#
include
"
GrRenderTargetContext
.
h
"
#
include
"
.
.
/
private
/
GrAuditTrail
.
h
"
#
include
"
.
.
/
private
/
SkShadowFlags
.
h
"
#
include
"
GrAppliedClip
.
h
"
#
include
"
GrBackendSemaphore
.
h
"
#
include
"
GrBlurUtils
.
h
"
#
include
"
GrCaps
.
h
"
#
include
"
GrColor
.
h
"
#
include
"
GrContextPriv
.
h
"
#
include
"
GrDrawingManager
.
h
"
#
include
"
GrFixedClip
.
h
"
#
include
"
GrGpuResourcePriv
.
h
"
#
include
"
GrMemoryPool
.
h
"
#
include
"
GrOpList
.
h
"
#
include
"
GrPathRenderer
.
h
"
#
include
"
GrQuad
.
h
"
#
include
"
GrRecordingContext
.
h
"
#
include
"
GrRecordingContextPriv
.
h
"
#
include
"
GrRenderTarget
.
h
"
#
include
"
GrRenderTargetContextPriv
.
h
"
#
include
"
GrResourceProvider
.
h
"
#
include
"
GrShape
.
h
"
#
include
"
GrStencilAttachment
.
h
"
#
include
"
GrStyle
.
h
"
#
include
"
GrTracing
.
h
"
#
include
"
SkDrawable
.
h
"
#
include
"
SkDrawShadowInfo
.
h
"
#
include
"
SkGlyphRunPainter
.
h
"
#
include
"
SkGr
.
h
"
#
include
"
SkLatticeIter
.
h
"
#
include
"
SkMatrixPriv
.
h
"
#
include
"
SkRRectPriv
.
h
"
#
include
"
SkShadowUtils
.
h
"
#
include
"
SkSurfacePriv
.
h
"
#
include
"
effects
/
GrRRectEffect
.
h
"
#
include
"
effects
/
GrTextureDomain
.
h
"
#
include
"
ops
/
GrAtlasTextOp
.
h
"
#
include
"
ops
/
GrClearOp
.
h
"
#
include
"
ops
/
GrClearStencilClipOp
.
h
"
#
include
"
ops
/
GrDebugMarkerOp
.
h
"
#
include
"
ops
/
GrDrawableOp
.
h
"
#
include
"
ops
/
GrDrawAtlasOp
.
h
"
#
include
"
ops
/
GrDrawOp
.
h
"
#
include
"
ops
/
GrDrawVerticesOp
.
h
"
#
include
"
ops
/
GrFillRectOp
.
h
"
#
include
"
ops
/
GrAAFillRRectOp
.
h
"
#
include
"
ops
/
GrLatticeOp
.
h
"
#
include
"
ops
/
GrOp
.
h
"
#
include
"
ops
/
GrOvalOpFactory
.
h
"
#
include
"
ops
/
GrRegionOp
.
h
"
#
include
"
ops
/
GrSemaphoreOp
.
h
"
#
include
"
ops
/
GrShadowRRectOp
.
h
"
#
include
"
ops
/
GrStencilPathOp
.
h
"
#
include
"
ops
/
GrStrokeRectOp
.
h
"
#
include
"
ops
/
GrTextureOp
.
h
"
#
include
"
text
/
GrTextContext
.
h
"
#
include
"
text
/
GrTextTarget
.
h
"
class
GrRenderTargetContext
:
:
TextTarget
:
public
GrTextTarget
{
public
:
TextTarget
(
GrRenderTargetContext
*
renderTargetContext
)
:
GrTextTarget
(
renderTargetContext
-
>
width
(
)
renderTargetContext
-
>
height
(
)
renderTargetContext
-
>
colorSpaceInfo
(
)
)
fRenderTargetContext
(
renderTargetContext
)
fGlyphPainter
{
*
renderTargetContext
}
{
}
void
addDrawOp
(
const
GrClip
&
clip
std
:
:
unique_ptr
<
GrAtlasTextOp
>
op
)
override
{
fRenderTargetContext
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
void
drawShape
(
const
GrClip
&
clip
const
SkPaint
&
paint
const
SkMatrix
&
viewMatrix
const
GrShape
&
shape
)
override
{
GrBlurUtils
:
:
drawShapeWithMaskFilter
(
fRenderTargetContext
-
>
fContext
fRenderTargetContext
clip
paint
viewMatrix
shape
)
;
}
void
makeGrPaint
(
GrMaskFormat
maskFormat
const
SkPaint
&
skPaint
const
SkMatrix
&
viewMatrix
GrPaint
*
grPaint
)
override
{
auto
context
=
fRenderTargetContext
-
>
fContext
;
const
GrColorSpaceInfo
&
colorSpaceInfo
=
fRenderTargetContext
-
>
colorSpaceInfo
(
)
;
if
(
kARGB_GrMaskFormat
=
=
maskFormat
)
{
SkPaintToGrPaintWithPrimitiveColor
(
context
colorSpaceInfo
skPaint
grPaint
)
;
}
else
{
SkPaintToGrPaint
(
context
colorSpaceInfo
skPaint
viewMatrix
grPaint
)
;
}
}
GrRecordingContext
*
getContext
(
)
override
{
return
fRenderTargetContext
-
>
fContext
;
}
SkGlyphRunListPainter
*
glyphPainter
(
)
override
{
return
&
fGlyphPainter
;
}
private
:
GrRenderTargetContext
*
fRenderTargetContext
;
SkGlyphRunListPainter
fGlyphPainter
;
}
;
#
define
ASSERT_OWNED_RESOURCE
(
R
)
SkASSERT
(
!
(
R
)
|
|
(
R
)
-
>
getContext
(
)
=
=
this
-
>
drawingManager
(
)
-
>
getContext
(
)
)
#
define
ASSERT_SINGLE_OWNER
\
SkDEBUGCODE
(
GrSingleOwner
:
:
AutoEnforce
debug_SingleOwner
(
this
-
>
singleOwner
(
)
)
;
)
#
define
ASSERT_SINGLE_OWNER_PRIV
\
SkDEBUGCODE
(
GrSingleOwner
:
:
AutoEnforce
debug_SingleOwner
(
fRenderTargetContext
-
>
singleOwner
(
)
)
;
)
#
define
RETURN_IF_ABANDONED
if
(
fContext
-
>
priv
(
)
.
abandoned
(
)
)
{
return
;
}
#
define
RETURN_IF_ABANDONED_PRIV
if
(
fRenderTargetContext
-
>
fContext
-
>
priv
(
)
.
abandoned
(
)
)
{
return
;
}
#
define
RETURN_FALSE_IF_ABANDONED
if
(
fContext
-
>
priv
(
)
.
abandoned
(
)
)
{
return
false
;
}
#
define
RETURN_FALSE_IF_ABANDONED_PRIV
if
(
fRenderTargetContext
-
>
fContext
-
>
priv
(
)
.
abandoned
(
)
)
{
return
false
;
}
#
define
RETURN_NULL_IF_ABANDONED
if
(
fContext
-
>
priv
(
)
.
abandoned
(
)
)
{
return
nullptr
;
}
GrAAType
GrChooseAAType
(
GrAA
aa
GrFSAAType
fsaaType
GrAllowMixedSamples
allowMixedSamples
const
GrCaps
&
caps
)
{
if
(
GrAA
:
:
kNo
=
=
aa
)
{
if
(
fsaaType
=
=
GrFSAAType
:
:
kUnifiedMSAA
&
&
!
caps
.
multisampleDisableSupport
(
)
)
{
return
GrAAType
:
:
kMSAA
;
}
return
GrAAType
:
:
kNone
;
}
switch
(
fsaaType
)
{
case
GrFSAAType
:
:
kNone
:
return
GrAAType
:
:
kCoverage
;
case
GrFSAAType
:
:
kUnifiedMSAA
:
return
GrAAType
:
:
kMSAA
;
case
GrFSAAType
:
:
kMixedSamples
:
return
GrAllowMixedSamples
:
:
kYes
=
=
allowMixedSamples
?
GrAAType
:
:
kMixedSamples
:
GrAAType
:
:
kCoverage
;
}
SK_ABORT
(
"
Unexpected
fsaa
type
"
)
;
return
GrAAType
:
:
kNone
;
}
class
AutoCheckFlush
{
public
:
AutoCheckFlush
(
GrDrawingManager
*
drawingManager
)
:
fDrawingManager
(
drawingManager
)
{
SkASSERT
(
fDrawingManager
)
;
}
~
AutoCheckFlush
(
)
{
fDrawingManager
-
>
flushIfNecessary
(
)
;
}
private
:
GrDrawingManager
*
fDrawingManager
;
}
;
GrRenderTargetContext
:
:
GrRenderTargetContext
(
GrRecordingContext
*
context
sk_sp
<
GrRenderTargetProxy
>
rtp
sk_sp
<
SkColorSpace
>
colorSpace
const
SkSurfaceProps
*
surfaceProps
bool
managedOpList
)
:
GrSurfaceContext
(
context
rtp
-
>
config
(
)
std
:
:
move
(
colorSpace
)
)
fRenderTargetProxy
(
std
:
:
move
(
rtp
)
)
fOpList
(
sk_ref_sp
(
fRenderTargetProxy
-
>
getLastRenderTargetOpList
(
)
)
)
fSurfaceProps
(
SkSurfacePropsCopyOrDefault
(
surfaceProps
)
)
fManagedOpList
(
managedOpList
)
{
if
(
!
context
-
>
priv
(
)
.
explicitlyAllocateGPUResources
(
)
)
{
this
-
>
getRTOpList
(
)
;
}
fTextTarget
.
reset
(
new
TextTarget
(
this
)
)
;
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
#
ifdef
SK_DEBUG
void
GrRenderTargetContext
:
:
validate
(
)
const
{
SkASSERT
(
fRenderTargetProxy
)
;
fRenderTargetProxy
-
>
validate
(
fContext
)
;
if
(
fOpList
&
&
!
fOpList
-
>
isClosed
(
)
)
{
SkASSERT
(
fRenderTargetProxy
-
>
getLastOpList
(
)
=
=
fOpList
.
get
(
)
)
;
}
}
#
endif
GrRenderTargetContext
:
:
~
GrRenderTargetContext
(
)
{
ASSERT_SINGLE_OWNER
}
GrTextureProxy
*
GrRenderTargetContext
:
:
asTextureProxy
(
)
{
return
fRenderTargetProxy
-
>
asTextureProxy
(
)
;
}
const
GrTextureProxy
*
GrRenderTargetContext
:
:
asTextureProxy
(
)
const
{
return
fRenderTargetProxy
-
>
asTextureProxy
(
)
;
}
sk_sp
<
GrTextureProxy
>
GrRenderTargetContext
:
:
asTextureProxyRef
(
)
{
return
sk_ref_sp
(
fRenderTargetProxy
-
>
asTextureProxy
(
)
)
;
}
GrMipMapped
GrRenderTargetContext
:
:
mipMapped
(
)
const
{
if
(
const
GrTextureProxy
*
proxy
=
this
-
>
asTextureProxy
(
)
)
{
return
proxy
-
>
mipMapped
(
)
;
}
return
GrMipMapped
:
:
kNo
;
}
GrRenderTargetOpList
*
GrRenderTargetContext
:
:
getRTOpList
(
)
{
ASSERT_SINGLE_OWNER
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
if
(
!
fOpList
|
|
fOpList
-
>
isClosed
(
)
)
{
fOpList
=
this
-
>
drawingManager
(
)
-
>
newRTOpList
(
fRenderTargetProxy
.
get
(
)
fManagedOpList
)
;
}
return
fOpList
.
get
(
)
;
}
GrOpList
*
GrRenderTargetContext
:
:
getOpList
(
)
{
return
this
-
>
getRTOpList
(
)
;
}
void
GrRenderTargetContext
:
:
drawGlyphRunList
(
const
GrClip
&
clip
const
SkMatrix
&
viewMatrix
const
SkGlyphRunList
&
blob
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawGlyphRunList
"
fContext
)
;
if
(
this
-
>
wrapsVkSecondaryCB
(
)
)
{
return
;
}
GrTextContext
*
atlasTextContext
=
this
-
>
drawingManager
(
)
-
>
getTextContext
(
)
;
atlasTextContext
-
>
drawGlyphRunList
(
fContext
fTextTarget
.
get
(
)
clip
viewMatrix
fSurfaceProps
blob
)
;
}
void
GrRenderTargetContext
:
:
discard
(
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
discard
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
this
-
>
getRTOpList
(
)
-
>
discard
(
)
;
}
void
GrRenderTargetContext
:
:
clear
(
const
SkIRect
*
rect
const
SkPMColor4f
&
color
CanClearFullscreen
canClearFullscreen
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
clear
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
this
-
>
internalClear
(
rect
?
GrFixedClip
(
*
rect
)
:
GrFixedClip
:
:
Disabled
(
)
color
canClearFullscreen
)
;
}
void
GrRenderTargetContextPriv
:
:
clear
(
const
GrFixedClip
&
clip
const
SkPMColor4f
&
color
CanClearFullscreen
canClearFullscreen
)
{
ASSERT_SINGLE_OWNER_PRIV
RETURN_IF_ABANDONED_PRIV
SkDEBUGCODE
(
fRenderTargetContext
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContextPriv
"
"
clear
"
fRenderTargetContext
-
>
fContext
)
;
AutoCheckFlush
acf
(
fRenderTargetContext
-
>
drawingManager
(
)
)
;
fRenderTargetContext
-
>
internalClear
(
clip
color
canClearFullscreen
)
;
}
static
void
clear_to_grpaint
(
const
SkPMColor4f
&
color
GrPaint
*
paint
)
{
paint
-
>
setColor4f
(
color
)
;
if
(
color
.
isOpaque
(
)
)
{
paint
-
>
setPorterDuffXPFactory
(
SkBlendMode
:
:
kSrcOver
)
;
}
else
{
paint
-
>
setPorterDuffXPFactory
(
SkBlendMode
:
:
kSrc
)
;
}
}
void
GrRenderTargetContext
:
:
internalClear
(
const
GrFixedClip
&
clip
const
SkPMColor4f
&
color
CanClearFullscreen
canClearFullscreen
)
{
bool
isFull
=
false
;
if
(
!
clip
.
hasWindowRectangles
(
)
)
{
isFull
=
!
clip
.
scissorEnabled
(
)
|
|
(
CanClearFullscreen
:
:
kYes
=
=
canClearFullscreen
&
&
this
-
>
caps
(
)
-
>
preferFullscreenClears
(
)
)
|
|
clip
.
scissorRect
(
)
.
contains
(
SkIRect
:
:
MakeWH
(
this
-
>
width
(
)
this
-
>
height
(
)
)
)
;
}
if
(
isFull
)
{
if
(
this
-
>
getRTOpList
(
)
-
>
resetForFullscreenClear
(
)
&
&
!
this
-
>
caps
(
)
-
>
performColorClearsAsDraws
(
)
)
{
this
-
>
getRTOpList
(
)
-
>
setColorLoadOp
(
GrLoadOp
:
:
kClear
color
)
;
return
;
}
else
{
this
-
>
getRTOpList
(
)
-
>
setColorLoadOp
(
GrLoadOp
:
:
kDiscard
)
;
}
if
(
this
-
>
caps
(
)
-
>
performColorClearsAsDraws
(
)
)
{
SkRect
rtRect
=
SkRect
:
:
MakeWH
(
this
-
>
width
(
)
this
-
>
height
(
)
)
;
GrPaint
paint
;
clear_to_grpaint
(
color
&
paint
)
;
this
-
>
addDrawOp
(
GrFixedClip
:
:
Disabled
(
)
GrFillRectOp
:
:
Make
(
fContext
std
:
:
move
(
paint
)
GrAAType
:
:
kNone
SkMatrix
:
:
I
(
)
rtRect
)
)
;
}
else
{
this
-
>
getRTOpList
(
)
-
>
addOp
(
GrClearOp
:
:
Make
(
fContext
SkIRect
:
:
MakeEmpty
(
)
color
true
)
*
this
-
>
caps
(
)
)
;
}
}
else
{
if
(
this
-
>
caps
(
)
-
>
performPartialClearsAsDraws
(
)
)
{
SkRect
scissor
=
SkRect
:
:
Make
(
clip
.
scissorRect
(
)
)
;
GrPaint
paint
;
clear_to_grpaint
(
color
&
paint
)
;
this
-
>
addDrawOp
(
clip
GrFillRectOp
:
:
Make
(
fContext
std
:
:
move
(
paint
)
GrAAType
:
:
kNone
SkMatrix
:
:
I
(
)
scissor
)
)
;
}
else
{
std
:
:
unique_ptr
<
GrOp
>
op
(
GrClearOp
:
:
Make
(
fContext
clip
color
this
-
>
asSurfaceProxy
(
)
)
)
;
if
(
!
op
)
{
return
;
}
this
-
>
getRTOpList
(
)
-
>
addOp
(
std
:
:
move
(
op
)
*
this
-
>
caps
(
)
)
;
}
}
}
void
GrRenderTargetContextPriv
:
:
absClear
(
const
SkIRect
*
clearRect
const
SkPMColor4f
&
color
)
{
ASSERT_SINGLE_OWNER_PRIV
RETURN_IF_ABANDONED_PRIV
SkDEBUGCODE
(
fRenderTargetContext
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContextPriv
"
"
absClear
"
fRenderTargetContext
-
>
fContext
)
;
AutoCheckFlush
acf
(
fRenderTargetContext
-
>
drawingManager
(
)
)
;
SkIRect
rtRect
=
SkIRect
:
:
MakeWH
(
fRenderTargetContext
-
>
fRenderTargetProxy
-
>
worstCaseWidth
(
)
fRenderTargetContext
-
>
fRenderTargetProxy
-
>
worstCaseHeight
(
)
)
;
if
(
clearRect
)
{
if
(
clearRect
-
>
contains
(
rtRect
)
)
{
clearRect
=
nullptr
;
}
else
{
if
(
!
rtRect
.
intersect
(
*
clearRect
)
)
{
return
;
}
}
}
if
(
clearRect
)
{
if
(
fRenderTargetContext
-
>
caps
(
)
-
>
performPartialClearsAsDraws
(
)
)
{
GrPaint
paint
;
clear_to_grpaint
(
color
&
paint
)
;
fRenderTargetContext
-
>
addDrawOp
(
GrFixedClip
:
:
Disabled
(
)
GrFillRectOp
:
:
Make
(
fRenderTargetContext
-
>
fContext
std
:
:
move
(
paint
)
GrAAType
:
:
kNone
SkMatrix
:
:
I
(
)
SkRect
:
:
Make
(
rtRect
)
)
)
;
}
else
{
fRenderTargetContext
-
>
getRTOpList
(
)
-
>
addOp
(
GrClearOp
:
:
Make
(
fRenderTargetContext
-
>
fContext
rtRect
color
false
)
*
fRenderTargetContext
-
>
caps
(
)
)
;
}
}
else
{
fRenderTargetContext
-
>
getRTOpList
(
)
-
>
resetForFullscreenClear
(
)
;
fRenderTargetContext
-
>
getRTOpList
(
)
-
>
setColorLoadOp
(
GrLoadOp
:
:
kDiscard
)
;
if
(
fRenderTargetContext
-
>
caps
(
)
-
>
performColorClearsAsDraws
(
)
)
{
GrPaint
paint
;
clear_to_grpaint
(
color
&
paint
)
;
fRenderTargetContext
-
>
addDrawOp
(
GrFixedClip
:
:
Disabled
(
)
GrFillRectOp
:
:
Make
(
fRenderTargetContext
-
>
fContext
std
:
:
move
(
paint
)
GrAAType
:
:
kNone
SkMatrix
:
:
I
(
)
SkRect
:
:
Make
(
rtRect
)
)
)
;
}
else
{
fRenderTargetContext
-
>
getRTOpList
(
)
-
>
addOp
(
GrClearOp
:
:
Make
(
fRenderTargetContext
-
>
fContext
SkIRect
:
:
MakeEmpty
(
)
color
true
)
*
fRenderTargetContext
-
>
caps
(
)
)
;
}
}
}
void
GrRenderTargetContext
:
:
drawPaint
(
const
GrClip
&
clip
GrPaint
&
&
paint
const
SkMatrix
&
viewMatrix
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawPaint
"
fContext
)
;
SkRect
r
=
fRenderTargetProxy
-
>
getBoundsRect
(
)
;
if
(
!
paint
.
numTotalFragmentProcessors
(
)
)
{
SkRRect
rrect
;
GrAA
aa
=
GrAA
:
:
kNo
;
if
(
clip
.
isRRect
(
r
&
rrect
&
aa
)
)
{
if
(
rrect
.
isRect
(
)
)
{
this
-
>
drawFilledRect
(
GrNoClip
(
)
std
:
:
move
(
paint
)
aa
SkMatrix
:
:
I
(
)
rrect
.
rect
(
)
)
;
}
else
{
this
-
>
drawRRect
(
GrNoClip
(
)
std
:
:
move
(
paint
)
aa
SkMatrix
:
:
I
(
)
rrect
GrStyle
:
:
SimpleFill
(
)
)
;
}
}
else
{
this
-
>
drawFilledRect
(
clip
std
:
:
move
(
paint
)
aa
SkMatrix
:
:
I
(
)
r
)
;
}
return
;
}
SkMatrix
localMatrix
;
if
(
!
viewMatrix
.
invert
(
&
localMatrix
)
)
{
return
;
}
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
std
:
:
unique_ptr
<
GrDrawOp
>
op
=
GrFillRectOp
:
:
MakeWithLocalMatrix
(
fContext
std
:
:
move
(
paint
)
GrAAType
:
:
kNone
SkMatrix
:
:
I
(
)
localMatrix
r
)
;
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
static
inline
bool
rect_contains_inclusive
(
const
SkRect
&
rect
const
SkPoint
&
point
)
{
return
point
.
fX
>
=
rect
.
fLeft
&
&
point
.
fX
<
=
rect
.
fRight
&
&
point
.
fY
>
=
rect
.
fTop
&
&
point
.
fY
<
=
rect
.
fBottom
;
}
static
bool
crop_filled_rect
(
int
width
int
height
const
GrClip
&
clip
const
SkMatrix
&
viewMatrix
SkRect
*
rect
SkRect
*
localRect
=
nullptr
)
{
if
(
!
viewMatrix
.
rectStaysRect
(
)
)
{
return
true
;
}
SkIRect
clipDevBounds
;
SkRect
clipBounds
;
clip
.
getConservativeBounds
(
width
height
&
clipDevBounds
)
;
if
(
!
SkMatrixPriv
:
:
InverseMapRect
(
viewMatrix
&
clipBounds
SkRect
:
:
Make
(
clipDevBounds
)
)
)
{
return
false
;
}
if
(
localRect
)
{
if
(
!
rect
-
>
intersects
(
clipBounds
)
)
{
return
false
;
}
const
SkScalar
dx
=
localRect
-
>
width
(
)
/
rect
-
>
width
(
)
;
const
SkScalar
dy
=
localRect
-
>
height
(
)
/
rect
-
>
height
(
)
;
if
(
clipBounds
.
fLeft
>
rect
-
>
fLeft
)
{
localRect
-
>
fLeft
+
=
(
clipBounds
.
fLeft
-
rect
-
>
fLeft
)
*
dx
;
rect
-
>
fLeft
=
clipBounds
.
fLeft
;
}
if
(
clipBounds
.
fTop
>
rect
-
>
fTop
)
{
localRect
-
>
fTop
+
=
(
clipBounds
.
fTop
-
rect
-
>
fTop
)
*
dy
;
rect
-
>
fTop
=
clipBounds
.
fTop
;
}
if
(
clipBounds
.
fRight
<
rect
-
>
fRight
)
{
localRect
-
>
fRight
-
=
(
rect
-
>
fRight
-
clipBounds
.
fRight
)
*
dx
;
rect
-
>
fRight
=
clipBounds
.
fRight
;
}
if
(
clipBounds
.
fBottom
<
rect
-
>
fBottom
)
{
localRect
-
>
fBottom
-
=
(
rect
-
>
fBottom
-
clipBounds
.
fBottom
)
*
dy
;
rect
-
>
fBottom
=
clipBounds
.
fBottom
;
}
return
true
;
}
return
rect
-
>
intersect
(
clipBounds
)
;
}
bool
GrRenderTargetContext
:
:
drawFilledRectAsClear
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRect
&
rect
)
{
SkPMColor4f
clearColor
;
if
(
paint
.
numCoverageFragmentProcessors
(
)
>
0
|
|
!
paint
.
isConstantBlendedColor
(
&
clearColor
)
)
{
return
false
;
}
const
SkRect
rtRect
=
fRenderTargetProxy
-
>
getBoundsRect
(
)
;
SkRect
combinedRect
=
rtRect
;
SkRRect
clipRRect
;
GrAA
clipAA
;
if
(
!
clip
.
quickContains
(
rtRect
)
)
{
if
(
!
clip
.
isRRect
(
rtRect
&
clipRRect
&
clipAA
)
|
|
!
clipRRect
.
isRect
(
)
)
{
return
false
;
}
combinedRect
=
clipRRect
.
rect
(
)
;
}
else
{
clipAA
=
GrAA
:
:
kNo
;
}
if
(
viewMatrix
.
rectStaysRect
(
)
)
{
if
(
!
combinedRect
.
intersect
(
viewMatrix
.
mapRect
(
rect
)
)
)
{
return
true
;
}
}
else
{
SkMatrix
invM
;
if
(
!
viewMatrix
.
invert
(
&
invM
)
)
{
return
false
;
}
GrQuad
quad
=
GrQuad
:
:
MakeFromRect
(
rtRect
invM
)
;
if
(
!
rect_contains_inclusive
(
rect
quad
.
point
(
0
)
)
|
|
!
rect_contains_inclusive
(
rect
quad
.
point
(
1
)
)
|
|
!
rect_contains_inclusive
(
rect
quad
.
point
(
2
)
)
|
|
!
rect_contains_inclusive
(
rect
quad
.
point
(
3
)
)
)
{
return
false
;
}
}
if
(
combinedRect
.
contains
(
rtRect
)
)
{
this
-
>
clear
(
nullptr
clearColor
CanClearFullscreen
:
:
kYes
)
;
return
true
;
}
else
if
(
GrClip
:
:
IsPixelAligned
(
combinedRect
)
&
&
combinedRect
.
width
(
)
>
256
&
&
combinedRect
.
height
(
)
>
256
)
{
SkIRect
scissorRect
;
combinedRect
.
round
(
&
scissorRect
)
;
this
-
>
clear
(
&
scissorRect
clearColor
CanClearFullscreen
:
:
kNo
)
;
return
true
;
}
if
(
clipAA
=
=
GrAA
:
:
kYes
)
{
aa
=
GrAA
:
:
kYes
;
}
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
GrAllowMixedSamples
:
:
kNo
)
;
this
-
>
addDrawOp
(
GrFixedClip
:
:
Disabled
(
)
GrFillRectOp
:
:
Make
(
fContext
std
:
:
move
(
paint
)
aaType
SkMatrix
:
:
I
(
)
combinedRect
)
)
;
return
true
;
}
void
GrRenderTargetContext
:
:
drawFilledRect
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRect
&
rect
const
GrUserStencilSettings
*
ss
)
{
if
(
!
ss
)
{
if
(
this
-
>
drawFilledRectAsClear
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
rect
)
)
{
return
;
}
assert_alive
(
paint
)
;
}
SkRect
croppedRect
=
rect
;
if
(
!
crop_filled_rect
(
this
-
>
width
(
)
this
-
>
height
(
)
clip
viewMatrix
&
croppedRect
)
)
{
return
;
}
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
GrAllowMixedSamples
:
:
kNo
)
;
this
-
>
addDrawOp
(
clip
GrFillRectOp
:
:
Make
(
fContext
std
:
:
move
(
paint
)
aaType
viewMatrix
croppedRect
ss
)
)
;
}
void
GrRenderTargetContext
:
:
drawRect
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRect
&
rect
const
GrStyle
*
style
)
{
if
(
!
style
)
{
style
=
&
GrStyle
:
:
SimpleFill
(
)
;
}
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawRect
"
fContext
)
;
SkASSERT
(
!
style
-
>
pathEffect
(
)
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
const
SkStrokeRec
&
stroke
=
style
-
>
strokeRec
(
)
;
if
(
stroke
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kFill_Style
)
{
this
-
>
drawFilledRect
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
rect
)
;
return
;
}
else
if
(
stroke
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kStroke_Style
|
|
stroke
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kHairline_Style
)
{
if
(
(
!
rect
.
width
(
)
|
|
!
rect
.
height
(
)
)
&
&
SkStrokeRec
:
:
kHairline_Style
!
=
stroke
.
getStyle
(
)
)
{
SkScalar
r
=
stroke
.
getWidth
(
)
/
2
;
switch
(
stroke
.
getJoin
(
)
)
{
case
SkPaint
:
:
kMiter_Join
:
this
-
>
drawRect
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
{
rect
.
fLeft
-
r
rect
.
fTop
-
r
rect
.
fRight
+
r
rect
.
fBottom
+
r
}
&
GrStyle
:
:
SimpleFill
(
)
)
;
return
;
case
SkPaint
:
:
kRound_Join
:
if
(
rect
.
width
(
)
|
|
rect
.
height
(
)
)
{
SkRRect
rrect
=
SkRRect
:
:
MakeRectXY
(
rect
.
makeOutset
(
r
r
)
r
r
)
;
this
-
>
drawRRect
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
rrect
GrStyle
:
:
SimpleFill
(
)
)
;
return
;
}
case
SkPaint
:
:
kBevel_Join
:
if
(
!
rect
.
width
(
)
)
{
this
-
>
drawRect
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
{
rect
.
fLeft
-
r
rect
.
fTop
rect
.
fRight
+
r
rect
.
fBottom
}
&
GrStyle
:
:
SimpleFill
(
)
)
;
}
else
{
this
-
>
drawRect
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
{
rect
.
fLeft
rect
.
fTop
-
r
rect
.
fRight
rect
.
fBottom
+
r
}
&
GrStyle
:
:
SimpleFill
(
)
)
;
}
return
;
}
}
std
:
:
unique_ptr
<
GrDrawOp
>
op
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
GrAllowMixedSamples
:
:
kNo
)
;
op
=
GrStrokeRectOp
:
:
Make
(
fContext
std
:
:
move
(
paint
)
aaType
viewMatrix
rect
stroke
)
;
if
(
op
)
{
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
return
;
}
}
assert_alive
(
paint
)
;
this
-
>
drawShapeUsingPathRenderer
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
GrShape
(
rect
*
style
)
)
;
}
void
GrRenderTargetContext
:
:
drawQuadSet
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
QuadSetEntry
quads
[
]
int
cnt
)
{
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
GrAllowMixedSamples
:
:
kNo
)
;
this
-
>
addDrawOp
(
clip
GrFillRectOp
:
:
MakeSet
(
fContext
std
:
:
move
(
paint
)
aaType
viewMatrix
quads
cnt
)
)
;
}
int
GrRenderTargetContextPriv
:
:
maxWindowRectangles
(
)
const
{
return
fRenderTargetContext
-
>
fRenderTargetProxy
-
>
maxWindowRectangles
(
*
fRenderTargetContext
-
>
caps
(
)
)
;
}
void
GrRenderTargetContextPriv
:
:
clearStencilClip
(
const
GrFixedClip
&
clip
bool
insideStencilMask
)
{
ASSERT_SINGLE_OWNER_PRIV
RETURN_IF_ABANDONED_PRIV
SkDEBUGCODE
(
fRenderTargetContext
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContextPriv
"
"
clearStencilClip
"
fRenderTargetContext
-
>
fContext
)
;
AutoCheckFlush
acf
(
fRenderTargetContext
-
>
drawingManager
(
)
)
;
fRenderTargetContext
-
>
internalStencilClear
(
clip
insideStencilMask
)
;
}
void
GrRenderTargetContext
:
:
internalStencilClear
(
const
GrFixedClip
&
clip
bool
insideStencilMask
)
{
if
(
this
-
>
caps
(
)
-
>
performStencilClearsAsDraws
(
)
)
{
const
GrUserStencilSettings
*
ss
=
GrStencilSettings
:
:
SetClipBitSettings
(
insideStencilMask
)
;
SkRect
rtRect
=
SkRect
:
:
MakeWH
(
this
-
>
width
(
)
this
-
>
height
(
)
)
;
GrPaint
paint
;
paint
.
setColor4f
(
{
0
.
f
0
.
f
0
.
f
0
.
f
}
)
;
paint
.
setPorterDuffXPFactory
(
SkBlendMode
:
:
kSrcOver
)
;
this
-
>
setNeedsStencil
(
)
;
this
-
>
addDrawOp
(
clip
GrFillRectOp
:
:
Make
(
fContext
std
:
:
move
(
paint
)
GrAAType
:
:
kNone
SkMatrix
:
:
I
(
)
rtRect
ss
)
)
;
}
else
{
std
:
:
unique_ptr
<
GrOp
>
op
(
GrClearStencilClipOp
:
:
Make
(
fContext
clip
insideStencilMask
fRenderTargetProxy
.
get
(
)
)
)
;
if
(
!
op
)
{
return
;
}
this
-
>
getRTOpList
(
)
-
>
addOp
(
std
:
:
move
(
op
)
*
this
-
>
caps
(
)
)
;
}
}
void
GrRenderTargetContextPriv
:
:
stencilPath
(
const
GrHardClip
&
clip
GrAAType
aaType
const
SkMatrix
&
viewMatrix
const
GrPath
*
path
)
{
ASSERT_SINGLE_OWNER_PRIV
RETURN_IF_ABANDONED_PRIV
SkDEBUGCODE
(
fRenderTargetContext
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContextPriv
"
"
stencilPath
"
fRenderTargetContext
-
>
fContext
)
;
SkASSERT
(
aaType
!
=
GrAAType
:
:
kCoverage
)
;
bool
useHWAA
=
GrAATypeIsHW
(
aaType
)
;
SkASSERT
(
path
)
;
SkASSERT
(
fRenderTargetContext
-
>
caps
(
)
-
>
shaderCaps
(
)
-
>
pathRenderingSupport
(
)
)
;
SkRect
bounds
=
SkRect
:
:
MakeIWH
(
fRenderTargetContext
-
>
width
(
)
fRenderTargetContext
-
>
height
(
)
)
;
GrAppliedHardClip
appliedClip
;
if
(
!
clip
.
apply
(
fRenderTargetContext
-
>
width
(
)
fRenderTargetContext
-
>
height
(
)
&
appliedClip
&
bounds
)
)
{
return
;
}
fRenderTargetContext
-
>
setNeedsStencil
(
)
;
std
:
:
unique_ptr
<
GrOp
>
op
=
GrStencilPathOp
:
:
Make
(
fRenderTargetContext
-
>
fContext
viewMatrix
useHWAA
path
-
>
getFillType
(
)
appliedClip
.
hasStencilClip
(
)
appliedClip
.
scissorState
(
)
path
)
;
if
(
!
op
)
{
return
;
}
op
-
>
setClippedBounds
(
bounds
)
;
fRenderTargetContext
-
>
getRTOpList
(
)
-
>
addOp
(
std
:
:
move
(
op
)
*
fRenderTargetContext
-
>
caps
(
)
)
;
}
void
GrRenderTargetContextPriv
:
:
stencilRect
(
const
GrHardClip
&
clip
const
GrUserStencilSettings
*
ss
GrAAType
aaType
const
SkMatrix
&
viewMatrix
const
SkRect
&
rect
)
{
ASSERT_SINGLE_OWNER_PRIV
RETURN_IF_ABANDONED_PRIV
SkDEBUGCODE
(
fRenderTargetContext
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContextPriv
"
"
stencilRect
"
fRenderTargetContext
-
>
fContext
)
;
SkASSERT
(
GrAAType
:
:
kCoverage
!
=
aaType
)
;
AutoCheckFlush
acf
(
fRenderTargetContext
-
>
drawingManager
(
)
)
;
GrPaint
paint
;
paint
.
setXPFactory
(
GrDisableColorXPFactory
:
:
Get
(
)
)
;
std
:
:
unique_ptr
<
GrDrawOp
>
op
=
GrFillRectOp
:
:
Make
(
fRenderTargetContext
-
>
fContext
std
:
:
move
(
paint
)
aaType
viewMatrix
rect
ss
)
;
fRenderTargetContext
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
bool
GrRenderTargetContextPriv
:
:
drawAndStencilRect
(
const
GrHardClip
&
clip
const
GrUserStencilSettings
*
ss
SkRegion
:
:
Op
op
bool
invert
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRect
&
rect
)
{
ASSERT_SINGLE_OWNER_PRIV
RETURN_FALSE_IF_ABANDONED_PRIV
SkDEBUGCODE
(
fRenderTargetContext
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContextPriv
"
"
drawAndStencilRect
"
fRenderTargetContext
-
>
fContext
)
;
AutoCheckFlush
acf
(
fRenderTargetContext
-
>
drawingManager
(
)
)
;
GrPaint
paint
;
paint
.
setCoverageSetOpXPFactory
(
op
invert
)
;
fRenderTargetContext
-
>
drawFilledRect
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
rect
ss
)
;
return
true
;
}
void
GrRenderTargetContext
:
:
fillRectWithEdgeAA
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
GrQuadAAFlags
edgeAA
const
SkMatrix
&
viewMatrix
const
SkRect
&
rect
const
SkRect
*
localRect
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
fillRectWithEdgeAA
"
fContext
)
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
GrAllowMixedSamples
:
:
kNo
)
;
std
:
:
unique_ptr
<
GrDrawOp
>
op
;
if
(
localRect
)
{
SkRect
croppedRect
=
rect
;
SkRect
croppedLocalRect
=
*
localRect
;
if
(
!
crop_filled_rect
(
this
-
>
width
(
)
this
-
>
height
(
)
clip
viewMatrix
&
croppedRect
&
croppedLocalRect
)
)
{
return
;
}
op
=
GrFillRectOp
:
:
MakePerEdgeWithLocalRect
(
fContext
std
:
:
move
(
paint
)
aaType
edgeAA
viewMatrix
croppedRect
croppedLocalRect
)
;
}
else
{
if
(
aaType
!
=
GrAAType
:
:
kMSAA
&
&
(
edgeAA
=
=
GrQuadAAFlags
:
:
kNone
|
|
edgeAA
=
=
GrQuadAAFlags
:
:
kAll
)
)
{
this
-
>
drawFilledRect
(
clip
std
:
:
move
(
paint
)
GrAA
(
edgeAA
=
=
GrQuadAAFlags
:
:
kAll
)
viewMatrix
rect
)
;
return
;
}
SkRect
croppedRect
=
rect
;
if
(
!
crop_filled_rect
(
this
-
>
width
(
)
this
-
>
height
(
)
clip
viewMatrix
&
croppedRect
)
)
{
return
;
}
op
=
GrFillRectOp
:
:
MakePerEdge
(
fContext
std
:
:
move
(
paint
)
aaType
edgeAA
viewMatrix
croppedRect
)
;
}
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
void
GrRenderTargetContext
:
:
fillQuadWithEdgeAA
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
GrQuadAAFlags
edgeAA
const
SkMatrix
&
viewMatrix
const
SkPoint
quad
[
4
]
const
SkPoint
localQuad
[
4
]
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
fillQuadWithEdgeAA
"
fContext
)
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
GrAllowMixedSamples
:
:
kNo
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
this
-
>
addDrawOp
(
clip
GrFillRectOp
:
:
MakePerEdgeQuad
(
fContext
std
:
:
move
(
paint
)
aaType
edgeAA
viewMatrix
quad
localQuad
)
)
;
}
static
void
draw_texture_to_grpaint
(
sk_sp
<
GrTextureProxy
>
proxy
const
SkRect
*
domain
GrSamplerState
:
:
Filter
filter
SkBlendMode
mode
const
SkPMColor4f
&
color
sk_sp
<
GrColorSpaceXform
>
csXform
GrPaint
*
paint
)
{
paint
-
>
setColor4f
(
color
)
;
paint
-
>
setXPFactory
(
SkBlendMode_AsXPFactory
(
mode
)
)
;
std
:
:
unique_ptr
<
GrFragmentProcessor
>
fp
;
if
(
domain
)
{
SkRect
correctedDomain
=
*
domain
;
if
(
filter
=
=
GrSamplerState
:
:
Filter
:
:
kBilerp
)
{
correctedDomain
.
inset
(
0
.
5f
0
.
5f
)
;
}
fp
=
GrTextureDomainEffect
:
:
Make
(
std
:
:
move
(
proxy
)
SkMatrix
:
:
I
(
)
correctedDomain
GrTextureDomain
:
:
kClamp_Mode
filter
)
;
}
else
{
fp
=
GrSimpleTextureEffect
:
:
Make
(
std
:
:
move
(
proxy
)
SkMatrix
:
:
I
(
)
filter
)
;
}
fp
=
GrColorSpaceXformEffect
:
:
Make
(
std
:
:
move
(
fp
)
csXform
)
;
paint
-
>
addColorFragmentProcessor
(
std
:
:
move
(
fp
)
)
;
}
void
GrRenderTargetContext
:
:
drawTexture
(
const
GrClip
&
clip
sk_sp
<
GrTextureProxy
>
proxy
GrSamplerState
:
:
Filter
filter
SkBlendMode
mode
const
SkPMColor4f
&
color
const
SkRect
&
srcRect
const
SkRect
&
dstRect
GrAA
aa
GrQuadAAFlags
aaFlags
SkCanvas
:
:
SrcRectConstraint
constraint
const
SkMatrix
&
viewMatrix
sk_sp
<
GrColorSpaceXform
>
textureColorSpaceXform
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawTexture
"
fContext
)
;
if
(
constraint
=
=
SkCanvas
:
:
kStrict_SrcRectConstraint
&
&
srcRect
.
contains
(
proxy
-
>
getWorstCaseBoundsRect
(
)
)
)
{
constraint
=
SkCanvas
:
:
kFast_SrcRectConstraint
;
}
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
GrAllowMixedSamples
:
:
kNo
)
;
SkRect
clippedDstRect
=
dstRect
;
SkRect
clippedSrcRect
=
srcRect
;
if
(
!
crop_filled_rect
(
this
-
>
width
(
)
this
-
>
height
(
)
clip
viewMatrix
&
clippedDstRect
&
clippedSrcRect
)
)
{
return
;
}
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
std
:
:
unique_ptr
<
GrDrawOp
>
op
;
if
(
mode
!
=
SkBlendMode
:
:
kSrcOver
)
{
if
(
filter
!
=
GrSamplerState
:
:
Filter
:
:
kNearest
&
&
!
GrTextureOp
:
:
GetFilterHasEffect
(
viewMatrix
clippedSrcRect
clippedDstRect
)
)
{
filter
=
GrSamplerState
:
:
Filter
:
:
kNearest
;
}
GrPaint
paint
;
draw_texture_to_grpaint
(
std
:
:
move
(
proxy
)
constraint
=
=
SkCanvas
:
:
kStrict_SrcRectConstraint
?
&
srcRect
:
nullptr
filter
mode
color
std
:
:
move
(
textureColorSpaceXform
)
&
paint
)
;
op
=
GrFillRectOp
:
:
MakePerEdgeWithLocalRect
(
fContext
std
:
:
move
(
paint
)
aaType
aaFlags
viewMatrix
clippedDstRect
clippedSrcRect
)
;
}
else
{
op
=
GrTextureOp
:
:
Make
(
fContext
std
:
:
move
(
proxy
)
filter
color
clippedSrcRect
clippedDstRect
aaType
aaFlags
constraint
viewMatrix
std
:
:
move
(
textureColorSpaceXform
)
)
;
}
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
void
GrRenderTargetContext
:
:
drawTextureQuad
(
const
GrClip
&
clip
sk_sp
<
GrTextureProxy
>
proxy
GrSamplerState
:
:
Filter
filter
SkBlendMode
mode
const
SkPMColor4f
&
color
const
SkPoint
srcQuad
[
4
]
const
SkPoint
dstQuad
[
4
]
GrAA
aa
GrQuadAAFlags
aaFlags
const
SkRect
*
domain
const
SkMatrix
&
viewMatrix
sk_sp
<
GrColorSpaceXform
>
texXform
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawTextureQuad
"
fContext
)
;
if
(
domain
&
&
domain
-
>
contains
(
proxy
-
>
getWorstCaseBoundsRect
(
)
)
)
{
domain
=
nullptr
;
}
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
GrAllowMixedSamples
:
:
kNo
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
std
:
:
unique_ptr
<
GrDrawOp
>
op
;
if
(
mode
!
=
SkBlendMode
:
:
kSrcOver
)
{
GrPaint
paint
;
draw_texture_to_grpaint
(
std
:
:
move
(
proxy
)
domain
filter
mode
color
std
:
:
move
(
texXform
)
&
paint
)
;
op
=
GrFillRectOp
:
:
MakePerEdgeQuad
(
fContext
std
:
:
move
(
paint
)
aaType
aaFlags
viewMatrix
dstQuad
srcQuad
)
;
}
else
{
op
=
GrTextureOp
:
:
MakeQuad
(
fContext
std
:
:
move
(
proxy
)
filter
color
srcQuad
dstQuad
aaType
aaFlags
domain
viewMatrix
std
:
:
move
(
texXform
)
)
;
}
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
void
GrRenderTargetContext
:
:
drawTextureSet
(
const
GrClip
&
clip
const
TextureSetEntry
set
[
]
int
cnt
GrSamplerState
:
:
Filter
filter
SkBlendMode
mode
GrAA
aa
const
SkMatrix
&
viewMatrix
sk_sp
<
GrColorSpaceXform
>
texXform
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawTextureSet
"
fContext
)
;
if
(
mode
!
=
SkBlendMode
:
:
kSrcOver
|
|
!
fContext
-
>
priv
(
)
.
caps
(
)
-
>
dynamicStateArrayGeometryProcessorTextureSupport
(
)
)
{
SkMatrix
ctm
;
for
(
int
i
=
0
;
i
<
cnt
;
+
+
i
)
{
float
alpha
=
set
[
i
]
.
fAlpha
;
ctm
=
viewMatrix
;
if
(
set
[
i
]
.
fPreViewMatrix
)
{
ctm
.
preConcat
(
*
set
[
i
]
.
fPreViewMatrix
)
;
}
if
(
set
[
i
]
.
fDstClipQuad
=
=
nullptr
)
{
this
-
>
drawTexture
(
clip
set
[
i
]
.
fProxy
filter
mode
{
alpha
alpha
alpha
alpha
}
set
[
i
]
.
fSrcRect
set
[
i
]
.
fDstRect
aa
set
[
i
]
.
fAAFlags
SkCanvas
:
:
kFast_SrcRectConstraint
ctm
texXform
)
;
}
else
{
SkPoint
srcQuad
[
4
]
;
GrMapRectPoints
(
set
[
i
]
.
fDstRect
set
[
i
]
.
fSrcRect
set
[
i
]
.
fDstClipQuad
srcQuad
4
)
;
this
-
>
drawTextureQuad
(
clip
set
[
i
]
.
fProxy
filter
mode
{
alpha
alpha
alpha
alpha
}
srcQuad
set
[
i
]
.
fDstClipQuad
aa
set
[
i
]
.
fAAFlags
nullptr
ctm
texXform
)
;
}
}
}
else
{
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
GrAllowMixedSamples
:
:
kNo
)
;
auto
op
=
GrTextureOp
:
:
MakeSet
(
fContext
set
cnt
filter
aaType
viewMatrix
std
:
:
move
(
texXform
)
)
;
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
}
void
GrRenderTargetContext
:
:
fillRectWithLocalMatrix
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRect
&
rectToDraw
const
SkMatrix
&
localMatrix
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
fillRectWithLocalMatrix
"
fContext
)
;
SkRect
croppedRect
=
rectToDraw
;
if
(
!
crop_filled_rect
(
this
-
>
width
(
)
this
-
>
height
(
)
clip
viewMatrix
&
croppedRect
)
)
{
return
;
}
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
GrAllowMixedSamples
:
:
kNo
)
;
this
-
>
addDrawOp
(
clip
GrFillRectOp
:
:
MakeWithLocalMatrix
(
fContext
std
:
:
move
(
paint
)
aaType
viewMatrix
localMatrix
croppedRect
)
)
;
}
void
GrRenderTargetContext
:
:
drawVertices
(
const
GrClip
&
clip
GrPaint
&
&
paint
const
SkMatrix
&
viewMatrix
sk_sp
<
SkVertices
>
vertices
const
SkVertices
:
:
Bone
bones
[
]
int
boneCount
GrPrimitiveType
*
overridePrimType
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawVertices
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
SkASSERT
(
vertices
)
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
GrAA
:
:
kNo
GrAllowMixedSamples
:
:
kNo
)
;
std
:
:
unique_ptr
<
GrDrawOp
>
op
=
GrDrawVerticesOp
:
:
Make
(
fContext
std
:
:
move
(
paint
)
std
:
:
move
(
vertices
)
bones
boneCount
viewMatrix
aaType
this
-
>
colorSpaceInfo
(
)
.
refColorSpaceXformFromSRGB
(
)
overridePrimType
)
;
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
void
GrRenderTargetContext
:
:
drawAtlas
(
const
GrClip
&
clip
GrPaint
&
&
paint
const
SkMatrix
&
viewMatrix
int
spriteCount
const
SkRSXform
xform
[
]
const
SkRect
texRect
[
]
const
SkColor
colors
[
]
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawAtlas
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
GrAA
:
:
kNo
GrAllowMixedSamples
:
:
kNo
)
;
std
:
:
unique_ptr
<
GrDrawOp
>
op
=
GrDrawAtlasOp
:
:
Make
(
fContext
std
:
:
move
(
paint
)
viewMatrix
aaType
spriteCount
xform
texRect
colors
)
;
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
void
GrRenderTargetContext
:
:
drawRRect
(
const
GrClip
&
origClip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRRect
&
rrect
const
GrStyle
&
style
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawRRect
"
fContext
)
;
const
SkStrokeRec
&
stroke
=
style
.
strokeRec
(
)
;
if
(
stroke
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kFill_Style
&
&
rrect
.
isEmpty
(
)
)
{
return
;
}
GrNoClip
noclip
;
const
GrClip
*
clip
=
&
origClip
;
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
SkRRect
devRRect
;
if
(
rrect
.
transform
(
viewMatrix
&
devRRect
)
&
&
clip
-
>
quickContains
(
devRRect
)
)
{
clip
=
&
noclip
;
}
#
endif
SkASSERT
(
!
style
.
pathEffect
(
)
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
GrAllowMixedSamples
:
:
kNo
)
;
if
(
GrAAType
:
:
kCoverage
=
=
aaType
)
{
std
:
:
unique_ptr
<
GrDrawOp
>
op
;
if
(
style
.
isSimpleFill
(
)
)
{
op
=
GrAAFillRRectOp
:
:
Make
(
fContext
viewMatrix
rrect
*
this
-
>
caps
(
)
std
:
:
move
(
paint
)
)
;
}
if
(
!
op
)
{
assert_alive
(
paint
)
;
op
=
GrOvalOpFactory
:
:
MakeRRectOp
(
fContext
std
:
:
move
(
paint
)
viewMatrix
rrect
stroke
this
-
>
caps
(
)
-
>
shaderCaps
(
)
)
;
}
if
(
op
)
{
this
-
>
addDrawOp
(
*
clip
std
:
:
move
(
op
)
)
;
return
;
}
}
assert_alive
(
paint
)
;
this
-
>
drawShapeUsingPathRenderer
(
*
clip
std
:
:
move
(
paint
)
aa
viewMatrix
GrShape
(
rrect
style
)
)
;
}
static
SkPoint3
map
(
const
SkMatrix
&
m
const
SkPoint3
&
pt
)
{
SkPoint3
result
;
m
.
mapXY
(
pt
.
fX
pt
.
fY
(
SkPoint
*
)
&
result
.
fX
)
;
result
.
fZ
=
pt
.
fZ
;
return
result
;
}
bool
GrRenderTargetContext
:
:
drawFastShadow
(
const
GrClip
&
clip
const
SkMatrix
&
viewMatrix
const
SkPath
&
path
const
SkDrawShadowRec
&
rec
)
{
ASSERT_SINGLE_OWNER
if
(
fContext
-
>
priv
(
)
.
abandoned
(
)
)
{
return
true
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawFastShadow
"
fContext
)
;
bool
tiltZPlane
=
SkToBool
(
!
SkScalarNearlyZero
(
rec
.
fZPlaneParams
.
fX
)
|
|
!
SkScalarNearlyZero
(
rec
.
fZPlaneParams
.
fY
)
)
;
bool
skipAnalytic
=
SkToBool
(
rec
.
fFlags
&
SkShadowFlags
:
:
kGeometricOnly_ShadowFlag
)
;
if
(
tiltZPlane
|
|
skipAnalytic
|
|
!
viewMatrix
.
rectStaysRect
(
)
|
|
!
viewMatrix
.
isSimilarity
(
)
)
{
return
false
;
}
SkRRect
rrect
;
SkRect
rect
;
bool
isRRect
=
path
.
isRRect
(
&
rrect
)
&
&
SkRRectPriv
:
:
IsSimpleCircular
(
rrect
)
&
&
rrect
.
radii
(
SkRRect
:
:
kUpperLeft_Corner
)
.
fX
>
SK_ScalarNearlyZero
;
if
(
!
isRRect
&
&
path
.
isOval
(
&
rect
)
&
&
SkScalarNearlyEqual
(
rect
.
width
(
)
rect
.
height
(
)
)
&
&
rect
.
width
(
)
>
SK_ScalarNearlyZero
)
{
rrect
.
setOval
(
rect
)
;
isRRect
=
true
;
}
if
(
!
isRRect
&
&
path
.
isRect
(
&
rect
)
)
{
rrect
.
setRect
(
rect
)
;
isRRect
=
true
;
}
if
(
!
isRRect
)
{
return
false
;
}
if
(
rrect
.
isEmpty
(
)
)
{
return
true
;
}
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
SkPoint3
devLightPos
=
map
(
viewMatrix
rec
.
fLightPos
)
;
SkScalar
devToSrcScale
=
viewMatrix
.
isScaleTranslate
(
)
?
SkScalarInvert
(
viewMatrix
[
SkMatrix
:
:
kMScaleX
]
)
:
sk_float_rsqrt
(
viewMatrix
[
SkMatrix
:
:
kMScaleX
]
*
viewMatrix
[
SkMatrix
:
:
kMScaleX
]
+
viewMatrix
[
SkMatrix
:
:
kMSkewX
]
*
viewMatrix
[
SkMatrix
:
:
kMSkewX
]
)
;
SkScalar
occluderHeight
=
rec
.
fZPlaneParams
.
fZ
;
bool
transparent
=
SkToBool
(
rec
.
fFlags
&
SkShadowFlags
:
:
kTransparentOccluder_ShadowFlag
)
;
if
(
SkColorGetA
(
rec
.
fAmbientColor
)
>
0
)
{
SkScalar
devSpaceInsetWidth
=
SkDrawShadowMetrics
:
:
AmbientBlurRadius
(
occluderHeight
)
;
const
SkScalar
umbraRecipAlpha
=
SkDrawShadowMetrics
:
:
AmbientRecipAlpha
(
occluderHeight
)
;
const
SkScalar
devSpaceAmbientBlur
=
devSpaceInsetWidth
*
umbraRecipAlpha
;
SkScalar
ambientPathOutset
=
devSpaceInsetWidth
*
devToSrcScale
;
SkRRect
ambientRRect
;
SkRect
outsetRect
=
rrect
.
rect
(
)
.
makeOutset
(
ambientPathOutset
ambientPathOutset
)
;
if
(
rrect
.
isOval
(
)
)
{
ambientRRect
=
SkRRect
:
:
MakeOval
(
outsetRect
)
;
}
else
{
SkScalar
outsetRad
=
SkRRectPriv
:
:
GetSimpleRadii
(
rrect
)
.
fX
+
ambientPathOutset
;
ambientRRect
=
SkRRect
:
:
MakeRectXY
(
outsetRect
outsetRad
outsetRad
)
;
}
GrColor
ambientColor
=
SkColorToPremulGrColor
(
rec
.
fAmbientColor
)
;
if
(
transparent
)
{
devSpaceInsetWidth
=
ambientRRect
.
width
(
)
;
}
std
:
:
unique_ptr
<
GrDrawOp
>
op
=
GrShadowRRectOp
:
:
Make
(
fContext
ambientColor
viewMatrix
ambientRRect
devSpaceAmbientBlur
devSpaceInsetWidth
)
;
SkASSERT
(
op
)
;
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
if
(
SkColorGetA
(
rec
.
fSpotColor
)
>
0
)
{
SkScalar
devSpaceSpotBlur
;
SkScalar
spotScale
;
SkVector
spotOffset
;
SkDrawShadowMetrics
:
:
GetSpotParams
(
occluderHeight
devLightPos
.
fX
devLightPos
.
fY
devLightPos
.
fZ
rec
.
fLightRadius
&
devSpaceSpotBlur
&
spotScale
&
spotOffset
)
;
const
SkScalar
srcSpaceSpotBlur
=
devSpaceSpotBlur
*
devToSrcScale
;
spotOffset
.
fX
+
=
spotScale
*
viewMatrix
[
SkMatrix
:
:
kMTransX
]
;
spotOffset
.
fY
+
=
spotScale
*
viewMatrix
[
SkMatrix
:
:
kMTransY
]
;
SkMatrix
ctmInverse
;
if
(
viewMatrix
.
invert
(
&
ctmInverse
)
)
{
ctmInverse
.
mapPoints
(
&
spotOffset
1
)
;
}
else
{
SkDebugf
(
"
Matrix
is
degenerate
.
Will
not
render
spot
shadow
correctly
!
\
n
"
)
;
SkASSERT
(
false
)
;
}
SkRRect
spotShadowRRect
;
SkMatrix
shadowTransform
;
shadowTransform
.
setScaleTranslate
(
spotScale
spotScale
spotOffset
.
fX
spotOffset
.
fY
)
;
rrect
.
transform
(
shadowTransform
&
spotShadowRRect
)
;
SkScalar
spotRadius
=
SkRRectPriv
:
:
GetSimpleRadii
(
spotShadowRRect
)
.
fX
;
SkScalar
blurOutset
=
srcSpaceSpotBlur
;
SkScalar
insetWidth
=
blurOutset
;
if
(
transparent
)
{
insetWidth
+
=
spotShadowRRect
.
width
(
)
;
}
else
{
SkScalar
maxOffset
;
if
(
rrect
.
isRect
(
)
)
{
maxOffset
=
SkTMax
(
SkTMax
(
SkTAbs
(
spotShadowRRect
.
rect
(
)
.
fLeft
-
rrect
.
rect
(
)
.
fLeft
)
SkTAbs
(
spotShadowRRect
.
rect
(
)
.
fTop
-
rrect
.
rect
(
)
.
fTop
)
)
SkTMax
(
SkTAbs
(
spotShadowRRect
.
rect
(
)
.
fRight
-
rrect
.
rect
(
)
.
fRight
)
SkTAbs
(
spotShadowRRect
.
rect
(
)
.
fBottom
-
rrect
.
rect
(
)
.
fBottom
)
)
)
;
}
else
{
SkScalar
dr
=
spotRadius
-
SkRRectPriv
:
:
GetSimpleRadii
(
rrect
)
.
fX
;
SkPoint
upperLeftOffset
=
SkPoint
:
:
Make
(
spotShadowRRect
.
rect
(
)
.
fLeft
-
rrect
.
rect
(
)
.
fLeft
+
dr
spotShadowRRect
.
rect
(
)
.
fTop
-
rrect
.
rect
(
)
.
fTop
+
dr
)
;
SkPoint
lowerRightOffset
=
SkPoint
:
:
Make
(
spotShadowRRect
.
rect
(
)
.
fRight
-
rrect
.
rect
(
)
.
fRight
-
dr
spotShadowRRect
.
rect
(
)
.
fBottom
-
rrect
.
rect
(
)
.
fBottom
-
dr
)
;
maxOffset
=
SkScalarSqrt
(
SkTMax
(
SkPointPriv
:
:
LengthSqd
(
upperLeftOffset
)
SkPointPriv
:
:
LengthSqd
(
lowerRightOffset
)
)
)
+
dr
;
}
insetWidth
+
=
SkTMax
(
blurOutset
maxOffset
)
;
}
SkRect
outsetRect
=
spotShadowRRect
.
rect
(
)
.
makeOutset
(
blurOutset
blurOutset
)
;
if
(
spotShadowRRect
.
isOval
(
)
)
{
spotShadowRRect
=
SkRRect
:
:
MakeOval
(
outsetRect
)
;
}
else
{
SkScalar
outsetRad
=
spotRadius
+
blurOutset
;
spotShadowRRect
=
SkRRect
:
:
MakeRectXY
(
outsetRect
outsetRad
outsetRad
)
;
}
GrColor
spotColor
=
SkColorToPremulGrColor
(
rec
.
fSpotColor
)
;
std
:
:
unique_ptr
<
GrDrawOp
>
op
=
GrShadowRRectOp
:
:
Make
(
fContext
spotColor
viewMatrix
spotShadowRRect
2
.
0f
*
devSpaceSpotBlur
insetWidth
)
;
SkASSERT
(
op
)
;
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
return
true
;
}
bool
GrRenderTargetContext
:
:
drawFilledDRRect
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRRect
&
origOuter
const
SkRRect
&
origInner
)
{
SkASSERT
(
!
origInner
.
isEmpty
(
)
)
;
SkASSERT
(
!
origOuter
.
isEmpty
(
)
)
;
SkTCopyOnFirstWrite
<
SkRRect
>
inner
(
origInner
)
outer
(
origOuter
)
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
GrAllowMixedSamples
:
:
kNo
)
;
if
(
GrAAType
:
:
kMSAA
=
=
aaType
)
{
return
false
;
}
if
(
GrAAType
:
:
kCoverage
=
=
aaType
&
&
SkRRectPriv
:
:
IsCircle
(
*
inner
)
&
&
SkRRectPriv
:
:
IsCircle
(
*
outer
)
)
{
auto
outerR
=
outer
-
>
width
(
)
/
2
.
f
;
auto
innerR
=
inner
-
>
width
(
)
/
2
.
f
;
auto
cx
=
outer
-
>
getBounds
(
)
.
fLeft
+
outerR
;
auto
cy
=
outer
-
>
getBounds
(
)
.
fTop
+
outerR
;
if
(
SkScalarNearlyEqual
(
cx
inner
-
>
getBounds
(
)
.
fLeft
+
innerR
)
&
&
SkScalarNearlyEqual
(
cy
inner
-
>
getBounds
(
)
.
fTop
+
innerR
)
)
{
auto
avgR
=
(
innerR
+
outerR
)
/
2
.
f
;
auto
circleBounds
=
SkRect
:
:
MakeLTRB
(
cx
-
avgR
cy
-
avgR
cx
+
avgR
cy
+
avgR
)
;
SkStrokeRec
stroke
(
SkStrokeRec
:
:
kFill_InitStyle
)
;
stroke
.
setStrokeStyle
(
outerR
-
innerR
)
;
auto
op
=
GrOvalOpFactory
:
:
MakeOvalOp
(
fContext
std
:
:
move
(
paint
)
viewMatrix
circleBounds
GrStyle
(
stroke
nullptr
)
this
-
>
caps
(
)
-
>
shaderCaps
(
)
)
;
if
(
op
)
{
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
return
true
;
}
assert_alive
(
paint
)
;
}
}
GrClipEdgeType
innerEdgeType
outerEdgeType
;
if
(
GrAAType
:
:
kCoverage
=
=
aaType
)
{
innerEdgeType
=
GrClipEdgeType
:
:
kInverseFillAA
;
outerEdgeType
=
GrClipEdgeType
:
:
kFillAA
;
}
else
{
innerEdgeType
=
GrClipEdgeType
:
:
kInverseFillBW
;
outerEdgeType
=
GrClipEdgeType
:
:
kFillBW
;
}
SkMatrix
inverseVM
;
if
(
!
viewMatrix
.
isIdentity
(
)
)
{
if
(
!
origInner
.
transform
(
viewMatrix
inner
.
writable
(
)
)
)
{
return
false
;
}
if
(
!
origOuter
.
transform
(
viewMatrix
outer
.
writable
(
)
)
)
{
return
false
;
}
if
(
!
viewMatrix
.
invert
(
&
inverseVM
)
)
{
return
false
;
}
}
else
{
inverseVM
.
reset
(
)
;
}
const
auto
&
caps
=
*
this
-
>
caps
(
)
-
>
shaderCaps
(
)
;
auto
innerEffect
=
GrRRectEffect
:
:
Make
(
innerEdgeType
*
inner
caps
)
;
if
(
!
innerEffect
)
{
return
false
;
}
auto
outerEffect
=
GrRRectEffect
:
:
Make
(
outerEdgeType
*
outer
caps
)
;
if
(
!
outerEffect
)
{
return
false
;
}
paint
.
addCoverageFragmentProcessor
(
std
:
:
move
(
innerEffect
)
)
;
paint
.
addCoverageFragmentProcessor
(
std
:
:
move
(
outerEffect
)
)
;
SkRect
bounds
=
outer
-
>
getBounds
(
)
;
if
(
GrAAType
:
:
kCoverage
=
=
aaType
)
{
bounds
.
outset
(
SK_ScalarHalf
SK_ScalarHalf
)
;
}
this
-
>
fillRectWithLocalMatrix
(
clip
std
:
:
move
(
paint
)
GrAA
:
:
kNo
SkMatrix
:
:
I
(
)
bounds
inverseVM
)
;
return
true
;
}
void
GrRenderTargetContext
:
:
drawDRRect
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRRect
&
outer
const
SkRRect
&
inner
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawDRRect
"
fContext
)
;
SkASSERT
(
!
outer
.
isEmpty
(
)
)
;
SkASSERT
(
!
inner
.
isEmpty
(
)
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
if
(
this
-
>
drawFilledDRRect
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
outer
inner
)
)
{
return
;
}
assert_alive
(
paint
)
;
SkPath
path
;
path
.
setIsVolatile
(
true
)
;
path
.
addRRect
(
inner
)
;
path
.
addRRect
(
outer
)
;
path
.
setFillType
(
SkPath
:
:
kEvenOdd_FillType
)
;
this
-
>
drawShapeUsingPathRenderer
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
GrShape
(
path
)
)
;
}
void
GrRenderTargetContext
:
:
drawRegion
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRegion
&
region
const
GrStyle
&
style
const
GrUserStencilSettings
*
ss
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawRegion
"
fContext
)
;
if
(
GrAA
:
:
kYes
=
=
aa
)
{
if
(
!
SkToBool
(
viewMatrix
.
getType
(
)
&
~
(
SkMatrix
:
:
kTranslate_Mask
)
)
&
&
SkScalarIsInt
(
viewMatrix
.
getTranslateX
(
)
)
&
&
SkScalarIsInt
(
viewMatrix
.
getTranslateY
(
)
)
)
{
aa
=
GrAA
:
:
kNo
;
}
}
bool
complexStyle
=
!
style
.
isSimpleFill
(
)
;
if
(
complexStyle
|
|
GrAA
:
:
kYes
=
=
aa
)
{
SkPath
path
;
region
.
getBoundaryPath
(
&
path
)
;
path
.
setIsVolatile
(
true
)
;
return
this
-
>
drawPath
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
path
style
)
;
}
GrAAType
aaType
=
this
-
>
chooseAAType
(
GrAA
:
:
kNo
GrAllowMixedSamples
:
:
kNo
)
;
std
:
:
unique_ptr
<
GrDrawOp
>
op
=
GrRegionOp
:
:
Make
(
fContext
std
:
:
move
(
paint
)
viewMatrix
region
aaType
ss
)
;
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
void
GrRenderTargetContext
:
:
drawOval
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRect
&
oval
const
GrStyle
&
style
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawOval
"
fContext
)
;
const
SkStrokeRec
&
stroke
=
style
.
strokeRec
(
)
;
if
(
oval
.
isEmpty
(
)
&
&
!
style
.
pathEffect
(
)
)
{
if
(
stroke
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kFill_Style
)
{
return
;
}
this
-
>
drawRect
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
oval
&
style
)
;
return
;
}
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
GrAllowMixedSamples
:
:
kNo
)
;
if
(
GrAAType
:
:
kCoverage
=
=
aaType
)
{
std
:
:
unique_ptr
<
GrDrawOp
>
op
;
if
(
style
.
isSimpleFill
(
)
&
&
oval
.
height
(
)
!
=
oval
.
width
(
)
)
{
op
=
GrAAFillRRectOp
:
:
Make
(
fContext
viewMatrix
SkRRect
:
:
MakeOval
(
oval
)
*
this
-
>
caps
(
)
std
:
:
move
(
paint
)
)
;
}
if
(
!
op
)
{
assert_alive
(
paint
)
;
op
=
GrOvalOpFactory
:
:
MakeOvalOp
(
fContext
std
:
:
move
(
paint
)
viewMatrix
oval
style
this
-
>
caps
(
)
-
>
shaderCaps
(
)
)
;
}
if
(
op
)
{
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
return
;
}
}
assert_alive
(
paint
)
;
this
-
>
drawShapeUsingPathRenderer
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
GrShape
(
SkRRect
:
:
MakeOval
(
oval
)
SkPath
:
:
kCW_Direction
2
false
style
)
)
;
}
void
GrRenderTargetContext
:
:
drawArc
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
bool
useCenter
const
GrStyle
&
style
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawArc
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
GrAllowMixedSamples
:
:
kNo
)
;
if
(
GrAAType
:
:
kCoverage
=
=
aaType
)
{
const
GrShaderCaps
*
shaderCaps
=
this
-
>
caps
(
)
-
>
shaderCaps
(
)
;
std
:
:
unique_ptr
<
GrDrawOp
>
op
=
GrOvalOpFactory
:
:
MakeArcOp
(
fContext
std
:
:
move
(
paint
)
viewMatrix
oval
startAngle
sweepAngle
useCenter
style
shaderCaps
)
;
if
(
op
)
{
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
return
;
}
assert_alive
(
paint
)
;
}
this
-
>
drawShapeUsingPathRenderer
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
GrShape
:
:
MakeArc
(
oval
startAngle
sweepAngle
useCenter
style
)
)
;
}
void
GrRenderTargetContext
:
:
drawImageLattice
(
const
GrClip
&
clip
GrPaint
&
&
paint
const
SkMatrix
&
viewMatrix
sk_sp
<
GrTextureProxy
>
image
sk_sp
<
GrColorSpaceXform
>
csxf
GrSamplerState
:
:
Filter
filter
std
:
:
unique_ptr
<
SkLatticeIter
>
iter
const
SkRect
&
dst
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawImageLattice
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
std
:
:
unique_ptr
<
GrDrawOp
>
op
=
GrLatticeOp
:
:
MakeNonAA
(
fContext
std
:
:
move
(
paint
)
viewMatrix
std
:
:
move
(
image
)
std
:
:
move
(
csxf
)
filter
std
:
:
move
(
iter
)
dst
)
;
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
void
GrRenderTargetContext
:
:
drawDrawable
(
std
:
:
unique_ptr
<
SkDrawable
:
:
GpuDrawHandler
>
drawable
const
SkRect
&
bounds
)
{
std
:
:
unique_ptr
<
GrOp
>
op
(
GrDrawableOp
:
:
Make
(
fContext
std
:
:
move
(
drawable
)
bounds
)
)
;
SkASSERT
(
op
)
;
this
-
>
getRTOpList
(
)
-
>
addOp
(
std
:
:
move
(
op
)
*
this
-
>
caps
(
)
)
;
}
GrSemaphoresSubmitted
GrRenderTargetContext
:
:
prepareForExternalIO
(
SkSurface
:
:
BackendSurfaceAccess
access
SkSurface
:
:
FlushFlags
flags
int
numSemaphores
GrBackendSemaphore
backendSemaphores
[
]
)
{
ASSERT_SINGLE_OWNER
if
(
fContext
-
>
priv
(
)
.
abandoned
(
)
)
{
return
GrSemaphoresSubmitted
:
:
kNo
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
prepareForExternalIO
"
fContext
)
;
return
this
-
>
drawingManager
(
)
-
>
prepareSurfaceForExternalIO
(
fRenderTargetProxy
.
get
(
)
access
flags
numSemaphores
backendSemaphores
)
;
}
bool
GrRenderTargetContext
:
:
waitOnSemaphores
(
int
numSemaphores
const
GrBackendSemaphore
waitSemaphores
[
]
)
{
ASSERT_SINGLE_OWNER
RETURN_FALSE_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
waitOnSemaphores
"
fContext
)
;
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
if
(
numSemaphores
&
&
!
this
-
>
caps
(
)
-
>
fenceSyncSupport
(
)
)
{
return
false
;
}
auto
direct
=
fContext
-
>
priv
(
)
.
asDirectContext
(
)
;
if
(
!
direct
)
{
return
false
;
}
auto
resourceProvider
=
direct
-
>
priv
(
)
.
resourceProvider
(
)
;
SkTArray
<
sk_sp
<
GrSemaphore
>
>
semaphores
(
numSemaphores
)
;
for
(
int
i
=
0
;
i
<
numSemaphores
;
+
+
i
)
{
sk_sp
<
GrSemaphore
>
sema
=
resourceProvider
-
>
wrapBackendSemaphore
(
waitSemaphores
[
i
]
GrResourceProvider
:
:
SemaphoreWrapType
:
:
kWillWait
kAdopt_GrWrapOwnership
)
;
std
:
:
unique_ptr
<
GrOp
>
waitOp
(
GrSemaphoreOp
:
:
MakeWait
(
fContext
std
:
:
move
(
sema
)
fRenderTargetProxy
.
get
(
)
)
)
;
this
-
>
getRTOpList
(
)
-
>
addWaitOp
(
std
:
:
move
(
waitOp
)
*
this
-
>
caps
(
)
)
;
}
return
true
;
}
void
GrRenderTargetContext
:
:
insertEventMarker
(
const
SkString
&
str
)
{
std
:
:
unique_ptr
<
GrOp
>
op
(
GrDebugMarkerOp
:
:
Make
(
fContext
fRenderTargetProxy
.
get
(
)
str
)
)
;
this
-
>
getRTOpList
(
)
-
>
addOp
(
std
:
:
move
(
op
)
*
this
-
>
caps
(
)
)
;
}
const
GrCaps
*
GrRenderTargetContext
:
:
caps
(
)
const
{
return
fContext
-
>
priv
(
)
.
caps
(
)
;
}
void
GrRenderTargetContext
:
:
drawPath
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkPath
&
path
const
GrStyle
&
style
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawPath
"
fContext
)
;
GrShape
shape
(
path
style
)
;
this
-
>
drawShape
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
shape
)
;
}
void
GrRenderTargetContext
:
:
drawShape
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
GrShape
&
shape
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
drawShape
"
fContext
)
;
if
(
shape
.
isEmpty
(
)
)
{
if
(
shape
.
inverseFilled
(
)
)
{
this
-
>
drawPaint
(
clip
std
:
:
move
(
paint
)
viewMatrix
)
;
}
return
;
}
AutoCheckFlush
acf
(
this
-
>
drawingManager
(
)
)
;
if
(
!
shape
.
style
(
)
.
hasPathEffect
(
)
)
{
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
GrAllowMixedSamples
:
:
kNo
)
;
SkRRect
rrect
;
bool
inverted
;
if
(
shape
.
asRRect
(
&
rrect
nullptr
nullptr
&
inverted
)
&
&
!
inverted
)
{
if
(
rrect
.
isRect
(
)
)
{
this
-
>
drawRect
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
rrect
.
rect
(
)
&
shape
.
style
(
)
)
;
return
;
}
else
if
(
rrect
.
isOval
(
)
)
{
this
-
>
drawOval
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
rrect
.
rect
(
)
shape
.
style
(
)
)
;
return
;
}
this
-
>
drawRRect
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
rrect
shape
.
style
(
)
)
;
return
;
}
else
if
(
GrAAType
:
:
kCoverage
=
=
aaType
&
&
shape
.
style
(
)
.
isSimpleFill
(
)
&
&
viewMatrix
.
rectStaysRect
(
)
)
{
SkRect
rects
[
2
]
;
if
(
shape
.
asNestedRects
(
rects
)
)
{
std
:
:
unique_ptr
<
GrDrawOp
>
op
=
GrStrokeRectOp
:
:
MakeNested
(
fContext
std
:
:
move
(
paint
)
viewMatrix
rects
)
;
if
(
op
)
{
this
-
>
addDrawOp
(
clip
std
:
:
move
(
op
)
)
;
}
return
;
}
}
}
this
-
>
drawShapeUsingPathRenderer
(
clip
std
:
:
move
(
paint
)
aa
viewMatrix
shape
)
;
}
bool
GrRenderTargetContextPriv
:
:
drawAndStencilPath
(
const
GrHardClip
&
clip
const
GrUserStencilSettings
*
ss
SkRegion
:
:
Op
op
bool
invert
GrAA
aa
const
SkMatrix
&
viewMatrix
const
SkPath
&
path
)
{
ASSERT_SINGLE_OWNER_PRIV
RETURN_FALSE_IF_ABANDONED_PRIV
SkDEBUGCODE
(
fRenderTargetContext
-
>
validate
(
)
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContextPriv
"
"
drawAndStencilPath
"
fRenderTargetContext
-
>
fContext
)
;
if
(
path
.
isEmpty
(
)
&
&
path
.
isInverseFillType
(
)
)
{
this
-
>
drawAndStencilRect
(
clip
ss
op
invert
GrAA
:
:
kNo
SkMatrix
:
:
I
(
)
SkRect
:
:
MakeIWH
(
fRenderTargetContext
-
>
width
(
)
fRenderTargetContext
-
>
height
(
)
)
)
;
return
true
;
}
AutoCheckFlush
acf
(
fRenderTargetContext
-
>
drawingManager
(
)
)
;
GrAAType
aaType
=
fRenderTargetContext
-
>
chooseAAType
(
aa
GrAllowMixedSamples
:
:
kNo
)
;
bool
hasUserStencilSettings
=
!
ss
-
>
isUnused
(
)
;
SkIRect
clipConservativeBounds
;
clip
.
getConservativeBounds
(
fRenderTargetContext
-
>
width
(
)
fRenderTargetContext
-
>
height
(
)
&
clipConservativeBounds
nullptr
)
;
GrShape
shape
(
path
GrStyle
:
:
SimpleFill
(
)
)
;
GrPathRenderer
:
:
CanDrawPathArgs
canDrawArgs
;
canDrawArgs
.
fCaps
=
fRenderTargetContext
-
>
caps
(
)
;
canDrawArgs
.
fViewMatrix
=
&
viewMatrix
;
canDrawArgs
.
fShape
=
&
shape
;
canDrawArgs
.
fClipConservativeBounds
=
&
clipConservativeBounds
;
canDrawArgs
.
fAAType
=
aaType
;
SkASSERT
(
!
fRenderTargetContext
-
>
wrapsVkSecondaryCB
(
)
)
;
canDrawArgs
.
fTargetIsWrappedVkSecondaryCB
=
false
;
canDrawArgs
.
fHasUserStencilSettings
=
hasUserStencilSettings
;
GrPathRenderer
*
pr
=
fRenderTargetContext
-
>
drawingManager
(
)
-
>
getPathRenderer
(
canDrawArgs
false
GrPathRendererChain
:
:
DrawType
:
:
kStencilAndColor
)
;
if
(
!
pr
)
{
return
false
;
}
GrPaint
paint
;
paint
.
setCoverageSetOpXPFactory
(
op
invert
)
;
GrPathRenderer
:
:
DrawPathArgs
args
{
fRenderTargetContext
-
>
drawingManager
(
)
-
>
getContext
(
)
std
:
:
move
(
paint
)
ss
fRenderTargetContext
&
clip
&
clipConservativeBounds
&
viewMatrix
&
shape
aaType
fRenderTargetContext
-
>
colorSpaceInfo
(
)
.
isLinearlyBlended
(
)
}
;
pr
-
>
drawPath
(
args
)
;
return
true
;
}
SkBudgeted
GrRenderTargetContextPriv
:
:
isBudgeted
(
)
const
{
ASSERT_SINGLE_OWNER_PRIV
if
(
fRenderTargetContext
-
>
fContext
-
>
priv
(
)
.
abandoned
(
)
)
{
return
SkBudgeted
:
:
kNo
;
}
SkDEBUGCODE
(
fRenderTargetContext
-
>
validate
(
)
;
)
return
fRenderTargetContext
-
>
fRenderTargetProxy
-
>
isBudgeted
(
)
;
}
void
GrRenderTargetContext
:
:
drawShapeUsingPathRenderer
(
const
GrClip
&
clip
GrPaint
&
&
paint
GrAA
aa
const
SkMatrix
&
viewMatrix
const
GrShape
&
originalShape
)
{
ASSERT_SINGLE_OWNER
RETURN_IF_ABANDONED
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
internalDrawPath
"
fContext
)
;
if
(
!
viewMatrix
.
isFinite
(
)
|
|
!
originalShape
.
bounds
(
)
.
isFinite
(
)
)
{
return
;
}
SkIRect
clipConservativeBounds
;
clip
.
getConservativeBounds
(
this
-
>
width
(
)
this
-
>
height
(
)
&
clipConservativeBounds
nullptr
)
;
GrShape
tempShape
;
GrAllowMixedSamples
allowMixedSamples
=
originalShape
.
style
(
)
.
isSimpleHairline
(
)
?
GrAllowMixedSamples
:
:
kNo
:
GrAllowMixedSamples
:
:
kYes
;
GrAAType
aaType
=
this
-
>
chooseAAType
(
aa
allowMixedSamples
)
;
GrPathRenderer
:
:
CanDrawPathArgs
canDrawArgs
;
canDrawArgs
.
fCaps
=
this
-
>
caps
(
)
;
canDrawArgs
.
fViewMatrix
=
&
viewMatrix
;
canDrawArgs
.
fShape
=
&
originalShape
;
canDrawArgs
.
fClipConservativeBounds
=
&
clipConservativeBounds
;
canDrawArgs
.
fTargetIsWrappedVkSecondaryCB
=
this
-
>
wrapsVkSecondaryCB
(
)
;
canDrawArgs
.
fHasUserStencilSettings
=
false
;
GrPathRenderer
*
pr
;
static
constexpr
GrPathRendererChain
:
:
DrawType
kType
=
GrPathRendererChain
:
:
DrawType
:
:
kColor
;
if
(
originalShape
.
isEmpty
(
)
&
&
!
originalShape
.
inverseFilled
(
)
)
{
return
;
}
canDrawArgs
.
fAAType
=
aaType
;
pr
=
this
-
>
drawingManager
(
)
-
>
getPathRenderer
(
canDrawArgs
false
kType
)
;
SkScalar
styleScale
=
GrStyle
:
:
MatrixToScaleFactor
(
viewMatrix
)
;
if
(
!
pr
&
&
originalShape
.
style
(
)
.
pathEffect
(
)
)
{
tempShape
=
originalShape
.
applyStyle
(
GrStyle
:
:
Apply
:
:
kPathEffectOnly
styleScale
)
;
if
(
tempShape
.
isEmpty
(
)
)
{
return
;
}
canDrawArgs
.
fShape
=
&
tempShape
;
pr
=
this
-
>
drawingManager
(
)
-
>
getPathRenderer
(
canDrawArgs
false
kType
)
;
}
if
(
!
pr
)
{
if
(
canDrawArgs
.
fShape
-
>
style
(
)
.
applies
(
)
)
{
tempShape
=
canDrawArgs
.
fShape
-
>
applyStyle
(
GrStyle
:
:
Apply
:
:
kPathEffectAndStrokeRec
styleScale
)
;
if
(
tempShape
.
isEmpty
(
)
)
{
return
;
}
canDrawArgs
.
fShape
=
&
tempShape
;
pr
=
this
-
>
drawingManager
(
)
-
>
getPathRenderer
(
canDrawArgs
true
kType
)
;
}
else
{
pr
=
this
-
>
drawingManager
(
)
-
>
getSoftwarePathRenderer
(
)
;
}
}
if
(
!
pr
)
{
#
ifdef
SK_DEBUG
SkDebugf
(
"
Unable
to
find
path
renderer
compatible
with
path
.
\
n
"
)
;
#
endif
return
;
}
GrPathRenderer
:
:
DrawPathArgs
args
{
this
-
>
drawingManager
(
)
-
>
getContext
(
)
std
:
:
move
(
paint
)
&
GrUserStencilSettings
:
:
kUnused
this
&
clip
&
clipConservativeBounds
&
viewMatrix
canDrawArgs
.
fShape
aaType
this
-
>
colorSpaceInfo
(
)
.
isLinearlyBlended
(
)
}
;
pr
-
>
drawPath
(
args
)
;
}
static
void
op_bounds
(
SkRect
*
bounds
const
GrOp
*
op
)
{
*
bounds
=
op
-
>
bounds
(
)
;
if
(
op
-
>
hasZeroArea
(
)
)
{
if
(
op
-
>
hasAABloat
(
)
)
{
bounds
-
>
outset
(
0
.
5f
0
.
5f
)
;
}
else
{
SkRect
before
=
*
bounds
;
bounds
-
>
roundOut
(
bounds
)
;
if
(
bounds
-
>
fLeft
=
=
before
.
fLeft
)
{
bounds
-
>
fLeft
-
=
1
;
}
if
(
bounds
-
>
fTop
=
=
before
.
fTop
)
{
bounds
-
>
fTop
-
=
1
;
}
if
(
bounds
-
>
fRight
=
=
before
.
fRight
)
{
bounds
-
>
fRight
+
=
1
;
}
if
(
bounds
-
>
fBottom
=
=
before
.
fBottom
)
{
bounds
-
>
fBottom
+
=
1
;
}
}
}
}
void
GrRenderTargetContext
:
:
addDrawOp
(
const
GrClip
&
clip
std
:
:
unique_ptr
<
GrDrawOp
>
op
const
std
:
:
function
<
WillAddOpFn
>
&
willAddFn
)
{
ASSERT_SINGLE_OWNER
if
(
fContext
-
>
priv
(
)
.
abandoned
(
)
)
{
fContext
-
>
priv
(
)
.
opMemoryPool
(
)
-
>
release
(
std
:
:
move
(
op
)
)
;
return
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
SkDEBUGCODE
(
op
-
>
fAddDrawOpCalled
=
true
;
)
GR_CREATE_TRACE_MARKER_CONTEXT
(
"
GrRenderTargetContext
"
"
addDrawOp
"
fContext
)
;
SkRect
bounds
;
op_bounds
(
&
bounds
op
.
get
(
)
)
;
GrAppliedClip
appliedClip
;
GrDrawOp
:
:
FixedFunctionFlags
fixedFunctionFlags
=
op
-
>
fixedFunctionFlags
(
)
;
if
(
!
clip
.
apply
(
fContext
this
fixedFunctionFlags
&
GrDrawOp
:
:
FixedFunctionFlags
:
:
kUsesHWAA
fixedFunctionFlags
&
GrDrawOp
:
:
FixedFunctionFlags
:
:
kUsesStencil
&
appliedClip
&
bounds
)
)
{
fContext
-
>
priv
(
)
.
opMemoryPool
(
)
-
>
release
(
std
:
:
move
(
op
)
)
;
return
;
}
if
(
fixedFunctionFlags
&
GrDrawOp
:
:
FixedFunctionFlags
:
:
kUsesStencil
|
|
appliedClip
.
hasStencilClip
(
)
)
{
if
(
this
-
>
caps
(
)
-
>
performStencilClearsAsDraws
(
)
)
{
if
(
!
fRenderTargetProxy
-
>
needsStencil
(
)
)
{
this
-
>
internalStencilClear
(
GrFixedClip
:
:
Disabled
(
)
false
)
;
}
}
else
{
this
-
>
getRTOpList
(
)
-
>
setStencilLoadOp
(
GrLoadOp
:
:
kClear
)
;
}
this
-
>
setNeedsStencil
(
)
;
}
GrXferProcessor
:
:
DstProxy
dstProxy
;
GrProcessorSet
:
:
Analysis
analysis
=
op
-
>
finalize
(
*
this
-
>
caps
(
)
&
appliedClip
this
-
>
fsaaType
(
)
)
;
if
(
analysis
.
requiresDstTexture
(
)
)
{
if
(
!
this
-
>
setupDstProxy
(
this
-
>
asRenderTargetProxy
(
)
clip
*
op
&
dstProxy
)
)
{
fContext
-
>
priv
(
)
.
opMemoryPool
(
)
-
>
release
(
std
:
:
move
(
op
)
)
;
return
;
}
}
op
-
>
setClippedBounds
(
bounds
)
;
auto
opList
=
this
-
>
getRTOpList
(
)
;
if
(
willAddFn
)
{
willAddFn
(
op
.
get
(
)
opList
-
>
uniqueID
(
)
)
;
}
opList
-
>
addDrawOp
(
std
:
:
move
(
op
)
analysis
std
:
:
move
(
appliedClip
)
dstProxy
*
this
-
>
caps
(
)
)
;
}
bool
GrRenderTargetContext
:
:
setupDstProxy
(
GrRenderTargetProxy
*
rtProxy
const
GrClip
&
clip
const
GrOp
&
op
GrXferProcessor
:
:
DstProxy
*
dstProxy
)
{
if
(
rtProxy
-
>
wrapsVkSecondaryCB
(
)
)
{
return
false
;
}
if
(
this
-
>
caps
(
)
-
>
textureBarrierSupport
(
)
)
{
if
(
GrTextureProxy
*
texProxy
=
rtProxy
-
>
asTextureProxy
(
)
)
{
dstProxy
-
>
setProxy
(
sk_ref_sp
(
texProxy
)
)
;
dstProxy
-
>
setOffset
(
0
0
)
;
return
true
;
}
}
SkIRect
copyRect
=
SkIRect
:
:
MakeWH
(
rtProxy
-
>
width
(
)
rtProxy
-
>
height
(
)
)
;
SkIRect
clippedRect
;
clip
.
getConservativeBounds
(
rtProxy
-
>
width
(
)
rtProxy
-
>
height
(
)
&
clippedRect
)
;
SkRect
opBounds
=
op
.
bounds
(
)
;
if
(
op
.
hasAABloat
(
)
|
|
op
.
hasZeroArea
(
)
)
{
opBounds
.
outset
(
0
.
5f
0
.
5f
)
;
clippedRect
.
outset
(
1
1
)
;
clippedRect
.
intersect
(
SkIRect
:
:
MakeWH
(
rtProxy
-
>
width
(
)
rtProxy
-
>
height
(
)
)
)
;
}
SkIRect
opIBounds
;
opBounds
.
roundOut
(
&
opIBounds
)
;
if
(
!
clippedRect
.
intersect
(
opIBounds
)
)
{
#
ifdef
SK_DEBUG
GrCapsDebugf
(
this
-
>
caps
(
)
"
setupDstTexture
:
Missed
an
early
reject
bailing
on
draw
.
"
)
;
#
endif
return
false
;
}
GrSurfaceDesc
desc
;
bool
rectsMustMatch
=
false
;
bool
disallowSubrect
=
false
;
GrSurfaceOrigin
origin
;
if
(
!
this
-
>
caps
(
)
-
>
initDescForDstCopy
(
rtProxy
&
desc
&
origin
&
rectsMustMatch
&
disallowSubrect
)
)
{
desc
.
fFlags
=
kRenderTarget_GrSurfaceFlag
;
desc
.
fConfig
=
rtProxy
-
>
config
(
)
;
origin
=
rtProxy
-
>
origin
(
)
;
}
if
(
!
disallowSubrect
)
{
copyRect
=
clippedRect
;
}
SkIPoint
dstPoint
dstOffset
;
SkBackingFit
fit
;
if
(
rectsMustMatch
)
{
desc
.
fWidth
=
rtProxy
-
>
width
(
)
;
desc
.
fHeight
=
rtProxy
-
>
height
(
)
;
dstPoint
=
{
copyRect
.
fLeft
copyRect
.
fTop
}
;
dstOffset
=
{
0
0
}
;
fit
=
SkBackingFit
:
:
kExact
;
}
else
{
desc
.
fWidth
=
copyRect
.
width
(
)
;
desc
.
fHeight
=
copyRect
.
height
(
)
;
dstPoint
=
{
0
0
}
;
dstOffset
=
{
copyRect
.
fLeft
copyRect
.
fTop
}
;
fit
=
SkBackingFit
:
:
kApprox
;
}
SkASSERT
(
rtProxy
-
>
backendFormat
(
)
.
textureType
(
)
=
=
GrTextureType
:
:
k2D
)
;
const
GrBackendFormat
&
format
=
rtProxy
-
>
backendFormat
(
)
;
sk_sp
<
GrSurfaceContext
>
sContext
=
fContext
-
>
priv
(
)
.
makeDeferredSurfaceContext
(
format
desc
origin
GrMipMapped
:
:
kNo
fit
SkBudgeted
:
:
kYes
sk_ref_sp
(
this
-
>
colorSpaceInfo
(
)
.
colorSpace
(
)
)
)
;
if
(
!
sContext
)
{
SkDebugf
(
"
setupDstTexture
:
surfaceContext
creation
failed
.
\
n
"
)
;
return
false
;
}
if
(
!
sContext
-
>
copy
(
rtProxy
copyRect
dstPoint
)
)
{
SkDebugf
(
"
setupDstTexture
:
copy
failed
.
\
n
"
)
;
return
false
;
}
dstProxy
-
>
setProxy
(
sContext
-
>
asTextureProxyRef
(
)
)
;
dstProxy
-
>
setOffset
(
dstOffset
)
;
return
true
;
}
