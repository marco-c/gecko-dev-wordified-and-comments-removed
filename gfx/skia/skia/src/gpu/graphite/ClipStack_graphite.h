#
ifndef
skgpu_graphite_ClipStack_DEFINED
#
define
skgpu_graphite_ClipStack_DEFINED
#
include
"
include
/
core
/
SkClipOp
.
h
"
#
include
"
src
/
base
/
SkTBlockList
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawOrder
.
h
"
#
include
"
src
/
gpu
/
graphite
/
geom
/
Shape
.
h
"
#
include
"
src
/
gpu
/
graphite
/
geom
/
Transform_graphite
.
h
"
class
SkShader
;
class
SkStrokeRec
;
namespace
skgpu
:
:
graphite
{
class
BoundsManager
;
class
Clip
;
class
Device
;
class
Geometry
;
class
ClipStack
{
public
:
enum
class
ClipState
:
uint8_t
{
kEmpty
kWideOpen
kDeviceRect
kDeviceRRect
kComplex
}
;
struct
Element
{
Shape
fShape
;
Transform
fLocalToDevice
;
SkClipOp
fOp
;
}
;
ClipStack
(
Device
*
owningDevice
)
;
~
ClipStack
(
)
;
ClipStack
(
const
ClipStack
&
)
=
delete
;
ClipStack
&
operator
=
(
const
ClipStack
&
)
=
delete
;
ClipState
clipState
(
)
const
{
return
this
-
>
currentSaveRecord
(
)
.
state
(
)
;
}
int
maxDeferredClipDraws
(
)
const
{
return
fElements
.
count
(
)
;
}
Rect
conservativeBounds
(
)
const
;
class
ElementIter
;
inline
ElementIter
begin
(
)
const
;
inline
ElementIter
end
(
)
const
;
void
save
(
)
;
void
restore
(
)
;
void
clipShape
(
const
Transform
&
localToDevice
const
Shape
&
shape
SkClipOp
op
)
;
void
clipShader
(
sk_sp
<
SkShader
>
shader
)
;
std
:
:
pair
<
Clip
CompressedPaintersOrder
>
applyClipToDraw
(
const
BoundsManager
*
const
Transform
&
const
Geometry
&
const
SkStrokeRec
&
PaintersDepth
z
)
;
void
recordDeferredClipDraws
(
)
;
private
:
class
SaveRecord
;
struct
TransformedShape
;
enum
class
SimplifyResult
{
kEmpty
kAOnly
kBOnly
kBoth
}
;
static
SimplifyResult
Simplify
(
const
TransformedShape
&
a
const
TransformedShape
&
b
)
;
class
RawElement
:
private
Element
{
public
:
using
Stack
=
SkTBlockList
<
RawElement
1
>
;
RawElement
(
const
Rect
&
deviceBounds
const
Transform
&
localToDevice
const
Shape
&
shape
SkClipOp
op
)
;
~
RawElement
(
)
{
SkASSERT
(
!
this
-
>
hasPendingDraw
(
)
)
;
}
RawElement
(
const
RawElement
&
)
=
default
;
RawElement
&
operator
=
(
const
RawElement
&
)
=
default
;
operator
TransformedShape
(
)
const
;
const
Element
&
asElement
(
)
const
{
return
*
this
;
}
bool
hasPendingDraw
(
)
const
{
return
fOrder
!
=
DrawOrder
:
:
kNoIntersection
;
}
const
Shape
&
shape
(
)
const
{
return
fShape
;
}
const
Transform
&
localToDevice
(
)
const
{
return
fLocalToDevice
;
}
const
Rect
&
outerBounds
(
)
const
{
return
fOuterBounds
;
}
const
Rect
&
innerBounds
(
)
const
{
return
fInnerBounds
;
}
SkClipOp
op
(
)
const
{
return
fOp
;
}
ClipState
clipType
(
)
const
;
bool
isInvalid
(
)
const
{
return
fInvalidatedByIndex
>
=
0
;
}
void
markInvalid
(
const
SaveRecord
&
current
)
;
void
restoreValid
(
const
SaveRecord
&
current
)
;
void
updateForElement
(
RawElement
*
added
const
SaveRecord
&
current
)
;
std
:
:
pair
<
bool
CompressedPaintersOrder
>
updateForDraw
(
const
BoundsManager
*
boundsManager
const
TransformedShape
&
draw
PaintersDepth
drawZ
)
;
void
drawClip
(
Device
*
)
;
void
validate
(
)
const
;
private
:
bool
combine
(
const
RawElement
&
other
const
SaveRecord
&
current
)
;
Rect
fInnerBounds
;
Rect
fOuterBounds
;
Rect
fUsageBounds
;
CompressedPaintersOrder
fOrder
;
PaintersDepth
fMaxZ
;
int
fInvalidatedByIndex
;
}
;
class
SaveRecord
{
public
:
using
Stack
=
SkTBlockList
<
SaveRecord
2
>
;
explicit
SaveRecord
(
const
Rect
&
deviceBounds
)
;
SaveRecord
(
const
SaveRecord
&
prior
int
startingElementIndex
)
;
const
SkShader
*
shader
(
)
const
{
return
fShader
.
get
(
)
;
}
const
Rect
&
outerBounds
(
)
const
{
return
fOuterBounds
;
}
const
Rect
&
innerBounds
(
)
const
{
return
fInnerBounds
;
}
SkClipOp
op
(
)
const
{
return
fStackOp
;
}
ClipState
state
(
)
const
;
int
firstActiveElementIndex
(
)
const
{
return
fStartingElementIndex
;
}
int
oldestElementIndex
(
)
const
{
return
fOldestValidIndex
;
}
bool
canBeUpdated
(
)
const
{
return
(
fDeferredSaveCount
=
=
0
)
;
}
Rect
scissor
(
const
Rect
&
deviceBounds
const
Rect
&
drawBounds
)
const
;
void
pushSave
(
)
{
SkASSERT
(
fDeferredSaveCount
>
=
0
)
;
fDeferredSaveCount
+
+
;
}
bool
popSave
(
)
{
fDeferredSaveCount
-
-
;
SkASSERT
(
fDeferredSaveCount
>
=
-
1
)
;
return
fDeferredSaveCount
>
=
0
;
}
bool
addElement
(
RawElement
&
&
toAdd
RawElement
:
:
Stack
*
elements
Device
*
)
;
void
addShader
(
sk_sp
<
SkShader
>
shader
)
;
void
removeElements
(
RawElement
:
:
Stack
*
elements
Device
*
)
;
void
restoreElements
(
RawElement
:
:
Stack
*
elements
)
;
private
:
bool
appendElement
(
RawElement
&
&
toAdd
RawElement
:
:
Stack
*
elements
Device
*
)
;
void
replaceWithElement
(
RawElement
&
&
toAdd
RawElement
:
:
Stack
*
elements
Device
*
)
;
Rect
fInnerBounds
;
Rect
fOuterBounds
;
sk_sp
<
SkShader
>
fShader
;
const
int
fStartingElementIndex
;
int
fOldestValidIndex
;
int
fDeferredSaveCount
;
SkClipOp
fStackOp
;
ClipState
fState
;
}
;
Rect
deviceBounds
(
)
const
;
const
SaveRecord
&
currentSaveRecord
(
)
const
{
SkASSERT
(
!
fSaves
.
empty
(
)
)
;
return
fSaves
.
back
(
)
;
}
SaveRecord
&
writableSaveRecord
(
bool
*
wasDeferred
)
;
RawElement
:
:
Stack
fElements
;
SaveRecord
:
:
Stack
fSaves
;
Device
*
fDevice
;
}
;
class
ClipStack
:
:
ElementIter
{
public
:
bool
operator
!
=
(
const
ElementIter
&
o
)
const
{
return
o
.
fItem
!
=
fItem
&
&
o
.
fRemaining
!
=
fRemaining
;
}
const
Element
&
operator
*
(
)
const
{
return
(
*
fItem
)
.
asElement
(
)
;
}
ElementIter
&
operator
+
+
(
)
{
do
{
fRemaining
-
-
;
+
+
fItem
;
}
while
(
fRemaining
>
0
&
&
(
*
fItem
)
.
isInvalid
(
)
)
;
return
*
this
;
}
ElementIter
(
RawElement
:
:
Stack
:
:
CRIter
:
:
Item
item
int
r
)
:
fItem
(
item
)
fRemaining
(
r
)
{
}
RawElement
:
:
Stack
:
:
CRIter
:
:
Item
fItem
;
int
fRemaining
;
friend
class
ClipStack
;
}
;
ClipStack
:
:
ElementIter
ClipStack
:
:
begin
(
)
const
{
if
(
this
-
>
currentSaveRecord
(
)
.
state
(
)
=
=
ClipState
:
:
kEmpty
|
|
this
-
>
currentSaveRecord
(
)
.
state
(
)
=
=
ClipState
:
:
kWideOpen
)
{
return
this
-
>
end
(
)
;
}
int
count
=
fElements
.
count
(
)
-
this
-
>
currentSaveRecord
(
)
.
oldestElementIndex
(
)
;
return
ElementIter
(
fElements
.
ritems
(
)
.
begin
(
)
count
)
;
}
ClipStack
:
:
ElementIter
ClipStack
:
:
end
(
)
const
{
return
ElementIter
(
fElements
.
ritems
(
)
.
end
(
)
0
)
;
}
}
#
endif
