#
include
"
src
/
gpu
/
graphite
/
UniformManager
.
h
"
#
include
"
include
/
core
/
SkM44
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
private
/
base
/
SkAlign
.
h
"
#
include
"
include
/
private
/
base
/
SkTemplates
.
h
"
#
include
"
src
/
base
/
SkHalf
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawTypes
.
h
"
#
include
"
src
/
gpu
/
graphite
/
PipelineData
.
h
"
#
include
"
src
/
gpu
/
graphite
/
Uniform
.
h
"
static_assert
(
sizeof
(
int32_t
)
=
=
4
)
;
static_assert
(
sizeof
(
float
)
=
=
4
)
;
static_assert
(
sizeof
(
int16_t
)
=
=
2
)
;
static_assert
(
sizeof
(
SkHalf
)
=
=
2
)
;
namespace
skgpu
:
:
graphite
{
template
<
typename
BaseType
>
static
constexpr
size_t
tight_vec_size
(
int
vecLength
)
{
return
sizeof
(
BaseType
)
*
vecLength
;
}
template
<
typename
BaseType
int
RowsOrVecLength
=
1
int
Cols
=
1
>
struct
Rules140
{
static
constexpr
size_t
Stride
(
int
count
)
{
SkASSERT
(
count
>
=
1
|
|
count
=
=
graphite
:
:
Uniform
:
:
kNonArray
)
;
static_assert
(
RowsOrVecLength
>
=
1
&
&
RowsOrVecLength
<
=
4
)
;
static_assert
(
Cols
>
=
1
&
&
Cols
<
=
4
)
;
if
(
Cols
!
=
1
)
{
SkASSERT
(
RowsOrVecLength
>
1
)
;
return
Rules140
<
BaseType
RowsOrVecLength
>
:
:
Stride
(
Uniform
:
:
kNonArray
)
;
}
int
n
=
RowsOrVecLength
=
=
3
?
4
:
RowsOrVecLength
;
if
(
count
=
=
Uniform
:
:
kNonArray
)
{
return
n
*
sizeof
(
BaseType
)
;
}
constexpr
size_t
kVec4Alignment
=
tight_vec_size
<
float
>
(
4
)
;
size_t
kElementAlignment
=
tight_vec_size
<
BaseType
>
(
n
)
;
size_t
m
=
(
kElementAlignment
+
kVec4Alignment
-
1
)
/
kVec4Alignment
;
return
m
*
kVec4Alignment
;
}
}
;
template
<
typename
BaseType
int
RowsOrVecLength
=
1
int
Cols
=
1
>
struct
Rules430
{
static
constexpr
size_t
Stride
(
int
count
)
{
SkASSERT
(
count
>
=
1
|
|
count
=
=
Uniform
:
:
kNonArray
)
;
static_assert
(
RowsOrVecLength
>
=
1
&
&
RowsOrVecLength
<
=
4
)
;
static_assert
(
Cols
>
=
1
&
&
Cols
<
=
4
)
;
if
(
Cols
!
=
1
)
{
SkASSERT
(
RowsOrVecLength
>
1
)
;
return
Rules430
<
BaseType
RowsOrVecLength
>
:
:
Stride
(
Uniform
:
:
kNonArray
)
;
}
int
n
=
RowsOrVecLength
=
=
3
?
4
:
RowsOrVecLength
;
if
(
count
=
=
Uniform
:
:
kNonArray
)
{
return
n
*
sizeof
(
BaseType
)
;
}
return
tight_vec_size
<
BaseType
>
(
n
)
;
}
}
;
template
<
typename
BaseType
int
RowsOrVecLength
=
1
int
Cols
=
1
>
struct
RulesMetal
{
static
constexpr
size_t
Stride
(
int
count
)
{
SkASSERT
(
count
>
=
1
|
|
count
=
=
Uniform
:
:
kNonArray
)
;
static_assert
(
RowsOrVecLength
>
=
1
&
&
RowsOrVecLength
<
=
4
)
;
static_assert
(
Cols
>
=
1
&
&
Cols
<
=
4
)
;
if
(
Cols
!
=
1
)
{
SkASSERT
(
RowsOrVecLength
>
1
)
;
return
RulesMetal
<
BaseType
RowsOrVecLength
>
:
:
Stride
(
Uniform
:
:
kNonArray
)
;
}
int
n
=
RowsOrVecLength
=
=
3
?
4
:
RowsOrVecLength
;
if
(
count
=
=
0
)
{
return
n
*
sizeof
(
BaseType
)
;
}
return
tight_vec_size
<
BaseType
>
(
n
)
;
}
}
;
template
<
template
<
typename
BaseType
int
RowsOrVecLength
int
Cols
>
class
Rules
>
class
Writer
{
private
:
template
<
typename
MemType
typename
UniformType
>
static
void
CopyUniforms
(
void
*
dst
const
void
*
src
int
numUniforms
)
{
if
constexpr
(
std
:
:
is_same
<
MemType
UniformType
>
:
:
value
)
{
std
:
:
memcpy
(
dst
src
numUniforms
*
sizeof
(
MemType
)
)
;
return
;
}
if
constexpr
(
std
:
:
is_same
<
MemType
float
>
:
:
value
&
&
std
:
:
is_same
<
UniformType
SkHalf
>
:
:
value
)
{
const
float
*
floatBits
=
static_cast
<
const
float
*
>
(
src
)
;
SkHalf
*
halfBits
=
static_cast
<
SkHalf
*
>
(
dst
)
;
while
(
numUniforms
-
-
>
0
)
{
*
halfBits
+
+
=
SkFloatToHalf
(
*
floatBits
+
+
)
;
}
return
;
}
if
constexpr
(
std
:
:
is_same
<
MemType
int32_t
>
:
:
value
&
&
std
:
:
is_same
<
UniformType
int16_t
>
:
:
value
)
{
const
int32_t
*
intBits
=
static_cast
<
const
int32_t
*
>
(
src
)
;
int16_t
*
shortBits
=
static_cast
<
int16_t
*
>
(
dst
)
;
while
(
numUniforms
-
-
>
0
)
{
*
shortBits
+
+
=
int16_t
(
*
intBits
+
+
)
;
}
return
;
}
SK_ABORT
(
"
implement
conversion
from
MemType
to
UniformType
"
)
;
}
template
<
typename
MemType
typename
UniformType
int
RowsOrVecLength
=
1
int
Cols
=
1
>
static
uint32_t
Write
(
void
*
dst
int
n
const
MemType
src
[
]
)
{
size_t
stride
=
Rules
<
UniformType
RowsOrVecLength
Cols
>
:
:
Stride
(
n
)
;
n
=
(
n
=
=
Uniform
:
:
kNonArray
)
?
1
:
n
;
n
*
=
Cols
;
if
(
dst
)
{
if
(
stride
=
=
RowsOrVecLength
*
sizeof
(
UniformType
)
)
{
CopyUniforms
<
MemType
UniformType
>
(
dst
src
n
*
RowsOrVecLength
)
;
}
else
{
for
(
int
i
=
0
;
i
<
n
;
+
+
i
)
{
CopyUniforms
<
MemType
UniformType
>
(
dst
src
RowsOrVecLength
)
;
src
+
=
RowsOrVecLength
;
dst
=
SkTAddOffset
<
void
>
(
dst
stride
)
;
}
}
}
return
n
*
stride
;
}
template
<
typename
UniformType
>
static
uint32_t
WriteSkMatrices
(
void
*
dst
int
n
const
SkMatrix
m
[
]
)
{
size_t
stride
=
3
*
Rules
<
UniformType
3
3
>
:
:
Stride
(
1
)
;
n
=
std
:
:
max
(
n
1
)
;
if
(
dst
)
{
size_t
offset
=
0
;
for
(
int
i
=
0
;
i
<
n
;
+
+
i
)
{
float
mt
[
]
=
{
m
[
i
]
.
get
(
SkMatrix
:
:
kMScaleX
)
m
[
i
]
.
get
(
SkMatrix
:
:
kMSkewY
)
m
[
i
]
.
get
(
SkMatrix
:
:
kMPersp0
)
m
[
i
]
.
get
(
SkMatrix
:
:
kMSkewX
)
m
[
i
]
.
get
(
SkMatrix
:
:
kMScaleY
)
m
[
i
]
.
get
(
SkMatrix
:
:
kMPersp1
)
m
[
i
]
.
get
(
SkMatrix
:
:
kMTransX
)
m
[
i
]
.
get
(
SkMatrix
:
:
kMTransY
)
m
[
i
]
.
get
(
SkMatrix
:
:
kMPersp2
)
}
;
Write
<
float
UniformType
3
3
>
(
SkTAddOffset
<
void
>
(
dst
offset
)
1
mt
)
;
offset
+
=
stride
;
}
}
return
n
*
stride
;
}
public
:
static
uint32_t
WriteUniform
(
SkSLType
type
CType
ctype
void
*
dest
int
n
const
void
*
src
)
{
SkASSERT
(
n
>
=
1
|
|
n
=
=
Uniform
:
:
kNonArray
)
;
switch
(
type
)
{
case
SkSLType
:
:
kShort
:
return
Write
<
int32_t
int16_t
>
(
dest
n
static_cast
<
const
int32_t
*
>
(
src
)
)
;
case
SkSLType
:
:
kShort2
:
return
Write
<
int32_t
int16_t
2
>
(
dest
n
static_cast
<
const
int32_t
*
>
(
src
)
)
;
case
SkSLType
:
:
kShort3
:
return
Write
<
int32_t
int16_t
3
>
(
dest
n
static_cast
<
const
int32_t
*
>
(
src
)
)
;
case
SkSLType
:
:
kShort4
:
return
Write
<
int32_t
int16_t
4
>
(
dest
n
static_cast
<
const
int32_t
*
>
(
src
)
)
;
case
SkSLType
:
:
kInt
:
return
Write
<
int32_t
int32_t
>
(
dest
n
static_cast
<
const
int32_t
*
>
(
src
)
)
;
case
SkSLType
:
:
kInt2
:
return
Write
<
int32_t
int32_t
2
>
(
dest
n
static_cast
<
const
int32_t
*
>
(
src
)
)
;
case
SkSLType
:
:
kInt3
:
return
Write
<
int32_t
int32_t
3
>
(
dest
n
static_cast
<
const
int32_t
*
>
(
src
)
)
;
case
SkSLType
:
:
kInt4
:
return
Write
<
int32_t
int32_t
4
>
(
dest
n
static_cast
<
const
int32_t
*
>
(
src
)
)
;
case
SkSLType
:
:
kHalf
:
return
Write
<
float
SkHalf
>
(
dest
n
static_cast
<
const
float
*
>
(
src
)
)
;
case
SkSLType
:
:
kFloat
:
return
Write
<
float
float
>
(
dest
n
static_cast
<
const
float
*
>
(
src
)
)
;
case
SkSLType
:
:
kHalf2
:
return
Write
<
float
SkHalf
2
>
(
dest
n
static_cast
<
const
float
*
>
(
src
)
)
;
case
SkSLType
:
:
kFloat2
:
return
Write
<
float
float
2
>
(
dest
n
static_cast
<
const
float
*
>
(
src
)
)
;
case
SkSLType
:
:
kHalf3
:
return
Write
<
float
SkHalf
3
>
(
dest
n
static_cast
<
const
float
*
>
(
src
)
)
;
case
SkSLType
:
:
kFloat3
:
return
Write
<
float
float
3
>
(
dest
n
static_cast
<
const
float
*
>
(
src
)
)
;
case
SkSLType
:
:
kHalf4
:
return
Write
<
float
SkHalf
4
>
(
dest
n
static_cast
<
const
float
*
>
(
src
)
)
;
case
SkSLType
:
:
kFloat4
:
return
Write
<
float
float
4
>
(
dest
n
static_cast
<
const
float
*
>
(
src
)
)
;
case
SkSLType
:
:
kHalf2x2
:
return
Write
<
float
SkHalf
2
2
>
(
dest
n
static_cast
<
const
float
*
>
(
src
)
)
;
case
SkSLType
:
:
kFloat2x2
:
return
Write
<
float
float
2
2
>
(
dest
n
static_cast
<
const
float
*
>
(
src
)
)
;
case
SkSLType
:
:
kHalf3x3
:
switch
(
ctype
)
{
case
CType
:
:
kDefault
:
return
Write
<
float
SkHalf
3
3
>
(
dest
n
static_cast
<
const
float
*
>
(
src
)
)
;
case
CType
:
:
kSkMatrix
:
return
WriteSkMatrices
<
SkHalf
>
(
dest
n
static_cast
<
const
SkMatrix
*
>
(
src
)
)
;
}
SkUNREACHABLE
;
case
SkSLType
:
:
kFloat3x3
:
switch
(
ctype
)
{
case
CType
:
:
kDefault
:
return
Write
<
float
float
3
3
>
(
dest
n
static_cast
<
const
float
*
>
(
src
)
)
;
case
CType
:
:
kSkMatrix
:
return
WriteSkMatrices
<
float
>
(
dest
n
static_cast
<
const
SkMatrix
*
>
(
src
)
)
;
}
SkUNREACHABLE
;
case
SkSLType
:
:
kHalf4x4
:
return
Write
<
float
SkHalf
4
4
>
(
dest
n
static_cast
<
const
float
*
>
(
src
)
)
;
case
SkSLType
:
:
kFloat4x4
:
return
Write
<
float
float
4
4
>
(
dest
n
static_cast
<
const
float
*
>
(
src
)
)
;
default
:
SK_ABORT
(
"
Unexpected
uniform
type
"
)
;
}
}
}
;
static
uint32_t
sksltype_to_alignment_mask
(
SkSLType
type
)
{
switch
(
type
)
{
case
SkSLType
:
:
kInt
:
case
SkSLType
:
:
kUInt
:
case
SkSLType
:
:
kFloat
:
return
0x3
;
case
SkSLType
:
:
kInt2
:
case
SkSLType
:
:
kUInt2
:
case
SkSLType
:
:
kFloat2
:
return
0x7
;
case
SkSLType
:
:
kInt3
:
case
SkSLType
:
:
kUInt3
:
case
SkSLType
:
:
kFloat3
:
case
SkSLType
:
:
kInt4
:
case
SkSLType
:
:
kUInt4
:
case
SkSLType
:
:
kFloat4
:
return
0xF
;
case
SkSLType
:
:
kFloat2x2
:
return
0x7
;
case
SkSLType
:
:
kFloat3x3
:
return
0xF
;
case
SkSLType
:
:
kFloat4x4
:
return
0xF
;
case
SkSLType
:
:
kShort
:
case
SkSLType
:
:
kUShort
:
case
SkSLType
:
:
kHalf
:
return
0x1
;
case
SkSLType
:
:
kShort2
:
case
SkSLType
:
:
kUShort2
:
case
SkSLType
:
:
kHalf2
:
return
0x3
;
case
SkSLType
:
:
kShort3
:
case
SkSLType
:
:
kShort4
:
case
SkSLType
:
:
kUShort3
:
case
SkSLType
:
:
kUShort4
:
case
SkSLType
:
:
kHalf3
:
case
SkSLType
:
:
kHalf4
:
return
0x7
;
case
SkSLType
:
:
kHalf2x2
:
return
0x3
;
case
SkSLType
:
:
kHalf3x3
:
return
0x7
;
case
SkSLType
:
:
kHalf4x4
:
return
0x7
;
case
SkSLType
:
:
kVoid
:
case
SkSLType
:
:
kBool
:
case
SkSLType
:
:
kBool2
:
case
SkSLType
:
:
kBool3
:
case
SkSLType
:
:
kBool4
:
case
SkSLType
:
:
kTexture2DSampler
:
case
SkSLType
:
:
kTextureExternalSampler
:
case
SkSLType
:
:
kTexture2DRectSampler
:
case
SkSLType
:
:
kSampler
:
case
SkSLType
:
:
kTexture2D
:
case
SkSLType
:
:
kInput
:
break
;
}
SK_ABORT
(
"
Unexpected
type
"
)
;
}
static
uint32_t
get_ubo_aligned_offset
(
Layout
layout
uint32_t
currentOffset
SkSLType
type
bool
isArray
)
{
uint32_t
alignmentMask
;
if
(
layout
=
=
Layout
:
:
kStd140
&
&
isArray
)
{
alignmentMask
=
sksltype_to_alignment_mask
(
SkSLType
:
:
kFloat4
)
;
}
else
{
alignmentMask
=
sksltype_to_alignment_mask
(
type
)
;
}
return
(
currentOffset
+
alignmentMask
)
&
~
alignmentMask
;
}
SkSLType
UniformOffsetCalculator
:
:
getUniformTypeForLayout
(
SkSLType
type
)
{
if
(
fLayout
!
=
Layout
:
:
kMetal
)
{
switch
(
type
)
{
case
SkSLType
:
:
kShort
:
return
SkSLType
:
:
kInt
;
case
SkSLType
:
:
kUShort
:
return
SkSLType
:
:
kUInt
;
case
SkSLType
:
:
kHalf
:
return
SkSLType
:
:
kFloat
;
case
SkSLType
:
:
kShort2
:
return
SkSLType
:
:
kInt2
;
case
SkSLType
:
:
kUShort2
:
return
SkSLType
:
:
kUInt2
;
case
SkSLType
:
:
kHalf2
:
return
SkSLType
:
:
kFloat2
;
case
SkSLType
:
:
kShort3
:
return
SkSLType
:
:
kInt3
;
case
SkSLType
:
:
kUShort3
:
return
SkSLType
:
:
kUInt3
;
case
SkSLType
:
:
kHalf3
:
return
SkSLType
:
:
kFloat3
;
case
SkSLType
:
:
kShort4
:
return
SkSLType
:
:
kInt4
;
case
SkSLType
:
:
kUShort4
:
return
SkSLType
:
:
kUInt4
;
case
SkSLType
:
:
kHalf4
:
return
SkSLType
:
:
kFloat4
;
case
SkSLType
:
:
kHalf2x2
:
return
SkSLType
:
:
kFloat2x2
;
case
SkSLType
:
:
kHalf3x3
:
return
SkSLType
:
:
kFloat3x3
;
case
SkSLType
:
:
kHalf4x4
:
return
SkSLType
:
:
kFloat4x4
;
default
:
break
;
}
}
return
type
;
}
void
UniformOffsetCalculator
:
:
setLayout
(
Layout
layout
)
{
fLayout
=
layout
;
switch
(
layout
)
{
case
Layout
:
:
kStd140
:
fWriteUniform
=
Writer
<
Rules140
>
:
:
WriteUniform
;
break
;
case
Layout
:
:
kStd430
:
fWriteUniform
=
Writer
<
Rules430
>
:
:
WriteUniform
;
break
;
case
Layout
:
:
kMetal
:
fWriteUniform
=
Writer
<
RulesMetal
>
:
:
WriteUniform
;
break
;
case
Layout
:
:
kInvalid
:
SK_ABORT
(
"
Invalid
layout
type
"
)
;
break
;
}
}
UniformOffsetCalculator
:
:
UniformOffsetCalculator
(
Layout
layout
uint32_t
startingOffset
)
:
fLayout
(
layout
)
fOffset
(
startingOffset
)
{
this
-
>
setLayout
(
fLayout
)
;
}
size_t
UniformOffsetCalculator
:
:
advanceOffset
(
SkSLType
type
unsigned
int
count
)
{
SkSLType
revisedType
=
this
-
>
getUniformTypeForLayout
(
type
)
;
uint32_t
alignedOffset
=
get_ubo_aligned_offset
(
fLayout
fOffset
revisedType
count
!
=
Uniform
:
:
kNonArray
)
;
SkASSERT
(
alignedOffset
>
=
fOffset
)
;
uint32_t
uniformSize
=
fWriteUniform
(
revisedType
CType
:
:
kDefault
nullptr
count
nullptr
)
;
fOffset
=
alignedOffset
+
uniformSize
;
return
alignedOffset
;
}
UniformDataBlock
UniformManager
:
:
finishUniformDataBlock
(
)
{
size_t
size
=
SkAlignTo
(
fStorage
.
size
(
)
fReqAlignment
)
;
size_t
paddingSize
=
size
-
fStorage
.
size
(
)
;
char
*
padding
=
fStorage
.
append
(
paddingSize
)
;
memset
(
padding
0
paddingSize
)
;
return
UniformDataBlock
(
SkSpan
(
fStorage
.
begin
(
)
size
)
)
;
}
void
UniformManager
:
:
resetWithNewLayout
(
Layout
layout
)
{
if
(
layout
!
=
fLayout
)
{
this
-
>
setLayout
(
layout
)
;
}
this
-
>
reset
(
)
;
}
void
UniformManager
:
:
reset
(
)
{
fOffset
=
0
;
fReqAlignment
=
0
;
fStorage
.
clear
(
)
;
}
void
UniformManager
:
:
checkReset
(
)
const
{
SkASSERT
(
fOffset
=
=
0
)
;
SkASSERT
(
fStorage
.
empty
(
)
)
;
}
void
UniformManager
:
:
setExpectedUniforms
(
SkSpan
<
const
Uniform
>
expectedUniforms
)
{
SkDEBUGCODE
(
fExpectedUniforms
=
expectedUniforms
;
)
SkDEBUGCODE
(
fExpectedUniformIndex
=
0
;
)
}
void
UniformManager
:
:
checkExpected
(
SkSLType
type
unsigned
int
count
)
{
SkASSERT
(
fExpectedUniforms
.
size
(
)
)
;
SkASSERT
(
fExpectedUniformIndex
>
=
0
&
&
fExpectedUniformIndex
<
(
int
)
fExpectedUniforms
.
size
(
)
)
;
SkASSERT
(
fExpectedUniforms
[
fExpectedUniformIndex
]
.
type
(
)
=
=
type
)
;
SkASSERT
(
(
fExpectedUniforms
[
fExpectedUniformIndex
]
.
count
(
)
=
=
0
&
&
count
=
=
1
)
|
|
fExpectedUniforms
[
fExpectedUniformIndex
]
.
count
(
)
=
=
count
)
;
SkDEBUGCODE
(
fExpectedUniformIndex
+
+
;
)
}
void
UniformManager
:
:
doneWithExpectedUniforms
(
)
{
SkASSERT
(
fExpectedUniformIndex
=
=
static_cast
<
int
>
(
fExpectedUniforms
.
size
(
)
)
)
;
SkDEBUGCODE
(
fExpectedUniforms
=
{
}
;
)
}
void
UniformManager
:
:
writeInternal
(
SkSLType
type
unsigned
int
count
const
void
*
src
)
{
SkSLType
revisedType
=
this
-
>
getUniformTypeForLayout
(
type
)
;
const
uint32_t
startOffset
=
fOffset
;
const
uint32_t
alignedStartOffset
=
this
-
>
advanceOffset
(
revisedType
count
)
;
SkASSERT
(
fOffset
>
alignedStartOffset
)
;
const
uint32_t
bytesNeeded
=
fOffset
-
alignedStartOffset
;
if
(
alignedStartOffset
>
startOffset
)
{
fStorage
.
append
(
alignedStartOffset
-
startOffset
)
;
}
char
*
dst
=
fStorage
.
append
(
bytesNeeded
)
;
[
[
maybe_unused
]
]
uint32_t
bytesWritten
=
fWriteUniform
(
revisedType
CType
:
:
kDefault
dst
count
src
)
;
SkASSERT
(
bytesNeeded
=
=
bytesWritten
)
;
fReqAlignment
=
std
:
:
max
(
fReqAlignment
sksltype_to_alignment_mask
(
revisedType
)
+
1
)
;
}
void
UniformManager
:
:
write
(
SkSLType
type
const
void
*
src
)
{
this
-
>
checkExpected
(
type
1
)
;
this
-
>
writeInternal
(
type
Uniform
:
:
kNonArray
src
)
;
}
void
UniformManager
:
:
writeArray
(
SkSLType
type
const
void
*
src
unsigned
int
count
)
{
if
(
count
>
0
)
{
this
-
>
checkExpected
(
type
count
)
;
this
-
>
writeInternal
(
type
count
src
)
;
}
}
void
UniformManager
:
:
write
(
const
Uniform
&
u
const
uint8_t
*
src
)
{
this
-
>
checkExpected
(
u
.
type
(
)
(
u
.
count
(
)
=
=
Uniform
:
:
kNonArray
)
?
1
:
u
.
count
(
)
)
;
this
-
>
writeInternal
(
u
.
type
(
)
u
.
count
(
)
src
)
;
}
void
UniformManager
:
:
write
(
const
SkM44
&
mat
)
{
static
constexpr
SkSLType
kType
=
SkSLType
:
:
kFloat4x4
;
this
-
>
write
(
kType
&
mat
)
;
}
void
UniformManager
:
:
write
(
const
SkPMColor4f
&
color
)
{
static
constexpr
SkSLType
kType
=
SkSLType
:
:
kFloat4
;
this
-
>
write
(
kType
&
color
)
;
}
void
UniformManager
:
:
write
(
const
SkRect
&
rect
)
{
static
constexpr
SkSLType
kType
=
SkSLType
:
:
kFloat4
;
this
-
>
write
(
kType
&
rect
)
;
}
void
UniformManager
:
:
write
(
const
SkPoint
&
point
)
{
static
constexpr
SkSLType
kType
=
SkSLType
:
:
kFloat2
;
this
-
>
write
(
kType
&
point
)
;
}
void
UniformManager
:
:
write
(
float
f
)
{
static
constexpr
SkSLType
kType
=
SkSLType
:
:
kFloat
;
this
-
>
write
(
kType
&
f
)
;
}
void
UniformManager
:
:
write
(
int
i
)
{
static
constexpr
SkSLType
kType
=
SkSLType
:
:
kInt
;
this
-
>
write
(
kType
&
i
)
;
}
void
UniformManager
:
:
write
(
const
SkV2
&
v
)
{
static
constexpr
SkSLType
kType
=
SkSLType
:
:
kFloat2
;
this
-
>
write
(
kType
&
v
)
;
}
void
UniformManager
:
:
write
(
const
SkV4
&
v
)
{
static
constexpr
SkSLType
kType
=
SkSLType
:
:
kFloat4
;
this
-
>
write
(
kType
&
v
)
;
}
void
UniformManager
:
:
writeArray
(
SkSpan
<
const
SkColor4f
>
arr
)
{
static
constexpr
SkSLType
kType
=
SkSLType
:
:
kFloat4
;
this
-
>
writeArray
(
kType
arr
.
data
(
)
arr
.
size
(
)
)
;
}
void
UniformManager
:
:
writeArray
(
SkSpan
<
const
SkPMColor4f
>
arr
)
{
static
constexpr
SkSLType
kType
=
SkSLType
:
:
kFloat4
;
this
-
>
writeArray
(
kType
arr
.
data
(
)
arr
.
size
(
)
)
;
}
void
UniformManager
:
:
writeArray
(
SkSpan
<
const
float
>
arr
)
{
static
constexpr
SkSLType
kType
=
SkSLType
:
:
kFloat
;
this
-
>
writeArray
(
kType
arr
.
data
(
)
arr
.
size
(
)
)
;
}
void
UniformManager
:
:
writeHalf
(
const
SkMatrix
&
mat
)
{
static
constexpr
SkSLType
kType
=
SkSLType
:
:
kHalf3x3
;
this
-
>
write
(
kType
&
mat
)
;
}
void
UniformManager
:
:
writeHalfArray
(
SkSpan
<
const
float
>
arr
)
{
static
constexpr
SkSLType
kType
=
SkSLType
:
:
kHalf
;
this
-
>
writeArray
(
kType
arr
.
data
(
)
arr
.
size
(
)
)
;
}
}
