#
include
"
src
/
gpu
/
graphite
/
ImageUtils
.
h
"
#
include
"
include
/
gpu
/
graphite
/
ImageProvider
.
h
"
#
include
"
include
/
gpu
/
graphite
/
Recorder
.
h
"
#
include
"
src
/
core
/
SkSamplingPriv
.
h
"
#
include
"
src
/
image
/
SkImage_Base
.
h
"
namespace
{
bool
valid_client_provided_image
(
const
SkImage
*
clientProvided
const
SkImage
*
original
SkImage
:
:
RequiredImageProperties
requiredProps
)
{
if
(
!
clientProvided
|
|
!
as_IB
(
clientProvided
)
-
>
isGraphiteBacked
(
)
|
|
original
-
>
dimensions
(
)
!
=
clientProvided
-
>
dimensions
(
)
|
|
original
-
>
alphaType
(
)
!
=
clientProvided
-
>
alphaType
(
)
)
{
return
false
;
}
uint32_t
origChannels
=
SkColorTypeChannelFlags
(
original
-
>
colorType
(
)
)
;
uint32_t
clientChannels
=
SkColorTypeChannelFlags
(
clientProvided
-
>
colorType
(
)
)
;
if
(
origChannels
!
=
clientChannels
)
{
return
false
;
}
return
true
;
}
}
namespace
skgpu
:
:
graphite
{
std
:
:
pair
<
sk_sp
<
SkImage
>
SkSamplingOptions
>
GetGraphiteBacked
(
Recorder
*
recorder
const
SkImage
*
imageIn
SkSamplingOptions
sampling
)
{
skgpu
:
:
Mipmapped
mipmapped
=
(
sampling
.
mipmap
!
=
SkMipmapMode
:
:
kNone
)
?
skgpu
:
:
Mipmapped
:
:
kYes
:
skgpu
:
:
Mipmapped
:
:
kNo
;
if
(
imageIn
-
>
dimensions
(
)
.
area
(
)
<
=
1
&
&
mipmapped
=
=
skgpu
:
:
Mipmapped
:
:
kYes
)
{
mipmapped
=
skgpu
:
:
Mipmapped
:
:
kNo
;
sampling
=
SkSamplingOptions
(
SkFilterMode
:
:
kLinear
SkMipmapMode
:
:
kNone
)
;
}
sk_sp
<
SkImage
>
result
;
if
(
as_IB
(
imageIn
)
-
>
isGraphiteBacked
(
)
)
{
result
=
sk_ref_sp
(
imageIn
)
;
if
(
mipmapped
=
=
skgpu
:
:
Mipmapped
:
:
kYes
&
&
!
result
-
>
hasMipmaps
(
)
)
{
mipmapped
=
skgpu
:
:
Mipmapped
:
:
kNo
;
sampling
=
SkSamplingOptions
(
SkFilterMode
:
:
kLinear
SkMipmapMode
:
:
kNone
)
;
}
}
else
{
auto
clientImageProvider
=
recorder
-
>
clientImageProvider
(
)
;
result
=
clientImageProvider
-
>
findOrCreate
(
recorder
imageIn
{
mipmapped
}
)
;
if
(
!
valid_client_provided_image
(
result
.
get
(
)
imageIn
{
mipmapped
}
)
)
{
result
=
nullptr
;
}
}
if
(
sampling
.
isAniso
(
)
&
&
result
)
{
sampling
=
SkSamplingPriv
:
:
AnisoFallback
(
result
-
>
hasMipmaps
(
)
)
;
}
return
{
result
sampling
}
;
}
}
