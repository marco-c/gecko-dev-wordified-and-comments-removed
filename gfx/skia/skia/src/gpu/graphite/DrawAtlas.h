#
ifndef
skgpu_graphite_DrawAtlas_DEFINED
#
define
skgpu_graphite_DrawAtlas_DEFINED
#
include
<
cmath
>
#
include
<
string
>
#
include
<
string_view
>
#
include
<
vector
>
#
include
"
src
/
core
/
SkIPoint16
.
h
"
#
include
"
src
/
core
/
SkTHash
.
h
"
#
include
"
src
/
gpu
/
AtlasTypes
.
h
"
#
include
"
src
/
gpu
/
RectanizerSkyline
.
h
"
namespace
skgpu
:
:
graphite
{
class
Recorder
;
class
UploadList
;
class
TextureProxy
;
class
DrawAtlas
{
public
:
enum
class
AllowMultitexturing
:
bool
{
kNo
kYes
}
;
static
std
:
:
unique_ptr
<
DrawAtlas
>
Make
(
SkColorType
ct
size_t
bpp
int
width
int
height
int
plotWidth
int
plotHeight
AtlasGenerationCounter
*
generationCounter
AllowMultitexturing
allowMultitexturing
PlotEvictionCallback
*
evictor
std
:
:
string_view
label
)
;
enum
class
ErrorCode
{
kError
kSucceeded
kTryAgain
}
;
ErrorCode
addToAtlas
(
Recorder
*
int
width
int
height
const
void
*
image
AtlasLocator
*
)
;
bool
recordUploads
(
UploadList
*
Recorder
*
bool
useCachedUploads
)
;
const
sk_sp
<
TextureProxy
>
*
getProxies
(
)
const
{
return
fProxies
;
}
uint32_t
atlasID
(
)
const
{
return
fAtlasID
;
}
uint64_t
atlasGeneration
(
)
const
{
return
fAtlasGeneration
;
}
bool
hasID
(
const
PlotLocator
&
plotLocator
)
{
if
(
!
plotLocator
.
isValid
(
)
)
{
return
false
;
}
uint32_t
plot
=
plotLocator
.
plotIndex
(
)
;
uint32_t
page
=
plotLocator
.
pageIndex
(
)
;
uint64_t
plotGeneration
=
fPages
[
page
]
.
fPlotArray
[
plot
]
-
>
genID
(
)
;
uint64_t
locatorGeneration
=
plotLocator
.
genID
(
)
;
return
plot
<
fNumPlots
&
&
page
<
fNumActivePages
&
&
plotGeneration
=
=
locatorGeneration
;
}
void
setLastUseToken
(
const
AtlasLocator
&
atlasLocator
AtlasToken
token
)
{
SkASSERT
(
this
-
>
hasID
(
atlasLocator
.
plotLocator
(
)
)
)
;
uint32_t
plotIdx
=
atlasLocator
.
plotIndex
(
)
;
SkASSERT
(
plotIdx
<
fNumPlots
)
;
uint32_t
pageIdx
=
atlasLocator
.
pageIndex
(
)
;
SkASSERT
(
pageIdx
<
fNumActivePages
)
;
Plot
*
plot
=
fPages
[
pageIdx
]
.
fPlotArray
[
plotIdx
]
.
get
(
)
;
this
-
>
makeMRU
(
plot
pageIdx
)
;
plot
-
>
setLastUseToken
(
token
)
;
}
uint32_t
numActivePages
(
)
{
return
fNumActivePages
;
}
void
setLastUseTokenBulk
(
const
BulkUsePlotUpdater
&
updater
AtlasToken
token
)
{
int
count
=
updater
.
count
(
)
;
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
const
BulkUsePlotUpdater
:
:
PlotData
&
pd
=
updater
.
plotData
(
i
)
;
if
(
pd
.
fPageIndex
<
fNumActivePages
)
{
Plot
*
plot
=
fPages
[
pd
.
fPageIndex
]
.
fPlotArray
[
pd
.
fPlotIndex
]
.
get
(
)
;
this
-
>
makeMRU
(
plot
pd
.
fPageIndex
)
;
plot
-
>
setLastUseToken
(
token
)
;
}
}
}
void
compact
(
AtlasToken
startTokenForNextFlush
)
;
void
evictAllPlots
(
)
;
uint32_t
maxPages
(
)
const
{
return
fMaxPages
;
}
int
numAllocated_TestingOnly
(
)
const
;
void
setMaxPages_TestingOnly
(
uint32_t
maxPages
)
;
private
:
DrawAtlas
(
SkColorType
size_t
bpp
int
width
int
height
int
plotWidth
int
plotHeight
AtlasGenerationCounter
*
generationCounter
AllowMultitexturing
allowMultitexturing
std
:
:
string_view
label
)
;
bool
updatePlot
(
AtlasLocator
*
Plot
*
plot
)
;
inline
void
makeMRU
(
Plot
*
plot
int
pageIdx
)
{
if
(
fPages
[
pageIdx
]
.
fPlotList
.
head
(
)
=
=
plot
)
{
return
;
}
fPages
[
pageIdx
]
.
fPlotList
.
remove
(
plot
)
;
fPages
[
pageIdx
]
.
fPlotList
.
addToHead
(
plot
)
;
}
bool
addToPage
(
unsigned
int
pageIdx
int
width
int
height
const
void
*
image
AtlasLocator
*
)
;
bool
createPages
(
AtlasGenerationCounter
*
)
;
bool
activateNewPage
(
Recorder
*
)
;
void
deactivateLastPage
(
)
;
void
processEviction
(
PlotLocator
)
;
inline
void
processEvictionAndResetRects
(
Plot
*
plot
)
{
this
-
>
processEviction
(
plot
-
>
plotLocator
(
)
)
;
plot
-
>
resetRects
(
)
;
}
SkColorType
fColorType
;
size_t
fBytesPerPixel
;
int
fTextureWidth
;
int
fTextureHeight
;
int
fPlotWidth
;
int
fPlotHeight
;
unsigned
int
fNumPlots
;
const
std
:
:
string
fLabel
;
uint32_t
fAtlasID
;
AtlasGenerationCounter
*
const
fGenerationCounter
;
uint64_t
fAtlasGeneration
;
AtlasToken
fPrevFlushToken
;
int
fFlushesSinceLastUse
;
std
:
:
vector
<
PlotEvictionCallback
*
>
fEvictionCallbacks
;
struct
Page
{
std
:
:
unique_ptr
<
sk_sp
<
Plot
>
[
]
>
fPlotArray
;
PlotList
fPlotList
;
}
;
sk_sp
<
TextureProxy
>
fProxies
[
PlotLocator
:
:
kMaxMultitexturePages
]
;
Page
fPages
[
PlotLocator
:
:
kMaxMultitexturePages
]
;
uint32_t
fMaxPages
;
uint32_t
fNumActivePages
;
SkDEBUGCODE
(
void
validate
(
const
AtlasLocator
&
atlasLocator
)
const
;
)
}
;
class
DrawAtlasConfig
{
public
:
DrawAtlasConfig
(
int
maxTextureSize
size_t
maxBytes
)
;
SkISize
atlasDimensions
(
MaskFormat
type
)
const
;
SkISize
plotDimensions
(
MaskFormat
type
)
const
;
private
:
inline
static
constexpr
int
kMaxAtlasDim
=
2048
;
SkISize
fARGBDimensions
;
int
fMaxTextureSize
;
}
;
class
PlotUploadTracker
{
public
:
PlotUploadTracker
(
)
=
default
;
bool
needsUpload
(
PlotLocator
plotLocator
AtlasToken
uploadToken
uint32_t
atlasID
)
;
private
:
struct
PlotAgeData
{
uint64_t
genID
;
AtlasToken
uploadToken
;
}
;
using
PlotAgeHashMap
=
SkTHashMap
<
uint32_t
PlotAgeData
>
;
SkTHashMap
<
uint32_t
PlotAgeHashMap
>
fAtlasData
;
}
;
}
#
endif
