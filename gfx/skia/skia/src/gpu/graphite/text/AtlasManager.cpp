#
include
"
src
/
gpu
/
graphite
/
text
/
AtlasManager
.
h
"
#
include
"
include
/
core
/
SkColorSpace
.
h
"
#
include
"
include
/
gpu
/
graphite
/
Recorder
.
h
"
#
include
"
src
/
base
/
SkAutoMalloc
.
h
"
#
include
"
src
/
codec
/
SkMasks
.
h
"
#
include
"
src
/
core
/
SkDistanceFieldGen
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawAtlas
.
h
"
#
include
"
src
/
gpu
/
graphite
/
RecorderPriv
.
h
"
#
include
"
src
/
gpu
/
graphite
/
TextureProxy
.
h
"
#
include
"
src
/
sksl
/
SkSLUtil
.
h
"
#
include
"
src
/
text
/
gpu
/
Glyph
.
h
"
#
include
"
src
/
text
/
gpu
/
GlyphVector
.
h
"
#
include
"
src
/
text
/
gpu
/
StrikeCache
.
h
"
using
Glyph
=
sktext
:
:
gpu
:
:
Glyph
;
namespace
skgpu
:
:
graphite
{
AtlasManager
:
:
AtlasManager
(
Recorder
*
recorder
)
:
fRecorder
(
recorder
)
fSupportBilerpAtlas
{
recorder
-
>
priv
(
)
.
caps
(
)
-
>
supportBilerpFromGlyphAtlas
(
)
}
fAtlasConfig
{
recorder
-
>
priv
(
)
.
caps
(
)
-
>
maxTextureSize
(
)
recorder
-
>
priv
(
)
.
caps
(
)
-
>
glyphCacheTextureMaximumBytes
(
)
}
{
if
(
!
recorder
-
>
priv
(
)
.
caps
(
)
-
>
allowMultipleGlyphCacheTextures
(
)
|
|
!
(
recorder
-
>
priv
(
)
.
caps
(
)
-
>
shaderCaps
(
)
-
>
fFloatIs32Bits
|
|
recorder
-
>
priv
(
)
.
caps
(
)
-
>
shaderCaps
(
)
-
>
fIntegerSupport
)
)
{
fAllowMultitexturing
=
DrawAtlas
:
:
AllowMultitexturing
:
:
kNo
;
}
else
{
fAllowMultitexturing
=
DrawAtlas
:
:
AllowMultitexturing
:
:
kYes
;
}
}
AtlasManager
:
:
~
AtlasManager
(
)
=
default
;
void
AtlasManager
:
:
freeAll
(
)
{
for
(
int
i
=
0
;
i
<
kMaskFormatCount
;
+
+
i
)
{
fAtlases
[
i
]
=
nullptr
;
}
}
bool
AtlasManager
:
:
hasGlyph
(
MaskFormat
format
Glyph
*
glyph
)
{
SkASSERT
(
glyph
)
;
return
this
-
>
getAtlas
(
format
)
-
>
hasID
(
glyph
-
>
fAtlasLocator
.
plotLocator
(
)
)
;
}
template
<
typename
INT_TYPE
>
static
void
expand_bits
(
INT_TYPE
*
dst
const
uint8_t
*
src
int
width
int
height
int
dstRowBytes
int
srcRowBytes
)
{
for
(
int
y
=
0
;
y
<
height
;
+
+
y
)
{
int
rowWritesLeft
=
width
;
const
uint8_t
*
s
=
src
;
INT_TYPE
*
d
=
dst
;
while
(
rowWritesLeft
>
0
)
{
unsigned
mask
=
*
s
+
+
;
for
(
int
x
=
7
;
x
>
=
0
&
&
rowWritesLeft
;
-
-
x
-
-
rowWritesLeft
)
{
*
d
+
+
=
(
mask
&
(
1
<
<
x
)
)
?
(
INT_TYPE
)
(
~
0UL
)
:
0
;
}
}
dst
=
reinterpret_cast
<
INT_TYPE
*
>
(
reinterpret_cast
<
intptr_t
>
(
dst
)
+
dstRowBytes
)
;
src
+
=
srcRowBytes
;
}
}
static
void
get_packed_glyph_image
(
const
SkGlyph
&
glyph
int
dstRB
MaskFormat
expectedMaskFormat
void
*
dst
)
{
const
int
width
=
glyph
.
width
(
)
;
const
int
height
=
glyph
.
height
(
)
;
const
void
*
src
=
glyph
.
image
(
)
;
SkASSERT
(
src
!
=
nullptr
)
;
MaskFormat
maskFormat
=
Glyph
:
:
FormatFromSkGlyph
(
glyph
.
maskFormat
(
)
)
;
if
(
maskFormat
=
=
expectedMaskFormat
)
{
int
srcRB
=
glyph
.
rowBytes
(
)
;
if
(
glyph
.
maskFormat
(
)
!
=
SkMask
:
:
kBW_Format
)
{
if
(
srcRB
!
=
dstRB
)
{
const
int
bbp
=
MaskFormatBytesPerPixel
(
expectedMaskFormat
)
;
for
(
int
y
=
0
;
y
<
height
;
y
+
+
)
{
memcpy
(
dst
src
width
*
bbp
)
;
src
=
(
const
char
*
)
src
+
srcRB
;
dst
=
(
char
*
)
dst
+
dstRB
;
}
}
else
{
memcpy
(
dst
src
dstRB
*
height
)
;
}
}
else
{
const
uint8_t
*
bits
=
reinterpret_cast
<
const
uint8_t
*
>
(
src
)
;
switch
(
expectedMaskFormat
)
{
case
MaskFormat
:
:
kA8
:
{
uint8_t
*
bytes
=
reinterpret_cast
<
uint8_t
*
>
(
dst
)
;
expand_bits
(
bytes
bits
width
height
dstRB
srcRB
)
;
break
;
}
case
MaskFormat
:
:
kA565
:
{
uint16_t
*
rgb565
=
reinterpret_cast
<
uint16_t
*
>
(
dst
)
;
expand_bits
(
rgb565
bits
width
height
dstRB
srcRB
)
;
break
;
}
default
:
SK_ABORT
(
"
Invalid
MaskFormat
"
)
;
}
}
}
else
if
(
maskFormat
=
=
MaskFormat
:
:
kA565
&
&
expectedMaskFormat
=
=
MaskFormat
:
:
kARGB
)
{
static
constexpr
SkMasks
masks
{
{
0b1111
'
1000
'
0000
'
0000
11
5
}
{
0b0000
'
0111
'
1110
'
0000
5
6
}
{
0b0000
'
0000
'
0001
'
1111
0
5
}
{
0
0
0
}
}
;
constexpr
int
a565Bpp
=
MaskFormatBytesPerPixel
(
MaskFormat
:
:
kA565
)
;
constexpr
int
argbBpp
=
MaskFormatBytesPerPixel
(
MaskFormat
:
:
kARGB
)
;
char
*
dstRow
=
(
char
*
)
dst
;
for
(
int
y
=
0
;
y
<
height
;
y
+
+
)
{
dst
=
dstRow
;
for
(
int
x
=
0
;
x
<
width
;
x
+
+
)
{
uint16_t
color565
=
0
;
memcpy
(
&
color565
src
a565Bpp
)
;
uint32_t
colorRGBA
=
masks
.
getRed
(
color565
)
|
(
masks
.
getGreen
(
color565
)
<
<
8
)
|
(
masks
.
getBlue
(
color565
)
<
<
16
)
|
(
0xFF
<
<
24
)
;
memcpy
(
dst
&
colorRGBA
argbBpp
)
;
src
=
(
char
*
)
src
+
a565Bpp
;
dst
=
(
char
*
)
dst
+
argbBpp
;
}
dstRow
+
=
dstRB
;
}
}
else
{
SkUNREACHABLE
;
}
}
MaskFormat
AtlasManager
:
:
resolveMaskFormat
(
MaskFormat
format
)
const
{
if
(
MaskFormat
:
:
kA565
=
=
format
&
&
!
fRecorder
-
>
priv
(
)
.
caps
(
)
-
>
getDefaultSampledTextureInfo
(
kRGB_565_SkColorType
Mipmapped
:
:
kNo
Protected
:
:
kNo
Renderable
:
:
kNo
)
.
isValid
(
)
)
{
format
=
MaskFormat
:
:
kARGB
;
}
return
format
;
}
DrawAtlas
:
:
ErrorCode
AtlasManager
:
:
addGlyphToAtlas
(
const
SkGlyph
&
skGlyph
Glyph
*
glyph
int
srcPadding
)
{
#
if
!
defined
(
SK_DISABLE_SDF_TEXT
)
SkASSERT
(
0
<
=
srcPadding
&
&
srcPadding
<
=
SK_DistanceFieldInset
)
;
#
else
SkASSERT
(
0
<
=
srcPadding
)
;
#
endif
if
(
skGlyph
.
image
(
)
=
=
nullptr
)
{
return
DrawAtlas
:
:
ErrorCode
:
:
kError
;
}
SkASSERT
(
glyph
!
=
nullptr
)
;
MaskFormat
glyphFormat
=
Glyph
:
:
FormatFromSkGlyph
(
skGlyph
.
maskFormat
(
)
)
;
MaskFormat
expectedMaskFormat
=
this
-
>
resolveMaskFormat
(
glyphFormat
)
;
int
bytesPerPixel
=
MaskFormatBytesPerPixel
(
expectedMaskFormat
)
;
int
padding
;
switch
(
srcPadding
)
{
case
0
:
padding
=
0
;
if
(
fSupportBilerpAtlas
)
{
padding
=
1
;
srcPadding
=
1
;
}
break
;
case
1
:
padding
=
1
;
break
;
#
if
!
defined
(
SK_DISABLE_SDF_TEXT
)
case
SK_DistanceFieldInset
:
padding
=
0
;
break
;
#
endif
default
:
return
DrawAtlas
:
:
ErrorCode
:
:
kError
;
}
const
int
width
=
skGlyph
.
width
(
)
+
2
*
padding
;
const
int
height
=
skGlyph
.
height
(
)
+
2
*
padding
;
int
rowBytes
=
width
*
bytesPerPixel
;
size_t
size
=
height
*
rowBytes
;
SkAutoSMalloc
<
1024
>
storage
(
size
)
;
void
*
dataPtr
=
storage
.
get
(
)
;
if
(
padding
>
0
)
{
sk_bzero
(
dataPtr
size
)
;
dataPtr
=
(
char
*
)
(
dataPtr
)
+
rowBytes
+
bytesPerPixel
;
}
get_packed_glyph_image
(
skGlyph
rowBytes
expectedMaskFormat
dataPtr
)
;
DrawAtlas
*
atlas
=
this
-
>
getAtlas
(
expectedMaskFormat
)
;
auto
errorCode
=
atlas
-
>
addToAtlas
(
fRecorder
width
height
storage
.
get
(
)
&
glyph
-
>
fAtlasLocator
)
;
if
(
errorCode
=
=
DrawAtlas
:
:
ErrorCode
:
:
kSucceeded
)
{
glyph
-
>
fAtlasLocator
.
insetSrc
(
srcPadding
)
;
}
return
errorCode
;
}
bool
AtlasManager
:
:
recordUploads
(
UploadList
*
ul
bool
useCachedUploads
)
{
for
(
int
i
=
0
;
i
<
skgpu
:
:
kMaskFormatCount
;
i
+
+
)
{
if
(
fAtlases
[
i
]
&
&
!
fAtlases
[
i
]
-
>
recordUploads
(
ul
fRecorder
useCachedUploads
)
)
{
return
false
;
}
}
fRecorder
-
>
priv
(
)
.
tokenTracker
(
)
-
>
issueFlushToken
(
)
;
return
true
;
}
void
AtlasManager
:
:
addGlyphToBulkAndSetUseToken
(
BulkUsePlotUpdater
*
updater
MaskFormat
format
Glyph
*
glyph
AtlasToken
token
)
{
SkASSERT
(
glyph
)
;
if
(
updater
-
>
add
(
glyph
-
>
fAtlasLocator
)
)
{
this
-
>
getAtlas
(
format
)
-
>
setLastUseToken
(
glyph
-
>
fAtlasLocator
token
)
;
}
}
void
AtlasManager
:
:
setAtlasDimensionsToMinimum_ForTesting
(
)
{
for
(
int
i
=
0
;
i
<
skgpu
:
:
kMaskFormatCount
;
i
+
+
)
{
fAtlases
[
i
]
=
nullptr
;
}
new
(
&
fAtlasConfig
)
DrawAtlasConfig
{
2048
0
}
;
}
bool
AtlasManager
:
:
initAtlas
(
MaskFormat
format
)
{
int
index
=
MaskFormatToAtlasIndex
(
format
)
;
if
(
fAtlases
[
index
]
=
=
nullptr
)
{
SkColorType
colorType
=
MaskFormatToColorType
(
format
)
;
SkISize
atlasDimensions
=
fAtlasConfig
.
atlasDimensions
(
format
)
;
SkISize
plotDimensions
=
fAtlasConfig
.
plotDimensions
(
format
)
;
fAtlases
[
index
]
=
DrawAtlas
:
:
Make
(
colorType
SkColorTypeBytesPerPixel
(
colorType
)
atlasDimensions
.
width
(
)
atlasDimensions
.
height
(
)
plotDimensions
.
width
(
)
plotDimensions
.
height
(
)
this
fAllowMultitexturing
nullptr
"
TextAtlas
"
)
;
if
(
!
fAtlases
[
index
]
)
{
return
false
;
}
}
return
true
;
}
}
namespace
sktext
:
:
gpu
{
using
DrawAtlas
=
skgpu
:
:
graphite
:
:
DrawAtlas
;
std
:
:
tuple
<
bool
int
>
GlyphVector
:
:
regenerateAtlas
(
int
begin
int
end
skgpu
:
:
MaskFormat
maskFormat
int
srcPadding
skgpu
:
:
graphite
:
:
Recorder
*
recorder
)
{
auto
atlasManager
=
recorder
-
>
priv
(
)
.
atlasManager
(
)
;
auto
tokenTracker
=
recorder
-
>
priv
(
)
.
tokenTracker
(
)
;
unsigned
int
numActiveProxies
;
const
sk_sp
<
skgpu
:
:
graphite
:
:
TextureProxy
>
*
proxies
=
atlasManager
-
>
getProxies
(
maskFormat
&
numActiveProxies
)
;
if
(
!
proxies
)
{
SkDebugf
(
"
Could
not
allocate
backing
texture
for
atlas
\
n
"
)
;
return
{
false
0
}
;
}
uint64_t
currentAtlasGen
=
atlasManager
-
>
atlasGeneration
(
maskFormat
)
;
this
-
>
packedGlyphIDToGlyph
(
recorder
-
>
priv
(
)
.
strikeCache
(
)
)
;
if
(
fAtlasGeneration
!
=
currentAtlasGen
)
{
fBulkUseUpdater
.
reset
(
)
;
SkBulkGlyphMetricsAndImages
metricsAndImages
{
fTextStrike
-
>
strikeSpec
(
)
}
;
auto
glyphs
=
fGlyphs
.
subspan
(
begin
end
-
begin
)
;
int
glyphsPlacedInAtlas
=
0
;
bool
success
=
true
;
for
(
const
Variant
&
variant
:
glyphs
)
{
Glyph
*
gpuGlyph
=
variant
.
glyph
;
SkASSERT
(
gpuGlyph
!
=
nullptr
)
;
if
(
!
atlasManager
-
>
hasGlyph
(
maskFormat
gpuGlyph
)
)
{
const
SkGlyph
&
skGlyph
=
*
metricsAndImages
.
glyph
(
gpuGlyph
-
>
fPackedID
)
;
auto
code
=
atlasManager
-
>
addGlyphToAtlas
(
skGlyph
gpuGlyph
srcPadding
)
;
if
(
code
!
=
DrawAtlas
:
:
ErrorCode
:
:
kSucceeded
)
{
success
=
code
!
=
DrawAtlas
:
:
ErrorCode
:
:
kError
;
break
;
}
}
atlasManager
-
>
addGlyphToBulkAndSetUseToken
(
&
fBulkUseUpdater
maskFormat
gpuGlyph
tokenTracker
-
>
nextFlushToken
(
)
)
;
glyphsPlacedInAtlas
+
+
;
}
if
(
success
&
&
begin
+
glyphsPlacedInAtlas
=
=
SkCount
(
fGlyphs
)
)
{
fAtlasGeneration
=
atlasManager
-
>
atlasGeneration
(
maskFormat
)
;
}
return
{
success
glyphsPlacedInAtlas
}
;
}
else
{
if
(
end
=
=
SkCount
(
fGlyphs
)
)
{
atlasManager
-
>
setUseTokenBulk
(
fBulkUseUpdater
tokenTracker
-
>
nextFlushToken
(
)
maskFormat
)
;
}
return
{
true
end
-
begin
}
;
}
}
}
