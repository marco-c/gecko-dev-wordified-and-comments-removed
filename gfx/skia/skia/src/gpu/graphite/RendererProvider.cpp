#
include
"
src
/
gpu
/
graphite
/
RendererProvider
.
h
"
#
include
"
include
/
core
/
SkPathTypes
.
h
"
#
include
"
include
/
core
/
SkVertices
.
h
"
#
include
"
src
/
gpu
/
graphite
/
Caps
.
h
"
#
include
"
src
/
gpu
/
graphite
/
render
/
AnalyticRRectRenderStep
.
h
"
#
include
"
src
/
gpu
/
graphite
/
render
/
BitmapTextRenderStep
.
h
"
#
include
"
src
/
gpu
/
graphite
/
render
/
CommonDepthStencilSettings
.
h
"
#
include
"
src
/
gpu
/
graphite
/
render
/
CoverBoundsRenderStep
.
h
"
#
include
"
src
/
gpu
/
graphite
/
render
/
MiddleOutFanRenderStep
.
h
"
#
include
"
src
/
gpu
/
graphite
/
render
/
SDFTextRenderStep
.
h
"
#
include
"
src
/
gpu
/
graphite
/
render
/
TessellateCurvesRenderStep
.
h
"
#
include
"
src
/
gpu
/
graphite
/
render
/
TessellateStrokesRenderStep
.
h
"
#
include
"
src
/
gpu
/
graphite
/
render
/
TessellateWedgesRenderStep
.
h
"
#
include
"
src
/
gpu
/
graphite
/
render
/
VerticesRenderStep
.
h
"
#
include
"
src
/
sksl
/
SkSLUtil
.
h
"
namespace
skgpu
:
:
graphite
{
RendererProvider
:
:
RendererProvider
(
const
Caps
*
caps
StaticBufferManager
*
bufferManager
)
{
static
constexpr
size_t
kRendererSize
=
offsetof
(
RendererProvider
fRenderers
)
-
offsetof
(
RendererProvider
fStencilTessellatedCurves
)
;
static_assert
(
kRendererSize
%
sizeof
(
Renderer
)
=
=
0
"
Renderer
declarations
are
not
dense
"
)
;
const
bool
infinitySupport
=
caps
-
>
shaderCaps
(
)
-
>
fInfinitySupport
;
auto
makeFromStep
=
[
&
]
(
std
:
:
unique_ptr
<
RenderStep
>
singleStep
DrawTypeFlags
drawTypes
)
{
std
:
:
string
name
=
"
SingleStep
[
"
;
name
+
=
singleStep
-
>
name
(
)
;
name
+
=
"
]
"
;
fRenderSteps
.
push_back
(
std
:
:
move
(
singleStep
)
)
;
return
Renderer
(
name
drawTypes
fRenderSteps
.
back
(
)
.
get
(
)
)
;
}
;
fConvexTessellatedWedges
=
makeFromStep
(
std
:
:
make_unique
<
TessellateWedgesRenderStep
>
(
"
convex
"
infinitySupport
kDirectDepthGreaterPass
bufferManager
)
DrawTypeFlags
:
:
kShape
)
;
fTessellatedStrokes
=
makeFromStep
(
std
:
:
make_unique
<
TessellateStrokesRenderStep
>
(
infinitySupport
)
DrawTypeFlags
:
:
kShape
)
;
fBitmapText
=
makeFromStep
(
std
:
:
make_unique
<
BitmapTextRenderStep
>
(
)
DrawTypeFlags
:
:
kText
)
;
for
(
bool
lcd
:
{
false
true
}
)
{
fSDFText
[
lcd
]
=
makeFromStep
(
std
:
:
make_unique
<
SDFTextRenderStep
>
(
lcd
)
DrawTypeFlags
:
:
kText
)
;
}
fAnalyticRRect
=
makeFromStep
(
std
:
:
make_unique
<
AnalyticRRectRenderStep
>
(
bufferManager
)
DrawTypeFlags
:
:
kShape
)
;
for
(
PrimitiveType
primType
:
{
PrimitiveType
:
:
kTriangles
PrimitiveType
:
:
kTriangleStrip
}
)
{
for
(
bool
color
:
{
false
true
}
)
{
for
(
bool
texCoords
:
{
false
true
}
)
{
int
index
=
4
*
(
primType
=
=
PrimitiveType
:
:
kTriangleStrip
)
+
2
*
color
+
texCoords
;
fVertices
[
index
]
=
makeFromStep
(
std
:
:
make_unique
<
VerticesRenderStep
>
(
primType
color
texCoords
)
DrawTypeFlags
:
:
kDrawVertices
)
;
}
}
}
auto
coverFill
=
std
:
:
make_unique
<
CoverBoundsRenderStep
>
(
false
)
;
auto
coverInverse
=
std
:
:
make_unique
<
CoverBoundsRenderStep
>
(
true
)
;
for
(
bool
evenOdd
:
{
false
true
}
)
{
auto
stencilFan
=
std
:
:
make_unique
<
MiddleOutFanRenderStep
>
(
evenOdd
)
;
auto
stencilCurve
=
std
:
:
make_unique
<
TessellateCurvesRenderStep
>
(
evenOdd
infinitySupport
bufferManager
)
;
auto
stencilWedge
=
evenOdd
?
std
:
:
make_unique
<
TessellateWedgesRenderStep
>
(
"
evenodd
"
infinitySupport
kEvenOddStencilPass
bufferManager
)
:
std
:
:
make_unique
<
TessellateWedgesRenderStep
>
(
"
winding
"
infinitySupport
kWindingStencilPass
bufferManager
)
;
for
(
bool
inverse
:
{
false
true
}
)
{
static
const
char
*
kTessVariants
[
4
]
=
{
"
[
winding
]
"
"
[
evenodd
]
"
"
[
inverse
-
winding
]
"
"
[
inverse
-
evenodd
]
"
}
;
int
index
=
2
*
inverse
+
evenOdd
;
std
:
:
string
variant
=
kTessVariants
[
index
]
;
constexpr
DrawTypeFlags
kTextAndShape
=
static_cast
<
DrawTypeFlags
>
(
DrawTypeFlags
:
:
kText
|
DrawTypeFlags
:
:
kShape
)
;
const
RenderStep
*
coverStep
=
inverse
?
coverInverse
.
get
(
)
:
coverFill
.
get
(
)
;
fStencilTessellatedCurves
[
index
]
=
Renderer
(
"
StencilTessellatedCurvesAndTris
"
+
variant
kTextAndShape
stencilFan
.
get
(
)
stencilCurve
.
get
(
)
coverStep
)
;
fStencilTessellatedWedges
[
index
]
=
Renderer
(
"
StencilTessellatedWedges
"
+
variant
kTextAndShape
stencilWedge
.
get
(
)
coverStep
)
;
}
fRenderSteps
.
push_back
(
std
:
:
move
(
stencilFan
)
)
;
fRenderSteps
.
push_back
(
std
:
:
move
(
stencilCurve
)
)
;
fRenderSteps
.
push_back
(
std
:
:
move
(
stencilWedge
)
)
;
}
fRenderSteps
.
push_back
(
std
:
:
move
(
coverInverse
)
)
;
fRenderSteps
.
push_back
(
std
:
:
move
(
coverFill
)
)
;
SkSpan
<
Renderer
>
allRenderers
=
{
fStencilTessellatedCurves
kRendererSize
/
sizeof
(
Renderer
)
}
;
for
(
const
Renderer
&
r
:
allRenderers
)
{
if
(
r
.
numRenderSteps
(
)
>
0
)
{
fRenderers
.
push_back
(
&
r
)
;
}
}
}
const
RenderStep
*
RendererProvider
:
:
lookup
(
uint32_t
uniqueID
)
const
{
for
(
auto
&
&
rs
:
fRenderSteps
)
{
if
(
rs
-
>
uniqueID
(
)
=
=
uniqueID
)
{
return
rs
.
get
(
)
;
}
}
return
nullptr
;
}
}
