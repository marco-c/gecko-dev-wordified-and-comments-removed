#
include
"
src
/
gpu
/
graphite
/
ResourceCache
.
h
"
#
include
"
include
/
private
/
base
/
SingleOwner
.
h
"
#
include
"
src
/
base
/
SkRandom
.
h
"
#
include
"
src
/
core
/
SkTMultiMap
.
h
"
#
include
"
src
/
gpu
/
graphite
/
GraphiteResourceKey
.
h
"
#
include
"
src
/
gpu
/
graphite
/
Resource
.
h
"
namespace
skgpu
:
:
graphite
{
#
define
ASSERT_SINGLE_OWNER
SKGPU_ASSERT_SINGLE_OWNER
(
fSingleOwner
)
sk_sp
<
ResourceCache
>
ResourceCache
:
:
Make
(
SingleOwner
*
singleOwner
)
{
return
sk_sp
<
ResourceCache
>
(
new
ResourceCache
(
singleOwner
)
)
;
}
ResourceCache
:
:
ResourceCache
(
SingleOwner
*
singleOwner
)
:
fSingleOwner
(
singleOwner
)
{
#
ifndef
SK_DEBUG
(
void
)
fSingleOwner
;
#
endif
}
ResourceCache
:
:
~
ResourceCache
(
)
{
SkASSERT
(
fIsShutdown
)
;
}
void
ResourceCache
:
:
shutdown
(
)
{
ASSERT_SINGLE_OWNER
SkASSERT
(
!
fIsShutdown
)
;
{
SkAutoMutexExclusive
locked
(
fReturnMutex
)
;
fIsShutdown
=
true
;
}
this
-
>
processReturnedResources
(
)
;
while
(
fNonpurgeableResources
.
size
(
)
)
{
Resource
*
back
=
*
(
fNonpurgeableResources
.
end
(
)
-
1
)
;
SkASSERT
(
!
back
-
>
wasDestroyed
(
)
)
;
this
-
>
removeFromNonpurgeableArray
(
back
)
;
back
-
>
unrefCache
(
)
;
}
while
(
fPurgeableQueue
.
count
(
)
)
{
Resource
*
top
=
fPurgeableQueue
.
peek
(
)
;
SkASSERT
(
!
top
-
>
wasDestroyed
(
)
)
;
this
-
>
removeFromPurgeableQueue
(
top
)
;
top
-
>
unrefCache
(
)
;
}
}
void
ResourceCache
:
:
insertResource
(
Resource
*
resource
)
{
ASSERT_SINGLE_OWNER
SkASSERT
(
resource
)
;
SkASSERT
(
!
this
-
>
isInCache
(
resource
)
)
;
SkASSERT
(
!
resource
-
>
wasDestroyed
(
)
)
;
SkASSERT
(
!
resource
-
>
isPurgeable
(
)
)
;
SkASSERT
(
resource
-
>
key
(
)
.
isValid
(
)
)
;
SkASSERT
(
resource
-
>
ownership
(
)
=
=
Ownership
:
:
kOwned
)
;
this
-
>
processReturnedResources
(
)
;
resource
-
>
registerWithCache
(
sk_ref_sp
(
this
)
)
;
resource
-
>
refCache
(
)
;
resource
-
>
setTimestamp
(
this
-
>
getNextTimestamp
(
)
)
;
this
-
>
addToNonpurgeableArray
(
resource
)
;
SkDEBUGCODE
(
fCount
+
+
;
)
if
(
resource
-
>
key
(
)
.
shareable
(
)
=
=
Shareable
:
:
kYes
)
{
fResourceMap
.
insert
(
resource
-
>
key
(
)
resource
)
;
}
}
Resource
*
ResourceCache
:
:
findAndRefResource
(
const
GraphiteResourceKey
&
key
skgpu
:
:
Budgeted
budgeted
)
{
ASSERT_SINGLE_OWNER
this
-
>
processReturnedResources
(
)
;
SkASSERT
(
key
.
isValid
(
)
)
;
Resource
*
resource
=
fResourceMap
.
find
(
key
)
;
if
(
resource
)
{
SkASSERT
(
resource
-
>
budgeted
(
)
=
=
skgpu
:
:
Budgeted
:
:
kYes
)
;
if
(
key
.
shareable
(
)
=
=
Shareable
:
:
kNo
)
{
fResourceMap
.
remove
(
key
resource
)
;
if
(
budgeted
=
=
skgpu
:
:
Budgeted
:
:
kNo
)
{
resource
-
>
makeUnbudgeted
(
)
;
}
SkDEBUGCODE
(
resource
-
>
fNonShareableInCache
=
false
;
)
}
else
{
SkASSERT
(
budgeted
=
=
skgpu
:
:
Budgeted
:
:
kYes
)
;
}
this
-
>
refAndMakeResourceMRU
(
resource
)
;
this
-
>
validate
(
)
;
}
return
resource
;
}
void
ResourceCache
:
:
refAndMakeResourceMRU
(
Resource
*
resource
)
{
SkASSERT
(
resource
)
;
SkASSERT
(
this
-
>
isInCache
(
resource
)
)
;
if
(
this
-
>
inPurgeableQueue
(
resource
)
)
{
this
-
>
removeFromPurgeableQueue
(
resource
)
;
this
-
>
addToNonpurgeableArray
(
resource
)
;
}
resource
-
>
initialUsageRef
(
)
;
resource
-
>
setTimestamp
(
this
-
>
getNextTimestamp
(
)
)
;
this
-
>
validate
(
)
;
}
bool
ResourceCache
:
:
returnResource
(
Resource
*
resource
LastRemovedRef
removedRef
)
{
SkASSERT
(
removedRef
!
=
LastRemovedRef
:
:
kCache
)
;
SkAutoMutexExclusive
locked
(
fReturnMutex
)
;
if
(
fIsShutdown
)
{
return
false
;
}
SkASSERT
(
resource
)
;
if
(
*
resource
-
>
accessReturnIndex
(
)
>
=
0
)
{
if
(
removedRef
=
=
LastRemovedRef
:
:
kUsage
)
{
SkASSERT
(
*
resource
-
>
accessReturnIndex
(
)
<
(
int
)
fReturnQueue
.
size
(
)
)
;
fReturnQueue
[
*
resource
-
>
accessReturnIndex
(
)
]
.
second
=
removedRef
;
}
return
true
;
}
#
ifdef
SK_DEBUG
for
(
auto
&
nextResource
:
fReturnQueue
)
{
SkASSERT
(
nextResource
.
first
!
=
resource
)
;
}
#
endif
fReturnQueue
.
push_back
(
std
:
:
make_pair
(
resource
removedRef
)
)
;
*
resource
-
>
accessReturnIndex
(
)
=
fReturnQueue
.
size
(
)
-
1
;
resource
-
>
refCache
(
)
;
return
true
;
}
void
ResourceCache
:
:
processReturnedResources
(
)
{
ReturnQueue
tempQueue
;
{
SkAutoMutexExclusive
locked
(
fReturnMutex
)
;
tempQueue
=
fReturnQueue
;
fReturnQueue
.
clear
(
)
;
for
(
auto
&
nextResource
:
tempQueue
)
{
auto
[
resource
ref
]
=
nextResource
;
SkASSERT
(
*
resource
-
>
accessReturnIndex
(
)
>
=
0
)
;
*
resource
-
>
accessReturnIndex
(
)
=
-
1
;
}
}
for
(
auto
&
nextResource
:
tempQueue
)
{
auto
[
resource
ref
]
=
nextResource
;
if
(
*
resource
-
>
accessCacheIndex
(
)
!
=
-
1
)
{
this
-
>
returnResourceToCache
(
resource
ref
)
;
}
resource
-
>
unrefCache
(
)
;
}
}
void
ResourceCache
:
:
returnResourceToCache
(
Resource
*
resource
LastRemovedRef
removedRef
)
{
SkASSERT
(
!
resource
-
>
wasDestroyed
(
)
)
;
SkASSERT
(
this
-
>
isInCache
(
resource
)
)
;
if
(
removedRef
=
=
LastRemovedRef
:
:
kUsage
)
{
if
(
resource
-
>
key
(
)
.
shareable
(
)
=
=
Shareable
:
:
kYes
)
{
SkASSERT
(
fResourceMap
.
find
(
resource
-
>
key
(
)
)
)
;
}
else
{
SkDEBUGCODE
(
resource
-
>
fNonShareableInCache
=
true
;
)
fResourceMap
.
insert
(
resource
-
>
key
(
)
resource
)
;
if
(
resource
-
>
budgeted
(
)
=
=
skgpu
:
:
Budgeted
:
:
kNo
)
{
resource
-
>
makeBudgeted
(
)
;
}
}
}
if
(
!
resource
-
>
isPurgeable
(
)
|
|
this
-
>
inPurgeableQueue
(
resource
)
)
{
this
-
>
validate
(
)
;
return
;
}
resource
-
>
setTimestamp
(
this
-
>
getNextTimestamp
(
)
)
;
this
-
>
removeFromNonpurgeableArray
(
resource
)
;
fPurgeableQueue
.
insert
(
resource
)
;
this
-
>
validate
(
)
;
}
void
ResourceCache
:
:
addToNonpurgeableArray
(
Resource
*
resource
)
{
int
index
=
fNonpurgeableResources
.
size
(
)
;
*
fNonpurgeableResources
.
append
(
)
=
resource
;
*
resource
-
>
accessCacheIndex
(
)
=
index
;
}
void
ResourceCache
:
:
removeFromNonpurgeableArray
(
Resource
*
resource
)
{
int
*
index
=
resource
-
>
accessCacheIndex
(
)
;
Resource
*
tail
=
*
(
fNonpurgeableResources
.
end
(
)
-
1
)
;
SkASSERT
(
fNonpurgeableResources
[
*
index
]
=
=
resource
)
;
fNonpurgeableResources
[
*
index
]
=
tail
;
*
tail
-
>
accessCacheIndex
(
)
=
*
index
;
fNonpurgeableResources
.
pop_back
(
)
;
*
index
=
-
1
;
}
void
ResourceCache
:
:
removeFromPurgeableQueue
(
Resource
*
resource
)
{
fPurgeableQueue
.
remove
(
resource
)
;
*
resource
-
>
accessCacheIndex
(
)
=
-
1
;
}
bool
ResourceCache
:
:
inPurgeableQueue
(
Resource
*
resource
)
const
{
SkASSERT
(
this
-
>
isInCache
(
resource
)
)
;
int
index
=
*
resource
-
>
accessCacheIndex
(
)
;
if
(
index
<
fPurgeableQueue
.
count
(
)
&
&
fPurgeableQueue
.
at
(
index
)
=
=
resource
)
{
return
true
;
}
return
false
;
}
uint32_t
ResourceCache
:
:
getNextTimestamp
(
)
{
if
(
0
=
=
fTimestamp
)
{
int
count
=
this
-
>
getResourceCount
(
)
;
if
(
count
)
{
SkTDArray
<
Resource
*
>
sortedPurgeableResources
;
sortedPurgeableResources
.
reserve
(
fPurgeableQueue
.
count
(
)
)
;
while
(
fPurgeableQueue
.
count
(
)
)
{
*
sortedPurgeableResources
.
append
(
)
=
fPurgeableQueue
.
peek
(
)
;
fPurgeableQueue
.
pop
(
)
;
}
SkTQSort
(
fNonpurgeableResources
.
begin
(
)
fNonpurgeableResources
.
end
(
)
CompareTimestamp
)
;
int
currP
=
0
;
int
currNP
=
0
;
while
(
currP
<
sortedPurgeableResources
.
size
(
)
&
&
currNP
<
fNonpurgeableResources
.
size
(
)
)
{
uint32_t
tsP
=
sortedPurgeableResources
[
currP
]
-
>
timestamp
(
)
;
uint32_t
tsNP
=
fNonpurgeableResources
[
currNP
]
-
>
timestamp
(
)
;
SkASSERT
(
tsP
!
=
tsNP
)
;
if
(
tsP
<
tsNP
)
{
sortedPurgeableResources
[
currP
+
+
]
-
>
setTimestamp
(
fTimestamp
+
+
)
;
}
else
{
*
fNonpurgeableResources
[
currNP
]
-
>
accessCacheIndex
(
)
=
currNP
;
fNonpurgeableResources
[
currNP
+
+
]
-
>
setTimestamp
(
fTimestamp
+
+
)
;
}
}
while
(
currP
<
sortedPurgeableResources
.
size
(
)
)
{
sortedPurgeableResources
[
currP
+
+
]
-
>
setTimestamp
(
fTimestamp
+
+
)
;
}
while
(
currNP
<
fNonpurgeableResources
.
size
(
)
)
{
*
fNonpurgeableResources
[
currNP
]
-
>
accessCacheIndex
(
)
=
currNP
;
fNonpurgeableResources
[
currNP
+
+
]
-
>
setTimestamp
(
fTimestamp
+
+
)
;
}
for
(
int
i
=
0
;
i
<
sortedPurgeableResources
.
size
(
)
;
+
+
i
)
{
fPurgeableQueue
.
insert
(
sortedPurgeableResources
[
i
]
)
;
}
this
-
>
validate
(
)
;
SkASSERT
(
count
=
=
this
-
>
getResourceCount
(
)
)
;
SkASSERT
(
fTimestamp
=
=
SkToU32
(
count
)
)
;
}
}
return
fTimestamp
+
+
;
}
const
GraphiteResourceKey
&
ResourceCache
:
:
MapTraits
:
:
GetKey
(
const
Resource
&
r
)
{
return
r
.
key
(
)
;
}
uint32_t
ResourceCache
:
:
MapTraits
:
:
Hash
(
const
GraphiteResourceKey
&
key
)
{
return
key
.
hash
(
)
;
}
bool
ResourceCache
:
:
CompareTimestamp
(
Resource
*
const
&
a
Resource
*
const
&
b
)
{
return
a
-
>
timestamp
(
)
<
b
-
>
timestamp
(
)
;
}
int
*
ResourceCache
:
:
AccessResourceIndex
(
Resource
*
const
&
res
)
{
return
res
-
>
accessCacheIndex
(
)
;
}
#
ifdef
SK_DEBUG
void
ResourceCache
:
:
validate
(
)
const
{
static
SkRandom
gRandom
;
int
mask
=
(
SkNextPow2
(
fCount
+
1
)
>
>
5
)
-
1
;
if
(
~
mask
&
&
(
gRandom
.
nextU
(
)
&
mask
)
)
{
return
;
}
struct
Stats
{
int
fShareable
;
int
fScratch
;
const
ResourceMap
*
fResourceMap
;
Stats
(
const
ResourceCache
*
cache
)
{
memset
(
this
0
sizeof
(
*
this
)
)
;
fResourceMap
=
&
cache
-
>
fResourceMap
;
}
void
update
(
Resource
*
resource
)
{
const
GraphiteResourceKey
&
key
=
resource
-
>
key
(
)
;
SkASSERT
(
key
.
isValid
(
)
)
;
SkASSERT
(
resource
-
>
hasCacheRef
(
)
)
;
SkASSERT
(
resource
-
>
ownership
(
)
=
=
Ownership
:
:
kOwned
)
;
if
(
resource
-
>
isUsableAsScratch
(
)
)
{
SkASSERT
(
key
.
shareable
(
)
=
=
Shareable
:
:
kNo
)
;
SkASSERT
(
!
resource
-
>
hasUsageRef
(
)
)
;
+
+
fScratch
;
SkASSERT
(
fResourceMap
-
>
has
(
resource
key
)
)
;
SkASSERT
(
resource
-
>
budgeted
(
)
=
=
skgpu
:
:
Budgeted
:
:
kYes
)
;
}
else
if
(
key
.
shareable
(
)
=
=
Shareable
:
:
kNo
)
{
SkASSERT
(
!
fResourceMap
-
>
has
(
resource
key
)
)
;
}
else
{
SkASSERT
(
key
.
shareable
(
)
=
=
Shareable
:
:
kYes
)
;
+
+
fShareable
;
SkASSERT
(
fResourceMap
-
>
has
(
resource
key
)
)
;
SkASSERT
(
resource
-
>
budgeted
(
)
=
=
skgpu
:
:
Budgeted
:
:
kYes
)
;
}
}
}
;
{
int
count
=
0
;
fResourceMap
.
foreach
(
[
&
]
(
const
Resource
&
resource
)
{
SkASSERT
(
resource
.
isUsableAsScratch
(
)
|
|
resource
.
key
(
)
.
shareable
(
)
=
=
Shareable
:
:
kYes
)
;
SkASSERT
(
resource
.
budgeted
(
)
=
=
skgpu
:
:
Budgeted
:
:
kYes
)
;
count
+
+
;
}
)
;
SkASSERT
(
count
=
=
fResourceMap
.
count
(
)
)
;
}
Stats
stats
(
this
)
;
for
(
int
i
=
0
;
i
<
fNonpurgeableResources
.
size
(
)
;
+
+
i
)
{
SkASSERT
(
*
fNonpurgeableResources
[
i
]
-
>
accessCacheIndex
(
)
=
=
i
)
;
SkASSERT
(
!
fNonpurgeableResources
[
i
]
-
>
wasDestroyed
(
)
)
;
SkASSERT
(
!
this
-
>
inPurgeableQueue
(
fNonpurgeableResources
[
i
]
)
)
;
stats
.
update
(
fNonpurgeableResources
[
i
]
)
;
}
for
(
int
i
=
0
;
i
<
fPurgeableQueue
.
count
(
)
;
+
+
i
)
{
SkASSERT
(
fPurgeableQueue
.
at
(
i
)
-
>
isPurgeable
(
)
)
;
SkASSERT
(
*
fPurgeableQueue
.
at
(
i
)
-
>
accessCacheIndex
(
)
=
=
i
)
;
SkASSERT
(
!
fPurgeableQueue
.
at
(
i
)
-
>
wasDestroyed
(
)
)
;
stats
.
update
(
fPurgeableQueue
.
at
(
i
)
)
;
}
SkASSERT
(
(
stats
.
fScratch
+
stats
.
fShareable
)
=
=
fResourceMap
.
count
(
)
)
;
}
bool
ResourceCache
:
:
isInCache
(
const
Resource
*
resource
)
const
{
int
index
=
*
resource
-
>
accessCacheIndex
(
)
;
if
(
index
<
0
)
{
return
false
;
}
if
(
index
<
fPurgeableQueue
.
count
(
)
&
&
fPurgeableQueue
.
at
(
index
)
=
=
resource
)
{
return
true
;
}
if
(
index
<
fNonpurgeableResources
.
size
(
)
&
&
fNonpurgeableResources
[
index
]
=
=
resource
)
{
return
true
;
}
SkDEBUGFAIL
(
"
Resource
index
should
be
-
1
or
the
resource
should
be
in
the
cache
.
"
)
;
return
false
;
}
#
endif
#
if
GRAPHITE_TEST_UTILS
int
ResourceCache
:
:
numFindableResources
(
)
const
{
return
fResourceMap
.
count
(
)
;
}
#
endif
}
