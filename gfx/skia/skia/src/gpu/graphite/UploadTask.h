#
ifndef
skgpu_graphite_UploadTask_DEFINED
#
define
skgpu_graphite_UploadTask_DEFINED
#
include
"
src
/
gpu
/
graphite
/
Task
.
h
"
#
include
<
memory
>
#
include
<
vector
>
#
include
"
include
/
core
/
SkImageInfo
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
namespace
skgpu
:
:
graphite
{
class
Buffer
;
struct
BufferTextureCopyData
;
class
Recorder
;
class
TextureProxy
;
struct
MipLevel
{
const
void
*
fPixels
=
nullptr
;
size_t
fRowBytes
=
0
;
}
;
class
ConditionalUploadContext
{
public
:
virtual
~
ConditionalUploadContext
(
)
{
}
virtual
bool
needsUpload
(
Context
*
)
const
=
0
;
virtual
void
uploadSubmitted
(
)
{
}
}
;
class
ImageUploadContext
:
public
ConditionalUploadContext
{
public
:
~
ImageUploadContext
(
)
override
{
}
bool
needsUpload
(
Context
*
context
)
const
override
{
return
fNeedsUpload
;
}
void
uploadSubmitted
(
)
override
{
fNeedsUpload
=
false
;
}
private
:
bool
fNeedsUpload
=
true
;
}
;
class
UploadInstance
{
public
:
static
UploadInstance
Make
(
Recorder
*
sk_sp
<
TextureProxy
>
targetProxy
const
SkColorInfo
&
srcColorInfo
const
SkColorInfo
&
dstColorInfo
const
std
:
:
vector
<
MipLevel
>
&
levels
const
SkIRect
&
dstRect
std
:
:
unique_ptr
<
ConditionalUploadContext
>
)
;
bool
isValid
(
)
const
{
return
fBuffer
!
=
nullptr
;
}
bool
prepareResources
(
ResourceProvider
*
)
;
void
addCommand
(
Context
*
CommandBuffer
*
Task
:
:
ReplayTargetData
)
const
;
private
:
UploadInstance
(
)
{
}
UploadInstance
(
const
Buffer
*
size_t
bytesPerPixel
sk_sp
<
TextureProxy
>
std
:
:
vector
<
BufferTextureCopyData
>
std
:
:
unique_ptr
<
ConditionalUploadContext
>
)
;
const
Buffer
*
fBuffer
;
size_t
fBytesPerPixel
;
sk_sp
<
TextureProxy
>
fTextureProxy
;
std
:
:
vector
<
BufferTextureCopyData
>
fCopyData
;
std
:
:
unique_ptr
<
ConditionalUploadContext
>
fConditionalContext
;
}
;
class
UploadList
{
public
:
bool
recordUpload
(
Recorder
*
sk_sp
<
TextureProxy
>
targetProxy
const
SkColorInfo
&
srcColorInfo
const
SkColorInfo
&
dstColorInfo
const
std
:
:
vector
<
MipLevel
>
&
levels
const
SkIRect
&
dstRect
std
:
:
unique_ptr
<
ConditionalUploadContext
>
)
;
int
size
(
)
{
return
fInstances
.
size
(
)
;
}
private
:
friend
class
UploadTask
;
std
:
:
vector
<
UploadInstance
>
fInstances
;
}
;
class
UploadTask
final
:
public
Task
{
public
:
static
sk_sp
<
UploadTask
>
Make
(
UploadList
*
)
;
static
sk_sp
<
UploadTask
>
Make
(
UploadInstance
)
;
~
UploadTask
(
)
override
;
bool
prepareResources
(
ResourceProvider
*
const
RuntimeEffectDictionary
*
)
override
;
bool
addCommands
(
Context
*
CommandBuffer
*
ReplayTargetData
)
override
;
private
:
UploadTask
(
std
:
:
vector
<
UploadInstance
>
)
;
UploadTask
(
UploadInstance
)
;
std
:
:
vector
<
UploadInstance
>
fInstances
;
}
;
}
#
endif
