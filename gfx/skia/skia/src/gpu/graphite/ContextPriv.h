#
ifndef
skgpu_graphite_ContextPriv_DEFINED
#
define
skgpu_graphite_ContextPriv_DEFINED
#
include
"
include
/
gpu
/
graphite
/
Context
.
h
"
#
include
"
src
/
gpu
/
graphite
/
QueueManager
.
h
"
#
include
"
src
/
gpu
/
graphite
/
SharedContext
.
h
"
namespace
skgpu
:
:
graphite
{
class
Caps
;
class
GlobalCache
;
class
RendererProvider
;
class
ResourceProvider
;
class
ShaderCodeDictionary
;
class
ContextPriv
{
public
:
#
if
GRAPHITE_TEST_UTILS
const
Caps
*
caps
(
)
const
{
return
fContext
-
>
fSharedContext
-
>
caps
(
)
;
}
const
ShaderCodeDictionary
*
shaderCodeDictionary
(
)
const
{
return
fContext
-
>
fSharedContext
-
>
shaderCodeDictionary
(
)
;
}
ShaderCodeDictionary
*
shaderCodeDictionary
(
)
{
return
fContext
-
>
fSharedContext
-
>
shaderCodeDictionary
(
)
;
}
const
GlobalCache
*
globalCache
(
)
const
{
return
fContext
-
>
fSharedContext
-
>
globalCache
(
)
;
}
GlobalCache
*
globalCache
(
)
{
return
fContext
-
>
fSharedContext
-
>
globalCache
(
)
;
}
const
RendererProvider
*
rendererProvider
(
)
const
{
return
fContext
-
>
fSharedContext
-
>
rendererProvider
(
)
;
}
ResourceProvider
*
resourceProvider
(
)
const
{
return
fContext
-
>
fResourceProvider
.
get
(
)
;
}
PlotUploadTracker
*
plotUploadTracker
(
)
const
{
return
fContext
-
>
fPlotUploadTracker
.
get
(
)
;
}
void
startCapture
(
)
{
fContext
-
>
fQueueManager
-
>
startCapture
(
)
;
}
void
stopCapture
(
)
{
fContext
-
>
fQueueManager
-
>
stopCapture
(
)
;
}
void
deregisterRecorder
(
const
Recorder
*
)
;
bool
readPixels
(
const
SkPixmap
&
const
TextureProxy
*
const
SkImageInfo
&
srcImageInfo
int
srcX
int
srcY
)
;
#
endif
private
:
friend
class
Context
;
explicit
ContextPriv
(
Context
*
context
)
:
fContext
(
context
)
{
}
ContextPriv
&
operator
=
(
const
ContextPriv
&
)
=
delete
;
const
ContextPriv
*
operator
&
(
)
const
;
ContextPriv
*
operator
&
(
)
;
Context
*
fContext
;
}
;
inline
ContextPriv
Context
:
:
priv
(
)
{
return
ContextPriv
(
this
)
;
}
inline
const
ContextPriv
Context
:
:
priv
(
)
const
{
return
ContextPriv
(
const_cast
<
Context
*
>
(
this
)
)
;
}
class
ContextCtorAccessor
{
public
:
static
std
:
:
unique_ptr
<
Context
>
MakeContext
(
sk_sp
<
SharedContext
>
std
:
:
unique_ptr
<
QueueManager
>
const
ContextOptions
&
)
;
}
;
}
#
endif
