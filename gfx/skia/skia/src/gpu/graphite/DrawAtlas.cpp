#
include
"
src
/
gpu
/
graphite
/
DrawAtlas
.
h
"
#
include
<
memory
>
#
include
"
include
/
core
/
SkColorSpace
.
h
"
#
include
"
include
/
gpu
/
graphite
/
Recorder
.
h
"
#
include
"
include
/
private
/
SkColorData
.
h
"
#
include
"
include
/
private
/
base
/
SkTPin
.
h
"
#
include
"
src
/
base
/
SkMathPriv
.
h
"
#
include
"
src
/
core
/
SkOpts
.
h
"
#
include
"
src
/
core
/
SkTraceEvent
.
h
"
#
include
"
src
/
gpu
/
AtlasTypes
.
h
"
#
include
"
src
/
gpu
/
graphite
/
Caps
.
h
"
#
include
"
src
/
gpu
/
graphite
/
CommandTypes
.
h
"
#
include
"
src
/
gpu
/
graphite
/
ContextPriv
.
h
"
#
include
"
src
/
gpu
/
graphite
/
RecorderPriv
.
h
"
#
include
"
src
/
gpu
/
graphite
/
TextureProxy
.
h
"
#
include
"
src
/
gpu
/
graphite
/
UploadTask
.
h
"
namespace
skgpu
:
:
graphite
{
#
if
defined
(
DUMP_ATLAS_DATA
)
static
const
constexpr
bool
kDumpAtlasData
=
true
;
#
else
static
const
constexpr
bool
kDumpAtlasData
=
false
;
#
endif
class
PlotUploadContext
:
public
ConditionalUploadContext
{
public
:
static
std
:
:
unique_ptr
<
ConditionalUploadContext
>
Make
(
PlotLocator
plotLocator
AtlasToken
uploadToken
uint32_t
atlasID
)
{
return
std
:
:
unique_ptr
<
PlotUploadContext
>
(
new
PlotUploadContext
(
plotLocator
uploadToken
atlasID
)
)
;
}
~
PlotUploadContext
(
)
override
{
}
bool
needsUpload
(
Context
*
context
)
const
override
{
return
context
-
>
priv
(
)
.
plotUploadTracker
(
)
-
>
needsUpload
(
fPlotLocator
fUploadToken
fAtlasID
)
;
}
private
:
PlotUploadContext
(
PlotLocator
plotLocator
AtlasToken
uploadToken
uint32_t
atlasID
)
:
ConditionalUploadContext
(
)
fPlotLocator
(
plotLocator
)
fUploadToken
(
uploadToken
)
fAtlasID
(
atlasID
)
{
}
PlotLocator
fPlotLocator
;
AtlasToken
fUploadToken
;
uint32_t
fAtlasID
;
}
;
#
ifdef
SK_DEBUG
void
DrawAtlas
:
:
validate
(
const
AtlasLocator
&
atlasLocator
)
const
{
int
numPlotsX
=
fTextureWidth
/
fPlotWidth
;
int
numPlotsY
=
fTextureHeight
/
fPlotHeight
;
int
plotIndex
=
atlasLocator
.
plotIndex
(
)
;
auto
topLeft
=
atlasLocator
.
topLeft
(
)
;
int
plotX
=
topLeft
.
x
(
)
/
fPlotWidth
;
int
plotY
=
topLeft
.
y
(
)
/
fPlotHeight
;
SkASSERT
(
plotIndex
=
=
(
numPlotsY
-
plotY
-
1
)
*
numPlotsX
+
(
numPlotsX
-
plotX
-
1
)
)
;
}
#
endif
std
:
:
unique_ptr
<
DrawAtlas
>
DrawAtlas
:
:
Make
(
SkColorType
colorType
size_t
bpp
int
width
int
height
int
plotWidth
int
plotHeight
AtlasGenerationCounter
*
generationCounter
AllowMultitexturing
allowMultitexturing
PlotEvictionCallback
*
evictor
std
:
:
string_view
label
)
{
std
:
:
unique_ptr
<
DrawAtlas
>
atlas
(
new
DrawAtlas
(
colorType
bpp
width
height
plotWidth
plotHeight
generationCounter
allowMultitexturing
label
)
)
;
if
(
evictor
!
=
nullptr
)
{
atlas
-
>
fEvictionCallbacks
.
emplace_back
(
evictor
)
;
}
return
atlas
;
}
static
int32_t
next_id
(
)
{
static
std
:
:
atomic
<
int32_t
>
nextID
{
1
}
;
int32_t
id
;
do
{
id
=
nextID
.
fetch_add
(
1
std
:
:
memory_order_relaxed
)
;
}
while
(
id
=
=
SK_InvalidGenID
)
;
return
id
;
}
DrawAtlas
:
:
DrawAtlas
(
SkColorType
colorType
size_t
bpp
int
width
int
height
int
plotWidth
int
plotHeight
AtlasGenerationCounter
*
generationCounter
AllowMultitexturing
allowMultitexturing
std
:
:
string_view
label
)
:
fColorType
(
colorType
)
fBytesPerPixel
(
bpp
)
fTextureWidth
(
width
)
fTextureHeight
(
height
)
fPlotWidth
(
plotWidth
)
fPlotHeight
(
plotHeight
)
fLabel
(
label
)
fAtlasID
(
next_id
(
)
)
fGenerationCounter
(
generationCounter
)
fAtlasGeneration
(
fGenerationCounter
-
>
next
(
)
)
fPrevFlushToken
(
AtlasToken
:
:
InvalidToken
(
)
)
fFlushesSinceLastUse
(
0
)
fMaxPages
(
AllowMultitexturing
:
:
kYes
=
=
allowMultitexturing
?
PlotLocator
:
:
kMaxMultitexturePages
:
1
)
fNumActivePages
(
0
)
{
int
numPlotsX
=
width
/
plotWidth
;
int
numPlotsY
=
height
/
plotHeight
;
SkASSERT
(
numPlotsX
*
numPlotsY
<
=
PlotLocator
:
:
kMaxPlots
)
;
SkASSERT
(
fPlotWidth
*
numPlotsX
=
=
fTextureWidth
)
;
SkASSERT
(
fPlotHeight
*
numPlotsY
=
=
fTextureHeight
)
;
fNumPlots
=
numPlotsX
*
numPlotsY
;
this
-
>
createPages
(
generationCounter
)
;
}
inline
void
DrawAtlas
:
:
processEviction
(
PlotLocator
plotLocator
)
{
for
(
PlotEvictionCallback
*
evictor
:
fEvictionCallbacks
)
{
evictor
-
>
evict
(
plotLocator
)
;
}
fAtlasGeneration
=
fGenerationCounter
-
>
next
(
)
;
}
inline
bool
DrawAtlas
:
:
updatePlot
(
AtlasLocator
*
atlasLocator
Plot
*
plot
)
{
int
pageIdx
=
plot
-
>
pageIndex
(
)
;
this
-
>
makeMRU
(
plot
pageIdx
)
;
atlasLocator
-
>
updatePlotLocator
(
plot
-
>
plotLocator
(
)
)
;
SkDEBUGCODE
(
this
-
>
validate
(
*
atlasLocator
)
;
)
return
true
;
}
bool
DrawAtlas
:
:
addToPage
(
unsigned
int
pageIdx
int
width
int
height
const
void
*
image
AtlasLocator
*
atlasLocator
)
{
SkASSERT
(
fProxies
[
pageIdx
]
)
;
PlotList
:
:
Iter
plotIter
;
plotIter
.
init
(
fPages
[
pageIdx
]
.
fPlotList
PlotList
:
:
Iter
:
:
kHead_IterStart
)
;
for
(
Plot
*
plot
=
plotIter
.
get
(
)
;
plot
;
plot
=
plotIter
.
next
(
)
)
{
if
(
plot
-
>
addSubImage
(
width
height
image
atlasLocator
)
)
{
return
this
-
>
updatePlot
(
atlasLocator
plot
)
;
}
}
return
false
;
}
bool
DrawAtlas
:
:
recordUploads
(
UploadList
*
ul
Recorder
*
recorder
bool
useCachedUploads
)
{
TRACE_EVENT0
(
"
skia
.
gpu
"
TRACE_FUNC
)
;
for
(
uint32_t
pageIdx
=
0
;
pageIdx
<
fNumActivePages
;
+
+
pageIdx
)
{
PlotList
:
:
Iter
plotIter
;
plotIter
.
init
(
fPages
[
pageIdx
]
.
fPlotList
PlotList
:
:
Iter
:
:
kHead_IterStart
)
;
for
(
Plot
*
plot
=
plotIter
.
get
(
)
;
plot
;
plot
=
plotIter
.
next
(
)
)
{
if
(
useCachedUploads
|
|
plot
-
>
needsUpload
(
)
)
{
TextureProxy
*
proxy
=
fProxies
[
pageIdx
]
.
get
(
)
;
SkASSERT
(
proxy
)
;
const
void
*
dataPtr
;
SkIRect
dstRect
;
std
:
:
tie
(
dataPtr
dstRect
)
=
plot
-
>
prepareForUpload
(
useCachedUploads
)
;
if
(
dstRect
.
isEmpty
(
)
)
{
continue
;
}
std
:
:
vector
<
MipLevel
>
levels
;
levels
.
push_back
(
{
dataPtr
fBytesPerPixel
*
fPlotWidth
}
)
;
plot
-
>
setLastUploadToken
(
recorder
-
>
priv
(
)
.
tokenTracker
(
)
-
>
nextFlushToken
(
)
)
;
auto
uploadContext
=
PlotUploadContext
:
:
Make
(
plot
-
>
plotLocator
(
)
plot
-
>
lastUploadToken
(
)
fAtlasID
)
;
SkColorInfo
colorInfo
(
fColorType
kUnknown_SkAlphaType
nullptr
)
;
if
(
!
ul
-
>
recordUpload
(
recorder
sk_ref_sp
(
proxy
)
colorInfo
colorInfo
levels
dstRect
std
:
:
move
(
uploadContext
)
)
)
{
return
false
;
}
}
}
}
return
true
;
}
static
constexpr
auto
kPlotRecentlyUsedCount
=
32
;
static
constexpr
auto
kAtlasRecentlyUsedCount
=
128
;
DrawAtlas
:
:
ErrorCode
DrawAtlas
:
:
addToAtlas
(
Recorder
*
recorder
int
width
int
height
const
void
*
image
AtlasLocator
*
atlasLocator
)
{
if
(
width
>
fPlotWidth
|
|
height
>
fPlotHeight
)
{
return
ErrorCode
:
:
kError
;
}
for
(
unsigned
int
pageIdx
=
0
;
pageIdx
<
fNumActivePages
;
+
+
pageIdx
)
{
if
(
this
-
>
addToPage
(
pageIdx
width
height
image
atlasLocator
)
)
{
return
ErrorCode
:
:
kSucceeded
;
}
}
if
(
fNumActivePages
=
=
this
-
>
maxPages
(
)
)
{
for
(
unsigned
int
pageIdx
=
0
;
pageIdx
<
fNumActivePages
;
+
+
pageIdx
)
{
Plot
*
plot
=
fPages
[
pageIdx
]
.
fPlotList
.
tail
(
)
;
SkASSERT
(
plot
)
;
if
(
plot
-
>
lastUseToken
(
)
<
recorder
-
>
priv
(
)
.
tokenTracker
(
)
-
>
nextFlushToken
(
)
)
{
this
-
>
processEvictionAndResetRects
(
plot
)
;
SkDEBUGCODE
(
bool
verify
=
)
plot
-
>
addSubImage
(
width
height
image
atlasLocator
)
;
SkASSERT
(
verify
)
;
if
(
!
this
-
>
updatePlot
(
atlasLocator
plot
)
)
{
return
ErrorCode
:
:
kError
;
}
return
ErrorCode
:
:
kSucceeded
;
}
}
}
else
{
if
(
!
this
-
>
activateNewPage
(
recorder
)
)
{
return
ErrorCode
:
:
kError
;
}
if
(
this
-
>
addToPage
(
fNumActivePages
-
1
width
height
image
atlasLocator
)
)
{
return
ErrorCode
:
:
kSucceeded
;
}
else
{
return
ErrorCode
:
:
kError
;
}
}
if
(
!
fNumActivePages
)
{
return
ErrorCode
:
:
kError
;
}
return
ErrorCode
:
:
kTryAgain
;
}
void
DrawAtlas
:
:
compact
(
AtlasToken
startTokenForNextFlush
)
{
if
(
fNumActivePages
<
1
)
{
fPrevFlushToken
=
startTokenForNextFlush
;
return
;
}
PlotList
:
:
Iter
plotIter
;
bool
atlasUsedThisFlush
=
false
;
for
(
uint32_t
pageIndex
=
0
;
pageIndex
<
fNumActivePages
;
+
+
pageIndex
)
{
plotIter
.
init
(
fPages
[
pageIndex
]
.
fPlotList
PlotList
:
:
Iter
:
:
kHead_IterStart
)
;
while
(
Plot
*
plot
=
plotIter
.
get
(
)
)
{
if
(
plot
-
>
lastUseToken
(
)
.
inInterval
(
fPrevFlushToken
startTokenForNextFlush
)
)
{
plot
-
>
resetFlushesSinceLastUsed
(
)
;
atlasUsedThisFlush
=
true
;
}
plotIter
.
next
(
)
;
}
}
if
(
atlasUsedThisFlush
)
{
fFlushesSinceLastUse
=
0
;
}
else
{
+
+
fFlushesSinceLastUse
;
}
if
(
atlasUsedThisFlush
|
|
fFlushesSinceLastUse
>
kAtlasRecentlyUsedCount
)
{
SkTArray
<
Plot
*
>
availablePlots
;
uint32_t
lastPageIndex
=
fNumActivePages
-
1
;
for
(
uint32_t
pageIndex
=
0
;
pageIndex
<
lastPageIndex
;
+
+
pageIndex
)
{
if
constexpr
(
kDumpAtlasData
)
{
SkDebugf
(
"
page
%
d
:
"
pageIndex
)
;
}
plotIter
.
init
(
fPages
[
pageIndex
]
.
fPlotList
PlotList
:
:
Iter
:
:
kHead_IterStart
)
;
while
(
Plot
*
plot
=
plotIter
.
get
(
)
)
{
if
(
!
plot
-
>
lastUseToken
(
)
.
inInterval
(
fPrevFlushToken
startTokenForNextFlush
)
)
{
plot
-
>
incFlushesSinceLastUsed
(
)
;
}
if
constexpr
(
kDumpAtlasData
)
{
SkDebugf
(
"
%
d
"
plot
-
>
flushesSinceLastUsed
(
)
)
;
}
if
(
plot
-
>
flushesSinceLastUsed
(
)
>
kPlotRecentlyUsedCount
)
{
availablePlots
.
push_back
(
)
=
plot
;
}
plotIter
.
next
(
)
;
}
if
constexpr
(
kDumpAtlasData
)
{
SkDebugf
(
"
\
n
"
)
;
}
}
plotIter
.
init
(
fPages
[
lastPageIndex
]
.
fPlotList
PlotList
:
:
Iter
:
:
kHead_IterStart
)
;
unsigned
int
usedPlots
=
0
;
if
constexpr
(
kDumpAtlasData
)
{
SkDebugf
(
"
page
%
d
:
"
lastPageIndex
)
;
}
while
(
Plot
*
plot
=
plotIter
.
get
(
)
)
{
if
(
!
plot
-
>
lastUseToken
(
)
.
inInterval
(
fPrevFlushToken
startTokenForNextFlush
)
)
{
plot
-
>
incFlushesSinceLastUsed
(
)
;
}
if
constexpr
(
kDumpAtlasData
)
{
SkDebugf
(
"
%
d
"
plot
-
>
flushesSinceLastUsed
(
)
)
;
}
if
(
plot
-
>
flushesSinceLastUsed
(
)
<
=
kPlotRecentlyUsedCount
)
{
usedPlots
+
+
;
}
else
if
(
plot
-
>
lastUseToken
(
)
!
=
AtlasToken
:
:
InvalidToken
(
)
)
{
this
-
>
processEvictionAndResetRects
(
plot
)
;
}
plotIter
.
next
(
)
;
}
if
constexpr
(
kDumpAtlasData
)
{
SkDebugf
(
"
\
n
"
)
;
}
if
(
availablePlots
.
size
(
)
&
&
usedPlots
&
&
usedPlots
<
=
fNumPlots
/
4
)
{
plotIter
.
init
(
fPages
[
lastPageIndex
]
.
fPlotList
PlotList
:
:
Iter
:
:
kHead_IterStart
)
;
while
(
Plot
*
plot
=
plotIter
.
get
(
)
)
{
if
(
plot
-
>
flushesSinceLastUsed
(
)
<
=
kPlotRecentlyUsedCount
)
{
if
(
availablePlots
.
size
(
)
>
0
)
{
this
-
>
processEvictionAndResetRects
(
plot
)
;
this
-
>
processEvictionAndResetRects
(
availablePlots
.
back
(
)
)
;
availablePlots
.
pop_back
(
)
;
-
-
usedPlots
;
}
if
(
!
usedPlots
|
|
!
availablePlots
.
size
(
)
)
{
break
;
}
}
plotIter
.
next
(
)
;
}
}
if
(
!
usedPlots
)
{
if
constexpr
(
kDumpAtlasData
)
{
SkDebugf
(
"
delete
%
d
\
n
"
fNumActivePages
-
1
)
;
}
this
-
>
deactivateLastPage
(
)
;
fFlushesSinceLastUse
=
0
;
}
}
fPrevFlushToken
=
startTokenForNextFlush
;
}
bool
DrawAtlas
:
:
createPages
(
AtlasGenerationCounter
*
generationCounter
)
{
SkASSERT
(
SkIsPow2
(
fTextureWidth
)
&
&
SkIsPow2
(
fTextureHeight
)
)
;
int
numPlotsX
=
fTextureWidth
/
fPlotWidth
;
int
numPlotsY
=
fTextureHeight
/
fPlotHeight
;
for
(
uint32_t
i
=
0
;
i
<
this
-
>
maxPages
(
)
;
+
+
i
)
{
fProxies
[
i
]
=
nullptr
;
fPages
[
i
]
.
fPlotArray
=
std
:
:
make_unique
<
sk_sp
<
Plot
>
[
]
>
(
numPlotsX
*
numPlotsY
)
;
sk_sp
<
Plot
>
*
currPlot
=
fPages
[
i
]
.
fPlotArray
.
get
(
)
;
for
(
int
y
=
numPlotsY
-
1
r
=
0
;
y
>
=
0
;
-
-
y
+
+
r
)
{
for
(
int
x
=
numPlotsX
-
1
c
=
0
;
x
>
=
0
;
-
-
x
+
+
c
)
{
uint32_t
plotIndex
=
r
*
numPlotsX
+
c
;
currPlot
-
>
reset
(
new
Plot
(
i
plotIndex
generationCounter
x
y
fPlotWidth
fPlotHeight
fColorType
fBytesPerPixel
)
)
;
fPages
[
i
]
.
fPlotList
.
addToHead
(
currPlot
-
>
get
(
)
)
;
+
+
currPlot
;
}
}
}
return
true
;
}
bool
DrawAtlas
:
:
activateNewPage
(
Recorder
*
recorder
)
{
SkASSERT
(
fNumActivePages
<
this
-
>
maxPages
(
)
)
;
SkASSERT
(
!
fProxies
[
fNumActivePages
]
)
;
auto
textureInfo
=
recorder
-
>
priv
(
)
.
caps
(
)
-
>
getDefaultSampledTextureInfo
(
fColorType
Mipmapped
:
:
kNo
Protected
:
:
kNo
Renderable
:
:
kNo
)
;
fProxies
[
fNumActivePages
]
.
reset
(
new
TextureProxy
(
{
fTextureWidth
fTextureHeight
}
textureInfo
skgpu
:
:
Budgeted
:
:
kYes
)
)
;
if
(
!
fProxies
[
fNumActivePages
]
)
{
return
false
;
}
if
constexpr
(
kDumpAtlasData
)
{
SkDebugf
(
"
activated
page
#
:
%
d
\
n
"
fNumActivePages
)
;
}
+
+
fNumActivePages
;
return
true
;
}
inline
void
DrawAtlas
:
:
deactivateLastPage
(
)
{
SkASSERT
(
fNumActivePages
)
;
uint32_t
lastPageIndex
=
fNumActivePages
-
1
;
int
numPlotsX
=
fTextureWidth
/
fPlotWidth
;
int
numPlotsY
=
fTextureHeight
/
fPlotHeight
;
fPages
[
lastPageIndex
]
.
fPlotList
.
reset
(
)
;
for
(
int
r
=
0
;
r
<
numPlotsY
;
+
+
r
)
{
for
(
int
c
=
0
;
c
<
numPlotsX
;
+
+
c
)
{
uint32_t
plotIndex
=
r
*
numPlotsX
+
c
;
Plot
*
currPlot
=
fPages
[
lastPageIndex
]
.
fPlotArray
[
plotIndex
]
.
get
(
)
;
currPlot
-
>
resetRects
(
)
;
currPlot
-
>
resetFlushesSinceLastUsed
(
)
;
SkDEBUGCODE
(
currPlot
-
>
resetListPtrs
(
)
)
;
fPages
[
lastPageIndex
]
.
fPlotList
.
addToHead
(
currPlot
)
;
}
}
fProxies
[
lastPageIndex
]
.
reset
(
)
;
-
-
fNumActivePages
;
}
void
DrawAtlas
:
:
evictAllPlots
(
)
{
PlotList
:
:
Iter
plotIter
;
for
(
uint32_t
pageIndex
=
0
;
pageIndex
<
fNumActivePages
;
+
+
pageIndex
)
{
plotIter
.
init
(
fPages
[
pageIndex
]
.
fPlotList
PlotList
:
:
Iter
:
:
kHead_IterStart
)
;
while
(
Plot
*
plot
=
plotIter
.
get
(
)
)
{
this
-
>
processEvictionAndResetRects
(
plot
)
;
plotIter
.
next
(
)
;
}
}
}
DrawAtlasConfig
:
:
DrawAtlasConfig
(
int
maxTextureSize
size_t
maxBytes
)
{
static
const
SkISize
kARGBDimensions
[
]
=
{
{
256
256
}
{
512
256
}
{
512
512
}
{
1024
512
}
{
1024
1024
}
{
2048
1024
}
}
;
maxBytes
>
>
=
18
;
int
index
=
maxBytes
>
0
?
SkTPin
<
int
>
(
SkPrevLog2
(
maxBytes
)
0
std
:
:
size
(
kARGBDimensions
)
-
1
)
:
0
;
SkASSERT
(
kARGBDimensions
[
index
]
.
width
(
)
<
=
kMaxAtlasDim
)
;
SkASSERT
(
kARGBDimensions
[
index
]
.
height
(
)
<
=
kMaxAtlasDim
)
;
fARGBDimensions
.
set
(
std
:
:
min
<
int
>
(
kARGBDimensions
[
index
]
.
width
(
)
maxTextureSize
)
std
:
:
min
<
int
>
(
kARGBDimensions
[
index
]
.
height
(
)
maxTextureSize
)
)
;
fMaxTextureSize
=
std
:
:
min
<
int
>
(
maxTextureSize
kMaxAtlasDim
)
;
}
SkISize
DrawAtlasConfig
:
:
atlasDimensions
(
MaskFormat
type
)
const
{
if
(
MaskFormat
:
:
kA8
=
=
type
)
{
return
{
std
:
:
min
<
int
>
(
2
*
fARGBDimensions
.
width
(
)
fMaxTextureSize
)
std
:
:
min
<
int
>
(
2
*
fARGBDimensions
.
height
(
)
fMaxTextureSize
)
}
;
}
else
{
return
fARGBDimensions
;
}
}
SkISize
DrawAtlasConfig
:
:
plotDimensions
(
MaskFormat
type
)
const
{
if
(
MaskFormat
:
:
kA8
=
=
type
)
{
SkISize
atlasDimensions
=
this
-
>
atlasDimensions
(
type
)
;
int
plotWidth
=
atlasDimensions
.
width
(
)
>
=
2048
?
512
:
256
;
int
plotHeight
=
atlasDimensions
.
height
(
)
>
=
2048
?
512
:
256
;
return
{
plotWidth
plotHeight
}
;
}
else
{
return
{
256
256
}
;
}
}
bool
PlotUploadTracker
:
:
needsUpload
(
PlotLocator
plotLocator
AtlasToken
uploadToken
uint32_t
atlasID
)
{
uint32_t
key
=
plotLocator
.
pageIndex
(
)
<
<
8
|
plotLocator
.
plotIndex
(
)
;
PlotAgeData
*
ageData
=
fAtlasData
[
atlasID
]
.
find
(
key
)
;
if
(
!
ageData
|
|
ageData
-
>
genID
!
=
plotLocator
.
genID
(
)
|
|
ageData
-
>
uploadToken
<
uploadToken
)
{
PlotAgeData
data
{
plotLocator
.
genID
(
)
uploadToken
}
;
fAtlasData
[
atlasID
]
.
set
(
key
data
)
;
return
true
;
}
return
false
;
}
}
