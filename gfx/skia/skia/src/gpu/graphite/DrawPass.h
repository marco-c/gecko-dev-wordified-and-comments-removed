#
ifndef
skgpu_graphite_DrawPass_DEFINED
#
define
skgpu_graphite_DrawPass_DEFINED
#
include
"
include
/
core
/
SkColor
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
src
/
core
/
SkEnumBitMask
.
h
"
#
include
"
src
/
gpu
/
graphite
/
AttachmentTypes
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawCommands
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawTypes
.
h
"
#
include
"
src
/
gpu
/
graphite
/
GraphicsPipelineDesc
.
h
"
#
include
"
src
/
gpu
/
graphite
/
ResourceTypes
.
h
"
#
include
<
memory
>
struct
SkImageInfo
;
namespace
skgpu
:
:
graphite
{
class
BoundsManager
;
class
CommandBuffer
;
class
DrawList
;
class
GraphicsPipeline
;
class
Recorder
;
struct
RenderPassDesc
;
class
ResourceProvider
;
class
RuntimeEffectDictionary
;
class
Sampler
;
class
TextureDataBlock
;
class
TextureProxy
;
class
Texture
;
enum
class
UniformSlot
;
class
DrawPass
{
public
:
~
DrawPass
(
)
;
static
std
:
:
unique_ptr
<
DrawPass
>
Make
(
Recorder
*
std
:
:
unique_ptr
<
DrawList
>
sk_sp
<
TextureProxy
>
target
const
SkImageInfo
&
targetInfo
std
:
:
pair
<
LoadOp
StoreOp
>
std
:
:
array
<
float
4
>
clearColor
)
;
const
SkIRect
&
bounds
(
)
const
{
return
fBounds
;
}
TextureProxy
*
target
(
)
const
{
return
fTarget
.
get
(
)
;
}
std
:
:
pair
<
LoadOp
StoreOp
>
ops
(
)
const
{
return
fOps
;
}
std
:
:
array
<
float
4
>
clearColor
(
)
const
{
return
fClearColor
;
}
bool
requiresDstTexture
(
)
const
{
return
false
;
}
bool
requiresMSAA
(
)
const
{
return
fRequiresMSAA
;
}
SkEnumBitMask
<
DepthStencilFlags
>
depthStencilFlags
(
)
const
{
return
fDepthStencilFlags
;
}
size_t
vertexBufferSize
(
)
const
{
return
0
;
}
size_t
uniformBufferSize
(
)
const
{
return
0
;
}
bool
prepareResources
(
ResourceProvider
*
const
RuntimeEffectDictionary
*
const
RenderPassDesc
&
)
;
DrawPassCommands
:
:
List
:
:
Iter
commands
(
)
const
{
return
fCommandList
.
commands
(
)
;
}
const
GraphicsPipeline
*
getPipeline
(
size_t
index
)
const
{
return
fFullPipelines
[
index
]
.
get
(
)
;
}
const
Texture
*
getTexture
(
size_t
index
)
const
;
const
Sampler
*
getSampler
(
size_t
index
)
const
;
void
addResourceRefs
(
CommandBuffer
*
)
const
;
private
:
class
SortKey
;
DrawPass
(
sk_sp
<
TextureProxy
>
target
std
:
:
pair
<
LoadOp
StoreOp
>
ops
std
:
:
array
<
float
4
>
clearColor
)
;
DrawPassCommands
:
:
List
fCommandList
;
sk_sp
<
TextureProxy
>
fTarget
;
SkIRect
fBounds
;
std
:
:
pair
<
LoadOp
StoreOp
>
fOps
;
std
:
:
array
<
float
4
>
fClearColor
;
SkEnumBitMask
<
DepthStencilFlags
>
fDepthStencilFlags
=
DepthStencilFlags
:
:
kNone
;
bool
fRequiresMSAA
=
false
;
SkTArray
<
GraphicsPipelineDesc
>
fPipelineDescs
;
SkTArray
<
SamplerDesc
>
fSamplerDescs
;
SkTArray
<
sk_sp
<
GraphicsPipeline
>
>
fFullPipelines
;
SkTArray
<
sk_sp
<
TextureProxy
>
>
fSampledTextures
;
SkTArray
<
sk_sp
<
Sampler
>
>
fSamplers
;
}
;
}
#
endif
