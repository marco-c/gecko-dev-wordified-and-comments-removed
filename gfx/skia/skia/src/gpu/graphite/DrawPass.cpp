#
include
"
src
/
gpu
/
graphite
/
DrawPass
.
h
"
#
include
"
include
/
gpu
/
graphite
/
GraphiteTypes
.
h
"
#
include
"
include
/
gpu
/
graphite
/
Recorder
.
h
"
#
include
"
src
/
gpu
/
graphite
/
Buffer
.
h
"
#
include
"
src
/
gpu
/
graphite
/
BufferManager
.
h
"
#
include
"
src
/
gpu
/
graphite
/
Caps
.
h
"
#
include
"
src
/
gpu
/
graphite
/
ContextPriv
.
h
"
#
include
"
src
/
gpu
/
graphite
/
ContextUtils
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawContext
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawList
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawWriter
.
h
"
#
include
"
src
/
gpu
/
graphite
/
GlobalCache
.
h
"
#
include
"
src
/
gpu
/
graphite
/
GraphicsPipeline
.
h
"
#
include
"
src
/
gpu
/
graphite
/
GraphicsPipelineDesc
.
h
"
#
include
"
src
/
gpu
/
graphite
/
Log
.
h
"
#
include
"
src
/
gpu
/
graphite
/
PaintParamsKey
.
h
"
#
include
"
src
/
gpu
/
graphite
/
PipelineData
.
h
"
#
include
"
src
/
gpu
/
graphite
/
PipelineDataCache
.
h
"
#
include
"
src
/
gpu
/
graphite
/
RecorderPriv
.
h
"
#
include
"
src
/
gpu
/
graphite
/
Renderer
.
h
"
#
include
"
src
/
gpu
/
graphite
/
ResourceProvider
.
h
"
#
include
"
src
/
gpu
/
graphite
/
Sampler
.
h
"
#
include
"
src
/
gpu
/
graphite
/
Texture
.
h
"
#
include
"
src
/
gpu
/
graphite
/
TextureProxy
.
h
"
#
include
"
src
/
gpu
/
graphite
/
UniformManager
.
h
"
#
include
"
src
/
gpu
/
graphite
/
geom
/
BoundsManager
.
h
"
#
include
"
src
/
base
/
SkMathPriv
.
h
"
#
include
"
src
/
base
/
SkTBlockList
.
h
"
#
include
<
algorithm
>
#
include
<
unordered_map
>
namespace
skgpu
:
:
graphite
{
namespace
{
template
<
uint64_t
Bits
uint64_t
Offset
>
struct
Bitfield
{
static
constexpr
uint64_t
kMask
=
(
(
uint64_t
)
1
<
<
Bits
)
-
1
;
static
constexpr
uint64_t
kOffset
=
Offset
;
static
constexpr
uint64_t
kBits
=
Bits
;
static
uint32_t
get
(
uint64_t
v
)
{
return
static_cast
<
uint32_t
>
(
(
v
>
>
kOffset
)
&
kMask
)
;
}
static
uint64_t
set
(
uint32_t
v
)
{
return
(
v
&
kMask
)
<
<
kOffset
;
}
}
;
template
<
typename
T
typename
V
=
T
typename
C
=
V
>
class
DenseBiMap
{
public
:
using
Index
=
uint32_t
;
static
constexpr
Index
kInvalidIndex
{
1
<
<
SkNextLog2_portable
(
Renderer
:
:
kMaxRenderSteps
*
DrawList
:
:
kMaxDraws
)
}
;
bool
empty
(
)
const
{
return
fIndexToData
.
empty
(
)
;
}
size_t
size
(
)
const
{
return
fIndexToData
.
size
(
)
;
}
Index
insert
(
const
T
&
data
)
{
Index
*
index
=
fDataToIndex
.
find
(
data
)
;
if
(
!
index
)
{
SkASSERT
(
SkToU32
(
fIndexToData
.
size
(
)
)
<
kInvalidIndex
-
1
)
;
index
=
fDataToIndex
.
set
(
data
(
Index
)
fIndexToData
.
size
(
)
)
;
fIndexToData
.
push_back
(
C
{
data
}
)
;
}
return
*
index
;
}
const
V
&
lookup
(
Index
index
)
{
SkASSERT
(
index
<
kInvalidIndex
)
;
return
fIndexToData
[
index
]
;
}
SkSpan
<
V
>
data
(
)
{
return
{
fIndexToData
.
data
(
)
fIndexToData
.
size
(
)
}
;
}
SkTArray
<
V
>
&
&
detach
(
)
{
return
std
:
:
move
(
fIndexToData
)
;
}
private
:
SkTHashMap
<
T
Index
>
fDataToIndex
;
SkTArray
<
V
>
fIndexToData
;
}
;
struct
CpuOrGpuData
{
union
{
const
UniformDataBlock
*
fCpuData
;
BindBufferInfo
fGpuData
;
}
;
CpuOrGpuData
(
const
UniformDataBlock
*
cpuData
)
:
fCpuData
(
cpuData
)
{
}
}
;
struct
TextureBinding
{
const
TextureDataBlock
*
fPaintTextures
;
const
TextureDataBlock
*
fStepTextures
;
bool
operator
=
=
(
const
TextureBinding
&
other
)
const
{
return
fPaintTextures
=
=
other
.
fPaintTextures
&
&
fStepTextures
=
=
other
.
fStepTextures
;
}
bool
operator
!
=
(
const
TextureBinding
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
int
numTextures
(
)
const
{
return
(
fPaintTextures
?
fPaintTextures
-
>
numTextures
(
)
:
0
)
+
(
fStepTextures
?
fStepTextures
-
>
numTextures
(
)
:
0
)
;
}
}
;
using
UniformSsboCache
=
DenseBiMap
<
const
UniformDataBlock
*
CpuOrGpuData
>
;
using
TextureBindingCache
=
DenseBiMap
<
TextureBinding
>
;
using
GraphicsPipelineCache
=
DenseBiMap
<
GraphicsPipelineDesc
>
;
class
TextureBindingTracker
{
public
:
TextureBindingCache
:
:
Index
trackTextures
(
const
TextureDataBlock
*
paintTextures
const
TextureDataBlock
*
stepTextures
)
{
if
(
!
paintTextures
&
&
!
stepTextures
)
{
return
TextureBindingCache
:
:
kInvalidIndex
;
}
return
fBindingCache
.
insert
(
{
paintTextures
stepTextures
}
)
;
}
bool
setCurrentTextureBindings
(
TextureBindingCache
:
:
Index
bindingIndex
)
{
if
(
bindingIndex
<
TextureBindingCache
:
:
kInvalidIndex
&
&
fLastIndex
!
=
bindingIndex
)
{
fLastIndex
=
bindingIndex
;
return
true
;
}
return
false
;
}
void
bindTextures
(
DrawPassCommands
:
:
List
*
commandList
)
{
SkASSERT
(
fLastIndex
<
TextureBindingCache
:
:
kInvalidIndex
)
;
const
TextureBinding
&
binding
=
fBindingCache
.
lookup
(
fLastIndex
)
;
auto
[
texIndices
samplerIndices
]
=
commandList
-
>
bindDeferredTexturesAndSamplers
(
binding
.
numTextures
(
)
)
;
if
(
binding
.
fPaintTextures
)
{
for
(
int
i
=
0
;
i
<
binding
.
fPaintTextures
-
>
numTextures
(
)
;
+
+
i
)
{
auto
[
tex
sampler
]
=
binding
.
fPaintTextures
-
>
texture
(
i
)
;
*
texIndices
+
+
=
fProxyCache
.
insert
(
tex
.
get
(
)
)
;
*
samplerIndices
+
+
=
fSamplerCache
.
insert
(
sampler
)
;
}
}
if
(
binding
.
fStepTextures
)
{
for
(
int
i
=
0
;
i
<
binding
.
fStepTextures
-
>
numTextures
(
)
;
+
+
i
)
{
auto
[
tex
sampler
]
=
binding
.
fStepTextures
-
>
texture
(
i
)
;
*
texIndices
+
+
=
fProxyCache
.
insert
(
tex
.
get
(
)
)
;
*
samplerIndices
+
+
=
fSamplerCache
.
insert
(
sampler
)
;
}
}
}
SkTArray
<
sk_sp
<
TextureProxy
>
>
&
&
detachTextures
(
)
{
return
fProxyCache
.
detach
(
)
;
}
SkTArray
<
SamplerDesc
>
&
&
detachSamplers
(
)
{
return
fSamplerCache
.
detach
(
)
;
}
private
:
struct
ProxyRef
{
const
TextureProxy
*
fProxy
;
operator
sk_sp
<
TextureProxy
>
(
)
const
{
return
sk_ref_sp
(
fProxy
)
;
}
}
;
using
TextureProxyCache
=
DenseBiMap
<
const
TextureProxy
*
sk_sp
<
TextureProxy
>
ProxyRef
>
;
using
SamplerDescCache
=
DenseBiMap
<
SamplerDesc
>
;
TextureBindingCache
fBindingCache
;
TextureProxyCache
fProxyCache
;
SamplerDescCache
fSamplerCache
;
TextureBindingCache
:
:
Index
fLastIndex
=
TextureBindingCache
:
:
kInvalidIndex
;
}
;
class
UniformSsboTracker
{
public
:
UniformSsboTracker
(
bool
useStorageBuffers
)
:
fUseStorageBuffers
(
useStorageBuffers
)
{
}
UniformSsboCache
:
:
Index
trackUniforms
(
GraphicsPipelineCache
:
:
Index
pipelineIndex
const
UniformDataBlock
*
cpuData
)
{
if
(
!
cpuData
)
{
return
UniformSsboCache
:
:
kInvalidIndex
;
}
if
(
pipelineIndex
>
=
SkToU32
(
fPerPipelineCaches
.
size
(
)
)
)
{
fPerPipelineCaches
.
resize
(
pipelineIndex
+
1
)
;
}
return
fPerPipelineCaches
[
pipelineIndex
]
.
insert
(
cpuData
)
;
}
void
writeUniforms
(
DrawBufferManager
*
bufferMgr
)
{
for
(
UniformSsboCache
&
cache
:
fPerPipelineCaches
)
{
if
(
cache
.
empty
(
)
)
{
continue
;
}
size_t
udbSize
=
cache
.
lookup
(
0
)
.
fCpuData
-
>
size
(
)
;
size_t
udbDataSize
=
udbSize
;
if
(
!
fUseStorageBuffers
)
{
udbSize
=
bufferMgr
-
>
alignUniformBlockSize
(
udbSize
)
;
}
auto
[
writer
bufferInfo
]
=
fUseStorageBuffers
?
bufferMgr
-
>
getSsboWriter
(
udbSize
*
cache
.
size
(
)
)
:
bufferMgr
-
>
getUniformWriter
(
udbSize
*
cache
.
size
(
)
)
;
for
(
CpuOrGpuData
&
dataBlock
:
cache
.
data
(
)
)
{
SkASSERT
(
dataBlock
.
fCpuData
-
>
size
(
)
=
=
udbDataSize
)
;
writer
.
write
(
dataBlock
.
fCpuData
-
>
data
(
)
udbDataSize
)
;
dataBlock
.
fGpuData
=
bufferInfo
;
if
(
!
fUseStorageBuffers
)
{
bufferInfo
.
fOffset
+
=
udbSize
;
writer
.
skipBytes
(
udbSize
-
udbDataSize
)
;
}
}
}
}
bool
setCurrentUniforms
(
GraphicsPipelineCache
:
:
Index
pipelineIndex
UniformSsboCache
:
:
Index
ssboIndex
)
{
if
(
ssboIndex
>
=
UniformSsboCache
:
:
kInvalidIndex
)
{
return
false
;
}
SkASSERT
(
pipelineIndex
<
SkToU32
(
fPerPipelineCaches
.
size
(
)
)
&
&
ssboIndex
<
fPerPipelineCaches
[
pipelineIndex
]
.
size
(
)
)
;
if
(
fUseStorageBuffers
)
{
ssboIndex
=
0
;
}
if
(
fLastPipeline
!
=
pipelineIndex
|
|
fLastIndex
!
=
ssboIndex
)
{
fLastPipeline
=
pipelineIndex
;
fLastIndex
=
ssboIndex
;
return
true
;
}
else
{
return
false
;
}
}
void
bindUniforms
(
UniformSlot
slot
DrawPassCommands
:
:
List
*
commandList
)
{
SkASSERT
(
fLastPipeline
<
GraphicsPipelineCache
:
:
kInvalidIndex
&
&
fLastIndex
<
UniformSsboCache
:
:
kInvalidIndex
)
;
SkASSERT
(
!
fUseStorageBuffers
|
|
fLastIndex
=
=
0
)
;
const
BindBufferInfo
&
binding
=
fPerPipelineCaches
[
fLastPipeline
]
.
lookup
(
fLastIndex
)
.
fGpuData
;
commandList
-
>
bindUniformBuffer
(
binding
slot
)
;
}
private
:
SkTArray
<
UniformSsboCache
>
fPerPipelineCaches
;
const
bool
fUseStorageBuffers
;
GraphicsPipelineCache
:
:
Index
fLastPipeline
=
GraphicsPipelineCache
:
:
kInvalidIndex
;
UniformSsboCache
:
:
Index
fLastIndex
=
UniformSsboCache
:
:
kInvalidIndex
;
}
;
}
class
DrawPass
:
:
SortKey
{
public
:
SortKey
(
const
DrawList
:
:
Draw
*
draw
int
renderStep
GraphicsPipelineCache
:
:
Index
pipelineIndex
UniformSsboCache
:
:
Index
geomSsboIndex
UniformSsboCache
:
:
Index
shadingSsboIndex
TextureBindingCache
:
:
Index
textureBindingIndex
)
:
fPipelineKey
(
ColorDepthOrderField
:
:
set
(
draw
-
>
fDrawParams
.
order
(
)
.
paintOrder
(
)
.
bits
(
)
)
|
StencilIndexField
:
:
set
(
draw
-
>
fDrawParams
.
order
(
)
.
stencilIndex
(
)
.
bits
(
)
)
|
RenderStepField
:
:
set
(
static_cast
<
uint32_t
>
(
renderStep
)
)
|
PipelineField
:
:
set
(
pipelineIndex
)
)
fUniformKey
(
GeometryUniformField
:
:
set
(
geomSsboIndex
)
|
ShadingUniformField
:
:
set
(
shadingSsboIndex
)
|
TextureBindingsField
:
:
set
(
textureBindingIndex
)
)
fDraw
(
draw
)
{
SkASSERT
(
pipelineIndex
<
GraphicsPipelineCache
:
:
kInvalidIndex
)
;
SkASSERT
(
renderStep
<
=
draw
-
>
fRenderer
-
>
numRenderSteps
(
)
)
;
}
bool
operator
<
(
const
SortKey
&
k
)
const
{
return
fPipelineKey
<
k
.
fPipelineKey
|
|
(
fPipelineKey
=
=
k
.
fPipelineKey
&
&
fUniformKey
<
k
.
fUniformKey
)
;
}
const
RenderStep
&
renderStep
(
)
const
{
return
fDraw
-
>
fRenderer
-
>
step
(
RenderStepField
:
:
get
(
fPipelineKey
)
)
;
}
const
DrawList
:
:
Draw
&
draw
(
)
const
{
return
*
fDraw
;
}
GraphicsPipelineCache
:
:
Index
pipelineIndex
(
)
const
{
return
PipelineField
:
:
get
(
fPipelineKey
)
;
}
UniformSsboCache
:
:
Index
geometrySsboIndex
(
)
const
{
return
GeometryUniformField
:
:
get
(
fUniformKey
)
;
}
UniformSsboCache
:
:
Index
shadingSsboIndex
(
)
const
{
return
ShadingUniformField
:
:
get
(
fUniformKey
)
;
}
TextureBindingCache
:
:
Index
textureBindingIndex
(
)
const
{
return
TextureBindingsField
:
:
get
(
fUniformKey
)
;
}
private
:
using
ColorDepthOrderField
=
Bitfield
<
16
48
>
;
using
StencilIndexField
=
Bitfield
<
16
32
>
;
using
RenderStepField
=
Bitfield
<
2
30
>
;
using
PipelineField
=
Bitfield
<
30
0
>
;
uint64_t
fPipelineKey
;
using
GeometryUniformField
=
Bitfield
<
22
42
>
;
using
ShadingUniformField
=
Bitfield
<
21
21
>
;
using
TextureBindingsField
=
Bitfield
<
21
0
>
;
uint64_t
fUniformKey
;
const
DrawList
:
:
Draw
*
fDraw
;
static_assert
(
ColorDepthOrderField
:
:
kBits
>
=
sizeof
(
CompressedPaintersOrder
)
)
;
static_assert
(
StencilIndexField
:
:
kBits
>
=
sizeof
(
DisjointStencilIndex
)
)
;
static_assert
(
RenderStepField
:
:
kBits
>
=
SkNextLog2_portable
(
Renderer
:
:
kMaxRenderSteps
)
)
;
static_assert
(
PipelineField
:
:
kBits
>
=
SkNextLog2_portable
(
Renderer
:
:
kMaxRenderSteps
*
DrawList
:
:
kMaxDraws
)
)
;
static_assert
(
GeometryUniformField
:
:
kBits
>
=
1
+
SkNextLog2_portable
(
Renderer
:
:
kMaxRenderSteps
*
DrawList
:
:
kMaxDraws
)
)
;
static_assert
(
ShadingUniformField
:
:
kBits
>
=
1
+
SkNextLog2_portable
(
Renderer
:
:
kMaxRenderSteps
*
DrawList
:
:
kMaxDraws
)
)
;
static_assert
(
TextureBindingsField
:
:
kBits
>
=
1
+
SkNextLog2_portable
(
Renderer
:
:
kMaxRenderSteps
*
DrawList
:
:
kMaxDraws
)
)
;
}
;
DrawPass
:
:
DrawPass
(
sk_sp
<
TextureProxy
>
target
std
:
:
pair
<
LoadOp
StoreOp
>
ops
std
:
:
array
<
float
4
>
clearColor
)
:
fTarget
(
std
:
:
move
(
target
)
)
fBounds
(
SkIRect
:
:
MakeEmpty
(
)
)
fOps
(
ops
)
fClearColor
(
clearColor
)
{
}
DrawPass
:
:
~
DrawPass
(
)
=
default
;
std
:
:
unique_ptr
<
DrawPass
>
DrawPass
:
:
Make
(
Recorder
*
recorder
std
:
:
unique_ptr
<
DrawList
>
draws
sk_sp
<
TextureProxy
>
target
const
SkImageInfo
&
targetInfo
std
:
:
pair
<
LoadOp
StoreOp
>
ops
std
:
:
array
<
float
4
>
clearColor
)
{
static_assert
(
sizeof
(
DrawPass
:
:
SortKey
)
=
=
16
+
sizeof
(
void
*
)
)
;
std
:
:
unique_ptr
<
DrawPass
>
drawPass
(
new
DrawPass
(
std
:
:
move
(
target
)
ops
clearColor
)
)
;
Rect
passBounds
=
Rect
:
:
InfiniteInverted
(
)
;
UniformDataCache
geometryUniformDataCache
;
TextureDataCache
*
textureDataCache
=
recorder
-
>
priv
(
)
.
textureDataCache
(
)
;
DrawBufferManager
*
bufferMgr
=
recorder
-
>
priv
(
)
.
drawBufferManager
(
)
;
GraphicsPipelineCache
pipelineCache
;
const
ResourceBindingRequirements
&
bindingReqs
=
recorder
-
>
priv
(
)
.
caps
(
)
-
>
resourceBindingRequirements
(
)
;
Layout
geometryUniformLayout
=
bindingReqs
.
fUniformBufferLayout
;
UniformSsboTracker
geometrySsboTracker
(
false
)
;
bool
useStorageBuffers
=
recorder
-
>
priv
(
)
.
caps
(
)
-
>
storageBufferPreferred
(
)
;
Layout
shadingUniformLayout
=
useStorageBuffers
?
bindingReqs
.
fStorageBufferLayout
:
bindingReqs
.
fUniformBufferLayout
;
UniformSsboTracker
shadingSsboTracker
(
useStorageBuffers
)
;
TextureBindingTracker
textureBindingTracker
;
ShaderCodeDictionary
*
dict
=
recorder
-
>
priv
(
)
.
shaderCodeDictionary
(
)
;
PaintParamsKeyBuilder
builder
(
dict
)
;
PipelineDataGatherer
gatherer
(
shadingUniformLayout
)
;
std
:
:
vector
<
SortKey
>
keys
;
keys
.
reserve
(
draws
-
>
renderStepCount
(
)
)
;
for
(
const
DrawList
:
:
Draw
&
draw
:
draws
-
>
fDraws
.
items
(
)
)
{
UniquePaintParamsID
shaderID
;
const
UniformDataBlock
*
shadingUniforms
=
nullptr
;
const
TextureDataBlock
*
paintTextures
=
nullptr
;
if
(
draw
.
fPaintParams
.
has_value
(
)
)
{
std
:
:
tie
(
shaderID
shadingUniforms
paintTextures
)
=
ExtractPaintData
(
recorder
&
gatherer
&
builder
shadingUniformLayout
draw
.
fDrawParams
.
transform
(
)
draw
.
fPaintParams
.
value
(
)
targetInfo
.
colorInfo
(
)
)
;
}
for
(
int
stepIndex
=
0
;
stepIndex
<
draw
.
fRenderer
-
>
numRenderSteps
(
)
;
+
+
stepIndex
)
{
const
RenderStep
*
const
step
=
draw
.
fRenderer
-
>
steps
(
)
[
stepIndex
]
;
const
bool
performsShading
=
draw
.
fPaintParams
.
has_value
(
)
&
&
step
-
>
performsShading
(
)
;
GraphicsPipelineCache
:
:
Index
pipelineIndex
=
pipelineCache
.
insert
(
{
step
performsShading
?
shaderID
:
UniquePaintParamsID
:
:
InvalidID
(
)
}
)
;
auto
[
geometryUniforms
stepTextures
]
=
ExtractRenderStepData
(
&
geometryUniformDataCache
textureDataCache
&
gatherer
geometryUniformLayout
step
draw
.
fDrawParams
)
;
UniformSsboCache
:
:
Index
geomSsboIndex
=
geometrySsboTracker
.
trackUniforms
(
pipelineIndex
geometryUniforms
)
;
UniformSsboCache
:
:
Index
shadingSsboIndex
=
shadingSsboTracker
.
trackUniforms
(
pipelineIndex
performsShading
?
shadingUniforms
:
nullptr
)
;
TextureBindingCache
:
:
Index
textureIndex
=
textureBindingTracker
.
trackTextures
(
performsShading
?
paintTextures
:
nullptr
stepTextures
)
;
keys
.
push_back
(
{
&
draw
stepIndex
pipelineIndex
geomSsboIndex
shadingSsboIndex
textureIndex
}
)
;
}
passBounds
.
join
(
draw
.
fDrawParams
.
clip
(
)
.
drawBounds
(
)
)
;
drawPass
-
>
fDepthStencilFlags
|
=
draw
.
fRenderer
-
>
depthStencilFlags
(
)
;
drawPass
-
>
fRequiresMSAA
|
=
draw
.
fRenderer
-
>
requiresMSAA
(
)
;
}
geometrySsboTracker
.
writeUniforms
(
bufferMgr
)
;
shadingSsboTracker
.
writeUniforms
(
bufferMgr
)
;
std
:
:
sort
(
keys
.
begin
(
)
keys
.
end
(
)
)
;
DrawWriter
drawWriter
(
&
drawPass
-
>
fCommandList
bufferMgr
)
;
GraphicsPipelineCache
:
:
Index
lastPipeline
=
GraphicsPipelineCache
:
:
kInvalidIndex
;
SkIRect
lastScissor
=
SkIRect
:
:
MakeSize
(
targetInfo
.
dimensions
(
)
)
;
SkASSERT
(
!
drawPass
-
>
fTarget
-
>
isInstantiated
(
)
|
|
SkIRect
:
:
MakeSize
(
drawPass
-
>
fTarget
-
>
dimensions
(
)
)
.
contains
(
lastScissor
)
)
;
drawPass
-
>
fCommandList
.
setScissor
(
lastScissor
)
;
for
(
const
SortKey
&
key
:
keys
)
{
const
DrawList
:
:
Draw
&
draw
=
key
.
draw
(
)
;
const
RenderStep
&
renderStep
=
key
.
renderStep
(
)
;
const
bool
pipelineChange
=
key
.
pipelineIndex
(
)
!
=
lastPipeline
;
const
bool
geomBindingChange
=
geometrySsboTracker
.
setCurrentUniforms
(
key
.
pipelineIndex
(
)
key
.
geometrySsboIndex
(
)
)
;
const
bool
shadingBindingChange
=
shadingSsboTracker
.
setCurrentUniforms
(
key
.
pipelineIndex
(
)
key
.
shadingSsboIndex
(
)
)
;
const
bool
textureBindingsChange
=
textureBindingTracker
.
setCurrentTextureBindings
(
key
.
textureBindingIndex
(
)
)
;
const
SkIRect
*
newScissor
=
draw
.
fDrawParams
.
clip
(
)
.
scissor
(
)
!
=
lastScissor
?
&
draw
.
fDrawParams
.
clip
(
)
.
scissor
(
)
:
nullptr
;
const
bool
stateChange
=
geomBindingChange
|
|
shadingBindingChange
|
|
textureBindingsChange
|
|
SkToBool
(
newScissor
)
;
if
(
pipelineChange
)
{
drawWriter
.
newPipelineState
(
renderStep
.
primitiveType
(
)
renderStep
.
vertexStride
(
)
renderStep
.
instanceStride
(
)
)
;
}
else
if
(
stateChange
)
{
drawWriter
.
newDynamicState
(
)
;
}
if
(
pipelineChange
)
{
drawPass
-
>
fCommandList
.
bindGraphicsPipeline
(
key
.
pipelineIndex
(
)
)
;
lastPipeline
=
key
.
pipelineIndex
(
)
;
}
if
(
stateChange
)
{
if
(
geomBindingChange
)
{
geometrySsboTracker
.
bindUniforms
(
UniformSlot
:
:
kRenderStep
&
drawPass
-
>
fCommandList
)
;
}
if
(
shadingBindingChange
)
{
shadingSsboTracker
.
bindUniforms
(
UniformSlot
:
:
kPaint
&
drawPass
-
>
fCommandList
)
;
}
if
(
textureBindingsChange
)
{
textureBindingTracker
.
bindTextures
(
&
drawPass
-
>
fCommandList
)
;
}
if
(
newScissor
)
{
drawPass
-
>
fCommandList
.
setScissor
(
*
newScissor
)
;
lastScissor
=
*
newScissor
;
}
}
renderStep
.
writeVertices
(
&
drawWriter
draw
.
fDrawParams
key
.
shadingSsboIndex
(
)
)
;
}
drawWriter
.
flush
(
)
;
drawPass
-
>
fBounds
=
passBounds
.
roundOut
(
)
.
asSkIRect
(
)
;
drawPass
-
>
fPipelineDescs
=
pipelineCache
.
detach
(
)
;
drawPass
-
>
fSamplerDescs
=
textureBindingTracker
.
detachSamplers
(
)
;
drawPass
-
>
fSampledTextures
=
textureBindingTracker
.
detachTextures
(
)
;
return
drawPass
;
}
bool
DrawPass
:
:
prepareResources
(
ResourceProvider
*
resourceProvider
const
RuntimeEffectDictionary
*
runtimeDict
const
RenderPassDesc
&
renderPassDesc
)
{
fFullPipelines
.
reserve_back
(
fPipelineDescs
.
size
(
)
)
;
for
(
const
GraphicsPipelineDesc
&
pipelineDesc
:
fPipelineDescs
)
{
auto
pipeline
=
resourceProvider
-
>
findOrCreateGraphicsPipeline
(
runtimeDict
pipelineDesc
renderPassDesc
)
;
if
(
!
pipeline
)
{
SKGPU_LOG_W
(
"
Failed
to
create
GraphicsPipeline
for
draw
in
RenderPass
.
Dropping
pass
!
"
)
;
return
false
;
}
fFullPipelines
.
push_back
(
std
:
:
move
(
pipeline
)
)
;
}
fPipelineDescs
.
clear
(
)
;
for
(
int
i
=
0
;
i
<
fSampledTextures
.
size
(
)
;
+
+
i
)
{
if
(
!
fSampledTextures
[
i
]
-
>
textureInfo
(
)
.
isValid
(
)
)
{
SKGPU_LOG_W
(
"
Failed
to
validate
sampled
texture
.
Will
not
create
renderpass
!
"
)
;
return
false
;
}
if
(
!
TextureProxy
:
:
InstantiateIfNotLazy
(
resourceProvider
fSampledTextures
[
i
]
.
get
(
)
)
)
{
SKGPU_LOG_W
(
"
Failed
to
instantiate
sampled
texture
.
Will
not
create
renderpass
!
"
)
;
return
false
;
}
}
fSamplers
.
reserve_back
(
fSamplerDescs
.
size
(
)
)
;
for
(
int
i
=
0
;
i
<
fSamplerDescs
.
size
(
)
;
+
+
i
)
{
sk_sp
<
Sampler
>
sampler
=
resourceProvider
-
>
findOrCreateCompatibleSampler
(
fSamplerDescs
[
i
]
.
fSamplingOptions
fSamplerDescs
[
i
]
.
fTileModes
[
0
]
fSamplerDescs
[
i
]
.
fTileModes
[
1
]
)
;
if
(
!
sampler
)
{
SKGPU_LOG_W
(
"
Failed
to
create
sampler
.
Will
not
create
renderpass
!
"
)
;
return
false
;
}
fSamplers
.
push_back
(
std
:
:
move
(
sampler
)
)
;
}
fSamplerDescs
.
clear
(
)
;
return
true
;
}
void
DrawPass
:
:
addResourceRefs
(
CommandBuffer
*
commandBuffer
)
const
{
for
(
int
i
=
0
;
i
<
fFullPipelines
.
size
(
)
;
+
+
i
)
{
commandBuffer
-
>
trackResource
(
fFullPipelines
[
i
]
)
;
}
for
(
int
i
=
0
;
i
<
fSampledTextures
.
size
(
)
;
+
+
i
)
{
commandBuffer
-
>
trackResource
(
fSampledTextures
[
i
]
-
>
refTexture
(
)
)
;
}
for
(
int
i
=
0
;
i
<
fSamplers
.
size
(
)
;
+
+
i
)
{
commandBuffer
-
>
trackResource
(
fSamplers
[
i
]
)
;
}
}
const
Texture
*
DrawPass
:
:
getTexture
(
size_t
index
)
const
{
SkASSERT
(
index
<
SkToSizeT
(
fSampledTextures
.
size
(
)
)
)
;
SkASSERT
(
fSampledTextures
[
index
]
)
;
SkASSERT
(
fSampledTextures
[
index
]
-
>
texture
(
)
)
;
return
fSampledTextures
[
index
]
-
>
texture
(
)
;
}
const
Sampler
*
DrawPass
:
:
getSampler
(
size_t
index
)
const
{
SkASSERT
(
index
<
SkToSizeT
(
fSamplers
.
size
(
)
)
)
;
SkASSERT
(
fSamplers
[
index
]
)
;
return
fSamplers
[
index
]
.
get
(
)
;
}
}
