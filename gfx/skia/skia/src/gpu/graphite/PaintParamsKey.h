#
ifndef
skgpu_graphite_PaintParamsKey_DEFINED
#
define
skgpu_graphite_PaintParamsKey_DEFINED
#
include
"
include
/
core
/
SkColor
.
h
"
#
include
"
include
/
core
/
SkSpan
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkMacros
.
h
"
#
include
"
include
/
private
/
base
/
SkTDArray
.
h
"
#
include
"
src
/
gpu
/
Blend
.
h
"
#
include
"
src
/
gpu
/
graphite
/
BuiltInCodeSnippetID
.
h
"
#
include
<
array
>
#
include
<
limits
>
namespace
skgpu
:
:
graphite
{
class
PaintParamsKeyBuilder
;
class
ShaderCodeDictionary
;
class
ShaderInfo
;
struct
ShaderSnippet
;
class
PaintParamsKey
{
public
:
#
pragma
pack
(
push
1
)
struct
Header
{
int32_t
codeSnippetID
;
uint8_t
blockSize
;
}
;
#
pragma
pack
(
pop
)
static
const
int
kBlockSizeOffsetInBytes
=
offsetof
(
Header
blockSize
)
;
static
const
int
kMaxBlockSize
=
std
:
:
numeric_limits
<
uint8_t
>
:
:
max
(
)
;
enum
class
DataPayloadType
{
kByte
kInt
kFloat4
}
;
struct
DataPayloadField
{
const
char
*
fName
;
DataPayloadType
fType
;
uint32_t
fCount
;
}
;
~
PaintParamsKey
(
)
;
class
BlockReader
{
public
:
uint8_t
blockSize
(
)
const
{
SkASSERT
(
fBlock
[
kBlockSizeOffsetInBytes
]
=
=
fBlock
.
size
(
)
)
;
return
SkTo
<
uint8_t
>
(
fBlock
.
size
(
)
)
;
}
int
numChildren
(
)
const
;
int32_t
codeSnippetId
(
)
const
;
BlockReader
child
(
const
ShaderCodeDictionary
*
int
childIndex
)
const
;
SkSpan
<
const
uint8_t
>
bytes
(
int
fieldIndex
)
const
;
SkSpan
<
const
int32_t
>
ints
(
int
fieldIndex
)
const
;
SkSpan
<
const
SkColor4f
>
colors
(
int
fieldIndex
)
const
;
const
ShaderSnippet
*
entry
(
)
const
{
return
fEntry
;
}
#
ifdef
SK_DEBUG
int
numDataPayloadFields
(
)
const
;
void
dump
(
const
ShaderCodeDictionary
*
int
indent
)
const
;
#
endif
private
:
friend
class
PaintParamsKey
;
BlockReader
(
const
ShaderCodeDictionary
*
SkSpan
<
const
uint8_t
>
parentSpan
int
offsetInParent
)
;
SkSpan
<
const
uint8_t
>
dataPayload
(
)
const
;
SkSpan
<
const
uint8_t
>
fBlock
;
const
ShaderSnippet
*
fEntry
;
}
;
BlockReader
reader
(
const
ShaderCodeDictionary
*
int
headerOffset
)
const
;
#
ifdef
SK_DEBUG
uint8_t
byte
(
int
offset
)
const
{
SkASSERT
(
offset
<
this
-
>
sizeInBytes
(
)
)
;
return
fData
[
offset
]
;
}
void
dump
(
const
ShaderCodeDictionary
*
)
const
;
#
endif
void
toShaderInfo
(
const
ShaderCodeDictionary
*
ShaderInfo
*
)
const
;
SkSpan
<
const
uint8_t
>
asSpan
(
)
const
{
return
fData
;
}
const
uint8_t
*
data
(
)
const
{
return
fData
.
data
(
)
;
}
int
sizeInBytes
(
)
const
{
return
SkTo
<
int
>
(
fData
.
size
(
)
)
;
}
bool
operator
=
=
(
const
PaintParamsKey
&
that
)
const
;
bool
operator
!
=
(
const
PaintParamsKey
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
#
if
GRAPHITE_TEST_UTILS
bool
isErrorKey
(
)
const
;
#
endif
private
:
friend
class
PaintParamsKeyBuilder
;
friend
class
ShaderCodeDictionary
;
PaintParamsKey
(
SkSpan
<
const
uint8_t
>
span
PaintParamsKeyBuilder
*
originatingBuilder
)
;
PaintParamsKey
(
SkSpan
<
const
uint8_t
>
rawData
)
;
static
void
AddBlockToShaderInfo
(
const
ShaderCodeDictionary
*
const
BlockReader
&
ShaderInfo
*
)
;
SkSpan
<
const
uint8_t
>
fData
;
PaintParamsKeyBuilder
*
fOriginatingBuilder
;
}
;
class
PaintParamsKeyBuilder
{
public
:
PaintParamsKeyBuilder
(
const
ShaderCodeDictionary
*
)
;
~
PaintParamsKeyBuilder
(
)
{
SkASSERT
(
!
this
-
>
isLocked
(
)
)
;
}
void
setBlendInfo
(
const
skgpu
:
:
BlendInfo
&
blendInfo
)
{
fBlendInfo
=
blendInfo
;
}
const
skgpu
:
:
BlendInfo
&
blendInfo
(
)
const
{
return
fBlendInfo
;
}
void
beginBlock
(
int32_t
codeSnippetID
)
;
void
beginBlock
(
BuiltInCodeSnippetID
id
)
{
this
-
>
beginBlock
(
static_cast
<
int32_t
>
(
id
)
)
;
}
void
endBlock
(
)
;
void
addBytes
(
uint32_t
numBytes
const
uint8_t
*
data
)
;
void
addByte
(
uint8_t
data
)
{
this
-
>
addBytes
(
1
&
data
)
;
}
void
addInts
(
uint32_t
numInts
const
int32_t
*
data
)
;
void
addInt
(
int32_t
data
)
{
this
-
>
addInts
(
1
&
data
)
;
}
void
add
(
int
numColors
const
SkColor4f
*
colors
)
;
void
add
(
const
SkColor4f
&
color
)
{
this
-
>
add
(
1
&
color
)
;
}
#
ifdef
SK_DEBUG
void
checkReset
(
)
;
uint8_t
byte
(
int
offset
)
const
{
return
fData
[
offset
]
;
}
#
endif
PaintParamsKey
lockAsKey
(
)
;
int
sizeInBytes
(
)
const
{
return
fData
.
size
(
)
;
}
bool
isValid
(
)
const
{
return
fIsValid
;
}
void
lock
(
)
{
SkASSERT
(
!
fLocked
)
;
SkDEBUGCODE
(
fLocked
=
true
;
)
}
void
unlock
(
)
{
SkASSERT
(
fLocked
)
;
fData
.
clear
(
)
;
fBlendInfo
=
{
}
;
SkDEBUGCODE
(
fLocked
=
false
;
)
SkDEBUGCODE
(
this
-
>
checkReset
(
)
;
)
}
void
discard
(
)
{
SkASSERT
(
!
fIsValid
&
&
!
fLocked
)
;
fData
.
clear
(
)
;
fBlendInfo
=
{
}
;
fIsValid
=
true
;
SkDEBUGCODE
(
this
-
>
checkReset
(
)
)
;
}
SkDEBUGCODE
(
bool
isLocked
(
)
const
{
return
fLocked
;
}
)
private
:
void
addToKey
(
uint32_t
count
const
void
*
data
PaintParamsKey
:
:
DataPayloadType
payloadType
)
;
void
makeInvalid
(
)
;
#
ifdef
SK_DEBUG
void
checkExpectations
(
PaintParamsKey
:
:
DataPayloadType
actualType
uint32_t
actualCount
)
;
#
endif
struct
StackFrame
{
int
fCodeSnippetID
;
int
fHeaderOffset
;
#
ifdef
SK_DEBUG
SkSpan
<
const
PaintParamsKey
:
:
DataPayloadField
>
fDataPayloadExpectations
;
int
fCurDataPayloadEntry
=
0
;
int
fNumExpectedChildren
=
0
;
int
fNumActualChildren
=
0
;
#
endif
}
;
const
ShaderCodeDictionary
*
fDict
;
bool
fIsValid
=
true
;
SkDEBUGCODE
(
bool
fLocked
=
false
;
)
SkTDArray
<
StackFrame
>
fStack
;
SkTDArray
<
uint8_t
>
fData
;
skgpu
:
:
BlendInfo
fBlendInfo
;
}
;
}
#
endif
