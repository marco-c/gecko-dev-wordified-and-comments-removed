#
include
"
src
/
gpu
/
graphite
/
geom
/
IntersectionTree
.
h
"
#
include
"
include
/
private
/
base
/
SkTPin
.
h
"
#
include
"
src
/
base
/
SkVx
.
h
"
#
include
<
algorithm
>
#
include
<
limits
>
namespace
skgpu
:
:
graphite
{
template
<
IntersectionTree
:
:
SplitType
kSplitType
>
class
IntersectionTree
:
:
TreeNode
final
:
public
Node
{
public
:
TreeNode
(
float
splitCoord
Node
*
lo
Node
*
hi
)
:
fSplitCoord
(
splitCoord
)
fLo
(
lo
)
fHi
(
hi
)
{
}
bool
intersects
(
Rect
rect
)
override
{
if
(
GetLoVal
(
rect
)
<
fSplitCoord
&
&
fLo
-
>
intersects
(
rect
)
)
{
return
true
;
}
if
(
GetHiVal
(
rect
)
>
fSplitCoord
&
&
fHi
-
>
intersects
(
rect
)
)
{
return
true
;
}
return
false
;
}
Node
*
addNonIntersecting
(
Rect
rect
SkArenaAlloc
*
arena
)
override
{
if
(
GetLoVal
(
rect
)
<
fSplitCoord
)
{
fLo
=
fLo
-
>
addNonIntersecting
(
rect
arena
)
;
}
if
(
GetHiVal
(
rect
)
>
fSplitCoord
)
{
fHi
=
fHi
-
>
addNonIntersecting
(
rect
arena
)
;
}
return
this
;
}
private
:
SK_ALWAYS_INLINE
static
float
GetLoVal
(
const
Rect
&
rect
)
{
return
(
kSplitType
=
=
SplitType
:
:
kX
)
?
rect
.
left
(
)
:
rect
.
top
(
)
;
}
SK_ALWAYS_INLINE
static
float
GetHiVal
(
const
Rect
&
rect
)
{
return
(
kSplitType
=
=
SplitType
:
:
kX
)
?
rect
.
right
(
)
:
rect
.
bot
(
)
;
}
float
fSplitCoord
;
Node
*
fLo
;
Node
*
fHi
;
}
;
class
IntersectionTree
:
:
LeafNode
final
:
public
Node
{
public
:
constexpr
static
int
kMaxRectsInList
=
64
;
LeafNode
(
)
{
this
-
>
popAll
(
)
;
constexpr
static
float
infinity
=
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
;
std
:
:
fill_n
(
fLefts
kMaxRectsInList
infinity
)
;
std
:
:
fill_n
(
fTops
kMaxRectsInList
infinity
)
;
std
:
:
fill_n
(
fNegRights
kMaxRectsInList
infinity
)
;
std
:
:
fill_n
(
fNegBots
kMaxRectsInList
infinity
)
;
}
void
popAll
(
)
{
fNumRects
=
0
;
fSplittableBounds
=
-
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
;
fRectValsSum
=
0
;
}
bool
intersects
(
Rect
rect
)
override
{
static_assert
(
kMaxRectsInList
%
4
=
=
0
)
;
SkASSERT
(
fNumRects
<
=
kMaxRectsInList
)
;
auto
comp
=
Rect
:
:
ComplementRect
(
rect
)
.
fVals
;
for
(
int
i
=
0
;
i
<
fNumRects
;
i
+
=
4
)
{
auto
l
=
skvx
:
:
float4
:
:
Load
(
fLefts
+
i
)
;
auto
t
=
skvx
:
:
float4
:
:
Load
(
fTops
+
i
)
;
auto
nr
=
skvx
:
:
float4
:
:
Load
(
fNegRights
+
i
)
;
auto
nb
=
skvx
:
:
float4
:
:
Load
(
fNegBots
+
i
)
;
if
(
any
(
(
l
<
comp
[
0
]
)
&
(
t
<
comp
[
1
]
)
&
(
nr
<
comp
[
2
]
)
&
(
nb
<
comp
[
3
]
)
)
)
{
return
true
;
}
}
return
false
;
}
Node
*
addNonIntersecting
(
Rect
rect
SkArenaAlloc
*
arena
)
override
{
if
(
fNumRects
=
=
kMaxRectsInList
)
{
return
this
-
>
split
(
arena
)
-
>
addNonIntersecting
(
rect
arena
)
;
}
this
-
>
appendToList
(
rect
)
;
return
this
;
}
private
:
void
appendToList
(
Rect
rect
)
{
SkASSERT
(
fNumRects
<
kMaxRectsInList
)
;
int
i
=
fNumRects
+
+
;
fSplittableBounds
=
max
(
fSplittableBounds
rect
.
vals
(
)
)
;
fRectValsSum
+
=
rect
.
vals
(
)
;
fLefts
[
i
]
=
rect
.
vals
(
)
[
0
]
;
fTops
[
i
]
=
rect
.
vals
(
)
[
1
]
;
fNegRights
[
i
]
=
rect
.
vals
(
)
[
2
]
;
fNegBots
[
i
]
=
rect
.
vals
(
)
[
3
]
;
}
Rect
loadRect
(
int
i
)
const
{
return
Rect
:
:
FromVals
(
{
fLefts
[
i
]
fTops
[
i
]
fNegRights
[
i
]
fNegBots
[
i
]
}
)
;
}
IntersectionTree
:
:
Node
*
split
(
SkArenaAlloc
*
arena
)
{
SkASSERT
(
fNumRects
=
=
kMaxRectsInList
)
;
auto
splittableSize
=
fSplittableBounds
.
xy
(
)
+
fSplittableBounds
.
zw
(
)
;
SkASSERT
(
max
(
splittableSize
)
>
=
0
)
;
SplitType
splitType
=
(
splittableSize
.
x
(
)
>
splittableSize
.
y
(
)
)
?
SplitType
:
:
kX
:
SplitType
:
:
kY
;
float
splitCoord
;
const
float
*
loVals
*
negHiVals
;
if
(
splitType
=
=
SplitType
:
:
kX
)
{
splitCoord
=
(
fRectValsSum
.
x
(
)
-
fRectValsSum
.
z
(
)
)
*
(
.
5f
/
kMaxRectsInList
)
;
splitCoord
=
SkTPin
(
splitCoord
-
fSplittableBounds
.
z
(
)
fSplittableBounds
.
x
(
)
)
;
loVals
=
fLefts
;
negHiVals
=
fNegRights
;
}
else
{
splitCoord
=
(
fRectValsSum
.
y
(
)
-
fRectValsSum
.
w
(
)
)
*
(
.
5f
/
kMaxRectsInList
)
;
splitCoord
=
SkTPin
(
splitCoord
-
fSplittableBounds
.
w
(
)
fSplittableBounds
.
y
(
)
)
;
loVals
=
fTops
;
negHiVals
=
fNegBots
;
}
LeafNode
*
hiNode
=
arena
-
>
make
<
LeafNode
>
(
)
;
int
numCombinedRects
=
fNumRects
;
float
negSplitCoord
=
-
splitCoord
;
this
-
>
popAll
(
)
;
for
(
int
i
=
0
;
i
<
numCombinedRects
;
+
+
i
)
{
Rect
rect
=
this
-
>
loadRect
(
i
)
;
if
(
loVals
[
i
]
<
splitCoord
)
{
this
-
>
appendToList
(
rect
)
;
}
if
(
negHiVals
[
i
]
<
negSplitCoord
)
{
hiNode
-
>
appendToList
(
rect
)
;
}
}
SkASSERT
(
0
<
fNumRects
&
&
fNumRects
<
numCombinedRects
)
;
SkASSERT
(
0
<
hiNode
-
>
fNumRects
&
&
hiNode
-
>
fNumRects
<
numCombinedRects
)
;
return
(
splitType
=
=
SplitType
:
:
kX
)
?
(
Node
*
)
arena
-
>
make
<
TreeNode
<
SplitType
:
:
kX
>
>
(
splitCoord
this
hiNode
)
:
(
Node
*
)
arena
-
>
make
<
TreeNode
<
SplitType
:
:
kY
>
>
(
splitCoord
this
hiNode
)
;
}
int
fNumRects
;
skvx
:
:
float4
fSplittableBounds
;
skvx
:
:
float4
fRectValsSum
;
alignas
(
Rect
)
float
fLefts
[
kMaxRectsInList
]
;
alignas
(
Rect
)
float
fTops
[
kMaxRectsInList
]
;
alignas
(
Rect
)
float
fNegRights
[
kMaxRectsInList
]
;
alignas
(
Rect
)
float
fNegBots
[
kMaxRectsInList
]
;
static_assert
(
(
kMaxRectsInList
*
sizeof
(
float
)
)
%
sizeof
(
Rect
)
=
=
0
)
;
}
;
IntersectionTree
:
:
IntersectionTree
(
)
:
fRoot
(
fArena
.
make
<
LeafNode
>
(
)
)
{
static_assert
(
kTreeNodeSize
=
=
sizeof
(
TreeNode
<
SplitType
:
:
kX
>
)
)
;
static_assert
(
kTreeNodeSize
=
=
sizeof
(
TreeNode
<
SplitType
:
:
kY
>
)
)
;
static_assert
(
kLeafNodeSize
=
=
sizeof
(
LeafNode
)
)
;
}
}
