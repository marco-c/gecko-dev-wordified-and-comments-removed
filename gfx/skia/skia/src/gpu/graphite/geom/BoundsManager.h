#
ifndef
skgpu_graphite_geom_BoundsManager_DEFINED
#
define
skgpu_graphite_geom_BoundsManager_DEFINED
#
include
"
include
/
core
/
SkSize
.
h
"
#
include
"
include
/
private
/
base
/
SkTemplates
.
h
"
#
include
"
src
/
base
/
SkTBlockList
.
h
"
#
include
"
src
/
base
/
SkVx
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawOrder
.
h
"
#
include
"
src
/
gpu
/
graphite
/
geom
/
Rect
.
h
"
#
include
<
cstdint
>
namespace
skgpu
:
:
graphite
{
class
BoundsManager
{
public
:
virtual
~
BoundsManager
(
)
{
}
virtual
CompressedPaintersOrder
getMostRecentDraw
(
const
Rect
&
bounds
)
const
=
0
;
virtual
void
recordDraw
(
const
Rect
&
bounds
CompressedPaintersOrder
order
)
=
0
;
virtual
void
reset
(
)
=
0
;
}
;
class
NaiveBoundsManager
final
:
public
BoundsManager
{
public
:
~
NaiveBoundsManager
(
)
override
{
}
CompressedPaintersOrder
getMostRecentDraw
(
const
Rect
&
bounds
)
const
override
{
return
fLatestDraw
;
}
void
recordDraw
(
const
Rect
&
bounds
CompressedPaintersOrder
order
)
override
{
if
(
fLatestDraw
<
order
)
{
fLatestDraw
=
order
;
}
}
void
reset
(
)
override
{
fLatestDraw
=
CompressedPaintersOrder
:
:
First
(
)
;
}
private
:
CompressedPaintersOrder
fLatestDraw
=
CompressedPaintersOrder
:
:
First
(
)
;
}
;
class
BruteForceBoundsManager
:
public
BoundsManager
{
public
:
~
BruteForceBoundsManager
(
)
override
{
}
CompressedPaintersOrder
getMostRecentDraw
(
const
Rect
&
bounds
)
const
override
{
SkASSERT
(
fRects
.
count
(
)
=
=
fOrders
.
count
(
)
)
;
Rect
:
:
ComplementRect
boundsComplement
(
bounds
)
;
CompressedPaintersOrder
max
=
CompressedPaintersOrder
:
:
First
(
)
;
auto
orderIter
=
fOrders
.
items
(
)
.
begin
(
)
;
for
(
const
Rect
&
r
:
fRects
.
items
(
)
)
{
if
(
r
.
intersects
(
boundsComplement
)
&
&
max
<
*
orderIter
)
{
max
=
*
orderIter
;
}
+
+
orderIter
;
}
return
max
;
}
void
recordDraw
(
const
Rect
&
bounds
CompressedPaintersOrder
order
)
override
{
fRects
.
push_back
(
bounds
)
;
fOrders
.
push_back
(
order
)
;
}
void
reset
(
)
override
{
fRects
.
reset
(
)
;
fOrders
.
reset
(
)
;
}
int
count
(
)
const
{
return
fRects
.
count
(
)
;
}
void
replayDraws
(
BoundsManager
*
manager
)
const
{
auto
orderIter
=
fOrders
.
items
(
)
.
begin
(
)
;
for
(
const
Rect
&
r
:
fRects
.
items
(
)
)
{
manager
-
>
recordDraw
(
r
*
orderIter
)
;
+
+
orderIter
;
}
}
private
:
SkTBlockList
<
Rect
>
fRects
{
16
SkBlockAllocator
:
:
GrowthPolicy
:
:
kFibonacci
}
;
SkTBlockList
<
CompressedPaintersOrder
>
fOrders
{
16
SkBlockAllocator
:
:
GrowthPolicy
:
:
kFibonacci
}
;
}
;
class
GridBoundsManager
:
public
BoundsManager
{
public
:
static
std
:
:
unique_ptr
<
GridBoundsManager
>
Make
(
const
SkISize
&
deviceSize
const
SkISize
&
gridSize
)
{
SkASSERT
(
deviceSize
.
width
(
)
>
0
&
&
deviceSize
.
height
(
)
>
0
)
;
SkASSERT
(
gridSize
.
width
(
)
>
=
1
&
&
gridSize
.
height
(
)
>
=
1
)
;
return
std
:
:
unique_ptr
<
GridBoundsManager
>
(
new
GridBoundsManager
(
deviceSize
gridSize
)
)
;
}
static
std
:
:
unique_ptr
<
GridBoundsManager
>
Make
(
const
SkISize
&
deviceSize
int
gridSize
)
{
return
Make
(
deviceSize
{
gridSize
gridSize
}
)
;
}
static
std
:
:
unique_ptr
<
GridBoundsManager
>
MakeRes
(
const
SkISize
&
deviceSize
int
gridCellSize
)
{
SkASSERT
(
deviceSize
.
width
(
)
>
0
&
&
deviceSize
.
height
(
)
>
0
)
;
SkASSERT
(
gridCellSize
>
=
1
)
;
int
gridWidth
=
SkScalarCeilToInt
(
deviceSize
.
width
(
)
/
(
float
)
gridCellSize
)
;
int
gridHeight
=
SkScalarCeilToInt
(
deviceSize
.
height
(
)
/
(
float
)
gridCellSize
)
;
SkISize
paddedDeviceSize
=
{
gridWidth
*
gridCellSize
gridHeight
*
gridCellSize
}
;
return
Make
(
paddedDeviceSize
{
gridWidth
gridHeight
}
)
;
}
~
GridBoundsManager
(
)
override
{
}
CompressedPaintersOrder
getMostRecentDraw
(
const
Rect
&
bounds
)
const
override
{
SkASSERT
(
!
bounds
.
isEmptyNegativeOrNaN
(
)
)
;
auto
ltrb
=
this
-
>
getGridCoords
(
bounds
)
;
const
CompressedPaintersOrder
*
p
=
fNodes
.
data
(
)
+
ltrb
[
1
]
*
fGridWidth
+
ltrb
[
0
]
;
int
h
=
ltrb
[
3
]
-
ltrb
[
1
]
;
int
w
=
ltrb
[
2
]
-
ltrb
[
0
]
;
CompressedPaintersOrder
max
=
CompressedPaintersOrder
:
:
First
(
)
;
for
(
int
y
=
0
;
y
<
=
h
;
+
+
y
)
{
for
(
int
x
=
0
;
x
<
=
w
;
+
+
x
)
{
CompressedPaintersOrder
v
=
*
(
p
+
x
)
;
if
(
v
>
max
)
{
max
=
v
;
}
}
p
=
p
+
fGridWidth
;
}
return
max
;
}
void
recordDraw
(
const
Rect
&
bounds
CompressedPaintersOrder
order
)
override
{
SkASSERT
(
!
bounds
.
isEmptyNegativeOrNaN
(
)
)
;
auto
ltrb
=
this
-
>
getGridCoords
(
bounds
)
;
CompressedPaintersOrder
*
p
=
fNodes
.
data
(
)
+
ltrb
[
1
]
*
fGridWidth
+
ltrb
[
0
]
;
int
h
=
ltrb
[
3
]
-
ltrb
[
1
]
;
int
w
=
ltrb
[
2
]
-
ltrb
[
0
]
;
for
(
int
y
=
0
;
y
<
=
h
;
+
+
y
)
{
for
(
int
x
=
0
;
x
<
=
w
;
+
+
x
)
{
CompressedPaintersOrder
v
=
*
(
p
+
x
)
;
if
(
order
>
v
)
{
*
(
p
+
x
)
=
order
;
}
}
p
=
p
+
fGridWidth
;
}
}
void
reset
(
)
override
{
memset
(
fNodes
.
data
(
)
0
sizeof
(
CompressedPaintersOrder
)
*
fGridWidth
*
fGridHeight
)
;
}
private
:
GridBoundsManager
(
const
SkISize
&
deviceSize
const
SkISize
&
gridSize
)
:
fScaleX
(
gridSize
.
width
(
)
/
(
float
)
deviceSize
.
width
(
)
)
fScaleY
(
gridSize
.
height
(
)
/
(
float
)
deviceSize
.
height
(
)
)
fGridWidth
(
gridSize
.
width
(
)
)
fGridHeight
(
gridSize
.
height
(
)
)
fNodes
(
(
size_t
)
fGridWidth
*
fGridHeight
)
{
this
-
>
reset
(
)
;
}
skvx
:
:
int4
getGridCoords
(
const
Rect
&
bounds
)
const
{
return
pin
(
skvx
:
:
cast
<
int32_t
>
(
bounds
.
ltrb
(
)
*
skvx
:
:
float2
(
fScaleX
fScaleY
)
.
xyxy
(
)
)
skvx
:
:
int4
(
0
)
skvx
:
:
int2
(
fGridWidth
fGridHeight
)
.
xyxy
(
)
-
1
)
;
}
const
float
fScaleX
;
const
float
fScaleY
;
const
int
fGridWidth
;
const
int
fGridHeight
;
skia_private
:
:
AutoTMalloc
<
CompressedPaintersOrder
>
fNodes
;
}
;
class
HybridBoundsManager
:
public
BoundsManager
{
public
:
HybridBoundsManager
(
const
SkISize
&
deviceSize
int
gridCellSize
int
maxBruteForceN
)
:
fDeviceSize
(
deviceSize
)
fGridCellSize
(
gridCellSize
)
fMaxBruteForceN
(
maxBruteForceN
)
fCurrentManager
(
&
fBruteForceManager
)
{
SkASSERT
(
deviceSize
.
width
(
)
>
=
1
&
&
deviceSize
.
height
(
)
>
=
1
&
&
gridCellSize
>
=
1
&
&
maxBruteForceN
>
=
1
)
;
}
CompressedPaintersOrder
getMostRecentDraw
(
const
Rect
&
bounds
)
const
override
{
return
fCurrentManager
-
>
getMostRecentDraw
(
bounds
)
;
}
void
recordDraw
(
const
Rect
&
bounds
CompressedPaintersOrder
order
)
override
{
this
-
>
updateCurrentManagerIfNeeded
(
)
;
fCurrentManager
-
>
recordDraw
(
bounds
order
)
;
}
void
reset
(
)
override
{
const
bool
usedGrid
=
fCurrentManager
=
=
fGridManager
.
get
(
)
;
if
(
usedGrid
)
{
fGridManager
-
>
reset
(
)
;
fCurrentManager
=
&
fBruteForceManager
;
}
else
{
if
(
fGridManager
)
{
fGridManager
=
nullptr
;
}
fBruteForceManager
.
reset
(
)
;
SkASSERT
(
fCurrentManager
=
=
&
fBruteForceManager
)
;
}
}
private
:
const
SkISize
fDeviceSize
;
const
int
fGridCellSize
;
const
int
fMaxBruteForceN
;
BoundsManager
*
fCurrentManager
;
BruteForceBoundsManager
fBruteForceManager
;
std
:
:
unique_ptr
<
GridBoundsManager
>
fGridManager
;
void
updateCurrentManagerIfNeeded
(
)
{
if
(
fCurrentManager
=
=
fGridManager
.
get
(
)
|
|
fBruteForceManager
.
count
(
)
<
fMaxBruteForceN
)
{
return
;
}
if
(
!
fGridManager
)
{
fGridManager
=
GridBoundsManager
:
:
MakeRes
(
fDeviceSize
fGridCellSize
)
;
}
fCurrentManager
=
fGridManager
.
get
(
)
;
fBruteForceManager
.
replayDraws
(
fCurrentManager
)
;
fBruteForceManager
.
reset
(
)
;
}
}
;
}
#
endif
