#
include
"
src
/
gpu
/
graphite
/
geom
/
Transform_graphite
.
h
"
#
include
"
src
/
base
/
SkVx
.
h
"
#
include
"
src
/
core
/
SkMatrixPriv
.
h
"
#
include
"
src
/
gpu
/
graphite
/
geom
/
Rect
.
h
"
namespace
skgpu
:
:
graphite
{
namespace
{
Rect
map_rect
(
const
SkM44
&
m
const
Rect
&
r
)
{
return
SkMatrixPriv
:
:
MapRect
(
m
r
.
asSkRect
(
)
)
;
}
void
map_points
(
const
SkM44
&
m
const
SkV4
*
in
SkV4
*
out
int
count
)
{
auto
c0
=
skvx
:
:
float4
:
:
Load
(
SkMatrixPriv
:
:
M44ColMajor
(
m
)
+
0
)
;
auto
c1
=
skvx
:
:
float4
:
:
Load
(
SkMatrixPriv
:
:
M44ColMajor
(
m
)
+
4
)
;
auto
c2
=
skvx
:
:
float4
:
:
Load
(
SkMatrixPriv
:
:
M44ColMajor
(
m
)
+
8
)
;
auto
c3
=
skvx
:
:
float4
:
:
Load
(
SkMatrixPriv
:
:
M44ColMajor
(
m
)
+
12
)
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
auto
p
=
(
c0
*
in
[
i
]
.
x
)
+
(
c1
*
in
[
i
]
.
y
)
+
(
c2
*
in
[
i
]
.
z
)
+
(
c3
*
in
[
i
]
.
w
)
;
p
.
store
(
out
+
i
)
;
}
}
Transform
:
:
Type
get_matrix_info
(
const
SkM44
&
m
SkM44
*
inverse
SkV2
*
scale
)
{
if
(
!
m
.
invert
(
inverse
)
)
{
*
scale
=
{
1
.
f
1
.
f
}
;
return
Transform
:
:
Type
:
:
kInvalid
;
}
static
constexpr
SkV4
kNoPerspective
=
{
0
.
f
0
.
f
0
.
f
1
.
f
}
;
static
constexpr
SkV4
kNoZ
=
{
0
.
f
0
.
f
1
.
f
0
.
f
}
;
if
(
m
.
row
(
3
)
!
=
kNoPerspective
|
|
m
.
col
(
2
)
!
=
kNoZ
|
|
m
.
row
(
2
)
!
=
kNoZ
)
{
*
scale
=
{
1
.
f
1
.
f
}
;
return
Transform
:
:
Type
:
:
kProjection
;
}
float
sx
=
m
.
rc
(
0
0
)
;
float
sy
=
m
.
rc
(
1
1
)
;
float
kx
=
m
.
rc
(
0
1
)
;
float
ky
=
m
.
rc
(
1
0
)
;
if
(
kx
=
=
0
.
f
&
&
ky
=
=
0
.
f
)
{
*
scale
=
{
std
:
:
abs
(
sx
)
std
:
:
abs
(
sy
)
}
;
if
(
sx
=
=
1
.
f
&
&
sy
=
=
1
.
f
&
&
m
.
rc
(
0
3
)
=
=
0
.
f
&
&
m
.
rc
(
1
3
)
=
=
0
.
f
)
{
return
Transform
:
:
Type
:
:
kIdentity
;
}
else
if
(
sx
>
0
.
f
&
&
sy
>
0
.
f
)
{
return
Transform
:
:
Type
:
:
kSimpleRectStaysRect
;
}
else
{
SkASSERT
(
sx
!
=
0
.
f
&
&
sy
!
=
0
.
f
)
;
return
Transform
:
:
Type
:
:
kRectStaysRect
;
}
}
else
if
(
sx
=
=
0
.
f
&
&
sy
=
=
0
.
f
)
{
SkASSERT
(
kx
!
=
0
.
f
&
&
ky
!
=
0
.
f
)
;
*
scale
=
{
std
:
:
abs
(
ky
)
std
:
:
abs
(
kx
)
}
;
return
Transform
:
:
Type
:
:
kRectStaysRect
;
}
else
{
*
scale
=
{
SkV2
{
sx
ky
}
.
length
(
)
SkV2
{
kx
sy
}
.
length
(
)
}
;
return
Transform
:
:
Type
:
:
kAffine
;
}
}
}
Transform
:
:
Transform
(
const
SkM44
&
m
)
:
fM
(
m
)
{
fType
=
get_matrix_info
(
m
&
fInvM
&
fScale
)
;
}
const
Transform
&
Transform
:
:
Identity
(
)
{
static
const
Transform
kIdentity
{
SkM44
(
)
}
;
return
kIdentity
;
}
const
Transform
&
Transform
:
:
Invalid
(
)
{
static
const
Transform
kInvalid
{
SkM44
(
SkM44
:
:
kNaN_Constructor
)
}
;
return
kInvalid
;
}
bool
Transform
:
:
operator
=
=
(
const
Transform
&
t
)
const
{
SkASSERT
(
fM
!
=
t
.
fM
|
|
(
fInvM
=
=
t
.
fInvM
&
&
fType
=
=
t
.
fType
&
&
fScale
=
=
t
.
fScale
)
)
;
return
fM
=
=
t
.
fM
;
}
Rect
Transform
:
:
mapRect
(
const
Rect
&
rect
)
const
{
return
map_rect
(
fM
rect
)
;
}
Rect
Transform
:
:
inverseMapRect
(
const
Rect
&
rect
)
const
{
return
map_rect
(
fInvM
rect
)
;
}
void
Transform
:
:
mapPoints
(
const
Rect
&
localRect
SkV4
deviceOut
[
4
]
)
const
{
SkV2
localCorners
[
4
]
=
{
{
localRect
.
left
(
)
localRect
.
top
(
)
}
{
localRect
.
right
(
)
localRect
.
top
(
)
}
{
localRect
.
right
(
)
localRect
.
bot
(
)
}
{
localRect
.
left
(
)
localRect
.
bot
(
)
}
}
;
this
-
>
mapPoints
(
localCorners
deviceOut
4
)
;
}
void
Transform
:
:
mapPoints
(
const
SkV2
*
localIn
SkV4
*
deviceOut
int
count
)
const
{
auto
c0
=
skvx
:
:
float4
:
:
Load
(
SkMatrixPriv
:
:
M44ColMajor
(
fM
)
+
0
)
;
auto
c1
=
skvx
:
:
float4
:
:
Load
(
SkMatrixPriv
:
:
M44ColMajor
(
fM
)
+
4
)
;
auto
c3
=
skvx
:
:
float4
:
:
Load
(
SkMatrixPriv
:
:
M44ColMajor
(
fM
)
+
12
)
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
auto
p
=
c0
*
localIn
[
i
]
.
x
+
c1
*
localIn
[
i
]
.
y
+
c3
;
p
.
store
(
deviceOut
+
i
)
;
}
}
void
Transform
:
:
mapPoints
(
const
SkV4
*
localIn
SkV4
*
deviceOut
int
count
)
const
{
return
map_points
(
fM
localIn
deviceOut
count
)
;
}
void
Transform
:
:
inverseMapPoints
(
const
SkV4
*
deviceIn
SkV4
*
localOut
int
count
)
const
{
return
map_points
(
fInvM
deviceIn
localOut
count
)
;
}
Transform
Transform
:
:
preTranslate
(
float
x
float
y
)
const
{
Transform
t
=
*
this
;
t
.
fM
.
preTranslate
(
x
y
)
;
t
.
fInvM
.
postTranslate
(
-
x
-
y
)
;
if
(
!
t
.
fM
.
isFinite
(
)
|
|
!
t
.
fInvM
.
isFinite
(
)
)
{
t
.
fType
=
Type
:
:
kInvalid
;
}
return
t
;
}
Transform
Transform
:
:
postTranslate
(
float
x
float
y
)
const
{
Transform
t
=
*
this
;
t
.
fM
.
postTranslate
(
x
y
)
;
t
.
fInvM
.
preTranslate
(
-
x
-
y
)
;
if
(
!
t
.
fM
.
isFinite
(
)
|
|
!
t
.
fInvM
.
isFinite
(
)
)
{
t
.
fType
=
Type
:
:
kInvalid
;
}
return
t
;
}
Transform
Transform
:
:
concat
(
const
Transform
&
t
)
const
{
Transform
c
=
{
fM
*
t
.
fM
t
.
fInvM
*
fInvM
std
:
:
max
(
fType
t
.
fType
)
{
fScale
*
t
.
fScale
}
}
;
if
(
!
c
.
fM
.
isFinite
(
)
|
|
!
c
.
fInvM
.
isFinite
(
)
)
{
c
.
fType
=
Type
:
:
kInvalid
;
}
return
c
;
}
Transform
Transform
:
:
concatInverse
(
const
Transform
&
t
)
const
{
Transform
c
=
{
fM
*
t
.
fInvM
t
.
fM
*
fInvM
std
:
:
max
(
fType
t
.
fType
)
{
fScale
*
(
1
.
f
/
t
.
fScale
)
}
}
;
if
(
!
c
.
fM
.
isFinite
(
)
|
|
!
c
.
fInvM
.
isFinite
(
)
)
{
c
.
fType
=
Type
:
:
kInvalid
;
}
return
c
;
}
Transform
Transform
:
:
concatInverse
(
const
SkM44
&
t
)
const
{
Transform
inverse
{
t
*
fInvM
}
;
return
{
inverse
.
fInvM
inverse
.
fM
inverse
.
fType
1
.
f
/
inverse
.
fScale
}
;
}
}
