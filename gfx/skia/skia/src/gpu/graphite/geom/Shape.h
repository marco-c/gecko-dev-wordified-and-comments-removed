#
ifndef
skgpu_graphite_geom_Shape_DEFINED
#
define
skgpu_graphite_geom_Shape_DEFINED
#
include
"
include
/
core
/
SkM44
.
h
"
#
include
"
include
/
core
/
SkPath
.
h
"
#
include
"
include
/
core
/
SkRRect
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
src
/
base
/
SkVx
.
h
"
#
include
"
src
/
gpu
/
graphite
/
geom
/
Rect
.
h
"
#
include
<
array
>
namespace
skgpu
:
:
graphite
{
class
Shape
{
public
:
enum
class
Type
:
uint8_t
{
kEmpty
kLine
kRect
kRRect
kPath
}
;
inline
static
constexpr
int
kTypeCount
=
static_cast
<
int
>
(
Type
:
:
kPath
)
+
1
;
Shape
(
)
{
}
Shape
(
const
Shape
&
shape
)
{
*
this
=
shape
;
}
Shape
(
Shape
&
&
)
=
delete
;
Shape
(
SkPoint
p0
SkPoint
p1
)
{
this
-
>
setLine
(
p0
p1
)
;
}
Shape
(
SkV2
p0
SkV2
p1
)
{
this
-
>
setLine
(
p0
p1
)
;
}
Shape
(
skvx
:
:
float2
p0
skvx
:
:
float2
p1
)
{
this
-
>
setLine
(
p0
p1
)
;
}
explicit
Shape
(
const
Rect
&
rect
)
{
this
-
>
setRect
(
rect
)
;
}
explicit
Shape
(
const
SkRect
&
rect
)
{
this
-
>
setRect
(
rect
)
;
}
explicit
Shape
(
const
SkRRect
&
rrect
)
{
this
-
>
setRRect
(
rrect
)
;
}
explicit
Shape
(
const
SkPath
&
path
)
{
this
-
>
setPath
(
path
)
;
}
~
Shape
(
)
{
this
-
>
reset
(
)
;
}
Shape
&
operator
=
(
Shape
&
&
)
=
delete
;
Shape
&
operator
=
(
const
Shape
&
)
;
Type
type
(
)
const
{
return
fType
;
}
bool
isEmpty
(
)
const
{
return
fType
=
=
Type
:
:
kEmpty
;
}
bool
isLine
(
)
const
{
return
fType
=
=
Type
:
:
kLine
;
}
bool
isRect
(
)
const
{
return
fType
=
=
Type
:
:
kRect
;
}
bool
isRRect
(
)
const
{
return
fType
=
=
Type
:
:
kRRect
;
}
bool
isPath
(
)
const
{
return
fType
=
=
Type
:
:
kPath
;
}
bool
inverted
(
)
const
{
SkASSERT
(
fType
!
=
Type
:
:
kPath
|
|
fInverted
=
=
fPath
.
isInverseFillType
(
)
)
;
return
fInverted
;
}
void
setInverted
(
bool
inverted
)
{
if
(
fType
=
=
Type
:
:
kPath
&
&
inverted
!
=
fPath
.
isInverseFillType
(
)
)
{
fPath
.
toggleInverseFillType
(
)
;
}
fInverted
=
inverted
;
}
SkPathFillType
fillType
(
)
const
{
if
(
fType
=
=
Type
:
:
kPath
)
{
return
fPath
.
getFillType
(
)
;
}
else
{
return
fInverted
?
SkPathFillType
:
:
kInverseEvenOdd
:
SkPathFillType
:
:
kEvenOdd
;
}
}
bool
conservativeContains
(
const
Rect
&
rect
)
const
;
bool
conservativeContains
(
skvx
:
:
float2
point
)
const
;
bool
convex
(
bool
simpleFill
=
true
)
const
;
Rect
bounds
(
)
const
;
SkPath
asPath
(
)
const
;
skvx
:
:
float2
p0
(
)
const
{
SkASSERT
(
this
-
>
isLine
(
)
)
;
return
fRect
.
topLeft
(
)
;
}
skvx
:
:
float2
p1
(
)
const
{
SkASSERT
(
this
-
>
isLine
(
)
)
;
return
fRect
.
botRight
(
)
;
}
const
Rect
&
rect
(
)
const
{
SkASSERT
(
this
-
>
isRect
(
)
)
;
return
fRect
;
}
const
SkRRect
&
rrect
(
)
const
{
SkASSERT
(
this
-
>
isRRect
(
)
)
;
return
fRRect
;
}
const
SkPath
&
path
(
)
const
{
SkASSERT
(
this
-
>
isPath
(
)
)
;
return
fPath
;
}
void
setLine
(
SkPoint
p0
SkPoint
p1
)
{
this
-
>
setLine
(
skvx
:
:
float2
{
p0
.
fX
p0
.
fY
}
skvx
:
:
float2
{
p1
.
fX
p1
.
fY
}
)
;
}
void
setLine
(
SkV2
p0
SkV2
p1
)
{
this
-
>
setLine
(
skvx
:
:
float2
{
p0
.
x
p0
.
y
}
skvx
:
:
float2
{
p1
.
x
p1
.
y
}
)
;
}
void
setLine
(
skvx
:
:
float2
p0
skvx
:
:
float2
p1
)
{
this
-
>
setType
(
Type
:
:
kLine
)
;
fRect
=
Rect
(
p0
p1
)
;
fInverted
=
false
;
}
void
setRect
(
const
SkRect
&
rect
)
{
this
-
>
setRect
(
Rect
(
rect
)
)
;
}
void
setRect
(
const
Rect
&
rect
)
{
this
-
>
setType
(
Type
:
:
kRect
)
;
fRect
=
rect
;
fInverted
=
false
;
}
void
setRRect
(
const
SkRRect
&
rrect
)
{
this
-
>
setType
(
Type
:
:
kRRect
)
;
fRRect
=
rrect
;
fInverted
=
false
;
}
void
setPath
(
const
SkPath
&
path
)
{
if
(
fType
=
=
Type
:
:
kPath
)
{
fPath
=
path
;
}
else
{
this
-
>
setType
(
Type
:
:
kPath
)
;
new
(
&
fPath
)
SkPath
(
path
)
;
}
fInverted
=
path
.
isInverseFillType
(
)
;
}
void
reset
(
)
{
this
-
>
setType
(
Type
:
:
kEmpty
)
;
fInverted
=
false
;
}
private
:
void
setType
(
Type
type
)
{
if
(
this
-
>
isPath
(
)
&
&
type
!
=
Type
:
:
kPath
)
{
fPath
.
~
SkPath
(
)
;
}
fType
=
type
;
}
union
{
Rect
fRect
;
SkRRect
fRRect
;
SkPath
fPath
;
}
;
Type
fType
=
Type
:
:
kEmpty
;
bool
fInverted
=
false
;
}
;
}
#
endif
