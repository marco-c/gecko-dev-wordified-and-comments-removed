#
ifndef
skgpu_graphite_DrawContext_DEFINED
#
define
skgpu_graphite_DrawContext_DEFINED
#
include
"
include
/
core
/
SkImageInfo
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSurfaceProps
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
src
/
gpu
/
graphite
/
AttachmentTypes
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawList
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawOrder
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawTypes
.
h
"
#
include
"
src
/
gpu
/
graphite
/
UploadTask
.
h
"
#
include
<
vector
>
#
ifdef
SK_ENABLE_PIET_GPU
#
include
"
src
/
gpu
/
graphite
/
PietRenderTask
.
h
"
namespace
skgpu
:
:
piet
{
class
Scene
;
}
#
endif
class
SkPixmap
;
namespace
skgpu
:
:
graphite
{
class
Geometry
;
class
Recorder
;
class
Transform
;
class
AtlasManager
;
class
Caps
;
class
DrawPass
;
class
Task
;
class
TextureProxy
;
class
TextureProxyView
;
class
DrawContext
final
:
public
SkRefCnt
{
public
:
static
sk_sp
<
DrawContext
>
Make
(
sk_sp
<
TextureProxy
>
target
SkISize
deviceSize
const
SkColorInfo
&
const
SkSurfaceProps
&
)
;
~
DrawContext
(
)
override
;
const
SkImageInfo
&
imageInfo
(
)
const
{
return
fImageInfo
;
}
const
SkColorInfo
&
colorInfo
(
)
const
{
return
fImageInfo
.
colorInfo
(
)
;
}
TextureProxy
*
target
(
)
{
return
fTarget
.
get
(
)
;
}
const
TextureProxy
*
target
(
)
const
{
return
fTarget
.
get
(
)
;
}
TextureProxyView
readSurfaceView
(
const
Caps
*
)
;
const
SkSurfaceProps
&
surfaceProps
(
)
const
{
return
fSurfaceProps
;
}
int
pendingDrawCount
(
)
const
{
return
fPendingDraws
-
>
drawCount
(
)
;
}
void
clear
(
const
SkColor4f
&
clearColor
)
;
void
recordDraw
(
const
Renderer
*
renderer
const
Transform
&
localToDevice
const
Geometry
&
geometry
const
Clip
&
clip
DrawOrder
ordering
const
PaintParams
*
paint
const
StrokeStyle
*
stroke
)
;
bool
recordTextUploads
(
AtlasManager
*
)
;
bool
recordUpload
(
Recorder
*
recorder
sk_sp
<
TextureProxy
>
targetProxy
const
SkColorInfo
&
srcColorInfo
const
SkColorInfo
&
dstColorInfo
const
std
:
:
vector
<
MipLevel
>
&
levels
const
SkIRect
&
dstRect
std
:
:
unique_ptr
<
ConditionalUploadContext
>
)
;
#
ifdef
SK_ENABLE_PIET_GPU
bool
recordPietSceneRender
(
Recorder
*
recorder
sk_sp
<
TextureProxy
>
targetProxy
sk_sp
<
const
skgpu
:
:
piet
:
:
Scene
>
pietScene
)
;
#
endif
void
snapDrawPass
(
Recorder
*
)
;
sk_sp
<
Task
>
snapRenderPassTask
(
Recorder
*
)
;
sk_sp
<
Task
>
snapUploadTask
(
Recorder
*
)
;
#
ifdef
SK_ENABLE_PIET_GPU
sk_sp
<
Task
>
snapPietRenderTask
(
Recorder
*
)
;
#
endif
private
:
DrawContext
(
sk_sp
<
TextureProxy
>
const
SkImageInfo
&
const
SkSurfaceProps
&
)
;
sk_sp
<
TextureProxy
>
fTarget
;
SkImageInfo
fImageInfo
;
const
SkSurfaceProps
fSurfaceProps
;
std
:
:
unique_ptr
<
DrawList
>
fPendingDraws
;
LoadOp
fPendingLoadOp
=
LoadOp
:
:
kLoad
;
StoreOp
fPendingStoreOp
=
StoreOp
:
:
kStore
;
std
:
:
array
<
float
4
>
fPendingClearColor
=
{
0
0
0
0
}
;
SkTArray
<
std
:
:
unique_ptr
<
DrawPass
>
>
fDrawPasses
;
std
:
:
unique_ptr
<
UploadList
>
fPendingUploads
;
#
ifdef
SK_ENABLE_PIET_GPU
std
:
:
vector
<
PietRenderInstance
>
fPendingPietRenders
;
#
endif
}
;
}
#
endif
