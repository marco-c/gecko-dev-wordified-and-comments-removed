#
include
"
src
/
gpu
/
graphite
/
ClipStack_graphite
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkShader
.
h
"
#
include
"
include
/
core
/
SkStrokeRec
.
h
"
#
include
"
src
/
base
/
SkTLazy
.
h
"
#
include
"
src
/
core
/
SkMatrixProvider
.
h
"
#
include
"
src
/
core
/
SkPathPriv
.
h
"
#
include
"
src
/
core
/
SkRRectPriv
.
h
"
#
include
"
src
/
core
/
SkRectPriv
.
h
"
#
include
"
src
/
gpu
/
graphite
/
Device
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawParams
.
h
"
#
include
"
src
/
gpu
/
graphite
/
geom
/
BoundsManager
.
h
"
#
include
"
src
/
gpu
/
graphite
/
geom
/
Geometry
.
h
"
namespace
skgpu
:
:
graphite
{
namespace
{
Rect
subtract
(
const
Rect
&
a
const
Rect
&
b
bool
exact
)
{
SkRect
diff
;
if
(
SkRectPriv
:
:
Subtract
(
a
.
asSkRect
(
)
b
.
asSkRect
(
)
&
diff
)
|
|
!
exact
)
{
return
Rect
{
diff
}
;
}
else
{
return
a
;
}
}
bool
oriented_bbox_intersection
(
const
Rect
&
a
const
Transform
&
aXform
const
Rect
&
b
const
Transform
&
bXform
)
{
SkASSERT
(
aXform
.
type
(
)
!
=
Transform
:
:
Type
:
:
kProjection
&
&
bXform
.
type
(
)
!
=
Transform
:
:
Type
:
:
kProjection
)
;
SkV4
quadA
[
4
]
quadB
[
4
]
;
aXform
.
mapPoints
(
a
quadA
)
;
bXform
.
mapPoints
(
b
quadB
)
;
auto
axesX
=
skvx
:
:
float4
(
-
aXform
.
matrix
(
)
.
rc
(
1
0
)
-
aXform
.
matrix
(
)
.
rc
(
1
1
)
-
bXform
.
matrix
(
)
.
rc
(
1
0
)
-
bXform
.
matrix
(
)
.
rc
(
1
1
)
)
;
auto
axesY
=
skvx
:
:
float4
(
aXform
.
matrix
(
)
.
rc
(
0
0
)
aXform
.
matrix
(
)
.
rc
(
0
1
)
bXform
.
matrix
(
)
.
rc
(
0
0
)
bXform
.
matrix
(
)
.
rc
(
0
1
)
)
;
auto
aProj0
=
quadA
[
0
]
.
x
*
axesX
+
quadA
[
0
]
.
y
*
axesY
;
auto
aProj1
=
quadA
[
1
]
.
x
*
axesX
+
quadA
[
1
]
.
y
*
axesY
;
auto
aProj2
=
quadA
[
2
]
.
x
*
axesX
+
quadA
[
2
]
.
y
*
axesY
;
auto
aProj3
=
quadA
[
3
]
.
x
*
axesX
+
quadA
[
3
]
.
y
*
axesY
;
auto
bProj0
=
quadB
[
0
]
.
x
*
axesX
+
quadB
[
0
]
.
y
*
axesY
;
auto
bProj1
=
quadB
[
1
]
.
x
*
axesX
+
quadB
[
1
]
.
y
*
axesY
;
auto
bProj2
=
quadB
[
2
]
.
x
*
axesX
+
quadB
[
2
]
.
y
*
axesY
;
auto
bProj3
=
quadB
[
3
]
.
x
*
axesX
+
quadB
[
3
]
.
y
*
axesY
;
auto
minA
=
min
(
min
(
aProj0
aProj1
)
min
(
aProj2
aProj3
)
)
;
auto
maxA
=
max
(
max
(
aProj0
aProj1
)
max
(
aProj2
aProj3
)
)
;
auto
minB
=
min
(
min
(
bProj0
bProj1
)
min
(
bProj2
bProj3
)
)
;
auto
maxB
=
max
(
max
(
bProj0
bProj1
)
max
(
bProj2
bProj3
)
)
;
auto
overlaps
=
(
minB
<
=
maxA
)
&
(
minA
<
=
maxB
)
;
return
all
(
overlaps
)
;
}
static
const
Transform
kIdentity
{
SkM44
(
)
}
;
}
struct
ClipStack
:
:
TransformedShape
{
const
Transform
&
fLocalToDevice
;
const
Shape
&
fShape
;
const
Rect
&
fOuterBounds
;
const
Rect
&
fInnerBounds
;
SkClipOp
fOp
;
bool
fContainsChecksOnlyBounds
=
false
;
bool
intersects
(
const
TransformedShape
&
)
const
;
bool
contains
(
const
TransformedShape
&
)
const
;
}
;
bool
ClipStack
:
:
TransformedShape
:
:
intersects
(
const
TransformedShape
&
o
)
const
{
if
(
!
fOuterBounds
.
intersects
(
o
.
fOuterBounds
)
)
{
return
false
;
}
if
(
fLocalToDevice
.
type
(
)
<
=
Transform
:
:
Type
:
:
kRectStaysRect
&
&
o
.
fLocalToDevice
.
type
(
)
<
=
Transform
:
:
Type
:
:
kRectStaysRect
)
{
return
true
;
}
else
if
(
fLocalToDevice
=
=
o
.
fLocalToDevice
)
{
return
fShape
.
bounds
(
)
.
intersects
(
o
.
fShape
.
bounds
(
)
)
;
}
else
if
(
fLocalToDevice
.
type
(
)
!
=
Transform
:
:
Type
:
:
kProjection
&
&
o
.
fLocalToDevice
.
type
(
)
!
=
Transform
:
:
Type
:
:
kProjection
)
{
return
oriented_bbox_intersection
(
fShape
.
bounds
(
)
fLocalToDevice
o
.
fShape
.
bounds
(
)
o
.
fLocalToDevice
)
;
}
return
true
;
}
bool
ClipStack
:
:
TransformedShape
:
:
contains
(
const
TransformedShape
&
o
)
const
{
if
(
fInnerBounds
.
contains
(
o
.
fOuterBounds
)
)
{
return
true
;
}
if
(
fContainsChecksOnlyBounds
|
|
!
fOuterBounds
.
contains
(
o
.
fOuterBounds
)
)
{
return
false
;
}
if
(
fContainsChecksOnlyBounds
)
{
return
false
;
}
if
(
fLocalToDevice
=
=
o
.
fLocalToDevice
)
{
static
constexpr
int
kMaxPathComparePoints
=
16
;
if
(
fShape
.
isRRect
(
)
&
&
o
.
fShape
.
isRRect
(
)
)
{
return
SkRRectPriv
:
:
ConservativeIntersect
(
fShape
.
rrect
(
)
o
.
fShape
.
rrect
(
)
)
=
=
o
.
fShape
.
rrect
(
)
;
}
else
if
(
fShape
.
isPath
(
)
&
&
o
.
fShape
.
isPath
(
)
)
{
return
(
fShape
.
path
(
)
.
getGenerationID
(
)
=
=
o
.
fShape
.
path
(
)
.
getGenerationID
(
)
)
|
|
(
fShape
.
path
(
)
.
countPoints
(
)
<
=
kMaxPathComparePoints
&
&
fShape
.
path
(
)
=
=
o
.
fShape
.
path
(
)
)
;
}
else
{
return
fShape
.
conservativeContains
(
o
.
fShape
.
bounds
(
)
)
;
}
}
else
if
(
fLocalToDevice
.
type
(
)
<
=
Transform
:
:
Type
:
:
kRectStaysRect
&
&
o
.
fLocalToDevice
.
type
(
)
<
=
Transform
:
:
Type
:
:
kRectStaysRect
)
{
Rect
localBounds
=
fLocalToDevice
.
inverseMapRect
(
o
.
fLocalToDevice
.
mapRect
(
o
.
fShape
.
bounds
(
)
)
)
;
return
fShape
.
conservativeContains
(
localBounds
)
;
}
else
if
(
fShape
.
convex
(
)
)
{
SkV4
deviceQuad
[
4
]
;
o
.
fLocalToDevice
.
mapPoints
(
o
.
fShape
.
bounds
(
)
deviceQuad
)
;
SkV4
localQuad
[
4
]
;
fLocalToDevice
.
inverseMapPoints
(
deviceQuad
localQuad
4
)
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
if
(
deviceQuad
[
i
]
.
w
<
SkPathPriv
:
:
kW0PlaneDistance
|
|
localQuad
[
i
]
.
w
<
SkPathPriv
:
:
kW0PlaneDistance
)
{
return
false
;
}
if
(
!
fShape
.
conservativeContains
(
skvx
:
:
float2
:
:
Load
(
localQuad
+
i
)
/
localQuad
[
i
]
.
w
)
)
{
return
false
;
}
}
return
true
;
}
return
false
;
}
ClipStack
:
:
SimplifyResult
ClipStack
:
:
Simplify
(
const
TransformedShape
&
a
const
TransformedShape
&
b
)
{
enum
class
ClipCombo
{
kDD
=
0b00
kDI
=
0b01
kID
=
0b10
kII
=
0b11
}
;
switch
(
static_cast
<
ClipCombo
>
(
(
(
int
)
a
.
fOp
<
<
1
)
|
(
int
)
b
.
fOp
)
)
{
case
ClipCombo
:
:
kII
:
if
(
!
a
.
intersects
(
b
)
)
{
return
SimplifyResult
:
:
kEmpty
;
}
else
if
(
b
.
contains
(
a
)
)
{
return
SimplifyResult
:
:
kAOnly
;
}
else
if
(
a
.
contains
(
b
)
)
{
return
SimplifyResult
:
:
kBOnly
;
}
else
{
return
SimplifyResult
:
:
kBoth
;
}
case
ClipCombo
:
:
kID
:
if
(
!
a
.
intersects
(
b
)
)
{
return
SimplifyResult
:
:
kAOnly
;
}
else
if
(
b
.
contains
(
a
)
)
{
return
SimplifyResult
:
:
kEmpty
;
}
else
{
return
SimplifyResult
:
:
kBoth
;
}
case
ClipCombo
:
:
kDI
:
if
(
!
b
.
intersects
(
a
)
)
{
return
SimplifyResult
:
:
kBOnly
;
}
else
if
(
a
.
contains
(
b
)
)
{
return
SimplifyResult
:
:
kEmpty
;
}
else
{
return
SimplifyResult
:
:
kBoth
;
}
case
ClipCombo
:
:
kDD
:
if
(
a
.
contains
(
b
)
)
{
return
SimplifyResult
:
:
kAOnly
;
}
else
if
(
b
.
contains
(
a
)
)
{
return
SimplifyResult
:
:
kBOnly
;
}
else
{
return
SimplifyResult
:
:
kBoth
;
}
}
SkUNREACHABLE
;
}
ClipStack
:
:
RawElement
:
:
RawElement
(
const
Rect
&
deviceBounds
const
Transform
&
localToDevice
const
Shape
&
shape
SkClipOp
op
)
:
Element
{
shape
localToDevice
op
}
fUsageBounds
{
Rect
:
:
InfiniteInverted
(
)
}
fOrder
(
DrawOrder
:
:
kNoIntersection
)
fMaxZ
(
DrawOrder
:
:
kClearDepth
)
fInvalidatedByIndex
(
-
1
)
{
if
(
fShape
.
isLine
(
)
|
|
!
localToDevice
.
valid
(
)
)
{
fShape
.
reset
(
)
;
}
if
(
fShape
.
inverted
(
)
)
{
fOp
=
(
fOp
=
=
SkClipOp
:
:
kIntersect
)
?
SkClipOp
:
:
kDifference
:
SkClipOp
:
:
kIntersect
;
}
fOuterBounds
=
fLocalToDevice
.
mapRect
(
fShape
.
bounds
(
)
)
.
makeIntersect
(
deviceBounds
)
;
fInnerBounds
=
Rect
:
:
InfiniteInverted
(
)
;
if
(
!
fOuterBounds
.
isEmptyNegativeOrNaN
(
)
&
&
fLocalToDevice
.
type
(
)
<
=
Transform
:
:
Type
:
:
kRectStaysRect
)
{
if
(
fShape
.
isRect
(
)
)
{
fShape
.
setRect
(
fOuterBounds
)
;
fLocalToDevice
=
kIdentity
;
fInnerBounds
=
fOuterBounds
;
}
else
if
(
fShape
.
isRRect
(
)
)
{
SkRRect
xformed
;
if
(
fShape
.
rrect
(
)
.
transform
(
fLocalToDevice
&
xformed
)
)
{
fShape
.
setRRect
(
xformed
)
;
fLocalToDevice
=
kIdentity
;
fOuterBounds
=
fShape
.
bounds
(
)
.
makeIntersect
(
deviceBounds
)
;
fInnerBounds
=
Rect
{
SkRRectPriv
:
:
InnerBounds
(
xformed
)
}
.
makeIntersect
(
fOuterBounds
)
;
}
}
}
if
(
fOuterBounds
.
isEmptyNegativeOrNaN
(
)
)
{
fShape
.
reset
(
)
;
fInnerBounds
=
Rect
:
:
InfiniteInverted
(
)
;
}
fShape
.
setInverted
(
fOp
=
=
SkClipOp
:
:
kIntersect
)
;
SkASSERT
(
fShape
.
isEmpty
(
)
|
|
deviceBounds
.
contains
(
fOuterBounds
)
)
;
this
-
>
validate
(
)
;
}
ClipStack
:
:
RawElement
:
:
operator
ClipStack
:
:
TransformedShape
(
)
const
{
return
{
fLocalToDevice
fShape
fOuterBounds
fInnerBounds
fOp
}
;
}
void
ClipStack
:
:
RawElement
:
:
drawClip
(
Device
*
device
)
{
this
-
>
validate
(
)
;
if
(
!
this
-
>
hasPendingDraw
(
)
)
{
SkASSERT
(
fUsageBounds
.
isEmptyNegativeOrNaN
(
)
)
;
return
;
}
SkASSERT
(
!
fUsageBounds
.
isEmptyNegativeOrNaN
(
)
)
;
Rect
scissor
=
fUsageBounds
.
makeRoundOut
(
)
;
Rect
drawBounds
=
fOuterBounds
.
makeIntersect
(
scissor
)
;
if
(
!
drawBounds
.
isEmptyNegativeOrNaN
(
)
)
{
DrawOrder
order
{
fMaxZ
.
next
(
)
fOrder
}
;
SkASSERT
(
(
fOp
=
=
SkClipOp
:
:
kDifference
&
&
!
fShape
.
inverted
(
)
)
|
|
(
fOp
=
=
SkClipOp
:
:
kIntersect
&
&
fShape
.
inverted
(
)
)
)
;
device
-
>
drawClipShape
(
fLocalToDevice
fShape
Clip
{
drawBounds
scissor
.
asSkIRect
(
)
}
order
)
;
}
fUsageBounds
=
Rect
:
:
InfiniteInverted
(
)
;
fOrder
=
DrawOrder
:
:
kNoIntersection
;
fMaxZ
=
DrawOrder
:
:
kClearDepth
;
}
void
ClipStack
:
:
RawElement
:
:
validate
(
)
const
{
SkASSERT
(
(
fShape
.
isEmpty
(
)
|
|
!
fOuterBounds
.
isEmptyNegativeOrNaN
(
)
)
&
&
(
fInnerBounds
.
isEmptyNegativeOrNaN
(
)
|
|
fOuterBounds
.
contains
(
fInnerBounds
)
)
)
;
SkASSERT
(
(
fOp
=
=
SkClipOp
:
:
kDifference
&
&
!
fShape
.
inverted
(
)
)
|
|
(
fOp
=
=
SkClipOp
:
:
kIntersect
&
&
fShape
.
inverted
(
)
)
)
;
SkASSERT
(
!
this
-
>
hasPendingDraw
(
)
|
|
!
fUsageBounds
.
isEmptyNegativeOrNaN
(
)
)
;
}
void
ClipStack
:
:
RawElement
:
:
markInvalid
(
const
SaveRecord
&
current
)
{
SkASSERT
(
!
this
-
>
isInvalid
(
)
)
;
fInvalidatedByIndex
=
current
.
firstActiveElementIndex
(
)
;
}
void
ClipStack
:
:
RawElement
:
:
restoreValid
(
const
SaveRecord
&
current
)
{
if
(
current
.
firstActiveElementIndex
(
)
<
fInvalidatedByIndex
)
{
fInvalidatedByIndex
=
-
1
;
}
}
bool
ClipStack
:
:
RawElement
:
:
combine
(
const
RawElement
&
other
const
SaveRecord
&
current
)
{
if
(
this
-
>
hasPendingDraw
(
)
|
|
other
.
hasPendingDraw
(
)
)
{
return
false
;
}
if
(
other
.
fOp
!
=
SkClipOp
:
:
kIntersect
|
|
fOp
!
=
SkClipOp
:
:
kIntersect
)
{
return
false
;
}
bool
shapeUpdated
=
false
;
if
(
fShape
.
isRect
(
)
&
&
other
.
fShape
.
isRect
(
)
)
{
if
(
fLocalToDevice
=
=
other
.
fLocalToDevice
)
{
Rect
intersection
=
fShape
.
rect
(
)
.
makeIntersect
(
other
.
fShape
.
rect
(
)
)
;
SkASSERT
(
!
intersection
.
isEmptyNegativeOrNaN
(
)
)
;
fShape
.
setRect
(
intersection
)
;
shapeUpdated
=
true
;
}
}
else
if
(
(
fShape
.
isRect
(
)
|
|
fShape
.
isRRect
(
)
)
&
&
(
other
.
fShape
.
isRect
(
)
|
|
other
.
fShape
.
isRRect
(
)
)
)
{
if
(
fLocalToDevice
=
=
other
.
fLocalToDevice
)
{
SkRRect
a
=
fShape
.
isRect
(
)
?
SkRRect
:
:
MakeRect
(
fShape
.
rect
(
)
.
asSkRect
(
)
)
:
fShape
.
rrect
(
)
;
SkRRect
b
=
other
.
fShape
.
isRect
(
)
?
SkRRect
:
:
MakeRect
(
other
.
fShape
.
rect
(
)
.
asSkRect
(
)
)
:
other
.
fShape
.
rrect
(
)
;
SkRRect
joined
=
SkRRectPriv
:
:
ConservativeIntersect
(
a
b
)
;
if
(
!
joined
.
isEmpty
(
)
)
{
if
(
joined
.
isRect
(
)
)
{
fShape
.
setRect
(
joined
.
rect
(
)
)
;
}
else
{
fShape
.
setRRect
(
joined
)
;
}
shapeUpdated
=
true
;
}
}
}
if
(
shapeUpdated
)
{
SkASSERT
(
fOp
=
=
SkClipOp
:
:
kIntersect
&
&
other
.
fOp
=
=
SkClipOp
:
:
kIntersect
)
;
fOuterBounds
.
intersect
(
other
.
fOuterBounds
)
;
fInnerBounds
.
intersect
(
other
.
fInnerBounds
)
;
SkASSERT
(
!
fOuterBounds
.
isEmptyNegativeOrNaN
(
)
)
;
fShape
.
setInverted
(
true
)
;
this
-
>
validate
(
)
;
return
true
;
}
else
{
return
false
;
}
}
void
ClipStack
:
:
RawElement
:
:
updateForElement
(
RawElement
*
added
const
SaveRecord
&
current
)
{
if
(
this
-
>
isInvalid
(
)
)
{
return
;
}
switch
(
Simplify
(
*
this
*
added
)
)
{
case
SimplifyResult
:
:
kEmpty
:
this
-
>
markInvalid
(
current
)
;
added
-
>
markInvalid
(
current
)
;
break
;
case
SimplifyResult
:
:
kAOnly
:
added
-
>
markInvalid
(
current
)
;
break
;
case
SimplifyResult
:
:
kBOnly
:
this
-
>
markInvalid
(
current
)
;
break
;
case
SimplifyResult
:
:
kBoth
:
if
(
added
-
>
combine
(
*
this
current
)
)
{
this
-
>
markInvalid
(
current
)
;
}
break
;
}
}
std
:
:
pair
<
bool
CompressedPaintersOrder
>
ClipStack
:
:
RawElement
:
:
updateForDraw
(
const
BoundsManager
*
boundsManager
const
TransformedShape
&
draw
PaintersDepth
drawZ
)
{
if
(
this
-
>
isInvalid
(
)
)
{
return
{
false
DrawOrder
:
:
kNoIntersection
}
;
}
switch
(
Simplify
(
*
this
draw
)
)
{
case
SimplifyResult
:
:
kEmpty
:
return
{
true
DrawOrder
:
:
kNoIntersection
}
;
case
SimplifyResult
:
:
kBOnly
:
return
{
false
DrawOrder
:
:
kNoIntersection
}
;
case
SimplifyResult
:
:
kAOnly
:
[
[
fallthrough
]
]
;
case
SimplifyResult
:
:
kBoth
:
if
(
!
this
-
>
hasPendingDraw
(
)
)
{
fOrder
=
boundsManager
-
>
getMostRecentDraw
(
fOuterBounds
)
.
next
(
)
;
fUsageBounds
=
draw
.
fOuterBounds
;
fMaxZ
=
drawZ
;
}
else
{
fUsageBounds
.
join
(
draw
.
fOuterBounds
)
;
if
(
drawZ
>
fMaxZ
)
{
fMaxZ
=
drawZ
;
}
}
return
{
false
fOrder
}
;
}
SkUNREACHABLE
;
}
ClipStack
:
:
ClipState
ClipStack
:
:
RawElement
:
:
clipType
(
)
const
{
switch
(
fShape
.
type
(
)
)
{
case
Shape
:
:
Type
:
:
kEmpty
:
return
ClipState
:
:
kEmpty
;
case
Shape
:
:
Type
:
:
kRect
:
return
fOp
=
=
SkClipOp
:
:
kIntersect
&
&
fLocalToDevice
.
type
(
)
=
=
Transform
:
:
Type
:
:
kIdentity
?
ClipState
:
:
kDeviceRect
:
ClipState
:
:
kComplex
;
case
Shape
:
:
Type
:
:
kRRect
:
return
fOp
=
=
SkClipOp
:
:
kIntersect
&
&
fLocalToDevice
.
type
(
)
=
=
Transform
:
:
Type
:
:
kIdentity
?
ClipState
:
:
kDeviceRRect
:
ClipState
:
:
kComplex
;
case
Shape
:
:
Type
:
:
kLine
:
SkASSERT
(
false
)
;
[
[
fallthrough
]
]
;
case
Shape
:
:
Type
:
:
kPath
:
return
ClipState
:
:
kComplex
;
}
SkUNREACHABLE
;
}
ClipStack
:
:
SaveRecord
:
:
SaveRecord
(
const
Rect
&
deviceBounds
)
:
fInnerBounds
(
deviceBounds
)
fOuterBounds
(
deviceBounds
)
fShader
(
nullptr
)
fStartingElementIndex
(
0
)
fOldestValidIndex
(
0
)
fDeferredSaveCount
(
0
)
fStackOp
(
SkClipOp
:
:
kIntersect
)
fState
(
ClipState
:
:
kWideOpen
)
{
}
ClipStack
:
:
SaveRecord
:
:
SaveRecord
(
const
SaveRecord
&
prior
int
startingElementIndex
)
:
fInnerBounds
(
prior
.
fInnerBounds
)
fOuterBounds
(
prior
.
fOuterBounds
)
fShader
(
prior
.
fShader
)
fStartingElementIndex
(
startingElementIndex
)
fOldestValidIndex
(
prior
.
fOldestValidIndex
)
fDeferredSaveCount
(
0
)
fStackOp
(
prior
.
fStackOp
)
fState
(
prior
.
fState
)
{
SkASSERT
(
startingElementIndex
>
=
prior
.
fStartingElementIndex
)
;
}
ClipStack
:
:
ClipState
ClipStack
:
:
SaveRecord
:
:
state
(
)
const
{
if
(
fShader
&
&
fState
!
=
ClipState
:
:
kEmpty
)
{
return
ClipState
:
:
kComplex
;
}
else
{
return
fState
;
}
}
Rect
ClipStack
:
:
SaveRecord
:
:
scissor
(
const
Rect
&
deviceBounds
const
Rect
&
drawBounds
)
const
{
SkASSERT
(
this
-
>
state
(
)
!
=
ClipState
:
:
kEmpty
&
&
this
-
>
state
(
)
!
=
ClipState
:
:
kWideOpen
)
;
SkASSERT
(
deviceBounds
.
contains
(
drawBounds
)
)
;
if
(
fStackOp
=
=
SkClipOp
:
:
kDifference
)
{
if
(
!
fOuterBounds
.
intersects
(
drawBounds
)
)
{
return
deviceBounds
;
}
else
{
return
subtract
(
drawBounds
fInnerBounds
true
)
;
}
}
else
{
if
(
fOuterBounds
.
contains
(
drawBounds
)
)
{
return
deviceBounds
;
}
else
{
return
fOuterBounds
;
}
}
}
void
ClipStack
:
:
SaveRecord
:
:
removeElements
(
RawElement
:
:
Stack
*
elements
Device
*
device
)
{
while
(
elements
-
>
count
(
)
>
fStartingElementIndex
)
{
elements
-
>
back
(
)
.
drawClip
(
device
)
;
elements
-
>
pop_back
(
)
;
}
}
void
ClipStack
:
:
SaveRecord
:
:
restoreElements
(
RawElement
:
:
Stack
*
elements
)
{
int
i
=
elements
-
>
count
(
)
-
1
;
for
(
RawElement
&
e
:
elements
-
>
ritems
(
)
)
{
if
(
i
<
fOldestValidIndex
)
{
break
;
}
e
.
restoreValid
(
*
this
)
;
-
-
i
;
}
}
void
ClipStack
:
:
SaveRecord
:
:
addShader
(
sk_sp
<
SkShader
>
shader
)
{
SkASSERT
(
shader
)
;
SkASSERT
(
this
-
>
canBeUpdated
(
)
)
;
if
(
!
fShader
)
{
fShader
=
std
:
:
move
(
shader
)
;
}
else
{
fShader
=
SkShaders
:
:
Blend
(
SkBlendMode
:
:
kSrcIn
std
:
:
move
(
shader
)
fShader
)
;
}
}
bool
ClipStack
:
:
SaveRecord
:
:
addElement
(
RawElement
&
&
toAdd
RawElement
:
:
Stack
*
elements
Device
*
device
)
{
toAdd
.
validate
(
)
;
SkASSERT
(
this
-
>
canBeUpdated
(
)
)
;
if
(
fState
=
=
ClipState
:
:
kEmpty
)
{
return
false
;
}
else
if
(
toAdd
.
shape
(
)
.
isEmpty
(
)
)
{
SkASSERT
(
toAdd
.
op
(
)
=
=
SkClipOp
:
:
kIntersect
)
;
fState
=
ClipState
:
:
kEmpty
;
this
-
>
removeElements
(
elements
device
)
;
return
true
;
}
Shape
outerSaveBounds
{
fOuterBounds
}
;
TransformedShape
save
{
kIdentity
outerSaveBounds
fOuterBounds
fInnerBounds
fStackOp
true
}
;
switch
(
Simplify
(
save
toAdd
)
)
{
case
SimplifyResult
:
:
kEmpty
:
fState
=
ClipState
:
:
kEmpty
;
this
-
>
removeElements
(
elements
device
)
;
return
true
;
case
SimplifyResult
:
:
kAOnly
:
return
false
;
case
SimplifyResult
:
:
kBOnly
:
this
-
>
replaceWithElement
(
std
:
:
move
(
toAdd
)
elements
device
)
;
return
true
;
case
SimplifyResult
:
:
kBoth
:
break
;
}
if
(
fState
=
=
ClipState
:
:
kWideOpen
)
{
this
-
>
replaceWithElement
(
std
:
:
move
(
toAdd
)
elements
device
)
;
return
true
;
}
if
(
fStackOp
=
=
SkClipOp
:
:
kIntersect
)
{
if
(
toAdd
.
op
(
)
=
=
SkClipOp
:
:
kIntersect
)
{
fOuterBounds
.
intersect
(
toAdd
.
outerBounds
(
)
)
;
fInnerBounds
.
intersect
(
toAdd
.
innerBounds
(
)
)
;
SkASSERT
(
!
fOuterBounds
.
isEmptyNegativeOrNaN
(
)
)
;
}
else
{
fOuterBounds
=
subtract
(
fOuterBounds
toAdd
.
innerBounds
(
)
true
)
;
fInnerBounds
=
subtract
(
fInnerBounds
toAdd
.
outerBounds
(
)
false
)
;
}
}
else
{
if
(
toAdd
.
op
(
)
=
=
SkClipOp
:
:
kIntersect
)
{
Rect
oldOuter
=
fOuterBounds
;
fOuterBounds
=
subtract
(
toAdd
.
outerBounds
(
)
fInnerBounds
true
)
;
fInnerBounds
=
subtract
(
toAdd
.
innerBounds
(
)
oldOuter
false
)
;
}
else
{
fOuterBounds
.
join
(
toAdd
.
outerBounds
(
)
)
;
if
(
toAdd
.
innerBounds
(
)
.
area
(
)
>
fInnerBounds
.
area
(
)
)
{
fInnerBounds
=
toAdd
.
innerBounds
(
)
;
}
}
}
SkASSERT
(
!
fOuterBounds
.
isEmptyNegativeOrNaN
(
)
&
&
(
fInnerBounds
.
isEmptyNegativeOrNaN
(
)
|
|
fOuterBounds
.
contains
(
fInnerBounds
)
)
)
;
return
this
-
>
appendElement
(
std
:
:
move
(
toAdd
)
elements
device
)
;
}
bool
ClipStack
:
:
SaveRecord
:
:
appendElement
(
RawElement
&
&
toAdd
RawElement
:
:
Stack
*
elements
Device
*
device
)
{
int
i
=
elements
-
>
count
(
)
-
1
;
int
youngestValid
=
fStartingElementIndex
-
1
;
int
oldestValid
=
elements
-
>
count
(
)
;
RawElement
*
oldestActiveInvalid
=
nullptr
;
int
oldestActiveInvalidIndex
=
elements
-
>
count
(
)
;
for
(
RawElement
&
existing
:
elements
-
>
ritems
(
)
)
{
if
(
i
<
fOldestValidIndex
)
{
break
;
}
existing
.
updateForElement
(
&
toAdd
*
this
)
;
if
(
toAdd
.
isInvalid
(
)
)
{
if
(
existing
.
isInvalid
(
)
)
{
fState
=
ClipState
:
:
kEmpty
;
return
true
;
}
else
{
return
false
;
}
}
else
if
(
existing
.
isInvalid
(
)
)
{
if
(
i
>
=
fStartingElementIndex
)
{
oldestActiveInvalid
=
&
existing
;
oldestActiveInvalidIndex
=
i
;
}
}
else
{
oldestValid
=
i
;
if
(
i
>
youngestValid
)
{
youngestValid
=
i
;
}
}
-
-
i
;
}
SkASSERT
(
oldestValid
=
=
elements
-
>
count
(
)
|
|
(
oldestValid
>
=
fOldestValidIndex
&
&
oldestValid
<
elements
-
>
count
(
)
)
)
;
SkASSERT
(
youngestValid
=
=
fStartingElementIndex
-
1
|
|
(
youngestValid
>
=
fStartingElementIndex
&
&
youngestValid
<
elements
-
>
count
(
)
)
)
;
SkASSERT
(
(
oldestActiveInvalid
&
&
oldestActiveInvalidIndex
>
=
fStartingElementIndex
&
&
oldestActiveInvalidIndex
<
elements
-
>
count
(
)
)
|
|
!
oldestActiveInvalid
)
;
SkASSERT
(
oldestValid
>
=
fOldestValidIndex
)
;
fOldestValidIndex
=
std
:
:
min
(
oldestValid
oldestActiveInvalidIndex
)
;
fState
=
oldestValid
=
=
elements
-
>
count
(
)
?
toAdd
.
clipType
(
)
:
ClipState
:
:
kComplex
;
if
(
fStackOp
=
=
SkClipOp
:
:
kDifference
&
&
toAdd
.
op
(
)
=
=
SkClipOp
:
:
kIntersect
)
{
fStackOp
=
SkClipOp
:
:
kIntersect
;
}
int
targetCount
=
youngestValid
+
1
;
if
(
!
oldestActiveInvalid
|
|
oldestActiveInvalidIndex
>
=
targetCount
)
{
targetCount
+
+
;
oldestActiveInvalid
=
nullptr
;
}
while
(
elements
-
>
count
(
)
>
targetCount
)
{
SkASSERT
(
oldestActiveInvalid
!
=
&
elements
-
>
back
(
)
)
;
elements
-
>
back
(
)
.
drawClip
(
device
)
;
elements
-
>
pop_back
(
)
;
}
if
(
oldestActiveInvalid
)
{
oldestActiveInvalid
-
>
drawClip
(
device
)
;
*
oldestActiveInvalid
=
std
:
:
move
(
toAdd
)
;
}
else
if
(
elements
-
>
count
(
)
<
targetCount
)
{
elements
-
>
push_back
(
std
:
:
move
(
toAdd
)
)
;
}
else
{
elements
-
>
back
(
)
.
drawClip
(
device
)
;
elements
-
>
back
(
)
=
std
:
:
move
(
toAdd
)
;
}
return
true
;
}
void
ClipStack
:
:
SaveRecord
:
:
replaceWithElement
(
RawElement
&
&
toAdd
RawElement
:
:
Stack
*
elements
Device
*
device
)
{
fInnerBounds
=
toAdd
.
innerBounds
(
)
;
fOuterBounds
=
toAdd
.
outerBounds
(
)
;
fStackOp
=
toAdd
.
op
(
)
;
fState
=
toAdd
.
clipType
(
)
;
int
targetCount
=
fStartingElementIndex
+
1
;
while
(
elements
-
>
count
(
)
>
targetCount
)
{
elements
-
>
back
(
)
.
drawClip
(
device
)
;
elements
-
>
pop_back
(
)
;
}
if
(
elements
-
>
count
(
)
<
targetCount
)
{
elements
-
>
push_back
(
std
:
:
move
(
toAdd
)
)
;
}
else
{
elements
-
>
back
(
)
.
drawClip
(
device
)
;
elements
-
>
back
(
)
=
std
:
:
move
(
toAdd
)
;
}
SkASSERT
(
elements
-
>
count
(
)
=
=
fStartingElementIndex
+
1
)
;
fOldestValidIndex
=
fStartingElementIndex
;
}
static
constexpr
int
kElementStackIncrement
=
8
;
static
constexpr
int
kSaveStackIncrement
=
8
;
ClipStack
:
:
ClipStack
(
Device
*
owningDevice
)
:
fElements
(
kElementStackIncrement
)
fSaves
(
kSaveStackIncrement
)
fDevice
(
owningDevice
)
{
fSaves
.
emplace_back
(
this
-
>
deviceBounds
(
)
)
;
}
ClipStack
:
:
~
ClipStack
(
)
=
default
;
void
ClipStack
:
:
save
(
)
{
SkASSERT
(
!
fSaves
.
empty
(
)
)
;
fSaves
.
back
(
)
.
pushSave
(
)
;
}
void
ClipStack
:
:
restore
(
)
{
SkASSERT
(
!
fSaves
.
empty
(
)
)
;
SaveRecord
&
current
=
fSaves
.
back
(
)
;
if
(
current
.
popSave
(
)
)
{
return
;
}
current
.
removeElements
(
&
fElements
fDevice
)
;
fSaves
.
pop_back
(
)
;
fSaves
.
back
(
)
.
restoreElements
(
&
fElements
)
;
}
Rect
ClipStack
:
:
deviceBounds
(
)
const
{
return
Rect
:
:
WH
(
fDevice
-
>
width
(
)
fDevice
-
>
height
(
)
)
;
}
Rect
ClipStack
:
:
conservativeBounds
(
)
const
{
const
SaveRecord
&
current
=
this
-
>
currentSaveRecord
(
)
;
if
(
current
.
state
(
)
=
=
ClipState
:
:
kEmpty
)
{
return
Rect
:
:
InfiniteInverted
(
)
;
}
else
if
(
current
.
state
(
)
=
=
ClipState
:
:
kWideOpen
)
{
return
this
-
>
deviceBounds
(
)
;
}
else
{
if
(
current
.
op
(
)
=
=
SkClipOp
:
:
kDifference
)
{
return
subtract
(
this
-
>
deviceBounds
(
)
current
.
innerBounds
(
)
true
)
;
}
else
{
SkASSERT
(
this
-
>
deviceBounds
(
)
.
contains
(
current
.
outerBounds
(
)
)
)
;
return
current
.
outerBounds
(
)
;
}
}
}
ClipStack
:
:
SaveRecord
&
ClipStack
:
:
writableSaveRecord
(
bool
*
wasDeferred
)
{
SaveRecord
&
current
=
fSaves
.
back
(
)
;
if
(
current
.
canBeUpdated
(
)
)
{
*
wasDeferred
=
false
;
return
current
;
}
else
{
SkAssertResult
(
current
.
popSave
(
)
)
;
*
wasDeferred
=
true
;
return
fSaves
.
emplace_back
(
current
fElements
.
count
(
)
)
;
}
}
void
ClipStack
:
:
clipShader
(
sk_sp
<
SkShader
>
shader
)
{
if
(
this
-
>
currentSaveRecord
(
)
.
state
(
)
=
=
ClipState
:
:
kEmpty
)
{
return
;
}
bool
wasDeferred
;
this
-
>
writableSaveRecord
(
&
wasDeferred
)
.
addShader
(
std
:
:
move
(
shader
)
)
;
}
void
ClipStack
:
:
clipShape
(
const
Transform
&
localToDevice
const
Shape
&
shape
SkClipOp
op
)
{
if
(
this
-
>
currentSaveRecord
(
)
.
state
(
)
=
=
ClipState
:
:
kEmpty
)
{
return
;
}
RawElement
element
{
this
-
>
deviceBounds
(
)
localToDevice
shape
op
}
;
if
(
element
.
shape
(
)
.
isEmpty
(
)
)
{
if
(
element
.
op
(
)
=
=
SkClipOp
:
:
kDifference
)
{
return
;
}
}
bool
wasDeferred
;
SaveRecord
&
save
=
this
-
>
writableSaveRecord
(
&
wasDeferred
)
;
SkDEBUGCODE
(
int
elementCount
=
fElements
.
count
(
)
;
)
if
(
!
save
.
addElement
(
std
:
:
move
(
element
)
&
fElements
fDevice
)
)
{
if
(
wasDeferred
)
{
SkASSERT
(
elementCount
=
=
fElements
.
count
(
)
)
;
fSaves
.
pop_back
(
)
;
fSaves
.
back
(
)
.
pushSave
(
)
;
}
}
}
std
:
:
pair
<
Clip
CompressedPaintersOrder
>
ClipStack
:
:
applyClipToDraw
(
const
BoundsManager
*
boundsManager
const
Transform
&
localToDevice
const
Geometry
&
geometry
const
SkStrokeRec
&
style
PaintersDepth
z
)
{
static
const
std
:
:
pair
<
Clip
CompressedPaintersOrder
>
kClippedOut
=
{
{
Rect
:
:
InfiniteInverted
(
)
SkIRect
:
:
MakeEmpty
(
)
}
DrawOrder
:
:
kNoIntersection
}
;
const
SaveRecord
&
cs
=
this
-
>
currentSaveRecord
(
)
;
if
(
cs
.
state
(
)
=
=
ClipState
:
:
kEmpty
)
{
return
kClippedOut
;
}
const
Rect
deviceBounds
=
this
-
>
deviceBounds
(
)
;
SkTCopyOnFirstWrite
<
Shape
>
styledShape
;
if
(
geometry
.
isShape
(
)
)
{
styledShape
.
init
(
geometry
.
shape
(
)
)
;
}
else
{
styledShape
.
initIfNeeded
(
geometry
.
bounds
(
)
)
;
}
auto
origSize
=
geometry
.
bounds
(
)
.
size
(
)
;
if
(
!
std
:
:
isfinite
(
origSize
.
x
(
)
)
|
|
!
std
:
:
isfinite
(
origSize
.
y
(
)
)
)
{
return
kClippedOut
;
}
Rect
drawBounds
;
bool
shapeInDeviceSpace
=
false
;
if
(
styledShape
-
>
inverted
(
)
)
{
drawBounds
=
deviceBounds
;
styledShape
.
writable
(
)
-
>
setRect
(
drawBounds
)
;
shapeInDeviceSpace
=
true
;
}
else
{
if
(
any
(
origSize
=
=
0
.
f
)
)
{
if
(
style
.
isFillStyle
(
)
|
|
(
style
.
getCap
(
)
=
=
SkPaint
:
:
kButt_Cap
&
&
all
(
origSize
=
=
0
.
f
)
)
)
{
return
kClippedOut
;
}
}
drawBounds
=
styledShape
-
>
bounds
(
)
;
if
(
!
style
.
isHairlineStyle
(
)
)
{
float
localStyleOutset
=
style
.
getInflationRadius
(
)
;
drawBounds
.
outset
(
localStyleOutset
)
;
if
(
!
style
.
isFillStyle
(
)
)
{
styledShape
.
writable
(
)
-
>
setRect
(
drawBounds
)
;
}
}
drawBounds
=
localToDevice
.
mapRect
(
drawBounds
)
;
if
(
style
.
isHairlineStyle
(
)
)
{
drawBounds
.
outset
(
0
.
5f
)
;
styledShape
.
writable
(
)
-
>
setRect
(
drawBounds
)
;
shapeInDeviceSpace
=
true
;
}
drawBounds
.
intersect
(
deviceBounds
)
;
}
if
(
drawBounds
.
isEmptyNegativeOrNaN
(
)
|
|
cs
.
state
(
)
=
=
ClipState
:
:
kWideOpen
)
{
return
{
Clip
{
drawBounds
deviceBounds
.
asSkIRect
(
)
}
DrawOrder
:
:
kNoIntersection
}
;
}
Rect
scissor
=
cs
.
scissor
(
deviceBounds
drawBounds
)
.
makeRoundOut
(
)
;
drawBounds
.
intersect
(
scissor
)
;
if
(
drawBounds
.
isEmptyNegativeOrNaN
(
)
|
|
cs
.
innerBounds
(
)
.
contains
(
drawBounds
)
)
{
return
{
Clip
{
drawBounds
scissor
.
asSkIRect
(
)
}
DrawOrder
:
:
kNoIntersection
}
;
}
TransformedShape
draw
{
shapeInDeviceSpace
?
kIdentity
:
localToDevice
*
styledShape
drawBounds
Rect
:
:
InfiniteInverted
(
)
SkClipOp
:
:
kIntersect
true
}
;
CompressedPaintersOrder
maxClipOrder
=
DrawOrder
:
:
kNoIntersection
;
int
i
=
fElements
.
count
(
)
;
for
(
RawElement
&
e
:
fElements
.
ritems
(
)
)
{
-
-
i
;
if
(
i
<
cs
.
oldestElementIndex
(
)
)
{
break
;
}
auto
[
clippedOut
order
]
=
e
.
updateForDraw
(
boundsManager
draw
z
)
;
if
(
clippedOut
)
{
drawBounds
=
Rect
:
:
InfiniteInverted
(
)
;
break
;
}
else
{
maxClipOrder
=
std
:
:
max
(
order
maxClipOrder
)
;
}
}
return
{
Clip
{
drawBounds
scissor
.
asSkIRect
(
)
}
maxClipOrder
}
;
}
void
ClipStack
:
:
recordDeferredClipDraws
(
)
{
for
(
auto
&
e
:
fElements
.
items
(
)
)
{
e
.
drawClip
(
fDevice
)
;
}
}
}
