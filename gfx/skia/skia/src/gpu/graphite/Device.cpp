#
include
"
src
/
gpu
/
graphite
/
Device
.
h
"
#
include
"
include
/
gpu
/
graphite
/
Recorder
.
h
"
#
include
"
include
/
gpu
/
graphite
/
Recording
.
h
"
#
include
"
src
/
gpu
/
AtlasTypes
.
h
"
#
include
"
src
/
gpu
/
graphite
/
Buffer
.
h
"
#
include
"
src
/
gpu
/
graphite
/
Caps
.
h
"
#
include
"
src
/
gpu
/
graphite
/
CommandBuffer
.
h
"
#
include
"
src
/
gpu
/
graphite
/
ContextPriv
.
h
"
#
include
"
src
/
gpu
/
graphite
/
CopyTask
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawContext
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawList
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawParams
.
h
"
#
include
"
src
/
gpu
/
graphite
/
ImageUtils
.
h
"
#
include
"
src
/
gpu
/
graphite
/
Image_Graphite
.
h
"
#
include
"
src
/
gpu
/
graphite
/
Log
.
h
"
#
include
"
src
/
gpu
/
graphite
/
RecorderPriv
.
h
"
#
include
"
src
/
gpu
/
graphite
/
Renderer
.
h
"
#
include
"
src
/
gpu
/
graphite
/
RendererProvider
.
h
"
#
include
"
src
/
gpu
/
graphite
/
SharedContext
.
h
"
#
include
"
src
/
gpu
/
graphite
/
TextureProxy
.
h
"
#
include
"
src
/
gpu
/
graphite
/
TextureUtils
.
h
"
#
include
"
src
/
gpu
/
graphite
/
geom
/
BoundsManager
.
h
"
#
include
"
src
/
gpu
/
graphite
/
geom
/
Geometry
.
h
"
#
include
"
src
/
gpu
/
graphite
/
geom
/
IntersectionTree
.
h
"
#
include
"
src
/
gpu
/
graphite
/
geom
/
Shape
.
h
"
#
include
"
src
/
gpu
/
graphite
/
geom
/
Transform_graphite
.
h
"
#
include
"
src
/
gpu
/
graphite
/
text
/
AtlasManager
.
h
"
#
include
"
include
/
core
/
SkColorSpace
.
h
"
#
include
"
include
/
core
/
SkPath
.
h
"
#
include
"
include
/
core
/
SkPathEffect
.
h
"
#
include
"
include
/
core
/
SkStrokeRec
.
h
"
#
include
"
src
/
core
/
SkBlenderBase
.
h
"
#
include
"
src
/
core
/
SkColorSpacePriv
.
h
"
#
include
"
src
/
core
/
SkConvertPixels
.
h
"
#
include
"
src
/
core
/
SkImageInfoPriv
.
h
"
#
include
"
src
/
core
/
SkMatrixPriv
.
h
"
#
include
"
src
/
core
/
SkPaintPriv
.
h
"
#
include
"
src
/
core
/
SkRRectPriv
.
h
"
#
include
"
src
/
core
/
SkSpecialImage
.
h
"
#
include
"
src
/
core
/
SkTraceEvent
.
h
"
#
include
"
src
/
core
/
SkVerticesPriv
.
h
"
#
include
"
src
/
shaders
/
SkImageShader
.
h
"
#
include
"
src
/
text
/
gpu
/
SubRunContainer
.
h
"
#
include
"
src
/
text
/
gpu
/
TextBlobRedrawCoordinator
.
h
"
#
include
<
unordered_map
>
#
include
<
vector
>
using
RescaleGamma
=
SkImage
:
:
RescaleGamma
;
using
RescaleMode
=
SkImage
:
:
RescaleMode
;
using
ReadPixelsCallback
=
SkImage
:
:
ReadPixelsCallback
;
using
ReadPixelsContext
=
SkImage
:
:
ReadPixelsContext
;
namespace
skgpu
:
:
graphite
{
namespace
{
static
const
SkStrokeRec
kFillStyle
(
SkStrokeRec
:
:
kFill_InitStyle
)
;
bool
paint_depends_on_dst
(
SkColor4f
color
const
SkShader
*
shader
const
SkColorFilter
*
colorFilter
const
SkBlender
*
blender
)
{
std
:
:
optional
<
SkBlendMode
>
bm
=
blender
?
as_BB
(
blender
)
-
>
asBlendMode
(
)
:
SkBlendMode
:
:
kSrcOver
;
if
(
!
bm
.
has_value
(
)
)
{
return
true
;
}
if
(
bm
.
value
(
)
=
=
SkBlendMode
:
:
kSrc
|
|
bm
.
value
(
)
=
=
SkBlendMode
:
:
kClear
)
{
return
false
;
}
if
(
bm
.
value
(
)
=
=
SkBlendMode
:
:
kSrcOver
)
{
return
!
color
.
isOpaque
(
)
|
|
(
shader
&
&
!
shader
-
>
isOpaque
(
)
)
|
|
(
colorFilter
&
&
!
colorFilter
-
>
isAlphaUnchanged
(
)
)
;
}
return
true
;
}
bool
paint_depends_on_dst
(
const
PaintParams
&
paintParams
)
{
return
paint_depends_on_dst
(
paintParams
.
color
(
)
paintParams
.
shader
(
)
paintParams
.
colorFilter
(
)
paintParams
.
finalBlender
(
)
)
;
}
bool
paint_depends_on_dst
(
const
SkPaint
&
paint
)
{
SkASSERT
(
!
paint
.
getImageFilter
(
)
)
;
return
paint_depends_on_dst
(
paint
.
getColor4f
(
)
paint
.
getShader
(
)
paint
.
getColorFilter
(
)
paint
.
getBlender
(
)
)
;
}
std
:
:
optional
<
SkColor4f
>
extract_paint_color
(
const
SkPaint
&
paint
const
SkColorInfo
&
dstColorInfo
)
{
SkASSERT
(
!
paint_depends_on_dst
(
paint
)
)
;
if
(
paint
.
getShader
(
)
)
{
return
std
:
:
nullopt
;
}
SkColor4f
dstPaintColor
=
PaintParams
:
:
Color4fPrepForDst
(
paint
.
getColor4f
(
)
dstColorInfo
)
;
if
(
SkColorFilter
*
filter
=
paint
.
getColorFilter
(
)
)
{
SkColorSpace
*
dstCS
=
dstColorInfo
.
colorSpace
(
)
;
return
filter
-
>
filterColor4f
(
dstPaintColor
dstCS
dstCS
)
;
}
return
dstPaintColor
;
}
SkIRect
rect_to_pixelbounds
(
const
Rect
&
r
)
{
return
r
.
makeRoundOut
(
)
.
asSkIRect
(
)
;
}
bool
create_img_shader_paint
(
sk_sp
<
SkImage
>
image
const
SkRect
&
subset
const
SkSamplingOptions
&
sampling
const
SkMatrix
*
localMatrix
SkPaint
*
paint
)
{
bool
imageIsAlphaOnly
=
SkColorTypeIsAlphaOnly
(
image
-
>
colorType
(
)
)
;
sk_sp
<
SkShader
>
imgShader
=
SkImageShader
:
:
MakeSubset
(
std
:
:
move
(
image
)
subset
SkTileMode
:
:
kClamp
SkTileMode
:
:
kClamp
sampling
localMatrix
)
;
if
(
!
imgShader
)
{
SKGPU_LOG_W
(
"
Couldn
'
t
create
subset
image
shader
"
)
;
return
false
;
}
if
(
imageIsAlphaOnly
&
&
paint
-
>
getShader
(
)
)
{
imgShader
=
SkShaders
:
:
Blend
(
SkBlendMode
:
:
kDstIn
paint
-
>
refShader
(
)
std
:
:
move
(
imgShader
)
)
;
}
paint
-
>
setStyle
(
SkPaint
:
:
kFill_Style
)
;
paint
-
>
setShader
(
std
:
:
move
(
imgShader
)
)
;
paint
-
>
setPathEffect
(
nullptr
)
;
return
true
;
}
bool
is_simple_shape
(
const
Shape
&
shape
SkStrokeRec
:
:
Style
type
)
{
return
!
shape
.
inverted
(
)
&
&
type
!
=
SkStrokeRec
:
:
kStrokeAndFill_Style
&
&
(
shape
.
isRect
(
)
|
|
(
shape
.
isRRect
(
)
&
&
(
type
!
=
SkStrokeRec
:
:
kStroke_Style
|
|
SkRRectPriv
:
:
AllCornersCircular
(
shape
.
rrect
(
)
)
)
)
)
;
}
}
class
Device
:
:
IntersectionTreeSet
{
public
:
IntersectionTreeSet
(
)
=
default
;
DisjointStencilIndex
add
(
CompressedPaintersOrder
drawOrder
Rect
rect
)
{
auto
&
trees
=
fTrees
[
drawOrder
]
;
DisjointStencilIndex
stencil
=
DrawOrder
:
:
kUnassigned
.
next
(
)
;
for
(
auto
&
&
tree
:
trees
)
{
if
(
tree
-
>
add
(
rect
)
)
{
return
stencil
;
}
stencil
=
stencil
.
next
(
)
;
}
IntersectionTree
*
newTree
=
this
-
>
makeTree
(
)
;
SkAssertResult
(
newTree
-
>
add
(
rect
)
)
;
trees
.
push_back
(
newTree
)
;
return
stencil
;
}
void
reset
(
)
{
fTrees
.
clear
(
)
;
fTreeStore
.
reset
(
)
;
}
private
:
struct
Hash
{
size_t
operator
(
)
(
const
CompressedPaintersOrder
&
o
)
const
noexcept
{
return
o
.
bits
(
)
;
}
}
;
IntersectionTree
*
makeTree
(
)
{
return
fTreeStore
.
make
<
IntersectionTree
>
(
)
;
}
std
:
:
unordered_map
<
CompressedPaintersOrder
std
:
:
vector
<
IntersectionTree
*
>
Hash
>
fTrees
;
SkSTArenaAllocWithReset
<
4
*
sizeof
(
IntersectionTree
)
>
fTreeStore
;
}
;
sk_sp
<
Device
>
Device
:
:
Make
(
Recorder
*
recorder
const
SkImageInfo
&
ii
skgpu
:
:
Budgeted
budgeted
Mipmapped
mipmapped
const
SkSurfaceProps
&
props
bool
addInitialClear
)
{
if
(
!
recorder
)
{
return
nullptr
;
}
sk_sp
<
TextureProxy
>
target
=
TextureProxy
:
:
Make
(
recorder
-
>
priv
(
)
.
caps
(
)
ii
.
dimensions
(
)
ii
.
colorType
(
)
mipmapped
Protected
:
:
kNo
Renderable
:
:
kYes
budgeted
)
;
if
(
!
target
)
{
return
nullptr
;
}
return
Make
(
recorder
std
:
:
move
(
target
)
ii
.
colorInfo
(
)
props
addInitialClear
)
;
}
sk_sp
<
Device
>
Device
:
:
Make
(
Recorder
*
recorder
sk_sp
<
TextureProxy
>
target
const
SkColorInfo
&
colorInfo
const
SkSurfaceProps
&
props
bool
addInitialClear
)
{
return
Make
(
recorder
target
target
-
>
dimensions
(
)
colorInfo
props
addInitialClear
)
;
}
sk_sp
<
Device
>
Device
:
:
Make
(
Recorder
*
recorder
sk_sp
<
TextureProxy
>
target
SkISize
deviceSize
const
SkColorInfo
&
colorInfo
const
SkSurfaceProps
&
props
bool
addInitialClear
)
{
if
(
!
recorder
)
{
return
nullptr
;
}
if
(
colorInfo
.
alphaType
(
)
!
=
kPremul_SkAlphaType
)
{
return
nullptr
;
}
sk_sp
<
DrawContext
>
dc
=
DrawContext
:
:
Make
(
std
:
:
move
(
target
)
deviceSize
colorInfo
props
)
;
if
(
!
dc
)
{
return
nullptr
;
}
return
sk_sp
<
Device
>
(
new
Device
(
recorder
std
:
:
move
(
dc
)
addInitialClear
)
)
;
}
static
constexpr
int
kGridCellSize
=
16
;
static
constexpr
int
kMaxBruteForceN
=
64
;
Device
:
:
Device
(
Recorder
*
recorder
sk_sp
<
DrawContext
>
dc
bool
addInitialClear
)
:
SkBaseDevice
(
dc
-
>
imageInfo
(
)
dc
-
>
surfaceProps
(
)
)
fRecorder
(
recorder
)
fDC
(
std
:
:
move
(
dc
)
)
fClip
(
this
)
fColorDepthBoundsManager
(
std
:
:
make_unique
<
HybridBoundsManager
>
(
fDC
-
>
imageInfo
(
)
.
dimensions
(
)
kGridCellSize
kMaxBruteForceN
)
)
fDisjointStencilSet
(
std
:
:
make_unique
<
IntersectionTreeSet
>
(
)
)
fCachedLocalToDevice
(
SkM44
(
)
)
fCurrentDepth
(
DrawOrder
:
:
kClearDepth
)
fSDFTControl
(
recorder
-
>
priv
(
)
.
caps
(
)
-
>
getSDFTControl
(
false
)
)
fDrawsOverlap
(
false
)
{
SkASSERT
(
SkToBool
(
fDC
)
&
&
SkToBool
(
fRecorder
)
)
;
fRecorder
-
>
registerDevice
(
this
)
;
if
(
addInitialClear
)
{
fDC
-
>
clear
(
SkColors
:
:
kTransparent
)
;
}
}
Device
:
:
~
Device
(
)
{
if
(
fRecorder
)
{
this
-
>
flushPendingWorkToRecorder
(
)
;
fRecorder
-
>
deregisterDevice
(
this
)
;
}
}
void
Device
:
:
abandonRecorder
(
)
{
fRecorder
=
nullptr
;
}
const
Transform
&
Device
:
:
localToDeviceTransform
(
)
{
if
(
this
-
>
checkLocalToDeviceDirty
(
)
)
{
fCachedLocalToDevice
=
Transform
{
this
-
>
localToDevice44
(
)
}
;
}
return
fCachedLocalToDevice
;
}
SkStrikeDeviceInfo
Device
:
:
strikeDeviceInfo
(
)
const
{
return
{
this
-
>
surfaceProps
(
)
this
-
>
scalerContextFlags
(
)
&
fSDFTControl
}
;
}
SkBaseDevice
*
Device
:
:
onCreateDevice
(
const
CreateInfo
&
info
const
SkPaint
*
)
{
SkSurfaceProps
props
(
this
-
>
surfaceProps
(
)
.
flags
(
)
info
.
fPixelGeometry
)
;
bool
addInitialClear
=
!
info
.
fInfo
.
isOpaque
(
)
;
return
Make
(
fRecorder
info
.
fInfo
skgpu
:
:
Budgeted
:
:
kYes
Mipmapped
:
:
kNo
props
addInitialClear
)
.
release
(
)
;
}
sk_sp
<
SkSurface
>
Device
:
:
makeSurface
(
const
SkImageInfo
&
ii
const
SkSurfaceProps
&
props
)
{
return
SkSurface
:
:
MakeGraphite
(
fRecorder
ii
Mipmapped
:
:
kNo
&
props
)
;
}
TextureProxyView
Device
:
:
createCopy
(
const
SkIRect
*
subset
Mipmapped
mipmapped
)
{
this
-
>
flushPendingWorkToRecorder
(
)
;
TextureProxyView
srcView
=
this
-
>
readSurfaceView
(
)
;
if
(
!
srcView
)
{
return
{
}
;
}
SkIRect
srcRect
=
subset
?
*
subset
:
SkIRect
:
:
MakeSize
(
this
-
>
imageInfo
(
)
.
dimensions
(
)
)
;
return
TextureProxyView
:
:
Copy
(
this
-
>
recorder
(
)
this
-
>
imageInfo
(
)
.
colorInfo
(
)
srcView
srcRect
mipmapped
)
;
}
TextureProxyView
TextureProxyView
:
:
Copy
(
Recorder
*
recorder
const
SkColorInfo
&
srcColorInfo
const
TextureProxyView
&
srcView
SkIRect
srcRect
Mipmapped
mipmapped
)
{
SkASSERT
(
srcView
.
proxy
(
)
-
>
isFullyLazy
(
)
|
|
SkIRect
:
:
MakeSize
(
srcView
.
proxy
(
)
-
>
dimensions
(
)
)
.
contains
(
srcRect
)
)
;
sk_sp
<
TextureProxy
>
dest
=
TextureProxy
:
:
Make
(
recorder
-
>
priv
(
)
.
caps
(
)
srcRect
.
size
(
)
srcColorInfo
.
colorType
(
)
mipmapped
srcView
.
proxy
(
)
-
>
textureInfo
(
)
.
isProtected
(
)
Renderable
:
:
kNo
skgpu
:
:
Budgeted
:
:
kNo
)
;
if
(
!
dest
)
{
return
{
}
;
}
sk_sp
<
CopyTextureToTextureTask
>
copyTask
=
CopyTextureToTextureTask
:
:
Make
(
srcView
.
refProxy
(
)
srcRect
dest
{
0
0
}
)
;
if
(
!
copyTask
)
{
return
{
}
;
}
recorder
-
>
priv
(
)
.
add
(
std
:
:
move
(
copyTask
)
)
;
return
{
std
:
:
move
(
dest
)
srcView
.
swizzle
(
)
}
;
}
bool
Device
:
:
onReadPixels
(
const
SkPixmap
&
pm
int
srcX
int
srcY
)
{
#
if
GRAPHITE_TEST_UTILS
if
(
Context
*
context
=
fRecorder
-
>
priv
(
)
.
context
(
)
)
{
this
-
>
flushPendingWorkToRecorder
(
)
;
std
:
:
unique_ptr
<
Recording
>
recording
=
fRecorder
-
>
snap
(
)
;
if
(
!
recording
)
{
return
false
;
}
InsertRecordingInfo
info
;
info
.
fRecording
=
recording
.
get
(
)
;
if
(
!
context
-
>
insertRecording
(
info
)
)
{
return
false
;
}
return
context
-
>
priv
(
)
.
readPixels
(
pm
fDC
-
>
target
(
)
this
-
>
imageInfo
(
)
srcX
srcY
)
;
}
#
endif
return
false
;
}
void
Device
:
:
asyncRescaleAndReadPixels
(
const
SkImageInfo
&
info
SkIRect
srcRect
RescaleGamma
rescaleGamma
RescaleMode
rescaleMode
ReadPixelsCallback
callback
ReadPixelsContext
context
)
{
callback
(
context
nullptr
)
;
}
void
Device
:
:
asyncRescaleAndReadPixelsYUV420
(
SkYUVColorSpace
yuvColorSpace
sk_sp
<
SkColorSpace
>
dstColorSpace
SkIRect
srcRect
SkISize
dstSize
RescaleGamma
rescaleGamma
RescaleMode
rescaleMode
ReadPixelsCallback
callback
ReadPixelsContext
context
)
{
callback
(
context
nullptr
)
;
}
bool
Device
:
:
onWritePixels
(
const
SkPixmap
&
src
int
x
int
y
)
{
const
TextureProxy
*
target
=
fDC
-
>
target
(
)
;
if
(
src
.
colorType
(
)
=
=
kUnknown_SkColorType
)
{
return
false
;
}
if
(
(
src
.
alphaType
(
)
=
=
kUnknown_SkAlphaType
)
!
=
(
this
-
>
imageInfo
(
)
.
alphaType
(
)
=
=
kUnknown_SkAlphaType
)
)
{
return
false
;
}
SkIRect
dstRect
=
SkIRect
:
:
MakePtSize
(
{
x
y
}
src
.
dimensions
(
)
)
;
if
(
!
target
-
>
isFullyLazy
(
)
&
&
!
dstRect
.
intersect
(
SkIRect
:
:
MakeSize
(
target
-
>
dimensions
(
)
)
)
)
{
return
false
;
}
const
void
*
addr
=
src
.
addr
(
dstRect
.
fLeft
-
x
dstRect
.
fTop
-
y
)
;
std
:
:
vector
<
MipLevel
>
levels
;
levels
.
push_back
(
{
addr
src
.
rowBytes
(
)
}
)
;
this
-
>
flushPendingWorkToRecorder
(
)
;
return
fDC
-
>
recordUpload
(
fRecorder
sk_ref_sp
(
target
)
src
.
info
(
)
.
colorInfo
(
)
this
-
>
imageInfo
(
)
.
colorInfo
(
)
levels
dstRect
nullptr
)
;
}
bool
Device
:
:
onClipIsAA
(
)
const
{
ClipStack
:
:
ClipState
type
=
fClip
.
clipState
(
)
;
if
(
type
=
=
ClipStack
:
:
ClipState
:
:
kWideOpen
|
|
type
=
=
ClipStack
:
:
ClipState
:
:
kEmpty
)
{
return
false
;
}
else
if
(
type
=
=
ClipStack
:
:
ClipState
:
:
kDeviceRect
)
{
const
ClipStack
:
:
Element
rect
=
*
fClip
.
begin
(
)
;
SkASSERT
(
rect
.
fShape
.
isRect
(
)
&
&
rect
.
fLocalToDevice
.
type
(
)
=
=
Transform
:
:
Type
:
:
kIdentity
)
;
return
rect
.
fShape
.
rect
(
)
!
=
rect
.
fShape
.
rect
(
)
.
makeRoundOut
(
)
;
}
else
{
return
true
;
}
}
SkBaseDevice
:
:
ClipType
Device
:
:
onGetClipType
(
)
const
{
ClipStack
:
:
ClipState
state
=
fClip
.
clipState
(
)
;
if
(
state
=
=
ClipStack
:
:
ClipState
:
:
kEmpty
)
{
return
ClipType
:
:
kEmpty
;
}
else
if
(
state
=
=
ClipStack
:
:
ClipState
:
:
kDeviceRect
|
|
state
=
=
ClipStack
:
:
ClipState
:
:
kWideOpen
)
{
return
ClipType
:
:
kRect
;
}
else
{
return
ClipType
:
:
kComplex
;
}
}
SkIRect
Device
:
:
onDevClipBounds
(
)
const
{
return
rect_to_pixelbounds
(
fClip
.
conservativeBounds
(
)
)
;
}
void
Device
:
:
onAsRgnClip
(
SkRegion
*
region
)
const
{
SkIRect
bounds
=
this
-
>
devClipBounds
(
)
;
region
-
>
setRect
(
bounds
)
;
const
SkRegion
deviceBounds
(
bounds
)
;
for
(
const
ClipStack
:
:
Element
&
e
:
fClip
)
{
SkRegion
tmp
;
if
(
e
.
fShape
.
isRect
(
)
&
&
e
.
fLocalToDevice
.
type
(
)
=
=
Transform
:
:
Type
:
:
kIdentity
)
{
tmp
.
setRect
(
rect_to_pixelbounds
(
e
.
fShape
.
rect
(
)
)
)
;
}
else
{
SkPath
tmpPath
=
e
.
fShape
.
asPath
(
)
;
tmpPath
.
transform
(
e
.
fLocalToDevice
)
;
tmp
.
setPath
(
tmpPath
deviceBounds
)
;
}
region
-
>
op
(
tmp
(
SkRegion
:
:
Op
)
e
.
fOp
)
;
}
}
void
Device
:
:
onClipRect
(
const
SkRect
&
rect
SkClipOp
op
bool
aa
)
{
SkASSERT
(
op
=
=
SkClipOp
:
:
kIntersect
|
|
op
=
=
SkClipOp
:
:
kDifference
)
;
fClip
.
clipShape
(
this
-
>
localToDeviceTransform
(
)
Shape
{
rect
}
op
)
;
}
void
Device
:
:
onClipRRect
(
const
SkRRect
&
rrect
SkClipOp
op
bool
aa
)
{
SkASSERT
(
op
=
=
SkClipOp
:
:
kIntersect
|
|
op
=
=
SkClipOp
:
:
kDifference
)
;
fClip
.
clipShape
(
this
-
>
localToDeviceTransform
(
)
Shape
{
rrect
}
op
)
;
}
void
Device
:
:
onClipPath
(
const
SkPath
&
path
SkClipOp
op
bool
aa
)
{
SkASSERT
(
op
=
=
SkClipOp
:
:
kIntersect
|
|
op
=
=
SkClipOp
:
:
kDifference
)
;
fClip
.
clipShape
(
this
-
>
localToDeviceTransform
(
)
Shape
{
path
}
op
)
;
}
void
Device
:
:
onClipShader
(
sk_sp
<
SkShader
>
shader
)
{
fClip
.
clipShader
(
std
:
:
move
(
shader
)
)
;
}
void
Device
:
:
onClipRegion
(
const
SkRegion
&
globalRgn
SkClipOp
op
)
{
SkASSERT
(
op
=
=
SkClipOp
:
:
kIntersect
|
|
op
=
=
SkClipOp
:
:
kDifference
)
;
Transform
globalToDevice
{
this
-
>
globalToDevice
(
)
}
;
if
(
globalRgn
.
isEmpty
(
)
)
{
fClip
.
clipShape
(
globalToDevice
Shape
{
}
op
)
;
}
else
if
(
globalRgn
.
isRect
(
)
)
{
fClip
.
clipShape
(
globalToDevice
Shape
{
SkRect
:
:
Make
(
globalRgn
.
getBounds
(
)
)
}
op
)
;
}
else
{
SkPath
path
;
globalRgn
.
getBoundaryPath
(
&
path
)
;
fClip
.
clipShape
(
globalToDevice
Shape
{
path
}
op
)
;
}
}
void
Device
:
:
onReplaceClip
(
const
SkIRect
&
rect
)
{
}
void
Device
:
:
drawPaint
(
const
SkPaint
&
paint
)
{
if
(
this
-
>
clipIsWideOpen
(
)
&
&
!
fDC
-
>
target
(
)
-
>
isFullyLazy
(
)
)
{
if
(
!
paint_depends_on_dst
(
paint
)
)
{
if
(
std
:
:
optional
<
SkColor4f
>
color
=
extract_paint_color
(
paint
fDC
-
>
colorInfo
(
)
)
)
{
fDC
-
>
clear
(
*
color
)
;
return
;
}
}
}
const
Transform
&
localToDevice
=
this
-
>
localToDeviceTransform
(
)
;
if
(
!
localToDevice
.
valid
(
)
)
{
return
;
}
Rect
localCoveringBounds
=
localToDevice
.
inverseMapRect
(
fClip
.
conservativeBounds
(
)
)
;
this
-
>
drawGeometry
(
localToDevice
Geometry
(
Shape
(
localCoveringBounds
)
)
paint
kFillStyle
DrawFlags
:
:
kIgnorePathEffect
|
DrawFlags
:
:
kIgnoreMaskFilter
)
;
}
void
Device
:
:
drawRect
(
const
SkRect
&
r
const
SkPaint
&
paint
)
{
this
-
>
drawGeometry
(
this
-
>
localToDeviceTransform
(
)
Geometry
(
Shape
(
r
)
)
paint
SkStrokeRec
(
paint
)
)
;
}
void
Device
:
:
drawVertices
(
const
SkVertices
*
vertices
sk_sp
<
SkBlender
>
blender
const
SkPaint
&
paint
bool
skipColorXform
)
{
this
-
>
drawGeometry
(
this
-
>
localToDeviceTransform
(
)
Geometry
(
sk_ref_sp
(
vertices
)
)
paint
kFillStyle
DrawFlags
:
:
kIgnorePathEffect
|
DrawFlags
:
:
kIgnoreMaskFilter
std
:
:
move
(
blender
)
skipColorXform
)
;
}
void
Device
:
:
drawOval
(
const
SkRect
&
oval
const
SkPaint
&
paint
)
{
this
-
>
drawGeometry
(
this
-
>
localToDeviceTransform
(
)
Geometry
(
Shape
(
SkRRect
:
:
MakeOval
(
oval
)
)
)
paint
SkStrokeRec
(
paint
)
)
;
}
void
Device
:
:
drawRRect
(
const
SkRRect
&
rr
const
SkPaint
&
paint
)
{
this
-
>
drawGeometry
(
this
-
>
localToDeviceTransform
(
)
Geometry
(
Shape
(
rr
)
)
paint
SkStrokeRec
(
paint
)
)
;
}
void
Device
:
:
drawPath
(
const
SkPath
&
path
const
SkPaint
&
paint
bool
pathIsMutable
)
{
this
-
>
drawGeometry
(
this
-
>
localToDeviceTransform
(
)
Geometry
(
Shape
(
path
)
)
paint
SkStrokeRec
(
paint
)
)
;
}
void
Device
:
:
drawPoints
(
SkCanvas
:
:
PointMode
mode
size_t
count
const
SkPoint
*
points
const
SkPaint
&
paint
)
{
if
(
mode
=
=
SkCanvas
:
:
kPoints_PointMode
)
{
float
radius
=
0
.
5f
*
paint
.
getStrokeWidth
(
)
;
for
(
size_t
i
=
0
;
i
<
count
;
+
+
i
)
{
SkRect
pointRect
=
SkRect
:
:
MakeLTRB
(
points
[
i
]
.
fX
-
radius
points
[
i
]
.
fY
-
radius
points
[
i
]
.
fX
+
radius
points
[
i
]
.
fY
+
radius
)
;
if
(
paint
.
getStrokeCap
(
)
=
=
SkPaint
:
:
kRound_Cap
)
{
this
-
>
drawGeometry
(
this
-
>
localToDeviceTransform
(
)
Geometry
(
Shape
(
SkRRect
:
:
MakeOval
(
pointRect
)
)
)
paint
kFillStyle
)
;
}
else
{
this
-
>
drawGeometry
(
this
-
>
localToDeviceTransform
(
)
Geometry
(
Shape
(
pointRect
)
)
paint
kFillStyle
)
;
}
}
}
else
{
SkStrokeRec
stroke
(
paint
SkPaint
:
:
kStroke_Style
)
;
size_t
inc
=
(
mode
=
=
SkCanvas
:
:
kLines_PointMode
)
?
2
:
1
;
for
(
size_t
i
=
0
;
i
<
count
-
1
;
i
+
=
inc
)
{
this
-
>
drawGeometry
(
this
-
>
localToDeviceTransform
(
)
Geometry
(
Shape
(
points
[
i
]
points
[
i
+
1
]
)
)
paint
stroke
)
;
}
}
}
void
Device
:
:
drawEdgeAAQuad
(
const
SkRect
&
rect
const
SkPoint
clip
[
4
]
SkCanvas
:
:
QuadAAFlags
aaFlags
const
SkColor4f
&
color
SkBlendMode
mode
)
{
SkPaint
solidColorPaint
;
solidColorPaint
.
setColor4f
(
color
nullptr
)
;
solidColorPaint
.
setBlendMode
(
mode
)
;
auto
flags
=
SkEnumBitMask
<
EdgeAAQuad
:
:
Flags
>
(
static_cast
<
EdgeAAQuad
:
:
Flags
>
(
aaFlags
)
)
;
EdgeAAQuad
quad
=
clip
?
EdgeAAQuad
(
clip
flags
)
:
EdgeAAQuad
(
rect
flags
)
;
this
-
>
drawGeometry
(
this
-
>
localToDeviceTransform
(
)
Geometry
(
quad
)
solidColorPaint
kFillStyle
DrawFlags
:
:
kIgnoreMaskFilter
|
DrawFlags
:
:
kIgnorePathEffect
)
;
}
void
Device
:
:
drawEdgeAAImageSet
(
const
SkCanvas
:
:
ImageSetEntry
set
[
]
int
count
const
SkPoint
dstClips
[
]
const
SkMatrix
preViewMatrices
[
]
const
SkSamplingOptions
&
sampling
const
SkPaint
&
paint
SkCanvas
:
:
SrcRectConstraint
constraint
)
{
SkASSERT
(
count
>
0
)
;
SkPaint
paintWithShader
(
paint
)
;
int
dstClipIndex
=
0
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
SkASSERT
(
!
set
[
i
]
.
fHasClip
|
|
dstClips
)
;
SkASSERT
(
set
[
i
]
.
fMatrixIndex
<
0
|
|
preViewMatrices
)
;
SkRect
imgBounds
=
SkRect
:
:
Make
(
set
[
i
]
.
fImage
-
>
bounds
(
)
)
;
SkRect
src
=
set
[
i
]
.
fSrcRect
;
SkRect
dst
=
set
[
i
]
.
fDstRect
;
SkASSERT
(
src
.
isFinite
(
)
&
&
dst
.
isFinite
(
)
&
&
dst
.
isSorted
(
)
)
;
SkMatrix
localMatrix
=
SkMatrix
:
:
RectToRect
(
src
dst
)
;
if
(
!
imgBounds
.
contains
(
src
)
)
{
if
(
!
src
.
intersect
(
imgBounds
)
)
{
continue
;
}
dst
=
localMatrix
.
mapRect
(
src
)
;
}
auto
[
imageToDraw
newSampling
]
=
skgpu
:
:
graphite
:
:
GetGraphiteBacked
(
this
-
>
recorder
(
)
set
[
i
]
.
fImage
.
get
(
)
sampling
)
;
if
(
!
imageToDraw
)
{
SKGPU_LOG_W
(
"
Device
:
:
drawImageRect
:
Creation
of
Graphite
-
backed
image
failed
"
)
;
return
;
}
paintWithShader
.
setShader
(
paint
.
refShader
(
)
)
;
if
(
!
create_img_shader_paint
(
std
:
:
move
(
imageToDraw
)
src
newSampling
&
localMatrix
&
paintWithShader
)
)
{
return
;
}
paintWithShader
.
setAlphaf
(
paint
.
getAlphaf
(
)
*
set
[
i
]
.
fAlpha
)
;
auto
flags
=
SkEnumBitMask
<
EdgeAAQuad
:
:
Flags
>
(
static_cast
<
EdgeAAQuad
:
:
Flags
>
(
set
[
i
]
.
fAAFlags
)
)
;
EdgeAAQuad
quad
=
set
[
i
]
.
fHasClip
?
EdgeAAQuad
(
dstClips
+
dstClipIndex
flags
)
:
EdgeAAQuad
(
dst
flags
)
;
if
(
set
[
i
]
.
fMatrixIndex
<
0
)
{
this
-
>
drawGeometry
(
this
-
>
localToDeviceTransform
(
)
Geometry
(
quad
)
paintWithShader
kFillStyle
DrawFlags
:
:
kIgnorePathEffect
)
;
}
else
{
SkM44
xtraTransform
(
preViewMatrices
[
set
[
i
]
.
fMatrixIndex
]
)
;
this
-
>
drawGeometry
(
this
-
>
localToDeviceTransform
(
)
.
concat
(
xtraTransform
)
Geometry
(
quad
)
paintWithShader
kFillStyle
DrawFlags
:
:
kIgnorePathEffect
)
;
}
dstClipIndex
+
=
4
*
set
[
i
]
.
fHasClip
;
}
}
void
Device
:
:
drawImageRect
(
const
SkImage
*
image
const
SkRect
*
src
const
SkRect
&
dst
const
SkSamplingOptions
&
sampling
const
SkPaint
&
paint
SkCanvas
:
:
SrcRectConstraint
constraint
)
{
SkCanvas
:
:
ImageSetEntry
single
{
sk_ref_sp
(
image
)
src
?
*
src
:
SkRect
:
:
Make
(
image
-
>
bounds
(
)
)
dst
1
.
f
SkCanvas
:
:
kAll_QuadAAFlags
}
;
this
-
>
drawEdgeAAImageSet
(
&
single
1
nullptr
nullptr
sampling
paint
constraint
)
;
}
void
Device
:
:
onDrawGlyphRunList
(
SkCanvas
*
canvas
const
sktext
:
:
GlyphRunList
&
glyphRunList
const
SkPaint
&
initialPaint
const
SkPaint
&
drawingPaint
)
{
fRecorder
-
>
priv
(
)
.
textBlobCache
(
)
-
>
drawGlyphRunList
(
canvas
this
-
>
localToDevice
(
)
glyphRunList
drawingPaint
this
-
>
strikeDeviceInfo
(
)
this
)
;
}
void
Device
:
:
drawAtlasSubRun
(
const
sktext
:
:
gpu
:
:
AtlasSubRun
*
subRun
SkPoint
drawOrigin
const
SkPaint
&
paint
sk_sp
<
SkRefCnt
>
subRunStorage
)
{
const
int
subRunEnd
=
subRun
-
>
glyphCount
(
)
;
for
(
int
subRunCursor
=
0
;
subRunCursor
<
subRunEnd
;
)
{
auto
[
ok
glyphsRegenerated
]
=
subRun
-
>
regenerateAtlas
(
subRunCursor
subRunEnd
fRecorder
)
;
if
(
!
ok
)
{
return
;
}
if
(
glyphsRegenerated
)
{
auto
[
bounds
localToDevice
]
=
subRun
-
>
boundsAndDeviceMatrix
(
this
-
>
localToDeviceTransform
(
)
drawOrigin
)
;
SkPaint
subRunPaint
=
paint
;
if
(
subRun
-
>
maskFormat
(
)
=
=
skgpu
:
:
MaskFormat
:
:
kARGB
)
{
subRunPaint
.
setColor
(
SK_ColorWHITE
)
;
subRunPaint
.
setAlphaf
(
paint
.
getAlphaf
(
)
)
;
}
this
-
>
drawGeometry
(
localToDevice
Geometry
(
SubRunData
(
subRun
subRunStorage
bounds
subRunCursor
glyphsRegenerated
fRecorder
)
)
subRunPaint
kFillStyle
DrawFlags
:
:
kIgnorePathEffect
|
DrawFlags
:
:
kIgnoreMaskFilter
)
;
}
subRunCursor
+
=
glyphsRegenerated
;
if
(
subRunCursor
<
subRunEnd
)
{
ATRACE_ANDROID_FRAMEWORK_ALWAYS
(
"
Atlas
full
"
)
;
fRecorder
-
>
priv
(
)
.
flushTrackedDevices
(
)
;
}
}
}
void
Device
:
:
drawGeometry
(
const
Transform
&
localToDevice
const
Geometry
&
geometry
const
SkPaint
&
paint
const
SkStrokeRec
&
style
SkEnumBitMask
<
DrawFlags
>
flags
sk_sp
<
SkBlender
>
primitiveBlender
bool
skipColorXform
)
{
if
(
!
localToDevice
.
valid
(
)
)
{
SKGPU_LOG_W
(
"
Skipping
draw
with
non
-
invertible
/
non
-
finite
transform
.
"
)
;
return
;
}
if
(
!
(
flags
&
DrawFlags
:
:
kIgnorePathEffect
)
&
&
paint
.
getPathEffect
(
)
)
{
SkASSERT
(
geometry
.
isShape
(
)
)
;
SkStrokeRec
newStyle
=
style
;
newStyle
.
setResScale
(
localToDevice
.
maxScaleFactor
(
)
)
;
SkPath
dst
;
if
(
paint
.
getPathEffect
(
)
-
>
filterPath
(
&
dst
geometry
.
shape
(
)
.
asPath
(
)
&
newStyle
nullptr
localToDevice
)
)
{
this
-
>
drawGeometry
(
localToDevice
Geometry
(
Shape
(
dst
)
)
paint
newStyle
flags
|
DrawFlags
:
:
kIgnorePathEffect
std
:
:
move
(
primitiveBlender
)
skipColorXform
)
;
return
;
}
else
{
SKGPU_LOG_W
(
"
Path
effect
failed
to
apply
drawing
original
path
.
"
)
;
this
-
>
drawGeometry
(
localToDevice
geometry
paint
style
flags
|
DrawFlags
:
:
kIgnorePathEffect
std
:
:
move
(
primitiveBlender
)
skipColorXform
)
;
return
;
}
}
if
(
!
(
flags
&
DrawFlags
:
:
kIgnoreMaskFilter
)
&
&
paint
.
getMaskFilter
(
)
)
{
this
-
>
drawGeometry
(
localToDevice
geometry
paint
style
flags
|
DrawFlags
:
:
kIgnoreMaskFilter
std
:
:
move
(
primitiveBlender
)
skipColorXform
)
;
return
;
}
if
(
geometry
.
isShape
(
)
&
&
localToDevice
.
type
(
)
=
=
Transform
:
:
Type
:
:
kProjection
&
&
!
is_simple_shape
(
geometry
.
shape
(
)
style
.
getStyle
(
)
)
)
{
SkPath
devicePath
=
geometry
.
shape
(
)
.
asPath
(
)
;
devicePath
.
transform
(
localToDevice
.
matrix
(
)
.
asM33
(
)
)
;
this
-
>
drawGeometry
(
Transform
:
:
Identity
(
)
Geometry
(
Shape
(
devicePath
)
)
paint
style
flags
std
:
:
move
(
primitiveBlender
)
skipColorXform
)
;
return
;
}
SkASSERT
(
!
SkToBool
(
paint
.
getPathEffect
(
)
)
|
|
(
flags
&
DrawFlags
:
:
kIgnorePathEffect
)
)
;
SkASSERT
(
!
SkToBool
(
paint
.
getMaskFilter
(
)
)
|
|
(
flags
&
DrawFlags
:
:
kIgnoreMaskFilter
)
)
;
SkStrokeRec
:
:
Style
styleType
=
style
.
getStyle
(
)
;
if
(
this
-
>
needsFlushBeforeDraw
(
styleType
=
=
SkStrokeRec
:
:
kStrokeAndFill_Style
?
2
:
1
)
)
{
this
-
>
flushPendingWorkToRecorder
(
)
;
}
DrawOrder
order
(
fCurrentDepth
.
next
(
)
)
;
auto
[
clip
clipOrder
]
=
fClip
.
applyClipToDraw
(
fColorDepthBoundsManager
.
get
(
)
localToDevice
geometry
style
order
.
depth
(
)
)
;
if
(
clip
.
drawBounds
(
)
.
isEmptyNegativeOrNaN
(
)
)
{
return
;
}
const
Renderer
*
renderer
=
this
-
>
chooseRenderer
(
geometry
clip
style
false
)
;
if
(
!
renderer
)
{
SKGPU_LOG_W
(
"
Skipping
draw
with
no
supported
renderer
.
"
)
;
return
;
}
#
if
defined
(
SK_DEBUG
)
for
(
const
RenderStep
*
step
:
renderer
-
>
steps
(
)
)
{
auto
dss
=
step
-
>
depthStencilSettings
(
)
;
SkASSERT
(
(
!
step
-
>
performsShading
(
)
|
|
dss
.
fDepthTestEnabled
)
&
&
(
!
dss
.
fDepthTestEnabled
|
|
dss
.
fDepthCompareOp
=
=
CompareOp
:
:
kGreater
|
|
dss
.
fDepthCompareOp
=
=
CompareOp
:
:
kGEqual
)
)
;
}
#
endif
order
.
dependsOnPaintersOrder
(
clipOrder
)
;
if
(
!
renderer
-
>
emitsPrimitiveColor
(
)
)
{
primitiveBlender
=
nullptr
;
}
else
if
(
!
SkToBool
(
primitiveBlender
)
)
{
primitiveBlender
=
SkBlender
:
:
Mode
(
SkBlendMode
:
:
kSrcOver
)
;
}
PaintParams
shading
{
paint
std
:
:
move
(
primitiveBlender
)
skipColorXform
}
;
const
bool
dependsOnDst
=
renderer
-
>
emitsCoverage
(
)
|
|
paint_depends_on_dst
(
shading
)
;
CompressedPaintersOrder
prevDraw
=
fColorDepthBoundsManager
-
>
getMostRecentDraw
(
clip
.
drawBounds
(
)
)
;
if
(
dependsOnDst
)
{
order
.
dependsOnPaintersOrder
(
prevDraw
)
;
}
if
(
renderer
-
>
depthStencilFlags
(
)
&
DepthStencilFlags
:
:
kStencil
)
{
DisjointStencilIndex
setIndex
=
fDisjointStencilSet
-
>
add
(
order
.
paintOrder
(
)
clip
.
drawBounds
(
)
)
;
order
.
dependsOnStencil
(
setIndex
)
;
}
if
(
styleType
=
=
SkStrokeRec
:
:
kStroke_Style
|
|
styleType
=
=
SkStrokeRec
:
:
kHairline_Style
|
|
styleType
=
=
SkStrokeRec
:
:
kStrokeAndFill_Style
)
{
StrokeStyle
stroke
(
style
.
getWidth
(
)
style
.
getMiter
(
)
style
.
getJoin
(
)
style
.
getCap
(
)
)
;
fDC
-
>
recordDraw
(
styleType
=
=
SkStrokeRec
:
:
kStrokeAndFill_Style
?
fRecorder
-
>
priv
(
)
.
rendererProvider
(
)
-
>
tessellatedStrokes
(
)
:
renderer
localToDevice
geometry
clip
order
&
shading
&
stroke
)
;
}
if
(
styleType
=
=
SkStrokeRec
:
:
kFill_Style
|
|
styleType
=
=
SkStrokeRec
:
:
kStrokeAndFill_Style
)
{
fDC
-
>
recordDraw
(
renderer
localToDevice
geometry
clip
order
&
shading
nullptr
)
;
}
fColorDepthBoundsManager
-
>
recordDraw
(
clip
.
drawBounds
(
)
order
.
paintOrder
(
)
)
;
fCurrentDepth
=
order
.
depth
(
)
;
fDrawsOverlap
|
=
(
prevDraw
!
=
DrawOrder
:
:
kNoIntersection
)
;
}
void
Device
:
:
drawClipShape
(
const
Transform
&
localToDevice
const
Shape
&
shape
const
Clip
&
clip
DrawOrder
order
)
{
SkASSERT
(
fDC
-
>
pendingDrawCount
(
)
+
1
<
DrawList
:
:
kMaxDraws
)
;
Geometry
geometry
{
shape
}
;
const
Renderer
*
renderer
=
this
-
>
chooseRenderer
(
geometry
clip
kFillStyle
true
)
;
if
(
!
renderer
)
{
SKGPU_LOG_W
(
"
Skipping
clip
with
no
supported
path
renderer
.
"
)
;
return
;
}
else
if
(
renderer
-
>
depthStencilFlags
(
)
&
DepthStencilFlags
:
:
kStencil
)
{
DisjointStencilIndex
setIndex
=
fDisjointStencilSet
-
>
add
(
order
.
paintOrder
(
)
clip
.
drawBounds
(
)
)
;
order
.
dependsOnStencil
(
setIndex
)
;
}
SkASSERT
(
!
renderer
-
>
emitsCoverage
(
)
&
&
renderer
-
>
requiresMSAA
(
)
)
;
if
(
localToDevice
.
type
(
)
=
=
Transform
:
:
Type
:
:
kProjection
)
{
SkPath
devicePath
=
geometry
.
shape
(
)
.
asPath
(
)
;
devicePath
.
transform
(
localToDevice
.
matrix
(
)
.
asM33
(
)
)
;
fDC
-
>
recordDraw
(
renderer
Transform
:
:
Identity
(
)
Geometry
(
Shape
(
devicePath
)
)
clip
order
nullptr
nullptr
)
;
}
else
{
fDC
-
>
recordDraw
(
renderer
localToDevice
geometry
clip
order
nullptr
nullptr
)
;
}
if
(
order
.
depth
(
)
>
fCurrentDepth
)
{
fCurrentDepth
=
order
.
depth
(
)
;
}
}
const
Renderer
*
Device
:
:
chooseRenderer
(
const
Geometry
&
geometry
const
Clip
&
clip
const
SkStrokeRec
&
style
bool
requireMSAA
)
const
{
const
RendererProvider
*
renderers
=
fRecorder
-
>
priv
(
)
.
rendererProvider
(
)
;
SkStrokeRec
:
:
Style
type
=
style
.
getStyle
(
)
;
if
(
geometry
.
isSubRun
(
)
)
{
SkASSERT
(
!
requireMSAA
)
;
return
geometry
.
subRunData
(
)
.
subRun
(
)
-
>
renderer
(
renderers
)
;
}
else
if
(
geometry
.
isVertices
(
)
)
{
SkVerticesPriv
info
(
geometry
.
vertices
(
)
-
>
priv
(
)
)
;
return
renderers
-
>
vertices
(
info
.
mode
(
)
info
.
hasColors
(
)
info
.
hasTexCoords
(
)
)
;
}
else
if
(
geometry
.
isEdgeAAQuad
(
)
)
{
SkASSERT
(
!
requireMSAA
&
&
style
.
isFillStyle
(
)
)
;
return
renderers
-
>
analyticRRect
(
)
;
}
else
if
(
!
geometry
.
isShape
(
)
)
{
return
nullptr
;
}
const
Shape
&
shape
=
geometry
.
shape
(
)
;
if
(
!
requireMSAA
&
&
is_simple_shape
(
shape
type
)
)
{
return
renderers
-
>
analyticRRect
(
)
;
}
if
(
type
=
=
SkStrokeRec
:
:
kStroke_Style
|
|
type
=
=
SkStrokeRec
:
:
kHairline_Style
)
{
return
renderers
-
>
tessellatedStrokes
(
)
;
}
if
(
shape
.
convex
(
)
&
&
!
shape
.
inverted
(
)
)
{
return
renderers
-
>
convexTessellatedWedges
(
)
;
}
else
{
const
bool
preferWedges
=
(
shape
.
isPath
(
)
&
&
shape
.
path
(
)
.
countVerbs
(
)
<
50
)
|
|
clip
.
drawBounds
(
)
.
area
(
)
<
=
(
256
*
256
)
;
if
(
preferWedges
)
{
return
renderers
-
>
stencilTessellatedWedges
(
shape
.
fillType
(
)
)
;
}
else
{
return
renderers
-
>
stencilTessellatedCurvesAndTris
(
shape
.
fillType
(
)
)
;
}
}
}
void
Device
:
:
flushPendingWorkToRecorder
(
)
{
SkASSERT
(
fRecorder
)
;
auto
atlasManager
=
fRecorder
-
>
priv
(
)
.
atlasManager
(
)
;
if
(
!
fDC
-
>
recordTextUploads
(
atlasManager
)
)
{
SKGPU_LOG_E
(
"
AtlasManager
uploads
have
failed
-
-
may
see
invalid
results
.
"
)
;
}
auto
uploadTask
=
fDC
-
>
snapUploadTask
(
fRecorder
)
;
if
(
uploadTask
)
{
fRecorder
-
>
priv
(
)
.
add
(
std
:
:
move
(
uploadTask
)
)
;
}
#
ifdef
SK_ENABLE_PIET_GPU
auto
pietTask
=
fDC
-
>
snapPietRenderTask
(
fRecorder
)
;
if
(
pietTask
)
{
fRecorder
-
>
priv
(
)
.
add
(
std
:
:
move
(
pietTask
)
)
;
}
#
endif
fClip
.
recordDeferredClipDraws
(
)
;
auto
drawTask
=
fDC
-
>
snapRenderPassTask
(
fRecorder
)
;
if
(
drawTask
)
{
fRecorder
-
>
priv
(
)
.
add
(
std
:
:
move
(
drawTask
)
)
;
}
fColorDepthBoundsManager
-
>
reset
(
)
;
fDisjointStencilSet
-
>
reset
(
)
;
fCurrentDepth
=
DrawOrder
:
:
kClearDepth
;
}
bool
Device
:
:
needsFlushBeforeDraw
(
int
numNewDraws
)
const
{
numNewDraws
+
=
fClip
.
maxDeferredClipDraws
(
)
;
return
(
DrawList
:
:
kMaxDraws
-
fDC
-
>
pendingDrawCount
(
)
)
<
numNewDraws
;
}
void
Device
:
:
drawDevice
(
SkBaseDevice
*
device
const
SkSamplingOptions
&
sampling
const
SkPaint
&
paint
)
{
this
-
>
SkBaseDevice
:
:
drawDevice
(
device
sampling
paint
)
;
}
void
Device
:
:
drawSpecial
(
SkSpecialImage
*
special
const
SkMatrix
&
localToDevice
const
SkSamplingOptions
&
sampling
const
SkPaint
&
paint
)
{
SkASSERT
(
!
paint
.
getMaskFilter
(
)
&
&
!
paint
.
getImageFilter
(
)
)
;
sk_sp
<
SkImage
>
img
=
special
-
>
asImage
(
)
;
if
(
!
img
)
{
SKGPU_LOG_W
(
"
Couldn
'
t
get
Graphite
-
backed
special
image
as
image
"
)
;
return
;
}
if
(
!
img
-
>
isTextureBacked
(
)
)
{
return
;
}
SkRect
src
=
SkRect
:
:
Make
(
special
-
>
subset
(
)
)
;
SkRect
dst
=
SkRect
:
:
MakeWH
(
special
-
>
width
(
)
special
-
>
height
(
)
)
;
SkMatrix
srcToDst
=
SkMatrix
:
:
RectToRect
(
src
dst
)
;
SkASSERT
(
srcToDst
.
isTranslate
(
)
)
;
SkPaint
paintWithShader
(
paint
)
;
if
(
!
create_img_shader_paint
(
std
:
:
move
(
img
)
src
sampling
&
srcToDst
&
paintWithShader
)
)
{
return
;
}
this
-
>
drawGeometry
(
Transform
(
SkM44
(
localToDevice
)
)
Geometry
(
Shape
(
dst
)
)
paintWithShader
kFillStyle
DrawFlags
:
:
kIgnorePathEffect
|
DrawFlags
:
:
kIgnoreMaskFilter
)
;
}
sk_sp
<
SkSpecialImage
>
Device
:
:
makeSpecial
(
const
SkBitmap
&
)
{
return
nullptr
;
}
sk_sp
<
SkSpecialImage
>
Device
:
:
makeSpecial
(
const
SkImage
*
)
{
return
nullptr
;
}
sk_sp
<
SkSpecialImage
>
Device
:
:
snapSpecial
(
const
SkIRect
&
subset
bool
forceCopy
)
{
this
-
>
flushPendingWorkToRecorder
(
)
;
SkIRect
finalSubset
=
subset
;
TextureProxyView
view
=
this
-
>
readSurfaceView
(
)
;
if
(
forceCopy
|
|
!
view
|
|
view
.
proxy
(
)
-
>
isFullyLazy
(
)
)
{
view
=
this
-
>
createCopy
(
&
subset
Mipmapped
:
:
kNo
)
;
if
(
!
view
)
{
return
nullptr
;
}
finalSubset
=
SkIRect
:
:
MakeWH
(
view
.
width
(
)
view
.
height
(
)
)
;
}
return
SkSpecialImage
:
:
MakeGraphite
(
fRecorder
finalSubset
kNeedNewImageUniqueID_SpecialImage
std
:
:
move
(
view
)
this
-
>
imageInfo
(
)
.
colorInfo
(
)
this
-
>
surfaceProps
(
)
)
;
}
TextureProxy
*
Device
:
:
target
(
)
{
return
fDC
-
>
target
(
)
;
}
TextureProxyView
Device
:
:
readSurfaceView
(
)
const
{
if
(
!
fRecorder
)
{
return
{
}
;
}
return
fDC
-
>
readSurfaceView
(
fRecorder
-
>
priv
(
)
.
caps
(
)
)
;
}
}
