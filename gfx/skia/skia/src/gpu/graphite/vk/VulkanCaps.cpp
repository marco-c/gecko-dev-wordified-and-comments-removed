#
include
"
src
/
gpu
/
graphite
/
vk
/
VulkanCaps
.
h
"
#
include
"
include
/
gpu
/
graphite
/
ContextOptions
.
h
"
#
include
"
include
/
gpu
/
graphite
/
TextureInfo
.
h
"
#
include
"
include
/
gpu
/
graphite
/
vk
/
VulkanGraphiteTypes
.
h
"
#
include
"
include
/
gpu
/
vk
/
VulkanExtensions
.
h
"
#
include
"
src
/
gpu
/
graphite
/
vk
/
VulkanGraphiteUtilsPriv
.
h
"
#
include
"
src
/
gpu
/
vk
/
VulkanUtilsPriv
.
h
"
#
ifdef
SK_BUILD_FOR_ANDROID
#
include
<
sys
/
system_properties
.
h
>
#
endif
namespace
skgpu
:
:
graphite
{
VulkanCaps
:
:
VulkanCaps
(
const
skgpu
:
:
VulkanInterface
*
vkInterface
VkPhysicalDevice
physDev
uint32_t
physicalDeviceVersion
const
skgpu
:
:
VulkanExtensions
*
extensions
const
ContextOptions
&
contextOptions
)
:
Caps
(
)
{
this
-
>
init
(
vkInterface
physDev
physicalDeviceVersion
extensions
contextOptions
)
;
}
VulkanCaps
:
:
~
VulkanCaps
(
)
{
}
void
VulkanCaps
:
:
init
(
const
skgpu
:
:
VulkanInterface
*
vkInterface
VkPhysicalDevice
physDev
uint32_t
physicalDeviceVersion
const
skgpu
:
:
VulkanExtensions
*
extensions
const
ContextOptions
&
contextOptions
)
{
VkPhysicalDeviceProperties
physDevProperties
;
VULKAN_CALL
(
vkInterface
GetPhysicalDeviceProperties
(
physDev
&
physDevProperties
)
)
;
fProtectedSupport
=
true
;
if
(
physDevProperties
.
vendorID
=
=
kARM_VkVendor
|
|
physDevProperties
.
vendorID
=
=
kQualcomm_VkVendor
)
{
fSupportsMemorylessAttachments
=
true
;
}
#
ifdef
SK_BUILD_FOR_UNIX
if
(
kNvidia_VkVendor
=
=
physDevProperties
.
vendorID
)
{
fShouldAlwaysUseDedicatedImageMemory
=
true
;
}
#
endif
if
(
physDevProperties
.
vendorID
=
=
kNvidia_VkVendor
|
|
physDevProperties
.
vendorID
=
=
kAMD_VkVendor
)
{
fGpuOnlyBuffersMorePerformant
=
true
;
fShouldPersistentlyMapCpuToGpuBuffers
=
false
;
}
this
-
>
initFormatTable
(
vkInterface
physDev
physDevProperties
)
;
this
-
>
initDepthStencilFormatTable
(
vkInterface
physDev
physDevProperties
)
;
if
(
!
contextOptions
.
fDisableDriverCorrectnessWorkarounds
)
{
this
-
>
applyDriverCorrectnessWorkarounds
(
physDevProperties
)
;
}
}
void
VulkanCaps
:
:
applyDriverCorrectnessWorkarounds
(
const
VkPhysicalDeviceProperties
&
properties
)
{
int
androidAPIVersion
=
0
;
#
if
defined
(
SK_BUILD_FOR_ANDROID
)
char
androidAPIVersionStr
[
PROP_VALUE_MAX
]
;
int
strLength
=
__system_property_get
(
"
ro
.
build
.
version
.
sdk
"
androidAPIVersionStr
)
;
androidAPIVersion
=
(
strLength
=
=
0
)
?
0
:
atoi
(
androidAPIVersionStr
)
;
#
endif
if
(
kARM_VkVendor
=
=
properties
.
vendorID
&
&
androidAPIVersion
<
=
28
)
{
fShouldAlwaysUseDedicatedImageMemory
=
true
;
}
}
static
constexpr
VkFormat
kVkFormats
[
]
=
{
VK_FORMAT_R8G8B8A8_UNORM
VK_FORMAT_R8_UNORM
VK_FORMAT_B8G8R8A8_UNORM
VK_FORMAT_R5G6B5_UNORM_PACK16
VK_FORMAT_R16G16B16A16_SFLOAT
VK_FORMAT_R16_SFLOAT
VK_FORMAT_R8G8B8_UNORM
VK_FORMAT_R8G8_UNORM
VK_FORMAT_A2B10G10R10_UNORM_PACK32
VK_FORMAT_A2R10G10B10_UNORM_PACK32
VK_FORMAT_B4G4R4A4_UNORM_PACK16
VK_FORMAT_R4G4B4A4_UNORM_PACK16
VK_FORMAT_R8G8B8A8_SRGB
VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
VK_FORMAT_BC1_RGB_UNORM_BLOCK
VK_FORMAT_BC1_RGBA_UNORM_BLOCK
VK_FORMAT_R16_UNORM
VK_FORMAT_R16G16_UNORM
VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM
VK_FORMAT_G8_B8R8_2PLANE_420_UNORM
VK_FORMAT_R16G16B16A16_UNORM
VK_FORMAT_R16G16_SFLOAT
}
;
static
constexpr
VkFormat
kDepthStencilVkFormats
[
]
=
{
VK_FORMAT_S8_UINT
VK_FORMAT_D24_UNORM_S8_UINT
VK_FORMAT_D32_SFLOAT_S8_UINT
}
;
TextureInfo
VulkanCaps
:
:
getDefaultSampledTextureInfo
(
SkColorType
ct
Mipmapped
mipmapped
Protected
isProtected
Renderable
isRenderable
)
const
{
VkFormat
format
=
this
-
>
getFormatFromColorType
(
ct
)
;
const
FormatInfo
&
formatInfo
=
this
-
>
getFormatInfo
(
format
)
;
static
constexpr
int
defaultSampleCount
=
1
;
if
(
(
isProtected
=
=
Protected
:
:
kYes
&
&
!
this
-
>
protectedSupport
(
)
)
|
|
!
formatInfo
.
isTexturable
(
VK_IMAGE_TILING_OPTIMAL
)
|
|
(
isRenderable
=
=
Renderable
:
:
kYes
&
&
!
formatInfo
.
isRenderable
(
VK_IMAGE_TILING_OPTIMAL
defaultSampleCount
)
)
)
{
return
{
}
;
}
VulkanTextureInfo
info
;
info
.
fSampleCount
=
defaultSampleCount
;
info
.
fMipmapped
=
mipmapped
;
info
.
fFlags
=
(
isProtected
=
=
Protected
:
:
kYes
)
?
VK_IMAGE_CREATE_PROTECTED_BIT
:
0
;
info
.
fFormat
=
format
;
info
.
fImageTiling
=
VK_IMAGE_TILING_OPTIMAL
;
info
.
fImageUsageFlags
=
VK_IMAGE_USAGE_SAMPLED_BIT
|
VK_IMAGE_USAGE_TRANSFER_SRC_BIT
|
VK_IMAGE_USAGE_TRANSFER_DST_BIT
;
if
(
isRenderable
=
=
Renderable
:
:
kYes
)
{
info
.
fImageUsageFlags
=
info
.
fImageUsageFlags
|
VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
;
}
info
.
fSharingMode
=
VK_SHARING_MODE_EXCLUSIVE
;
info
.
fAspectMask
=
VK_IMAGE_ASPECT_COLOR_BIT
;
return
info
;
}
TextureInfo
VulkanCaps
:
:
getDefaultMSAATextureInfo
(
const
TextureInfo
&
singleSampledInfo
Discardable
discardable
)
const
{
const
VkFormat
singleSpecFormat
=
singleSampledInfo
.
vulkanTextureSpec
(
)
.
fFormat
;
const
FormatInfo
&
formatInfo
=
this
-
>
getFormatInfo
(
singleSpecFormat
)
;
if
(
(
singleSampledInfo
.
isProtected
(
)
=
=
Protected
:
:
kYes
&
&
!
this
-
>
protectedSupport
(
)
)
|
|
!
formatInfo
.
isRenderable
(
VK_IMAGE_TILING_OPTIMAL
this
-
>
defaultMSAASamples
(
)
)
)
{
return
{
}
;
}
VulkanTextureInfo
info
;
info
.
fSampleCount
=
this
-
>
defaultMSAASamples
(
)
;
info
.
fMipmapped
=
Mipmapped
:
:
kNo
;
info
.
fFlags
=
(
singleSampledInfo
.
isProtected
(
)
=
=
Protected
:
:
kYes
)
?
VK_IMAGE_CREATE_PROTECTED_BIT
:
0
;
info
.
fFormat
=
singleSpecFormat
;
info
.
fImageTiling
=
VK_IMAGE_TILING_OPTIMAL
;
VkImageUsageFlags
flags
=
VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
;
if
(
discardable
=
=
Discardable
:
:
kYes
&
&
fSupportsMemorylessAttachments
)
{
flags
=
flags
|
VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT
;
}
info
.
fImageUsageFlags
=
flags
;
info
.
fSharingMode
=
VK_SHARING_MODE_EXCLUSIVE
;
info
.
fAspectMask
=
VK_IMAGE_ASPECT_COLOR_BIT
;
return
info
;
}
TextureInfo
VulkanCaps
:
:
getDefaultDepthStencilTextureInfo
(
SkEnumBitMask
<
DepthStencilFlags
>
flags
uint32_t
sampleCount
Protected
isProtected
)
const
{
VkFormat
format
=
this
-
>
getFormatFromDepthStencilFlags
(
flags
)
;
const
DepthStencilFormatInfo
&
formatInfo
=
this
-
>
getDepthStencilFormatInfo
(
format
)
;
if
(
(
isProtected
=
=
Protected
:
:
kYes
&
&
!
this
-
>
protectedSupport
(
)
)
|
|
!
formatInfo
.
isDepthStencilSupported
(
formatInfo
.
fFormatProperties
.
optimalTilingFeatures
)
|
|
!
formatInfo
.
fSupportedSampleCounts
.
isSampleCountSupported
(
sampleCount
)
)
{
return
{
}
;
}
VulkanTextureInfo
info
;
info
.
fSampleCount
=
sampleCount
;
info
.
fMipmapped
=
Mipmapped
:
:
kNo
;
info
.
fFlags
=
(
isProtected
=
=
Protected
:
:
kYes
)
?
VK_IMAGE_CREATE_PROTECTED_BIT
:
0
;
info
.
fFormat
=
format
;
info
.
fImageTiling
=
VK_IMAGE_TILING_OPTIMAL
;
info
.
fImageUsageFlags
=
VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
;
info
.
fSharingMode
=
VK_SHARING_MODE_EXCLUSIVE
;
info
.
fAspectMask
=
VK_IMAGE_ASPECT_COLOR_BIT
;
return
info
;
}
uint32_t
VulkanCaps
:
:
channelMask
(
const
TextureInfo
&
textureInfo
)
const
{
return
skgpu
:
:
VkFormatChannels
(
textureInfo
.
vulkanTextureSpec
(
)
.
fFormat
)
;
}
size_t
VulkanCaps
:
:
bytesPerPixel
(
const
TextureInfo
&
info
)
const
{
const
VkFormat
format
=
info
.
vulkanTextureSpec
(
)
.
fFormat
;
return
VkFormatBytesPerBlock
(
format
)
;
}
void
VulkanCaps
:
:
initFormatTable
(
const
skgpu
:
:
VulkanInterface
*
interface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceProperties
&
properties
)
{
static_assert
(
std
:
:
size
(
kVkFormats
)
=
=
VulkanCaps
:
:
kNumVkFormats
"
Size
of
VkFormats
array
must
match
static
value
in
header
"
)
;
std
:
:
fill_n
(
fColorTypeToFormatTable
kSkColorTypeCnt
VK_FORMAT_UNDEFINED
)
;
{
constexpr
VkFormat
format
=
VK_FORMAT_R8G8B8A8_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
if
(
info
.
isTexturable
(
VK_IMAGE_TILING_OPTIMAL
)
)
{
info
.
fColorTypeInfoCount
=
2
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
SkColorType
ct
=
SkColorType
:
:
kRGBA_8888_SkColorType
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
{
constexpr
SkColorType
ct
=
SkColorType
:
:
kRGB_888x_SkColorType
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
;
ctInfo
.
fReadSwizzle
=
skgpu
:
:
Swizzle
:
:
RGB1
(
)
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R8_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
if
(
info
.
isTexturable
(
VK_IMAGE_TILING_OPTIMAL
)
)
{
info
.
fColorTypeInfoCount
=
3
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
SkColorType
ct
=
SkColorType
:
:
kR8_unorm_SkColorType
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
{
constexpr
SkColorType
ct
=
SkColorType
:
:
kAlpha_8_SkColorType
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
ctInfo
.
fReadSwizzle
=
skgpu
:
:
Swizzle
(
"
000r
"
)
;
ctInfo
.
fWriteSwizzle
=
skgpu
:
:
Swizzle
(
"
a000
"
)
;
}
{
constexpr
SkColorType
ct
=
SkColorType
:
:
kGray_8_SkColorType
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
;
ctInfo
.
fReadSwizzle
=
skgpu
:
:
Swizzle
(
"
rrr1
"
)
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_B8G8R8A8_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
if
(
info
.
isTexturable
(
VK_IMAGE_TILING_OPTIMAL
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
SkColorType
ct
=
SkColorType
:
:
kBGRA_8888_SkColorType
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R5G6B5_UNORM_PACK16
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
if
(
info
.
isTexturable
(
VK_IMAGE_TILING_OPTIMAL
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
SkColorType
ct
=
SkColorType
:
:
kRGB_565_SkColorType
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R16G16B16A16_SFLOAT
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
if
(
info
.
isTexturable
(
VK_IMAGE_TILING_OPTIMAL
)
)
{
info
.
fColorTypeInfoCount
=
2
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
SkColorType
ct
=
SkColorType
:
:
kRGBA_F16_SkColorType
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R16_SFLOAT
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
if
(
info
.
isTexturable
(
VK_IMAGE_TILING_OPTIMAL
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
SkColorType
ct
=
SkColorType
:
:
kA16_float_SkColorType
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
ctInfo
.
fReadSwizzle
=
skgpu
:
:
Swizzle
(
"
000r
"
)
;
ctInfo
.
fWriteSwizzle
=
skgpu
:
:
Swizzle
(
"
a000
"
)
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R8G8B8_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
if
(
info
.
isTexturable
(
VK_IMAGE_TILING_OPTIMAL
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
SkColorType
ct
=
SkColorType
:
:
kRGB_888x_SkColorType
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
SkColorType
:
:
kRGB_888x_SkColorType
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R8G8_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
if
(
info
.
isTexturable
(
VK_IMAGE_TILING_OPTIMAL
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
SkColorType
ct
=
SkColorType
:
:
kR8G8_unorm_SkColorType
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_A2B10G10R10_UNORM_PACK32
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
if
(
info
.
isTexturable
(
VK_IMAGE_TILING_OPTIMAL
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
SkColorType
ct
=
SkColorType
:
:
kRGBA_1010102_SkColorType
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_A2R10G10B10_UNORM_PACK32
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
if
(
info
.
isTexturable
(
VK_IMAGE_TILING_OPTIMAL
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
SkColorType
ct
=
SkColorType
:
:
kBGRA_1010102_SkColorType
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_B4G4R4A4_UNORM_PACK16
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
if
(
info
.
isTexturable
(
VK_IMAGE_TILING_OPTIMAL
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
SkColorType
ct
=
SkColorType
:
:
kARGB_4444_SkColorType
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
ctInfo
.
fReadSwizzle
=
skgpu
:
:
Swizzle
:
:
BGRA
(
)
;
ctInfo
.
fWriteSwizzle
=
skgpu
:
:
Swizzle
:
:
BGRA
(
)
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R4G4B4A4_UNORM_PACK16
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
if
(
info
.
isTexturable
(
VK_IMAGE_TILING_OPTIMAL
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
SkColorType
ct
=
SkColorType
:
:
kARGB_4444_SkColorType
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R8G8B8A8_SRGB
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
if
(
info
.
isTexturable
(
VK_IMAGE_TILING_OPTIMAL
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
SkColorType
ct
=
SkColorType
:
:
kSRGBA_8888_SkColorType
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R16_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
if
(
info
.
isTexturable
(
VK_IMAGE_TILING_OPTIMAL
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
SkColorType
ct
=
SkColorType
:
:
kA16_unorm_SkColorType
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
ctInfo
.
fReadSwizzle
=
skgpu
:
:
Swizzle
(
"
000r
"
)
;
ctInfo
.
fWriteSwizzle
=
skgpu
:
:
Swizzle
(
"
a000
"
)
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R16G16_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
if
(
info
.
isTexturable
(
VK_IMAGE_TILING_OPTIMAL
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
SkColorType
ct
=
SkColorType
:
:
kR16G16_unorm_SkColorType
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R16G16B16A16_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
if
(
info
.
isTexturable
(
VK_IMAGE_TILING_OPTIMAL
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
SkColorType
ct
=
SkColorType
:
:
kR16G16B16A16_unorm_SkColorType
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_R16G16_SFLOAT
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
if
(
info
.
isTexturable
(
VK_IMAGE_TILING_OPTIMAL
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
SkColorType
ct
=
SkColorType
:
:
kR16G16_float_SkColorType
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
|
ColorTypeInfo
:
:
kRenderable_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
if
(
fSupportsYcbcrConversion
)
{
info
.
init
(
interface
physDev
properties
format
)
;
SkDEBUGCODE
(
info
.
fIsWrappedOnly
=
true
;
)
}
if
(
info
.
isTexturable
(
VK_IMAGE_TILING_OPTIMAL
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
SkColorType
ct
=
SkColorType
:
:
kRGB_888x_SkColorType
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_G8_B8R8_2PLANE_420_UNORM
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
if
(
fSupportsYcbcrConversion
)
{
info
.
init
(
interface
physDev
properties
format
)
;
SkDEBUGCODE
(
info
.
fIsWrappedOnly
=
true
;
)
}
if
(
info
.
isTexturable
(
VK_IMAGE_TILING_OPTIMAL
)
)
{
info
.
fColorTypeInfoCount
=
1
;
info
.
fColorTypeInfos
=
std
:
:
make_unique
<
ColorTypeInfo
[
]
>
(
info
.
fColorTypeInfoCount
)
;
int
ctIdx
=
0
;
{
constexpr
SkColorType
ct
=
SkColorType
:
:
kRGB_888x_SkColorType
;
auto
&
ctInfo
=
info
.
fColorTypeInfos
[
ctIdx
+
+
]
;
ctInfo
.
fColorType
=
ct
;
ctInfo
.
fTransferColorType
=
ct
;
ctInfo
.
fFlags
=
ColorTypeInfo
:
:
kUploadData_Flag
;
}
}
}
{
constexpr
VkFormat
format
=
VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
}
{
constexpr
VkFormat
format
=
VK_FORMAT_BC1_RGB_UNORM_BLOCK
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
}
{
constexpr
VkFormat
format
=
VK_FORMAT_BC1_RGBA_UNORM_BLOCK
;
auto
&
info
=
this
-
>
getFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
}
typedef
SkColorType
ct
;
this
-
>
setColorType
(
ct
:
:
kAlpha_8_SkColorType
{
VK_FORMAT_R8_UNORM
}
)
;
this
-
>
setColorType
(
ct
:
:
kRGB_565_SkColorType
{
VK_FORMAT_R5G6B5_UNORM_PACK16
}
)
;
this
-
>
setColorType
(
ct
:
:
kARGB_4444_SkColorType
{
VK_FORMAT_R4G4B4A4_UNORM_PACK16
VK_FORMAT_B4G4R4A4_UNORM_PACK16
}
)
;
this
-
>
setColorType
(
ct
:
:
kRGBA_8888_SkColorType
{
VK_FORMAT_R8G8B8A8_UNORM
}
)
;
this
-
>
setColorType
(
ct
:
:
kSRGBA_8888_SkColorType
{
VK_FORMAT_R8G8B8A8_SRGB
}
)
;
this
-
>
setColorType
(
ct
:
:
kRGB_888x_SkColorType
{
VK_FORMAT_R8G8B8_UNORM
VK_FORMAT_R8G8B8A8_UNORM
}
)
;
this
-
>
setColorType
(
ct
:
:
kR8G8_unorm_SkColorType
{
VK_FORMAT_R8G8_UNORM
}
)
;
this
-
>
setColorType
(
ct
:
:
kBGRA_8888_SkColorType
{
VK_FORMAT_B8G8R8A8_UNORM
}
)
;
this
-
>
setColorType
(
ct
:
:
kRGBA_1010102_SkColorType
{
VK_FORMAT_A2B10G10R10_UNORM_PACK32
}
)
;
this
-
>
setColorType
(
ct
:
:
kBGRA_1010102_SkColorType
{
VK_FORMAT_A2R10G10B10_UNORM_PACK32
}
)
;
this
-
>
setColorType
(
ct
:
:
kGray_8_SkColorType
{
VK_FORMAT_R8_UNORM
}
)
;
this
-
>
setColorType
(
ct
:
:
kA16_float_SkColorType
{
VK_FORMAT_R16_SFLOAT
}
)
;
this
-
>
setColorType
(
ct
:
:
kRGBA_F16_SkColorType
{
VK_FORMAT_R16G16B16A16_SFLOAT
}
)
;
this
-
>
setColorType
(
ct
:
:
kA16_unorm_SkColorType
{
VK_FORMAT_R16_UNORM
}
)
;
this
-
>
setColorType
(
ct
:
:
kR16G16_unorm_SkColorType
{
VK_FORMAT_R16G16_UNORM
}
)
;
this
-
>
setColorType
(
ct
:
:
kR16G16B16A16_unorm_SkColorType
{
VK_FORMAT_R16G16B16A16_UNORM
}
)
;
this
-
>
setColorType
(
ct
:
:
kR16G16_float_SkColorType
{
VK_FORMAT_R16G16_SFLOAT
}
)
;
}
void
VulkanCaps
:
:
initDepthStencilFormatTable
(
const
skgpu
:
:
VulkanInterface
*
interface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceProperties
&
properties
)
{
static_assert
(
std
:
:
size
(
kDepthStencilVkFormats
)
=
=
VulkanCaps
:
:
kNumDepthStencilVkFormats
"
Size
of
DepthStencilVkFormats
array
must
match
static
value
in
header
"
)
;
std
:
:
fill_n
(
fDepthStencilFlagsToFormatTable
kNumDepthStencilFlags
VK_FORMAT_UNDEFINED
)
;
{
constexpr
VkFormat
format
=
VK_FORMAT_S8_UINT
;
auto
&
info
=
this
-
>
getDepthStencilFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
}
{
constexpr
VkFormat
format
=
VK_FORMAT_D24_UNORM_S8_UINT
;
auto
&
info
=
this
-
>
getDepthStencilFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
}
{
constexpr
VkFormat
format
=
VK_FORMAT_D32_SFLOAT_S8_UINT
;
auto
&
info
=
this
-
>
getDepthStencilFormatInfo
(
format
)
;
info
.
init
(
interface
physDev
properties
format
)
;
}
}
void
VulkanCaps
:
:
SupportedSampleCounts
:
:
initSampleCounts
(
const
skgpu
:
:
VulkanInterface
*
interface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceProperties
&
physProps
VkFormat
format
VkImageUsageFlags
usage
)
{
VkImageFormatProperties
properties
;
VkResult
result
;
VULKAN_CALL_RESULT
(
interface
result
GetPhysicalDeviceImageFormatProperties
(
physDev
format
VK_IMAGE_TYPE_2D
VK_IMAGE_TILING_OPTIMAL
usage
0
&
properties
)
)
;
if
(
result
!
=
VK_SUCCESS
)
{
SKGPU_LOG_W
(
"
Vulkan
call
GetPhysicalDeviceImageFormatProperties
failed
"
)
;
return
;
}
VkSampleCountFlags
flags
=
properties
.
sampleCounts
;
if
(
flags
&
VK_SAMPLE_COUNT_1_BIT
)
{
fSampleCounts
.
push_back
(
1
)
;
}
if
(
kImagination_VkVendor
=
=
physProps
.
vendorID
)
{
return
;
}
if
(
kIntel_VkVendor
=
=
physProps
.
vendorID
)
{
return
;
}
if
(
flags
&
VK_SAMPLE_COUNT_2_BIT
)
{
fSampleCounts
.
push_back
(
2
)
;
}
if
(
flags
&
VK_SAMPLE_COUNT_4_BIT
)
{
fSampleCounts
.
push_back
(
4
)
;
}
if
(
flags
&
VK_SAMPLE_COUNT_8_BIT
)
{
fSampleCounts
.
push_back
(
8
)
;
}
if
(
flags
&
VK_SAMPLE_COUNT_16_BIT
)
{
fSampleCounts
.
push_back
(
16
)
;
}
}
bool
VulkanCaps
:
:
SupportedSampleCounts
:
:
isSampleCountSupported
(
int
requestedCount
)
const
{
requestedCount
=
std
:
:
max
(
1
requestedCount
)
;
for
(
int
i
=
0
;
i
<
fSampleCounts
.
size
(
)
;
i
+
+
)
{
if
(
fSampleCounts
[
i
]
=
=
requestedCount
)
{
return
true
;
}
else
if
(
requestedCount
<
fSampleCounts
[
i
]
)
{
return
false
;
}
}
return
false
;
}
void
VulkanCaps
:
:
FormatInfo
:
:
init
(
const
skgpu
:
:
VulkanInterface
*
interface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceProperties
&
properties
VkFormat
format
)
{
memset
(
&
fFormatProperties
0
sizeof
(
VkFormatProperties
)
)
;
VULKAN_CALL
(
interface
GetPhysicalDeviceFormatProperties
(
physDev
format
&
fFormatProperties
)
)
;
if
(
this
-
>
isRenderable
(
fFormatProperties
.
optimalTilingFeatures
)
)
{
VkImageUsageFlags
usageFlags
=
VK_IMAGE_USAGE_TRANSFER_SRC_BIT
|
VK_IMAGE_USAGE_TRANSFER_DST_BIT
|
VK_IMAGE_USAGE_SAMPLED_BIT
|
VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
;
this
-
>
fSupportedSampleCounts
.
initSampleCounts
(
interface
physDev
properties
format
usageFlags
)
;
}
}
bool
VulkanCaps
:
:
FormatInfo
:
:
isTexturable
(
VkImageTiling
imageTiling
)
const
{
switch
(
imageTiling
)
{
case
VK_IMAGE_TILING_OPTIMAL
:
return
this
-
>
isTexturable
(
fFormatProperties
.
optimalTilingFeatures
)
;
case
VK_IMAGE_TILING_LINEAR
:
return
this
-
>
isTexturable
(
fFormatProperties
.
linearTilingFeatures
)
;
default
:
return
false
;
}
SkUNREACHABLE
;
}
bool
VulkanCaps
:
:
FormatInfo
:
:
isRenderable
(
VkImageTiling
imageTiling
uint32_t
sampleCount
)
const
{
if
(
!
fSupportedSampleCounts
.
isSampleCountSupported
(
sampleCount
)
)
{
return
false
;
}
switch
(
imageTiling
)
{
case
VK_IMAGE_TILING_OPTIMAL
:
return
this
-
>
isRenderable
(
fFormatProperties
.
optimalTilingFeatures
)
;
case
VK_IMAGE_TILING_LINEAR
:
return
this
-
>
isRenderable
(
fFormatProperties
.
linearTilingFeatures
)
;
default
:
return
false
;
}
SkUNREACHABLE
;
}
bool
VulkanCaps
:
:
FormatInfo
:
:
isTexturable
(
VkFormatFeatureFlags
flags
)
const
{
return
SkToBool
(
VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT
&
flags
)
&
&
SkToBool
(
VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
&
flags
)
;
}
bool
VulkanCaps
:
:
FormatInfo
:
:
isRenderable
(
VkFormatFeatureFlags
flags
)
const
{
return
SkToBool
(
VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
&
flags
)
;
}
void
VulkanCaps
:
:
setColorType
(
SkColorType
colorType
std
:
:
initializer_list
<
VkFormat
>
formats
)
{
#
ifdef
SK_DEBUG
for
(
size_t
i
=
0
;
i
<
kNumVkFormats
;
+
+
i
)
{
const
auto
&
formatInfo
=
fFormatTable
[
i
]
;
for
(
int
j
=
0
;
j
<
formatInfo
.
fColorTypeInfoCount
;
+
+
j
)
{
const
auto
&
ctInfo
=
formatInfo
.
fColorTypeInfos
[
j
]
;
if
(
ctInfo
.
fColorType
=
=
colorType
&
&
!
formatInfo
.
fIsWrappedOnly
)
{
bool
found
=
false
;
for
(
auto
it
=
formats
.
begin
(
)
;
it
!
=
formats
.
end
(
)
;
+
+
it
)
{
if
(
kVkFormats
[
i
]
=
=
*
it
)
{
found
=
true
;
}
}
SkASSERT
(
found
)
;
}
}
}
#
endif
int
idx
=
static_cast
<
int
>
(
colorType
)
;
for
(
auto
it
=
formats
.
begin
(
)
;
it
!
=
formats
.
end
(
)
;
+
+
it
)
{
const
auto
&
info
=
this
-
>
getFormatInfo
(
*
it
)
;
for
(
int
i
=
0
;
i
<
info
.
fColorTypeInfoCount
;
+
+
i
)
{
if
(
info
.
fColorTypeInfos
[
i
]
.
fColorType
=
=
colorType
)
{
fColorTypeToFormatTable
[
idx
]
=
*
it
;
return
;
}
}
}
}
VkFormat
VulkanCaps
:
:
getFormatFromColorType
(
SkColorType
colorType
)
const
{
int
idx
=
static_cast
<
int
>
(
colorType
)
;
return
fColorTypeToFormatTable
[
idx
]
;
}
VulkanCaps
:
:
FormatInfo
&
VulkanCaps
:
:
getFormatInfo
(
VkFormat
format
)
{
static_assert
(
std
:
:
size
(
kVkFormats
)
=
=
VulkanCaps
:
:
kNumVkFormats
"
Size
of
VkFormats
array
must
match
static
value
in
header
"
)
;
for
(
size_t
i
=
0
;
i
<
std
:
:
size
(
kVkFormats
)
;
+
+
i
)
{
if
(
kVkFormats
[
i
]
=
=
format
)
{
return
fFormatTable
[
i
]
;
}
}
static
FormatInfo
kInvalidFormat
;
return
kInvalidFormat
;
}
const
VulkanCaps
:
:
FormatInfo
&
VulkanCaps
:
:
getFormatInfo
(
VkFormat
format
)
const
{
VulkanCaps
*
nonConstThis
=
const_cast
<
VulkanCaps
*
>
(
this
)
;
return
nonConstThis
-
>
getFormatInfo
(
format
)
;
}
void
VulkanCaps
:
:
DepthStencilFormatInfo
:
:
init
(
const
skgpu
:
:
VulkanInterface
*
interface
VkPhysicalDevice
physDev
const
VkPhysicalDeviceProperties
&
properties
VkFormat
format
)
{
memset
(
&
fFormatProperties
0
sizeof
(
VkFormatProperties
)
)
;
VULKAN_CALL
(
interface
GetPhysicalDeviceFormatProperties
(
physDev
format
&
fFormatProperties
)
)
;
VkImageUsageFlags
usageFlags
=
VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
;
fSupportedSampleCounts
.
initSampleCounts
(
interface
physDev
properties
format
usageFlags
)
;
}
bool
VulkanCaps
:
:
DepthStencilFormatInfo
:
:
isDepthStencilSupported
(
VkFormatFeatureFlags
flags
)
const
{
return
SkToBool
(
VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
&
flags
)
;
}
VkFormat
VulkanCaps
:
:
getFormatFromDepthStencilFlags
(
const
SkEnumBitMask
<
DepthStencilFlags
>
&
flags
)
const
{
int
idx
=
static_cast
<
int
>
(
flags
)
;
return
fDepthStencilFlagsToFormatTable
[
idx
]
;
}
VulkanCaps
:
:
DepthStencilFormatInfo
&
VulkanCaps
:
:
getDepthStencilFormatInfo
(
VkFormat
format
)
{
static_assert
(
std
:
:
size
(
kDepthStencilVkFormats
)
=
=
VulkanCaps
:
:
kNumDepthStencilVkFormats
"
Size
of
VkFormats
array
must
match
static
value
in
header
"
)
;
for
(
size_t
i
=
0
;
i
<
std
:
:
size
(
kDepthStencilVkFormats
)
;
+
+
i
)
{
if
(
kVkFormats
[
i
]
=
=
format
)
{
return
fDepthStencilFormatTable
[
i
]
;
}
}
static
DepthStencilFormatInfo
kInvalidFormat
;
return
kInvalidFormat
;
}
const
VulkanCaps
:
:
DepthStencilFormatInfo
&
VulkanCaps
:
:
getDepthStencilFormatInfo
(
VkFormat
format
)
const
{
VulkanCaps
*
nonConstThis
=
const_cast
<
VulkanCaps
*
>
(
this
)
;
return
nonConstThis
-
>
getDepthStencilFormatInfo
(
format
)
;
}
}
