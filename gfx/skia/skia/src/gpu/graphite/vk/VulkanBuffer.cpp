#
include
"
src
/
gpu
/
graphite
/
vk
/
VulkanBuffer
.
h
"
#
include
"
include
/
gpu
/
vk
/
VulkanMemoryAllocator
.
h
"
#
include
"
src
/
gpu
/
graphite
/
vk
/
VulkanGraphiteUtilsPriv
.
h
"
#
include
"
src
/
gpu
/
vk
/
VulkanMemory
.
h
"
namespace
skgpu
:
:
graphite
{
sk_sp
<
Buffer
>
VulkanBuffer
:
:
Make
(
const
VulkanSharedContext
*
sharedContext
size_t
size
BufferType
type
PrioritizeGpuReads
prioritizeGpuReads
)
{
if
(
size
<
=
0
)
{
return
nullptr
;
}
VkBuffer
buffer
;
skgpu
:
:
VulkanAlloc
alloc
;
bool
requiresMappable
=
sharedContext
-
>
isProtected
(
)
=
=
Protected
:
:
kYes
|
|
prioritizeGpuReads
=
=
PrioritizeGpuReads
:
:
kNo
|
|
!
sharedContext
-
>
vulkanCaps
(
)
.
gpuOnlyBuffersMorePerformant
(
)
;
using
BufferUsage
=
skgpu
:
:
VulkanMemoryAllocator
:
:
BufferUsage
;
BufferUsage
allocUsage
=
requiresMappable
?
BufferUsage
:
:
kCpuWritesGpuReads
:
BufferUsage
:
:
kGpuOnly
;
VkBufferCreateInfo
bufInfo
;
memset
(
&
bufInfo
0
sizeof
(
VkBufferCreateInfo
)
)
;
bufInfo
.
sType
=
VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO
;
bufInfo
.
flags
=
0
;
bufInfo
.
size
=
size
;
switch
(
type
)
{
case
BufferType
:
:
kVertex
:
bufInfo
.
usage
=
VK_BUFFER_USAGE_VERTEX_BUFFER_BIT
|
VK_BUFFER_USAGE_TRANSFER_DST_BIT
;
break
;
case
BufferType
:
:
kIndex
:
bufInfo
.
usage
=
VK_BUFFER_USAGE_INDEX_BUFFER_BIT
|
VK_BUFFER_USAGE_TRANSFER_DST_BIT
;
break
;
case
BufferType
:
:
kStorage
:
bufInfo
.
usage
=
VK_BUFFER_USAGE_STORAGE_BUFFER_BIT
;
break
;
case
BufferType
:
:
kIndirect
:
bufInfo
.
usage
=
VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT
|
VK_BUFFER_USAGE_STORAGE_BUFFER_BIT
;
break
;
case
BufferType
:
:
kVertexStorage
:
bufInfo
.
usage
=
VK_BUFFER_USAGE_VERTEX_BUFFER_BIT
|
VK_BUFFER_USAGE_STORAGE_BUFFER_BIT
;
break
;
case
BufferType
:
:
kIndexStorage
:
bufInfo
.
usage
=
VK_BUFFER_USAGE_INDEX_BUFFER_BIT
|
VK_BUFFER_USAGE_STORAGE_BUFFER_BIT
;
break
;
case
BufferType
:
:
kUniform
:
bufInfo
.
usage
=
VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT
;
allocUsage
=
BufferUsage
:
:
kCpuWritesGpuReads
;
break
;
case
BufferType
:
:
kXferCpuToGpu
:
bufInfo
.
usage
=
VK_BUFFER_USAGE_TRANSFER_SRC_BIT
;
allocUsage
=
BufferUsage
:
:
kTransfersFromCpuToGpu
;
break
;
case
BufferType
:
:
kXferGpuToCpu
:
bufInfo
.
usage
=
VK_BUFFER_USAGE_TRANSFER_DST_BIT
;
allocUsage
=
BufferUsage
:
:
kTransfersFromGpuToCpu
;
break
;
}
if
(
!
requiresMappable
)
{
bufInfo
.
usage
|
=
VK_BUFFER_USAGE_TRANSFER_DST_BIT
;
}
bufInfo
.
sharingMode
=
VK_SHARING_MODE_EXCLUSIVE
;
bufInfo
.
queueFamilyIndexCount
=
0
;
bufInfo
.
pQueueFamilyIndices
=
nullptr
;
VkResult
result
;
VULKAN_CALL_RESULT
(
sharedContext
-
>
interface
(
)
result
CreateBuffer
(
sharedContext
-
>
device
(
)
&
bufInfo
nullptr
&
buffer
)
)
;
if
(
result
!
=
VK_SUCCESS
)
{
return
nullptr
;
}
auto
allocator
=
sharedContext
-
>
memoryAllocator
(
)
;
bool
shouldPersistentlyMapCpuToGpu
=
sharedContext
-
>
vulkanCaps
(
)
.
shouldPersistentlyMapCpuToGpuBuffers
(
)
;
auto
checkResult
=
[
]
(
VkResult
result
)
{
return
result
=
=
VK_SUCCESS
;
}
;
if
(
!
skgpu
:
:
VulkanMemory
:
:
AllocBufferMemory
(
allocator
buffer
allocUsage
shouldPersistentlyMapCpuToGpu
checkResult
&
alloc
)
)
{
VULKAN_CALL
(
sharedContext
-
>
interface
(
)
DestroyBuffer
(
sharedContext
-
>
device
(
)
buffer
nullptr
)
)
;
return
nullptr
;
}
VULKAN_CALL_RESULT
(
sharedContext
-
>
interface
(
)
result
BindBufferMemory
(
sharedContext
-
>
device
(
)
buffer
alloc
.
fMemory
alloc
.
fOffset
)
)
;
if
(
result
!
=
VK_SUCCESS
)
{
skgpu
:
:
VulkanMemory
:
:
FreeBufferMemory
(
allocator
alloc
)
;
VULKAN_CALL
(
sharedContext
-
>
interface
(
)
DestroyBuffer
(
sharedContext
-
>
device
(
)
buffer
nullptr
)
)
;
return
nullptr
;
}
return
sk_sp
<
Buffer
>
(
new
VulkanBuffer
(
sharedContext
size
type
prioritizeGpuReads
std
:
:
move
(
buffer
)
alloc
bufInfo
.
usage
)
)
;
}
VulkanBuffer
:
:
VulkanBuffer
(
const
VulkanSharedContext
*
sharedContext
size_t
size
BufferType
type
PrioritizeGpuReads
prioritizeGpuReads
VkBuffer
buffer
const
skgpu
:
:
VulkanAlloc
&
alloc
const
VkBufferUsageFlags
usageFlags
)
:
Buffer
(
sharedContext
size
)
fBuffer
(
std
:
:
move
(
buffer
)
)
fAlloc
(
alloc
)
fBufferUsageFlags
(
usageFlags
)
fBufferUsedForCPURead
(
type
=
=
BufferType
:
:
kXferGpuToCpu
)
{
}
void
VulkanBuffer
:
:
freeGpuData
(
)
{
if
(
fMapPtr
)
{
this
-
>
internalUnmap
(
0
this
-
>
size
(
)
)
;
fMapPtr
=
nullptr
;
}
const
VulkanSharedContext
*
sharedContext
=
static_cast
<
const
VulkanSharedContext
*
>
(
this
-
>
sharedContext
(
)
)
;
SkASSERT
(
fBuffer
)
;
SkASSERT
(
fAlloc
.
fMemory
&
&
fAlloc
.
fBackendMemory
)
;
VULKAN_CALL
(
sharedContext
-
>
interface
(
)
DestroyBuffer
(
sharedContext
-
>
device
(
)
fBuffer
nullptr
)
)
;
fBuffer
=
VK_NULL_HANDLE
;
skgpu
:
:
VulkanMemory
:
:
FreeBufferMemory
(
sharedContext
-
>
memoryAllocator
(
)
fAlloc
)
;
fAlloc
.
fMemory
=
VK_NULL_HANDLE
;
fAlloc
.
fBackendMemory
=
0
;
}
void
VulkanBuffer
:
:
internalMap
(
size_t
readOffset
size_t
readSize
)
{
SkASSERT
(
!
fMapPtr
)
;
if
(
this
-
>
isMappable
(
)
)
{
#
ifdef
SK_DEBUG
SkASSERT
(
!
this
-
>
debugHasCommandBufferRef
(
)
)
;
#
endif
SkASSERT
(
fAlloc
.
fSize
>
0
)
;
SkASSERT
(
fAlloc
.
fSize
>
=
readOffset
+
readSize
)
;
const
VulkanSharedContext
*
sharedContext
=
this
-
>
vulkanSharedContext
(
)
;
auto
allocator
=
sharedContext
-
>
memoryAllocator
(
)
;
auto
checkResult
=
[
sharedContext
]
(
VkResult
result
)
{
return
sharedContext
-
>
checkVkResult
(
result
)
;
}
;
fMapPtr
=
skgpu
:
:
VulkanMemory
:
:
MapAlloc
(
allocator
fAlloc
checkResult
)
;
if
(
fMapPtr
&
&
readSize
!
=
0
)
{
skgpu
:
:
VulkanMemory
:
:
InvalidateMappedAlloc
(
allocator
fAlloc
readOffset
readSize
nullptr
)
;
}
}
}
void
VulkanBuffer
:
:
internalUnmap
(
size_t
flushOffset
size_t
flushSize
)
{
SkASSERT
(
fMapPtr
&
&
this
-
>
isMappable
(
)
)
;
SkASSERT
(
fAlloc
.
fSize
>
0
)
;
SkASSERT
(
fAlloc
.
fSize
>
=
flushOffset
+
flushSize
)
;
auto
allocator
=
this
-
>
vulkanSharedContext
(
)
-
>
memoryAllocator
(
)
;
skgpu
:
:
VulkanMemory
:
:
FlushMappedAlloc
(
allocator
fAlloc
flushOffset
flushSize
nullptr
)
;
skgpu
:
:
VulkanMemory
:
:
UnmapAlloc
(
allocator
fAlloc
)
;
}
void
VulkanBuffer
:
:
onMap
(
)
{
SkASSERT
(
fBuffer
)
;
SkASSERT
(
!
this
-
>
isMapped
(
)
)
;
this
-
>
internalMap
(
0
fBufferUsedForCPURead
?
this
-
>
size
(
)
:
0
)
;
}
void
VulkanBuffer
:
:
onUnmap
(
)
{
SkASSERT
(
fBuffer
)
;
SkASSERT
(
this
-
>
isMapped
(
)
)
;
this
-
>
internalUnmap
(
0
fBufferUsedForCPURead
?
0
:
this
-
>
size
(
)
)
;
}
}
