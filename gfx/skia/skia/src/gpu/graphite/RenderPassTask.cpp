#
include
"
src
/
gpu
/
graphite
/
RenderPassTask
.
h
"
#
include
"
src
/
gpu
/
graphite
/
CommandBuffer
.
h
"
#
include
"
src
/
gpu
/
graphite
/
ContextPriv
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawPass
.
h
"
#
include
"
src
/
gpu
/
graphite
/
Log
.
h
"
#
include
"
src
/
gpu
/
graphite
/
ResourceProvider
.
h
"
#
include
"
src
/
gpu
/
graphite
/
Texture
.
h
"
#
include
"
src
/
gpu
/
graphite
/
TextureProxy
.
h
"
namespace
skgpu
:
:
graphite
{
sk_sp
<
RenderPassTask
>
RenderPassTask
:
:
Make
(
DrawPassList
passes
const
RenderPassDesc
&
desc
sk_sp
<
TextureProxy
>
target
)
{
SkASSERT
(
passes
.
size
(
)
=
=
1
)
;
if
(
!
target
)
{
return
nullptr
;
}
return
sk_sp
<
RenderPassTask
>
(
new
RenderPassTask
(
std
:
:
move
(
passes
)
desc
target
)
)
;
}
RenderPassTask
:
:
RenderPassTask
(
DrawPassList
passes
const
RenderPassDesc
&
desc
sk_sp
<
TextureProxy
>
target
)
:
fDrawPasses
(
std
:
:
move
(
passes
)
)
fRenderPassDesc
(
desc
)
fTarget
(
std
:
:
move
(
target
)
)
{
}
RenderPassTask
:
:
~
RenderPassTask
(
)
=
default
;
bool
RenderPassTask
:
:
prepareResources
(
ResourceProvider
*
resourceProvider
const
RuntimeEffectDictionary
*
runtimeDict
)
{
SkASSERT
(
fTarget
)
;
if
(
!
TextureProxy
:
:
InstantiateIfNotLazy
(
resourceProvider
fTarget
.
get
(
)
)
)
{
SKGPU_LOG_W
(
"
Failed
to
instantiate
RenderPassTask
target
.
Will
not
create
renderpass
!
"
)
;
SKGPU_LOG_W
(
"
Dimensions
are
(
%
d
%
d
)
.
"
fTarget
-
>
dimensions
(
)
.
width
(
)
fTarget
-
>
dimensions
(
)
.
height
(
)
)
;
return
false
;
}
SkASSERT
(
fDrawPasses
.
size
(
)
=
=
1
)
;
for
(
const
auto
&
drawPass
:
fDrawPasses
)
{
if
(
!
drawPass
-
>
prepareResources
(
resourceProvider
runtimeDict
fRenderPassDesc
)
)
{
return
false
;
}
}
return
true
;
}
bool
RenderPassTask
:
:
addCommands
(
Context
*
context
CommandBuffer
*
commandBuffer
ReplayTargetData
replayData
)
{
SkASSERT
(
fTarget
&
&
fTarget
-
>
isInstantiated
(
)
)
;
if
(
fTarget
-
>
texture
(
)
=
=
replayData
.
fTarget
)
{
commandBuffer
-
>
setReplayTranslation
(
replayData
.
fTranslation
)
;
}
else
{
commandBuffer
-
>
clearReplayTranslation
(
)
;
}
ResourceProvider
*
resourceProvider
=
context
-
>
priv
(
)
.
resourceProvider
(
)
;
sk_sp
<
Texture
>
colorAttachment
;
sk_sp
<
Texture
>
resolveAttachment
;
if
(
fRenderPassDesc
.
fColorResolveAttachment
.
fTextureInfo
.
isValid
(
)
)
{
SkASSERT
(
fTarget
-
>
numSamples
(
)
=
=
1
&
&
fRenderPassDesc
.
fColorAttachment
.
fTextureInfo
.
numSamples
(
)
>
1
)
;
colorAttachment
=
resourceProvider
-
>
findOrCreateDiscardableMSAAAttachment
(
fTarget
-
>
dimensions
(
)
fRenderPassDesc
.
fColorAttachment
.
fTextureInfo
)
;
if
(
!
colorAttachment
)
{
SKGPU_LOG_W
(
"
Could
not
get
Color
attachment
for
RenderPassTask
"
)
;
return
false
;
}
resolveAttachment
=
fTarget
-
>
refTexture
(
)
;
}
else
{
colorAttachment
=
fTarget
-
>
refTexture
(
)
;
}
sk_sp
<
Texture
>
depthStencilAttachment
;
if
(
fRenderPassDesc
.
fDepthStencilAttachment
.
fTextureInfo
.
isValid
(
)
)
{
depthStencilAttachment
=
resourceProvider
-
>
findOrCreateDepthStencilAttachment
(
fTarget
-
>
dimensions
(
)
fRenderPassDesc
.
fDepthStencilAttachment
.
fTextureInfo
)
;
if
(
!
depthStencilAttachment
)
{
SKGPU_LOG_W
(
"
Could
not
get
DepthStencil
attachment
for
RenderPassTask
"
)
;
return
false
;
}
}
return
commandBuffer
-
>
addRenderPass
(
fRenderPassDesc
std
:
:
move
(
colorAttachment
)
std
:
:
move
(
resolveAttachment
)
std
:
:
move
(
depthStencilAttachment
)
SkRect
:
:
Make
(
fTarget
-
>
dimensions
(
)
)
fDrawPasses
)
;
}
}
