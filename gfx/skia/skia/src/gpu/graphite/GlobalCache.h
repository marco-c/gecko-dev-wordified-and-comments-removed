#
ifndef
skgpu_graphite_GlobalCache_DEFINED
#
define
skgpu_graphite_GlobalCache_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
private
/
SkSpinlock
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
src
/
core
/
SkLRUCache
.
h
"
#
include
"
src
/
gpu
/
ResourceKey
.
h
"
namespace
skgpu
:
:
graphite
{
class
ComputePipeline
;
class
GraphicsPipeline
;
class
Resource
;
class
ShaderCodeDictionary
;
class
GlobalCache
{
public
:
GlobalCache
(
)
;
~
GlobalCache
(
)
;
sk_sp
<
GraphicsPipeline
>
findGraphicsPipeline
(
const
UniqueKey
&
)
SK_EXCLUDES
(
fSpinLock
)
;
sk_sp
<
GraphicsPipeline
>
addGraphicsPipeline
(
const
UniqueKey
&
sk_sp
<
GraphicsPipeline
>
)
SK_EXCLUDES
(
fSpinLock
)
;
#
if
GRAPHITE_TEST_UTILS
int
numGraphicsPipelines
(
)
const
SK_EXCLUDES
(
fSpinLock
)
;
void
resetGraphicsPipelines
(
)
SK_EXCLUDES
(
fSpinLock
)
;
#
endif
sk_sp
<
ComputePipeline
>
findComputePipeline
(
const
UniqueKey
&
)
SK_EXCLUDES
(
fSpinLock
)
;
sk_sp
<
ComputePipeline
>
addComputePipeline
(
const
UniqueKey
&
sk_sp
<
ComputePipeline
>
)
SK_EXCLUDES
(
fSpinLock
)
;
void
addStaticResource
(
sk_sp
<
Resource
>
)
SK_EXCLUDES
(
fSpinLock
)
;
private
:
struct
KeyHash
{
uint32_t
operator
(
)
(
const
UniqueKey
&
key
)
const
{
return
key
.
hash
(
)
;
}
}
;
using
GraphicsPipelineCache
=
SkLRUCache
<
UniqueKey
sk_sp
<
GraphicsPipeline
>
KeyHash
>
;
using
ComputePipelineCache
=
SkLRUCache
<
UniqueKey
sk_sp
<
ComputePipeline
>
KeyHash
>
;
mutable
SkSpinlock
fSpinLock
;
GraphicsPipelineCache
fGraphicsPipelineCache
SK_GUARDED_BY
(
fSpinLock
)
;
ComputePipelineCache
fComputePipelineCache
SK_GUARDED_BY
(
fSpinLock
)
;
SkTArray
<
sk_sp
<
Resource
>
>
fStaticResource
SK_GUARDED_BY
(
fSpinLock
)
;
}
;
}
#
endif
