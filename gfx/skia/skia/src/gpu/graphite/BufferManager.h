#
ifndef
skgpu_graphite_BufferManager_DEFINED
#
define
skgpu_graphite_BufferManager_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
src
/
gpu
/
BufferWriter
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawTypes
.
h
"
#
include
"
src
/
gpu
/
graphite
/
ResourceTypes
.
h
"
#
include
<
array
>
#
include
<
vector
>
namespace
skgpu
:
:
graphite
{
class
Buffer
;
class
Caps
;
class
Context
;
class
GlobalCache
;
class
QueueManager
;
class
Recording
;
class
ResourceProvider
;
class
DrawBufferManager
{
public
:
DrawBufferManager
(
ResourceProvider
*
const
Caps
*
)
;
~
DrawBufferManager
(
)
;
std
:
:
tuple
<
VertexWriter
BindBufferInfo
>
getVertexWriter
(
size_t
requiredBytes
)
;
std
:
:
tuple
<
IndexWriter
BindBufferInfo
>
getIndexWriter
(
size_t
requiredBytes
)
;
std
:
:
tuple
<
UniformWriter
BindBufferInfo
>
getUniformWriter
(
size_t
requiredBytes
)
;
std
:
:
tuple
<
UniformWriter
BindBufferInfo
>
getSsboWriter
(
size_t
requiredBytes
)
;
std
:
:
tuple
<
void
*
BindBufferInfo
>
getMappedStorage
(
size_t
requiredBytes
)
;
BindBufferInfo
getStorage
(
size_t
requiredBytes
)
;
BindBufferInfo
getVertexStorage
(
size_t
requiredBytes
)
;
BindBufferInfo
getIndexStorage
(
size_t
requiredBytes
)
;
BindBufferInfo
getIndirectStorage
(
size_t
requiredBytes
)
;
void
returnVertexBytes
(
size_t
unusedBytes
)
;
size_t
alignUniformBlockSize
(
size_t
dataSize
)
{
return
SkAlignTo
(
dataSize
fCurrentBuffers
[
kUniformBufferIndex
]
.
fStartAlignment
)
;
}
void
transferToRecording
(
Recording
*
)
;
private
:
struct
BufferInfo
{
BufferInfo
(
BufferType
type
size_t
blockSize
const
Caps
*
caps
)
;
const
BufferType
fType
;
const
size_t
fStartAlignment
;
const
size_t
fBlockSize
;
sk_sp
<
Buffer
>
fBuffer
{
}
;
sk_sp
<
Buffer
>
fTransferBuffer
{
}
;
size_t
fOffset
=
0
;
Buffer
*
getMappableBuffer
(
)
{
return
fTransferBuffer
?
fTransferBuffer
.
get
(
)
:
fBuffer
.
get
(
)
;
}
}
;
std
:
:
pair
<
void
*
BindBufferInfo
>
prepareMappedBindBuffer
(
BufferInfo
*
info
size_t
requiredBytes
)
;
BindBufferInfo
prepareBindBuffer
(
BufferInfo
*
info
size_t
requiredBytes
bool
mappable
=
false
)
;
ResourceProvider
*
const
fResourceProvider
;
const
Caps
*
const
fCaps
;
static
constexpr
size_t
kVertexBufferIndex
=
0
;
static
constexpr
size_t
kIndexBufferIndex
=
1
;
static
constexpr
size_t
kUniformBufferIndex
=
2
;
static
constexpr
size_t
kStorageBufferIndex
=
3
;
static
constexpr
size_t
kGpuOnlyStorageBufferIndex
=
4
;
static
constexpr
size_t
kVertexStorageBufferIndex
=
5
;
static
constexpr
size_t
kIndexStorageBufferIndex
=
6
;
static
constexpr
size_t
kIndirectStorageBufferIndex
=
7
;
std
:
:
array
<
BufferInfo
8
>
fCurrentBuffers
;
std
:
:
vector
<
std
:
:
pair
<
sk_sp
<
Buffer
>
sk_sp
<
Buffer
>
>
>
fUsedBuffers
;
}
;
class
StaticBufferManager
{
public
:
StaticBufferManager
(
ResourceProvider
*
const
Caps
*
)
;
~
StaticBufferManager
(
)
;
VertexWriter
getVertexWriter
(
size_t
size
BindBufferInfo
*
binding
)
;
VertexWriter
getIndexWriter
(
size_t
size
BindBufferInfo
*
binding
)
;
enum
class
FinishResult
:
int
{
kFailure
kSuccess
kNoWork
}
;
FinishResult
finalize
(
Context
*
QueueManager
*
GlobalCache
*
)
;
private
:
struct
CopyRange
{
BindBufferInfo
fSource
;
BindBufferInfo
*
fTarget
;
size_t
fSize
;
}
;
struct
BufferInfo
{
BufferInfo
(
BufferType
type
const
Caps
*
caps
)
;
bool
createAndUpdateBindings
(
ResourceProvider
*
Context
*
QueueManager
*
GlobalCache
*
)
const
;
void
reset
(
)
{
fData
.
clear
(
)
;
fTotalRequiredBytes
=
0
;
}
const
BufferType
fBufferType
;
const
size_t
fAlignment
;
std
:
:
vector
<
CopyRange
>
fData
;
size_t
fTotalRequiredBytes
;
}
;
void
*
prepareStaticData
(
BufferInfo
*
info
size_t
requiredBytes
BindBufferInfo
*
target
)
;
ResourceProvider
*
const
fResourceProvider
;
BufferInfo
fVertexBufferInfo
;
BufferInfo
fIndexBufferInfo
;
std
:
:
vector
<
sk_sp
<
Buffer
>
>
fUsedBuffers
;
sk_sp
<
Buffer
>
fCurrentTransferBuffer
;
size_t
fCurrentOffset
;
}
;
}
#
endif
