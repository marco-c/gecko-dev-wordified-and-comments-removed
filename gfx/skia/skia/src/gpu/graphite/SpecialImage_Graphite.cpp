#
include
"
include
/
core
/
SkCanvas
.
h
"
#
include
"
include
/
core
/
SkColorSpace
.
h
"
#
include
"
src
/
core
/
SkSpecialImage
.
h
"
#
include
"
src
/
core
/
SkSpecialSurface
.
h
"
#
include
"
src
/
gpu
/
graphite
/
Image_Graphite
.
h
"
#
include
"
src
/
gpu
/
graphite
/
Surface_Graphite
.
h
"
#
include
"
src
/
shaders
/
SkImageShader
.
h
"
namespace
skgpu
:
:
graphite
{
class
SkSpecialImage_Graphite
final
:
public
SkSpecialImage
{
public
:
SkSpecialImage_Graphite
(
Recorder
*
recorder
const
SkIRect
&
subset
uint32_t
uniqueID
TextureProxyView
view
const
SkColorInfo
&
colorInfo
const
SkSurfaceProps
&
props
)
:
SkSpecialImage
(
subset
uniqueID
colorInfo
props
)
fRecorder
(
recorder
)
fTextureProxyView
(
std
:
:
move
(
view
)
)
{
}
size_t
getSize
(
)
const
override
{
return
0
;
}
void
onDraw
(
SkCanvas
*
canvas
SkScalar
x
SkScalar
y
const
SkSamplingOptions
&
sampling
const
SkPaint
*
paint
)
const
override
{
SkRect
dst
=
SkRect
:
:
MakeXYWH
(
x
y
this
-
>
subset
(
)
.
width
(
)
this
-
>
subset
(
)
.
height
(
)
)
;
sk_sp
<
SkImage
>
img
=
sk_sp
<
SkImage
>
(
new
skgpu
:
:
graphite
:
:
Image
(
this
-
>
uniqueID
(
)
fTextureProxyView
this
-
>
colorInfo
(
)
)
)
;
canvas
-
>
drawImageRect
(
img
SkRect
:
:
Make
(
this
-
>
subset
(
)
)
dst
sampling
paint
SkCanvas
:
:
kStrict_SrcRectConstraint
)
;
}
#
if
defined
(
SK_GANESH
)
GrSurfaceProxyView
onView
(
GrRecordingContext
*
)
const
override
{
SkASSERT
(
false
)
;
return
{
}
;
}
#
endif
TextureProxyView
onTextureProxyView
(
)
const
override
{
return
fTextureProxyView
;
}
bool
onGetROPixels
(
SkBitmap
*
dst
)
const
override
{
return
false
;
}
sk_sp
<
SkSpecialSurface
>
onMakeSurface
(
SkColorType
colorType
const
SkColorSpace
*
colorSpace
const
SkISize
&
size
SkAlphaType
at
const
SkSurfaceProps
&
props
)
const
override
{
SkASSERT
(
fRecorder
)
;
SkImageInfo
ii
=
SkImageInfo
:
:
Make
(
size
colorType
at
sk_ref_sp
(
colorSpace
)
)
;
return
SkSpecialSurface
:
:
MakeGraphite
(
fRecorder
ii
props
)
;
}
sk_sp
<
SkSpecialImage
>
onMakeSubset
(
const
SkIRect
&
subset
)
const
override
{
return
SkSpecialImage
:
:
MakeGraphite
(
fRecorder
subset
this
-
>
uniqueID
(
)
fTextureProxyView
this
-
>
colorInfo
(
)
this
-
>
props
(
)
)
;
}
sk_sp
<
SkImage
>
onAsImage
(
const
SkIRect
*
subset
)
const
override
{
if
(
subset
)
{
return
nullptr
;
}
return
sk_make_sp
<
Image
>
(
this
-
>
uniqueID
(
)
fTextureProxyView
this
-
>
colorInfo
(
)
)
;
}
sk_sp
<
SkShader
>
onAsShader
(
SkTileMode
tileMode
const
SkSamplingOptions
&
sampling
const
SkMatrix
&
lm
)
const
override
{
SkMatrix
subsetOrigin
=
SkMatrix
:
:
Translate
(
-
this
-
>
subset
(
)
.
topLeft
(
)
)
;
subsetOrigin
.
postConcat
(
lm
)
;
const
SkRect
subset
=
SkRect
:
:
Make
(
this
-
>
subset
(
)
)
;
return
SkImageShader
:
:
MakeSubset
(
this
-
>
asImage
(
)
subset
tileMode
tileMode
sampling
&
subsetOrigin
)
;
}
sk_sp
<
SkSurface
>
onMakeTightSurface
(
SkColorType
colorType
const
SkColorSpace
*
colorSpace
const
SkISize
&
size
SkAlphaType
at
)
const
override
{
colorType
=
colorSpace
&
&
colorSpace
-
>
gammaIsLinear
(
)
?
kRGBA_F16_SkColorType
:
kRGBA_8888_SkColorType
;
SkImageInfo
info
=
SkImageInfo
:
:
Make
(
size
colorType
at
sk_ref_sp
(
colorSpace
)
)
;
return
Surface
:
:
MakeGraphite
(
fRecorder
info
skgpu
:
:
Budgeted
:
:
kYes
)
;
}
private
:
Recorder
*
fRecorder
;
TextureProxyView
fTextureProxyView
;
}
;
}
sk_sp
<
SkSpecialImage
>
SkSpecialImage
:
:
MakeGraphite
(
skgpu
:
:
graphite
:
:
Recorder
*
recorder
const
SkIRect
&
subset
uint32_t
uniqueID
skgpu
:
:
graphite
:
:
TextureProxyView
view
const
SkColorInfo
&
colorInfo
const
SkSurfaceProps
&
props
)
{
if
(
!
recorder
|
|
!
view
)
{
return
nullptr
;
}
SkASSERT
(
RectFits
(
subset
view
.
width
(
)
view
.
height
(
)
)
)
;
return
sk_make_sp
<
skgpu
:
:
graphite
:
:
SkSpecialImage_Graphite
>
(
recorder
subset
uniqueID
std
:
:
move
(
view
)
colorInfo
props
)
;
}
