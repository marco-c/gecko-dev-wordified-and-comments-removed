#
ifndef
skgpu_graphite_Caps_DEFINED
#
define
skgpu_graphite_Caps_DEFINED
#
include
"
include
/
core
/
SkImageInfo
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
private
/
base
/
SkAlign
.
h
"
#
include
"
src
/
core
/
SkEnumBitMask
.
h
"
#
include
"
src
/
gpu
/
ResourceKey
.
h
"
#
include
"
src
/
gpu
/
Swizzle
.
h
"
#
include
"
src
/
gpu
/
graphite
/
ResourceTypes
.
h
"
#
include
"
src
/
text
/
gpu
/
SDFTControl
.
h
"
class
SkCapabilities
;
namespace
SkSL
{
struct
ShaderCaps
;
}
namespace
skgpu
{
class
ShaderErrorHandler
;
}
namespace
skgpu
:
:
graphite
{
enum
class
BufferType
:
int
;
struct
ContextOptions
;
class
ComputePipelineDesc
;
class
GraphicsPipelineDesc
;
class
GraphiteResourceKey
;
struct
RenderPassDesc
;
class
TextureInfo
;
class
TextureProxy
;
struct
ResourceBindingRequirements
{
Layout
fUniformBufferLayout
=
Layout
:
:
kInvalid
;
Layout
fStorageBufferLayout
=
Layout
:
:
kInvalid
;
bool
fSeparateTextureAndSamplerBinding
=
false
;
bool
fDistinctIndexRanges
=
false
;
}
;
class
Caps
{
public
:
virtual
~
Caps
(
)
;
const
SkSL
:
:
ShaderCaps
*
shaderCaps
(
)
const
{
return
fShaderCaps
.
get
(
)
;
}
sk_sp
<
SkCapabilities
>
capabilities
(
)
const
;
virtual
TextureInfo
getDefaultSampledTextureInfo
(
SkColorType
Mipmapped
mipmapped
Protected
Renderable
)
const
=
0
;
virtual
TextureInfo
getDefaultMSAATextureInfo
(
const
TextureInfo
&
singleSampledInfo
Discardable
discardable
)
const
=
0
;
virtual
TextureInfo
getDefaultDepthStencilTextureInfo
(
SkEnumBitMask
<
DepthStencilFlags
>
uint32_t
sampleCount
Protected
)
const
=
0
;
virtual
UniqueKey
makeGraphicsPipelineKey
(
const
GraphicsPipelineDesc
&
const
RenderPassDesc
&
)
const
=
0
;
virtual
UniqueKey
makeComputePipelineKey
(
const
ComputePipelineDesc
&
)
const
=
0
;
bool
areColorTypeAndTextureInfoCompatible
(
SkColorType
const
TextureInfo
&
)
const
;
virtual
uint32_t
channelMask
(
const
TextureInfo
&
)
const
=
0
;
bool
isTexturable
(
const
TextureInfo
&
)
const
;
virtual
bool
isRenderable
(
const
TextureInfo
&
)
const
=
0
;
int
maxTextureSize
(
)
const
{
return
fMaxTextureSize
;
}
virtual
void
buildKeyForTexture
(
SkISize
dimensions
const
TextureInfo
&
ResourceType
Shareable
GraphiteResourceKey
*
)
const
=
0
;
virtual
size_t
bytesPerPixel
(
const
TextureInfo
&
)
const
=
0
;
const
ResourceBindingRequirements
&
resourceBindingRequirements
(
)
const
{
return
fResourceBindingReqs
;
}
size_t
requiredUniformBufferAlignment
(
)
const
{
return
fRequiredUniformBufferAlignment
;
}
size_t
requiredStorageBufferAlignment
(
)
const
{
return
fRequiredStorageBufferAlignment
;
}
size_t
requiredTransferBufferAlignment
(
)
const
{
return
fRequiredTransferBufferAlignment
;
}
size_t
getAlignedTextureDataRowBytes
(
size_t
rowBytes
)
const
{
return
SkAlignTo
(
rowBytes
fTextureDataRowBytesAlignment
)
;
}
virtual
bool
supportsWritePixels
(
const
TextureInfo
&
textureInfo
)
const
=
0
;
virtual
bool
supportsReadPixels
(
const
TextureInfo
&
textureInfo
)
const
=
0
;
virtual
SkColorType
supportedWritePixelsColorType
(
SkColorType
dstColorType
const
TextureInfo
&
dstTextureInfo
SkColorType
srcColorType
)
const
=
0
;
virtual
SkColorType
supportedReadPixelsColorType
(
SkColorType
srcColorType
const
TextureInfo
&
srcTextureInfo
SkColorType
dstColorType
)
const
=
0
;
bool
clampToBorderSupport
(
)
const
{
return
fClampToBorderSupport
;
}
bool
protectedSupport
(
)
const
{
return
fProtectedSupport
;
}
bool
storageBufferSupport
(
)
const
{
return
fStorageBufferSupport
;
}
bool
storageBufferPreferred
(
)
const
{
return
fStorageBufferPreferred
;
}
bool
drawBufferCanBeMapped
(
)
const
{
return
fDrawBufferCanBeMapped
;
}
skgpu
:
:
Swizzle
getReadSwizzle
(
SkColorType
const
TextureInfo
&
)
const
;
skgpu
:
:
Swizzle
getWriteSwizzle
(
SkColorType
const
TextureInfo
&
)
const
;
skgpu
:
:
ShaderErrorHandler
*
shaderErrorHandler
(
)
const
{
return
fShaderErrorHandler
;
}
float
minDistanceFieldFontSize
(
)
const
{
return
fMinDistanceFieldFontSize
;
}
float
glyphsAsPathsFontSize
(
)
const
{
return
fGlyphsAsPathsFontSize
;
}
size_t
glyphCacheTextureMaximumBytes
(
)
const
{
return
fGlyphCacheTextureMaximumBytes
;
}
bool
allowMultipleGlyphCacheTextures
(
)
const
{
return
fAllowMultipleGlyphCacheTextures
;
}
bool
supportBilerpFromGlyphAtlas
(
)
const
{
return
fSupportBilerpFromGlyphAtlas
;
}
sktext
:
:
gpu
:
:
SDFTControl
getSDFTControl
(
bool
useSDFTForSmallText
)
const
;
protected
:
Caps
(
)
;
void
finishInitialization
(
const
ContextOptions
&
)
;
uint32_t
defaultMSAASamples
(
)
const
{
return
4
;
}
static
inline
uint32_t
SamplesToKey
(
uint32_t
numSamples
)
{
switch
(
numSamples
)
{
case
1
:
return
0
;
case
2
:
return
1
;
case
4
:
return
2
;
case
8
:
return
3
;
case
16
:
return
4
;
default
:
SkUNREACHABLE
;
}
}
struct
ColorTypeInfo
{
SkColorType
fColorType
=
kUnknown_SkColorType
;
SkColorType
fTransferColorType
=
kUnknown_SkColorType
;
enum
{
kUploadData_Flag
=
0x1
kRenderable_Flag
=
0x2
}
;
uint32_t
fFlags
=
0
;
skgpu
:
:
Swizzle
fReadSwizzle
;
skgpu
:
:
Swizzle
fWriteSwizzle
;
}
;
int
fMaxTextureSize
=
0
;
size_t
fRequiredUniformBufferAlignment
=
0
;
size_t
fRequiredStorageBufferAlignment
=
0
;
size_t
fRequiredTransferBufferAlignment
=
0
;
size_t
fTextureDataRowBytesAlignment
=
1
;
std
:
:
unique_ptr
<
SkSL
:
:
ShaderCaps
>
fShaderCaps
;
bool
fClampToBorderSupport
=
true
;
bool
fProtectedSupport
=
false
;
bool
fStorageBufferSupport
=
false
;
bool
fStorageBufferPreferred
=
false
;
bool
fDrawBufferCanBeMapped
=
true
;
ResourceBindingRequirements
fResourceBindingReqs
;
ShaderErrorHandler
*
fShaderErrorHandler
=
nullptr
;
#
if
GRAPHITE_TEST_UTILS
int
fMaxTextureAtlasSize
=
2048
;
#
endif
size_t
fGlyphCacheTextureMaximumBytes
=
2048
*
1024
*
4
;
float
fMinDistanceFieldFontSize
=
18
;
float
fGlyphsAsPathsFontSize
=
324
;
bool
fAllowMultipleGlyphCacheTextures
=
true
;
bool
fSupportBilerpFromGlyphAtlas
=
false
;
private
:
virtual
bool
onIsTexturable
(
const
TextureInfo
&
)
const
=
0
;
virtual
const
ColorTypeInfo
*
getColorTypeInfo
(
SkColorType
const
TextureInfo
&
)
const
=
0
;
sk_sp
<
SkCapabilities
>
fCapabilities
;
}
;
}
#
endif
