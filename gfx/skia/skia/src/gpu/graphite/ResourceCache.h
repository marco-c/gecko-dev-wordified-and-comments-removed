#
ifndef
skgpu_graphite_ResourceCache_DEFINED
#
define
skgpu_graphite_ResourceCache_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
private
/
base
/
SkMutex
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
src
/
base
/
SkTDPQueue
.
h
"
#
include
"
src
/
core
/
SkTHash
.
h
"
#
include
"
src
/
core
/
SkTMultiMap
.
h
"
#
include
"
src
/
gpu
/
graphite
/
ResourceTypes
.
h
"
#
include
<
vector
>
namespace
skgpu
{
class
SingleOwner
;
}
namespace
skgpu
:
:
graphite
{
class
GraphiteResourceKey
;
class
Resource
;
class
ResourceCache
:
public
SkRefCnt
{
public
:
static
sk_sp
<
ResourceCache
>
Make
(
SingleOwner
*
)
;
~
ResourceCache
(
)
override
;
ResourceCache
(
const
ResourceCache
&
)
=
delete
;
ResourceCache
(
ResourceCache
&
&
)
=
delete
;
ResourceCache
&
operator
=
(
const
ResourceCache
&
)
=
delete
;
ResourceCache
&
operator
=
(
ResourceCache
&
&
)
=
delete
;
int
getResourceCount
(
)
const
{
return
fPurgeableQueue
.
count
(
)
+
fNonpurgeableResources
.
size
(
)
;
}
void
insertResource
(
Resource
*
)
;
Resource
*
findAndRefResource
(
const
GraphiteResourceKey
&
key
skgpu
:
:
Budgeted
)
;
bool
returnResource
(
Resource
*
LastRemovedRef
)
;
void
shutdown
(
)
;
#
if
GRAPHITE_TEST_UTILS
void
forceProcessReturnedResources
(
)
{
this
-
>
processReturnedResources
(
)
;
}
int
numFindableResources
(
)
const
;
#
endif
private
:
ResourceCache
(
SingleOwner
*
)
;
void
refAndMakeResourceMRU
(
Resource
*
)
;
void
addToNonpurgeableArray
(
Resource
*
resource
)
;
void
removeFromNonpurgeableArray
(
Resource
*
resource
)
;
void
removeFromPurgeableQueue
(
Resource
*
resource
)
;
void
processReturnedResources
(
)
;
void
returnResourceToCache
(
Resource
*
LastRemovedRef
)
;
uint32_t
getNextTimestamp
(
)
;
bool
inPurgeableQueue
(
Resource
*
)
const
;
#
ifdef
SK_DEBUG
bool
isInCache
(
const
Resource
*
r
)
const
;
void
validate
(
)
const
;
#
else
void
validate
(
)
const
{
}
#
endif
struct
MapTraits
{
static
const
GraphiteResourceKey
&
GetKey
(
const
Resource
&
r
)
;
static
uint32_t
Hash
(
const
GraphiteResourceKey
&
key
)
;
static
void
OnFree
(
Resource
*
)
{
}
}
;
typedef
SkTMultiMap
<
Resource
GraphiteResourceKey
MapTraits
>
ResourceMap
;
static
bool
CompareTimestamp
(
Resource
*
const
&
a
Resource
*
const
&
b
)
;
static
int
*
AccessResourceIndex
(
Resource
*
const
&
res
)
;
using
PurgeableQueue
=
SkTDPQueue
<
Resource
*
CompareTimestamp
AccessResourceIndex
>
;
using
ResourceArray
=
SkTDArray
<
Resource
*
>
;
uint32_t
fTimestamp
=
0
;
PurgeableQueue
fPurgeableQueue
;
ResourceArray
fNonpurgeableResources
;
SkDEBUGCODE
(
int
fCount
=
0
;
)
ResourceMap
fResourceMap
;
SingleOwner
*
fSingleOwner
=
nullptr
;
bool
fIsShutdown
=
false
;
SkMutex
fReturnMutex
;
using
ReturnQueue
=
std
:
:
vector
<
std
:
:
pair
<
Resource
*
LastRemovedRef
>
>
;
ReturnQueue
fReturnQueue
SK_GUARDED_BY
(
fReturnMutex
)
;
}
;
}
#
endif
