#
include
"
src
/
gpu
/
graphite
/
render
/
AnalyticRRectRenderStep
.
h
"
#
include
"
src
/
base
/
SkVx
.
h
"
#
include
"
src
/
core
/
SkRRectPriv
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawParams
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawWriter
.
h
"
#
include
"
src
/
gpu
/
graphite
/
render
/
CommonDepthStencilSettings
.
h
"
namespace
skgpu
:
:
graphite
{
using
AAFlags
=
EdgeAAQuad
:
:
Flags
;
static
skvx
:
:
float4
load_x_radii
(
const
SkRRect
&
rrect
)
{
return
skvx
:
:
float4
{
rrect
.
radii
(
SkRRect
:
:
kUpperLeft_Corner
)
.
fX
rrect
.
radii
(
SkRRect
:
:
kUpperRight_Corner
)
.
fX
rrect
.
radii
(
SkRRect
:
:
kLowerRight_Corner
)
.
fX
rrect
.
radii
(
SkRRect
:
:
kLowerLeft_Corner
)
.
fX
}
;
}
static
skvx
:
:
float4
load_y_radii
(
const
SkRRect
&
rrect
)
{
return
skvx
:
:
float4
{
rrect
.
radii
(
SkRRect
:
:
kUpperLeft_Corner
)
.
fY
rrect
.
radii
(
SkRRect
:
:
kUpperRight_Corner
)
.
fY
rrect
.
radii
(
SkRRect
:
:
kLowerRight_Corner
)
.
fY
rrect
.
radii
(
SkRRect
:
:
kLowerLeft_Corner
)
.
fY
}
;
}
static
float
local_aa_radius
(
const
Transform
&
t
const
SkV2
&
p
)
{
const
SkM44
&
matrix
=
t
.
matrix
(
)
;
SkV4
devP
=
matrix
.
map
(
p
.
x
p
.
y
0
.
f
1
.
f
)
;
const
float
dxdu
=
matrix
.
rc
(
0
0
)
;
const
float
dxdv
=
matrix
.
rc
(
0
1
)
;
const
float
dydu
=
matrix
.
rc
(
1
0
)
;
const
float
dydv
=
matrix
.
rc
(
1
1
)
;
const
float
dwdu
=
matrix
.
rc
(
3
0
)
;
const
float
dwdv
=
matrix
.
rc
(
3
1
)
;
float
invW2
=
sk_ieee_float_divide
(
1
.
f
(
devP
.
w
*
devP
.
w
)
)
;
float
dfdu
=
(
devP
.
w
*
dxdu
-
devP
.
x
*
dwdu
)
*
invW2
;
float
dfdv
=
(
devP
.
w
*
dxdv
-
devP
.
x
*
dwdv
)
*
invW2
;
float
dgdu
=
(
devP
.
w
*
dydu
-
devP
.
y
*
dwdu
)
*
invW2
;
float
dgdv
=
(
devP
.
w
*
dydv
-
devP
.
y
*
dwdv
)
*
invW2
;
float
s1
=
dfdu
*
dfdu
+
dfdv
*
dfdv
+
dgdu
*
dgdu
+
dgdv
*
dgdv
;
float
e
=
dfdu
*
dfdu
+
dfdv
*
dfdv
-
dgdu
*
dgdu
-
dgdv
*
dgdv
;
float
f
=
dfdu
*
dgdu
+
dfdv
*
dgdv
;
float
s2
=
SkScalarSqrt
(
e
*
e
+
4
*
f
*
f
)
;
float
singular1
=
SkScalarSqrt
(
0
.
5f
*
(
s1
+
s2
)
)
;
float
singular2
=
SkScalarSqrt
(
0
.
5f
*
(
s1
-
s2
)
)
;
float
aaRadius
=
sk_ieee_float_divide
(
1
.
f
std
:
:
min
(
singular1
singular2
)
)
;
if
(
sk_float_isfinite
(
aaRadius
)
)
{
return
aaRadius
;
}
else
{
return
SK_FloatInfinity
;
}
}
static
float
local_aa_radius
(
const
Transform
&
t
const
Rect
&
bounds
)
{
if
(
t
.
type
(
)
<
Transform
:
:
Type
:
:
kProjection
)
{
return
local_aa_radius
(
t
SkV2
{
0
.
f
0
.
f
}
)
;
}
else
{
float
tl
=
local_aa_radius
(
t
SkV2
{
bounds
.
left
(
)
bounds
.
top
(
)
}
)
;
float
tr
=
local_aa_radius
(
t
SkV2
{
bounds
.
right
(
)
bounds
.
top
(
)
}
)
;
float
br
=
local_aa_radius
(
t
SkV2
{
bounds
.
right
(
)
bounds
.
bot
(
)
}
)
;
float
bl
=
local_aa_radius
(
t
SkV2
{
bounds
.
left
(
)
bounds
.
bot
(
)
}
)
;
return
std
:
:
max
(
std
:
:
max
(
tl
tr
)
std
:
:
max
(
bl
br
)
)
;
}
}
static
bool
opposite_insets_intersect
(
const
SkRRect
&
rrect
float
strokeRadius
float
aaRadius
)
{
const
float
maxInset
=
strokeRadius
+
2
.
f
*
aaRadius
;
return
maxInset
>
=
rrect
.
width
(
)
-
rrect
.
radii
(
SkRRect
:
:
kLowerLeft_Corner
)
.
fX
|
|
maxInset
>
=
rrect
.
width
(
)
-
rrect
.
radii
(
SkRRect
:
:
kLowerRight_Corner
)
.
fX
|
|
maxInset
>
=
rrect
.
width
(
)
-
rrect
.
radii
(
SkRRect
:
:
kUpperLeft_Corner
)
.
fX
|
|
maxInset
>
=
rrect
.
width
(
)
-
rrect
.
radii
(
SkRRect
:
:
kUpperRight_Corner
)
.
fX
|
|
maxInset
>
=
rrect
.
height
(
)
-
rrect
.
radii
(
SkRRect
:
:
kLowerLeft_Corner
)
.
fY
|
|
maxInset
>
=
rrect
.
height
(
)
-
rrect
.
radii
(
SkRRect
:
:
kLowerRight_Corner
)
.
fY
|
|
maxInset
>
=
rrect
.
height
(
)
-
rrect
.
radii
(
SkRRect
:
:
kUpperLeft_Corner
)
.
fY
|
|
maxInset
>
=
rrect
.
height
(
)
-
rrect
.
radii
(
SkRRect
:
:
kUpperRight_Corner
)
.
fY
;
}
static
bool
opposite_insets_intersect
(
const
Rect
&
rect
float
strokeRadius
float
aaRadius
)
{
return
any
(
rect
.
size
(
)
<
=
2
.
f
*
(
strokeRadius
+
aaRadius
)
)
;
}
static
bool
opposite_insets_intersect
(
const
Geometry
&
geometry
float
strokeRadius
float
aaRadius
)
{
if
(
geometry
.
isEdgeAAQuad
(
)
)
{
SkASSERT
(
strokeRadius
=
=
0
.
f
)
;
const
EdgeAAQuad
&
quad
=
geometry
.
edgeAAQuad
(
)
;
if
(
quad
.
edgeFlags
(
)
=
=
AAFlags
:
:
kNone
)
{
return
false
;
}
else
if
(
quad
.
isRect
(
)
&
&
quad
.
edgeFlags
(
)
=
=
AAFlags
:
:
kAll
)
{
return
opposite_insets_intersect
(
quad
.
bounds
(
)
0
.
f
aaRadius
)
;
}
else
{
return
true
;
}
}
else
{
const
Shape
&
shape
=
geometry
.
shape
(
)
;
if
(
shape
.
isRect
(
)
)
{
return
opposite_insets_intersect
(
shape
.
rect
(
)
strokeRadius
aaRadius
)
;
}
else
{
SkASSERT
(
shape
.
isRRect
(
)
)
;
return
opposite_insets_intersect
(
shape
.
rrect
(
)
strokeRadius
aaRadius
)
;
}
}
}
static
bool
is_clockwise
(
const
EdgeAAQuad
&
quad
)
{
if
(
quad
.
isRect
(
)
)
{
return
true
;
}
const
skvx
:
:
float4
&
xs
=
quad
.
xs
(
)
;
const
skvx
:
:
float4
&
ys
=
quad
.
ys
(
)
;
float
winding
=
(
xs
[
0
]
-
xs
[
3
]
)
*
(
ys
[
1
]
-
ys
[
0
]
)
-
(
ys
[
0
]
-
ys
[
3
]
)
*
(
xs
[
1
]
-
xs
[
0
]
)
;
if
(
winding
=
=
0
.
f
)
{
winding
=
(
xs
[
2
]
-
xs
[
1
]
)
*
(
ys
[
3
]
-
ys
[
2
]
)
-
(
ys
[
2
]
-
ys
[
1
]
)
*
(
xs
[
3
]
-
xs
[
2
]
)
;
}
return
winding
>
=
0
.
f
;
}
static
skvx
:
:
float2
quad_center
(
const
EdgeAAQuad
&
quad
)
{
return
skvx
:
:
float2
(
dot
(
quad
.
xs
(
)
skvx
:
:
float4
(
0
.
25f
)
)
dot
(
quad
.
ys
(
)
skvx
:
:
float4
(
0
.
25f
)
)
)
;
}
struct
Vertex
{
SkV2
fPosition
;
SkV2
fNormal
;
float
fNormalScale
;
float
fCenterWeight
;
}
;
static
constexpr
float
kSolidInterior
=
1
.
f
;
static
constexpr
float
kStrokeInterior
=
0
.
f
;
static
constexpr
float
kFilledStrokeInterior
=
-
1
.
f
;
static
constexpr
float
kComplexAAInsets
=
-
1
.
f
;
static
constexpr
int
kCornerVertexCount
=
9
;
static
constexpr
int
kVertexCount
=
4
*
kCornerVertexCount
;
static
constexpr
int
kIndexCount
=
69
;
static
void
write_index_buffer
(
VertexWriter
writer
)
{
static
constexpr
uint16_t
kTL
=
0
*
kCornerVertexCount
;
static
constexpr
uint16_t
kTR
=
1
*
kCornerVertexCount
;
static
constexpr
uint16_t
kBR
=
2
*
kCornerVertexCount
;
static
constexpr
uint16_t
kBL
=
3
*
kCornerVertexCount
;
static
const
uint16_t
kIndices
[
kIndexCount
]
=
{
kTL
+
0
kTL
+
4
kTL
+
1
kTL
+
5
kTL
+
2
kTL
+
3
kTL
+
5
kTR
+
0
kTR
+
4
kTR
+
1
kTR
+
5
kTR
+
2
kTR
+
3
kTR
+
5
kBR
+
0
kBR
+
4
kBR
+
1
kBR
+
5
kBR
+
2
kBR
+
3
kBR
+
5
kBL
+
0
kBL
+
4
kBL
+
1
kBL
+
5
kBL
+
2
kBL
+
3
kBL
+
5
kTL
+
0
kTL
+
4
kTL
+
4
kTL
+
6
kTL
+
5
kTL
+
7
kTR
+
4
kTR
+
6
kTR
+
5
kTR
+
7
kBR
+
4
kBR
+
6
kBR
+
5
kBR
+
7
kBL
+
4
kBL
+
6
kBL
+
5
kBL
+
7
kTL
+
4
kTL
+
6
kTL
+
6
kTL
+
8
kTL
+
7
kTL
+
7
kTR
+
8
kTR
+
6
kTR
+
8
kTR
+
7
kTR
+
7
kBR
+
8
kBR
+
6
kBR
+
8
kBR
+
7
kBR
+
7
kBL
+
8
kBL
+
6
kBL
+
8
kBL
+
7
kBL
+
7
kTL
+
8
kTL
+
6
}
;
writer
<
<
kIndices
;
}
static
void
write_vertex_buffer
(
VertexWriter
writer
)
{
static
constexpr
float
kOutset
=
1
.
0
;
static
constexpr
float
kInset
=
-
1
.
0
;
static
constexpr
float
kCenter
=
1
.
f
;
static
constexpr
float
_______
=
0
.
f
;
static
constexpr
float
kHR2
=
0
.
5f
*
SK_FloatSqrt2
;
static
constexpr
Vertex
kCornerTemplate
[
kCornerVertexCount
]
=
{
{
{
1
.
0f
0
.
0f
}
{
1
.
0f
0
.
0f
}
kOutset
_______
}
{
{
1
.
0f
0
.
0f
}
{
kHR2
kHR2
}
kOutset
_______
}
{
{
0
.
0f
1
.
0f
}
{
kHR2
kHR2
}
kOutset
_______
}
{
{
0
.
0f
1
.
0f
}
{
0
.
0f
1
.
0f
}
kOutset
_______
}
{
{
1
.
0f
0
.
0f
}
{
kHR2
kHR2
}
_______
_______
}
{
{
0
.
0f
1
.
0f
}
{
kHR2
kHR2
}
_______
_______
}
{
{
1
.
0f
0
.
0f
}
{
1
.
0f
0
.
0f
}
kInset
_______
}
{
{
0
.
0f
1
.
0f
}
{
0
.
0f
1
.
0f
}
kInset
_______
}
{
{
1
.
0f
0
.
0f
}
{
1
.
0f
0
.
0f
}
kInset
kCenter
}
}
;
writer
<
<
kCornerTemplate
<
<
kCornerTemplate
<
<
kCornerTemplate
<
<
kCornerTemplate
;
}
AnalyticRRectRenderStep
:
:
AnalyticRRectRenderStep
(
StaticBufferManager
*
bufferManager
)
:
RenderStep
(
"
AnalyticRRectRenderStep
"
"
"
Flags
:
:
kPerformsShading
|
Flags
:
:
kEmitsCoverage
{
}
PrimitiveType
:
:
kTriangleStrip
kDirectDepthGreaterPass
{
{
"
position
"
VertexAttribType
:
:
kFloat2
SkSLType
:
:
kFloat2
}
{
"
normal
"
VertexAttribType
:
:
kFloat2
SkSLType
:
:
kFloat2
}
{
"
normalScale
"
VertexAttribType
:
:
kFloat
SkSLType
:
:
kFloat
}
{
"
centerWeight
"
VertexAttribType
:
:
kFloat
SkSLType
:
:
kFloat
}
}
{
{
"
xRadiiOrFlags
"
VertexAttribType
:
:
kFloat4
SkSLType
:
:
kFloat4
}
{
"
radiiOrQuadXs
"
VertexAttribType
:
:
kFloat4
SkSLType
:
:
kFloat4
}
{
"
ltrbOrQuadYs
"
VertexAttribType
:
:
kFloat4
SkSLType
:
:
kFloat4
}
{
"
center
"
VertexAttribType
:
:
kFloat4
SkSLType
:
:
kFloat4
}
{
"
depth
"
VertexAttribType
:
:
kFloat
SkSLType
:
:
kFloat
}
{
"
ssboIndex
"
VertexAttribType
:
:
kInt
SkSLType
:
:
kInt
}
{
"
mat0
"
VertexAttribType
:
:
kFloat3
SkSLType
:
:
kFloat3
}
{
"
mat1
"
VertexAttribType
:
:
kFloat3
SkSLType
:
:
kFloat3
}
{
"
mat2
"
VertexAttribType
:
:
kFloat3
SkSLType
:
:
kFloat3
}
}
{
{
"
jacobian
"
SkSLType
:
:
kFloat4
}
{
"
edgeDistances
"
SkSLType
:
:
kFloat4
}
{
"
xRadii
"
SkSLType
:
:
kFloat4
}
{
"
yRadii
"
SkSLType
:
:
kFloat4
}
{
"
strokeParams
"
SkSLType
:
:
kFloat2
}
{
"
perPixelControl
"
SkSLType
:
:
kFloat2
}
}
)
{
write_vertex_buffer
(
bufferManager
-
>
getVertexWriter
(
sizeof
(
Vertex
)
*
kVertexCount
&
fVertexBuffer
)
)
;
write_index_buffer
(
bufferManager
-
>
getIndexWriter
(
sizeof
(
uint16_t
)
*
kIndexCount
&
fIndexBuffer
)
)
;
}
AnalyticRRectRenderStep
:
:
~
AnalyticRRectRenderStep
(
)
{
}
std
:
:
string
AnalyticRRectRenderStep
:
:
vertexSkSL
(
)
const
{
return
R
"
(
const
int
kCornerVertexCount
=
9
;
/
/
KEEP
IN
SYNC
WITH
C
+
+
'
s
kCornerVertexCount
const
float
kMiterScale
=
1
.
0
;
const
float
kBevelScale
=
0
.
0
;
const
float
kRoundScale
=
0
.
41421356237
;
/
/
sqrt
(
2
)
-
1
const
float
kEpsilon
=
0
.
00024
;
/
/
SK_ScalarNearlyZero
/
/
Default
to
miter
'
ed
vertex
positioning
.
Corners
with
sufficiently
large
corner
radii
or
/
/
bevel
'
ed
strokes
will
adjust
vertex
placement
on
a
per
corner
basis
.
This
will
not
affect
/
/
the
final
coverage
calculations
in
the
fragment
shader
.
float
joinScale
=
kMiterScale
;
/
/
Unpack
instance
-
level
state
that
determines
the
vertex
placement
and
style
of
shape
.
bool
bidirectionalCoverage
=
center
.
z
<
=
0
.
0
;
bool
deviceSpaceDistances
=
false
;
float4
xs
ys
;
/
/
ordered
TL
TR
BR
BL
float4
edgeAA
=
float4
(
1
.
0
)
;
/
/
ordered
L
T
R
B
.
1
=
AA
0
=
no
AA
if
(
xRadiiOrFlags
.
x
<
-
1
.
0
)
{
/
/
Stroked
rect
or
round
rect
xs
=
ltrbOrQuadYs
.
LRRL
;
ys
=
ltrbOrQuadYs
.
TTBB
;
if
(
xRadiiOrFlags
.
y
<
0
.
0
)
{
/
/
A
hairline
so
the
X
radii
are
encoded
as
negative
values
in
this
field
and
Y
/
/
radii
are
stored
directly
in
the
subsequent
float4
.
xRadii
=
-
xRadiiOrFlags
-
2
.
0
;
yRadii
=
radiiOrQuadXs
;
/
/
All
hairlines
use
miter
joins
(
join
style
>
0
)
strokeParams
=
float2
(
0
.
0
1
.
0
)
;
}
else
{
xRadii
=
radiiOrQuadXs
;
yRadii
=
xRadii
;
/
/
regular
strokes
are
circular
strokeParams
=
xRadiiOrFlags
.
zw
;
if
(
strokeParams
.
y
<
0
.
0
)
{
joinScale
=
kRoundScale
;
/
/
the
stroke
radius
rounds
rectangular
corners
}
else
if
(
strokeParams
.
y
=
=
0
.
0
)
{
joinScale
=
kBevelScale
;
}
/
/
else
stay
mitered
}
}
else
if
(
any
(
greaterThan
(
xRadiiOrFlags
float4
(
0
.
0
)
)
)
)
{
/
/
Filled
round
rect
xs
=
ltrbOrQuadYs
.
LRRL
;
ys
=
ltrbOrQuadYs
.
TTBB
;
xRadii
=
xRadiiOrFlags
;
yRadii
=
radiiOrQuadXs
;
strokeParams
=
float2
(
0
.
0
-
1
.
0
)
;
/
/
A
negative
join
style
is
"
round
"
}
else
{
/
/
Per
-
edge
quadrilateral
so
we
have
to
calculate
the
corner
'
s
basis
from
the
/
/
quad
'
s
edges
.
xs
=
radiiOrQuadXs
;
ys
=
ltrbOrQuadYs
;
edgeAA
=
-
xRadiiOrFlags
;
/
/
AA
flags
needed
to
be
<
0
on
upload
so
flip
the
sign
.
xRadii
=
float4
(
0
.
0
)
;
yRadii
=
float4
(
0
.
0
)
;
strokeParams
=
float2
(
0
.
0
1
.
0
)
;
/
/
Will
be
ignored
but
set
to
a
"
miter
"
deviceSpaceDistances
=
true
;
}
/
/
Adjust
state
on
a
per
-
corner
basis
int
cornerID
=
sk_VertexID
/
kCornerVertexCount
;
float
strokeRadius
=
strokeParams
.
x
;
/
/
alias
float2
cornerRadii
=
float2
(
xRadii
[
cornerID
]
yRadii
[
cornerID
]
)
;
if
(
cornerID
%
2
!
=
0
)
{
/
/
Corner
radii
are
uploaded
in
the
local
coordinate
frame
but
vertex
placement
happens
/
/
in
a
consistent
winding
before
transforming
to
final
local
coords
so
swap
the
/
/
radii
for
odd
corners
.
cornerRadii
=
cornerRadii
.
yx
;
}
float2
cornerAspectRatio
=
float2
(
1
.
0
)
;
if
(
cornerRadii
.
x
>
kEpsilon
&
&
cornerRadii
.
y
>
kEpsilon
)
{
/
/
Position
vertices
for
an
elliptical
corner
;
overriding
any
previous
join
style
since
/
/
that
only
applies
when
radii
are
0
.
joinScale
=
kRoundScale
;
cornerAspectRatio
=
cornerRadii
.
yx
;
}
else
if
(
cornerRadii
.
x
!
=
0
&
&
cornerRadii
.
y
!
=
0
)
{
/
/
A
very
small
rounded
corner
which
technically
ignores
style
(
i
.
e
.
should
not
be
/
/
beveled
or
mitered
)
but
place
the
vertices
as
a
miter
to
fully
cover
it
and
let
/
/
the
fragment
shader
evaluate
the
curve
per
pixel
.
joinScale
=
kMiterScale
;
cornerAspectRatio
=
cornerRadii
.
yx
;
cornerRadii
=
float2
(
0
.
0
)
;
}
else
if
(
strokeRadius
>
0
.
0
&
&
strokeRadius
<
=
kEpsilon
)
{
/
/
A
stroked
rectangular
corner
that
could
have
a
very
small
bevel
or
round
join
/
/
so
place
vertices
as
a
miter
.
joinScale
=
kMiterScale
;
}
/
/
Calculate
the
local
edge
vectors
ordered
L
T
R
B
starting
from
the
bottom
left
point
.
/
/
For
quadrilaterals
these
are
not
necessarily
axis
-
aligned
but
in
all
cases
they
orient
/
/
the
+
X
/
+
Y
normalized
vertex
template
for
each
corner
.
float4
dx
=
xs
-
xs
.
wxyz
;
float4
dy
=
ys
-
ys
.
wxyz
;
float4
edgeLen
=
sqrt
(
dx
*
dx
+
dy
*
dy
)
;
float4
edgeMask
=
sign
(
edgeLen
)
;
/
/
0
for
zero
-
length
edge
1
for
non
-
zero
edge
.
if
(
any
(
equal
(
edgeMask
float4
(
0
.
0
)
)
)
)
{
/
/
Must
clean
up
(
dx
dy
)
depending
on
the
empty
edge
configuration
if
(
all
(
equal
(
edgeMask
float4
(
0
.
0
)
)
)
)
{
/
/
A
point
so
use
the
canonical
basis
dx
=
float4
(
0
.
0
1
.
0
0
.
0
-
1
.
0
)
;
dy
=
float4
(
-
1
.
0
0
.
0
1
.
0
0
.
0
)
;
edgeLen
=
float4
(
1
.
0
)
;
}
else
{
/
/
Triangles
(
3
non
-
zero
edges
)
copy
the
adjacent
edge
.
Otherwise
it
'
s
a
line
so
/
/
replace
empty
edges
with
the
left
-
hand
normal
vector
of
the
adjacent
edge
.
bool
triangle
=
(
edgeMask
[
0
]
+
edgeMask
[
1
]
+
edgeMask
[
2
]
+
edgeMask
[
3
]
)
>
2
.
5
;
float4
edgeX
=
triangle
?
dx
.
yzwx
:
dy
.
yzwx
;
float4
edgeY
=
triangle
?
dy
.
yzwx
:
-
dx
.
yzwx
;
dx
=
mix
(
edgeX
dx
edgeMask
)
;
dy
=
mix
(
edgeY
dy
edgeMask
)
;
edgeLen
=
mix
(
edgeLen
.
yzwx
edgeLen
edgeMask
)
;
edgeAA
=
mix
(
edgeAA
.
yzwx
edgeAA
edgeMask
)
;
}
}
dx
/
=
edgeLen
;
dy
/
=
edgeLen
;
/
/
Calculate
local
coordinate
for
the
vertex
(
relative
to
xAxis
and
yAxis
at
first
)
.
float2
xAxis
=
-
float2
(
dx
.
yzwx
[
cornerID
]
dy
.
yzwx
[
cornerID
]
)
;
float2
yAxis
=
float2
(
dx
.
xyzw
[
cornerID
]
dy
.
xyzw
[
cornerID
]
)
;
float2
localPos
;
bool
snapToCenter
=
false
;
if
(
normalScale
<
0
.
0
)
{
/
/
Vertex
is
inset
from
the
base
shape
so
we
scale
by
(
cornerRadii
-
strokeRadius
)
/
/
and
have
to
check
for
the
possibility
of
an
inner
miter
.
It
is
always
inset
by
an
/
/
additional
conservative
AA
amount
.
if
(
center
.
w
<
0
.
0
|
|
centerWeight
*
center
.
z
!
=
0
.
0
)
{
snapToCenter
=
true
;
}
else
{
float
localAARadius
=
center
.
w
;
float2
insetRadii
=
cornerRadii
+
(
bidirectionalCoverage
?
-
strokeRadius
:
strokeRadius
)
;
if
(
joinScale
=
=
kMiterScale
|
|
insetRadii
.
x
<
=
localAARadius
|
|
insetRadii
.
y
<
=
localAARadius
)
{
/
/
Miter
the
inset
position
localPos
=
(
insetRadii
-
localAARadius
)
;
}
else
{
localPos
=
insetRadii
*
position
-
localAARadius
*
normal
;
}
}
}
else
{
/
/
Vertex
is
outset
from
the
base
shape
(
and
possibly
with
an
additional
AA
outset
later
/
/
in
device
space
)
.
localPos
=
(
cornerRadii
+
strokeRadius
)
*
(
position
+
joinScale
*
position
.
yx
)
;
}
if
(
snapToCenter
)
{
/
/
Center
is
already
relative
to
true
local
coords
not
the
corner
basis
.
localPos
=
center
.
xy
;
}
else
{
/
/
Transform
from
corner
basis
to
true
local
coords
.
localPos
-
=
cornerRadii
;
localPos
=
float2
(
xs
[
cornerID
]
ys
[
cornerID
]
)
+
xAxis
*
localPos
.
x
+
yAxis
*
localPos
.
y
;
}
/
/
Calculate
edge
distances
and
device
space
coordinate
for
the
vertex
/
/
TODO
:
Apply
edge
AA
flags
to
these
values
to
turn
off
AA
when
necessary
.
edgeDistances
=
dy
*
(
xs
-
localPos
.
x
)
-
dx
*
(
ys
-
localPos
.
y
)
;
float3x3
localToDevice
=
float3x3
(
mat0
mat1
mat2
)
;
/
/
NOTE
:
This
3x3
inverse
is
different
than
just
taking
the
1st
two
columns
of
the
4x4
/
/
inverse
of
the
original
SkM44
local
-
to
-
device
matrix
.
We
could
calculate
the
3x3
inverse
/
/
and
upload
it
but
it
does
not
seem
to
be
a
bottleneck
and
saves
on
bandwidth
to
/
/
calculate
it
here
instead
.
float3x3
deviceToLocal
=
inverse
(
localToDevice
)
;
float3
devPos
=
localToDevice
*
localPos
.
xy1
;
jacobian
=
float4
(
deviceToLocal
[
0
]
.
xy
-
deviceToLocal
[
0
]
.
z
*
localPos
deviceToLocal
[
1
]
.
xy
-
deviceToLocal
[
1
]
.
z
*
localPos
)
;
if
(
deviceSpaceDistances
)
{
/
/
Apply
the
Jacobian
in
the
vertex
shader
so
any
quadrilateral
normals
do
not
have
to
/
/
be
passed
to
the
fragment
shader
.
However
it
'
s
important
to
use
the
Jacobian
at
a
/
/
vertex
on
the
edge
not
the
current
vertex
'
s
Jacobian
.
float4
gx
=
-
dy
*
(
deviceToLocal
[
0
]
.
x
-
deviceToLocal
[
0
]
.
z
*
xs
)
+
dx
*
(
deviceToLocal
[
0
]
.
y
-
deviceToLocal
[
0
]
.
z
*
ys
)
;
float4
gy
=
-
dy
*
(
deviceToLocal
[
1
]
.
x
-
deviceToLocal
[
1
]
.
z
*
xs
)
+
dx
*
(
deviceToLocal
[
1
]
.
y
-
deviceToLocal
[
1
]
.
z
*
ys
)
;
/
/
NOTE
:
The
gradient
is
missing
a
W
term
so
edgeDistances
must
still
be
multiplied
by
/
/
1
/
w
in
the
fragment
shader
.
The
same
goes
for
the
encoded
coverage
scale
.
edgeDistances
*
=
inversesqrt
(
gx
*
gx
+
gy
*
gy
)
;
/
/
Bias
non
-
AA
edge
distances
by
device
W
so
its
coverage
contribution
is
>
=
1
.
0
edgeDistances
+
=
(
1
-
edgeAA
)
*
abs
(
devPos
.
z
)
;
/
/
Mixed
edge
AA
shapes
do
not
use
subpixel
scale
+
bias
for
coverage
since
they
tile
/
/
to
a
large
shape
of
unknown
-
-
but
likely
not
subpixel
-
-
size
.
Triangles
and
quads
do
/
/
not
use
subpixel
coverage
since
the
scale
+
bias
is
not
constant
over
the
shape
but
/
/
we
can
'
t
evaluate
per
-
fragment
since
we
aren
'
t
passing
down
their
arbitrary
normals
.
bool
subpixelCoverage
=
edgeAA
=
=
float4
(
1
.
0
)
&
&
dot
(
abs
(
dx
*
dx
.
yzwx
+
dy
*
dy
.
yzwx
)
float4
(
1
.
0
)
)
<
kEpsilon
;
if
(
subpixelCoverage
)
{
/
/
Reconstructs
the
actual
device
-
space
width
and
height
for
all
rectangle
vertices
.
float2
dim
=
edgeDistances
.
xy
+
edgeDistances
.
zw
;
perPixelControl
.
y
=
1
.
0
+
min
(
min
(
dim
.
x
dim
.
y
)
abs
(
devPos
.
z
)
)
;
}
else
{
perPixelControl
.
y
=
1
.
0
+
abs
(
devPos
.
z
)
;
/
/
standard
1px
width
pre
W
division
.
}
}
/
/
Only
outset
for
a
vertex
that
is
in
front
of
the
w
=
0
plane
to
avoid
dealing
with
outset
/
/
triangles
rasterizing
differently
from
the
main
triangles
as
w
crosses
0
.
if
(
normalScale
>
0
.
0
&
&
devPos
.
z
>
0
.
0
)
{
/
/
Note
that
when
there
'
s
no
perspective
the
jacobian
is
equivalent
to
the
normal
/
/
matrix
(
inverse
transpose
)
but
produces
correct
results
when
there
'
s
perspective
/
/
because
it
accounts
for
the
position
'
s
influence
on
a
line
'
s
projected
direction
.
float2x2
J
=
float2x2
(
jacobian
.
xy
jacobian
.
zw
)
;
float2
edgeAANormal
=
float2
(
edgeAA
[
cornerID
]
edgeAA
.
yzwx
[
cornerID
]
)
*
normal
;
float2
nx
=
cornerAspectRatio
.
x
*
edgeAANormal
.
x
*
perp
(
-
yAxis
)
*
J
;
float2
ny
=
cornerAspectRatio
.
y
*
edgeAANormal
.
y
*
perp
(
xAxis
)
*
J
;
bool
isMidVertex
=
edgeAANormal
.
x
!
=
0
.
0
&
&
edgeAANormal
.
y
!
=
0
.
0
;
if
(
joinScale
=
=
kMiterScale
&
&
isMidVertex
)
{
/
/
Produce
a
bisecting
vector
in
device
space
(
ignoring
'
normal
'
since
that
was
/
/
previously
corrected
to
match
the
mitered
edge
normals
)
.
nx
=
normalize
(
nx
)
;
ny
=
normalize
(
ny
)
;
if
(
dot
(
nx
ny
)
<
-
0
.
8
)
{
/
/
Normals
are
in
nearly
opposite
directions
so
adjust
to
avoid
float
error
.
float
s
=
sign
(
cross_length_2d
(
nx
ny
)
)
;
nx
=
s
*
perp
(
nx
)
;
ny
=
-
s
*
perp
(
ny
)
;
}
}
/
/
Adding
the
normal
components
together
directly
results
in
what
we
'
d
have
/
/
calculated
if
we
'
d
just
transformed
'
normal
'
in
one
go
assuming
they
weren
'
t
/
/
normalized
in
the
if
-
block
above
.
If
they
were
normalized
the
sum
equals
the
/
/
bisector
between
the
original
nx
and
ny
.
/
/
/
/
We
multiply
by
W
so
that
after
perspective
division
the
new
point
is
offset
by
the
/
/
now
-
unit
normal
.
/
/
NOTE
:
(
nx
+
ny
)
can
become
the
zero
vector
if
the
device
outset
is
for
an
edge
/
/
marked
as
non
-
AA
.
In
this
case
normalize
(
)
could
produce
the
zero
vector
or
NaN
.
/
/
Until
a
counter
-
example
is
found
GPUs
seem
to
discard
triangles
with
NaN
vertices
/
/
which
has
the
same
effect
as
outsetting
by
the
zero
vector
with
this
mesh
so
we
/
/
don
'
t
bother
guarding
the
normalize
(
)
(
yet
)
.
devPos
.
xy
+
=
devPos
.
z
*
normalize
(
nx
+
ny
)
;
/
/
By
construction
these
points
are
1px
away
from
the
outer
edge
in
device
space
.
if
(
deviceSpaceDistances
)
{
/
/
Apply
directly
to
edgeDistances
to
save
work
per
pixel
later
on
.
edgeDistances
-
=
devPos
.
z
;
}
else
{
/
/
Otherwise
store
separately
so
edgeDistances
can
be
used
to
reconstruct
corner
pos
perPixelControl
.
y
=
-
devPos
.
z
;
}
}
else
if
(
!
deviceSpaceDistances
)
{
/
/
Triangles
are
within
the
original
shape
so
there
'
s
no
additional
outsetting
to
/
/
take
into
account
for
coverage
calculations
.
perPixelControl
.
y
=
0
.
0
;
}
if
(
centerWeight
!
=
0
.
0
)
{
/
/
A
positive
value
signals
that
a
pixel
is
trivially
full
coverage
.
perPixelControl
.
x
=
1
.
0
;
}
else
{
/
/
A
negative
value
signals
bidirectional
coverage
and
a
zero
value
signals
a
solid
/
/
interior
with
per
-
pixel
coverage
.
perPixelControl
.
x
=
bidirectionalCoverage
?
-
1
.
0
:
0
.
0
;
}
/
/
Write
out
final
results
stepLocalCoords
=
localPos
;
float4
devPosition
=
float4
(
devPos
.
xy
devPos
.
z
*
depth
devPos
.
z
)
;
)
"
;
}
const
char
*
AnalyticRRectRenderStep
:
:
fragmentCoverageSkSL
(
)
const
{
return
R
"
(
if
(
perPixelControl
.
x
>
0
.
0
)
{
/
/
A
trivially
solid
interior
pixel
either
from
a
filled
rect
or
round
rect
or
a
/
/
stroke
with
sufficiently
large
width
that
the
interior
completely
overlaps
itself
.
outputCoverage
=
half4
(
1
.
0
)
;
}
else
if
(
perPixelControl
.
y
>
1
.
0
)
{
/
/
This
represents
a
filled
rectangle
or
quadrilateral
where
the
distances
have
already
/
/
been
converted
to
device
space
.
Mitered
strokes
cannot
use
this
optimization
because
/
/
their
scale
and
bias
is
not
uniform
over
the
shape
;
Rounded
shapes
cannot
use
this
/
/
because
they
rely
on
the
edge
distances
being
in
local
space
to
reconstruct
the
/
/
per
-
corner
positions
for
the
elliptical
implicit
functions
.
float2
outerDist
=
min
(
edgeDistances
.
xy
edgeDistances
.
zw
)
;
float
c
=
min
(
outerDist
.
x
outerDist
.
y
)
*
sk_FragCoord
.
w
;
float
scale
=
(
perPixelControl
.
y
-
1
.
0
)
*
sk_FragCoord
.
w
;
float
bias
=
coverage_bias
(
scale
)
;
outputCoverage
=
half4
(
clamp
(
scale
*
(
c
+
bias
)
0
.
0
1
.
0
)
)
;
}
else
{
/
/
Compute
per
-
pixel
coverage
mixing
four
outer
edge
distances
possibly
four
inner
/
/
edge
distances
and
per
-
corner
elliptical
distances
into
a
final
coverage
value
.
/
/
The
Jacobian
needs
to
be
multiplied
by
W
but
sk_FragCoord
.
w
stores
1
/
w
.
float2x2
J
=
float2x2
(
jacobian
.
xy
jacobian
.
zw
)
/
sk_FragCoord
.
w
;
float2
invGradLen
=
float2
(
inverse_grad_len
(
float2
(
1
.
0
0
.
0
)
J
)
inverse_grad_len
(
float2
(
0
.
0
1
.
0
)
J
)
)
;
float2
outerDist
=
invGradLen
*
(
strokeParams
.
x
+
min
(
edgeDistances
.
xy
edgeDistances
.
zw
)
)
;
/
/
d
.
x
tracks
minimum
outer
distance
(
pre
scale
-
and
-
biasing
to
a
coverage
value
)
.
/
/
d
.
y
tracks
negative
maximum
inner
distance
(
so
min
(
)
over
c
accumulates
min
and
outer
/
/
and
max
inner
simultaneously
)
.
)
float2
d
=
float2
(
min
(
outerDist
.
x
outerDist
.
y
)
-
1
.
0
)
;
float
scale
bias
;
/
/
Check
for
bidirectional
coverage
which
is
is
marked
as
a
-
1
from
the
vertex
shader
.
/
/
We
don
'
t
just
check
for
<
0
since
extrapolated
fill
triangle
samples
can
have
small
/
/
negative
values
.
if
(
perPixelControl
.
x
>
-
0
.
95
)
{
/
/
A
solid
interior
so
update
scale
and
bias
based
on
full
width
and
height
float2
dim
=
invGradLen
*
(
edgeDistances
.
xy
+
edgeDistances
.
zw
+
2
*
strokeParams
.
xx
)
;
scale
=
min
(
min
(
dim
.
x
dim
.
y
)
1
.
0
)
;
bias
=
coverage_bias
(
scale
)
;
/
/
Since
we
leave
d
.
y
=
-
1
.
0
no
inner
curve
coverage
will
adjust
it
closer
to
0
/
/
so
'
finalCoverage
'
is
based
solely
on
outer
edges
and
curves
.
}
else
{
/
/
Bidirectional
coverage
so
we
modify
c
.
y
to
hold
the
negative
of
the
maximum
/
/
interior
coverage
and
update
scale
and
bias
based
on
stroke
width
.
float2
strokeWidth
=
2
.
0
*
strokeParams
.
x
*
invGradLen
;
float2
innerDist
=
strokeWidth
-
outerDist
;
d
.
y
=
-
max
(
innerDist
.
x
innerDist
.
y
)
;
if
(
strokeParams
.
x
>
0
.
0
)
{
float
strokeDim
=
min
(
strokeWidth
.
x
strokeWidth
.
y
)
;
if
(
innerDist
.
y
>
=
-
0
.
5
&
&
strokeWidth
.
y
>
strokeDim
)
{
strokeDim
=
strokeWidth
.
y
;
}
if
(
innerDist
.
x
>
=
-
0
.
5
&
&
strokeWidth
.
x
>
strokeDim
)
{
strokeDim
=
strokeWidth
.
x
;
}
scale
=
min
(
strokeDim
1
.
0
)
;
bias
=
coverage_bias
(
scale
)
;
}
else
{
/
/
A
hairline
so
scale
and
bias
should
both
be
1
scale
=
bias
=
1
.
0
;
}
}
/
/
Check
all
corners
although
most
pixels
should
only
be
influenced
by
1
.
corner_distances
(
d
J
strokeParams
edgeDistances
xRadii
yRadii
)
;
float
outsetDist
=
min
(
perPixelControl
.
y
0
.
0
)
*
sk_FragCoord
.
w
;
float
finalCoverage
=
scale
*
(
min
(
d
.
x
+
outsetDist
-
d
.
y
)
+
bias
)
;
outputCoverage
=
half4
(
clamp
(
finalCoverage
0
.
0
1
.
0
)
)
;
}
)
"
;
}
void
AnalyticRRectRenderStep
:
:
writeVertices
(
DrawWriter
*
writer
const
DrawParams
&
params
int
ssboIndex
)
const
{
SkASSERT
(
params
.
geometry
(
)
.
isShape
(
)
|
|
params
.
geometry
(
)
.
isEdgeAAQuad
(
)
)
;
DrawWriter
:
:
Instances
instance
{
*
writer
fVertexBuffer
fIndexBuffer
kIndexCount
}
;
auto
vw
=
instance
.
append
(
1
)
;
Rect
bounds
=
params
.
geometry
(
)
.
bounds
(
)
;
const
skvx
:
:
float2
size
=
bounds
.
size
(
)
;
float
aaRadius
=
local_aa_radius
(
params
.
transform
(
)
bounds
)
;
float
strokeInset
=
0
.
f
;
float
centerWeight
=
kSolidInterior
;
if
(
params
.
isStroke
(
)
)
{
const
Shape
&
shape
=
params
.
geometry
(
)
.
shape
(
)
;
SkASSERT
(
params
.
strokeStyle
(
)
.
halfWidth
(
)
>
=
0
.
f
)
;
SkASSERT
(
shape
.
isRect
(
)
|
|
params
.
strokeStyle
(
)
.
halfWidth
(
)
=
=
0
.
f
|
|
(
shape
.
isRRect
(
)
&
&
SkRRectPriv
:
:
AllCornersCircular
(
shape
.
rrect
(
)
)
)
)
;
float
strokeRadius
=
params
.
strokeStyle
(
)
.
halfWidth
(
)
;
skvx
:
:
float2
innerGap
=
size
-
2
.
f
*
params
.
strokeStyle
(
)
.
halfWidth
(
)
;
if
(
any
(
innerGap
<
=
0
.
f
)
)
{
strokeInset
=
-
strokeRadius
;
}
else
{
centerWeight
=
kStrokeInterior
;
strokeInset
=
strokeRadius
;
}
skvx
:
:
float4
xRadii
=
shape
.
isRRect
(
)
?
load_x_radii
(
shape
.
rrect
(
)
)
:
skvx
:
:
float4
(
0
.
f
)
;
if
(
strokeRadius
>
0
.
f
)
{
float
joinStyle
=
params
.
strokeStyle
(
)
.
joinLimit
(
)
;
if
(
params
.
strokeStyle
(
)
.
isMiterJoin
(
)
)
{
if
(
params
.
strokeStyle
(
)
.
miterLimit
(
)
<
SK_ScalarSqrt2
)
{
joinStyle
=
0
.
f
;
}
else
{
joinStyle
=
1
.
f
;
}
}
auto
empty
=
size
=
=
0
.
f
;
if
(
all
(
empty
)
)
{
SkASSERT
(
params
.
strokeStyle
(
)
.
cap
(
)
!
=
SkPaint
:
:
kButt_Cap
)
;
joinStyle
=
params
.
strokeStyle
(
)
.
cap
(
)
=
=
SkPaint
:
:
kRound_Cap
?
-
1
.
f
:
1
.
f
;
}
else
if
(
any
(
empty
)
&
&
joinStyle
>
=
0
.
f
)
{
float
strokeDelta
=
std
:
:
min
(
0
.
f
std
:
:
max
(
innerGap
.
x
(
)
innerGap
.
y
(
)
)
)
;
auto
adjust
=
strokeDelta
+
if_then_else
(
empty
skvx
:
:
float2
(
0
.
f
)
skvx
:
:
float2
(
strokeRadius
)
)
;
bounds
.
inset
(
adjust
)
;
strokeRadius
+
=
strokeDelta
;
joinStyle
=
1
.
f
;
if
(
opposite_insets_intersect
(
bounds
strokeRadius
aaRadius
)
)
{
aaRadius
=
kComplexAAInsets
;
SkASSERT
(
centerWeight
=
=
kSolidInterior
)
;
}
}
vw
<
<
-
2
.
f
<
<
0
.
f
<
<
strokeRadius
<
<
joinStyle
<
<
xRadii
<
<
bounds
.
ltrb
(
)
;
}
else
{
skvx
:
:
float4
yRadii
=
shape
.
isRRect
(
)
?
load_y_radii
(
shape
.
rrect
(
)
)
:
skvx
:
:
float4
(
0
.
f
)
;
vw
<
<
(
-
2
.
f
-
xRadii
)
<
<
yRadii
<
<
bounds
.
ltrb
(
)
;
}
}
else
{
SkASSERT
(
!
bounds
.
isEmptyNegativeOrNaN
(
)
)
;
if
(
params
.
geometry
(
)
.
isEdgeAAQuad
(
)
)
{
const
EdgeAAQuad
&
quad
=
params
.
geometry
(
)
.
edgeAAQuad
(
)
;
if
(
quad
.
edgeFlags
(
)
=
=
EdgeAAQuad
:
:
Flags
:
:
kNone
)
{
aaRadius
=
0
.
f
;
}
auto
edgeSigns
=
skvx
:
:
float4
{
quad
.
edgeFlags
(
)
&
AAFlags
:
:
kLeft
?
-
1
.
f
:
0
.
f
quad
.
edgeFlags
(
)
&
AAFlags
:
:
kTop
?
-
1
.
f
:
0
.
f
quad
.
edgeFlags
(
)
&
AAFlags
:
:
kRight
?
-
1
.
f
:
0
.
f
quad
.
edgeFlags
(
)
&
AAFlags
:
:
kBottom
?
-
1
.
f
:
0
.
f
}
;
if
(
is_clockwise
(
quad
)
)
{
vw
<
<
edgeSigns
<
<
quad
.
xs
(
)
<
<
quad
.
ys
(
)
;
}
else
{
vw
<
<
skvx
:
:
shuffle
<
2
1
0
3
>
(
edgeSigns
)
<
<
skvx
:
:
shuffle
<
1
0
3
2
>
(
quad
.
xs
(
)
)
<
<
skvx
:
:
shuffle
<
1
0
3
2
>
(
quad
.
ys
(
)
)
;
}
}
else
{
const
Shape
&
shape
=
params
.
geometry
(
)
.
shape
(
)
;
if
(
shape
.
isRect
(
)
|
|
(
shape
.
isRRect
(
)
&
&
shape
.
rrect
(
)
.
isRect
(
)
)
)
{
skvx
:
:
float4
ltrb
=
bounds
.
ltrb
(
)
;
vw
<
<
skvx
:
:
float4
(
-
1
.
f
)
<
<
skvx
:
:
shuffle
<
0
2
2
0
>
(
ltrb
)
<
<
skvx
:
:
shuffle
<
1
1
3
3
>
(
ltrb
)
;
}
else
{
SkASSERT
(
any
(
load_x_radii
(
shape
.
rrect
(
)
)
>
0
.
f
)
)
;
vw
<
<
load_x_radii
(
shape
.
rrect
(
)
)
<
<
load_y_radii
(
shape
.
rrect
(
)
)
<
<
bounds
.
ltrb
(
)
;
}
}
}
if
(
opposite_insets_intersect
(
params
.
geometry
(
)
strokeInset
aaRadius
)
)
{
aaRadius
=
kComplexAAInsets
;
if
(
centerWeight
=
=
kStrokeInterior
)
{
centerWeight
=
kFilledStrokeInterior
;
}
}
const
SkM44
&
m
=
params
.
transform
(
)
.
matrix
(
)
;
auto
center
=
params
.
geometry
(
)
.
isEdgeAAQuad
(
)
?
quad_center
(
params
.
geometry
(
)
.
edgeAAQuad
(
)
)
:
bounds
.
center
(
)
;
vw
<
<
center
<
<
centerWeight
<
<
aaRadius
<
<
params
.
order
(
)
.
depthAsFloat
(
)
<
<
ssboIndex
<
<
m
.
rc
(
0
0
)
<
<
m
.
rc
(
1
0
)
<
<
m
.
rc
(
3
0
)
<
<
m
.
rc
(
0
1
)
<
<
m
.
rc
(
1
1
)
<
<
m
.
rc
(
3
1
)
<
<
m
.
rc
(
0
3
)
<
<
m
.
rc
(
1
3
)
<
<
m
.
rc
(
3
3
)
;
}
void
AnalyticRRectRenderStep
:
:
writeUniformsAndTextures
(
const
DrawParams
&
PipelineDataGatherer
*
)
const
{
}
}
