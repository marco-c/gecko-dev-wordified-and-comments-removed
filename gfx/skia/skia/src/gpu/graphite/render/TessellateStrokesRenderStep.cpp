#
include
"
src
/
gpu
/
graphite
/
render
/
TessellateStrokesRenderStep
.
h
"
#
include
"
include
/
core
/
SkM44
.
h
"
#
include
"
include
/
private
/
SkSLString
.
h
"
#
include
"
src
/
base
/
SkVx
.
h
"
#
include
"
src
/
core
/
SkGeometry
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawParams
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawTypes
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawWriter
.
h
"
#
include
"
src
/
gpu
/
graphite
/
PipelineData
.
h
"
#
include
"
src
/
gpu
/
graphite
/
render
/
CommonDepthStencilSettings
.
h
"
#
include
"
src
/
gpu
/
graphite
/
render
/
DynamicInstancesPatchAllocator
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
FixedCountBufferUtils
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
PatchWriter
.
h
"
#
include
"
src
/
gpu
/
tessellate
/
StrokeIterator
.
h
"
namespace
skgpu
:
:
graphite
{
namespace
{
using
namespace
skgpu
:
:
tess
;
static
constexpr
PatchAttribs
kAttribs
=
PatchAttribs
:
:
kJoinControlPoint
|
PatchAttribs
:
:
kStrokeParams
|
PatchAttribs
:
:
kPaintDepth
|
PatchAttribs
:
:
kSsboIndex
;
static
constexpr
PatchAttribs
kAttribsWithCurveType
=
kAttribs
|
PatchAttribs
:
:
kExplicitCurveType
;
using
Writer
=
PatchWriter
<
DynamicInstancesPatchAllocator
<
FixedCountStrokes
>
Required
<
PatchAttribs
:
:
kJoinControlPoint
>
Required
<
PatchAttribs
:
:
kStrokeParams
>
Required
<
PatchAttribs
:
:
kPaintDepth
>
Required
<
PatchAttribs
:
:
kSsboIndex
>
Optional
<
PatchAttribs
:
:
kExplicitCurveType
>
ReplicateLineEndPoints
TrackJoinControlPoints
>
;
static
constexpr
Attribute
kBaseAttributes
[
]
=
{
{
"
p01
"
VertexAttribType
:
:
kFloat4
SkSLType
:
:
kFloat4
}
{
"
p23
"
VertexAttribType
:
:
kFloat4
SkSLType
:
:
kFloat4
}
{
"
prevPoint
"
VertexAttribType
:
:
kFloat2
SkSLType
:
:
kFloat2
}
{
"
stroke
"
VertexAttribType
:
:
kFloat2
SkSLType
:
:
kFloat2
}
{
"
depth
"
VertexAttribType
:
:
kFloat
SkSLType
:
:
kFloat
}
{
"
ssboIndex
"
VertexAttribType
:
:
kInt
SkSLType
:
:
kInt
}
}
;
static
constexpr
Attribute
kAttributesWithCurveType
[
]
=
{
{
"
p01
"
VertexAttribType
:
:
kFloat4
SkSLType
:
:
kFloat4
}
{
"
p23
"
VertexAttribType
:
:
kFloat4
SkSLType
:
:
kFloat4
}
{
"
prevPoint
"
VertexAttribType
:
:
kFloat2
SkSLType
:
:
kFloat2
}
{
"
stroke
"
VertexAttribType
:
:
kFloat2
SkSLType
:
:
kFloat2
}
{
"
depth
"
VertexAttribType
:
:
kFloat
SkSLType
:
:
kFloat
}
{
"
curveType
"
VertexAttribType
:
:
kFloat
SkSLType
:
:
kFloat
}
{
"
ssboIndex
"
VertexAttribType
:
:
kInt
SkSLType
:
:
kInt
}
}
;
static
constexpr
SkSpan
<
const
Attribute
>
kAttributes
[
2
]
=
{
kAttributesWithCurveType
kBaseAttributes
}
;
}
TessellateStrokesRenderStep
:
:
TessellateStrokesRenderStep
(
bool
infinitySupport
)
:
RenderStep
(
"
TessellateStrokeRenderStep
"
"
"
Flags
:
:
kRequiresMSAA
|
Flags
:
:
kPerformsShading
{
{
"
affineMatrix
"
SkSLType
:
:
kFloat4
}
{
"
translate
"
SkSLType
:
:
kFloat2
}
{
"
maxScale
"
SkSLType
:
:
kFloat
}
}
PrimitiveType
:
:
kTriangleStrip
kDirectDepthGreaterPass
{
}
kAttributes
[
infinitySupport
]
)
fInfinitySupport
(
infinitySupport
)
{
}
TessellateStrokesRenderStep
:
:
~
TessellateStrokesRenderStep
(
)
{
}
std
:
:
string
TessellateStrokesRenderStep
:
:
vertexSkSL
(
)
const
{
return
SkSL
:
:
String
:
:
printf
(
R
"
(
float
edgeID
=
float
(
sk_VertexID
>
>
1
)
;
if
(
(
sk_VertexID
&
1
)
!
=
0
)
{
edgeID
=
-
edgeID
;
}
float2x2
affine
=
float2x2
(
affineMatrix
.
xy
affineMatrix
.
zw
)
;
float4
devAndLocalCoords
=
tessellate_stroked_curve
(
edgeID
16383
affine
translate
maxScale
p01
p23
prevPoint
stroke
%
s
)
;
float4
devPosition
=
float4
(
devAndLocalCoords
.
xy
depth
1
.
0
)
;
stepLocalCoords
=
devAndLocalCoords
.
zw
;
)
"
fInfinitySupport
?
"
curve_type_using_inf_support
(
p23
)
"
:
"
curveType
"
)
;
}
void
TessellateStrokesRenderStep
:
:
writeVertices
(
DrawWriter
*
dw
const
DrawParams
&
params
int
ssboIndex
)
const
{
SkPath
path
=
params
.
geometry
(
)
.
shape
(
)
.
asPath
(
)
;
int
patchReserveCount
=
FixedCountStrokes
:
:
PreallocCount
(
path
.
countVerbs
(
)
)
;
static
const
BindBufferInfo
kNullBinding
=
{
}
;
Writer
writer
{
fInfinitySupport
?
kAttribs
:
kAttribsWithCurveType
*
dw
kNullBinding
kNullBinding
patchReserveCount
}
;
writer
.
updatePaintDepthAttrib
(
params
.
order
(
)
.
depthAsFloat
(
)
)
;
writer
.
updateSsboIndexAttrib
(
ssboIndex
)
;
writer
.
setShaderTransform
(
wangs_formula
:
:
VectorXform
{
params
.
transform
(
)
.
matrix
(
)
}
params
.
transform
(
)
.
maxScaleFactor
(
)
)
;
SkASSERT
(
params
.
isStroke
(
)
)
;
writer
.
updateStrokeParamsAttrib
(
{
params
.
strokeStyle
(
)
.
halfWidth
(
)
params
.
strokeStyle
(
)
.
joinLimit
(
)
}
)
;
SkMatrix
shaderMatrix
=
params
.
transform
(
)
;
SkStrokeRec
stroke
{
SkStrokeRec
:
:
kHairline_InitStyle
}
;
stroke
.
setStrokeStyle
(
params
.
strokeStyle
(
)
.
width
(
)
)
;
stroke
.
setStrokeParams
(
params
.
strokeStyle
(
)
.
cap
(
)
params
.
strokeStyle
(
)
.
join
(
)
params
.
strokeStyle
(
)
.
miterLimit
(
)
)
;
StrokeIterator
strokeIter
(
path
&
stroke
&
shaderMatrix
)
;
while
(
strokeIter
.
next
(
)
)
{
using
Verb
=
StrokeIterator
:
:
Verb
;
const
SkPoint
*
p
=
strokeIter
.
pts
(
)
;
int
numChops
;
switch
(
strokeIter
.
verb
(
)
)
{
case
Verb
:
:
kContourFinished
:
writer
.
writeDeferredStrokePatch
(
)
;
break
;
case
Verb
:
:
kCircle
:
writer
.
writeCircle
(
p
[
0
]
)
;
[
[
fallthrough
]
]
;
case
Verb
:
:
kMoveWithinContour
:
writer
.
updateJoinControlPointAttrib
(
p
[
0
]
)
;
break
;
case
Verb
:
:
kLine
:
writer
.
writeLine
(
p
[
0
]
p
[
1
]
)
;
break
;
case
Verb
:
:
kQuad
:
if
(
ConicHasCusp
(
p
)
)
{
SkPoint
cusp
=
SkEvalQuadAt
(
p
SkFindQuadMidTangent
(
p
)
)
;
writer
.
writeCircle
(
cusp
)
;
writer
.
writeLine
(
p
[
0
]
cusp
)
;
writer
.
writeLine
(
cusp
p
[
2
]
)
;
}
else
{
writer
.
writeQuadratic
(
p
)
;
}
break
;
case
Verb
:
:
kConic
:
if
(
ConicHasCusp
(
p
)
)
{
SkConic
conic
(
p
strokeIter
.
w
(
)
)
;
SkPoint
cusp
=
conic
.
evalAt
(
conic
.
findMidTangent
(
)
)
;
writer
.
writeCircle
(
cusp
)
;
writer
.
writeLine
(
p
[
0
]
cusp
)
;
writer
.
writeLine
(
cusp
p
[
2
]
)
;
}
else
{
writer
.
writeConic
(
p
strokeIter
.
w
(
)
)
;
}
break
;
case
Verb
:
:
kCubic
:
SkPoint
chops
[
10
]
;
float
T
[
2
]
;
bool
areCusps
;
numChops
=
FindCubicConvex180Chops
(
p
T
&
areCusps
)
;
if
(
numChops
=
=
0
)
{
writer
.
writeCubic
(
p
)
;
}
else
if
(
numChops
=
=
1
)
{
SkChopCubicAt
(
p
chops
T
[
0
]
)
;
if
(
areCusps
)
{
writer
.
writeCircle
(
chops
[
3
]
)
;
chops
[
2
]
=
chops
[
4
]
=
chops
[
3
]
;
}
writer
.
writeCubic
(
chops
)
;
writer
.
writeCubic
(
chops
+
3
)
;
}
else
{
SkASSERT
(
numChops
=
=
2
)
;
SkChopCubicAt
(
p
chops
T
[
0
]
T
[
1
]
)
;
if
(
areCusps
)
{
writer
.
writeCircle
(
chops
[
3
]
)
;
writer
.
writeCircle
(
chops
[
6
]
)
;
writer
.
writeLine
(
chops
[
0
]
chops
[
3
]
)
;
writer
.
writeLine
(
chops
[
3
]
chops
[
6
]
)
;
writer
.
writeLine
(
chops
[
6
]
chops
[
9
]
)
;
}
else
{
writer
.
writeCubic
(
chops
)
;
writer
.
writeCubic
(
chops
+
3
)
;
writer
.
writeCubic
(
chops
+
6
)
;
}
}
break
;
}
}
}
void
TessellateStrokesRenderStep
:
:
writeUniformsAndTextures
(
const
DrawParams
&
params
PipelineDataGatherer
*
gatherer
)
const
{
SkASSERT
(
params
.
transform
(
)
.
type
(
)
<
Transform
:
:
Type
:
:
kProjection
)
;
SkDEBUGCODE
(
UniformExpectationsValidator
uev
(
gatherer
this
-
>
uniforms
(
)
)
;
)
SkV4
upper
=
{
params
.
transform
(
)
.
matrix
(
)
.
rc
(
0
0
)
params
.
transform
(
)
.
matrix
(
)
.
rc
(
1
0
)
params
.
transform
(
)
.
matrix
(
)
.
rc
(
0
1
)
params
.
transform
(
)
.
matrix
(
)
.
rc
(
1
1
)
}
;
gatherer
-
>
write
(
upper
)
;
gatherer
-
>
write
(
SkPoint
{
params
.
transform
(
)
.
matrix
(
)
.
rc
(
0
3
)
params
.
transform
(
)
.
matrix
(
)
.
rc
(
1
3
)
}
)
;
gatherer
-
>
write
(
params
.
transform
(
)
.
maxScaleFactor
(
)
)
;
}
}
