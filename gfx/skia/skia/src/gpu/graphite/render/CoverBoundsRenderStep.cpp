#
include
"
src
/
gpu
/
graphite
/
render
/
CoverBoundsRenderStep
.
h
"
#
include
"
src
/
base
/
SkVx
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawParams
.
h
"
#
include
"
src
/
gpu
/
graphite
/
DrawWriter
.
h
"
#
include
"
src
/
gpu
/
graphite
/
render
/
CommonDepthStencilSettings
.
h
"
namespace
skgpu
:
:
graphite
{
CoverBoundsRenderStep
:
:
CoverBoundsRenderStep
(
bool
inverseFill
)
:
RenderStep
(
"
CoverBoundsRenderStep
"
inverseFill
?
"
inverse
"
:
"
regular
"
Flags
:
:
kPerformsShading
{
}
PrimitiveType
:
:
kTriangleStrip
inverseFill
?
kInverseCoverPass
:
kRegularCoverPass
{
{
"
position
"
VertexAttribType
:
:
kFloat4
SkSLType
:
:
kFloat4
}
}
{
{
"
bounds
"
VertexAttribType
:
:
kFloat4
SkSLType
:
:
kFloat4
}
{
"
depth
"
VertexAttribType
:
:
kFloat
SkSLType
:
:
kFloat
}
{
"
ssboIndex
"
VertexAttribType
:
:
kInt
SkSLType
:
:
kInt
}
{
"
mat0
"
VertexAttribType
:
:
kFloat3
SkSLType
:
:
kFloat3
}
{
"
mat1
"
VertexAttribType
:
:
kFloat3
SkSLType
:
:
kFloat3
}
{
"
mat2
"
VertexAttribType
:
:
kFloat3
SkSLType
:
:
kFloat3
}
}
)
fInverseFill
(
inverseFill
)
{
}
CoverBoundsRenderStep
:
:
~
CoverBoundsRenderStep
(
)
{
}
std
:
:
string
CoverBoundsRenderStep
:
:
vertexSkSL
(
)
const
{
return
R
"
(
float3x3
matrix
=
float3x3
(
mat0
mat1
mat2
)
;
float2
corner
=
float2
(
float
(
sk_VertexID
/
2
)
float
(
sk_VertexID
%
2
)
)
;
float4
devPosition
;
if
(
bounds
.
L
<
=
bounds
.
R
&
&
bounds
.
T
<
=
bounds
.
B
)
{
/
/
A
regular
fill
corner
=
(
1
.
0
-
corner
)
*
bounds
.
LT
+
corner
*
bounds
.
RB
;
float3
devCorner
=
matrix
*
corner
.
xy1
;
devPosition
=
float4
(
devCorner
.
xy
depth
devCorner
.
z
)
;
stepLocalCoords
=
corner
;
}
else
{
/
/
An
inverse
fill
corner
=
corner
*
bounds
.
LT
+
(
1
.
0
-
corner
)
*
bounds
.
RB
;
devPosition
=
float4
(
corner
depth
1
.
0
)
;
/
/
TODO
:
Support
float3
local
coordinates
if
the
matrix
has
perspective
so
that
W
/
/
is
interpolated
correctly
to
the
fragment
shader
.
float3
localCoords
=
matrix
*
corner
.
xy1
;
stepLocalCoords
=
localCoords
.
xy
/
localCoords
.
z
;
}
)
"
;
}
void
CoverBoundsRenderStep
:
:
writeVertices
(
DrawWriter
*
writer
const
DrawParams
&
params
int
ssboIndex
)
const
{
DrawWriter
:
:
Instances
instances
{
*
writer
{
}
{
}
4
}
;
skvx
:
:
float4
bounds
;
const
SkM44
*
m
;
if
(
fInverseFill
)
{
bounds
=
skvx
:
:
shuffle
<
2
3
0
1
>
(
skvx
:
:
cast
<
float
>
(
skvx
:
:
int4
:
:
Load
(
&
params
.
clip
(
)
.
scissor
(
)
)
)
)
;
m
=
&
params
.
transform
(
)
.
inverse
(
)
;
}
else
{
bounds
=
params
.
geometry
(
)
.
bounds
(
)
.
ltrb
(
)
;
m
=
&
params
.
transform
(
)
.
matrix
(
)
;
}
instances
.
append
(
1
)
<
<
bounds
<
<
params
.
order
(
)
.
depthAsFloat
(
)
<
<
ssboIndex
<
<
m
-
>
rc
(
0
0
)
<
<
m
-
>
rc
(
1
0
)
<
<
m
-
>
rc
(
3
0
)
<
<
m
-
>
rc
(
0
1
)
<
<
m
-
>
rc
(
1
1
)
<
<
m
-
>
rc
(
3
1
)
<
<
m
-
>
rc
(
0
3
)
<
<
m
-
>
rc
(
1
3
)
<
<
m
-
>
rc
(
3
3
)
;
}
void
CoverBoundsRenderStep
:
:
writeUniformsAndTextures
(
const
DrawParams
&
PipelineDataGatherer
*
)
const
{
}
}
