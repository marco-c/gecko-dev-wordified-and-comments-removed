#
ifndef
GrStyle_DEFINED
#
define
GrStyle_DEFINED
#
include
"
include
/
core
/
SkPathEffect
.
h
"
#
include
"
include
/
core
/
SkStrokeRec
.
h
"
#
include
"
include
/
gpu
/
GrTypes
.
h
"
#
include
"
include
/
private
/
SkTemplates
.
h
"
class
GrStyle
{
public
:
static
const
GrStyle
&
SimpleFill
(
)
{
static
const
GrStyle
kFill
(
SkStrokeRec
:
:
kFill_InitStyle
)
;
return
kFill
;
}
static
const
GrStyle
&
SimpleHairline
(
)
{
static
const
GrStyle
kHairline
(
SkStrokeRec
:
:
kHairline_InitStyle
)
;
return
kHairline
;
}
enum
class
Apply
{
kPathEffectOnly
kPathEffectAndStrokeRec
}
;
enum
KeyFlags
{
kClosed_KeyFlag
=
0x1
kNoJoins_KeyFlag
=
0x2
}
;
static
int
KeySize
(
const
GrStyle
&
Apply
uint32_t
flags
=
0
)
;
static
void
WriteKey
(
uint32_t
*
const
GrStyle
&
Apply
SkScalar
scale
uint32_t
flags
=
0
)
;
GrStyle
(
)
:
GrStyle
(
SkStrokeRec
:
:
kFill_InitStyle
)
{
}
explicit
GrStyle
(
SkStrokeRec
:
:
InitStyle
initStyle
)
:
fStrokeRec
(
initStyle
)
{
}
GrStyle
(
const
SkStrokeRec
&
strokeRec
sk_sp
<
SkPathEffect
>
pe
)
:
fStrokeRec
(
strokeRec
)
{
this
-
>
initPathEffect
(
std
:
:
move
(
pe
)
)
;
}
GrStyle
(
const
GrStyle
&
that
)
=
default
;
explicit
GrStyle
(
const
SkPaint
&
paint
)
:
fStrokeRec
(
paint
)
{
this
-
>
initPathEffect
(
paint
.
refPathEffect
(
)
)
;
}
explicit
GrStyle
(
const
SkPaint
&
paint
SkPaint
:
:
Style
overrideStyle
)
:
fStrokeRec
(
paint
overrideStyle
)
{
this
-
>
initPathEffect
(
paint
.
refPathEffect
(
)
)
;
}
GrStyle
&
operator
=
(
const
GrStyle
&
that
)
{
fPathEffect
=
that
.
fPathEffect
;
fDashInfo
=
that
.
fDashInfo
;
fStrokeRec
=
that
.
fStrokeRec
;
return
*
this
;
}
void
resetToInitStyle
(
SkStrokeRec
:
:
InitStyle
fillOrHairline
)
{
fDashInfo
.
reset
(
)
;
fPathEffect
.
reset
(
nullptr
)
;
if
(
SkStrokeRec
:
:
kFill_InitStyle
=
=
fillOrHairline
)
{
fStrokeRec
.
setFillStyle
(
)
;
}
else
{
fStrokeRec
.
setHairlineStyle
(
)
;
}
}
bool
isSimpleFill
(
)
const
{
return
fStrokeRec
.
isFillStyle
(
)
&
&
!
fPathEffect
;
}
bool
isSimpleHairline
(
)
const
{
return
fStrokeRec
.
isHairlineStyle
(
)
&
&
!
fPathEffect
;
}
SkPathEffect
*
pathEffect
(
)
const
{
return
fPathEffect
.
get
(
)
;
}
sk_sp
<
SkPathEffect
>
refPathEffect
(
)
const
{
return
fPathEffect
;
}
bool
hasPathEffect
(
)
const
{
return
SkToBool
(
fPathEffect
.
get
(
)
)
;
}
bool
hasNonDashPathEffect
(
)
const
{
return
fPathEffect
.
get
(
)
&
&
!
this
-
>
isDashed
(
)
;
}
bool
isDashed
(
)
const
{
return
SkPathEffect
:
:
kDash_DashType
=
=
fDashInfo
.
fType
;
}
SkScalar
dashPhase
(
)
const
{
SkASSERT
(
this
-
>
isDashed
(
)
)
;
return
fDashInfo
.
fPhase
;
}
int
dashIntervalCnt
(
)
const
{
SkASSERT
(
this
-
>
isDashed
(
)
)
;
return
fDashInfo
.
fIntervals
.
count
(
)
;
}
const
SkScalar
*
dashIntervals
(
)
const
{
SkASSERT
(
this
-
>
isDashed
(
)
)
;
return
fDashInfo
.
fIntervals
.
get
(
)
;
}
const
SkStrokeRec
&
strokeRec
(
)
const
{
return
fStrokeRec
;
}
bool
applies
(
)
const
{
return
this
-
>
pathEffect
(
)
|
|
(
!
fStrokeRec
.
isFillStyle
(
)
&
&
!
fStrokeRec
.
isHairlineStyle
(
)
)
;
}
static
SkScalar
MatrixToScaleFactor
(
const
SkMatrix
&
matrix
)
{
return
SkScalarAbs
(
matrix
.
getMaxScale
(
)
)
;
}
bool
SK_WARN_UNUSED_RESULT
applyPathEffectToPath
(
SkPath
*
dst
SkStrokeRec
*
remainingStoke
const
SkPath
&
src
SkScalar
scale
)
const
;
bool
SK_WARN_UNUSED_RESULT
applyToPath
(
SkPath
*
dst
SkStrokeRec
:
:
InitStyle
*
fillOrHairline
const
SkPath
&
src
SkScalar
scale
)
const
;
void
adjustBounds
(
SkRect
*
dst
const
SkRect
&
src
)
const
{
if
(
this
-
>
pathEffect
(
)
)
{
this
-
>
pathEffect
(
)
-
>
computeFastBounds
(
dst
src
)
;
SkScalar
radius
=
fStrokeRec
.
getInflationRadius
(
)
;
dst
-
>
outset
(
radius
radius
)
;
}
else
{
SkScalar
radius
=
fStrokeRec
.
getInflationRadius
(
)
;
*
dst
=
src
.
makeOutset
(
radius
radius
)
;
}
}
private
:
void
initPathEffect
(
sk_sp
<
SkPathEffect
>
pe
)
;
struct
DashInfo
{
DashInfo
(
)
:
fType
(
SkPathEffect
:
:
kNone_DashType
)
{
}
DashInfo
(
const
DashInfo
&
that
)
{
*
this
=
that
;
}
DashInfo
&
operator
=
(
const
DashInfo
&
that
)
{
fType
=
that
.
fType
;
fPhase
=
that
.
fPhase
;
fIntervals
.
reset
(
that
.
fIntervals
.
count
(
)
)
;
sk_careful_memcpy
(
fIntervals
.
get
(
)
that
.
fIntervals
.
get
(
)
sizeof
(
SkScalar
)
*
that
.
fIntervals
.
count
(
)
)
;
return
*
this
;
}
void
reset
(
)
{
fType
=
SkPathEffect
:
:
kNone_DashType
;
fIntervals
.
reset
(
0
)
;
}
SkPathEffect
:
:
DashType
fType
;
SkScalar
fPhase
{
0
}
;
SkAutoSTArray
<
4
SkScalar
>
fIntervals
;
}
;
bool
applyPathEffect
(
SkPath
*
dst
SkStrokeRec
*
strokeRec
const
SkPath
&
src
)
const
;
SkStrokeRec
fStrokeRec
;
sk_sp
<
SkPathEffect
>
fPathEffect
;
DashInfo
fDashInfo
;
}
;
#
endif
