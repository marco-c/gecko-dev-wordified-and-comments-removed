#
ifndef
skgpu_ResourceKey_DEFINED
#
define
skgpu_ResourceKey_DEFINED
#
include
"
include
/
core
/
SkData
.
h
"
#
include
"
include
/
core
/
SkString
.
h
"
#
include
"
include
/
private
/
base
/
SkAlign
.
h
"
#
include
"
include
/
private
/
base
/
SkAlignedStorage
.
h
"
#
include
"
include
/
private
/
base
/
SkOnce
.
h
"
#
include
"
include
/
private
/
base
/
SkTemplates
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
<
new
>
class
TestResource
;
namespace
skgpu
{
uint32_t
ResourceKeyHash
(
const
uint32_t
*
data
size_t
size
)
;
class
ResourceKey
{
public
:
uint32_t
hash
(
)
const
{
this
-
>
validate
(
)
;
return
fKey
[
kHash_MetaDataIdx
]
;
}
size_t
size
(
)
const
{
this
-
>
validate
(
)
;
SkASSERT
(
this
-
>
isValid
(
)
)
;
return
this
-
>
internalSize
(
)
;
}
void
reset
(
)
{
fKey
.
reset
(
kMetaDataCnt
)
;
fKey
[
kHash_MetaDataIdx
]
=
0
;
fKey
[
kDomainAndSize_MetaDataIdx
]
=
kInvalidDomain
;
}
bool
isValid
(
)
const
{
return
kInvalidDomain
!
=
this
-
>
domain
(
)
;
}
class
Builder
{
public
:
~
Builder
(
)
{
this
-
>
finish
(
)
;
}
void
finish
(
)
{
if
(
nullptr
=
=
fKey
)
{
return
;
}
uint32_t
*
hash
=
&
fKey
-
>
fKey
[
kHash_MetaDataIdx
]
;
*
hash
=
ResourceKeyHash
(
hash
+
1
fKey
-
>
internalSize
(
)
-
sizeof
(
uint32_t
)
)
;
fKey
-
>
validate
(
)
;
fKey
=
nullptr
;
}
uint32_t
&
operator
[
]
(
int
dataIdx
)
{
SkASSERT
(
fKey
)
;
SkDEBUGCODE
(
size_t
dataCount
=
fKey
-
>
internalSize
(
)
/
sizeof
(
uint32_t
)
-
kMetaDataCnt
;
)
SkASSERT
(
SkToU32
(
dataIdx
)
<
dataCount
)
;
return
fKey
-
>
fKey
[
(
int
)
kMetaDataCnt
+
dataIdx
]
;
}
protected
:
Builder
(
ResourceKey
*
key
uint32_t
domain
int
data32Count
)
:
fKey
(
key
)
{
size_t
count
=
SkToSizeT
(
data32Count
)
;
SkASSERT
(
domain
!
=
kInvalidDomain
)
;
key
-
>
fKey
.
reset
(
kMetaDataCnt
+
count
)
;
size_t
size
=
(
count
+
kMetaDataCnt
)
*
sizeof
(
uint32_t
)
;
SkASSERT
(
SkToU16
(
size
)
=
=
size
)
;
SkASSERT
(
SkToU16
(
domain
)
=
=
domain
)
;
key
-
>
fKey
[
kDomainAndSize_MetaDataIdx
]
=
SkToU32
(
domain
|
(
size
<
<
16
)
)
;
}
private
:
ResourceKey
*
fKey
;
}
;
protected
:
static
const
uint32_t
kInvalidDomain
=
0
;
ResourceKey
(
)
{
this
-
>
reset
(
)
;
}
bool
operator
=
=
(
const
ResourceKey
&
that
)
const
{
return
0
=
=
memcmp
(
fKey
.
get
(
)
that
.
fKey
.
get
(
)
kMetaDataCnt
*
sizeof
(
uint32_t
)
)
&
&
0
=
=
memcmp
(
&
fKey
[
kMetaDataCnt
]
&
that
.
fKey
[
kMetaDataCnt
]
this
-
>
dataSize
(
)
)
;
}
ResourceKey
&
operator
=
(
const
ResourceKey
&
that
)
{
if
(
this
!
=
&
that
)
{
if
(
!
that
.
isValid
(
)
)
{
this
-
>
reset
(
)
;
}
else
{
size_t
bytes
=
that
.
size
(
)
;
SkASSERT
(
SkIsAlign4
(
bytes
)
)
;
fKey
.
reset
(
bytes
/
sizeof
(
uint32_t
)
)
;
memcpy
(
fKey
.
get
(
)
that
.
fKey
.
get
(
)
bytes
)
;
this
-
>
validate
(
)
;
}
}
return
*
this
;
}
uint32_t
domain
(
)
const
{
return
fKey
[
kDomainAndSize_MetaDataIdx
]
&
0xffff
;
}
size_t
dataSize
(
)
const
{
return
this
-
>
size
(
)
-
4
*
kMetaDataCnt
;
}
const
uint32_t
*
data
(
)
const
{
this
-
>
validate
(
)
;
return
&
fKey
[
kMetaDataCnt
]
;
}
#
ifdef
SK_DEBUG
void
dump
(
)
const
{
if
(
!
this
-
>
isValid
(
)
)
{
SkDebugf
(
"
Invalid
Key
\
n
"
)
;
}
else
{
SkDebugf
(
"
hash
:
%
d
"
this
-
>
hash
(
)
)
;
SkDebugf
(
"
domain
:
%
d
"
this
-
>
domain
(
)
)
;
SkDebugf
(
"
size
:
%
zuB
"
this
-
>
internalSize
(
)
)
;
size_t
dataCount
=
this
-
>
internalSize
(
)
/
sizeof
(
uint32_t
)
-
kMetaDataCnt
;
for
(
size_t
i
=
0
;
i
<
dataCount
;
+
+
i
)
{
SkDebugf
(
"
%
d
"
fKey
[
SkTo
<
int
>
(
kMetaDataCnt
+
i
)
]
)
;
}
SkDebugf
(
"
\
n
"
)
;
}
}
#
endif
private
:
enum
MetaDataIdx
{
kHash_MetaDataIdx
kDomainAndSize_MetaDataIdx
kLastMetaDataIdx
=
kDomainAndSize_MetaDataIdx
}
;
static
const
uint32_t
kMetaDataCnt
=
kLastMetaDataIdx
+
1
;
size_t
internalSize
(
)
const
{
return
fKey
[
kDomainAndSize_MetaDataIdx
]
>
>
16
;
}
void
validate
(
)
const
{
SkASSERT
(
this
-
>
isValid
(
)
)
;
SkASSERT
(
fKey
[
kHash_MetaDataIdx
]
=
=
ResourceKeyHash
(
&
fKey
[
kHash_MetaDataIdx
]
+
1
this
-
>
internalSize
(
)
-
sizeof
(
uint32_t
)
)
)
;
SkASSERT
(
SkIsAlign4
(
this
-
>
internalSize
(
)
)
)
;
}
friend
class
:
:
TestResource
;
skia_private
:
:
AutoSTMalloc
<
kMetaDataCnt
+
5
uint32_t
>
fKey
;
}
;
class
ScratchKey
:
public
ResourceKey
{
public
:
typedef
uint32_t
ResourceType
;
static
ResourceType
GenerateResourceType
(
)
;
ScratchKey
(
)
{
}
ScratchKey
(
const
ScratchKey
&
that
)
{
*
this
=
that
;
}
ResourceType
resourceType
(
)
const
{
return
this
-
>
domain
(
)
;
}
ScratchKey
&
operator
=
(
const
ScratchKey
&
that
)
{
this
-
>
ResourceKey
:
:
operator
=
(
that
)
;
return
*
this
;
}
bool
operator
=
=
(
const
ScratchKey
&
that
)
const
{
return
this
-
>
ResourceKey
:
:
operator
=
=
(
that
)
;
}
bool
operator
!
=
(
const
ScratchKey
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
class
Builder
:
public
ResourceKey
:
:
Builder
{
public
:
Builder
(
ScratchKey
*
key
ResourceType
type
int
data32Count
)
:
ResourceKey
:
:
Builder
(
key
type
data32Count
)
{
}
}
;
}
;
class
UniqueKey
:
public
ResourceKey
{
public
:
typedef
uint32_t
Domain
;
static
Domain
GenerateDomain
(
)
;
UniqueKey
(
)
:
fTag
(
nullptr
)
{
}
UniqueKey
(
const
UniqueKey
&
that
)
{
*
this
=
that
;
}
UniqueKey
&
operator
=
(
const
UniqueKey
&
that
)
{
this
-
>
ResourceKey
:
:
operator
=
(
that
)
;
this
-
>
setCustomData
(
sk_ref_sp
(
that
.
getCustomData
(
)
)
)
;
fTag
=
that
.
fTag
;
return
*
this
;
}
bool
operator
=
=
(
const
UniqueKey
&
that
)
const
{
return
this
-
>
ResourceKey
:
:
operator
=
=
(
that
)
;
}
bool
operator
!
=
(
const
UniqueKey
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
void
setCustomData
(
sk_sp
<
SkData
>
data
)
{
fData
=
std
:
:
move
(
data
)
;
}
SkData
*
getCustomData
(
)
const
{
return
fData
.
get
(
)
;
}
sk_sp
<
SkData
>
refCustomData
(
)
const
{
return
fData
;
}
const
char
*
tag
(
)
const
{
return
fTag
;
}
#
ifdef
SK_DEBUG
void
dump
(
const
char
*
label
)
const
{
SkDebugf
(
"
%
s
tag
:
%
s
\
n
"
label
fTag
?
fTag
:
"
None
"
)
;
this
-
>
ResourceKey
:
:
dump
(
)
;
}
#
endif
class
Builder
:
public
ResourceKey
:
:
Builder
{
public
:
Builder
(
UniqueKey
*
key
Domain
type
int
data32Count
const
char
*
tag
=
nullptr
)
:
ResourceKey
:
:
Builder
(
key
type
data32Count
)
{
key
-
>
fTag
=
tag
;
}
Builder
(
UniqueKey
*
key
const
UniqueKey
&
innerKey
Domain
domain
int
extraData32Cnt
const
char
*
tag
=
nullptr
)
:
ResourceKey
:
:
Builder
(
key
domain
Data32CntForInnerKey
(
innerKey
)
+
extraData32Cnt
)
{
SkASSERT
(
&
innerKey
!
=
key
)
;
uint32_t
*
innerKeyData
=
&
this
-
>
operator
[
]
(
extraData32Cnt
)
;
const
uint32_t
*
srcData
=
innerKey
.
data
(
)
;
(
*
innerKeyData
+
+
)
=
innerKey
.
domain
(
)
;
memcpy
(
innerKeyData
srcData
innerKey
.
dataSize
(
)
)
;
key
-
>
fTag
=
tag
;
}
private
:
static
int
Data32CntForInnerKey
(
const
UniqueKey
&
innerKey
)
{
return
SkToInt
(
(
innerKey
.
dataSize
(
)
>
>
2
)
+
1
)
;
}
}
;
private
:
sk_sp
<
SkData
>
fData
;
const
char
*
fTag
;
}
;
#
define
SKGPU_DECLARE_STATIC_UNIQUE_KEY
(
name
)
static
SkOnce
name
#
#
_once
#
define
SKGPU_DEFINE_STATIC_UNIQUE_KEY
(
name
)
\
static
SkAlignedSTStorage
<
1
skgpu
:
:
UniqueKey
>
name
#
#
_storage
;
\
name
#
#
_once
(
skgpu
:
:
skgpu_init_static_unique_key_once
&
name
#
#
_storage
)
;
\
static
const
skgpu
:
:
UniqueKey
&
name
=
\
*
reinterpret_cast
<
skgpu
:
:
UniqueKey
*
>
(
name
#
#
_storage
.
get
(
)
)
static
inline
void
skgpu_init_static_unique_key_once
(
SkAlignedSTStorage
<
1
UniqueKey
>
*
keyStorage
)
{
UniqueKey
*
key
=
new
(
keyStorage
-
>
get
(
)
)
UniqueKey
;
UniqueKey
:
:
Builder
builder
(
key
UniqueKey
:
:
GenerateDomain
(
)
0
)
;
}
class
UniqueKeyInvalidatedMessage
{
public
:
UniqueKeyInvalidatedMessage
(
)
=
default
;
UniqueKeyInvalidatedMessage
(
const
UniqueKey
&
key
uint32_t
contextUniqueID
bool
inThreadSafeCache
=
false
)
:
fKey
(
key
)
fContextID
(
contextUniqueID
)
fInThreadSafeCache
(
inThreadSafeCache
)
{
SkASSERT
(
SK_InvalidUniqueID
!
=
contextUniqueID
)
;
}
UniqueKeyInvalidatedMessage
(
const
UniqueKeyInvalidatedMessage
&
)
=
default
;
UniqueKeyInvalidatedMessage
&
operator
=
(
const
UniqueKeyInvalidatedMessage
&
)
=
default
;
const
UniqueKey
&
key
(
)
const
{
return
fKey
;
}
uint32_t
contextID
(
)
const
{
return
fContextID
;
}
bool
inThreadSafeCache
(
)
const
{
return
fInThreadSafeCache
;
}
private
:
UniqueKey
fKey
;
uint32_t
fContextID
=
SK_InvalidUniqueID
;
bool
fInThreadSafeCache
=
false
;
}
;
static
inline
bool
SkShouldPostMessageToBus
(
const
UniqueKeyInvalidatedMessage
&
msg
uint32_t
msgBusUniqueID
)
{
return
msg
.
contextID
(
)
=
=
msgBusUniqueID
;
}
}
#
endif
