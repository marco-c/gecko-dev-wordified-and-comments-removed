#
include
"
GrGpuResource
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrContextPriv
.
h
"
#
include
"
GrResourceCache
.
h
"
#
include
"
GrGpu
.
h
"
#
include
"
GrGpuResourcePriv
.
h
"
#
include
"
SkTraceMemoryDump
.
h
"
static
inline
GrResourceCache
*
get_resource_cache
(
GrGpu
*
gpu
)
{
SkASSERT
(
gpu
)
;
SkASSERT
(
gpu
-
>
getContext
(
)
)
;
SkASSERT
(
gpu
-
>
getContext
(
)
-
>
contextPriv
(
)
.
getResourceCache
(
)
)
;
return
gpu
-
>
getContext
(
)
-
>
contextPriv
(
)
.
getResourceCache
(
)
;
}
GrGpuResource
:
:
GrGpuResource
(
GrGpu
*
gpu
)
:
fGpu
(
gpu
)
fGpuMemorySize
(
kInvalidGpuMemorySize
)
fBudgeted
(
SkBudgeted
:
:
kNo
)
fRefsWrappedObjects
(
false
)
fUniqueID
(
CreateUniqueID
(
)
)
{
SkDEBUGCODE
(
fCacheArrayIndex
=
-
1
)
;
}
void
GrGpuResource
:
:
registerWithCache
(
SkBudgeted
budgeted
)
{
SkASSERT
(
fBudgeted
=
=
SkBudgeted
:
:
kNo
)
;
fBudgeted
=
budgeted
;
this
-
>
computeScratchKey
(
&
fScratchKey
)
;
get_resource_cache
(
fGpu
)
-
>
resourceAccess
(
)
.
insertResource
(
this
)
;
}
void
GrGpuResource
:
:
registerWithCacheWrapped
(
)
{
SkASSERT
(
fBudgeted
=
=
SkBudgeted
:
:
kNo
)
;
fRefsWrappedObjects
=
true
;
get_resource_cache
(
fGpu
)
-
>
resourceAccess
(
)
.
insertResource
(
this
)
;
}
GrGpuResource
:
:
~
GrGpuResource
(
)
{
SkASSERT
(
this
-
>
wasDestroyed
(
)
)
;
}
void
GrGpuResource
:
:
release
(
)
{
SkASSERT
(
fGpu
)
;
this
-
>
onRelease
(
)
;
get_resource_cache
(
fGpu
)
-
>
resourceAccess
(
)
.
removeResource
(
this
)
;
fGpu
=
nullptr
;
fGpuMemorySize
=
0
;
}
void
GrGpuResource
:
:
abandon
(
)
{
if
(
this
-
>
wasDestroyed
(
)
)
{
return
;
}
SkASSERT
(
fGpu
)
;
this
-
>
onAbandon
(
)
;
get_resource_cache
(
fGpu
)
-
>
resourceAccess
(
)
.
removeResource
(
this
)
;
fGpu
=
nullptr
;
fGpuMemorySize
=
0
;
}
void
GrGpuResource
:
:
dumpMemoryStatistics
(
SkTraceMemoryDump
*
traceMemoryDump
)
const
{
if
(
this
-
>
fRefsWrappedObjects
&
&
!
traceMemoryDump
-
>
shouldDumpWrappedObjects
(
)
)
{
return
;
}
this
-
>
dumpMemoryStatisticsPriv
(
traceMemoryDump
this
-
>
getResourceName
(
)
this
-
>
getResourceType
(
)
this
-
>
gpuMemorySize
(
)
)
;
}
void
GrGpuResource
:
:
dumpMemoryStatisticsPriv
(
SkTraceMemoryDump
*
traceMemoryDump
const
SkString
&
resourceName
const
char
*
type
size_t
size
)
const
{
const
char
*
tag
=
"
Scratch
"
;
if
(
fUniqueKey
.
isValid
(
)
)
{
tag
=
(
fUniqueKey
.
tag
(
)
!
=
nullptr
)
?
fUniqueKey
.
tag
(
)
:
"
Other
"
;
}
traceMemoryDump
-
>
dumpNumericValue
(
resourceName
.
c_str
(
)
"
size
"
"
bytes
"
size
)
;
traceMemoryDump
-
>
dumpStringValue
(
resourceName
.
c_str
(
)
"
type
"
type
)
;
traceMemoryDump
-
>
dumpStringValue
(
resourceName
.
c_str
(
)
"
category
"
tag
)
;
if
(
this
-
>
isPurgeable
(
)
)
{
traceMemoryDump
-
>
dumpNumericValue
(
resourceName
.
c_str
(
)
"
purgeable_size
"
"
bytes
"
size
)
;
}
this
-
>
setMemoryBacking
(
traceMemoryDump
resourceName
)
;
}
SkString
GrGpuResource
:
:
getResourceName
(
)
const
{
SkString
resourceName
(
"
skia
/
gpu_resources
/
resource_
"
)
;
resourceName
.
appendU32
(
this
-
>
uniqueID
(
)
.
asUInt
(
)
)
;
return
resourceName
;
}
const
GrContext
*
GrGpuResource
:
:
getContext
(
)
const
{
if
(
fGpu
)
{
return
fGpu
-
>
getContext
(
)
;
}
else
{
return
nullptr
;
}
}
GrContext
*
GrGpuResource
:
:
getContext
(
)
{
if
(
fGpu
)
{
return
fGpu
-
>
getContext
(
)
;
}
else
{
return
nullptr
;
}
}
void
GrGpuResource
:
:
removeUniqueKey
(
)
{
if
(
this
-
>
wasDestroyed
(
)
)
{
return
;
}
SkASSERT
(
fUniqueKey
.
isValid
(
)
)
;
get_resource_cache
(
fGpu
)
-
>
resourceAccess
(
)
.
removeUniqueKey
(
this
)
;
}
void
GrGpuResource
:
:
setUniqueKey
(
const
GrUniqueKey
&
key
)
{
SkASSERT
(
this
-
>
internalHasRef
(
)
)
;
SkASSERT
(
key
.
isValid
(
)
)
;
if
(
SkBudgeted
:
:
kNo
=
=
this
-
>
resourcePriv
(
)
.
isBudgeted
(
)
&
&
!
this
-
>
fRefsWrappedObjects
)
{
return
;
}
if
(
this
-
>
wasDestroyed
(
)
)
{
return
;
}
get_resource_cache
(
fGpu
)
-
>
resourceAccess
(
)
.
changeUniqueKey
(
this
key
)
;
}
void
GrGpuResource
:
:
notifyAllCntsAreZero
(
CntType
lastCntTypeToReachZero
)
const
{
if
(
this
-
>
wasDestroyed
(
)
)
{
delete
this
;
return
;
}
SkASSERT
(
kRef_CntType
!
=
lastCntTypeToReachZero
)
;
GrGpuResource
*
mutableThis
=
const_cast
<
GrGpuResource
*
>
(
this
)
;
static
const
uint32_t
kFlag
=
GrResourceCache
:
:
ResourceAccess
:
:
kAllCntsReachedZero_RefNotificationFlag
;
get_resource_cache
(
fGpu
)
-
>
resourceAccess
(
)
.
notifyCntReachedZero
(
mutableThis
kFlag
)
;
}
bool
GrGpuResource
:
:
notifyRefCountIsZero
(
)
const
{
if
(
this
-
>
wasDestroyed
(
)
)
{
return
true
;
}
GrGpuResource
*
mutableThis
=
const_cast
<
GrGpuResource
*
>
(
this
)
;
uint32_t
flags
=
GrResourceCache
:
:
ResourceAccess
:
:
kRefCntReachedZero_RefNotificationFlag
;
if
(
!
this
-
>
internalHasPendingIO
(
)
)
{
flags
|
=
GrResourceCache
:
:
ResourceAccess
:
:
kAllCntsReachedZero_RefNotificationFlag
;
}
get_resource_cache
(
fGpu
)
-
>
resourceAccess
(
)
.
notifyCntReachedZero
(
mutableThis
flags
)
;
return
false
;
}
void
GrGpuResource
:
:
removeScratchKey
(
)
{
if
(
!
this
-
>
wasDestroyed
(
)
&
&
fScratchKey
.
isValid
(
)
)
{
get_resource_cache
(
fGpu
)
-
>
resourceAccess
(
)
.
willRemoveScratchKey
(
this
)
;
fScratchKey
.
reset
(
)
;
}
}
void
GrGpuResource
:
:
makeBudgeted
(
)
{
if
(
!
this
-
>
wasDestroyed
(
)
&
&
SkBudgeted
:
:
kNo
=
=
fBudgeted
)
{
SkASSERT
(
!
fRefsWrappedObjects
)
;
fBudgeted
=
SkBudgeted
:
:
kYes
;
get_resource_cache
(
fGpu
)
-
>
resourceAccess
(
)
.
didChangeBudgetStatus
(
this
)
;
}
}
void
GrGpuResource
:
:
makeUnbudgeted
(
)
{
if
(
!
this
-
>
wasDestroyed
(
)
&
&
SkBudgeted
:
:
kYes
=
=
fBudgeted
&
&
!
fUniqueKey
.
isValid
(
)
)
{
fBudgeted
=
SkBudgeted
:
:
kNo
;
get_resource_cache
(
fGpu
)
-
>
resourceAccess
(
)
.
didChangeBudgetStatus
(
this
)
;
}
}
uint32_t
GrGpuResource
:
:
CreateUniqueID
(
)
{
static
int32_t
gUniqueID
=
SK_InvalidUniqueID
;
uint32_t
id
;
do
{
id
=
static_cast
<
uint32_t
>
(
sk_atomic_inc
(
&
gUniqueID
)
+
1
)
;
}
while
(
id
=
=
SK_InvalidUniqueID
)
;
return
id
;
}
