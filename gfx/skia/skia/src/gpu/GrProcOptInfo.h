#
ifndef
GrProcOptInfo_DEFINED
#
define
GrProcOptInfo_DEFINED
#
include
"
GrColor
.
h
"
#
include
"
GrInvariantOutput
.
h
"
class
GrDrawBatch
;
class
GrFragmentProcessor
;
class
GrPrimitiveProcessor
;
class
GrProcOptInfo
{
public
:
GrProcOptInfo
(
)
:
fInOut
(
0
static_cast
<
GrColorComponentFlags
>
(
0
)
false
)
fFirstEffectiveProcessorIndex
(
0
)
fInputColorIsUsed
(
true
)
fInputColor
(
0
)
{
}
void
calcWithInitialValues
(
const
GrFragmentProcessor
*
const
*
int
cnt
GrColor
startColor
GrColorComponentFlags
bool
areCoverageStages
bool
isLCD
=
false
)
;
void
initUsingInvariantOutput
(
GrInitInvariantOutput
invOutput
)
;
void
completeCalculations
(
const
GrFragmentProcessor
*
const
processors
[
]
int
cnt
)
;
bool
isSolidWhite
(
)
const
{
return
fInOut
.
isSolidWhite
(
)
;
}
bool
isOpaque
(
)
const
{
return
fInOut
.
isOpaque
(
)
;
}
bool
isSingleComponent
(
)
const
{
return
fInOut
.
isSingleComponent
(
)
;
}
bool
allStagesMultiplyInput
(
)
const
{
return
fInOut
.
allStagesMulInput
(
)
;
}
bool
isFourChannelOutput
(
)
const
{
return
!
fInOut
.
isSingleComponent
(
)
&
&
fInOut
.
isLCDCoverage
(
)
;
}
GrColor
color
(
)
const
{
return
fInOut
.
color
(
)
;
}
GrColorComponentFlags
validFlags
(
)
const
{
return
fInOut
.
validFlags
(
)
;
}
int
firstEffectiveProcessorIndex
(
)
const
{
return
fFirstEffectiveProcessorIndex
;
}
bool
inputColorIsUsed
(
)
const
{
return
fInputColorIsUsed
;
}
GrColor
inputColorToFirstEffectiveProccesor
(
)
const
{
return
fInputColor
;
}
private
:
void
internalCalc
(
const
GrFragmentProcessor
*
const
[
]
int
cnt
)
;
GrInvariantOutput
fInOut
;
int
fFirstEffectiveProcessorIndex
;
bool
fInputColorIsUsed
;
GrColor
fInputColor
;
}
;
#
endif
