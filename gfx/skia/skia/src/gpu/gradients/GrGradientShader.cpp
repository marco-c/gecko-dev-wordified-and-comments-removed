#
include
"
GrGradientShader
.
h
"
#
include
"
GrClampedGradientEffect
.
h
"
#
include
"
GrTiledGradientEffect
.
h
"
#
include
"
GrLinearGradientLayout
.
h
"
#
include
"
GrRadialGradientLayout
.
h
"
#
include
"
GrSweepGradientLayout
.
h
"
#
include
"
GrTwoPointConicalGradientLayout
.
h
"
#
include
"
GrDualIntervalGradientColorizer
.
h
"
#
include
"
GrSingleIntervalGradientColorizer
.
h
"
#
include
"
GrTextureGradientColorizer
.
h
"
#
include
"
GrUnrolledBinaryGradientColorizer
.
h
"
#
include
"
GrGradientBitmapCache
.
h
"
#
include
"
SkGr
.
h
"
#
include
"
GrColor
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrContextPriv
.
h
"
static
const
SkScalar
kLowPrecisionIntervalLimit
=
0
.
01f
;
static
const
int
kMaxNumCachedGradientBitmaps
=
32
;
static
const
int
kGradientTextureSize
=
256
;
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
make_textured_colorizer
(
const
GrColor4f
*
colors
const
SkScalar
*
positions
int
count
bool
premul
const
GrFPArgs
&
args
)
{
static
GrGradientBitmapCache
gCache
(
kMaxNumCachedGradientBitmaps
kGradientTextureSize
)
;
SkColorType
colorType
=
kRGBA_8888_SkColorType
;
if
(
kLow_GrSLPrecision
!
=
GrSLSamplerPrecision
(
args
.
fDstColorSpaceInfo
-
>
config
(
)
)
&
&
args
.
fContext
-
>
contextPriv
(
)
.
caps
(
)
-
>
isConfigTexturable
(
kRGBA_half_GrPixelConfig
)
)
{
colorType
=
kRGBA_F16_SkColorType
;
}
SkAlphaType
alphaType
=
premul
?
kPremul_SkAlphaType
:
kUnpremul_SkAlphaType
;
SkBitmap
bitmap
;
gCache
.
getGradient
(
colors
positions
count
colorType
alphaType
&
bitmap
)
;
SkASSERT
(
1
=
=
bitmap
.
height
(
)
&
&
SkIsPow2
(
bitmap
.
width
(
)
)
)
;
SkASSERT
(
bitmap
.
isImmutable
(
)
)
;
sk_sp
<
GrTextureProxy
>
proxy
=
GrMakeCachedBitmapProxy
(
args
.
fContext
-
>
contextPriv
(
)
.
proxyProvider
(
)
bitmap
)
;
if
(
proxy
=
=
nullptr
)
{
SkDebugf
(
"
Gradient
won
'
t
draw
.
Could
not
create
texture
.
"
)
;
return
nullptr
;
}
return
GrTextureGradientColorizer
:
:
Make
(
std
:
:
move
(
proxy
)
)
;
}
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
make_colorizer
(
const
GrColor4f
*
colors
const
SkScalar
*
positions
int
count
bool
premul
const
GrFPArgs
&
args
)
{
bool
bottomHardStop
=
SkScalarNearlyEqual
(
positions
[
0
]
positions
[
1
]
)
;
bool
topHardStop
=
SkScalarNearlyEqual
(
positions
[
count
-
2
]
positions
[
count
-
1
]
)
;
int
offset
=
0
;
if
(
bottomHardStop
)
{
offset
+
=
1
;
count
-
-
;
}
if
(
topHardStop
)
{
count
-
-
;
}
if
(
count
=
=
2
)
{
return
GrSingleIntervalGradientColorizer
:
:
Make
(
colors
[
offset
]
colors
[
offset
+
1
]
)
;
}
bool
tryAnalyticColorizer
=
count
<
=
GrUnrolledBinaryGradientColorizer
:
:
kMaxColorCount
;
const
GrShaderCaps
*
caps
=
args
.
fContext
-
>
contextPriv
(
)
.
caps
(
)
-
>
shaderCaps
(
)
;
if
(
!
caps
-
>
floatIs32Bits
(
)
&
&
tryAnalyticColorizer
)
{
for
(
int
i
=
offset
;
i
<
count
-
1
;
i
+
+
)
{
SkScalar
dt
=
SkScalarAbs
(
positions
[
i
]
-
positions
[
i
+
1
]
)
;
if
(
dt
<
=
kLowPrecisionIntervalLimit
&
&
dt
>
SK_ScalarNearlyZero
)
{
tryAnalyticColorizer
=
false
;
break
;
}
}
}
if
(
tryAnalyticColorizer
)
{
if
(
count
=
=
3
)
{
return
GrDualIntervalGradientColorizer
:
:
Make
(
colors
[
offset
]
colors
[
offset
+
1
]
colors
[
offset
+
1
]
colors
[
offset
+
2
]
positions
[
offset
+
1
]
)
;
}
else
if
(
count
=
=
4
&
&
SkScalarNearlyEqual
(
positions
[
offset
+
1
]
positions
[
offset
+
2
]
)
)
{
return
GrDualIntervalGradientColorizer
:
:
Make
(
colors
[
offset
]
colors
[
offset
+
1
]
colors
[
offset
+
2
]
colors
[
offset
+
3
]
positions
[
offset
+
1
]
)
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
unrolled
=
GrUnrolledBinaryGradientColorizer
:
:
Make
(
colors
+
offset
positions
+
offset
count
)
;
if
(
unrolled
)
{
return
unrolled
;
}
}
return
make_textured_colorizer
(
colors
+
offset
positions
+
offset
count
premul
args
)
;
}
static
std
:
:
unique_ptr
<
GrFragmentProcessor
>
make_gradient
(
const
SkGradientShaderBase
&
shader
const
GrFPArgs
&
args
std
:
:
unique_ptr
<
GrFragmentProcessor
>
layout
)
{
if
(
layout
=
=
nullptr
)
{
return
nullptr
;
}
bool
inputPremul
=
shader
.
getGradFlags
(
)
&
SkGradientShader
:
:
kInterpolateColorsInPremul_Flag
;
bool
allOpaque
=
true
;
SkAutoSTMalloc
<
4
GrColor4f
>
colors
(
shader
.
fColorCount
)
;
SkColor4fXformer
xformedColors
(
shader
.
fOrigColors4f
shader
.
fColorCount
shader
.
fColorSpace
.
get
(
)
args
.
fDstColorSpaceInfo
-
>
colorSpace
(
)
)
;
for
(
int
i
=
0
;
i
<
shader
.
fColorCount
;
i
+
+
)
{
colors
[
i
]
=
GrColor4f
:
:
FromRGBA4f
(
xformedColors
.
fColors
[
i
]
)
;
if
(
inputPremul
)
{
colors
[
i
]
=
colors
[
i
]
.
premul
(
)
;
}
if
(
allOpaque
&
&
!
SkScalarNearlyEqual
(
colors
[
i
]
.
fRGBA
[
3
]
1
.
0
)
)
{
allOpaque
=
false
;
}
}
SkTArray
<
SkScalar
true
>
implicitPos
;
SkScalar
*
positions
;
if
(
shader
.
fOrigPos
)
{
positions
=
shader
.
fOrigPos
;
}
else
{
implicitPos
.
reserve
(
shader
.
fColorCount
)
;
SkScalar
posScale
=
SkScalarFastInvert
(
shader
.
fColorCount
-
1
)
;
for
(
int
i
=
0
;
i
<
shader
.
fColorCount
;
i
+
+
)
{
implicitPos
.
push_back
(
SkIntToScalar
(
i
)
*
posScale
)
;
}
positions
=
implicitPos
.
begin
(
)
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
colorizer
=
make_colorizer
(
colors
.
get
(
)
positions
shader
.
fColorCount
inputPremul
args
)
;
if
(
colorizer
=
=
nullptr
)
{
return
nullptr
;
}
bool
makePremul
=
!
inputPremul
&
&
!
allOpaque
;
std
:
:
unique_ptr
<
GrFragmentProcessor
>
master
;
switch
(
shader
.
getTileMode
(
)
)
{
case
SkShader
:
:
kRepeat_TileMode
:
master
=
GrTiledGradientEffect
:
:
Make
(
std
:
:
move
(
colorizer
)
std
:
:
move
(
layout
)
false
makePremul
allOpaque
)
;
break
;
case
SkShader
:
:
kMirror_TileMode
:
master
=
GrTiledGradientEffect
:
:
Make
(
std
:
:
move
(
colorizer
)
std
:
:
move
(
layout
)
true
makePremul
allOpaque
)
;
break
;
case
SkShader
:
:
kClamp_TileMode
:
master
=
GrClampedGradientEffect
:
:
Make
(
std
:
:
move
(
colorizer
)
std
:
:
move
(
layout
)
colors
[
0
]
colors
[
shader
.
fColorCount
-
1
]
makePremul
allOpaque
)
;
break
;
case
SkShader
:
:
kDecal_TileMode
:
master
=
GrClampedGradientEffect
:
:
Make
(
std
:
:
move
(
colorizer
)
std
:
:
move
(
layout
)
GrColor4f
:
:
TransparentBlack
(
)
GrColor4f
:
:
TransparentBlack
(
)
makePremul
false
)
;
break
;
}
if
(
master
=
=
nullptr
)
{
return
nullptr
;
}
return
GrFragmentProcessor
:
:
MulChildByInputAlpha
(
std
:
:
move
(
master
)
)
;
}
namespace
GrGradientShader
{
std
:
:
unique_ptr
<
GrFragmentProcessor
>
MakeLinear
(
const
SkLinearGradient
&
shader
const
GrFPArgs
&
args
)
{
return
make_gradient
(
shader
args
GrLinearGradientLayout
:
:
Make
(
shader
args
)
)
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
MakeRadial
(
const
SkRadialGradient
&
shader
const
GrFPArgs
&
args
)
{
return
make_gradient
(
shader
args
GrRadialGradientLayout
:
:
Make
(
shader
args
)
)
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
MakeSweep
(
const
SkSweepGradient
&
shader
const
GrFPArgs
&
args
)
{
return
make_gradient
(
shader
args
GrSweepGradientLayout
:
:
Make
(
shader
args
)
)
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
MakeConical
(
const
SkTwoPointConicalGradient
&
shader
const
GrFPArgs
&
args
)
{
return
make_gradient
(
shader
args
GrTwoPointConicalGradientLayout
:
:
Make
(
shader
args
)
)
;
}
#
if
GR_TEST_UTILS
RandomParams
:
:
RandomParams
(
SkRandom
*
random
)
{
fColorCount
=
random
-
>
nextRangeU
(
2
kMaxRandomGradientColors
)
;
fUseColors4f
=
random
-
>
nextBool
(
)
;
if
(
fColorCount
=
=
1
|
|
(
fColorCount
>
=
2
&
&
random
-
>
nextBool
(
)
)
)
{
fStops
=
nullptr
;
}
else
{
fStops
=
fStopStorage
;
}
if
(
fUseColors4f
)
{
fColorSpace
=
GrTest
:
:
TestColorSpace
(
random
)
;
}
SkScalar
stop
=
0
.
f
;
for
(
int
i
=
0
;
i
<
fColorCount
;
+
+
i
)
{
if
(
fUseColors4f
)
{
fColors4f
[
i
]
.
fR
=
random
-
>
nextUScalar1
(
)
;
fColors4f
[
i
]
.
fG
=
random
-
>
nextUScalar1
(
)
;
fColors4f
[
i
]
.
fB
=
random
-
>
nextUScalar1
(
)
;
fColors4f
[
i
]
.
fA
=
random
-
>
nextUScalar1
(
)
;
}
else
{
fColors
[
i
]
=
random
-
>
nextU
(
)
;
}
if
(
fStops
)
{
fStops
[
i
]
=
stop
;
stop
=
i
<
fColorCount
-
1
?
stop
+
random
-
>
nextUScalar1
(
)
*
(
1
.
f
-
stop
)
:
1
.
f
;
}
}
fTileMode
=
static_cast
<
SkShader
:
:
TileMode
>
(
random
-
>
nextULessThan
(
SkShader
:
:
kTileModeCount
)
)
;
}
#
endif
}
