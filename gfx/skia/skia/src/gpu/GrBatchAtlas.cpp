#
include
"
GrBatchAtlas
.
h
"
#
include
"
GrBatchFlushState
.
h
"
#
include
"
GrRectanizer
.
h
"
#
include
"
GrTracing
.
h
"
GrBatchAtlas
:
:
BatchPlot
:
:
BatchPlot
(
int
index
uint64_t
genID
int
offX
int
offY
int
width
int
height
GrPixelConfig
config
)
:
fLastUpload
(
GrBatchDrawToken
:
:
AlreadyFlushedToken
(
)
)
fLastUse
(
GrBatchDrawToken
:
:
AlreadyFlushedToken
(
)
)
fIndex
(
index
)
fGenID
(
genID
)
fID
(
CreateId
(
fIndex
fGenID
)
)
fData
(
nullptr
)
fWidth
(
width
)
fHeight
(
height
)
fX
(
offX
)
fY
(
offY
)
fRects
(
nullptr
)
fOffset
(
SkIPoint16
:
:
Make
(
fX
*
fWidth
fY
*
fHeight
)
)
fConfig
(
config
)
fBytesPerPixel
(
GrBytesPerPixel
(
config
)
)
#
ifdef
SK_DEBUG
fDirty
(
false
)
#
endif
{
fDirtyRect
.
setEmpty
(
)
;
}
GrBatchAtlas
:
:
BatchPlot
:
:
~
BatchPlot
(
)
{
sk_free
(
fData
)
;
delete
fRects
;
}
bool
GrBatchAtlas
:
:
BatchPlot
:
:
addSubImage
(
int
width
int
height
const
void
*
image
SkIPoint16
*
loc
)
{
SkASSERT
(
width
<
=
fWidth
&
&
height
<
=
fHeight
)
;
if
(
!
fRects
)
{
fRects
=
GrRectanizer
:
:
Factory
(
fWidth
fHeight
)
;
}
if
(
!
fRects
-
>
addRect
(
width
height
loc
)
)
{
return
false
;
}
if
(
!
fData
)
{
fData
=
reinterpret_cast
<
unsigned
char
*
>
(
sk_calloc_throw
(
fBytesPerPixel
*
fWidth
*
fHeight
)
)
;
}
size_t
rowBytes
=
width
*
fBytesPerPixel
;
const
unsigned
char
*
imagePtr
=
(
const
unsigned
char
*
)
image
;
unsigned
char
*
dataPtr
=
fData
;
dataPtr
+
=
fBytesPerPixel
*
fWidth
*
loc
-
>
fY
;
dataPtr
+
=
fBytesPerPixel
*
loc
-
>
fX
;
for
(
int
i
=
0
;
i
<
height
;
+
+
i
)
{
memcpy
(
dataPtr
imagePtr
rowBytes
)
;
dataPtr
+
=
fBytesPerPixel
*
fWidth
;
imagePtr
+
=
rowBytes
;
}
fDirtyRect
.
join
(
loc
-
>
fX
loc
-
>
fY
loc
-
>
fX
+
width
loc
-
>
fY
+
height
)
;
loc
-
>
fX
+
=
fOffset
.
fX
;
loc
-
>
fY
+
=
fOffset
.
fY
;
SkDEBUGCODE
(
fDirty
=
true
;
)
return
true
;
}
void
GrBatchAtlas
:
:
BatchPlot
:
:
uploadToTexture
(
GrDrawBatch
:
:
WritePixelsFn
&
writePixels
GrTexture
*
texture
)
{
SkASSERT
(
fDirty
&
&
fData
&
&
texture
)
;
TRACE_EVENT0
(
TRACE_DISABLED_BY_DEFAULT
(
"
skia
.
gpu
"
)
"
GrBatchPlot
:
:
uploadToTexture
"
)
;
size_t
rowBytes
=
fBytesPerPixel
*
fWidth
;
const
unsigned
char
*
dataPtr
=
fData
;
dataPtr
+
=
rowBytes
*
fDirtyRect
.
fTop
;
dataPtr
+
=
fBytesPerPixel
*
fDirtyRect
.
fLeft
;
writePixels
(
texture
fOffset
.
fX
+
fDirtyRect
.
fLeft
fOffset
.
fY
+
fDirtyRect
.
fTop
fDirtyRect
.
width
(
)
fDirtyRect
.
height
(
)
fConfig
dataPtr
rowBytes
)
;
fDirtyRect
.
setEmpty
(
)
;
SkDEBUGCODE
(
fDirty
=
false
;
)
}
void
GrBatchAtlas
:
:
BatchPlot
:
:
resetRects
(
)
{
if
(
fRects
)
{
fRects
-
>
reset
(
)
;
}
fGenID
+
+
;
fID
=
CreateId
(
fIndex
fGenID
)
;
if
(
fData
)
{
sk_bzero
(
fData
fBytesPerPixel
*
fWidth
*
fHeight
)
;
}
fDirtyRect
.
setEmpty
(
)
;
SkDEBUGCODE
(
fDirty
=
false
;
)
}
GrBatchAtlas
:
:
GrBatchAtlas
(
GrTexture
*
texture
int
numPlotsX
int
numPlotsY
)
:
fTexture
(
texture
)
fAtlasGeneration
(
kInvalidAtlasGeneration
+
1
)
{
int
plotWidth
=
texture
-
>
width
(
)
/
numPlotsX
;
int
plotHeight
=
texture
-
>
height
(
)
/
numPlotsY
;
SkASSERT
(
numPlotsX
*
numPlotsY
<
=
BulkUseTokenUpdater
:
:
kMaxPlots
)
;
SkASSERT
(
plotWidth
*
numPlotsX
=
=
texture
-
>
width
(
)
)
;
SkASSERT
(
plotHeight
*
numPlotsY
=
=
texture
-
>
height
(
)
)
;
SkDEBUGCODE
(
fNumPlots
=
numPlotsX
*
numPlotsY
;
)
SkASSERT
(
!
GrPixelConfigIsCompressed
(
texture
-
>
desc
(
)
.
fConfig
)
)
;
fPlotArray
=
new
SkAutoTUnref
<
BatchPlot
>
[
numPlotsX
*
numPlotsY
]
;
SkAutoTUnref
<
BatchPlot
>
*
currPlot
=
fPlotArray
;
for
(
int
y
=
numPlotsY
-
1
r
=
0
;
y
>
=
0
;
-
-
y
+
+
r
)
{
for
(
int
x
=
numPlotsX
-
1
c
=
0
;
x
>
=
0
;
-
-
x
+
+
c
)
{
uint32_t
index
=
r
*
numPlotsX
+
c
;
currPlot
-
>
reset
(
new
BatchPlot
(
index
1
x
y
plotWidth
plotHeight
texture
-
>
desc
(
)
.
fConfig
)
)
;
fPlotList
.
addToHead
(
currPlot
-
>
get
(
)
)
;
+
+
currPlot
;
}
}
}
GrBatchAtlas
:
:
~
GrBatchAtlas
(
)
{
SkSafeUnref
(
fTexture
)
;
delete
[
]
fPlotArray
;
}
void
GrBatchAtlas
:
:
processEviction
(
AtlasID
id
)
{
for
(
int
i
=
0
;
i
<
fEvictionCallbacks
.
count
(
)
;
i
+
+
)
{
(
*
fEvictionCallbacks
[
i
]
.
fFunc
)
(
id
fEvictionCallbacks
[
i
]
.
fData
)
;
}
}
inline
void
GrBatchAtlas
:
:
updatePlot
(
GrDrawBatch
:
:
Target
*
target
AtlasID
*
id
BatchPlot
*
plot
)
{
this
-
>
makeMRU
(
plot
)
;
if
(
target
-
>
hasDrawBeenFlushed
(
plot
-
>
lastUploadToken
(
)
)
)
{
sk_sp
<
BatchPlot
>
plotsp
(
SkRef
(
plot
)
)
;
GrTexture
*
texture
=
fTexture
;
GrBatchDrawToken
lastUploadToken
=
target
-
>
addAsapUpload
(
[
plotsp
texture
]
(
GrDrawBatch
:
:
WritePixelsFn
&
writePixels
)
{
plotsp
-
>
uploadToTexture
(
writePixels
texture
)
;
}
)
;
plot
-
>
setLastUploadToken
(
lastUploadToken
)
;
}
*
id
=
plot
-
>
id
(
)
;
}
bool
GrBatchAtlas
:
:
addToAtlas
(
AtlasID
*
id
GrDrawBatch
:
:
Target
*
target
int
width
int
height
const
void
*
image
SkIPoint16
*
loc
)
{
SkASSERT
(
fTexture
)
;
GrBatchPlotList
:
:
Iter
plotIter
;
plotIter
.
init
(
fPlotList
GrBatchPlotList
:
:
Iter
:
:
kHead_IterStart
)
;
BatchPlot
*
plot
;
while
(
(
plot
=
plotIter
.
get
(
)
)
)
{
SkASSERT
(
GrBytesPerPixel
(
fTexture
-
>
desc
(
)
.
fConfig
)
=
=
plot
-
>
bpp
(
)
)
;
if
(
plot
-
>
addSubImage
(
width
height
image
loc
)
)
{
this
-
>
updatePlot
(
target
id
plot
)
;
return
true
;
}
plotIter
.
next
(
)
;
}
plot
=
fPlotList
.
tail
(
)
;
SkASSERT
(
plot
)
;
if
(
target
-
>
hasDrawBeenFlushed
(
plot
-
>
lastUseToken
(
)
)
)
{
this
-
>
processEviction
(
plot
-
>
id
(
)
)
;
plot
-
>
resetRects
(
)
;
SkASSERT
(
GrBytesPerPixel
(
fTexture
-
>
desc
(
)
.
fConfig
)
=
=
plot
-
>
bpp
(
)
)
;
SkDEBUGCODE
(
bool
verify
=
)
plot
-
>
addSubImage
(
width
height
image
loc
)
;
SkASSERT
(
verify
)
;
this
-
>
updatePlot
(
target
id
plot
)
;
fAtlasGeneration
+
+
;
return
true
;
}
if
(
plot
-
>
lastUseToken
(
)
=
=
target
-
>
nextDrawToken
(
)
)
{
return
false
;
}
SkASSERT
(
!
plot
-
>
unique
(
)
)
;
this
-
>
processEviction
(
plot
-
>
id
(
)
)
;
fPlotList
.
remove
(
plot
)
;
SkAutoTUnref
<
BatchPlot
>
&
newPlot
=
fPlotArray
[
plot
-
>
index
(
)
]
;
newPlot
.
reset
(
plot
-
>
clone
(
)
)
;
fPlotList
.
addToHead
(
newPlot
.
get
(
)
)
;
SkASSERT
(
GrBytesPerPixel
(
fTexture
-
>
desc
(
)
.
fConfig
)
=
=
newPlot
-
>
bpp
(
)
)
;
SkDEBUGCODE
(
bool
verify
=
)
newPlot
-
>
addSubImage
(
width
height
image
loc
)
;
SkASSERT
(
verify
)
;
sk_sp
<
BatchPlot
>
plotsp
(
SkRef
(
newPlot
.
get
(
)
)
)
;
GrTexture
*
texture
=
fTexture
;
GrBatchDrawToken
lastUploadToken
=
target
-
>
addInlineUpload
(
[
plotsp
texture
]
(
GrDrawBatch
:
:
WritePixelsFn
&
writePixels
)
{
plotsp
-
>
uploadToTexture
(
writePixels
texture
)
;
}
)
;
newPlot
-
>
setLastUploadToken
(
lastUploadToken
)
;
*
id
=
newPlot
-
>
id
(
)
;
fAtlasGeneration
+
+
;
return
true
;
}
