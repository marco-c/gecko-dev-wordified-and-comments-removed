#
include
"
GrOpList
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrDeferredProxyUploader
.
h
"
#
include
"
GrSurfaceProxy
.
h
"
#
include
"
GrTextureProxyPriv
.
h
"
#
include
"
SkAtomics
.
h
"
uint32_t
GrOpList
:
:
CreateUniqueID
(
)
{
static
int32_t
gUniqueID
=
SK_InvalidUniqueID
;
uint32_t
id
;
do
{
id
=
static_cast
<
uint32_t
>
(
sk_atomic_inc
(
&
gUniqueID
)
+
1
)
;
}
while
(
id
=
=
SK_InvalidUniqueID
)
;
return
id
;
}
GrOpList
:
:
GrOpList
(
GrResourceProvider
*
resourceProvider
GrSurfaceProxy
*
surfaceProxy
GrAuditTrail
*
auditTrail
)
:
fAuditTrail
(
auditTrail
)
fUniqueID
(
CreateUniqueID
(
)
)
fFlags
(
0
)
{
fTarget
.
setProxy
(
sk_ref_sp
(
surfaceProxy
)
kWrite_GrIOType
)
;
fTarget
.
get
(
)
-
>
setLastOpList
(
this
)
;
if
(
resourceProvider
&
&
!
resourceProvider
-
>
explicitlyAllocateGPUResources
(
)
)
{
fTarget
.
get
(
)
-
>
instantiate
(
resourceProvider
)
;
}
fTarget
.
markPendingIO
(
)
;
}
GrOpList
:
:
~
GrOpList
(
)
{
if
(
fTarget
.
get
(
)
&
&
this
=
=
fTarget
.
get
(
)
-
>
getLastOpList
(
)
)
{
fTarget
.
get
(
)
-
>
setLastOpList
(
nullptr
)
;
}
}
bool
GrOpList
:
:
instantiate
(
GrResourceProvider
*
resourceProvider
)
{
return
SkToBool
(
fTarget
.
get
(
)
-
>
instantiate
(
resourceProvider
)
)
;
}
void
GrOpList
:
:
endFlush
(
)
{
if
(
fTarget
.
get
(
)
&
&
this
=
=
fTarget
.
get
(
)
-
>
getLastOpList
(
)
)
{
fTarget
.
get
(
)
-
>
setLastOpList
(
nullptr
)
;
}
fTarget
.
reset
(
)
;
fDeferredProxies
.
reset
(
)
;
fAuditTrail
=
nullptr
;
}
void
GrOpList
:
:
instantiateDeferredProxies
(
GrResourceProvider
*
resourceProvider
)
{
for
(
int
i
=
0
;
i
<
fDeferredProxies
.
count
(
)
;
+
+
i
)
{
if
(
resourceProvider
-
>
explicitlyAllocateGPUResources
(
)
)
{
SkASSERT
(
fDeferredProxies
[
i
]
-
>
priv
(
)
.
isInstantiated
(
)
)
;
}
else
{
fDeferredProxies
[
i
]
-
>
instantiate
(
resourceProvider
)
;
}
}
}
void
GrOpList
:
:
prepare
(
GrOpFlushState
*
flushState
)
{
for
(
int
i
=
0
;
i
<
fDeferredProxies
.
count
(
)
;
+
+
i
)
{
fDeferredProxies
[
i
]
-
>
texPriv
(
)
.
scheduleUpload
(
flushState
)
;
}
this
-
>
onPrepare
(
flushState
)
;
}
void
GrOpList
:
:
addDependency
(
GrOpList
*
dependedOn
)
{
SkASSERT
(
!
dependedOn
-
>
dependsOn
(
this
)
)
;
if
(
this
-
>
dependsOn
(
dependedOn
)
)
{
return
;
}
fDependencies
.
push_back
(
dependedOn
)
;
}
void
GrOpList
:
:
addDependency
(
GrSurfaceProxy
*
dependedOn
const
GrCaps
&
caps
)
{
if
(
dependedOn
-
>
getLastOpList
(
)
)
{
SkASSERT
(
!
this
-
>
isClosed
(
)
)
;
GrOpList
*
opList
=
dependedOn
-
>
getLastOpList
(
)
;
if
(
opList
=
=
this
)
{
}
else
{
this
-
>
addDependency
(
opList
)
;
opList
-
>
makeClosed
(
caps
)
;
}
}
if
(
GrTextureProxy
*
textureProxy
=
dependedOn
-
>
asTextureProxy
(
)
)
{
if
(
textureProxy
-
>
texPriv
(
)
.
isDeferred
(
)
)
{
fDeferredProxies
.
push_back
(
textureProxy
)
;
}
}
}
bool
GrOpList
:
:
isInstantiated
(
)
const
{
return
fTarget
.
get
(
)
-
>
priv
(
)
.
isInstantiated
(
)
;
}
#
ifdef
SK_DEBUG
void
GrOpList
:
:
dump
(
)
const
{
SkDebugf
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
SkDebugf
(
"
node
:
%
d
-
>
RT
:
%
d
\
n
"
fUniqueID
fTarget
.
get
(
)
?
fTarget
.
get
(
)
-
>
uniqueID
(
)
.
asUInt
(
)
:
-
1
)
;
SkDebugf
(
"
relies
On
(
%
d
)
:
"
fDependencies
.
count
(
)
)
;
for
(
int
i
=
0
;
i
<
fDependencies
.
count
(
)
;
+
+
i
)
{
SkDebugf
(
"
%
d
"
fDependencies
[
i
]
-
>
fUniqueID
)
;
}
SkDebugf
(
"
\
n
"
)
;
}
#
endif
