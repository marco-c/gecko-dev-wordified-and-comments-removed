#
include
"
GrOpList
.
h
"
#
include
"
GrContext
.
h
"
#
include
"
GrDeferredProxyUploader
.
h
"
#
include
"
GrMemoryPool
.
h
"
#
include
"
GrRenderTargetPriv
.
h
"
#
include
"
GrSurfaceProxy
.
h
"
#
include
"
GrTextureProxyPriv
.
h
"
#
include
"
SkAtomics
.
h
"
uint32_t
GrOpList
:
:
CreateUniqueID
(
)
{
static
int32_t
gUniqueID
=
SK_InvalidUniqueID
;
uint32_t
id
;
do
{
id
=
static_cast
<
uint32_t
>
(
sk_atomic_inc
(
&
gUniqueID
)
+
1
)
;
}
while
(
id
=
=
SK_InvalidUniqueID
)
;
return
id
;
}
GrOpList
:
:
GrOpList
(
GrResourceProvider
*
resourceProvider
sk_sp
<
GrOpMemoryPool
>
opMemoryPool
GrSurfaceProxy
*
surfaceProxy
GrAuditTrail
*
auditTrail
)
:
fOpMemoryPool
(
std
:
:
move
(
opMemoryPool
)
)
fAuditTrail
(
auditTrail
)
fUniqueID
(
CreateUniqueID
(
)
)
fFlags
(
0
)
{
SkASSERT
(
fOpMemoryPool
)
;
fTarget
.
setProxy
(
sk_ref_sp
(
surfaceProxy
)
kWrite_GrIOType
)
;
fTarget
.
get
(
)
-
>
setLastOpList
(
this
)
;
if
(
resourceProvider
&
&
!
resourceProvider
-
>
explicitlyAllocateGPUResources
(
)
)
{
fTarget
.
get
(
)
-
>
instantiate
(
resourceProvider
)
;
}
fTarget
.
markPendingIO
(
)
;
}
GrOpList
:
:
~
GrOpList
(
)
{
if
(
fTarget
.
get
(
)
&
&
this
=
=
fTarget
.
get
(
)
-
>
getLastOpList
(
)
)
{
fTarget
.
get
(
)
-
>
setLastOpList
(
nullptr
)
;
}
}
bool
GrOpList
:
:
instantiate
(
GrResourceProvider
*
resourceProvider
)
{
return
SkToBool
(
fTarget
.
get
(
)
-
>
instantiate
(
resourceProvider
)
)
;
}
void
GrOpList
:
:
endFlush
(
)
{
if
(
fTarget
.
get
(
)
&
&
this
=
=
fTarget
.
get
(
)
-
>
getLastOpList
(
)
)
{
fTarget
.
get
(
)
-
>
setLastOpList
(
nullptr
)
;
}
fTarget
.
reset
(
)
;
fDeferredProxies
.
reset
(
)
;
fAuditTrail
=
nullptr
;
}
void
GrOpList
:
:
instantiateDeferredProxies
(
GrResourceProvider
*
resourceProvider
)
{
for
(
int
i
=
0
;
i
<
fDeferredProxies
.
count
(
)
;
+
+
i
)
{
if
(
resourceProvider
-
>
explicitlyAllocateGPUResources
(
)
)
{
SkASSERT
(
fDeferredProxies
[
i
]
-
>
isInstantiated
(
)
)
;
}
else
{
fDeferredProxies
[
i
]
-
>
instantiate
(
resourceProvider
)
;
}
}
}
void
GrOpList
:
:
prepare
(
GrOpFlushState
*
flushState
)
{
for
(
int
i
=
0
;
i
<
fDeferredProxies
.
count
(
)
;
+
+
i
)
{
fDeferredProxies
[
i
]
-
>
texPriv
(
)
.
scheduleUpload
(
flushState
)
;
}
this
-
>
onPrepare
(
flushState
)
;
}
void
GrOpList
:
:
addDependency
(
GrOpList
*
dependedOn
)
{
SkASSERT
(
!
dependedOn
-
>
dependsOn
(
this
)
)
;
if
(
this
-
>
dependsOn
(
dependedOn
)
)
{
return
;
}
fDependencies
.
push_back
(
dependedOn
)
;
dependedOn
-
>
addDependent
(
this
)
;
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
}
void
GrOpList
:
:
addDependency
(
GrSurfaceProxy
*
dependedOn
const
GrCaps
&
caps
)
{
if
(
dependedOn
-
>
getLastOpList
(
)
)
{
SkASSERT
(
!
this
-
>
isClosed
(
)
)
;
GrOpList
*
opList
=
dependedOn
-
>
getLastOpList
(
)
;
if
(
opList
=
=
this
)
{
}
else
{
this
-
>
addDependency
(
opList
)
;
opList
-
>
makeClosed
(
caps
)
;
}
}
if
(
GrTextureProxy
*
textureProxy
=
dependedOn
-
>
asTextureProxy
(
)
)
{
if
(
textureProxy
-
>
texPriv
(
)
.
isDeferred
(
)
)
{
fDeferredProxies
.
push_back
(
textureProxy
)
;
}
}
}
bool
GrOpList
:
:
dependsOn
(
const
GrOpList
*
dependedOn
)
const
{
for
(
int
i
=
0
;
i
<
fDependencies
.
count
(
)
;
+
+
i
)
{
if
(
fDependencies
[
i
]
=
=
dependedOn
)
{
return
true
;
}
}
return
false
;
}
void
GrOpList
:
:
addDependent
(
GrOpList
*
dependent
)
{
fDependents
.
push_back
(
dependent
)
;
}
#
ifdef
SK_DEBUG
bool
GrOpList
:
:
isDependedent
(
const
GrOpList
*
dependent
)
const
{
for
(
int
i
=
0
;
i
<
fDependents
.
count
(
)
;
+
+
i
)
{
if
(
fDependents
[
i
]
=
=
dependent
)
{
return
true
;
}
}
return
false
;
}
void
GrOpList
:
:
validate
(
)
const
{
for
(
int
i
=
0
;
i
<
fDependencies
.
count
(
)
;
+
+
i
)
{
SkASSERT
(
fDependencies
[
i
]
-
>
isDependedent
(
this
)
)
;
}
}
#
endif
bool
GrOpList
:
:
isInstantiated
(
)
const
{
return
fTarget
.
get
(
)
-
>
isInstantiated
(
)
;
}
void
GrOpList
:
:
closeThoseWhoDependOnMe
(
const
GrCaps
&
caps
)
{
for
(
int
i
=
0
;
i
<
fDependents
.
count
(
)
;
+
+
i
)
{
if
(
!
fDependents
[
i
]
-
>
isClosed
(
)
)
{
fDependents
[
i
]
-
>
makeClosed
(
caps
)
;
}
}
}
bool
GrOpList
:
:
isFullyInstantiated
(
)
const
{
if
(
!
this
-
>
isInstantiated
(
)
)
{
return
false
;
}
GrSurfaceProxy
*
proxy
=
fTarget
.
get
(
)
;
bool
needsStencil
=
proxy
-
>
asRenderTargetProxy
(
)
?
proxy
-
>
asRenderTargetProxy
(
)
-
>
needsStencil
(
)
:
false
;
if
(
needsStencil
)
{
GrRenderTarget
*
rt
=
proxy
-
>
peekRenderTarget
(
)
;
if
(
!
rt
-
>
renderTargetPriv
(
)
.
getStencilAttachment
(
)
)
{
return
false
;
}
}
GrSurface
*
surface
=
proxy
-
>
peekSurface
(
)
;
if
(
surface
-
>
wasDestroyed
(
)
)
{
return
false
;
}
return
true
;
}
#
ifdef
SK_DEBUG
static
const
char
*
op_to_name
(
GrLoadOp
op
)
{
return
GrLoadOp
:
:
kLoad
=
=
op
?
"
load
"
:
GrLoadOp
:
:
kClear
=
=
op
?
"
clear
"
:
"
discard
"
;
}
void
GrOpList
:
:
dump
(
bool
printDependencies
)
const
{
SkDebugf
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
SkDebugf
(
"
opListID
:
%
d
-
proxyID
:
%
d
-
surfaceID
:
%
d
\
n
"
fUniqueID
fTarget
.
get
(
)
?
fTarget
.
get
(
)
-
>
uniqueID
(
)
.
asUInt
(
)
:
-
1
fTarget
.
get
(
)
&
&
fTarget
.
get
(
)
-
>
peekSurface
(
)
?
fTarget
.
get
(
)
-
>
peekSurface
(
)
-
>
uniqueID
(
)
.
asUInt
(
)
:
-
1
)
;
SkDebugf
(
"
ColorLoadOp
:
%
s
%
x
StencilLoadOp
:
%
s
\
n
"
op_to_name
(
fColorLoadOp
)
GrLoadOp
:
:
kClear
=
=
fColorLoadOp
?
fLoadClearColor
:
0x0
op_to_name
(
fStencilLoadOp
)
)
;
if
(
printDependencies
)
{
SkDebugf
(
"
I
rely
On
(
%
d
)
:
"
fDependencies
.
count
(
)
)
;
for
(
int
i
=
0
;
i
<
fDependencies
.
count
(
)
;
+
+
i
)
{
SkDebugf
(
"
%
d
"
fDependencies
[
i
]
-
>
fUniqueID
)
;
}
SkDebugf
(
"
\
n
"
)
;
SkDebugf
(
"
(
%
d
)
Rely
On
Me
:
"
fDependents
.
count
(
)
)
;
for
(
int
i
=
0
;
i
<
fDependents
.
count
(
)
;
+
+
i
)
{
SkDebugf
(
"
%
d
"
fDependents
[
i
]
-
>
fUniqueID
)
;
}
SkDebugf
(
"
\
n
"
)
;
}
}
#
endif
