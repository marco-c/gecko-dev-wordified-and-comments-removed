#
ifndef
GrResourceCache_DEFINED
#
define
GrResourceCache_DEFINED
#
include
"
GrGpuResource
.
h
"
#
include
"
GrGpuResourceCacheAccess
.
h
"
#
include
"
GrGpuResourcePriv
.
h
"
#
include
"
GrResourceKey
.
h
"
#
include
"
SkMessageBus
.
h
"
#
include
"
SkRefCnt
.
h
"
#
include
"
SkTArray
.
h
"
#
include
"
SkTDPQueue
.
h
"
#
include
"
SkTInternalLList
.
h
"
#
include
"
SkTMultiMap
.
h
"
class
GrCaps
;
class
SkString
;
class
SkTraceMemoryDump
;
class
GrResourceCache
{
public
:
GrResourceCache
(
const
GrCaps
*
caps
)
;
~
GrResourceCache
(
)
;
static
const
int
kDefaultMaxCount
=
2
*
(
1
<
<
12
)
;
static
const
size_t
kDefaultMaxSize
=
96
*
(
1
<
<
20
)
;
static
const
int
kDefaultMaxUnusedFlushes
=
64
;
class
ResourceAccess
;
ResourceAccess
resourceAccess
(
)
;
void
setLimits
(
int
count
size_t
bytes
int
maxUnusedFlushes
=
kDefaultMaxUnusedFlushes
)
;
int
getResourceCount
(
)
const
{
return
fPurgeableQueue
.
count
(
)
+
fNonpurgeableResources
.
count
(
)
;
}
int
getBudgetedResourceCount
(
)
const
{
return
fBudgetedCount
;
}
size_t
getResourceBytes
(
)
const
{
return
fBytes
;
}
size_t
getBudgetedResourceBytes
(
)
const
{
return
fBudgetedBytes
;
}
int
getMaxResourceCount
(
)
const
{
return
fMaxCount
;
}
size_t
getMaxResourceBytes
(
)
const
{
return
fMaxBytes
;
}
void
abandonAll
(
)
;
void
releaseAll
(
)
;
enum
{
kPreferNoPendingIO_ScratchFlag
=
0x1
kRequireNoPendingIO_ScratchFlag
=
0x2
}
;
GrGpuResource
*
findAndRefScratchResource
(
const
GrScratchKey
&
scratchKey
size_t
resourceSize
uint32_t
flags
)
;
#
ifdef
SK_DEBUG
int
countScratchEntriesForKey
(
const
GrScratchKey
&
scratchKey
)
const
{
return
fScratchMap
.
countForKey
(
scratchKey
)
;
}
#
endif
GrGpuResource
*
findAndRefUniqueResource
(
const
GrUniqueKey
&
key
)
{
GrGpuResource
*
resource
=
fUniqueHash
.
find
(
key
)
;
if
(
resource
)
{
this
-
>
refAndMakeResourceMRU
(
resource
)
;
}
return
resource
;
}
bool
hasUniqueKey
(
const
GrUniqueKey
&
key
)
const
{
return
SkToBool
(
fUniqueHash
.
find
(
key
)
)
;
}
void
purgeAsNeeded
(
)
;
void
purgeAllUnlocked
(
)
;
typedef
void
(
*
PFOverBudgetCB
)
(
void
*
data
)
;
void
setOverBudgetCallback
(
PFOverBudgetCB
overBudgetCB
void
*
data
)
{
fOverBudgetCB
=
overBudgetCB
;
fOverBudgetData
=
data
;
}
void
notifyFlushOccurred
(
)
;
#
if
GR_CACHE_STATS
struct
Stats
{
int
fTotal
;
int
fNumPurgeable
;
int
fNumNonPurgeable
;
int
fScratch
;
int
fExternal
;
int
fBorrowed
;
int
fAdopted
;
size_t
fUnbudgetedSize
;
Stats
(
)
{
this
-
>
reset
(
)
;
}
void
reset
(
)
{
fTotal
=
0
;
fNumPurgeable
=
0
;
fNumNonPurgeable
=
0
;
fScratch
=
0
;
fExternal
=
0
;
fBorrowed
=
0
;
fAdopted
=
0
;
fUnbudgetedSize
=
0
;
}
void
update
(
GrGpuResource
*
resource
)
{
if
(
resource
-
>
cacheAccess
(
)
.
isScratch
(
)
)
{
+
+
fScratch
;
}
if
(
resource
-
>
cacheAccess
(
)
.
isExternal
(
)
)
{
+
+
fExternal
;
}
if
(
resource
-
>
cacheAccess
(
)
.
isBorrowed
(
)
)
{
+
+
fBorrowed
;
}
if
(
resource
-
>
cacheAccess
(
)
.
isAdopted
(
)
)
{
+
+
fAdopted
;
}
if
(
!
resource
-
>
resourcePriv
(
)
.
isBudgeted
(
)
)
{
fUnbudgetedSize
+
=
resource
-
>
gpuMemorySize
(
)
;
}
}
}
;
void
getStats
(
Stats
*
)
const
;
void
dumpStats
(
SkString
*
)
const
;
void
dumpStatsKeyValuePairs
(
SkTArray
<
SkString
>
*
keys
SkTArray
<
double
>
*
value
)
const
;
#
endif
void
changeTimestamp
(
uint32_t
newTimestamp
)
;
void
dumpMemoryStatistics
(
SkTraceMemoryDump
*
traceMemoryDump
)
const
;
private
:
void
insertResource
(
GrGpuResource
*
)
;
void
removeResource
(
GrGpuResource
*
)
;
void
notifyCntReachedZero
(
GrGpuResource
*
uint32_t
flags
)
;
void
didChangeGpuMemorySize
(
const
GrGpuResource
*
size_t
oldSize
)
;
void
changeUniqueKey
(
GrGpuResource
*
const
GrUniqueKey
&
)
;
void
removeUniqueKey
(
GrGpuResource
*
)
;
void
willRemoveScratchKey
(
const
GrGpuResource
*
)
;
void
didChangeBudgetStatus
(
GrGpuResource
*
)
;
void
refAndMakeResourceMRU
(
GrGpuResource
*
)
;
void
resetFlushTimestamps
(
)
;
void
processInvalidUniqueKeys
(
const
SkTArray
<
GrUniqueKeyInvalidatedMessage
>
&
)
;
void
addToNonpurgeableArray
(
GrGpuResource
*
)
;
void
removeFromNonpurgeableArray
(
GrGpuResource
*
)
;
bool
overBudget
(
)
const
{
return
fBudgetedBytes
>
fMaxBytes
|
|
fBudgetedCount
>
fMaxCount
;
}
bool
wouldFit
(
size_t
bytes
)
{
return
fBudgetedBytes
+
bytes
<
=
fMaxBytes
&
&
fBudgetedCount
+
1
<
=
fMaxCount
;
}
uint32_t
getNextTimestamp
(
)
;
#
ifdef
SK_DEBUG
bool
isInCache
(
const
GrGpuResource
*
r
)
const
;
void
validate
(
)
const
;
#
else
void
validate
(
)
const
{
}
#
endif
class
AutoValidate
;
class
AvailableForScratchUse
;
struct
ScratchMapTraits
{
static
const
GrScratchKey
&
GetKey
(
const
GrGpuResource
&
r
)
{
return
r
.
resourcePriv
(
)
.
getScratchKey
(
)
;
}
static
uint32_t
Hash
(
const
GrScratchKey
&
key
)
{
return
key
.
hash
(
)
;
}
}
;
typedef
SkTMultiMap
<
GrGpuResource
GrScratchKey
ScratchMapTraits
>
ScratchMap
;
struct
UniqueHashTraits
{
static
const
GrUniqueKey
&
GetKey
(
const
GrGpuResource
&
r
)
{
return
r
.
getUniqueKey
(
)
;
}
static
uint32_t
Hash
(
const
GrUniqueKey
&
key
)
{
return
key
.
hash
(
)
;
}
}
;
typedef
SkTDynamicHash
<
GrGpuResource
GrUniqueKey
UniqueHashTraits
>
UniqueHash
;
static
bool
CompareTimestamp
(
GrGpuResource
*
const
&
a
GrGpuResource
*
const
&
b
)
{
return
a
-
>
cacheAccess
(
)
.
timestamp
(
)
<
b
-
>
cacheAccess
(
)
.
timestamp
(
)
;
}
static
int
*
AccessResourceIndex
(
GrGpuResource
*
const
&
res
)
{
return
res
-
>
cacheAccess
(
)
.
accessCacheIndex
(
)
;
}
typedef
SkMessageBus
<
GrUniqueKeyInvalidatedMessage
>
:
:
Inbox
InvalidUniqueKeyInbox
;
typedef
SkTDPQueue
<
GrGpuResource
*
CompareTimestamp
AccessResourceIndex
>
PurgeableQueue
;
typedef
SkTDArray
<
GrGpuResource
*
>
ResourceArray
;
uint32_t
fTimestamp
;
PurgeableQueue
fPurgeableQueue
;
ResourceArray
fNonpurgeableResources
;
ScratchMap
fScratchMap
;
UniqueHash
fUniqueHash
;
int
fMaxCount
;
size_t
fMaxBytes
;
int
fMaxUnusedFlushes
;
#
if
GR_CACHE_STATS
int
fHighWaterCount
;
size_t
fHighWaterBytes
;
int
fBudgetedHighWaterCount
;
size_t
fBudgetedHighWaterBytes
;
#
endif
SkDEBUGCODE
(
int
fCount
;
)
size_t
fBytes
;
int
fBudgetedCount
;
size_t
fBudgetedBytes
;
PFOverBudgetCB
fOverBudgetCB
;
void
*
fOverBudgetData
;
uint32_t
*
fFlushTimestamps
;
int
fLastFlushTimestampIndex
;
InvalidUniqueKeyInbox
fInvalidUniqueKeyInbox
;
SkDEBUGCODE
(
GrGpuResource
*
fNewlyPurgeableResourceForValidation
;
)
bool
fPreferVRAMUseOverFlushes
;
}
;
class
GrResourceCache
:
:
ResourceAccess
{
private
:
ResourceAccess
(
GrResourceCache
*
cache
)
:
fCache
(
cache
)
{
}
ResourceAccess
(
const
ResourceAccess
&
that
)
:
fCache
(
that
.
fCache
)
{
}
ResourceAccess
&
operator
=
(
const
ResourceAccess
&
)
;
void
insertResource
(
GrGpuResource
*
resource
)
{
fCache
-
>
insertResource
(
resource
)
;
}
void
removeResource
(
GrGpuResource
*
resource
)
{
fCache
-
>
removeResource
(
resource
)
;
}
enum
RefNotificationFlags
{
kAllCntsReachedZero_RefNotificationFlag
=
0x1
kRefCntReachedZero_RefNotificationFlag
=
0x2
}
;
void
notifyCntReachedZero
(
GrGpuResource
*
resource
uint32_t
flags
)
{
fCache
-
>
notifyCntReachedZero
(
resource
flags
)
;
}
void
didChangeGpuMemorySize
(
const
GrGpuResource
*
resource
size_t
oldSize
)
{
fCache
-
>
didChangeGpuMemorySize
(
resource
oldSize
)
;
}
void
changeUniqueKey
(
GrGpuResource
*
resource
const
GrUniqueKey
&
newKey
)
{
fCache
-
>
changeUniqueKey
(
resource
newKey
)
;
}
void
removeUniqueKey
(
GrGpuResource
*
resource
)
{
fCache
-
>
removeUniqueKey
(
resource
)
;
}
void
willRemoveScratchKey
(
const
GrGpuResource
*
resource
)
{
fCache
-
>
willRemoveScratchKey
(
resource
)
;
}
void
didChangeBudgetStatus
(
GrGpuResource
*
resource
)
{
fCache
-
>
didChangeBudgetStatus
(
resource
)
;
}
const
ResourceAccess
*
operator
&
(
)
const
;
ResourceAccess
*
operator
&
(
)
;
GrResourceCache
*
fCache
;
friend
class
GrGpuResource
;
friend
class
GrResourceCache
;
}
;
inline
GrResourceCache
:
:
ResourceAccess
GrResourceCache
:
:
resourceAccess
(
)
{
return
ResourceAccess
(
this
)
;
}
#
endif
