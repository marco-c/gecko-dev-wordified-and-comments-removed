#
ifndef
GrResourceCache_DEFINED
#
define
GrResourceCache_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
gpu
/
GrGpuResource
.
h
"
#
include
"
include
/
private
/
GrResourceKey
.
h
"
#
include
"
include
/
private
/
SkTArray
.
h
"
#
include
"
include
/
private
/
SkTHash
.
h
"
#
include
"
src
/
core
/
SkMessageBus
.
h
"
#
include
"
src
/
core
/
SkTDPQueue
.
h
"
#
include
"
src
/
core
/
SkTInternalLList
.
h
"
#
include
"
src
/
core
/
SkTMultiMap
.
h
"
#
include
"
src
/
gpu
/
GrGpuResourceCacheAccess
.
h
"
#
include
"
src
/
gpu
/
GrGpuResourcePriv
.
h
"
class
GrCaps
;
class
GrProxyProvider
;
class
SkString
;
class
SkTraceMemoryDump
;
class
GrSingleOwner
;
struct
GrTextureFreedMessage
{
GrTexture
*
fTexture
;
uint32_t
fOwningUniqueID
;
}
;
static
inline
bool
SkShouldPostMessageToBus
(
const
GrTextureFreedMessage
&
msg
uint32_t
msgBusUniqueID
)
{
return
msgBusUniqueID
=
=
msg
.
fOwningUniqueID
;
}
class
GrResourceCache
{
public
:
GrResourceCache
(
const
GrCaps
*
GrSingleOwner
*
owner
uint32_t
contextUniqueID
)
;
~
GrResourceCache
(
)
;
static
const
size_t
kDefaultMaxSize
=
96
*
(
1
<
<
20
)
;
class
ResourceAccess
;
ResourceAccess
resourceAccess
(
)
;
uint32_t
contextUniqueID
(
)
const
{
return
fContextUniqueID
;
}
void
setLimit
(
size_t
bytes
)
;
int
getResourceCount
(
)
const
{
return
fPurgeableQueue
.
count
(
)
+
fNonpurgeableResources
.
count
(
)
;
}
int
getBudgetedResourceCount
(
)
const
{
return
fBudgetedCount
;
}
size_t
getResourceBytes
(
)
const
{
return
fBytes
;
}
size_t
getPurgeableBytes
(
)
const
{
return
fPurgeableBytes
;
}
size_t
getBudgetedResourceBytes
(
)
const
{
return
fBudgetedBytes
;
}
size_t
getMaxResourceBytes
(
)
const
{
return
fMaxBytes
;
}
void
abandonAll
(
)
;
void
releaseAll
(
)
;
GrGpuResource
*
findAndRefScratchResource
(
const
GrScratchKey
&
scratchKey
)
;
#
ifdef
SK_DEBUG
int
countScratchEntriesForKey
(
const
GrScratchKey
&
scratchKey
)
const
{
return
fScratchMap
.
countForKey
(
scratchKey
)
;
}
#
endif
GrGpuResource
*
findAndRefUniqueResource
(
const
GrUniqueKey
&
key
)
{
GrGpuResource
*
resource
=
fUniqueHash
.
find
(
key
)
;
if
(
resource
)
{
this
-
>
refAndMakeResourceMRU
(
resource
)
;
}
return
resource
;
}
bool
hasUniqueKey
(
const
GrUniqueKey
&
key
)
const
{
return
SkToBool
(
fUniqueHash
.
find
(
key
)
)
;
}
void
purgeAsNeeded
(
)
;
void
purgeAllUnlocked
(
)
{
this
-
>
purgeUnlockedResources
(
false
)
;
}
void
purgeUnlockedResources
(
bool
scratchResourcesOnly
)
;
void
purgeResourcesNotUsedSince
(
GrStdSteadyClock
:
:
time_point
)
;
bool
overBudget
(
)
const
{
return
fBudgetedBytes
>
fMaxBytes
;
}
void
purgeUnlockedResources
(
size_t
bytesToPurge
bool
preferScratchResources
)
;
bool
requestsFlush
(
)
const
;
void
insertDelayedTextureUnref
(
GrTexture
*
)
;
#
if
GR_CACHE_STATS
struct
Stats
{
int
fTotal
;
int
fNumPurgeable
;
int
fNumNonPurgeable
;
int
fScratch
;
int
fWrapped
;
size_t
fUnbudgetedSize
;
Stats
(
)
{
this
-
>
reset
(
)
;
}
void
reset
(
)
{
fTotal
=
0
;
fNumPurgeable
=
0
;
fNumNonPurgeable
=
0
;
fScratch
=
0
;
fWrapped
=
0
;
fUnbudgetedSize
=
0
;
}
void
update
(
GrGpuResource
*
resource
)
{
if
(
resource
-
>
cacheAccess
(
)
.
isScratch
(
)
)
{
+
+
fScratch
;
}
if
(
resource
-
>
resourcePriv
(
)
.
refsWrappedObjects
(
)
)
{
+
+
fWrapped
;
}
if
(
GrBudgetedType
:
:
kBudgeted
!
=
resource
-
>
resourcePriv
(
)
.
budgetedType
(
)
)
{
fUnbudgetedSize
+
=
resource
-
>
gpuMemorySize
(
)
;
}
}
}
;
void
getStats
(
Stats
*
)
const
;
#
if
GR_TEST_UTILS
void
dumpStats
(
SkString
*
)
const
;
void
dumpStatsKeyValuePairs
(
SkTArray
<
SkString
>
*
keys
SkTArray
<
double
>
*
value
)
const
;
#
endif
#
endif
#
ifdef
SK_DEBUG
int
countUniqueKeysWithTag
(
const
char
*
tag
)
const
;
#
endif
void
changeTimestamp
(
uint32_t
newTimestamp
)
;
void
dumpMemoryStatistics
(
SkTraceMemoryDump
*
traceMemoryDump
)
const
;
void
setProxyProvider
(
GrProxyProvider
*
proxyProvider
)
{
fProxyProvider
=
proxyProvider
;
}
private
:
void
insertResource
(
GrGpuResource
*
)
;
void
removeResource
(
GrGpuResource
*
)
;
void
notifyRefCntReachedZero
(
GrGpuResource
*
)
;
void
changeUniqueKey
(
GrGpuResource
*
const
GrUniqueKey
&
)
;
void
removeUniqueKey
(
GrGpuResource
*
)
;
void
willRemoveScratchKey
(
const
GrGpuResource
*
)
;
void
didChangeBudgetStatus
(
GrGpuResource
*
)
;
void
refResource
(
GrGpuResource
*
resource
)
;
void
refAndMakeResourceMRU
(
GrGpuResource
*
)
;
void
processFreedGpuResources
(
)
;
void
addToNonpurgeableArray
(
GrGpuResource
*
)
;
void
removeFromNonpurgeableArray
(
GrGpuResource
*
)
;
bool
wouldFit
(
size_t
bytes
)
const
{
return
fBudgetedBytes
+
bytes
<
=
fMaxBytes
;
}
uint32_t
getNextTimestamp
(
)
;
#
ifdef
SK_DEBUG
bool
isInCache
(
const
GrGpuResource
*
r
)
const
;
void
validate
(
)
const
;
#
else
void
validate
(
)
const
{
}
#
endif
class
AutoValidate
;
class
AvailableForScratchUse
;
struct
ScratchMapTraits
{
static
const
GrScratchKey
&
GetKey
(
const
GrGpuResource
&
r
)
{
return
r
.
resourcePriv
(
)
.
getScratchKey
(
)
;
}
static
uint32_t
Hash
(
const
GrScratchKey
&
key
)
{
return
key
.
hash
(
)
;
}
static
void
OnFree
(
GrGpuResource
*
)
{
}
}
;
typedef
SkTMultiMap
<
GrGpuResource
GrScratchKey
ScratchMapTraits
>
ScratchMap
;
struct
UniqueHashTraits
{
static
const
GrUniqueKey
&
GetKey
(
const
GrGpuResource
&
r
)
{
return
r
.
getUniqueKey
(
)
;
}
static
uint32_t
Hash
(
const
GrUniqueKey
&
key
)
{
return
key
.
hash
(
)
;
}
}
;
typedef
SkTDynamicHash
<
GrGpuResource
GrUniqueKey
UniqueHashTraits
>
UniqueHash
;
class
TextureAwaitingUnref
{
public
:
TextureAwaitingUnref
(
)
;
TextureAwaitingUnref
(
GrTexture
*
texture
)
;
TextureAwaitingUnref
(
const
TextureAwaitingUnref
&
)
=
delete
;
TextureAwaitingUnref
&
operator
=
(
const
TextureAwaitingUnref
&
)
=
delete
;
TextureAwaitingUnref
(
TextureAwaitingUnref
&
&
)
;
TextureAwaitingUnref
&
operator
=
(
TextureAwaitingUnref
&
&
)
;
~
TextureAwaitingUnref
(
)
;
void
addRef
(
)
;
void
unref
(
)
;
bool
finished
(
)
;
private
:
GrTexture
*
fTexture
=
nullptr
;
int
fNumUnrefs
=
0
;
}
;
using
TexturesAwaitingUnref
=
SkTHashMap
<
uint32_t
TextureAwaitingUnref
>
;
static
bool
CompareTimestamp
(
GrGpuResource
*
const
&
a
GrGpuResource
*
const
&
b
)
{
return
a
-
>
cacheAccess
(
)
.
timestamp
(
)
<
b
-
>
cacheAccess
(
)
.
timestamp
(
)
;
}
static
int
*
AccessResourceIndex
(
GrGpuResource
*
const
&
res
)
{
return
res
-
>
cacheAccess
(
)
.
accessCacheIndex
(
)
;
}
typedef
SkMessageBus
<
GrUniqueKeyInvalidatedMessage
>
:
:
Inbox
InvalidUniqueKeyInbox
;
typedef
SkMessageBus
<
GrTextureFreedMessage
>
:
:
Inbox
FreedTextureInbox
;
typedef
SkTDPQueue
<
GrGpuResource
*
CompareTimestamp
AccessResourceIndex
>
PurgeableQueue
;
typedef
SkTDArray
<
GrGpuResource
*
>
ResourceArray
;
GrProxyProvider
*
fProxyProvider
=
nullptr
;
uint32_t
fTimestamp
=
0
;
PurgeableQueue
fPurgeableQueue
;
ResourceArray
fNonpurgeableResources
;
ScratchMap
fScratchMap
;
UniqueHash
fUniqueHash
;
size_t
fMaxBytes
=
kDefaultMaxSize
;
#
if
GR_CACHE_STATS
int
fHighWaterCount
=
0
;
size_t
fHighWaterBytes
=
0
;
int
fBudgetedHighWaterCount
=
0
;
size_t
fBudgetedHighWaterBytes
=
0
;
#
endif
SkDEBUGCODE
(
int
fCount
=
0
;
)
size_t
fBytes
=
0
;
int
fBudgetedCount
=
0
;
size_t
fBudgetedBytes
=
0
;
size_t
fPurgeableBytes
=
0
;
int
fNumBudgetedResourcesFlushWillMakePurgeable
=
0
;
InvalidUniqueKeyInbox
fInvalidUniqueKeyInbox
;
FreedTextureInbox
fFreedTextureInbox
;
TexturesAwaitingUnref
fTexturesAwaitingUnref
;
uint32_t
fContextUniqueID
=
SK_InvalidUniqueID
;
GrSingleOwner
*
fSingleOwner
=
nullptr
;
SkDEBUGCODE
(
GrGpuResource
*
fNewlyPurgeableResourceForValidation
=
nullptr
;
)
bool
fPreferVRAMUseOverFlushes
=
false
;
}
;
class
GrResourceCache
:
:
ResourceAccess
{
private
:
ResourceAccess
(
GrResourceCache
*
cache
)
:
fCache
(
cache
)
{
}
ResourceAccess
(
const
ResourceAccess
&
that
)
:
fCache
(
that
.
fCache
)
{
}
ResourceAccess
&
operator
=
(
const
ResourceAccess
&
)
;
void
insertResource
(
GrGpuResource
*
resource
)
{
fCache
-
>
insertResource
(
resource
)
;
}
void
removeResource
(
GrGpuResource
*
resource
)
{
fCache
-
>
removeResource
(
resource
)
;
}
void
refResource
(
GrGpuResource
*
resource
)
{
fCache
-
>
refResource
(
resource
)
;
}
enum
RefNotificationFlags
{
kAllCntsReachedZero_RefNotificationFlag
=
0x1
kRefCntReachedZero_RefNotificationFlag
=
0x2
}
;
void
notifyRefCntReachedZero
(
GrGpuResource
*
resource
)
{
fCache
-
>
notifyRefCntReachedZero
(
resource
)
;
}
void
changeUniqueKey
(
GrGpuResource
*
resource
const
GrUniqueKey
&
newKey
)
{
fCache
-
>
changeUniqueKey
(
resource
newKey
)
;
}
void
removeUniqueKey
(
GrGpuResource
*
resource
)
{
fCache
-
>
removeUniqueKey
(
resource
)
;
}
void
willRemoveScratchKey
(
const
GrGpuResource
*
resource
)
{
fCache
-
>
willRemoveScratchKey
(
resource
)
;
}
void
didChangeBudgetStatus
(
GrGpuResource
*
resource
)
{
fCache
-
>
didChangeBudgetStatus
(
resource
)
;
}
const
ResourceAccess
*
operator
&
(
)
const
;
ResourceAccess
*
operator
&
(
)
;
GrResourceCache
*
fCache
;
friend
class
GrGpuResource
;
friend
class
GrResourceCache
;
}
;
inline
GrResourceCache
:
:
ResourceAccess
GrResourceCache
:
:
resourceAccess
(
)
{
return
ResourceAccess
(
this
)
;
}
#
endif
