#
ifndef
GrProcessorSet_DEFINED
#
define
GrProcessorSet_DEFINED
#
include
"
GrFragmentProcessor
.
h
"
#
include
"
GrPaint
.
h
"
#
include
"
GrProcessorAnalysis
.
h
"
#
include
"
SkTemplates
.
h
"
#
include
"
GrXferProcessor
.
h
"
class
GrAppliedClip
;
class
GrXPFactory
;
class
GrProcessorSet
{
private
:
enum
class
Empty
{
kEmpty
}
;
public
:
GrProcessorSet
(
GrPaint
&
&
)
;
GrProcessorSet
(
SkBlendMode
)
;
GrProcessorSet
(
std
:
:
unique_ptr
<
GrFragmentProcessor
>
colorFP
)
;
GrProcessorSet
(
GrProcessorSet
&
&
)
;
GrProcessorSet
(
const
GrProcessorSet
&
)
=
delete
;
GrProcessorSet
&
operator
=
(
const
GrProcessorSet
&
)
=
delete
;
~
GrProcessorSet
(
)
;
int
numColorFragmentProcessors
(
)
const
{
return
fColorFragmentProcessorCnt
;
}
int
numCoverageFragmentProcessors
(
)
const
{
return
this
-
>
numFragmentProcessors
(
)
-
fColorFragmentProcessorCnt
;
}
const
GrFragmentProcessor
*
colorFragmentProcessor
(
int
idx
)
const
{
SkASSERT
(
idx
<
fColorFragmentProcessorCnt
)
;
return
fFragmentProcessors
[
idx
+
fFragmentProcessorOffset
]
.
get
(
)
;
}
const
GrFragmentProcessor
*
coverageFragmentProcessor
(
int
idx
)
const
{
return
fFragmentProcessors
[
idx
+
fColorFragmentProcessorCnt
+
fFragmentProcessorOffset
]
.
get
(
)
;
}
const
GrXferProcessor
*
xferProcessor
(
)
const
{
SkASSERT
(
this
-
>
isFinalized
(
)
)
;
return
fXP
.
fProcessor
;
}
sk_sp
<
const
GrXferProcessor
>
refXferProcessor
(
)
const
{
SkASSERT
(
this
-
>
isFinalized
(
)
)
;
return
sk_ref_sp
(
fXP
.
fProcessor
)
;
}
std
:
:
unique_ptr
<
const
GrFragmentProcessor
>
detachColorFragmentProcessor
(
int
idx
)
{
SkASSERT
(
idx
<
fColorFragmentProcessorCnt
)
;
return
std
:
:
move
(
fFragmentProcessors
[
idx
+
fFragmentProcessorOffset
]
)
;
}
std
:
:
unique_ptr
<
const
GrFragmentProcessor
>
detachCoverageFragmentProcessor
(
int
idx
)
{
return
std
:
:
move
(
fFragmentProcessors
[
idx
+
fFragmentProcessorOffset
+
fColorFragmentProcessorCnt
]
)
;
}
bool
operator
=
=
(
const
GrProcessorSet
&
that
)
const
;
bool
operator
!
=
(
const
GrProcessorSet
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
class
Analysis
{
public
:
Analysis
(
const
Analysis
&
)
=
default
;
Analysis
(
)
{
*
reinterpret_cast
<
uint32_t
*
>
(
this
)
=
0
;
}
bool
isInitialized
(
)
const
{
return
fIsInitialized
;
}
bool
usesLocalCoords
(
)
const
{
return
fUsesLocalCoords
;
}
bool
requiresDstTexture
(
)
const
{
return
fRequiresDstTexture
;
}
bool
canCombineOverlappedStencilAndCover
(
)
const
{
return
fCanCombineOverlappedStencilAndCover
;
}
bool
requiresBarrierBetweenOverlappingDraws
(
)
const
{
return
fRequiresBarrierBetweenOverlappingDraws
;
}
bool
isCompatibleWithCoverageAsAlpha
(
)
const
{
return
fCompatibleWithCoverageAsAlpha
;
}
bool
inputColorIsIgnored
(
)
const
{
return
fInputColorType
=
=
kIgnored_InputColorType
;
}
bool
inputColorIsOverridden
(
)
const
{
return
fInputColorType
=
=
kOverridden_InputColorType
;
}
private
:
constexpr
Analysis
(
Empty
)
:
fUsesLocalCoords
(
false
)
fCompatibleWithCoverageAsAlpha
(
true
)
fRequiresDstTexture
(
false
)
fCanCombineOverlappedStencilAndCover
(
true
)
fRequiresBarrierBetweenOverlappingDraws
(
false
)
fIsInitialized
(
true
)
fInputColorType
(
kOriginal_InputColorType
)
{
}
enum
InputColorType
:
uint32_t
{
kOriginal_InputColorType
kOverridden_InputColorType
kIgnored_InputColorType
}
;
using
PackedBool
=
uint32_t
;
using
PackedInputColorType
=
uint32_t
;
PackedBool
fUsesLocalCoords
:
1
;
PackedBool
fCompatibleWithCoverageAsAlpha
:
1
;
PackedBool
fRequiresDstTexture
:
1
;
PackedBool
fCanCombineOverlappedStencilAndCover
:
1
;
PackedBool
fRequiresBarrierBetweenOverlappingDraws
:
1
;
PackedBool
fIsInitialized
:
1
;
PackedInputColorType
fInputColorType
:
2
;
friend
class
GrProcessorSet
;
}
;
GR_STATIC_ASSERT
(
sizeof
(
Analysis
)
<
=
sizeof
(
uint32_t
)
)
;
Analysis
finalize
(
const
GrProcessorAnalysisColor
&
colorInput
const
GrProcessorAnalysisCoverage
coverageInput
const
GrAppliedClip
*
bool
isMixedSamples
const
GrCaps
&
GrColor
*
inputColorOverride
)
;
bool
isFinalized
(
)
const
{
return
SkToBool
(
kFinalized_Flag
&
fFlags
)
;
}
static
const
GrProcessorSet
&
EmptySet
(
)
;
static
GrProcessorSet
MakeEmptySet
(
)
;
static
constexpr
const
Analysis
EmptySetAnalysis
(
)
{
return
Analysis
(
Empty
:
:
kEmpty
)
;
}
SkString
dumpProcessors
(
)
const
;
void
visitProxies
(
const
std
:
:
function
<
void
(
GrSurfaceProxy
*
)
>
&
func
)
const
{
for
(
int
i
=
0
;
i
<
this
-
>
numFragmentProcessors
(
)
;
+
+
i
)
{
GrFragmentProcessor
:
:
TextureAccessIter
iter
(
this
-
>
fragmentProcessor
(
i
)
)
;
while
(
const
GrFragmentProcessor
:
:
TextureSampler
*
sampler
=
iter
.
next
(
)
)
{
func
(
sampler
-
>
proxy
(
)
)
;
}
}
}
private
:
GrProcessorSet
(
Empty
)
:
fXP
(
(
const
GrXferProcessor
*
)
nullptr
)
fFlags
(
kFinalized_Flag
)
{
}
int
numFragmentProcessors
(
)
const
{
return
fFragmentProcessors
.
count
(
)
-
fFragmentProcessorOffset
;
}
const
GrFragmentProcessor
*
fragmentProcessor
(
int
idx
)
const
{
return
fFragmentProcessors
[
idx
+
fFragmentProcessorOffset
]
.
get
(
)
;
}
static
constexpr
int
kMaxColorProcessors
=
UINT8_MAX
;
enum
Flags
:
uint16_t
{
kFinalized_Flag
=
0x1
}
;
union
XP
{
XP
(
const
GrXPFactory
*
factory
)
:
fFactory
(
factory
)
{
}
XP
(
const
GrXferProcessor
*
processor
)
:
fProcessor
(
processor
)
{
}
XP
(
XP
&
&
that
)
:
fProcessor
(
that
.
fProcessor
)
{
SkASSERT
(
fProcessor
=
=
that
.
fProcessor
)
;
that
.
fProcessor
=
nullptr
;
}
const
GrXPFactory
*
fFactory
;
const
GrXferProcessor
*
fProcessor
;
}
;
const
GrXPFactory
*
xpFactory
(
)
const
{
SkASSERT
(
!
this
-
>
isFinalized
(
)
)
;
return
fXP
.
fFactory
;
}
SkAutoSTArray
<
4
std
:
:
unique_ptr
<
const
GrFragmentProcessor
>
>
fFragmentProcessors
;
XP
fXP
;
uint8_t
fColorFragmentProcessorCnt
=
0
;
uint8_t
fFragmentProcessorOffset
=
0
;
uint8_t
fFlags
;
}
;
#
endif
