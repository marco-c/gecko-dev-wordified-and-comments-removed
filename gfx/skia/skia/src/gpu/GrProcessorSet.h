#
ifndef
GrProcessorSet_DEFINED
#
define
GrProcessorSet_DEFINED
#
include
"
GrFragmentProcessor
.
h
"
#
include
"
GrPaint
.
h
"
#
include
"
GrProcessorAnalysis
.
h
"
#
include
"
SkTemplates
.
h
"
class
GrAppliedClip
;
class
GrXferProcessor
;
class
GrXPFactory
;
class
GrProcessorSet
:
private
SkNoncopyable
{
public
:
GrProcessorSet
(
GrPaint
&
&
paint
)
;
~
GrProcessorSet
(
)
;
int
numColorFragmentProcessors
(
)
const
{
return
fColorFragmentProcessorCnt
;
}
int
numCoverageFragmentProcessors
(
)
const
{
return
this
-
>
numFragmentProcessors
(
)
-
fColorFragmentProcessorCnt
;
}
int
numFragmentProcessors
(
)
const
{
return
fFragmentProcessors
.
count
(
)
-
fFragmentProcessorOffset
;
}
const
GrFragmentProcessor
*
colorFragmentProcessor
(
int
idx
)
const
{
SkASSERT
(
idx
<
fColorFragmentProcessorCnt
)
;
return
fFragmentProcessors
[
idx
+
fFragmentProcessorOffset
]
;
}
const
GrFragmentProcessor
*
coverageFragmentProcessor
(
int
idx
)
const
{
return
fFragmentProcessors
[
idx
+
fColorFragmentProcessorCnt
+
fFragmentProcessorOffset
]
;
}
const
GrXferProcessor
*
xferProcessor
(
)
const
{
SkASSERT
(
this
-
>
isFinalized
(
)
)
;
return
fXP
.
fProcessor
;
}
sk_sp
<
const
GrXferProcessor
>
refXferProcessor
(
)
const
{
SkASSERT
(
this
-
>
isFinalized
(
)
)
;
return
sk_ref_sp
(
fXP
.
fProcessor
)
;
}
bool
usesDistanceVectorField
(
)
const
{
return
SkToBool
(
fFlags
&
kUseDistanceVectorField_Flag
)
;
}
bool
disableOutputConversionToSRGB
(
)
const
{
return
SkToBool
(
fFlags
&
kDisableOutputConversionToSRGB_Flag
)
;
}
bool
allowSRGBInputs
(
)
const
{
return
SkToBool
(
fFlags
&
kAllowSRGBInputs_Flag
)
;
}
bool
operator
=
=
(
const
GrProcessorSet
&
that
)
const
;
bool
operator
!
=
(
const
GrProcessorSet
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
class
Analysis
{
public
:
Analysis
(
const
Analysis
&
)
=
default
;
Analysis
(
)
{
*
reinterpret_cast
<
uint32_t
*
>
(
this
)
=
0
;
}
bool
isInitialized
(
)
const
{
return
fIsInitialized
;
}
bool
usesLocalCoords
(
)
const
{
return
fUsesLocalCoords
;
}
bool
requiresDstTexture
(
)
const
{
return
fRequiresDstTexture
;
}
bool
canCombineOverlappedStencilAndCover
(
)
const
{
return
fCanCombineOverlappedStencilAndCover
;
}
bool
requiresBarrierBetweenOverlappingDraws
(
)
const
{
return
fRequiresBarrierBetweenOverlappingDraws
;
}
bool
isCompatibleWithCoverageAsAlpha
(
)
const
{
return
fCompatibleWithCoverageAsAlpha
;
}
bool
inputColorIsIgnored
(
)
const
{
return
fInputColorType
=
=
kIgnored_InputColorType
;
}
bool
inputColorIsOverridden
(
)
const
{
return
fInputColorType
=
=
kOverridden_InputColorType
;
}
private
:
enum
InputColorType
:
uint32_t
{
kOriginal_InputColorType
kOverridden_InputColorType
kIgnored_InputColorType
}
;
using
PackedBool
=
uint32_t
;
using
PackedInputColorType
=
uint32_t
;
PackedBool
fUsesLocalCoords
:
1
;
PackedBool
fCompatibleWithCoverageAsAlpha
:
1
;
PackedBool
fRequiresDstTexture
:
1
;
PackedBool
fCanCombineOverlappedStencilAndCover
:
1
;
PackedBool
fRequiresBarrierBetweenOverlappingDraws
:
1
;
PackedBool
fIsInitialized
:
1
;
PackedInputColorType
fInputColorType
:
2
;
friend
class
GrProcessorSet
;
}
;
GR_STATIC_ASSERT
(
sizeof
(
Analysis
)
<
=
sizeof
(
uint32_t
)
)
;
Analysis
finalize
(
const
GrProcessorAnalysisColor
&
colorInput
const
GrProcessorAnalysisCoverage
coverageInput
const
GrAppliedClip
*
bool
isMixedSamples
const
GrCaps
&
GrColor
*
inputColorOverride
)
;
bool
isFinalized
(
)
const
{
return
SkToBool
(
kFinalized_Flag
&
fFlags
)
;
}
private
:
static
constexpr
int
kMaxColorProcessors
=
UINT8_MAX
;
enum
Flags
:
uint16_t
{
kUseDistanceVectorField_Flag
=
0x1
kDisableOutputConversionToSRGB_Flag
=
0x2
kAllowSRGBInputs_Flag
=
0x4
kFinalized_Flag
=
0x8
}
;
union
XP
{
XP
(
const
GrXPFactory
*
factory
)
:
fFactory
(
factory
)
{
}
const
GrXPFactory
*
fFactory
;
const
GrXferProcessor
*
fProcessor
;
}
;
const
GrXPFactory
*
xpFactory
(
)
const
{
SkASSERT
(
!
this
-
>
isFinalized
(
)
)
;
return
fXP
.
fFactory
;
}
SkAutoSTArray
<
4
const
GrFragmentProcessor
*
>
fFragmentProcessors
;
XP
fXP
;
uint8_t
fColorFragmentProcessorCnt
;
uint8_t
fFragmentProcessorOffset
=
0
;
uint8_t
fFlags
;
}
;
#
endif
