#
ifndef
GrRenderTargetContextPriv_DEFINED
#
define
GrRenderTargetContextPriv_DEFINED
#
include
"
GrRenderTargetContext
.
h
"
#
include
"
GrRenderTargetOpList
.
h
"
#
include
"
GrPathRendering
.
h
"
class
GrFixedClip
;
class
GrHardClip
;
class
GrPath
;
class
GrRenderTargetPriv
;
struct
GrUserStencilSettings
;
class
GrRenderTargetContextPriv
{
public
:
void
setLastClip
(
uint32_t
clipStackGenID
const
SkIRect
&
devClipBounds
int
numClipAnalyticFPs
)
{
GrRenderTargetOpList
*
opList
=
fRenderTargetContext
-
>
getRTOpList
(
)
;
opList
-
>
fLastClipStackGenID
=
clipStackGenID
;
opList
-
>
fLastDevClipBounds
=
devClipBounds
;
opList
-
>
fLastClipNumAnalyticFPs
=
numClipAnalyticFPs
;
}
bool
mustRenderClip
(
uint32_t
clipStackGenID
const
SkIRect
&
devClipBounds
int
numClipAnalyticFPs
)
const
{
GrRenderTargetOpList
*
opList
=
fRenderTargetContext
-
>
getRTOpList
(
)
;
return
opList
-
>
fLastClipStackGenID
!
=
clipStackGenID
|
|
!
opList
-
>
fLastDevClipBounds
.
contains
(
devClipBounds
)
|
|
opList
-
>
fLastClipNumAnalyticFPs
!
=
numClipAnalyticFPs
;
}
using
CanClearFullscreen
=
GrRenderTargetContext
:
:
CanClearFullscreen
;
void
clear
(
const
GrFixedClip
&
const
SkPMColor4f
&
CanClearFullscreen
)
;
void
clearStencilClip
(
const
GrFixedClip
&
bool
insideStencilMask
)
;
void
absClear
(
const
SkIRect
*
rect
const
SkPMColor4f
&
color
)
;
void
stencilRect
(
const
GrHardClip
&
const
GrUserStencilSettings
*
ss
GrAAType
const
SkMatrix
&
viewMatrix
const
SkRect
&
rect
)
;
void
stencilPath
(
const
GrHardClip
&
GrAAType
const
SkMatrix
&
viewMatrix
const
GrPath
*
)
;
bool
drawAndStencilRect
(
const
GrHardClip
&
const
GrUserStencilSettings
*
SkRegion
:
:
Op
op
bool
invert
GrAA
const
SkMatrix
&
viewMatrix
const
SkRect
&
)
;
bool
drawAndStencilPath
(
const
GrHardClip
&
const
GrUserStencilSettings
*
SkRegion
:
:
Op
op
bool
invert
GrAA
const
SkMatrix
&
viewMatrix
const
SkPath
&
)
;
SkBudgeted
isBudgeted
(
)
const
;
int
maxWindowRectangles
(
)
const
;
GrSurfaceProxy
:
:
UniqueID
uniqueID
(
)
const
{
return
fRenderTargetContext
-
>
fRenderTargetProxy
-
>
uniqueID
(
)
;
}
uint32_t
testingOnly_getOpListID
(
)
;
using
WillAddOpFn
=
GrRenderTargetContext
:
:
WillAddOpFn
;
void
testingOnly_addDrawOp
(
std
:
:
unique_ptr
<
GrDrawOp
>
)
;
void
testingOnly_addDrawOp
(
const
GrClip
&
std
:
:
unique_ptr
<
GrDrawOp
>
const
std
:
:
function
<
WillAddOpFn
>
&
=
std
:
:
function
<
WillAddOpFn
>
(
)
)
;
bool
refsWrappedObjects
(
)
const
{
return
fRenderTargetContext
-
>
fRenderTargetProxy
-
>
refsWrappedObjects
(
)
;
}
private
:
explicit
GrRenderTargetContextPriv
(
GrRenderTargetContext
*
renderTargetContext
)
:
fRenderTargetContext
(
renderTargetContext
)
{
}
GrRenderTargetContextPriv
(
const
GrRenderTargetPriv
&
)
{
}
GrRenderTargetContextPriv
&
operator
=
(
const
GrRenderTargetPriv
&
)
;
const
GrRenderTargetContextPriv
*
operator
&
(
)
const
;
GrRenderTargetContextPriv
*
operator
&
(
)
;
GrRenderTargetContext
*
fRenderTargetContext
;
friend
class
GrRenderTargetContext
;
}
;
inline
GrRenderTargetContextPriv
GrRenderTargetContext
:
:
priv
(
)
{
return
GrRenderTargetContextPriv
(
this
)
;
}
inline
const
GrRenderTargetContextPriv
GrRenderTargetContext
:
:
priv
(
)
const
{
return
GrRenderTargetContextPriv
(
const_cast
<
GrRenderTargetContext
*
>
(
this
)
)
;
}
#
endif
