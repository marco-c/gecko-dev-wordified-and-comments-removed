#
include
"
GrTextureProducer
.
h
"
#
include
"
GrClip
.
h
"
#
include
"
GrContextPriv
.
h
"
#
include
"
GrProxyProvider
.
h
"
#
include
"
GrRecordingContext
.
h
"
#
include
"
GrRecordingContextPriv
.
h
"
#
include
"
GrRenderTargetContext
.
h
"
#
include
"
GrTextureProxy
.
h
"
#
include
"
SkGr
.
h
"
#
include
"
SkMipMap
.
h
"
#
include
"
SkRectPriv
.
h
"
#
include
"
effects
/
GrBicubicEffect
.
h
"
#
include
"
effects
/
GrSimpleTextureEffect
.
h
"
#
include
"
effects
/
GrTextureDomain
.
h
"
sk_sp
<
GrTextureProxy
>
GrTextureProducer
:
:
CopyOnGpu
(
GrRecordingContext
*
context
sk_sp
<
GrTextureProxy
>
inputProxy
const
CopyParams
&
copyParams
bool
dstWillRequireMipMaps
)
{
SkASSERT
(
context
)
;
GrPixelConfig
config
=
GrMakePixelConfigUncompressed
(
inputProxy
-
>
config
(
)
)
;
const
SkRect
dstRect
=
SkRect
:
:
MakeIWH
(
copyParams
.
fWidth
copyParams
.
fHeight
)
;
GrMipMapped
mipMapped
=
dstWillRequireMipMaps
?
GrMipMapped
:
:
kYes
:
GrMipMapped
:
:
kNo
;
SkRect
localRect
=
SkRect
:
:
MakeWH
(
inputProxy
-
>
width
(
)
inputProxy
-
>
height
(
)
)
;
bool
needsDomain
=
false
;
bool
resizing
=
false
;
if
(
copyParams
.
fFilter
!
=
GrSamplerState
:
:
Filter
:
:
kNearest
)
{
bool
resizing
=
localRect
.
width
(
)
!
=
dstRect
.
width
(
)
|
|
localRect
.
height
(
)
!
=
dstRect
.
height
(
)
;
needsDomain
=
resizing
&
&
!
GrProxyProvider
:
:
IsFunctionallyExact
(
inputProxy
.
get
(
)
)
;
}
if
(
copyParams
.
fFilter
=
=
GrSamplerState
:
:
Filter
:
:
kNearest
&
&
!
needsDomain
&
&
!
resizing
&
&
dstWillRequireMipMaps
)
{
sk_sp
<
GrTextureProxy
>
proxy
=
GrCopyBaseMipMapToTextureProxy
(
context
inputProxy
.
get
(
)
)
;
if
(
proxy
)
{
return
proxy
;
}
}
GrBackendFormat
format
=
inputProxy
-
>
backendFormat
(
)
.
makeTexture2D
(
)
;
if
(
!
format
.
isValid
(
)
)
{
return
nullptr
;
}
sk_sp
<
GrRenderTargetContext
>
copyRTC
=
context
-
>
priv
(
)
.
makeDeferredRenderTargetContextWithFallback
(
format
SkBackingFit
:
:
kExact
dstRect
.
width
(
)
dstRect
.
height
(
)
config
nullptr
1
mipMapped
inputProxy
-
>
origin
(
)
)
;
if
(
!
copyRTC
)
{
return
nullptr
;
}
GrPaint
paint
;
if
(
needsDomain
)
{
const
SkRect
domain
=
localRect
.
makeInset
(
0
.
5f
0
.
5f
)
;
SkASSERT
(
copyParams
.
fFilter
!
=
GrSamplerState
:
:
Filter
:
:
kMipMap
)
;
paint
.
addColorFragmentProcessor
(
GrTextureDomainEffect
:
:
Make
(
std
:
:
move
(
inputProxy
)
SkMatrix
:
:
I
(
)
domain
GrTextureDomain
:
:
kClamp_Mode
copyParams
.
fFilter
)
)
;
}
else
{
GrSamplerState
samplerState
(
GrSamplerState
:
:
WrapMode
:
:
kClamp
copyParams
.
fFilter
)
;
paint
.
addColorTextureProcessor
(
std
:
:
move
(
inputProxy
)
SkMatrix
:
:
I
(
)
samplerState
)
;
}
paint
.
setPorterDuffXPFactory
(
SkBlendMode
:
:
kSrc
)
;
copyRTC
-
>
fillRectToRect
(
GrNoClip
(
)
std
:
:
move
(
paint
)
GrAA
:
:
kNo
SkMatrix
:
:
I
(
)
dstRect
localRect
)
;
return
copyRTC
-
>
asTextureProxyRef
(
)
;
}
GrTextureProducer
:
:
DomainMode
GrTextureProducer
:
:
DetermineDomainMode
(
const
SkRect
&
constraintRect
FilterConstraint
filterConstraint
bool
coordsLimitedToConstraintRect
GrTextureProxy
*
proxy
const
GrSamplerState
:
:
Filter
*
filterModeOrNullForBicubic
SkRect
*
domainRect
)
{
const
SkIRect
proxyBounds
=
SkIRect
:
:
MakeWH
(
proxy
-
>
width
(
)
proxy
-
>
height
(
)
)
;
SkASSERT
(
proxyBounds
.
contains
(
constraintRect
)
)
;
const
bool
proxyIsExact
=
GrProxyProvider
:
:
IsFunctionallyExact
(
proxy
)
;
if
(
constraintRect
.
contains
(
proxyBounds
)
&
&
proxyIsExact
)
{
return
kNoDomain_DomainMode
;
}
bool
restrictFilterToRect
=
(
filterConstraint
=
=
GrTextureProducer
:
:
kYes_FilterConstraint
)
;
if
(
!
restrictFilterToRect
&
&
proxyIsExact
&
&
coordsLimitedToConstraintRect
)
{
return
kNoDomain_DomainMode
;
}
SkScalar
filterHalfWidth
=
0
.
f
;
if
(
filterModeOrNullForBicubic
)
{
switch
(
*
filterModeOrNullForBicubic
)
{
case
GrSamplerState
:
:
Filter
:
:
kNearest
:
if
(
coordsLimitedToConstraintRect
)
{
return
kNoDomain_DomainMode
;
}
else
{
filterHalfWidth
=
0
.
f
;
}
break
;
case
GrSamplerState
:
:
Filter
:
:
kBilerp
:
filterHalfWidth
=
.
5f
;
break
;
case
GrSamplerState
:
:
Filter
:
:
kMipMap
:
if
(
restrictFilterToRect
|
|
!
proxyIsExact
)
{
return
kTightCopy_DomainMode
;
}
return
kNoDomain_DomainMode
;
}
}
else
{
filterHalfWidth
=
1
.
5f
;
}
static
const
SkScalar
kDomainInset
=
0
.
5f
;
if
(
restrictFilterToRect
)
{
*
domainRect
=
constraintRect
.
makeInset
(
kDomainInset
kDomainInset
)
;
}
else
if
(
!
proxyIsExact
)
{
*
domainRect
=
SkRectPriv
:
:
MakeLargest
(
)
;
if
(
coordsLimitedToConstraintRect
)
{
bool
needContentAreaConstraint
=
false
;
if
(
proxyBounds
.
fRight
-
filterHalfWidth
<
constraintRect
.
fRight
)
{
domainRect
-
>
fRight
=
proxyBounds
.
fRight
-
kDomainInset
;
needContentAreaConstraint
=
true
;
}
if
(
proxyBounds
.
fBottom
-
filterHalfWidth
<
constraintRect
.
fBottom
)
{
domainRect
-
>
fBottom
=
proxyBounds
.
fBottom
-
kDomainInset
;
needContentAreaConstraint
=
true
;
}
if
(
!
needContentAreaConstraint
)
{
return
kNoDomain_DomainMode
;
}
}
else
{
domainRect
-
>
fRight
=
proxyBounds
.
fRight
-
kDomainInset
;
domainRect
-
>
fBottom
=
proxyBounds
.
fBottom
-
kDomainInset
;
}
}
else
{
return
kNoDomain_DomainMode
;
}
if
(
domainRect
-
>
fLeft
>
domainRect
-
>
fRight
)
{
domainRect
-
>
fLeft
=
domainRect
-
>
fRight
=
SkScalarAve
(
domainRect
-
>
fLeft
domainRect
-
>
fRight
)
;
}
if
(
domainRect
-
>
fTop
>
domainRect
-
>
fBottom
)
{
domainRect
-
>
fTop
=
domainRect
-
>
fBottom
=
SkScalarAve
(
domainRect
-
>
fTop
domainRect
-
>
fBottom
)
;
}
return
kDomain_DomainMode
;
}
std
:
:
unique_ptr
<
GrFragmentProcessor
>
GrTextureProducer
:
:
createFragmentProcessorForDomainAndFilter
(
sk_sp
<
GrTextureProxy
>
proxy
const
SkMatrix
&
textureMatrix
DomainMode
domainMode
const
SkRect
&
domain
const
GrSamplerState
:
:
Filter
*
filterOrNullForBicubic
)
{
SkASSERT
(
kTightCopy_DomainMode
!
=
domainMode
)
;
bool
clampToBorderSupport
=
fContext
-
>
priv
(
)
.
caps
(
)
-
>
clampToBorderSupport
(
)
;
if
(
filterOrNullForBicubic
)
{
if
(
kDomain_DomainMode
=
=
domainMode
|
|
(
fDomainNeedsDecal
&
&
!
clampToBorderSupport
)
)
{
GrTextureDomain
:
:
Mode
wrapMode
=
fDomainNeedsDecal
?
GrTextureDomain
:
:
kDecal_Mode
:
GrTextureDomain
:
:
kClamp_Mode
;
return
GrTextureDomainEffect
:
:
Make
(
std
:
:
move
(
proxy
)
textureMatrix
domain
wrapMode
*
filterOrNullForBicubic
)
;
}
else
{
GrSamplerState
:
:
WrapMode
wrapMode
=
fDomainNeedsDecal
?
GrSamplerState
:
:
WrapMode
:
:
kClampToBorder
:
GrSamplerState
:
:
WrapMode
:
:
kClamp
;
GrSamplerState
samplerState
(
wrapMode
*
filterOrNullForBicubic
)
;
return
GrSimpleTextureEffect
:
:
Make
(
std
:
:
move
(
proxy
)
textureMatrix
samplerState
)
;
}
}
else
{
static
const
GrSamplerState
:
:
WrapMode
kClampClamp
[
]
=
{
GrSamplerState
:
:
WrapMode
:
:
kClamp
GrSamplerState
:
:
WrapMode
:
:
kClamp
}
;
static
const
GrSamplerState
:
:
WrapMode
kDecalDecal
[
]
=
{
GrSamplerState
:
:
WrapMode
:
:
kClampToBorder
GrSamplerState
:
:
WrapMode
:
:
kClampToBorder
}
;
if
(
kDomain_DomainMode
=
=
domainMode
|
|
(
fDomainNeedsDecal
&
&
!
clampToBorderSupport
)
)
{
GrTextureDomain
:
:
Mode
wrapMode
=
fDomainNeedsDecal
?
GrTextureDomain
:
:
kDecal_Mode
:
GrTextureDomain
:
:
kClamp_Mode
;
return
GrBicubicEffect
:
:
Make
(
std
:
:
move
(
proxy
)
textureMatrix
kClampClamp
wrapMode
wrapMode
kDomain_DomainMode
=
=
domainMode
?
&
domain
:
nullptr
)
;
}
else
{
return
GrBicubicEffect
:
:
Make
(
std
:
:
move
(
proxy
)
textureMatrix
fDomainNeedsDecal
?
kDecalDecal
:
kClampClamp
)
;
}
}
}
sk_sp
<
GrTextureProxy
>
GrTextureProducer
:
:
refTextureProxyForParams
(
const
GrSamplerState
:
:
Filter
*
filterOrNullForBicubic
SkScalar
scaleAdjust
[
2
]
)
{
GrSamplerState
sampler
;
if
(
filterOrNullForBicubic
)
{
sampler
.
setFilterMode
(
*
filterOrNullForBicubic
)
;
}
if
(
fDomainNeedsDecal
)
{
if
(
fContext
-
>
priv
(
)
.
caps
(
)
-
>
clampToBorderSupport
(
)
)
{
sampler
.
setWrapModeX
(
GrSamplerState
:
:
WrapMode
:
:
kClampToBorder
)
;
sampler
.
setWrapModeY
(
GrSamplerState
:
:
WrapMode
:
:
kClampToBorder
)
;
}
}
return
this
-
>
refTextureProxyForParams
(
sampler
scaleAdjust
)
;
}
sk_sp
<
GrTextureProxy
>
GrTextureProducer
:
:
refTextureProxyForParams
(
const
GrSamplerState
&
sampler
SkScalar
scaleAdjust
[
2
]
)
{
SkASSERT
(
!
scaleAdjust
|
|
(
scaleAdjust
[
0
]
=
=
1
&
&
scaleAdjust
[
1
]
=
=
1
)
)
;
SkDEBUGCODE
(
bool
expectNoScale
=
(
sampler
.
filter
(
)
!
=
GrSamplerState
:
:
Filter
:
:
kMipMap
&
&
!
sampler
.
isRepeated
(
)
)
)
;
SkASSERT
(
scaleAdjust
|
|
expectNoScale
)
;
int
mipCount
=
SkMipMap
:
:
ComputeLevelCount
(
this
-
>
width
(
)
this
-
>
height
(
)
)
;
bool
willBeMipped
=
GrSamplerState
:
:
Filter
:
:
kMipMap
=
=
sampler
.
filter
(
)
&
&
mipCount
&
&
this
-
>
context
(
)
-
>
priv
(
)
.
caps
(
)
-
>
mipMapSupport
(
)
;
auto
result
=
this
-
>
onRefTextureProxyForParams
(
sampler
willBeMipped
scaleAdjust
)
;
SkASSERT
(
!
result
|
|
!
willBeMipped
|
|
result
-
>
mipMapped
(
)
=
=
GrMipMapped
:
:
kYes
|
|
!
this
-
>
context
(
)
-
>
priv
(
)
.
caps
(
)
-
>
isConfigCopyable
(
result
-
>
config
(
)
)
)
;
SkASSERT
(
!
result
|
|
!
expectNoScale
|
|
(
result
-
>
width
(
)
=
=
this
-
>
width
(
)
&
&
result
-
>
height
(
)
=
=
this
-
>
height
(
)
)
)
;
return
result
;
}
sk_sp
<
GrTextureProxy
>
GrTextureProducer
:
:
refTextureProxy
(
GrMipMapped
willNeedMips
)
{
GrSamplerState
:
:
Filter
filter
=
GrMipMapped
:
:
kNo
=
=
willNeedMips
?
GrSamplerState
:
:
Filter
:
:
kNearest
:
GrSamplerState
:
:
Filter
:
:
kMipMap
;
GrSamplerState
sampler
(
GrSamplerState
:
:
WrapMode
:
:
kClamp
filter
)
;
int
mipCount
=
SkMipMap
:
:
ComputeLevelCount
(
this
-
>
width
(
)
this
-
>
height
(
)
)
;
bool
willBeMipped
=
GrSamplerState
:
:
Filter
:
:
kMipMap
=
=
sampler
.
filter
(
)
&
&
mipCount
&
&
this
-
>
context
(
)
-
>
priv
(
)
.
caps
(
)
-
>
mipMapSupport
(
)
;
auto
result
=
this
-
>
onRefTextureProxyForParams
(
sampler
willBeMipped
nullptr
)
;
SkASSERT
(
!
result
|
|
!
willBeMipped
|
|
result
-
>
mipMapped
(
)
=
=
GrMipMapped
:
:
kYes
|
|
!
this
-
>
context
(
)
-
>
priv
(
)
.
caps
(
)
-
>
isConfigCopyable
(
result
-
>
config
(
)
)
)
;
SkASSERT
(
!
result
|
|
(
result
-
>
width
(
)
=
=
this
-
>
width
(
)
&
&
result
-
>
height
(
)
=
=
this
-
>
height
(
)
)
)
;
return
result
;
}
