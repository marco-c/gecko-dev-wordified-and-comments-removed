#
include
"
GrTextureProducer
.
h
"
#
include
"
GrClip
.
h
"
#
include
"
GrRenderTargetContext
.
h
"
#
include
"
GrResourceProvider
.
h
"
#
include
"
GrSurfaceProxy
.
h
"
#
include
"
GrSurfaceProxyPriv
.
h
"
#
include
"
GrTexture
.
h
"
#
include
"
effects
/
GrBicubicEffect
.
h
"
#
include
"
effects
/
GrSimpleTextureEffect
.
h
"
#
include
"
effects
/
GrTextureDomain
.
h
"
sk_sp
<
GrTextureProxy
>
GrTextureProducer
:
:
CopyOnGpu
(
GrContext
*
context
sk_sp
<
GrTextureProxy
>
inputProxy
const
SkIRect
*
subset
const
CopyParams
&
copyParams
)
{
SkASSERT
(
!
subset
|
|
!
subset
-
>
isEmpty
(
)
)
;
SkASSERT
(
context
)
;
GrPixelConfig
config
=
GrMakePixelConfigUncompressed
(
inputProxy
-
>
config
(
)
)
;
const
SkRect
dstRect
=
SkRect
:
:
MakeIWH
(
copyParams
.
fWidth
copyParams
.
fHeight
)
;
sk_sp
<
GrRenderTargetContext
>
copyRTC
=
context
-
>
makeRenderTargetContextWithFallback
(
SkBackingFit
:
:
kExact
dstRect
.
width
(
)
dstRect
.
height
(
)
config
nullptr
)
;
if
(
!
copyRTC
)
{
return
nullptr
;
}
GrPaint
paint
;
paint
.
setGammaCorrect
(
true
)
;
SkRect
localRect
;
if
(
subset
)
{
localRect
=
SkRect
:
:
Make
(
*
subset
)
;
}
else
{
localRect
=
SkRect
:
:
MakeWH
(
inputProxy
-
>
width
(
)
inputProxy
-
>
height
(
)
)
;
}
bool
needsDomain
=
false
;
if
(
copyParams
.
fFilter
!
=
GrSamplerParams
:
:
kNone_FilterMode
)
{
bool
resizing
=
localRect
.
width
(
)
!
=
dstRect
.
width
(
)
|
|
localRect
.
height
(
)
!
=
dstRect
.
height
(
)
;
if
(
GrResourceProvider
:
:
IsFunctionallyExact
(
inputProxy
.
get
(
)
)
)
{
needsDomain
=
subset
&
&
resizing
;
}
else
{
needsDomain
=
resizing
;
}
}
if
(
needsDomain
)
{
const
SkRect
domain
=
localRect
.
makeInset
(
0
.
5f
0
.
5f
)
;
SkASSERT
(
copyParams
.
fFilter
!
=
GrSamplerParams
:
:
kMipMap_FilterMode
)
;
paint
.
addColorFragmentProcessor
(
GrTextureDomainEffect
:
:
Make
(
context
-
>
resourceProvider
(
)
std
:
:
move
(
inputProxy
)
nullptr
SkMatrix
:
:
I
(
)
domain
GrTextureDomain
:
:
kClamp_Mode
copyParams
.
fFilter
)
)
;
}
else
{
GrSamplerParams
params
(
SkShader
:
:
kClamp_TileMode
copyParams
.
fFilter
)
;
paint
.
addColorTextureProcessor
(
context
-
>
resourceProvider
(
)
std
:
:
move
(
inputProxy
)
nullptr
SkMatrix
:
:
I
(
)
params
)
;
}
paint
.
setPorterDuffXPFactory
(
SkBlendMode
:
:
kSrc
)
;
copyRTC
-
>
fillRectToRect
(
GrNoClip
(
)
std
:
:
move
(
paint
)
GrAA
:
:
kNo
SkMatrix
:
:
I
(
)
dstRect
localRect
)
;
return
copyRTC
-
>
asTextureProxyRef
(
)
;
}
GrTextureProducer
:
:
DomainMode
GrTextureProducer
:
:
DetermineDomainMode
(
const
SkRect
&
constraintRect
FilterConstraint
filterConstraint
bool
coordsLimitedToConstraintRect
GrTextureProxy
*
proxy
const
SkIRect
*
contentRect
const
GrSamplerParams
:
:
FilterMode
*
filterModeOrNullForBicubic
SkRect
*
domainRect
)
{
const
SkIRect
proxyBounds
=
SkIRect
:
:
MakeWH
(
proxy
-
>
width
(
)
proxy
-
>
height
(
)
)
;
SkASSERT
(
proxyBounds
.
contains
(
constraintRect
)
)
;
SkASSERT
(
!
contentRect
|
|
(
!
contentRect
-
>
contains
(
proxyBounds
)
&
&
proxyBounds
.
contains
(
*
contentRect
)
&
&
contentRect
-
>
contains
(
constraintRect
)
)
)
;
const
bool
proxyIsExact
=
GrResourceProvider
:
:
IsFunctionallyExact
(
proxy
)
;
if
(
constraintRect
.
contains
(
proxyBounds
)
&
&
proxyIsExact
)
{
return
kNoDomain_DomainMode
;
}
if
(
!
contentRect
&
&
!
proxyIsExact
)
{
contentRect
=
&
proxyBounds
;
}
bool
restrictFilterToRect
=
(
filterConstraint
=
=
GrTextureProducer
:
:
kYes_FilterConstraint
)
;
if
(
!
restrictFilterToRect
&
&
!
contentRect
&
&
coordsLimitedToConstraintRect
)
{
return
kNoDomain_DomainMode
;
}
SkScalar
filterHalfWidth
=
0
.
f
;
if
(
filterModeOrNullForBicubic
)
{
switch
(
*
filterModeOrNullForBicubic
)
{
case
GrSamplerParams
:
:
kNone_FilterMode
:
if
(
coordsLimitedToConstraintRect
)
{
return
kNoDomain_DomainMode
;
}
else
{
filterHalfWidth
=
0
.
f
;
}
break
;
case
GrSamplerParams
:
:
kBilerp_FilterMode
:
filterHalfWidth
=
.
5f
;
break
;
case
GrSamplerParams
:
:
kMipMap_FilterMode
:
if
(
restrictFilterToRect
|
|
contentRect
)
{
return
kTightCopy_DomainMode
;
}
return
kNoDomain_DomainMode
;
}
}
else
{
filterHalfWidth
=
1
.
5f
;
}
static
const
SkScalar
kDomainInset
=
0
.
5f
;
if
(
restrictFilterToRect
)
{
*
domainRect
=
constraintRect
.
makeInset
(
kDomainInset
kDomainInset
)
;
}
else
if
(
contentRect
)
{
domainRect
-
>
setLargest
(
)
;
if
(
coordsLimitedToConstraintRect
)
{
bool
needContentAreaConstraint
=
false
;
if
(
contentRect
-
>
fLeft
>
0
&
&
contentRect
-
>
fLeft
+
filterHalfWidth
>
constraintRect
.
fLeft
)
{
domainRect
-
>
fLeft
=
contentRect
-
>
fLeft
+
kDomainInset
;
needContentAreaConstraint
=
true
;
}
if
(
contentRect
-
>
fTop
>
0
&
&
contentRect
-
>
fTop
+
filterHalfWidth
>
constraintRect
.
fTop
)
{
domainRect
-
>
fTop
=
contentRect
-
>
fTop
+
kDomainInset
;
needContentAreaConstraint
=
true
;
}
if
(
(
!
proxyIsExact
|
|
contentRect
-
>
fRight
<
proxy
-
>
width
(
)
)
&
&
contentRect
-
>
fRight
-
filterHalfWidth
<
constraintRect
.
fRight
)
{
domainRect
-
>
fRight
=
contentRect
-
>
fRight
-
kDomainInset
;
needContentAreaConstraint
=
true
;
}
if
(
(
!
proxyIsExact
|
|
contentRect
-
>
fBottom
<
proxy
-
>
height
(
)
)
&
&
contentRect
-
>
fBottom
-
filterHalfWidth
<
constraintRect
.
fBottom
)
{
domainRect
-
>
fBottom
=
contentRect
-
>
fBottom
-
kDomainInset
;
needContentAreaConstraint
=
true
;
}
if
(
!
needContentAreaConstraint
)
{
return
kNoDomain_DomainMode
;
}
}
else
{
if
(
contentRect
-
>
fLeft
>
0
)
{
domainRect
-
>
fLeft
=
contentRect
-
>
fLeft
+
kDomainInset
;
}
if
(
contentRect
-
>
fTop
>
0
)
{
domainRect
-
>
fTop
=
contentRect
-
>
fTop
+
kDomainInset
;
}
if
(
!
proxyIsExact
|
|
contentRect
-
>
fRight
<
proxy
-
>
width
(
)
)
{
domainRect
-
>
fRight
=
contentRect
-
>
fRight
-
kDomainInset
;
}
if
(
!
proxyIsExact
|
|
contentRect
-
>
fBottom
<
proxy
-
>
height
(
)
)
{
domainRect
-
>
fBottom
=
contentRect
-
>
fBottom
-
kDomainInset
;
}
}
}
else
{
return
kNoDomain_DomainMode
;
}
if
(
domainRect
-
>
fLeft
>
domainRect
-
>
fRight
)
{
domainRect
-
>
fLeft
=
domainRect
-
>
fRight
=
SkScalarAve
(
domainRect
-
>
fLeft
domainRect
-
>
fRight
)
;
}
if
(
domainRect
-
>
fTop
>
domainRect
-
>
fBottom
)
{
domainRect
-
>
fTop
=
domainRect
-
>
fBottom
=
SkScalarAve
(
domainRect
-
>
fTop
domainRect
-
>
fBottom
)
;
}
return
kDomain_DomainMode
;
}
sk_sp
<
GrFragmentProcessor
>
GrTextureProducer
:
:
CreateFragmentProcessorForDomainAndFilter
(
GrResourceProvider
*
resourceProvider
sk_sp
<
GrTextureProxy
>
proxy
sk_sp
<
GrColorSpaceXform
>
colorSpaceXform
const
SkMatrix
&
textureMatrix
DomainMode
domainMode
const
SkRect
&
domain
const
GrSamplerParams
:
:
FilterMode
*
filterOrNullForBicubic
)
{
SkASSERT
(
kTightCopy_DomainMode
!
=
domainMode
)
;
if
(
filterOrNullForBicubic
)
{
if
(
kDomain_DomainMode
=
=
domainMode
)
{
return
GrTextureDomainEffect
:
:
Make
(
resourceProvider
std
:
:
move
(
proxy
)
std
:
:
move
(
colorSpaceXform
)
textureMatrix
domain
GrTextureDomain
:
:
kClamp_Mode
*
filterOrNullForBicubic
)
;
}
else
{
GrSamplerParams
params
(
SkShader
:
:
kClamp_TileMode
*
filterOrNullForBicubic
)
;
return
GrSimpleTextureEffect
:
:
Make
(
resourceProvider
std
:
:
move
(
proxy
)
std
:
:
move
(
colorSpaceXform
)
textureMatrix
params
)
;
}
}
else
{
if
(
kDomain_DomainMode
=
=
domainMode
)
{
return
GrBicubicEffect
:
:
Make
(
resourceProvider
std
:
:
move
(
proxy
)
std
:
:
move
(
colorSpaceXform
)
textureMatrix
domain
)
;
}
else
{
static
const
SkShader
:
:
TileMode
kClampClamp
[
]
=
{
SkShader
:
:
kClamp_TileMode
SkShader
:
:
kClamp_TileMode
}
;
return
GrBicubicEffect
:
:
Make
(
resourceProvider
std
:
:
move
(
proxy
)
std
:
:
move
(
colorSpaceXform
)
textureMatrix
kClampClamp
)
;
}
}
}
