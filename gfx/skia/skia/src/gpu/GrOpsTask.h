#
ifndef
GrOpsTask_DEFINED
#
define
GrOpsTask_DEFINED
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkStrokeRec
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
SkColorData
.
h
"
#
include
"
include
/
private
/
SkTArray
.
h
"
#
include
"
include
/
private
/
SkTDArray
.
h
"
#
include
"
src
/
core
/
SkArenaAlloc
.
h
"
#
include
"
src
/
core
/
SkClipStack
.
h
"
#
include
"
src
/
core
/
SkStringUtils
.
h
"
#
include
"
src
/
core
/
SkTLazy
.
h
"
#
include
"
src
/
gpu
/
GrAppliedClip
.
h
"
#
include
"
src
/
gpu
/
GrPathRendering
.
h
"
#
include
"
src
/
gpu
/
GrPrimitiveProcessor
.
h
"
#
include
"
src
/
gpu
/
GrRenderTask
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrDrawOp
.
h
"
#
include
"
src
/
gpu
/
ops
/
GrOp
.
h
"
class
GrAuditTrail
;
class
GrCaps
;
class
GrClearOp
;
class
GrGpuBuffer
;
class
GrOpMemoryPool
;
class
GrRenderTargetProxy
;
class
GrOpsTask
:
public
GrRenderTask
{
private
:
using
DstProxy
=
GrXferProcessor
:
:
DstProxy
;
public
:
GrOpsTask
(
sk_sp
<
GrOpMemoryPool
>
sk_sp
<
GrRenderTargetProxy
>
GrAuditTrail
*
)
;
~
GrOpsTask
(
)
override
;
GrOpsTask
*
asOpsTask
(
)
override
{
return
this
;
}
bool
isEmpty
(
)
const
{
return
fOpChains
.
empty
(
)
;
}
void
endFlush
(
)
override
;
void
onPrePrepare
(
GrRecordingContext
*
)
override
;
void
onPrepare
(
GrOpFlushState
*
flushState
)
override
;
bool
onExecute
(
GrOpFlushState
*
flushState
)
override
;
void
addSampledTexture
(
GrTextureProxy
*
proxy
)
{
fSampledProxies
.
push_back
(
proxy
)
;
}
void
addOp
(
std
:
:
unique_ptr
<
GrOp
>
op
GrTextureResolveManager
textureResolveManager
const
GrCaps
&
caps
)
{
auto
addDependency
=
[
textureResolveManager
&
caps
this
]
(
GrTextureProxy
*
p
GrMipMapped
mipmapped
)
{
this
-
>
addDependency
(
p
mipmapped
textureResolveManager
caps
)
;
}
;
op
-
>
visitProxies
(
addDependency
)
;
this
-
>
recordOp
(
std
:
:
move
(
op
)
GrProcessorSet
:
:
EmptySetAnalysis
(
)
nullptr
nullptr
caps
)
;
}
void
addWaitOp
(
std
:
:
unique_ptr
<
GrOp
>
op
GrTextureResolveManager
textureResolveManager
const
GrCaps
&
caps
)
{
fHasWaitOp
=
true
;
this
-
>
addOp
(
std
:
:
move
(
op
)
textureResolveManager
caps
)
;
}
void
addDrawOp
(
std
:
:
unique_ptr
<
GrDrawOp
>
op
const
GrProcessorSet
:
:
Analysis
&
processorAnalysis
GrAppliedClip
&
&
clip
const
DstProxy
&
dstProxy
GrTextureResolveManager
textureResolveManager
const
GrCaps
&
caps
)
{
auto
addDependency
=
[
textureResolveManager
&
caps
this
]
(
GrTextureProxy
*
p
GrMipMapped
mipmapped
)
{
this
-
>
addSampledTexture
(
p
)
;
this
-
>
addDependency
(
p
mipmapped
textureResolveManager
caps
)
;
}
;
op
-
>
visitProxies
(
addDependency
)
;
clip
.
visitProxies
(
addDependency
)
;
if
(
dstProxy
.
proxy
(
)
)
{
this
-
>
addSampledTexture
(
dstProxy
.
proxy
(
)
)
;
addDependency
(
dstProxy
.
proxy
(
)
GrMipMapped
:
:
kNo
)
;
}
this
-
>
recordOp
(
std
:
:
move
(
op
)
processorAnalysis
clip
.
doesClip
(
)
?
&
clip
:
nullptr
&
dstProxy
caps
)
;
}
void
discard
(
)
;
SkDEBUGCODE
(
void
dump
(
bool
printDependencies
)
const
override
;
)
SkDEBUGCODE
(
int
numClips
(
)
const
override
{
return
fNumClips
;
}
)
SkDEBUGCODE
(
void
visitProxies_debugOnly
(
const
VisitSurfaceProxyFunc
&
)
const
override
;
)
private
:
bool
isNoOp
(
)
const
{
return
fOpChains
.
empty
(
)
&
&
GrLoadOp
:
:
kLoad
=
=
fColorLoadOp
;
}
void
deleteOps
(
)
;
enum
class
StencilContent
{
kDontCare
kUserBitsCleared
kPreserved
}
;
void
setInitialStencilContent
(
StencilContent
initialContent
)
{
fInitialStencilContent
=
initialContent
;
}
void
setMustPreserveStencil
(
)
{
fMustPreserveStencil
=
true
;
}
void
setColorLoadOp
(
GrLoadOp
op
const
SkPMColor4f
&
color
)
;
void
setColorLoadOp
(
GrLoadOp
op
)
{
static
const
SkPMColor4f
kDefaultClearColor
=
{
0
.
f
0
.
f
0
.
f
0
.
f
}
;
this
-
>
setColorLoadOp
(
op
kDefaultClearColor
)
;
}
enum
class
CanDiscardPreviousOps
:
bool
{
kYes
=
true
kNo
=
false
}
;
bool
resetForFullscreenClear
(
CanDiscardPreviousOps
)
;
class
OpChain
{
public
:
OpChain
(
const
OpChain
&
)
=
delete
;
OpChain
&
operator
=
(
const
OpChain
&
)
=
delete
;
OpChain
(
std
:
:
unique_ptr
<
GrOp
>
GrProcessorSet
:
:
Analysis
GrAppliedClip
*
const
DstProxy
*
)
;
~
OpChain
(
)
{
SkASSERT
(
fList
.
empty
(
)
)
;
}
void
visitProxies
(
const
GrOp
:
:
VisitProxyFunc
&
)
const
;
GrOp
*
head
(
)
const
{
return
fList
.
head
(
)
;
}
GrAppliedClip
*
appliedClip
(
)
const
{
return
fAppliedClip
;
}
const
DstProxy
&
dstProxy
(
)
const
{
return
fDstProxy
;
}
const
SkRect
&
bounds
(
)
const
{
return
fBounds
;
}
void
deleteOps
(
GrOpMemoryPool
*
pool
)
;
bool
prependChain
(
OpChain
*
const
GrCaps
&
GrOpMemoryPool
*
GrAuditTrail
*
)
;
std
:
:
unique_ptr
<
GrOp
>
appendOp
(
std
:
:
unique_ptr
<
GrOp
>
op
GrProcessorSet
:
:
Analysis
const
DstProxy
*
const
GrAppliedClip
*
const
GrCaps
&
GrOpMemoryPool
*
GrAuditTrail
*
)
;
void
setSkipExecuteFlag
(
)
{
fSkipExecute
=
true
;
}
bool
shouldExecute
(
)
const
{
return
SkToBool
(
this
-
>
head
(
)
)
&
&
!
fSkipExecute
;
}
private
:
class
List
{
public
:
List
(
)
=
default
;
List
(
std
:
:
unique_ptr
<
GrOp
>
)
;
List
(
List
&
&
)
;
List
&
operator
=
(
List
&
&
that
)
;
bool
empty
(
)
const
{
return
!
SkToBool
(
fHead
)
;
}
GrOp
*
head
(
)
const
{
return
fHead
.
get
(
)
;
}
GrOp
*
tail
(
)
const
{
return
fTail
;
}
std
:
:
unique_ptr
<
GrOp
>
popHead
(
)
;
std
:
:
unique_ptr
<
GrOp
>
removeOp
(
GrOp
*
op
)
;
void
pushHead
(
std
:
:
unique_ptr
<
GrOp
>
op
)
;
void
pushTail
(
std
:
:
unique_ptr
<
GrOp
>
)
;
void
validate
(
)
const
;
private
:
std
:
:
unique_ptr
<
GrOp
>
fHead
;
GrOp
*
fTail
=
nullptr
;
}
;
void
validate
(
)
const
;
bool
tryConcat
(
List
*
GrProcessorSet
:
:
Analysis
const
DstProxy
&
const
GrAppliedClip
*
const
SkRect
&
bounds
const
GrCaps
&
GrOpMemoryPool
*
GrAuditTrail
*
)
;
static
List
DoConcat
(
List
List
const
GrCaps
&
GrOpMemoryPool
*
GrAuditTrail
*
)
;
List
fList
;
GrProcessorSet
:
:
Analysis
fProcessorAnalysis
;
DstProxy
fDstProxy
;
GrAppliedClip
*
fAppliedClip
;
SkRect
fBounds
;
bool
fSkipExecute
=
false
;
}
;
bool
onIsUsed
(
GrSurfaceProxy
*
)
const
override
;
void
handleInternalAllocationFailure
(
)
override
;
void
gatherProxyIntervals
(
GrResourceAllocator
*
)
const
override
;
void
recordOp
(
std
:
:
unique_ptr
<
GrOp
>
GrProcessorSet
:
:
Analysis
GrAppliedClip
*
const
DstProxy
*
const
GrCaps
&
caps
)
;
void
forwardCombine
(
const
GrCaps
&
)
;
ExpectedOutcome
onMakeClosed
(
const
GrCaps
&
caps
SkIRect
*
targetUpdateBounds
)
override
;
friend
class
GrRenderTargetContextPriv
;
friend
class
GrRenderTargetContext
;
sk_sp
<
GrOpMemoryPool
>
fOpMemoryPool
;
GrAuditTrail
*
fAuditTrail
;
GrLoadOp
fColorLoadOp
=
GrLoadOp
:
:
kLoad
;
SkPMColor4f
fLoadClearColor
=
SK_PMColor4fTRANSPARENT
;
StencilContent
fInitialStencilContent
=
StencilContent
:
:
kDontCare
;
bool
fMustPreserveStencil
=
false
;
uint32_t
fLastClipStackGenID
;
SkIRect
fLastDevClipBounds
;
int
fLastClipNumAnalyticFPs
;
bool
fHasWaitOp
=
false
;
;
SkSTArray
<
25
OpChain
true
>
fOpChains
;
SkArenaAlloc
fClipAllocator
{
4096
}
;
SkDEBUGCODE
(
int
fNumClips
;
)
SkTArray
<
GrTextureProxy
*
true
>
fSampledProxies
;
SkRect
fTotalBounds
=
SkRect
:
:
MakeEmpty
(
)
;
SkIRect
fClippedContentBounds
=
SkIRect
:
:
MakeEmpty
(
)
;
}
;
#
endif
