#
ifndef
GrProcessor_DEFINED
#
define
GrProcessor_DEFINED
#
include
"
.
.
/
private
/
SkAtomics
.
h
"
#
include
"
GrBuffer
.
h
"
#
include
"
GrColor
.
h
"
#
include
"
GrGpuResourceRef
.
h
"
#
include
"
GrProcessorUnitTest
.
h
"
#
include
"
GrProgramElement
.
h
"
#
include
"
GrSamplerState
.
h
"
#
include
"
GrShaderVar
.
h
"
#
include
"
GrSurfaceProxyPriv
.
h
"
#
include
"
GrSurfaceProxyRef
.
h
"
#
include
"
GrTextureProxy
.
h
"
#
include
"
SkMath
.
h
"
#
include
"
SkString
.
h
"
class
GrContext
;
class
GrCoordTransform
;
class
GrInvariantOutput
;
class
GrResourceProvider
;
class
GrProcessorKeyBuilder
{
public
:
GrProcessorKeyBuilder
(
SkTArray
<
unsigned
char
true
>
*
data
)
:
fData
(
data
)
fCount
(
0
)
{
SkASSERT
(
0
=
=
fData
-
>
count
(
)
%
sizeof
(
uint32_t
)
)
;
}
void
add32
(
uint32_t
v
)
{
+
+
fCount
;
fData
-
>
push_back_n
(
4
reinterpret_cast
<
uint8_t
*
>
(
&
v
)
)
;
}
uint32_t
*
SK_WARN_UNUSED_RESULT
add32n
(
int
count
)
{
SkASSERT
(
count
>
0
)
;
fCount
+
=
count
;
return
reinterpret_cast
<
uint32_t
*
>
(
fData
-
>
push_back_n
(
4
*
count
)
)
;
}
size_t
size
(
)
const
{
return
sizeof
(
uint32_t
)
*
fCount
;
}
private
:
SkTArray
<
uint8_t
true
>
*
fData
;
int
fCount
;
}
;
class
GrProcessor
{
public
:
enum
ClassID
{
kBigKeyProcessor_ClassID
kBlockInputFragmentProcessor_ClassID
kCircleGeometryProcessor_ClassID
kCircularRRectEffect_ClassID
kColorMatrixEffect_ClassID
kColorTableEffect_ClassID
kComposeOneFragmentProcessor_ClassID
kComposeTwoFragmentProcessor_ClassID
kCoverageSetOpXP_ClassID
kCustomXP_ClassID
kDashingCircleEffect_ClassID
kDashingLineEffect_ClassID
kDefaultGeoProc_ClassID
kDIEllipseGeometryProcessor_ClassID
kDisableColorXP_ClassID
kTwoPointConicalEffect_ClassID
kEllipseGeometryProcessor_ClassID
kEllipticalRRectEffect_ClassID
kGP_ClassID
kGrAARectEffect_ClassID
kGrAlphaThresholdFragmentProcessor_ClassID
kGrArithmeticFP_ClassID
kGrBicubicEffect_ClassID
kGrBitmapTextGeoProc_ClassID
kGrBlurredEdgeFragmentProcessor_ClassID
kGrCCClipProcessor_ClassID
kGrCCCoverageProcessor_ClassID
kGrCCPathProcessor_ClassID
kGrCircleBlurFragmentProcessor_ClassID
kGrCircleEffect_ClassID
kGrColorSpaceXformEffect_ClassID
kGrConfigConversionEffect_ClassID
kGrConicEffect_ClassID
kGrConstColorProcessor_ClassID
kGrConvexPolyEffect_ClassID
kGrCubicEffect_ClassID
kGrDeviceSpaceTextureDecalFragmentProcessor_ClassID
kGrDiffuseLightingEffect_ClassID
kGrDisplacementMapEffect_ClassID
kGrDistanceFieldA8TextGeoProc_ClassID
kGrDistanceFieldLCDTextGeoProc_ClassID
kGrDistanceFieldPathGeoProc_ClassID
kGrDitherEffect_ClassID
kGrEllipseEffect_ClassID
kGrGaussianConvolutionFragmentProcessor_ClassID
kGrImprovedPerlinNoiseEffect_ClassID
kGrLightingEffect_ClassID
kGrLinearGradient_ClassID
kGrLumaColorFilterEffect_ClassID
kGrMagnifierEffect_ClassID
kGrMatrixConvolutionEffect_ClassID
kGrMeshTestProcessor_ClassID
kGrMorphologyEffect_ClassID
kGrNonlinearColorSpaceXformEffect_ClassID
kGrOverdrawFragmentProcessor_ClassID
kGrPathProcessor_ClassID
kGrPerlinNoise2Effect_ClassID
kGrPipelineDynamicStateTestProcessor_ClassID
kGrPremulInputFragmentProcessor_ClassID
kGrQuadEffect_ClassID
kGrRadialGradient_ClassID
kGrRectBlurEffect_ClassID
kGrRRectBlurEffect_ClassID
kGrRRectShadowGeoProc_ClassID
kGrSimpleTextureEffect_ClassID
kGrSpecularLightingEffect_ClassID
kGrSRGBEffect_ClassID
kGrSweepGradient_ClassID
kGrTextureDomainEffect_ClassID
kGrUnpremulInputFragmentProcessor_ClassID
kGrYUVtoRGBEffect_ClassID
kHighContrastFilterEffect_ClassID
kInstanceProcessor_ClassID
kLumaColorFilterEffect_ClassID
kMSAAQuadProcessor_ClassID
kPDLCDXferProcessor_ClassID
kPorterDuffXferProcessor_ClassID
kPremulFragmentProcessor_ClassID
kQuadEdgeEffect_ClassID
kReplaceInputFragmentProcessor_ClassID
kRRectsGaussianEdgeFP_ClassID
kSeriesFragmentProcessor_ClassID
kShaderPDXferProcessor_ClassID
kSwizzleFragmentProcessor_ClassID
kTestFP_ClassID
kTextureGeometryProcessor_ClassID
}
;
virtual
~
GrProcessor
(
)
=
default
;
virtual
const
char
*
name
(
)
const
=
0
;
virtual
SkString
dumpInfo
(
)
const
{
SkString
str
;
str
.
appendf
(
"
Missing
data
"
)
;
return
str
;
}
void
*
operator
new
(
size_t
size
)
;
void
operator
delete
(
void
*
target
)
;
void
*
operator
new
(
size_t
size
void
*
placement
)
{
return
:
:
operator
new
(
size
placement
)
;
}
void
operator
delete
(
void
*
target
void
*
placement
)
{
:
:
operator
delete
(
target
placement
)
;
}
template
<
typename
T
>
const
T
&
cast
(
)
const
{
return
*
static_cast
<
const
T
*
>
(
this
)
;
}
ClassID
classID
(
)
const
{
return
fClassID
;
}
protected
:
GrProcessor
(
ClassID
classID
)
:
fClassID
(
classID
)
{
}
private
:
GrProcessor
(
const
GrProcessor
&
)
=
delete
;
GrProcessor
&
operator
=
(
const
GrProcessor
&
)
=
delete
;
ClassID
fClassID
;
}
;
class
GrResourceIOProcessor
:
public
GrProcessor
{
public
:
class
TextureSampler
;
class
BufferAccess
;
int
numTextureSamplers
(
)
const
{
return
fTextureSamplers
.
count
(
)
;
}
const
TextureSampler
&
textureSampler
(
int
index
)
const
{
return
*
fTextureSamplers
[
index
]
;
}
int
numBuffers
(
)
const
{
return
fBufferAccesses
.
count
(
)
;
}
const
BufferAccess
&
bufferAccess
(
int
index
)
const
{
return
*
fBufferAccesses
[
index
]
;
}
bool
instantiate
(
GrResourceProvider
*
resourceProvider
)
const
;
protected
:
GrResourceIOProcessor
(
ClassID
classID
)
:
INHERITED
(
classID
)
{
}
void
addTextureSampler
(
const
TextureSampler
*
)
;
void
addBufferAccess
(
const
BufferAccess
*
)
;
bool
hasSameSamplersAndAccesses
(
const
GrResourceIOProcessor
&
)
const
;
void
addPendingIOs
(
)
const
;
void
removeRefs
(
)
const
;
void
pendingIOComplete
(
)
const
;
private
:
SkSTArray
<
4
const
TextureSampler
*
true
>
fTextureSamplers
;
SkSTArray
<
1
const
BufferAccess
*
true
>
fBufferAccesses
;
typedef
GrProcessor
INHERITED
;
}
;
class
GrResourceIOProcessor
:
:
TextureSampler
{
public
:
TextureSampler
(
)
;
explicit
TextureSampler
(
const
TextureSampler
&
that
)
:
fProxyRef
(
sk_ref_sp
(
that
.
fProxyRef
.
get
(
)
)
that
.
fProxyRef
.
ioType
(
)
)
fSamplerState
(
that
.
fSamplerState
)
fVisibility
(
that
.
fVisibility
)
{
}
TextureSampler
(
sk_sp
<
GrTextureProxy
>
const
GrSamplerState
&
)
;
explicit
TextureSampler
(
sk_sp
<
GrTextureProxy
>
GrSamplerState
:
:
Filter
=
GrSamplerState
:
:
Filter
:
:
kNearest
GrSamplerState
:
:
WrapMode
wrapXAndY
=
GrSamplerState
:
:
WrapMode
:
:
kClamp
GrShaderFlags
visibility
=
kFragment_GrShaderFlag
)
;
TextureSampler
&
operator
=
(
const
TextureSampler
&
)
=
delete
;
void
reset
(
sk_sp
<
GrTextureProxy
>
const
GrSamplerState
&
GrShaderFlags
visibility
=
kFragment_GrShaderFlag
)
;
void
reset
(
sk_sp
<
GrTextureProxy
>
GrSamplerState
:
:
Filter
=
GrSamplerState
:
:
Filter
:
:
kNearest
GrSamplerState
:
:
WrapMode
wrapXAndY
=
GrSamplerState
:
:
WrapMode
:
:
kClamp
GrShaderFlags
visibility
=
kFragment_GrShaderFlag
)
;
bool
operator
=
=
(
const
TextureSampler
&
that
)
const
{
return
this
-
>
proxy
(
)
-
>
underlyingUniqueID
(
)
=
=
that
.
proxy
(
)
-
>
underlyingUniqueID
(
)
&
&
fSamplerState
=
=
that
.
fSamplerState
&
&
fVisibility
=
=
that
.
fVisibility
;
}
bool
operator
!
=
(
const
TextureSampler
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
bool
instantiate
(
GrResourceProvider
*
resourceProvider
)
const
{
return
SkToBool
(
fProxyRef
.
get
(
)
-
>
instantiate
(
resourceProvider
)
)
;
}
GrTexture
*
peekTexture
(
)
const
{
SkASSERT
(
fProxyRef
.
get
(
)
-
>
priv
(
)
.
peekTexture
(
)
)
;
return
fProxyRef
.
get
(
)
-
>
priv
(
)
.
peekTexture
(
)
;
}
GrTextureProxy
*
proxy
(
)
const
{
return
fProxyRef
.
get
(
)
-
>
asTextureProxy
(
)
;
}
GrShaderFlags
visibility
(
)
const
{
return
fVisibility
;
}
const
GrSamplerState
&
samplerState
(
)
const
{
return
fSamplerState
;
}
bool
isInitialized
(
)
const
{
return
SkToBool
(
fProxyRef
.
get
(
)
)
;
}
const
GrSurfaceProxyRef
*
programProxy
(
)
const
{
return
&
fProxyRef
;
}
private
:
GrSurfaceProxyRef
fProxyRef
;
GrSamplerState
fSamplerState
;
GrShaderFlags
fVisibility
;
}
;
class
GrResourceIOProcessor
:
:
BufferAccess
{
public
:
BufferAccess
(
)
=
default
;
BufferAccess
(
GrPixelConfig
texelConfig
GrBuffer
*
buffer
GrShaderFlags
visibility
=
kFragment_GrShaderFlag
)
{
this
-
>
reset
(
texelConfig
buffer
visibility
)
;
}
explicit
BufferAccess
(
const
BufferAccess
&
that
)
{
this
-
>
reset
(
that
.
fTexelConfig
that
.
fBuffer
.
get
(
)
that
.
fVisibility
)
;
}
BufferAccess
&
operator
=
(
const
BufferAccess
&
)
=
delete
;
void
reset
(
GrPixelConfig
texelConfig
GrBuffer
*
buffer
GrShaderFlags
visibility
=
kFragment_GrShaderFlag
)
{
fTexelConfig
=
texelConfig
;
fBuffer
.
set
(
SkRef
(
buffer
)
kRead_GrIOType
)
;
fVisibility
=
visibility
;
}
bool
operator
=
=
(
const
BufferAccess
&
that
)
const
{
return
fTexelConfig
=
=
that
.
fTexelConfig
&
&
this
-
>
buffer
(
)
=
=
that
.
buffer
(
)
&
&
fVisibility
=
=
that
.
fVisibility
;
}
bool
operator
!
=
(
const
BufferAccess
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
GrPixelConfig
texelConfig
(
)
const
{
return
fTexelConfig
;
}
GrBuffer
*
buffer
(
)
const
{
return
fBuffer
.
get
(
)
;
}
GrShaderFlags
visibility
(
)
const
{
return
fVisibility
;
}
const
GrGpuResourceRef
*
programBuffer
(
)
const
{
return
&
fBuffer
;
}
private
:
GrPixelConfig
fTexelConfig
;
GrTGpuResourceRef
<
GrBuffer
>
fBuffer
;
GrShaderFlags
fVisibility
;
typedef
SkNoncopyable
INHERITED
;
}
;
#
endif
