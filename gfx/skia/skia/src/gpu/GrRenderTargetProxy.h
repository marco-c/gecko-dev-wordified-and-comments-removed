#
ifndef
GrRenderTargetProxy_DEFINED
#
define
GrRenderTargetProxy_DEFINED
#
include
"
include
/
private
/
GrTypesPriv
.
h
"
#
include
"
src
/
gpu
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
GrSurfaceProxy
.
h
"
#
include
"
src
/
gpu
/
GrSwizzle
.
h
"
class
GrResourceProvider
;
class
GrRenderTargetProxyPriv
;
class
GrRenderTargetProxy
:
virtual
public
GrSurfaceProxy
{
public
:
GrRenderTargetProxy
*
asRenderTargetProxy
(
)
override
{
return
this
;
}
const
GrRenderTargetProxy
*
asRenderTargetProxy
(
)
const
override
{
return
this
;
}
bool
instantiate
(
GrResourceProvider
*
)
override
;
bool
canUseMixedSamples
(
const
GrCaps
&
caps
)
const
{
return
caps
.
mixedSamplesSupport
(
)
&
&
!
this
-
>
glRTFBOIDIs0
(
)
&
&
caps
.
internalMultisampleCount
(
this
-
>
backendFormat
(
)
)
>
0
&
&
this
-
>
canChangeStencilAttachment
(
)
;
}
void
setNeedsStencil
(
int8_t
numStencilSamples
)
{
SkASSERT
(
numStencilSamples
>
=
fSampleCnt
)
;
fNumStencilSamples
=
SkTMax
(
numStencilSamples
fNumStencilSamples
)
;
}
int
numStencilSamples
(
)
const
{
return
fNumStencilSamples
;
}
int
numSamples
(
)
const
{
return
fSampleCnt
;
}
int
maxWindowRectangles
(
const
GrCaps
&
caps
)
const
;
const
GrSwizzle
&
outputSwizzle
(
)
const
{
return
fOutputSwizzle
;
}
bool
wrapsVkSecondaryCB
(
)
const
{
return
fWrapsVkSecondaryCB
=
=
WrapsVkSecondaryCB
:
:
kYes
;
}
void
markMSAADirty
(
const
SkIRect
&
dirtyRect
)
{
SkASSERT
(
SkIRect
:
:
MakeWH
(
this
-
>
width
(
)
this
-
>
height
(
)
)
.
contains
(
dirtyRect
)
)
;
SkASSERT
(
this
-
>
requiresManualMSAAResolve
(
)
)
;
fMSAADirtyRect
.
join
(
dirtyRect
)
;
}
void
markMSAAResolved
(
)
{
SkASSERT
(
this
-
>
requiresManualMSAAResolve
(
)
)
;
fMSAADirtyRect
.
setEmpty
(
)
;
}
bool
isMSAADirty
(
)
const
{
SkASSERT
(
fMSAADirtyRect
.
isEmpty
(
)
|
|
this
-
>
requiresManualMSAAResolve
(
)
)
;
return
this
-
>
requiresManualMSAAResolve
(
)
&
&
!
fMSAADirtyRect
.
isEmpty
(
)
;
}
const
SkIRect
&
msaaDirtyRect
(
)
const
{
SkASSERT
(
this
-
>
requiresManualMSAAResolve
(
)
)
;
return
fMSAADirtyRect
;
}
bool
refsWrappedObjects
(
)
const
;
GrRenderTargetProxyPriv
rtPriv
(
)
;
const
GrRenderTargetProxyPriv
rtPriv
(
)
const
;
protected
:
friend
class
GrProxyProvider
;
friend
class
GrRenderTargetProxyPriv
;
GrRenderTargetProxy
(
const
GrCaps
&
const
GrBackendFormat
&
const
GrSurfaceDesc
&
int
sampleCount
GrSurfaceOrigin
const
GrSwizzle
&
textureSwizzle
const
GrSwizzle
&
outputSwizzle
SkBackingFit
SkBudgeted
GrProtected
GrInternalSurfaceFlags
UseAllocator
)
;
enum
class
WrapsVkSecondaryCB
:
bool
{
kNo
=
false
kYes
=
true
}
;
GrRenderTargetProxy
(
LazyInstantiateCallback
&
&
const
GrBackendFormat
&
const
GrSurfaceDesc
&
int
sampleCount
GrSurfaceOrigin
const
GrSwizzle
&
textureSwizzle
const
GrSwizzle
&
outputSwizzle
SkBackingFit
SkBudgeted
GrProtected
GrInternalSurfaceFlags
UseAllocator
WrapsVkSecondaryCB
)
;
GrRenderTargetProxy
(
sk_sp
<
GrSurface
>
GrSurfaceOrigin
const
GrSwizzle
&
textureSwizzle
const
GrSwizzle
&
outputSwizzle
UseAllocator
WrapsVkSecondaryCB
=
WrapsVkSecondaryCB
:
:
kNo
)
;
sk_sp
<
GrSurface
>
createSurface
(
GrResourceProvider
*
)
const
override
;
private
:
void
setGLRTFBOIDIs0
(
)
{
fSurfaceFlags
|
=
GrInternalSurfaceFlags
:
:
kGLRTFBOIDIs0
;
}
bool
glRTFBOIDIs0
(
)
const
{
return
fSurfaceFlags
&
GrInternalSurfaceFlags
:
:
kGLRTFBOIDIs0
;
}
bool
canChangeStencilAttachment
(
)
const
;
size_t
onUninstantiatedGpuMemorySize
(
const
GrCaps
&
)
const
override
;
SkDEBUGCODE
(
void
onValidateSurface
(
const
GrSurface
*
)
override
;
)
int8_t
fSampleCnt
;
int8_t
fNumStencilSamples
=
0
;
WrapsVkSecondaryCB
fWrapsVkSecondaryCB
;
GrSwizzle
fOutputSwizzle
;
SkIRect
fMSAADirtyRect
=
SkIRect
:
:
MakeEmpty
(
)
;
char
fDummyPadding
[
10
]
;
typedef
GrSurfaceProxy
INHERITED
;
}
;
#
endif
