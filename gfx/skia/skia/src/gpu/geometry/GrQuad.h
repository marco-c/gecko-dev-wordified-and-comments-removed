#
ifndef
GrQuad_DEFINED
#
define
GrQuad_DEFINED
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkPoint3
.
h
"
#
include
"
include
/
private
/
SkVx
.
h
"
class
GrQuad
{
public
:
enum
class
Type
{
kAxisAligned
kRectilinear
kGeneral
kPerspective
kLast
=
kPerspective
}
;
static
const
int
kTypeCount
=
static_cast
<
int
>
(
Type
:
:
kLast
)
+
1
;
GrQuad
(
)
=
default
;
explicit
GrQuad
(
const
SkRect
&
rect
)
:
fX
{
rect
.
fLeft
rect
.
fLeft
rect
.
fRight
rect
.
fRight
}
fY
{
rect
.
fTop
rect
.
fBottom
rect
.
fTop
rect
.
fBottom
}
fW
{
1
.
f
1
.
f
1
.
f
1
.
f
}
fType
(
Type
:
:
kAxisAligned
)
{
}
GrQuad
(
const
skvx
:
:
Vec
<
4
float
>
&
xs
const
skvx
:
:
Vec
<
4
float
>
&
ys
Type
type
)
:
fType
(
type
)
{
SkASSERT
(
type
!
=
Type
:
:
kPerspective
)
;
xs
.
store
(
fX
)
;
ys
.
store
(
fY
)
;
fW
[
0
]
=
fW
[
1
]
=
fW
[
2
]
=
fW
[
3
]
=
1
.
f
;
}
GrQuad
(
const
skvx
:
:
Vec
<
4
float
>
&
xs
const
skvx
:
:
Vec
<
4
float
>
&
ys
const
skvx
:
:
Vec
<
4
float
>
&
ws
Type
type
)
:
fType
(
type
)
{
xs
.
store
(
fX
)
;
ys
.
store
(
fY
)
;
ws
.
store
(
fW
)
;
}
GrQuad
(
const
float
xs
[
4
]
const
float
ys
[
4
]
const
float
ws
[
4
]
Type
type
)
:
fType
(
type
)
{
memcpy
(
fX
xs
4
*
sizeof
(
float
)
)
;
memcpy
(
fY
ys
4
*
sizeof
(
float
)
)
;
memcpy
(
fW
ws
4
*
sizeof
(
float
)
)
;
}
static
GrQuad
MakeFromRect
(
const
SkRect
&
const
SkMatrix
&
)
;
static
GrQuad
MakeFromSkQuad
(
const
SkPoint
pts
[
4
]
const
SkMatrix
&
)
;
GrQuad
&
operator
=
(
const
GrQuad
&
)
=
default
;
SkPoint3
point3
(
int
i
)
const
{
return
{
fX
[
i
]
fY
[
i
]
fW
[
i
]
}
;
}
SkPoint
point
(
int
i
)
const
{
if
(
fType
=
=
Type
:
:
kPerspective
)
{
return
{
fX
[
i
]
/
fW
[
i
]
fY
[
i
]
/
fW
[
i
]
}
;
}
else
{
return
{
fX
[
i
]
fY
[
i
]
}
;
}
}
SkRect
bounds
(
)
const
{
auto
x
=
this
-
>
x4f
(
)
;
auto
y
=
this
-
>
y4f
(
)
;
if
(
fType
=
=
Type
:
:
kPerspective
)
{
auto
iw
=
this
-
>
iw4f
(
)
;
x
*
=
iw
;
y
*
=
iw
;
}
return
{
min
(
x
)
min
(
y
)
max
(
x
)
max
(
y
)
}
;
}
bool
isFinite
(
)
const
{
float
accum
=
0
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
accum
*
=
fX
[
i
]
;
accum
*
=
fY
[
i
]
;
accum
*
=
fW
[
i
]
;
}
SkASSERT
(
0
=
=
accum
|
|
SkScalarIsNaN
(
accum
)
)
;
return
!
SkScalarIsNaN
(
accum
)
;
}
float
x
(
int
i
)
const
{
return
fX
[
i
]
;
}
float
y
(
int
i
)
const
{
return
fY
[
i
]
;
}
float
w
(
int
i
)
const
{
return
fW
[
i
]
;
}
float
iw
(
int
i
)
const
{
return
sk_ieee_float_divide
(
1
.
f
fW
[
i
]
)
;
}
skvx
:
:
Vec
<
4
float
>
x4f
(
)
const
{
return
skvx
:
:
Vec
<
4
float
>
:
:
Load
(
fX
)
;
}
skvx
:
:
Vec
<
4
float
>
y4f
(
)
const
{
return
skvx
:
:
Vec
<
4
float
>
:
:
Load
(
fY
)
;
}
skvx
:
:
Vec
<
4
float
>
w4f
(
)
const
{
return
skvx
:
:
Vec
<
4
float
>
:
:
Load
(
fW
)
;
}
skvx
:
:
Vec
<
4
float
>
iw4f
(
)
const
{
return
1
.
f
/
this
-
>
w4f
(
)
;
}
Type
quadType
(
)
const
{
return
fType
;
}
bool
hasPerspective
(
)
const
{
return
fType
=
=
Type
:
:
kPerspective
;
}
bool
aaHasEffectOnRect
(
)
const
;
bool
asRect
(
SkRect
*
rect
)
const
;
const
float
*
xs
(
)
const
{
return
fX
;
}
float
*
xs
(
)
{
return
fX
;
}
const
float
*
ys
(
)
const
{
return
fY
;
}
float
*
ys
(
)
{
return
fY
;
}
const
float
*
ws
(
)
const
{
return
fW
;
}
float
*
ws
(
)
{
return
fW
;
}
void
setQuadType
(
Type
newType
)
{
fType
=
newType
;
}
private
:
template
<
typename
T
>
friend
class
GrQuadListBase
;
float
fX
[
4
]
;
float
fY
[
4
]
;
float
fW
[
4
]
;
Type
fType
;
}
;
#
endif
