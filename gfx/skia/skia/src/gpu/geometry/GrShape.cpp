#
include
"
src
/
gpu
/
geometry
/
GrShape
.
h
"
#
include
<
utility
>
GrShape
&
GrShape
:
:
operator
=
(
const
GrShape
&
that
)
{
fStyle
=
that
.
fStyle
;
this
-
>
changeType
(
that
.
fType
Type
:
:
kPath
=
=
that
.
fType
?
&
that
.
path
(
)
:
nullptr
)
;
switch
(
fType
)
{
case
Type
:
:
kEmpty
:
break
;
case
Type
:
:
kInvertedEmpty
:
break
;
case
Type
:
:
kRRect
:
fRRectData
=
that
.
fRRectData
;
break
;
case
Type
:
:
kArc
:
fArcData
=
that
.
fArcData
;
break
;
case
Type
:
:
kLine
:
fLineData
=
that
.
fLineData
;
break
;
case
Type
:
:
kPath
:
fPathData
.
fGenID
=
that
.
fPathData
.
fGenID
;
break
;
}
fInheritedKey
.
reset
(
that
.
fInheritedKey
.
count
(
)
)
;
sk_careful_memcpy
(
fInheritedKey
.
get
(
)
that
.
fInheritedKey
.
get
(
)
sizeof
(
uint32_t
)
*
fInheritedKey
.
count
(
)
)
;
if
(
that
.
fInheritedPathForListeners
.
isValid
(
)
)
{
fInheritedPathForListeners
.
set
(
*
that
.
fInheritedPathForListeners
.
get
(
)
)
;
}
else
{
fInheritedPathForListeners
.
reset
(
)
;
}
return
*
this
;
}
static
bool
flip_inversion
(
bool
originalIsInverted
GrShape
:
:
FillInversion
inversion
)
{
switch
(
inversion
)
{
case
GrShape
:
:
FillInversion
:
:
kPreserve
:
return
false
;
case
GrShape
:
:
FillInversion
:
:
kFlip
:
return
true
;
case
GrShape
:
:
FillInversion
:
:
kForceInverted
:
return
!
originalIsInverted
;
case
GrShape
:
:
FillInversion
:
:
kForceNoninverted
:
return
originalIsInverted
;
}
return
false
;
}
static
bool
is_inverted
(
bool
originalIsInverted
GrShape
:
:
FillInversion
inversion
)
{
switch
(
inversion
)
{
case
GrShape
:
:
FillInversion
:
:
kPreserve
:
return
originalIsInverted
;
case
GrShape
:
:
FillInversion
:
:
kFlip
:
return
!
originalIsInverted
;
case
GrShape
:
:
FillInversion
:
:
kForceInverted
:
return
true
;
case
GrShape
:
:
FillInversion
:
:
kForceNoninverted
:
return
false
;
}
return
false
;
}
GrShape
GrShape
:
:
MakeFilled
(
const
GrShape
&
original
FillInversion
inversion
)
{
if
(
original
.
style
(
)
.
isSimpleFill
(
)
&
&
!
flip_inversion
(
original
.
inverseFilled
(
)
inversion
)
)
{
return
original
;
}
GrShape
result
;
if
(
original
.
fInheritedPathForListeners
.
isValid
(
)
)
{
result
.
fInheritedPathForListeners
.
set
(
*
original
.
fInheritedPathForListeners
.
get
(
)
)
;
}
switch
(
original
.
fType
)
{
case
Type
:
:
kRRect
:
result
.
fType
=
original
.
fType
;
result
.
fRRectData
.
fRRect
=
original
.
fRRectData
.
fRRect
;
result
.
fRRectData
.
fDir
=
kDefaultRRectDir
;
result
.
fRRectData
.
fStart
=
kDefaultRRectStart
;
result
.
fRRectData
.
fInverted
=
is_inverted
(
original
.
fRRectData
.
fInverted
inversion
)
;
break
;
case
Type
:
:
kArc
:
result
.
fType
=
original
.
fType
;
result
.
fArcData
.
fOval
=
original
.
fArcData
.
fOval
;
result
.
fArcData
.
fStartAngleDegrees
=
original
.
fArcData
.
fStartAngleDegrees
;
result
.
fArcData
.
fSweepAngleDegrees
=
original
.
fArcData
.
fSweepAngleDegrees
;
result
.
fArcData
.
fUseCenter
=
original
.
fArcData
.
fUseCenter
;
result
.
fArcData
.
fInverted
=
is_inverted
(
original
.
fArcData
.
fInverted
inversion
)
;
break
;
case
Type
:
:
kLine
:
if
(
is_inverted
(
original
.
fLineData
.
fInverted
inversion
)
)
{
result
.
fType
=
Type
:
:
kInvertedEmpty
;
}
else
{
result
.
fType
=
Type
:
:
kEmpty
;
}
break
;
case
Type
:
:
kEmpty
:
result
.
fType
=
is_inverted
(
false
inversion
)
?
Type
:
:
kInvertedEmpty
:
Type
:
:
kEmpty
;
break
;
case
Type
:
:
kInvertedEmpty
:
result
.
fType
=
is_inverted
(
true
inversion
)
?
Type
:
:
kInvertedEmpty
:
Type
:
:
kEmpty
;
break
;
case
Type
:
:
kPath
:
result
.
initType
(
Type
:
:
kPath
&
original
.
fPathData
.
fPath
)
;
result
.
fPathData
.
fGenID
=
original
.
fPathData
.
fGenID
;
if
(
flip_inversion
(
original
.
fPathData
.
fPath
.
isInverseFillType
(
)
inversion
)
)
{
result
.
fPathData
.
fPath
.
toggleInverseFillType
(
)
;
}
if
(
!
original
.
style
(
)
.
isSimpleFill
(
)
)
{
result
.
attemptToSimplifyPath
(
)
;
}
break
;
}
return
result
;
}
SkRect
GrShape
:
:
bounds
(
)
const
{
static
constexpr
SkRect
kInverted
=
SkRect
:
:
MakeLTRB
(
1
1
-
1
-
1
)
;
switch
(
fType
)
{
case
Type
:
:
kEmpty
:
return
kInverted
;
case
Type
:
:
kInvertedEmpty
:
return
kInverted
;
case
Type
:
:
kLine
:
{
SkRect
bounds
;
if
(
fLineData
.
fPts
[
0
]
.
fX
<
fLineData
.
fPts
[
1
]
.
fX
)
{
bounds
.
fLeft
=
fLineData
.
fPts
[
0
]
.
fX
;
bounds
.
fRight
=
fLineData
.
fPts
[
1
]
.
fX
;
}
else
{
bounds
.
fLeft
=
fLineData
.
fPts
[
1
]
.
fX
;
bounds
.
fRight
=
fLineData
.
fPts
[
0
]
.
fX
;
}
if
(
fLineData
.
fPts
[
0
]
.
fY
<
fLineData
.
fPts
[
1
]
.
fY
)
{
bounds
.
fTop
=
fLineData
.
fPts
[
0
]
.
fY
;
bounds
.
fBottom
=
fLineData
.
fPts
[
1
]
.
fY
;
}
else
{
bounds
.
fTop
=
fLineData
.
fPts
[
1
]
.
fY
;
bounds
.
fBottom
=
fLineData
.
fPts
[
0
]
.
fY
;
}
return
bounds
;
}
case
Type
:
:
kRRect
:
return
fRRectData
.
fRRect
.
getBounds
(
)
;
case
Type
:
:
kArc
:
return
fArcData
.
fOval
;
case
Type
:
:
kPath
:
return
this
-
>
path
(
)
.
getBounds
(
)
;
}
SK_ABORT
(
"
Unknown
shape
type
"
)
;
}
SkRect
GrShape
:
:
styledBounds
(
)
const
{
if
(
this
-
>
isEmpty
(
)
&
&
!
fStyle
.
hasNonDashPathEffect
(
)
)
{
return
SkRect
:
:
MakeEmpty
(
)
;
}
SkRect
bounds
;
fStyle
.
adjustBounds
(
&
bounds
this
-
>
bounds
(
)
)
;
return
bounds
;
}
static
int
path_key_from_data_size
(
const
SkPath
&
path
)
{
const
int
verbCnt
=
path
.
countVerbs
(
)
;
if
(
verbCnt
>
GrShape
:
:
kMaxKeyFromDataVerbCnt
)
{
return
-
1
;
}
const
int
pointCnt
=
path
.
countPoints
(
)
;
const
int
conicWeightCnt
=
SkPathPriv
:
:
ConicWeightCnt
(
path
)
;
GR_STATIC_ASSERT
(
sizeof
(
SkPoint
)
=
=
2
*
sizeof
(
uint32_t
)
)
;
GR_STATIC_ASSERT
(
sizeof
(
SkScalar
)
=
=
sizeof
(
uint32_t
)
)
;
return
2
+
(
SkAlign4
(
verbCnt
)
>
>
2
)
+
2
*
pointCnt
+
conicWeightCnt
;
}
static
void
write_path_key_from_data
(
const
SkPath
&
path
uint32_t
*
origKey
)
{
uint32_t
*
key
=
origKey
;
const
int
verbCnt
=
path
.
countVerbs
(
)
;
const
int
pointCnt
=
path
.
countPoints
(
)
;
const
int
conicWeightCnt
=
SkPathPriv
:
:
ConicWeightCnt
(
path
)
;
SkASSERT
(
verbCnt
<
=
GrShape
:
:
kMaxKeyFromDataVerbCnt
)
;
SkASSERT
(
pointCnt
&
&
verbCnt
)
;
*
key
+
+
=
path
.
getFillType
(
)
;
*
key
+
+
=
verbCnt
;
memcpy
(
key
SkPathPriv
:
:
VerbData
(
path
)
verbCnt
*
sizeof
(
uint8_t
)
)
;
int
verbKeySize
=
SkAlign4
(
verbCnt
)
;
uint8_t
*
pad
=
reinterpret_cast
<
uint8_t
*
>
(
key
)
+
verbCnt
;
memset
(
pad
0xDE
verbKeySize
-
verbCnt
)
;
key
+
=
verbKeySize
>
>
2
;
memcpy
(
key
SkPathPriv
:
:
PointData
(
path
)
sizeof
(
SkPoint
)
*
pointCnt
)
;
GR_STATIC_ASSERT
(
sizeof
(
SkPoint
)
=
=
2
*
sizeof
(
uint32_t
)
)
;
key
+
=
2
*
pointCnt
;
sk_careful_memcpy
(
key
SkPathPriv
:
:
ConicWeightData
(
path
)
sizeof
(
SkScalar
)
*
conicWeightCnt
)
;
GR_STATIC_ASSERT
(
sizeof
(
SkScalar
)
=
=
sizeof
(
uint32_t
)
)
;
SkDEBUGCODE
(
key
+
=
conicWeightCnt
)
;
SkASSERT
(
key
-
origKey
=
=
path_key_from_data_size
(
path
)
)
;
}
int
GrShape
:
:
unstyledKeySize
(
)
const
{
if
(
fInheritedKey
.
count
(
)
)
{
return
fInheritedKey
.
count
(
)
;
}
switch
(
fType
)
{
case
Type
:
:
kEmpty
:
return
1
;
case
Type
:
:
kInvertedEmpty
:
return
1
;
case
Type
:
:
kRRect
:
SkASSERT
(
!
fInheritedKey
.
count
(
)
)
;
GR_STATIC_ASSERT
(
0
=
=
SkRRect
:
:
kSizeInMemory
%
sizeof
(
uint32_t
)
)
;
return
SkRRect
:
:
kSizeInMemory
/
sizeof
(
uint32_t
)
+
1
;
case
Type
:
:
kArc
:
SkASSERT
(
!
fInheritedKey
.
count
(
)
)
;
GR_STATIC_ASSERT
(
0
=
=
sizeof
(
fArcData
)
%
sizeof
(
uint32_t
)
)
;
return
sizeof
(
fArcData
)
/
sizeof
(
uint32_t
)
;
case
Type
:
:
kLine
:
GR_STATIC_ASSERT
(
2
*
sizeof
(
uint32_t
)
=
=
sizeof
(
SkPoint
)
)
;
return
5
;
case
Type
:
:
kPath
:
{
if
(
0
=
=
fPathData
.
fGenID
)
{
return
-
1
;
}
int
dataKeySize
=
path_key_from_data_size
(
fPathData
.
fPath
)
;
if
(
dataKeySize
>
=
0
)
{
return
dataKeySize
;
}
return
2
;
}
}
SK_ABORT
(
"
Should
never
get
here
.
"
)
;
}
void
GrShape
:
:
writeUnstyledKey
(
uint32_t
*
key
)
const
{
SkASSERT
(
this
-
>
unstyledKeySize
(
)
)
;
SkDEBUGCODE
(
uint32_t
*
origKey
=
key
;
)
if
(
fInheritedKey
.
count
(
)
)
{
memcpy
(
key
fInheritedKey
.
get
(
)
sizeof
(
uint32_t
)
*
fInheritedKey
.
count
(
)
)
;
SkDEBUGCODE
(
key
+
=
fInheritedKey
.
count
(
)
;
)
}
else
{
switch
(
fType
)
{
case
Type
:
:
kEmpty
:
*
key
+
+
=
1
;
break
;
case
Type
:
:
kInvertedEmpty
:
*
key
+
+
=
2
;
break
;
case
Type
:
:
kRRect
:
fRRectData
.
fRRect
.
writeToMemory
(
key
)
;
key
+
=
SkRRect
:
:
kSizeInMemory
/
sizeof
(
uint32_t
)
;
*
key
=
(
fRRectData
.
fDir
=
=
SkPath
:
:
kCCW_Direction
)
?
(
1
<
<
31
)
:
0
;
*
key
|
=
fRRectData
.
fInverted
?
(
1
<
<
30
)
:
0
;
*
key
+
+
|
=
fRRectData
.
fStart
;
SkASSERT
(
fRRectData
.
fStart
<
8
)
;
break
;
case
Type
:
:
kArc
:
memcpy
(
key
&
fArcData
sizeof
(
fArcData
)
)
;
key
+
=
sizeof
(
fArcData
)
/
sizeof
(
uint32_t
)
;
break
;
case
Type
:
:
kLine
:
memcpy
(
key
fLineData
.
fPts
2
*
sizeof
(
SkPoint
)
)
;
key
+
=
4
;
*
key
+
+
=
fLineData
.
fInverted
?
1
:
0
;
break
;
case
Type
:
:
kPath
:
{
SkASSERT
(
fPathData
.
fGenID
)
;
int
dataKeySize
=
path_key_from_data_size
(
fPathData
.
fPath
)
;
if
(
dataKeySize
>
=
0
)
{
write_path_key_from_data
(
fPathData
.
fPath
key
)
;
return
;
}
*
key
+
+
=
fPathData
.
fGenID
;
*
key
+
+
=
this
-
>
path
(
)
.
getFillType
(
)
;
break
;
}
}
}
SkASSERT
(
key
-
origKey
=
=
this
-
>
unstyledKeySize
(
)
)
;
}
void
GrShape
:
:
setInheritedKey
(
const
GrShape
&
parent
GrStyle
:
:
Apply
apply
SkScalar
scale
)
{
SkASSERT
(
!
fInheritedKey
.
count
(
)
)
;
if
(
Type
:
:
kPath
=
=
fType
)
{
int
parentCnt
=
parent
.
fInheritedKey
.
count
(
)
;
bool
useParentGeoKey
=
!
parentCnt
;
if
(
useParentGeoKey
)
{
parentCnt
=
parent
.
unstyledKeySize
(
)
;
if
(
parentCnt
<
0
)
{
fPathData
.
fGenID
=
0
;
return
;
}
}
uint32_t
styleKeyFlags
=
0
;
if
(
parent
.
knownToBeClosed
(
)
)
{
styleKeyFlags
|
=
GrStyle
:
:
kClosed_KeyFlag
;
}
if
(
parent
.
asLine
(
nullptr
nullptr
)
)
{
styleKeyFlags
|
=
GrStyle
:
:
kNoJoins_KeyFlag
;
}
int
styleCnt
=
GrStyle
:
:
KeySize
(
parent
.
fStyle
apply
styleKeyFlags
)
;
if
(
styleCnt
<
0
)
{
fPathData
.
fGenID
=
0
;
return
;
}
fInheritedKey
.
reset
(
parentCnt
+
styleCnt
)
;
if
(
useParentGeoKey
)
{
parent
.
writeUnstyledKey
(
fInheritedKey
.
get
(
)
)
;
}
else
{
memcpy
(
fInheritedKey
.
get
(
)
parent
.
fInheritedKey
.
get
(
)
parentCnt
*
sizeof
(
uint32_t
)
)
;
}
GrStyle
:
:
WriteKey
(
fInheritedKey
.
get
(
)
+
parentCnt
parent
.
fStyle
apply
scale
styleKeyFlags
)
;
}
}
const
SkPath
*
GrShape
:
:
originalPathForListeners
(
)
const
{
if
(
fInheritedPathForListeners
.
isValid
(
)
)
{
return
fInheritedPathForListeners
.
get
(
)
;
}
else
if
(
Type
:
:
kPath
=
=
fType
&
&
!
fPathData
.
fPath
.
isVolatile
(
)
)
{
return
&
fPathData
.
fPath
;
}
return
nullptr
;
}
void
GrShape
:
:
addGenIDChangeListener
(
sk_sp
<
SkPathRef
:
:
GenIDChangeListener
>
listener
)
const
{
if
(
const
auto
*
lp
=
this
-
>
originalPathForListeners
(
)
)
{
SkPathPriv
:
:
AddGenIDChangeListener
(
*
lp
std
:
:
move
(
listener
)
)
;
}
}
GrShape
GrShape
:
:
MakeArc
(
const
SkRect
&
oval
SkScalar
startAngleDegrees
SkScalar
sweepAngleDegrees
bool
useCenter
const
GrStyle
&
style
)
{
GrShape
result
;
result
.
changeType
(
Type
:
:
kArc
)
;
result
.
fArcData
.
fOval
=
oval
;
result
.
fArcData
.
fStartAngleDegrees
=
startAngleDegrees
;
result
.
fArcData
.
fSweepAngleDegrees
=
sweepAngleDegrees
;
result
.
fArcData
.
fUseCenter
=
useCenter
;
result
.
fArcData
.
fInverted
=
false
;
result
.
fStyle
=
style
;
result
.
attemptToSimplifyArc
(
)
;
return
result
;
}
GrShape
:
:
GrShape
(
const
GrShape
&
that
)
:
fStyle
(
that
.
fStyle
)
{
const
SkPath
*
thatPath
=
Type
:
:
kPath
=
=
that
.
fType
?
&
that
.
fPathData
.
fPath
:
nullptr
;
this
-
>
initType
(
that
.
fType
thatPath
)
;
switch
(
fType
)
{
case
Type
:
:
kEmpty
:
break
;
case
Type
:
:
kInvertedEmpty
:
break
;
case
Type
:
:
kRRect
:
fRRectData
=
that
.
fRRectData
;
break
;
case
Type
:
:
kArc
:
fArcData
=
that
.
fArcData
;
break
;
case
Type
:
:
kLine
:
fLineData
=
that
.
fLineData
;
break
;
case
Type
:
:
kPath
:
fPathData
.
fGenID
=
that
.
fPathData
.
fGenID
;
break
;
}
fInheritedKey
.
reset
(
that
.
fInheritedKey
.
count
(
)
)
;
sk_careful_memcpy
(
fInheritedKey
.
get
(
)
that
.
fInheritedKey
.
get
(
)
sizeof
(
uint32_t
)
*
fInheritedKey
.
count
(
)
)
;
if
(
that
.
fInheritedPathForListeners
.
isValid
(
)
)
{
fInheritedPathForListeners
.
set
(
*
that
.
fInheritedPathForListeners
.
get
(
)
)
;
}
}
GrShape
:
:
GrShape
(
const
GrShape
&
parent
GrStyle
:
:
Apply
apply
SkScalar
scale
)
{
if
(
!
parent
.
style
(
)
.
applies
(
)
|
|
(
GrStyle
:
:
Apply
:
:
kPathEffectOnly
=
=
apply
&
&
!
parent
.
style
(
)
.
pathEffect
(
)
)
)
{
this
-
>
initType
(
Type
:
:
kEmpty
)
;
*
this
=
parent
;
return
;
}
SkPathEffect
*
pe
=
parent
.
fStyle
.
pathEffect
(
)
;
SkTLazy
<
SkPath
>
tmpPath
;
const
GrShape
*
parentForKey
=
&
parent
;
SkTLazy
<
GrShape
>
tmpParent
;
this
-
>
initType
(
Type
:
:
kPath
)
;
fPathData
.
fGenID
=
0
;
if
(
pe
)
{
const
SkPath
*
srcForPathEffect
;
if
(
parent
.
fType
=
=
Type
:
:
kPath
)
{
srcForPathEffect
=
&
parent
.
path
(
)
;
}
else
{
srcForPathEffect
=
tmpPath
.
init
(
)
;
parent
.
asPath
(
tmpPath
.
get
(
)
)
;
}
SkStrokeRec
strokeRec
=
parent
.
fStyle
.
strokeRec
(
)
;
if
(
!
parent
.
fStyle
.
applyPathEffectToPath
(
&
this
-
>
path
(
)
&
strokeRec
*
srcForPathEffect
scale
)
)
{
tmpParent
.
init
(
*
srcForPathEffect
GrStyle
(
strokeRec
nullptr
)
)
;
*
this
=
tmpParent
.
get
(
)
-
>
applyStyle
(
apply
scale
)
;
return
;
}
SkASSERT
(
scale
=
=
strokeRec
.
getResScale
(
)
)
;
if
(
GrStyle
:
:
Apply
:
:
kPathEffectAndStrokeRec
=
=
apply
&
&
strokeRec
.
needToApply
(
)
)
{
tmpParent
.
init
(
this
-
>
path
(
)
GrStyle
(
strokeRec
nullptr
)
)
;
tmpParent
.
get
(
)
-
>
setInheritedKey
(
parent
GrStyle
:
:
Apply
:
:
kPathEffectOnly
scale
)
;
if
(
!
tmpPath
.
isValid
(
)
)
{
tmpPath
.
init
(
)
;
}
tmpParent
.
get
(
)
-
>
asPath
(
tmpPath
.
get
(
)
)
;
SkStrokeRec
:
:
InitStyle
fillOrHairline
;
if
(
tmpParent
.
get
(
)
-
>
style
(
)
.
applies
(
)
)
{
SkAssertResult
(
tmpParent
.
get
(
)
-
>
style
(
)
.
applyToPath
(
&
this
-
>
path
(
)
&
fillOrHairline
*
tmpPath
.
get
(
)
scale
)
)
;
}
else
if
(
tmpParent
.
get
(
)
-
>
style
(
)
.
isSimpleFill
(
)
)
{
fillOrHairline
=
SkStrokeRec
:
:
kFill_InitStyle
;
}
else
{
SkASSERT
(
tmpParent
.
get
(
)
-
>
style
(
)
.
isSimpleHairline
(
)
)
;
fillOrHairline
=
SkStrokeRec
:
:
kHairline_InitStyle
;
}
fStyle
.
resetToInitStyle
(
fillOrHairline
)
;
parentForKey
=
tmpParent
.
get
(
)
;
}
else
{
fStyle
=
GrStyle
(
strokeRec
nullptr
)
;
}
}
else
{
const
SkPath
*
srcForParentStyle
;
if
(
parent
.
fType
=
=
Type
:
:
kPath
)
{
srcForParentStyle
=
&
parent
.
path
(
)
;
}
else
{
srcForParentStyle
=
tmpPath
.
init
(
)
;
parent
.
asPath
(
tmpPath
.
get
(
)
)
;
}
SkStrokeRec
:
:
InitStyle
fillOrHairline
;
SkASSERT
(
parent
.
fStyle
.
applies
(
)
)
;
SkASSERT
(
!
parent
.
fStyle
.
pathEffect
(
)
)
;
SkAssertResult
(
parent
.
fStyle
.
applyToPath
(
&
this
-
>
path
(
)
&
fillOrHairline
*
srcForParentStyle
scale
)
)
;
fStyle
.
resetToInitStyle
(
fillOrHairline
)
;
}
if
(
parent
.
fInheritedPathForListeners
.
isValid
(
)
)
{
fInheritedPathForListeners
.
set
(
*
parent
.
fInheritedPathForListeners
.
get
(
)
)
;
}
else
if
(
Type
:
:
kPath
=
=
parent
.
fType
&
&
!
parent
.
fPathData
.
fPath
.
isVolatile
(
)
)
{
fInheritedPathForListeners
.
set
(
parent
.
fPathData
.
fPath
)
;
}
this
-
>
attemptToSimplifyPath
(
)
;
this
-
>
setInheritedKey
(
*
parentForKey
apply
scale
)
;
}
void
GrShape
:
:
attemptToSimplifyPath
(
)
{
SkRect
rect
;
SkRRect
rrect
;
SkPath
:
:
Direction
rrectDir
;
unsigned
rrectStart
;
bool
inverted
=
this
-
>
path
(
)
.
isInverseFillType
(
)
;
SkPoint
pts
[
2
]
;
if
(
this
-
>
path
(
)
.
isEmpty
(
)
)
{
this
-
>
changeType
(
inverted
&
&
!
this
-
>
style
(
)
.
isDashed
(
)
?
Type
:
:
kInvertedEmpty
:
Type
:
:
kEmpty
)
;
}
else
if
(
this
-
>
path
(
)
.
isLine
(
pts
)
)
{
this
-
>
changeType
(
Type
:
:
kLine
)
;
fLineData
.
fPts
[
0
]
=
pts
[
0
]
;
fLineData
.
fPts
[
1
]
=
pts
[
1
]
;
fLineData
.
fInverted
=
inverted
;
}
else
if
(
SkPathPriv
:
:
IsRRect
(
this
-
>
path
(
)
&
rrect
&
rrectDir
&
rrectStart
)
)
{
this
-
>
changeType
(
Type
:
:
kRRect
)
;
fRRectData
.
fRRect
=
rrect
;
fRRectData
.
fDir
=
rrectDir
;
fRRectData
.
fStart
=
rrectStart
;
fRRectData
.
fInverted
=
inverted
;
SkASSERT
(
!
fRRectData
.
fRRect
.
isEmpty
(
)
)
;
}
else
if
(
SkPathPriv
:
:
IsOval
(
this
-
>
path
(
)
&
rect
&
rrectDir
&
rrectStart
)
)
{
this
-
>
changeType
(
Type
:
:
kRRect
)
;
fRRectData
.
fRRect
.
setOval
(
rect
)
;
fRRectData
.
fDir
=
rrectDir
;
fRRectData
.
fInverted
=
inverted
;
fRRectData
.
fStart
=
2
*
rrectStart
;
}
else
if
(
SkPathPriv
:
:
IsSimpleClosedRect
(
this
-
>
path
(
)
&
rect
&
rrectDir
&
rrectStart
)
)
{
this
-
>
changeType
(
Type
:
:
kRRect
)
;
fRRectData
.
fRRect
.
setRect
(
rect
)
;
fRRectData
.
fInverted
=
inverted
;
fRRectData
.
fDir
=
rrectDir
;
fRRectData
.
fStart
=
2
*
rrectStart
;
}
else
if
(
!
this
-
>
style
(
)
.
hasPathEffect
(
)
)
{
bool
closed
;
if
(
this
-
>
path
(
)
.
isRect
(
&
rect
&
closed
nullptr
)
)
{
if
(
closed
|
|
this
-
>
style
(
)
.
isSimpleFill
(
)
)
{
this
-
>
changeType
(
Type
:
:
kRRect
)
;
fRRectData
.
fRRect
.
setRect
(
rect
)
;
fRRectData
.
fDir
=
kDefaultRRectDir
;
fRRectData
.
fStart
=
kDefaultRRectStart
;
fRRectData
.
fInverted
=
inverted
;
}
}
}
if
(
Type
:
:
kPath
!
=
fType
)
{
fInheritedKey
.
reset
(
0
)
;
fInheritedPathForListeners
.
reset
(
)
;
if
(
Type
:
:
kRRect
=
=
fType
)
{
this
-
>
attemptToSimplifyRRect
(
)
;
}
else
if
(
Type
:
:
kLine
=
=
fType
)
{
this
-
>
attemptToSimplifyLine
(
)
;
}
}
else
{
if
(
fInheritedKey
.
count
(
)
|
|
this
-
>
path
(
)
.
isVolatile
(
)
)
{
fPathData
.
fGenID
=
0
;
}
else
{
fPathData
.
fGenID
=
this
-
>
path
(
)
.
getGenerationID
(
)
;
}
if
(
!
this
-
>
style
(
)
.
hasNonDashPathEffect
(
)
)
{
if
(
this
-
>
style
(
)
.
strokeRec
(
)
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kStroke_Style
|
|
this
-
>
style
(
)
.
strokeRec
(
)
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kHairline_Style
)
{
bool
inverse
=
!
this
-
>
style
(
)
.
isDashed
(
)
&
&
this
-
>
path
(
)
.
isInverseFillType
(
)
;
if
(
inverse
)
{
this
-
>
path
(
)
.
setFillType
(
kDefaultPathInverseFillType
)
;
}
else
{
this
-
>
path
(
)
.
setFillType
(
kDefaultPathFillType
)
;
}
}
else
if
(
this
-
>
path
(
)
.
isConvex
(
)
)
{
if
(
this
-
>
path
(
)
.
isInverseFillType
(
)
)
{
this
-
>
path
(
)
.
setFillType
(
kDefaultPathInverseFillType
)
;
}
else
{
this
-
>
path
(
)
.
setFillType
(
kDefaultPathFillType
)
;
}
}
}
}
}
void
GrShape
:
:
attemptToSimplifyRRect
(
)
{
SkASSERT
(
Type
:
:
kRRect
=
=
fType
)
;
SkASSERT
(
!
fInheritedKey
.
count
(
)
)
;
if
(
fRRectData
.
fRRect
.
isEmpty
(
)
)
{
if
(
fStyle
.
isSimpleFill
(
)
)
{
fType
=
fRRectData
.
fInverted
?
Type
:
:
kInvertedEmpty
:
Type
:
:
kEmpty
;
fStyle
=
GrStyle
:
:
SimpleFill
(
)
;
return
;
}
if
(
fStyle
.
isDashed
(
)
&
&
!
fRRectData
.
fRRect
.
width
(
)
&
&
!
fRRectData
.
fRRect
.
height
(
)
)
{
fType
=
Type
:
:
kEmpty
;
fStyle
=
GrStyle
:
:
SimpleFill
(
)
;
return
;
}
}
if
(
!
this
-
>
style
(
)
.
hasPathEffect
(
)
)
{
fRRectData
.
fDir
=
kDefaultRRectDir
;
fRRectData
.
fStart
=
kDefaultRRectStart
;
}
else
if
(
fStyle
.
isDashed
(
)
)
{
fRRectData
.
fInverted
=
false
;
}
if
(
!
fStyle
.
hasPathEffect
(
)
&
&
fStyle
.
strokeRec
(
)
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kStrokeAndFill_Style
&
&
fStyle
.
strokeRec
(
)
.
getJoin
(
)
=
=
SkPaint
:
:
kMiter_Join
&
&
fStyle
.
strokeRec
(
)
.
getMiter
(
)
>
=
SK_ScalarSqrt2
&
&
fRRectData
.
fRRect
.
isRect
(
)
)
{
SkScalar
r
=
fStyle
.
strokeRec
(
)
.
getWidth
(
)
/
2
;
fRRectData
.
fRRect
=
SkRRect
:
:
MakeRect
(
fRRectData
.
fRRect
.
rect
(
)
.
makeOutset
(
r
r
)
)
;
fStyle
=
GrStyle
:
:
SimpleFill
(
)
;
}
}
void
GrShape
:
:
attemptToSimplifyLine
(
)
{
SkASSERT
(
Type
:
:
kLine
=
=
fType
)
;
SkASSERT
(
!
fInheritedKey
.
count
(
)
)
;
if
(
fStyle
.
isDashed
(
)
)
{
bool
allOffsZero
=
true
;
for
(
int
i
=
1
;
i
<
fStyle
.
dashIntervalCnt
(
)
&
&
allOffsZero
;
i
+
=
2
)
{
allOffsZero
=
!
fStyle
.
dashIntervals
(
)
[
i
]
;
}
if
(
allOffsZero
&
&
this
-
>
attemptToSimplifyStrokedLineToRRect
(
)
)
{
return
;
}
fLineData
.
fInverted
=
false
;
return
;
}
else
if
(
fStyle
.
hasPathEffect
(
)
)
{
return
;
}
if
(
fStyle
.
strokeRec
(
)
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kStrokeAndFill_Style
)
{
SkStrokeRec
rec
=
fStyle
.
strokeRec
(
)
;
rec
.
setStrokeStyle
(
fStyle
.
strokeRec
(
)
.
getWidth
(
)
false
)
;
fStyle
=
GrStyle
(
rec
nullptr
)
;
}
if
(
fStyle
.
isSimpleFill
(
)
)
{
this
-
>
changeType
(
fLineData
.
fInverted
?
Type
:
:
kInvertedEmpty
:
Type
:
:
kEmpty
)
;
return
;
}
if
(
fStyle
.
strokeRec
(
)
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kStroke_Style
&
&
this
-
>
attemptToSimplifyStrokedLineToRRect
(
)
)
{
return
;
}
SkPoint
*
pts
=
fLineData
.
fPts
;
if
(
pts
[
1
]
.
fY
<
pts
[
0
]
.
fY
|
|
(
pts
[
1
]
.
fY
=
=
pts
[
0
]
.
fY
&
&
pts
[
1
]
.
fX
<
pts
[
0
]
.
fX
)
)
{
using
std
:
:
swap
;
swap
(
pts
[
0
]
pts
[
1
]
)
;
}
}
void
GrShape
:
:
attemptToSimplifyArc
(
)
{
SkASSERT
(
fType
=
=
Type
:
:
kArc
)
;
SkASSERT
(
!
fArcData
.
fInverted
)
;
if
(
fArcData
.
fOval
.
isEmpty
(
)
|
|
!
fArcData
.
fSweepAngleDegrees
)
{
this
-
>
changeType
(
Type
:
:
kEmpty
)
;
return
;
}
if
(
fStyle
.
isSimpleFill
(
)
|
|
(
!
fStyle
.
pathEffect
(
)
&
&
!
fArcData
.
fUseCenter
&
&
fStyle
.
strokeRec
(
)
.
getCap
(
)
=
=
SkPaint
:
:
kButt_Cap
)
)
{
if
(
fArcData
.
fSweepAngleDegrees
>
=
360
.
f
|
|
fArcData
.
fSweepAngleDegrees
<
=
-
360
.
f
)
{
auto
oval
=
fArcData
.
fOval
;
this
-
>
changeType
(
Type
:
:
kRRect
)
;
this
-
>
fRRectData
.
fRRect
.
setOval
(
oval
)
;
this
-
>
fRRectData
.
fDir
=
kDefaultRRectDir
;
this
-
>
fRRectData
.
fStart
=
kDefaultRRectStart
;
this
-
>
fRRectData
.
fInverted
=
false
;
return
;
}
}
if
(
!
fStyle
.
pathEffect
(
)
)
{
if
(
fArcData
.
fSweepAngleDegrees
<
0
)
{
fArcData
.
fStartAngleDegrees
=
fArcData
.
fStartAngleDegrees
+
fArcData
.
fSweepAngleDegrees
;
fArcData
.
fSweepAngleDegrees
=
-
fArcData
.
fSweepAngleDegrees
;
}
}
if
(
this
-
>
fArcData
.
fStartAngleDegrees
<
0
|
|
this
-
>
fArcData
.
fStartAngleDegrees
>
=
360
.
f
)
{
this
-
>
fArcData
.
fStartAngleDegrees
=
SkScalarMod
(
this
-
>
fArcData
.
fStartAngleDegrees
360
.
f
)
;
}
}
bool
GrShape
:
:
attemptToSimplifyStrokedLineToRRect
(
)
{
SkASSERT
(
Type
:
:
kLine
=
=
fType
)
;
SkASSERT
(
fStyle
.
strokeRec
(
)
.
getStyle
(
)
=
=
SkStrokeRec
:
:
kStroke_Style
)
;
SkRect
rect
;
SkVector
outset
;
if
(
fLineData
.
fPts
[
0
]
.
fY
=
=
fLineData
.
fPts
[
1
]
.
fY
)
{
rect
.
fLeft
=
SkTMin
(
fLineData
.
fPts
[
0
]
.
fX
fLineData
.
fPts
[
1
]
.
fX
)
;
rect
.
fRight
=
SkTMax
(
fLineData
.
fPts
[
0
]
.
fX
fLineData
.
fPts
[
1
]
.
fX
)
;
rect
.
fTop
=
rect
.
fBottom
=
fLineData
.
fPts
[
0
]
.
fY
;
outset
.
fY
=
fStyle
.
strokeRec
(
)
.
getWidth
(
)
/
2
.
f
;
outset
.
fX
=
SkPaint
:
:
kButt_Cap
=
=
fStyle
.
strokeRec
(
)
.
getCap
(
)
?
0
.
f
:
outset
.
fY
;
}
else
if
(
fLineData
.
fPts
[
0
]
.
fX
=
=
fLineData
.
fPts
[
1
]
.
fX
)
{
rect
.
fTop
=
SkTMin
(
fLineData
.
fPts
[
0
]
.
fY
fLineData
.
fPts
[
1
]
.
fY
)
;
rect
.
fBottom
=
SkTMax
(
fLineData
.
fPts
[
0
]
.
fY
fLineData
.
fPts
[
1
]
.
fY
)
;
rect
.
fLeft
=
rect
.
fRight
=
fLineData
.
fPts
[
0
]
.
fX
;
outset
.
fX
=
fStyle
.
strokeRec
(
)
.
getWidth
(
)
/
2
.
f
;
outset
.
fY
=
SkPaint
:
:
kButt_Cap
=
=
fStyle
.
strokeRec
(
)
.
getCap
(
)
?
0
.
f
:
outset
.
fX
;
}
else
{
return
false
;
}
rect
.
outset
(
outset
.
fX
outset
.
fY
)
;
if
(
rect
.
isEmpty
(
)
)
{
this
-
>
changeType
(
Type
:
:
kEmpty
)
;
fStyle
=
GrStyle
:
:
SimpleFill
(
)
;
return
true
;
}
SkRRect
rrect
;
if
(
fStyle
.
strokeRec
(
)
.
getCap
(
)
=
=
SkPaint
:
:
kRound_Cap
)
{
SkASSERT
(
outset
.
fX
=
=
outset
.
fY
)
;
rrect
=
SkRRect
:
:
MakeRectXY
(
rect
outset
.
fX
outset
.
fY
)
;
}
else
{
rrect
=
SkRRect
:
:
MakeRect
(
rect
)
;
}
bool
inverted
=
fLineData
.
fInverted
&
&
!
fStyle
.
hasPathEffect
(
)
;
this
-
>
changeType
(
Type
:
:
kRRect
)
;
fRRectData
.
fRRect
=
rrect
;
fRRectData
.
fInverted
=
inverted
;
fRRectData
.
fDir
=
kDefaultRRectDir
;
fRRectData
.
fStart
=
kDefaultRRectStart
;
fStyle
=
GrStyle
:
:
SimpleFill
(
)
;
return
true
;
}
