#
ifndef
GrRect_DEFINED
#
define
GrRect_DEFINED
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
SkTo
.
h
"
struct
GrIRect16
{
int16_t
fLeft
fTop
fRight
fBottom
;
static
GrIRect16
SK_WARN_UNUSED_RESULT
MakeEmpty
(
)
{
GrIRect16
r
;
r
.
setEmpty
(
)
;
return
r
;
}
static
GrIRect16
SK_WARN_UNUSED_RESULT
MakeWH
(
int16_t
w
int16_t
h
)
{
GrIRect16
r
;
r
.
set
(
0
0
w
h
)
;
return
r
;
}
static
GrIRect16
SK_WARN_UNUSED_RESULT
MakeXYWH
(
int16_t
x
int16_t
y
int16_t
w
int16_t
h
)
{
GrIRect16
r
;
r
.
set
(
x
y
x
+
w
y
+
h
)
;
return
r
;
}
static
GrIRect16
SK_WARN_UNUSED_RESULT
Make
(
const
SkIRect
&
ir
)
{
GrIRect16
r
;
r
.
set
(
ir
)
;
return
r
;
}
int
width
(
)
const
{
return
fRight
-
fLeft
;
}
int
height
(
)
const
{
return
fBottom
-
fTop
;
}
int
area
(
)
const
{
return
this
-
>
width
(
)
*
this
-
>
height
(
)
;
}
bool
isEmpty
(
)
const
{
return
fLeft
>
=
fRight
|
|
fTop
>
=
fBottom
;
}
void
setEmpty
(
)
{
memset
(
this
0
sizeof
(
*
this
)
)
;
}
void
set
(
int16_t
left
int16_t
top
int16_t
right
int16_t
bottom
)
{
fLeft
=
left
;
fTop
=
top
;
fRight
=
right
;
fBottom
=
bottom
;
}
void
set
(
const
SkIRect
&
r
)
{
fLeft
=
SkToS16
(
r
.
fLeft
)
;
fTop
=
SkToS16
(
r
.
fTop
)
;
fRight
=
SkToS16
(
r
.
fRight
)
;
fBottom
=
SkToS16
(
r
.
fBottom
)
;
}
}
;
static
inline
bool
GrRectsOverlap
(
const
SkRect
&
a
const
SkRect
&
b
)
{
SkASSERT
(
!
a
.
isFinite
(
)
|
|
(
a
.
fLeft
<
=
a
.
fRight
&
&
a
.
fTop
<
=
a
.
fBottom
)
)
;
SkASSERT
(
!
b
.
isFinite
(
)
|
|
(
b
.
fLeft
<
=
b
.
fRight
&
&
b
.
fTop
<
=
b
.
fBottom
)
)
;
return
a
.
fRight
>
b
.
fLeft
&
&
a
.
fBottom
>
b
.
fTop
&
&
b
.
fRight
>
a
.
fLeft
&
&
b
.
fBottom
>
a
.
fTop
;
}
static
inline
bool
GrRectsTouchOrOverlap
(
const
SkRect
&
a
const
SkRect
&
b
)
{
SkASSERT
(
!
a
.
isFinite
(
)
|
|
(
a
.
fLeft
<
=
a
.
fRight
&
&
a
.
fTop
<
=
a
.
fBottom
)
)
;
SkASSERT
(
!
b
.
isFinite
(
)
|
|
(
b
.
fLeft
<
=
b
.
fRight
&
&
b
.
fTop
<
=
b
.
fBottom
)
)
;
return
a
.
fRight
>
=
b
.
fLeft
&
&
a
.
fBottom
>
=
b
.
fTop
&
&
b
.
fRight
>
=
a
.
fLeft
&
&
b
.
fBottom
>
=
a
.
fTop
;
}
static
inline
void
GrMapRectPoints
(
const
SkRect
&
inRect
const
SkRect
&
outRect
const
SkPoint
inPts
[
]
SkPoint
outPts
[
]
int
ptCount
)
{
SkMatrix
rectTransform
=
SkMatrix
:
:
MakeRectToRect
(
inRect
outRect
SkMatrix
:
:
kFill_ScaleToFit
)
;
rectTransform
.
mapPoints
(
outPts
inPts
ptCount
)
;
}
static
inline
bool
GrClipSrcRectAndDstPoint
(
const
SkISize
&
dstSize
const
SkISize
&
srcSize
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
SkIRect
*
clippedSrcRect
SkIPoint
*
clippedDstPoint
)
{
*
clippedSrcRect
=
srcRect
;
*
clippedDstPoint
=
dstPoint
;
if
(
clippedSrcRect
-
>
fLeft
<
0
)
{
clippedDstPoint
-
>
fX
-
=
clippedSrcRect
-
>
fLeft
;
clippedSrcRect
-
>
fLeft
=
0
;
}
if
(
clippedDstPoint
-
>
fX
<
0
)
{
clippedSrcRect
-
>
fLeft
-
=
clippedDstPoint
-
>
fX
;
clippedDstPoint
-
>
fX
=
0
;
}
if
(
clippedSrcRect
-
>
fTop
<
0
)
{
clippedDstPoint
-
>
fY
-
=
clippedSrcRect
-
>
fTop
;
clippedSrcRect
-
>
fTop
=
0
;
}
if
(
clippedDstPoint
-
>
fY
<
0
)
{
clippedSrcRect
-
>
fTop
-
=
clippedDstPoint
-
>
fY
;
clippedDstPoint
-
>
fY
=
0
;
}
if
(
clippedSrcRect
-
>
fRight
>
srcSize
.
width
(
)
)
{
clippedSrcRect
-
>
fRight
=
srcSize
.
width
(
)
;
}
if
(
clippedDstPoint
-
>
fX
+
clippedSrcRect
-
>
width
(
)
>
dstSize
.
width
(
)
)
{
clippedSrcRect
-
>
fRight
=
clippedSrcRect
-
>
fLeft
+
dstSize
.
width
(
)
-
clippedDstPoint
-
>
fX
;
}
if
(
clippedSrcRect
-
>
fBottom
>
srcSize
.
height
(
)
)
{
clippedSrcRect
-
>
fBottom
=
srcSize
.
height
(
)
;
}
if
(
clippedDstPoint
-
>
fY
+
clippedSrcRect
-
>
height
(
)
>
dstSize
.
height
(
)
)
{
clippedSrcRect
-
>
fBottom
=
clippedSrcRect
-
>
fTop
+
dstSize
.
height
(
)
-
clippedDstPoint
-
>
fY
;
}
return
!
clippedSrcRect
-
>
isEmpty
(
)
;
}
#
endif
