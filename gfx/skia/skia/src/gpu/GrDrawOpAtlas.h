#
ifndef
GrDrawOpAtlas_DEFINED
#
define
GrDrawOpAtlas_DEFINED
#
include
<
cmath
>
#
include
"
SkGlyphRun
.
h
"
#
include
"
SkIPoint16
.
h
"
#
include
"
SkSize
.
h
"
#
include
"
SkTDArray
.
h
"
#
include
"
SkTInternalLList
.
h
"
#
include
"
ops
/
GrDrawOp
.
h
"
class
GrOnFlushResourceProvider
;
class
GrRectanizer
;
class
GrDrawOpAtlasConfig
{
public
:
GrDrawOpAtlasConfig
(
int
maxDimension
size_t
maxBytes
)
:
fPlotsPerLongDimension
{
PlotsPerLongDimensionForARGB
(
maxDimension
maxBytes
)
}
{
SkASSERT
(
kPlotSize
>
=
SkGlyphCacheCommon
:
:
kSkSideTooBigForAtlas
)
;
}
GrDrawOpAtlasConfig
(
)
:
fPlotsPerLongDimension
{
1
}
{
SkASSERT
(
kPlotSize
>
=
SkGlyphCacheCommon
:
:
kSkSideTooBigForAtlas
)
;
}
SkISize
numPlots
(
GrMaskFormat
type
)
const
{
switch
(
type
)
{
case
kA8_GrMaskFormat
:
return
{
fPlotsPerLongDimension
fPlotsPerLongDimension
}
;
case
kA565_GrMaskFormat
:
case
kARGB_GrMaskFormat
:
{
int
plotsPerWidth
=
std
:
:
max
(
1
fPlotsPerLongDimension
/
2
)
;
return
{
plotsPerWidth
fPlotsPerLongDimension
}
;
}
}
return
{
1
1
}
;
}
SkISize
atlasDimensions
(
GrMaskFormat
type
)
const
{
SkISize
plots
=
this
-
>
numPlots
(
type
)
;
return
{
plots
.
width
(
)
*
kPlotSize
plots
.
height
(
)
*
kPlotSize
}
;
}
private
:
static
int
PlotsPerLongDimensionForARGB
(
size_t
maxDimension
size_t
maxBytes
)
{
double
fitsHeight
=
std
:
:
sqrt
(
2
.
0
*
maxBytes
/
GrMaskFormatBytesPerPixel
(
kARGB_GrMaskFormat
)
)
;
maxDimension
=
std
:
:
min
(
maxDimension
SkTo
<
size_t
>
(
2048
)
)
;
double
height
=
std
:
:
max
(
std
:
:
min
(
fitsHeight
(
double
)
maxDimension
)
(
double
)
kPlotSize
)
;
double
alignedHeight
=
std
:
:
exp2
(
std
:
:
floor
(
std
:
:
log2
(
height
)
)
)
;
return
(
int
)
alignedHeight
/
kPlotSize
;
}
static
constexpr
int
kPlotSize
=
512
;
const
int
fPlotsPerLongDimension
;
}
;
class
GrDrawOpAtlas
{
private
:
static
constexpr
auto
kMaxMultitexturePages
=
4
;
public
:
enum
class
AllowMultitexturing
:
bool
{
kNo
kYes
}
;
typedef
uint64_t
AtlasID
;
static
const
uint32_t
kInvalidAtlasID
=
0
;
static
const
uint64_t
kInvalidAtlasGeneration
=
0
;
typedef
void
(
*
EvictionFunc
)
(
GrDrawOpAtlas
:
:
AtlasID
void
*
)
;
static
std
:
:
unique_ptr
<
GrDrawOpAtlas
>
Make
(
GrProxyProvider
*
GrPixelConfig
int
width
int
height
int
numPlotsX
int
numPlotsY
AllowMultitexturing
allowMultitexturing
GrDrawOpAtlas
:
:
EvictionFunc
func
void
*
data
)
;
enum
class
ErrorCode
{
kError
kSucceeded
kTryAgain
}
;
ErrorCode
addToAtlas
(
GrResourceProvider
*
AtlasID
*
GrDeferredUploadTarget
*
int
width
int
height
const
void
*
image
SkIPoint16
*
loc
)
;
const
sk_sp
<
GrTextureProxy
>
*
getProxies
(
)
const
{
return
fProxies
;
}
uint64_t
atlasGeneration
(
)
const
{
return
fAtlasGeneration
;
}
inline
bool
hasID
(
AtlasID
id
)
{
if
(
kInvalidAtlasID
=
=
id
)
{
return
false
;
}
uint32_t
plot
=
GetPlotIndexFromID
(
id
)
;
SkASSERT
(
plot
<
fNumPlots
)
;
uint32_t
page
=
GetPageIndexFromID
(
id
)
;
SkASSERT
(
page
<
fNumActivePages
)
;
return
fPages
[
page
]
.
fPlotArray
[
plot
]
-
>
genID
(
)
=
=
GetGenerationFromID
(
id
)
;
}
inline
void
setLastUseToken
(
AtlasID
id
GrDeferredUploadToken
token
)
{
SkASSERT
(
this
-
>
hasID
(
id
)
)
;
uint32_t
plotIdx
=
GetPlotIndexFromID
(
id
)
;
SkASSERT
(
plotIdx
<
fNumPlots
)
;
uint32_t
pageIdx
=
GetPageIndexFromID
(
id
)
;
SkASSERT
(
pageIdx
<
fNumActivePages
)
;
Plot
*
plot
=
fPages
[
pageIdx
]
.
fPlotArray
[
plotIdx
]
.
get
(
)
;
this
-
>
makeMRU
(
plot
pageIdx
)
;
plot
-
>
setLastUseToken
(
token
)
;
}
inline
void
registerEvictionCallback
(
EvictionFunc
func
void
*
userData
)
{
EvictionData
*
data
=
fEvictionCallbacks
.
append
(
)
;
data
-
>
fFunc
=
func
;
data
-
>
fData
=
userData
;
}
uint32_t
numActivePages
(
)
{
return
fNumActivePages
;
}
class
BulkUseTokenUpdater
{
public
:
BulkUseTokenUpdater
(
)
{
memset
(
fPlotAlreadyUpdated
0
sizeof
(
fPlotAlreadyUpdated
)
)
;
}
BulkUseTokenUpdater
(
const
BulkUseTokenUpdater
&
that
)
:
fPlotsToUpdate
(
that
.
fPlotsToUpdate
)
{
memcpy
(
fPlotAlreadyUpdated
that
.
fPlotAlreadyUpdated
sizeof
(
fPlotAlreadyUpdated
)
)
;
}
void
add
(
AtlasID
id
)
{
int
index
=
GrDrawOpAtlas
:
:
GetPlotIndexFromID
(
id
)
;
int
pageIdx
=
GrDrawOpAtlas
:
:
GetPageIndexFromID
(
id
)
;
if
(
!
this
-
>
find
(
pageIdx
index
)
)
{
this
-
>
set
(
pageIdx
index
)
;
}
}
void
reset
(
)
{
fPlotsToUpdate
.
reset
(
)
;
memset
(
fPlotAlreadyUpdated
0
sizeof
(
fPlotAlreadyUpdated
)
)
;
}
struct
PlotData
{
PlotData
(
int
pageIdx
int
plotIdx
)
:
fPageIndex
(
pageIdx
)
fPlotIndex
(
plotIdx
)
{
}
uint32_t
fPageIndex
;
uint32_t
fPlotIndex
;
}
;
private
:
bool
find
(
int
pageIdx
int
index
)
const
{
SkASSERT
(
index
<
kMaxPlots
)
;
return
(
fPlotAlreadyUpdated
[
pageIdx
]
>
>
index
)
&
1
;
}
void
set
(
int
pageIdx
int
index
)
{
SkASSERT
(
!
this
-
>
find
(
pageIdx
index
)
)
;
fPlotAlreadyUpdated
[
pageIdx
]
|
=
(
1
<
<
index
)
;
fPlotsToUpdate
.
push_back
(
PlotData
(
pageIdx
index
)
)
;
}
static
constexpr
int
kMinItems
=
4
;
static
constexpr
int
kMaxPlots
=
32
;
SkSTArray
<
kMinItems
PlotData
true
>
fPlotsToUpdate
;
uint32_t
fPlotAlreadyUpdated
[
kMaxMultitexturePages
]
;
friend
class
GrDrawOpAtlas
;
}
;
void
setLastUseTokenBulk
(
const
BulkUseTokenUpdater
&
updater
GrDeferredUploadToken
token
)
{
int
count
=
updater
.
fPlotsToUpdate
.
count
(
)
;
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
const
BulkUseTokenUpdater
:
:
PlotData
&
pd
=
updater
.
fPlotsToUpdate
[
i
]
;
if
(
pd
.
fPageIndex
<
fNumActivePages
)
{
Plot
*
plot
=
fPages
[
pd
.
fPageIndex
]
.
fPlotArray
[
pd
.
fPlotIndex
]
.
get
(
)
;
this
-
>
makeMRU
(
plot
pd
.
fPageIndex
)
;
plot
-
>
setLastUseToken
(
token
)
;
}
}
}
void
compact
(
GrDeferredUploadToken
startTokenForNextFlush
)
;
static
uint32_t
GetPageIndexFromID
(
AtlasID
id
)
{
return
id
&
0xff
;
}
void
instantiate
(
GrOnFlushResourceProvider
*
)
;
uint32_t
maxPages
(
)
const
{
return
fMaxPages
;
}
int
numAllocated_TestingOnly
(
)
const
;
void
setMaxPages_TestingOnly
(
uint32_t
maxPages
)
;
private
:
GrDrawOpAtlas
(
GrProxyProvider
*
GrPixelConfig
int
width
int
height
int
numPlotsX
int
numPlotsY
AllowMultitexturing
allowMultitexturing
)
;
class
Plot
:
public
SkRefCnt
{
SK_DECLARE_INTERNAL_LLIST_INTERFACE
(
Plot
)
;
public
:
uint32_t
index
(
)
const
{
return
fPlotIndex
;
}
uint64_t
genID
(
)
const
{
return
fGenID
;
}
GrDrawOpAtlas
:
:
AtlasID
id
(
)
const
{
SkASSERT
(
GrDrawOpAtlas
:
:
kInvalidAtlasID
!
=
fID
)
;
return
fID
;
}
SkDEBUGCODE
(
size_t
bpp
(
)
const
{
return
fBytesPerPixel
;
}
)
bool
addSubImage
(
int
width
int
height
const
void
*
image
SkIPoint16
*
loc
)
;
GrDeferredUploadToken
lastUploadToken
(
)
const
{
return
fLastUpload
;
}
GrDeferredUploadToken
lastUseToken
(
)
const
{
return
fLastUse
;
}
void
setLastUploadToken
(
GrDeferredUploadToken
token
)
{
fLastUpload
=
token
;
}
void
setLastUseToken
(
GrDeferredUploadToken
token
)
{
fLastUse
=
token
;
}
void
uploadToTexture
(
GrDeferredTextureUploadWritePixelsFn
&
GrTextureProxy
*
)
;
void
resetRects
(
)
;
int
flushesSinceLastUsed
(
)
{
return
fFlushesSinceLastUse
;
}
void
resetFlushesSinceLastUsed
(
)
{
fFlushesSinceLastUse
=
0
;
}
void
incFlushesSinceLastUsed
(
)
{
fFlushesSinceLastUse
+
+
;
}
private
:
Plot
(
int
pageIndex
int
plotIndex
uint64_t
genID
int
offX
int
offY
int
width
int
height
GrPixelConfig
config
)
;
~
Plot
(
)
override
;
Plot
*
clone
(
)
const
{
return
new
Plot
(
fPageIndex
fPlotIndex
fGenID
+
1
fX
fY
fWidth
fHeight
fConfig
)
;
}
static
GrDrawOpAtlas
:
:
AtlasID
CreateId
(
uint32_t
pageIdx
uint32_t
plotIdx
uint64_t
generation
)
{
SkASSERT
(
pageIdx
<
(
1
<
<
8
)
)
;
SkASSERT
(
pageIdx
<
kMaxMultitexturePages
)
;
SkASSERT
(
plotIdx
<
(
1
<
<
8
)
)
;
SkASSERT
(
generation
<
(
(
uint64_t
)
1
<
<
48
)
)
;
return
generation
<
<
16
|
plotIdx
<
<
8
|
pageIdx
;
}
GrDeferredUploadToken
fLastUpload
;
GrDeferredUploadToken
fLastUse
;
int
fFlushesSinceLastUse
;
struct
{
const
uint32_t
fPageIndex
:
16
;
const
uint32_t
fPlotIndex
:
16
;
}
;
uint64_t
fGenID
;
GrDrawOpAtlas
:
:
AtlasID
fID
;
unsigned
char
*
fData
;
const
int
fWidth
;
const
int
fHeight
;
const
int
fX
;
const
int
fY
;
GrRectanizer
*
fRects
;
const
SkIPoint16
fOffset
;
const
GrPixelConfig
fConfig
;
const
size_t
fBytesPerPixel
;
SkIRect
fDirtyRect
;
SkDEBUGCODE
(
bool
fDirty
)
;
friend
class
GrDrawOpAtlas
;
typedef
SkRefCnt
INHERITED
;
}
;
typedef
SkTInternalLList
<
Plot
>
PlotList
;
static
uint32_t
GetPlotIndexFromID
(
AtlasID
id
)
{
return
(
id
>
>
8
)
&
0xff
;
}
static
uint64_t
GetGenerationFromID
(
AtlasID
id
)
{
return
(
id
>
>
16
)
&
0xffffffffffff
;
}
inline
bool
updatePlot
(
GrDeferredUploadTarget
*
AtlasID
*
Plot
*
)
;
inline
void
makeMRU
(
Plot
*
plot
int
pageIdx
)
{
if
(
fPages
[
pageIdx
]
.
fPlotList
.
head
(
)
=
=
plot
)
{
return
;
}
fPages
[
pageIdx
]
.
fPlotList
.
remove
(
plot
)
;
fPages
[
pageIdx
]
.
fPlotList
.
addToHead
(
plot
)
;
}
bool
uploadToPage
(
unsigned
int
pageIdx
AtlasID
*
id
GrDeferredUploadTarget
*
target
int
width
int
height
const
void
*
image
SkIPoint16
*
loc
)
;
bool
createPages
(
GrProxyProvider
*
)
;
bool
activateNewPage
(
GrResourceProvider
*
)
;
void
deactivateLastPage
(
)
;
void
processEviction
(
AtlasID
)
;
inline
void
processEvictionAndResetRects
(
Plot
*
plot
)
{
this
-
>
processEviction
(
plot
-
>
id
(
)
)
;
plot
-
>
resetRects
(
)
;
}
GrPixelConfig
fPixelConfig
;
int
fTextureWidth
;
int
fTextureHeight
;
int
fPlotWidth
;
int
fPlotHeight
;
unsigned
int
fNumPlots
;
uint64_t
fAtlasGeneration
;
GrDeferredUploadToken
fPrevFlushToken
;
struct
EvictionData
{
EvictionFunc
fFunc
;
void
*
fData
;
}
;
SkTDArray
<
EvictionData
>
fEvictionCallbacks
;
struct
Page
{
std
:
:
unique_ptr
<
sk_sp
<
Plot
>
[
]
>
fPlotArray
;
PlotList
fPlotList
;
}
;
sk_sp
<
GrTextureProxy
>
fProxies
[
kMaxMultitexturePages
]
;
Page
fPages
[
kMaxMultitexturePages
]
;
uint32_t
fMaxPages
;
uint32_t
fNumActivePages
;
}
;
#
endif
