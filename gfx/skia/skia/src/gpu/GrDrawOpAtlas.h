#
ifndef
GrDrawOpAtlas_DEFINED
#
define
GrDrawOpAtlas_DEFINED
#
include
"
SkPoint
.
h
"
#
include
"
SkTDArray
.
h
"
#
include
"
SkTInternalLList
.
h
"
#
include
"
ops
/
GrDrawOp
.
h
"
class
GrRectanizer
;
struct
GrDrawOpAtlasConfig
{
int
numPlotsX
(
)
const
{
return
fWidth
/
fPlotWidth
;
}
int
numPlotsY
(
)
const
{
return
fHeight
/
fPlotWidth
;
}
int
fWidth
;
int
fHeight
;
int
fLog2Width
;
int
fLog2Height
;
int
fPlotWidth
;
int
fPlotHeight
;
}
;
class
GrDrawOpAtlas
{
public
:
typedef
uint64_t
AtlasID
;
static
const
uint32_t
kInvalidAtlasID
=
0
;
static
const
uint64_t
kInvalidAtlasGeneration
=
0
;
typedef
void
(
*
EvictionFunc
)
(
GrDrawOpAtlas
:
:
AtlasID
void
*
)
;
static
std
:
:
unique_ptr
<
GrDrawOpAtlas
>
Make
(
GrContext
*
GrPixelConfig
int
width
int
height
int
numPlotsX
int
numPlotsY
GrDrawOpAtlas
:
:
EvictionFunc
func
void
*
data
)
;
bool
addToAtlas
(
AtlasID
*
GrDrawOp
:
:
Target
*
int
width
int
height
const
void
*
image
SkIPoint16
*
loc
)
;
GrContext
*
context
(
)
const
{
return
fContext
;
}
sk_sp
<
GrTextureProxy
>
getProxy
(
)
const
{
return
fProxy
;
}
uint64_t
atlasGeneration
(
)
const
{
return
fAtlasGeneration
;
}
inline
bool
hasID
(
AtlasID
id
)
{
uint32_t
index
=
GetIndexFromID
(
id
)
;
SkASSERT
(
index
<
fNumPlots
)
;
return
fPlotArray
[
index
]
-
>
genID
(
)
=
=
GetGenerationFromID
(
id
)
;
}
inline
void
setLastUseToken
(
AtlasID
id
GrDrawOpUploadToken
token
)
{
SkASSERT
(
this
-
>
hasID
(
id
)
)
;
uint32_t
index
=
GetIndexFromID
(
id
)
;
SkASSERT
(
index
<
fNumPlots
)
;
this
-
>
makeMRU
(
fPlotArray
[
index
]
.
get
(
)
)
;
fPlotArray
[
index
]
-
>
setLastUseToken
(
token
)
;
}
inline
void
registerEvictionCallback
(
EvictionFunc
func
void
*
userData
)
{
EvictionData
*
data
=
fEvictionCallbacks
.
append
(
)
;
data
-
>
fFunc
=
func
;
data
-
>
fData
=
userData
;
}
class
BulkUseTokenUpdater
{
public
:
BulkUseTokenUpdater
(
)
:
fPlotAlreadyUpdated
(
0
)
{
}
BulkUseTokenUpdater
(
const
BulkUseTokenUpdater
&
that
)
:
fPlotsToUpdate
(
that
.
fPlotsToUpdate
)
fPlotAlreadyUpdated
(
that
.
fPlotAlreadyUpdated
)
{
}
void
add
(
AtlasID
id
)
{
int
index
=
GrDrawOpAtlas
:
:
GetIndexFromID
(
id
)
;
if
(
!
this
-
>
find
(
index
)
)
{
this
-
>
set
(
index
)
;
}
}
void
reset
(
)
{
fPlotsToUpdate
.
reset
(
)
;
fPlotAlreadyUpdated
=
0
;
}
private
:
bool
find
(
int
index
)
const
{
SkASSERT
(
index
<
kMaxPlots
)
;
return
(
fPlotAlreadyUpdated
>
>
index
)
&
1
;
}
void
set
(
int
index
)
{
SkASSERT
(
!
this
-
>
find
(
index
)
)
;
fPlotAlreadyUpdated
=
fPlotAlreadyUpdated
|
(
1
<
<
index
)
;
fPlotsToUpdate
.
push_back
(
index
)
;
}
static
const
int
kMinItems
=
4
;
static
const
int
kMaxPlots
=
32
;
SkSTArray
<
kMinItems
int
true
>
fPlotsToUpdate
;
uint32_t
fPlotAlreadyUpdated
;
friend
class
GrDrawOpAtlas
;
}
;
void
setLastUseTokenBulk
(
const
BulkUseTokenUpdater
&
updater
GrDrawOpUploadToken
token
)
{
int
count
=
updater
.
fPlotsToUpdate
.
count
(
)
;
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
Plot
*
plot
=
fPlotArray
[
updater
.
fPlotsToUpdate
[
i
]
]
.
get
(
)
;
this
-
>
makeMRU
(
plot
)
;
plot
-
>
setLastUseToken
(
token
)
;
}
}
static
const
int
kGlyphMaxDim
=
256
;
static
bool
GlyphTooLargeForAtlas
(
int
width
int
height
)
{
return
width
>
kGlyphMaxDim
|
|
height
>
kGlyphMaxDim
;
}
private
:
GrDrawOpAtlas
(
GrContext
*
sk_sp
<
GrTextureProxy
>
int
numPlotsX
int
numPlotsY
)
;
class
Plot
:
public
SkRefCnt
{
SK_DECLARE_INTERNAL_LLIST_INTERFACE
(
Plot
)
;
public
:
uint32_t
index
(
)
const
{
return
fIndex
;
}
uint64_t
genID
(
)
const
{
return
fGenID
;
}
GrDrawOpAtlas
:
:
AtlasID
id
(
)
const
{
SkASSERT
(
GrDrawOpAtlas
:
:
kInvalidAtlasID
!
=
fID
)
;
return
fID
;
}
SkDEBUGCODE
(
size_t
bpp
(
)
const
{
return
fBytesPerPixel
;
}
)
bool
addSubImage
(
int
width
int
height
const
void
*
image
SkIPoint16
*
loc
)
;
GrDrawOpUploadToken
lastUploadToken
(
)
const
{
return
fLastUpload
;
}
GrDrawOpUploadToken
lastUseToken
(
)
const
{
return
fLastUse
;
}
void
setLastUploadToken
(
GrDrawOpUploadToken
token
)
{
fLastUpload
=
token
;
}
void
setLastUseToken
(
GrDrawOpUploadToken
token
)
{
fLastUse
=
token
;
}
void
uploadToTexture
(
GrDrawOp
:
:
WritePixelsFn
&
GrTexture
*
texture
)
;
void
resetRects
(
)
;
private
:
Plot
(
int
index
uint64_t
genID
int
offX
int
offY
int
width
int
height
GrPixelConfig
config
)
;
~
Plot
(
)
override
;
Plot
*
clone
(
)
const
{
return
new
Plot
(
fIndex
fGenID
+
1
fX
fY
fWidth
fHeight
fConfig
)
;
}
static
GrDrawOpAtlas
:
:
AtlasID
CreateId
(
uint32_t
index
uint64_t
generation
)
{
SkASSERT
(
index
<
(
1
<
<
16
)
)
;
SkASSERT
(
generation
<
(
(
uint64_t
)
1
<
<
48
)
)
;
return
generation
<
<
16
|
index
;
}
GrDrawOpUploadToken
fLastUpload
;
GrDrawOpUploadToken
fLastUse
;
const
uint32_t
fIndex
;
uint64_t
fGenID
;
GrDrawOpAtlas
:
:
AtlasID
fID
;
unsigned
char
*
fData
;
const
int
fWidth
;
const
int
fHeight
;
const
int
fX
;
const
int
fY
;
GrRectanizer
*
fRects
;
const
SkIPoint16
fOffset
;
const
GrPixelConfig
fConfig
;
const
size_t
fBytesPerPixel
;
SkIRect
fDirtyRect
;
SkDEBUGCODE
(
bool
fDirty
)
;
friend
class
GrDrawOpAtlas
;
typedef
SkRefCnt
INHERITED
;
}
;
typedef
SkTInternalLList
<
Plot
>
PlotList
;
static
uint32_t
GetIndexFromID
(
AtlasID
id
)
{
return
id
&
0xffff
;
}
static
uint64_t
GetGenerationFromID
(
AtlasID
id
)
{
return
(
id
>
>
16
)
&
0xffffffffffff
;
}
inline
bool
updatePlot
(
GrDrawOp
:
:
Target
*
AtlasID
*
Plot
*
)
;
inline
void
makeMRU
(
Plot
*
plot
)
{
if
(
fPlotList
.
head
(
)
=
=
plot
)
{
return
;
}
fPlotList
.
remove
(
plot
)
;
fPlotList
.
addToHead
(
plot
)
;
}
inline
void
processEviction
(
AtlasID
)
;
GrContext
*
fContext
;
sk_sp
<
GrTextureProxy
>
fProxy
;
int
fPlotWidth
;
int
fPlotHeight
;
SkDEBUGCODE
(
uint32_t
fNumPlots
;
)
uint64_t
fAtlasGeneration
;
struct
EvictionData
{
EvictionFunc
fFunc
;
void
*
fData
;
}
;
SkTDArray
<
EvictionData
>
fEvictionCallbacks
;
std
:
:
unique_ptr
<
sk_sp
<
Plot
>
[
]
>
fPlotArray
;
PlotList
fPlotList
;
}
;
#
endif
