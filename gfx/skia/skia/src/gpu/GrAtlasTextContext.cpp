#
include
"
GrAtlasTextContext
.
h
"
#
include
"
GrBlurUtils
.
h
"
#
include
"
GrDrawContext
.
h
"
#
include
"
GrDrawTarget
.
h
"
#
include
"
GrFontScaler
.
h
"
#
include
"
GrStrokeInfo
.
h
"
#
include
"
GrTextBlobCache
.
h
"
#
include
"
GrTexturePriv
.
h
"
#
include
"
GrVertexBuffer
.
h
"
#
include
"
SkAutoKern
.
h
"
#
include
"
SkColorPriv
.
h
"
#
include
"
SkColorFilter
.
h
"
#
include
"
SkDistanceFieldGen
.
h
"
#
include
"
SkDraw
.
h
"
#
include
"
SkDrawFilter
.
h
"
#
include
"
SkDrawProcs
.
h
"
#
include
"
SkFindAndPlaceGlyph
.
h
"
#
include
"
SkGlyphCache
.
h
"
#
include
"
SkGpuDevice
.
h
"
#
include
"
SkGrPriv
.
h
"
#
include
"
SkPath
.
h
"
#
include
"
SkRTConf
.
h
"
#
include
"
SkStrokeRec
.
h
"
#
include
"
SkTextBlob
.
h
"
#
include
"
SkTextMapStateProc
.
h
"
#
include
"
batches
/
GrAtlasTextBatch
.
h
"
namespace
{
static
const
int
kMinDFFontSize
=
18
;
static
const
int
kSmallDFFontSize
=
32
;
static
const
int
kSmallDFFontLimit
=
32
;
static
const
int
kMediumDFFontSize
=
72
;
static
const
int
kMediumDFFontLimit
=
72
;
static
const
int
kLargeDFFontSize
=
162
;
#
ifdef
SK_BUILD_FOR_ANDROID
static
const
int
kLargeDFFontLimit
=
384
;
#
else
static
const
int
kLargeDFFontLimit
=
2
*
kLargeDFFontSize
;
#
endif
SkDEBUGCODE
(
static
const
int
kExpectedDistanceAdjustTableSize
=
8
;
)
}
;
GrAtlasTextContext
:
:
GrAtlasTextContext
(
GrContext
*
context
const
SkSurfaceProps
&
surfaceProps
)
:
INHERITED
(
context
surfaceProps
)
fDistanceAdjustTable
(
new
DistanceAdjustTable
)
{
static_assert
(
GrAtlasTextBatch
:
:
kGrayTextVASize
>
=
GrAtlasTextBatch
:
:
kColorTextVASize
&
&
GrAtlasTextBatch
:
:
kGrayTextVASize
>
=
GrAtlasTextBatch
:
:
kLCDTextVASize
"
vertex_attribute_changed
"
)
;
fCurrStrike
=
nullptr
;
fCache
=
context
-
>
getTextBlobCache
(
)
;
}
void
GrAtlasTextContext
:
:
DistanceAdjustTable
:
:
buildDistanceAdjustTable
(
)
{
int
width
height
;
size_t
size
;
#
ifdef
SK_GAMMA_CONTRAST
SkScalar
contrast
=
SK_GAMMA_CONTRAST
;
#
else
SkScalar
contrast
=
0
.
5f
;
#
endif
SkScalar
paintGamma
=
SK_GAMMA_EXPONENT
;
SkScalar
deviceGamma
=
SK_GAMMA_EXPONENT
;
size
=
SkScalerContext
:
:
GetGammaLUTSize
(
contrast
paintGamma
deviceGamma
&
width
&
height
)
;
SkASSERT
(
kExpectedDistanceAdjustTableSize
=
=
height
)
;
fTable
=
new
SkScalar
[
height
]
;
SkAutoTArray
<
uint8_t
>
data
(
(
int
)
size
)
;
SkScalerContext
:
:
GetGammaLUTData
(
contrast
paintGamma
deviceGamma
data
.
get
(
)
)
;
for
(
int
row
=
0
;
row
<
height
;
+
+
row
)
{
uint8_t
*
rowPtr
=
data
.
get
(
)
+
row
*
width
;
for
(
int
col
=
0
;
col
<
width
-
1
;
+
+
col
)
{
if
(
rowPtr
[
col
]
<
=
127
&
&
rowPtr
[
col
+
1
]
>
=
128
)
{
float
interp
=
(
127
.
5f
-
rowPtr
[
col
]
)
/
(
rowPtr
[
col
+
1
]
-
rowPtr
[
col
]
)
;
float
borderAlpha
=
(
col
+
interp
)
/
255
.
f
;
float
t
=
borderAlpha
*
(
borderAlpha
*
(
4
.
0f
*
borderAlpha
-
6
.
0f
)
+
5
.
0f
)
/
3
.
0f
;
const
float
kDistanceFieldAAFactor
=
0
.
65f
;
float
d
=
2
.
0f
*
kDistanceFieldAAFactor
*
t
-
kDistanceFieldAAFactor
;
fTable
[
row
]
=
d
;
break
;
}
}
}
}
GrAtlasTextContext
*
GrAtlasTextContext
:
:
Create
(
GrContext
*
context
const
SkSurfaceProps
&
surfaceProps
)
{
return
new
GrAtlasTextContext
(
context
surfaceProps
)
;
}
bool
GrAtlasTextContext
:
:
canDraw
(
const
SkPaint
&
skPaint
const
SkMatrix
&
viewMatrix
)
{
return
this
-
>
canDrawAsDistanceFields
(
skPaint
viewMatrix
)
|
|
!
SkDraw
:
:
ShouldDrawTextAsPaths
(
skPaint
viewMatrix
)
;
}
GrColor
GrAtlasTextContext
:
:
ComputeCanonicalColor
(
const
SkPaint
&
paint
bool
lcd
)
{
GrColor
canonicalColor
=
paint
.
computeLuminanceColor
(
)
;
if
(
lcd
)
{
SkASSERT
(
false
)
;
}
else
{
U8CPU
lum
=
SkComputeLuminance
(
SkColorGetR
(
canonicalColor
)
SkColorGetG
(
canonicalColor
)
SkColorGetB
(
canonicalColor
)
)
;
canonicalColor
=
SkMaskGamma
:
:
CanonicalColor
(
SkColorSetRGB
(
lum
lum
lum
)
)
;
}
return
canonicalColor
;
}
bool
GrAtlasTextContext
:
:
HasLCD
(
const
SkTextBlob
*
blob
)
{
SkTextBlobRunIterator
it
(
blob
)
;
for
(
;
!
it
.
done
(
)
;
it
.
next
(
)
)
{
if
(
it
.
isLCD
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
GrAtlasTextContext
:
:
MustRegenerateBlob
(
SkScalar
*
outTransX
SkScalar
*
outTransY
const
GrAtlasTextBlob
&
blob
const
SkPaint
&
paint
GrColor
color
const
SkMaskFilter
:
:
BlurRec
&
blurRec
const
SkMatrix
&
viewMatrix
SkScalar
x
SkScalar
y
)
{
if
(
blob
.
fKey
.
fCanonicalColor
=
=
SK_ColorTRANSPARENT
&
&
blob
.
fPaintColor
!
=
color
)
{
return
true
;
}
if
(
blob
.
fViewMatrix
.
hasPerspective
(
)
!
=
viewMatrix
.
hasPerspective
(
)
)
{
return
true
;
}
if
(
blob
.
fViewMatrix
.
hasPerspective
(
)
&
&
!
blob
.
fViewMatrix
.
cheapEqualTo
(
viewMatrix
)
)
{
return
true
;
}
if
(
blob
.
fKey
.
fHasBlur
&
&
(
blob
.
fBlurRec
.
fSigma
!
=
blurRec
.
fSigma
|
|
blob
.
fBlurRec
.
fStyle
!
=
blurRec
.
fStyle
|
|
blob
.
fBlurRec
.
fQuality
!
=
blurRec
.
fQuality
)
)
{
return
true
;
}
if
(
blob
.
fKey
.
fStyle
!
=
SkPaint
:
:
kFill_Style
&
&
(
blob
.
fStrokeInfo
.
fFrameWidth
!
=
paint
.
getStrokeWidth
(
)
|
|
blob
.
fStrokeInfo
.
fMiterLimit
!
=
paint
.
getStrokeMiter
(
)
|
|
blob
.
fStrokeInfo
.
fJoin
!
=
paint
.
getStrokeJoin
(
)
)
)
{
return
true
;
}
if
(
blob
.
hasBitmap
(
)
&
&
blob
.
hasDistanceField
(
)
)
{
if
(
blob
.
fViewMatrix
.
cheapEqualTo
(
viewMatrix
)
&
&
x
=
=
blob
.
fX
&
&
y
=
=
blob
.
fY
)
{
return
false
;
}
return
true
;
}
if
(
blob
.
hasBitmap
(
)
)
{
if
(
blob
.
fViewMatrix
.
getScaleX
(
)
!
=
viewMatrix
.
getScaleX
(
)
|
|
blob
.
fViewMatrix
.
getScaleY
(
)
!
=
viewMatrix
.
getScaleY
(
)
|
|
blob
.
fViewMatrix
.
getSkewX
(
)
!
=
viewMatrix
.
getSkewX
(
)
|
|
blob
.
fViewMatrix
.
getSkewY
(
)
!
=
viewMatrix
.
getSkewY
(
)
)
{
return
true
;
}
SkScalar
transX
=
viewMatrix
.
getTranslateX
(
)
+
viewMatrix
.
getScaleX
(
)
*
(
x
-
blob
.
fX
)
+
viewMatrix
.
getSkewX
(
)
*
(
y
-
blob
.
fY
)
-
blob
.
fViewMatrix
.
getTranslateX
(
)
;
SkScalar
transY
=
viewMatrix
.
getTranslateY
(
)
+
viewMatrix
.
getSkewY
(
)
*
(
x
-
blob
.
fX
)
+
viewMatrix
.
getScaleY
(
)
*
(
y
-
blob
.
fY
)
-
blob
.
fViewMatrix
.
getTranslateY
(
)
;
if
(
!
SkScalarIsInt
(
transX
)
|
|
!
SkScalarIsInt
(
transY
)
)
{
return
true
;
}
(
*
outTransX
)
=
transX
;
(
*
outTransY
)
=
transY
;
}
else
if
(
blob
.
hasDistanceField
(
)
)
{
SkScalar
newMaxScale
=
viewMatrix
.
getMaxScale
(
)
;
SkScalar
oldMaxScale
=
blob
.
fViewMatrix
.
getMaxScale
(
)
;
SkScalar
scaleAdjust
=
newMaxScale
/
oldMaxScale
;
if
(
scaleAdjust
<
blob
.
fMaxMinScale
|
|
scaleAdjust
>
blob
.
fMinMaxScale
)
{
return
true
;
}
(
*
outTransX
)
=
x
-
blob
.
fX
;
(
*
outTransY
)
=
y
-
blob
.
fY
;
}
return
false
;
}
inline
SkGlyphCache
*
GrAtlasTextContext
:
:
setupCache
(
GrAtlasTextBlob
:
:
Run
*
run
const
SkPaint
&
skPaint
const
SkMatrix
*
viewMatrix
bool
noGamma
)
{
skPaint
.
getScalerContextDescriptor
(
&
run
-
>
fDescriptor
fSurfaceProps
viewMatrix
noGamma
)
;
run
-
>
fTypeface
.
reset
(
SkSafeRef
(
skPaint
.
getTypeface
(
)
)
)
;
return
SkGlyphCache
:
:
DetachCache
(
run
-
>
fTypeface
run
-
>
fDescriptor
.
getDesc
(
)
)
;
}
void
GrAtlasTextContext
:
:
drawTextBlob
(
GrDrawContext
*
dc
GrRenderTarget
*
rt
const
GrClip
&
clip
const
SkPaint
&
skPaint
const
SkMatrix
&
viewMatrix
const
SkTextBlob
*
blob
SkScalar
x
SkScalar
y
SkDrawFilter
*
drawFilter
const
SkIRect
&
clipBounds
)
{
if
(
fContext
-
>
abandoned
(
)
)
{
return
;
}
SkAutoTUnref
<
GrAtlasTextBlob
>
cacheBlob
;
SkMaskFilter
:
:
BlurRec
blurRec
;
GrAtlasTextBlob
:
:
Key
key
;
const
SkMaskFilter
*
mf
=
skPaint
.
getMaskFilter
(
)
;
bool
canCache
=
!
(
skPaint
.
getPathEffect
(
)
|
|
(
mf
&
&
!
mf
-
>
asABlur
(
&
blurRec
)
)
|
|
drawFilter
)
;
if
(
canCache
)
{
bool
hasLCD
=
HasLCD
(
blob
)
;
SkPixelGeometry
pixelGeometry
=
hasLCD
?
fSurfaceProps
.
pixelGeometry
(
)
:
kUnknown_SkPixelGeometry
;
GrColor
canonicalColor
=
hasLCD
?
SK_ColorTRANSPARENT
:
ComputeCanonicalColor
(
skPaint
hasLCD
)
;
key
.
fPixelGeometry
=
pixelGeometry
;
key
.
fUniqueID
=
blob
-
>
uniqueID
(
)
;
key
.
fStyle
=
skPaint
.
getStyle
(
)
;
key
.
fHasBlur
=
SkToBool
(
mf
)
;
key
.
fCanonicalColor
=
canonicalColor
;
cacheBlob
.
reset
(
SkSafeRef
(
fCache
-
>
find
(
key
)
)
)
;
}
SkScalar
transX
=
0
.
f
;
SkScalar
transY
=
0
.
f
;
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
fContext
skPaint
viewMatrix
&
grPaint
)
)
{
return
;
}
if
(
cacheBlob
)
{
if
(
MustRegenerateBlob
(
&
transX
&
transY
*
cacheBlob
skPaint
grPaint
.
getColor
(
)
blurRec
viewMatrix
x
y
)
)
{
fCache
-
>
remove
(
cacheBlob
)
;
cacheBlob
.
reset
(
SkRef
(
fCache
-
>
createCachedBlob
(
blob
key
blurRec
skPaint
GrAtlasTextBatch
:
:
kGrayTextVASize
)
)
)
;
this
-
>
regenerateTextBlob
(
cacheBlob
skPaint
grPaint
.
getColor
(
)
viewMatrix
blob
x
y
drawFilter
clip
)
;
}
else
{
cacheBlob
-
>
fViewMatrix
=
viewMatrix
;
cacheBlob
-
>
fX
=
x
;
cacheBlob
-
>
fY
=
y
;
fCache
-
>
makeMRU
(
cacheBlob
)
;
#
ifdef
CACHE_SANITY_CHECK
{
int
glyphCount
=
0
;
int
runCount
=
0
;
GrTextBlobCache
:
:
BlobGlyphCount
(
&
glyphCount
&
runCount
blob
)
;
SkAutoTUnref
<
GrAtlasTextBlob
>
sanityBlob
(
fCache
-
>
createBlob
(
glyphCount
runCount
kGrayTextVASize
)
)
;
GrTextBlobCache
:
:
SetupCacheBlobKey
(
sanityBlob
key
blurRec
skPaint
)
;
this
-
>
regenerateTextBlob
(
sanityBlob
skPaint
grPaint
.
getColor
(
)
viewMatrix
blob
x
y
drawFilter
clip
)
;
GrAtlasTextBlob
:
:
AssertEqual
(
*
sanityBlob
*
cacheBlob
)
;
}
#
endif
}
}
else
{
if
(
canCache
)
{
cacheBlob
.
reset
(
SkRef
(
fCache
-
>
createCachedBlob
(
blob
key
blurRec
skPaint
GrAtlasTextBatch
:
:
kGrayTextVASize
)
)
)
;
}
else
{
cacheBlob
.
reset
(
fCache
-
>
createBlob
(
blob
GrAtlasTextBatch
:
:
kGrayTextVASize
)
)
;
}
this
-
>
regenerateTextBlob
(
cacheBlob
skPaint
grPaint
.
getColor
(
)
viewMatrix
blob
x
y
drawFilter
clip
)
;
}
this
-
>
flush
(
blob
cacheBlob
dc
rt
skPaint
grPaint
drawFilter
clip
viewMatrix
clipBounds
x
y
transX
transY
)
;
}
inline
bool
GrAtlasTextContext
:
:
canDrawAsDistanceFields
(
const
SkPaint
&
skPaint
const
SkMatrix
&
viewMatrix
)
{
if
(
viewMatrix
.
hasPerspective
(
)
)
{
return
false
;
}
SkScalar
maxScale
=
viewMatrix
.
getMaxScale
(
)
;
SkScalar
scaledTextSize
=
maxScale
*
skPaint
.
getTextSize
(
)
;
if
(
scaledTextSize
<
kMinDFFontSize
|
|
scaledTextSize
>
kLargeDFFontLimit
)
{
return
false
;
}
bool
useDFT
=
fSurfaceProps
.
isUseDeviceIndependentFonts
(
)
;
#
if
SK_FORCE_DISTANCE_FIELD_TEXT
useDFT
=
true
;
#
endif
if
(
!
useDFT
&
&
scaledTextSize
<
kLargeDFFontSize
)
{
return
false
;
}
if
(
skPaint
.
getRasterizer
(
)
|
|
skPaint
.
getMaskFilter
(
)
|
|
!
fContext
-
>
caps
(
)
-
>
shaderCaps
(
)
-
>
shaderDerivativeSupport
(
)
)
{
return
false
;
}
if
(
skPaint
.
getStyle
(
)
!
=
SkPaint
:
:
kFill_Style
)
{
return
false
;
}
return
true
;
}
void
GrAtlasTextContext
:
:
regenerateTextBlob
(
GrAtlasTextBlob
*
cacheBlob
const
SkPaint
&
skPaint
GrColor
color
const
SkMatrix
&
viewMatrix
const
SkTextBlob
*
blob
SkScalar
x
SkScalar
y
SkDrawFilter
*
drawFilter
const
GrClip
&
clip
)
{
cacheBlob
-
>
fPaintColor
=
color
;
cacheBlob
-
>
fViewMatrix
=
viewMatrix
;
cacheBlob
-
>
fX
=
x
;
cacheBlob
-
>
fY
=
y
;
SkPaint
runPaint
=
skPaint
;
SkTextBlobRunIterator
it
(
blob
)
;
for
(
int
run
=
0
;
!
it
.
done
(
)
;
it
.
next
(
)
run
+
+
)
{
int
glyphCount
=
it
.
glyphCount
(
)
;
size_t
textLen
=
glyphCount
*
sizeof
(
uint16_t
)
;
const
SkPoint
&
offset
=
it
.
offset
(
)
;
it
.
applyFontToPaint
(
&
runPaint
)
;
if
(
drawFilter
&
&
!
drawFilter
-
>
filter
(
&
runPaint
SkDrawFilter
:
:
kText_Type
)
)
{
runPaint
=
skPaint
;
continue
;
}
runPaint
.
setFlags
(
FilterTextFlags
(
fSurfaceProps
runPaint
)
)
;
if
(
run
>
0
)
{
PerSubRunInfo
&
newRun
=
cacheBlob
-
>
fRuns
[
run
]
.
fSubRunInfo
.
back
(
)
;
PerSubRunInfo
&
lastRun
=
cacheBlob
-
>
fRuns
[
run
-
1
]
.
fSubRunInfo
.
back
(
)
;
newRun
.
fVertexStartIndex
=
lastRun
.
fVertexEndIndex
;
newRun
.
fVertexEndIndex
=
lastRun
.
fVertexEndIndex
;
newRun
.
fGlyphStartIndex
=
lastRun
.
fGlyphEndIndex
;
newRun
.
fGlyphEndIndex
=
lastRun
.
fGlyphEndIndex
;
}
if
(
this
-
>
canDrawAsDistanceFields
(
runPaint
viewMatrix
)
)
{
cacheBlob
-
>
setHasDistanceField
(
)
;
SkPaint
dfPaint
=
runPaint
;
SkScalar
textRatio
;
this
-
>
initDistanceFieldPaint
(
cacheBlob
&
dfPaint
&
textRatio
viewMatrix
)
;
Run
&
runIdx
=
cacheBlob
-
>
fRuns
[
run
]
;
PerSubRunInfo
&
subRun
=
runIdx
.
fSubRunInfo
.
back
(
)
;
subRun
.
fUseLCDText
=
runPaint
.
isLCDRenderText
(
)
;
subRun
.
fDrawAsDistanceFields
=
true
;
SkTDArray
<
char
>
fallbackTxt
;
SkTDArray
<
SkScalar
>
fallbackPos
;
SkPoint
dfOffset
;
int
scalarsPerPosition
=
2
;
switch
(
it
.
positioning
(
)
)
{
case
SkTextBlob
:
:
kDefault_Positioning
:
{
this
-
>
internalDrawDFText
(
cacheBlob
run
dfPaint
color
viewMatrix
(
const
char
*
)
it
.
glyphs
(
)
textLen
x
+
offset
.
x
(
)
y
+
offset
.
y
(
)
textRatio
&
fallbackTxt
&
fallbackPos
&
dfOffset
runPaint
)
;
break
;
}
case
SkTextBlob
:
:
kHorizontal_Positioning
:
{
scalarsPerPosition
=
1
;
dfOffset
=
SkPoint
:
:
Make
(
x
y
+
offset
.
y
(
)
)
;
this
-
>
internalDrawDFPosText
(
cacheBlob
run
dfPaint
color
viewMatrix
(
const
char
*
)
it
.
glyphs
(
)
textLen
it
.
pos
(
)
scalarsPerPosition
dfOffset
textRatio
&
fallbackTxt
&
fallbackPos
)
;
break
;
}
case
SkTextBlob
:
:
kFull_Positioning
:
{
dfOffset
=
SkPoint
:
:
Make
(
x
y
)
;
this
-
>
internalDrawDFPosText
(
cacheBlob
run
dfPaint
color
viewMatrix
(
const
char
*
)
it
.
glyphs
(
)
textLen
it
.
pos
(
)
scalarsPerPosition
dfOffset
textRatio
&
fallbackTxt
&
fallbackPos
)
;
break
;
}
}
if
(
fallbackTxt
.
count
(
)
)
{
this
-
>
fallbackDrawPosText
(
cacheBlob
run
clip
color
runPaint
viewMatrix
fallbackTxt
fallbackPos
scalarsPerPosition
dfOffset
)
;
}
}
else
if
(
SkDraw
:
:
ShouldDrawTextAsPaths
(
runPaint
viewMatrix
)
)
{
cacheBlob
-
>
fRuns
[
run
]
.
fDrawAsPaths
=
true
;
}
else
{
cacheBlob
-
>
setHasBitmap
(
)
;
SkGlyphCache
*
cache
=
this
-
>
setupCache
(
&
cacheBlob
-
>
fRuns
[
run
]
runPaint
&
viewMatrix
false
)
;
switch
(
it
.
positioning
(
)
)
{
case
SkTextBlob
:
:
kDefault_Positioning
:
this
-
>
internalDrawBMPText
(
cacheBlob
run
cache
runPaint
color
viewMatrix
(
const
char
*
)
it
.
glyphs
(
)
textLen
x
+
offset
.
x
(
)
y
+
offset
.
y
(
)
)
;
break
;
case
SkTextBlob
:
:
kHorizontal_Positioning
:
this
-
>
internalDrawBMPPosText
(
cacheBlob
run
cache
runPaint
color
viewMatrix
(
const
char
*
)
it
.
glyphs
(
)
textLen
it
.
pos
(
)
1
SkPoint
:
:
Make
(
x
y
+
offset
.
y
(
)
)
)
;
break
;
case
SkTextBlob
:
:
kFull_Positioning
:
this
-
>
internalDrawBMPPosText
(
cacheBlob
run
cache
runPaint
color
viewMatrix
(
const
char
*
)
it
.
glyphs
(
)
textLen
it
.
pos
(
)
2
SkPoint
:
:
Make
(
x
y
)
)
;
break
;
}
SkGlyphCache
:
:
AttachCache
(
cache
)
;
}
if
(
drawFilter
)
{
runPaint
=
skPaint
;
}
}
}
inline
void
GrAtlasTextContext
:
:
initDistanceFieldPaint
(
GrAtlasTextBlob
*
blob
SkPaint
*
skPaint
SkScalar
*
textRatio
const
SkMatrix
&
viewMatrix
)
{
SkASSERT
(
!
viewMatrix
.
hasPerspective
(
)
)
;
SkScalar
maxScale
=
viewMatrix
.
getMaxScale
(
)
;
SkScalar
textSize
=
skPaint
-
>
getTextSize
(
)
;
SkScalar
scaledTextSize
=
textSize
;
if
(
maxScale
>
0
&
&
!
SkScalarNearlyEqual
(
maxScale
SK_Scalar1
)
)
{
scaledTextSize
*
=
maxScale
;
}
SkScalar
dfMaskScaleFloor
;
SkScalar
dfMaskScaleCeil
;
if
(
scaledTextSize
<
=
kSmallDFFontLimit
)
{
dfMaskScaleFloor
=
kMinDFFontSize
;
dfMaskScaleCeil
=
kSmallDFFontLimit
;
*
textRatio
=
textSize
/
kSmallDFFontSize
;
skPaint
-
>
setTextSize
(
SkIntToScalar
(
kSmallDFFontSize
)
)
;
}
else
if
(
scaledTextSize
<
=
kMediumDFFontLimit
)
{
dfMaskScaleFloor
=
kSmallDFFontLimit
;
dfMaskScaleCeil
=
kMediumDFFontLimit
;
*
textRatio
=
textSize
/
kMediumDFFontSize
;
skPaint
-
>
setTextSize
(
SkIntToScalar
(
kMediumDFFontSize
)
)
;
}
else
{
dfMaskScaleFloor
=
kMediumDFFontLimit
;
dfMaskScaleCeil
=
kLargeDFFontLimit
;
*
textRatio
=
textSize
/
kLargeDFFontSize
;
skPaint
-
>
setTextSize
(
SkIntToScalar
(
kLargeDFFontSize
)
)
;
}
SkASSERT
(
dfMaskScaleFloor
<
=
scaledTextSize
&
&
scaledTextSize
<
=
dfMaskScaleCeil
)
;
blob
-
>
fMaxMinScale
=
SkMaxScalar
(
dfMaskScaleFloor
/
scaledTextSize
blob
-
>
fMaxMinScale
)
;
blob
-
>
fMinMaxScale
=
SkMinScalar
(
dfMaskScaleCeil
/
scaledTextSize
blob
-
>
fMinMaxScale
)
;
skPaint
-
>
setLCDRenderText
(
false
)
;
skPaint
-
>
setAutohinted
(
false
)
;
skPaint
-
>
setHinting
(
SkPaint
:
:
kNormal_Hinting
)
;
skPaint
-
>
setSubpixelText
(
true
)
;
}
inline
void
GrAtlasTextContext
:
:
fallbackDrawPosText
(
GrAtlasTextBlob
*
blob
int
runIndex
const
GrClip
&
clip
GrColor
color
const
SkPaint
&
skPaint
const
SkMatrix
&
viewMatrix
const
SkTDArray
<
char
>
&
fallbackTxt
const
SkTDArray
<
SkScalar
>
&
fallbackPos
int
scalarsPerPosition
const
SkPoint
&
offset
)
{
SkASSERT
(
fallbackTxt
.
count
(
)
)
;
blob
-
>
setHasBitmap
(
)
;
Run
&
run
=
blob
-
>
fRuns
[
runIndex
]
;
run
.
push_back
(
)
;
run
.
fOverrideDescriptor
.
reset
(
new
SkAutoDescriptor
)
;
skPaint
.
getScalerContextDescriptor
(
run
.
fOverrideDescriptor
fSurfaceProps
&
viewMatrix
false
)
;
SkGlyphCache
*
cache
=
SkGlyphCache
:
:
DetachCache
(
run
.
fTypeface
run
.
fOverrideDescriptor
-
>
getDesc
(
)
)
;
this
-
>
internalDrawBMPPosText
(
blob
runIndex
cache
skPaint
color
viewMatrix
fallbackTxt
.
begin
(
)
fallbackTxt
.
count
(
)
fallbackPos
.
begin
(
)
scalarsPerPosition
offset
)
;
SkGlyphCache
:
:
AttachCache
(
cache
)
;
}
inline
GrAtlasTextBlob
*
GrAtlasTextContext
:
:
setupDFBlob
(
int
glyphCount
const
SkPaint
&
origPaint
const
SkMatrix
&
viewMatrix
SkPaint
*
dfPaint
SkScalar
*
textRatio
)
{
GrAtlasTextBlob
*
blob
=
fCache
-
>
createBlob
(
glyphCount
1
GrAtlasTextBatch
:
:
kGrayTextVASize
)
;
*
dfPaint
=
origPaint
;
this
-
>
initDistanceFieldPaint
(
blob
dfPaint
textRatio
viewMatrix
)
;
blob
-
>
fViewMatrix
=
viewMatrix
;
Run
&
run
=
blob
-
>
fRuns
[
0
]
;
PerSubRunInfo
&
subRun
=
run
.
fSubRunInfo
.
back
(
)
;
subRun
.
fUseLCDText
=
origPaint
.
isLCDRenderText
(
)
;
subRun
.
fDrawAsDistanceFields
=
true
;
return
blob
;
}
inline
GrAtlasTextBlob
*
GrAtlasTextContext
:
:
createDrawTextBlob
(
const
GrClip
&
clip
const
GrPaint
&
paint
const
SkPaint
&
skPaint
const
SkMatrix
&
viewMatrix
const
char
text
[
]
size_t
byteLength
SkScalar
x
SkScalar
y
const
SkIRect
&
regionClipBounds
)
{
int
glyphCount
=
skPaint
.
countText
(
text
byteLength
)
;
GrAtlasTextBlob
*
blob
;
if
(
this
-
>
canDrawAsDistanceFields
(
skPaint
viewMatrix
)
)
{
SkPaint
dfPaint
;
SkScalar
textRatio
;
blob
=
this
-
>
setupDFBlob
(
glyphCount
skPaint
viewMatrix
&
dfPaint
&
textRatio
)
;
SkTDArray
<
char
>
fallbackTxt
;
SkTDArray
<
SkScalar
>
fallbackPos
;
SkPoint
offset
;
this
-
>
internalDrawDFText
(
blob
0
dfPaint
paint
.
getColor
(
)
viewMatrix
text
byteLength
x
y
textRatio
&
fallbackTxt
&
fallbackPos
&
offset
skPaint
)
;
if
(
fallbackTxt
.
count
(
)
)
{
this
-
>
fallbackDrawPosText
(
blob
0
clip
paint
.
getColor
(
)
skPaint
viewMatrix
fallbackTxt
fallbackPos
2
offset
)
;
}
}
else
{
blob
=
fCache
-
>
createBlob
(
glyphCount
1
GrAtlasTextBatch
:
:
kGrayTextVASize
)
;
blob
-
>
fViewMatrix
=
viewMatrix
;
SkGlyphCache
*
cache
=
this
-
>
setupCache
(
&
blob
-
>
fRuns
[
0
]
skPaint
&
viewMatrix
false
)
;
this
-
>
internalDrawBMPText
(
blob
0
cache
skPaint
paint
.
getColor
(
)
viewMatrix
text
byteLength
x
y
)
;
SkGlyphCache
:
:
AttachCache
(
cache
)
;
}
return
blob
;
}
inline
GrAtlasTextBlob
*
GrAtlasTextContext
:
:
createDrawPosTextBlob
(
const
GrClip
&
clip
const
GrPaint
&
paint
const
SkPaint
&
skPaint
const
SkMatrix
&
viewMatrix
const
char
text
[
]
size_t
byteLength
const
SkScalar
pos
[
]
int
scalarsPerPosition
const
SkPoint
&
offset
const
SkIRect
&
regionClipBounds
)
{
int
glyphCount
=
skPaint
.
countText
(
text
byteLength
)
;
GrAtlasTextBlob
*
blob
;
if
(
this
-
>
canDrawAsDistanceFields
(
skPaint
viewMatrix
)
)
{
SkPaint
dfPaint
;
SkScalar
textRatio
;
blob
=
this
-
>
setupDFBlob
(
glyphCount
skPaint
viewMatrix
&
dfPaint
&
textRatio
)
;
SkTDArray
<
char
>
fallbackTxt
;
SkTDArray
<
SkScalar
>
fallbackPos
;
this
-
>
internalDrawDFPosText
(
blob
0
dfPaint
paint
.
getColor
(
)
viewMatrix
text
byteLength
pos
scalarsPerPosition
offset
textRatio
&
fallbackTxt
&
fallbackPos
)
;
if
(
fallbackTxt
.
count
(
)
)
{
this
-
>
fallbackDrawPosText
(
blob
0
clip
paint
.
getColor
(
)
skPaint
viewMatrix
fallbackTxt
fallbackPos
scalarsPerPosition
offset
)
;
}
}
else
{
blob
=
fCache
-
>
createBlob
(
glyphCount
1
GrAtlasTextBatch
:
:
kGrayTextVASize
)
;
blob
-
>
fViewMatrix
=
viewMatrix
;
SkGlyphCache
*
cache
=
this
-
>
setupCache
(
&
blob
-
>
fRuns
[
0
]
skPaint
&
viewMatrix
false
)
;
this
-
>
internalDrawBMPPosText
(
blob
0
cache
skPaint
paint
.
getColor
(
)
viewMatrix
text
byteLength
pos
scalarsPerPosition
offset
)
;
SkGlyphCache
:
:
AttachCache
(
cache
)
;
}
return
blob
;
}
void
GrAtlasTextContext
:
:
onDrawText
(
GrDrawContext
*
dc
GrRenderTarget
*
rt
const
GrClip
&
clip
const
GrPaint
&
paint
const
SkPaint
&
skPaint
const
SkMatrix
&
viewMatrix
const
char
text
[
]
size_t
byteLength
SkScalar
x
SkScalar
y
const
SkIRect
&
regionClipBounds
)
{
SkAutoTUnref
<
GrAtlasTextBlob
>
blob
(
this
-
>
createDrawTextBlob
(
clip
paint
skPaint
viewMatrix
text
byteLength
x
y
regionClipBounds
)
)
;
this
-
>
flush
(
blob
dc
rt
skPaint
paint
clip
regionClipBounds
)
;
}
void
GrAtlasTextContext
:
:
onDrawPosText
(
GrDrawContext
*
dc
GrRenderTarget
*
rt
const
GrClip
&
clip
const
GrPaint
&
paint
const
SkPaint
&
skPaint
const
SkMatrix
&
viewMatrix
const
char
text
[
]
size_t
byteLength
const
SkScalar
pos
[
]
int
scalarsPerPosition
const
SkPoint
&
offset
const
SkIRect
&
regionClipBounds
)
{
SkAutoTUnref
<
GrAtlasTextBlob
>
blob
(
this
-
>
createDrawPosTextBlob
(
clip
paint
skPaint
viewMatrix
text
byteLength
pos
scalarsPerPosition
offset
regionClipBounds
)
)
;
this
-
>
flush
(
blob
dc
rt
skPaint
paint
clip
regionClipBounds
)
;
}
void
GrAtlasTextContext
:
:
internalDrawBMPText
(
GrAtlasTextBlob
*
blob
int
runIndex
SkGlyphCache
*
cache
const
SkPaint
&
skPaint
GrColor
color
const
SkMatrix
&
viewMatrix
const
char
text
[
]
size_t
byteLength
SkScalar
x
SkScalar
y
)
{
SkASSERT
(
byteLength
=
=
0
|
|
text
!
=
nullptr
)
;
if
(
text
=
=
nullptr
|
|
byteLength
=
=
0
)
{
return
;
}
fCurrStrike
=
nullptr
;
GrFontScaler
*
fontScaler
=
GetGrFontScaler
(
cache
)
;
SkFindAndPlaceGlyph
:
:
ProcessText
(
skPaint
.
getTextEncoding
(
)
text
byteLength
{
x
y
}
viewMatrix
skPaint
.
getTextAlign
(
)
cache
[
&
]
(
const
SkGlyph
&
glyph
SkPoint
position
SkPoint
rounding
)
{
position
+
=
rounding
;
this
-
>
bmpAppendGlyph
(
blob
runIndex
glyph
SkScalarFloorToInt
(
position
.
fX
)
SkScalarFloorToInt
(
position
.
fY
)
color
fontScaler
)
;
}
)
;
}
void
GrAtlasTextContext
:
:
internalDrawBMPPosText
(
GrAtlasTextBlob
*
blob
int
runIndex
SkGlyphCache
*
cache
const
SkPaint
&
skPaint
GrColor
color
const
SkMatrix
&
viewMatrix
const
char
text
[
]
size_t
byteLength
const
SkScalar
pos
[
]
int
scalarsPerPosition
const
SkPoint
&
offset
)
{
SkASSERT
(
byteLength
=
=
0
|
|
text
!
=
nullptr
)
;
SkASSERT
(
1
=
=
scalarsPerPosition
|
|
2
=
=
scalarsPerPosition
)
;
if
(
text
=
=
nullptr
|
|
byteLength
=
=
0
)
{
return
;
}
fCurrStrike
=
nullptr
;
GrFontScaler
*
fontScaler
=
GetGrFontScaler
(
cache
)
;
SkFindAndPlaceGlyph
:
:
ProcessPosText
(
skPaint
.
getTextEncoding
(
)
text
byteLength
offset
viewMatrix
pos
scalarsPerPosition
skPaint
.
getTextAlign
(
)
cache
[
&
]
(
const
SkGlyph
&
glyph
SkPoint
position
SkPoint
rounding
)
{
position
+
=
rounding
;
this
-
>
bmpAppendGlyph
(
blob
runIndex
glyph
SkScalarFloorToInt
(
position
.
fX
)
SkScalarFloorToInt
(
position
.
fY
)
color
fontScaler
)
;
}
)
;
}
void
GrAtlasTextContext
:
:
internalDrawDFText
(
GrAtlasTextBlob
*
blob
int
runIndex
const
SkPaint
&
skPaint
GrColor
color
const
SkMatrix
&
viewMatrix
const
char
text
[
]
size_t
byteLength
SkScalar
x
SkScalar
y
SkScalar
textRatio
SkTDArray
<
char
>
*
fallbackTxt
SkTDArray
<
SkScalar
>
*
fallbackPos
SkPoint
*
offset
const
SkPaint
&
origPaint
)
{
SkASSERT
(
byteLength
=
=
0
|
|
text
!
=
nullptr
)
;
if
(
text
=
=
nullptr
|
|
byteLength
=
=
0
)
{
return
;
}
SkDrawCacheProc
glyphCacheProc
=
origPaint
.
getDrawCacheProc
(
)
;
SkAutoDescriptor
desc
;
origPaint
.
getScalerContextDescriptor
(
&
desc
fSurfaceProps
nullptr
true
)
;
SkGlyphCache
*
origPaintCache
=
SkGlyphCache
:
:
DetachCache
(
origPaint
.
getTypeface
(
)
desc
.
getDesc
(
)
)
;
SkTArray
<
SkScalar
>
positions
;
const
char
*
textPtr
=
text
;
SkFixed
stopX
=
0
;
SkFixed
stopY
=
0
;
SkFixed
origin
=
0
;
switch
(
origPaint
.
getTextAlign
(
)
)
{
case
SkPaint
:
:
kRight_Align
:
origin
=
SK_Fixed1
;
break
;
case
SkPaint
:
:
kCenter_Align
:
origin
=
SK_FixedHalf
;
break
;
case
SkPaint
:
:
kLeft_Align
:
origin
=
0
;
break
;
}
SkAutoKern
autokern
;
const
char
*
stop
=
text
+
byteLength
;
while
(
textPtr
<
stop
)
{
const
SkGlyph
&
glyph
=
glyphCacheProc
(
origPaintCache
&
textPtr
0
0
)
;
SkFixed
width
=
glyph
.
fAdvanceX
+
autokern
.
adjust
(
glyph
)
;
positions
.
push_back
(
SkFixedToScalar
(
stopX
+
SkFixedMul
(
origin
width
)
)
)
;
SkFixed
height
=
glyph
.
fAdvanceY
;
positions
.
push_back
(
SkFixedToScalar
(
stopY
+
SkFixedMul
(
origin
height
)
)
)
;
stopX
+
=
width
;
stopY
+
=
height
;
}
SkASSERT
(
textPtr
=
=
stop
)
;
SkGlyphCache
:
:
AttachCache
(
origPaintCache
)
;
SkScalar
alignX
=
SkFixedToScalar
(
stopX
)
;
SkScalar
alignY
=
SkFixedToScalar
(
stopY
)
;
if
(
origPaint
.
getTextAlign
(
)
=
=
SkPaint
:
:
kCenter_Align
)
{
alignX
=
SkScalarHalf
(
alignX
)
;
alignY
=
SkScalarHalf
(
alignY
)
;
}
else
if
(
origPaint
.
getTextAlign
(
)
=
=
SkPaint
:
:
kLeft_Align
)
{
alignX
=
0
;
alignY
=
0
;
}
x
-
=
alignX
;
y
-
=
alignY
;
*
offset
=
SkPoint
:
:
Make
(
x
y
)
;
this
-
>
internalDrawDFPosText
(
blob
runIndex
skPaint
color
viewMatrix
text
byteLength
positions
.
begin
(
)
2
*
offset
textRatio
fallbackTxt
fallbackPos
)
;
}
void
GrAtlasTextContext
:
:
internalDrawDFPosText
(
GrAtlasTextBlob
*
blob
int
runIndex
const
SkPaint
&
skPaint
GrColor
color
const
SkMatrix
&
viewMatrix
const
char
text
[
]
size_t
byteLength
const
SkScalar
pos
[
]
int
scalarsPerPosition
const
SkPoint
&
offset
SkScalar
textRatio
SkTDArray
<
char
>
*
fallbackTxt
SkTDArray
<
SkScalar
>
*
fallbackPos
)
{
SkASSERT
(
byteLength
=
=
0
|
|
text
!
=
nullptr
)
;
SkASSERT
(
1
=
=
scalarsPerPosition
|
|
2
=
=
scalarsPerPosition
)
;
if
(
text
=
=
nullptr
|
|
byteLength
=
=
0
)
{
return
;
}
fCurrStrike
=
nullptr
;
SkDrawCacheProc
glyphCacheProc
=
skPaint
.
getDrawCacheProc
(
)
;
SkGlyphCache
*
cache
=
this
-
>
setupCache
(
&
blob
-
>
fRuns
[
runIndex
]
skPaint
nullptr
true
)
;
GrFontScaler
*
fontScaler
=
GetGrFontScaler
(
cache
)
;
const
char
*
stop
=
text
+
byteLength
;
if
(
SkPaint
:
:
kLeft_Align
=
=
skPaint
.
getTextAlign
(
)
)
{
while
(
text
<
stop
)
{
const
char
*
lastText
=
text
;
const
SkGlyph
&
glyph
=
glyphCacheProc
(
cache
&
text
0
0
)
;
if
(
glyph
.
fWidth
)
{
SkScalar
x
=
offset
.
x
(
)
+
pos
[
0
]
;
SkScalar
y
=
offset
.
y
(
)
+
(
2
=
=
scalarsPerPosition
?
pos
[
1
]
:
0
)
;
if
(
!
this
-
>
dfAppendGlyph
(
blob
runIndex
glyph
x
y
color
fontScaler
textRatio
viewMatrix
)
)
{
fallbackTxt
-
>
append
(
SkToInt
(
text
-
lastText
)
lastText
)
;
*
fallbackPos
-
>
append
(
)
=
pos
[
0
]
;
if
(
2
=
=
scalarsPerPosition
)
{
*
fallbackPos
-
>
append
(
)
=
pos
[
1
]
;
}
}
}
pos
+
=
scalarsPerPosition
;
}
}
else
{
SkScalar
alignMul
=
SkPaint
:
:
kCenter_Align
=
=
skPaint
.
getTextAlign
(
)
?
SK_ScalarHalf
:
SK_Scalar1
;
while
(
text
<
stop
)
{
const
char
*
lastText
=
text
;
const
SkGlyph
&
glyph
=
glyphCacheProc
(
cache
&
text
0
0
)
;
if
(
glyph
.
fWidth
)
{
SkScalar
x
=
offset
.
x
(
)
+
pos
[
0
]
;
SkScalar
y
=
offset
.
y
(
)
+
(
2
=
=
scalarsPerPosition
?
pos
[
1
]
:
0
)
;
SkScalar
advanceX
=
SkFixedToScalar
(
glyph
.
fAdvanceX
)
*
alignMul
*
textRatio
;
SkScalar
advanceY
=
SkFixedToScalar
(
glyph
.
fAdvanceY
)
*
alignMul
*
textRatio
;
if
(
!
this
-
>
dfAppendGlyph
(
blob
runIndex
glyph
x
-
advanceX
y
-
advanceY
color
fontScaler
textRatio
viewMatrix
)
)
{
fallbackTxt
-
>
append
(
SkToInt
(
text
-
lastText
)
lastText
)
;
*
fallbackPos
-
>
append
(
)
=
pos
[
0
]
;
if
(
2
=
=
scalarsPerPosition
)
{
*
fallbackPos
-
>
append
(
)
=
pos
[
1
]
;
}
}
}
pos
+
=
scalarsPerPosition
;
}
}
SkGlyphCache
:
:
AttachCache
(
cache
)
;
}
void
GrAtlasTextContext
:
:
bmpAppendGlyph
(
GrAtlasTextBlob
*
blob
int
runIndex
const
SkGlyph
&
skGlyph
int
vx
int
vy
GrColor
color
GrFontScaler
*
scaler
)
{
Run
&
run
=
blob
-
>
fRuns
[
runIndex
]
;
if
(
!
fCurrStrike
)
{
fCurrStrike
=
fContext
-
>
getBatchFontCache
(
)
-
>
getStrike
(
scaler
)
;
}
GrGlyph
:
:
PackedID
id
=
GrGlyph
:
:
Pack
(
skGlyph
.
getGlyphID
(
)
skGlyph
.
getSubXFixed
(
)
skGlyph
.
getSubYFixed
(
)
GrGlyph
:
:
kCoverage_MaskStyle
)
;
GrGlyph
*
glyph
=
fCurrStrike
-
>
getGlyph
(
skGlyph
id
scaler
)
;
if
(
!
glyph
)
{
return
;
}
int
x
=
vx
+
glyph
-
>
fBounds
.
fLeft
;
int
y
=
vy
+
glyph
-
>
fBounds
.
fTop
;
int
width
=
glyph
-
>
fBounds
.
width
(
)
;
int
height
=
glyph
-
>
fBounds
.
height
(
)
;
if
(
glyph
-
>
fTooLargeForAtlas
)
{
this
-
>
appendGlyphPath
(
blob
glyph
scaler
skGlyph
SkIntToScalar
(
vx
)
SkIntToScalar
(
vy
)
)
;
return
;
}
GrMaskFormat
format
=
glyph
-
>
fMaskFormat
;
PerSubRunInfo
*
subRun
=
&
run
.
fSubRunInfo
.
back
(
)
;
if
(
run
.
fInitialized
&
&
subRun
-
>
fMaskFormat
!
=
format
)
{
subRun
=
&
run
.
push_back
(
)
;
subRun
-
>
fStrike
.
reset
(
SkRef
(
fCurrStrike
)
)
;
}
else
if
(
!
run
.
fInitialized
)
{
subRun
-
>
fStrike
.
reset
(
SkRef
(
fCurrStrike
)
)
;
}
run
.
fInitialized
=
true
;
size_t
vertexStride
=
GrAtlasTextBatch
:
:
GetVertexStride
(
format
)
;
SkRect
r
;
r
.
fLeft
=
SkIntToScalar
(
x
)
;
r
.
fTop
=
SkIntToScalar
(
y
)
;
r
.
fRight
=
r
.
fLeft
+
SkIntToScalar
(
width
)
;
r
.
fBottom
=
r
.
fTop
+
SkIntToScalar
(
height
)
;
subRun
-
>
fMaskFormat
=
format
;
this
-
>
appendGlyphCommon
(
blob
&
run
subRun
r
color
vertexStride
kA8_GrMaskFormat
=
=
format
glyph
)
;
}
bool
GrAtlasTextContext
:
:
dfAppendGlyph
(
GrAtlasTextBlob
*
blob
int
runIndex
const
SkGlyph
&
skGlyph
SkScalar
sx
SkScalar
sy
GrColor
color
GrFontScaler
*
scaler
SkScalar
textRatio
const
SkMatrix
&
viewMatrix
)
{
Run
&
run
=
blob
-
>
fRuns
[
runIndex
]
;
if
(
!
fCurrStrike
)
{
fCurrStrike
=
fContext
-
>
getBatchFontCache
(
)
-
>
getStrike
(
scaler
)
;
}
GrGlyph
:
:
PackedID
id
=
GrGlyph
:
:
Pack
(
skGlyph
.
getGlyphID
(
)
skGlyph
.
getSubXFixed
(
)
skGlyph
.
getSubYFixed
(
)
GrGlyph
:
:
kDistance_MaskStyle
)
;
GrGlyph
*
glyph
=
fCurrStrike
-
>
getGlyph
(
skGlyph
id
scaler
)
;
if
(
!
glyph
)
{
return
true
;
}
if
(
kA8_GrMaskFormat
!
=
glyph
-
>
fMaskFormat
)
{
return
false
;
}
SkScalar
dx
=
SkIntToScalar
(
glyph
-
>
fBounds
.
fLeft
+
SK_DistanceFieldInset
)
;
SkScalar
dy
=
SkIntToScalar
(
glyph
-
>
fBounds
.
fTop
+
SK_DistanceFieldInset
)
;
SkScalar
width
=
SkIntToScalar
(
glyph
-
>
fBounds
.
width
(
)
-
2
*
SK_DistanceFieldInset
)
;
SkScalar
height
=
SkIntToScalar
(
glyph
-
>
fBounds
.
height
(
)
-
2
*
SK_DistanceFieldInset
)
;
SkScalar
scale
=
textRatio
;
dx
*
=
scale
;
dy
*
=
scale
;
width
*
=
scale
;
height
*
=
scale
;
sx
+
=
dx
;
sy
+
=
dy
;
SkRect
glyphRect
=
SkRect
:
:
MakeXYWH
(
sx
sy
width
height
)
;
if
(
glyph
-
>
fTooLargeForAtlas
)
{
this
-
>
appendGlyphPath
(
blob
glyph
scaler
skGlyph
sx
-
dx
sy
-
dy
scale
true
)
;
return
true
;
}
PerSubRunInfo
*
subRun
=
&
run
.
fSubRunInfo
.
back
(
)
;
if
(
!
run
.
fInitialized
)
{
subRun
-
>
fStrike
.
reset
(
SkRef
(
fCurrStrike
)
)
;
}
run
.
fInitialized
=
true
;
SkASSERT
(
glyph
-
>
fMaskFormat
=
=
kA8_GrMaskFormat
)
;
subRun
-
>
fMaskFormat
=
kA8_GrMaskFormat
;
size_t
vertexStride
=
GrAtlasTextBatch
:
:
GetVertexStrideDf
(
kA8_GrMaskFormat
subRun
-
>
fUseLCDText
)
;
bool
useColorVerts
=
!
subRun
-
>
fUseLCDText
;
this
-
>
appendGlyphCommon
(
blob
&
run
subRun
glyphRect
color
vertexStride
useColorVerts
glyph
)
;
return
true
;
}
inline
void
GrAtlasTextContext
:
:
appendGlyphPath
(
GrAtlasTextBlob
*
blob
GrGlyph
*
glyph
GrFontScaler
*
scaler
const
SkGlyph
&
skGlyph
SkScalar
x
SkScalar
y
SkScalar
scale
bool
applyVM
)
{
if
(
nullptr
=
=
glyph
-
>
fPath
)
{
const
SkPath
*
glyphPath
=
scaler
-
>
getGlyphPath
(
skGlyph
)
;
if
(
!
glyphPath
)
{
return
;
}
glyph
-
>
fPath
=
new
SkPath
(
*
glyphPath
)
;
}
blob
-
>
fBigGlyphs
.
push_back
(
GrAtlasTextBlob
:
:
BigGlyph
(
*
glyph
-
>
fPath
x
y
scale
applyVM
)
)
;
}
inline
void
GrAtlasTextContext
:
:
appendGlyphCommon
(
GrAtlasTextBlob
*
blob
Run
*
run
Run
:
:
SubRunInfo
*
subRun
const
SkRect
&
positions
GrColor
color
size_t
vertexStride
bool
useVertexColor
GrGlyph
*
glyph
)
{
blob
-
>
fGlyphs
[
subRun
-
>
fGlyphEndIndex
]
=
glyph
;
run
-
>
fVertexBounds
.
joinNonEmptyArg
(
positions
)
;
run
-
>
fColor
=
color
;
intptr_t
vertex
=
reinterpret_cast
<
intptr_t
>
(
blob
-
>
fVertices
+
subRun
-
>
fVertexEndIndex
)
;
if
(
useVertexColor
)
{
SkPoint
*
position
=
reinterpret_cast
<
SkPoint
*
>
(
vertex
)
;
position
-
>
set
(
positions
.
fLeft
positions
.
fTop
)
;
SkColor
*
colorPtr
=
reinterpret_cast
<
SkColor
*
>
(
vertex
+
sizeof
(
SkPoint
)
)
;
*
colorPtr
=
color
;
vertex
+
=
vertexStride
;
position
=
reinterpret_cast
<
SkPoint
*
>
(
vertex
)
;
position
-
>
set
(
positions
.
fLeft
positions
.
fBottom
)
;
colorPtr
=
reinterpret_cast
<
SkColor
*
>
(
vertex
+
sizeof
(
SkPoint
)
)
;
*
colorPtr
=
color
;
vertex
+
=
vertexStride
;
position
=
reinterpret_cast
<
SkPoint
*
>
(
vertex
)
;
position
-
>
set
(
positions
.
fRight
positions
.
fBottom
)
;
colorPtr
=
reinterpret_cast
<
SkColor
*
>
(
vertex
+
sizeof
(
SkPoint
)
)
;
*
colorPtr
=
color
;
vertex
+
=
vertexStride
;
position
=
reinterpret_cast
<
SkPoint
*
>
(
vertex
)
;
position
-
>
set
(
positions
.
fRight
positions
.
fTop
)
;
colorPtr
=
reinterpret_cast
<
SkColor
*
>
(
vertex
+
sizeof
(
SkPoint
)
)
;
*
colorPtr
=
color
;
}
else
{
SkPoint
*
position
=
reinterpret_cast
<
SkPoint
*
>
(
vertex
)
;
position
-
>
set
(
positions
.
fLeft
positions
.
fTop
)
;
vertex
+
=
vertexStride
;
position
=
reinterpret_cast
<
SkPoint
*
>
(
vertex
)
;
position
-
>
set
(
positions
.
fLeft
positions
.
fBottom
)
;
vertex
+
=
vertexStride
;
position
=
reinterpret_cast
<
SkPoint
*
>
(
vertex
)
;
position
-
>
set
(
positions
.
fRight
positions
.
fBottom
)
;
vertex
+
=
vertexStride
;
position
=
reinterpret_cast
<
SkPoint
*
>
(
vertex
)
;
position
-
>
set
(
positions
.
fRight
positions
.
fTop
)
;
}
subRun
-
>
fGlyphEndIndex
+
+
;
subRun
-
>
fVertexEndIndex
+
=
vertexStride
*
GrAtlasTextBatch
:
:
kVerticesPerGlyph
;
}
void
GrAtlasTextContext
:
:
flushRunAsPaths
(
GrDrawContext
*
dc
const
SkTextBlobRunIterator
&
it
const
GrClip
&
clip
const
SkPaint
&
skPaint
SkDrawFilter
*
drawFilter
const
SkMatrix
&
viewMatrix
const
SkIRect
&
clipBounds
SkScalar
x
SkScalar
y
)
{
SkPaint
runPaint
=
skPaint
;
size_t
textLen
=
it
.
glyphCount
(
)
*
sizeof
(
uint16_t
)
;
const
SkPoint
&
offset
=
it
.
offset
(
)
;
it
.
applyFontToPaint
(
&
runPaint
)
;
if
(
drawFilter
&
&
!
drawFilter
-
>
filter
(
&
runPaint
SkDrawFilter
:
:
kText_Type
)
)
{
return
;
}
runPaint
.
setFlags
(
FilterTextFlags
(
fSurfaceProps
runPaint
)
)
;
switch
(
it
.
positioning
(
)
)
{
case
SkTextBlob
:
:
kDefault_Positioning
:
this
-
>
drawTextAsPath
(
dc
clip
runPaint
viewMatrix
(
const
char
*
)
it
.
glyphs
(
)
textLen
x
+
offset
.
x
(
)
y
+
offset
.
y
(
)
clipBounds
)
;
break
;
case
SkTextBlob
:
:
kHorizontal_Positioning
:
this
-
>
drawPosTextAsPath
(
dc
clip
runPaint
viewMatrix
(
const
char
*
)
it
.
glyphs
(
)
textLen
it
.
pos
(
)
1
SkPoint
:
:
Make
(
x
y
+
offset
.
y
(
)
)
clipBounds
)
;
break
;
case
SkTextBlob
:
:
kFull_Positioning
:
this
-
>
drawPosTextAsPath
(
dc
clip
runPaint
viewMatrix
(
const
char
*
)
it
.
glyphs
(
)
textLen
it
.
pos
(
)
2
SkPoint
:
:
Make
(
x
y
)
clipBounds
)
;
break
;
}
}
inline
GrDrawBatch
*
GrAtlasTextContext
:
:
createBatch
(
GrAtlasTextBlob
*
cacheBlob
const
PerSubRunInfo
&
info
int
glyphCount
int
run
int
subRun
GrColor
color
SkScalar
transX
SkScalar
transY
const
SkPaint
&
skPaint
)
{
GrMaskFormat
format
=
info
.
fMaskFormat
;
GrColor
subRunColor
;
if
(
kARGB_GrMaskFormat
=
=
format
)
{
uint8_t
paintAlpha
=
skPaint
.
getAlpha
(
)
;
subRunColor
=
SkColorSetARGB
(
paintAlpha
paintAlpha
paintAlpha
paintAlpha
)
;
}
else
{
subRunColor
=
color
;
}
GrAtlasTextBatch
*
batch
;
if
(
info
.
fDrawAsDistanceFields
)
{
SkColor
filteredColor
;
SkColorFilter
*
colorFilter
=
skPaint
.
getColorFilter
(
)
;
if
(
colorFilter
)
{
filteredColor
=
colorFilter
-
>
filterColor
(
skPaint
.
getColor
(
)
)
;
}
else
{
filteredColor
=
skPaint
.
getColor
(
)
;
}
bool
useBGR
=
SkPixelGeometryIsBGR
(
fSurfaceProps
.
pixelGeometry
(
)
)
;
batch
=
GrAtlasTextBatch
:
:
CreateDistanceField
(
glyphCount
fContext
-
>
getBatchFontCache
(
)
fDistanceAdjustTable
filteredColor
info
.
fUseLCDText
useBGR
)
;
}
else
{
batch
=
GrAtlasTextBatch
:
:
CreateBitmap
(
format
glyphCount
fContext
-
>
getBatchFontCache
(
)
)
;
}
GrAtlasTextBatch
:
:
Geometry
&
geometry
=
batch
-
>
geometry
(
)
;
geometry
.
fBlob
=
SkRef
(
cacheBlob
)
;
geometry
.
fRun
=
run
;
geometry
.
fSubRun
=
subRun
;
geometry
.
fColor
=
subRunColor
;
geometry
.
fTransX
=
transX
;
geometry
.
fTransY
=
transY
;
batch
-
>
init
(
)
;
return
batch
;
}
inline
void
GrAtlasTextContext
:
:
flushRun
(
GrDrawContext
*
dc
GrPipelineBuilder
*
pipelineBuilder
GrAtlasTextBlob
*
cacheBlob
int
run
GrColor
color
SkScalar
transX
SkScalar
transY
const
SkPaint
&
skPaint
)
{
for
(
int
subRun
=
0
;
subRun
<
cacheBlob
-
>
fRuns
[
run
]
.
fSubRunInfo
.
count
(
)
;
subRun
+
+
)
{
const
PerSubRunInfo
&
info
=
cacheBlob
-
>
fRuns
[
run
]
.
fSubRunInfo
[
subRun
]
;
int
glyphCount
=
info
.
fGlyphEndIndex
-
info
.
fGlyphStartIndex
;
if
(
0
=
=
glyphCount
)
{
continue
;
}
SkAutoTUnref
<
GrDrawBatch
>
batch
(
this
-
>
createBatch
(
cacheBlob
info
glyphCount
run
subRun
color
transX
transY
skPaint
)
)
;
dc
-
>
drawBatch
(
pipelineBuilder
batch
)
;
}
}
inline
void
GrAtlasTextContext
:
:
flushBigGlyphs
(
GrAtlasTextBlob
*
cacheBlob
GrDrawContext
*
dc
const
GrClip
&
clip
const
SkPaint
&
skPaint
SkScalar
transX
SkScalar
transY
const
SkIRect
&
clipBounds
)
{
if
(
!
cacheBlob
-
>
fBigGlyphs
.
count
(
)
)
{
return
;
}
for
(
int
i
=
0
;
i
<
cacheBlob
-
>
fBigGlyphs
.
count
(
)
;
i
+
+
)
{
GrAtlasTextBlob
:
:
BigGlyph
&
bigGlyph
=
cacheBlob
-
>
fBigGlyphs
[
i
]
;
bigGlyph
.
fVx
+
=
transX
;
bigGlyph
.
fVy
+
=
transY
;
SkMatrix
ctm
;
ctm
.
setScale
(
bigGlyph
.
fScale
bigGlyph
.
fScale
)
;
ctm
.
postTranslate
(
bigGlyph
.
fVx
bigGlyph
.
fVy
)
;
if
(
bigGlyph
.
fApplyVM
)
{
ctm
.
postConcat
(
cacheBlob
-
>
fViewMatrix
)
;
}
GrBlurUtils
:
:
drawPathWithMaskFilter
(
fContext
dc
clip
bigGlyph
.
fPath
skPaint
ctm
nullptr
clipBounds
false
)
;
}
}
void
GrAtlasTextContext
:
:
flush
(
const
SkTextBlob
*
blob
GrAtlasTextBlob
*
cacheBlob
GrDrawContext
*
dc
GrRenderTarget
*
rt
const
SkPaint
&
skPaint
const
GrPaint
&
grPaint
SkDrawFilter
*
drawFilter
const
GrClip
&
clip
const
SkMatrix
&
viewMatrix
const
SkIRect
&
clipBounds
SkScalar
x
SkScalar
y
SkScalar
transX
SkScalar
transY
)
{
GrPipelineBuilder
pipelineBuilder
(
grPaint
rt
clip
)
;
GrColor
color
=
grPaint
.
getColor
(
)
;
SkTextBlobRunIterator
it
(
blob
)
;
for
(
int
run
=
0
;
!
it
.
done
(
)
;
it
.
next
(
)
run
+
+
)
{
if
(
cacheBlob
-
>
fRuns
[
run
]
.
fDrawAsPaths
)
{
this
-
>
flushRunAsPaths
(
dc
it
clip
skPaint
drawFilter
viewMatrix
clipBounds
x
y
)
;
continue
;
}
cacheBlob
-
>
fRuns
[
run
]
.
fVertexBounds
.
offset
(
transX
transY
)
;
this
-
>
flushRun
(
dc
&
pipelineBuilder
cacheBlob
run
color
transX
transY
skPaint
)
;
}
this
-
>
flushBigGlyphs
(
cacheBlob
dc
clip
skPaint
transX
transY
clipBounds
)
;
}
void
GrAtlasTextContext
:
:
flush
(
GrAtlasTextBlob
*
cacheBlob
GrDrawContext
*
dc
GrRenderTarget
*
rt
const
SkPaint
&
skPaint
const
GrPaint
&
grPaint
const
GrClip
&
clip
const
SkIRect
&
clipBounds
)
{
GrPipelineBuilder
pipelineBuilder
(
grPaint
rt
clip
)
;
GrColor
color
=
grPaint
.
getColor
(
)
;
for
(
int
run
=
0
;
run
<
cacheBlob
-
>
fRunCount
;
run
+
+
)
{
this
-
>
flushRun
(
dc
&
pipelineBuilder
cacheBlob
run
color
0
0
skPaint
)
;
}
this
-
>
flushBigGlyphs
(
cacheBlob
dc
clip
skPaint
0
0
clipBounds
)
;
}
#
ifdef
GR_TEST_UTILS
DRAW_BATCH_TEST_DEFINE
(
TextBlobBatch
)
{
static
uint32_t
gContextID
=
SK_InvalidGenID
;
static
GrAtlasTextContext
*
gTextContext
=
nullptr
;
static
SkSurfaceProps
gSurfaceProps
(
SkSurfaceProps
:
:
kLegacyFontHost_InitType
)
;
if
(
context
-
>
uniqueID
(
)
!
=
gContextID
)
{
gContextID
=
context
-
>
uniqueID
(
)
;
delete
gTextContext
;
gTextContext
=
GrAtlasTextContext
:
:
Create
(
context
gSurfaceProps
)
;
}
GrColor
color
=
GrRandomColor
(
random
)
;
SkMatrix
viewMatrix
=
GrTest
:
:
TestMatrixInvertible
(
random
)
;
SkPaint
skPaint
;
skPaint
.
setColor
(
color
)
;
skPaint
.
setLCDRenderText
(
random
-
>
nextBool
(
)
)
;
skPaint
.
setAntiAlias
(
skPaint
.
isLCDRenderText
(
)
?
true
:
random
-
>
nextBool
(
)
)
;
skPaint
.
setSubpixelText
(
random
-
>
nextBool
(
)
)
;
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaint
(
context
skPaint
viewMatrix
&
grPaint
)
)
{
SkFAIL
(
"
couldn
'
t
convert
paint
\
n
"
)
;
}
const
char
*
text
=
"
The
quick
brown
fox
jumps
over
the
lazy
dog
.
"
;
int
textLen
=
(
int
)
strlen
(
text
)
;
GrClip
clip
;
SkIRect
noClip
=
SkIRect
:
:
MakeLargest
(
)
;
SkAutoTUnref
<
GrAtlasTextBlob
>
blob
(
gTextContext
-
>
createDrawTextBlob
(
clip
grPaint
skPaint
viewMatrix
text
static_cast
<
size_t
>
(
textLen
)
0
0
noClip
)
)
;
SkScalar
transX
=
static_cast
<
SkScalar
>
(
random
-
>
nextU
(
)
)
;
SkScalar
transY
=
static_cast
<
SkScalar
>
(
random
-
>
nextU
(
)
)
;
const
GrAtlasTextBlob
:
:
Run
:
:
SubRunInfo
&
info
=
blob
-
>
fRuns
[
0
]
.
fSubRunInfo
[
0
]
;
return
gTextContext
-
>
createBatch
(
blob
info
textLen
0
0
color
transX
transY
skPaint
)
;
}
#
endif
