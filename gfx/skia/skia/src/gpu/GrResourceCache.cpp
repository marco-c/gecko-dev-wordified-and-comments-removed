#
include
"
src
/
gpu
/
GrResourceCache
.
h
"
#
include
<
atomic
>
#
include
"
include
/
gpu
/
GrContext
.
h
"
#
include
"
include
/
gpu
/
GrTexture
.
h
"
#
include
"
include
/
private
/
GrSingleOwner
.
h
"
#
include
"
include
/
private
/
SkTo
.
h
"
#
include
"
include
/
utils
/
SkRandom
.
h
"
#
include
"
src
/
core
/
SkExchange
.
h
"
#
include
"
src
/
core
/
SkMessageBus
.
h
"
#
include
"
src
/
core
/
SkOpts
.
h
"
#
include
"
src
/
core
/
SkScopeExit
.
h
"
#
include
"
src
/
core
/
SkTSort
.
h
"
#
include
"
src
/
gpu
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
GrContextPriv
.
h
"
#
include
"
src
/
gpu
/
GrGpuResourceCacheAccess
.
h
"
#
include
"
src
/
gpu
/
GrProxyProvider
.
h
"
#
include
"
src
/
gpu
/
GrTextureProxyCacheAccess
.
h
"
#
include
"
src
/
gpu
/
GrTracing
.
h
"
#
include
"
src
/
gpu
/
SkGr
.
h
"
DECLARE_SKMESSAGEBUS_MESSAGE
(
GrUniqueKeyInvalidatedMessage
)
;
DECLARE_SKMESSAGEBUS_MESSAGE
(
GrTextureFreedMessage
)
;
#
define
ASSERT_SINGLE_OWNER
\
SkDEBUGCODE
(
GrSingleOwner
:
:
AutoEnforce
debug_SingleOwner
(
fSingleOwner
)
;
)
GrScratchKey
:
:
ResourceType
GrScratchKey
:
:
GenerateResourceType
(
)
{
static
std
:
:
atomic
<
int32_t
>
nextType
{
INHERITED
:
:
kInvalidDomain
+
1
}
;
int32_t
type
=
nextType
+
+
;
if
(
type
>
SkTo
<
int32_t
>
(
UINT16_MAX
)
)
{
SK_ABORT
(
"
Too
many
Resource
Types
"
)
;
}
return
static_cast
<
ResourceType
>
(
type
)
;
}
GrUniqueKey
:
:
Domain
GrUniqueKey
:
:
GenerateDomain
(
)
{
static
std
:
:
atomic
<
int32_t
>
nextDomain
{
INHERITED
:
:
kInvalidDomain
+
1
}
;
int32_t
domain
=
nextDomain
+
+
;
if
(
domain
>
SkTo
<
int32_t
>
(
UINT16_MAX
)
)
{
SK_ABORT
(
"
Too
many
GrUniqueKey
Domains
"
)
;
}
return
static_cast
<
Domain
>
(
domain
)
;
}
uint32_t
GrResourceKeyHash
(
const
uint32_t
*
data
size_t
size
)
{
return
SkOpts
:
:
hash
(
data
size
)
;
}
class
GrResourceCache
:
:
AutoValidate
:
:
:
SkNoncopyable
{
public
:
AutoValidate
(
GrResourceCache
*
cache
)
:
fCache
(
cache
)
{
cache
-
>
validate
(
)
;
}
~
AutoValidate
(
)
{
fCache
-
>
validate
(
)
;
}
private
:
GrResourceCache
*
fCache
;
}
;
inline
GrResourceCache
:
:
TextureAwaitingUnref
:
:
TextureAwaitingUnref
(
)
=
default
;
inline
GrResourceCache
:
:
TextureAwaitingUnref
:
:
TextureAwaitingUnref
(
GrTexture
*
texture
)
:
fTexture
(
texture
)
fNumUnrefs
(
1
)
{
}
inline
GrResourceCache
:
:
TextureAwaitingUnref
:
:
TextureAwaitingUnref
(
TextureAwaitingUnref
&
&
that
)
{
fTexture
=
skstd
:
:
exchange
(
that
.
fTexture
nullptr
)
;
fNumUnrefs
=
skstd
:
:
exchange
(
that
.
fNumUnrefs
0
)
;
}
inline
GrResourceCache
:
:
TextureAwaitingUnref
&
GrResourceCache
:
:
TextureAwaitingUnref
:
:
operator
=
(
TextureAwaitingUnref
&
&
that
)
{
fTexture
=
skstd
:
:
exchange
(
that
.
fTexture
nullptr
)
;
fNumUnrefs
=
skstd
:
:
exchange
(
that
.
fNumUnrefs
0
)
;
return
*
this
;
}
inline
GrResourceCache
:
:
TextureAwaitingUnref
:
:
~
TextureAwaitingUnref
(
)
{
if
(
fTexture
)
{
for
(
int
i
=
0
;
i
<
fNumUnrefs
;
+
+
i
)
{
fTexture
-
>
unref
(
)
;
}
}
}
inline
void
GrResourceCache
:
:
TextureAwaitingUnref
:
:
TextureAwaitingUnref
:
:
addRef
(
)
{
+
+
fNumUnrefs
;
}
inline
void
GrResourceCache
:
:
TextureAwaitingUnref
:
:
unref
(
)
{
SkASSERT
(
fNumUnrefs
>
0
)
;
fTexture
-
>
unref
(
)
;
-
-
fNumUnrefs
;
}
inline
bool
GrResourceCache
:
:
TextureAwaitingUnref
:
:
finished
(
)
{
return
!
fNumUnrefs
;
}
GrResourceCache
:
:
GrResourceCache
(
const
GrCaps
*
caps
GrSingleOwner
*
singleOwner
uint32_t
contextUniqueID
)
:
fInvalidUniqueKeyInbox
(
contextUniqueID
)
fFreedTextureInbox
(
contextUniqueID
)
fContextUniqueID
(
contextUniqueID
)
fSingleOwner
(
singleOwner
)
fPreferVRAMUseOverFlushes
(
caps
-
>
preferVRAMUseOverFlushes
(
)
)
{
SkASSERT
(
contextUniqueID
!
=
SK_InvalidUniqueID
)
;
}
GrResourceCache
:
:
~
GrResourceCache
(
)
{
this
-
>
releaseAll
(
)
;
}
void
GrResourceCache
:
:
setLimit
(
size_t
bytes
)
{
fMaxBytes
=
bytes
;
this
-
>
purgeAsNeeded
(
)
;
}
void
GrResourceCache
:
:
insertResource
(
GrGpuResource
*
resource
)
{
ASSERT_SINGLE_OWNER
SkASSERT
(
resource
)
;
SkASSERT
(
!
this
-
>
isInCache
(
resource
)
)
;
SkASSERT
(
!
resource
-
>
wasDestroyed
(
)
)
;
SkASSERT
(
!
resource
-
>
resourcePriv
(
)
.
isPurgeable
(
)
)
;
resource
-
>
cacheAccess
(
)
.
setTimestamp
(
this
-
>
getNextTimestamp
(
)
)
;
this
-
>
addToNonpurgeableArray
(
resource
)
;
size_t
size
=
resource
-
>
gpuMemorySize
(
)
;
SkDEBUGCODE
(
+
+
fCount
;
)
fBytes
+
=
size
;
#
if
GR_CACHE_STATS
fHighWaterCount
=
SkTMax
(
this
-
>
getResourceCount
(
)
fHighWaterCount
)
;
fHighWaterBytes
=
SkTMax
(
fBytes
fHighWaterBytes
)
;
#
endif
if
(
GrBudgetedType
:
:
kBudgeted
=
=
resource
-
>
resourcePriv
(
)
.
budgetedType
(
)
)
{
+
+
fBudgetedCount
;
fBudgetedBytes
+
=
size
;
TRACE_COUNTER2
(
"
skia
.
gpu
.
cache
"
"
skia
budget
"
"
used
"
fBudgetedBytes
"
free
"
fMaxBytes
-
fBudgetedBytes
)
;
#
if
GR_CACHE_STATS
fBudgetedHighWaterCount
=
SkTMax
(
fBudgetedCount
fBudgetedHighWaterCount
)
;
fBudgetedHighWaterBytes
=
SkTMax
(
fBudgetedBytes
fBudgetedHighWaterBytes
)
;
#
endif
}
if
(
resource
-
>
resourcePriv
(
)
.
getScratchKey
(
)
.
isValid
(
)
&
&
!
resource
-
>
getUniqueKey
(
)
.
isValid
(
)
)
{
SkASSERT
(
!
resource
-
>
resourcePriv
(
)
.
refsWrappedObjects
(
)
)
;
fScratchMap
.
insert
(
resource
-
>
resourcePriv
(
)
.
getScratchKey
(
)
resource
)
;
}
this
-
>
purgeAsNeeded
(
)
;
}
void
GrResourceCache
:
:
removeResource
(
GrGpuResource
*
resource
)
{
ASSERT_SINGLE_OWNER
this
-
>
validate
(
)
;
SkASSERT
(
this
-
>
isInCache
(
resource
)
)
;
size_t
size
=
resource
-
>
gpuMemorySize
(
)
;
if
(
resource
-
>
resourcePriv
(
)
.
isPurgeable
(
)
)
{
fPurgeableQueue
.
remove
(
resource
)
;
fPurgeableBytes
-
=
size
;
}
else
{
this
-
>
removeFromNonpurgeableArray
(
resource
)
;
}
SkDEBUGCODE
(
-
-
fCount
;
)
fBytes
-
=
size
;
if
(
GrBudgetedType
:
:
kBudgeted
=
=
resource
-
>
resourcePriv
(
)
.
budgetedType
(
)
)
{
-
-
fBudgetedCount
;
fBudgetedBytes
-
=
size
;
TRACE_COUNTER2
(
"
skia
.
gpu
.
cache
"
"
skia
budget
"
"
used
"
fBudgetedBytes
"
free
"
fMaxBytes
-
fBudgetedBytes
)
;
}
if
(
resource
-
>
resourcePriv
(
)
.
getScratchKey
(
)
.
isValid
(
)
&
&
!
resource
-
>
getUniqueKey
(
)
.
isValid
(
)
)
{
fScratchMap
.
remove
(
resource
-
>
resourcePriv
(
)
.
getScratchKey
(
)
resource
)
;
}
if
(
resource
-
>
getUniqueKey
(
)
.
isValid
(
)
)
{
fUniqueHash
.
remove
(
resource
-
>
getUniqueKey
(
)
)
;
}
this
-
>
validate
(
)
;
}
void
GrResourceCache
:
:
abandonAll
(
)
{
AutoValidate
av
(
this
)
;
fTexturesAwaitingUnref
.
reset
(
)
;
while
(
fNonpurgeableResources
.
count
(
)
)
{
GrGpuResource
*
back
=
*
(
fNonpurgeableResources
.
end
(
)
-
1
)
;
SkASSERT
(
!
back
-
>
wasDestroyed
(
)
)
;
back
-
>
cacheAccess
(
)
.
abandon
(
)
;
}
while
(
fPurgeableQueue
.
count
(
)
)
{
GrGpuResource
*
top
=
fPurgeableQueue
.
peek
(
)
;
SkASSERT
(
!
top
-
>
wasDestroyed
(
)
)
;
top
-
>
cacheAccess
(
)
.
abandon
(
)
;
}
SkASSERT
(
!
fScratchMap
.
count
(
)
)
;
SkASSERT
(
!
fUniqueHash
.
count
(
)
)
;
SkASSERT
(
!
fCount
)
;
SkASSERT
(
!
this
-
>
getResourceCount
(
)
)
;
SkASSERT
(
!
fBytes
)
;
SkASSERT
(
!
fBudgetedCount
)
;
SkASSERT
(
!
fBudgetedBytes
)
;
SkASSERT
(
!
fPurgeableBytes
)
;
SkASSERT
(
!
fTexturesAwaitingUnref
.
count
(
)
)
;
}
void
GrResourceCache
:
:
releaseAll
(
)
{
AutoValidate
av
(
this
)
;
this
-
>
processFreedGpuResources
(
)
;
fTexturesAwaitingUnref
.
reset
(
)
;
SkASSERT
(
fProxyProvider
)
;
fProxyProvider
-
>
removeAllUniqueKeys
(
)
;
while
(
fNonpurgeableResources
.
count
(
)
)
{
GrGpuResource
*
back
=
*
(
fNonpurgeableResources
.
end
(
)
-
1
)
;
SkASSERT
(
!
back
-
>
wasDestroyed
(
)
)
;
back
-
>
cacheAccess
(
)
.
release
(
)
;
}
while
(
fPurgeableQueue
.
count
(
)
)
{
GrGpuResource
*
top
=
fPurgeableQueue
.
peek
(
)
;
SkASSERT
(
!
top
-
>
wasDestroyed
(
)
)
;
top
-
>
cacheAccess
(
)
.
release
(
)
;
}
SkASSERT
(
!
fScratchMap
.
count
(
)
)
;
SkASSERT
(
!
fUniqueHash
.
count
(
)
)
;
SkASSERT
(
!
fCount
)
;
SkASSERT
(
!
this
-
>
getResourceCount
(
)
)
;
SkASSERT
(
!
fBytes
)
;
SkASSERT
(
!
fBudgetedCount
)
;
SkASSERT
(
!
fBudgetedBytes
)
;
SkASSERT
(
!
fPurgeableBytes
)
;
SkASSERT
(
!
fTexturesAwaitingUnref
.
count
(
)
)
;
}
void
GrResourceCache
:
:
refResource
(
GrGpuResource
*
resource
)
{
SkASSERT
(
resource
)
;
SkASSERT
(
resource
-
>
getContext
(
)
-
>
priv
(
)
.
getResourceCache
(
)
=
=
this
)
;
if
(
resource
-
>
cacheAccess
(
)
.
hasRef
(
)
)
{
resource
-
>
ref
(
)
;
}
else
{
this
-
>
refAndMakeResourceMRU
(
resource
)
;
}
this
-
>
validate
(
)
;
}
class
GrResourceCache
:
:
AvailableForScratchUse
{
public
:
AvailableForScratchUse
(
)
{
}
bool
operator
(
)
(
const
GrGpuResource
*
resource
)
const
{
SkASSERT
(
!
resource
-
>
getUniqueKey
(
)
.
isValid
(
)
&
&
resource
-
>
resourcePriv
(
)
.
getScratchKey
(
)
.
isValid
(
)
)
;
if
(
resource
-
>
internalHasRef
(
)
|
|
!
resource
-
>
cacheAccess
(
)
.
isScratch
(
)
)
{
return
false
;
}
return
true
;
}
}
;
GrGpuResource
*
GrResourceCache
:
:
findAndRefScratchResource
(
const
GrScratchKey
&
scratchKey
)
{
SkASSERT
(
scratchKey
.
isValid
(
)
)
;
GrGpuResource
*
resource
=
fScratchMap
.
find
(
scratchKey
AvailableForScratchUse
(
)
)
;
if
(
resource
)
{
this
-
>
refAndMakeResourceMRU
(
resource
)
;
this
-
>
validate
(
)
;
}
return
resource
;
}
void
GrResourceCache
:
:
willRemoveScratchKey
(
const
GrGpuResource
*
resource
)
{
ASSERT_SINGLE_OWNER
SkASSERT
(
resource
-
>
resourcePriv
(
)
.
getScratchKey
(
)
.
isValid
(
)
)
;
if
(
!
resource
-
>
getUniqueKey
(
)
.
isValid
(
)
)
{
fScratchMap
.
remove
(
resource
-
>
resourcePriv
(
)
.
getScratchKey
(
)
resource
)
;
}
}
void
GrResourceCache
:
:
removeUniqueKey
(
GrGpuResource
*
resource
)
{
ASSERT_SINGLE_OWNER
if
(
resource
-
>
getUniqueKey
(
)
.
isValid
(
)
)
{
SkASSERT
(
resource
=
=
fUniqueHash
.
find
(
resource
-
>
getUniqueKey
(
)
)
)
;
fUniqueHash
.
remove
(
resource
-
>
getUniqueKey
(
)
)
;
}
resource
-
>
cacheAccess
(
)
.
removeUniqueKey
(
)
;
if
(
resource
-
>
resourcePriv
(
)
.
getScratchKey
(
)
.
isValid
(
)
)
{
fScratchMap
.
insert
(
resource
-
>
resourcePriv
(
)
.
getScratchKey
(
)
resource
)
;
}
SkASSERT
(
!
resource
-
>
resourcePriv
(
)
.
isPurgeable
(
)
)
;
this
-
>
validate
(
)
;
}
void
GrResourceCache
:
:
changeUniqueKey
(
GrGpuResource
*
resource
const
GrUniqueKey
&
newKey
)
{
ASSERT_SINGLE_OWNER
SkASSERT
(
resource
)
;
SkASSERT
(
this
-
>
isInCache
(
resource
)
)
;
if
(
newKey
.
isValid
(
)
)
{
if
(
GrGpuResource
*
old
=
fUniqueHash
.
find
(
newKey
)
)
{
if
(
!
old
-
>
resourcePriv
(
)
.
getScratchKey
(
)
.
isValid
(
)
&
&
old
-
>
resourcePriv
(
)
.
isPurgeable
(
)
)
{
old
-
>
cacheAccess
(
)
.
release
(
)
;
}
else
{
this
-
>
removeUniqueKey
(
sk_ref_sp
(
old
)
.
get
(
)
)
;
}
}
SkASSERT
(
nullptr
=
=
fUniqueHash
.
find
(
newKey
)
)
;
if
(
resource
-
>
getUniqueKey
(
)
.
isValid
(
)
)
{
SkASSERT
(
resource
=
=
fUniqueHash
.
find
(
resource
-
>
getUniqueKey
(
)
)
)
;
fUniqueHash
.
remove
(
resource
-
>
getUniqueKey
(
)
)
;
SkASSERT
(
nullptr
=
=
fUniqueHash
.
find
(
resource
-
>
getUniqueKey
(
)
)
)
;
}
else
{
if
(
resource
-
>
resourcePriv
(
)
.
getScratchKey
(
)
.
isValid
(
)
)
{
fScratchMap
.
remove
(
resource
-
>
resourcePriv
(
)
.
getScratchKey
(
)
resource
)
;
}
}
resource
-
>
cacheAccess
(
)
.
setUniqueKey
(
newKey
)
;
fUniqueHash
.
add
(
resource
)
;
}
else
{
this
-
>
removeUniqueKey
(
resource
)
;
}
this
-
>
validate
(
)
;
}
void
GrResourceCache
:
:
refAndMakeResourceMRU
(
GrGpuResource
*
resource
)
{
ASSERT_SINGLE_OWNER
SkASSERT
(
resource
)
;
SkASSERT
(
this
-
>
isInCache
(
resource
)
)
;
if
(
resource
-
>
resourcePriv
(
)
.
isPurgeable
(
)
)
{
fPurgeableBytes
-
=
resource
-
>
gpuMemorySize
(
)
;
fPurgeableQueue
.
remove
(
resource
)
;
this
-
>
addToNonpurgeableArray
(
resource
)
;
}
else
if
(
!
resource
-
>
cacheAccess
(
)
.
hasRef
(
)
&
&
resource
-
>
resourcePriv
(
)
.
budgetedType
(
)
=
=
GrBudgetedType
:
:
kBudgeted
)
{
SkASSERT
(
fNumBudgetedResourcesFlushWillMakePurgeable
>
0
)
;
fNumBudgetedResourcesFlushWillMakePurgeable
-
-
;
}
resource
-
>
cacheAccess
(
)
.
ref
(
)
;
resource
-
>
cacheAccess
(
)
.
setTimestamp
(
this
-
>
getNextTimestamp
(
)
)
;
this
-
>
validate
(
)
;
}
void
GrResourceCache
:
:
notifyRefCntReachedZero
(
GrGpuResource
*
resource
)
{
ASSERT_SINGLE_OWNER
SkASSERT
(
resource
)
;
SkASSERT
(
!
resource
-
>
wasDestroyed
(
)
)
;
SkASSERT
(
this
-
>
isInCache
(
resource
)
)
;
SkASSERT
(
fNonpurgeableResources
[
*
resource
-
>
cacheAccess
(
)
.
accessCacheIndex
(
)
]
=
=
resource
)
;
#
ifdef
SK_DEBUG
if
(
resource
-
>
resourcePriv
(
)
.
isPurgeable
(
)
)
{
fNewlyPurgeableResourceForValidation
=
resource
;
}
#
endif
resource
-
>
cacheAccess
(
)
.
setTimestamp
(
this
-
>
getNextTimestamp
(
)
)
;
SkDEBUGCODE
(
fNewlyPurgeableResourceForValidation
=
nullptr
)
;
if
(
!
resource
-
>
resourcePriv
(
)
.
isPurgeable
(
)
&
&
resource
-
>
resourcePriv
(
)
.
budgetedType
(
)
=
=
GrBudgetedType
:
:
kBudgeted
)
{
+
+
fNumBudgetedResourcesFlushWillMakePurgeable
;
}
if
(
!
resource
-
>
resourcePriv
(
)
.
isPurgeable
(
)
)
{
this
-
>
validate
(
)
;
return
;
}
this
-
>
removeFromNonpurgeableArray
(
resource
)
;
fPurgeableQueue
.
insert
(
resource
)
;
resource
-
>
cacheAccess
(
)
.
setTimeWhenResourceBecomePurgeable
(
)
;
fPurgeableBytes
+
=
resource
-
>
gpuMemorySize
(
)
;
bool
hasUniqueKey
=
resource
-
>
getUniqueKey
(
)
.
isValid
(
)
;
GrBudgetedType
budgetedType
=
resource
-
>
resourcePriv
(
)
.
budgetedType
(
)
;
if
(
budgetedType
=
=
GrBudgetedType
:
:
kBudgeted
)
{
bool
hasKey
=
resource
-
>
resourcePriv
(
)
.
getScratchKey
(
)
.
isValid
(
)
|
|
hasUniqueKey
;
if
(
!
this
-
>
overBudget
(
)
&
&
hasKey
)
{
return
;
}
}
else
{
if
(
hasUniqueKey
&
&
budgetedType
=
=
GrBudgetedType
:
:
kUnbudgetedCacheable
)
{
return
;
}
if
(
!
resource
-
>
resourcePriv
(
)
.
refsWrappedObjects
(
)
&
&
resource
-
>
resourcePriv
(
)
.
getScratchKey
(
)
.
isValid
(
)
)
{
if
(
this
-
>
wouldFit
(
resource
-
>
gpuMemorySize
(
)
)
)
{
resource
-
>
resourcePriv
(
)
.
makeBudgeted
(
)
;
return
;
}
}
}
SkDEBUGCODE
(
int
beforeCount
=
this
-
>
getResourceCount
(
)
;
)
resource
-
>
cacheAccess
(
)
.
release
(
)
;
SkASSERT
(
this
-
>
getResourceCount
(
)
<
beforeCount
)
;
this
-
>
validate
(
)
;
}
void
GrResourceCache
:
:
didChangeBudgetStatus
(
GrGpuResource
*
resource
)
{
ASSERT_SINGLE_OWNER
SkASSERT
(
resource
)
;
SkASSERT
(
this
-
>
isInCache
(
resource
)
)
;
size_t
size
=
resource
-
>
gpuMemorySize
(
)
;
SkDEBUGCODE
(
bool
wasPurgeable
=
resource
-
>
resourcePriv
(
)
.
isPurgeable
(
)
)
;
if
(
resource
-
>
resourcePriv
(
)
.
budgetedType
(
)
=
=
GrBudgetedType
:
:
kBudgeted
)
{
+
+
fBudgetedCount
;
fBudgetedBytes
+
=
size
;
#
if
GR_CACHE_STATS
fBudgetedHighWaterBytes
=
SkTMax
(
fBudgetedBytes
fBudgetedHighWaterBytes
)
;
fBudgetedHighWaterCount
=
SkTMax
(
fBudgetedCount
fBudgetedHighWaterCount
)
;
#
endif
if
(
!
resource
-
>
resourcePriv
(
)
.
isPurgeable
(
)
&
&
!
resource
-
>
cacheAccess
(
)
.
hasRef
(
)
)
{
+
+
fNumBudgetedResourcesFlushWillMakePurgeable
;
}
this
-
>
purgeAsNeeded
(
)
;
}
else
{
SkASSERT
(
resource
-
>
resourcePriv
(
)
.
budgetedType
(
)
!
=
GrBudgetedType
:
:
kUnbudgetedCacheable
)
;
-
-
fBudgetedCount
;
fBudgetedBytes
-
=
size
;
if
(
!
resource
-
>
resourcePriv
(
)
.
isPurgeable
(
)
&
&
!
resource
-
>
cacheAccess
(
)
.
hasRef
(
)
)
{
-
-
fNumBudgetedResourcesFlushWillMakePurgeable
;
}
}
SkASSERT
(
wasPurgeable
=
=
resource
-
>
resourcePriv
(
)
.
isPurgeable
(
)
)
;
TRACE_COUNTER2
(
"
skia
.
gpu
.
cache
"
"
skia
budget
"
"
used
"
fBudgetedBytes
"
free
"
fMaxBytes
-
fBudgetedBytes
)
;
this
-
>
validate
(
)
;
}
void
GrResourceCache
:
:
purgeAsNeeded
(
)
{
SkTArray
<
GrUniqueKeyInvalidatedMessage
>
invalidKeyMsgs
;
fInvalidUniqueKeyInbox
.
poll
(
&
invalidKeyMsgs
)
;
if
(
invalidKeyMsgs
.
count
(
)
)
{
SkASSERT
(
fProxyProvider
)
;
for
(
int
i
=
0
;
i
<
invalidKeyMsgs
.
count
(
)
;
+
+
i
)
{
fProxyProvider
-
>
processInvalidUniqueKey
(
invalidKeyMsgs
[
i
]
.
key
(
)
nullptr
GrProxyProvider
:
:
InvalidateGPUResource
:
:
kYes
)
;
SkASSERT
(
!
this
-
>
findAndRefUniqueResource
(
invalidKeyMsgs
[
i
]
.
key
(
)
)
)
;
}
}
this
-
>
processFreedGpuResources
(
)
;
bool
stillOverbudget
=
this
-
>
overBudget
(
)
;
while
(
stillOverbudget
&
&
fPurgeableQueue
.
count
(
)
)
{
GrGpuResource
*
resource
=
fPurgeableQueue
.
peek
(
)
;
SkASSERT
(
resource
-
>
resourcePriv
(
)
.
isPurgeable
(
)
)
;
resource
-
>
cacheAccess
(
)
.
release
(
)
;
stillOverbudget
=
this
-
>
overBudget
(
)
;
}
this
-
>
validate
(
)
;
}
void
GrResourceCache
:
:
purgeUnlockedResources
(
bool
scratchResourcesOnly
)
{
if
(
!
scratchResourcesOnly
)
{
while
(
fPurgeableQueue
.
count
(
)
)
{
GrGpuResource
*
resource
=
fPurgeableQueue
.
peek
(
)
;
SkASSERT
(
resource
-
>
resourcePriv
(
)
.
isPurgeable
(
)
)
;
resource
-
>
cacheAccess
(
)
.
release
(
)
;
}
}
else
{
fPurgeableQueue
.
sort
(
)
;
SkTDArray
<
GrGpuResource
*
>
scratchResources
;
for
(
int
i
=
0
;
i
<
fPurgeableQueue
.
count
(
)
;
i
+
+
)
{
GrGpuResource
*
resource
=
fPurgeableQueue
.
at
(
i
)
;
SkASSERT
(
resource
-
>
resourcePriv
(
)
.
isPurgeable
(
)
)
;
if
(
!
resource
-
>
getUniqueKey
(
)
.
isValid
(
)
)
{
*
scratchResources
.
append
(
)
=
resource
;
}
}
for
(
int
i
=
0
;
i
<
scratchResources
.
count
(
)
;
i
+
+
)
{
scratchResources
.
getAt
(
i
)
-
>
cacheAccess
(
)
.
release
(
)
;
}
}
this
-
>
validate
(
)
;
}
void
GrResourceCache
:
:
purgeResourcesNotUsedSince
(
GrStdSteadyClock
:
:
time_point
purgeTime
)
{
while
(
fPurgeableQueue
.
count
(
)
)
{
const
GrStdSteadyClock
:
:
time_point
resourceTime
=
fPurgeableQueue
.
peek
(
)
-
>
cacheAccess
(
)
.
timeWhenResourceBecamePurgeable
(
)
;
if
(
resourceTime
>
=
purgeTime
)
{
break
;
}
GrGpuResource
*
resource
=
fPurgeableQueue
.
peek
(
)
;
SkASSERT
(
resource
-
>
resourcePriv
(
)
.
isPurgeable
(
)
)
;
resource
-
>
cacheAccess
(
)
.
release
(
)
;
}
}
void
GrResourceCache
:
:
purgeUnlockedResources
(
size_t
bytesToPurge
bool
preferScratchResources
)
{
const
size_t
tmpByteBudget
=
SkTMax
(
(
size_t
)
0
fBytes
-
bytesToPurge
)
;
bool
stillOverbudget
=
tmpByteBudget
<
fBytes
;
if
(
preferScratchResources
&
&
bytesToPurge
<
fPurgeableBytes
)
{
fPurgeableQueue
.
sort
(
)
;
SkTDArray
<
GrGpuResource
*
>
scratchResources
;
size_t
scratchByteCount
=
0
;
for
(
int
i
=
0
;
i
<
fPurgeableQueue
.
count
(
)
&
&
stillOverbudget
;
i
+
+
)
{
GrGpuResource
*
resource
=
fPurgeableQueue
.
at
(
i
)
;
SkASSERT
(
resource
-
>
resourcePriv
(
)
.
isPurgeable
(
)
)
;
if
(
!
resource
-
>
getUniqueKey
(
)
.
isValid
(
)
)
{
*
scratchResources
.
append
(
)
=
resource
;
scratchByteCount
+
=
resource
-
>
gpuMemorySize
(
)
;
stillOverbudget
=
tmpByteBudget
<
fBytes
-
scratchByteCount
;
}
}
for
(
int
i
=
0
;
i
<
scratchResources
.
count
(
)
;
i
+
+
)
{
scratchResources
.
getAt
(
i
)
-
>
cacheAccess
(
)
.
release
(
)
;
}
stillOverbudget
=
tmpByteBudget
<
fBytes
;
this
-
>
validate
(
)
;
}
if
(
stillOverbudget
)
{
const
size_t
cachedByteCount
=
fMaxBytes
;
fMaxBytes
=
tmpByteBudget
;
this
-
>
purgeAsNeeded
(
)
;
fMaxBytes
=
cachedByteCount
;
}
}
bool
GrResourceCache
:
:
requestsFlush
(
)
const
{
return
this
-
>
overBudget
(
)
&
&
!
fPurgeableQueue
.
count
(
)
&
&
fNumBudgetedResourcesFlushWillMakePurgeable
>
0
;
}
void
GrResourceCache
:
:
insertDelayedTextureUnref
(
GrTexture
*
texture
)
{
texture
-
>
ref
(
)
;
uint32_t
id
=
texture
-
>
uniqueID
(
)
.
asUInt
(
)
;
if
(
auto
*
data
=
fTexturesAwaitingUnref
.
find
(
id
)
)
{
data
-
>
addRef
(
)
;
}
else
{
fTexturesAwaitingUnref
.
set
(
id
{
texture
}
)
;
}
}
void
GrResourceCache
:
:
processFreedGpuResources
(
)
{
if
(
!
fTexturesAwaitingUnref
.
count
(
)
)
{
return
;
}
SkTArray
<
GrTextureFreedMessage
>
msgs
;
fFreedTextureInbox
.
poll
(
&
msgs
)
;
for
(
int
i
=
0
;
i
<
msgs
.
count
(
)
;
+
+
i
)
{
SkASSERT
(
msgs
[
i
]
.
fOwningUniqueID
=
=
fContextUniqueID
)
;
uint32_t
id
=
msgs
[
i
]
.
fTexture
-
>
uniqueID
(
)
.
asUInt
(
)
;
TextureAwaitingUnref
*
info
=
fTexturesAwaitingUnref
.
find
(
id
)
;
if
(
info
)
{
info
-
>
unref
(
)
;
if
(
info
-
>
finished
(
)
)
{
fTexturesAwaitingUnref
.
remove
(
id
)
;
}
}
}
}
void
GrResourceCache
:
:
addToNonpurgeableArray
(
GrGpuResource
*
resource
)
{
int
index
=
fNonpurgeableResources
.
count
(
)
;
*
fNonpurgeableResources
.
append
(
)
=
resource
;
*
resource
-
>
cacheAccess
(
)
.
accessCacheIndex
(
)
=
index
;
}
void
GrResourceCache
:
:
removeFromNonpurgeableArray
(
GrGpuResource
*
resource
)
{
int
*
index
=
resource
-
>
cacheAccess
(
)
.
accessCacheIndex
(
)
;
GrGpuResource
*
tail
=
*
(
fNonpurgeableResources
.
end
(
)
-
1
)
;
SkASSERT
(
fNonpurgeableResources
[
*
index
]
=
=
resource
)
;
fNonpurgeableResources
[
*
index
]
=
tail
;
*
tail
-
>
cacheAccess
(
)
.
accessCacheIndex
(
)
=
*
index
;
fNonpurgeableResources
.
pop
(
)
;
SkDEBUGCODE
(
*
index
=
-
1
)
;
}
uint32_t
GrResourceCache
:
:
getNextTimestamp
(
)
{
if
(
0
=
=
fTimestamp
)
{
int
count
=
this
-
>
getResourceCount
(
)
;
if
(
count
)
{
SkTDArray
<
GrGpuResource
*
>
sortedPurgeableResources
;
sortedPurgeableResources
.
setReserve
(
fPurgeableQueue
.
count
(
)
)
;
while
(
fPurgeableQueue
.
count
(
)
)
{
*
sortedPurgeableResources
.
append
(
)
=
fPurgeableQueue
.
peek
(
)
;
fPurgeableQueue
.
pop
(
)
;
}
SkTQSort
(
fNonpurgeableResources
.
begin
(
)
fNonpurgeableResources
.
end
(
)
-
1
CompareTimestamp
)
;
int
currP
=
0
;
int
currNP
=
0
;
while
(
currP
<
sortedPurgeableResources
.
count
(
)
&
&
currNP
<
fNonpurgeableResources
.
count
(
)
)
{
uint32_t
tsP
=
sortedPurgeableResources
[
currP
]
-
>
cacheAccess
(
)
.
timestamp
(
)
;
uint32_t
tsNP
=
fNonpurgeableResources
[
currNP
]
-
>
cacheAccess
(
)
.
timestamp
(
)
;
SkASSERT
(
tsP
!
=
tsNP
)
;
if
(
tsP
<
tsNP
)
{
sortedPurgeableResources
[
currP
+
+
]
-
>
cacheAccess
(
)
.
setTimestamp
(
fTimestamp
+
+
)
;
}
else
{
*
fNonpurgeableResources
[
currNP
]
-
>
cacheAccess
(
)
.
accessCacheIndex
(
)
=
currNP
;
fNonpurgeableResources
[
currNP
+
+
]
-
>
cacheAccess
(
)
.
setTimestamp
(
fTimestamp
+
+
)
;
}
}
while
(
currP
<
sortedPurgeableResources
.
count
(
)
)
{
sortedPurgeableResources
[
currP
+
+
]
-
>
cacheAccess
(
)
.
setTimestamp
(
fTimestamp
+
+
)
;
}
while
(
currNP
<
fNonpurgeableResources
.
count
(
)
)
{
*
fNonpurgeableResources
[
currNP
]
-
>
cacheAccess
(
)
.
accessCacheIndex
(
)
=
currNP
;
fNonpurgeableResources
[
currNP
+
+
]
-
>
cacheAccess
(
)
.
setTimestamp
(
fTimestamp
+
+
)
;
}
for
(
int
i
=
0
;
i
<
sortedPurgeableResources
.
count
(
)
;
+
+
i
)
{
fPurgeableQueue
.
insert
(
sortedPurgeableResources
[
i
]
)
;
}
this
-
>
validate
(
)
;
SkASSERT
(
count
=
=
this
-
>
getResourceCount
(
)
)
;
SkASSERT
(
fTimestamp
=
=
SkToU32
(
count
)
)
;
}
}
return
fTimestamp
+
+
;
}
void
GrResourceCache
:
:
dumpMemoryStatistics
(
SkTraceMemoryDump
*
traceMemoryDump
)
const
{
for
(
int
i
=
0
;
i
<
fNonpurgeableResources
.
count
(
)
;
+
+
i
)
{
fNonpurgeableResources
[
i
]
-
>
dumpMemoryStatistics
(
traceMemoryDump
)
;
}
for
(
int
i
=
0
;
i
<
fPurgeableQueue
.
count
(
)
;
+
+
i
)
{
fPurgeableQueue
.
at
(
i
)
-
>
dumpMemoryStatistics
(
traceMemoryDump
)
;
}
}
#
if
GR_CACHE_STATS
void
GrResourceCache
:
:
getStats
(
Stats
*
stats
)
const
{
stats
-
>
reset
(
)
;
stats
-
>
fTotal
=
this
-
>
getResourceCount
(
)
;
stats
-
>
fNumNonPurgeable
=
fNonpurgeableResources
.
count
(
)
;
stats
-
>
fNumPurgeable
=
fPurgeableQueue
.
count
(
)
;
for
(
int
i
=
0
;
i
<
fNonpurgeableResources
.
count
(
)
;
+
+
i
)
{
stats
-
>
update
(
fNonpurgeableResources
[
i
]
)
;
}
for
(
int
i
=
0
;
i
<
fPurgeableQueue
.
count
(
)
;
+
+
i
)
{
stats
-
>
update
(
fPurgeableQueue
.
at
(
i
)
)
;
}
}
#
if
GR_TEST_UTILS
void
GrResourceCache
:
:
dumpStats
(
SkString
*
out
)
const
{
this
-
>
validate
(
)
;
Stats
stats
;
this
-
>
getStats
(
&
stats
)
;
float
byteUtilization
=
(
100
.
f
*
fBudgetedBytes
)
/
fMaxBytes
;
out
-
>
appendf
(
"
Budget
:
%
d
bytes
\
n
"
(
int
)
fMaxBytes
)
;
out
-
>
appendf
(
"
\
t
\
tEntry
Count
:
current
%
d
"
"
(
%
d
budgeted
%
d
wrapped
%
d
locked
%
d
scratch
)
high
%
d
\
n
"
stats
.
fTotal
fBudgetedCount
stats
.
fWrapped
stats
.
fNumNonPurgeable
stats
.
fScratch
fHighWaterCount
)
;
out
-
>
appendf
(
"
\
t
\
tEntry
Bytes
:
current
%
d
(
budgeted
%
d
%
.
2g
%
%
full
%
d
unbudgeted
)
high
%
d
\
n
"
SkToInt
(
fBytes
)
SkToInt
(
fBudgetedBytes
)
byteUtilization
SkToInt
(
stats
.
fUnbudgetedSize
)
SkToInt
(
fHighWaterBytes
)
)
;
}
void
GrResourceCache
:
:
dumpStatsKeyValuePairs
(
SkTArray
<
SkString
>
*
keys
SkTArray
<
double
>
*
values
)
const
{
this
-
>
validate
(
)
;
Stats
stats
;
this
-
>
getStats
(
&
stats
)
;
keys
-
>
push_back
(
SkString
(
"
gpu_cache_purgable_entries
"
)
)
;
values
-
>
push_back
(
stats
.
fNumPurgeable
)
;
}
#
endif
#
endif
#
ifdef
SK_DEBUG
void
GrResourceCache
:
:
validate
(
)
const
{
static
SkRandom
gRandom
;
int
mask
=
(
SkNextPow2
(
fCount
+
1
)
>
>
5
)
-
1
;
if
(
~
mask
&
&
(
gRandom
.
nextU
(
)
&
mask
)
)
{
return
;
}
struct
Stats
{
size_t
fBytes
;
int
fBudgetedCount
;
size_t
fBudgetedBytes
;
int
fLocked
;
int
fScratch
;
int
fCouldBeScratch
;
int
fContent
;
const
ScratchMap
*
fScratchMap
;
const
UniqueHash
*
fUniqueHash
;
Stats
(
const
GrResourceCache
*
cache
)
{
memset
(
this
0
sizeof
(
*
this
)
)
;
fScratchMap
=
&
cache
-
>
fScratchMap
;
fUniqueHash
=
&
cache
-
>
fUniqueHash
;
}
void
update
(
GrGpuResource
*
resource
)
{
fBytes
+
=
resource
-
>
gpuMemorySize
(
)
;
if
(
!
resource
-
>
resourcePriv
(
)
.
isPurgeable
(
)
)
{
+
+
fLocked
;
}
const
GrScratchKey
&
scratchKey
=
resource
-
>
resourcePriv
(
)
.
getScratchKey
(
)
;
const
GrUniqueKey
&
uniqueKey
=
resource
-
>
getUniqueKey
(
)
;
if
(
resource
-
>
cacheAccess
(
)
.
isScratch
(
)
)
{
SkASSERT
(
!
uniqueKey
.
isValid
(
)
)
;
+
+
fScratch
;
SkASSERT
(
fScratchMap
-
>
countForKey
(
scratchKey
)
)
;
SkASSERT
(
!
resource
-
>
resourcePriv
(
)
.
refsWrappedObjects
(
)
)
;
}
else
if
(
scratchKey
.
isValid
(
)
)
{
SkASSERT
(
GrBudgetedType
:
:
kBudgeted
!
=
resource
-
>
resourcePriv
(
)
.
budgetedType
(
)
|
|
uniqueKey
.
isValid
(
)
)
;
if
(
!
uniqueKey
.
isValid
(
)
)
{
+
+
fCouldBeScratch
;
SkASSERT
(
fScratchMap
-
>
countForKey
(
scratchKey
)
)
;
}
SkASSERT
(
!
resource
-
>
resourcePriv
(
)
.
refsWrappedObjects
(
)
)
;
}
if
(
uniqueKey
.
isValid
(
)
)
{
+
+
fContent
;
SkASSERT
(
fUniqueHash
-
>
find
(
uniqueKey
)
=
=
resource
)
;
SkASSERT
(
GrBudgetedType
:
:
kBudgeted
=
=
resource
-
>
resourcePriv
(
)
.
budgetedType
(
)
|
|
resource
-
>
resourcePriv
(
)
.
refsWrappedObjects
(
)
)
;
if
(
scratchKey
.
isValid
(
)
)
{
SkASSERT
(
!
fScratchMap
-
>
has
(
resource
scratchKey
)
)
;
}
}
if
(
GrBudgetedType
:
:
kBudgeted
=
=
resource
-
>
resourcePriv
(
)
.
budgetedType
(
)
)
{
+
+
fBudgetedCount
;
fBudgetedBytes
+
=
resource
-
>
gpuMemorySize
(
)
;
}
}
}
;
{
ScratchMap
:
:
ConstIter
iter
(
&
fScratchMap
)
;
int
count
=
0
;
for
(
;
!
iter
.
done
(
)
;
+
+
iter
)
{
const
GrGpuResource
*
resource
=
*
iter
;
SkASSERT
(
resource
-
>
resourcePriv
(
)
.
getScratchKey
(
)
.
isValid
(
)
)
;
SkASSERT
(
!
resource
-
>
getUniqueKey
(
)
.
isValid
(
)
)
;
count
+
+
;
}
SkASSERT
(
count
=
=
fScratchMap
.
count
(
)
)
;
}
Stats
stats
(
this
)
;
size_t
purgeableBytes
=
0
;
int
numBudgetedResourcesFlushWillMakePurgeable
=
0
;
for
(
int
i
=
0
;
i
<
fNonpurgeableResources
.
count
(
)
;
+
+
i
)
{
SkASSERT
(
!
fNonpurgeableResources
[
i
]
-
>
resourcePriv
(
)
.
isPurgeable
(
)
|
|
fNewlyPurgeableResourceForValidation
=
=
fNonpurgeableResources
[
i
]
)
;
SkASSERT
(
*
fNonpurgeableResources
[
i
]
-
>
cacheAccess
(
)
.
accessCacheIndex
(
)
=
=
i
)
;
SkASSERT
(
!
fNonpurgeableResources
[
i
]
-
>
wasDestroyed
(
)
)
;
if
(
fNonpurgeableResources
[
i
]
-
>
resourcePriv
(
)
.
budgetedType
(
)
=
=
GrBudgetedType
:
:
kBudgeted
&
&
!
fNonpurgeableResources
[
i
]
-
>
cacheAccess
(
)
.
hasRef
(
)
&
&
fNewlyPurgeableResourceForValidation
!
=
fNonpurgeableResources
[
i
]
)
{
+
+
numBudgetedResourcesFlushWillMakePurgeable
;
}
stats
.
update
(
fNonpurgeableResources
[
i
]
)
;
}
for
(
int
i
=
0
;
i
<
fPurgeableQueue
.
count
(
)
;
+
+
i
)
{
SkASSERT
(
fPurgeableQueue
.
at
(
i
)
-
>
resourcePriv
(
)
.
isPurgeable
(
)
)
;
SkASSERT
(
*
fPurgeableQueue
.
at
(
i
)
-
>
cacheAccess
(
)
.
accessCacheIndex
(
)
=
=
i
)
;
SkASSERT
(
!
fPurgeableQueue
.
at
(
i
)
-
>
wasDestroyed
(
)
)
;
stats
.
update
(
fPurgeableQueue
.
at
(
i
)
)
;
purgeableBytes
+
=
fPurgeableQueue
.
at
(
i
)
-
>
gpuMemorySize
(
)
;
}
SkASSERT
(
fCount
=
=
this
-
>
getResourceCount
(
)
)
;
SkASSERT
(
fBudgetedCount
<
=
fCount
)
;
SkASSERT
(
fBudgetedBytes
<
=
fBytes
)
;
SkASSERT
(
stats
.
fBytes
=
=
fBytes
)
;
SkASSERT
(
fNumBudgetedResourcesFlushWillMakePurgeable
=
=
numBudgetedResourcesFlushWillMakePurgeable
)
;
SkASSERT
(
stats
.
fBudgetedBytes
=
=
fBudgetedBytes
)
;
SkASSERT
(
stats
.
fBudgetedCount
=
=
fBudgetedCount
)
;
SkASSERT
(
purgeableBytes
=
=
fPurgeableBytes
)
;
#
if
GR_CACHE_STATS
SkASSERT
(
fBudgetedHighWaterCount
<
=
fHighWaterCount
)
;
SkASSERT
(
fBudgetedHighWaterBytes
<
=
fHighWaterBytes
)
;
SkASSERT
(
fBytes
<
=
fHighWaterBytes
)
;
SkASSERT
(
fCount
<
=
fHighWaterCount
)
;
SkASSERT
(
fBudgetedBytes
<
=
fBudgetedHighWaterBytes
)
;
SkASSERT
(
fBudgetedCount
<
=
fBudgetedHighWaterCount
)
;
#
endif
SkASSERT
(
stats
.
fContent
=
=
fUniqueHash
.
count
(
)
)
;
SkASSERT
(
stats
.
fScratch
+
stats
.
fCouldBeScratch
=
=
fScratchMap
.
count
(
)
)
;
}
bool
GrResourceCache
:
:
isInCache
(
const
GrGpuResource
*
resource
)
const
{
int
index
=
*
resource
-
>
cacheAccess
(
)
.
accessCacheIndex
(
)
;
if
(
index
<
0
)
{
return
false
;
}
if
(
index
<
fPurgeableQueue
.
count
(
)
&
&
fPurgeableQueue
.
at
(
index
)
=
=
resource
)
{
return
true
;
}
if
(
index
<
fNonpurgeableResources
.
count
(
)
&
&
fNonpurgeableResources
[
index
]
=
=
resource
)
{
return
true
;
}
SkDEBUGFAIL
(
"
Resource
index
should
be
-
1
or
the
resource
should
be
in
the
cache
.
"
)
;
return
false
;
}
#
endif
