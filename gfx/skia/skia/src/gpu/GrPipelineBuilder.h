#
ifndef
GrPipelineBuilder_DEFINED
#
define
GrPipelineBuilder_DEFINED
#
include
"
GrBlend
.
h
"
#
include
"
GrCaps
.
h
"
#
include
"
GrClip
.
h
"
#
include
"
GrGpuResourceRef
.
h
"
#
include
"
GrProcOptInfo
.
h
"
#
include
"
GrRenderTarget
.
h
"
#
include
"
GrStencil
.
h
"
#
include
"
GrXferProcessor
.
h
"
#
include
"
SkMatrix
.
h
"
#
include
"
effects
/
GrCoverageSetOpXP
.
h
"
#
include
"
effects
/
GrDisableColorXP
.
h
"
#
include
"
effects
/
GrPorterDuffXferProcessor
.
h
"
#
include
"
effects
/
GrSimpleTextureEffect
.
h
"
class
GrDrawBatch
;
class
GrCaps
;
class
GrPaint
;
class
GrTexture
;
class
GrPipelineBuilder
:
public
SkNoncopyable
{
public
:
GrPipelineBuilder
(
)
;
GrPipelineBuilder
(
const
GrPaint
&
GrRenderTarget
*
const
GrClip
&
)
;
virtual
~
GrPipelineBuilder
(
)
;
int
numColorFragmentProcessors
(
)
const
{
return
fColorFragmentProcessors
.
count
(
)
;
}
int
numCoverageFragmentProcessors
(
)
const
{
return
fCoverageFragmentProcessors
.
count
(
)
;
}
int
numFragmentProcessors
(
)
const
{
return
this
-
>
numColorFragmentProcessors
(
)
+
this
-
>
numCoverageFragmentProcessors
(
)
;
}
const
GrFragmentProcessor
*
getColorFragmentProcessor
(
int
idx
)
const
{
return
fColorFragmentProcessors
[
idx
]
;
}
const
GrFragmentProcessor
*
getCoverageFragmentProcessor
(
int
idx
)
const
{
return
fCoverageFragmentProcessors
[
idx
]
;
}
const
GrFragmentProcessor
*
addColorFragmentProcessor
(
const
GrFragmentProcessor
*
processor
)
{
SkASSERT
(
processor
)
;
fColorFragmentProcessors
.
push_back
(
SkRef
(
processor
)
)
;
return
processor
;
}
const
GrFragmentProcessor
*
addCoverageFragmentProcessor
(
const
GrFragmentProcessor
*
processor
)
{
SkASSERT
(
processor
)
;
fCoverageFragmentProcessors
.
push_back
(
SkRef
(
processor
)
)
;
return
processor
;
}
void
addColorTextureProcessor
(
GrTexture
*
texture
const
SkMatrix
&
matrix
)
{
this
-
>
addColorFragmentProcessor
(
GrSimpleTextureEffect
:
:
Create
(
texture
matrix
)
)
-
>
unref
(
)
;
}
void
addCoverageTextureProcessor
(
GrTexture
*
texture
const
SkMatrix
&
matrix
)
{
this
-
>
addCoverageFragmentProcessor
(
GrSimpleTextureEffect
:
:
Create
(
texture
matrix
)
)
-
>
unref
(
)
;
}
void
addColorTextureProcessor
(
GrTexture
*
texture
const
SkMatrix
&
matrix
const
GrTextureParams
&
params
)
{
this
-
>
addColorFragmentProcessor
(
GrSimpleTextureEffect
:
:
Create
(
texture
matrix
params
)
)
-
>
unref
(
)
;
}
void
addCoverageTextureProcessor
(
GrTexture
*
texture
const
SkMatrix
&
matrix
const
GrTextureParams
&
params
)
{
this
-
>
addCoverageFragmentProcessor
(
GrSimpleTextureEffect
:
:
Create
(
texture
matrix
params
)
)
-
>
unref
(
)
;
}
class
AutoRestoreFragmentProcessorState
:
public
:
:
SkNoncopyable
{
public
:
AutoRestoreFragmentProcessorState
(
)
:
fPipelineBuilder
(
nullptr
)
fColorEffectCnt
(
0
)
fCoverageEffectCnt
(
0
)
{
}
AutoRestoreFragmentProcessorState
(
const
GrPipelineBuilder
&
ds
)
:
fPipelineBuilder
(
nullptr
)
fColorEffectCnt
(
0
)
fCoverageEffectCnt
(
0
)
{
this
-
>
set
(
&
ds
)
;
}
~
AutoRestoreFragmentProcessorState
(
)
{
this
-
>
set
(
nullptr
)
;
}
void
set
(
const
GrPipelineBuilder
*
ds
)
;
bool
isSet
(
)
const
{
return
SkToBool
(
fPipelineBuilder
)
;
}
const
GrFragmentProcessor
*
addCoverageFragmentProcessor
(
const
GrFragmentProcessor
*
processor
)
{
SkASSERT
(
this
-
>
isSet
(
)
)
;
return
fPipelineBuilder
-
>
addCoverageFragmentProcessor
(
processor
)
;
}
private
:
GrPipelineBuilder
*
fPipelineBuilder
;
int
fColorEffectCnt
;
int
fCoverageEffectCnt
;
}
;
const
GrXPFactory
*
setXPFactory
(
const
GrXPFactory
*
xpFactory
)
{
fXPFactory
.
reset
(
SkSafeRef
(
xpFactory
)
)
;
return
xpFactory
;
}
void
setDisableColorXPFactory
(
)
{
fXPFactory
.
reset
(
GrDisableColorXPFactory
:
:
Create
(
)
)
;
}
const
GrXPFactory
*
getXPFactory
(
)
const
{
return
fXPFactory
;
}
bool
willXPNeedDstTexture
(
const
GrCaps
&
caps
const
GrPipelineOptimizations
&
optimizations
)
const
;
GrRenderTarget
*
getRenderTarget
(
)
const
{
return
fRenderTarget
.
get
(
)
;
}
void
setRenderTarget
(
GrRenderTarget
*
target
)
{
fRenderTarget
.
reset
(
SkSafeRef
(
target
)
)
;
}
bool
hasMixedSamples
(
)
const
{
return
fRenderTarget
-
>
hasMixedSamples
(
)
&
&
(
this
-
>
isHWAntialias
(
)
|
|
!
fStencilSettings
.
isDisabled
(
)
)
;
}
const
GrStencilSettings
&
getStencil
(
)
const
{
return
fStencilSettings
;
}
void
setStencil
(
const
GrStencilSettings
&
settings
)
{
fStencilSettings
=
settings
;
}
GrStencilSettings
*
stencil
(
)
{
return
&
fStencilSettings
;
}
class
AutoRestoreStencil
:
public
:
:
SkNoncopyable
{
public
:
AutoRestoreStencil
(
)
:
fPipelineBuilder
(
nullptr
)
{
}
AutoRestoreStencil
(
const
GrPipelineBuilder
&
ds
)
:
fPipelineBuilder
(
nullptr
)
{
this
-
>
set
(
&
ds
)
;
}
~
AutoRestoreStencil
(
)
{
this
-
>
set
(
nullptr
)
;
}
void
set
(
const
GrPipelineBuilder
*
ds
)
{
if
(
fPipelineBuilder
)
{
fPipelineBuilder
-
>
setStencil
(
fStencilSettings
)
;
}
fPipelineBuilder
=
const_cast
<
GrPipelineBuilder
*
>
(
ds
)
;
if
(
ds
)
{
fStencilSettings
=
ds
-
>
getStencil
(
)
;
}
}
bool
isSet
(
)
const
{
return
SkToBool
(
fPipelineBuilder
)
;
}
void
setStencil
(
const
GrStencilSettings
&
settings
)
{
SkASSERT
(
this
-
>
isSet
(
)
)
;
fPipelineBuilder
-
>
setStencil
(
settings
)
;
}
private
:
GrPipelineBuilder
*
fPipelineBuilder
;
GrStencilSettings
fStencilSettings
;
}
;
enum
Flags
{
kHWAntialias_Flag
=
0x01
kSnapVerticesToPixelCenters_Flag
=
0x02
kDisableOutputConversionToSRGB_Flag
=
0x04
kAllowSRGBInputs_Flag
=
0x08
kLast_Flag
=
kAllowSRGBInputs_Flag
}
;
bool
isHWAntialias
(
)
const
{
return
SkToBool
(
fFlags
&
kHWAntialias_Flag
)
;
}
bool
snapVerticesToPixelCenters
(
)
const
{
return
SkToBool
(
fFlags
&
kSnapVerticesToPixelCenters_Flag
)
;
}
bool
getDisableOutputConversionToSRGB
(
)
const
{
return
SkToBool
(
fFlags
&
kDisableOutputConversionToSRGB_Flag
)
;
}
bool
getAllowSRGBInputs
(
)
const
{
return
SkToBool
(
fFlags
&
kAllowSRGBInputs_Flag
)
;
}
void
enableState
(
uint32_t
flags
)
{
fFlags
|
=
flags
;
}
void
disableState
(
uint32_t
flags
)
{
fFlags
&
=
~
(
flags
)
;
}
void
setState
(
uint32_t
flags
bool
enable
)
{
if
(
enable
)
{
this
-
>
enableState
(
flags
)
;
}
else
{
this
-
>
disableState
(
flags
)
;
}
}
enum
DrawFace
{
kInvalid_DrawFace
=
-
1
kBoth_DrawFace
kCCW_DrawFace
kCW_DrawFace
}
;
DrawFace
getDrawFace
(
)
const
{
return
fDrawFace
;
}
void
setDrawFace
(
DrawFace
face
)
{
SkASSERT
(
kInvalid_DrawFace
!
=
face
)
;
fDrawFace
=
face
;
}
bool
usePLSDstRead
(
const
GrDrawBatch
*
batch
)
const
;
void
setClip
(
const
GrClip
&
clip
)
{
fClip
=
clip
;
}
const
GrClip
&
clip
(
)
const
{
return
fClip
;
}
private
:
SkDEBUGCODE
(
mutable
int
fBlockEffectRemovalCnt
;
)
typedef
SkSTArray
<
4
const
GrFragmentProcessor
*
true
>
FragmentProcessorArray
;
SkAutoTUnref
<
GrRenderTarget
>
fRenderTarget
;
uint32_t
fFlags
;
GrStencilSettings
fStencilSettings
;
DrawFace
fDrawFace
;
mutable
SkAutoTUnref
<
const
GrXPFactory
>
fXPFactory
;
FragmentProcessorArray
fColorFragmentProcessors
;
FragmentProcessorArray
fCoverageFragmentProcessors
;
GrClip
fClip
;
friend
class
GrPipeline
;
friend
class
GrDrawTarget
;
}
;
#
endif
