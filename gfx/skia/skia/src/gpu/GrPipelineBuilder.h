#
ifndef
GrPipelineBuilder_DEFINED
#
define
GrPipelineBuilder_DEFINED
#
include
"
GrBlend
.
h
"
#
include
"
GrCaps
.
h
"
#
include
"
GrGpuResourceRef
.
h
"
#
include
"
GrProcOptInfo
.
h
"
#
include
"
GrRenderTarget
.
h
"
#
include
"
GrUserStencilSettings
.
h
"
#
include
"
GrXferProcessor
.
h
"
#
include
"
SkMatrix
.
h
"
#
include
"
SkRefCnt
.
h
"
#
include
"
effects
/
GrCoverageSetOpXP
.
h
"
#
include
"
effects
/
GrDisableColorXP
.
h
"
#
include
"
effects
/
GrPorterDuffXferProcessor
.
h
"
#
include
"
effects
/
GrSimpleTextureEffect
.
h
"
class
GrDrawBatch
;
class
GrCaps
;
class
GrPaint
;
class
GrTexture
;
class
GrPipelineBuilder
:
public
SkNoncopyable
{
public
:
GrPipelineBuilder
(
)
;
GrPipelineBuilder
(
const
GrPaint
&
bool
useHWAA
=
false
)
;
virtual
~
GrPipelineBuilder
(
)
;
int
numColorFragmentProcessors
(
)
const
{
return
fColorFragmentProcessors
.
count
(
)
;
}
int
numCoverageFragmentProcessors
(
)
const
{
return
fCoverageFragmentProcessors
.
count
(
)
;
}
int
numFragmentProcessors
(
)
const
{
return
this
-
>
numColorFragmentProcessors
(
)
+
this
-
>
numCoverageFragmentProcessors
(
)
;
}
const
GrFragmentProcessor
*
getColorFragmentProcessor
(
int
idx
)
const
{
return
fColorFragmentProcessors
[
idx
]
.
get
(
)
;
}
const
GrFragmentProcessor
*
getCoverageFragmentProcessor
(
int
idx
)
const
{
return
fCoverageFragmentProcessors
[
idx
]
.
get
(
)
;
}
void
addColorFragmentProcessor
(
sk_sp
<
GrFragmentProcessor
>
processor
)
{
SkASSERT
(
processor
)
;
fColorFragmentProcessors
.
push_back
(
std
:
:
move
(
processor
)
)
;
}
void
addCoverageFragmentProcessor
(
sk_sp
<
GrFragmentProcessor
>
processor
)
{
SkASSERT
(
processor
)
;
fCoverageFragmentProcessors
.
push_back
(
std
:
:
move
(
processor
)
)
;
}
void
addColorTextureProcessor
(
GrTexture
*
texture
const
SkMatrix
&
matrix
)
{
this
-
>
addColorFragmentProcessor
(
GrSimpleTextureEffect
:
:
Make
(
texture
nullptr
matrix
)
)
;
}
void
addCoverageTextureProcessor
(
GrTexture
*
texture
const
SkMatrix
&
matrix
)
{
this
-
>
addCoverageFragmentProcessor
(
GrSimpleTextureEffect
:
:
Make
(
texture
nullptr
matrix
)
)
;
}
void
addColorTextureProcessor
(
GrTexture
*
texture
const
SkMatrix
&
matrix
const
GrTextureParams
&
params
)
{
this
-
>
addColorFragmentProcessor
(
GrSimpleTextureEffect
:
:
Make
(
texture
nullptr
matrix
params
)
)
;
}
void
addCoverageTextureProcessor
(
GrTexture
*
texture
const
SkMatrix
&
matrix
const
GrTextureParams
&
params
)
{
this
-
>
addCoverageFragmentProcessor
(
GrSimpleTextureEffect
:
:
Make
(
texture
nullptr
matrix
params
)
)
;
}
class
AutoRestoreFragmentProcessorState
:
public
:
:
SkNoncopyable
{
public
:
AutoRestoreFragmentProcessorState
(
)
:
fPipelineBuilder
(
nullptr
)
fColorEffectCnt
(
0
)
fCoverageEffectCnt
(
0
)
{
}
AutoRestoreFragmentProcessorState
(
const
GrPipelineBuilder
&
ds
)
:
fPipelineBuilder
(
nullptr
)
fColorEffectCnt
(
0
)
fCoverageEffectCnt
(
0
)
{
this
-
>
set
(
&
ds
)
;
}
~
AutoRestoreFragmentProcessorState
(
)
{
this
-
>
set
(
nullptr
)
;
}
void
set
(
const
GrPipelineBuilder
*
ds
)
;
bool
isSet
(
)
const
{
return
SkToBool
(
fPipelineBuilder
)
;
}
void
addCoverageFragmentProcessor
(
sk_sp
<
GrFragmentProcessor
>
processor
)
{
SkASSERT
(
this
-
>
isSet
(
)
)
;
return
fPipelineBuilder
-
>
addCoverageFragmentProcessor
(
std
:
:
move
(
processor
)
)
;
}
private
:
GrPipelineBuilder
*
fPipelineBuilder
;
int
fColorEffectCnt
;
int
fCoverageEffectCnt
;
}
;
void
setXPFactory
(
sk_sp
<
GrXPFactory
>
xpFactory
)
{
fXPFactory
=
std
:
:
move
(
xpFactory
)
;
}
void
setDisableColorXPFactory
(
)
{
fXPFactory
=
GrDisableColorXPFactory
:
:
Make
(
)
;
}
const
GrXPFactory
*
getXPFactory
(
)
const
{
return
fXPFactory
.
get
(
)
;
}
bool
willXPNeedDstTexture
(
const
GrCaps
&
caps
const
GrPipelineOptimizations
&
optimizations
)
const
;
bool
hasUserStencilSettings
(
)
const
{
return
!
fUserStencilSettings
-
>
isUnused
(
)
;
}
const
GrUserStencilSettings
*
getUserStencil
(
)
const
{
return
fUserStencilSettings
;
}
void
setUserStencil
(
const
GrUserStencilSettings
*
settings
)
{
fUserStencilSettings
=
settings
;
}
void
disableUserStencil
(
)
{
fUserStencilSettings
=
&
GrUserStencilSettings
:
:
kUnused
;
}
enum
Flags
{
kHWAntialias_Flag
=
0x01
kSnapVerticesToPixelCenters_Flag
=
0x02
kDisableOutputConversionToSRGB_Flag
=
0x04
kAllowSRGBInputs_Flag
=
0x08
kUsesDistanceVectorField_Flag
=
0x10
kLast_Flag
=
kUsesDistanceVectorField_Flag
}
;
bool
isHWAntialias
(
)
const
{
return
SkToBool
(
fFlags
&
kHWAntialias_Flag
)
;
}
bool
snapVerticesToPixelCenters
(
)
const
{
return
SkToBool
(
fFlags
&
kSnapVerticesToPixelCenters_Flag
)
;
}
bool
getDisableOutputConversionToSRGB
(
)
const
{
return
SkToBool
(
fFlags
&
kDisableOutputConversionToSRGB_Flag
)
;
}
bool
getAllowSRGBInputs
(
)
const
{
return
SkToBool
(
fFlags
&
kAllowSRGBInputs_Flag
)
;
}
bool
getUsesDistanceVectorField
(
)
const
{
return
SkToBool
(
fFlags
&
kUsesDistanceVectorField_Flag
)
;
}
void
enableState
(
uint32_t
flags
)
{
fFlags
|
=
flags
;
}
void
disableState
(
uint32_t
flags
)
{
fFlags
&
=
~
(
flags
)
;
}
void
setState
(
uint32_t
flags
bool
enable
)
{
if
(
enable
)
{
this
-
>
enableState
(
flags
)
;
}
else
{
this
-
>
disableState
(
flags
)
;
}
}
GrDrawFace
getDrawFace
(
)
const
{
return
fDrawFace
;
}
void
setDrawFace
(
GrDrawFace
face
)
{
SkASSERT
(
GrDrawFace
:
:
kInvalid
!
=
face
)
;
fDrawFace
=
face
;
}
bool
usePLSDstRead
(
const
GrDrawBatch
*
batch
)
const
;
private
:
SkDEBUGCODE
(
mutable
int
fBlockEffectRemovalCnt
;
)
typedef
SkSTArray
<
4
sk_sp
<
GrFragmentProcessor
>
>
FragmentProcessorArray
;
uint32_t
fFlags
;
const
GrUserStencilSettings
*
fUserStencilSettings
;
GrDrawFace
fDrawFace
;
mutable
sk_sp
<
GrXPFactory
>
fXPFactory
;
FragmentProcessorArray
fColorFragmentProcessors
;
FragmentProcessorArray
fCoverageFragmentProcessors
;
friend
class
GrPipeline
;
friend
class
GrDrawTarget
;
}
;
#
endif
