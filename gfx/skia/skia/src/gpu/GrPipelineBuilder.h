#
ifndef
GrPipelineBuilder_DEFINED
#
define
GrPipelineBuilder_DEFINED
#
include
"
GrGpuResourceRef
.
h
"
#
include
"
GrPipeline
.
h
"
#
include
"
GrProcessorSet
.
h
"
#
include
"
GrRenderTarget
.
h
"
#
include
"
GrUserStencilSettings
.
h
"
#
include
"
GrXferProcessor
.
h
"
class
GrCaps
;
class
GrDrawOp
;
class
GrPaint
;
class
GrTexture
;
class
GrPipelineBuilder
:
private
SkNoncopyable
{
public
:
GrPipelineBuilder
(
GrPaint
&
&
paint
GrAAType
aaType
)
:
fFlags
(
0x0
)
fDrawFace
(
GrDrawFace
:
:
kBoth
)
fUserStencilSettings
(
&
GrUserStencilSettings
:
:
kUnused
)
fProcessors
(
std
:
:
move
(
paint
)
)
{
if
(
GrAATypeIsHW
(
aaType
)
)
{
fFlags
|
=
GrPipeline
:
:
kHWAntialias_Flag
;
}
}
int
numColorFragmentProcessors
(
)
const
{
return
fProcessors
.
numColorFragmentProcessors
(
)
;
}
int
numCoverageFragmentProcessors
(
)
const
{
return
fProcessors
.
numCoverageFragmentProcessors
(
)
;
}
int
numFragmentProcessors
(
)
const
{
return
fProcessors
.
numFragmentProcessors
(
)
;
}
const
GrFragmentProcessor
*
getColorFragmentProcessor
(
int
idx
)
const
{
return
fProcessors
.
colorFragmentProcessor
(
idx
)
;
}
const
GrFragmentProcessor
*
getCoverageFragmentProcessor
(
int
idx
)
const
{
return
fProcessors
.
coverageFragmentProcessor
(
idx
)
;
}
const
GrProcessorSet
&
processors
(
)
const
{
return
fProcessors
;
}
GrProcessorSet
:
:
Analysis
finalizeProcessors
(
const
GrProcessorAnalysisColor
&
colorInput
const
GrProcessorAnalysisCoverage
coverageInput
const
GrAppliedClip
*
clip
bool
isMixedSamples
const
GrCaps
&
caps
GrColor
*
overrideColor
)
{
return
fProcessors
.
finalize
(
colorInput
coverageInput
clip
isMixedSamples
caps
overrideColor
)
;
}
bool
hasUserStencilSettings
(
)
const
{
return
!
fUserStencilSettings
-
>
isUnused
(
)
;
}
void
setUserStencil
(
const
GrUserStencilSettings
*
settings
)
{
fUserStencilSettings
=
settings
;
}
bool
isHWAntialias
(
)
const
{
return
SkToBool
(
fFlags
&
GrPipeline
:
:
kHWAntialias_Flag
)
;
}
void
setSnapVerticesToPixelCenters
(
bool
enable
)
{
if
(
enable
)
{
fFlags
|
=
GrPipeline
:
:
kSnapVerticesToPixelCenters_Flag
;
}
else
{
fFlags
&
=
~
GrPipeline
:
:
kSnapVerticesToPixelCenters_Flag
;
}
}
void
setDrawFace
(
GrDrawFace
face
)
{
SkASSERT
(
GrDrawFace
:
:
kInvalid
!
=
face
)
;
fDrawFace
=
face
;
}
void
getPipelineInitArgs
(
GrPipeline
:
:
InitArgs
*
args
)
const
{
args
-
>
fFlags
=
fFlags
;
args
-
>
fUserStencil
=
fUserStencilSettings
;
args
-
>
fDrawFace
=
fDrawFace
;
args
-
>
fProcessors
=
&
fProcessors
;
}
private
:
uint32_t
fFlags
;
GrDrawFace
fDrawFace
;
const
GrUserStencilSettings
*
fUserStencilSettings
;
GrProcessorSet
fProcessors
;
}
;
#
endif
