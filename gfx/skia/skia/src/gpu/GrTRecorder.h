#
ifndef
GrTRecorder_DEFINED
#
define
GrTRecorder_DEFINED
#
include
"
SkTypes
.
h
"
template
<
typename
TBase
typename
TAlign
>
class
GrTRecorder
;
template
<
typename
TItem
>
struct
GrTRecorderAllocWrapper
;
template
<
typename
TBase
typename
TAlign
>
class
GrTRecorder
:
SkNoncopyable
{
public
:
class
Iter
;
class
ReverseIter
;
GrTRecorder
(
int
initialSizeInBytes
)
:
fHeadBlock
(
MemBlock
:
:
Alloc
(
LengthOf
(
initialSizeInBytes
)
nullptr
)
)
fTailBlock
(
fHeadBlock
)
fLastItem
(
nullptr
)
{
}
~
GrTRecorder
(
)
{
this
-
>
reset
(
)
;
MemBlock
:
:
Free
(
fHeadBlock
)
;
}
bool
empty
(
)
{
return
!
fLastItem
;
}
TBase
&
back
(
)
{
SkASSERT
(
!
this
-
>
empty
(
)
)
;
return
*
reinterpret_cast
<
TBase
*
>
(
fLastItem
)
;
}
void
pop_back
(
)
;
void
reset
(
)
;
template
<
typename
TItem
>
static
const
void
*
GetDataForItem
(
const
TItem
*
item
)
{
const
TAlign
*
ptr
=
reinterpret_cast
<
const
TAlign
*
>
(
item
)
;
return
&
ptr
[
length_of
<
TItem
>
:
:
kValue
]
;
}
template
<
typename
TItem
>
static
void
*
GetDataForItem
(
TItem
*
item
)
{
TAlign
*
ptr
=
reinterpret_cast
<
TAlign
*
>
(
item
)
;
return
&
ptr
[
length_of
<
TItem
>
:
:
kValue
]
;
}
private
:
template
<
typename
TItem
>
struct
length_of
{
enum
{
kValue
=
(
sizeof
(
TItem
)
+
sizeof
(
TAlign
)
-
1
)
/
sizeof
(
TAlign
)
}
;
}
;
static
int
LengthOf
(
int
bytes
)
{
return
(
bytes
+
sizeof
(
TAlign
)
-
1
)
/
sizeof
(
TAlign
)
;
}
struct
Header
{
int
fTotalLength
;
int
fPrevLength
;
}
;
template
<
typename
TItem
>
void
*
alloc_back
(
int
dataLength
)
;
struct
MemBlock
:
SkNoncopyable
{
static
MemBlock
*
Alloc
(
int
length
MemBlock
*
prev
)
{
MemBlock
*
block
=
reinterpret_cast
<
MemBlock
*
>
(
sk_malloc_throw
(
sizeof
(
TAlign
)
*
(
length_of
<
MemBlock
>
:
:
kValue
+
length
)
)
)
;
block
-
>
fLength
=
length
;
block
-
>
fBack
=
0
;
block
-
>
fNext
=
nullptr
;
block
-
>
fPrev
=
prev
;
if
(
prev
)
{
SkASSERT
(
nullptr
=
=
prev
-
>
fNext
)
;
prev
-
>
fNext
=
block
;
}
return
block
;
}
static
void
Free
(
MemBlock
*
block
)
{
if
(
block
&
&
block
-
>
fPrev
)
{
SkASSERT
(
block
-
>
fPrev
-
>
fNext
=
=
block
)
;
block
-
>
fPrev
-
>
fNext
=
nullptr
;
}
while
(
block
)
{
MemBlock
*
next
=
block
-
>
fNext
;
sk_free
(
block
)
;
block
=
next
;
}
}
TAlign
&
operator
[
]
(
int
i
)
{
return
reinterpret_cast
<
TAlign
*
>
(
this
)
[
length_of
<
MemBlock
>
:
:
kValue
+
i
]
;
}
int
fLength
;
int
fBack
;
MemBlock
*
fNext
;
MemBlock
*
fPrev
;
}
;
MemBlock
*
const
fHeadBlock
;
MemBlock
*
fTailBlock
;
void
*
fLastItem
;
template
<
typename
TItem
>
friend
struct
GrTRecorderAllocWrapper
;
template
<
typename
UBase
typename
UAlign
typename
UItem
>
friend
void
*
operator
new
(
size_t
GrTRecorder
<
UBase
UAlign
>
&
const
GrTRecorderAllocWrapper
<
UItem
>
&
)
;
friend
class
Iter
;
friend
class
ReverseIter
;
}
;
template
<
typename
TBase
typename
TAlign
>
void
GrTRecorder
<
TBase
TAlign
>
:
:
pop_back
(
)
{
SkASSERT
(
fLastItem
)
;
Header
*
header
=
reinterpret_cast
<
Header
*
>
(
reinterpret_cast
<
TAlign
*
>
(
fLastItem
)
-
length_of
<
Header
>
:
:
kValue
)
;
fTailBlock
-
>
fBack
-
=
header
-
>
fTotalLength
;
reinterpret_cast
<
TBase
*
>
(
fLastItem
)
-
>
~
TBase
(
)
;
int
lastItemLength
=
header
-
>
fPrevLength
;
if
(
!
header
-
>
fPrevLength
)
{
SkASSERT
(
0
=
=
fTailBlock
-
>
fBack
)
;
fLastItem
=
nullptr
;
return
;
}
while
(
!
fTailBlock
-
>
fBack
)
{
fTailBlock
=
fTailBlock
-
>
fPrev
;
SkASSERT
(
fTailBlock
)
;
}
fLastItem
=
&
(
*
fTailBlock
)
[
fTailBlock
-
>
fBack
-
lastItemLength
+
length_of
<
Header
>
:
:
kValue
]
;
}
template
<
typename
TBase
typename
TAlign
>
template
<
typename
TItem
>
void
*
GrTRecorder
<
TBase
TAlign
>
:
:
alloc_back
(
int
dataLength
)
{
int
prevLength
=
0
;
if
(
fLastItem
)
{
Header
*
lastHeader
=
reinterpret_cast
<
Header
*
>
(
reinterpret_cast
<
TAlign
*
>
(
fLastItem
)
-
length_of
<
Header
>
:
:
kValue
)
;
prevLength
=
lastHeader
-
>
fTotalLength
;
}
const
int
totalLength
=
length_of
<
Header
>
:
:
kValue
+
length_of
<
TItem
>
:
:
kValue
+
dataLength
;
while
(
fTailBlock
-
>
fBack
+
totalLength
>
fTailBlock
-
>
fLength
)
{
if
(
!
fTailBlock
-
>
fNext
)
{
fTailBlock
=
MemBlock
:
:
Alloc
(
SkTMax
(
2
*
fTailBlock
-
>
fLength
totalLength
)
fTailBlock
)
;
}
else
{
fTailBlock
=
fTailBlock
-
>
fNext
;
}
SkASSERT
(
0
=
=
fTailBlock
-
>
fBack
)
;
}
Header
*
header
=
reinterpret_cast
<
Header
*
>
(
&
(
*
fTailBlock
)
[
fTailBlock
-
>
fBack
]
)
;
void
*
rawPtr
=
&
(
*
fTailBlock
)
[
fTailBlock
-
>
fBack
+
length_of
<
Header
>
:
:
kValue
]
;
header
-
>
fTotalLength
=
totalLength
;
header
-
>
fPrevLength
=
prevLength
;
fLastItem
=
rawPtr
;
fTailBlock
-
>
fBack
+
=
totalLength
;
SkDEBUGCODE
(
void
*
baseAddr
=
fLastItem
;
void
*
subclassAddr
=
rawPtr
)
;
SkASSERT
(
baseAddr
=
=
subclassAddr
)
;
return
rawPtr
;
}
template
<
typename
TBase
typename
TAlign
>
class
GrTRecorder
<
TBase
TAlign
>
:
:
Iter
{
public
:
Iter
(
GrTRecorder
&
recorder
)
:
fBlock
(
recorder
.
fHeadBlock
)
fPosition
(
0
)
fItem
(
nullptr
)
{
}
bool
next
(
)
{
while
(
fPosition
>
=
fBlock
-
>
fBack
)
{
SkASSERT
(
fPosition
=
=
fBlock
-
>
fBack
)
;
if
(
!
fBlock
-
>
fNext
)
{
return
false
;
}
fBlock
=
fBlock
-
>
fNext
;
fPosition
=
0
;
}
Header
*
header
=
reinterpret_cast
<
Header
*
>
(
&
(
*
fBlock
)
[
fPosition
]
)
;
fItem
=
reinterpret_cast
<
TBase
*
>
(
&
(
*
fBlock
)
[
fPosition
+
length_of
<
Header
>
:
:
kValue
]
)
;
fPosition
+
=
header
-
>
fTotalLength
;
return
true
;
}
TBase
*
get
(
)
const
{
SkASSERT
(
fItem
)
;
return
fItem
;
}
TBase
*
operator
-
>
(
)
const
{
return
this
-
>
get
(
)
;
}
private
:
MemBlock
*
fBlock
;
int
fPosition
;
TBase
*
fItem
;
}
;
template
<
typename
TBase
typename
TAlign
>
class
GrTRecorder
<
TBase
TAlign
>
:
:
ReverseIter
{
public
:
ReverseIter
(
GrTRecorder
&
recorder
)
:
fBlock
(
recorder
.
fTailBlock
)
fItem
(
&
recorder
.
back
(
)
)
{
Header
*
lastHeader
=
reinterpret_cast
<
Header
*
>
(
reinterpret_cast
<
TAlign
*
>
(
fItem
)
-
length_of
<
Header
>
:
:
kValue
)
;
fPosition
=
fBlock
-
>
fBack
-
lastHeader
-
>
fTotalLength
;
}
bool
previous
(
)
{
Header
*
header
=
reinterpret_cast
<
Header
*
>
(
&
(
*
fBlock
)
[
fPosition
]
)
;
while
(
0
=
=
fPosition
)
{
if
(
!
fBlock
-
>
fPrev
)
{
return
false
;
}
fBlock
=
fBlock
-
>
fPrev
;
fPosition
=
fBlock
-
>
fBack
;
}
fPosition
-
=
header
-
>
fPrevLength
;
SkASSERT
(
fPosition
>
=
0
)
;
fItem
=
reinterpret_cast
<
TBase
*
>
(
&
(
*
fBlock
)
[
fPosition
+
length_of
<
Header
>
:
:
kValue
]
)
;
return
true
;
}
TBase
*
get
(
)
const
{
return
fItem
;
}
TBase
*
operator
-
>
(
)
const
{
return
this
-
>
get
(
)
;
}
private
:
MemBlock
*
fBlock
;
int
fPosition
;
TBase
*
fItem
;
}
;
template
<
typename
TBase
typename
TAlign
>
void
GrTRecorder
<
TBase
TAlign
>
:
:
reset
(
)
{
Iter
iter
(
*
this
)
;
while
(
iter
.
next
(
)
)
{
iter
-
>
~
TBase
(
)
;
}
if
(
fTailBlock
-
>
fBack
<
=
fTailBlock
-
>
fLength
/
2
)
{
MemBlock
:
:
Free
(
fTailBlock
-
>
fNext
)
;
}
else
if
(
fTailBlock
-
>
fNext
)
{
MemBlock
:
:
Free
(
fTailBlock
-
>
fNext
-
>
fNext
)
;
fTailBlock
-
>
fNext
-
>
fNext
=
nullptr
;
}
for
(
MemBlock
*
block
=
fHeadBlock
;
block
;
block
=
block
-
>
fNext
)
{
block
-
>
fBack
=
0
;
}
fTailBlock
=
fHeadBlock
;
fLastItem
=
nullptr
;
}
template
<
typename
TItem
>
struct
GrTRecorderAllocWrapper
{
GrTRecorderAllocWrapper
(
)
:
fDataLength
(
0
)
{
}
template
<
typename
TBase
typename
TAlign
>
GrTRecorderAllocWrapper
(
const
GrTRecorder
<
TBase
TAlign
>
&
int
sizeOfData
)
:
fDataLength
(
GrTRecorder
<
TBase
TAlign
>
:
:
LengthOf
(
sizeOfData
)
)
{
}
const
int
fDataLength
;
}
;
template
<
typename
TBase
typename
TAlign
typename
TItem
>
void
*
operator
new
(
size_t
size
GrTRecorder
<
TBase
TAlign
>
&
recorder
const
GrTRecorderAllocWrapper
<
TItem
>
&
wrapper
)
{
SkASSERT
(
size
=
=
sizeof
(
TItem
)
)
;
return
recorder
.
template
alloc_back
<
TItem
>
(
wrapper
.
fDataLength
)
;
}
template
<
typename
TBase
typename
TAlign
typename
TItem
>
void
operator
delete
(
void
*
GrTRecorder
<
TBase
TAlign
>
&
const
GrTRecorderAllocWrapper
<
TItem
>
&
)
{
SK_ABORT
(
"
Invalid
Operation
"
)
;
}
#
define
GrNEW_APPEND_TO_RECORDER
(
recorder
type_name
args
)
\
(
new
(
recorder
GrTRecorderAllocWrapper
<
type_name
>
(
)
)
type_name
args
)
#
define
GrNEW_APPEND_WITH_DATA_TO_RECORDER
(
recorder
type_name
args
size_of_data
)
\
(
new
(
recorder
GrTRecorderAllocWrapper
<
type_name
>
(
recorder
size_of_data
)
)
type_name
args
)
#
endif
