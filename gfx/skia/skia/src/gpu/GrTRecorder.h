#
ifndef
GrTRecorder_DEFINED
#
define
GrTRecorder_DEFINED
#
include
"
include
/
gpu
/
GrTypes
.
h
"
#
include
"
include
/
private
/
SkTLogic
.
h
"
#
include
"
src
/
core
/
SkArenaAlloc
.
h
"
template
<
typename
TBase
>
class
GrTRecorder
{
private
:
template
<
bool
IsConst
>
class
IterImpl
;
public
:
using
iterator
=
IterImpl
<
false
>
;
using
const_iterator
=
IterImpl
<
true
>
;
explicit
GrTRecorder
(
size_t
initialSizeInBytes
)
:
fArena
(
initialSizeInBytes
)
{
}
GrTRecorder
(
const
GrTRecorder
&
)
=
delete
;
GrTRecorder
&
operator
=
(
const
GrTRecorder
&
)
=
delete
;
~
GrTRecorder
(
)
{
this
-
>
reset
(
)
;
}
bool
empty
(
)
{
return
!
SkToBool
(
fTail
)
;
}
TBase
&
back
(
)
{
SkASSERT
(
!
this
-
>
empty
(
)
)
;
return
*
fTail
-
>
get
(
)
;
}
iterator
begin
(
)
{
return
iterator
(
fHead
)
;
}
iterator
end
(
)
{
return
iterator
(
nullptr
)
;
}
const_iterator
begin
(
)
const
{
return
const_iterator
(
fHead
)
;
}
const_iterator
end
(
)
const
{
return
const_iterator
(
nullptr
)
;
}
void
reset
(
)
;
template
<
typename
TItem
typename
.
.
.
Args
>
TItem
&
emplace
(
Args
&
&
.
.
.
args
)
{
return
this
-
>
emplaceWithData
<
TItem
Args
.
.
.
>
(
0
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
typename
TItem
typename
.
.
.
Args
>
SK_WHEN
(
(
std
:
:
is_base_of
<
TBase
TItem
>
:
:
value
)
TItem
&
)
emplaceWithData
(
size_t
extraDataSize
Args
.
.
.
args
)
;
private
:
struct
Header
{
Header
*
fNext
=
nullptr
;
TBase
*
get
(
)
const
{
return
reinterpret_cast
<
TBase
*
>
(
const_cast
<
Header
*
>
(
this
)
+
1
)
;
}
}
;
SkArenaAlloc
fArena
;
Header
*
fHead
=
nullptr
;
Header
*
fTail
=
nullptr
;
}
;
template
<
typename
TBase
>
template
<
typename
TItem
typename
.
.
.
Args
>
inline
SK_WHEN
(
(
std
:
:
is_base_of
<
TBase
TItem
>
:
:
value
)
TItem
&
)
GrTRecorder
<
TBase
>
:
:
emplaceWithData
(
size_t
extraDataSize
Args
.
.
.
args
)
{
static
constexpr
size_t
kTAlign
=
alignof
(
TItem
)
;
static
constexpr
size_t
kHeaderAlign
=
alignof
(
Header
)
;
static
constexpr
size_t
kAllocAlign
=
kTAlign
>
kHeaderAlign
?
kTAlign
:
kHeaderAlign
;
static
constexpr
size_t
kTItemOffset
=
GrSizeAlignUp
(
sizeof
(
Header
)
kAllocAlign
)
;
GR_STATIC_ASSERT
(
sizeof
(
Header
)
%
alignof
(
Header
)
=
=
0
)
;
const
size_t
totalSize
=
kTItemOffset
+
sizeof
(
TItem
)
+
extraDataSize
;
auto
alloc
=
reinterpret_cast
<
char
*
>
(
fArena
.
makeBytesAlignedTo
(
totalSize
kAllocAlign
)
)
;
Header
*
header
=
new
(
alloc
+
kTItemOffset
-
sizeof
(
Header
)
)
Header
(
)
;
if
(
fTail
)
{
fTail
-
>
fNext
=
header
;
}
fTail
=
header
;
if
(
!
fHead
)
{
fHead
=
header
;
}
auto
*
item
=
new
(
alloc
+
kTItemOffset
)
TItem
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
SkASSERT
(
reinterpret_cast
<
uintptr_t
>
(
item
)
=
=
reinterpret_cast
<
uintptr_t
>
(
static_cast
<
TBase
*
>
(
item
)
)
)
;
return
*
item
;
}
template
<
typename
TBase
>
inline
void
GrTRecorder
<
TBase
>
:
:
reset
(
)
{
for
(
auto
&
i
:
*
this
)
{
i
.
~
TBase
(
)
;
}
GR_STATIC_ASSERT
(
std
:
:
is_trivially_destructible
<
Header
>
:
:
value
)
;
fHead
=
fTail
=
nullptr
;
fArena
.
reset
(
)
;
}
template
<
typename
TBase
>
template
<
bool
IsConst
>
class
GrTRecorder
<
TBase
>
:
:
IterImpl
{
private
:
using
T
=
typename
std
:
:
conditional
<
IsConst
const
TBase
TBase
>
:
:
type
;
public
:
IterImpl
(
)
=
default
;
IterImpl
operator
+
+
(
)
{
fCurr
=
fCurr
-
>
fNext
;
return
*
this
;
}
IterImpl
operator
+
+
(
int
)
{
auto
old
=
fCurr
;
fCurr
=
fCurr
-
>
fNext
;
return
{
old
}
;
}
T
&
operator
*
(
)
const
{
return
*
fCurr
-
>
get
(
)
;
}
T
*
operator
-
>
(
)
const
{
return
fCurr
-
>
get
(
)
;
}
bool
operator
=
=
(
const
IterImpl
&
that
)
const
{
return
fCurr
=
=
that
.
fCurr
;
}
bool
operator
!
=
(
const
IterImpl
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
private
:
IterImpl
(
Header
*
curr
)
:
fCurr
(
curr
)
{
}
Header
*
fCurr
=
nullptr
;
friend
class
GrTRecorder
<
TBase
>
;
}
;
#
endif
