#
include
"
SkGpuDevice
.
h
"
#
include
"
GrBlurUtils
.
h
"
#
include
"
GrCaps
.
h
"
#
include
"
GrRenderTargetContext
.
h
"
#
include
"
GrStyle
.
h
"
#
include
"
GrTextureAdjuster
.
h
"
#
include
"
SkDraw
.
h
"
#
include
"
SkGr
.
h
"
#
include
"
SkMaskFilter
.
h
"
#
include
"
effects
/
GrBicubicEffect
.
h
"
#
include
"
effects
/
GrSimpleTextureEffect
.
h
"
#
include
"
effects
/
GrTextureDomain
.
h
"
static
inline
bool
use_shader
(
bool
textureIsAlphaOnly
const
SkPaint
&
paint
)
{
return
textureIsAlphaOnly
&
&
paint
.
getShader
(
)
;
}
static
const
SkScalar
kColorBleedTolerance
=
0
.
001f
;
static
bool
has_aligned_samples
(
const
SkRect
&
srcRect
const
SkRect
&
transformedRect
)
{
if
(
SkScalarAbs
(
SkScalarRoundToScalar
(
transformedRect
.
left
(
)
)
-
transformedRect
.
left
(
)
)
<
kColorBleedTolerance
&
&
SkScalarAbs
(
SkScalarRoundToScalar
(
transformedRect
.
top
(
)
)
-
transformedRect
.
top
(
)
)
<
kColorBleedTolerance
&
&
SkScalarAbs
(
transformedRect
.
width
(
)
-
srcRect
.
width
(
)
)
<
kColorBleedTolerance
&
&
SkScalarAbs
(
transformedRect
.
height
(
)
-
srcRect
.
height
(
)
)
<
kColorBleedTolerance
)
{
return
true
;
}
return
false
;
}
static
bool
may_color_bleed
(
const
SkRect
&
srcRect
const
SkRect
&
transformedRect
const
SkMatrix
&
m
bool
isMSAA
)
{
SkASSERT
(
!
has_aligned_samples
(
srcRect
transformedRect
)
)
;
SkRect
innerSrcRect
(
srcRect
)
innerTransformedRect
outerTransformedRect
(
transformedRect
)
;
if
(
isMSAA
)
{
innerSrcRect
.
inset
(
SK_Scalar1
SK_Scalar1
)
;
}
else
{
innerSrcRect
.
inset
(
SK_ScalarHalf
SK_ScalarHalf
)
;
}
m
.
mapRect
(
&
innerTransformedRect
innerSrcRect
)
;
outerTransformedRect
.
inset
(
kColorBleedTolerance
kColorBleedTolerance
)
;
innerTransformedRect
.
outset
(
kColorBleedTolerance
kColorBleedTolerance
)
;
SkIRect
outer
inner
;
outerTransformedRect
.
round
(
&
outer
)
;
innerTransformedRect
.
round
(
&
inner
)
;
return
inner
!
=
outer
;
}
static
bool
can_ignore_bilerp_constraint
(
const
GrTextureProducer
&
producer
const
SkRect
&
srcRect
const
SkMatrix
&
srcRectToDeviceSpace
bool
isMSAA
)
{
if
(
srcRectToDeviceSpace
.
rectStaysRect
(
)
)
{
SkRect
transformedRect
;
srcRectToDeviceSpace
.
mapRect
(
&
transformedRect
srcRect
)
;
if
(
has_aligned_samples
(
srcRect
transformedRect
)
|
|
!
may_color_bleed
(
srcRect
transformedRect
srcRectToDeviceSpace
isMSAA
)
)
{
return
true
;
}
}
return
false
;
}
void
SkGpuDevice
:
:
drawTextureProducer
(
GrTextureProducer
*
producer
const
SkRect
*
srcRect
const
SkRect
*
dstRect
SkCanvas
:
:
SrcRectConstraint
constraint
const
SkMatrix
&
viewMatrix
const
GrClip
&
clip
const
SkPaint
&
paint
)
{
SK_HISTOGRAM_BOOLEAN
(
"
DrawTiled
"
false
)
;
SkRect
clippedSrcRect
;
SkRect
clippedDstRect
;
const
SkRect
srcBounds
=
SkRect
:
:
MakeIWH
(
producer
-
>
width
(
)
producer
-
>
height
(
)
)
;
SkMatrix
srcToDstMatrix
;
if
(
srcRect
)
{
if
(
!
dstRect
)
{
dstRect
=
&
srcBounds
;
}
if
(
!
srcBounds
.
contains
(
*
srcRect
)
)
{
clippedSrcRect
=
*
srcRect
;
if
(
!
clippedSrcRect
.
intersect
(
srcBounds
)
)
{
return
;
}
if
(
!
srcToDstMatrix
.
setRectToRect
(
*
srcRect
*
dstRect
SkMatrix
:
:
kFill_ScaleToFit
)
)
{
return
;
}
srcToDstMatrix
.
mapRect
(
&
clippedDstRect
clippedSrcRect
)
;
}
else
{
clippedSrcRect
=
*
srcRect
;
clippedDstRect
=
*
dstRect
;
if
(
!
srcToDstMatrix
.
setRectToRect
(
*
srcRect
*
dstRect
SkMatrix
:
:
kFill_ScaleToFit
)
)
{
return
;
}
}
}
else
{
clippedSrcRect
=
srcBounds
;
if
(
dstRect
)
{
clippedDstRect
=
*
dstRect
;
if
(
!
srcToDstMatrix
.
setRectToRect
(
srcBounds
*
dstRect
SkMatrix
:
:
kFill_ScaleToFit
)
)
{
return
;
}
}
else
{
clippedDstRect
=
srcBounds
;
srcToDstMatrix
.
reset
(
)
;
}
}
LogDrawScaleFactor
(
SkMatrix
:
:
Concat
(
viewMatrix
srcToDstMatrix
)
paint
.
getFilterQuality
(
)
)
;
this
-
>
drawTextureProducerImpl
(
producer
clippedSrcRect
clippedDstRect
constraint
viewMatrix
srcToDstMatrix
clip
paint
)
;
}
void
SkGpuDevice
:
:
drawTextureProducerImpl
(
GrTextureProducer
*
producer
const
SkRect
&
clippedSrcRect
const
SkRect
&
clippedDstRect
SkCanvas
:
:
SrcRectConstraint
constraint
const
SkMatrix
&
viewMatrix
const
SkMatrix
&
srcToDstMatrix
const
GrClip
&
clip
const
SkPaint
&
paint
)
{
const
SkMaskFilter
*
mf
=
paint
.
getMaskFilter
(
)
;
bool
canUseTextureCoordsAsLocalCoords
=
!
use_shader
(
producer
-
>
isAlphaOnly
(
)
paint
)
&
&
!
mf
;
bool
doBicubic
;
GrSamplerParams
:
:
FilterMode
fm
=
GrSkFilterQualityToGrFilterMode
(
paint
.
getFilterQuality
(
)
viewMatrix
srcToDstMatrix
&
doBicubic
)
;
const
GrSamplerParams
:
:
FilterMode
*
filterMode
=
doBicubic
?
nullptr
:
&
fm
;
GrTextureProducer
:
:
FilterConstraint
constraintMode
;
if
(
SkCanvas
:
:
kFast_SrcRectConstraint
=
=
constraint
)
{
constraintMode
=
GrTextureAdjuster
:
:
kNo_FilterConstraint
;
}
else
{
constraintMode
=
GrTextureAdjuster
:
:
kYes_FilterConstraint
;
}
bool
coordsAllInsideSrcRect
=
!
paint
.
isAntiAlias
(
)
&
&
!
mf
;
if
(
filterMode
&
&
GrSamplerParams
:
:
kBilerp_FilterMode
=
=
*
filterMode
&
&
GrTextureAdjuster
:
:
kYes_FilterConstraint
=
=
constraintMode
&
&
coordsAllInsideSrcRect
)
{
SkMatrix
combinedMatrix
;
combinedMatrix
.
setConcat
(
viewMatrix
srcToDstMatrix
)
;
if
(
can_ignore_bilerp_constraint
(
*
producer
clippedSrcRect
combinedMatrix
fRenderTargetContext
-
>
isUnifiedMultisampled
(
)
)
)
{
constraintMode
=
GrTextureAdjuster
:
:
kNo_FilterConstraint
;
}
}
const
SkMatrix
*
textureMatrix
;
SkMatrix
tempMatrix
;
if
(
canUseTextureCoordsAsLocalCoords
)
{
textureMatrix
=
&
SkMatrix
:
:
I
(
)
;
}
else
{
if
(
!
srcToDstMatrix
.
invert
(
&
tempMatrix
)
)
{
return
;
}
textureMatrix
=
&
tempMatrix
;
}
sk_sp
<
GrFragmentProcessor
>
fp
(
producer
-
>
createFragmentProcessor
(
*
textureMatrix
clippedSrcRect
constraintMode
coordsAllInsideSrcRect
filterMode
fRenderTargetContext
-
>
getColorSpace
(
)
)
)
;
if
(
!
fp
)
{
return
;
}
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaintWithTexture
(
fContext
.
get
(
)
fRenderTargetContext
.
get
(
)
paint
viewMatrix
fp
producer
-
>
isAlphaOnly
(
)
&
grPaint
)
)
{
return
;
}
GrAA
aa
=
GrBoolToAA
(
paint
.
isAntiAlias
(
)
)
;
if
(
canUseTextureCoordsAsLocalCoords
)
{
fRenderTargetContext
-
>
fillRectToRect
(
clip
std
:
:
move
(
grPaint
)
aa
viewMatrix
clippedDstRect
clippedSrcRect
)
;
return
;
}
if
(
!
mf
)
{
fRenderTargetContext
-
>
drawRect
(
clip
std
:
:
move
(
grPaint
)
aa
viewMatrix
clippedDstRect
)
;
return
;
}
if
(
viewMatrix
.
isScaleTranslate
(
)
)
{
SkRect
devClippedDstRect
;
viewMatrix
.
mapRectScaleTranslate
(
&
devClippedDstRect
clippedDstRect
)
;
SkStrokeRec
rec
(
SkStrokeRec
:
:
kFill_InitStyle
)
;
if
(
mf
-
>
directFilterRRectMaskGPU
(
fContext
.
get
(
)
fRenderTargetContext
.
get
(
)
std
:
:
move
(
grPaint
)
clip
viewMatrix
rec
SkRRect
:
:
MakeRect
(
clippedDstRect
)
SkRRect
:
:
MakeRect
(
devClippedDstRect
)
)
)
{
return
;
}
}
SkPath
rectPath
;
rectPath
.
addRect
(
clippedDstRect
)
;
rectPath
.
setIsVolatile
(
true
)
;
GrBlurUtils
:
:
drawPathWithMaskFilter
(
this
-
>
context
(
)
fRenderTargetContext
.
get
(
)
this
-
>
clip
(
)
rectPath
std
:
:
move
(
grPaint
)
aa
viewMatrix
mf
GrStyle
:
:
SimpleFill
(
)
true
)
;
}
