#
include
"
src
/
gpu
/
SkGpuDevice
.
h
"
#
include
"
include
/
core
/
SkYUVAIndex
.
h
"
#
include
"
src
/
core
/
SkDraw
.
h
"
#
include
"
src
/
core
/
SkMaskFilterBase
.
h
"
#
include
"
src
/
gpu
/
GrBitmapTextureMaker
.
h
"
#
include
"
src
/
gpu
/
GrBlurUtils
.
h
"
#
include
"
src
/
gpu
/
GrCaps
.
h
"
#
include
"
src
/
gpu
/
GrColorSpaceXform
.
h
"
#
include
"
src
/
gpu
/
GrImageTextureMaker
.
h
"
#
include
"
src
/
gpu
/
GrRenderTargetContext
.
h
"
#
include
"
src
/
gpu
/
GrStyle
.
h
"
#
include
"
src
/
gpu
/
GrTextureAdjuster
.
h
"
#
include
"
src
/
gpu
/
GrTextureMaker
.
h
"
#
include
"
src
/
gpu
/
SkGr
.
h
"
#
include
"
src
/
gpu
/
effects
/
GrBicubicEffect
.
h
"
#
include
"
src
/
gpu
/
effects
/
GrTextureDomain
.
h
"
#
include
"
src
/
gpu
/
effects
/
generated
/
GrSimpleTextureEffect
.
h
"
#
include
"
src
/
gpu
/
geometry
/
GrShape
.
h
"
#
include
"
src
/
image
/
SkImage_Base
.
h
"
namespace
{
static
inline
bool
use_shader
(
bool
textureIsAlphaOnly
const
SkPaint
&
paint
)
{
return
textureIsAlphaOnly
&
&
paint
.
getShader
(
)
;
}
static
const
SkScalar
kColorBleedTolerance
=
0
.
001f
;
static
bool
has_aligned_samples
(
const
SkRect
&
srcRect
const
SkRect
&
transformedRect
)
{
if
(
SkScalarAbs
(
SkScalarRoundToScalar
(
transformedRect
.
left
(
)
)
-
transformedRect
.
left
(
)
)
<
kColorBleedTolerance
&
&
SkScalarAbs
(
SkScalarRoundToScalar
(
transformedRect
.
top
(
)
)
-
transformedRect
.
top
(
)
)
<
kColorBleedTolerance
&
&
SkScalarAbs
(
transformedRect
.
width
(
)
-
srcRect
.
width
(
)
)
<
kColorBleedTolerance
&
&
SkScalarAbs
(
transformedRect
.
height
(
)
-
srcRect
.
height
(
)
)
<
kColorBleedTolerance
)
{
return
true
;
}
return
false
;
}
static
bool
may_color_bleed
(
const
SkRect
&
srcRect
const
SkRect
&
transformedRect
const
SkMatrix
&
m
int
numSamples
)
{
SkASSERT
(
!
has_aligned_samples
(
srcRect
transformedRect
)
)
;
SkRect
innerSrcRect
(
srcRect
)
innerTransformedRect
outerTransformedRect
(
transformedRect
)
;
if
(
numSamples
>
1
)
{
innerSrcRect
.
inset
(
SK_Scalar1
SK_Scalar1
)
;
}
else
{
innerSrcRect
.
inset
(
SK_ScalarHalf
SK_ScalarHalf
)
;
}
m
.
mapRect
(
&
innerTransformedRect
innerSrcRect
)
;
outerTransformedRect
.
inset
(
kColorBleedTolerance
kColorBleedTolerance
)
;
innerTransformedRect
.
outset
(
kColorBleedTolerance
kColorBleedTolerance
)
;
SkIRect
outer
inner
;
outerTransformedRect
.
round
(
&
outer
)
;
innerTransformedRect
.
round
(
&
inner
)
;
return
inner
!
=
outer
;
}
static
bool
can_ignore_bilerp_constraint
(
const
GrTextureProducer
&
producer
const
SkRect
&
srcRect
const
SkMatrix
&
srcRectToDeviceSpace
int
numSamples
)
{
if
(
srcRectToDeviceSpace
.
rectStaysRect
(
)
)
{
SkRect
transformedRect
;
srcRectToDeviceSpace
.
mapRect
(
&
transformedRect
srcRect
)
;
if
(
has_aligned_samples
(
srcRect
transformedRect
)
|
|
!
may_color_bleed
(
srcRect
transformedRect
srcRectToDeviceSpace
numSamples
)
)
{
return
true
;
}
}
return
false
;
}
enum
class
ImageDrawMode
{
kOptimized
kDecal
kSkip
}
;
static
ImageDrawMode
optimize_sample_area
(
const
SkISize
&
image
const
SkRect
*
origSrcRect
const
SkRect
*
origDstRect
const
SkPoint
dstClip
[
4
]
SkRect
*
outSrcRect
SkRect
*
outDstRect
SkMatrix
*
srcToDst
)
{
SkRect
srcBounds
=
SkRect
:
:
MakeIWH
(
image
.
fWidth
image
.
fHeight
)
;
SkRect
src
=
origSrcRect
?
*
origSrcRect
:
srcBounds
;
SkRect
dst
=
origDstRect
?
*
origDstRect
:
src
;
if
(
src
.
isEmpty
(
)
|
|
dst
.
isEmpty
(
)
)
{
return
ImageDrawMode
:
:
kSkip
;
}
if
(
outDstRect
)
{
srcToDst
-
>
setRectToRect
(
src
dst
SkMatrix
:
:
kFill_ScaleToFit
)
;
}
else
{
srcToDst
-
>
setIdentity
(
)
;
}
if
(
origSrcRect
&
&
!
srcBounds
.
contains
(
src
)
)
{
if
(
!
src
.
intersect
(
srcBounds
)
)
{
return
ImageDrawMode
:
:
kSkip
;
}
srcToDst
-
>
mapRect
(
&
dst
src
)
;
if
(
dstClip
)
{
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
if
(
!
dst
.
contains
(
dstClip
[
i
]
.
fX
dstClip
[
i
]
.
fY
)
)
{
*
outSrcRect
=
src
;
*
outDstRect
=
(
origDstRect
?
*
origDstRect
:
(
origSrcRect
?
*
origSrcRect
:
srcBounds
)
)
;
return
ImageDrawMode
:
:
kDecal
;
}
}
}
}
*
outSrcRect
=
src
;
*
outDstRect
=
dst
;
return
ImageDrawMode
:
:
kOptimized
;
}
static
bool
can_use_draw_texture
(
const
SkPaint
&
paint
)
{
return
(
!
paint
.
getColorFilter
(
)
&
&
!
paint
.
getShader
(
)
&
&
!
paint
.
getMaskFilter
(
)
&
&
!
paint
.
getImageFilter
(
)
&
&
paint
.
getFilterQuality
(
)
<
kMedium_SkFilterQuality
)
;
}
static
void
draw_texture
(
GrRenderTargetContext
*
rtc
const
GrClip
&
clip
const
SkMatrix
&
ctm
const
SkPaint
&
paint
const
SkRect
&
srcRect
const
SkRect
&
dstRect
const
SkPoint
dstClip
[
4
]
GrAA
aa
GrQuadAAFlags
aaFlags
SkCanvas
:
:
SrcRectConstraint
constraint
sk_sp
<
GrTextureProxy
>
proxy
const
GrColorInfo
&
srcColorInfo
)
{
const
GrColorInfo
&
dstInfo
(
rtc
-
>
colorInfo
(
)
)
;
auto
textureXform
=
GrColorSpaceXform
:
:
Make
(
srcColorInfo
.
colorSpace
(
)
srcColorInfo
.
alphaType
(
)
dstInfo
.
colorSpace
(
)
kPremul_SkAlphaType
)
;
GrSamplerState
:
:
Filter
filter
;
switch
(
paint
.
getFilterQuality
(
)
)
{
case
kNone_SkFilterQuality
:
filter
=
GrSamplerState
:
:
Filter
:
:
kNearest
;
break
;
case
kLow_SkFilterQuality
:
filter
=
GrSamplerState
:
:
Filter
:
:
kBilerp
;
break
;
case
kMedium_SkFilterQuality
:
case
kHigh_SkFilterQuality
:
SK_ABORT
(
"
Quality
level
not
allowed
.
"
)
;
}
if
(
constraint
!
=
SkCanvas
:
:
kStrict_SrcRectConstraint
&
&
!
GrProxyProvider
:
:
IsFunctionallyExact
(
proxy
.
get
(
)
)
)
{
float
buffer
=
0
.
5f
*
(
aa
=
=
GrAA
:
:
kYes
)
+
0
.
5f
*
(
filter
=
=
GrSamplerState
:
:
Filter
:
:
kBilerp
)
;
SkRect
safeBounds
=
SkRect
:
:
MakeWH
(
proxy
-
>
width
(
)
proxy
-
>
height
(
)
)
;
safeBounds
.
inset
(
buffer
buffer
)
;
if
(
!
safeBounds
.
contains
(
srcRect
)
)
{
constraint
=
SkCanvas
:
:
kStrict_SrcRectConstraint
;
}
}
SkPMColor4f
color
;
if
(
GrColorTypeIsAlphaOnly
(
srcColorInfo
.
colorType
(
)
)
)
{
color
=
SkColor4fPrepForDst
(
paint
.
getColor4f
(
)
dstInfo
)
.
premul
(
)
;
}
else
{
float
paintAlpha
=
paint
.
getColor4f
(
)
.
fA
;
color
=
{
paintAlpha
paintAlpha
paintAlpha
paintAlpha
}
;
}
if
(
dstClip
)
{
SkPoint
srcQuad
[
4
]
;
GrMapRectPoints
(
dstRect
srcRect
dstClip
srcQuad
4
)
;
rtc
-
>
drawTextureQuad
(
clip
std
:
:
move
(
proxy
)
srcColorInfo
.
colorType
(
)
filter
paint
.
getBlendMode
(
)
color
srcQuad
dstClip
aa
aaFlags
constraint
=
=
SkCanvas
:
:
kStrict_SrcRectConstraint
?
&
srcRect
:
nullptr
ctm
std
:
:
move
(
textureXform
)
)
;
}
else
{
rtc
-
>
drawTexture
(
clip
std
:
:
move
(
proxy
)
srcColorInfo
.
colorType
(
)
filter
paint
.
getBlendMode
(
)
color
srcRect
dstRect
aa
aaFlags
constraint
ctm
std
:
:
move
(
textureXform
)
)
;
}
}
static
void
draw_texture_producer
(
GrContext
*
context
GrRenderTargetContext
*
rtc
const
GrClip
&
clip
const
SkMatrix
&
ctm
const
SkPaint
&
paint
GrTextureProducer
*
producer
const
SkRect
&
src
const
SkRect
&
dst
const
SkPoint
dstClip
[
4
]
const
SkMatrix
&
srcToDst
GrAA
aa
GrQuadAAFlags
aaFlags
SkCanvas
:
:
SrcRectConstraint
constraint
bool
attemptDrawTexture
)
{
if
(
attemptDrawTexture
&
&
can_use_draw_texture
(
paint
)
)
{
auto
proxy
=
producer
-
>
refTextureProxyForParams
(
GrSamplerState
:
:
ClampNearest
(
)
nullptr
)
;
if
(
!
proxy
)
{
return
;
}
draw_texture
(
rtc
clip
ctm
paint
src
dst
dstClip
aa
aaFlags
constraint
std
:
:
move
(
proxy
)
producer
-
>
colorInfo
(
)
)
;
return
;
}
const
SkMaskFilter
*
mf
=
paint
.
getMaskFilter
(
)
;
bool
canUseTextureCoordsAsLocalCoords
=
!
use_shader
(
producer
-
>
isAlphaOnly
(
)
paint
)
&
&
!
mf
;
if
(
mf
&
&
as_MFB
(
mf
)
-
>
hasFragmentProcessor
(
)
)
{
mf
=
nullptr
;
}
bool
doBicubic
;
GrSamplerState
:
:
Filter
fm
=
GrSkFilterQualityToGrFilterMode
(
producer
-
>
width
(
)
producer
-
>
height
(
)
paint
.
getFilterQuality
(
)
ctm
srcToDst
context
-
>
priv
(
)
.
options
(
)
.
fSharpenMipmappedTextures
&
doBicubic
)
;
const
GrSamplerState
:
:
Filter
*
filterMode
=
doBicubic
?
nullptr
:
&
fm
;
GrTextureProducer
:
:
FilterConstraint
constraintMode
;
if
(
SkCanvas
:
:
kFast_SrcRectConstraint
=
=
constraint
)
{
constraintMode
=
GrTextureAdjuster
:
:
kNo_FilterConstraint
;
}
else
{
constraintMode
=
GrTextureAdjuster
:
:
kYes_FilterConstraint
;
}
bool
coordsAllInsideSrcRect
=
aaFlags
=
=
GrQuadAAFlags
:
:
kNone
&
&
!
mf
;
if
(
filterMode
&
&
GrSamplerState
:
:
Filter
:
:
kBilerp
=
=
*
filterMode
&
&
GrTextureAdjuster
:
:
kYes_FilterConstraint
=
=
constraintMode
&
&
coordsAllInsideSrcRect
&
&
!
producer
-
>
hasMixedResolutions
(
)
)
{
SkMatrix
combinedMatrix
;
combinedMatrix
.
setConcat
(
ctm
srcToDst
)
;
if
(
can_ignore_bilerp_constraint
(
*
producer
src
combinedMatrix
rtc
-
>
numSamples
(
)
)
)
{
constraintMode
=
GrTextureAdjuster
:
:
kNo_FilterConstraint
;
}
}
SkMatrix
textureMatrix
;
if
(
canUseTextureCoordsAsLocalCoords
)
{
textureMatrix
=
SkMatrix
:
:
I
(
)
;
}
else
{
if
(
!
srcToDst
.
invert
(
&
textureMatrix
)
)
{
return
;
}
}
auto
fp
=
producer
-
>
createFragmentProcessor
(
textureMatrix
src
constraintMode
coordsAllInsideSrcRect
filterMode
)
;
fp
=
GrColorSpaceXformEffect
:
:
Make
(
std
:
:
move
(
fp
)
producer
-
>
colorSpace
(
)
producer
-
>
alphaType
(
)
rtc
-
>
colorInfo
(
)
.
colorSpace
(
)
)
;
if
(
!
fp
)
{
return
;
}
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaintWithTexture
(
context
rtc
-
>
colorInfo
(
)
paint
ctm
std
:
:
move
(
fp
)
producer
-
>
isAlphaOnly
(
)
&
grPaint
)
)
{
return
;
}
if
(
!
mf
)
{
if
(
dstClip
)
{
SkPoint
srcClipPoints
[
4
]
;
SkPoint
*
srcClip
=
nullptr
;
if
(
canUseTextureCoordsAsLocalCoords
)
{
GrMapRectPoints
(
dst
src
dstClip
srcClipPoints
4
)
;
srcClip
=
srcClipPoints
;
}
rtc
-
>
fillQuadWithEdgeAA
(
clip
std
:
:
move
(
grPaint
)
aa
aaFlags
ctm
dstClip
srcClip
)
;
}
else
{
rtc
-
>
fillRectWithEdgeAA
(
clip
std
:
:
move
(
grPaint
)
aa
aaFlags
ctm
dst
canUseTextureCoordsAsLocalCoords
?
&
src
:
nullptr
)
;
}
}
else
{
GrShape
shape
;
if
(
dstClip
)
{
SkPath
path
;
path
.
addPoly
(
dstClip
4
true
)
;
shape
=
GrShape
(
path
)
;
}
else
{
shape
=
GrShape
(
dst
)
;
}
GrBlurUtils
:
:
drawShapeWithMaskFilter
(
context
rtc
clip
shape
std
:
:
move
(
grPaint
)
ctm
mf
)
;
}
}
}
void
SkGpuDevice
:
:
drawImageQuad
(
const
SkImage
*
image
const
SkRect
*
srcRect
const
SkRect
*
dstRect
const
SkPoint
dstClip
[
4
]
GrAA
aa
GrQuadAAFlags
aaFlags
const
SkMatrix
*
preViewMatrix
const
SkPaint
&
paint
SkCanvas
:
:
SrcRectConstraint
constraint
)
{
SkRect
src
;
SkRect
dst
;
SkMatrix
srcToDst
;
ImageDrawMode
mode
=
optimize_sample_area
(
SkISize
:
:
Make
(
image
-
>
width
(
)
image
-
>
height
(
)
)
srcRect
dstRect
dstClip
&
src
&
dst
&
srcToDst
)
;
if
(
mode
=
=
ImageDrawMode
:
:
kSkip
)
{
return
;
}
if
(
src
.
contains
(
image
-
>
bounds
(
)
)
)
{
constraint
=
SkCanvas
:
:
kFast_SrcRectConstraint
;
}
bool
useDecal
=
mode
=
=
ImageDrawMode
:
:
kDecal
;
bool
attemptDrawTexture
=
!
useDecal
;
SkMatrix
ctm
=
this
-
>
ctm
(
)
;
if
(
preViewMatrix
)
{
ctm
.
preConcat
(
*
preViewMatrix
)
;
}
if
(
as_IB
(
image
)
-
>
isYUVA
(
)
)
{
SK_HISTOGRAM_BOOLEAN
(
"
DrawTiled
"
false
)
;
LogDrawScaleFactor
(
ctm
srcToDst
paint
.
getFilterQuality
(
)
)
;
GrYUVAImageTextureMaker
maker
(
fContext
.
get
(
)
image
useDecal
)
;
draw_texture_producer
(
fContext
.
get
(
)
fRenderTargetContext
.
get
(
)
this
-
>
clip
(
)
ctm
paint
&
maker
src
dst
dstClip
srcToDst
aa
aaFlags
constraint
false
)
;
return
;
}
uint32_t
pinnedUniqueID
;
if
(
sk_sp
<
GrTextureProxy
>
proxy
=
as_IB
(
image
)
-
>
refPinnedTextureProxy
(
this
-
>
context
(
)
&
pinnedUniqueID
)
)
{
SK_HISTOGRAM_BOOLEAN
(
"
DrawTiled
"
false
)
;
LogDrawScaleFactor
(
ctm
srcToDst
paint
.
getFilterQuality
(
)
)
;
GrColorInfo
colorInfo
(
image
-
>
imageInfo
(
)
.
colorInfo
(
)
)
;
if
(
attemptDrawTexture
&
&
can_use_draw_texture
(
paint
)
)
{
draw_texture
(
fRenderTargetContext
.
get
(
)
this
-
>
clip
(
)
ctm
paint
src
dst
dstClip
aa
aaFlags
constraint
std
:
:
move
(
proxy
)
colorInfo
)
;
return
;
}
GrTextureAdjuster
adjuster
(
fContext
.
get
(
)
std
:
:
move
(
proxy
)
colorInfo
pinnedUniqueID
useDecal
)
;
draw_texture_producer
(
fContext
.
get
(
)
fRenderTargetContext
.
get
(
)
this
-
>
clip
(
)
ctm
paint
&
adjuster
src
dst
dstClip
srcToDst
aa
aaFlags
constraint
false
)
;
return
;
}
SkBitmap
bm
;
if
(
this
-
>
shouldTileImage
(
image
&
src
constraint
paint
.
getFilterQuality
(
)
ctm
srcToDst
)
)
{
if
(
!
as_IB
(
image
)
-
>
getROPixels
(
&
bm
)
)
{
return
;
}
this
-
>
drawBitmapRect
(
bm
&
src
dst
paint
constraint
)
;
return
;
}
SK_HISTOGRAM_BOOLEAN
(
"
DrawTiled
"
false
)
;
LogDrawScaleFactor
(
ctm
srcToDst
paint
.
getFilterQuality
(
)
)
;
if
(
image
-
>
isLazyGenerated
(
)
)
{
GrImageTextureMaker
maker
(
fContext
.
get
(
)
image
SkImage
:
:
kAllow_CachingHint
useDecal
)
;
draw_texture_producer
(
fContext
.
get
(
)
fRenderTargetContext
.
get
(
)
this
-
>
clip
(
)
ctm
paint
&
maker
src
dst
dstClip
srcToDst
aa
aaFlags
constraint
attemptDrawTexture
)
;
return
;
}
if
(
as_IB
(
image
)
-
>
getROPixels
(
&
bm
)
)
{
GrBitmapTextureMaker
maker
(
fContext
.
get
(
)
bm
useDecal
)
;
draw_texture_producer
(
fContext
.
get
(
)
fRenderTargetContext
.
get
(
)
this
-
>
clip
(
)
ctm
paint
&
maker
src
dst
dstClip
srcToDst
aa
aaFlags
constraint
attemptDrawTexture
)
;
}
}
void
SkGpuDevice
:
:
drawEdgeAAImageSet
(
const
SkCanvas
:
:
ImageSetEntry
set
[
]
int
count
const
SkPoint
dstClips
[
]
const
SkMatrix
preViewMatrices
[
]
const
SkPaint
&
paint
SkCanvas
:
:
SrcRectConstraint
constraint
)
{
SkASSERT
(
count
>
0
)
;
if
(
!
can_use_draw_texture
(
paint
)
)
{
int
dstClipIndex
=
0
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
SkASSERT
(
!
set
[
i
]
.
fHasClip
|
|
dstClips
)
;
SkASSERT
(
set
[
i
]
.
fMatrixIndex
<
0
|
|
preViewMatrices
)
;
SkTCopyOnFirstWrite
<
SkPaint
>
entryPaint
(
paint
)
;
if
(
set
[
i
]
.
fAlpha
!
=
1
.
f
)
{
auto
paintAlpha
=
paint
.
getAlphaf
(
)
;
entryPaint
.
writable
(
)
-
>
setAlphaf
(
paintAlpha
*
set
[
i
]
.
fAlpha
)
;
}
this
-
>
drawImageQuad
(
set
[
i
]
.
fImage
.
get
(
)
&
set
[
i
]
.
fSrcRect
&
set
[
i
]
.
fDstRect
set
[
i
]
.
fHasClip
?
dstClips
+
dstClipIndex
:
nullptr
GrAA
:
:
kYes
SkToGrQuadAAFlags
(
set
[
i
]
.
fAAFlags
)
set
[
i
]
.
fMatrixIndex
<
0
?
nullptr
:
preViewMatrices
+
set
[
i
]
.
fMatrixIndex
*
entryPaint
constraint
)
;
dstClipIndex
+
=
4
*
set
[
i
]
.
fHasClip
;
}
return
;
}
GrSamplerState
:
:
Filter
filter
=
kNone_SkFilterQuality
=
=
paint
.
getFilterQuality
(
)
?
GrSamplerState
:
:
Filter
:
:
kNearest
:
GrSamplerState
:
:
Filter
:
:
kBilerp
;
SkBlendMode
mode
=
paint
.
getBlendMode
(
)
;
SkAutoTArray
<
GrRenderTargetContext
:
:
TextureSetEntry
>
textures
(
count
)
;
int
base
=
0
n
=
0
;
auto
draw
=
[
&
]
{
if
(
n
>
0
)
{
auto
textureXform
=
GrColorSpaceXform
:
:
Make
(
set
[
base
]
.
fImage
-
>
colorSpace
(
)
set
[
base
]
.
fImage
-
>
alphaType
(
)
fRenderTargetContext
-
>
colorInfo
(
)
.
colorSpace
(
)
kPremul_SkAlphaType
)
;
fRenderTargetContext
-
>
drawTextureSet
(
this
-
>
clip
(
)
textures
.
get
(
)
+
base
n
filter
mode
GrAA
:
:
kYes
constraint
this
-
>
ctm
(
)
std
:
:
move
(
textureXform
)
)
;
}
}
;
int
dstClipIndex
=
0
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
SkASSERT
(
!
set
[
i
]
.
fHasClip
|
|
dstClips
)
;
SkASSERT
(
set
[
i
]
.
fMatrixIndex
<
0
|
|
preViewMatrices
)
;
const
SkPoint
*
clip
=
set
[
i
]
.
fHasClip
?
dstClips
+
dstClipIndex
:
nullptr
;
dstClipIndex
+
=
4
*
set
[
i
]
.
fHasClip
;
if
(
!
set
[
i
]
.
fSrcRect
.
isSorted
(
)
)
{
draw
(
)
;
base
=
i
+
1
;
n
=
0
;
continue
;
}
sk_sp
<
GrTextureProxy
>
proxy
;
const
SkImage_Base
*
image
=
as_IB
(
set
[
i
]
.
fImage
.
get
(
)
)
;
if
(
!
image
-
>
isYUVA
(
)
)
{
uint32_t
uniqueID
;
proxy
=
image
-
>
refPinnedTextureProxy
(
this
-
>
context
(
)
&
uniqueID
)
;
if
(
!
proxy
)
{
proxy
=
image
-
>
asTextureProxyRef
(
this
-
>
context
(
)
GrSamplerState
:
:
ClampBilerp
(
)
nullptr
)
;
}
}
if
(
!
proxy
)
{
draw
(
)
;
base
=
i
+
1
;
n
=
0
;
SkTCopyOnFirstWrite
<
SkPaint
>
entryPaint
(
paint
)
;
if
(
set
[
i
]
.
fAlpha
!
=
1
.
f
)
{
auto
paintAlpha
=
paint
.
getAlphaf
(
)
;
entryPaint
.
writable
(
)
-
>
setAlphaf
(
paintAlpha
*
set
[
i
]
.
fAlpha
)
;
}
this
-
>
drawImageQuad
(
image
&
set
[
i
]
.
fSrcRect
&
set
[
i
]
.
fDstRect
clip
GrAA
:
:
kYes
SkToGrQuadAAFlags
(
set
[
i
]
.
fAAFlags
)
set
[
i
]
.
fMatrixIndex
<
0
?
nullptr
:
preViewMatrices
+
set
[
i
]
.
fMatrixIndex
*
entryPaint
constraint
)
;
continue
;
}
textures
[
i
]
.
fProxy
=
std
:
:
move
(
proxy
)
;
textures
[
i
]
.
fSrcColorType
=
SkColorTypeToGrColorType
(
image
-
>
colorType
(
)
)
;
textures
[
i
]
.
fSrcRect
=
set
[
i
]
.
fSrcRect
;
textures
[
i
]
.
fDstRect
=
set
[
i
]
.
fDstRect
;
textures
[
i
]
.
fDstClipQuad
=
clip
;
textures
[
i
]
.
fPreViewMatrix
=
set
[
i
]
.
fMatrixIndex
<
0
?
nullptr
:
preViewMatrices
+
set
[
i
]
.
fMatrixIndex
;
textures
[
i
]
.
fAlpha
=
set
[
i
]
.
fAlpha
*
paint
.
getAlphaf
(
)
;
textures
[
i
]
.
fAAFlags
=
SkToGrQuadAAFlags
(
set
[
i
]
.
fAAFlags
)
;
if
(
n
>
0
&
&
(
!
GrTextureProxy
:
:
ProxiesAreCompatibleAsDynamicState
(
textures
[
i
]
.
fProxy
.
get
(
)
textures
[
base
]
.
fProxy
.
get
(
)
)
|
|
set
[
i
]
.
fImage
-
>
alphaType
(
)
!
=
set
[
base
]
.
fImage
-
>
alphaType
(
)
|
|
!
SkColorSpace
:
:
Equals
(
set
[
i
]
.
fImage
-
>
colorSpace
(
)
set
[
base
]
.
fImage
-
>
colorSpace
(
)
)
)
)
{
draw
(
)
;
base
=
i
;
n
=
1
;
}
else
{
+
+
n
;
}
}
draw
(
)
;
}
void
SkGpuDevice
:
:
drawTextureProducer
(
GrTextureProducer
*
producer
const
SkRect
*
srcRect
const
SkRect
*
dstRect
SkCanvas
:
:
SrcRectConstraint
constraint
const
SkMatrix
&
viewMatrix
const
SkPaint
&
paint
bool
attemptDrawTexture
)
{
SkRect
src
;
SkRect
dst
;
SkMatrix
srcToDst
;
ImageDrawMode
mode
=
optimize_sample_area
(
SkISize
:
:
Make
(
producer
-
>
width
(
)
producer
-
>
height
(
)
)
srcRect
dstRect
nullptr
&
src
&
dst
&
srcToDst
)
;
if
(
mode
=
=
ImageDrawMode
:
:
kSkip
)
{
return
;
}
SkASSERT
(
mode
!
=
ImageDrawMode
:
:
kDecal
)
;
draw_texture_producer
(
fContext
.
get
(
)
fRenderTargetContext
.
get
(
)
this
-
>
clip
(
)
viewMatrix
paint
producer
src
dst
nullptr
srcToDst
GrAA
(
paint
.
isAntiAlias
(
)
)
paint
.
isAntiAlias
(
)
?
GrQuadAAFlags
:
:
kAll
:
GrQuadAAFlags
:
:
kNone
constraint
attemptDrawTexture
)
;
}
