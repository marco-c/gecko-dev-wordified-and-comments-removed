#
include
"
SkGpuDevice
.
h
"
#
include
"
GrBitmapTextureMaker
.
h
"
#
include
"
GrBlurUtils
.
h
"
#
include
"
GrCaps
.
h
"
#
include
"
GrColorSpaceXform
.
h
"
#
include
"
GrImageTextureMaker
.
h
"
#
include
"
GrRenderTargetContext
.
h
"
#
include
"
GrShape
.
h
"
#
include
"
GrStyle
.
h
"
#
include
"
GrTextureAdjuster
.
h
"
#
include
"
GrTextureMaker
.
h
"
#
include
"
SkDraw
.
h
"
#
include
"
SkGr
.
h
"
#
include
"
SkImage_Base
.
h
"
#
include
"
SkMaskFilterBase
.
h
"
#
include
"
SkYUVAIndex
.
h
"
#
include
"
effects
/
GrBicubicEffect
.
h
"
#
include
"
effects
/
GrSimpleTextureEffect
.
h
"
#
include
"
effects
/
GrTextureDomain
.
h
"
namespace
{
static
inline
bool
use_shader
(
bool
textureIsAlphaOnly
const
SkPaint
&
paint
)
{
return
textureIsAlphaOnly
&
&
paint
.
getShader
(
)
;
}
static
const
SkScalar
kColorBleedTolerance
=
0
.
001f
;
static
bool
has_aligned_samples
(
const
SkRect
&
srcRect
const
SkRect
&
transformedRect
)
{
if
(
SkScalarAbs
(
SkScalarRoundToScalar
(
transformedRect
.
left
(
)
)
-
transformedRect
.
left
(
)
)
<
kColorBleedTolerance
&
&
SkScalarAbs
(
SkScalarRoundToScalar
(
transformedRect
.
top
(
)
)
-
transformedRect
.
top
(
)
)
<
kColorBleedTolerance
&
&
SkScalarAbs
(
transformedRect
.
width
(
)
-
srcRect
.
width
(
)
)
<
kColorBleedTolerance
&
&
SkScalarAbs
(
transformedRect
.
height
(
)
-
srcRect
.
height
(
)
)
<
kColorBleedTolerance
)
{
return
true
;
}
return
false
;
}
static
bool
may_color_bleed
(
const
SkRect
&
srcRect
const
SkRect
&
transformedRect
const
SkMatrix
&
m
GrFSAAType
fsaaType
)
{
SkASSERT
(
!
has_aligned_samples
(
srcRect
transformedRect
)
)
;
SkRect
innerSrcRect
(
srcRect
)
innerTransformedRect
outerTransformedRect
(
transformedRect
)
;
if
(
GrFSAAType
:
:
kUnifiedMSAA
=
=
fsaaType
)
{
innerSrcRect
.
inset
(
SK_Scalar1
SK_Scalar1
)
;
}
else
{
innerSrcRect
.
inset
(
SK_ScalarHalf
SK_ScalarHalf
)
;
}
m
.
mapRect
(
&
innerTransformedRect
innerSrcRect
)
;
outerTransformedRect
.
inset
(
kColorBleedTolerance
kColorBleedTolerance
)
;
innerTransformedRect
.
outset
(
kColorBleedTolerance
kColorBleedTolerance
)
;
SkIRect
outer
inner
;
outerTransformedRect
.
round
(
&
outer
)
;
innerTransformedRect
.
round
(
&
inner
)
;
return
inner
!
=
outer
;
}
static
bool
can_ignore_bilerp_constraint
(
const
GrTextureProducer
&
producer
const
SkRect
&
srcRect
const
SkMatrix
&
srcRectToDeviceSpace
GrFSAAType
fsaaType
)
{
if
(
srcRectToDeviceSpace
.
rectStaysRect
(
)
)
{
SkRect
transformedRect
;
srcRectToDeviceSpace
.
mapRect
(
&
transformedRect
srcRect
)
;
if
(
has_aligned_samples
(
srcRect
transformedRect
)
|
|
!
may_color_bleed
(
srcRect
transformedRect
srcRectToDeviceSpace
fsaaType
)
)
{
return
true
;
}
}
return
false
;
}
enum
class
ImageDrawMode
{
kOptimized
kDecal
kSkip
}
;
static
ImageDrawMode
optimize_sample_area
(
const
SkISize
&
image
const
SkRect
*
origSrcRect
const
SkRect
*
origDstRect
const
SkPoint
dstClip
[
4
]
SkRect
*
outSrcRect
SkRect
*
outDstRect
SkMatrix
*
srcToDst
)
{
SkRect
srcBounds
=
SkRect
:
:
MakeIWH
(
image
.
fWidth
image
.
fHeight
)
;
SkRect
src
=
origSrcRect
?
*
origSrcRect
:
srcBounds
;
SkRect
dst
=
origDstRect
?
*
origDstRect
:
src
;
if
(
src
.
isEmpty
(
)
|
|
dst
.
isEmpty
(
)
)
{
return
ImageDrawMode
:
:
kSkip
;
}
if
(
outDstRect
)
{
srcToDst
-
>
setRectToRect
(
src
dst
SkMatrix
:
:
kFill_ScaleToFit
)
;
}
else
{
srcToDst
-
>
setIdentity
(
)
;
}
if
(
origSrcRect
&
&
!
srcBounds
.
contains
(
src
)
)
{
if
(
!
src
.
intersect
(
srcBounds
)
)
{
return
ImageDrawMode
:
:
kSkip
;
}
srcToDst
-
>
mapRect
(
&
dst
src
)
;
if
(
dstClip
)
{
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
if
(
!
dst
.
contains
(
dstClip
[
i
]
.
fX
dstClip
[
i
]
.
fY
)
)
{
*
outSrcRect
=
src
;
*
outDstRect
=
(
origDstRect
?
*
origDstRect
:
(
origSrcRect
?
*
origSrcRect
:
srcBounds
)
)
;
return
ImageDrawMode
:
:
kDecal
;
}
}
}
}
*
outSrcRect
=
src
;
*
outDstRect
=
dst
;
return
ImageDrawMode
:
:
kOptimized
;
}
static
bool
can_use_draw_texture
(
const
SkPaint
&
paint
)
{
return
(
!
paint
.
getColorFilter
(
)
&
&
!
paint
.
getShader
(
)
&
&
!
paint
.
getMaskFilter
(
)
&
&
!
paint
.
getImageFilter
(
)
&
&
paint
.
getFilterQuality
(
)
<
kMedium_SkFilterQuality
)
;
}
static
void
draw_texture
(
GrRenderTargetContext
*
rtc
const
GrClip
&
clip
const
SkMatrix
&
ctm
const
SkPaint
&
paint
const
SkRect
&
srcRect
const
SkRect
&
dstRect
const
SkPoint
dstClip
[
4
]
GrAA
aa
GrQuadAAFlags
aaFlags
SkCanvas
:
:
SrcRectConstraint
constraint
sk_sp
<
GrTextureProxy
>
proxy
SkAlphaType
alphaType
SkColorSpace
*
colorSpace
)
{
const
GrColorSpaceInfo
&
dstInfo
(
rtc
-
>
colorSpaceInfo
(
)
)
;
auto
textureXform
=
GrColorSpaceXform
:
:
Make
(
colorSpace
alphaType
dstInfo
.
colorSpace
(
)
kPremul_SkAlphaType
)
;
GrSamplerState
:
:
Filter
filter
;
switch
(
paint
.
getFilterQuality
(
)
)
{
case
kNone_SkFilterQuality
:
filter
=
GrSamplerState
:
:
Filter
:
:
kNearest
;
break
;
case
kLow_SkFilterQuality
:
filter
=
GrSamplerState
:
:
Filter
:
:
kBilerp
;
break
;
case
kMedium_SkFilterQuality
:
case
kHigh_SkFilterQuality
:
SK_ABORT
(
"
Quality
level
not
allowed
.
"
)
;
}
if
(
constraint
!
=
SkCanvas
:
:
kStrict_SrcRectConstraint
&
&
!
GrProxyProvider
:
:
IsFunctionallyExact
(
proxy
.
get
(
)
)
)
{
float
buffer
=
0
.
5f
*
(
aa
=
=
GrAA
:
:
kYes
)
+
0
.
5f
*
(
filter
=
=
GrSamplerState
:
:
Filter
:
:
kBilerp
)
;
SkRect
safeBounds
=
SkRect
:
:
MakeWH
(
proxy
-
>
width
(
)
proxy
-
>
height
(
)
)
;
safeBounds
.
inset
(
buffer
buffer
)
;
if
(
!
safeBounds
.
contains
(
srcRect
)
)
{
constraint
=
SkCanvas
:
:
kStrict_SrcRectConstraint
;
}
}
SkPMColor4f
color
;
if
(
GrPixelConfigIsAlphaOnly
(
proxy
-
>
config
(
)
)
)
{
color
=
SkColor4fPrepForDst
(
paint
.
getColor4f
(
)
dstInfo
*
rtc
-
>
caps
(
)
)
.
premul
(
)
;
}
else
{
float
paintAlpha
=
paint
.
getColor4f
(
)
.
fA
;
color
=
{
paintAlpha
paintAlpha
paintAlpha
paintAlpha
}
;
}
if
(
dstClip
)
{
SkPoint
srcQuad
[
4
]
;
GrMapRectPoints
(
dstRect
srcRect
dstClip
srcQuad
4
)
;
rtc
-
>
drawTextureQuad
(
clip
std
:
:
move
(
proxy
)
filter
paint
.
getBlendMode
(
)
color
srcQuad
dstClip
aa
aaFlags
constraint
=
=
SkCanvas
:
:
kStrict_SrcRectConstraint
?
&
srcRect
:
nullptr
ctm
std
:
:
move
(
textureXform
)
)
;
}
else
{
rtc
-
>
drawTexture
(
clip
std
:
:
move
(
proxy
)
filter
paint
.
getBlendMode
(
)
color
srcRect
dstRect
aa
aaFlags
constraint
ctm
std
:
:
move
(
textureXform
)
)
;
}
}
static
void
draw_texture_producer
(
GrContext
*
context
GrRenderTargetContext
*
rtc
const
GrClip
&
clip
const
SkMatrix
&
ctm
const
SkPaint
&
paint
GrTextureProducer
*
producer
const
SkRect
&
src
const
SkRect
&
dst
const
SkPoint
dstClip
[
4
]
const
SkMatrix
&
srcToDst
GrAA
aa
GrQuadAAFlags
aaFlags
SkCanvas
:
:
SrcRectConstraint
constraint
bool
attemptDrawTexture
)
{
if
(
attemptDrawTexture
&
&
can_use_draw_texture
(
paint
)
)
{
auto
proxy
=
producer
-
>
refTextureProxyForParams
(
GrSamplerState
:
:
ClampNearest
(
)
nullptr
)
;
if
(
!
proxy
)
{
return
;
}
draw_texture
(
rtc
clip
ctm
paint
src
dst
dstClip
aa
aaFlags
constraint
std
:
:
move
(
proxy
)
producer
-
>
alphaType
(
)
producer
-
>
colorSpace
(
)
)
;
return
;
}
const
SkMaskFilter
*
mf
=
paint
.
getMaskFilter
(
)
;
bool
canUseTextureCoordsAsLocalCoords
=
!
use_shader
(
producer
-
>
isAlphaOnly
(
)
paint
)
&
&
!
mf
;
if
(
mf
&
&
as_MFB
(
mf
)
-
>
hasFragmentProcessor
(
)
)
{
mf
=
nullptr
;
}
bool
doBicubic
;
GrSamplerState
:
:
Filter
fm
=
GrSkFilterQualityToGrFilterMode
(
paint
.
getFilterQuality
(
)
ctm
srcToDst
context
-
>
priv
(
)
.
options
(
)
.
fSharpenMipmappedTextures
&
doBicubic
)
;
const
GrSamplerState
:
:
Filter
*
filterMode
=
doBicubic
?
nullptr
:
&
fm
;
GrTextureProducer
:
:
FilterConstraint
constraintMode
;
if
(
SkCanvas
:
:
kFast_SrcRectConstraint
=
=
constraint
)
{
constraintMode
=
GrTextureAdjuster
:
:
kNo_FilterConstraint
;
}
else
{
constraintMode
=
GrTextureAdjuster
:
:
kYes_FilterConstraint
;
}
bool
coordsAllInsideSrcRect
=
aaFlags
=
=
GrQuadAAFlags
:
:
kNone
&
&
!
mf
;
if
(
filterMode
&
&
GrSamplerState
:
:
Filter
:
:
kBilerp
=
=
*
filterMode
&
&
GrTextureAdjuster
:
:
kYes_FilterConstraint
=
=
constraintMode
&
&
coordsAllInsideSrcRect
)
{
SkMatrix
combinedMatrix
;
combinedMatrix
.
setConcat
(
ctm
srcToDst
)
;
if
(
can_ignore_bilerp_constraint
(
*
producer
src
combinedMatrix
rtc
-
>
fsaaType
(
)
)
)
{
constraintMode
=
GrTextureAdjuster
:
:
kNo_FilterConstraint
;
}
}
SkMatrix
textureMatrix
;
if
(
canUseTextureCoordsAsLocalCoords
)
{
textureMatrix
=
SkMatrix
:
:
I
(
)
;
}
else
{
if
(
!
srcToDst
.
invert
(
&
textureMatrix
)
)
{
return
;
}
}
auto
fp
=
producer
-
>
createFragmentProcessor
(
textureMatrix
src
constraintMode
coordsAllInsideSrcRect
filterMode
)
;
fp
=
GrColorSpaceXformEffect
:
:
Make
(
std
:
:
move
(
fp
)
producer
-
>
colorSpace
(
)
producer
-
>
alphaType
(
)
rtc
-
>
colorSpaceInfo
(
)
.
colorSpace
(
)
)
;
if
(
!
fp
)
{
return
;
}
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaintWithTexture
(
context
rtc
-
>
colorSpaceInfo
(
)
paint
ctm
std
:
:
move
(
fp
)
producer
-
>
isAlphaOnly
(
)
&
grPaint
)
)
{
return
;
}
if
(
!
mf
)
{
if
(
dstClip
)
{
SkPoint
srcClipPoints
[
4
]
;
SkPoint
*
srcClip
=
nullptr
;
if
(
canUseTextureCoordsAsLocalCoords
)
{
GrMapRectPoints
(
dst
src
dstClip
srcClipPoints
4
)
;
srcClip
=
srcClipPoints
;
}
rtc
-
>
fillQuadWithEdgeAA
(
clip
std
:
:
move
(
grPaint
)
aa
aaFlags
ctm
dstClip
srcClip
)
;
}
else
{
rtc
-
>
fillRectWithEdgeAA
(
clip
std
:
:
move
(
grPaint
)
aa
aaFlags
ctm
dst
canUseTextureCoordsAsLocalCoords
?
&
src
:
nullptr
)
;
}
}
else
{
GrShape
shape
;
if
(
dstClip
)
{
SkPath
path
;
path
.
addPoly
(
dstClip
4
true
)
;
shape
=
GrShape
(
path
)
;
}
else
{
shape
=
GrShape
(
dst
)
;
}
GrBlurUtils
:
:
drawShapeWithMaskFilter
(
context
rtc
clip
shape
std
:
:
move
(
grPaint
)
ctm
mf
)
;
}
}
}
void
SkGpuDevice
:
:
drawImageQuad
(
const
SkImage
*
image
const
SkRect
*
srcRect
const
SkRect
*
dstRect
const
SkPoint
dstClip
[
4
]
GrAA
aa
GrQuadAAFlags
aaFlags
const
SkMatrix
*
preViewMatrix
const
SkPaint
&
paint
SkCanvas
:
:
SrcRectConstraint
constraint
)
{
SkRect
src
;
SkRect
dst
;
SkMatrix
srcToDst
;
ImageDrawMode
mode
=
optimize_sample_area
(
SkISize
:
:
Make
(
image
-
>
width
(
)
image
-
>
height
(
)
)
srcRect
dstRect
dstClip
&
src
&
dst
&
srcToDst
)
;
if
(
mode
=
=
ImageDrawMode
:
:
kSkip
)
{
return
;
}
if
(
src
.
contains
(
image
-
>
bounds
(
)
)
)
{
constraint
=
SkCanvas
:
:
kFast_SrcRectConstraint
;
}
bool
useDecal
=
mode
=
=
ImageDrawMode
:
:
kDecal
;
bool
attemptDrawTexture
=
!
useDecal
;
SkMatrix
ctm
=
this
-
>
ctm
(
)
;
if
(
preViewMatrix
)
{
ctm
.
preConcat
(
*
preViewMatrix
)
;
}
if
(
as_IB
(
image
)
-
>
isYUVA
(
)
)
{
SK_HISTOGRAM_BOOLEAN
(
"
DrawTiled
"
false
)
;
LogDrawScaleFactor
(
ctm
srcToDst
paint
.
getFilterQuality
(
)
)
;
GrYUVAImageTextureMaker
maker
(
fContext
.
get
(
)
image
useDecal
)
;
draw_texture_producer
(
fContext
.
get
(
)
fRenderTargetContext
.
get
(
)
this
-
>
clip
(
)
ctm
paint
&
maker
src
dst
dstClip
srcToDst
aa
aaFlags
constraint
false
)
;
return
;
}
uint32_t
pinnedUniqueID
;
if
(
sk_sp
<
GrTextureProxy
>
proxy
=
as_IB
(
image
)
-
>
refPinnedTextureProxy
(
this
-
>
context
(
)
&
pinnedUniqueID
)
)
{
SK_HISTOGRAM_BOOLEAN
(
"
DrawTiled
"
false
)
;
LogDrawScaleFactor
(
ctm
srcToDst
paint
.
getFilterQuality
(
)
)
;
SkAlphaType
alphaType
=
image
-
>
alphaType
(
)
;
SkColorSpace
*
colorSpace
=
as_IB
(
image
)
-
>
colorSpace
(
)
;
if
(
attemptDrawTexture
&
&
can_use_draw_texture
(
paint
)
)
{
draw_texture
(
fRenderTargetContext
.
get
(
)
this
-
>
clip
(
)
ctm
paint
src
dst
dstClip
aa
aaFlags
constraint
std
:
:
move
(
proxy
)
alphaType
colorSpace
)
;
return
;
}
GrTextureAdjuster
adjuster
(
fContext
.
get
(
)
std
:
:
move
(
proxy
)
alphaType
pinnedUniqueID
colorSpace
useDecal
)
;
draw_texture_producer
(
fContext
.
get
(
)
fRenderTargetContext
.
get
(
)
this
-
>
clip
(
)
ctm
paint
&
adjuster
src
dst
dstClip
srcToDst
aa
aaFlags
constraint
false
)
;
return
;
}
SkBitmap
bm
;
if
(
this
-
>
shouldTileImage
(
image
&
src
constraint
paint
.
getFilterQuality
(
)
ctm
srcToDst
)
)
{
if
(
!
as_IB
(
image
)
-
>
getROPixels
(
&
bm
)
)
{
return
;
}
this
-
>
drawBitmapRect
(
bm
&
src
dst
paint
constraint
)
;
return
;
}
SK_HISTOGRAM_BOOLEAN
(
"
DrawTiled
"
false
)
;
LogDrawScaleFactor
(
ctm
srcToDst
paint
.
getFilterQuality
(
)
)
;
if
(
image
-
>
isLazyGenerated
(
)
)
{
GrImageTextureMaker
maker
(
fContext
.
get
(
)
image
SkImage
:
:
kAllow_CachingHint
useDecal
)
;
draw_texture_producer
(
fContext
.
get
(
)
fRenderTargetContext
.
get
(
)
this
-
>
clip
(
)
ctm
paint
&
maker
src
dst
dstClip
srcToDst
aa
aaFlags
constraint
attemptDrawTexture
)
;
return
;
}
if
(
as_IB
(
image
)
-
>
getROPixels
(
&
bm
)
)
{
GrBitmapTextureMaker
maker
(
fContext
.
get
(
)
bm
useDecal
)
;
draw_texture_producer
(
fContext
.
get
(
)
fRenderTargetContext
.
get
(
)
this
-
>
clip
(
)
ctm
paint
&
maker
src
dst
dstClip
srcToDst
aa
aaFlags
constraint
attemptDrawTexture
)
;
}
}
void
SkGpuDevice
:
:
tmp_drawImageSetV3
(
const
SkCanvas
:
:
ImageSetEntry
set
[
]
int
dstClipCounts
[
]
int
preViewMatrixIdx
[
]
int
count
const
SkPoint
dstClips
[
]
const
SkMatrix
preViewMatrices
[
]
const
SkPaint
&
paint
SkCanvas
:
:
SrcRectConstraint
constraint
)
{
SkASSERT
(
count
>
0
)
;
if
(
!
can_use_draw_texture
(
paint
)
)
{
int
dstClipIndex
=
0
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
SkASSERT
(
!
dstClipCounts
|
|
dstClipCounts
[
i
]
=
=
0
|
|
dstClipCounts
[
i
]
=
=
4
)
;
int
xform
=
preViewMatrixIdx
?
preViewMatrixIdx
[
i
]
:
-
1
;
SkASSERT
(
xform
<
0
|
|
preViewMatrices
)
;
this
-
>
drawImageQuad
(
set
[
i
]
.
fImage
.
get
(
)
&
set
[
i
]
.
fSrcRect
&
set
[
i
]
.
fDstRect
(
dstClipCounts
&
&
dstClipCounts
[
i
]
>
0
)
?
dstClips
+
dstClipIndex
:
nullptr
GrAA
:
:
kYes
SkToGrQuadAAFlags
(
set
[
i
]
.
fAAFlags
)
xform
<
0
?
nullptr
:
preViewMatrices
+
xform
paint
constraint
)
;
if
(
dstClipCounts
)
{
dstClipIndex
+
=
dstClipCounts
[
i
]
;
}
}
return
;
}
GrSamplerState
:
:
Filter
filter
=
kNone_SkFilterQuality
=
=
paint
.
getFilterQuality
(
)
?
GrSamplerState
:
:
Filter
:
:
kNearest
:
GrSamplerState
:
:
Filter
:
:
kBilerp
;
SkBlendMode
mode
=
paint
.
getBlendMode
(
)
;
SkAutoTArray
<
GrRenderTargetContext
:
:
TextureSetEntry
>
textures
(
count
)
;
int
base
=
0
n
=
0
;
auto
draw
=
[
&
]
{
if
(
n
>
0
)
{
auto
textureXform
=
GrColorSpaceXform
:
:
Make
(
set
[
base
]
.
fImage
-
>
colorSpace
(
)
set
[
base
]
.
fImage
-
>
alphaType
(
)
fRenderTargetContext
-
>
colorSpaceInfo
(
)
.
colorSpace
(
)
kPremul_SkAlphaType
)
;
fRenderTargetContext
-
>
drawTextureSet
(
this
-
>
clip
(
)
textures
.
get
(
)
+
base
n
filter
mode
GrAA
:
:
kYes
this
-
>
ctm
(
)
std
:
:
move
(
textureXform
)
)
;
}
}
;
int
dstClipIndex
=
0
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
int
clipCount
=
(
dstClipCounts
?
dstClipCounts
[
i
]
:
0
)
;
SkASSERT
(
clipCount
=
=
0
|
|
(
dstClipCounts
[
i
]
=
=
4
&
&
dstClips
)
)
;
const
SkPoint
*
clip
=
clipCount
>
0
?
dstClips
+
dstClipIndex
:
nullptr
;
if
(
dstClipCounts
)
{
dstClipIndex
+
=
dstClipCounts
[
i
]
;
}
if
(
!
set
[
i
]
.
fSrcRect
.
isSorted
(
)
)
{
draw
(
)
;
base
=
i
+
1
;
n
=
0
;
continue
;
}
uint32_t
uniqueID
;
textures
[
i
]
.
fProxy
=
as_IB
(
set
[
i
]
.
fImage
.
get
(
)
)
-
>
refPinnedTextureProxy
(
this
-
>
context
(
)
&
uniqueID
)
;
if
(
!
textures
[
i
]
.
fProxy
)
{
textures
[
i
]
.
fProxy
=
as_IB
(
set
[
i
]
.
fImage
.
get
(
)
)
-
>
asTextureProxyRef
(
fContext
.
get
(
)
GrSamplerState
:
:
ClampBilerp
(
)
nullptr
)
;
if
(
!
textures
[
i
]
.
fProxy
)
{
draw
(
)
;
base
=
i
+
1
;
n
=
0
;
continue
;
}
}
int
xform
=
preViewMatrixIdx
?
preViewMatrixIdx
[
i
]
:
-
1
;
SkASSERT
(
xform
<
0
|
|
preViewMatrices
)
;
textures
[
i
]
.
fSrcRect
=
set
[
i
]
.
fSrcRect
;
textures
[
i
]
.
fDstRect
=
set
[
i
]
.
fDstRect
;
textures
[
i
]
.
fDstClipQuad
=
clip
;
textures
[
i
]
.
fPreViewMatrix
=
xform
<
0
?
nullptr
:
preViewMatrices
+
xform
;
textures
[
i
]
.
fAlpha
=
set
[
i
]
.
fAlpha
*
paint
.
getAlphaf
(
)
;
textures
[
i
]
.
fAAFlags
=
SkToGrQuadAAFlags
(
set
[
i
]
.
fAAFlags
)
;
if
(
n
>
0
&
&
(
!
GrTextureProxy
:
:
ProxiesAreCompatibleAsDynamicState
(
textures
[
i
]
.
fProxy
.
get
(
)
textures
[
base
]
.
fProxy
.
get
(
)
)
|
|
set
[
i
]
.
fImage
-
>
alphaType
(
)
!
=
set
[
base
]
.
fImage
-
>
alphaType
(
)
|
|
!
SkColorSpace
:
:
Equals
(
set
[
i
]
.
fImage
-
>
colorSpace
(
)
set
[
base
]
.
fImage
-
>
colorSpace
(
)
)
)
)
{
draw
(
)
;
base
=
i
;
n
=
1
;
}
else
{
+
+
n
;
}
}
draw
(
)
;
}
void
SkGpuDevice
:
:
drawTextureProducer
(
GrTextureProducer
*
producer
const
SkRect
*
srcRect
const
SkRect
*
dstRect
SkCanvas
:
:
SrcRectConstraint
constraint
const
SkMatrix
&
viewMatrix
const
SkPaint
&
paint
bool
attemptDrawTexture
)
{
SkRect
src
;
SkRect
dst
;
SkMatrix
srcToDst
;
ImageDrawMode
mode
=
optimize_sample_area
(
SkISize
:
:
Make
(
producer
-
>
width
(
)
producer
-
>
height
(
)
)
srcRect
dstRect
nullptr
&
src
&
dst
&
srcToDst
)
;
if
(
mode
=
=
ImageDrawMode
:
:
kSkip
)
{
return
;
}
SkASSERT
(
mode
!
=
ImageDrawMode
:
:
kDecal
)
;
draw_texture_producer
(
fContext
.
get
(
)
fRenderTargetContext
.
get
(
)
this
-
>
clip
(
)
viewMatrix
paint
producer
src
dst
nullptr
srcToDst
GrAA
(
paint
.
isAntiAlias
(
)
)
paint
.
isAntiAlias
(
)
?
GrQuadAAFlags
:
:
kAll
:
GrQuadAAFlags
:
:
kNone
constraint
attemptDrawTexture
)
;
}
