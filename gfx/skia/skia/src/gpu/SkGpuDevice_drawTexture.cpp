#
include
"
SkGpuDevice
.
h
"
#
include
"
GrBlurUtils
.
h
"
#
include
"
GrCaps
.
h
"
#
include
"
GrColorSpaceXform
.
h
"
#
include
"
GrRenderTargetContext
.
h
"
#
include
"
GrShape
.
h
"
#
include
"
GrStyle
.
h
"
#
include
"
GrTextureAdjuster
.
h
"
#
include
"
GrTextureMaker
.
h
"
#
include
"
SkDraw
.
h
"
#
include
"
SkGr
.
h
"
#
include
"
SkMaskFilterBase
.
h
"
#
include
"
effects
/
GrBicubicEffect
.
h
"
#
include
"
effects
/
GrSimpleTextureEffect
.
h
"
#
include
"
effects
/
GrTextureDomain
.
h
"
static
inline
bool
use_shader
(
bool
textureIsAlphaOnly
const
SkPaint
&
paint
)
{
return
textureIsAlphaOnly
&
&
paint
.
getShader
(
)
;
}
static
const
SkScalar
kColorBleedTolerance
=
0
.
001f
;
static
bool
has_aligned_samples
(
const
SkRect
&
srcRect
const
SkRect
&
transformedRect
)
{
if
(
SkScalarAbs
(
SkScalarRoundToScalar
(
transformedRect
.
left
(
)
)
-
transformedRect
.
left
(
)
)
<
kColorBleedTolerance
&
&
SkScalarAbs
(
SkScalarRoundToScalar
(
transformedRect
.
top
(
)
)
-
transformedRect
.
top
(
)
)
<
kColorBleedTolerance
&
&
SkScalarAbs
(
transformedRect
.
width
(
)
-
srcRect
.
width
(
)
)
<
kColorBleedTolerance
&
&
SkScalarAbs
(
transformedRect
.
height
(
)
-
srcRect
.
height
(
)
)
<
kColorBleedTolerance
)
{
return
true
;
}
return
false
;
}
static
bool
may_color_bleed
(
const
SkRect
&
srcRect
const
SkRect
&
transformedRect
const
SkMatrix
&
m
GrFSAAType
fsaaType
)
{
SkASSERT
(
!
has_aligned_samples
(
srcRect
transformedRect
)
)
;
SkRect
innerSrcRect
(
srcRect
)
innerTransformedRect
outerTransformedRect
(
transformedRect
)
;
if
(
GrFSAAType
:
:
kUnifiedMSAA
=
=
fsaaType
)
{
innerSrcRect
.
inset
(
SK_Scalar1
SK_Scalar1
)
;
}
else
{
innerSrcRect
.
inset
(
SK_ScalarHalf
SK_ScalarHalf
)
;
}
m
.
mapRect
(
&
innerTransformedRect
innerSrcRect
)
;
outerTransformedRect
.
inset
(
kColorBleedTolerance
kColorBleedTolerance
)
;
innerTransformedRect
.
outset
(
kColorBleedTolerance
kColorBleedTolerance
)
;
SkIRect
outer
inner
;
outerTransformedRect
.
round
(
&
outer
)
;
innerTransformedRect
.
round
(
&
inner
)
;
return
inner
!
=
outer
;
}
static
bool
can_ignore_bilerp_constraint
(
const
GrTextureProducer
&
producer
const
SkRect
&
srcRect
const
SkMatrix
&
srcRectToDeviceSpace
GrFSAAType
fsaaType
)
{
if
(
srcRectToDeviceSpace
.
rectStaysRect
(
)
)
{
SkRect
transformedRect
;
srcRectToDeviceSpace
.
mapRect
(
&
transformedRect
srcRect
)
;
if
(
has_aligned_samples
(
srcRect
transformedRect
)
|
|
!
may_color_bleed
(
srcRect
transformedRect
srcRectToDeviceSpace
fsaaType
)
)
{
return
true
;
}
}
return
false
;
}
static
bool
can_use_draw_texture
(
const
SkPaint
&
paint
)
{
return
(
!
paint
.
getColorFilter
(
)
&
&
!
paint
.
getShader
(
)
&
&
!
paint
.
getMaskFilter
(
)
&
&
!
paint
.
getImageFilter
(
)
&
&
paint
.
getFilterQuality
(
)
<
kMedium_SkFilterQuality
&
&
paint
.
getBlendMode
(
)
=
=
SkBlendMode
:
:
kSrcOver
)
;
}
static
void
draw_texture
(
const
SkPaint
&
paint
const
SkMatrix
&
ctm
const
SkRect
*
src
const
SkRect
*
dst
GrAA
aa
SkCanvas
:
:
SrcRectConstraint
constraint
sk_sp
<
GrTextureProxy
>
proxy
SkAlphaType
alphaType
SkColorSpace
*
colorSpace
const
GrClip
&
clip
GrRenderTargetContext
*
rtc
)
{
SkASSERT
(
!
(
SkToBool
(
src
)
&
&
!
SkToBool
(
dst
)
)
)
;
SkRect
srcRect
=
src
?
*
src
:
SkRect
:
:
MakeWH
(
proxy
-
>
width
(
)
proxy
-
>
height
(
)
)
;
SkRect
dstRect
=
dst
?
*
dst
:
srcRect
;
if
(
src
&
&
!
SkRect
:
:
MakeIWH
(
proxy
-
>
width
(
)
proxy
-
>
height
(
)
)
.
contains
(
srcRect
)
)
{
SkMatrix
srcToDst
;
srcToDst
.
setRectToRect
(
srcRect
dstRect
SkMatrix
:
:
kFill_ScaleToFit
)
;
SkAssertResult
(
srcRect
.
intersect
(
SkRect
:
:
MakeIWH
(
proxy
-
>
width
(
)
proxy
-
>
height
(
)
)
)
)
;
srcToDst
.
mapRect
(
&
dstRect
srcRect
)
;
}
auto
textureXform
=
GrColorSpaceXform
:
:
Make
(
colorSpace
alphaType
rtc
-
>
colorSpaceInfo
(
)
.
colorSpace
(
)
kPremul_SkAlphaType
)
;
GrSamplerState
:
:
Filter
filter
;
switch
(
paint
.
getFilterQuality
(
)
)
{
case
kNone_SkFilterQuality
:
filter
=
GrSamplerState
:
:
Filter
:
:
kNearest
;
break
;
case
kLow_SkFilterQuality
:
filter
=
GrSamplerState
:
:
Filter
:
:
kBilerp
;
break
;
case
kMedium_SkFilterQuality
:
case
kHigh_SkFilterQuality
:
SK_ABORT
(
"
Quality
level
not
allowed
.
"
)
;
}
GrColor
color
;
sk_sp
<
GrColorSpaceXform
>
paintColorXform
=
nullptr
;
if
(
GrPixelConfigIsAlphaOnly
(
proxy
-
>
config
(
)
)
)
{
paintColorXform
=
rtc
-
>
colorSpaceInfo
(
)
.
refColorSpaceXformFromSRGB
(
)
;
color
=
paintColorXform
?
SkColorToUnpremulGrColor
(
paint
.
getColor
(
)
)
:
SkColorToPremulGrColor
(
paint
.
getColor
(
)
)
;
}
else
{
color
=
GrColorPackA4
(
paint
.
getAlpha
(
)
)
;
}
GrQuadAAFlags
aaFlags
=
aa
=
=
GrAA
:
:
kYes
?
GrQuadAAFlags
:
:
kAll
:
GrQuadAAFlags
:
:
kNone
;
rtc
-
>
drawTexture
(
clip
std
:
:
move
(
proxy
)
filter
color
srcRect
dstRect
aaFlags
constraint
ctm
std
:
:
move
(
textureXform
)
std
:
:
move
(
paintColorXform
)
)
;
}
void
SkGpuDevice
:
:
drawPinnedTextureProxy
(
sk_sp
<
GrTextureProxy
>
proxy
uint32_t
pinnedUniqueID
SkColorSpace
*
colorSpace
SkAlphaType
alphaType
const
SkRect
*
srcRect
const
SkRect
*
dstRect
SkCanvas
:
:
SrcRectConstraint
constraint
const
SkMatrix
&
viewMatrix
const
SkPaint
&
paint
)
{
GrAA
aa
=
GrAA
(
paint
.
isAntiAlias
(
)
)
;
if
(
can_use_draw_texture
(
paint
)
)
{
draw_texture
(
paint
viewMatrix
srcRect
dstRect
aa
constraint
std
:
:
move
(
proxy
)
alphaType
colorSpace
this
-
>
clip
(
)
fRenderTargetContext
.
get
(
)
)
;
return
;
}
GrTextureAdjuster
adjuster
(
this
-
>
context
(
)
std
:
:
move
(
proxy
)
alphaType
pinnedUniqueID
colorSpace
)
;
this
-
>
drawTextureProducer
(
&
adjuster
srcRect
dstRect
constraint
viewMatrix
paint
)
;
}
void
SkGpuDevice
:
:
drawTextureMaker
(
GrTextureMaker
*
maker
int
imageW
int
imageH
const
SkRect
*
srcRect
const
SkRect
*
dstRect
SkCanvas
:
:
SrcRectConstraint
constraint
const
SkMatrix
&
viewMatrix
const
SkPaint
&
paint
)
{
GrAA
aa
=
GrAA
(
paint
.
isAntiAlias
(
)
)
;
if
(
can_use_draw_texture
(
paint
)
)
{
sk_sp
<
SkColorSpace
>
cs
;
auto
proxy
=
maker
-
>
refTextureProxyForParams
(
GrSamplerState
:
:
ClampNearest
(
)
fRenderTargetContext
-
>
colorSpaceInfo
(
)
.
colorSpace
(
)
&
cs
nullptr
)
;
if
(
!
proxy
)
{
return
;
}
draw_texture
(
paint
viewMatrix
srcRect
dstRect
aa
constraint
std
:
:
move
(
proxy
)
maker
-
>
alphaType
(
)
cs
.
get
(
)
this
-
>
clip
(
)
fRenderTargetContext
.
get
(
)
)
;
return
;
}
this
-
>
drawTextureProducer
(
maker
srcRect
dstRect
constraint
viewMatrix
paint
)
;
}
void
SkGpuDevice
:
:
drawTextureProducer
(
GrTextureProducer
*
producer
const
SkRect
*
srcRect
const
SkRect
*
dstRect
SkCanvas
:
:
SrcRectConstraint
constraint
const
SkMatrix
&
viewMatrix
const
SkPaint
&
paint
)
{
SK_HISTOGRAM_BOOLEAN
(
"
DrawTiled
"
false
)
;
SkRect
clippedSrcRect
;
SkRect
clippedDstRect
;
const
SkRect
srcBounds
=
SkRect
:
:
MakeIWH
(
producer
-
>
width
(
)
producer
-
>
height
(
)
)
;
SkMatrix
srcToDstMatrix
;
if
(
srcRect
)
{
if
(
!
dstRect
)
{
dstRect
=
&
srcBounds
;
}
if
(
!
srcBounds
.
contains
(
*
srcRect
)
)
{
clippedSrcRect
=
*
srcRect
;
if
(
!
clippedSrcRect
.
intersect
(
srcBounds
)
)
{
return
;
}
if
(
!
srcToDstMatrix
.
setRectToRect
(
*
srcRect
*
dstRect
SkMatrix
:
:
kFill_ScaleToFit
)
)
{
return
;
}
srcToDstMatrix
.
mapRect
(
&
clippedDstRect
clippedSrcRect
)
;
}
else
{
clippedSrcRect
=
*
srcRect
;
clippedDstRect
=
*
dstRect
;
if
(
!
srcToDstMatrix
.
setRectToRect
(
*
srcRect
*
dstRect
SkMatrix
:
:
kFill_ScaleToFit
)
)
{
return
;
}
}
}
else
{
clippedSrcRect
=
srcBounds
;
if
(
dstRect
)
{
clippedDstRect
=
*
dstRect
;
if
(
!
srcToDstMatrix
.
setRectToRect
(
srcBounds
*
dstRect
SkMatrix
:
:
kFill_ScaleToFit
)
)
{
return
;
}
}
else
{
clippedDstRect
=
srcBounds
;
srcToDstMatrix
.
reset
(
)
;
}
}
LogDrawScaleFactor
(
SkMatrix
:
:
Concat
(
viewMatrix
srcToDstMatrix
)
paint
.
getFilterQuality
(
)
)
;
this
-
>
drawTextureProducerImpl
(
producer
clippedSrcRect
clippedDstRect
constraint
viewMatrix
srcToDstMatrix
paint
)
;
}
void
SkGpuDevice
:
:
drawTextureProducerImpl
(
GrTextureProducer
*
producer
const
SkRect
&
clippedSrcRect
const
SkRect
&
clippedDstRect
SkCanvas
:
:
SrcRectConstraint
constraint
const
SkMatrix
&
viewMatrix
const
SkMatrix
&
srcToDstMatrix
const
SkPaint
&
paint
)
{
const
SkMaskFilter
*
mf
=
paint
.
getMaskFilter
(
)
;
if
(
mf
&
&
as_MFB
(
mf
)
-
>
hasFragmentProcessor
(
)
)
{
mf
=
nullptr
;
}
bool
canUseTextureCoordsAsLocalCoords
=
!
use_shader
(
producer
-
>
isAlphaOnly
(
)
paint
)
&
&
!
mf
;
bool
doBicubic
;
GrSamplerState
:
:
Filter
fm
=
GrSkFilterQualityToGrFilterMode
(
paint
.
getFilterQuality
(
)
viewMatrix
srcToDstMatrix
fContext
-
>
contextPriv
(
)
.
sharpenMipmappedTextures
(
)
&
doBicubic
)
;
const
GrSamplerState
:
:
Filter
*
filterMode
=
doBicubic
?
nullptr
:
&
fm
;
GrTextureProducer
:
:
FilterConstraint
constraintMode
;
if
(
SkCanvas
:
:
kFast_SrcRectConstraint
=
=
constraint
)
{
constraintMode
=
GrTextureAdjuster
:
:
kNo_FilterConstraint
;
}
else
{
constraintMode
=
GrTextureAdjuster
:
:
kYes_FilterConstraint
;
}
bool
coordsAllInsideSrcRect
=
!
paint
.
isAntiAlias
(
)
&
&
!
mf
;
if
(
filterMode
&
&
GrSamplerState
:
:
Filter
:
:
kBilerp
=
=
*
filterMode
&
&
GrTextureAdjuster
:
:
kYes_FilterConstraint
=
=
constraintMode
&
&
coordsAllInsideSrcRect
)
{
SkMatrix
combinedMatrix
;
combinedMatrix
.
setConcat
(
viewMatrix
srcToDstMatrix
)
;
if
(
can_ignore_bilerp_constraint
(
*
producer
clippedSrcRect
combinedMatrix
fRenderTargetContext
-
>
fsaaType
(
)
)
)
{
constraintMode
=
GrTextureAdjuster
:
:
kNo_FilterConstraint
;
}
}
const
SkMatrix
*
textureMatrix
;
SkMatrix
tempMatrix
;
if
(
canUseTextureCoordsAsLocalCoords
)
{
textureMatrix
=
&
SkMatrix
:
:
I
(
)
;
}
else
{
if
(
!
srcToDstMatrix
.
invert
(
&
tempMatrix
)
)
{
return
;
}
textureMatrix
=
&
tempMatrix
;
}
auto
fp
=
producer
-
>
createFragmentProcessor
(
*
textureMatrix
clippedSrcRect
constraintMode
coordsAllInsideSrcRect
filterMode
fRenderTargetContext
-
>
colorSpaceInfo
(
)
.
colorSpace
(
)
)
;
if
(
!
fp
)
{
return
;
}
GrPaint
grPaint
;
if
(
!
SkPaintToGrPaintWithTexture
(
fContext
.
get
(
)
fRenderTargetContext
-
>
colorSpaceInfo
(
)
paint
viewMatrix
std
:
:
move
(
fp
)
producer
-
>
isAlphaOnly
(
)
&
grPaint
)
)
{
return
;
}
GrAA
aa
=
GrAA
(
paint
.
isAntiAlias
(
)
)
;
if
(
canUseTextureCoordsAsLocalCoords
)
{
fRenderTargetContext
-
>
fillRectToRect
(
this
-
>
clip
(
)
std
:
:
move
(
grPaint
)
aa
viewMatrix
clippedDstRect
clippedSrcRect
)
;
return
;
}
if
(
!
mf
)
{
fRenderTargetContext
-
>
drawRect
(
this
-
>
clip
(
)
std
:
:
move
(
grPaint
)
aa
viewMatrix
clippedDstRect
)
;
return
;
}
GrShape
shape
(
clippedDstRect
GrStyle
:
:
SimpleFill
(
)
)
;
GrBlurUtils
:
:
drawShapeWithMaskFilter
(
this
-
>
context
(
)
fRenderTargetContext
.
get
(
)
this
-
>
clip
(
)
shape
std
:
:
move
(
grPaint
)
viewMatrix
mf
)
;
}
