#
include
"
SkImage_Base
.
h
"
#
include
"
SkImageCacherator
.
h
"
#
include
"
SkBitmap
.
h
"
#
include
"
SkBitmapCache
.
h
"
#
include
"
SkData
.
h
"
#
include
"
SkImageGenerator
.
h
"
#
include
"
SkImagePriv
.
h
"
#
include
"
SkNextID
.
h
"
#
include
"
SkPixelRef
.
h
"
#
if
SK_SUPPORT_GPU
#
include
"
GrContext
.
h
"
#
include
"
GrContextPriv
.
h
"
#
include
"
GrGpuResourcePriv
.
h
"
#
include
"
GrImageTextureMaker
.
h
"
#
include
"
GrResourceKey
.
h
"
#
include
"
GrProxyProvider
.
h
"
#
include
"
GrSamplerState
.
h
"
#
include
"
GrYUVProvider
.
h
"
#
include
"
SkGr
.
h
"
#
endif
class
SharedGenerator
final
:
public
SkNVRefCnt
<
SharedGenerator
>
{
public
:
static
sk_sp
<
SharedGenerator
>
Make
(
std
:
:
unique_ptr
<
SkImageGenerator
>
gen
)
{
return
gen
?
sk_sp
<
SharedGenerator
>
(
new
SharedGenerator
(
std
:
:
move
(
gen
)
)
)
:
nullptr
;
}
const
SkImageInfo
&
getInfo
(
)
{
return
fGenerator
-
>
getInfo
(
)
;
}
private
:
explicit
SharedGenerator
(
std
:
:
unique_ptr
<
SkImageGenerator
>
gen
)
:
fGenerator
(
std
:
:
move
(
gen
)
)
{
SkASSERT
(
fGenerator
)
;
}
friend
class
ScopedGenerator
;
friend
class
SkImage_Lazy
;
std
:
:
unique_ptr
<
SkImageGenerator
>
fGenerator
;
SkMutex
fMutex
;
}
;
class
SkImage_Lazy
:
public
SkImage_Base
public
SkImageCacherator
{
public
:
struct
Validator
{
Validator
(
sk_sp
<
SharedGenerator
>
const
SkIRect
*
subset
sk_sp
<
SkColorSpace
>
colorSpace
)
;
MOZ_IMPLICIT
operator
bool
(
)
const
{
return
fSharedGenerator
.
get
(
)
;
}
sk_sp
<
SharedGenerator
>
fSharedGenerator
;
SkImageInfo
fInfo
;
SkIPoint
fOrigin
;
sk_sp
<
SkColorSpace
>
fColorSpace
;
uint32_t
fUniqueID
;
}
;
SkImage_Lazy
(
Validator
*
validator
)
;
SkImageInfo
onImageInfo
(
)
const
override
{
return
fInfo
;
}
SkAlphaType
onAlphaType
(
)
const
override
{
return
fInfo
.
alphaType
(
)
;
}
bool
onReadPixels
(
const
SkImageInfo
&
void
*
size_t
int
srcX
int
srcY
CachingHint
)
const
override
;
#
if
SK_SUPPORT_GPU
sk_sp
<
GrTextureProxy
>
asTextureProxyRef
(
GrContext
*
const
GrSamplerState
&
SkColorSpace
*
sk_sp
<
SkColorSpace
>
*
SkScalar
scaleAdjust
[
2
]
)
const
override
;
#
endif
SkData
*
onRefEncoded
(
)
const
override
;
sk_sp
<
SkImage
>
onMakeSubset
(
const
SkIRect
&
)
const
override
;
bool
getROPixels
(
SkBitmap
*
SkColorSpace
*
dstColorSpace
CachingHint
)
const
override
;
bool
onIsLazyGenerated
(
)
const
override
{
return
true
;
}
bool
onCanLazyGenerateOnGPU
(
)
const
override
;
sk_sp
<
SkImage
>
onMakeColorSpace
(
sk_sp
<
SkColorSpace
>
SkColorType
SkTransferFunctionBehavior
)
const
override
;
bool
onIsValid
(
GrContext
*
)
const
override
;
SkImageCacherator
*
peekCacherator
(
)
const
override
{
return
const_cast
<
SkImage_Lazy
*
>
(
this
)
;
}
bool
lockAsBitmapOnlyIfAlreadyCached
(
SkBitmap
*
CachedFormat
)
const
;
bool
directGeneratePixels
(
const
SkImageInfo
&
dstInfo
void
*
dstPixels
size_t
dstRB
int
srcX
int
srcY
SkTransferFunctionBehavior
behavior
)
const
;
#
if
SK_SUPPORT_GPU
sk_sp
<
GrTextureProxy
>
lockTextureProxy
(
GrContext
*
const
GrUniqueKey
&
key
SkImage
:
:
CachingHint
bool
willBeMipped
SkColorSpace
*
dstColorSpace
GrTextureMaker
:
:
AllowedTexGenType
genType
)
override
;
sk_sp
<
SkColorSpace
>
getColorSpace
(
GrContext
*
SkColorSpace
*
dstColorSpace
)
override
;
void
makeCacheKeyFromOrigKey
(
const
GrUniqueKey
&
origKey
CachedFormat
GrUniqueKey
*
cacheKey
)
override
;
#
endif
CachedFormat
chooseCacheFormat
(
SkColorSpace
*
dstColorSpace
const
GrCaps
*
=
nullptr
)
const
override
;
SkImageInfo
buildCacheInfo
(
CachedFormat
)
const
override
;
private
:
class
ScopedGenerator
;
bool
lockAsBitmap
(
SkBitmap
*
SkImage
:
:
CachingHint
CachedFormat
const
SkImageInfo
&
SkTransferFunctionBehavior
)
const
;
SkTransferFunctionBehavior
getGeneratorBehaviorAndInfo
(
SkImageInfo
*
generatorImageInfo
)
const
;
sk_sp
<
SharedGenerator
>
fSharedGenerator
;
const
SkImageInfo
fInfo
;
const
SkIPoint
fOrigin
;
struct
IDRec
{
SkOnce
fOnce
;
uint32_t
fUniqueID
;
}
;
mutable
IDRec
fIDRecs
[
kNumCachedFormats
]
;
uint32_t
getUniqueID
(
CachedFormat
)
const
;
mutable
SkMutex
fOnMakeColorSpaceMutex
;
mutable
sk_sp
<
SkColorSpace
>
fOnMakeColorSpaceTarget
;
mutable
sk_sp
<
SkImage
>
fOnMakeColorSpaceResult
;
typedef
SkImage_Base
INHERITED
;
}
;
SkImage_Lazy
:
:
Validator
:
:
Validator
(
sk_sp
<
SharedGenerator
>
gen
const
SkIRect
*
subset
sk_sp
<
SkColorSpace
>
colorSpace
)
:
fSharedGenerator
(
std
:
:
move
(
gen
)
)
{
if
(
!
fSharedGenerator
)
{
return
;
}
const
SkImageInfo
&
info
=
fSharedGenerator
-
>
fGenerator
-
>
getInfo
(
)
;
if
(
info
.
isEmpty
(
)
)
{
fSharedGenerator
.
reset
(
)
;
return
;
}
fUniqueID
=
fSharedGenerator
-
>
fGenerator
-
>
uniqueID
(
)
;
const
SkIRect
bounds
=
SkIRect
:
:
MakeWH
(
info
.
width
(
)
info
.
height
(
)
)
;
if
(
subset
)
{
if
(
!
bounds
.
contains
(
*
subset
)
)
{
fSharedGenerator
.
reset
(
)
;
return
;
}
if
(
*
subset
!
=
bounds
)
{
fUniqueID
=
SkNextID
:
:
ImageID
(
)
;
}
}
else
{
subset
=
&
bounds
;
}
fInfo
=
info
.
makeWH
(
subset
-
>
width
(
)
subset
-
>
height
(
)
)
;
fOrigin
=
SkIPoint
:
:
Make
(
subset
-
>
x
(
)
subset
-
>
y
(
)
)
;
if
(
colorSpace
)
{
fInfo
=
fInfo
.
makeColorSpace
(
colorSpace
)
;
fUniqueID
=
SkNextID
:
:
ImageID
(
)
;
}
}
class
SkImage_Lazy
:
:
ScopedGenerator
{
public
:
ScopedGenerator
(
const
sk_sp
<
SharedGenerator
>
&
gen
)
:
fSharedGenerator
(
gen
)
fAutoAquire
(
gen
-
>
fMutex
)
{
}
SkImageGenerator
*
operator
-
>
(
)
const
{
fSharedGenerator
-
>
fMutex
.
assertHeld
(
)
;
return
fSharedGenerator
-
>
fGenerator
.
get
(
)
;
}
operator
SkImageGenerator
*
(
)
const
{
fSharedGenerator
-
>
fMutex
.
assertHeld
(
)
;
return
fSharedGenerator
-
>
fGenerator
.
get
(
)
;
}
private
:
const
sk_sp
<
SharedGenerator
>
&
fSharedGenerator
;
SkAutoExclusive
fAutoAquire
;
}
;
SkImage_Lazy
:
:
SkImage_Lazy
(
Validator
*
validator
)
:
INHERITED
(
validator
-
>
fInfo
.
width
(
)
validator
-
>
fInfo
.
height
(
)
validator
-
>
fUniqueID
)
fSharedGenerator
(
std
:
:
move
(
validator
-
>
fSharedGenerator
)
)
fInfo
(
validator
-
>
fInfo
)
fOrigin
(
validator
-
>
fOrigin
)
{
SkASSERT
(
fSharedGenerator
)
;
fIDRecs
[
kLegacy_CachedFormat
]
.
fOnce
(
[
this
validator
]
{
fIDRecs
[
kLegacy_CachedFormat
]
.
fUniqueID
=
validator
-
>
fUniqueID
;
}
)
;
}
uint32_t
SkImage_Lazy
:
:
getUniqueID
(
CachedFormat
format
)
const
{
IDRec
*
rec
=
&
fIDRecs
[
format
]
;
rec
-
>
fOnce
(
[
rec
]
{
rec
-
>
fUniqueID
=
SkNextID
:
:
ImageID
(
)
;
}
)
;
return
rec
-
>
fUniqueID
;
}
struct
CacheCaps
{
CacheCaps
(
const
GrCaps
*
caps
)
:
fCaps
(
caps
)
{
}
#
if
SK_SUPPORT_GPU
bool
supportsHalfFloat
(
)
const
{
return
!
fCaps
|
|
(
fCaps
-
>
isConfigTexturable
(
kRGBA_half_GrPixelConfig
)
&
&
fCaps
-
>
isConfigRenderable
(
kRGBA_half_GrPixelConfig
)
)
;
}
bool
supportsSRGB
(
)
const
{
return
!
fCaps
|
|
(
fCaps
-
>
srgbSupport
(
)
&
&
fCaps
-
>
isConfigTexturable
(
kSRGBA_8888_GrPixelConfig
)
)
;
}
bool
supportsSBGR
(
)
const
{
return
!
fCaps
|
|
fCaps
-
>
srgbSupport
(
)
;
}
#
else
bool
supportsHalfFloat
(
)
const
{
return
true
;
}
bool
supportsSRGB
(
)
const
{
return
true
;
}
bool
supportsSBGR
(
)
const
{
return
true
;
}
#
endif
const
GrCaps
*
fCaps
;
}
;
SkImageCacherator
:
:
CachedFormat
SkImage_Lazy
:
:
chooseCacheFormat
(
SkColorSpace
*
dstColorSpace
const
GrCaps
*
grCaps
)
const
{
SkColorSpace
*
cs
=
fInfo
.
colorSpace
(
)
;
if
(
!
cs
|
|
!
dstColorSpace
)
{
return
kLegacy_CachedFormat
;
}
CacheCaps
caps
(
grCaps
)
;
switch
(
fInfo
.
colorType
(
)
)
{
case
kUnknown_SkColorType
:
case
kAlpha_8_SkColorType
:
case
kRGB_565_SkColorType
:
case
kARGB_4444_SkColorType
:
case
kRGB_888x_SkColorType
:
case
kRGBA_1010102_SkColorType
:
case
kRGB_101010x_SkColorType
:
return
kLegacy_CachedFormat
;
case
kGray_8_SkColorType
:
if
(
cs
-
>
gammaCloseToSRGB
(
)
&
&
caps
.
supportsSRGB
(
)
)
{
return
kSRGB8888_CachedFormat
;
}
else
{
return
kLegacy_CachedFormat
;
}
case
kRGBA_8888_SkColorType
:
if
(
cs
-
>
gammaCloseToSRGB
(
)
)
{
if
(
caps
.
supportsSRGB
(
)
)
{
return
kSRGB8888_CachedFormat
;
}
else
if
(
caps
.
supportsHalfFloat
(
)
)
{
return
kLinearF16_CachedFormat
;
}
else
{
return
kLegacy_CachedFormat
;
}
}
else
{
if
(
caps
.
supportsHalfFloat
(
)
)
{
return
kLinearF16_CachedFormat
;
}
else
if
(
caps
.
supportsSRGB
(
)
)
{
return
kSRGB8888_CachedFormat
;
}
else
{
return
kLegacy_CachedFormat
;
}
}
case
kBGRA_8888_SkColorType
:
if
(
caps
.
supportsSBGR
(
)
)
{
if
(
cs
-
>
gammaCloseToSRGB
(
)
)
{
return
kSBGR8888_CachedFormat
;
}
else
if
(
caps
.
supportsHalfFloat
(
)
)
{
return
kLinearF16_CachedFormat
;
}
else
if
(
caps
.
supportsSRGB
(
)
)
{
return
kSRGB8888_CachedFormat
;
}
else
{
return
kLegacy_CachedFormat
;
}
}
else
{
if
(
cs
-
>
gammaCloseToSRGB
(
)
)
{
if
(
caps
.
supportsSRGB
(
)
)
{
return
kSRGB8888_CachedFormat
;
}
else
if
(
caps
.
supportsHalfFloat
(
)
)
{
return
kLinearF16_CachedFormat
;
}
else
{
return
kLegacy_CachedFormat
;
}
}
else
{
if
(
caps
.
supportsHalfFloat
(
)
)
{
return
kLinearF16_CachedFormat
;
}
else
if
(
caps
.
supportsSRGB
(
)
)
{
return
kSRGB8888_CachedFormat
;
}
else
{
return
kLegacy_CachedFormat
;
}
}
}
case
kRGBA_F16_SkColorType
:
if
(
caps
.
supportsHalfFloat
(
)
)
{
return
kLinearF16_CachedFormat
;
}
else
if
(
caps
.
supportsSRGB
(
)
)
{
return
kSRGB8888_CachedFormat
;
}
else
{
return
kLegacy_CachedFormat
;
}
}
SkDEBUGFAIL
(
"
Unreachable
"
)
;
return
kLegacy_CachedFormat
;
}
SkImageInfo
SkImage_Lazy
:
:
buildCacheInfo
(
CachedFormat
format
)
const
{
switch
(
format
)
{
case
kLegacy_CachedFormat
:
return
fInfo
.
makeColorSpace
(
nullptr
)
;
case
kLinearF16_CachedFormat
:
return
fInfo
.
makeColorType
(
kRGBA_F16_SkColorType
)
.
makeColorSpace
(
fInfo
.
colorSpace
(
)
-
>
makeLinearGamma
(
)
)
;
case
kSRGB8888_CachedFormat
:
if
(
fInfo
.
colorSpace
(
)
-
>
gammaCloseToSRGB
(
)
)
{
return
fInfo
.
makeColorType
(
kRGBA_8888_SkColorType
)
;
}
else
{
return
fInfo
.
makeColorType
(
kRGBA_8888_SkColorType
)
.
makeColorSpace
(
fInfo
.
colorSpace
(
)
-
>
makeSRGBGamma
(
)
)
;
}
case
kSBGR8888_CachedFormat
:
if
(
fInfo
.
colorSpace
(
)
-
>
gammaCloseToSRGB
(
)
)
{
return
fInfo
.
makeColorType
(
kBGRA_8888_SkColorType
)
;
}
else
{
return
fInfo
.
makeColorType
(
kBGRA_8888_SkColorType
)
.
makeColorSpace
(
fInfo
.
colorSpace
(
)
-
>
makeSRGBGamma
(
)
)
;
}
default
:
SkDEBUGFAIL
(
"
Invalid
cached
format
"
)
;
return
fInfo
;
}
}
static
bool
check_output_bitmap
(
const
SkBitmap
&
bitmap
uint32_t
expectedID
)
{
SkASSERT
(
bitmap
.
getGenerationID
(
)
=
=
expectedID
)
;
SkASSERT
(
bitmap
.
isImmutable
(
)
)
;
SkASSERT
(
bitmap
.
getPixels
(
)
)
;
return
true
;
}
bool
SkImage_Lazy
:
:
directGeneratePixels
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rb
int
srcX
int
srcY
SkTransferFunctionBehavior
behavior
)
const
{
ScopedGenerator
generator
(
fSharedGenerator
)
;
const
SkImageInfo
&
genInfo
=
generator
-
>
getInfo
(
)
;
if
(
srcX
|
|
srcY
|
|
genInfo
.
width
(
)
!
=
info
.
width
(
)
|
|
genInfo
.
height
(
)
!
=
info
.
height
(
)
)
{
return
false
;
}
SkImageGenerator
:
:
Options
opts
;
opts
.
fBehavior
=
SkTransferFunctionBehavior
:
:
kIgnore
;
return
generator
-
>
getPixels
(
info
pixels
rb
&
opts
)
;
}
bool
SkImage_Lazy
:
:
lockAsBitmapOnlyIfAlreadyCached
(
SkBitmap
*
bitmap
CachedFormat
format
)
const
{
uint32_t
uniqueID
=
this
-
>
getUniqueID
(
format
)
;
return
SkBitmapCache
:
:
Find
(
SkBitmapCacheDesc
:
:
Make
(
uniqueID
fInfo
.
width
(
)
fInfo
.
height
(
)
)
bitmap
)
&
&
check_output_bitmap
(
*
bitmap
uniqueID
)
;
}
static
bool
generate_pixels
(
SkImageGenerator
*
gen
const
SkPixmap
&
pmap
int
originX
int
originY
SkTransferFunctionBehavior
behavior
)
{
const
int
genW
=
gen
-
>
getInfo
(
)
.
width
(
)
;
const
int
genH
=
gen
-
>
getInfo
(
)
.
height
(
)
;
const
SkIRect
srcR
=
SkIRect
:
:
MakeWH
(
genW
genH
)
;
const
SkIRect
dstR
=
SkIRect
:
:
MakeXYWH
(
originX
originY
pmap
.
width
(
)
pmap
.
height
(
)
)
;
if
(
!
srcR
.
contains
(
dstR
)
)
{
return
false
;
}
SkBitmap
full
;
SkPixmap
fullPM
;
const
SkPixmap
*
dstPM
=
&
pmap
;
if
(
srcR
!
=
dstR
)
{
if
(
!
full
.
tryAllocPixels
(
pmap
.
info
(
)
.
makeWH
(
genW
genH
)
)
)
{
return
false
;
}
if
(
!
full
.
peekPixels
(
&
fullPM
)
)
{
return
false
;
}
dstPM
=
&
fullPM
;
}
SkImageGenerator
:
:
Options
opts
;
opts
.
fBehavior
=
behavior
;
if
(
!
gen
-
>
getPixels
(
dstPM
-
>
info
(
)
dstPM
-
>
writable_addr
(
)
dstPM
-
>
rowBytes
(
)
&
opts
)
)
{
return
false
;
}
if
(
srcR
!
=
dstR
)
{
if
(
!
full
.
readPixels
(
pmap
originX
originY
)
)
{
return
false
;
}
}
return
true
;
}
bool
SkImage_Lazy
:
:
lockAsBitmap
(
SkBitmap
*
bitmap
SkImage
:
:
CachingHint
chint
CachedFormat
format
const
SkImageInfo
&
info
SkTransferFunctionBehavior
behavior
)
const
{
if
(
this
-
>
lockAsBitmapOnlyIfAlreadyCached
(
bitmap
format
)
)
{
return
true
;
}
uint32_t
uniqueID
=
this
-
>
getUniqueID
(
format
)
;
SkBitmap
tmpBitmap
;
SkBitmapCache
:
:
RecPtr
cacheRec
;
SkPixmap
pmap
;
if
(
SkImage
:
:
kAllow_CachingHint
=
=
chint
)
{
auto
desc
=
SkBitmapCacheDesc
:
:
Make
(
uniqueID
info
.
width
(
)
info
.
height
(
)
)
;
cacheRec
=
SkBitmapCache
:
:
Alloc
(
desc
info
&
pmap
)
;
if
(
!
cacheRec
)
{
return
false
;
}
}
else
{
if
(
!
tmpBitmap
.
tryAllocPixels
(
info
)
)
{
return
false
;
}
if
(
!
tmpBitmap
.
peekPixels
(
&
pmap
)
)
{
return
false
;
}
}
ScopedGenerator
generator
(
fSharedGenerator
)
;
if
(
!
generate_pixels
(
generator
pmap
fOrigin
.
x
(
)
fOrigin
.
y
(
)
behavior
)
)
{
return
false
;
}
if
(
cacheRec
)
{
SkBitmapCache
:
:
Add
(
std
:
:
move
(
cacheRec
)
bitmap
)
;
SkASSERT
(
bitmap
-
>
getPixels
(
)
)
;
SkASSERT
(
bitmap
-
>
isImmutable
(
)
)
;
SkASSERT
(
bitmap
-
>
getGenerationID
(
)
=
=
uniqueID
)
;
this
-
>
notifyAddedToCache
(
)
;
}
else
{
*
bitmap
=
tmpBitmap
;
bitmap
-
>
pixelRef
(
)
-
>
setImmutableWithID
(
uniqueID
)
;
}
check_output_bitmap
(
*
bitmap
uniqueID
)
;
return
true
;
}
bool
SkImage_Lazy
:
:
onReadPixels
(
const
SkImageInfo
&
dstInfo
void
*
dstPixels
size_t
dstRB
int
srcX
int
srcY
CachingHint
chint
)
const
{
SkColorSpace
*
dstColorSpace
=
dstInfo
.
colorSpace
(
)
;
SkBitmap
bm
;
if
(
kDisallow_CachingHint
=
=
chint
)
{
CachedFormat
cacheFormat
=
this
-
>
chooseCacheFormat
(
dstColorSpace
)
;
SkImageInfo
genPixelsInfo
=
dstInfo
;
SkTransferFunctionBehavior
behavior
=
getGeneratorBehaviorAndInfo
(
&
genPixelsInfo
)
;
if
(
this
-
>
lockAsBitmapOnlyIfAlreadyCached
(
&
bm
cacheFormat
)
)
{
return
bm
.
readPixels
(
dstInfo
dstPixels
dstRB
srcX
srcY
)
;
}
else
{
if
(
this
-
>
directGeneratePixels
(
genPixelsInfo
dstPixels
dstRB
srcX
srcY
behavior
)
)
{
return
true
;
}
}
}
if
(
this
-
>
getROPixels
(
&
bm
dstColorSpace
chint
)
)
{
return
bm
.
readPixels
(
dstInfo
dstPixels
dstRB
srcX
srcY
)
;
}
return
false
;
}
SkData
*
SkImage_Lazy
:
:
onRefEncoded
(
)
const
{
ScopedGenerator
generator
(
fSharedGenerator
)
;
return
generator
-
>
refEncodedData
(
)
;
}
bool
SkImage_Lazy
:
:
getROPixels
(
SkBitmap
*
bitmap
SkColorSpace
*
dstColorSpace
CachingHint
chint
)
const
{
CachedFormat
cacheFormat
=
this
-
>
chooseCacheFormat
(
dstColorSpace
)
;
const
SkImageInfo
cacheInfo
=
this
-
>
buildCacheInfo
(
cacheFormat
)
;
SkImageInfo
genPixelsInfo
=
cacheInfo
;
SkTransferFunctionBehavior
behavior
=
getGeneratorBehaviorAndInfo
(
&
genPixelsInfo
)
;
return
this
-
>
lockAsBitmap
(
bitmap
chint
cacheFormat
genPixelsInfo
behavior
)
;
}
bool
SkImage_Lazy
:
:
onIsValid
(
GrContext
*
context
)
const
{
ScopedGenerator
generator
(
fSharedGenerator
)
;
return
generator
-
>
isValid
(
context
)
;
}
bool
SkImage_Lazy
:
:
onCanLazyGenerateOnGPU
(
)
const
{
#
if
SK_SUPPORT_GPU
ScopedGenerator
generator
(
fSharedGenerator
)
;
return
SkImageGenerator
:
:
TexGenType
:
:
kNone
!
=
generator
-
>
onCanGenerateTexture
(
)
;
#
else
return
false
;
#
endif
}
SkTransferFunctionBehavior
SkImage_Lazy
:
:
getGeneratorBehaviorAndInfo
(
SkImageInfo
*
generatorImageInfo
)
const
{
if
(
generatorImageInfo
-
>
colorSpace
(
)
)
{
return
SkTransferFunctionBehavior
:
:
kRespect
;
}
switch
(
generatorImageInfo
-
>
colorType
(
)
)
{
case
kRGBA_8888_SkColorType
:
case
kBGRA_8888_SkColorType
:
case
kRGBA_F16_SkColorType
:
case
kRGB_565_SkColorType
:
*
generatorImageInfo
=
generatorImageInfo
-
>
makeColorSpace
(
fInfo
.
refColorSpace
(
)
)
;
break
;
default
:
break
;
}
return
SkTransferFunctionBehavior
:
:
kIgnore
;
}
#
if
SK_SUPPORT_GPU
sk_sp
<
GrTextureProxy
>
SkImage_Lazy
:
:
asTextureProxyRef
(
GrContext
*
context
const
GrSamplerState
&
params
SkColorSpace
*
dstColorSpace
sk_sp
<
SkColorSpace
>
*
texColorSpace
SkScalar
scaleAdjust
[
2
]
)
const
{
if
(
!
context
)
{
return
nullptr
;
}
GrImageTextureMaker
textureMaker
(
context
this
kAllow_CachingHint
)
;
return
textureMaker
.
refTextureProxyForParams
(
params
dstColorSpace
texColorSpace
scaleAdjust
)
;
}
#
endif
sk_sp
<
SkImage
>
SkImage_Lazy
:
:
onMakeSubset
(
const
SkIRect
&
subset
)
const
{
SkASSERT
(
fInfo
.
bounds
(
)
.
contains
(
subset
)
)
;
SkASSERT
(
fInfo
.
bounds
(
)
!
=
subset
)
;
const
SkIRect
generatorSubset
=
subset
.
makeOffset
(
fOrigin
.
x
(
)
fOrigin
.
y
(
)
)
;
Validator
validator
(
fSharedGenerator
&
generatorSubset
fInfo
.
refColorSpace
(
)
)
;
return
validator
?
sk_sp
<
SkImage
>
(
new
SkImage_Lazy
(
&
validator
)
)
:
nullptr
;
}
sk_sp
<
SkImage
>
SkImage_Lazy
:
:
onMakeColorSpace
(
sk_sp
<
SkColorSpace
>
target
SkColorType
targetColorType
SkTransferFunctionBehavior
premulBehavior
)
const
{
SkAutoExclusive
autoAquire
(
fOnMakeColorSpaceMutex
)
;
if
(
target
&
&
fOnMakeColorSpaceTarget
&
&
SkColorSpace
:
:
Equals
(
target
.
get
(
)
fOnMakeColorSpaceTarget
.
get
(
)
)
)
{
return
fOnMakeColorSpaceResult
;
}
const
SkIRect
generatorSubset
=
SkIRect
:
:
MakeXYWH
(
fOrigin
.
x
(
)
fOrigin
.
y
(
)
fInfo
.
width
(
)
fInfo
.
height
(
)
)
;
Validator
validator
(
fSharedGenerator
&
generatorSubset
target
)
;
sk_sp
<
SkImage
>
result
=
validator
?
sk_sp
<
SkImage
>
(
new
SkImage_Lazy
(
&
validator
)
)
:
nullptr
;
if
(
result
)
{
fOnMakeColorSpaceTarget
=
target
;
fOnMakeColorSpaceResult
=
result
;
}
return
result
;
}
sk_sp
<
SkImage
>
SkImage
:
:
MakeFromGenerator
(
std
:
:
unique_ptr
<
SkImageGenerator
>
generator
const
SkIRect
*
subset
)
{
SkImage_Lazy
:
:
Validator
validator
(
SharedGenerator
:
:
Make
(
std
:
:
move
(
generator
)
)
subset
nullptr
)
;
return
validator
?
sk_make_sp
<
SkImage_Lazy
>
(
&
validator
)
:
nullptr
;
}
#
if
SK_SUPPORT_GPU
void
SkImage_Lazy
:
:
makeCacheKeyFromOrigKey
(
const
GrUniqueKey
&
origKey
CachedFormat
format
GrUniqueKey
*
cacheKey
)
{
SkASSERT
(
!
cacheKey
-
>
isValid
(
)
)
;
if
(
origKey
.
isValid
(
)
)
{
static
const
GrUniqueKey
:
:
Domain
kDomain
=
GrUniqueKey
:
:
GenerateDomain
(
)
;
GrUniqueKey
:
:
Builder
builder
(
cacheKey
origKey
kDomain
1
)
;
builder
[
0
]
=
format
;
}
}
class
Generator_GrYUVProvider
:
public
GrYUVProvider
{
SkImageGenerator
*
fGen
;
public
:
Generator_GrYUVProvider
(
SkImageGenerator
*
gen
)
:
fGen
(
gen
)
{
}
uint32_t
onGetID
(
)
override
{
return
fGen
-
>
uniqueID
(
)
;
}
bool
onQueryYUV8
(
SkYUVSizeInfo
*
sizeInfo
SkYUVColorSpace
*
colorSpace
)
const
override
{
return
fGen
-
>
queryYUV8
(
sizeInfo
colorSpace
)
;
}
bool
onGetYUV8Planes
(
const
SkYUVSizeInfo
&
sizeInfo
void
*
planes
[
3
]
)
override
{
return
fGen
-
>
getYUV8Planes
(
sizeInfo
planes
)
;
}
}
;
static
void
set_key_on_proxy
(
GrProxyProvider
*
proxyProvider
GrTextureProxy
*
proxy
GrTextureProxy
*
originalProxy
const
GrUniqueKey
&
key
)
{
if
(
key
.
isValid
(
)
)
{
SkASSERT
(
proxy
-
>
origin
(
)
=
=
kTopLeft_GrSurfaceOrigin
)
;
if
(
originalProxy
&
&
originalProxy
-
>
getUniqueKey
(
)
.
isValid
(
)
)
{
SkASSERT
(
originalProxy
-
>
getUniqueKey
(
)
=
=
key
)
;
SkASSERT
(
GrMipMapped
:
:
kYes
=
=
proxy
-
>
mipMapped
(
)
&
&
GrMipMapped
:
:
kNo
=
=
originalProxy
-
>
mipMapped
(
)
)
;
proxyProvider
-
>
removeUniqueKeyFromProxy
(
key
originalProxy
)
;
}
proxyProvider
-
>
assignUniqueKeyToProxy
(
key
proxy
)
;
}
}
sk_sp
<
SkColorSpace
>
SkImage_Lazy
:
:
getColorSpace
(
GrContext
*
ctx
SkColorSpace
*
dstColorSpace
)
{
if
(
!
dstColorSpace
)
{
return
fInfo
.
refColorSpace
(
)
;
}
else
{
CachedFormat
format
=
this
-
>
chooseCacheFormat
(
dstColorSpace
ctx
-
>
caps
(
)
)
;
SkImageInfo
cacheInfo
=
this
-
>
buildCacheInfo
(
format
)
;
return
cacheInfo
.
refColorSpace
(
)
;
}
}
sk_sp
<
GrTextureProxy
>
SkImage_Lazy
:
:
lockTextureProxy
(
GrContext
*
ctx
const
GrUniqueKey
&
origKey
SkImage
:
:
CachingHint
chint
bool
willBeMipped
SkColorSpace
*
dstColorSpace
GrTextureMaker
:
:
AllowedTexGenType
genType
)
{
enum
LockTexturePath
{
kFailure_LockTexturePath
kPreExisting_LockTexturePath
kNative_LockTexturePath
kCompressed_LockTexturePath
kYUV_LockTexturePath
kRGBA_LockTexturePath
}
;
enum
{
kLockTexturePathCount
=
kRGBA_LockTexturePath
+
1
}
;
CachedFormat
format
=
this
-
>
chooseCacheFormat
(
dstColorSpace
ctx
-
>
caps
(
)
)
;
GrUniqueKey
key
;
this
-
>
makeCacheKeyFromOrigKey
(
origKey
format
&
key
)
;
GrProxyProvider
*
proxyProvider
=
ctx
-
>
contextPriv
(
)
.
proxyProvider
(
)
;
sk_sp
<
GrTextureProxy
>
proxy
;
if
(
key
.
isValid
(
)
)
{
proxy
=
proxyProvider
-
>
findOrCreateProxyByUniqueKey
(
key
kTopLeft_GrSurfaceOrigin
)
;
if
(
proxy
)
{
SK_HISTOGRAM_ENUMERATION
(
"
LockTexturePath
"
kPreExisting_LockTexturePath
kLockTexturePathCount
)
;
if
(
!
willBeMipped
|
|
GrMipMapped
:
:
kYes
=
=
proxy
-
>
mipMapped
(
)
)
{
return
proxy
;
}
}
}
const
SkImageInfo
cacheInfo
=
this
-
>
buildCacheInfo
(
format
)
;
SkImageInfo
genPixelsInfo
=
cacheInfo
;
SkTransferFunctionBehavior
behavior
=
getGeneratorBehaviorAndInfo
(
&
genPixelsInfo
)
;
if
(
!
proxy
)
{
ScopedGenerator
generator
(
fSharedGenerator
)
;
if
(
GrTextureMaker
:
:
AllowedTexGenType
:
:
kCheap
=
=
genType
&
&
SkImageGenerator
:
:
TexGenType
:
:
kCheap
!
=
generator
-
>
onCanGenerateTexture
(
)
)
{
return
nullptr
;
}
if
(
(
proxy
=
generator
-
>
generateTexture
(
ctx
genPixelsInfo
fOrigin
behavior
willBeMipped
)
)
)
{
SK_HISTOGRAM_ENUMERATION
(
"
LockTexturePath
"
kNative_LockTexturePath
kLockTexturePathCount
)
;
set_key_on_proxy
(
proxyProvider
proxy
.
get
(
)
nullptr
key
)
;
if
(
!
willBeMipped
|
|
GrMipMapped
:
:
kYes
=
=
proxy
-
>
mipMapped
(
)
)
{
return
proxy
;
}
}
}
if
(
!
proxy
&
&
!
willBeMipped
&
&
!
ctx
-
>
contextPriv
(
)
.
disableGpuYUVConversion
(
)
)
{
const
GrSurfaceDesc
desc
=
GrImageInfoToSurfaceDesc
(
cacheInfo
*
ctx
-
>
caps
(
)
)
;
ScopedGenerator
generator
(
fSharedGenerator
)
;
Generator_GrYUVProvider
provider
(
generator
)
;
const
SkColorSpace
*
generatorColorSpace
=
fSharedGenerator
-
>
fGenerator
-
>
getInfo
(
)
.
colorSpace
(
)
;
const
SkColorSpace
*
thisColorSpace
=
fInfo
.
colorSpace
(
)
;
proxy
=
provider
.
refAsTextureProxy
(
ctx
desc
generatorColorSpace
thisColorSpace
)
;
if
(
proxy
)
{
SK_HISTOGRAM_ENUMERATION
(
"
LockTexturePath
"
kYUV_LockTexturePath
kLockTexturePathCount
)
;
set_key_on_proxy
(
proxyProvider
proxy
.
get
(
)
nullptr
key
)
;
return
proxy
;
}
}
SkBitmap
bitmap
;
if
(
!
proxy
&
&
this
-
>
lockAsBitmap
(
&
bitmap
chint
format
genPixelsInfo
behavior
)
)
{
if
(
willBeMipped
)
{
proxy
=
proxyProvider
-
>
createMipMapProxyFromBitmap
(
bitmap
dstColorSpace
)
;
}
if
(
!
proxy
)
{
proxy
=
GrUploadBitmapToTextureProxy
(
proxyProvider
bitmap
dstColorSpace
)
;
}
if
(
proxy
&
&
(
!
willBeMipped
|
|
GrMipMapped
:
:
kYes
=
=
proxy
-
>
mipMapped
(
)
)
)
{
SK_HISTOGRAM_ENUMERATION
(
"
LockTexturePath
"
kRGBA_LockTexturePath
kLockTexturePathCount
)
;
set_key_on_proxy
(
proxyProvider
proxy
.
get
(
)
nullptr
key
)
;
return
proxy
;
}
}
if
(
proxy
)
{
SkASSERT
(
willBeMipped
)
;
SkASSERT
(
GrMipMapped
:
:
kNo
=
=
proxy
-
>
mipMapped
(
)
)
;
if
(
auto
mippedProxy
=
GrCopyBaseMipMapToTextureProxy
(
ctx
proxy
.
get
(
)
)
)
{
set_key_on_proxy
(
proxyProvider
mippedProxy
.
get
(
)
proxy
.
get
(
)
key
)
;
return
mippedProxy
;
}
return
proxy
;
}
SK_HISTOGRAM_ENUMERATION
(
"
LockTexturePath
"
kFailure_LockTexturePath
kLockTexturePathCount
)
;
return
nullptr
;
}
#
endif
