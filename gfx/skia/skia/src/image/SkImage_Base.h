#
ifndef
SkImage_Base_DEFINED
#
define
SkImage_Base_DEFINED
#
include
"
SkImage
.
h
"
#
include
"
SkSurface
.
h
"
#
include
<
atomic
>
#
if
SK_SUPPORT_GPU
#
include
"
GrTextureProxy
.
h
"
#
include
"
SkTDArray
.
h
"
class
GrRecordingContext
;
class
GrTexture
;
#
endif
#
include
<
new
>
class
GrSamplerState
;
class
SkCachedData
;
struct
SkYUVASizeInfo
;
enum
{
kNeedNewImageUniqueID
=
0
}
;
class
SkImage_Base
:
public
SkImage
{
public
:
virtual
~
SkImage_Base
(
)
;
virtual
SkImageInfo
onImageInfo
(
)
const
=
0
;
virtual
SkIRect
onGetSubset
(
)
const
{
return
{
0
0
this
-
>
width
(
)
this
-
>
height
(
)
}
;
}
virtual
bool
onPeekPixels
(
SkPixmap
*
)
const
{
return
false
;
}
virtual
const
SkBitmap
*
onPeekBitmap
(
)
const
{
return
nullptr
;
}
virtual
bool
onReadPixels
(
const
SkImageInfo
&
dstInfo
void
*
dstPixels
size_t
dstRowBytes
int
srcX
int
srcY
CachingHint
)
const
=
0
;
virtual
GrContext
*
context
(
)
const
{
return
nullptr
;
}
#
if
SK_SUPPORT_GPU
virtual
GrTextureProxy
*
peekProxy
(
)
const
{
return
nullptr
;
}
virtual
sk_sp
<
GrTextureProxy
>
asTextureProxyRef
(
GrRecordingContext
*
)
const
{
return
nullptr
;
}
virtual
sk_sp
<
GrTextureProxy
>
asTextureProxyRef
(
GrRecordingContext
*
const
GrSamplerState
&
SkScalar
scaleAdjust
[
2
]
)
const
=
0
;
virtual
sk_sp
<
GrTextureProxy
>
refPinnedTextureProxy
(
GrRecordingContext
*
uint32_t
*
uniqueID
)
const
{
return
nullptr
;
}
virtual
bool
isYUVA
(
)
const
{
return
false
;
}
virtual
bool
asYUVATextureProxiesRef
(
sk_sp
<
GrTextureProxy
>
[
4
]
SkYUVAIndex
[
4
]
SkYUVColorSpace
*
)
const
{
return
false
;
}
virtual
GrTexture
*
onGetTexture
(
)
const
{
return
nullptr
;
}
#
endif
virtual
GrBackendTexture
onGetBackendTexture
(
bool
flushPendingGrContextIO
GrSurfaceOrigin
*
origin
)
const
;
virtual
bool
getROPixels
(
SkBitmap
*
CachingHint
=
kAllow_CachingHint
)
const
=
0
;
virtual
sk_sp
<
SkImage
>
onMakeSubset
(
GrRecordingContext
*
const
SkIRect
&
)
const
=
0
;
virtual
sk_sp
<
SkCachedData
>
getPlanes
(
SkYUVASizeInfo
*
SkYUVAIndex
[
4
]
SkYUVColorSpace
*
const
void
*
planes
[
4
]
)
;
virtual
sk_sp
<
SkData
>
onRefEncoded
(
)
const
{
return
nullptr
;
}
virtual
bool
onAsLegacyBitmap
(
SkBitmap
*
)
const
;
virtual
bool
onIsLazyGenerated
(
)
const
{
return
false
;
}
virtual
bool
onIsTextureBacked
(
)
const
{
return
false
;
}
virtual
void
notifyAddedToRasterCache
(
)
const
{
fAddedToRasterCache
.
store
(
true
)
;
}
virtual
bool
onIsValid
(
GrContext
*
)
const
=
0
;
virtual
bool
onPinAsTexture
(
GrContext
*
)
const
{
return
false
;
}
virtual
void
onUnpinAsTexture
(
GrContext
*
)
const
{
}
virtual
sk_sp
<
SkImage
>
onMakeColorTypeAndColorSpace
(
GrRecordingContext
*
SkColorType
sk_sp
<
SkColorSpace
>
)
const
=
0
;
protected
:
SkImage_Base
(
int
width
int
height
uint32_t
uniqueID
)
;
private
:
mutable
std
:
:
atomic
<
bool
>
fAddedToRasterCache
;
typedef
SkImage
INHERITED
;
}
;
static
inline
SkImage_Base
*
as_IB
(
SkImage
*
image
)
{
return
static_cast
<
SkImage_Base
*
>
(
image
)
;
}
static
inline
SkImage_Base
*
as_IB
(
const
sk_sp
<
SkImage
>
&
image
)
{
return
static_cast
<
SkImage_Base
*
>
(
image
.
get
(
)
)
;
}
static
inline
const
SkImage_Base
*
as_IB
(
const
SkImage
*
image
)
{
return
static_cast
<
const
SkImage_Base
*
>
(
image
)
;
}
#
endif
