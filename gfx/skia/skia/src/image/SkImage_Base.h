#
ifndef
SkImage_Base_DEFINED
#
define
SkImage_Base_DEFINED
#
include
"
SkAtomics
.
h
"
#
include
"
SkImage
.
h
"
#
include
"
SkSurface
.
h
"
#
include
<
new
>
class
GrTextureParams
;
class
SkImageCacherator
;
enum
{
kNeedNewImageUniqueID
=
0
}
;
class
SkImage_Base
:
public
SkImage
{
public
:
SkImage_Base
(
int
width
int
height
uint32_t
uniqueID
)
;
virtual
~
SkImage_Base
(
)
;
virtual
const
void
*
onPeekPixels
(
SkImageInfo
*
size_t
*
)
const
{
return
nullptr
;
}
virtual
bool
onReadPixels
(
const
SkImageInfo
&
dstInfo
void
*
dstPixels
size_t
dstRowBytes
int
srcX
int
srcY
CachingHint
)
const
;
virtual
GrTexture
*
peekTexture
(
)
const
{
return
nullptr
;
}
virtual
SkImageCacherator
*
peekCacherator
(
)
const
{
return
nullptr
;
}
virtual
bool
getROPixels
(
SkBitmap
*
CachingHint
=
kAllow_CachingHint
)
const
=
0
;
virtual
SkSurface
*
onNewSurface
(
const
SkImageInfo
&
info
)
const
{
return
SkSurface
:
:
NewRaster
(
info
)
;
}
virtual
GrTexture
*
asTextureRef
(
GrContext
*
const
GrTextureParams
&
)
const
=
0
;
virtual
SkImage
*
onNewSubset
(
const
SkIRect
&
)
const
=
0
;
virtual
SkData
*
onRefEncoded
(
GrContext
*
)
const
{
return
nullptr
;
}
virtual
bool
onAsLegacyBitmap
(
SkBitmap
*
LegacyBitmapMode
)
const
;
virtual
bool
onIsLazyGenerated
(
)
const
{
return
false
;
}
virtual
bool
asBitmapForImageFilters
(
SkBitmap
*
bitmap
)
const
{
return
this
-
>
getROPixels
(
bitmap
kAllow_CachingHint
)
;
}
void
notifyAddedToCache
(
)
const
{
fAddedToCache
.
store
(
true
)
;
}
private
:
mutable
SkAtomic
<
bool
>
fAddedToCache
;
typedef
SkImage
INHERITED
;
}
;
static
inline
SkImage_Base
*
as_IB
(
SkImage
*
image
)
{
return
static_cast
<
SkImage_Base
*
>
(
image
)
;
}
static
inline
const
SkImage_Base
*
as_IB
(
const
SkImage
*
image
)
{
return
static_cast
<
const
SkImage_Base
*
>
(
image
)
;
}
#
endif
