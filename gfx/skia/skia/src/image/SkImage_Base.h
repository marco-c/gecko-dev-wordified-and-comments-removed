#
ifndef
SkImage_Base_DEFINED
#
define
SkImage_Base_DEFINED
#
include
"
SkAtomics
.
h
"
#
include
"
SkImage
.
h
"
#
include
"
SkSurface
.
h
"
#
if
SK_SUPPORT_GPU
#
include
"
GrTexture
.
h
"
#
include
"
GrTextureProxy
.
h
"
#
endif
#
include
<
new
>
class
GrSamplerParams
;
class
SkImageCacherator
;
enum
{
kNeedNewImageUniqueID
=
0
}
;
class
SkImage_Base
:
public
SkImage
{
public
:
SkImage_Base
(
int
width
int
height
uint32_t
uniqueID
)
;
virtual
~
SkImage_Base
(
)
;
virtual
SkImageInfo
onImageInfo
(
)
const
=
0
;
virtual
SkAlphaType
onAlphaType
(
)
const
=
0
;
virtual
bool
onPeekPixels
(
SkPixmap
*
)
const
{
return
false
;
}
virtual
const
SkBitmap
*
onPeekBitmap
(
)
const
{
return
nullptr
;
}
virtual
bool
onReadYUV8Planes
(
const
SkISize
sizes
[
3
]
void
*
const
planes
[
3
]
const
size_t
rowBytes
[
3
]
SkYUVColorSpace
colorSpace
)
const
;
virtual
bool
onReadPixels
(
const
SkImageInfo
&
dstInfo
void
*
dstPixels
size_t
dstRowBytes
int
srcX
int
srcY
CachingHint
)
const
=
0
;
virtual
GrTexture
*
peekTexture
(
)
const
{
return
nullptr
;
}
#
if
SK_SUPPORT_GPU
virtual
GrTextureProxy
*
peekProxy
(
)
const
{
return
nullptr
;
}
virtual
sk_sp
<
GrTextureProxy
>
asTextureProxyRef
(
)
const
{
return
nullptr
;
}
virtual
sk_sp
<
GrTextureProxy
>
asTextureProxyRef
(
GrContext
*
const
GrSamplerParams
&
SkColorSpace
*
sk_sp
<
SkColorSpace
>
*
SkScalar
scaleAdjust
[
2
]
)
const
=
0
;
virtual
sk_sp
<
GrTextureProxy
>
refPinnedTextureProxy
(
uint32_t
*
uniqueID
)
const
{
return
nullptr
;
}
virtual
GrBackendObject
onGetTextureHandle
(
bool
flushPendingGrContextIO
GrSurfaceOrigin
*
origin
)
const
{
return
0
;
}
virtual
GrTexture
*
onGetTexture
(
)
const
{
return
nullptr
;
}
#
endif
virtual
SkImageCacherator
*
peekCacherator
(
)
const
{
return
nullptr
;
}
virtual
bool
getROPixels
(
SkBitmap
*
SkColorSpace
*
dstColorSpace
CachingHint
=
kAllow_CachingHint
)
const
=
0
;
virtual
sk_sp
<
SkImage
>
onMakeSubset
(
const
SkIRect
&
)
const
=
0
;
virtual
SkData
*
onRefEncoded
(
GrContext
*
)
const
{
return
nullptr
;
}
virtual
bool
onAsLegacyBitmap
(
SkBitmap
*
LegacyBitmapMode
)
const
;
virtual
bool
onIsLazyGenerated
(
)
const
{
return
false
;
}
void
notifyAddedToCache
(
)
const
{
fAddedToCache
.
store
(
true
)
;
}
virtual
bool
onPinAsTexture
(
GrContext
*
)
const
{
return
false
;
}
virtual
void
onUnpinAsTexture
(
GrContext
*
)
const
{
}
virtual
sk_sp
<
SkImage
>
onMakeColorSpace
(
sk_sp
<
SkColorSpace
>
)
const
=
0
;
private
:
mutable
SkAtomic
<
bool
>
fAddedToCache
;
typedef
SkImage
INHERITED
;
}
;
static
inline
SkImage_Base
*
as_IB
(
SkImage
*
image
)
{
return
static_cast
<
SkImage_Base
*
>
(
image
)
;
}
static
inline
SkImage_Base
*
as_IB
(
const
sk_sp
<
SkImage
>
&
image
)
{
return
static_cast
<
SkImage_Base
*
>
(
image
.
get
(
)
)
;
}
static
inline
const
SkImage_Base
*
as_IB
(
const
SkImage
*
image
)
{
return
static_cast
<
const
SkImage_Base
*
>
(
image
)
;
}
#
endif
