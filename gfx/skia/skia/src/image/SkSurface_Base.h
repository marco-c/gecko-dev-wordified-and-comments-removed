#
ifndef
SkSurface_Base_DEFINED
#
define
SkSurface_Base_DEFINED
#
include
"
SkCanvas
.
h
"
#
include
"
SkImagePriv
.
h
"
#
include
"
SkSurface
.
h
"
#
include
"
SkSurfacePriv
.
h
"
class
SkSurface_Base
:
public
SkSurface
{
public
:
SkSurface_Base
(
int
width
int
height
const
SkSurfaceProps
*
)
;
SkSurface_Base
(
const
SkImageInfo
&
const
SkSurfaceProps
*
)
;
virtual
~
SkSurface_Base
(
)
;
virtual
GrBackendObject
onGetTextureHandle
(
BackendHandleAccess
)
{
return
0
;
}
virtual
bool
onGetRenderTargetHandle
(
GrBackendObject
*
BackendHandleAccess
)
{
return
false
;
}
virtual
SkCanvas
*
onNewCanvas
(
)
=
0
;
virtual
sk_sp
<
SkSurface
>
onNewSurface
(
const
SkImageInfo
&
)
=
0
;
virtual
sk_sp
<
SkImage
>
onNewImageSnapshot
(
SkBudgeted
SkCopyPixelsMode
)
=
0
;
virtual
void
onDraw
(
SkCanvas
*
SkScalar
x
SkScalar
y
const
SkPaint
*
)
;
virtual
void
onDiscard
(
)
{
}
virtual
void
onCopyOnWrite
(
ContentChangeMode
)
=
0
;
virtual
void
onRestoreBackingMutability
(
)
{
}
virtual
void
onPrepareForExternalIO
(
)
{
}
inline
SkCanvas
*
getCachedCanvas
(
)
;
inline
sk_sp
<
SkImage
>
refCachedImage
(
SkBudgeted
ForceUnique
)
;
bool
hasCachedImage
(
)
const
{
return
fCachedImage
!
=
nullptr
;
}
uint32_t
newGenerationID
(
)
;
private
:
SkCanvas
*
fCachedCanvas
;
SkImage
*
fCachedImage
;
void
aboutToDraw
(
ContentChangeMode
mode
)
;
bool
outstandingImageSnapshot
(
)
const
;
friend
class
SkCanvas
;
friend
class
SkSurface
;
typedef
SkSurface
INHERITED
;
}
;
SkCanvas
*
SkSurface_Base
:
:
getCachedCanvas
(
)
{
if
(
nullptr
=
=
fCachedCanvas
)
{
fCachedCanvas
=
this
-
>
onNewCanvas
(
)
;
if
(
fCachedCanvas
)
{
fCachedCanvas
-
>
setSurfaceBase
(
this
)
;
}
}
return
fCachedCanvas
;
}
sk_sp
<
SkImage
>
SkSurface_Base
:
:
refCachedImage
(
SkBudgeted
budgeted
ForceUnique
unique
)
{
SkImage
*
snap
=
fCachedImage
;
if
(
kYes_ForceUnique
=
=
unique
&
&
snap
&
&
!
snap
-
>
unique
(
)
)
{
snap
=
nullptr
;
}
if
(
snap
)
{
return
sk_ref_sp
(
snap
)
;
}
SkCopyPixelsMode
cpm
=
(
kYes_ForceUnique
=
=
unique
)
?
kAlways_SkCopyPixelsMode
:
kIfMutable_SkCopyPixelsMode
;
snap
=
this
-
>
onNewImageSnapshot
(
budgeted
cpm
)
.
release
(
)
;
if
(
kNo_ForceUnique
=
=
unique
)
{
SkASSERT
(
!
fCachedImage
)
;
fCachedImage
=
SkSafeRef
(
snap
)
;
}
SkASSERT
(
!
fCachedCanvas
|
|
fCachedCanvas
-
>
getSurfaceBase
(
)
=
=
this
)
;
return
sk_sp
<
SkImage
>
(
snap
)
;
}
#
endif
