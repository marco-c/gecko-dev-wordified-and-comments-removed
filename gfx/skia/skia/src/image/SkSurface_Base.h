#
ifndef
SkSurface_Base_DEFINED
#
define
SkSurface_Base_DEFINED
#
include
"
include
/
core
/
SkCanvas
.
h
"
#
include
"
include
/
core
/
SkSurface
.
h
"
#
include
"
src
/
core
/
SkImagePriv
.
h
"
#
include
"
src
/
core
/
SkSurfacePriv
.
h
"
class
SkSurface_Base
:
public
SkSurface
{
public
:
SkSurface_Base
(
int
width
int
height
const
SkSurfaceProps
*
)
;
SkSurface_Base
(
const
SkImageInfo
&
const
SkSurfaceProps
*
)
;
virtual
~
SkSurface_Base
(
)
;
virtual
GrBackendTexture
onGetBackendTexture
(
BackendHandleAccess
)
;
virtual
GrBackendRenderTarget
onGetBackendRenderTarget
(
BackendHandleAccess
)
;
virtual
bool
onReplaceBackendTexture
(
const
GrBackendTexture
&
GrSurfaceOrigin
TextureReleaseProc
ReleaseContext
)
;
virtual
SkCanvas
*
onNewCanvas
(
)
=
0
;
virtual
sk_sp
<
SkSurface
>
onNewSurface
(
const
SkImageInfo
&
)
=
0
;
virtual
sk_sp
<
SkImage
>
onNewImageSnapshot
(
const
SkIRect
*
subset
=
nullptr
)
{
return
nullptr
;
}
virtual
void
onWritePixels
(
const
SkPixmap
&
int
x
int
y
)
=
0
;
virtual
void
onAsyncRescaleAndReadPixels
(
const
SkImageInfo
&
const
SkIRect
&
srcRect
RescaleGamma
SkFilterQuality
ReadPixelsCallback
ReadPixelsContext
)
;
virtual
void
onAsyncRescaleAndReadPixelsYUV420
(
SkYUVColorSpace
sk_sp
<
SkColorSpace
>
dstColorSpace
const
SkIRect
&
srcRect
const
SkISize
&
dstSize
RescaleGamma
SkFilterQuality
ReadPixelsCallback
ReadPixelsContext
)
;
virtual
void
onDraw
(
SkCanvas
*
SkScalar
x
SkScalar
y
const
SkPaint
*
)
;
virtual
void
onDiscard
(
)
{
}
virtual
void
onCopyOnWrite
(
ContentChangeMode
)
=
0
;
virtual
void
onRestoreBackingMutability
(
)
{
}
virtual
GrSemaphoresSubmitted
onFlush
(
BackendSurfaceAccess
access
const
GrFlushInfo
&
)
{
return
GrSemaphoresSubmitted
:
:
kNo
;
}
virtual
bool
onWait
(
int
numSemaphores
const
GrBackendSemaphore
*
waitSemaphores
)
{
return
false
;
}
virtual
bool
onCharacterize
(
SkSurfaceCharacterization
*
)
const
{
return
false
;
}
virtual
bool
onIsCompatible
(
const
SkSurfaceCharacterization
&
)
const
{
return
false
;
}
virtual
bool
onDraw
(
const
SkDeferredDisplayList
*
)
{
return
false
;
}
inline
SkCanvas
*
getCachedCanvas
(
)
;
inline
sk_sp
<
SkImage
>
refCachedImage
(
)
;
bool
hasCachedImage
(
)
const
{
return
fCachedImage
!
=
nullptr
;
}
uint32_t
newGenerationID
(
)
;
private
:
std
:
:
unique_ptr
<
SkCanvas
>
fCachedCanvas
;
sk_sp
<
SkImage
>
fCachedImage
;
void
aboutToDraw
(
ContentChangeMode
mode
)
;
bool
outstandingImageSnapshot
(
)
const
;
friend
class
SkCanvas
;
friend
class
SkSurface
;
typedef
SkSurface
INHERITED
;
}
;
SkCanvas
*
SkSurface_Base
:
:
getCachedCanvas
(
)
{
if
(
nullptr
=
=
fCachedCanvas
)
{
fCachedCanvas
=
std
:
:
unique_ptr
<
SkCanvas
>
(
this
-
>
onNewCanvas
(
)
)
;
if
(
fCachedCanvas
)
{
fCachedCanvas
-
>
setSurfaceBase
(
this
)
;
}
}
return
fCachedCanvas
.
get
(
)
;
}
sk_sp
<
SkImage
>
SkSurface_Base
:
:
refCachedImage
(
)
{
if
(
fCachedImage
)
{
return
fCachedImage
;
}
fCachedImage
=
this
-
>
onNewImageSnapshot
(
)
;
SkASSERT
(
!
fCachedCanvas
|
|
fCachedCanvas
-
>
getSurfaceBase
(
)
=
=
this
)
;
return
fCachedImage
;
}
#
endif
