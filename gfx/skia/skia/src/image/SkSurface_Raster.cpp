#
include
"
SkSurface_Base
.
h
"
#
include
"
SkImagePriv
.
h
"
#
include
"
SkCanvas
.
h
"
#
include
"
SkDevice
.
h
"
#
include
"
SkMallocPixelRef
.
h
"
static
const
size_t
kIgnoreRowBytesValue
=
(
size_t
)
~
0
;
class
SkSurface_Raster
:
public
SkSurface_Base
{
public
:
static
bool
Valid
(
const
SkImageInfo
&
size_t
rb
=
kIgnoreRowBytesValue
)
;
SkSurface_Raster
(
const
SkImageInfo
&
void
*
size_t
rb
void
(
*
releaseProc
)
(
void
*
pixels
void
*
context
)
void
*
context
const
SkSurfaceProps
*
)
;
SkSurface_Raster
(
SkPixelRef
*
const
SkSurfaceProps
*
)
;
SkCanvas
*
onNewCanvas
(
)
override
;
sk_sp
<
SkSurface
>
onNewSurface
(
const
SkImageInfo
&
)
override
;
sk_sp
<
SkImage
>
onNewImageSnapshot
(
SkBudgeted
SkCopyPixelsMode
)
override
;
void
onDraw
(
SkCanvas
*
SkScalar
x
SkScalar
y
const
SkPaint
*
)
override
;
void
onCopyOnWrite
(
ContentChangeMode
)
override
;
void
onRestoreBackingMutability
(
)
override
;
private
:
SkBitmap
fBitmap
;
size_t
fRowBytes
;
bool
fWeOwnThePixels
;
typedef
SkSurface_Base
INHERITED
;
}
;
bool
SkSurface_Raster
:
:
Valid
(
const
SkImageInfo
&
info
size_t
rowBytes
)
{
if
(
info
.
isEmpty
(
)
)
{
return
false
;
}
static
const
size_t
kMaxTotalSize
=
SK_MaxS32
;
int
shift
=
0
;
switch
(
info
.
colorType
(
)
)
{
case
kAlpha_8_SkColorType
:
if
(
info
.
colorSpace
(
)
)
{
return
false
;
}
shift
=
0
;
break
;
case
kRGB_565_SkColorType
:
if
(
info
.
colorSpace
(
)
)
{
return
false
;
}
shift
=
1
;
break
;
case
kN32_SkColorType
:
if
(
info
.
colorSpace
(
)
&
&
!
info
.
colorSpace
(
)
-
>
gammaCloseToSRGB
(
)
)
{
return
false
;
}
shift
=
2
;
break
;
case
kRGBA_F16_SkColorType
:
if
(
!
info
.
colorSpace
(
)
|
|
!
info
.
colorSpace
(
)
-
>
gammaIsLinear
(
)
)
{
return
false
;
}
shift
=
3
;
break
;
default
:
return
false
;
}
if
(
kIgnoreRowBytesValue
=
=
rowBytes
)
{
return
true
;
}
uint64_t
minRB
=
(
uint64_t
)
info
.
width
(
)
<
<
shift
;
if
(
minRB
>
rowBytes
)
{
return
false
;
}
size_t
alignedRowBytes
=
rowBytes
>
>
shift
<
<
shift
;
if
(
alignedRowBytes
!
=
rowBytes
)
{
return
false
;
}
uint64_t
size
=
sk_64_mul
(
info
.
height
(
)
rowBytes
)
;
if
(
size
>
kMaxTotalSize
)
{
return
false
;
}
return
true
;
}
SkSurface_Raster
:
:
SkSurface_Raster
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rb
void
(
*
releaseProc
)
(
void
*
pixels
void
*
context
)
void
*
context
const
SkSurfaceProps
*
props
)
:
INHERITED
(
info
props
)
{
fBitmap
.
installPixels
(
info
pixels
rb
nullptr
releaseProc
context
)
;
fRowBytes
=
0
;
fWeOwnThePixels
=
false
;
}
SkSurface_Raster
:
:
SkSurface_Raster
(
SkPixelRef
*
pr
const
SkSurfaceProps
*
props
)
:
INHERITED
(
pr
-
>
info
(
)
.
width
(
)
pr
-
>
info
(
)
.
height
(
)
props
)
{
const
SkImageInfo
&
info
=
pr
-
>
info
(
)
;
fBitmap
.
setInfo
(
info
pr
-
>
rowBytes
(
)
)
;
fBitmap
.
setPixelRef
(
pr
)
;
fRowBytes
=
pr
-
>
rowBytes
(
)
;
fWeOwnThePixels
=
true
;
}
SkCanvas
*
SkSurface_Raster
:
:
onNewCanvas
(
)
{
return
new
SkCanvas
(
fBitmap
this
-
>
props
(
)
)
;
}
sk_sp
<
SkSurface
>
SkSurface_Raster
:
:
onNewSurface
(
const
SkImageInfo
&
info
)
{
return
SkSurface
:
:
MakeRaster
(
info
&
this
-
>
props
(
)
)
;
}
void
SkSurface_Raster
:
:
onDraw
(
SkCanvas
*
canvas
SkScalar
x
SkScalar
y
const
SkPaint
*
paint
)
{
canvas
-
>
drawBitmap
(
fBitmap
x
y
paint
)
;
}
sk_sp
<
SkImage
>
SkSurface_Raster
:
:
onNewImageSnapshot
(
SkBudgeted
SkCopyPixelsMode
cpm
)
{
if
(
fWeOwnThePixels
)
{
if
(
SkPixelRef
*
pr
=
fBitmap
.
pixelRef
(
)
)
{
pr
-
>
setTemporarilyImmutable
(
)
;
}
}
else
{
cpm
=
kAlways_SkCopyPixelsMode
;
}
return
SkMakeImageFromRasterBitmap
(
fBitmap
cpm
)
;
}
void
SkSurface_Raster
:
:
onRestoreBackingMutability
(
)
{
SkASSERT
(
!
this
-
>
hasCachedImage
(
)
)
;
if
(
SkPixelRef
*
pr
=
fBitmap
.
pixelRef
(
)
)
{
pr
-
>
restoreMutability
(
)
;
}
}
void
SkSurface_Raster
:
:
onCopyOnWrite
(
ContentChangeMode
mode
)
{
sk_sp
<
SkImage
>
cached
(
this
-
>
refCachedImage
(
SkBudgeted
:
:
kNo
kNo_ForceUnique
)
)
;
SkASSERT
(
cached
)
;
if
(
SkBitmapImageGetPixelRef
(
cached
.
get
(
)
)
=
=
fBitmap
.
pixelRef
(
)
)
{
SkASSERT
(
fWeOwnThePixels
)
;
if
(
kDiscard_ContentChangeMode
=
=
mode
)
{
fBitmap
.
allocPixels
(
)
;
}
else
{
SkBitmap
prev
(
fBitmap
)
;
fBitmap
.
allocPixels
(
)
;
prev
.
lockPixels
(
)
;
SkASSERT
(
prev
.
info
(
)
=
=
fBitmap
.
info
(
)
)
;
SkASSERT
(
prev
.
rowBytes
(
)
=
=
fBitmap
.
rowBytes
(
)
)
;
memcpy
(
fBitmap
.
getPixels
(
)
prev
.
getPixels
(
)
fBitmap
.
getSafeSize
(
)
)
;
}
SkASSERT
(
fBitmap
.
rowBytes
(
)
=
=
fRowBytes
)
;
SkASSERT
(
this
-
>
getCachedCanvas
(
)
)
;
this
-
>
getCachedCanvas
(
)
-
>
getDevice
(
)
-
>
replaceBitmapBackendForRasterSurface
(
fBitmap
)
;
}
}
sk_sp
<
SkSurface
>
SkSurface
:
:
MakeRasterDirectReleaseProc
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rb
void
(
*
releaseProc
)
(
void
*
pixels
void
*
context
)
void
*
context
const
SkSurfaceProps
*
props
)
{
if
(
nullptr
=
=
releaseProc
)
{
context
=
nullptr
;
}
if
(
!
SkSurface_Raster
:
:
Valid
(
info
rb
)
)
{
return
nullptr
;
}
if
(
nullptr
=
=
pixels
)
{
return
nullptr
;
}
return
sk_make_sp
<
SkSurface_Raster
>
(
info
pixels
rb
releaseProc
context
props
)
;
}
sk_sp
<
SkSurface
>
SkSurface
:
:
MakeRasterDirect
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
const
SkSurfaceProps
*
props
)
{
return
MakeRasterDirectReleaseProc
(
info
pixels
rowBytes
nullptr
nullptr
props
)
;
}
sk_sp
<
SkSurface
>
SkSurface
:
:
MakeRaster
(
const
SkImageInfo
&
info
size_t
rowBytes
const
SkSurfaceProps
*
props
)
{
if
(
!
SkSurface_Raster
:
:
Valid
(
info
)
)
{
return
nullptr
;
}
SkAutoTUnref
<
SkPixelRef
>
pr
(
info
.
isOpaque
(
)
?
SkMallocPixelRef
:
:
NewAllocate
(
info
rowBytes
nullptr
)
:
SkMallocPixelRef
:
:
NewZeroed
(
info
rowBytes
nullptr
)
)
;
if
(
nullptr
=
=
pr
.
get
(
)
)
{
return
nullptr
;
}
if
(
rowBytes
)
{
SkASSERT
(
pr
-
>
rowBytes
(
)
=
=
rowBytes
)
;
}
return
sk_make_sp
<
SkSurface_Raster
>
(
pr
props
)
;
}
