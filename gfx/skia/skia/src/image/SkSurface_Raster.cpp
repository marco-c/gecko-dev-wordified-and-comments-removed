#
include
"
include
/
core
/
SkCanvas
.
h
"
#
include
"
include
/
core
/
SkMallocPixelRef
.
h
"
#
include
"
include
/
private
/
SkImageInfoPriv
.
h
"
#
include
"
src
/
core
/
SkDevice
.
h
"
#
include
"
src
/
core
/
SkImagePriv
.
h
"
#
include
"
src
/
image
/
SkSurface_Base
.
h
"
class
SkSurface_Raster
:
public
SkSurface_Base
{
public
:
SkSurface_Raster
(
const
SkImageInfo
&
void
*
size_t
rb
void
(
*
releaseProc
)
(
void
*
pixels
void
*
context
)
void
*
context
const
SkSurfaceProps
*
)
;
SkSurface_Raster
(
const
SkImageInfo
&
info
sk_sp
<
SkPixelRef
>
const
SkSurfaceProps
*
)
;
SkCanvas
*
onNewCanvas
(
)
override
;
sk_sp
<
SkSurface
>
onNewSurface
(
const
SkImageInfo
&
)
override
;
sk_sp
<
SkImage
>
onNewImageSnapshot
(
const
SkIRect
*
subset
)
override
;
void
onWritePixels
(
const
SkPixmap
&
int
x
int
y
)
override
;
void
onDraw
(
SkCanvas
*
SkScalar
x
SkScalar
y
const
SkPaint
*
)
override
;
void
onCopyOnWrite
(
ContentChangeMode
)
override
;
void
onRestoreBackingMutability
(
)
override
;
private
:
SkBitmap
fBitmap
;
size_t
fRowBytes
;
bool
fWeOwnThePixels
;
typedef
SkSurface_Base
INHERITED
;
}
;
bool
SkSurfaceValidateRasterInfo
(
const
SkImageInfo
&
info
size_t
rowBytes
)
{
if
(
!
SkImageInfoIsValid
(
info
)
)
{
return
false
;
}
if
(
info
.
colorType
(
)
=
=
kR8G8_unorm_SkColorType
|
|
info
.
colorType
(
)
=
=
kR16G16_unorm_SkColorType
|
|
info
.
colorType
(
)
=
=
kR16G16_float_SkColorType
|
|
info
.
colorType
(
)
=
=
kA16_unorm_SkColorType
|
|
info
.
colorType
(
)
=
=
kA16_float_SkColorType
|
|
info
.
colorType
(
)
=
=
kR16G16B16A16_unorm_SkColorType
)
{
return
false
;
}
if
(
kIgnoreRowBytesValue
=
=
rowBytes
)
{
return
true
;
}
int
shift
=
info
.
shiftPerPixel
(
)
;
uint64_t
minRB
=
(
uint64_t
)
info
.
width
(
)
<
<
shift
;
if
(
minRB
>
rowBytes
)
{
return
false
;
}
size_t
alignedRowBytes
=
rowBytes
>
>
shift
<
<
shift
;
if
(
alignedRowBytes
!
=
rowBytes
)
{
return
false
;
}
uint64_t
size
=
sk_64_mul
(
info
.
height
(
)
rowBytes
)
;
static
const
size_t
kMaxTotalSize
=
SK_MaxS32
;
if
(
size
>
kMaxTotalSize
)
{
return
false
;
}
return
true
;
}
SkSurface_Raster
:
:
SkSurface_Raster
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rb
void
(
*
releaseProc
)
(
void
*
pixels
void
*
context
)
void
*
context
const
SkSurfaceProps
*
props
)
:
INHERITED
(
info
props
)
{
fBitmap
.
installPixels
(
info
pixels
rb
releaseProc
context
)
;
fRowBytes
=
0
;
fWeOwnThePixels
=
false
;
}
SkSurface_Raster
:
:
SkSurface_Raster
(
const
SkImageInfo
&
info
sk_sp
<
SkPixelRef
>
pr
const
SkSurfaceProps
*
props
)
:
INHERITED
(
pr
-
>
width
(
)
pr
-
>
height
(
)
props
)
{
fBitmap
.
setInfo
(
info
pr
-
>
rowBytes
(
)
)
;
fRowBytes
=
pr
-
>
rowBytes
(
)
;
fBitmap
.
setPixelRef
(
std
:
:
move
(
pr
)
0
0
)
;
fWeOwnThePixels
=
true
;
}
SkCanvas
*
SkSurface_Raster
:
:
onNewCanvas
(
)
{
return
new
SkCanvas
(
fBitmap
this
-
>
props
(
)
)
;
}
sk_sp
<
SkSurface
>
SkSurface_Raster
:
:
onNewSurface
(
const
SkImageInfo
&
info
)
{
return
SkSurface
:
:
MakeRaster
(
info
&
this
-
>
props
(
)
)
;
}
void
SkSurface_Raster
:
:
onDraw
(
SkCanvas
*
canvas
SkScalar
x
SkScalar
y
const
SkPaint
*
paint
)
{
canvas
-
>
drawBitmap
(
fBitmap
x
y
paint
)
;
}
sk_sp
<
SkImage
>
SkSurface_Raster
:
:
onNewImageSnapshot
(
const
SkIRect
*
subset
)
{
if
(
subset
)
{
SkASSERT
(
SkIRect
:
:
MakeWH
(
fBitmap
.
width
(
)
fBitmap
.
height
(
)
)
.
contains
(
*
subset
)
)
;
SkBitmap
dst
;
dst
.
allocPixels
(
fBitmap
.
info
(
)
.
makeDimensions
(
subset
-
>
size
(
)
)
)
;
SkAssertResult
(
fBitmap
.
readPixels
(
dst
.
pixmap
(
)
subset
-
>
left
(
)
subset
-
>
top
(
)
)
)
;
dst
.
setImmutable
(
)
;
return
SkImage
:
:
MakeFromBitmap
(
dst
)
;
}
SkCopyPixelsMode
cpm
=
kIfMutable_SkCopyPixelsMode
;
if
(
fWeOwnThePixels
)
{
if
(
SkPixelRef
*
pr
=
fBitmap
.
pixelRef
(
)
)
{
pr
-
>
setTemporarilyImmutable
(
)
;
}
}
else
{
cpm
=
kAlways_SkCopyPixelsMode
;
}
return
SkMakeImageFromRasterBitmap
(
fBitmap
cpm
)
;
}
void
SkSurface_Raster
:
:
onWritePixels
(
const
SkPixmap
&
src
int
x
int
y
)
{
fBitmap
.
writePixels
(
src
x
y
)
;
}
void
SkSurface_Raster
:
:
onRestoreBackingMutability
(
)
{
SkASSERT
(
!
this
-
>
hasCachedImage
(
)
)
;
if
(
SkPixelRef
*
pr
=
fBitmap
.
pixelRef
(
)
)
{
pr
-
>
restoreMutability
(
)
;
}
}
void
SkSurface_Raster
:
:
onCopyOnWrite
(
ContentChangeMode
mode
)
{
sk_sp
<
SkImage
>
cached
(
this
-
>
refCachedImage
(
)
)
;
SkASSERT
(
cached
)
;
if
(
SkBitmapImageGetPixelRef
(
cached
.
get
(
)
)
=
=
fBitmap
.
pixelRef
(
)
)
{
SkASSERT
(
fWeOwnThePixels
)
;
if
(
kDiscard_ContentChangeMode
=
=
mode
)
{
fBitmap
.
allocPixels
(
)
;
}
else
{
SkBitmap
prev
(
fBitmap
)
;
fBitmap
.
allocPixels
(
)
;
SkASSERT
(
prev
.
info
(
)
=
=
fBitmap
.
info
(
)
)
;
SkASSERT
(
prev
.
rowBytes
(
)
=
=
fBitmap
.
rowBytes
(
)
)
;
memcpy
(
fBitmap
.
getPixels
(
)
prev
.
getPixels
(
)
fBitmap
.
computeByteSize
(
)
)
;
}
SkASSERT
(
fBitmap
.
rowBytes
(
)
=
=
fRowBytes
)
;
SkASSERT
(
this
-
>
getCachedCanvas
(
)
)
;
this
-
>
getCachedCanvas
(
)
-
>
getDevice
(
)
-
>
replaceBitmapBackendForRasterSurface
(
fBitmap
)
;
}
}
sk_sp
<
SkSurface
>
SkSurface
:
:
MakeRasterDirectReleaseProc
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rb
void
(
*
releaseProc
)
(
void
*
pixels
void
*
context
)
void
*
context
const
SkSurfaceProps
*
props
)
{
if
(
nullptr
=
=
releaseProc
)
{
context
=
nullptr
;
}
if
(
!
SkSurfaceValidateRasterInfo
(
info
rb
)
)
{
return
nullptr
;
}
if
(
nullptr
=
=
pixels
)
{
return
nullptr
;
}
return
sk_make_sp
<
SkSurface_Raster
>
(
info
pixels
rb
releaseProc
context
props
)
;
}
sk_sp
<
SkSurface
>
SkSurface
:
:
MakeRasterDirect
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
const
SkSurfaceProps
*
props
)
{
return
MakeRasterDirectReleaseProc
(
info
pixels
rowBytes
nullptr
nullptr
props
)
;
}
sk_sp
<
SkSurface
>
SkSurface
:
:
MakeRaster
(
const
SkImageInfo
&
info
size_t
rowBytes
const
SkSurfaceProps
*
props
)
{
if
(
!
SkSurfaceValidateRasterInfo
(
info
)
)
{
return
nullptr
;
}
sk_sp
<
SkPixelRef
>
pr
=
SkMallocPixelRef
:
:
MakeAllocate
(
info
rowBytes
)
;
if
(
!
pr
)
{
return
nullptr
;
}
if
(
rowBytes
)
{
SkASSERT
(
pr
-
>
rowBytes
(
)
=
=
rowBytes
)
;
}
return
sk_make_sp
<
SkSurface_Raster
>
(
info
std
:
:
move
(
pr
)
props
)
;
}
sk_sp
<
SkSurface
>
SkSurface
:
:
MakeRasterN32Premul
(
int
width
int
height
const
SkSurfaceProps
*
surfaceProps
)
{
return
MakeRaster
(
SkImageInfo
:
:
MakeN32Premul
(
width
height
)
surfaceProps
)
;
}
