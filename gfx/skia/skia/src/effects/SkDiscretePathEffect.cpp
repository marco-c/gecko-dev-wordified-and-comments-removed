#
include
"
include
/
core
/
SkPathMeasure
.
h
"
#
include
"
include
/
core
/
SkStrokeRec
.
h
"
#
include
"
include
/
effects
/
SkDiscretePathEffect
.
h
"
#
include
"
include
/
private
/
SkFixed
.
h
"
#
include
"
src
/
core
/
SkPointPriv
.
h
"
#
include
"
src
/
core
/
SkReadBuffer
.
h
"
#
include
"
src
/
core
/
SkWriteBuffer
.
h
"
sk_sp
<
SkPathEffect
>
SkDiscretePathEffect
:
:
Make
(
SkScalar
segLength
SkScalar
deviation
uint32_t
seedAssist
)
{
if
(
!
SkScalarIsFinite
(
segLength
)
|
|
!
SkScalarIsFinite
(
deviation
)
)
{
return
nullptr
;
}
if
(
segLength
<
=
SK_ScalarNearlyZero
)
{
return
nullptr
;
}
return
sk_sp
<
SkPathEffect
>
(
new
SkDiscretePathEffect
(
segLength
deviation
seedAssist
)
)
;
}
static
void
Perterb
(
SkPoint
*
p
const
SkVector
&
tangent
SkScalar
scale
)
{
SkVector
normal
=
tangent
;
SkPointPriv
:
:
RotateCCW
(
&
normal
)
;
normal
.
setLength
(
scale
)
;
*
p
+
=
normal
;
}
SkDiscretePathEffect
:
:
SkDiscretePathEffect
(
SkScalar
segLength
SkScalar
deviation
uint32_t
seedAssist
)
:
fSegLength
(
segLength
)
fPerterb
(
deviation
)
fSeedAssist
(
seedAssist
)
{
}
class
LCGRandom
{
public
:
LCGRandom
(
uint32_t
seed
)
:
fSeed
(
seed
)
{
}
SkScalar
nextSScalar1
(
)
{
return
SkFixedToScalar
(
this
-
>
nextSFixed1
(
)
)
;
}
private
:
uint32_t
nextU
(
)
{
uint32_t
r
=
fSeed
*
kMul
+
kAdd
;
fSeed
=
r
;
return
r
;
}
int32_t
nextS
(
)
{
return
(
int32_t
)
this
-
>
nextU
(
)
;
}
SkFixed
nextSFixed1
(
)
{
return
this
-
>
nextS
(
)
>
>
15
;
}
enum
{
kMul
=
1664525
kAdd
=
1013904223
}
;
uint32_t
fSeed
;
}
;
bool
SkDiscretePathEffect
:
:
onFilterPath
(
SkPath
*
dst
const
SkPath
&
src
SkStrokeRec
*
rec
const
SkRect
*
)
const
{
bool
doFill
=
rec
-
>
isFillStyle
(
)
;
SkPathMeasure
meas
(
src
doFill
)
;
uint32_t
seed
=
fSeedAssist
^
SkScalarRoundToInt
(
meas
.
getLength
(
)
)
;
LCGRandom
rand
(
seed
^
(
(
seed
<
<
16
)
|
(
seed
>
>
16
)
)
)
;
SkScalar
scale
=
fPerterb
;
SkPoint
p
;
SkVector
v
;
do
{
SkScalar
length
=
meas
.
getLength
(
)
;
if
(
fSegLength
*
(
2
+
doFill
)
>
length
)
{
meas
.
getSegment
(
0
length
dst
true
)
;
}
else
{
int
n
=
SkScalarRoundToInt
(
length
/
fSegLength
)
;
constexpr
int
kMaxReasonableIterations
=
100000
;
n
=
SkTMin
(
n
kMaxReasonableIterations
)
;
SkScalar
delta
=
length
/
n
;
SkScalar
distance
=
0
;
if
(
meas
.
isClosed
(
)
)
{
n
-
=
1
;
distance
+
=
delta
/
2
;
}
if
(
meas
.
getPosTan
(
distance
&
p
&
v
)
)
{
Perterb
(
&
p
v
rand
.
nextSScalar1
(
)
*
scale
)
;
dst
-
>
moveTo
(
p
)
;
}
while
(
-
-
n
>
=
0
)
{
distance
+
=
delta
;
if
(
meas
.
getPosTan
(
distance
&
p
&
v
)
)
{
Perterb
(
&
p
v
rand
.
nextSScalar1
(
)
*
scale
)
;
dst
-
>
lineTo
(
p
)
;
}
}
if
(
meas
.
isClosed
(
)
)
{
dst
-
>
close
(
)
;
}
}
}
while
(
meas
.
nextContour
(
)
)
;
return
true
;
}
sk_sp
<
SkFlattenable
>
SkDiscretePathEffect
:
:
CreateProc
(
SkReadBuffer
&
buffer
)
{
SkScalar
segLength
=
buffer
.
readScalar
(
)
;
SkScalar
perterb
=
buffer
.
readScalar
(
)
;
uint32_t
seed
=
buffer
.
readUInt
(
)
;
return
Make
(
segLength
perterb
seed
)
;
}
void
SkDiscretePathEffect
:
:
flatten
(
SkWriteBuffer
&
buffer
)
const
{
buffer
.
writeScalar
(
fSegLength
)
;
buffer
.
writeScalar
(
fPerterb
)
;
buffer
.
writeUInt
(
fSeedAssist
)
;
}
