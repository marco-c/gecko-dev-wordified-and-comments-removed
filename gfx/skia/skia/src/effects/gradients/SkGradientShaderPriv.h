#
ifndef
SkGradientShaderPriv_DEFINED
#
define
SkGradientShaderPriv_DEFINED
#
include
"
SkGradientBitmapCache
.
h
"
#
include
"
SkGradientShader
.
h
"
#
include
"
SkClampRange
.
h
"
#
include
"
SkColorPriv
.
h
"
#
include
"
SkReadBuffer
.
h
"
#
include
"
SkWriteBuffer
.
h
"
#
include
"
SkMallocPixelRef
.
h
"
#
include
"
SkUtils
.
h
"
#
include
"
SkShader
.
h
"
#
include
"
SkOnce
.
h
"
static
inline
void
sk_memset32_dither
(
uint32_t
dst
[
]
uint32_t
v0
uint32_t
v1
int
count
)
{
if
(
count
>
0
)
{
if
(
v0
=
=
v1
)
{
sk_memset32
(
dst
v0
count
)
;
}
else
{
int
pairs
=
count
>
>
1
;
for
(
int
i
=
0
;
i
<
pairs
;
i
+
+
)
{
*
dst
+
+
=
v0
;
*
dst
+
+
=
v1
;
}
if
(
count
&
1
)
{
*
dst
=
v0
;
}
}
}
}
static
inline
SkFixed
clamp_tileproc
(
SkFixed
x
)
{
return
SkClampMax
(
x
0xFFFF
)
;
}
static
inline
SkFixed
repeat_tileproc
(
SkFixed
x
)
{
return
x
&
0xFFFF
;
}
#
if
defined
(
_MSC_VER
)
&
&
(
_MSC_VER
>
=
1600
)
#
pragma
optimize
(
"
"
off
)
#
endif
static
inline
SkFixed
mirror_tileproc
(
SkFixed
x
)
{
int
s
=
SkLeftShift
(
x
15
)
>
>
31
;
return
(
x
^
s
)
&
0xFFFF
;
}
#
if
defined
(
_MSC_VER
)
&
&
(
_MSC_VER
>
=
1600
)
#
pragma
optimize
(
"
"
on
)
#
endif
typedef
SkFixed
(
*
TileProc
)
(
SkFixed
)
;
static
const
TileProc
gTileProcs
[
]
=
{
clamp_tileproc
repeat_tileproc
mirror_tileproc
}
;
class
SkGradientShaderBase
:
public
SkShader
{
public
:
struct
Descriptor
{
Descriptor
(
)
{
sk_bzero
(
this
sizeof
(
*
this
)
)
;
fTileMode
=
SkShader
:
:
kClamp_TileMode
;
}
const
SkMatrix
*
fLocalMatrix
;
const
SkColor
*
fColors
;
const
SkScalar
*
fPos
;
int
fCount
;
SkShader
:
:
TileMode
fTileMode
;
uint32_t
fGradFlags
;
void
flatten
(
SkWriteBuffer
&
)
const
;
}
;
class
DescriptorScope
:
public
Descriptor
{
public
:
DescriptorScope
(
)
{
}
bool
unflatten
(
SkReadBuffer
&
)
;
SkColor
*
mutableColors
(
)
{
return
const_cast
<
SkColor
*
>
(
fColors
)
;
}
SkScalar
*
mutablePos
(
)
{
return
const_cast
<
SkScalar
*
>
(
fPos
)
;
}
private
:
enum
{
kStorageCount
=
16
}
;
SkColor
fColorStorage
[
kStorageCount
]
;
SkScalar
fPosStorage
[
kStorageCount
]
;
SkMatrix
fLocalMatrixStorage
;
SkAutoMalloc
fDynamicStorage
;
}
;
public
:
SkGradientShaderBase
(
const
Descriptor
&
desc
const
SkMatrix
&
ptsToUnit
)
;
virtual
~
SkGradientShaderBase
(
)
;
class
GradientShaderCache
:
public
SkRefCnt
{
public
:
GradientShaderCache
(
U8CPU
alpha
bool
dither
const
SkGradientShaderBase
&
shader
)
;
~
GradientShaderCache
(
)
;
const
uint16_t
*
getCache16
(
)
;
const
SkPMColor
*
getCache32
(
)
;
SkMallocPixelRef
*
getCache32PixelRef
(
)
const
{
return
fCache32PixelRef
;
}
unsigned
getAlpha
(
)
const
{
return
fCacheAlpha
;
}
bool
getDither
(
)
const
{
return
fCacheDither
;
}
private
:
uint16_t
*
fCache16
;
SkPMColor
*
fCache32
;
uint16_t
*
fCache16Storage
;
SkMallocPixelRef
*
fCache32PixelRef
;
const
unsigned
fCacheAlpha
;
const
bool
fCacheDither
;
const
SkGradientShaderBase
&
fShader
;
bool
fCache16Inited
fCache32Inited
;
SkMutex
fCache16Mutex
fCache32Mutex
;
static
void
initCache16
(
GradientShaderCache
*
cache
)
;
static
void
initCache32
(
GradientShaderCache
*
cache
)
;
static
void
Build16bitCache
(
uint16_t
[
]
SkColor
c0
SkColor
c1
int
count
bool
dither
)
;
static
void
Build32bitCache
(
SkPMColor
[
]
SkColor
c0
SkColor
c1
int
count
U8CPU
alpha
uint32_t
gradFlags
bool
dither
)
;
}
;
class
GradientShaderBaseContext
:
public
SkShader
:
:
Context
{
public
:
GradientShaderBaseContext
(
const
SkGradientShaderBase
&
shader
const
ContextRec
&
)
;
uint32_t
getFlags
(
)
const
override
{
return
fFlags
;
}
protected
:
SkMatrix
fDstToIndex
;
SkMatrix
:
:
MapXYProc
fDstToIndexProc
;
uint8_t
fDstToIndexClass
;
uint8_t
fFlags
;
bool
fDither
;
SkAutoTUnref
<
GradientShaderCache
>
fCache
;
private
:
typedef
SkShader
:
:
Context
INHERITED
;
}
;
bool
isOpaque
(
)
const
override
;
void
getGradientTableBitmap
(
SkBitmap
*
)
const
;
enum
{
kCache16Bits
=
8
kCache16Count
=
(
1
<
<
kCache16Bits
)
kCache16Shift
=
16
-
kCache16Bits
kSqrt16Shift
=
8
-
kCache16Bits
kCache32Bits
=
8
kCache32Count
=
(
1
<
<
kCache32Bits
)
kCache32Shift
=
16
-
kCache32Bits
kSqrt32Shift
=
8
-
kCache32Bits
kDitherStride32
=
kCache32Count
kDitherStride16
=
kCache16Count
}
;
enum
GpuColorType
{
kTwo_GpuColorType
kThree_GpuColorType
kTexture_GpuColorType
}
;
GpuColorType
getGpuColorType
(
SkColor
colors
[
3
]
)
const
;
uint32_t
getGradFlags
(
)
const
{
return
fGradFlags
;
}
protected
:
SkGradientShaderBase
(
SkReadBuffer
&
)
;
void
flatten
(
SkWriteBuffer
&
)
const
override
;
SK_TO_STRING_OVERRIDE
(
)
const
SkMatrix
fPtsToUnit
;
TileMode
fTileMode
;
TileProc
fTileProc
;
int
fColorCount
;
uint8_t
fGradFlags
;
struct
Rec
{
SkFixed
fPos
;
uint32_t
fScale
;
}
;
Rec
*
fRecs
;
void
commonAsAGradient
(
GradientInfo
*
bool
flipGrad
=
false
)
const
;
bool
onAsLuminanceColor
(
SkColor
*
)
const
override
;
static
void
FlipGradientColors
(
SkColor
*
colorDst
Rec
*
recDst
SkColor
*
colorSrc
Rec
*
recSrc
int
count
)
;
private
:
enum
{
kColorStorageCount
=
4
kStorageSize
=
kColorStorageCount
*
(
sizeof
(
SkColor
)
+
sizeof
(
SkScalar
)
+
sizeof
(
Rec
)
)
}
;
SkColor
fStorage
[
(
kStorageSize
+
3
)
>
>
2
]
;
public
:
SkColor
*
fOrigColors
;
SkScalar
*
fOrigPos
;
bool
colorsAreOpaque
(
)
const
{
return
fColorsAreOpaque
;
}
private
:
bool
fColorsAreOpaque
;
GradientShaderCache
*
refCache
(
U8CPU
alpha
bool
dither
)
const
;
mutable
SkMutex
fCacheMutex
;
mutable
SkAutoTUnref
<
GradientShaderCache
>
fCache
;
void
initCommon
(
)
;
typedef
SkShader
INHERITED
;
}
;
static
inline
int
init_dither_toggle
(
int
x
int
y
)
{
x
&
=
1
;
y
=
(
y
&
1
)
<
<
1
;
return
(
x
|
y
)
*
SkGradientShaderBase
:
:
kDitherStride32
;
}
static
inline
int
next_dither_toggle
(
int
toggle
)
{
return
toggle
^
SkGradientShaderBase
:
:
kDitherStride32
;
}
static
inline
int
init_dither_toggle16
(
int
x
int
y
)
{
return
(
(
x
^
y
)
&
1
)
*
SkGradientShaderBase
:
:
kDitherStride16
;
}
static
inline
int
next_dither_toggle16
(
int
toggle
)
{
return
toggle
^
SkGradientShaderBase
:
:
kDitherStride16
;
}
#
if
SK_SUPPORT_GPU
#
include
"
GrCoordTransform
.
h
"
#
include
"
GrFragmentProcessor
.
h
"
#
include
"
glsl
/
GrGLSLFragmentProcessor
.
h
"
#
include
"
glsl
/
GrGLSLProgramDataManager
.
h
"
class
GrInvariantOutput
;
class
GrTextureStripAtlas
;
class
GrGradientEffect
:
public
GrFragmentProcessor
{
public
:
GrGradientEffect
(
GrContext
*
ctx
const
SkGradientShaderBase
&
shader
const
SkMatrix
&
matrix
SkShader
:
:
TileMode
tileMode
)
;
virtual
~
GrGradientEffect
(
)
;
bool
useAtlas
(
)
const
{
return
SkToBool
(
-
1
!
=
fRow
)
;
}
SkScalar
getYCoord
(
)
const
{
return
fYCoord
;
}
;
SkGradientShaderBase
:
:
GpuColorType
getColorType
(
)
const
{
return
fColorType
;
}
enum
PremulType
{
kBeforeInterp_PremulType
kAfterInterp_PremulType
}
;
PremulType
getPremulType
(
)
const
{
return
fPremulType
;
}
const
SkColor
*
getColors
(
int
pos
)
const
{
SkASSERT
(
fColorType
!
=
SkGradientShaderBase
:
:
kTexture_GpuColorType
)
;
SkASSERT
(
(
pos
-
1
)
<
=
fColorType
)
;
return
&
fColors
[
pos
]
;
}
protected
:
static
const
int
kMaxRandomGradientColors
=
4
;
static
int
RandomGradientParams
(
SkRandom
*
r
SkColor
colors
[
kMaxRandomGradientColors
]
SkScalar
*
*
stops
SkShader
:
:
TileMode
*
tm
)
;
bool
onIsEqual
(
const
GrFragmentProcessor
&
)
const
override
;
void
onComputeInvariantOutput
(
GrInvariantOutput
*
inout
)
const
override
;
const
GrCoordTransform
&
getCoordTransform
(
)
const
{
return
fCoordTransform
;
}
private
:
static
const
GrCoordSet
kCoordSet
=
kLocal_GrCoordSet
;
GrCoordTransform
fCoordTransform
;
GrTextureAccess
fTextureAccess
;
SkScalar
fYCoord
;
GrTextureStripAtlas
*
fAtlas
;
int
fRow
;
bool
fIsOpaque
;
SkGradientShaderBase
:
:
GpuColorType
fColorType
;
SkColor
fColors
[
3
]
;
PremulType
fPremulType
;
typedef
GrFragmentProcessor
INHERITED
;
}
;
class
GrGLGradientEffect
:
public
GrGLSLFragmentProcessor
{
public
:
GrGLGradientEffect
(
)
;
virtual
~
GrGLGradientEffect
(
)
;
protected
:
void
onSetData
(
const
GrGLSLProgramDataManager
&
const
GrProcessor
&
)
override
;
protected
:
static
uint32_t
GenBaseGradientKey
(
const
GrProcessor
&
)
;
void
emitUniforms
(
GrGLSLUniformHandler
*
const
GrGradientEffect
&
)
;
void
emitColor
(
GrGLSLFragmentBuilder
*
fragBuilder
GrGLSLUniformHandler
*
uniformHandler
const
GrGLSLCaps
*
caps
const
GrGradientEffect
&
const
char
*
gradientTValue
const
char
*
outputColor
const
char
*
inputColor
const
TextureSamplerArray
&
samplers
)
;
private
:
enum
{
kPremulTypeKeyBitCnt
=
1
kPremulTypeMask
=
1
kPremulBeforeInterpKey
=
kPremulTypeMask
kTwoColorKey
=
2
<
<
kPremulTypeKeyBitCnt
kThreeColorKey
=
3
<
<
kPremulTypeKeyBitCnt
kColorKeyMask
=
kTwoColorKey
|
kThreeColorKey
kColorKeyBitCnt
=
2
kBaseKeyBitCnt
=
(
kPremulTypeKeyBitCnt
+
kColorKeyBitCnt
)
}
;
GR_STATIC_ASSERT
(
kBaseKeyBitCnt
<
=
32
)
;
SkScalar
fCachedYCoord
;
GrGLSLProgramDataManager
:
:
UniformHandle
fFSYUni
;
GrGLSLProgramDataManager
:
:
UniformHandle
fColorStartUni
;
GrGLSLProgramDataManager
:
:
UniformHandle
fColorMidUni
;
GrGLSLProgramDataManager
:
:
UniformHandle
fColorEndUni
;
typedef
GrGLSLFragmentProcessor
INHERITED
;
}
;
#
endif
#
endif
