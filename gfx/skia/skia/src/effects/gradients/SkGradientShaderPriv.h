#
ifndef
SkGradientShaderPriv_DEFINED
#
define
SkGradientShaderPriv_DEFINED
#
include
"
SkGradientBitmapCache
.
h
"
#
include
"
SkGradientShader
.
h
"
#
include
"
SkArenaAlloc
.
h
"
#
include
"
SkAutoMalloc
.
h
"
#
include
"
SkClampRange
.
h
"
#
include
"
SkColorPriv
.
h
"
#
include
"
SkColorSpace
.
h
"
#
include
"
SkOnce
.
h
"
#
include
"
SkReadBuffer
.
h
"
#
include
"
SkShader
.
h
"
#
include
"
SkUtils
.
h
"
#
include
"
SkWriteBuffer
.
h
"
#
if
SK_SUPPORT_GPU
#
define
GR_GL_USE_ACCURATE_HARD_STOP_GRADIENTS
1
#
endif
static
inline
void
sk_memset32_dither
(
uint32_t
dst
[
]
uint32_t
v0
uint32_t
v1
int
count
)
{
if
(
count
>
0
)
{
if
(
v0
=
=
v1
)
{
sk_memset32
(
dst
v0
count
)
;
}
else
{
int
pairs
=
count
>
>
1
;
for
(
int
i
=
0
;
i
<
pairs
;
i
+
+
)
{
*
dst
+
+
=
v0
;
*
dst
+
+
=
v1
;
}
if
(
count
&
1
)
{
*
dst
=
v0
;
}
}
}
}
static
inline
SkFixed
clamp_tileproc
(
SkFixed
x
)
{
return
SkClampMax
(
x
0xFFFF
)
;
}
static
inline
SkFixed
repeat_tileproc
(
SkFixed
x
)
{
return
x
&
0xFFFF
;
}
static
inline
SkFixed
mirror_tileproc
(
SkFixed
x
)
{
int
s
=
SkLeftShift
(
x
15
)
>
>
31
;
return
(
x
^
s
)
&
0xFFFF
;
}
typedef
SkFixed
(
*
TileProc
)
(
SkFixed
)
;
static
const
TileProc
gTileProcs
[
]
=
{
clamp_tileproc
repeat_tileproc
mirror_tileproc
}
;
class
SkGradientShaderBase
:
public
SkShader
{
public
:
struct
Descriptor
{
Descriptor
(
)
{
sk_bzero
(
this
sizeof
(
*
this
)
)
;
fTileMode
=
SkShader
:
:
kClamp_TileMode
;
}
const
SkMatrix
*
fLocalMatrix
;
const
SkColor4f
*
fColors
;
sk_sp
<
SkColorSpace
>
fColorSpace
;
const
SkScalar
*
fPos
;
int
fCount
;
SkShader
:
:
TileMode
fTileMode
;
uint32_t
fGradFlags
;
void
flatten
(
SkWriteBuffer
&
)
const
;
}
;
class
DescriptorScope
:
public
Descriptor
{
public
:
DescriptorScope
(
)
{
}
bool
unflatten
(
SkReadBuffer
&
)
;
SkColor4f
*
mutableColors
(
)
{
return
const_cast
<
SkColor4f
*
>
(
fColors
)
;
}
SkScalar
*
mutablePos
(
)
{
return
const_cast
<
SkScalar
*
>
(
fPos
)
;
}
private
:
enum
{
kStorageCount
=
16
}
;
SkColor4f
fColorStorage
[
kStorageCount
]
;
SkScalar
fPosStorage
[
kStorageCount
]
;
SkMatrix
fLocalMatrixStorage
;
SkAutoMalloc
fDynamicStorage
;
}
;
SkGradientShaderBase
(
const
Descriptor
&
desc
const
SkMatrix
&
ptsToUnit
)
;
~
SkGradientShaderBase
(
)
override
;
class
GradientShaderCache
:
public
SkRefCnt
{
public
:
GradientShaderCache
(
U8CPU
alpha
bool
dither
const
SkGradientShaderBase
&
shader
)
;
~
GradientShaderCache
(
)
;
const
SkPMColor
*
getCache32
(
)
;
SkPixelRef
*
getCache32PixelRef
(
)
const
{
return
fCache32PixelRef
.
get
(
)
;
}
unsigned
getAlpha
(
)
const
{
return
fCacheAlpha
;
}
bool
getDither
(
)
const
{
return
fCacheDither
;
}
private
:
SkPMColor
*
fCache32
;
sk_sp
<
SkPixelRef
>
fCache32PixelRef
;
const
unsigned
fCacheAlpha
;
const
bool
fCacheDither
;
const
SkGradientShaderBase
&
fShader
;
SkOnce
fCache32InitOnce
;
static
void
initCache32
(
GradientShaderCache
*
cache
)
;
static
void
Build32bitCache
(
SkPMColor
[
]
SkColor
c0
SkColor
c1
int
count
U8CPU
alpha
uint32_t
gradFlags
bool
dither
)
;
}
;
class
GradientShaderBaseContext
:
public
SkShader
:
:
Context
{
public
:
GradientShaderBaseContext
(
const
SkGradientShaderBase
&
shader
const
ContextRec
&
)
;
uint32_t
getFlags
(
)
const
override
{
return
fFlags
;
}
bool
isValid
(
)
const
;
protected
:
SkMatrix
fDstToIndex
;
SkMatrix
:
:
MapXYProc
fDstToIndexProc
;
uint8_t
fDstToIndexClass
;
uint8_t
fFlags
;
bool
fDither
;
sk_sp
<
GradientShaderCache
>
fCache
;
private
:
typedef
SkShader
:
:
Context
INHERITED
;
}
;
bool
isOpaque
(
)
const
override
;
enum
class
GradientBitmapType
:
uint8_t
{
kLegacy
kSRGB
kHalfFloat
}
;
void
getGradientTableBitmap
(
SkBitmap
*
GradientBitmapType
bitmapType
)
const
;
enum
{
kCache32Bits
=
8
kCache32Count
=
(
1
<
<
kCache32Bits
)
kCache32Shift
=
16
-
kCache32Bits
kSqrt32Shift
=
8
-
kCache32Bits
kDitherStride32
=
kCache32Count
}
;
uint32_t
getGradFlags
(
)
const
{
return
fGradFlags
;
}
protected
:
class
GradientShaderBase4fContext
;
SkGradientShaderBase
(
SkReadBuffer
&
)
;
void
flatten
(
SkWriteBuffer
&
)
const
override
;
SK_TO_STRING_OVERRIDE
(
)
const
SkMatrix
fPtsToUnit
;
TileMode
fTileMode
;
TileProc
fTileProc
;
uint8_t
fGradFlags
;
struct
Rec
{
SkFixed
fPos
;
uint32_t
fScale
;
}
;
Rec
*
fRecs
;
void
commonAsAGradient
(
GradientInfo
*
bool
flipGrad
=
false
)
const
;
bool
onAsLuminanceColor
(
SkColor
*
)
const
override
;
void
initLinearBitmap
(
SkBitmap
*
bitmap
)
const
;
static
void
FlipGradientColors
(
SkColor
*
colorDst
Rec
*
recDst
SkColor
*
colorSrc
Rec
*
recSrc
int
count
)
;
template
<
typename
T
typename
.
.
.
Args
>
static
Context
*
CheckedMakeContext
(
SkArenaAlloc
*
alloc
Args
&
&
.
.
.
args
)
{
auto
*
ctx
=
alloc
-
>
make
<
T
>
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
if
(
!
ctx
-
>
isValid
(
)
)
{
return
nullptr
;
}
return
ctx
;
}
private
:
enum
{
kColorStorageCount
=
4
kStorageSize
=
kColorStorageCount
*
(
sizeof
(
SkColor
)
+
sizeof
(
SkScalar
)
+
sizeof
(
Rec
)
+
sizeof
(
SkColor4f
)
)
}
;
SkColor
fStorage
[
(
kStorageSize
+
3
)
>
>
2
]
;
public
:
SkColor
*
fOrigColors
;
SkColor4f
*
fOrigColors4f
;
SkScalar
*
fOrigPos
;
int
fColorCount
;
sk_sp
<
SkColorSpace
>
fColorSpace
;
bool
colorsAreOpaque
(
)
const
{
return
fColorsAreOpaque
;
}
TileMode
getTileMode
(
)
const
{
return
fTileMode
;
}
Rec
*
getRecs
(
)
const
{
return
fRecs
;
}
private
:
bool
fColorsAreOpaque
;
sk_sp
<
GradientShaderCache
>
refCache
(
U8CPU
alpha
bool
dither
)
const
;
mutable
SkMutex
fCacheMutex
;
mutable
sk_sp
<
GradientShaderCache
>
fCache
;
void
initCommon
(
)
;
typedef
SkShader
INHERITED
;
}
;
static
inline
int
init_dither_toggle
(
int
x
int
y
)
{
x
&
=
1
;
y
=
(
y
&
1
)
<
<
1
;
return
(
x
|
y
)
*
SkGradientShaderBase
:
:
kDitherStride32
;
}
static
inline
int
next_dither_toggle
(
int
toggle
)
{
return
toggle
^
SkGradientShaderBase
:
:
kDitherStride32
;
}
#
if
SK_SUPPORT_GPU
#
include
"
GrColorSpaceXform
.
h
"
#
include
"
GrCoordTransform
.
h
"
#
include
"
GrFragmentProcessor
.
h
"
#
include
"
glsl
/
GrGLSLColorSpaceXformHelper
.
h
"
#
include
"
glsl
/
GrGLSLFragmentProcessor
.
h
"
#
include
"
glsl
/
GrGLSLProgramDataManager
.
h
"
class
GrInvariantOutput
;
class
GrTextureStripAtlas
;
class
GrGradientEffect
:
public
GrFragmentProcessor
{
public
:
struct
CreateArgs
{
CreateArgs
(
GrContext
*
context
const
SkGradientShaderBase
*
shader
const
SkMatrix
*
matrix
SkShader
:
:
TileMode
tileMode
sk_sp
<
GrColorSpaceXform
>
colorSpaceXform
bool
gammaCorrect
)
:
fContext
(
context
)
fShader
(
shader
)
fMatrix
(
matrix
)
fTileMode
(
tileMode
)
fColorSpaceXform
(
std
:
:
move
(
colorSpaceXform
)
)
fGammaCorrect
(
gammaCorrect
)
{
}
GrContext
*
fContext
;
const
SkGradientShaderBase
*
fShader
;
const
SkMatrix
*
fMatrix
;
SkShader
:
:
TileMode
fTileMode
;
sk_sp
<
GrColorSpaceXform
>
fColorSpaceXform
;
bool
fGammaCorrect
;
}
;
class
GLSLProcessor
;
~
GrGradientEffect
(
)
override
;
bool
useAtlas
(
)
const
{
return
SkToBool
(
-
1
!
=
fRow
)
;
}
SkScalar
getYCoord
(
)
const
{
return
fYCoord
;
}
enum
ColorType
{
kTwo_ColorType
kThree_ColorType
kTexture_ColorType
#
if
GR_GL_USE_ACCURATE_HARD_STOP_GRADIENTS
kSingleHardStop_ColorType
kHardStopLeftEdged_ColorType
kHardStopRightEdged_ColorType
#
endif
}
;
ColorType
getColorType
(
)
const
{
return
fColorType
;
}
ColorType
determineColorType
(
const
SkGradientShaderBase
&
shader
)
;
enum
PremulType
{
kBeforeInterp_PremulType
kAfterInterp_PremulType
}
;
PremulType
getPremulType
(
)
const
{
return
fPremulType
;
}
const
SkColor
*
getColors
(
int
pos
)
const
{
SkASSERT
(
fColorType
!
=
kTexture_ColorType
)
;
SkASSERT
(
pos
<
fColors
.
count
(
)
)
;
return
&
fColors
[
pos
]
;
}
const
SkColor4f
*
getColors4f
(
int
pos
)
const
{
SkASSERT
(
fColorType
!
=
kTexture_ColorType
)
;
SkASSERT
(
pos
<
fColors4f
.
count
(
)
)
;
return
&
fColors4f
[
pos
]
;
}
protected
:
GrGradientEffect
(
const
CreateArgs
&
bool
isOpaque
)
;
#
if
GR_TEST_UTILS
struct
RandomGradientParams
{
static
const
int
kMaxRandomGradientColors
=
5
;
RandomGradientParams
(
SkRandom
*
r
)
;
bool
fUseColors4f
;
SkColor
fColors
[
kMaxRandomGradientColors
]
;
SkColor4f
fColors4f
[
kMaxRandomGradientColors
]
;
sk_sp
<
SkColorSpace
>
fColorSpace
;
SkScalar
fStopStorage
[
kMaxRandomGradientColors
]
;
SkShader
:
:
TileMode
fTileMode
;
int
fColorCount
;
SkScalar
*
fStops
;
}
;
#
endif
bool
onIsEqual
(
const
GrFragmentProcessor
&
)
const
override
;
const
GrCoordTransform
&
getCoordTransform
(
)
const
{
return
fCoordTransform
;
}
private
:
static
OptimizationFlags
OptFlags
(
bool
isOpaque
)
;
SkTDArray
<
SkColor
>
fColors
;
SkTDArray
<
SkColor4f
>
fColors4f
;
sk_sp
<
GrColorSpaceXform
>
fColorSpaceXform
;
SkTDArray
<
SkScalar
>
fPositions
;
SkShader
:
:
TileMode
fTileMode
;
GrCoordTransform
fCoordTransform
;
TextureSampler
fTextureSampler
;
SkScalar
fYCoord
;
GrTextureStripAtlas
*
fAtlas
;
int
fRow
;
bool
fIsOpaque
;
ColorType
fColorType
;
PremulType
fPremulType
;
typedef
GrFragmentProcessor
INHERITED
;
}
;
class
GrGradientEffect
:
:
GLSLProcessor
:
public
GrGLSLFragmentProcessor
{
public
:
GLSLProcessor
(
)
{
fCachedYCoord
=
SK_ScalarMax
;
}
protected
:
void
onSetData
(
const
GrGLSLProgramDataManager
&
const
GrFragmentProcessor
&
)
override
;
protected
:
static
uint32_t
GenBaseGradientKey
(
const
GrProcessor
&
)
;
void
emitUniforms
(
GrGLSLUniformHandler
*
const
GrGradientEffect
&
)
;
void
emitColor
(
GrGLSLFPFragmentBuilder
*
fragBuilder
GrGLSLUniformHandler
*
uniformHandler
const
GrShaderCaps
*
shaderCaps
const
GrGradientEffect
&
const
char
*
gradientTValue
const
char
*
outputColor
const
char
*
inputColor
const
TextureSamplers
&
)
;
private
:
enum
{
kPremulBeforeInterpKey
=
1
kTwoColorKey
=
2
kThreeColorKey
=
4
#
if
GR_GL_USE_ACCURATE_HARD_STOP_GRADIENTS
kHardStopCenteredKey
=
6
kHardStopZeroZeroOneKey
=
8
kHardStopZeroOneOneKey
=
10
kClampTileMode
=
16
kRepeatTileMode
=
32
kMirrorTileMode
=
48
kReservedBits
=
6
#
endif
}
;
SkScalar
fCachedYCoord
;
GrGLSLProgramDataManager
:
:
UniformHandle
fColorsUni
;
GrGLSLProgramDataManager
:
:
UniformHandle
fHardStopT
;
GrGLSLProgramDataManager
:
:
UniformHandle
fFSYUni
;
GrGLSLColorSpaceXformHelper
fColorSpaceHelper
;
typedef
GrGLSLFragmentProcessor
INHERITED
;
}
;
#
endif
#
endif
