#
include
"
SkDashPathEffect
.
h
"
#
include
"
SkDashPathPriv
.
h
"
#
include
"
SkReadBuffer
.
h
"
#
include
"
SkWriteBuffer
.
h
"
#
include
"
SkStrokeRec
.
h
"
SkDashPathEffect
:
:
SkDashPathEffect
(
const
SkScalar
intervals
[
]
int
count
SkScalar
phase
)
:
fPhase
(
0
)
fInitialDashLength
(
-
1
)
fInitialDashIndex
(
0
)
fIntervalLength
(
0
)
{
SkASSERT
(
intervals
)
;
SkASSERT
(
count
>
1
&
&
SkAlign2
(
count
)
=
=
count
)
;
fIntervals
=
(
SkScalar
*
)
sk_malloc_throw
(
sizeof
(
SkScalar
)
*
count
)
;
fCount
=
count
;
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
fIntervals
[
i
]
=
intervals
[
i
]
;
}
SkDashPath
:
:
CalcDashParameters
(
phase
fIntervals
fCount
&
fInitialDashLength
&
fInitialDashIndex
&
fIntervalLength
&
fPhase
)
;
}
SkDashPathEffect
:
:
~
SkDashPathEffect
(
)
{
sk_free
(
fIntervals
)
;
}
bool
SkDashPathEffect
:
:
filterPath
(
SkPath
*
dst
const
SkPath
&
src
SkStrokeRec
*
rec
const
SkRect
*
cullRect
)
const
{
return
SkDashPath
:
:
InternalFilter
(
dst
src
rec
cullRect
fIntervals
fCount
fInitialDashLength
fInitialDashIndex
fIntervalLength
)
;
}
static
void
outset_for_stroke
(
SkRect
*
rect
const
SkStrokeRec
&
rec
)
{
SkScalar
radius
=
SkScalarHalf
(
rec
.
getWidth
(
)
)
;
if
(
0
=
=
radius
)
{
radius
=
SK_Scalar1
;
}
if
(
SkPaint
:
:
kMiter_Join
=
=
rec
.
getJoin
(
)
)
{
radius
=
SkScalarMul
(
radius
rec
.
getMiter
(
)
)
;
}
rect
-
>
outset
(
radius
radius
)
;
}
static
bool
cull_line
(
SkPoint
*
pts
const
SkStrokeRec
&
rec
const
SkMatrix
&
ctm
const
SkRect
*
cullRect
const
SkScalar
intervalLength
)
{
if
(
nullptr
=
=
cullRect
)
{
SkASSERT
(
false
)
;
return
false
;
}
SkScalar
dx
=
pts
[
1
]
.
x
(
)
-
pts
[
0
]
.
x
(
)
;
SkScalar
dy
=
pts
[
1
]
.
y
(
)
-
pts
[
0
]
.
y
(
)
;
if
(
(
dx
&
&
dy
)
|
|
(
!
dx
&
&
!
dy
)
)
{
return
false
;
}
SkRect
bounds
=
*
cullRect
;
outset_for_stroke
(
&
bounds
rec
)
;
SkASSERT
(
ctm
.
rectStaysRect
(
)
)
;
SkMatrix
inv
;
if
(
!
ctm
.
invert
(
&
inv
)
)
{
return
false
;
}
inv
.
mapRect
(
&
bounds
)
;
if
(
dx
)
{
SkASSERT
(
dx
&
&
!
dy
)
;
SkScalar
minX
=
pts
[
0
]
.
fX
;
SkScalar
maxX
=
pts
[
1
]
.
fX
;
if
(
dx
<
0
)
{
SkTSwap
(
minX
maxX
)
;
}
SkASSERT
(
minX
<
maxX
)
;
if
(
maxX
<
=
bounds
.
fLeft
|
|
minX
>
=
bounds
.
fRight
)
{
return
false
;
}
if
(
minX
<
bounds
.
fLeft
)
{
minX
=
bounds
.
fLeft
-
SkScalarMod
(
bounds
.
fLeft
-
minX
intervalLength
)
;
}
if
(
maxX
>
bounds
.
fRight
)
{
maxX
=
bounds
.
fRight
+
SkScalarMod
(
maxX
-
bounds
.
fRight
intervalLength
)
;
}
SkASSERT
(
maxX
>
minX
)
;
if
(
dx
<
0
)
{
SkTSwap
(
minX
maxX
)
;
}
pts
[
0
]
.
fX
=
minX
;
pts
[
1
]
.
fX
=
maxX
;
}
else
{
SkASSERT
(
dy
&
&
!
dx
)
;
SkScalar
minY
=
pts
[
0
]
.
fY
;
SkScalar
maxY
=
pts
[
1
]
.
fY
;
if
(
dy
<
0
)
{
SkTSwap
(
minY
maxY
)
;
}
SkASSERT
(
minY
<
maxY
)
;
if
(
maxY
<
=
bounds
.
fTop
|
|
minY
>
=
bounds
.
fBottom
)
{
return
false
;
}
if
(
minY
<
bounds
.
fTop
)
{
minY
=
bounds
.
fTop
-
SkScalarMod
(
bounds
.
fTop
-
minY
intervalLength
)
;
}
if
(
maxY
>
bounds
.
fBottom
)
{
maxY
=
bounds
.
fBottom
+
SkScalarMod
(
maxY
-
bounds
.
fBottom
intervalLength
)
;
}
SkASSERT
(
maxY
>
minY
)
;
if
(
dy
<
0
)
{
SkTSwap
(
minY
maxY
)
;
}
pts
[
0
]
.
fY
=
minY
;
pts
[
1
]
.
fY
=
maxY
;
}
return
true
;
}
bool
SkDashPathEffect
:
:
asPoints
(
PointData
*
results
const
SkPath
&
src
const
SkStrokeRec
&
rec
const
SkMatrix
&
matrix
const
SkRect
*
cullRect
)
const
{
if
(
0
>
=
rec
.
getWidth
(
)
)
{
return
false
;
}
if
(
fCount
!
=
2
|
|
!
SkScalarNearlyEqual
(
fIntervals
[
0
]
fIntervals
[
1
]
)
|
|
!
SkScalarIsInt
(
fIntervals
[
0
]
)
|
|
!
SkScalarIsInt
(
fIntervals
[
1
]
)
)
{
return
false
;
}
SkPoint
pts
[
2
]
;
if
(
!
src
.
isLine
(
pts
)
)
{
return
false
;
}
if
(
SkPaint
:
:
kButt_Cap
!
=
rec
.
getCap
(
)
)
{
return
false
;
}
if
(
!
matrix
.
rectStaysRect
(
)
)
{
return
false
;
}
if
(
!
cull_line
(
pts
rec
matrix
cullRect
fIntervalLength
)
)
{
return
false
;
}
SkScalar
length
=
SkPoint
:
:
Distance
(
pts
[
1
]
pts
[
0
]
)
;
SkVector
tangent
=
pts
[
1
]
-
pts
[
0
]
;
if
(
tangent
.
isZero
(
)
)
{
return
false
;
}
tangent
.
scale
(
SkScalarInvert
(
length
)
)
;
bool
isXAxis
=
true
;
if
(
SkScalarNearlyEqual
(
SK_Scalar1
tangent
.
fX
)
|
|
SkScalarNearlyEqual
(
-
SK_Scalar1
tangent
.
fX
)
)
{
results
-
>
fSize
.
set
(
SkScalarHalf
(
fIntervals
[
0
]
)
SkScalarHalf
(
rec
.
getWidth
(
)
)
)
;
}
else
if
(
SkScalarNearlyEqual
(
SK_Scalar1
tangent
.
fY
)
|
|
SkScalarNearlyEqual
(
-
SK_Scalar1
tangent
.
fY
)
)
{
results
-
>
fSize
.
set
(
SkScalarHalf
(
rec
.
getWidth
(
)
)
SkScalarHalf
(
fIntervals
[
0
]
)
)
;
isXAxis
=
false
;
}
else
if
(
SkPaint
:
:
kRound_Cap
!
=
rec
.
getCap
(
)
)
{
return
false
;
}
if
(
results
)
{
results
-
>
fFlags
=
0
;
SkScalar
clampedInitialDashLength
=
SkMinScalar
(
length
fInitialDashLength
)
;
if
(
SkPaint
:
:
kRound_Cap
=
=
rec
.
getCap
(
)
)
{
results
-
>
fFlags
|
=
PointData
:
:
kCircles_PointFlag
;
}
results
-
>
fNumPoints
=
0
;
SkScalar
len2
=
length
;
if
(
clampedInitialDashLength
>
0
|
|
0
=
=
fInitialDashIndex
)
{
SkASSERT
(
len2
>
=
clampedInitialDashLength
)
;
if
(
0
=
=
fInitialDashIndex
)
{
if
(
clampedInitialDashLength
>
0
)
{
if
(
clampedInitialDashLength
>
=
fIntervals
[
0
]
)
{
+
+
results
-
>
fNumPoints
;
}
len2
-
=
clampedInitialDashLength
;
}
len2
-
=
fIntervals
[
1
]
;
if
(
len2
<
0
)
{
len2
=
0
;
}
}
else
{
len2
-
=
clampedInitialDashLength
;
}
}
SkScalar
numIntervals
=
len2
/
fIntervalLength
;
if
(
!
SkScalarIsFinite
(
numIntervals
)
|
|
numIntervals
>
SkDashPath
:
:
kMaxDashCount
)
{
return
false
;
}
int
numMidPoints
=
SkScalarFloorToInt
(
numIntervals
)
;
results
-
>
fNumPoints
+
=
numMidPoints
;
len2
-
=
numMidPoints
*
fIntervalLength
;
bool
partialLast
=
false
;
if
(
len2
>
0
)
{
if
(
len2
<
fIntervals
[
0
]
)
{
partialLast
=
true
;
}
else
{
+
+
numMidPoints
;
+
+
results
-
>
fNumPoints
;
}
}
results
-
>
fPoints
=
new
SkPoint
[
results
-
>
fNumPoints
]
;
SkScalar
distance
=
0
;
int
curPt
=
0
;
if
(
clampedInitialDashLength
>
0
|
|
0
=
=
fInitialDashIndex
)
{
SkASSERT
(
clampedInitialDashLength
<
=
length
)
;
if
(
0
=
=
fInitialDashIndex
)
{
if
(
clampedInitialDashLength
>
0
)
{
SkASSERT
(
SkPaint
:
:
kRound_Cap
!
=
rec
.
getCap
(
)
)
;
SkScalar
x
=
pts
[
0
]
.
fX
+
SkScalarMul
(
tangent
.
fX
SkScalarHalf
(
clampedInitialDashLength
)
)
;
SkScalar
y
=
pts
[
0
]
.
fY
+
SkScalarMul
(
tangent
.
fY
SkScalarHalf
(
clampedInitialDashLength
)
)
;
SkScalar
halfWidth
halfHeight
;
if
(
isXAxis
)
{
halfWidth
=
SkScalarHalf
(
clampedInitialDashLength
)
;
halfHeight
=
SkScalarHalf
(
rec
.
getWidth
(
)
)
;
}
else
{
halfWidth
=
SkScalarHalf
(
rec
.
getWidth
(
)
)
;
halfHeight
=
SkScalarHalf
(
clampedInitialDashLength
)
;
}
if
(
clampedInitialDashLength
<
fIntervals
[
0
]
)
{
results
-
>
fFirst
.
addRect
(
x
-
halfWidth
y
-
halfHeight
x
+
halfWidth
y
+
halfHeight
)
;
}
else
{
SkASSERT
(
curPt
<
results
-
>
fNumPoints
)
;
results
-
>
fPoints
[
curPt
]
.
set
(
x
y
)
;
+
+
curPt
;
}
distance
+
=
clampedInitialDashLength
;
}
distance
+
=
fIntervals
[
1
]
;
}
else
{
distance
+
=
clampedInitialDashLength
;
}
}
if
(
0
!
=
numMidPoints
)
{
distance
+
=
SkScalarHalf
(
fIntervals
[
0
]
)
;
for
(
int
i
=
0
;
i
<
numMidPoints
;
+
+
i
)
{
SkScalar
x
=
pts
[
0
]
.
fX
+
SkScalarMul
(
tangent
.
fX
distance
)
;
SkScalar
y
=
pts
[
0
]
.
fY
+
SkScalarMul
(
tangent
.
fY
distance
)
;
SkASSERT
(
curPt
<
results
-
>
fNumPoints
)
;
results
-
>
fPoints
[
curPt
]
.
set
(
x
y
)
;
+
+
curPt
;
distance
+
=
fIntervalLength
;
}
distance
-
=
SkScalarHalf
(
fIntervals
[
0
]
)
;
}
if
(
partialLast
)
{
SkASSERT
(
SkPaint
:
:
kRound_Cap
!
=
rec
.
getCap
(
)
)
;
SkScalar
temp
=
length
-
distance
;
SkASSERT
(
temp
<
fIntervals
[
0
]
)
;
SkScalar
x
=
pts
[
0
]
.
fX
+
SkScalarMul
(
tangent
.
fX
distance
+
SkScalarHalf
(
temp
)
)
;
SkScalar
y
=
pts
[
0
]
.
fY
+
SkScalarMul
(
tangent
.
fY
distance
+
SkScalarHalf
(
temp
)
)
;
SkScalar
halfWidth
halfHeight
;
if
(
isXAxis
)
{
halfWidth
=
SkScalarHalf
(
temp
)
;
halfHeight
=
SkScalarHalf
(
rec
.
getWidth
(
)
)
;
}
else
{
halfWidth
=
SkScalarHalf
(
rec
.
getWidth
(
)
)
;
halfHeight
=
SkScalarHalf
(
temp
)
;
}
results
-
>
fLast
.
addRect
(
x
-
halfWidth
y
-
halfHeight
x
+
halfWidth
y
+
halfHeight
)
;
}
SkASSERT
(
curPt
=
=
results
-
>
fNumPoints
)
;
}
return
true
;
}
SkPathEffect
:
:
DashType
SkDashPathEffect
:
:
asADash
(
DashInfo
*
info
)
const
{
if
(
info
)
{
if
(
info
-
>
fCount
>
=
fCount
&
&
info
-
>
fIntervals
)
{
memcpy
(
info
-
>
fIntervals
fIntervals
fCount
*
sizeof
(
SkScalar
)
)
;
}
info
-
>
fCount
=
fCount
;
info
-
>
fPhase
=
fPhase
;
}
return
kDash_DashType
;
}
void
SkDashPathEffect
:
:
flatten
(
SkWriteBuffer
&
buffer
)
const
{
buffer
.
writeScalar
(
fPhase
)
;
buffer
.
writeScalarArray
(
fIntervals
fCount
)
;
}
sk_sp
<
SkFlattenable
>
SkDashPathEffect
:
:
CreateProc
(
SkReadBuffer
&
buffer
)
{
const
SkScalar
phase
=
buffer
.
readScalar
(
)
;
uint32_t
count
=
buffer
.
getArrayCount
(
)
;
SkAutoSTArray
<
32
SkScalar
>
intervals
(
count
)
;
if
(
buffer
.
readScalarArray
(
intervals
.
get
(
)
count
)
)
{
return
Make
(
intervals
.
get
(
)
SkToInt
(
count
)
phase
)
;
}
return
nullptr
;
}
#
ifndef
SK_IGNORE_TO_STRING
void
SkDashPathEffect
:
:
toString
(
SkString
*
str
)
const
{
str
-
>
appendf
(
"
SkDashPathEffect
:
(
"
)
;
str
-
>
appendf
(
"
count
:
%
d
phase
%
.
2f
intervals
:
(
"
fCount
fPhase
)
;
for
(
int
i
=
0
;
i
<
fCount
;
+
+
i
)
{
str
-
>
appendf
(
"
%
.
2f
"
fIntervals
[
i
]
)
;
if
(
i
<
fCount
-
1
)
{
str
-
>
appendf
(
"
"
)
;
}
}
str
-
>
appendf
(
"
)
)
"
)
;
}
#
endif
sk_sp
<
SkPathEffect
>
SkDashPathEffect
:
:
Make
(
const
SkScalar
intervals
[
]
int
count
SkScalar
phase
)
{
if
(
!
SkDashPath
:
:
ValidDashPath
(
phase
intervals
count
)
)
{
return
nullptr
;
}
return
sk_sp
<
SkPathEffect
>
(
new
SkDashPathEffect
(
intervals
count
phase
)
)
;
}
