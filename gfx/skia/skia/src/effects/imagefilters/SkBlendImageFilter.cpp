#
include
"
include
/
effects
/
SkImageFilters
.
h
"
#
include
"
include
/
core
/
SkBlendMode
.
h
"
#
include
"
include
/
core
/
SkBlender
.
h
"
#
include
"
include
/
core
/
SkColor
.
h
"
#
include
"
include
/
core
/
SkFlattenable
.
h
"
#
include
"
include
/
core
/
SkImageFilter
.
h
"
#
include
"
include
/
core
/
SkM44
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkShader
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
effects
/
SkBlenders
.
h
"
#
include
"
include
/
private
/
base
/
SkSpan_impl
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
src
/
core
/
SkBlendModePriv
.
h
"
#
include
"
src
/
core
/
SkBlenderBase
.
h
"
#
include
"
src
/
core
/
SkImageFilterTypes
.
h
"
#
include
"
src
/
core
/
SkImageFilter_Base
.
h
"
#
include
"
src
/
core
/
SkPicturePriv
.
h
"
#
include
"
src
/
core
/
SkReadBuffer
.
h
"
#
include
"
src
/
core
/
SkRectPriv
.
h
"
#
include
"
src
/
core
/
SkWriteBuffer
.
h
"
#
include
<
cstdint
>
#
include
<
optional
>
#
include
<
utility
>
namespace
{
class
SkBlendImageFilter
:
public
SkImageFilter_Base
{
static
constexpr
int
kBackground
=
0
;
static
constexpr
int
kForeground
=
1
;
public
:
SkBlendImageFilter
(
sk_sp
<
SkBlender
>
blender
const
std
:
:
optional
<
SkV4
>
&
coefficients
bool
enforcePremul
sk_sp
<
SkImageFilter
>
inputs
[
2
]
)
:
SkImageFilter_Base
(
inputs
2
)
fBlender
(
std
:
:
move
(
blender
)
)
fArithmeticCoefficients
(
coefficients
)
fEnforcePremul
(
enforcePremul
)
{
SkASSERT
(
fBlender
)
;
}
SkRect
computeFastBounds
(
const
SkRect
&
bounds
)
const
override
;
protected
:
void
flatten
(
SkWriteBuffer
&
)
const
override
;
private
:
static
constexpr
uint32_t
kArithmetic_SkBlendMode
=
kCustom_SkBlendMode
+
1
;
friend
void
:
:
SkRegisterBlendImageFilterFlattenable
(
)
;
SK_FLATTENABLE_HOOKS
(
SkBlendImageFilter
)
static
sk_sp
<
SkFlattenable
>
LegacyArithmeticCreateProc
(
SkReadBuffer
&
buffer
)
;
MatrixCapability
onGetCTMCapability
(
)
const
override
{
return
MatrixCapability
:
:
kComplex
;
}
bool
onAffectsTransparentBlack
(
)
const
override
{
return
!
as_BB
(
fBlender
)
-
>
asBlendMode
(
)
.
has_value
(
)
&
&
(
!
fArithmeticCoefficients
.
has_value
(
)
|
|
(
*
fArithmeticCoefficients
)
[
3
]
!
=
0
.
f
)
;
}
skif
:
:
FilterResult
onFilterImage
(
const
skif
:
:
Context
&
)
const
override
;
skif
:
:
LayerSpace
<
SkIRect
>
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
override
;
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
override
;
sk_sp
<
SkShader
>
makeBlendShader
(
sk_sp
<
SkShader
>
bg
sk_sp
<
SkShader
>
fg
)
const
;
sk_sp
<
SkBlender
>
fBlender
;
std
:
:
optional
<
SkV4
>
fArithmeticCoefficients
;
bool
fEnforcePremul
;
}
;
sk_sp
<
SkImageFilter
>
make_blend
(
sk_sp
<
SkBlender
>
blender
sk_sp
<
SkImageFilter
>
background
sk_sp
<
SkImageFilter
>
foreground
const
SkImageFilters
:
:
CropRect
&
cropRect
std
:
:
optional
<
SkV4
>
coefficients
=
{
}
bool
enforcePremul
=
false
)
{
if
(
!
blender
)
{
blender
=
SkBlender
:
:
Mode
(
SkBlendMode
:
:
kSrcOver
)
;
}
auto
cropped
=
[
cropRect
]
(
sk_sp
<
SkImageFilter
>
filter
)
{
if
(
cropRect
)
{
filter
=
SkImageFilters
:
:
Crop
(
*
cropRect
std
:
:
move
(
filter
)
)
;
}
return
filter
;
}
;
if
(
auto
bm
=
as_BB
(
blender
)
-
>
asBlendMode
(
)
)
{
if
(
bm
=
=
SkBlendMode
:
:
kSrc
)
{
return
cropped
(
std
:
:
move
(
foreground
)
)
;
}
else
if
(
bm
=
=
SkBlendMode
:
:
kDst
)
{
return
cropped
(
std
:
:
move
(
background
)
)
;
}
else
if
(
bm
=
=
SkBlendMode
:
:
kClear
)
{
return
SkImageFilters
:
:
Empty
(
)
;
}
}
sk_sp
<
SkImageFilter
>
inputs
[
2
]
=
{
std
:
:
move
(
background
)
std
:
:
move
(
foreground
)
}
;
sk_sp
<
SkImageFilter
>
filter
{
new
SkBlendImageFilter
(
blender
coefficients
enforcePremul
inputs
)
}
;
return
cropped
(
std
:
:
move
(
filter
)
)
;
}
}
sk_sp
<
SkImageFilter
>
SkImageFilters
:
:
Blend
(
SkBlendMode
mode
sk_sp
<
SkImageFilter
>
background
sk_sp
<
SkImageFilter
>
foreground
const
CropRect
&
cropRect
)
{
return
make_blend
(
SkBlender
:
:
Mode
(
mode
)
std
:
:
move
(
background
)
std
:
:
move
(
foreground
)
cropRect
)
;
}
sk_sp
<
SkImageFilter
>
SkImageFilters
:
:
Blend
(
sk_sp
<
SkBlender
>
blender
sk_sp
<
SkImageFilter
>
background
sk_sp
<
SkImageFilter
>
foreground
const
CropRect
&
cropRect
)
{
return
make_blend
(
std
:
:
move
(
blender
)
std
:
:
move
(
background
)
std
:
:
move
(
foreground
)
cropRect
)
;
}
sk_sp
<
SkImageFilter
>
SkImageFilters
:
:
Arithmetic
(
SkScalar
k1
SkScalar
k2
SkScalar
k3
SkScalar
k4
bool
enforcePMColor
sk_sp
<
SkImageFilter
>
background
sk_sp
<
SkImageFilter
>
foreground
const
CropRect
&
cropRect
)
{
auto
blender
=
SkBlenders
:
:
Arithmetic
(
k1
k2
k3
k4
enforcePMColor
)
;
if
(
!
blender
)
{
return
nullptr
;
}
return
make_blend
(
std
:
:
move
(
blender
)
std
:
:
move
(
background
)
std
:
:
move
(
foreground
)
cropRect
SkV4
{
k1
k2
k3
k4
}
enforcePMColor
)
;
}
void
SkRegisterBlendImageFilterFlattenable
(
)
{
SK_REGISTER_FLATTENABLE
(
SkBlendImageFilter
)
;
SkFlattenable
:
:
Register
(
"
SkXfermodeImageFilter_Base
"
SkBlendImageFilter
:
:
CreateProc
)
;
SkFlattenable
:
:
Register
(
"
SkXfermodeImageFilterImpl
"
SkBlendImageFilter
:
:
CreateProc
)
;
SkFlattenable
:
:
Register
(
"
ArithmeticImageFilterImpl
"
SkBlendImageFilter
:
:
LegacyArithmeticCreateProc
)
;
SkFlattenable
:
:
Register
(
"
SkArithmeticImageFilter
"
SkBlendImageFilter
:
:
LegacyArithmeticCreateProc
)
;
}
sk_sp
<
SkFlattenable
>
SkBlendImageFilter
:
:
LegacyArithmeticCreateProc
(
SkReadBuffer
&
buffer
)
{
if
(
!
buffer
.
validate
(
buffer
.
isVersionLT
(
SkPicturePriv
:
:
kCombineBlendArithmeticFilters
)
)
)
{
SkASSERT
(
false
)
;
return
nullptr
;
}
SK_IMAGEFILTER_UNFLATTEN_COMMON
(
common
2
)
;
float
k
[
4
]
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
k
[
i
]
=
buffer
.
readScalar
(
)
;
}
const
bool
enforcePremul
=
buffer
.
readBool
(
)
;
return
SkImageFilters
:
:
Arithmetic
(
k
[
0
]
k
[
1
]
k
[
2
]
k
[
3
]
enforcePremul
common
.
getInput
(
0
)
common
.
getInput
(
1
)
common
.
cropRect
(
)
)
;
}
sk_sp
<
SkFlattenable
>
SkBlendImageFilter
:
:
CreateProc
(
SkReadBuffer
&
buffer
)
{
SK_IMAGEFILTER_UNFLATTEN_COMMON
(
common
2
)
;
sk_sp
<
SkBlender
>
blender
;
std
:
:
optional
<
SkV4
>
coefficients
;
bool
enforcePremul
=
false
;
const
uint32_t
mode
=
buffer
.
read32
(
)
;
if
(
mode
=
=
kArithmetic_SkBlendMode
)
{
if
(
buffer
.
validate
(
!
buffer
.
isVersionLT
(
SkPicturePriv
:
:
kCombineBlendArithmeticFilters
)
)
)
{
SkV4
k
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
k
[
i
]
=
buffer
.
readScalar
(
)
;
}
coefficients
=
k
;
enforcePremul
=
buffer
.
readBool
(
)
;
blender
=
SkBlenders
:
:
Arithmetic
(
k
.
x
k
.
y
k
.
z
k
.
w
enforcePremul
)
;
if
(
!
buffer
.
validate
(
SkToBool
(
blender
)
)
)
{
return
nullptr
;
}
}
}
else
if
(
mode
=
=
kCustom_SkBlendMode
)
{
blender
=
buffer
.
readBlender
(
)
;
}
else
{
if
(
!
buffer
.
validate
(
mode
<
=
(
unsigned
)
SkBlendMode
:
:
kLastMode
)
)
{
return
nullptr
;
}
blender
=
SkBlender
:
:
Mode
(
(
SkBlendMode
)
mode
)
;
}
return
make_blend
(
std
:
:
move
(
blender
)
common
.
getInput
(
kBackground
)
common
.
getInput
(
kForeground
)
common
.
cropRect
(
)
coefficients
enforcePremul
)
;
}
void
SkBlendImageFilter
:
:
flatten
(
SkWriteBuffer
&
buffer
)
const
{
this
-
>
SkImageFilter_Base
:
:
flatten
(
buffer
)
;
if
(
fArithmeticCoefficients
.
has_value
(
)
)
{
buffer
.
write32
(
kArithmetic_SkBlendMode
)
;
const
SkV4
&
k
=
*
fArithmeticCoefficients
;
buffer
.
writeScalar
(
k
[
0
]
)
;
buffer
.
writeScalar
(
k
[
1
]
)
;
buffer
.
writeScalar
(
k
[
2
]
)
;
buffer
.
writeScalar
(
k
[
3
]
)
;
buffer
.
writeBool
(
fEnforcePremul
)
;
}
else
if
(
auto
bm
=
as_BB
(
fBlender
)
-
>
asBlendMode
(
)
)
{
buffer
.
write32
(
(
unsigned
)
bm
.
value
(
)
)
;
}
else
{
buffer
.
write32
(
kCustom_SkBlendMode
)
;
buffer
.
writeFlattenable
(
fBlender
.
get
(
)
)
;
}
}
sk_sp
<
SkShader
>
SkBlendImageFilter
:
:
makeBlendShader
(
sk_sp
<
SkShader
>
bg
sk_sp
<
SkShader
>
fg
)
const
{
if
(
!
bg
|
|
!
fg
)
{
if
(
!
this
-
>
onAffectsTransparentBlack
(
)
&
&
!
bg
&
&
!
fg
)
{
return
nullptr
;
}
if
(
auto
bm
=
as_BB
(
fBlender
)
-
>
asBlendMode
(
)
)
{
SkBlendModeCoeff
src
dst
;
if
(
SkBlendMode_AsCoeff
(
*
bm
&
src
&
dst
)
)
{
if
(
bg
&
&
(
dst
=
=
SkBlendModeCoeff
:
:
kOne
|
|
dst
=
=
SkBlendModeCoeff
:
:
kISA
|
|
dst
=
=
SkBlendModeCoeff
:
:
kISC
)
)
{
return
bg
;
}
if
(
fg
&
&
(
src
=
=
SkBlendModeCoeff
:
:
kOne
|
|
src
=
=
SkBlendModeCoeff
:
:
kIDA
)
)
{
return
fg
;
}
}
}
if
(
!
bg
)
{
bg
=
SkShaders
:
:
Color
(
SK_ColorTRANSPARENT
)
;
}
if
(
!
fg
)
{
fg
=
SkShaders
:
:
Color
(
SK_ColorTRANSPARENT
)
;
}
}
return
SkShaders
:
:
Blend
(
fBlender
std
:
:
move
(
bg
)
std
:
:
move
(
fg
)
)
;
}
skif
:
:
FilterResult
SkBlendImageFilter
:
:
onFilterImage
(
const
skif
:
:
Context
&
ctx
)
const
{
auto
requiredInput
=
this
-
>
onGetOutputLayerBounds
(
ctx
.
mapping
(
)
ctx
.
source
(
)
.
layerBounds
(
)
)
;
if
(
requiredInput
)
{
if
(
!
requiredInput
-
>
intersect
(
ctx
.
desiredOutput
(
)
)
)
{
return
{
}
;
}
}
else
{
requiredInput
=
ctx
.
desiredOutput
(
)
;
}
skif
:
:
Context
inputCtx
=
ctx
.
withNewDesiredOutput
(
*
requiredInput
)
;
skif
:
:
FilterResult
:
:
Builder
builder
{
ctx
}
;
builder
.
add
(
this
-
>
getChildOutput
(
kBackground
inputCtx
)
)
;
builder
.
add
(
this
-
>
getChildOutput
(
kForeground
inputCtx
)
)
;
return
builder
.
eval
(
[
&
]
(
SkSpan
<
sk_sp
<
SkShader
>
>
inputs
)
-
>
sk_sp
<
SkShader
>
{
return
this
-
>
makeBlendShader
(
inputs
[
kBackground
]
inputs
[
kForeground
]
)
;
}
requiredInput
)
;
}
skif
:
:
LayerSpace
<
SkIRect
>
SkBlendImageFilter
:
:
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
{
skif
:
:
LayerSpace
<
SkIRect
>
requiredInput
;
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
maxOutput
;
if
(
contentBounds
&
&
(
maxOutput
=
this
-
>
onGetOutputLayerBounds
(
mapping
*
contentBounds
)
)
)
{
requiredInput
=
*
maxOutput
;
if
(
!
requiredInput
.
intersect
(
desiredOutput
)
)
{
return
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Empty
(
)
;
}
}
else
{
requiredInput
=
desiredOutput
;
}
skif
:
:
LayerSpace
<
SkIRect
>
bgInput
=
this
-
>
getChildInputLayerBounds
(
kBackground
mapping
requiredInput
contentBounds
)
;
skif
:
:
LayerSpace
<
SkIRect
>
fgInput
=
this
-
>
getChildInputLayerBounds
(
kForeground
mapping
requiredInput
contentBounds
)
;
bgInput
.
join
(
fgInput
)
;
return
bgInput
;
}
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
SkBlendImageFilter
:
:
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
{
bool
transparentOutsideFG
=
false
;
bool
transparentOutsideBG
=
false
;
if
(
auto
bm
=
as_BB
(
fBlender
)
-
>
asBlendMode
(
)
)
{
SkASSERT
(
*
bm
!
=
SkBlendMode
:
:
kClear
)
;
SkBlendModeCoeff
src
dst
;
if
(
SkBlendMode_AsCoeff
(
*
bm
&
src
&
dst
)
)
{
transparentOutsideFG
=
dst
=
=
SkBlendModeCoeff
:
:
kZero
|
|
dst
=
=
SkBlendModeCoeff
:
:
kSA
|
|
dst
=
=
SkBlendModeCoeff
:
:
kSC
;
transparentOutsideBG
=
src
=
=
SkBlendModeCoeff
:
:
kZero
|
|
src
=
=
SkBlendModeCoeff
:
:
kDA
;
}
}
else
if
(
fArithmeticCoefficients
.
has_value
(
)
)
{
[
[
maybe_unused
]
]
static
constexpr
SkV4
kClearCoeff
=
{
0
.
f
0
.
f
0
.
f
0
.
f
}
;
const
SkV4
&
k
=
*
fArithmeticCoefficients
;
SkASSERT
(
k
!
=
kClearCoeff
)
;
if
(
k
[
3
]
!
=
0
.
f
)
{
return
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Unbounded
(
)
;
}
else
{
transparentOutsideFG
=
k
[
2
]
=
=
0
.
f
;
transparentOutsideBG
=
k
[
1
]
=
=
0
.
f
;
}
}
else
{
return
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Unbounded
(
)
;
}
auto
foregroundBounds
=
this
-
>
getChildOutputLayerBounds
(
kForeground
mapping
contentBounds
)
;
auto
backgroundBounds
=
this
-
>
getChildOutputLayerBounds
(
kBackground
mapping
contentBounds
)
;
if
(
transparentOutsideFG
)
{
if
(
transparentOutsideBG
)
{
if
(
!
foregroundBounds
&
&
backgroundBounds
)
{
foregroundBounds
=
*
backgroundBounds
;
}
else
if
(
backgroundBounds
&
&
!
foregroundBounds
-
>
intersect
(
*
backgroundBounds
)
)
{
return
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Empty
(
)
;
}
}
return
foregroundBounds
;
}
else
{
if
(
!
transparentOutsideBG
)
{
if
(
foregroundBounds
&
&
backgroundBounds
)
{
backgroundBounds
-
>
join
(
*
foregroundBounds
)
;
}
else
{
backgroundBounds
.
reset
(
)
;
}
}
return
backgroundBounds
;
}
}
SkRect
SkBlendImageFilter
:
:
computeFastBounds
(
const
SkRect
&
bounds
)
const
{
bool
transparentOutsideFG
=
false
;
bool
transparentOutsideBG
=
false
;
if
(
auto
bm
=
as_BB
(
fBlender
)
-
>
asBlendMode
(
)
)
{
SkASSERT
(
*
bm
!
=
SkBlendMode
:
:
kClear
)
;
SkBlendModeCoeff
src
dst
;
if
(
SkBlendMode_AsCoeff
(
*
bm
&
src
&
dst
)
)
{
transparentOutsideFG
=
dst
=
=
SkBlendModeCoeff
:
:
kZero
|
|
dst
=
=
SkBlendModeCoeff
:
:
kSA
;
transparentOutsideBG
=
src
=
=
SkBlendModeCoeff
:
:
kZero
|
|
src
=
=
SkBlendModeCoeff
:
:
kDA
;
}
}
else
if
(
fArithmeticCoefficients
.
has_value
(
)
)
{
[
[
maybe_unused
]
]
static
constexpr
SkV4
kClearCoeff
=
{
0
.
f
0
.
f
0
.
f
0
.
f
}
;
const
SkV4
&
k
=
*
fArithmeticCoefficients
;
SkASSERT
(
k
!
=
kClearCoeff
)
;
if
(
k
[
3
]
!
=
0
.
f
)
{
return
SkRectPriv
:
:
MakeLargeS32
(
)
;
}
else
{
transparentOutsideFG
=
k
[
2
]
=
=
0
.
f
;
transparentOutsideBG
=
k
[
1
]
=
=
0
.
f
;
}
}
else
{
return
SkRectPriv
:
:
MakeLargeS32
(
)
;
}
SkRect
foregroundBounds
=
this
-
>
getInput
(
kForeground
)
?
this
-
>
getInput
(
kForeground
)
-
>
computeFastBounds
(
bounds
)
:
bounds
;
SkRect
backgroundBounds
=
this
-
>
getInput
(
kBackground
)
?
this
-
>
getInput
(
kBackground
)
-
>
computeFastBounds
(
bounds
)
:
bounds
;
if
(
transparentOutsideFG
)
{
if
(
transparentOutsideBG
)
{
if
(
!
foregroundBounds
.
intersect
(
backgroundBounds
)
)
{
return
SkRect
:
:
MakeEmpty
(
)
;
}
}
return
foregroundBounds
;
}
else
{
if
(
!
transparentOutsideBG
)
{
backgroundBounds
.
join
(
foregroundBounds
)
;
}
return
backgroundBounds
;
}
}
