#
include
"
include
/
effects
/
SkMergeImageFilter
.
h
"
#
include
"
include
/
core
/
SkCanvas
.
h
"
#
include
"
src
/
core
/
SkImageFilter_Base
.
h
"
#
include
"
src
/
core
/
SkReadBuffer
.
h
"
#
include
"
src
/
core
/
SkSpecialImage
.
h
"
#
include
"
src
/
core
/
SkSpecialSurface
.
h
"
#
include
"
src
/
core
/
SkValidationUtils
.
h
"
#
include
"
src
/
core
/
SkWriteBuffer
.
h
"
namespace
{
class
SkMergeImageFilterImpl
final
:
public
SkImageFilter_Base
{
public
:
SkMergeImageFilterImpl
(
sk_sp
<
SkImageFilter
>
*
const
filters
int
count
const
CropRect
*
cropRect
)
:
INHERITED
(
filters
count
cropRect
)
{
SkASSERT
(
count
>
=
0
)
;
}
protected
:
sk_sp
<
SkSpecialImage
>
onFilterImage
(
const
Context
&
SkIPoint
*
offset
)
const
override
;
bool
onCanHandleComplexCTM
(
)
const
override
{
return
true
;
}
private
:
friend
void
SkMergeImageFilter
:
:
RegisterFlattenables
(
)
;
SK_FLATTENABLE_HOOKS
(
SkMergeImageFilterImpl
)
typedef
SkImageFilter_Base
INHERITED
;
}
;
}
sk_sp
<
SkImageFilter
>
SkMergeImageFilter
:
:
Make
(
sk_sp
<
SkImageFilter
>
*
const
filters
int
count
const
SkImageFilter
:
:
CropRect
*
cropRect
)
{
return
sk_sp
<
SkImageFilter
>
(
new
SkMergeImageFilterImpl
(
filters
count
cropRect
)
)
;
}
void
SkMergeImageFilter
:
:
RegisterFlattenables
(
)
{
SK_REGISTER_FLATTENABLE
(
SkMergeImageFilterImpl
)
;
SkFlattenable
:
:
Register
(
"
SkMergeImageFilter
"
SkMergeImageFilterImpl
:
:
CreateProc
)
;
}
sk_sp
<
SkFlattenable
>
SkMergeImageFilterImpl
:
:
CreateProc
(
SkReadBuffer
&
buffer
)
{
Common
common
;
if
(
!
common
.
unflatten
(
buffer
-
1
)
|
|
!
buffer
.
isValid
(
)
)
{
return
nullptr
;
}
return
SkMergeImageFilter
:
:
Make
(
common
.
inputs
(
)
common
.
inputCount
(
)
&
common
.
cropRect
(
)
)
;
}
sk_sp
<
SkSpecialImage
>
SkMergeImageFilterImpl
:
:
onFilterImage
(
const
Context
&
ctx
SkIPoint
*
offset
)
const
{
int
inputCount
=
this
-
>
countInputs
(
)
;
if
(
inputCount
<
1
)
{
return
nullptr
;
}
SkIRect
bounds
;
bounds
.
setEmpty
(
)
;
std
:
:
unique_ptr
<
sk_sp
<
SkSpecialImage
>
[
]
>
inputs
(
new
sk_sp
<
SkSpecialImage
>
[
inputCount
]
)
;
std
:
:
unique_ptr
<
SkIPoint
[
]
>
offsets
(
new
SkIPoint
[
inputCount
]
)
;
for
(
int
i
=
0
;
i
<
inputCount
;
+
+
i
)
{
offsets
[
i
]
=
{
0
0
}
;
inputs
[
i
]
=
this
-
>
filterInput
(
i
ctx
&
offsets
[
i
]
)
;
if
(
!
inputs
[
i
]
)
{
continue
;
}
const
SkIRect
inputBounds
=
SkIRect
:
:
MakeXYWH
(
offsets
[
i
]
.
fX
offsets
[
i
]
.
fY
inputs
[
i
]
-
>
width
(
)
inputs
[
i
]
-
>
height
(
)
)
;
bounds
.
join
(
inputBounds
)
;
}
if
(
bounds
.
isEmpty
(
)
)
{
return
nullptr
;
}
bool
embiggen
=
false
;
this
-
>
getCropRect
(
)
.
applyTo
(
bounds
ctx
.
ctm
(
)
embiggen
&
bounds
)
;
if
(
!
bounds
.
intersect
(
ctx
.
clipBounds
(
)
)
)
{
return
nullptr
;
}
const
int
x0
=
bounds
.
left
(
)
;
const
int
y0
=
bounds
.
top
(
)
;
sk_sp
<
SkSpecialSurface
>
surf
(
ctx
.
makeSurface
(
bounds
.
size
(
)
)
)
;
if
(
!
surf
)
{
return
nullptr
;
}
SkCanvas
*
canvas
=
surf
-
>
getCanvas
(
)
;
SkASSERT
(
canvas
)
;
canvas
-
>
clear
(
0x0
)
;
for
(
int
i
=
0
;
i
<
inputCount
;
+
+
i
)
{
if
(
!
inputs
[
i
]
)
{
continue
;
}
inputs
[
i
]
-
>
draw
(
canvas
SkIntToScalar
(
offsets
[
i
]
.
x
(
)
-
x0
)
SkIntToScalar
(
offsets
[
i
]
.
y
(
)
-
y0
)
nullptr
)
;
}
offset
-
>
fX
=
bounds
.
left
(
)
;
offset
-
>
fY
=
bounds
.
top
(
)
;
return
surf
-
>
makeImageSnapshot
(
)
;
}
