#
include
"
include
/
effects
/
SkImageFilters
.
h
"
#
include
"
include
/
core
/
SkColor
.
h
"
#
include
"
include
/
core
/
SkFlattenable
.
h
"
#
include
"
include
/
core
/
SkImageFilter
.
h
"
#
include
"
include
/
core
/
SkM44
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkPoint3
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkShader
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
effects
/
SkRuntimeEffect
.
h
"
#
include
"
include
/
private
/
base
/
SkCPUTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkSpan_impl
.
h
"
#
include
"
src
/
core
/
SkImageFilterTypes
.
h
"
#
include
"
src
/
core
/
SkImageFilter_Base
.
h
"
#
include
"
src
/
core
/
SkKnownRuntimeEffects
.
h
"
#
include
"
src
/
core
/
SkReadBuffer
.
h
"
#
include
"
src
/
core
/
SkRectPriv
.
h
"
#
include
"
src
/
core
/
SkWriteBuffer
.
h
"
#
include
<
optional
>
#
include
<
utility
>
struct
SkISize
;
namespace
{
struct
ZValue
{
ZValue
(
)
:
fZ
(
0
.
f
)
{
}
ZValue
(
float
z
)
:
fZ
(
z
)
{
}
operator
float
(
)
const
{
return
fZ
;
}
float
fZ
;
}
;
}
namespace
skif
{
template
<
>
class
LayerSpace
<
ZValue
>
{
public
:
LayerSpace
(
)
=
default
;
explicit
LayerSpace
(
ZValue
z
)
:
fData
(
z
)
{
}
float
val
(
)
const
{
return
fData
.
fZ
;
}
static
LayerSpace
<
ZValue
>
Map
(
const
Mapping
&
mapping
ParameterSpace
<
ZValue
>
z
)
{
skif
:
:
LayerSpace
<
skif
:
:
Vector
>
z2d
=
mapping
.
paramToLayer
(
skif
:
:
ParameterSpace
<
skif
:
:
Vector
>
(
{
ZValue
(
z
)
ZValue
(
z
)
}
)
)
;
return
LayerSpace
<
ZValue
>
(
SkScalarAve
(
z2d
.
x
(
)
z2d
.
y
(
)
)
)
;
}
private
:
ZValue
fData
;
}
;
}
namespace
{
struct
Light
{
enum
class
Type
{
kDistant
kPoint
kSpot
kLast
=
kSpot
}
;
Type
fType
;
SkColor
fLightColor
;
skif
:
:
ParameterSpace
<
SkPoint
>
fLocationXY
;
skif
:
:
ParameterSpace
<
ZValue
>
fLocationZ
;
skif
:
:
ParameterSpace
<
skif
:
:
Vector
>
fDirectionXY
;
skif
:
:
ParameterSpace
<
ZValue
>
fDirectionZ
;
float
fFalloffExponent
;
float
fCosCutoffAngle
;
static
Light
Point
(
SkColor
color
const
SkPoint3
&
location
)
{
return
{
Type
:
:
kPoint
color
skif
:
:
ParameterSpace
<
SkPoint
>
(
{
location
.
fX
location
.
fY
}
)
skif
:
:
ParameterSpace
<
ZValue
>
(
location
.
fZ
)
{
}
{
}
0
.
f
0
.
f
}
;
}
static
Light
Distant
(
SkColor
color
const
SkPoint3
&
direction
)
{
return
{
Type
:
:
kDistant
color
{
}
{
}
skif
:
:
ParameterSpace
<
skif
:
:
Vector
>
(
{
direction
.
fX
direction
.
fY
}
)
skif
:
:
ParameterSpace
<
ZValue
>
(
direction
.
fZ
)
0
.
f
0
.
f
}
;
}
static
Light
Spot
(
SkColor
color
const
SkPoint3
&
location
const
SkPoint3
&
direction
float
falloffExponent
float
cosCutoffAngle
)
{
return
{
Type
:
:
kSpot
color
skif
:
:
ParameterSpace
<
SkPoint
>
(
{
location
.
fX
location
.
fY
}
)
skif
:
:
ParameterSpace
<
ZValue
>
(
location
.
fZ
)
skif
:
:
ParameterSpace
<
skif
:
:
Vector
>
(
{
direction
.
fX
direction
.
fY
}
)
skif
:
:
ParameterSpace
<
ZValue
>
(
direction
.
fZ
)
falloffExponent
cosCutoffAngle
}
;
}
}
;
struct
Material
{
enum
class
Type
{
kDiffuse
kSpecular
kLast
=
kSpecular
}
;
Type
fType
;
skif
:
:
ParameterSpace
<
ZValue
>
fSurfaceDepth
;
float
fK
;
float
fShininess
;
static
Material
Diffuse
(
float
k
float
surfaceDepth
)
{
return
{
Type
:
:
kDiffuse
skif
:
:
ParameterSpace
<
ZValue
>
(
surfaceDepth
)
k
0
.
f
}
;
}
static
Material
Specular
(
float
k
float
shininess
float
surfaceDepth
)
{
return
{
Type
:
:
kSpecular
skif
:
:
ParameterSpace
<
ZValue
>
(
surfaceDepth
)
k
shininess
}
;
}
}
;
class
SkLightingImageFilter
final
:
public
SkImageFilter_Base
{
public
:
SkLightingImageFilter
(
const
Light
&
light
const
Material
&
material
sk_sp
<
SkImageFilter
>
input
)
:
SkImageFilter_Base
(
&
input
1
)
fLight
(
light
)
fMaterial
(
material
)
{
}
SkRect
computeFastBounds
(
const
SkRect
&
src
)
const
override
;
protected
:
void
flatten
(
SkWriteBuffer
&
)
const
override
;
private
:
friend
void
:
:
SkRegisterLightingImageFilterFlattenables
(
)
;
SK_FLATTENABLE_HOOKS
(
SkLightingImageFilter
)
static
Light
LegacyDeserializeLight
(
SkReadBuffer
&
buffer
)
;
static
sk_sp
<
SkFlattenable
>
LegacyDiffuseCreateProc
(
SkReadBuffer
&
buffer
)
;
static
sk_sp
<
SkFlattenable
>
LegacySpecularCreateProc
(
SkReadBuffer
&
buffer
)
;
bool
onAffectsTransparentBlack
(
)
const
override
{
return
true
;
}
skif
:
:
FilterResult
onFilterImage
(
const
skif
:
:
Context
&
)
const
override
;
skif
:
:
LayerSpace
<
SkIRect
>
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
override
;
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
override
;
skif
:
:
LayerSpace
<
SkIRect
>
requiredInput
(
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
)
const
{
skif
:
:
LayerSpace
<
SkIRect
>
requiredInput
=
desiredOutput
;
requiredInput
.
outset
(
skif
:
:
LayerSpace
<
SkISize
>
(
{
1
1
}
)
)
;
return
requiredInput
;
}
Light
fLight
;
Material
fMaterial
;
}
;
sk_sp
<
SkShader
>
make_normal_shader
(
sk_sp
<
SkShader
>
alphaMap
const
skif
:
:
LayerSpace
<
SkIRect
>
&
edgeBounds
skif
:
:
LayerSpace
<
ZValue
>
surfaceDepth
)
{
const
SkRuntimeEffect
*
normalEffect
=
GetKnownRuntimeEffect
(
SkKnownRuntimeEffects
:
:
StableKey
:
:
kNormal
)
;
SkRuntimeShaderBuilder
builder
(
sk_ref_sp
(
normalEffect
)
)
;
builder
.
child
(
"
alphaMap
"
)
=
std
:
:
move
(
alphaMap
)
;
builder
.
uniform
(
"
edgeBounds
"
)
=
SkRect
:
:
Make
(
SkIRect
(
edgeBounds
)
)
.
makeInset
(
0
.
5f
0
.
5f
)
;
builder
.
uniform
(
"
negSurfaceDepth
"
)
=
-
surfaceDepth
.
val
(
)
;
return
builder
.
makeShader
(
)
;
}
sk_sp
<
SkShader
>
make_lighting_shader
(
sk_sp
<
SkShader
>
normalMap
Light
:
:
Type
lightType
SkColor
lightColor
skif
:
:
LayerSpace
<
SkPoint
>
locationXY
skif
:
:
LayerSpace
<
ZValue
>
locationZ
skif
:
:
LayerSpace
<
skif
:
:
Vector
>
directionXY
skif
:
:
LayerSpace
<
ZValue
>
directionZ
float
falloffExponent
float
cosCutoffAngle
Material
:
:
Type
matType
skif
:
:
LayerSpace
<
ZValue
>
surfaceDepth
float
k
float
shininess
)
{
const
SkRuntimeEffect
*
lightingEffect
=
GetKnownRuntimeEffect
(
SkKnownRuntimeEffects
:
:
StableKey
:
:
kLighting
)
;
SkRuntimeShaderBuilder
builder
(
sk_ref_sp
(
lightingEffect
)
)
;
builder
.
child
(
"
normalMap
"
)
=
std
:
:
move
(
normalMap
)
;
builder
.
uniform
(
"
materialAndLightType
"
)
=
SkV4
{
surfaceDepth
.
val
(
)
shininess
matType
=
=
Material
:
:
Type
:
:
kDiffuse
?
0
.
f
:
1
.
f
lightType
=
=
Light
:
:
Type
:
:
kPoint
?
0
.
f
:
(
lightType
=
=
Light
:
:
Type
:
:
kDistant
?
-
1
.
f
:
1
.
f
)
}
;
builder
.
uniform
(
"
lightPosAndSpotFalloff
"
)
=
SkV4
{
locationXY
.
x
(
)
locationXY
.
y
(
)
locationZ
.
val
(
)
falloffExponent
}
;
SkV3
dir
{
directionXY
.
x
(
)
directionXY
.
y
(
)
directionZ
.
val
(
)
}
;
float
invDirLen
=
dir
.
length
(
)
;
invDirLen
=
invDirLen
?
1
.
0f
/
invDirLen
:
0
.
f
;
builder
.
uniform
(
"
lightDirAndSpotCutoff
"
)
=
SkV4
{
invDirLen
*
dir
.
x
invDirLen
*
dir
.
y
invDirLen
*
dir
.
z
cosCutoffAngle
}
;
const
float
colorScale
=
k
/
255
.
f
;
builder
.
uniform
(
"
lightColor
"
)
=
SkV3
{
SkColorGetR
(
lightColor
)
*
colorScale
SkColorGetG
(
lightColor
)
*
colorScale
SkColorGetB
(
lightColor
)
*
colorScale
}
;
return
builder
.
makeShader
(
)
;
}
sk_sp
<
SkImageFilter
>
make_lighting
(
const
Light
&
light
const
Material
&
material
sk_sp
<
SkImageFilter
>
input
const
SkImageFilters
:
:
CropRect
&
cropRect
)
{
if
(
!
SkScalarIsFinite
(
material
.
fK
)
|
|
material
.
fK
<
0
.
f
|
|
!
SkScalarIsFinite
(
material
.
fShininess
)
|
|
!
SkScalarIsFinite
(
ZValue
(
material
.
fSurfaceDepth
)
)
)
{
return
nullptr
;
}
if
(
!
SkPoint
(
light
.
fLocationXY
)
.
isFinite
(
)
|
|
!
SkScalarIsFinite
(
ZValue
(
light
.
fLocationZ
)
)
|
|
!
skif
:
:
Vector
(
light
.
fDirectionXY
)
.
isFinite
(
)
|
|
!
SkScalarIsFinite
(
ZValue
(
light
.
fDirectionZ
)
)
|
|
!
SkScalarIsFinite
(
light
.
fFalloffExponent
)
|
|
!
SkScalarIsFinite
(
light
.
fCosCutoffAngle
)
|
|
light
.
fCosCutoffAngle
<
-
1
.
f
|
|
light
.
fCosCutoffAngle
>
1
.
f
)
{
return
nullptr
;
}
sk_sp
<
SkImageFilter
>
filter
=
std
:
:
move
(
input
)
;
if
(
cropRect
)
{
filter
=
SkImageFilters
:
:
Crop
(
*
cropRect
std
:
:
move
(
filter
)
)
;
}
filter
=
sk_sp
<
SkImageFilter
>
(
new
SkLightingImageFilter
(
light
material
std
:
:
move
(
filter
)
)
)
;
if
(
cropRect
)
{
filter
=
SkImageFilters
:
:
Crop
(
*
cropRect
std
:
:
move
(
filter
)
)
;
}
return
filter
;
}
}
sk_sp
<
SkImageFilter
>
SkImageFilters
:
:
DistantLitDiffuse
(
const
SkPoint3
&
direction
SkColor
lightColor
SkScalar
surfaceScale
SkScalar
kd
sk_sp
<
SkImageFilter
>
input
const
CropRect
&
cropRect
)
{
return
make_lighting
(
Light
:
:
Distant
(
lightColor
direction
)
Material
:
:
Diffuse
(
kd
surfaceScale
)
std
:
:
move
(
input
)
cropRect
)
;
}
sk_sp
<
SkImageFilter
>
SkImageFilters
:
:
PointLitDiffuse
(
const
SkPoint3
&
location
SkColor
lightColor
SkScalar
surfaceScale
SkScalar
kd
sk_sp
<
SkImageFilter
>
input
const
CropRect
&
cropRect
)
{
return
make_lighting
(
Light
:
:
Point
(
lightColor
location
)
Material
:
:
Diffuse
(
kd
surfaceScale
)
std
:
:
move
(
input
)
cropRect
)
;
}
sk_sp
<
SkImageFilter
>
SkImageFilters
:
:
SpotLitDiffuse
(
const
SkPoint3
&
location
const
SkPoint3
&
target
SkScalar
falloffExponent
SkScalar
cutoffAngle
SkColor
lightColor
SkScalar
surfaceScale
SkScalar
kd
sk_sp
<
SkImageFilter
>
input
const
CropRect
&
cropRect
)
{
SkPoint3
dir
=
target
-
location
;
float
cosCutoffAngle
=
SkScalarCos
(
SkDegreesToRadians
(
cutoffAngle
)
)
;
return
make_lighting
(
Light
:
:
Spot
(
lightColor
location
dir
falloffExponent
cosCutoffAngle
)
Material
:
:
Diffuse
(
kd
surfaceScale
)
std
:
:
move
(
input
)
cropRect
)
;
}
sk_sp
<
SkImageFilter
>
SkImageFilters
:
:
DistantLitSpecular
(
const
SkPoint3
&
direction
SkColor
lightColor
SkScalar
surfaceScale
SkScalar
ks
SkScalar
shininess
sk_sp
<
SkImageFilter
>
input
const
CropRect
&
cropRect
)
{
return
make_lighting
(
Light
:
:
Distant
(
lightColor
direction
)
Material
:
:
Specular
(
ks
shininess
surfaceScale
)
std
:
:
move
(
input
)
cropRect
)
;
}
sk_sp
<
SkImageFilter
>
SkImageFilters
:
:
PointLitSpecular
(
const
SkPoint3
&
location
SkColor
lightColor
SkScalar
surfaceScale
SkScalar
ks
SkScalar
shininess
sk_sp
<
SkImageFilter
>
input
const
CropRect
&
cropRect
)
{
return
make_lighting
(
Light
:
:
Point
(
lightColor
location
)
Material
:
:
Specular
(
ks
shininess
surfaceScale
)
std
:
:
move
(
input
)
cropRect
)
;
}
sk_sp
<
SkImageFilter
>
SkImageFilters
:
:
SpotLitSpecular
(
const
SkPoint3
&
location
const
SkPoint3
&
target
SkScalar
falloffExponent
SkScalar
cutoffAngle
SkColor
lightColor
SkScalar
surfaceScale
SkScalar
ks
SkScalar
shininess
sk_sp
<
SkImageFilter
>
input
const
CropRect
&
cropRect
)
{
SkPoint3
dir
=
target
-
location
;
float
cosCutoffAngle
=
SkScalarCos
(
SkDegreesToRadians
(
cutoffAngle
)
)
;
return
make_lighting
(
Light
:
:
Spot
(
lightColor
location
dir
falloffExponent
cosCutoffAngle
)
Material
:
:
Specular
(
ks
shininess
surfaceScale
)
std
:
:
move
(
input
)
cropRect
)
;
}
void
SkRegisterLightingImageFilterFlattenables
(
)
{
SK_REGISTER_FLATTENABLE
(
SkLightingImageFilter
)
;
SkFlattenable
:
:
Register
(
"
SkDiffuseLightingImageFilter
"
SkLightingImageFilter
:
:
LegacyDiffuseCreateProc
)
;
SkFlattenable
:
:
Register
(
"
SkSpecularLightingImageFilter
"
SkLightingImageFilter
:
:
LegacySpecularCreateProc
)
;
}
sk_sp
<
SkFlattenable
>
SkLightingImageFilter
:
:
CreateProc
(
SkReadBuffer
&
buffer
)
{
SK_IMAGEFILTER_UNFLATTEN_COMMON
(
common
1
)
;
Light
light
;
light
.
fType
=
buffer
.
read32LE
(
Light
:
:
Type
:
:
kLast
)
;
light
.
fLightColor
=
buffer
.
readColor
(
)
;
SkPoint3
lightPos
lightDir
;
buffer
.
readPoint3
(
&
lightPos
)
;
light
.
fLocationXY
=
skif
:
:
ParameterSpace
<
SkPoint
>
(
{
lightPos
.
fX
lightPos
.
fY
}
)
;
light
.
fLocationZ
=
skif
:
:
ParameterSpace
<
ZValue
>
(
lightPos
.
fZ
)
;
buffer
.
readPoint3
(
&
lightDir
)
;
light
.
fDirectionXY
=
skif
:
:
ParameterSpace
<
skif
:
:
Vector
>
(
{
lightDir
.
fX
lightDir
.
fY
}
)
;
light
.
fDirectionZ
=
skif
:
:
ParameterSpace
<
ZValue
>
(
lightDir
.
fZ
)
;
light
.
fFalloffExponent
=
buffer
.
readScalar
(
)
;
light
.
fCosCutoffAngle
=
buffer
.
readScalar
(
)
;
Material
material
;
material
.
fType
=
buffer
.
read32LE
(
Material
:
:
Type
:
:
kLast
)
;
material
.
fSurfaceDepth
=
skif
:
:
ParameterSpace
<
ZValue
>
(
buffer
.
readScalar
(
)
)
;
material
.
fK
=
buffer
.
readScalar
(
)
;
material
.
fShininess
=
buffer
.
readScalar
(
)
;
if
(
!
buffer
.
isValid
(
)
)
{
return
nullptr
;
}
return
make_lighting
(
light
material
common
.
getInput
(
0
)
common
.
cropRect
(
)
)
;
}
Light
SkLightingImageFilter
:
:
LegacyDeserializeLight
(
SkReadBuffer
&
buffer
)
{
Light
:
:
Type
lightType
=
buffer
.
read32LE
(
Light
:
:
Type
:
:
kLast
)
;
if
(
!
buffer
.
isValid
(
)
)
{
return
{
}
;
}
SkColor
lightColor
=
SkColorSetARGB
(
255
(
U8CPU
)
buffer
.
readScalar
(
)
(
U8CPU
)
buffer
.
readScalar
(
)
(
U8CPU
)
buffer
.
readScalar
(
)
)
;
switch
(
lightType
)
{
case
Light
:
:
Type
:
:
kDistant
:
{
SkPoint3
dir
=
{
buffer
.
readScalar
(
)
buffer
.
readScalar
(
)
buffer
.
readScalar
(
)
}
;
return
Light
:
:
Distant
(
lightColor
dir
)
;
}
case
Light
:
:
Type
:
:
kPoint
:
{
SkPoint3
loc
=
{
buffer
.
readScalar
(
)
buffer
.
readScalar
(
)
buffer
.
readScalar
(
)
}
;
return
Light
:
:
Point
(
lightColor
loc
)
;
}
case
Light
:
:
Type
:
:
kSpot
:
{
SkPoint3
loc
=
{
buffer
.
readScalar
(
)
buffer
.
readScalar
(
)
buffer
.
readScalar
(
)
}
;
SkPoint3
target
=
{
buffer
.
readScalar
(
)
buffer
.
readScalar
(
)
buffer
.
readScalar
(
)
}
;
float
falloffExponent
=
buffer
.
readScalar
(
)
;
float
cosOuterConeAngle
=
buffer
.
readScalar
(
)
;
buffer
.
readScalar
(
)
;
buffer
.
readScalar
(
)
;
buffer
.
readScalar
(
)
;
buffer
.
readScalar
(
)
;
buffer
.
readScalar
(
)
;
return
Light
:
:
Spot
(
lightColor
loc
target
-
loc
falloffExponent
cosOuterConeAngle
)
;
}
}
SkUNREACHABLE
;
}
sk_sp
<
SkFlattenable
>
SkLightingImageFilter
:
:
LegacyDiffuseCreateProc
(
SkReadBuffer
&
buffer
)
{
SK_IMAGEFILTER_UNFLATTEN_COMMON
(
common
1
)
;
Light
light
=
LegacyDeserializeLight
(
buffer
)
;
float
surfaceScale
=
buffer
.
readScalar
(
)
;
float
kd
=
buffer
.
readScalar
(
)
;
Material
material
=
Material
:
:
Diffuse
(
kd
surfaceScale
)
;
return
make_lighting
(
light
material
common
.
getInput
(
0
)
common
.
cropRect
(
)
)
;
}
sk_sp
<
SkFlattenable
>
SkLightingImageFilter
:
:
LegacySpecularCreateProc
(
SkReadBuffer
&
buffer
)
{
SK_IMAGEFILTER_UNFLATTEN_COMMON
(
common
1
)
;
Light
light
=
LegacyDeserializeLight
(
buffer
)
;
float
surfaceScale
=
buffer
.
readScalar
(
)
;
float
ks
=
buffer
.
readScalar
(
)
;
float
shininess
=
buffer
.
readScalar
(
)
;
Material
material
=
Material
:
:
Specular
(
ks
shininess
surfaceScale
)
;
return
make_lighting
(
light
material
common
.
getInput
(
0
)
common
.
cropRect
(
)
)
;
}
void
SkLightingImageFilter
:
:
flatten
(
SkWriteBuffer
&
buffer
)
const
{
this
-
>
SkImageFilter_Base
:
:
flatten
(
buffer
)
;
buffer
.
writeInt
(
(
int
)
fLight
.
fType
)
;
buffer
.
writeColor
(
fLight
.
fLightColor
)
;
buffer
.
writePoint
(
SkPoint
(
fLight
.
fLocationXY
)
)
;
buffer
.
writeScalar
(
ZValue
(
fLight
.
fLocationZ
)
)
;
skif
:
:
Vector
dirXY
{
fLight
.
fDirectionXY
}
;
buffer
.
writePoint
(
SkPoint
{
dirXY
.
fX
dirXY
.
fY
}
)
;
buffer
.
writeScalar
(
ZValue
(
fLight
.
fDirectionZ
)
)
;
buffer
.
writeScalar
(
fLight
.
fFalloffExponent
)
;
buffer
.
writeScalar
(
fLight
.
fCosCutoffAngle
)
;
buffer
.
writeInt
(
(
int
)
fMaterial
.
fType
)
;
buffer
.
writeScalar
(
ZValue
(
fMaterial
.
fSurfaceDepth
)
)
;
buffer
.
writeScalar
(
fMaterial
.
fK
)
;
buffer
.
writeScalar
(
fMaterial
.
fShininess
)
;
}
skif
:
:
FilterResult
SkLightingImageFilter
:
:
onFilterImage
(
const
skif
:
:
Context
&
ctx
)
const
{
using
ShaderFlags
=
skif
:
:
FilterResult
:
:
ShaderFlags
;
auto
mapZToLayer
=
[
&
ctx
]
(
skif
:
:
ParameterSpace
<
ZValue
>
z
)
{
return
skif
:
:
LayerSpace
<
ZValue
>
:
:
Map
(
ctx
.
mapping
(
)
z
)
;
}
;
skif
:
:
LayerSpace
<
ZValue
>
surfaceDepth
=
mapZToLayer
(
fMaterial
.
fSurfaceDepth
)
;
skif
:
:
LayerSpace
<
SkPoint
>
lightLocationXY
=
ctx
.
mapping
(
)
.
paramToLayer
(
fLight
.
fLocationXY
)
;
skif
:
:
LayerSpace
<
ZValue
>
lightLocationZ
=
mapZToLayer
(
fLight
.
fLocationZ
)
;
skif
:
:
LayerSpace
<
skif
:
:
Vector
>
lightDirXY
=
ctx
.
mapping
(
)
.
paramToLayer
(
fLight
.
fDirectionXY
)
;
skif
:
:
LayerSpace
<
ZValue
>
lightDirZ
=
mapZToLayer
(
fLight
.
fDirectionZ
)
;
skif
:
:
LayerSpace
<
SkIRect
>
requiredInput
=
this
-
>
requiredInput
(
ctx
.
desiredOutput
(
)
)
;
skif
:
:
FilterResult
childOutput
=
this
-
>
getChildOutput
(
0
ctx
.
withNewDesiredOutput
(
requiredInput
)
)
;
skif
:
:
LayerSpace
<
SkIRect
>
clampRect
=
requiredInput
;
if
(
!
childOutput
.
layerBounds
(
)
.
contains
(
requiredInput
)
)
{
auto
edgeClamp
=
[
]
(
int
actualEdgeValue
int
requestedEdgeValue
int
outputEdge
)
{
return
actualEdgeValue
=
=
outputEdge
?
outputEdge
:
requestedEdgeValue
;
}
;
auto
inputRect
=
childOutput
.
layerBounds
(
)
;
auto
clampTo
=
ctx
.
desiredOutput
(
)
;
clampRect
=
skif
:
:
LayerSpace
<
SkIRect
>
(
{
edgeClamp
(
inputRect
.
left
(
)
requiredInput
.
left
(
)
clampTo
.
left
(
)
)
edgeClamp
(
inputRect
.
top
(
)
requiredInput
.
top
(
)
clampTo
.
top
(
)
)
edgeClamp
(
inputRect
.
right
(
)
requiredInput
.
right
(
)
clampTo
.
right
(
)
)
edgeClamp
(
inputRect
.
bottom
(
)
requiredInput
.
bottom
(
)
clampTo
.
bottom
(
)
)
}
)
;
}
skif
:
:
FilterResult
:
:
Builder
builder
{
ctx
}
;
builder
.
add
(
childOutput
clampRect
ShaderFlags
:
:
kSampledRepeatedly
)
;
return
builder
.
eval
(
[
&
]
(
SkSpan
<
sk_sp
<
SkShader
>
>
input
)
{
sk_sp
<
SkShader
>
normals
=
make_normal_shader
(
std
:
:
move
(
input
[
0
]
)
clampRect
surfaceDepth
)
;
return
make_lighting_shader
(
std
:
:
move
(
normals
)
fLight
.
fType
fLight
.
fLightColor
lightLocationXY
lightLocationZ
lightDirXY
lightDirZ
fLight
.
fFalloffExponent
fLight
.
fCosCutoffAngle
fMaterial
.
fType
surfaceDepth
fMaterial
.
fK
fMaterial
.
fShininess
)
;
}
)
;
}
skif
:
:
LayerSpace
<
SkIRect
>
SkLightingImageFilter
:
:
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
{
skif
:
:
LayerSpace
<
SkIRect
>
requiredInput
=
this
-
>
requiredInput
(
desiredOutput
)
;
return
this
-
>
getChildInputLayerBounds
(
0
mapping
requiredInput
contentBounds
)
;
}
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
SkLightingImageFilter
:
:
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
{
return
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Unbounded
(
)
;
}
SkRect
SkLightingImageFilter
:
:
computeFastBounds
(
const
SkRect
&
src
)
const
{
return
SkRectPriv
:
:
MakeLargeS32
(
)
;
}
