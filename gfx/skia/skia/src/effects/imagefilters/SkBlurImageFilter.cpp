#
include
"
include
/
effects
/
SkImageFilters
.
h
"
#
include
"
include
/
core
/
SkBitmap
.
h
"
#
include
"
include
/
core
/
SkColor
.
h
"
#
include
"
include
/
core
/
SkColorType
.
h
"
#
include
"
include
/
core
/
SkFlattenable
.
h
"
#
include
"
include
/
core
/
SkImageFilter
.
h
"
#
include
"
include
/
core
/
SkImageInfo
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkSize
.
h
"
#
include
"
include
/
core
/
SkTileMode
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkFloatingPoint
.
h
"
#
include
"
include
/
private
/
base
/
SkMalloc
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
src
/
base
/
SkArenaAlloc
.
h
"
#
include
"
src
/
base
/
SkVx
.
h
"
#
include
"
src
/
core
/
SkImageFilterTypes
.
h
"
#
include
"
src
/
core
/
SkImageFilter_Base
.
h
"
#
include
"
src
/
core
/
SkReadBuffer
.
h
"
#
include
"
src
/
core
/
SkSpecialImage
.
h
"
#
include
"
src
/
core
/
SkWriteBuffer
.
h
"
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
optional
>
#
include
<
utility
>
struct
SkIPoint
;
#
if
defined
(
SK_GANESH
)
|
|
defined
(
SK_GRAPHITE
)
#
include
"
src
/
gpu
/
BlurUtils
.
h
"
#
endif
#
if
SK_CPU_SSE_LEVEL
>
=
SK_CPU_SSE_LEVEL_SSE1
#
include
<
xmmintrin
.
h
>
#
define
SK_PREFETCH
(
ptr
)
_mm_prefetch
(
reinterpret_cast
<
const
char
*
>
(
ptr
)
_MM_HINT_T0
)
#
elif
defined
(
__GNUC__
)
#
define
SK_PREFETCH
(
ptr
)
__builtin_prefetch
(
ptr
)
#
else
#
define
SK_PREFETCH
(
ptr
)
#
endif
namespace
{
class
SkBlurImageFilter
final
:
public
SkImageFilter_Base
{
public
:
SkBlurImageFilter
(
SkSize
sigma
sk_sp
<
SkImageFilter
>
input
)
:
SkImageFilter_Base
(
&
input
1
)
fSigma
{
sigma
}
{
}
SkBlurImageFilter
(
SkSize
sigma
SkTileMode
legacyTileMode
sk_sp
<
SkImageFilter
>
input
)
:
SkImageFilter_Base
(
&
input
1
)
fSigma
(
sigma
)
fLegacyTileMode
(
legacyTileMode
)
{
}
SkRect
computeFastBounds
(
const
SkRect
&
)
const
override
;
protected
:
void
flatten
(
SkWriteBuffer
&
)
const
override
;
private
:
friend
void
:
:
SkRegisterBlurImageFilterFlattenable
(
)
;
SK_FLATTENABLE_HOOKS
(
SkBlurImageFilter
)
skif
:
:
FilterResult
onFilterImage
(
const
skif
:
:
Context
&
context
)
const
override
;
skif
:
:
LayerSpace
<
SkIRect
>
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
override
;
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
override
;
skif
:
:
LayerSpace
<
SkSize
>
mapSigma
(
const
skif
:
:
Mapping
&
mapping
bool
gpuBacked
)
const
;
skif
:
:
LayerSpace
<
SkIRect
>
kernelBounds
(
const
skif
:
:
Mapping
&
mapping
skif
:
:
LayerSpace
<
SkIRect
>
bounds
bool
gpuBacked
)
const
{
skif
:
:
LayerSpace
<
SkSize
>
sigma
=
this
-
>
mapSigma
(
mapping
gpuBacked
)
;
bounds
.
outset
(
skif
:
:
LayerSpace
<
SkSize
>
(
{
3
*
sigma
.
width
(
)
3
*
sigma
.
height
(
)
}
)
.
ceil
(
)
)
;
return
bounds
;
}
skif
:
:
ParameterSpace
<
SkSize
>
fSigma
;
SkTileMode
fLegacyTileMode
=
SkTileMode
:
:
kDecal
;
}
;
}
sk_sp
<
SkImageFilter
>
SkImageFilters
:
:
Blur
(
SkScalar
sigmaX
SkScalar
sigmaY
SkTileMode
tileMode
sk_sp
<
SkImageFilter
>
input
const
CropRect
&
cropRect
)
{
if
(
!
SkScalarsAreFinite
(
sigmaX
sigmaY
)
|
|
sigmaX
<
0
.
f
|
|
sigmaY
<
0
.
f
)
{
return
nullptr
;
}
if
(
tileMode
!
=
SkTileMode
:
:
kDecal
&
&
!
cropRect
)
{
return
sk_make_sp
<
SkBlurImageFilter
>
(
SkSize
{
sigmaX
sigmaY
}
tileMode
std
:
:
move
(
input
)
)
;
}
sk_sp
<
SkImageFilter
>
filter
=
std
:
:
move
(
input
)
;
if
(
tileMode
!
=
SkTileMode
:
:
kDecal
&
&
cropRect
)
{
filter
=
SkImageFilters
:
:
Crop
(
*
cropRect
tileMode
std
:
:
move
(
filter
)
)
;
}
filter
=
sk_make_sp
<
SkBlurImageFilter
>
(
SkSize
{
sigmaX
sigmaY
}
std
:
:
move
(
filter
)
)
;
if
(
cropRect
)
{
filter
=
SkImageFilters
:
:
Crop
(
*
cropRect
SkTileMode
:
:
kDecal
std
:
:
move
(
filter
)
)
;
}
return
filter
;
}
void
SkRegisterBlurImageFilterFlattenable
(
)
{
SK_REGISTER_FLATTENABLE
(
SkBlurImageFilter
)
;
SkFlattenable
:
:
Register
(
"
SkBlurImageFilterImpl
"
SkBlurImageFilter
:
:
CreateProc
)
;
}
sk_sp
<
SkFlattenable
>
SkBlurImageFilter
:
:
CreateProc
(
SkReadBuffer
&
buffer
)
{
SK_IMAGEFILTER_UNFLATTEN_COMMON
(
common
1
)
;
SkScalar
sigmaX
=
buffer
.
readScalar
(
)
;
SkScalar
sigmaY
=
buffer
.
readScalar
(
)
;
SkTileMode
tileMode
=
buffer
.
read32LE
(
SkTileMode
:
:
kLastTileMode
)
;
return
SkImageFilters
:
:
Blur
(
sigmaX
sigmaY
tileMode
common
.
getInput
(
0
)
common
.
cropRect
(
)
)
;
}
void
SkBlurImageFilter
:
:
flatten
(
SkWriteBuffer
&
buffer
)
const
{
this
-
>
SkImageFilter_Base
:
:
flatten
(
buffer
)
;
buffer
.
writeScalar
(
SkSize
(
fSigma
)
.
fWidth
)
;
buffer
.
writeScalar
(
SkSize
(
fSigma
)
.
fHeight
)
;
buffer
.
writeInt
(
static_cast
<
int
>
(
fLegacyTileMode
)
)
;
}
namespace
{
int
calculate_window
(
double
sigma
)
{
auto
possibleWindow
=
static_cast
<
int
>
(
floor
(
sigma
*
3
*
sqrt
(
2
*
SK_DoublePI
)
/
4
+
0
.
5
)
)
;
return
std
:
:
max
(
1
possibleWindow
)
;
}
static
constexpr
SkScalar
kMaxSigma
=
532
.
f
;
class
Pass
{
public
:
explicit
Pass
(
int
border
)
:
fBorder
(
border
)
{
}
virtual
~
Pass
(
)
=
default
;
void
blur
(
int
srcLeft
int
srcRight
int
dstRight
const
uint32_t
*
src
int
srcStride
uint32_t
*
dst
int
dstStride
)
{
this
-
>
startBlur
(
)
;
auto
srcStart
=
srcLeft
-
fBorder
srcEnd
=
srcRight
-
fBorder
dstEnd
=
dstRight
srcIdx
=
srcStart
dstIdx
=
0
;
const
uint32_t
*
srcCursor
=
src
;
uint32_t
*
dstCursor
=
dst
;
if
(
dstIdx
<
srcIdx
)
{
int
commonEnd
=
std
:
:
min
(
srcIdx
dstEnd
)
;
while
(
dstIdx
<
commonEnd
)
{
*
dstCursor
=
0
;
dstCursor
+
=
dstStride
;
SK_PREFETCH
(
dstCursor
)
;
dstIdx
+
+
;
}
}
else
if
(
srcIdx
<
dstIdx
)
{
if
(
int
commonEnd
=
std
:
:
min
(
dstIdx
srcEnd
)
;
srcIdx
<
commonEnd
)
{
int
n
=
commonEnd
-
srcIdx
;
this
-
>
blurSegment
(
n
srcCursor
srcStride
nullptr
0
)
;
srcIdx
+
=
n
;
srcCursor
+
=
n
*
srcStride
;
}
if
(
srcIdx
<
dstIdx
)
{
int
n
=
dstIdx
-
srcIdx
;
this
-
>
blurSegment
(
n
nullptr
0
nullptr
0
)
;
srcIdx
+
=
n
;
}
}
if
(
int
commonEnd
=
std
:
:
min
(
dstEnd
srcEnd
)
;
dstIdx
<
commonEnd
)
{
SkASSERT
(
srcIdx
=
=
dstIdx
)
;
int
n
=
commonEnd
-
dstIdx
;
this
-
>
blurSegment
(
n
srcCursor
srcStride
dstCursor
dstStride
)
;
srcCursor
+
=
n
*
srcStride
;
dstCursor
+
=
n
*
dstStride
;
dstIdx
+
=
n
;
srcIdx
+
=
n
;
}
if
(
dstIdx
<
dstEnd
)
{
int
n
=
dstEnd
-
dstIdx
;
this
-
>
blurSegment
(
n
nullptr
0
dstCursor
dstStride
)
;
}
}
protected
:
virtual
void
startBlur
(
)
=
0
;
virtual
void
blurSegment
(
int
n
const
uint32_t
*
src
int
srcStride
uint32_t
*
dst
int
dstStride
)
=
0
;
private
:
const
int
fBorder
;
}
;
class
PassMaker
{
public
:
explicit
PassMaker
(
int
window
)
:
fWindow
{
window
}
{
}
virtual
~
PassMaker
(
)
=
default
;
virtual
Pass
*
makePass
(
void
*
buffer
SkArenaAlloc
*
alloc
)
const
=
0
;
virtual
size_t
bufferSizeBytes
(
)
const
=
0
;
int
window
(
)
const
{
return
fWindow
;
}
private
:
const
int
fWindow
;
}
;
class
GaussPass
final
:
public
Pass
{
public
:
static
PassMaker
*
MakeMaker
(
double
sigma
SkArenaAlloc
*
alloc
)
{
SkASSERT
(
0
<
=
sigma
)
;
int
window
=
calculate_window
(
sigma
)
;
if
(
255
<
=
window
)
{
return
nullptr
;
}
class
Maker
:
public
PassMaker
{
public
:
explicit
Maker
(
int
window
)
:
PassMaker
{
window
}
{
}
Pass
*
makePass
(
void
*
buffer
SkArenaAlloc
*
alloc
)
const
override
{
return
GaussPass
:
:
Make
(
this
-
>
window
(
)
buffer
alloc
)
;
}
size_t
bufferSizeBytes
(
)
const
override
{
int
window
=
this
-
>
window
(
)
;
size_t
onePassSize
=
window
-
1
;
size_t
bufferCount
=
(
window
&
1
)
=
=
1
?
3
*
onePassSize
:
3
*
onePassSize
+
1
;
return
bufferCount
*
sizeof
(
skvx
:
:
Vec
<
4
uint32_t
>
)
;
}
}
;
return
alloc
-
>
make
<
Maker
>
(
window
)
;
}
static
GaussPass
*
Make
(
int
window
void
*
buffers
SkArenaAlloc
*
alloc
)
{
int
passSize
=
window
-
1
;
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer0
=
static_cast
<
skvx
:
:
Vec
<
4
uint32_t
>
*
>
(
buffers
)
;
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer1
=
buffer0
+
passSize
;
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer2
=
buffer1
+
passSize
;
skvx
:
:
Vec
<
4
uint32_t
>
*
buffersEnd
=
buffer2
+
(
(
window
&
1
)
?
passSize
:
passSize
+
1
)
;
int
border
=
(
window
&
1
)
=
=
1
?
3
*
(
(
window
-
1
)
/
2
)
:
3
*
(
window
/
2
)
-
1
;
int
window2
=
window
*
window
;
int
window3
=
window2
*
window
;
int
divisor
=
(
window
&
1
)
=
=
1
?
window3
:
window3
+
window2
;
return
alloc
-
>
make
<
GaussPass
>
(
buffer0
buffer1
buffer2
buffersEnd
border
divisor
)
;
}
GaussPass
(
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer0
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer1
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer2
skvx
:
:
Vec
<
4
uint32_t
>
*
buffersEnd
int
border
int
divisor
)
:
Pass
{
border
}
fBuffer0
{
buffer0
}
fBuffer1
{
buffer1
}
fBuffer2
{
buffer2
}
fBuffersEnd
{
buffersEnd
}
fDivider
(
divisor
)
{
}
private
:
void
startBlur
(
)
override
{
skvx
:
:
Vec
<
4
uint32_t
>
zero
=
{
0u
0u
0u
0u
}
;
zero
.
store
(
fSum0
)
;
zero
.
store
(
fSum1
)
;
auto
half
=
fDivider
.
half
(
)
;
skvx
:
:
Vec
<
4
uint32_t
>
{
half
half
half
half
}
.
store
(
fSum2
)
;
sk_bzero
(
fBuffer0
(
fBuffersEnd
-
fBuffer0
)
*
sizeof
(
skvx
:
:
Vec
<
4
uint32_t
>
)
)
;
fBuffer0Cursor
=
fBuffer0
;
fBuffer1Cursor
=
fBuffer1
;
fBuffer2Cursor
=
fBuffer2
;
}
void
blurSegment
(
int
n
const
uint32_t
*
src
int
srcStride
uint32_t
*
dst
int
dstStride
)
override
{
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer0Cursor
=
fBuffer0Cursor
;
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer1Cursor
=
fBuffer1Cursor
;
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer2Cursor
=
fBuffer2Cursor
;
skvx
:
:
Vec
<
4
uint32_t
>
sum0
=
skvx
:
:
Vec
<
4
uint32_t
>
:
:
Load
(
fSum0
)
;
skvx
:
:
Vec
<
4
uint32_t
>
sum1
=
skvx
:
:
Vec
<
4
uint32_t
>
:
:
Load
(
fSum1
)
;
skvx
:
:
Vec
<
4
uint32_t
>
sum2
=
skvx
:
:
Vec
<
4
uint32_t
>
:
:
Load
(
fSum2
)
;
auto
processValue
=
[
&
]
(
const
skvx
:
:
Vec
<
4
uint32_t
>
&
leadingEdge
)
{
sum0
+
=
leadingEdge
;
sum1
+
=
sum0
;
sum2
+
=
sum1
;
skvx
:
:
Vec
<
4
uint32_t
>
blurred
=
fDivider
.
divide
(
sum2
)
;
sum2
-
=
*
buffer2Cursor
;
*
buffer2Cursor
=
sum1
;
buffer2Cursor
=
(
buffer2Cursor
+
1
)
<
fBuffersEnd
?
buffer2Cursor
+
1
:
fBuffer2
;
sum1
-
=
*
buffer1Cursor
;
*
buffer1Cursor
=
sum0
;
buffer1Cursor
=
(
buffer1Cursor
+
1
)
<
fBuffer2
?
buffer1Cursor
+
1
:
fBuffer1
;
sum0
-
=
*
buffer0Cursor
;
*
buffer0Cursor
=
leadingEdge
;
buffer0Cursor
=
(
buffer0Cursor
+
1
)
<
fBuffer1
?
buffer0Cursor
+
1
:
fBuffer0
;
return
skvx
:
:
cast
<
uint8_t
>
(
blurred
)
;
}
;
auto
loadEdge
=
[
&
]
(
const
uint32_t
*
srcCursor
)
{
return
skvx
:
:
cast
<
uint32_t
>
(
skvx
:
:
Vec
<
4
uint8_t
>
:
:
Load
(
srcCursor
)
)
;
}
;
if
(
!
src
&
&
!
dst
)
{
while
(
n
-
-
>
0
)
{
(
void
)
processValue
(
0
)
;
}
}
else
if
(
src
&
&
!
dst
)
{
while
(
n
-
-
>
0
)
{
(
void
)
processValue
(
loadEdge
(
src
)
)
;
src
+
=
srcStride
;
}
}
else
if
(
!
src
&
&
dst
)
{
while
(
n
-
-
>
0
)
{
processValue
(
0u
)
.
store
(
dst
)
;
dst
+
=
dstStride
;
}
}
else
if
(
src
&
&
dst
)
{
while
(
n
-
-
>
0
)
{
processValue
(
loadEdge
(
src
)
)
.
store
(
dst
)
;
src
+
=
srcStride
;
dst
+
=
dstStride
;
}
}
fBuffer0Cursor
=
buffer0Cursor
;
fBuffer1Cursor
=
buffer1Cursor
;
fBuffer2Cursor
=
buffer2Cursor
;
sum0
.
store
(
fSum0
)
;
sum1
.
store
(
fSum1
)
;
sum2
.
store
(
fSum2
)
;
}
skvx
:
:
Vec
<
4
uint32_t
>
*
const
fBuffer0
;
skvx
:
:
Vec
<
4
uint32_t
>
*
const
fBuffer1
;
skvx
:
:
Vec
<
4
uint32_t
>
*
const
fBuffer2
;
skvx
:
:
Vec
<
4
uint32_t
>
*
const
fBuffersEnd
;
const
skvx
:
:
ScaledDividerU32
fDivider
;
char
fSum0
[
sizeof
(
skvx
:
:
Vec
<
4
uint32_t
>
)
]
;
char
fSum1
[
sizeof
(
skvx
:
:
Vec
<
4
uint32_t
>
)
]
;
char
fSum2
[
sizeof
(
skvx
:
:
Vec
<
4
uint32_t
>
)
]
;
skvx
:
:
Vec
<
4
uint32_t
>
*
fBuffer0Cursor
;
skvx
:
:
Vec
<
4
uint32_t
>
*
fBuffer1Cursor
;
skvx
:
:
Vec
<
4
uint32_t
>
*
fBuffer2Cursor
;
}
;
class
TentPass
final
:
public
Pass
{
public
:
static
PassMaker
*
MakeMaker
(
double
sigma
SkArenaAlloc
*
alloc
)
{
SkASSERT
(
0
<
=
sigma
)
;
int
gaussianWindow
=
calculate_window
(
sigma
)
;
int
tentWindow
=
3
*
gaussianWindow
/
2
;
if
(
tentWindow
>
=
4104
)
{
return
nullptr
;
}
class
Maker
:
public
PassMaker
{
public
:
explicit
Maker
(
int
window
)
:
PassMaker
{
window
}
{
}
Pass
*
makePass
(
void
*
buffer
SkArenaAlloc
*
alloc
)
const
override
{
return
TentPass
:
:
Make
(
this
-
>
window
(
)
buffer
alloc
)
;
}
size_t
bufferSizeBytes
(
)
const
override
{
size_t
onePassSize
=
this
-
>
window
(
)
-
1
;
size_t
bufferCount
=
2
*
onePassSize
;
return
bufferCount
*
sizeof
(
skvx
:
:
Vec
<
4
uint32_t
>
)
;
}
}
;
return
alloc
-
>
make
<
Maker
>
(
tentWindow
)
;
}
static
TentPass
*
Make
(
int
window
void
*
buffers
SkArenaAlloc
*
alloc
)
{
if
(
window
>
4104
)
{
return
nullptr
;
}
int
passSize
=
window
-
1
;
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer0
=
static_cast
<
skvx
:
:
Vec
<
4
uint32_t
>
*
>
(
buffers
)
;
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer1
=
buffer0
+
passSize
;
skvx
:
:
Vec
<
4
uint32_t
>
*
buffersEnd
=
buffer1
+
passSize
;
int
border
=
window
-
1
;
int
divisor
=
window
*
window
;
return
alloc
-
>
make
<
TentPass
>
(
buffer0
buffer1
buffersEnd
border
divisor
)
;
}
TentPass
(
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer0
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer1
skvx
:
:
Vec
<
4
uint32_t
>
*
buffersEnd
int
border
int
divisor
)
:
Pass
{
border
}
fBuffer0
{
buffer0
}
fBuffer1
{
buffer1
}
fBuffersEnd
{
buffersEnd
}
fDivider
(
divisor
)
{
}
private
:
void
startBlur
(
)
override
{
skvx
:
:
Vec
<
4
uint32_t
>
{
0u
0u
0u
0u
}
.
store
(
fSum0
)
;
auto
half
=
fDivider
.
half
(
)
;
skvx
:
:
Vec
<
4
uint32_t
>
{
half
half
half
half
}
.
store
(
fSum1
)
;
sk_bzero
(
fBuffer0
(
fBuffersEnd
-
fBuffer0
)
*
sizeof
(
skvx
:
:
Vec
<
4
uint32_t
>
)
)
;
fBuffer0Cursor
=
fBuffer0
;
fBuffer1Cursor
=
fBuffer1
;
}
void
blurSegment
(
int
n
const
uint32_t
*
src
int
srcStride
uint32_t
*
dst
int
dstStride
)
override
{
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer0Cursor
=
fBuffer0Cursor
;
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer1Cursor
=
fBuffer1Cursor
;
skvx
:
:
Vec
<
4
uint32_t
>
sum0
=
skvx
:
:
Vec
<
4
uint32_t
>
:
:
Load
(
fSum0
)
;
skvx
:
:
Vec
<
4
uint32_t
>
sum1
=
skvx
:
:
Vec
<
4
uint32_t
>
:
:
Load
(
fSum1
)
;
auto
processValue
=
[
&
]
(
const
skvx
:
:
Vec
<
4
uint32_t
>
&
leadingEdge
)
{
sum0
+
=
leadingEdge
;
sum1
+
=
sum0
;
skvx
:
:
Vec
<
4
uint32_t
>
blurred
=
fDivider
.
divide
(
sum1
)
;
sum1
-
=
*
buffer1Cursor
;
*
buffer1Cursor
=
sum0
;
buffer1Cursor
=
(
buffer1Cursor
+
1
)
<
fBuffersEnd
?
buffer1Cursor
+
1
:
fBuffer1
;
sum0
-
=
*
buffer0Cursor
;
*
buffer0Cursor
=
leadingEdge
;
buffer0Cursor
=
(
buffer0Cursor
+
1
)
<
fBuffer1
?
buffer0Cursor
+
1
:
fBuffer0
;
return
skvx
:
:
cast
<
uint8_t
>
(
blurred
)
;
}
;
auto
loadEdge
=
[
&
]
(
const
uint32_t
*
srcCursor
)
{
return
skvx
:
:
cast
<
uint32_t
>
(
skvx
:
:
Vec
<
4
uint8_t
>
:
:
Load
(
srcCursor
)
)
;
}
;
if
(
!
src
&
&
!
dst
)
{
while
(
n
-
-
>
0
)
{
(
void
)
processValue
(
0
)
;
}
}
else
if
(
src
&
&
!
dst
)
{
while
(
n
-
-
>
0
)
{
(
void
)
processValue
(
loadEdge
(
src
)
)
;
src
+
=
srcStride
;
}
}
else
if
(
!
src
&
&
dst
)
{
while
(
n
-
-
>
0
)
{
processValue
(
0u
)
.
store
(
dst
)
;
dst
+
=
dstStride
;
}
}
else
if
(
src
&
&
dst
)
{
while
(
n
-
-
>
0
)
{
processValue
(
loadEdge
(
src
)
)
.
store
(
dst
)
;
src
+
=
srcStride
;
dst
+
=
dstStride
;
}
}
fBuffer0Cursor
=
buffer0Cursor
;
fBuffer1Cursor
=
buffer1Cursor
;
sum0
.
store
(
fSum0
)
;
sum1
.
store
(
fSum1
)
;
}
skvx
:
:
Vec
<
4
uint32_t
>
*
const
fBuffer0
;
skvx
:
:
Vec
<
4
uint32_t
>
*
const
fBuffer1
;
skvx
:
:
Vec
<
4
uint32_t
>
*
const
fBuffersEnd
;
const
skvx
:
:
ScaledDividerU32
fDivider
;
char
fSum0
[
sizeof
(
skvx
:
:
Vec
<
4
uint32_t
>
)
]
;
char
fSum1
[
sizeof
(
skvx
:
:
Vec
<
4
uint32_t
>
)
]
;
skvx
:
:
Vec
<
4
uint32_t
>
*
fBuffer0Cursor
;
skvx
:
:
Vec
<
4
uint32_t
>
*
fBuffer1Cursor
;
}
;
sk_sp
<
SkSpecialImage
>
cpu_blur
(
const
skif
:
:
Context
&
ctx
skif
:
:
LayerSpace
<
SkSize
>
sigma
const
sk_sp
<
SkSpecialImage
>
&
input
skif
:
:
LayerSpace
<
SkIRect
>
srcBounds
skif
:
:
LayerSpace
<
SkIRect
>
dstBounds
)
{
static_assert
(
kMaxSigma
<
=
2183
.
0f
)
;
SkASSERT
(
input
-
>
width
(
)
=
=
srcBounds
.
width
(
)
&
&
input
-
>
height
(
)
=
=
srcBounds
.
height
(
)
)
;
SkSTArenaAlloc
<
1024
>
alloc
;
auto
makeMaker
=
[
&
]
(
double
sigma
)
-
>
PassMaker
*
{
SkASSERT
(
0
<
=
sigma
&
&
sigma
<
=
2183
)
;
if
(
PassMaker
*
maker
=
GaussPass
:
:
MakeMaker
(
sigma
&
alloc
)
)
{
return
maker
;
}
if
(
PassMaker
*
maker
=
TentPass
:
:
MakeMaker
(
sigma
&
alloc
)
)
{
return
maker
;
}
SK_ABORT
(
"
Sigma
is
out
of
range
.
"
)
;
}
;
PassMaker
*
makerX
=
makeMaker
(
sigma
.
width
(
)
)
;
PassMaker
*
makerY
=
makeMaker
(
sigma
.
height
(
)
)
;
SkASSERT
(
makerX
-
>
window
(
)
>
1
|
|
makerY
-
>
window
(
)
>
1
)
;
SkBitmap
src
;
if
(
!
SkSpecialImages
:
:
AsBitmap
(
input
.
get
(
)
&
src
)
)
{
return
nullptr
;
}
if
(
src
.
colorType
(
)
!
=
kN32_SkColorType
)
{
return
nullptr
;
}
auto
originalDstBounds
=
dstBounds
;
if
(
makerX
-
>
window
(
)
>
1
)
{
const
auto
yPadding
=
skif
:
:
LayerSpace
<
SkSize
>
(
{
0
.
f
3
*
sigma
.
height
(
)
}
)
.
ceil
(
)
;
dstBounds
.
outset
(
yPadding
)
;
}
SkBitmap
dst
;
const
skif
:
:
LayerSpace
<
SkIPoint
>
dstOrigin
=
dstBounds
.
topLeft
(
)
;
if
(
!
dst
.
tryAllocPixels
(
src
.
info
(
)
.
makeWH
(
dstBounds
.
width
(
)
dstBounds
.
height
(
)
)
)
)
{
return
nullptr
;
}
dst
.
eraseColor
(
SK_ColorTRANSPARENT
)
;
auto
buffer
=
alloc
.
makeBytesAlignedTo
(
std
:
:
max
(
makerX
-
>
bufferSizeBytes
(
)
makerY
-
>
bufferSizeBytes
(
)
)
alignof
(
skvx
:
:
Vec
<
4
uint32_t
>
)
)
;
int
loopStart
=
std
:
:
max
(
srcBounds
.
left
(
)
dstBounds
.
left
(
)
)
;
int
loopEnd
=
std
:
:
min
(
srcBounds
.
right
(
)
dstBounds
.
right
(
)
)
;
int
dstYOffset
=
0
;
if
(
makerX
-
>
window
(
)
>
1
)
{
loopStart
=
std
:
:
max
(
srcBounds
.
top
(
)
dstBounds
.
top
(
)
)
;
loopEnd
=
std
:
:
min
(
srcBounds
.
bottom
(
)
dstBounds
.
bottom
(
)
)
;
auto
srcAddr
=
src
.
getAddr32
(
0
loopStart
-
srcBounds
.
top
(
)
)
;
auto
dstAddr
=
dst
.
getAddr32
(
0
loopStart
-
dstBounds
.
top
(
)
)
;
Pass
*
pass
=
makerX
-
>
makePass
(
buffer
&
alloc
)
;
for
(
int
y
=
loopStart
;
y
<
loopEnd
;
+
+
y
)
{
pass
-
>
blur
(
srcBounds
.
left
(
)
-
dstBounds
.
left
(
)
srcBounds
.
right
(
)
-
dstBounds
.
left
(
)
dstBounds
.
width
(
)
srcAddr
1
dstAddr
1
)
;
srcAddr
+
=
src
.
rowBytesAsPixels
(
)
;
dstAddr
+
=
dst
.
rowBytesAsPixels
(
)
;
}
src
=
dst
;
loopStart
=
originalDstBounds
.
left
(
)
;
loopEnd
=
originalDstBounds
.
right
(
)
;
dstYOffset
=
originalDstBounds
.
top
(
)
-
dstBounds
.
top
(
)
;
srcBounds
=
dstBounds
;
dstBounds
=
originalDstBounds
;
}
if
(
makerY
-
>
window
(
)
>
1
)
{
auto
srcAddr
=
src
.
getAddr32
(
loopStart
-
srcBounds
.
left
(
)
0
)
;
auto
dstAddr
=
dst
.
getAddr32
(
loopStart
-
dstBounds
.
left
(
)
dstYOffset
)
;
Pass
*
pass
=
makerY
-
>
makePass
(
buffer
&
alloc
)
;
for
(
int
x
=
loopStart
;
x
<
loopEnd
;
+
+
x
)
{
pass
-
>
blur
(
srcBounds
.
top
(
)
-
dstBounds
.
top
(
)
srcBounds
.
bottom
(
)
-
dstBounds
.
top
(
)
dstBounds
.
height
(
)
srcAddr
src
.
rowBytesAsPixels
(
)
dstAddr
dst
.
rowBytesAsPixels
(
)
)
;
srcAddr
+
=
1
;
dstAddr
+
=
1
;
}
}
originalDstBounds
.
offset
(
-
dstOrigin
)
;
return
SkSpecialImages
:
:
MakeFromRaster
(
SkIRect
(
originalDstBounds
)
dst
ctx
.
backend
(
)
-
>
surfaceProps
(
)
)
;
}
}
skif
:
:
FilterResult
SkBlurImageFilter
:
:
onFilterImage
(
const
skif
:
:
Context
&
ctx
)
const
{
const
bool
gpuBacked
=
SkToBool
(
ctx
.
backend
(
)
-
>
getBlurEngine
(
)
)
;
skif
:
:
Context
inputCtx
=
ctx
.
withNewDesiredOutput
(
this
-
>
kernelBounds
(
ctx
.
mapping
(
)
ctx
.
desiredOutput
(
)
gpuBacked
)
)
;
skif
:
:
FilterResult
childOutput
=
this
-
>
getChildOutput
(
0
inputCtx
)
;
skif
:
:
LayerSpace
<
SkSize
>
sigma
=
this
-
>
mapSigma
(
ctx
.
mapping
(
)
gpuBacked
)
;
if
(
sigma
.
width
(
)
=
=
0
.
f
&
&
sigma
.
height
(
)
=
=
0
.
f
)
{
return
childOutput
;
}
SkASSERT
(
sigma
.
width
(
)
>
=
0
.
f
&
&
sigma
.
width
(
)
<
=
kMaxSigma
&
&
sigma
.
height
(
)
>
=
0
.
f
&
&
sigma
.
height
(
)
<
=
kMaxSigma
)
;
skif
:
:
LayerSpace
<
SkIRect
>
maxOutput
=
this
-
>
kernelBounds
(
ctx
.
mapping
(
)
childOutput
.
layerBounds
(
)
gpuBacked
)
;
if
(
!
maxOutput
.
intersect
(
ctx
.
desiredOutput
(
)
)
)
{
return
{
}
;
}
if
(
fLegacyTileMode
!
=
SkTileMode
:
:
kDecal
)
{
childOutput
=
childOutput
.
applyCrop
(
inputCtx
childOutput
.
layerBounds
(
)
fLegacyTileMode
)
;
}
if
(
gpuBacked
)
{
skif
:
:
Context
croppedOutput
=
ctx
.
withNewDesiredOutput
(
maxOutput
)
;
skif
:
:
FilterResult
:
:
Builder
builder
{
croppedOutput
}
;
builder
.
add
(
childOutput
)
;
return
builder
.
blur
(
sigma
)
;
}
auto
[
resolvedChildOutput
origin
]
=
childOutput
.
imageAndOffset
(
inputCtx
)
;
if
(
!
resolvedChildOutput
)
{
return
{
}
;
}
skif
:
:
LayerSpace
<
SkIRect
>
srcBounds
{
SkIRect
:
:
MakeXYWH
(
origin
.
x
(
)
origin
.
y
(
)
resolvedChildOutput
-
>
width
(
)
resolvedChildOutput
-
>
height
(
)
)
}
;
return
skif
:
:
FilterResult
{
cpu_blur
(
ctx
sigma
std
:
:
move
(
resolvedChildOutput
)
srcBounds
maxOutput
)
maxOutput
.
topLeft
(
)
}
;
}
skif
:
:
LayerSpace
<
SkSize
>
SkBlurImageFilter
:
:
mapSigma
(
const
skif
:
:
Mapping
&
mapping
bool
gpuBacked
)
const
{
skif
:
:
LayerSpace
<
SkSize
>
sigma
=
mapping
.
paramToLayer
(
fSigma
)
;
sigma
=
skif
:
:
LayerSpace
<
SkSize
>
(
{
std
:
:
min
(
sigma
.
width
(
)
kMaxSigma
)
std
:
:
min
(
sigma
.
height
(
)
kMaxSigma
)
}
)
;
if
(
!
SkScalarIsFinite
(
sigma
.
width
(
)
)
|
|
(
!
gpuBacked
&
&
calculate_window
(
sigma
.
width
(
)
)
<
=
1
)
#
if
defined
(
SK_GANESH
)
|
|
defined
(
SK_GRAPHITE
)
|
|
(
gpuBacked
&
&
skgpu
:
:
BlurIsEffectivelyIdentity
(
sigma
.
width
(
)
)
)
#
endif
)
{
sigma
=
skif
:
:
LayerSpace
<
SkSize
>
(
{
0
.
f
sigma
.
height
(
)
}
)
;
}
if
(
!
SkScalarIsFinite
(
sigma
.
height
(
)
)
|
|
(
!
gpuBacked
&
&
calculate_window
(
sigma
.
height
(
)
)
<
=
1
)
#
if
defined
(
SK_GANESH
)
|
|
defined
(
SK_GRAPHITE
)
|
|
(
gpuBacked
&
&
skgpu
:
:
BlurIsEffectivelyIdentity
(
sigma
.
height
(
)
)
)
#
endif
)
{
sigma
=
skif
:
:
LayerSpace
<
SkSize
>
(
{
sigma
.
width
(
)
0
.
f
}
)
;
}
return
sigma
;
}
skif
:
:
LayerSpace
<
SkIRect
>
SkBlurImageFilter
:
:
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
{
skif
:
:
LayerSpace
<
SkIRect
>
requiredInput
=
this
-
>
kernelBounds
(
mapping
desiredOutput
true
)
;
return
this
-
>
getChildInputLayerBounds
(
0
mapping
requiredInput
contentBounds
)
;
}
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
SkBlurImageFilter
:
:
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
{
auto
childOutput
=
this
-
>
getChildOutputLayerBounds
(
0
mapping
contentBounds
)
;
if
(
childOutput
)
{
return
this
-
>
kernelBounds
(
mapping
*
childOutput
true
)
;
}
else
{
return
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Unbounded
(
)
;
}
}
SkRect
SkBlurImageFilter
:
:
computeFastBounds
(
const
SkRect
&
src
)
const
{
SkRect
bounds
=
this
-
>
getInput
(
0
)
?
this
-
>
getInput
(
0
)
-
>
computeFastBounds
(
src
)
:
src
;
bounds
.
outset
(
SkSize
(
fSigma
)
.
width
(
)
*
3
SkSize
(
fSigma
)
.
height
(
)
*
3
)
;
return
bounds
;
}
