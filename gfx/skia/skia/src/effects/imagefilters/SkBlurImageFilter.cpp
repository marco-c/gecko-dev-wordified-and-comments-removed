#
include
"
include
/
effects
/
SkBlurImageFilter
.
h
"
#
include
<
algorithm
>
#
include
"
include
/
core
/
SkBitmap
.
h
"
#
include
"
include
/
core
/
SkTileMode
.
h
"
#
include
"
include
/
private
/
SkColorData
.
h
"
#
include
"
include
/
private
/
SkNx
.
h
"
#
include
"
include
/
private
/
SkTFitsIn
.
h
"
#
include
"
src
/
core
/
SkArenaAlloc
.
h
"
#
include
"
src
/
core
/
SkAutoPixmapStorage
.
h
"
#
include
"
src
/
core
/
SkGpuBlurUtils
.
h
"
#
include
"
src
/
core
/
SkImageFilter_Base
.
h
"
#
include
"
src
/
core
/
SkOpts
.
h
"
#
include
"
src
/
core
/
SkReadBuffer
.
h
"
#
include
"
src
/
core
/
SkSpecialImage
.
h
"
#
include
"
src
/
core
/
SkWriteBuffer
.
h
"
#
if
SK_SUPPORT_GPU
#
include
"
include
/
gpu
/
GrContext
.
h
"
#
include
"
src
/
gpu
/
GrTextureProxy
.
h
"
#
include
"
src
/
gpu
/
SkGr
.
h
"
#
endif
namespace
{
class
SkBlurImageFilterImpl
final
:
public
SkImageFilter_Base
{
public
:
SkBlurImageFilterImpl
(
SkScalar
sigmaX
SkScalar
sigmaY
SkTileMode
tileMode
sk_sp
<
SkImageFilter
>
input
const
CropRect
*
cropRect
)
:
INHERITED
(
&
input
1
cropRect
)
fSigma
{
sigmaX
sigmaY
}
fTileMode
(
tileMode
)
{
}
SkRect
computeFastBounds
(
const
SkRect
&
)
const
override
;
protected
:
void
flatten
(
SkWriteBuffer
&
)
const
override
;
sk_sp
<
SkSpecialImage
>
onFilterImage
(
const
Context
&
SkIPoint
*
offset
)
const
override
;
SkIRect
onFilterNodeBounds
(
const
SkIRect
&
src
const
SkMatrix
&
ctm
MapDirection
const
SkIRect
*
inputRect
)
const
override
;
private
:
friend
void
SkBlurImageFilter
:
:
RegisterFlattenables
(
)
;
SK_FLATTENABLE_HOOKS
(
SkBlurImageFilterImpl
)
#
if
SK_SUPPORT_GPU
sk_sp
<
SkSpecialImage
>
gpuFilter
(
const
Context
&
ctx
SkVector
sigma
const
sk_sp
<
SkSpecialImage
>
&
input
SkIRect
inputBounds
SkIRect
dstBounds
SkIPoint
inputOffset
SkIPoint
*
offset
)
const
;
#
endif
SkSize
fSigma
;
SkTileMode
fTileMode
;
typedef
SkImageFilter_Base
INHERITED
;
}
;
}
static
SkTileMode
to_sktilemode
(
SkBlurImageFilter
:
:
TileMode
tileMode
)
{
switch
(
tileMode
)
{
case
SkBlurImageFilter
:
:
kClamp_TileMode
:
return
SkTileMode
:
:
kClamp
;
case
SkBlurImageFilter
:
:
kRepeat_TileMode
:
return
SkTileMode
:
:
kRepeat
;
case
SkBlurImageFilter
:
:
kClampToBlack_TileMode
:
default
:
return
SkTileMode
:
:
kDecal
;
}
}
sk_sp
<
SkImageFilter
>
SkBlurImageFilter
:
:
Make
(
SkScalar
sigmaX
SkScalar
sigmaY
sk_sp
<
SkImageFilter
>
input
const
SkImageFilter
:
:
CropRect
*
cropRect
TileMode
tileMode
)
{
return
Make
(
sigmaX
sigmaY
to_sktilemode
(
tileMode
)
std
:
:
move
(
input
)
cropRect
)
;
}
sk_sp
<
SkImageFilter
>
SkBlurImageFilter
:
:
Make
(
SkScalar
sigmaX
SkScalar
sigmaY
SkTileMode
tileMode
sk_sp
<
SkImageFilter
>
input
const
SkImageFilter
:
:
CropRect
*
cropRect
)
{
if
(
sigmaX
<
SK_ScalarNearlyZero
&
&
sigmaY
<
SK_ScalarNearlyZero
&
&
!
cropRect
)
{
return
input
;
}
return
sk_sp
<
SkImageFilter
>
(
new
SkBlurImageFilterImpl
(
sigmaX
sigmaY
tileMode
input
cropRect
)
)
;
}
void
SkBlurImageFilter
:
:
RegisterFlattenables
(
)
{
SK_REGISTER_FLATTENABLE
(
SkBlurImageFilterImpl
)
;
}
sk_sp
<
SkFlattenable
>
SkBlurImageFilterImpl
:
:
CreateProc
(
SkReadBuffer
&
buffer
)
{
SK_IMAGEFILTER_UNFLATTEN_COMMON
(
common
1
)
;
SkScalar
sigmaX
=
buffer
.
readScalar
(
)
;
SkScalar
sigmaY
=
buffer
.
readScalar
(
)
;
SkTileMode
tileMode
;
if
(
buffer
.
isVersionLT
(
SkPicturePriv
:
:
kTileModeInBlurImageFilter_Version
)
)
{
tileMode
=
SkTileMode
:
:
kDecal
;
}
else
if
(
buffer
.
isVersionLT
(
SkPicturePriv
:
:
kCleanupImageFilterEnums_Version
)
)
{
tileMode
=
to_sktilemode
(
buffer
.
read32LE
(
SkBlurImageFilter
:
:
kLast_TileMode
)
)
;
}
else
{
tileMode
=
buffer
.
read32LE
(
SkTileMode
:
:
kLastTileMode
)
;
}
static_assert
(
SkBlurImageFilter
:
:
kLast_TileMode
=
=
2
"
CreateProc
"
)
;
return
SkBlurImageFilter
:
:
Make
(
sigmaX
sigmaY
tileMode
common
.
getInput
(
0
)
&
common
.
cropRect
(
)
)
;
}
void
SkBlurImageFilterImpl
:
:
flatten
(
SkWriteBuffer
&
buffer
)
const
{
this
-
>
INHERITED
:
:
flatten
(
buffer
)
;
buffer
.
writeScalar
(
fSigma
.
fWidth
)
;
buffer
.
writeScalar
(
fSigma
.
fHeight
)
;
static_assert
(
(
int
)
SkTileMode
:
:
kLastTileMode
=
=
3
&
&
SkBlurImageFilter
:
:
kLast_TileMode
=
=
2
"
SkBlurImageFilterImpl
:
:
flatten
"
)
;
SkASSERT
(
fTileMode
<
=
SkTileMode
:
:
kLastTileMode
)
;
buffer
.
writeInt
(
static_cast
<
int
>
(
fTileMode
)
)
;
}
#
if
SK_SUPPORT_GPU
static
GrTextureDomain
:
:
Mode
to_texture_domain_mode
(
SkTileMode
tileMode
)
{
switch
(
tileMode
)
{
case
SkTileMode
:
:
kClamp
:
return
GrTextureDomain
:
:
kClamp_Mode
;
case
SkTileMode
:
:
kDecal
:
return
GrTextureDomain
:
:
kDecal_Mode
;
case
SkTileMode
:
:
kMirror
:
case
SkTileMode
:
:
kRepeat
:
return
GrTextureDomain
:
:
kRepeat_Mode
;
default
:
SK_ABORT
(
"
Unsupported
tile
mode
.
"
)
;
}
}
#
endif
static
int
calculate_window
(
double
sigma
)
{
sigma
=
SkTPin
(
sigma
0
.
0
136
.
0
)
;
auto
possibleWindow
=
static_cast
<
int
>
(
floor
(
sigma
*
3
*
sqrt
(
2
*
SK_DoublePI
)
/
4
+
0
.
5
)
)
;
return
std
:
:
max
(
1
possibleWindow
)
;
}
static
int
calculate_border
(
int
window
)
{
return
(
window
&
1
)
=
=
1
?
3
*
(
(
window
-
1
)
/
2
)
:
3
*
(
window
/
2
)
-
1
;
}
static
int
calculate_buffer
(
int
window
)
{
int
bufferSize
=
window
-
1
;
return
(
window
&
1
)
=
=
1
?
3
*
bufferSize
:
3
*
bufferSize
+
1
;
}
using
Pass0And1
=
Sk4u
[
2
]
;
static
void
blur_one_direction
(
Sk4u
*
buffer
int
window
int
srcLeft
int
srcRight
int
dstRight
const
uint32_t
*
src
int
srcXStride
int
srcYStride
int
srcH
uint32_t
*
dst
int
dstXStride
int
dstYStride
)
{
auto
pass0Count
=
window
-
1
pass1Count
=
window
-
1
pass2Count
=
(
window
&
1
)
=
=
1
?
window
-
1
:
window
;
Pass0And1
*
buffer01Start
=
(
Pass0And1
*
)
buffer
;
Sk4u
*
buffer2Start
=
buffer
+
pass0Count
+
pass1Count
;
Pass0And1
*
buffer01End
=
(
Pass0And1
*
)
buffer2Start
;
Sk4u
*
buffer2End
=
buffer2Start
+
pass2Count
;
auto
window2
=
window
*
window
;
auto
window3
=
window2
*
window
;
auto
divisor
=
(
window
&
1
)
=
=
1
?
window3
:
window3
+
window2
;
auto
weight
=
static_cast
<
uint32_t
>
(
round
(
1
.
0
/
divisor
*
(
1ull
<
<
32
)
)
)
;
auto
half
=
static_cast
<
uint32_t
>
(
(
divisor
+
1
)
/
2
)
;
auto
border
=
calculate_border
(
window
)
;
auto
srcStart
=
srcLeft
-
border
srcEnd
=
srcRight
-
border
dstEnd
=
dstRight
;
for
(
auto
y
=
0
;
y
<
srcH
;
y
+
+
)
{
auto
buffer01Cursor
=
buffer01Start
;
auto
buffer2Cursor
=
buffer2Start
;
Sk4u
sum0
{
0u
}
;
Sk4u
sum1
{
0u
}
;
Sk4u
sum2
{
half
}
;
sk_bzero
(
buffer01Start
(
buffer2End
-
(
Sk4u
*
)
(
buffer01Start
)
)
*
sizeof
(
*
buffer2Start
)
)
;
auto
processValue
=
[
&
]
(
const
Sk4u
&
leadingEdge
)
-
>
Sk4u
{
sum0
+
=
leadingEdge
;
sum1
+
=
sum0
;
sum2
+
=
sum1
;
Sk4u
value
=
sum2
.
mulHi
(
weight
)
;
sum2
-
=
*
buffer2Cursor
;
*
buffer2Cursor
=
sum1
;
buffer2Cursor
=
(
buffer2Cursor
+
1
)
<
buffer2End
?
buffer2Cursor
+
1
:
buffer2Start
;
sum1
-
=
(
*
buffer01Cursor
)
[
1
]
;
(
*
buffer01Cursor
)
[
1
]
=
sum0
;
sum0
-
=
(
*
buffer01Cursor
)
[
0
]
;
(
*
buffer01Cursor
)
[
0
]
=
leadingEdge
;
buffer01Cursor
=
(
buffer01Cursor
+
1
)
<
buffer01End
?
buffer01Cursor
+
1
:
buffer01Start
;
return
value
;
}
;
auto
srcIdx
=
srcStart
;
auto
dstIdx
=
0
;
const
uint32_t
*
srcCursor
=
src
;
uint32_t
*
dstCursor
=
dst
;
while
(
dstIdx
<
srcIdx
)
{
*
dstCursor
=
0
;
dstCursor
+
=
dstXStride
;
SK_PREFETCH
(
dstCursor
)
;
dstIdx
+
+
;
}
while
(
dstIdx
>
srcIdx
)
{
Sk4u
leadingEdge
=
srcIdx
<
srcEnd
?
SkNx_cast
<
uint32_t
>
(
Sk4b
:
:
Load
(
srcCursor
)
)
:
0
;
(
void
)
processValue
(
leadingEdge
)
;
srcCursor
+
=
srcXStride
;
srcIdx
+
+
;
}
auto
loopEnd
=
std
:
:
min
(
dstEnd
srcEnd
)
;
while
(
dstIdx
<
loopEnd
)
{
Sk4u
leadingEdge
=
SkNx_cast
<
uint32_t
>
(
Sk4b
:
:
Load
(
srcCursor
)
)
;
SkNx_cast
<
uint8_t
>
(
processValue
(
leadingEdge
)
)
.
store
(
dstCursor
)
;
srcCursor
+
=
srcXStride
;
dstCursor
+
=
dstXStride
;
SK_PREFETCH
(
dstCursor
)
;
dstIdx
+
+
;
}
loopEnd
=
dstEnd
;
while
(
dstIdx
<
loopEnd
)
{
SkNx_cast
<
uint8_t
>
(
processValue
(
0u
)
)
.
store
(
dstCursor
)
;
dstCursor
+
=
dstXStride
;
SK_PREFETCH
(
dstCursor
)
;
dstIdx
+
+
;
}
src
+
=
srcYStride
;
dst
+
=
dstYStride
;
}
}
static
sk_sp
<
SkSpecialImage
>
copy_image_with_bounds
(
const
SkImageFilter_Base
:
:
Context
&
ctx
const
sk_sp
<
SkSpecialImage
>
&
input
SkIRect
srcBounds
SkIRect
dstBounds
)
{
SkBitmap
inputBM
;
if
(
!
input
-
>
getROPixels
(
&
inputBM
)
)
{
return
nullptr
;
}
if
(
inputBM
.
colorType
(
)
!
=
kN32_SkColorType
)
{
return
nullptr
;
}
SkBitmap
src
;
inputBM
.
extractSubset
(
&
src
srcBounds
)
;
srcBounds
.
offset
(
-
dstBounds
.
x
(
)
-
dstBounds
.
y
(
)
)
;
dstBounds
.
offset
(
-
dstBounds
.
x
(
)
-
dstBounds
.
y
(
)
)
;
auto
srcW
=
srcBounds
.
width
(
)
dstW
=
dstBounds
.
width
(
)
dstH
=
dstBounds
.
height
(
)
;
SkImageInfo
dstInfo
=
SkImageInfo
:
:
Make
(
dstW
dstH
inputBM
.
colorType
(
)
inputBM
.
alphaType
(
)
)
;
SkBitmap
dst
;
if
(
!
dst
.
tryAllocPixels
(
dstInfo
)
)
{
return
nullptr
;
}
int
y
=
0
;
size_t
dstWBytes
=
dstW
*
sizeof
(
uint32_t
)
;
for
(
;
y
<
srcBounds
.
top
(
)
;
y
+
+
)
{
sk_bzero
(
dst
.
getAddr32
(
0
y
)
dstWBytes
)
;
}
for
(
;
y
<
srcBounds
.
bottom
(
)
;
y
+
+
)
{
int
x
=
0
;
uint32_t
*
dstPtr
=
dst
.
getAddr32
(
0
y
)
;
for
(
;
x
<
srcBounds
.
left
(
)
;
x
+
+
)
{
*
dstPtr
+
+
=
0
;
}
memcpy
(
dstPtr
src
.
getAddr32
(
x
-
srcBounds
.
left
(
)
y
-
srcBounds
.
top
(
)
)
srcW
*
sizeof
(
uint32_t
)
)
;
dstPtr
+
=
srcW
;
x
+
=
srcW
;
for
(
;
x
<
dstBounds
.
right
(
)
;
x
+
+
)
{
*
dstPtr
+
+
=
0
;
}
}
for
(
;
y
<
dstBounds
.
bottom
(
)
;
y
+
+
)
{
sk_bzero
(
dst
.
getAddr32
(
0
y
)
dstWBytes
)
;
}
return
SkSpecialImage
:
:
MakeFromRaster
(
SkIRect
:
:
MakeWH
(
dstBounds
.
width
(
)
dstBounds
.
height
(
)
)
dst
ctx
.
surfaceProps
(
)
)
;
}
static
sk_sp
<
SkSpecialImage
>
cpu_blur
(
const
SkImageFilter_Base
:
:
Context
&
ctx
SkVector
sigma
const
sk_sp
<
SkSpecialImage
>
&
input
SkIRect
srcBounds
SkIRect
dstBounds
)
{
auto
windowW
=
calculate_window
(
sigma
.
x
(
)
)
windowH
=
calculate_window
(
sigma
.
y
(
)
)
;
if
(
windowW
<
=
1
&
&
windowH
<
=
1
)
{
return
copy_image_with_bounds
(
ctx
input
srcBounds
dstBounds
)
;
}
SkBitmap
inputBM
;
if
(
!
input
-
>
getROPixels
(
&
inputBM
)
)
{
return
nullptr
;
}
if
(
inputBM
.
colorType
(
)
!
=
kN32_SkColorType
)
{
return
nullptr
;
}
SkBitmap
src
;
inputBM
.
extractSubset
(
&
src
srcBounds
)
;
srcBounds
.
offset
(
-
dstBounds
.
x
(
)
-
dstBounds
.
y
(
)
)
;
dstBounds
.
offset
(
-
dstBounds
.
x
(
)
-
dstBounds
.
y
(
)
)
;
auto
srcW
=
srcBounds
.
width
(
)
srcH
=
srcBounds
.
height
(
)
dstW
=
dstBounds
.
width
(
)
dstH
=
dstBounds
.
height
(
)
;
SkImageInfo
dstInfo
=
inputBM
.
info
(
)
.
makeWH
(
dstW
dstH
)
;
SkBitmap
dst
;
if
(
!
dst
.
tryAllocPixels
(
dstInfo
)
)
{
return
nullptr
;
}
auto
bufferSizeW
=
calculate_buffer
(
windowW
)
bufferSizeH
=
calculate_buffer
(
windowH
)
;
SkSTArenaAlloc
<
1024
>
alloc
;
Sk4u
*
buffer
=
alloc
.
makeArrayDefault
<
Sk4u
>
(
std
:
:
max
(
bufferSizeW
bufferSizeH
)
)
;
auto
intermediateSrc
=
static_cast
<
uint32_t
*
>
(
src
.
getPixels
(
)
)
;
auto
intermediateRowBytesAsPixels
=
src
.
rowBytesAsPixels
(
)
;
auto
intermediateWidth
=
srcW
;
auto
intermediateDst
=
dst
.
getAddr32
(
srcBounds
.
left
(
)
0
)
;
if
(
windowW
=
=
1
|
|
windowH
=
=
1
)
{
dst
.
eraseColor
(
0
)
;
}
if
(
windowW
>
1
)
{
int64_t
shift
=
srcBounds
.
top
(
)
-
dstBounds
.
top
(
)
;
intermediateSrc
=
static_cast
<
uint32_t
*
>
(
dst
.
getPixels
(
)
)
+
(
shift
>
0
?
shift
*
dst
.
rowBytesAsPixels
(
)
:
0
)
;
intermediateRowBytesAsPixels
=
dst
.
rowBytesAsPixels
(
)
;
intermediateWidth
=
dstW
;
intermediateDst
=
static_cast
<
uint32_t
*
>
(
dst
.
getPixels
(
)
)
;
blur_one_direction
(
buffer
windowW
srcBounds
.
left
(
)
srcBounds
.
right
(
)
dstBounds
.
right
(
)
static_cast
<
uint32_t
*
>
(
src
.
getPixels
(
)
)
1
src
.
rowBytesAsPixels
(
)
srcH
intermediateSrc
1
intermediateRowBytesAsPixels
)
;
}
if
(
windowH
>
1
)
{
blur_one_direction
(
buffer
windowH
srcBounds
.
top
(
)
srcBounds
.
bottom
(
)
dstBounds
.
bottom
(
)
intermediateSrc
intermediateRowBytesAsPixels
1
intermediateWidth
intermediateDst
dst
.
rowBytesAsPixels
(
)
1
)
;
}
return
SkSpecialImage
:
:
MakeFromRaster
(
SkIRect
:
:
MakeWH
(
dstBounds
.
width
(
)
dstBounds
.
height
(
)
)
dst
ctx
.
surfaceProps
(
)
)
;
}
#
define
MAX_SIGMA
SkIntToScalar
(
532
)
static
SkVector
map_sigma
(
const
SkSize
&
localSigma
const
SkMatrix
&
ctm
)
{
SkVector
sigma
=
SkVector
:
:
Make
(
localSigma
.
width
(
)
localSigma
.
height
(
)
)
;
ctm
.
mapVectors
(
&
sigma
1
)
;
sigma
.
fX
=
SkMinScalar
(
SkScalarAbs
(
sigma
.
fX
)
MAX_SIGMA
)
;
sigma
.
fY
=
SkMinScalar
(
SkScalarAbs
(
sigma
.
fY
)
MAX_SIGMA
)
;
return
sigma
;
}
sk_sp
<
SkSpecialImage
>
SkBlurImageFilterImpl
:
:
onFilterImage
(
const
Context
&
ctx
SkIPoint
*
offset
)
const
{
SkIPoint
inputOffset
=
SkIPoint
:
:
Make
(
0
0
)
;
sk_sp
<
SkSpecialImage
>
input
(
this
-
>
filterInput
(
0
ctx
&
inputOffset
)
)
;
if
(
!
input
)
{
return
nullptr
;
}
SkIRect
inputBounds
=
SkIRect
:
:
MakeXYWH
(
inputOffset
.
fX
inputOffset
.
fY
input
-
>
width
(
)
input
-
>
height
(
)
)
;
SkIRect
dstBounds
;
if
(
!
this
-
>
applyCropRect
(
this
-
>
mapContext
(
ctx
)
inputBounds
&
dstBounds
)
)
{
return
nullptr
;
}
if
(
!
inputBounds
.
intersect
(
dstBounds
)
)
{
return
nullptr
;
}
SkIPoint
resultOffset
=
SkIPoint
:
:
Make
(
dstBounds
.
fLeft
dstBounds
.
fTop
)
;
inputBounds
.
offset
(
-
inputOffset
)
;
dstBounds
.
offset
(
-
inputOffset
)
;
SkVector
sigma
=
map_sigma
(
fSigma
ctx
.
ctm
(
)
)
;
if
(
sigma
.
x
(
)
<
0
|
|
sigma
.
y
(
)
<
0
)
{
return
nullptr
;
}
sk_sp
<
SkSpecialImage
>
result
;
#
if
SK_SUPPORT_GPU
if
(
ctx
.
gpuBacked
(
)
)
{
input
=
ImageToColorSpace
(
input
.
get
(
)
ctx
.
colorType
(
)
ctx
.
colorSpace
(
)
)
;
result
=
this
-
>
gpuFilter
(
ctx
sigma
input
inputBounds
dstBounds
inputOffset
&
resultOffset
)
;
}
else
#
endif
{
sigma
.
fX
=
SkTPin
(
sigma
.
fX
0
.
0f
135
.
0f
)
;
sigma
.
fY
=
SkTPin
(
sigma
.
fY
0
.
0f
135
.
0f
)
;
result
=
cpu_blur
(
ctx
sigma
input
inputBounds
dstBounds
)
;
}
if
(
result
!
=
nullptr
)
{
*
offset
=
resultOffset
;
}
return
result
;
}
#
if
SK_SUPPORT_GPU
sk_sp
<
SkSpecialImage
>
SkBlurImageFilterImpl
:
:
gpuFilter
(
const
Context
&
ctx
SkVector
sigma
const
sk_sp
<
SkSpecialImage
>
&
input
SkIRect
inputBounds
SkIRect
dstBounds
SkIPoint
inputOffset
SkIPoint
*
offset
)
const
{
if
(
0
=
=
sigma
.
x
(
)
&
&
0
=
=
sigma
.
y
(
)
)
{
offset
-
>
fX
=
inputBounds
.
x
(
)
+
inputOffset
.
fX
;
offset
-
>
fY
=
inputBounds
.
y
(
)
+
inputOffset
.
fY
;
return
input
-
>
makeSubset
(
inputBounds
)
;
}
auto
context
=
ctx
.
getContext
(
)
;
sk_sp
<
GrTextureProxy
>
inputTexture
(
input
-
>
asTextureProxyRef
(
context
)
)
;
if
(
!
inputTexture
)
{
return
nullptr
;
}
auto
renderTargetContext
=
SkGpuBlurUtils
:
:
GaussianBlur
(
context
std
:
:
move
(
inputTexture
)
SkColorTypeToGrColorType
(
input
-
>
colorType
(
)
)
input
-
>
alphaType
(
)
input
-
>
subset
(
)
.
topLeft
(
)
ctx
.
colorSpace
(
)
?
sk_ref_sp
(
input
-
>
getColorSpace
(
)
)
:
nullptr
dstBounds
inputBounds
sigma
.
x
(
)
sigma
.
y
(
)
to_texture_domain_mode
(
fTileMode
)
)
;
if
(
!
renderTargetContext
)
{
return
nullptr
;
}
return
SkSpecialImage
:
:
MakeDeferredFromGpu
(
context
SkIRect
:
:
MakeWH
(
dstBounds
.
width
(
)
dstBounds
.
height
(
)
)
kNeedNewImageUniqueID_SpecialImage
renderTargetContext
-
>
asTextureProxyRef
(
)
renderTargetContext
-
>
colorInfo
(
)
.
colorType
(
)
sk_ref_sp
(
input
-
>
getColorSpace
(
)
)
ctx
.
surfaceProps
(
)
)
;
}
#
endif
SkRect
SkBlurImageFilterImpl
:
:
computeFastBounds
(
const
SkRect
&
src
)
const
{
SkRect
bounds
=
this
-
>
getInput
(
0
)
?
this
-
>
getInput
(
0
)
-
>
computeFastBounds
(
src
)
:
src
;
bounds
.
outset
(
fSigma
.
width
(
)
*
3
fSigma
.
height
(
)
*
3
)
;
return
bounds
;
}
SkIRect
SkBlurImageFilterImpl
:
:
onFilterNodeBounds
(
const
SkIRect
&
src
const
SkMatrix
&
ctm
MapDirection
const
SkIRect
*
inputRect
)
const
{
SkVector
sigma
=
map_sigma
(
fSigma
ctm
)
;
return
src
.
makeOutset
(
SkScalarCeilToInt
(
sigma
.
x
(
)
*
3
)
SkScalarCeilToInt
(
sigma
.
y
(
)
*
3
)
)
;
}
