#
include
"
include
/
core
/
SkBitmap
.
h
"
#
include
"
include
/
core
/
SkColorType
.
h
"
#
include
"
include
/
core
/
SkFlattenable
.
h
"
#
include
"
include
/
core
/
SkImageFilter
.
h
"
#
include
"
include
/
core
/
SkImageInfo
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkSize
.
h
"
#
include
"
include
/
core
/
SkTileMode
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
effects
/
SkImageFilters
.
h
"
#
include
"
include
/
private
/
base
/
SkFloatingPoint
.
h
"
#
include
"
include
/
private
/
base
/
SkMalloc
.
h
"
#
include
"
src
/
base
/
SkArenaAlloc
.
h
"
#
include
"
src
/
base
/
SkVx
.
h
"
#
include
"
src
/
core
/
SkImageFilter_Base
.
h
"
#
include
"
src
/
core
/
SkReadBuffer
.
h
"
#
include
"
src
/
core
/
SkSpecialImage
.
h
"
#
include
"
src
/
core
/
SkWriteBuffer
.
h
"
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
memory
>
#
include
<
utility
>
#
if
defined
(
SK_GANESH
)
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrTypesPriv
.
h
"
#
include
"
src
/
core
/
SkGpuBlurUtils
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
GrSurfaceProxyView
.
h
"
#
include
"
src
/
gpu
/
ganesh
/
SurfaceDrawContext
.
h
"
#
endif
#
if
SK_CPU_SSE_LEVEL
>
=
SK_CPU_SSE_LEVEL_SSE1
#
include
<
xmmintrin
.
h
>
#
define
SK_PREFETCH
(
ptr
)
_mm_prefetch
(
reinterpret_cast
<
const
char
*
>
(
ptr
)
_MM_HINT_T0
)
#
elif
defined
(
__GNUC__
)
#
define
SK_PREFETCH
(
ptr
)
__builtin_prefetch
(
ptr
)
#
else
#
define
SK_PREFETCH
(
ptr
)
#
endif
namespace
{
class
SkBlurImageFilter
final
:
public
SkImageFilter_Base
{
public
:
SkBlurImageFilter
(
SkScalar
sigmaX
SkScalar
sigmaY
SkTileMode
tileMode
sk_sp
<
SkImageFilter
>
input
const
SkRect
*
cropRect
)
:
INHERITED
(
&
input
1
cropRect
)
fSigma
{
sigmaX
sigmaY
}
fTileMode
(
tileMode
)
{
}
SkRect
computeFastBounds
(
const
SkRect
&
)
const
override
;
protected
:
void
flatten
(
SkWriteBuffer
&
)
const
override
;
sk_sp
<
SkSpecialImage
>
onFilterImage
(
const
Context
&
SkIPoint
*
offset
)
const
override
;
SkIRect
onFilterNodeBounds
(
const
SkIRect
&
src
const
SkMatrix
&
ctm
MapDirection
const
SkIRect
*
inputRect
)
const
override
;
private
:
friend
void
:
:
SkRegisterBlurImageFilterFlattenable
(
)
;
SK_FLATTENABLE_HOOKS
(
SkBlurImageFilter
)
#
if
defined
(
SK_GANESH
)
sk_sp
<
SkSpecialImage
>
gpuFilter
(
const
Context
&
ctx
SkVector
sigma
const
sk_sp
<
SkSpecialImage
>
&
input
SkIRect
inputBounds
SkIRect
dstBounds
SkIPoint
inputOffset
SkIPoint
*
offset
)
const
;
#
endif
SkSize
fSigma
;
SkTileMode
fTileMode
;
using
INHERITED
=
SkImageFilter_Base
;
}
;
}
sk_sp
<
SkImageFilter
>
SkImageFilters
:
:
Blur
(
SkScalar
sigmaX
SkScalar
sigmaY
SkTileMode
tileMode
sk_sp
<
SkImageFilter
>
input
const
CropRect
&
cropRect
)
{
if
(
sigmaX
<
SK_ScalarNearlyZero
&
&
sigmaY
<
SK_ScalarNearlyZero
&
&
!
cropRect
)
{
return
input
;
}
return
sk_sp
<
SkImageFilter
>
(
new
SkBlurImageFilter
(
sigmaX
sigmaY
tileMode
input
cropRect
)
)
;
}
void
SkRegisterBlurImageFilterFlattenable
(
)
{
SK_REGISTER_FLATTENABLE
(
SkBlurImageFilter
)
;
SkFlattenable
:
:
Register
(
"
SkBlurImageFilterImpl
"
SkBlurImageFilter
:
:
CreateProc
)
;
}
sk_sp
<
SkFlattenable
>
SkBlurImageFilter
:
:
CreateProc
(
SkReadBuffer
&
buffer
)
{
SK_IMAGEFILTER_UNFLATTEN_COMMON
(
common
1
)
;
SkScalar
sigmaX
=
buffer
.
readScalar
(
)
;
SkScalar
sigmaY
=
buffer
.
readScalar
(
)
;
SkTileMode
tileMode
=
buffer
.
read32LE
(
SkTileMode
:
:
kLastTileMode
)
;
return
SkImageFilters
:
:
Blur
(
sigmaX
sigmaY
tileMode
common
.
getInput
(
0
)
common
.
cropRect
(
)
)
;
}
void
SkBlurImageFilter
:
:
flatten
(
SkWriteBuffer
&
buffer
)
const
{
this
-
>
INHERITED
:
:
flatten
(
buffer
)
;
buffer
.
writeScalar
(
fSigma
.
fWidth
)
;
buffer
.
writeScalar
(
fSigma
.
fHeight
)
;
SkASSERT
(
fTileMode
<
=
SkTileMode
:
:
kLastTileMode
)
;
buffer
.
writeInt
(
static_cast
<
int
>
(
fTileMode
)
)
;
}
namespace
{
int
calculate_window
(
double
sigma
)
{
auto
possibleWindow
=
static_cast
<
int
>
(
floor
(
sigma
*
3
*
sqrt
(
2
*
SK_DoublePI
)
/
4
+
0
.
5
)
)
;
return
std
:
:
max
(
1
possibleWindow
)
;
}
static
constexpr
SkScalar
kMaxSigma
=
532
.
f
;
static
SkVector
map_sigma
(
const
SkSize
&
localSigma
const
SkMatrix
&
ctm
)
{
SkVector
sigma
=
SkVector
:
:
Make
(
localSigma
.
width
(
)
localSigma
.
height
(
)
)
;
ctm
.
mapVectors
(
&
sigma
1
)
;
sigma
.
fX
=
std
:
:
min
(
SkScalarAbs
(
sigma
.
fX
)
kMaxSigma
)
;
sigma
.
fY
=
std
:
:
min
(
SkScalarAbs
(
sigma
.
fY
)
kMaxSigma
)
;
if
(
!
SkScalarIsFinite
(
sigma
.
fX
)
)
{
sigma
.
fX
=
0
.
f
;
}
if
(
!
SkScalarIsFinite
(
sigma
.
fY
)
)
{
sigma
.
fY
=
0
.
f
;
}
return
sigma
;
}
class
Pass
{
public
:
explicit
Pass
(
int
border
)
:
fBorder
(
border
)
{
}
virtual
~
Pass
(
)
=
default
;
void
blur
(
int
srcLeft
int
srcRight
int
dstRight
const
uint32_t
*
src
int
srcStride
uint32_t
*
dst
int
dstStride
)
{
this
-
>
startBlur
(
)
;
auto
srcStart
=
srcLeft
-
fBorder
srcEnd
=
srcRight
-
fBorder
dstEnd
=
dstRight
srcIdx
=
srcStart
dstIdx
=
0
;
const
uint32_t
*
srcCursor
=
src
;
uint32_t
*
dstCursor
=
dst
;
if
(
dstIdx
<
srcIdx
)
{
while
(
dstIdx
<
srcIdx
)
{
*
dstCursor
=
0
;
dstCursor
+
=
dstStride
;
SK_PREFETCH
(
dstCursor
)
;
dstIdx
+
+
;
}
}
else
if
(
srcIdx
<
dstIdx
)
{
if
(
int
commonEnd
=
std
:
:
min
(
dstIdx
srcEnd
)
;
srcIdx
<
commonEnd
)
{
int
n
=
commonEnd
-
srcIdx
;
this
-
>
blurSegment
(
n
srcCursor
srcStride
nullptr
0
)
;
srcIdx
+
=
n
;
srcCursor
+
=
n
*
srcStride
;
}
if
(
srcIdx
<
dstIdx
)
{
int
n
=
dstIdx
-
srcIdx
;
this
-
>
blurSegment
(
n
nullptr
0
nullptr
0
)
;
srcIdx
+
=
n
;
}
}
SkASSERT
(
srcIdx
=
=
dstIdx
)
;
if
(
int
commonEnd
=
std
:
:
min
(
dstEnd
srcEnd
)
;
dstIdx
<
commonEnd
)
{
int
n
=
commonEnd
-
dstIdx
;
this
-
>
blurSegment
(
n
srcCursor
srcStride
dstCursor
dstStride
)
;
srcCursor
+
=
n
*
srcStride
;
dstCursor
+
=
n
*
dstStride
;
dstIdx
+
=
n
;
srcIdx
+
=
n
;
}
if
(
dstIdx
<
dstEnd
)
{
int
n
=
dstEnd
-
dstIdx
;
this
-
>
blurSegment
(
n
nullptr
0
dstCursor
dstStride
)
;
}
}
protected
:
virtual
void
startBlur
(
)
=
0
;
virtual
void
blurSegment
(
int
n
const
uint32_t
*
src
int
srcStride
uint32_t
*
dst
int
dstStride
)
=
0
;
private
:
const
int
fBorder
;
}
;
class
PassMaker
{
public
:
explicit
PassMaker
(
int
window
)
:
fWindow
{
window
}
{
}
virtual
~
PassMaker
(
)
=
default
;
virtual
Pass
*
makePass
(
void
*
buffer
SkArenaAlloc
*
alloc
)
const
=
0
;
virtual
size_t
bufferSizeBytes
(
)
const
=
0
;
int
window
(
)
const
{
return
fWindow
;
}
private
:
const
int
fWindow
;
}
;
class
GaussPass
final
:
public
Pass
{
public
:
static
PassMaker
*
MakeMaker
(
double
sigma
SkArenaAlloc
*
alloc
)
{
SkASSERT
(
0
<
=
sigma
)
;
int
window
=
calculate_window
(
sigma
)
;
if
(
255
<
=
window
)
{
return
nullptr
;
}
class
Maker
:
public
PassMaker
{
public
:
explicit
Maker
(
int
window
)
:
PassMaker
{
window
}
{
}
Pass
*
makePass
(
void
*
buffer
SkArenaAlloc
*
alloc
)
const
override
{
return
GaussPass
:
:
Make
(
this
-
>
window
(
)
buffer
alloc
)
;
}
size_t
bufferSizeBytes
(
)
const
override
{
int
window
=
this
-
>
window
(
)
;
size_t
onePassSize
=
window
-
1
;
size_t
bufferCount
=
(
window
&
1
)
=
=
1
?
3
*
onePassSize
:
3
*
onePassSize
+
1
;
return
bufferCount
*
sizeof
(
skvx
:
:
Vec
<
4
uint32_t
>
)
;
}
}
;
return
alloc
-
>
make
<
Maker
>
(
window
)
;
}
static
GaussPass
*
Make
(
int
window
void
*
buffers
SkArenaAlloc
*
alloc
)
{
int
passSize
=
window
-
1
;
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer0
=
static_cast
<
skvx
:
:
Vec
<
4
uint32_t
>
*
>
(
buffers
)
;
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer1
=
buffer0
+
passSize
;
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer2
=
buffer1
+
passSize
;
skvx
:
:
Vec
<
4
uint32_t
>
*
buffersEnd
=
buffer2
+
(
(
window
&
1
)
?
passSize
:
passSize
+
1
)
;
int
border
=
(
window
&
1
)
=
=
1
?
3
*
(
(
window
-
1
)
/
2
)
:
3
*
(
window
/
2
)
-
1
;
int
window2
=
window
*
window
;
int
window3
=
window2
*
window
;
int
divisor
=
(
window
&
1
)
=
=
1
?
window3
:
window3
+
window2
;
return
alloc
-
>
make
<
GaussPass
>
(
buffer0
buffer1
buffer2
buffersEnd
border
divisor
)
;
}
GaussPass
(
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer0
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer1
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer2
skvx
:
:
Vec
<
4
uint32_t
>
*
buffersEnd
int
border
int
divisor
)
:
Pass
{
border
}
fBuffer0
{
buffer0
}
fBuffer1
{
buffer1
}
fBuffer2
{
buffer2
}
fBuffersEnd
{
buffersEnd
}
fDivider
(
divisor
)
{
}
private
:
void
startBlur
(
)
override
{
skvx
:
:
Vec
<
4
uint32_t
>
zero
=
{
0u
0u
0u
0u
}
;
zero
.
store
(
fSum0
)
;
zero
.
store
(
fSum1
)
;
auto
half
=
fDivider
.
half
(
)
;
skvx
:
:
Vec
<
4
uint32_t
>
{
half
half
half
half
}
.
store
(
fSum2
)
;
sk_bzero
(
fBuffer0
(
fBuffersEnd
-
fBuffer0
)
*
sizeof
(
skvx
:
:
Vec
<
4
uint32_t
>
)
)
;
fBuffer0Cursor
=
fBuffer0
;
fBuffer1Cursor
=
fBuffer1
;
fBuffer2Cursor
=
fBuffer2
;
}
void
blurSegment
(
int
n
const
uint32_t
*
src
int
srcStride
uint32_t
*
dst
int
dstStride
)
override
{
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer0Cursor
=
fBuffer0Cursor
;
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer1Cursor
=
fBuffer1Cursor
;
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer2Cursor
=
fBuffer2Cursor
;
skvx
:
:
Vec
<
4
uint32_t
>
sum0
=
skvx
:
:
Vec
<
4
uint32_t
>
:
:
Load
(
fSum0
)
;
skvx
:
:
Vec
<
4
uint32_t
>
sum1
=
skvx
:
:
Vec
<
4
uint32_t
>
:
:
Load
(
fSum1
)
;
skvx
:
:
Vec
<
4
uint32_t
>
sum2
=
skvx
:
:
Vec
<
4
uint32_t
>
:
:
Load
(
fSum2
)
;
auto
processValue
=
[
&
]
(
const
skvx
:
:
Vec
<
4
uint32_t
>
&
leadingEdge
)
{
sum0
+
=
leadingEdge
;
sum1
+
=
sum0
;
sum2
+
=
sum1
;
skvx
:
:
Vec
<
4
uint32_t
>
blurred
=
fDivider
.
divide
(
sum2
)
;
sum2
-
=
*
buffer2Cursor
;
*
buffer2Cursor
=
sum1
;
buffer2Cursor
=
(
buffer2Cursor
+
1
)
<
fBuffersEnd
?
buffer2Cursor
+
1
:
fBuffer2
;
sum1
-
=
*
buffer1Cursor
;
*
buffer1Cursor
=
sum0
;
buffer1Cursor
=
(
buffer1Cursor
+
1
)
<
fBuffer2
?
buffer1Cursor
+
1
:
fBuffer1
;
sum0
-
=
*
buffer0Cursor
;
*
buffer0Cursor
=
leadingEdge
;
buffer0Cursor
=
(
buffer0Cursor
+
1
)
<
fBuffer1
?
buffer0Cursor
+
1
:
fBuffer0
;
return
skvx
:
:
cast
<
uint8_t
>
(
blurred
)
;
}
;
auto
loadEdge
=
[
&
]
(
const
uint32_t
*
srcCursor
)
{
return
skvx
:
:
cast
<
uint32_t
>
(
skvx
:
:
Vec
<
4
uint8_t
>
:
:
Load
(
srcCursor
)
)
;
}
;
if
(
!
src
&
&
!
dst
)
{
while
(
n
-
-
>
0
)
{
(
void
)
processValue
(
0
)
;
}
}
else
if
(
src
&
&
!
dst
)
{
while
(
n
-
-
>
0
)
{
(
void
)
processValue
(
loadEdge
(
src
)
)
;
src
+
=
srcStride
;
}
}
else
if
(
!
src
&
&
dst
)
{
while
(
n
-
-
>
0
)
{
processValue
(
0u
)
.
store
(
dst
)
;
dst
+
=
dstStride
;
}
}
else
if
(
src
&
&
dst
)
{
while
(
n
-
-
>
0
)
{
processValue
(
loadEdge
(
src
)
)
.
store
(
dst
)
;
src
+
=
srcStride
;
dst
+
=
dstStride
;
}
}
fBuffer0Cursor
=
buffer0Cursor
;
fBuffer1Cursor
=
buffer1Cursor
;
fBuffer2Cursor
=
buffer2Cursor
;
sum0
.
store
(
fSum0
)
;
sum1
.
store
(
fSum1
)
;
sum2
.
store
(
fSum2
)
;
}
skvx
:
:
Vec
<
4
uint32_t
>
*
const
fBuffer0
;
skvx
:
:
Vec
<
4
uint32_t
>
*
const
fBuffer1
;
skvx
:
:
Vec
<
4
uint32_t
>
*
const
fBuffer2
;
skvx
:
:
Vec
<
4
uint32_t
>
*
const
fBuffersEnd
;
const
skvx
:
:
ScaledDividerU32
fDivider
;
char
fSum0
[
sizeof
(
skvx
:
:
Vec
<
4
uint32_t
>
)
]
;
char
fSum1
[
sizeof
(
skvx
:
:
Vec
<
4
uint32_t
>
)
]
;
char
fSum2
[
sizeof
(
skvx
:
:
Vec
<
4
uint32_t
>
)
]
;
skvx
:
:
Vec
<
4
uint32_t
>
*
fBuffer0Cursor
;
skvx
:
:
Vec
<
4
uint32_t
>
*
fBuffer1Cursor
;
skvx
:
:
Vec
<
4
uint32_t
>
*
fBuffer2Cursor
;
}
;
class
TentPass
final
:
public
Pass
{
public
:
static
PassMaker
*
MakeMaker
(
double
sigma
SkArenaAlloc
*
alloc
)
{
SkASSERT
(
0
<
=
sigma
)
;
int
gaussianWindow
=
calculate_window
(
sigma
)
;
int
tentWindow
=
3
*
gaussianWindow
/
2
;
if
(
tentWindow
>
=
4104
)
{
return
nullptr
;
}
class
Maker
:
public
PassMaker
{
public
:
explicit
Maker
(
int
window
)
:
PassMaker
{
window
}
{
}
Pass
*
makePass
(
void
*
buffer
SkArenaAlloc
*
alloc
)
const
override
{
return
TentPass
:
:
Make
(
this
-
>
window
(
)
buffer
alloc
)
;
}
size_t
bufferSizeBytes
(
)
const
override
{
size_t
onePassSize
=
this
-
>
window
(
)
-
1
;
size_t
bufferCount
=
2
*
onePassSize
;
return
bufferCount
*
sizeof
(
skvx
:
:
Vec
<
4
uint32_t
>
)
;
}
}
;
return
alloc
-
>
make
<
Maker
>
(
tentWindow
)
;
}
static
TentPass
*
Make
(
int
window
void
*
buffers
SkArenaAlloc
*
alloc
)
{
if
(
window
>
4104
)
{
return
nullptr
;
}
int
passSize
=
window
-
1
;
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer0
=
static_cast
<
skvx
:
:
Vec
<
4
uint32_t
>
*
>
(
buffers
)
;
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer1
=
buffer0
+
passSize
;
skvx
:
:
Vec
<
4
uint32_t
>
*
buffersEnd
=
buffer1
+
passSize
;
int
border
=
window
-
1
;
int
divisor
=
window
*
window
;
return
alloc
-
>
make
<
TentPass
>
(
buffer0
buffer1
buffersEnd
border
divisor
)
;
}
TentPass
(
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer0
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer1
skvx
:
:
Vec
<
4
uint32_t
>
*
buffersEnd
int
border
int
divisor
)
:
Pass
{
border
}
fBuffer0
{
buffer0
}
fBuffer1
{
buffer1
}
fBuffersEnd
{
buffersEnd
}
fDivider
(
divisor
)
{
}
private
:
void
startBlur
(
)
override
{
skvx
:
:
Vec
<
4
uint32_t
>
{
0u
0u
0u
0u
}
.
store
(
fSum0
)
;
auto
half
=
fDivider
.
half
(
)
;
skvx
:
:
Vec
<
4
uint32_t
>
{
half
half
half
half
}
.
store
(
fSum1
)
;
sk_bzero
(
fBuffer0
(
fBuffersEnd
-
fBuffer0
)
*
sizeof
(
skvx
:
:
Vec
<
4
uint32_t
>
)
)
;
fBuffer0Cursor
=
fBuffer0
;
fBuffer1Cursor
=
fBuffer1
;
}
void
blurSegment
(
int
n
const
uint32_t
*
src
int
srcStride
uint32_t
*
dst
int
dstStride
)
override
{
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer0Cursor
=
fBuffer0Cursor
;
skvx
:
:
Vec
<
4
uint32_t
>
*
buffer1Cursor
=
fBuffer1Cursor
;
skvx
:
:
Vec
<
4
uint32_t
>
sum0
=
skvx
:
:
Vec
<
4
uint32_t
>
:
:
Load
(
fSum0
)
;
skvx
:
:
Vec
<
4
uint32_t
>
sum1
=
skvx
:
:
Vec
<
4
uint32_t
>
:
:
Load
(
fSum1
)
;
auto
processValue
=
[
&
]
(
const
skvx
:
:
Vec
<
4
uint32_t
>
&
leadingEdge
)
{
sum0
+
=
leadingEdge
;
sum1
+
=
sum0
;
skvx
:
:
Vec
<
4
uint32_t
>
blurred
=
fDivider
.
divide
(
sum1
)
;
sum1
-
=
*
buffer1Cursor
;
*
buffer1Cursor
=
sum0
;
buffer1Cursor
=
(
buffer1Cursor
+
1
)
<
fBuffersEnd
?
buffer1Cursor
+
1
:
fBuffer1
;
sum0
-
=
*
buffer0Cursor
;
*
buffer0Cursor
=
leadingEdge
;
buffer0Cursor
=
(
buffer0Cursor
+
1
)
<
fBuffer1
?
buffer0Cursor
+
1
:
fBuffer0
;
return
skvx
:
:
cast
<
uint8_t
>
(
blurred
)
;
}
;
auto
loadEdge
=
[
&
]
(
const
uint32_t
*
srcCursor
)
{
return
skvx
:
:
cast
<
uint32_t
>
(
skvx
:
:
Vec
<
4
uint8_t
>
:
:
Load
(
srcCursor
)
)
;
}
;
if
(
!
src
&
&
!
dst
)
{
while
(
n
-
-
>
0
)
{
(
void
)
processValue
(
0
)
;
}
}
else
if
(
src
&
&
!
dst
)
{
while
(
n
-
-
>
0
)
{
(
void
)
processValue
(
loadEdge
(
src
)
)
;
src
+
=
srcStride
;
}
}
else
if
(
!
src
&
&
dst
)
{
while
(
n
-
-
>
0
)
{
processValue
(
0u
)
.
store
(
dst
)
;
dst
+
=
dstStride
;
}
}
else
if
(
src
&
&
dst
)
{
while
(
n
-
-
>
0
)
{
processValue
(
loadEdge
(
src
)
)
.
store
(
dst
)
;
src
+
=
srcStride
;
dst
+
=
dstStride
;
}
}
fBuffer0Cursor
=
buffer0Cursor
;
fBuffer1Cursor
=
buffer1Cursor
;
sum0
.
store
(
fSum0
)
;
sum1
.
store
(
fSum1
)
;
}
skvx
:
:
Vec
<
4
uint32_t
>
*
const
fBuffer0
;
skvx
:
:
Vec
<
4
uint32_t
>
*
const
fBuffer1
;
skvx
:
:
Vec
<
4
uint32_t
>
*
const
fBuffersEnd
;
const
skvx
:
:
ScaledDividerU32
fDivider
;
char
fSum0
[
sizeof
(
skvx
:
:
Vec
<
4
uint32_t
>
)
]
;
char
fSum1
[
sizeof
(
skvx
:
:
Vec
<
4
uint32_t
>
)
]
;
skvx
:
:
Vec
<
4
uint32_t
>
*
fBuffer0Cursor
;
skvx
:
:
Vec
<
4
uint32_t
>
*
fBuffer1Cursor
;
}
;
sk_sp
<
SkSpecialImage
>
copy_image_with_bounds
(
const
SkImageFilter_Base
:
:
Context
&
ctx
const
sk_sp
<
SkSpecialImage
>
&
input
SkIRect
srcBounds
SkIRect
dstBounds
)
{
SkBitmap
inputBM
;
if
(
!
input
-
>
getROPixels
(
&
inputBM
)
)
{
return
nullptr
;
}
if
(
inputBM
.
colorType
(
)
!
=
kN32_SkColorType
)
{
return
nullptr
;
}
SkBitmap
src
;
inputBM
.
extractSubset
(
&
src
srcBounds
)
;
srcBounds
.
offset
(
-
dstBounds
.
x
(
)
-
dstBounds
.
y
(
)
)
;
dstBounds
.
offset
(
-
dstBounds
.
x
(
)
-
dstBounds
.
y
(
)
)
;
auto
srcW
=
srcBounds
.
width
(
)
dstW
=
dstBounds
.
width
(
)
dstH
=
dstBounds
.
height
(
)
;
SkImageInfo
dstInfo
=
SkImageInfo
:
:
Make
(
dstW
dstH
inputBM
.
colorType
(
)
inputBM
.
alphaType
(
)
)
;
SkBitmap
dst
;
if
(
!
dst
.
tryAllocPixels
(
dstInfo
)
)
{
return
nullptr
;
}
int
y
=
0
;
size_t
dstWBytes
=
dstW
*
sizeof
(
uint32_t
)
;
for
(
;
y
<
srcBounds
.
top
(
)
;
y
+
+
)
{
sk_bzero
(
dst
.
getAddr32
(
0
y
)
dstWBytes
)
;
}
for
(
;
y
<
srcBounds
.
bottom
(
)
;
y
+
+
)
{
int
x
=
0
;
uint32_t
*
dstPtr
=
dst
.
getAddr32
(
0
y
)
;
for
(
;
x
<
srcBounds
.
left
(
)
;
x
+
+
)
{
*
dstPtr
+
+
=
0
;
}
memcpy
(
dstPtr
src
.
getAddr32
(
x
-
srcBounds
.
left
(
)
y
-
srcBounds
.
top
(
)
)
srcW
*
sizeof
(
uint32_t
)
)
;
dstPtr
+
=
srcW
;
x
+
=
srcW
;
for
(
;
x
<
dstBounds
.
right
(
)
;
x
+
+
)
{
*
dstPtr
+
+
=
0
;
}
}
for
(
;
y
<
dstBounds
.
bottom
(
)
;
y
+
+
)
{
sk_bzero
(
dst
.
getAddr32
(
0
y
)
dstWBytes
)
;
}
return
SkSpecialImage
:
:
MakeFromRaster
(
SkIRect
:
:
MakeWH
(
dstBounds
.
width
(
)
dstBounds
.
height
(
)
)
dst
ctx
.
surfaceProps
(
)
)
;
}
sk_sp
<
SkSpecialImage
>
cpu_blur
(
const
SkImageFilter_Base
:
:
Context
&
ctx
SkVector
sigma
const
sk_sp
<
SkSpecialImage
>
&
input
SkIRect
srcBounds
SkIRect
dstBounds
)
{
static_assert
(
kMaxSigma
<
=
2183
.
0f
)
;
SkSTArenaAlloc
<
1024
>
alloc
;
auto
makeMaker
=
[
&
]
(
double
sigma
)
-
>
PassMaker
*
{
SkASSERT
(
0
<
=
sigma
&
&
sigma
<
=
2183
)
;
if
(
PassMaker
*
maker
=
GaussPass
:
:
MakeMaker
(
sigma
&
alloc
)
)
{
return
maker
;
}
if
(
PassMaker
*
maker
=
TentPass
:
:
MakeMaker
(
sigma
&
alloc
)
)
{
return
maker
;
}
SK_ABORT
(
"
Sigma
is
out
of
range
.
"
)
;
}
;
PassMaker
*
makerX
=
makeMaker
(
sigma
.
x
(
)
)
;
PassMaker
*
makerY
=
makeMaker
(
sigma
.
y
(
)
)
;
if
(
makerX
-
>
window
(
)
<
=
1
&
&
makerY
-
>
window
(
)
<
=
1
)
{
return
copy_image_with_bounds
(
ctx
input
srcBounds
dstBounds
)
;
}
SkBitmap
inputBM
;
if
(
!
input
-
>
getROPixels
(
&
inputBM
)
)
{
return
nullptr
;
}
if
(
inputBM
.
colorType
(
)
!
=
kN32_SkColorType
)
{
return
nullptr
;
}
SkBitmap
src
;
inputBM
.
extractSubset
(
&
src
srcBounds
)
;
srcBounds
.
offset
(
-
dstBounds
.
x
(
)
-
dstBounds
.
y
(
)
)
;
dstBounds
.
offset
(
-
dstBounds
.
x
(
)
-
dstBounds
.
y
(
)
)
;
auto
srcW
=
srcBounds
.
width
(
)
srcH
=
srcBounds
.
height
(
)
dstW
=
dstBounds
.
width
(
)
dstH
=
dstBounds
.
height
(
)
;
SkImageInfo
dstInfo
=
inputBM
.
info
(
)
.
makeWH
(
dstW
dstH
)
;
SkBitmap
dst
;
if
(
!
dst
.
tryAllocPixels
(
dstInfo
)
)
{
return
nullptr
;
}
size_t
bufferSizeBytes
=
std
:
:
max
(
makerX
-
>
bufferSizeBytes
(
)
makerY
-
>
bufferSizeBytes
(
)
)
;
auto
buffer
=
alloc
.
makeBytesAlignedTo
(
bufferSizeBytes
alignof
(
skvx
:
:
Vec
<
4
uint32_t
>
)
)
;
auto
intermediateSrc
=
static_cast
<
uint32_t
*
>
(
src
.
getPixels
(
)
)
;
auto
intermediateRowBytesAsPixels
=
src
.
rowBytesAsPixels
(
)
;
auto
intermediateWidth
=
srcW
;
auto
intermediateDst
=
dst
.
getAddr32
(
srcBounds
.
left
(
)
0
)
;
if
(
makerX
-
>
window
(
)
=
=
1
|
|
makerY
-
>
window
(
)
=
=
1
)
{
dst
.
eraseColor
(
0
)
;
}
if
(
makerX
-
>
window
(
)
>
1
)
{
Pass
*
pass
=
makerX
-
>
makePass
(
buffer
&
alloc
)
;
int64_t
shift
=
srcBounds
.
top
(
)
-
dstBounds
.
top
(
)
;
intermediateSrc
=
static_cast
<
uint32_t
*
>
(
dst
.
getPixels
(
)
)
+
(
shift
>
0
?
shift
*
dst
.
rowBytesAsPixels
(
)
:
0
)
;
intermediateRowBytesAsPixels
=
dst
.
rowBytesAsPixels
(
)
;
intermediateWidth
=
dstW
;
intermediateDst
=
static_cast
<
uint32_t
*
>
(
dst
.
getPixels
(
)
)
;
const
uint32_t
*
srcCursor
=
static_cast
<
uint32_t
*
>
(
src
.
getPixels
(
)
)
;
uint32_t
*
dstCursor
=
intermediateSrc
;
for
(
auto
y
=
0
;
y
<
srcH
;
y
+
+
)
{
pass
-
>
blur
(
srcBounds
.
left
(
)
srcBounds
.
right
(
)
dstBounds
.
right
(
)
srcCursor
1
dstCursor
1
)
;
srcCursor
+
=
src
.
rowBytesAsPixels
(
)
;
dstCursor
+
=
intermediateRowBytesAsPixels
;
}
}
if
(
makerY
-
>
window
(
)
>
1
)
{
Pass
*
pass
=
makerY
-
>
makePass
(
buffer
&
alloc
)
;
const
uint32_t
*
srcCursor
=
intermediateSrc
;
uint32_t
*
dstCursor
=
intermediateDst
;
for
(
auto
x
=
0
;
x
<
intermediateWidth
;
x
+
+
)
{
pass
-
>
blur
(
srcBounds
.
top
(
)
srcBounds
.
bottom
(
)
dstBounds
.
bottom
(
)
srcCursor
intermediateRowBytesAsPixels
dstCursor
dst
.
rowBytesAsPixels
(
)
)
;
srcCursor
+
=
1
;
dstCursor
+
=
1
;
}
}
return
SkSpecialImage
:
:
MakeFromRaster
(
SkIRect
:
:
MakeWH
(
dstBounds
.
width
(
)
dstBounds
.
height
(
)
)
dst
ctx
.
surfaceProps
(
)
)
;
}
}
sk_sp
<
SkSpecialImage
>
SkBlurImageFilter
:
:
onFilterImage
(
const
Context
&
ctx
SkIPoint
*
offset
)
const
{
SkIPoint
inputOffset
=
SkIPoint
:
:
Make
(
0
0
)
;
sk_sp
<
SkSpecialImage
>
input
(
this
-
>
filterInput
(
0
ctx
&
inputOffset
)
)
;
if
(
!
input
)
{
return
nullptr
;
}
SkIRect
inputBounds
=
SkIRect
:
:
MakeXYWH
(
inputOffset
.
fX
inputOffset
.
fY
input
-
>
width
(
)
input
-
>
height
(
)
)
;
SkIRect
dstBounds
;
if
(
!
this
-
>
applyCropRect
(
this
-
>
mapContext
(
ctx
)
inputBounds
&
dstBounds
)
)
{
return
nullptr
;
}
if
(
!
inputBounds
.
intersect
(
dstBounds
)
)
{
return
nullptr
;
}
SkIPoint
resultOffset
=
SkIPoint
:
:
Make
(
dstBounds
.
fLeft
dstBounds
.
fTop
)
;
inputBounds
.
offset
(
-
inputOffset
)
;
dstBounds
.
offset
(
-
inputOffset
)
;
SkVector
sigma
=
map_sigma
(
fSigma
ctx
.
ctm
(
)
)
;
SkASSERT
(
SkScalarIsFinite
(
sigma
.
x
(
)
)
&
&
sigma
.
x
(
)
>
=
0
.
f
&
&
sigma
.
x
(
)
<
=
kMaxSigma
&
&
SkScalarIsFinite
(
sigma
.
y
(
)
)
&
&
sigma
.
y
(
)
>
=
0
.
f
&
&
sigma
.
y
(
)
<
=
kMaxSigma
)
;
sk_sp
<
SkSpecialImage
>
result
;
#
if
defined
(
SK_GANESH
)
if
(
ctx
.
gpuBacked
(
)
)
{
input
=
ImageToColorSpace
(
input
.
get
(
)
ctx
.
colorType
(
)
ctx
.
colorSpace
(
)
ctx
.
surfaceProps
(
)
)
;
result
=
this
-
>
gpuFilter
(
ctx
sigma
input
inputBounds
dstBounds
inputOffset
&
resultOffset
)
;
}
else
#
endif
{
result
=
cpu_blur
(
ctx
sigma
input
inputBounds
dstBounds
)
;
}
if
(
result
!
=
nullptr
)
{
*
offset
=
resultOffset
;
}
return
result
;
}
#
if
defined
(
SK_GANESH
)
sk_sp
<
SkSpecialImage
>
SkBlurImageFilter
:
:
gpuFilter
(
const
Context
&
ctx
SkVector
sigma
const
sk_sp
<
SkSpecialImage
>
&
input
SkIRect
inputBounds
SkIRect
dstBounds
SkIPoint
inputOffset
SkIPoint
*
offset
)
const
{
if
(
SkGpuBlurUtils
:
:
IsEffectivelyZeroSigma
(
sigma
.
x
(
)
)
&
&
SkGpuBlurUtils
:
:
IsEffectivelyZeroSigma
(
sigma
.
y
(
)
)
)
{
offset
-
>
fX
=
inputBounds
.
x
(
)
+
inputOffset
.
fX
;
offset
-
>
fY
=
inputBounds
.
y
(
)
+
inputOffset
.
fY
;
return
input
-
>
makeSubset
(
inputBounds
)
;
}
auto
context
=
ctx
.
getContext
(
)
;
GrSurfaceProxyView
inputView
=
input
-
>
view
(
context
)
;
if
(
!
inputView
.
proxy
(
)
)
{
return
nullptr
;
}
SkASSERT
(
inputView
.
asTextureProxy
(
)
)
;
dstBounds
.
offset
(
input
-
>
subset
(
)
.
topLeft
(
)
)
;
inputBounds
.
offset
(
input
-
>
subset
(
)
.
topLeft
(
)
)
;
auto
sdc
=
SkGpuBlurUtils
:
:
GaussianBlur
(
context
std
:
:
move
(
inputView
)
SkColorTypeToGrColorType
(
input
-
>
colorType
(
)
)
input
-
>
alphaType
(
)
ctx
.
refColorSpace
(
)
dstBounds
inputBounds
sigma
.
x
(
)
sigma
.
y
(
)
fTileMode
)
;
if
(
!
sdc
)
{
return
nullptr
;
}
return
SkSpecialImage
:
:
MakeDeferredFromGpu
(
context
SkIRect
:
:
MakeSize
(
dstBounds
.
size
(
)
)
kNeedNewImageUniqueID_SpecialImage
sdc
-
>
readSurfaceView
(
)
sdc
-
>
colorInfo
(
)
ctx
.
surfaceProps
(
)
)
;
}
#
endif
SkRect
SkBlurImageFilter
:
:
computeFastBounds
(
const
SkRect
&
src
)
const
{
SkRect
bounds
=
this
-
>
getInput
(
0
)
?
this
-
>
getInput
(
0
)
-
>
computeFastBounds
(
src
)
:
src
;
bounds
.
outset
(
fSigma
.
width
(
)
*
3
fSigma
.
height
(
)
*
3
)
;
return
bounds
;
}
SkIRect
SkBlurImageFilter
:
:
onFilterNodeBounds
(
const
SkIRect
&
src
const
SkMatrix
&
ctm
MapDirection
const
SkIRect
*
inputRect
)
const
{
SkVector
sigma
=
map_sigma
(
fSigma
ctm
)
;
return
src
.
makeOutset
(
SkScalarCeilToInt
(
sigma
.
x
(
)
*
3
)
SkScalarCeilToInt
(
sigma
.
y
(
)
*
3
)
)
;
}
