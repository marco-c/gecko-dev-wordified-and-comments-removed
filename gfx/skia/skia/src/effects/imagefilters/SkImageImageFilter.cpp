#
include
"
include
/
effects
/
SkImageFilters
.
h
"
#
include
"
include
/
core
/
SkFlattenable
.
h
"
#
include
"
include
/
core
/
SkImage
.
h
"
#
include
"
include
/
core
/
SkImageFilter
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSamplingOptions
.
h
"
#
include
"
include
/
private
/
base
/
SkAssert
.
h
"
#
include
"
src
/
core
/
SkImageFilterTypes
.
h
"
#
include
"
src
/
core
/
SkImageFilter_Base
.
h
"
#
include
"
src
/
core
/
SkPicturePriv
.
h
"
#
include
"
src
/
core
/
SkReadBuffer
.
h
"
#
include
"
src
/
core
/
SkSamplingPriv
.
h
"
#
include
"
src
/
core
/
SkWriteBuffer
.
h
"
#
include
<
optional
>
#
include
<
utility
>
namespace
{
class
SkImageImageFilter
final
:
public
SkImageFilter_Base
{
public
:
SkImageImageFilter
(
sk_sp
<
SkImage
>
image
const
SkRect
&
srcRect
const
SkRect
&
dstRect
const
SkSamplingOptions
&
sampling
)
:
SkImageFilter_Base
(
nullptr
0
)
fImage
(
std
:
:
move
(
image
)
)
fSrcRect
(
srcRect
)
fDstRect
(
dstRect
)
fSampling
(
sampling
)
{
SkASSERT
(
fImage
&
&
!
dstRect
.
isEmpty
(
)
)
;
}
SkRect
computeFastBounds
(
const
SkRect
&
)
const
override
{
return
SkRect
(
fDstRect
)
;
}
protected
:
void
flatten
(
SkWriteBuffer
&
)
const
override
;
private
:
friend
void
:
:
SkRegisterImageImageFilterFlattenable
(
)
;
SK_FLATTENABLE_HOOKS
(
SkImageImageFilter
)
MatrixCapability
onGetCTMCapability
(
)
const
override
{
return
MatrixCapability
:
:
kComplex
;
}
skif
:
:
FilterResult
onFilterImage
(
const
skif
:
:
Context
&
)
const
override
;
skif
:
:
LayerSpace
<
SkIRect
>
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
override
;
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
override
;
sk_sp
<
SkImage
>
fImage
;
SkRect
fSrcRect
;
skif
:
:
ParameterSpace
<
SkRect
>
fDstRect
;
SkSamplingOptions
fSampling
;
}
;
}
sk_sp
<
SkImageFilter
>
SkImageFilters
:
:
Image
(
sk_sp
<
SkImage
>
image
const
SkRect
&
srcRect
const
SkRect
&
dstRect
const
SkSamplingOptions
&
sampling
)
{
if
(
srcRect
.
isEmpty
(
)
|
|
dstRect
.
isEmpty
(
)
|
|
!
image
)
{
return
SkImageFilters
:
:
Empty
(
)
;
}
else
{
SkRect
imageBounds
=
SkRect
:
:
Make
(
image
-
>
dimensions
(
)
)
;
if
(
imageBounds
.
contains
(
srcRect
)
)
{
return
sk_sp
<
SkImageFilter
>
(
new
SkImageImageFilter
(
std
:
:
move
(
image
)
srcRect
dstRect
sampling
)
)
;
}
else
{
SkMatrix
srcToDst
=
SkMatrix
:
:
RectToRect
(
srcRect
dstRect
)
;
if
(
!
imageBounds
.
intersect
(
srcRect
)
)
{
return
SkImageFilters
:
:
Empty
(
)
;
}
SkRect
mappedBounds
=
srcToDst
.
mapRect
(
imageBounds
)
;
if
(
mappedBounds
.
isEmpty
(
)
)
{
return
SkImageFilters
:
:
Empty
(
)
;
}
return
sk_sp
<
SkImageFilter
>
(
new
SkImageImageFilter
(
std
:
:
move
(
image
)
imageBounds
mappedBounds
sampling
)
)
;
}
}
}
void
SkRegisterImageImageFilterFlattenable
(
)
{
SK_REGISTER_FLATTENABLE
(
SkImageImageFilter
)
;
SkFlattenable
:
:
Register
(
"
SkImageSourceImpl
"
SkImageImageFilter
:
:
CreateProc
)
;
}
sk_sp
<
SkFlattenable
>
SkImageImageFilter
:
:
CreateProc
(
SkReadBuffer
&
buffer
)
{
SkSamplingOptions
sampling
;
if
(
buffer
.
isVersionLT
(
SkPicturePriv
:
:
kImageFilterImageSampling_Version
)
)
{
sampling
=
SkSamplingPriv
:
:
FromFQ
(
buffer
.
checkFilterQuality
(
)
kLinear_SkMediumAs
)
;
}
else
{
sampling
=
buffer
.
readSampling
(
)
;
}
SkRect
src
dst
;
buffer
.
readRect
(
&
src
)
;
buffer
.
readRect
(
&
dst
)
;
sk_sp
<
SkImage
>
image
(
buffer
.
readImage
(
)
)
;
if
(
!
image
)
{
return
nullptr
;
}
return
SkImageFilters
:
:
Image
(
std
:
:
move
(
image
)
src
dst
sampling
)
;
}
void
SkImageImageFilter
:
:
flatten
(
SkWriteBuffer
&
buffer
)
const
{
buffer
.
writeSampling
(
fSampling
)
;
buffer
.
writeRect
(
fSrcRect
)
;
buffer
.
writeRect
(
SkRect
(
fDstRect
)
)
;
buffer
.
writeImage
(
fImage
.
get
(
)
)
;
}
skif
:
:
FilterResult
SkImageImageFilter
:
:
onFilterImage
(
const
skif
:
:
Context
&
ctx
)
const
{
return
skif
:
:
FilterResult
:
:
MakeFromImage
(
ctx
fImage
fSrcRect
fDstRect
fSampling
)
;
}
skif
:
:
LayerSpace
<
SkIRect
>
SkImageImageFilter
:
:
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
const
skif
:
:
LayerSpace
<
SkIRect
>
&
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
)
const
{
return
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Empty
(
)
;
}
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
SkImageImageFilter
:
:
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
)
const
{
return
mapping
.
paramToLayer
(
fDstRect
)
.
roundOut
(
)
;
}
