#
include
"
src
/
effects
/
imagefilters
/
SkMatrixConvolutionImageFilter
.
h
"
#
include
"
include
/
core
/
SkAlphaType
.
h
"
#
include
"
include
/
core
/
SkBitmap
.
h
"
#
include
"
include
/
core
/
SkColorType
.
h
"
#
include
"
include
/
core
/
SkFlattenable
.
h
"
#
include
"
include
/
core
/
SkImage
.
h
"
#
include
"
include
/
core
/
SkImageFilter
.
h
"
#
include
"
include
/
core
/
SkImageInfo
.
h
"
#
include
"
include
/
core
/
SkM44
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSamplingOptions
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkShader
.
h
"
#
include
"
include
/
core
/
SkSize
.
h
"
#
include
"
include
/
core
/
SkTileMode
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
effects
/
SkImageFilters
.
h
"
#
include
"
include
/
effects
/
SkRuntimeEffect
.
h
"
#
include
"
include
/
private
/
base
/
SkMath
.
h
"
#
include
"
include
/
private
/
base
/
SkSpan_impl
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
include
/
private
/
base
/
SkTemplates
.
h
"
#
include
"
src
/
base
/
SkSafeMath
.
h
"
#
include
"
src
/
core
/
SkImageFilterTypes
.
h
"
#
include
"
src
/
core
/
SkImageFilter_Base
.
h
"
#
include
"
src
/
core
/
SkKnownRuntimeEffects
.
h
"
#
include
"
src
/
core
/
SkPicturePriv
.
h
"
#
include
"
src
/
core
/
SkReadBuffer
.
h
"
#
include
"
src
/
core
/
SkRectPriv
.
h
"
#
include
"
src
/
core
/
SkWriteBuffer
.
h
"
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
optional
>
#
include
<
utility
>
using
namespace
skia_private
;
using
namespace
MatrixConvolutionImageFilter
;
namespace
{
static_assert
(
kLargeKernelSize
%
4
=
=
0
"
Must
be
a
multiple
of
4
"
)
;
static_assert
(
kSmallKernelSize
<
=
kLargeKernelSize
"
Small
kernel
size
must
be
<
=
max
size
"
)
;
static_assert
(
kMaxUniformKernelSize
%
4
=
=
0
"
Must
be
a
multiple
of
4
"
)
;
SkBitmap
create_kernel_bitmap
(
const
SkISize
&
kernelSize
const
float
*
kernel
float
*
innerGain
float
*
innerBias
)
;
class
SkMatrixConvolutionImageFilter
final
:
public
SkImageFilter_Base
{
public
:
SkMatrixConvolutionImageFilter
(
const
SkISize
&
kernelSize
const
SkScalar
*
kernel
SkScalar
gain
SkScalar
bias
const
SkIPoint
&
kernelOffset
bool
convolveAlpha
sk_sp
<
SkImageFilter
>
const
*
input
)
:
SkImageFilter_Base
(
input
1
)
fKernel
(
kernel
kernelSize
.
width
(
)
*
kernelSize
.
height
(
)
)
fKernelSize
(
kernelSize
)
fKernelOffset
(
{
kernelOffset
.
fX
kernelOffset
.
fY
}
)
fGain
(
gain
)
fBias
(
bias
)
fConvolveAlpha
(
convolveAlpha
)
{
SkASSERT
(
SkSafeMath
:
:
Mul
(
kernelSize
.
fWidth
kernelSize
.
fHeight
)
<
=
kLargeKernelSize
)
;
SkASSERT
(
kernelSize
.
fWidth
>
=
1
&
&
kernelSize
.
fHeight
>
=
1
)
;
SkASSERT
(
kernelOffset
.
fX
>
=
0
&
&
kernelOffset
.
fX
<
kernelSize
.
fWidth
)
;
SkASSERT
(
kernelOffset
.
fY
>
=
0
&
&
kernelOffset
.
fY
<
kernelSize
.
fHeight
)
;
fKernelBitmap
=
create_kernel_bitmap
(
kernelSize
kernel
&
fInnerGain
&
fInnerBias
)
;
}
SkRect
computeFastBounds
(
const
SkRect
&
bounds
)
const
override
;
protected
:
void
flatten
(
SkWriteBuffer
&
)
const
override
;
private
:
friend
void
:
:
SkRegisterMatrixConvolutionImageFilterFlattenable
(
)
;
SK_FLATTENABLE_HOOKS
(
SkMatrixConvolutionImageFilter
)
bool
onAffectsTransparentBlack
(
)
const
override
{
return
true
;
}
skif
:
:
FilterResult
onFilterImage
(
const
skif
:
:
Context
&
context
)
const
override
;
skif
:
:
LayerSpace
<
SkIRect
>
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
override
;
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
override
;
skif
:
:
LayerSpace
<
SkIRect
>
boundsSampledByKernel
(
const
skif
:
:
LayerSpace
<
SkIRect
>
&
bounds
)
const
;
skif
:
:
LayerSpace
<
SkIRect
>
boundsAffectedByKernel
(
const
skif
:
:
LayerSpace
<
SkIRect
>
&
bounds
)
const
;
sk_sp
<
SkShader
>
createShader
(
const
skif
:
:
Context
&
ctx
sk_sp
<
SkShader
>
input
)
const
;
TArray
<
float
>
fKernel
;
skif
:
:
LayerSpace
<
SkISize
>
fKernelSize
;
skif
:
:
LayerSpace
<
skif
:
:
IVector
>
fKernelOffset
;
float
fGain
;
float
fBias
;
bool
fConvolveAlpha
;
SkBitmap
fKernelBitmap
;
float
fInnerBias
;
float
fInnerGain
;
}
;
skif
:
:
LayerSpace
<
SkIRect
>
adjust
(
const
skif
:
:
LayerSpace
<
SkIRect
>
&
rect
int
dl
int
dt
int
dr
int
db
)
{
SkIRect
adjusted
=
SkIRect
(
rect
)
;
adjusted
.
adjust
(
dl
dt
dr
db
)
;
return
skif
:
:
LayerSpace
<
SkIRect
>
(
adjusted
)
;
}
std
:
:
pair
<
int
SkKnownRuntimeEffects
:
:
StableKey
>
quantize_by_kernel_size
(
int
kernelSize
)
{
if
(
kernelSize
<
kMaxUniformKernelSize
)
{
return
{
kMaxUniformKernelSize
SkKnownRuntimeEffects
:
:
StableKey
:
:
kMatrixConvUniforms
}
;
}
else
if
(
kernelSize
<
=
kSmallKernelSize
)
{
return
{
kSmallKernelSize
SkKnownRuntimeEffects
:
:
StableKey
:
:
kMatrixConvTexSm
}
;
}
return
{
kLargeKernelSize
SkKnownRuntimeEffects
:
:
StableKey
:
:
kMatrixConvTexLg
}
;
}
SkBitmap
create_kernel_bitmap
(
const
SkISize
&
kernelSize
const
float
*
kernel
float
*
innerGain
float
*
innerBias
)
{
int
length
=
kernelSize
.
fWidth
*
kernelSize
.
fHeight
;
auto
[
quantizedKernelSize
key
]
=
quantize_by_kernel_size
(
length
)
;
if
(
key
=
=
SkKnownRuntimeEffects
:
:
StableKey
:
:
kMatrixConvUniforms
)
{
*
innerGain
=
1
.
f
;
*
innerBias
=
0
.
f
;
return
{
}
;
}
float
min
=
kernel
[
0
]
;
float
max
=
kernel
[
0
]
;
for
(
int
i
=
1
;
i
<
length
;
+
+
i
)
{
if
(
kernel
[
i
]
<
min
)
{
min
=
kernel
[
i
]
;
}
if
(
kernel
[
i
]
>
max
)
{
max
=
kernel
[
i
]
;
}
}
*
innerGain
=
max
-
min
;
*
innerBias
=
min
;
if
(
SkScalarNearlyZero
(
*
innerGain
)
)
{
*
innerGain
=
1
.
f
;
}
SkBitmap
kernelBM
;
if
(
!
kernelBM
.
tryAllocPixels
(
SkImageInfo
:
:
Make
(
{
quantizedKernelSize
1
}
kAlpha_8_SkColorType
kPremul_SkAlphaType
)
)
)
{
return
{
}
;
}
for
(
int
i
=
0
;
i
<
length
;
+
+
i
)
{
*
kernelBM
.
getAddr8
(
i
0
)
=
SkScalarRoundToInt
(
255
*
(
kernel
[
i
]
-
min
)
/
*
innerGain
)
;
}
for
(
int
i
=
length
;
i
<
quantizedKernelSize
;
+
+
i
)
{
*
kernelBM
.
getAddr8
(
i
0
)
=
0
;
}
kernelBM
.
setImmutable
(
)
;
return
kernelBM
;
}
}
sk_sp
<
SkImageFilter
>
SkImageFilters
:
:
MatrixConvolution
(
const
SkISize
&
kernelSize
const
SkScalar
kernel
[
]
SkScalar
gain
SkScalar
bias
const
SkIPoint
&
kernelOffset
SkTileMode
tileMode
bool
convolveAlpha
sk_sp
<
SkImageFilter
>
input
const
CropRect
&
cropRect
)
{
if
(
kernelSize
.
width
(
)
<
1
|
|
kernelSize
.
height
(
)
<
1
)
{
return
nullptr
;
}
if
(
SkSafeMath
:
:
Mul
(
kernelSize
.
width
(
)
kernelSize
.
height
(
)
)
>
kLargeKernelSize
)
{
return
nullptr
;
}
if
(
!
kernel
)
{
return
nullptr
;
}
if
(
(
kernelOffset
.
fX
<
0
)
|
|
(
kernelOffset
.
fX
>
=
kernelSize
.
fWidth
)
|
|
(
kernelOffset
.
fY
<
0
)
|
|
(
kernelOffset
.
fY
>
=
kernelSize
.
fHeight
)
)
{
return
nullptr
;
}
sk_sp
<
SkImageFilter
>
filter
=
std
:
:
move
(
input
)
;
if
(
cropRect
&
&
tileMode
!
=
SkTileMode
:
:
kDecal
)
{
filter
=
SkImageFilters
:
:
Crop
(
*
cropRect
tileMode
std
:
:
move
(
filter
)
)
;
}
filter
=
sk_sp
<
SkImageFilter
>
(
new
SkMatrixConvolutionImageFilter
(
kernelSize
kernel
gain
bias
kernelOffset
convolveAlpha
&
filter
)
)
;
if
(
cropRect
)
{
filter
=
SkImageFilters
:
:
Crop
(
*
cropRect
SkTileMode
:
:
kDecal
std
:
:
move
(
filter
)
)
;
}
return
filter
;
}
void
SkRegisterMatrixConvolutionImageFilterFlattenable
(
)
{
SK_REGISTER_FLATTENABLE
(
SkMatrixConvolutionImageFilter
)
;
SkFlattenable
:
:
Register
(
"
SkMatrixConvolutionImageFilterImpl
"
SkMatrixConvolutionImageFilter
:
:
CreateProc
)
;
}
sk_sp
<
SkFlattenable
>
SkMatrixConvolutionImageFilter
:
:
CreateProc
(
SkReadBuffer
&
buffer
)
{
SK_IMAGEFILTER_UNFLATTEN_COMMON
(
common
1
)
;
SkISize
kernelSize
;
kernelSize
.
fWidth
=
buffer
.
readInt
(
)
;
kernelSize
.
fHeight
=
buffer
.
readInt
(
)
;
const
int
count
=
buffer
.
getArrayCount
(
)
;
const
int64_t
kernelArea
=
sk_64_mul
(
kernelSize
.
width
(
)
kernelSize
.
height
(
)
)
;
if
(
!
buffer
.
validate
(
kernelArea
=
=
count
)
)
{
return
nullptr
;
}
if
(
!
buffer
.
validateCanReadN
<
SkScalar
>
(
count
)
)
{
return
nullptr
;
}
AutoSTArray
<
16
SkScalar
>
kernel
(
count
)
;
if
(
!
buffer
.
readScalarArray
(
kernel
.
get
(
)
count
)
)
{
return
nullptr
;
}
SkScalar
gain
=
buffer
.
readScalar
(
)
;
SkScalar
bias
=
buffer
.
readScalar
(
)
;
SkIPoint
kernelOffset
;
kernelOffset
.
fX
=
buffer
.
readInt
(
)
;
kernelOffset
.
fY
=
buffer
.
readInt
(
)
;
SkTileMode
tileMode
=
SkTileMode
:
:
kDecal
;
if
(
buffer
.
isVersionLT
(
SkPicturePriv
:
:
kConvolutionImageFilterTilingUpdate
)
)
{
tileMode
=
buffer
.
read32LE
(
SkTileMode
:
:
kLastTileMode
)
;
}
bool
convolveAlpha
=
buffer
.
readBool
(
)
;
if
(
!
buffer
.
isValid
(
)
)
{
return
nullptr
;
}
return
SkImageFilters
:
:
MatrixConvolution
(
kernelSize
kernel
.
get
(
)
gain
bias
kernelOffset
tileMode
convolveAlpha
common
.
getInput
(
0
)
common
.
cropRect
(
)
)
;
}
void
SkMatrixConvolutionImageFilter
:
:
flatten
(
SkWriteBuffer
&
buffer
)
const
{
this
-
>
SkImageFilter_Base
:
:
flatten
(
buffer
)
;
buffer
.
writeInt
(
fKernelSize
.
width
(
)
)
;
buffer
.
writeInt
(
fKernelSize
.
height
(
)
)
;
buffer
.
writeScalarArray
(
fKernel
.
data
(
)
fKernel
.
size
(
)
)
;
buffer
.
writeScalar
(
fGain
)
;
buffer
.
writeScalar
(
fBias
)
;
buffer
.
writeInt
(
fKernelOffset
.
x
(
)
)
;
buffer
.
writeInt
(
fKernelOffset
.
y
(
)
)
;
buffer
.
writeBool
(
fConvolveAlpha
)
;
}
skif
:
:
LayerSpace
<
SkIRect
>
SkMatrixConvolutionImageFilter
:
:
boundsSampledByKernel
(
const
skif
:
:
LayerSpace
<
SkIRect
>
&
bounds
)
const
{
return
adjust
(
bounds
-
fKernelOffset
.
x
(
)
-
fKernelOffset
.
y
(
)
fKernelSize
.
width
(
)
-
fKernelOffset
.
x
(
)
-
1
fKernelSize
.
height
(
)
-
fKernelOffset
.
y
(
)
-
1
)
;
}
skif
:
:
LayerSpace
<
SkIRect
>
SkMatrixConvolutionImageFilter
:
:
boundsAffectedByKernel
(
const
skif
:
:
LayerSpace
<
SkIRect
>
&
bounds
)
const
{
return
adjust
(
bounds
fKernelOffset
.
x
(
)
-
fKernelSize
.
width
(
)
+
1
fKernelOffset
.
y
(
)
-
fKernelSize
.
height
(
)
+
1
fKernelOffset
.
x
(
)
fKernelOffset
.
y
(
)
)
;
}
sk_sp
<
SkShader
>
SkMatrixConvolutionImageFilter
:
:
createShader
(
const
skif
:
:
Context
&
ctx
sk_sp
<
SkShader
>
input
)
const
{
const
int
kernelLength
=
fKernelSize
.
width
(
)
*
fKernelSize
.
height
(
)
;
auto
[
_
key
]
=
quantize_by_kernel_size
(
kernelLength
)
;
const
bool
useTextureShader
=
(
key
!
=
SkKnownRuntimeEffects
:
:
StableKey
:
:
kMatrixConvUniforms
)
;
if
(
useTextureShader
&
&
fKernelBitmap
.
empty
(
)
)
{
return
nullptr
;
}
const
SkRuntimeEffect
*
matrixConvEffect
=
GetKnownRuntimeEffect
(
key
)
;
SkRuntimeShaderBuilder
builder
(
sk_ref_sp
(
matrixConvEffect
)
)
;
builder
.
child
(
"
child
"
)
=
std
:
:
move
(
input
)
;
if
(
useTextureShader
)
{
sk_sp
<
SkImage
>
cachedKernel
=
ctx
.
backend
(
)
-
>
getCachedBitmap
(
fKernelBitmap
)
;
if
(
!
cachedKernel
)
{
return
nullptr
;
}
builder
.
child
(
"
kernel
"
)
=
cachedKernel
-
>
makeRawShader
(
SkFilterMode
:
:
kNearest
)
;
builder
.
uniform
(
"
innerGainAndBias
"
)
=
SkV2
{
fInnerGain
fInnerBias
}
;
}
else
{
float
paddedKernel
[
kMaxUniformKernelSize
]
;
memcpy
(
paddedKernel
fKernel
.
data
(
)
kernelLength
*
sizeof
(
float
)
)
;
memset
(
paddedKernel
+
kernelLength
0
(
kMaxUniformKernelSize
-
kernelLength
)
*
sizeof
(
float
)
)
;
builder
.
uniform
(
"
kernel
"
)
.
set
(
paddedKernel
kMaxUniformKernelSize
)
;
}
builder
.
uniform
(
"
size
"
)
=
SkISize
(
fKernelSize
)
;
builder
.
uniform
(
"
offset
"
)
=
skif
:
:
IVector
(
fKernelOffset
)
;
builder
.
uniform
(
"
gainAndBias
"
)
=
SkV2
{
fGain
fBias
/
255
.
f
}
;
builder
.
uniform
(
"
convolveAlpha
"
)
=
fConvolveAlpha
?
1
:
0
;
return
builder
.
makeShader
(
)
;
}
skif
:
:
FilterResult
SkMatrixConvolutionImageFilter
:
:
onFilterImage
(
const
skif
:
:
Context
&
context
)
const
{
using
ShaderFlags
=
skif
:
:
FilterResult
:
:
ShaderFlags
;
skif
:
:
LayerSpace
<
SkIRect
>
requiredInput
=
this
-
>
boundsSampledByKernel
(
context
.
desiredOutput
(
)
)
;
skif
:
:
FilterResult
childOutput
=
this
-
>
getChildOutput
(
0
context
.
withNewDesiredOutput
(
requiredInput
)
)
;
skif
:
:
LayerSpace
<
SkIRect
>
outputBounds
;
if
(
fConvolveAlpha
&
&
fBias
!
=
0
.
f
)
{
outputBounds
=
context
.
desiredOutput
(
)
;
}
else
{
outputBounds
=
this
-
>
boundsAffectedByKernel
(
childOutput
.
layerBounds
(
)
)
;
if
(
!
outputBounds
.
intersect
(
context
.
desiredOutput
(
)
)
)
{
return
{
}
;
}
}
skif
:
:
FilterResult
:
:
Builder
builder
{
context
}
;
builder
.
add
(
childOutput
this
-
>
boundsSampledByKernel
(
outputBounds
)
ShaderFlags
:
:
kSampledRepeatedly
)
;
return
builder
.
eval
(
[
&
]
(
SkSpan
<
sk_sp
<
SkShader
>
>
inputs
)
{
return
this
-
>
createShader
(
context
inputs
[
0
]
)
;
}
outputBounds
)
;
}
skif
:
:
LayerSpace
<
SkIRect
>
SkMatrixConvolutionImageFilter
:
:
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
{
skif
:
:
LayerSpace
<
SkIRect
>
requiredInput
=
this
-
>
boundsSampledByKernel
(
desiredOutput
)
;
return
this
-
>
getChildInputLayerBounds
(
0
mapping
requiredInput
contentBounds
)
;
}
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
SkMatrixConvolutionImageFilter
:
:
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
{
if
(
fConvolveAlpha
&
&
fBias
!
=
0
.
f
)
{
return
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Unbounded
(
)
;
}
auto
outputBounds
=
this
-
>
getChildOutputLayerBounds
(
0
mapping
contentBounds
)
;
if
(
outputBounds
)
{
return
this
-
>
boundsAffectedByKernel
(
*
outputBounds
)
;
}
else
{
return
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Unbounded
(
)
;
}
}
SkRect
SkMatrixConvolutionImageFilter
:
:
computeFastBounds
(
const
SkRect
&
bounds
)
const
{
return
SkRectPriv
:
:
MakeLargeS32
(
)
;
}
