#
include
"
include
/
effects
/
SkImageFilters
.
h
"
#
include
"
include
/
core
/
SkAlphaType
.
h
"
#
include
"
include
/
core
/
SkBitmap
.
h
"
#
include
"
include
/
core
/
SkColorType
.
h
"
#
include
"
include
/
core
/
SkFlattenable
.
h
"
#
include
"
include
/
core
/
SkImage
.
h
"
#
include
"
include
/
core
/
SkImageFilter
.
h
"
#
include
"
include
/
core
/
SkImageInfo
.
h
"
#
include
"
include
/
core
/
SkM44
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSamplingOptions
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkShader
.
h
"
#
include
"
include
/
core
/
SkSize
.
h
"
#
include
"
include
/
core
/
SkString
.
h
"
#
include
"
include
/
core
/
SkTileMode
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
effects
/
SkRuntimeEffect
.
h
"
#
include
"
include
/
private
/
base
/
SkMath
.
h
"
#
include
"
include
/
private
/
base
/
SkMutex
.
h
"
#
include
"
include
/
private
/
base
/
SkSpan_impl
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
include
/
private
/
base
/
SkTemplates
.
h
"
#
include
"
include
/
private
/
base
/
SkThreadAnnotations
.
h
"
#
include
"
src
/
base
/
SkMathPriv
.
h
"
#
include
"
src
/
base
/
SkSafeMath
.
h
"
#
include
"
src
/
core
/
SkImageFilterTypes
.
h
"
#
include
"
src
/
core
/
SkImageFilter_Base
.
h
"
#
include
"
src
/
core
/
SkLRUCache
.
h
"
#
include
"
src
/
core
/
SkPicturePriv
.
h
"
#
include
"
src
/
core
/
SkReadBuffer
.
h
"
#
include
"
src
/
core
/
SkRectPriv
.
h
"
#
include
"
src
/
core
/
SkRuntimeEffectPriv
.
h
"
#
include
"
src
/
core
/
SkWriteBuffer
.
h
"
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
optional
>
#
include
<
utility
>
using
namespace
skia_private
;
namespace
{
static
constexpr
int
kMaxKernelSize
=
256
;
static
constexpr
int
kMaxUniformKernelSize
=
28
;
SkBitmap
create_kernel_bitmap
(
const
SkISize
&
kernelSize
const
float
*
kernel
float
*
innerGain
float
*
innerBias
)
;
class
SkMatrixConvolutionImageFilter
final
:
public
SkImageFilter_Base
{
public
:
SkMatrixConvolutionImageFilter
(
const
SkISize
&
kernelSize
const
SkScalar
*
kernel
SkScalar
gain
SkScalar
bias
const
SkIPoint
&
kernelOffset
bool
convolveAlpha
sk_sp
<
SkImageFilter
>
const
*
input
)
:
SkImageFilter_Base
(
input
1
)
fKernel
(
kernel
kernelSize
.
width
(
)
*
kernelSize
.
height
(
)
)
fKernelSize
(
kernelSize
)
fKernelOffset
(
{
kernelOffset
.
fX
kernelOffset
.
fY
}
)
fGain
(
gain
)
fBias
(
bias
)
fConvolveAlpha
(
convolveAlpha
)
{
SkASSERT
(
SkSafeMath
:
:
Mul
(
kernelSize
.
fWidth
kernelSize
.
fHeight
)
<
=
kMaxKernelSize
)
;
SkASSERT
(
kernelSize
.
fWidth
>
=
1
&
&
kernelSize
.
fHeight
>
=
1
)
;
SkASSERT
(
kernelOffset
.
fX
>
=
0
&
&
kernelOffset
.
fX
<
kernelSize
.
fWidth
)
;
SkASSERT
(
kernelOffset
.
fY
>
=
0
&
&
kernelOffset
.
fY
<
kernelSize
.
fHeight
)
;
fKernelBitmap
=
create_kernel_bitmap
(
kernelSize
kernel
&
fInnerGain
&
fInnerBias
)
;
}
SkRect
computeFastBounds
(
const
SkRect
&
bounds
)
const
override
;
protected
:
void
flatten
(
SkWriteBuffer
&
)
const
override
;
private
:
friend
void
:
:
SkRegisterMatrixConvolutionImageFilterFlattenable
(
)
;
SK_FLATTENABLE_HOOKS
(
SkMatrixConvolutionImageFilter
)
bool
onAffectsTransparentBlack
(
)
const
override
{
return
true
;
}
skif
:
:
FilterResult
onFilterImage
(
const
skif
:
:
Context
&
context
)
const
override
;
skif
:
:
LayerSpace
<
SkIRect
>
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
override
;
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
override
;
skif
:
:
LayerSpace
<
SkIRect
>
boundsSampledByKernel
(
const
skif
:
:
LayerSpace
<
SkIRect
>
&
bounds
)
const
;
skif
:
:
LayerSpace
<
SkIRect
>
boundsAffectedByKernel
(
const
skif
:
:
LayerSpace
<
SkIRect
>
&
bounds
)
const
;
sk_sp
<
SkShader
>
createShader
(
const
skif
:
:
Context
&
ctx
sk_sp
<
SkShader
>
input
)
const
;
TArray
<
float
>
fKernel
;
skif
:
:
LayerSpace
<
SkISize
>
fKernelSize
;
skif
:
:
LayerSpace
<
skif
:
:
IVector
>
fKernelOffset
;
float
fGain
;
float
fBias
;
bool
fConvolveAlpha
;
SkBitmap
fKernelBitmap
;
float
fInnerBias
;
float
fInnerGain
;
}
;
skif
:
:
LayerSpace
<
SkIRect
>
adjust
(
const
skif
:
:
LayerSpace
<
SkIRect
>
&
rect
int
dl
int
dt
int
dr
int
db
)
{
SkIRect
adjusted
=
SkIRect
(
rect
)
;
adjusted
.
adjust
(
dl
dt
dr
db
)
;
return
skif
:
:
LayerSpace
<
SkIRect
>
(
adjusted
)
;
}
SkBitmap
create_kernel_bitmap
(
const
SkISize
&
kernelSize
const
float
*
kernel
float
*
innerGain
float
*
innerBias
)
{
int
length
=
kernelSize
.
fWidth
*
kernelSize
.
fHeight
;
if
(
length
<
=
kMaxUniformKernelSize
)
{
*
innerGain
=
1
.
f
;
*
innerBias
=
0
.
f
;
return
{
}
;
}
float
min
=
kernel
[
0
]
;
float
max
=
kernel
[
0
]
;
for
(
int
i
=
1
;
i
<
length
;
+
+
i
)
{
if
(
kernel
[
i
]
<
min
)
{
min
=
kernel
[
i
]
;
}
if
(
kernel
[
i
]
>
max
)
{
max
=
kernel
[
i
]
;
}
}
*
innerGain
=
max
-
min
;
*
innerBias
=
min
;
if
(
SkScalarNearlyZero
(
*
innerGain
)
)
{
*
innerGain
=
1
.
f
;
}
SkBitmap
kernelBM
;
if
(
!
kernelBM
.
tryAllocPixels
(
SkImageInfo
:
:
Make
(
kernelSize
kAlpha_8_SkColorType
kPremul_SkAlphaType
)
)
)
{
return
{
}
;
}
for
(
int
y
=
0
;
y
<
kernelSize
.
fHeight
;
+
+
y
)
{
for
(
int
x
=
0
;
x
<
kernelSize
.
fWidth
;
+
+
x
)
{
int
i
=
y
*
kernelSize
.
fWidth
+
x
;
*
kernelBM
.
getAddr8
(
x
y
)
=
SkScalarRoundToInt
(
255
*
(
kernel
[
i
]
-
min
)
/
*
innerGain
)
;
}
}
kernelBM
.
setImmutable
(
)
;
return
kernelBM
;
}
}
sk_sp
<
SkImageFilter
>
SkImageFilters
:
:
MatrixConvolution
(
const
SkISize
&
kernelSize
const
SkScalar
kernel
[
]
SkScalar
gain
SkScalar
bias
const
SkIPoint
&
kernelOffset
SkTileMode
tileMode
bool
convolveAlpha
sk_sp
<
SkImageFilter
>
input
const
CropRect
&
cropRect
)
{
if
(
kernelSize
.
width
(
)
<
1
|
|
kernelSize
.
height
(
)
<
1
)
{
return
nullptr
;
}
if
(
SkSafeMath
:
:
Mul
(
kernelSize
.
width
(
)
kernelSize
.
height
(
)
)
>
kMaxKernelSize
)
{
return
nullptr
;
}
if
(
!
kernel
)
{
return
nullptr
;
}
if
(
(
kernelOffset
.
fX
<
0
)
|
|
(
kernelOffset
.
fX
>
=
kernelSize
.
fWidth
)
|
|
(
kernelOffset
.
fY
<
0
)
|
|
(
kernelOffset
.
fY
>
=
kernelSize
.
fHeight
)
)
{
return
nullptr
;
}
sk_sp
<
SkImageFilter
>
filter
=
std
:
:
move
(
input
)
;
if
(
cropRect
&
&
tileMode
!
=
SkTileMode
:
:
kDecal
)
{
filter
=
SkImageFilters
:
:
Crop
(
*
cropRect
tileMode
std
:
:
move
(
filter
)
)
;
}
filter
=
sk_sp
<
SkImageFilter
>
(
new
SkMatrixConvolutionImageFilter
(
kernelSize
kernel
gain
bias
kernelOffset
convolveAlpha
&
filter
)
)
;
if
(
cropRect
)
{
filter
=
SkImageFilters
:
:
Crop
(
*
cropRect
SkTileMode
:
:
kDecal
std
:
:
move
(
filter
)
)
;
}
return
filter
;
}
void
SkRegisterMatrixConvolutionImageFilterFlattenable
(
)
{
SK_REGISTER_FLATTENABLE
(
SkMatrixConvolutionImageFilter
)
;
SkFlattenable
:
:
Register
(
"
SkMatrixConvolutionImageFilterImpl
"
SkMatrixConvolutionImageFilter
:
:
CreateProc
)
;
}
sk_sp
<
SkFlattenable
>
SkMatrixConvolutionImageFilter
:
:
CreateProc
(
SkReadBuffer
&
buffer
)
{
SK_IMAGEFILTER_UNFLATTEN_COMMON
(
common
1
)
;
SkISize
kernelSize
;
kernelSize
.
fWidth
=
buffer
.
readInt
(
)
;
kernelSize
.
fHeight
=
buffer
.
readInt
(
)
;
const
int
count
=
buffer
.
getArrayCount
(
)
;
const
int64_t
kernelArea
=
sk_64_mul
(
kernelSize
.
width
(
)
kernelSize
.
height
(
)
)
;
if
(
!
buffer
.
validate
(
kernelArea
=
=
count
)
)
{
return
nullptr
;
}
if
(
!
buffer
.
validateCanReadN
<
SkScalar
>
(
count
)
)
{
return
nullptr
;
}
AutoSTArray
<
16
SkScalar
>
kernel
(
count
)
;
if
(
!
buffer
.
readScalarArray
(
kernel
.
get
(
)
count
)
)
{
return
nullptr
;
}
SkScalar
gain
=
buffer
.
readScalar
(
)
;
SkScalar
bias
=
buffer
.
readScalar
(
)
;
SkIPoint
kernelOffset
;
kernelOffset
.
fX
=
buffer
.
readInt
(
)
;
kernelOffset
.
fY
=
buffer
.
readInt
(
)
;
SkTileMode
tileMode
=
SkTileMode
:
:
kDecal
;
if
(
buffer
.
isVersionLT
(
SkPicturePriv
:
:
kConvolutionImageFilterTilingUpdate
)
)
{
tileMode
=
buffer
.
read32LE
(
SkTileMode
:
:
kLastTileMode
)
;
}
bool
convolveAlpha
=
buffer
.
readBool
(
)
;
if
(
!
buffer
.
isValid
(
)
)
{
return
nullptr
;
}
return
SkImageFilters
:
:
MatrixConvolution
(
kernelSize
kernel
.
get
(
)
gain
bias
kernelOffset
tileMode
convolveAlpha
common
.
getInput
(
0
)
common
.
cropRect
(
)
)
;
}
void
SkMatrixConvolutionImageFilter
:
:
flatten
(
SkWriteBuffer
&
buffer
)
const
{
this
-
>
SkImageFilter_Base
:
:
flatten
(
buffer
)
;
buffer
.
writeInt
(
fKernelSize
.
width
(
)
)
;
buffer
.
writeInt
(
fKernelSize
.
height
(
)
)
;
buffer
.
writeScalarArray
(
fKernel
.
data
(
)
fKernel
.
size
(
)
)
;
buffer
.
writeScalar
(
fGain
)
;
buffer
.
writeScalar
(
fBias
)
;
buffer
.
writeInt
(
fKernelOffset
.
x
(
)
)
;
buffer
.
writeInt
(
fKernelOffset
.
y
(
)
)
;
buffer
.
writeBool
(
fConvolveAlpha
)
;
}
skif
:
:
LayerSpace
<
SkIRect
>
SkMatrixConvolutionImageFilter
:
:
boundsSampledByKernel
(
const
skif
:
:
LayerSpace
<
SkIRect
>
&
bounds
)
const
{
return
adjust
(
bounds
-
fKernelOffset
.
x
(
)
-
fKernelOffset
.
y
(
)
fKernelSize
.
width
(
)
-
fKernelOffset
.
x
(
)
-
1
fKernelSize
.
height
(
)
-
fKernelOffset
.
y
(
)
-
1
)
;
}
skif
:
:
LayerSpace
<
SkIRect
>
SkMatrixConvolutionImageFilter
:
:
boundsAffectedByKernel
(
const
skif
:
:
LayerSpace
<
SkIRect
>
&
bounds
)
const
{
return
adjust
(
bounds
fKernelOffset
.
x
(
)
-
fKernelSize
.
width
(
)
+
1
fKernelOffset
.
y
(
)
-
fKernelSize
.
height
(
)
+
1
fKernelOffset
.
x
(
)
fKernelOffset
.
y
(
)
)
;
}
static
sk_sp
<
SkRuntimeEffect
>
get_runtime_effect
(
int
texWidth
int
texHeight
)
{
static
const
char
*
kHeaderSkSL
=
"
uniform
int2
size
;
"
"
uniform
int2
offset
;
"
"
uniform
half2
gainAndBias
;
"
"
uniform
int
convolveAlpha
;
"
"
uniform
shader
child
;
"
"
half4
main
(
float2
coord
)
{
"
"
half4
sum
=
half4
(
0
)
;
"
"
half
origAlpha
=
0
;
"
;
static
const
char
*
kAccumulateSkSL
=
"
half4
c
=
child
.
eval
(
coord
+
half2
(
kernelPos
)
-
half2
(
offset
)
)
;
"
"
if
(
convolveAlpha
=
=
0
)
{
"
"
if
(
kernelPos
=
=
offset
)
{
"
"
origAlpha
=
c
.
a
;
"
"
}
"
"
c
=
unpremul
(
c
)
;
"
"
}
"
"
sum
+
=
c
*
k
;
"
;
static
const
char
*
kFooterSkSL
=
"
half4
color
=
sum
*
gainAndBias
.
x
+
gainAndBias
.
y
;
"
"
if
(
convolveAlpha
=
=
0
)
{
"
"
color
=
half4
(
color
.
rgb
*
origAlpha
origAlpha
)
;
"
"
}
else
{
"
"
color
.
a
=
saturate
(
color
.
a
)
;
"
"
}
"
"
color
.
rgb
=
clamp
(
color
.
rgb
0
color
.
a
)
;
"
"
return
color
;
"
"
}
"
;
static_assert
(
kMaxUniformKernelSize
%
4
=
=
0
"
Must
be
a
multiple
of
4
"
)
;
static
SkRuntimeEffect
*
uniformEffect
=
SkMakeRuntimeEffect
(
SkRuntimeEffect
:
:
MakeForShader
SkStringPrintf
(
"
const
int
kMaxUniformKernelSize
=
%
d
/
4
;
"
"
uniform
half4
kernel
[
kMaxUniformKernelSize
]
;
"
"
%
s
"
"
int2
kernelPos
=
int2
(
0
)
;
"
"
for
(
int
i
=
0
;
i
<
kMaxUniformKernelSize
;
+
+
i
)
{
"
"
if
(
kernelPos
.
y
>
=
size
.
y
)
{
break
;
}
"
"
half4
k4
=
kernel
[
i
]
;
"
"
for
(
int
j
=
0
;
j
<
4
;
+
+
j
)
{
"
"
if
(
kernelPos
.
y
>
=
size
.
y
)
{
break
;
}
"
"
half
k
=
k4
[
j
]
;
"
"
%
s
"
"
kernelPos
.
x
+
=
1
;
"
"
if
(
kernelPos
.
x
>
=
size
.
x
)
{
"
"
kernelPos
.
x
=
0
;
"
"
kernelPos
.
y
+
=
1
;
"
"
}
"
"
}
"
"
}
"
"
%
s
"
kMaxUniformKernelSize
kHeaderSkSL
kAccumulateSkSL
kFooterSkSL
)
.
c_str
(
)
)
;
static
SkMutex
cacheLock
;
static
SkLRUCache
<
SkISize
sk_sp
<
SkRuntimeEffect
>
>
textureShaderCache
SK_GUARDED_BY
(
cacheLock
)
{
5
}
;
static
const
auto
makeTextureEffect
=
[
]
(
SkISize
maxKernelSize
)
{
return
SkMakeRuntimeEffect
(
SkRuntimeEffect
:
:
MakeForShader
SkStringPrintf
(
"
const
int
kMaxKernelWidth
=
%
d
;
"
"
const
int
kMaxKernelHeight
=
%
d
;
"
"
uniform
shader
kernel
;
"
"
uniform
half2
innerGainAndBias
;
"
"
%
s
"
"
for
(
int
y
=
0
;
y
<
kMaxKernelHeight
;
+
+
y
)
{
"
"
if
(
y
>
=
size
.
y
)
{
break
;
}
"
"
for
(
int
x
=
0
;
x
<
kMaxKernelWidth
;
+
+
x
)
{
"
"
if
(
x
>
=
size
.
x
)
{
break
;
}
"
"
int2
kernelPos
=
int2
(
x
y
)
;
"
"
half
k
=
kernel
.
eval
(
half2
(
kernelPos
)
+
0
.
5
)
.
a
;
"
"
k
=
k
*
innerGainAndBias
.
x
+
innerGainAndBias
.
y
;
"
"
%
s
"
"
}
"
"
}
"
"
%
s
"
maxKernelSize
.
fWidth
maxKernelSize
.
fHeight
kHeaderSkSL
kAccumulateSkSL
kFooterSkSL
)
.
c_str
(
)
)
;
}
;
if
(
texWidth
=
=
0
&
&
texHeight
=
=
0
)
{
return
sk_ref_sp
(
uniformEffect
)
;
}
else
{
static_assert
(
kMaxKernelSize
%
4
=
=
0
"
Must
be
a
multiple
of
4
"
)
;
SkASSERT
(
SkSafeMath
:
:
Mul
(
texWidth
texHeight
)
<
=
kMaxKernelSize
)
;
const
SkISize
key
=
{
SkNextPow2
(
texWidth
)
SkNextPow2
(
texHeight
)
}
;
SkAutoMutexExclusive
acquire
{
cacheLock
}
;
sk_sp
<
SkRuntimeEffect
>
*
effect
=
textureShaderCache
.
find
(
key
)
;
if
(
!
effect
)
{
sk_sp
<
SkRuntimeEffect
>
newEffect
{
makeTextureEffect
(
key
)
}
;
effect
=
textureShaderCache
.
insert
(
key
std
:
:
move
(
newEffect
)
)
;
}
return
*
effect
;
}
}
sk_sp
<
SkShader
>
SkMatrixConvolutionImageFilter
:
:
createShader
(
const
skif
:
:
Context
&
ctx
sk_sp
<
SkShader
>
input
)
const
{
const
int
kernelLength
=
fKernelSize
.
width
(
)
*
fKernelSize
.
height
(
)
;
const
bool
useTextureShader
=
kernelLength
>
kMaxUniformKernelSize
;
if
(
useTextureShader
&
&
fKernelBitmap
.
empty
(
)
)
{
return
nullptr
;
}
auto
effect
=
get_runtime_effect
(
useTextureShader
?
fKernelSize
.
width
(
)
:
0
useTextureShader
?
fKernelSize
.
height
(
)
:
0
)
;
SkRuntimeShaderBuilder
builder
(
std
:
:
move
(
effect
)
)
;
builder
.
child
(
"
child
"
)
=
std
:
:
move
(
input
)
;
if
(
useTextureShader
)
{
sk_sp
<
SkImage
>
cachedKernel
=
ctx
.
backend
(
)
-
>
getCachedBitmap
(
fKernelBitmap
)
;
if
(
!
cachedKernel
)
{
return
nullptr
;
}
builder
.
child
(
"
kernel
"
)
=
cachedKernel
-
>
makeRawShader
(
SkFilterMode
:
:
kNearest
)
;
builder
.
uniform
(
"
innerGainAndBias
"
)
=
SkV2
{
fInnerGain
fInnerBias
}
;
}
else
{
float
paddedKernel
[
kMaxUniformKernelSize
]
;
memcpy
(
paddedKernel
fKernel
.
data
(
)
kernelLength
*
sizeof
(
float
)
)
;
memset
(
paddedKernel
+
kernelLength
0
(
kMaxUniformKernelSize
-
kernelLength
)
*
sizeof
(
float
)
)
;
builder
.
uniform
(
"
kernel
"
)
.
set
(
paddedKernel
kMaxUniformKernelSize
)
;
}
builder
.
uniform
(
"
size
"
)
=
SkISize
(
fKernelSize
)
;
builder
.
uniform
(
"
offset
"
)
=
skif
:
:
IVector
(
fKernelOffset
)
;
builder
.
uniform
(
"
gainAndBias
"
)
=
SkV2
{
fGain
fBias
/
255
.
f
}
;
builder
.
uniform
(
"
convolveAlpha
"
)
=
fConvolveAlpha
?
1
:
0
;
return
builder
.
makeShader
(
)
;
}
skif
:
:
FilterResult
SkMatrixConvolutionImageFilter
:
:
onFilterImage
(
const
skif
:
:
Context
&
context
)
const
{
using
ShaderFlags
=
skif
:
:
FilterResult
:
:
ShaderFlags
;
skif
:
:
LayerSpace
<
SkIRect
>
requiredInput
=
this
-
>
boundsSampledByKernel
(
context
.
desiredOutput
(
)
)
;
skif
:
:
FilterResult
childOutput
=
this
-
>
getChildOutput
(
0
context
.
withNewDesiredOutput
(
requiredInput
)
)
;
skif
:
:
LayerSpace
<
SkIRect
>
outputBounds
;
if
(
fConvolveAlpha
&
&
fBias
!
=
0
.
f
)
{
outputBounds
=
context
.
desiredOutput
(
)
;
}
else
{
outputBounds
=
this
-
>
boundsAffectedByKernel
(
childOutput
.
layerBounds
(
)
)
;
if
(
!
outputBounds
.
intersect
(
context
.
desiredOutput
(
)
)
)
{
return
{
}
;
}
}
skif
:
:
FilterResult
:
:
Builder
builder
{
context
}
;
builder
.
add
(
childOutput
this
-
>
boundsSampledByKernel
(
outputBounds
)
ShaderFlags
:
:
kSampledRepeatedly
)
;
return
builder
.
eval
(
[
&
]
(
SkSpan
<
sk_sp
<
SkShader
>
>
inputs
)
{
return
this
-
>
createShader
(
context
inputs
[
0
]
)
;
}
outputBounds
)
;
}
skif
:
:
LayerSpace
<
SkIRect
>
SkMatrixConvolutionImageFilter
:
:
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
{
skif
:
:
LayerSpace
<
SkIRect
>
requiredInput
=
this
-
>
boundsSampledByKernel
(
desiredOutput
)
;
return
this
-
>
getChildInputLayerBounds
(
0
mapping
requiredInput
contentBounds
)
;
}
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
SkMatrixConvolutionImageFilter
:
:
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
{
if
(
fConvolveAlpha
&
&
fBias
!
=
0
.
f
)
{
return
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Unbounded
(
)
;
}
auto
outputBounds
=
this
-
>
getChildOutputLayerBounds
(
0
mapping
contentBounds
)
;
if
(
outputBounds
)
{
return
this
-
>
boundsAffectedByKernel
(
*
outputBounds
)
;
}
else
{
return
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Unbounded
(
)
;
}
}
SkRect
SkMatrixConvolutionImageFilter
:
:
computeFastBounds
(
const
SkRect
&
bounds
)
const
{
return
SkRectPriv
:
:
MakeLargeS32
(
)
;
}
