#
include
"
include
/
effects
/
SkImageFilters
.
h
"
#
include
"
include
/
core
/
SkBlendMode
.
h
"
#
include
"
include
/
core
/
SkColor
.
h
"
#
include
"
include
/
core
/
SkColorFilter
.
h
"
#
include
"
include
/
core
/
SkColorSpace
.
h
"
#
include
"
include
/
core
/
SkFlattenable
.
h
"
#
include
"
include
/
core
/
SkImageFilter
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSamplingOptions
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkSize
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
src
/
core
/
SkImageFilter_Base
.
h
"
#
include
"
src
/
core
/
SkPicturePriv
.
h
"
#
include
"
src
/
core
/
SkReadBuffer
.
h
"
#
include
<
optional
>
#
include
<
utility
>
struct
SkRect
;
namespace
{
static
sk_sp
<
SkImageFilter
>
make_drop_shadow_graph
(
SkVector
offset
SkSize
sigma
SkColor4f
color
sk_sp
<
SkColorSpace
>
colorSpace
bool
shadowOnly
sk_sp
<
SkImageFilter
>
input
const
std
:
:
optional
<
SkRect
>
&
crop
)
{
sk_sp
<
SkImageFilter
>
filter
=
input
;
filter
=
SkImageFilters
:
:
Blur
(
sigma
.
fWidth
sigma
.
fHeight
std
:
:
move
(
filter
)
)
;
filter
=
SkImageFilters
:
:
ColorFilter
(
SkColorFilters
:
:
Blend
(
color
std
:
:
move
(
colorSpace
)
SkBlendMode
:
:
kSrcIn
)
std
:
:
move
(
filter
)
)
;
filter
=
SkImageFilters
:
:
MatrixTransform
(
SkMatrix
:
:
Translate
(
offset
.
fX
offset
.
fY
)
SkFilterMode
:
:
kLinear
std
:
:
move
(
filter
)
)
;
if
(
!
shadowOnly
)
{
#
if
defined
(
SK_LEGACY_BLEND_FOR_DROP_SHADOWS
)
filter
=
SkImageFilters
:
:
Blend
(
SkBlendMode
:
:
kSrcOver
std
:
:
move
(
filter
)
std
:
:
move
(
input
)
)
;
#
else
filter
=
SkImageFilters
:
:
Merge
(
std
:
:
move
(
filter
)
std
:
:
move
(
input
)
)
;
#
endif
}
if
(
crop
)
{
filter
=
SkImageFilters
:
:
Crop
(
*
crop
std
:
:
move
(
filter
)
)
;
}
return
filter
;
}
sk_sp
<
SkFlattenable
>
legacy_drop_shadow_create_proc
(
SkReadBuffer
&
buffer
)
{
if
(
!
buffer
.
isVersionLT
(
SkPicturePriv
:
:
Version
:
:
kDropShadowImageFilterComposition
)
)
{
return
nullptr
;
}
auto
[
child
cropRect
]
=
SkImageFilter_Base
:
:
Unflatten
(
buffer
)
;
SkScalar
dx
=
buffer
.
readScalar
(
)
;
SkScalar
dy
=
buffer
.
readScalar
(
)
;
SkScalar
sigmaX
=
buffer
.
readScalar
(
)
;
SkScalar
sigmaY
=
buffer
.
readScalar
(
)
;
SkColor4f
color
=
SkColor4f
:
:
FromColor
(
buffer
.
readColor
(
)
)
;
bool
shadowOnly
=
SkToBool
(
buffer
.
read32LE
(
1
)
)
;
return
make_drop_shadow_graph
(
{
dx
dy
}
{
sigmaX
sigmaY
}
color
nullptr
shadowOnly
std
:
:
move
(
child
)
cropRect
)
;
}
}
sk_sp
<
SkImageFilter
>
SkImageFilters
:
:
DropShadow
(
SkScalar
dx
SkScalar
dy
SkScalar
sigmaX
SkScalar
sigmaY
SkColor4f
color
sk_sp
<
SkColorSpace
>
colorSpace
sk_sp
<
SkImageFilter
>
input
const
CropRect
&
cropRect
)
{
return
make_drop_shadow_graph
(
{
dx
dy
}
{
sigmaX
sigmaY
}
color
std
:
:
move
(
colorSpace
)
false
std
:
:
move
(
input
)
cropRect
)
;
}
sk_sp
<
SkImageFilter
>
SkImageFilters
:
:
DropShadowOnly
(
SkScalar
dx
SkScalar
dy
SkScalar
sigmaX
SkScalar
sigmaY
SkColor4f
color
sk_sp
<
SkColorSpace
>
colorSpace
sk_sp
<
SkImageFilter
>
input
const
CropRect
&
cropRect
)
{
return
make_drop_shadow_graph
(
{
dx
dy
}
{
sigmaX
sigmaY
}
color
std
:
:
move
(
colorSpace
)
true
std
:
:
move
(
input
)
cropRect
)
;
}
void
SkRegisterLegacyDropShadowImageFilterFlattenable
(
)
{
SkFlattenable
:
:
Register
(
"
SkDropShadowImageFilter
"
legacy_drop_shadow_create_proc
)
;
SkFlattenable
:
:
Register
(
"
SkDropShadowImageFilterImpl
"
legacy_drop_shadow_create_proc
)
;
}
