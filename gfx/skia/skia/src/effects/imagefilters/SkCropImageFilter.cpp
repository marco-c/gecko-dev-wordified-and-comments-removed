#
include
"
src
/
effects
/
imagefilters
/
SkCropImageFilter
.
h
"
#
include
"
include
/
core
/
SkFlattenable
.
h
"
#
include
"
include
/
core
/
SkImageFilter
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
src
/
core
/
SkImageFilterTypes
.
h
"
#
include
"
src
/
core
/
SkImageFilter_Base
.
h
"
#
include
"
src
/
core
/
SkReadBuffer
.
h
"
#
include
"
src
/
core
/
SkValidationUtils
.
h
"
#
include
"
src
/
core
/
SkWriteBuffer
.
h
"
#
include
<
utility
>
namespace
{
class
SkCropImageFilter
final
:
public
SkImageFilter_Base
{
public
:
SkCropImageFilter
(
const
SkRect
&
cropRect
sk_sp
<
SkImageFilter
>
input
)
:
SkImageFilter_Base
(
&
input
1
nullptr
)
fCropRect
(
cropRect
)
{
SkASSERT
(
cropRect
.
isFinite
(
)
)
;
SkASSERT
(
cropRect
.
isSorted
(
)
)
;
}
SkRect
computeFastBounds
(
const
SkRect
&
bounds
)
const
override
;
protected
:
void
flatten
(
SkWriteBuffer
&
)
const
override
;
private
:
friend
void
:
:
SkRegisterCropImageFilterFlattenable
(
)
;
SK_FLATTENABLE_HOOKS
(
SkCropImageFilter
)
skif
:
:
FilterResult
onFilterImage
(
const
skif
:
:
Context
&
context
)
const
override
;
skif
:
:
LayerSpace
<
SkIRect
>
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
const
skif
:
:
LayerSpace
<
SkIRect
>
&
contentBounds
VisitChildren
recurse
)
const
override
;
skif
:
:
LayerSpace
<
SkIRect
>
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
contentBounds
)
const
override
;
skif
:
:
LayerSpace
<
SkIRect
>
cropRect
(
const
skif
:
:
Mapping
&
mapping
)
const
{
return
mapping
.
paramToLayer
(
fCropRect
)
.
roundOut
(
)
;
}
skif
:
:
ParameterSpace
<
SkRect
>
fCropRect
;
}
;
}
sk_sp
<
SkImageFilter
>
SkMakeCropImageFilter
(
const
SkRect
&
rect
sk_sp
<
SkImageFilter
>
input
)
{
if
(
!
rect
.
isFinite
(
)
)
{
return
nullptr
;
}
return
sk_sp
<
SkImageFilter
>
(
new
SkCropImageFilter
(
rect
std
:
:
move
(
input
)
)
)
;
}
void
SkRegisterCropImageFilterFlattenable
(
)
{
SK_REGISTER_FLATTENABLE
(
SkCropImageFilter
)
;
}
sk_sp
<
SkFlattenable
>
SkCropImageFilter
:
:
CreateProc
(
SkReadBuffer
&
buffer
)
{
SK_IMAGEFILTER_UNFLATTEN_COMMON
(
common
1
)
;
SkRect
cropRect
=
buffer
.
readRect
(
)
;
if
(
!
buffer
.
isValid
(
)
|
|
!
buffer
.
validate
(
SkIsValidRect
(
cropRect
)
)
)
{
return
nullptr
;
}
return
SkMakeCropImageFilter
(
cropRect
common
.
getInput
(
0
)
)
;
}
void
SkCropImageFilter
:
:
flatten
(
SkWriteBuffer
&
buffer
)
const
{
this
-
>
SkImageFilter_Base
:
:
flatten
(
buffer
)
;
buffer
.
writeRect
(
SkRect
(
fCropRect
)
)
;
}
skif
:
:
FilterResult
SkCropImageFilter
:
:
onFilterImage
(
const
skif
:
:
Context
&
context
)
const
{
skif
:
:
LayerSpace
<
SkIRect
>
cropBounds
=
this
-
>
cropRect
(
context
.
mapping
(
)
)
;
if
(
cropBounds
.
isEmpty
(
)
)
{
return
{
}
;
}
skif
:
:
FilterResult
childOutput
=
this
-
>
filterInput
(
0
context
)
;
return
childOutput
.
applyCrop
(
context
cropBounds
)
;
}
skif
:
:
LayerSpace
<
SkIRect
>
SkCropImageFilter
:
:
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
const
skif
:
:
LayerSpace
<
SkIRect
>
&
contentBounds
VisitChildren
recurse
)
const
{
skif
:
:
LayerSpace
<
SkIRect
>
requiredInput
=
this
-
>
cropRect
(
mapping
)
;
if
(
!
requiredInput
.
intersect
(
desiredOutput
)
)
{
return
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Empty
(
)
;
}
if
(
recurse
=
=
VisitChildren
:
:
kNo
)
{
return
requiredInput
;
}
else
{
return
this
-
>
visitInputLayerBounds
(
mapping
requiredInput
contentBounds
)
;
}
}
skif
:
:
LayerSpace
<
SkIRect
>
SkCropImageFilter
:
:
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
contentBounds
)
const
{
skif
:
:
LayerSpace
<
SkIRect
>
output
=
this
-
>
cropRect
(
mapping
)
;
skif
:
:
LayerSpace
<
SkIRect
>
childOutput
=
this
-
>
visitOutputLayerBounds
(
mapping
contentBounds
)
;
if
(
output
.
intersect
(
childOutput
)
)
{
return
output
;
}
else
{
return
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Empty
(
)
;
}
}
SkRect
SkCropImageFilter
:
:
computeFastBounds
(
const
SkRect
&
bounds
)
const
{
if
(
this
-
>
getInput
(
0
)
&
&
!
this
-
>
getInput
(
0
)
-
>
canComputeFastBounds
(
)
)
{
return
SkRect
(
fCropRect
)
;
}
SkRect
inputBounds
=
this
-
>
getInput
(
0
)
?
this
-
>
getInput
(
0
)
-
>
computeFastBounds
(
bounds
)
:
bounds
;
if
(
!
inputBounds
.
intersect
(
SkRect
(
fCropRect
)
)
)
{
return
SkRect
:
:
MakeEmpty
(
)
;
}
return
inputBounds
;
}
