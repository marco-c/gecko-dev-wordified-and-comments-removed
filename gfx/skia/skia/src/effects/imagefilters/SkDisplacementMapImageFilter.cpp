#
include
"
include
/
effects
/
SkImageFilters
.
h
"
#
include
"
include
/
core
/
SkColor
.
h
"
#
include
"
include
/
core
/
SkFlattenable
.
h
"
#
include
"
include
/
core
/
SkImageFilter
.
h
"
#
include
"
include
/
core
/
SkM44
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSamplingOptions
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkShader
.
h
"
#
include
"
include
/
core
/
SkSize
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
effects
/
SkRuntimeEffect
.
h
"
#
include
"
include
/
private
/
base
/
SkSpan_impl
.
h
"
#
include
"
src
/
core
/
SkImageFilterTypes
.
h
"
#
include
"
src
/
core
/
SkImageFilter_Base
.
h
"
#
include
"
src
/
core
/
SkKnownRuntimeEffects
.
h
"
#
include
"
src
/
core
/
SkReadBuffer
.
h
"
#
include
"
src
/
core
/
SkWriteBuffer
.
h
"
#
include
<
optional
>
#
include
<
utility
>
namespace
{
class
SkDisplacementMapImageFilter
final
:
public
SkImageFilter_Base
{
static
constexpr
int
kDisplacement
=
0
;
static
constexpr
int
kColor
=
1
;
static
constexpr
SkSamplingOptions
kDisplacementSampling
{
SkFilterMode
:
:
kNearest
}
;
public
:
SkDisplacementMapImageFilter
(
SkColorChannel
xChannel
SkColorChannel
yChannel
SkScalar
scale
sk_sp
<
SkImageFilter
>
inputs
[
2
]
)
:
SkImageFilter_Base
(
inputs
2
)
fXChannel
(
xChannel
)
fYChannel
(
yChannel
)
fScale
(
scale
)
{
}
SkRect
computeFastBounds
(
const
SkRect
&
src
)
const
override
;
protected
:
void
flatten
(
SkWriteBuffer
&
)
const
override
;
private
:
friend
void
:
:
SkRegisterDisplacementMapImageFilterFlattenable
(
)
;
SK_FLATTENABLE_HOOKS
(
SkDisplacementMapImageFilter
)
skif
:
:
FilterResult
onFilterImage
(
const
skif
:
:
Context
&
)
const
override
;
skif
:
:
LayerSpace
<
SkIRect
>
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
override
;
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
override
;
skif
:
:
LayerSpace
<
SkIRect
>
outsetByMaxDisplacement
(
const
skif
:
:
Mapping
&
mapping
skif
:
:
LayerSpace
<
SkIRect
>
bounds
)
const
{
skif
:
:
LayerSpace
<
SkSize
>
maxDisplacement
=
mapping
.
paramToLayer
(
skif
:
:
ParameterSpace
<
SkSize
>
(
{
0
.
5f
*
fScale
0
.
5f
*
fScale
}
)
)
;
bounds
.
outset
(
maxDisplacement
.
ceil
(
)
)
;
return
bounds
;
}
SkColorChannel
fXChannel
;
SkColorChannel
fYChannel
;
SkScalar
fScale
;
}
;
bool
channel_selector_type_is_valid
(
SkColorChannel
cst
)
{
switch
(
cst
)
{
case
SkColorChannel
:
:
kR
:
case
SkColorChannel
:
:
kG
:
case
SkColorChannel
:
:
kB
:
case
SkColorChannel
:
:
kA
:
return
true
;
default
:
break
;
}
return
false
;
}
sk_sp
<
SkShader
>
make_displacement_shader
(
sk_sp
<
SkShader
>
displacement
sk_sp
<
SkShader
>
color
skif
:
:
LayerSpace
<
skif
:
:
Vector
>
scale
SkColorChannel
xChannel
SkColorChannel
yChannel
)
{
if
(
!
color
)
{
return
nullptr
;
}
if
(
!
displacement
)
{
displacement
=
SkShaders
:
:
Color
(
SK_ColorTRANSPARENT
)
;
}
const
SkRuntimeEffect
*
displacementEffect
=
GetKnownRuntimeEffect
(
SkKnownRuntimeEffects
:
:
StableKey
:
:
kDisplacement
)
;
auto
channelSelector
=
[
]
(
SkColorChannel
c
)
{
return
SkV4
{
c
=
=
SkColorChannel
:
:
kR
?
1
.
f
:
0
.
f
c
=
=
SkColorChannel
:
:
kG
?
1
.
f
:
0
.
f
c
=
=
SkColorChannel
:
:
kB
?
1
.
f
:
0
.
f
c
=
=
SkColorChannel
:
:
kA
?
1
.
f
:
0
.
f
}
;
}
;
SkRuntimeShaderBuilder
builder
(
sk_ref_sp
(
displacementEffect
)
)
;
builder
.
child
(
"
displMap
"
)
=
std
:
:
move
(
displacement
)
;
builder
.
child
(
"
colorMap
"
)
=
std
:
:
move
(
color
)
;
builder
.
uniform
(
"
scale
"
)
=
SkV2
{
scale
.
x
(
)
scale
.
y
(
)
}
;
builder
.
uniform
(
"
xSelect
"
)
=
channelSelector
(
xChannel
)
;
builder
.
uniform
(
"
ySelect
"
)
=
channelSelector
(
yChannel
)
;
return
builder
.
makeShader
(
)
;
}
}
sk_sp
<
SkImageFilter
>
SkImageFilters
:
:
DisplacementMap
(
SkColorChannel
xChannelSelector
SkColorChannel
yChannelSelector
SkScalar
scale
sk_sp
<
SkImageFilter
>
displacement
sk_sp
<
SkImageFilter
>
color
const
CropRect
&
cropRect
)
{
if
(
!
channel_selector_type_is_valid
(
xChannelSelector
)
|
|
!
channel_selector_type_is_valid
(
yChannelSelector
)
)
{
return
nullptr
;
}
sk_sp
<
SkImageFilter
>
inputs
[
2
]
=
{
std
:
:
move
(
displacement
)
std
:
:
move
(
color
)
}
;
sk_sp
<
SkImageFilter
>
filter
(
new
SkDisplacementMapImageFilter
(
xChannelSelector
yChannelSelector
scale
inputs
)
)
;
if
(
cropRect
)
{
filter
=
SkImageFilters
:
:
Crop
(
*
cropRect
std
:
:
move
(
filter
)
)
;
}
return
filter
;
}
void
SkRegisterDisplacementMapImageFilterFlattenable
(
)
{
SK_REGISTER_FLATTENABLE
(
SkDisplacementMapImageFilter
)
;
SkFlattenable
:
:
Register
(
"
SkDisplacementMapEffect
"
SkDisplacementMapImageFilter
:
:
CreateProc
)
;
SkFlattenable
:
:
Register
(
"
SkDisplacementMapEffectImpl
"
SkDisplacementMapImageFilter
:
:
CreateProc
)
;
}
sk_sp
<
SkFlattenable
>
SkDisplacementMapImageFilter
:
:
CreateProc
(
SkReadBuffer
&
buffer
)
{
SK_IMAGEFILTER_UNFLATTEN_COMMON
(
common
2
)
;
SkColorChannel
xsel
=
buffer
.
read32LE
(
SkColorChannel
:
:
kLastEnum
)
;
SkColorChannel
ysel
=
buffer
.
read32LE
(
SkColorChannel
:
:
kLastEnum
)
;
SkScalar
scale
=
buffer
.
readScalar
(
)
;
return
SkImageFilters
:
:
DisplacementMap
(
xsel
ysel
scale
common
.
getInput
(
0
)
common
.
getInput
(
1
)
common
.
cropRect
(
)
)
;
}
void
SkDisplacementMapImageFilter
:
:
flatten
(
SkWriteBuffer
&
buffer
)
const
{
this
-
>
SkImageFilter_Base
:
:
flatten
(
buffer
)
;
buffer
.
writeInt
(
(
int
)
fXChannel
)
;
buffer
.
writeInt
(
(
int
)
fYChannel
)
;
buffer
.
writeScalar
(
fScale
)
;
}
skif
:
:
FilterResult
SkDisplacementMapImageFilter
:
:
onFilterImage
(
const
skif
:
:
Context
&
ctx
)
const
{
skif
:
:
LayerSpace
<
SkIRect
>
requiredColorInput
=
this
-
>
outsetByMaxDisplacement
(
ctx
.
mapping
(
)
ctx
.
desiredOutput
(
)
)
;
skif
:
:
FilterResult
colorOutput
=
this
-
>
getChildOutput
(
kColor
ctx
.
withNewDesiredOutput
(
requiredColorInput
)
)
;
if
(
!
colorOutput
)
{
return
{
}
;
}
skif
:
:
LayerSpace
<
SkIRect
>
outputBounds
=
this
-
>
outsetByMaxDisplacement
(
ctx
.
mapping
(
)
colorOutput
.
layerBounds
(
)
)
;
if
(
!
outputBounds
.
intersect
(
ctx
.
desiredOutput
(
)
)
)
{
return
{
}
;
}
skif
:
:
FilterResult
displacementOutput
=
this
-
>
getChildOutput
(
kDisplacement
ctx
.
withNewDesiredOutput
(
outputBounds
)
.
withNewColorSpace
(
nullptr
)
)
;
const
skif
:
:
LayerSpace
<
skif
:
:
Vector
>
scale
=
ctx
.
mapping
(
)
.
paramToLayer
(
skif
:
:
ParameterSpace
<
skif
:
:
Vector
>
(
{
fScale
fScale
}
)
)
;
if
(
!
displacementOutput
)
{
skif
:
:
LayerSpace
<
SkMatrix
>
constantDisplacement
{
SkMatrix
:
:
Translate
(
-
0
.
5f
*
scale
.
x
(
)
-
0
.
5f
*
scale
.
y
(
)
)
}
;
return
colorOutput
.
applyTransform
(
ctx
constantDisplacement
kDisplacementSampling
)
;
}
using
ShaderFlags
=
skif
:
:
FilterResult
:
:
ShaderFlags
;
skif
:
:
FilterResult
:
:
Builder
builder
{
ctx
}
;
builder
.
add
(
displacementOutput
outputBounds
)
;
builder
.
add
(
colorOutput
requiredColorInput
ShaderFlags
:
:
kNonTrivialSampling
kDisplacementSampling
)
;
return
builder
.
eval
(
[
&
]
(
SkSpan
<
sk_sp
<
SkShader
>
>
inputs
)
{
return
make_displacement_shader
(
inputs
[
kDisplacement
]
inputs
[
kColor
]
scale
fXChannel
fYChannel
)
;
}
outputBounds
)
;
}
skif
:
:
LayerSpace
<
SkIRect
>
SkDisplacementMapImageFilter
:
:
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
{
skif
:
:
LayerSpace
<
SkIRect
>
requiredInput
=
this
-
>
outsetByMaxDisplacement
(
mapping
desiredOutput
)
;
requiredInput
=
this
-
>
getChildInputLayerBounds
(
kColor
mapping
requiredInput
contentBounds
)
;
requiredInput
.
join
(
this
-
>
getChildInputLayerBounds
(
kDisplacement
mapping
desiredOutput
contentBounds
)
)
;
return
requiredInput
;
}
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
SkDisplacementMapImageFilter
:
:
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
{
auto
colorOutput
=
this
-
>
getChildOutputLayerBounds
(
kColor
mapping
contentBounds
)
;
if
(
colorOutput
)
{
return
this
-
>
outsetByMaxDisplacement
(
mapping
*
colorOutput
)
;
}
else
{
return
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Unbounded
(
)
;
}
}
SkRect
SkDisplacementMapImageFilter
:
:
computeFastBounds
(
const
SkRect
&
src
)
const
{
SkRect
colorBounds
=
this
-
>
getInput
(
kColor
)
?
this
-
>
getInput
(
kColor
)
-
>
computeFastBounds
(
src
)
:
src
;
float
maxDisplacement
=
0
.
5f
*
SkScalarAbs
(
fScale
)
;
return
colorBounds
.
makeOutset
(
maxDisplacement
maxDisplacement
)
;
}
