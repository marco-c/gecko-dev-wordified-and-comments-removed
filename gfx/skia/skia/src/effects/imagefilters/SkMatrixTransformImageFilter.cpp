#
include
"
include
/
core
/
SkFlattenable
.
h
"
#
include
"
include
/
core
/
SkImageFilter
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSamplingOptions
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
effects
/
SkImageFilters
.
h
"
#
include
"
src
/
core
/
SkImageFilterTypes
.
h
"
#
include
"
src
/
core
/
SkImageFilter_Base
.
h
"
#
include
"
src
/
core
/
SkPicturePriv
.
h
"
#
include
"
src
/
core
/
SkReadBuffer
.
h
"
#
include
"
src
/
core
/
SkSamplingPriv
.
h
"
#
include
"
src
/
core
/
SkWriteBuffer
.
h
"
#
include
<
optional
>
#
include
<
utility
>
struct
SkISize
;
namespace
{
class
SkMatrixTransformImageFilter
final
:
public
SkImageFilter_Base
{
public
:
SkMatrixTransformImageFilter
(
const
SkMatrix
&
transform
const
SkSamplingOptions
&
sampling
sk_sp
<
SkImageFilter
>
input
)
:
SkImageFilter_Base
(
&
input
1
)
fTransform
(
transform
)
fSampling
(
sampling
)
{
(
void
)
static_cast
<
const
SkMatrix
&
>
(
fTransform
)
.
getType
(
)
;
}
SkRect
computeFastBounds
(
const
SkRect
&
)
const
override
;
protected
:
void
flatten
(
SkWriteBuffer
&
)
const
override
;
private
:
friend
void
:
:
SkRegisterMatrixTransformImageFilterFlattenable
(
)
;
SK_FLATTENABLE_HOOKS
(
SkMatrixTransformImageFilter
)
static
sk_sp
<
SkFlattenable
>
LegacyOffsetCreateProc
(
SkReadBuffer
&
buffer
)
;
MatrixCapability
onGetCTMCapability
(
)
const
override
{
return
MatrixCapability
:
:
kComplex
;
}
skif
:
:
FilterResult
onFilterImage
(
const
skif
:
:
Context
&
context
)
const
override
;
skif
:
:
LayerSpace
<
SkIRect
>
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
override
;
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
override
;
skif
:
:
LayerSpace
<
SkIRect
>
requiredInput
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
)
const
;
skif
:
:
ParameterSpace
<
SkMatrix
>
fTransform
;
SkSamplingOptions
fSampling
;
}
;
}
sk_sp
<
SkImageFilter
>
SkImageFilters
:
:
MatrixTransform
(
const
SkMatrix
&
transform
const
SkSamplingOptions
&
sampling
sk_sp
<
SkImageFilter
>
input
)
{
if
(
!
transform
.
invert
(
nullptr
)
)
{
return
nullptr
;
}
return
sk_sp
<
SkImageFilter
>
(
new
SkMatrixTransformImageFilter
(
transform
sampling
std
:
:
move
(
input
)
)
)
;
}
sk_sp
<
SkImageFilter
>
SkImageFilters
:
:
Offset
(
SkScalar
dx
SkScalar
dy
sk_sp
<
SkImageFilter
>
input
const
CropRect
&
cropRect
)
{
sk_sp
<
SkImageFilter
>
offset
=
SkImageFilters
:
:
MatrixTransform
(
SkMatrix
:
:
Translate
(
dx
dy
)
SkFilterMode
:
:
kNearest
std
:
:
move
(
input
)
)
;
if
(
cropRect
)
{
offset
=
SkImageFilters
:
:
Crop
(
*
cropRect
std
:
:
move
(
offset
)
)
;
}
return
offset
;
}
void
SkRegisterMatrixTransformImageFilterFlattenable
(
)
{
SK_REGISTER_FLATTENABLE
(
SkMatrixTransformImageFilter
)
;
SkFlattenable
:
:
Register
(
"
SkMatrixImageFilter
"
SkMatrixTransformImageFilter
:
:
CreateProc
)
;
SkFlattenable
:
:
Register
(
"
SkOffsetImageFilter
"
SkMatrixTransformImageFilter
:
:
LegacyOffsetCreateProc
)
;
SkFlattenable
:
:
Register
(
"
SkOffsetImageFilterImpl
"
SkMatrixTransformImageFilter
:
:
LegacyOffsetCreateProc
)
;
}
sk_sp
<
SkFlattenable
>
SkMatrixTransformImageFilter
:
:
LegacyOffsetCreateProc
(
SkReadBuffer
&
buffer
)
{
SK_IMAGEFILTER_UNFLATTEN_COMMON
(
common
1
)
;
SkPoint
offset
;
buffer
.
readPoint
(
&
offset
)
;
return
SkImageFilters
:
:
Offset
(
offset
.
x
(
)
offset
.
y
(
)
common
.
getInput
(
0
)
common
.
cropRect
(
)
)
;
}
sk_sp
<
SkFlattenable
>
SkMatrixTransformImageFilter
:
:
CreateProc
(
SkReadBuffer
&
buffer
)
{
SK_IMAGEFILTER_UNFLATTEN_COMMON
(
common
1
)
;
SkMatrix
matrix
;
buffer
.
readMatrix
(
&
matrix
)
;
auto
sampling
=
[
&
]
(
)
{
if
(
buffer
.
isVersionLT
(
SkPicturePriv
:
:
kMatrixImageFilterSampling_Version
)
)
{
return
SkSamplingPriv
:
:
FromFQ
(
buffer
.
read32LE
(
kLast_SkLegacyFQ
)
kLinear_SkMediumAs
)
;
}
else
{
return
buffer
.
readSampling
(
)
;
}
}
(
)
;
return
SkImageFilters
:
:
MatrixTransform
(
matrix
sampling
common
.
getInput
(
0
)
)
;
}
void
SkMatrixTransformImageFilter
:
:
flatten
(
SkWriteBuffer
&
buffer
)
const
{
this
-
>
SkImageFilter_Base
:
:
flatten
(
buffer
)
;
buffer
.
writeMatrix
(
SkMatrix
(
fTransform
)
)
;
buffer
.
writeSampling
(
fSampling
)
;
}
skif
:
:
FilterResult
SkMatrixTransformImageFilter
:
:
onFilterImage
(
const
skif
:
:
Context
&
context
)
const
{
skif
:
:
LayerSpace
<
SkIRect
>
requiredInput
=
this
-
>
requiredInput
(
context
.
mapping
(
)
context
.
desiredOutput
(
)
)
;
skif
:
:
FilterResult
childOutput
=
this
-
>
getChildOutput
(
0
context
.
withNewDesiredOutput
(
requiredInput
)
)
;
skif
:
:
LayerSpace
<
SkMatrix
>
transform
=
context
.
mapping
(
)
.
paramToLayer
(
fTransform
)
;
return
childOutput
.
applyTransform
(
context
transform
fSampling
)
;
}
SkRect
SkMatrixTransformImageFilter
:
:
computeFastBounds
(
const
SkRect
&
src
)
const
{
SkRect
bounds
=
this
-
>
getInput
(
0
)
?
this
-
>
getInput
(
0
)
-
>
computeFastBounds
(
src
)
:
src
;
return
static_cast
<
const
SkMatrix
&
>
(
fTransform
)
.
mapRect
(
bounds
)
;
}
skif
:
:
LayerSpace
<
SkIRect
>
SkMatrixTransformImageFilter
:
:
requiredInput
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
)
const
{
skif
:
:
LayerSpace
<
SkIRect
>
requiredInput
;
if
(
!
mapping
.
paramToLayer
(
fTransform
)
.
inverseMapRect
(
desiredOutput
&
requiredInput
)
)
{
return
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Empty
(
)
;
}
if
(
fSampling
!
=
SkSamplingOptions
(
)
)
{
requiredInput
.
outset
(
skif
:
:
LayerSpace
<
SkISize
>
(
{
1
1
}
)
)
;
}
return
requiredInput
;
}
skif
:
:
LayerSpace
<
SkIRect
>
SkMatrixTransformImageFilter
:
:
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
{
skif
:
:
LayerSpace
<
SkIRect
>
requiredInput
=
this
-
>
requiredInput
(
mapping
desiredOutput
)
;
return
this
-
>
getChildInputLayerBounds
(
0
mapping
requiredInput
contentBounds
)
;
}
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
SkMatrixTransformImageFilter
:
:
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
{
auto
childOutput
=
this
-
>
getChildOutputLayerBounds
(
0
mapping
contentBounds
)
;
if
(
childOutput
)
{
return
mapping
.
paramToLayer
(
fTransform
)
.
mapRect
(
*
childOutput
)
;
}
else
{
return
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Unbounded
(
)
;
}
}
