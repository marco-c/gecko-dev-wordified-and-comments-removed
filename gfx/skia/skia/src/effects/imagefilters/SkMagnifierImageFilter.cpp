#
include
"
include
/
effects
/
SkImageFilters
.
h
"
#
include
"
include
/
core
/
SkFlattenable
.
h
"
#
include
"
include
/
core
/
SkImageFilter
.
h
"
#
include
"
include
/
core
/
SkM44
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSamplingOptions
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkShader
.
h
"
#
include
"
include
/
core
/
SkSize
.
h
"
#
include
"
include
/
core
/
SkSpan
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
effects
/
SkRuntimeEffect
.
h
"
#
include
"
include
/
private
/
base
/
SkFloatingPoint
.
h
"
#
include
"
src
/
core
/
SkImageFilterTypes
.
h
"
#
include
"
src
/
core
/
SkImageFilter_Base
.
h
"
#
include
"
src
/
core
/
SkKnownRuntimeEffects
.
h
"
#
include
"
src
/
core
/
SkPicturePriv
.
h
"
#
include
"
src
/
core
/
SkReadBuffer
.
h
"
#
include
"
src
/
core
/
SkWriteBuffer
.
h
"
#
include
<
algorithm
>
#
include
<
optional
>
#
include
<
utility
>
namespace
{
class
SkMagnifierImageFilter
final
:
public
SkImageFilter_Base
{
public
:
SkMagnifierImageFilter
(
const
SkRect
&
lensBounds
float
zoomAmount
float
inset
const
SkSamplingOptions
&
sampling
sk_sp
<
SkImageFilter
>
input
)
:
SkImageFilter_Base
(
&
input
1
)
fLensBounds
(
lensBounds
)
fZoomAmount
(
zoomAmount
)
fInset
(
inset
)
fSampling
(
sampling
)
{
}
SkRect
computeFastBounds
(
const
SkRect
&
)
const
override
;
protected
:
void
flatten
(
SkWriteBuffer
&
)
const
override
;
private
:
friend
void
:
:
SkRegisterMagnifierImageFilterFlattenable
(
)
;
SK_FLATTENABLE_HOOKS
(
SkMagnifierImageFilter
)
skif
:
:
FilterResult
onFilterImage
(
const
skif
:
:
Context
&
context
)
const
override
;
skif
:
:
LayerSpace
<
SkIRect
>
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
override
;
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
override
;
skif
:
:
ParameterSpace
<
SkRect
>
fLensBounds
;
float
fZoomAmount
;
float
fInset
;
SkSamplingOptions
fSampling
;
}
;
}
sk_sp
<
SkImageFilter
>
SkImageFilters
:
:
Magnifier
(
const
SkRect
&
lensBounds
SkScalar
zoomAmount
SkScalar
inset
const
SkSamplingOptions
&
sampling
sk_sp
<
SkImageFilter
>
input
const
CropRect
&
cropRect
)
{
if
(
lensBounds
.
isEmpty
(
)
|
|
!
lensBounds
.
isFinite
(
)
|
|
zoomAmount
<
=
0
.
f
|
|
inset
<
0
.
f
|
|
!
SkIsFinite
(
zoomAmount
inset
)
)
{
return
nullptr
;
}
if
(
cropRect
)
{
input
=
SkImageFilters
:
:
Crop
(
*
cropRect
std
:
:
move
(
input
)
)
;
}
if
(
zoomAmount
>
1
.
f
)
{
return
sk_sp
<
SkImageFilter
>
(
new
SkMagnifierImageFilter
(
lensBounds
zoomAmount
inset
sampling
std
:
:
move
(
input
)
)
)
;
}
else
{
return
input
;
}
}
void
SkRegisterMagnifierImageFilterFlattenable
(
)
{
SK_REGISTER_FLATTENABLE
(
SkMagnifierImageFilter
)
;
}
sk_sp
<
SkFlattenable
>
SkMagnifierImageFilter
:
:
CreateProc
(
SkReadBuffer
&
buffer
)
{
if
(
buffer
.
isVersionLT
(
SkPicturePriv
:
:
kRevampMagnifierFilter
)
)
{
return
nullptr
;
}
SK_IMAGEFILTER_UNFLATTEN_COMMON
(
common
1
)
;
SkRect
lensBounds
;
buffer
.
readRect
(
&
lensBounds
)
;
SkScalar
zoomAmount
=
buffer
.
readScalar
(
)
;
SkScalar
inset
=
buffer
.
readScalar
(
)
;
SkSamplingOptions
sampling
=
buffer
.
readSampling
(
)
;
return
SkImageFilters
:
:
Magnifier
(
lensBounds
zoomAmount
inset
sampling
common
.
getInput
(
0
)
)
;
}
void
SkMagnifierImageFilter
:
:
flatten
(
SkWriteBuffer
&
buffer
)
const
{
this
-
>
SkImageFilter_Base
:
:
flatten
(
buffer
)
;
buffer
.
writeRect
(
SkRect
(
fLensBounds
)
)
;
buffer
.
writeScalar
(
fZoomAmount
)
;
buffer
.
writeScalar
(
fInset
)
;
buffer
.
writeSampling
(
fSampling
)
;
}
static
sk_sp
<
SkShader
>
make_magnifier_shader
(
sk_sp
<
SkShader
>
input
const
skif
:
:
LayerSpace
<
SkRect
>
&
lensBounds
const
skif
:
:
LayerSpace
<
SkMatrix
>
&
zoomXform
const
skif
:
:
LayerSpace
<
SkSize
>
&
inset
)
{
const
SkRuntimeEffect
*
magEffect
=
GetKnownRuntimeEffect
(
SkKnownRuntimeEffects
:
:
StableKey
:
:
kMagnifier
)
;
SkRuntimeShaderBuilder
builder
(
sk_ref_sp
(
magEffect
)
)
;
builder
.
child
(
"
src
"
)
=
std
:
:
move
(
input
)
;
SkASSERT
(
inset
.
width
(
)
>
0
.
f
&
&
inset
.
height
(
)
>
0
.
f
)
;
builder
.
uniform
(
"
lensBounds
"
)
=
SkRect
(
lensBounds
)
;
builder
.
uniform
(
"
zoomXform
"
)
=
SkV4
{
zoomXform
.
rc
(
0
2
)
zoomXform
.
rc
(
1
2
)
zoomXform
.
rc
(
0
0
)
zoomXform
.
rc
(
1
1
)
}
;
builder
.
uniform
(
"
invInset
"
)
=
SkV2
{
1
.
f
/
inset
.
width
(
)
1
.
f
/
inset
.
height
(
)
}
;
return
builder
.
makeShader
(
)
;
}
skif
:
:
FilterResult
SkMagnifierImageFilter
:
:
onFilterImage
(
const
skif
:
:
Context
&
context
)
const
{
skif
:
:
LayerSpace
<
SkRect
>
lensBounds
=
context
.
mapping
(
)
.
paramToLayer
(
fLensBounds
)
;
skif
:
:
LayerSpace
<
SkPoint
>
zoomCenter
=
lensBounds
.
center
(
)
;
skif
:
:
LayerSpace
<
SkRect
>
visibleLensBounds
=
lensBounds
;
if
(
!
visibleLensBounds
.
intersect
(
skif
:
:
LayerSpace
<
SkRect
>
(
context
.
desiredOutput
(
)
)
)
)
{
return
{
}
;
}
skif
:
:
LayerSpace
<
SkRect
>
expectedChildOutput
=
lensBounds
;
if
(
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
output
=
this
-
>
getChildOutputLayerBounds
(
0
context
.
mapping
(
)
context
.
source
(
)
.
layerBounds
(
)
)
)
{
expectedChildOutput
=
skif
:
:
LayerSpace
<
SkRect
>
(
*
output
)
;
}
zoomCenter
=
expectedChildOutput
.
clamp
(
zoomCenter
)
;
SkASSERT
(
this
-
>
getCTMCapability
(
)
=
=
MatrixCapability
:
:
kScaleTranslate
)
;
const
float
maxLensSize
=
std
:
:
max
(
1
.
f
std
:
:
max
(
lensBounds
.
width
(
)
lensBounds
.
height
(
)
)
)
;
const
float
invZoom
=
1
.
f
/
std
:
:
min
(
fZoomAmount
2
.
f
*
maxLensSize
)
;
skif
:
:
LayerSpace
<
SkRect
>
srcRect
{
{
lensBounds
.
left
(
)
*
invZoom
+
zoomCenter
.
x
(
)
*
(
1
.
f
-
invZoom
)
lensBounds
.
top
(
)
*
invZoom
+
zoomCenter
.
y
(
)
*
(
1
.
f
-
invZoom
)
lensBounds
.
right
(
)
*
invZoom
+
zoomCenter
.
x
(
)
*
(
1
.
f
-
invZoom
)
lensBounds
.
bottom
(
)
*
invZoom
+
zoomCenter
.
y
(
)
*
(
1
.
f
-
invZoom
)
}
}
;
auto
zoomXform
=
skif
:
:
LayerSpace
<
SkMatrix
>
:
:
RectToRect
(
lensBounds
srcRect
)
;
if
(
!
expectedChildOutput
.
contains
(
visibleLensBounds
)
)
{
srcRect
=
zoomXform
.
mapRect
(
visibleLensBounds
)
;
if
(
expectedChildOutput
.
width
(
)
>
=
srcRect
.
width
(
)
&
&
expectedChildOutput
.
height
(
)
>
=
srcRect
.
height
(
)
)
{
float
left
=
srcRect
.
left
(
)
<
expectedChildOutput
.
left
(
)
?
expectedChildOutput
.
left
(
)
:
std
:
:
min
(
srcRect
.
right
(
)
expectedChildOutput
.
right
(
)
)
-
srcRect
.
width
(
)
;
float
top
=
srcRect
.
top
(
)
<
expectedChildOutput
.
top
(
)
?
expectedChildOutput
.
top
(
)
:
std
:
:
min
(
srcRect
.
bottom
(
)
expectedChildOutput
.
bottom
(
)
)
-
srcRect
.
height
(
)
;
srcRect
=
skif
:
:
LayerSpace
<
SkRect
>
(
SkRect
:
:
MakeXYWH
(
left
top
srcRect
.
width
(
)
srcRect
.
height
(
)
)
)
;
zoomXform
=
skif
:
:
LayerSpace
<
SkMatrix
>
:
:
RectToRect
(
visibleLensBounds
srcRect
)
;
}
}
skif
:
:
LayerSpace
<
SkSize
>
inset
=
context
.
mapping
(
)
.
paramToLayer
(
skif
:
:
ParameterSpace
<
SkSize
>
(
{
fInset
fInset
}
)
)
;
if
(
inset
.
width
(
)
<
=
0
.
f
|
|
inset
.
height
(
)
<
=
0
.
f
)
{
skif
:
:
LayerSpace
<
SkMatrix
>
invZoomXform
;
if
(
!
zoomXform
.
invert
(
&
invZoomXform
)
)
{
return
{
}
;
}
skif
:
:
FilterResult
childOutput
=
this
-
>
getChildOutput
(
0
context
.
withNewDesiredOutput
(
srcRect
.
roundOut
(
)
)
)
;
return
childOutput
.
applyTransform
(
context
invZoomXform
fSampling
)
.
applyCrop
(
context
lensBounds
.
roundOut
(
)
)
;
}
using
ShaderFlags
=
skif
:
:
FilterResult
:
:
ShaderFlags
;
skif
:
:
FilterResult
:
:
Builder
builder
{
context
}
;
builder
.
add
(
this
-
>
getChildOutput
(
0
context
.
withNewDesiredOutput
(
visibleLensBounds
.
roundOut
(
)
)
)
{
}
ShaderFlags
:
:
kNonTrivialSampling
fSampling
)
;
return
builder
.
eval
(
[
&
]
(
SkSpan
<
sk_sp
<
SkShader
>
>
inputs
)
{
return
inputs
[
0
]
?
make_magnifier_shader
(
inputs
[
0
]
lensBounds
zoomXform
inset
)
:
nullptr
;
}
lensBounds
.
roundOut
(
)
)
;
}
skif
:
:
LayerSpace
<
SkIRect
>
SkMagnifierImageFilter
:
:
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
{
skif
:
:
LayerSpace
<
SkIRect
>
requiredInput
=
mapping
.
paramToLayer
(
fLensBounds
)
.
roundOut
(
)
;
return
this
-
>
getChildInputLayerBounds
(
0
mapping
requiredInput
contentBounds
)
;
}
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
SkMagnifierImageFilter
:
:
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
{
auto
output
=
this
-
>
getChildOutputLayerBounds
(
0
mapping
contentBounds
)
;
skif
:
:
LayerSpace
<
SkIRect
>
lensBounds
=
mapping
.
paramToLayer
(
fLensBounds
)
.
roundOut
(
)
;
if
(
!
output
|
|
lensBounds
.
intersect
(
*
output
)
)
{
return
lensBounds
;
}
else
{
return
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Empty
(
)
;
}
}
SkRect
SkMagnifierImageFilter
:
:
computeFastBounds
(
const
SkRect
&
src
)
const
{
SkRect
bounds
=
this
-
>
getInput
(
0
)
?
this
-
>
getInput
(
0
)
-
>
computeFastBounds
(
src
)
:
src
;
if
(
bounds
.
intersect
(
SkRect
(
fLensBounds
)
)
)
{
return
bounds
;
}
else
{
return
SkRect
:
:
MakeEmpty
(
)
;
}
}
