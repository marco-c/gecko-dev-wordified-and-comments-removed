#
include
"
include
/
effects
/
SkImageFilters
.
h
"
#
include
"
include
/
core
/
SkData
.
h
"
#
include
"
include
/
core
/
SkFlattenable
.
h
"
#
include
"
include
/
core
/
SkImageFilter
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkShader
.
h
"
#
include
"
include
/
core
/
SkSize
.
h
"
#
include
"
include
/
core
/
SkSpan
.
h
"
#
include
"
include
/
core
/
SkString
.
h
"
#
include
"
include
/
effects
/
SkRuntimeEffect
.
h
"
#
include
"
include
/
private
/
base
/
SkAssert
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
src
/
base
/
SkSpinlock
.
h
"
#
include
"
src
/
core
/
SkImageFilterTypes
.
h
"
#
include
"
src
/
core
/
SkImageFilter_Base
.
h
"
#
include
"
src
/
core
/
SkPicturePriv
.
h
"
#
include
"
src
/
core
/
SkReadBuffer
.
h
"
#
include
"
src
/
core
/
SkRectPriv
.
h
"
#
include
"
src
/
core
/
SkRuntimeEffectPriv
.
h
"
#
include
"
src
/
core
/
SkWriteBuffer
.
h
"
#
include
<
cstddef
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
string_view
>
#
include
<
utility
>
using
namespace
skia_private
;
class
SkRuntimeImageFilter
final
:
public
SkImageFilter_Base
{
public
:
SkRuntimeImageFilter
(
const
SkRuntimeShaderBuilder
&
builder
float
maxSampleRadius
std
:
:
string_view
childShaderNames
[
]
const
sk_sp
<
SkImageFilter
>
inputs
[
]
int
inputCount
)
:
SkImageFilter_Base
(
inputs
inputCount
)
fRuntimeEffectBuilder
(
builder
)
fMaxSampleRadius
(
maxSampleRadius
)
{
SkASSERT
(
maxSampleRadius
>
=
0
.
f
)
;
fChildShaderNames
.
reserve_exact
(
inputCount
)
;
for
(
int
i
=
0
;
i
<
inputCount
;
i
+
+
)
{
fChildShaderNames
.
push_back
(
SkString
(
childShaderNames
[
i
]
)
)
;
}
}
SkRect
computeFastBounds
(
const
SkRect
&
src
)
const
override
;
protected
:
void
flatten
(
SkWriteBuffer
&
)
const
override
;
private
:
friend
void
:
:
SkRegisterRuntimeImageFilterFlattenable
(
)
;
SK_FLATTENABLE_HOOKS
(
SkRuntimeImageFilter
)
bool
onAffectsTransparentBlack
(
)
const
override
{
return
true
;
}
MatrixCapability
onGetCTMCapability
(
)
const
override
{
return
MatrixCapability
:
:
kTranslate
;
}
skif
:
:
FilterResult
onFilterImage
(
const
skif
:
:
Context
&
)
const
override
;
skif
:
:
LayerSpace
<
SkIRect
>
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
override
;
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
override
;
skif
:
:
LayerSpace
<
SkIRect
>
applyMaxSampleRadius
(
const
skif
:
:
Mapping
&
mapping
skif
:
:
LayerSpace
<
SkIRect
>
bounds
)
const
{
skif
:
:
LayerSpace
<
SkISize
>
maxSampleRadius
=
mapping
.
paramToLayer
(
skif
:
:
ParameterSpace
<
SkSize
>
(
{
fMaxSampleRadius
fMaxSampleRadius
}
)
)
.
ceil
(
)
;
bounds
.
outset
(
maxSampleRadius
)
;
return
bounds
;
}
mutable
SkSpinlock
fRuntimeEffectLock
;
mutable
SkRuntimeShaderBuilder
fRuntimeEffectBuilder
;
STArray
<
1
SkString
>
fChildShaderNames
;
float
fMaxSampleRadius
;
}
;
sk_sp
<
SkImageFilter
>
SkImageFilters
:
:
RuntimeShader
(
const
SkRuntimeShaderBuilder
&
builder
SkScalar
sampleRadius
std
:
:
string_view
childShaderName
sk_sp
<
SkImageFilter
>
input
)
{
if
(
childShaderName
.
empty
(
)
)
{
auto
children
=
builder
.
effect
(
)
-
>
children
(
)
;
if
(
children
.
size
(
)
!
=
1
)
{
return
nullptr
;
}
childShaderName
=
children
.
front
(
)
.
name
;
}
return
SkImageFilters
:
:
RuntimeShader
(
builder
sampleRadius
&
childShaderName
&
input
1
)
;
}
sk_sp
<
SkImageFilter
>
SkImageFilters
:
:
RuntimeShader
(
const
SkRuntimeShaderBuilder
&
builder
SkScalar
maxSampleRadius
std
:
:
string_view
childShaderNames
[
]
const
sk_sp
<
SkImageFilter
>
inputs
[
]
int
inputCount
)
{
if
(
maxSampleRadius
<
0
.
f
)
{
return
nullptr
;
}
auto
child_is_shader
=
[
]
(
const
SkRuntimeEffect
:
:
Child
*
child
)
{
return
child
&
&
child
-
>
type
=
=
SkRuntimeEffect
:
:
ChildType
:
:
kShader
;
}
;
for
(
int
i
=
0
;
i
<
inputCount
;
i
+
+
)
{
std
:
:
string_view
name
=
childShaderNames
[
i
]
;
if
(
name
.
empty
(
)
|
|
!
child_is_shader
(
builder
.
effect
(
)
-
>
findChild
(
name
)
)
)
{
return
nullptr
;
}
for
(
int
j
=
0
;
j
<
i
;
j
+
+
)
{
if
(
name
=
=
childShaderNames
[
j
]
)
{
return
nullptr
;
}
}
}
return
sk_sp
<
SkImageFilter
>
(
new
SkRuntimeImageFilter
(
builder
maxSampleRadius
childShaderNames
inputs
inputCount
)
)
;
}
void
SkRegisterRuntimeImageFilterFlattenable
(
)
{
SK_REGISTER_FLATTENABLE
(
SkRuntimeImageFilter
)
;
}
sk_sp
<
SkFlattenable
>
SkRuntimeImageFilter
:
:
CreateProc
(
SkReadBuffer
&
buffer
)
{
SK_IMAGEFILTER_UNFLATTEN_COMMON
(
common
-
1
)
;
if
(
common
.
cropRect
(
)
)
{
return
nullptr
;
}
SkString
sksl
;
buffer
.
readString
(
&
sksl
)
;
auto
effect
=
SkMakeCachedRuntimeEffect
(
SkRuntimeEffect
:
:
MakeForShader
std
:
:
move
(
sksl
)
)
;
if
(
!
buffer
.
validate
(
effect
!
=
nullptr
)
)
{
return
nullptr
;
}
sk_sp
<
SkData
>
uniforms
=
buffer
.
readByteArrayAsData
(
)
;
if
(
!
buffer
.
validate
(
uniforms
-
>
size
(
)
=
=
effect
-
>
uniformSize
(
)
)
)
{
return
nullptr
;
}
STArray
<
4
std
:
:
string_view
>
childShaderNames
;
STArray
<
4
SkString
>
childShaderNameStrings
;
childShaderNames
.
resize
(
common
.
inputCount
(
)
)
;
childShaderNameStrings
.
resize
(
common
.
inputCount
(
)
)
;
for
(
int
i
=
0
;
i
<
common
.
inputCount
(
)
;
i
+
+
)
{
buffer
.
readString
(
&
childShaderNameStrings
[
i
]
)
;
childShaderNames
[
i
]
=
childShaderNameStrings
[
i
]
.
c_str
(
)
;
}
SkRuntimeShaderBuilder
builder
(
std
:
:
move
(
effect
)
std
:
:
move
(
uniforms
)
)
;
for
(
const
SkRuntimeEffect
:
:
Child
&
child
:
builder
.
effect
(
)
-
>
children
(
)
)
{
std
:
:
string_view
name
=
child
.
name
;
switch
(
child
.
type
)
{
case
SkRuntimeEffect
:
:
ChildType
:
:
kBlender
:
{
builder
.
child
(
name
)
=
buffer
.
readBlender
(
)
;
break
;
}
case
SkRuntimeEffect
:
:
ChildType
:
:
kColorFilter
:
{
builder
.
child
(
name
)
=
buffer
.
readColorFilter
(
)
;
break
;
}
case
SkRuntimeEffect
:
:
ChildType
:
:
kShader
:
{
builder
.
child
(
name
)
=
buffer
.
readShader
(
)
;
break
;
}
}
}
float
maxSampleRadius
=
0
.
f
;
if
(
!
buffer
.
isVersionLT
(
SkPicturePriv
:
:
kRuntimeImageFilterSampleRadius
)
)
{
maxSampleRadius
=
buffer
.
readScalar
(
)
;
}
if
(
!
buffer
.
isValid
(
)
)
{
return
nullptr
;
}
return
SkImageFilters
:
:
RuntimeShader
(
builder
maxSampleRadius
childShaderNames
.
data
(
)
common
.
inputs
(
)
common
.
inputCount
(
)
)
;
}
void
SkRuntimeImageFilter
:
:
flatten
(
SkWriteBuffer
&
buffer
)
const
{
this
-
>
SkImageFilter_Base
:
:
flatten
(
buffer
)
;
fRuntimeEffectLock
.
acquire
(
)
;
buffer
.
writeString
(
fRuntimeEffectBuilder
.
effect
(
)
-
>
source
(
)
.
c_str
(
)
)
;
buffer
.
writeDataAsByteArray
(
fRuntimeEffectBuilder
.
uniforms
(
)
.
get
(
)
)
;
for
(
const
SkString
&
name
:
fChildShaderNames
)
{
buffer
.
writeString
(
name
.
c_str
(
)
)
;
}
for
(
size_t
x
=
0
;
x
<
fRuntimeEffectBuilder
.
children
(
)
.
size
(
)
;
x
+
+
)
{
buffer
.
writeFlattenable
(
fRuntimeEffectBuilder
.
children
(
)
[
x
]
.
flattenable
(
)
)
;
}
fRuntimeEffectLock
.
release
(
)
;
buffer
.
writeScalar
(
fMaxSampleRadius
)
;
}
skif
:
:
FilterResult
SkRuntimeImageFilter
:
:
onFilterImage
(
const
skif
:
:
Context
&
ctx
)
const
{
using
ShaderFlags
=
skif
:
:
FilterResult
:
:
ShaderFlags
;
const
int
inputCount
=
this
-
>
countInputs
(
)
;
SkASSERT
(
inputCount
=
=
fChildShaderNames
.
size
(
)
)
;
skif
:
:
Context
inputCtx
=
ctx
.
withNewDesiredOutput
(
this
-
>
applyMaxSampleRadius
(
ctx
.
mapping
(
)
ctx
.
desiredOutput
(
)
)
)
;
skif
:
:
FilterResult
:
:
Builder
builder
{
ctx
}
;
for
(
int
i
=
0
;
i
<
inputCount
;
+
+
i
)
{
builder
.
add
(
this
-
>
getChildOutput
(
i
inputCtx
)
inputCtx
.
desiredOutput
(
)
ShaderFlags
:
:
kNonTrivialSampling
)
;
}
return
builder
.
eval
(
[
&
]
(
SkSpan
<
sk_sp
<
SkShader
>
>
inputs
)
{
fRuntimeEffectLock
.
acquire
(
)
;
for
(
int
i
=
0
;
i
<
inputCount
;
i
+
+
)
{
fRuntimeEffectBuilder
.
child
(
fChildShaderNames
[
i
]
.
c_str
(
)
)
=
inputs
[
i
]
;
}
sk_sp
<
SkShader
>
shader
=
fRuntimeEffectBuilder
.
makeShader
(
)
;
for
(
int
i
=
0
;
i
<
inputCount
;
i
+
+
)
{
fRuntimeEffectBuilder
.
child
(
fChildShaderNames
[
i
]
.
c_str
(
)
)
=
nullptr
;
}
fRuntimeEffectLock
.
release
(
)
;
return
shader
;
}
{
}
true
)
;
}
skif
:
:
LayerSpace
<
SkIRect
>
SkRuntimeImageFilter
:
:
onGetInputLayerBounds
(
const
skif
:
:
Mapping
&
mapping
const
skif
:
:
LayerSpace
<
SkIRect
>
&
desiredOutput
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
contentBounds
)
const
{
const
int
inputCount
=
this
-
>
countInputs
(
)
;
if
(
inputCount
<
=
0
)
{
return
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Empty
(
)
;
}
else
{
skif
:
:
LayerSpace
<
SkIRect
>
requiredInput
=
this
-
>
applyMaxSampleRadius
(
mapping
desiredOutput
)
;
return
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Union
(
inputCount
[
&
]
(
int
i
)
{
return
this
-
>
getChildInputLayerBounds
(
i
mapping
requiredInput
contentBounds
)
;
}
)
;
}
}
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
SkRuntimeImageFilter
:
:
onGetOutputLayerBounds
(
const
skif
:
:
Mapping
&
std
:
:
optional
<
skif
:
:
LayerSpace
<
SkIRect
>
>
)
const
{
return
skif
:
:
LayerSpace
<
SkIRect
>
:
:
Unbounded
(
)
;
}
SkRect
SkRuntimeImageFilter
:
:
computeFastBounds
(
const
SkRect
&
src
)
const
{
return
SkRectPriv
:
:
MakeLargeS32
(
)
;
}
