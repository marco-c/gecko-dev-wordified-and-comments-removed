#
include
"
SkPerlinNoiseShader
.
h
"
#
include
"
SkColorFilter
.
h
"
#
include
"
SkReadBuffer
.
h
"
#
include
"
SkWriteBuffer
.
h
"
#
include
"
SkShader
.
h
"
#
include
"
SkUnPreMultiply
.
h
"
#
include
"
SkString
.
h
"
#
if
SK_SUPPORT_GPU
#
include
"
GrContext
.
h
"
#
include
"
GrCoordTransform
.
h
"
#
include
"
GrInvariantOutput
.
h
"
#
include
"
SkGr
.
h
"
#
include
"
effects
/
GrConstColorProcessor
.
h
"
#
include
"
glsl
/
GrGLSLFragmentProcessor
.
h
"
#
include
"
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
glsl
/
GrGLSLProgramDataManager
.
h
"
#
include
"
glsl
/
GrGLSLUniformHandler
.
h
"
#
endif
static
const
int
kBlockSize
=
256
;
static
const
int
kBlockMask
=
kBlockSize
-
1
;
static
const
int
kPerlinNoise
=
4096
;
static
const
int
kRandMaximum
=
SK_MaxS32
;
namespace
{
inline
int
checkNoise
(
int
noiseValue
int
limitValue
int
newValue
)
{
if
(
noiseValue
>
=
limitValue
)
{
noiseValue
-
=
newValue
;
}
return
noiseValue
;
}
inline
SkScalar
smoothCurve
(
SkScalar
t
)
{
static
const
SkScalar
SK_Scalar3
=
3
.
0f
;
return
SkScalarMul
(
SkScalarSquare
(
t
)
SK_Scalar3
-
2
*
t
)
;
}
}
struct
SkPerlinNoiseShader
:
:
StitchData
{
StitchData
(
)
:
fWidth
(
0
)
fWrapX
(
0
)
fHeight
(
0
)
fWrapY
(
0
)
{
}
bool
operator
=
=
(
const
StitchData
&
other
)
const
{
return
fWidth
=
=
other
.
fWidth
&
&
fWrapX
=
=
other
.
fWrapX
&
&
fHeight
=
=
other
.
fHeight
&
&
fWrapY
=
=
other
.
fWrapY
;
}
int
fWidth
;
int
fWrapX
;
int
fHeight
;
int
fWrapY
;
}
;
struct
SkPerlinNoiseShader
:
:
PaintingData
{
PaintingData
(
const
SkISize
&
tileSize
SkScalar
seed
SkScalar
baseFrequencyX
SkScalar
baseFrequencyY
const
SkMatrix
&
matrix
)
{
SkVector
vec
[
2
]
=
{
{
SkScalarInvert
(
baseFrequencyX
)
SkScalarInvert
(
baseFrequencyY
)
}
{
SkIntToScalar
(
tileSize
.
fWidth
)
SkIntToScalar
(
tileSize
.
fHeight
)
}
}
;
matrix
.
mapVectors
(
vec
2
)
;
fBaseFrequency
.
set
(
SkScalarInvert
(
vec
[
0
]
.
fX
)
SkScalarInvert
(
vec
[
0
]
.
fY
)
)
;
fTileSize
.
set
(
SkScalarRoundToInt
(
vec
[
1
]
.
fX
)
SkScalarRoundToInt
(
vec
[
1
]
.
fY
)
)
;
this
-
>
init
(
seed
)
;
if
(
!
fTileSize
.
isEmpty
(
)
)
{
this
-
>
stitch
(
)
;
}
#
if
SK_SUPPORT_GPU
fPermutationsBitmap
.
setInfo
(
SkImageInfo
:
:
MakeA8
(
kBlockSize
1
)
)
;
fPermutationsBitmap
.
setPixels
(
fLatticeSelector
)
;
fNoiseBitmap
.
setInfo
(
SkImageInfo
:
:
MakeN32Premul
(
kBlockSize
4
)
)
;
fNoiseBitmap
.
setPixels
(
fNoise
[
0
]
[
0
]
)
;
#
endif
}
int
fSeed
;
uint8_t
fLatticeSelector
[
kBlockSize
]
;
uint16_t
fNoise
[
4
]
[
kBlockSize
]
[
2
]
;
SkPoint
fGradient
[
4
]
[
kBlockSize
]
;
SkISize
fTileSize
;
SkVector
fBaseFrequency
;
StitchData
fStitchDataInit
;
private
:
#
if
SK_SUPPORT_GPU
SkBitmap
fPermutationsBitmap
;
SkBitmap
fNoiseBitmap
;
#
endif
inline
int
random
(
)
{
static
const
int
gRandAmplitude
=
16807
;
static
const
int
gRandQ
=
127773
;
static
const
int
gRandR
=
2836
;
int
result
=
gRandAmplitude
*
(
fSeed
%
gRandQ
)
-
gRandR
*
(
fSeed
/
gRandQ
)
;
if
(
result
<
=
0
)
result
+
=
kRandMaximum
;
fSeed
=
result
;
return
result
;
}
void
init
(
SkScalar
seed
)
{
static
const
SkScalar
gInvBlockSizef
=
SkScalarInvert
(
SkIntToScalar
(
kBlockSize
)
)
;
fSeed
=
SkScalarTruncToInt
(
seed
)
;
if
(
fSeed
<
=
0
)
{
fSeed
=
-
(
fSeed
%
(
kRandMaximum
-
1
)
)
+
1
;
}
if
(
fSeed
>
kRandMaximum
-
1
)
{
fSeed
=
kRandMaximum
-
1
;
}
for
(
int
channel
=
0
;
channel
<
4
;
+
+
channel
)
{
for
(
int
i
=
0
;
i
<
kBlockSize
;
+
+
i
)
{
fLatticeSelector
[
i
]
=
i
;
fNoise
[
channel
]
[
i
]
[
0
]
=
(
random
(
)
%
(
2
*
kBlockSize
)
)
;
fNoise
[
channel
]
[
i
]
[
1
]
=
(
random
(
)
%
(
2
*
kBlockSize
)
)
;
}
}
for
(
int
i
=
kBlockSize
-
1
;
i
>
0
;
-
-
i
)
{
int
k
=
fLatticeSelector
[
i
]
;
int
j
=
random
(
)
%
kBlockSize
;
SkASSERT
(
j
>
=
0
)
;
SkASSERT
(
j
<
kBlockSize
)
;
fLatticeSelector
[
i
]
=
fLatticeSelector
[
j
]
;
fLatticeSelector
[
j
]
=
k
;
}
{
uint16_t
noise
[
4
]
[
kBlockSize
]
[
2
]
;
for
(
int
i
=
0
;
i
<
kBlockSize
;
+
+
i
)
{
for
(
int
channel
=
0
;
channel
<
4
;
+
+
channel
)
{
for
(
int
j
=
0
;
j
<
2
;
+
+
j
)
{
noise
[
channel
]
[
i
]
[
j
]
=
fNoise
[
channel
]
[
i
]
[
j
]
;
}
}
}
for
(
int
i
=
0
;
i
<
kBlockSize
;
+
+
i
)
{
for
(
int
channel
=
0
;
channel
<
4
;
+
+
channel
)
{
for
(
int
j
=
0
;
j
<
2
;
+
+
j
)
{
fNoise
[
channel
]
[
i
]
[
j
]
=
noise
[
channel
]
[
fLatticeSelector
[
i
]
]
[
j
]
;
}
}
}
}
static
const
SkScalar
gHalfMax16bits
=
32767
.
5f
;
for
(
int
channel
=
0
;
channel
<
4
;
+
+
channel
)
{
for
(
int
i
=
0
;
i
<
kBlockSize
;
+
+
i
)
{
fGradient
[
channel
]
[
i
]
=
SkPoint
:
:
Make
(
SkScalarMul
(
SkIntToScalar
(
fNoise
[
channel
]
[
i
]
[
0
]
-
kBlockSize
)
gInvBlockSizef
)
SkScalarMul
(
SkIntToScalar
(
fNoise
[
channel
]
[
i
]
[
1
]
-
kBlockSize
)
gInvBlockSizef
)
)
;
fGradient
[
channel
]
[
i
]
.
normalize
(
)
;
fNoise
[
channel
]
[
i
]
[
0
]
=
SkScalarRoundToInt
(
SkScalarMul
(
fGradient
[
channel
]
[
i
]
.
fX
+
SK_Scalar1
gHalfMax16bits
)
)
;
fNoise
[
channel
]
[
i
]
[
1
]
=
SkScalarRoundToInt
(
SkScalarMul
(
fGradient
[
channel
]
[
i
]
.
fY
+
SK_Scalar1
gHalfMax16bits
)
)
;
}
}
}
void
stitch
(
)
{
SkScalar
tileWidth
=
SkIntToScalar
(
fTileSize
.
width
(
)
)
;
SkScalar
tileHeight
=
SkIntToScalar
(
fTileSize
.
height
(
)
)
;
SkASSERT
(
tileWidth
>
0
&
&
tileHeight
>
0
)
;
if
(
fBaseFrequency
.
fX
)
{
SkScalar
lowFrequencx
=
SkScalarFloorToScalar
(
tileWidth
*
fBaseFrequency
.
fX
)
/
tileWidth
;
SkScalar
highFrequencx
=
SkScalarCeilToScalar
(
tileWidth
*
fBaseFrequency
.
fX
)
/
tileWidth
;
if
(
fBaseFrequency
.
fX
/
lowFrequencx
<
highFrequencx
/
fBaseFrequency
.
fX
)
{
fBaseFrequency
.
fX
=
lowFrequencx
;
}
else
{
fBaseFrequency
.
fX
=
highFrequencx
;
}
}
if
(
fBaseFrequency
.
fY
)
{
SkScalar
lowFrequency
=
SkScalarFloorToScalar
(
tileHeight
*
fBaseFrequency
.
fY
)
/
tileHeight
;
SkScalar
highFrequency
=
SkScalarCeilToScalar
(
tileHeight
*
fBaseFrequency
.
fY
)
/
tileHeight
;
if
(
fBaseFrequency
.
fY
/
lowFrequency
<
highFrequency
/
fBaseFrequency
.
fY
)
{
fBaseFrequency
.
fY
=
lowFrequency
;
}
else
{
fBaseFrequency
.
fY
=
highFrequency
;
}
}
fStitchDataInit
.
fWidth
=
SkScalarRoundToInt
(
tileWidth
*
fBaseFrequency
.
fX
)
;
fStitchDataInit
.
fWrapX
=
kPerlinNoise
+
fStitchDataInit
.
fWidth
;
fStitchDataInit
.
fHeight
=
SkScalarRoundToInt
(
tileHeight
*
fBaseFrequency
.
fY
)
;
fStitchDataInit
.
fWrapY
=
kPerlinNoise
+
fStitchDataInit
.
fHeight
;
}
public
:
#
if
SK_SUPPORT_GPU
const
SkBitmap
&
getPermutationsBitmap
(
)
const
{
return
fPermutationsBitmap
;
}
const
SkBitmap
&
getNoiseBitmap
(
)
const
{
return
fNoiseBitmap
;
}
#
endif
}
;
SkShader
*
SkPerlinNoiseShader
:
:
CreateFractalNoise
(
SkScalar
baseFrequencyX
SkScalar
baseFrequencyY
int
numOctaves
SkScalar
seed
const
SkISize
*
tileSize
)
{
return
new
SkPerlinNoiseShader
(
kFractalNoise_Type
baseFrequencyX
baseFrequencyY
numOctaves
seed
tileSize
)
;
}
SkShader
*
SkPerlinNoiseShader
:
:
CreateTurbulence
(
SkScalar
baseFrequencyX
SkScalar
baseFrequencyY
int
numOctaves
SkScalar
seed
const
SkISize
*
tileSize
)
{
return
new
SkPerlinNoiseShader
(
kTurbulence_Type
baseFrequencyX
baseFrequencyY
numOctaves
seed
tileSize
)
;
}
SkPerlinNoiseShader
:
:
SkPerlinNoiseShader
(
SkPerlinNoiseShader
:
:
Type
type
SkScalar
baseFrequencyX
SkScalar
baseFrequencyY
int
numOctaves
SkScalar
seed
const
SkISize
*
tileSize
)
:
fType
(
type
)
fBaseFrequencyX
(
baseFrequencyX
)
fBaseFrequencyY
(
baseFrequencyY
)
fNumOctaves
(
numOctaves
>
255
?
255
:
numOctaves
)
fSeed
(
seed
)
fTileSize
(
nullptr
=
=
tileSize
?
SkISize
:
:
Make
(
0
0
)
:
*
tileSize
)
fStitchTiles
(
!
fTileSize
.
isEmpty
(
)
)
{
SkASSERT
(
numOctaves
>
=
0
&
&
numOctaves
<
256
)
;
}
SkPerlinNoiseShader
:
:
~
SkPerlinNoiseShader
(
)
{
}
SkFlattenable
*
SkPerlinNoiseShader
:
:
CreateProc
(
SkReadBuffer
&
buffer
)
{
Type
type
=
(
Type
)
buffer
.
readInt
(
)
;
SkScalar
freqX
=
buffer
.
readScalar
(
)
;
SkScalar
freqY
=
buffer
.
readScalar
(
)
;
int
octaves
=
buffer
.
readInt
(
)
;
SkScalar
seed
=
buffer
.
readScalar
(
)
;
SkISize
tileSize
;
tileSize
.
fWidth
=
buffer
.
readInt
(
)
;
tileSize
.
fHeight
=
buffer
.
readInt
(
)
;
switch
(
type
)
{
case
kFractalNoise_Type
:
return
SkPerlinNoiseShader
:
:
CreateFractalNoise
(
freqX
freqY
octaves
seed
&
tileSize
)
;
case
kTurbulence_Type
:
return
SkPerlinNoiseShader
:
:
CreateTubulence
(
freqX
freqY
octaves
seed
&
tileSize
)
;
default
:
return
nullptr
;
}
}
void
SkPerlinNoiseShader
:
:
flatten
(
SkWriteBuffer
&
buffer
)
const
{
buffer
.
writeInt
(
(
int
)
fType
)
;
buffer
.
writeScalar
(
fBaseFrequencyX
)
;
buffer
.
writeScalar
(
fBaseFrequencyY
)
;
buffer
.
writeInt
(
fNumOctaves
)
;
buffer
.
writeScalar
(
fSeed
)
;
buffer
.
writeInt
(
fTileSize
.
fWidth
)
;
buffer
.
writeInt
(
fTileSize
.
fHeight
)
;
}
SkScalar
SkPerlinNoiseShader
:
:
PerlinNoiseShaderContext
:
:
noise2D
(
int
channel
const
StitchData
&
stitchData
const
SkPoint
&
noiseVector
)
const
{
struct
Noise
{
int
noisePositionIntegerValue
;
int
nextNoisePositionIntegerValue
;
SkScalar
noisePositionFractionValue
;
Noise
(
SkScalar
component
)
{
SkScalar
position
=
component
+
kPerlinNoise
;
noisePositionIntegerValue
=
SkScalarFloorToInt
(
position
)
;
noisePositionFractionValue
=
position
-
SkIntToScalar
(
noisePositionIntegerValue
)
;
nextNoisePositionIntegerValue
=
noisePositionIntegerValue
+
1
;
}
}
;
Noise
noiseX
(
noiseVector
.
x
(
)
)
;
Noise
noiseY
(
noiseVector
.
y
(
)
)
;
SkScalar
u
v
;
const
SkPerlinNoiseShader
&
perlinNoiseShader
=
static_cast
<
const
SkPerlinNoiseShader
&
>
(
fShader
)
;
if
(
perlinNoiseShader
.
fStitchTiles
)
{
noiseX
.
noisePositionIntegerValue
=
checkNoise
(
noiseX
.
noisePositionIntegerValue
stitchData
.
fWrapX
stitchData
.
fWidth
)
;
noiseY
.
noisePositionIntegerValue
=
checkNoise
(
noiseY
.
noisePositionIntegerValue
stitchData
.
fWrapY
stitchData
.
fHeight
)
;
noiseX
.
nextNoisePositionIntegerValue
=
checkNoise
(
noiseX
.
nextNoisePositionIntegerValue
stitchData
.
fWrapX
stitchData
.
fWidth
)
;
noiseY
.
nextNoisePositionIntegerValue
=
checkNoise
(
noiseY
.
nextNoisePositionIntegerValue
stitchData
.
fWrapY
stitchData
.
fHeight
)
;
}
noiseX
.
noisePositionIntegerValue
&
=
kBlockMask
;
noiseY
.
noisePositionIntegerValue
&
=
kBlockMask
;
noiseX
.
nextNoisePositionIntegerValue
&
=
kBlockMask
;
noiseY
.
nextNoisePositionIntegerValue
&
=
kBlockMask
;
int
i
=
fPaintingData
-
>
fLatticeSelector
[
noiseX
.
noisePositionIntegerValue
]
;
int
j
=
fPaintingData
-
>
fLatticeSelector
[
noiseX
.
nextNoisePositionIntegerValue
]
;
int
b00
=
(
i
+
noiseY
.
noisePositionIntegerValue
)
&
kBlockMask
;
int
b10
=
(
j
+
noiseY
.
noisePositionIntegerValue
)
&
kBlockMask
;
int
b01
=
(
i
+
noiseY
.
nextNoisePositionIntegerValue
)
&
kBlockMask
;
int
b11
=
(
j
+
noiseY
.
nextNoisePositionIntegerValue
)
&
kBlockMask
;
SkScalar
sx
=
smoothCurve
(
noiseX
.
noisePositionFractionValue
)
;
SkScalar
sy
=
smoothCurve
(
noiseY
.
noisePositionFractionValue
)
;
SkPoint
fractionValue
=
SkPoint
:
:
Make
(
noiseX
.
noisePositionFractionValue
noiseY
.
noisePositionFractionValue
)
;
u
=
fPaintingData
-
>
fGradient
[
channel
]
[
b00
]
.
dot
(
fractionValue
)
;
fractionValue
.
fX
-
=
SK_Scalar1
;
v
=
fPaintingData
-
>
fGradient
[
channel
]
[
b10
]
.
dot
(
fractionValue
)
;
SkScalar
a
=
SkScalarInterp
(
u
v
sx
)
;
fractionValue
.
fY
-
=
SK_Scalar1
;
v
=
fPaintingData
-
>
fGradient
[
channel
]
[
b11
]
.
dot
(
fractionValue
)
;
fractionValue
.
fX
=
noiseX
.
noisePositionFractionValue
;
u
=
fPaintingData
-
>
fGradient
[
channel
]
[
b01
]
.
dot
(
fractionValue
)
;
SkScalar
b
=
SkScalarInterp
(
u
v
sx
)
;
return
SkScalarInterp
(
a
b
sy
)
;
}
SkScalar
SkPerlinNoiseShader
:
:
PerlinNoiseShaderContext
:
:
calculateTurbulenceValueForPoint
(
int
channel
StitchData
&
stitchData
const
SkPoint
&
point
)
const
{
const
SkPerlinNoiseShader
&
perlinNoiseShader
=
static_cast
<
const
SkPerlinNoiseShader
&
>
(
fShader
)
;
if
(
perlinNoiseShader
.
fStitchTiles
)
{
stitchData
=
fPaintingData
-
>
fStitchDataInit
;
}
SkScalar
turbulenceFunctionResult
=
0
;
SkPoint
noiseVector
(
SkPoint
:
:
Make
(
SkScalarMul
(
point
.
x
(
)
fPaintingData
-
>
fBaseFrequency
.
fX
)
SkScalarMul
(
point
.
y
(
)
fPaintingData
-
>
fBaseFrequency
.
fY
)
)
)
;
SkScalar
ratio
=
SK_Scalar1
;
for
(
int
octave
=
0
;
octave
<
perlinNoiseShader
.
fNumOctaves
;
+
+
octave
)
{
SkScalar
noise
=
noise2D
(
channel
stitchData
noiseVector
)
;
SkScalar
numer
=
(
perlinNoiseShader
.
fType
=
=
kFractalNoise_Type
)
?
noise
:
SkScalarAbs
(
noise
)
;
turbulenceFunctionResult
+
=
numer
/
ratio
;
noiseVector
.
fX
*
=
2
;
noiseVector
.
fY
*
=
2
;
ratio
*
=
2
;
if
(
perlinNoiseShader
.
fStitchTiles
)
{
stitchData
.
fWidth
*
=
2
;
stitchData
.
fWrapX
=
stitchData
.
fWidth
+
kPerlinNoise
;
stitchData
.
fHeight
*
=
2
;
stitchData
.
fWrapY
=
stitchData
.
fHeight
+
kPerlinNoise
;
}
}
if
(
perlinNoiseShader
.
fType
=
=
kFractalNoise_Type
)
{
turbulenceFunctionResult
=
SkScalarMul
(
turbulenceFunctionResult
SK_ScalarHalf
)
+
SK_ScalarHalf
;
}
if
(
channel
=
=
3
)
{
turbulenceFunctionResult
*
=
SkIntToScalar
(
getPaintAlpha
(
)
)
/
255
;
}
return
SkScalarPin
(
turbulenceFunctionResult
0
SK_Scalar1
)
;
}
SkPMColor
SkPerlinNoiseShader
:
:
PerlinNoiseShaderContext
:
:
shade
(
const
SkPoint
&
point
StitchData
&
stitchData
)
const
{
SkPoint
newPoint
;
fMatrix
.
mapPoints
(
&
newPoint
&
point
1
)
;
newPoint
.
fX
=
SkScalarRoundToScalar
(
newPoint
.
fX
)
;
newPoint
.
fY
=
SkScalarRoundToScalar
(
newPoint
.
fY
)
;
U8CPU
rgba
[
4
]
;
for
(
int
channel
=
3
;
channel
>
=
0
;
-
-
channel
)
{
rgba
[
channel
]
=
SkScalarFloorToInt
(
255
*
calculateTurbulenceValueForPoint
(
channel
stitchData
newPoint
)
)
;
}
return
SkPreMultiplyARGB
(
rgba
[
3
]
rgba
[
0
]
rgba
[
1
]
rgba
[
2
]
)
;
}
SkShader
:
:
Context
*
SkPerlinNoiseShader
:
:
onCreateContext
(
const
ContextRec
&
rec
void
*
storage
)
const
{
return
new
(
storage
)
PerlinNoiseShaderContext
(
*
this
rec
)
;
}
size_t
SkPerlinNoiseShader
:
:
contextSize
(
)
const
{
return
sizeof
(
PerlinNoiseShaderContext
)
;
}
SkPerlinNoiseShader
:
:
PerlinNoiseShaderContext
:
:
PerlinNoiseShaderContext
(
const
SkPerlinNoiseShader
&
shader
const
ContextRec
&
rec
)
:
INHERITED
(
shader
rec
)
{
SkMatrix
newMatrix
=
*
rec
.
fMatrix
;
newMatrix
.
preConcat
(
shader
.
getLocalMatrix
(
)
)
;
if
(
rec
.
fLocalMatrix
)
{
newMatrix
.
preConcat
(
*
rec
.
fLocalMatrix
)
;
}
fMatrix
.
setTranslate
(
-
newMatrix
.
getTranslateX
(
)
+
SK_Scalar1
-
newMatrix
.
getTranslateY
(
)
+
SK_Scalar1
)
;
fPaintingData
=
new
PaintingData
(
shader
.
fTileSize
shader
.
fSeed
shader
.
fBaseFrequencyX
shader
.
fBaseFrequencyY
newMatrix
)
;
}
SkPerlinNoiseShader
:
:
PerlinNoiseShaderContext
:
:
~
PerlinNoiseShaderContext
(
)
{
delete
fPaintingData
;
}
void
SkPerlinNoiseShader
:
:
PerlinNoiseShaderContext
:
:
shadeSpan
(
int
x
int
y
SkPMColor
result
[
]
int
count
)
{
SkPoint
point
=
SkPoint
:
:
Make
(
SkIntToScalar
(
x
)
SkIntToScalar
(
y
)
)
;
StitchData
stitchData
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
result
[
i
]
=
shade
(
point
stitchData
)
;
point
.
fX
+
=
SK_Scalar1
;
}
}
#
if
SK_SUPPORT_GPU
class
GrGLPerlinNoise
:
public
GrGLSLFragmentProcessor
{
public
:
GrGLPerlinNoise
(
const
GrProcessor
&
)
;
virtual
~
GrGLPerlinNoise
(
)
{
}
virtual
void
emitCode
(
EmitArgs
&
)
override
;
static
inline
void
GenKey
(
const
GrProcessor
&
const
GrGLSLCaps
&
GrProcessorKeyBuilder
*
b
)
;
protected
:
void
onSetData
(
const
GrGLSLProgramDataManager
&
const
GrProcessor
&
)
override
;
private
:
GrGLSLProgramDataManager
:
:
UniformHandle
fStitchDataUni
;
SkPerlinNoiseShader
:
:
Type
fType
;
bool
fStitchTiles
;
int
fNumOctaves
;
GrGLSLProgramDataManager
:
:
UniformHandle
fBaseFrequencyUni
;
private
:
typedef
GrGLSLFragmentProcessor
INHERITED
;
}
;
class
GrPerlinNoiseEffect
:
public
GrFragmentProcessor
{
public
:
static
GrFragmentProcessor
*
Create
(
SkPerlinNoiseShader
:
:
Type
type
int
numOctaves
bool
stitchTiles
SkPerlinNoiseShader
:
:
PaintingData
*
paintingData
GrTexture
*
permutationsTexture
GrTexture
*
noiseTexture
const
SkMatrix
&
matrix
)
{
return
new
GrPerlinNoiseEffect
(
type
numOctaves
stitchTiles
paintingData
permutationsTexture
noiseTexture
matrix
)
;
}
virtual
~
GrPerlinNoiseEffect
(
)
{
delete
fPaintingData
;
}
const
char
*
name
(
)
const
override
{
return
"
PerlinNoise
"
;
}
const
SkPerlinNoiseShader
:
:
StitchData
&
stitchData
(
)
const
{
return
fPaintingData
-
>
fStitchDataInit
;
}
SkPerlinNoiseShader
:
:
Type
type
(
)
const
{
return
fType
;
}
bool
stitchTiles
(
)
const
{
return
fStitchTiles
;
}
const
SkVector
&
baseFrequency
(
)
const
{
return
fPaintingData
-
>
fBaseFrequency
;
}
int
numOctaves
(
)
const
{
return
fNumOctaves
;
}
const
SkMatrix
&
matrix
(
)
const
{
return
fCoordTransform
.
getMatrix
(
)
;
}
private
:
GrGLSLFragmentProcessor
*
onCreateGLSLInstance
(
)
const
override
{
return
new
GrGLPerlinNoise
(
*
this
)
;
}
virtual
void
onGetGLSLProcessorKey
(
const
GrGLSLCaps
&
caps
GrProcessorKeyBuilder
*
b
)
const
override
{
GrGLPerlinNoise
:
:
GenKey
(
*
this
caps
b
)
;
}
bool
onIsEqual
(
const
GrFragmentProcessor
&
sBase
)
const
override
{
const
GrPerlinNoiseEffect
&
s
=
sBase
.
cast
<
GrPerlinNoiseEffect
>
(
)
;
return
fType
=
=
s
.
fType
&
&
fPaintingData
-
>
fBaseFrequency
=
=
s
.
fPaintingData
-
>
fBaseFrequency
&
&
fNumOctaves
=
=
s
.
fNumOctaves
&
&
fStitchTiles
=
=
s
.
fStitchTiles
&
&
fPaintingData
-
>
fStitchDataInit
=
=
s
.
fPaintingData
-
>
fStitchDataInit
;
}
void
onComputeInvariantOutput
(
GrInvariantOutput
*
inout
)
const
override
{
inout
-
>
setToUnknown
(
GrInvariantOutput
:
:
kWillNot_ReadInput
)
;
}
GrPerlinNoiseEffect
(
SkPerlinNoiseShader
:
:
Type
type
int
numOctaves
bool
stitchTiles
SkPerlinNoiseShader
:
:
PaintingData
*
paintingData
GrTexture
*
permutationsTexture
GrTexture
*
noiseTexture
const
SkMatrix
&
matrix
)
:
fType
(
type
)
fNumOctaves
(
numOctaves
)
fStitchTiles
(
stitchTiles
)
fPermutationsAccess
(
permutationsTexture
)
fNoiseAccess
(
noiseTexture
)
fPaintingData
(
paintingData
)
{
this
-
>
initClassID
<
GrPerlinNoiseEffect
>
(
)
;
this
-
>
addTextureAccess
(
&
fPermutationsAccess
)
;
this
-
>
addTextureAccess
(
&
fNoiseAccess
)
;
fCoordTransform
.
reset
(
kLocal_GrCoordSet
matrix
)
;
this
-
>
addCoordTransform
(
&
fCoordTransform
)
;
}
GR_DECLARE_FRAGMENT_PROCESSOR_TEST
;
SkPerlinNoiseShader
:
:
Type
fType
;
GrCoordTransform
fCoordTransform
;
int
fNumOctaves
;
bool
fStitchTiles
;
GrTextureAccess
fPermutationsAccess
;
GrTextureAccess
fNoiseAccess
;
SkPerlinNoiseShader
:
:
PaintingData
*
fPaintingData
;
private
:
typedef
GrFragmentProcessor
INHERITED
;
}
;
GR_DEFINE_FRAGMENT_PROCESSOR_TEST
(
GrPerlinNoiseEffect
)
;
const
GrFragmentProcessor
*
GrPerlinNoiseEffect
:
:
TestCreate
(
GrProcessorTestData
*
d
)
{
int
numOctaves
=
d
-
>
fRandom
-
>
nextRangeU
(
2
10
)
;
bool
stitchTiles
=
d
-
>
fRandom
-
>
nextBool
(
)
;
SkScalar
seed
=
SkIntToScalar
(
d
-
>
fRandom
-
>
nextU
(
)
)
;
SkISize
tileSize
=
SkISize
:
:
Make
(
d
-
>
fRandom
-
>
nextRangeU
(
4
4096
)
d
-
>
fRandom
-
>
nextRangeU
(
4
4096
)
)
;
SkScalar
baseFrequencyX
=
d
-
>
fRandom
-
>
nextRangeScalar
(
0
.
01f
0
.
99f
)
;
SkScalar
baseFrequencyY
=
d
-
>
fRandom
-
>
nextRangeScalar
(
0
.
01f
0
.
99f
)
;
SkAutoTUnref
<
SkShader
>
shader
(
d
-
>
fRandom
-
>
nextBool
(
)
?
SkPerlinNoiseShader
:
:
CreateFractalNoise
(
baseFrequencyX
baseFrequencyY
numOctaves
seed
stitchTiles
?
&
tileSize
:
nullptr
)
:
SkPerlinNoiseShader
:
:
CreateTurbulence
(
baseFrequencyX
baseFrequencyY
numOctaves
seed
stitchTiles
?
&
tileSize
:
nullptr
)
)
;
return
shader
-
>
asFragmentProcessor
(
d
-
>
fContext
GrTest
:
:
TestMatrix
(
d
-
>
fRandom
)
nullptr
kNone_SkFilterQuality
)
;
}
GrGLPerlinNoise
:
:
GrGLPerlinNoise
(
const
GrProcessor
&
processor
)
:
fType
(
processor
.
cast
<
GrPerlinNoiseEffect
>
(
)
.
type
(
)
)
fStitchTiles
(
processor
.
cast
<
GrPerlinNoiseEffect
>
(
)
.
stitchTiles
(
)
)
fNumOctaves
(
processor
.
cast
<
GrPerlinNoiseEffect
>
(
)
.
numOctaves
(
)
)
{
}
void
GrGLPerlinNoise
:
:
emitCode
(
EmitArgs
&
args
)
{
GrGLSLFragmentBuilder
*
fragBuilder
=
args
.
fFragBuilder
;
GrGLSLUniformHandler
*
uniformHandler
=
args
.
fUniformHandler
;
SkString
vCoords
=
fragBuilder
-
>
ensureFSCoords2D
(
args
.
fCoords
0
)
;
fBaseFrequencyUni
=
uniformHandler
-
>
addUniform
(
GrGLSLUniformHandler
:
:
kFragment_Visibility
kVec2f_GrSLType
kDefault_GrSLPrecision
"
baseFrequency
"
)
;
const
char
*
baseFrequencyUni
=
uniformHandler
-
>
getUniformCStr
(
fBaseFrequencyUni
)
;
const
char
*
stitchDataUni
=
nullptr
;
if
(
fStitchTiles
)
{
fStitchDataUni
=
uniformHandler
-
>
addUniform
(
GrGLSLUniformHandler
:
:
kFragment_Visibility
kVec2f_GrSLType
kDefault_GrSLPrecision
"
stitchData
"
)
;
stitchDataUni
=
uniformHandler
-
>
getUniformCStr
(
fStitchDataUni
)
;
}
const
char
*
chanCoordR
=
"
0
.
125
"
;
const
char
*
chanCoordG
=
"
0
.
375
"
;
const
char
*
chanCoordB
=
"
0
.
625
"
;
const
char
*
chanCoordA
=
"
0
.
875
"
;
const
char
*
chanCoord
=
"
chanCoord
"
;
const
char
*
stitchData
=
"
stitchData
"
;
const
char
*
ratio
=
"
ratio
"
;
const
char
*
noiseVec
=
"
noiseVec
"
;
const
char
*
noiseSmooth
=
"
noiseSmooth
"
;
const
char
*
floorVal
=
"
floorVal
"
;
const
char
*
fractVal
=
"
fractVal
"
;
const
char
*
uv
=
"
uv
"
;
const
char
*
ab
=
"
ab
"
;
const
char
*
latticeIdx
=
"
latticeIdx
"
;
const
char
*
bcoords
=
"
bcoords
"
;
const
char
*
lattice
=
"
lattice
"
;
const
char
*
inc8bit
=
"
0
.
00390625
"
;
const
char
*
dotLattice
=
"
dot
(
(
(
%
s
.
ga
+
%
s
.
rb
*
vec2
(
%
s
)
)
*
vec2
(
2
.
0
)
-
vec2
(
1
.
0
)
)
%
s
)
;
"
;
static
const
GrGLSLShaderVar
gPerlinNoiseArgs
[
]
=
{
GrGLSLShaderVar
(
chanCoord
kFloat_GrSLType
)
GrGLSLShaderVar
(
noiseVec
kVec2f_GrSLType
)
}
;
static
const
GrGLSLShaderVar
gPerlinNoiseStitchArgs
[
]
=
{
GrGLSLShaderVar
(
chanCoord
kFloat_GrSLType
)
GrGLSLShaderVar
(
noiseVec
kVec2f_GrSLType
)
GrGLSLShaderVar
(
stitchData
kVec2f_GrSLType
)
}
;
SkString
noiseCode
;
noiseCode
.
appendf
(
"
\
tvec4
%
s
;
\
n
"
floorVal
)
;
noiseCode
.
appendf
(
"
\
t
%
s
.
xy
=
floor
(
%
s
)
;
\
n
"
floorVal
noiseVec
)
;
noiseCode
.
appendf
(
"
\
t
%
s
.
zw
=
%
s
.
xy
+
vec2
(
1
.
0
)
;
\
n
"
floorVal
floorVal
)
;
noiseCode
.
appendf
(
"
\
tvec2
%
s
=
fract
(
%
s
)
;
\
n
"
fractVal
noiseVec
)
;
noiseCode
.
appendf
(
"
\
n
\
tvec2
%
s
=
%
s
*
%
s
*
(
vec2
(
3
.
0
)
-
vec2
(
2
.
0
)
*
%
s
)
;
"
noiseSmooth
fractVal
fractVal
fractVal
)
;
if
(
fStitchTiles
)
{
noiseCode
.
appendf
(
"
\
n
\
tif
(
%
s
.
x
>
=
%
s
.
x
)
{
%
s
.
x
-
=
%
s
.
x
;
}
"
floorVal
stitchData
floorVal
stitchData
)
;
noiseCode
.
appendf
(
"
\
n
\
tif
(
%
s
.
y
>
=
%
s
.
y
)
{
%
s
.
y
-
=
%
s
.
y
;
}
"
floorVal
stitchData
floorVal
stitchData
)
;
noiseCode
.
appendf
(
"
\
n
\
tif
(
%
s
.
z
>
=
%
s
.
x
)
{
%
s
.
z
-
=
%
s
.
x
;
}
"
floorVal
stitchData
floorVal
stitchData
)
;
noiseCode
.
appendf
(
"
\
n
\
tif
(
%
s
.
w
>
=
%
s
.
y
)
{
%
s
.
w
-
=
%
s
.
y
;
}
"
floorVal
stitchData
floorVal
stitchData
)
;
}
noiseCode
.
appendf
(
"
\
n
\
t
%
s
=
fract
(
floor
(
mod
(
%
s
256
.
0
)
)
/
vec4
(
256
.
0
)
)
;
\
n
"
floorVal
floorVal
)
;
{
SkString
xCoords
(
"
"
)
;
xCoords
.
appendf
(
"
vec2
(
%
s
.
x
0
.
5
)
"
floorVal
)
;
noiseCode
.
appendf
(
"
\
n
\
tvec2
%
s
;
\
n
\
t
%
s
.
x
=
"
latticeIdx
latticeIdx
)
;
fragBuilder
-
>
appendTextureLookup
(
&
noiseCode
args
.
fSamplers
[
0
]
xCoords
.
c_str
(
)
kVec2f_GrSLType
)
;
noiseCode
.
append
(
"
.
r
;
"
)
;
}
{
SkString
xCoords
(
"
"
)
;
xCoords
.
appendf
(
"
vec2
(
%
s
.
z
0
.
5
)
"
floorVal
)
;
noiseCode
.
appendf
(
"
\
n
\
t
%
s
.
y
=
"
latticeIdx
)
;
fragBuilder
-
>
appendTextureLookup
(
&
noiseCode
args
.
fSamplers
[
0
]
xCoords
.
c_str
(
)
kVec2f_GrSLType
)
;
noiseCode
.
append
(
"
.
r
;
"
)
;
}
#
if
defined
(
SK_BUILD_FOR_ANDROID
)
noiseCode
.
appendf
(
"
\
n
\
t
%
s
=
floor
(
%
s
*
vec2
(
255
.
0
)
+
vec2
(
0
.
5
)
)
*
vec2
(
0
.
003921569
)
;
"
latticeIdx
latticeIdx
)
;
#
endif
noiseCode
.
appendf
(
"
\
n
\
tvec4
%
s
=
fract
(
%
s
.
xyxy
+
%
s
.
yyww
)
;
"
bcoords
latticeIdx
floorVal
)
;
noiseCode
.
appendf
(
"
\
n
\
n
\
tvec2
%
s
;
"
uv
)
;
{
SkString
latticeCoords
(
"
"
)
;
latticeCoords
.
appendf
(
"
vec2
(
%
s
.
x
%
s
)
"
bcoords
chanCoord
)
;
noiseCode
.
appendf
(
"
\
n
\
tvec4
%
s
=
"
lattice
)
;
fragBuilder
-
>
appendTextureLookup
(
&
noiseCode
args
.
fSamplers
[
1
]
latticeCoords
.
c_str
(
)
kVec2f_GrSLType
)
;
noiseCode
.
appendf
(
"
.
bgra
;
\
n
\
t
%
s
.
x
=
"
uv
)
;
noiseCode
.
appendf
(
dotLattice
lattice
lattice
inc8bit
fractVal
)
;
}
noiseCode
.
appendf
(
"
\
n
\
t
%
s
.
x
-
=
1
.
0
;
"
fractVal
)
;
{
SkString
latticeCoords
(
"
"
)
;
latticeCoords
.
appendf
(
"
vec2
(
%
s
.
y
%
s
)
"
bcoords
chanCoord
)
;
noiseCode
.
append
(
"
\
n
\
tlattice
=
"
)
;
fragBuilder
-
>
appendTextureLookup
(
&
noiseCode
args
.
fSamplers
[
1
]
latticeCoords
.
c_str
(
)
kVec2f_GrSLType
)
;
noiseCode
.
appendf
(
"
.
bgra
;
\
n
\
t
%
s
.
y
=
"
uv
)
;
noiseCode
.
appendf
(
dotLattice
lattice
lattice
inc8bit
fractVal
)
;
}
noiseCode
.
appendf
(
"
\
n
\
tvec2
%
s
;
"
ab
)
;
noiseCode
.
appendf
(
"
\
n
\
t
%
s
.
x
=
mix
(
%
s
.
x
%
s
.
y
%
s
.
x
)
;
"
ab
uv
uv
noiseSmooth
)
;
noiseCode
.
appendf
(
"
\
n
\
t
%
s
.
y
-
=
1
.
0
;
"
fractVal
)
;
{
SkString
latticeCoords
(
"
"
)
;
latticeCoords
.
appendf
(
"
vec2
(
%
s
.
w
%
s
)
"
bcoords
chanCoord
)
;
noiseCode
.
append
(
"
\
n
\
tlattice
=
"
)
;
fragBuilder
-
>
appendTextureLookup
(
&
noiseCode
args
.
fSamplers
[
1
]
latticeCoords
.
c_str
(
)
kVec2f_GrSLType
)
;
noiseCode
.
appendf
(
"
.
bgra
;
\
n
\
t
%
s
.
y
=
"
uv
)
;
noiseCode
.
appendf
(
dotLattice
lattice
lattice
inc8bit
fractVal
)
;
}
noiseCode
.
appendf
(
"
\
n
\
t
%
s
.
x
+
=
1
.
0
;
"
fractVal
)
;
{
SkString
latticeCoords
(
"
"
)
;
latticeCoords
.
appendf
(
"
vec2
(
%
s
.
z
%
s
)
"
bcoords
chanCoord
)
;
noiseCode
.
append
(
"
\
n
\
tlattice
=
"
)
;
fragBuilder
-
>
appendTextureLookup
(
&
noiseCode
args
.
fSamplers
[
1
]
latticeCoords
.
c_str
(
)
kVec2f_GrSLType
)
;
noiseCode
.
appendf
(
"
.
bgra
;
\
n
\
t
%
s
.
x
=
"
uv
)
;
noiseCode
.
appendf
(
dotLattice
lattice
lattice
inc8bit
fractVal
)
;
}
noiseCode
.
appendf
(
"
\
n
\
t
%
s
.
y
=
mix
(
%
s
.
x
%
s
.
y
%
s
.
x
)
;
"
ab
uv
uv
noiseSmooth
)
;
noiseCode
.
appendf
(
"
\
n
\
treturn
mix
(
%
s
.
x
%
s
.
y
%
s
.
y
)
;
\
n
"
ab
ab
noiseSmooth
)
;
SkString
noiseFuncName
;
if
(
fStitchTiles
)
{
fragBuilder
-
>
emitFunction
(
kFloat_GrSLType
"
perlinnoise
"
SK_ARRAY_COUNT
(
gPerlinNoiseStitchArgs
)
gPerlinNoiseStitchArgs
noiseCode
.
c_str
(
)
&
noiseFuncName
)
;
}
else
{
fragBuilder
-
>
emitFunction
(
kFloat_GrSLType
"
perlinnoise
"
SK_ARRAY_COUNT
(
gPerlinNoiseArgs
)
gPerlinNoiseArgs
noiseCode
.
c_str
(
)
&
noiseFuncName
)
;
}
fragBuilder
-
>
codeAppendf
(
"
\
n
\
t
\
tvec2
%
s
=
floor
(
%
s
.
xy
)
*
%
s
;
"
noiseVec
vCoords
.
c_str
(
)
baseFrequencyUni
)
;
fragBuilder
-
>
codeAppendf
(
"
\
n
\
t
\
t
%
s
=
vec4
(
0
.
0
)
;
"
args
.
fOutputColor
)
;
if
(
fStitchTiles
)
{
fragBuilder
-
>
codeAppendf
(
"
\
n
\
t
\
tvec2
%
s
=
%
s
;
"
stitchData
stitchDataUni
)
;
}
fragBuilder
-
>
codeAppendf
(
"
\
n
\
t
\
tfloat
%
s
=
1
.
0
;
"
ratio
)
;
fragBuilder
-
>
codeAppendf
(
"
\
n
\
t
\
tfor
(
int
octave
=
0
;
octave
<
%
d
;
+
+
octave
)
{
"
fNumOctaves
)
;
fragBuilder
-
>
codeAppendf
(
"
\
n
\
t
\
t
\
t
%
s
+
=
"
args
.
fOutputColor
)
;
if
(
fType
!
=
SkPerlinNoiseShader
:
:
kFractalNoise_Type
)
{
fragBuilder
-
>
codeAppend
(
"
abs
(
"
)
;
}
if
(
fStitchTiles
)
{
fragBuilder
-
>
codeAppendf
(
"
vec4
(
\
n
\
t
\
t
\
t
\
t
%
s
(
%
s
%
s
%
s
)
\
n
\
t
\
t
\
t
\
t
%
s
(
%
s
%
s
%
s
)
"
"
\
n
\
t
\
t
\
t
\
t
%
s
(
%
s
%
s
%
s
)
\
n
\
t
\
t
\
t
\
t
%
s
(
%
s
%
s
%
s
)
)
"
noiseFuncName
.
c_str
(
)
chanCoordR
noiseVec
stitchData
noiseFuncName
.
c_str
(
)
chanCoordG
noiseVec
stitchData
noiseFuncName
.
c_str
(
)
chanCoordB
noiseVec
stitchData
noiseFuncName
.
c_str
(
)
chanCoordA
noiseVec
stitchData
)
;
}
else
{
fragBuilder
-
>
codeAppendf
(
"
vec4
(
\
n
\
t
\
t
\
t
\
t
%
s
(
%
s
%
s
)
\
n
\
t
\
t
\
t
\
t
%
s
(
%
s
%
s
)
"
"
\
n
\
t
\
t
\
t
\
t
%
s
(
%
s
%
s
)
\
n
\
t
\
t
\
t
\
t
%
s
(
%
s
%
s
)
)
"
noiseFuncName
.
c_str
(
)
chanCoordR
noiseVec
noiseFuncName
.
c_str
(
)
chanCoordG
noiseVec
noiseFuncName
.
c_str
(
)
chanCoordB
noiseVec
noiseFuncName
.
c_str
(
)
chanCoordA
noiseVec
)
;
}
if
(
fType
!
=
SkPerlinNoiseShader
:
:
kFractalNoise_Type
)
{
fragBuilder
-
>
codeAppendf
(
"
)
"
)
;
}
fragBuilder
-
>
codeAppendf
(
"
*
%
s
;
"
ratio
)
;
fragBuilder
-
>
codeAppendf
(
"
\
n
\
t
\
t
\
t
%
s
*
=
vec2
(
2
.
0
)
;
"
noiseVec
)
;
fragBuilder
-
>
codeAppendf
(
"
\
n
\
t
\
t
\
t
%
s
*
=
0
.
5
;
"
ratio
)
;
if
(
fStitchTiles
)
{
fragBuilder
-
>
codeAppendf
(
"
\
n
\
t
\
t
\
t
%
s
*
=
vec2
(
2
.
0
)
;
"
stitchData
)
;
}
fragBuilder
-
>
codeAppend
(
"
\
n
\
t
\
t
}
"
)
;
if
(
fType
=
=
SkPerlinNoiseShader
:
:
kFractalNoise_Type
)
{
fragBuilder
-
>
codeAppendf
(
"
\
n
\
t
\
t
%
s
=
%
s
*
vec4
(
0
.
5
)
+
vec4
(
0
.
5
)
;
"
args
.
fOutputColor
args
.
fOutputColor
)
;
}
fragBuilder
-
>
codeAppendf
(
"
\
n
\
t
\
t
%
s
=
clamp
(
%
s
0
.
0
1
.
0
)
;
"
args
.
fOutputColor
args
.
fOutputColor
)
;
fragBuilder
-
>
codeAppendf
(
"
\
n
\
t
\
t
%
s
=
vec4
(
%
s
.
rgb
*
%
s
.
aaa
%
s
.
a
)
;
\
n
"
args
.
fOutputColor
args
.
fOutputColor
args
.
fOutputColor
args
.
fOutputColor
)
;
}
void
GrGLPerlinNoise
:
:
GenKey
(
const
GrProcessor
&
processor
const
GrGLSLCaps
&
GrProcessorKeyBuilder
*
b
)
{
const
GrPerlinNoiseEffect
&
turbulence
=
processor
.
cast
<
GrPerlinNoiseEffect
>
(
)
;
uint32_t
key
=
turbulence
.
numOctaves
(
)
;
key
=
key
<
<
3
;
switch
(
turbulence
.
type
(
)
)
{
case
SkPerlinNoiseShader
:
:
kFractalNoise_Type
:
key
|
=
0x1
;
break
;
case
SkPerlinNoiseShader
:
:
kTurbulence_Type
:
key
|
=
0x2
;
break
;
default
:
break
;
}
if
(
turbulence
.
stitchTiles
(
)
)
{
key
|
=
0x4
;
}
b
-
>
add32
(
key
)
;
}
void
GrGLPerlinNoise
:
:
onSetData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrProcessor
&
processor
)
{
INHERITED
:
:
onSetData
(
pdman
processor
)
;
const
GrPerlinNoiseEffect
&
turbulence
=
processor
.
cast
<
GrPerlinNoiseEffect
>
(
)
;
const
SkVector
&
baseFrequency
=
turbulence
.
baseFrequency
(
)
;
pdman
.
set2f
(
fBaseFrequencyUni
baseFrequency
.
fX
baseFrequency
.
fY
)
;
if
(
turbulence
.
stitchTiles
(
)
)
{
const
SkPerlinNoiseShader
:
:
StitchData
&
stitchData
=
turbulence
.
stitchData
(
)
;
pdman
.
set2f
(
fStitchDataUni
SkIntToScalar
(
stitchData
.
fWidth
)
SkIntToScalar
(
stitchData
.
fHeight
)
)
;
}
}
const
GrFragmentProcessor
*
SkPerlinNoiseShader
:
:
asFragmentProcessor
(
GrContext
*
context
const
SkMatrix
&
viewM
const
SkMatrix
*
externalLocalMatrix
SkFilterQuality
)
const
{
SkASSERT
(
context
)
;
SkMatrix
localMatrix
=
this
-
>
getLocalMatrix
(
)
;
if
(
externalLocalMatrix
)
{
localMatrix
.
preConcat
(
*
externalLocalMatrix
)
;
}
SkMatrix
matrix
=
viewM
;
matrix
.
preConcat
(
localMatrix
)
;
if
(
0
=
=
fNumOctaves
)
{
if
(
kFractalNoise_Type
=
=
fType
)
{
SkAutoTUnref
<
const
GrFragmentProcessor
>
inner
(
GrConstColorProcessor
:
:
Create
(
0x80404040
GrConstColorProcessor
:
:
kModulateRGBA_InputMode
)
)
;
return
GrFragmentProcessor
:
:
MulOutputByInputAlpha
(
inner
)
;
}
return
GrConstColorProcessor
:
:
Create
(
0x0
GrConstColorProcessor
:
:
kIgnore_InputMode
)
;
}
SkASSERT
(
!
fStitchTiles
|
|
!
fTileSize
.
isEmpty
(
)
)
;
SkPerlinNoiseShader
:
:
PaintingData
*
paintingData
=
new
PaintingData
(
fTileSize
fSeed
fBaseFrequencyX
fBaseFrequencyY
matrix
)
;
SkAutoTUnref
<
GrTexture
>
permutationsTexture
(
GrRefCachedBitmapTexture
(
context
paintingData
-
>
getPermutationsBitmap
(
)
GrTextureParams
:
:
ClampNoFilter
(
)
)
)
;
SkAutoTUnref
<
GrTexture
>
noiseTexture
(
GrRefCachedBitmapTexture
(
context
paintingData
-
>
getNoiseBitmap
(
)
GrTextureParams
:
:
ClampNoFilter
(
)
)
)
;
SkMatrix
m
=
viewM
;
m
.
setTranslateX
(
-
localMatrix
.
getTranslateX
(
)
+
SK_Scalar1
)
;
m
.
setTranslateY
(
-
localMatrix
.
getTranslateY
(
)
+
SK_Scalar1
)
;
if
(
(
permutationsTexture
)
&
&
(
noiseTexture
)
)
{
SkAutoTUnref
<
GrFragmentProcessor
>
inner
(
GrPerlinNoiseEffect
:
:
Create
(
fType
fNumOctaves
fStitchTiles
paintingData
permutationsTexture
noiseTexture
m
)
)
;
return
GrFragmentProcessor
:
:
MulOutputByInputAlpha
(
inner
)
;
}
delete
paintingData
;
return
nullptr
;
}
#
endif
#
ifndef
SK_IGNORE_TO_STRING
void
SkPerlinNoiseShader
:
:
toString
(
SkString
*
str
)
const
{
str
-
>
append
(
"
SkPerlinNoiseShader
:
(
"
)
;
str
-
>
append
(
"
type
:
"
)
;
switch
(
fType
)
{
case
kFractalNoise_Type
:
str
-
>
append
(
"
\
"
fractal
noise
\
"
"
)
;
break
;
case
kTurbulence_Type
:
str
-
>
append
(
"
\
"
turbulence
\
"
"
)
;
break
;
default
:
str
-
>
append
(
"
\
"
unknown
\
"
"
)
;
break
;
}
str
-
>
append
(
"
base
frequency
:
(
"
)
;
str
-
>
appendScalar
(
fBaseFrequencyX
)
;
str
-
>
append
(
"
"
)
;
str
-
>
appendScalar
(
fBaseFrequencyY
)
;
str
-
>
append
(
"
)
number
of
octaves
:
"
)
;
str
-
>
appendS32
(
fNumOctaves
)
;
str
-
>
append
(
"
seed
:
"
)
;
str
-
>
appendScalar
(
fSeed
)
;
str
-
>
append
(
"
stitch
tiles
:
"
)
;
str
-
>
append
(
fStitchTiles
?
"
true
"
:
"
false
"
)
;
this
-
>
INHERITED
:
:
toString
(
str
)
;
str
-
>
append
(
"
)
"
)
;
}
#
endif
