#
include
"
GrCircleBlurFragmentProcessor
.
h
"
#
if
SK_SUPPORT_GPU
#
include
"
GrContext
.
h
"
#
include
"
GrInvariantOutput
.
h
"
#
include
"
GrTextureProvider
.
h
"
#
include
"
glsl
/
GrGLSLFragmentProcessor
.
h
"
#
include
"
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
glsl
/
GrGLSLProgramDataManager
.
h
"
#
include
"
glsl
/
GrGLSLUniformHandler
.
h
"
#
include
"
SkFixed
.
h
"
class
GrCircleBlurFragmentProcessor
:
:
GLSLProcessor
:
public
GrGLSLFragmentProcessor
{
public
:
void
emitCode
(
EmitArgs
&
)
override
;
protected
:
void
onSetData
(
const
GrGLSLProgramDataManager
&
const
GrProcessor
&
)
override
;
private
:
GrGLSLProgramDataManager
:
:
UniformHandle
fDataUniform
;
typedef
GrGLSLFragmentProcessor
INHERITED
;
}
;
void
GrCircleBlurFragmentProcessor
:
:
GLSLProcessor
:
:
emitCode
(
EmitArgs
&
args
)
{
const
char
*
dataName
;
fDataUniform
=
args
.
fUniformHandler
-
>
addUniform
(
kFragment_GrShaderFlag
kVec4f_GrSLType
kDefault_GrSLPrecision
"
data
"
&
dataName
)
;
GrGLSLFPFragmentBuilder
*
fragBuilder
=
args
.
fFragBuilder
;
const
char
*
fragmentPos
=
fragBuilder
-
>
fragmentPosition
(
)
;
if
(
args
.
fInputColor
)
{
fragBuilder
-
>
codeAppendf
(
"
vec4
src
=
%
s
;
"
args
.
fInputColor
)
;
}
else
{
fragBuilder
-
>
codeAppendf
(
"
vec4
src
=
vec4
(
1
)
;
"
)
;
}
fragBuilder
-
>
codeAppendf
(
"
vec2
vec
=
vec2
(
(
%
s
.
x
-
%
s
.
x
)
*
%
s
.
w
(
%
s
.
y
-
%
s
.
y
)
*
%
s
.
w
)
;
"
fragmentPos
dataName
dataName
fragmentPos
dataName
dataName
)
;
fragBuilder
-
>
codeAppendf
(
"
float
dist
=
length
(
vec
)
+
(
0
.
5
-
%
s
.
z
)
*
%
s
.
w
;
"
dataName
dataName
)
;
fragBuilder
-
>
codeAppendf
(
"
float
intensity
=
"
)
;
fragBuilder
-
>
appendTextureLookup
(
args
.
fTexSamplers
[
0
]
"
vec2
(
dist
0
.
5
)
"
)
;
fragBuilder
-
>
codeAppend
(
"
.
a
;
"
)
;
fragBuilder
-
>
codeAppendf
(
"
%
s
=
src
*
intensity
;
\
n
"
args
.
fOutputColor
)
;
}
void
GrCircleBlurFragmentProcessor
:
:
GLSLProcessor
:
:
onSetData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrProcessor
&
proc
)
{
const
GrCircleBlurFragmentProcessor
&
cbfp
=
proc
.
cast
<
GrCircleBlurFragmentProcessor
>
(
)
;
const
SkRect
&
circle
=
cbfp
.
fCircle
;
pdman
.
set4f
(
fDataUniform
circle
.
centerX
(
)
circle
.
centerY
(
)
cbfp
.
fSolidRadius
1
.
f
/
cbfp
.
fTextureRadius
)
;
}
GrCircleBlurFragmentProcessor
:
:
GrCircleBlurFragmentProcessor
(
const
SkRect
&
circle
float
textureRadius
float
solidRadius
GrTexture
*
blurProfile
)
:
fCircle
(
circle
)
fSolidRadius
(
solidRadius
)
fTextureRadius
(
textureRadius
)
fBlurProfileAccess
(
blurProfile
GrTextureParams
:
:
kBilerp_FilterMode
)
{
this
-
>
initClassID
<
GrCircleBlurFragmentProcessor
>
(
)
;
this
-
>
addTextureAccess
(
&
fBlurProfileAccess
)
;
this
-
>
setWillReadFragmentPosition
(
)
;
}
GrGLSLFragmentProcessor
*
GrCircleBlurFragmentProcessor
:
:
onCreateGLSLInstance
(
)
const
{
return
new
GLSLProcessor
;
}
void
GrCircleBlurFragmentProcessor
:
:
onGetGLSLProcessorKey
(
const
GrGLSLCaps
&
caps
GrProcessorKeyBuilder
*
b
)
const
{
return
;
}
void
GrCircleBlurFragmentProcessor
:
:
onComputeInvariantOutput
(
GrInvariantOutput
*
inout
)
const
{
inout
-
>
mulByUnknownSingleComponent
(
)
;
}
static
float
make_unnormalized_half_kernel
(
float
*
halfKernel
int
halfKernelSize
float
sigma
)
{
const
float
invSigma
=
1
.
f
/
sigma
;
const
float
b
=
-
0
.
5f
*
invSigma
*
invSigma
;
float
tot
=
0
.
0f
;
float
t
=
0
.
5f
;
for
(
int
i
=
0
;
i
<
halfKernelSize
;
+
+
i
)
{
float
value
=
expf
(
t
*
t
*
b
)
;
tot
+
=
value
;
halfKernel
[
i
]
=
value
;
t
+
=
1
.
f
;
}
return
tot
;
}
static
void
make_half_kernel_and_summed_table
(
float
*
halfKernel
float
*
summedHalfKernel
int
halfKernelSize
float
sigma
)
{
const
float
tot
=
2
.
f
*
make_unnormalized_half_kernel
(
halfKernel
halfKernelSize
sigma
)
;
float
sum
=
0
.
f
;
for
(
int
i
=
0
;
i
<
halfKernelSize
;
+
+
i
)
{
halfKernel
[
i
]
/
=
tot
;
sum
+
=
halfKernel
[
i
]
;
summedHalfKernel
[
i
]
=
sum
;
}
}
void
apply_kernel_in_y
(
float
*
results
int
numSteps
float
firstX
float
circleR
int
halfKernelSize
const
float
*
summedHalfKernelTable
)
{
float
x
=
firstX
;
for
(
int
i
=
0
;
i
<
numSteps
;
+
+
i
x
+
=
1
.
f
)
{
if
(
x
<
-
circleR
|
|
x
>
circleR
)
{
results
[
i
]
=
0
;
continue
;
}
float
y
=
sqrtf
(
circleR
*
circleR
-
x
*
x
)
;
y
-
=
0
.
5f
;
int
yInt
=
SkScalarFloorToInt
(
y
)
;
SkASSERT
(
yInt
>
=
-
1
)
;
if
(
y
<
0
)
{
results
[
i
]
=
(
y
+
0
.
5f
)
*
summedHalfKernelTable
[
0
]
;
}
else
if
(
yInt
>
=
halfKernelSize
-
1
)
{
results
[
i
]
=
0
.
5f
;
}
else
{
float
yFrac
=
y
-
yInt
;
results
[
i
]
=
(
1
.
f
-
yFrac
)
*
summedHalfKernelTable
[
yInt
]
+
yFrac
*
summedHalfKernelTable
[
yInt
+
1
]
;
}
}
}
static
uint8_t
eval_at
(
float
evalX
float
circleR
const
float
*
halfKernel
int
halfKernelSize
const
float
*
yKernelEvaluations
)
{
float
acc
=
0
;
float
x
=
evalX
-
halfKernelSize
;
for
(
int
i
=
0
;
i
<
halfKernelSize
;
+
+
i
x
+
=
1
.
f
)
{
if
(
x
<
-
circleR
|
|
x
>
circleR
)
{
continue
;
}
float
verticalEval
=
yKernelEvaluations
[
i
]
;
acc
+
=
verticalEval
*
halfKernel
[
halfKernelSize
-
i
-
1
]
;
}
for
(
int
i
=
0
;
i
<
halfKernelSize
;
+
+
i
x
+
=
1
.
f
)
{
if
(
x
<
-
circleR
|
|
x
>
circleR
)
{
continue
;
}
float
verticalEval
=
yKernelEvaluations
[
i
+
halfKernelSize
]
;
acc
+
=
verticalEval
*
halfKernel
[
i
]
;
}
return
SkUnitScalarClampToByte
(
2
.
f
*
acc
)
;
}
static
uint8_t
*
create_circle_profile
(
float
sigma
float
circleR
int
profileTextureWidth
)
{
const
int
numSteps
=
profileTextureWidth
;
uint8_t
*
weights
=
new
uint8_t
[
numSteps
]
;
int
halfKernelSize
=
SkScalarCeilToInt
(
6
.
0f
*
sigma
)
;
halfKernelSize
=
(
(
halfKernelSize
+
1
)
&
~
1
)
>
>
1
;
int
numYSteps
=
numSteps
+
2
*
halfKernelSize
;
SkAutoTArray
<
float
>
bulkAlloc
(
halfKernelSize
+
halfKernelSize
+
numYSteps
)
;
float
*
halfKernel
=
bulkAlloc
.
get
(
)
;
float
*
summedKernel
=
bulkAlloc
.
get
(
)
+
halfKernelSize
;
float
*
yEvals
=
bulkAlloc
.
get
(
)
+
2
*
halfKernelSize
;
make_half_kernel_and_summed_table
(
halfKernel
summedKernel
halfKernelSize
sigma
)
;
float
firstX
=
-
halfKernelSize
+
0
.
5f
;
apply_kernel_in_y
(
yEvals
numYSteps
firstX
circleR
halfKernelSize
summedKernel
)
;
for
(
int
i
=
0
;
i
<
numSteps
-
1
;
+
+
i
)
{
float
evalX
=
i
+
0
.
5f
;
weights
[
i
]
=
eval_at
(
evalX
circleR
halfKernel
halfKernelSize
yEvals
+
i
)
;
}
weights
[
numSteps
-
1
]
=
0
;
return
weights
;
}
static
uint8_t
*
create_half_plane_profile
(
int
profileWidth
)
{
SkASSERT
(
!
(
profileWidth
&
0x1
)
)
;
float
sigma
=
profileWidth
/
6
.
f
;
int
halfKernelSize
=
profileWidth
/
2
;
SkAutoTArray
<
float
>
halfKernel
(
halfKernelSize
)
;
uint8_t
*
profile
=
new
uint8_t
[
profileWidth
]
;
const
float
tot
=
2
.
f
*
make_unnormalized_half_kernel
(
halfKernel
.
get
(
)
halfKernelSize
sigma
)
;
float
sum
=
0
.
f
;
for
(
int
i
=
0
;
i
<
halfKernelSize
;
+
+
i
)
{
halfKernel
[
halfKernelSize
-
i
-
1
]
/
=
tot
;
sum
+
=
halfKernel
[
halfKernelSize
-
i
-
1
]
;
profile
[
profileWidth
-
i
-
1
]
=
SkUnitScalarClampToByte
(
sum
)
;
}
for
(
int
i
=
0
;
i
<
halfKernelSize
;
+
+
i
)
{
sum
+
=
halfKernel
[
i
]
;
profile
[
halfKernelSize
-
i
-
1
]
=
SkUnitScalarClampToByte
(
sum
)
;
}
profile
[
profileWidth
-
1
]
=
0
;
return
profile
;
}
static
GrTexture
*
create_profile_texture
(
GrTextureProvider
*
textureProvider
const
SkRect
&
circle
float
sigma
float
*
solidRadius
float
*
textureRadius
)
{
float
circleR
=
circle
.
width
(
)
/
2
.
0f
;
SkScalar
sigmaToCircleRRatio
=
sigma
/
circleR
;
sigmaToCircleRRatio
=
SkTMin
(
sigmaToCircleRRatio
8
.
f
)
;
SkFixed
sigmaToCircleRRatioFixed
;
static
const
SkScalar
kHalfPlaneThreshold
=
0
.
1f
;
bool
useHalfPlaneApprox
=
false
;
if
(
sigmaToCircleRRatio
<
=
kHalfPlaneThreshold
)
{
useHalfPlaneApprox
=
true
;
sigmaToCircleRRatioFixed
=
0
;
*
solidRadius
=
circleR
-
3
*
sigma
;
*
textureRadius
=
6
*
sigma
;
}
else
{
sigmaToCircleRRatioFixed
=
SkScalarToFixed
(
sigmaToCircleRRatio
)
;
sigmaToCircleRRatioFixed
&
=
~
0xff
;
sigmaToCircleRRatio
=
SkFixedToScalar
(
sigmaToCircleRRatioFixed
)
;
sigma
=
circleR
*
sigmaToCircleRRatio
;
*
solidRadius
=
0
;
*
textureRadius
=
circleR
+
3
*
sigma
;
}
static
const
GrUniqueKey
:
:
Domain
kDomain
=
GrUniqueKey
:
:
GenerateDomain
(
)
;
GrUniqueKey
key
;
GrUniqueKey
:
:
Builder
builder
(
&
key
kDomain
1
)
;
builder
[
0
]
=
sigmaToCircleRRatioFixed
;
builder
.
finish
(
)
;
GrTexture
*
blurProfile
=
textureProvider
-
>
findAndRefTextureByUniqueKey
(
key
)
;
if
(
!
blurProfile
)
{
static
constexpr
int
kProfileTextureWidth
=
512
;
GrSurfaceDesc
texDesc
;
texDesc
.
fWidth
=
kProfileTextureWidth
;
texDesc
.
fHeight
=
1
;
texDesc
.
fConfig
=
kAlpha_8_GrPixelConfig
;
SkAutoTDeleteArray
<
uint8_t
>
profile
(
nullptr
)
;
if
(
useHalfPlaneApprox
)
{
profile
.
reset
(
create_half_plane_profile
(
kProfileTextureWidth
)
)
;
}
else
{
SkScalar
scale
=
kProfileTextureWidth
/
*
textureRadius
;
profile
.
reset
(
create_circle_profile
(
sigma
*
scale
circleR
*
scale
kProfileTextureWidth
)
)
;
}
blurProfile
=
textureProvider
-
>
createTexture
(
texDesc
SkBudgeted
:
:
kYes
profile
.
get
(
)
0
)
;
if
(
blurProfile
)
{
textureProvider
-
>
assignUniqueKeyToTexture
(
key
blurProfile
)
;
}
}
return
blurProfile
;
}
sk_sp
<
GrFragmentProcessor
>
GrCircleBlurFragmentProcessor
:
:
Make
(
GrTextureProvider
*
textureProvider
const
SkRect
&
circle
float
sigma
)
{
float
solidRadius
;
float
textureRadius
;
SkAutoTUnref
<
GrTexture
>
profile
(
create_profile_texture
(
textureProvider
circle
sigma
&
solidRadius
&
textureRadius
)
)
;
if
(
!
profile
)
{
return
nullptr
;
}
return
sk_sp
<
GrFragmentProcessor
>
(
new
GrCircleBlurFragmentProcessor
(
circle
textureRadius
solidRadius
profile
)
)
;
}
GR_DEFINE_FRAGMENT_PROCESSOR_TEST
(
GrCircleBlurFragmentProcessor
)
;
sk_sp
<
GrFragmentProcessor
>
GrCircleBlurFragmentProcessor
:
:
TestCreate
(
GrProcessorTestData
*
d
)
{
SkScalar
wh
=
d
-
>
fRandom
-
>
nextRangeScalar
(
100
.
f
1000
.
f
)
;
SkScalar
sigma
=
d
-
>
fRandom
-
>
nextRangeF
(
1
.
f
10
.
f
)
;
SkRect
circle
=
SkRect
:
:
MakeWH
(
wh
wh
)
;
return
GrCircleBlurFragmentProcessor
:
:
Make
(
d
-
>
fContext
-
>
textureProvider
(
)
circle
sigma
)
;
}
#
endif
