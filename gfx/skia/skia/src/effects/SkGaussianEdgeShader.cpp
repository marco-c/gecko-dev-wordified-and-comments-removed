#
include
"
SkGaussianEdgeShader
.
h
"
#
include
"
SkReadBuffer
.
h
"
#
include
"
SkWriteBuffer
.
h
"
class
SkGaussianEdgeShaderImpl
:
public
SkShader
{
public
:
SkGaussianEdgeShaderImpl
(
)
{
}
bool
isOpaque
(
)
const
override
;
#
if
SK_SUPPORT_GPU
sk_sp
<
GrFragmentProcessor
>
asFragmentProcessor
(
const
AsFPArgs
&
)
const
override
;
#
endif
SK_TO_STRING_OVERRIDE
(
)
SK_DECLARE_PUBLIC_FLATTENABLE_DESERIALIZATION_PROCS
(
SkGaussianEdgeShaderImpl
)
protected
:
void
flatten
(
SkWriteBuffer
&
)
const
override
;
private
:
friend
class
SkGaussianEdgeShader
;
typedef
SkShader
INHERITED
;
}
;
#
if
SK_SUPPORT_GPU
#
include
"
GrCoordTransform
.
h
"
#
include
"
GrFragmentProcessor
.
h
"
#
include
"
GrInvariantOutput
.
h
"
#
include
"
glsl
/
GrGLSLFragmentProcessor
.
h
"
#
include
"
glsl
/
GrGLSLFragmentShaderBuilder
.
h
"
#
include
"
glsl
/
GrGLSLProgramDataManager
.
h
"
#
include
"
glsl
/
GrGLSLUniformHandler
.
h
"
#
include
"
SkGr
.
h
"
#
include
"
SkGrPriv
.
h
"
class
GaussianEdgeFP
:
public
GrFragmentProcessor
{
public
:
GaussianEdgeFP
(
)
{
this
-
>
initClassID
<
GaussianEdgeFP
>
(
)
;
fUsesDistanceVectorField
=
true
;
}
class
GLSLGaussianEdgeFP
:
public
GrGLSLFragmentProcessor
{
public
:
GLSLGaussianEdgeFP
(
)
{
}
void
emitCode
(
EmitArgs
&
args
)
override
{
GrGLSLFPFragmentBuilder
*
fragBuilder
=
args
.
fFragBuilder
;
if
(
!
args
.
fGpImplementsDistanceVector
)
{
fragBuilder
-
>
codeAppendf
(
"
/
/
GP
does
not
implement
fsDistanceVector
-
"
"
returning
grey
in
GLSLGaussianEdgeFP
\
n
"
)
;
fragBuilder
-
>
codeAppendf
(
"
vec4
color
=
%
s
;
"
args
.
fInputColor
)
;
fragBuilder
-
>
codeAppendf
(
"
%
s
=
vec4
(
0
.
0
0
.
0
0
.
0
color
.
r
)
;
"
args
.
fOutputColor
)
;
}
else
{
fragBuilder
-
>
codeAppendf
(
"
vec4
color
=
%
s
;
"
args
.
fInputColor
)
;
fragBuilder
-
>
codeAppend
(
"
float
radius
=
color
.
r
*
256
.
0
*
64
.
0
+
color
.
g
*
64
.
0
;
"
)
;
fragBuilder
-
>
codeAppend
(
"
float
pad
=
color
.
b
*
64
.
0
;
"
)
;
fragBuilder
-
>
codeAppendf
(
"
float
factor
=
1
.
0
-
clamp
(
(
%
s
.
z
-
pad
)
/
radius
0
.
0
1
.
0
)
;
"
fragBuilder
-
>
distanceVectorName
(
)
)
;
fragBuilder
-
>
codeAppend
(
"
factor
=
exp
(
-
factor
*
factor
*
4
.
0
)
-
0
.
018
;
"
)
;
fragBuilder
-
>
codeAppendf
(
"
%
s
=
factor
*
vec4
(
0
.
0
0
.
0
0
.
0
color
.
a
)
;
"
args
.
fOutputColor
)
;
}
}
static
void
GenKey
(
const
GrProcessor
&
proc
const
GrGLSLCaps
&
GrProcessorKeyBuilder
*
b
)
{
b
-
>
add32
(
0x0
)
;
}
protected
:
void
onSetData
(
const
GrGLSLProgramDataManager
&
pdman
const
GrProcessor
&
proc
)
override
{
}
bool
fLargerBlur
;
}
;
void
onGetGLSLProcessorKey
(
const
GrGLSLCaps
&
caps
GrProcessorKeyBuilder
*
b
)
const
override
{
GLSLGaussianEdgeFP
:
:
GenKey
(
*
this
caps
b
)
;
}
const
char
*
name
(
)
const
override
{
return
"
GaussianEdgeFP
"
;
}
void
onComputeInvariantOutput
(
GrInvariantOutput
*
inout
)
const
override
{
inout
-
>
mulByUnknownFourComponents
(
)
;
}
private
:
GrGLSLFragmentProcessor
*
onCreateGLSLInstance
(
)
const
override
{
return
new
GLSLGaussianEdgeFP
(
)
;
}
bool
onIsEqual
(
const
GrFragmentProcessor
&
proc
)
const
override
{
return
true
;
}
}
;
sk_sp
<
GrFragmentProcessor
>
SkGaussianEdgeShaderImpl
:
:
asFragmentProcessor
(
const
AsFPArgs
&
)
const
{
return
sk_make_sp
<
GaussianEdgeFP
>
(
)
;
}
#
endif
bool
SkGaussianEdgeShaderImpl
:
:
isOpaque
(
)
const
{
return
false
;
}
#
ifndef
SK_IGNORE_TO_STRING
void
SkGaussianEdgeShaderImpl
:
:
toString
(
SkString
*
str
)
const
{
str
-
>
appendf
(
"
GaussianEdgeShader
:
(
)
"
)
;
}
#
endif
sk_sp
<
SkFlattenable
>
SkGaussianEdgeShaderImpl
:
:
CreateProc
(
SkReadBuffer
&
buf
)
{
return
sk_make_sp
<
SkGaussianEdgeShaderImpl
>
(
)
;
}
void
SkGaussianEdgeShaderImpl
:
:
flatten
(
SkWriteBuffer
&
buf
)
const
{
}
sk_sp
<
SkShader
>
SkGaussianEdgeShader
:
:
Make
(
)
{
return
sk_make_sp
<
SkGaussianEdgeShaderImpl
>
(
)
;
}
SK_DEFINE_FLATTENABLE_REGISTRAR_GROUP_START
(
SkGaussianEdgeShader
)
SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY
(
SkGaussianEdgeShaderImpl
)
SK_DEFINE_FLATTENABLE_REGISTRAR_GROUP_END
