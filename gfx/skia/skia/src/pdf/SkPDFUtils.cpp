#
include
"
SkData
.
h
"
#
include
"
SkGeometry
.
h
"
#
include
"
SkPaint
.
h
"
#
include
"
SkPath
.
h
"
#
include
"
SkPDFResourceDict
.
h
"
#
include
"
SkPDFUtils
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkString
.
h
"
#
include
"
SkPDFTypes
.
h
"
#
include
<
cmath
>
sk_sp
<
SkPDFArray
>
SkPDFUtils
:
:
RectToArray
(
const
SkRect
&
rect
)
{
auto
result
=
sk_make_sp
<
SkPDFArray
>
(
)
;
result
-
>
reserve
(
4
)
;
result
-
>
appendScalar
(
rect
.
fLeft
)
;
result
-
>
appendScalar
(
rect
.
fTop
)
;
result
-
>
appendScalar
(
rect
.
fRight
)
;
result
-
>
appendScalar
(
rect
.
fBottom
)
;
return
result
;
}
sk_sp
<
SkPDFArray
>
SkPDFUtils
:
:
MatrixToArray
(
const
SkMatrix
&
matrix
)
{
SkScalar
values
[
6
]
;
if
(
!
matrix
.
asAffine
(
values
)
)
{
SkMatrix
:
:
SetAffineIdentity
(
values
)
;
}
auto
result
=
sk_make_sp
<
SkPDFArray
>
(
)
;
result
-
>
reserve
(
6
)
;
for
(
size_t
i
=
0
;
i
<
SK_ARRAY_COUNT
(
values
)
;
i
+
+
)
{
result
-
>
appendScalar
(
values
[
i
]
)
;
}
return
result
;
}
void
SkPDFUtils
:
:
AppendTransform
(
const
SkMatrix
&
matrix
SkWStream
*
content
)
{
SkScalar
values
[
6
]
;
if
(
!
matrix
.
asAffine
(
values
)
)
{
SkMatrix
:
:
SetAffineIdentity
(
values
)
;
}
for
(
size_t
i
=
0
;
i
<
SK_ARRAY_COUNT
(
values
)
;
i
+
+
)
{
SkPDFUtils
:
:
AppendScalar
(
values
[
i
]
content
)
;
content
-
>
writeText
(
"
"
)
;
}
content
-
>
writeText
(
"
cm
\
n
"
)
;
}
void
SkPDFUtils
:
:
MoveTo
(
SkScalar
x
SkScalar
y
SkWStream
*
content
)
{
SkPDFUtils
:
:
AppendScalar
(
x
content
)
;
content
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendScalar
(
y
content
)
;
content
-
>
writeText
(
"
m
\
n
"
)
;
}
void
SkPDFUtils
:
:
AppendLine
(
SkScalar
x
SkScalar
y
SkWStream
*
content
)
{
SkPDFUtils
:
:
AppendScalar
(
x
content
)
;
content
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendScalar
(
y
content
)
;
content
-
>
writeText
(
"
l
\
n
"
)
;
}
void
SkPDFUtils
:
:
AppendCubic
(
SkScalar
ctl1X
SkScalar
ctl1Y
SkScalar
ctl2X
SkScalar
ctl2Y
SkScalar
dstX
SkScalar
dstY
SkWStream
*
content
)
{
SkString
cmd
(
"
y
\
n
"
)
;
SkPDFUtils
:
:
AppendScalar
(
ctl1X
content
)
;
content
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendScalar
(
ctl1Y
content
)
;
content
-
>
writeText
(
"
"
)
;
if
(
ctl2X
!
=
dstX
|
|
ctl2Y
!
=
dstY
)
{
cmd
.
set
(
"
c
\
n
"
)
;
SkPDFUtils
:
:
AppendScalar
(
ctl2X
content
)
;
content
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendScalar
(
ctl2Y
content
)
;
content
-
>
writeText
(
"
"
)
;
}
SkPDFUtils
:
:
AppendScalar
(
dstX
content
)
;
content
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendScalar
(
dstY
content
)
;
content
-
>
writeText
(
"
"
)
;
content
-
>
writeText
(
cmd
.
c_str
(
)
)
;
}
static
void
append_quad
(
const
SkPoint
quad
[
]
SkWStream
*
content
)
{
SkPoint
cubic
[
4
]
;
SkConvertQuadToCubic
(
quad
cubic
)
;
SkPDFUtils
:
:
AppendCubic
(
cubic
[
1
]
.
fX
cubic
[
1
]
.
fY
cubic
[
2
]
.
fX
cubic
[
2
]
.
fY
cubic
[
3
]
.
fX
cubic
[
3
]
.
fY
content
)
;
}
void
SkPDFUtils
:
:
AppendRectangle
(
const
SkRect
&
rect
SkWStream
*
content
)
{
SkScalar
bottom
=
SkMinScalar
(
rect
.
fBottom
rect
.
fTop
)
;
SkPDFUtils
:
:
AppendScalar
(
rect
.
fLeft
content
)
;
content
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendScalar
(
bottom
content
)
;
content
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendScalar
(
rect
.
width
(
)
content
)
;
content
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendScalar
(
rect
.
height
(
)
content
)
;
content
-
>
writeText
(
"
re
\
n
"
)
;
}
void
SkPDFUtils
:
:
EmitPath
(
const
SkPath
&
path
SkPaint
:
:
Style
paintStyle
bool
doConsumeDegerates
SkWStream
*
content
)
{
enum
SkipFillState
{
kEmpty_SkipFillState
kSingleLine_SkipFillState
kNonSingleLine_SkipFillState
}
;
SkipFillState
fillState
=
kEmpty_SkipFillState
;
SkPoint
lastMovePt
=
SkPoint
:
:
Make
(
0
0
)
;
SkDynamicMemoryWStream
currentSegment
;
SkPoint
args
[
4
]
;
SkPath
:
:
Iter
iter
(
path
false
)
;
for
(
SkPath
:
:
Verb
verb
=
iter
.
next
(
args
doConsumeDegerates
)
;
verb
!
=
SkPath
:
:
kDone_Verb
;
verb
=
iter
.
next
(
args
doConsumeDegerates
)
)
{
switch
(
verb
)
{
case
SkPath
:
:
kMove_Verb
:
MoveTo
(
args
[
0
]
.
fX
args
[
0
]
.
fY
&
currentSegment
)
;
lastMovePt
=
args
[
0
]
;
fillState
=
kEmpty_SkipFillState
;
break
;
case
SkPath
:
:
kLine_Verb
:
AppendLine
(
args
[
1
]
.
fX
args
[
1
]
.
fY
&
currentSegment
)
;
if
(
(
fillState
=
=
kEmpty_SkipFillState
)
&
&
(
args
[
0
]
!
=
lastMovePt
)
)
{
fillState
=
kSingleLine_SkipFillState
;
break
;
}
fillState
=
kNonSingleLine_SkipFillState
;
break
;
case
SkPath
:
:
kQuad_Verb
:
append_quad
(
args
&
currentSegment
)
;
fillState
=
kNonSingleLine_SkipFillState
;
break
;
case
SkPath
:
:
kConic_Verb
:
{
const
SkScalar
tol
=
SK_Scalar1
/
4
;
SkAutoConicToQuads
converter
;
const
SkPoint
*
quads
=
converter
.
computeQuads
(
args
iter
.
conicWeight
(
)
tol
)
;
for
(
int
i
=
0
;
i
<
converter
.
countQuads
(
)
;
+
+
i
)
{
append_quad
(
&
quads
[
i
*
2
]
&
currentSegment
)
;
}
fillState
=
kNonSingleLine_SkipFillState
;
}
break
;
case
SkPath
:
:
kCubic_Verb
:
AppendCubic
(
args
[
1
]
.
fX
args
[
1
]
.
fY
args
[
2
]
.
fX
args
[
2
]
.
fY
args
[
3
]
.
fX
args
[
3
]
.
fY
&
currentSegment
)
;
fillState
=
kNonSingleLine_SkipFillState
;
break
;
case
SkPath
:
:
kClose_Verb
:
ClosePath
(
&
currentSegment
)
;
currentSegment
.
writeToStream
(
content
)
;
currentSegment
.
reset
(
)
;
break
;
default
:
SkASSERT
(
false
)
;
break
;
}
}
if
(
currentSegment
.
bytesWritten
(
)
>
0
)
{
currentSegment
.
writeToStream
(
content
)
;
}
}
void
SkPDFUtils
:
:
ClosePath
(
SkWStream
*
content
)
{
content
-
>
writeText
(
"
h
\
n
"
)
;
}
void
SkPDFUtils
:
:
PaintPath
(
SkPaint
:
:
Style
style
SkPath
:
:
FillType
fill
SkWStream
*
content
)
{
if
(
style
=
=
SkPaint
:
:
kFill_Style
)
{
content
-
>
writeText
(
"
f
"
)
;
}
else
if
(
style
=
=
SkPaint
:
:
kStrokeAndFill_Style
)
{
content
-
>
writeText
(
"
B
"
)
;
}
else
if
(
style
=
=
SkPaint
:
:
kStroke_Style
)
{
content
-
>
writeText
(
"
S
"
)
;
}
if
(
style
!
=
SkPaint
:
:
kStroke_Style
)
{
NOT_IMPLEMENTED
(
fill
=
=
SkPath
:
:
kInverseEvenOdd_FillType
false
)
;
NOT_IMPLEMENTED
(
fill
=
=
SkPath
:
:
kInverseWinding_FillType
false
)
;
if
(
fill
=
=
SkPath
:
:
kEvenOdd_FillType
)
{
content
-
>
writeText
(
"
*
"
)
;
}
}
content
-
>
writeText
(
"
\
n
"
)
;
}
void
SkPDFUtils
:
:
StrokePath
(
SkWStream
*
content
)
{
SkPDFUtils
:
:
PaintPath
(
SkPaint
:
:
kStroke_Style
SkPath
:
:
kWinding_FillType
content
)
;
}
void
SkPDFUtils
:
:
DrawFormXObject
(
int
objectIndex
SkWStream
*
content
)
{
content
-
>
writeText
(
"
/
"
)
;
content
-
>
writeText
(
SkPDFResourceDict
:
:
getResourceName
(
SkPDFResourceDict
:
:
kXObject_ResourceType
objectIndex
)
.
c_str
(
)
)
;
content
-
>
writeText
(
"
Do
\
n
"
)
;
}
void
SkPDFUtils
:
:
ApplyGraphicState
(
int
objectIndex
SkWStream
*
content
)
{
content
-
>
writeText
(
"
/
"
)
;
content
-
>
writeText
(
SkPDFResourceDict
:
:
getResourceName
(
SkPDFResourceDict
:
:
kExtGState_ResourceType
objectIndex
)
.
c_str
(
)
)
;
content
-
>
writeText
(
"
gs
\
n
"
)
;
}
void
SkPDFUtils
:
:
ApplyPattern
(
int
objectIndex
SkWStream
*
content
)
{
SkString
resourceName
=
SkPDFResourceDict
:
:
getResourceName
(
SkPDFResourceDict
:
:
kPattern_ResourceType
objectIndex
)
;
content
-
>
writeText
(
"
/
Pattern
CS
/
Pattern
cs
/
"
)
;
content
-
>
writeText
(
resourceName
.
c_str
(
)
)
;
content
-
>
writeText
(
"
SCN
/
"
)
;
content
-
>
writeText
(
resourceName
.
c_str
(
)
)
;
content
-
>
writeText
(
"
scn
\
n
"
)
;
}
void
SkPDFUtils
:
:
AppendScalar
(
SkScalar
value
SkWStream
*
stream
)
{
char
result
[
kMaximumFloatDecimalLength
]
;
size_t
len
=
SkPDFUtils
:
:
FloatToDecimal
(
SkScalarToFloat
(
value
)
result
)
;
SkASSERT
(
len
<
kMaximumFloatDecimalLength
)
;
stream
-
>
write
(
result
len
)
;
}
size_t
SkPDFUtils
:
:
FloatToDecimal
(
float
value
char
result
[
kMaximumFloatDecimalLength
]
)
{
char
*
output
=
&
result
[
0
]
;
const
char
*
const
end
=
&
result
[
kMaximumFloatDecimalLength
-
1
]
;
if
(
value
=
=
SK_FloatInfinity
)
{
value
=
FLT_MAX
;
}
if
(
value
=
=
SK_FloatNegativeInfinity
)
{
value
=
-
FLT_MAX
;
}
if
(
!
std
:
:
isfinite
(
value
)
|
|
value
=
=
0
.
0f
)
{
*
output
+
+
=
'
0
'
;
*
output
=
'
\
0
'
;
return
output
-
result
;
}
if
(
value
<
0
.
0
)
{
*
output
+
+
=
'
-
'
;
value
=
-
value
;
}
SkASSERT
(
value
>
=
0
.
0f
)
;
double
intPart
;
double
fracPart
=
std
:
:
modf
(
static_cast
<
double
>
(
value
)
&
intPart
)
;
SkASSERT
(
intPart
+
fracPart
=
=
static_cast
<
double
>
(
value
)
)
;
size_t
significantDigits
=
0
;
const
size_t
maxSignificantDigits
=
9
;
SkASSERT
(
intPart
>
=
0
.
0
&
&
fracPart
>
=
0
.
0
)
;
SkASSERT
(
intPart
>
0
.
0
|
|
fracPart
>
0
.
0
)
;
if
(
intPart
>
0
.
0
)
{
char
reversed
[
1
+
FLT_MAX_10_EXP
]
;
size_t
reversedIndex
=
0
;
do
{
SkASSERT
(
reversedIndex
<
sizeof
(
reversed
)
)
;
int
digit
=
static_cast
<
int
>
(
std
:
:
fmod
(
intPart
10
.
0
)
)
;
SkASSERT
(
digit
>
=
0
&
&
digit
<
=
9
)
;
reversed
[
reversedIndex
+
+
]
=
'
0
'
+
digit
;
intPart
=
std
:
:
floor
(
intPart
/
10
.
0
)
;
}
while
(
intPart
>
0
.
0
)
;
significantDigits
=
reversedIndex
;
SkASSERT
(
reversedIndex
<
=
sizeof
(
reversed
)
)
;
SkASSERT
(
output
+
reversedIndex
<
=
end
)
;
while
(
reversedIndex
-
-
>
0
)
{
*
output
+
+
=
reversed
[
reversedIndex
]
;
}
}
if
(
fracPart
>
0
&
&
significantDigits
<
maxSignificantDigits
)
{
*
output
+
+
=
'
.
'
;
SkASSERT
(
output
<
=
end
)
;
do
{
fracPart
=
std
:
:
modf
(
fracPart
*
10
.
0
&
intPart
)
;
int
digit
=
static_cast
<
int
>
(
intPart
)
;
SkASSERT
(
digit
>
=
0
&
&
digit
<
=
9
)
;
*
output
+
+
=
'
0
'
+
digit
;
SkASSERT
(
output
<
=
end
)
;
if
(
digit
>
0
|
|
significantDigits
>
0
)
{
+
+
significantDigits
;
}
}
while
(
fracPart
>
0
.
0
&
&
significantDigits
<
maxSignificantDigits
&
&
output
<
end
)
;
}
SkASSERT
(
output
<
=
end
)
;
*
output
=
'
\
0
'
;
return
output
-
result
;
}
SkString
SkPDFUtils
:
:
FormatString
(
const
char
*
cin
size_t
len
)
{
SkDEBUGCODE
(
static
const
size_t
kMaxLen
=
65535
;
)
SkASSERT
(
len
<
=
kMaxLen
)
;
bool
sevenBitClean
=
true
;
size_t
characterCount
=
2
+
len
;
for
(
size_t
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
cin
[
i
]
>
'
~
'
|
|
cin
[
i
]
<
'
'
)
{
sevenBitClean
=
false
;
break
;
}
if
(
cin
[
i
]
=
=
'
\
\
'
|
|
cin
[
i
]
=
=
'
(
'
|
|
cin
[
i
]
=
=
'
)
'
)
{
+
+
characterCount
;
}
}
SkString
result
;
if
(
sevenBitClean
)
{
result
.
resize
(
characterCount
)
;
char
*
str
=
result
.
writable_str
(
)
;
*
str
+
+
=
'
(
'
;
for
(
size_t
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
cin
[
i
]
=
=
'
\
\
'
|
|
cin
[
i
]
=
=
'
(
'
|
|
cin
[
i
]
=
=
'
)
'
)
{
*
str
+
+
=
'
\
\
'
;
}
*
str
+
+
=
cin
[
i
]
;
}
*
str
+
+
=
'
)
'
;
}
else
{
result
.
resize
(
2
*
len
+
2
)
;
char
*
str
=
result
.
writable_str
(
)
;
*
str
+
+
=
'
<
'
;
for
(
size_t
i
=
0
;
i
<
len
;
i
+
+
)
{
uint8_t
c
=
static_cast
<
uint8_t
>
(
cin
[
i
]
)
;
static
const
char
gHex
[
]
=
"
0123456789ABCDEF
"
;
*
str
+
+
=
gHex
[
(
c
>
>
4
)
&
0xF
]
;
*
str
+
+
=
gHex
[
(
c
)
&
0xF
]
;
}
*
str
+
+
=
'
>
'
;
}
return
result
;
}
