#
include
"
SkData
.
h
"
#
include
"
SkFixed
.
h
"
#
include
"
SkGeometry
.
h
"
#
include
"
SkPDFResourceDict
.
h
"
#
include
"
SkPDFUtils
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkString
.
h
"
#
include
"
SkPDFTypes
.
h
"
#
include
<
cmath
>
sk_sp
<
SkPDFArray
>
SkPDFUtils
:
:
RectToArray
(
const
SkRect
&
rect
)
{
auto
result
=
sk_make_sp
<
SkPDFArray
>
(
)
;
result
-
>
reserve
(
4
)
;
result
-
>
appendScalar
(
rect
.
fLeft
)
;
result
-
>
appendScalar
(
rect
.
fTop
)
;
result
-
>
appendScalar
(
rect
.
fRight
)
;
result
-
>
appendScalar
(
rect
.
fBottom
)
;
return
result
;
}
sk_sp
<
SkPDFArray
>
SkPDFUtils
:
:
MatrixToArray
(
const
SkMatrix
&
matrix
)
{
SkScalar
values
[
6
]
;
if
(
!
matrix
.
asAffine
(
values
)
)
{
SkMatrix
:
:
SetAffineIdentity
(
values
)
;
}
auto
result
=
sk_make_sp
<
SkPDFArray
>
(
)
;
result
-
>
reserve
(
6
)
;
for
(
size_t
i
=
0
;
i
<
SK_ARRAY_COUNT
(
values
)
;
i
+
+
)
{
result
-
>
appendScalar
(
values
[
i
]
)
;
}
return
result
;
}
void
SkPDFUtils
:
:
AppendTransform
(
const
SkMatrix
&
matrix
SkWStream
*
content
)
{
SkScalar
values
[
6
]
;
if
(
!
matrix
.
asAffine
(
values
)
)
{
SkMatrix
:
:
SetAffineIdentity
(
values
)
;
}
for
(
size_t
i
=
0
;
i
<
SK_ARRAY_COUNT
(
values
)
;
i
+
+
)
{
SkPDFUtils
:
:
AppendScalar
(
values
[
i
]
content
)
;
content
-
>
writeText
(
"
"
)
;
}
content
-
>
writeText
(
"
cm
\
n
"
)
;
}
void
SkPDFUtils
:
:
MoveTo
(
SkScalar
x
SkScalar
y
SkWStream
*
content
)
{
SkPDFUtils
:
:
AppendScalar
(
x
content
)
;
content
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendScalar
(
y
content
)
;
content
-
>
writeText
(
"
m
\
n
"
)
;
}
void
SkPDFUtils
:
:
AppendLine
(
SkScalar
x
SkScalar
y
SkWStream
*
content
)
{
SkPDFUtils
:
:
AppendScalar
(
x
content
)
;
content
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendScalar
(
y
content
)
;
content
-
>
writeText
(
"
l
\
n
"
)
;
}
void
SkPDFUtils
:
:
AppendCubic
(
SkScalar
ctl1X
SkScalar
ctl1Y
SkScalar
ctl2X
SkScalar
ctl2Y
SkScalar
dstX
SkScalar
dstY
SkWStream
*
content
)
{
SkString
cmd
(
"
y
\
n
"
)
;
SkPDFUtils
:
:
AppendScalar
(
ctl1X
content
)
;
content
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendScalar
(
ctl1Y
content
)
;
content
-
>
writeText
(
"
"
)
;
if
(
ctl2X
!
=
dstX
|
|
ctl2Y
!
=
dstY
)
{
cmd
.
set
(
"
c
\
n
"
)
;
SkPDFUtils
:
:
AppendScalar
(
ctl2X
content
)
;
content
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendScalar
(
ctl2Y
content
)
;
content
-
>
writeText
(
"
"
)
;
}
SkPDFUtils
:
:
AppendScalar
(
dstX
content
)
;
content
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendScalar
(
dstY
content
)
;
content
-
>
writeText
(
"
"
)
;
content
-
>
writeText
(
cmd
.
c_str
(
)
)
;
}
static
void
append_quad
(
const
SkPoint
quad
[
]
SkWStream
*
content
)
{
SkPoint
cubic
[
4
]
;
SkConvertQuadToCubic
(
quad
cubic
)
;
SkPDFUtils
:
:
AppendCubic
(
cubic
[
1
]
.
fX
cubic
[
1
]
.
fY
cubic
[
2
]
.
fX
cubic
[
2
]
.
fY
cubic
[
3
]
.
fX
cubic
[
3
]
.
fY
content
)
;
}
void
SkPDFUtils
:
:
AppendRectangle
(
const
SkRect
&
rect
SkWStream
*
content
)
{
SkScalar
bottom
=
SkMinScalar
(
rect
.
fBottom
rect
.
fTop
)
;
SkPDFUtils
:
:
AppendScalar
(
rect
.
fLeft
content
)
;
content
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendScalar
(
bottom
content
)
;
content
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendScalar
(
rect
.
width
(
)
content
)
;
content
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendScalar
(
rect
.
height
(
)
content
)
;
content
-
>
writeText
(
"
re
\
n
"
)
;
}
void
SkPDFUtils
:
:
EmitPath
(
const
SkPath
&
path
SkPaint
:
:
Style
paintStyle
bool
doConsumeDegerates
SkWStream
*
content
SkScalar
tolerance
)
{
SkRect
rect
;
bool
isClosed
;
SkPath
:
:
Direction
direction
;
if
(
path
.
isRect
(
&
rect
&
isClosed
&
direction
)
&
&
isClosed
&
&
SkPath
:
:
kCW_Direction
=
=
direction
)
{
SkPDFUtils
:
:
AppendRectangle
(
rect
content
)
;
return
;
}
enum
SkipFillState
{
kEmpty_SkipFillState
kSingleLine_SkipFillState
kNonSingleLine_SkipFillState
}
;
SkipFillState
fillState
=
kEmpty_SkipFillState
;
SkPoint
lastMovePt
=
SkPoint
:
:
Make
(
0
0
)
;
SkDynamicMemoryWStream
currentSegment
;
SkPoint
args
[
4
]
;
SkPath
:
:
Iter
iter
(
path
false
)
;
for
(
SkPath
:
:
Verb
verb
=
iter
.
next
(
args
doConsumeDegerates
)
;
verb
!
=
SkPath
:
:
kDone_Verb
;
verb
=
iter
.
next
(
args
doConsumeDegerates
)
)
{
switch
(
verb
)
{
case
SkPath
:
:
kMove_Verb
:
MoveTo
(
args
[
0
]
.
fX
args
[
0
]
.
fY
&
currentSegment
)
;
lastMovePt
=
args
[
0
]
;
fillState
=
kEmpty_SkipFillState
;
break
;
case
SkPath
:
:
kLine_Verb
:
AppendLine
(
args
[
1
]
.
fX
args
[
1
]
.
fY
&
currentSegment
)
;
if
(
(
fillState
=
=
kEmpty_SkipFillState
)
&
&
(
args
[
0
]
!
=
lastMovePt
)
)
{
fillState
=
kSingleLine_SkipFillState
;
break
;
}
fillState
=
kNonSingleLine_SkipFillState
;
break
;
case
SkPath
:
:
kQuad_Verb
:
append_quad
(
args
&
currentSegment
)
;
fillState
=
kNonSingleLine_SkipFillState
;
break
;
case
SkPath
:
:
kConic_Verb
:
{
SkAutoConicToQuads
converter
;
const
SkPoint
*
quads
=
converter
.
computeQuads
(
args
iter
.
conicWeight
(
)
tolerance
)
;
for
(
int
i
=
0
;
i
<
converter
.
countQuads
(
)
;
+
+
i
)
{
append_quad
(
&
quads
[
i
*
2
]
&
currentSegment
)
;
}
fillState
=
kNonSingleLine_SkipFillState
;
}
break
;
case
SkPath
:
:
kCubic_Verb
:
AppendCubic
(
args
[
1
]
.
fX
args
[
1
]
.
fY
args
[
2
]
.
fX
args
[
2
]
.
fY
args
[
3
]
.
fX
args
[
3
]
.
fY
&
currentSegment
)
;
fillState
=
kNonSingleLine_SkipFillState
;
break
;
case
SkPath
:
:
kClose_Verb
:
ClosePath
(
&
currentSegment
)
;
currentSegment
.
writeToStream
(
content
)
;
currentSegment
.
reset
(
)
;
break
;
default
:
SkASSERT
(
false
)
;
break
;
}
}
if
(
currentSegment
.
bytesWritten
(
)
>
0
)
{
currentSegment
.
writeToStream
(
content
)
;
}
}
void
SkPDFUtils
:
:
ClosePath
(
SkWStream
*
content
)
{
content
-
>
writeText
(
"
h
\
n
"
)
;
}
void
SkPDFUtils
:
:
PaintPath
(
SkPaint
:
:
Style
style
SkPath
:
:
FillType
fill
SkWStream
*
content
)
{
if
(
style
=
=
SkPaint
:
:
kFill_Style
)
{
content
-
>
writeText
(
"
f
"
)
;
}
else
if
(
style
=
=
SkPaint
:
:
kStrokeAndFill_Style
)
{
content
-
>
writeText
(
"
B
"
)
;
}
else
if
(
style
=
=
SkPaint
:
:
kStroke_Style
)
{
content
-
>
writeText
(
"
S
"
)
;
}
if
(
style
!
=
SkPaint
:
:
kStroke_Style
)
{
NOT_IMPLEMENTED
(
fill
=
=
SkPath
:
:
kInverseEvenOdd_FillType
false
)
;
NOT_IMPLEMENTED
(
fill
=
=
SkPath
:
:
kInverseWinding_FillType
false
)
;
if
(
fill
=
=
SkPath
:
:
kEvenOdd_FillType
)
{
content
-
>
writeText
(
"
*
"
)
;
}
}
content
-
>
writeText
(
"
\
n
"
)
;
}
void
SkPDFUtils
:
:
StrokePath
(
SkWStream
*
content
)
{
SkPDFUtils
:
:
PaintPath
(
SkPaint
:
:
kStroke_Style
SkPath
:
:
kWinding_FillType
content
)
;
}
void
SkPDFUtils
:
:
DrawFormXObject
(
int
objectIndex
SkWStream
*
content
)
{
content
-
>
writeText
(
"
/
"
)
;
content
-
>
writeText
(
SkPDFResourceDict
:
:
getResourceName
(
SkPDFResourceDict
:
:
kXObject_ResourceType
objectIndex
)
.
c_str
(
)
)
;
content
-
>
writeText
(
"
Do
\
n
"
)
;
}
void
SkPDFUtils
:
:
ApplyGraphicState
(
int
objectIndex
SkWStream
*
content
)
{
content
-
>
writeText
(
"
/
"
)
;
content
-
>
writeText
(
SkPDFResourceDict
:
:
getResourceName
(
SkPDFResourceDict
:
:
kExtGState_ResourceType
objectIndex
)
.
c_str
(
)
)
;
content
-
>
writeText
(
"
gs
\
n
"
)
;
}
void
SkPDFUtils
:
:
ApplyPattern
(
int
objectIndex
SkWStream
*
content
)
{
SkString
resourceName
=
SkPDFResourceDict
:
:
getResourceName
(
SkPDFResourceDict
:
:
kPattern_ResourceType
objectIndex
)
;
content
-
>
writeText
(
"
/
Pattern
CS
/
Pattern
cs
/
"
)
;
content
-
>
writeText
(
resourceName
.
c_str
(
)
)
;
content
-
>
writeText
(
"
SCN
/
"
)
;
content
-
>
writeText
(
resourceName
.
c_str
(
)
)
;
content
-
>
writeText
(
"
scn
\
n
"
)
;
}
size_t
SkPDFUtils
:
:
ColorToDecimal
(
uint8_t
value
char
result
[
5
]
)
{
if
(
value
=
=
255
|
|
value
=
=
0
)
{
result
[
0
]
=
value
?
'
1
'
:
'
0
'
;
result
[
1
]
=
'
\
0
'
;
return
1
;
}
int
x
=
SkFixedRoundToInt
(
(
SK_Fixed1
*
1000
/
255
)
*
value
)
;
result
[
0
]
=
'
.
'
;
for
(
int
i
=
3
;
i
>
0
;
-
-
i
)
{
result
[
i
]
=
'
0
'
+
x
%
10
;
x
/
=
10
;
}
int
j
;
for
(
j
=
3
;
j
>
1
;
-
-
j
)
{
if
(
result
[
j
]
!
=
'
0
'
)
{
break
;
}
}
result
[
j
+
1
]
=
'
\
0
'
;
return
j
+
1
;
}
void
SkPDFUtils
:
:
AppendScalar
(
SkScalar
value
SkWStream
*
stream
)
{
char
result
[
kMaximumFloatDecimalLength
]
;
size_t
len
=
SkPDFUtils
:
:
FloatToDecimal
(
SkScalarToFloat
(
value
)
result
)
;
SkASSERT
(
len
<
kMaximumFloatDecimalLength
)
;
stream
-
>
write
(
result
len
)
;
}
inline
double
pow10
(
int
e
)
{
switch
(
e
)
{
case
0
:
return
1
.
0
;
case
1
:
return
10
.
0
;
case
2
:
return
100
.
0
;
case
3
:
return
1e
+
03
;
case
4
:
return
1e
+
04
;
case
5
:
return
1e
+
05
;
case
6
:
return
1e
+
06
;
case
7
:
return
1e
+
07
;
case
8
:
return
1e
+
08
;
case
9
:
return
1e
+
09
;
case
10
:
return
1e
+
10
;
case
11
:
return
1e
+
11
;
case
12
:
return
1e
+
12
;
case
13
:
return
1e
+
13
;
case
14
:
return
1e
+
14
;
case
15
:
return
1e
+
15
;
default
:
if
(
e
>
15
)
{
double
value
=
1e
+
15
;
while
(
e
-
-
>
15
)
{
value
*
=
10
.
0
;
}
return
value
;
}
else
{
SkASSERT
(
e
<
0
)
;
double
value
=
1
.
0
;
while
(
e
+
+
<
0
)
{
value
/
=
10
.
0
;
}
return
value
;
}
}
}
size_t
SkPDFUtils
:
:
FloatToDecimal
(
float
value
char
result
[
kMaximumFloatDecimalLength
]
)
{
char
*
output
=
&
result
[
0
]
;
const
char
*
const
end
=
&
result
[
kMaximumFloatDecimalLength
-
1
]
;
if
(
value
=
=
SK_FloatInfinity
)
{
value
=
FLT_MAX
;
}
if
(
value
=
=
SK_FloatNegativeInfinity
)
{
value
=
-
FLT_MAX
;
}
if
(
!
std
:
:
isfinite
(
value
)
|
|
value
=
=
0
.
0f
)
{
*
output
+
+
=
'
0
'
;
*
output
=
'
\
0
'
;
return
output
-
result
;
}
if
(
value
<
0
.
0
)
{
*
output
+
+
=
'
-
'
;
value
=
-
value
;
}
SkASSERT
(
value
>
=
0
.
0f
)
;
int
binaryExponent
;
(
void
)
std
:
:
frexp
(
value
&
binaryExponent
)
;
static
const
double
kLog2
=
0
.
3010299956639812
;
int
decimalExponent
=
static_cast
<
int
>
(
std
:
:
floor
(
kLog2
*
binaryExponent
)
)
;
int
decimalShift
=
decimalExponent
-
8
;
double
power
=
pow10
(
-
decimalShift
)
;
int32_t
d
=
static_cast
<
int32_t
>
(
value
*
power
+
0
.
5
)
;
SkASSERT
(
d
<
=
999999999
)
;
if
(
d
>
167772159
)
{
decimalShift
=
decimalExponent
-
7
;
d
=
static_cast
<
int32_t
>
(
value
*
(
power
*
0
.
1
)
+
0
.
5
)
;
SkASSERT
(
d
<
=
99999999
)
;
}
while
(
d
%
10
=
=
0
)
{
d
/
=
10
;
+
+
decimalShift
;
}
SkASSERT
(
d
>
0
)
;
uint8_t
buffer
[
9
]
;
int
bufferIndex
=
0
;
do
{
buffer
[
bufferIndex
+
+
]
=
d
%
10
;
d
/
=
10
;
}
while
(
d
!
=
0
)
;
SkASSERT
(
bufferIndex
<
=
(
int
)
sizeof
(
buffer
)
&
&
bufferIndex
>
0
)
;
if
(
decimalShift
>
=
0
)
{
do
{
-
-
bufferIndex
;
*
output
+
+
=
'
0
'
+
buffer
[
bufferIndex
]
;
}
while
(
bufferIndex
)
;
for
(
int
i
=
0
;
i
<
decimalShift
;
+
+
i
)
{
*
output
+
+
=
'
0
'
;
}
}
else
{
int
placesBeforeDecimal
=
bufferIndex
+
decimalShift
;
if
(
placesBeforeDecimal
>
0
)
{
while
(
placesBeforeDecimal
-
-
>
0
)
{
-
-
bufferIndex
;
*
output
+
+
=
'
0
'
+
buffer
[
bufferIndex
]
;
}
*
output
+
+
=
'
.
'
;
}
else
{
*
output
+
+
=
'
.
'
;
int
placesAfterDecimal
=
-
placesBeforeDecimal
;
while
(
placesAfterDecimal
-
-
>
0
)
{
*
output
+
+
=
'
0
'
;
}
}
while
(
bufferIndex
>
0
)
{
-
-
bufferIndex
;
*
output
+
+
=
'
0
'
+
buffer
[
bufferIndex
]
;
if
(
output
=
=
end
)
{
break
;
}
}
}
SkASSERT
(
output
<
=
end
)
;
*
output
=
'
\
0
'
;
return
output
-
result
;
}
void
SkPDFUtils
:
:
WriteString
(
SkWStream
*
wStream
const
char
*
cin
size_t
len
)
{
SkDEBUGCODE
(
static
const
size_t
kMaxLen
=
65535
;
)
SkASSERT
(
len
<
=
kMaxLen
)
;
size_t
extraCharacterCount
=
0
;
for
(
size_t
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
cin
[
i
]
>
'
~
'
|
|
cin
[
i
]
<
'
'
)
{
extraCharacterCount
+
=
3
;
}
if
(
cin
[
i
]
=
=
'
\
\
'
|
|
cin
[
i
]
=
=
'
(
'
|
|
cin
[
i
]
=
=
'
)
'
)
{
+
+
extraCharacterCount
;
}
}
if
(
extraCharacterCount
<
=
len
)
{
wStream
-
>
writeText
(
"
(
"
)
;
for
(
size_t
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
cin
[
i
]
>
'
~
'
|
|
cin
[
i
]
<
'
'
)
{
uint8_t
c
=
static_cast
<
uint8_t
>
(
cin
[
i
]
)
;
uint8_t
octal
[
4
]
;
octal
[
0
]
=
'
\
\
'
;
octal
[
1
]
=
'
0
'
+
(
c
>
>
6
)
;
octal
[
2
]
=
'
0
'
+
(
(
c
>
>
3
)
&
0x07
)
;
octal
[
3
]
=
'
0
'
+
(
c
&
0x07
)
;
wStream
-
>
write
(
octal
4
)
;
}
else
{
if
(
cin
[
i
]
=
=
'
\
\
'
|
|
cin
[
i
]
=
=
'
(
'
|
|
cin
[
i
]
=
=
'
)
'
)
{
wStream
-
>
writeText
(
"
\
\
"
)
;
}
wStream
-
>
write
(
&
cin
[
i
]
1
)
;
}
}
wStream
-
>
writeText
(
"
)
"
)
;
}
else
{
wStream
-
>
writeText
(
"
<
"
)
;
for
(
size_t
i
=
0
;
i
<
len
;
i
+
+
)
{
uint8_t
c
=
static_cast
<
uint8_t
>
(
cin
[
i
]
)
;
static
const
char
gHex
[
]
=
"
0123456789ABCDEF
"
;
char
hexValue
[
2
]
;
hexValue
[
0
]
=
gHex
[
(
c
>
>
4
)
&
0xF
]
;
hexValue
[
1
]
=
gHex
[
c
&
0xF
]
;
wStream
-
>
write
(
hexValue
2
)
;
}
wStream
-
>
writeText
(
"
>
"
)
;
}
}
