#
include
"
SkPDFGradientShader
.
h
"
#
include
"
SkOpts
.
h
"
#
include
"
SkPDFDocument
.
h
"
#
include
"
SkPDFFormXObject
.
h
"
#
include
"
SkPDFResourceDict
.
h
"
#
include
"
SkPDFUtils
.
h
"
static
uint32_t
hash
(
const
SkShader
:
:
GradientInfo
&
v
)
{
uint32_t
buffer
[
]
=
{
(
uint32_t
)
v
.
fColorCount
SkOpts
:
:
hash
(
v
.
fColors
v
.
fColorCount
*
sizeof
(
SkColor
)
)
SkOpts
:
:
hash
(
v
.
fColorOffsets
v
.
fColorCount
*
sizeof
(
SkScalar
)
)
SkOpts
:
:
hash
(
v
.
fPoint
2
*
sizeof
(
SkPoint
)
)
SkOpts
:
:
hash
(
v
.
fRadius
2
*
sizeof
(
SkScalar
)
)
(
uint32_t
)
v
.
fTileMode
v
.
fGradientFlags
}
;
return
SkOpts
:
:
hash
(
buffer
sizeof
(
buffer
)
)
;
}
static
uint32_t
hash
(
const
SkPDFGradientShader
:
:
Key
&
k
)
{
uint32_t
buffer
[
]
=
{
(
uint32_t
)
k
.
fType
hash
(
k
.
fInfo
)
SkOpts
:
:
hash
(
&
k
.
fCanvasTransform
sizeof
(
SkMatrix
)
)
SkOpts
:
:
hash
(
&
k
.
fShaderTransform
sizeof
(
SkMatrix
)
)
SkOpts
:
:
hash
(
&
k
.
fBBox
sizeof
(
SkIRect
)
)
}
;
return
SkOpts
:
:
hash
(
buffer
sizeof
(
buffer
)
)
;
}
static
void
unit_to_points_matrix
(
const
SkPoint
pts
[
2
]
SkMatrix
*
matrix
)
{
SkVector
vec
=
pts
[
1
]
-
pts
[
0
]
;
SkScalar
mag
=
vec
.
length
(
)
;
SkScalar
inv
=
mag
?
SkScalarInvert
(
mag
)
:
0
;
vec
.
scale
(
inv
)
;
matrix
-
>
setSinCos
(
vec
.
fY
vec
.
fX
)
;
matrix
-
>
preScale
(
mag
mag
)
;
matrix
-
>
postTranslate
(
pts
[
0
]
.
fX
pts
[
0
]
.
fY
)
;
}
static
const
int
kColorComponents
=
3
;
typedef
uint8_t
ColorTuple
[
kColorComponents
]
;
static
void
interpolate_color_code
(
SkScalar
range
const
ColorTuple
&
curColor
const
ColorTuple
&
prevColor
SkDynamicMemoryWStream
*
result
)
{
SkASSERT
(
range
!
=
SkIntToScalar
(
0
)
)
;
SkScalar
multiplier
[
kColorComponents
]
;
for
(
int
i
=
0
;
i
<
kColorComponents
;
i
+
+
)
{
static
const
SkScalar
kColorScale
=
SkScalarInvert
(
255
)
;
multiplier
[
i
]
=
kColorScale
*
(
curColor
[
i
]
-
prevColor
[
i
]
)
/
range
;
}
bool
dupInput
[
kColorComponents
]
;
dupInput
[
kColorComponents
-
1
]
=
false
;
for
(
int
i
=
kColorComponents
-
2
;
i
>
=
0
;
i
-
-
)
{
dupInput
[
i
]
=
dupInput
[
i
+
1
]
|
|
multiplier
[
i
+
1
]
!
=
0
;
}
if
(
!
dupInput
[
0
]
&
&
multiplier
[
0
]
=
=
0
)
{
result
-
>
writeText
(
"
pop
"
)
;
}
for
(
int
i
=
0
;
i
<
kColorComponents
;
i
+
+
)
{
if
(
dupInput
[
i
]
&
&
multiplier
[
i
]
!
=
0
)
{
result
-
>
writeText
(
"
dup
"
)
;
}
if
(
multiplier
[
i
]
=
=
0
)
{
SkPDFUtils
:
:
AppendColorComponent
(
prevColor
[
i
]
result
)
;
result
-
>
writeText
(
"
"
)
;
}
else
{
if
(
multiplier
[
i
]
!
=
1
)
{
SkPDFUtils
:
:
AppendScalar
(
multiplier
[
i
]
result
)
;
result
-
>
writeText
(
"
mul
"
)
;
}
if
(
prevColor
[
i
]
!
=
0
)
{
SkPDFUtils
:
:
AppendColorComponent
(
prevColor
[
i
]
result
)
;
result
-
>
writeText
(
"
add
"
)
;
}
}
if
(
dupInput
[
i
]
)
{
result
-
>
writeText
(
"
exch
\
n
"
)
;
}
}
}
static
void
gradient_function_code
(
const
SkShader
:
:
GradientInfo
&
info
SkDynamicMemoryWStream
*
result
)
{
SkAutoSTMalloc
<
4
ColorTuple
>
colorDataAlloc
(
info
.
fColorCount
)
;
ColorTuple
*
colorData
=
colorDataAlloc
.
get
(
)
;
for
(
int
i
=
0
;
i
<
info
.
fColorCount
;
i
+
+
)
{
colorData
[
i
]
[
0
]
=
SkColorGetR
(
info
.
fColors
[
i
]
)
;
colorData
[
i
]
[
1
]
=
SkColorGetG
(
info
.
fColors
[
i
]
)
;
colorData
[
i
]
[
2
]
=
SkColorGetB
(
info
.
fColors
[
i
]
)
;
}
result
-
>
writeText
(
"
dup
0
le
{
pop
"
)
;
SkPDFUtils
:
:
AppendColorComponent
(
colorData
[
0
]
[
0
]
result
)
;
result
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendColorComponent
(
colorData
[
0
]
[
1
]
result
)
;
result
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendColorComponent
(
colorData
[
0
]
[
2
]
result
)
;
result
-
>
writeText
(
"
}
\
n
"
)
;
int
gradients
=
0
;
for
(
int
i
=
1
;
i
<
info
.
fColorCount
;
i
+
+
)
{
if
(
info
.
fColorOffsets
[
i
]
=
=
info
.
fColorOffsets
[
i
-
1
]
)
{
continue
;
}
gradients
+
+
;
result
-
>
writeText
(
"
{
dup
"
)
;
SkPDFUtils
:
:
AppendScalar
(
info
.
fColorOffsets
[
i
]
result
)
;
result
-
>
writeText
(
"
le
{
"
)
;
if
(
info
.
fColorOffsets
[
i
-
1
]
!
=
0
)
{
SkPDFUtils
:
:
AppendScalar
(
info
.
fColorOffsets
[
i
-
1
]
result
)
;
result
-
>
writeText
(
"
sub
\
n
"
)
;
}
interpolate_color_code
(
info
.
fColorOffsets
[
i
]
-
info
.
fColorOffsets
[
i
-
1
]
colorData
[
i
]
colorData
[
i
-
1
]
result
)
;
result
-
>
writeText
(
"
}
\
n
"
)
;
}
result
-
>
writeText
(
"
{
pop
"
)
;
SkPDFUtils
:
:
AppendColorComponent
(
colorData
[
info
.
fColorCount
-
1
]
[
0
]
result
)
;
result
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendColorComponent
(
colorData
[
info
.
fColorCount
-
1
]
[
1
]
result
)
;
result
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendColorComponent
(
colorData
[
info
.
fColorCount
-
1
]
[
2
]
result
)
;
for
(
int
i
=
0
;
i
<
gradients
+
1
;
i
+
+
)
{
result
-
>
writeText
(
"
}
ifelse
\
n
"
)
;
}
}
static
sk_sp
<
SkPDFDict
>
createInterpolationFunction
(
const
ColorTuple
&
color1
const
ColorTuple
&
color2
)
{
auto
retval
=
sk_make_sp
<
SkPDFDict
>
(
)
;
auto
c0
=
sk_make_sp
<
SkPDFArray
>
(
)
;
c0
-
>
appendColorComponent
(
color1
[
0
]
)
;
c0
-
>
appendColorComponent
(
color1
[
1
]
)
;
c0
-
>
appendColorComponent
(
color1
[
2
]
)
;
retval
-
>
insertObject
(
"
C0
"
std
:
:
move
(
c0
)
)
;
auto
c1
=
sk_make_sp
<
SkPDFArray
>
(
)
;
c1
-
>
appendColorComponent
(
color2
[
0
]
)
;
c1
-
>
appendColorComponent
(
color2
[
1
]
)
;
c1
-
>
appendColorComponent
(
color2
[
2
]
)
;
retval
-
>
insertObject
(
"
C1
"
std
:
:
move
(
c1
)
)
;
auto
domain
=
sk_make_sp
<
SkPDFArray
>
(
)
;
domain
-
>
appendScalar
(
0
)
;
domain
-
>
appendScalar
(
1
.
0f
)
;
retval
-
>
insertObject
(
"
Domain
"
std
:
:
move
(
domain
)
)
;
retval
-
>
insertInt
(
"
FunctionType
"
2
)
;
retval
-
>
insertScalar
(
"
N
"
1
.
0f
)
;
return
retval
;
}
static
sk_sp
<
SkPDFDict
>
gradientStitchCode
(
const
SkShader
:
:
GradientInfo
&
info
)
{
auto
retval
=
sk_make_sp
<
SkPDFDict
>
(
)
;
int
colorCount
=
info
.
fColorCount
;
SkTDArray
<
SkColor
>
colors
(
info
.
fColors
colorCount
)
;
SkTDArray
<
SkScalar
>
colorOffsets
(
info
.
fColorOffsets
colorCount
)
;
int
i
=
1
;
while
(
i
<
colorCount
-
1
)
{
if
(
colorOffsets
[
i
-
1
]
>
colorOffsets
[
i
]
)
{
colorOffsets
[
i
]
=
colorOffsets
[
i
-
1
]
;
}
if
(
(
colorOffsets
[
i
-
1
]
=
=
colorOffsets
[
i
]
)
&
&
(
colorOffsets
[
i
]
=
=
colorOffsets
[
i
+
1
]
)
)
{
colorCount
-
=
1
;
colors
.
remove
(
i
)
;
colorOffsets
.
remove
(
i
)
;
}
else
{
i
+
+
;
}
}
for
(
i
=
1
;
i
<
colorCount
-
1
;
i
+
+
)
{
if
(
colorOffsets
[
i
-
1
]
=
=
colorOffsets
[
i
]
)
{
colorOffsets
[
i
]
+
=
0
.
00001f
;
}
}
if
(
colorOffsets
[
i
-
1
]
=
=
colorOffsets
[
i
]
)
{
colorOffsets
[
i
-
1
]
-
=
0
.
00001f
;
}
SkAutoSTMalloc
<
4
ColorTuple
>
colorDataAlloc
(
colorCount
)
;
ColorTuple
*
colorData
=
colorDataAlloc
.
get
(
)
;
for
(
int
i
=
0
;
i
<
colorCount
;
i
+
+
)
{
colorData
[
i
]
[
0
]
=
SkColorGetR
(
colors
[
i
]
)
;
colorData
[
i
]
[
1
]
=
SkColorGetG
(
colors
[
i
]
)
;
colorData
[
i
]
[
2
]
=
SkColorGetB
(
colors
[
i
]
)
;
}
if
(
colorCount
=
=
2
)
return
createInterpolationFunction
(
colorData
[
0
]
colorData
[
1
]
)
;
auto
encode
=
sk_make_sp
<
SkPDFArray
>
(
)
;
auto
bounds
=
sk_make_sp
<
SkPDFArray
>
(
)
;
auto
functions
=
sk_make_sp
<
SkPDFArray
>
(
)
;
auto
domain
=
sk_make_sp
<
SkPDFArray
>
(
)
;
domain
-
>
appendScalar
(
0
)
;
domain
-
>
appendScalar
(
1
.
0f
)
;
retval
-
>
insertObject
(
"
Domain
"
std
:
:
move
(
domain
)
)
;
retval
-
>
insertInt
(
"
FunctionType
"
3
)
;
for
(
int
i
=
1
;
i
<
colorCount
;
i
+
+
)
{
if
(
i
>
1
)
{
bounds
-
>
appendScalar
(
colorOffsets
[
i
-
1
]
)
;
}
encode
-
>
appendScalar
(
0
)
;
encode
-
>
appendScalar
(
1
.
0f
)
;
functions
-
>
appendObject
(
createInterpolationFunction
(
colorData
[
i
-
1
]
colorData
[
i
]
)
)
;
}
retval
-
>
insertObject
(
"
Encode
"
std
:
:
move
(
encode
)
)
;
retval
-
>
insertObject
(
"
Bounds
"
std
:
:
move
(
bounds
)
)
;
retval
-
>
insertObject
(
"
Functions
"
std
:
:
move
(
functions
)
)
;
return
retval
;
}
static
void
tileModeCode
(
SkShader
:
:
TileMode
mode
SkDynamicMemoryWStream
*
result
)
{
if
(
mode
=
=
SkShader
:
:
kRepeat_TileMode
)
{
result
-
>
writeText
(
"
dup
truncate
sub
\
n
"
)
;
result
-
>
writeText
(
"
dup
0
le
{
1
add
}
if
\
n
"
)
;
return
;
}
if
(
mode
=
=
SkShader
:
:
kMirror_TileMode
)
{
result
-
>
writeText
(
"
abs
"
"
dup
"
"
truncate
"
"
dup
"
"
cvi
"
"
2
mod
"
"
1
eq
"
"
3
1
roll
"
"
sub
"
"
exch
"
"
{
1
exch
sub
}
if
\
n
"
)
;
}
}
static
void
apply_perspective_to_coordinates
(
const
SkMatrix
&
inversePerspectiveMatrix
SkDynamicMemoryWStream
*
code
)
{
if
(
!
inversePerspectiveMatrix
.
hasPerspective
(
)
)
{
return
;
}
const
SkScalar
p0
=
inversePerspectiveMatrix
[
SkMatrix
:
:
kMPersp0
]
;
const
SkScalar
p1
=
inversePerspectiveMatrix
[
SkMatrix
:
:
kMPersp1
]
;
const
SkScalar
p2
=
inversePerspectiveMatrix
[
SkMatrix
:
:
kMPersp2
]
;
code
-
>
writeText
(
"
dup
"
)
;
SkPDFUtils
:
:
AppendScalar
(
p1
code
)
;
code
-
>
writeText
(
"
mul
"
"
2
index
"
)
;
SkPDFUtils
:
:
AppendScalar
(
p0
code
)
;
code
-
>
writeText
(
"
mul
"
)
;
SkPDFUtils
:
:
AppendScalar
(
p2
code
)
;
code
-
>
writeText
(
"
add
"
"
add
"
"
3
1
roll
"
"
2
index
"
"
div
"
"
3
1
roll
"
"
exch
"
"
div
"
"
exch
\
n
"
)
;
}
static
void
linearCode
(
const
SkShader
:
:
GradientInfo
&
info
const
SkMatrix
&
perspectiveRemover
SkDynamicMemoryWStream
*
function
)
{
function
-
>
writeText
(
"
{
"
)
;
apply_perspective_to_coordinates
(
perspectiveRemover
function
)
;
function
-
>
writeText
(
"
pop
\
n
"
)
;
tileModeCode
(
info
.
fTileMode
function
)
;
gradient_function_code
(
info
function
)
;
function
-
>
writeText
(
"
}
"
)
;
}
static
void
radialCode
(
const
SkShader
:
:
GradientInfo
&
info
const
SkMatrix
&
perspectiveRemover
SkDynamicMemoryWStream
*
function
)
{
function
-
>
writeText
(
"
{
"
)
;
apply_perspective_to_coordinates
(
perspectiveRemover
function
)
;
function
-
>
writeText
(
"
dup
"
"
mul
"
"
exch
"
"
dup
"
"
mul
"
"
add
"
"
sqrt
\
n
"
)
;
tileModeCode
(
info
.
fTileMode
function
)
;
gradient_function_code
(
info
function
)
;
function
-
>
writeText
(
"
}
"
)
;
}
static
void
twoPointConicalCode
(
const
SkShader
:
:
GradientInfo
&
info
const
SkMatrix
&
perspectiveRemover
SkDynamicMemoryWStream
*
function
)
{
SkScalar
dx
=
info
.
fPoint
[
1
]
.
fX
-
info
.
fPoint
[
0
]
.
fX
;
SkScalar
dy
=
info
.
fPoint
[
1
]
.
fY
-
info
.
fPoint
[
0
]
.
fY
;
SkScalar
r0
=
info
.
fRadius
[
0
]
;
SkScalar
dr
=
info
.
fRadius
[
1
]
-
info
.
fRadius
[
0
]
;
SkScalar
a
=
dx
*
dx
+
dy
*
dy
-
dr
*
dr
;
function
-
>
writeText
(
"
{
"
)
;
apply_perspective_to_coordinates
(
perspectiveRemover
function
)
;
function
-
>
writeText
(
"
2
copy
"
)
;
SkPDFUtils
:
:
AppendScalar
(
dy
function
)
;
function
-
>
writeText
(
"
mul
exch
"
)
;
SkPDFUtils
:
:
AppendScalar
(
dx
function
)
;
function
-
>
writeText
(
"
mul
add
"
)
;
SkPDFUtils
:
:
AppendScalar
(
r0
*
dr
function
)
;
function
-
>
writeText
(
"
add
-
2
mul
dup
dup
mul
\
n
"
)
;
function
-
>
writeText
(
"
4
2
roll
dup
mul
exch
dup
mul
add
"
)
;
SkPDFUtils
:
:
AppendScalar
(
r0
*
r0
function
)
;
function
-
>
writeText
(
"
sub
dup
4
1
roll
\
n
"
)
;
if
(
a
=
=
0
)
{
function
-
>
writeText
(
"
pop
pop
div
neg
dup
"
)
;
SkPDFUtils
:
:
AppendScalar
(
dr
function
)
;
function
-
>
writeText
(
"
mul
"
)
;
SkPDFUtils
:
:
AppendScalar
(
r0
function
)
;
function
-
>
writeText
(
"
add
\
n
"
)
;
function
-
>
writeText
(
"
0
lt
{
pop
false
}
{
true
}
ifelse
\
n
"
)
;
}
else
{
SkPDFUtils
:
:
AppendScalar
(
a
*
4
function
)
;
function
-
>
writeText
(
"
mul
sub
dup
\
n
"
)
;
function
-
>
writeText
(
"
0
ge
{
\
n
"
)
;
function
-
>
writeText
(
"
sqrt
exch
dup
0
lt
{
exch
-
1
mul
}
if
"
)
;
function
-
>
writeText
(
"
add
-
0
.
5
mul
dup
\
n
"
)
;
SkPDFUtils
:
:
AppendScalar
(
a
function
)
;
function
-
>
writeText
(
"
div
\
n
"
)
;
function
-
>
writeText
(
"
3
1
roll
div
\
n
"
)
;
function
-
>
writeText
(
"
2
copy
gt
{
exch
}
if
\
n
"
)
;
function
-
>
writeText
(
"
dup
"
)
;
SkPDFUtils
:
:
AppendScalar
(
dr
function
)
;
function
-
>
writeText
(
"
mul
"
)
;
SkPDFUtils
:
:
AppendScalar
(
r0
function
)
;
function
-
>
writeText
(
"
add
\
n
"
)
;
function
-
>
writeText
(
"
0
gt
{
exch
pop
true
}
\
n
"
)
;
function
-
>
writeText
(
"
{
pop
dup
\
n
"
)
;
SkPDFUtils
:
:
AppendScalar
(
dr
function
)
;
function
-
>
writeText
(
"
mul
"
)
;
SkPDFUtils
:
:
AppendScalar
(
r0
function
)
;
function
-
>
writeText
(
"
add
\
n
"
)
;
function
-
>
writeText
(
"
0
le
{
pop
false
}
{
true
}
ifelse
\
n
"
)
;
function
-
>
writeText
(
"
}
ifelse
\
n
"
)
;
function
-
>
writeText
(
"
}
{
pop
pop
pop
false
}
ifelse
\
n
"
)
;
}
function
-
>
writeText
(
"
{
"
)
;
tileModeCode
(
info
.
fTileMode
function
)
;
gradient_function_code
(
info
function
)
;
function
-
>
writeText
(
"
}
{
0
0
0
}
ifelse
}
"
)
;
}
static
void
sweepCode
(
const
SkShader
:
:
GradientInfo
&
info
const
SkMatrix
&
perspectiveRemover
SkDynamicMemoryWStream
*
function
)
{
function
-
>
writeText
(
"
{
exch
atan
360
div
\
n
"
)
;
tileModeCode
(
info
.
fTileMode
function
)
;
gradient_function_code
(
info
function
)
;
function
-
>
writeText
(
"
}
"
)
;
}
static
void
FixUpRadius
(
const
SkPoint
&
p1
SkScalar
&
r1
const
SkPoint
&
p2
SkScalar
&
r2
)
{
SkScalar
distance
=
SkPoint
:
:
Distance
(
p1
p2
)
;
SkScalar
subtractRadii
=
fabs
(
r1
-
r2
)
;
if
(
fabs
(
distance
-
subtractRadii
)
<
0
.
002f
)
{
if
(
r1
>
r2
)
{
r1
+
=
0
.
002f
;
}
else
{
r2
+
=
0
.
002f
;
}
}
}
static
bool
split_perspective
(
const
SkMatrix
in
SkMatrix
*
affine
SkMatrix
*
perspectiveInverse
)
{
const
SkScalar
p2
=
in
[
SkMatrix
:
:
kMPersp2
]
;
if
(
SkScalarNearlyZero
(
p2
)
)
{
return
false
;
}
const
SkScalar
zero
=
SkIntToScalar
(
0
)
;
const
SkScalar
one
=
SkIntToScalar
(
1
)
;
const
SkScalar
sx
=
in
[
SkMatrix
:
:
kMScaleX
]
;
const
SkScalar
kx
=
in
[
SkMatrix
:
:
kMSkewX
]
;
const
SkScalar
tx
=
in
[
SkMatrix
:
:
kMTransX
]
;
const
SkScalar
ky
=
in
[
SkMatrix
:
:
kMSkewY
]
;
const
SkScalar
sy
=
in
[
SkMatrix
:
:
kMScaleY
]
;
const
SkScalar
ty
=
in
[
SkMatrix
:
:
kMTransY
]
;
const
SkScalar
p0
=
in
[
SkMatrix
:
:
kMPersp0
]
;
const
SkScalar
p1
=
in
[
SkMatrix
:
:
kMPersp1
]
;
perspectiveInverse
-
>
setAll
(
one
zero
zero
zero
one
zero
-
p0
/
p2
-
p1
/
p2
1
/
p2
)
;
affine
-
>
setAll
(
sx
-
p0
*
tx
/
p2
kx
-
p1
*
tx
/
p2
tx
/
p2
ky
-
p0
*
ty
/
p2
sy
-
p1
*
ty
/
p2
ty
/
p2
zero
zero
one
)
;
return
true
;
}
static
sk_sp
<
SkPDFArray
>
make_range_object
(
)
{
auto
range
=
sk_make_sp
<
SkPDFArray
>
(
)
;
range
-
>
reserve
(
6
)
;
range
-
>
appendInt
(
0
)
;
range
-
>
appendInt
(
1
)
;
range
-
>
appendInt
(
0
)
;
range
-
>
appendInt
(
1
)
;
range
-
>
appendInt
(
0
)
;
range
-
>
appendInt
(
1
)
;
return
range
;
}
static
sk_sp
<
SkPDFStream
>
make_ps_function
(
std
:
:
unique_ptr
<
SkStreamAsset
>
psCode
sk_sp
<
SkPDFArray
>
domain
sk_sp
<
SkPDFObject
>
range
)
{
auto
result
=
sk_make_sp
<
SkPDFStream
>
(
std
:
:
move
(
psCode
)
)
;
result
-
>
dict
(
)
-
>
insertInt
(
"
FunctionType
"
4
)
;
result
-
>
dict
(
)
-
>
insertObject
(
"
Domain
"
std
:
:
move
(
domain
)
)
;
result
-
>
dict
(
)
-
>
insertObject
(
"
Range
"
std
:
:
move
(
range
)
)
;
return
result
;
}
static
sk_sp
<
SkPDFDict
>
make_function_shader
(
SkPDFCanon
*
canon
const
SkPDFGradientShader
:
:
Key
&
state
)
{
SkPoint
transformPoints
[
2
]
;
const
SkShader
:
:
GradientInfo
&
info
=
state
.
fInfo
;
SkMatrix
finalMatrix
=
state
.
fCanvasTransform
;
finalMatrix
.
preConcat
(
state
.
fShaderTransform
)
;
bool
doStitchFunctions
=
(
state
.
fType
=
=
SkShader
:
:
kLinear_GradientType
|
|
state
.
fType
=
=
SkShader
:
:
kRadial_GradientType
|
|
state
.
fType
=
=
SkShader
:
:
kConical_GradientType
)
&
&
info
.
fTileMode
=
=
SkShader
:
:
kClamp_TileMode
&
&
!
finalMatrix
.
hasPerspective
(
)
;
auto
domain
=
sk_make_sp
<
SkPDFArray
>
(
)
;
int32_t
shadingType
=
1
;
auto
pdfShader
=
sk_make_sp
<
SkPDFDict
>
(
)
;
if
(
doStitchFunctions
)
{
pdfShader
-
>
insertObject
(
"
Function
"
gradientStitchCode
(
info
)
)
;
shadingType
=
(
state
.
fType
=
=
SkShader
:
:
kLinear_GradientType
)
?
2
:
3
;
auto
extend
=
sk_make_sp
<
SkPDFArray
>
(
)
;
extend
-
>
reserve
(
2
)
;
extend
-
>
appendBool
(
true
)
;
extend
-
>
appendBool
(
true
)
;
pdfShader
-
>
insertObject
(
"
Extend
"
std
:
:
move
(
extend
)
)
;
auto
coords
=
sk_make_sp
<
SkPDFArray
>
(
)
;
if
(
state
.
fType
=
=
SkShader
:
:
kConical_GradientType
)
{
coords
-
>
reserve
(
6
)
;
SkScalar
r1
=
info
.
fRadius
[
0
]
;
SkScalar
r2
=
info
.
fRadius
[
1
]
;
SkPoint
pt1
=
info
.
fPoint
[
0
]
;
SkPoint
pt2
=
info
.
fPoint
[
1
]
;
FixUpRadius
(
pt1
r1
pt2
r2
)
;
coords
-
>
appendScalar
(
pt1
.
fX
)
;
coords
-
>
appendScalar
(
pt1
.
fY
)
;
coords
-
>
appendScalar
(
r1
)
;
coords
-
>
appendScalar
(
pt2
.
fX
)
;
coords
-
>
appendScalar
(
pt2
.
fY
)
;
coords
-
>
appendScalar
(
r2
)
;
}
else
if
(
state
.
fType
=
=
SkShader
:
:
kRadial_GradientType
)
{
coords
-
>
reserve
(
6
)
;
const
SkPoint
&
pt1
=
info
.
fPoint
[
0
]
;
coords
-
>
appendScalar
(
pt1
.
fX
)
;
coords
-
>
appendScalar
(
pt1
.
fY
)
;
coords
-
>
appendScalar
(
0
)
;
coords
-
>
appendScalar
(
pt1
.
fX
)
;
coords
-
>
appendScalar
(
pt1
.
fY
)
;
coords
-
>
appendScalar
(
info
.
fRadius
[
0
]
)
;
}
else
{
coords
-
>
reserve
(
4
)
;
const
SkPoint
&
pt1
=
info
.
fPoint
[
0
]
;
const
SkPoint
&
pt2
=
info
.
fPoint
[
1
]
;
coords
-
>
appendScalar
(
pt1
.
fX
)
;
coords
-
>
appendScalar
(
pt1
.
fY
)
;
coords
-
>
appendScalar
(
pt2
.
fX
)
;
coords
-
>
appendScalar
(
pt2
.
fY
)
;
}
pdfShader
-
>
insertObject
(
"
Coords
"
std
:
:
move
(
coords
)
)
;
}
else
{
transformPoints
[
0
]
=
info
.
fPoint
[
0
]
;
transformPoints
[
1
]
=
info
.
fPoint
[
1
]
;
switch
(
state
.
fType
)
{
case
SkShader
:
:
kLinear_GradientType
:
break
;
case
SkShader
:
:
kRadial_GradientType
:
transformPoints
[
1
]
=
transformPoints
[
0
]
;
transformPoints
[
1
]
.
fX
+
=
info
.
fRadius
[
0
]
;
break
;
case
SkShader
:
:
kConical_GradientType
:
{
transformPoints
[
1
]
=
transformPoints
[
0
]
;
transformPoints
[
1
]
.
fX
+
=
SK_Scalar1
;
break
;
}
case
SkShader
:
:
kSweep_GradientType
:
transformPoints
[
1
]
=
transformPoints
[
0
]
;
transformPoints
[
1
]
.
fX
+
=
SK_Scalar1
;
break
;
case
SkShader
:
:
kColor_GradientType
:
case
SkShader
:
:
kNone_GradientType
:
default
:
return
nullptr
;
}
SkMatrix
mapperMatrix
;
unit_to_points_matrix
(
transformPoints
&
mapperMatrix
)
;
finalMatrix
.
preConcat
(
mapperMatrix
)
;
SkMatrix
perspectiveInverseOnly
=
SkMatrix
:
:
I
(
)
;
if
(
finalMatrix
.
hasPerspective
(
)
)
{
if
(
!
split_perspective
(
finalMatrix
&
finalMatrix
&
perspectiveInverseOnly
)
)
{
return
nullptr
;
}
}
SkRect
bbox
;
bbox
.
set
(
state
.
fBBox
)
;
if
(
!
SkPDFUtils
:
:
InverseTransformBBox
(
finalMatrix
&
bbox
)
)
{
return
nullptr
;
}
domain
-
>
reserve
(
4
)
;
domain
-
>
appendScalar
(
bbox
.
fLeft
)
;
domain
-
>
appendScalar
(
bbox
.
fRight
)
;
domain
-
>
appendScalar
(
bbox
.
fTop
)
;
domain
-
>
appendScalar
(
bbox
.
fBottom
)
;
SkDynamicMemoryWStream
functionCode
;
SkShader
:
:
GradientInfo
infoCopy
=
info
;
if
(
state
.
fType
=
=
SkShader
:
:
kConical_GradientType
)
{
SkMatrix
inverseMapperMatrix
;
if
(
!
mapperMatrix
.
invert
(
&
inverseMapperMatrix
)
)
{
return
nullptr
;
}
inverseMapperMatrix
.
mapPoints
(
infoCopy
.
fPoint
2
)
;
infoCopy
.
fRadius
[
0
]
=
inverseMapperMatrix
.
mapRadius
(
info
.
fRadius
[
0
]
)
;
infoCopy
.
fRadius
[
1
]
=
inverseMapperMatrix
.
mapRadius
(
info
.
fRadius
[
1
]
)
;
}
switch
(
state
.
fType
)
{
case
SkShader
:
:
kLinear_GradientType
:
linearCode
(
infoCopy
perspectiveInverseOnly
&
functionCode
)
;
break
;
case
SkShader
:
:
kRadial_GradientType
:
radialCode
(
infoCopy
perspectiveInverseOnly
&
functionCode
)
;
break
;
case
SkShader
:
:
kConical_GradientType
:
twoPointConicalCode
(
infoCopy
perspectiveInverseOnly
&
functionCode
)
;
break
;
case
SkShader
:
:
kSweep_GradientType
:
sweepCode
(
infoCopy
perspectiveInverseOnly
&
functionCode
)
;
break
;
default
:
SkASSERT
(
false
)
;
}
pdfShader
-
>
insertObject
(
"
Domain
"
domain
)
;
sk_sp
<
SkPDFArray
>
&
rangeObject
=
canon
-
>
fRangeObject
;
if
(
!
rangeObject
)
{
rangeObject
=
make_range_object
(
)
;
}
pdfShader
-
>
insertObjRef
(
"
Function
"
make_ps_function
(
functionCode
.
detachAsStream
(
)
std
:
:
move
(
domain
)
rangeObject
)
)
;
}
pdfShader
-
>
insertInt
(
"
ShadingType
"
shadingType
)
;
pdfShader
-
>
insertName
(
"
ColorSpace
"
"
DeviceRGB
"
)
;
auto
pdfFunctionShader
=
sk_make_sp
<
SkPDFDict
>
(
"
Pattern
"
)
;
pdfFunctionShader
-
>
insertInt
(
"
PatternType
"
2
)
;
pdfFunctionShader
-
>
insertObject
(
"
Matrix
"
SkPDFUtils
:
:
MatrixToArray
(
finalMatrix
)
)
;
pdfFunctionShader
-
>
insertObject
(
"
Shading
"
std
:
:
move
(
pdfShader
)
)
;
return
pdfFunctionShader
;
}
static
sk_sp
<
SkPDFObject
>
find_pdf_shader
(
SkPDFDocument
*
doc
SkPDFGradientShader
:
:
Key
key
bool
keyHasAlpha
)
;
static
sk_sp
<
SkPDFDict
>
get_gradient_resource_dict
(
SkPDFObject
*
functionShader
SkPDFObject
*
gState
)
{
SkTDArray
<
SkPDFObject
*
>
patterns
;
if
(
functionShader
)
{
patterns
.
push
(
functionShader
)
;
}
SkTDArray
<
SkPDFObject
*
>
graphicStates
;
if
(
gState
)
{
graphicStates
.
push
(
gState
)
;
}
return
SkPDFResourceDict
:
:
Make
(
&
graphicStates
&
patterns
nullptr
nullptr
)
;
}
static
std
:
:
unique_ptr
<
SkStreamAsset
>
create_pattern_fill_content
(
int
gsIndex
SkRect
&
bounds
)
{
SkDynamicMemoryWStream
content
;
if
(
gsIndex
>
=
0
)
{
SkPDFUtils
:
:
ApplyGraphicState
(
gsIndex
&
content
)
;
}
SkPDFUtils
:
:
ApplyPattern
(
0
&
content
)
;
SkPDFUtils
:
:
AppendRectangle
(
bounds
&
content
)
;
SkPDFUtils
:
:
PaintPath
(
SkPaint
:
:
kFill_Style
SkPath
:
:
kEvenOdd_FillType
&
content
)
;
return
content
.
detachAsStream
(
)
;
}
static
bool
gradient_has_alpha
(
const
SkPDFGradientShader
:
:
Key
&
key
)
{
SkASSERT
(
key
.
fType
!
=
SkShader
:
:
kNone_GradientType
)
;
for
(
int
i
=
0
;
i
<
key
.
fInfo
.
fColorCount
;
i
+
+
)
{
if
(
(
SkAlpha
)
SkColorGetA
(
key
.
fInfo
.
fColors
[
i
]
)
!
=
SK_AlphaOPAQUE
)
{
return
true
;
}
}
return
false
;
}
static
SkPDFGradientShader
:
:
Key
clone_key
(
const
SkPDFGradientShader
:
:
Key
&
k
)
{
SkPDFGradientShader
:
:
Key
clone
=
{
k
.
fType
k
.
fInfo
std
:
:
unique_ptr
<
SkColor
[
]
>
(
new
SkColor
[
k
.
fInfo
.
fColorCount
]
)
std
:
:
unique_ptr
<
SkScalar
[
]
>
(
new
SkScalar
[
k
.
fInfo
.
fColorCount
]
)
k
.
fCanvasTransform
k
.
fShaderTransform
k
.
fBBox
0
}
;
clone
.
fInfo
.
fColors
=
clone
.
fColors
.
get
(
)
;
clone
.
fInfo
.
fColorOffsets
=
clone
.
fStops
.
get
(
)
;
for
(
int
i
=
0
;
i
<
clone
.
fInfo
.
fColorCount
;
i
+
+
)
{
clone
.
fInfo
.
fColorOffsets
[
i
]
=
k
.
fInfo
.
fColorOffsets
[
i
]
;
clone
.
fInfo
.
fColors
[
i
]
=
k
.
fInfo
.
fColors
[
i
]
;
}
return
clone
;
}
static
sk_sp
<
SkPDFObject
>
create_smask_graphic_state
(
SkPDFDocument
*
doc
const
SkPDFGradientShader
:
:
Key
&
state
)
{
SkASSERT
(
state
.
fType
!
=
SkShader
:
:
kNone_GradientType
)
;
SkPDFGradientShader
:
:
Key
luminosityState
=
clone_key
(
state
)
;
for
(
int
i
=
0
;
i
<
luminosityState
.
fInfo
.
fColorCount
;
i
+
+
)
{
SkAlpha
alpha
=
SkColorGetA
(
luminosityState
.
fInfo
.
fColors
[
i
]
)
;
luminosityState
.
fInfo
.
fColors
[
i
]
=
SkColorSetARGB
(
255
alpha
alpha
alpha
)
;
}
luminosityState
.
fHash
=
hash
(
luminosityState
)
;
SkASSERT
(
!
gradient_has_alpha
(
luminosityState
)
)
;
sk_sp
<
SkPDFObject
>
luminosityShader
=
find_pdf_shader
(
doc
std
:
:
move
(
luminosityState
)
false
)
;
sk_sp
<
SkPDFDict
>
resources
=
get_gradient_resource_dict
(
luminosityShader
.
get
(
)
nullptr
)
;
SkRect
bbox
=
SkRect
:
:
Make
(
state
.
fBBox
)
;
sk_sp
<
SkPDFObject
>
alphaMask
=
SkPDFMakeFormXObject
(
create_pattern_fill_content
(
-
1
bbox
)
SkPDFUtils
:
:
RectToArray
(
bbox
)
std
:
:
move
(
resources
)
SkMatrix
:
:
I
(
)
"
DeviceRGB
"
)
;
return
SkPDFGraphicState
:
:
GetSMaskGraphicState
(
std
:
:
move
(
alphaMask
)
false
SkPDFGraphicState
:
:
kLuminosity_SMaskMode
doc
-
>
canon
(
)
)
;
}
static
sk_sp
<
SkPDFStream
>
make_alpha_function_shader
(
SkPDFDocument
*
doc
const
SkPDFGradientShader
:
:
Key
&
state
)
{
SkASSERT
(
state
.
fType
!
=
SkShader
:
:
kNone_GradientType
)
;
SkPDFGradientShader
:
:
Key
opaqueState
=
clone_key
(
state
)
;
for
(
int
i
=
0
;
i
<
opaqueState
.
fInfo
.
fColorCount
;
i
+
+
)
{
opaqueState
.
fInfo
.
fColors
[
i
]
=
SkColorSetA
(
opaqueState
.
fInfo
.
fColors
[
i
]
SK_AlphaOPAQUE
)
;
}
opaqueState
.
fHash
=
hash
(
opaqueState
)
;
SkASSERT
(
!
gradient_has_alpha
(
opaqueState
)
)
;
SkRect
bbox
=
SkRect
:
:
Make
(
state
.
fBBox
)
;
sk_sp
<
SkPDFObject
>
colorShader
=
find_pdf_shader
(
doc
std
:
:
move
(
opaqueState
)
false
)
;
if
(
!
colorShader
)
{
return
nullptr
;
}
sk_sp
<
SkPDFObject
>
alphaGs
=
create_smask_graphic_state
(
doc
state
)
;
sk_sp
<
SkPDFDict
>
resourceDict
=
get_gradient_resource_dict
(
colorShader
.
get
(
)
alphaGs
.
get
(
)
)
;
std
:
:
unique_ptr
<
SkStreamAsset
>
colorStream
(
create_pattern_fill_content
(
0
bbox
)
)
;
auto
alphaFunctionShader
=
sk_make_sp
<
SkPDFStream
>
(
std
:
:
move
(
colorStream
)
)
;
SkPDFUtils
:
:
PopulateTilingPatternDict
(
alphaFunctionShader
-
>
dict
(
)
bbox
std
:
:
move
(
resourceDict
)
SkMatrix
:
:
I
(
)
)
;
return
alphaFunctionShader
;
}
static
SkPDFGradientShader
:
:
Key
make_key
(
const
SkShader
*
shader
const
SkMatrix
&
canvasTransform
const
SkIRect
&
bbox
)
{
SkPDFGradientShader
:
:
Key
key
=
{
SkShader
:
:
kNone_GradientType
{
0
nullptr
nullptr
{
{
0
0
}
{
0
0
}
}
{
0
0
}
SkShader
:
:
kClamp_TileMode
0
}
nullptr
nullptr
canvasTransform
SkPDFUtils
:
:
GetShaderLocalMatrix
(
shader
)
bbox
0
}
;
key
.
fType
=
shader
-
>
asAGradient
(
&
key
.
fInfo
)
;
SkASSERT
(
SkShader
:
:
kNone_GradientType
!
=
key
.
fType
)
;
SkASSERT
(
key
.
fInfo
.
fColorCount
>
0
)
;
key
.
fColors
.
reset
(
new
SkColor
[
key
.
fInfo
.
fColorCount
]
)
;
key
.
fStops
.
reset
(
new
SkScalar
[
key
.
fInfo
.
fColorCount
]
)
;
key
.
fInfo
.
fColors
=
key
.
fColors
.
get
(
)
;
key
.
fInfo
.
fColorOffsets
=
key
.
fStops
.
get
(
)
;
(
void
)
shader
-
>
asAGradient
(
&
key
.
fInfo
)
;
key
.
fHash
=
hash
(
key
)
;
return
key
;
}
static
sk_sp
<
SkPDFObject
>
find_pdf_shader
(
SkPDFDocument
*
doc
SkPDFGradientShader
:
:
Key
key
bool
keyHasAlpha
)
{
SkASSERT
(
gradient_has_alpha
(
key
)
=
=
keyHasAlpha
)
;
SkPDFCanon
*
canon
=
doc
-
>
canon
(
)
;
if
(
sk_sp
<
SkPDFObject
>
*
ptr
=
canon
-
>
fGradientPatternMap
.
find
(
key
)
)
{
return
*
ptr
;
}
sk_sp
<
SkPDFObject
>
pdfShader
;
if
(
keyHasAlpha
)
{
pdfShader
=
make_alpha_function_shader
(
doc
key
)
;
}
else
{
pdfShader
=
make_function_shader
(
canon
key
)
;
}
canon
-
>
fGradientPatternMap
.
set
(
std
:
:
move
(
key
)
pdfShader
)
;
return
pdfShader
;
}
sk_sp
<
SkPDFObject
>
SkPDFGradientShader
:
:
Make
(
SkPDFDocument
*
doc
SkShader
*
shader
const
SkMatrix
&
canvasTransform
const
SkIRect
&
bbox
)
{
SkASSERT
(
shader
)
;
SkASSERT
(
SkShader
:
:
kNone_GradientType
!
=
shader
-
>
asAGradient
(
nullptr
)
)
;
SkPDFGradientShader
:
:
Key
key
=
make_key
(
shader
canvasTransform
bbox
)
;
bool
alpha
=
gradient_has_alpha
(
key
)
;
return
find_pdf_shader
(
doc
std
:
:
move
(
key
)
alpha
)
;
}
