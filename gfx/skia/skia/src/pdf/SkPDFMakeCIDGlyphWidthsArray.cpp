#
include
"
src
/
pdf
/
SkPDFMakeCIDGlyphWidthsArray
.
h
"
#
include
"
include
/
core
/
SkPaint
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
src
/
core
/
SkStrike
.
h
"
#
include
"
src
/
core
/
SkStrikeSpec
.
h
"
#
include
"
src
/
pdf
/
SkPDFGlyphUse
.
h
"
#
include
<
algorithm
>
#
include
<
vector
>
namespace
{
SkScalar
from_font_units
(
SkScalar
scaled
uint16_t
emSize
)
{
if
(
emSize
=
=
1000
)
{
return
scaled
;
}
else
{
return
scaled
*
1000
/
emSize
;
}
}
SkScalar
scale_from_font_units
(
int16_t
val
uint16_t
emSize
)
{
return
from_font_units
(
SkIntToScalar
(
val
)
emSize
)
;
}
#
if
defined
(
SK_PDF_CAN_USE_DW
)
int16_t
findMode
(
SkSpan
<
const
int16_t
>
advances
)
{
if
(
advances
.
empty
(
)
)
{
return
0
;
}
int16_t
previousAdvance
=
advances
[
0
]
;
int16_t
currentModeAdvance
=
advances
[
0
]
;
size_t
currentCount
=
1
;
size_t
currentModeCount
=
1
;
for
(
size_t
i
=
1
;
i
<
advances
.
size
(
)
;
+
+
i
)
{
if
(
advances
[
i
]
=
=
previousAdvance
)
{
+
+
currentCount
;
}
else
{
if
(
currentCount
>
currentModeCount
)
{
currentModeAdvance
=
previousAdvance
;
currentModeCount
=
currentCount
;
}
previousAdvance
=
advances
[
i
]
;
currentCount
=
1
;
}
}
return
currentCount
>
currentModeCount
?
previousAdvance
:
currentModeAdvance
;
}
#
endif
}
std
:
:
unique_ptr
<
SkPDFArray
>
SkPDFMakeCIDGlyphWidthsArray
(
const
SkTypeface
&
typeface
const
SkPDFGlyphUse
&
subset
SkScalar
*
defaultAdvance
)
{
int
emSize
;
SkStrikeSpec
strikeSpec
=
SkStrikeSpec
:
:
MakePDFVector
(
typeface
&
emSize
)
;
SkBulkGlyphMetricsAndPaths
paths
{
strikeSpec
}
;
auto
result
=
SkPDFMakeArray
(
)
;
std
:
:
vector
<
SkGlyphID
>
glyphIDs
;
subset
.
getSetValues
(
[
&
]
(
unsigned
index
)
{
glyphIDs
.
push_back
(
SkToU16
(
index
)
)
;
}
)
;
auto
glyphs
=
paths
.
glyphs
(
SkSpan
(
glyphIDs
)
)
;
#
if
defined
(
SK_PDF_CAN_USE_DW
)
std
:
:
vector
<
int16_t
>
advances
;
advances
.
reserve_back
(
glyphs
.
size
(
)
)
;
for
(
const
SkGlyph
*
glyph
:
glyphs
)
{
advances
.
push_back
(
(
int16_t
)
glyph
-
>
advanceX
(
)
)
;
}
std
:
:
sort
(
advances
.
begin
(
)
advances
.
end
(
)
)
;
int16_t
modeAdvance
=
findMode
(
SkSpan
(
advances
)
)
;
*
defaultAdvance
=
scale_from_font_units
(
modeAdvance
emSize
)
;
#
else
*
defaultAdvance
=
0
;
#
endif
for
(
size_t
i
=
0
;
i
<
glyphs
.
size
(
)
;
+
+
i
)
{
int16_t
advance
=
(
int16_t
)
glyphs
[
i
]
-
>
advanceX
(
)
;
#
if
defined
(
SK_PDF_CAN_USE_DW
)
if
(
advance
=
=
modeAdvance
)
{
continue
;
}
#
endif
{
size_t
j
=
i
+
1
;
for
(
;
j
<
glyphs
.
size
(
)
;
+
+
j
)
{
int16_t
next_advance
=
(
int16_t
)
glyphs
[
j
]
-
>
advanceX
(
)
;
if
(
advance
!
=
next_advance
)
{
break
;
}
}
if
(
j
-
i
>
=
2
)
{
result
-
>
appendInt
(
glyphs
[
i
]
-
>
getGlyphID
(
)
)
;
result
-
>
appendInt
(
glyphs
[
j
-
1
]
-
>
getGlyphID
(
)
)
;
result
-
>
appendScalar
(
scale_from_font_units
(
advance
emSize
)
)
;
i
=
j
-
1
;
continue
;
}
}
{
result
-
>
appendInt
(
glyphs
[
i
]
-
>
getGlyphID
(
)
)
;
auto
advanceArray
=
SkPDFMakeArray
(
)
;
advanceArray
-
>
appendScalar
(
scale_from_font_units
(
advance
emSize
)
)
;
size_t
j
=
i
+
1
;
for
(
;
j
<
glyphs
.
size
(
)
;
+
+
j
)
{
advance
=
(
int16_t
)
glyphs
[
j
]
-
>
advanceX
(
)
;
#
if
defined
(
SK_PDF_CAN_USE_DW
)
if
(
advance
=
=
modeAdvance
)
{
break
;
}
#
endif
int
dontCares
=
glyphs
[
j
]
-
>
getGlyphID
(
)
-
glyphs
[
j
-
1
]
-
>
getGlyphID
(
)
-
1
;
if
(
dontCares
>
=
4
)
{
break
;
}
int16_t
next_advance
=
0
;
if
(
j
+
1
<
glyphs
.
size
(
)
)
{
next_advance
=
(
int16_t
)
glyphs
[
j
+
1
]
-
>
advanceX
(
)
;
int
next_dontCares
=
glyphs
[
j
+
1
]
-
>
getGlyphID
(
)
-
glyphs
[
j
]
-
>
getGlyphID
(
)
-
1
;
if
(
advance
=
=
next_advance
&
&
dontCares
+
next_dontCares
>
=
4
)
{
break
;
}
}
if
(
j
+
2
<
glyphs
.
size
(
)
&
&
advance
=
=
next_advance
)
{
next_advance
=
(
int16_t
)
glyphs
[
j
+
2
]
-
>
advanceX
(
)
;
if
(
advance
=
=
next_advance
)
{
break
;
}
}
while
(
dontCares
-
-
>
0
)
{
advanceArray
-
>
appendScalar
(
0
)
;
}
advanceArray
-
>
appendScalar
(
scale_from_font_units
(
advance
emSize
)
)
;
}
result
-
>
appendObject
(
std
:
:
move
(
advanceArray
)
)
;
i
=
j
-
1
;
}
}
return
result
;
}
