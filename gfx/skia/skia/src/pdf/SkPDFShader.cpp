#
include
"
SkPDFShader
.
h
"
#
include
"
SkData
.
h
"
#
include
"
SkPDFCanon
.
h
"
#
include
"
SkPDFDevice
.
h
"
#
include
"
SkPDFDocument
.
h
"
#
include
"
SkPDFFormXObject
.
h
"
#
include
"
SkPDFGraphicState
.
h
"
#
include
"
SkPDFResourceDict
.
h
"
#
include
"
SkPDFUtils
.
h
"
#
include
"
SkScalar
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkTemplates
.
h
"
static
bool
inverse_transform_bbox
(
const
SkMatrix
&
matrix
SkRect
*
bbox
)
{
SkMatrix
inverse
;
if
(
!
matrix
.
invert
(
&
inverse
)
)
{
return
false
;
}
inverse
.
mapRect
(
bbox
)
;
return
true
;
}
static
void
unitToPointsMatrix
(
const
SkPoint
pts
[
2
]
SkMatrix
*
matrix
)
{
SkVector
vec
=
pts
[
1
]
-
pts
[
0
]
;
SkScalar
mag
=
vec
.
length
(
)
;
SkScalar
inv
=
mag
?
SkScalarInvert
(
mag
)
:
0
;
vec
.
scale
(
inv
)
;
matrix
-
>
setSinCos
(
vec
.
fY
vec
.
fX
)
;
matrix
-
>
preScale
(
mag
mag
)
;
matrix
-
>
postTranslate
(
pts
[
0
]
.
fX
pts
[
0
]
.
fY
)
;
}
static
void
interpolateColorCode
(
SkScalar
range
SkScalar
*
curColor
SkScalar
*
prevColor
SkDynamicMemoryWStream
*
result
)
{
SkASSERT
(
range
!
=
SkIntToScalar
(
0
)
)
;
static
const
int
kColorComponents
=
3
;
SkScalar
multiplier
[
kColorComponents
]
;
for
(
int
i
=
0
;
i
<
kColorComponents
;
i
+
+
)
{
multiplier
[
i
]
=
(
curColor
[
i
]
-
prevColor
[
i
]
)
/
range
;
}
bool
dupInput
[
kColorComponents
]
;
dupInput
[
kColorComponents
-
1
]
=
false
;
for
(
int
i
=
kColorComponents
-
2
;
i
>
=
0
;
i
-
-
)
{
dupInput
[
i
]
=
dupInput
[
i
+
1
]
|
|
multiplier
[
i
+
1
]
!
=
0
;
}
if
(
!
dupInput
[
0
]
&
&
multiplier
[
0
]
=
=
0
)
{
result
-
>
writeText
(
"
pop
"
)
;
}
for
(
int
i
=
0
;
i
<
kColorComponents
;
i
+
+
)
{
if
(
dupInput
[
i
]
&
&
multiplier
[
i
]
!
=
0
)
{
result
-
>
writeText
(
"
dup
"
)
;
}
if
(
multiplier
[
i
]
=
=
0
)
{
SkPDFUtils
:
:
AppendScalar
(
prevColor
[
i
]
result
)
;
result
-
>
writeText
(
"
"
)
;
}
else
{
if
(
multiplier
[
i
]
!
=
1
)
{
SkPDFUtils
:
:
AppendScalar
(
multiplier
[
i
]
result
)
;
result
-
>
writeText
(
"
mul
"
)
;
}
if
(
prevColor
[
i
]
!
=
0
)
{
SkPDFUtils
:
:
AppendScalar
(
prevColor
[
i
]
result
)
;
result
-
>
writeText
(
"
add
"
)
;
}
}
if
(
dupInput
[
i
]
)
{
result
-
>
writeText
(
"
exch
\
n
"
)
;
}
}
}
static
void
gradientFunctionCode
(
const
SkShader
:
:
GradientInfo
&
info
SkDynamicMemoryWStream
*
result
)
{
static
const
int
kColorComponents
=
3
;
typedef
SkScalar
ColorTuple
[
kColorComponents
]
;
SkAutoSTMalloc
<
4
ColorTuple
>
colorDataAlloc
(
info
.
fColorCount
)
;
ColorTuple
*
colorData
=
colorDataAlloc
.
get
(
)
;
const
SkScalar
scale
=
SkScalarInvert
(
SkIntToScalar
(
255
)
)
;
for
(
int
i
=
0
;
i
<
info
.
fColorCount
;
i
+
+
)
{
colorData
[
i
]
[
0
]
=
SkScalarMul
(
SkColorGetR
(
info
.
fColors
[
i
]
)
scale
)
;
colorData
[
i
]
[
1
]
=
SkScalarMul
(
SkColorGetG
(
info
.
fColors
[
i
]
)
scale
)
;
colorData
[
i
]
[
2
]
=
SkScalarMul
(
SkColorGetB
(
info
.
fColors
[
i
]
)
scale
)
;
}
result
-
>
writeText
(
"
dup
0
le
{
pop
"
)
;
SkPDFUtils
:
:
AppendScalar
(
colorData
[
0
]
[
0
]
result
)
;
result
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendScalar
(
colorData
[
0
]
[
1
]
result
)
;
result
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendScalar
(
colorData
[
0
]
[
2
]
result
)
;
result
-
>
writeText
(
"
}
\
n
"
)
;
int
gradients
=
0
;
for
(
int
i
=
1
;
i
<
info
.
fColorCount
;
i
+
+
)
{
if
(
info
.
fColorOffsets
[
i
]
=
=
info
.
fColorOffsets
[
i
-
1
]
)
{
continue
;
}
gradients
+
+
;
result
-
>
writeText
(
"
{
dup
"
)
;
SkPDFUtils
:
:
AppendScalar
(
info
.
fColorOffsets
[
i
]
result
)
;
result
-
>
writeText
(
"
le
{
"
)
;
if
(
info
.
fColorOffsets
[
i
-
1
]
!
=
0
)
{
SkPDFUtils
:
:
AppendScalar
(
info
.
fColorOffsets
[
i
-
1
]
result
)
;
result
-
>
writeText
(
"
sub
\
n
"
)
;
}
interpolateColorCode
(
info
.
fColorOffsets
[
i
]
-
info
.
fColorOffsets
[
i
-
1
]
colorData
[
i
]
colorData
[
i
-
1
]
result
)
;
result
-
>
writeText
(
"
}
\
n
"
)
;
}
result
-
>
writeText
(
"
{
pop
"
)
;
SkPDFUtils
:
:
AppendScalar
(
colorData
[
info
.
fColorCount
-
1
]
[
0
]
result
)
;
result
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendScalar
(
colorData
[
info
.
fColorCount
-
1
]
[
1
]
result
)
;
result
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendScalar
(
colorData
[
info
.
fColorCount
-
1
]
[
2
]
result
)
;
for
(
int
i
=
0
;
i
<
gradients
+
1
;
i
+
+
)
{
result
-
>
writeText
(
"
}
ifelse
\
n
"
)
;
}
}
static
void
tileModeCode
(
SkShader
:
:
TileMode
mode
SkDynamicMemoryWStream
*
result
)
{
if
(
mode
=
=
SkShader
:
:
kRepeat_TileMode
)
{
result
-
>
writeText
(
"
dup
truncate
sub
\
n
"
)
;
result
-
>
writeText
(
"
dup
0
le
{
1
add
}
if
\
n
"
)
;
return
;
}
if
(
mode
=
=
SkShader
:
:
kMirror_TileMode
)
{
result
-
>
writeText
(
"
abs
"
"
dup
"
"
truncate
"
"
dup
"
"
cvi
"
"
2
mod
"
"
1
eq
"
"
3
1
roll
"
"
sub
"
"
exch
"
"
{
1
exch
sub
}
if
\
n
"
)
;
}
}
static
void
apply_perspective_to_coordinates
(
const
SkMatrix
&
inversePerspectiveMatrix
SkDynamicMemoryWStream
*
code
)
{
if
(
!
inversePerspectiveMatrix
.
hasPerspective
(
)
)
{
return
;
}
const
SkScalar
p0
=
inversePerspectiveMatrix
[
SkMatrix
:
:
kMPersp0
]
;
const
SkScalar
p1
=
inversePerspectiveMatrix
[
SkMatrix
:
:
kMPersp1
]
;
const
SkScalar
p2
=
inversePerspectiveMatrix
[
SkMatrix
:
:
kMPersp2
]
;
code
-
>
writeText
(
"
dup
"
)
;
SkPDFUtils
:
:
AppendScalar
(
p1
code
)
;
code
-
>
writeText
(
"
mul
"
"
2
index
"
)
;
SkPDFUtils
:
:
AppendScalar
(
p0
code
)
;
code
-
>
writeText
(
"
mul
"
)
;
SkPDFUtils
:
:
AppendScalar
(
p2
code
)
;
code
-
>
writeText
(
"
add
"
"
add
"
"
3
1
roll
"
"
2
index
"
"
div
"
"
3
1
roll
"
"
exch
"
"
div
"
"
exch
\
n
"
)
;
}
static
void
linearCode
(
const
SkShader
:
:
GradientInfo
&
info
const
SkMatrix
&
perspectiveRemover
SkDynamicMemoryWStream
*
function
)
{
function
-
>
writeText
(
"
{
"
)
;
apply_perspective_to_coordinates
(
perspectiveRemover
function
)
;
function
-
>
writeText
(
"
pop
\
n
"
)
;
tileModeCode
(
info
.
fTileMode
function
)
;
gradientFunctionCode
(
info
function
)
;
function
-
>
writeText
(
"
}
"
)
;
}
static
void
radialCode
(
const
SkShader
:
:
GradientInfo
&
info
const
SkMatrix
&
perspectiveRemover
SkDynamicMemoryWStream
*
function
)
{
function
-
>
writeText
(
"
{
"
)
;
apply_perspective_to_coordinates
(
perspectiveRemover
function
)
;
function
-
>
writeText
(
"
dup
"
"
mul
"
"
exch
"
"
dup
"
"
mul
"
"
add
"
"
sqrt
\
n
"
)
;
tileModeCode
(
info
.
fTileMode
function
)
;
gradientFunctionCode
(
info
function
)
;
function
-
>
writeText
(
"
}
"
)
;
}
static
void
twoPointConicalCode
(
const
SkShader
:
:
GradientInfo
&
info
const
SkMatrix
&
perspectiveRemover
SkDynamicMemoryWStream
*
function
)
{
SkScalar
dx
=
info
.
fPoint
[
1
]
.
fX
-
info
.
fPoint
[
0
]
.
fX
;
SkScalar
dy
=
info
.
fPoint
[
1
]
.
fY
-
info
.
fPoint
[
0
]
.
fY
;
SkScalar
r0
=
info
.
fRadius
[
0
]
;
SkScalar
dr
=
info
.
fRadius
[
1
]
-
info
.
fRadius
[
0
]
;
SkScalar
a
=
SkScalarMul
(
dx
dx
)
+
SkScalarMul
(
dy
dy
)
-
SkScalarMul
(
dr
dr
)
;
function
-
>
writeText
(
"
{
"
)
;
apply_perspective_to_coordinates
(
perspectiveRemover
function
)
;
function
-
>
writeText
(
"
2
copy
"
)
;
SkPDFUtils
:
:
AppendScalar
(
dy
function
)
;
function
-
>
writeText
(
"
mul
exch
"
)
;
SkPDFUtils
:
:
AppendScalar
(
dx
function
)
;
function
-
>
writeText
(
"
mul
add
"
)
;
SkPDFUtils
:
:
AppendScalar
(
SkScalarMul
(
r0
dr
)
function
)
;
function
-
>
writeText
(
"
add
-
2
mul
dup
dup
mul
\
n
"
)
;
function
-
>
writeText
(
"
4
2
roll
dup
mul
exch
dup
mul
add
"
)
;
SkPDFUtils
:
:
AppendScalar
(
SkScalarMul
(
r0
r0
)
function
)
;
function
-
>
writeText
(
"
sub
dup
4
1
roll
\
n
"
)
;
if
(
a
=
=
0
)
{
function
-
>
writeText
(
"
pop
pop
div
neg
dup
"
)
;
SkPDFUtils
:
:
AppendScalar
(
dr
function
)
;
function
-
>
writeText
(
"
mul
"
)
;
SkPDFUtils
:
:
AppendScalar
(
r0
function
)
;
function
-
>
writeText
(
"
add
\
n
"
)
;
function
-
>
writeText
(
"
0
lt
{
pop
false
}
{
true
}
ifelse
\
n
"
)
;
}
else
{
SkPDFUtils
:
:
AppendScalar
(
SkScalarMul
(
SkIntToScalar
(
4
)
a
)
function
)
;
function
-
>
writeText
(
"
mul
sub
dup
\
n
"
)
;
function
-
>
writeText
(
"
0
ge
{
\
n
"
)
;
function
-
>
writeText
(
"
sqrt
exch
dup
0
lt
{
exch
-
1
mul
}
if
"
)
;
function
-
>
writeText
(
"
add
-
0
.
5
mul
dup
\
n
"
)
;
SkPDFUtils
:
:
AppendScalar
(
a
function
)
;
function
-
>
writeText
(
"
div
\
n
"
)
;
function
-
>
writeText
(
"
3
1
roll
div
\
n
"
)
;
function
-
>
writeText
(
"
2
copy
gt
{
exch
}
if
\
n
"
)
;
function
-
>
writeText
(
"
dup
"
)
;
SkPDFUtils
:
:
AppendScalar
(
dr
function
)
;
function
-
>
writeText
(
"
mul
"
)
;
SkPDFUtils
:
:
AppendScalar
(
r0
function
)
;
function
-
>
writeText
(
"
add
\
n
"
)
;
function
-
>
writeText
(
"
0
gt
{
exch
pop
true
}
\
n
"
)
;
function
-
>
writeText
(
"
{
pop
dup
\
n
"
)
;
SkPDFUtils
:
:
AppendScalar
(
dr
function
)
;
function
-
>
writeText
(
"
mul
"
)
;
SkPDFUtils
:
:
AppendScalar
(
r0
function
)
;
function
-
>
writeText
(
"
add
\
n
"
)
;
function
-
>
writeText
(
"
0
le
{
pop
false
}
{
true
}
ifelse
\
n
"
)
;
function
-
>
writeText
(
"
}
ifelse
\
n
"
)
;
function
-
>
writeText
(
"
}
{
pop
pop
pop
false
}
ifelse
\
n
"
)
;
}
function
-
>
writeText
(
"
{
"
)
;
tileModeCode
(
info
.
fTileMode
function
)
;
gradientFunctionCode
(
info
function
)
;
function
-
>
writeText
(
"
}
{
0
0
0
}
ifelse
}
"
)
;
}
static
void
sweepCode
(
const
SkShader
:
:
GradientInfo
&
info
const
SkMatrix
&
perspectiveRemover
SkDynamicMemoryWStream
*
function
)
{
function
-
>
writeText
(
"
{
exch
atan
360
div
\
n
"
)
;
tileModeCode
(
info
.
fTileMode
function
)
;
gradientFunctionCode
(
info
function
)
;
function
-
>
writeText
(
"
}
"
)
;
}
static
void
drawBitmapMatrix
(
SkCanvas
*
canvas
const
SkBitmap
&
bm
const
SkMatrix
&
matrix
)
{
SkAutoCanvasRestore
acr
(
canvas
true
)
;
canvas
-
>
concat
(
matrix
)
;
canvas
-
>
drawBitmap
(
bm
0
0
)
;
}
class
SkPDFShader
:
:
State
{
public
:
SkShader
:
:
GradientType
fType
;
SkShader
:
:
GradientInfo
fInfo
;
SkAutoFree
fColorData
;
SkMatrix
fCanvasTransform
;
SkMatrix
fShaderTransform
;
SkIRect
fBBox
;
SkBitmap
fImage
;
SkBitmapKey
fBitmapKey
;
SkShader
:
:
TileMode
fImageTileModes
[
2
]
;
State
(
SkShader
*
shader
const
SkMatrix
&
canvasTransform
const
SkIRect
&
bbox
SkScalar
rasterScale
)
;
bool
operator
=
=
(
const
State
&
b
)
const
;
SkPDFShader
:
:
State
*
CreateAlphaToLuminosityState
(
)
const
;
SkPDFShader
:
:
State
*
CreateOpaqueState
(
)
const
;
bool
GradientHasAlpha
(
)
const
;
private
:
State
(
const
State
&
other
)
;
State
operator
=
(
const
State
&
rhs
)
;
void
AllocateGradientInfoStorage
(
)
;
}
;
SkPDFFunctionShader
:
:
SkPDFFunctionShader
(
SkPDFShader
:
:
State
*
state
)
:
SkPDFDict
(
"
Pattern
"
)
fShaderState
(
state
)
{
state
-
>
fImage
.
reset
(
)
;
}
SkPDFFunctionShader
:
:
~
SkPDFFunctionShader
(
)
{
}
bool
SkPDFFunctionShader
:
:
equals
(
const
SkPDFShader
:
:
State
&
state
)
const
{
return
state
=
=
*
fShaderState
;
}
SkPDFAlphaFunctionShader
:
:
SkPDFAlphaFunctionShader
(
SkPDFShader
:
:
State
*
state
)
:
fShaderState
(
state
)
{
state
-
>
fImage
.
reset
(
)
;
}
bool
SkPDFAlphaFunctionShader
:
:
equals
(
const
SkPDFShader
:
:
State
&
state
)
const
{
return
state
=
=
*
fShaderState
;
}
SkPDFAlphaFunctionShader
:
:
~
SkPDFAlphaFunctionShader
(
)
{
}
SkPDFImageShader
:
:
SkPDFImageShader
(
SkPDFShader
:
:
State
*
state
)
:
fShaderState
(
state
)
{
state
-
>
fImage
.
reset
(
)
;
}
bool
SkPDFImageShader
:
:
equals
(
const
SkPDFShader
:
:
State
&
state
)
const
{
return
state
=
=
*
fShaderState
;
}
SkPDFImageShader
:
:
~
SkPDFImageShader
(
)
{
}
static
SkPDFObject
*
get_pdf_shader_by_state
(
SkPDFDocument
*
doc
SkScalar
dpi
std
:
:
unique_ptr
<
SkPDFShader
:
:
State
>
*
autoState
)
{
const
SkPDFShader
:
:
State
&
state
=
*
*
autoState
;
SkPDFCanon
*
canon
=
doc
-
>
canon
(
)
;
if
(
state
.
fType
=
=
SkShader
:
:
kNone_GradientType
&
&
state
.
fImage
.
isNull
(
)
)
{
return
nullptr
;
}
else
if
(
state
.
fType
=
=
SkShader
:
:
kNone_GradientType
)
{
SkPDFObject
*
shader
=
canon
-
>
findImageShader
(
state
)
;
return
shader
?
SkRef
(
shader
)
:
SkPDFImageShader
:
:
Create
(
doc
dpi
autoState
)
;
}
else
if
(
state
.
GradientHasAlpha
(
)
)
{
SkPDFObject
*
shader
=
canon
-
>
findAlphaShader
(
state
)
;
return
shader
?
SkRef
(
shader
)
:
SkPDFAlphaFunctionShader
:
:
Create
(
doc
dpi
autoState
)
;
}
else
{
SkPDFObject
*
shader
=
canon
-
>
findFunctionShader
(
state
)
;
return
shader
?
SkRef
(
shader
)
:
SkPDFFunctionShader
:
:
Create
(
canon
autoState
)
;
}
}
SkPDFObject
*
SkPDFShader
:
:
GetPDFShader
(
SkPDFDocument
*
doc
SkScalar
dpi
SkShader
*
shader
const
SkMatrix
&
matrix
const
SkIRect
&
surfaceBBox
SkScalar
rasterScale
)
{
std
:
:
unique_ptr
<
SkPDFShader
:
:
State
>
state
(
new
State
(
shader
matrix
surfaceBBox
rasterScale
)
)
;
return
get_pdf_shader_by_state
(
doc
dpi
&
state
)
;
}
static
sk_sp
<
SkPDFDict
>
get_gradient_resource_dict
(
SkPDFObject
*
functionShader
SkPDFObject
*
gState
)
{
SkTDArray
<
SkPDFObject
*
>
patterns
;
if
(
functionShader
)
{
patterns
.
push
(
functionShader
)
;
}
SkTDArray
<
SkPDFObject
*
>
graphicStates
;
if
(
gState
)
{
graphicStates
.
push
(
gState
)
;
}
return
SkPDFResourceDict
:
:
Make
(
&
graphicStates
&
patterns
nullptr
nullptr
)
;
}
static
void
populate_tiling_pattern_dict
(
SkPDFDict
*
pattern
SkRect
&
bbox
SkPDFDict
*
resources
const
SkMatrix
&
matrix
)
{
const
int
kTiling_PatternType
=
1
;
const
int
kColoredTilingPattern_PaintType
=
1
;
const
int
kConstantSpacing_TilingType
=
1
;
pattern
-
>
insertName
(
"
Type
"
"
Pattern
"
)
;
pattern
-
>
insertInt
(
"
PatternType
"
kTiling_PatternType
)
;
pattern
-
>
insertInt
(
"
PaintType
"
kColoredTilingPattern_PaintType
)
;
pattern
-
>
insertInt
(
"
TilingType
"
kConstantSpacing_TilingType
)
;
pattern
-
>
insertObject
(
"
BBox
"
SkPDFUtils
:
:
RectToArray
(
bbox
)
)
;
pattern
-
>
insertScalar
(
"
XStep
"
bbox
.
width
(
)
)
;
pattern
-
>
insertScalar
(
"
YStep
"
bbox
.
height
(
)
)
;
pattern
-
>
insertObject
(
"
Resources
"
sk_ref_sp
(
resources
)
)
;
if
(
!
matrix
.
isIdentity
(
)
)
{
pattern
-
>
insertObject
(
"
Matrix
"
SkPDFUtils
:
:
MatrixToArray
(
matrix
)
)
;
}
}
static
SkStream
*
create_pattern_fill_content
(
int
gsIndex
SkRect
&
bounds
)
{
SkDynamicMemoryWStream
content
;
if
(
gsIndex
>
=
0
)
{
SkPDFUtils
:
:
ApplyGraphicState
(
gsIndex
&
content
)
;
}
SkPDFUtils
:
:
ApplyPattern
(
0
&
content
)
;
SkPDFUtils
:
:
AppendRectangle
(
bounds
&
content
)
;
SkPDFUtils
:
:
PaintPath
(
SkPaint
:
:
kFill_Style
SkPath
:
:
kEvenOdd_FillType
&
content
)
;
return
content
.
detachAsStream
(
)
;
}
static
sk_sp
<
SkPDFObject
>
create_smask_graphic_state
(
SkPDFDocument
*
doc
SkScalar
dpi
const
SkPDFShader
:
:
State
&
state
)
{
SkRect
bbox
;
bbox
.
set
(
state
.
fBBox
)
;
std
:
:
unique_ptr
<
SkPDFShader
:
:
State
>
alphaToLuminosityState
(
state
.
CreateAlphaToLuminosityState
(
)
)
;
sk_sp
<
SkPDFObject
>
luminosityShader
(
get_pdf_shader_by_state
(
doc
dpi
&
alphaToLuminosityState
)
)
;
std
:
:
unique_ptr
<
SkStream
>
alphaStream
(
create_pattern_fill_content
(
-
1
bbox
)
)
;
auto
resources
=
get_gradient_resource_dict
(
luminosityShader
.
get
(
)
nullptr
)
;
sk_sp
<
SkPDFFormXObject
>
alphaMask
(
new
SkPDFFormXObject
(
alphaStream
.
get
(
)
bbox
resources
.
get
(
)
)
)
;
return
SkPDFGraphicState
:
:
GetSMaskGraphicState
(
alphaMask
.
get
(
)
false
SkPDFGraphicState
:
:
kLuminosity_SMaskMode
doc
-
>
canon
(
)
)
;
}
SkPDFAlphaFunctionShader
*
SkPDFAlphaFunctionShader
:
:
Create
(
SkPDFDocument
*
doc
SkScalar
dpi
std
:
:
unique_ptr
<
SkPDFShader
:
:
State
>
*
autoState
)
{
const
SkPDFShader
:
:
State
&
state
=
*
*
autoState
;
SkRect
bbox
;
bbox
.
set
(
state
.
fBBox
)
;
std
:
:
unique_ptr
<
SkPDFShader
:
:
State
>
opaqueState
(
state
.
CreateOpaqueState
(
)
)
;
sk_sp
<
SkPDFObject
>
colorShader
(
get_pdf_shader_by_state
(
doc
dpi
&
opaqueState
)
)
;
if
(
!
colorShader
)
{
return
nullptr
;
}
auto
alphaGs
=
create_smask_graphic_state
(
doc
dpi
state
)
;
SkPDFAlphaFunctionShader
*
alphaFunctionShader
=
new
SkPDFAlphaFunctionShader
(
autoState
-
>
release
(
)
)
;
auto
resourceDict
=
get_gradient_resource_dict
(
colorShader
.
get
(
)
alphaGs
.
get
(
)
)
;
std
:
:
unique_ptr
<
SkStream
>
colorStream
(
create_pattern_fill_content
(
0
bbox
)
)
;
alphaFunctionShader
-
>
setData
(
colorStream
.
get
(
)
)
;
populate_tiling_pattern_dict
(
alphaFunctionShader
bbox
resourceDict
.
get
(
)
SkMatrix
:
:
I
(
)
)
;
doc
-
>
canon
(
)
-
>
addAlphaShader
(
alphaFunctionShader
)
;
return
alphaFunctionShader
;
}
static
bool
split_perspective
(
const
SkMatrix
in
SkMatrix
*
affine
SkMatrix
*
perspectiveInverse
)
{
const
SkScalar
p2
=
in
[
SkMatrix
:
:
kMPersp2
]
;
if
(
SkScalarNearlyZero
(
p2
)
)
{
return
false
;
}
const
SkScalar
zero
=
SkIntToScalar
(
0
)
;
const
SkScalar
one
=
SkIntToScalar
(
1
)
;
const
SkScalar
sx
=
in
[
SkMatrix
:
:
kMScaleX
]
;
const
SkScalar
kx
=
in
[
SkMatrix
:
:
kMSkewX
]
;
const
SkScalar
tx
=
in
[
SkMatrix
:
:
kMTransX
]
;
const
SkScalar
ky
=
in
[
SkMatrix
:
:
kMSkewY
]
;
const
SkScalar
sy
=
in
[
SkMatrix
:
:
kMScaleY
]
;
const
SkScalar
ty
=
in
[
SkMatrix
:
:
kMTransY
]
;
const
SkScalar
p0
=
in
[
SkMatrix
:
:
kMPersp0
]
;
const
SkScalar
p1
=
in
[
SkMatrix
:
:
kMPersp1
]
;
perspectiveInverse
-
>
setAll
(
one
zero
zero
zero
one
zero
-
p0
/
p2
-
p1
/
p2
1
/
p2
)
;
affine
-
>
setAll
(
sx
-
p0
*
tx
/
p2
kx
-
p1
*
tx
/
p2
tx
/
p2
ky
-
p0
*
ty
/
p2
sy
-
p1
*
ty
/
p2
ty
/
p2
zero
zero
one
)
;
return
true
;
}
sk_sp
<
SkPDFArray
>
SkPDFShader
:
:
MakeRangeObject
(
)
{
auto
range
=
sk_make_sp
<
SkPDFArray
>
(
)
;
range
-
>
reserve
(
6
)
;
range
-
>
appendInt
(
0
)
;
range
-
>
appendInt
(
1
)
;
range
-
>
appendInt
(
0
)
;
range
-
>
appendInt
(
1
)
;
range
-
>
appendInt
(
0
)
;
range
-
>
appendInt
(
1
)
;
return
range
;
}
static
sk_sp
<
SkPDFStream
>
make_ps_function
(
std
:
:
unique_ptr
<
SkStreamAsset
>
psCode
SkPDFArray
*
domain
sk_sp
<
SkPDFObject
>
range
)
{
auto
result
=
sk_make_sp
<
SkPDFStream
>
(
psCode
.
get
(
)
)
;
result
-
>
insertInt
(
"
FunctionType
"
4
)
;
result
-
>
insertObject
(
"
Domain
"
sk_ref_sp
(
domain
)
)
;
result
-
>
insertObject
(
"
Range
"
std
:
:
move
(
range
)
)
;
return
result
;
}
SkPDFFunctionShader
*
SkPDFFunctionShader
:
:
Create
(
SkPDFCanon
*
canon
std
:
:
unique_ptr
<
SkPDFShader
:
:
State
>
*
autoState
)
{
const
SkPDFShader
:
:
State
&
state
=
*
*
autoState
;
void
(
*
codeFunction
)
(
const
SkShader
:
:
GradientInfo
&
info
const
SkMatrix
&
perspectiveRemover
SkDynamicMemoryWStream
*
function
)
=
nullptr
;
SkPoint
transformPoints
[
2
]
;
const
SkShader
:
:
GradientInfo
*
info
=
&
state
.
fInfo
;
transformPoints
[
0
]
=
info
-
>
fPoint
[
0
]
;
transformPoints
[
1
]
=
info
-
>
fPoint
[
1
]
;
switch
(
state
.
fType
)
{
case
SkShader
:
:
kLinear_GradientType
:
codeFunction
=
&
linearCode
;
break
;
case
SkShader
:
:
kRadial_GradientType
:
transformPoints
[
1
]
=
transformPoints
[
0
]
;
transformPoints
[
1
]
.
fX
+
=
info
-
>
fRadius
[
0
]
;
codeFunction
=
&
radialCode
;
break
;
case
SkShader
:
:
kConical_GradientType
:
{
transformPoints
[
1
]
=
transformPoints
[
0
]
;
transformPoints
[
1
]
.
fX
+
=
SK_Scalar1
;
codeFunction
=
&
twoPointConicalCode
;
break
;
}
case
SkShader
:
:
kSweep_GradientType
:
transformPoints
[
1
]
=
transformPoints
[
0
]
;
transformPoints
[
1
]
.
fX
+
=
SK_Scalar1
;
codeFunction
=
&
sweepCode
;
break
;
case
SkShader
:
:
kColor_GradientType
:
case
SkShader
:
:
kNone_GradientType
:
default
:
return
nullptr
;
}
SkMatrix
mapperMatrix
;
unitToPointsMatrix
(
transformPoints
&
mapperMatrix
)
;
SkMatrix
finalMatrix
=
state
.
fCanvasTransform
;
finalMatrix
.
preConcat
(
state
.
fShaderTransform
)
;
finalMatrix
.
preConcat
(
mapperMatrix
)
;
SkMatrix
perspectiveInverseOnly
=
SkMatrix
:
:
I
(
)
;
if
(
finalMatrix
.
hasPerspective
(
)
)
{
if
(
!
split_perspective
(
finalMatrix
&
finalMatrix
&
perspectiveInverseOnly
)
)
{
return
nullptr
;
}
}
SkRect
bbox
;
bbox
.
set
(
state
.
fBBox
)
;
if
(
!
inverse_transform_bbox
(
finalMatrix
&
bbox
)
)
{
return
nullptr
;
}
auto
domain
=
sk_make_sp
<
SkPDFArray
>
(
)
;
domain
-
>
reserve
(
4
)
;
domain
-
>
appendScalar
(
bbox
.
fLeft
)
;
domain
-
>
appendScalar
(
bbox
.
fRight
)
;
domain
-
>
appendScalar
(
bbox
.
fTop
)
;
domain
-
>
appendScalar
(
bbox
.
fBottom
)
;
SkDynamicMemoryWStream
functionCode
;
if
(
state
.
fType
=
=
SkShader
:
:
kConical_GradientType
)
{
SkShader
:
:
GradientInfo
twoPointRadialInfo
=
*
info
;
SkMatrix
inverseMapperMatrix
;
if
(
!
mapperMatrix
.
invert
(
&
inverseMapperMatrix
)
)
{
return
nullptr
;
}
inverseMapperMatrix
.
mapPoints
(
twoPointRadialInfo
.
fPoint
2
)
;
twoPointRadialInfo
.
fRadius
[
0
]
=
inverseMapperMatrix
.
mapRadius
(
info
-
>
fRadius
[
0
]
)
;
twoPointRadialInfo
.
fRadius
[
1
]
=
inverseMapperMatrix
.
mapRadius
(
info
-
>
fRadius
[
1
]
)
;
codeFunction
(
twoPointRadialInfo
perspectiveInverseOnly
&
functionCode
)
;
}
else
{
codeFunction
(
*
info
perspectiveInverseOnly
&
functionCode
)
;
}
auto
pdfShader
=
sk_make_sp
<
SkPDFDict
>
(
)
;
pdfShader
-
>
insertInt
(
"
ShadingType
"
1
)
;
pdfShader
-
>
insertName
(
"
ColorSpace
"
"
DeviceRGB
"
)
;
pdfShader
-
>
insertObject
(
"
Domain
"
sk_ref_sp
(
domain
.
get
(
)
)
)
;
std
:
:
unique_ptr
<
SkStreamAsset
>
functionStream
(
functionCode
.
detachAsStream
(
)
)
;
auto
function
=
make_ps_function
(
std
:
:
move
(
functionStream
)
domain
.
get
(
)
canon
-
>
makeRangeObject
(
)
)
;
pdfShader
-
>
insertObjRef
(
"
Function
"
std
:
:
move
(
function
)
)
;
sk_sp
<
SkPDFFunctionShader
>
pdfFunctionShader
(
new
SkPDFFunctionShader
(
autoState
-
>
release
(
)
)
)
;
pdfFunctionShader
-
>
insertInt
(
"
PatternType
"
2
)
;
pdfFunctionShader
-
>
insertObject
(
"
Matrix
"
SkPDFUtils
:
:
MatrixToArray
(
finalMatrix
)
)
;
pdfFunctionShader
-
>
insertObject
(
"
Shading
"
std
:
:
move
(
pdfShader
)
)
;
canon
-
>
addFunctionShader
(
pdfFunctionShader
.
get
(
)
)
;
return
pdfFunctionShader
.
release
(
)
;
}
SkPDFImageShader
*
SkPDFImageShader
:
:
Create
(
SkPDFDocument
*
doc
SkScalar
dpi
std
:
:
unique_ptr
<
SkPDFShader
:
:
State
>
*
autoState
)
{
const
SkPDFShader
:
:
State
&
state
=
*
*
autoState
;
state
.
fImage
.
lockPixels
(
)
;
SkMatrix
finalMatrix
=
state
.
fCanvasTransform
;
finalMatrix
.
preConcat
(
state
.
fShaderTransform
)
;
SkRect
deviceBounds
;
deviceBounds
.
set
(
state
.
fBBox
)
;
if
(
!
inverse_transform_bbox
(
finalMatrix
&
deviceBounds
)
)
{
return
nullptr
;
}
const
SkBitmap
*
image
=
&
state
.
fImage
;
SkRect
bitmapBounds
;
image
-
>
getBounds
(
&
bitmapBounds
)
;
SkShader
:
:
TileMode
tileModes
[
2
]
;
tileModes
[
0
]
=
state
.
fImageTileModes
[
0
]
;
tileModes
[
1
]
=
state
.
fImageTileModes
[
1
]
;
if
(
tileModes
[
0
]
!
=
SkShader
:
:
kClamp_TileMode
|
|
tileModes
[
1
]
!
=
SkShader
:
:
kClamp_TileMode
)
{
deviceBounds
.
join
(
bitmapBounds
)
;
}
SkISize
size
=
SkISize
:
:
Make
(
SkScalarRoundToInt
(
deviceBounds
.
width
(
)
)
SkScalarRoundToInt
(
deviceBounds
.
height
(
)
)
)
;
sk_sp
<
SkPDFDevice
>
patternDevice
(
SkPDFDevice
:
:
CreateUnflipped
(
size
dpi
doc
)
)
;
SkCanvas
canvas
(
patternDevice
.
get
(
)
)
;
SkRect
patternBBox
;
image
-
>
getBounds
(
&
patternBBox
)
;
canvas
.
translate
(
-
deviceBounds
.
left
(
)
-
deviceBounds
.
top
(
)
)
;
patternBBox
.
offset
(
-
deviceBounds
.
left
(
)
-
deviceBounds
.
top
(
)
)
;
finalMatrix
.
preTranslate
(
deviceBounds
.
left
(
)
deviceBounds
.
top
(
)
)
;
canvas
.
drawBitmap
(
*
image
0
0
)
;
SkScalar
width
=
SkIntToScalar
(
image
-
>
width
(
)
)
;
SkScalar
height
=
SkIntToScalar
(
image
-
>
height
(
)
)
;
if
(
tileModes
[
0
]
=
=
SkShader
:
:
kMirror_TileMode
)
{
SkMatrix
xMirror
;
xMirror
.
setScale
(
-
1
1
)
;
xMirror
.
postTranslate
(
2
*
width
0
)
;
drawBitmapMatrix
(
&
canvas
*
image
xMirror
)
;
patternBBox
.
fRight
+
=
width
;
}
if
(
tileModes
[
1
]
=
=
SkShader
:
:
kMirror_TileMode
)
{
SkMatrix
yMirror
;
yMirror
.
setScale
(
SK_Scalar1
-
SK_Scalar1
)
;
yMirror
.
postTranslate
(
0
2
*
height
)
;
drawBitmapMatrix
(
&
canvas
*
image
yMirror
)
;
patternBBox
.
fBottom
+
=
height
;
}
if
(
tileModes
[
0
]
=
=
SkShader
:
:
kMirror_TileMode
&
&
tileModes
[
1
]
=
=
SkShader
:
:
kMirror_TileMode
)
{
SkMatrix
mirror
;
mirror
.
setScale
(
-
1
-
1
)
;
mirror
.
postTranslate
(
2
*
width
2
*
height
)
;
drawBitmapMatrix
(
&
canvas
*
image
mirror
)
;
}
if
(
tileModes
[
0
]
=
=
SkShader
:
:
kClamp_TileMode
&
&
tileModes
[
1
]
=
=
SkShader
:
:
kClamp_TileMode
)
{
SkPaint
paint
;
SkRect
rect
;
rect
=
SkRect
:
:
MakeLTRB
(
deviceBounds
.
left
(
)
deviceBounds
.
top
(
)
0
0
)
;
if
(
!
rect
.
isEmpty
(
)
)
{
paint
.
setColor
(
image
-
>
getColor
(
0
0
)
)
;
canvas
.
drawRect
(
rect
paint
)
;
}
rect
=
SkRect
:
:
MakeLTRB
(
width
deviceBounds
.
top
(
)
deviceBounds
.
right
(
)
0
)
;
if
(
!
rect
.
isEmpty
(
)
)
{
paint
.
setColor
(
image
-
>
getColor
(
image
-
>
width
(
)
-
1
0
)
)
;
canvas
.
drawRect
(
rect
paint
)
;
}
rect
=
SkRect
:
:
MakeLTRB
(
width
height
deviceBounds
.
right
(
)
deviceBounds
.
bottom
(
)
)
;
if
(
!
rect
.
isEmpty
(
)
)
{
paint
.
setColor
(
image
-
>
getColor
(
image
-
>
width
(
)
-
1
image
-
>
height
(
)
-
1
)
)
;
canvas
.
drawRect
(
rect
paint
)
;
}
rect
=
SkRect
:
:
MakeLTRB
(
deviceBounds
.
left
(
)
height
0
deviceBounds
.
bottom
(
)
)
;
if
(
!
rect
.
isEmpty
(
)
)
{
paint
.
setColor
(
image
-
>
getColor
(
0
image
-
>
height
(
)
-
1
)
)
;
canvas
.
drawRect
(
rect
paint
)
;
}
}
if
(
tileModes
[
0
]
=
=
SkShader
:
:
kClamp_TileMode
)
{
SkIRect
subset
=
SkIRect
:
:
MakeXYWH
(
0
0
1
image
-
>
height
(
)
)
;
if
(
deviceBounds
.
left
(
)
<
0
)
{
SkBitmap
left
;
SkAssertResult
(
image
-
>
extractSubset
(
&
left
subset
)
)
;
SkMatrix
leftMatrix
;
leftMatrix
.
setScale
(
-
deviceBounds
.
left
(
)
1
)
;
leftMatrix
.
postTranslate
(
deviceBounds
.
left
(
)
0
)
;
drawBitmapMatrix
(
&
canvas
left
leftMatrix
)
;
if
(
tileModes
[
1
]
=
=
SkShader
:
:
kMirror_TileMode
)
{
leftMatrix
.
postScale
(
SK_Scalar1
-
SK_Scalar1
)
;
leftMatrix
.
postTranslate
(
0
2
*
height
)
;
drawBitmapMatrix
(
&
canvas
left
leftMatrix
)
;
}
patternBBox
.
fLeft
=
0
;
}
if
(
deviceBounds
.
right
(
)
>
width
)
{
SkBitmap
right
;
subset
.
offset
(
image
-
>
width
(
)
-
1
0
)
;
SkAssertResult
(
image
-
>
extractSubset
(
&
right
subset
)
)
;
SkMatrix
rightMatrix
;
rightMatrix
.
setScale
(
deviceBounds
.
right
(
)
-
width
1
)
;
rightMatrix
.
postTranslate
(
width
0
)
;
drawBitmapMatrix
(
&
canvas
right
rightMatrix
)
;
if
(
tileModes
[
1
]
=
=
SkShader
:
:
kMirror_TileMode
)
{
rightMatrix
.
postScale
(
SK_Scalar1
-
SK_Scalar1
)
;
rightMatrix
.
postTranslate
(
0
2
*
height
)
;
drawBitmapMatrix
(
&
canvas
right
rightMatrix
)
;
}
patternBBox
.
fRight
=
deviceBounds
.
width
(
)
;
}
}
if
(
tileModes
[
1
]
=
=
SkShader
:
:
kClamp_TileMode
)
{
SkIRect
subset
=
SkIRect
:
:
MakeXYWH
(
0
0
image
-
>
width
(
)
1
)
;
if
(
deviceBounds
.
top
(
)
<
0
)
{
SkBitmap
top
;
SkAssertResult
(
image
-
>
extractSubset
(
&
top
subset
)
)
;
SkMatrix
topMatrix
;
topMatrix
.
setScale
(
SK_Scalar1
-
deviceBounds
.
top
(
)
)
;
topMatrix
.
postTranslate
(
0
deviceBounds
.
top
(
)
)
;
drawBitmapMatrix
(
&
canvas
top
topMatrix
)
;
if
(
tileModes
[
0
]
=
=
SkShader
:
:
kMirror_TileMode
)
{
topMatrix
.
postScale
(
-
1
1
)
;
topMatrix
.
postTranslate
(
2
*
width
0
)
;
drawBitmapMatrix
(
&
canvas
top
topMatrix
)
;
}
patternBBox
.
fTop
=
0
;
}
if
(
deviceBounds
.
bottom
(
)
>
height
)
{
SkBitmap
bottom
;
subset
.
offset
(
0
image
-
>
height
(
)
-
1
)
;
SkAssertResult
(
image
-
>
extractSubset
(
&
bottom
subset
)
)
;
SkMatrix
bottomMatrix
;
bottomMatrix
.
setScale
(
SK_Scalar1
deviceBounds
.
bottom
(
)
-
height
)
;
bottomMatrix
.
postTranslate
(
0
height
)
;
drawBitmapMatrix
(
&
canvas
bottom
bottomMatrix
)
;
if
(
tileModes
[
0
]
=
=
SkShader
:
:
kMirror_TileMode
)
{
bottomMatrix
.
postScale
(
-
1
1
)
;
bottomMatrix
.
postTranslate
(
2
*
width
0
)
;
drawBitmapMatrix
(
&
canvas
bottom
bottomMatrix
)
;
}
patternBBox
.
fBottom
=
deviceBounds
.
height
(
)
;
}
}
auto
content
=
patternDevice
-
>
content
(
)
;
SkPDFImageShader
*
imageShader
=
new
SkPDFImageShader
(
autoState
-
>
release
(
)
)
;
imageShader
-
>
setData
(
content
.
get
(
)
)
;
auto
resourceDict
=
patternDevice
-
>
makeResourceDict
(
)
;
populate_tiling_pattern_dict
(
imageShader
patternBBox
resourceDict
.
get
(
)
finalMatrix
)
;
imageShader
-
>
fShaderState
-
>
fImage
.
unlockPixels
(
)
;
doc
-
>
canon
(
)
-
>
addImageShader
(
imageShader
)
;
return
imageShader
;
}
bool
SkPDFShader
:
:
State
:
:
operator
=
=
(
const
SkPDFShader
:
:
State
&
b
)
const
{
if
(
fType
!
=
b
.
fType
|
|
fCanvasTransform
!
=
b
.
fCanvasTransform
|
|
fShaderTransform
!
=
b
.
fShaderTransform
|
|
fBBox
!
=
b
.
fBBox
)
{
return
false
;
}
if
(
fType
=
=
SkShader
:
:
kNone_GradientType
)
{
if
(
fBitmapKey
!
=
b
.
fBitmapKey
|
|
fBitmapKey
.
id
(
)
=
=
0
|
|
fImageTileModes
[
0
]
!
=
b
.
fImageTileModes
[
0
]
|
|
fImageTileModes
[
1
]
!
=
b
.
fImageTileModes
[
1
]
)
{
return
false
;
}
}
else
{
if
(
fInfo
.
fColorCount
!
=
b
.
fInfo
.
fColorCount
|
|
memcmp
(
fInfo
.
fColors
b
.
fInfo
.
fColors
sizeof
(
SkColor
)
*
fInfo
.
fColorCount
)
!
=
0
|
|
memcmp
(
fInfo
.
fColorOffsets
b
.
fInfo
.
fColorOffsets
sizeof
(
SkScalar
)
*
fInfo
.
fColorCount
)
!
=
0
|
|
fInfo
.
fPoint
[
0
]
!
=
b
.
fInfo
.
fPoint
[
0
]
|
|
fInfo
.
fTileMode
!
=
b
.
fInfo
.
fTileMode
)
{
return
false
;
}
switch
(
fType
)
{
case
SkShader
:
:
kLinear_GradientType
:
if
(
fInfo
.
fPoint
[
1
]
!
=
b
.
fInfo
.
fPoint
[
1
]
)
{
return
false
;
}
break
;
case
SkShader
:
:
kRadial_GradientType
:
if
(
fInfo
.
fRadius
[
0
]
!
=
b
.
fInfo
.
fRadius
[
0
]
)
{
return
false
;
}
break
;
case
SkShader
:
:
kConical_GradientType
:
if
(
fInfo
.
fPoint
[
1
]
!
=
b
.
fInfo
.
fPoint
[
1
]
|
|
fInfo
.
fRadius
[
0
]
!
=
b
.
fInfo
.
fRadius
[
0
]
|
|
fInfo
.
fRadius
[
1
]
!
=
b
.
fInfo
.
fRadius
[
1
]
)
{
return
false
;
}
break
;
case
SkShader
:
:
kSweep_GradientType
:
case
SkShader
:
:
kNone_GradientType
:
case
SkShader
:
:
kColor_GradientType
:
break
;
}
}
return
true
;
}
SkPDFShader
:
:
State
:
:
State
(
SkShader
*
shader
const
SkMatrix
&
canvasTransform
const
SkIRect
&
bbox
SkScalar
rasterScale
)
:
fCanvasTransform
(
canvasTransform
)
fBBox
(
bbox
)
{
fInfo
.
fColorCount
=
0
;
fInfo
.
fColors
=
nullptr
;
fInfo
.
fColorOffsets
=
nullptr
;
fShaderTransform
=
shader
-
>
getLocalMatrix
(
)
;
fImageTileModes
[
0
]
=
fImageTileModes
[
1
]
=
SkShader
:
:
kClamp_TileMode
;
fType
=
shader
-
>
asAGradient
(
&
fInfo
)
;
if
(
fType
=
=
SkShader
:
:
kNone_GradientType
)
{
SkMatrix
matrix
;
if
(
shader
-
>
isABitmap
(
&
fImage
&
matrix
fImageTileModes
)
)
{
SkASSERT
(
matrix
.
isIdentity
(
)
)
;
}
else
{
SkRect
shaderRect
=
SkRect
:
:
Make
(
bbox
)
;
if
(
!
inverse_transform_bbox
(
canvasTransform
&
shaderRect
)
)
{
fImage
.
reset
(
)
;
return
;
}
static
const
SkScalar
kMaxBitmapArea
=
1024
*
1024
;
SkScalar
bitmapArea
=
rasterScale
*
bbox
.
width
(
)
*
rasterScale
*
bbox
.
height
(
)
;
if
(
bitmapArea
>
kMaxBitmapArea
)
{
rasterScale
*
=
SkScalarSqrt
(
kMaxBitmapArea
/
bitmapArea
)
;
}
SkISize
size
=
SkISize
:
:
Make
(
SkScalarRoundToInt
(
rasterScale
*
bbox
.
width
(
)
)
SkScalarRoundToInt
(
rasterScale
*
bbox
.
height
(
)
)
)
;
SkSize
scale
=
SkSize
:
:
Make
(
SkIntToScalar
(
size
.
width
(
)
)
/
shaderRect
.
width
(
)
SkIntToScalar
(
size
.
height
(
)
)
/
shaderRect
.
height
(
)
)
;
fImage
.
allocN32Pixels
(
size
.
width
(
)
size
.
height
(
)
)
;
fImage
.
eraseColor
(
SK_ColorTRANSPARENT
)
;
SkPaint
p
;
p
.
setShader
(
sk_ref_sp
(
shader
)
)
;
SkCanvas
canvas
(
fImage
)
;
canvas
.
scale
(
scale
.
width
(
)
scale
.
height
(
)
)
;
canvas
.
translate
(
-
shaderRect
.
x
(
)
-
shaderRect
.
y
(
)
)
;
canvas
.
drawPaint
(
p
)
;
fShaderTransform
.
setTranslate
(
shaderRect
.
x
(
)
shaderRect
.
y
(
)
)
;
fShaderTransform
.
preScale
(
1
/
scale
.
width
(
)
1
/
scale
.
height
(
)
)
;
}
fBitmapKey
=
SkBitmapKey
(
fImage
)
;
}
else
{
AllocateGradientInfoStorage
(
)
;
shader
-
>
asAGradient
(
&
fInfo
)
;
}
}
SkPDFShader
:
:
State
:
:
State
(
const
SkPDFShader
:
:
State
&
other
)
:
fType
(
other
.
fType
)
fCanvasTransform
(
other
.
fCanvasTransform
)
fShaderTransform
(
other
.
fShaderTransform
)
fBBox
(
other
.
fBBox
)
{
SkASSERT
(
fType
!
=
SkShader
:
:
kNone_GradientType
)
;
if
(
fType
!
=
SkShader
:
:
kNone_GradientType
)
{
fInfo
=
other
.
fInfo
;
AllocateGradientInfoStorage
(
)
;
for
(
int
i
=
0
;
i
<
fInfo
.
fColorCount
;
i
+
+
)
{
fInfo
.
fColors
[
i
]
=
other
.
fInfo
.
fColors
[
i
]
;
fInfo
.
fColorOffsets
[
i
]
=
other
.
fInfo
.
fColorOffsets
[
i
]
;
}
}
}
SkPDFShader
:
:
State
*
SkPDFShader
:
:
State
:
:
CreateAlphaToLuminosityState
(
)
const
{
SkASSERT
(
fType
!
=
SkShader
:
:
kNone_GradientType
)
;
SkPDFShader
:
:
State
*
newState
=
new
SkPDFShader
:
:
State
(
*
this
)
;
for
(
int
i
=
0
;
i
<
fInfo
.
fColorCount
;
i
+
+
)
{
SkAlpha
alpha
=
SkColorGetA
(
fInfo
.
fColors
[
i
]
)
;
newState
-
>
fInfo
.
fColors
[
i
]
=
SkColorSetARGB
(
255
alpha
alpha
alpha
)
;
}
return
newState
;
}
SkPDFShader
:
:
State
*
SkPDFShader
:
:
State
:
:
CreateOpaqueState
(
)
const
{
SkASSERT
(
fType
!
=
SkShader
:
:
kNone_GradientType
)
;
SkPDFShader
:
:
State
*
newState
=
new
SkPDFShader
:
:
State
(
*
this
)
;
for
(
int
i
=
0
;
i
<
fInfo
.
fColorCount
;
i
+
+
)
{
newState
-
>
fInfo
.
fColors
[
i
]
=
SkColorSetA
(
fInfo
.
fColors
[
i
]
SK_AlphaOPAQUE
)
;
}
return
newState
;
}
bool
SkPDFShader
:
:
State
:
:
GradientHasAlpha
(
)
const
{
if
(
fType
=
=
SkShader
:
:
kNone_GradientType
)
{
return
false
;
}
for
(
int
i
=
0
;
i
<
fInfo
.
fColorCount
;
i
+
+
)
{
SkAlpha
alpha
=
SkColorGetA
(
fInfo
.
fColors
[
i
]
)
;
if
(
alpha
!
=
SK_AlphaOPAQUE
)
{
return
true
;
}
}
return
false
;
}
void
SkPDFShader
:
:
State
:
:
AllocateGradientInfoStorage
(
)
{
fColorData
.
set
(
sk_malloc_throw
(
fInfo
.
fColorCount
*
(
sizeof
(
SkColor
)
+
sizeof
(
SkScalar
)
)
)
)
;
fInfo
.
fColors
=
reinterpret_cast
<
SkColor
*
>
(
fColorData
.
get
(
)
)
;
fInfo
.
fColorOffsets
=
reinterpret_cast
<
SkScalar
*
>
(
fInfo
.
fColors
+
fInfo
.
fColorCount
)
;
}
