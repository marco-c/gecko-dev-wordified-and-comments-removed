#
include
"
SkPDFShader
.
h
"
#
include
"
SkData
.
h
"
#
include
"
SkPDFCanon
.
h
"
#
include
"
SkPDFDevice
.
h
"
#
include
"
SkPDFDocument
.
h
"
#
include
"
SkPDFFormXObject
.
h
"
#
include
"
SkPDFGraphicState
.
h
"
#
include
"
SkPDFResourceDict
.
h
"
#
include
"
SkPDFUtils
.
h
"
#
include
"
SkScalar
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkTemplates
.
h
"
static
bool
inverse_transform_bbox
(
const
SkMatrix
&
matrix
SkRect
*
bbox
)
{
SkMatrix
inverse
;
if
(
!
matrix
.
invert
(
&
inverse
)
)
{
return
false
;
}
inverse
.
mapRect
(
bbox
)
;
return
true
;
}
static
void
unitToPointsMatrix
(
const
SkPoint
pts
[
2
]
SkMatrix
*
matrix
)
{
SkVector
vec
=
pts
[
1
]
-
pts
[
0
]
;
SkScalar
mag
=
vec
.
length
(
)
;
SkScalar
inv
=
mag
?
SkScalarInvert
(
mag
)
:
0
;
vec
.
scale
(
inv
)
;
matrix
-
>
setSinCos
(
vec
.
fY
vec
.
fX
)
;
matrix
-
>
preScale
(
mag
mag
)
;
matrix
-
>
postTranslate
(
pts
[
0
]
.
fX
pts
[
0
]
.
fY
)
;
}
static
const
int
kColorComponents
=
3
;
typedef
uint8_t
ColorTuple
[
kColorComponents
]
;
static
void
interpolateColorCode
(
SkScalar
range
const
ColorTuple
&
curColor
const
ColorTuple
&
prevColor
SkDynamicMemoryWStream
*
result
)
{
SkASSERT
(
range
!
=
SkIntToScalar
(
0
)
)
;
SkScalar
multiplier
[
kColorComponents
]
;
for
(
int
i
=
0
;
i
<
kColorComponents
;
i
+
+
)
{
static
const
SkScalar
kColorScale
=
SkScalarInvert
(
255
)
;
multiplier
[
i
]
=
kColorScale
*
(
curColor
[
i
]
-
prevColor
[
i
]
)
/
range
;
}
bool
dupInput
[
kColorComponents
]
;
dupInput
[
kColorComponents
-
1
]
=
false
;
for
(
int
i
=
kColorComponents
-
2
;
i
>
=
0
;
i
-
-
)
{
dupInput
[
i
]
=
dupInput
[
i
+
1
]
|
|
multiplier
[
i
+
1
]
!
=
0
;
}
if
(
!
dupInput
[
0
]
&
&
multiplier
[
0
]
=
=
0
)
{
result
-
>
writeText
(
"
pop
"
)
;
}
for
(
int
i
=
0
;
i
<
kColorComponents
;
i
+
+
)
{
if
(
dupInput
[
i
]
&
&
multiplier
[
i
]
!
=
0
)
{
result
-
>
writeText
(
"
dup
"
)
;
}
if
(
multiplier
[
i
]
=
=
0
)
{
SkPDFUtils
:
:
AppendColorComponent
(
prevColor
[
i
]
result
)
;
result
-
>
writeText
(
"
"
)
;
}
else
{
if
(
multiplier
[
i
]
!
=
1
)
{
SkPDFUtils
:
:
AppendScalar
(
multiplier
[
i
]
result
)
;
result
-
>
writeText
(
"
mul
"
)
;
}
if
(
prevColor
[
i
]
!
=
0
)
{
SkPDFUtils
:
:
AppendColorComponent
(
prevColor
[
i
]
result
)
;
result
-
>
writeText
(
"
add
"
)
;
}
}
if
(
dupInput
[
i
]
)
{
result
-
>
writeText
(
"
exch
\
n
"
)
;
}
}
}
static
void
gradientFunctionCode
(
const
SkShader
:
:
GradientInfo
&
info
SkDynamicMemoryWStream
*
result
)
{
SkAutoSTMalloc
<
4
ColorTuple
>
colorDataAlloc
(
info
.
fColorCount
)
;
ColorTuple
*
colorData
=
colorDataAlloc
.
get
(
)
;
for
(
int
i
=
0
;
i
<
info
.
fColorCount
;
i
+
+
)
{
colorData
[
i
]
[
0
]
=
SkColorGetR
(
info
.
fColors
[
i
]
)
;
colorData
[
i
]
[
1
]
=
SkColorGetG
(
info
.
fColors
[
i
]
)
;
colorData
[
i
]
[
2
]
=
SkColorGetB
(
info
.
fColors
[
i
]
)
;
}
result
-
>
writeText
(
"
dup
0
le
{
pop
"
)
;
SkPDFUtils
:
:
AppendColorComponent
(
colorData
[
0
]
[
0
]
result
)
;
result
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendColorComponent
(
colorData
[
0
]
[
1
]
result
)
;
result
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendColorComponent
(
colorData
[
0
]
[
2
]
result
)
;
result
-
>
writeText
(
"
}
\
n
"
)
;
int
gradients
=
0
;
for
(
int
i
=
1
;
i
<
info
.
fColorCount
;
i
+
+
)
{
if
(
info
.
fColorOffsets
[
i
]
=
=
info
.
fColorOffsets
[
i
-
1
]
)
{
continue
;
}
gradients
+
+
;
result
-
>
writeText
(
"
{
dup
"
)
;
SkPDFUtils
:
:
AppendScalar
(
info
.
fColorOffsets
[
i
]
result
)
;
result
-
>
writeText
(
"
le
{
"
)
;
if
(
info
.
fColorOffsets
[
i
-
1
]
!
=
0
)
{
SkPDFUtils
:
:
AppendScalar
(
info
.
fColorOffsets
[
i
-
1
]
result
)
;
result
-
>
writeText
(
"
sub
\
n
"
)
;
}
interpolateColorCode
(
info
.
fColorOffsets
[
i
]
-
info
.
fColorOffsets
[
i
-
1
]
colorData
[
i
]
colorData
[
i
-
1
]
result
)
;
result
-
>
writeText
(
"
}
\
n
"
)
;
}
result
-
>
writeText
(
"
{
pop
"
)
;
SkPDFUtils
:
:
AppendColorComponent
(
colorData
[
info
.
fColorCount
-
1
]
[
0
]
result
)
;
result
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendColorComponent
(
colorData
[
info
.
fColorCount
-
1
]
[
1
]
result
)
;
result
-
>
writeText
(
"
"
)
;
SkPDFUtils
:
:
AppendColorComponent
(
colorData
[
info
.
fColorCount
-
1
]
[
2
]
result
)
;
for
(
int
i
=
0
;
i
<
gradients
+
1
;
i
+
+
)
{
result
-
>
writeText
(
"
}
ifelse
\
n
"
)
;
}
}
static
sk_sp
<
SkPDFDict
>
createInterpolationFunction
(
const
ColorTuple
&
color1
const
ColorTuple
&
color2
)
{
auto
retval
=
sk_make_sp
<
SkPDFDict
>
(
)
;
auto
c0
=
sk_make_sp
<
SkPDFArray
>
(
)
;
c0
-
>
appendColorComponent
(
color1
[
0
]
)
;
c0
-
>
appendColorComponent
(
color1
[
1
]
)
;
c0
-
>
appendColorComponent
(
color1
[
2
]
)
;
retval
-
>
insertObject
(
"
C0
"
std
:
:
move
(
c0
)
)
;
auto
c1
=
sk_make_sp
<
SkPDFArray
>
(
)
;
c1
-
>
appendColorComponent
(
color2
[
0
]
)
;
c1
-
>
appendColorComponent
(
color2
[
1
]
)
;
c1
-
>
appendColorComponent
(
color2
[
2
]
)
;
retval
-
>
insertObject
(
"
C1
"
std
:
:
move
(
c1
)
)
;
auto
domain
=
sk_make_sp
<
SkPDFArray
>
(
)
;
domain
-
>
appendScalar
(
0
)
;
domain
-
>
appendScalar
(
1
.
0f
)
;
retval
-
>
insertObject
(
"
Domain
"
std
:
:
move
(
domain
)
)
;
retval
-
>
insertInt
(
"
FunctionType
"
2
)
;
retval
-
>
insertScalar
(
"
N
"
1
.
0f
)
;
return
retval
;
}
static
sk_sp
<
SkPDFDict
>
gradientStitchCode
(
const
SkShader
:
:
GradientInfo
&
info
)
{
auto
retval
=
sk_make_sp
<
SkPDFDict
>
(
)
;
int
colorCount
=
info
.
fColorCount
;
SkTDArray
<
SkColor
>
colors
(
info
.
fColors
colorCount
)
;
SkTDArray
<
SkScalar
>
colorOffsets
(
info
.
fColorOffsets
colorCount
)
;
int
i
=
1
;
while
(
i
<
colorCount
-
1
)
{
if
(
colorOffsets
[
i
-
1
]
>
colorOffsets
[
i
]
)
{
colorOffsets
[
i
]
=
colorOffsets
[
i
-
1
]
;
}
if
(
(
colorOffsets
[
i
-
1
]
=
=
colorOffsets
[
i
]
)
&
&
(
colorOffsets
[
i
]
=
=
colorOffsets
[
i
+
1
]
)
)
{
colorCount
-
=
1
;
colors
.
remove
(
i
)
;
colorOffsets
.
remove
(
i
)
;
}
else
{
i
+
+
;
}
}
for
(
i
=
1
;
i
<
colorCount
-
1
;
i
+
+
)
{
if
(
colorOffsets
[
i
-
1
]
=
=
colorOffsets
[
i
]
)
{
colorOffsets
[
i
]
+
=
0
.
00001f
;
}
}
if
(
colorOffsets
[
i
-
1
]
=
=
colorOffsets
[
i
]
)
{
colorOffsets
[
i
-
1
]
-
=
0
.
00001f
;
}
SkAutoSTMalloc
<
4
ColorTuple
>
colorDataAlloc
(
colorCount
)
;
ColorTuple
*
colorData
=
colorDataAlloc
.
get
(
)
;
for
(
int
i
=
0
;
i
<
colorCount
;
i
+
+
)
{
colorData
[
i
]
[
0
]
=
SkColorGetR
(
colors
[
i
]
)
;
colorData
[
i
]
[
1
]
=
SkColorGetG
(
colors
[
i
]
)
;
colorData
[
i
]
[
2
]
=
SkColorGetB
(
colors
[
i
]
)
;
}
if
(
colorCount
=
=
2
)
return
createInterpolationFunction
(
colorData
[
0
]
colorData
[
1
]
)
;
auto
encode
=
sk_make_sp
<
SkPDFArray
>
(
)
;
auto
bounds
=
sk_make_sp
<
SkPDFArray
>
(
)
;
auto
functions
=
sk_make_sp
<
SkPDFArray
>
(
)
;
auto
domain
=
sk_make_sp
<
SkPDFArray
>
(
)
;
domain
-
>
appendScalar
(
0
)
;
domain
-
>
appendScalar
(
1
.
0f
)
;
retval
-
>
insertObject
(
"
Domain
"
std
:
:
move
(
domain
)
)
;
retval
-
>
insertInt
(
"
FunctionType
"
3
)
;
for
(
int
i
=
1
;
i
<
colorCount
;
i
+
+
)
{
if
(
i
>
1
)
{
bounds
-
>
appendScalar
(
colorOffsets
[
i
-
1
]
)
;
}
encode
-
>
appendScalar
(
0
)
;
encode
-
>
appendScalar
(
1
.
0f
)
;
functions
-
>
appendObject
(
createInterpolationFunction
(
colorData
[
i
-
1
]
colorData
[
i
]
)
)
;
}
retval
-
>
insertObject
(
"
Encode
"
std
:
:
move
(
encode
)
)
;
retval
-
>
insertObject
(
"
Bounds
"
std
:
:
move
(
bounds
)
)
;
retval
-
>
insertObject
(
"
Functions
"
std
:
:
move
(
functions
)
)
;
return
retval
;
}
static
void
tileModeCode
(
SkShader
:
:
TileMode
mode
SkDynamicMemoryWStream
*
result
)
{
if
(
mode
=
=
SkShader
:
:
kRepeat_TileMode
)
{
result
-
>
writeText
(
"
dup
truncate
sub
\
n
"
)
;
result
-
>
writeText
(
"
dup
0
le
{
1
add
}
if
\
n
"
)
;
return
;
}
if
(
mode
=
=
SkShader
:
:
kMirror_TileMode
)
{
result
-
>
writeText
(
"
abs
"
"
dup
"
"
truncate
"
"
dup
"
"
cvi
"
"
2
mod
"
"
1
eq
"
"
3
1
roll
"
"
sub
"
"
exch
"
"
{
1
exch
sub
}
if
\
n
"
)
;
}
}
static
void
apply_perspective_to_coordinates
(
const
SkMatrix
&
inversePerspectiveMatrix
SkDynamicMemoryWStream
*
code
)
{
if
(
!
inversePerspectiveMatrix
.
hasPerspective
(
)
)
{
return
;
}
const
SkScalar
p0
=
inversePerspectiveMatrix
[
SkMatrix
:
:
kMPersp0
]
;
const
SkScalar
p1
=
inversePerspectiveMatrix
[
SkMatrix
:
:
kMPersp1
]
;
const
SkScalar
p2
=
inversePerspectiveMatrix
[
SkMatrix
:
:
kMPersp2
]
;
code
-
>
writeText
(
"
dup
"
)
;
SkPDFUtils
:
:
AppendScalar
(
p1
code
)
;
code
-
>
writeText
(
"
mul
"
"
2
index
"
)
;
SkPDFUtils
:
:
AppendScalar
(
p0
code
)
;
code
-
>
writeText
(
"
mul
"
)
;
SkPDFUtils
:
:
AppendScalar
(
p2
code
)
;
code
-
>
writeText
(
"
add
"
"
add
"
"
3
1
roll
"
"
2
index
"
"
div
"
"
3
1
roll
"
"
exch
"
"
div
"
"
exch
\
n
"
)
;
}
static
void
linearCode
(
const
SkShader
:
:
GradientInfo
&
info
const
SkMatrix
&
perspectiveRemover
SkDynamicMemoryWStream
*
function
)
{
function
-
>
writeText
(
"
{
"
)
;
apply_perspective_to_coordinates
(
perspectiveRemover
function
)
;
function
-
>
writeText
(
"
pop
\
n
"
)
;
tileModeCode
(
info
.
fTileMode
function
)
;
gradientFunctionCode
(
info
function
)
;
function
-
>
writeText
(
"
}
"
)
;
}
static
void
radialCode
(
const
SkShader
:
:
GradientInfo
&
info
const
SkMatrix
&
perspectiveRemover
SkDynamicMemoryWStream
*
function
)
{
function
-
>
writeText
(
"
{
"
)
;
apply_perspective_to_coordinates
(
perspectiveRemover
function
)
;
function
-
>
writeText
(
"
dup
"
"
mul
"
"
exch
"
"
dup
"
"
mul
"
"
add
"
"
sqrt
\
n
"
)
;
tileModeCode
(
info
.
fTileMode
function
)
;
gradientFunctionCode
(
info
function
)
;
function
-
>
writeText
(
"
}
"
)
;
}
static
void
twoPointConicalCode
(
const
SkShader
:
:
GradientInfo
&
info
const
SkMatrix
&
perspectiveRemover
SkDynamicMemoryWStream
*
function
)
{
SkScalar
dx
=
info
.
fPoint
[
1
]
.
fX
-
info
.
fPoint
[
0
]
.
fX
;
SkScalar
dy
=
info
.
fPoint
[
1
]
.
fY
-
info
.
fPoint
[
0
]
.
fY
;
SkScalar
r0
=
info
.
fRadius
[
0
]
;
SkScalar
dr
=
info
.
fRadius
[
1
]
-
info
.
fRadius
[
0
]
;
SkScalar
a
=
dx
*
dx
+
dy
*
dy
-
dr
*
dr
;
function
-
>
writeText
(
"
{
"
)
;
apply_perspective_to_coordinates
(
perspectiveRemover
function
)
;
function
-
>
writeText
(
"
2
copy
"
)
;
SkPDFUtils
:
:
AppendScalar
(
dy
function
)
;
function
-
>
writeText
(
"
mul
exch
"
)
;
SkPDFUtils
:
:
AppendScalar
(
dx
function
)
;
function
-
>
writeText
(
"
mul
add
"
)
;
SkPDFUtils
:
:
AppendScalar
(
r0
*
dr
function
)
;
function
-
>
writeText
(
"
add
-
2
mul
dup
dup
mul
\
n
"
)
;
function
-
>
writeText
(
"
4
2
roll
dup
mul
exch
dup
mul
add
"
)
;
SkPDFUtils
:
:
AppendScalar
(
r0
*
r0
function
)
;
function
-
>
writeText
(
"
sub
dup
4
1
roll
\
n
"
)
;
if
(
a
=
=
0
)
{
function
-
>
writeText
(
"
pop
pop
div
neg
dup
"
)
;
SkPDFUtils
:
:
AppendScalar
(
dr
function
)
;
function
-
>
writeText
(
"
mul
"
)
;
SkPDFUtils
:
:
AppendScalar
(
r0
function
)
;
function
-
>
writeText
(
"
add
\
n
"
)
;
function
-
>
writeText
(
"
0
lt
{
pop
false
}
{
true
}
ifelse
\
n
"
)
;
}
else
{
SkPDFUtils
:
:
AppendScalar
(
a
*
4
function
)
;
function
-
>
writeText
(
"
mul
sub
dup
\
n
"
)
;
function
-
>
writeText
(
"
0
ge
{
\
n
"
)
;
function
-
>
writeText
(
"
sqrt
exch
dup
0
lt
{
exch
-
1
mul
}
if
"
)
;
function
-
>
writeText
(
"
add
-
0
.
5
mul
dup
\
n
"
)
;
SkPDFUtils
:
:
AppendScalar
(
a
function
)
;
function
-
>
writeText
(
"
div
\
n
"
)
;
function
-
>
writeText
(
"
3
1
roll
div
\
n
"
)
;
function
-
>
writeText
(
"
2
copy
gt
{
exch
}
if
\
n
"
)
;
function
-
>
writeText
(
"
dup
"
)
;
SkPDFUtils
:
:
AppendScalar
(
dr
function
)
;
function
-
>
writeText
(
"
mul
"
)
;
SkPDFUtils
:
:
AppendScalar
(
r0
function
)
;
function
-
>
writeText
(
"
add
\
n
"
)
;
function
-
>
writeText
(
"
0
gt
{
exch
pop
true
}
\
n
"
)
;
function
-
>
writeText
(
"
{
pop
dup
\
n
"
)
;
SkPDFUtils
:
:
AppendScalar
(
dr
function
)
;
function
-
>
writeText
(
"
mul
"
)
;
SkPDFUtils
:
:
AppendScalar
(
r0
function
)
;
function
-
>
writeText
(
"
add
\
n
"
)
;
function
-
>
writeText
(
"
0
le
{
pop
false
}
{
true
}
ifelse
\
n
"
)
;
function
-
>
writeText
(
"
}
ifelse
\
n
"
)
;
function
-
>
writeText
(
"
}
{
pop
pop
pop
false
}
ifelse
\
n
"
)
;
}
function
-
>
writeText
(
"
{
"
)
;
tileModeCode
(
info
.
fTileMode
function
)
;
gradientFunctionCode
(
info
function
)
;
function
-
>
writeText
(
"
}
{
0
0
0
}
ifelse
}
"
)
;
}
static
void
sweepCode
(
const
SkShader
:
:
GradientInfo
&
info
const
SkMatrix
&
perspectiveRemover
SkDynamicMemoryWStream
*
function
)
{
function
-
>
writeText
(
"
{
exch
atan
360
div
\
n
"
)
;
tileModeCode
(
info
.
fTileMode
function
)
;
gradientFunctionCode
(
info
function
)
;
function
-
>
writeText
(
"
}
"
)
;
}
static
void
drawBitmapMatrix
(
SkCanvas
*
canvas
const
SkBitmap
&
bm
const
SkMatrix
&
matrix
)
{
SkAutoCanvasRestore
acr
(
canvas
true
)
;
canvas
-
>
concat
(
matrix
)
;
canvas
-
>
drawBitmap
(
bm
0
0
)
;
}
static
sk_sp
<
SkPDFStream
>
make_alpha_function_shader
(
SkPDFDocument
*
doc
SkScalar
dpi
const
SkPDFShader
:
:
State
&
state
)
;
static
sk_sp
<
SkPDFDict
>
make_function_shader
(
SkPDFCanon
*
canon
const
SkPDFShader
:
:
State
&
state
)
;
static
sk_sp
<
SkPDFStream
>
make_image_shader
(
SkPDFDocument
*
doc
SkScalar
dpi
const
SkPDFShader
:
:
State
&
state
SkBitmap
image
)
;
static
sk_sp
<
SkPDFObject
>
get_pdf_shader_by_state
(
SkPDFDocument
*
doc
SkScalar
dpi
SkPDFShader
:
:
State
state
SkBitmap
image
)
{
SkPDFCanon
*
canon
=
doc
-
>
canon
(
)
;
if
(
state
.
fType
=
=
SkShader
:
:
kNone_GradientType
&
&
image
.
isNull
(
)
)
{
return
nullptr
;
}
else
if
(
state
.
fType
=
=
SkShader
:
:
kNone_GradientType
)
{
sk_sp
<
SkPDFObject
>
shader
=
canon
-
>
findImageShader
(
state
)
;
if
(
!
shader
)
{
shader
=
make_image_shader
(
doc
dpi
state
std
:
:
move
(
image
)
)
;
canon
-
>
addImageShader
(
shader
std
:
:
move
(
state
)
)
;
}
return
shader
;
}
else
if
(
state
.
GradientHasAlpha
(
)
)
{
sk_sp
<
SkPDFObject
>
shader
=
canon
-
>
findAlphaShader
(
state
)
;
if
(
!
shader
)
{
shader
=
make_alpha_function_shader
(
doc
dpi
state
)
;
canon
-
>
addAlphaShader
(
shader
std
:
:
move
(
state
)
)
;
}
return
shader
;
}
else
{
sk_sp
<
SkPDFObject
>
shader
=
canon
-
>
findFunctionShader
(
state
)
;
if
(
!
shader
)
{
shader
=
make_function_shader
(
canon
state
)
;
canon
-
>
addFunctionShader
(
shader
std
:
:
move
(
state
)
)
;
}
return
shader
;
}
}
sk_sp
<
SkPDFObject
>
SkPDFShader
:
:
GetPDFShader
(
SkPDFDocument
*
doc
SkScalar
dpi
SkShader
*
shader
const
SkMatrix
&
matrix
const
SkIRect
&
surfaceBBox
SkScalar
rasterScale
)
{
if
(
surfaceBBox
.
isEmpty
(
)
)
{
return
nullptr
;
}
SkBitmap
image
;
State
state
(
shader
matrix
surfaceBBox
rasterScale
&
image
)
;
return
get_pdf_shader_by_state
(
doc
dpi
std
:
:
move
(
state
)
std
:
:
move
(
image
)
)
;
}
static
sk_sp
<
SkPDFDict
>
get_gradient_resource_dict
(
SkPDFObject
*
functionShader
SkPDFObject
*
gState
)
{
SkTDArray
<
SkPDFObject
*
>
patterns
;
if
(
functionShader
)
{
patterns
.
push
(
functionShader
)
;
}
SkTDArray
<
SkPDFObject
*
>
graphicStates
;
if
(
gState
)
{
graphicStates
.
push
(
gState
)
;
}
return
SkPDFResourceDict
:
:
Make
(
&
graphicStates
&
patterns
nullptr
nullptr
)
;
}
static
void
populate_tiling_pattern_dict
(
SkPDFDict
*
pattern
SkRect
&
bbox
sk_sp
<
SkPDFDict
>
resources
const
SkMatrix
&
matrix
)
{
const
int
kTiling_PatternType
=
1
;
const
int
kColoredTilingPattern_PaintType
=
1
;
const
int
kConstantSpacing_TilingType
=
1
;
pattern
-
>
insertName
(
"
Type
"
"
Pattern
"
)
;
pattern
-
>
insertInt
(
"
PatternType
"
kTiling_PatternType
)
;
pattern
-
>
insertInt
(
"
PaintType
"
kColoredTilingPattern_PaintType
)
;
pattern
-
>
insertInt
(
"
TilingType
"
kConstantSpacing_TilingType
)
;
pattern
-
>
insertObject
(
"
BBox
"
SkPDFUtils
:
:
RectToArray
(
bbox
)
)
;
pattern
-
>
insertScalar
(
"
XStep
"
bbox
.
width
(
)
)
;
pattern
-
>
insertScalar
(
"
YStep
"
bbox
.
height
(
)
)
;
pattern
-
>
insertObject
(
"
Resources
"
std
:
:
move
(
resources
)
)
;
if
(
!
matrix
.
isIdentity
(
)
)
{
pattern
-
>
insertObject
(
"
Matrix
"
SkPDFUtils
:
:
MatrixToArray
(
matrix
)
)
;
}
}
static
std
:
:
unique_ptr
<
SkStreamAsset
>
create_pattern_fill_content
(
int
gsIndex
SkRect
&
bounds
)
{
SkDynamicMemoryWStream
content
;
if
(
gsIndex
>
=
0
)
{
SkPDFUtils
:
:
ApplyGraphicState
(
gsIndex
&
content
)
;
}
SkPDFUtils
:
:
ApplyPattern
(
0
&
content
)
;
SkPDFUtils
:
:
AppendRectangle
(
bounds
&
content
)
;
SkPDFUtils
:
:
PaintPath
(
SkPaint
:
:
kFill_Style
SkPath
:
:
kEvenOdd_FillType
&
content
)
;
return
std
:
:
unique_ptr
<
SkStreamAsset
>
(
content
.
detachAsStream
(
)
)
;
}
static
sk_sp
<
SkPDFObject
>
create_smask_graphic_state
(
SkPDFDocument
*
doc
SkScalar
dpi
const
SkPDFShader
:
:
State
&
state
)
{
SkRect
bbox
;
bbox
.
set
(
state
.
fBBox
)
;
sk_sp
<
SkPDFObject
>
luminosityShader
(
get_pdf_shader_by_state
(
doc
dpi
state
.
MakeAlphaToLuminosityState
(
)
SkBitmap
(
)
)
)
;
std
:
:
unique_ptr
<
SkStreamAsset
>
alphaStream
(
create_pattern_fill_content
(
-
1
bbox
)
)
;
sk_sp
<
SkPDFDict
>
resources
=
get_gradient_resource_dict
(
luminosityShader
.
get
(
)
nullptr
)
;
sk_sp
<
SkPDFObject
>
alphaMask
=
SkPDFMakeFormXObject
(
std
:
:
move
(
alphaStream
)
SkPDFUtils
:
:
RectToArray
(
bbox
)
std
:
:
move
(
resources
)
SkMatrix
:
:
I
(
)
"
DeviceRGB
"
)
;
return
SkPDFGraphicState
:
:
GetSMaskGraphicState
(
std
:
:
move
(
alphaMask
)
false
SkPDFGraphicState
:
:
kLuminosity_SMaskMode
doc
-
>
canon
(
)
)
;
}
static
sk_sp
<
SkPDFStream
>
make_alpha_function_shader
(
SkPDFDocument
*
doc
SkScalar
dpi
const
SkPDFShader
:
:
State
&
state
)
{
SkRect
bbox
;
bbox
.
set
(
state
.
fBBox
)
;
SkPDFShader
:
:
State
opaqueState
(
state
.
MakeOpaqueState
(
)
)
;
sk_sp
<
SkPDFObject
>
colorShader
(
get_pdf_shader_by_state
(
doc
dpi
std
:
:
move
(
opaqueState
)
SkBitmap
(
)
)
)
;
if
(
!
colorShader
)
{
return
nullptr
;
}
sk_sp
<
SkPDFObject
>
alphaGs
=
create_smask_graphic_state
(
doc
dpi
state
)
;
sk_sp
<
SkPDFDict
>
resourceDict
=
get_gradient_resource_dict
(
colorShader
.
get
(
)
alphaGs
.
get
(
)
)
;
std
:
:
unique_ptr
<
SkStreamAsset
>
colorStream
(
create_pattern_fill_content
(
0
bbox
)
)
;
auto
alphaFunctionShader
=
sk_make_sp
<
SkPDFStream
>
(
std
:
:
move
(
colorStream
)
)
;
populate_tiling_pattern_dict
(
alphaFunctionShader
-
>
dict
(
)
bbox
std
:
:
move
(
resourceDict
)
SkMatrix
:
:
I
(
)
)
;
return
alphaFunctionShader
;
}
static
bool
split_perspective
(
const
SkMatrix
in
SkMatrix
*
affine
SkMatrix
*
perspectiveInverse
)
{
const
SkScalar
p2
=
in
[
SkMatrix
:
:
kMPersp2
]
;
if
(
SkScalarNearlyZero
(
p2
)
)
{
return
false
;
}
const
SkScalar
zero
=
SkIntToScalar
(
0
)
;
const
SkScalar
one
=
SkIntToScalar
(
1
)
;
const
SkScalar
sx
=
in
[
SkMatrix
:
:
kMScaleX
]
;
const
SkScalar
kx
=
in
[
SkMatrix
:
:
kMSkewX
]
;
const
SkScalar
tx
=
in
[
SkMatrix
:
:
kMTransX
]
;
const
SkScalar
ky
=
in
[
SkMatrix
:
:
kMSkewY
]
;
const
SkScalar
sy
=
in
[
SkMatrix
:
:
kMScaleY
]
;
const
SkScalar
ty
=
in
[
SkMatrix
:
:
kMTransY
]
;
const
SkScalar
p0
=
in
[
SkMatrix
:
:
kMPersp0
]
;
const
SkScalar
p1
=
in
[
SkMatrix
:
:
kMPersp1
]
;
perspectiveInverse
-
>
setAll
(
one
zero
zero
zero
one
zero
-
p0
/
p2
-
p1
/
p2
1
/
p2
)
;
affine
-
>
setAll
(
sx
-
p0
*
tx
/
p2
kx
-
p1
*
tx
/
p2
tx
/
p2
ky
-
p0
*
ty
/
p2
sy
-
p1
*
ty
/
p2
ty
/
p2
zero
zero
one
)
;
return
true
;
}
sk_sp
<
SkPDFArray
>
SkPDFShader
:
:
MakeRangeObject
(
)
{
auto
range
=
sk_make_sp
<
SkPDFArray
>
(
)
;
range
-
>
reserve
(
6
)
;
range
-
>
appendInt
(
0
)
;
range
-
>
appendInt
(
1
)
;
range
-
>
appendInt
(
0
)
;
range
-
>
appendInt
(
1
)
;
range
-
>
appendInt
(
0
)
;
range
-
>
appendInt
(
1
)
;
return
range
;
}
static
sk_sp
<
SkPDFStream
>
make_ps_function
(
std
:
:
unique_ptr
<
SkStreamAsset
>
psCode
sk_sp
<
SkPDFArray
>
domain
sk_sp
<
SkPDFObject
>
range
)
{
auto
result
=
sk_make_sp
<
SkPDFStream
>
(
std
:
:
move
(
psCode
)
)
;
result
-
>
dict
(
)
-
>
insertInt
(
"
FunctionType
"
4
)
;
result
-
>
dict
(
)
-
>
insertObject
(
"
Domain
"
std
:
:
move
(
domain
)
)
;
result
-
>
dict
(
)
-
>
insertObject
(
"
Range
"
std
:
:
move
(
range
)
)
;
return
result
;
}
static
void
FixUpRadius
(
const
SkPoint
&
p1
SkScalar
&
r1
const
SkPoint
&
p2
SkScalar
&
r2
)
{
SkScalar
distance
=
SkPoint
:
:
Distance
(
p1
p2
)
;
SkScalar
subtractRadii
=
fabs
(
r1
-
r2
)
;
if
(
fabs
(
distance
-
subtractRadii
)
<
0
.
002f
)
{
if
(
r1
>
r2
)
{
r1
+
=
0
.
002f
;
}
else
{
r2
+
=
0
.
002f
;
}
}
}
static
sk_sp
<
SkPDFDict
>
make_function_shader
(
SkPDFCanon
*
canon
const
SkPDFShader
:
:
State
&
state
)
{
void
(
*
codeFunction
)
(
const
SkShader
:
:
GradientInfo
&
info
const
SkMatrix
&
perspectiveRemover
SkDynamicMemoryWStream
*
function
)
=
nullptr
;
SkPoint
transformPoints
[
2
]
;
const
SkShader
:
:
GradientInfo
*
info
=
&
state
.
fInfo
;
SkMatrix
finalMatrix
=
state
.
fCanvasTransform
;
finalMatrix
.
preConcat
(
state
.
fShaderTransform
)
;
bool
doStitchFunctions
=
(
state
.
fType
=
=
SkShader
:
:
kLinear_GradientType
|
|
state
.
fType
=
=
SkShader
:
:
kRadial_GradientType
|
|
state
.
fType
=
=
SkShader
:
:
kConical_GradientType
)
&
&
info
-
>
fTileMode
=
=
SkShader
:
:
kClamp_TileMode
&
&
!
finalMatrix
.
hasPerspective
(
)
;
auto
domain
=
sk_make_sp
<
SkPDFArray
>
(
)
;
int32_t
shadingType
=
1
;
auto
pdfShader
=
sk_make_sp
<
SkPDFDict
>
(
)
;
if
(
doStitchFunctions
)
{
pdfShader
-
>
insertObject
(
"
Function
"
gradientStitchCode
(
*
info
)
)
;
shadingType
=
(
state
.
fType
=
=
SkShader
:
:
kLinear_GradientType
)
?
2
:
3
;
auto
extend
=
sk_make_sp
<
SkPDFArray
>
(
)
;
extend
-
>
reserve
(
2
)
;
extend
-
>
appendBool
(
true
)
;
extend
-
>
appendBool
(
true
)
;
pdfShader
-
>
insertObject
(
"
Extend
"
std
:
:
move
(
extend
)
)
;
auto
coords
=
sk_make_sp
<
SkPDFArray
>
(
)
;
if
(
state
.
fType
=
=
SkShader
:
:
kConical_GradientType
)
{
coords
-
>
reserve
(
6
)
;
SkScalar
r1
=
info
-
>
fRadius
[
0
]
;
SkScalar
r2
=
info
-
>
fRadius
[
1
]
;
SkPoint
pt1
=
info
-
>
fPoint
[
0
]
;
SkPoint
pt2
=
info
-
>
fPoint
[
1
]
;
FixUpRadius
(
pt1
r1
pt2
r2
)
;
coords
-
>
appendScalar
(
pt1
.
fX
)
;
coords
-
>
appendScalar
(
pt1
.
fY
)
;
coords
-
>
appendScalar
(
r1
)
;
coords
-
>
appendScalar
(
pt2
.
fX
)
;
coords
-
>
appendScalar
(
pt2
.
fY
)
;
coords
-
>
appendScalar
(
r2
)
;
}
else
if
(
state
.
fType
=
=
SkShader
:
:
kRadial_GradientType
)
{
coords
-
>
reserve
(
6
)
;
const
SkPoint
&
pt1
=
info
-
>
fPoint
[
0
]
;
coords
-
>
appendScalar
(
pt1
.
fX
)
;
coords
-
>
appendScalar
(
pt1
.
fY
)
;
coords
-
>
appendScalar
(
0
)
;
coords
-
>
appendScalar
(
pt1
.
fX
)
;
coords
-
>
appendScalar
(
pt1
.
fY
)
;
coords
-
>
appendScalar
(
info
-
>
fRadius
[
0
]
)
;
}
else
{
coords
-
>
reserve
(
4
)
;
const
SkPoint
&
pt1
=
info
-
>
fPoint
[
0
]
;
const
SkPoint
&
pt2
=
info
-
>
fPoint
[
1
]
;
coords
-
>
appendScalar
(
pt1
.
fX
)
;
coords
-
>
appendScalar
(
pt1
.
fY
)
;
coords
-
>
appendScalar
(
pt2
.
fX
)
;
coords
-
>
appendScalar
(
pt2
.
fY
)
;
}
pdfShader
-
>
insertObject
(
"
Coords
"
std
:
:
move
(
coords
)
)
;
}
else
{
transformPoints
[
0
]
=
info
-
>
fPoint
[
0
]
;
transformPoints
[
1
]
=
info
-
>
fPoint
[
1
]
;
switch
(
state
.
fType
)
{
case
SkShader
:
:
kLinear_GradientType
:
codeFunction
=
&
linearCode
;
break
;
case
SkShader
:
:
kRadial_GradientType
:
transformPoints
[
1
]
=
transformPoints
[
0
]
;
transformPoints
[
1
]
.
fX
+
=
info
-
>
fRadius
[
0
]
;
codeFunction
=
&
radialCode
;
break
;
case
SkShader
:
:
kConical_GradientType
:
{
transformPoints
[
1
]
=
transformPoints
[
0
]
;
transformPoints
[
1
]
.
fX
+
=
SK_Scalar1
;
codeFunction
=
&
twoPointConicalCode
;
break
;
}
case
SkShader
:
:
kSweep_GradientType
:
transformPoints
[
1
]
=
transformPoints
[
0
]
;
transformPoints
[
1
]
.
fX
+
=
SK_Scalar1
;
codeFunction
=
&
sweepCode
;
break
;
case
SkShader
:
:
kColor_GradientType
:
case
SkShader
:
:
kNone_GradientType
:
default
:
return
nullptr
;
}
SkMatrix
mapperMatrix
;
unitToPointsMatrix
(
transformPoints
&
mapperMatrix
)
;
finalMatrix
.
preConcat
(
mapperMatrix
)
;
SkMatrix
perspectiveInverseOnly
=
SkMatrix
:
:
I
(
)
;
if
(
finalMatrix
.
hasPerspective
(
)
)
{
if
(
!
split_perspective
(
finalMatrix
&
finalMatrix
&
perspectiveInverseOnly
)
)
{
return
nullptr
;
}
}
SkRect
bbox
;
bbox
.
set
(
state
.
fBBox
)
;
if
(
!
inverse_transform_bbox
(
finalMatrix
&
bbox
)
)
{
return
nullptr
;
}
domain
-
>
reserve
(
4
)
;
domain
-
>
appendScalar
(
bbox
.
fLeft
)
;
domain
-
>
appendScalar
(
bbox
.
fRight
)
;
domain
-
>
appendScalar
(
bbox
.
fTop
)
;
domain
-
>
appendScalar
(
bbox
.
fBottom
)
;
SkDynamicMemoryWStream
functionCode
;
if
(
state
.
fType
=
=
SkShader
:
:
kConical_GradientType
)
{
SkShader
:
:
GradientInfo
twoPointRadialInfo
=
*
info
;
SkMatrix
inverseMapperMatrix
;
if
(
!
mapperMatrix
.
invert
(
&
inverseMapperMatrix
)
)
{
return
nullptr
;
}
inverseMapperMatrix
.
mapPoints
(
twoPointRadialInfo
.
fPoint
2
)
;
twoPointRadialInfo
.
fRadius
[
0
]
=
inverseMapperMatrix
.
mapRadius
(
info
-
>
fRadius
[
0
]
)
;
twoPointRadialInfo
.
fRadius
[
1
]
=
inverseMapperMatrix
.
mapRadius
(
info
-
>
fRadius
[
1
]
)
;
codeFunction
(
twoPointRadialInfo
perspectiveInverseOnly
&
functionCode
)
;
}
else
{
codeFunction
(
*
info
perspectiveInverseOnly
&
functionCode
)
;
}
pdfShader
-
>
insertObject
(
"
Domain
"
domain
)
;
std
:
:
unique_ptr
<
SkStreamAsset
>
functionStream
(
functionCode
.
detachAsStream
(
)
)
;
sk_sp
<
SkPDFStream
>
function
=
make_ps_function
(
std
:
:
move
(
functionStream
)
std
:
:
move
(
domain
)
canon
-
>
makeRangeObject
(
)
)
;
pdfShader
-
>
insertObjRef
(
"
Function
"
std
:
:
move
(
function
)
)
;
}
pdfShader
-
>
insertInt
(
"
ShadingType
"
shadingType
)
;
pdfShader
-
>
insertName
(
"
ColorSpace
"
"
DeviceRGB
"
)
;
auto
pdfFunctionShader
=
sk_make_sp
<
SkPDFDict
>
(
"
Pattern
"
)
;
pdfFunctionShader
-
>
insertInt
(
"
PatternType
"
2
)
;
pdfFunctionShader
-
>
insertObject
(
"
Matrix
"
SkPDFUtils
:
:
MatrixToArray
(
finalMatrix
)
)
;
pdfFunctionShader
-
>
insertObject
(
"
Shading
"
std
:
:
move
(
pdfShader
)
)
;
return
pdfFunctionShader
;
}
static
sk_sp
<
SkPDFStream
>
make_image_shader
(
SkPDFDocument
*
doc
SkScalar
dpi
const
SkPDFShader
:
:
State
&
state
SkBitmap
image
)
{
SkASSERT
(
state
.
fBitmapKey
=
=
(
SkBitmapKey
{
image
.
getSubset
(
)
image
.
getGenerationID
(
)
}
)
)
;
SkAutoLockPixels
SkAutoLockPixels
(
image
)
;
SkMatrix
finalMatrix
=
state
.
fCanvasTransform
;
finalMatrix
.
preConcat
(
state
.
fShaderTransform
)
;
SkRect
deviceBounds
;
deviceBounds
.
set
(
state
.
fBBox
)
;
if
(
!
inverse_transform_bbox
(
finalMatrix
&
deviceBounds
)
)
{
return
nullptr
;
}
SkRect
bitmapBounds
;
image
.
getBounds
(
&
bitmapBounds
)
;
SkShader
:
:
TileMode
tileModes
[
2
]
;
tileModes
[
0
]
=
state
.
fImageTileModes
[
0
]
;
tileModes
[
1
]
=
state
.
fImageTileModes
[
1
]
;
if
(
tileModes
[
0
]
!
=
SkShader
:
:
kClamp_TileMode
|
|
tileModes
[
1
]
!
=
SkShader
:
:
kClamp_TileMode
)
{
deviceBounds
.
join
(
bitmapBounds
)
;
}
SkISize
size
=
SkISize
:
:
Make
(
SkScalarRoundToInt
(
deviceBounds
.
width
(
)
)
SkScalarRoundToInt
(
deviceBounds
.
height
(
)
)
)
;
sk_sp
<
SkPDFDevice
>
patternDevice
(
SkPDFDevice
:
:
CreateUnflipped
(
size
dpi
doc
)
)
;
SkCanvas
canvas
(
patternDevice
.
get
(
)
)
;
SkRect
patternBBox
;
image
.
getBounds
(
&
patternBBox
)
;
canvas
.
translate
(
-
deviceBounds
.
left
(
)
-
deviceBounds
.
top
(
)
)
;
patternBBox
.
offset
(
-
deviceBounds
.
left
(
)
-
deviceBounds
.
top
(
)
)
;
finalMatrix
.
preTranslate
(
deviceBounds
.
left
(
)
deviceBounds
.
top
(
)
)
;
canvas
.
drawBitmap
(
image
0
0
)
;
SkScalar
width
=
SkIntToScalar
(
image
.
width
(
)
)
;
SkScalar
height
=
SkIntToScalar
(
image
.
height
(
)
)
;
if
(
tileModes
[
0
]
=
=
SkShader
:
:
kMirror_TileMode
)
{
SkMatrix
xMirror
;
xMirror
.
setScale
(
-
1
1
)
;
xMirror
.
postTranslate
(
2
*
width
0
)
;
drawBitmapMatrix
(
&
canvas
image
xMirror
)
;
patternBBox
.
fRight
+
=
width
;
}
if
(
tileModes
[
1
]
=
=
SkShader
:
:
kMirror_TileMode
)
{
SkMatrix
yMirror
;
yMirror
.
setScale
(
SK_Scalar1
-
SK_Scalar1
)
;
yMirror
.
postTranslate
(
0
2
*
height
)
;
drawBitmapMatrix
(
&
canvas
image
yMirror
)
;
patternBBox
.
fBottom
+
=
height
;
}
if
(
tileModes
[
0
]
=
=
SkShader
:
:
kMirror_TileMode
&
&
tileModes
[
1
]
=
=
SkShader
:
:
kMirror_TileMode
)
{
SkMatrix
mirror
;
mirror
.
setScale
(
-
1
-
1
)
;
mirror
.
postTranslate
(
2
*
width
2
*
height
)
;
drawBitmapMatrix
(
&
canvas
image
mirror
)
;
}
if
(
tileModes
[
0
]
=
=
SkShader
:
:
kClamp_TileMode
&
&
tileModes
[
1
]
=
=
SkShader
:
:
kClamp_TileMode
)
{
SkPaint
paint
;
SkRect
rect
;
rect
=
SkRect
:
:
MakeLTRB
(
deviceBounds
.
left
(
)
deviceBounds
.
top
(
)
0
0
)
;
if
(
!
rect
.
isEmpty
(
)
)
{
paint
.
setColor
(
image
.
getColor
(
0
0
)
)
;
canvas
.
drawRect
(
rect
paint
)
;
}
rect
=
SkRect
:
:
MakeLTRB
(
width
deviceBounds
.
top
(
)
deviceBounds
.
right
(
)
0
)
;
if
(
!
rect
.
isEmpty
(
)
)
{
paint
.
setColor
(
image
.
getColor
(
image
.
width
(
)
-
1
0
)
)
;
canvas
.
drawRect
(
rect
paint
)
;
}
rect
=
SkRect
:
:
MakeLTRB
(
width
height
deviceBounds
.
right
(
)
deviceBounds
.
bottom
(
)
)
;
if
(
!
rect
.
isEmpty
(
)
)
{
paint
.
setColor
(
image
.
getColor
(
image
.
width
(
)
-
1
image
.
height
(
)
-
1
)
)
;
canvas
.
drawRect
(
rect
paint
)
;
}
rect
=
SkRect
:
:
MakeLTRB
(
deviceBounds
.
left
(
)
height
0
deviceBounds
.
bottom
(
)
)
;
if
(
!
rect
.
isEmpty
(
)
)
{
paint
.
setColor
(
image
.
getColor
(
0
image
.
height
(
)
-
1
)
)
;
canvas
.
drawRect
(
rect
paint
)
;
}
}
if
(
tileModes
[
0
]
=
=
SkShader
:
:
kClamp_TileMode
)
{
SkIRect
subset
=
SkIRect
:
:
MakeXYWH
(
0
0
1
image
.
height
(
)
)
;
if
(
deviceBounds
.
left
(
)
<
0
)
{
SkBitmap
left
;
SkAssertResult
(
image
.
extractSubset
(
&
left
subset
)
)
;
SkMatrix
leftMatrix
;
leftMatrix
.
setScale
(
-
deviceBounds
.
left
(
)
1
)
;
leftMatrix
.
postTranslate
(
deviceBounds
.
left
(
)
0
)
;
drawBitmapMatrix
(
&
canvas
left
leftMatrix
)
;
if
(
tileModes
[
1
]
=
=
SkShader
:
:
kMirror_TileMode
)
{
leftMatrix
.
postScale
(
SK_Scalar1
-
SK_Scalar1
)
;
leftMatrix
.
postTranslate
(
0
2
*
height
)
;
drawBitmapMatrix
(
&
canvas
left
leftMatrix
)
;
}
patternBBox
.
fLeft
=
0
;
}
if
(
deviceBounds
.
right
(
)
>
width
)
{
SkBitmap
right
;
subset
.
offset
(
image
.
width
(
)
-
1
0
)
;
SkAssertResult
(
image
.
extractSubset
(
&
right
subset
)
)
;
SkMatrix
rightMatrix
;
rightMatrix
.
setScale
(
deviceBounds
.
right
(
)
-
width
1
)
;
rightMatrix
.
postTranslate
(
width
0
)
;
drawBitmapMatrix
(
&
canvas
right
rightMatrix
)
;
if
(
tileModes
[
1
]
=
=
SkShader
:
:
kMirror_TileMode
)
{
rightMatrix
.
postScale
(
SK_Scalar1
-
SK_Scalar1
)
;
rightMatrix
.
postTranslate
(
0
2
*
height
)
;
drawBitmapMatrix
(
&
canvas
right
rightMatrix
)
;
}
patternBBox
.
fRight
=
deviceBounds
.
width
(
)
;
}
}
if
(
tileModes
[
1
]
=
=
SkShader
:
:
kClamp_TileMode
)
{
SkIRect
subset
=
SkIRect
:
:
MakeXYWH
(
0
0
image
.
width
(
)
1
)
;
if
(
deviceBounds
.
top
(
)
<
0
)
{
SkBitmap
top
;
SkAssertResult
(
image
.
extractSubset
(
&
top
subset
)
)
;
SkMatrix
topMatrix
;
topMatrix
.
setScale
(
SK_Scalar1
-
deviceBounds
.
top
(
)
)
;
topMatrix
.
postTranslate
(
0
deviceBounds
.
top
(
)
)
;
drawBitmapMatrix
(
&
canvas
top
topMatrix
)
;
if
(
tileModes
[
0
]
=
=
SkShader
:
:
kMirror_TileMode
)
{
topMatrix
.
postScale
(
-
1
1
)
;
topMatrix
.
postTranslate
(
2
*
width
0
)
;
drawBitmapMatrix
(
&
canvas
top
topMatrix
)
;
}
patternBBox
.
fTop
=
0
;
}
if
(
deviceBounds
.
bottom
(
)
>
height
)
{
SkBitmap
bottom
;
subset
.
offset
(
0
image
.
height
(
)
-
1
)
;
SkAssertResult
(
image
.
extractSubset
(
&
bottom
subset
)
)
;
SkMatrix
bottomMatrix
;
bottomMatrix
.
setScale
(
SK_Scalar1
deviceBounds
.
bottom
(
)
-
height
)
;
bottomMatrix
.
postTranslate
(
0
height
)
;
drawBitmapMatrix
(
&
canvas
bottom
bottomMatrix
)
;
if
(
tileModes
[
0
]
=
=
SkShader
:
:
kMirror_TileMode
)
{
bottomMatrix
.
postScale
(
-
1
1
)
;
bottomMatrix
.
postTranslate
(
2
*
width
0
)
;
drawBitmapMatrix
(
&
canvas
bottom
bottomMatrix
)
;
}
patternBBox
.
fBottom
=
deviceBounds
.
height
(
)
;
}
}
auto
imageShader
=
sk_make_sp
<
SkPDFStream
>
(
patternDevice
-
>
content
(
)
)
;
populate_tiling_pattern_dict
(
imageShader
-
>
dict
(
)
patternBBox
patternDevice
-
>
makeResourceDict
(
)
finalMatrix
)
;
return
imageShader
;
}
bool
SkPDFShader
:
:
State
:
:
operator
=
=
(
const
SkPDFShader
:
:
State
&
b
)
const
{
if
(
fType
!
=
b
.
fType
|
|
fCanvasTransform
!
=
b
.
fCanvasTransform
|
|
fShaderTransform
!
=
b
.
fShaderTransform
|
|
fBBox
!
=
b
.
fBBox
)
{
return
false
;
}
if
(
fType
=
=
SkShader
:
:
kNone_GradientType
)
{
if
(
fBitmapKey
!
=
b
.
fBitmapKey
|
|
fBitmapKey
.
fID
=
=
0
|
|
fImageTileModes
[
0
]
!
=
b
.
fImageTileModes
[
0
]
|
|
fImageTileModes
[
1
]
!
=
b
.
fImageTileModes
[
1
]
)
{
return
false
;
}
}
else
{
if
(
fInfo
.
fColorCount
!
=
b
.
fInfo
.
fColorCount
|
|
memcmp
(
fInfo
.
fColors
b
.
fInfo
.
fColors
sizeof
(
SkColor
)
*
fInfo
.
fColorCount
)
!
=
0
|
|
memcmp
(
fInfo
.
fColorOffsets
b
.
fInfo
.
fColorOffsets
sizeof
(
SkScalar
)
*
fInfo
.
fColorCount
)
!
=
0
|
|
fInfo
.
fPoint
[
0
]
!
=
b
.
fInfo
.
fPoint
[
0
]
|
|
fInfo
.
fTileMode
!
=
b
.
fInfo
.
fTileMode
)
{
return
false
;
}
switch
(
fType
)
{
case
SkShader
:
:
kLinear_GradientType
:
if
(
fInfo
.
fPoint
[
1
]
!
=
b
.
fInfo
.
fPoint
[
1
]
)
{
return
false
;
}
break
;
case
SkShader
:
:
kRadial_GradientType
:
if
(
fInfo
.
fRadius
[
0
]
!
=
b
.
fInfo
.
fRadius
[
0
]
)
{
return
false
;
}
break
;
case
SkShader
:
:
kConical_GradientType
:
if
(
fInfo
.
fPoint
[
1
]
!
=
b
.
fInfo
.
fPoint
[
1
]
|
|
fInfo
.
fRadius
[
0
]
!
=
b
.
fInfo
.
fRadius
[
0
]
|
|
fInfo
.
fRadius
[
1
]
!
=
b
.
fInfo
.
fRadius
[
1
]
)
{
return
false
;
}
break
;
case
SkShader
:
:
kSweep_GradientType
:
case
SkShader
:
:
kNone_GradientType
:
case
SkShader
:
:
kColor_GradientType
:
break
;
}
}
return
true
;
}
SkPDFShader
:
:
State
:
:
State
(
SkShader
*
shader
const
SkMatrix
&
canvasTransform
const
SkIRect
&
bbox
SkScalar
rasterScale
SkBitmap
*
imageDst
)
:
fType
(
SkShader
:
:
kNone_GradientType
)
fInfo
{
0
nullptr
nullptr
{
{
0
.
0f
0
.
0f
}
{
0
.
0f
0
.
0f
}
}
{
0
.
0f
0
.
0f
}
SkShader
:
:
kClamp_TileMode
0
}
fCanvasTransform
(
canvasTransform
)
fShaderTransform
{
SkMatrix
:
:
I
(
)
}
fBBox
(
bbox
)
fBitmapKey
{
{
0
0
0
0
}
0
}
fImageTileModes
{
SkShader
:
:
kClamp_TileMode
SkShader
:
:
kClamp_TileMode
}
{
SkASSERT
(
imageDst
)
;
fInfo
.
fColorCount
=
0
;
fInfo
.
fColors
=
nullptr
;
fInfo
.
fColorOffsets
=
nullptr
;
fImageTileModes
[
0
]
=
fImageTileModes
[
1
]
=
SkShader
:
:
kClamp_TileMode
;
fType
=
shader
-
>
asAGradient
(
&
fInfo
)
;
if
(
fType
!
=
SkShader
:
:
kNone_GradientType
)
{
fBitmapKey
=
SkBitmapKey
{
{
0
0
0
0
}
0
}
;
fShaderTransform
=
shader
-
>
getLocalMatrix
(
)
;
this
-
>
allocateGradientInfoStorage
(
)
;
shader
-
>
asAGradient
(
&
fInfo
)
;
return
;
}
if
(
SkImage
*
skimg
=
shader
-
>
isAImage
(
&
fShaderTransform
fImageTileModes
)
)
{
if
(
skimg
-
>
asLegacyBitmap
(
imageDst
SkImage
:
:
kRO_LegacyBitmapMode
)
)
{
fBitmapKey
=
SkBitmapKey
{
imageDst
-
>
getSubset
(
)
imageDst
-
>
getGenerationID
(
)
}
;
return
;
}
}
fShaderTransform
=
shader
-
>
getLocalMatrix
(
)
;
SkRect
shaderRect
=
SkRect
:
:
Make
(
bbox
)
;
if
(
!
inverse_transform_bbox
(
canvasTransform
&
shaderRect
)
)
{
imageDst
-
>
reset
(
)
;
return
;
}
static
const
SkScalar
kMaxBitmapArea
=
1024
*
1024
;
SkScalar
bitmapArea
=
rasterScale
*
bbox
.
width
(
)
*
rasterScale
*
bbox
.
height
(
)
;
if
(
bitmapArea
>
kMaxBitmapArea
)
{
rasterScale
*
=
SkScalarSqrt
(
kMaxBitmapArea
/
bitmapArea
)
;
}
SkISize
size
=
{
SkScalarRoundToInt
(
rasterScale
*
bbox
.
width
(
)
)
SkScalarRoundToInt
(
rasterScale
*
bbox
.
height
(
)
)
}
;
SkSize
scale
=
{
SkIntToScalar
(
size
.
width
(
)
)
/
shaderRect
.
width
(
)
SkIntToScalar
(
size
.
height
(
)
)
/
shaderRect
.
height
(
)
}
;
imageDst
-
>
allocN32Pixels
(
size
.
width
(
)
size
.
height
(
)
)
;
imageDst
-
>
eraseColor
(
SK_ColorTRANSPARENT
)
;
SkPaint
p
;
p
.
setShader
(
sk_ref_sp
(
shader
)
)
;
SkCanvas
canvas
(
*
imageDst
)
;
canvas
.
scale
(
scale
.
width
(
)
scale
.
height
(
)
)
;
canvas
.
translate
(
-
shaderRect
.
x
(
)
-
shaderRect
.
y
(
)
)
;
canvas
.
drawPaint
(
p
)
;
fShaderTransform
.
setTranslate
(
shaderRect
.
x
(
)
shaderRect
.
y
(
)
)
;
fShaderTransform
.
preScale
(
1
/
scale
.
width
(
)
1
/
scale
.
height
(
)
)
;
fBitmapKey
=
SkBitmapKey
{
imageDst
-
>
getSubset
(
)
imageDst
-
>
getGenerationID
(
)
}
;
}
SkPDFShader
:
:
State
:
:
State
(
const
SkPDFShader
:
:
State
&
other
)
:
fType
(
other
.
fType
)
fCanvasTransform
(
other
.
fCanvasTransform
)
fShaderTransform
(
other
.
fShaderTransform
)
fBBox
(
other
.
fBBox
)
{
SkASSERT
(
fType
!
=
SkShader
:
:
kNone_GradientType
)
;
if
(
fType
!
=
SkShader
:
:
kNone_GradientType
)
{
fInfo
=
other
.
fInfo
;
this
-
>
allocateGradientInfoStorage
(
)
;
for
(
int
i
=
0
;
i
<
fInfo
.
fColorCount
;
i
+
+
)
{
fInfo
.
fColors
[
i
]
=
other
.
fInfo
.
fColors
[
i
]
;
fInfo
.
fColorOffsets
[
i
]
=
other
.
fInfo
.
fColorOffsets
[
i
]
;
}
}
}
SkPDFShader
:
:
State
SkPDFShader
:
:
State
:
:
MakeAlphaToLuminosityState
(
)
const
{
SkASSERT
(
fBitmapKey
=
=
(
SkBitmapKey
{
{
0
0
0
0
}
0
}
)
)
;
SkASSERT
(
fType
!
=
SkShader
:
:
kNone_GradientType
)
;
SkPDFShader
:
:
State
newState
(
*
this
)
;
for
(
int
i
=
0
;
i
<
fInfo
.
fColorCount
;
i
+
+
)
{
SkAlpha
alpha
=
SkColorGetA
(
fInfo
.
fColors
[
i
]
)
;
newState
.
fInfo
.
fColors
[
i
]
=
SkColorSetARGB
(
255
alpha
alpha
alpha
)
;
}
return
newState
;
}
SkPDFShader
:
:
State
SkPDFShader
:
:
State
:
:
MakeOpaqueState
(
)
const
{
SkASSERT
(
fBitmapKey
=
=
(
SkBitmapKey
{
{
0
0
0
0
}
0
}
)
)
;
SkASSERT
(
fType
!
=
SkShader
:
:
kNone_GradientType
)
;
SkPDFShader
:
:
State
newState
(
*
this
)
;
for
(
int
i
=
0
;
i
<
fInfo
.
fColorCount
;
i
+
+
)
{
newState
.
fInfo
.
fColors
[
i
]
=
SkColorSetA
(
fInfo
.
fColors
[
i
]
SK_AlphaOPAQUE
)
;
}
return
newState
;
}
bool
SkPDFShader
:
:
State
:
:
GradientHasAlpha
(
)
const
{
if
(
fType
=
=
SkShader
:
:
kNone_GradientType
)
{
return
false
;
}
for
(
int
i
=
0
;
i
<
fInfo
.
fColorCount
;
i
+
+
)
{
SkAlpha
alpha
=
SkColorGetA
(
fInfo
.
fColors
[
i
]
)
;
if
(
alpha
!
=
SK_AlphaOPAQUE
)
{
return
true
;
}
}
return
false
;
}
void
SkPDFShader
:
:
State
:
:
allocateGradientInfoStorage
(
)
{
fColors
.
reset
(
new
SkColor
[
fInfo
.
fColorCount
]
)
;
fStops
.
reset
(
new
SkScalar
[
fInfo
.
fColorCount
]
)
;
fInfo
.
fColors
=
fColors
.
get
(
)
;
fInfo
.
fColorOffsets
=
fStops
.
get
(
)
;
}
