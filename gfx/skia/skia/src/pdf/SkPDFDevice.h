#
ifndef
SkPDFDevice_DEFINED
#
define
SkPDFDevice_DEFINED
#
include
"
include
/
core
/
SkCanvas
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSamplingOptions
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkStream
.
h
"
#
include
"
src
/
core
/
SkClipStack
.
h
"
#
include
"
src
/
core
/
SkClipStackDevice
.
h
"
#
include
"
src
/
core
/
SkTHash
.
h
"
#
include
"
src
/
pdf
/
SkKeyedImage
.
h
"
#
include
"
src
/
pdf
/
SkPDFGraphicStackState
.
h
"
#
include
"
src
/
pdf
/
SkPDFTag
.
h
"
#
include
"
src
/
pdf
/
SkPDFTypes
.
h
"
#
include
<
cstddef
>
#
include
<
memory
>
class
SkBitmap
;
class
SkBlender
;
class
SkData
;
class
SkDevice
;
class
SkImage
;
class
SkMesh
;
class
SkPDFDocument
;
class
SkPaint
;
class
SkPath
;
class
SkRRect
;
class
SkSpecialImage
;
class
SkSurface
;
class
SkSurfaceProps
;
class
SkVertices
;
enum
class
SkBlendMode
;
struct
SkIRect
;
struct
SkISize
;
struct
SkImageInfo
;
struct
SkPoint
;
struct
SkRect
;
namespace
sktext
{
class
GlyphRun
;
class
GlyphRunList
;
}
class
SkPDFDevice
final
:
public
SkClipStackDevice
{
public
:
SkPDFDevice
(
SkISize
pageSize
SkPDFDocument
*
document
const
SkMatrix
&
initialTransform
=
SkMatrix
:
:
I
(
)
)
;
sk_sp
<
SkPDFDevice
>
makeCongruentDevice
(
)
{
return
sk_make_sp
<
SkPDFDevice
>
(
this
-
>
size
(
)
fDocument
)
;
}
~
SkPDFDevice
(
)
override
;
void
drawPaint
(
const
SkPaint
&
paint
)
override
;
void
drawPoints
(
SkCanvas
:
:
PointMode
mode
size_t
count
const
SkPoint
[
]
const
SkPaint
&
paint
)
override
;
void
drawRect
(
const
SkRect
&
r
const
SkPaint
&
paint
)
override
;
void
drawOval
(
const
SkRect
&
oval
const
SkPaint
&
paint
)
override
;
void
drawRRect
(
const
SkRRect
&
rr
const
SkPaint
&
paint
)
override
;
void
drawPath
(
const
SkPath
&
origpath
const
SkPaint
&
paint
bool
pathIsMutable
)
override
;
void
drawImageRect
(
const
SkImage
*
const
SkRect
*
src
const
SkRect
&
dst
const
SkSamplingOptions
&
const
SkPaint
&
SkCanvas
:
:
SrcRectConstraint
)
override
;
void
drawVertices
(
const
SkVertices
*
sk_sp
<
SkBlender
>
const
SkPaint
&
bool
)
override
;
void
drawMesh
(
const
SkMesh
&
sk_sp
<
SkBlender
>
const
SkPaint
&
)
override
;
void
drawAnnotation
(
const
SkRect
&
const
char
key
[
]
SkData
*
value
)
override
;
void
drawDevice
(
SkDevice
*
const
SkSamplingOptions
&
const
SkPaint
&
)
override
;
void
drawSpecial
(
SkSpecialImage
*
const
SkMatrix
&
const
SkSamplingOptions
&
const
SkPaint
&
SkCanvas
:
:
SrcRectConstraint
)
override
;
sk_sp
<
SkSurface
>
makeSurface
(
const
SkImageInfo
&
const
SkSurfaceProps
&
)
override
;
sk_sp
<
SkDevice
>
createDevice
(
const
CreateInfo
&
const
SkPaint
*
)
override
;
void
drawSprite
(
const
SkBitmap
&
bitmap
int
x
int
y
const
SkPaint
&
paint
)
;
std
:
:
unique_ptr
<
SkPDFDict
>
makeResourceDict
(
)
;
std
:
:
unique_ptr
<
SkStreamAsset
>
content
(
)
;
const
SkMatrix
&
initialTransform
(
)
const
{
return
fInitialTransform
;
}
protected
:
sk_sp
<
SkSpecialImage
>
makeSpecial
(
const
SkBitmap
&
)
override
;
sk_sp
<
SkSpecialImage
>
makeSpecial
(
const
SkImage
*
)
override
;
private
:
friend
class
ScopedContentEntry
;
SkMatrix
fInitialTransform
;
skia_private
:
:
THashSet
<
SkPDFIndirectReference
>
fGraphicStateResources
;
skia_private
:
:
THashSet
<
SkPDFIndirectReference
>
fXObjectResources
;
skia_private
:
:
THashSet
<
SkPDFIndirectReference
>
fShaderResources
;
skia_private
:
:
THashSet
<
SkPDFIndirectReference
>
fFontResources
;
class
MarkedContentManager
{
public
:
MarkedContentManager
(
SkPDFDocument
*
document
SkDynamicMemoryWStream
*
out
)
;
~
MarkedContentManager
(
)
;
void
setNextMarksElemId
(
int
nextMarksElemId
)
;
int
elemId
(
)
const
;
void
beginMark
(
)
;
bool
hasActiveMark
(
)
const
;
void
accumulate
(
const
SkPoint
&
p
)
;
bool
madeMarks
(
)
const
{
return
fMadeMarks
;
}
private
:
SkPDFDocument
*
fDoc
;
SkDynamicMemoryWStream
*
fOut
;
SkPDFStructTree
:
:
Mark
fCurrentlyActiveMark
;
int
fNextMarksElemId
;
bool
fMadeMarks
;
}
fMarkManager
;
SkDynamicMemoryWStream
fContent
;
SkDynamicMemoryWStream
fContentBuffer
;
bool
fNeedsExtraSave
=
false
;
SkPDFGraphicStackState
fActiveStackState
;
SkPDFDocument
*
fDocument
;
void
onDrawGlyphRunList
(
SkCanvas
*
const
sktext
:
:
GlyphRunList
&
const
SkPaint
&
paint
)
override
;
SkPDFIndirectReference
makeFormXObjectFromDevice
(
bool
alpha
=
false
)
;
SkPDFIndirectReference
makeFormXObjectFromDevice
(
SkIRect
bbox
bool
alpha
=
false
)
;
void
drawFormXObjectWithMask
(
SkPDFIndirectReference
xObject
SkPDFIndirectReference
sMask
SkBlendMode
bool
invertClip
)
;
SkDynamicMemoryWStream
*
setUpContentEntry
(
const
SkClipStack
*
clipStack
const
SkMatrix
&
matrix
const
SkPaint
&
paint
SkScalar
SkPDFIndirectReference
*
dst
)
;
void
finishContentEntry
(
const
SkClipStack
*
SkBlendMode
SkPDFIndirectReference
SkPath
*
)
;
bool
isContentEmpty
(
)
;
void
internalDrawGlyphRun
(
const
sktext
:
:
GlyphRun
&
glyphRun
SkPoint
offset
const
SkPaint
&
runPaint
)
;
void
drawGlyphRunAsPath
(
const
sktext
:
:
GlyphRun
&
glyphRun
SkPoint
offset
const
SkPaint
&
runPaint
)
;
void
internalDrawImageRect
(
SkKeyedImage
const
SkRect
*
src
const
SkRect
&
dst
const
SkSamplingOptions
&
const
SkPaint
&
const
SkMatrix
&
canvasTransformationMatrix
)
;
void
internalDrawPath
(
const
SkClipStack
&
const
SkMatrix
&
const
SkPath
&
const
SkPaint
&
bool
pathIsMutable
)
;
void
internalDrawPathWithFilter
(
const
SkClipStack
&
clipStack
const
SkMatrix
&
ctm
const
SkPath
&
origPath
const
SkPaint
&
paint
)
;
bool
handleInversePath
(
const
SkPath
&
origPath
const
SkPaint
&
paint
bool
pathIsMutable
)
;
void
clearMaskOnGraphicState
(
SkDynamicMemoryWStream
*
)
;
void
setGraphicState
(
SkPDFIndirectReference
gs
SkDynamicMemoryWStream
*
)
;
void
drawFormXObject
(
SkPDFIndirectReference
xObject
SkDynamicMemoryWStream
*
SkPath
*
shape
)
;
bool
hasEmptyClip
(
)
const
{
return
this
-
>
cs
(
)
.
isEmpty
(
this
-
>
bounds
(
)
)
;
}
void
reset
(
)
;
}
;
#
endif
