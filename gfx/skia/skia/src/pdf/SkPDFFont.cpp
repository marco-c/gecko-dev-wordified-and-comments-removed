#
include
"
include
/
core
/
SkBitmap
.
h
"
#
include
"
include
/
core
/
SkData
.
h
"
#
include
"
include
/
core
/
SkFont
.
h
"
#
include
"
include
/
core
/
SkFontMetrics
.
h
"
#
include
"
include
/
core
/
SkFontTypes
.
h
"
#
include
"
include
/
core
/
SkImage
.
h
"
#
include
"
include
/
core
/
SkImageInfo
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkPaint
.
h
"
#
include
"
include
/
core
/
SkPath
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkStream
.
h
"
#
include
"
include
/
core
/
SkString
.
h
"
#
include
"
include
/
core
/
SkSurfaceProps
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
docs
/
SkPDFDocument
.
h
"
#
include
"
include
/
private
/
SkBitmaskEnum
.
h
"
#
include
"
include
/
private
/
SkTHash
.
h
"
#
include
"
include
/
private
/
SkTo
.
h
"
#
include
"
src
/
core
/
SkGlyph
.
h
"
#
include
"
src
/
core
/
SkImagePriv
.
h
"
#
include
"
src
/
core
/
SkMakeUnique
.
h
"
#
include
"
src
/
core
/
SkMask
.
h
"
#
include
"
src
/
core
/
SkScalerContext
.
h
"
#
include
"
src
/
core
/
SkStrike
.
h
"
#
include
"
src
/
core
/
SkStrikeSpec
.
h
"
#
include
"
src
/
pdf
/
SkPDFBitmap
.
h
"
#
include
"
src
/
pdf
/
SkPDFDocumentPriv
.
h
"
#
include
"
src
/
pdf
/
SkPDFFont
.
h
"
#
include
"
src
/
pdf
/
SkPDFMakeCIDGlyphWidthsArray
.
h
"
#
include
"
src
/
pdf
/
SkPDFMakeToUnicodeCmap
.
h
"
#
include
"
src
/
pdf
/
SkPDFSubsetFont
.
h
"
#
include
"
src
/
pdf
/
SkPDFType1Font
.
h
"
#
include
"
src
/
pdf
/
SkPDFUtils
.
h
"
#
include
"
src
/
utils
/
SkUTF
.
h
"
#
include
<
limits
.
h
>
#
include
<
initializer_list
>
#
include
<
memory
>
#
include
<
utility
>
void
SkPDFFont
:
:
GetType1GlyphNames
(
const
SkTypeface
&
face
SkString
*
dst
)
{
face
.
getPostScriptGlyphNames
(
dst
)
;
}
namespace
{
static
const
int32_t
kPdfSymbolic
=
4
;
inline
SkScalar
from_font_units
(
SkScalar
scaled
uint16_t
emSize
)
{
return
emSize
=
=
1000
?
scaled
:
scaled
*
1000
/
emSize
;
}
inline
SkScalar
scaleFromFontUnits
(
int16_t
val
uint16_t
emSize
)
{
return
from_font_units
(
SkIntToScalar
(
val
)
emSize
)
;
}
void
setGlyphWidthAndBoundingBox
(
SkScalar
width
SkIRect
box
SkDynamicMemoryWStream
*
content
)
{
SkPDFUtils
:
:
AppendScalar
(
width
content
)
;
content
-
>
writeText
(
"
0
"
)
;
content
-
>
writeDecAsText
(
box
.
fLeft
)
;
content
-
>
writeText
(
"
"
)
;
content
-
>
writeDecAsText
(
box
.
fTop
)
;
content
-
>
writeText
(
"
"
)
;
content
-
>
writeDecAsText
(
box
.
fRight
)
;
content
-
>
writeText
(
"
"
)
;
content
-
>
writeDecAsText
(
box
.
fBottom
)
;
content
-
>
writeText
(
"
d1
\
n
"
)
;
}
}
SkPDFFont
:
:
~
SkPDFFont
(
)
=
default
;
SkPDFFont
:
:
SkPDFFont
(
SkPDFFont
&
&
)
=
default
;
SkPDFFont
&
SkPDFFont
:
:
operator
=
(
SkPDFFont
&
&
)
=
default
;
static
bool
can_embed
(
const
SkAdvancedTypefaceMetrics
&
metrics
)
{
return
!
SkToBool
(
metrics
.
fFlags
&
SkAdvancedTypefaceMetrics
:
:
kNotEmbeddable_FontFlag
)
;
}
const
SkAdvancedTypefaceMetrics
*
SkPDFFont
:
:
GetMetrics
(
const
SkTypeface
*
typeface
SkPDFDocument
*
canon
)
{
SkASSERT
(
typeface
)
;
SkFontID
id
=
typeface
-
>
uniqueID
(
)
;
if
(
std
:
:
unique_ptr
<
SkAdvancedTypefaceMetrics
>
*
ptr
=
canon
-
>
fTypefaceMetrics
.
find
(
id
)
)
{
return
ptr
-
>
get
(
)
;
}
int
count
=
typeface
-
>
countGlyphs
(
)
;
if
(
count
<
=
0
|
|
count
>
1
+
SkTo
<
int
>
(
UINT16_MAX
)
)
{
canon
-
>
fTypefaceMetrics
.
set
(
id
nullptr
)
;
return
nullptr
;
}
std
:
:
unique_ptr
<
SkAdvancedTypefaceMetrics
>
metrics
=
typeface
-
>
getAdvancedMetrics
(
)
;
if
(
!
metrics
)
{
metrics
=
skstd
:
:
make_unique
<
SkAdvancedTypefaceMetrics
>
(
)
;
}
if
(
0
=
=
metrics
-
>
fStemV
|
|
0
=
=
metrics
-
>
fCapHeight
)
{
SkFont
font
;
font
.
setHinting
(
SkFontHinting
:
:
kNone
)
;
font
.
setTypeface
(
sk_ref_sp
(
typeface
)
)
;
font
.
setSize
(
1000
)
;
if
(
0
=
=
metrics
-
>
fStemV
)
{
int16_t
stemV
=
SHRT_MAX
;
for
(
char
c
:
{
'
i
'
'
I
'
'
!
'
'
1
'
}
)
{
uint16_t
g
=
font
.
unicharToGlyph
(
c
)
;
SkRect
bounds
;
font
.
getBounds
(
&
g
1
&
bounds
nullptr
)
;
stemV
=
SkTMin
(
stemV
SkToS16
(
SkScalarRoundToInt
(
bounds
.
width
(
)
)
)
)
;
}
metrics
-
>
fStemV
=
stemV
;
}
if
(
0
=
=
metrics
-
>
fCapHeight
)
{
SkScalar
capHeight
=
0
;
for
(
char
c
:
{
'
M
'
'
X
'
}
)
{
uint16_t
g
=
font
.
unicharToGlyph
(
c
)
;
SkRect
bounds
;
font
.
getBounds
(
&
g
1
&
bounds
nullptr
)
;
capHeight
+
=
bounds
.
height
(
)
;
}
metrics
-
>
fCapHeight
=
SkToS16
(
SkScalarRoundToInt
(
capHeight
/
2
)
)
;
}
}
return
canon
-
>
fTypefaceMetrics
.
set
(
id
std
:
:
move
(
metrics
)
)
-
>
get
(
)
;
}
const
std
:
:
vector
<
SkUnichar
>
&
SkPDFFont
:
:
GetUnicodeMap
(
const
SkTypeface
*
typeface
SkPDFDocument
*
canon
)
{
SkASSERT
(
typeface
)
;
SkASSERT
(
canon
)
;
SkFontID
id
=
typeface
-
>
uniqueID
(
)
;
if
(
std
:
:
vector
<
SkUnichar
>
*
ptr
=
canon
-
>
fToUnicodeMap
.
find
(
id
)
)
{
return
*
ptr
;
}
std
:
:
vector
<
SkUnichar
>
buffer
(
typeface
-
>
countGlyphs
(
)
)
;
typeface
-
>
getGlyphToUnicodeMap
(
buffer
.
data
(
)
)
;
return
*
canon
-
>
fToUnicodeMap
.
set
(
id
std
:
:
move
(
buffer
)
)
;
}
SkAdvancedTypefaceMetrics
:
:
FontType
SkPDFFont
:
:
FontType
(
const
SkAdvancedTypefaceMetrics
&
metrics
)
{
if
(
SkToBool
(
metrics
.
fFlags
&
SkAdvancedTypefaceMetrics
:
:
kMultiMaster_FontFlag
)
|
|
SkToBool
(
metrics
.
fFlags
&
SkAdvancedTypefaceMetrics
:
:
kNotEmbeddable_FontFlag
)
)
{
return
SkAdvancedTypefaceMetrics
:
:
kOther_Font
;
}
return
metrics
.
fType
;
}
static
SkGlyphID
first_nonzero_glyph_for_single_byte_encoding
(
SkGlyphID
gid
)
{
return
gid
!
=
0
?
gid
-
(
gid
-
1
)
%
255
:
1
;
}
SkPDFFont
*
SkPDFFont
:
:
GetFontResource
(
SkPDFDocument
*
doc
const
SkGlyph
*
glyph
SkTypeface
*
face
)
{
SkASSERT
(
doc
)
;
SkASSERT
(
face
)
;
const
SkAdvancedTypefaceMetrics
*
fontMetrics
=
SkPDFFont
:
:
GetMetrics
(
face
doc
)
;
SkASSERT
(
fontMetrics
)
;
const
SkAdvancedTypefaceMetrics
&
metrics
=
*
fontMetrics
;
SkAdvancedTypefaceMetrics
:
:
FontType
type
=
SkPDFFont
:
:
FontType
(
metrics
)
;
if
(
!
(
glyph
-
>
isEmpty
(
)
|
|
glyph
-
>
path
(
)
)
)
{
type
=
SkAdvancedTypefaceMetrics
:
:
kOther_Font
;
}
bool
multibyte
=
SkPDFFont
:
:
IsMultiByte
(
type
)
;
SkGlyphID
subsetCode
=
multibyte
?
0
:
first_nonzero_glyph_for_single_byte_encoding
(
glyph
-
>
getGlyphID
(
)
)
;
uint64_t
fontID
=
(
static_cast
<
uint64_t
>
(
SkTypeface
:
:
UniqueID
(
face
)
)
<
<
16
)
|
subsetCode
;
if
(
SkPDFFont
*
found
=
doc
-
>
fFontMap
.
find
(
fontID
)
)
{
SkASSERT
(
multibyte
=
=
found
-
>
multiByteGlyphs
(
)
)
;
return
found
;
}
sk_sp
<
SkTypeface
>
typeface
(
sk_ref_sp
(
face
)
)
;
SkASSERT
(
typeface
)
;
SkGlyphID
lastGlyph
=
SkToU16
(
typeface
-
>
countGlyphs
(
)
-
1
)
;
SkASSERT
(
glyph
-
>
getGlyphID
(
)
<
=
lastGlyph
)
;
SkGlyphID
firstNonZeroGlyph
;
if
(
multibyte
)
{
firstNonZeroGlyph
=
1
;
}
else
{
firstNonZeroGlyph
=
subsetCode
;
lastGlyph
=
SkToU16
(
SkTMin
<
int
>
(
(
int
)
lastGlyph
254
+
(
int
)
subsetCode
)
)
;
}
auto
ref
=
doc
-
>
reserveRef
(
)
;
return
doc
-
>
fFontMap
.
set
(
fontID
SkPDFFont
(
std
:
:
move
(
typeface
)
firstNonZeroGlyph
lastGlyph
type
ref
)
)
;
}
SkPDFFont
:
:
SkPDFFont
(
sk_sp
<
SkTypeface
>
typeface
SkGlyphID
firstGlyphID
SkGlyphID
lastGlyphID
SkAdvancedTypefaceMetrics
:
:
FontType
fontType
SkPDFIndirectReference
indirectReference
)
:
fTypeface
(
std
:
:
move
(
typeface
)
)
fGlyphUsage
(
firstGlyphID
lastGlyphID
)
fIndirectReference
(
indirectReference
)
fFontType
(
fontType
)
{
this
-
>
noteGlyphUsage
(
0
)
;
}
void
SkPDFFont
:
:
PopulateCommonFontDescriptor
(
SkPDFDict
*
descriptor
const
SkAdvancedTypefaceMetrics
&
metrics
uint16_t
emSize
int16_t
defaultWidth
)
{
descriptor
-
>
insertName
(
"
FontName
"
metrics
.
fPostScriptName
)
;
descriptor
-
>
insertInt
(
"
Flags
"
(
size_t
)
(
metrics
.
fStyle
|
kPdfSymbolic
)
)
;
descriptor
-
>
insertScalar
(
"
Ascent
"
scaleFromFontUnits
(
metrics
.
fAscent
emSize
)
)
;
descriptor
-
>
insertScalar
(
"
Descent
"
scaleFromFontUnits
(
metrics
.
fDescent
emSize
)
)
;
descriptor
-
>
insertScalar
(
"
StemV
"
scaleFromFontUnits
(
metrics
.
fStemV
emSize
)
)
;
descriptor
-
>
insertScalar
(
"
CapHeight
"
scaleFromFontUnits
(
metrics
.
fCapHeight
emSize
)
)
;
descriptor
-
>
insertInt
(
"
ItalicAngle
"
metrics
.
fItalicAngle
)
;
descriptor
-
>
insertObject
(
"
FontBBox
"
SkPDFMakeArray
(
scaleFromFontUnits
(
metrics
.
fBBox
.
left
(
)
emSize
)
scaleFromFontUnits
(
metrics
.
fBBox
.
bottom
(
)
emSize
)
scaleFromFontUnits
(
metrics
.
fBBox
.
right
(
)
emSize
)
scaleFromFontUnits
(
metrics
.
fBBox
.
top
(
)
emSize
)
)
)
;
if
(
defaultWidth
>
0
)
{
descriptor
-
>
insertScalar
(
"
MissingWidth
"
scaleFromFontUnits
(
defaultWidth
emSize
)
)
;
}
}
static
sk_sp
<
SkData
>
stream_to_data
(
std
:
:
unique_ptr
<
SkStreamAsset
>
stream
)
{
SkASSERT
(
stream
)
;
(
void
)
stream
-
>
rewind
(
)
;
SkASSERT
(
stream
-
>
hasLength
(
)
)
;
size_t
size
=
stream
-
>
getLength
(
)
;
if
(
const
void
*
base
=
stream
-
>
getMemoryBase
(
)
)
{
SkData
:
:
ReleaseProc
proc
=
[
]
(
const
void
*
void
*
ctx
)
{
delete
(
SkStreamAsset
*
)
ctx
;
}
;
return
SkData
:
:
MakeWithProc
(
base
size
proc
stream
.
release
(
)
)
;
}
return
SkData
:
:
MakeFromStream
(
stream
.
get
(
)
size
)
;
}
static
void
emit_subset_type0
(
const
SkPDFFont
&
font
SkPDFDocument
*
doc
)
{
const
SkAdvancedTypefaceMetrics
*
metricsPtr
=
SkPDFFont
:
:
GetMetrics
(
font
.
typeface
(
)
doc
)
;
SkASSERT
(
metricsPtr
)
;
if
(
!
metricsPtr
)
{
return
;
}
const
SkAdvancedTypefaceMetrics
&
metrics
=
*
metricsPtr
;
SkASSERT
(
can_embed
(
metrics
)
)
;
SkAdvancedTypefaceMetrics
:
:
FontType
type
=
font
.
getType
(
)
;
SkTypeface
*
face
=
font
.
typeface
(
)
;
SkASSERT
(
face
)
;
auto
descriptor
=
SkPDFMakeDict
(
"
FontDescriptor
"
)
;
uint16_t
emSize
=
SkToU16
(
font
.
typeface
(
)
-
>
getUnitsPerEm
(
)
)
;
SkPDFFont
:
:
PopulateCommonFontDescriptor
(
descriptor
.
get
(
)
metrics
emSize
0
)
;
int
ttcIndex
;
std
:
:
unique_ptr
<
SkStreamAsset
>
fontAsset
=
face
-
>
openStream
(
&
ttcIndex
)
;
size_t
fontSize
=
fontAsset
?
fontAsset
-
>
getLength
(
)
:
0
;
if
(
0
=
=
fontSize
)
{
SkDebugf
(
"
Error
:
(
SkTypeface
)
(
%
p
)
:
:
openStream
(
)
returned
"
"
empty
stream
(
%
p
)
when
identified
as
kType1CID_Font
"
"
or
kTrueType_Font
.
\
n
"
face
fontAsset
.
get
(
)
)
;
}
else
{
switch
(
type
)
{
case
SkAdvancedTypefaceMetrics
:
:
kTrueType_Font
:
{
if
(
!
SkToBool
(
metrics
.
fFlags
&
SkAdvancedTypefaceMetrics
:
:
kNotSubsettable_FontFlag
)
)
{
SkASSERT
(
font
.
firstGlyphID
(
)
=
=
1
)
;
sk_sp
<
SkData
>
subsetFontData
=
SkPDFSubsetFont
(
stream_to_data
(
std
:
:
move
(
fontAsset
)
)
font
.
glyphUsage
(
)
doc
-
>
metadata
(
)
.
fSubsetter
metrics
.
fFontName
.
c_str
(
)
ttcIndex
)
;
if
(
subsetFontData
)
{
std
:
:
unique_ptr
<
SkPDFDict
>
tmp
=
SkPDFMakeDict
(
)
;
tmp
-
>
insertInt
(
"
Length1
"
SkToInt
(
subsetFontData
-
>
size
(
)
)
)
;
descriptor
-
>
insertRef
(
"
FontFile2
"
SkPDFStreamOut
(
std
:
:
move
(
tmp
)
SkMemoryStream
:
:
Make
(
std
:
:
move
(
subsetFontData
)
)
doc
true
)
)
;
break
;
}
fontAsset
=
face
-
>
openStream
(
&
ttcIndex
)
;
SkASSERT
(
fontAsset
)
;
SkASSERT
(
fontAsset
-
>
getLength
(
)
=
=
fontSize
)
;
if
(
!
fontAsset
|
|
fontAsset
-
>
getLength
(
)
=
=
0
)
{
break
;
}
}
std
:
:
unique_ptr
<
SkPDFDict
>
tmp
=
SkPDFMakeDict
(
)
;
tmp
-
>
insertInt
(
"
Length1
"
fontSize
)
;
descriptor
-
>
insertRef
(
"
FontFile2
"
SkPDFStreamOut
(
std
:
:
move
(
tmp
)
std
:
:
move
(
fontAsset
)
doc
true
)
)
;
break
;
}
case
SkAdvancedTypefaceMetrics
:
:
kType1CID_Font
:
{
std
:
:
unique_ptr
<
SkPDFDict
>
tmp
=
SkPDFMakeDict
(
)
;
tmp
-
>
insertName
(
"
Subtype
"
"
CIDFontType0C
"
)
;
descriptor
-
>
insertRef
(
"
FontFile3
"
SkPDFStreamOut
(
std
:
:
move
(
tmp
)
std
:
:
move
(
fontAsset
)
doc
true
)
)
;
break
;
}
default
:
SkASSERT
(
false
)
;
}
}
auto
newCIDFont
=
SkPDFMakeDict
(
"
Font
"
)
;
newCIDFont
-
>
insertRef
(
"
FontDescriptor
"
doc
-
>
emit
(
*
descriptor
)
)
;
newCIDFont
-
>
insertName
(
"
BaseFont
"
metrics
.
fPostScriptName
)
;
switch
(
type
)
{
case
SkAdvancedTypefaceMetrics
:
:
kType1CID_Font
:
newCIDFont
-
>
insertName
(
"
Subtype
"
"
CIDFontType0
"
)
;
break
;
case
SkAdvancedTypefaceMetrics
:
:
kTrueType_Font
:
newCIDFont
-
>
insertName
(
"
Subtype
"
"
CIDFontType2
"
)
;
newCIDFont
-
>
insertName
(
"
CIDToGIDMap
"
"
Identity
"
)
;
break
;
default
:
SkASSERT
(
false
)
;
}
auto
sysInfo
=
SkPDFMakeDict
(
)
;
sysInfo
-
>
insertString
(
"
Registry
"
"
Adobe
"
)
;
sysInfo
-
>
insertString
(
"
Ordering
"
"
Identity
"
)
;
sysInfo
-
>
insertInt
(
"
Supplement
"
0
)
;
newCIDFont
-
>
insertObject
(
"
CIDSystemInfo
"
std
:
:
move
(
sysInfo
)
)
;
SkScalar
defaultWidth
=
0
;
{
std
:
:
unique_ptr
<
SkPDFArray
>
widths
=
SkPDFMakeCIDGlyphWidthsArray
(
*
face
font
.
glyphUsage
(
)
&
defaultWidth
)
;
if
(
widths
&
&
widths
-
>
size
(
)
>
0
)
{
newCIDFont
-
>
insertObject
(
"
W
"
std
:
:
move
(
widths
)
)
;
}
newCIDFont
-
>
insertScalar
(
"
DW
"
defaultWidth
)
;
}
SkPDFDict
fontDict
(
"
Font
"
)
;
fontDict
.
insertName
(
"
Subtype
"
"
Type0
"
)
;
fontDict
.
insertName
(
"
BaseFont
"
metrics
.
fPostScriptName
)
;
fontDict
.
insertName
(
"
Encoding
"
"
Identity
-
H
"
)
;
auto
descendantFonts
=
SkPDFMakeArray
(
)
;
descendantFonts
-
>
appendRef
(
doc
-
>
emit
(
*
newCIDFont
)
)
;
fontDict
.
insertObject
(
"
DescendantFonts
"
std
:
:
move
(
descendantFonts
)
)
;
const
std
:
:
vector
<
SkUnichar
>
&
glyphToUnicode
=
SkPDFFont
:
:
GetUnicodeMap
(
font
.
typeface
(
)
doc
)
;
SkASSERT
(
SkToSizeT
(
font
.
typeface
(
)
-
>
countGlyphs
(
)
)
=
=
glyphToUnicode
.
size
(
)
)
;
std
:
:
unique_ptr
<
SkStreamAsset
>
toUnicode
=
SkPDFMakeToUnicodeCmap
(
glyphToUnicode
.
data
(
)
&
font
.
glyphUsage
(
)
font
.
multiByteGlyphs
(
)
font
.
firstGlyphID
(
)
font
.
lastGlyphID
(
)
)
;
fontDict
.
insertRef
(
"
ToUnicode
"
SkPDFStreamOut
(
nullptr
std
:
:
move
(
toUnicode
)
doc
)
)
;
doc
-
>
emit
(
fontDict
font
.
indirectReference
(
)
)
;
}
namespace
{
struct
SingleByteGlyphIdIterator
{
SingleByteGlyphIdIterator
(
SkGlyphID
first
SkGlyphID
last
)
:
fFirst
(
first
)
fLast
(
last
)
{
SkASSERT
(
fFirst
>
0
)
;
SkASSERT
(
fLast
>
=
first
)
;
}
struct
Iter
{
void
operator
+
+
(
)
{
fCurrent
=
(
0
=
=
fCurrent
)
?
fFirst
:
fCurrent
+
1
;
}
SkGlyphID
operator
*
(
)
const
{
return
(
SkGlyphID
)
fCurrent
;
}
bool
operator
!
=
(
const
Iter
&
rhs
)
const
{
return
fCurrent
!
=
rhs
.
fCurrent
;
}
Iter
(
SkGlyphID
f
int
c
)
:
fFirst
(
f
)
fCurrent
(
c
)
{
}
private
:
const
SkGlyphID
fFirst
;
int
fCurrent
;
}
;
Iter
begin
(
)
const
{
return
Iter
(
fFirst
0
)
;
}
Iter
end
(
)
const
{
return
Iter
(
fFirst
(
int
)
fLast
+
1
)
;
}
private
:
const
SkGlyphID
fFirst
;
const
SkGlyphID
fLast
;
}
;
}
struct
ImageAndOffset
{
sk_sp
<
SkImage
>
fImage
;
SkIPoint
fOffset
;
}
;
static
ImageAndOffset
to_image
(
SkGlyphID
gid
SkStrike
*
cache
)
{
(
void
)
cache
-
>
prepareImage
(
cache
-
>
glyph
(
gid
)
)
;
SkMask
mask
=
cache
-
>
glyph
(
gid
)
-
>
mask
(
)
;
if
(
!
mask
.
fImage
)
{
return
{
nullptr
{
0
0
}
}
;
}
SkIRect
bounds
=
mask
.
fBounds
;
SkBitmap
bm
;
switch
(
mask
.
fFormat
)
{
case
SkMask
:
:
kBW_Format
:
bm
.
allocPixels
(
SkImageInfo
:
:
MakeA8
(
bounds
.
width
(
)
bounds
.
height
(
)
)
)
;
for
(
int
y
=
0
;
y
<
bm
.
height
(
)
;
+
+
y
)
{
for
(
int
x8
=
0
;
x8
<
bm
.
width
(
)
;
x8
+
=
8
)
{
uint8_t
v
=
*
mask
.
getAddr1
(
x8
+
bounds
.
x
(
)
y
+
bounds
.
y
(
)
)
;
int
e
=
SkTMin
(
x8
+
8
bm
.
width
(
)
)
;
for
(
int
x
=
x8
;
x
<
e
;
+
+
x
)
{
*
bm
.
getAddr8
(
x
y
)
=
(
v
>
>
(
x
&
0x7
)
)
&
0x1
?
0xFF
:
0x00
;
}
}
}
bm
.
setImmutable
(
)
;
return
{
SkImage
:
:
MakeFromBitmap
(
bm
)
{
bounds
.
x
(
)
bounds
.
y
(
)
}
}
;
case
SkMask
:
:
kA8_Format
:
bm
.
installPixels
(
SkImageInfo
:
:
MakeA8
(
bounds
.
width
(
)
bounds
.
height
(
)
)
mask
.
fImage
mask
.
fRowBytes
)
;
return
{
SkMakeImageFromRasterBitmap
(
bm
kAlways_SkCopyPixelsMode
)
{
bounds
.
x
(
)
bounds
.
y
(
)
}
}
;
case
SkMask
:
:
kARGB32_Format
:
bm
.
installPixels
(
SkImageInfo
:
:
MakeN32Premul
(
bounds
.
width
(
)
bounds
.
height
(
)
)
mask
.
fImage
mask
.
fRowBytes
)
;
return
{
SkMakeImageFromRasterBitmap
(
bm
kAlways_SkCopyPixelsMode
)
{
bounds
.
x
(
)
bounds
.
y
(
)
}
}
;
case
SkMask
:
:
k3D_Format
:
case
SkMask
:
:
kLCD16_Format
:
default
:
SkASSERT
(
false
)
;
return
{
nullptr
{
0
0
}
}
;
}
}
static
SkPDFIndirectReference
type3_descriptor
(
SkPDFDocument
*
doc
const
SkTypeface
*
typeface
SkStrike
*
cache
)
{
if
(
SkPDFIndirectReference
*
ptr
=
doc
-
>
fType3FontDescriptors
.
find
(
typeface
-
>
uniqueID
(
)
)
)
{
return
*
ptr
;
}
SkPDFDict
descriptor
(
"
FontDescriptor
"
)
;
int32_t
fontDescriptorFlags
=
kPdfSymbolic
;
if
(
const
SkAdvancedTypefaceMetrics
*
metrics
=
SkPDFFont
:
:
GetMetrics
(
typeface
doc
)
)
{
descriptor
.
insertName
(
"
FontName
"
metrics
-
>
fPostScriptName
)
;
descriptor
.
insertInt
(
"
ItalicAngle
"
metrics
-
>
fItalicAngle
)
;
fontDescriptorFlags
|
=
(
int32_t
)
metrics
-
>
fStyle
;
if
(
metrics
-
>
fCapHeight
!
=
0
)
{
descriptor
.
insertInt
(
"
CapHeight
"
metrics
-
>
fCapHeight
)
;
}
if
(
metrics
-
>
fStemV
!
=
0
)
{
descriptor
.
insertInt
(
"
StemV
"
metrics
-
>
fStemV
)
;
}
SkScalar
xHeight
=
cache
-
>
getFontMetrics
(
)
.
fXHeight
;
if
(
xHeight
!
=
0
)
{
descriptor
.
insertScalar
(
"
XHeight
"
xHeight
)
;
}
}
descriptor
.
insertInt
(
"
Flags
"
fontDescriptorFlags
)
;
SkPDFIndirectReference
ref
=
doc
-
>
emit
(
descriptor
)
;
doc
-
>
fType3FontDescriptors
.
set
(
typeface
-
>
uniqueID
(
)
ref
)
;
return
ref
;
}
#
ifdef
SK_PDF_BITMAP_GLYPH_RASTER_SIZE
static
constexpr
float
kBitmapFontSize
=
SK_PDF_BITMAP_GLYPH_RASTER_SIZE
;
#
else
static
constexpr
float
kBitmapFontSize
=
64
;
#
endif
SkStrikeSpec
make_small_strike
(
const
SkTypeface
&
typeface
)
{
SkFont
font
(
sk_ref_sp
(
&
typeface
)
kBitmapFontSize
)
;
font
.
setHinting
(
SkFontHinting
:
:
kNone
)
;
font
.
setEdging
(
SkFont
:
:
Edging
:
:
kAlias
)
;
return
SkStrikeSpec
:
:
MakeMask
(
font
SkPaint
(
)
SkSurfaceProps
(
0
kUnknown_SkPixelGeometry
)
kFakeGammaAndBoostContrast
SkMatrix
:
:
I
(
)
)
;
}
static
void
emit_subset_type3
(
const
SkPDFFont
&
pdfFont
SkPDFDocument
*
doc
)
{
SkTypeface
*
typeface
=
pdfFont
.
typeface
(
)
;
SkGlyphID
firstGlyphID
=
pdfFont
.
firstGlyphID
(
)
;
SkGlyphID
lastGlyphID
=
pdfFont
.
lastGlyphID
(
)
;
const
SkPDFGlyphUse
&
subset
=
pdfFont
.
glyphUsage
(
)
;
SkASSERT
(
lastGlyphID
>
=
firstGlyphID
)
;
while
(
lastGlyphID
>
firstGlyphID
&
&
!
subset
.
has
(
lastGlyphID
)
)
{
-
-
lastGlyphID
;
}
int
unitsPerEm
;
SkStrikeSpec
strikeSpec
=
SkStrikeSpec
:
:
MakePDFVector
(
*
typeface
&
unitsPerEm
)
;
auto
cache
=
strikeSpec
.
findOrCreateExclusiveStrike
(
)
;
SkASSERT
(
cache
)
;
SkScalar
emSize
=
(
SkScalar
)
unitsPerEm
;
SkStrikeSpec
strikeSpecSmall
=
kBitmapFontSize
>
0
?
make_small_strike
(
*
typeface
)
:
strikeSpec
;
auto
smallCache
=
strikeSpecSmall
.
findOrCreateExclusiveStrike
(
)
;
SkASSERT
(
smallCache
)
;
float
bitmapScale
=
kBitmapFontSize
>
0
?
emSize
/
kBitmapFontSize
:
1
.
0f
;
SkPDFDict
font
(
"
Font
"
)
;
font
.
insertName
(
"
Subtype
"
"
Type3
"
)
;
SkMatrix
fontMatrix
;
fontMatrix
.
setScale
(
SkScalarInvert
(
emSize
)
-
SkScalarInvert
(
emSize
)
)
;
font
.
insertObject
(
"
FontMatrix
"
SkPDFUtils
:
:
MatrixToArray
(
fontMatrix
)
)
;
auto
charProcs
=
SkPDFMakeDict
(
)
;
auto
encoding
=
SkPDFMakeDict
(
"
Encoding
"
)
;
auto
encDiffs
=
SkPDFMakeArray
(
)
;
SkASSERT
(
firstGlyphID
>
0
)
;
SkASSERT
(
lastGlyphID
>
=
firstGlyphID
)
;
int
glyphCount
=
lastGlyphID
-
firstGlyphID
+
2
;
encDiffs
-
>
reserve
(
glyphCount
+
1
)
;
encDiffs
-
>
appendInt
(
0
)
;
auto
widthArray
=
SkPDFMakeArray
(
)
;
widthArray
-
>
reserve
(
glyphCount
)
;
SkIRect
bbox
=
SkIRect
:
:
MakeEmpty
(
)
;
std
:
:
vector
<
std
:
:
pair
<
SkGlyphID
SkPDFIndirectReference
>
>
imageGlyphs
;
for
(
SkGlyphID
gID
:
SingleByteGlyphIdIterator
(
firstGlyphID
lastGlyphID
)
)
{
bool
skipGlyph
=
gID
!
=
0
&
&
!
subset
.
has
(
gID
)
;
SkString
characterName
;
SkScalar
advance
=
0
.
0f
;
SkIRect
glyphBBox
;
if
(
skipGlyph
)
{
characterName
.
set
(
"
g0
"
)
;
}
else
{
characterName
.
printf
(
"
g
%
X
"
gID
)
;
SkGlyph
*
glyph
=
cache
-
>
glyph
(
gID
)
;
advance
=
glyph
-
>
advanceX
(
)
;
glyphBBox
=
glyph
-
>
iRect
(
)
;
bbox
.
join
(
glyphBBox
)
;
const
SkPath
*
path
=
cache
-
>
preparePath
(
glyph
)
;
SkDynamicMemoryWStream
content
;
if
(
path
&
&
!
path
-
>
isEmpty
(
)
)
{
setGlyphWidthAndBoundingBox
(
glyph
-
>
advanceX
(
)
glyphBBox
&
content
)
;
SkPDFUtils
:
:
EmitPath
(
*
path
SkPaint
:
:
kFill_Style
&
content
)
;
SkPDFUtils
:
:
PaintPath
(
SkPaint
:
:
kFill_Style
path
-
>
getFillType
(
)
&
content
)
;
}
else
{
auto
pimg
=
to_image
(
gID
smallCache
.
get
(
)
)
;
if
(
!
pimg
.
fImage
)
{
setGlyphWidthAndBoundingBox
(
glyph
-
>
advanceX
(
)
glyphBBox
&
content
)
;
}
else
{
using
SkPDFUtils
:
:
AppendScalar
;
imageGlyphs
.
emplace_back
(
gID
SkPDFSerializeImage
(
pimg
.
fImage
.
get
(
)
doc
)
)
;
AppendScalar
(
glyph
-
>
advanceX
(
)
&
content
)
;
content
.
writeText
(
"
0
d0
\
n
"
)
;
AppendScalar
(
pimg
.
fImage
-
>
width
(
)
*
bitmapScale
&
content
)
;
content
.
writeText
(
"
0
0
"
)
;
AppendScalar
(
-
pimg
.
fImage
-
>
height
(
)
*
bitmapScale
&
content
)
;
content
.
writeText
(
"
"
)
;
AppendScalar
(
pimg
.
fOffset
.
x
(
)
*
bitmapScale
&
content
)
;
content
.
writeText
(
"
"
)
;
AppendScalar
(
(
pimg
.
fImage
-
>
height
(
)
+
pimg
.
fOffset
.
y
(
)
)
*
bitmapScale
&
content
)
;
content
.
writeText
(
"
cm
\
n
/
X
"
)
;
content
.
write
(
characterName
.
c_str
(
)
characterName
.
size
(
)
)
;
content
.
writeText
(
"
Do
\
n
"
)
;
}
}
charProcs
-
>
insertRef
(
characterName
SkPDFStreamOut
(
nullptr
content
.
detachAsStream
(
)
doc
)
)
;
}
encDiffs
-
>
appendName
(
std
:
:
move
(
characterName
)
)
;
widthArray
-
>
appendScalar
(
advance
)
;
}
if
(
!
imageGlyphs
.
empty
(
)
)
{
auto
d0
=
SkPDFMakeDict
(
)
;
for
(
const
auto
&
pair
:
imageGlyphs
)
{
d0
-
>
insertRef
(
SkStringPrintf
(
"
Xg
%
X
"
pair
.
first
)
pair
.
second
)
;
}
auto
d1
=
SkPDFMakeDict
(
)
;
d1
-
>
insertObject
(
"
XObject
"
std
:
:
move
(
d0
)
)
;
font
.
insertObject
(
"
Resources
"
std
:
:
move
(
d1
)
)
;
}
encoding
-
>
insertObject
(
"
Differences
"
std
:
:
move
(
encDiffs
)
)
;
font
.
insertInt
(
"
FirstChar
"
0
)
;
font
.
insertInt
(
"
LastChar
"
lastGlyphID
-
firstGlyphID
+
1
)
;
font
.
insertObject
(
"
FontBBox
"
SkPDFMakeArray
(
bbox
.
left
(
)
bbox
.
bottom
(
)
bbox
.
right
(
)
bbox
.
top
(
)
)
)
;
font
.
insertName
(
"
CIDToGIDMap
"
"
Identity
"
)
;
const
std
:
:
vector
<
SkUnichar
>
&
glyphToUnicode
=
SkPDFFont
:
:
GetUnicodeMap
(
typeface
doc
)
;
SkASSERT
(
glyphToUnicode
.
size
(
)
=
=
SkToSizeT
(
typeface
-
>
countGlyphs
(
)
)
)
;
auto
toUnicodeCmap
=
SkPDFMakeToUnicodeCmap
(
glyphToUnicode
.
data
(
)
&
subset
false
firstGlyphID
lastGlyphID
)
;
font
.
insertRef
(
"
ToUnicode
"
SkPDFStreamOut
(
nullptr
std
:
:
move
(
toUnicodeCmap
)
doc
)
)
;
font
.
insertRef
(
"
FontDescriptor
"
type3_descriptor
(
doc
typeface
cache
.
get
(
)
)
)
;
font
.
insertObject
(
"
Widths
"
std
:
:
move
(
widthArray
)
)
;
font
.
insertObject
(
"
Encoding
"
std
:
:
move
(
encoding
)
)
;
font
.
insertObject
(
"
CharProcs
"
std
:
:
move
(
charProcs
)
)
;
doc
-
>
emit
(
font
pdfFont
.
indirectReference
(
)
)
;
}
void
SkPDFFont
:
:
emitSubset
(
SkPDFDocument
*
doc
)
const
{
SkASSERT
(
fFontType
!
=
SkPDFFont
(
)
.
fFontType
)
;
switch
(
fFontType
)
{
case
SkAdvancedTypefaceMetrics
:
:
kType1CID_Font
:
case
SkAdvancedTypefaceMetrics
:
:
kTrueType_Font
:
return
emit_subset_type0
(
*
this
doc
)
;
#
ifndef
SK_PDF_DO_NOT_SUPPORT_TYPE_1_FONTS
case
SkAdvancedTypefaceMetrics
:
:
kType1_Font
:
return
SkPDFEmitType1Font
(
*
this
doc
)
;
#
endif
default
:
return
emit_subset_type3
(
*
this
doc
)
;
}
}
bool
SkPDFFont
:
:
CanEmbedTypeface
(
SkTypeface
*
typeface
SkPDFDocument
*
doc
)
{
const
SkAdvancedTypefaceMetrics
*
metrics
=
SkPDFFont
:
:
GetMetrics
(
typeface
doc
)
;
return
metrics
&
&
can_embed
(
*
metrics
)
;
}
