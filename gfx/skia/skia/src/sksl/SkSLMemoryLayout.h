#
ifndef
SKIASL_MEMORYLAYOUT
#
define
SKIASL_MEMORYLAYOUT
#
include
<
algorithm
>
#
include
"
src
/
sksl
/
ir
/
SkSLType
.
h
"
namespace
SkSL
{
class
MemoryLayout
{
public
:
enum
class
Standard
{
k140
k430
kMetal
kWGSLUniform_Base
kWGSLUniform_EnableF16
kWGSLStorage_Base
kWGSLStorage_EnableF16
}
;
MemoryLayout
(
Standard
std
)
:
fStd
(
std
)
{
}
bool
isWGSL_Base
(
)
const
{
return
fStd
=
=
Standard
:
:
kWGSLUniform_Base
|
|
fStd
=
=
Standard
:
:
kWGSLStorage_Base
;
}
bool
isWGSL_F16
(
)
const
{
return
fStd
=
=
Standard
:
:
kWGSLUniform_EnableF16
|
|
fStd
=
=
Standard
:
:
kWGSLStorage_EnableF16
;
}
bool
isWGSL_Uniform
(
)
const
{
return
fStd
=
=
Standard
:
:
kWGSLUniform_Base
|
|
fStd
=
=
Standard
:
:
kWGSLUniform_EnableF16
;
}
bool
isWGSL
(
)
const
{
return
fStd
=
=
Standard
:
:
kWGSLUniform_Base
|
|
fStd
=
=
Standard
:
:
kWGSLStorage_Base
|
|
fStd
=
=
Standard
:
:
kWGSLUniform_EnableF16
|
|
fStd
=
=
Standard
:
:
kWGSLStorage_EnableF16
;
}
bool
isMetal
(
)
const
{
return
fStd
=
=
Standard
:
:
kMetal
;
}
size_t
roundUpIfNeeded
(
size_t
raw
Type
:
:
TypeKind
type
)
const
{
if
(
fStd
=
=
Standard
:
:
k140
)
{
return
roundUp16
(
raw
)
;
}
if
(
this
-
>
isWGSL_Uniform
(
)
&
&
type
!
=
Type
:
:
TypeKind
:
:
kMatrix
)
{
return
roundUp16
(
raw
)
;
}
return
raw
;
}
size_t
roundUp16
(
size_t
n
)
const
{
return
(
n
+
15
)
&
~
15
;
}
size_t
alignment
(
const
Type
&
type
)
const
{
switch
(
type
.
typeKind
(
)
)
{
case
Type
:
:
TypeKind
:
:
kScalar
:
case
Type
:
:
TypeKind
:
:
kAtomic
:
return
this
-
>
size
(
type
)
;
case
Type
:
:
TypeKind
:
:
kVector
:
return
GetVectorAlignment
(
this
-
>
size
(
type
.
componentType
(
)
)
type
.
columns
(
)
)
;
case
Type
:
:
TypeKind
:
:
kMatrix
:
return
this
-
>
roundUpIfNeeded
(
GetVectorAlignment
(
this
-
>
size
(
type
.
componentType
(
)
)
type
.
rows
(
)
)
type
.
typeKind
(
)
)
;
case
Type
:
:
TypeKind
:
:
kArray
:
return
this
-
>
roundUpIfNeeded
(
this
-
>
alignment
(
type
.
componentType
(
)
)
type
.
typeKind
(
)
)
;
case
Type
:
:
TypeKind
:
:
kStruct
:
{
size_t
result
=
0
;
for
(
const
auto
&
f
:
type
.
fields
(
)
)
{
size_t
alignment
=
this
-
>
alignment
(
*
f
.
fType
)
;
if
(
alignment
>
result
)
{
result
=
alignment
;
}
}
return
this
-
>
roundUpIfNeeded
(
result
type
.
typeKind
(
)
)
;
}
default
:
SK_ABORT
(
"
cannot
determine
alignment
of
type
'
%
s
'
"
type
.
displayName
(
)
.
c_str
(
)
)
;
}
}
size_t
stride
(
const
Type
&
type
)
const
{
switch
(
type
.
typeKind
(
)
)
{
case
Type
:
:
TypeKind
:
:
kMatrix
:
return
this
-
>
alignment
(
type
)
;
case
Type
:
:
TypeKind
:
:
kArray
:
{
int
stride
=
this
-
>
size
(
type
.
componentType
(
)
)
;
if
(
stride
>
0
)
{
int
align
=
this
-
>
alignment
(
type
.
componentType
(
)
)
;
stride
+
=
align
-
1
;
stride
-
=
stride
%
align
;
stride
=
this
-
>
roundUpIfNeeded
(
stride
type
.
typeKind
(
)
)
;
}
return
stride
;
}
default
:
SK_ABORT
(
"
type
'
%
s
'
does
not
have
a
stride
"
type
.
displayName
(
)
.
c_str
(
)
)
;
}
}
size_t
size
(
const
Type
&
type
)
const
{
switch
(
type
.
typeKind
(
)
)
{
case
Type
:
:
TypeKind
:
:
kScalar
:
if
(
type
.
isBoolean
(
)
)
{
return
this
-
>
isWGSL
(
)
?
0
:
1
;
}
if
(
this
-
>
isMetal
(
)
&
&
!
type
.
highPrecision
(
)
&
&
type
.
isNumber
(
)
)
{
return
2
;
}
if
(
this
-
>
isWGSL_F16
(
)
&
&
!
type
.
highPrecision
(
)
&
&
type
.
isFloat
(
)
)
{
return
2
;
}
return
4
;
case
Type
:
:
TypeKind
:
:
kAtomic
:
return
4
;
case
Type
:
:
TypeKind
:
:
kVector
:
if
(
this
-
>
isMetal
(
)
&
&
type
.
columns
(
)
=
=
3
)
{
return
4
*
this
-
>
size
(
type
.
componentType
(
)
)
;
}
return
type
.
columns
(
)
*
this
-
>
size
(
type
.
componentType
(
)
)
;
case
Type
:
:
TypeKind
:
:
kMatrix
:
case
Type
:
:
TypeKind
:
:
kArray
:
return
type
.
isUnsizedArray
(
)
?
0
:
(
type
.
columns
(
)
*
this
-
>
stride
(
type
)
)
;
case
Type
:
:
TypeKind
:
:
kStruct
:
{
size_t
total
=
0
;
for
(
const
auto
&
f
:
type
.
fields
(
)
)
{
size_t
alignment
=
this
-
>
alignment
(
*
f
.
fType
)
;
if
(
total
%
alignment
!
=
0
)
{
total
+
=
alignment
-
total
%
alignment
;
}
SkASSERT
(
total
%
alignment
=
=
0
)
;
total
+
=
this
-
>
size
(
*
f
.
fType
)
;
}
size_t
alignment
=
this
-
>
alignment
(
type
)
;
SkASSERT
(
!
type
.
fields
(
)
.
size
(
)
|
|
(
0
=
=
alignment
%
this
-
>
alignment
(
*
type
.
fields
(
)
[
0
]
.
fType
)
)
)
;
return
(
total
+
alignment
-
1
)
&
~
(
alignment
-
1
)
;
}
default
:
SK_ABORT
(
"
cannot
determine
size
of
type
'
%
s
'
"
type
.
displayName
(
)
.
c_str
(
)
)
;
}
}
size_t
isSupported
(
const
Type
&
type
)
const
{
switch
(
type
.
typeKind
(
)
)
{
case
Type
:
:
TypeKind
:
:
kAtomic
:
return
true
;
case
Type
:
:
TypeKind
:
:
kScalar
:
return
this
-
>
isWGSL
(
)
?
!
type
.
isBoolean
(
)
:
true
;
case
Type
:
:
TypeKind
:
:
kVector
:
case
Type
:
:
TypeKind
:
:
kMatrix
:
case
Type
:
:
TypeKind
:
:
kArray
:
return
this
-
>
isSupported
(
type
.
componentType
(
)
)
;
case
Type
:
:
TypeKind
:
:
kStruct
:
return
std
:
:
all_of
(
type
.
fields
(
)
.
begin
(
)
type
.
fields
(
)
.
end
(
)
[
this
]
(
const
Field
&
f
)
{
return
this
-
>
isSupported
(
*
f
.
fType
)
;
}
)
;
default
:
return
false
;
}
}
private
:
static
size_t
GetVectorAlignment
(
size_t
componentSize
int
columns
)
{
return
componentSize
*
(
columns
+
columns
%
2
)
;
}
const
Standard
fStd
;
}
;
}
#
endif
