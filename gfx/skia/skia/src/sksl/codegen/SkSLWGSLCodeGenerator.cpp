#
include
"
src
/
sksl
/
codegen
/
SkSLWGSLCodeGenerator
.
h
"
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
memory
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
include
/
core
/
SkSpan
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
SkBitmaskEnum
.
h
"
#
include
"
include
/
private
/
SkSLIRNode
.
h
"
#
include
"
include
/
private
/
SkSLLayout
.
h
"
#
include
"
include
/
private
/
SkSLModifiers
.
h
"
#
include
"
include
/
private
/
SkSLProgramElement
.
h
"
#
include
"
include
/
private
/
SkSLStatement
.
h
"
#
include
"
include
/
private
/
SkSLString
.
h
"
#
include
"
include
/
private
/
SkSLSymbol
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
include
/
sksl
/
SkSLErrorReporter
.
h
"
#
include
"
include
/
sksl
/
SkSLOperator
.
h
"
#
include
"
include
/
sksl
/
SkSLPosition
.
h
"
#
include
"
src
/
sksl
/
SkSLAnalysis
.
h
"
#
include
"
src
/
sksl
/
SkSLBuiltinTypes
.
h
"
#
include
"
src
/
sksl
/
SkSLCompiler
.
h
"
#
include
"
src
/
sksl
/
SkSLContext
.
h
"
#
include
"
src
/
sksl
/
SkSLOutputStream
.
h
"
#
include
"
src
/
sksl
/
SkSLProgramSettings
.
h
"
#
include
"
src
/
sksl
/
SkSLStringStream
.
h
"
#
include
"
src
/
sksl
/
SkSLUtil
.
h
"
#
include
"
src
/
sksl
/
analysis
/
SkSLProgramVisitor
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLBinaryExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLBlock
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructor
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorCompound
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorDiagonalMatrix
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorMatrixResize
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLExpressionStatement
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFieldAccess
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFunctionCall
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFunctionDeclaration
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFunctionDefinition
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLIfStatement
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLIndexExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLInterfaceBlock
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLLiteral
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLProgram
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLReturnStatement
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLStructDefinition
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLSwizzle
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLSymbolTable
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLTernaryExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLType
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLVarDeclarations
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLVariable
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLVariableReference
.
h
"
#
define
DUMP_SRC_IR
0
namespace
SkSL
{
enum
class
ProgramKind
:
int8_t
;
namespace
{
enum
class
PtrAddressSpace
{
kFunction
kPrivate
kStorage
}
;
std
:
:
string_view
pipeline_struct_prefix
(
ProgramKind
kind
)
{
if
(
ProgramConfig
:
:
IsVertex
(
kind
)
)
{
return
"
VS
"
;
}
if
(
ProgramConfig
:
:
IsFragment
(
kind
)
)
{
return
"
FS
"
;
}
return
"
"
;
}
std
:
:
string_view
address_space_to_str
(
PtrAddressSpace
addressSpace
)
{
switch
(
addressSpace
)
{
case
PtrAddressSpace
:
:
kFunction
:
return
"
function
"
;
case
PtrAddressSpace
:
:
kPrivate
:
return
"
private
"
;
case
PtrAddressSpace
:
:
kStorage
:
return
"
storage
"
;
}
SkDEBUGFAIL
(
"
unsupported
ptr
address
space
"
)
;
return
"
unsupported
"
;
}
std
:
:
string_view
to_scalar_type
(
const
Type
&
type
)
{
SkASSERT
(
type
.
typeKind
(
)
=
=
Type
:
:
TypeKind
:
:
kScalar
)
;
switch
(
type
.
numberKind
(
)
)
{
case
Type
:
:
NumberKind
:
:
kFloat
:
return
"
f32
"
;
case
Type
:
:
NumberKind
:
:
kSigned
:
return
"
i32
"
;
case
Type
:
:
NumberKind
:
:
kUnsigned
:
return
"
u32
"
;
case
Type
:
:
NumberKind
:
:
kBoolean
:
return
"
bool
"
;
case
Type
:
:
NumberKind
:
:
kNonnumeric
:
[
[
fallthrough
]
]
;
default
:
break
;
}
return
type
.
name
(
)
;
}
std
:
:
string
to_wgsl_type
(
const
Type
&
type
)
{
switch
(
type
.
typeKind
(
)
)
{
case
Type
:
:
TypeKind
:
:
kScalar
:
return
std
:
:
string
(
to_scalar_type
(
type
)
)
;
case
Type
:
:
TypeKind
:
:
kVector
:
{
std
:
:
string_view
ct
=
to_scalar_type
(
type
.
componentType
(
)
)
;
return
String
:
:
printf
(
"
vec
%
d
<
%
.
*
s
>
"
type
.
columns
(
)
(
int
)
ct
.
length
(
)
ct
.
data
(
)
)
;
}
case
Type
:
:
TypeKind
:
:
kMatrix
:
{
std
:
:
string_view
ct
=
to_scalar_type
(
type
.
componentType
(
)
)
;
return
String
:
:
printf
(
"
mat
%
dx
%
d
<
%
.
*
s
>
"
type
.
columns
(
)
type
.
rows
(
)
(
int
)
ct
.
length
(
)
ct
.
data
(
)
)
;
}
case
Type
:
:
TypeKind
:
:
kArray
:
{
std
:
:
string
elementType
=
to_wgsl_type
(
type
.
componentType
(
)
)
;
if
(
type
.
isUnsizedArray
(
)
)
{
return
String
:
:
printf
(
"
array
<
%
s
>
"
elementType
.
c_str
(
)
)
;
}
return
String
:
:
printf
(
"
array
<
%
s
%
d
>
"
elementType
.
c_str
(
)
type
.
columns
(
)
)
;
}
default
:
break
;
}
return
std
:
:
string
(
type
.
name
(
)
)
;
}
std
:
:
string
to_mangled_wgsl_type_name
(
const
Type
&
type
)
{
switch
(
type
.
typeKind
(
)
)
{
case
Type
:
:
TypeKind
:
:
kScalar
:
return
std
:
:
string
(
to_scalar_type
(
type
)
)
;
case
Type
:
:
TypeKind
:
:
kVector
:
{
std
:
:
string_view
ct
=
to_scalar_type
(
type
.
componentType
(
)
)
;
return
String
:
:
printf
(
"
vec
%
d
%
.
*
s
"
type
.
columns
(
)
(
int
)
ct
.
length
(
)
ct
.
data
(
)
)
;
}
case
Type
:
:
TypeKind
:
:
kMatrix
:
{
std
:
:
string_view
ct
=
to_scalar_type
(
type
.
componentType
(
)
)
;
return
String
:
:
printf
(
"
mat
%
dx
%
d
%
.
*
s
"
type
.
columns
(
)
type
.
rows
(
)
(
int
)
ct
.
length
(
)
ct
.
data
(
)
)
;
}
case
Type
:
:
TypeKind
:
:
kArray
:
{
std
:
:
string
elementType
=
to_wgsl_type
(
type
.
componentType
(
)
)
;
if
(
type
.
isUnsizedArray
(
)
)
{
return
String
:
:
printf
(
"
arrayof
%
s
"
elementType
.
c_str
(
)
)
;
}
return
String
:
:
printf
(
"
array
%
dof
%
s
"
type
.
columns
(
)
elementType
.
c_str
(
)
)
;
}
default
:
break
;
}
return
std
:
:
string
(
type
.
name
(
)
)
;
}
std
:
:
string
to_ptr_type
(
const
Type
&
type
PtrAddressSpace
addressSpace
=
PtrAddressSpace
:
:
kFunction
)
{
return
"
ptr
<
"
+
std
:
:
string
(
address_space_to_str
(
addressSpace
)
)
+
"
"
+
to_wgsl_type
(
type
)
+
"
>
"
;
}
std
:
:
string_view
wgsl_builtin_name
(
WGSLCodeGenerator
:
:
Builtin
builtin
)
{
using
Builtin
=
WGSLCodeGenerator
:
:
Builtin
;
switch
(
builtin
)
{
case
Builtin
:
:
kVertexIndex
:
return
"
vertex_index
"
;
case
Builtin
:
:
kInstanceIndex
:
return
"
instance_index
"
;
case
Builtin
:
:
kPosition
:
return
"
position
"
;
case
Builtin
:
:
kFrontFacing
:
return
"
front_facing
"
;
case
Builtin
:
:
kSampleIndex
:
return
"
sample_index
"
;
case
Builtin
:
:
kFragDepth
:
return
"
frag_depth
"
;
case
Builtin
:
:
kSampleMask
:
return
"
sample_mask
"
;
case
Builtin
:
:
kLocalInvocationId
:
return
"
local_invocation_id
"
;
case
Builtin
:
:
kLocalInvocationIndex
:
return
"
local_invocation_index
"
;
case
Builtin
:
:
kGlobalInvocationId
:
return
"
global_invocation_id
"
;
case
Builtin
:
:
kWorkgroupId
:
return
"
workgroup_id
"
;
case
Builtin
:
:
kNumWorkgroups
:
return
"
num_workgroups
"
;
default
:
break
;
}
SkDEBUGFAIL
(
"
unsupported
builtin
"
)
;
return
"
unsupported
"
;
}
std
:
:
string_view
wgsl_builtin_type
(
WGSLCodeGenerator
:
:
Builtin
builtin
)
{
using
Builtin
=
WGSLCodeGenerator
:
:
Builtin
;
switch
(
builtin
)
{
case
Builtin
:
:
kVertexIndex
:
return
"
u32
"
;
case
Builtin
:
:
kInstanceIndex
:
return
"
u32
"
;
case
Builtin
:
:
kPosition
:
return
"
vec4
<
f32
>
"
;
case
Builtin
:
:
kFrontFacing
:
return
"
bool
"
;
case
Builtin
:
:
kSampleIndex
:
return
"
u32
"
;
case
Builtin
:
:
kFragDepth
:
return
"
f32
"
;
case
Builtin
:
:
kSampleMask
:
return
"
u32
"
;
case
Builtin
:
:
kLocalInvocationId
:
return
"
vec3
<
u32
>
"
;
case
Builtin
:
:
kLocalInvocationIndex
:
return
"
u32
"
;
case
Builtin
:
:
kGlobalInvocationId
:
return
"
vec3
<
u32
>
"
;
case
Builtin
:
:
kWorkgroupId
:
return
"
vec3
<
u32
>
"
;
case
Builtin
:
:
kNumWorkgroups
:
return
"
vec3
<
u32
>
"
;
default
:
break
;
}
SkDEBUGFAIL
(
"
unsupported
builtin
"
)
;
return
"
unsupported
"
;
}
std
:
:
optional
<
std
:
:
string_view
>
needs_builtin_type_conversion
(
const
Variable
&
v
)
{
switch
(
v
.
modifiers
(
)
.
fLayout
.
fBuiltin
)
{
case
SK_VERTEXID_BUILTIN
:
case
SK_INSTANCEID_BUILTIN
:
return
{
"
i32
"
}
;
default
:
break
;
}
return
std
:
:
nullopt
;
}
std
:
:
optional
<
WGSLCodeGenerator
:
:
Builtin
>
builtin_from_sksl_name
(
int
builtin
)
{
using
Builtin
=
WGSLCodeGenerator
:
:
Builtin
;
switch
(
builtin
)
{
case
SK_POSITION_BUILTIN
:
[
[
fallthrough
]
]
;
case
SK_FRAGCOORD_BUILTIN
:
return
{
Builtin
:
:
kPosition
}
;
case
SK_VERTEXID_BUILTIN
:
return
{
Builtin
:
:
kVertexIndex
}
;
case
SK_INSTANCEID_BUILTIN
:
return
{
Builtin
:
:
kInstanceIndex
}
;
case
SK_CLOCKWISE_BUILTIN
:
return
{
Builtin
:
:
kFrontFacing
}
;
default
:
break
;
}
return
std
:
:
nullopt
;
}
const
SymbolTable
*
top_level_symbol_table
(
const
FunctionDefinition
&
f
)
{
return
f
.
body
(
)
-
>
as
<
Block
>
(
)
.
symbolTable
(
)
-
>
fParent
.
get
(
)
;
}
const
char
*
delimiter_to_str
(
WGSLCodeGenerator
:
:
Delimiter
delimiter
)
{
using
Delim
=
WGSLCodeGenerator
:
:
Delimiter
;
switch
(
delimiter
)
{
case
Delim
:
:
kComma
:
return
"
"
;
case
Delim
:
:
kSemicolon
:
return
"
;
"
;
case
Delim
:
:
kNone
:
default
:
break
;
}
return
"
"
;
}
class
FunctionDependencyResolver
:
public
ProgramVisitor
{
public
:
using
Deps
=
WGSLCodeGenerator
:
:
FunctionDependencies
;
using
DepsMap
=
WGSLCodeGenerator
:
:
ProgramRequirements
:
:
DepsMap
;
FunctionDependencyResolver
(
const
Program
*
p
const
FunctionDeclaration
*
f
DepsMap
*
programDependencyMap
)
:
fProgram
(
p
)
fFunction
(
f
)
fDependencyMap
(
programDependencyMap
)
{
}
Deps
resolve
(
)
{
fDeps
=
Deps
:
:
kNone
;
this
-
>
visit
(
*
fProgram
)
;
return
fDeps
;
}
private
:
bool
visitProgramElement
(
const
ProgramElement
&
p
)
override
{
if
(
p
.
is
<
FunctionDefinition
>
(
)
&
&
&
p
.
as
<
FunctionDefinition
>
(
)
.
declaration
(
)
=
=
fFunction
)
{
return
INHERITED
:
:
visitProgramElement
(
p
)
;
}
return
false
;
}
bool
visitExpression
(
const
Expression
&
e
)
override
{
if
(
e
.
is
<
VariableReference
>
(
)
)
{
const
VariableReference
&
v
=
e
.
as
<
VariableReference
>
(
)
;
const
Modifiers
&
modifiers
=
v
.
variable
(
)
-
>
modifiers
(
)
;
if
(
v
.
variable
(
)
-
>
storage
(
)
=
=
Variable
:
:
Storage
:
:
kGlobal
)
{
if
(
modifiers
.
fFlags
&
Modifiers
:
:
kIn_Flag
)
{
fDeps
|
=
Deps
:
:
kPipelineInputs
;
}
if
(
modifiers
.
fFlags
&
Modifiers
:
:
kOut_Flag
)
{
fDeps
|
=
Deps
:
:
kPipelineOutputs
;
}
}
}
else
if
(
e
.
is
<
FunctionCall
>
(
)
)
{
const
FunctionCall
&
callee
=
e
.
as
<
FunctionCall
>
(
)
;
Deps
*
found
=
fDependencyMap
-
>
find
(
&
callee
.
function
(
)
)
;
if
(
found
)
{
fDeps
|
=
*
found
;
}
else
{
fDependencyMap
-
>
set
(
fFunction
fDeps
)
;
FunctionDependencyResolver
resolver
(
fProgram
&
callee
.
function
(
)
fDependencyMap
)
;
Deps
calleeDeps
=
resolver
.
resolve
(
)
;
fDependencyMap
-
>
set
(
&
callee
.
function
(
)
calleeDeps
)
;
fDeps
|
=
calleeDeps
;
}
}
return
INHERITED
:
:
visitExpression
(
e
)
;
}
const
Program
*
const
fProgram
;
const
FunctionDeclaration
*
const
fFunction
;
DepsMap
*
const
fDependencyMap
;
Deps
fDeps
=
Deps
:
:
kNone
;
using
INHERITED
=
ProgramVisitor
;
}
;
WGSLCodeGenerator
:
:
ProgramRequirements
resolve_program_requirements
(
const
Program
*
program
)
{
bool
mainNeedsCoordsArgument
=
false
;
WGSLCodeGenerator
:
:
ProgramRequirements
:
:
DepsMap
dependencies
;
for
(
const
ProgramElement
*
e
:
program
-
>
elements
(
)
)
{
if
(
!
e
-
>
is
<
FunctionDefinition
>
(
)
)
{
continue
;
}
const
FunctionDeclaration
&
decl
=
e
-
>
as
<
FunctionDefinition
>
(
)
.
declaration
(
)
;
if
(
decl
.
isMain
(
)
)
{
for
(
const
Variable
*
v
:
decl
.
parameters
(
)
)
{
if
(
v
-
>
modifiers
(
)
.
fLayout
.
fBuiltin
=
=
SK_MAIN_COORDS_BUILTIN
)
{
mainNeedsCoordsArgument
=
true
;
break
;
}
}
}
FunctionDependencyResolver
resolver
(
program
&
decl
&
dependencies
)
;
dependencies
.
set
(
&
decl
resolver
.
resolve
(
)
)
;
}
return
WGSLCodeGenerator
:
:
ProgramRequirements
(
std
:
:
move
(
dependencies
)
mainNeedsCoordsArgument
)
;
}
int
count_pipeline_inputs
(
const
Program
*
program
)
{
int
inputCount
=
0
;
for
(
const
ProgramElement
*
e
:
program
-
>
elements
(
)
)
{
if
(
e
-
>
is
<
GlobalVarDeclaration
>
(
)
)
{
const
Variable
*
v
=
e
-
>
as
<
GlobalVarDeclaration
>
(
)
.
varDeclaration
(
)
.
var
(
)
;
if
(
v
-
>
modifiers
(
)
.
fFlags
&
Modifiers
:
:
kIn_Flag
)
{
inputCount
+
+
;
}
}
else
if
(
e
-
>
is
<
InterfaceBlock
>
(
)
)
{
const
Variable
*
v
=
e
-
>
as
<
InterfaceBlock
>
(
)
.
var
(
)
;
if
(
v
-
>
modifiers
(
)
.
fFlags
&
Modifiers
:
:
kIn_Flag
)
{
inputCount
+
+
;
}
}
}
return
inputCount
;
}
static
bool
is_in_global_uniforms
(
const
Variable
&
var
)
{
SkASSERT
(
var
.
storage
(
)
=
=
VariableStorage
:
:
kGlobal
)
;
return
var
.
modifiers
(
)
.
fFlags
&
Modifiers
:
:
kUniform_Flag
&
&
!
var
.
type
(
)
.
isOpaque
(
)
;
}
}
bool
WGSLCodeGenerator
:
:
generateCode
(
)
{
this
-
>
preprocessProgram
(
)
;
StringStream
header
;
{
AutoOutputStream
outputToHeader
(
this
&
header
&
fIndentation
)
;
this
-
>
writeStageInputStruct
(
)
;
this
-
>
writeStageOutputStruct
(
)
;
this
-
>
writeNonBlockUniformsForTests
(
)
;
}
StringStream
body
;
{
AutoOutputStream
outputToBody
(
this
&
body
&
fIndentation
)
;
for
(
const
ProgramElement
*
e
:
fProgram
.
elements
(
)
)
{
this
-
>
writeProgramElement
(
*
e
)
;
}
#
if
DUMP_SRC_IR
this
-
>
writeLine
(
"
\
n
-
-
-
-
-
-
-
-
-
-
"
)
;
this
-
>
writeLine
(
"
Source
IR
:
\
n
"
)
;
for
(
const
ProgramElement
*
e
:
fProgram
.
elements
(
)
)
{
this
-
>
writeLine
(
e
-
>
description
(
)
.
c_str
(
)
)
;
}
#
endif
}
write_stringstream
(
header
*
fOut
)
;
write_stringstream
(
fExtraFunctions
*
fOut
)
;
write_stringstream
(
body
*
fOut
)
;
return
fContext
.
fErrors
-
>
errorCount
(
)
=
=
0
;
}
void
WGSLCodeGenerator
:
:
preprocessProgram
(
)
{
fRequirements
=
resolve_program_requirements
(
&
fProgram
)
;
fPipelineInputCount
=
count_pipeline_inputs
(
&
fProgram
)
;
}
void
WGSLCodeGenerator
:
:
write
(
std
:
:
string_view
s
)
{
if
(
s
.
empty
(
)
)
{
return
;
}
if
(
fAtLineStart
)
{
for
(
int
i
=
0
;
i
<
fIndentation
;
i
+
+
)
{
fOut
-
>
writeText
(
"
"
)
;
}
}
fOut
-
>
writeText
(
std
:
:
string
(
s
)
.
c_str
(
)
)
;
fAtLineStart
=
false
;
}
void
WGSLCodeGenerator
:
:
writeLine
(
std
:
:
string_view
s
)
{
this
-
>
write
(
s
)
;
fOut
-
>
writeText
(
"
\
n
"
)
;
fAtLineStart
=
true
;
}
void
WGSLCodeGenerator
:
:
finishLine
(
)
{
if
(
!
fAtLineStart
)
{
this
-
>
writeLine
(
)
;
}
}
void
WGSLCodeGenerator
:
:
writeName
(
std
:
:
string_view
name
)
{
if
(
fReservedWords
.
contains
(
name
)
)
{
this
-
>
write
(
"
_
"
)
;
}
this
-
>
write
(
name
)
;
}
void
WGSLCodeGenerator
:
:
writeVariableDecl
(
const
Type
&
type
std
:
:
string_view
name
Delimiter
delimiter
)
{
this
-
>
writeName
(
name
)
;
this
-
>
write
(
"
:
"
+
to_wgsl_type
(
type
)
)
;
this
-
>
writeLine
(
delimiter_to_str
(
delimiter
)
)
;
}
void
WGSLCodeGenerator
:
:
writePipelineIODeclaration
(
Modifiers
modifiers
const
Type
&
type
std
:
:
string_view
name
Delimiter
delimiter
)
{
int
location
=
modifiers
.
fLayout
.
fLocation
;
if
(
location
>
=
0
)
{
this
-
>
writeUserDefinedIODecl
(
type
name
location
delimiter
)
;
}
else
if
(
modifiers
.
fLayout
.
fBuiltin
>
=
0
)
{
auto
builtin
=
builtin_from_sksl_name
(
modifiers
.
fLayout
.
fBuiltin
)
;
if
(
builtin
.
has_value
(
)
)
{
this
-
>
writeBuiltinIODecl
(
type
name
*
builtin
delimiter
)
;
}
}
}
void
WGSLCodeGenerator
:
:
writeUserDefinedIODecl
(
const
Type
&
type
std
:
:
string_view
name
int
location
Delimiter
delimiter
)
{
this
-
>
write
(
"
location
(
"
+
std
:
:
to_string
(
location
)
+
"
)
"
)
;
if
(
type
.
isInteger
(
)
|
|
(
type
.
isVector
(
)
&
&
type
.
componentType
(
)
.
isInteger
(
)
)
)
{
this
-
>
write
(
"
interpolate
(
flat
)
"
)
;
}
this
-
>
writeVariableDecl
(
type
name
delimiter
)
;
}
void
WGSLCodeGenerator
:
:
writeBuiltinIODecl
(
const
Type
&
type
std
:
:
string_view
name
Builtin
builtin
Delimiter
delimiter
)
{
this
-
>
write
(
"
builtin
(
"
)
;
this
-
>
write
(
wgsl_builtin_name
(
builtin
)
)
;
this
-
>
write
(
"
)
"
)
;
this
-
>
writeName
(
name
)
;
this
-
>
write
(
"
:
"
)
;
this
-
>
write
(
wgsl_builtin_type
(
builtin
)
)
;
this
-
>
writeLine
(
delimiter_to_str
(
delimiter
)
)
;
}
void
WGSLCodeGenerator
:
:
writeFunction
(
const
FunctionDefinition
&
f
)
{
this
-
>
writeFunctionDeclaration
(
f
.
declaration
(
)
)
;
this
-
>
write
(
"
"
)
;
this
-
>
writeBlock
(
f
.
body
(
)
-
>
as
<
Block
>
(
)
)
;
if
(
f
.
declaration
(
)
.
isMain
(
)
)
{
this
-
>
writeEntryPoint
(
f
)
;
}
}
void
WGSLCodeGenerator
:
:
writeFunctionDeclaration
(
const
FunctionDeclaration
&
f
)
{
this
-
>
write
(
"
fn
"
)
;
this
-
>
write
(
f
.
mangledName
(
)
)
;
this
-
>
write
(
"
(
"
)
;
auto
separator
=
SkSL
:
:
String
:
:
Separator
(
)
;
if
(
this
-
>
writeFunctionDependencyParams
(
f
)
)
{
separator
(
)
;
}
for
(
const
Variable
*
param
:
f
.
parameters
(
)
)
{
this
-
>
write
(
separator
(
)
)
;
this
-
>
writeName
(
param
-
>
mangledName
(
)
)
;
this
-
>
write
(
"
:
"
)
;
if
(
param
-
>
modifiers
(
)
.
fFlags
&
Modifiers
:
:
kOut_Flag
)
{
this
-
>
write
(
to_ptr_type
(
param
-
>
type
(
)
)
)
;
}
else
{
this
-
>
write
(
to_wgsl_type
(
param
-
>
type
(
)
)
)
;
}
}
this
-
>
write
(
"
)
"
)
;
if
(
!
f
.
returnType
(
)
.
isVoid
(
)
)
{
this
-
>
write
(
"
-
>
"
)
;
this
-
>
write
(
to_wgsl_type
(
f
.
returnType
(
)
)
)
;
}
}
void
WGSLCodeGenerator
:
:
writeEntryPoint
(
const
FunctionDefinition
&
main
)
{
SkASSERT
(
main
.
declaration
(
)
.
isMain
(
)
)
;
std
:
:
string
outputType
;
if
(
ProgramConfig
:
:
IsVertex
(
fProgram
.
fConfig
-
>
fKind
)
)
{
this
-
>
write
(
"
vertex
fn
vertexMain
(
"
)
;
if
(
fPipelineInputCount
>
0
)
{
this
-
>
write
(
"
_stageIn
:
VSIn
"
)
;
}
this
-
>
writeLine
(
"
)
-
>
VSOut
{
"
)
;
outputType
=
"
VSOut
"
;
}
else
if
(
ProgramConfig
:
:
IsFragment
(
fProgram
.
fConfig
-
>
fKind
)
)
{
this
-
>
write
(
"
fragment
fn
fragmentMain
(
"
)
;
if
(
fPipelineInputCount
>
0
)
{
this
-
>
write
(
"
_stageIn
:
FSIn
"
)
;
}
this
-
>
writeLine
(
"
)
-
>
FSOut
{
"
)
;
outputType
=
"
FSOut
"
;
}
else
{
fContext
.
fErrors
-
>
error
(
Position
(
)
"
program
kind
not
supported
"
)
;
return
;
}
fIndentation
+
+
;
this
-
>
write
(
"
var
_stageOut
:
"
)
;
this
-
>
write
(
outputType
)
;
this
-
>
writeLine
(
"
;
"
)
;
if
(
ProgramConfig
:
:
IsFragment
(
fProgram
.
fConfig
-
>
fKind
)
)
{
const
SymbolTable
*
symbolTable
=
top_level_symbol_table
(
main
)
;
const
Symbol
*
symbol
=
symbolTable
-
>
find
(
"
sk_FragColor
"
)
;
SkASSERT
(
symbol
)
;
if
(
main
.
declaration
(
)
.
returnType
(
)
.
matches
(
symbol
-
>
type
(
)
)
)
{
this
-
>
write
(
"
_stageOut
.
sk_FragColor
=
"
)
;
}
}
this
-
>
write
(
main
.
declaration
(
)
.
mangledName
(
)
)
;
this
-
>
write
(
"
(
"
)
;
auto
separator
=
SkSL
:
:
String
:
:
Separator
(
)
;
FunctionDependencies
*
deps
=
fRequirements
.
dependencies
.
find
(
&
main
.
declaration
(
)
)
;
if
(
deps
)
{
if
(
(
*
deps
&
FunctionDependencies
:
:
kPipelineInputs
)
!
=
FunctionDependencies
:
:
kNone
)
{
this
-
>
write
(
separator
(
)
)
;
this
-
>
write
(
"
_stageIn
"
)
;
}
if
(
(
*
deps
&
FunctionDependencies
:
:
kPipelineOutputs
)
!
=
FunctionDependencies
:
:
kNone
)
{
this
-
>
write
(
separator
(
)
)
;
this
-
>
write
(
"
&
_stageOut
"
)
;
}
}
if
(
main
.
declaration
(
)
.
parameters
(
)
.
size
(
)
!
=
0
)
{
const
Variable
*
v
=
main
.
declaration
(
)
.
parameters
(
)
[
0
]
;
const
Type
&
type
=
v
-
>
type
(
)
;
if
(
v
-
>
modifiers
(
)
.
fLayout
.
fBuiltin
=
=
SK_MAIN_COORDS_BUILTIN
)
{
if
(
!
type
.
matches
(
*
fContext
.
fTypes
.
fFloat2
)
)
{
fContext
.
fErrors
-
>
error
(
main
.
fPosition
"
main
function
has
unsupported
parameter
:
"
+
type
.
description
(
)
)
;
return
;
}
this
-
>
write
(
separator
(
)
)
;
this
-
>
write
(
"
_stageIn
.
sk_FragCoord
.
xy
"
)
;
}
}
this
-
>
writeLine
(
"
)
;
"
)
;
this
-
>
writeLine
(
"
return
_stageOut
;
"
)
;
fIndentation
-
-
;
this
-
>
writeLine
(
"
}
"
)
;
}
void
WGSLCodeGenerator
:
:
writeStatement
(
const
Statement
&
s
)
{
switch
(
s
.
kind
(
)
)
{
case
Statement
:
:
Kind
:
:
kBlock
:
this
-
>
writeBlock
(
s
.
as
<
Block
>
(
)
)
;
break
;
case
Statement
:
:
Kind
:
:
kExpression
:
this
-
>
writeExpressionStatement
(
s
.
as
<
ExpressionStatement
>
(
)
)
;
break
;
case
Statement
:
:
Kind
:
:
kIf
:
this
-
>
writeIfStatement
(
s
.
as
<
IfStatement
>
(
)
)
;
break
;
case
Statement
:
:
Kind
:
:
kReturn
:
this
-
>
writeReturnStatement
(
s
.
as
<
ReturnStatement
>
(
)
)
;
break
;
case
Statement
:
:
Kind
:
:
kVarDeclaration
:
this
-
>
writeVarDeclaration
(
s
.
as
<
VarDeclaration
>
(
)
)
;
break
;
default
:
SkDEBUGFAILF
(
"
unsupported
statement
(
kind
:
%
d
)
%
s
"
static_cast
<
int
>
(
s
.
kind
(
)
)
s
.
description
(
)
.
c_str
(
)
)
;
break
;
}
}
void
WGSLCodeGenerator
:
:
writeStatements
(
const
StatementArray
&
statements
)
{
for
(
const
auto
&
s
:
statements
)
{
if
(
!
s
-
>
isEmpty
(
)
)
{
this
-
>
writeStatement
(
*
s
)
;
this
-
>
finishLine
(
)
;
}
}
}
void
WGSLCodeGenerator
:
:
writeBlock
(
const
Block
&
b
)
{
bool
isScope
=
b
.
isScope
(
)
|
|
b
.
isEmpty
(
)
;
if
(
isScope
)
{
this
-
>
writeLine
(
"
{
"
)
;
fIndentation
+
+
;
}
this
-
>
writeStatements
(
b
.
children
(
)
)
;
if
(
isScope
)
{
fIndentation
-
-
;
this
-
>
writeLine
(
"
}
"
)
;
}
}
void
WGSLCodeGenerator
:
:
writeExpressionStatement
(
const
ExpressionStatement
&
s
)
{
if
(
Analysis
:
:
HasSideEffects
(
*
s
.
expression
(
)
)
)
{
this
-
>
writeExpression
(
*
s
.
expression
(
)
Precedence
:
:
kTopLevel
)
;
this
-
>
write
(
"
;
"
)
;
}
}
void
WGSLCodeGenerator
:
:
writeIfStatement
(
const
IfStatement
&
s
)
{
this
-
>
write
(
"
if
(
"
)
;
this
-
>
writeExpression
(
*
s
.
test
(
)
Precedence
:
:
kTopLevel
)
;
this
-
>
write
(
"
)
"
)
;
this
-
>
writeStatement
(
*
s
.
ifTrue
(
)
)
;
if
(
s
.
ifFalse
(
)
)
{
this
-
>
write
(
"
else
"
)
;
this
-
>
writeStatement
(
*
s
.
ifFalse
(
)
)
;
}
}
void
WGSLCodeGenerator
:
:
writeReturnStatement
(
const
ReturnStatement
&
s
)
{
this
-
>
write
(
"
return
"
)
;
if
(
s
.
expression
(
)
)
{
this
-
>
write
(
"
"
)
;
this
-
>
writeExpression
(
*
s
.
expression
(
)
Precedence
:
:
kTopLevel
)
;
}
this
-
>
write
(
"
;
"
)
;
}
void
WGSLCodeGenerator
:
:
writeVarDeclaration
(
const
VarDeclaration
&
varDecl
)
{
bool
isConst
=
varDecl
.
var
(
)
-
>
modifiers
(
)
.
fFlags
&
Modifiers
:
:
kConst_Flag
;
if
(
isConst
)
{
this
-
>
write
(
"
let
"
)
;
}
else
{
this
-
>
write
(
"
var
"
)
;
}
this
-
>
writeName
(
varDecl
.
var
(
)
-
>
mangledName
(
)
)
;
this
-
>
write
(
"
:
"
)
;
this
-
>
write
(
to_wgsl_type
(
varDecl
.
var
(
)
-
>
type
(
)
)
)
;
if
(
varDecl
.
value
(
)
)
{
this
-
>
write
(
"
=
"
)
;
this
-
>
writeExpression
(
*
varDecl
.
value
(
)
Precedence
:
:
kTopLevel
)
;
}
else
if
(
isConst
)
{
SkDEBUGFAILF
(
"
A
let
-
declared
constant
must
specify
a
value
"
)
;
}
this
-
>
write
(
"
;
"
)
;
}
void
WGSLCodeGenerator
:
:
writeExpression
(
const
Expression
&
e
Precedence
parentPrecedence
)
{
switch
(
e
.
kind
(
)
)
{
case
Expression
:
:
Kind
:
:
kBinary
:
this
-
>
writeBinaryExpression
(
e
.
as
<
BinaryExpression
>
(
)
parentPrecedence
)
;
break
;
case
Expression
:
:
Kind
:
:
kConstructorCompound
:
this
-
>
writeConstructorCompound
(
e
.
as
<
ConstructorCompound
>
(
)
parentPrecedence
)
;
break
;
case
Expression
:
:
Kind
:
:
kConstructorCompoundCast
:
case
Expression
:
:
Kind
:
:
kConstructorScalarCast
:
case
Expression
:
:
Kind
:
:
kConstructorSplat
:
this
-
>
writeAnyConstructor
(
e
.
asAnyConstructor
(
)
parentPrecedence
)
;
break
;
case
Expression
:
:
Kind
:
:
kConstructorDiagonalMatrix
:
this
-
>
writeConstructorDiagonalMatrix
(
e
.
as
<
ConstructorDiagonalMatrix
>
(
)
parentPrecedence
)
;
break
;
case
Expression
:
:
Kind
:
:
kConstructorMatrixResize
:
this
-
>
writeConstructorMatrixResize
(
e
.
as
<
ConstructorMatrixResize
>
(
)
parentPrecedence
)
;
break
;
case
Expression
:
:
Kind
:
:
kFieldAccess
:
this
-
>
writeFieldAccess
(
e
.
as
<
FieldAccess
>
(
)
)
;
break
;
case
Expression
:
:
Kind
:
:
kFunctionCall
:
this
-
>
writeFunctionCall
(
e
.
as
<
FunctionCall
>
(
)
)
;
break
;
case
Expression
:
:
Kind
:
:
kIndex
:
this
-
>
writeIndexExpression
(
e
.
as
<
IndexExpression
>
(
)
)
;
break
;
case
Expression
:
:
Kind
:
:
kLiteral
:
this
-
>
writeLiteral
(
e
.
as
<
Literal
>
(
)
)
;
break
;
case
Expression
:
:
Kind
:
:
kSwizzle
:
this
-
>
writeSwizzle
(
e
.
as
<
Swizzle
>
(
)
)
;
break
;
case
Expression
:
:
Kind
:
:
kTernary
:
this
-
>
writeTernaryExpression
(
e
.
as
<
TernaryExpression
>
(
)
parentPrecedence
)
;
break
;
case
Expression
:
:
Kind
:
:
kVariableReference
:
this
-
>
writeVariableReference
(
e
.
as
<
VariableReference
>
(
)
)
;
break
;
default
:
SkDEBUGFAILF
(
"
unsupported
expression
(
kind
:
%
d
)
%
s
"
static_cast
<
int
>
(
e
.
kind
(
)
)
e
.
description
(
)
.
c_str
(
)
)
;
break
;
}
}
void
WGSLCodeGenerator
:
:
writeBinaryExpression
(
const
BinaryExpression
&
b
Precedence
parentPrecedence
)
{
const
Expression
&
left
=
*
b
.
left
(
)
;
const
Expression
&
right
=
*
b
.
right
(
)
;
Operator
op
=
b
.
getOperator
(
)
;
if
(
op
.
isEquality
(
)
&
&
!
left
.
type
(
)
.
isScalar
(
)
&
&
!
left
.
type
(
)
.
isVector
(
)
)
{
if
(
left
.
type
(
)
.
isMatrix
(
)
)
{
if
(
op
.
kind
(
)
=
=
OperatorKind
:
:
NEQ
)
{
this
-
>
write
(
"
!
"
)
;
}
this
-
>
writeMatrixEquality
(
left
right
)
;
return
;
}
return
;
}
Precedence
precedence
=
op
.
getBinaryPrecedence
(
)
;
bool
needParens
=
precedence
>
=
parentPrecedence
;
if
(
left
.
type
(
)
.
isVector
(
)
)
{
if
(
op
.
kind
(
)
=
=
Operator
:
:
Kind
:
:
EQEQ
)
{
this
-
>
write
(
"
all
"
)
;
needParens
=
true
;
}
else
if
(
op
.
kind
(
)
=
=
Operator
:
:
Kind
:
:
NEQ
)
{
this
-
>
write
(
"
any
"
)
;
needParens
=
true
;
}
}
if
(
needParens
)
{
this
-
>
write
(
"
(
"
)
;
}
this
-
>
writeExpression
(
left
precedence
)
;
this
-
>
write
(
op
.
operatorName
(
)
)
;
this
-
>
writeExpression
(
right
precedence
)
;
if
(
needParens
)
{
this
-
>
write
(
"
)
"
)
;
}
}
void
WGSLCodeGenerator
:
:
writeFieldAccess
(
const
FieldAccess
&
f
)
{
const
Type
:
:
Field
*
field
=
&
f
.
base
(
)
-
>
type
(
)
.
fields
(
)
[
f
.
fieldIndex
(
)
]
;
if
(
FieldAccess
:
:
OwnerKind
:
:
kDefault
=
=
f
.
ownerKind
(
)
)
{
this
-
>
writeExpression
(
*
f
.
base
(
)
Precedence
:
:
kPostfix
)
;
this
-
>
write
(
"
.
"
)
;
}
else
{
const
Variable
&
v
=
*
f
.
base
(
)
-
>
as
<
VariableReference
>
(
)
.
variable
(
)
;
if
(
v
.
modifiers
(
)
.
fFlags
&
Modifiers
:
:
kIn_Flag
)
{
this
-
>
write
(
"
_stageIn
.
"
)
;
}
else
if
(
v
.
modifiers
(
)
.
fFlags
&
Modifiers
:
:
kOut_Flag
&
&
field
-
>
fModifiers
.
fLayout
.
fBuiltin
!
=
SK_POINTSIZE_BUILTIN
)
{
this
-
>
write
(
"
(
*
_stageOut
)
.
"
)
;
}
else
{
}
}
this
-
>
writeName
(
field
-
>
fName
)
;
}
void
WGSLCodeGenerator
:
:
writeFunctionCall
(
const
FunctionCall
&
c
)
{
const
FunctionDeclaration
&
func
=
c
.
function
(
)
;
const
ExpressionArray
&
args
=
c
.
arguments
(
)
;
const
std
:
:
vector
<
Variable
*
>
&
params
=
func
.
parameters
(
)
;
SkASSERT
(
SkToSizeT
(
args
.
size
(
)
)
=
=
params
.
size
(
)
)
;
bool
foundOutParam
=
false
;
SkSTArray
<
16
VariableReference
*
>
outVars
;
outVars
.
push_back_n
(
args
.
size
(
)
static_cast
<
VariableReference
*
>
(
nullptr
)
)
;
for
(
int
i
=
0
;
i
<
args
.
size
(
)
;
+
+
i
)
{
if
(
params
[
i
]
-
>
modifiers
(
)
.
fFlags
&
Modifiers
:
:
kOut_Flag
)
{
Analysis
:
:
AssignmentInfo
info
;
SkAssertResult
(
Analysis
:
:
IsAssignable
(
*
args
[
i
]
&
info
)
)
;
outVars
[
i
]
=
info
.
fAssignedVar
;
foundOutParam
=
true
;
}
}
if
(
foundOutParam
)
{
this
-
>
writeName
(
this
-
>
writeOutParamHelper
(
c
args
outVars
)
)
;
}
else
{
this
-
>
writeName
(
func
.
mangledName
(
)
)
;
}
this
-
>
write
(
"
(
"
)
;
auto
separator
=
SkSL
:
:
String
:
:
Separator
(
)
;
if
(
this
-
>
writeFunctionDependencyArgs
(
func
)
)
{
separator
(
)
;
}
for
(
int
i
=
0
;
i
<
args
.
size
(
)
;
+
+
i
)
{
this
-
>
write
(
separator
(
)
)
;
if
(
outVars
[
i
]
)
{
this
-
>
write
(
"
&
"
)
;
this
-
>
writeExpression
(
*
outVars
[
i
]
Precedence
:
:
kSequence
)
;
}
else
{
this
-
>
writeExpression
(
*
args
[
i
]
Precedence
:
:
kSequence
)
;
}
}
this
-
>
write
(
"
)
"
)
;
}
void
WGSLCodeGenerator
:
:
writeIndexExpression
(
const
IndexExpression
&
i
)
{
this
-
>
writeExpression
(
*
i
.
base
(
)
Precedence
:
:
kPostfix
)
;
this
-
>
write
(
"
[
"
)
;
this
-
>
writeExpression
(
*
i
.
index
(
)
Precedence
:
:
kTopLevel
)
;
this
-
>
write
(
"
]
"
)
;
}
void
WGSLCodeGenerator
:
:
writeLiteral
(
const
Literal
&
l
)
{
const
Type
&
type
=
l
.
type
(
)
;
if
(
type
.
isFloat
(
)
|
|
type
.
isBoolean
(
)
)
{
this
-
>
write
(
l
.
description
(
OperatorPrecedence
:
:
kTopLevel
)
)
;
return
;
}
SkASSERT
(
type
.
isInteger
(
)
)
;
if
(
type
.
matches
(
*
fContext
.
fTypes
.
fUInt
)
)
{
this
-
>
write
(
std
:
:
to_string
(
l
.
intValue
(
)
&
0xffffffff
)
)
;
this
-
>
write
(
"
u
"
)
;
}
else
if
(
type
.
matches
(
*
fContext
.
fTypes
.
fUShort
)
)
{
this
-
>
write
(
std
:
:
to_string
(
l
.
intValue
(
)
&
0xffff
)
)
;
this
-
>
write
(
"
u
"
)
;
}
else
{
this
-
>
write
(
std
:
:
to_string
(
l
.
intValue
(
)
)
)
;
}
}
void
WGSLCodeGenerator
:
:
writeSwizzle
(
const
Swizzle
&
swizzle
)
{
this
-
>
writeExpression
(
*
swizzle
.
base
(
)
Precedence
:
:
kPostfix
)
;
this
-
>
write
(
"
.
"
)
;
for
(
int
c
:
swizzle
.
components
(
)
)
{
SkASSERT
(
c
>
=
0
&
&
c
<
=
3
)
;
this
-
>
write
(
&
(
"
x
\
0y
\
0z
\
0w
\
0
"
[
c
*
2
]
)
)
;
}
}
void
WGSLCodeGenerator
:
:
writeTernaryExpression
(
const
TernaryExpression
&
t
Precedence
parentPrecedence
)
{
bool
needParens
=
Precedence
:
:
kTernary
>
=
parentPrecedence
;
if
(
needParens
)
{
this
-
>
write
(
"
(
"
)
;
}
if
(
(
t
.
type
(
)
.
isScalar
(
)
|
|
t
.
type
(
)
.
isVector
(
)
)
&
&
!
Analysis
:
:
HasSideEffects
(
*
t
.
ifTrue
(
)
)
&
&
!
Analysis
:
:
HasSideEffects
(
*
t
.
ifFalse
(
)
)
)
{
this
-
>
write
(
"
select
(
"
)
;
this
-
>
writeExpression
(
*
t
.
ifFalse
(
)
Precedence
:
:
kTernary
)
;
this
-
>
write
(
"
"
)
;
this
-
>
writeExpression
(
*
t
.
ifTrue
(
)
Precedence
:
:
kTernary
)
;
this
-
>
write
(
"
"
)
;
bool
isVector
=
t
.
type
(
)
.
isVector
(
)
;
if
(
isVector
)
{
this
-
>
write
(
String
:
:
printf
(
"
vec
%
d
<
bool
>
(
"
t
.
type
(
)
.
columns
(
)
)
)
;
}
this
-
>
writeExpression
(
*
t
.
test
(
)
Precedence
:
:
kTernary
)
;
if
(
isVector
)
{
this
-
>
write
(
"
)
"
)
;
}
this
-
>
write
(
"
)
"
)
;
if
(
needParens
)
{
this
-
>
write
(
"
)
"
)
;
}
return
;
}
}
void
WGSLCodeGenerator
:
:
writeVariableReference
(
const
VariableReference
&
r
)
{
const
Variable
&
v
=
*
r
.
variable
(
)
;
std
:
:
optional
<
std
:
:
string_view
>
conversion
=
needs_builtin_type_conversion
(
v
)
;
if
(
conversion
.
has_value
(
)
)
{
this
-
>
write
(
*
conversion
)
;
this
-
>
write
(
"
(
"
)
;
}
bool
needsDeref
=
false
;
bool
isSynthesizedOutParamArg
=
fOutParamArgVars
.
contains
(
&
v
)
;
if
(
v
.
storage
(
)
=
=
Variable
:
:
Storage
:
:
kGlobal
&
&
!
isSynthesizedOutParamArg
)
{
if
(
v
.
modifiers
(
)
.
fFlags
&
Modifiers
:
:
kIn_Flag
)
{
this
-
>
write
(
"
_stageIn
.
"
)
;
}
else
if
(
v
.
modifiers
(
)
.
fFlags
&
Modifiers
:
:
kOut_Flag
)
{
this
-
>
write
(
"
(
*
_stageOut
)
.
"
)
;
}
else
if
(
is_in_global_uniforms
(
v
)
)
{
this
-
>
write
(
"
_globalUniforms
.
"
)
;
}
}
else
if
(
(
v
.
storage
(
)
=
=
Variable
:
:
Storage
:
:
kParameter
&
&
v
.
modifiers
(
)
.
fFlags
&
Modifiers
:
:
kOut_Flag
)
|
|
isSynthesizedOutParamArg
)
{
needsDeref
=
true
;
this
-
>
write
(
"
(
*
"
)
;
}
this
-
>
writeName
(
v
.
mangledName
(
)
)
;
if
(
needsDeref
)
{
this
-
>
write
(
"
)
"
)
;
}
if
(
conversion
.
has_value
(
)
)
{
this
-
>
write
(
"
)
"
)
;
}
}
void
WGSLCodeGenerator
:
:
writeAnyConstructor
(
const
AnyConstructor
&
c
Precedence
parentPrecedence
)
{
this
-
>
write
(
to_wgsl_type
(
c
.
type
(
)
)
)
;
this
-
>
write
(
"
(
"
)
;
auto
separator
=
SkSL
:
:
String
:
:
Separator
(
)
;
for
(
const
auto
&
e
:
c
.
argumentSpan
(
)
)
{
this
-
>
write
(
separator
(
)
)
;
this
-
>
writeExpression
(
*
e
Precedence
:
:
kSequence
)
;
}
this
-
>
write
(
"
)
"
)
;
}
void
WGSLCodeGenerator
:
:
writeConstructorCompound
(
const
ConstructorCompound
&
c
Precedence
parentPrecedence
)
{
if
(
c
.
type
(
)
.
isVector
(
)
)
{
this
-
>
writeConstructorCompoundVector
(
c
parentPrecedence
)
;
}
else
if
(
c
.
type
(
)
.
isMatrix
(
)
)
{
this
-
>
writeConstructorCompoundMatrix
(
c
parentPrecedence
)
;
}
else
{
fContext
.
fErrors
-
>
error
(
c
.
fPosition
"
unsupported
compound
constructor
"
)
;
}
}
void
WGSLCodeGenerator
:
:
writeConstructorCompoundVector
(
const
ConstructorCompound
&
c
Precedence
parentPrecedence
)
{
if
(
c
.
type
(
)
.
columns
(
)
=
=
4
&
&
c
.
argumentSpan
(
)
.
size
(
)
=
=
1
)
{
const
Expression
&
arg
=
*
c
.
argumentSpan
(
)
.
front
(
)
;
if
(
arg
.
type
(
)
.
isMatrix
(
)
)
{
SkASSERT
(
arg
.
type
(
)
.
columns
(
)
=
=
2
)
;
SkASSERT
(
arg
.
type
(
)
.
rows
(
)
=
=
2
)
;
std
:
:
string
name
=
String
:
:
printf
(
"
%
s_from_
%
s
"
to_mangled_wgsl_type_name
(
c
.
type
(
)
)
.
c_str
(
)
to_mangled_wgsl_type_name
(
arg
.
type
(
)
)
.
c_str
(
)
)
;
if
(
!
fHelpers
.
contains
(
name
)
)
{
fHelpers
.
add
(
name
)
;
std
:
:
string
returnType
=
to_wgsl_type
(
c
.
type
(
)
)
;
std
:
:
string
argType
=
to_wgsl_type
(
arg
.
type
(
)
)
;
fExtraFunctions
.
printf
(
"
fn
%
s
(
x
:
%
s
)
-
>
%
s
{
\
n
return
%
s
(
x
[
0
]
.
xy
x
[
1
]
.
xy
)
;
\
n
}
\
n
"
name
.
c_str
(
)
argType
.
c_str
(
)
returnType
.
c_str
(
)
returnType
.
c_str
(
)
)
;
}
this
-
>
write
(
name
)
;
this
-
>
write
(
"
(
"
)
;
this
-
>
writeExpression
(
arg
Precedence
:
:
kSequence
)
;
this
-
>
write
(
"
)
"
)
;
return
;
}
}
this
-
>
writeAnyConstructor
(
c
parentPrecedence
)
;
}
void
WGSLCodeGenerator
:
:
writeConstructorCompoundMatrix
(
const
ConstructorCompound
&
c
Precedence
parentPrecedence
)
{
SkASSERT
(
c
.
type
(
)
.
isMatrix
(
)
)
;
if
(
this
-
>
isMatrixConstructorHelperNeeded
(
c
)
)
{
this
-
>
write
(
this
-
>
getMatrixConstructorHelper
(
c
)
)
;
this
-
>
write
(
"
(
"
)
;
auto
separator
=
String
:
:
Separator
(
)
;
for
(
const
std
:
:
unique_ptr
<
Expression
>
&
expr
:
c
.
arguments
(
)
)
{
this
-
>
write
(
separator
(
)
)
;
this
-
>
writeExpression
(
*
expr
Precedence
:
:
kSequence
)
;
}
this
-
>
write
(
"
)
"
)
;
return
;
}
const
Type
&
matrixType
=
c
.
type
(
)
;
const
Type
&
columnType
=
matrixType
.
componentType
(
)
.
toCompound
(
fContext
matrixType
.
rows
(
)
1
)
;
this
-
>
write
(
to_wgsl_type
(
matrixType
)
)
;
this
-
>
write
(
"
(
"
)
;
auto
separator
=
String
:
:
Separator
(
)
;
int
scalarCount
=
0
;
for
(
const
std
:
:
unique_ptr
<
Expression
>
&
arg
:
c
.
arguments
(
)
)
{
this
-
>
write
(
separator
(
)
)
;
if
(
arg
-
>
type
(
)
.
columns
(
)
<
matrixType
.
rows
(
)
)
{
if
(
!
scalarCount
)
{
this
-
>
write
(
to_wgsl_type
(
columnType
)
)
;
this
-
>
write
(
"
(
"
)
;
}
scalarCount
+
=
arg
-
>
type
(
)
.
columns
(
)
;
}
this
-
>
writeExpression
(
*
arg
Precedence
:
:
kSequence
)
;
if
(
scalarCount
&
&
scalarCount
=
=
matrixType
.
rows
(
)
)
{
this
-
>
write
(
"
)
"
)
;
scalarCount
=
0
;
}
}
this
-
>
write
(
"
)
"
)
;
}
void
WGSLCodeGenerator
:
:
writeConstructorDiagonalMatrix
(
const
ConstructorDiagonalMatrix
&
c
Precedence
parentPrecedence
)
{
const
Type
&
type
=
c
.
type
(
)
;
SkASSERT
(
type
.
isMatrix
(
)
)
;
SkASSERT
(
c
.
argument
(
)
-
>
type
(
)
.
isScalar
(
)
)
;
std
:
:
string
name
=
String
:
:
printf
(
"
%
s_diagonal
"
to_mangled_wgsl_type_name
(
type
)
.
c_str
(
)
)
;
if
(
!
fHelpers
.
contains
(
name
)
)
{
fHelpers
.
add
(
name
)
;
std
:
:
string
typeName
=
to_wgsl_type
(
type
)
;
fExtraFunctions
.
printf
(
"
fn
%
s
(
x
:
%
s
)
-
>
%
s
{
\
n
"
name
.
c_str
(
)
to_wgsl_type
(
c
.
argument
(
)
-
>
type
(
)
)
.
c_str
(
)
typeName
.
c_str
(
)
)
;
fExtraFunctions
.
printf
(
"
return
%
s
(
"
typeName
.
c_str
(
)
)
;
auto
separator
=
String
:
:
Separator
(
)
;
for
(
int
col
=
0
;
col
<
type
.
columns
(
)
;
+
+
col
)
{
for
(
int
row
=
0
;
row
<
type
.
rows
(
)
;
+
+
row
)
{
fExtraFunctions
.
printf
(
"
%
s
%
s
"
separator
(
)
.
c_str
(
)
(
col
=
=
row
)
?
"
x
"
:
"
0
.
0
"
)
;
}
}
fExtraFunctions
.
printf
(
"
)
;
\
n
}
\
n
"
)
;
}
this
-
>
write
(
name
)
;
this
-
>
write
(
"
(
"
)
;
this
-
>
writeExpression
(
*
c
.
argument
(
)
Precedence
:
:
kSequence
)
;
this
-
>
write
(
"
)
"
)
;
}
void
WGSLCodeGenerator
:
:
writeConstructorMatrixResize
(
const
ConstructorMatrixResize
&
c
Precedence
parentPrecedence
)
{
this
-
>
write
(
this
-
>
getMatrixConstructorHelper
(
c
)
)
;
this
-
>
write
(
"
(
"
)
;
this
-
>
writeExpression
(
*
c
.
argument
(
)
Precedence
:
:
kSequence
)
;
this
-
>
write
(
"
)
"
)
;
}
bool
WGSLCodeGenerator
:
:
isMatrixConstructorHelperNeeded
(
const
ConstructorCompound
&
c
)
{
int
position
=
0
;
for
(
const
std
:
:
unique_ptr
<
Expression
>
&
expr
:
c
.
arguments
(
)
)
{
if
(
expr
-
>
type
(
)
.
isMatrix
(
)
)
{
return
true
;
}
position
+
=
expr
-
>
type
(
)
.
columns
(
)
;
if
(
position
>
c
.
type
(
)
.
rows
(
)
)
{
return
true
;
}
if
(
position
=
=
c
.
type
(
)
.
rows
(
)
)
{
position
=
0
;
}
}
return
false
;
}
std
:
:
string
WGSLCodeGenerator
:
:
getMatrixConstructorHelper
(
const
AnyConstructor
&
c
)
{
const
Type
&
type
=
c
.
type
(
)
;
int
columns
=
type
.
columns
(
)
;
int
rows
=
type
.
rows
(
)
;
auto
args
=
c
.
argumentSpan
(
)
;
std
:
:
string
typeName
=
to_wgsl_type
(
type
)
;
std
:
:
string
name
=
String
:
:
printf
(
"
%
s_from
"
to_mangled_wgsl_type_name
(
type
)
.
c_str
(
)
)
;
for
(
const
std
:
:
unique_ptr
<
Expression
>
&
expr
:
args
)
{
String
:
:
appendf
(
&
name
"
_
%
s
"
to_mangled_wgsl_type_name
(
expr
-
>
type
(
)
)
.
c_str
(
)
)
;
}
if
(
!
fHelpers
.
contains
(
name
)
)
{
fHelpers
.
add
(
name
)
;
fExtraFunctions
.
printf
(
"
fn
%
s
(
"
name
.
c_str
(
)
)
;
auto
separator
=
String
:
:
Separator
(
)
;
for
(
size_t
i
=
0
;
i
<
args
.
size
(
)
;
+
+
i
)
{
fExtraFunctions
.
printf
(
"
%
sx
%
zu
:
%
s
"
separator
(
)
.
c_str
(
)
i
to_wgsl_type
(
args
[
i
]
-
>
type
(
)
)
.
c_str
(
)
)
;
}
fExtraFunctions
.
printf
(
"
)
-
>
%
s
{
\
n
return
%
s
(
"
typeName
.
c_str
(
)
typeName
.
c_str
(
)
)
;
if
(
args
.
size
(
)
=
=
1
&
&
args
.
front
(
)
-
>
type
(
)
.
isMatrix
(
)
)
{
this
-
>
writeMatrixFromMatrixArgs
(
args
.
front
(
)
-
>
type
(
)
columns
rows
)
;
}
else
{
this
-
>
writeMatrixFromScalarAndVectorArgs
(
c
columns
rows
)
;
}
fExtraFunctions
.
writeText
(
"
)
;
\
n
}
\
n
"
)
;
}
return
name
;
}
void
WGSLCodeGenerator
:
:
writeMatrixFromMatrixArgs
(
const
Type
&
sourceMatrix
int
columns
int
rows
)
{
SkASSERT
(
rows
<
=
4
)
;
SkASSERT
(
columns
<
=
4
)
;
const
char
*
separator
=
"
"
;
std
:
:
string
matrixType
=
to_wgsl_type
(
sourceMatrix
.
componentType
(
)
)
;
for
(
int
c
=
0
;
c
<
columns
;
+
+
c
)
{
fExtraFunctions
.
printf
(
"
%
svec
%
d
<
%
s
>
(
"
separator
rows
matrixType
.
c_str
(
)
)
;
separator
=
"
)
"
;
int
swizzleLength
=
0
;
if
(
c
<
sourceMatrix
.
columns
(
)
)
{
swizzleLength
=
std
:
:
min
<
>
(
rows
sourceMatrix
.
rows
(
)
)
;
}
bool
firstItem
;
switch
(
swizzleLength
)
{
case
0
:
firstItem
=
true
;
break
;
case
1
:
firstItem
=
false
;
fExtraFunctions
.
printf
(
"
x0
[
%
d
]
.
x
"
c
)
;
break
;
case
2
:
firstItem
=
false
;
fExtraFunctions
.
printf
(
"
x0
[
%
d
]
.
xy
"
c
)
;
break
;
case
3
:
firstItem
=
false
;
fExtraFunctions
.
printf
(
"
x0
[
%
d
]
.
xyz
"
c
)
;
break
;
case
4
:
firstItem
=
false
;
fExtraFunctions
.
printf
(
"
x0
[
%
d
]
.
xyzw
"
c
)
;
break
;
default
:
SkUNREACHABLE
;
}
for
(
int
r
=
swizzleLength
;
r
<
rows
;
+
+
r
)
{
fExtraFunctions
.
printf
(
"
%
s
%
s
"
firstItem
?
"
"
:
"
"
(
r
=
=
c
)
?
"
1
.
0
"
:
"
0
.
0
"
)
;
firstItem
=
false
;
}
}
fExtraFunctions
.
writeText
(
"
)
"
)
;
}
void
WGSLCodeGenerator
:
:
writeMatrixFromScalarAndVectorArgs
(
const
AnyConstructor
&
ctor
int
columns
int
rows
)
{
SkASSERT
(
rows
<
=
4
)
;
SkASSERT
(
columns
<
=
4
)
;
std
:
:
string
matrixType
=
to_wgsl_type
(
ctor
.
type
(
)
.
componentType
(
)
)
;
size_t
argIndex
=
0
;
int
argPosition
=
0
;
auto
args
=
ctor
.
argumentSpan
(
)
;
static
constexpr
char
kSwizzle
[
]
=
"
xyzw
"
;
const
char
*
separator
=
"
"
;
for
(
int
c
=
0
;
c
<
columns
;
+
+
c
)
{
fExtraFunctions
.
printf
(
"
%
svec
%
d
<
%
s
>
(
"
separator
rows
matrixType
.
c_str
(
)
)
;
separator
=
"
)
"
;
auto
columnSeparator
=
String
:
:
Separator
(
)
;
for
(
int
r
=
0
;
r
<
rows
;
)
{
fExtraFunctions
.
writeText
(
columnSeparator
(
)
.
c_str
(
)
)
;
if
(
argIndex
<
args
.
size
(
)
)
{
const
Type
&
argType
=
args
[
argIndex
]
-
>
type
(
)
;
switch
(
argType
.
typeKind
(
)
)
{
case
Type
:
:
TypeKind
:
:
kScalar
:
{
fExtraFunctions
.
printf
(
"
x
%
zu
"
argIndex
)
;
+
+
r
;
+
+
argPosition
;
break
;
}
case
Type
:
:
TypeKind
:
:
kVector
:
{
fExtraFunctions
.
printf
(
"
x
%
zu
.
"
argIndex
)
;
do
{
fExtraFunctions
.
write8
(
kSwizzle
[
argPosition
]
)
;
+
+
r
;
+
+
argPosition
;
}
while
(
r
<
rows
&
&
argPosition
<
argType
.
columns
(
)
)
;
break
;
}
case
Type
:
:
TypeKind
:
:
kMatrix
:
{
fExtraFunctions
.
printf
(
"
x
%
zu
[
%
d
]
.
"
argIndex
argPosition
/
argType
.
rows
(
)
)
;
do
{
fExtraFunctions
.
write8
(
kSwizzle
[
argPosition
]
)
;
+
+
r
;
+
+
argPosition
;
}
while
(
r
<
rows
&
&
(
argPosition
%
argType
.
rows
(
)
)
!
=
0
)
;
break
;
}
default
:
{
SkDEBUGFAIL
(
"
incorrect
type
of
argument
for
matrix
constructor
"
)
;
fExtraFunctions
.
writeText
(
"
<
error
>
"
)
;
break
;
}
}
if
(
argPosition
>
=
argType
.
columns
(
)
*
argType
.
rows
(
)
)
{
+
+
argIndex
;
argPosition
=
0
;
}
}
else
{
SkDEBUGFAIL
(
"
not
enough
arguments
for
matrix
constructor
"
)
;
fExtraFunctions
.
writeText
(
"
<
error
>
"
)
;
}
}
}
if
(
argPosition
!
=
0
|
|
argIndex
!
=
args
.
size
(
)
)
{
SkDEBUGFAIL
(
"
incorrect
number
of
arguments
for
matrix
constructor
"
)
;
fExtraFunctions
.
writeText
(
"
<
error
>
"
)
;
}
fExtraFunctions
.
writeText
(
"
)
"
)
;
}
void
WGSLCodeGenerator
:
:
writeMatrixEquality
(
const
Expression
&
left
const
Expression
&
right
)
{
const
Type
&
leftType
=
left
.
type
(
)
;
const
Type
&
rightType
=
right
.
type
(
)
;
SkASSERT
(
leftType
.
isMatrix
(
)
)
;
SkASSERT
(
rightType
.
isMatrix
(
)
)
;
SkASSERT
(
leftType
.
rows
(
)
=
=
rightType
.
rows
(
)
)
;
SkASSERT
(
leftType
.
columns
(
)
=
=
rightType
.
columns
(
)
)
;
std
:
:
string
name
=
String
:
:
printf
(
"
%
s_eq_
%
s
"
to_mangled_wgsl_type_name
(
leftType
)
.
c_str
(
)
to_mangled_wgsl_type_name
(
rightType
)
.
c_str
(
)
)
;
if
(
!
fHelpers
.
contains
(
name
)
)
{
fHelpers
.
add
(
name
)
;
fExtraFunctions
.
printf
(
"
fn
%
s
(
left
:
%
s
right
:
%
s
)
-
>
bool
{
\
n
return
"
name
.
c_str
(
)
to_wgsl_type
(
leftType
)
.
c_str
(
)
to_wgsl_type
(
rightType
)
.
c_str
(
)
)
;
const
char
*
separator
=
"
"
;
for
(
int
i
=
0
;
i
<
leftType
.
columns
(
)
;
+
+
i
)
{
fExtraFunctions
.
printf
(
"
%
sall
(
left
[
%
d
]
=
=
right
[
%
d
]
)
"
separator
i
i
)
;
separator
=
"
&
&
\
n
"
;
}
fExtraFunctions
.
printf
(
"
;
\
n
}
\
n
"
)
;
}
this
-
>
write
(
name
)
;
this
-
>
write
(
"
(
"
)
;
this
-
>
writeExpression
(
left
Precedence
:
:
kSequence
)
;
this
-
>
write
(
"
"
)
;
this
-
>
writeExpression
(
right
Precedence
:
:
kSequence
)
;
this
-
>
write
(
"
)
"
)
;
}
void
WGSLCodeGenerator
:
:
writeProgramElement
(
const
ProgramElement
&
e
)
{
switch
(
e
.
kind
(
)
)
{
case
ProgramElement
:
:
Kind
:
:
kExtension
:
break
;
case
ProgramElement
:
:
Kind
:
:
kGlobalVar
:
this
-
>
writeGlobalVarDeclaration
(
e
.
as
<
GlobalVarDeclaration
>
(
)
)
;
break
;
case
ProgramElement
:
:
Kind
:
:
kInterfaceBlock
:
break
;
case
ProgramElement
:
:
Kind
:
:
kStructDefinition
:
this
-
>
writeStructDefinition
(
e
.
as
<
StructDefinition
>
(
)
)
;
break
;
case
ProgramElement
:
:
Kind
:
:
kFunctionPrototype
:
break
;
case
ProgramElement
:
:
Kind
:
:
kFunction
:
this
-
>
writeFunction
(
e
.
as
<
FunctionDefinition
>
(
)
)
;
break
;
default
:
SkDEBUGFAILF
(
"
unsupported
program
element
:
%
s
\
n
"
e
.
description
(
)
.
c_str
(
)
)
;
break
;
}
}
void
WGSLCodeGenerator
:
:
writeGlobalVarDeclaration
(
const
GlobalVarDeclaration
&
d
)
{
const
Variable
&
var
=
*
d
.
declaration
(
)
-
>
as
<
VarDeclaration
>
(
)
.
var
(
)
;
if
(
(
var
.
modifiers
(
)
.
fFlags
&
(
Modifiers
:
:
kIn_Flag
|
Modifiers
:
:
kOut_Flag
)
)
|
|
is_in_global_uniforms
(
var
)
)
{
return
;
}
this
-
>
write
(
"
var
<
private
>
"
)
;
this
-
>
writeVariableDecl
(
var
.
type
(
)
var
.
name
(
)
Delimiter
:
:
kSemicolon
)
;
}
void
WGSLCodeGenerator
:
:
writeStructDefinition
(
const
StructDefinition
&
s
)
{
const
Type
&
type
=
s
.
type
(
)
;
this
-
>
writeLine
(
"
struct
"
+
type
.
displayName
(
)
+
"
{
"
)
;
fIndentation
+
+
;
this
-
>
writeFields
(
SkSpan
(
type
.
fields
(
)
)
type
.
fPosition
)
;
fIndentation
-
-
;
this
-
>
writeLine
(
"
}
;
"
)
;
}
void
WGSLCodeGenerator
:
:
writeFields
(
SkSpan
<
const
Type
:
:
Field
>
fields
Position
parentPos
const
MemoryLayout
*
)
{
for
(
const
Type
:
:
Field
&
field
:
fields
)
{
const
Type
*
fieldType
=
field
.
fType
;
this
-
>
writeVariableDecl
(
*
fieldType
field
.
fName
Delimiter
:
:
kComma
)
;
}
}
void
WGSLCodeGenerator
:
:
writeStageInputStruct
(
)
{
std
:
:
string_view
structNamePrefix
=
pipeline_struct_prefix
(
fProgram
.
fConfig
-
>
fKind
)
;
if
(
structNamePrefix
.
empty
(
)
)
{
return
;
}
if
(
fPipelineInputCount
<
1
)
{
return
;
}
this
-
>
write
(
"
struct
"
)
;
this
-
>
write
(
structNamePrefix
)
;
this
-
>
writeLine
(
"
In
{
"
)
;
fIndentation
+
+
;
bool
declaredFragCoordsBuiltin
=
false
;
for
(
const
ProgramElement
*
e
:
fProgram
.
elements
(
)
)
{
if
(
e
-
>
is
<
GlobalVarDeclaration
>
(
)
)
{
const
Variable
*
v
=
e
-
>
as
<
GlobalVarDeclaration
>
(
)
.
declaration
(
)
-
>
as
<
VarDeclaration
>
(
)
.
var
(
)
;
if
(
v
-
>
modifiers
(
)
.
fFlags
&
Modifiers
:
:
kIn_Flag
)
{
this
-
>
writePipelineIODeclaration
(
v
-
>
modifiers
(
)
v
-
>
type
(
)
v
-
>
mangledName
(
)
Delimiter
:
:
kComma
)
;
if
(
v
-
>
modifiers
(
)
.
fLayout
.
fBuiltin
=
=
SK_FRAGCOORD_BUILTIN
)
{
declaredFragCoordsBuiltin
=
true
;
}
}
}
else
if
(
e
-
>
is
<
InterfaceBlock
>
(
)
)
{
const
Variable
*
v
=
e
-
>
as
<
InterfaceBlock
>
(
)
.
var
(
)
;
if
(
v
-
>
modifiers
(
)
.
fFlags
&
Modifiers
:
:
kIn_Flag
)
{
for
(
const
auto
&
f
:
v
-
>
type
(
)
.
fields
(
)
)
{
this
-
>
writePipelineIODeclaration
(
f
.
fModifiers
*
f
.
fType
f
.
fName
Delimiter
:
:
kComma
)
;
if
(
f
.
fModifiers
.
fLayout
.
fBuiltin
=
=
SK_FRAGCOORD_BUILTIN
)
{
declaredFragCoordsBuiltin
=
true
;
}
}
}
}
}
if
(
ProgramConfig
:
:
IsFragment
(
fProgram
.
fConfig
-
>
fKind
)
&
&
fRequirements
.
mainNeedsCoordsArgument
&
&
!
declaredFragCoordsBuiltin
)
{
this
-
>
writeLine
(
"
builtin
(
position
)
sk_FragCoord
:
vec4
<
f32
>
"
)
;
}
fIndentation
-
-
;
this
-
>
writeLine
(
"
}
;
"
)
;
}
void
WGSLCodeGenerator
:
:
writeStageOutputStruct
(
)
{
std
:
:
string_view
structNamePrefix
=
pipeline_struct_prefix
(
fProgram
.
fConfig
-
>
fKind
)
;
if
(
structNamePrefix
.
empty
(
)
)
{
return
;
}
this
-
>
write
(
"
struct
"
)
;
this
-
>
write
(
structNamePrefix
)
;
this
-
>
writeLine
(
"
Out
{
"
)
;
fIndentation
+
+
;
bool
declaredPositionBuiltin
=
false
;
bool
requiresPointSizeBuiltin
=
false
;
for
(
const
ProgramElement
*
e
:
fProgram
.
elements
(
)
)
{
if
(
e
-
>
is
<
GlobalVarDeclaration
>
(
)
)
{
const
Variable
*
v
=
e
-
>
as
<
GlobalVarDeclaration
>
(
)
.
declaration
(
)
-
>
as
<
VarDeclaration
>
(
)
.
var
(
)
;
if
(
v
-
>
modifiers
(
)
.
fFlags
&
Modifiers
:
:
kOut_Flag
)
{
this
-
>
writePipelineIODeclaration
(
v
-
>
modifiers
(
)
v
-
>
type
(
)
v
-
>
mangledName
(
)
Delimiter
:
:
kComma
)
;
}
}
else
if
(
e
-
>
is
<
InterfaceBlock
>
(
)
)
{
const
Variable
*
v
=
e
-
>
as
<
InterfaceBlock
>
(
)
.
var
(
)
;
if
(
v
-
>
modifiers
(
)
.
fFlags
&
Modifiers
:
:
kOut_Flag
)
{
for
(
const
auto
&
f
:
v
-
>
type
(
)
.
fields
(
)
)
{
this
-
>
writePipelineIODeclaration
(
f
.
fModifiers
*
f
.
fType
f
.
fName
Delimiter
:
:
kComma
)
;
if
(
f
.
fModifiers
.
fLayout
.
fBuiltin
=
=
SK_POSITION_BUILTIN
)
{
declaredPositionBuiltin
=
true
;
}
else
if
(
f
.
fModifiers
.
fLayout
.
fBuiltin
=
=
SK_POINTSIZE_BUILTIN
)
{
requiresPointSizeBuiltin
=
true
;
}
}
}
}
}
if
(
ProgramConfig
:
:
IsVertex
(
fProgram
.
fConfig
-
>
fKind
)
&
&
!
declaredPositionBuiltin
)
{
this
-
>
writeLine
(
"
builtin
(
position
)
sk_Position
:
vec4
<
f32
>
"
)
;
}
fIndentation
-
-
;
this
-
>
writeLine
(
"
}
;
"
)
;
if
(
ProgramConfig
:
:
IsVertex
(
fProgram
.
fConfig
-
>
fKind
)
&
&
requiresPointSizeBuiltin
)
{
this
-
>
writeLine
(
"
/
*
unsupported
*
/
var
<
private
>
sk_PointSize
:
f32
;
"
)
;
}
}
void
WGSLCodeGenerator
:
:
writeNonBlockUniformsForTests
(
)
{
for
(
const
ProgramElement
*
e
:
fProgram
.
elements
(
)
)
{
if
(
e
-
>
is
<
GlobalVarDeclaration
>
(
)
)
{
const
GlobalVarDeclaration
&
decls
=
e
-
>
as
<
GlobalVarDeclaration
>
(
)
;
const
Variable
&
var
=
*
decls
.
varDeclaration
(
)
.
var
(
)
;
if
(
is_in_global_uniforms
(
var
)
)
{
if
(
!
fDeclaredUniformsStruct
)
{
this
-
>
write
(
"
struct
_GlobalUniforms
{
\
n
"
)
;
fDeclaredUniformsStruct
=
true
;
}
this
-
>
write
(
"
"
)
;
this
-
>
writeVariableDecl
(
var
.
type
(
)
var
.
mangledName
(
)
Delimiter
:
:
kComma
)
;
}
}
}
if
(
fDeclaredUniformsStruct
)
{
int
binding
=
fProgram
.
fConfig
-
>
fSettings
.
fDefaultUniformBinding
;
int
set
=
fProgram
.
fConfig
-
>
fSettings
.
fDefaultUniformSet
;
this
-
>
write
(
"
}
;
\
n
"
)
;
this
-
>
write
(
"
binding
(
"
+
std
:
:
to_string
(
binding
)
+
"
)
"
)
;
this
-
>
write
(
"
group
(
"
+
std
:
:
to_string
(
set
)
+
"
)
"
)
;
this
-
>
writeLine
(
"
var
<
uniform
>
_globalUniforms
:
_GlobalUniforms
;
"
)
;
}
}
bool
WGSLCodeGenerator
:
:
writeFunctionDependencyArgs
(
const
FunctionDeclaration
&
f
)
{
FunctionDependencies
*
deps
=
fRequirements
.
dependencies
.
find
(
&
f
)
;
if
(
!
deps
|
|
*
deps
=
=
FunctionDependencies
:
:
kNone
)
{
return
false
;
}
const
char
*
separator
=
"
"
;
if
(
(
*
deps
&
FunctionDependencies
:
:
kPipelineInputs
)
!
=
FunctionDependencies
:
:
kNone
)
{
this
-
>
write
(
"
_stageIn
"
)
;
separator
=
"
"
;
}
if
(
(
*
deps
&
FunctionDependencies
:
:
kPipelineOutputs
)
!
=
FunctionDependencies
:
:
kNone
)
{
this
-
>
write
(
separator
)
;
this
-
>
write
(
"
_stageOut
"
)
;
}
return
true
;
}
bool
WGSLCodeGenerator
:
:
writeFunctionDependencyParams
(
const
FunctionDeclaration
&
f
)
{
FunctionDependencies
*
deps
=
fRequirements
.
dependencies
.
find
(
&
f
)
;
if
(
!
deps
|
|
*
deps
=
=
FunctionDependencies
:
:
kNone
)
{
return
false
;
}
std
:
:
string_view
structNamePrefix
=
pipeline_struct_prefix
(
fProgram
.
fConfig
-
>
fKind
)
;
if
(
structNamePrefix
.
empty
(
)
)
{
return
false
;
}
const
char
*
separator
=
"
"
;
if
(
(
*
deps
&
FunctionDependencies
:
:
kPipelineInputs
)
!
=
FunctionDependencies
:
:
kNone
)
{
this
-
>
write
(
"
_stageIn
:
"
)
;
separator
=
"
"
;
this
-
>
write
(
structNamePrefix
)
;
this
-
>
write
(
"
In
"
)
;
}
if
(
(
*
deps
&
FunctionDependencies
:
:
kPipelineOutputs
)
!
=
FunctionDependencies
:
:
kNone
)
{
this
-
>
write
(
separator
)
;
this
-
>
write
(
"
_stageOut
:
ptr
<
function
"
)
;
this
-
>
write
(
structNamePrefix
)
;
this
-
>
write
(
"
Out
>
"
)
;
}
return
true
;
}
std
:
:
string
WGSLCodeGenerator
:
:
writeOutParamHelper
(
const
FunctionCall
&
c
const
ExpressionArray
&
args
const
SkTArray
<
VariableReference
*
>
&
outVars
)
{
StringStream
tmpStream
;
AutoOutputStream
outputToExtraFunctions
(
this
&
tmpStream
&
fIndentation
)
;
bool
atLineStart
=
fAtLineStart
;
fAtLineStart
=
false
;
const
FunctionDeclaration
&
func
=
c
.
function
(
)
;
std
:
:
string
name
=
"
_outParamHelper_
"
+
std
:
:
to_string
(
fSwizzleHelperCount
+
+
)
+
"
_
"
+
func
.
mangledName
(
)
;
auto
separator
=
SkSL
:
:
String
:
:
Separator
(
)
;
this
-
>
write
(
"
fn
"
)
;
this
-
>
write
(
name
)
;
this
-
>
write
(
"
(
"
)
;
if
(
this
-
>
writeFunctionDependencyParams
(
func
)
)
{
separator
(
)
;
}
SkASSERT
(
outVars
.
size
(
)
=
=
args
.
size
(
)
)
;
SkASSERT
(
SkToSizeT
(
outVars
.
size
(
)
)
=
=
func
.
parameters
(
)
.
size
(
)
)
;
auto
parentOutParamArgVars
=
std
:
:
move
(
fOutParamArgVars
)
;
SkASSERT
(
fOutParamArgVars
.
empty
(
)
)
;
for
(
int
i
=
0
;
i
<
args
.
size
(
)
;
+
+
i
)
{
this
-
>
write
(
separator
(
)
)
;
if
(
outVars
[
i
]
)
{
const
Variable
*
var
=
outVars
[
i
]
-
>
variable
(
)
;
if
(
!
fOutParamArgVars
.
contains
(
var
)
)
{
fOutParamArgVars
.
add
(
var
)
;
this
-
>
writeName
(
var
-
>
mangledName
(
)
)
;
}
else
{
this
-
>
write
(
"
_unused
"
)
;
this
-
>
write
(
std
:
:
to_string
(
i
)
)
;
}
}
else
{
this
-
>
write
(
"
_var
"
)
;
this
-
>
write
(
std
:
:
to_string
(
i
)
)
;
}
this
-
>
write
(
"
:
"
)
;
const
Type
&
type
=
outVars
[
i
]
?
outVars
[
i
]
-
>
type
(
)
:
args
[
i
]
-
>
type
(
)
;
if
(
func
.
parameters
(
)
[
i
]
-
>
modifiers
(
)
.
fFlags
&
Modifiers
:
:
kOut_Flag
)
{
this
-
>
write
(
to_ptr_type
(
type
)
)
;
}
else
{
this
-
>
write
(
to_wgsl_type
(
type
)
)
;
}
}
this
-
>
write
(
"
)
"
)
;
if
(
!
func
.
returnType
(
)
.
isVoid
(
)
)
{
this
-
>
write
(
"
-
>
"
)
;
this
-
>
write
(
to_wgsl_type
(
func
.
returnType
(
)
)
)
;
}
this
-
>
writeLine
(
"
{
"
)
;
+
+
fIndentation
;
for
(
int
i
=
0
;
i
<
outVars
.
size
(
)
;
+
+
i
)
{
if
(
!
outVars
[
i
]
)
{
continue
;
}
this
-
>
write
(
"
var
"
)
;
this
-
>
write
(
"
_var
"
)
;
this
-
>
write
(
std
:
:
to_string
(
i
)
)
;
this
-
>
write
(
"
:
"
)
;
this
-
>
write
(
to_wgsl_type
(
args
[
i
]
-
>
type
(
)
)
)
;
if
(
func
.
parameters
(
)
[
i
]
-
>
modifiers
(
)
.
fFlags
&
Modifiers
:
:
kIn_Flag
)
{
this
-
>
write
(
"
=
"
)
;
this
-
>
writeExpression
(
*
args
[
i
]
Precedence
:
:
kAssignment
)
;
}
this
-
>
writeLine
(
"
;
"
)
;
}
bool
hasReturn
=
!
c
.
type
(
)
.
isVoid
(
)
;
if
(
hasReturn
)
{
this
-
>
write
(
"
var
_return
:
"
)
;
this
-
>
write
(
to_wgsl_type
(
c
.
type
(
)
)
)
;
this
-
>
write
(
"
=
"
)
;
}
this
-
>
writeName
(
func
.
mangledName
(
)
)
;
this
-
>
write
(
"
(
"
)
;
auto
newSeparator
=
SkSL
:
:
String
:
:
Separator
(
)
;
if
(
this
-
>
writeFunctionDependencyArgs
(
func
)
)
{
newSeparator
(
)
;
}
for
(
int
i
=
0
;
i
<
args
.
size
(
)
;
+
+
i
)
{
this
-
>
write
(
newSeparator
(
)
)
;
if
(
outVars
[
i
]
)
{
this
-
>
write
(
"
&
"
)
;
}
this
-
>
write
(
"
_var
"
)
;
this
-
>
write
(
std
:
:
to_string
(
i
)
)
;
}
this
-
>
writeLine
(
"
)
;
"
)
;
for
(
int
i
=
0
;
i
<
outVars
.
size
(
)
;
+
+
i
)
{
if
(
!
outVars
[
i
]
)
{
continue
;
}
this
-
>
writeExpression
(
*
args
[
i
]
Precedence
:
:
kAssignment
)
;
this
-
>
write
(
"
=
_var
"
)
;
this
-
>
write
(
std
:
:
to_string
(
i
)
)
;
this
-
>
writeLine
(
"
;
"
)
;
}
if
(
hasReturn
)
{
this
-
>
writeLine
(
"
return
_return
;
"
)
;
}
-
-
fIndentation
;
this
-
>
writeLine
(
"
}
"
)
;
write_stringstream
(
tmpStream
fExtraFunctions
)
;
fOutParamArgVars
=
std
:
:
move
(
parentOutParamArgVars
)
;
fAtLineStart
=
atLineStart
;
return
name
;
}
}
