#
ifndef
SKSL_RASTERPIPELINECODEBUILDER
#
define
SKSL_RASTERPIPELINECODEBUILDER
#
include
"
include
/
core
/
SkSpan
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
src
/
base
/
SkUtils
.
h
"
#
include
"
src
/
core
/
SkRasterPipelineOpList
.
h
"
#
include
"
src
/
core
/
SkTHash
.
h
"
#
include
<
cstdint
>
#
include
<
initializer_list
>
#
include
<
memory
>
class
SkArenaAlloc
;
class
SkRasterPipeline
;
class
SkWStream
;
namespace
SkSL
{
class
SkRPDebugTrace
;
namespace
RP
{
using
Slot
=
int
;
constexpr
Slot
NA
=
-
1
;
struct
SlotRange
{
Slot
index
=
0
;
int
count
=
0
;
}
;
enum
class
ProgramOp
{
#
define
M
(
stage
)
stage
SK_RASTER_PIPELINE_OPS_ALL
(
M
)
#
undef
M
label
invoke_shader
invoke_color_filter
invoke_blender
invoke_to_linear_srgb
invoke_from_linear_srgb
}
;
enum
class
BuilderOp
{
#
define
M
(
stage
)
stage
SK_RASTER_PIPELINE_OPS_ALL
(
M
)
#
undef
M
label
invoke_shader
invoke_color_filter
invoke_blender
invoke_to_linear_srgb
invoke_from_linear_srgb
push_literal
push_slots
push_slots_indirect
push_uniform
push_uniform_indirect
push_zeros
push_clone
push_clone_from_stack
push_clone_indirect_from_stack
copy_stack_to_slots
copy_stack_to_slots_unmasked
copy_stack_to_slots_indirect
swizzle_copy_stack_to_slots
swizzle_copy_stack_to_slots_indirect
discard_stack
select
push_condition_mask
pop_condition_mask
push_loop_mask
pop_loop_mask
pop_and_reenable_loop_mask
push_return_mask
pop_return_mask
push_src_rgba
push_dst_rgba
pop_src_rg
pop_src_rgba
pop_dst_rgba
set_current_stack
branch_if_no_active_lanes_on_stack_top_equal
unsupported
}
;
static_assert
(
(
int
)
ProgramOp
:
:
label
=
=
(
int
)
BuilderOp
:
:
label
)
;
static_assert
(
(
int
)
ProgramOp
:
:
invoke_shader
=
=
(
int
)
BuilderOp
:
:
invoke_shader
)
;
static_assert
(
(
int
)
ProgramOp
:
:
invoke_color_filter
=
=
(
int
)
BuilderOp
:
:
invoke_color_filter
)
;
static_assert
(
(
int
)
ProgramOp
:
:
invoke_blender
=
=
(
int
)
BuilderOp
:
:
invoke_blender
)
;
static_assert
(
(
int
)
ProgramOp
:
:
invoke_to_linear_srgb
=
=
(
int
)
BuilderOp
:
:
invoke_to_linear_srgb
)
;
static_assert
(
(
int
)
ProgramOp
:
:
invoke_from_linear_srgb
=
=
(
int
)
BuilderOp
:
:
invoke_from_linear_srgb
)
;
struct
Instruction
{
Instruction
(
BuilderOp
op
std
:
:
initializer_list
<
Slot
>
slots
int
a
=
0
int
b
=
0
int
c
=
0
int
d
=
0
)
:
fOp
(
op
)
fImmA
(
a
)
fImmB
(
b
)
fImmC
(
c
)
fImmD
(
d
)
{
auto
iter
=
slots
.
begin
(
)
;
if
(
iter
!
=
slots
.
end
(
)
)
{
fSlotA
=
*
iter
+
+
;
}
if
(
iter
!
=
slots
.
end
(
)
)
{
fSlotB
=
*
iter
+
+
;
}
SkASSERT
(
iter
=
=
slots
.
end
(
)
)
;
}
BuilderOp
fOp
;
Slot
fSlotA
=
NA
;
Slot
fSlotB
=
NA
;
int
fImmA
=
0
;
int
fImmB
=
0
;
int
fImmC
=
0
;
int
fImmD
=
0
;
}
;
class
Callbacks
{
public
:
virtual
~
Callbacks
(
)
=
default
;
virtual
bool
appendShader
(
int
index
)
=
0
;
virtual
bool
appendColorFilter
(
int
index
)
=
0
;
virtual
bool
appendBlender
(
int
index
)
=
0
;
virtual
void
toLinearSrgb
(
)
=
0
;
virtual
void
fromLinearSrgb
(
)
=
0
;
}
;
class
Program
{
public
:
Program
(
SkTArray
<
Instruction
>
instrs
int
numValueSlots
int
numUniformSlots
int
numLabels
SkRPDebugTrace
*
debugTrace
)
;
#
if
!
defined
(
SKSL_STANDALONE
)
bool
appendStages
(
SkRasterPipeline
*
pipeline
SkArenaAlloc
*
alloc
Callbacks
*
callbacks
SkSpan
<
const
float
>
uniforms
)
const
;
#
endif
void
dump
(
SkWStream
*
out
)
const
;
private
:
using
StackDepthMap
=
SkTHashMap
<
int
int
>
;
struct
SlotData
{
SkSpan
<
float
>
values
;
SkSpan
<
float
>
stack
;
}
;
SlotData
allocateSlotData
(
SkArenaAlloc
*
alloc
)
const
;
struct
Stage
{
ProgramOp
op
;
void
*
ctx
;
}
;
void
makeStages
(
SkTArray
<
Stage
>
*
pipeline
SkArenaAlloc
*
alloc
SkSpan
<
const
float
>
uniforms
const
SlotData
&
slots
)
const
;
void
optimize
(
)
;
StackDepthMap
tempStackMaxDepths
(
)
const
;
void
appendCopy
(
SkTArray
<
Stage
>
*
pipeline
SkArenaAlloc
*
alloc
ProgramOp
baseStage
float
*
dst
int
dstStride
const
float
*
src
int
srcStride
int
numSlots
)
const
;
void
appendCopySlotsUnmasked
(
SkTArray
<
Stage
>
*
pipeline
SkArenaAlloc
*
alloc
float
*
dst
const
float
*
src
int
numSlots
)
const
;
void
appendCopySlotsMasked
(
SkTArray
<
Stage
>
*
pipeline
SkArenaAlloc
*
alloc
float
*
dst
const
float
*
src
int
numSlots
)
const
;
void
appendCopyConstants
(
SkTArray
<
Stage
>
*
pipeline
SkArenaAlloc
*
alloc
float
*
dst
const
float
*
src
int
numSlots
)
const
;
void
appendSingleSlotUnaryOp
(
SkTArray
<
Stage
>
*
pipeline
ProgramOp
stage
float
*
dst
int
numSlots
)
const
;
void
appendMultiSlotUnaryOp
(
SkTArray
<
Stage
>
*
pipeline
ProgramOp
baseStage
float
*
dst
int
numSlots
)
const
;
void
appendAdjacentNWayBinaryOp
(
SkTArray
<
Stage
>
*
pipeline
SkArenaAlloc
*
alloc
ProgramOp
stage
float
*
dst
const
float
*
src
int
numSlots
)
const
;
void
appendAdjacentMultiSlotBinaryOp
(
SkTArray
<
Stage
>
*
pipeline
SkArenaAlloc
*
alloc
ProgramOp
baseStage
float
*
dst
const
float
*
src
int
numSlots
)
const
;
void
appendAdjacentMultiSlotTernaryOp
(
SkTArray
<
Stage
>
*
pipeline
SkArenaAlloc
*
alloc
ProgramOp
stage
float
*
dst
const
float
*
src0
const
float
*
src1
int
numSlots
)
const
;
void
appendAdjacentNWayTernaryOp
(
SkTArray
<
Stage
>
*
pipeline
SkArenaAlloc
*
alloc
ProgramOp
stage
float
*
dst
const
float
*
src0
const
float
*
src1
int
numSlots
)
const
;
void
appendStackRewind
(
SkTArray
<
Stage
>
*
pipeline
)
const
;
SkTArray
<
Instruction
>
fInstructions
;
int
fNumValueSlots
=
0
;
int
fNumUniformSlots
=
0
;
int
fNumTempStackSlots
=
0
;
int
fNumLabels
=
0
;
SkTHashMap
<
int
int
>
fTempStackMaxDepths
;
SkRPDebugTrace
*
fDebugTrace
=
nullptr
;
}
;
class
Builder
{
public
:
std
:
:
unique_ptr
<
Program
>
finish
(
int
numValueSlots
int
numUniformSlots
SkRPDebugTrace
*
debugTrace
=
nullptr
)
;
int
nextLabelID
(
)
{
return
fNumLabels
+
+
;
}
void
enableExecutionMaskWrites
(
)
{
+
+
fExecutionMaskWritesEnabled
;
}
void
disableExecutionMaskWrites
(
)
{
SkASSERT
(
this
-
>
executionMaskWritesAreEnabled
(
)
)
;
-
-
fExecutionMaskWritesEnabled
;
}
bool
executionMaskWritesAreEnabled
(
)
{
return
fExecutionMaskWritesEnabled
>
0
;
}
void
init_lane_masks
(
)
{
fInstructions
.
push_back
(
{
BuilderOp
:
:
init_lane_masks
{
}
}
)
;
}
void
store_src_rg
(
SlotRange
slots
)
{
SkASSERT
(
slots
.
count
=
=
2
)
;
fInstructions
.
push_back
(
{
BuilderOp
:
:
store_src_rg
{
slots
.
index
}
}
)
;
}
void
store_src
(
SlotRange
slots
)
{
SkASSERT
(
slots
.
count
=
=
4
)
;
fInstructions
.
push_back
(
{
BuilderOp
:
:
store_src
{
slots
.
index
}
}
)
;
}
void
store_dst
(
SlotRange
slots
)
{
SkASSERT
(
slots
.
count
=
=
4
)
;
fInstructions
.
push_back
(
{
BuilderOp
:
:
store_dst
{
slots
.
index
}
}
)
;
}
void
store_device_xy01
(
SlotRange
slots
)
{
SkASSERT
(
slots
.
count
=
=
4
)
;
fInstructions
.
push_back
(
{
BuilderOp
:
:
store_device_xy01
{
slots
.
index
}
}
)
;
}
void
load_src
(
SlotRange
slots
)
{
SkASSERT
(
slots
.
count
=
=
4
)
;
fInstructions
.
push_back
(
{
BuilderOp
:
:
load_src
{
slots
.
index
}
}
)
;
}
void
load_dst
(
SlotRange
slots
)
{
SkASSERT
(
slots
.
count
=
=
4
)
;
fInstructions
.
push_back
(
{
BuilderOp
:
:
load_dst
{
slots
.
index
}
}
)
;
}
void
set_current_stack
(
int
stackIdx
)
{
fInstructions
.
push_back
(
{
BuilderOp
:
:
set_current_stack
{
}
stackIdx
}
)
;
}
void
label
(
int
labelID
)
;
void
jump
(
int
labelID
)
;
void
branch_if_all_lanes_active
(
int
labelID
)
;
void
branch_if_any_lanes_active
(
int
labelID
)
;
void
branch_if_no_lanes_active
(
int
labelID
)
;
void
branch_if_no_active_lanes_on_stack_top_equal
(
int
value
int
labelID
)
;
void
push_literal_f
(
float
val
)
{
this
-
>
push_literal_i
(
sk_bit_cast
<
int32_t
>
(
val
)
)
;
}
void
push_literal_i
(
int32_t
val
)
{
if
(
val
=
=
0
)
{
this
-
>
push_zeros
(
1
)
;
}
else
{
fInstructions
.
push_back
(
{
BuilderOp
:
:
push_literal
{
}
val
}
)
;
}
}
void
push_literal_u
(
uint32_t
val
)
{
this
-
>
push_literal_i
(
sk_bit_cast
<
int32_t
>
(
val
)
)
;
}
void
push_uniform
(
SlotRange
src
)
;
void
push_uniform_indirect
(
SlotRange
fixedRange
int
dynamicStack
SlotRange
limitRange
)
;
void
push_zeros
(
int
count
)
{
SkASSERT
(
count
>
=
0
)
;
if
(
count
>
0
)
{
if
(
!
fInstructions
.
empty
(
)
&
&
fInstructions
.
back
(
)
.
fOp
=
=
BuilderOp
:
:
push_zeros
)
{
fInstructions
.
back
(
)
.
fImmA
+
=
count
;
}
else
{
fInstructions
.
push_back
(
{
BuilderOp
:
:
push_zeros
{
}
count
}
)
;
}
}
}
void
push_slots
(
SlotRange
src
)
;
void
push_slots_indirect
(
SlotRange
fixedRange
int
dynamicStack
SlotRange
limitRange
)
;
void
copy_stack_to_slots
(
SlotRange
dst
)
{
this
-
>
copy_stack_to_slots
(
dst
dst
.
count
)
;
}
void
copy_stack_to_slots
(
SlotRange
dst
int
offsetFromStackTop
)
;
void
swizzle_copy_stack_to_slots
(
SlotRange
dst
SkSpan
<
const
int8_t
>
components
int
offsetFromStackTop
)
;
void
swizzle_copy_stack_to_slots_indirect
(
SlotRange
fixedRange
int
dynamicStackID
SlotRange
limitRange
SkSpan
<
const
int8_t
>
components
int
offsetFromStackTop
)
;
void
copy_stack_to_slots_unmasked
(
SlotRange
dst
)
{
this
-
>
copy_stack_to_slots_unmasked
(
dst
dst
.
count
)
;
}
void
copy_stack_to_slots_unmasked
(
SlotRange
dst
int
offsetFromStackTop
)
;
void
copy_stack_to_slots_indirect
(
SlotRange
fixedRange
int
dynamicStackID
SlotRange
limitRange
)
;
void
pop_slots_indirect
(
SlotRange
fixedRange
int
dynamicStackID
SlotRange
limitRange
)
{
this
-
>
copy_stack_to_slots_indirect
(
fixedRange
dynamicStackID
limitRange
)
;
this
-
>
discard_stack
(
fixedRange
.
count
)
;
}
void
unary_op
(
BuilderOp
op
int32_t
slots
)
;
void
binary_op
(
BuilderOp
op
int32_t
slots
)
;
void
ternary_op
(
BuilderOp
op
int32_t
slots
)
;
void
dot_floats
(
int32_t
slots
)
;
void
refract_floats
(
)
;
void
inverse_matrix
(
int32_t
n
)
;
void
discard_stack
(
int32_t
count
=
1
)
;
void
pop_slots
(
SlotRange
dst
)
;
void
push_duplicates
(
int
count
)
;
void
push_clone
(
int
numSlots
int
offsetFromStackTop
=
0
)
{
fInstructions
.
push_back
(
{
BuilderOp
:
:
push_clone
{
}
numSlots
numSlots
+
offsetFromStackTop
}
)
;
}
void
push_clone_from_stack
(
SlotRange
range
int
otherStackID
int
offsetFromStackTop
)
;
void
push_clone_indirect_from_stack
(
SlotRange
fixedOffset
int
dynamicStackID
int
otherStackID
int
offsetFromStackTop
)
;
void
case_op
(
int
value
)
{
fInstructions
.
push_back
(
{
BuilderOp
:
:
case_op
{
}
value
}
)
;
}
void
select
(
int
slots
)
{
SkASSERT
(
slots
>
0
)
;
fInstructions
.
push_back
(
{
BuilderOp
:
:
select
{
}
slots
}
)
;
}
void
pop_slots_unmasked
(
SlotRange
dst
)
;
void
copy_slots_masked
(
SlotRange
dst
SlotRange
src
)
{
SkASSERT
(
dst
.
count
=
=
src
.
count
)
;
fInstructions
.
push_back
(
{
BuilderOp
:
:
copy_slot_masked
{
dst
.
index
src
.
index
}
dst
.
count
}
)
;
}
void
copy_slots_unmasked
(
SlotRange
dst
SlotRange
src
)
;
void
copy_constant
(
Slot
slot
int
constantValue
)
{
fInstructions
.
push_back
(
{
BuilderOp
:
:
copy_constant
{
slot
}
constantValue
}
)
;
}
void
zero_slots_unmasked
(
SlotRange
dst
)
;
void
swizzle
(
int
consumedSlots
SkSpan
<
const
int8_t
>
components
)
;
void
transpose
(
int
columns
int
rows
)
;
void
diagonal_matrix
(
int
columns
int
rows
)
;
void
matrix_resize
(
int
origColumns
int
origRows
int
newColumns
int
newRows
)
;
void
push_condition_mask
(
)
{
SkASSERT
(
this
-
>
executionMaskWritesAreEnabled
(
)
)
;
fInstructions
.
push_back
(
{
BuilderOp
:
:
push_condition_mask
{
}
}
)
;
}
void
pop_condition_mask
(
)
{
SkASSERT
(
this
-
>
executionMaskWritesAreEnabled
(
)
)
;
fInstructions
.
push_back
(
{
BuilderOp
:
:
pop_condition_mask
{
}
}
)
;
}
void
merge_condition_mask
(
)
{
SkASSERT
(
this
-
>
executionMaskWritesAreEnabled
(
)
)
;
fInstructions
.
push_back
(
{
BuilderOp
:
:
merge_condition_mask
{
}
}
)
;
}
void
push_loop_mask
(
)
{
SkASSERT
(
this
-
>
executionMaskWritesAreEnabled
(
)
)
;
fInstructions
.
push_back
(
{
BuilderOp
:
:
push_loop_mask
{
}
}
)
;
}
void
pop_loop_mask
(
)
{
SkASSERT
(
this
-
>
executionMaskWritesAreEnabled
(
)
)
;
fInstructions
.
push_back
(
{
BuilderOp
:
:
pop_loop_mask
{
}
}
)
;
}
void
push_src_rgba
(
)
{
fInstructions
.
push_back
(
{
BuilderOp
:
:
push_src_rgba
{
}
}
)
;
}
void
push_dst_rgba
(
)
{
fInstructions
.
push_back
(
{
BuilderOp
:
:
push_dst_rgba
{
}
}
)
;
}
void
pop_src_rg
(
)
{
fInstructions
.
push_back
(
{
BuilderOp
:
:
pop_src_rg
{
}
}
)
;
}
void
pop_src_rgba
(
)
{
fInstructions
.
push_back
(
{
BuilderOp
:
:
pop_src_rgba
{
}
}
)
;
}
void
pop_dst_rgba
(
)
{
fInstructions
.
push_back
(
{
BuilderOp
:
:
pop_dst_rgba
{
}
}
)
;
}
void
mask_off_loop_mask
(
)
{
SkASSERT
(
this
-
>
executionMaskWritesAreEnabled
(
)
)
;
fInstructions
.
push_back
(
{
BuilderOp
:
:
mask_off_loop_mask
{
}
}
)
;
}
void
reenable_loop_mask
(
SlotRange
src
)
{
SkASSERT
(
this
-
>
executionMaskWritesAreEnabled
(
)
)
;
SkASSERT
(
src
.
count
=
=
1
)
;
fInstructions
.
push_back
(
{
BuilderOp
:
:
reenable_loop_mask
{
src
.
index
}
}
)
;
}
void
pop_and_reenable_loop_mask
(
)
{
SkASSERT
(
this
-
>
executionMaskWritesAreEnabled
(
)
)
;
fInstructions
.
push_back
(
{
BuilderOp
:
:
pop_and_reenable_loop_mask
{
}
}
)
;
}
void
merge_loop_mask
(
)
{
SkASSERT
(
this
-
>
executionMaskWritesAreEnabled
(
)
)
;
fInstructions
.
push_back
(
{
BuilderOp
:
:
merge_loop_mask
{
}
}
)
;
}
void
push_return_mask
(
)
{
SkASSERT
(
this
-
>
executionMaskWritesAreEnabled
(
)
)
;
fInstructions
.
push_back
(
{
BuilderOp
:
:
push_return_mask
{
}
}
)
;
}
void
pop_return_mask
(
)
;
void
mask_off_return_mask
(
)
{
SkASSERT
(
this
-
>
executionMaskWritesAreEnabled
(
)
)
;
fInstructions
.
push_back
(
{
BuilderOp
:
:
mask_off_return_mask
{
}
}
)
;
}
void
invoke_shader
(
int
childIdx
)
{
fInstructions
.
push_back
(
{
BuilderOp
:
:
invoke_shader
{
}
childIdx
}
)
;
}
void
invoke_color_filter
(
int
childIdx
)
{
fInstructions
.
push_back
(
{
BuilderOp
:
:
invoke_color_filter
{
}
childIdx
}
)
;
}
void
invoke_blender
(
int
childIdx
)
{
fInstructions
.
push_back
(
{
BuilderOp
:
:
invoke_blender
{
}
childIdx
}
)
;
}
void
invoke_to_linear_srgb
(
)
{
fInstructions
.
push_back
(
{
BuilderOp
:
:
invoke_to_linear_srgb
{
}
}
)
;
}
void
invoke_from_linear_srgb
(
)
{
fInstructions
.
push_back
(
{
BuilderOp
:
:
invoke_from_linear_srgb
{
}
}
)
;
}
private
:
void
simplifyPopSlotsUnmasked
(
SlotRange
*
dst
)
;
SkTArray
<
Instruction
>
fInstructions
;
int
fNumLabels
=
0
;
int
fExecutionMaskWritesEnabled
=
0
;
}
;
}
}
#
endif
