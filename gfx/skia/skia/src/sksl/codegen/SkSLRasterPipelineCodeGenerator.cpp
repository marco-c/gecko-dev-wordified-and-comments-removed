#
include
"
include
/
core
/
SkSpan
.
h
"
#
include
"
include
/
private
/
SkSLDefines
.
h
"
#
include
"
include
/
private
/
SkSLIRNode
.
h
"
#
include
"
include
/
private
/
SkSLLayout
.
h
"
#
include
"
include
/
private
/
SkSLModifiers
.
h
"
#
include
"
include
/
private
/
SkSLProgramElement
.
h
"
#
include
"
include
/
private
/
SkSLStatement
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
include
/
sksl
/
SkSLOperator
.
h
"
#
include
"
include
/
sksl
/
SkSLPosition
.
h
"
#
include
"
src
/
base
/
SkStringView
.
h
"
#
include
"
src
/
core
/
SkTHash
.
h
"
#
include
"
src
/
sksl
/
SkSLAnalysis
.
h
"
#
include
"
src
/
sksl
/
SkSLBuiltinTypes
.
h
"
#
include
"
src
/
sksl
/
SkSLCompiler
.
h
"
#
include
"
src
/
sksl
/
SkSLConstantFolder
.
h
"
#
include
"
src
/
sksl
/
SkSLContext
.
h
"
#
include
"
src
/
sksl
/
SkSLIntrinsicList
.
h
"
#
include
"
src
/
sksl
/
SkSLModifiersPool
.
h
"
#
include
"
src
/
sksl
/
codegen
/
SkSLRasterPipelineBuilder
.
h
"
#
include
"
src
/
sksl
/
codegen
/
SkSLRasterPipelineCodeGenerator
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLBinaryExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLBlock
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLBreakStatement
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLChildCall
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructor
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorDiagonalMatrix
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorMatrixResize
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorSplat
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLContinueStatement
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLDoStatement
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLExpressionStatement
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFieldAccess
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLForStatement
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFunctionCall
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFunctionDeclaration
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFunctionDefinition
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLIfStatement
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLIndexExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLLiteral
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLPostfixExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLPrefixExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLProgram
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLReturnStatement
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLSwitchCase
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLSwitchStatement
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLSwizzle
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLTernaryExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLType
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLVarDeclarations
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLVariable
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLVariableReference
.
h
"
#
include
"
src
/
sksl
/
tracing
/
SkRPDebugTrace
.
h
"
#
include
"
src
/
sksl
/
tracing
/
SkSLDebugInfo
.
h
"
#
include
"
src
/
sksl
/
transform
/
SkSLTransform
.
h
"
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
float
.
h
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
string_view
>
#
include
<
utility
>
#
include
<
vector
>
namespace
SkSL
{
namespace
RP
{
static
bool
unsupported
(
)
{
return
false
;
}
class
SlotManager
{
public
:
SlotManager
(
std
:
:
vector
<
SlotDebugInfo
>
*
i
)
:
fSlotDebugInfo
(
i
)
{
}
void
addSlotDebugInfoForGroup
(
const
std
:
:
string
&
varName
const
Type
&
type
Position
pos
int
*
groupIndex
bool
isFunctionReturnValue
)
;
void
addSlotDebugInfo
(
const
std
:
:
string
&
varName
const
Type
&
type
Position
pos
bool
isFunctionReturnValue
)
;
SlotRange
createSlots
(
std
:
:
string
name
const
Type
&
type
Position
pos
bool
isFunctionReturnValue
)
;
SlotRange
getVariableSlots
(
const
Variable
&
v
)
;
SlotRange
getFunctionSlots
(
const
IRNode
&
callSite
const
FunctionDeclaration
&
f
)
;
int
slotCount
(
)
const
{
return
fSlotCount
;
}
private
:
SkTHashMap
<
const
IRNode
*
SlotRange
>
fSlotMap
;
int
fSlotCount
=
0
;
std
:
:
vector
<
SlotDebugInfo
>
*
fSlotDebugInfo
;
}
;
class
AutoContinueMask
;
class
LValue
;
class
Generator
{
public
:
Generator
(
const
SkSL
:
:
Program
&
program
SkRPDebugTrace
*
debugTrace
)
:
fProgram
(
program
)
fContext
(
fProgram
.
fContext
-
>
fTypes
fProgram
.
fContext
-
>
fCaps
*
fProgram
.
fContext
-
>
fErrors
)
fDebugTrace
(
debugTrace
)
fProgramSlots
(
debugTrace
?
&
debugTrace
-
>
fSlotInfo
:
nullptr
)
fUniformSlots
(
debugTrace
?
&
debugTrace
-
>
fUniformInfo
:
nullptr
)
{
fContext
.
fModifiersPool
=
&
fModifiersPool
;
fContext
.
fConfig
=
fProgram
.
fConfig
.
get
(
)
;
fContext
.
fModule
=
fProgram
.
fContext
-
>
fModule
;
}
bool
writeProgram
(
const
FunctionDefinition
&
function
)
;
std
:
:
unique_ptr
<
RP
:
:
Program
>
finish
(
)
;
std
:
:
optional
<
SlotRange
>
writeFunction
(
const
IRNode
&
callSite
const
FunctionDefinition
&
function
)
;
int
getFunctionDebugInfo
(
const
FunctionDeclaration
&
decl
)
;
SlotRange
getVariableSlots
(
const
Variable
&
v
)
{
SkASSERT
(
!
IsUniform
(
v
)
)
;
return
fProgramSlots
.
getVariableSlots
(
v
)
;
}
SlotRange
getUniformSlots
(
const
Variable
&
v
)
{
SkASSERT
(
IsUniform
(
v
)
)
;
return
fUniformSlots
.
getVariableSlots
(
v
)
;
}
SlotRange
getFunctionSlots
(
const
IRNode
&
callSite
const
FunctionDeclaration
&
f
)
{
return
fProgramSlots
.
getFunctionSlots
(
callSite
f
)
;
}
int
createStack
(
)
;
void
recycleStack
(
int
stackID
)
;
void
setCurrentStack
(
int
stackID
)
;
int
currentStack
(
)
{
return
fCurrentStack
;
}
std
:
:
unique_ptr
<
LValue
>
makeLValue
(
const
Expression
&
e
bool
allowScratch
=
false
)
;
[
[
nodiscard
]
]
bool
store
(
LValue
&
lvalue
)
;
[
[
nodiscard
]
]
bool
push
(
LValue
&
lvalue
)
;
Builder
*
builder
(
)
{
return
&
fBuilder
;
}
[
[
nodiscard
]
]
bool
writeStatement
(
const
Statement
&
s
)
;
[
[
nodiscard
]
]
bool
writeBlock
(
const
Block
&
b
)
;
[
[
nodiscard
]
]
bool
writeBreakStatement
(
const
BreakStatement
&
b
)
;
[
[
nodiscard
]
]
bool
writeContinueStatement
(
const
ContinueStatement
&
b
)
;
[
[
nodiscard
]
]
bool
writeDoStatement
(
const
DoStatement
&
d
)
;
[
[
nodiscard
]
]
bool
writeExpressionStatement
(
const
ExpressionStatement
&
e
)
;
[
[
nodiscard
]
]
bool
writeMasklessForStatement
(
const
ForStatement
&
f
)
;
[
[
nodiscard
]
]
bool
writeForStatement
(
const
ForStatement
&
f
)
;
[
[
nodiscard
]
]
bool
writeGlobals
(
)
;
[
[
nodiscard
]
]
bool
writeIfStatement
(
const
IfStatement
&
i
)
;
[
[
nodiscard
]
]
bool
writeDynamicallyUniformIfStatement
(
const
IfStatement
&
i
)
;
[
[
nodiscard
]
]
bool
writeReturnStatement
(
const
ReturnStatement
&
r
)
;
[
[
nodiscard
]
]
bool
writeSwitchStatement
(
const
SwitchStatement
&
s
)
;
[
[
nodiscard
]
]
bool
writeVarDeclaration
(
const
VarDeclaration
&
v
)
;
[
[
nodiscard
]
]
bool
pushBinaryExpression
(
const
BinaryExpression
&
e
)
;
[
[
nodiscard
]
]
bool
pushBinaryExpression
(
const
Expression
&
left
Operator
op
const
Expression
&
right
)
;
[
[
nodiscard
]
]
bool
pushChildCall
(
const
ChildCall
&
c
)
;
[
[
nodiscard
]
]
bool
pushConstructorCast
(
const
AnyConstructor
&
c
)
;
[
[
nodiscard
]
]
bool
pushConstructorCompound
(
const
AnyConstructor
&
c
)
;
[
[
nodiscard
]
]
bool
pushConstructorDiagonalMatrix
(
const
ConstructorDiagonalMatrix
&
c
)
;
[
[
nodiscard
]
]
bool
pushConstructorMatrixResize
(
const
ConstructorMatrixResize
&
c
)
;
[
[
nodiscard
]
]
bool
pushConstructorSplat
(
const
ConstructorSplat
&
c
)
;
[
[
nodiscard
]
]
bool
pushExpression
(
const
Expression
&
e
bool
usesResult
=
true
)
;
[
[
nodiscard
]
]
bool
pushFieldAccess
(
const
FieldAccess
&
f
)
;
[
[
nodiscard
]
]
bool
pushFunctionCall
(
const
FunctionCall
&
c
)
;
[
[
nodiscard
]
]
bool
pushIndexExpression
(
const
IndexExpression
&
i
)
;
[
[
nodiscard
]
]
bool
pushIntrinsic
(
const
FunctionCall
&
c
)
;
[
[
nodiscard
]
]
bool
pushIntrinsic
(
IntrinsicKind
intrinsic
const
Expression
&
arg0
)
;
[
[
nodiscard
]
]
bool
pushIntrinsic
(
IntrinsicKind
intrinsic
const
Expression
&
arg0
const
Expression
&
arg1
)
;
[
[
nodiscard
]
]
bool
pushIntrinsic
(
IntrinsicKind
intrinsic
const
Expression
&
arg0
const
Expression
&
arg1
const
Expression
&
arg2
)
;
[
[
nodiscard
]
]
bool
pushLiteral
(
const
Literal
&
l
)
;
[
[
nodiscard
]
]
bool
pushPostfixExpression
(
const
PostfixExpression
&
p
bool
usesResult
)
;
[
[
nodiscard
]
]
bool
pushPrefixExpression
(
const
PrefixExpression
&
p
)
;
[
[
nodiscard
]
]
bool
pushPrefixExpression
(
Operator
op
const
Expression
&
expr
)
;
[
[
nodiscard
]
]
bool
pushSwizzle
(
const
Swizzle
&
s
)
;
[
[
nodiscard
]
]
bool
pushTernaryExpression
(
const
TernaryExpression
&
t
)
;
[
[
nodiscard
]
]
bool
pushTernaryExpression
(
const
Expression
&
test
const
Expression
&
ifTrue
const
Expression
&
ifFalse
)
;
[
[
nodiscard
]
]
bool
pushDynamicallyUniformTernaryExpression
(
const
Expression
&
test
const
Expression
&
ifTrue
const
Expression
&
ifFalse
)
;
[
[
nodiscard
]
]
bool
pushVariableReference
(
const
VariableReference
&
v
)
;
void
popToSlotRange
(
SlotRange
r
)
{
fBuilder
.
pop_slots
(
r
)
;
}
void
popToSlotRangeUnmasked
(
SlotRange
r
)
{
fBuilder
.
pop_slots_unmasked
(
r
)
;
}
void
discardExpression
(
int
slots
)
{
fBuilder
.
discard_stack
(
slots
)
;
}
void
zeroSlotRangeUnmasked
(
SlotRange
r
)
{
fBuilder
.
zero_slots_unmasked
(
r
)
;
}
struct
TypedOps
{
BuilderOp
fFloatOp
;
BuilderOp
fSignedOp
;
BuilderOp
fUnsignedOp
;
BuilderOp
fBooleanOp
;
}
;
static
BuilderOp
GetTypedOp
(
const
SkSL
:
:
Type
&
type
const
TypedOps
&
ops
)
;
[
[
nodiscard
]
]
bool
unaryOp
(
const
SkSL
:
:
Type
&
type
const
TypedOps
&
ops
)
;
[
[
nodiscard
]
]
bool
binaryOp
(
const
SkSL
:
:
Type
&
type
const
TypedOps
&
ops
)
;
[
[
nodiscard
]
]
bool
ternaryOp
(
const
SkSL
:
:
Type
&
type
const
TypedOps
&
ops
)
;
[
[
nodiscard
]
]
bool
pushIntrinsic
(
const
TypedOps
&
ops
const
Expression
&
arg0
)
;
[
[
nodiscard
]
]
bool
pushIntrinsic
(
const
TypedOps
&
ops
const
Expression
&
arg0
const
Expression
&
arg1
)
;
[
[
nodiscard
]
]
bool
pushIntrinsic
(
BuilderOp
builderOp
const
Expression
&
arg0
)
;
[
[
nodiscard
]
]
bool
pushIntrinsic
(
BuilderOp
builderOp
const
Expression
&
arg0
const
Expression
&
arg1
)
;
[
[
nodiscard
]
]
bool
pushLengthIntrinsic
(
int
slotCount
)
;
[
[
nodiscard
]
]
bool
pushVectorizedExpression
(
const
Expression
&
expr
const
Type
&
vectorType
)
;
[
[
nodiscard
]
]
bool
pushVariableReferencePartial
(
const
VariableReference
&
v
SlotRange
subset
)
;
[
[
nodiscard
]
]
bool
pushLValueOrExpression
(
LValue
*
lvalue
const
Expression
&
expr
)
;
[
[
nodiscard
]
]
bool
pushMatrixMultiply
(
LValue
*
lvalue
const
Expression
&
left
const
Expression
&
right
int
leftColumns
int
leftRows
int
rightColumns
int
rightRows
)
;
[
[
nodiscard
]
]
bool
pushStructuredComparison
(
LValue
*
left
Operator
op
LValue
*
right
const
Type
&
type
)
;
void
foldWithMultiOp
(
BuilderOp
op
int
elements
)
;
void
foldComparisonOp
(
Operator
op
int
elements
)
;
BuilderOp
getTypedOp
(
const
SkSL
:
:
Type
&
type
const
TypedOps
&
ops
)
const
;
Analysis
:
:
ReturnComplexity
returnComplexity
(
const
FunctionDefinition
*
func
)
{
Analysis
:
:
ReturnComplexity
*
complexity
=
fReturnComplexityMap
.
find
(
fCurrentFunction
)
;
if
(
!
complexity
)
{
complexity
=
fReturnComplexityMap
.
set
(
fCurrentFunction
Analysis
:
:
GetReturnComplexity
(
*
fCurrentFunction
)
)
;
}
return
*
complexity
;
}
bool
needsReturnMask
(
)
{
return
this
-
>
returnComplexity
(
fCurrentFunction
)
>
=
Analysis
:
:
ReturnComplexity
:
:
kEarlyReturns
;
}
bool
needsFunctionResultSlots
(
)
{
return
this
-
>
returnComplexity
(
fCurrentFunction
)
>
Analysis
:
:
ReturnComplexity
:
:
kSingleSafeReturn
;
}
static
bool
IsUniform
(
const
Variable
&
var
)
{
return
var
.
modifiers
(
)
.
fFlags
&
Modifiers
:
:
kUniform_Flag
;
}
static
bool
IsOutParameter
(
const
Variable
&
var
)
{
return
(
var
.
modifiers
(
)
.
fFlags
&
(
Modifiers
:
:
kIn_Flag
|
Modifiers
:
:
kOut_Flag
)
)
=
=
Modifiers
:
:
kOut_Flag
;
}
static
bool
IsInoutParameter
(
const
Variable
&
var
)
{
return
(
var
.
modifiers
(
)
.
fFlags
&
(
Modifiers
:
:
kIn_Flag
|
Modifiers
:
:
kOut_Flag
)
)
=
=
(
Modifiers
:
:
kIn_Flag
|
Modifiers
:
:
kOut_Flag
)
;
}
private
:
const
SkSL
:
:
Program
&
fProgram
;
SkSL
:
:
Context
fContext
;
SkSL
:
:
ModifiersPool
fModifiersPool
;
Builder
fBuilder
;
SkRPDebugTrace
*
fDebugTrace
=
nullptr
;
SkTHashMap
<
const
Variable
*
int
>
fChildEffectMap
;
SlotManager
fProgramSlots
;
SlotManager
fUniformSlots
;
const
FunctionDefinition
*
fCurrentFunction
=
nullptr
;
SlotRange
fCurrentFunctionResult
;
AutoContinueMask
*
fCurrentContinueMask
=
nullptr
;
int
fCurrentBreakTarget
=
-
1
;
int
fCurrentStack
=
0
;
int
fNextStackID
=
0
;
SkTArray
<
int
>
fRecycledStacks
;
SkTHashMap
<
const
FunctionDefinition
*
Analysis
:
:
ReturnComplexity
>
fReturnComplexityMap
;
static
constexpr
auto
kAbsOps
=
TypedOps
{
BuilderOp
:
:
abs_float
BuilderOp
:
:
abs_int
BuilderOp
:
:
unsupported
BuilderOp
:
:
unsupported
}
;
static
constexpr
auto
kAddOps
=
TypedOps
{
BuilderOp
:
:
add_n_floats
BuilderOp
:
:
add_n_ints
BuilderOp
:
:
add_n_ints
BuilderOp
:
:
unsupported
}
;
static
constexpr
auto
kSubtractOps
=
TypedOps
{
BuilderOp
:
:
sub_n_floats
BuilderOp
:
:
sub_n_ints
BuilderOp
:
:
sub_n_ints
BuilderOp
:
:
unsupported
}
;
static
constexpr
auto
kMultiplyOps
=
TypedOps
{
BuilderOp
:
:
mul_n_floats
BuilderOp
:
:
mul_n_ints
BuilderOp
:
:
mul_n_ints
BuilderOp
:
:
unsupported
}
;
static
constexpr
auto
kDivideOps
=
TypedOps
{
BuilderOp
:
:
div_n_floats
BuilderOp
:
:
div_n_ints
BuilderOp
:
:
div_n_uints
BuilderOp
:
:
unsupported
}
;
static
constexpr
auto
kLessThanOps
=
TypedOps
{
BuilderOp
:
:
cmplt_n_floats
BuilderOp
:
:
cmplt_n_ints
BuilderOp
:
:
cmplt_n_uints
BuilderOp
:
:
unsupported
}
;
static
constexpr
auto
kLessThanEqualOps
=
TypedOps
{
BuilderOp
:
:
cmple_n_floats
BuilderOp
:
:
cmple_n_ints
BuilderOp
:
:
cmple_n_uints
BuilderOp
:
:
unsupported
}
;
static
constexpr
auto
kEqualOps
=
TypedOps
{
BuilderOp
:
:
cmpeq_n_floats
BuilderOp
:
:
cmpeq_n_ints
BuilderOp
:
:
cmpeq_n_ints
BuilderOp
:
:
cmpeq_n_ints
}
;
static
constexpr
auto
kNotEqualOps
=
TypedOps
{
BuilderOp
:
:
cmpne_n_floats
BuilderOp
:
:
cmpne_n_ints
BuilderOp
:
:
cmpne_n_ints
BuilderOp
:
:
cmpne_n_ints
}
;
static
constexpr
auto
kModOps
=
TypedOps
{
BuilderOp
:
:
mod_n_floats
BuilderOp
:
:
unsupported
BuilderOp
:
:
unsupported
BuilderOp
:
:
unsupported
}
;
static
constexpr
auto
kMinOps
=
TypedOps
{
BuilderOp
:
:
min_n_floats
BuilderOp
:
:
min_n_ints
BuilderOp
:
:
min_n_uints
BuilderOp
:
:
min_n_uints
}
;
static
constexpr
auto
kMaxOps
=
TypedOps
{
BuilderOp
:
:
max_n_floats
BuilderOp
:
:
max_n_ints
BuilderOp
:
:
max_n_uints
BuilderOp
:
:
max_n_uints
}
;
static
constexpr
auto
kMixOps
=
TypedOps
{
BuilderOp
:
:
mix_n_floats
BuilderOp
:
:
unsupported
BuilderOp
:
:
unsupported
BuilderOp
:
:
unsupported
}
;
static
constexpr
auto
kInverseSqrtOps
=
TypedOps
{
BuilderOp
:
:
invsqrt_float
BuilderOp
:
:
unsupported
BuilderOp
:
:
unsupported
BuilderOp
:
:
unsupported
}
;
friend
class
AutoContinueMask
;
}
;
class
AutoStack
{
public
:
explicit
AutoStack
(
Generator
*
g
)
:
fGenerator
(
g
)
fStackID
(
g
-
>
createStack
(
)
)
{
}
~
AutoStack
(
)
{
fGenerator
-
>
recycleStack
(
fStackID
)
;
}
void
enter
(
)
{
fParentStackID
=
fGenerator
-
>
currentStack
(
)
;
fGenerator
-
>
setCurrentStack
(
fStackID
)
;
}
void
exit
(
)
{
SkASSERT
(
fGenerator
-
>
currentStack
(
)
=
=
fStackID
)
;
fGenerator
-
>
setCurrentStack
(
fParentStackID
)
;
}
void
pushClone
(
int
slots
)
{
this
-
>
pushClone
(
SlotRange
{
0
slots
}
slots
)
;
}
void
pushClone
(
SlotRange
range
int
offsetFromStackTop
)
{
fGenerator
-
>
builder
(
)
-
>
push_clone_from_stack
(
range
fStackID
offsetFromStackTop
)
;
}
void
pushCloneIndirect
(
SlotRange
range
int
dynamicStackID
int
offsetFromStackTop
)
{
fGenerator
-
>
builder
(
)
-
>
push_clone_indirect_from_stack
(
range
dynamicStackID
fStackID
offsetFromStackTop
)
;
}
int
stackID
(
)
const
{
return
fStackID
;
}
private
:
Generator
*
fGenerator
;
int
fStackID
=
0
;
int
fParentStackID
=
0
;
}
;
class
AutoContinueMask
{
public
:
AutoContinueMask
(
Generator
*
gen
)
:
fGenerator
(
gen
)
{
}
~
AutoContinueMask
(
)
{
if
(
fPreviousContinueMask
)
{
fGenerator
-
>
fCurrentContinueMask
=
fPreviousContinueMask
;
}
}
void
enable
(
)
{
SkASSERT
(
!
fContinueMaskStack
.
has_value
(
)
)
;
fContinueMaskStack
.
emplace
(
fGenerator
)
;
fPreviousContinueMask
=
fGenerator
-
>
fCurrentContinueMask
;
fGenerator
-
>
fCurrentContinueMask
=
this
;
}
void
enter
(
)
{
SkASSERT
(
fContinueMaskStack
.
has_value
(
)
)
;
fContinueMaskStack
-
>
enter
(
)
;
}
void
exit
(
)
{
SkASSERT
(
fContinueMaskStack
.
has_value
(
)
)
;
fContinueMaskStack
-
>
exit
(
)
;
}
void
enterLoopBody
(
)
{
if
(
fContinueMaskStack
.
has_value
(
)
)
{
fContinueMaskStack
-
>
enter
(
)
;
fGenerator
-
>
builder
(
)
-
>
push_literal_i
(
0
)
;
fContinueMaskStack
-
>
exit
(
)
;
}
}
void
exitLoopBody
(
)
{
if
(
fContinueMaskStack
.
has_value
(
)
)
{
fContinueMaskStack
-
>
enter
(
)
;
fGenerator
-
>
builder
(
)
-
>
pop_and_reenable_loop_mask
(
)
;
fContinueMaskStack
-
>
exit
(
)
;
}
}
private
:
std
:
:
optional
<
AutoStack
>
fContinueMaskStack
;
Generator
*
fGenerator
=
nullptr
;
AutoContinueMask
*
fPreviousContinueMask
=
nullptr
;
}
;
class
AutoLoopTarget
{
public
:
AutoLoopTarget
(
Generator
*
gen
int
*
targetPtr
)
:
fGenerator
(
gen
)
fLoopTargetPtr
(
targetPtr
)
{
fLabelID
=
fGenerator
-
>
builder
(
)
-
>
nextLabelID
(
)
;
fPreviousLoopTarget
=
*
fLoopTargetPtr
;
*
fLoopTargetPtr
=
fLabelID
;
}
~
AutoLoopTarget
(
)
{
*
fLoopTargetPtr
=
fPreviousLoopTarget
;
}
int
labelID
(
)
{
return
fLabelID
;
}
private
:
Generator
*
fGenerator
=
nullptr
;
int
*
fLoopTargetPtr
=
nullptr
;
int
fPreviousLoopTarget
;
int
fLabelID
;
}
;
class
LValue
{
public
:
virtual
~
LValue
(
)
=
default
;
virtual
bool
isWritable
(
)
const
=
0
;
virtual
SlotRange
fixedSlotRange
(
Generator
*
gen
)
=
0
;
virtual
AutoStack
*
dynamicSlotRange
(
)
=
0
;
virtual
SkSpan
<
const
int8_t
>
swizzle
(
)
{
return
{
}
;
}
[
[
nodiscard
]
]
virtual
bool
push
(
Generator
*
gen
SlotRange
fixedOffset
AutoStack
*
dynamicOffset
SkSpan
<
const
int8_t
>
swizzle
)
=
0
;
[
[
nodiscard
]
]
virtual
bool
store
(
Generator
*
gen
SlotRange
fixedOffset
AutoStack
*
dynamicOffset
SkSpan
<
const
int8_t
>
swizzle
)
=
0
;
std
:
:
unique_ptr
<
Expression
>
fScratchExpression
;
}
;
class
ScratchLValue
final
:
public
LValue
{
public
:
explicit
ScratchLValue
(
const
Expression
&
e
)
:
fExpression
(
&
e
)
fNumSlots
(
e
.
type
(
)
.
slotCount
(
)
)
{
}
~
ScratchLValue
(
)
override
{
if
(
fGenerator
&
&
fDedicatedStack
.
has_value
(
)
)
{
fDedicatedStack
-
>
enter
(
)
;
fGenerator
-
>
discardExpression
(
fNumSlots
)
;
fDedicatedStack
-
>
exit
(
)
;
}
}
bool
isWritable
(
)
const
override
{
return
false
;
}
SlotRange
fixedSlotRange
(
Generator
*
gen
)
override
{
return
SlotRange
{
0
fNumSlots
}
;
}
AutoStack
*
dynamicSlotRange
(
)
override
{
return
nullptr
;
}
[
[
nodiscard
]
]
bool
push
(
Generator
*
gen
SlotRange
fixedOffset
AutoStack
*
dynamicOffset
SkSpan
<
const
int8_t
>
swizzle
)
override
{
if
(
!
fDedicatedStack
.
has_value
(
)
)
{
fGenerator
=
gen
;
fDedicatedStack
.
emplace
(
fGenerator
)
;
fDedicatedStack
-
>
enter
(
)
;
if
(
!
fGenerator
-
>
pushExpression
(
*
fExpression
)
)
{
return
unsupported
(
)
;
}
fDedicatedStack
-
>
exit
(
)
;
}
if
(
dynamicOffset
)
{
fDedicatedStack
-
>
pushCloneIndirect
(
fixedOffset
dynamicOffset
-
>
stackID
(
)
fNumSlots
)
;
}
else
{
fDedicatedStack
-
>
pushClone
(
fixedOffset
fNumSlots
)
;
}
if
(
!
swizzle
.
empty
(
)
)
{
gen
-
>
builder
(
)
-
>
swizzle
(
fixedOffset
.
count
swizzle
)
;
}
return
true
;
}
[
[
nodiscard
]
]
bool
store
(
Generator
*
SlotRange
AutoStack
*
SkSpan
<
const
int8_t
>
)
override
{
SkDEBUGFAIL
(
"
scratch
lvalues
cannot
be
stored
into
"
)
;
return
unsupported
(
)
;
}
private
:
Generator
*
fGenerator
=
nullptr
;
const
Expression
*
fExpression
=
nullptr
;
std
:
:
optional
<
AutoStack
>
fDedicatedStack
;
int
fNumSlots
=
0
;
}
;
class
VariableLValue
final
:
public
LValue
{
public
:
explicit
VariableLValue
(
const
Variable
*
v
)
:
fVariable
(
v
)
{
}
bool
isWritable
(
)
const
override
{
return
!
Generator
:
:
IsUniform
(
*
fVariable
)
;
}
SlotRange
fixedSlotRange
(
Generator
*
gen
)
override
{
return
Generator
:
:
IsUniform
(
*
fVariable
)
?
gen
-
>
getUniformSlots
(
*
fVariable
)
:
gen
-
>
getVariableSlots
(
*
fVariable
)
;
}
AutoStack
*
dynamicSlotRange
(
)
override
{
return
nullptr
;
}
[
[
nodiscard
]
]
bool
push
(
Generator
*
gen
SlotRange
fixedOffset
AutoStack
*
dynamicOffset
SkSpan
<
const
int8_t
>
swizzle
)
override
{
if
(
Generator
:
:
IsUniform
(
*
fVariable
)
)
{
if
(
dynamicOffset
)
{
gen
-
>
builder
(
)
-
>
push_uniform_indirect
(
fixedOffset
dynamicOffset
-
>
stackID
(
)
this
-
>
fixedSlotRange
(
gen
)
)
;
}
else
{
gen
-
>
builder
(
)
-
>
push_uniform
(
fixedOffset
)
;
}
}
else
{
if
(
dynamicOffset
)
{
gen
-
>
builder
(
)
-
>
push_slots_indirect
(
fixedOffset
dynamicOffset
-
>
stackID
(
)
this
-
>
fixedSlotRange
(
gen
)
)
;
}
else
{
gen
-
>
builder
(
)
-
>
push_slots
(
fixedOffset
)
;
}
}
if
(
!
swizzle
.
empty
(
)
)
{
gen
-
>
builder
(
)
-
>
swizzle
(
fixedOffset
.
count
swizzle
)
;
}
return
true
;
}
[
[
nodiscard
]
]
bool
store
(
Generator
*
gen
SlotRange
fixedOffset
AutoStack
*
dynamicOffset
SkSpan
<
const
int8_t
>
swizzle
)
override
{
SkASSERT
(
!
Generator
:
:
IsUniform
(
*
fVariable
)
)
;
if
(
swizzle
.
empty
(
)
)
{
if
(
dynamicOffset
)
{
gen
-
>
builder
(
)
-
>
copy_stack_to_slots_indirect
(
fixedOffset
dynamicOffset
-
>
stackID
(
)
this
-
>
fixedSlotRange
(
gen
)
)
;
}
else
{
gen
-
>
builder
(
)
-
>
copy_stack_to_slots
(
fixedOffset
)
;
}
}
else
{
if
(
dynamicOffset
)
{
gen
-
>
builder
(
)
-
>
swizzle_copy_stack_to_slots_indirect
(
fixedOffset
dynamicOffset
-
>
stackID
(
)
this
-
>
fixedSlotRange
(
gen
)
swizzle
swizzle
.
size
(
)
)
;
}
else
{
gen
-
>
builder
(
)
-
>
swizzle_copy_stack_to_slots
(
fixedOffset
swizzle
swizzle
.
size
(
)
)
;
}
}
return
true
;
}
private
:
const
Variable
*
fVariable
;
}
;
class
SwizzleLValue
final
:
public
LValue
{
public
:
explicit
SwizzleLValue
(
std
:
:
unique_ptr
<
LValue
>
p
const
ComponentArray
&
c
)
:
fParent
(
std
:
:
move
(
p
)
)
fComponents
(
c
)
{
SkASSERT
(
!
fComponents
.
empty
(
)
&
&
fComponents
.
size
(
)
<
=
4
)
;
}
bool
isWritable
(
)
const
override
{
return
fParent
-
>
isWritable
(
)
;
}
SlotRange
fixedSlotRange
(
Generator
*
gen
)
override
{
return
fParent
-
>
fixedSlotRange
(
gen
)
;
}
AutoStack
*
dynamicSlotRange
(
)
override
{
return
fParent
-
>
dynamicSlotRange
(
)
;
}
SkSpan
<
const
int8_t
>
swizzle
(
)
override
{
return
fComponents
;
}
[
[
nodiscard
]
]
bool
push
(
Generator
*
gen
SlotRange
fixedOffset
AutoStack
*
dynamicOffset
SkSpan
<
const
int8_t
>
swizzle
)
override
{
if
(
!
swizzle
.
empty
(
)
)
{
SkDEBUGFAIL
(
"
swizzle
-
of
-
a
-
swizzle
should
have
been
folded
out
in
front
end
"
)
;
return
unsupported
(
)
;
}
return
fParent
-
>
push
(
gen
fixedOffset
dynamicOffset
fComponents
)
;
}
[
[
nodiscard
]
]
bool
store
(
Generator
*
gen
SlotRange
fixedOffset
AutoStack
*
dynamicOffset
SkSpan
<
const
int8_t
>
swizzle
)
override
{
if
(
!
swizzle
.
empty
(
)
)
{
SkDEBUGFAIL
(
"
swizzle
-
of
-
a
-
swizzle
should
have
been
folded
out
in
front
end
"
)
;
return
unsupported
(
)
;
}
return
fParent
-
>
store
(
gen
fixedOffset
dynamicOffset
fComponents
)
;
}
private
:
std
:
:
unique_ptr
<
LValue
>
fParent
;
const
ComponentArray
&
fComponents
;
}
;
class
UnownedLValueSlice
:
public
LValue
{
public
:
explicit
UnownedLValueSlice
(
LValue
*
p
int
initialSlot
int
numSlots
)
:
fParent
(
p
)
fInitialSlot
(
initialSlot
)
fNumSlots
(
numSlots
)
{
SkASSERT
(
fInitialSlot
>
=
0
)
;
SkASSERT
(
fNumSlots
>
0
)
;
}
bool
isWritable
(
)
const
override
{
return
fParent
-
>
isWritable
(
)
;
}
SlotRange
fixedSlotRange
(
Generator
*
gen
)
override
{
SlotRange
range
=
fParent
-
>
fixedSlotRange
(
gen
)
;
SlotRange
adjusted
=
range
;
adjusted
.
index
+
=
fInitialSlot
;
adjusted
.
count
=
fNumSlots
;
SkASSERT
(
(
adjusted
.
index
+
adjusted
.
count
)
<
=
(
range
.
index
+
range
.
count
)
)
;
return
adjusted
;
}
AutoStack
*
dynamicSlotRange
(
)
override
{
return
fParent
-
>
dynamicSlotRange
(
)
;
}
[
[
nodiscard
]
]
bool
push
(
Generator
*
gen
SlotRange
fixedOffset
AutoStack
*
dynamicOffset
SkSpan
<
const
int8_t
>
swizzle
)
override
{
return
fParent
-
>
push
(
gen
fixedOffset
dynamicOffset
swizzle
)
;
}
[
[
nodiscard
]
]
bool
store
(
Generator
*
gen
SlotRange
fixedOffset
AutoStack
*
dynamicOffset
SkSpan
<
const
int8_t
>
swizzle
)
override
{
return
fParent
-
>
store
(
gen
fixedOffset
dynamicOffset
swizzle
)
;
}
protected
:
LValue
*
fParent
;
private
:
int
fInitialSlot
=
0
;
int
fNumSlots
=
0
;
}
;
class
LValueSlice
final
:
public
UnownedLValueSlice
{
public
:
explicit
LValueSlice
(
std
:
:
unique_ptr
<
LValue
>
p
int
initialSlot
int
numSlots
)
:
UnownedLValueSlice
(
p
.
release
(
)
initialSlot
numSlots
)
{
}
~
LValueSlice
(
)
override
{
delete
fParent
;
}
}
;
class
DynamicIndexLValue
final
:
public
LValue
{
public
:
explicit
DynamicIndexLValue
(
std
:
:
unique_ptr
<
LValue
>
p
const
IndexExpression
&
i
)
:
fParent
(
std
:
:
move
(
p
)
)
fIndexExpr
(
&
i
)
{
SkASSERT
(
fIndexExpr
-
>
index
(
)
-
>
type
(
)
.
isInteger
(
)
)
;
}
~
DynamicIndexLValue
(
)
override
{
if
(
fDedicatedStack
.
has_value
(
)
)
{
SkASSERT
(
fGenerator
)
;
fDedicatedStack
-
>
enter
(
)
;
fGenerator
-
>
discardExpression
(
1
)
;
fDedicatedStack
-
>
exit
(
)
;
}
}
bool
isWritable
(
)
const
override
{
return
fParent
-
>
isWritable
(
)
;
}
[
[
nodiscard
]
]
bool
evaluateDynamicIndices
(
Generator
*
gen
)
{
SkASSERT
(
!
fDedicatedStack
.
has_value
(
)
)
;
SkASSERT
(
!
fGenerator
)
;
fGenerator
=
gen
;
fDedicatedStack
.
emplace
(
fGenerator
)
;
if
(
!
fParent
-
>
swizzle
(
)
.
empty
(
)
)
{
SkDEBUGFAIL
(
"
an
indexed
-
swizzle
should
have
been
handled
by
RewriteIndexedSwizzle
"
)
;
return
unsupported
(
)
;
}
fDedicatedStack
-
>
enter
(
)
;
if
(
!
fGenerator
-
>
pushExpression
(
*
fIndexExpr
-
>
index
(
)
)
)
{
return
unsupported
(
)
;
}
int
slotCount
=
fIndexExpr
-
>
type
(
)
.
slotCount
(
)
;
if
(
slotCount
!
=
1
)
{
fGenerator
-
>
builder
(
)
-
>
push_literal_i
(
fIndexExpr
-
>
type
(
)
.
slotCount
(
)
)
;
fGenerator
-
>
builder
(
)
-
>
binary_op
(
BuilderOp
:
:
mul_n_ints
1
)
;
}
if
(
AutoStack
*
parentDynamicIndexStack
=
fParent
-
>
dynamicSlotRange
(
)
)
{
parentDynamicIndexStack
-
>
pushClone
(
1
)
;
fGenerator
-
>
builder
(
)
-
>
binary_op
(
BuilderOp
:
:
add_n_ints
1
)
;
}
fDedicatedStack
-
>
exit
(
)
;
return
true
;
}
SlotRange
fixedSlotRange
(
Generator
*
gen
)
override
{
SlotRange
range
=
fParent
-
>
fixedSlotRange
(
gen
)
;
range
.
count
=
fIndexExpr
-
>
type
(
)
.
slotCount
(
)
;
return
range
;
}
AutoStack
*
dynamicSlotRange
(
)
override
{
SkASSERT
(
fDedicatedStack
.
has_value
(
)
)
;
return
&
*
fDedicatedStack
;
}
[
[
nodiscard
]
]
bool
push
(
Generator
*
gen
SlotRange
fixedOffset
AutoStack
*
dynamicOffset
SkSpan
<
const
int8_t
>
swizzle
)
override
{
return
fParent
-
>
push
(
gen
fixedOffset
dynamicOffset
swizzle
)
;
}
[
[
nodiscard
]
]
bool
store
(
Generator
*
gen
SlotRange
fixedOffset
AutoStack
*
dynamicOffset
SkSpan
<
const
int8_t
>
swizzle
)
override
{
return
fParent
-
>
store
(
gen
fixedOffset
dynamicOffset
swizzle
)
;
}
private
:
Generator
*
fGenerator
=
nullptr
;
std
:
:
unique_ptr
<
LValue
>
fParent
;
std
:
:
optional
<
AutoStack
>
fDedicatedStack
;
const
IndexExpression
*
fIndexExpr
=
nullptr
;
}
;
void
SlotManager
:
:
addSlotDebugInfoForGroup
(
const
std
:
:
string
&
varName
const
Type
&
type
Position
pos
int
*
groupIndex
bool
isFunctionReturnValue
)
{
SkASSERT
(
fSlotDebugInfo
)
;
switch
(
type
.
typeKind
(
)
)
{
case
Type
:
:
TypeKind
:
:
kArray
:
{
int
nslots
=
type
.
columns
(
)
;
const
Type
&
elemType
=
type
.
componentType
(
)
;
for
(
int
slot
=
0
;
slot
<
nslots
;
+
+
slot
)
{
this
-
>
addSlotDebugInfoForGroup
(
varName
+
"
[
"
+
std
:
:
to_string
(
slot
)
+
"
]
"
elemType
pos
groupIndex
isFunctionReturnValue
)
;
}
break
;
}
case
Type
:
:
TypeKind
:
:
kStruct
:
{
for
(
const
Type
:
:
Field
&
field
:
type
.
fields
(
)
)
{
this
-
>
addSlotDebugInfoForGroup
(
varName
+
"
.
"
+
std
:
:
string
(
field
.
fName
)
*
field
.
fType
pos
groupIndex
isFunctionReturnValue
)
;
}
break
;
}
default
:
SkASSERTF
(
0
"
unsupported
slot
type
%
d
"
(
int
)
type
.
typeKind
(
)
)
;
[
[
fallthrough
]
]
;
case
Type
:
:
TypeKind
:
:
kScalar
:
case
Type
:
:
TypeKind
:
:
kVector
:
case
Type
:
:
TypeKind
:
:
kMatrix
:
{
Type
:
:
NumberKind
numberKind
=
type
.
componentType
(
)
.
numberKind
(
)
;
int
nslots
=
type
.
slotCount
(
)
;
for
(
int
slot
=
0
;
slot
<
nslots
;
+
+
slot
)
{
SlotDebugInfo
slotInfo
;
slotInfo
.
name
=
varName
;
slotInfo
.
columns
=
type
.
columns
(
)
;
slotInfo
.
rows
=
type
.
rows
(
)
;
slotInfo
.
componentIndex
=
slot
;
slotInfo
.
groupIndex
=
(
*
groupIndex
)
+
+
;
slotInfo
.
numberKind
=
numberKind
;
slotInfo
.
pos
=
pos
;
slotInfo
.
fnReturnValue
=
isFunctionReturnValue
?
1
:
-
1
;
fSlotDebugInfo
-
>
push_back
(
std
:
:
move
(
slotInfo
)
)
;
}
break
;
}
}
}
void
SlotManager
:
:
addSlotDebugInfo
(
const
std
:
:
string
&
varName
const
Type
&
type
Position
pos
bool
isFunctionReturnValue
)
{
int
groupIndex
=
0
;
this
-
>
addSlotDebugInfoForGroup
(
varName
type
pos
&
groupIndex
isFunctionReturnValue
)
;
SkASSERT
(
(
size_t
)
groupIndex
=
=
type
.
slotCount
(
)
)
;
}
SlotRange
SlotManager
:
:
createSlots
(
std
:
:
string
name
const
Type
&
type
Position
pos
bool
isFunctionReturnValue
)
{
size_t
nslots
=
type
.
slotCount
(
)
;
if
(
nslots
=
=
0
)
{
return
{
}
;
}
if
(
fSlotDebugInfo
)
{
SkASSERT
(
fSlotDebugInfo
-
>
size
(
)
=
=
(
size_t
)
fSlotCount
)
;
fSlotDebugInfo
-
>
reserve
(
fSlotCount
+
nslots
)
;
this
-
>
addSlotDebugInfo
(
name
type
pos
isFunctionReturnValue
)
;
SkASSERT
(
fSlotDebugInfo
-
>
size
(
)
=
=
(
size_t
)
(
fSlotCount
+
nslots
)
)
;
}
SlotRange
result
=
{
fSlotCount
(
int
)
nslots
}
;
fSlotCount
+
=
nslots
;
return
result
;
}
SlotRange
SlotManager
:
:
getVariableSlots
(
const
Variable
&
v
)
{
SlotRange
*
entry
=
fSlotMap
.
find
(
&
v
)
;
if
(
entry
!
=
nullptr
)
{
return
*
entry
;
}
SlotRange
range
=
this
-
>
createSlots
(
std
:
:
string
(
v
.
name
(
)
)
v
.
type
(
)
v
.
fPosition
false
)
;
fSlotMap
.
set
(
&
v
range
)
;
return
range
;
}
SlotRange
SlotManager
:
:
getFunctionSlots
(
const
IRNode
&
callSite
const
FunctionDeclaration
&
f
)
{
SlotRange
*
entry
=
fSlotMap
.
find
(
&
callSite
)
;
if
(
entry
!
=
nullptr
)
{
return
*
entry
;
}
SlotRange
range
=
this
-
>
createSlots
(
"
[
"
+
std
:
:
string
(
f
.
name
(
)
)
+
"
]
.
result
"
f
.
returnType
(
)
f
.
fPosition
true
)
;
fSlotMap
.
set
(
&
callSite
range
)
;
return
range
;
}
static
bool
is_sliceable_swizzle
(
SkSpan
<
const
int8_t
>
components
)
{
for
(
size_t
index
=
1
;
index
<
components
.
size
(
)
;
+
+
index
)
{
if
(
components
[
index
]
!
=
int8_t
(
components
[
0
]
+
index
)
)
{
return
false
;
}
}
return
true
;
}
std
:
:
unique_ptr
<
LValue
>
Generator
:
:
makeLValue
(
const
Expression
&
e
bool
allowScratch
)
{
if
(
e
.
is
<
VariableReference
>
(
)
)
{
return
std
:
:
make_unique
<
VariableLValue
>
(
e
.
as
<
VariableReference
>
(
)
.
variable
(
)
)
;
}
if
(
e
.
is
<
Swizzle
>
(
)
)
{
const
Swizzle
&
swizzleExpr
=
e
.
as
<
Swizzle
>
(
)
;
if
(
std
:
:
unique_ptr
<
LValue
>
base
=
this
-
>
makeLValue
(
*
swizzleExpr
.
base
(
)
allowScratch
)
)
{
const
ComponentArray
&
components
=
swizzleExpr
.
components
(
)
;
if
(
is_sliceable_swizzle
(
components
)
)
{
return
std
:
:
make_unique
<
LValueSlice
>
(
std
:
:
move
(
base
)
components
[
0
]
components
.
size
(
)
)
;
}
return
std
:
:
make_unique
<
SwizzleLValue
>
(
std
:
:
move
(
base
)
components
)
;
}
return
nullptr
;
}
if
(
e
.
is
<
FieldAccess
>
(
)
)
{
const
FieldAccess
&
fieldExpr
=
e
.
as
<
FieldAccess
>
(
)
;
if
(
std
:
:
unique_ptr
<
LValue
>
base
=
this
-
>
makeLValue
(
*
fieldExpr
.
base
(
)
allowScratch
)
)
{
return
std
:
:
make_unique
<
LValueSlice
>
(
std
:
:
move
(
base
)
fieldExpr
.
initialSlot
(
)
fieldExpr
.
type
(
)
.
slotCount
(
)
)
;
}
return
nullptr
;
}
if
(
e
.
is
<
IndexExpression
>
(
)
)
{
const
IndexExpression
&
indexExpr
=
e
.
as
<
IndexExpression
>
(
)
;
if
(
std
:
:
unique_ptr
<
Expression
>
rewritten
=
Transform
:
:
RewriteIndexedSwizzle
(
fContext
indexExpr
)
)
{
std
:
:
unique_ptr
<
LValue
>
lvalue
=
this
-
>
makeLValue
(
*
rewritten
allowScratch
)
;
if
(
!
lvalue
)
{
return
nullptr
;
}
lvalue
-
>
fScratchExpression
=
std
:
:
move
(
rewritten
)
;
return
lvalue
;
}
if
(
std
:
:
unique_ptr
<
LValue
>
base
=
this
-
>
makeLValue
(
*
indexExpr
.
base
(
)
allowScratch
)
)
{
SKSL_INT
indexValue
;
if
(
ConstantFolder
:
:
GetConstantInt
(
*
indexExpr
.
index
(
)
&
indexValue
)
)
{
int
numSlots
=
indexExpr
.
type
(
)
.
slotCount
(
)
;
return
std
:
:
make_unique
<
LValueSlice
>
(
std
:
:
move
(
base
)
numSlots
*
indexValue
numSlots
)
;
}
auto
dynLValue
=
std
:
:
make_unique
<
DynamicIndexLValue
>
(
std
:
:
move
(
base
)
indexExpr
)
;
return
dynLValue
-
>
evaluateDynamicIndices
(
this
)
?
std
:
:
move
(
dynLValue
)
:
nullptr
;
}
return
nullptr
;
}
if
(
allowScratch
)
{
return
std
:
:
make_unique
<
ScratchLValue
>
(
e
)
;
}
return
nullptr
;
}
bool
Generator
:
:
push
(
LValue
&
lvalue
)
{
return
lvalue
.
push
(
this
lvalue
.
fixedSlotRange
(
this
)
lvalue
.
dynamicSlotRange
(
)
{
}
)
;
}
bool
Generator
:
:
store
(
LValue
&
lvalue
)
{
SkASSERT
(
lvalue
.
isWritable
(
)
)
;
return
lvalue
.
store
(
this
lvalue
.
fixedSlotRange
(
this
)
lvalue
.
dynamicSlotRange
(
)
{
}
)
;
}
int
Generator
:
:
getFunctionDebugInfo
(
const
FunctionDeclaration
&
decl
)
{
SkASSERT
(
fDebugTrace
)
;
std
:
:
string
name
=
decl
.
description
(
)
;
static
constexpr
std
:
:
string_view
kNoInline
=
"
noinline
"
;
if
(
skstd
:
:
starts_with
(
name
kNoInline
)
)
{
name
=
name
.
substr
(
kNoInline
.
size
(
)
)
;
}
for
(
size_t
index
=
0
;
index
<
fDebugTrace
-
>
fFuncInfo
.
size
(
)
;
+
+
index
)
{
if
(
fDebugTrace
-
>
fFuncInfo
[
index
]
.
name
=
=
name
)
{
return
index
;
}
}
int
slot
=
(
int
)
fDebugTrace
-
>
fFuncInfo
.
size
(
)
;
fDebugTrace
-
>
fFuncInfo
.
push_back
(
FunctionDebugInfo
{
std
:
:
move
(
name
)
}
)
;
return
slot
;
}
int
Generator
:
:
createStack
(
)
{
if
(
!
fRecycledStacks
.
empty
(
)
)
{
int
stackID
=
fRecycledStacks
.
back
(
)
;
fRecycledStacks
.
pop_back
(
)
;
return
stackID
;
}
return
+
+
fNextStackID
;
}
void
Generator
:
:
recycleStack
(
int
stackID
)
{
fRecycledStacks
.
push_back
(
stackID
)
;
}
void
Generator
:
:
setCurrentStack
(
int
stackID
)
{
if
(
fCurrentStack
!
=
stackID
)
{
fCurrentStack
=
stackID
;
fBuilder
.
set_current_stack
(
stackID
)
;
}
}
std
:
:
optional
<
SlotRange
>
Generator
:
:
writeFunction
(
const
IRNode
&
callSite
const
FunctionDefinition
&
function
)
{
[
[
maybe_unused
]
]
int
funcIndex
=
-
1
;
if
(
fDebugTrace
)
{
funcIndex
=
this
-
>
getFunctionDebugInfo
(
function
.
declaration
(
)
)
;
SkASSERT
(
funcIndex
>
=
0
)
;
}
SlotRange
lastFunctionResult
=
fCurrentFunctionResult
;
fCurrentFunctionResult
=
this
-
>
getFunctionSlots
(
callSite
function
.
declaration
(
)
)
;
if
(
!
this
-
>
writeStatement
(
*
function
.
body
(
)
)
)
{
return
std
:
:
nullopt
;
}
SlotRange
functionResult
=
fCurrentFunctionResult
;
fCurrentFunctionResult
=
lastFunctionResult
;
if
(
fDebugTrace
)
{
}
return
functionResult
;
}
bool
Generator
:
:
writeGlobals
(
)
{
for
(
const
ProgramElement
*
e
:
fProgram
.
elements
(
)
)
{
if
(
e
-
>
is
<
GlobalVarDeclaration
>
(
)
)
{
const
GlobalVarDeclaration
&
gvd
=
e
-
>
as
<
GlobalVarDeclaration
>
(
)
;
const
VarDeclaration
&
decl
=
gvd
.
varDeclaration
(
)
;
const
Variable
*
var
=
decl
.
var
(
)
;
if
(
var
-
>
type
(
)
.
isEffectChild
(
)
)
{
SkASSERT
(
!
fChildEffectMap
.
find
(
var
)
)
;
int
childEffectIndex
=
fChildEffectMap
.
count
(
)
;
fChildEffectMap
[
var
]
=
childEffectIndex
;
continue
;
}
SkASSERT
(
!
var
-
>
type
(
)
.
isVoid
(
)
)
;
SkASSERT
(
!
var
-
>
type
(
)
.
isOpaque
(
)
)
;
if
(
int
builtin
=
var
-
>
modifiers
(
)
.
fLayout
.
fBuiltin
;
builtin
>
=
0
)
{
if
(
builtin
=
=
SK_FRAGCOORD_BUILTIN
)
{
fBuilder
.
store_device_xy01
(
this
-
>
getVariableSlots
(
*
var
)
)
;
continue
;
}
return
unsupported
(
)
;
}
if
(
IsUniform
(
*
var
)
)
{
(
void
)
this
-
>
getUniformSlots
(
*
var
)
;
continue
;
}
if
(
!
this
-
>
writeVarDeclaration
(
decl
)
)
{
return
unsupported
(
)
;
}
}
}
return
true
;
}
bool
Generator
:
:
writeStatement
(
const
Statement
&
s
)
{
switch
(
s
.
kind
(
)
)
{
case
Statement
:
:
Kind
:
:
kBlock
:
return
this
-
>
writeBlock
(
s
.
as
<
Block
>
(
)
)
;
case
Statement
:
:
Kind
:
:
kBreak
:
return
this
-
>
writeBreakStatement
(
s
.
as
<
BreakStatement
>
(
)
)
;
case
Statement
:
:
Kind
:
:
kContinue
:
return
this
-
>
writeContinueStatement
(
s
.
as
<
ContinueStatement
>
(
)
)
;
case
Statement
:
:
Kind
:
:
kDo
:
return
this
-
>
writeDoStatement
(
s
.
as
<
DoStatement
>
(
)
)
;
case
Statement
:
:
Kind
:
:
kExpression
:
return
this
-
>
writeExpressionStatement
(
s
.
as
<
ExpressionStatement
>
(
)
)
;
case
Statement
:
:
Kind
:
:
kFor
:
return
this
-
>
writeForStatement
(
s
.
as
<
ForStatement
>
(
)
)
;
case
Statement
:
:
Kind
:
:
kIf
:
return
this
-
>
writeIfStatement
(
s
.
as
<
IfStatement
>
(
)
)
;
case
Statement
:
:
Kind
:
:
kNop
:
return
true
;
case
Statement
:
:
Kind
:
:
kReturn
:
return
this
-
>
writeReturnStatement
(
s
.
as
<
ReturnStatement
>
(
)
)
;
case
Statement
:
:
Kind
:
:
kSwitch
:
return
this
-
>
writeSwitchStatement
(
s
.
as
<
SwitchStatement
>
(
)
)
;
case
Statement
:
:
Kind
:
:
kVarDeclaration
:
return
this
-
>
writeVarDeclaration
(
s
.
as
<
VarDeclaration
>
(
)
)
;
default
:
return
unsupported
(
)
;
}
}
bool
Generator
:
:
writeBlock
(
const
Block
&
b
)
{
for
(
const
std
:
:
unique_ptr
<
Statement
>
&
stmt
:
b
.
children
(
)
)
{
if
(
!
this
-
>
writeStatement
(
*
stmt
)
)
{
return
unsupported
(
)
;
}
}
return
true
;
}
bool
Generator
:
:
writeBreakStatement
(
const
BreakStatement
&
)
{
fBuilder
.
branch_if_all_lanes_active
(
fCurrentBreakTarget
)
;
fBuilder
.
mask_off_loop_mask
(
)
;
return
true
;
}
bool
Generator
:
:
writeContinueStatement
(
const
ContinueStatement
&
)
{
fCurrentContinueMask
-
>
enter
(
)
;
fBuilder
.
push_literal_i
(
~
0
)
;
fBuilder
.
select
(
1
)
;
fBuilder
.
mask_off_loop_mask
(
)
;
fCurrentContinueMask
-
>
exit
(
)
;
return
true
;
}
bool
Generator
:
:
writeDoStatement
(
const
DoStatement
&
d
)
{
AutoLoopTarget
breakTarget
(
this
&
fCurrentBreakTarget
)
;
fBuilder
.
enableExecutionMaskWrites
(
)
;
fBuilder
.
push_loop_mask
(
)
;
Analysis
:
:
LoopControlFlowInfo
loopInfo
=
Analysis
:
:
GetLoopControlFlowInfo
(
*
d
.
statement
(
)
)
;
AutoContinueMask
autoContinueMask
(
this
)
;
if
(
loopInfo
.
fHasContinue
)
{
autoContinueMask
.
enable
(
)
;
}
int
labelID
=
fBuilder
.
nextLabelID
(
)
;
fBuilder
.
label
(
labelID
)
;
autoContinueMask
.
enterLoopBody
(
)
;
if
(
!
this
-
>
writeStatement
(
*
d
.
statement
(
)
)
)
{
return
false
;
}
autoContinueMask
.
exitLoopBody
(
)
;
if
(
!
this
-
>
pushExpression
(
*
d
.
test
(
)
)
)
{
return
false
;
}
fBuilder
.
merge_loop_mask
(
)
;
this
-
>
discardExpression
(
1
)
;
fBuilder
.
branch_if_any_lanes_active
(
labelID
)
;
fBuilder
.
label
(
breakTarget
.
labelID
(
)
)
;
fBuilder
.
pop_loop_mask
(
)
;
fBuilder
.
disableExecutionMaskWrites
(
)
;
return
true
;
}
bool
Generator
:
:
writeMasklessForStatement
(
const
ForStatement
&
f
)
{
SkASSERT
(
f
.
unrollInfo
(
)
)
;
SkASSERT
(
f
.
unrollInfo
(
)
-
>
fCount
>
0
)
;
SkASSERT
(
f
.
initializer
(
)
)
;
SkASSERT
(
f
.
test
(
)
)
;
SkASSERT
(
f
.
next
(
)
)
;
int
loopExitID
=
fBuilder
.
nextLabelID
(
)
;
int
loopBodyID
=
fBuilder
.
nextLabelID
(
)
;
fBuilder
.
branch_if_no_lanes_active
(
loopExitID
)
;
if
(
!
this
-
>
writeStatement
(
*
f
.
initializer
(
)
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
label
(
loopBodyID
)
;
if
(
!
this
-
>
writeStatement
(
*
f
.
statement
(
)
)
)
{
return
unsupported
(
)
;
}
if
(
f
.
unrollInfo
(
)
-
>
fCount
>
1
)
{
if
(
!
this
-
>
pushExpression
(
*
f
.
next
(
)
false
)
)
{
return
unsupported
(
)
;
}
this
-
>
discardExpression
(
f
.
next
(
)
-
>
type
(
)
.
slotCount
(
)
)
;
if
(
!
this
-
>
pushExpression
(
*
f
.
test
(
)
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
branch_if_no_active_lanes_on_stack_top_equal
(
0
loopBodyID
)
;
this
-
>
discardExpression
(
1
)
;
}
fBuilder
.
label
(
loopExitID
)
;
return
true
;
}
bool
Generator
:
:
writeForStatement
(
const
ForStatement
&
f
)
{
if
(
f
.
unrollInfo
(
)
&
&
f
.
unrollInfo
(
)
-
>
fCount
=
=
0
)
{
return
true
;
}
Analysis
:
:
LoopControlFlowInfo
loopInfo
=
Analysis
:
:
GetLoopControlFlowInfo
(
*
f
.
statement
(
)
)
;
if
(
!
loopInfo
.
fHasContinue
&
&
!
loopInfo
.
fHasBreak
&
&
!
loopInfo
.
fHasReturn
&
&
f
.
unrollInfo
(
)
)
{
return
this
-
>
writeMasklessForStatement
(
f
)
;
}
AutoLoopTarget
breakTarget
(
this
&
fCurrentBreakTarget
)
;
if
(
f
.
initializer
(
)
&
&
!
this
-
>
writeStatement
(
*
f
.
initializer
(
)
)
)
{
return
unsupported
(
)
;
}
AutoContinueMask
autoContinueMask
(
this
)
;
if
(
loopInfo
.
fHasContinue
)
{
autoContinueMask
.
enable
(
)
;
}
fBuilder
.
enableExecutionMaskWrites
(
)
;
fBuilder
.
push_loop_mask
(
)
;
int
loopTestID
=
fBuilder
.
nextLabelID
(
)
;
int
loopBodyID
=
fBuilder
.
nextLabelID
(
)
;
fBuilder
.
jump
(
loopTestID
)
;
fBuilder
.
label
(
loopBodyID
)
;
autoContinueMask
.
enterLoopBody
(
)
;
if
(
!
this
-
>
writeStatement
(
*
f
.
statement
(
)
)
)
{
return
unsupported
(
)
;
}
autoContinueMask
.
exitLoopBody
(
)
;
if
(
f
.
next
(
)
)
{
if
(
!
this
-
>
pushExpression
(
*
f
.
next
(
)
false
)
)
{
return
unsupported
(
)
;
}
this
-
>
discardExpression
(
f
.
next
(
)
-
>
type
(
)
.
slotCount
(
)
)
;
}
fBuilder
.
label
(
loopTestID
)
;
if
(
f
.
test
(
)
)
{
if
(
!
this
-
>
pushExpression
(
*
f
.
test
(
)
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
merge_loop_mask
(
)
;
this
-
>
discardExpression
(
1
)
;
}
fBuilder
.
branch_if_any_lanes_active
(
loopBodyID
)
;
fBuilder
.
label
(
breakTarget
.
labelID
(
)
)
;
fBuilder
.
pop_loop_mask
(
)
;
fBuilder
.
disableExecutionMaskWrites
(
)
;
return
true
;
}
bool
Generator
:
:
writeExpressionStatement
(
const
ExpressionStatement
&
e
)
{
if
(
!
this
-
>
pushExpression
(
*
e
.
expression
(
)
false
)
)
{
return
unsupported
(
)
;
}
this
-
>
discardExpression
(
e
.
expression
(
)
-
>
type
(
)
.
slotCount
(
)
)
;
return
true
;
}
bool
Generator
:
:
writeDynamicallyUniformIfStatement
(
const
IfStatement
&
i
)
{
SkASSERT
(
Analysis
:
:
IsDynamicallyUniformExpression
(
*
i
.
test
(
)
)
)
;
int
falseLabelID
=
fBuilder
.
nextLabelID
(
)
;
int
exitLabelID
=
fBuilder
.
nextLabelID
(
)
;
if
(
!
this
-
>
pushExpression
(
*
i
.
test
(
)
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
branch_if_no_active_lanes_on_stack_top_equal
(
~
0
falseLabelID
)
;
if
(
!
this
-
>
writeStatement
(
*
i
.
ifTrue
(
)
)
)
{
return
unsupported
(
)
;
}
if
(
!
i
.
ifFalse
(
)
)
{
fBuilder
.
label
(
falseLabelID
)
;
}
else
{
fBuilder
.
jump
(
exitLabelID
)
;
fBuilder
.
label
(
falseLabelID
)
;
if
(
!
this
-
>
writeStatement
(
*
i
.
ifFalse
(
)
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
label
(
exitLabelID
)
;
}
this
-
>
discardExpression
(
1
)
;
return
true
;
}
bool
Generator
:
:
writeIfStatement
(
const
IfStatement
&
i
)
{
if
(
Analysis
:
:
IsDynamicallyUniformExpression
(
*
i
.
test
(
)
)
)
{
return
this
-
>
writeDynamicallyUniformIfStatement
(
i
)
;
}
fBuilder
.
enableExecutionMaskWrites
(
)
;
fBuilder
.
push_condition_mask
(
)
;
if
(
!
this
-
>
pushExpression
(
*
i
.
test
(
)
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
merge_condition_mask
(
)
;
if
(
!
this
-
>
writeStatement
(
*
i
.
ifTrue
(
)
)
)
{
return
unsupported
(
)
;
}
if
(
i
.
ifFalse
(
)
)
{
fBuilder
.
unary_op
(
BuilderOp
:
:
bitwise_not_int
1
)
;
fBuilder
.
merge_condition_mask
(
)
;
if
(
!
this
-
>
writeStatement
(
*
i
.
ifFalse
(
)
)
)
{
return
unsupported
(
)
;
}
}
this
-
>
discardExpression
(
1
)
;
fBuilder
.
pop_condition_mask
(
)
;
fBuilder
.
disableExecutionMaskWrites
(
)
;
return
true
;
}
bool
Generator
:
:
writeReturnStatement
(
const
ReturnStatement
&
r
)
{
if
(
r
.
expression
(
)
)
{
if
(
!
this
-
>
pushExpression
(
*
r
.
expression
(
)
)
)
{
return
unsupported
(
)
;
}
if
(
this
-
>
needsFunctionResultSlots
(
)
)
{
this
-
>
popToSlotRange
(
fCurrentFunctionResult
)
;
}
}
if
(
fBuilder
.
executionMaskWritesAreEnabled
(
)
&
&
this
-
>
needsReturnMask
(
)
)
{
fBuilder
.
mask_off_return_mask
(
)
;
}
return
true
;
}
bool
Generator
:
:
writeSwitchStatement
(
const
SwitchStatement
&
s
)
{
const
StatementArray
&
cases
=
s
.
cases
(
)
;
SkASSERT
(
std
:
:
all_of
(
cases
.
begin
(
)
cases
.
end
(
)
[
]
(
const
std
:
:
unique_ptr
<
Statement
>
&
stmt
)
{
return
stmt
-
>
is
<
SwitchCase
>
(
)
;
}
)
)
;
AutoLoopTarget
breakTarget
(
this
&
fCurrentBreakTarget
)
;
fBuilder
.
enableExecutionMaskWrites
(
)
;
fBuilder
.
push_loop_mask
(
)
;
if
(
!
this
-
>
pushExpression
(
*
s
.
value
(
)
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
push_loop_mask
(
)
;
fBuilder
.
mask_off_loop_mask
(
)
;
bool
foundDefaultCase
=
false
;
for
(
const
std
:
:
unique_ptr
<
Statement
>
&
stmt
:
cases
)
{
int
skipLabelID
=
fBuilder
.
nextLabelID
(
)
;
const
SwitchCase
&
sc
=
stmt
-
>
as
<
SwitchCase
>
(
)
;
if
(
sc
.
isDefault
(
)
)
{
foundDefaultCase
=
true
;
if
(
stmt
.
get
(
)
!
=
cases
.
back
(
)
.
get
(
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
pop_and_reenable_loop_mask
(
)
;
fBuilder
.
branch_if_no_lanes_active
(
skipLabelID
)
;
if
(
!
this
-
>
writeStatement
(
*
sc
.
statement
(
)
)
)
{
return
unsupported
(
)
;
}
}
else
{
fBuilder
.
case_op
(
sc
.
value
(
)
)
;
fBuilder
.
branch_if_no_lanes_active
(
skipLabelID
)
;
if
(
!
this
-
>
writeStatement
(
*
sc
.
statement
(
)
)
)
{
return
unsupported
(
)
;
}
}
fBuilder
.
label
(
skipLabelID
)
;
}
this
-
>
discardExpression
(
foundDefaultCase
?
1
:
2
)
;
fBuilder
.
label
(
breakTarget
.
labelID
(
)
)
;
fBuilder
.
pop_loop_mask
(
)
;
fBuilder
.
disableExecutionMaskWrites
(
)
;
return
true
;
}
bool
Generator
:
:
writeVarDeclaration
(
const
VarDeclaration
&
v
)
{
if
(
v
.
value
(
)
)
{
if
(
!
this
-
>
pushExpression
(
*
v
.
value
(
)
)
)
{
return
unsupported
(
)
;
}
this
-
>
popToSlotRangeUnmasked
(
this
-
>
getVariableSlots
(
*
v
.
var
(
)
)
)
;
}
else
{
this
-
>
zeroSlotRangeUnmasked
(
this
-
>
getVariableSlots
(
*
v
.
var
(
)
)
)
;
}
return
true
;
}
bool
Generator
:
:
pushExpression
(
const
Expression
&
e
bool
usesResult
)
{
switch
(
e
.
kind
(
)
)
{
case
Expression
:
:
Kind
:
:
kBinary
:
return
this
-
>
pushBinaryExpression
(
e
.
as
<
BinaryExpression
>
(
)
)
;
case
Expression
:
:
Kind
:
:
kChildCall
:
return
this
-
>
pushChildCall
(
e
.
as
<
ChildCall
>
(
)
)
;
case
Expression
:
:
Kind
:
:
kConstructorArray
:
case
Expression
:
:
Kind
:
:
kConstructorArrayCast
:
case
Expression
:
:
Kind
:
:
kConstructorCompound
:
case
Expression
:
:
Kind
:
:
kConstructorStruct
:
return
this
-
>
pushConstructorCompound
(
e
.
asAnyConstructor
(
)
)
;
case
Expression
:
:
Kind
:
:
kConstructorCompoundCast
:
case
Expression
:
:
Kind
:
:
kConstructorScalarCast
:
return
this
-
>
pushConstructorCast
(
e
.
asAnyConstructor
(
)
)
;
case
Expression
:
:
Kind
:
:
kConstructorDiagonalMatrix
:
return
this
-
>
pushConstructorDiagonalMatrix
(
e
.
as
<
ConstructorDiagonalMatrix
>
(
)
)
;
case
Expression
:
:
Kind
:
:
kConstructorMatrixResize
:
return
this
-
>
pushConstructorMatrixResize
(
e
.
as
<
ConstructorMatrixResize
>
(
)
)
;
case
Expression
:
:
Kind
:
:
kConstructorSplat
:
return
this
-
>
pushConstructorSplat
(
e
.
as
<
ConstructorSplat
>
(
)
)
;
case
Expression
:
:
Kind
:
:
kFieldAccess
:
return
this
-
>
pushFieldAccess
(
e
.
as
<
FieldAccess
>
(
)
)
;
case
Expression
:
:
Kind
:
:
kFunctionCall
:
return
this
-
>
pushFunctionCall
(
e
.
as
<
FunctionCall
>
(
)
)
;
case
Expression
:
:
Kind
:
:
kIndex
:
return
this
-
>
pushIndexExpression
(
e
.
as
<
IndexExpression
>
(
)
)
;
case
Expression
:
:
Kind
:
:
kLiteral
:
return
this
-
>
pushLiteral
(
e
.
as
<
Literal
>
(
)
)
;
case
Expression
:
:
Kind
:
:
kPrefix
:
return
this
-
>
pushPrefixExpression
(
e
.
as
<
PrefixExpression
>
(
)
)
;
case
Expression
:
:
Kind
:
:
kPostfix
:
return
this
-
>
pushPostfixExpression
(
e
.
as
<
PostfixExpression
>
(
)
usesResult
)
;
case
Expression
:
:
Kind
:
:
kSwizzle
:
return
this
-
>
pushSwizzle
(
e
.
as
<
Swizzle
>
(
)
)
;
case
Expression
:
:
Kind
:
:
kTernary
:
return
this
-
>
pushTernaryExpression
(
e
.
as
<
TernaryExpression
>
(
)
)
;
case
Expression
:
:
Kind
:
:
kVariableReference
:
return
this
-
>
pushVariableReference
(
e
.
as
<
VariableReference
>
(
)
)
;
default
:
return
unsupported
(
)
;
}
}
BuilderOp
Generator
:
:
GetTypedOp
(
const
SkSL
:
:
Type
&
type
const
TypedOps
&
ops
)
{
switch
(
type
.
componentType
(
)
.
numberKind
(
)
)
{
case
Type
:
:
NumberKind
:
:
kFloat
:
return
ops
.
fFloatOp
;
case
Type
:
:
NumberKind
:
:
kSigned
:
return
ops
.
fSignedOp
;
case
Type
:
:
NumberKind
:
:
kUnsigned
:
return
ops
.
fUnsignedOp
;
case
Type
:
:
NumberKind
:
:
kBoolean
:
return
ops
.
fBooleanOp
;
default
:
return
BuilderOp
:
:
unsupported
;
}
}
bool
Generator
:
:
unaryOp
(
const
SkSL
:
:
Type
&
type
const
TypedOps
&
ops
)
{
BuilderOp
op
=
GetTypedOp
(
type
ops
)
;
if
(
op
=
=
BuilderOp
:
:
unsupported
)
{
return
unsupported
(
)
;
}
fBuilder
.
unary_op
(
op
type
.
slotCount
(
)
)
;
return
true
;
}
bool
Generator
:
:
binaryOp
(
const
SkSL
:
:
Type
&
type
const
TypedOps
&
ops
)
{
BuilderOp
op
=
GetTypedOp
(
type
ops
)
;
if
(
op
=
=
BuilderOp
:
:
unsupported
)
{
return
unsupported
(
)
;
}
fBuilder
.
binary_op
(
op
type
.
slotCount
(
)
)
;
return
true
;
}
bool
Generator
:
:
ternaryOp
(
const
SkSL
:
:
Type
&
type
const
TypedOps
&
ops
)
{
BuilderOp
op
=
GetTypedOp
(
type
ops
)
;
if
(
op
=
=
BuilderOp
:
:
unsupported
)
{
return
unsupported
(
)
;
}
fBuilder
.
ternary_op
(
op
type
.
slotCount
(
)
)
;
return
true
;
}
void
Generator
:
:
foldWithMultiOp
(
BuilderOp
op
int
elements
)
{
for
(
;
elements
>
=
8
;
elements
-
=
4
)
{
fBuilder
.
binary_op
(
op
4
)
;
}
for
(
;
elements
>
=
6
;
elements
-
=
3
)
{
fBuilder
.
binary_op
(
op
3
)
;
}
for
(
;
elements
>
=
4
;
elements
-
=
2
)
{
fBuilder
.
binary_op
(
op
2
)
;
}
for
(
;
elements
>
=
2
;
elements
-
=
1
)
{
fBuilder
.
binary_op
(
op
1
)
;
}
}
bool
Generator
:
:
pushLValueOrExpression
(
LValue
*
lvalue
const
Expression
&
expr
)
{
return
lvalue
?
this
-
>
push
(
*
lvalue
)
:
this
-
>
pushExpression
(
expr
)
;
}
bool
Generator
:
:
pushMatrixMultiply
(
LValue
*
lvalue
const
Expression
&
left
const
Expression
&
right
int
leftColumns
int
leftRows
int
rightColumns
int
rightRows
)
{
SkASSERT
(
left
.
type
(
)
.
isMatrix
(
)
|
|
left
.
type
(
)
.
isVector
(
)
)
;
SkASSERT
(
right
.
type
(
)
.
isMatrix
(
)
|
|
right
.
type
(
)
.
isVector
(
)
)
;
SkASSERT
(
leftColumns
=
=
rightRows
)
;
int
outColumns
=
rightColumns
outRows
=
leftRows
;
AutoStack
matrixStack
(
this
)
;
matrixStack
.
enter
(
)
;
if
(
!
this
-
>
pushLValueOrExpression
(
lvalue
left
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
transpose
(
leftColumns
leftRows
)
;
if
(
!
this
-
>
pushExpression
(
right
)
)
{
return
unsupported
(
)
;
}
matrixStack
.
exit
(
)
;
int
leftMtxBase
=
left
.
type
(
)
.
slotCount
(
)
+
right
.
type
(
)
.
slotCount
(
)
;
int
rightMtxBase
=
right
.
type
(
)
.
slotCount
(
)
;
for
(
int
c
=
0
;
c
<
outColumns
;
+
+
c
)
{
for
(
int
r
=
0
;
r
<
outRows
;
+
+
r
)
{
matrixStack
.
pushClone
(
SlotRange
{
r
*
leftColumns
leftColumns
}
leftMtxBase
)
;
matrixStack
.
pushClone
(
SlotRange
{
c
*
leftColumns
leftColumns
}
rightMtxBase
)
;
fBuilder
.
dot_floats
(
leftColumns
)
;
}
}
matrixStack
.
enter
(
)
;
this
-
>
discardExpression
(
left
.
type
(
)
.
slotCount
(
)
)
;
this
-
>
discardExpression
(
right
.
type
(
)
.
slotCount
(
)
)
;
matrixStack
.
exit
(
)
;
return
lvalue
?
this
-
>
store
(
*
lvalue
)
:
true
;
}
void
Generator
:
:
foldComparisonOp
(
Operator
op
int
elements
)
{
switch
(
op
.
kind
(
)
)
{
case
OperatorKind
:
:
EQEQ
:
this
-
>
foldWithMultiOp
(
BuilderOp
:
:
bitwise_and_n_ints
elements
)
;
break
;
case
OperatorKind
:
:
NEQ
:
this
-
>
foldWithMultiOp
(
BuilderOp
:
:
bitwise_or_n_ints
elements
)
;
break
;
default
:
SkDEBUGFAIL
(
"
comparison
only
allows
=
=
and
!
=
"
)
;
break
;
}
}
bool
Generator
:
:
pushStructuredComparison
(
LValue
*
left
Operator
op
LValue
*
right
const
Type
&
type
)
{
if
(
type
.
isStruct
(
)
)
{
SkSpan
<
const
Type
:
:
Field
>
fields
=
type
.
fields
(
)
;
int
currentSlot
=
0
;
for
(
size_t
index
=
0
;
index
<
fields
.
size
(
)
;
+
+
index
)
{
const
Type
&
fieldType
=
*
fields
[
index
]
.
fType
;
const
int
fieldSlotCount
=
fieldType
.
slotCount
(
)
;
UnownedLValueSlice
fieldLeft
{
left
currentSlot
fieldSlotCount
}
;
UnownedLValueSlice
fieldRight
{
right
currentSlot
fieldSlotCount
}
;
if
(
!
this
-
>
pushStructuredComparison
(
&
fieldLeft
op
&
fieldRight
fieldType
)
)
{
return
unsupported
(
)
;
}
currentSlot
+
=
fieldSlotCount
;
}
this
-
>
foldComparisonOp
(
op
fields
.
size
(
)
)
;
return
true
;
}
if
(
type
.
isArray
(
)
)
{
const
Type
&
indexedType
=
type
.
componentType
(
)
;
if
(
indexedType
.
numberKind
(
)
=
=
Type
:
:
NumberKind
:
:
kNonnumeric
)
{
const
int
indexedSlotCount
=
indexedType
.
slotCount
(
)
;
int
currentSlot
=
0
;
for
(
int
index
=
0
;
index
<
type
.
columns
(
)
;
+
+
index
)
{
UnownedLValueSlice
indexedLeft
{
left
currentSlot
indexedSlotCount
}
;
UnownedLValueSlice
indexedRight
{
right
currentSlot
indexedSlotCount
}
;
if
(
!
this
-
>
pushStructuredComparison
(
&
indexedLeft
op
&
indexedRight
indexedType
)
)
{
return
unsupported
(
)
;
}
currentSlot
+
=
indexedSlotCount
;
}
this
-
>
foldComparisonOp
(
op
type
.
columns
(
)
)
;
return
true
;
}
}
if
(
!
this
-
>
push
(
*
left
)
|
|
!
this
-
>
push
(
*
right
)
)
{
return
unsupported
(
)
;
}
switch
(
op
.
kind
(
)
)
{
case
OperatorKind
:
:
EQEQ
:
if
(
!
this
-
>
binaryOp
(
type
kEqualOps
)
)
{
return
unsupported
(
)
;
}
break
;
case
OperatorKind
:
:
NEQ
:
if
(
!
this
-
>
binaryOp
(
type
kNotEqualOps
)
)
{
return
unsupported
(
)
;
}
break
;
default
:
SkDEBUGFAIL
(
"
comparison
only
allows
=
=
and
!
=
"
)
;
break
;
}
this
-
>
foldComparisonOp
(
op
type
.
slotCount
(
)
)
;
return
true
;
}
bool
Generator
:
:
pushBinaryExpression
(
const
BinaryExpression
&
e
)
{
return
this
-
>
pushBinaryExpression
(
*
e
.
left
(
)
e
.
getOperator
(
)
*
e
.
right
(
)
)
;
}
bool
Generator
:
:
pushBinaryExpression
(
const
Expression
&
left
Operator
op
const
Expression
&
right
)
{
switch
(
op
.
kind
(
)
)
{
case
OperatorKind
:
:
GT
:
return
this
-
>
pushBinaryExpression
(
right
OperatorKind
:
:
LT
left
)
;
case
OperatorKind
:
:
GTEQ
:
return
this
-
>
pushBinaryExpression
(
right
OperatorKind
:
:
LTEQ
left
)
;
case
OperatorKind
:
:
EQEQ
:
case
OperatorKind
:
:
NEQ
:
if
(
left
.
type
(
)
.
isStruct
(
)
|
|
left
.
type
(
)
.
isArray
(
)
)
{
SkASSERT
(
left
.
type
(
)
.
matches
(
right
.
type
(
)
)
)
;
std
:
:
unique_ptr
<
LValue
>
lvLeft
=
this
-
>
makeLValue
(
left
true
)
;
std
:
:
unique_ptr
<
LValue
>
lvRight
=
this
-
>
makeLValue
(
right
true
)
;
return
this
-
>
pushStructuredComparison
(
lvLeft
.
get
(
)
op
lvRight
.
get
(
)
left
.
type
(
)
)
;
}
break
;
case
OperatorKind
:
:
COMMA
:
if
(
Analysis
:
:
HasSideEffects
(
left
)
)
{
if
(
!
this
-
>
pushExpression
(
left
false
)
)
{
return
unsupported
(
)
;
}
this
-
>
discardExpression
(
left
.
type
(
)
.
slotCount
(
)
)
;
}
return
this
-
>
pushExpression
(
right
)
;
default
:
break
;
}
bool
vectorizeLeft
=
false
vectorizeRight
=
false
;
if
(
!
left
.
type
(
)
.
matches
(
right
.
type
(
)
)
)
{
if
(
left
.
type
(
)
.
componentType
(
)
.
numberKind
(
)
!
=
right
.
type
(
)
.
componentType
(
)
.
numberKind
(
)
)
{
return
unsupported
(
)
;
}
if
(
left
.
type
(
)
.
isScalar
(
)
&
&
(
right
.
type
(
)
.
isVector
(
)
|
|
right
.
type
(
)
.
isMatrix
(
)
)
)
{
vectorizeLeft
=
true
;
}
else
if
(
(
left
.
type
(
)
.
isVector
(
)
|
|
left
.
type
(
)
.
isMatrix
(
)
)
&
&
right
.
type
(
)
.
isScalar
(
)
)
{
vectorizeRight
=
true
;
}
}
const
Type
&
type
=
vectorizeLeft
?
right
.
type
(
)
:
left
.
type
(
)
;
std
:
:
unique_ptr
<
LValue
>
lvalue
;
if
(
op
.
isAssignment
(
)
)
{
lvalue
=
this
-
>
makeLValue
(
left
)
;
if
(
!
lvalue
)
{
return
unsupported
(
)
;
}
if
(
op
.
kind
(
)
=
=
OperatorKind
:
:
EQ
)
{
return
this
-
>
pushExpression
(
right
)
&
&
this
-
>
store
(
*
lvalue
)
;
}
op
=
op
.
removeAssignment
(
)
;
}
if
(
op
.
kind
(
)
=
=
OperatorKind
:
:
STAR
)
{
if
(
left
.
type
(
)
.
isMatrix
(
)
&
&
right
.
type
(
)
.
isMatrix
(
)
)
{
return
this
-
>
pushMatrixMultiply
(
lvalue
.
get
(
)
left
right
left
.
type
(
)
.
columns
(
)
left
.
type
(
)
.
rows
(
)
right
.
type
(
)
.
columns
(
)
right
.
type
(
)
.
rows
(
)
)
;
}
if
(
left
.
type
(
)
.
isVector
(
)
&
&
right
.
type
(
)
.
isMatrix
(
)
)
{
return
this
-
>
pushMatrixMultiply
(
lvalue
.
get
(
)
left
right
left
.
type
(
)
.
columns
(
)
1
right
.
type
(
)
.
columns
(
)
right
.
type
(
)
.
rows
(
)
)
;
}
if
(
left
.
type
(
)
.
isMatrix
(
)
&
&
right
.
type
(
)
.
isVector
(
)
)
{
return
this
-
>
pushMatrixMultiply
(
lvalue
.
get
(
)
left
right
left
.
type
(
)
.
columns
(
)
left
.
type
(
)
.
rows
(
)
1
right
.
type
(
)
.
columns
(
)
)
;
}
}
if
(
!
vectorizeLeft
&
&
!
vectorizeRight
&
&
!
type
.
matches
(
right
.
type
(
)
)
)
{
return
unsupported
(
)
;
}
switch
(
op
.
kind
(
)
)
{
case
OperatorKind
:
:
LOGICALAND
:
if
(
Analysis
:
:
HasSideEffects
(
right
)
)
{
SkASSERT
(
!
op
.
isAssignment
(
)
)
;
SkASSERT
(
type
.
componentType
(
)
.
isBoolean
(
)
)
;
SkASSERT
(
type
.
slotCount
(
)
=
=
1
)
;
Literal
falseLiteral
{
Position
{
}
0
.
0
&
right
.
type
(
)
}
;
return
this
-
>
pushTernaryExpression
(
left
right
falseLiteral
)
;
}
break
;
case
OperatorKind
:
:
LOGICALOR
:
if
(
Analysis
:
:
HasSideEffects
(
right
)
)
{
SkASSERT
(
!
op
.
isAssignment
(
)
)
;
SkASSERT
(
type
.
componentType
(
)
.
isBoolean
(
)
)
;
SkASSERT
(
type
.
slotCount
(
)
=
=
1
)
;
Literal
trueLiteral
{
Position
{
}
1
.
0
&
right
.
type
(
)
}
;
return
this
-
>
pushTernaryExpression
(
left
trueLiteral
right
)
;
}
break
;
default
:
break
;
}
if
(
!
this
-
>
pushLValueOrExpression
(
lvalue
.
get
(
)
left
)
)
{
return
unsupported
(
)
;
}
if
(
vectorizeLeft
)
{
fBuilder
.
push_duplicates
(
right
.
type
(
)
.
slotCount
(
)
-
1
)
;
}
if
(
!
this
-
>
pushExpression
(
right
)
)
{
return
unsupported
(
)
;
}
if
(
vectorizeRight
)
{
fBuilder
.
push_duplicates
(
left
.
type
(
)
.
slotCount
(
)
-
1
)
;
}
switch
(
op
.
kind
(
)
)
{
case
OperatorKind
:
:
PLUS
:
if
(
!
this
-
>
binaryOp
(
type
kAddOps
)
)
{
return
unsupported
(
)
;
}
break
;
case
OperatorKind
:
:
MINUS
:
if
(
!
this
-
>
binaryOp
(
type
kSubtractOps
)
)
{
return
unsupported
(
)
;
}
break
;
case
OperatorKind
:
:
STAR
:
if
(
!
this
-
>
binaryOp
(
type
kMultiplyOps
)
)
{
return
unsupported
(
)
;
}
break
;
case
OperatorKind
:
:
SLASH
:
if
(
!
this
-
>
binaryOp
(
type
kDivideOps
)
)
{
return
unsupported
(
)
;
}
break
;
case
OperatorKind
:
:
LT
:
case
OperatorKind
:
:
GT
:
if
(
!
this
-
>
binaryOp
(
type
kLessThanOps
)
)
{
return
unsupported
(
)
;
}
SkASSERT
(
type
.
slotCount
(
)
=
=
1
)
;
break
;
case
OperatorKind
:
:
LTEQ
:
case
OperatorKind
:
:
GTEQ
:
if
(
!
this
-
>
binaryOp
(
type
kLessThanEqualOps
)
)
{
return
unsupported
(
)
;
}
SkASSERT
(
type
.
slotCount
(
)
=
=
1
)
;
break
;
case
OperatorKind
:
:
EQEQ
:
if
(
!
this
-
>
binaryOp
(
type
kEqualOps
)
)
{
return
unsupported
(
)
;
}
this
-
>
foldComparisonOp
(
op
type
.
slotCount
(
)
)
;
break
;
case
OperatorKind
:
:
NEQ
:
if
(
!
this
-
>
binaryOp
(
type
kNotEqualOps
)
)
{
return
unsupported
(
)
;
}
this
-
>
foldComparisonOp
(
op
type
.
slotCount
(
)
)
;
break
;
case
OperatorKind
:
:
LOGICALAND
:
case
OperatorKind
:
:
BITWISEAND
:
fBuilder
.
binary_op
(
BuilderOp
:
:
bitwise_and_n_ints
type
.
slotCount
(
)
)
;
break
;
case
OperatorKind
:
:
LOGICALOR
:
case
OperatorKind
:
:
BITWISEOR
:
fBuilder
.
binary_op
(
BuilderOp
:
:
bitwise_or_n_ints
type
.
slotCount
(
)
)
;
break
;
case
OperatorKind
:
:
LOGICALXOR
:
case
OperatorKind
:
:
BITWISEXOR
:
fBuilder
.
binary_op
(
BuilderOp
:
:
bitwise_xor_n_ints
type
.
slotCount
(
)
)
;
break
;
default
:
return
unsupported
(
)
;
}
return
lvalue
?
this
-
>
store
(
*
lvalue
)
:
true
;
}
bool
Generator
:
:
pushConstructorCompound
(
const
AnyConstructor
&
c
)
{
for
(
const
std
:
:
unique_ptr
<
Expression
>
&
arg
:
c
.
argumentSpan
(
)
)
{
if
(
!
this
-
>
pushExpression
(
*
arg
)
)
{
return
unsupported
(
)
;
}
}
return
true
;
}
bool
Generator
:
:
pushChildCall
(
const
ChildCall
&
c
)
{
int
*
childIdx
=
fChildEffectMap
.
find
(
&
c
.
child
(
)
)
;
SkASSERT
(
childIdx
!
=
nullptr
)
;
SkASSERT
(
!
c
.
arguments
(
)
.
empty
(
)
)
;
fBuilder
.
push_dst_rgba
(
)
;
const
Expression
*
arg
=
c
.
arguments
(
)
[
0
]
.
get
(
)
;
if
(
!
this
-
>
pushExpression
(
*
arg
)
)
{
return
unsupported
(
)
;
}
switch
(
c
.
child
(
)
.
type
(
)
.
typeKind
(
)
)
{
case
Type
:
:
TypeKind
:
:
kShader
:
{
SkASSERT
(
c
.
arguments
(
)
.
size
(
)
=
=
1
)
;
SkASSERT
(
arg
-
>
type
(
)
.
matches
(
*
fContext
.
fTypes
.
fFloat2
)
)
;
fBuilder
.
pop_src_rg
(
)
;
fBuilder
.
invoke_shader
(
*
childIdx
)
;
break
;
}
case
Type
:
:
TypeKind
:
:
kColorFilter
:
{
SkASSERT
(
c
.
arguments
(
)
.
size
(
)
=
=
1
)
;
SkASSERT
(
arg
-
>
type
(
)
.
matches
(
*
fContext
.
fTypes
.
fHalf4
)
|
|
arg
-
>
type
(
)
.
matches
(
*
fContext
.
fTypes
.
fFloat4
)
)
;
fBuilder
.
pop_src_rgba
(
)
;
fBuilder
.
invoke_color_filter
(
*
childIdx
)
;
break
;
}
case
Type
:
:
TypeKind
:
:
kBlender
:
{
SkASSERT
(
c
.
arguments
(
)
.
size
(
)
=
=
2
)
;
SkASSERT
(
arg
-
>
type
(
)
.
matches
(
*
fContext
.
fTypes
.
fHalf4
)
|
|
arg
-
>
type
(
)
.
matches
(
*
fContext
.
fTypes
.
fFloat4
)
)
;
arg
=
c
.
arguments
(
)
[
1
]
.
get
(
)
;
SkASSERT
(
arg
-
>
type
(
)
.
matches
(
*
fContext
.
fTypes
.
fHalf4
)
|
|
arg
-
>
type
(
)
.
matches
(
*
fContext
.
fTypes
.
fFloat4
)
)
;
if
(
!
this
-
>
pushExpression
(
*
arg
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
pop_dst_rgba
(
)
;
fBuilder
.
pop_src_rgba
(
)
;
fBuilder
.
invoke_blender
(
*
childIdx
)
;
break
;
}
default
:
{
SkDEBUGFAILF
(
"
cannot
sample
from
type
'
%
s
'
"
c
.
child
(
)
.
type
(
)
.
description
(
)
.
c_str
(
)
)
;
}
}
fBuilder
.
pop_dst_rgba
(
)
;
fBuilder
.
push_src_rgba
(
)
;
return
true
;
}
bool
Generator
:
:
pushConstructorCast
(
const
AnyConstructor
&
c
)
{
SkASSERT
(
c
.
argumentSpan
(
)
.
size
(
)
=
=
1
)
;
const
Expression
&
inner
=
*
c
.
argumentSpan
(
)
.
front
(
)
;
SkASSERT
(
inner
.
type
(
)
.
slotCount
(
)
=
=
c
.
type
(
)
.
slotCount
(
)
)
;
if
(
!
this
-
>
pushExpression
(
inner
)
)
{
return
unsupported
(
)
;
}
if
(
inner
.
type
(
)
.
componentType
(
)
.
numberKind
(
)
=
=
c
.
type
(
)
.
componentType
(
)
.
numberKind
(
)
)
{
return
true
;
}
if
(
inner
.
type
(
)
.
componentType
(
)
.
isSigned
(
)
&
&
c
.
type
(
)
.
componentType
(
)
.
isUnsigned
(
)
)
{
return
true
;
}
if
(
inner
.
type
(
)
.
componentType
(
)
.
isUnsigned
(
)
&
&
c
.
type
(
)
.
componentType
(
)
.
isSigned
(
)
)
{
return
true
;
}
if
(
c
.
type
(
)
.
componentType
(
)
.
isBoolean
(
)
)
{
fBuilder
.
push_zeros
(
c
.
type
(
)
.
slotCount
(
)
)
;
return
this
-
>
binaryOp
(
inner
.
type
(
)
kNotEqualOps
)
;
}
if
(
inner
.
type
(
)
.
componentType
(
)
.
isBoolean
(
)
)
{
if
(
c
.
type
(
)
.
componentType
(
)
.
isFloat
(
)
)
{
fBuilder
.
push_literal_f
(
1
.
0f
)
;
}
else
if
(
c
.
type
(
)
.
componentType
(
)
.
isSigned
(
)
|
|
c
.
type
(
)
.
componentType
(
)
.
isUnsigned
(
)
)
{
fBuilder
.
push_literal_i
(
1
)
;
}
else
{
SkDEBUGFAILF
(
"
unexpected
cast
from
bool
to
%
s
"
c
.
type
(
)
.
description
(
)
.
c_str
(
)
)
;
return
unsupported
(
)
;
}
fBuilder
.
push_duplicates
(
c
.
type
(
)
.
slotCount
(
)
-
1
)
;
fBuilder
.
binary_op
(
BuilderOp
:
:
bitwise_and_n_ints
c
.
type
(
)
.
slotCount
(
)
)
;
return
true
;
}
if
(
inner
.
type
(
)
.
componentType
(
)
.
isFloat
(
)
)
{
if
(
c
.
type
(
)
.
componentType
(
)
.
isSigned
(
)
)
{
fBuilder
.
unary_op
(
BuilderOp
:
:
cast_to_int_from_float
c
.
type
(
)
.
slotCount
(
)
)
;
return
true
;
}
if
(
c
.
type
(
)
.
componentType
(
)
.
isUnsigned
(
)
)
{
fBuilder
.
unary_op
(
BuilderOp
:
:
cast_to_uint_from_float
c
.
type
(
)
.
slotCount
(
)
)
;
return
true
;
}
}
else
if
(
c
.
type
(
)
.
componentType
(
)
.
isFloat
(
)
)
{
if
(
inner
.
type
(
)
.
componentType
(
)
.
isSigned
(
)
)
{
fBuilder
.
unary_op
(
BuilderOp
:
:
cast_to_float_from_int
c
.
type
(
)
.
slotCount
(
)
)
;
return
true
;
}
if
(
inner
.
type
(
)
.
componentType
(
)
.
isUnsigned
(
)
)
{
fBuilder
.
unary_op
(
BuilderOp
:
:
cast_to_float_from_uint
c
.
type
(
)
.
slotCount
(
)
)
;
return
true
;
}
}
SkDEBUGFAILF
(
"
unexpected
cast
from
%
s
to
%
s
"
c
.
type
(
)
.
description
(
)
.
c_str
(
)
inner
.
type
(
)
.
description
(
)
.
c_str
(
)
)
;
return
unsupported
(
)
;
}
bool
Generator
:
:
pushConstructorDiagonalMatrix
(
const
ConstructorDiagonalMatrix
&
c
)
{
fBuilder
.
push_zeros
(
1
)
;
if
(
!
this
-
>
pushExpression
(
*
c
.
argument
(
)
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
diagonal_matrix
(
c
.
type
(
)
.
columns
(
)
c
.
type
(
)
.
rows
(
)
)
;
return
true
;
}
bool
Generator
:
:
pushConstructorMatrixResize
(
const
ConstructorMatrixResize
&
c
)
{
if
(
!
this
-
>
pushExpression
(
*
c
.
argument
(
)
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
matrix_resize
(
c
.
argument
(
)
-
>
type
(
)
.
columns
(
)
c
.
argument
(
)
-
>
type
(
)
.
rows
(
)
c
.
type
(
)
.
columns
(
)
c
.
type
(
)
.
rows
(
)
)
;
return
true
;
}
bool
Generator
:
:
pushConstructorSplat
(
const
ConstructorSplat
&
c
)
{
if
(
!
this
-
>
pushExpression
(
*
c
.
argument
(
)
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
push_duplicates
(
c
.
type
(
)
.
slotCount
(
)
-
1
)
;
return
true
;
}
bool
Generator
:
:
pushFieldAccess
(
const
FieldAccess
&
f
)
{
std
:
:
unique_ptr
<
LValue
>
lvalue
=
this
-
>
makeLValue
(
f
true
)
;
return
lvalue
&
&
this
-
>
push
(
*
lvalue
)
;
}
bool
Generator
:
:
pushFunctionCall
(
const
FunctionCall
&
c
)
{
if
(
c
.
function
(
)
.
isIntrinsic
(
)
)
{
return
this
-
>
pushIntrinsic
(
c
)
;
}
const
FunctionDefinition
*
lastFunction
=
fCurrentFunction
;
fCurrentFunction
=
c
.
function
(
)
.
definition
(
)
;
int
skipLabelID
=
fBuilder
.
nextLabelID
(
)
;
fBuilder
.
branch_if_no_lanes_active
(
skipLabelID
)
;
if
(
this
-
>
needsReturnMask
(
)
)
{
fBuilder
.
enableExecutionMaskWrites
(
)
;
fBuilder
.
push_return_mask
(
)
;
}
SkTArray
<
std
:
:
unique_ptr
<
LValue
>
>
lvalues
;
lvalues
.
resize
(
c
.
arguments
(
)
.
size
(
)
)
;
for
(
int
index
=
0
;
index
<
c
.
arguments
(
)
.
size
(
)
;
+
+
index
)
{
const
Expression
&
arg
=
*
c
.
arguments
(
)
[
index
]
;
const
Variable
&
param
=
*
c
.
function
(
)
.
parameters
(
)
[
index
]
;
if
(
IsInoutParameter
(
param
)
|
|
IsOutParameter
(
param
)
)
{
lvalues
[
index
]
=
this
-
>
makeLValue
(
arg
)
;
if
(
!
lvalues
[
index
]
)
{
return
unsupported
(
)
;
}
if
(
IsInoutParameter
(
param
)
)
{
if
(
!
this
-
>
push
(
*
lvalues
[
index
]
)
)
{
return
unsupported
(
)
;
}
this
-
>
popToSlotRangeUnmasked
(
this
-
>
getVariableSlots
(
param
)
)
;
}
}
else
{
if
(
!
this
-
>
pushExpression
(
arg
)
)
{
return
unsupported
(
)
;
}
this
-
>
popToSlotRangeUnmasked
(
this
-
>
getVariableSlots
(
param
)
)
;
}
}
std
:
:
optional
<
SlotRange
>
r
=
this
-
>
writeFunction
(
c
*
fCurrentFunction
)
;
if
(
!
r
.
has_value
(
)
)
{
return
unsupported
(
)
;
}
if
(
this
-
>
needsReturnMask
(
)
)
{
fBuilder
.
pop_return_mask
(
)
;
fBuilder
.
disableExecutionMaskWrites
(
)
;
}
if
(
this
-
>
needsFunctionResultSlots
(
)
)
{
fBuilder
.
push_slots
(
*
r
)
;
}
fCurrentFunction
=
lastFunction
;
for
(
int
index
=
0
;
index
<
c
.
arguments
(
)
.
size
(
)
;
+
+
index
)
{
if
(
lvalues
[
index
]
)
{
const
Variable
&
param
=
*
c
.
function
(
)
.
parameters
(
)
[
index
]
;
SkASSERT
(
IsInoutParameter
(
param
)
|
|
IsOutParameter
(
param
)
)
;
fBuilder
.
push_slots
(
this
-
>
getVariableSlots
(
param
)
)
;
if
(
!
this
-
>
store
(
*
lvalues
[
index
]
)
)
{
return
unsupported
(
)
;
}
this
-
>
discardExpression
(
param
.
type
(
)
.
slotCount
(
)
)
;
}
}
fBuilder
.
label
(
skipLabelID
)
;
return
true
;
}
bool
Generator
:
:
pushIndexExpression
(
const
IndexExpression
&
i
)
{
std
:
:
unique_ptr
<
LValue
>
lvalue
=
this
-
>
makeLValue
(
i
true
)
;
return
lvalue
&
&
this
-
>
push
(
*
lvalue
)
;
}
bool
Generator
:
:
pushIntrinsic
(
const
FunctionCall
&
c
)
{
const
ExpressionArray
&
args
=
c
.
arguments
(
)
;
switch
(
args
.
size
(
)
)
{
case
1
:
return
this
-
>
pushIntrinsic
(
c
.
function
(
)
.
intrinsicKind
(
)
*
args
[
0
]
)
;
case
2
:
return
this
-
>
pushIntrinsic
(
c
.
function
(
)
.
intrinsicKind
(
)
*
args
[
0
]
*
args
[
1
]
)
;
case
3
:
return
this
-
>
pushIntrinsic
(
c
.
function
(
)
.
intrinsicKind
(
)
*
args
[
0
]
*
args
[
1
]
*
args
[
2
]
)
;
default
:
break
;
}
return
unsupported
(
)
;
}
bool
Generator
:
:
pushLengthIntrinsic
(
int
slotCount
)
{
if
(
slotCount
>
1
)
{
fBuilder
.
push_clone
(
slotCount
)
;
fBuilder
.
dot_floats
(
slotCount
)
;
fBuilder
.
unary_op
(
BuilderOp
:
:
sqrt_float
1
)
;
}
else
{
fBuilder
.
unary_op
(
BuilderOp
:
:
abs_float
1
)
;
}
return
true
;
}
bool
Generator
:
:
pushVectorizedExpression
(
const
Expression
&
expr
const
Type
&
vectorType
)
{
if
(
!
this
-
>
pushExpression
(
expr
)
)
{
return
unsupported
(
)
;
}
if
(
vectorType
.
slotCount
(
)
>
expr
.
type
(
)
.
slotCount
(
)
)
{
SkASSERT
(
expr
.
type
(
)
.
slotCount
(
)
=
=
1
)
;
fBuilder
.
push_duplicates
(
vectorType
.
slotCount
(
)
-
expr
.
type
(
)
.
slotCount
(
)
)
;
}
return
true
;
}
bool
Generator
:
:
pushIntrinsic
(
const
TypedOps
&
ops
const
Expression
&
arg0
)
{
if
(
!
this
-
>
pushExpression
(
arg0
)
)
{
return
unsupported
(
)
;
}
return
this
-
>
unaryOp
(
arg0
.
type
(
)
ops
)
;
}
bool
Generator
:
:
pushIntrinsic
(
BuilderOp
builderOp
const
Expression
&
arg0
)
{
if
(
!
this
-
>
pushExpression
(
arg0
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
unary_op
(
builderOp
arg0
.
type
(
)
.
slotCount
(
)
)
;
return
true
;
}
bool
Generator
:
:
pushIntrinsic
(
IntrinsicKind
intrinsic
const
Expression
&
arg0
)
{
switch
(
intrinsic
)
{
case
IntrinsicKind
:
:
k_abs_IntrinsicKind
:
return
this
-
>
pushIntrinsic
(
kAbsOps
arg0
)
;
case
IntrinsicKind
:
:
k_any_IntrinsicKind
:
if
(
!
this
-
>
pushExpression
(
arg0
)
)
{
return
unsupported
(
)
;
}
this
-
>
foldWithMultiOp
(
BuilderOp
:
:
bitwise_or_n_ints
arg0
.
type
(
)
.
slotCount
(
)
)
;
return
true
;
case
IntrinsicKind
:
:
k_all_IntrinsicKind
:
if
(
!
this
-
>
pushExpression
(
arg0
)
)
{
return
unsupported
(
)
;
}
this
-
>
foldWithMultiOp
(
BuilderOp
:
:
bitwise_and_n_ints
arg0
.
type
(
)
.
slotCount
(
)
)
;
return
true
;
case
IntrinsicKind
:
:
k_acos_IntrinsicKind
:
return
this
-
>
pushIntrinsic
(
BuilderOp
:
:
acos_float
arg0
)
;
case
IntrinsicKind
:
:
k_asin_IntrinsicKind
:
return
this
-
>
pushIntrinsic
(
BuilderOp
:
:
asin_float
arg0
)
;
case
IntrinsicKind
:
:
k_atan_IntrinsicKind
:
return
this
-
>
pushIntrinsic
(
BuilderOp
:
:
atan_float
arg0
)
;
case
IntrinsicKind
:
:
k_ceil_IntrinsicKind
:
return
this
-
>
pushIntrinsic
(
BuilderOp
:
:
ceil_float
arg0
)
;
case
IntrinsicKind
:
:
k_cos_IntrinsicKind
:
return
this
-
>
pushIntrinsic
(
BuilderOp
:
:
cos_float
arg0
)
;
case
IntrinsicKind
:
:
k_degrees_IntrinsicKind
:
{
Literal
lit180OverPi
{
Position
{
}
57
.
2957795131f
&
arg0
.
type
(
)
.
componentType
(
)
}
;
return
this
-
>
pushBinaryExpression
(
arg0
OperatorKind
:
:
STAR
lit180OverPi
)
;
}
case
IntrinsicKind
:
:
k_floatBitsToInt_IntrinsicKind
:
case
IntrinsicKind
:
:
k_floatBitsToUint_IntrinsicKind
:
case
IntrinsicKind
:
:
k_intBitsToFloat_IntrinsicKind
:
case
IntrinsicKind
:
:
k_uintBitsToFloat_IntrinsicKind
:
return
this
-
>
pushExpression
(
arg0
)
;
case
IntrinsicKind
:
:
k_exp_IntrinsicKind
:
return
this
-
>
pushIntrinsic
(
BuilderOp
:
:
exp_float
arg0
)
;
case
IntrinsicKind
:
:
k_exp2_IntrinsicKind
:
return
this
-
>
pushIntrinsic
(
BuilderOp
:
:
exp2_float
arg0
)
;
case
IntrinsicKind
:
:
k_floor_IntrinsicKind
:
return
this
-
>
pushIntrinsic
(
BuilderOp
:
:
floor_float
arg0
)
;
case
IntrinsicKind
:
:
k_fract_IntrinsicKind
:
if
(
!
this
-
>
pushExpression
(
arg0
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
push_clone
(
arg0
.
type
(
)
.
slotCount
(
)
)
;
fBuilder
.
unary_op
(
BuilderOp
:
:
floor_float
arg0
.
type
(
)
.
slotCount
(
)
)
;
return
this
-
>
binaryOp
(
arg0
.
type
(
)
kSubtractOps
)
;
case
IntrinsicKind
:
:
k_inverse_IntrinsicKind
:
SkASSERT
(
arg0
.
type
(
)
.
isMatrix
(
)
)
;
SkASSERT
(
arg0
.
type
(
)
.
rows
(
)
=
=
arg0
.
type
(
)
.
columns
(
)
)
;
if
(
!
this
-
>
pushExpression
(
arg0
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
inverse_matrix
(
arg0
.
type
(
)
.
rows
(
)
)
;
return
true
;
case
IntrinsicKind
:
:
k_inversesqrt_IntrinsicKind
:
return
this
-
>
pushIntrinsic
(
kInverseSqrtOps
arg0
)
;
case
IntrinsicKind
:
:
k_length_IntrinsicKind
:
return
this
-
>
pushExpression
(
arg0
)
&
&
this
-
>
pushLengthIntrinsic
(
arg0
.
type
(
)
.
slotCount
(
)
)
;
case
IntrinsicKind
:
:
k_log_IntrinsicKind
:
if
(
!
this
-
>
pushExpression
(
arg0
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
unary_op
(
BuilderOp
:
:
log_float
arg0
.
type
(
)
.
slotCount
(
)
)
;
return
true
;
case
IntrinsicKind
:
:
k_log2_IntrinsicKind
:
if
(
!
this
-
>
pushExpression
(
arg0
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
unary_op
(
BuilderOp
:
:
log2_float
arg0
.
type
(
)
.
slotCount
(
)
)
;
return
true
;
case
IntrinsicKind
:
:
k_normalize_IntrinsicKind
:
{
if
(
!
this
-
>
pushExpression
(
arg0
)
)
{
return
unsupported
(
)
;
}
int
slotCount
=
arg0
.
type
(
)
.
slotCount
(
)
;
if
(
slotCount
>
1
)
{
fBuilder
.
push_clone
(
slotCount
)
;
fBuilder
.
push_clone
(
slotCount
)
;
fBuilder
.
dot_floats
(
slotCount
)
;
fBuilder
.
unary_op
(
BuilderOp
:
:
invsqrt_float
1
)
;
fBuilder
.
push_duplicates
(
slotCount
-
1
)
;
return
this
-
>
binaryOp
(
arg0
.
type
(
)
kMultiplyOps
)
;
}
else
{
fBuilder
.
push_clone
(
slotCount
)
;
fBuilder
.
unary_op
(
BuilderOp
:
:
abs_float
1
)
;
return
this
-
>
binaryOp
(
arg0
.
type
(
)
kDivideOps
)
;
}
}
case
IntrinsicKind
:
:
k_not_IntrinsicKind
:
return
this
-
>
pushPrefixExpression
(
OperatorKind
:
:
LOGICALNOT
arg0
)
;
case
IntrinsicKind
:
:
k_radians_IntrinsicKind
:
{
Literal
litPiOver180
{
Position
{
}
0
.
01745329251f
&
arg0
.
type
(
)
.
componentType
(
)
}
;
return
this
-
>
pushBinaryExpression
(
arg0
OperatorKind
:
:
STAR
litPiOver180
)
;
}
case
IntrinsicKind
:
:
k_saturate_IntrinsicKind
:
{
Literal
zeroLiteral
{
Position
{
}
0
.
0
&
arg0
.
type
(
)
.
componentType
(
)
}
;
Literal
oneLiteral
{
Position
{
}
1
.
0
&
arg0
.
type
(
)
.
componentType
(
)
}
;
return
this
-
>
pushIntrinsic
(
k_clamp_IntrinsicKind
arg0
zeroLiteral
oneLiteral
)
;
}
case
IntrinsicKind
:
:
k_sign_IntrinsicKind
:
{
if
(
!
this
-
>
pushExpression
(
arg0
)
)
{
return
unsupported
(
)
;
}
if
(
arg0
.
type
(
)
.
componentType
(
)
.
isFloat
(
)
)
{
Literal
fltMaxLiteral
{
Position
{
}
FLT_MAX
&
arg0
.
type
(
)
.
componentType
(
)
}
;
if
(
!
this
-
>
pushVectorizedExpression
(
fltMaxLiteral
arg0
.
type
(
)
)
)
{
return
unsupported
(
)
;
}
if
(
!
this
-
>
binaryOp
(
arg0
.
type
(
)
kMultiplyOps
)
)
{
return
unsupported
(
)
;
}
}
Literal
neg1Literal
{
Position
{
}
-
1
.
0
&
arg0
.
type
(
)
.
componentType
(
)
}
;
if
(
!
this
-
>
pushVectorizedExpression
(
neg1Literal
arg0
.
type
(
)
)
)
{
return
unsupported
(
)
;
}
if
(
!
this
-
>
binaryOp
(
arg0
.
type
(
)
kMaxOps
)
)
{
return
unsupported
(
)
;
}
Literal
pos1Literal
{
Position
{
}
1
.
0
&
arg0
.
type
(
)
.
componentType
(
)
}
;
if
(
!
this
-
>
pushVectorizedExpression
(
pos1Literal
arg0
.
type
(
)
)
)
{
return
unsupported
(
)
;
}
return
this
-
>
binaryOp
(
arg0
.
type
(
)
kMinOps
)
;
}
case
IntrinsicKind
:
:
k_sin_IntrinsicKind
:
return
this
-
>
pushIntrinsic
(
BuilderOp
:
:
sin_float
arg0
)
;
case
IntrinsicKind
:
:
k_sqrt_IntrinsicKind
:
return
this
-
>
pushIntrinsic
(
BuilderOp
:
:
sqrt_float
arg0
)
;
case
IntrinsicKind
:
:
k_tan_IntrinsicKind
:
return
this
-
>
pushIntrinsic
(
BuilderOp
:
:
tan_float
arg0
)
;
case
IntrinsicKind
:
:
k_transpose_IntrinsicKind
:
SkASSERT
(
arg0
.
type
(
)
.
isMatrix
(
)
)
;
if
(
!
this
-
>
pushExpression
(
arg0
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
transpose
(
arg0
.
type
(
)
.
columns
(
)
arg0
.
type
(
)
.
rows
(
)
)
;
return
true
;
case
IntrinsicKind
:
:
k_trunc_IntrinsicKind
:
if
(
!
this
-
>
pushExpression
(
arg0
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
unary_op
(
BuilderOp
:
:
cast_to_int_from_float
arg0
.
type
(
)
.
slotCount
(
)
)
;
fBuilder
.
unary_op
(
BuilderOp
:
:
cast_to_float_from_int
arg0
.
type
(
)
.
slotCount
(
)
)
;
return
true
;
case
IntrinsicKind
:
:
k_fromLinearSrgb_IntrinsicKind
:
case
IntrinsicKind
:
:
k_toLinearSrgb_IntrinsicKind
:
{
SkASSERT
(
arg0
.
type
(
)
.
matches
(
*
fContext
.
fTypes
.
fHalf3
)
)
;
if
(
!
this
-
>
pushExpression
(
arg0
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
push_literal_f
(
1
.
0f
)
;
fBuilder
.
pop_src_rgba
(
)
;
if
(
intrinsic
=
=
IntrinsicKind
:
:
k_fromLinearSrgb_IntrinsicKind
)
{
fBuilder
.
invoke_from_linear_srgb
(
)
;
}
else
{
fBuilder
.
invoke_to_linear_srgb
(
)
;
}
fBuilder
.
push_src_rgba
(
)
;
this
-
>
discardExpression
(
1
)
;
return
true
;
}
default
:
break
;
}
return
unsupported
(
)
;
}
bool
Generator
:
:
pushIntrinsic
(
const
TypedOps
&
ops
const
Expression
&
arg0
const
Expression
&
arg1
)
{
if
(
!
this
-
>
pushExpression
(
arg0
)
|
|
!
this
-
>
pushVectorizedExpression
(
arg1
arg0
.
type
(
)
)
)
{
return
unsupported
(
)
;
}
return
this
-
>
binaryOp
(
arg0
.
type
(
)
ops
)
;
}
bool
Generator
:
:
pushIntrinsic
(
BuilderOp
builderOp
const
Expression
&
arg0
const
Expression
&
arg1
)
{
if
(
!
this
-
>
pushExpression
(
arg0
)
|
|
!
this
-
>
pushVectorizedExpression
(
arg1
arg0
.
type
(
)
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
binary_op
(
builderOp
arg0
.
type
(
)
.
slotCount
(
)
)
;
return
true
;
}
bool
Generator
:
:
pushIntrinsic
(
IntrinsicKind
intrinsic
const
Expression
&
arg0
const
Expression
&
arg1
)
{
switch
(
intrinsic
)
{
case
IntrinsicKind
:
:
k_atan_IntrinsicKind
:
return
this
-
>
pushIntrinsic
(
BuilderOp
:
:
atan2_n_floats
arg0
arg1
)
;
case
IntrinsicKind
:
:
k_cross_IntrinsicKind
:
{
SkASSERT
(
arg0
.
type
(
)
.
matches
(
arg1
.
type
(
)
)
)
;
SkASSERT
(
arg0
.
type
(
)
.
slotCount
(
)
=
=
3
)
;
SkASSERT
(
arg1
.
type
(
)
.
slotCount
(
)
=
=
3
)
;
AutoStack
subexpressionStack
(
this
)
;
subexpressionStack
.
enter
(
)
;
if
(
!
this
-
>
pushExpression
(
arg0
)
)
{
return
unsupported
(
)
;
}
subexpressionStack
.
exit
(
)
;
subexpressionStack
.
pushClone
(
3
)
;
fBuilder
.
swizzle
(
3
{
1
2
0
}
)
;
subexpressionStack
.
enter
(
)
;
fBuilder
.
swizzle
(
3
{
2
0
1
}
)
;
subexpressionStack
.
exit
(
)
;
subexpressionStack
.
enter
(
)
;
if
(
!
this
-
>
pushExpression
(
arg1
)
)
{
return
unsupported
(
)
;
}
subexpressionStack
.
exit
(
)
;
subexpressionStack
.
pushClone
(
3
)
;
fBuilder
.
swizzle
(
3
{
2
0
1
}
)
;
fBuilder
.
binary_op
(
BuilderOp
:
:
mul_n_floats
3
)
;
subexpressionStack
.
enter
(
)
;
fBuilder
.
swizzle
(
3
{
1
2
0
}
)
;
fBuilder
.
binary_op
(
BuilderOp
:
:
mul_n_floats
3
)
;
subexpressionStack
.
exit
(
)
;
subexpressionStack
.
pushClone
(
3
)
;
fBuilder
.
binary_op
(
BuilderOp
:
:
sub_n_floats
3
)
;
subexpressionStack
.
enter
(
)
;
this
-
>
discardExpression
(
3
)
;
subexpressionStack
.
exit
(
)
;
return
true
;
}
case
IntrinsicKind
:
:
k_distance_IntrinsicKind
:
SkASSERT
(
arg0
.
type
(
)
.
slotCount
(
)
=
=
arg1
.
type
(
)
.
slotCount
(
)
)
;
return
this
-
>
pushBinaryExpression
(
arg0
OperatorKind
:
:
MINUS
arg1
)
&
&
this
-
>
pushLengthIntrinsic
(
arg0
.
type
(
)
.
slotCount
(
)
)
;
case
IntrinsicKind
:
:
k_dot_IntrinsicKind
:
SkASSERT
(
arg0
.
type
(
)
.
matches
(
arg1
.
type
(
)
)
)
;
if
(
!
this
-
>
pushExpression
(
arg0
)
|
|
!
this
-
>
pushExpression
(
arg1
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
dot_floats
(
arg0
.
type
(
)
.
slotCount
(
)
)
;
return
true
;
case
IntrinsicKind
:
:
k_equal_IntrinsicKind
:
SkASSERT
(
arg0
.
type
(
)
.
matches
(
arg1
.
type
(
)
)
)
;
return
this
-
>
pushIntrinsic
(
kEqualOps
arg0
arg1
)
;
case
IntrinsicKind
:
:
k_notEqual_IntrinsicKind
:
SkASSERT
(
arg0
.
type
(
)
.
matches
(
arg1
.
type
(
)
)
)
;
return
this
-
>
pushIntrinsic
(
kNotEqualOps
arg0
arg1
)
;
case
IntrinsicKind
:
:
k_lessThan_IntrinsicKind
:
SkASSERT
(
arg0
.
type
(
)
.
matches
(
arg1
.
type
(
)
)
)
;
return
this
-
>
pushIntrinsic
(
kLessThanOps
arg0
arg1
)
;
case
IntrinsicKind
:
:
k_greaterThan_IntrinsicKind
:
SkASSERT
(
arg0
.
type
(
)
.
matches
(
arg1
.
type
(
)
)
)
;
return
this
-
>
pushIntrinsic
(
kLessThanOps
arg1
arg0
)
;
case
IntrinsicKind
:
:
k_lessThanEqual_IntrinsicKind
:
SkASSERT
(
arg0
.
type
(
)
.
matches
(
arg1
.
type
(
)
)
)
;
return
this
-
>
pushIntrinsic
(
kLessThanEqualOps
arg0
arg1
)
;
case
IntrinsicKind
:
:
k_greaterThanEqual_IntrinsicKind
:
SkASSERT
(
arg0
.
type
(
)
.
matches
(
arg1
.
type
(
)
)
)
;
return
this
-
>
pushIntrinsic
(
kLessThanEqualOps
arg1
arg0
)
;
case
IntrinsicKind
:
:
k_min_IntrinsicKind
:
SkASSERT
(
arg0
.
type
(
)
.
componentType
(
)
.
matches
(
arg1
.
type
(
)
.
componentType
(
)
)
)
;
return
this
-
>
pushIntrinsic
(
kMinOps
arg0
arg1
)
;
case
IntrinsicKind
:
:
k_matrixCompMult_IntrinsicKind
:
SkASSERT
(
arg0
.
type
(
)
.
matches
(
arg1
.
type
(
)
)
)
;
return
this
-
>
pushIntrinsic
(
kMultiplyOps
arg0
arg1
)
;
case
IntrinsicKind
:
:
k_max_IntrinsicKind
:
SkASSERT
(
arg0
.
type
(
)
.
componentType
(
)
.
matches
(
arg1
.
type
(
)
.
componentType
(
)
)
)
;
return
this
-
>
pushIntrinsic
(
kMaxOps
arg0
arg1
)
;
case
IntrinsicKind
:
:
k_mod_IntrinsicKind
:
SkASSERT
(
arg0
.
type
(
)
.
componentType
(
)
.
matches
(
arg1
.
type
(
)
.
componentType
(
)
)
)
;
return
this
-
>
pushIntrinsic
(
kModOps
arg0
arg1
)
;
case
IntrinsicKind
:
:
k_pow_IntrinsicKind
:
SkASSERT
(
arg0
.
type
(
)
.
matches
(
arg1
.
type
(
)
)
)
;
return
this
-
>
pushIntrinsic
(
BuilderOp
:
:
pow_n_floats
arg0
arg1
)
;
case
IntrinsicKind
:
:
k_reflect_IntrinsicKind
:
{
SkASSERT
(
arg0
.
type
(
)
.
matches
(
arg1
.
type
(
)
)
)
;
SkASSERT
(
arg0
.
type
(
)
.
slotCount
(
)
=
=
arg1
.
type
(
)
.
slotCount
(
)
)
;
SkASSERT
(
arg0
.
type
(
)
.
componentType
(
)
.
isFloat
(
)
)
;
int
slotCount
=
arg0
.
type
(
)
.
slotCount
(
)
;
if
(
!
this
-
>
pushExpression
(
arg0
)
|
|
!
this
-
>
pushExpression
(
arg1
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
push_clone
(
2
*
slotCount
)
;
fBuilder
.
dot_floats
(
slotCount
)
;
fBuilder
.
push_literal_f
(
2
.
0
)
;
fBuilder
.
binary_op
(
BuilderOp
:
:
mul_n_floats
1
)
;
fBuilder
.
push_duplicates
(
slotCount
-
1
)
;
fBuilder
.
binary_op
(
BuilderOp
:
:
mul_n_floats
slotCount
)
;
fBuilder
.
binary_op
(
BuilderOp
:
:
sub_n_floats
slotCount
)
;
return
true
;
}
case
IntrinsicKind
:
:
k_step_IntrinsicKind
:
{
SkASSERT
(
arg0
.
type
(
)
.
componentType
(
)
.
matches
(
arg1
.
type
(
)
.
componentType
(
)
)
)
;
if
(
!
this
-
>
pushVectorizedExpression
(
arg0
arg1
.
type
(
)
)
|
|
!
this
-
>
pushExpression
(
arg1
)
)
{
return
unsupported
(
)
;
}
if
(
!
this
-
>
binaryOp
(
arg1
.
type
(
)
kLessThanOps
)
)
{
return
unsupported
(
)
;
}
Literal
pos1Literal
{
Position
{
}
1
.
0
&
arg1
.
type
(
)
.
componentType
(
)
}
;
if
(
!
this
-
>
pushVectorizedExpression
(
pos1Literal
arg1
.
type
(
)
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
binary_op
(
BuilderOp
:
:
bitwise_and_n_ints
arg1
.
type
(
)
.
slotCount
(
)
)
;
return
true
;
}
default
:
break
;
}
return
unsupported
(
)
;
}
bool
Generator
:
:
pushIntrinsic
(
IntrinsicKind
intrinsic
const
Expression
&
arg0
const
Expression
&
arg1
const
Expression
&
arg2
)
{
switch
(
intrinsic
)
{
case
IntrinsicKind
:
:
k_clamp_IntrinsicKind
:
SkASSERT
(
arg0
.
type
(
)
.
componentType
(
)
.
matches
(
arg1
.
type
(
)
.
componentType
(
)
)
)
;
SkASSERT
(
arg0
.
type
(
)
.
componentType
(
)
.
matches
(
arg2
.
type
(
)
.
componentType
(
)
)
)
;
if
(
!
this
-
>
pushExpression
(
arg0
)
|
|
!
this
-
>
pushVectorizedExpression
(
arg1
arg0
.
type
(
)
)
)
{
return
unsupported
(
)
;
}
if
(
!
this
-
>
binaryOp
(
arg0
.
type
(
)
kMaxOps
)
)
{
return
unsupported
(
)
;
}
if
(
!
this
-
>
pushVectorizedExpression
(
arg2
arg0
.
type
(
)
)
)
{
return
unsupported
(
)
;
}
if
(
!
this
-
>
binaryOp
(
arg0
.
type
(
)
kMinOps
)
)
{
return
unsupported
(
)
;
}
return
true
;
case
IntrinsicKind
:
:
k_faceforward_IntrinsicKind
:
{
SkASSERT
(
arg0
.
type
(
)
.
matches
(
arg1
.
type
(
)
)
)
;
SkASSERT
(
arg0
.
type
(
)
.
matches
(
arg2
.
type
(
)
)
)
;
int
slotCount
=
arg0
.
type
(
)
.
slotCount
(
)
;
if
(
!
this
-
>
pushExpression
(
arg0
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
push_literal_f
(
0
.
0
)
;
if
(
!
this
-
>
pushExpression
(
arg1
)
|
|
!
this
-
>
pushExpression
(
arg2
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
dot_floats
(
slotCount
)
;
fBuilder
.
binary_op
(
BuilderOp
:
:
cmple_n_floats
1
)
;
fBuilder
.
push_literal_i
(
0x80000000
)
;
fBuilder
.
binary_op
(
BuilderOp
:
:
bitwise_and_n_ints
1
)
;
fBuilder
.
push_duplicates
(
slotCount
-
1
)
;
fBuilder
.
binary_op
(
BuilderOp
:
:
bitwise_xor_n_ints
slotCount
)
;
return
true
;
}
case
IntrinsicKind
:
:
k_mix_IntrinsicKind
:
SkASSERT
(
arg0
.
type
(
)
.
matches
(
arg1
.
type
(
)
)
)
;
if
(
arg2
.
type
(
)
.
componentType
(
)
.
isFloat
(
)
)
{
SkASSERT
(
arg0
.
type
(
)
.
componentType
(
)
.
matches
(
arg2
.
type
(
)
.
componentType
(
)
)
)
;
if
(
!
this
-
>
pushVectorizedExpression
(
arg2
arg0
.
type
(
)
)
)
{
return
unsupported
(
)
;
}
if
(
!
this
-
>
pushExpression
(
arg0
)
|
|
!
this
-
>
pushExpression
(
arg1
)
)
{
return
unsupported
(
)
;
}
return
this
-
>
ternaryOp
(
arg0
.
type
(
)
kMixOps
)
;
}
if
(
arg2
.
type
(
)
.
componentType
(
)
.
isBoolean
(
)
)
{
if
(
!
this
-
>
pushExpression
(
arg2
)
)
{
return
unsupported
(
)
;
}
if
(
!
this
-
>
pushExpression
(
arg0
)
|
|
!
this
-
>
pushExpression
(
arg1
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
ternary_op
(
BuilderOp
:
:
mix_n_ints
arg0
.
type
(
)
.
slotCount
(
)
)
;
return
true
;
}
return
unsupported
(
)
;
case
IntrinsicKind
:
:
k_refract_IntrinsicKind
:
{
int
padding
=
4
-
arg0
.
type
(
)
.
slotCount
(
)
;
if
(
!
this
-
>
pushExpression
(
arg0
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
push_zeros
(
padding
)
;
if
(
!
this
-
>
pushExpression
(
arg1
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
push_zeros
(
padding
)
;
if
(
!
this
-
>
pushExpression
(
arg2
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
refract_floats
(
)
;
fBuilder
.
discard_stack
(
padding
)
;
return
true
;
}
case
IntrinsicKind
:
:
k_smoothstep_IntrinsicKind
:
SkASSERT
(
arg0
.
type
(
)
.
componentType
(
)
.
isFloat
(
)
)
;
SkASSERT
(
arg1
.
type
(
)
.
matches
(
arg0
.
type
(
)
)
)
;
SkASSERT
(
arg2
.
type
(
)
.
componentType
(
)
.
isFloat
(
)
)
;
if
(
!
this
-
>
pushVectorizedExpression
(
arg0
arg2
.
type
(
)
)
|
|
!
this
-
>
pushVectorizedExpression
(
arg1
arg2
.
type
(
)
)
|
|
!
this
-
>
pushExpression
(
arg2
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
ternary_op
(
BuilderOp
:
:
smoothstep_n_floats
arg2
.
type
(
)
.
slotCount
(
)
)
;
return
true
;
default
:
break
;
}
return
unsupported
(
)
;
}
bool
Generator
:
:
pushLiteral
(
const
Literal
&
l
)
{
switch
(
l
.
type
(
)
.
numberKind
(
)
)
{
case
Type
:
:
NumberKind
:
:
kFloat
:
fBuilder
.
push_literal_f
(
l
.
floatValue
(
)
)
;
return
true
;
case
Type
:
:
NumberKind
:
:
kSigned
:
fBuilder
.
push_literal_i
(
l
.
intValue
(
)
)
;
return
true
;
case
Type
:
:
NumberKind
:
:
kUnsigned
:
fBuilder
.
push_literal_u
(
l
.
intValue
(
)
)
;
return
true
;
case
Type
:
:
NumberKind
:
:
kBoolean
:
fBuilder
.
push_literal_i
(
l
.
boolValue
(
)
?
~
0
:
0
)
;
return
true
;
default
:
SkUNREACHABLE
;
}
}
bool
Generator
:
:
pushPostfixExpression
(
const
PostfixExpression
&
p
bool
usesResult
)
{
if
(
!
usesResult
)
{
return
this
-
>
pushPrefixExpression
(
p
.
getOperator
(
)
*
p
.
operand
(
)
)
;
}
std
:
:
unique_ptr
<
LValue
>
lvalue
=
this
-
>
makeLValue
(
*
p
.
operand
(
)
)
;
if
(
!
lvalue
|
|
!
this
-
>
push
(
*
lvalue
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
push_clone
(
p
.
type
(
)
.
slotCount
(
)
)
;
Literal
oneLiteral
{
Position
{
}
1
.
0
&
p
.
type
(
)
.
componentType
(
)
}
;
if
(
!
this
-
>
pushVectorizedExpression
(
oneLiteral
p
.
type
(
)
)
)
{
return
unsupported
(
)
;
}
switch
(
p
.
getOperator
(
)
.
kind
(
)
)
{
case
OperatorKind
:
:
PLUSPLUS
:
if
(
!
this
-
>
binaryOp
(
p
.
type
(
)
kAddOps
)
)
{
return
unsupported
(
)
;
}
break
;
case
OperatorKind
:
:
MINUSMINUS
:
if
(
!
this
-
>
binaryOp
(
p
.
type
(
)
kSubtractOps
)
)
{
return
unsupported
(
)
;
}
break
;
default
:
SkUNREACHABLE
;
}
if
(
!
this
-
>
store
(
*
lvalue
)
)
{
return
unsupported
(
)
;
}
this
-
>
discardExpression
(
p
.
type
(
)
.
slotCount
(
)
)
;
return
true
;
}
bool
Generator
:
:
pushPrefixExpression
(
const
PrefixExpression
&
p
)
{
return
this
-
>
pushPrefixExpression
(
p
.
getOperator
(
)
*
p
.
operand
(
)
)
;
}
bool
Generator
:
:
pushPrefixExpression
(
Operator
op
const
Expression
&
expr
)
{
switch
(
op
.
kind
(
)
)
{
case
OperatorKind
:
:
BITWISENOT
:
case
OperatorKind
:
:
LOGICALNOT
:
if
(
!
this
-
>
pushExpression
(
expr
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
unary_op
(
BuilderOp
:
:
bitwise_not_int
expr
.
type
(
)
.
slotCount
(
)
)
;
return
true
;
case
OperatorKind
:
:
MINUS
:
fBuilder
.
push_zeros
(
expr
.
type
(
)
.
slotCount
(
)
)
;
if
(
!
this
-
>
pushExpression
(
expr
)
)
{
return
unsupported
(
)
;
}
return
this
-
>
binaryOp
(
expr
.
type
(
)
kSubtractOps
)
;
case
OperatorKind
:
:
PLUSPLUS
:
{
Literal
oneLiteral
{
Position
{
}
1
.
0
&
expr
.
type
(
)
.
componentType
(
)
}
;
return
this
-
>
pushBinaryExpression
(
expr
OperatorKind
:
:
PLUSEQ
oneLiteral
)
;
}
case
OperatorKind
:
:
MINUSMINUS
:
{
Literal
oneLiteral
{
Position
{
}
1
.
0
&
expr
.
type
(
)
.
componentType
(
)
}
;
return
this
-
>
pushBinaryExpression
(
expr
OperatorKind
:
:
MINUSEQ
oneLiteral
)
;
}
default
:
break
;
}
return
unsupported
(
)
;
}
bool
Generator
:
:
pushSwizzle
(
const
Swizzle
&
s
)
{
SkASSERT
(
!
s
.
components
(
)
.
empty
(
)
&
&
s
.
components
(
)
.
size
(
)
<
=
4
)
;
bool
isSimpleSubset
=
is_sliceable_swizzle
(
s
.
components
(
)
)
;
if
(
isSimpleSubset
&
&
s
.
base
(
)
-
>
is
<
VariableReference
>
(
)
)
{
return
this
-
>
pushVariableReferencePartial
(
s
.
base
(
)
-
>
as
<
VariableReference
>
(
)
SlotRange
{
s
.
components
(
)
[
0
]
s
.
components
(
)
.
size
(
)
}
)
;
}
if
(
!
this
-
>
pushExpression
(
*
s
.
base
(
)
)
)
{
return
false
;
}
if
(
isSimpleSubset
&
&
s
.
components
(
)
[
0
]
=
=
0
)
{
int
discardedElements
=
s
.
base
(
)
-
>
type
(
)
.
slotCount
(
)
-
s
.
components
(
)
.
size
(
)
;
SkASSERT
(
discardedElements
>
=
0
)
;
fBuilder
.
discard_stack
(
discardedElements
)
;
return
true
;
}
fBuilder
.
swizzle
(
s
.
base
(
)
-
>
type
(
)
.
slotCount
(
)
s
.
components
(
)
)
;
return
true
;
}
bool
Generator
:
:
pushTernaryExpression
(
const
TernaryExpression
&
t
)
{
return
this
-
>
pushTernaryExpression
(
*
t
.
test
(
)
*
t
.
ifTrue
(
)
*
t
.
ifFalse
(
)
)
;
}
bool
Generator
:
:
pushDynamicallyUniformTernaryExpression
(
const
Expression
&
test
const
Expression
&
ifTrue
const
Expression
&
ifFalse
)
{
SkASSERT
(
Analysis
:
:
IsDynamicallyUniformExpression
(
test
)
)
;
int
falseLabelID
=
fBuilder
.
nextLabelID
(
)
;
int
exitLabelID
=
fBuilder
.
nextLabelID
(
)
;
AutoStack
testStack
(
this
)
;
testStack
.
enter
(
)
;
if
(
!
this
-
>
pushExpression
(
test
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
branch_if_no_active_lanes_on_stack_top_equal
(
~
0
falseLabelID
)
;
testStack
.
exit
(
)
;
if
(
!
this
-
>
pushExpression
(
ifTrue
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
jump
(
exitLabelID
)
;
this
-
>
discardExpression
(
ifTrue
.
type
(
)
.
slotCount
(
)
)
;
fBuilder
.
label
(
falseLabelID
)
;
if
(
!
this
-
>
pushExpression
(
ifFalse
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
label
(
exitLabelID
)
;
testStack
.
enter
(
)
;
this
-
>
discardExpression
(
1
)
;
testStack
.
exit
(
)
;
return
true
;
}
bool
Generator
:
:
pushTernaryExpression
(
const
Expression
&
test
const
Expression
&
ifTrue
const
Expression
&
ifFalse
)
{
if
(
Analysis
:
:
IsDynamicallyUniformExpression
(
test
)
)
{
return
this
-
>
pushDynamicallyUniformTernaryExpression
(
test
ifTrue
ifFalse
)
;
}
bool
ifFalseHasSideEffects
=
Analysis
:
:
HasSideEffects
(
ifFalse
)
;
bool
ifTrueHasSideEffects
=
Analysis
:
:
HasSideEffects
(
ifTrue
)
;
bool
ifTrueIsTrivial
=
Analysis
:
:
IsTrivialExpression
(
ifTrue
)
;
int
cleanupLabelID
=
fBuilder
.
nextLabelID
(
)
;
if
(
!
ifFalseHasSideEffects
&
&
!
ifTrueHasSideEffects
&
&
ifTrueIsTrivial
)
{
if
(
!
this
-
>
pushVectorizedExpression
(
test
ifTrue
.
type
(
)
)
)
{
return
unsupported
(
)
;
}
if
(
!
this
-
>
pushExpression
(
ifFalse
)
)
{
return
unsupported
(
)
;
}
if
(
!
this
-
>
pushExpression
(
ifTrue
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
ternary_op
(
BuilderOp
:
:
mix_n_ints
ifTrue
.
type
(
)
.
slotCount
(
)
)
;
return
true
;
}
fBuilder
.
enableExecutionMaskWrites
(
)
;
AutoStack
testStack
(
this
)
;
testStack
.
enter
(
)
;
fBuilder
.
push_condition_mask
(
)
;
if
(
!
this
-
>
pushExpression
(
test
)
)
{
return
unsupported
(
)
;
}
testStack
.
exit
(
)
;
if
(
!
ifFalseHasSideEffects
)
{
if
(
!
this
-
>
pushExpression
(
ifFalse
)
)
{
return
unsupported
(
)
;
}
testStack
.
enter
(
)
;
fBuilder
.
merge_condition_mask
(
)
;
testStack
.
exit
(
)
;
if
(
!
ifTrueIsTrivial
)
{
fBuilder
.
branch_if_no_lanes_active
(
cleanupLabelID
)
;
}
if
(
!
this
-
>
pushExpression
(
ifTrue
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
select
(
ifTrue
.
type
(
)
.
slotCount
(
)
)
;
fBuilder
.
label
(
cleanupLabelID
)
;
}
else
{
testStack
.
enter
(
)
;
fBuilder
.
merge_condition_mask
(
)
;
testStack
.
exit
(
)
;
if
(
!
this
-
>
pushExpression
(
ifTrue
)
)
{
return
unsupported
(
)
;
}
testStack
.
enter
(
)
;
fBuilder
.
unary_op
(
BuilderOp
:
:
bitwise_not_int
1
)
;
fBuilder
.
merge_condition_mask
(
)
;
testStack
.
exit
(
)
;
if
(
!
this
-
>
pushExpression
(
ifFalse
)
)
{
return
unsupported
(
)
;
}
fBuilder
.
select
(
ifTrue
.
type
(
)
.
slotCount
(
)
)
;
}
testStack
.
enter
(
)
;
this
-
>
discardExpression
(
1
)
;
fBuilder
.
pop_condition_mask
(
)
;
testStack
.
exit
(
)
;
fBuilder
.
disableExecutionMaskWrites
(
)
;
return
true
;
}
bool
Generator
:
:
pushVariableReference
(
const
VariableReference
&
v
)
{
return
this
-
>
pushVariableReferencePartial
(
v
SlotRange
{
0
(
int
)
v
.
type
(
)
.
slotCount
(
)
}
)
;
}
bool
Generator
:
:
pushVariableReferencePartial
(
const
VariableReference
&
v
SlotRange
subset
)
{
const
Variable
&
var
=
*
v
.
variable
(
)
;
SlotRange
r
;
if
(
IsUniform
(
var
)
)
{
r
=
this
-
>
getUniformSlots
(
var
)
;
SkASSERT
(
r
.
count
=
=
(
int
)
var
.
type
(
)
.
slotCount
(
)
)
;
r
.
index
+
=
subset
.
index
;
r
.
count
=
subset
.
count
;
fBuilder
.
push_uniform
(
r
)
;
}
else
{
r
=
this
-
>
getVariableSlots
(
var
)
;
SkASSERT
(
r
.
count
=
=
(
int
)
var
.
type
(
)
.
slotCount
(
)
)
;
r
.
index
+
=
subset
.
index
;
r
.
count
=
subset
.
count
;
fBuilder
.
push_slots
(
r
)
;
}
return
true
;
}
bool
Generator
:
:
writeProgram
(
const
FunctionDefinition
&
function
)
{
fCurrentFunction
=
&
function
;
if
(
fDebugTrace
)
{
fDebugTrace
-
>
setSource
(
*
fProgram
.
fSource
)
;
}
for
(
const
SkSL
:
:
Variable
*
param
:
function
.
declaration
(
)
.
parameters
(
)
)
{
switch
(
param
-
>
modifiers
(
)
.
fLayout
.
fBuiltin
)
{
case
SK_MAIN_COORDS_BUILTIN
:
{
SlotRange
fragCoord
=
this
-
>
getVariableSlots
(
*
param
)
;
SkASSERT
(
fragCoord
.
count
=
=
2
)
;
fBuilder
.
store_src_rg
(
fragCoord
)
;
break
;
}
case
SK_INPUT_COLOR_BUILTIN
:
{
SlotRange
srcColor
=
this
-
>
getVariableSlots
(
*
param
)
;
SkASSERT
(
srcColor
.
count
=
=
4
)
;
fBuilder
.
store_src
(
srcColor
)
;
break
;
}
case
SK_DEST_COLOR_BUILTIN
:
{
SlotRange
destColor
=
this
-
>
getVariableSlots
(
*
param
)
;
SkASSERT
(
destColor
.
count
=
=
4
)
;
fBuilder
.
store_dst
(
destColor
)
;
break
;
}
default
:
{
SkDEBUGFAIL
(
"
Invalid
parameter
to
main
(
)
"
)
;
return
unsupported
(
)
;
}
}
}
fBuilder
.
init_lane_masks
(
)
;
if
(
!
this
-
>
writeGlobals
(
)
)
{
return
unsupported
(
)
;
}
if
(
this
-
>
needsReturnMask
(
)
)
{
fBuilder
.
enableExecutionMaskWrites
(
)
;
}
std
:
:
optional
<
SlotRange
>
mainResult
=
this
-
>
writeFunction
(
function
function
)
;
if
(
!
mainResult
.
has_value
(
)
)
{
return
unsupported
(
)
;
}
if
(
this
-
>
needsReturnMask
(
)
)
{
fBuilder
.
disableExecutionMaskWrites
(
)
;
}
SkASSERT
(
mainResult
-
>
count
=
=
4
)
;
if
(
this
-
>
needsFunctionResultSlots
(
)
)
{
fBuilder
.
load_src
(
*
mainResult
)
;
}
else
{
fBuilder
.
pop_src_rgba
(
)
;
}
return
true
;
}
std
:
:
unique_ptr
<
RP
:
:
Program
>
Generator
:
:
finish
(
)
{
return
fBuilder
.
finish
(
fProgramSlots
.
slotCount
(
)
fUniformSlots
.
slotCount
(
)
fDebugTrace
)
;
}
}
std
:
:
unique_ptr
<
RP
:
:
Program
>
MakeRasterPipelineProgram
(
const
SkSL
:
:
Program
&
program
const
FunctionDefinition
&
function
SkRPDebugTrace
*
debugTrace
)
{
RP
:
:
Generator
generator
(
program
debugTrace
)
;
if
(
!
generator
.
writeProgram
(
function
)
)
{
return
nullptr
;
}
return
generator
.
finish
(
)
;
}
}
