#
ifndef
SKSL_BYTECODE
#
define
SKSL_BYTECODE
#
include
"
include
/
private
/
SkOnce
.
h
"
#
include
"
src
/
sksl
/
SkSLString
.
h
"
#
include
<
memory
>
#
include
<
vector
>
namespace
SkSL
{
class
ExternalValue
;
struct
FunctionDeclaration
;
#
if
defined
(
__GNUC__
)
|
|
defined
(
__clang__
)
#
define
SKSLC_THREADED_CODE
using
instruction
=
void
*
;
#
else
using
instruction
=
uint16_t
;
#
endif
#
define
VECTOR
(
name
)
name
#
#
4
name
#
#
3
name
#
#
2
name
#
define
VECTOR_MATRIX
(
name
)
name
#
#
4
name
#
#
3
name
#
#
2
name
name
#
#
N
enum
class
ByteCodeInstruction
:
uint16_t
{
VECTOR_MATRIX
(
kAddF
)
VECTOR
(
kAddI
)
kAndB
kBranch
kCall
kCallExternal
kClampIndex
VECTOR
(
kCompareIEQ
)
VECTOR
(
kCompareINEQ
)
VECTOR_MATRIX
(
kCompareFEQ
)
VECTOR_MATRIX
(
kCompareFNEQ
)
VECTOR
(
kCompareFGT
)
VECTOR
(
kCompareFGTEQ
)
VECTOR
(
kCompareFLT
)
VECTOR
(
kCompareFLTEQ
)
VECTOR
(
kCompareSGT
)
VECTOR
(
kCompareSGTEQ
)
VECTOR
(
kCompareSLT
)
VECTOR
(
kCompareSLTEQ
)
VECTOR
(
kCompareUGT
)
VECTOR
(
kCompareUGTEQ
)
VECTOR
(
kCompareULT
)
VECTOR
(
kCompareULTEQ
)
VECTOR
(
kConvertFtoI
)
VECTOR
(
kConvertStoF
)
VECTOR
(
kConvertUtoF
)
VECTOR
(
kCos
)
VECTOR_MATRIX
(
kDivideF
)
VECTOR
(
kDivideS
)
VECTOR
(
kDivideU
)
VECTOR_MATRIX
(
kDup
)
kInverse2x2
kInverse3x3
kInverse4x4
VECTOR
(
kLoad
)
VECTOR
(
kLoadGlobal
)
VECTOR
(
kLoadUniform
)
kLoadSwizzle
kLoadSwizzleGlobal
kLoadSwizzleUniform
kLoadExtended
kLoadExtendedGlobal
kLoadExtendedUniform
kMatrixToMatrix
kMatrixMultiply
VECTOR_MATRIX
(
kNegateF
)
VECTOR
(
kNegateI
)
VECTOR_MATRIX
(
kMultiplyF
)
VECTOR
(
kMultiplyI
)
kNotB
kOrB
VECTOR_MATRIX
(
kPop
)
kPushImmediate
VECTOR
(
kReadExternal
)
VECTOR
(
kRemainderF
)
VECTOR
(
kRemainderS
)
VECTOR
(
kRemainderU
)
kReserve
kReturn
kScalarToMatrix
kShiftLeft
kShiftRightS
kShiftRightU
VECTOR
(
kSin
)
VECTOR
(
kSqrt
)
VECTOR
(
kStore
)
VECTOR
(
kStoreGlobal
)
kStoreExtended
kStoreExtendedGlobal
kStoreSwizzle
kStoreSwizzleGlobal
kStoreSwizzleIndirect
kStoreSwizzleIndirectGlobal
kSwizzle
VECTOR_MATRIX
(
kSubtractF
)
VECTOR
(
kSubtractI
)
VECTOR
(
kTan
)
VECTOR
(
kWriteExternal
)
kXorB
kMaskPush
kMaskPop
kMaskNegate
kMaskBlend
kBranchIfAllFalse
kLoopBegin
kLoopNext
kLoopMask
kLoopEnd
kLoopBreak
kLoopContinue
}
;
#
undef
VECTOR
class
ByteCodeFunction
{
public
:
int
getParameterCount
(
)
const
{
return
fParameterCount
;
}
int
getReturnCount
(
)
const
{
return
fReturnCount
;
}
void
disassemble
(
)
const
;
private
:
ByteCodeFunction
(
const
FunctionDeclaration
*
declaration
)
;
friend
class
ByteCode
;
friend
class
ByteCodeGenerator
;
friend
struct
Interpreter
;
struct
Parameter
{
int
fSlotCount
;
bool
fIsOutParameter
;
}
;
SkSL
:
:
String
fName
;
std
:
:
vector
<
Parameter
>
fParameters
;
int
fParameterCount
;
int
fReturnCount
=
0
;
int
fLocalCount
=
0
;
int
fStackCount
=
0
;
int
fConditionCount
=
0
;
int
fLoopCount
=
0
;
mutable
SkOnce
fPreprocessOnce
;
std
:
:
vector
<
uint8_t
>
fCode
;
void
preprocess
(
const
void
*
labels
[
]
)
;
}
;
enum
class
TypeCategory
{
kBool
kSigned
kUnsigned
kFloat
}
;
class
SK_API
ByteCode
{
public
:
static
constexpr
int
kVecWidth
=
16
;
ByteCode
(
)
=
default
;
const
ByteCodeFunction
*
getFunction
(
const
char
*
name
)
const
{
for
(
const
auto
&
f
:
fFunctions
)
{
if
(
f
-
>
fName
=
=
name
)
{
return
f
.
get
(
)
;
}
}
return
nullptr
;
}
bool
SKSL_WARN_UNUSED_RESULT
run
(
const
ByteCodeFunction
*
float
*
args
int
argCount
float
*
outReturn
int
returnCount
const
float
*
uniforms
int
uniformCount
)
const
;
bool
SKSL_WARN_UNUSED_RESULT
runStriped
(
const
ByteCodeFunction
*
int
N
float
*
args
[
]
int
argCount
float
*
outReturn
[
]
int
returnCount
const
float
*
uniforms
int
uniformCount
)
const
;
struct
Uniform
{
SkSL
:
:
String
fName
;
TypeCategory
fType
;
int
fColumns
;
int
fRows
;
int
fSlot
;
}
;
int
getUniformSlotCount
(
)
const
{
return
fUniformSlotCount
;
}
int
getUniformCount
(
)
const
{
return
fUniforms
.
size
(
)
;
}
int
getUniformLocation
(
const
char
*
name
)
const
{
for
(
int
i
=
0
;
i
<
(
int
)
fUniforms
.
size
(
)
;
+
+
i
)
{
if
(
fUniforms
[
i
]
.
fName
=
=
name
)
{
return
fUniforms
[
i
]
.
fSlot
;
}
}
return
-
1
;
}
const
Uniform
&
getUniform
(
int
i
)
const
{
return
fUniforms
[
i
]
;
}
private
:
ByteCode
(
const
ByteCode
&
)
=
delete
;
ByteCode
&
operator
=
(
const
ByteCode
&
)
=
delete
;
friend
class
ByteCodeGenerator
;
friend
struct
Interpreter
;
int
fGlobalSlotCount
=
0
;
int
fUniformSlotCount
=
0
;
std
:
:
vector
<
Uniform
>
fUniforms
;
std
:
:
vector
<
std
:
:
unique_ptr
<
ByteCodeFunction
>
>
fFunctions
;
std
:
:
vector
<
ExternalValue
*
>
fExternalValues
;
}
;
}
#
endif
