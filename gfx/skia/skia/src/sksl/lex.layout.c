#
line
2
"
lex
.
layout
.
c
"
#
define
YY_INT_ALIGNED
short
int
#
define
FLEX_SCANNER
#
define
YY_FLEX_MAJOR_VERSION
2
#
define
YY_FLEX_MINOR_VERSION
6
#
define
YY_FLEX_SUBMINOR_VERSION
3
#
if
YY_FLEX_SUBMINOR_VERSION
>
0
#
define
FLEX_BETA
#
endif
#
define
yy_create_buffer
layout_create_buffer
#
define
yy_delete_buffer
layout_delete_buffer
#
define
yy_scan_buffer
layout_scan_buffer
#
define
yy_scan_string
layout_scan_string
#
define
yy_scan_bytes
layout_scan_bytes
#
define
yy_init_buffer
layout_init_buffer
#
define
yy_flush_buffer
layout_flush_buffer
#
define
yy_load_buffer_state
layout_load_buffer_state
#
define
yy_switch_to_buffer
layout_switch_to_buffer
#
define
yypush_buffer_state
layoutpush_buffer_state
#
define
yypop_buffer_state
layoutpop_buffer_state
#
define
yyensure_buffer_stack
layoutensure_buffer_stack
#
define
yylex
layoutlex
#
define
yyrestart
layoutrestart
#
define
yylex_init
layoutlex_init
#
define
yylex_init_extra
layoutlex_init_extra
#
define
yylex_destroy
layoutlex_destroy
#
define
yyget_debug
layoutget_debug
#
define
yyset_debug
layoutset_debug
#
define
yyget_extra
layoutget_extra
#
define
yyset_extra
layoutset_extra
#
define
yyget_in
layoutget_in
#
define
yyset_in
layoutset_in
#
define
yyget_out
layoutget_out
#
define
yyset_out
layoutset_out
#
define
yyget_leng
layoutget_leng
#
define
yyget_text
layoutget_text
#
define
yyget_lineno
layoutget_lineno
#
define
yyset_lineno
layoutset_lineno
#
define
yyget_column
layoutget_column
#
define
yyset_column
layoutset_column
#
define
yywrap
layoutwrap
#
define
yyalloc
layoutalloc
#
define
yyrealloc
layoutrealloc
#
define
yyfree
layoutfree
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
errno
.
h
>
#
include
<
stdlib
.
h
>
#
ifndef
FLEXINT_H
#
define
FLEXINT_H
#
if
defined
(
__STDC_VERSION__
)
&
&
__STDC_VERSION__
>
=
199901L
#
ifndef
__STDC_LIMIT_MACROS
#
define
__STDC_LIMIT_MACROS
1
#
endif
#
include
<
inttypes
.
h
>
typedef
int8_t
flex_int8_t
;
typedef
uint8_t
flex_uint8_t
;
typedef
int16_t
flex_int16_t
;
typedef
uint16_t
flex_uint16_t
;
typedef
int32_t
flex_int32_t
;
typedef
uint32_t
flex_uint32_t
;
#
else
typedef
signed
char
flex_int8_t
;
typedef
short
int
flex_int16_t
;
typedef
int
flex_int32_t
;
typedef
unsigned
char
flex_uint8_t
;
typedef
unsigned
short
int
flex_uint16_t
;
typedef
unsigned
int
flex_uint32_t
;
#
ifndef
INT8_MIN
#
define
INT8_MIN
(
-
128
)
#
endif
#
ifndef
INT16_MIN
#
define
INT16_MIN
(
-
32767
-
1
)
#
endif
#
ifndef
INT32_MIN
#
define
INT32_MIN
(
-
2147483647
-
1
)
#
endif
#
ifndef
INT8_MAX
#
define
INT8_MAX
(
127
)
#
endif
#
ifndef
INT16_MAX
#
define
INT16_MAX
(
32767
)
#
endif
#
ifndef
INT32_MAX
#
define
INT32_MAX
(
2147483647
)
#
endif
#
ifndef
UINT8_MAX
#
define
UINT8_MAX
(
255U
)
#
endif
#
ifndef
UINT16_MAX
#
define
UINT16_MAX
(
65535U
)
#
endif
#
ifndef
UINT32_MAX
#
define
UINT32_MAX
(
4294967295U
)
#
endif
#
endif
#
endif
#
define
yyconst
const
#
if
defined
(
__GNUC__
)
&
&
__GNUC__
>
=
3
#
define
yynoreturn
__attribute__
(
(
__noreturn__
)
)
#
else
#
define
yynoreturn
#
endif
#
define
YY_NULL
0
#
define
YY_SC_TO_UI
(
c
)
(
(
YY_CHAR
)
(
c
)
)
#
ifndef
YY_TYPEDEF_YY_SCANNER_T
#
define
YY_TYPEDEF_YY_SCANNER_T
typedef
void
*
yyscan_t
;
#
endif
#
define
yyin
yyg
-
>
yyin_r
#
define
yyout
yyg
-
>
yyout_r
#
define
yyextra
yyg
-
>
yyextra_r
#
define
yyleng
yyg
-
>
yyleng_r
#
define
yytext
yyg
-
>
yytext_r
#
define
yylineno
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_bs_lineno
)
#
define
yycolumn
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_bs_column
)
#
define
yy_flex_debug
yyg
-
>
yy_flex_debug_r
#
define
BEGIN
yyg
-
>
yy_start
=
1
+
2
*
#
define
YY_START
(
(
yyg
-
>
yy_start
-
1
)
/
2
)
#
define
YYSTATE
YY_START
#
define
YY_STATE_EOF
(
state
)
(
YY_END_OF_BUFFER
+
state
+
1
)
#
define
YY_NEW_FILE
layoutrestart
(
yyin
yyscanner
)
#
define
YY_END_OF_BUFFER_CHAR
0
#
ifndef
YY_BUF_SIZE
#
ifdef
__ia64__
#
define
YY_BUF_SIZE
32768
#
else
#
define
YY_BUF_SIZE
16384
#
endif
#
endif
#
define
YY_STATE_BUF_SIZE
(
(
YY_BUF_SIZE
+
2
)
*
sizeof
(
yy_state_type
)
)
#
ifndef
YY_TYPEDEF_YY_BUFFER_STATE
#
define
YY_TYPEDEF_YY_BUFFER_STATE
typedef
struct
yy_buffer_state
*
YY_BUFFER_STATE
;
#
endif
#
ifndef
YY_TYPEDEF_YY_SIZE_T
#
define
YY_TYPEDEF_YY_SIZE_T
typedef
size_t
yy_size_t
;
#
endif
#
define
EOB_ACT_CONTINUE_SCAN
0
#
define
EOB_ACT_END_OF_FILE
1
#
define
EOB_ACT_LAST_MATCH
2
#
define
YY_LESS_LINENO
(
n
)
\
do
{
\
int
yyl
;
\
for
(
yyl
=
n
;
yyl
<
yyleng
;
+
+
yyl
)
\
if
(
yytext
[
yyl
]
=
=
'
\
n
'
)
\
-
-
yylineno
;
\
}
while
(
0
)
#
define
YY_LINENO_REWIND_TO
(
dst
)
\
do
{
\
const
char
*
p
;
\
for
(
p
=
yy_cp
-
1
;
p
>
=
(
dst
)
;
-
-
p
)
\
if
(
*
p
=
=
'
\
n
'
)
\
-
-
yylineno
;
\
}
while
(
0
)
#
define
yyless
(
n
)
\
do
\
{
\
/
*
Undo
effects
of
setting
up
yytext
.
*
/
\
int
yyless_macro_arg
=
(
n
)
;
\
YY_LESS_LINENO
(
yyless_macro_arg
)
;
\
*
yy_cp
=
yyg
-
>
yy_hold_char
;
\
YY_RESTORE_YY_MORE_OFFSET
\
yyg
-
>
yy_c_buf_p
=
yy_cp
=
yy_bp
+
yyless_macro_arg
-
YY_MORE_ADJ
;
\
YY_DO_BEFORE_ACTION
;
/
*
set
up
yytext
again
*
/
\
}
\
while
(
0
)
#
define
unput
(
c
)
yyunput
(
c
yyg
-
>
yytext_ptr
yyscanner
)
#
ifndef
YY_STRUCT_YY_BUFFER_STATE
#
define
YY_STRUCT_YY_BUFFER_STATE
struct
yy_buffer_state
{
FILE
*
yy_input_file
;
char
*
yy_ch_buf
;
char
*
yy_buf_pos
;
int
yy_buf_size
;
int
yy_n_chars
;
int
yy_is_our_buffer
;
int
yy_is_interactive
;
int
yy_at_bol
;
int
yy_bs_lineno
;
int
yy_bs_column
;
int
yy_fill_buffer
;
int
yy_buffer_status
;
#
define
YY_BUFFER_NEW
0
#
define
YY_BUFFER_NORMAL
1
#
define
YY_BUFFER_EOF_PENDING
2
}
;
#
endif
#
define
YY_CURRENT_BUFFER
(
yyg
-
>
yy_buffer_stack
\
?
yyg
-
>
yy_buffer_stack
[
yyg
-
>
yy_buffer_stack_top
]
\
:
NULL
)
#
define
YY_CURRENT_BUFFER_LVALUE
yyg
-
>
yy_buffer_stack
[
yyg
-
>
yy_buffer_stack_top
]
void
layoutrestart
(
FILE
*
input_file
yyscan_t
yyscanner
)
;
void
layout_switch_to_buffer
(
YY_BUFFER_STATE
new_buffer
yyscan_t
yyscanner
)
;
YY_BUFFER_STATE
layout_create_buffer
(
FILE
*
file
int
size
yyscan_t
yyscanner
)
;
void
layout_delete_buffer
(
YY_BUFFER_STATE
b
yyscan_t
yyscanner
)
;
void
layout_flush_buffer
(
YY_BUFFER_STATE
b
yyscan_t
yyscanner
)
;
void
layoutpush_buffer_state
(
YY_BUFFER_STATE
new_buffer
yyscan_t
yyscanner
)
;
void
layoutpop_buffer_state
(
yyscan_t
yyscanner
)
;
static
void
layoutensure_buffer_stack
(
yyscan_t
yyscanner
)
;
static
void
layout_load_buffer_state
(
yyscan_t
yyscanner
)
;
static
void
layout_init_buffer
(
YY_BUFFER_STATE
b
FILE
*
file
yyscan_t
yyscanner
)
;
#
define
YY_FLUSH_BUFFER
layout_flush_buffer
(
YY_CURRENT_BUFFER
yyscanner
)
YY_BUFFER_STATE
layout_scan_buffer
(
char
*
base
yy_size_t
size
yyscan_t
yyscanner
)
;
YY_BUFFER_STATE
layout_scan_string
(
const
char
*
yy_str
yyscan_t
yyscanner
)
;
YY_BUFFER_STATE
layout_scan_bytes
(
const
char
*
bytes
int
len
yyscan_t
yyscanner
)
;
void
*
layoutalloc
(
yy_size_t
yyscan_t
yyscanner
)
;
void
*
layoutrealloc
(
void
*
yy_size_t
yyscan_t
yyscanner
)
;
void
layoutfree
(
void
*
yyscan_t
yyscanner
)
;
#
define
yy_new_buffer
layout_create_buffer
#
define
yy_set_interactive
(
is_interactive
)
\
{
\
if
(
!
YY_CURRENT_BUFFER
)
{
\
layoutensure_buffer_stack
(
yyscanner
)
;
\
YY_CURRENT_BUFFER_LVALUE
=
\
layout_create_buffer
(
yyin
YY_BUF_SIZE
yyscanner
)
;
\
}
\
YY_CURRENT_BUFFER_LVALUE
-
>
yy_is_interactive
=
is_interactive
;
\
}
#
define
yy_set_bol
(
at_bol
)
\
{
\
if
(
!
YY_CURRENT_BUFFER
)
{
\
layoutensure_buffer_stack
(
yyscanner
)
;
\
YY_CURRENT_BUFFER_LVALUE
=
\
layout_create_buffer
(
yyin
YY_BUF_SIZE
yyscanner
)
;
\
}
\
YY_CURRENT_BUFFER_LVALUE
-
>
yy_at_bol
=
at_bol
;
\
}
#
define
YY_AT_BOL
(
)
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_at_bol
)
typedef
flex_uint8_t
YY_CHAR
;
typedef
int
yy_state_type
;
#
define
yytext_ptr
yytext_r
static
yy_state_type
yy_get_previous_state
(
yyscan_t
yyscanner
)
;
static
yy_state_type
yy_try_NUL_trans
(
yy_state_type
current_state
yyscan_t
yyscanner
)
;
static
int
yy_get_next_buffer
(
yyscan_t
yyscanner
)
;
static
void
yynoreturn
yy_fatal_error
(
const
char
*
msg
yyscan_t
yyscanner
)
;
#
define
YY_DO_BEFORE_ACTION
\
yyg
-
>
yytext_ptr
=
yy_bp
;
\
yyleng
=
(
int
)
(
yy_cp
-
yy_bp
)
;
\
yyg
-
>
yy_hold_char
=
*
yy_cp
;
\
*
yy_cp
=
'
\
0
'
;
\
yyg
-
>
yy_c_buf_p
=
yy_cp
;
#
define
YY_NUM_RULES
22
#
define
YY_END_OF_BUFFER
23
struct
yy_trans_info
{
flex_int32_t
yy_verify
;
flex_int32_t
yy_nxt
;
}
;
static
const
flex_int16_t
yy_accept
[
204
]
=
{
0
0
0
23
21
22
21
21
21
21
21
21
21
21
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
5
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
4
0
0
0
13
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
2
0
0
12
0
0
3
0
6
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
16
0
0
0
14
0
0
0
0
0
0
0
0
0
20
0
0
0
0
0
0
0
0
0
0
19
0
0
0
0
0
0
0
0
0
0
11
0
0
0
0
0
0
0
17
0
0
0
15
0
0
0
0
0
0
0
0
0
0
8
9
0
0
0
0
0
0
18
0
0
0
0
0
7
0
0
0
0
10
0
}
;
static
const
YY_CHAR
yy_ec
[
256
]
=
{
0
1
1
1
1
1
1
1
1
1
2
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
3
1
4
5
6
7
8
9
10
11
12
13
1
14
15
16
17
18
19
20
21
22
23
24
1
25
26
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
}
;
static
const
YY_CHAR
yy_meta
[
27
]
=
{
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
}
;
static
const
flex_int16_t
yy_base
[
205
]
=
{
0
0
21
218
219
219
17
201
7
212
21
11
207
194
197
204
199
30
194
203
183
198
194
197
192
182
180
189
193
183
184
189
173
178
186
189
189
170
180
169
172
176
219
182
173
177
161
157
159
174
4
157
154
169
164
155
152
170
156
155
167
157
219
165
163
145
162
152
155
140
145
148
138
152
147
146
134
138
149
130
129
146
132
128
219
144
139
219
128
130
219
120
219
120
129
120
132
122
115
113
127
118
125
114
109
113
117
115
219
115
108
122
103
6
105
118
105
102
115
112
99
110
93
93
110
95
105
89
219
103
100
99
89
101
82
99
82
90
219
92
78
78
73
80
75
87
71
77
75
219
87
81
66
75
73
82
76
77
68
61
219
62
75
74
61
50
67
70
219
67
58
49
219
61
59
60
53
63
43
56
47
59
49
219
219
54
51
42
31
37
48
219
30
44
47
25
27
219
35
29
28
11
219
219
0
}
;
static
const
flex_int16_t
yy_def
[
205
]
=
{
0
204
204
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
0
203
}
;
static
const
flex_int16_t
yy_nxt
[
246
]
=
{
0
4
5
203
203
6
203
65
203
123
203
203
7
203
8
9
203
10
11
18
203
12
13
5
19
66
6
124
24
14
21
15
202
7
25
8
9
31
10
11
16
22
12
13
201
23
200
199
32
198
197
196
195
194
33
193
192
191
190
189
188
187
186
185
184
183
182
181
180
179
178
177
176
175
174
173
172
171
170
169
168
167
166
165
164
163
162
161
160
159
158
157
156
155
154
153
152
151
150
149
148
147
146
145
144
143
142
141
140
139
138
137
136
135
134
133
132
131
130
129
128
127
126
125
122
121
120
119
118
117
116
115
114
113
112
111
110
109
108
107
106
105
104
103
102
101
100
99
98
97
96
95
94
93
92
91
90
89
88
87
86
85
84
83
82
81
80
79
78
77
76
75
74
73
72
71
70
69
68
67
64
63
62
61
60
59
58
57
56
55
54
53
52
51
50
49
48
47
46
45
44
43
42
41
40
39
38
37
36
35
34
30
29
28
27
26
20
17
203
3
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
}
;
static
const
flex_int16_t
yy_chk
[
246
]
=
{
0
204
1
0
0
1
0
50
0
113
0
0
1
0
1
1
0
1
1
8
0
1
1
2
8
50
2
113
11
6
10
6
201
2
11
2
2
17
2
2
6
10
2
2
200
10
199
198
17
196
195
194
193
192
17
190
189
188
187
186
185
182
181
180
179
178
177
176
175
174
173
171
170
169
167
166
165
164
163
162
161
159
158
157
156
155
154
153
152
151
150
148
147
146
145
144
143
142
141
140
139
137
136
135
134
133
132
131
130
129
127
126
125
124
123
122
121
120
119
118
117
116
115
114
112
111
110
109
107
106
105
104
103
102
101
100
99
98
97
96
95
94
93
91
89
88
86
85
83
82
81
80
79
78
77
76
75
74
73
72
71
70
69
68
67
66
65
64
63
61
60
59
58
57
56
55
54
53
52
51
49
48
47
46
45
44
43
41
40
39
38
37
36
35
34
33
32
31
30
29
28
27
26
25
24
23
22
21
20
19
18
16
15
14
13
12
9
7
3
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
203
}
;
static
const
flex_int32_t
yy_rule_can_match_eol
[
23
]
=
{
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
}
;
#
define
REJECT
reject_used_but_not_detected
#
define
yymore
(
)
yymore_used_but_not_detected
#
define
YY_MORE_ADJ
0
#
define
YY_RESTORE_YY_MORE_OFFSET
#
line
1
"
layout
.
flex
"
#
define
YY_NO_UNISTD_H
1
#
line
29
"
layout
.
flex
"
#
include
"
SkSLToken
.
h
"
#
line
648
"
lex
.
layout
.
c
"
#
line
649
"
lex
.
layout
.
c
"
#
define
INITIAL
0
#
ifndef
YY_NO_UNISTD_H
#
include
<
unistd
.
h
>
#
endif
#
ifndef
YY_EXTRA_TYPE
#
define
YY_EXTRA_TYPE
void
*
#
endif
struct
yyguts_t
{
YY_EXTRA_TYPE
yyextra_r
;
FILE
*
yyin_r
*
yyout_r
;
size_t
yy_buffer_stack_top
;
size_t
yy_buffer_stack_max
;
YY_BUFFER_STATE
*
yy_buffer_stack
;
char
yy_hold_char
;
int
yy_n_chars
;
int
yyleng_r
;
char
*
yy_c_buf_p
;
int
yy_init
;
int
yy_start
;
int
yy_did_buffer_switch_on_eof
;
int
yy_start_stack_ptr
;
int
yy_start_stack_depth
;
int
*
yy_start_stack
;
yy_state_type
yy_last_accepting_state
;
char
*
yy_last_accepting_cpos
;
int
yylineno_r
;
int
yy_flex_debug_r
;
char
*
yytext_r
;
int
yy_more_flag
;
int
yy_more_len
;
}
;
static
int
yy_init_globals
(
yyscan_t
yyscanner
)
;
int
layoutlex_init
(
yyscan_t
*
scanner
)
;
int
layoutlex_init_extra
(
YY_EXTRA_TYPE
user_defined
yyscan_t
*
scanner
)
;
int
layoutlex_destroy
(
yyscan_t
yyscanner
)
;
int
layoutget_debug
(
yyscan_t
yyscanner
)
;
void
layoutset_debug
(
int
debug_flag
yyscan_t
yyscanner
)
;
YY_EXTRA_TYPE
layoutget_extra
(
yyscan_t
yyscanner
)
;
void
layoutset_extra
(
YY_EXTRA_TYPE
user_defined
yyscan_t
yyscanner
)
;
FILE
*
layoutget_in
(
yyscan_t
yyscanner
)
;
void
layoutset_in
(
FILE
*
_in_str
yyscan_t
yyscanner
)
;
FILE
*
layoutget_out
(
yyscan_t
yyscanner
)
;
void
layoutset_out
(
FILE
*
_out_str
yyscan_t
yyscanner
)
;
int
layoutget_leng
(
yyscan_t
yyscanner
)
;
char
*
layoutget_text
(
yyscan_t
yyscanner
)
;
int
layoutget_lineno
(
yyscan_t
yyscanner
)
;
void
layoutset_lineno
(
int
_line_number
yyscan_t
yyscanner
)
;
int
layoutget_column
(
yyscan_t
yyscanner
)
;
void
layoutset_column
(
int
_column_no
yyscan_t
yyscanner
)
;
#
ifndef
YY_SKIP_YYWRAP
#
ifdef
__cplusplus
extern
"
C
"
int
layoutwrap
(
yyscan_t
yyscanner
)
;
#
else
extern
int
layoutwrap
(
yyscan_t
yyscanner
)
;
#
endif
#
endif
#
ifndef
YY_NO_UNPUT
static
void
yyunput
(
int
c
char
*
buf_ptr
yyscan_t
yyscanner
)
;
#
endif
#
ifndef
yytext_ptr
static
void
yy_flex_strncpy
(
char
*
const
char
*
int
yyscan_t
yyscanner
)
;
#
endif
#
ifdef
YY_NEED_STRLEN
static
int
yy_flex_strlen
(
const
char
*
yyscan_t
yyscanner
)
;
#
endif
#
ifndef
YY_NO_INPUT
#
ifdef
__cplusplus
static
int
yyinput
(
yyscan_t
yyscanner
)
;
#
else
static
int
input
(
yyscan_t
yyscanner
)
;
#
endif
#
endif
#
ifndef
YY_READ_BUF_SIZE
#
ifdef
__ia64__
#
define
YY_READ_BUF_SIZE
16384
#
else
#
define
YY_READ_BUF_SIZE
8192
#
endif
#
endif
#
ifndef
ECHO
#
define
ECHO
do
{
if
(
fwrite
(
yytext
(
size_t
)
yyleng
1
yyout
)
)
{
}
}
while
(
0
)
#
endif
#
ifndef
YY_INPUT
#
define
YY_INPUT
(
buf
result
max_size
)
\
if
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_is_interactive
)
\
{
\
int
c
=
'
*
'
;
\
int
n
;
\
for
(
n
=
0
;
n
<
max_size
&
&
\
(
c
=
getc
(
yyin
)
)
!
=
EOF
&
&
c
!
=
'
\
n
'
;
+
+
n
)
\
buf
[
n
]
=
(
char
)
c
;
\
if
(
c
=
=
'
\
n
'
)
\
buf
[
n
+
+
]
=
(
char
)
c
;
\
if
(
c
=
=
EOF
&
&
ferror
(
yyin
)
)
\
YY_FATAL_ERROR
(
"
input
in
flex
scanner
failed
"
)
;
\
result
=
n
;
\
}
\
else
\
{
\
errno
=
0
;
\
while
(
(
result
=
(
int
)
fread
(
buf
1
(
yy_size_t
)
max_size
yyin
)
)
=
=
0
&
&
ferror
(
yyin
)
)
\
{
\
if
(
errno
!
=
EINTR
)
\
{
\
YY_FATAL_ERROR
(
"
input
in
flex
scanner
failed
"
)
;
\
break
;
\
}
\
errno
=
0
;
\
clearerr
(
yyin
)
;
\
}
\
}
\
\
#
endif
#
ifndef
yyterminate
#
define
yyterminate
(
)
return
YY_NULL
#
endif
#
ifndef
YY_START_STACK_INCR
#
define
YY_START_STACK_INCR
25
#
endif
#
ifndef
YY_FATAL_ERROR
#
define
YY_FATAL_ERROR
(
msg
)
yy_fatal_error
(
msg
yyscanner
)
#
endif
#
ifndef
YY_DECL
#
define
YY_DECL_IS_OURS
1
extern
int
layoutlex
(
yyscan_t
yyscanner
)
;
#
define
YY_DECL
int
layoutlex
(
yyscan_t
yyscanner
)
#
endif
#
ifndef
YY_USER_ACTION
#
define
YY_USER_ACTION
#
endif
#
ifndef
YY_BREAK
#
define
YY_BREAKbreak
;
#
endif
#
define
YY_RULE_SETUP
\
YY_USER_ACTION
YY_DECL
{
yy_state_type
yy_current_state
;
char
*
yy_cp
*
yy_bp
;
int
yy_act
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
yyg
-
>
yy_init
)
{
yyg
-
>
yy_init
=
1
;
#
ifdef
YY_USER_INIT
YY_USER_INIT
;
#
endif
if
(
!
yyg
-
>
yy_start
)
yyg
-
>
yy_start
=
1
;
if
(
!
yyin
)
yyin
=
stdin
;
if
(
!
yyout
)
yyout
=
stdout
;
if
(
!
YY_CURRENT_BUFFER
)
{
layoutensure_buffer_stack
(
yyscanner
)
;
YY_CURRENT_BUFFER_LVALUE
=
layout_create_buffer
(
yyin
YY_BUF_SIZE
yyscanner
)
;
}
layout_load_buffer_state
(
yyscanner
)
;
}
{
#
line
32
"
layout
.
flex
"
#
line
912
"
lex
.
layout
.
c
"
while
(
1
)
{
yy_cp
=
yyg
-
>
yy_c_buf_p
;
*
yy_cp
=
yyg
-
>
yy_hold_char
;
yy_bp
=
yy_cp
;
yy_current_state
=
yyg
-
>
yy_start
;
yy_match
:
do
{
YY_CHAR
yy_c
=
yy_ec
[
YY_SC_TO_UI
(
*
yy_cp
)
]
;
if
(
yy_accept
[
yy_current_state
]
)
{
yyg
-
>
yy_last_accepting_state
=
yy_current_state
;
yyg
-
>
yy_last_accepting_cpos
=
yy_cp
;
}
while
(
yy_chk
[
yy_base
[
yy_current_state
]
+
yy_c
]
!
=
yy_current_state
)
{
yy_current_state
=
(
int
)
yy_def
[
yy_current_state
]
;
if
(
yy_current_state
>
=
204
)
yy_c
=
yy_meta
[
yy_c
]
;
}
yy_current_state
=
yy_nxt
[
yy_base
[
yy_current_state
]
+
yy_c
]
;
+
+
yy_cp
;
}
while
(
yy_current_state
!
=
203
)
;
yy_cp
=
yyg
-
>
yy_last_accepting_cpos
;
yy_current_state
=
yyg
-
>
yy_last_accepting_state
;
yy_find_action
:
yy_act
=
yy_accept
[
yy_current_state
]
;
YY_DO_BEFORE_ACTION
;
if
(
yy_act
!
=
YY_END_OF_BUFFER
&
&
yy_rule_can_match_eol
[
yy_act
]
)
{
int
yyl
;
for
(
yyl
=
0
;
yyl
<
yyleng
;
+
+
yyl
)
if
(
yytext
[
yyl
]
=
=
'
\
n
'
)
do
{
yylineno
+
+
;
yycolumn
=
0
;
}
while
(
0
)
;
}
do_action
:
switch
(
yy_act
)
{
case
0
:
*
yy_cp
=
yyg
-
>
yy_hold_char
;
yy_cp
=
yyg
-
>
yy_last_accepting_cpos
;
yy_current_state
=
yyg
-
>
yy_last_accepting_state
;
goto
yy_find_action
;
case
1
:
YY_RULE_SETUP
#
line
34
"
layout
.
flex
"
{
return
SkSL
:
:
Token
:
:
LOCATION
;
}
YY_BREAK
case
2
:
YY_RULE_SETUP
#
line
35
"
layout
.
flex
"
{
return
SkSL
:
:
Token
:
:
OFFSET
;
}
YY_BREAK
case
3
:
YY_RULE_SETUP
#
line
36
"
layout
.
flex
"
{
return
SkSL
:
:
Token
:
:
BINDING
;
}
YY_BREAK
case
4
:
YY_RULE_SETUP
#
line
37
"
layout
.
flex
"
{
return
SkSL
:
:
Token
:
:
INDEX
;
}
YY_BREAK
case
5
:
YY_RULE_SETUP
#
line
38
"
layout
.
flex
"
{
return
SkSL
:
:
Token
:
:
SET
;
}
YY_BREAK
case
6
:
YY_RULE_SETUP
#
line
39
"
layout
.
flex
"
{
return
SkSL
:
:
Token
:
:
BUILTIN
;
}
YY_BREAK
case
7
:
YY_RULE_SETUP
#
line
40
"
layout
.
flex
"
{
return
SkSL
:
:
Token
:
:
INPUT_ATTACHMENT_INDEX
;
}
YY_BREAK
case
8
:
YY_RULE_SETUP
#
line
41
"
layout
.
flex
"
{
return
SkSL
:
:
Token
:
:
ORIGIN_UPPER_LEFT
;
}
YY_BREAK
case
9
:
YY_RULE_SETUP
#
line
42
"
layout
.
flex
"
{
return
SkSL
:
:
Token
:
:
OVERRIDE_COVERAGE
;
}
YY_BREAK
case
10
:
YY_RULE_SETUP
#
line
43
"
layout
.
flex
"
{
return
SkSL
:
:
Token
:
:
BLEND_SUPPORT_ALL_EQUATIONS
;
}
YY_BREAK
case
11
:
YY_RULE_SETUP
#
line
44
"
layout
.
flex
"
{
return
SkSL
:
:
Token
:
:
PUSH_CONSTANT
;
}
YY_BREAK
case
12
:
YY_RULE_SETUP
#
line
45
"
layout
.
flex
"
{
return
SkSL
:
:
Token
:
:
POINTS
;
}
YY_BREAK
case
13
:
YY_RULE_SETUP
#
line
46
"
layout
.
flex
"
{
return
SkSL
:
:
Token
:
:
LINES
;
}
YY_BREAK
case
14
:
YY_RULE_SETUP
#
line
47
"
layout
.
flex
"
{
return
SkSL
:
:
Token
:
:
LINE_STRIP
;
}
YY_BREAK
case
15
:
YY_RULE_SETUP
#
line
48
"
layout
.
flex
"
{
return
SkSL
:
:
Token
:
:
LINES_ADJACENCY
;
}
YY_BREAK
case
16
:
YY_RULE_SETUP
#
line
49
"
layout
.
flex
"
{
return
SkSL
:
:
Token
:
:
TRIANGLES
;
}
YY_BREAK
case
17
:
YY_RULE_SETUP
#
line
50
"
layout
.
flex
"
{
return
SkSL
:
:
Token
:
:
TRIANGLE_STRIP
;
}
YY_BREAK
case
18
:
YY_RULE_SETUP
#
line
51
"
layout
.
flex
"
{
return
SkSL
:
:
Token
:
:
TRIANGLES_ADJACENCY
;
}
YY_BREAK
case
19
:
YY_RULE_SETUP
#
line
52
"
layout
.
flex
"
{
return
SkSL
:
:
Token
:
:
MAX_VERTICES
;
}
YY_BREAK
case
20
:
YY_RULE_SETUP
#
line
53
"
layout
.
flex
"
{
return
SkSL
:
:
Token
:
:
INVOCATIONS
;
}
YY_BREAK
case
21
:
YY_RULE_SETUP
#
line
55
"
layout
.
flex
"
{
return
SkSL
:
:
Token
:
:
INVALID_TOKEN
;
}
YY_BREAK
case
22
:
YY_RULE_SETUP
#
line
57
"
layout
.
flex
"
ECHO
;
YY_BREAK
#
line
1087
"
lex
.
layout
.
c
"
case
YY_STATE_EOF
(
INITIAL
)
:
yyterminate
(
)
;
case
YY_END_OF_BUFFER
:
{
int
yy_amount_of_matched_text
=
(
int
)
(
yy_cp
-
yyg
-
>
yytext_ptr
)
-
1
;
*
yy_cp
=
yyg
-
>
yy_hold_char
;
YY_RESTORE_YY_MORE_OFFSET
if
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buffer_status
=
=
YY_BUFFER_NEW
)
{
yyg
-
>
yy_n_chars
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_input_file
=
yyin
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buffer_status
=
YY_BUFFER_NORMAL
;
}
if
(
yyg
-
>
yy_c_buf_p
<
=
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
]
)
{
yy_state_type
yy_next_state
;
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yytext_ptr
+
yy_amount_of_matched_text
;
yy_current_state
=
yy_get_previous_state
(
yyscanner
)
;
yy_next_state
=
yy_try_NUL_trans
(
yy_current_state
yyscanner
)
;
yy_bp
=
yyg
-
>
yytext_ptr
+
YY_MORE_ADJ
;
if
(
yy_next_state
)
{
yy_cp
=
+
+
yyg
-
>
yy_c_buf_p
;
yy_current_state
=
yy_next_state
;
goto
yy_match
;
}
else
{
yy_cp
=
yyg
-
>
yy_last_accepting_cpos
;
yy_current_state
=
yyg
-
>
yy_last_accepting_state
;
goto
yy_find_action
;
}
}
else
switch
(
yy_get_next_buffer
(
yyscanner
)
)
{
case
EOB_ACT_END_OF_FILE
:
{
yyg
-
>
yy_did_buffer_switch_on_eof
=
0
;
if
(
layoutwrap
(
yyscanner
)
)
{
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yytext_ptr
+
YY_MORE_ADJ
;
yy_act
=
YY_STATE_EOF
(
YY_START
)
;
goto
do_action
;
}
else
{
if
(
!
yyg
-
>
yy_did_buffer_switch_on_eof
)
YY_NEW_FILE
;
}
break
;
}
case
EOB_ACT_CONTINUE_SCAN
:
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yytext_ptr
+
yy_amount_of_matched_text
;
yy_current_state
=
yy_get_previous_state
(
yyscanner
)
;
yy_cp
=
yyg
-
>
yy_c_buf_p
;
yy_bp
=
yyg
-
>
yytext_ptr
+
YY_MORE_ADJ
;
goto
yy_match
;
case
EOB_ACT_LAST_MATCH
:
yyg
-
>
yy_c_buf_p
=
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
]
;
yy_current_state
=
yy_get_previous_state
(
yyscanner
)
;
yy_cp
=
yyg
-
>
yy_c_buf_p
;
yy_bp
=
yyg
-
>
yytext_ptr
+
YY_MORE_ADJ
;
goto
yy_find_action
;
}
break
;
}
default
:
YY_FATAL_ERROR
(
"
fatal
flex
scanner
internal
error
-
-
no
action
found
"
)
;
}
}
}
}
static
int
yy_get_next_buffer
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
char
*
dest
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
;
char
*
source
=
yyg
-
>
yytext_ptr
;
int
number_to_move
i
;
int
ret_val
;
if
(
yyg
-
>
yy_c_buf_p
>
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
+
1
]
)
YY_FATAL_ERROR
(
"
fatal
flex
scanner
internal
error
-
-
end
of
buffer
missed
"
)
;
if
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_fill_buffer
=
=
0
)
{
if
(
yyg
-
>
yy_c_buf_p
-
yyg
-
>
yytext_ptr
-
YY_MORE_ADJ
=
=
1
)
{
return
EOB_ACT_END_OF_FILE
;
}
else
{
return
EOB_ACT_LAST_MATCH
;
}
}
number_to_move
=
(
int
)
(
yyg
-
>
yy_c_buf_p
-
yyg
-
>
yytext_ptr
-
1
)
;
for
(
i
=
0
;
i
<
number_to_move
;
+
+
i
)
*
(
dest
+
+
)
=
*
(
source
+
+
)
;
if
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buffer_status
=
=
YY_BUFFER_EOF_PENDING
)
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
=
yyg
-
>
yy_n_chars
=
0
;
else
{
int
num_to_read
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_size
-
number_to_move
-
1
;
while
(
num_to_read
<
=
0
)
{
YY_BUFFER_STATE
b
=
YY_CURRENT_BUFFER_LVALUE
;
int
yy_c_buf_p_offset
=
(
int
)
(
yyg
-
>
yy_c_buf_p
-
b
-
>
yy_ch_buf
)
;
if
(
b
-
>
yy_is_our_buffer
)
{
int
new_size
=
b
-
>
yy_buf_size
*
2
;
if
(
new_size
<
=
0
)
b
-
>
yy_buf_size
+
=
b
-
>
yy_buf_size
/
8
;
else
b
-
>
yy_buf_size
*
=
2
;
b
-
>
yy_ch_buf
=
(
char
*
)
layoutrealloc
(
(
void
*
)
b
-
>
yy_ch_buf
(
yy_size_t
)
(
b
-
>
yy_buf_size
+
2
)
yyscanner
)
;
}
else
b
-
>
yy_ch_buf
=
NULL
;
if
(
!
b
-
>
yy_ch_buf
)
YY_FATAL_ERROR
(
"
fatal
error
-
scanner
input
buffer
overflow
"
)
;
yyg
-
>
yy_c_buf_p
=
&
b
-
>
yy_ch_buf
[
yy_c_buf_p_offset
]
;
num_to_read
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_size
-
number_to_move
-
1
;
}
if
(
num_to_read
>
YY_READ_BUF_SIZE
)
num_to_read
=
YY_READ_BUF_SIZE
;
YY_INPUT
(
(
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
number_to_move
]
)
yyg
-
>
yy_n_chars
num_to_read
)
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
=
yyg
-
>
yy_n_chars
;
}
if
(
yyg
-
>
yy_n_chars
=
=
0
)
{
if
(
number_to_move
=
=
YY_MORE_ADJ
)
{
ret_val
=
EOB_ACT_END_OF_FILE
;
layoutrestart
(
yyin
yyscanner
)
;
}
else
{
ret_val
=
EOB_ACT_LAST_MATCH
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buffer_status
=
YY_BUFFER_EOF_PENDING
;
}
}
else
ret_val
=
EOB_ACT_CONTINUE_SCAN
;
if
(
(
yyg
-
>
yy_n_chars
+
number_to_move
)
>
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_size
)
{
int
new_size
=
yyg
-
>
yy_n_chars
+
number_to_move
+
(
yyg
-
>
yy_n_chars
>
>
1
)
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
=
(
char
*
)
layoutrealloc
(
(
void
*
)
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
(
yy_size_t
)
new_size
yyscanner
)
;
if
(
!
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
yy_get_next_buffer
(
)
"
)
;
}
yyg
-
>
yy_n_chars
+
=
number_to_move
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
]
=
YY_END_OF_BUFFER_CHAR
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
+
1
]
=
YY_END_OF_BUFFER_CHAR
;
yyg
-
>
yytext_ptr
=
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
0
]
;
return
ret_val
;
}
static
yy_state_type
yy_get_previous_state
(
yyscan_t
yyscanner
)
{
yy_state_type
yy_current_state
;
char
*
yy_cp
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yy_current_state
=
yyg
-
>
yy_start
;
for
(
yy_cp
=
yyg
-
>
yytext_ptr
+
YY_MORE_ADJ
;
yy_cp
<
yyg
-
>
yy_c_buf_p
;
+
+
yy_cp
)
{
YY_CHAR
yy_c
=
(
*
yy_cp
?
yy_ec
[
YY_SC_TO_UI
(
*
yy_cp
)
]
:
1
)
;
if
(
yy_accept
[
yy_current_state
]
)
{
yyg
-
>
yy_last_accepting_state
=
yy_current_state
;
yyg
-
>
yy_last_accepting_cpos
=
yy_cp
;
}
while
(
yy_chk
[
yy_base
[
yy_current_state
]
+
yy_c
]
!
=
yy_current_state
)
{
yy_current_state
=
(
int
)
yy_def
[
yy_current_state
]
;
if
(
yy_current_state
>
=
204
)
yy_c
=
yy_meta
[
yy_c
]
;
}
yy_current_state
=
yy_nxt
[
yy_base
[
yy_current_state
]
+
yy_c
]
;
}
return
yy_current_state
;
}
static
yy_state_type
yy_try_NUL_trans
(
yy_state_type
yy_current_state
yyscan_t
yyscanner
)
{
int
yy_is_jam
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
char
*
yy_cp
=
yyg
-
>
yy_c_buf_p
;
YY_CHAR
yy_c
=
1
;
if
(
yy_accept
[
yy_current_state
]
)
{
yyg
-
>
yy_last_accepting_state
=
yy_current_state
;
yyg
-
>
yy_last_accepting_cpos
=
yy_cp
;
}
while
(
yy_chk
[
yy_base
[
yy_current_state
]
+
yy_c
]
!
=
yy_current_state
)
{
yy_current_state
=
(
int
)
yy_def
[
yy_current_state
]
;
if
(
yy_current_state
>
=
204
)
yy_c
=
yy_meta
[
yy_c
]
;
}
yy_current_state
=
yy_nxt
[
yy_base
[
yy_current_state
]
+
yy_c
]
;
yy_is_jam
=
(
yy_current_state
=
=
203
)
;
(
void
)
yyg
;
return
yy_is_jam
?
0
:
yy_current_state
;
}
#
ifndef
YY_NO_UNPUT
static
void
yyunput
(
int
c
char
*
yy_bp
yyscan_t
yyscanner
)
{
char
*
yy_cp
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yy_cp
=
yyg
-
>
yy_c_buf_p
;
*
yy_cp
=
yyg
-
>
yy_hold_char
;
if
(
yy_cp
<
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
+
2
)
{
int
number_to_move
=
yyg
-
>
yy_n_chars
+
2
;
char
*
dest
=
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_size
+
2
]
;
char
*
source
=
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
number_to_move
]
;
while
(
source
>
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
)
*
-
-
dest
=
*
-
-
source
;
yy_cp
+
=
(
int
)
(
dest
-
source
)
;
yy_bp
+
=
(
int
)
(
dest
-
source
)
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
=
yyg
-
>
yy_n_chars
=
(
int
)
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_size
;
if
(
yy_cp
<
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
+
2
)
YY_FATAL_ERROR
(
"
flex
scanner
push
-
back
overflow
"
)
;
}
*
-
-
yy_cp
=
(
char
)
c
;
if
(
c
=
=
'
\
n
'
)
{
-
-
yylineno
;
}
yyg
-
>
yytext_ptr
=
yy_bp
;
yyg
-
>
yy_hold_char
=
*
yy_cp
;
yyg
-
>
yy_c_buf_p
=
yy_cp
;
}
#
endif
#
ifndef
YY_NO_INPUT
#
ifdef
__cplusplus
static
int
yyinput
(
yyscan_t
yyscanner
)
#
else
static
int
input
(
yyscan_t
yyscanner
)
#
endif
{
int
c
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
*
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yy_hold_char
;
if
(
*
yyg
-
>
yy_c_buf_p
=
=
YY_END_OF_BUFFER_CHAR
)
{
if
(
yyg
-
>
yy_c_buf_p
<
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
]
)
*
yyg
-
>
yy_c_buf_p
=
'
\
0
'
;
else
{
int
offset
=
(
int
)
(
yyg
-
>
yy_c_buf_p
-
yyg
-
>
yytext_ptr
)
;
+
+
yyg
-
>
yy_c_buf_p
;
switch
(
yy_get_next_buffer
(
yyscanner
)
)
{
case
EOB_ACT_LAST_MATCH
:
layoutrestart
(
yyin
yyscanner
)
;
case
EOB_ACT_END_OF_FILE
:
{
if
(
layoutwrap
(
yyscanner
)
)
return
0
;
if
(
!
yyg
-
>
yy_did_buffer_switch_on_eof
)
YY_NEW_FILE
;
#
ifdef
__cplusplus
return
yyinput
(
yyscanner
)
;
#
else
return
input
(
yyscanner
)
;
#
endif
}
case
EOB_ACT_CONTINUE_SCAN
:
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yytext_ptr
+
offset
;
break
;
}
}
}
c
=
*
(
unsigned
char
*
)
yyg
-
>
yy_c_buf_p
;
*
yyg
-
>
yy_c_buf_p
=
'
\
0
'
;
yyg
-
>
yy_hold_char
=
*
+
+
yyg
-
>
yy_c_buf_p
;
if
(
c
=
=
'
\
n
'
)
do
{
yylineno
+
+
;
yycolumn
=
0
;
}
while
(
0
)
;
return
c
;
}
#
endif
void
layoutrestart
(
FILE
*
input_file
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
{
layoutensure_buffer_stack
(
yyscanner
)
;
YY_CURRENT_BUFFER_LVALUE
=
layout_create_buffer
(
yyin
YY_BUF_SIZE
yyscanner
)
;
}
layout_init_buffer
(
YY_CURRENT_BUFFER
input_file
yyscanner
)
;
layout_load_buffer_state
(
yyscanner
)
;
}
void
layout_switch_to_buffer
(
YY_BUFFER_STATE
new_buffer
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
layoutensure_buffer_stack
(
yyscanner
)
;
if
(
YY_CURRENT_BUFFER
=
=
new_buffer
)
return
;
if
(
YY_CURRENT_BUFFER
)
{
*
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yy_hold_char
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_pos
=
yyg
-
>
yy_c_buf_p
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
=
yyg
-
>
yy_n_chars
;
}
YY_CURRENT_BUFFER_LVALUE
=
new_buffer
;
layout_load_buffer_state
(
yyscanner
)
;
yyg
-
>
yy_did_buffer_switch_on_eof
=
1
;
}
static
void
layout_load_buffer_state
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yyg
-
>
yy_n_chars
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
;
yyg
-
>
yytext_ptr
=
yyg
-
>
yy_c_buf_p
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_pos
;
yyin
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_input_file
;
yyg
-
>
yy_hold_char
=
*
yyg
-
>
yy_c_buf_p
;
}
YY_BUFFER_STATE
layout_create_buffer
(
FILE
*
file
int
size
yyscan_t
yyscanner
)
{
YY_BUFFER_STATE
b
;
b
=
(
YY_BUFFER_STATE
)
layoutalloc
(
sizeof
(
struct
yy_buffer_state
)
yyscanner
)
;
if
(
!
b
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
layout_create_buffer
(
)
"
)
;
b
-
>
yy_buf_size
=
size
;
b
-
>
yy_ch_buf
=
(
char
*
)
layoutalloc
(
(
yy_size_t
)
(
b
-
>
yy_buf_size
+
2
)
yyscanner
)
;
if
(
!
b
-
>
yy_ch_buf
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
layout_create_buffer
(
)
"
)
;
b
-
>
yy_is_our_buffer
=
1
;
layout_init_buffer
(
b
file
yyscanner
)
;
return
b
;
}
void
layout_delete_buffer
(
YY_BUFFER_STATE
b
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
b
)
return
;
if
(
b
=
=
YY_CURRENT_BUFFER
)
YY_CURRENT_BUFFER_LVALUE
=
(
YY_BUFFER_STATE
)
0
;
if
(
b
-
>
yy_is_our_buffer
)
layoutfree
(
(
void
*
)
b
-
>
yy_ch_buf
yyscanner
)
;
layoutfree
(
(
void
*
)
b
yyscanner
)
;
}
static
void
layout_init_buffer
(
YY_BUFFER_STATE
b
FILE
*
file
yyscan_t
yyscanner
)
{
int
oerrno
=
errno
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
layout_flush_buffer
(
b
yyscanner
)
;
b
-
>
yy_input_file
=
file
;
b
-
>
yy_fill_buffer
=
1
;
if
(
b
!
=
YY_CURRENT_BUFFER
)
{
b
-
>
yy_bs_lineno
=
1
;
b
-
>
yy_bs_column
=
0
;
}
b
-
>
yy_is_interactive
=
0
;
errno
=
oerrno
;
}
void
layout_flush_buffer
(
YY_BUFFER_STATE
b
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
b
)
return
;
b
-
>
yy_n_chars
=
0
;
b
-
>
yy_ch_buf
[
0
]
=
YY_END_OF_BUFFER_CHAR
;
b
-
>
yy_ch_buf
[
1
]
=
YY_END_OF_BUFFER_CHAR
;
b
-
>
yy_buf_pos
=
&
b
-
>
yy_ch_buf
[
0
]
;
b
-
>
yy_at_bol
=
1
;
b
-
>
yy_buffer_status
=
YY_BUFFER_NEW
;
if
(
b
=
=
YY_CURRENT_BUFFER
)
layout_load_buffer_state
(
yyscanner
)
;
}
void
layoutpush_buffer_state
(
YY_BUFFER_STATE
new_buffer
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
new_buffer
=
=
NULL
)
return
;
layoutensure_buffer_stack
(
yyscanner
)
;
if
(
YY_CURRENT_BUFFER
)
{
*
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yy_hold_char
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_pos
=
yyg
-
>
yy_c_buf_p
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
=
yyg
-
>
yy_n_chars
;
}
if
(
YY_CURRENT_BUFFER
)
yyg
-
>
yy_buffer_stack_top
+
+
;
YY_CURRENT_BUFFER_LVALUE
=
new_buffer
;
layout_load_buffer_state
(
yyscanner
)
;
yyg
-
>
yy_did_buffer_switch_on_eof
=
1
;
}
void
layoutpop_buffer_state
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
return
;
layout_delete_buffer
(
YY_CURRENT_BUFFER
yyscanner
)
;
YY_CURRENT_BUFFER_LVALUE
=
NULL
;
if
(
yyg
-
>
yy_buffer_stack_top
>
0
)
-
-
yyg
-
>
yy_buffer_stack_top
;
if
(
YY_CURRENT_BUFFER
)
{
layout_load_buffer_state
(
yyscanner
)
;
yyg
-
>
yy_did_buffer_switch_on_eof
=
1
;
}
}
static
void
layoutensure_buffer_stack
(
yyscan_t
yyscanner
)
{
yy_size_t
num_to_alloc
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
yyg
-
>
yy_buffer_stack
)
{
num_to_alloc
=
1
;
yyg
-
>
yy_buffer_stack
=
(
struct
yy_buffer_state
*
*
)
layoutalloc
(
num_to_alloc
*
sizeof
(
struct
yy_buffer_state
*
)
yyscanner
)
;
if
(
!
yyg
-
>
yy_buffer_stack
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
layoutensure_buffer_stack
(
)
"
)
;
memset
(
yyg
-
>
yy_buffer_stack
0
num_to_alloc
*
sizeof
(
struct
yy_buffer_state
*
)
)
;
yyg
-
>
yy_buffer_stack_max
=
num_to_alloc
;
yyg
-
>
yy_buffer_stack_top
=
0
;
return
;
}
if
(
yyg
-
>
yy_buffer_stack_top
>
=
(
yyg
-
>
yy_buffer_stack_max
)
-
1
)
{
yy_size_t
grow_size
=
8
;
num_to_alloc
=
yyg
-
>
yy_buffer_stack_max
+
grow_size
;
yyg
-
>
yy_buffer_stack
=
(
struct
yy_buffer_state
*
*
)
layoutrealloc
(
yyg
-
>
yy_buffer_stack
num_to_alloc
*
sizeof
(
struct
yy_buffer_state
*
)
yyscanner
)
;
if
(
!
yyg
-
>
yy_buffer_stack
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
layoutensure_buffer_stack
(
)
"
)
;
memset
(
yyg
-
>
yy_buffer_stack
+
yyg
-
>
yy_buffer_stack_max
0
grow_size
*
sizeof
(
struct
yy_buffer_state
*
)
)
;
yyg
-
>
yy_buffer_stack_max
=
num_to_alloc
;
}
}
YY_BUFFER_STATE
layout_scan_buffer
(
char
*
base
yy_size_t
size
yyscan_t
yyscanner
)
{
YY_BUFFER_STATE
b
;
if
(
size
<
2
|
|
base
[
size
-
2
]
!
=
YY_END_OF_BUFFER_CHAR
|
|
base
[
size
-
1
]
!
=
YY_END_OF_BUFFER_CHAR
)
return
NULL
;
b
=
(
YY_BUFFER_STATE
)
layoutalloc
(
sizeof
(
struct
yy_buffer_state
)
yyscanner
)
;
if
(
!
b
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
layout_scan_buffer
(
)
"
)
;
b
-
>
yy_buf_size
=
(
int
)
(
size
-
2
)
;
b
-
>
yy_buf_pos
=
b
-
>
yy_ch_buf
=
base
;
b
-
>
yy_is_our_buffer
=
0
;
b
-
>
yy_input_file
=
NULL
;
b
-
>
yy_n_chars
=
b
-
>
yy_buf_size
;
b
-
>
yy_is_interactive
=
0
;
b
-
>
yy_at_bol
=
1
;
b
-
>
yy_fill_buffer
=
0
;
b
-
>
yy_buffer_status
=
YY_BUFFER_NEW
;
layout_switch_to_buffer
(
b
yyscanner
)
;
return
b
;
}
YY_BUFFER_STATE
layout_scan_string
(
const
char
*
yystr
yyscan_t
yyscanner
)
{
return
layout_scan_bytes
(
yystr
(
int
)
strlen
(
yystr
)
yyscanner
)
;
}
YY_BUFFER_STATE
layout_scan_bytes
(
const
char
*
yybytes
int
_yybytes_len
yyscan_t
yyscanner
)
{
YY_BUFFER_STATE
b
;
char
*
buf
;
yy_size_t
n
;
int
i
;
n
=
(
yy_size_t
)
(
_yybytes_len
+
2
)
;
buf
=
(
char
*
)
layoutalloc
(
n
yyscanner
)
;
if
(
!
buf
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
layout_scan_bytes
(
)
"
)
;
for
(
i
=
0
;
i
<
_yybytes_len
;
+
+
i
)
buf
[
i
]
=
yybytes
[
i
]
;
buf
[
_yybytes_len
]
=
buf
[
_yybytes_len
+
1
]
=
YY_END_OF_BUFFER_CHAR
;
b
=
layout_scan_buffer
(
buf
n
yyscanner
)
;
if
(
!
b
)
YY_FATAL_ERROR
(
"
bad
buffer
in
layout_scan_bytes
(
)
"
)
;
b
-
>
yy_is_our_buffer
=
1
;
return
b
;
}
#
ifndef
YY_EXIT_FAILURE
#
define
YY_EXIT_FAILURE
2
#
endif
static
void
yynoreturn
yy_fatal_error
(
const
char
*
msg
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
(
void
)
yyg
;
(
void
)
fprintf
(
stderr
"
%
s
\
n
"
msg
)
;
exit
(
YY_EXIT_FAILURE
)
;
}
#
undef
yyless
#
define
yyless
(
n
)
\
do
\
{
\
/
*
Undo
effects
of
setting
up
yytext
.
*
/
\
int
yyless_macro_arg
=
(
n
)
;
\
YY_LESS_LINENO
(
yyless_macro_arg
)
;
\
yytext
[
yyleng
]
=
yyg
-
>
yy_hold_char
;
\
yyg
-
>
yy_c_buf_p
=
yytext
+
yyless_macro_arg
;
\
yyg
-
>
yy_hold_char
=
*
yyg
-
>
yy_c_buf_p
;
\
*
yyg
-
>
yy_c_buf_p
=
'
\
0
'
;
\
yyleng
=
yyless_macro_arg
;
\
}
\
while
(
0
)
YY_EXTRA_TYPE
layoutget_extra
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yyextra
;
}
int
layoutget_lineno
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
return
0
;
return
yylineno
;
}
int
layoutget_column
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
return
0
;
return
yycolumn
;
}
FILE
*
layoutget_in
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yyin
;
}
FILE
*
layoutget_out
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yyout
;
}
int
layoutget_leng
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yyleng
;
}
char
*
layoutget_text
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yytext
;
}
void
layoutset_extra
(
YY_EXTRA_TYPE
user_defined
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yyextra
=
user_defined
;
}
void
layoutset_lineno
(
int
_line_number
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
YY_FATAL_ERROR
(
"
layoutset_lineno
called
with
no
buffer
"
)
;
yylineno
=
_line_number
;
}
void
layoutset_column
(
int
_column_no
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
YY_FATAL_ERROR
(
"
layoutset_column
called
with
no
buffer
"
)
;
yycolumn
=
_column_no
;
}
void
layoutset_in
(
FILE
*
_in_str
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yyin
=
_in_str
;
}
void
layoutset_out
(
FILE
*
_out_str
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yyout
=
_out_str
;
}
int
layoutget_debug
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yy_flex_debug
;
}
void
layoutset_debug
(
int
_bdebug
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yy_flex_debug
=
_bdebug
;
}
int
layoutlex_init
(
yyscan_t
*
ptr_yy_globals
)
{
if
(
ptr_yy_globals
=
=
NULL
)
{
errno
=
EINVAL
;
return
1
;
}
*
ptr_yy_globals
=
(
yyscan_t
)
layoutalloc
(
sizeof
(
struct
yyguts_t
)
NULL
)
;
if
(
*
ptr_yy_globals
=
=
NULL
)
{
errno
=
ENOMEM
;
return
1
;
}
memset
(
*
ptr_yy_globals
0x00
sizeof
(
struct
yyguts_t
)
)
;
return
yy_init_globals
(
*
ptr_yy_globals
)
;
}
int
layoutlex_init_extra
(
YY_EXTRA_TYPE
yy_user_defined
yyscan_t
*
ptr_yy_globals
)
{
struct
yyguts_t
dummy_yyguts
;
layoutset_extra
(
yy_user_defined
&
dummy_yyguts
)
;
if
(
ptr_yy_globals
=
=
NULL
)
{
errno
=
EINVAL
;
return
1
;
}
*
ptr_yy_globals
=
(
yyscan_t
)
layoutalloc
(
sizeof
(
struct
yyguts_t
)
&
dummy_yyguts
)
;
if
(
*
ptr_yy_globals
=
=
NULL
)
{
errno
=
ENOMEM
;
return
1
;
}
memset
(
*
ptr_yy_globals
0x00
sizeof
(
struct
yyguts_t
)
)
;
layoutset_extra
(
yy_user_defined
*
ptr_yy_globals
)
;
return
yy_init_globals
(
*
ptr_yy_globals
)
;
}
static
int
yy_init_globals
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yyg
-
>
yy_buffer_stack
=
NULL
;
yyg
-
>
yy_buffer_stack_top
=
0
;
yyg
-
>
yy_buffer_stack_max
=
0
;
yyg
-
>
yy_c_buf_p
=
NULL
;
yyg
-
>
yy_init
=
0
;
yyg
-
>
yy_start
=
0
;
yyg
-
>
yy_start_stack_ptr
=
0
;
yyg
-
>
yy_start_stack_depth
=
0
;
yyg
-
>
yy_start_stack
=
NULL
;
#
ifdef
YY_STDINIT
yyin
=
stdin
;
yyout
=
stdout
;
#
else
yyin
=
NULL
;
yyout
=
NULL
;
#
endif
return
0
;
}
int
layoutlex_destroy
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
while
(
YY_CURRENT_BUFFER
)
{
layout_delete_buffer
(
YY_CURRENT_BUFFER
yyscanner
)
;
YY_CURRENT_BUFFER_LVALUE
=
NULL
;
layoutpop_buffer_state
(
yyscanner
)
;
}
layoutfree
(
yyg
-
>
yy_buffer_stack
yyscanner
)
;
yyg
-
>
yy_buffer_stack
=
NULL
;
layoutfree
(
yyg
-
>
yy_start_stack
yyscanner
)
;
yyg
-
>
yy_start_stack
=
NULL
;
yy_init_globals
(
yyscanner
)
;
layoutfree
(
yyscanner
yyscanner
)
;
yyscanner
=
NULL
;
return
0
;
}
#
ifndef
yytext_ptr
static
void
yy_flex_strncpy
(
char
*
s1
const
char
*
s2
int
n
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
(
void
)
yyg
;
int
i
;
for
(
i
=
0
;
i
<
n
;
+
+
i
)
s1
[
i
]
=
s2
[
i
]
;
}
#
endif
#
ifdef
YY_NEED_STRLEN
static
int
yy_flex_strlen
(
const
char
*
s
yyscan_t
yyscanner
)
{
int
n
;
for
(
n
=
0
;
s
[
n
]
;
+
+
n
)
;
return
n
;
}
#
endif
void
*
layoutalloc
(
yy_size_t
size
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
(
void
)
yyg
;
return
malloc
(
size
)
;
}
void
*
layoutrealloc
(
void
*
ptr
yy_size_t
size
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
(
void
)
yyg
;
return
realloc
(
ptr
size
)
;
}
void
layoutfree
(
void
*
ptr
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
(
void
)
yyg
;
free
(
(
char
*
)
ptr
)
;
}
#
define
YYTABLES_NAME
"
yytables
"
#
line
57
"
layout
.
flex
"
int
layoutwrap
(
yyscan_t
scanner
)
{
return
1
;
}
