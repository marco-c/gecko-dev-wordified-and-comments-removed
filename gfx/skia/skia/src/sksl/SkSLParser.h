#
ifndef
SKSL_PARSER
#
define
SKSL_PARSER
#
include
<
vector
>
#
include
<
memory
>
#
include
<
unordered_map
>
#
include
<
unordered_set
>
#
include
"
SkSLErrorReporter
.
h
"
#
include
"
ir
/
SkSLLayout
.
h
"
#
include
"
SkSLLexer
.
h
"
struct
yy_buffer_state
;
#
define
YY_TYPEDEF_YY_BUFFER_STATE
typedef
struct
yy_buffer_state
*
YY_BUFFER_STATE
;
namespace
SkSL
{
struct
ASTBlock
;
struct
ASTBreakStatement
;
struct
ASTContinueStatement
;
struct
ASTDeclaration
;
struct
ASTDiscardStatement
;
struct
ASTDoStatement
;
struct
ASTExpression
;
struct
ASTExpressionStatement
;
struct
ASTForStatement
;
struct
ASTIfStatement
;
struct
ASTInterfaceBlock
;
struct
ASTParameter
;
struct
ASTPrecision
;
struct
ASTReturnStatement
;
struct
ASTStatement
;
struct
ASTSuffix
;
struct
ASTSwitchCase
;
struct
ASTSwitchStatement
;
struct
ASTType
;
struct
ASTWhileStatement
;
struct
ASTVarDeclarations
;
struct
Modifiers
;
class
SymbolTable
;
class
Parser
{
public
:
enum
class
LayoutToken
{
LOCATION
OFFSET
BINDING
INDEX
SET
BUILTIN
INPUT_ATTACHMENT_INDEX
ORIGIN_UPPER_LEFT
OVERRIDE_COVERAGE
BLEND_SUPPORT_ALL_EQUATIONS
BLEND_SUPPORT_MULTIPLY
BLEND_SUPPORT_SCREEN
BLEND_SUPPORT_OVERLAY
BLEND_SUPPORT_DARKEN
BLEND_SUPPORT_LIGHTEN
BLEND_SUPPORT_COLORDODGE
BLEND_SUPPORT_COLORBURN
BLEND_SUPPORT_HARDLIGHT
BLEND_SUPPORT_SOFTLIGHT
BLEND_SUPPORT_DIFFERENCE
BLEND_SUPPORT_EXCLUSION
BLEND_SUPPORT_HSL_HUE
BLEND_SUPPORT_HSL_SATURATION
BLEND_SUPPORT_HSL_COLOR
BLEND_SUPPORT_HSL_LUMINOSITY
PUSH_CONSTANT
POINTS
LINES
LINE_STRIP
LINES_ADJACENCY
TRIANGLES
TRIANGLE_STRIP
TRIANGLES_ADJACENCY
MAX_VERTICES
INVOCATIONS
WHEN
KEY
TRACKED
CTYPE
GRCOLOR4F
SKPMCOLOR4F
SKRECT
SKIRECT
SKPMCOLOR
}
;
Parser
(
const
char
*
text
size_t
length
SymbolTable
&
types
ErrorReporter
&
errors
)
;
std
:
:
vector
<
std
:
:
unique_ptr
<
ASTDeclaration
>
>
file
(
)
;
StringFragment
text
(
Token
token
)
;
Position
position
(
Token
token
)
;
private
:
static
void
InitLayoutMap
(
)
;
Token
nextRawToken
(
)
;
Token
nextToken
(
)
;
void
pushback
(
Token
t
)
;
Token
peek
(
)
;
bool
checkNext
(
Token
:
:
Kind
kind
Token
*
result
=
nullptr
)
;
bool
expect
(
Token
:
:
Kind
kind
const
char
*
expected
Token
*
result
=
nullptr
)
;
bool
expect
(
Token
:
:
Kind
kind
String
expected
Token
*
result
=
nullptr
)
;
void
error
(
Token
token
String
msg
)
;
void
error
(
int
offset
String
msg
)
;
bool
isType
(
StringFragment
name
)
;
std
:
:
unique_ptr
<
ASTDeclaration
>
precision
(
)
;
std
:
:
unique_ptr
<
ASTDeclaration
>
directive
(
)
;
std
:
:
unique_ptr
<
ASTDeclaration
>
section
(
)
;
std
:
:
unique_ptr
<
ASTDeclaration
>
enumDeclaration
(
)
;
std
:
:
unique_ptr
<
ASTDeclaration
>
declaration
(
)
;
std
:
:
unique_ptr
<
ASTVarDeclarations
>
varDeclarations
(
)
;
std
:
:
unique_ptr
<
ASTType
>
structDeclaration
(
)
;
std
:
:
unique_ptr
<
ASTVarDeclarations
>
structVarDeclaration
(
Modifiers
modifiers
)
;
std
:
:
unique_ptr
<
ASTVarDeclarations
>
varDeclarationEnd
(
Modifiers
modifiers
std
:
:
unique_ptr
<
ASTType
>
type
StringFragment
name
)
;
std
:
:
unique_ptr
<
ASTParameter
>
parameter
(
)
;
int
layoutInt
(
)
;
StringFragment
layoutIdentifier
(
)
;
String
layoutCode
(
)
;
Layout
:
:
Key
layoutKey
(
)
;
Layout
:
:
CType
layoutCType
(
)
;
Layout
layout
(
)
;
Modifiers
modifiers
(
)
;
Modifiers
modifiersWithDefaults
(
int
defaultFlags
)
;
std
:
:
unique_ptr
<
ASTStatement
>
statement
(
)
;
std
:
:
unique_ptr
<
ASTType
>
type
(
)
;
std
:
:
unique_ptr
<
ASTDeclaration
>
interfaceBlock
(
Modifiers
mods
)
;
std
:
:
unique_ptr
<
ASTIfStatement
>
ifStatement
(
)
;
std
:
:
unique_ptr
<
ASTDoStatement
>
doStatement
(
)
;
std
:
:
unique_ptr
<
ASTWhileStatement
>
whileStatement
(
)
;
std
:
:
unique_ptr
<
ASTForStatement
>
forStatement
(
)
;
std
:
:
unique_ptr
<
ASTSwitchCase
>
switchCase
(
)
;
std
:
:
unique_ptr
<
ASTStatement
>
switchStatement
(
)
;
std
:
:
unique_ptr
<
ASTReturnStatement
>
returnStatement
(
)
;
std
:
:
unique_ptr
<
ASTBreakStatement
>
breakStatement
(
)
;
std
:
:
unique_ptr
<
ASTContinueStatement
>
continueStatement
(
)
;
std
:
:
unique_ptr
<
ASTDiscardStatement
>
discardStatement
(
)
;
std
:
:
unique_ptr
<
ASTBlock
>
block
(
)
;
std
:
:
unique_ptr
<
ASTExpressionStatement
>
expressionStatement
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
expression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
commaExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
assignmentExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
ternaryExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
logicalOrExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
logicalXorExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
logicalAndExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
bitwiseOrExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
bitwiseXorExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
bitwiseAndExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
equalityExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
relationalExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
shiftExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
additiveExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
multiplicativeExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
unaryExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
postfixExpression
(
)
;
std
:
:
unique_ptr
<
ASTSuffix
>
suffix
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
term
(
)
;
bool
intLiteral
(
int64_t
*
dest
)
;
bool
floatLiteral
(
double
*
dest
)
;
bool
boolLiteral
(
bool
*
dest
)
;
bool
identifier
(
StringFragment
*
dest
)
;
static
std
:
:
unordered_map
<
String
LayoutToken
>
*
layoutTokens
;
const
char
*
fText
;
Lexer
fLexer
;
YY_BUFFER_STATE
fBuffer
;
int
fDepth
=
0
;
Token
fPushback
;
SymbolTable
&
fTypes
;
ErrorReporter
&
fErrors
;
friend
class
AutoDepth
;
friend
class
HCodeGenerator
;
}
;
}
#
endif
