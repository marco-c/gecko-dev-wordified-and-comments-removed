#
ifndef
SKSL_PARSER
#
define
SKSL_PARSER
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
src
/
sksl
/
SkSLDefines
.
h
"
#
include
"
src
/
sksl
/
SkSLLexer
.
h
"
#
include
"
src
/
sksl
/
SkSLOperator
.
h
"
#
include
"
src
/
sksl
/
SkSLPosition
.
h
"
#
include
"
src
/
sksl
/
SkSLProgramSettings
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLLayout
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLModifiers
.
h
"
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
string_view
>
#
include
<
vector
>
namespace
SkSL
{
class
Compiler
;
class
ErrorReporter
;
class
Expression
;
class
FunctionDeclaration
;
struct
Module
;
struct
Program
;
class
ProgramElement
;
enum
class
ProgramKind
:
int8_t
;
class
Statement
;
class
SymbolTable
;
class
Type
;
class
VarDeclaration
;
class
Variable
;
class
Parser
{
public
:
Parser
(
Compiler
*
compiler
const
ProgramSettings
&
settings
ProgramKind
kind
std
:
:
unique_ptr
<
std
:
:
string
>
text
)
;
~
Parser
(
)
;
std
:
:
unique_ptr
<
Program
>
programInheritingFrom
(
const
Module
*
module
)
;
std
:
:
unique_ptr
<
Module
>
moduleInheritingFrom
(
const
Module
*
parentModule
)
;
std
:
:
string_view
text
(
Token
token
)
;
Position
position
(
Token
token
)
;
private
:
class
AutoDepth
;
class
AutoSymbolTable
;
class
Checkpoint
;
Token
nextRawToken
(
)
;
Token
nextToken
(
)
;
void
pushback
(
Token
t
)
;
Token
peek
(
)
;
bool
checkNext
(
Token
:
:
Kind
kind
Token
*
result
=
nullptr
)
;
bool
checkIdentifier
(
Token
*
result
=
nullptr
)
;
bool
expect
(
Token
:
:
Kind
kind
const
char
*
expected
Token
*
result
=
nullptr
)
;
bool
expect
(
Token
:
:
Kind
kind
std
:
:
string
expected
Token
*
result
=
nullptr
)
;
bool
expectIdentifier
(
Token
*
result
)
;
bool
expectNewline
(
)
;
void
error
(
Token
token
std
:
:
string_view
msg
)
;
void
error
(
Position
position
std
:
:
string_view
msg
)
;
Position
rangeFrom
(
Position
start
)
;
Position
rangeFrom
(
Token
start
)
;
void
declarations
(
)
;
bool
arraySize
(
SKSL_INT
*
outResult
)
;
void
directive
(
bool
allowVersion
)
;
void
extensionDirective
(
Position
start
)
;
void
versionDirective
(
Position
start
bool
allowVersion
)
;
bool
declaration
(
)
;
bool
functionDeclarationEnd
(
Position
start
Modifiers
&
modifiers
const
Type
*
returnType
const
Token
&
name
)
;
bool
prototypeFunction
(
SkSL
:
:
FunctionDeclaration
*
decl
)
;
bool
defineFunction
(
SkSL
:
:
FunctionDeclaration
*
decl
)
;
struct
VarDeclarationsPrefix
{
Position
fPosition
;
Modifiers
fModifiers
;
const
Type
*
fType
;
Token
fName
;
}
;
bool
varDeclarationsPrefix
(
VarDeclarationsPrefix
*
prefixData
)
;
std
:
:
unique_ptr
<
Statement
>
varDeclarationsOrExpressionStatement
(
)
;
std
:
:
unique_ptr
<
Statement
>
varDeclarations
(
)
;
const
Type
*
structDeclaration
(
)
;
void
structVarDeclaration
(
Position
start
const
Modifiers
&
modifiers
)
;
bool
allowUnsizedArrays
(
)
{
return
ProgramConfig
:
:
IsCompute
(
fKind
)
|
|
ProgramConfig
:
:
IsFragment
(
fKind
)
|
|
ProgramConfig
:
:
IsVertex
(
fKind
)
;
}
const
Type
*
arrayType
(
const
Type
*
base
int
count
Position
pos
)
;
const
Type
*
unsizedArrayType
(
const
Type
*
base
Position
pos
)
;
bool
parseArrayDimensions
(
Position
pos
const
Type
*
*
type
)
;
bool
parseInitializer
(
Position
pos
std
:
:
unique_ptr
<
Expression
>
*
initializer
)
;
void
addGlobalVarDeclaration
(
std
:
:
unique_ptr
<
SkSL
:
:
VarDeclaration
>
decl
)
;
void
globalVarDeclarationEnd
(
Position
position
const
Modifiers
&
mods
const
Type
*
baseType
Token
name
)
;
std
:
:
unique_ptr
<
Statement
>
localVarDeclarationEnd
(
Position
position
const
Modifiers
&
mods
const
Type
*
baseType
Token
name
)
;
bool
modifiersDeclarationEnd
(
const
Modifiers
&
mods
)
;
bool
parameter
(
std
:
:
unique_ptr
<
SkSL
:
:
Variable
>
*
outParam
)
;
int
layoutInt
(
)
;
std
:
:
string_view
layoutIdentifier
(
)
;
SkSL
:
:
Layout
layout
(
)
;
Modifiers
modifiers
(
)
;
std
:
:
unique_ptr
<
Statement
>
statementOrNop
(
Position
pos
std
:
:
unique_ptr
<
Statement
>
stmt
)
;
std
:
:
unique_ptr
<
Statement
>
statement
(
bool
bracesIntroduceNewScope
=
true
)
;
const
Type
*
findType
(
Position
pos
Modifiers
*
modifiers
std
:
:
string_view
name
)
;
const
Type
*
type
(
Modifiers
*
modifiers
)
;
bool
interfaceBlock
(
const
Modifiers
&
mods
)
;
std
:
:
unique_ptr
<
Statement
>
ifStatement
(
)
;
std
:
:
unique_ptr
<
Statement
>
doStatement
(
)
;
std
:
:
unique_ptr
<
Statement
>
whileStatement
(
)
;
std
:
:
unique_ptr
<
Statement
>
forStatement
(
)
;
bool
switchCaseBody
(
ExpressionArray
*
values
StatementArray
*
caseBlocks
std
:
:
unique_ptr
<
Expression
>
value
)
;
bool
switchCase
(
ExpressionArray
*
values
StatementArray
*
caseBlocks
)
;
std
:
:
unique_ptr
<
Statement
>
switchStatement
(
)
;
std
:
:
unique_ptr
<
Statement
>
returnStatement
(
)
;
std
:
:
unique_ptr
<
Statement
>
breakStatement
(
)
;
std
:
:
unique_ptr
<
Statement
>
continueStatement
(
)
;
std
:
:
unique_ptr
<
Statement
>
discardStatement
(
)
;
std
:
:
unique_ptr
<
Statement
>
block
(
bool
introduceNewScope
std
:
:
unique_ptr
<
SymbolTable
>
*
adoptExistingSymbolTable
)
;
std
:
:
unique_ptr
<
Statement
>
expressionStatement
(
)
;
using
BinaryParseFn
=
std
:
:
unique_ptr
<
Expression
>
(
Parser
:
:
*
)
(
)
;
[
[
nodiscard
]
]
bool
operatorRight
(
AutoDepth
&
depth
Operator
:
:
Kind
op
BinaryParseFn
rightFn
std
:
:
unique_ptr
<
Expression
>
&
expr
)
;
std
:
:
unique_ptr
<
Expression
>
poison
(
Position
pos
)
;
std
:
:
unique_ptr
<
Expression
>
expressionOrPoison
(
Position
pos
std
:
:
unique_ptr
<
Expression
>
expr
)
;
std
:
:
unique_ptr
<
Expression
>
expression
(
)
;
std
:
:
unique_ptr
<
Expression
>
assignmentExpression
(
)
;
std
:
:
unique_ptr
<
Expression
>
ternaryExpression
(
)
;
std
:
:
unique_ptr
<
Expression
>
logicalOrExpression
(
)
;
std
:
:
unique_ptr
<
Expression
>
logicalXorExpression
(
)
;
std
:
:
unique_ptr
<
Expression
>
logicalAndExpression
(
)
;
std
:
:
unique_ptr
<
Expression
>
bitwiseOrExpression
(
)
;
std
:
:
unique_ptr
<
Expression
>
bitwiseXorExpression
(
)
;
std
:
:
unique_ptr
<
Expression
>
bitwiseAndExpression
(
)
;
std
:
:
unique_ptr
<
Expression
>
equalityExpression
(
)
;
std
:
:
unique_ptr
<
Expression
>
relationalExpression
(
)
;
std
:
:
unique_ptr
<
Expression
>
shiftExpression
(
)
;
std
:
:
unique_ptr
<
Expression
>
additiveExpression
(
)
;
std
:
:
unique_ptr
<
Expression
>
multiplicativeExpression
(
)
;
std
:
:
unique_ptr
<
Expression
>
unaryExpression
(
)
;
std
:
:
unique_ptr
<
Expression
>
postfixExpression
(
)
;
std
:
:
unique_ptr
<
Expression
>
swizzle
(
Position
pos
std
:
:
unique_ptr
<
Expression
>
base
std
:
:
string_view
swizzleMask
Position
maskPos
)
;
std
:
:
unique_ptr
<
Expression
>
call
(
Position
pos
std
:
:
unique_ptr
<
Expression
>
base
ExpressionArray
args
)
;
std
:
:
unique_ptr
<
Expression
>
suffix
(
std
:
:
unique_ptr
<
Expression
>
base
)
;
std
:
:
unique_ptr
<
Expression
>
term
(
)
;
bool
intLiteral
(
SKSL_INT
*
dest
)
;
bool
floatLiteral
(
SKSL_FLOAT
*
dest
)
;
bool
boolLiteral
(
bool
*
dest
)
;
bool
identifier
(
std
:
:
string_view
*
dest
)
;
SymbolTable
*
symbolTable
(
)
;
Compiler
&
fCompiler
;
ProgramSettings
fSettings
;
ErrorReporter
*
fErrorReporter
;
bool
fEncounteredFatalError
;
ProgramKind
fKind
;
std
:
:
unique_ptr
<
std
:
:
string
>
fText
;
std
:
:
vector
<
std
:
:
unique_ptr
<
SkSL
:
:
ProgramElement
>
>
fProgramElements
;
Lexer
fLexer
;
int
fDepth
=
0
;
Token
fPushback
;
}
;
}
#
endif
