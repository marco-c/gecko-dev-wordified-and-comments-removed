#
ifndef
SKSL_PARSER
#
define
SKSL_PARSER
#
include
<
string
>
#
include
<
vector
>
#
include
<
memory
>
#
include
<
unordered_set
>
#
include
"
SkSLErrorReporter
.
h
"
#
include
"
SkSLToken
.
h
"
struct
yy_buffer_state
;
#
define
YY_TYPEDEF_YY_BUFFER_STATE
typedef
struct
yy_buffer_state
*
YY_BUFFER_STATE
;
namespace
SkSL
{
struct
ASTBlock
;
struct
ASTBreakStatement
;
struct
ASTContinueStatement
;
struct
ASTDeclaration
;
struct
ASTDiscardStatement
;
struct
ASTDoStatement
;
struct
ASTExpression
;
struct
ASTExpressionStatement
;
struct
ASTForStatement
;
struct
ASTIfStatement
;
struct
ASTInterfaceBlock
;
struct
ASTLayout
;
struct
ASTModifiers
;
struct
ASTParameter
;
struct
ASTReturnStatement
;
struct
ASTStatement
;
struct
ASTSuffix
;
struct
ASTType
;
struct
ASTWhileStatement
;
struct
ASTVarDeclarations
;
class
SymbolTable
;
class
Parser
{
public
:
Parser
(
std
:
:
string
text
SymbolTable
&
types
ErrorReporter
&
errors
)
;
~
Parser
(
)
;
std
:
:
vector
<
std
:
:
unique_ptr
<
ASTDeclaration
>
>
file
(
)
;
private
:
Token
nextToken
(
)
;
void
pushback
(
Token
t
)
;
Token
peek
(
)
;
bool
expect
(
Token
:
:
Kind
kind
std
:
:
string
expected
Token
*
result
=
nullptr
)
;
void
error
(
Position
p
std
:
:
string
msg
)
;
bool
isType
(
std
:
:
string
name
)
;
void
precision
(
)
;
std
:
:
unique_ptr
<
ASTDeclaration
>
directive
(
)
;
std
:
:
unique_ptr
<
ASTDeclaration
>
declaration
(
)
;
std
:
:
unique_ptr
<
ASTVarDeclarations
>
varDeclarations
(
)
;
std
:
:
unique_ptr
<
ASTType
>
structDeclaration
(
)
;
std
:
:
unique_ptr
<
ASTVarDeclarations
>
structVarDeclaration
(
ASTModifiers
modifiers
)
;
std
:
:
unique_ptr
<
ASTVarDeclarations
>
varDeclarationEnd
(
ASTModifiers
modifiers
std
:
:
unique_ptr
<
ASTType
>
type
std
:
:
string
name
)
;
std
:
:
unique_ptr
<
ASTParameter
>
parameter
(
)
;
int
layoutInt
(
)
;
ASTLayout
layout
(
)
;
ASTModifiers
modifiers
(
)
;
ASTModifiers
modifiersWithDefaults
(
int
defaultFlags
)
;
std
:
:
unique_ptr
<
ASTStatement
>
statement
(
)
;
std
:
:
unique_ptr
<
ASTType
>
type
(
)
;
std
:
:
unique_ptr
<
ASTDeclaration
>
interfaceBlock
(
ASTModifiers
mods
)
;
std
:
:
unique_ptr
<
ASTIfStatement
>
ifStatement
(
)
;
std
:
:
unique_ptr
<
ASTDoStatement
>
doStatement
(
)
;
std
:
:
unique_ptr
<
ASTWhileStatement
>
whileStatement
(
)
;
std
:
:
unique_ptr
<
ASTForStatement
>
forStatement
(
)
;
std
:
:
unique_ptr
<
ASTReturnStatement
>
returnStatement
(
)
;
std
:
:
unique_ptr
<
ASTBreakStatement
>
breakStatement
(
)
;
std
:
:
unique_ptr
<
ASTContinueStatement
>
continueStatement
(
)
;
std
:
:
unique_ptr
<
ASTDiscardStatement
>
discardStatement
(
)
;
std
:
:
unique_ptr
<
ASTBlock
>
block
(
)
;
std
:
:
unique_ptr
<
ASTExpressionStatement
>
expressionStatement
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
expression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
assignmentExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
ternaryExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
logicalOrExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
logicalXorExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
logicalAndExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
bitwiseOrExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
bitwiseXorExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
bitwiseAndExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
equalityExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
relationalExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
shiftExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
additiveExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
multiplicativeExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
unaryExpression
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
postfixExpression
(
)
;
std
:
:
unique_ptr
<
ASTSuffix
>
suffix
(
)
;
std
:
:
unique_ptr
<
ASTExpression
>
term
(
)
;
bool
intLiteral
(
int64_t
*
dest
)
;
bool
floatLiteral
(
double
*
dest
)
;
bool
boolLiteral
(
bool
*
dest
)
;
bool
identifier
(
std
:
:
string
*
dest
)
;
void
*
fScanner
;
YY_BUFFER_STATE
fBuffer
;
Token
fPushback
;
SymbolTable
&
fTypes
;
ErrorReporter
&
fErrors
;
}
;
}
#
endif
