#
ifndef
SKSL_JIT
#
define
SKSL_JIT
#
ifdef
SK_LLVM_AVAILABLE
#
include
"
ir
/
SkSLBinaryExpression
.
h
"
#
include
"
ir
/
SkSLBreakStatement
.
h
"
#
include
"
ir
/
SkSLContinueStatement
.
h
"
#
include
"
ir
/
SkSLExpression
.
h
"
#
include
"
ir
/
SkSLDoStatement
.
h
"
#
include
"
ir
/
SkSLForStatement
.
h
"
#
include
"
ir
/
SkSLFunctionCall
.
h
"
#
include
"
ir
/
SkSLFunctionDefinition
.
h
"
#
include
"
ir
/
SkSLIfStatement
.
h
"
#
include
"
ir
/
SkSLIndexExpression
.
h
"
#
include
"
ir
/
SkSLPrefixExpression
.
h
"
#
include
"
ir
/
SkSLPostfixExpression
.
h
"
#
include
"
ir
/
SkSLProgram
.
h
"
#
include
"
ir
/
SkSLReturnStatement
.
h
"
#
include
"
ir
/
SkSLStatement
.
h
"
#
include
"
ir
/
SkSLSwizzle
.
h
"
#
include
"
ir
/
SkSLTernaryExpression
.
h
"
#
include
"
ir
/
SkSLVarDeclarationsStatement
.
h
"
#
include
"
ir
/
SkSLVariableReference
.
h
"
#
include
"
ir
/
SkSLWhileStatement
.
h
"
#
include
"
llvm
-
c
/
Analysis
.
h
"
#
include
"
llvm
-
c
/
Core
.
h
"
#
include
"
llvm
-
c
/
OrcBindings
.
h
"
#
include
"
llvm
-
c
/
Support
.
h
"
#
include
"
llvm
-
c
/
Target
.
h
"
#
include
"
llvm
-
c
/
Transforms
/
PassManagerBuilder
.
h
"
#
include
"
llvm
-
c
/
Types
.
h
"
#
include
<
stack
>
class
SkRasterPipeline
;
namespace
SkSL
{
struct
AppendStage
;
class
JIT
{
typedef
int
StackIndex
;
public
:
class
Module
{
public
:
void
*
getSymbol
(
const
char
*
name
)
;
void
*
getJumperStage
(
const
char
*
name
)
;
~
Module
(
)
{
LLVMOrcDisposeSharedModuleRef
(
fSharedModule
)
;
}
private
:
Module
(
std
:
:
unique_ptr
<
Program
>
program
LLVMSharedModuleRef
sharedModule
LLVMOrcJITStackRef
jitStack
)
:
fProgram
(
std
:
:
move
(
program
)
)
fSharedModule
(
sharedModule
)
fJITStack
(
jitStack
)
{
}
std
:
:
unique_ptr
<
Program
>
fProgram
;
LLVMSharedModuleRef
fSharedModule
;
LLVMOrcJITStackRef
fJITStack
;
friend
class
JIT
;
}
;
JIT
(
Compiler
*
compiler
)
;
~
JIT
(
)
;
std
:
:
unique_ptr
<
Module
>
compile
(
std
:
:
unique_ptr
<
Program
>
program
)
;
private
:
static
constexpr
int
CHANNELS
=
4
;
enum
TypeKind
{
kFloat_TypeKind
kInt_TypeKind
kUInt_TypeKind
kBool_TypeKind
}
;
class
LValue
{
public
:
virtual
~
LValue
(
)
{
}
virtual
LLVMValueRef
load
(
LLVMBuilderRef
builder
)
=
0
;
virtual
void
store
(
LLVMBuilderRef
builder
LLVMValueRef
value
)
=
0
;
}
;
void
addBuiltinFunction
(
const
char
*
ourName
const
char
*
realName
LLVMTypeRef
returnType
std
:
:
vector
<
LLVMTypeRef
>
parameters
)
;
void
loadBuiltinFunctions
(
)
;
void
setBlock
(
LLVMBuilderRef
builder
LLVMBasicBlockRef
block
)
;
LLVMTypeRef
getType
(
const
Type
&
type
)
;
TypeKind
typeKind
(
const
Type
&
type
)
;
std
:
:
unique_ptr
<
LValue
>
getLValue
(
LLVMBuilderRef
builder
const
Expression
&
expr
)
;
void
vectorize
(
LLVMBuilderRef
builder
LLVMValueRef
*
value
int
columns
)
;
void
vectorize
(
LLVMBuilderRef
builder
const
BinaryExpression
&
b
LLVMValueRef
*
left
LLVMValueRef
*
right
)
;
LLVMValueRef
compileBinary
(
LLVMBuilderRef
builder
const
BinaryExpression
&
b
)
;
LLVMValueRef
compileConstructor
(
LLVMBuilderRef
builder
const
Constructor
&
c
)
;
LLVMValueRef
compileFunctionCall
(
LLVMBuilderRef
builder
const
FunctionCall
&
fc
)
;
LLVMValueRef
compileIndex
(
LLVMBuilderRef
builder
const
IndexExpression
&
v
)
;
LLVMValueRef
compilePostfix
(
LLVMBuilderRef
builder
const
PostfixExpression
&
p
)
;
LLVMValueRef
compilePrefix
(
LLVMBuilderRef
builder
const
PrefixExpression
&
p
)
;
LLVMValueRef
compileSwizzle
(
LLVMBuilderRef
builder
const
Swizzle
&
s
)
;
LLVMValueRef
compileVariableReference
(
LLVMBuilderRef
builder
const
VariableReference
&
v
)
;
LLVMValueRef
compileTernary
(
LLVMBuilderRef
builder
const
TernaryExpression
&
t
)
;
LLVMValueRef
compileExpression
(
LLVMBuilderRef
builder
const
Expression
&
expr
)
;
void
appendStage
(
LLVMBuilderRef
builder
const
AppendStage
&
a
)
;
void
compileBlock
(
LLVMBuilderRef
builder
const
Block
&
block
)
;
void
compileBreak
(
LLVMBuilderRef
builder
const
BreakStatement
&
b
)
;
void
compileContinue
(
LLVMBuilderRef
builder
const
ContinueStatement
&
c
)
;
void
compileDo
(
LLVMBuilderRef
builder
const
DoStatement
&
d
)
;
void
compileFor
(
LLVMBuilderRef
builder
const
ForStatement
&
f
)
;
void
compileIf
(
LLVMBuilderRef
builder
const
IfStatement
&
i
)
;
void
compileReturn
(
LLVMBuilderRef
builder
const
ReturnStatement
&
r
)
;
void
compileVarDeclarations
(
LLVMBuilderRef
builder
const
VarDeclarationsStatement
&
decls
)
;
void
compileWhile
(
LLVMBuilderRef
builder
const
WhileStatement
&
w
)
;
void
compileStatement
(
LLVMBuilderRef
builder
const
Statement
&
stmt
)
;
bool
compileVectorBinary
(
LLVMBuilderRef
builder
const
BinaryExpression
&
b
LLVMValueRef
out
[
CHANNELS
]
)
;
bool
compileVectorConstructor
(
LLVMBuilderRef
builder
const
Constructor
&
c
LLVMValueRef
out
[
CHANNELS
]
)
;
bool
compileVectorFloatLiteral
(
LLVMBuilderRef
builder
const
FloatLiteral
&
f
LLVMValueRef
out
[
CHANNELS
]
)
;
bool
compileVectorSwizzle
(
LLVMBuilderRef
builder
const
Swizzle
&
s
LLVMValueRef
out
[
CHANNELS
]
)
;
bool
compileVectorVariableReference
(
LLVMBuilderRef
builder
const
VariableReference
&
v
LLVMValueRef
out
[
CHANNELS
]
)
;
bool
compileVectorExpression
(
LLVMBuilderRef
builder
const
Expression
&
expr
LLVMValueRef
out
[
CHANNELS
]
)
;
bool
getVectorLValue
(
LLVMBuilderRef
builder
const
Expression
&
e
LLVMValueRef
out
[
CHANNELS
]
)
;
bool
getVectorBinaryOperands
(
LLVMBuilderRef
builder
const
Expression
&
left
LLVMValueRef
outLeft
[
CHANNELS
]
const
Expression
&
right
LLVMValueRef
outRight
[
CHANNELS
]
)
;
bool
compileVectorStatement
(
LLVMBuilderRef
builder
const
Statement
&
stmt
)
;
bool
hasStageSignature
(
const
FunctionDeclaration
&
f
)
;
bool
compileStageFunctionVector
(
const
FunctionDefinition
&
f
LLVMValueRef
newFunc
)
;
void
compileStageFunctionLoop
(
const
FunctionDefinition
&
f
LLVMValueRef
newFunc
)
;
LLVMValueRef
compileStageFunction
(
const
FunctionDefinition
&
f
)
;
LLVMValueRef
compileFunction
(
const
FunctionDefinition
&
f
)
;
void
createModule
(
)
;
void
optimize
(
)
;
bool
isColorRef
(
const
Expression
&
expr
)
;
static
uint64_t
resolveSymbol
(
const
char
*
name
JIT
*
jit
)
;
const
char
*
fCPU
;
int
fVectorCount
;
Compiler
&
fCompiler
;
std
:
:
unique_ptr
<
Program
>
fProgram
;
LLVMContextRef
fContext
;
LLVMModuleRef
fModule
;
LLVMSharedModuleRef
fSharedModule
;
LLVMOrcJITStackRef
fJITStack
;
LLVMValueRef
fCurrentFunction
;
LLVMBasicBlockRef
fAllocaBlock
;
LLVMBasicBlockRef
fCurrentBlock
;
LLVMTypeRef
fVoidType
;
LLVMTypeRef
fInt1Type
;
LLVMTypeRef
fInt1VectorType
;
LLVMTypeRef
fInt1Vector2Type
;
LLVMTypeRef
fInt1Vector3Type
;
LLVMTypeRef
fInt1Vector4Type
;
LLVMTypeRef
fInt8Type
;
LLVMTypeRef
fInt8PtrType
;
LLVMTypeRef
fInt32Type
;
LLVMTypeRef
fInt32VectorType
;
LLVMTypeRef
fInt32Vector2Type
;
LLVMTypeRef
fInt32Vector3Type
;
LLVMTypeRef
fInt32Vector4Type
;
LLVMTypeRef
fInt64Type
;
LLVMTypeRef
fSizeTType
;
LLVMTypeRef
fFloat32Type
;
LLVMTypeRef
fFloat32VectorType
;
LLVMTypeRef
fFloat32Vector2Type
;
LLVMTypeRef
fFloat32Vector3Type
;
LLVMTypeRef
fFloat32Vector4Type
;
LLVMValueRef
fChannels
[
CHANNELS
]
;
const
Variable
*
fColorParam
;
std
:
:
unordered_map
<
const
FunctionDeclaration
*
LLVMValueRef
>
fFunctions
;
std
:
:
unordered_map
<
const
Variable
*
LLVMValueRef
>
fVariables
;
std
:
:
set
<
const
Variable
*
>
fPromotedParameters
;
std
:
:
vector
<
LLVMBasicBlockRef
>
fBreakTarget
;
std
:
:
vector
<
LLVMBasicBlockRef
>
fContinueTarget
;
LLVMValueRef
fFoldAnd2Func
;
LLVMValueRef
fFoldOr2Func
;
LLVMValueRef
fFoldAnd3Func
;
LLVMValueRef
fFoldOr3Func
;
LLVMValueRef
fFoldAnd4Func
;
LLVMValueRef
fFoldOr4Func
;
LLVMValueRef
fAppendFunc
;
LLVMValueRef
fAppendCallbackFunc
;
LLVMValueRef
fDebugFunc
;
}
;
}
#
endif
#
endif
