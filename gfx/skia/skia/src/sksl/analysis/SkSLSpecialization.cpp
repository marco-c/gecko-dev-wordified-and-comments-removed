#
include
"
src
/
sksl
/
analysis
/
SkSLSpecialization
.
h
"
#
include
"
include
/
private
/
base
/
SkAssert
.
h
"
#
include
"
include
/
private
/
base
/
SkSpan_impl
.
h
"
#
include
"
src
/
sksl
/
SkSLAnalysis
.
h
"
#
include
"
src
/
sksl
/
SkSLDefines
.
h
"
#
include
"
src
/
sksl
/
analysis
/
SkSLProgramVisitor
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFieldAccess
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFunctionCall
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFunctionDeclaration
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFunctionDefinition
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLProgram
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLProgramElement
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLVariable
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLVariableReference
.
h
"
#
include
<
algorithm
>
#
include
<
memory
>
using
namespace
skia_private
;
namespace
SkSL
:
:
Analysis
{
static
bool
parameter_mappings_are_equal
(
const
SpecializedParameters
&
left
const
SpecializedParameters
&
right
)
{
if
(
left
.
count
(
)
!
=
right
.
count
(
)
)
{
return
false
;
}
for
(
const
auto
&
[
key
leftExpr
]
:
left
)
{
const
Expression
*
*
rightExpr
=
right
.
find
(
key
)
;
if
(
!
rightExpr
)
{
return
false
;
}
if
(
!
Analysis
:
:
IsSameExpressionTree
(
*
leftExpr
*
*
rightExpr
)
)
{
return
false
;
}
}
return
true
;
}
void
FindFunctionsToSpecialize
(
const
Program
&
program
SpecializationInfo
*
info
const
ParameterMatchesFn
&
parameterMatchesFn
)
{
class
Searcher
:
public
ProgramVisitor
{
public
:
using
ProgramVisitor
:
:
visitProgramElement
;
using
INHERITED
=
ProgramVisitor
;
Searcher
(
SpecializationInfo
&
info
const
ParameterMatchesFn
&
parameterMatchesFn
)
:
fSpecializationMap
(
info
.
fSpecializationMap
)
fSpecializedCallMap
(
info
.
fSpecializedCallMap
)
fParameterMatchesFn
(
parameterMatchesFn
)
{
}
bool
visitExpression
(
const
Expression
&
expr
)
override
{
if
(
expr
.
is
<
FunctionCall
>
(
)
)
{
const
FunctionCall
&
call
=
expr
.
as
<
FunctionCall
>
(
)
;
const
FunctionDeclaration
&
decl
=
call
.
function
(
)
;
if
(
!
decl
.
isIntrinsic
(
)
)
{
SpecializedParameters
specialization
;
const
int
numParams
=
decl
.
parameters
(
)
.
size
(
)
;
SkASSERT
(
call
.
arguments
(
)
.
size
(
)
=
=
numParams
)
;
for
(
int
i
=
0
;
i
<
numParams
;
i
+
+
)
{
const
Expression
&
arg
=
*
call
.
arguments
(
)
[
i
]
;
const
Variable
*
argBase
=
nullptr
;
if
(
arg
.
is
<
VariableReference
>
(
)
)
{
argBase
=
arg
.
as
<
VariableReference
>
(
)
.
variable
(
)
;
}
else
if
(
arg
.
is
<
FieldAccess
>
(
)
&
&
arg
.
as
<
FieldAccess
>
(
)
.
base
(
)
-
>
is
<
VariableReference
>
(
)
)
{
argBase
=
arg
.
as
<
FieldAccess
>
(
)
.
base
(
)
-
>
as
<
VariableReference
>
(
)
.
variable
(
)
;
}
else
{
continue
;
}
SkASSERT
(
argBase
)
;
const
Variable
*
param
=
decl
.
parameters
(
)
[
i
]
;
if
(
!
fParameterMatchesFn
(
*
param
)
)
{
continue
;
}
if
(
argBase
-
>
storage
(
)
=
=
Variable
:
:
Storage
:
:
kGlobal
)
{
specialization
[
param
]
=
&
arg
;
}
else
if
(
argBase
-
>
storage
(
)
=
=
Variable
:
:
Storage
:
:
kParameter
)
{
const
Expression
*
*
uniformExpr
=
fInheritedSpecializations
.
find
(
argBase
)
;
SkASSERT
(
uniformExpr
)
;
specialization
[
param
]
=
*
uniformExpr
;
}
else
{
SK_ABORT
(
"
Specialization
requires
a
uniform
or
parameter
variable
"
)
;
}
}
if
(
specialization
.
count
(
)
>
0
)
{
Specializations
&
specializations
=
fSpecializationMap
[
&
decl
]
;
SpecializedCallKey
callKey
{
call
.
stablePointer
(
)
fInheritedSpecializationIndex
}
;
for
(
int
i
=
0
;
i
<
specializations
.
size
(
)
;
i
+
+
)
{
const
SpecializedParameters
&
entry
=
specializations
[
i
]
;
if
(
parameter_mappings_are_equal
(
specialization
entry
)
)
{
fSpecializedCallMap
[
callKey
]
=
i
;
return
INHERITED
:
:
visitExpression
(
expr
)
;
}
}
SpecializationIndex
specializationIndex
=
specializations
.
size
(
)
;
fSpecializedCallMap
[
callKey
]
=
specializationIndex
;
specializations
.
push_back
(
specialization
)
;
fInheritedSpecializations
.
swap
(
specialization
)
;
std
:
:
swap
(
fInheritedSpecializationIndex
specializationIndex
)
;
this
-
>
visitProgramElement
(
*
decl
.
definition
(
)
)
;
std
:
:
swap
(
fInheritedSpecializationIndex
specializationIndex
)
;
fInheritedSpecializations
.
swap
(
specialization
)
;
}
else
{
if
(
!
fVisitedFunctions
.
find
(
&
decl
)
)
{
fVisitedFunctions
.
add
(
&
decl
)
;
this
-
>
visitProgramElement
(
*
decl
.
definition
(
)
)
;
}
}
}
}
return
INHERITED
:
:
visitExpression
(
expr
)
;
}
private
:
SpecializationMap
&
fSpecializationMap
;
SpecializedCallMap
&
fSpecializedCallMap
;
const
ParameterMatchesFn
&
fParameterMatchesFn
;
THashSet
<
const
FunctionDeclaration
*
>
fVisitedFunctions
;
SpecializedParameters
fInheritedSpecializations
;
SpecializationIndex
fInheritedSpecializationIndex
=
kUnspecialized
;
}
;
for
(
const
ProgramElement
*
elem
:
program
.
elements
(
)
)
{
if
(
elem
-
>
is
<
FunctionDefinition
>
(
)
)
{
const
FunctionDeclaration
&
decl
=
elem
-
>
as
<
FunctionDefinition
>
(
)
.
declaration
(
)
;
if
(
decl
.
isMain
(
)
)
{
Searcher
(
*
info
parameterMatchesFn
)
.
visitProgramElement
(
*
elem
)
;
continue
;
}
for
(
const
Variable
*
param
:
decl
.
parameters
(
)
)
{
if
(
parameterMatchesFn
(
*
param
)
)
{
info
-
>
fSpecializationMap
[
&
decl
]
;
break
;
}
}
}
}
}
SpecializationIndex
FindSpecializationIndexForCall
(
const
FunctionCall
&
call
const
SpecializationInfo
&
info
SpecializationIndex
parentSpecializationIndex
)
{
SpecializedCallKey
callKey
{
call
.
stablePointer
(
)
parentSpecializationIndex
}
;
SpecializationIndex
*
foundIndex
=
info
.
fSpecializedCallMap
.
find
(
callKey
)
;
return
foundIndex
?
*
foundIndex
:
kUnspecialized
;
}
SkBitSet
FindSpecializedParametersForFunction
(
const
FunctionDeclaration
&
func
const
SpecializationInfo
&
info
)
{
SkBitSet
result
(
func
.
parameters
(
)
.
size
(
)
)
;
if
(
const
Specializations
*
specializations
=
info
.
fSpecializationMap
.
find
(
&
func
)
)
{
const
Analysis
:
:
SpecializedParameters
&
specializedParams
=
specializations
-
>
front
(
)
;
const
SkSpan
<
Variable
*
const
>
funcParams
=
func
.
parameters
(
)
;
for
(
size_t
index
=
0
;
index
<
funcParams
.
size
(
)
;
+
+
index
)
{
if
(
specializedParams
.
find
(
funcParams
[
index
]
)
)
{
result
.
set
(
index
)
;
}
}
}
return
result
;
}
void
GetParameterMappingsForFunction
(
const
FunctionDeclaration
&
func
const
SpecializationInfo
&
info
SpecializationIndex
specializationIndex
const
ParameterMappingCallback
&
callback
)
{
if
(
specializationIndex
!
=
Analysis
:
:
kUnspecialized
)
{
if
(
const
Specializations
*
specializations
=
info
.
fSpecializationMap
.
find
(
&
func
)
)
{
const
Analysis
:
:
SpecializedParameters
&
specializedParams
=
specializations
-
>
at
(
specializationIndex
)
;
const
SkSpan
<
Variable
*
const
>
funcParams
=
func
.
parameters
(
)
;
for
(
size_t
index
=
0
;
index
<
funcParams
.
size
(
)
;
+
+
index
)
{
const
Variable
*
param
=
funcParams
[
index
]
;
if
(
const
Expression
*
*
expr
=
specializedParams
.
find
(
param
)
)
{
callback
(
index
param
*
expr
)
;
}
}
}
}
}
}
