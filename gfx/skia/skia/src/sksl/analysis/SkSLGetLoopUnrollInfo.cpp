#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
SkSLIRNode
.
h
"
#
include
"
include
/
private
/
SkSLStatement
.
h
"
#
include
"
include
/
private
/
base
/
SkFloatingPoint
.
h
"
#
include
"
include
/
sksl
/
SkSLErrorReporter
.
h
"
#
include
"
include
/
sksl
/
SkSLOperator
.
h
"
#
include
"
include
/
sksl
/
SkSLPosition
.
h
"
#
include
"
src
/
sksl
/
SkSLAnalysis
.
h
"
#
include
"
src
/
sksl
/
SkSLConstantFolder
.
h
"
#
include
"
src
/
sksl
/
analysis
/
SkSLNoOpErrorReporter
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLBinaryExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLForStatement
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLPostfixExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLPrefixExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLType
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLVarDeclarations
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLVariableReference
.
h
"
#
include
<
cmath
>
#
include
<
memory
>
namespace
SkSL
{
static
constexpr
int
kLoopTerminationLimit
=
100000
;
static
int
calculate_count
(
double
start
double
end
double
delta
bool
forwards
bool
inclusive
)
{
if
(
forwards
!
=
(
start
<
end
)
)
{
return
0
;
}
if
(
(
delta
=
=
0
.
0
)
|
|
forwards
!
=
(
delta
>
0
.
0
)
)
{
return
kLoopTerminationLimit
;
}
double
iterations
=
sk_ieee_double_divide
(
end
-
start
delta
)
;
double
count
=
std
:
:
ceil
(
iterations
)
;
if
(
inclusive
&
&
(
count
=
=
iterations
)
)
{
count
+
=
1
.
0
;
}
if
(
count
>
kLoopTerminationLimit
|
|
!
std
:
:
isfinite
(
count
)
)
{
return
kLoopTerminationLimit
;
}
return
(
int
)
count
;
}
std
:
:
unique_ptr
<
LoopUnrollInfo
>
Analysis
:
:
GetLoopUnrollInfo
(
Position
loopPos
const
ForLoopPositions
&
positions
const
Statement
*
loopInitializer
const
Expression
*
loopTest
const
Expression
*
loopNext
const
Statement
*
loopStatement
ErrorReporter
*
errorPtr
)
{
NoOpErrorReporter
unused
;
ErrorReporter
&
errors
=
errorPtr
?
*
errorPtr
:
unused
;
auto
loopInfo
=
std
:
:
make_unique
<
LoopUnrollInfo
>
(
)
;
if
(
!
loopInitializer
)
{
Position
pos
=
positions
.
initPosition
.
valid
(
)
?
positions
.
initPosition
:
loopPos
;
errors
.
error
(
pos
"
missing
init
declaration
"
)
;
return
nullptr
;
}
if
(
!
loopInitializer
-
>
is
<
VarDeclaration
>
(
)
)
{
errors
.
error
(
loopInitializer
-
>
fPosition
"
invalid
init
declaration
"
)
;
return
nullptr
;
}
const
VarDeclaration
&
initDecl
=
loopInitializer
-
>
as
<
VarDeclaration
>
(
)
;
if
(
!
initDecl
.
baseType
(
)
.
isNumber
(
)
)
{
errors
.
error
(
loopInitializer
-
>
fPosition
"
invalid
type
for
loop
index
"
)
;
return
nullptr
;
}
if
(
initDecl
.
arraySize
(
)
!
=
0
)
{
errors
.
error
(
loopInitializer
-
>
fPosition
"
invalid
type
for
loop
index
"
)
;
return
nullptr
;
}
if
(
!
initDecl
.
value
(
)
)
{
errors
.
error
(
loopInitializer
-
>
fPosition
"
missing
loop
index
initializer
"
)
;
return
nullptr
;
}
if
(
!
ConstantFolder
:
:
GetConstantValue
(
*
initDecl
.
value
(
)
&
loopInfo
-
>
fStart
)
)
{
errors
.
error
(
loopInitializer
-
>
fPosition
"
loop
index
initializer
must
be
a
constant
expression
"
)
;
return
nullptr
;
}
loopInfo
-
>
fIndex
=
initDecl
.
var
(
)
;
auto
is_loop_index
=
[
&
]
(
const
std
:
:
unique_ptr
<
Expression
>
&
expr
)
{
return
expr
-
>
is
<
VariableReference
>
(
)
&
&
expr
-
>
as
<
VariableReference
>
(
)
.
variable
(
)
=
=
loopInfo
-
>
fIndex
;
}
;
if
(
!
loopTest
)
{
Position
pos
=
positions
.
conditionPosition
.
valid
(
)
?
positions
.
conditionPosition
:
loopPos
;
errors
.
error
(
pos
"
missing
condition
"
)
;
return
nullptr
;
}
if
(
!
loopTest
-
>
is
<
BinaryExpression
>
(
)
)
{
errors
.
error
(
loopTest
-
>
fPosition
"
invalid
condition
"
)
;
return
nullptr
;
}
const
BinaryExpression
&
cond
=
loopTest
-
>
as
<
BinaryExpression
>
(
)
;
if
(
!
is_loop_index
(
cond
.
left
(
)
)
)
{
errors
.
error
(
loopTest
-
>
fPosition
"
expected
loop
index
on
left
hand
side
of
condition
"
)
;
return
nullptr
;
}
switch
(
cond
.
getOperator
(
)
.
kind
(
)
)
{
case
Operator
:
:
Kind
:
:
GT
:
case
Operator
:
:
Kind
:
:
GTEQ
:
case
Operator
:
:
Kind
:
:
LT
:
case
Operator
:
:
Kind
:
:
LTEQ
:
case
Operator
:
:
Kind
:
:
EQEQ
:
case
Operator
:
:
Kind
:
:
NEQ
:
break
;
default
:
errors
.
error
(
loopTest
-
>
fPosition
"
invalid
relational
operator
"
)
;
return
nullptr
;
}
double
loopEnd
=
0
;
if
(
!
ConstantFolder
:
:
GetConstantValue
(
*
cond
.
right
(
)
&
loopEnd
)
)
{
errors
.
error
(
loopTest
-
>
fPosition
"
loop
index
must
be
compared
with
a
constant
expression
"
)
;
return
nullptr
;
}
if
(
!
loopNext
)
{
Position
pos
=
positions
.
nextPosition
.
valid
(
)
?
positions
.
nextPosition
:
loopPos
;
errors
.
error
(
pos
"
missing
loop
expression
"
)
;
return
nullptr
;
}
switch
(
loopNext
-
>
kind
(
)
)
{
case
Expression
:
:
Kind
:
:
kBinary
:
{
const
BinaryExpression
&
next
=
loopNext
-
>
as
<
BinaryExpression
>
(
)
;
if
(
!
is_loop_index
(
next
.
left
(
)
)
)
{
errors
.
error
(
loopNext
-
>
fPosition
"
expected
loop
index
in
loop
expression
"
)
;
return
nullptr
;
}
if
(
!
ConstantFolder
:
:
GetConstantValue
(
*
next
.
right
(
)
&
loopInfo
-
>
fDelta
)
)
{
errors
.
error
(
loopNext
-
>
fPosition
"
loop
index
must
be
modified
by
a
constant
expression
"
)
;
return
nullptr
;
}
switch
(
next
.
getOperator
(
)
.
kind
(
)
)
{
case
Operator
:
:
Kind
:
:
PLUSEQ
:
break
;
case
Operator
:
:
Kind
:
:
MINUSEQ
:
loopInfo
-
>
fDelta
=
-
loopInfo
-
>
fDelta
;
break
;
default
:
errors
.
error
(
loopNext
-
>
fPosition
"
invalid
operator
in
loop
expression
"
)
;
return
nullptr
;
}
}
break
;
case
Expression
:
:
Kind
:
:
kPrefix
:
{
const
PrefixExpression
&
next
=
loopNext
-
>
as
<
PrefixExpression
>
(
)
;
if
(
!
is_loop_index
(
next
.
operand
(
)
)
)
{
errors
.
error
(
loopNext
-
>
fPosition
"
expected
loop
index
in
loop
expression
"
)
;
return
nullptr
;
}
switch
(
next
.
getOperator
(
)
.
kind
(
)
)
{
case
Operator
:
:
Kind
:
:
PLUSPLUS
:
loopInfo
-
>
fDelta
=
1
;
break
;
case
Operator
:
:
Kind
:
:
MINUSMINUS
:
loopInfo
-
>
fDelta
=
-
1
;
break
;
default
:
errors
.
error
(
loopNext
-
>
fPosition
"
invalid
operator
in
loop
expression
"
)
;
return
nullptr
;
}
}
break
;
case
Expression
:
:
Kind
:
:
kPostfix
:
{
const
PostfixExpression
&
next
=
loopNext
-
>
as
<
PostfixExpression
>
(
)
;
if
(
!
is_loop_index
(
next
.
operand
(
)
)
)
{
errors
.
error
(
loopNext
-
>
fPosition
"
expected
loop
index
in
loop
expression
"
)
;
return
nullptr
;
}
switch
(
next
.
getOperator
(
)
.
kind
(
)
)
{
case
Operator
:
:
Kind
:
:
PLUSPLUS
:
loopInfo
-
>
fDelta
=
1
;
break
;
case
Operator
:
:
Kind
:
:
MINUSMINUS
:
loopInfo
-
>
fDelta
=
-
1
;
break
;
default
:
errors
.
error
(
loopNext
-
>
fPosition
"
invalid
operator
in
loop
expression
"
)
;
return
nullptr
;
}
}
break
;
default
:
errors
.
error
(
loopNext
-
>
fPosition
"
invalid
loop
expression
"
)
;
return
nullptr
;
}
if
(
Analysis
:
:
StatementWritesToVariable
(
*
loopStatement
*
initDecl
.
var
(
)
)
)
{
errors
.
error
(
loopStatement
-
>
fPosition
"
loop
index
must
not
be
modified
within
body
of
the
loop
"
)
;
return
nullptr
;
}
loopInfo
-
>
fCount
=
0
;
switch
(
cond
.
getOperator
(
)
.
kind
(
)
)
{
case
Operator
:
:
Kind
:
:
LT
:
loopInfo
-
>
fCount
=
calculate_count
(
loopInfo
-
>
fStart
loopEnd
loopInfo
-
>
fDelta
true
false
)
;
break
;
case
Operator
:
:
Kind
:
:
GT
:
loopInfo
-
>
fCount
=
calculate_count
(
loopInfo
-
>
fStart
loopEnd
loopInfo
-
>
fDelta
false
false
)
;
break
;
case
Operator
:
:
Kind
:
:
LTEQ
:
loopInfo
-
>
fCount
=
calculate_count
(
loopInfo
-
>
fStart
loopEnd
loopInfo
-
>
fDelta
true
true
)
;
break
;
case
Operator
:
:
Kind
:
:
GTEQ
:
loopInfo
-
>
fCount
=
calculate_count
(
loopInfo
-
>
fStart
loopEnd
loopInfo
-
>
fDelta
false
true
)
;
break
;
case
Operator
:
:
Kind
:
:
NEQ
:
{
float
iterations
=
sk_ieee_double_divide
(
loopEnd
-
loopInfo
-
>
fStart
loopInfo
-
>
fDelta
)
;
loopInfo
-
>
fCount
=
std
:
:
ceil
(
iterations
)
;
if
(
loopInfo
-
>
fCount
<
0
|
|
loopInfo
-
>
fCount
!
=
iterations
|
|
!
std
:
:
isfinite
(
iterations
)
)
{
loopInfo
-
>
fCount
=
kLoopTerminationLimit
;
}
break
;
}
case
Operator
:
:
Kind
:
:
EQEQ
:
{
if
(
loopInfo
-
>
fStart
=
=
loopEnd
)
{
if
(
loopInfo
-
>
fDelta
)
{
loopInfo
-
>
fCount
=
1
;
}
else
{
loopInfo
-
>
fCount
=
kLoopTerminationLimit
;
}
}
else
{
loopInfo
-
>
fCount
=
0
;
}
break
;
}
default
:
SkUNREACHABLE
;
}
SkASSERT
(
loopInfo
-
>
fCount
>
=
0
)
;
if
(
loopInfo
-
>
fCount
>
=
kLoopTerminationLimit
)
{
errors
.
error
(
loopPos
"
loop
must
guarantee
termination
in
fewer
iterations
"
)
;
return
nullptr
;
}
return
loopInfo
;
}
}
