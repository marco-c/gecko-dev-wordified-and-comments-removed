#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
SkSLIRNode
.
h
"
#
include
"
include
/
private
/
SkSLProgramElement
.
h
"
#
include
"
include
/
private
/
SkSLStatement
.
h
"
#
include
"
include
/
sksl
/
SkSLErrorReporter
.
h
"
#
include
"
include
/
sksl
/
SkSLPosition
.
h
"
#
include
"
src
/
base
/
SkSafeMath
.
h
"
#
include
"
src
/
core
/
SkTHash
.
h
"
#
include
"
src
/
sksl
/
SkSLAnalysis
.
h
"
#
include
"
src
/
sksl
/
SkSLContext
.
h
"
#
include
"
src
/
sksl
/
analysis
/
SkSLProgramVisitor
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLForStatement
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFunctionCall
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFunctionDeclaration
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFunctionDefinition
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLProgram
.
h
"
#
include
<
cstddef
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
namespace
SkSL
{
bool
Analysis
:
:
CheckProgramStructure
(
const
Program
&
program
bool
enforceSizeLimit
)
{
const
Context
&
context
=
*
program
.
fContext
;
static
constexpr
size_t
kExpressionCost
=
1
;
static
constexpr
size_t
kStatementCost
=
1
;
static
constexpr
size_t
kUnknownCost
=
-
1
;
static
constexpr
size_t
kProgramSizeLimit
=
100000
;
static
constexpr
size_t
kProgramStackDepthLimit
=
50
;
class
ProgramSizeVisitor
:
public
ProgramVisitor
{
public
:
ProgramSizeVisitor
(
const
Context
&
c
)
:
fContext
(
c
)
{
}
using
ProgramVisitor
:
:
visitProgramElement
;
size_t
functionSize
(
)
const
{
return
fFunctionSize
;
}
bool
visitProgramElement
(
const
ProgramElement
&
pe
)
override
{
if
(
pe
.
is
<
FunctionDefinition
>
(
)
)
{
const
FunctionDeclaration
*
decl
=
&
pe
.
as
<
FunctionDefinition
>
(
)
.
declaration
(
)
;
if
(
size_t
*
cachedCost
=
fFunctionCostMap
.
find
(
decl
)
)
{
if
(
*
cachedCost
=
=
kUnknownCost
)
{
std
:
:
string
msg
=
"
\
n
\
t
"
+
decl
-
>
description
(
)
;
for
(
auto
unwind
=
fStack
.
rbegin
(
)
;
unwind
!
=
fStack
.
rend
(
)
;
+
+
unwind
)
{
msg
=
"
\
n
\
t
"
+
(
*
unwind
)
-
>
description
(
)
+
msg
;
if
(
*
unwind
=
=
decl
)
{
break
;
}
}
msg
=
"
potential
recursion
(
function
call
cycle
)
not
allowed
:
"
+
msg
;
fContext
.
fErrors
-
>
error
(
pe
.
fPosition
std
:
:
move
(
msg
)
)
;
fFunctionSize
=
0
;
*
cachedCost
=
0
;
return
true
;
}
fFunctionSize
=
*
cachedCost
;
return
false
;
}
if
(
fStack
.
size
(
)
>
=
kProgramStackDepthLimit
)
{
std
:
:
string
msg
=
"
exceeded
max
function
call
depth
:
"
;
for
(
auto
unwind
=
fStack
.
begin
(
)
;
unwind
!
=
fStack
.
end
(
)
;
+
+
unwind
)
{
msg
+
=
"
\
n
\
t
"
+
(
*
unwind
)
-
>
description
(
)
;
}
msg
+
=
"
\
n
\
t
"
+
decl
-
>
description
(
)
;
fContext
.
fErrors
-
>
error
(
pe
.
fPosition
std
:
:
move
(
msg
)
)
;
fFunctionSize
=
0
;
fFunctionCostMap
.
set
(
decl
0
)
;
return
true
;
}
fFunctionCostMap
.
set
(
decl
kUnknownCost
)
;
fStack
.
push_back
(
decl
)
;
fFunctionSize
=
0
;
bool
result
=
INHERITED
:
:
visitProgramElement
(
pe
)
;
fFunctionCostMap
.
set
(
decl
fFunctionSize
)
;
fStack
.
pop_back
(
)
;
return
result
;
}
return
INHERITED
:
:
visitProgramElement
(
pe
)
;
}
bool
visitStatement
(
const
Statement
&
stmt
)
override
{
switch
(
stmt
.
kind
(
)
)
{
case
Statement
:
:
Kind
:
:
kFor
:
{
bool
earlyExit
=
false
;
const
ForStatement
&
forStmt
=
stmt
.
as
<
ForStatement
>
(
)
;
if
(
forStmt
.
initializer
(
)
&
&
this
-
>
visitStatement
(
*
forStmt
.
initializer
(
)
)
)
{
earlyExit
=
true
;
}
size_t
originalFunctionSize
=
fFunctionSize
;
fFunctionSize
=
0
;
if
(
forStmt
.
next
(
)
&
&
this
-
>
visitExpression
(
*
forStmt
.
next
(
)
)
)
{
earlyExit
=
true
;
}
if
(
forStmt
.
test
(
)
&
&
this
-
>
visitExpression
(
*
forStmt
.
test
(
)
)
)
{
earlyExit
=
true
;
}
if
(
this
-
>
visitStatement
(
*
forStmt
.
statement
(
)
)
)
{
earlyExit
=
true
;
}
if
(
const
LoopUnrollInfo
*
unrollInfo
=
forStmt
.
unrollInfo
(
)
)
{
fFunctionSize
=
SkSafeMath
:
:
Mul
(
fFunctionSize
unrollInfo
-
>
fCount
)
;
}
fFunctionSize
=
SkSafeMath
:
:
Add
(
fFunctionSize
originalFunctionSize
)
;
return
earlyExit
;
}
case
Statement
:
:
Kind
:
:
kExpression
:
break
;
case
Statement
:
:
Kind
:
:
kNop
:
case
Statement
:
:
Kind
:
:
kVarDeclaration
:
break
;
default
:
fFunctionSize
=
SkSafeMath
:
:
Add
(
fFunctionSize
kStatementCost
)
;
break
;
}
return
INHERITED
:
:
visitStatement
(
stmt
)
;
}
bool
visitExpression
(
const
Expression
&
expr
)
override
{
bool
earlyExit
=
false
;
size_t
expressionCost
=
kExpressionCost
;
if
(
expr
.
is
<
FunctionCall
>
(
)
)
{
const
FunctionCall
&
call
=
expr
.
as
<
FunctionCall
>
(
)
;
const
FunctionDeclaration
*
decl
=
&
call
.
function
(
)
;
if
(
decl
-
>
definition
(
)
&
&
!
decl
-
>
isIntrinsic
(
)
)
{
size_t
originalFunctionSize
=
fFunctionSize
;
fFunctionSize
=
0
;
earlyExit
=
this
-
>
visitProgramElement
(
*
decl
-
>
definition
(
)
)
;
expressionCost
=
fFunctionSize
;
fFunctionSize
=
originalFunctionSize
;
}
}
fFunctionSize
=
SkSafeMath
:
:
Add
(
fFunctionSize
expressionCost
)
;
return
earlyExit
|
|
INHERITED
:
:
visitExpression
(
expr
)
;
}
private
:
using
INHERITED
=
ProgramVisitor
;
const
Context
&
fContext
;
size_t
fFunctionSize
=
0
;
SkTHashMap
<
const
FunctionDeclaration
*
size_t
>
fFunctionCostMap
;
std
:
:
vector
<
const
FunctionDeclaration
*
>
fStack
;
}
;
ProgramSizeVisitor
visitor
{
context
}
;
for
(
const
std
:
:
unique_ptr
<
ProgramElement
>
&
element
:
program
.
fOwnedElements
)
{
if
(
element
-
>
is
<
FunctionDefinition
>
(
)
)
{
visitor
.
visitProgramElement
(
*
element
)
;
if
(
enforceSizeLimit
&
&
visitor
.
functionSize
(
)
>
kProgramSizeLimit
&
&
element
-
>
as
<
FunctionDefinition
>
(
)
.
declaration
(
)
.
isMain
(
)
)
{
context
.
fErrors
-
>
error
(
Position
(
)
"
program
is
too
large
"
)
;
}
}
}
return
true
;
}
}
