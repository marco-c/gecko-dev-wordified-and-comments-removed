#
include
"
include
/
private
/
SkSLDefines
.
h
"
#
include
"
include
/
private
/
SkSLIRNode
.
h
"
#
include
"
include
/
private
/
SkSLStatement
.
h
"
#
include
"
src
/
sksl
/
SkSLAnalysis
.
h
"
#
include
"
src
/
sksl
/
analysis
/
SkSLProgramVisitor
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLDoStatement
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLForStatement
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFunctionDeclaration
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLIfStatement
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLSwitchCase
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLSwitchStatement
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLType
.
h
"
#
include
<
memory
>
namespace
SkSL
{
class
Expression
;
namespace
{
class
ReturnsOnAllPathsVisitor
:
public
ProgramVisitor
{
public
:
bool
visitExpression
(
const
Expression
&
expr
)
override
{
return
false
;
}
bool
visitStatement
(
const
Statement
&
stmt
)
override
{
switch
(
stmt
.
kind
(
)
)
{
case
Statement
:
:
Kind
:
:
kReturn
:
fFoundReturn
=
true
;
return
true
;
case
Statement
:
:
Kind
:
:
kBreak
:
fFoundBreak
=
true
;
return
true
;
case
Statement
:
:
Kind
:
:
kContinue
:
fFoundContinue
=
true
;
return
true
;
case
Statement
:
:
Kind
:
:
kIf
:
{
const
IfStatement
&
i
=
stmt
.
as
<
IfStatement
>
(
)
;
ReturnsOnAllPathsVisitor
trueVisitor
;
ReturnsOnAllPathsVisitor
falseVisitor
;
trueVisitor
.
visitStatement
(
*
i
.
ifTrue
(
)
)
;
if
(
i
.
ifFalse
(
)
)
{
falseVisitor
.
visitStatement
(
*
i
.
ifFalse
(
)
)
;
}
fFoundBreak
=
(
trueVisitor
.
fFoundBreak
|
|
falseVisitor
.
fFoundBreak
)
;
fFoundContinue
=
(
trueVisitor
.
fFoundContinue
|
|
falseVisitor
.
fFoundContinue
)
;
fFoundReturn
=
(
trueVisitor
.
fFoundReturn
&
&
falseVisitor
.
fFoundReturn
)
;
return
fFoundBreak
|
|
fFoundContinue
|
|
fFoundReturn
;
}
case
Statement
:
:
Kind
:
:
kFor
:
{
const
ForStatement
&
f
=
stmt
.
as
<
ForStatement
>
(
)
;
ReturnsOnAllPathsVisitor
forVisitor
;
forVisitor
.
visitStatement
(
*
f
.
statement
(
)
)
;
fFoundReturn
=
forVisitor
.
fFoundReturn
;
return
fFoundReturn
;
}
case
Statement
:
:
Kind
:
:
kDo
:
{
const
DoStatement
&
d
=
stmt
.
as
<
DoStatement
>
(
)
;
ReturnsOnAllPathsVisitor
doVisitor
;
doVisitor
.
visitStatement
(
*
d
.
statement
(
)
)
;
fFoundReturn
=
doVisitor
.
fFoundReturn
;
return
fFoundReturn
;
}
case
Statement
:
:
Kind
:
:
kBlock
:
return
INHERITED
:
:
visitStatement
(
stmt
)
;
case
Statement
:
:
Kind
:
:
kSwitch
:
{
const
SwitchStatement
&
s
=
stmt
.
as
<
SwitchStatement
>
(
)
;
bool
foundDefault
=
false
;
bool
fellThrough
=
false
;
for
(
const
std
:
:
unique_ptr
<
Statement
>
&
switchStmt
:
s
.
cases
(
)
)
{
const
SwitchCase
&
sc
=
switchStmt
-
>
as
<
SwitchCase
>
(
)
;
if
(
sc
.
isDefault
(
)
)
{
foundDefault
=
true
;
}
ReturnsOnAllPathsVisitor
caseVisitor
;
caseVisitor
.
visitStatement
(
sc
)
;
if
(
caseVisitor
.
fFoundContinue
)
{
fFoundContinue
=
true
;
return
false
;
}
if
(
caseVisitor
.
fFoundBreak
)
{
return
false
;
}
fellThrough
=
!
caseVisitor
.
fFoundReturn
;
}
if
(
fellThrough
|
|
!
foundDefault
)
{
return
false
;
}
fFoundReturn
=
true
;
return
true
;
}
case
Statement
:
:
Kind
:
:
kSwitchCase
:
return
INHERITED
:
:
visitStatement
(
stmt
)
;
case
Statement
:
:
Kind
:
:
kDiscard
:
case
Statement
:
:
Kind
:
:
kExpression
:
case
Statement
:
:
Kind
:
:
kNop
:
case
Statement
:
:
Kind
:
:
kVarDeclaration
:
break
;
}
return
false
;
}
bool
fFoundReturn
=
false
;
bool
fFoundBreak
=
false
;
bool
fFoundContinue
=
false
;
using
INHERITED
=
ProgramVisitor
;
}
;
}
bool
Analysis
:
:
CanExitWithoutReturningValue
(
const
FunctionDeclaration
&
funcDecl
const
Statement
&
body
)
{
if
(
funcDecl
.
returnType
(
)
.
isVoid
(
)
)
{
return
false
;
}
ReturnsOnAllPathsVisitor
visitor
;
visitor
.
visitStatement
(
body
)
;
return
!
visitor
.
fFoundReturn
;
}
}
