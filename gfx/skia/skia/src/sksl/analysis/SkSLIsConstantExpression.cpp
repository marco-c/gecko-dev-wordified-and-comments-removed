#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
SkSLIRNode
.
h
"
#
include
"
include
/
private
/
SkSLModifiers
.
h
"
#
include
"
include
/
sksl
/
SkSLOperator
.
h
"
#
include
"
src
/
sksl
/
SkSLAnalysis
.
h
"
#
include
"
src
/
sksl
/
analysis
/
SkSLProgramVisitor
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLBinaryExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLVariable
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLVariableReference
.
h
"
#
include
<
set
>
namespace
SkSL
{
class
ConstantExpressionVisitor
:
public
ProgramVisitor
{
public
:
ConstantExpressionVisitor
(
const
std
:
:
set
<
const
Variable
*
>
*
loopIndices
)
:
fLoopIndices
(
loopIndices
)
{
}
bool
visitExpression
(
const
Expression
&
e
)
override
{
switch
(
e
.
kind
(
)
)
{
case
Expression
:
:
Kind
:
:
kLiteral
:
return
false
;
case
Expression
:
:
Kind
:
:
kSetting
:
return
false
;
case
Expression
:
:
Kind
:
:
kVariableReference
:
{
const
Variable
*
v
=
e
.
as
<
VariableReference
>
(
)
.
variable
(
)
;
if
(
(
v
-
>
storage
(
)
=
=
Variable
:
:
Storage
:
:
kGlobal
|
|
v
-
>
storage
(
)
=
=
Variable
:
:
Storage
:
:
kLocal
)
&
&
(
v
-
>
modifiers
(
)
.
fFlags
&
Modifiers
:
:
kConst_Flag
)
)
{
return
false
;
}
return
!
fLoopIndices
|
|
fLoopIndices
-
>
find
(
v
)
=
=
fLoopIndices
-
>
end
(
)
;
}
case
Expression
:
:
Kind
:
:
kBinary
:
if
(
e
.
as
<
BinaryExpression
>
(
)
.
getOperator
(
)
.
kind
(
)
=
=
Operator
:
:
Kind
:
:
COMMA
)
{
return
true
;
}
[
[
fallthrough
]
]
;
case
Expression
:
:
Kind
:
:
kConstructorArray
:
case
Expression
:
:
Kind
:
:
kConstructorArrayCast
:
case
Expression
:
:
Kind
:
:
kConstructorCompound
:
case
Expression
:
:
Kind
:
:
kConstructorCompoundCast
:
case
Expression
:
:
Kind
:
:
kConstructorDiagonalMatrix
:
case
Expression
:
:
Kind
:
:
kConstructorMatrixResize
:
case
Expression
:
:
Kind
:
:
kConstructorScalarCast
:
case
Expression
:
:
Kind
:
:
kConstructorSplat
:
case
Expression
:
:
Kind
:
:
kConstructorStruct
:
case
Expression
:
:
Kind
:
:
kFieldAccess
:
case
Expression
:
:
Kind
:
:
kIndex
:
case
Expression
:
:
Kind
:
:
kPrefix
:
case
Expression
:
:
Kind
:
:
kPostfix
:
case
Expression
:
:
Kind
:
:
kSwizzle
:
case
Expression
:
:
Kind
:
:
kTernary
:
return
INHERITED
:
:
visitExpression
(
e
)
;
case
Expression
:
:
Kind
:
:
kFunctionCall
:
case
Expression
:
:
Kind
:
:
kChildCall
:
case
Expression
:
:
Kind
:
:
kPoison
:
case
Expression
:
:
Kind
:
:
kFunctionReference
:
case
Expression
:
:
Kind
:
:
kMethodReference
:
case
Expression
:
:
Kind
:
:
kTypeReference
:
return
true
;
default
:
SkDEBUGFAIL
(
"
Unexpected
expression
type
"
)
;
return
true
;
}
}
private
:
const
std
:
:
set
<
const
Variable
*
>
*
fLoopIndices
;
using
INHERITED
=
ProgramVisitor
;
}
;
bool
Analysis
:
:
IsConstantExpression
(
const
Expression
&
expr
)
{
return
!
ConstantExpressionVisitor
{
nullptr
}
.
visitExpression
(
expr
)
;
}
bool
Analysis
:
:
IsConstantIndexExpression
(
const
Expression
&
expr
const
std
:
:
set
<
const
Variable
*
>
*
loopIndices
)
{
return
!
ConstantExpressionVisitor
{
loopIndices
}
.
visitExpression
(
expr
)
;
}
}
