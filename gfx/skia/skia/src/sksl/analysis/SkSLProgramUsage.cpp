#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
SkSLModifiers
.
h
"
#
include
"
include
/
private
/
SkSLProgramElement
.
h
"
#
include
"
include
/
private
/
SkSLStatement
.
h
"
#
include
"
include
/
private
/
base
/
SkDebug
.
h
"
#
include
"
src
/
core
/
SkTHash
.
h
"
#
include
"
src
/
sksl
/
SkSLAnalysis
.
h
"
#
include
"
src
/
sksl
/
SkSLCompiler
.
h
"
#
include
"
src
/
sksl
/
analysis
/
SkSLProgramUsage
.
h
"
#
include
"
src
/
sksl
/
analysis
/
SkSLProgramVisitor
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFunctionCall
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFunctionDeclaration
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFunctionDefinition
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLInterfaceBlock
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLVarDeclarations
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLVariable
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLVariableReference
.
h
"
#
include
<
cstring
>
#
include
<
memory
>
#
include
<
string_view
>
#
include
<
vector
>
namespace
SkSL
{
struct
Program
;
namespace
{
class
ProgramUsageVisitor
:
public
ProgramVisitor
{
public
:
ProgramUsageVisitor
(
ProgramUsage
*
usage
int
delta
)
:
fUsage
(
usage
)
fDelta
(
delta
)
{
}
bool
visitProgramElement
(
const
ProgramElement
&
pe
)
override
{
if
(
pe
.
is
<
FunctionDefinition
>
(
)
)
{
for
(
const
Variable
*
param
:
pe
.
as
<
FunctionDefinition
>
(
)
.
declaration
(
)
.
parameters
(
)
)
{
fUsage
-
>
fVariableCounts
[
param
]
;
}
}
else
if
(
pe
.
is
<
InterfaceBlock
>
(
)
)
{
fUsage
-
>
fVariableCounts
[
pe
.
as
<
InterfaceBlock
>
(
)
.
var
(
)
]
;
}
return
INHERITED
:
:
visitProgramElement
(
pe
)
;
}
bool
visitStatement
(
const
Statement
&
s
)
override
{
if
(
s
.
is
<
VarDeclaration
>
(
)
)
{
const
VarDeclaration
&
vd
=
s
.
as
<
VarDeclaration
>
(
)
;
ProgramUsage
:
:
VariableCounts
&
counts
=
fUsage
-
>
fVariableCounts
[
vd
.
var
(
)
]
;
counts
.
fVarExists
+
=
fDelta
;
SkASSERT
(
counts
.
fVarExists
>
=
0
&
&
counts
.
fVarExists
<
=
1
)
;
if
(
vd
.
value
(
)
)
{
counts
.
fWrite
+
=
fDelta
;
}
}
return
INHERITED
:
:
visitStatement
(
s
)
;
}
bool
visitExpression
(
const
Expression
&
e
)
override
{
if
(
e
.
is
<
FunctionCall
>
(
)
)
{
const
FunctionDeclaration
*
f
=
&
e
.
as
<
FunctionCall
>
(
)
.
function
(
)
;
fUsage
-
>
fCallCounts
[
f
]
+
=
fDelta
;
SkASSERT
(
fUsage
-
>
fCallCounts
[
f
]
>
=
0
)
;
}
else
if
(
e
.
is
<
VariableReference
>
(
)
)
{
const
VariableReference
&
ref
=
e
.
as
<
VariableReference
>
(
)
;
ProgramUsage
:
:
VariableCounts
&
counts
=
fUsage
-
>
fVariableCounts
[
ref
.
variable
(
)
]
;
switch
(
ref
.
refKind
(
)
)
{
case
VariableRefKind
:
:
kRead
:
counts
.
fRead
+
=
fDelta
;
break
;
case
VariableRefKind
:
:
kWrite
:
counts
.
fWrite
+
=
fDelta
;
break
;
case
VariableRefKind
:
:
kReadWrite
:
case
VariableRefKind
:
:
kPointer
:
counts
.
fRead
+
=
fDelta
;
counts
.
fWrite
+
=
fDelta
;
break
;
}
SkASSERT
(
counts
.
fRead
>
=
0
&
&
counts
.
fWrite
>
=
0
)
;
}
return
INHERITED
:
:
visitExpression
(
e
)
;
}
using
ProgramVisitor
:
:
visitProgramElement
;
using
ProgramVisitor
:
:
visitStatement
;
ProgramUsage
*
fUsage
;
int
fDelta
;
using
INHERITED
=
ProgramVisitor
;
}
;
}
std
:
:
unique_ptr
<
ProgramUsage
>
Analysis
:
:
GetUsage
(
const
Program
&
program
)
{
auto
usage
=
std
:
:
make_unique
<
ProgramUsage
>
(
)
;
ProgramUsageVisitor
addRefs
(
usage
.
get
(
)
+
1
)
;
addRefs
.
visit
(
program
)
;
return
usage
;
}
std
:
:
unique_ptr
<
ProgramUsage
>
Analysis
:
:
GetUsage
(
const
Module
&
module
)
{
auto
usage
=
std
:
:
make_unique
<
ProgramUsage
>
(
)
;
ProgramUsageVisitor
addRefs
(
usage
.
get
(
)
+
1
)
;
for
(
const
Module
*
m
=
&
module
;
m
!
=
nullptr
;
m
=
m
-
>
fParent
)
{
for
(
const
std
:
:
unique_ptr
<
ProgramElement
>
&
element
:
m
-
>
fElements
)
{
addRefs
.
visitProgramElement
(
*
element
)
;
}
}
return
usage
;
}
ProgramUsage
:
:
VariableCounts
ProgramUsage
:
:
get
(
const
Variable
&
v
)
const
{
const
VariableCounts
*
counts
=
fVariableCounts
.
find
(
&
v
)
;
SkASSERT
(
counts
)
;
return
*
counts
;
}
bool
ProgramUsage
:
:
isDead
(
const
Variable
&
v
)
const
{
const
Modifiers
&
modifiers
=
v
.
modifiers
(
)
;
VariableCounts
counts
=
this
-
>
get
(
v
)
;
if
(
(
v
.
storage
(
)
!
=
Variable
:
:
Storage
:
:
kLocal
&
&
counts
.
fRead
)
|
|
(
modifiers
.
fFlags
&
(
Modifiers
:
:
kIn_Flag
|
Modifiers
:
:
kOut_Flag
|
Modifiers
:
:
kUniform_Flag
)
)
)
{
return
false
;
}
return
!
counts
.
fRead
&
&
(
counts
.
fWrite
<
=
(
v
.
initialValue
(
)
?
1
:
0
)
)
;
}
int
ProgramUsage
:
:
get
(
const
FunctionDeclaration
&
f
)
const
{
const
int
*
count
=
fCallCounts
.
find
(
&
f
)
;
return
count
?
*
count
:
0
;
}
void
ProgramUsage
:
:
add
(
const
Expression
*
expr
)
{
ProgramUsageVisitor
addRefs
(
this
+
1
)
;
addRefs
.
visitExpression
(
*
expr
)
;
}
void
ProgramUsage
:
:
add
(
const
Statement
*
stmt
)
{
ProgramUsageVisitor
addRefs
(
this
+
1
)
;
addRefs
.
visitStatement
(
*
stmt
)
;
}
void
ProgramUsage
:
:
add
(
const
ProgramElement
&
element
)
{
ProgramUsageVisitor
addRefs
(
this
+
1
)
;
addRefs
.
visitProgramElement
(
element
)
;
}
void
ProgramUsage
:
:
remove
(
const
Expression
*
expr
)
{
ProgramUsageVisitor
subRefs
(
this
-
1
)
;
subRefs
.
visitExpression
(
*
expr
)
;
}
void
ProgramUsage
:
:
remove
(
const
Statement
*
stmt
)
{
ProgramUsageVisitor
subRefs
(
this
-
1
)
;
subRefs
.
visitStatement
(
*
stmt
)
;
}
void
ProgramUsage
:
:
remove
(
const
ProgramElement
&
element
)
{
ProgramUsageVisitor
subRefs
(
this
-
1
)
;
subRefs
.
visitProgramElement
(
element
)
;
}
static
bool
contains_matching_data
(
const
ProgramUsage
&
a
const
ProgramUsage
&
b
)
{
constexpr
bool
kReportMismatch
=
false
;
for
(
const
auto
&
[
varA
varCountA
]
:
a
.
fVariableCounts
)
{
if
(
!
varCountA
.
fVarExists
&
&
!
varCountA
.
fRead
&
&
!
varCountA
.
fWrite
)
{
continue
;
}
const
ProgramUsage
:
:
VariableCounts
*
varCountB
=
b
.
fVariableCounts
.
find
(
varA
)
;
if
(
!
varCountB
|
|
0
!
=
memcmp
(
&
varCountA
varCountB
sizeof
(
varCountA
)
)
)
{
if
constexpr
(
kReportMismatch
)
{
SkDebugf
(
"
VariableCounts
mismatch
:
'
%
.
*
s
'
(
E
%
d
R
%
d
W
%
d
!
=
E
%
d
R
%
d
W
%
d
)
\
n
"
(
int
)
varA
-
>
name
(
)
.
size
(
)
varA
-
>
name
(
)
.
data
(
)
varCountA
.
fVarExists
varCountA
.
fRead
varCountA
.
fWrite
varCountB
?
varCountB
-
>
fVarExists
:
0
varCountB
?
varCountB
-
>
fRead
:
0
varCountB
?
varCountB
-
>
fWrite
:
0
)
;
}
return
false
;
}
}
for
(
const
auto
&
[
callA
callCountA
]
:
a
.
fCallCounts
)
{
if
(
!
callCountA
)
{
continue
;
}
const
int
*
callCountB
=
b
.
fCallCounts
.
find
(
callA
)
;
if
(
!
callCountB
|
|
callCountA
!
=
*
callCountB
)
{
if
constexpr
(
kReportMismatch
)
{
SkDebugf
(
"
CallCounts
mismatch
:
'
%
.
*
s
'
(
%
d
!
=
%
d
)
\
n
"
(
int
)
callA
-
>
name
(
)
.
size
(
)
callA
-
>
name
(
)
.
data
(
)
callCountA
callCountB
?
*
callCountB
:
0
)
;
}
return
false
;
}
}
return
true
;
}
bool
ProgramUsage
:
:
operator
=
=
(
const
ProgramUsage
&
that
)
const
{
return
contains_matching_data
(
*
this
that
)
&
&
contains_matching_data
(
that
*
this
)
;
}
}
