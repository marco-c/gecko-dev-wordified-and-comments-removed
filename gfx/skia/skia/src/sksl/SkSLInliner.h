#
ifndef
SKSL_INLINER
#
define
SKSL_INLINER
#
ifndef
SK_ENABLE_OPTIMIZE_SIZE
#
include
"
src
/
core
/
SkTHash
.
h
"
#
include
"
src
/
sksl
/
SkSLContext
.
h
"
#
include
"
src
/
sksl
/
SkSLMangler
.
h
"
#
include
"
src
/
sksl
/
SkSLProgramSettings
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLBlock
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLExpression
.
h
"
#
include
<
memory
>
#
include
<
vector
>
namespace
SkSL
{
class
FunctionCall
;
class
FunctionDeclaration
;
class
FunctionDefinition
;
class
Position
;
class
ProgramElement
;
class
ProgramUsage
;
class
Statement
;
class
SymbolTable
;
class
Variable
;
struct
InlineCandidate
;
struct
InlineCandidateList
;
namespace
Analysis
{
enum
class
ReturnComplexity
;
}
class
Inliner
{
public
:
Inliner
(
const
Context
*
context
)
:
fContext
(
context
)
{
}
bool
analyze
(
const
std
:
:
vector
<
std
:
:
unique_ptr
<
ProgramElement
>
>
&
elements
SymbolTable
*
symbols
ProgramUsage
*
usage
)
;
private
:
using
VariableRewriteMap
=
skia_private
:
:
THashMap
<
const
Variable
*
std
:
:
unique_ptr
<
Expression
>
>
;
const
ProgramSettings
&
settings
(
)
const
{
return
fContext
-
>
fConfig
-
>
fSettings
;
}
void
buildCandidateList
(
const
std
:
:
vector
<
std
:
:
unique_ptr
<
ProgramElement
>
>
&
elements
SymbolTable
*
symbols
ProgramUsage
*
usage
InlineCandidateList
*
candidateList
)
;
std
:
:
unique_ptr
<
Expression
>
inlineExpression
(
Position
pos
VariableRewriteMap
*
varMap
SymbolTable
*
symbolTableForExpression
const
Expression
&
expression
)
;
std
:
:
unique_ptr
<
Statement
>
inlineStatement
(
Position
pos
VariableRewriteMap
*
varMap
SymbolTable
*
symbolTableForStatement
std
:
:
unique_ptr
<
Expression
>
*
resultExpr
Analysis
:
:
ReturnComplexity
returnComplexity
const
Statement
&
statement
const
ProgramUsage
&
usage
bool
isBuiltinCode
)
;
static
const
Variable
*
RemapVariable
(
const
Variable
*
variable
const
VariableRewriteMap
*
varMap
)
;
using
InlinabilityCache
=
skia_private
:
:
THashMap
<
const
FunctionDeclaration
*
bool
>
;
bool
candidateCanBeInlined
(
const
InlineCandidate
&
candidate
const
ProgramUsage
&
usage
InlinabilityCache
*
cache
)
;
bool
functionCanBeInlined
(
const
FunctionDeclaration
&
funcDecl
const
ProgramUsage
&
usage
InlinabilityCache
*
cache
)
;
using
FunctionSizeCache
=
skia_private
:
:
THashMap
<
const
FunctionDeclaration
*
int
>
;
int
getFunctionSize
(
const
FunctionDeclaration
&
fnDecl
FunctionSizeCache
*
cache
)
;
struct
InlinedCall
{
std
:
:
unique_ptr
<
Block
>
fInlinedBody
;
std
:
:
unique_ptr
<
Expression
>
fReplacementExpr
;
}
;
InlinedCall
inlineCall
(
const
FunctionCall
&
SymbolTable
*
const
ProgramUsage
&
const
FunctionDeclaration
*
caller
)
;
void
ensureScopedBlocks
(
Statement
*
inlinedBody
Statement
*
parentStmt
)
;
bool
isSafeToInline
(
const
FunctionDefinition
*
functionDef
const
ProgramUsage
&
usage
)
;
const
Context
*
fContext
=
nullptr
;
Mangler
fMangler
;
int
fInlinedStatementCounter
=
0
;
}
;
}
#
endif
#
endif
