#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
src
/
core
/
SkTHash
.
h
"
#
include
"
src
/
sksl
/
SkSLCompiler
.
h
"
#
include
"
src
/
sksl
/
analysis
/
SkSLProgramUsage
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLProgram
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLProgramElement
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLStructDefinition
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLSymbol
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLType
.
h
"
#
include
"
src
/
sksl
/
transform
/
SkSLTransform
.
h
"
#
include
<
memory
>
#
include
<
type_traits
>
#
include
<
vector
>
using
namespace
skia_private
;
namespace
SkSL
{
static
bool
contains_builtin_struct
(
const
ProgramUsage
&
usage
)
{
for
(
const
auto
&
[
symbol
count
]
:
usage
.
fStructCounts
)
{
const
Type
&
type
=
symbol
-
>
as
<
Type
>
(
)
;
if
(
type
.
isBuiltin
(
)
)
{
return
true
;
}
}
return
false
;
}
static
void
get_struct_definitions_from_module
(
Program
&
program
const
Module
&
module
std
:
:
vector
<
const
ProgramElement
*
>
*
addedStructDefs
)
{
if
(
module
.
fParent
)
{
get_struct_definitions_from_module
(
program
*
module
.
fParent
addedStructDefs
)
;
}
for
(
const
std
:
:
unique_ptr
<
ProgramElement
>
&
elem
:
module
.
fElements
)
{
if
(
elem
-
>
is
<
StructDefinition
>
(
)
)
{
const
StructDefinition
&
structDef
=
elem
-
>
as
<
StructDefinition
>
(
)
;
int
*
structCount
=
program
.
fUsage
-
>
fStructCounts
.
find
(
&
structDef
.
type
(
)
)
;
if
(
structCount
&
&
*
structCount
>
0
)
{
addedStructDefs
-
>
push_back
(
&
structDef
)
;
}
}
}
}
void
Transform
:
:
FindAndDeclareBuiltinStructs
(
Program
&
program
)
{
if
(
contains_builtin_struct
(
*
program
.
fUsage
)
)
{
std
:
:
vector
<
const
ProgramElement
*
>
addedStructDefs
;
get_struct_definitions_from_module
(
program
*
program
.
fContext
-
>
fModule
&
addedStructDefs
)
;
program
.
fSharedElements
.
insert
(
program
.
fSharedElements
.
begin
(
)
addedStructDefs
.
begin
(
)
addedStructDefs
.
end
(
)
)
;
for
(
const
ProgramElement
*
element
:
addedStructDefs
)
{
program
.
fUsage
-
>
add
(
*
element
)
;
}
}
}
}
