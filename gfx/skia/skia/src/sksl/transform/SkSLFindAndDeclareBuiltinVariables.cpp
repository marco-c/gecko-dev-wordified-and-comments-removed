#
include
"
include
/
core
/
SkSpan
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
src
/
core
/
SkTHash
.
h
"
#
include
"
src
/
sksl
/
SkSLBuiltinTypes
.
h
"
#
include
"
src
/
sksl
/
SkSLCompiler
.
h
"
#
include
"
src
/
sksl
/
SkSLContext
.
h
"
#
include
"
src
/
sksl
/
SkSLProgramSettings
.
h
"
#
include
"
src
/
sksl
/
analysis
/
SkSLProgramUsage
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFunctionDeclaration
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFunctionDefinition
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLIRNode
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLInterfaceBlock
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLLayout
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLProgram
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLProgramElement
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLSymbol
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLSymbolTable
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLType
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLVarDeclarations
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLVariable
.
h
"
#
include
"
src
/
sksl
/
transform
/
SkSLTransform
.
h
"
#
include
<
algorithm
>
#
include
<
memory
>
#
include
<
string_view
>
#
include
<
vector
>
namespace
SkSL
{
namespace
Transform
{
namespace
{
class
BuiltinVariableScanner
{
public
:
BuiltinVariableScanner
(
const
Context
&
context
const
SymbolTable
&
symbols
)
:
fContext
(
context
)
fSymbols
(
symbols
)
{
}
void
addDeclaringElement
(
const
ProgramElement
*
decl
)
{
if
(
std
:
:
find
(
fNewElements
.
begin
(
)
fNewElements
.
end
(
)
decl
)
=
=
fNewElements
.
end
(
)
)
{
fNewElements
.
push_back
(
decl
)
;
}
}
void
addDeclaringElement
(
const
Symbol
*
symbol
)
{
if
(
!
symbol
|
|
!
symbol
-
>
is
<
Variable
>
(
)
)
{
return
;
}
const
Variable
&
var
=
symbol
-
>
as
<
Variable
>
(
)
;
if
(
const
GlobalVarDeclaration
*
decl
=
var
.
globalVarDeclaration
(
)
)
{
this
-
>
addDeclaringElement
(
decl
)
;
}
else
if
(
const
InterfaceBlock
*
block
=
var
.
interfaceBlock
(
)
)
{
this
-
>
addDeclaringElement
(
block
)
;
}
else
{
SkASSERTF
(
var
.
storage
(
)
!
=
VariableStorage
:
:
kGlobal
&
&
var
.
storage
(
)
!
=
VariableStorage
:
:
kInterfaceBlock
"
%
.
*
s
"
(
int
)
var
.
name
(
)
.
size
(
)
var
.
name
(
)
.
data
(
)
)
;
}
}
void
addImplicitFragColorWrite
(
SkSpan
<
const
std
:
:
unique_ptr
<
ProgramElement
>
>
elements
)
{
for
(
const
std
:
:
unique_ptr
<
ProgramElement
>
&
pe
:
elements
)
{
if
(
!
pe
-
>
is
<
FunctionDefinition
>
(
)
)
{
continue
;
}
const
FunctionDefinition
&
funcDef
=
pe
-
>
as
<
FunctionDefinition
>
(
)
;
if
(
funcDef
.
declaration
(
)
.
isMain
(
)
)
{
if
(
funcDef
.
declaration
(
)
.
returnType
(
)
.
matches
(
*
fContext
.
fTypes
.
fHalf4
)
)
{
this
-
>
addDeclaringElement
(
fSymbols
.
findBuiltinSymbol
(
Compiler
:
:
FRAGCOLOR_NAME
)
)
;
}
break
;
}
}
}
static
std
:
:
string_view
GlobalVarBuiltinName
(
const
ProgramElement
&
elem
)
{
return
elem
.
as
<
GlobalVarDeclaration
>
(
)
.
varDeclaration
(
)
.
var
(
)
-
>
name
(
)
;
}
static
std
:
:
string_view
InterfaceBlockName
(
const
ProgramElement
&
elem
)
{
return
elem
.
as
<
InterfaceBlock
>
(
)
.
instanceName
(
)
;
}
void
sortNewElements
(
)
{
std
:
:
sort
(
fNewElements
.
begin
(
)
fNewElements
.
end
(
)
[
]
(
const
ProgramElement
*
a
const
ProgramElement
*
b
)
{
if
(
a
-
>
kind
(
)
!
=
b
-
>
kind
(
)
)
{
return
a
-
>
kind
(
)
<
b
-
>
kind
(
)
;
}
switch
(
a
-
>
kind
(
)
)
{
case
ProgramElement
:
:
Kind
:
:
kGlobalVar
:
SkASSERT
(
a
=
=
b
|
|
GlobalVarBuiltinName
(
*
a
)
!
=
GlobalVarBuiltinName
(
*
b
)
)
;
return
GlobalVarBuiltinName
(
*
a
)
<
GlobalVarBuiltinName
(
*
b
)
;
case
ProgramElement
:
:
Kind
:
:
kInterfaceBlock
:
SkASSERT
(
a
=
=
b
|
|
InterfaceBlockName
(
*
a
)
!
=
InterfaceBlockName
(
*
b
)
)
;
return
InterfaceBlockName
(
*
a
)
<
InterfaceBlockName
(
*
b
)
;
default
:
SkUNREACHABLE
;
}
}
)
;
}
const
Context
&
fContext
;
const
SymbolTable
&
fSymbols
;
std
:
:
vector
<
const
ProgramElement
*
>
fNewElements
;
}
;
}
void
FindAndDeclareBuiltinVariables
(
Program
&
program
)
{
using
Interface
=
Program
:
:
Interface
;
const
Context
&
context
=
*
program
.
fContext
;
const
SymbolTable
&
symbols
=
*
program
.
fSymbols
;
BuiltinVariableScanner
scanner
(
context
symbols
)
;
if
(
ProgramConfig
:
:
IsFragment
(
program
.
fConfig
-
>
fKind
)
)
{
scanner
.
addImplicitFragColorWrite
(
program
.
fOwnedElements
)
;
}
for
(
const
auto
&
[
var
counts
]
:
program
.
fUsage
-
>
fVariableCounts
)
{
if
(
var
-
>
isBuiltin
(
)
)
{
scanner
.
addDeclaringElement
(
var
)
;
switch
(
var
-
>
layout
(
)
.
fBuiltin
)
{
case
SK_FRAGCOORD_BUILTIN
:
if
(
!
context
.
fConfig
-
>
fSettings
.
fForceNoRTFlip
)
{
program
.
fInterface
.
fRTFlipUniform
|
=
Interface
:
:
kRTFlip_FragCoord
;
}
break
;
case
SK_CLOCKWISE_BUILTIN
:
if
(
!
context
.
fConfig
-
>
fSettings
.
fForceNoRTFlip
)
{
program
.
fInterface
.
fRTFlipUniform
|
=
Interface
:
:
kRTFlip_Clockwise
;
}
break
;
case
SK_LASTFRAGCOLOR_BUILTIN
:
program
.
fInterface
.
fUseLastFragColor
=
true
;
break
;
case
SK_SECONDARYFRAGCOLOR_BUILTIN
:
program
.
fInterface
.
fOutputSecondaryColor
=
true
;
break
;
}
}
}
scanner
.
sortNewElements
(
)
;
program
.
fSharedElements
.
insert
(
program
.
fSharedElements
.
begin
(
)
scanner
.
fNewElements
.
begin
(
)
scanner
.
fNewElements
.
end
(
)
)
;
for
(
const
ProgramElement
*
element
:
scanner
.
fNewElements
)
{
program
.
fUsage
-
>
add
(
*
element
)
;
}
}
}
}
