#
include
"
SkSLCPPUniformCTypes
.
h
"
#
include
"
SkSLHCodeGenerator
.
h
"
#
include
"
SkSLStringStream
.
h
"
#
include
<
vector
>
namespace
SkSL
{
static
String
eval_template
(
const
String
&
format
const
std
:
:
vector
<
String
>
&
tokens
const
std
:
:
vector
<
const
String
*
>
&
values
)
{
StringStream
stream
;
int
tokenNameStart
=
-
1
;
for
(
size_t
i
=
0
;
i
<
format
.
size
(
)
;
i
+
+
)
{
if
(
tokenNameStart
>
=
0
)
{
if
(
format
[
i
]
=
=
'
}
'
)
{
String
token
(
format
.
c_str
(
)
+
tokenNameStart
+
2
i
-
tokenNameStart
-
2
)
;
bool
found
=
false
;
for
(
size_t
j
=
0
;
j
<
tokens
.
size
(
)
;
j
+
+
)
{
if
(
token
=
=
tokens
[
j
]
)
{
stream
.
writeText
(
values
[
j
]
-
>
c_str
(
)
)
;
found
=
true
;
break
;
}
}
if
(
!
found
)
{
stream
.
writeText
(
"
{
"
)
;
stream
.
writeText
(
token
.
c_str
(
)
)
;
stream
.
writeText
(
"
}
"
)
;
}
tokenNameStart
=
-
1
;
}
}
else
{
if
(
i
<
format
.
size
(
)
-
1
&
&
format
[
i
]
=
=
'
'
&
&
format
[
i
+
1
]
=
=
'
{
'
)
{
tokenNameStart
=
i
;
}
else
{
stream
.
write8
(
format
[
i
]
)
;
}
}
}
return
stream
.
str
(
)
;
}
static
bool
determine_inline_from_template
(
const
String
&
uniformTemplate
)
{
int
firstMatch
=
uniformTemplate
.
find
(
"
{
var
}
"
)
;
if
(
firstMatch
<
0
)
{
return
true
;
}
int
secondMatch
=
uniformTemplate
.
find
(
"
{
var
}
"
firstMatch
+
strlen
(
"
{
var
}
"
)
)
;
return
secondMatch
<
0
;
}
String
UniformCTypeMapper
:
:
dirtyExpression
(
const
String
&
newVar
const
String
&
oldVar
)
const
{
if
(
fSupportsTracking
)
{
std
:
:
vector
<
String
>
tokens
=
{
"
newVar
"
"
oldVar
"
}
;
std
:
:
vector
<
const
String
*
>
values
=
{
&
newVar
&
oldVar
}
;
return
eval_template
(
fDirtyExpressionTemplate
tokens
values
)
;
}
else
{
return
"
"
;
}
}
String
UniformCTypeMapper
:
:
saveState
(
const
String
&
newVar
const
String
&
oldVar
)
const
{
if
(
fSupportsTracking
)
{
std
:
:
vector
<
String
>
tokens
=
{
"
newVar
"
"
oldVar
"
}
;
std
:
:
vector
<
const
String
*
>
values
=
{
&
newVar
&
oldVar
}
;
return
eval_template
(
fSaveStateTemplate
tokens
values
)
;
}
else
{
return
"
"
;
}
}
String
UniformCTypeMapper
:
:
setUniform
(
const
String
&
pdman
const
String
&
uniform
const
String
&
var
)
const
{
std
:
:
vector
<
String
>
tokens
=
{
"
pdman
"
"
uniform
"
"
var
"
}
;
std
:
:
vector
<
const
String
*
>
values
=
{
&
pdman
&
uniform
&
var
}
;
return
eval_template
(
fUniformTemplate
tokens
values
)
;
}
UniformCTypeMapper
:
:
UniformCTypeMapper
(
Layout
:
:
CType
ctype
const
std
:
:
vector
<
String
>
&
skslTypes
const
String
&
setUniformFormat
bool
enableTracking
const
String
&
defaultValue
const
String
&
dirtyExpressionFormat
const
String
&
saveStateFormat
)
:
fCType
(
ctype
)
fSKSLTypes
(
skslTypes
)
fUniformTemplate
(
setUniformFormat
)
fInlineValue
(
determine_inline_from_template
(
setUniformFormat
)
)
fSupportsTracking
(
enableTracking
)
fDefaultValue
(
defaultValue
)
fDirtyExpressionTemplate
(
dirtyExpressionFormat
)
fSaveStateTemplate
(
saveStateFormat
)
{
}
static
UniformCTypeMapper
REGISTER
(
Layout
:
:
CType
ctype
const
std
:
:
vector
<
String
>
&
skslTypes
const
char
*
uniformFormat
const
char
*
defaultValue
const
char
*
dirtyExpression
)
{
return
UniformCTypeMapper
(
ctype
skslTypes
uniformFormat
defaultValue
dirtyExpression
"
{
oldVar
}
=
{
newVar
}
"
)
;
}
static
UniformCTypeMapper
REGISTER
(
Layout
:
:
CType
ctype
const
std
:
:
vector
<
String
>
&
skslTypes
const
char
*
uniformFormat
const
char
*
defaultValue
)
{
return
REGISTER
(
ctype
skslTypes
uniformFormat
defaultValue
"
{
oldVar
}
!
=
{
newVar
}
"
)
;
}
static
const
std
:
:
vector
<
UniformCTypeMapper
>
&
get_mappers
(
)
{
static
const
std
:
:
vector
<
UniformCTypeMapper
>
registeredMappers
=
{
REGISTER
(
Layout
:
:
CType
:
:
kSkRect
{
"
half4
"
"
float4
"
"
double4
"
}
"
{
pdman
}
.
set4fv
(
{
uniform
}
1
reinterpret_cast
<
const
float
*
>
(
&
{
var
}
)
)
"
"
SkRect
:
:
MakeEmpty
(
)
"
"
{
oldVar
}
.
isEmpty
(
)
|
|
{
oldVar
}
!
=
{
newVar
}
"
)
REGISTER
(
Layout
:
:
CType
:
:
kSkIRect
{
"
int4
"
"
short4
"
"
byte4
"
}
"
{
pdman
}
.
set4iv
(
{
uniform
}
1
reinterpret_cast
<
const
int
*
>
(
&
{
var
}
)
)
"
"
SkIRect
:
:
MakeEmpty
(
)
"
"
{
oldVar
}
.
isEmpty
(
)
|
|
{
oldVar
}
!
=
{
newVar
}
"
)
REGISTER
(
Layout
:
:
CType
:
:
kGrColor4f
{
"
half4
"
"
float4
"
"
double4
"
}
"
{
pdman
}
.
set4fv
(
{
uniform
}
1
{
var
}
.
fRGBA
)
"
"
GrColor4f
:
:
kIllegalConstructor
"
)
REGISTER
(
Layout
:
:
CType
:
:
kSkPMColor4f
{
"
half4
"
"
float4
"
"
double4
"
}
"
{
pdman
}
.
set4fv
(
{
uniform
}
1
{
var
}
.
vec
(
)
)
"
"
{
SK_FloatNaN
SK_FloatNaN
SK_FloatNaN
SK_FloatNaN
}
"
)
REGISTER
(
Layout
:
:
CType
:
:
kSkPoint
{
"
half2
"
"
float2
"
"
double2
"
}
"
{
pdman
}
.
set2f
(
{
uniform
}
{
var
}
.
fX
{
var
}
.
fY
)
"
"
SkPoint
:
:
Make
(
SK_FloatNaN
SK_FloatNaN
)
"
)
REGISTER
(
Layout
:
:
CType
:
:
kSkIPoint
{
"
int2
"
"
short2
"
"
byte2
"
}
"
{
pdman
}
.
set2i
(
{
uniform
}
{
var
}
.
fX
{
var
}
.
fY
)
"
"
SkIPoint
:
:
Make
(
SK_NaN32
SK_NaN32
)
"
)
REGISTER
(
Layout
:
:
CType
:
:
kSkMatrix
{
"
half3x3
"
"
float3x3
"
"
double3x3
"
}
"
{
pdman
}
.
setSkMatrix
(
{
uniform
}
{
var
}
)
"
"
SkMatrix
:
:
MakeScale
(
SK_FloatNaN
)
"
"
!
{
oldVar
}
.
cheapEqualTo
(
{
newVar
}
)
"
)
REGISTER
(
Layout
:
:
CType
:
:
kSkMatrix44
{
"
half4x4
"
"
float4x4
"
"
double4x4
"
}
"
{
pdman
}
.
setSkMatrix44
(
{
uniform
}
{
var
}
)
"
"
SkMatrix
:
:
MakeScale
(
SK_FloatNaN
)
"
"
!
{
oldVar
}
.
cheapEqualTo
(
{
newVar
}
)
"
)
REGISTER
(
Layout
:
:
CType
:
:
kFloat
{
"
half
"
"
float
"
"
double
"
}
"
{
pdman
}
.
set1f
(
{
uniform
}
{
var
}
)
"
"
SK_FloatNaN
"
)
REGISTER
(
Layout
:
:
CType
:
:
kInt32
{
"
int
"
"
short
"
"
byte
"
}
"
{
pdman
}
.
set1i
(
{
uniform
}
{
var
}
)
"
"
SK_NaN32
"
)
}
;
return
registeredMappers
;
}
const
UniformCTypeMapper
*
UniformCTypeMapper
:
:
Get
(
const
Context
&
context
const
Type
&
type
const
Layout
&
layout
)
{
const
std
:
:
vector
<
UniformCTypeMapper
>
&
registeredMappers
=
get_mappers
(
)
;
Layout
:
:
CType
ctype
=
layout
.
fCType
;
if
(
ctype
=
=
Layout
:
:
CType
:
:
kDefault
)
{
ctype
=
HCodeGenerator
:
:
ParameterCType
(
context
type
layout
)
;
}
const
String
&
skslType
=
type
.
name
(
)
;
for
(
size_t
i
=
0
;
i
<
registeredMappers
.
size
(
)
;
i
+
+
)
{
if
(
registeredMappers
[
i
]
.
ctype
(
)
=
=
ctype
)
{
const
std
:
:
vector
<
String
>
supportedSKSL
=
registeredMappers
[
i
]
.
supportedTypeNames
(
)
;
for
(
size_t
j
=
0
;
j
<
supportedSKSL
.
size
(
)
;
j
+
+
)
{
if
(
supportedSKSL
[
j
]
=
=
skslType
)
{
return
&
registeredMappers
[
i
]
;
}
}
}
}
return
nullptr
;
}
}
