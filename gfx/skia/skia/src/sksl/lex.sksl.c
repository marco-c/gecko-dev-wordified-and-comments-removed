#
line
3
"
lex
.
sksl
.
c
"
#
define
YY_INT_ALIGNED
short
int
#
define
FLEX_SCANNER
#
define
YY_FLEX_MAJOR_VERSION
2
#
define
YY_FLEX_MINOR_VERSION
5
#
define
YY_FLEX_SUBMINOR_VERSION
37
#
if
YY_FLEX_SUBMINOR_VERSION
>
0
#
define
FLEX_BETA
#
endif
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
errno
.
h
>
#
include
<
stdlib
.
h
>
#
ifndef
FLEXINT_H
#
define
FLEXINT_H
#
if
defined
(
__STDC_VERSION__
)
&
&
__STDC_VERSION__
>
=
199901L
#
ifndef
__STDC_LIMIT_MACROS
#
define
__STDC_LIMIT_MACROS
1
#
endif
#
include
<
inttypes
.
h
>
typedef
int8_t
flex_int8_t
;
typedef
uint8_t
flex_uint8_t
;
typedef
int16_t
flex_int16_t
;
typedef
uint16_t
flex_uint16_t
;
typedef
int32_t
flex_int32_t
;
typedef
uint32_t
flex_uint32_t
;
#
else
typedef
signed
char
flex_int8_t
;
typedef
short
int
flex_int16_t
;
typedef
int
flex_int32_t
;
typedef
unsigned
char
flex_uint8_t
;
typedef
unsigned
short
int
flex_uint16_t
;
typedef
unsigned
int
flex_uint32_t
;
#
ifndef
INT8_MIN
#
define
INT8_MIN
(
-
128
)
#
endif
#
ifndef
INT16_MIN
#
define
INT16_MIN
(
-
32767
-
1
)
#
endif
#
ifndef
INT32_MIN
#
define
INT32_MIN
(
-
2147483647
-
1
)
#
endif
#
ifndef
INT8_MAX
#
define
INT8_MAX
(
127
)
#
endif
#
ifndef
INT16_MAX
#
define
INT16_MAX
(
32767
)
#
endif
#
ifndef
INT32_MAX
#
define
INT32_MAX
(
2147483647
)
#
endif
#
ifndef
UINT8_MAX
#
define
UINT8_MAX
(
255U
)
#
endif
#
ifndef
UINT16_MAX
#
define
UINT16_MAX
(
65535U
)
#
endif
#
ifndef
UINT32_MAX
#
define
UINT32_MAX
(
4294967295U
)
#
endif
#
endif
#
endif
#
ifdef
__cplusplus
#
define
YY_USE_CONST
#
else
#
if
defined
(
__STDC__
)
#
define
YY_USE_CONST
#
endif
#
endif
#
ifdef
YY_USE_CONST
#
define
yyconst
const
#
else
#
define
yyconst
#
endif
#
define
YY_NULL
0
#
define
YY_SC_TO_UI
(
c
)
(
(
unsigned
int
)
(
unsigned
char
)
c
)
#
ifndef
YY_TYPEDEF_YY_SCANNER_T
#
define
YY_TYPEDEF_YY_SCANNER_T
typedef
void
*
yyscan_t
;
#
endif
#
define
yyin
yyg
-
>
yyin_r
#
define
yyout
yyg
-
>
yyout_r
#
define
yyextra
yyg
-
>
yyextra_r
#
define
yyleng
yyg
-
>
yyleng_r
#
define
yytext
yyg
-
>
yytext_r
#
define
yylineno
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_bs_lineno
)
#
define
yycolumn
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_bs_column
)
#
define
yy_flex_debug
yyg
-
>
yy_flex_debug_r
#
define
BEGIN
yyg
-
>
yy_start
=
1
+
2
*
#
define
YY_START
(
(
yyg
-
>
yy_start
-
1
)
/
2
)
#
define
YYSTATE
YY_START
#
define
YY_STATE_EOF
(
state
)
(
YY_END_OF_BUFFER
+
state
+
1
)
#
define
YY_NEW_FILE
skslrestart
(
yyin
yyscanner
)
#
define
YY_END_OF_BUFFER_CHAR
0
#
ifndef
YY_BUF_SIZE
#
define
YY_BUF_SIZE
16384
#
endif
#
define
YY_STATE_BUF_SIZE
(
(
YY_BUF_SIZE
+
2
)
*
sizeof
(
yy_state_type
)
)
#
ifndef
YY_TYPEDEF_YY_BUFFER_STATE
#
define
YY_TYPEDEF_YY_BUFFER_STATE
typedef
struct
yy_buffer_state
*
YY_BUFFER_STATE
;
#
endif
#
ifndef
YY_TYPEDEF_YY_SIZE_T
#
define
YY_TYPEDEF_YY_SIZE_T
typedef
size_t
yy_size_t
;
#
endif
#
define
EOB_ACT_CONTINUE_SCAN
0
#
define
EOB_ACT_END_OF_FILE
1
#
define
EOB_ACT_LAST_MATCH
2
#
define
YY_LESS_LINENO
(
n
)
\
do
{
\
int
yyl
;
\
for
(
yyl
=
n
;
yyl
<
yyleng
;
+
+
yyl
)
\
if
(
yytext
[
yyl
]
=
=
'
\
n
'
)
\
-
-
yylineno
;
\
}
while
(
0
)
#
define
yyless
(
n
)
\
do
\
{
\
/
*
Undo
effects
of
setting
up
yytext
.
*
/
\
int
yyless_macro_arg
=
(
n
)
;
\
YY_LESS_LINENO
(
yyless_macro_arg
)
;
\
*
yy_cp
=
yyg
-
>
yy_hold_char
;
\
YY_RESTORE_YY_MORE_OFFSET
\
yyg
-
>
yy_c_buf_p
=
yy_cp
=
yy_bp
+
yyless_macro_arg
-
YY_MORE_ADJ
;
\
YY_DO_BEFORE_ACTION
;
/
*
set
up
yytext
again
*
/
\
}
\
while
(
0
)
#
define
unput
(
c
)
yyunput
(
c
yyg
-
>
yytext_ptr
yyscanner
)
#
ifndef
YY_STRUCT_YY_BUFFER_STATE
#
define
YY_STRUCT_YY_BUFFER_STATE
struct
yy_buffer_state
{
FILE
*
yy_input_file
;
char
*
yy_ch_buf
;
char
*
yy_buf_pos
;
yy_size_t
yy_buf_size
;
yy_size_t
yy_n_chars
;
int
yy_is_our_buffer
;
int
yy_is_interactive
;
int
yy_at_bol
;
int
yy_bs_lineno
;
int
yy_bs_column
;
int
yy_fill_buffer
;
int
yy_buffer_status
;
#
define
YY_BUFFER_NEW
0
#
define
YY_BUFFER_NORMAL
1
#
define
YY_BUFFER_EOF_PENDING
2
}
;
#
endif
#
define
YY_CURRENT_BUFFER
(
yyg
-
>
yy_buffer_stack
\
?
yyg
-
>
yy_buffer_stack
[
yyg
-
>
yy_buffer_stack_top
]
\
:
NULL
)
#
define
YY_CURRENT_BUFFER_LVALUE
yyg
-
>
yy_buffer_stack
[
yyg
-
>
yy_buffer_stack_top
]
void
skslrestart
(
FILE
*
input_file
yyscan_t
yyscanner
)
;
void
sksl_switch_to_buffer
(
YY_BUFFER_STATE
new_buffer
yyscan_t
yyscanner
)
;
YY_BUFFER_STATE
sksl_create_buffer
(
FILE
*
file
int
size
yyscan_t
yyscanner
)
;
void
sksl_delete_buffer
(
YY_BUFFER_STATE
b
yyscan_t
yyscanner
)
;
void
sksl_flush_buffer
(
YY_BUFFER_STATE
b
yyscan_t
yyscanner
)
;
void
skslpush_buffer_state
(
YY_BUFFER_STATE
new_buffer
yyscan_t
yyscanner
)
;
void
skslpop_buffer_state
(
yyscan_t
yyscanner
)
;
static
void
skslensure_buffer_stack
(
yyscan_t
yyscanner
)
;
static
void
sksl_load_buffer_state
(
yyscan_t
yyscanner
)
;
static
void
sksl_init_buffer
(
YY_BUFFER_STATE
b
FILE
*
file
yyscan_t
yyscanner
)
;
#
define
YY_FLUSH_BUFFER
sksl_flush_buffer
(
YY_CURRENT_BUFFER
yyscanner
)
YY_BUFFER_STATE
sksl_scan_buffer
(
char
*
base
yy_size_t
size
yyscan_t
yyscanner
)
;
YY_BUFFER_STATE
sksl_scan_string
(
yyconst
char
*
yy_str
yyscan_t
yyscanner
)
;
YY_BUFFER_STATE
sksl_scan_bytes
(
yyconst
char
*
bytes
yy_size_t
len
yyscan_t
yyscanner
)
;
void
*
skslalloc
(
yy_size_t
yyscan_t
yyscanner
)
;
void
*
skslrealloc
(
void
*
yy_size_t
yyscan_t
yyscanner
)
;
void
skslfree
(
void
*
yyscan_t
yyscanner
)
;
#
define
yy_new_buffer
sksl_create_buffer
#
define
yy_set_interactive
(
is_interactive
)
\
{
\
if
(
!
YY_CURRENT_BUFFER
)
{
\
skslensure_buffer_stack
(
yyscanner
)
;
\
YY_CURRENT_BUFFER_LVALUE
=
\
sksl_create_buffer
(
yyin
YY_BUF_SIZE
yyscanner
)
;
\
}
\
YY_CURRENT_BUFFER_LVALUE
-
>
yy_is_interactive
=
is_interactive
;
\
}
#
define
yy_set_bol
(
at_bol
)
\
{
\
if
(
!
YY_CURRENT_BUFFER
)
{
\
skslensure_buffer_stack
(
yyscanner
)
;
\
YY_CURRENT_BUFFER_LVALUE
=
\
sksl_create_buffer
(
yyin
YY_BUF_SIZE
yyscanner
)
;
\
}
\
YY_CURRENT_BUFFER_LVALUE
-
>
yy_at_bol
=
at_bol
;
\
}
#
define
YY_AT_BOL
(
)
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_at_bol
)
typedef
unsigned
char
YY_CHAR
;
typedef
int
yy_state_type
;
#
define
yytext_ptr
yytext_r
static
yy_state_type
yy_get_previous_state
(
yyscan_t
yyscanner
)
;
static
yy_state_type
yy_try_NUL_trans
(
yy_state_type
current_state
yyscan_t
yyscanner
)
;
static
int
yy_get_next_buffer
(
yyscan_t
yyscanner
)
;
static
void
yy_fatal_error
(
yyconst
char
msg
[
]
yyscan_t
yyscanner
)
;
#
define
YY_DO_BEFORE_ACTION
\
yyg
-
>
yytext_ptr
=
yy_bp
;
\
yyleng
=
(
size_t
)
(
yy_cp
-
yy_bp
)
;
\
yyg
-
>
yy_hold_char
=
*
yy_cp
;
\
*
yy_cp
=
'
\
0
'
;
\
yyg
-
>
yy_c_buf_p
=
yy_cp
;
#
define
YY_NUM_RULES
82
#
define
YY_END_OF_BUFFER
83
struct
yy_trans_info
{
flex_int32_t
yy_verify
;
flex_int32_t
yy_nxt
;
}
;
static
yyconst
flex_int16_t
yy_accept
[
201
]
=
{
0
0
0
83
81
80
80
54
81
29
45
50
31
32
43
41
38
42
37
44
4
56
77
61
57
60
55
35
36
49
29
29
29
29
29
29
29
29
29
29
29
29
29
29
29
29
29
33
48
34
80
59
30
29
68
53
73
66
39
64
40
65
1
0
78
67
2
4
0
46
63
58
62
47
72
52
29
29
29
11
29
29
29
29
29
7
16
29
29
29
29
29
29
29
29
29
29
29
71
51
30
76
0
0
0
78
1
0
0
3
69
70
75
29
29
29
29
29
29
9
29
29
29
29
29
29
17
29
29
29
29
29
29
74
0
1
79
0
0
2
29
29
29
29
8
29
24
29
29
29
21
29
29
29
29
29
5
29
29
0
1
12
20
29
29
6
23
18
29
29
29
29
29
29
29
10
29
29
27
29
29
29
15
26
29
29
14
22
29
29
19
13
29
29
29
28
29
29
29
25
0
}
;
static
yyconst
flex_int32_t
yy_ec
[
256
]
=
{
0
1
1
1
1
1
1
1
1
2
3
1
1
2
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
2
4
1
5
6
7
8
1
9
10
11
12
13
14
15
16
17
17
17
17
17
17
17
17
17
17
18
19
20
21
22
23
1
6
6
6
6
24
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
25
1
26
27
6
1
28
29
30
31
32
33
34
35
36
6
37
38
39
40
41
42
6
43
44
45
46
47
48
6
49
6
50
51
52
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
}
;
static
yyconst
flex_int32_t
yy_meta
[
53
]
=
{
0
1
1
2
1
1
3
1
1
1
1
1
1
1
1
1
1
4
1
1
1
1
1
1
3
1
1
1
3
3
3
3
3
3
3
3
3
3
3
3
3
3
3
3
3
3
3
3
3
3
1
1
1
}
;
static
yyconst
flex_int16_t
yy_base
[
206
]
=
{
0
0
0
238
239
51
53
216
0
0
215
49
239
239
214
46
239
45
217
52
45
239
239
44
212
50
239
239
239
53
189
190
40
192
47
193
46
50
196
186
180
182
192
178
179
181
185
239
61
239
81
239
0
0
239
198
239
239
239
239
239
239
70
207
0
239
72
75
81
196
239
239
239
195
239
194
182
173
168
0
167
172
181
165
173
0
165
156
156
172
160
156
168
154
155
151
160
159
239
173
0
239
89
182
176
0
91
97
174
173
239
239
239
161
72
158
155
142
140
0
149
137
141
139
144
147
0
148
131
130
143
141
135
239
155
154
239
107
153
152
131
122
130
137
0
132
0
121
117
115
0
114
116
122
114
126
0
114
122
136
135
0
0
111
107
0
0
0
104
109
103
102
105
99
100
0
96
110
0
98
97
102
0
0
98
102
0
0
90
79
0
0
88
73
65
0
69
53
65
0
239
58
122
124
128
132
}
;
static
yyconst
flex_int16_t
yy_def
[
206
]
=
{
0
200
1
200
200
200
200
200
201
202
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
200
200
200
200
200
203
202
200
200
200
200
200
200
200
200
200
204
205
200
200
200
200
200
200
200
200
200
200
200
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
200
200
203
200
200
204
204
205
200
200
200
200
200
200
200
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
200
200
200
200
200
200
200
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
200
200
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
202
0
200
200
200
200
200
}
;
static
yyconst
flex_int16_t
yy_nxt
[
292
]
=
{
0
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
9
27
28
29
9
30
31
32
33
34
9
35
36
9
37
38
39
40
41
42
43
44
45
9
46
9
47
48
49
50
50
50
50
55
58
60
66
52
67
63
69
70
61
59
64
68
56
72
73
65
74
81
78
68
87
85
75
79
98
50
50
82
86
62
83
106
66
88
67
108
102
108
107
199
109
68
198
134
102
134
107
197
135
68
106
138
196
138
99
195
139
137
141
142
194
159
193
159
192
137
160
53
53
100
100
103
103
103
103
105
191
105
105
190
189
188
187
186
185
184
183
182
181
180
179
178
177
176
160
160
175
174
173
172
171
170
169
168
167
166
165
164
163
162
161
139
139
135
135
158
157
156
155
154
153
152
151
150
149
148
147
146
145
144
143
140
109
109
136
104
133
132
131
130
129
128
127
126
125
124
123
122
121
120
119
118
117
116
115
114
113
112
111
110
104
101
97
96
95
94
93
92
91
90
89
84
80
77
76
71
62
57
54
51
200
3
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
}
;
static
yyconst
flex_int16_t
yy_chk
[
292
]
=
{
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
5
5
6
6
11
15
17
20
201
20
19
23
23
17
15
19
20
11
25
25
19
29
34
32
20
37
36
29
32
48
50
50
34
36
62
34
66
67
37
67
68
62
68
66
198
68
67
197
102
62
102
66
196
102
67
106
107
194
107
48
193
107
106
114
114
192
137
189
137
188
106
137
202
202
203
203
204
204
204
204
205
185
205
205
184
181
180
179
177
176
174
173
172
171
170
169
168
164
163
160
159
158
157
155
154
153
152
151
149
148
147
145
143
142
141
140
139
138
135
134
132
131
130
129
128
127
125
124
123
122
121
120
118
117
116
115
113
109
108
104
103
99
97
96
95
94
93
92
91
90
89
88
87
86
84
83
82
81
80
78
77
76
75
73
69
63
55
46
45
44
43
42
41
40
39
38
35
33
31
30
24
18
14
10
7
3
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
200
}
;
static
yyconst
flex_int32_t
yy_rule_can_match_eol
[
83
]
=
{
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
}
;
#
define
REJECT
reject_used_but_not_detected
#
define
yymore
(
)
yymore_used_but_not_detected
#
define
YY_MORE_ADJ
0
#
define
YY_RESTORE_YY_MORE_OFFSET
#
line
1
"
sksl
.
flex
"
#
define
YY_NO_UNISTD_H
1
#
line
598
"
lex
.
sksl
.
c
"
#
define
INITIAL
0
#
ifndef
YY_NO_UNISTD_H
#
include
<
unistd
.
h
>
#
endif
#
ifndef
YY_EXTRA_TYPE
#
define
YY_EXTRA_TYPE
void
*
#
endif
struct
yyguts_t
{
YY_EXTRA_TYPE
yyextra_r
;
FILE
*
yyin_r
*
yyout_r
;
size_t
yy_buffer_stack_top
;
size_t
yy_buffer_stack_max
;
YY_BUFFER_STATE
*
yy_buffer_stack
;
char
yy_hold_char
;
yy_size_t
yy_n_chars
;
yy_size_t
yyleng_r
;
char
*
yy_c_buf_p
;
int
yy_init
;
int
yy_start
;
int
yy_did_buffer_switch_on_eof
;
int
yy_start_stack_ptr
;
int
yy_start_stack_depth
;
int
*
yy_start_stack
;
yy_state_type
yy_last_accepting_state
;
char
*
yy_last_accepting_cpos
;
int
yylineno_r
;
int
yy_flex_debug_r
;
char
*
yytext_r
;
int
yy_more_flag
;
int
yy_more_len
;
}
;
static
int
yy_init_globals
(
yyscan_t
yyscanner
)
;
int
sksllex_init
(
yyscan_t
*
scanner
)
;
int
sksllex_init_extra
(
YY_EXTRA_TYPE
user_defined
yyscan_t
*
scanner
)
;
int
sksllex_destroy
(
yyscan_t
yyscanner
)
;
int
skslget_debug
(
yyscan_t
yyscanner
)
;
void
skslset_debug
(
int
debug_flag
yyscan_t
yyscanner
)
;
YY_EXTRA_TYPE
skslget_extra
(
yyscan_t
yyscanner
)
;
void
skslset_extra
(
YY_EXTRA_TYPE
user_defined
yyscan_t
yyscanner
)
;
FILE
*
skslget_in
(
yyscan_t
yyscanner
)
;
void
skslset_in
(
FILE
*
in_str
yyscan_t
yyscanner
)
;
FILE
*
skslget_out
(
yyscan_t
yyscanner
)
;
void
skslset_out
(
FILE
*
out_str
yyscan_t
yyscanner
)
;
yy_size_t
skslget_leng
(
yyscan_t
yyscanner
)
;
char
*
skslget_text
(
yyscan_t
yyscanner
)
;
int
skslget_lineno
(
yyscan_t
yyscanner
)
;
void
skslset_lineno
(
int
line_number
yyscan_t
yyscanner
)
;
int
skslget_column
(
yyscan_t
yyscanner
)
;
void
skslset_column
(
int
column_no
yyscan_t
yyscanner
)
;
#
ifndef
YY_SKIP_YYWRAP
#
ifdef
__cplusplus
extern
"
C
"
int
skslwrap
(
yyscan_t
yyscanner
)
;
#
else
extern
int
skslwrap
(
yyscan_t
yyscanner
)
;
#
endif
#
endif
static
void
yyunput
(
int
c
char
*
buf_ptr
yyscan_t
yyscanner
)
;
#
ifndef
yytext_ptr
static
void
yy_flex_strncpy
(
char
*
yyconst
char
*
int
yyscan_t
yyscanner
)
;
#
endif
#
ifdef
YY_NEED_STRLEN
static
int
yy_flex_strlen
(
yyconst
char
*
yyscan_t
yyscanner
)
;
#
endif
#
ifndef
YY_NO_INPUT
#
ifdef
__cplusplus
static
int
yyinput
(
yyscan_t
yyscanner
)
;
#
else
static
int
input
(
yyscan_t
yyscanner
)
;
#
endif
#
endif
#
ifndef
YY_READ_BUF_SIZE
#
define
YY_READ_BUF_SIZE
8192
#
endif
#
ifndef
ECHO
#
define
ECHO
do
{
if
(
fwrite
(
yytext
yyleng
1
yyout
)
)
{
}
}
while
(
0
)
#
endif
#
ifndef
YY_INPUT
#
define
YY_INPUT
(
buf
result
max_size
)
\
if
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_is_interactive
)
\
{
\
int
c
=
'
*
'
;
\
size_t
n
;
\
for
(
n
=
0
;
n
<
max_size
&
&
\
(
c
=
getc
(
yyin
)
)
!
=
EOF
&
&
c
!
=
'
\
n
'
;
+
+
n
)
\
buf
[
n
]
=
(
char
)
c
;
\
if
(
c
=
=
'
\
n
'
)
\
buf
[
n
+
+
]
=
(
char
)
c
;
\
if
(
c
=
=
EOF
&
&
ferror
(
yyin
)
)
\
YY_FATAL_ERROR
(
"
input
in
flex
scanner
failed
"
)
;
\
result
=
n
;
\
}
\
else
\
{
\
errno
=
0
;
\
while
(
(
result
=
fread
(
buf
1
max_size
yyin
)
)
=
=
0
&
&
ferror
(
yyin
)
)
\
{
\
if
(
errno
!
=
EINTR
)
\
{
\
YY_FATAL_ERROR
(
"
input
in
flex
scanner
failed
"
)
;
\
break
;
\
}
\
errno
=
0
;
\
clearerr
(
yyin
)
;
\
}
\
}
\
\
#
endif
#
ifndef
yyterminate
#
define
yyterminate
(
)
return
YY_NULL
#
endif
#
ifndef
YY_START_STACK_INCR
#
define
YY_START_STACK_INCR
25
#
endif
#
ifndef
YY_FATAL_ERROR
#
define
YY_FATAL_ERROR
(
msg
)
yy_fatal_error
(
msg
yyscanner
)
#
endif
#
ifndef
YY_DECL
#
define
YY_DECL_IS_OURS
1
extern
int
sksllex
(
yyscan_t
yyscanner
)
;
#
define
YY_DECL
int
sksllex
(
yyscan_t
yyscanner
)
#
endif
#
ifndef
YY_USER_ACTION
#
define
YY_USER_ACTION
#
endif
#
ifndef
YY_BREAK
#
define
YY_BREAK
break
;
#
endif
#
define
YY_RULE_SETUP
\
YY_USER_ACTION
YY_DECL
{
register
yy_state_type
yy_current_state
;
register
char
*
yy_cp
*
yy_bp
;
register
int
yy_act
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
#
line
23
"
sksl
.
flex
"
#
line
826
"
lex
.
sksl
.
c
"
if
(
!
yyg
-
>
yy_init
)
{
yyg
-
>
yy_init
=
1
;
#
ifdef
YY_USER_INIT
YY_USER_INIT
;
#
endif
if
(
!
yyg
-
>
yy_start
)
yyg
-
>
yy_start
=
1
;
if
(
!
yyin
)
yyin
=
stdin
;
if
(
!
yyout
)
yyout
=
stdout
;
if
(
!
YY_CURRENT_BUFFER
)
{
skslensure_buffer_stack
(
yyscanner
)
;
YY_CURRENT_BUFFER_LVALUE
=
sksl_create_buffer
(
yyin
YY_BUF_SIZE
yyscanner
)
;
}
sksl_load_buffer_state
(
yyscanner
)
;
}
while
(
1
)
{
yy_cp
=
yyg
-
>
yy_c_buf_p
;
*
yy_cp
=
yyg
-
>
yy_hold_char
;
yy_bp
=
yy_cp
;
yy_current_state
=
yyg
-
>
yy_start
;
yy_match
:
do
{
register
YY_CHAR
yy_c
=
yy_ec
[
YY_SC_TO_UI
(
*
yy_cp
)
]
;
if
(
yy_accept
[
yy_current_state
]
)
{
yyg
-
>
yy_last_accepting_state
=
yy_current_state
;
yyg
-
>
yy_last_accepting_cpos
=
yy_cp
;
}
while
(
yy_chk
[
yy_base
[
yy_current_state
]
+
yy_c
]
!
=
yy_current_state
)
{
yy_current_state
=
(
int
)
yy_def
[
yy_current_state
]
;
if
(
yy_current_state
>
=
201
)
yy_c
=
yy_meta
[
(
unsigned
int
)
yy_c
]
;
}
yy_current_state
=
yy_nxt
[
yy_base
[
yy_current_state
]
+
(
unsigned
int
)
yy_c
]
;
+
+
yy_cp
;
}
while
(
yy_current_state
!
=
200
)
;
yy_cp
=
yyg
-
>
yy_last_accepting_cpos
;
yy_current_state
=
yyg
-
>
yy_last_accepting_state
;
yy_find_action
:
yy_act
=
yy_accept
[
yy_current_state
]
;
YY_DO_BEFORE_ACTION
;
if
(
yy_act
!
=
YY_END_OF_BUFFER
&
&
yy_rule_can_match_eol
[
yy_act
]
)
{
int
yyl
;
for
(
yyl
=
0
;
yyl
<
yyleng
;
+
+
yyl
)
if
(
yytext
[
yyl
]
=
=
'
\
n
'
)
do
{
yylineno
+
+
;
yycolumn
=
0
;
}
while
(
0
)
;
}
do_action
:
switch
(
yy_act
)
{
case
0
:
*
yy_cp
=
yyg
-
>
yy_hold_char
;
yy_cp
=
yyg
-
>
yy_last_accepting_cpos
;
yy_current_state
=
yyg
-
>
yy_last_accepting_state
;
goto
yy_find_action
;
case
1
:
YY_RULE_SETUP
#
line
25
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
FLOAT_LITERAL
;
}
YY_BREAK
case
2
:
YY_RULE_SETUP
#
line
27
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
FLOAT_LITERAL
;
}
YY_BREAK
case
3
:
YY_RULE_SETUP
#
line
29
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
FLOAT_LITERAL
;
}
YY_BREAK
case
4
:
YY_RULE_SETUP
#
line
31
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
INT_LITERAL
;
}
YY_BREAK
case
5
:
YY_RULE_SETUP
#
line
33
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
TRUE_LITERAL
;
}
YY_BREAK
case
6
:
YY_RULE_SETUP
#
line
35
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
FALSE_LITERAL
;
}
YY_BREAK
case
7
:
YY_RULE_SETUP
#
line
37
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
IF
;
}
YY_BREAK
case
8
:
YY_RULE_SETUP
#
line
39
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
ELSE
;
}
YY_BREAK
case
9
:
YY_RULE_SETUP
#
line
41
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
FOR
;
}
YY_BREAK
case
10
:
YY_RULE_SETUP
#
line
43
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
WHILE
;
}
YY_BREAK
case
11
:
YY_RULE_SETUP
#
line
45
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
DO
;
}
YY_BREAK
case
12
:
YY_RULE_SETUP
#
line
47
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
BREAK
;
}
YY_BREAK
case
13
:
YY_RULE_SETUP
#
line
49
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
CONTINUE
;
}
YY_BREAK
case
14
:
YY_RULE_SETUP
#
line
51
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
DISCARD
;
}
YY_BREAK
case
15
:
YY_RULE_SETUP
#
line
53
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
RETURN
;
}
YY_BREAK
case
16
:
YY_RULE_SETUP
#
line
55
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
IN
;
}
YY_BREAK
case
17
:
YY_RULE_SETUP
#
line
57
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
OUT
;
}
YY_BREAK
case
18
:
YY_RULE_SETUP
#
line
59
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
INOUT
;
}
YY_BREAK
case
19
:
YY_RULE_SETUP
#
line
61
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
UNIFORM
;
}
YY_BREAK
case
20
:
YY_RULE_SETUP
#
line
63
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
CONST
;
}
YY_BREAK
case
21
:
YY_RULE_SETUP
#
line
65
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LOWP
;
}
YY_BREAK
case
22
:
YY_RULE_SETUP
#
line
67
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
MEDIUMP
;
}
YY_BREAK
case
23
:
YY_RULE_SETUP
#
line
69
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
HIGHP
;
}
YY_BREAK
case
24
:
YY_RULE_SETUP
#
line
71
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
FLAT
;
}
YY_BREAK
case
25
:
YY_RULE_SETUP
#
line
73
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
NOPERSPECTIVE
;
}
YY_BREAK
case
26
:
YY_RULE_SETUP
#
line
75
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
STRUCT
;
}
YY_BREAK
case
27
:
YY_RULE_SETUP
#
line
77
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LAYOUT
;
}
YY_BREAK
case
28
:
YY_RULE_SETUP
#
line
79
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
PRECISION
;
}
YY_BREAK
case
29
:
YY_RULE_SETUP
#
line
81
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
IDENTIFIER
;
}
YY_BREAK
case
30
:
YY_RULE_SETUP
#
line
83
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
DIRECTIVE
;
}
YY_BREAK
case
31
:
YY_RULE_SETUP
#
line
85
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LPAREN
;
}
YY_BREAK
case
32
:
YY_RULE_SETUP
#
line
87
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
RPAREN
;
}
YY_BREAK
case
33
:
YY_RULE_SETUP
#
line
89
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LBRACE
;
}
YY_BREAK
case
34
:
YY_RULE_SETUP
#
line
91
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
RBRACE
;
}
YY_BREAK
case
35
:
YY_RULE_SETUP
#
line
93
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LBRACKET
;
}
YY_BREAK
case
36
:
YY_RULE_SETUP
#
line
95
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
RBRACKET
;
}
YY_BREAK
case
37
:
YY_RULE_SETUP
#
line
97
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
DOT
;
}
YY_BREAK
case
38
:
YY_RULE_SETUP
#
line
99
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
COMMA
;
}
YY_BREAK
case
39
:
YY_RULE_SETUP
#
line
101
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
PLUSPLUS
;
}
YY_BREAK
case
40
:
YY_RULE_SETUP
#
line
103
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
MINUSMINUS
;
}
YY_BREAK
case
41
:
YY_RULE_SETUP
#
line
105
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
PLUS
;
}
YY_BREAK
case
42
:
YY_RULE_SETUP
#
line
107
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
MINUS
;
}
YY_BREAK
case
43
:
YY_RULE_SETUP
#
line
109
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
STAR
;
}
YY_BREAK
case
44
:
YY_RULE_SETUP
#
line
111
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
SLASH
;
}
YY_BREAK
case
45
:
YY_RULE_SETUP
#
line
113
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
PERCENT
;
}
YY_BREAK
case
46
:
YY_RULE_SETUP
#
line
115
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
SHL
;
}
YY_BREAK
case
47
:
YY_RULE_SETUP
#
line
117
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
SHR
;
}
YY_BREAK
case
48
:
YY_RULE_SETUP
#
line
119
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
BITWISEOR
;
}
YY_BREAK
case
49
:
YY_RULE_SETUP
#
line
121
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
BITWISEXOR
;
}
YY_BREAK
case
50
:
YY_RULE_SETUP
#
line
123
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
BITWISEAND
;
}
YY_BREAK
case
51
:
YY_RULE_SETUP
#
line
125
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LOGICALOR
;
}
YY_BREAK
case
52
:
YY_RULE_SETUP
#
line
127
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LOGICALXOR
;
}
YY_BREAK
case
53
:
YY_RULE_SETUP
#
line
129
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LOGICALAND
;
}
YY_BREAK
case
54
:
YY_RULE_SETUP
#
line
131
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
NOT
;
}
YY_BREAK
case
55
:
YY_RULE_SETUP
#
line
133
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
QUESTION
;
}
YY_BREAK
case
56
:
YY_RULE_SETUP
#
line
135
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
COLON
;
}
YY_BREAK
case
57
:
YY_RULE_SETUP
#
line
137
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
EQ
;
}
YY_BREAK
case
58
:
YY_RULE_SETUP
#
line
139
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
EQEQ
;
}
YY_BREAK
case
59
:
YY_RULE_SETUP
#
line
141
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
NEQ
;
}
YY_BREAK
case
60
:
YY_RULE_SETUP
#
line
143
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
GT
;
}
YY_BREAK
case
61
:
YY_RULE_SETUP
#
line
145
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LT
;
}
YY_BREAK
case
62
:
YY_RULE_SETUP
#
line
147
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
GTEQ
;
}
YY_BREAK
case
63
:
YY_RULE_SETUP
#
line
149
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LTEQ
;
}
YY_BREAK
case
64
:
YY_RULE_SETUP
#
line
151
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
PLUSEQ
;
}
YY_BREAK
case
65
:
YY_RULE_SETUP
#
line
153
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
MINUSEQ
;
}
YY_BREAK
case
66
:
YY_RULE_SETUP
#
line
155
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
STAREQ
;
}
YY_BREAK
case
67
:
YY_RULE_SETUP
#
line
157
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
SLASHEQ
;
}
YY_BREAK
case
68
:
YY_RULE_SETUP
#
line
159
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
PERCENTEQ
;
}
YY_BREAK
case
69
:
YY_RULE_SETUP
#
line
161
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
SHLEQ
;
}
YY_BREAK
case
70
:
YY_RULE_SETUP
#
line
163
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
SHREQ
;
}
YY_BREAK
case
71
:
YY_RULE_SETUP
#
line
165
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
BITWISEOREQ
;
}
YY_BREAK
case
72
:
YY_RULE_SETUP
#
line
167
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
BITWISEXOREQ
;
}
YY_BREAK
case
73
:
YY_RULE_SETUP
#
line
169
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
BITWISEANDEQ
;
}
YY_BREAK
case
74
:
YY_RULE_SETUP
#
line
171
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LOGICALOREQ
;
}
YY_BREAK
case
75
:
YY_RULE_SETUP
#
line
173
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LOGICALXOREQ
;
}
YY_BREAK
case
76
:
YY_RULE_SETUP
#
line
175
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LOGICALANDEQ
;
}
YY_BREAK
case
77
:
YY_RULE_SETUP
#
line
177
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
SEMICOLON
;
}
YY_BREAK
case
78
:
YY_RULE_SETUP
#
line
179
"
sksl
.
flex
"
YY_BREAK
case
79
:
YY_RULE_SETUP
#
line
181
"
sksl
.
flex
"
YY_BREAK
case
80
:
YY_RULE_SETUP
#
line
183
"
sksl
.
flex
"
YY_BREAK
case
81
:
YY_RULE_SETUP
#
line
185
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
INVALID_TOKEN
;
}
YY_BREAK
case
82
:
YY_RULE_SETUP
#
line
187
"
sksl
.
flex
"
ECHO
;
YY_BREAK
#
line
1329
"
lex
.
sksl
.
c
"
case
YY_STATE_EOF
(
INITIAL
)
:
yyterminate
(
)
;
case
YY_END_OF_BUFFER
:
{
int
yy_amount_of_matched_text
=
(
int
)
(
yy_cp
-
yyg
-
>
yytext_ptr
)
-
1
;
*
yy_cp
=
yyg
-
>
yy_hold_char
;
YY_RESTORE_YY_MORE_OFFSET
if
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buffer_status
=
=
YY_BUFFER_NEW
)
{
yyg
-
>
yy_n_chars
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_input_file
=
yyin
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buffer_status
=
YY_BUFFER_NORMAL
;
}
if
(
yyg
-
>
yy_c_buf_p
<
=
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
]
)
{
yy_state_type
yy_next_state
;
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yytext_ptr
+
yy_amount_of_matched_text
;
yy_current_state
=
yy_get_previous_state
(
yyscanner
)
;
yy_next_state
=
yy_try_NUL_trans
(
yy_current_state
yyscanner
)
;
yy_bp
=
yyg
-
>
yytext_ptr
+
YY_MORE_ADJ
;
if
(
yy_next_state
)
{
yy_cp
=
+
+
yyg
-
>
yy_c_buf_p
;
yy_current_state
=
yy_next_state
;
goto
yy_match
;
}
else
{
yy_cp
=
yyg
-
>
yy_last_accepting_cpos
;
yy_current_state
=
yyg
-
>
yy_last_accepting_state
;
goto
yy_find_action
;
}
}
else
switch
(
yy_get_next_buffer
(
yyscanner
)
)
{
case
EOB_ACT_END_OF_FILE
:
{
yyg
-
>
yy_did_buffer_switch_on_eof
=
0
;
if
(
skslwrap
(
yyscanner
)
)
{
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yytext_ptr
+
YY_MORE_ADJ
;
yy_act
=
YY_STATE_EOF
(
YY_START
)
;
goto
do_action
;
}
else
{
if
(
!
yyg
-
>
yy_did_buffer_switch_on_eof
)
YY_NEW_FILE
;
}
break
;
}
case
EOB_ACT_CONTINUE_SCAN
:
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yytext_ptr
+
yy_amount_of_matched_text
;
yy_current_state
=
yy_get_previous_state
(
yyscanner
)
;
yy_cp
=
yyg
-
>
yy_c_buf_p
;
yy_bp
=
yyg
-
>
yytext_ptr
+
YY_MORE_ADJ
;
goto
yy_match
;
case
EOB_ACT_LAST_MATCH
:
yyg
-
>
yy_c_buf_p
=
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
]
;
yy_current_state
=
yy_get_previous_state
(
yyscanner
)
;
yy_cp
=
yyg
-
>
yy_c_buf_p
;
yy_bp
=
yyg
-
>
yytext_ptr
+
YY_MORE_ADJ
;
goto
yy_find_action
;
}
break
;
}
default
:
YY_FATAL_ERROR
(
"
fatal
flex
scanner
internal
error
-
-
no
action
found
"
)
;
}
}
}
static
int
yy_get_next_buffer
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
register
char
*
dest
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
;
register
char
*
source
=
yyg
-
>
yytext_ptr
;
register
int
number_to_move
i
;
int
ret_val
;
if
(
yyg
-
>
yy_c_buf_p
>
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
+
1
]
)
YY_FATAL_ERROR
(
"
fatal
flex
scanner
internal
error
-
-
end
of
buffer
missed
"
)
;
if
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_fill_buffer
=
=
0
)
{
if
(
yyg
-
>
yy_c_buf_p
-
yyg
-
>
yytext_ptr
-
YY_MORE_ADJ
=
=
1
)
{
return
EOB_ACT_END_OF_FILE
;
}
else
{
return
EOB_ACT_LAST_MATCH
;
}
}
number_to_move
=
(
int
)
(
yyg
-
>
yy_c_buf_p
-
yyg
-
>
yytext_ptr
)
-
1
;
for
(
i
=
0
;
i
<
number_to_move
;
+
+
i
)
*
(
dest
+
+
)
=
*
(
source
+
+
)
;
if
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buffer_status
=
=
YY_BUFFER_EOF_PENDING
)
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
=
yyg
-
>
yy_n_chars
=
0
;
else
{
yy_size_t
num_to_read
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_size
-
number_to_move
-
1
;
while
(
num_to_read
<
=
0
)
{
YY_BUFFER_STATE
b
=
YY_CURRENT_BUFFER_LVALUE
;
int
yy_c_buf_p_offset
=
(
int
)
(
yyg
-
>
yy_c_buf_p
-
b
-
>
yy_ch_buf
)
;
if
(
b
-
>
yy_is_our_buffer
)
{
yy_size_t
new_size
=
b
-
>
yy_buf_size
*
2
;
if
(
new_size
<
=
0
)
b
-
>
yy_buf_size
+
=
b
-
>
yy_buf_size
/
8
;
else
b
-
>
yy_buf_size
*
=
2
;
b
-
>
yy_ch_buf
=
(
char
*
)
skslrealloc
(
(
void
*
)
b
-
>
yy_ch_buf
b
-
>
yy_buf_size
+
2
yyscanner
)
;
}
else
b
-
>
yy_ch_buf
=
0
;
if
(
!
b
-
>
yy_ch_buf
)
YY_FATAL_ERROR
(
"
fatal
error
-
scanner
input
buffer
overflow
"
)
;
yyg
-
>
yy_c_buf_p
=
&
b
-
>
yy_ch_buf
[
yy_c_buf_p_offset
]
;
num_to_read
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_size
-
number_to_move
-
1
;
}
if
(
num_to_read
>
YY_READ_BUF_SIZE
)
num_to_read
=
YY_READ_BUF_SIZE
;
YY_INPUT
(
(
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
number_to_move
]
)
yyg
-
>
yy_n_chars
num_to_read
)
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
=
yyg
-
>
yy_n_chars
;
}
if
(
yyg
-
>
yy_n_chars
=
=
0
)
{
if
(
number_to_move
=
=
YY_MORE_ADJ
)
{
ret_val
=
EOB_ACT_END_OF_FILE
;
skslrestart
(
yyin
yyscanner
)
;
}
else
{
ret_val
=
EOB_ACT_LAST_MATCH
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buffer_status
=
YY_BUFFER_EOF_PENDING
;
}
}
else
ret_val
=
EOB_ACT_CONTINUE_SCAN
;
if
(
(
yy_size_t
)
(
yyg
-
>
yy_n_chars
+
number_to_move
)
>
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_size
)
{
yy_size_t
new_size
=
yyg
-
>
yy_n_chars
+
number_to_move
+
(
yyg
-
>
yy_n_chars
>
>
1
)
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
=
(
char
*
)
skslrealloc
(
(
void
*
)
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
new_size
yyscanner
)
;
if
(
!
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
yy_get_next_buffer
(
)
"
)
;
}
yyg
-
>
yy_n_chars
+
=
number_to_move
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
]
=
YY_END_OF_BUFFER_CHAR
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
+
1
]
=
YY_END_OF_BUFFER_CHAR
;
yyg
-
>
yytext_ptr
=
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
0
]
;
return
ret_val
;
}
static
yy_state_type
yy_get_previous_state
(
yyscan_t
yyscanner
)
{
register
yy_state_type
yy_current_state
;
register
char
*
yy_cp
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yy_current_state
=
yyg
-
>
yy_start
;
for
(
yy_cp
=
yyg
-
>
yytext_ptr
+
YY_MORE_ADJ
;
yy_cp
<
yyg
-
>
yy_c_buf_p
;
+
+
yy_cp
)
{
register
YY_CHAR
yy_c
=
(
*
yy_cp
?
yy_ec
[
YY_SC_TO_UI
(
*
yy_cp
)
]
:
1
)
;
if
(
yy_accept
[
yy_current_state
]
)
{
yyg
-
>
yy_last_accepting_state
=
yy_current_state
;
yyg
-
>
yy_last_accepting_cpos
=
yy_cp
;
}
while
(
yy_chk
[
yy_base
[
yy_current_state
]
+
yy_c
]
!
=
yy_current_state
)
{
yy_current_state
=
(
int
)
yy_def
[
yy_current_state
]
;
if
(
yy_current_state
>
=
201
)
yy_c
=
yy_meta
[
(
unsigned
int
)
yy_c
]
;
}
yy_current_state
=
yy_nxt
[
yy_base
[
yy_current_state
]
+
(
unsigned
int
)
yy_c
]
;
}
return
yy_current_state
;
}
static
yy_state_type
yy_try_NUL_trans
(
yy_state_type
yy_current_state
yyscan_t
yyscanner
)
{
register
int
yy_is_jam
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
register
char
*
yy_cp
=
yyg
-
>
yy_c_buf_p
;
register
YY_CHAR
yy_c
=
1
;
if
(
yy_accept
[
yy_current_state
]
)
{
yyg
-
>
yy_last_accepting_state
=
yy_current_state
;
yyg
-
>
yy_last_accepting_cpos
=
yy_cp
;
}
while
(
yy_chk
[
yy_base
[
yy_current_state
]
+
yy_c
]
!
=
yy_current_state
)
{
yy_current_state
=
(
int
)
yy_def
[
yy_current_state
]
;
if
(
yy_current_state
>
=
201
)
yy_c
=
yy_meta
[
(
unsigned
int
)
yy_c
]
;
}
yy_current_state
=
yy_nxt
[
yy_base
[
yy_current_state
]
+
(
unsigned
int
)
yy_c
]
;
yy_is_jam
=
(
yy_current_state
=
=
200
)
;
(
void
)
yyg
;
return
yy_is_jam
?
0
:
yy_current_state
;
}
static
void
yyunput
(
int
c
register
char
*
yy_bp
yyscan_t
yyscanner
)
{
register
char
*
yy_cp
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yy_cp
=
yyg
-
>
yy_c_buf_p
;
*
yy_cp
=
yyg
-
>
yy_hold_char
;
if
(
yy_cp
<
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
+
2
)
{
register
yy_size_t
number_to_move
=
yyg
-
>
yy_n_chars
+
2
;
register
char
*
dest
=
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_size
+
2
]
;
register
char
*
source
=
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
number_to_move
]
;
while
(
source
>
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
)
*
-
-
dest
=
*
-
-
source
;
yy_cp
+
=
(
int
)
(
dest
-
source
)
;
yy_bp
+
=
(
int
)
(
dest
-
source
)
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
=
yyg
-
>
yy_n_chars
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_size
;
if
(
yy_cp
<
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
+
2
)
YY_FATAL_ERROR
(
"
flex
scanner
push
-
back
overflow
"
)
;
}
*
-
-
yy_cp
=
(
char
)
c
;
if
(
c
=
=
'
\
n
'
)
{
-
-
yylineno
;
}
yyg
-
>
yytext_ptr
=
yy_bp
;
yyg
-
>
yy_hold_char
=
*
yy_cp
;
yyg
-
>
yy_c_buf_p
=
yy_cp
;
}
#
ifndef
YY_NO_INPUT
#
ifdef
__cplusplus
static
int
yyinput
(
yyscan_t
yyscanner
)
#
else
static
int
input
(
yyscan_t
yyscanner
)
#
endif
{
int
c
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
*
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yy_hold_char
;
if
(
*
yyg
-
>
yy_c_buf_p
=
=
YY_END_OF_BUFFER_CHAR
)
{
if
(
yyg
-
>
yy_c_buf_p
<
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
]
)
*
yyg
-
>
yy_c_buf_p
=
'
\
0
'
;
else
{
yy_size_t
offset
=
yyg
-
>
yy_c_buf_p
-
yyg
-
>
yytext_ptr
;
+
+
yyg
-
>
yy_c_buf_p
;
switch
(
yy_get_next_buffer
(
yyscanner
)
)
{
case
EOB_ACT_LAST_MATCH
:
skslrestart
(
yyin
yyscanner
)
;
case
EOB_ACT_END_OF_FILE
:
{
if
(
skslwrap
(
yyscanner
)
)
return
EOF
;
if
(
!
yyg
-
>
yy_did_buffer_switch_on_eof
)
YY_NEW_FILE
;
#
ifdef
__cplusplus
return
yyinput
(
yyscanner
)
;
#
else
return
input
(
yyscanner
)
;
#
endif
}
case
EOB_ACT_CONTINUE_SCAN
:
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yytext_ptr
+
offset
;
break
;
}
}
}
c
=
*
(
unsigned
char
*
)
yyg
-
>
yy_c_buf_p
;
*
yyg
-
>
yy_c_buf_p
=
'
\
0
'
;
yyg
-
>
yy_hold_char
=
*
+
+
yyg
-
>
yy_c_buf_p
;
if
(
c
=
=
'
\
n
'
)
do
{
yylineno
+
+
;
yycolumn
=
0
;
}
while
(
0
)
;
return
c
;
}
#
endif
void
skslrestart
(
FILE
*
input_file
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
{
skslensure_buffer_stack
(
yyscanner
)
;
YY_CURRENT_BUFFER_LVALUE
=
sksl_create_buffer
(
yyin
YY_BUF_SIZE
yyscanner
)
;
}
sksl_init_buffer
(
YY_CURRENT_BUFFER
input_file
yyscanner
)
;
sksl_load_buffer_state
(
yyscanner
)
;
}
void
sksl_switch_to_buffer
(
YY_BUFFER_STATE
new_buffer
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
skslensure_buffer_stack
(
yyscanner
)
;
if
(
YY_CURRENT_BUFFER
=
=
new_buffer
)
return
;
if
(
YY_CURRENT_BUFFER
)
{
*
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yy_hold_char
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_pos
=
yyg
-
>
yy_c_buf_p
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
=
yyg
-
>
yy_n_chars
;
}
YY_CURRENT_BUFFER_LVALUE
=
new_buffer
;
sksl_load_buffer_state
(
yyscanner
)
;
yyg
-
>
yy_did_buffer_switch_on_eof
=
1
;
}
static
void
sksl_load_buffer_state
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yyg
-
>
yy_n_chars
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
;
yyg
-
>
yytext_ptr
=
yyg
-
>
yy_c_buf_p
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_pos
;
yyin
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_input_file
;
yyg
-
>
yy_hold_char
=
*
yyg
-
>
yy_c_buf_p
;
}
YY_BUFFER_STATE
sksl_create_buffer
(
FILE
*
file
int
size
yyscan_t
yyscanner
)
{
YY_BUFFER_STATE
b
;
b
=
(
YY_BUFFER_STATE
)
skslalloc
(
sizeof
(
struct
yy_buffer_state
)
yyscanner
)
;
if
(
!
b
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
sksl_create_buffer
(
)
"
)
;
b
-
>
yy_buf_size
=
size
;
b
-
>
yy_ch_buf
=
(
char
*
)
skslalloc
(
b
-
>
yy_buf_size
+
2
yyscanner
)
;
if
(
!
b
-
>
yy_ch_buf
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
sksl_create_buffer
(
)
"
)
;
b
-
>
yy_is_our_buffer
=
1
;
sksl_init_buffer
(
b
file
yyscanner
)
;
return
b
;
}
void
sksl_delete_buffer
(
YY_BUFFER_STATE
b
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
b
)
return
;
if
(
b
=
=
YY_CURRENT_BUFFER
)
YY_CURRENT_BUFFER_LVALUE
=
(
YY_BUFFER_STATE
)
0
;
if
(
b
-
>
yy_is_our_buffer
)
skslfree
(
(
void
*
)
b
-
>
yy_ch_buf
yyscanner
)
;
skslfree
(
(
void
*
)
b
yyscanner
)
;
}
static
void
sksl_init_buffer
(
YY_BUFFER_STATE
b
FILE
*
file
yyscan_t
yyscanner
)
{
int
oerrno
=
errno
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
sksl_flush_buffer
(
b
yyscanner
)
;
b
-
>
yy_input_file
=
file
;
b
-
>
yy_fill_buffer
=
1
;
if
(
b
!
=
YY_CURRENT_BUFFER
)
{
b
-
>
yy_bs_lineno
=
1
;
b
-
>
yy_bs_column
=
0
;
}
b
-
>
yy_is_interactive
=
0
;
errno
=
oerrno
;
}
void
sksl_flush_buffer
(
YY_BUFFER_STATE
b
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
b
)
return
;
b
-
>
yy_n_chars
=
0
;
b
-
>
yy_ch_buf
[
0
]
=
YY_END_OF_BUFFER_CHAR
;
b
-
>
yy_ch_buf
[
1
]
=
YY_END_OF_BUFFER_CHAR
;
b
-
>
yy_buf_pos
=
&
b
-
>
yy_ch_buf
[
0
]
;
b
-
>
yy_at_bol
=
1
;
b
-
>
yy_buffer_status
=
YY_BUFFER_NEW
;
if
(
b
=
=
YY_CURRENT_BUFFER
)
sksl_load_buffer_state
(
yyscanner
)
;
}
void
skslpush_buffer_state
(
YY_BUFFER_STATE
new_buffer
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
new_buffer
=
=
NULL
)
return
;
skslensure_buffer_stack
(
yyscanner
)
;
if
(
YY_CURRENT_BUFFER
)
{
*
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yy_hold_char
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_pos
=
yyg
-
>
yy_c_buf_p
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
=
yyg
-
>
yy_n_chars
;
}
if
(
YY_CURRENT_BUFFER
)
yyg
-
>
yy_buffer_stack_top
+
+
;
YY_CURRENT_BUFFER_LVALUE
=
new_buffer
;
sksl_load_buffer_state
(
yyscanner
)
;
yyg
-
>
yy_did_buffer_switch_on_eof
=
1
;
}
void
skslpop_buffer_state
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
return
;
sksl_delete_buffer
(
YY_CURRENT_BUFFER
yyscanner
)
;
YY_CURRENT_BUFFER_LVALUE
=
NULL
;
if
(
yyg
-
>
yy_buffer_stack_top
>
0
)
-
-
yyg
-
>
yy_buffer_stack_top
;
if
(
YY_CURRENT_BUFFER
)
{
sksl_load_buffer_state
(
yyscanner
)
;
yyg
-
>
yy_did_buffer_switch_on_eof
=
1
;
}
}
static
void
skslensure_buffer_stack
(
yyscan_t
yyscanner
)
{
yy_size_t
num_to_alloc
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
yyg
-
>
yy_buffer_stack
)
{
num_to_alloc
=
1
;
yyg
-
>
yy_buffer_stack
=
(
struct
yy_buffer_state
*
*
)
skslalloc
(
num_to_alloc
*
sizeof
(
struct
yy_buffer_state
*
)
yyscanner
)
;
if
(
!
yyg
-
>
yy_buffer_stack
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
skslensure_buffer_stack
(
)
"
)
;
memset
(
yyg
-
>
yy_buffer_stack
0
num_to_alloc
*
sizeof
(
struct
yy_buffer_state
*
)
)
;
yyg
-
>
yy_buffer_stack_max
=
num_to_alloc
;
yyg
-
>
yy_buffer_stack_top
=
0
;
return
;
}
if
(
yyg
-
>
yy_buffer_stack_top
>
=
(
yyg
-
>
yy_buffer_stack_max
)
-
1
)
{
int
grow_size
=
8
;
num_to_alloc
=
yyg
-
>
yy_buffer_stack_max
+
grow_size
;
yyg
-
>
yy_buffer_stack
=
(
struct
yy_buffer_state
*
*
)
skslrealloc
(
yyg
-
>
yy_buffer_stack
num_to_alloc
*
sizeof
(
struct
yy_buffer_state
*
)
yyscanner
)
;
if
(
!
yyg
-
>
yy_buffer_stack
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
skslensure_buffer_stack
(
)
"
)
;
memset
(
yyg
-
>
yy_buffer_stack
+
yyg
-
>
yy_buffer_stack_max
0
grow_size
*
sizeof
(
struct
yy_buffer_state
*
)
)
;
yyg
-
>
yy_buffer_stack_max
=
num_to_alloc
;
}
}
YY_BUFFER_STATE
sksl_scan_buffer
(
char
*
base
yy_size_t
size
yyscan_t
yyscanner
)
{
YY_BUFFER_STATE
b
;
if
(
size
<
2
|
|
base
[
size
-
2
]
!
=
YY_END_OF_BUFFER_CHAR
|
|
base
[
size
-
1
]
!
=
YY_END_OF_BUFFER_CHAR
)
return
0
;
b
=
(
YY_BUFFER_STATE
)
skslalloc
(
sizeof
(
struct
yy_buffer_state
)
yyscanner
)
;
if
(
!
b
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
sksl_scan_buffer
(
)
"
)
;
b
-
>
yy_buf_size
=
size
-
2
;
b
-
>
yy_buf_pos
=
b
-
>
yy_ch_buf
=
base
;
b
-
>
yy_is_our_buffer
=
0
;
b
-
>
yy_input_file
=
0
;
b
-
>
yy_n_chars
=
b
-
>
yy_buf_size
;
b
-
>
yy_is_interactive
=
0
;
b
-
>
yy_at_bol
=
1
;
b
-
>
yy_fill_buffer
=
0
;
b
-
>
yy_buffer_status
=
YY_BUFFER_NEW
;
sksl_switch_to_buffer
(
b
yyscanner
)
;
return
b
;
}
YY_BUFFER_STATE
sksl_scan_string
(
yyconst
char
*
yystr
yyscan_t
yyscanner
)
{
return
sksl_scan_bytes
(
yystr
strlen
(
yystr
)
yyscanner
)
;
}
YY_BUFFER_STATE
sksl_scan_bytes
(
yyconst
char
*
yybytes
yy_size_t
_yybytes_len
yyscan_t
yyscanner
)
{
YY_BUFFER_STATE
b
;
char
*
buf
;
yy_size_t
n
;
int
i
;
n
=
_yybytes_len
+
2
;
buf
=
(
char
*
)
skslalloc
(
n
yyscanner
)
;
if
(
!
buf
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
sksl_scan_bytes
(
)
"
)
;
for
(
i
=
0
;
i
<
_yybytes_len
;
+
+
i
)
buf
[
i
]
=
yybytes
[
i
]
;
buf
[
_yybytes_len
]
=
buf
[
_yybytes_len
+
1
]
=
YY_END_OF_BUFFER_CHAR
;
b
=
sksl_scan_buffer
(
buf
n
yyscanner
)
;
if
(
!
b
)
YY_FATAL_ERROR
(
"
bad
buffer
in
sksl_scan_bytes
(
)
"
)
;
b
-
>
yy_is_our_buffer
=
1
;
return
b
;
}
#
ifndef
YY_EXIT_FAILURE
#
define
YY_EXIT_FAILURE
2
#
endif
static
void
yy_fatal_error
(
yyconst
char
*
msg
yyscan_t
yyscanner
)
{
(
void
)
fprintf
(
stderr
"
%
s
\
n
"
msg
)
;
exit
(
YY_EXIT_FAILURE
)
;
}
#
undef
yyless
#
define
yyless
(
n
)
\
do
\
{
\
/
*
Undo
effects
of
setting
up
yytext
.
*
/
\
int
yyless_macro_arg
=
(
n
)
;
\
YY_LESS_LINENO
(
yyless_macro_arg
)
;
\
yytext
[
yyleng
]
=
yyg
-
>
yy_hold_char
;
\
yyg
-
>
yy_c_buf_p
=
yytext
+
yyless_macro_arg
;
\
yyg
-
>
yy_hold_char
=
*
yyg
-
>
yy_c_buf_p
;
\
*
yyg
-
>
yy_c_buf_p
=
'
\
0
'
;
\
yyleng
=
yyless_macro_arg
;
\
}
\
while
(
0
)
YY_EXTRA_TYPE
skslget_extra
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yyextra
;
}
int
skslget_lineno
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
return
0
;
return
yylineno
;
}
int
skslget_column
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
return
0
;
return
yycolumn
;
}
FILE
*
skslget_in
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yyin
;
}
FILE
*
skslget_out
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yyout
;
}
yy_size_t
skslget_leng
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yyleng
;
}
char
*
skslget_text
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yytext
;
}
void
skslset_extra
(
YY_EXTRA_TYPE
user_defined
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yyextra
=
user_defined
;
}
void
skslset_lineno
(
int
line_number
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
YY_FATAL_ERROR
(
"
skslset_lineno
called
with
no
buffer
"
)
;
yylineno
=
line_number
;
}
void
skslset_column
(
int
column_no
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
YY_FATAL_ERROR
(
"
skslset_column
called
with
no
buffer
"
)
;
yycolumn
=
column_no
;
}
void
skslset_in
(
FILE
*
in_str
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yyin
=
in_str
;
}
void
skslset_out
(
FILE
*
out_str
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yyout
=
out_str
;
}
int
skslget_debug
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yy_flex_debug
;
}
void
skslset_debug
(
int
bdebug
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yy_flex_debug
=
bdebug
;
}
int
sksllex_init
(
yyscan_t
*
ptr_yy_globals
)
{
if
(
ptr_yy_globals
=
=
NULL
)
{
errno
=
EINVAL
;
return
1
;
}
*
ptr_yy_globals
=
(
yyscan_t
)
skslalloc
(
sizeof
(
struct
yyguts_t
)
NULL
)
;
if
(
*
ptr_yy_globals
=
=
NULL
)
{
errno
=
ENOMEM
;
return
1
;
}
memset
(
*
ptr_yy_globals
0x00
sizeof
(
struct
yyguts_t
)
)
;
return
yy_init_globals
(
*
ptr_yy_globals
)
;
}
int
sksllex_init_extra
(
YY_EXTRA_TYPE
yy_user_defined
yyscan_t
*
ptr_yy_globals
)
{
struct
yyguts_t
dummy_yyguts
;
skslset_extra
(
yy_user_defined
&
dummy_yyguts
)
;
if
(
ptr_yy_globals
=
=
NULL
)
{
errno
=
EINVAL
;
return
1
;
}
*
ptr_yy_globals
=
(
yyscan_t
)
skslalloc
(
sizeof
(
struct
yyguts_t
)
&
dummy_yyguts
)
;
if
(
*
ptr_yy_globals
=
=
NULL
)
{
errno
=
ENOMEM
;
return
1
;
}
memset
(
*
ptr_yy_globals
0x00
sizeof
(
struct
yyguts_t
)
)
;
skslset_extra
(
yy_user_defined
*
ptr_yy_globals
)
;
return
yy_init_globals
(
*
ptr_yy_globals
)
;
}
static
int
yy_init_globals
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yyg
-
>
yy_buffer_stack
=
0
;
yyg
-
>
yy_buffer_stack_top
=
0
;
yyg
-
>
yy_buffer_stack_max
=
0
;
yyg
-
>
yy_c_buf_p
=
(
char
*
)
0
;
yyg
-
>
yy_init
=
0
;
yyg
-
>
yy_start
=
0
;
yyg
-
>
yy_start_stack_ptr
=
0
;
yyg
-
>
yy_start_stack_depth
=
0
;
yyg
-
>
yy_start_stack
=
NULL
;
#
ifdef
YY_STDINIT
yyin
=
stdin
;
yyout
=
stdout
;
#
else
yyin
=
(
FILE
*
)
0
;
yyout
=
(
FILE
*
)
0
;
#
endif
return
0
;
}
int
sksllex_destroy
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
while
(
YY_CURRENT_BUFFER
)
{
sksl_delete_buffer
(
YY_CURRENT_BUFFER
yyscanner
)
;
YY_CURRENT_BUFFER_LVALUE
=
NULL
;
skslpop_buffer_state
(
yyscanner
)
;
}
skslfree
(
yyg
-
>
yy_buffer_stack
yyscanner
)
;
yyg
-
>
yy_buffer_stack
=
NULL
;
skslfree
(
yyg
-
>
yy_start_stack
yyscanner
)
;
yyg
-
>
yy_start_stack
=
NULL
;
yy_init_globals
(
yyscanner
)
;
skslfree
(
yyscanner
yyscanner
)
;
yyscanner
=
NULL
;
return
0
;
}
#
ifndef
yytext_ptr
static
void
yy_flex_strncpy
(
char
*
s1
yyconst
char
*
s2
int
n
yyscan_t
yyscanner
)
{
register
int
i
;
for
(
i
=
0
;
i
<
n
;
+
+
i
)
s1
[
i
]
=
s2
[
i
]
;
}
#
endif
#
ifdef
YY_NEED_STRLEN
static
int
yy_flex_strlen
(
yyconst
char
*
s
yyscan_t
yyscanner
)
{
register
int
n
;
for
(
n
=
0
;
s
[
n
]
;
+
+
n
)
;
return
n
;
}
#
endif
void
*
skslalloc
(
yy_size_t
size
yyscan_t
yyscanner
)
{
return
(
void
*
)
malloc
(
size
)
;
}
void
*
skslrealloc
(
void
*
ptr
yy_size_t
size
yyscan_t
yyscanner
)
{
return
(
void
*
)
realloc
(
(
char
*
)
ptr
size
)
;
}
void
skslfree
(
void
*
ptr
yyscan_t
yyscanner
)
{
free
(
(
char
*
)
ptr
)
;
}
#
define
YYTABLES_NAME
"
yytables
"
#
line
187
"
sksl
.
flex
"
int
skslwrap
(
yyscan_t
scanner
)
{
return
1
;
}
