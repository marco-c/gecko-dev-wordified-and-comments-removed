#
line
2
"
lex
.
sksl
.
c
"
#
define
YY_INT_ALIGNED
short
int
#
define
FLEX_SCANNER
#
define
YY_FLEX_MAJOR_VERSION
2
#
define
YY_FLEX_MINOR_VERSION
6
#
define
YY_FLEX_SUBMINOR_VERSION
3
#
if
YY_FLEX_SUBMINOR_VERSION
>
0
#
define
FLEX_BETA
#
endif
#
define
yy_create_buffer
sksl_create_buffer
#
define
yy_delete_buffer
sksl_delete_buffer
#
define
yy_scan_buffer
sksl_scan_buffer
#
define
yy_scan_string
sksl_scan_string
#
define
yy_scan_bytes
sksl_scan_bytes
#
define
yy_init_buffer
sksl_init_buffer
#
define
yy_flush_buffer
sksl_flush_buffer
#
define
yy_load_buffer_state
sksl_load_buffer_state
#
define
yy_switch_to_buffer
sksl_switch_to_buffer
#
define
yypush_buffer_state
skslpush_buffer_state
#
define
yypop_buffer_state
skslpop_buffer_state
#
define
yyensure_buffer_stack
skslensure_buffer_stack
#
define
yylex
sksllex
#
define
yyrestart
skslrestart
#
define
yylex_init
sksllex_init
#
define
yylex_init_extra
sksllex_init_extra
#
define
yylex_destroy
sksllex_destroy
#
define
yyget_debug
skslget_debug
#
define
yyset_debug
skslset_debug
#
define
yyget_extra
skslget_extra
#
define
yyset_extra
skslset_extra
#
define
yyget_in
skslget_in
#
define
yyset_in
skslset_in
#
define
yyget_out
skslget_out
#
define
yyset_out
skslset_out
#
define
yyget_leng
skslget_leng
#
define
yyget_text
skslget_text
#
define
yyget_lineno
skslget_lineno
#
define
yyset_lineno
skslset_lineno
#
define
yyget_column
skslget_column
#
define
yyset_column
skslset_column
#
define
yywrap
skslwrap
#
define
yyalloc
skslalloc
#
define
yyrealloc
skslrealloc
#
define
yyfree
skslfree
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
errno
.
h
>
#
include
<
stdlib
.
h
>
#
ifndef
FLEXINT_H
#
define
FLEXINT_H
#
if
defined
(
__STDC_VERSION__
)
&
&
__STDC_VERSION__
>
=
199901L
#
ifndef
__STDC_LIMIT_MACROS
#
define
__STDC_LIMIT_MACROS
1
#
endif
#
include
<
inttypes
.
h
>
typedef
int8_t
flex_int8_t
;
typedef
uint8_t
flex_uint8_t
;
typedef
int16_t
flex_int16_t
;
typedef
uint16_t
flex_uint16_t
;
typedef
int32_t
flex_int32_t
;
typedef
uint32_t
flex_uint32_t
;
#
else
typedef
signed
char
flex_int8_t
;
typedef
short
int
flex_int16_t
;
typedef
int
flex_int32_t
;
typedef
unsigned
char
flex_uint8_t
;
typedef
unsigned
short
int
flex_uint16_t
;
typedef
unsigned
int
flex_uint32_t
;
#
ifndef
INT8_MIN
#
define
INT8_MIN
(
-
128
)
#
endif
#
ifndef
INT16_MIN
#
define
INT16_MIN
(
-
32767
-
1
)
#
endif
#
ifndef
INT32_MIN
#
define
INT32_MIN
(
-
2147483647
-
1
)
#
endif
#
ifndef
INT8_MAX
#
define
INT8_MAX
(
127
)
#
endif
#
ifndef
INT16_MAX
#
define
INT16_MAX
(
32767
)
#
endif
#
ifndef
INT32_MAX
#
define
INT32_MAX
(
2147483647
)
#
endif
#
ifndef
UINT8_MAX
#
define
UINT8_MAX
(
255U
)
#
endif
#
ifndef
UINT16_MAX
#
define
UINT16_MAX
(
65535U
)
#
endif
#
ifndef
UINT32_MAX
#
define
UINT32_MAX
(
4294967295U
)
#
endif
#
endif
#
endif
#
define
yyconst
const
#
if
defined
(
__GNUC__
)
&
&
__GNUC__
>
=
3
#
define
yynoreturn
__attribute__
(
(
__noreturn__
)
)
#
else
#
define
yynoreturn
#
endif
#
define
YY_NULL
0
#
define
YY_SC_TO_UI
(
c
)
(
(
YY_CHAR
)
(
c
)
)
#
ifndef
YY_TYPEDEF_YY_SCANNER_T
#
define
YY_TYPEDEF_YY_SCANNER_T
typedef
void
*
yyscan_t
;
#
endif
#
define
yyin
yyg
-
>
yyin_r
#
define
yyout
yyg
-
>
yyout_r
#
define
yyextra
yyg
-
>
yyextra_r
#
define
yyleng
yyg
-
>
yyleng_r
#
define
yytext
yyg
-
>
yytext_r
#
define
yylineno
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_bs_lineno
)
#
define
yycolumn
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_bs_column
)
#
define
yy_flex_debug
yyg
-
>
yy_flex_debug_r
#
define
BEGIN
yyg
-
>
yy_start
=
1
+
2
*
#
define
YY_START
(
(
yyg
-
>
yy_start
-
1
)
/
2
)
#
define
YYSTATE
YY_START
#
define
YY_STATE_EOF
(
state
)
(
YY_END_OF_BUFFER
+
state
+
1
)
#
define
YY_NEW_FILE
skslrestart
(
yyin
yyscanner
)
#
define
YY_END_OF_BUFFER_CHAR
0
#
ifndef
YY_BUF_SIZE
#
ifdef
__ia64__
#
define
YY_BUF_SIZE
32768
#
else
#
define
YY_BUF_SIZE
16384
#
endif
#
endif
#
define
YY_STATE_BUF_SIZE
(
(
YY_BUF_SIZE
+
2
)
*
sizeof
(
yy_state_type
)
)
#
ifndef
YY_TYPEDEF_YY_BUFFER_STATE
#
define
YY_TYPEDEF_YY_BUFFER_STATE
typedef
struct
yy_buffer_state
*
YY_BUFFER_STATE
;
#
endif
#
ifndef
YY_TYPEDEF_YY_SIZE_T
#
define
YY_TYPEDEF_YY_SIZE_T
typedef
size_t
yy_size_t
;
#
endif
#
define
EOB_ACT_CONTINUE_SCAN
0
#
define
EOB_ACT_END_OF_FILE
1
#
define
EOB_ACT_LAST_MATCH
2
#
define
YY_LESS_LINENO
(
n
)
\
do
{
\
int
yyl
;
\
for
(
yyl
=
n
;
yyl
<
yyleng
;
+
+
yyl
)
\
if
(
yytext
[
yyl
]
=
=
'
\
n
'
)
\
-
-
yylineno
;
\
}
while
(
0
)
#
define
YY_LINENO_REWIND_TO
(
dst
)
\
do
{
\
const
char
*
p
;
\
for
(
p
=
yy_cp
-
1
;
p
>
=
(
dst
)
;
-
-
p
)
\
if
(
*
p
=
=
'
\
n
'
)
\
-
-
yylineno
;
\
}
while
(
0
)
#
define
yyless
(
n
)
\
do
\
{
\
/
*
Undo
effects
of
setting
up
yytext
.
*
/
\
int
yyless_macro_arg
=
(
n
)
;
\
YY_LESS_LINENO
(
yyless_macro_arg
)
;
\
*
yy_cp
=
yyg
-
>
yy_hold_char
;
\
YY_RESTORE_YY_MORE_OFFSET
\
yyg
-
>
yy_c_buf_p
=
yy_cp
=
yy_bp
+
yyless_macro_arg
-
YY_MORE_ADJ
;
\
YY_DO_BEFORE_ACTION
;
/
*
set
up
yytext
again
*
/
\
}
\
while
(
0
)
#
define
unput
(
c
)
yyunput
(
c
yyg
-
>
yytext_ptr
yyscanner
)
#
ifndef
YY_STRUCT_YY_BUFFER_STATE
#
define
YY_STRUCT_YY_BUFFER_STATE
struct
yy_buffer_state
{
FILE
*
yy_input_file
;
char
*
yy_ch_buf
;
char
*
yy_buf_pos
;
int
yy_buf_size
;
int
yy_n_chars
;
int
yy_is_our_buffer
;
int
yy_is_interactive
;
int
yy_at_bol
;
int
yy_bs_lineno
;
int
yy_bs_column
;
int
yy_fill_buffer
;
int
yy_buffer_status
;
#
define
YY_BUFFER_NEW
0
#
define
YY_BUFFER_NORMAL
1
#
define
YY_BUFFER_EOF_PENDING
2
}
;
#
endif
#
define
YY_CURRENT_BUFFER
(
yyg
-
>
yy_buffer_stack
\
?
yyg
-
>
yy_buffer_stack
[
yyg
-
>
yy_buffer_stack_top
]
\
:
NULL
)
#
define
YY_CURRENT_BUFFER_LVALUE
yyg
-
>
yy_buffer_stack
[
yyg
-
>
yy_buffer_stack_top
]
void
skslrestart
(
FILE
*
input_file
yyscan_t
yyscanner
)
;
void
sksl_switch_to_buffer
(
YY_BUFFER_STATE
new_buffer
yyscan_t
yyscanner
)
;
YY_BUFFER_STATE
sksl_create_buffer
(
FILE
*
file
int
size
yyscan_t
yyscanner
)
;
void
sksl_delete_buffer
(
YY_BUFFER_STATE
b
yyscan_t
yyscanner
)
;
void
sksl_flush_buffer
(
YY_BUFFER_STATE
b
yyscan_t
yyscanner
)
;
void
skslpush_buffer_state
(
YY_BUFFER_STATE
new_buffer
yyscan_t
yyscanner
)
;
void
skslpop_buffer_state
(
yyscan_t
yyscanner
)
;
static
void
skslensure_buffer_stack
(
yyscan_t
yyscanner
)
;
static
void
sksl_load_buffer_state
(
yyscan_t
yyscanner
)
;
static
void
sksl_init_buffer
(
YY_BUFFER_STATE
b
FILE
*
file
yyscan_t
yyscanner
)
;
#
define
YY_FLUSH_BUFFER
sksl_flush_buffer
(
YY_CURRENT_BUFFER
yyscanner
)
YY_BUFFER_STATE
sksl_scan_buffer
(
char
*
base
yy_size_t
size
yyscan_t
yyscanner
)
;
YY_BUFFER_STATE
sksl_scan_string
(
const
char
*
yy_str
yyscan_t
yyscanner
)
;
YY_BUFFER_STATE
sksl_scan_bytes
(
const
char
*
bytes
int
len
yyscan_t
yyscanner
)
;
void
*
skslalloc
(
yy_size_t
yyscan_t
yyscanner
)
;
void
*
skslrealloc
(
void
*
yy_size_t
yyscan_t
yyscanner
)
;
void
skslfree
(
void
*
yyscan_t
yyscanner
)
;
#
define
yy_new_buffer
sksl_create_buffer
#
define
yy_set_interactive
(
is_interactive
)
\
{
\
if
(
!
YY_CURRENT_BUFFER
)
{
\
skslensure_buffer_stack
(
yyscanner
)
;
\
YY_CURRENT_BUFFER_LVALUE
=
\
sksl_create_buffer
(
yyin
YY_BUF_SIZE
yyscanner
)
;
\
}
\
YY_CURRENT_BUFFER_LVALUE
-
>
yy_is_interactive
=
is_interactive
;
\
}
#
define
yy_set_bol
(
at_bol
)
\
{
\
if
(
!
YY_CURRENT_BUFFER
)
{
\
skslensure_buffer_stack
(
yyscanner
)
;
\
YY_CURRENT_BUFFER_LVALUE
=
\
sksl_create_buffer
(
yyin
YY_BUF_SIZE
yyscanner
)
;
\
}
\
YY_CURRENT_BUFFER_LVALUE
-
>
yy_at_bol
=
at_bol
;
\
}
#
define
YY_AT_BOL
(
)
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_at_bol
)
typedef
flex_uint8_t
YY_CHAR
;
typedef
int
yy_state_type
;
#
define
yytext_ptr
yytext_r
static
yy_state_type
yy_get_previous_state
(
yyscan_t
yyscanner
)
;
static
yy_state_type
yy_try_NUL_trans
(
yy_state_type
current_state
yyscan_t
yyscanner
)
;
static
int
yy_get_next_buffer
(
yyscan_t
yyscanner
)
;
static
void
yynoreturn
yy_fatal_error
(
const
char
*
msg
yyscan_t
yyscanner
)
;
#
define
YY_DO_BEFORE_ACTION
\
yyg
-
>
yytext_ptr
=
yy_bp
;
\
yyleng
=
(
int
)
(
yy_cp
-
yy_bp
)
;
\
yyg
-
>
yy_hold_char
=
*
yy_cp
;
\
*
yy_cp
=
'
\
0
'
;
\
yyg
-
>
yy_c_buf_p
=
yy_cp
;
#
define
YY_NUM_RULES
92
#
define
YY_END_OF_BUFFER
93
struct
yy_trans_info
{
flex_int32_t
yy_verify
;
flex_int32_t
yy_nxt
;
}
;
static
const
flex_int16_t
yy_accept
[
253
]
=
{
0
0
0
93
91
90
90
64
91
38
54
59
40
41
52
50
47
51
46
53
4
4
66
87
71
67
70
65
44
45
58
38
38
38
38
38
38
38
38
38
38
38
38
38
38
38
38
38
38
42
57
43
60
90
69
39
38
78
63
83
76
48
74
49
75
1
0
88
77
2
4
0
0
55
73
68
72
56
82
62
38
38
38
38
38
12
38
38
38
38
38
8
20
38
38
38
38
38
38
38
38
38
38
38
38
38
38
81
61
39
86
0
0
0
88
1
0
0
3
5
79
80
85
38
38
38
38
38
38
38
38
38
10
38
38
38
38
38
38
21
38
38
38
38
38
38
38
38
38
38
38
84
0
1
89
0
0
2
38
14
38
38
38
38
38
9
38
28
38
38
38
25
38
38
38
38
38
38
38
38
6
38
38
38
38
0
1
16
38
24
38
38
38
7
27
22
38
38
38
38
38
38
38
38
38
38
38
11
38
38
38
38
38
36
38
38
38
38
38
19
35
13
38
38
38
38
38
15
18
26
38
38
38
38
23
38
38
32
17
38
38
30
34
33
38
38
37
31
38
38
38
29
0
}
;
static
const
YY_CHAR
yy_ec
[
256
]
=
{
0
1
1
1
1
1
1
1
1
2
3
1
1
2
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
2
4
1
5
6
7
8
1
9
10
11
12
13
14
15
16
17
18
18
18
18
18
18
18
18
18
19
20
21
22
23
24
1
25
25
25
25
26
25
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
27
1
28
29
6
1
30
31
32
33
34
35
36
37
38
6
39
40
41
42
43
44
6
45
46
47
48
49
50
51
52
6
53
54
55
56
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
}
;
static
const
YY_CHAR
yy_meta
[
57
]
=
{
0
1
1
2
1
1
3
1
1
1
1
1
1
1
1
1
1
4
4
1
1
1
1
1
1
5
5
1
1
1
5
5
5
5
5
5
3
3
3
3
3
3
3
3
3
3
3
3
3
3
3
3
3
1
1
1
1
}
;
static
const
flex_int16_t
yy_base
[
259
]
=
{
0
0
0
320
321
55
57
297
0
0
296
53
321
321
295
50
321
49
47
57
52
59
321
321
59
294
60
321
321
321
62
270
57
54
274
59
275
59
65
278
268
262
264
274
57
262
264
262
53
321
74
321
321
103
321
0
0
321
282
321
321
321
321
321
321
92
292
0
321
95
99
118
0
280
321
321
321
279
321
278
265
252
78
262
250
0
249
254
263
247
255
0
247
237
238
254
242
238
250
92
238
244
233
242
239
240
239
321
254
0
321
128
264
258
0
126
136
106
138
0
321
321
321
243
238
237
111
240
237
234
221
219
0
228
216
220
218
223
226
0
227
225
210
208
207
207
219
217
221
210
202
321
144
146
321
153
151
155
209
0
202
199
207
196
213
0
208
0
197
193
191
0
190
192
198
192
189
188
200
199
0
187
182
194
193
157
159
0
192
0
183
184
178
0
0
0
175
180
174
173
176
179
174
168
177
168
174
0
168
168
161
161
174
0
162
161
166
163
170
0
0
0
160
160
157
146
145
0
0
0
132
116
99
102
0
113
101
0
0
105
92
0
0
0
79
80
0
0
81
62
32
0
321
175
178
181
186
191
193
}
;
static
const
flex_int16_t
yy_def
[
259
]
=
{
0
252
1
252
252
252
252
252
253
254
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
252
252
252
252
252
252
255
254
252
252
252
252
252
252
252
252
252
256
257
252
252
252
252
258
252
252
252
252
252
252
252
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
252
252
255
252
252
256
256
257
252
252
252
252
258
252
252
252
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
252
252
252
252
252
252
252
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
252
252
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
254
0
252
252
252
252
252
252
}
;
static
const
flex_int16_t
yy_nxt
[
378
]
=
{
0
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
9
9
28
29
30
9
31
32
33
34
35
9
36
37
9
38
39
40
41
42
43
44
45
46
47
48
9
9
49
50
51
52
53
53
53
53
58
61
63
65
65
251
69
66
70
70
64
62
67
69
59
70
70
71
68
73
74
76
77
78
71
71
81
83
87
105
79
84
71
91
93
107
85
106
88
82
92
89
72
100
53
53
101
94
65
65
250
115
115
69
125
70
70
111
249
126
116
141
118
118
71
111
248
108
116
117
247
117
71
246
118
118
245
142
143
152
244
152
115
115
153
153
243
156
242
156
241
155
157
157
118
118
161
162
240
155
153
153
153
153
185
239
185
157
157
186
186
157
157
186
186
186
186
55
238
55
56
56
56
109
109
109
112
112
112
112
112
114
237
114
114
114
119
119
236
235
234
233
232
231
230
229
228
227
226
225
224
223
222
221
220
219
218
217
216
215
214
213
212
211
210
209
208
207
206
205
204
203
202
201
200
199
198
197
196
195
194
193
192
191
190
189
188
187
184
183
182
181
180
179
178
177
176
175
174
173
172
171
170
169
168
167
166
165
164
163
160
159
158
154
113
151
150
149
148
147
146
145
144
140
139
138
137
136
135
134
133
132
131
130
129
128
127
124
123
122
121
120
113
110
104
103
102
99
98
97
96
95
90
86
80
75
60
57
54
252
3
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
}
;
static
const
flex_int16_t
yy_chk
[
378
]
=
{
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
5
5
6
6
11
15
17
18
18
250
20
19
20
20
17
15
19
21
11
21
21
20
19
24
24
26
26
30
21
20
32
33
35
48
30
33
21
37
38
50
33
48
35
32
37
35
20
44
53
53
44
38
65
65
249
69
69
70
82
70
70
65
248
82
69
99
117
117
70
65
245
50
69
71
244
71
70
240
71
71
239
99
99
111
236
111
115
115
111
111
235
116
233
116
232
115
116
116
118
118
126
126
231
115
152
152
153
153
155
230
155
156
156
155
155
157
157
185
185
186
186
253
226
253
254
254
254
255
255
255
256
256
256
256
256
257
225
257
257
257
258
258
224
223
222
218
217
216
215
214
212
211
210
209
208
206
205
204
203
202
201
200
199
198
197
196
192
191
190
188
184
183
182
181
179
178
177
176
175
174
173
172
170
169
168
166
164
163
162
161
160
158
150
149
148
147
146
145
144
143
142
141
140
138
137
136
135
134
133
131
130
129
128
127
125
124
123
113
112
108
106
105
104
103
102
101
100
98
97
96
95
94
93
92
90
89
88
87
86
84
83
81
80
79
77
73
66
58
47
46
45
43
42
41
40
39
36
34
31
25
14
10
7
3
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
252
}
;
static
const
flex_int32_t
yy_rule_can_match_eol
[
93
]
=
{
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
}
;
#
define
REJECT
reject_used_but_not_detected
#
define
yymore
(
)
yymore_used_but_not_detected
#
define
YY_MORE_ADJ
0
#
define
YY_RESTORE_YY_MORE_OFFSET
#
line
1
"
sksl
.
flex
"
#
define
YY_NO_UNISTD_H
1
#
line
694
"
lex
.
sksl
.
c
"
#
define
INITIAL
0
#
ifndef
YY_NO_UNISTD_H
#
include
<
unistd
.
h
>
#
endif
#
ifndef
YY_EXTRA_TYPE
#
define
YY_EXTRA_TYPE
void
*
#
endif
struct
yyguts_t
{
YY_EXTRA_TYPE
yyextra_r
;
FILE
*
yyin_r
*
yyout_r
;
size_t
yy_buffer_stack_top
;
size_t
yy_buffer_stack_max
;
YY_BUFFER_STATE
*
yy_buffer_stack
;
char
yy_hold_char
;
int
yy_n_chars
;
int
yyleng_r
;
char
*
yy_c_buf_p
;
int
yy_init
;
int
yy_start
;
int
yy_did_buffer_switch_on_eof
;
int
yy_start_stack_ptr
;
int
yy_start_stack_depth
;
int
*
yy_start_stack
;
yy_state_type
yy_last_accepting_state
;
char
*
yy_last_accepting_cpos
;
int
yylineno_r
;
int
yy_flex_debug_r
;
char
*
yytext_r
;
int
yy_more_flag
;
int
yy_more_len
;
}
;
static
int
yy_init_globals
(
yyscan_t
yyscanner
)
;
int
sksllex_init
(
yyscan_t
*
scanner
)
;
int
sksllex_init_extra
(
YY_EXTRA_TYPE
user_defined
yyscan_t
*
scanner
)
;
int
sksllex_destroy
(
yyscan_t
yyscanner
)
;
int
skslget_debug
(
yyscan_t
yyscanner
)
;
void
skslset_debug
(
int
debug_flag
yyscan_t
yyscanner
)
;
YY_EXTRA_TYPE
skslget_extra
(
yyscan_t
yyscanner
)
;
void
skslset_extra
(
YY_EXTRA_TYPE
user_defined
yyscan_t
yyscanner
)
;
FILE
*
skslget_in
(
yyscan_t
yyscanner
)
;
void
skslset_in
(
FILE
*
_in_str
yyscan_t
yyscanner
)
;
FILE
*
skslget_out
(
yyscan_t
yyscanner
)
;
void
skslset_out
(
FILE
*
_out_str
yyscan_t
yyscanner
)
;
int
skslget_leng
(
yyscan_t
yyscanner
)
;
char
*
skslget_text
(
yyscan_t
yyscanner
)
;
int
skslget_lineno
(
yyscan_t
yyscanner
)
;
void
skslset_lineno
(
int
_line_number
yyscan_t
yyscanner
)
;
int
skslget_column
(
yyscan_t
yyscanner
)
;
void
skslset_column
(
int
_column_no
yyscan_t
yyscanner
)
;
#
ifndef
YY_SKIP_YYWRAP
#
ifdef
__cplusplus
extern
"
C
"
int
skslwrap
(
yyscan_t
yyscanner
)
;
#
else
extern
int
skslwrap
(
yyscan_t
yyscanner
)
;
#
endif
#
endif
#
ifndef
YY_NO_UNPUT
static
void
yyunput
(
int
c
char
*
buf_ptr
yyscan_t
yyscanner
)
;
#
endif
#
ifndef
yytext_ptr
static
void
yy_flex_strncpy
(
char
*
const
char
*
int
yyscan_t
yyscanner
)
;
#
endif
#
ifdef
YY_NEED_STRLEN
static
int
yy_flex_strlen
(
const
char
*
yyscan_t
yyscanner
)
;
#
endif
#
ifndef
YY_NO_INPUT
#
ifdef
__cplusplus
static
int
yyinput
(
yyscan_t
yyscanner
)
;
#
else
static
int
input
(
yyscan_t
yyscanner
)
;
#
endif
#
endif
#
ifndef
YY_READ_BUF_SIZE
#
ifdef
__ia64__
#
define
YY_READ_BUF_SIZE
16384
#
else
#
define
YY_READ_BUF_SIZE
8192
#
endif
#
endif
#
ifndef
ECHO
#
define
ECHO
do
{
if
(
fwrite
(
yytext
(
size_t
)
yyleng
1
yyout
)
)
{
}
}
while
(
0
)
#
endif
#
ifndef
YY_INPUT
#
define
YY_INPUT
(
buf
result
max_size
)
\
if
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_is_interactive
)
\
{
\
int
c
=
'
*
'
;
\
int
n
;
\
for
(
n
=
0
;
n
<
max_size
&
&
\
(
c
=
getc
(
yyin
)
)
!
=
EOF
&
&
c
!
=
'
\
n
'
;
+
+
n
)
\
buf
[
n
]
=
(
char
)
c
;
\
if
(
c
=
=
'
\
n
'
)
\
buf
[
n
+
+
]
=
(
char
)
c
;
\
if
(
c
=
=
EOF
&
&
ferror
(
yyin
)
)
\
YY_FATAL_ERROR
(
"
input
in
flex
scanner
failed
"
)
;
\
result
=
n
;
\
}
\
else
\
{
\
errno
=
0
;
\
while
(
(
result
=
(
int
)
fread
(
buf
1
(
yy_size_t
)
max_size
yyin
)
)
=
=
0
&
&
ferror
(
yyin
)
)
\
{
\
if
(
errno
!
=
EINTR
)
\
{
\
YY_FATAL_ERROR
(
"
input
in
flex
scanner
failed
"
)
;
\
break
;
\
}
\
errno
=
0
;
\
clearerr
(
yyin
)
;
\
}
\
}
\
\
#
endif
#
ifndef
yyterminate
#
define
yyterminate
(
)
return
YY_NULL
#
endif
#
ifndef
YY_START_STACK_INCR
#
define
YY_START_STACK_INCR
25
#
endif
#
ifndef
YY_FATAL_ERROR
#
define
YY_FATAL_ERROR
(
msg
)
yy_fatal_error
(
msg
yyscanner
)
#
endif
#
ifndef
YY_DECL
#
define
YY_DECL_IS_OURS
1
extern
int
sksllex
(
yyscan_t
yyscanner
)
;
#
define
YY_DECL
int
sksllex
(
yyscan_t
yyscanner
)
#
endif
#
ifndef
YY_USER_ACTION
#
define
YY_USER_ACTION
#
endif
#
ifndef
YY_BREAK
#
define
YY_BREAKbreak
;
#
endif
#
define
YY_RULE_SETUP
\
YY_USER_ACTION
YY_DECL
{
yy_state_type
yy_current_state
;
char
*
yy_cp
*
yy_bp
;
int
yy_act
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
yyg
-
>
yy_init
)
{
yyg
-
>
yy_init
=
1
;
#
ifdef
YY_USER_INIT
YY_USER_INIT
;
#
endif
if
(
!
yyg
-
>
yy_start
)
yyg
-
>
yy_start
=
1
;
if
(
!
yyin
)
yyin
=
stdin
;
if
(
!
yyout
)
yyout
=
stdout
;
if
(
!
YY_CURRENT_BUFFER
)
{
skslensure_buffer_stack
(
yyscanner
)
;
YY_CURRENT_BUFFER_LVALUE
=
sksl_create_buffer
(
yyin
YY_BUF_SIZE
yyscanner
)
;
}
sksl_load_buffer_state
(
yyscanner
)
;
}
{
#
line
30
"
sksl
.
flex
"
#
line
957
"
lex
.
sksl
.
c
"
while
(
1
)
{
yy_cp
=
yyg
-
>
yy_c_buf_p
;
*
yy_cp
=
yyg
-
>
yy_hold_char
;
yy_bp
=
yy_cp
;
yy_current_state
=
yyg
-
>
yy_start
;
yy_match
:
do
{
YY_CHAR
yy_c
=
yy_ec
[
YY_SC_TO_UI
(
*
yy_cp
)
]
;
if
(
yy_accept
[
yy_current_state
]
)
{
yyg
-
>
yy_last_accepting_state
=
yy_current_state
;
yyg
-
>
yy_last_accepting_cpos
=
yy_cp
;
}
while
(
yy_chk
[
yy_base
[
yy_current_state
]
+
yy_c
]
!
=
yy_current_state
)
{
yy_current_state
=
(
int
)
yy_def
[
yy_current_state
]
;
if
(
yy_current_state
>
=
253
)
yy_c
=
yy_meta
[
yy_c
]
;
}
yy_current_state
=
yy_nxt
[
yy_base
[
yy_current_state
]
+
yy_c
]
;
+
+
yy_cp
;
}
while
(
yy_current_state
!
=
252
)
;
yy_cp
=
yyg
-
>
yy_last_accepting_cpos
;
yy_current_state
=
yyg
-
>
yy_last_accepting_state
;
yy_find_action
:
yy_act
=
yy_accept
[
yy_current_state
]
;
YY_DO_BEFORE_ACTION
;
if
(
yy_act
!
=
YY_END_OF_BUFFER
&
&
yy_rule_can_match_eol
[
yy_act
]
)
{
int
yyl
;
for
(
yyl
=
0
;
yyl
<
yyleng
;
+
+
yyl
)
if
(
yytext
[
yyl
]
=
=
'
\
n
'
)
do
{
yylineno
+
+
;
yycolumn
=
0
;
}
while
(
0
)
;
}
do_action
:
switch
(
yy_act
)
{
case
0
:
*
yy_cp
=
yyg
-
>
yy_hold_char
;
yy_cp
=
yyg
-
>
yy_last_accepting_cpos
;
yy_current_state
=
yyg
-
>
yy_last_accepting_state
;
goto
yy_find_action
;
case
1
:
YY_RULE_SETUP
#
line
32
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
FLOAT_LITERAL
;
}
YY_BREAK
case
2
:
YY_RULE_SETUP
#
line
34
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
FLOAT_LITERAL
;
}
YY_BREAK
case
3
:
YY_RULE_SETUP
#
line
36
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
FLOAT_LITERAL
;
}
YY_BREAK
case
4
:
YY_RULE_SETUP
#
line
38
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
INT_LITERAL
;
}
YY_BREAK
case
5
:
YY_RULE_SETUP
#
line
40
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
INT_LITERAL
;
}
YY_BREAK
case
6
:
YY_RULE_SETUP
#
line
42
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
TRUE_LITERAL
;
}
YY_BREAK
case
7
:
YY_RULE_SETUP
#
line
44
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
FALSE_LITERAL
;
}
YY_BREAK
case
8
:
YY_RULE_SETUP
#
line
46
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
IF
;
}
YY_BREAK
case
9
:
YY_RULE_SETUP
#
line
48
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
ELSE
;
}
YY_BREAK
case
10
:
YY_RULE_SETUP
#
line
50
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
FOR
;
}
YY_BREAK
case
11
:
YY_RULE_SETUP
#
line
52
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
WHILE
;
}
YY_BREAK
case
12
:
YY_RULE_SETUP
#
line
54
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
DO
;
}
YY_BREAK
case
13
:
YY_RULE_SETUP
#
line
56
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
SWITCH
;
}
YY_BREAK
case
14
:
YY_RULE_SETUP
#
line
58
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
CASE
;
}
YY_BREAK
case
15
:
YY_RULE_SETUP
#
line
60
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
DEFAULT
;
}
YY_BREAK
case
16
:
YY_RULE_SETUP
#
line
62
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
BREAK
;
}
YY_BREAK
case
17
:
YY_RULE_SETUP
#
line
64
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
CONTINUE
;
}
YY_BREAK
case
18
:
YY_RULE_SETUP
#
line
66
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
DISCARD
;
}
YY_BREAK
case
19
:
YY_RULE_SETUP
#
line
68
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
RETURN
;
}
YY_BREAK
case
20
:
YY_RULE_SETUP
#
line
70
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
IN
;
}
YY_BREAK
case
21
:
YY_RULE_SETUP
#
line
72
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
OUT
;
}
YY_BREAK
case
22
:
YY_RULE_SETUP
#
line
74
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
INOUT
;
}
YY_BREAK
case
23
:
YY_RULE_SETUP
#
line
76
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
UNIFORM
;
}
YY_BREAK
case
24
:
YY_RULE_SETUP
#
line
78
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
CONST
;
}
YY_BREAK
case
25
:
YY_RULE_SETUP
#
line
80
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LOWP
;
}
YY_BREAK
case
26
:
YY_RULE_SETUP
#
line
82
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
MEDIUMP
;
}
YY_BREAK
case
27
:
YY_RULE_SETUP
#
line
84
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
HIGHP
;
}
YY_BREAK
case
28
:
YY_RULE_SETUP
#
line
86
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
FLAT
;
}
YY_BREAK
case
29
:
YY_RULE_SETUP
#
line
88
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
NOPERSPECTIVE
;
}
YY_BREAK
case
30
:
YY_RULE_SETUP
#
line
90
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
READONLY
;
}
YY_BREAK
case
31
:
YY_RULE_SETUP
#
line
92
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
WRITEONLY
;
}
YY_BREAK
case
32
:
YY_RULE_SETUP
#
line
94
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
COHERENT
;
}
YY_BREAK
case
33
:
YY_RULE_SETUP
#
line
96
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
VOLATILE
;
}
YY_BREAK
case
34
:
YY_RULE_SETUP
#
line
98
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
RESTRICT
;
}
YY_BREAK
case
35
:
YY_RULE_SETUP
#
line
100
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
STRUCT
;
}
YY_BREAK
case
36
:
YY_RULE_SETUP
#
line
102
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LAYOUT
;
}
YY_BREAK
case
37
:
YY_RULE_SETUP
#
line
104
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
PRECISION
;
}
YY_BREAK
case
38
:
YY_RULE_SETUP
#
line
106
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
IDENTIFIER
;
}
YY_BREAK
case
39
:
YY_RULE_SETUP
#
line
108
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
DIRECTIVE
;
}
YY_BREAK
case
40
:
YY_RULE_SETUP
#
line
110
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LPAREN
;
}
YY_BREAK
case
41
:
YY_RULE_SETUP
#
line
112
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
RPAREN
;
}
YY_BREAK
case
42
:
YY_RULE_SETUP
#
line
114
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LBRACE
;
}
YY_BREAK
case
43
:
YY_RULE_SETUP
#
line
116
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
RBRACE
;
}
YY_BREAK
case
44
:
YY_RULE_SETUP
#
line
118
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LBRACKET
;
}
YY_BREAK
case
45
:
YY_RULE_SETUP
#
line
120
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
RBRACKET
;
}
YY_BREAK
case
46
:
YY_RULE_SETUP
#
line
122
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
DOT
;
}
YY_BREAK
case
47
:
YY_RULE_SETUP
#
line
124
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
COMMA
;
}
YY_BREAK
case
48
:
YY_RULE_SETUP
#
line
126
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
PLUSPLUS
;
}
YY_BREAK
case
49
:
YY_RULE_SETUP
#
line
128
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
MINUSMINUS
;
}
YY_BREAK
case
50
:
YY_RULE_SETUP
#
line
130
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
PLUS
;
}
YY_BREAK
case
51
:
YY_RULE_SETUP
#
line
132
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
MINUS
;
}
YY_BREAK
case
52
:
YY_RULE_SETUP
#
line
134
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
STAR
;
}
YY_BREAK
case
53
:
YY_RULE_SETUP
#
line
136
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
SLASH
;
}
YY_BREAK
case
54
:
YY_RULE_SETUP
#
line
138
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
PERCENT
;
}
YY_BREAK
case
55
:
YY_RULE_SETUP
#
line
140
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
SHL
;
}
YY_BREAK
case
56
:
YY_RULE_SETUP
#
line
142
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
SHR
;
}
YY_BREAK
case
57
:
YY_RULE_SETUP
#
line
144
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
BITWISEOR
;
}
YY_BREAK
case
58
:
YY_RULE_SETUP
#
line
146
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
BITWISEXOR
;
}
YY_BREAK
case
59
:
YY_RULE_SETUP
#
line
148
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
BITWISEAND
;
}
YY_BREAK
case
60
:
YY_RULE_SETUP
#
line
150
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
BITWISENOT
;
}
YY_BREAK
case
61
:
YY_RULE_SETUP
#
line
152
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LOGICALOR
;
}
YY_BREAK
case
62
:
YY_RULE_SETUP
#
line
154
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LOGICALXOR
;
}
YY_BREAK
case
63
:
YY_RULE_SETUP
#
line
156
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LOGICALAND
;
}
YY_BREAK
case
64
:
YY_RULE_SETUP
#
line
158
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LOGICALNOT
;
}
YY_BREAK
case
65
:
YY_RULE_SETUP
#
line
160
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
QUESTION
;
}
YY_BREAK
case
66
:
YY_RULE_SETUP
#
line
162
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
COLON
;
}
YY_BREAK
case
67
:
YY_RULE_SETUP
#
line
164
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
EQ
;
}
YY_BREAK
case
68
:
YY_RULE_SETUP
#
line
166
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
EQEQ
;
}
YY_BREAK
case
69
:
YY_RULE_SETUP
#
line
168
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
NEQ
;
}
YY_BREAK
case
70
:
YY_RULE_SETUP
#
line
170
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
GT
;
}
YY_BREAK
case
71
:
YY_RULE_SETUP
#
line
172
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LT
;
}
YY_BREAK
case
72
:
YY_RULE_SETUP
#
line
174
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
GTEQ
;
}
YY_BREAK
case
73
:
YY_RULE_SETUP
#
line
176
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LTEQ
;
}
YY_BREAK
case
74
:
YY_RULE_SETUP
#
line
178
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
PLUSEQ
;
}
YY_BREAK
case
75
:
YY_RULE_SETUP
#
line
180
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
MINUSEQ
;
}
YY_BREAK
case
76
:
YY_RULE_SETUP
#
line
182
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
STAREQ
;
}
YY_BREAK
case
77
:
YY_RULE_SETUP
#
line
184
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
SLASHEQ
;
}
YY_BREAK
case
78
:
YY_RULE_SETUP
#
line
186
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
PERCENTEQ
;
}
YY_BREAK
case
79
:
YY_RULE_SETUP
#
line
188
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
SHLEQ
;
}
YY_BREAK
case
80
:
YY_RULE_SETUP
#
line
190
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
SHREQ
;
}
YY_BREAK
case
81
:
YY_RULE_SETUP
#
line
192
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
BITWISEOREQ
;
}
YY_BREAK
case
82
:
YY_RULE_SETUP
#
line
194
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
BITWISEXOREQ
;
}
YY_BREAK
case
83
:
YY_RULE_SETUP
#
line
196
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
BITWISEANDEQ
;
}
YY_BREAK
case
84
:
YY_RULE_SETUP
#
line
198
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LOGICALOREQ
;
}
YY_BREAK
case
85
:
YY_RULE_SETUP
#
line
200
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LOGICALXOREQ
;
}
YY_BREAK
case
86
:
YY_RULE_SETUP
#
line
202
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
LOGICALANDEQ
;
}
YY_BREAK
case
87
:
YY_RULE_SETUP
#
line
204
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
SEMICOLON
;
}
YY_BREAK
case
88
:
YY_RULE_SETUP
#
line
206
"
sksl
.
flex
"
YY_BREAK
case
89
:
YY_RULE_SETUP
#
line
208
"
sksl
.
flex
"
YY_BREAK
case
90
:
YY_RULE_SETUP
#
line
210
"
sksl
.
flex
"
YY_BREAK
case
91
:
YY_RULE_SETUP
#
line
212
"
sksl
.
flex
"
{
return
SkSL
:
:
Token
:
:
INVALID_TOKEN
;
}
YY_BREAK
case
92
:
YY_RULE_SETUP
#
line
214
"
sksl
.
flex
"
ECHO
;
YY_BREAK
#
line
1484
"
lex
.
sksl
.
c
"
case
YY_STATE_EOF
(
INITIAL
)
:
yyterminate
(
)
;
case
YY_END_OF_BUFFER
:
{
int
yy_amount_of_matched_text
=
(
int
)
(
yy_cp
-
yyg
-
>
yytext_ptr
)
-
1
;
*
yy_cp
=
yyg
-
>
yy_hold_char
;
YY_RESTORE_YY_MORE_OFFSET
if
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buffer_status
=
=
YY_BUFFER_NEW
)
{
yyg
-
>
yy_n_chars
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_input_file
=
yyin
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buffer_status
=
YY_BUFFER_NORMAL
;
}
if
(
yyg
-
>
yy_c_buf_p
<
=
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
]
)
{
yy_state_type
yy_next_state
;
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yytext_ptr
+
yy_amount_of_matched_text
;
yy_current_state
=
yy_get_previous_state
(
yyscanner
)
;
yy_next_state
=
yy_try_NUL_trans
(
yy_current_state
yyscanner
)
;
yy_bp
=
yyg
-
>
yytext_ptr
+
YY_MORE_ADJ
;
if
(
yy_next_state
)
{
yy_cp
=
+
+
yyg
-
>
yy_c_buf_p
;
yy_current_state
=
yy_next_state
;
goto
yy_match
;
}
else
{
yy_cp
=
yyg
-
>
yy_last_accepting_cpos
;
yy_current_state
=
yyg
-
>
yy_last_accepting_state
;
goto
yy_find_action
;
}
}
else
switch
(
yy_get_next_buffer
(
yyscanner
)
)
{
case
EOB_ACT_END_OF_FILE
:
{
yyg
-
>
yy_did_buffer_switch_on_eof
=
0
;
if
(
skslwrap
(
yyscanner
)
)
{
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yytext_ptr
+
YY_MORE_ADJ
;
yy_act
=
YY_STATE_EOF
(
YY_START
)
;
goto
do_action
;
}
else
{
if
(
!
yyg
-
>
yy_did_buffer_switch_on_eof
)
YY_NEW_FILE
;
}
break
;
}
case
EOB_ACT_CONTINUE_SCAN
:
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yytext_ptr
+
yy_amount_of_matched_text
;
yy_current_state
=
yy_get_previous_state
(
yyscanner
)
;
yy_cp
=
yyg
-
>
yy_c_buf_p
;
yy_bp
=
yyg
-
>
yytext_ptr
+
YY_MORE_ADJ
;
goto
yy_match
;
case
EOB_ACT_LAST_MATCH
:
yyg
-
>
yy_c_buf_p
=
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
]
;
yy_current_state
=
yy_get_previous_state
(
yyscanner
)
;
yy_cp
=
yyg
-
>
yy_c_buf_p
;
yy_bp
=
yyg
-
>
yytext_ptr
+
YY_MORE_ADJ
;
goto
yy_find_action
;
}
break
;
}
default
:
YY_FATAL_ERROR
(
"
fatal
flex
scanner
internal
error
-
-
no
action
found
"
)
;
}
}
}
}
static
int
yy_get_next_buffer
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
char
*
dest
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
;
char
*
source
=
yyg
-
>
yytext_ptr
;
int
number_to_move
i
;
int
ret_val
;
if
(
yyg
-
>
yy_c_buf_p
>
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
+
1
]
)
YY_FATAL_ERROR
(
"
fatal
flex
scanner
internal
error
-
-
end
of
buffer
missed
"
)
;
if
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_fill_buffer
=
=
0
)
{
if
(
yyg
-
>
yy_c_buf_p
-
yyg
-
>
yytext_ptr
-
YY_MORE_ADJ
=
=
1
)
{
return
EOB_ACT_END_OF_FILE
;
}
else
{
return
EOB_ACT_LAST_MATCH
;
}
}
number_to_move
=
(
int
)
(
yyg
-
>
yy_c_buf_p
-
yyg
-
>
yytext_ptr
-
1
)
;
for
(
i
=
0
;
i
<
number_to_move
;
+
+
i
)
*
(
dest
+
+
)
=
*
(
source
+
+
)
;
if
(
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buffer_status
=
=
YY_BUFFER_EOF_PENDING
)
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
=
yyg
-
>
yy_n_chars
=
0
;
else
{
int
num_to_read
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_size
-
number_to_move
-
1
;
while
(
num_to_read
<
=
0
)
{
YY_BUFFER_STATE
b
=
YY_CURRENT_BUFFER_LVALUE
;
int
yy_c_buf_p_offset
=
(
int
)
(
yyg
-
>
yy_c_buf_p
-
b
-
>
yy_ch_buf
)
;
if
(
b
-
>
yy_is_our_buffer
)
{
int
new_size
=
b
-
>
yy_buf_size
*
2
;
if
(
new_size
<
=
0
)
b
-
>
yy_buf_size
+
=
b
-
>
yy_buf_size
/
8
;
else
b
-
>
yy_buf_size
*
=
2
;
b
-
>
yy_ch_buf
=
(
char
*
)
skslrealloc
(
(
void
*
)
b
-
>
yy_ch_buf
(
yy_size_t
)
(
b
-
>
yy_buf_size
+
2
)
yyscanner
)
;
}
else
b
-
>
yy_ch_buf
=
NULL
;
if
(
!
b
-
>
yy_ch_buf
)
YY_FATAL_ERROR
(
"
fatal
error
-
scanner
input
buffer
overflow
"
)
;
yyg
-
>
yy_c_buf_p
=
&
b
-
>
yy_ch_buf
[
yy_c_buf_p_offset
]
;
num_to_read
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_size
-
number_to_move
-
1
;
}
if
(
num_to_read
>
YY_READ_BUF_SIZE
)
num_to_read
=
YY_READ_BUF_SIZE
;
YY_INPUT
(
(
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
number_to_move
]
)
yyg
-
>
yy_n_chars
num_to_read
)
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
=
yyg
-
>
yy_n_chars
;
}
if
(
yyg
-
>
yy_n_chars
=
=
0
)
{
if
(
number_to_move
=
=
YY_MORE_ADJ
)
{
ret_val
=
EOB_ACT_END_OF_FILE
;
skslrestart
(
yyin
yyscanner
)
;
}
else
{
ret_val
=
EOB_ACT_LAST_MATCH
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buffer_status
=
YY_BUFFER_EOF_PENDING
;
}
}
else
ret_val
=
EOB_ACT_CONTINUE_SCAN
;
if
(
(
yyg
-
>
yy_n_chars
+
number_to_move
)
>
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_size
)
{
int
new_size
=
yyg
-
>
yy_n_chars
+
number_to_move
+
(
yyg
-
>
yy_n_chars
>
>
1
)
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
=
(
char
*
)
skslrealloc
(
(
void
*
)
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
(
yy_size_t
)
new_size
yyscanner
)
;
if
(
!
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
yy_get_next_buffer
(
)
"
)
;
}
yyg
-
>
yy_n_chars
+
=
number_to_move
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
]
=
YY_END_OF_BUFFER_CHAR
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
+
1
]
=
YY_END_OF_BUFFER_CHAR
;
yyg
-
>
yytext_ptr
=
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
0
]
;
return
ret_val
;
}
static
yy_state_type
yy_get_previous_state
(
yyscan_t
yyscanner
)
{
yy_state_type
yy_current_state
;
char
*
yy_cp
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yy_current_state
=
yyg
-
>
yy_start
;
for
(
yy_cp
=
yyg
-
>
yytext_ptr
+
YY_MORE_ADJ
;
yy_cp
<
yyg
-
>
yy_c_buf_p
;
+
+
yy_cp
)
{
YY_CHAR
yy_c
=
(
*
yy_cp
?
yy_ec
[
YY_SC_TO_UI
(
*
yy_cp
)
]
:
1
)
;
if
(
yy_accept
[
yy_current_state
]
)
{
yyg
-
>
yy_last_accepting_state
=
yy_current_state
;
yyg
-
>
yy_last_accepting_cpos
=
yy_cp
;
}
while
(
yy_chk
[
yy_base
[
yy_current_state
]
+
yy_c
]
!
=
yy_current_state
)
{
yy_current_state
=
(
int
)
yy_def
[
yy_current_state
]
;
if
(
yy_current_state
>
=
253
)
yy_c
=
yy_meta
[
yy_c
]
;
}
yy_current_state
=
yy_nxt
[
yy_base
[
yy_current_state
]
+
yy_c
]
;
}
return
yy_current_state
;
}
static
yy_state_type
yy_try_NUL_trans
(
yy_state_type
yy_current_state
yyscan_t
yyscanner
)
{
int
yy_is_jam
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
char
*
yy_cp
=
yyg
-
>
yy_c_buf_p
;
YY_CHAR
yy_c
=
1
;
if
(
yy_accept
[
yy_current_state
]
)
{
yyg
-
>
yy_last_accepting_state
=
yy_current_state
;
yyg
-
>
yy_last_accepting_cpos
=
yy_cp
;
}
while
(
yy_chk
[
yy_base
[
yy_current_state
]
+
yy_c
]
!
=
yy_current_state
)
{
yy_current_state
=
(
int
)
yy_def
[
yy_current_state
]
;
if
(
yy_current_state
>
=
253
)
yy_c
=
yy_meta
[
yy_c
]
;
}
yy_current_state
=
yy_nxt
[
yy_base
[
yy_current_state
]
+
yy_c
]
;
yy_is_jam
=
(
yy_current_state
=
=
252
)
;
(
void
)
yyg
;
return
yy_is_jam
?
0
:
yy_current_state
;
}
#
ifndef
YY_NO_UNPUT
static
void
yyunput
(
int
c
char
*
yy_bp
yyscan_t
yyscanner
)
{
char
*
yy_cp
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yy_cp
=
yyg
-
>
yy_c_buf_p
;
*
yy_cp
=
yyg
-
>
yy_hold_char
;
if
(
yy_cp
<
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
+
2
)
{
int
number_to_move
=
yyg
-
>
yy_n_chars
+
2
;
char
*
dest
=
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_size
+
2
]
;
char
*
source
=
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
number_to_move
]
;
while
(
source
>
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
)
*
-
-
dest
=
*
-
-
source
;
yy_cp
+
=
(
int
)
(
dest
-
source
)
;
yy_bp
+
=
(
int
)
(
dest
-
source
)
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
=
yyg
-
>
yy_n_chars
=
(
int
)
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_size
;
if
(
yy_cp
<
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
+
2
)
YY_FATAL_ERROR
(
"
flex
scanner
push
-
back
overflow
"
)
;
}
*
-
-
yy_cp
=
(
char
)
c
;
if
(
c
=
=
'
\
n
'
)
{
-
-
yylineno
;
}
yyg
-
>
yytext_ptr
=
yy_bp
;
yyg
-
>
yy_hold_char
=
*
yy_cp
;
yyg
-
>
yy_c_buf_p
=
yy_cp
;
}
#
endif
#
ifndef
YY_NO_INPUT
#
ifdef
__cplusplus
static
int
yyinput
(
yyscan_t
yyscanner
)
#
else
static
int
input
(
yyscan_t
yyscanner
)
#
endif
{
int
c
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
*
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yy_hold_char
;
if
(
*
yyg
-
>
yy_c_buf_p
=
=
YY_END_OF_BUFFER_CHAR
)
{
if
(
yyg
-
>
yy_c_buf_p
<
&
YY_CURRENT_BUFFER_LVALUE
-
>
yy_ch_buf
[
yyg
-
>
yy_n_chars
]
)
*
yyg
-
>
yy_c_buf_p
=
'
\
0
'
;
else
{
int
offset
=
(
int
)
(
yyg
-
>
yy_c_buf_p
-
yyg
-
>
yytext_ptr
)
;
+
+
yyg
-
>
yy_c_buf_p
;
switch
(
yy_get_next_buffer
(
yyscanner
)
)
{
case
EOB_ACT_LAST_MATCH
:
skslrestart
(
yyin
yyscanner
)
;
case
EOB_ACT_END_OF_FILE
:
{
if
(
skslwrap
(
yyscanner
)
)
return
0
;
if
(
!
yyg
-
>
yy_did_buffer_switch_on_eof
)
YY_NEW_FILE
;
#
ifdef
__cplusplus
return
yyinput
(
yyscanner
)
;
#
else
return
input
(
yyscanner
)
;
#
endif
}
case
EOB_ACT_CONTINUE_SCAN
:
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yytext_ptr
+
offset
;
break
;
}
}
}
c
=
*
(
unsigned
char
*
)
yyg
-
>
yy_c_buf_p
;
*
yyg
-
>
yy_c_buf_p
=
'
\
0
'
;
yyg
-
>
yy_hold_char
=
*
+
+
yyg
-
>
yy_c_buf_p
;
if
(
c
=
=
'
\
n
'
)
do
{
yylineno
+
+
;
yycolumn
=
0
;
}
while
(
0
)
;
return
c
;
}
#
endif
void
skslrestart
(
FILE
*
input_file
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
{
skslensure_buffer_stack
(
yyscanner
)
;
YY_CURRENT_BUFFER_LVALUE
=
sksl_create_buffer
(
yyin
YY_BUF_SIZE
yyscanner
)
;
}
sksl_init_buffer
(
YY_CURRENT_BUFFER
input_file
yyscanner
)
;
sksl_load_buffer_state
(
yyscanner
)
;
}
void
sksl_switch_to_buffer
(
YY_BUFFER_STATE
new_buffer
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
skslensure_buffer_stack
(
yyscanner
)
;
if
(
YY_CURRENT_BUFFER
=
=
new_buffer
)
return
;
if
(
YY_CURRENT_BUFFER
)
{
*
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yy_hold_char
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_pos
=
yyg
-
>
yy_c_buf_p
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
=
yyg
-
>
yy_n_chars
;
}
YY_CURRENT_BUFFER_LVALUE
=
new_buffer
;
sksl_load_buffer_state
(
yyscanner
)
;
yyg
-
>
yy_did_buffer_switch_on_eof
=
1
;
}
static
void
sksl_load_buffer_state
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yyg
-
>
yy_n_chars
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
;
yyg
-
>
yytext_ptr
=
yyg
-
>
yy_c_buf_p
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_pos
;
yyin
=
YY_CURRENT_BUFFER_LVALUE
-
>
yy_input_file
;
yyg
-
>
yy_hold_char
=
*
yyg
-
>
yy_c_buf_p
;
}
YY_BUFFER_STATE
sksl_create_buffer
(
FILE
*
file
int
size
yyscan_t
yyscanner
)
{
YY_BUFFER_STATE
b
;
b
=
(
YY_BUFFER_STATE
)
skslalloc
(
sizeof
(
struct
yy_buffer_state
)
yyscanner
)
;
if
(
!
b
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
sksl_create_buffer
(
)
"
)
;
b
-
>
yy_buf_size
=
size
;
b
-
>
yy_ch_buf
=
(
char
*
)
skslalloc
(
(
yy_size_t
)
(
b
-
>
yy_buf_size
+
2
)
yyscanner
)
;
if
(
!
b
-
>
yy_ch_buf
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
sksl_create_buffer
(
)
"
)
;
b
-
>
yy_is_our_buffer
=
1
;
sksl_init_buffer
(
b
file
yyscanner
)
;
return
b
;
}
void
sksl_delete_buffer
(
YY_BUFFER_STATE
b
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
b
)
return
;
if
(
b
=
=
YY_CURRENT_BUFFER
)
YY_CURRENT_BUFFER_LVALUE
=
(
YY_BUFFER_STATE
)
0
;
if
(
b
-
>
yy_is_our_buffer
)
skslfree
(
(
void
*
)
b
-
>
yy_ch_buf
yyscanner
)
;
skslfree
(
(
void
*
)
b
yyscanner
)
;
}
static
void
sksl_init_buffer
(
YY_BUFFER_STATE
b
FILE
*
file
yyscan_t
yyscanner
)
{
int
oerrno
=
errno
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
sksl_flush_buffer
(
b
yyscanner
)
;
b
-
>
yy_input_file
=
file
;
b
-
>
yy_fill_buffer
=
1
;
if
(
b
!
=
YY_CURRENT_BUFFER
)
{
b
-
>
yy_bs_lineno
=
1
;
b
-
>
yy_bs_column
=
0
;
}
b
-
>
yy_is_interactive
=
0
;
errno
=
oerrno
;
}
void
sksl_flush_buffer
(
YY_BUFFER_STATE
b
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
b
)
return
;
b
-
>
yy_n_chars
=
0
;
b
-
>
yy_ch_buf
[
0
]
=
YY_END_OF_BUFFER_CHAR
;
b
-
>
yy_ch_buf
[
1
]
=
YY_END_OF_BUFFER_CHAR
;
b
-
>
yy_buf_pos
=
&
b
-
>
yy_ch_buf
[
0
]
;
b
-
>
yy_at_bol
=
1
;
b
-
>
yy_buffer_status
=
YY_BUFFER_NEW
;
if
(
b
=
=
YY_CURRENT_BUFFER
)
sksl_load_buffer_state
(
yyscanner
)
;
}
void
skslpush_buffer_state
(
YY_BUFFER_STATE
new_buffer
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
new_buffer
=
=
NULL
)
return
;
skslensure_buffer_stack
(
yyscanner
)
;
if
(
YY_CURRENT_BUFFER
)
{
*
yyg
-
>
yy_c_buf_p
=
yyg
-
>
yy_hold_char
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_buf_pos
=
yyg
-
>
yy_c_buf_p
;
YY_CURRENT_BUFFER_LVALUE
-
>
yy_n_chars
=
yyg
-
>
yy_n_chars
;
}
if
(
YY_CURRENT_BUFFER
)
yyg
-
>
yy_buffer_stack_top
+
+
;
YY_CURRENT_BUFFER_LVALUE
=
new_buffer
;
sksl_load_buffer_state
(
yyscanner
)
;
yyg
-
>
yy_did_buffer_switch_on_eof
=
1
;
}
void
skslpop_buffer_state
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
return
;
sksl_delete_buffer
(
YY_CURRENT_BUFFER
yyscanner
)
;
YY_CURRENT_BUFFER_LVALUE
=
NULL
;
if
(
yyg
-
>
yy_buffer_stack_top
>
0
)
-
-
yyg
-
>
yy_buffer_stack_top
;
if
(
YY_CURRENT_BUFFER
)
{
sksl_load_buffer_state
(
yyscanner
)
;
yyg
-
>
yy_did_buffer_switch_on_eof
=
1
;
}
}
static
void
skslensure_buffer_stack
(
yyscan_t
yyscanner
)
{
yy_size_t
num_to_alloc
;
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
yyg
-
>
yy_buffer_stack
)
{
num_to_alloc
=
1
;
yyg
-
>
yy_buffer_stack
=
(
struct
yy_buffer_state
*
*
)
skslalloc
(
num_to_alloc
*
sizeof
(
struct
yy_buffer_state
*
)
yyscanner
)
;
if
(
!
yyg
-
>
yy_buffer_stack
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
skslensure_buffer_stack
(
)
"
)
;
memset
(
yyg
-
>
yy_buffer_stack
0
num_to_alloc
*
sizeof
(
struct
yy_buffer_state
*
)
)
;
yyg
-
>
yy_buffer_stack_max
=
num_to_alloc
;
yyg
-
>
yy_buffer_stack_top
=
0
;
return
;
}
if
(
yyg
-
>
yy_buffer_stack_top
>
=
(
yyg
-
>
yy_buffer_stack_max
)
-
1
)
{
yy_size_t
grow_size
=
8
;
num_to_alloc
=
yyg
-
>
yy_buffer_stack_max
+
grow_size
;
yyg
-
>
yy_buffer_stack
=
(
struct
yy_buffer_state
*
*
)
skslrealloc
(
yyg
-
>
yy_buffer_stack
num_to_alloc
*
sizeof
(
struct
yy_buffer_state
*
)
yyscanner
)
;
if
(
!
yyg
-
>
yy_buffer_stack
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
skslensure_buffer_stack
(
)
"
)
;
memset
(
yyg
-
>
yy_buffer_stack
+
yyg
-
>
yy_buffer_stack_max
0
grow_size
*
sizeof
(
struct
yy_buffer_state
*
)
)
;
yyg
-
>
yy_buffer_stack_max
=
num_to_alloc
;
}
}
YY_BUFFER_STATE
sksl_scan_buffer
(
char
*
base
yy_size_t
size
yyscan_t
yyscanner
)
{
YY_BUFFER_STATE
b
;
if
(
size
<
2
|
|
base
[
size
-
2
]
!
=
YY_END_OF_BUFFER_CHAR
|
|
base
[
size
-
1
]
!
=
YY_END_OF_BUFFER_CHAR
)
return
NULL
;
b
=
(
YY_BUFFER_STATE
)
skslalloc
(
sizeof
(
struct
yy_buffer_state
)
yyscanner
)
;
if
(
!
b
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
sksl_scan_buffer
(
)
"
)
;
b
-
>
yy_buf_size
=
(
int
)
(
size
-
2
)
;
b
-
>
yy_buf_pos
=
b
-
>
yy_ch_buf
=
base
;
b
-
>
yy_is_our_buffer
=
0
;
b
-
>
yy_input_file
=
NULL
;
b
-
>
yy_n_chars
=
b
-
>
yy_buf_size
;
b
-
>
yy_is_interactive
=
0
;
b
-
>
yy_at_bol
=
1
;
b
-
>
yy_fill_buffer
=
0
;
b
-
>
yy_buffer_status
=
YY_BUFFER_NEW
;
sksl_switch_to_buffer
(
b
yyscanner
)
;
return
b
;
}
YY_BUFFER_STATE
sksl_scan_string
(
const
char
*
yystr
yyscan_t
yyscanner
)
{
return
sksl_scan_bytes
(
yystr
(
int
)
strlen
(
yystr
)
yyscanner
)
;
}
YY_BUFFER_STATE
sksl_scan_bytes
(
const
char
*
yybytes
int
_yybytes_len
yyscan_t
yyscanner
)
{
YY_BUFFER_STATE
b
;
char
*
buf
;
yy_size_t
n
;
int
i
;
n
=
(
yy_size_t
)
(
_yybytes_len
+
2
)
;
buf
=
(
char
*
)
skslalloc
(
n
yyscanner
)
;
if
(
!
buf
)
YY_FATAL_ERROR
(
"
out
of
dynamic
memory
in
sksl_scan_bytes
(
)
"
)
;
for
(
i
=
0
;
i
<
_yybytes_len
;
+
+
i
)
buf
[
i
]
=
yybytes
[
i
]
;
buf
[
_yybytes_len
]
=
buf
[
_yybytes_len
+
1
]
=
YY_END_OF_BUFFER_CHAR
;
b
=
sksl_scan_buffer
(
buf
n
yyscanner
)
;
if
(
!
b
)
YY_FATAL_ERROR
(
"
bad
buffer
in
sksl_scan_bytes
(
)
"
)
;
b
-
>
yy_is_our_buffer
=
1
;
return
b
;
}
#
ifndef
YY_EXIT_FAILURE
#
define
YY_EXIT_FAILURE
2
#
endif
static
void
yynoreturn
yy_fatal_error
(
const
char
*
msg
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
(
void
)
yyg
;
(
void
)
fprintf
(
stderr
"
%
s
\
n
"
msg
)
;
exit
(
YY_EXIT_FAILURE
)
;
}
#
undef
yyless
#
define
yyless
(
n
)
\
do
\
{
\
/
*
Undo
effects
of
setting
up
yytext
.
*
/
\
int
yyless_macro_arg
=
(
n
)
;
\
YY_LESS_LINENO
(
yyless_macro_arg
)
;
\
yytext
[
yyleng
]
=
yyg
-
>
yy_hold_char
;
\
yyg
-
>
yy_c_buf_p
=
yytext
+
yyless_macro_arg
;
\
yyg
-
>
yy_hold_char
=
*
yyg
-
>
yy_c_buf_p
;
\
*
yyg
-
>
yy_c_buf_p
=
'
\
0
'
;
\
yyleng
=
yyless_macro_arg
;
\
}
\
while
(
0
)
YY_EXTRA_TYPE
skslget_extra
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yyextra
;
}
int
skslget_lineno
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
return
0
;
return
yylineno
;
}
int
skslget_column
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
return
0
;
return
yycolumn
;
}
FILE
*
skslget_in
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yyin
;
}
FILE
*
skslget_out
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yyout
;
}
int
skslget_leng
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yyleng
;
}
char
*
skslget_text
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yytext
;
}
void
skslset_extra
(
YY_EXTRA_TYPE
user_defined
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yyextra
=
user_defined
;
}
void
skslset_lineno
(
int
_line_number
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
YY_FATAL_ERROR
(
"
skslset_lineno
called
with
no
buffer
"
)
;
yylineno
=
_line_number
;
}
void
skslset_column
(
int
_column_no
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
if
(
!
YY_CURRENT_BUFFER
)
YY_FATAL_ERROR
(
"
skslset_column
called
with
no
buffer
"
)
;
yycolumn
=
_column_no
;
}
void
skslset_in
(
FILE
*
_in_str
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yyin
=
_in_str
;
}
void
skslset_out
(
FILE
*
_out_str
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yyout
=
_out_str
;
}
int
skslget_debug
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
return
yy_flex_debug
;
}
void
skslset_debug
(
int
_bdebug
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yy_flex_debug
=
_bdebug
;
}
int
sksllex_init
(
yyscan_t
*
ptr_yy_globals
)
{
if
(
ptr_yy_globals
=
=
NULL
)
{
errno
=
EINVAL
;
return
1
;
}
*
ptr_yy_globals
=
(
yyscan_t
)
skslalloc
(
sizeof
(
struct
yyguts_t
)
NULL
)
;
if
(
*
ptr_yy_globals
=
=
NULL
)
{
errno
=
ENOMEM
;
return
1
;
}
memset
(
*
ptr_yy_globals
0x00
sizeof
(
struct
yyguts_t
)
)
;
return
yy_init_globals
(
*
ptr_yy_globals
)
;
}
int
sksllex_init_extra
(
YY_EXTRA_TYPE
yy_user_defined
yyscan_t
*
ptr_yy_globals
)
{
struct
yyguts_t
dummy_yyguts
;
skslset_extra
(
yy_user_defined
&
dummy_yyguts
)
;
if
(
ptr_yy_globals
=
=
NULL
)
{
errno
=
EINVAL
;
return
1
;
}
*
ptr_yy_globals
=
(
yyscan_t
)
skslalloc
(
sizeof
(
struct
yyguts_t
)
&
dummy_yyguts
)
;
if
(
*
ptr_yy_globals
=
=
NULL
)
{
errno
=
ENOMEM
;
return
1
;
}
memset
(
*
ptr_yy_globals
0x00
sizeof
(
struct
yyguts_t
)
)
;
skslset_extra
(
yy_user_defined
*
ptr_yy_globals
)
;
return
yy_init_globals
(
*
ptr_yy_globals
)
;
}
static
int
yy_init_globals
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
yyg
-
>
yy_buffer_stack
=
NULL
;
yyg
-
>
yy_buffer_stack_top
=
0
;
yyg
-
>
yy_buffer_stack_max
=
0
;
yyg
-
>
yy_c_buf_p
=
NULL
;
yyg
-
>
yy_init
=
0
;
yyg
-
>
yy_start
=
0
;
yyg
-
>
yy_start_stack_ptr
=
0
;
yyg
-
>
yy_start_stack_depth
=
0
;
yyg
-
>
yy_start_stack
=
NULL
;
#
ifdef
YY_STDINIT
yyin
=
stdin
;
yyout
=
stdout
;
#
else
yyin
=
NULL
;
yyout
=
NULL
;
#
endif
return
0
;
}
int
sksllex_destroy
(
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
while
(
YY_CURRENT_BUFFER
)
{
sksl_delete_buffer
(
YY_CURRENT_BUFFER
yyscanner
)
;
YY_CURRENT_BUFFER_LVALUE
=
NULL
;
skslpop_buffer_state
(
yyscanner
)
;
}
skslfree
(
yyg
-
>
yy_buffer_stack
yyscanner
)
;
yyg
-
>
yy_buffer_stack
=
NULL
;
skslfree
(
yyg
-
>
yy_start_stack
yyscanner
)
;
yyg
-
>
yy_start_stack
=
NULL
;
yy_init_globals
(
yyscanner
)
;
skslfree
(
yyscanner
yyscanner
)
;
yyscanner
=
NULL
;
return
0
;
}
#
ifndef
yytext_ptr
static
void
yy_flex_strncpy
(
char
*
s1
const
char
*
s2
int
n
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
(
void
)
yyg
;
int
i
;
for
(
i
=
0
;
i
<
n
;
+
+
i
)
s1
[
i
]
=
s2
[
i
]
;
}
#
endif
#
ifdef
YY_NEED_STRLEN
static
int
yy_flex_strlen
(
const
char
*
s
yyscan_t
yyscanner
)
{
int
n
;
for
(
n
=
0
;
s
[
n
]
;
+
+
n
)
;
return
n
;
}
#
endif
void
*
skslalloc
(
yy_size_t
size
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
(
void
)
yyg
;
return
malloc
(
size
)
;
}
void
*
skslrealloc
(
void
*
ptr
yy_size_t
size
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
(
void
)
yyg
;
return
realloc
(
ptr
size
)
;
}
void
skslfree
(
void
*
ptr
yyscan_t
yyscanner
)
{
struct
yyguts_t
*
yyg
=
(
struct
yyguts_t
*
)
yyscanner
;
(
void
)
yyg
;
free
(
(
char
*
)
ptr
)
;
}
#
define
YYTABLES_NAME
"
yytables
"
#
line
214
"
sksl
.
flex
"
int
skslwrap
(
yyscan_t
scanner
)
{
return
1
;
}
