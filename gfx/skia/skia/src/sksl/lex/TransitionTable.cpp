#
include
"
src
/
sksl
/
lex
/
DFA
.
h
"
#
include
"
src
/
sksl
/
lex
/
TransitionTable
.
h
"
#
include
<
array
>
#
include
<
algorithm
>
#
include
<
cassert
>
#
include
<
cmath
>
#
include
<
unordered_map
>
#
include
<
unordered_set
>
#
include
<
utility
>
#
include
<
vector
>
namespace
{
constexpr
int
kNumBits
=
2
;
constexpr
int
kNumValues
=
(
1
<
<
kNumBits
)
-
1
;
constexpr
int
kDataPerByte
=
8
/
kNumBits
;
enum
IndexType
{
kCompactEntry
=
0
kFullEntry
}
;
struct
IndexEntry
{
IndexType
type
;
int
pos
;
}
;
struct
CompactEntry
{
std
:
:
array
<
int
kNumValues
>
v
=
{
}
;
std
:
:
vector
<
int
>
data
;
}
;
struct
FullEntry
{
std
:
:
vector
<
int
>
data
;
}
;
using
TransitionSet
=
std
:
:
unordered_set
<
int
>
;
static
int
add_compact_entry
(
const
TransitionSet
&
transitionSet
const
std
:
:
vector
<
int
>
&
data
std
:
:
vector
<
CompactEntry
>
*
entries
)
{
CompactEntry
result
{
}
;
assert
(
transitionSet
.
size
(
)
<
=
result
.
v
.
size
(
)
)
;
std
:
:
copy
(
transitionSet
.
begin
(
)
transitionSet
.
end
(
)
result
.
v
.
begin
(
)
)
;
std
:
:
sort
(
result
.
v
.
rbegin
(
)
result
.
v
.
rend
(
)
)
;
std
:
:
unordered_map
<
int
int
>
translationTable
;
for
(
size_t
index
=
0
;
index
<
result
.
v
.
size
(
)
;
+
+
index
)
{
translationTable
[
result
.
v
[
index
]
]
=
index
;
}
translationTable
[
0
]
=
result
.
v
.
size
(
)
;
for
(
size_t
index
=
0
;
index
<
data
.
size
(
)
;
+
+
index
)
{
int
value
=
data
[
index
]
;
assert
(
translationTable
.
find
(
value
)
!
=
translationTable
.
end
(
)
)
;
result
.
data
.
push_back
(
translationTable
[
value
]
)
;
}
for
(
size_t
index
=
0
;
index
<
entries
-
>
size
(
)
;
+
+
index
)
{
if
(
entries
-
>
at
(
index
)
.
v
=
=
result
.
v
&
&
entries
-
>
at
(
index
)
.
data
=
=
result
.
data
)
{
return
index
;
}
}
entries
-
>
push_back
(
std
:
:
move
(
result
)
)
;
return
(
int
)
(
entries
-
>
size
(
)
-
1
)
;
}
static
int
add_full_entry
(
const
TransitionSet
&
transitionMap
const
std
:
:
vector
<
int
>
&
data
std
:
:
vector
<
FullEntry
>
*
entries
)
{
FullEntry
result
{
}
;
result
.
data
=
std
:
:
vector
<
int
>
(
data
.
begin
(
)
data
.
end
(
)
)
;
for
(
size_t
index
=
0
;
index
<
entries
-
>
size
(
)
;
+
+
index
)
{
if
(
entries
-
>
at
(
index
)
.
data
=
=
result
.
data
)
{
return
index
;
}
}
entries
-
>
push_back
(
std
:
:
move
(
result
)
)
;
return
(
int
)
(
entries
-
>
size
(
)
-
1
)
;
}
}
void
WriteTransitionTable
(
std
:
:
ofstream
&
out
const
DFA
&
dfa
size_t
states
)
{
int
numTransitions
=
dfa
.
fTransitions
.
size
(
)
;
std
:
:
vector
<
CompactEntry
>
compactEntries
;
std
:
:
vector
<
FullEntry
>
fullEntries
;
std
:
:
vector
<
IndexEntry
>
indices
;
for
(
size_t
s
=
0
;
s
<
states
;
+
+
s
)
{
TransitionSet
transitionSet
;
std
:
:
vector
<
int
>
data
(
numTransitions
)
;
for
(
int
t
=
0
;
t
<
numTransitions
;
+
+
t
)
{
if
(
(
size_t
)
t
<
dfa
.
fTransitions
.
size
(
)
&
&
s
<
dfa
.
fTransitions
[
t
]
.
size
(
)
)
{
int
value
=
dfa
.
fTransitions
[
t
]
[
s
]
;
assert
(
value
>
=
0
&
&
value
<
(
int
)
states
)
;
data
[
t
]
=
value
;
transitionSet
.
insert
(
value
)
;
}
}
transitionSet
.
erase
(
0
)
;
if
(
transitionSet
.
size
(
)
<
=
kNumValues
)
{
int
index
=
add_compact_entry
(
transitionSet
data
&
compactEntries
)
;
indices
.
push_back
(
IndexEntry
{
kCompactEntry
index
}
)
;
}
else
{
int
index
=
add_full_entry
(
transitionSet
data
&
fullEntries
)
;
indices
.
push_back
(
IndexEntry
{
kFullEntry
index
}
)
;
}
}
int
maxValue
=
0
;
for
(
const
CompactEntry
&
entry
:
compactEntries
)
{
for
(
int
index
=
0
;
index
<
kNumValues
;
+
+
index
)
{
maxValue
=
std
:
:
max
(
maxValue
entry
.
v
[
index
]
)
;
}
}
int
bitsPerValue
=
std
:
:
ceil
(
std
:
:
log2
(
maxValue
)
)
;
maxValue
=
(
1
<
<
bitsPerValue
)
-
1
;
assert
(
bitsPerValue
<
=
10
)
;
out
<
<
"
using
IndexEntry
=
int16_t
;
\
n
"
<
<
"
struct
FullEntry
{
\
n
"
<
<
"
State
data
[
"
<
<
numTransitions
<
<
"
]
;
\
n
"
<
<
"
}
;
\
n
"
;
static_assert
(
kNumBits
=
=
2
)
;
out
<
<
"
struct
CompactEntry
{
\
n
"
<
<
"
uint32_t
values
;
\
n
"
<
<
"
uint8_t
data
[
"
<
<
std
:
:
ceil
(
float
(
numTransitions
)
/
float
(
kDataPerByte
)
)
<
<
"
]
;
\
n
"
<
<
"
}
;
\
n
"
;
out
<
<
"
static
constexpr
FullEntry
kFull
[
]
=
{
\
n
"
;
for
(
const
FullEntry
&
entry
:
fullEntries
)
{
out
<
<
"
{
"
;
for
(
int
value
:
entry
.
data
)
{
out
<
<
value
<
<
"
"
;
}
out
<
<
"
}
\
n
"
;
}
out
<
<
"
}
;
\
n
"
;
out
<
<
"
static
constexpr
CompactEntry
kCompact
[
]
=
{
\
n
"
;
for
(
const
CompactEntry
&
entry
:
compactEntries
)
{
out
<
<
"
{
"
;
static_assert
(
kNumBits
=
=
2
)
;
out
<
<
entry
.
v
[
0
]
;
if
(
entry
.
v
[
1
]
)
{
out
<
<
"
|
(
"
<
<
entry
.
v
[
1
]
<
<
"
<
<
"
<
<
bitsPerValue
<
<
"
)
"
;
}
if
(
entry
.
v
[
2
]
)
{
out
<
<
"
|
(
"
<
<
entry
.
v
[
2
]
<
<
"
<
<
"
<
<
(
2
*
bitsPerValue
)
<
<
"
)
"
;
}
out
<
<
"
{
"
;
unsigned
int
shiftBits
=
0
combinedBits
=
0
;
for
(
int
index
=
0
;
index
<
numTransitions
;
index
+
+
)
{
combinedBits
|
=
entry
.
data
[
index
]
<
<
shiftBits
;
shiftBits
+
=
kNumBits
;
assert
(
shiftBits
<
=
8
)
;
if
(
shiftBits
=
=
8
)
{
out
<
<
combinedBits
<
<
"
"
;
shiftBits
=
0
;
combinedBits
=
0
;
}
}
if
(
shiftBits
>
0
)
{
out
<
<
combinedBits
;
}
out
<
<
"
}
}
\
n
"
;
}
out
<
<
"
}
;
\
n
"
<
<
"
static
constexpr
IndexEntry
kIndices
[
]
=
{
\
n
"
;
for
(
const
IndexEntry
&
entry
:
indices
)
{
if
(
entry
.
type
=
=
kFullEntry
)
{
out
<
<
~
entry
.
pos
<
<
"
"
;
}
else
{
out
<
<
entry
.
pos
<
<
"
"
;
}
}
out
<
<
"
}
;
\
n
"
<
<
"
static
State
get_transition
(
uint8_t
transition
State
state
)
{
\
n
"
<
<
"
IndexEntry
index
=
kIndices
[
state
]
;
\
n
"
<
<
"
if
(
index
<
0
)
{
return
kFull
[
~
index
]
.
data
[
transition
]
;
}
\
n
"
<
<
"
const
CompactEntry
&
entry
=
kCompact
[
index
]
;
\
n
"
<
<
"
int
v
=
entry
.
data
[
transition
>
>
"
<
<
std
:
:
log2
(
kDataPerByte
)
<
<
"
]
;
\
n
"
<
<
"
v
>
>
=
"
<
<
kNumBits
<
<
"
*
(
transition
&
"
<
<
kDataPerByte
-
1
<
<
"
)
;
\
n
"
<
<
"
v
&
=
"
<
<
kNumValues
<
<
"
;
\
n
"
<
<
"
v
*
=
"
<
<
bitsPerValue
<
<
"
;
\
n
"
<
<
"
return
(
entry
.
values
>
>
v
)
&
"
<
<
maxValue
<
<
"
;
\
n
"
<
<
"
}
\
n
"
;
}
