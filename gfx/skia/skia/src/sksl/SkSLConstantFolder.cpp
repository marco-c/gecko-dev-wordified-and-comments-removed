#
include
"
src
/
sksl
/
SkSLConstantFolder
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
SkSLModifiers
.
h
"
#
include
"
include
/
private
/
base
/
SkFloatingPoint
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
include
/
sksl
/
SkSLErrorReporter
.
h
"
#
include
"
include
/
sksl
/
SkSLPosition
.
h
"
#
include
"
src
/
sksl
/
SkSLAnalysis
.
h
"
#
include
"
src
/
sksl
/
SkSLContext
.
h
"
#
include
"
src
/
sksl
/
SkSLProgramSettings
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLBinaryExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorCompound
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorDiagonalMatrix
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorSplat
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLLiteral
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLPrefixExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLType
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLVariable
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLVariableReference
.
h
"
#
include
<
cstdint
>
#
include
<
float
.
h
>
#
include
<
limits
>
#
include
<
optional
>
#
include
<
string
>
#
include
<
utility
>
namespace
SkSL
{
static
bool
is_vec_or_mat
(
const
Type
&
type
)
{
switch
(
type
.
typeKind
(
)
)
{
case
Type
:
:
TypeKind
:
:
kMatrix
:
case
Type
:
:
TypeKind
:
:
kVector
:
return
true
;
default
:
return
false
;
}
}
static
std
:
:
unique_ptr
<
Expression
>
eliminate_no_op_boolean
(
Position
pos
const
Expression
&
left
Operator
op
const
Expression
&
right
)
{
bool
rightVal
=
right
.
as
<
Literal
>
(
)
.
boolValue
(
)
;
if
(
(
op
.
kind
(
)
=
=
Operator
:
:
Kind
:
:
LOGICALAND
&
&
rightVal
)
|
|
(
op
.
kind
(
)
=
=
Operator
:
:
Kind
:
:
LOGICALOR
&
&
!
rightVal
)
|
|
(
op
.
kind
(
)
=
=
Operator
:
:
Kind
:
:
LOGICALXOR
&
&
!
rightVal
)
|
|
(
op
.
kind
(
)
=
=
Operator
:
:
Kind
:
:
EQEQ
&
&
rightVal
)
|
|
(
op
.
kind
(
)
=
=
Operator
:
:
Kind
:
:
NEQ
&
&
!
rightVal
)
)
{
return
left
.
clone
(
pos
)
;
}
return
nullptr
;
}
static
std
:
:
unique_ptr
<
Expression
>
short_circuit_boolean
(
Position
pos
const
Expression
&
left
Operator
op
const
Expression
&
right
)
{
bool
leftVal
=
left
.
as
<
Literal
>
(
)
.
boolValue
(
)
;
if
(
(
op
.
kind
(
)
=
=
Operator
:
:
Kind
:
:
LOGICALAND
&
&
!
leftVal
)
|
|
(
op
.
kind
(
)
=
=
Operator
:
:
Kind
:
:
LOGICALOR
&
&
leftVal
)
)
{
return
left
.
clone
(
pos
)
;
}
return
eliminate_no_op_boolean
(
pos
right
op
left
)
;
}
static
std
:
:
unique_ptr
<
Expression
>
simplify_constant_equality
(
const
Context
&
context
Position
pos
const
Expression
&
left
Operator
op
const
Expression
&
right
)
{
if
(
op
.
kind
(
)
=
=
Operator
:
:
Kind
:
:
EQEQ
|
|
op
.
kind
(
)
=
=
Operator
:
:
Kind
:
:
NEQ
)
{
bool
equality
=
(
op
.
kind
(
)
=
=
Operator
:
:
Kind
:
:
EQEQ
)
;
switch
(
left
.
compareConstant
(
right
)
)
{
case
Expression
:
:
ComparisonResult
:
:
kNotEqual
:
equality
=
!
equality
;
[
[
fallthrough
]
]
;
case
Expression
:
:
ComparisonResult
:
:
kEqual
:
return
Literal
:
:
MakeBool
(
context
pos
equality
)
;
case
Expression
:
:
ComparisonResult
:
:
kUnknown
:
break
;
}
}
return
nullptr
;
}
static
std
:
:
unique_ptr
<
Expression
>
simplify_matrix_multiplication
(
const
Context
&
context
Position
pos
const
Expression
&
left
const
Expression
&
right
int
leftColumns
int
leftRows
int
rightColumns
int
rightRows
)
{
const
Type
&
componentType
=
left
.
type
(
)
.
componentType
(
)
;
SkASSERT
(
componentType
.
matches
(
right
.
type
(
)
.
componentType
(
)
)
)
;
double
leftVals
[
4
]
[
4
]
;
for
(
int
c
=
0
;
c
<
leftColumns
;
+
+
c
)
{
for
(
int
r
=
0
;
r
<
leftRows
;
+
+
r
)
{
leftVals
[
c
]
[
r
]
=
*
left
.
getConstantValue
(
(
c
*
leftRows
)
+
r
)
;
}
}
double
rightVals
[
4
]
[
4
]
;
for
(
int
c
=
0
;
c
<
rightColumns
;
+
+
c
)
{
for
(
int
r
=
0
;
r
<
rightRows
;
+
+
r
)
{
rightVals
[
c
]
[
r
]
=
*
right
.
getConstantValue
(
(
c
*
rightRows
)
+
r
)
;
}
}
SkASSERT
(
leftColumns
=
=
rightRows
)
;
int
outColumns
=
rightColumns
outRows
=
leftRows
;
ExpressionArray
args
;
args
.
reserve_back
(
outColumns
*
outRows
)
;
for
(
int
c
=
0
;
c
<
outColumns
;
+
+
c
)
{
for
(
int
r
=
0
;
r
<
outRows
;
+
+
r
)
{
double
val
=
0
;
for
(
int
dotIdx
=
0
;
dotIdx
<
leftColumns
;
+
+
dotIdx
)
{
val
+
=
leftVals
[
dotIdx
]
[
r
]
*
rightVals
[
c
]
[
dotIdx
]
;
}
args
.
push_back
(
Literal
:
:
Make
(
pos
val
&
componentType
)
)
;
}
}
if
(
outColumns
=
=
1
)
{
std
:
:
swap
(
outColumns
outRows
)
;
}
const
Type
&
resultType
=
componentType
.
toCompound
(
context
outColumns
outRows
)
;
return
ConstructorCompound
:
:
Make
(
context
pos
resultType
std
:
:
move
(
args
)
)
;
}
static
std
:
:
unique_ptr
<
Expression
>
simplify_matrix_times_matrix
(
const
Context
&
context
Position
pos
const
Expression
&
left
const
Expression
&
right
)
{
const
Type
&
leftType
=
left
.
type
(
)
;
const
Type
&
rightType
=
right
.
type
(
)
;
SkASSERT
(
leftType
.
isMatrix
(
)
)
;
SkASSERT
(
rightType
.
isMatrix
(
)
)
;
return
simplify_matrix_multiplication
(
context
pos
left
right
leftType
.
columns
(
)
leftType
.
rows
(
)
rightType
.
columns
(
)
rightType
.
rows
(
)
)
;
}
static
std
:
:
unique_ptr
<
Expression
>
simplify_vector_times_matrix
(
const
Context
&
context
Position
pos
const
Expression
&
left
const
Expression
&
right
)
{
const
Type
&
leftType
=
left
.
type
(
)
;
const
Type
&
rightType
=
right
.
type
(
)
;
SkASSERT
(
leftType
.
isVector
(
)
)
;
SkASSERT
(
rightType
.
isMatrix
(
)
)
;
return
simplify_matrix_multiplication
(
context
pos
left
right
leftType
.
columns
(
)
1
rightType
.
columns
(
)
rightType
.
rows
(
)
)
;
}
static
std
:
:
unique_ptr
<
Expression
>
simplify_matrix_times_vector
(
const
Context
&
context
Position
pos
const
Expression
&
left
const
Expression
&
right
)
{
const
Type
&
leftType
=
left
.
type
(
)
;
const
Type
&
rightType
=
right
.
type
(
)
;
SkASSERT
(
leftType
.
isMatrix
(
)
)
;
SkASSERT
(
rightType
.
isVector
(
)
)
;
return
simplify_matrix_multiplication
(
context
pos
left
right
leftType
.
columns
(
)
leftType
.
rows
(
)
1
rightType
.
columns
(
)
)
;
}
static
std
:
:
unique_ptr
<
Expression
>
simplify_componentwise
(
const
Context
&
context
Position
pos
const
Expression
&
left
Operator
op
const
Expression
&
right
)
{
SkASSERT
(
is_vec_or_mat
(
left
.
type
(
)
)
)
;
SkASSERT
(
left
.
type
(
)
.
matches
(
right
.
type
(
)
)
)
;
const
Type
&
type
=
left
.
type
(
)
;
if
(
std
:
:
unique_ptr
<
Expression
>
result
=
simplify_constant_equality
(
context
pos
left
op
right
)
)
{
return
result
;
}
using
FoldFn
=
double
(
*
)
(
double
double
)
;
FoldFn
foldFn
;
switch
(
op
.
kind
(
)
)
{
case
Operator
:
:
Kind
:
:
PLUS
:
foldFn
=
+
[
]
(
double
a
double
b
)
{
return
a
+
b
;
}
;
break
;
case
Operator
:
:
Kind
:
:
MINUS
:
foldFn
=
+
[
]
(
double
a
double
b
)
{
return
a
-
b
;
}
;
break
;
case
Operator
:
:
Kind
:
:
STAR
:
foldFn
=
+
[
]
(
double
a
double
b
)
{
return
a
*
b
;
}
;
break
;
case
Operator
:
:
Kind
:
:
SLASH
:
foldFn
=
+
[
]
(
double
a
double
b
)
{
return
a
/
b
;
}
;
break
;
default
:
return
nullptr
;
}
const
Type
&
componentType
=
type
.
componentType
(
)
;
SkASSERT
(
componentType
.
isNumber
(
)
)
;
double
minimumValue
=
componentType
.
minimumValue
(
)
;
double
maximumValue
=
componentType
.
maximumValue
(
)
;
ExpressionArray
args
;
int
numSlots
=
type
.
slotCount
(
)
;
args
.
reserve_back
(
numSlots
)
;
for
(
int
i
=
0
;
i
<
numSlots
;
i
+
+
)
{
double
value
=
foldFn
(
*
left
.
getConstantValue
(
i
)
*
right
.
getConstantValue
(
i
)
)
;
if
(
value
<
minimumValue
|
|
value
>
maximumValue
)
{
return
nullptr
;
}
args
.
push_back
(
Literal
:
:
Make
(
pos
value
&
componentType
)
)
;
}
return
ConstructorCompound
:
:
Make
(
context
pos
type
std
:
:
move
(
args
)
)
;
}
static
std
:
:
unique_ptr
<
Expression
>
splat_scalar
(
const
Context
&
context
const
Expression
&
scalar
const
Type
&
type
)
{
if
(
type
.
isVector
(
)
)
{
return
ConstructorSplat
:
:
Make
(
context
scalar
.
fPosition
type
scalar
.
clone
(
)
)
;
}
if
(
type
.
isMatrix
(
)
)
{
int
numSlots
=
type
.
slotCount
(
)
;
ExpressionArray
splatMatrix
;
splatMatrix
.
reserve_back
(
numSlots
)
;
for
(
int
index
=
0
;
index
<
numSlots
;
+
+
index
)
{
splatMatrix
.
push_back
(
scalar
.
clone
(
)
)
;
}
return
ConstructorCompound
:
:
Make
(
context
scalar
.
fPosition
type
std
:
:
move
(
splatMatrix
)
)
;
}
SkDEBUGFAILF
(
"
unsupported
type
%
s
"
type
.
description
(
)
.
c_str
(
)
)
;
return
nullptr
;
}
static
std
:
:
unique_ptr
<
Expression
>
cast_expression
(
const
Context
&
context
Position
pos
const
Expression
&
expr
const
Type
&
type
)
{
SkASSERT
(
type
.
componentType
(
)
.
matches
(
expr
.
type
(
)
.
componentType
(
)
)
)
;
if
(
expr
.
type
(
)
.
isScalar
(
)
)
{
if
(
type
.
isMatrix
(
)
)
{
return
ConstructorDiagonalMatrix
:
:
Make
(
context
pos
type
expr
.
clone
(
)
)
;
}
if
(
type
.
isVector
(
)
)
{
return
ConstructorSplat
:
:
Make
(
context
pos
type
expr
.
clone
(
)
)
;
}
}
if
(
type
.
matches
(
expr
.
type
(
)
)
)
{
return
expr
.
clone
(
pos
)
;
}
return
nullptr
;
}
static
std
:
:
unique_ptr
<
Expression
>
zero_expression
(
const
Context
&
context
Position
pos
const
Type
&
type
)
{
std
:
:
unique_ptr
<
Expression
>
zero
=
Literal
:
:
Make
(
pos
0
.
0
&
type
.
componentType
(
)
)
;
if
(
type
.
isScalar
(
)
)
{
return
zero
;
}
if
(
type
.
isVector
(
)
)
{
return
ConstructorSplat
:
:
Make
(
context
pos
type
std
:
:
move
(
zero
)
)
;
}
if
(
type
.
isMatrix
(
)
)
{
return
ConstructorDiagonalMatrix
:
:
Make
(
context
pos
type
std
:
:
move
(
zero
)
)
;
}
SkDEBUGFAILF
(
"
unsupported
type
%
s
"
type
.
description
(
)
.
c_str
(
)
)
;
return
nullptr
;
}
static
std
:
:
unique_ptr
<
Expression
>
negate_expression
(
const
Context
&
context
Position
pos
const
Expression
&
expr
const
Type
&
type
)
{
std
:
:
unique_ptr
<
Expression
>
ctor
=
cast_expression
(
context
pos
expr
type
)
;
return
ctor
?
PrefixExpression
:
:
Make
(
context
pos
Operator
:
:
Kind
:
:
MINUS
std
:
:
move
(
ctor
)
)
:
nullptr
;
}
bool
ConstantFolder
:
:
GetConstantInt
(
const
Expression
&
value
SKSL_INT
*
out
)
{
const
Expression
*
expr
=
GetConstantValueForVariable
(
value
)
;
if
(
!
expr
-
>
isIntLiteral
(
)
)
{
return
false
;
}
*
out
=
expr
-
>
as
<
Literal
>
(
)
.
intValue
(
)
;
return
true
;
}
bool
ConstantFolder
:
:
GetConstantValue
(
const
Expression
&
value
double
*
out
)
{
const
Expression
*
expr
=
GetConstantValueForVariable
(
value
)
;
if
(
!
expr
-
>
is
<
Literal
>
(
)
)
{
return
false
;
}
*
out
=
expr
-
>
as
<
Literal
>
(
)
.
value
(
)
;
return
true
;
}
static
bool
contains_constant_zero
(
const
Expression
&
expr
)
{
int
numSlots
=
expr
.
type
(
)
.
slotCount
(
)
;
for
(
int
index
=
0
;
index
<
numSlots
;
+
+
index
)
{
std
:
:
optional
<
double
>
slotVal
=
expr
.
getConstantValue
(
index
)
;
if
(
slotVal
.
has_value
(
)
&
&
*
slotVal
=
=
0
.
0
)
{
return
true
;
}
}
return
false
;
}
static
bool
is_constant_splat
(
const
Expression
&
expr
double
value
)
{
int
numSlots
=
expr
.
type
(
)
.
slotCount
(
)
;
for
(
int
index
=
0
;
index
<
numSlots
;
+
+
index
)
{
std
:
:
optional
<
double
>
slotVal
=
expr
.
getConstantValue
(
index
)
;
if
(
!
slotVal
.
has_value
(
)
|
|
*
slotVal
!
=
value
)
{
return
false
;
}
}
return
true
;
}
static
bool
is_constant_diagonal
(
const
Expression
&
expr
double
value
)
{
SkASSERT
(
expr
.
type
(
)
.
isMatrix
(
)
)
;
int
columns
=
expr
.
type
(
)
.
columns
(
)
;
int
rows
=
expr
.
type
(
)
.
rows
(
)
;
if
(
columns
!
=
rows
)
{
return
false
;
}
int
slotIdx
=
0
;
for
(
int
c
=
0
;
c
<
columns
;
+
+
c
)
{
for
(
int
r
=
0
;
r
<
rows
;
+
+
r
)
{
double
expectation
=
(
c
=
=
r
)
?
value
:
0
;
std
:
:
optional
<
double
>
slotVal
=
expr
.
getConstantValue
(
slotIdx
+
+
)
;
if
(
!
slotVal
.
has_value
(
)
|
|
*
slotVal
!
=
expectation
)
{
return
false
;
}
}
}
return
true
;
}
static
bool
is_constant_value
(
const
Expression
&
expr
double
value
)
{
return
expr
.
type
(
)
.
isMatrix
(
)
?
is_constant_diagonal
(
expr
value
)
:
is_constant_splat
(
expr
value
)
;
}
static
std
:
:
unique_ptr
<
Expression
>
make_reciprocal_expression
(
const
Context
&
context
const
Expression
&
right
)
{
if
(
right
.
type
(
)
.
isMatrix
(
)
|
|
!
right
.
type
(
)
.
componentType
(
)
.
isFloat
(
)
)
{
return
nullptr
;
}
int
nslots
=
right
.
type
(
)
.
slotCount
(
)
;
SkSTArray
<
4
double
>
values
;
for
(
int
index
=
0
;
index
<
nslots
;
+
+
index
)
{
std
:
:
optional
<
double
>
value
=
right
.
getConstantValue
(
index
)
;
if
(
!
value
)
{
return
nullptr
;
}
*
value
=
sk_ieee_double_divide
(
1
.
0
*
value
)
;
if
(
*
value
>
=
-
FLT_MAX
&
&
*
value
<
=
FLT_MAX
&
&
*
value
!
=
0
.
0
)
{
values
.
push_back
(
*
value
)
;
}
else
{
return
nullptr
;
}
}
ExpressionArray
exprs
;
exprs
.
reserve_back
(
nslots
)
;
for
(
double
value
:
values
)
{
exprs
.
push_back
(
Literal
:
:
Make
(
right
.
fPosition
value
&
right
.
type
(
)
.
componentType
(
)
)
)
;
}
return
ConstructorCompound
:
:
Make
(
context
right
.
fPosition
right
.
type
(
)
std
:
:
move
(
exprs
)
)
;
}
static
bool
error_on_divide_by_zero
(
const
Context
&
context
Position
pos
Operator
op
const
Expression
&
right
)
{
switch
(
op
.
kind
(
)
)
{
case
Operator
:
:
Kind
:
:
SLASH
:
case
Operator
:
:
Kind
:
:
SLASHEQ
:
case
Operator
:
:
Kind
:
:
PERCENT
:
case
Operator
:
:
Kind
:
:
PERCENTEQ
:
if
(
contains_constant_zero
(
right
)
)
{
context
.
fErrors
-
>
error
(
pos
"
division
by
zero
"
)
;
return
true
;
}
return
false
;
default
:
return
false
;
}
}
const
Expression
*
ConstantFolder
:
:
GetConstantValueOrNullForVariable
(
const
Expression
&
inExpr
)
{
for
(
const
Expression
*
expr
=
&
inExpr
;
;
)
{
if
(
!
expr
-
>
is
<
VariableReference
>
(
)
)
{
break
;
}
const
VariableReference
&
varRef
=
expr
-
>
as
<
VariableReference
>
(
)
;
if
(
varRef
.
refKind
(
)
!
=
VariableRefKind
:
:
kRead
)
{
break
;
}
const
Variable
&
var
=
*
varRef
.
variable
(
)
;
if
(
!
(
var
.
modifiers
(
)
.
fFlags
&
Modifiers
:
:
kConst_Flag
)
)
{
break
;
}
expr
=
var
.
initialValue
(
)
;
if
(
!
expr
)
{
break
;
}
if
(
Analysis
:
:
IsCompileTimeConstant
(
*
expr
)
)
{
return
expr
;
}
}
return
nullptr
;
}
const
Expression
*
ConstantFolder
:
:
GetConstantValueForVariable
(
const
Expression
&
inExpr
)
{
const
Expression
*
expr
=
GetConstantValueOrNullForVariable
(
inExpr
)
;
return
expr
?
expr
:
&
inExpr
;
}
std
:
:
unique_ptr
<
Expression
>
ConstantFolder
:
:
MakeConstantValueForVariable
(
Position
pos
std
:
:
unique_ptr
<
Expression
>
inExpr
)
{
const
Expression
*
expr
=
GetConstantValueOrNullForVariable
(
*
inExpr
)
;
return
expr
?
expr
-
>
clone
(
pos
)
:
std
:
:
move
(
inExpr
)
;
}
static
bool
is_scalar_op_matrix
(
const
Expression
&
left
const
Expression
&
right
)
{
return
left
.
type
(
)
.
isScalar
(
)
&
&
right
.
type
(
)
.
isMatrix
(
)
;
}
static
bool
is_matrix_op_scalar
(
const
Expression
&
left
const
Expression
&
right
)
{
return
is_scalar_op_matrix
(
right
left
)
;
}
static
std
:
:
unique_ptr
<
Expression
>
simplify_arithmetic
(
const
Context
&
context
Position
pos
const
Expression
&
left
Operator
op
const
Expression
&
right
const
Type
&
resultType
)
{
switch
(
op
.
kind
(
)
)
{
case
Operator
:
:
Kind
:
:
PLUS
:
if
(
!
is_scalar_op_matrix
(
left
right
)
&
&
is_constant_splat
(
right
0
.
0
)
)
{
if
(
std
:
:
unique_ptr
<
Expression
>
expr
=
cast_expression
(
context
pos
left
resultType
)
)
{
return
expr
;
}
}
if
(
!
is_matrix_op_scalar
(
left
right
)
&
&
is_constant_splat
(
left
0
.
0
)
)
{
if
(
std
:
:
unique_ptr
<
Expression
>
expr
=
cast_expression
(
context
pos
right
resultType
)
)
{
return
expr
;
}
}
break
;
case
Operator
:
:
Kind
:
:
STAR
:
if
(
is_constant_value
(
right
1
.
0
)
)
{
if
(
std
:
:
unique_ptr
<
Expression
>
expr
=
cast_expression
(
context
pos
left
resultType
)
)
{
return
expr
;
}
}
if
(
is_constant_value
(
left
1
.
0
)
)
{
if
(
std
:
:
unique_ptr
<
Expression
>
expr
=
cast_expression
(
context
pos
right
resultType
)
)
{
return
expr
;
}
}
if
(
is_constant_value
(
right
0
.
0
)
&
&
!
Analysis
:
:
HasSideEffects
(
left
)
)
{
return
zero_expression
(
context
pos
resultType
)
;
}
if
(
is_constant_value
(
left
0
.
0
)
&
&
!
Analysis
:
:
HasSideEffects
(
right
)
)
{
return
zero_expression
(
context
pos
resultType
)
;
}
if
(
is_constant_value
(
right
-
1
.
0
)
)
{
if
(
std
:
:
unique_ptr
<
Expression
>
expr
=
negate_expression
(
context
pos
left
resultType
)
)
{
return
expr
;
}
}
if
(
is_constant_value
(
left
-
1
.
0
)
)
{
if
(
std
:
:
unique_ptr
<
Expression
>
expr
=
negate_expression
(
context
pos
right
resultType
)
)
{
return
expr
;
}
}
break
;
case
Operator
:
:
Kind
:
:
MINUS
:
if
(
!
is_scalar_op_matrix
(
left
right
)
&
&
is_constant_splat
(
right
0
.
0
)
)
{
if
(
std
:
:
unique_ptr
<
Expression
>
expr
=
cast_expression
(
context
pos
left
resultType
)
)
{
return
expr
;
}
}
if
(
!
is_matrix_op_scalar
(
left
right
)
&
&
is_constant_splat
(
left
0
.
0
)
)
{
if
(
std
:
:
unique_ptr
<
Expression
>
expr
=
negate_expression
(
context
pos
right
resultType
)
)
{
return
expr
;
}
}
break
;
case
Operator
:
:
Kind
:
:
SLASH
:
if
(
!
is_scalar_op_matrix
(
left
right
)
&
&
is_constant_splat
(
right
1
.
0
)
)
{
if
(
std
:
:
unique_ptr
<
Expression
>
expr
=
cast_expression
(
context
pos
left
resultType
)
)
{
return
expr
;
}
}
if
(
!
left
.
type
(
)
.
isMatrix
(
)
)
{
if
(
std
:
:
unique_ptr
<
Expression
>
expr
=
make_reciprocal_expression
(
context
right
)
)
{
return
BinaryExpression
:
:
Make
(
context
pos
left
.
clone
(
)
Operator
:
:
Kind
:
:
STAR
std
:
:
move
(
expr
)
)
;
}
}
break
;
case
Operator
:
:
Kind
:
:
PLUSEQ
:
case
Operator
:
:
Kind
:
:
MINUSEQ
:
if
(
is_constant_splat
(
right
0
.
0
)
)
{
if
(
std
:
:
unique_ptr
<
Expression
>
var
=
cast_expression
(
context
pos
left
resultType
)
)
{
Analysis
:
:
UpdateVariableRefKind
(
var
.
get
(
)
VariableRefKind
:
:
kRead
)
;
return
var
;
}
}
break
;
case
Operator
:
:
Kind
:
:
STAREQ
:
if
(
is_constant_value
(
right
1
.
0
)
)
{
if
(
std
:
:
unique_ptr
<
Expression
>
var
=
cast_expression
(
context
pos
left
resultType
)
)
{
Analysis
:
:
UpdateVariableRefKind
(
var
.
get
(
)
VariableRefKind
:
:
kRead
)
;
return
var
;
}
}
break
;
case
Operator
:
:
Kind
:
:
SLASHEQ
:
if
(
is_constant_splat
(
right
1
.
0
)
)
{
if
(
std
:
:
unique_ptr
<
Expression
>
var
=
cast_expression
(
context
pos
left
resultType
)
)
{
Analysis
:
:
UpdateVariableRefKind
(
var
.
get
(
)
VariableRefKind
:
:
kRead
)
;
return
var
;
}
}
if
(
std
:
:
unique_ptr
<
Expression
>
expr
=
make_reciprocal_expression
(
context
right
)
)
{
return
BinaryExpression
:
:
Make
(
context
pos
left
.
clone
(
)
Operator
:
:
Kind
:
:
STAREQ
std
:
:
move
(
expr
)
)
;
}
break
;
default
:
break
;
}
return
nullptr
;
}
static
std
:
:
unique_ptr
<
Expression
>
one_over_scalar
(
const
Context
&
context
const
Expression
&
right
)
{
SkASSERT
(
right
.
type
(
)
.
isScalar
(
)
)
;
Position
pos
=
right
.
fPosition
;
return
BinaryExpression
:
:
Make
(
context
pos
Literal
:
:
Make
(
pos
1
.
0
&
right
.
type
(
)
)
Operator
:
:
Kind
:
:
SLASH
right
.
clone
(
)
)
;
}
static
std
:
:
unique_ptr
<
Expression
>
simplify_matrix_division
(
const
Context
&
context
Position
pos
const
Expression
&
left
Operator
op
const
Expression
&
right
const
Type
&
resultType
)
{
switch
(
op
.
kind
(
)
)
{
case
OperatorKind
:
:
SLASH
:
case
OperatorKind
:
:
SLASHEQ
:
if
(
left
.
type
(
)
.
isMatrix
(
)
&
&
right
.
type
(
)
.
isScalar
(
)
)
{
Operator
multiplyOp
=
op
.
isAssignment
(
)
?
OperatorKind
:
:
STAREQ
:
OperatorKind
:
:
STAR
;
return
BinaryExpression
:
:
Make
(
context
pos
left
.
clone
(
)
multiplyOp
one_over_scalar
(
context
right
)
)
;
}
break
;
default
:
break
;
}
return
nullptr
;
}
static
std
:
:
unique_ptr
<
Expression
>
fold_expression
(
Position
pos
double
result
const
Type
*
resultType
)
{
if
(
resultType
-
>
isNumber
(
)
)
{
if
(
result
>
=
resultType
-
>
minimumValue
(
)
&
&
result
<
=
resultType
-
>
maximumValue
(
)
)
{
}
else
{
return
nullptr
;
}
}
return
Literal
:
:
Make
(
pos
result
resultType
)
;
}
std
:
:
unique_ptr
<
Expression
>
ConstantFolder
:
:
Simplify
(
const
Context
&
context
Position
pos
const
Expression
&
leftExpr
Operator
op
const
Expression
&
rightExpr
const
Type
&
resultType
)
{
const
Expression
*
left
=
GetConstantValueForVariable
(
leftExpr
)
;
const
Expression
*
right
=
GetConstantValueForVariable
(
rightExpr
)
;
if
(
op
.
kind
(
)
=
=
Operator
:
:
Kind
:
:
EQ
&
&
Analysis
:
:
IsSameExpressionTree
(
*
left
*
right
)
)
{
return
right
-
>
clone
(
pos
)
;
}
if
(
left
-
>
isBoolLiteral
(
)
&
&
right
-
>
isBoolLiteral
(
)
)
{
bool
leftVal
=
left
-
>
as
<
Literal
>
(
)
.
boolValue
(
)
;
bool
rightVal
=
right
-
>
as
<
Literal
>
(
)
.
boolValue
(
)
;
bool
result
;
switch
(
op
.
kind
(
)
)
{
case
Operator
:
:
Kind
:
:
LOGICALAND
:
result
=
leftVal
&
&
rightVal
;
break
;
case
Operator
:
:
Kind
:
:
LOGICALOR
:
result
=
leftVal
|
|
rightVal
;
break
;
case
Operator
:
:
Kind
:
:
LOGICALXOR
:
result
=
leftVal
^
rightVal
;
break
;
case
Operator
:
:
Kind
:
:
EQEQ
:
result
=
leftVal
=
=
rightVal
;
break
;
case
Operator
:
:
Kind
:
:
NEQ
:
result
=
leftVal
!
=
rightVal
;
break
;
default
:
return
nullptr
;
}
return
Literal
:
:
MakeBool
(
context
pos
result
)
;
}
if
(
left
-
>
isBoolLiteral
(
)
)
{
return
short_circuit_boolean
(
pos
*
left
op
*
right
)
;
}
if
(
right
-
>
isBoolLiteral
(
)
)
{
if
(
!
Analysis
:
:
HasSideEffects
(
*
left
)
)
{
return
short_circuit_boolean
(
pos
*
right
op
*
left
)
;
}
return
eliminate_no_op_boolean
(
pos
*
left
op
*
right
)
;
}
if
(
op
.
kind
(
)
=
=
Operator
:
:
Kind
:
:
EQEQ
&
&
Analysis
:
:
IsSameExpressionTree
(
*
left
*
right
)
)
{
return
Literal
:
:
MakeBool
(
context
pos
true
)
;
}
if
(
op
.
kind
(
)
=
=
Operator
:
:
Kind
:
:
NEQ
&
&
Analysis
:
:
IsSameExpressionTree
(
*
left
*
right
)
)
{
return
Literal
:
:
MakeBool
(
context
pos
false
)
;
}
if
(
error_on_divide_by_zero
(
context
pos
op
*
right
)
)
{
return
nullptr
;
}
const
Type
&
leftType
=
left
-
>
type
(
)
;
const
Type
&
rightType
=
right
-
>
type
(
)
;
bool
leftSideIsConstant
=
Analysis
:
:
IsCompileTimeConstant
(
*
left
)
;
bool
rightSideIsConstant
=
Analysis
:
:
IsCompileTimeConstant
(
*
right
)
;
if
(
leftSideIsConstant
&
&
rightSideIsConstant
)
{
if
(
left
-
>
isIntLiteral
(
)
&
&
right
-
>
isIntLiteral
(
)
)
{
using
SKSL_UINT
=
uint64_t
;
SKSL_INT
leftVal
=
left
-
>
as
<
Literal
>
(
)
.
intValue
(
)
;
SKSL_INT
rightVal
=
right
-
>
as
<
Literal
>
(
)
.
intValue
(
)
;
#
define
RESULT
(
Op
)
fold_expression
(
pos
(
SKSL_INT
)
(
leftVal
)
Op
\
(
SKSL_INT
)
(
rightVal
)
&
resultType
)
#
define
URESULT
(
Op
)
fold_expression
(
pos
(
SKSL_INT
)
(
(
SKSL_UINT
)
(
leftVal
)
Op
\
(
SKSL_UINT
)
(
rightVal
)
)
&
resultType
)
switch
(
op
.
kind
(
)
)
{
case
Operator
:
:
Kind
:
:
PLUS
:
return
URESULT
(
+
)
;
case
Operator
:
:
Kind
:
:
MINUS
:
return
URESULT
(
-
)
;
case
Operator
:
:
Kind
:
:
STAR
:
return
URESULT
(
*
)
;
case
Operator
:
:
Kind
:
:
SLASH
:
if
(
leftVal
=
=
std
:
:
numeric_limits
<
SKSL_INT
>
:
:
min
(
)
&
&
rightVal
=
=
-
1
)
{
context
.
fErrors
-
>
error
(
pos
"
arithmetic
overflow
"
)
;
return
nullptr
;
}
return
RESULT
(
/
)
;
case
Operator
:
:
Kind
:
:
PERCENT
:
if
(
leftVal
=
=
std
:
:
numeric_limits
<
SKSL_INT
>
:
:
min
(
)
&
&
rightVal
=
=
-
1
)
{
context
.
fErrors
-
>
error
(
pos
"
arithmetic
overflow
"
)
;
return
nullptr
;
}
return
RESULT
(
%
)
;
case
Operator
:
:
Kind
:
:
BITWISEAND
:
return
RESULT
(
&
)
;
case
Operator
:
:
Kind
:
:
BITWISEOR
:
return
RESULT
(
|
)
;
case
Operator
:
:
Kind
:
:
BITWISEXOR
:
return
RESULT
(
^
)
;
case
Operator
:
:
Kind
:
:
EQEQ
:
return
RESULT
(
=
=
)
;
case
Operator
:
:
Kind
:
:
NEQ
:
return
RESULT
(
!
=
)
;
case
Operator
:
:
Kind
:
:
GT
:
return
RESULT
(
>
)
;
case
Operator
:
:
Kind
:
:
GTEQ
:
return
RESULT
(
>
=
)
;
case
Operator
:
:
Kind
:
:
LT
:
return
RESULT
(
<
)
;
case
Operator
:
:
Kind
:
:
LTEQ
:
return
RESULT
(
<
=
)
;
case
Operator
:
:
Kind
:
:
SHL
:
if
(
rightVal
>
=
0
&
&
rightVal
<
=
31
)
{
return
URESULT
(
<
<
)
;
}
context
.
fErrors
-
>
error
(
pos
"
shift
value
out
of
range
"
)
;
return
nullptr
;
case
Operator
:
:
Kind
:
:
SHR
:
if
(
rightVal
>
=
0
&
&
rightVal
<
=
31
)
{
return
RESULT
(
>
>
)
;
}
context
.
fErrors
-
>
error
(
pos
"
shift
value
out
of
range
"
)
;
return
nullptr
;
default
:
return
nullptr
;
}
#
undef
RESULT
#
undef
URESULT
}
if
(
left
-
>
isFloatLiteral
(
)
&
&
right
-
>
isFloatLiteral
(
)
)
{
SKSL_FLOAT
leftVal
=
left
-
>
as
<
Literal
>
(
)
.
floatValue
(
)
;
SKSL_FLOAT
rightVal
=
right
-
>
as
<
Literal
>
(
)
.
floatValue
(
)
;
#
define
RESULT
(
Op
)
fold_expression
(
pos
leftVal
Op
rightVal
&
resultType
)
switch
(
op
.
kind
(
)
)
{
case
Operator
:
:
Kind
:
:
PLUS
:
return
RESULT
(
+
)
;
case
Operator
:
:
Kind
:
:
MINUS
:
return
RESULT
(
-
)
;
case
Operator
:
:
Kind
:
:
STAR
:
return
RESULT
(
*
)
;
case
Operator
:
:
Kind
:
:
SLASH
:
return
RESULT
(
/
)
;
case
Operator
:
:
Kind
:
:
EQEQ
:
return
RESULT
(
=
=
)
;
case
Operator
:
:
Kind
:
:
NEQ
:
return
RESULT
(
!
=
)
;
case
Operator
:
:
Kind
:
:
GT
:
return
RESULT
(
>
)
;
case
Operator
:
:
Kind
:
:
GTEQ
:
return
RESULT
(
>
=
)
;
case
Operator
:
:
Kind
:
:
LT
:
return
RESULT
(
<
)
;
case
Operator
:
:
Kind
:
:
LTEQ
:
return
RESULT
(
<
=
)
;
default
:
return
nullptr
;
}
#
undef
RESULT
}
if
(
op
.
kind
(
)
=
=
Operator
:
:
Kind
:
:
STAR
)
{
if
(
leftType
.
isMatrix
(
)
&
&
rightType
.
isMatrix
(
)
)
{
return
simplify_matrix_times_matrix
(
context
pos
*
left
*
right
)
;
}
if
(
leftType
.
isVector
(
)
&
&
rightType
.
isMatrix
(
)
)
{
return
simplify_vector_times_matrix
(
context
pos
*
left
*
right
)
;
}
if
(
leftType
.
isMatrix
(
)
&
&
rightType
.
isVector
(
)
)
{
return
simplify_matrix_times_vector
(
context
pos
*
left
*
right
)
;
}
}
if
(
is_vec_or_mat
(
leftType
)
&
&
leftType
.
matches
(
rightType
)
)
{
return
simplify_componentwise
(
context
pos
*
left
op
*
right
)
;
}
if
(
rightType
.
isScalar
(
)
&
&
is_vec_or_mat
(
leftType
)
&
&
leftType
.
componentType
(
)
.
matches
(
rightType
)
)
{
return
simplify_componentwise
(
context
pos
*
left
op
*
splat_scalar
(
context
*
right
left
-
>
type
(
)
)
)
;
}
if
(
leftType
.
isScalar
(
)
&
&
is_vec_or_mat
(
rightType
)
&
&
rightType
.
componentType
(
)
.
matches
(
leftType
)
)
{
return
simplify_componentwise
(
context
pos
*
splat_scalar
(
context
*
left
right
-
>
type
(
)
)
op
*
right
)
;
}
if
(
(
leftType
.
isMatrix
(
)
&
&
rightType
.
isMatrix
(
)
)
|
|
(
leftType
.
isArray
(
)
&
&
rightType
.
isArray
(
)
)
|
|
(
leftType
.
isStruct
(
)
&
&
rightType
.
isStruct
(
)
)
)
{
return
simplify_constant_equality
(
context
pos
*
left
op
*
right
)
;
}
}
if
(
context
.
fConfig
-
>
fSettings
.
fOptimize
)
{
if
(
leftSideIsConstant
|
|
rightSideIsConstant
)
{
if
(
std
:
:
unique_ptr
<
Expression
>
expr
=
simplify_arithmetic
(
context
pos
*
left
op
*
right
resultType
)
)
{
return
expr
;
}
}
if
(
std
:
:
unique_ptr
<
Expression
>
expr
=
simplify_matrix_division
(
context
pos
*
left
op
*
right
resultType
)
)
{
return
expr
;
}
}
return
nullptr
;
}
}
