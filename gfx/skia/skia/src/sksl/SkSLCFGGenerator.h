#
ifndef
SKSL_CFGGENERATOR
#
define
SKSL_CFGGENERATOR
#
include
"
src
/
sksl
/
ir
/
SkSLExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFunctionDefinition
.
h
"
#
include
<
set
>
#
include
<
stack
>
namespace
SkSL
{
typedef
size_t
BlockId
;
struct
BasicBlock
{
struct
Node
{
enum
Kind
{
kStatement_Kind
kExpression_Kind
}
;
Node
(
Kind
kind
bool
constantPropagation
std
:
:
unique_ptr
<
Expression
>
*
expression
std
:
:
unique_ptr
<
Statement
>
*
statement
)
:
fKind
(
kind
)
fConstantPropagation
(
constantPropagation
)
fExpression
(
expression
)
fStatement
(
statement
)
{
}
std
:
:
unique_ptr
<
Expression
>
*
expression
(
)
const
{
SkASSERT
(
fKind
=
=
kExpression_Kind
)
;
return
fExpression
;
}
void
setExpression
(
std
:
:
unique_ptr
<
Expression
>
expr
)
{
SkASSERT
(
fKind
=
=
kExpression_Kind
)
;
*
fExpression
=
std
:
:
move
(
expr
)
;
}
std
:
:
unique_ptr
<
Statement
>
*
statement
(
)
const
{
SkASSERT
(
fKind
=
=
kStatement_Kind
)
;
return
fStatement
;
}
void
setStatement
(
std
:
:
unique_ptr
<
Statement
>
stmt
)
{
SkASSERT
(
fKind
=
=
kStatement_Kind
)
;
*
fStatement
=
std
:
:
move
(
stmt
)
;
}
String
description
(
)
const
{
if
(
fKind
=
=
kStatement_Kind
)
{
return
(
*
fStatement
)
-
>
description
(
)
;
}
else
{
SkASSERT
(
fKind
=
=
kExpression_Kind
)
;
return
(
*
fExpression
)
-
>
description
(
)
;
}
}
Kind
fKind
;
bool
fConstantPropagation
;
private
:
std
:
:
unique_ptr
<
Expression
>
*
fExpression
;
std
:
:
unique_ptr
<
Statement
>
*
fStatement
;
}
;
bool
tryRemoveExpression
(
std
:
:
vector
<
BasicBlock
:
:
Node
>
:
:
iterator
*
iter
)
;
bool
tryRemoveExpressionBefore
(
std
:
:
vector
<
BasicBlock
:
:
Node
>
:
:
iterator
*
iter
Expression
*
e
)
;
bool
tryRemoveLValueBefore
(
std
:
:
vector
<
BasicBlock
:
:
Node
>
:
:
iterator
*
iter
Expression
*
lvalue
)
;
bool
tryInsertExpression
(
std
:
:
vector
<
BasicBlock
:
:
Node
>
:
:
iterator
*
iter
std
:
:
unique_ptr
<
Expression
>
*
expr
)
;
std
:
:
vector
<
Node
>
fNodes
;
std
:
:
set
<
BlockId
>
fEntrances
;
std
:
:
set
<
BlockId
>
fExits
;
DefinitionMap
fBefore
;
}
;
struct
CFG
{
BlockId
fStart
;
BlockId
fExit
;
std
:
:
vector
<
BasicBlock
>
fBlocks
;
void
dump
(
)
;
private
:
BlockId
fCurrent
;
BlockId
newBlock
(
)
;
BlockId
newIsolatedBlock
(
)
;
void
addExit
(
BlockId
from
BlockId
to
)
;
friend
class
CFGGenerator
;
}
;
class
CFGGenerator
{
public
:
CFGGenerator
(
)
{
}
CFG
getCFG
(
FunctionDefinition
&
f
)
;
private
:
void
addStatement
(
CFG
&
cfg
std
:
:
unique_ptr
<
Statement
>
*
s
)
;
void
addExpression
(
CFG
&
cfg
std
:
:
unique_ptr
<
Expression
>
*
e
bool
constantPropagate
)
;
void
addLValue
(
CFG
&
cfg
std
:
:
unique_ptr
<
Expression
>
*
e
)
;
std
:
:
stack
<
BlockId
>
fLoopContinues
;
std
:
:
stack
<
BlockId
>
fLoopExits
;
}
;
}
#
endif
