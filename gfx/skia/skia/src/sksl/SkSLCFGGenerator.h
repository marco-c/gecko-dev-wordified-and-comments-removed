#
ifndef
SKSL_CFGGENERATOR
#
define
SKSL_CFGGENERATOR
#
include
"
ir
/
SkSLExpression
.
h
"
#
include
"
ir
/
SkSLFunctionDefinition
.
h
"
#
include
<
set
>
#
include
<
stack
>
namespace
SkSL
{
typedef
size_t
BlockId
;
struct
BasicBlock
{
struct
Node
{
enum
Kind
{
kStatement_Kind
kExpression_Kind
}
;
Kind
fKind
;
bool
fConstantPropagation
;
std
:
:
unique_ptr
<
Expression
>
*
fExpression
;
const
Statement
*
fStatement
;
}
;
std
:
:
vector
<
Node
>
fNodes
;
std
:
:
set
<
BlockId
>
fEntrances
;
std
:
:
set
<
BlockId
>
fExits
;
DefinitionMap
fBefore
;
}
;
struct
CFG
{
BlockId
fStart
;
BlockId
fExit
;
std
:
:
vector
<
BasicBlock
>
fBlocks
;
void
dump
(
)
;
private
:
BlockId
fCurrent
;
BlockId
newBlock
(
)
;
BlockId
newIsolatedBlock
(
)
;
void
addExit
(
BlockId
from
BlockId
to
)
;
friend
class
CFGGenerator
;
}
;
class
CFGGenerator
{
public
:
CFGGenerator
(
)
{
}
CFG
getCFG
(
const
FunctionDefinition
&
f
)
;
private
:
void
addStatement
(
CFG
&
cfg
const
Statement
*
s
)
;
void
addExpression
(
CFG
&
cfg
std
:
:
unique_ptr
<
Expression
>
*
e
bool
constantPropagate
)
;
void
addLValue
(
CFG
&
cfg
std
:
:
unique_ptr
<
Expression
>
*
e
)
;
std
:
:
stack
<
BlockId
>
fLoopContinues
;
std
:
:
stack
<
BlockId
>
fLoopExits
;
}
;
}
#
endif
