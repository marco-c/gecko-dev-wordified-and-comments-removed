#
ifndef
SKSL_SWIZZLE
#
define
SKSL_SWIZZLE
#
include
"
SkSLExpression
.
h
"
#
include
"
SkSLUtil
.
h
"
namespace
SkSL
{
static
const
Type
&
get_type
(
const
Context
&
context
Expression
&
value
size_t
count
)
{
const
Type
&
base
=
value
.
fType
.
componentType
(
)
;
if
(
count
=
=
1
)
{
return
base
;
}
if
(
base
=
=
*
context
.
fFloat_Type
)
{
switch
(
count
)
{
case
2
:
return
*
context
.
fVec2_Type
;
case
3
:
return
*
context
.
fVec3_Type
;
case
4
:
return
*
context
.
fVec4_Type
;
}
}
else
if
(
base
=
=
*
context
.
fDouble_Type
)
{
switch
(
count
)
{
case
2
:
return
*
context
.
fDVec2_Type
;
case
3
:
return
*
context
.
fDVec3_Type
;
case
4
:
return
*
context
.
fDVec4_Type
;
}
}
else
if
(
base
=
=
*
context
.
fInt_Type
)
{
switch
(
count
)
{
case
2
:
return
*
context
.
fIVec2_Type
;
case
3
:
return
*
context
.
fIVec3_Type
;
case
4
:
return
*
context
.
fIVec4_Type
;
}
}
else
if
(
base
=
=
*
context
.
fUInt_Type
)
{
switch
(
count
)
{
case
2
:
return
*
context
.
fUVec2_Type
;
case
3
:
return
*
context
.
fUVec3_Type
;
case
4
:
return
*
context
.
fUVec4_Type
;
}
}
else
if
(
base
=
=
*
context
.
fBool_Type
)
{
switch
(
count
)
{
case
2
:
return
*
context
.
fBVec2_Type
;
case
3
:
return
*
context
.
fBVec3_Type
;
case
4
:
return
*
context
.
fBVec4_Type
;
}
}
ABORT
(
"
cannot
swizzle
%
s
\
n
"
value
.
description
(
)
.
c_str
(
)
)
;
}
struct
Swizzle
:
public
Expression
{
Swizzle
(
const
Context
&
context
std
:
:
unique_ptr
<
Expression
>
base
std
:
:
vector
<
int
>
components
)
:
INHERITED
(
base
-
>
fPosition
kSwizzle_Kind
get_type
(
context
*
base
components
.
size
(
)
)
)
fBase
(
std
:
:
move
(
base
)
)
fComponents
(
std
:
:
move
(
components
)
)
{
ASSERT
(
fComponents
.
size
(
)
>
=
1
&
&
fComponents
.
size
(
)
<
=
4
)
;
}
std
:
:
string
description
(
)
const
override
{
std
:
:
string
result
=
fBase
-
>
description
(
)
+
"
.
"
;
for
(
int
x
:
fComponents
)
{
result
+
=
"
xyzw
"
[
x
]
;
}
return
result
;
}
const
std
:
:
unique_ptr
<
Expression
>
fBase
;
const
std
:
:
vector
<
int
>
fComponents
;
typedef
Expression
INHERITED
;
}
;
}
#
endif
