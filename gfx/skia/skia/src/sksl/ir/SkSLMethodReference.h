#
ifndef
SKSL_METHODREFERENCE
#
define
SKSL_METHODREFERENCE
#
include
"
src
/
sksl
/
SkSLContext
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLExpression
.
h
"
namespace
SkSL
{
class
FunctionDeclaration
;
class
MethodReference
final
:
public
Expression
{
public
:
inline
static
constexpr
Kind
kIRNodeKind
=
Kind
:
:
kMethodReference
;
MethodReference
(
const
Context
&
context
Position
pos
std
:
:
unique_ptr
<
Expression
>
self
const
FunctionDeclaration
*
overloadChain
)
:
INHERITED
(
pos
kIRNodeKind
context
.
fTypes
.
fInvalid
.
get
(
)
)
fSelf
(
std
:
:
move
(
self
)
)
fOverloadChain
(
overloadChain
)
{
}
std
:
:
unique_ptr
<
Expression
>
&
self
(
)
{
return
fSelf
;
}
const
std
:
:
unique_ptr
<
Expression
>
&
self
(
)
const
{
return
fSelf
;
}
const
FunctionDeclaration
*
overloadChain
(
)
const
{
return
fOverloadChain
;
}
std
:
:
unique_ptr
<
Expression
>
clone
(
Position
pos
)
const
override
{
return
std
:
:
unique_ptr
<
Expression
>
(
new
MethodReference
(
pos
this
-
>
self
(
)
-
>
clone
(
)
this
-
>
overloadChain
(
)
&
this
-
>
type
(
)
)
)
;
}
std
:
:
string
description
(
OperatorPrecedence
)
const
override
{
return
"
<
method
>
"
;
}
private
:
MethodReference
(
Position
pos
std
:
:
unique_ptr
<
Expression
>
self
const
FunctionDeclaration
*
overloadChain
const
Type
*
type
)
:
INHERITED
(
pos
kIRNodeKind
type
)
fSelf
(
std
:
:
move
(
self
)
)
fOverloadChain
(
overloadChain
)
{
}
std
:
:
unique_ptr
<
Expression
>
fSelf
;
const
FunctionDeclaration
*
fOverloadChain
;
using
INHERITED
=
Expression
;
}
;
}
#
endif
