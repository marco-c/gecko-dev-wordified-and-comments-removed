#
include
"
src
/
sksl
/
ir
/
SkSLConstructor
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
SkSLString
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
include
/
sksl
/
SkSLErrorReporter
.
h
"
#
include
"
include
/
sksl
/
SkSLOperator
.
h
"
#
include
"
src
/
sksl
/
SkSLContext
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorArray
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorCompound
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorCompoundCast
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorDiagonalMatrix
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorMatrixResize
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorScalarCast
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorSplat
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorStruct
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLType
.
h
"
#
include
<
vector
>
namespace
SkSL
{
static
std
:
:
unique_ptr
<
Expression
>
convert_compound_constructor
(
const
Context
&
context
Position
pos
const
Type
&
type
ExpressionArray
args
)
{
SkASSERT
(
type
.
isVector
(
)
|
|
type
.
isMatrix
(
)
)
;
if
(
args
.
size
(
)
=
=
1
)
{
std
:
:
unique_ptr
<
Expression
>
&
argument
=
args
.
front
(
)
;
if
(
type
.
isVector
(
)
&
&
argument
-
>
type
(
)
.
isVector
(
)
&
&
argument
-
>
type
(
)
.
componentType
(
)
.
matches
(
type
.
componentType
(
)
)
&
&
argument
-
>
type
(
)
.
slotCount
(
)
>
type
.
slotCount
(
)
)
{
const
char
*
swizzleHint
;
switch
(
type
.
slotCount
(
)
)
{
case
2
:
swizzleHint
=
"
;
use
'
.
xy
'
instead
"
;
break
;
case
3
:
swizzleHint
=
"
;
use
'
.
xyz
'
instead
"
;
break
;
default
:
swizzleHint
=
"
"
;
SkDEBUGFAIL
(
"
unexpected
slicing
cast
"
)
;
break
;
}
context
.
fErrors
-
>
error
(
pos
"
'
"
+
argument
-
>
type
(
)
.
displayName
(
)
+
"
'
is
not
a
valid
parameter
to
'
"
+
type
.
displayName
(
)
+
"
'
constructor
"
+
swizzleHint
)
;
return
nullptr
;
}
if
(
argument
-
>
type
(
)
.
isScalar
(
)
)
{
std
:
:
unique_ptr
<
Expression
>
typecast
=
ConstructorScalarCast
:
:
Convert
(
context
pos
type
.
componentType
(
)
std
:
:
move
(
args
)
)
;
if
(
!
typecast
)
{
return
nullptr
;
}
return
type
.
isMatrix
(
)
?
ConstructorDiagonalMatrix
:
:
Make
(
context
pos
type
std
:
:
move
(
typecast
)
)
:
ConstructorSplat
:
:
Make
(
context
pos
type
std
:
:
move
(
typecast
)
)
;
}
else
if
(
argument
-
>
type
(
)
.
isVector
(
)
)
{
if
(
type
.
isVector
(
)
&
&
argument
-
>
type
(
)
.
columns
(
)
=
=
type
.
columns
(
)
)
{
return
ConstructorCompoundCast
:
:
Make
(
context
pos
type
std
:
:
move
(
argument
)
)
;
}
}
else
if
(
argument
-
>
type
(
)
.
isMatrix
(
)
)
{
if
(
type
.
isMatrix
(
)
)
{
const
Type
&
typecastType
=
type
.
componentType
(
)
.
toCompound
(
context
argument
-
>
type
(
)
.
columns
(
)
argument
-
>
type
(
)
.
rows
(
)
)
;
argument
=
ConstructorCompoundCast
:
:
Make
(
context
pos
typecastType
std
:
:
move
(
argument
)
)
;
return
ConstructorMatrixResize
:
:
Make
(
context
pos
type
std
:
:
move
(
argument
)
)
;
}
if
(
type
.
isVector
(
)
&
&
type
.
columns
(
)
=
=
4
&
&
argument
-
>
type
(
)
.
slotCount
(
)
=
=
4
)
{
const
Type
&
vectorType
=
argument
-
>
type
(
)
.
componentType
(
)
.
toCompound
(
context
4
1
)
;
std
:
:
unique_ptr
<
Expression
>
vecCtor
=
ConstructorCompound
:
:
Make
(
context
pos
vectorType
std
:
:
move
(
args
)
)
;
return
ConstructorCompoundCast
:
:
Make
(
context
pos
type
std
:
:
move
(
vecCtor
)
)
;
}
}
}
int
expected
=
type
.
rows
(
)
*
type
.
columns
(
)
;
int
actual
=
0
;
for
(
std
:
:
unique_ptr
<
Expression
>
&
arg
:
args
)
{
if
(
!
arg
-
>
type
(
)
.
isScalar
(
)
&
&
!
arg
-
>
type
(
)
.
isVector
(
)
)
{
context
.
fErrors
-
>
error
(
pos
"
'
"
+
arg
-
>
type
(
)
.
displayName
(
)
+
"
'
is
not
a
valid
parameter
to
'
"
+
type
.
displayName
(
)
+
"
'
constructor
"
)
;
return
nullptr
;
}
const
Type
&
ctorType
=
type
.
componentType
(
)
.
toCompound
(
context
arg
-
>
type
(
)
.
columns
(
)
1
)
;
ExpressionArray
ctorArg
;
ctorArg
.
push_back
(
std
:
:
move
(
arg
)
)
;
arg
=
Constructor
:
:
Convert
(
context
pos
ctorType
std
:
:
move
(
ctorArg
)
)
;
if
(
!
arg
)
{
return
nullptr
;
}
actual
+
=
ctorType
.
columns
(
)
;
}
if
(
actual
!
=
expected
)
{
context
.
fErrors
-
>
error
(
pos
"
invalid
arguments
to
'
"
+
type
.
displayName
(
)
+
"
'
constructor
(
expected
"
+
std
:
:
to_string
(
expected
)
+
"
scalars
but
found
"
+
std
:
:
to_string
(
actual
)
+
"
)
"
)
;
return
nullptr
;
}
return
ConstructorCompound
:
:
Make
(
context
pos
type
std
:
:
move
(
args
)
)
;
}
std
:
:
unique_ptr
<
Expression
>
Constructor
:
:
Convert
(
const
Context
&
context
Position
pos
const
Type
&
type
ExpressionArray
args
)
{
if
(
args
.
size
(
)
=
=
1
&
&
args
[
0
]
-
>
type
(
)
.
matches
(
type
)
&
&
!
type
.
componentType
(
)
.
isOpaque
(
)
)
{
args
[
0
]
-
>
fPosition
=
pos
;
return
std
:
:
move
(
args
[
0
]
)
;
}
if
(
type
.
isScalar
(
)
)
{
return
ConstructorScalarCast
:
:
Convert
(
context
pos
type
std
:
:
move
(
args
)
)
;
}
if
(
type
.
isVector
(
)
|
|
type
.
isMatrix
(
)
)
{
return
convert_compound_constructor
(
context
pos
type
std
:
:
move
(
args
)
)
;
}
if
(
type
.
isArray
(
)
&
&
type
.
columns
(
)
>
0
)
{
return
ConstructorArray
:
:
Convert
(
context
pos
type
std
:
:
move
(
args
)
)
;
}
if
(
type
.
isStruct
(
)
&
&
type
.
fields
(
)
.
size
(
)
>
0
)
{
return
ConstructorStruct
:
:
Convert
(
context
pos
type
std
:
:
move
(
args
)
)
;
}
context
.
fErrors
-
>
error
(
pos
"
cannot
construct
'
"
+
type
.
displayName
(
)
+
"
'
"
)
;
return
nullptr
;
}
std
:
:
optional
<
double
>
AnyConstructor
:
:
getConstantValue
(
int
n
)
const
{
SkASSERT
(
n
>
=
0
&
&
n
<
(
int
)
this
-
>
type
(
)
.
slotCount
(
)
)
;
for
(
const
std
:
:
unique_ptr
<
Expression
>
&
arg
:
this
-
>
argumentSpan
(
)
)
{
int
argSlots
=
arg
-
>
type
(
)
.
slotCount
(
)
;
if
(
n
<
argSlots
)
{
return
arg
-
>
getConstantValue
(
n
)
;
}
n
-
=
argSlots
;
}
SkDEBUGFAIL
(
"
argument
-
list
slot
count
doesn
'
t
match
constructor
-
type
slot
count
"
)
;
return
std
:
:
nullopt
;
}
Expression
:
:
ComparisonResult
AnyConstructor
:
:
compareConstant
(
const
Expression
&
other
)
const
{
SkASSERT
(
this
-
>
type
(
)
.
slotCount
(
)
=
=
other
.
type
(
)
.
slotCount
(
)
)
;
if
(
!
other
.
supportsConstantValues
(
)
)
{
return
ComparisonResult
:
:
kUnknown
;
}
int
exprs
=
this
-
>
type
(
)
.
slotCount
(
)
;
for
(
int
n
=
0
;
n
<
exprs
;
+
+
n
)
{
std
:
:
optional
<
double
>
left
=
this
-
>
getConstantValue
(
n
)
;
if
(
!
left
.
has_value
(
)
)
{
return
ComparisonResult
:
:
kUnknown
;
}
std
:
:
optional
<
double
>
right
=
other
.
getConstantValue
(
n
)
;
if
(
!
right
.
has_value
(
)
)
{
return
ComparisonResult
:
:
kUnknown
;
}
if
(
*
left
!
=
*
right
)
{
return
ComparisonResult
:
:
kNotEqual
;
}
}
return
ComparisonResult
:
:
kEqual
;
}
AnyConstructor
&
Expression
:
:
asAnyConstructor
(
)
{
SkASSERT
(
this
-
>
isAnyConstructor
(
)
)
;
return
static_cast
<
AnyConstructor
&
>
(
*
this
)
;
}
const
AnyConstructor
&
Expression
:
:
asAnyConstructor
(
)
const
{
SkASSERT
(
this
-
>
isAnyConstructor
(
)
)
;
return
static_cast
<
const
AnyConstructor
&
>
(
*
this
)
;
}
std
:
:
string
AnyConstructor
:
:
description
(
OperatorPrecedence
)
const
{
std
:
:
string
result
=
this
-
>
type
(
)
.
description
(
)
+
"
(
"
;
auto
separator
=
SkSL
:
:
String
:
:
Separator
(
)
;
for
(
const
std
:
:
unique_ptr
<
Expression
>
&
arg
:
this
-
>
argumentSpan
(
)
)
{
result
+
=
separator
(
)
;
result
+
=
arg
-
>
description
(
OperatorPrecedence
:
:
kSequence
)
;
}
result
.
push_back
(
'
)
'
)
;
return
result
;
}
}
