#
include
"
src
/
sksl
/
ir
/
SkSLBlock
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLNop
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLSymbolTable
.
h
"
#
include
<
type_traits
>
namespace
SkSL
{
std
:
:
unique_ptr
<
Statement
>
Block
:
:
Make
(
Position
pos
StatementArray
statements
Kind
kind
std
:
:
shared_ptr
<
SymbolTable
>
symbols
)
{
if
(
kind
=
=
Kind
:
:
kBracedScope
|
|
(
symbols
&
&
symbols
-
>
count
(
)
)
)
{
return
std
:
:
make_unique
<
Block
>
(
pos
std
:
:
move
(
statements
)
kind
std
:
:
move
(
symbols
)
)
;
}
if
(
statements
.
empty
(
)
)
{
return
Nop
:
:
Make
(
)
;
}
if
(
statements
.
size
(
)
>
1
)
{
std
:
:
unique_ptr
<
Statement
>
*
foundStatement
=
nullptr
;
for
(
std
:
:
unique_ptr
<
Statement
>
&
stmt
:
statements
)
{
if
(
!
stmt
-
>
isEmpty
(
)
)
{
if
(
!
foundStatement
)
{
foundStatement
=
&
stmt
;
continue
;
}
return
std
:
:
make_unique
<
Block
>
(
pos
std
:
:
move
(
statements
)
kind
nullptr
)
;
}
}
if
(
foundStatement
)
{
return
std
:
:
move
(
*
foundStatement
)
;
}
}
return
std
:
:
move
(
statements
.
front
(
)
)
;
}
std
:
:
unique_ptr
<
Block
>
Block
:
:
MakeBlock
(
Position
pos
StatementArray
statements
Kind
kind
std
:
:
shared_ptr
<
SymbolTable
>
symbols
)
{
return
std
:
:
make_unique
<
Block
>
(
pos
std
:
:
move
(
statements
)
kind
std
:
:
move
(
symbols
)
)
;
}
std
:
:
unique_ptr
<
Statement
>
Block
:
:
clone
(
)
const
{
StatementArray
cloned
;
cloned
.
reserve_back
(
this
-
>
children
(
)
.
size
(
)
)
;
for
(
const
std
:
:
unique_ptr
<
Statement
>
&
stmt
:
this
-
>
children
(
)
)
{
cloned
.
push_back
(
stmt
-
>
clone
(
)
)
;
}
return
std
:
:
make_unique
<
Block
>
(
fPosition
std
:
:
move
(
cloned
)
fBlockKind
SymbolTable
:
:
WrapIfBuiltin
(
this
-
>
symbolTable
(
)
)
)
;
}
std
:
:
string
Block
:
:
description
(
)
const
{
std
:
:
string
result
;
bool
isScope
=
this
-
>
isScope
(
)
|
|
this
-
>
isEmpty
(
)
;
if
(
isScope
)
{
result
+
=
"
{
"
;
}
for
(
const
std
:
:
unique_ptr
<
Statement
>
&
stmt
:
this
-
>
children
(
)
)
{
result
+
=
"
\
n
"
;
result
+
=
stmt
-
>
description
(
)
;
}
result
+
=
isScope
?
"
\
n
}
\
n
"
:
"
\
n
"
;
return
result
;
}
}
