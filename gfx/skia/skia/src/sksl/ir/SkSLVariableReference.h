#
ifndef
SKSL_VARIABLEREFERENCE
#
define
SKSL_VARIABLEREFERENCE
#
include
"
SkSLExpression
.
h
"
namespace
SkSL
{
class
IRGenerator
;
struct
VariableReference
:
public
Expression
{
enum
RefKind
{
kRead_RefKind
kWrite_RefKind
kReadWrite_RefKind
kPointer_RefKind
}
;
VariableReference
(
int
offset
const
Variable
&
variable
RefKind
refKind
=
kRead_RefKind
)
;
~
VariableReference
(
)
override
;
RefKind
refKind
(
)
const
{
return
fRefKind
;
}
void
setRefKind
(
RefKind
refKind
)
;
bool
hasSideEffects
(
)
const
override
{
return
false
;
}
bool
isConstant
(
)
const
override
{
return
0
!
=
(
fVariable
.
fModifiers
.
fFlags
&
Modifiers
:
:
kConst_Flag
)
;
}
std
:
:
unique_ptr
<
Expression
>
clone
(
)
const
override
{
return
std
:
:
unique_ptr
<
Expression
>
(
new
VariableReference
(
fOffset
fVariable
fRefKind
)
)
;
}
String
description
(
)
const
override
{
return
fVariable
.
fName
;
}
static
std
:
:
unique_ptr
<
Expression
>
copy_constant
(
const
IRGenerator
&
irGenerator
const
Expression
*
expr
)
;
std
:
:
unique_ptr
<
Expression
>
constantPropagate
(
const
IRGenerator
&
irGenerator
const
DefinitionMap
&
definitions
)
override
;
const
Variable
&
fVariable
;
RefKind
fRefKind
;
private
:
typedef
Expression
INHERITED
;
}
;
}
#
endif
