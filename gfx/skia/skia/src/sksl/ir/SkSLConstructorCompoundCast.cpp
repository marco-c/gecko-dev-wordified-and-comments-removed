#
include
"
src
/
sksl
/
ir
/
SkSLConstructorCompoundCast
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
SkSLDefines
.
h
"
#
include
"
src
/
sksl
/
SkSLAnalysis
.
h
"
#
include
"
src
/
sksl
/
SkSLConstantFolder
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorCompound
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorDiagonalMatrix
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorScalarCast
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorSplat
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLLiteral
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLType
.
h
"
#
include
<
cstddef
>
#
include
<
optional
>
namespace
SkSL
{
static
std
:
:
unique_ptr
<
Expression
>
cast_constant_composite
(
const
Context
&
context
Position
pos
const
Type
&
destType
std
:
:
unique_ptr
<
Expression
>
constCtor
)
{
const
Type
&
scalarType
=
destType
.
componentType
(
)
;
if
(
constCtor
-
>
is
<
ConstructorSplat
>
(
)
)
{
ConstructorSplat
&
splat
=
constCtor
-
>
as
<
ConstructorSplat
>
(
)
;
return
ConstructorSplat
:
:
Make
(
context
pos
destType
ConstructorScalarCast
:
:
Make
(
context
pos
scalarType
std
:
:
move
(
splat
.
argument
(
)
)
)
)
;
}
if
(
constCtor
-
>
is
<
ConstructorDiagonalMatrix
>
(
)
&
&
destType
.
isMatrix
(
)
)
{
ConstructorDiagonalMatrix
&
matrixCtor
=
constCtor
-
>
as
<
ConstructorDiagonalMatrix
>
(
)
;
return
ConstructorDiagonalMatrix
:
:
Make
(
context
pos
destType
ConstructorScalarCast
:
:
Make
(
context
pos
scalarType
std
:
:
move
(
matrixCtor
.
argument
(
)
)
)
)
;
}
size_t
numSlots
=
destType
.
slotCount
(
)
;
SkASSERT
(
numSlots
=
=
constCtor
-
>
type
(
)
.
slotCount
(
)
)
;
ExpressionArray
typecastArgs
;
typecastArgs
.
reserve_back
(
numSlots
)
;
for
(
size_t
index
=
0
;
index
<
numSlots
;
+
+
index
)
{
std
:
:
optional
<
double
>
slotVal
=
constCtor
-
>
getConstantValue
(
index
)
;
if
(
scalarType
.
checkForOutOfRangeLiteral
(
context
*
slotVal
constCtor
-
>
fPosition
)
)
{
*
slotVal
=
0
.
0
;
}
typecastArgs
.
push_back
(
Literal
:
:
Make
(
pos
*
slotVal
&
scalarType
)
)
;
}
return
ConstructorCompound
:
:
Make
(
context
pos
destType
std
:
:
move
(
typecastArgs
)
)
;
}
std
:
:
unique_ptr
<
Expression
>
ConstructorCompoundCast
:
:
Make
(
const
Context
&
context
Position
pos
const
Type
&
type
std
:
:
unique_ptr
<
Expression
>
arg
)
{
SkASSERT
(
type
.
isVector
(
)
|
|
type
.
isMatrix
(
)
)
;
SkASSERT
(
type
.
isAllowedInES2
(
context
)
)
;
SkASSERT
(
arg
-
>
type
(
)
.
isVector
(
)
=
=
type
.
isVector
(
)
)
;
SkASSERT
(
arg
-
>
type
(
)
.
isMatrix
(
)
=
=
type
.
isMatrix
(
)
)
;
SkASSERT
(
type
.
columns
(
)
=
=
arg
-
>
type
(
)
.
columns
(
)
)
;
SkASSERT
(
type
.
rows
(
)
=
=
arg
-
>
type
(
)
.
rows
(
)
)
;
if
(
type
.
matches
(
arg
-
>
type
(
)
)
)
{
return
arg
;
}
arg
=
ConstantFolder
:
:
MakeConstantValueForVariable
(
pos
std
:
:
move
(
arg
)
)
;
if
(
Analysis
:
:
IsCompileTimeConstant
(
*
arg
)
)
{
return
cast_constant_composite
(
context
pos
type
std
:
:
move
(
arg
)
)
;
}
return
std
:
:
make_unique
<
ConstructorCompoundCast
>
(
pos
type
std
:
:
move
(
arg
)
)
;
}
}
