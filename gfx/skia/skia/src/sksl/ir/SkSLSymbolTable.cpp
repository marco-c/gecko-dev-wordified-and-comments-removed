#
include
"
src
/
sksl
/
ir
/
SkSLSymbolTable
.
h
"
#
include
"
src
/
sksl
/
SkSLThreadContext
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFunctionDeclaration
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLType
.
h
"
namespace
SkSL
{
bool
SymbolTable
:
:
isType
(
std
:
:
string_view
name
)
const
{
const
Symbol
*
symbol
=
this
-
>
find
(
name
)
;
return
symbol
&
&
symbol
-
>
is
<
Type
>
(
)
;
}
bool
SymbolTable
:
:
isBuiltinType
(
std
:
:
string_view
name
)
const
{
if
(
!
this
-
>
isBuiltin
(
)
)
{
return
fParent
&
&
fParent
-
>
isBuiltinType
(
name
)
;
}
return
this
-
>
isType
(
name
)
;
}
const
Symbol
*
SymbolTable
:
:
findBuiltinSymbol
(
std
:
:
string_view
name
)
const
{
if
(
!
this
-
>
isBuiltin
(
)
)
{
return
fParent
?
fParent
-
>
findBuiltinSymbol
(
name
)
:
nullptr
;
}
return
this
-
>
find
(
name
)
;
}
Symbol
*
SymbolTable
:
:
lookup
(
const
SymbolKey
&
key
)
const
{
Symbol
*
*
symbolPPtr
=
fSymbols
.
find
(
key
)
;
if
(
symbolPPtr
)
{
return
*
symbolPPtr
;
}
return
fParent
?
fParent
-
>
lookup
(
key
)
:
nullptr
;
}
void
SymbolTable
:
:
renameSymbol
(
Symbol
*
symbol
std
:
:
string_view
newName
)
{
if
(
symbol
-
>
is
<
FunctionDeclaration
>
(
)
)
{
for
(
FunctionDeclaration
*
fn
=
&
symbol
-
>
as
<
FunctionDeclaration
>
(
)
;
fn
!
=
nullptr
;
fn
=
fn
-
>
mutableNextOverload
(
)
)
{
fn
-
>
setName
(
newName
)
;
}
}
else
{
symbol
-
>
setName
(
newName
)
;
}
this
-
>
addWithoutOwnership
(
symbol
)
;
}
const
std
:
:
string
*
SymbolTable
:
:
takeOwnershipOfString
(
std
:
:
string
str
)
{
fOwnedStrings
.
push_front
(
std
:
:
move
(
str
)
)
;
return
&
fOwnedStrings
.
front
(
)
;
}
void
SymbolTable
:
:
addWithoutOwnership
(
Symbol
*
symbol
)
{
auto
key
=
MakeSymbolKey
(
symbol
-
>
name
(
)
)
;
if
(
symbol
-
>
is
<
FunctionDeclaration
>
(
)
)
{
Symbol
*
existingSymbol
=
this
-
>
lookup
(
key
)
;
if
(
existingSymbol
&
&
existingSymbol
-
>
is
<
FunctionDeclaration
>
(
)
)
{
FunctionDeclaration
*
existingDecl
=
&
existingSymbol
-
>
as
<
FunctionDeclaration
>
(
)
;
symbol
-
>
as
<
FunctionDeclaration
>
(
)
.
setNextOverload
(
existingDecl
)
;
fSymbols
[
key
]
=
symbol
;
return
;
}
}
if
(
fAtModuleBoundary
&
&
fParent
&
&
fParent
-
>
lookup
(
key
)
)
{
}
else
{
Symbol
*
&
refInSymbolTable
=
fSymbols
[
key
]
;
if
(
refInSymbolTable
=
=
nullptr
)
{
refInSymbolTable
=
symbol
;
return
;
}
}
ThreadContext
:
:
ReportError
(
"
symbol
'
"
+
std
:
:
string
(
symbol
-
>
name
(
)
)
+
"
'
was
already
defined
"
symbol
-
>
fPosition
)
;
}
void
SymbolTable
:
:
injectWithoutOwnership
(
Symbol
*
symbol
)
{
auto
key
=
MakeSymbolKey
(
symbol
-
>
name
(
)
)
;
fSymbols
[
key
]
=
symbol
;
}
const
Type
*
SymbolTable
:
:
addArrayDimension
(
const
Type
*
type
int
arraySize
)
{
if
(
arraySize
=
=
0
)
{
return
type
;
}
if
(
type
-
>
isInBuiltinTypes
(
)
&
&
fParent
&
&
!
fAtModuleBoundary
)
{
return
fParent
-
>
addArrayDimension
(
type
arraySize
)
;
}
std
:
:
string
arrayName
=
type
-
>
getArrayName
(
arraySize
)
;
if
(
const
Symbol
*
existingType
=
this
-
>
find
(
arrayName
)
)
{
return
&
existingType
-
>
as
<
Type
>
(
)
;
}
const
std
:
:
string
*
arrayNamePtr
=
this
-
>
takeOwnershipOfString
(
std
:
:
move
(
arrayName
)
)
;
return
this
-
>
add
(
Type
:
:
MakeArrayType
(
*
arrayNamePtr
*
type
arraySize
)
)
;
}
}
