#
include
"
src
/
sksl
/
ir
/
SkSLSymbolTable
.
h
"
#
include
"
src
/
sksl
/
SkSLContext
.
h
"
#
include
"
src
/
sksl
/
SkSLErrorReporter
.
h
"
#
include
"
src
/
sksl
/
SkSLPosition
.
h
"
#
include
"
src
/
sksl
/
SkSLProgramSettings
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLFunctionDeclaration
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLType
.
h
"
namespace
SkSL
{
std
:
:
unique_ptr
<
SymbolTable
>
SymbolTable
:
:
insertNewParent
(
)
{
auto
newTable
=
std
:
:
make_unique
<
SymbolTable
>
(
fParent
fBuiltin
)
;
fParent
=
newTable
.
get
(
)
;
return
newTable
;
}
bool
SymbolTable
:
:
isType
(
std
:
:
string_view
name
)
const
{
const
Symbol
*
symbol
=
this
-
>
find
(
name
)
;
return
symbol
&
&
symbol
-
>
is
<
Type
>
(
)
;
}
bool
SymbolTable
:
:
isBuiltinType
(
std
:
:
string_view
name
)
const
{
if
(
!
this
-
>
isBuiltin
(
)
)
{
return
fParent
&
&
fParent
-
>
isBuiltinType
(
name
)
;
}
return
this
-
>
isType
(
name
)
;
}
const
Symbol
*
SymbolTable
:
:
findBuiltinSymbol
(
std
:
:
string_view
name
)
const
{
if
(
!
this
-
>
isBuiltin
(
)
)
{
return
fParent
?
fParent
-
>
findBuiltinSymbol
(
name
)
:
nullptr
;
}
return
this
-
>
find
(
name
)
;
}
bool
SymbolTable
:
:
wouldShadowSymbolsFrom
(
const
SymbolTable
*
other
)
const
{
const
SymbolTable
*
self
=
this
;
if
(
self
-
>
count
(
)
>
other
-
>
count
(
)
)
{
std
:
:
swap
(
self
other
)
;
}
bool
foundShadow
=
false
;
self
-
>
fSymbols
.
foreach
(
[
&
]
(
const
SymbolKey
&
key
const
Symbol
*
symbol
)
{
if
(
foundShadow
)
{
return
;
}
if
(
other
-
>
fSymbols
.
find
(
key
)
!
=
nullptr
)
{
foundShadow
=
true
;
}
}
)
;
return
foundShadow
;
}
Symbol
*
SymbolTable
:
:
lookup
(
const
SymbolKey
&
key
)
const
{
Symbol
*
*
symbolPPtr
=
fSymbols
.
find
(
key
)
;
if
(
symbolPPtr
)
{
return
*
symbolPPtr
;
}
return
fParent
?
fParent
-
>
lookup
(
key
)
:
nullptr
;
}
void
SymbolTable
:
:
renameSymbol
(
const
Context
&
context
Symbol
*
symbol
std
:
:
string_view
newName
)
{
if
(
symbol
-
>
is
<
FunctionDeclaration
>
(
)
)
{
for
(
FunctionDeclaration
*
fn
=
&
symbol
-
>
as
<
FunctionDeclaration
>
(
)
;
fn
!
=
nullptr
;
fn
=
fn
-
>
mutableNextOverload
(
)
)
{
fn
-
>
setName
(
newName
)
;
}
}
else
{
symbol
-
>
setName
(
newName
)
;
}
this
-
>
addWithoutOwnership
(
context
symbol
)
;
}
std
:
:
unique_ptr
<
Symbol
>
SymbolTable
:
:
removeSymbol
(
const
Symbol
*
symbol
)
{
if
(
fSymbols
.
removeIfExists
(
MakeSymbolKey
(
symbol
-
>
name
(
)
)
)
)
{
for
(
std
:
:
unique_ptr
<
Symbol
>
&
owned
:
fOwnedSymbols
)
{
if
(
symbol
=
=
owned
.
get
(
)
)
{
return
std
:
:
move
(
owned
)
;
}
}
}
return
nullptr
;
}
void
SymbolTable
:
:
moveSymbolTo
(
SymbolTable
*
otherTable
Symbol
*
sym
const
Context
&
context
)
{
if
(
std
:
:
unique_ptr
<
Symbol
>
ownedSymbol
=
this
-
>
removeSymbol
(
sym
)
)
{
otherTable
-
>
add
(
context
std
:
:
move
(
ownedSymbol
)
)
;
}
else
{
otherTable
-
>
addWithoutOwnership
(
context
sym
)
;
}
}
const
std
:
:
string
*
SymbolTable
:
:
takeOwnershipOfString
(
std
:
:
string
str
)
{
fOwnedStrings
.
push_front
(
std
:
:
move
(
str
)
)
;
return
&
fOwnedStrings
.
front
(
)
;
}
void
SymbolTable
:
:
addWithoutOwnership
(
const
Context
&
context
Symbol
*
symbol
)
{
if
(
!
this
-
>
addWithoutOwnership
(
symbol
)
)
{
context
.
fErrors
-
>
error
(
symbol
-
>
position
(
)
"
symbol
'
"
+
std
:
:
string
(
symbol
-
>
name
(
)
)
+
"
'
was
already
defined
"
)
;
}
}
void
SymbolTable
:
:
addWithoutOwnershipOrDie
(
Symbol
*
symbol
)
{
if
(
!
this
-
>
addWithoutOwnership
(
symbol
)
)
{
SK_ABORT
(
"
symbol
'
%
.
*
s
'
was
already
defined
"
(
int
)
symbol
-
>
name
(
)
.
size
(
)
symbol
-
>
name
(
)
.
data
(
)
)
;
}
}
bool
SymbolTable
:
:
addWithoutOwnership
(
Symbol
*
symbol
)
{
if
(
symbol
-
>
name
(
)
.
empty
(
)
)
{
return
true
;
}
auto
key
=
MakeSymbolKey
(
symbol
-
>
name
(
)
)
;
if
(
symbol
-
>
is
<
FunctionDeclaration
>
(
)
)
{
Symbol
*
existingSymbol
=
this
-
>
lookup
(
key
)
;
if
(
existingSymbol
&
&
existingSymbol
-
>
is
<
FunctionDeclaration
>
(
)
)
{
FunctionDeclaration
*
existingDecl
=
&
existingSymbol
-
>
as
<
FunctionDeclaration
>
(
)
;
symbol
-
>
as
<
FunctionDeclaration
>
(
)
.
setNextOverload
(
existingDecl
)
;
fSymbols
[
key
]
=
symbol
;
return
true
;
}
}
if
(
fAtModuleBoundary
&
&
fParent
&
&
fParent
-
>
lookup
(
key
)
)
{
return
false
;
}
std
:
:
swap
(
symbol
fSymbols
[
key
]
)
;
return
symbol
=
=
nullptr
;
}
void
SymbolTable
:
:
injectWithoutOwnership
(
Symbol
*
symbol
)
{
auto
key
=
MakeSymbolKey
(
symbol
-
>
name
(
)
)
;
fSymbols
[
key
]
=
symbol
;
}
const
Type
*
SymbolTable
:
:
addArrayDimension
(
const
Context
&
context
const
Type
*
type
int
arraySize
)
{
if
(
arraySize
=
=
0
)
{
return
type
;
}
if
(
fParent
&
&
!
fAtModuleBoundary
&
&
!
context
.
fConfig
-
>
isBuiltinCode
(
)
&
&
type
-
>
isBuiltin
(
)
)
{
return
fParent
-
>
addArrayDimension
(
context
type
arraySize
)
;
}
std
:
:
string
arrayName
=
type
-
>
getArrayName
(
arraySize
)
;
if
(
const
Symbol
*
existingSymbol
=
this
-
>
find
(
arrayName
)
)
{
const
Type
*
existingType
=
&
existingSymbol
-
>
as
<
Type
>
(
)
;
if
(
existingType
-
>
isArray
(
)
&
&
type
-
>
matches
(
existingType
-
>
componentType
(
)
)
)
{
return
existingType
;
}
}
const
std
:
:
string
*
arrayNamePtr
=
this
-
>
takeOwnershipOfString
(
std
:
:
move
(
arrayName
)
)
;
return
this
-
>
add
(
context
Type
:
:
MakeArrayType
(
context
*
arrayNamePtr
*
type
arraySize
)
)
;
}
std
:
:
unique_ptr
<
Expression
>
SymbolTable
:
:
instantiateSymbolRef
(
const
Context
&
context
std
:
:
string_view
name
Position
pos
)
{
if
(
const
Symbol
*
symbol
=
this
-
>
find
(
name
)
)
{
return
symbol
-
>
instantiate
(
context
pos
)
;
}
context
.
fErrors
-
>
error
(
pos
"
unknown
identifier
'
"
+
std
:
:
string
(
name
)
+
"
'
"
)
;
return
nullptr
;
}
}
