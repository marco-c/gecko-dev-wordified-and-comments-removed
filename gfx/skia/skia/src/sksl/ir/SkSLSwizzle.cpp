#
include
"
src
/
sksl
/
ir
/
SkSLSwizzle
.
h
"
#
include
"
include
/
core
/
SkSpan
.
h
"
#
include
"
include
/
private
/
SkSLString
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
include
/
sksl
/
SkSLErrorReporter
.
h
"
#
include
"
include
/
sksl
/
SkSLOperator
.
h
"
#
include
"
src
/
sksl
/
SkSLAnalysis
.
h
"
#
include
"
src
/
sksl
/
SkSLConstantFolder
.
h
"
#
include
"
src
/
sksl
/
SkSLContext
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorCompound
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorCompoundCast
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorScalarCast
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorSplat
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLLiteral
.
h
"
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
optional
>
namespace
SkSL
{
static
bool
validate_swizzle_domain
(
const
ComponentArray
&
fields
)
{
enum
SwizzleDomain
{
kCoordinate
kColor
kUV
kRectangle
}
;
std
:
:
optional
<
SwizzleDomain
>
domain
;
for
(
int8_t
field
:
fields
)
{
SwizzleDomain
fieldDomain
;
switch
(
field
)
{
case
SwizzleComponent
:
:
X
:
case
SwizzleComponent
:
:
Y
:
case
SwizzleComponent
:
:
Z
:
case
SwizzleComponent
:
:
W
:
fieldDomain
=
kCoordinate
;
break
;
case
SwizzleComponent
:
:
R
:
case
SwizzleComponent
:
:
G
:
case
SwizzleComponent
:
:
B
:
case
SwizzleComponent
:
:
A
:
fieldDomain
=
kColor
;
break
;
case
SwizzleComponent
:
:
S
:
case
SwizzleComponent
:
:
T
:
case
SwizzleComponent
:
:
P
:
case
SwizzleComponent
:
:
Q
:
fieldDomain
=
kUV
;
break
;
case
SwizzleComponent
:
:
UL
:
case
SwizzleComponent
:
:
UT
:
case
SwizzleComponent
:
:
UR
:
case
SwizzleComponent
:
:
UB
:
fieldDomain
=
kRectangle
;
break
;
case
SwizzleComponent
:
:
ZERO
:
case
SwizzleComponent
:
:
ONE
:
continue
;
default
:
return
false
;
}
if
(
!
domain
.
has_value
(
)
)
{
domain
=
fieldDomain
;
}
else
if
(
domain
!
=
fieldDomain
)
{
return
false
;
}
}
return
true
;
}
static
char
mask_char
(
int8_t
component
)
{
switch
(
component
)
{
case
SwizzleComponent
:
:
X
:
return
'
x
'
;
case
SwizzleComponent
:
:
Y
:
return
'
y
'
;
case
SwizzleComponent
:
:
Z
:
return
'
z
'
;
case
SwizzleComponent
:
:
W
:
return
'
w
'
;
case
SwizzleComponent
:
:
R
:
return
'
r
'
;
case
SwizzleComponent
:
:
G
:
return
'
g
'
;
case
SwizzleComponent
:
:
B
:
return
'
b
'
;
case
SwizzleComponent
:
:
A
:
return
'
a
'
;
case
SwizzleComponent
:
:
S
:
return
'
s
'
;
case
SwizzleComponent
:
:
T
:
return
'
t
'
;
case
SwizzleComponent
:
:
P
:
return
'
p
'
;
case
SwizzleComponent
:
:
Q
:
return
'
q
'
;
case
SwizzleComponent
:
:
UL
:
return
'
L
'
;
case
SwizzleComponent
:
:
UT
:
return
'
T
'
;
case
SwizzleComponent
:
:
UR
:
return
'
R
'
;
case
SwizzleComponent
:
:
UB
:
return
'
B
'
;
case
SwizzleComponent
:
:
ZERO
:
return
'
0
'
;
case
SwizzleComponent
:
:
ONE
:
return
'
1
'
;
default
:
SkUNREACHABLE
;
}
}
static
std
:
:
string
mask_string
(
const
ComponentArray
&
components
)
{
std
:
:
string
result
;
for
(
int8_t
component
:
components
)
{
result
+
=
mask_char
(
component
)
;
}
return
result
;
}
static
std
:
:
unique_ptr
<
Expression
>
optimize_constructor_swizzle
(
const
Context
&
context
Position
pos
const
ConstructorCompound
&
base
ComponentArray
components
)
{
auto
baseArguments
=
base
.
argumentSpan
(
)
;
std
:
:
unique_ptr
<
Expression
>
replacement
;
const
Type
&
exprType
=
base
.
type
(
)
;
const
Type
&
componentType
=
exprType
.
componentType
(
)
;
int
swizzleSize
=
components
.
size
(
)
;
struct
ConstructorArgMap
{
int8_t
fArgIndex
;
int8_t
fComponent
;
}
;
int
numConstructorArgs
=
base
.
type
(
)
.
columns
(
)
;
ConstructorArgMap
argMap
[
4
]
=
{
}
;
int
writeIdx
=
0
;
for
(
int
argIdx
=
0
;
argIdx
<
(
int
)
baseArguments
.
size
(
)
;
+
+
argIdx
)
{
const
Expression
&
arg
=
*
baseArguments
[
argIdx
]
;
const
Type
&
argType
=
arg
.
type
(
)
;
if
(
!
argType
.
isScalar
(
)
&
&
!
argType
.
isVector
(
)
)
{
return
nullptr
;
}
int
argSlots
=
argType
.
slotCount
(
)
;
for
(
int
componentIdx
=
0
;
componentIdx
<
argSlots
;
+
+
componentIdx
)
{
argMap
[
writeIdx
]
.
fArgIndex
=
argIdx
;
argMap
[
writeIdx
]
.
fComponent
=
componentIdx
;
+
+
writeIdx
;
}
}
SkASSERT
(
writeIdx
=
=
numConstructorArgs
)
;
int8_t
exprUsed
[
4
]
=
{
}
;
for
(
int8_t
c
:
components
)
{
exprUsed
[
argMap
[
c
]
.
fArgIndex
]
+
+
;
}
for
(
int
index
=
0
;
index
<
numConstructorArgs
;
+
+
index
)
{
int8_t
constructorArgIndex
=
argMap
[
index
]
.
fArgIndex
;
const
Expression
&
baseArg
=
*
baseArguments
[
constructorArgIndex
]
;
if
(
exprUsed
[
constructorArgIndex
]
>
1
&
&
!
Analysis
:
:
IsTrivialExpression
(
baseArg
)
)
{
return
nullptr
;
}
if
(
exprUsed
[
constructorArgIndex
]
!
=
1
&
&
Analysis
:
:
HasSideEffects
(
baseArg
)
)
{
return
nullptr
;
}
}
struct
ReorderedArgument
{
int8_t
fArgIndex
;
ComponentArray
fComponents
;
}
;
SkSTArray
<
4
ReorderedArgument
>
reorderedArgs
;
for
(
int8_t
c
:
components
)
{
const
ConstructorArgMap
&
argument
=
argMap
[
c
]
;
const
Expression
&
baseArg
=
*
baseArguments
[
argument
.
fArgIndex
]
;
if
(
baseArg
.
type
(
)
.
isScalar
(
)
)
{
SkASSERT
(
argument
.
fComponent
=
=
0
)
;
reorderedArgs
.
push_back
(
{
argument
.
fArgIndex
ComponentArray
{
}
}
)
;
}
else
{
SkASSERT
(
baseArg
.
type
(
)
.
isVector
(
)
)
;
SkASSERT
(
argument
.
fComponent
<
baseArg
.
type
(
)
.
columns
(
)
)
;
if
(
reorderedArgs
.
empty
(
)
|
|
reorderedArgs
.
back
(
)
.
fArgIndex
!
=
argument
.
fArgIndex
)
{
reorderedArgs
.
push_back
(
{
argument
.
fArgIndex
ComponentArray
{
argument
.
fComponent
}
}
)
;
}
else
{
SkASSERT
(
!
reorderedArgs
.
back
(
)
.
fComponents
.
empty
(
)
)
;
reorderedArgs
.
back
(
)
.
fComponents
.
push_back
(
argument
.
fComponent
)
;
}
}
}
ExpressionArray
newArgs
;
newArgs
.
reserve_back
(
swizzleSize
)
;
for
(
const
ReorderedArgument
&
reorderedArg
:
reorderedArgs
)
{
std
:
:
unique_ptr
<
Expression
>
newArg
=
baseArguments
[
reorderedArg
.
fArgIndex
]
-
>
clone
(
)
;
if
(
reorderedArg
.
fComponents
.
empty
(
)
)
{
newArgs
.
push_back
(
std
:
:
move
(
newArg
)
)
;
}
else
{
newArgs
.
push_back
(
Swizzle
:
:
Make
(
context
pos
std
:
:
move
(
newArg
)
reorderedArg
.
fComponents
)
)
;
}
}
return
ConstructorCompound
:
:
Make
(
context
pos
componentType
.
toCompound
(
context
swizzleSize
1
)
std
:
:
move
(
newArgs
)
)
;
}
std
:
:
unique_ptr
<
Expression
>
Swizzle
:
:
Convert
(
const
Context
&
context
Position
pos
Position
maskPos
std
:
:
unique_ptr
<
Expression
>
base
std
:
:
string_view
maskString
)
{
ComponentArray
components
;
for
(
size_t
i
=
0
;
i
<
maskString
.
length
(
)
;
+
+
i
)
{
char
field
=
maskString
[
i
]
;
switch
(
field
)
{
case
'
0
'
:
components
.
push_back
(
SwizzleComponent
:
:
ZERO
)
;
break
;
case
'
1
'
:
components
.
push_back
(
SwizzleComponent
:
:
ONE
)
;
break
;
case
'
x
'
:
components
.
push_back
(
SwizzleComponent
:
:
X
)
;
break
;
case
'
r
'
:
components
.
push_back
(
SwizzleComponent
:
:
R
)
;
break
;
case
'
s
'
:
components
.
push_back
(
SwizzleComponent
:
:
S
)
;
break
;
case
'
L
'
:
components
.
push_back
(
SwizzleComponent
:
:
UL
)
;
break
;
case
'
y
'
:
components
.
push_back
(
SwizzleComponent
:
:
Y
)
;
break
;
case
'
g
'
:
components
.
push_back
(
SwizzleComponent
:
:
G
)
;
break
;
case
'
t
'
:
components
.
push_back
(
SwizzleComponent
:
:
T
)
;
break
;
case
'
T
'
:
components
.
push_back
(
SwizzleComponent
:
:
UT
)
;
break
;
case
'
z
'
:
components
.
push_back
(
SwizzleComponent
:
:
Z
)
;
break
;
case
'
b
'
:
components
.
push_back
(
SwizzleComponent
:
:
B
)
;
break
;
case
'
p
'
:
components
.
push_back
(
SwizzleComponent
:
:
P
)
;
break
;
case
'
R
'
:
components
.
push_back
(
SwizzleComponent
:
:
UR
)
;
break
;
case
'
w
'
:
components
.
push_back
(
SwizzleComponent
:
:
W
)
;
break
;
case
'
a
'
:
components
.
push_back
(
SwizzleComponent
:
:
A
)
;
break
;
case
'
q
'
:
components
.
push_back
(
SwizzleComponent
:
:
Q
)
;
break
;
case
'
B
'
:
components
.
push_back
(
SwizzleComponent
:
:
UB
)
;
break
;
default
:
context
.
fErrors
-
>
error
(
Position
:
:
Range
(
maskPos
.
startOffset
(
)
+
i
maskPos
.
startOffset
(
)
+
i
+
1
)
String
:
:
printf
(
"
invalid
swizzle
component
'
%
c
'
"
field
)
)
;
return
nullptr
;
}
}
return
Convert
(
context
pos
maskPos
std
:
:
move
(
base
)
std
:
:
move
(
components
)
)
;
}
std
:
:
unique_ptr
<
Expression
>
Swizzle
:
:
Convert
(
const
Context
&
context
Position
pos
Position
rawMaskPos
std
:
:
unique_ptr
<
Expression
>
base
ComponentArray
inComponents
)
{
Position
maskPos
=
rawMaskPos
.
valid
(
)
?
rawMaskPos
:
pos
;
if
(
!
validate_swizzle_domain
(
inComponents
)
)
{
context
.
fErrors
-
>
error
(
maskPos
"
invalid
swizzle
mask
'
"
+
mask_string
(
inComponents
)
+
"
'
"
)
;
return
nullptr
;
}
const
Type
&
baseType
=
base
-
>
type
(
)
.
scalarTypeForLiteral
(
)
;
if
(
!
baseType
.
isVector
(
)
&
&
!
baseType
.
isScalar
(
)
)
{
context
.
fErrors
-
>
error
(
pos
"
cannot
swizzle
value
of
type
'
"
+
baseType
.
displayName
(
)
+
"
'
"
)
;
return
nullptr
;
}
if
(
inComponents
.
size
(
)
>
4
)
{
Position
errorPos
=
rawMaskPos
.
valid
(
)
?
Position
:
:
Range
(
maskPos
.
startOffset
(
)
+
4
maskPos
.
endOffset
(
)
)
:
pos
;
context
.
fErrors
-
>
error
(
errorPos
"
too
many
components
in
swizzle
mask
'
"
+
mask_string
(
inComponents
)
+
"
'
"
)
;
return
nullptr
;
}
ComponentArray
maskComponents
;
bool
foundXYZW
=
false
;
for
(
int
i
=
0
;
i
<
inComponents
.
size
(
)
;
+
+
i
)
{
switch
(
inComponents
[
i
]
)
{
case
SwizzleComponent
:
:
ZERO
:
case
SwizzleComponent
:
:
ONE
:
break
;
case
SwizzleComponent
:
:
X
:
case
SwizzleComponent
:
:
R
:
case
SwizzleComponent
:
:
S
:
case
SwizzleComponent
:
:
UL
:
foundXYZW
=
true
;
maskComponents
.
push_back
(
SwizzleComponent
:
:
X
)
;
break
;
case
SwizzleComponent
:
:
Y
:
case
SwizzleComponent
:
:
G
:
case
SwizzleComponent
:
:
T
:
case
SwizzleComponent
:
:
UT
:
foundXYZW
=
true
;
if
(
baseType
.
columns
(
)
>
=
2
)
{
maskComponents
.
push_back
(
SwizzleComponent
:
:
Y
)
;
break
;
}
[
[
fallthrough
]
]
;
case
SwizzleComponent
:
:
Z
:
case
SwizzleComponent
:
:
B
:
case
SwizzleComponent
:
:
P
:
case
SwizzleComponent
:
:
UR
:
foundXYZW
=
true
;
if
(
baseType
.
columns
(
)
>
=
3
)
{
maskComponents
.
push_back
(
SwizzleComponent
:
:
Z
)
;
break
;
}
[
[
fallthrough
]
]
;
case
SwizzleComponent
:
:
W
:
case
SwizzleComponent
:
:
A
:
case
SwizzleComponent
:
:
Q
:
case
SwizzleComponent
:
:
UB
:
foundXYZW
=
true
;
if
(
baseType
.
columns
(
)
>
=
4
)
{
maskComponents
.
push_back
(
SwizzleComponent
:
:
W
)
;
break
;
}
[
[
fallthrough
]
]
;
default
:
context
.
fErrors
-
>
error
(
Position
:
:
Range
(
maskPos
.
startOffset
(
)
+
i
maskPos
.
startOffset
(
)
+
i
+
1
)
String
:
:
printf
(
"
invalid
swizzle
component
'
%
c
'
"
mask_char
(
inComponents
[
i
]
)
)
)
;
return
nullptr
;
}
}
if
(
!
foundXYZW
)
{
context
.
fErrors
-
>
error
(
maskPos
"
swizzle
must
refer
to
base
expression
"
)
;
return
nullptr
;
}
base
=
baseType
.
coerceExpression
(
std
:
:
move
(
base
)
context
)
;
if
(
!
base
)
{
return
nullptr
;
}
std
:
:
unique_ptr
<
Expression
>
expr
=
Swizzle
:
:
Make
(
context
pos
std
:
:
move
(
base
)
maskComponents
)
;
if
(
maskComponents
.
size
(
)
=
=
inComponents
.
size
(
)
)
{
return
expr
;
}
ExpressionArray
constructorArgs
;
constructorArgs
.
reserve_back
(
3
)
;
constructorArgs
.
push_back
(
std
:
:
move
(
expr
)
)
;
const
Type
*
scalarType
=
&
baseType
.
componentType
(
)
;
ComponentArray
swizzleComponents
;
int
maskFieldIdx
=
0
;
int
constantFieldIdx
=
maskComponents
.
size
(
)
;
int
constantZeroIdx
=
-
1
constantOneIdx
=
-
1
;
for
(
int
i
=
0
;
i
<
inComponents
.
size
(
)
;
i
+
+
)
{
switch
(
inComponents
[
i
]
)
{
case
SwizzleComponent
:
:
ZERO
:
if
(
constantZeroIdx
=
=
-
1
)
{
constructorArgs
.
push_back
(
Literal
:
:
Make
(
pos
0
scalarType
)
)
;
constantZeroIdx
=
constantFieldIdx
+
+
;
}
swizzleComponents
.
push_back
(
constantZeroIdx
)
;
break
;
case
SwizzleComponent
:
:
ONE
:
if
(
constantOneIdx
=
=
-
1
)
{
constructorArgs
.
push_back
(
Literal
:
:
Make
(
pos
1
scalarType
)
)
;
constantOneIdx
=
constantFieldIdx
+
+
;
}
swizzleComponents
.
push_back
(
constantOneIdx
)
;
break
;
default
:
swizzleComponents
.
push_back
(
maskFieldIdx
+
+
)
;
break
;
}
}
expr
=
ConstructorCompound
:
:
Make
(
context
pos
scalarType
-
>
toCompound
(
context
constantFieldIdx
1
)
std
:
:
move
(
constructorArgs
)
)
;
return
Swizzle
:
:
Make
(
context
pos
std
:
:
move
(
expr
)
swizzleComponents
)
;
}
std
:
:
unique_ptr
<
Expression
>
Swizzle
:
:
Make
(
const
Context
&
context
Position
pos
std
:
:
unique_ptr
<
Expression
>
expr
ComponentArray
components
)
{
const
Type
&
exprType
=
expr
-
>
type
(
)
;
SkASSERTF
(
exprType
.
isVector
(
)
|
|
exprType
.
isScalar
(
)
"
cannot
swizzle
type
'
%
s
'
"
exprType
.
description
(
)
.
c_str
(
)
)
;
SkASSERT
(
components
.
size
(
)
>
=
1
&
&
components
.
size
(
)
<
=
4
)
;
SkASSERT
(
std
:
:
all_of
(
components
.
begin
(
)
components
.
end
(
)
[
]
(
int8_t
component
)
{
return
component
>
=
SwizzleComponent
:
:
X
&
&
component
<
=
SwizzleComponent
:
:
W
;
}
)
)
;
if
(
exprType
.
isScalar
(
)
)
{
return
ConstructorSplat
:
:
Make
(
context
pos
exprType
.
toCompound
(
context
components
.
size
(
)
1
)
std
:
:
move
(
expr
)
)
;
}
if
(
components
.
size
(
)
=
=
exprType
.
columns
(
)
)
{
bool
identity
=
true
;
for
(
int
i
=
0
;
i
<
components
.
size
(
)
;
+
+
i
)
{
if
(
components
[
i
]
!
=
i
)
{
identity
=
false
;
break
;
}
}
if
(
identity
)
{
expr
-
>
fPosition
=
pos
;
return
expr
;
}
}
if
(
expr
-
>
is
<
Swizzle
>
(
)
)
{
Swizzle
&
base
=
expr
-
>
as
<
Swizzle
>
(
)
;
ComponentArray
combined
;
for
(
int8_t
c
:
components
)
{
combined
.
push_back
(
base
.
components
(
)
[
c
]
)
;
}
return
Swizzle
:
:
Make
(
context
pos
std
:
:
move
(
base
.
base
(
)
)
combined
)
;
}
const
Expression
*
value
=
ConstantFolder
:
:
GetConstantValueForVariable
(
*
expr
)
;
if
(
value
-
>
is
<
ConstructorSplat
>
(
)
)
{
const
ConstructorSplat
&
splat
=
value
-
>
as
<
ConstructorSplat
>
(
)
;
return
ConstructorSplat
:
:
Make
(
context
pos
splat
.
type
(
)
.
componentType
(
)
.
toCompound
(
context
components
.
size
(
)
1
)
splat
.
argument
(
)
-
>
clone
(
)
)
;
}
if
(
value
-
>
is
<
ConstructorCompoundCast
>
(
)
)
{
const
ConstructorCompoundCast
&
cast
=
value
-
>
as
<
ConstructorCompoundCast
>
(
)
;
const
Type
&
castType
=
cast
.
type
(
)
.
componentType
(
)
.
toCompound
(
context
components
.
size
(
)
1
)
;
std
:
:
unique_ptr
<
Expression
>
swizzled
=
Swizzle
:
:
Make
(
context
pos
cast
.
argument
(
)
-
>
clone
(
)
std
:
:
move
(
components
)
)
;
return
(
castType
.
columns
(
)
>
1
)
?
ConstructorCompoundCast
:
:
Make
(
context
pos
castType
std
:
:
move
(
swizzled
)
)
:
ConstructorScalarCast
:
:
Make
(
context
pos
castType
std
:
:
move
(
swizzled
)
)
;
}
if
(
value
-
>
is
<
ConstructorCompound
>
(
)
)
{
const
ConstructorCompound
&
ctor
=
value
-
>
as
<
ConstructorCompound
>
(
)
;
if
(
auto
replacement
=
optimize_constructor_swizzle
(
context
pos
ctor
components
)
)
{
return
replacement
;
}
}
return
std
:
:
make_unique
<
Swizzle
>
(
context
pos
std
:
:
move
(
expr
)
components
)
;
}
std
:
:
string
Swizzle
:
:
description
(
OperatorPrecedence
)
const
{
std
:
:
string
result
=
this
-
>
base
(
)
-
>
description
(
OperatorPrecedence
:
:
kPostfix
)
+
"
.
"
;
for
(
int
x
:
this
-
>
components
(
)
)
{
result
+
=
"
xyzw
"
[
x
]
;
}
return
result
;
}
}
