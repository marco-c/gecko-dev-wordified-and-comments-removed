#
include
"
src
/
sksl
/
ir
/
SkSLFunctionDeclaration
.
h
"
#
include
"
include
/
core
/
SkSpan
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
SkSLDefines
.
h
"
#
include
"
include
/
private
/
SkSLLayout
.
h
"
#
include
"
include
/
private
/
SkSLModifiers
.
h
"
#
include
"
include
/
private
/
SkSLProgramKind
.
h
"
#
include
"
include
/
private
/
SkSLString
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
include
/
sksl
/
SkSLErrorReporter
.
h
"
#
include
"
include
/
sksl
/
SkSLPosition
.
h
"
#
include
"
src
/
base
/
SkStringView
.
h
"
#
include
"
src
/
sksl
/
SkSLBuiltinTypes
.
h
"
#
include
"
src
/
sksl
/
SkSLCompiler
.
h
"
#
include
"
src
/
sksl
/
SkSLContext
.
h
"
#
include
"
src
/
sksl
/
SkSLModifiersPool
.
h
"
#
include
"
src
/
sksl
/
SkSLProgramSettings
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLSymbolTable
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLType
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLVariable
.
h
"
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
utility
>
namespace
SkSL
{
static
bool
check_modifiers
(
const
Context
&
context
Position
pos
const
Modifiers
&
modifiers
)
{
const
int
permitted
=
Modifiers
:
:
kInline_Flag
|
Modifiers
:
:
kNoInline_Flag
|
(
context
.
fConfig
-
>
fIsBuiltinCode
?
(
Modifiers
:
:
kES3_Flag
|
Modifiers
:
:
kPure_Flag
|
Modifiers
:
:
kExport_Flag
)
:
0
)
;
modifiers
.
checkPermitted
(
context
pos
permitted
0
)
;
if
(
(
modifiers
.
fFlags
&
Modifiers
:
:
kInline_Flag
)
&
&
(
modifiers
.
fFlags
&
Modifiers
:
:
kNoInline_Flag
)
)
{
context
.
fErrors
-
>
error
(
pos
"
functions
cannot
be
both
'
inline
'
and
'
noinline
'
"
)
;
return
false
;
}
return
true
;
}
static
bool
check_return_type
(
const
Context
&
context
Position
pos
const
Type
&
returnType
)
{
ErrorReporter
&
errors
=
*
context
.
fErrors
;
if
(
returnType
.
isArray
(
)
)
{
errors
.
error
(
pos
"
functions
may
not
return
type
'
"
+
returnType
.
displayName
(
)
+
"
'
"
)
;
return
false
;
}
if
(
context
.
fConfig
-
>
strictES2Mode
(
)
&
&
returnType
.
isOrContainsArray
(
)
)
{
errors
.
error
(
pos
"
functions
may
not
return
structs
containing
arrays
"
)
;
return
false
;
}
if
(
!
context
.
fConfig
-
>
fIsBuiltinCode
&
&
returnType
.
componentType
(
)
.
isOpaque
(
)
)
{
errors
.
error
(
pos
"
functions
may
not
return
opaque
type
'
"
+
returnType
.
displayName
(
)
+
"
'
"
)
;
return
false
;
}
return
true
;
}
static
bool
check_parameters
(
const
Context
&
context
std
:
:
vector
<
std
:
:
unique_ptr
<
Variable
>
>
&
parameters
bool
isMain
)
{
auto
typeIsValidForColor
=
[
&
]
(
const
Type
&
type
)
{
return
type
.
matches
(
*
context
.
fTypes
.
fHalf4
)
|
|
type
.
matches
(
*
context
.
fTypes
.
fFloat4
)
;
}
;
static
constexpr
int
kBuiltinColorIDs
[
]
=
{
SK_INPUT_COLOR_BUILTIN
SK_DEST_COLOR_BUILTIN
}
;
unsigned
int
builtinColorIndex
=
0
;
for
(
auto
&
param
:
parameters
)
{
const
Type
&
type
=
param
-
>
type
(
)
;
int
permittedFlags
=
Modifiers
:
:
kConst_Flag
|
Modifiers
:
:
kIn_Flag
;
if
(
!
type
.
isOpaque
(
)
)
{
permittedFlags
|
=
Modifiers
:
:
kOut_Flag
;
}
if
(
type
.
typeKind
(
)
=
=
Type
:
:
TypeKind
:
:
kTexture
)
{
permittedFlags
|
=
Modifiers
:
:
kReadOnly_Flag
|
Modifiers
:
:
kWriteOnly_Flag
;
}
param
-
>
modifiers
(
)
.
checkPermitted
(
context
param
-
>
modifiersPosition
(
)
permittedFlags
0
)
;
if
(
type
.
isEffectChild
(
)
&
&
!
context
.
fConfig
-
>
fIsBuiltinCode
)
{
context
.
fErrors
-
>
error
(
param
-
>
fPosition
"
parameters
of
type
'
"
+
type
.
displayName
(
)
+
"
'
not
allowed
"
)
;
return
false
;
}
Modifiers
m
=
param
-
>
modifiers
(
)
;
bool
modifiersChanged
=
false
;
if
(
Modifiers
:
:
kIn_Flag
=
=
(
m
.
fFlags
&
(
Modifiers
:
:
kOut_Flag
|
Modifiers
:
:
kIn_Flag
)
)
)
{
m
.
fFlags
&
=
~
(
Modifiers
:
:
kOut_Flag
|
Modifiers
:
:
kIn_Flag
)
;
modifiersChanged
=
true
;
}
if
(
isMain
)
{
if
(
ProgramConfig
:
:
IsRuntimeEffect
(
context
.
fConfig
-
>
fKind
)
&
&
context
.
fConfig
-
>
fKind
!
=
ProgramKind
:
:
kMeshFragment
&
&
context
.
fConfig
-
>
fKind
!
=
ProgramKind
:
:
kMeshVertex
)
{
if
(
type
.
matches
(
*
context
.
fTypes
.
fFloat2
)
)
{
m
.
fLayout
.
fBuiltin
=
SK_MAIN_COORDS_BUILTIN
;
modifiersChanged
=
true
;
}
else
if
(
typeIsValidForColor
(
type
)
&
&
builtinColorIndex
<
std
:
:
size
(
kBuiltinColorIDs
)
)
{
m
.
fLayout
.
fBuiltin
=
kBuiltinColorIDs
[
builtinColorIndex
+
+
]
;
modifiersChanged
=
true
;
}
}
else
if
(
ProgramConfig
:
:
IsFragment
(
context
.
fConfig
-
>
fKind
)
)
{
if
(
type
.
matches
(
*
context
.
fTypes
.
fFloat2
)
)
{
m
.
fLayout
.
fBuiltin
=
SK_MAIN_COORDS_BUILTIN
;
modifiersChanged
=
true
;
}
}
}
if
(
modifiersChanged
)
{
param
-
>
setModifiers
(
context
.
fModifiersPool
-
>
add
(
m
)
)
;
}
}
return
true
;
}
static
bool
check_main_signature
(
const
Context
&
context
Position
pos
const
Type
&
returnType
std
:
:
vector
<
std
:
:
unique_ptr
<
Variable
>
>
&
parameters
)
{
ErrorReporter
&
errors
=
*
context
.
fErrors
;
ProgramKind
kind
=
context
.
fConfig
-
>
fKind
;
auto
typeIsValidForColor
=
[
&
]
(
const
Type
&
type
)
{
return
type
.
matches
(
*
context
.
fTypes
.
fHalf4
)
|
|
type
.
matches
(
*
context
.
fTypes
.
fFloat4
)
;
}
;
auto
typeIsValidForAttributes
=
[
&
]
(
const
Type
&
type
)
{
return
type
.
isStruct
(
)
&
&
type
.
name
(
)
=
=
"
Attributes
"
;
}
;
auto
typeIsValidForVaryings
=
[
&
]
(
const
Type
&
type
)
{
return
type
.
isStruct
(
)
&
&
type
.
name
(
)
=
=
"
Varyings
"
;
}
;
auto
paramIsCoords
=
[
&
]
(
int
idx
)
{
const
Variable
&
p
=
*
parameters
[
idx
]
;
return
p
.
type
(
)
.
matches
(
*
context
.
fTypes
.
fFloat2
)
&
&
p
.
modifiers
(
)
.
fFlags
=
=
0
&
&
p
.
modifiers
(
)
.
fLayout
.
fBuiltin
=
=
SK_MAIN_COORDS_BUILTIN
;
}
;
auto
paramIsBuiltinColor
=
[
&
]
(
int
idx
int
builtinID
)
{
const
Variable
&
p
=
*
parameters
[
idx
]
;
return
typeIsValidForColor
(
p
.
type
(
)
)
&
&
p
.
modifiers
(
)
.
fFlags
=
=
0
&
&
p
.
modifiers
(
)
.
fLayout
.
fBuiltin
=
=
builtinID
;
}
;
auto
paramIsConstInAttributes
=
[
&
]
(
int
idx
)
{
const
Variable
&
p
=
*
parameters
[
idx
]
;
return
typeIsValidForAttributes
(
p
.
type
(
)
)
&
&
p
.
modifiers
(
)
.
fFlags
=
=
Modifiers
:
:
kConst_Flag
;
}
;
auto
paramIsConstInVaryings
=
[
&
]
(
int
idx
)
{
const
Variable
&
p
=
*
parameters
[
idx
]
;
return
typeIsValidForVaryings
(
p
.
type
(
)
)
&
&
p
.
modifiers
(
)
.
fFlags
=
=
Modifiers
:
:
kConst_Flag
;
}
;
auto
paramIsOutColor
=
[
&
]
(
int
idx
)
{
const
Variable
&
p
=
*
parameters
[
idx
]
;
return
typeIsValidForColor
(
p
.
type
(
)
)
&
&
p
.
modifiers
(
)
.
fFlags
=
=
Modifiers
:
:
kOut_Flag
;
}
;
auto
paramIsInputColor
=
[
&
]
(
int
n
)
{
return
paramIsBuiltinColor
(
n
SK_INPUT_COLOR_BUILTIN
)
;
}
;
auto
paramIsDestColor
=
[
&
]
(
int
n
)
{
return
paramIsBuiltinColor
(
n
SK_DEST_COLOR_BUILTIN
)
;
}
;
switch
(
kind
)
{
case
ProgramKind
:
:
kRuntimeColorFilter
:
case
ProgramKind
:
:
kPrivateRuntimeColorFilter
:
{
if
(
!
typeIsValidForColor
(
returnType
)
)
{
errors
.
error
(
pos
"
'
main
'
must
return
:
'
vec4
'
'
float4
'
or
'
half4
'
"
)
;
return
false
;
}
bool
validParams
=
(
parameters
.
size
(
)
=
=
1
&
&
paramIsInputColor
(
0
)
)
;
if
(
!
validParams
)
{
errors
.
error
(
pos
"
'
main
'
parameter
must
be
'
vec4
'
'
float4
'
or
'
half4
'
"
)
;
return
false
;
}
break
;
}
case
ProgramKind
:
:
kRuntimeShader
:
case
ProgramKind
:
:
kPrivateRuntimeShader
:
{
if
(
!
typeIsValidForColor
(
returnType
)
)
{
errors
.
error
(
pos
"
'
main
'
must
return
:
'
vec4
'
'
float4
'
or
'
half4
'
"
)
;
return
false
;
}
if
(
!
(
parameters
.
size
(
)
=
=
1
&
&
paramIsCoords
(
0
)
)
)
{
errors
.
error
(
pos
"
'
main
'
parameter
must
be
'
float2
'
or
'
vec2
'
"
)
;
return
false
;
}
break
;
}
case
ProgramKind
:
:
kRuntimeBlender
:
case
ProgramKind
:
:
kPrivateRuntimeBlender
:
{
if
(
!
typeIsValidForColor
(
returnType
)
)
{
errors
.
error
(
pos
"
'
main
'
must
return
:
'
vec4
'
'
float4
'
or
'
half4
'
"
)
;
return
false
;
}
if
(
!
(
parameters
.
size
(
)
=
=
2
&
&
paramIsInputColor
(
0
)
&
&
paramIsDestColor
(
1
)
)
)
{
errors
.
error
(
pos
"
'
main
'
parameters
must
be
(
vec4
|
float4
|
half4
"
"
vec4
|
float4
|
half4
)
"
)
;
return
false
;
}
break
;
}
case
ProgramKind
:
:
kMeshVertex
:
{
if
(
!
typeIsValidForVaryings
(
returnType
)
)
{
errors
.
error
(
pos
"
'
main
'
must
return
'
Varyings
'
.
"
)
;
return
false
;
}
if
(
!
(
parameters
.
size
(
)
=
=
1
&
&
paramIsConstInAttributes
(
0
)
)
)
{
errors
.
error
(
pos
"
'
main
'
parameter
must
be
'
const
Attributes
'
.
"
)
;
return
false
;
}
break
;
}
case
ProgramKind
:
:
kMeshFragment
:
{
if
(
!
returnType
.
matches
(
*
context
.
fTypes
.
fFloat2
)
)
{
errors
.
error
(
pos
"
'
main
'
must
return
:
'
vec2
'
or
'
float2
'
"
)
;
return
false
;
}
if
(
!
(
(
parameters
.
size
(
)
=
=
1
&
&
paramIsConstInVaryings
(
0
)
)
|
|
(
parameters
.
size
(
)
=
=
2
&
&
paramIsConstInVaryings
(
0
)
&
&
paramIsOutColor
(
1
)
)
)
)
{
errors
.
error
(
pos
"
'
main
'
parameters
must
be
(
const
Varyings
(
out
(
half4
|
float4
)
)
?
)
"
)
;
return
false
;
}
break
;
}
case
ProgramKind
:
:
kFragment
:
case
ProgramKind
:
:
kGraphiteFragment
:
{
bool
validParams
=
(
parameters
.
size
(
)
=
=
0
)
|
|
(
parameters
.
size
(
)
=
=
1
&
&
paramIsCoords
(
0
)
)
;
if
(
!
validParams
)
{
errors
.
error
(
pos
"
shader
'
main
'
must
be
main
(
)
or
main
(
float2
)
"
)
;
return
false
;
}
break
;
}
case
ProgramKind
:
:
kVertex
:
case
ProgramKind
:
:
kGraphiteVertex
:
case
ProgramKind
:
:
kCompute
:
if
(
!
returnType
.
matches
(
*
context
.
fTypes
.
fVoid
)
)
{
errors
.
error
(
pos
"
'
main
'
must
return
'
void
'
"
)
;
return
false
;
}
if
(
parameters
.
size
(
)
)
{
errors
.
error
(
pos
"
shader
'
main
'
must
have
zero
parameters
"
)
;
return
false
;
}
break
;
}
return
true
;
}
static
int
find_generic_index
(
const
Type
&
concreteType
const
Type
&
genericType
bool
allowNarrowing
)
{
SkSpan
<
const
Type
*
const
>
genericTypes
=
genericType
.
coercibleTypes
(
)
;
for
(
size_t
index
=
0
;
index
<
genericTypes
.
size
(
)
;
+
+
index
)
{
if
(
concreteType
.
canCoerceTo
(
*
genericTypes
[
index
]
allowNarrowing
)
)
{
return
index
;
}
}
return
-
1
;
}
static
bool
type_generically_matches
(
const
Type
&
concreteType
const
Type
&
maybeGenericType
)
{
return
maybeGenericType
.
isGeneric
(
)
?
find_generic_index
(
concreteType
maybeGenericType
false
)
!
=
-
1
:
concreteType
.
matches
(
maybeGenericType
)
;
}
static
bool
parameters_match
(
const
std
:
:
vector
<
std
:
:
unique_ptr
<
Variable
>
>
&
params
const
std
:
:
vector
<
Variable
*
>
&
otherParams
)
{
if
(
params
.
size
(
)
!
=
otherParams
.
size
(
)
)
{
return
false
;
}
int
genericIndex
=
-
1
;
for
(
size_t
i
=
0
;
i
<
params
.
size
(
)
;
+
+
i
)
{
const
Type
*
paramType
=
&
params
[
i
]
-
>
type
(
)
;
const
Type
*
otherParamType
=
&
otherParams
[
i
]
-
>
type
(
)
;
if
(
otherParamType
-
>
isGeneric
(
)
)
{
int
genericIndexForThisParam
=
find_generic_index
(
*
paramType
*
otherParamType
false
)
;
if
(
genericIndexForThisParam
=
=
-
1
)
{
return
false
;
}
if
(
genericIndex
!
=
-
1
&
&
genericIndex
!
=
genericIndexForThisParam
)
{
return
false
;
}
genericIndex
=
genericIndexForThisParam
;
}
}
for
(
size_t
i
=
0
;
i
<
params
.
size
(
)
;
i
+
+
)
{
const
Type
*
paramType
=
&
params
[
i
]
-
>
type
(
)
;
const
Type
*
otherParamType
=
&
otherParams
[
i
]
-
>
type
(
)
;
if
(
otherParamType
-
>
isGeneric
(
)
)
{
SkASSERT
(
genericIndex
!
=
-
1
)
;
SkASSERT
(
genericIndex
<
(
int
)
otherParamType
-
>
coercibleTypes
(
)
.
size
(
)
)
;
otherParamType
=
otherParamType
-
>
coercibleTypes
(
)
[
genericIndex
]
;
}
if
(
!
paramType
-
>
matches
(
*
otherParamType
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
find_existing_declaration
(
const
Context
&
context
SymbolTable
&
symbols
Position
pos
const
Modifiers
*
modifiers
std
:
:
string_view
name
std
:
:
vector
<
std
:
:
unique_ptr
<
Variable
>
>
&
parameters
Position
returnTypePos
const
Type
*
returnType
FunctionDeclaration
*
*
outExistingDecl
)
{
auto
invalidDeclDescription
=
[
&
]
(
)
-
>
std
:
:
string
{
std
:
:
vector
<
Variable
*
>
paramPtrs
;
paramPtrs
.
reserve
(
parameters
.
size
(
)
)
;
for
(
std
:
:
unique_ptr
<
Variable
>
&
param
:
parameters
)
{
paramPtrs
.
push_back
(
param
.
get
(
)
)
;
}
return
FunctionDeclaration
(
pos
modifiers
name
std
:
:
move
(
paramPtrs
)
returnType
context
.
fConfig
-
>
fIsBuiltinCode
)
.
description
(
)
;
}
;
ErrorReporter
&
errors
=
*
context
.
fErrors
;
Symbol
*
entry
=
symbols
.
findMutable
(
name
)
;
*
outExistingDecl
=
nullptr
;
if
(
entry
)
{
if
(
!
entry
-
>
is
<
FunctionDeclaration
>
(
)
)
{
errors
.
error
(
pos
"
symbol
'
"
+
std
:
:
string
(
name
)
+
"
'
was
already
defined
"
)
;
return
false
;
}
for
(
FunctionDeclaration
*
other
=
&
entry
-
>
as
<
FunctionDeclaration
>
(
)
;
other
;
other
=
other
-
>
mutableNextOverload
(
)
)
{
SkASSERT
(
name
=
=
other
-
>
name
(
)
)
;
if
(
!
parameters_match
(
parameters
other
-
>
parameters
(
)
)
)
{
continue
;
}
if
(
!
type_generically_matches
(
*
returnType
other
-
>
returnType
(
)
)
)
{
errors
.
error
(
returnTypePos
"
functions
'
"
+
invalidDeclDescription
(
)
+
"
'
and
'
"
+
other
-
>
description
(
)
+
"
'
differ
only
in
return
type
"
)
;
return
false
;
}
for
(
size_t
i
=
0
;
i
<
parameters
.
size
(
)
;
i
+
+
)
{
if
(
parameters
[
i
]
-
>
modifiers
(
)
!
=
other
-
>
parameters
(
)
[
i
]
-
>
modifiers
(
)
)
{
errors
.
error
(
parameters
[
i
]
-
>
fPosition
"
modifiers
on
parameter
"
+
std
:
:
to_string
(
i
+
1
)
+
"
differ
between
declaration
and
definition
"
)
;
return
false
;
}
}
if
(
*
modifiers
!
=
other
-
>
modifiers
(
)
|
|
other
-
>
definition
(
)
|
|
other
-
>
isIntrinsic
(
)
)
{
errors
.
error
(
pos
"
duplicate
definition
of
'
"
+
invalidDeclDescription
(
)
+
"
'
"
)
;
return
false
;
}
*
outExistingDecl
=
other
;
break
;
}
if
(
!
*
outExistingDecl
&
&
entry
-
>
as
<
FunctionDeclaration
>
(
)
.
isMain
(
)
)
{
errors
.
error
(
pos
"
duplicate
definition
of
'
main
'
"
)
;
return
false
;
}
}
return
true
;
}
FunctionDeclaration
:
:
FunctionDeclaration
(
Position
pos
const
Modifiers
*
modifiers
std
:
:
string_view
name
std
:
:
vector
<
Variable
*
>
parameters
const
Type
*
returnType
bool
builtin
)
:
INHERITED
(
pos
kIRNodeKind
name
nullptr
)
fDefinition
(
nullptr
)
fModifiers
(
modifiers
)
fParameters
(
std
:
:
move
(
parameters
)
)
fReturnType
(
returnType
)
fBuiltin
(
builtin
)
fIsMain
(
name
=
=
"
main
"
)
fIntrinsicKind
(
builtin
?
FindIntrinsicKind
(
name
)
:
kNotIntrinsic
)
{
SkASSERT
(
std
:
:
count
(
fParameters
.
begin
(
)
fParameters
.
end
(
)
nullptr
)
=
=
0
)
;
}
FunctionDeclaration
*
FunctionDeclaration
:
:
Convert
(
const
Context
&
context
SymbolTable
&
symbols
Position
pos
Position
modifiersPosition
const
Modifiers
*
modifiers
std
:
:
string_view
name
std
:
:
vector
<
std
:
:
unique_ptr
<
Variable
>
>
parameters
Position
returnTypePos
const
Type
*
returnType
)
{
bool
isMain
=
(
name
=
=
"
main
"
)
;
FunctionDeclaration
*
decl
=
nullptr
;
if
(
!
check_modifiers
(
context
modifiersPosition
*
modifiers
)
|
|
!
check_return_type
(
context
returnTypePos
*
returnType
)
|
|
!
check_parameters
(
context
parameters
isMain
)
|
|
(
isMain
&
&
!
check_main_signature
(
context
pos
*
returnType
parameters
)
)
|
|
!
find_existing_declaration
(
context
symbols
pos
modifiers
name
parameters
returnTypePos
returnType
&
decl
)
)
{
return
nullptr
;
}
std
:
:
vector
<
Variable
*
>
finalParameters
;
finalParameters
.
reserve
(
parameters
.
size
(
)
)
;
for
(
std
:
:
unique_ptr
<
Variable
>
&
param
:
parameters
)
{
finalParameters
.
push_back
(
symbols
.
takeOwnershipOfSymbol
(
std
:
:
move
(
param
)
)
)
;
}
if
(
decl
)
{
return
decl
;
}
auto
result
=
std
:
:
make_unique
<
FunctionDeclaration
>
(
pos
modifiers
name
std
:
:
move
(
finalParameters
)
returnType
context
.
fConfig
-
>
fIsBuiltinCode
)
;
return
symbols
.
add
(
std
:
:
move
(
result
)
)
;
}
std
:
:
string
FunctionDeclaration
:
:
mangledName
(
)
const
{
if
(
(
this
-
>
isBuiltin
(
)
&
&
!
this
-
>
definition
(
)
)
|
|
this
-
>
isMain
(
)
)
{
return
std
:
:
string
(
this
-
>
name
(
)
)
;
}
std
:
:
string_view
name
=
this
-
>
name
(
)
;
const
char
*
builtinMarker
=
"
"
;
if
(
skstd
:
:
starts_with
(
name
'
'
)
)
{
name
.
remove_prefix
(
1
)
;
builtinMarker
=
"
Q
"
;
}
std
:
:
string
result
=
std
:
:
string
(
name
)
+
"
_
"
+
builtinMarker
+
this
-
>
returnType
(
)
.
abbreviatedName
(
)
;
for
(
const
Variable
*
p
:
this
-
>
parameters
(
)
)
{
result
+
=
p
-
>
type
(
)
.
abbreviatedName
(
)
;
}
return
result
;
}
std
:
:
string
FunctionDeclaration
:
:
description
(
)
const
{
int
modifierFlags
=
this
-
>
modifiers
(
)
.
fFlags
;
std
:
:
string
result
=
(
modifierFlags
?
Modifiers
:
:
DescribeFlags
(
modifierFlags
)
+
"
"
:
std
:
:
string
(
)
)
+
this
-
>
returnType
(
)
.
displayName
(
)
+
"
"
+
std
:
:
string
(
this
-
>
name
(
)
)
+
"
(
"
;
auto
separator
=
SkSL
:
:
String
:
:
Separator
(
)
;
for
(
const
Variable
*
p
:
this
-
>
parameters
(
)
)
{
result
+
=
separator
(
)
;
if
(
p
-
>
modifiers
(
)
.
fFlags
)
{
result
+
=
Modifiers
:
:
DescribeFlags
(
p
-
>
modifiers
(
)
.
fFlags
)
+
"
"
;
}
result
+
=
p
-
>
type
(
)
.
displayName
(
)
;
result
+
=
"
"
;
result
+
=
p
-
>
name
(
)
;
}
result
+
=
"
)
"
;
return
result
;
}
bool
FunctionDeclaration
:
:
matches
(
const
FunctionDeclaration
&
f
)
const
{
if
(
this
-
>
name
(
)
!
=
f
.
name
(
)
)
{
return
false
;
}
const
std
:
:
vector
<
Variable
*
>
&
parameters
=
this
-
>
parameters
(
)
;
const
std
:
:
vector
<
Variable
*
>
&
otherParameters
=
f
.
parameters
(
)
;
if
(
parameters
.
size
(
)
!
=
otherParameters
.
size
(
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
parameters
.
size
(
)
;
i
+
+
)
{
if
(
!
parameters
[
i
]
-
>
type
(
)
.
matches
(
otherParameters
[
i
]
-
>
type
(
)
)
)
{
return
false
;
}
}
return
true
;
}
bool
FunctionDeclaration
:
:
determineFinalTypes
(
const
ExpressionArray
&
arguments
ParamTypes
*
outParameterTypes
const
Type
*
*
outReturnType
)
const
{
const
std
:
:
vector
<
Variable
*
>
&
parameters
=
this
-
>
parameters
(
)
;
SkASSERT
(
SkToSizeT
(
arguments
.
size
(
)
)
=
=
parameters
.
size
(
)
)
;
outParameterTypes
-
>
reserve_back
(
arguments
.
size
(
)
)
;
int
genericIndex
=
-
1
;
for
(
int
i
=
0
;
i
<
arguments
.
size
(
)
;
i
+
+
)
{
const
Type
&
parameterType
=
parameters
[
i
]
-
>
type
(
)
;
if
(
!
parameterType
.
isGeneric
(
)
)
{
outParameterTypes
-
>
push_back
(
&
parameterType
)
;
continue
;
}
if
(
genericIndex
=
=
-
1
)
{
genericIndex
=
find_generic_index
(
arguments
[
i
]
-
>
type
(
)
parameterType
true
)
;
if
(
genericIndex
=
=
-
1
)
{
return
false
;
}
}
outParameterTypes
-
>
push_back
(
parameterType
.
coercibleTypes
(
)
[
genericIndex
]
)
;
}
const
Type
&
returnType
=
this
-
>
returnType
(
)
;
if
(
returnType
.
isGeneric
(
)
)
{
if
(
genericIndex
=
=
-
1
)
{
return
false
;
}
*
outReturnType
=
returnType
.
coercibleTypes
(
)
[
genericIndex
]
;
}
else
{
*
outReturnType
=
&
returnType
;
}
return
true
;
}
}
