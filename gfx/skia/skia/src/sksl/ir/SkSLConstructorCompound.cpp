#
include
"
src
/
sksl
/
ir
/
SkSLConstructorCompound
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
src
/
sksl
/
SkSLAnalysis
.
h
"
#
include
"
src
/
sksl
/
SkSLConstantFolder
.
h
"
#
include
"
src
/
sksl
/
SkSLContext
.
h
"
#
include
"
src
/
sksl
/
SkSLProgramSettings
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorSplat
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLType
.
h
"
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
numeric
>
#
include
<
string
>
namespace
SkSL
{
static
bool
is_safe_to_eliminate
(
const
Type
&
type
const
Expression
&
arg
)
{
if
(
type
.
isScalar
(
)
)
{
SkASSERTF
(
arg
.
type
(
)
.
matches
(
type
)
"
Creating
type
'
%
s
'
from
'
%
s
'
"
type
.
description
(
)
.
c_str
(
)
arg
.
type
(
)
.
description
(
)
.
c_str
(
)
)
;
return
true
;
}
if
(
type
.
isVector
(
)
&
&
arg
.
type
(
)
.
matches
(
type
)
)
{
return
true
;
}
return
false
;
}
static
const
Expression
*
make_splat_from_arguments
(
const
Type
&
type
const
ExpressionArray
&
args
)
{
if
(
type
.
isMatrix
(
)
)
{
return
nullptr
;
}
const
Expression
*
splatExpression
=
nullptr
;
for
(
int
index
=
0
;
index
<
args
.
size
(
)
;
+
+
index
)
{
const
Expression
*
expr
;
if
(
args
[
index
]
-
>
type
(
)
.
isScalar
(
)
)
{
expr
=
args
[
index
]
.
get
(
)
;
}
else
if
(
args
[
index
]
-
>
is
<
ConstructorSplat
>
(
)
)
{
expr
=
args
[
index
]
-
>
as
<
ConstructorSplat
>
(
)
.
argument
(
)
.
get
(
)
;
}
else
{
return
nullptr
;
}
if
(
index
=
=
0
)
{
splatExpression
=
expr
;
continue
;
}
if
(
!
Analysis
:
:
IsSameExpressionTree
(
*
expr
*
splatExpression
)
)
{
return
nullptr
;
}
}
return
splatExpression
;
}
std
:
:
unique_ptr
<
Expression
>
ConstructorCompound
:
:
Make
(
const
Context
&
context
Position
pos
const
Type
&
type
ExpressionArray
args
)
{
SkASSERT
(
type
.
isAllowedInES2
(
context
)
)
;
SkASSERT
(
std
:
:
all_of
(
args
.
begin
(
)
args
.
end
(
)
[
&
]
(
const
std
:
:
unique_ptr
<
Expression
>
&
arg
)
{
const
Type
&
argType
=
arg
-
>
type
(
)
;
return
(
argType
.
isScalar
(
)
|
|
argType
.
isVector
(
)
|
|
argType
.
isMatrix
(
)
)
&
&
(
argType
.
componentType
(
)
.
matches
(
type
.
componentType
(
)
)
)
;
}
)
)
;
SkASSERT
(
type
.
slotCount
(
)
=
=
std
:
:
accumulate
(
args
.
begin
(
)
args
.
end
(
)
(
size_t
)
0
[
]
(
size_t
n
const
std
:
:
unique_ptr
<
Expression
>
&
arg
)
{
return
n
+
arg
-
>
type
(
)
.
slotCount
(
)
;
}
)
)
;
if
(
args
.
size
(
)
=
=
1
&
&
is_safe_to_eliminate
(
type
*
args
.
front
(
)
)
)
{
args
.
front
(
)
-
>
fPosition
=
pos
;
return
std
:
:
move
(
args
.
front
(
)
)
;
}
SkASSERT
(
type
.
isVector
(
)
|
|
type
.
isMatrix
(
)
)
;
if
(
context
.
fConfig
-
>
fSettings
.
fOptimize
)
{
int
fields
=
0
;
for
(
const
std
:
:
unique_ptr
<
Expression
>
&
arg
:
args
)
{
fields
+
=
arg
-
>
is
<
ConstructorCompound
>
(
)
?
arg
-
>
as
<
ConstructorCompound
>
(
)
.
arguments
(
)
.
size
(
)
:
1
;
}
if
(
fields
>
args
.
size
(
)
)
{
ExpressionArray
flattened
;
flattened
.
reserve_back
(
fields
)
;
for
(
std
:
:
unique_ptr
<
Expression
>
&
arg
:
args
)
{
if
(
!
arg
-
>
is
<
ConstructorCompound
>
(
)
)
{
flattened
.
push_back
(
std
:
:
move
(
arg
)
)
;
continue
;
}
ConstructorCompound
&
compositeCtor
=
arg
-
>
as
<
ConstructorCompound
>
(
)
;
for
(
std
:
:
unique_ptr
<
Expression
>
&
innerArg
:
compositeCtor
.
arguments
(
)
)
{
flattened
.
push_back
(
std
:
:
move
(
innerArg
)
)
;
}
}
args
=
std
:
:
move
(
flattened
)
;
}
}
for
(
std
:
:
unique_ptr
<
Expression
>
&
arg
:
args
)
{
arg
=
ConstantFolder
:
:
MakeConstantValueForVariable
(
pos
std
:
:
move
(
arg
)
)
;
}
if
(
context
.
fConfig
-
>
fSettings
.
fOptimize
)
{
if
(
const
Expression
*
splat
=
make_splat_from_arguments
(
type
args
)
)
{
return
ConstructorSplat
:
:
Make
(
context
pos
type
splat
-
>
clone
(
)
)
;
}
}
return
std
:
:
make_unique
<
ConstructorCompound
>
(
pos
type
std
:
:
move
(
args
)
)
;
}
}
