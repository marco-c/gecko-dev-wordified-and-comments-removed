#
include
"
src
/
sksl
/
ir
/
SkSLTernaryExpression
.
h
"
#
include
"
src
/
sksl
/
SkSLAnalysis
.
h
"
#
include
"
src
/
sksl
/
SkSLBuiltinTypes
.
h
"
#
include
"
src
/
sksl
/
SkSLConstantFolder
.
h
"
#
include
"
src
/
sksl
/
SkSLContext
.
h
"
#
include
"
src
/
sksl
/
SkSLErrorReporter
.
h
"
#
include
"
src
/
sksl
/
SkSLOperator
.
h
"
#
include
"
src
/
sksl
/
SkSLProgramSettings
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLBinaryExpression
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLConstructorScalarCast
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLLiteral
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLPrefixExpression
.
h
"
namespace
SkSL
{
std
:
:
unique_ptr
<
Expression
>
TernaryExpression
:
:
Convert
(
const
Context
&
context
Position
pos
std
:
:
unique_ptr
<
Expression
>
test
std
:
:
unique_ptr
<
Expression
>
ifTrue
std
:
:
unique_ptr
<
Expression
>
ifFalse
)
{
test
=
context
.
fTypes
.
fBool
-
>
coerceExpression
(
std
:
:
move
(
test
)
context
)
;
if
(
!
test
|
|
!
ifTrue
|
|
!
ifFalse
)
{
return
nullptr
;
}
if
(
ifTrue
-
>
type
(
)
.
componentType
(
)
.
isOpaque
(
)
)
{
context
.
fErrors
-
>
error
(
pos
"
ternary
expression
of
opaque
type
'
"
+
ifTrue
-
>
type
(
)
.
displayName
(
)
+
"
'
is
not
allowed
"
)
;
return
nullptr
;
}
const
Type
*
trueType
;
const
Type
*
falseType
;
const
Type
*
resultType
;
Operator
equalityOp
(
Operator
:
:
Kind
:
:
EQEQ
)
;
if
(
!
equalityOp
.
determineBinaryType
(
context
ifTrue
-
>
type
(
)
ifFalse
-
>
type
(
)
&
trueType
&
falseType
&
resultType
)
|
|
!
trueType
-
>
matches
(
*
falseType
)
)
{
Position
errorPos
=
ifTrue
-
>
fPosition
.
rangeThrough
(
ifFalse
-
>
fPosition
)
;
if
(
ifTrue
-
>
type
(
)
.
isVoid
(
)
)
{
context
.
fErrors
-
>
error
(
errorPos
"
ternary
expression
of
type
'
void
'
is
not
allowed
"
)
;
}
else
{
context
.
fErrors
-
>
error
(
errorPos
"
ternary
operator
result
mismatch
:
'
"
+
ifTrue
-
>
type
(
)
.
displayName
(
)
+
"
'
'
"
+
ifFalse
-
>
type
(
)
.
displayName
(
)
+
"
'
"
)
;
}
return
nullptr
;
}
if
(
trueType
-
>
isOrContainsArray
(
)
)
{
context
.
fErrors
-
>
error
(
pos
"
ternary
operator
result
may
not
be
an
array
(
or
struct
"
"
containing
an
array
)
"
)
;
return
nullptr
;
}
ifTrue
=
trueType
-
>
coerceExpression
(
std
:
:
move
(
ifTrue
)
context
)
;
if
(
!
ifTrue
)
{
return
nullptr
;
}
ifFalse
=
falseType
-
>
coerceExpression
(
std
:
:
move
(
ifFalse
)
context
)
;
if
(
!
ifFalse
)
{
return
nullptr
;
}
return
TernaryExpression
:
:
Make
(
context
pos
std
:
:
move
(
test
)
std
:
:
move
(
ifTrue
)
std
:
:
move
(
ifFalse
)
)
;
}
std
:
:
unique_ptr
<
Expression
>
TernaryExpression
:
:
Make
(
const
Context
&
context
Position
pos
std
:
:
unique_ptr
<
Expression
>
test
std
:
:
unique_ptr
<
Expression
>
ifTrue
std
:
:
unique_ptr
<
Expression
>
ifFalse
)
{
SkASSERT
(
ifTrue
-
>
type
(
)
.
matches
(
ifFalse
-
>
type
(
)
)
)
;
SkASSERT
(
!
ifTrue
-
>
type
(
)
.
componentType
(
)
.
isOpaque
(
)
)
;
SkASSERT
(
!
context
.
fConfig
-
>
strictES2Mode
(
)
|
|
!
ifTrue
-
>
type
(
)
.
isOrContainsArray
(
)
)
;
const
Expression
*
testExpr
=
ConstantFolder
:
:
GetConstantValueForVariable
(
*
test
)
;
if
(
testExpr
-
>
isBoolLiteral
(
)
)
{
if
(
testExpr
-
>
as
<
Literal
>
(
)
.
boolValue
(
)
)
{
ifTrue
-
>
fPosition
=
pos
;
return
ifTrue
;
}
else
{
ifFalse
-
>
fPosition
=
pos
;
return
ifFalse
;
}
}
if
(
context
.
fConfig
-
>
fSettings
.
fOptimize
)
{
const
Expression
*
ifTrueExpr
=
ConstantFolder
:
:
GetConstantValueForVariable
(
*
ifTrue
)
;
const
Expression
*
ifFalseExpr
=
ConstantFolder
:
:
GetConstantValueForVariable
(
*
ifFalse
)
;
if
(
Analysis
:
:
IsSameExpressionTree
(
*
ifTrueExpr
*
ifFalseExpr
)
)
{
if
(
!
Analysis
:
:
HasSideEffects
(
*
test
)
)
{
ifTrue
-
>
fPosition
=
pos
;
return
ifTrue
;
}
return
BinaryExpression
:
:
Make
(
context
pos
std
:
:
move
(
test
)
Operator
:
:
Kind
:
:
COMMA
std
:
:
move
(
ifTrue
)
)
;
}
if
(
ifFalseExpr
-
>
isBoolLiteral
(
)
&
&
!
ifFalseExpr
-
>
as
<
Literal
>
(
)
.
boolValue
(
)
)
{
return
BinaryExpression
:
:
Make
(
context
pos
std
:
:
move
(
test
)
Operator
:
:
Kind
:
:
LOGICALAND
std
:
:
move
(
ifTrue
)
)
;
}
if
(
ifTrueExpr
-
>
isBoolLiteral
(
)
&
&
ifTrueExpr
-
>
as
<
Literal
>
(
)
.
boolValue
(
)
)
{
return
BinaryExpression
:
:
Make
(
context
pos
std
:
:
move
(
test
)
Operator
:
:
Kind
:
:
LOGICALOR
std
:
:
move
(
ifFalse
)
)
;
}
if
(
ifTrueExpr
-
>
isBoolLiteral
(
)
&
&
!
ifTrueExpr
-
>
as
<
Literal
>
(
)
.
boolValue
(
)
&
&
ifFalseExpr
-
>
isBoolLiteral
(
)
&
&
ifFalseExpr
-
>
as
<
Literal
>
(
)
.
boolValue
(
)
)
{
return
PrefixExpression
:
:
Make
(
context
pos
Operator
:
:
Kind
:
:
LOGICALNOT
std
:
:
move
(
test
)
)
;
}
if
(
ifTrueExpr
-
>
is
<
Literal
>
(
)
&
&
ifTrueExpr
-
>
as
<
Literal
>
(
)
.
value
(
)
=
=
1
.
0
&
&
ifFalseExpr
-
>
is
<
Literal
>
(
)
&
&
ifFalseExpr
-
>
as
<
Literal
>
(
)
.
value
(
)
=
=
0
.
0
)
{
return
ConstructorScalarCast
:
:
Make
(
context
pos
ifTrue
-
>
type
(
)
std
:
:
move
(
test
)
)
;
}
}
return
std
:
:
make_unique
<
TernaryExpression
>
(
pos
std
:
:
move
(
test
)
std
:
:
move
(
ifTrue
)
std
:
:
move
(
ifFalse
)
)
;
}
std
:
:
string
TernaryExpression
:
:
description
(
OperatorPrecedence
parentPrecedence
)
const
{
bool
needsParens
=
(
OperatorPrecedence
:
:
kTernary
>
=
parentPrecedence
)
;
return
std
:
:
string
(
needsParens
?
"
(
"
:
"
"
)
+
this
-
>
test
(
)
-
>
description
(
OperatorPrecedence
:
:
kTernary
)
+
"
?
"
+
this
-
>
ifTrue
(
)
-
>
description
(
OperatorPrecedence
:
:
kTernary
)
+
"
:
"
+
this
-
>
ifFalse
(
)
-
>
description
(
OperatorPrecedence
:
:
kTernary
)
+
std
:
:
string
(
needsParens
?
"
)
"
:
"
"
)
;
}
}
