#
include
"
src
/
sksl
/
ir
/
SkSLSwitchStatement
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
SkSLString
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
include
/
sksl
/
SkSLErrorReporter
.
h
"
#
include
"
src
/
core
/
SkTHash
.
h
"
#
include
"
src
/
sksl
/
SkSLAnalysis
.
h
"
#
include
"
src
/
sksl
/
SkSLBuiltinTypes
.
h
"
#
include
"
src
/
sksl
/
SkSLConstantFolder
.
h
"
#
include
"
src
/
sksl
/
SkSLContext
.
h
"
#
include
"
src
/
sksl
/
SkSLProgramSettings
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLBlock
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLNop
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLSwitchCase
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLSymbolTable
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLType
.
h
"
#
include
<
algorithm
>
#
include
<
forward_list
>
#
include
<
iterator
>
namespace
SkSL
{
std
:
:
unique_ptr
<
Statement
>
SwitchStatement
:
:
clone
(
)
const
{
StatementArray
cases
;
cases
.
reserve_back
(
this
-
>
cases
(
)
.
size
(
)
)
;
for
(
const
std
:
:
unique_ptr
<
Statement
>
&
stmt
:
this
-
>
cases
(
)
)
{
cases
.
push_back
(
stmt
-
>
clone
(
)
)
;
}
return
std
:
:
make_unique
<
SwitchStatement
>
(
fPosition
this
-
>
value
(
)
-
>
clone
(
)
std
:
:
move
(
cases
)
SymbolTable
:
:
WrapIfBuiltin
(
this
-
>
symbols
(
)
)
)
;
}
std
:
:
string
SwitchStatement
:
:
description
(
)
const
{
std
:
:
string
result
;
result
+
=
String
:
:
printf
(
"
switch
(
%
s
)
{
\
n
"
this
-
>
value
(
)
-
>
description
(
)
.
c_str
(
)
)
;
for
(
const
auto
&
c
:
this
-
>
cases
(
)
)
{
result
+
=
c
-
>
description
(
)
;
}
result
+
=
"
}
"
;
return
result
;
}
static
std
:
:
forward_list
<
const
SwitchCase
*
>
find_duplicate_case_values
(
const
StatementArray
&
cases
)
{
std
:
:
forward_list
<
const
SwitchCase
*
>
duplicateCases
;
SkTHashSet
<
SKSL_INT
>
intValues
;
bool
foundDefault
=
false
;
for
(
const
std
:
:
unique_ptr
<
Statement
>
&
stmt
:
cases
)
{
const
SwitchCase
*
sc
=
&
stmt
-
>
as
<
SwitchCase
>
(
)
;
if
(
sc
-
>
isDefault
(
)
)
{
if
(
foundDefault
)
{
duplicateCases
.
push_front
(
sc
)
;
continue
;
}
foundDefault
=
true
;
}
else
{
SKSL_INT
value
=
sc
-
>
value
(
)
;
if
(
intValues
.
contains
(
value
)
)
{
duplicateCases
.
push_front
(
sc
)
;
continue
;
}
intValues
.
add
(
value
)
;
}
}
return
duplicateCases
;
}
static
void
move_all_but_break
(
std
:
:
unique_ptr
<
Statement
>
&
stmt
StatementArray
*
target
)
{
switch
(
stmt
-
>
kind
(
)
)
{
case
Statement
:
:
Kind
:
:
kBlock
:
{
Block
&
block
=
stmt
-
>
as
<
Block
>
(
)
;
StatementArray
blockStmts
;
blockStmts
.
reserve_back
(
block
.
children
(
)
.
size
(
)
)
;
for
(
std
:
:
unique_ptr
<
Statement
>
&
blockStmt
:
block
.
children
(
)
)
{
move_all_but_break
(
blockStmt
&
blockStmts
)
;
}
target
-
>
push_back
(
Block
:
:
Make
(
block
.
fPosition
std
:
:
move
(
blockStmts
)
block
.
blockKind
(
)
block
.
symbolTable
(
)
)
)
;
break
;
}
case
Statement
:
:
Kind
:
:
kBreak
:
break
;
default
:
target
-
>
push_back
(
std
:
:
move
(
stmt
)
)
;
break
;
}
}
std
:
:
unique_ptr
<
Statement
>
SwitchStatement
:
:
BlockForCase
(
StatementArray
*
cases
SwitchCase
*
caseToCapture
std
:
:
shared_ptr
<
SymbolTable
>
symbolTable
)
{
auto
iter
=
cases
-
>
begin
(
)
;
for
(
;
iter
!
=
cases
-
>
end
(
)
;
+
+
iter
)
{
const
SwitchCase
&
sc
=
(
*
iter
)
-
>
as
<
SwitchCase
>
(
)
;
if
(
&
sc
=
=
caseToCapture
)
{
break
;
}
}
auto
startIter
=
iter
;
Statement
*
stripBreakStmt
=
nullptr
;
for
(
;
iter
!
=
cases
-
>
end
(
)
;
+
+
iter
)
{
std
:
:
unique_ptr
<
Statement
>
&
stmt
=
(
*
iter
)
-
>
as
<
SwitchCase
>
(
)
.
statement
(
)
;
if
(
Analysis
:
:
SwitchCaseContainsConditionalExit
(
*
stmt
)
)
{
return
nullptr
;
}
if
(
Analysis
:
:
SwitchCaseContainsUnconditionalExit
(
*
stmt
)
)
{
stripBreakStmt
=
stmt
.
get
(
)
;
break
;
}
}
StatementArray
caseStmts
;
caseStmts
.
reserve_back
(
std
:
:
distance
(
startIter
iter
)
+
1
)
;
while
(
startIter
!
=
iter
)
{
caseStmts
.
push_back
(
std
:
:
move
(
(
*
startIter
)
-
>
as
<
SwitchCase
>
(
)
.
statement
(
)
)
)
;
+
+
startIter
;
}
if
(
stripBreakStmt
!
=
nullptr
)
{
SkASSERT
(
(
*
startIter
)
-
>
as
<
SwitchCase
>
(
)
.
statement
(
)
.
get
(
)
=
=
stripBreakStmt
)
;
move_all_but_break
(
(
*
startIter
)
-
>
as
<
SwitchCase
>
(
)
.
statement
(
)
&
caseStmts
)
;
}
return
Block
:
:
Make
(
caseToCapture
-
>
fPosition
std
:
:
move
(
caseStmts
)
Block
:
:
Kind
:
:
kBracedScope
std
:
:
move
(
symbolTable
)
)
;
}
std
:
:
unique_ptr
<
Statement
>
SwitchStatement
:
:
Convert
(
const
Context
&
context
Position
pos
std
:
:
unique_ptr
<
Expression
>
value
ExpressionArray
caseValues
StatementArray
caseStatements
std
:
:
shared_ptr
<
SymbolTable
>
symbolTable
)
{
SkASSERT
(
caseValues
.
size
(
)
=
=
caseStatements
.
size
(
)
)
;
value
=
context
.
fTypes
.
fInt
-
>
coerceExpression
(
std
:
:
move
(
value
)
context
)
;
if
(
!
value
)
{
return
nullptr
;
}
StatementArray
cases
;
for
(
int
i
=
0
;
i
<
caseValues
.
size
(
)
;
+
+
i
)
{
if
(
caseValues
[
i
]
)
{
Position
casePos
=
caseValues
[
i
]
-
>
fPosition
;
std
:
:
unique_ptr
<
Expression
>
caseValue
=
value
-
>
type
(
)
.
coerceExpression
(
std
:
:
move
(
caseValues
[
i
]
)
context
)
;
if
(
!
caseValue
)
{
return
nullptr
;
}
SKSL_INT
intValue
;
if
(
!
ConstantFolder
:
:
GetConstantInt
(
*
caseValue
&
intValue
)
)
{
context
.
fErrors
-
>
error
(
casePos
"
case
value
must
be
a
constant
integer
"
)
;
return
nullptr
;
}
cases
.
push_back
(
SwitchCase
:
:
Make
(
casePos
intValue
std
:
:
move
(
caseStatements
[
i
]
)
)
)
;
}
else
{
cases
.
push_back
(
SwitchCase
:
:
MakeDefault
(
pos
std
:
:
move
(
caseStatements
[
i
]
)
)
)
;
}
}
std
:
:
forward_list
<
const
SwitchCase
*
>
duplicateCases
=
find_duplicate_case_values
(
cases
)
;
if
(
!
duplicateCases
.
empty
(
)
)
{
duplicateCases
.
reverse
(
)
;
for
(
const
SwitchCase
*
sc
:
duplicateCases
)
{
if
(
sc
-
>
isDefault
(
)
)
{
context
.
fErrors
-
>
error
(
sc
-
>
fPosition
"
duplicate
default
case
"
)
;
}
else
{
context
.
fErrors
-
>
error
(
sc
-
>
fPosition
"
duplicate
case
value
'
"
+
std
:
:
to_string
(
sc
-
>
value
(
)
)
+
"
'
"
)
;
}
}
return
nullptr
;
}
return
SwitchStatement
:
:
Make
(
context
pos
std
:
:
move
(
value
)
std
:
:
move
(
cases
)
std
:
:
move
(
symbolTable
)
)
;
}
std
:
:
unique_ptr
<
Statement
>
SwitchStatement
:
:
Make
(
const
Context
&
context
Position
pos
std
:
:
unique_ptr
<
Expression
>
value
StatementArray
cases
std
:
:
shared_ptr
<
SymbolTable
>
symbolTable
)
{
SkASSERT
(
std
:
:
all_of
(
cases
.
begin
(
)
cases
.
end
(
)
[
&
]
(
const
std
:
:
unique_ptr
<
Statement
>
&
stmt
)
{
return
stmt
-
>
is
<
SwitchCase
>
(
)
;
}
)
)
;
SkASSERT
(
find_duplicate_case_values
(
cases
)
.
empty
(
)
)
;
if
(
context
.
fConfig
-
>
fSettings
.
fOptimize
)
{
SKSL_INT
switchValue
;
if
(
ConstantFolder
:
:
GetConstantInt
(
*
value
&
switchValue
)
)
{
SwitchCase
*
defaultCase
=
nullptr
;
SwitchCase
*
matchingCase
=
nullptr
;
for
(
const
std
:
:
unique_ptr
<
Statement
>
&
stmt
:
cases
)
{
SwitchCase
&
sc
=
stmt
-
>
as
<
SwitchCase
>
(
)
;
if
(
sc
.
isDefault
(
)
)
{
defaultCase
=
&
sc
;
continue
;
}
if
(
sc
.
value
(
)
=
=
switchValue
)
{
matchingCase
=
&
sc
;
break
;
}
}
if
(
!
matchingCase
)
{
if
(
!
defaultCase
)
{
return
Nop
:
:
Make
(
)
;
}
matchingCase
=
defaultCase
;
}
std
:
:
unique_ptr
<
Statement
>
newBlock
=
BlockForCase
(
&
cases
matchingCase
symbolTable
)
;
if
(
newBlock
)
{
return
newBlock
;
}
}
}
return
std
:
:
make_unique
<
SwitchStatement
>
(
pos
std
:
:
move
(
value
)
std
:
:
move
(
cases
)
std
:
:
move
(
symbolTable
)
)
;
}
}
