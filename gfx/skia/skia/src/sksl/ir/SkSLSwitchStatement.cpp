#
include
"
src
/
sksl
/
ir
/
SkSLSwitchStatement
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
src
/
core
/
SkTHash
.
h
"
#
include
"
src
/
sksl
/
SkSLAnalysis
.
h
"
#
include
"
src
/
sksl
/
SkSLBuiltinTypes
.
h
"
#
include
"
src
/
sksl
/
SkSLConstantFolder
.
h
"
#
include
"
src
/
sksl
/
SkSLContext
.
h
"
#
include
"
src
/
sksl
/
SkSLErrorReporter
.
h
"
#
include
"
src
/
sksl
/
SkSLProgramSettings
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLBlock
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLBreakStatement
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLNop
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLSwitchCase
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLSymbolTable
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLType
.
h
"
#
include
"
src
/
sksl
/
transform
/
SkSLProgramWriter
.
h
"
#
include
"
src
/
sksl
/
transform
/
SkSLTransform
.
h
"
#
include
<
algorithm
>
#
include
<
iterator
>
using
namespace
skia_private
;
namespace
SkSL
{
std
:
:
string
SwitchStatement
:
:
description
(
)
const
{
return
"
switch
(
"
+
this
-
>
value
(
)
-
>
description
(
)
+
"
)
"
+
this
-
>
caseBlock
(
)
-
>
description
(
)
;
}
static
TArray
<
const
SwitchCase
*
>
find_duplicate_case_values
(
const
StatementArray
&
cases
)
{
TArray
<
const
SwitchCase
*
>
duplicateCases
;
THashSet
<
SKSL_INT
>
intValues
;
bool
foundDefault
=
false
;
for
(
const
std
:
:
unique_ptr
<
Statement
>
&
stmt
:
cases
)
{
const
SwitchCase
*
sc
=
&
stmt
-
>
as
<
SwitchCase
>
(
)
;
if
(
sc
-
>
isDefault
(
)
)
{
if
(
foundDefault
)
{
duplicateCases
.
push_back
(
sc
)
;
continue
;
}
foundDefault
=
true
;
}
else
{
SKSL_INT
value
=
sc
-
>
value
(
)
;
if
(
intValues
.
contains
(
value
)
)
{
duplicateCases
.
push_back
(
sc
)
;
continue
;
}
intValues
.
add
(
value
)
;
}
}
return
duplicateCases
;
}
static
void
remove_break_statements
(
std
:
:
unique_ptr
<
Statement
>
&
stmt
)
{
class
RemoveBreaksWriter
:
public
ProgramWriter
{
public
:
bool
visitStatementPtr
(
std
:
:
unique_ptr
<
Statement
>
&
stmt
)
override
{
if
(
stmt
-
>
is
<
BreakStatement
>
(
)
)
{
stmt
=
Nop
:
:
Make
(
)
;
return
false
;
}
return
ProgramWriter
:
:
visitStatementPtr
(
stmt
)
;
}
bool
visitExpressionPtr
(
std
:
:
unique_ptr
<
Expression
>
&
expr
)
override
{
return
false
;
}
}
;
RemoveBreaksWriter
{
}
.
visitStatementPtr
(
stmt
)
;
}
static
bool
block_for_case
(
Statement
*
caseBlock
SwitchCase
*
caseToCapture
)
{
StatementArray
&
cases
=
caseBlock
-
>
as
<
Block
>
(
)
.
children
(
)
;
auto
iter
=
cases
.
begin
(
)
;
for
(
;
iter
!
=
cases
.
end
(
)
;
+
+
iter
)
{
const
SwitchCase
&
sc
=
(
*
iter
)
-
>
as
<
SwitchCase
>
(
)
;
if
(
&
sc
=
=
caseToCapture
)
{
break
;
}
}
auto
startIter
=
iter
;
bool
removeBreakStatements
=
false
;
for
(
;
iter
!
=
cases
.
end
(
)
;
+
+
iter
)
{
std
:
:
unique_ptr
<
Statement
>
&
stmt
=
(
*
iter
)
-
>
as
<
SwitchCase
>
(
)
.
statement
(
)
;
if
(
Analysis
:
:
SwitchCaseContainsConditionalExit
(
*
stmt
)
)
{
return
false
;
}
if
(
Analysis
:
:
SwitchCaseContainsUnconditionalExit
(
*
stmt
)
)
{
removeBreakStatements
=
true
;
+
+
iter
;
break
;
}
}
int
numElements
=
SkToInt
(
std
:
:
distance
(
startIter
iter
)
)
;
for
(
int
index
=
0
;
index
<
numElements
;
+
+
index
+
+
startIter
)
{
cases
[
index
]
=
std
:
:
move
(
(
*
startIter
)
-
>
as
<
SwitchCase
>
(
)
.
statement
(
)
)
;
}
cases
.
pop_back_n
(
cases
.
size
(
)
-
numElements
)
;
if
(
removeBreakStatements
)
{
remove_break_statements
(
cases
.
back
(
)
)
;
}
return
true
;
}
std
:
:
unique_ptr
<
Statement
>
SwitchStatement
:
:
Convert
(
const
Context
&
context
Position
pos
std
:
:
unique_ptr
<
Expression
>
value
ExpressionArray
caseValues
StatementArray
caseStatements
std
:
:
unique_ptr
<
SymbolTable
>
symbolTable
)
{
SkASSERT
(
caseValues
.
size
(
)
=
=
caseStatements
.
size
(
)
)
;
value
=
context
.
fTypes
.
fInt
-
>
coerceExpression
(
std
:
:
move
(
value
)
context
)
;
if
(
!
value
)
{
return
nullptr
;
}
StatementArray
cases
;
for
(
int
i
=
0
;
i
<
caseValues
.
size
(
)
;
+
+
i
)
{
if
(
caseValues
[
i
]
)
{
Position
casePos
=
caseValues
[
i
]
-
>
fPosition
;
std
:
:
unique_ptr
<
Expression
>
caseValue
=
value
-
>
type
(
)
.
coerceExpression
(
std
:
:
move
(
caseValues
[
i
]
)
context
)
;
if
(
!
caseValue
)
{
return
nullptr
;
}
SKSL_INT
intValue
;
if
(
!
ConstantFolder
:
:
GetConstantInt
(
*
caseValue
&
intValue
)
)
{
context
.
fErrors
-
>
error
(
casePos
"
case
value
must
be
a
constant
integer
"
)
;
return
nullptr
;
}
cases
.
push_back
(
SwitchCase
:
:
Make
(
casePos
intValue
std
:
:
move
(
caseStatements
[
i
]
)
)
)
;
}
else
{
cases
.
push_back
(
SwitchCase
:
:
MakeDefault
(
pos
std
:
:
move
(
caseStatements
[
i
]
)
)
)
;
}
}
TArray
<
const
SwitchCase
*
>
duplicateCases
=
find_duplicate_case_values
(
cases
)
;
if
(
!
duplicateCases
.
empty
(
)
)
{
for
(
const
SwitchCase
*
sc
:
duplicateCases
)
{
if
(
sc
-
>
isDefault
(
)
)
{
context
.
fErrors
-
>
error
(
sc
-
>
fPosition
"
duplicate
default
case
"
)
;
}
else
{
context
.
fErrors
-
>
error
(
sc
-
>
fPosition
"
duplicate
case
value
'
"
+
std
:
:
to_string
(
sc
-
>
value
(
)
)
+
"
'
"
)
;
}
}
return
nullptr
;
}
std
:
:
unique_ptr
<
Block
>
block
=
Transform
:
:
HoistSwitchVarDeclarationsAtTopLevel
(
context
cases
*
symbolTable
pos
)
;
std
:
:
unique_ptr
<
Statement
>
switchStmt
=
SwitchStatement
:
:
Make
(
context
pos
std
:
:
move
(
value
)
Block
:
:
MakeBlock
(
pos
std
:
:
move
(
cases
)
Block
:
:
Kind
:
:
kBracedScope
std
:
:
move
(
symbolTable
)
)
)
;
if
(
block
)
{
block
-
>
children
(
)
.
push_back
(
std
:
:
move
(
switchStmt
)
)
;
return
block
;
}
else
{
return
switchStmt
;
}
}
std
:
:
unique_ptr
<
Statement
>
SwitchStatement
:
:
Make
(
const
Context
&
context
Position
pos
std
:
:
unique_ptr
<
Expression
>
value
std
:
:
unique_ptr
<
Statement
>
caseBlock
)
{
const
StatementArray
&
cases
=
caseBlock
-
>
as
<
Block
>
(
)
.
children
(
)
;
SkASSERT
(
std
:
:
all_of
(
cases
.
begin
(
)
cases
.
end
(
)
[
&
]
(
const
std
:
:
unique_ptr
<
Statement
>
&
stmt
)
{
return
stmt
-
>
is
<
SwitchCase
>
(
)
;
}
)
)
;
SkASSERT
(
find_duplicate_case_values
(
cases
)
.
empty
(
)
)
;
if
(
context
.
fConfig
-
>
fSettings
.
fOptimize
)
{
SKSL_INT
switchValue
;
if
(
ConstantFolder
:
:
GetConstantInt
(
*
value
&
switchValue
)
)
{
SwitchCase
*
defaultCase
=
nullptr
;
SwitchCase
*
matchingCase
=
nullptr
;
for
(
const
std
:
:
unique_ptr
<
Statement
>
&
stmt
:
cases
)
{
SwitchCase
&
sc
=
stmt
-
>
as
<
SwitchCase
>
(
)
;
if
(
sc
.
isDefault
(
)
)
{
defaultCase
=
&
sc
;
continue
;
}
if
(
sc
.
value
(
)
=
=
switchValue
)
{
matchingCase
=
&
sc
;
break
;
}
}
if
(
!
matchingCase
)
{
if
(
!
defaultCase
)
{
caseBlock
-
>
as
<
Block
>
(
)
.
children
(
)
.
clear
(
)
;
return
caseBlock
;
}
matchingCase
=
defaultCase
;
}
if
(
block_for_case
(
caseBlock
.
get
(
)
matchingCase
)
)
{
return
caseBlock
;
}
}
}
return
std
:
:
make_unique
<
SwitchStatement
>
(
pos
std
:
:
move
(
value
)
std
:
:
move
(
caseBlock
)
)
;
}
}
