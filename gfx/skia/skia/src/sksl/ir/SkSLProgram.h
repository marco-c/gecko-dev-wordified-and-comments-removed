#
ifndef
SKSL_PROGRAM
#
define
SKSL_PROGRAM
#
include
"
src
/
sksl
/
ir
/
SkSLType
.
h
"
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
define
SKSL_RTFLIP_NAME
"
u_skRTFlip
"
namespace
SkSL
{
class
Context
;
class
FunctionDeclaration
;
class
ModifiersPool
;
class
Pool
;
class
ProgramElement
;
class
ProgramUsage
;
class
SymbolTable
;
struct
ProgramConfig
;
struct
UniformInfo
{
struct
Uniform
{
std
:
:
string
fName
;
SkSL
:
:
Type
:
:
NumberKind
fKind
;
int
fColumns
;
int
fRows
;
int
fSlot
;
}
;
std
:
:
vector
<
Uniform
>
fUniforms
;
int
fUniformSlotCount
=
0
;
}
;
struct
Program
{
struct
Inputs
{
bool
fUseFlipRTUniform
=
false
;
bool
operator
=
=
(
const
Inputs
&
that
)
const
{
return
fUseFlipRTUniform
=
=
that
.
fUseFlipRTUniform
;
}
bool
operator
!
=
(
const
Inputs
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
}
;
Program
(
std
:
:
unique_ptr
<
std
:
:
string
>
source
std
:
:
unique_ptr
<
ProgramConfig
>
config
std
:
:
shared_ptr
<
Context
>
context
std
:
:
vector
<
std
:
:
unique_ptr
<
ProgramElement
>
>
elements
std
:
:
vector
<
const
ProgramElement
*
>
sharedElements
std
:
:
unique_ptr
<
ModifiersPool
>
modifiers
std
:
:
shared_ptr
<
SymbolTable
>
symbols
std
:
:
unique_ptr
<
Pool
>
pool
Inputs
inputs
)
;
~
Program
(
)
;
class
ElementsCollection
{
public
:
class
iterator
{
public
:
const
ProgramElement
*
operator
*
(
)
{
if
(
fShared
!
=
fSharedEnd
)
{
return
*
fShared
;
}
else
{
return
fOwned
-
>
get
(
)
;
}
}
iterator
&
operator
+
+
(
)
{
if
(
fShared
!
=
fSharedEnd
)
{
+
+
fShared
;
}
else
{
+
+
fOwned
;
}
return
*
this
;
}
bool
operator
=
=
(
const
iterator
&
other
)
const
{
return
fOwned
=
=
other
.
fOwned
&
&
fShared
=
=
other
.
fShared
;
}
bool
operator
!
=
(
const
iterator
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
private
:
using
Owned
=
std
:
:
vector
<
std
:
:
unique_ptr
<
ProgramElement
>
>
:
:
const_iterator
;
using
Shared
=
std
:
:
vector
<
const
ProgramElement
*
>
:
:
const_iterator
;
friend
class
ElementsCollection
;
iterator
(
Owned
owned
Owned
ownedEnd
Shared
shared
Shared
sharedEnd
)
:
fOwned
(
owned
)
fOwnedEnd
(
ownedEnd
)
fShared
(
shared
)
fSharedEnd
(
sharedEnd
)
{
}
Owned
fOwned
;
Owned
fOwnedEnd
;
Shared
fShared
;
Shared
fSharedEnd
;
}
;
iterator
begin
(
)
const
{
return
iterator
(
fProgram
.
fOwnedElements
.
begin
(
)
fProgram
.
fOwnedElements
.
end
(
)
fProgram
.
fSharedElements
.
begin
(
)
fProgram
.
fSharedElements
.
end
(
)
)
;
}
iterator
end
(
)
const
{
return
iterator
(
fProgram
.
fOwnedElements
.
end
(
)
fProgram
.
fOwnedElements
.
end
(
)
fProgram
.
fSharedElements
.
end
(
)
fProgram
.
fSharedElements
.
end
(
)
)
;
}
private
:
friend
struct
Program
;
ElementsCollection
(
const
Program
&
program
)
:
fProgram
(
program
)
{
}
const
Program
&
fProgram
;
}
;
ElementsCollection
elements
(
)
const
{
return
ElementsCollection
(
*
this
)
;
}
const
FunctionDeclaration
*
getFunction
(
const
char
*
functionName
)
const
;
std
:
:
unique_ptr
<
UniformInfo
>
getUniformInfo
(
)
;
std
:
:
string
description
(
)
const
;
const
ProgramUsage
*
usage
(
)
const
{
return
fUsage
.
get
(
)
;
}
std
:
:
unique_ptr
<
std
:
:
string
>
fSource
;
std
:
:
unique_ptr
<
ProgramConfig
>
fConfig
;
std
:
:
shared_ptr
<
Context
>
fContext
;
std
:
:
unique_ptr
<
ProgramUsage
>
fUsage
;
std
:
:
unique_ptr
<
ModifiersPool
>
fModifiers
;
std
:
:
shared_ptr
<
SymbolTable
>
fSymbols
;
std
:
:
unique_ptr
<
Pool
>
fPool
;
std
:
:
vector
<
std
:
:
unique_ptr
<
ProgramElement
>
>
fOwnedElements
;
std
:
:
vector
<
const
ProgramElement
*
>
fSharedElements
;
Inputs
fInputs
;
}
;
}
#
endif
