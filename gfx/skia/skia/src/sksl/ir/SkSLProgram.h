#
ifndef
SKSL_PROGRAM
#
define
SKSL_PROGRAM
#
include
"
src
/
sksl
/
ir
/
SkSLType
.
h
"
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
define
SKSL_RTFLIP_NAME
"
u_skRTFlip
"
namespace
SkSL
{
class
Context
;
class
FunctionDeclaration
;
class
Pool
;
class
ProgramElement
;
class
ProgramUsage
;
class
SymbolTable
;
struct
ProgramConfig
;
struct
UniformInfo
{
struct
Uniform
{
std
:
:
string
fName
;
SkSL
:
:
Type
:
:
NumberKind
fKind
;
int
fColumns
;
int
fRows
;
int
fSlot
;
}
;
std
:
:
vector
<
Uniform
>
fUniforms
;
int
fUniformSlotCount
=
0
;
}
;
struct
ProgramInterface
{
enum
RTFlip
:
uint8_t
{
kRTFlip_None
=
0b0000
'
0000
kRTFlip_FragCoord
=
0b0000
'
0001
kRTFlip_Clockwise
=
0b0000
'
0010
kRTFlip_Derivative
=
0b0000
'
0100
}
;
uint8_t
fRTFlipUniform
=
kRTFlip_None
;
bool
fUseLastFragColor
=
false
;
bool
fOutputSecondaryColor
=
false
;
bool
operator
=
=
(
const
ProgramInterface
&
that
)
const
{
return
fRTFlipUniform
=
=
that
.
fRTFlipUniform
&
&
fUseLastFragColor
=
=
that
.
fUseLastFragColor
&
&
fOutputSecondaryColor
=
=
that
.
fOutputSecondaryColor
;
}
bool
operator
!
=
(
const
ProgramInterface
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
}
;
struct
Program
{
Program
(
std
:
:
unique_ptr
<
std
:
:
string
>
source
std
:
:
unique_ptr
<
ProgramConfig
>
config
std
:
:
shared_ptr
<
Context
>
context
std
:
:
vector
<
std
:
:
unique_ptr
<
ProgramElement
>
>
elements
std
:
:
unique_ptr
<
SymbolTable
>
symbols
std
:
:
unique_ptr
<
Pool
>
pool
)
;
~
Program
(
)
;
class
ElementsCollection
{
public
:
class
iterator
{
public
:
const
ProgramElement
*
operator
*
(
)
{
if
(
fShared
!
=
fSharedEnd
)
{
return
*
fShared
;
}
else
{
return
fOwned
-
>
get
(
)
;
}
}
iterator
&
operator
+
+
(
)
{
if
(
fShared
!
=
fSharedEnd
)
{
+
+
fShared
;
}
else
{
+
+
fOwned
;
}
return
*
this
;
}
bool
operator
=
=
(
const
iterator
&
other
)
const
{
return
fOwned
=
=
other
.
fOwned
&
&
fShared
=
=
other
.
fShared
;
}
bool
operator
!
=
(
const
iterator
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
private
:
using
Owned
=
std
:
:
vector
<
std
:
:
unique_ptr
<
ProgramElement
>
>
:
:
const_iterator
;
using
Shared
=
std
:
:
vector
<
const
ProgramElement
*
>
:
:
const_iterator
;
friend
class
ElementsCollection
;
iterator
(
Owned
owned
Owned
ownedEnd
Shared
shared
Shared
sharedEnd
)
:
fOwned
(
owned
)
fOwnedEnd
(
ownedEnd
)
fShared
(
shared
)
fSharedEnd
(
sharedEnd
)
{
}
Owned
fOwned
;
Owned
fOwnedEnd
;
Shared
fShared
;
Shared
fSharedEnd
;
}
;
iterator
begin
(
)
const
{
return
iterator
(
fProgram
.
fOwnedElements
.
begin
(
)
fProgram
.
fOwnedElements
.
end
(
)
fProgram
.
fSharedElements
.
begin
(
)
fProgram
.
fSharedElements
.
end
(
)
)
;
}
iterator
end
(
)
const
{
return
iterator
(
fProgram
.
fOwnedElements
.
end
(
)
fProgram
.
fOwnedElements
.
end
(
)
fProgram
.
fSharedElements
.
end
(
)
fProgram
.
fSharedElements
.
end
(
)
)
;
}
private
:
friend
struct
Program
;
ElementsCollection
(
const
Program
&
program
)
:
fProgram
(
program
)
{
}
const
Program
&
fProgram
;
}
;
ElementsCollection
elements
(
)
const
{
return
ElementsCollection
(
*
this
)
;
}
const
FunctionDeclaration
*
getFunction
(
const
char
*
functionName
)
const
;
std
:
:
string
description
(
)
const
;
const
ProgramUsage
*
usage
(
)
const
{
return
fUsage
.
get
(
)
;
}
std
:
:
unique_ptr
<
std
:
:
string
>
fSource
;
std
:
:
unique_ptr
<
ProgramConfig
>
fConfig
;
std
:
:
shared_ptr
<
Context
>
fContext
;
std
:
:
unique_ptr
<
ProgramUsage
>
fUsage
;
std
:
:
unique_ptr
<
SymbolTable
>
fSymbols
;
std
:
:
unique_ptr
<
Pool
>
fPool
;
std
:
:
vector
<
std
:
:
unique_ptr
<
ProgramElement
>
>
fOwnedElements
;
std
:
:
vector
<
const
ProgramElement
*
>
fSharedElements
;
ProgramInterface
fInterface
;
using
Interface
=
ProgramInterface
;
}
;
}
#
endif
