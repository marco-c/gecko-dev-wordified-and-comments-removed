#
ifndef
SKSL_PROGRAM
#
define
SKSL_PROGRAM
#
include
<
vector
>
#
include
<
memory
>
#
include
"
SkSLBoolLiteral
.
h
"
#
include
"
SkSLExpression
.
h
"
#
include
"
SkSLIntLiteral
.
h
"
#
include
"
SkSLModifiers
.
h
"
#
include
"
SkSLProgramElement
.
h
"
#
include
"
SkSLSymbolTable
.
h
"
#
define
SKSL_RTHEIGHT_NAME
"
u_skRTHeight
"
namespace
SkSL
{
class
Context
;
struct
Program
{
struct
Settings
{
struct
Value
{
Value
(
bool
b
)
:
fKind
(
kBool_Kind
)
fValue
(
b
)
{
}
Value
(
int
i
)
:
fKind
(
kInt_Kind
)
fValue
(
i
)
{
}
std
:
:
unique_ptr
<
Expression
>
literal
(
const
Context
&
context
int
offset
)
const
{
switch
(
fKind
)
{
case
Program
:
:
Settings
:
:
Value
:
:
kBool_Kind
:
return
std
:
:
unique_ptr
<
Expression
>
(
new
BoolLiteral
(
context
offset
fValue
)
)
;
case
Program
:
:
Settings
:
:
Value
:
:
kInt_Kind
:
return
std
:
:
unique_ptr
<
Expression
>
(
new
IntLiteral
(
context
offset
fValue
)
)
;
default
:
ASSERT
(
false
)
;
return
nullptr
;
}
}
enum
{
kBool_Kind
kInt_Kind
}
fKind
;
int
fValue
;
}
;
#
ifdef
SKSL_STANDALONE
const
StandaloneShaderCaps
*
fCaps
=
&
standaloneCaps
;
#
else
const
GrShaderCaps
*
fCaps
=
nullptr
;
#
endif
bool
fFlipY
=
false
;
bool
fReplaceSettings
=
true
;
bool
fForceHighPrecision
=
false
;
bool
fSharpenTextures
=
false
;
std
:
:
unordered_map
<
String
Value
>
fArgs
;
}
;
struct
Inputs
{
bool
fRTHeight
;
bool
fFlipY
;
void
reset
(
)
{
fRTHeight
=
false
;
fFlipY
=
false
;
}
bool
isEmpty
(
)
{
return
!
fRTHeight
&
&
!
fFlipY
;
}
}
;
enum
Kind
{
kFragment_Kind
kVertex_Kind
kGeometry_Kind
kFragmentProcessor_Kind
}
;
Program
(
Kind
kind
std
:
:
unique_ptr
<
String
>
source
Settings
settings
Context
*
context
std
:
:
vector
<
std
:
:
unique_ptr
<
ProgramElement
>
>
elements
std
:
:
shared_ptr
<
SymbolTable
>
symbols
Inputs
inputs
)
:
fKind
(
kind
)
fSource
(
std
:
:
move
(
source
)
)
fSettings
(
settings
)
fContext
(
context
)
fSymbols
(
symbols
)
fElements
(
std
:
:
move
(
elements
)
)
fInputs
(
inputs
)
{
}
Kind
fKind
;
std
:
:
unique_ptr
<
String
>
fSource
;
Settings
fSettings
;
Context
*
fContext
;
std
:
:
shared_ptr
<
SymbolTable
>
fSymbols
;
std
:
:
vector
<
std
:
:
unique_ptr
<
ProgramElement
>
>
fElements
;
Inputs
fInputs
;
}
;
}
#
endif
