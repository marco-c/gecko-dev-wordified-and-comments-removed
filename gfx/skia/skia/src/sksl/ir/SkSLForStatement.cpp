#
include
"
src
/
sksl
/
ir
/
SkSLForStatement
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
SkSLDefines
.
h
"
#
include
"
include
/
sksl
/
SkSLErrorReporter
.
h
"
#
include
"
src
/
sksl
/
SkSLAnalysis
.
h
"
#
include
"
src
/
sksl
/
SkSLBuiltinTypes
.
h
"
#
include
"
src
/
sksl
/
SkSLContext
.
h
"
#
include
"
src
/
sksl
/
SkSLProgramSettings
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLBlock
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLExpressionStatement
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLNop
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLSymbolTable
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLType
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLVarDeclarations
.
h
"
namespace
SkSL
{
static
bool
is_vardecl_block_initializer
(
const
Statement
*
stmt
)
{
if
(
!
stmt
)
{
return
false
;
}
if
(
!
stmt
-
>
is
<
SkSL
:
:
Block
>
(
)
)
{
return
false
;
}
const
SkSL
:
:
Block
&
b
=
stmt
-
>
as
<
SkSL
:
:
Block
>
(
)
;
if
(
b
.
isScope
(
)
)
{
return
false
;
}
for
(
const
auto
&
child
:
b
.
children
(
)
)
{
if
(
!
child
-
>
is
<
SkSL
:
:
VarDeclaration
>
(
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
is_simple_initializer
(
const
Statement
*
stmt
)
{
return
!
stmt
|
|
stmt
-
>
isEmpty
(
)
|
|
stmt
-
>
is
<
SkSL
:
:
VarDeclaration
>
(
)
|
|
stmt
-
>
is
<
SkSL
:
:
ExpressionStatement
>
(
)
;
}
std
:
:
unique_ptr
<
Statement
>
ForStatement
:
:
clone
(
)
const
{
std
:
:
unique_ptr
<
LoopUnrollInfo
>
unrollInfo
;
if
(
fUnrollInfo
)
{
unrollInfo
=
std
:
:
make_unique
<
LoopUnrollInfo
>
(
*
fUnrollInfo
)
;
}
return
std
:
:
make_unique
<
ForStatement
>
(
fPosition
fForLoopPositions
this
-
>
initializer
(
)
?
this
-
>
initializer
(
)
-
>
clone
(
)
:
nullptr
this
-
>
test
(
)
?
this
-
>
test
(
)
-
>
clone
(
)
:
nullptr
this
-
>
next
(
)
?
this
-
>
next
(
)
-
>
clone
(
)
:
nullptr
this
-
>
statement
(
)
-
>
clone
(
)
std
:
:
move
(
unrollInfo
)
SymbolTable
:
:
WrapIfBuiltin
(
this
-
>
symbols
(
)
)
)
;
}
std
:
:
string
ForStatement
:
:
description
(
)
const
{
std
:
:
string
result
(
"
for
(
"
)
;
if
(
this
-
>
initializer
(
)
)
{
result
+
=
this
-
>
initializer
(
)
-
>
description
(
)
;
}
else
{
result
+
=
"
;
"
;
}
result
+
=
"
"
;
if
(
this
-
>
test
(
)
)
{
result
+
=
this
-
>
test
(
)
-
>
description
(
)
;
}
result
+
=
"
;
"
;
if
(
this
-
>
next
(
)
)
{
result
+
=
this
-
>
next
(
)
-
>
description
(
)
;
}
result
+
=
"
)
"
+
this
-
>
statement
(
)
-
>
description
(
)
;
return
result
;
}
std
:
:
unique_ptr
<
Statement
>
ForStatement
:
:
Convert
(
const
Context
&
context
Position
pos
ForLoopPositions
positions
std
:
:
unique_ptr
<
Statement
>
initializer
std
:
:
unique_ptr
<
Expression
>
test
std
:
:
unique_ptr
<
Expression
>
next
std
:
:
unique_ptr
<
Statement
>
statement
std
:
:
shared_ptr
<
SymbolTable
>
symbolTable
)
{
bool
isSimpleInitializer
=
is_simple_initializer
(
initializer
.
get
(
)
)
;
bool
isVardeclBlockInitializer
=
!
isSimpleInitializer
&
&
is_vardecl_block_initializer
(
initializer
.
get
(
)
)
;
if
(
!
isSimpleInitializer
&
&
!
isVardeclBlockInitializer
)
{
context
.
fErrors
-
>
error
(
initializer
-
>
fPosition
"
invalid
for
loop
initializer
"
)
;
return
nullptr
;
}
if
(
test
)
{
test
=
context
.
fTypes
.
fBool
-
>
coerceExpression
(
std
:
:
move
(
test
)
context
)
;
if
(
!
test
)
{
return
nullptr
;
}
}
if
(
next
&
&
next
-
>
isIncomplete
(
context
)
)
{
return
nullptr
;
}
std
:
:
unique_ptr
<
LoopUnrollInfo
>
unrollInfo
;
if
(
context
.
fConfig
-
>
strictES2Mode
(
)
)
{
unrollInfo
=
Analysis
:
:
GetLoopUnrollInfo
(
pos
positions
initializer
.
get
(
)
test
.
get
(
)
next
.
get
(
)
statement
.
get
(
)
context
.
fErrors
)
;
if
(
!
unrollInfo
)
{
return
nullptr
;
}
}
else
{
unrollInfo
=
Analysis
:
:
GetLoopUnrollInfo
(
pos
positions
initializer
.
get
(
)
test
.
get
(
)
next
.
get
(
)
statement
.
get
(
)
nullptr
)
;
}
if
(
Analysis
:
:
DetectVarDeclarationWithoutScope
(
*
statement
context
.
fErrors
)
)
{
return
nullptr
;
}
if
(
isVardeclBlockInitializer
)
{
StatementArray
scope
;
scope
.
push_back
(
std
:
:
move
(
initializer
)
)
;
scope
.
push_back
(
ForStatement
:
:
Make
(
context
pos
positions
nullptr
std
:
:
move
(
test
)
std
:
:
move
(
next
)
std
:
:
move
(
statement
)
std
:
:
move
(
unrollInfo
)
nullptr
)
)
;
return
Block
:
:
Make
(
pos
std
:
:
move
(
scope
)
Block
:
:
Kind
:
:
kBracedScope
std
:
:
move
(
symbolTable
)
)
;
}
return
ForStatement
:
:
Make
(
context
pos
positions
std
:
:
move
(
initializer
)
std
:
:
move
(
test
)
std
:
:
move
(
next
)
std
:
:
move
(
statement
)
std
:
:
move
(
unrollInfo
)
std
:
:
move
(
symbolTable
)
)
;
}
std
:
:
unique_ptr
<
Statement
>
ForStatement
:
:
ConvertWhile
(
const
Context
&
context
Position
pos
std
:
:
unique_ptr
<
Expression
>
test
std
:
:
unique_ptr
<
Statement
>
statement
std
:
:
shared_ptr
<
SymbolTable
>
symbolTable
)
{
if
(
context
.
fConfig
-
>
strictES2Mode
(
)
)
{
context
.
fErrors
-
>
error
(
pos
"
while
loops
are
not
supported
"
)
;
return
nullptr
;
}
return
ForStatement
:
:
Convert
(
context
pos
ForLoopPositions
(
)
nullptr
std
:
:
move
(
test
)
nullptr
std
:
:
move
(
statement
)
std
:
:
move
(
symbolTable
)
)
;
}
std
:
:
unique_ptr
<
Statement
>
ForStatement
:
:
Make
(
const
Context
&
context
Position
pos
ForLoopPositions
positions
std
:
:
unique_ptr
<
Statement
>
initializer
std
:
:
unique_ptr
<
Expression
>
test
std
:
:
unique_ptr
<
Expression
>
next
std
:
:
unique_ptr
<
Statement
>
statement
std
:
:
unique_ptr
<
LoopUnrollInfo
>
unrollInfo
std
:
:
shared_ptr
<
SymbolTable
>
symbolTable
)
{
SkASSERT
(
is_simple_initializer
(
initializer
.
get
(
)
)
|
|
is_vardecl_block_initializer
(
initializer
.
get
(
)
)
)
;
SkASSERT
(
!
test
|
|
test
-
>
type
(
)
.
matches
(
*
context
.
fTypes
.
fBool
)
)
;
SkASSERT
(
!
Analysis
:
:
DetectVarDeclarationWithoutScope
(
*
statement
)
)
;
SkASSERT
(
unrollInfo
|
|
!
context
.
fConfig
-
>
strictES2Mode
(
)
)
;
if
(
unrollInfo
)
{
if
(
unrollInfo
-
>
fCount
<
=
0
|
|
statement
-
>
isEmpty
(
)
)
{
return
Nop
:
:
Make
(
)
;
}
}
return
std
:
:
make_unique
<
ForStatement
>
(
pos
positions
std
:
:
move
(
initializer
)
std
:
:
move
(
test
)
std
:
:
move
(
next
)
std
:
:
move
(
statement
)
std
:
:
move
(
unrollInfo
)
std
:
:
move
(
symbolTable
)
)
;
}
}
