#
ifndef
SKIASL_TYPE
#
define
SKIASL_TYPE
#
include
"
SkSLModifiers
.
h
"
#
include
"
SkSLSymbol
.
h
"
#
include
"
.
.
/
SkSLPosition
.
h
"
#
include
"
.
.
/
SkSLUtil
.
h
"
#
include
"
.
.
/
spirv
.
h
"
#
include
<
vector
>
#
include
<
memory
>
namespace
SkSL
{
class
Context
;
class
Type
:
public
Symbol
{
public
:
struct
Field
{
Field
(
Modifiers
modifiers
std
:
:
string
name
const
Type
*
type
)
:
fModifiers
(
modifiers
)
fName
(
std
:
:
move
(
name
)
)
fType
(
std
:
:
move
(
type
)
)
{
}
const
std
:
:
string
description
(
)
const
{
return
fType
-
>
description
(
)
+
"
"
+
fName
+
"
;
"
;
}
Modifiers
fModifiers
;
std
:
:
string
fName
;
const
Type
*
fType
;
}
;
enum
Kind
{
kScalar_Kind
kVector_Kind
kMatrix_Kind
kArray_Kind
kStruct_Kind
kGeneric_Kind
kSampler_Kind
kOther_Kind
}
;
Type
(
std
:
:
string
name
)
:
INHERITED
(
Position
(
)
kType_Kind
std
:
:
move
(
name
)
)
fTypeKind
(
kOther_Kind
)
{
}
Type
(
std
:
:
string
name
std
:
:
vector
<
const
Type
*
>
types
)
:
INHERITED
(
Position
(
)
kType_Kind
std
:
:
move
(
name
)
)
fTypeKind
(
kGeneric_Kind
)
fCoercibleTypes
(
std
:
:
move
(
types
)
)
{
ASSERT
(
fCoercibleTypes
.
size
(
)
=
=
4
)
;
}
Type
(
std
:
:
string
name
std
:
:
vector
<
Field
>
fields
)
:
INHERITED
(
Position
(
)
kType_Kind
std
:
:
move
(
name
)
)
fTypeKind
(
kStruct_Kind
)
fFields
(
std
:
:
move
(
fields
)
)
{
}
Type
(
std
:
:
string
name
bool
isNumber
)
:
INHERITED
(
Position
(
)
kType_Kind
std
:
:
move
(
name
)
)
fTypeKind
(
kScalar_Kind
)
fIsNumber
(
isNumber
)
fColumns
(
1
)
fRows
(
1
)
{
}
Type
(
std
:
:
string
name
bool
isNumber
std
:
:
vector
<
const
Type
*
>
coercibleTypes
)
:
INHERITED
(
Position
(
)
kType_Kind
std
:
:
move
(
name
)
)
fTypeKind
(
kScalar_Kind
)
fIsNumber
(
isNumber
)
fCoercibleTypes
(
std
:
:
move
(
coercibleTypes
)
)
fColumns
(
1
)
fRows
(
1
)
{
}
Type
(
std
:
:
string
name
const
Type
&
componentType
int
columns
)
:
Type
(
name
kVector_Kind
componentType
columns
)
{
}
Type
(
std
:
:
string
name
Kind
kind
const
Type
&
componentType
int
columns
)
:
INHERITED
(
Position
(
)
kType_Kind
std
:
:
move
(
name
)
)
fTypeKind
(
kind
)
fComponentType
(
&
componentType
)
fColumns
(
columns
)
fRows
(
1
)
fDimensions
(
SpvDim1D
)
{
}
Type
(
std
:
:
string
name
const
Type
&
componentType
int
columns
int
rows
)
:
INHERITED
(
Position
(
)
kType_Kind
std
:
:
move
(
name
)
)
fTypeKind
(
kMatrix_Kind
)
fComponentType
(
&
componentType
)
fColumns
(
columns
)
fRows
(
rows
)
fDimensions
(
SpvDim1D
)
{
}
Type
(
std
:
:
string
name
SpvDim_
dimensions
bool
isDepth
bool
isArrayed
bool
isMultisampled
bool
isSampled
)
:
INHERITED
(
Position
(
)
kType_Kind
std
:
:
move
(
name
)
)
fTypeKind
(
kSampler_Kind
)
fDimensions
(
dimensions
)
fIsDepth
(
isDepth
)
fIsArrayed
(
isArrayed
)
fIsMultisampled
(
isMultisampled
)
fIsSampled
(
isSampled
)
{
}
std
:
:
string
name
(
)
const
{
return
fName
;
}
std
:
:
string
description
(
)
const
override
{
return
fName
;
}
bool
operator
=
=
(
const
Type
&
other
)
const
{
return
fName
=
=
other
.
fName
;
}
bool
operator
!
=
(
const
Type
&
other
)
const
{
return
fName
!
=
other
.
fName
;
}
Kind
kind
(
)
const
{
return
fTypeKind
;
}
bool
isNumber
(
)
const
{
return
fIsNumber
;
}
bool
canCoerceTo
(
const
Type
&
other
)
const
{
int
cost
;
return
determineCoercionCost
(
other
&
cost
)
;
}
bool
determineCoercionCost
(
const
Type
&
other
int
*
outCost
)
const
;
const
Type
&
componentType
(
)
const
{
ASSERT
(
fComponentType
)
;
return
*
fComponentType
;
}
int
columns
(
)
const
{
ASSERT
(
fTypeKind
=
=
kScalar_Kind
|
|
fTypeKind
=
=
kVector_Kind
|
|
fTypeKind
=
=
kMatrix_Kind
|
|
fTypeKind
=
=
kArray_Kind
)
;
return
fColumns
;
}
int
rows
(
)
const
{
ASSERT
(
fRows
>
0
)
;
return
fRows
;
}
const
std
:
:
vector
<
Field
>
&
fields
(
)
const
{
ASSERT
(
fTypeKind
=
=
kStruct_Kind
)
;
return
fFields
;
}
const
std
:
:
vector
<
const
Type
*
>
&
coercibleTypes
(
)
const
{
ASSERT
(
fCoercibleTypes
.
size
(
)
>
0
)
;
return
fCoercibleTypes
;
}
int
dimensions
(
)
const
{
ASSERT
(
fTypeKind
=
=
kSampler_Kind
)
;
return
fDimensions
;
}
bool
isDepth
(
)
const
{
ASSERT
(
fTypeKind
=
=
kSampler_Kind
)
;
return
fIsDepth
;
}
bool
isArrayed
(
)
const
{
ASSERT
(
fTypeKind
=
=
kSampler_Kind
)
;
return
fIsArrayed
;
}
bool
isMultisampled
(
)
const
{
ASSERT
(
fTypeKind
=
=
kSampler_Kind
)
;
return
fIsMultisampled
;
}
bool
isSampled
(
)
const
{
ASSERT
(
fTypeKind
=
=
kSampler_Kind
)
;
return
fIsSampled
;
}
static
size_t
vector_alignment
(
size_t
componentSize
int
columns
)
{
return
componentSize
*
(
columns
+
columns
%
2
)
;
}
size_t
alignment
(
)
const
{
switch
(
fTypeKind
)
{
case
kScalar_Kind
:
return
this
-
>
size
(
)
;
case
kVector_Kind
:
return
vector_alignment
(
fComponentType
-
>
size
(
)
fColumns
)
;
case
kMatrix_Kind
:
return
(
vector_alignment
(
fComponentType
-
>
size
(
)
fRows
)
+
15
)
&
~
15
;
case
kArray_Kind
:
return
(
fComponentType
-
>
alignment
(
)
+
15
)
&
~
15
;
case
kStruct_Kind
:
{
size_t
result
=
16
;
for
(
size_t
i
=
0
;
i
<
fFields
.
size
(
)
;
i
+
+
)
{
size_t
alignment
=
fFields
[
i
]
.
fType
-
>
alignment
(
)
;
if
(
alignment
>
result
)
{
result
=
alignment
;
}
}
}
default
:
ABORT
(
(
"
cannot
determine
size
of
type
"
+
fName
)
.
c_str
(
)
)
;
}
}
size_t
stride
(
)
const
{
switch
(
fTypeKind
)
{
case
kMatrix_Kind
:
case
kArray_Kind
:
return
this
-
>
alignment
(
)
;
default
:
ABORT
(
"
type
does
not
have
a
stride
"
)
;
}
}
size_t
size
(
)
const
{
switch
(
fTypeKind
)
{
case
kScalar_Kind
:
return
4
;
case
kVector_Kind
:
return
fColumns
*
fComponentType
-
>
size
(
)
;
case
kMatrix_Kind
:
return
vector_alignment
(
fComponentType
-
>
size
(
)
fRows
)
*
fColumns
;
case
kArray_Kind
:
return
fColumns
*
this
-
>
stride
(
)
;
case
kStruct_Kind
:
{
size_t
total
=
0
;
for
(
size_t
i
=
0
;
i
<
fFields
.
size
(
)
;
i
+
+
)
{
size_t
alignment
=
fFields
[
i
]
.
fType
-
>
alignment
(
)
;
if
(
total
%
alignment
!
=
0
)
{
total
+
=
alignment
-
total
%
alignment
;
}
ASSERT
(
false
)
;
ASSERT
(
total
%
alignment
=
=
0
)
;
total
+
=
fFields
[
i
]
.
fType
-
>
size
(
)
;
}
return
total
;
}
default
:
ABORT
(
(
"
cannot
determine
size
of
type
"
+
fName
)
.
c_str
(
)
)
;
}
}
const
Type
&
toCompound
(
const
Context
&
context
int
columns
int
rows
)
const
;
private
:
typedef
Symbol
INHERITED
;
const
Kind
fTypeKind
;
const
bool
fIsNumber
=
false
;
const
Type
*
fComponentType
=
nullptr
;
const
std
:
:
vector
<
const
Type
*
>
fCoercibleTypes
;
const
int
fColumns
=
-
1
;
const
int
fRows
=
-
1
;
const
std
:
:
vector
<
Field
>
fFields
;
const
SpvDim_
fDimensions
=
SpvDim1D
;
const
bool
fIsDepth
=
false
;
const
bool
fIsArrayed
=
false
;
const
bool
fIsMultisampled
=
false
;
const
bool
fIsSampled
=
false
;
}
;
}
#
endif
