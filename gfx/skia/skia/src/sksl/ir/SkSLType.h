#
ifndef
SKIASL_TYPE
#
define
SKIASL_TYPE
#
include
"
src
/
sksl
/
SkSLPosition
.
h
"
#
include
"
src
/
sksl
/
SkSLUtil
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLModifiers
.
h
"
#
include
"
src
/
sksl
/
ir
/
SkSLSymbol
.
h
"
#
include
"
src
/
sksl
/
spirv
.
h
"
#
include
<
climits
>
#
include
<
vector
>
#
include
<
memory
>
namespace
SkSL
{
class
Context
;
class
Type
:
public
Symbol
{
public
:
struct
Field
{
Field
(
Modifiers
modifiers
StringFragment
name
const
Type
*
type
)
:
fModifiers
(
modifiers
)
fName
(
name
)
fType
(
std
:
:
move
(
type
)
)
{
}
const
String
description
(
)
const
{
return
fType
-
>
description
(
)
+
"
"
+
fName
+
"
;
"
;
}
Modifiers
fModifiers
;
StringFragment
fName
;
const
Type
*
fType
;
}
;
enum
Kind
{
kArray_Kind
kEnum_Kind
kGeneric_Kind
kNullable_Kind
kMatrix_Kind
kOther_Kind
kSampler_Kind
kSeparateSampler_Kind
kScalar_Kind
kStruct_Kind
kTexture_Kind
kVector_Kind
}
;
enum
NumberKind
{
kFloat_NumberKind
kSigned_NumberKind
kUnsigned_NumberKind
kNonnumeric_NumberKind
}
;
Type
(
const
char
*
name
)
:
INHERITED
(
-
1
kType_Kind
StringFragment
(
)
)
fNameString
(
name
)
fTypeKind
(
kOther_Kind
)
fNumberKind
(
kNonnumeric_NumberKind
)
{
fName
.
fChars
=
fNameString
.
c_str
(
)
;
fName
.
fLength
=
fNameString
.
size
(
)
;
}
Type
(
const
char
*
name
std
:
:
vector
<
Field
>
fields
)
:
INHERITED
(
-
1
kType_Kind
StringFragment
(
)
)
fNameString
(
name
)
fTypeKind
(
kOther_Kind
)
fNumberKind
(
kNonnumeric_NumberKind
)
fFields
(
std
:
:
move
(
fields
)
)
{
fName
.
fChars
=
fNameString
.
c_str
(
)
;
fName
.
fLength
=
fNameString
.
size
(
)
;
}
Type
(
String
name
Kind
kind
)
:
INHERITED
(
-
1
kType_Kind
StringFragment
(
)
)
fNameString
(
std
:
:
move
(
name
)
)
fTypeKind
(
kind
)
fNumberKind
(
kNonnumeric_NumberKind
)
{
fName
.
fChars
=
fNameString
.
c_str
(
)
;
fName
.
fLength
=
fNameString
.
size
(
)
;
}
Type
(
const
char
*
name
std
:
:
vector
<
const
Type
*
>
types
)
:
INHERITED
(
-
1
kType_Kind
StringFragment
(
)
)
fNameString
(
name
)
fTypeKind
(
kGeneric_Kind
)
fNumberKind
(
kNonnumeric_NumberKind
)
fCoercibleTypes
(
std
:
:
move
(
types
)
)
{
fName
.
fChars
=
fNameString
.
c_str
(
)
;
fName
.
fLength
=
fNameString
.
size
(
)
;
}
Type
(
int
offset
String
name
std
:
:
vector
<
Field
>
fields
)
:
INHERITED
(
offset
kType_Kind
StringFragment
(
)
)
fNameString
(
std
:
:
move
(
name
)
)
fTypeKind
(
kStruct_Kind
)
fNumberKind
(
kNonnumeric_NumberKind
)
fFields
(
std
:
:
move
(
fields
)
)
{
fName
.
fChars
=
fNameString
.
c_str
(
)
;
fName
.
fLength
=
fNameString
.
size
(
)
;
}
Type
(
const
char
*
name
NumberKind
numberKind
int
priority
bool
highPrecision
=
false
)
:
INHERITED
(
-
1
kType_Kind
StringFragment
(
)
)
fNameString
(
name
)
fTypeKind
(
kScalar_Kind
)
fNumberKind
(
numberKind
)
fPriority
(
priority
)
fColumns
(
1
)
fRows
(
1
)
fHighPrecision
(
highPrecision
)
{
fName
.
fChars
=
fNameString
.
c_str
(
)
;
fName
.
fLength
=
fNameString
.
size
(
)
;
}
Type
(
const
char
*
name
NumberKind
numberKind
int
priority
std
:
:
vector
<
const
Type
*
>
coercibleTypes
)
:
INHERITED
(
-
1
kType_Kind
StringFragment
(
)
)
fNameString
(
name
)
fTypeKind
(
kScalar_Kind
)
fNumberKind
(
numberKind
)
fPriority
(
priority
)
fCoercibleTypes
(
std
:
:
move
(
coercibleTypes
)
)
fColumns
(
1
)
fRows
(
1
)
{
fName
.
fChars
=
fNameString
.
c_str
(
)
;
fName
.
fLength
=
fNameString
.
size
(
)
;
}
Type
(
String
name
Kind
kind
const
Type
&
componentType
)
:
INHERITED
(
-
1
kType_Kind
StringFragment
(
)
)
fNameString
(
std
:
:
move
(
name
)
)
fTypeKind
(
kind
)
fNumberKind
(
kNonnumeric_NumberKind
)
fComponentType
(
&
componentType
)
fColumns
(
1
)
fRows
(
1
)
fDimensions
(
SpvDim1D
)
{
fName
.
fChars
=
fNameString
.
c_str
(
)
;
fName
.
fLength
=
fNameString
.
size
(
)
;
}
Type
(
const
char
*
name
const
Type
&
componentType
int
columns
)
:
Type
(
name
kVector_Kind
componentType
columns
)
{
}
Type
(
String
name
Kind
kind
const
Type
&
componentType
int
columns
)
:
INHERITED
(
-
1
kType_Kind
StringFragment
(
)
)
fNameString
(
std
:
:
move
(
name
)
)
fTypeKind
(
kind
)
fNumberKind
(
kNonnumeric_NumberKind
)
fComponentType
(
&
componentType
)
fColumns
(
columns
)
fRows
(
1
)
fDimensions
(
SpvDim1D
)
{
fName
.
fChars
=
fNameString
.
c_str
(
)
;
fName
.
fLength
=
fNameString
.
size
(
)
;
}
Type
(
const
char
*
name
const
Type
&
componentType
int
columns
int
rows
)
:
INHERITED
(
-
1
kType_Kind
StringFragment
(
)
)
fNameString
(
name
)
fTypeKind
(
kMatrix_Kind
)
fNumberKind
(
kNonnumeric_NumberKind
)
fComponentType
(
&
componentType
)
fColumns
(
columns
)
fRows
(
rows
)
fDimensions
(
SpvDim1D
)
{
fName
.
fChars
=
fNameString
.
c_str
(
)
;
fName
.
fLength
=
fNameString
.
size
(
)
;
}
Type
(
const
char
*
name
SpvDim_
dimensions
bool
isDepth
bool
isArrayed
bool
isMultisampled
bool
isSampled
)
:
INHERITED
(
-
1
kType_Kind
StringFragment
(
)
)
fNameString
(
name
)
fTypeKind
(
kTexture_Kind
)
fNumberKind
(
kNonnumeric_NumberKind
)
fDimensions
(
dimensions
)
fIsDepth
(
isDepth
)
fIsArrayed
(
isArrayed
)
fIsMultisampled
(
isMultisampled
)
fIsSampled
(
isSampled
)
{
fName
.
fChars
=
fNameString
.
c_str
(
)
;
fName
.
fLength
=
fNameString
.
size
(
)
;
}
Type
(
const
char
*
name
const
Type
&
textureType
)
:
INHERITED
(
-
1
kType_Kind
StringFragment
(
)
)
fNameString
(
name
)
fTypeKind
(
kSampler_Kind
)
fNumberKind
(
kNonnumeric_NumberKind
)
fDimensions
(
textureType
.
dimensions
(
)
)
fIsDepth
(
textureType
.
isDepth
(
)
)
fIsArrayed
(
textureType
.
isArrayed
(
)
)
fIsMultisampled
(
textureType
.
isMultisampled
(
)
)
fIsSampled
(
textureType
.
isSampled
(
)
)
fTextureType
(
&
textureType
)
{
fName
.
fChars
=
fNameString
.
c_str
(
)
;
fName
.
fLength
=
fNameString
.
size
(
)
;
}
const
String
&
name
(
)
const
{
return
fNameString
;
}
String
description
(
)
const
override
{
if
(
fNameString
=
=
"
floatLiteral
"
)
{
return
"
float
"
;
}
if
(
fNameString
=
=
"
intLiteral
"
)
{
return
"
int
"
;
}
return
fNameString
;
}
bool
operator
=
=
(
const
Type
&
other
)
const
{
return
fName
=
=
other
.
fName
;
}
bool
operator
!
=
(
const
Type
&
other
)
const
{
return
fName
!
=
other
.
fName
;
}
Kind
kind
(
)
const
{
return
fTypeKind
;
}
bool
isNumber
(
)
const
{
return
fNumberKind
!
=
kNonnumeric_NumberKind
;
}
bool
isFloat
(
)
const
{
return
fNumberKind
=
=
kFloat_NumberKind
;
}
bool
isSigned
(
)
const
{
return
fNumberKind
=
=
kSigned_NumberKind
;
}
bool
isUnsigned
(
)
const
{
return
fNumberKind
=
=
kUnsigned_NumberKind
;
}
bool
isInteger
(
)
const
{
return
isSigned
(
)
|
|
isUnsigned
(
)
;
}
int
priority
(
)
const
{
return
fPriority
;
}
bool
canCoerceTo
(
const
Type
&
other
)
const
{
return
coercionCost
(
other
)
!
=
INT_MAX
;
}
int
coercionCost
(
const
Type
&
other
)
const
;
const
Type
&
componentType
(
)
const
{
SkASSERT
(
fComponentType
)
;
return
*
fComponentType
;
}
const
Type
&
textureType
(
)
const
{
SkASSERT
(
fTextureType
)
;
return
*
fTextureType
;
}
const
Type
&
nonnullable
(
)
const
{
if
(
fTypeKind
=
=
kNullable_Kind
)
{
return
this
-
>
componentType
(
)
;
}
return
*
this
;
}
int
columns
(
)
const
{
SkASSERT
(
fTypeKind
=
=
kScalar_Kind
|
|
fTypeKind
=
=
kVector_Kind
|
|
fTypeKind
=
=
kMatrix_Kind
|
|
fTypeKind
=
=
kArray_Kind
)
;
return
fColumns
;
}
int
rows
(
)
const
{
SkASSERT
(
fRows
>
0
)
;
return
fRows
;
}
const
std
:
:
vector
<
Field
>
&
fields
(
)
const
{
SkASSERT
(
fTypeKind
=
=
kStruct_Kind
|
|
fTypeKind
=
=
kOther_Kind
)
;
return
fFields
;
}
const
std
:
:
vector
<
const
Type
*
>
&
coercibleTypes
(
)
const
{
SkASSERT
(
fCoercibleTypes
.
size
(
)
>
0
)
;
return
fCoercibleTypes
;
}
SpvDim_
dimensions
(
)
const
{
SkASSERT
(
kSampler_Kind
=
=
fTypeKind
|
|
kTexture_Kind
=
=
fTypeKind
)
;
return
fDimensions
;
}
bool
isDepth
(
)
const
{
SkASSERT
(
kSampler_Kind
=
=
fTypeKind
|
|
kTexture_Kind
=
=
fTypeKind
)
;
return
fIsDepth
;
}
bool
isArrayed
(
)
const
{
SkASSERT
(
kSampler_Kind
=
=
fTypeKind
|
|
kTexture_Kind
=
=
fTypeKind
)
;
return
fIsArrayed
;
}
bool
isMultisampled
(
)
const
{
SkASSERT
(
kSampler_Kind
=
=
fTypeKind
|
|
kTexture_Kind
=
=
fTypeKind
)
;
return
fIsMultisampled
;
}
bool
isSampled
(
)
const
{
SkASSERT
(
kSampler_Kind
=
=
fTypeKind
|
|
kTexture_Kind
=
=
fTypeKind
)
;
return
fIsSampled
;
}
bool
highPrecision
(
)
const
{
if
(
fComponentType
)
{
return
fComponentType
-
>
highPrecision
(
)
;
}
return
fHighPrecision
;
}
const
Type
&
toCompound
(
const
Context
&
context
int
columns
int
rows
)
const
;
private
:
typedef
Symbol
INHERITED
;
String
fNameString
;
Kind
fTypeKind
;
NumberKind
fNumberKind
;
int
fPriority
=
-
1
;
const
Type
*
fComponentType
=
nullptr
;
std
:
:
vector
<
const
Type
*
>
fCoercibleTypes
;
int
fColumns
=
-
1
;
int
fRows
=
-
1
;
std
:
:
vector
<
Field
>
fFields
;
SpvDim_
fDimensions
=
SpvDim1D
;
bool
fIsDepth
=
false
;
bool
fIsArrayed
=
false
;
bool
fIsMultisampled
=
false
;
bool
fIsSampled
=
false
;
bool
fHighPrecision
=
false
;
const
Type
*
fTextureType
=
nullptr
;
}
;
}
#
endif
