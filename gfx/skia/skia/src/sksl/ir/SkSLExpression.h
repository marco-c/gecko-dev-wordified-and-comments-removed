#
ifndef
SKSL_EXPRESSION
#
define
SKSL_EXPRESSION
#
include
"
SkSLType
.
h
"
#
include
"
SkSLVariable
.
h
"
#
include
<
unordered_map
>
namespace
SkSL
{
struct
Expression
;
class
IRGenerator
;
typedef
std
:
:
unordered_map
<
const
Variable
*
std
:
:
unique_ptr
<
Expression
>
*
>
DefinitionMap
;
struct
Expression
:
public
IRNode
{
enum
Kind
{
kAppendStage_Kind
kBinary_Kind
kBoolLiteral_Kind
kConstructor_Kind
kIntLiteral_Kind
kFieldAccess_Kind
kFloatLiteral_Kind
kFunctionReference_Kind
kFunctionCall_Kind
kIndex_Kind
kPrefix_Kind
kPostfix_Kind
kSetting_Kind
kSwizzle_Kind
kVariableReference_Kind
kTernary_Kind
kTypeReference_Kind
kDefined_Kind
}
;
Expression
(
int
offset
Kind
kind
const
Type
&
type
)
:
INHERITED
(
offset
)
fKind
(
kind
)
fType
(
std
:
:
move
(
type
)
)
{
}
virtual
bool
isConstant
(
)
const
{
return
false
;
}
virtual
bool
compareConstant
(
const
Context
&
context
const
Expression
&
other
)
const
{
ABORT
(
"
cannot
call
compareConstant
on
this
type
"
)
;
}
virtual
int64_t
getConstantInt
(
)
const
{
ABORT
(
"
not
a
constant
int
"
)
;
}
virtual
double
getConstantFloat
(
)
const
{
ABORT
(
"
not
a
constant
float
"
)
;
}
virtual
bool
hasSideEffects
(
)
const
=
0
;
virtual
std
:
:
unique_ptr
<
Expression
>
constantPropagate
(
const
IRGenerator
&
irGenerator
const
DefinitionMap
&
definitions
)
{
return
nullptr
;
}
virtual
int
coercionCost
(
const
Type
&
target
)
const
{
return
fType
.
coercionCost
(
target
)
;
}
virtual
std
:
:
unique_ptr
<
Expression
>
clone
(
)
const
=
0
;
const
Kind
fKind
;
const
Type
&
fType
;
typedef
IRNode
INHERITED
;
}
;
}
#
endif
