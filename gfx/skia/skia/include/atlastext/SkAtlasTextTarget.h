#
ifndef
SkAtlasTextTarget_DEFINED
#
define
SkAtlasTextTarget_DEFINED
#
include
"
include
/
core
/
SkDeque
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
<
memory
>
class
SkAtlasTextContext
;
class
SkAtlasTextFont
;
class
SkMatrix
;
struct
SkPoint
;
class
SK_API
SkAtlasTextTarget
{
public
:
virtual
~
SkAtlasTextTarget
(
)
;
static
std
:
:
unique_ptr
<
SkAtlasTextTarget
>
Make
(
sk_sp
<
SkAtlasTextContext
>
int
width
int
height
void
*
handle
)
;
virtual
void
drawText
(
const
SkGlyphID
[
]
const
SkPoint
[
]
int
glyphCnt
uint32_t
color
const
SkAtlasTextFont
&
)
=
0
;
virtual
void
flush
(
)
=
0
;
int
width
(
)
const
{
return
fWidth
;
}
int
height
(
)
const
{
return
fHeight
;
}
void
*
handle
(
)
const
{
return
fHandle
;
}
SkAtlasTextContext
*
context
(
)
const
{
return
fContext
.
get
(
)
;
}
int
save
(
)
;
void
restore
(
)
;
void
restoreToCount
(
int
count
)
;
void
translate
(
SkScalar
dx
SkScalar
dy
)
;
void
scale
(
SkScalar
sx
SkScalar
sy
)
;
void
rotate
(
SkScalar
degrees
)
;
void
rotate
(
SkScalar
degrees
SkScalar
px
SkScalar
py
)
;
void
skew
(
SkScalar
sx
SkScalar
sy
)
;
void
concat
(
const
SkMatrix
&
matrix
)
;
protected
:
SkAtlasTextTarget
(
sk_sp
<
SkAtlasTextContext
>
int
width
int
height
void
*
handle
)
;
const
SkMatrix
&
ctm
(
)
const
{
return
*
static_cast
<
const
SkMatrix
*
>
(
fMatrixStack
.
back
(
)
)
;
}
void
*
const
fHandle
;
const
sk_sp
<
SkAtlasTextContext
>
fContext
;
const
int
fWidth
;
const
int
fHeight
;
private
:
SkDeque
fMatrixStack
;
int
fSaveCnt
;
SkMatrix
*
accessCTM
(
)
const
{
return
static_cast
<
SkMatrix
*
>
(
const_cast
<
void
*
>
(
fMatrixStack
.
back
(
)
)
)
;
}
SkAtlasTextTarget
(
)
=
delete
;
SkAtlasTextTarget
(
const
SkAtlasTextContext
&
)
=
delete
;
SkAtlasTextTarget
&
operator
=
(
const
SkAtlasTextContext
&
)
=
delete
;
}
;
#
endif
