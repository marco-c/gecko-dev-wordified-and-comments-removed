#
ifndef
SKSL_OPERATOR
#
define
SKSL_OPERATOR
#
include
<
cstdint
>
#
include
<
string_view
>
namespace
SkSL
{
class
Context
;
class
Type
;
enum
class
OperatorKind
:
uint8_t
{
PLUS
MINUS
STAR
SLASH
PERCENT
SHL
SHR
LOGICALNOT
LOGICALAND
LOGICALOR
LOGICALXOR
BITWISENOT
BITWISEAND
BITWISEOR
BITWISEXOR
EQ
EQEQ
NEQ
LT
GT
LTEQ
GTEQ
PLUSEQ
MINUSEQ
STAREQ
SLASHEQ
PERCENTEQ
SHLEQ
SHREQ
BITWISEANDEQ
BITWISEOREQ
BITWISEXOREQ
PLUSPLUS
MINUSMINUS
COMMA
}
;
enum
class
OperatorPrecedence
:
uint8_t
{
kParentheses
=
1
kPostfix
=
2
kPrefix
=
3
kMultiplicative
=
4
kAdditive
=
5
kShift
=
6
kRelational
=
7
kEquality
=
8
kBitwiseAnd
=
9
kBitwiseXor
=
10
kBitwiseOr
=
11
kLogicalAnd
=
12
kLogicalXor
=
13
kLogicalOr
=
14
kTernary
=
15
kAssignment
=
16
kSequence
=
17
kTopLevel
=
kSequence
}
;
class
Operator
{
public
:
using
Kind
=
OperatorKind
;
Operator
(
Kind
op
)
:
fKind
(
op
)
{
}
Kind
kind
(
)
const
{
return
fKind
;
}
bool
isEquality
(
)
const
{
return
fKind
=
=
Kind
:
:
EQEQ
|
|
fKind
=
=
Kind
:
:
NEQ
;
}
OperatorPrecedence
getBinaryPrecedence
(
)
const
;
const
char
*
operatorName
(
)
const
;
std
:
:
string_view
tightOperatorName
(
)
const
;
bool
isAssignment
(
)
const
;
Operator
removeAssignment
(
)
const
;
bool
isRelational
(
)
const
;
bool
isOnlyValidForIntegralTypes
(
)
const
;
bool
isValidForMatrixOrVector
(
)
const
;
bool
isAllowedInStrictES2Mode
(
)
const
{
return
!
this
-
>
isOnlyValidForIntegralTypes
(
)
;
}
bool
determineBinaryType
(
const
Context
&
context
const
Type
&
left
const
Type
&
right
const
Type
*
*
outLeftType
const
Type
*
*
outRightType
const
Type
*
*
outResultType
)
const
;
private
:
bool
isOperator
(
)
const
;
bool
isMatrixMultiply
(
const
Type
&
left
const
Type
&
right
)
const
;
Kind
fKind
;
}
;
}
#
endif
