#
ifndef
SkCodec_DEFINED
#
define
SkCodec_DEFINED
#
include
"
.
.
/
private
/
SkTemplates
.
h
"
#
include
"
SkColor
.
h
"
#
include
"
SkEncodedImageFormat
.
h
"
#
include
"
SkEncodedInfo
.
h
"
#
include
"
SkImageInfo
.
h
"
#
include
"
SkSize
.
h
"
#
include
"
SkStream
.
h
"
#
include
"
SkTypes
.
h
"
#
include
"
SkYUVSizeInfo
.
h
"
#
include
<
vector
>
class
SkColorSpace
;
class
SkColorSpaceXform
;
class
SkData
;
class
SkPngChunkReader
;
class
SkSampler
;
namespace
DM
{
class
CodecSrc
;
class
ColorCodecSrc
;
}
class
ColorCodecBench
;
class
SK_API
SkCodec
:
SkNoncopyable
{
public
:
static
size_t
MinBufferedBytesNeeded
(
)
;
static
SkCodec
*
NewFromStream
(
SkStream
*
SkPngChunkReader
*
=
NULL
)
;
static
SkCodec
*
NewFromData
(
sk_sp
<
SkData
>
SkPngChunkReader
*
=
NULL
)
;
static
SkCodec
*
NewFromData
(
SkData
*
data
SkPngChunkReader
*
reader
)
{
return
NewFromData
(
sk_ref_sp
(
data
)
reader
)
;
}
virtual
~
SkCodec
(
)
;
const
SkImageInfo
&
getInfo
(
)
const
{
return
fSrcInfo
;
}
const
SkEncodedInfo
&
getEncodedInfo
(
)
const
{
return
fEncodedInfo
;
}
enum
Origin
{
kTopLeft_Origin
=
1
kTopRight_Origin
=
2
kBottomRight_Origin
=
3
kBottomLeft_Origin
=
4
kLeftTop_Origin
=
5
kRightTop_Origin
=
6
kRightBottom_Origin
=
7
kLeftBottom_Origin
=
8
kDefault_Origin
=
kTopLeft_Origin
kLast_Origin
=
kLeftBottom_Origin
}
;
Origin
getOrigin
(
)
const
{
return
fOrigin
;
}
SkISize
getScaledDimensions
(
float
desiredScale
)
const
{
SkASSERT
(
desiredScale
>
0
.
0f
)
;
if
(
desiredScale
<
=
0
.
0f
)
{
return
SkISize
:
:
Make
(
0
0
)
;
}
if
(
desiredScale
>
=
1
.
0f
)
{
return
this
-
>
getInfo
(
)
.
dimensions
(
)
;
}
return
this
-
>
onGetScaledDimensions
(
desiredScale
)
;
}
bool
getValidSubset
(
SkIRect
*
desiredSubset
)
const
{
return
this
-
>
onGetValidSubset
(
desiredSubset
)
;
}
SkEncodedImageFormat
getEncodedFormat
(
)
const
{
return
this
-
>
onGetEncodedFormat
(
)
;
}
enum
Result
{
kSuccess
kIncompleteInput
kInvalidConversion
kInvalidScale
kInvalidParameters
kInvalidInput
kCouldNotRewind
kUnimplemented
}
;
enum
ZeroInitialized
{
kYes_ZeroInitialized
kNo_ZeroInitialized
}
;
struct
Options
{
Options
(
)
:
fZeroInitialized
(
kNo_ZeroInitialized
)
fSubset
(
nullptr
)
fFrameIndex
(
0
)
fHasPriorFrame
(
false
)
fPremulBehavior
(
SkTransferFunctionBehavior
:
:
kRespect
)
{
}
ZeroInitialized
fZeroInitialized
;
const
SkIRect
*
fSubset
;
size_t
fFrameIndex
;
bool
fHasPriorFrame
;
SkTransferFunctionBehavior
fPremulBehavior
;
}
;
Result
getPixels
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
const
Options
*
SkPMColor
ctable
[
]
int
*
ctableCount
)
;
Result
getPixels
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
)
;
bool
queryYUV8
(
SkYUVSizeInfo
*
sizeInfo
SkYUVColorSpace
*
colorSpace
)
const
{
if
(
nullptr
=
=
sizeInfo
)
{
return
false
;
}
return
this
-
>
onQueryYUV8
(
sizeInfo
colorSpace
)
;
}
Result
getYUV8Planes
(
const
SkYUVSizeInfo
&
sizeInfo
void
*
planes
[
3
]
)
{
if
(
nullptr
=
=
planes
|
|
nullptr
=
=
planes
[
0
]
|
|
nullptr
=
=
planes
[
1
]
|
|
nullptr
=
=
planes
[
2
]
)
{
return
kInvalidInput
;
}
if
(
!
this
-
>
rewindIfNeeded
(
)
)
{
return
kCouldNotRewind
;
}
return
this
-
>
onGetYUV8Planes
(
sizeInfo
planes
)
;
}
Result
startIncrementalDecode
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
rowBytes
const
SkCodec
:
:
Options
*
SkPMColor
*
ctable
int
*
ctableCount
)
;
Result
startIncrementalDecode
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
rowBytes
const
SkCodec
:
:
Options
*
options
)
{
return
this
-
>
startIncrementalDecode
(
dstInfo
dst
rowBytes
options
nullptr
nullptr
)
;
}
Result
startIncrementalDecode
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
rowBytes
)
{
return
this
-
>
startIncrementalDecode
(
dstInfo
dst
rowBytes
nullptr
nullptr
nullptr
)
;
}
Result
incrementalDecode
(
int
*
rowsDecoded
=
nullptr
)
{
if
(
!
fStartedIncrementalDecode
)
{
return
kInvalidParameters
;
}
return
this
-
>
onIncrementalDecode
(
rowsDecoded
)
;
}
Result
startScanlineDecode
(
const
SkImageInfo
&
dstInfo
const
SkCodec
:
:
Options
*
options
SkPMColor
ctable
[
]
int
*
ctableCount
)
;
Result
startScanlineDecode
(
const
SkImageInfo
&
dstInfo
)
;
int
getScanlines
(
void
*
dst
int
countLines
size_t
rowBytes
)
;
bool
skipScanlines
(
int
countLines
)
;
enum
SkScanlineOrder
{
kTopDown_SkScanlineOrder
kBottomUp_SkScanlineOrder
}
;
SkScanlineOrder
getScanlineOrder
(
)
const
{
return
this
-
>
onGetScanlineOrder
(
)
;
}
int
nextScanline
(
)
const
{
return
this
-
>
outputScanline
(
fCurrScanline
)
;
}
int
outputScanline
(
int
inputScanline
)
const
;
size_t
getFrameCount
(
)
{
return
this
-
>
onGetFrameCount
(
)
;
}
static
constexpr
size_t
kNone
=
static_cast
<
size_t
>
(
-
1
)
;
struct
FrameInfo
{
size_t
fRequiredFrame
;
size_t
fDuration
;
bool
fFullyReceived
;
SkAlphaType
fAlphaType
;
}
;
bool
getFrameInfo
(
size_t
index
FrameInfo
*
info
)
const
{
return
this
-
>
onGetFrameInfo
(
index
info
)
;
}
std
:
:
vector
<
FrameInfo
>
getFrameInfo
(
)
;
static
constexpr
int
kRepetitionCountInfinite
=
-
1
;
int
getRepetitionCount
(
)
{
return
this
-
>
onGetRepetitionCount
(
)
;
}
protected
:
SkCodec
(
int
width
int
height
const
SkEncodedInfo
&
SkStream
*
sk_sp
<
SkColorSpace
>
Origin
=
kTopLeft_Origin
)
;
SkCodec
(
const
SkEncodedInfo
&
const
SkImageInfo
&
SkStream
*
Origin
=
kTopLeft_Origin
)
;
virtual
SkISize
onGetScaledDimensions
(
float
)
const
{
return
this
-
>
getInfo
(
)
.
dimensions
(
)
;
}
virtual
bool
onDimensionsSupported
(
const
SkISize
&
)
{
return
false
;
}
virtual
SkEncodedImageFormat
onGetEncodedFormat
(
)
const
=
0
;
virtual
Result
onGetPixels
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
const
Options
&
SkPMColor
ctable
[
]
int
*
ctableCount
int
*
rowsDecoded
)
=
0
;
virtual
bool
onQueryYUV8
(
SkYUVSizeInfo
*
SkYUVColorSpace
*
)
const
{
return
false
;
}
virtual
Result
onGetYUV8Planes
(
const
SkYUVSizeInfo
&
void
*
[
3
]
)
{
return
kUnimplemented
;
}
virtual
bool
onGetValidSubset
(
SkIRect
*
)
const
{
return
false
;
}
bool
SK_WARN_UNUSED_RESULT
rewindIfNeeded
(
)
;
virtual
bool
onRewind
(
)
{
return
true
;
}
uint64_t
getFillValue
(
const
SkImageInfo
&
dstInfo
)
const
{
return
this
-
>
onGetFillValue
(
dstInfo
)
;
}
virtual
uint64_t
onGetFillValue
(
const
SkImageInfo
&
dstInfo
)
const
;
SkStream
*
stream
(
)
{
return
fStream
.
get
(
)
;
}
virtual
SkScanlineOrder
onGetScanlineOrder
(
)
const
{
return
kTopDown_SkScanlineOrder
;
}
const
SkImageInfo
&
dstInfo
(
)
const
{
return
fDstInfo
;
}
const
SkCodec
:
:
Options
&
options
(
)
const
{
return
fOptions
;
}
int
currScanline
(
)
const
{
return
fCurrScanline
;
}
virtual
int
onOutputScanline
(
int
inputScanline
)
const
;
bool
initializeColorXform
(
const
SkImageInfo
&
dstInfo
SkTransferFunctionBehavior
premulBehavior
)
;
SkColorSpaceXform
*
colorXform
(
)
const
{
return
fColorXform
.
get
(
)
;
}
virtual
size_t
onGetFrameCount
(
)
{
return
1
;
}
virtual
bool
onGetFrameInfo
(
size_t
FrameInfo
*
)
const
{
return
false
;
}
virtual
int
onGetRepetitionCount
(
)
{
return
0
;
}
void
setUnsupportedICC
(
bool
SkDEBUGCODE
(
value
)
)
{
SkDEBUGCODE
(
fUnsupportedICC
=
value
)
;
}
private
:
const
SkEncodedInfo
fEncodedInfo
;
const
SkImageInfo
fSrcInfo
;
std
:
:
unique_ptr
<
SkStream
>
fStream
;
bool
fNeedsRewind
;
const
Origin
fOrigin
;
SkImageInfo
fDstInfo
;
SkCodec
:
:
Options
fOptions
;
std
:
:
unique_ptr
<
SkColorSpaceXform
>
fColorXform
;
int
fCurrScanline
;
bool
fStartedIncrementalDecode
;
#
ifdef
SK_DEBUG
bool
fUnsupportedICC
=
false
;
#
endif
bool
dimensionsSupported
(
const
SkISize
&
dim
)
{
return
dim
=
=
fSrcInfo
.
dimensions
(
)
|
|
this
-
>
onDimensionsSupported
(
dim
)
;
}
virtual
SkCodec
:
:
Result
onStartScanlineDecode
(
const
SkImageInfo
&
const
SkCodec
:
:
Options
&
SkPMColor
*
int
*
)
{
return
kUnimplemented
;
}
virtual
Result
onStartIncrementalDecode
(
const
SkImageInfo
&
void
*
size_t
const
SkCodec
:
:
Options
&
SkPMColor
*
int
*
)
{
return
kUnimplemented
;
}
virtual
Result
onIncrementalDecode
(
int
*
)
{
return
kUnimplemented
;
}
virtual
bool
onSkipScanlines
(
int
)
{
return
false
;
}
virtual
int
onGetScanlines
(
void
*
int
size_t
)
{
return
0
;
}
void
fillIncompleteImage
(
const
SkImageInfo
&
dstInfo
void
*
dst
size_t
rowBytes
ZeroInitialized
zeroInit
int
linesRequested
int
linesDecoded
)
;
virtual
SkSampler
*
getSampler
(
bool
)
{
return
nullptr
;
}
friend
class
DM
:
:
CodecSrc
;
friend
class
SkSampledCodec
;
friend
class
SkIcoCodec
;
friend
struct
Sniffer
;
friend
class
AutoCleanPng
;
}
;
#
endif
