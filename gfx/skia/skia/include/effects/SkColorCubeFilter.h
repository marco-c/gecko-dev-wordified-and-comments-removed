#
ifndef
SkColorCubeFilter_DEFINED
#
define
SkColorCubeFilter_DEFINED
#
include
"
SkColorFilter
.
h
"
#
include
"
SkData
.
h
"
#
include
"
.
.
/
private
/
SkMutex
.
h
"
#
include
"
.
.
/
private
/
SkTemplates
.
h
"
class
SK_API
SkColorCubeFilter
:
public
SkColorFilter
{
public
:
static
SkColorFilter
*
Create
(
SkData
*
cubeData
int
cubeDimension
)
;
void
filterSpan
(
const
SkPMColor
src
[
]
int
count
SkPMColor
[
]
)
const
override
;
uint32_t
getFlags
(
)
const
override
;
#
if
SK_SUPPORT_GPU
const
GrFragmentProcessor
*
asFragmentProcessor
(
GrContext
*
)
const
override
;
#
endif
SK_TO_STRING_OVERRIDE
(
)
SK_DECLARE_PUBLIC_FLATTENABLE_DESERIALIZATION_PROCS
(
SkColorCubeFilter
)
protected
:
SkColorCubeFilter
(
SkData
*
cubeData
int
cubeDimension
)
;
void
flatten
(
SkWriteBuffer
&
)
const
override
;
private
:
class
ColorCubeProcesingCache
{
public
:
ColorCubeProcesingCache
(
int
cubeDimension
)
;
void
getProcessingLuts
(
const
int
*
(
*
colorToIndex
)
[
2
]
const
SkScalar
*
(
*
colorToFactors
)
[
2
]
const
SkScalar
*
*
colorToScalar
)
;
int
cubeDimension
(
)
const
{
return
fCubeDimension
;
}
private
:
int
*
fColorToIndex
[
2
]
;
SkScalar
*
fColorToFactors
[
2
]
;
SkScalar
*
fColorToScalar
;
SkAutoTMalloc
<
uint8_t
>
fLutStorage
;
const
int
fCubeDimension
;
SkMutex
fLutsMutex
;
bool
fLutsInited
;
static
void
initProcessingLuts
(
ColorCubeProcesingCache
*
cache
)
;
}
;
SkAutoDataUnref
fCubeData
;
int32_t
fUniqueID
;
mutable
ColorCubeProcesingCache
fCache
;
typedef
SkColorFilter
INHERITED
;
}
;
#
endif
