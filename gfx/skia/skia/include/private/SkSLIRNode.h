#
ifndef
SKSL_IRNODE
#
define
SKSL_IRNODE
#
include
"
include
/
sksl
/
SkSLPosition
.
h
"
#
include
"
src
/
sksl
/
SkSLPool
.
h
"
#
include
<
string
>
namespace
SkSL
{
enum
class
ProgramElementKind
{
kExtension
=
0
kFunction
kFunctionPrototype
kGlobalVar
kInterfaceBlock
kModifiers
kStructDefinition
kFirst
=
kExtension
kLast
=
kStructDefinition
}
;
enum
class
SymbolKind
{
kExternal
=
(
int
)
ProgramElementKind
:
:
kLast
+
1
kField
kFunctionDeclaration
kType
kVariable
kFirst
=
kExternal
kLast
=
kVariable
}
;
enum
class
StatementKind
{
kBlock
=
(
int
)
SymbolKind
:
:
kLast
+
1
kBreak
kContinue
kDiscard
kDo
kExpression
kFor
kIf
kNop
kReturn
kSwitch
kSwitchCase
kVarDeclaration
kFirst
=
kBlock
kLast
=
kVarDeclaration
}
;
enum
class
ExpressionKind
{
kBinary
=
(
int
)
StatementKind
:
:
kLast
+
1
kChildCall
kConstructorArray
kConstructorArrayCast
kConstructorCompound
kConstructorCompoundCast
kConstructorDiagonalMatrix
kConstructorMatrixResize
kConstructorScalarCast
kConstructorSplat
kConstructorStruct
kFieldAccess
kFunctionReference
kFunctionCall
kIndex
kLiteral
kMethodReference
kPoison
kPostfix
kPrefix
kSetting
kSwizzle
kTernary
kTypeReference
kVariableReference
kFirst
=
kBinary
kLast
=
kVariableReference
}
;
class
IRNode
:
public
Poolable
{
public
:
virtual
~
IRNode
(
)
{
}
virtual
std
:
:
string
description
(
)
const
=
0
;
IRNode
(
const
IRNode
&
)
=
delete
;
IRNode
&
operator
=
(
const
IRNode
&
)
=
delete
;
Position
fPosition
;
template
<
typename
T
>
bool
is
(
)
const
{
return
this
-
>
fKind
=
=
(
int
)
T
:
:
kIRNodeKind
;
}
template
<
typename
T
>
const
T
&
as
(
)
const
{
SkASSERT
(
this
-
>
is
<
T
>
(
)
)
;
return
static_cast
<
const
T
&
>
(
*
this
)
;
}
template
<
typename
T
>
T
&
as
(
)
{
SkASSERT
(
this
-
>
is
<
T
>
(
)
)
;
return
static_cast
<
T
&
>
(
*
this
)
;
}
protected
:
IRNode
(
Position
position
int
kind
)
:
fPosition
(
position
)
fKind
(
kind
)
{
}
int
fKind
;
}
;
}
#
endif
