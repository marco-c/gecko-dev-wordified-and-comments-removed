#
ifndef
GrCCClipPath_DEFINED
#
define
GrCCClipPath_DEFINED
#
include
"
GrTextureProxy
.
h
"
#
include
"
SkPath
.
h
"
struct
GrCCPerFlushResourceSpecs
;
class
GrCCAtlas
;
class
GrCCPerFlushResources
;
class
GrOnFlushResourceProvider
;
class
GrProxyProvider
;
class
GrCCClipPath
{
public
:
GrCCClipPath
(
)
=
default
;
GrCCClipPath
(
const
GrCCClipPath
&
)
=
delete
;
~
GrCCClipPath
(
)
{
SkASSERT
(
!
fAtlasLazyProxy
|
|
fAtlasLazyProxy
-
>
isUnique_debugOnly
(
)
)
;
}
bool
isInitialized
(
)
const
{
return
fAtlasLazyProxy
!
=
nullptr
;
}
void
init
(
const
SkPath
&
deviceSpacePath
const
SkIRect
&
accessRect
int
rtWidth
int
rtHeight
const
GrCaps
&
)
;
void
addAccess
(
const
SkIRect
&
accessRect
)
{
SkASSERT
(
this
-
>
isInitialized
(
)
)
;
fAccessRect
.
join
(
accessRect
)
;
}
GrTextureProxy
*
atlasLazyProxy
(
)
const
{
SkASSERT
(
this
-
>
isInitialized
(
)
)
;
return
fAtlasLazyProxy
.
get
(
)
;
}
const
SkPath
&
deviceSpacePath
(
)
const
{
SkASSERT
(
this
-
>
isInitialized
(
)
)
;
return
fDeviceSpacePath
;
}
const
SkIRect
&
pathDevIBounds
(
)
const
{
SkASSERT
(
this
-
>
isInitialized
(
)
)
;
return
fPathDevIBounds
;
}
void
accountForOwnPath
(
GrCCPerFlushResourceSpecs
*
)
const
;
void
renderPathInAtlas
(
GrCCPerFlushResources
*
GrOnFlushResourceProvider
*
)
;
const
SkVector
&
atlasScale
(
)
const
{
SkASSERT
(
fHasAtlasTransform
)
;
return
fAtlasScale
;
}
const
SkVector
&
atlasTranslate
(
)
const
{
SkASSERT
(
fHasAtlasTransform
)
;
return
fAtlasTranslate
;
}
private
:
sk_sp
<
GrTextureProxy
>
fAtlasLazyProxy
;
SkPath
fDeviceSpacePath
;
SkIRect
fPathDevIBounds
;
SkIRect
fAccessRect
;
const
GrCCAtlas
*
fAtlas
=
nullptr
;
SkIVector
fDevToAtlasOffset
;
SkDEBUGCODE
(
bool
fHasAtlas
=
false
)
;
SkVector
fAtlasScale
;
SkVector
fAtlasTranslate
;
SkDEBUGCODE
(
bool
fHasAtlasTransform
=
false
)
;
}
;
#
endif
