#
ifndef
GrVkSecondaryCBDrawContext_DEFINED
#
define
GrVkSecondaryCBDrawContext_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSurfaceProps
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
<
memory
>
class
GrBackendSemaphore
;
class
GrDeferredDisplayList
;
class
GrRecordingContext
;
class
GrSurfaceCharacterization
;
struct
GrVkDrawableInfo
;
namespace
skgpu
:
:
ganesh
{
class
Device
;
}
class
SkCanvas
;
struct
SkImageInfo
;
class
SkSurfaceProps
;
class
SK_SPI
GrVkSecondaryCBDrawContext
:
public
SkRefCnt
{
public
:
static
sk_sp
<
GrVkSecondaryCBDrawContext
>
Make
(
GrRecordingContext
*
const
SkImageInfo
&
const
GrVkDrawableInfo
&
const
SkSurfaceProps
*
props
)
;
~
GrVkSecondaryCBDrawContext
(
)
override
;
SkCanvas
*
getCanvas
(
)
;
void
flush
(
)
;
bool
wait
(
int
numSemaphores
const
GrBackendSemaphore
waitSemaphores
[
]
bool
deleteSemaphoresAfterWait
=
true
)
;
void
releaseResources
(
)
;
const
SkSurfaceProps
&
props
(
)
const
{
return
fProps
;
}
bool
characterize
(
GrSurfaceCharacterization
*
characterization
)
const
;
#
ifndef
SK_DDL_IS_UNIQUE_POINTER
bool
draw
(
sk_sp
<
const
GrDeferredDisplayList
>
deferredDisplayList
)
;
#
else
bool
draw
(
const
GrDeferredDisplayList
*
deferredDisplayList
)
;
#
endif
bool
isCompatible
(
const
GrSurfaceCharacterization
&
characterization
)
const
;
private
:
explicit
GrVkSecondaryCBDrawContext
(
sk_sp
<
skgpu
:
:
ganesh
:
:
Device
>
const
SkSurfaceProps
*
)
;
sk_sp
<
skgpu
:
:
ganesh
:
:
Device
>
fDevice
;
std
:
:
unique_ptr
<
SkCanvas
>
fCachedCanvas
;
const
SkSurfaceProps
fProps
;
using
INHERITED
=
SkRefCnt
;
}
;
#
endif
