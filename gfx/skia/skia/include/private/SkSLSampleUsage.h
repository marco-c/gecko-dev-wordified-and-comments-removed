#
ifndef
SkSLSampleUsage_DEFINED
#
define
SkSLSampleUsage_DEFINED
#
include
"
include
/
core
/
SkTypes
.
h
"
namespace
SkSL
{
class
SampleUsage
{
public
:
enum
class
Kind
{
kNone
kPassThrough
kUniformMatrix
kFragCoord
kExplicit
}
;
SampleUsage
(
)
=
default
;
SampleUsage
(
Kind
kind
bool
hasPerspective
)
:
fKind
(
kind
)
fHasPerspective
(
hasPerspective
)
{
if
(
kind
!
=
Kind
:
:
kUniformMatrix
)
{
SkASSERT
(
!
fHasPerspective
)
;
}
}
static
SampleUsage
UniformMatrix
(
bool
hasPerspective
)
{
return
SampleUsage
(
Kind
:
:
kUniformMatrix
hasPerspective
)
;
}
static
SampleUsage
Explicit
(
)
{
return
SampleUsage
(
Kind
:
:
kExplicit
false
)
;
}
static
SampleUsage
PassThrough
(
)
{
return
SampleUsage
(
Kind
:
:
kPassThrough
false
)
;
}
static
SampleUsage
FragCoord
(
)
{
return
SampleUsage
(
Kind
:
:
kFragCoord
false
)
;
}
bool
operator
=
=
(
const
SampleUsage
&
that
)
const
{
return
fKind
=
=
that
.
fKind
&
&
fHasPerspective
=
=
that
.
fHasPerspective
;
}
bool
operator
!
=
(
const
SampleUsage
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
static
const
char
*
MatrixUniformName
(
)
{
return
"
matrix
"
;
}
SampleUsage
merge
(
const
SampleUsage
&
other
)
;
Kind
kind
(
)
const
{
return
fKind
;
}
bool
hasPerspective
(
)
const
{
return
fHasPerspective
;
}
bool
isSampled
(
)
const
{
return
fKind
!
=
Kind
:
:
kNone
;
}
bool
isPassThrough
(
)
const
{
return
fKind
=
=
Kind
:
:
kPassThrough
;
}
bool
isExplicit
(
)
const
{
return
fKind
=
=
Kind
:
:
kExplicit
;
}
bool
isUniformMatrix
(
)
const
{
return
fKind
=
=
Kind
:
:
kUniformMatrix
;
}
bool
isFragCoord
(
)
const
{
return
fKind
=
=
Kind
:
:
kFragCoord
;
}
private
:
Kind
fKind
=
Kind
:
:
kNone
;
bool
fHasPerspective
=
false
;
}
;
}
#
endif
