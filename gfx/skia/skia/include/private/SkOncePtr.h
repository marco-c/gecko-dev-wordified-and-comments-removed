#
ifndef
SkOncePtr_DEFINED
#
define
SkOncePtr_DEFINED
#
include
"
.
.
/
private
/
SkAtomics
.
h
"
#
include
"
SkUniquePtr
.
h
"
template
<
typename
T
>
class
SkBaseOncePtr
;
#
define
SK_DECLARE_STATIC_ONCE_PTR
(
type
name
)
namespace
{
}
static
SkBaseOncePtr
<
type
>
name
;
template
<
typename
T
typename
Delete
=
skstd
:
:
default_delete
<
T
>
>
class
SkOncePtr
:
SkNoncopyable
{
public
:
SkOncePtr
(
)
{
sk_bzero
(
this
sizeof
(
*
this
)
)
;
}
~
SkOncePtr
(
)
{
if
(
T
*
ptr
=
(
T
*
)
*
this
)
{
Delete
(
)
(
ptr
)
;
}
}
template
<
typename
F
>
T
*
get
(
const
F
&
f
)
const
{
return
fOnce
.
get
(
f
)
;
}
operator
T
*
(
)
const
{
return
(
T
*
)
fOnce
;
}
private
:
SkBaseOncePtr
<
T
>
fOnce
;
}
;
template
<
typename
T
>
class
SkOncePtr
<
T
[
]
>
:
public
SkOncePtr
<
T
skstd
:
:
default_delete
<
T
[
]
>
>
{
}
;
template
<
typename
T
>
class
SkBaseOncePtr
{
public
:
template
<
typename
F
>
T
*
get
(
const
F
&
f
)
const
{
uintptr_t
state
=
sk_atomic_load
(
&
fState
sk_memory_order_acquire
)
;
if
(
state
<
2
)
{
if
(
state
=
=
0
)
{
if
(
sk_atomic_compare_exchange
(
&
fState
&
state
(
uintptr_t
)
1
sk_memory_order_relaxed
sk_memory_order_relaxed
)
)
{
state
=
(
uintptr_t
)
f
(
)
;
SkASSERT
(
state
>
1
)
;
sk_atomic_store
(
&
fState
state
sk_memory_order_release
)
;
}
else
{
}
}
while
(
state
=
=
1
)
{
state
=
sk_atomic_load
(
&
fState
sk_memory_order_acquire
)
;
}
SkASSERT
(
state
>
1
)
;
}
return
(
T
*
)
state
;
}
operator
T
*
(
)
const
{
auto
state
=
sk_atomic_load
(
&
fState
sk_memory_order_acquire
)
;
return
state
<
2
?
nullptr
:
(
T
*
)
state
;
}
mutable
uintptr_t
fState
;
}
;
#
endif
