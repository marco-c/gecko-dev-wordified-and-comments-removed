#
ifndef
SkTArray_DEFINED
#
define
SkTArray_DEFINED
#
include
"
.
.
/
private
/
SkSafe32
.
h
"
#
include
"
.
.
/
private
/
SkTLogic
.
h
"
#
include
"
.
.
/
private
/
SkTemplates
.
h
"
#
include
"
SkTypes
.
h
"
#
include
<
new
>
#
include
<
utility
>
template
<
typename
T
bool
MEM_MOVE
=
false
>
class
SkTArray
{
public
:
SkTArray
(
)
{
this
-
>
init
(
)
;
}
explicit
SkTArray
(
int
reserveCount
)
{
this
-
>
init
(
0
reserveCount
)
;
}
explicit
SkTArray
(
const
SkTArray
&
that
)
{
this
-
>
init
(
that
.
fCount
)
;
this
-
>
copy
(
that
.
fItemArray
)
;
}
SkTArray
(
SkTArray
&
&
that
)
{
this
-
>
init
(
that
.
fCount
)
;
that
.
move
(
fMemArray
)
;
that
.
fCount
=
0
;
}
SkTArray
(
const
T
*
array
int
count
)
{
this
-
>
init
(
count
)
;
this
-
>
copy
(
array
)
;
}
SkTArray
&
operator
=
(
const
SkTArray
&
that
)
{
if
(
this
=
=
&
that
)
{
return
*
this
;
}
for
(
int
i
=
0
;
i
<
fCount
;
+
+
i
)
{
fItemArray
[
i
]
.
~
T
(
)
;
}
fCount
=
0
;
this
-
>
checkRealloc
(
that
.
count
(
)
)
;
fCount
=
that
.
count
(
)
;
this
-
>
copy
(
that
.
fItemArray
)
;
return
*
this
;
}
SkTArray
&
operator
=
(
SkTArray
&
&
that
)
{
if
(
this
=
=
&
that
)
{
return
*
this
;
}
for
(
int
i
=
0
;
i
<
fCount
;
+
+
i
)
{
fItemArray
[
i
]
.
~
T
(
)
;
}
fCount
=
0
;
this
-
>
checkRealloc
(
that
.
count
(
)
)
;
fCount
=
that
.
count
(
)
;
that
.
move
(
fMemArray
)
;
that
.
fCount
=
0
;
return
*
this
;
}
~
SkTArray
(
)
{
for
(
int
i
=
0
;
i
<
fCount
;
+
+
i
)
{
fItemArray
[
i
]
.
~
T
(
)
;
}
if
(
fOwnMemory
)
{
sk_free
(
fMemArray
)
;
}
}
void
reset
(
)
{
this
-
>
pop_back_n
(
fCount
)
;
fReserved
=
false
;
}
void
reset
(
int
n
)
{
SkASSERT
(
n
>
=
0
)
;
for
(
int
i
=
0
;
i
<
fCount
;
+
+
i
)
{
fItemArray
[
i
]
.
~
T
(
)
;
}
fCount
=
0
;
this
-
>
checkRealloc
(
n
)
;
fCount
=
n
;
for
(
int
i
=
0
;
i
<
fCount
;
+
+
i
)
{
new
(
fItemArray
+
i
)
T
;
}
fReserved
=
false
;
}
void
reset
(
const
T
*
array
int
count
)
{
for
(
int
i
=
0
;
i
<
fCount
;
+
+
i
)
{
fItemArray
[
i
]
.
~
T
(
)
;
}
fCount
=
0
;
this
-
>
checkRealloc
(
count
)
;
fCount
=
count
;
this
-
>
copy
(
array
)
;
fReserved
=
false
;
}
void
reserve
(
int
n
)
{
SkASSERT
(
n
>
=
0
)
;
if
(
n
>
0
)
{
this
-
>
checkRealloc
(
n
)
;
fReserved
=
fOwnMemory
;
}
else
{
fReserved
=
false
;
}
}
void
removeShuffle
(
int
n
)
{
SkASSERT
(
n
<
fCount
)
;
int
newCount
=
fCount
-
1
;
fCount
=
newCount
;
fItemArray
[
n
]
.
~
T
(
)
;
if
(
n
!
=
newCount
)
{
this
-
>
move
(
n
newCount
)
;
}
}
int
count
(
)
const
{
return
fCount
;
}
bool
empty
(
)
const
{
return
!
fCount
;
}
T
&
push_back
(
)
{
void
*
newT
=
this
-
>
push_back_raw
(
1
)
;
return
*
new
(
newT
)
T
;
}
T
&
push_back
(
const
T
&
t
)
{
void
*
newT
=
this
-
>
push_back_raw
(
1
)
;
return
*
new
(
newT
)
T
(
t
)
;
}
T
&
push_back
(
T
&
&
t
)
{
void
*
newT
=
this
-
>
push_back_raw
(
1
)
;
return
*
new
(
newT
)
T
(
std
:
:
move
(
t
)
)
;
}
template
<
class
.
.
.
Args
>
T
&
emplace_back
(
Args
&
&
.
.
.
args
)
{
void
*
newT
=
this
-
>
push_back_raw
(
1
)
;
return
*
new
(
newT
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
T
*
push_back_n
(
int
n
)
{
SkASSERT
(
n
>
=
0
)
;
void
*
newTs
=
this
-
>
push_back_raw
(
n
)
;
for
(
int
i
=
0
;
i
<
n
;
+
+
i
)
{
new
(
static_cast
<
char
*
>
(
newTs
)
+
i
*
sizeof
(
T
)
)
T
;
}
return
static_cast
<
T
*
>
(
newTs
)
;
}
T
*
push_back_n
(
int
n
const
T
&
t
)
{
SkASSERT
(
n
>
=
0
)
;
void
*
newTs
=
this
-
>
push_back_raw
(
n
)
;
for
(
int
i
=
0
;
i
<
n
;
+
+
i
)
{
new
(
static_cast
<
char
*
>
(
newTs
)
+
i
*
sizeof
(
T
)
)
T
(
t
)
;
}
return
static_cast
<
T
*
>
(
newTs
)
;
}
T
*
push_back_n
(
int
n
const
T
t
[
]
)
{
SkASSERT
(
n
>
=
0
)
;
this
-
>
checkRealloc
(
n
)
;
for
(
int
i
=
0
;
i
<
n
;
+
+
i
)
{
new
(
fItemArray
+
fCount
+
i
)
T
(
t
[
i
]
)
;
}
fCount
+
=
n
;
return
fItemArray
+
fCount
-
n
;
}
T
*
move_back_n
(
int
n
T
*
t
)
{
SkASSERT
(
n
>
=
0
)
;
this
-
>
checkRealloc
(
n
)
;
for
(
int
i
=
0
;
i
<
n
;
+
+
i
)
{
new
(
fItemArray
+
fCount
+
i
)
T
(
std
:
:
move
(
t
[
i
]
)
)
;
}
fCount
+
=
n
;
return
fItemArray
+
fCount
-
n
;
}
void
pop_back
(
)
{
SkASSERT
(
fCount
>
0
)
;
-
-
fCount
;
fItemArray
[
fCount
]
.
~
T
(
)
;
this
-
>
checkRealloc
(
0
)
;
}
void
pop_back_n
(
int
n
)
{
SkASSERT
(
n
>
=
0
)
;
SkASSERT
(
fCount
>
=
n
)
;
fCount
-
=
n
;
for
(
int
i
=
0
;
i
<
n
;
+
+
i
)
{
fItemArray
[
fCount
+
i
]
.
~
T
(
)
;
}
this
-
>
checkRealloc
(
0
)
;
}
void
resize_back
(
int
newCount
)
{
SkASSERT
(
newCount
>
=
0
)
;
if
(
newCount
>
fCount
)
{
this
-
>
push_back_n
(
newCount
-
fCount
)
;
}
else
if
(
newCount
<
fCount
)
{
this
-
>
pop_back_n
(
fCount
-
newCount
)
;
}
}
void
swap
(
SkTArray
&
that
)
{
using
std
:
:
swap
;
if
(
this
=
=
&
that
)
{
return
;
}
if
(
fOwnMemory
&
&
that
.
fOwnMemory
)
{
swap
(
fItemArray
that
.
fItemArray
)
;
swap
(
fCount
that
.
fCount
)
;
swap
(
fAllocCount
that
.
fAllocCount
)
;
}
else
{
SkTArray
copy
(
std
:
:
move
(
that
)
)
;
that
=
std
:
:
move
(
*
this
)
;
*
this
=
std
:
:
move
(
copy
)
;
}
}
T
*
begin
(
)
{
return
fItemArray
;
}
const
T
*
begin
(
)
const
{
return
fItemArray
;
}
T
*
end
(
)
{
return
fItemArray
?
fItemArray
+
fCount
:
nullptr
;
}
const
T
*
end
(
)
const
{
return
fItemArray
?
fItemArray
+
fCount
:
nullptr
;
}
T
&
operator
[
]
(
int
i
)
{
SkASSERT
(
i
<
fCount
)
;
SkASSERT
(
i
>
=
0
)
;
return
fItemArray
[
i
]
;
}
const
T
&
operator
[
]
(
int
i
)
const
{
SkASSERT
(
i
<
fCount
)
;
SkASSERT
(
i
>
=
0
)
;
return
fItemArray
[
i
]
;
}
T
&
front
(
)
{
SkASSERT
(
fCount
>
0
)
;
return
fItemArray
[
0
]
;
}
const
T
&
front
(
)
const
{
SkASSERT
(
fCount
>
0
)
;
return
fItemArray
[
0
]
;
}
T
&
back
(
)
{
SkASSERT
(
fCount
)
;
return
fItemArray
[
fCount
-
1
]
;
}
const
T
&
back
(
)
const
{
SkASSERT
(
fCount
>
0
)
;
return
fItemArray
[
fCount
-
1
]
;
}
T
&
fromBack
(
int
i
)
{
SkASSERT
(
i
>
=
0
)
;
SkASSERT
(
i
<
fCount
)
;
return
fItemArray
[
fCount
-
i
-
1
]
;
}
const
T
&
fromBack
(
int
i
)
const
{
SkASSERT
(
i
>
=
0
)
;
SkASSERT
(
i
<
fCount
)
;
return
fItemArray
[
fCount
-
i
-
1
]
;
}
bool
operator
=
=
(
const
SkTArray
<
T
MEM_MOVE
>
&
right
)
const
{
int
leftCount
=
this
-
>
count
(
)
;
if
(
leftCount
!
=
right
.
count
(
)
)
{
return
false
;
}
for
(
int
index
=
0
;
index
<
leftCount
;
+
+
index
)
{
if
(
fItemArray
[
index
]
!
=
right
.
fItemArray
[
index
]
)
{
return
false
;
}
}
return
true
;
}
bool
operator
!
=
(
const
SkTArray
<
T
MEM_MOVE
>
&
right
)
const
{
return
!
(
*
this
=
=
right
)
;
}
inline
int
allocCntForTest
(
)
const
;
protected
:
template
<
int
N
>
SkTArray
(
SkAlignedSTStorage
<
N
T
>
*
storage
)
{
this
-
>
initWithPreallocatedStorage
(
0
storage
-
>
get
(
)
N
)
;
}
template
<
int
N
>
SkTArray
(
const
SkTArray
&
array
SkAlignedSTStorage
<
N
T
>
*
storage
)
{
this
-
>
initWithPreallocatedStorage
(
array
.
fCount
storage
-
>
get
(
)
N
)
;
this
-
>
copy
(
array
.
fItemArray
)
;
}
template
<
int
N
>
SkTArray
(
SkTArray
&
&
array
SkAlignedSTStorage
<
N
T
>
*
storage
)
{
this
-
>
initWithPreallocatedStorage
(
array
.
fCount
storage
-
>
get
(
)
N
)
;
array
.
move
(
fMemArray
)
;
array
.
fCount
=
0
;
}
template
<
int
N
>
SkTArray
(
const
T
*
array
int
count
SkAlignedSTStorage
<
N
T
>
*
storage
)
{
this
-
>
initWithPreallocatedStorage
(
count
storage
-
>
get
(
)
N
)
;
this
-
>
copy
(
array
)
;
}
private
:
void
init
(
int
count
=
0
int
reserveCount
=
0
)
{
SkASSERT
(
count
>
=
0
)
;
SkASSERT
(
reserveCount
>
=
0
)
;
fCount
=
count
;
if
(
!
count
&
&
!
reserveCount
)
{
fAllocCount
=
0
;
fMemArray
=
nullptr
;
fOwnMemory
=
true
;
fReserved
=
false
;
}
else
{
fAllocCount
=
SkTMax
(
count
SkTMax
(
kMinHeapAllocCount
reserveCount
)
)
;
fMemArray
=
sk_malloc_throw
(
fAllocCount
sizeof
(
T
)
)
;
fOwnMemory
=
true
;
fReserved
=
reserveCount
>
0
;
}
}
void
initWithPreallocatedStorage
(
int
count
void
*
preallocStorage
int
preallocCount
)
{
SkASSERT
(
count
>
=
0
)
;
SkASSERT
(
preallocCount
>
0
)
;
SkASSERT
(
preallocStorage
)
;
fCount
=
count
;
fMemArray
=
nullptr
;
fReserved
=
false
;
if
(
count
>
preallocCount
)
{
fAllocCount
=
SkTMax
(
count
kMinHeapAllocCount
)
;
fMemArray
=
sk_malloc_throw
(
fAllocCount
sizeof
(
T
)
)
;
fOwnMemory
=
true
;
}
else
{
fAllocCount
=
preallocCount
;
fMemArray
=
preallocStorage
;
fOwnMemory
=
false
;
}
}
void
copy
(
const
T
*
src
)
{
for
(
int
i
=
0
;
i
<
fCount
;
+
+
i
)
{
new
(
fItemArray
+
i
)
T
(
src
[
i
]
)
;
}
}
template
<
bool
E
=
MEM_MOVE
>
SK_WHEN
(
E
void
)
move
(
int
dst
int
src
)
{
memcpy
(
&
fItemArray
[
dst
]
&
fItemArray
[
src
]
sizeof
(
T
)
)
;
}
template
<
bool
E
=
MEM_MOVE
>
SK_WHEN
(
E
void
)
move
(
void
*
dst
)
{
sk_careful_memcpy
(
dst
fMemArray
fCount
*
sizeof
(
T
)
)
;
}
template
<
bool
E
=
MEM_MOVE
>
SK_WHEN
(
!
E
void
)
move
(
int
dst
int
src
)
{
new
(
&
fItemArray
[
dst
]
)
T
(
std
:
:
move
(
fItemArray
[
src
]
)
)
;
fItemArray
[
src
]
.
~
T
(
)
;
}
template
<
bool
E
=
MEM_MOVE
>
SK_WHEN
(
!
E
void
)
move
(
void
*
dst
)
{
for
(
int
i
=
0
;
i
<
fCount
;
+
+
i
)
{
new
(
static_cast
<
char
*
>
(
dst
)
+
sizeof
(
T
)
*
i
)
T
(
std
:
:
move
(
fItemArray
[
i
]
)
)
;
fItemArray
[
i
]
.
~
T
(
)
;
}
}
static
constexpr
int
kMinHeapAllocCount
=
8
;
void
*
push_back_raw
(
int
n
)
{
this
-
>
checkRealloc
(
n
)
;
void
*
ptr
=
fItemArray
+
fCount
;
fCount
+
=
n
;
return
ptr
;
}
void
checkRealloc
(
int
delta
)
{
SkASSERT
(
fCount
>
=
0
)
;
SkASSERT
(
fAllocCount
>
=
0
)
;
SkASSERT
(
-
delta
<
=
fCount
)
;
int64_t
newCount
=
fCount
+
delta
;
bool
mustGrow
=
newCount
>
fAllocCount
;
bool
shouldShrink
=
fAllocCount
>
3
*
newCount
&
&
fOwnMemory
&
&
!
fReserved
;
if
(
!
mustGrow
&
&
!
shouldShrink
)
{
return
;
}
int64_t
newAllocCount
=
newCount
+
(
(
newCount
+
1
)
>
>
1
)
;
static_assert
(
SkIsPow2
(
kMinHeapAllocCount
)
"
min
alloc
count
not
power
of
two
.
"
)
;
newAllocCount
=
(
newAllocCount
+
(
kMinHeapAllocCount
-
1
)
)
&
~
(
kMinHeapAllocCount
-
1
)
;
if
(
newAllocCount
=
=
fAllocCount
)
{
return
;
}
fAllocCount
=
Sk64_pin_to_s32
(
newAllocCount
)
;
SkASSERT
(
fAllocCount
>
=
newCount
)
;
void
*
newMemArray
=
sk_malloc_throw
(
fAllocCount
sizeof
(
T
)
)
;
this
-
>
move
(
newMemArray
)
;
if
(
fOwnMemory
)
{
sk_free
(
fMemArray
)
;
}
fMemArray
=
newMemArray
;
fOwnMemory
=
true
;
fReserved
=
false
;
}
union
{
T
*
fItemArray
;
void
*
fMemArray
;
}
;
int
fCount
;
int
fAllocCount
;
bool
fOwnMemory
:
1
;
bool
fReserved
:
1
;
}
;
template
<
typename
T
bool
M
>
static
inline
void
swap
(
SkTArray
<
T
M
>
&
a
SkTArray
<
T
M
>
&
b
)
{
a
.
swap
(
b
)
;
}
template
<
typename
T
bool
MEM_MOVE
>
constexpr
int
SkTArray
<
T
MEM_MOVE
>
:
:
kMinHeapAllocCount
;
template
<
int
N
typename
T
bool
MEM_MOVE
=
false
>
class
SkSTArray
:
public
SkTArray
<
T
MEM_MOVE
>
{
private
:
typedef
SkTArray
<
T
MEM_MOVE
>
INHERITED
;
public
:
SkSTArray
(
)
:
INHERITED
(
&
fStorage
)
{
}
SkSTArray
(
const
SkSTArray
&
array
)
:
INHERITED
(
array
&
fStorage
)
{
}
SkSTArray
(
SkSTArray
&
&
array
)
:
INHERITED
(
std
:
:
move
(
array
)
&
fStorage
)
{
}
explicit
SkSTArray
(
const
INHERITED
&
array
)
:
INHERITED
(
array
&
fStorage
)
{
}
explicit
SkSTArray
(
INHERITED
&
&
array
)
:
INHERITED
(
std
:
:
move
(
array
)
&
fStorage
)
{
}
explicit
SkSTArray
(
int
reserveCount
)
:
INHERITED
(
reserveCount
)
{
}
SkSTArray
(
const
T
*
array
int
count
)
:
INHERITED
(
array
count
&
fStorage
)
{
}
SkSTArray
&
operator
=
(
const
SkSTArray
&
array
)
{
INHERITED
:
:
operator
=
(
array
)
;
return
*
this
;
}
SkSTArray
&
operator
=
(
SkSTArray
&
&
array
)
{
INHERITED
:
:
operator
=
(
std
:
:
move
(
array
)
)
;
return
*
this
;
}
SkSTArray
&
operator
=
(
const
INHERITED
&
array
)
{
INHERITED
:
:
operator
=
(
array
)
;
return
*
this
;
}
SkSTArray
&
operator
=
(
INHERITED
&
&
array
)
{
INHERITED
:
:
operator
=
(
std
:
:
move
(
array
)
)
;
return
*
this
;
}
private
:
SkAlignedSTStorage
<
N
T
>
fStorage
;
}
;
#
endif
