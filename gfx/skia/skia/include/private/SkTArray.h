#
ifndef
SkTArray_DEFINED
#
define
SkTArray_DEFINED
#
include
"
SkTypes
.
h
"
#
include
"
.
.
/
private
/
SkTLogic
.
h
"
#
include
"
.
.
/
private
/
SkTemplates
.
h
"
#
include
<
new
>
#
include
<
utility
>
template
<
typename
T
bool
MEM_COPY
=
false
>
class
SkTArray
{
public
:
SkTArray
(
)
{
fCount
=
0
;
fReserveCount
=
gMIN_ALLOC_COUNT
;
fAllocCount
=
0
;
fMemArray
=
NULL
;
fPreAllocMemArray
=
NULL
;
}
explicit
SkTArray
(
int
reserveCount
)
{
this
-
>
init
(
NULL
0
NULL
reserveCount
)
;
}
explicit
SkTArray
(
const
SkTArray
&
array
)
{
this
-
>
init
(
array
.
fItemArray
array
.
fCount
NULL
0
)
;
}
SkTArray
(
const
T
*
array
int
count
)
{
this
-
>
init
(
array
count
NULL
0
)
;
}
SkTArray
&
operator
=
(
const
SkTArray
&
array
)
{
for
(
int
i
=
0
;
i
<
fCount
;
+
+
i
)
{
fItemArray
[
i
]
.
~
T
(
)
;
}
fCount
=
0
;
this
-
>
checkRealloc
(
(
int
)
array
.
count
(
)
)
;
fCount
=
array
.
count
(
)
;
this
-
>
copy
(
static_cast
<
const
T
*
>
(
array
.
fMemArray
)
)
;
return
*
this
;
}
~
SkTArray
(
)
{
for
(
int
i
=
0
;
i
<
fCount
;
+
+
i
)
{
fItemArray
[
i
]
.
~
T
(
)
;
}
if
(
fMemArray
!
=
fPreAllocMemArray
)
{
sk_free
(
fMemArray
)
;
}
}
void
reset
(
)
{
this
-
>
pop_back_n
(
fCount
)
;
}
void
reset
(
int
n
)
{
SkASSERT
(
n
>
=
0
)
;
for
(
int
i
=
0
;
i
<
fCount
;
+
+
i
)
{
fItemArray
[
i
]
.
~
T
(
)
;
}
fCount
=
0
;
this
-
>
checkRealloc
(
n
)
;
fCount
=
n
;
for
(
int
i
=
0
;
i
<
fCount
;
+
+
i
)
{
new
(
fItemArray
+
i
)
T
;
}
}
void
reset
(
const
T
*
array
int
count
)
{
for
(
int
i
=
0
;
i
<
fCount
;
+
+
i
)
{
fItemArray
[
i
]
.
~
T
(
)
;
}
int
delta
=
count
-
fCount
;
this
-
>
checkRealloc
(
delta
)
;
fCount
=
count
;
this
-
>
copy
(
array
)
;
}
void
removeShuffle
(
int
n
)
{
SkASSERT
(
n
<
fCount
)
;
int
newCount
=
fCount
-
1
;
fCount
=
newCount
;
fItemArray
[
n
]
.
~
T
(
)
;
if
(
n
!
=
newCount
)
{
this
-
>
move
(
n
newCount
)
;
}
}
int
count
(
)
const
{
return
fCount
;
}
bool
empty
(
)
const
{
return
!
fCount
;
}
T
&
push_back
(
)
{
T
*
newT
=
reinterpret_cast
<
T
*
>
(
this
-
>
push_back_raw
(
1
)
)
;
new
(
newT
)
T
;
return
*
newT
;
}
T
&
push_back
(
const
T
&
t
)
{
T
*
newT
=
reinterpret_cast
<
T
*
>
(
this
-
>
push_back_raw
(
1
)
)
;
new
(
newT
)
T
(
t
)
;
return
*
newT
;
}
T
&
push_back
(
T
&
&
t
)
{
T
*
newT
=
reinterpret_cast
<
T
*
>
(
this
-
>
push_back_raw
(
1
)
)
;
new
(
newT
)
T
(
std__move
(
t
)
)
;
return
*
newT
;
}
template
<
class
.
.
.
Args
>
T
&
emplace_back
(
Args
&
&
.
.
.
args
)
{
T
*
newT
=
reinterpret_cast
<
T
*
>
(
this
-
>
push_back_raw
(
1
)
)
;
return
*
new
(
newT
)
T
(
std__forward
<
Args
>
(
args
)
.
.
.
)
;
}
T
*
push_back_n
(
int
n
)
{
SkASSERT
(
n
>
=
0
)
;
T
*
newTs
=
reinterpret_cast
<
T
*
>
(
this
-
>
push_back_raw
(
n
)
)
;
for
(
int
i
=
0
;
i
<
n
;
+
+
i
)
{
new
(
newTs
+
i
)
T
;
}
return
newTs
;
}
T
*
push_back_n
(
int
n
const
T
&
t
)
{
SkASSERT
(
n
>
=
0
)
;
T
*
newTs
=
reinterpret_cast
<
T
*
>
(
this
-
>
push_back_raw
(
n
)
)
;
for
(
int
i
=
0
;
i
<
n
;
+
+
i
)
{
new
(
newTs
+
i
)
T
(
t
)
;
}
return
newTs
;
}
T
*
push_back_n
(
int
n
const
T
t
[
]
)
{
SkASSERT
(
n
>
=
0
)
;
this
-
>
checkRealloc
(
n
)
;
for
(
int
i
=
0
;
i
<
n
;
+
+
i
)
{
new
(
fItemArray
+
fCount
+
i
)
T
(
t
[
i
]
)
;
}
fCount
+
=
n
;
return
fItemArray
+
fCount
-
n
;
}
void
pop_back
(
)
{
SkASSERT
(
fCount
>
0
)
;
-
-
fCount
;
fItemArray
[
fCount
]
.
~
T
(
)
;
this
-
>
checkRealloc
(
0
)
;
}
void
pop_back_n
(
int
n
)
{
SkASSERT
(
n
>
=
0
)
;
SkASSERT
(
fCount
>
=
n
)
;
fCount
-
=
n
;
for
(
int
i
=
0
;
i
<
n
;
+
+
i
)
{
fItemArray
[
fCount
+
i
]
.
~
T
(
)
;
}
this
-
>
checkRealloc
(
0
)
;
}
void
resize_back
(
int
newCount
)
{
SkASSERT
(
newCount
>
=
0
)
;
if
(
newCount
>
fCount
)
{
this
-
>
push_back_n
(
newCount
-
fCount
)
;
}
else
if
(
newCount
<
fCount
)
{
this
-
>
pop_back_n
(
fCount
-
newCount
)
;
}
}
void
swap
(
SkTArray
*
that
)
{
if
(
this
=
=
that
)
{
return
;
}
if
(
this
-
>
fPreAllocMemArray
!
=
this
-
>
fItemArray
&
&
that
-
>
fPreAllocMemArray
!
=
that
-
>
fItemArray
)
{
SkTSwap
(
fItemArray
that
-
>
fItemArray
)
;
SkTSwap
(
fCount
that
-
>
fCount
)
;
SkTSwap
(
fAllocCount
that
-
>
fAllocCount
)
;
}
else
{
SkTArray
copy
(
*
that
)
;
*
that
=
*
this
;
*
this
=
copy
;
}
}
T
*
begin
(
)
{
return
fItemArray
;
}
const
T
*
begin
(
)
const
{
return
fItemArray
;
}
T
*
end
(
)
{
return
fItemArray
?
fItemArray
+
fCount
:
NULL
;
}
const
T
*
end
(
)
const
{
return
fItemArray
?
fItemArray
+
fCount
:
NULL
;
}
T
&
operator
[
]
(
int
i
)
{
SkASSERT
(
i
<
fCount
)
;
SkASSERT
(
i
>
=
0
)
;
return
fItemArray
[
i
]
;
}
const
T
&
operator
[
]
(
int
i
)
const
{
SkASSERT
(
i
<
fCount
)
;
SkASSERT
(
i
>
=
0
)
;
return
fItemArray
[
i
]
;
}
T
&
front
(
)
{
SkASSERT
(
fCount
>
0
)
;
return
fItemArray
[
0
]
;
}
const
T
&
front
(
)
const
{
SkASSERT
(
fCount
>
0
)
;
return
fItemArray
[
0
]
;
}
T
&
back
(
)
{
SkASSERT
(
fCount
)
;
return
fItemArray
[
fCount
-
1
]
;
}
const
T
&
back
(
)
const
{
SkASSERT
(
fCount
>
0
)
;
return
fItemArray
[
fCount
-
1
]
;
}
T
&
fromBack
(
int
i
)
{
SkASSERT
(
i
>
=
0
)
;
SkASSERT
(
i
<
fCount
)
;
return
fItemArray
[
fCount
-
i
-
1
]
;
}
const
T
&
fromBack
(
int
i
)
const
{
SkASSERT
(
i
>
=
0
)
;
SkASSERT
(
i
<
fCount
)
;
return
fItemArray
[
fCount
-
i
-
1
]
;
}
bool
operator
=
=
(
const
SkTArray
<
T
MEM_COPY
>
&
right
)
const
{
int
leftCount
=
this
-
>
count
(
)
;
if
(
leftCount
!
=
right
.
count
(
)
)
{
return
false
;
}
for
(
int
index
=
0
;
index
<
leftCount
;
+
+
index
)
{
if
(
fItemArray
[
index
]
!
=
right
.
fItemArray
[
index
]
)
{
return
false
;
}
}
return
true
;
}
bool
operator
!
=
(
const
SkTArray
<
T
MEM_COPY
>
&
right
)
const
{
return
!
(
*
this
=
=
right
)
;
}
protected
:
template
<
int
N
>
SkTArray
(
SkAlignedSTStorage
<
N
T
>
*
storage
)
{
this
-
>
init
(
NULL
0
storage
-
>
get
(
)
N
)
;
}
template
<
int
N
>
SkTArray
(
const
SkTArray
&
array
SkAlignedSTStorage
<
N
T
>
*
storage
)
{
this
-
>
init
(
array
.
fItemArray
array
.
fCount
storage
-
>
get
(
)
N
)
;
}
template
<
int
N
>
SkTArray
(
const
T
*
array
int
count
SkAlignedSTStorage
<
N
T
>
*
storage
)
{
this
-
>
init
(
array
count
storage
-
>
get
(
)
N
)
;
}
void
init
(
const
T
*
array
int
count
void
*
preAllocStorage
int
preAllocOrReserveCount
)
{
SkASSERT
(
count
>
=
0
)
;
SkASSERT
(
preAllocOrReserveCount
>
=
0
)
;
fCount
=
count
;
fReserveCount
=
(
preAllocOrReserveCount
>
0
)
?
preAllocOrReserveCount
:
gMIN_ALLOC_COUNT
;
fPreAllocMemArray
=
preAllocStorage
;
if
(
fReserveCount
>
=
fCount
&
&
preAllocStorage
)
{
fAllocCount
=
fReserveCount
;
fMemArray
=
preAllocStorage
;
}
else
{
fAllocCount
=
SkMax32
(
fCount
fReserveCount
)
;
fMemArray
=
sk_malloc_throw
(
fAllocCount
*
sizeof
(
T
)
)
;
}
this
-
>
copy
(
array
)
;
}
private
:
template
<
bool
E
=
MEM_COPY
>
SK_WHEN
(
E
void
)
copy
(
const
T
*
src
)
{
sk_careful_memcpy
(
fMemArray
src
fCount
*
sizeof
(
T
)
)
;
}
template
<
bool
E
=
MEM_COPY
>
SK_WHEN
(
E
void
)
move
(
int
dst
int
src
)
{
memcpy
(
&
fItemArray
[
dst
]
&
fItemArray
[
src
]
sizeof
(
T
)
)
;
}
template
<
bool
E
=
MEM_COPY
>
SK_WHEN
(
E
void
)
move
(
char
*
dst
)
{
sk_careful_memcpy
(
dst
fMemArray
fCount
*
sizeof
(
T
)
)
;
}
template
<
bool
E
=
MEM_COPY
>
SK_WHEN
(
!
E
void
)
copy
(
const
T
*
src
)
{
for
(
int
i
=
0
;
i
<
fCount
;
+
+
i
)
{
new
(
fItemArray
+
i
)
T
(
src
[
i
]
)
;
}
}
template
<
bool
E
=
MEM_COPY
>
SK_WHEN
(
!
E
void
)
move
(
int
dst
int
src
)
{
new
(
&
fItemArray
[
dst
]
)
T
(
std__move
(
fItemArray
[
src
]
)
)
;
fItemArray
[
src
]
.
~
T
(
)
;
}
template
<
bool
E
=
MEM_COPY
>
SK_WHEN
(
!
E
void
)
move
(
char
*
dst
)
{
for
(
int
i
=
0
;
i
<
fCount
;
+
+
i
)
{
new
(
dst
+
sizeof
(
T
)
*
i
)
T
(
std__move
(
fItemArray
[
i
]
)
)
;
fItemArray
[
i
]
.
~
T
(
)
;
}
}
static
const
int
gMIN_ALLOC_COUNT
=
8
;
void
*
push_back_raw
(
int
n
)
{
this
-
>
checkRealloc
(
n
)
;
void
*
ptr
=
fItemArray
+
fCount
;
fCount
+
=
n
;
return
ptr
;
}
inline
void
checkRealloc
(
int
delta
)
{
SkASSERT
(
fCount
>
=
0
)
;
SkASSERT
(
fAllocCount
>
=
0
)
;
SkASSERT
(
-
delta
<
=
fCount
)
;
int
newCount
=
fCount
+
delta
;
int
newAllocCount
=
fAllocCount
;
if
(
newCount
>
fAllocCount
|
|
newCount
<
(
fAllocCount
/
3
)
)
{
newAllocCount
=
SkMax32
(
newCount
+
(
(
newCount
+
1
)
>
>
1
)
fReserveCount
)
;
}
if
(
newAllocCount
!
=
fAllocCount
)
{
fAllocCount
=
newAllocCount
;
char
*
newMemArray
;
if
(
fAllocCount
=
=
fReserveCount
&
&
fPreAllocMemArray
)
{
newMemArray
=
(
char
*
)
fPreAllocMemArray
;
}
else
{
newMemArray
=
(
char
*
)
sk_malloc_throw
(
fAllocCount
*
sizeof
(
T
)
)
;
}
this
-
>
move
(
newMemArray
)
;
if
(
fMemArray
!
=
fPreAllocMemArray
)
{
sk_free
(
fMemArray
)
;
}
fMemArray
=
newMemArray
;
}
}
int
fReserveCount
;
int
fCount
;
int
fAllocCount
;
void
*
fPreAllocMemArray
;
union
{
T
*
fItemArray
;
void
*
fMemArray
;
}
;
}
;
template
<
int
N
typename
T
bool
MEM_COPY
=
false
>
class
SkSTArray
:
public
SkTArray
<
T
MEM_COPY
>
{
private
:
typedef
SkTArray
<
T
MEM_COPY
>
INHERITED
;
public
:
SkSTArray
(
)
:
INHERITED
(
&
fStorage
)
{
}
SkSTArray
(
const
SkSTArray
&
array
)
:
INHERITED
(
array
&
fStorage
)
{
}
explicit
SkSTArray
(
const
INHERITED
&
array
)
:
INHERITED
(
array
&
fStorage
)
{
}
explicit
SkSTArray
(
int
reserveCount
)
:
INHERITED
(
reserveCount
)
{
}
SkSTArray
(
const
T
*
array
int
count
)
:
INHERITED
(
array
count
&
fStorage
)
{
}
SkSTArray
&
operator
=
(
const
SkSTArray
&
array
)
{
return
*
this
=
*
(
const
INHERITED
*
)
&
array
;
}
SkSTArray
&
operator
=
(
const
INHERITED
&
array
)
{
INHERITED
:
:
operator
=
(
array
)
;
return
*
this
;
}
private
:
SkAlignedSTStorage
<
N
T
>
fStorage
;
}
;
#
endif
