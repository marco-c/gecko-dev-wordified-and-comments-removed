#
ifndef
SkFloatingPoint_DEFINED
#
define
SkFloatingPoint_DEFINED
#
include
"
.
.
/
private
/
SkFloatBits
.
h
"
#
include
"
SkTypes
.
h
"
#
include
"
SkSafe_math
.
h
"
#
include
<
float
.
h
>
#
include
<
math
.
h
>
#
include
<
cstring
>
#
include
<
limits
>
#
if
SK_CPU_SSE_LEVEL
>
=
SK_CPU_SSE_LEVEL_SSE1
#
include
<
xmmintrin
.
h
>
#
elif
defined
(
SK_ARM_HAS_NEON
)
#
include
<
arm_neon
.
h
>
#
endif
#
if
defined
(
__unix__
)
|
|
(
defined
(
__APPLE__
)
&
&
defined
(
__MACH__
)
)
#
include
<
unistd
.
h
>
#
endif
static
inline
float
sk_float_pow
(
float
base
float
exp
)
{
return
powf
(
base
exp
)
;
}
#
define
sk_float_sqrt
(
x
)
sqrtf
(
x
)
#
define
sk_float_sin
(
x
)
sinf
(
x
)
#
define
sk_float_cos
(
x
)
cosf
(
x
)
#
define
sk_float_tan
(
x
)
tanf
(
x
)
#
define
sk_float_floor
(
x
)
floorf
(
x
)
#
define
sk_float_ceil
(
x
)
ceilf
(
x
)
#
define
sk_float_trunc
(
x
)
truncf
(
x
)
#
ifdef
SK_BUILD_FOR_MAC
#
define
sk_float_acos
(
x
)
static_cast
<
float
>
(
acos
(
x
)
)
#
define
sk_float_asin
(
x
)
static_cast
<
float
>
(
asin
(
x
)
)
#
else
#
define
sk_float_acos
(
x
)
acosf
(
x
)
#
define
sk_float_asin
(
x
)
asinf
(
x
)
#
endif
#
define
sk_float_atan2
(
y
x
)
atan2f
(
y
x
)
#
define
sk_float_abs
(
x
)
fabsf
(
x
)
#
define
sk_float_copysign
(
x
y
)
copysignf
(
x
y
)
#
define
sk_float_mod
(
x
y
)
fmodf
(
x
y
)
#
define
sk_float_exp
(
x
)
expf
(
x
)
#
define
sk_float_log
(
x
)
logf
(
x
)
#
define
sk_float_round
(
x
)
sk_float_floor
(
(
x
)
+
0
.
5f
)
#
ifdef
SK_BUILD_FOR_ANDROID
static
inline
float
sk_float_log2
(
float
x
)
{
const
double
inv_ln_2
=
1
.
44269504088896
;
return
(
float
)
(
log
(
x
)
*
inv_ln_2
)
;
}
#
else
#
define
sk_float_log2
(
x
)
log2f
(
x
)
#
endif
static
inline
bool
sk_float_isfinite
(
float
x
)
{
return
SkFloatBits_IsFinite
(
SkFloat2Bits
(
x
)
)
;
}
static
inline
bool
sk_float_isinf
(
float
x
)
{
return
SkFloatBits_IsInf
(
SkFloat2Bits
(
x
)
)
;
}
#
ifdef
SK_BUILD_FOR_WIN
#
define
sk_float_isnan
(
x
)
_isnan
(
x
)
#
elif
defined
(
__clang__
)
|
|
defined
(
__GNUC__
)
#
define
sk_float_isnan
(
x
)
__builtin_isnan
(
x
)
#
else
#
define
sk_float_isnan
(
x
)
isnan
(
x
)
#
endif
#
define
sk_double_isnan
(
a
)
sk_float_isnan
(
a
)
#
define
SK_MaxS32FitsInFloat
2147483520
#
define
SK_MinS32FitsInFloat
-
SK_MaxS32FitsInFloat
#
define
SK_MaxS64FitsInFloat
(
SK_MaxS64
>
>
(
63
-
24
)
<
<
(
63
-
24
)
)
/
/
0x7fffff8000000000
#
define
SK_MinS64FitsInFloat
-
SK_MaxS64FitsInFloat
static
inline
int
sk_float_saturate2int
(
float
x
)
{
x
=
SkTMin
<
float
>
(
x
SK_MaxS32FitsInFloat
)
;
x
=
SkTMax
<
float
>
(
x
SK_MinS32FitsInFloat
)
;
return
(
int
)
x
;
}
static
inline
int
sk_double_saturate2int
(
double
x
)
{
x
=
SkTMin
<
double
>
(
x
SK_MaxS32
)
;
x
=
SkTMax
<
double
>
(
x
SK_MinS32
)
;
return
(
int
)
x
;
}
static
inline
int64_t
sk_float_saturate2int64
(
float
x
)
{
x
=
SkTMin
<
float
>
(
x
SK_MaxS64FitsInFloat
)
;
x
=
SkTMax
<
float
>
(
x
SK_MinS64FitsInFloat
)
;
return
(
int64_t
)
x
;
}
#
define
sk_float_floor2int
(
x
)
sk_float_saturate2int
(
sk_float_floor
(
x
)
)
#
define
sk_float_round2int
(
x
)
sk_float_saturate2int
(
sk_float_floor
(
(
x
)
+
0
.
5f
)
)
#
define
sk_float_ceil2int
(
x
)
sk_float_saturate2int
(
sk_float_ceil
(
x
)
)
#
define
sk_float_floor2int_no_saturate
(
x
)
(
int
)
sk_float_floor
(
x
)
#
define
sk_float_round2int_no_saturate
(
x
)
(
int
)
sk_float_floor
(
(
x
)
+
0
.
5f
)
#
define
sk_float_ceil2int_no_saturate
(
x
)
(
int
)
sk_float_ceil
(
x
)
#
define
sk_double_floor
(
x
)
floor
(
x
)
#
define
sk_double_round
(
x
)
floor
(
(
x
)
+
0
.
5
)
#
define
sk_double_ceil
(
x
)
ceil
(
x
)
#
define
sk_double_floor2int
(
x
)
(
int
)
floor
(
x
)
#
define
sk_double_round2int
(
x
)
(
int
)
floor
(
(
x
)
+
0
.
5
)
#
define
sk_double_ceil2int
(
x
)
(
int
)
ceil
(
x
)
#
if
defined
(
__clang__
)
&
&
(
__clang_major__
*
1000
+
__clang_minor__
)
>
=
3007
__attribute__
(
(
no_sanitize
(
"
float
-
cast
-
overflow
"
)
)
)
#
endif
static
inline
float
sk_double_to_float
(
double
x
)
{
return
static_cast
<
float
>
(
x
)
;
}
#
define
SK_FloatNaN
std
:
:
numeric_limits
<
float
>
:
:
quiet_NaN
(
)
#
define
SK_FloatInfinity
(
+
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
#
define
SK_FloatNegativeInfinity
(
-
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
bool
sk_floats_are_unit
(
const
float
array
[
]
size_t
count
)
;
static
inline
float
sk_float_rsqrt_portable
(
float
x
)
{
int
i
;
memcpy
(
&
i
&
x
4
)
;
i
=
0x5F1FFFF9
-
(
i
>
>
1
)
;
float
estimate
;
memcpy
(
&
estimate
&
i
4
)
;
const
float
estimate_sq
=
estimate
*
estimate
;
estimate
*
=
0
.
703952253f
*
(
2
.
38924456f
-
x
*
estimate_sq
)
;
return
estimate
;
}
static
inline
float
sk_float_rsqrt
(
float
x
)
{
#
if
SK_CPU_SSE_LEVEL
>
=
SK_CPU_SSE_LEVEL_SSE1
return
_mm_cvtss_f32
(
_mm_rsqrt_ss
(
_mm_set_ss
(
x
)
)
)
;
#
elif
defined
(
SK_ARM_HAS_NEON
)
const
float32x2_t
xx
=
vdup_n_f32
(
x
)
;
float32x2_t
estimate
=
vrsqrte_f32
(
xx
)
;
const
float32x2_t
estimate_sq
=
vmul_f32
(
estimate
estimate
)
;
estimate
=
vmul_f32
(
estimate
vrsqrts_f32
(
xx
estimate_sq
)
)
;
return
vget_lane_f32
(
estimate
0
)
;
#
else
return
sk_float_rsqrt_portable
(
x
)
;
#
endif
}
#
ifdef
FLT_DECIMAL_DIG
#
define
SK_FLT_DECIMAL_DIG
FLT_DECIMAL_DIG
#
else
#
define
SK_FLT_DECIMAL_DIG
9
#
endif
#
ifdef
__clang__
__attribute__
(
(
no_sanitize
(
"
float
-
divide
-
by
-
zero
"
)
)
)
#
endif
static
inline
float
sk_ieee_float_divide
(
float
numer
float
denom
)
{
return
numer
/
denom
;
}
#
ifdef
__clang__
__attribute__
(
(
no_sanitize
(
"
float
-
divide
-
by
-
zero
"
)
)
)
#
endif
static
inline
double
sk_ieee_double_divide
(
double
numer
double
denom
)
{
return
numer
/
denom
;
}
static
inline
float
sk_ieee_float_divide_TODO_IS_DIVIDE_BY_ZERO_SAFE_HERE
(
float
n
float
d
)
{
return
sk_ieee_float_divide
(
n
d
)
;
}
static
inline
float
sk_ieee_double_divide_TODO_IS_DIVIDE_BY_ZERO_SAFE_HERE
(
double
n
double
d
)
{
return
sk_ieee_double_divide
(
n
d
)
;
}
#
endif
