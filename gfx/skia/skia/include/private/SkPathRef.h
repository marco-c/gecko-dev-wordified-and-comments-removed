#
ifndef
SkPathRef_DEFINED
#
define
SkPathRef_DEFINED
#
include
"
SkMatrix
.
h
"
#
include
"
SkMutex
.
h
"
#
include
"
SkPoint
.
h
"
#
include
"
SkRRect
.
h
"
#
include
"
SkRect
.
h
"
#
include
"
SkRefCnt
.
h
"
#
include
"
SkTDArray
.
h
"
#
include
"
SkTemplates
.
h
"
#
include
"
SkTo
.
h
"
#
include
<
atomic
>
#
include
<
limits
>
class
SkRBuffer
;
class
SkWBuffer
;
class
SK_API
SkPathRef
final
:
public
SkNVRefCnt
<
SkPathRef
>
{
public
:
class
Editor
{
public
:
Editor
(
sk_sp
<
SkPathRef
>
*
pathRef
int
incReserveVerbs
=
0
int
incReservePoints
=
0
)
;
~
Editor
(
)
{
SkDEBUGCODE
(
fPathRef
-
>
fEditorsAttached
-
-
;
)
}
SkPoint
*
points
(
)
{
return
fPathRef
-
>
getPoints
(
)
;
}
const
SkPoint
*
points
(
)
const
{
return
fPathRef
-
>
points
(
)
;
}
SkPoint
*
atPoint
(
int
i
)
{
SkASSERT
(
(
unsigned
)
i
<
(
unsigned
)
fPathRef
-
>
fPointCnt
)
;
return
this
-
>
points
(
)
+
i
;
}
const
SkPoint
*
atPoint
(
int
i
)
const
{
SkASSERT
(
(
unsigned
)
i
<
(
unsigned
)
fPathRef
-
>
fPointCnt
)
;
return
this
-
>
points
(
)
+
i
;
}
SkPoint
*
growForVerb
(
int
verb
SkScalar
weight
=
0
)
{
SkDEBUGCODE
(
fPathRef
-
>
validate
(
)
;
)
return
fPathRef
-
>
growForVerb
(
verb
weight
)
;
}
SkPoint
*
growForRepeatedVerb
(
int
verb
int
numVbs
SkScalar
*
*
weights
=
nullptr
)
{
return
fPathRef
-
>
growForRepeatedVerb
(
verb
numVbs
weights
)
;
}
void
resetToSize
(
int
newVerbCnt
int
newPointCnt
int
newConicCount
)
{
fPathRef
-
>
resetToSize
(
newVerbCnt
newPointCnt
newConicCount
)
;
}
SkPathRef
*
pathRef
(
)
{
return
fPathRef
;
}
void
setIsOval
(
bool
isOval
bool
isCCW
unsigned
start
)
{
fPathRef
-
>
setIsOval
(
isOval
isCCW
start
)
;
}
void
setIsRRect
(
bool
isRRect
bool
isCCW
unsigned
start
)
{
fPathRef
-
>
setIsRRect
(
isRRect
isCCW
start
)
;
}
void
setBounds
(
const
SkRect
&
rect
)
{
fPathRef
-
>
setBounds
(
rect
)
;
}
private
:
SkPathRef
*
fPathRef
;
}
;
class
SK_API
Iter
{
public
:
Iter
(
)
;
Iter
(
const
SkPathRef
&
)
;
void
setPathRef
(
const
SkPathRef
&
)
;
uint8_t
next
(
SkPoint
pts
[
4
]
)
;
uint8_t
peek
(
)
const
;
SkScalar
conicWeight
(
)
const
{
return
*
fConicWeights
;
}
private
:
const
SkPoint
*
fPts
;
const
uint8_t
*
fVerbs
;
const
uint8_t
*
fVerbStop
;
const
SkScalar
*
fConicWeights
;
}
;
public
:
static
SkPathRef
*
CreateEmpty
(
)
;
bool
isFinite
(
)
const
{
if
(
fBoundsIsDirty
)
{
this
-
>
computeBounds
(
)
;
}
return
SkToBool
(
fIsFinite
)
;
}
uint32_t
getSegmentMasks
(
)
const
{
return
fSegmentMask
;
}
bool
isOval
(
SkRect
*
rect
bool
*
isCCW
unsigned
*
start
)
const
{
if
(
fIsOval
)
{
if
(
rect
)
{
*
rect
=
this
-
>
getBounds
(
)
;
}
if
(
isCCW
)
{
*
isCCW
=
SkToBool
(
fRRectOrOvalIsCCW
)
;
}
if
(
start
)
{
*
start
=
fRRectOrOvalStartIdx
;
}
}
return
SkToBool
(
fIsOval
)
;
}
bool
isRRect
(
SkRRect
*
rrect
bool
*
isCCW
unsigned
*
start
)
const
{
if
(
fIsRRect
)
{
if
(
rrect
)
{
*
rrect
=
this
-
>
getRRect
(
)
;
}
if
(
isCCW
)
{
*
isCCW
=
SkToBool
(
fRRectOrOvalIsCCW
)
;
}
if
(
start
)
{
*
start
=
fRRectOrOvalStartIdx
;
}
}
return
SkToBool
(
fIsRRect
)
;
}
bool
hasComputedBounds
(
)
const
{
return
!
fBoundsIsDirty
;
}
const
SkRect
&
getBounds
(
)
const
{
if
(
fBoundsIsDirty
)
{
this
-
>
computeBounds
(
)
;
}
return
fBounds
;
}
SkRRect
getRRect
(
)
const
;
static
void
CreateTransformedCopy
(
sk_sp
<
SkPathRef
>
*
dst
const
SkPathRef
&
src
const
SkMatrix
&
matrix
)
;
static
SkPathRef
*
CreateFromBuffer
(
SkRBuffer
*
buffer
)
;
static
void
Rewind
(
sk_sp
<
SkPathRef
>
*
pathRef
)
;
~
SkPathRef
(
)
;
int
countPoints
(
)
const
{
return
fPointCnt
;
}
int
countVerbs
(
)
const
{
return
fVerbCnt
;
}
int
countWeights
(
)
const
{
return
fConicWeights
.
count
(
)
;
}
const
uint8_t
*
verbs
(
)
const
{
return
fVerbs
;
}
const
uint8_t
*
verbsMemBegin
(
)
const
{
return
this
-
>
verbs
(
)
-
fVerbCnt
;
}
const
SkPoint
*
points
(
)
const
{
return
fPoints
;
}
const
SkPoint
*
pointsEnd
(
)
const
{
return
this
-
>
points
(
)
+
this
-
>
countPoints
(
)
;
}
const
SkScalar
*
conicWeights
(
)
const
{
return
fConicWeights
.
begin
(
)
;
}
const
SkScalar
*
conicWeightsEnd
(
)
const
{
return
fConicWeights
.
end
(
)
;
}
uint8_t
atVerb
(
int
index
)
const
{
SkASSERT
(
(
unsigned
)
index
<
(
unsigned
)
fVerbCnt
)
;
return
this
-
>
verbs
(
)
[
~
index
]
;
}
const
SkPoint
&
atPoint
(
int
index
)
const
{
SkASSERT
(
(
unsigned
)
index
<
(
unsigned
)
fPointCnt
)
;
return
this
-
>
points
(
)
[
index
]
;
}
bool
operator
=
=
(
const
SkPathRef
&
ref
)
const
;
void
writeToBuffer
(
SkWBuffer
*
buffer
)
const
;
uint32_t
writeSize
(
)
const
;
void
interpolate
(
const
SkPathRef
&
ending
SkScalar
weight
SkPathRef
*
out
)
const
;
uint32_t
genID
(
)
const
;
class
GenIDChangeListener
:
public
SkRefCnt
{
public
:
GenIDChangeListener
(
)
:
fShouldUnregisterFromPath
(
false
)
{
}
virtual
~
GenIDChangeListener
(
)
{
}
virtual
void
onChange
(
)
=
0
;
void
markShouldUnregisterFromPath
(
)
{
fShouldUnregisterFromPath
.
store
(
true
std
:
:
memory_order_relaxed
)
;
}
bool
shouldUnregisterFromPath
(
)
{
return
fShouldUnregisterFromPath
.
load
(
std
:
:
memory_order_acquire
)
;
}
private
:
std
:
:
atomic
<
bool
>
fShouldUnregisterFromPath
;
}
;
void
addGenIDChangeListener
(
sk_sp
<
GenIDChangeListener
>
)
;
bool
isValid
(
)
const
;
SkDEBUGCODE
(
void
validate
(
)
const
{
SkASSERT
(
this
-
>
isValid
(
)
)
;
}
)
private
:
enum
SerializationOffsets
{
kLegacyRRectOrOvalStartIdx_SerializationShift
=
28
kLegacyRRectOrOvalIsCCW_SerializationShift
=
27
kLegacyIsRRect_SerializationShift
=
26
kIsFinite_SerializationShift
=
25
kLegacyIsOval_SerializationShift
=
24
kSegmentMask_SerializationShift
=
0
}
;
SkPathRef
(
)
{
fBoundsIsDirty
=
true
;
fPointCnt
=
0
;
fVerbCnt
=
0
;
fVerbs
=
nullptr
;
fPoints
=
nullptr
;
fFreeSpace
=
0
;
fGenerationID
=
kEmptyGenID
;
fSegmentMask
=
0
;
fIsOval
=
false
;
fIsRRect
=
false
;
fRRectOrOvalIsCCW
=
false
;
fRRectOrOvalStartIdx
=
0xAC
;
SkDEBUGCODE
(
fEditorsAttached
.
store
(
0
)
;
)
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
void
copy
(
const
SkPathRef
&
ref
int
additionalReserveVerbs
int
additionalReservePoints
)
;
unsigned
computeSegmentMask
(
)
const
;
static
bool
ComputePtBounds
(
SkRect
*
bounds
const
SkPathRef
&
ref
)
{
return
bounds
-
>
setBoundsCheck
(
ref
.
points
(
)
ref
.
countPoints
(
)
)
;
}
void
computeBounds
(
)
const
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
SkASSERT
(
fBoundsIsDirty
)
;
fIsFinite
=
ComputePtBounds
(
&
fBounds
*
this
)
;
fBoundsIsDirty
=
false
;
}
void
setBounds
(
const
SkRect
&
rect
)
{
SkASSERT
(
rect
.
fLeft
<
=
rect
.
fRight
&
&
rect
.
fTop
<
=
rect
.
fBottom
)
;
fBounds
=
rect
;
fBoundsIsDirty
=
false
;
fIsFinite
=
fBounds
.
isFinite
(
)
;
}
void
incReserve
(
int
additionalVerbs
int
additionalPoints
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
size_t
space
=
additionalVerbs
*
sizeof
(
uint8_t
)
+
additionalPoints
*
sizeof
(
SkPoint
)
;
this
-
>
makeSpace
(
space
)
;
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
void
resetToSize
(
int
verbCount
int
pointCount
int
conicCount
int
reserveVerbs
=
0
int
reservePoints
=
0
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
fBoundsIsDirty
=
true
;
fGenerationID
=
0
;
fSegmentMask
=
0
;
fIsOval
=
false
;
fIsRRect
=
false
;
size_t
newSize
=
sizeof
(
uint8_t
)
*
verbCount
+
sizeof
(
SkPoint
)
*
pointCount
;
size_t
newReserve
=
sizeof
(
uint8_t
)
*
reserveVerbs
+
sizeof
(
SkPoint
)
*
reservePoints
;
size_t
minSize
=
newSize
+
newReserve
;
ptrdiff_t
sizeDelta
=
this
-
>
currSize
(
)
-
minSize
;
if
(
sizeDelta
<
0
|
|
static_cast
<
size_t
>
(
sizeDelta
)
>
=
3
*
minSize
)
{
sk_free
(
fPoints
)
;
fPoints
=
nullptr
;
fVerbs
=
nullptr
;
fFreeSpace
=
0
;
fVerbCnt
=
0
;
fPointCnt
=
0
;
this
-
>
makeSpace
(
minSize
true
)
;
fVerbCnt
=
verbCount
;
fPointCnt
=
pointCount
;
fFreeSpace
-
=
newSize
;
}
else
{
fPointCnt
=
pointCount
;
fVerbCnt
=
verbCount
;
fFreeSpace
=
this
-
>
currSize
(
)
-
minSize
;
}
fConicWeights
.
setCount
(
conicCount
)
;
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
SkPoint
*
growForRepeatedVerb
(
int
verb
int
numVbs
SkScalar
*
*
weights
)
;
SkPoint
*
growForVerb
(
int
verb
SkScalar
weight
)
;
void
makeSpace
(
size_t
size
bool
exact
=
false
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
if
(
size
<
=
fFreeSpace
)
{
return
;
}
size_t
growSize
=
size
-
fFreeSpace
;
size_t
oldSize
=
this
-
>
currSize
(
)
;
if
(
!
exact
)
{
growSize
=
(
growSize
+
7
)
&
~
static_cast
<
size_t
>
(
7
)
;
if
(
growSize
<
oldSize
)
{
growSize
=
oldSize
;
}
if
(
growSize
<
kMinSize
)
{
growSize
=
kMinSize
;
}
}
constexpr
size_t
maxSize
=
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
;
size_t
newSize
;
if
(
growSize
<
=
maxSize
-
oldSize
)
{
newSize
=
oldSize
+
growSize
;
}
else
{
SK_ABORT
(
"
Path
too
big
.
"
)
;
}
fPoints
=
reinterpret_cast
<
SkPoint
*
>
(
sk_realloc_throw
(
fPoints
newSize
)
)
;
size_t
oldVerbSize
=
fVerbCnt
*
sizeof
(
uint8_t
)
;
void
*
newVerbsDst
=
SkTAddOffset
<
void
>
(
fPoints
newSize
-
oldVerbSize
)
;
void
*
oldVerbsSrc
=
SkTAddOffset
<
void
>
(
fPoints
oldSize
-
oldVerbSize
)
;
memmove
(
newVerbsDst
oldVerbsSrc
oldVerbSize
)
;
fVerbs
=
SkTAddOffset
<
uint8_t
>
(
fPoints
newSize
)
;
fFreeSpace
+
=
growSize
;
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
uint8_t
*
verbsMemWritable
(
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
return
fVerbs
-
fVerbCnt
;
}
size_t
currSize
(
)
const
{
return
reinterpret_cast
<
intptr_t
>
(
fVerbs
)
-
reinterpret_cast
<
intptr_t
>
(
fPoints
)
;
}
friend
SkPathRef
*
sk_create_empty_pathref
(
)
;
void
setIsOval
(
bool
isOval
bool
isCCW
unsigned
start
)
{
fIsOval
=
isOval
;
fRRectOrOvalIsCCW
=
isCCW
;
fRRectOrOvalStartIdx
=
SkToU8
(
start
)
;
}
void
setIsRRect
(
bool
isRRect
bool
isCCW
unsigned
start
)
{
fIsRRect
=
isRRect
;
fRRectOrOvalIsCCW
=
isCCW
;
fRRectOrOvalStartIdx
=
SkToU8
(
start
)
;
}
SkPoint
*
getPoints
(
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
fIsOval
=
false
;
fIsRRect
=
false
;
return
fPoints
;
}
const
SkPoint
*
getPoints
(
)
const
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
return
fPoints
;
}
void
callGenIDChangeListeners
(
)
;
enum
{
kMinSize
=
256
}
;
mutable
SkRect
fBounds
;
SkPoint
*
fPoints
;
uint8_t
*
fVerbs
;
int
fVerbCnt
;
int
fPointCnt
;
size_t
fFreeSpace
;
SkTDArray
<
SkScalar
>
fConicWeights
;
enum
{
kEmptyGenID
=
1
}
;
mutable
uint32_t
fGenerationID
;
SkDEBUGCODE
(
std
:
:
atomic
<
int
>
fEditorsAttached
;
)
SkMutex
fGenIDChangeListenersMutex
;
SkTDArray
<
GenIDChangeListener
*
>
fGenIDChangeListeners
;
mutable
uint8_t
fBoundsIsDirty
;
mutable
bool
fIsFinite
;
bool
fIsOval
;
bool
fIsRRect
;
bool
fRRectOrOvalIsCCW
;
uint8_t
fRRectOrOvalStartIdx
;
uint8_t
fSegmentMask
;
friend
class
PathRefTest_Private
;
friend
class
ForceIsRRect_Private
;
friend
class
SkPath
;
friend
class
SkPathPriv
;
}
;
#
endif
