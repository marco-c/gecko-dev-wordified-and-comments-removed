#
ifndef
SkPathRef_DEFINED
#
define
SkPathRef_DEFINED
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
SkIDChangeListener
.
h
"
#
include
"
include
/
private
/
base
/
SkDebug
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
<
atomic
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
tuple
>
#
include
<
utility
>
class
SkMatrix
;
class
SkRRect
;
struct
SkPathVerbAnalysis
{
bool
valid
;
int
points
weights
;
unsigned
segmentMask
;
}
;
SkPathVerbAnalysis
sk_path_analyze_verbs
(
const
uint8_t
verbs
[
]
int
count
)
;
class
SK_API
SkPathRef
final
:
public
SkNVRefCnt
<
SkPathRef
>
{
public
:
using
PointsArray
=
skia_private
:
:
STArray
<
4
SkPoint
>
;
using
VerbsArray
=
skia_private
:
:
STArray
<
4
uint8_t
>
;
using
ConicWeightsArray
=
skia_private
:
:
STArray
<
2
SkScalar
>
;
enum
class
PathType
:
uint8_t
{
kGeneral
kOval
kRRect
}
;
SkPathRef
(
PointsArray
points
VerbsArray
verbs
ConicWeightsArray
weights
unsigned
segmentMask
)
:
fPoints
(
std
:
:
move
(
points
)
)
fVerbs
(
std
:
:
move
(
verbs
)
)
fConicWeights
(
std
:
:
move
(
weights
)
)
{
fBoundsIsDirty
=
true
;
fGenerationID
=
0
;
fSegmentMask
=
segmentMask
;
fType
=
PathType
:
:
kGeneral
;
fRRectOrOvalIsCCW
=
false
;
fRRectOrOvalStartIdx
=
0xAC
;
SkDEBUGCODE
(
fEditorsAttached
.
store
(
0
)
;
)
this
-
>
computeBounds
(
)
;
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
class
Editor
{
public
:
Editor
(
sk_sp
<
SkPathRef
>
*
pathRef
int
incReserveVerbs
=
0
int
incReservePoints
=
0
int
incReserveConics
=
0
)
;
~
Editor
(
)
{
SkDEBUGCODE
(
fPathRef
-
>
fEditorsAttached
-
-
;
)
}
SkPoint
*
writablePoints
(
)
{
return
fPathRef
-
>
getWritablePoints
(
)
;
}
const
SkPoint
*
points
(
)
const
{
return
fPathRef
-
>
points
(
)
;
}
SkPoint
*
atPoint
(
int
i
)
{
return
fPathRef
-
>
getWritablePoints
(
)
+
i
;
}
const
SkPoint
*
atPoint
(
int
i
)
const
{
return
&
fPathRef
-
>
fPoints
[
i
]
;
}
SkPoint
*
growForVerb
(
int
verb
SkScalar
weight
=
0
)
{
SkDEBUGCODE
(
fPathRef
-
>
validate
(
)
;
)
return
fPathRef
-
>
growForVerb
(
verb
weight
)
;
}
SkPoint
*
growForRepeatedVerb
(
int
verb
int
numVbs
SkScalar
*
*
weights
=
nullptr
)
{
return
fPathRef
-
>
growForRepeatedVerb
(
verb
numVbs
weights
)
;
}
std
:
:
tuple
<
SkPoint
*
SkScalar
*
>
growForVerbsInPath
(
const
SkPathRef
&
path
)
{
return
fPathRef
-
>
growForVerbsInPath
(
path
)
;
}
void
resetToSize
(
int
newVerbCnt
int
newPointCnt
int
newConicCount
)
{
fPathRef
-
>
resetToSize
(
newVerbCnt
newPointCnt
newConicCount
)
;
}
SkPathRef
*
pathRef
(
)
{
return
fPathRef
;
}
void
setIsOval
(
bool
isCCW
unsigned
start
)
{
fPathRef
-
>
setIsOval
(
isCCW
start
)
;
}
void
setIsRRect
(
bool
isCCW
unsigned
start
)
{
fPathRef
-
>
setIsRRect
(
isCCW
start
)
;
}
void
setBounds
(
const
SkRect
&
rect
)
{
fPathRef
-
>
setBounds
(
rect
)
;
}
private
:
SkPathRef
*
fPathRef
;
}
;
class
SK_API
Iter
{
public
:
Iter
(
)
;
Iter
(
const
SkPathRef
&
)
;
void
setPathRef
(
const
SkPathRef
&
)
;
uint8_t
next
(
SkPoint
pts
[
4
]
)
;
uint8_t
peek
(
)
const
;
SkScalar
conicWeight
(
)
const
{
return
*
fConicWeights
;
}
private
:
const
SkPoint
*
fPts
;
const
uint8_t
*
fVerbs
;
const
uint8_t
*
fVerbStop
;
const
SkScalar
*
fConicWeights
;
}
;
public
:
static
SkPathRef
*
CreateEmpty
(
)
;
bool
isFinite
(
)
const
{
if
(
fBoundsIsDirty
)
{
this
-
>
computeBounds
(
)
;
}
return
SkToBool
(
fIsFinite
)
;
}
uint32_t
getSegmentMasks
(
)
const
{
return
fSegmentMask
;
}
bool
isOval
(
SkRect
*
rect
bool
*
isCCW
unsigned
*
start
)
const
{
if
(
fType
=
=
PathType
:
:
kOval
)
{
if
(
rect
)
{
*
rect
=
this
-
>
getBounds
(
)
;
}
if
(
isCCW
)
{
*
isCCW
=
SkToBool
(
fRRectOrOvalIsCCW
)
;
}
if
(
start
)
{
*
start
=
fRRectOrOvalStartIdx
;
}
}
return
fType
=
=
PathType
:
:
kOval
;
}
bool
isRRect
(
SkRRect
*
rrect
bool
*
isCCW
unsigned
*
start
)
const
;
bool
hasComputedBounds
(
)
const
{
return
!
fBoundsIsDirty
;
}
const
SkRect
&
getBounds
(
)
const
{
if
(
fBoundsIsDirty
)
{
this
-
>
computeBounds
(
)
;
}
return
fBounds
;
}
SkRRect
getRRect
(
)
const
;
static
void
CreateTransformedCopy
(
sk_sp
<
SkPathRef
>
*
dst
const
SkPathRef
&
src
const
SkMatrix
&
matrix
)
;
static
void
Rewind
(
sk_sp
<
SkPathRef
>
*
pathRef
)
;
~
SkPathRef
(
)
;
int
countPoints
(
)
const
{
return
fPoints
.
size
(
)
;
}
int
countVerbs
(
)
const
{
return
fVerbs
.
size
(
)
;
}
int
countWeights
(
)
const
{
return
fConicWeights
.
size
(
)
;
}
size_t
approximateBytesUsed
(
)
const
;
const
uint8_t
*
verbsBegin
(
)
const
{
return
fVerbs
.
begin
(
)
;
}
const
uint8_t
*
verbsEnd
(
)
const
{
return
fVerbs
.
end
(
)
;
}
const
SkPoint
*
points
(
)
const
{
return
fPoints
.
begin
(
)
;
}
const
SkPoint
*
pointsEnd
(
)
const
{
return
this
-
>
points
(
)
+
this
-
>
countPoints
(
)
;
}
const
SkScalar
*
conicWeights
(
)
const
{
return
fConicWeights
.
begin
(
)
;
}
const
SkScalar
*
conicWeightsEnd
(
)
const
{
return
fConicWeights
.
end
(
)
;
}
uint8_t
atVerb
(
int
index
)
const
{
return
fVerbs
[
index
]
;
}
const
SkPoint
&
atPoint
(
int
index
)
const
{
return
fPoints
[
index
]
;
}
bool
operator
=
=
(
const
SkPathRef
&
ref
)
const
;
void
interpolate
(
const
SkPathRef
&
ending
SkScalar
weight
SkPathRef
*
out
)
const
;
uint32_t
genID
(
uint8_t
fillType
)
const
;
void
addGenIDChangeListener
(
sk_sp
<
SkIDChangeListener
>
)
;
int
genIDChangeListenerCount
(
)
;
bool
dataMatchesVerbs
(
)
const
;
bool
isValid
(
)
const
;
SkDEBUGCODE
(
void
validate
(
)
const
{
SkASSERT
(
this
-
>
isValid
(
)
)
;
}
)
void
reset
(
)
;
bool
isInitialEmptyPathRef
(
)
const
{
return
fGenerationID
=
=
kEmptyGenID
;
}
private
:
enum
SerializationOffsets
{
kLegacyRRectOrOvalStartIdx_SerializationShift
=
28
kLegacyRRectOrOvalIsCCW_SerializationShift
=
27
kLegacyIsRRect_SerializationShift
=
26
kIsFinite_SerializationShift
=
25
kLegacyIsOval_SerializationShift
=
24
kSegmentMask_SerializationShift
=
0
}
;
SkPathRef
(
int
numVerbs
=
0
int
numPoints
=
0
int
numConics
=
0
)
{
fBoundsIsDirty
=
true
;
fGenerationID
=
kEmptyGenID
;
fSegmentMask
=
0
;
fType
=
PathType
:
:
kGeneral
;
fRRectOrOvalIsCCW
=
false
;
fRRectOrOvalStartIdx
=
0xAC
;
if
(
numPoints
>
0
)
{
fPoints
.
reserve_exact
(
numPoints
)
;
}
if
(
numVerbs
>
0
)
{
fVerbs
.
reserve_exact
(
numVerbs
)
;
}
if
(
numConics
>
0
)
{
fConicWeights
.
reserve_exact
(
numConics
)
;
}
SkDEBUGCODE
(
fEditorsAttached
.
store
(
0
)
;
)
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
void
copy
(
const
SkPathRef
&
ref
int
additionalReserveVerbs
int
additionalReservePoints
int
additionalReserveConics
)
;
static
bool
ComputePtBounds
(
SkRect
*
bounds
const
SkPathRef
&
ref
)
{
return
bounds
-
>
setBoundsCheck
(
ref
.
points
(
)
ref
.
countPoints
(
)
)
;
}
void
computeBounds
(
)
const
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
SkASSERT
(
fBoundsIsDirty
)
;
fIsFinite
=
ComputePtBounds
(
&
fBounds
*
this
)
;
fBoundsIsDirty
=
false
;
}
void
setBounds
(
const
SkRect
&
rect
)
{
SkASSERT
(
rect
.
fLeft
<
=
rect
.
fRight
&
&
rect
.
fTop
<
=
rect
.
fBottom
)
;
fBounds
=
rect
;
fBoundsIsDirty
=
false
;
fIsFinite
=
fBounds
.
isFinite
(
)
;
}
void
incReserve
(
int
additionalVerbs
int
additionalPoints
int
additionalConics
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
if
(
additionalPoints
>
0
)
{
fPoints
.
reserve
(
fPoints
.
size
(
)
+
additionalPoints
)
;
}
if
(
additionalVerbs
>
0
)
{
fVerbs
.
reserve
(
fVerbs
.
size
(
)
+
additionalVerbs
)
;
}
if
(
additionalConics
>
0
)
{
fConicWeights
.
reserve
(
fConicWeights
.
size
(
)
+
additionalConics
)
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
void
commonReset
(
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
this
-
>
callGenIDChangeListeners
(
)
;
fBoundsIsDirty
=
true
;
fGenerationID
=
0
;
fSegmentMask
=
0
;
fType
=
PathType
:
:
kGeneral
;
}
void
resetToSize
(
int
verbCount
int
pointCount
int
conicCount
int
reserveVerbs
=
0
int
reservePoints
=
0
int
reserveConics
=
0
)
{
this
-
>
commonReset
(
)
;
fPoints
.
reserve_exact
(
pointCount
+
reservePoints
)
;
fPoints
.
resize_back
(
pointCount
)
;
fVerbs
.
reserve_exact
(
verbCount
+
reserveVerbs
)
;
fVerbs
.
resize_back
(
verbCount
)
;
fConicWeights
.
reserve_exact
(
conicCount
+
reserveConics
)
;
fConicWeights
.
resize_back
(
conicCount
)
;
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
SkPoint
*
growForRepeatedVerb
(
int
verb
int
numVbs
SkScalar
*
*
weights
)
;
SkPoint
*
growForVerb
(
int
verb
SkScalar
weight
)
;
std
:
:
tuple
<
SkPoint
*
SkScalar
*
>
growForVerbsInPath
(
const
SkPathRef
&
path
)
;
uint8_t
*
verbsBeginWritable
(
)
{
return
fVerbs
.
begin
(
)
;
}
friend
SkPathRef
*
sk_create_empty_pathref
(
)
;
void
setIsOval
(
bool
isCCW
unsigned
start
)
{
fType
=
PathType
:
:
kOval
;
fRRectOrOvalIsCCW
=
isCCW
;
fRRectOrOvalStartIdx
=
SkToU8
(
start
)
;
}
void
setIsRRect
(
bool
isCCW
unsigned
start
)
{
fType
=
PathType
:
:
kRRect
;
fRRectOrOvalIsCCW
=
isCCW
;
fRRectOrOvalStartIdx
=
SkToU8
(
start
)
;
}
SkPoint
*
getWritablePoints
(
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
fType
=
PathType
:
:
kGeneral
;
return
fPoints
.
begin
(
)
;
}
const
SkPoint
*
getPoints
(
)
const
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
return
fPoints
.
begin
(
)
;
}
void
callGenIDChangeListeners
(
)
;
enum
{
kMinSize
=
256
}
;
mutable
SkRect
fBounds
;
PointsArray
fPoints
;
VerbsArray
fVerbs
;
ConicWeightsArray
fConicWeights
;
enum
{
kEmptyGenID
=
1
}
;
mutable
uint32_t
fGenerationID
;
SkDEBUGCODE
(
std
:
:
atomic
<
int
>
fEditorsAttached
;
)
SkIDChangeListener
:
:
List
fGenIDChangeListeners
;
mutable
uint8_t
fBoundsIsDirty
;
mutable
bool
fIsFinite
;
PathType
fType
;
bool
fRRectOrOvalIsCCW
;
uint8_t
fRRectOrOvalStartIdx
;
uint8_t
fSegmentMask
;
friend
class
PathRefTest_Private
;
friend
class
ForceIsRRect_Private
;
friend
class
SkPath
;
friend
class
SkPathBuilder
;
friend
class
SkPathPriv
;
}
;
#
endif
