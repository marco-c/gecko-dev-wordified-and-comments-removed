#
ifndef
SkPathRef_DEFINED
#
define
SkPathRef_DEFINED
#
include
"
include
/
core
/
SkArc
.
h
"
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkPathTypes
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkRRect
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
SkIDChangeListener
.
h
"
#
include
"
include
/
private
/
base
/
SkDebug
.
h
"
#
include
"
include
/
private
/
base
/
SkSpan_impl
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
<
atomic
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
tuple
>
class
SkMatrix
;
struct
SkPathRectInfo
{
SkRect
fRect
;
SkPathDirection
fDirection
;
uint8_t
fStartIndex
;
}
;
struct
SkPathOvalInfo
{
SkRect
fBounds
;
SkPathDirection
fDirection
;
uint8_t
fStartIndex
;
}
;
struct
SkPathRRectInfo
{
SkRRect
fRRect
;
SkPathDirection
fDirection
;
uint8_t
fStartIndex
;
}
;
enum
class
SkPathIsAType
:
uint8_t
{
kGeneral
kOval
kRRect
}
;
struct
SkPathIsAData
{
uint8_t
fStartIndex
;
SkPathDirection
fDirection
;
}
;
class
SK_API
SkPathRef
final
:
public
SkNVRefCnt
<
SkPathRef
>
{
public
:
using
PointsArray
=
skia_private
:
:
STArray
<
4
SkPoint
>
;
using
VerbsArray
=
skia_private
:
:
STArray
<
4
SkPathVerb
>
;
using
ConicWeightsArray
=
skia_private
:
:
STArray
<
2
float
>
;
SkPathRef
(
SkSpan
<
const
SkPoint
>
points
SkSpan
<
const
SkPathVerb
>
verbs
SkSpan
<
const
SkScalar
>
weights
unsigned
segmentMask
const
SkMatrix
*
mx
)
:
fPoints
(
points
)
fVerbs
(
verbs
)
fConicWeights
(
weights
)
{
fBoundsIsDirty
=
true
;
fGenerationID
=
0
;
fSegmentMask
=
segmentMask
;
fType
=
SkPathIsAType
:
:
kGeneral
;
SkDEBUGCODE
(
fEditorsAttached
.
store
(
0
)
;
)
if
(
mx
&
&
!
mx
-
>
isIdentity
(
)
)
{
mx
-
>
mapPoints
(
fPoints
)
;
}
this
-
>
computeBounds
(
)
;
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
class
Editor
{
public
:
Editor
(
sk_sp
<
SkPathRef
>
*
pathRef
int
incReserveVerbs
=
0
int
incReservePoints
=
0
int
incReserveConics
=
0
)
;
~
Editor
(
)
{
SkDEBUGCODE
(
fPathRef
-
>
fEditorsAttached
-
-
;
)
}
SkPoint
*
writablePoints
(
)
{
return
fPathRef
-
>
getWritablePoints
(
)
;
}
const
SkPoint
*
points
(
)
const
{
return
fPathRef
-
>
points
(
)
;
}
SkPoint
*
atPoint
(
int
i
)
{
return
fPathRef
-
>
getWritablePoints
(
)
+
i
;
}
const
SkPoint
*
atPoint
(
int
i
)
const
{
return
&
fPathRef
-
>
fPoints
[
i
]
;
}
SkPoint
*
growForVerb
(
SkPathVerb
verb
SkScalar
weight
=
0
)
{
SkDEBUGCODE
(
fPathRef
-
>
validate
(
)
;
)
return
fPathRef
-
>
growForVerb
(
verb
weight
)
;
}
SkPoint
*
growForRepeatedVerb
(
SkPathVerb
verb
int
numVbs
SkScalar
*
*
weights
=
nullptr
)
{
return
fPathRef
-
>
growForRepeatedVerb
(
verb
numVbs
weights
)
;
}
std
:
:
tuple
<
SkPoint
*
SkScalar
*
>
growForVerbsInPath
(
const
SkPathRef
&
path
)
{
return
fPathRef
-
>
growForVerbsInPath
(
path
)
;
}
void
resetToSize
(
int
newVerbCnt
int
newPointCnt
int
newConicCount
)
{
fPathRef
-
>
resetToSize
(
newVerbCnt
newPointCnt
newConicCount
)
;
}
SkPathRef
*
pathRef
(
)
{
return
fPathRef
;
}
void
setIsOval
(
SkPathDirection
dir
unsigned
start
)
{
fPathRef
-
>
setIsOval
(
dir
start
)
;
}
void
setIsRRect
(
SkPathDirection
dir
unsigned
start
)
{
fPathRef
-
>
setIsRRect
(
dir
start
)
;
}
void
setBounds
(
const
SkRect
&
rect
)
{
fPathRef
-
>
setBounds
(
rect
)
;
}
private
:
SkPathRef
*
fPathRef
;
}
;
public
:
static
SkPathRef
*
CreateEmpty
(
)
;
bool
isFinite
(
)
const
{
if
(
fBoundsIsDirty
)
{
this
-
>
computeBounds
(
)
;
}
return
SkToBool
(
fIsFinite
)
;
}
uint32_t
getSegmentMasks
(
)
const
{
return
fSegmentMask
;
}
std
:
:
optional
<
SkPathOvalInfo
>
isOval
(
)
const
{
if
(
fType
=
=
SkPathIsAType
:
:
kOval
)
{
return
{
{
this
-
>
getBounds
(
)
fIsA
.
fDirection
fIsA
.
fStartIndex
}
}
;
}
return
{
}
;
}
std
:
:
optional
<
SkPathRRectInfo
>
isRRect
(
)
const
;
bool
hasComputedBounds
(
)
const
{
return
!
fBoundsIsDirty
;
}
const
SkRect
&
getBounds
(
)
const
{
if
(
fBoundsIsDirty
)
{
this
-
>
computeBounds
(
)
;
}
return
fBounds
;
}
SkRRect
getRRect
(
)
const
;
static
void
CreateTransformedCopy
(
sk_sp
<
SkPathRef
>
*
dst
const
SkPathRef
&
src
const
SkMatrix
&
matrix
)
;
static
void
Rewind
(
sk_sp
<
SkPathRef
>
*
pathRef
)
;
~
SkPathRef
(
)
;
int
countPoints
(
)
const
{
return
fPoints
.
size
(
)
;
}
int
countVerbs
(
)
const
{
return
fVerbs
.
size
(
)
;
}
int
countWeights
(
)
const
{
return
fConicWeights
.
size
(
)
;
}
size_t
approximateBytesUsed
(
)
const
;
const
SkPathVerb
*
verbsBegin
(
)
const
{
return
fVerbs
.
begin
(
)
;
}
const
SkPathVerb
*
verbsEnd
(
)
const
{
return
fVerbs
.
end
(
)
;
}
SkSpan
<
const
SkPathVerb
>
verbs
(
)
const
{
return
fVerbs
;
}
const
SkPoint
*
points
(
)
const
{
return
fPoints
.
begin
(
)
;
}
const
SkPoint
*
pointsEnd
(
)
const
{
return
this
-
>
points
(
)
+
this
-
>
countPoints
(
)
;
}
SkSpan
<
const
SkPoint
>
pointSpan
(
)
const
{
return
fPoints
;
}
SkSpan
<
const
float
>
conicSpan
(
)
const
{
return
fConicWeights
;
}
const
SkScalar
*
conicWeights
(
)
const
{
return
fConicWeights
.
begin
(
)
;
}
const
SkScalar
*
conicWeightsEnd
(
)
const
{
return
fConicWeights
.
end
(
)
;
}
SkPathVerb
atVerb
(
int
index
)
const
{
return
fVerbs
[
index
]
;
}
SkPoint
atPoint
(
int
index
)
const
{
return
fPoints
[
index
]
;
}
bool
operator
=
=
(
const
SkPathRef
&
ref
)
const
;
void
interpolate
(
const
SkPathRef
&
ending
SkScalar
weight
SkPathRef
*
out
)
const
;
uint32_t
genID
(
uint8_t
fillType
)
const
;
void
addGenIDChangeListener
(
sk_sp
<
SkIDChangeListener
>
)
;
int
genIDChangeListenerCount
(
)
;
bool
dataMatchesVerbs
(
)
const
;
bool
isValid
(
)
const
;
SkDEBUGCODE
(
void
validate
(
)
const
{
SkASSERT
(
this
-
>
isValid
(
)
)
;
}
)
void
reset
(
)
;
bool
isInitialEmptyPathRef
(
)
const
{
return
fGenerationID
=
=
kEmptyGenID
;
}
private
:
enum
SerializationOffsets
{
kLegacyRRectOrOvalStartIdx_SerializationShift
=
28
kLegacyRRectOrOvalIsCCW_SerializationShift
=
27
kLegacyIsRRect_SerializationShift
=
26
kIsFinite_SerializationShift
=
25
kLegacyIsOval_SerializationShift
=
24
kSegmentMask_SerializationShift
=
0
}
;
SkPathRef
(
int
numVerbs
=
0
int
numPoints
=
0
int
numConics
=
0
)
{
fBoundsIsDirty
=
true
;
fGenerationID
=
kEmptyGenID
;
fSegmentMask
=
0
;
fType
=
SkPathIsAType
:
:
kGeneral
;
if
(
numPoints
>
0
)
{
fPoints
.
reserve_exact
(
numPoints
)
;
}
if
(
numVerbs
>
0
)
{
fVerbs
.
reserve_exact
(
numVerbs
)
;
}
if
(
numConics
>
0
)
{
fConicWeights
.
reserve_exact
(
numConics
)
;
}
SkDEBUGCODE
(
fEditorsAttached
.
store
(
0
)
;
)
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
void
copy
(
const
SkPathRef
&
ref
int
additionalReserveVerbs
int
additionalReservePoints
int
additionalReserveConics
)
;
static
bool
ComputePtBounds
(
SkRect
*
bounds
const
SkPathRef
&
ref
)
{
return
bounds
-
>
setBoundsCheck
(
{
ref
.
points
(
)
ref
.
countPoints
(
)
}
)
;
}
void
computeBounds
(
)
const
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
SkASSERT
(
fBoundsIsDirty
)
;
fIsFinite
=
ComputePtBounds
(
&
fBounds
*
this
)
;
fBoundsIsDirty
=
false
;
}
void
setBounds
(
const
SkRect
&
rect
)
{
SkASSERT
(
rect
.
fLeft
<
=
rect
.
fRight
&
&
rect
.
fTop
<
=
rect
.
fBottom
)
;
fBounds
=
rect
;
fBoundsIsDirty
=
false
;
fIsFinite
=
fBounds
.
isFinite
(
)
;
}
void
incReserve
(
int
additionalVerbs
int
additionalPoints
int
additionalConics
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
if
(
additionalPoints
>
0
)
{
fPoints
.
reserve
(
fPoints
.
size
(
)
+
additionalPoints
)
;
}
if
(
additionalVerbs
>
0
)
{
fVerbs
.
reserve
(
fVerbs
.
size
(
)
+
additionalVerbs
)
;
}
if
(
additionalConics
>
0
)
{
fConicWeights
.
reserve
(
fConicWeights
.
size
(
)
+
additionalConics
)
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
void
commonReset
(
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
this
-
>
callGenIDChangeListeners
(
)
;
fBoundsIsDirty
=
true
;
fGenerationID
=
0
;
fSegmentMask
=
0
;
fType
=
SkPathIsAType
:
:
kGeneral
;
}
void
resetToSize
(
int
verbCount
int
pointCount
int
conicCount
int
reserveVerbs
=
0
int
reservePoints
=
0
int
reserveConics
=
0
)
{
this
-
>
commonReset
(
)
;
fPoints
.
reserve_exact
(
pointCount
+
reservePoints
)
;
fPoints
.
resize_back
(
pointCount
)
;
fVerbs
.
reserve_exact
(
verbCount
+
reserveVerbs
)
;
fVerbs
.
resize_back
(
verbCount
)
;
fConicWeights
.
reserve_exact
(
conicCount
+
reserveConics
)
;
fConicWeights
.
resize_back
(
conicCount
)
;
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
SkPoint
*
growForRepeatedVerb
(
SkPathVerb
int
numVbs
SkScalar
*
*
weights
)
;
SkPoint
*
growForVerb
(
SkPathVerb
SkScalar
weight
)
;
std
:
:
tuple
<
SkPoint
*
SkScalar
*
>
growForVerbsInPath
(
const
SkPathRef
&
path
)
;
uint8_t
*
verbsBeginWritable
(
)
{
return
(
uint8_t
*
)
fVerbs
.
begin
(
)
;
}
friend
SkPathRef
*
sk_create_empty_pathref
(
)
;
void
setIsOval
(
SkPathDirection
dir
unsigned
start
)
{
fType
=
SkPathIsAType
:
:
kOval
;
fIsA
.
fDirection
=
dir
;
fIsA
.
fStartIndex
=
SkToU8
(
start
)
;
}
void
setIsRRect
(
SkPathDirection
dir
unsigned
start
)
{
fType
=
SkPathIsAType
:
:
kRRect
;
fIsA
.
fDirection
=
dir
;
fIsA
.
fStartIndex
=
SkToU8
(
start
)
;
}
SkPoint
*
getWritablePoints
(
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
fType
=
SkPathIsAType
:
:
kGeneral
;
return
fPoints
.
begin
(
)
;
}
const
SkPoint
*
getPoints
(
)
const
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
return
fPoints
.
begin
(
)
;
}
void
callGenIDChangeListeners
(
)
;
PointsArray
fPoints
;
VerbsArray
fVerbs
;
ConicWeightsArray
fConicWeights
;
mutable
SkRect
fBounds
;
enum
{
kEmptyGenID
=
1
}
;
mutable
uint32_t
fGenerationID
;
SkIDChangeListener
:
:
List
fGenIDChangeListeners
;
SkDEBUGCODE
(
std
:
:
atomic
<
int
>
fEditorsAttached
;
)
SkPathIsAData
fIsA
{
}
;
SkPathIsAType
fType
;
uint8_t
fSegmentMask
;
mutable
bool
fBoundsIsDirty
;
mutable
bool
fIsFinite
;
friend
class
PathRefTest_Private
;
friend
class
ForceIsRRect_Private
;
friend
class
SkPath
;
friend
class
SkPathBuilder
;
friend
class
SkPathPriv
;
}
;
#
endif
