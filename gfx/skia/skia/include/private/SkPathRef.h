#
ifndef
SkPathRef_DEFINED
#
define
SkPathRef_DEFINED
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkRRect
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
private
/
SkMutex
.
h
"
#
include
"
include
/
private
/
SkTDArray
.
h
"
#
include
"
include
/
private
/
SkTemplates
.
h
"
#
include
"
include
/
private
/
SkTo
.
h
"
#
include
<
atomic
>
#
include
<
limits
>
class
SkRBuffer
;
class
SkWBuffer
;
class
SK_API
SkPathRef
final
:
public
SkNVRefCnt
<
SkPathRef
>
{
public
:
class
Editor
{
public
:
Editor
(
sk_sp
<
SkPathRef
>
*
pathRef
int
incReserveVerbs
=
0
int
incReservePoints
=
0
)
;
~
Editor
(
)
{
SkDEBUGCODE
(
fPathRef
-
>
fEditorsAttached
-
-
;
)
}
SkPoint
*
writablePoints
(
)
{
return
fPathRef
-
>
getWritablePoints
(
)
;
}
const
SkPoint
*
points
(
)
const
{
return
fPathRef
-
>
points
(
)
;
}
SkPoint
*
atPoint
(
int
i
)
{
return
fPathRef
-
>
getWritablePoints
(
)
+
i
;
}
const
SkPoint
*
atPoint
(
int
i
)
const
{
return
&
fPathRef
-
>
fPoints
[
i
]
;
}
SkPoint
*
growForVerb
(
int
verb
SkScalar
weight
=
0
)
{
SkDEBUGCODE
(
fPathRef
-
>
validate
(
)
;
)
return
fPathRef
-
>
growForVerb
(
verb
weight
)
;
}
SkPoint
*
growForRepeatedVerb
(
int
verb
int
numVbs
SkScalar
*
*
weights
=
nullptr
)
{
return
fPathRef
-
>
growForRepeatedVerb
(
verb
numVbs
weights
)
;
}
void
resetToSize
(
int
newVerbCnt
int
newPointCnt
int
newConicCount
)
{
fPathRef
-
>
resetToSize
(
newVerbCnt
newPointCnt
newConicCount
)
;
}
SkPathRef
*
pathRef
(
)
{
return
fPathRef
;
}
void
setIsOval
(
bool
isOval
bool
isCCW
unsigned
start
)
{
fPathRef
-
>
setIsOval
(
isOval
isCCW
start
)
;
}
void
setIsRRect
(
bool
isRRect
bool
isCCW
unsigned
start
)
{
fPathRef
-
>
setIsRRect
(
isRRect
isCCW
start
)
;
}
void
setBounds
(
const
SkRect
&
rect
)
{
fPathRef
-
>
setBounds
(
rect
)
;
}
private
:
SkPathRef
*
fPathRef
;
}
;
class
SK_API
Iter
{
public
:
Iter
(
)
;
Iter
(
const
SkPathRef
&
)
;
void
setPathRef
(
const
SkPathRef
&
)
;
uint8_t
next
(
SkPoint
pts
[
4
]
)
;
uint8_t
peek
(
)
const
;
SkScalar
conicWeight
(
)
const
{
return
*
fConicWeights
;
}
private
:
const
SkPoint
*
fPts
;
const
uint8_t
*
fVerbs
;
const
uint8_t
*
fVerbStop
;
const
SkScalar
*
fConicWeights
;
}
;
public
:
static
SkPathRef
*
CreateEmpty
(
)
;
bool
isFinite
(
)
const
{
if
(
fBoundsIsDirty
)
{
this
-
>
computeBounds
(
)
;
}
return
SkToBool
(
fIsFinite
)
;
}
uint32_t
getSegmentMasks
(
)
const
{
return
fSegmentMask
;
}
bool
isOval
(
SkRect
*
rect
bool
*
isCCW
unsigned
*
start
)
const
{
if
(
fIsOval
)
{
if
(
rect
)
{
*
rect
=
this
-
>
getBounds
(
)
;
}
if
(
isCCW
)
{
*
isCCW
=
SkToBool
(
fRRectOrOvalIsCCW
)
;
}
if
(
start
)
{
*
start
=
fRRectOrOvalStartIdx
;
}
}
return
SkToBool
(
fIsOval
)
;
}
bool
isRRect
(
SkRRect
*
rrect
bool
*
isCCW
unsigned
*
start
)
const
{
if
(
fIsRRect
)
{
if
(
rrect
)
{
*
rrect
=
this
-
>
getRRect
(
)
;
}
if
(
isCCW
)
{
*
isCCW
=
SkToBool
(
fRRectOrOvalIsCCW
)
;
}
if
(
start
)
{
*
start
=
fRRectOrOvalStartIdx
;
}
}
return
SkToBool
(
fIsRRect
)
;
}
bool
hasComputedBounds
(
)
const
{
return
!
fBoundsIsDirty
;
}
const
SkRect
&
getBounds
(
)
const
{
if
(
fBoundsIsDirty
)
{
this
-
>
computeBounds
(
)
;
}
return
fBounds
;
}
SkRRect
getRRect
(
)
const
;
static
void
CreateTransformedCopy
(
sk_sp
<
SkPathRef
>
*
dst
const
SkPathRef
&
src
const
SkMatrix
&
matrix
)
;
static
void
Rewind
(
sk_sp
<
SkPathRef
>
*
pathRef
)
;
~
SkPathRef
(
)
;
int
countPoints
(
)
const
{
return
fPoints
.
count
(
)
;
}
int
countVerbs
(
)
const
{
return
fVerbs
.
count
(
)
;
}
int
countWeights
(
)
const
{
return
fConicWeights
.
count
(
)
;
}
const
uint8_t
*
verbsBegin
(
)
const
{
return
fVerbs
.
begin
(
)
;
}
const
uint8_t
*
verbsEnd
(
)
const
{
return
fVerbs
.
end
(
)
;
}
const
SkPoint
*
points
(
)
const
{
return
fPoints
.
begin
(
)
;
}
const
SkPoint
*
pointsEnd
(
)
const
{
return
this
-
>
points
(
)
+
this
-
>
countPoints
(
)
;
}
const
SkScalar
*
conicWeights
(
)
const
{
return
fConicWeights
.
begin
(
)
;
}
const
SkScalar
*
conicWeightsEnd
(
)
const
{
return
fConicWeights
.
end
(
)
;
}
uint8_t
atVerb
(
int
index
)
const
{
return
fVerbs
[
index
]
;
}
const
SkPoint
&
atPoint
(
int
index
)
const
{
return
fPoints
[
index
]
;
}
bool
operator
=
=
(
const
SkPathRef
&
ref
)
const
;
void
writeToBuffer
(
SkWBuffer
*
buffer
)
const
;
uint32_t
writeSize
(
)
const
;
void
interpolate
(
const
SkPathRef
&
ending
SkScalar
weight
SkPathRef
*
out
)
const
;
uint32_t
genID
(
)
const
;
class
GenIDChangeListener
:
public
SkRefCnt
{
public
:
GenIDChangeListener
(
)
:
fShouldUnregisterFromPath
(
false
)
{
}
virtual
~
GenIDChangeListener
(
)
{
}
virtual
void
onChange
(
)
=
0
;
void
markShouldUnregisterFromPath
(
)
{
fShouldUnregisterFromPath
.
store
(
true
std
:
:
memory_order_relaxed
)
;
}
bool
shouldUnregisterFromPath
(
)
{
return
fShouldUnregisterFromPath
.
load
(
std
:
:
memory_order_acquire
)
;
}
private
:
std
:
:
atomic
<
bool
>
fShouldUnregisterFromPath
;
}
;
void
addGenIDChangeListener
(
sk_sp
<
GenIDChangeListener
>
)
;
bool
isValid
(
)
const
;
SkDEBUGCODE
(
void
validate
(
)
const
{
SkASSERT
(
this
-
>
isValid
(
)
)
;
}
)
private
:
enum
SerializationOffsets
{
kLegacyRRectOrOvalStartIdx_SerializationShift
=
28
kLegacyRRectOrOvalIsCCW_SerializationShift
=
27
kLegacyIsRRect_SerializationShift
=
26
kIsFinite_SerializationShift
=
25
kLegacyIsOval_SerializationShift
=
24
kSegmentMask_SerializationShift
=
0
}
;
SkPathRef
(
)
{
fBoundsIsDirty
=
true
;
fGenerationID
=
kEmptyGenID
;
fSegmentMask
=
0
;
fIsOval
=
false
;
fIsRRect
=
false
;
fRRectOrOvalIsCCW
=
false
;
fRRectOrOvalStartIdx
=
0xAC
;
SkDEBUGCODE
(
fEditorsAttached
.
store
(
0
)
;
)
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
void
copy
(
const
SkPathRef
&
ref
int
additionalReserveVerbs
int
additionalReservePoints
)
;
unsigned
computeSegmentMask
(
)
const
;
static
bool
ComputePtBounds
(
SkRect
*
bounds
const
SkPathRef
&
ref
)
{
return
bounds
-
>
setBoundsCheck
(
ref
.
points
(
)
ref
.
countPoints
(
)
)
;
}
void
computeBounds
(
)
const
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
SkASSERT
(
fBoundsIsDirty
)
;
fIsFinite
=
ComputePtBounds
(
&
fBounds
*
this
)
;
fBoundsIsDirty
=
false
;
}
void
setBounds
(
const
SkRect
&
rect
)
{
SkASSERT
(
rect
.
fLeft
<
=
rect
.
fRight
&
&
rect
.
fTop
<
=
rect
.
fBottom
)
;
fBounds
=
rect
;
fBoundsIsDirty
=
false
;
fIsFinite
=
fBounds
.
isFinite
(
)
;
}
void
incReserve
(
int
additionalVerbs
int
additionalPoints
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
fPoints
.
setReserve
(
fPoints
.
count
(
)
+
additionalPoints
)
;
fVerbs
.
setReserve
(
fVerbs
.
count
(
)
+
additionalVerbs
)
;
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
void
resetToSize
(
int
verbCount
int
pointCount
int
conicCount
int
reserveVerbs
=
0
int
reservePoints
=
0
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
this
-
>
callGenIDChangeListeners
(
)
;
fBoundsIsDirty
=
true
;
fGenerationID
=
0
;
fSegmentMask
=
0
;
fIsOval
=
false
;
fIsRRect
=
false
;
fPoints
.
setReserve
(
pointCount
+
reservePoints
)
;
fPoints
.
setCount
(
pointCount
)
;
fVerbs
.
setReserve
(
verbCount
+
reserveVerbs
)
;
fVerbs
.
setCount
(
verbCount
)
;
fConicWeights
.
setCount
(
conicCount
)
;
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
SkPoint
*
growForRepeatedVerb
(
int
verb
int
numVbs
SkScalar
*
*
weights
)
;
SkPoint
*
growForVerb
(
int
verb
SkScalar
weight
)
;
uint8_t
*
verbsBeginWritable
(
)
{
return
fVerbs
.
begin
(
)
;
}
friend
SkPathRef
*
sk_create_empty_pathref
(
)
;
void
setIsOval
(
bool
isOval
bool
isCCW
unsigned
start
)
{
fIsOval
=
isOval
;
fRRectOrOvalIsCCW
=
isCCW
;
fRRectOrOvalStartIdx
=
SkToU8
(
start
)
;
}
void
setIsRRect
(
bool
isRRect
bool
isCCW
unsigned
start
)
{
fIsRRect
=
isRRect
;
fRRectOrOvalIsCCW
=
isCCW
;
fRRectOrOvalStartIdx
=
SkToU8
(
start
)
;
}
SkPoint
*
getWritablePoints
(
)
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
fIsOval
=
false
;
fIsRRect
=
false
;
return
fPoints
.
begin
(
)
;
}
const
SkPoint
*
getPoints
(
)
const
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
return
fPoints
.
begin
(
)
;
}
void
callGenIDChangeListeners
(
)
;
enum
{
kMinSize
=
256
}
;
mutable
SkRect
fBounds
;
SkTDArray
<
SkPoint
>
fPoints
;
SkTDArray
<
uint8_t
>
fVerbs
;
SkTDArray
<
SkScalar
>
fConicWeights
;
enum
{
kEmptyGenID
=
1
}
;
mutable
uint32_t
fGenerationID
;
SkDEBUGCODE
(
std
:
:
atomic
<
int
>
fEditorsAttached
;
)
SkMutex
fGenIDChangeListenersMutex
;
SkTDArray
<
GenIDChangeListener
*
>
fGenIDChangeListeners
;
mutable
uint8_t
fBoundsIsDirty
;
mutable
bool
fIsFinite
;
bool
fIsOval
;
bool
fIsRRect
;
bool
fRRectOrOvalIsCCW
;
uint8_t
fRRectOrOvalStartIdx
;
uint8_t
fSegmentMask
;
friend
class
PathRefTest_Private
;
friend
class
ForceIsRRect_Private
;
friend
class
SkPath
;
friend
class
SkPathPriv
;
}
;
#
endif
