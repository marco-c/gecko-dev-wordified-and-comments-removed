#
ifndef
GrResourceKey_DEFINED
#
define
GrResourceKey_DEFINED
#
include
"
include
/
core
/
SkData
.
h
"
#
include
"
include
/
core
/
SkString
.
h
"
#
include
"
include
/
gpu
/
GrTypes
.
h
"
#
include
"
include
/
private
/
SkOnce
.
h
"
#
include
"
include
/
private
/
SkTemplates
.
h
"
#
include
"
include
/
private
/
SkTo
.
h
"
#
include
<
new
>
uint32_t
GrResourceKeyHash
(
const
uint32_t
*
data
size_t
size
)
;
class
GrResourceKey
{
public
:
uint32_t
hash
(
)
const
{
this
-
>
validate
(
)
;
return
fKey
[
kHash_MetaDataIdx
]
;
}
size_t
size
(
)
const
{
this
-
>
validate
(
)
;
SkASSERT
(
this
-
>
isValid
(
)
)
;
return
this
-
>
internalSize
(
)
;
}
protected
:
static
const
uint32_t
kInvalidDomain
=
0
;
GrResourceKey
(
)
{
this
-
>
reset
(
)
;
}
void
reset
(
)
{
GR_STATIC_ASSERT
(
(
uint16_t
)
kInvalidDomain
=
=
kInvalidDomain
)
;
fKey
.
reset
(
kMetaDataCnt
)
;
fKey
[
kHash_MetaDataIdx
]
=
0
;
fKey
[
kDomainAndSize_MetaDataIdx
]
=
kInvalidDomain
;
}
bool
operator
=
=
(
const
GrResourceKey
&
that
)
const
{
return
this
-
>
hash
(
)
=
=
that
.
hash
(
)
&
&
0
=
=
memcmp
(
&
fKey
[
kHash_MetaDataIdx
+
1
]
&
that
.
fKey
[
kHash_MetaDataIdx
+
1
]
this
-
>
internalSize
(
)
-
sizeof
(
uint32_t
)
)
;
}
GrResourceKey
&
operator
=
(
const
GrResourceKey
&
that
)
{
if
(
this
!
=
&
that
)
{
if
(
!
that
.
isValid
(
)
)
{
this
-
>
reset
(
)
;
}
else
{
size_t
bytes
=
that
.
size
(
)
;
SkASSERT
(
SkIsAlign4
(
bytes
)
)
;
fKey
.
reset
(
SkToInt
(
bytes
/
sizeof
(
uint32_t
)
)
)
;
memcpy
(
fKey
.
get
(
)
that
.
fKey
.
get
(
)
bytes
)
;
this
-
>
validate
(
)
;
}
}
return
*
this
;
}
bool
isValid
(
)
const
{
return
kInvalidDomain
!
=
this
-
>
domain
(
)
;
}
uint32_t
domain
(
)
const
{
return
fKey
[
kDomainAndSize_MetaDataIdx
]
&
0xffff
;
}
size_t
dataSize
(
)
const
{
return
this
-
>
size
(
)
-
4
*
kMetaDataCnt
;
}
const
uint32_t
*
data
(
)
const
{
this
-
>
validate
(
)
;
return
&
fKey
[
kMetaDataCnt
]
;
}
#
ifdef
SK_DEBUG
void
dump
(
)
const
{
if
(
!
this
-
>
isValid
(
)
)
{
SkDebugf
(
"
Invalid
Key
\
n
"
)
;
}
else
{
SkDebugf
(
"
hash
:
%
d
"
this
-
>
hash
(
)
)
;
SkDebugf
(
"
domain
:
%
d
"
this
-
>
domain
(
)
)
;
SkDebugf
(
"
size
:
%
dB
"
this
-
>
internalSize
(
)
)
;
for
(
size_t
i
=
0
;
i
<
this
-
>
internalSize
(
)
;
+
+
i
)
{
SkDebugf
(
"
%
d
"
fKey
[
SkTo
<
int
>
(
i
)
]
)
;
}
SkDebugf
(
"
\
n
"
)
;
}
}
#
endif
class
Builder
{
public
:
Builder
(
GrResourceKey
*
key
uint32_t
domain
int
data32Count
)
:
fKey
(
key
)
{
SkASSERT
(
data32Count
>
=
0
)
;
SkASSERT
(
domain
!
=
kInvalidDomain
)
;
key
-
>
fKey
.
reset
(
kMetaDataCnt
+
data32Count
)
;
int
size
=
(
data32Count
+
kMetaDataCnt
)
*
sizeof
(
uint32_t
)
;
SkASSERT
(
SkToU16
(
size
)
=
=
size
)
;
SkASSERT
(
SkToU16
(
domain
)
=
=
domain
)
;
key
-
>
fKey
[
kDomainAndSize_MetaDataIdx
]
=
domain
|
(
size
<
<
16
)
;
}
~
Builder
(
)
{
this
-
>
finish
(
)
;
}
void
finish
(
)
{
if
(
nullptr
=
=
fKey
)
{
return
;
}
GR_STATIC_ASSERT
(
0
=
=
kHash_MetaDataIdx
)
;
uint32_t
*
hash
=
&
fKey
-
>
fKey
[
kHash_MetaDataIdx
]
;
*
hash
=
GrResourceKeyHash
(
hash
+
1
fKey
-
>
internalSize
(
)
-
sizeof
(
uint32_t
)
)
;
fKey
-
>
validate
(
)
;
fKey
=
nullptr
;
}
uint32_t
&
operator
[
]
(
int
dataIdx
)
{
SkASSERT
(
fKey
)
;
SkDEBUGCODE
(
size_t
dataCount
=
fKey
-
>
internalSize
(
)
/
sizeof
(
uint32_t
)
-
kMetaDataCnt
;
)
SkASSERT
(
SkToU32
(
dataIdx
)
<
dataCount
)
;
return
fKey
-
>
fKey
[
kMetaDataCnt
+
dataIdx
]
;
}
private
:
GrResourceKey
*
fKey
;
}
;
private
:
enum
MetaDataIdx
{
kHash_MetaDataIdx
kDomainAndSize_MetaDataIdx
kLastMetaDataIdx
=
kDomainAndSize_MetaDataIdx
}
;
static
const
uint32_t
kMetaDataCnt
=
kLastMetaDataIdx
+
1
;
size_t
internalSize
(
)
const
{
return
fKey
[
kDomainAndSize_MetaDataIdx
]
>
>
16
;
}
void
validate
(
)
const
{
SkASSERT
(
this
-
>
isValid
(
)
)
;
SkASSERT
(
fKey
[
kHash_MetaDataIdx
]
=
=
GrResourceKeyHash
(
&
fKey
[
kHash_MetaDataIdx
]
+
1
this
-
>
internalSize
(
)
-
sizeof
(
uint32_t
)
)
)
;
SkASSERT
(
SkIsAlign4
(
this
-
>
internalSize
(
)
)
)
;
}
friend
class
TestResource
;
SkAutoSTMalloc
<
kMetaDataCnt
+
5
uint32_t
>
fKey
;
}
;
class
GrScratchKey
:
public
GrResourceKey
{
private
:
typedef
GrResourceKey
INHERITED
;
public
:
typedef
uint32_t
ResourceType
;
static
ResourceType
GenerateResourceType
(
)
;
GrScratchKey
(
)
{
}
GrScratchKey
(
const
GrScratchKey
&
that
)
{
*
this
=
that
;
}
using
INHERITED
:
:
reset
;
using
INHERITED
:
:
isValid
;
ResourceType
resourceType
(
)
const
{
return
this
-
>
domain
(
)
;
}
GrScratchKey
&
operator
=
(
const
GrScratchKey
&
that
)
{
this
-
>
INHERITED
:
:
operator
=
(
that
)
;
return
*
this
;
}
bool
operator
=
=
(
const
GrScratchKey
&
that
)
const
{
return
this
-
>
INHERITED
:
:
operator
=
=
(
that
)
;
}
bool
operator
!
=
(
const
GrScratchKey
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
class
Builder
:
public
INHERITED
:
:
Builder
{
public
:
Builder
(
GrScratchKey
*
key
ResourceType
type
int
data32Count
)
:
INHERITED
:
:
Builder
(
key
type
data32Count
)
{
}
}
;
}
;
class
GrUniqueKey
:
public
GrResourceKey
{
private
:
typedef
GrResourceKey
INHERITED
;
public
:
typedef
uint32_t
Domain
;
static
Domain
GenerateDomain
(
)
;
GrUniqueKey
(
)
:
fTag
(
nullptr
)
{
}
GrUniqueKey
(
const
GrUniqueKey
&
that
)
{
*
this
=
that
;
}
using
INHERITED
:
:
reset
;
using
INHERITED
:
:
isValid
;
GrUniqueKey
&
operator
=
(
const
GrUniqueKey
&
that
)
{
this
-
>
INHERITED
:
:
operator
=
(
that
)
;
this
-
>
setCustomData
(
sk_ref_sp
(
that
.
getCustomData
(
)
)
)
;
fTag
=
that
.
fTag
;
return
*
this
;
}
bool
operator
=
=
(
const
GrUniqueKey
&
that
)
const
{
return
this
-
>
INHERITED
:
:
operator
=
=
(
that
)
;
}
bool
operator
!
=
(
const
GrUniqueKey
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
void
setCustomData
(
sk_sp
<
SkData
>
data
)
{
fData
=
std
:
:
move
(
data
)
;
}
SkData
*
getCustomData
(
)
const
{
return
fData
.
get
(
)
;
}
const
char
*
tag
(
)
const
{
return
fTag
;
}
#
ifdef
SK_DEBUG
void
dump
(
const
char
*
label
)
const
{
SkDebugf
(
"
%
s
tag
:
%
s
\
n
"
label
fTag
?
fTag
:
"
None
"
)
;
this
-
>
INHERITED
:
:
dump
(
)
;
}
#
endif
class
Builder
:
public
INHERITED
:
:
Builder
{
public
:
Builder
(
GrUniqueKey
*
key
Domain
type
int
data32Count
const
char
*
tag
=
nullptr
)
:
INHERITED
:
:
Builder
(
key
type
data32Count
)
{
key
-
>
fTag
=
tag
;
}
Builder
(
GrUniqueKey
*
key
const
GrUniqueKey
&
innerKey
Domain
domain
int
extraData32Cnt
const
char
*
tag
=
nullptr
)
:
INHERITED
:
:
Builder
(
key
domain
Data32CntForInnerKey
(
innerKey
)
+
extraData32Cnt
)
{
SkASSERT
(
&
innerKey
!
=
key
)
;
uint32_t
*
innerKeyData
=
&
this
-
>
operator
[
]
(
extraData32Cnt
)
;
const
uint32_t
*
srcData
=
innerKey
.
data
(
)
;
(
*
innerKeyData
+
+
)
=
innerKey
.
domain
(
)
;
memcpy
(
innerKeyData
srcData
innerKey
.
dataSize
(
)
)
;
key
-
>
fTag
=
tag
;
}
private
:
static
int
Data32CntForInnerKey
(
const
GrUniqueKey
&
innerKey
)
{
return
SkToInt
(
(
innerKey
.
dataSize
(
)
>
>
2
)
+
1
)
;
}
}
;
private
:
sk_sp
<
SkData
>
fData
;
const
char
*
fTag
;
}
;
#
define
GR_DECLARE_STATIC_UNIQUE_KEY
(
name
)
static
SkOnce
name
#
#
_once
#
define
GR_DEFINE_STATIC_UNIQUE_KEY
(
name
)
\
static
SkAlignedSTStorage
<
1
GrUniqueKey
>
name
#
#
_storage
;
\
name
#
#
_once
(
gr_init_static_unique_key_once
&
name
#
#
_storage
)
;
\
static
const
GrUniqueKey
&
name
=
*
reinterpret_cast
<
GrUniqueKey
*
>
(
name
#
#
_storage
.
get
(
)
)
static
inline
void
gr_init_static_unique_key_once
(
SkAlignedSTStorage
<
1
GrUniqueKey
>
*
keyStorage
)
{
GrUniqueKey
*
key
=
new
(
keyStorage
-
>
get
(
)
)
GrUniqueKey
;
GrUniqueKey
:
:
Builder
builder
(
key
GrUniqueKey
:
:
GenerateDomain
(
)
0
)
;
}
class
GrUniqueKeyInvalidatedMessage
{
public
:
GrUniqueKeyInvalidatedMessage
(
)
=
default
;
GrUniqueKeyInvalidatedMessage
(
const
GrUniqueKey
&
key
uint32_t
contextUniqueID
)
:
fKey
(
key
)
fContextID
(
contextUniqueID
)
{
SkASSERT
(
SK_InvalidUniqueID
!
=
contextUniqueID
)
;
}
GrUniqueKeyInvalidatedMessage
(
const
GrUniqueKeyInvalidatedMessage
&
)
=
default
;
GrUniqueKeyInvalidatedMessage
&
operator
=
(
const
GrUniqueKeyInvalidatedMessage
&
)
=
default
;
const
GrUniqueKey
&
key
(
)
const
{
return
fKey
;
}
uint32_t
contextID
(
)
const
{
return
fContextID
;
}
private
:
GrUniqueKey
fKey
;
uint32_t
fContextID
=
SK_InvalidUniqueID
;
}
;
static
inline
bool
SkShouldPostMessageToBus
(
const
GrUniqueKeyInvalidatedMessage
&
msg
uint32_t
msgBusUniqueID
)
{
return
msg
.
contextID
(
)
=
=
msgBusUniqueID
;
}
#
endif
