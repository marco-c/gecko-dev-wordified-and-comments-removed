#
ifndef
SkFloatBits_DEFINED
#
define
SkFloatBits_DEFINED
#
include
"
SkTypes
.
h
"
#
include
<
math
.
h
>
static
inline
int32_t
SkSignBitTo2sCompliment
(
int32_t
x
)
{
if
(
x
<
0
)
{
x
&
=
0x7FFFFFFF
;
x
=
-
x
;
}
return
x
;
}
static
inline
int32_t
Sk2sComplimentToSignBit
(
int32_t
x
)
{
int
sign
=
x
>
>
31
;
x
=
(
x
^
sign
)
-
sign
;
x
|
=
SkLeftShift
(
sign
31
)
;
return
x
;
}
union
SkFloatIntUnion
{
float
fFloat
;
int32_t
fSignBitInt
;
}
;
static
inline
int32_t
SkFloat2Bits
(
float
x
)
{
SkFloatIntUnion
data
;
data
.
fFloat
=
x
;
return
data
.
fSignBitInt
;
}
static
inline
float
SkBits2Float
(
int32_t
floatAsBits
)
{
SkFloatIntUnion
data
;
data
.
fSignBitInt
=
floatAsBits
;
return
data
.
fFloat
;
}
static
inline
int32_t
SkFloatAs2sCompliment
(
float
x
)
{
return
SkSignBitTo2sCompliment
(
SkFloat2Bits
(
x
)
)
;
}
static
inline
float
Sk2sComplimentAsFloat
(
int32_t
x
)
{
return
SkBits2Float
(
Sk2sComplimentToSignBit
(
x
)
)
;
}
static
inline
int32_t
pin_double_to_int
(
double
x
)
{
return
(
int32_t
)
SkTPin
<
double
>
(
x
SK_MinS32
SK_MaxS32
)
;
}
static
inline
int32_t
SkFloatToIntFloor
(
float
x
)
{
return
pin_double_to_int
(
floor
(
x
)
)
;
}
static
inline
int32_t
SkFloatToIntRound
(
float
x
)
{
return
pin_double_to_int
(
floor
(
(
double
)
x
+
0
.
5
)
)
;
}
static
inline
int32_t
SkFloatToIntCeil
(
float
x
)
{
return
pin_double_to_int
(
ceil
(
x
)
)
;
}
#
define
SkScalarAs2sCompliment
(
x
)
SkFloatAs2sCompliment
(
x
)
#
define
Sk2sComplimentAsScalar
(
x
)
Sk2sComplimentAsFloat
(
x
)
#
endif
