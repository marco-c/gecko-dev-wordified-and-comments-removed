#
ifndef
SkTHash_DEFINED
#
define
SkTHash_DEFINED
#
include
"
SkChecksum
.
h
"
#
include
"
SkTypes
.
h
"
#
include
"
SkTemplates
.
h
"
template
<
typename
T
typename
K
typename
Traits
=
T
>
class
SkTHashTable
:
SkNoncopyable
{
public
:
SkTHashTable
(
)
:
fCount
(
0
)
fRemoved
(
0
)
fCapacity
(
0
)
{
}
void
reset
(
)
{
this
-
>
~
SkTHashTable
(
)
;
new
(
this
)
SkTHashTable
;
}
int
count
(
)
const
{
return
fCount
;
}
size_t
approxBytesUsed
(
)
const
{
return
fCapacity
*
sizeof
(
Slot
)
;
}
T
*
set
(
const
T
&
val
)
{
if
(
4
*
(
fCount
+
fRemoved
)
>
=
3
*
fCapacity
)
{
this
-
>
resize
(
fCapacity
>
0
?
fCapacity
*
2
:
4
)
;
}
return
this
-
>
uncheckedSet
(
val
)
;
}
T
*
find
(
const
K
&
key
)
const
{
uint32_t
hash
=
Hash
(
key
)
;
int
index
=
hash
&
(
fCapacity
-
1
)
;
for
(
int
n
=
0
;
n
<
fCapacity
;
n
+
+
)
{
Slot
&
s
=
fSlots
[
index
]
;
if
(
s
.
empty
(
)
)
{
return
NULL
;
}
if
(
!
s
.
removed
(
)
&
&
hash
=
=
s
.
hash
&
&
key
=
=
Traits
:
:
GetKey
(
s
.
val
)
)
{
return
&
s
.
val
;
}
index
=
this
-
>
next
(
index
n
)
;
}
SkASSERT
(
fCapacity
=
=
0
)
;
return
NULL
;
}
void
remove
(
const
K
&
key
)
{
SkASSERT
(
this
-
>
find
(
key
)
)
;
uint32_t
hash
=
Hash
(
key
)
;
int
index
=
hash
&
(
fCapacity
-
1
)
;
for
(
int
n
=
0
;
n
<
fCapacity
;
n
+
+
)
{
Slot
&
s
=
fSlots
[
index
]
;
SkASSERT
(
!
s
.
empty
(
)
)
;
if
(
!
s
.
removed
(
)
&
&
hash
=
=
s
.
hash
&
&
key
=
=
Traits
:
:
GetKey
(
s
.
val
)
)
{
fRemoved
+
+
;
fCount
-
-
;
s
.
markRemoved
(
)
;
return
;
}
index
=
this
-
>
next
(
index
n
)
;
}
SkASSERT
(
fCapacity
=
=
0
)
;
}
template
<
typename
Fn
>
void
foreach
(
Fn
&
&
fn
)
{
for
(
int
i
=
0
;
i
<
fCapacity
;
i
+
+
)
{
if
(
!
fSlots
[
i
]
.
empty
(
)
&
&
!
fSlots
[
i
]
.
removed
(
)
)
{
fn
(
&
fSlots
[
i
]
.
val
)
;
}
}
}
template
<
typename
Fn
>
void
foreach
(
Fn
&
&
fn
)
const
{
for
(
int
i
=
0
;
i
<
fCapacity
;
i
+
+
)
{
if
(
!
fSlots
[
i
]
.
empty
(
)
&
&
!
fSlots
[
i
]
.
removed
(
)
)
{
fn
(
fSlots
[
i
]
.
val
)
;
}
}
}
private
:
T
*
uncheckedSet
(
const
T
&
val
)
{
const
K
&
key
=
Traits
:
:
GetKey
(
val
)
;
uint32_t
hash
=
Hash
(
key
)
;
int
index
=
hash
&
(
fCapacity
-
1
)
;
for
(
int
n
=
0
;
n
<
fCapacity
;
n
+
+
)
{
Slot
&
s
=
fSlots
[
index
]
;
if
(
s
.
empty
(
)
|
|
s
.
removed
(
)
)
{
if
(
s
.
removed
(
)
)
{
fRemoved
-
-
;
}
s
.
val
=
val
;
s
.
hash
=
hash
;
fCount
+
+
;
return
&
s
.
val
;
}
if
(
hash
=
=
s
.
hash
&
&
key
=
=
Traits
:
:
GetKey
(
s
.
val
)
)
{
s
.
val
=
val
;
return
&
s
.
val
;
}
index
=
this
-
>
next
(
index
n
)
;
}
SkASSERT
(
false
)
;
return
NULL
;
}
void
resize
(
int
capacity
)
{
int
oldCapacity
=
fCapacity
;
SkDEBUGCODE
(
int
oldCount
=
fCount
)
;
fCount
=
fRemoved
=
0
;
fCapacity
=
capacity
;
SkAutoTArray
<
Slot
>
oldSlots
(
capacity
)
;
oldSlots
.
swap
(
fSlots
)
;
for
(
int
i
=
0
;
i
<
oldCapacity
;
i
+
+
)
{
const
Slot
&
s
=
oldSlots
[
i
]
;
if
(
!
s
.
empty
(
)
&
&
!
s
.
removed
(
)
)
{
this
-
>
uncheckedSet
(
s
.
val
)
;
}
}
SkASSERT
(
fCount
=
=
oldCount
)
;
}
int
next
(
int
index
int
n
)
const
{
return
(
index
+
n
+
1
)
&
(
fCapacity
-
1
)
;
}
static
uint32_t
Hash
(
const
K
&
key
)
{
uint32_t
hash
=
Traits
:
:
Hash
(
key
)
;
return
hash
<
2
?
hash
+
2
:
hash
;
}
struct
Slot
{
Slot
(
)
:
hash
(
0
)
{
}
bool
empty
(
)
const
{
return
this
-
>
hash
=
=
0
;
}
bool
removed
(
)
const
{
return
this
-
>
hash
=
=
1
;
}
void
markRemoved
(
)
{
this
-
>
hash
=
1
;
}
T
val
;
uint32_t
hash
;
}
;
int
fCount
fRemoved
fCapacity
;
SkAutoTArray
<
Slot
>
fSlots
;
}
;
template
<
typename
K
typename
V
typename
HashK
=
SkGoodHash
>
class
SkTHashMap
:
SkNoncopyable
{
public
:
SkTHashMap
(
)
{
}
void
reset
(
)
{
fTable
.
reset
(
)
;
}
int
count
(
)
const
{
return
fTable
.
count
(
)
;
}
size_t
approxBytesUsed
(
)
const
{
return
fTable
.
approxBytesUsed
(
)
;
}
V
*
set
(
const
K
&
key
const
V
&
val
)
{
Pair
in
=
{
key
val
}
;
Pair
*
out
=
fTable
.
set
(
in
)
;
return
&
out
-
>
val
;
}
V
*
find
(
const
K
&
key
)
const
{
if
(
Pair
*
p
=
fTable
.
find
(
key
)
)
{
return
&
p
-
>
val
;
}
return
NULL
;
}
void
remove
(
const
K
&
key
)
{
SkASSERT
(
this
-
>
find
(
key
)
)
;
fTable
.
remove
(
key
)
;
}
template
<
typename
Fn
>
void
foreach
(
Fn
&
&
fn
)
{
fTable
.
foreach
(
[
&
fn
]
(
Pair
*
p
)
{
fn
(
p
-
>
key
&
p
-
>
val
)
;
}
)
;
}
template
<
typename
Fn
>
void
foreach
(
Fn
&
&
fn
)
const
{
fTable
.
foreach
(
[
&
fn
]
(
const
Pair
&
p
)
{
fn
(
p
.
key
p
.
val
)
;
}
)
;
}
private
:
struct
Pair
{
K
key
;
V
val
;
static
const
K
&
GetKey
(
const
Pair
&
p
)
{
return
p
.
key
;
}
static
uint32_t
Hash
(
const
K
&
key
)
{
return
HashK
(
)
(
key
)
;
}
}
;
SkTHashTable
<
Pair
K
>
fTable
;
}
;
template
<
typename
T
typename
HashT
=
SkGoodHash
>
class
SkTHashSet
:
SkNoncopyable
{
public
:
SkTHashSet
(
)
{
}
void
reset
(
)
{
fTable
.
reset
(
)
;
}
int
count
(
)
const
{
return
fTable
.
count
(
)
;
}
size_t
approxBytesUsed
(
)
const
{
return
fTable
.
approxBytesUsed
(
)
;
}
void
add
(
const
T
&
item
)
{
fTable
.
set
(
item
)
;
}
bool
contains
(
const
T
&
item
)
const
{
return
SkToBool
(
this
-
>
find
(
item
)
)
;
}
const
T
*
find
(
const
T
&
item
)
const
{
return
fTable
.
find
(
item
)
;
}
void
remove
(
const
T
&
item
)
{
SkASSERT
(
this
-
>
contains
(
item
)
)
;
fTable
.
remove
(
item
)
;
}
template
<
typename
Fn
>
void
foreach
(
Fn
&
&
fn
)
const
{
fTable
.
foreach
(
fn
)
;
}
private
:
struct
Traits
{
static
const
T
&
GetKey
(
const
T
&
item
)
{
return
item
;
}
static
uint32_t
Hash
(
const
T
&
item
)
{
return
HashT
(
)
(
item
)
;
}
}
;
SkTHashTable
<
T
T
Traits
>
fTable
;
}
;
#
endif
