#
ifndef
SkTemplates_DEFINED
#
define
SkTemplates_DEFINED
#
include
"
SkMath
.
h
"
#
include
"
SkMalloc
.
h
"
#
include
"
SkTLogic
.
h
"
#
include
"
SkTypes
.
h
"
#
include
<
limits
.
h
>
#
include
<
memory
>
#
include
<
new
>
template
<
typename
T
>
inline
void
sk_ignore_unused_variable
(
const
T
&
)
{
}
template
<
typename
D
typename
S
>
static
D
*
SkTAfter
(
S
*
ptr
size_t
count
=
1
)
{
return
reinterpret_cast
<
D
*
>
(
ptr
+
count
)
;
}
template
<
typename
D
typename
S
>
static
D
*
SkTAddOffset
(
S
*
ptr
size_t
byteOffset
)
{
return
reinterpret_cast
<
D
*
>
(
reinterpret_cast
<
sknonstd
:
:
same_cv_t
<
char
D
>
*
>
(
ptr
)
+
byteOffset
)
;
}
template
<
typename
R
typename
T
R
(
*
P
)
(
T
*
)
>
struct
SkFunctionWrapper
{
R
operator
(
)
(
T
*
t
)
{
return
P
(
t
)
;
}
}
;
template
<
typename
T
void
(
*
P
)
(
T
*
)
>
class
SkAutoTCallVProc
:
public
std
:
:
unique_ptr
<
T
SkFunctionWrapper
<
void
T
P
>
>
{
public
:
SkAutoTCallVProc
(
T
*
obj
)
:
std
:
:
unique_ptr
<
T
SkFunctionWrapper
<
void
T
P
>
>
(
obj
)
{
}
operator
T
*
(
)
const
{
return
this
-
>
get
(
)
;
}
}
;
template
<
typename
T
>
class
SkAutoTArray
{
public
:
SkAutoTArray
(
)
{
}
explicit
SkAutoTArray
(
int
count
)
{
SkASSERT
(
count
>
=
0
)
;
if
(
count
)
{
fArray
.
reset
(
new
T
[
count
]
)
;
}
SkDEBUGCODE
(
fCount
=
count
;
)
}
SkAutoTArray
(
SkAutoTArray
&
&
other
)
:
fArray
(
std
:
:
move
(
other
.
fArray
)
)
{
SkDEBUGCODE
(
fCount
=
other
.
fCount
;
other
.
fCount
=
0
;
)
}
SkAutoTArray
&
operator
=
(
SkAutoTArray
&
&
other
)
{
if
(
this
!
=
&
other
)
{
fArray
=
std
:
:
move
(
other
.
fArray
)
;
SkDEBUGCODE
(
fCount
=
other
.
fCount
;
other
.
fCount
=
0
;
)
}
return
*
this
;
}
void
reset
(
int
count
)
{
*
this
=
SkAutoTArray
(
count
)
;
}
T
*
get
(
)
const
{
return
fArray
.
get
(
)
;
}
T
&
operator
[
]
(
int
index
)
const
{
SkASSERT
(
(
unsigned
)
index
<
(
unsigned
)
fCount
)
;
return
fArray
[
index
]
;
}
private
:
std
:
:
unique_ptr
<
T
[
]
>
fArray
;
SkDEBUGCODE
(
int
fCount
=
0
;
)
}
;
template
<
int
kCountRequested
typename
T
>
class
SkAutoSTArray
{
public
:
SkAutoSTArray
(
SkAutoSTArray
&
&
)
=
delete
;
SkAutoSTArray
(
const
SkAutoSTArray
&
)
=
delete
;
SkAutoSTArray
&
operator
=
(
SkAutoSTArray
&
&
)
=
delete
;
SkAutoSTArray
&
operator
=
(
const
SkAutoSTArray
&
)
=
delete
;
SkAutoSTArray
(
)
{
fArray
=
nullptr
;
fCount
=
0
;
}
SkAutoSTArray
(
int
count
)
{
fArray
=
nullptr
;
fCount
=
0
;
this
-
>
reset
(
count
)
;
}
~
SkAutoSTArray
(
)
{
this
-
>
reset
(
0
)
;
}
void
reset
(
int
count
)
{
T
*
start
=
fArray
;
T
*
iter
=
start
+
fCount
;
while
(
iter
>
start
)
{
(
-
-
iter
)
-
>
~
T
(
)
;
}
SkASSERT
(
count
>
=
0
)
;
if
(
fCount
!
=
count
)
{
if
(
fCount
>
kCount
)
{
SkASSERT
(
(
T
*
)
fStorage
!
=
fArray
)
;
sk_free
(
fArray
)
;
}
if
(
count
>
kCount
)
{
fArray
=
(
T
*
)
sk_malloc_throw
(
count
sizeof
(
T
)
)
;
}
else
if
(
count
>
0
)
{
fArray
=
(
T
*
)
fStorage
;
}
else
{
fArray
=
nullptr
;
}
fCount
=
count
;
}
iter
=
fArray
;
T
*
stop
=
fArray
+
count
;
while
(
iter
<
stop
)
{
new
(
iter
+
+
)
T
;
}
}
int
count
(
)
const
{
return
fCount
;
}
T
*
get
(
)
const
{
return
fArray
;
}
T
*
begin
(
)
{
return
fArray
;
}
const
T
*
begin
(
)
const
{
return
fArray
;
}
T
*
end
(
)
{
return
fArray
+
fCount
;
}
const
T
*
end
(
)
const
{
return
fArray
+
fCount
;
}
T
&
operator
[
]
(
int
index
)
const
{
SkASSERT
(
index
<
fCount
)
;
return
fArray
[
index
]
;
}
private
:
#
if
defined
(
SK_BUILD_FOR_GOOGLE3
)
static
const
int
kMaxBytes
=
4
*
1024
;
static
const
int
kCount
=
kCountRequested
*
sizeof
(
T
)
>
kMaxBytes
?
kMaxBytes
/
sizeof
(
T
)
:
kCountRequested
;
#
else
static
const
int
kCount
=
kCountRequested
;
#
endif
int
fCount
;
T
*
fArray
;
char
fStorage
[
kCount
*
sizeof
(
T
)
]
;
}
;
template
<
typename
T
>
class
SkAutoTMalloc
{
public
:
explicit
SkAutoTMalloc
(
T
*
ptr
=
nullptr
)
:
fPtr
(
ptr
)
{
}
explicit
SkAutoTMalloc
(
size_t
count
)
:
fPtr
(
count
?
(
T
*
)
sk_malloc_throw
(
count
sizeof
(
T
)
)
:
nullptr
)
{
}
SkAutoTMalloc
(
SkAutoTMalloc
&
&
)
=
default
;
SkAutoTMalloc
&
operator
=
(
SkAutoTMalloc
&
&
)
=
default
;
void
realloc
(
size_t
count
)
{
fPtr
.
reset
(
count
?
(
T
*
)
sk_realloc_throw
(
fPtr
.
release
(
)
count
*
sizeof
(
T
)
)
:
nullptr
)
;
}
T
*
reset
(
size_t
count
=
0
)
{
fPtr
.
reset
(
count
?
(
T
*
)
sk_malloc_throw
(
count
sizeof
(
T
)
)
:
nullptr
)
;
return
this
-
>
get
(
)
;
}
T
*
get
(
)
const
{
return
fPtr
.
get
(
)
;
}
operator
T
*
(
)
{
return
fPtr
.
get
(
)
;
}
operator
const
T
*
(
)
const
{
return
fPtr
.
get
(
)
;
}
T
&
operator
[
]
(
int
index
)
{
return
fPtr
.
get
(
)
[
index
]
;
}
const
T
&
operator
[
]
(
int
index
)
const
{
return
fPtr
.
get
(
)
[
index
]
;
}
T
*
release
(
)
{
return
fPtr
.
release
(
)
;
}
private
:
std
:
:
unique_ptr
<
T
SkFunctionWrapper
<
void
void
sk_free
>
>
fPtr
;
}
;
template
<
size_t
kCountRequested
typename
T
>
class
SkAutoSTMalloc
{
public
:
SkAutoSTMalloc
(
)
:
fPtr
(
fTStorage
)
{
}
SkAutoSTMalloc
(
size_t
count
)
{
if
(
count
>
kCount
)
{
fPtr
=
(
T
*
)
sk_malloc_throw
(
count
sizeof
(
T
)
)
;
}
else
if
(
count
)
{
fPtr
=
fTStorage
;
}
else
{
fPtr
=
nullptr
;
}
}
SkAutoSTMalloc
(
SkAutoSTMalloc
&
&
)
=
delete
;
SkAutoSTMalloc
(
const
SkAutoSTMalloc
&
)
=
delete
;
SkAutoSTMalloc
&
operator
=
(
SkAutoSTMalloc
&
&
)
=
delete
;
SkAutoSTMalloc
&
operator
=
(
const
SkAutoSTMalloc
&
)
=
delete
;
~
SkAutoSTMalloc
(
)
{
if
(
fPtr
!
=
fTStorage
)
{
sk_free
(
fPtr
)
;
}
}
T
*
reset
(
size_t
count
)
{
if
(
fPtr
!
=
fTStorage
)
{
sk_free
(
fPtr
)
;
}
if
(
count
>
kCount
)
{
fPtr
=
(
T
*
)
sk_malloc_throw
(
count
sizeof
(
T
)
)
;
}
else
if
(
count
)
{
fPtr
=
fTStorage
;
}
else
{
fPtr
=
nullptr
;
}
return
fPtr
;
}
T
*
get
(
)
const
{
return
fPtr
;
}
operator
T
*
(
)
{
return
fPtr
;
}
operator
const
T
*
(
)
const
{
return
fPtr
;
}
T
&
operator
[
]
(
int
index
)
{
return
fPtr
[
index
]
;
}
const
T
&
operator
[
]
(
int
index
)
const
{
return
fPtr
[
index
]
;
}
void
realloc
(
size_t
count
)
{
if
(
count
>
kCount
)
{
if
(
fPtr
=
=
fTStorage
)
{
fPtr
=
(
T
*
)
sk_malloc_throw
(
count
sizeof
(
T
)
)
;
memcpy
(
fPtr
fTStorage
kCount
*
sizeof
(
T
)
)
;
}
else
{
fPtr
=
(
T
*
)
sk_realloc_throw
(
fPtr
count
sizeof
(
T
)
)
;
}
}
else
if
(
count
)
{
if
(
fPtr
!
=
fTStorage
)
{
fPtr
=
(
T
*
)
sk_realloc_throw
(
fPtr
count
sizeof
(
T
)
)
;
}
}
else
{
this
-
>
reset
(
0
)
;
}
}
private
:
static
const
size_t
kCountWithPadding
=
SkAlign4
(
kCountRequested
*
sizeof
(
T
)
)
/
sizeof
(
T
)
;
#
if
defined
(
SK_BUILD_FOR_GOOGLE3
)
static
const
size_t
kMaxBytes
=
4
*
1024
;
static
const
size_t
kCount
=
kCountRequested
*
sizeof
(
T
)
>
kMaxBytes
?
kMaxBytes
/
sizeof
(
T
)
:
kCountWithPadding
;
#
else
static
const
size_t
kCount
=
kCountWithPadding
;
#
endif
T
*
fPtr
;
union
{
uint32_t
fStorage32
[
SkAlign4
(
kCount
*
sizeof
(
T
)
)
>
>
2
]
;
T
fTStorage
[
1
]
;
}
;
}
;
template
<
typename
T
>
void
SkInPlaceDeleteCheck
(
T
*
obj
void
*
storage
)
{
if
(
storage
=
=
obj
)
{
obj
-
>
~
T
(
)
;
}
else
{
delete
obj
;
}
}
template
<
typename
T
typename
.
.
.
Args
>
T
*
SkInPlaceNewCheck
(
void
*
storage
size_t
size
Args
&
&
.
.
.
args
)
{
return
(
sizeof
(
T
)
<
=
size
)
?
new
(
storage
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
:
new
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
template
<
size_t
N
>
class
SkAlignedSStorage
{
public
:
SkAlignedSStorage
(
)
{
}
SkAlignedSStorage
(
SkAlignedSStorage
&
&
)
=
delete
;
SkAlignedSStorage
(
const
SkAlignedSStorage
&
)
=
delete
;
SkAlignedSStorage
&
operator
=
(
SkAlignedSStorage
&
&
)
=
delete
;
SkAlignedSStorage
&
operator
=
(
const
SkAlignedSStorage
&
)
=
delete
;
size_t
size
(
)
const
{
return
N
;
}
void
*
get
(
)
{
return
fData
;
}
const
void
*
get
(
)
const
{
return
fData
;
}
private
:
union
{
void
*
fPtr
;
double
fDouble
;
char
fData
[
N
]
;
}
;
}
;
template
<
int
N
typename
T
>
class
SkAlignedSTStorage
{
public
:
SkAlignedSTStorage
(
)
{
}
SkAlignedSTStorage
(
SkAlignedSTStorage
&
&
)
=
delete
;
SkAlignedSTStorage
(
const
SkAlignedSTStorage
&
)
=
delete
;
SkAlignedSTStorage
&
operator
=
(
SkAlignedSTStorage
&
&
)
=
delete
;
SkAlignedSTStorage
&
operator
=
(
const
SkAlignedSTStorage
&
)
=
delete
;
void
*
get
(
)
{
return
fStorage
.
get
(
)
;
}
const
void
*
get
(
)
const
{
return
fStorage
.
get
(
)
;
}
private
:
SkAlignedSStorage
<
sizeof
(
T
)
*
N
>
fStorage
;
}
;
using
SkAutoFree
=
std
:
:
unique_ptr
<
void
SkFunctionWrapper
<
void
void
sk_free
>
>
;
template
<
typename
C
std
:
:
size_t
.
.
.
Is
>
constexpr
auto
SkMakeArrayFromIndexSequence
(
C
c
skstd
:
:
index_sequence
<
Is
.
.
.
>
)
-
>
std
:
:
array
<
skstd
:
:
result_of_t
<
C
(
std
:
:
size_t
)
>
sizeof
.
.
.
(
Is
)
>
{
return
{
{
c
(
Is
)
.
.
.
}
}
;
}
template
<
size_t
N
typename
C
>
constexpr
auto
SkMakeArray
(
C
c
)
-
>
std
:
:
array
<
skstd
:
:
result_of_t
<
C
(
std
:
:
size_t
)
>
N
>
{
return
SkMakeArrayFromIndexSequence
(
c
skstd
:
:
make_index_sequence
<
N
>
{
}
)
;
}
#
endif
