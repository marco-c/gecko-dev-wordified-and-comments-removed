#
ifndef
SkTemplates_DEFINED
#
define
SkTemplates_DEFINED
#
include
"
SkMath
.
h
"
#
include
"
SkMalloc
.
h
"
#
include
"
SkTLogic
.
h
"
#
include
"
SkTypes
.
h
"
#
include
<
limits
.
h
>
#
include
<
memory
>
#
include
<
new
>
template
<
typename
T
>
inline
void
sk_ignore_unused_variable
(
const
T
&
)
{
}
template
<
typename
D
typename
S
>
static
D
*
SkTAfter
(
S
*
ptr
size_t
count
=
1
)
{
return
reinterpret_cast
<
D
*
>
(
ptr
+
count
)
;
}
template
<
typename
D
typename
S
>
static
D
*
SkTAddOffset
(
S
*
ptr
size_t
byteOffset
)
{
return
reinterpret_cast
<
D
*
>
(
reinterpret_cast
<
sknonstd
:
:
same_cv_t
<
char
D
>
*
>
(
ptr
)
+
byteOffset
)
;
}
template
<
typename
R
typename
T
R
(
*
P
)
(
T
*
)
>
struct
SkFunctionWrapper
{
R
operator
(
)
(
T
*
t
)
{
return
P
(
t
)
;
}
}
;
template
<
typename
T
void
(
*
P
)
(
T
*
)
>
class
SkAutoTCallVProc
:
public
std
:
:
unique_ptr
<
T
SkFunctionWrapper
<
void
T
P
>
>
{
public
:
SkAutoTCallVProc
(
T
*
obj
)
:
std
:
:
unique_ptr
<
T
SkFunctionWrapper
<
void
T
P
>
>
(
obj
)
{
}
operator
T
*
(
)
const
{
return
this
-
>
get
(
)
;
}
}
;
template
<
typename
T
int
(
*
P
)
(
T
*
)
>
class
SkAutoTCallIProc
:
public
std
:
:
unique_ptr
<
T
SkFunctionWrapper
<
int
T
P
>
>
{
public
:
SkAutoTCallIProc
(
T
*
obj
)
:
std
:
:
unique_ptr
<
T
SkFunctionWrapper
<
int
T
P
>
>
(
obj
)
{
}
operator
T
*
(
)
const
{
return
this
-
>
get
(
)
;
}
}
;
template
<
typename
T
>
class
SkAutoTArray
:
SkNoncopyable
{
public
:
SkAutoTArray
(
)
{
fArray
=
NULL
;
SkDEBUGCODE
(
fCount
=
0
;
)
}
explicit
SkAutoTArray
(
int
count
)
{
SkASSERT
(
count
>
=
0
)
;
fArray
=
NULL
;
if
(
count
)
{
fArray
=
new
T
[
count
]
;
}
SkDEBUGCODE
(
fCount
=
count
;
)
}
void
reset
(
int
count
)
{
delete
[
]
fArray
;
SkASSERT
(
count
>
=
0
)
;
fArray
=
NULL
;
if
(
count
)
{
fArray
=
new
T
[
count
]
;
}
SkDEBUGCODE
(
fCount
=
count
;
)
}
~
SkAutoTArray
(
)
{
delete
[
]
fArray
;
}
T
*
get
(
)
const
{
return
fArray
;
}
T
&
operator
[
]
(
int
index
)
const
{
SkASSERT
(
(
unsigned
)
index
<
(
unsigned
)
fCount
)
;
return
fArray
[
index
]
;
}
void
swap
(
SkAutoTArray
&
other
)
{
SkTSwap
(
fArray
other
.
fArray
)
;
SkDEBUGCODE
(
SkTSwap
(
fCount
other
.
fCount
)
)
;
}
private
:
T
*
fArray
;
SkDEBUGCODE
(
int
fCount
;
)
}
;
template
<
int
kCountRequested
typename
T
>
class
SkAutoSTArray
:
SkNoncopyable
{
public
:
SkAutoSTArray
(
)
{
fArray
=
NULL
;
fCount
=
0
;
}
SkAutoSTArray
(
int
count
)
{
fArray
=
NULL
;
fCount
=
0
;
this
-
>
reset
(
count
)
;
}
~
SkAutoSTArray
(
)
{
this
-
>
reset
(
0
)
;
}
void
reset
(
int
count
)
{
T
*
start
=
fArray
;
T
*
iter
=
start
+
fCount
;
while
(
iter
>
start
)
{
(
-
-
iter
)
-
>
~
T
(
)
;
}
SkASSERT
(
count
>
=
0
)
;
if
(
fCount
!
=
count
)
{
if
(
fCount
>
kCount
)
{
SkASSERT
(
(
T
*
)
fStorage
!
=
fArray
)
;
sk_free
(
fArray
)
;
}
if
(
count
>
kCount
)
{
const
uint64_t
size64
=
sk_64_mul
(
count
sizeof
(
T
)
)
;
const
size_t
size
=
static_cast
<
size_t
>
(
size64
)
;
if
(
size
!
=
size64
)
{
sk_out_of_memory
(
)
;
}
fArray
=
(
T
*
)
sk_malloc_throw
(
size
)
;
}
else
if
(
count
>
0
)
{
fArray
=
(
T
*
)
fStorage
;
}
else
{
fArray
=
NULL
;
}
fCount
=
count
;
}
iter
=
fArray
;
T
*
stop
=
fArray
+
count
;
while
(
iter
<
stop
)
{
new
(
iter
+
+
)
T
;
}
}
int
count
(
)
const
{
return
fCount
;
}
T
*
get
(
)
const
{
return
fArray
;
}
T
*
begin
(
)
{
return
fArray
;
}
const
T
*
begin
(
)
const
{
return
fArray
;
}
T
*
end
(
)
{
return
fArray
+
fCount
;
}
const
T
*
end
(
)
const
{
return
fArray
+
fCount
;
}
T
&
operator
[
]
(
int
index
)
const
{
SkASSERT
(
index
<
fCount
)
;
return
fArray
[
index
]
;
}
private
:
#
if
defined
(
GOOGLE3
)
static
const
int
kMaxBytes
=
4
*
1024
;
static
const
int
kCount
=
kCountRequested
*
sizeof
(
T
)
>
kMaxBytes
?
kMaxBytes
/
sizeof
(
T
)
:
kCountRequested
;
#
else
static
const
int
kCount
=
kCountRequested
;
#
endif
int
fCount
;
T
*
fArray
;
char
fStorage
[
kCount
*
sizeof
(
T
)
]
;
}
;
template
<
typename
T
>
class
SkAutoTMalloc
:
SkNoncopyable
{
public
:
explicit
SkAutoTMalloc
(
T
*
ptr
=
NULL
)
{
fPtr
=
ptr
;
}
explicit
SkAutoTMalloc
(
size_t
count
)
{
fPtr
=
count
?
(
T
*
)
sk_malloc_flags
(
count
*
sizeof
(
T
)
SK_MALLOC_THROW
)
:
nullptr
;
}
SkAutoTMalloc
(
SkAutoTMalloc
<
T
>
&
&
that
)
:
fPtr
(
that
.
release
(
)
)
{
}
~
SkAutoTMalloc
(
)
{
sk_free
(
fPtr
)
;
}
void
realloc
(
size_t
count
)
{
if
(
count
)
{
fPtr
=
reinterpret_cast
<
T
*
>
(
sk_realloc_throw
(
fPtr
count
*
sizeof
(
T
)
)
)
;
}
else
{
this
-
>
reset
(
0
)
;
}
}
T
*
reset
(
size_t
count
=
0
)
{
sk_free
(
fPtr
)
;
fPtr
=
count
?
(
T
*
)
sk_malloc_flags
(
count
*
sizeof
(
T
)
SK_MALLOC_THROW
)
:
nullptr
;
return
fPtr
;
}
T
*
get
(
)
const
{
return
fPtr
;
}
operator
T
*
(
)
{
return
fPtr
;
}
operator
const
T
*
(
)
const
{
return
fPtr
;
}
T
&
operator
[
]
(
int
index
)
{
return
fPtr
[
index
]
;
}
const
T
&
operator
[
]
(
int
index
)
const
{
return
fPtr
[
index
]
;
}
SkAutoTMalloc
&
operator
=
(
SkAutoTMalloc
<
T
>
&
&
that
)
{
if
(
this
!
=
&
that
)
{
sk_free
(
fPtr
)
;
fPtr
=
that
.
release
(
)
;
}
return
*
this
;
}
T
*
release
(
)
{
T
*
ptr
=
fPtr
;
fPtr
=
NULL
;
return
ptr
;
}
private
:
T
*
fPtr
;
}
;
template
<
size_t
kCountRequested
typename
T
>
class
SkAutoSTMalloc
:
SkNoncopyable
{
public
:
SkAutoSTMalloc
(
)
:
fPtr
(
fTStorage
)
{
}
SkAutoSTMalloc
(
size_t
count
)
{
if
(
count
>
kCount
)
{
fPtr
=
(
T
*
)
sk_malloc_flags
(
count
*
sizeof
(
T
)
SK_MALLOC_THROW
|
SK_MALLOC_TEMP
)
;
}
else
if
(
count
)
{
fPtr
=
fTStorage
;
}
else
{
fPtr
=
nullptr
;
}
}
~
SkAutoSTMalloc
(
)
{
if
(
fPtr
!
=
fTStorage
)
{
sk_free
(
fPtr
)
;
}
}
T
*
reset
(
size_t
count
)
{
if
(
fPtr
!
=
fTStorage
)
{
sk_free
(
fPtr
)
;
}
if
(
count
>
kCount
)
{
fPtr
=
(
T
*
)
sk_malloc_throw
(
count
*
sizeof
(
T
)
)
;
}
else
if
(
count
)
{
fPtr
=
fTStorage
;
}
else
{
fPtr
=
nullptr
;
}
return
fPtr
;
}
T
*
get
(
)
const
{
return
fPtr
;
}
operator
T
*
(
)
{
return
fPtr
;
}
operator
const
T
*
(
)
const
{
return
fPtr
;
}
T
&
operator
[
]
(
int
index
)
{
return
fPtr
[
index
]
;
}
const
T
&
operator
[
]
(
int
index
)
const
{
return
fPtr
[
index
]
;
}
void
realloc
(
size_t
count
)
{
if
(
count
>
kCount
)
{
if
(
fPtr
=
=
fTStorage
)
{
fPtr
=
(
T
*
)
sk_malloc_throw
(
count
*
sizeof
(
T
)
)
;
memcpy
(
fPtr
fTStorage
kCount
*
sizeof
(
T
)
)
;
}
else
{
fPtr
=
(
T
*
)
sk_realloc_throw
(
fPtr
count
*
sizeof
(
T
)
)
;
}
}
else
if
(
count
)
{
if
(
fPtr
!
=
fTStorage
)
{
fPtr
=
(
T
*
)
sk_realloc_throw
(
fPtr
count
*
sizeof
(
T
)
)
;
}
}
else
{
this
-
>
reset
(
0
)
;
}
}
private
:
static
const
size_t
kCountWithPadding
=
SkAlign4
(
kCountRequested
*
sizeof
(
T
)
)
/
sizeof
(
T
)
;
#
if
defined
(
GOOGLE3
)
static
const
size_t
kMaxBytes
=
4
*
1024
;
static
const
size_t
kCount
=
kCountRequested
*
sizeof
(
T
)
>
kMaxBytes
?
kMaxBytes
/
sizeof
(
T
)
:
kCountWithPadding
;
#
else
static
const
size_t
kCount
=
kCountWithPadding
;
#
endif
T
*
fPtr
;
union
{
uint32_t
fStorage32
[
SkAlign4
(
kCount
*
sizeof
(
T
)
)
>
>
2
]
;
T
fTStorage
[
1
]
;
}
;
}
;
template
<
typename
T
>
void
SkInPlaceDeleteCheck
(
T
*
obj
void
*
storage
)
{
if
(
storage
=
=
obj
)
{
obj
-
>
~
T
(
)
;
}
else
{
delete
obj
;
}
}
template
<
typename
T
>
T
*
SkInPlaceNewCheck
(
void
*
storage
size_t
size
)
{
return
(
sizeof
(
T
)
<
=
size
)
?
new
(
storage
)
T
:
new
T
;
}
template
<
typename
T
typename
A1
typename
A2
typename
A3
>
T
*
SkInPlaceNewCheck
(
void
*
storage
size_t
size
const
A1
&
a1
const
A2
&
a2
const
A3
&
a3
)
{
return
(
sizeof
(
T
)
<
=
size
)
?
new
(
storage
)
T
(
a1
a2
a3
)
:
new
T
(
a1
a2
a3
)
;
}
template
<
typename
T
typename
A1
typename
A2
typename
A3
typename
A4
>
T
*
SkInPlaceNewCheck
(
void
*
storage
size_t
size
const
A1
&
a1
const
A2
&
a2
const
A3
&
a3
const
A4
&
a4
)
{
return
(
sizeof
(
T
)
<
=
size
)
?
new
(
storage
)
T
(
a1
a2
a3
a4
)
:
new
T
(
a1
a2
a3
a4
)
;
}
template
<
size_t
N
>
class
SkAlignedSStorage
:
SkNoncopyable
{
public
:
size_t
size
(
)
const
{
return
N
;
}
void
*
get
(
)
{
return
fData
;
}
const
void
*
get
(
)
const
{
return
fData
;
}
private
:
union
{
void
*
fPtr
;
double
fDouble
;
char
fData
[
N
]
;
}
;
}
;
template
<
int
N
typename
T
>
class
SkAlignedSTStorage
:
SkNoncopyable
{
public
:
void
*
get
(
)
{
return
fStorage
.
get
(
)
;
}
const
void
*
get
(
)
const
{
return
fStorage
.
get
(
)
;
}
private
:
SkAlignedSStorage
<
sizeof
(
T
)
*
N
>
fStorage
;
}
;
using
SkAutoFree
=
std
:
:
unique_ptr
<
void
SkFunctionWrapper
<
void
void
sk_free
>
>
;
#
endif
