#
ifndef
GrSurfaceProxy_DEFINED
#
define
GrSurfaceProxy_DEFINED
#
include
"
.
.
/
private
/
SkNoncopyable
.
h
"
#
include
"
GrGpuResource
.
h
"
#
include
"
GrSurface
.
h
"
#
include
"
SkRect
.
h
"
class
GrBackendTexture
;
class
GrCaps
;
class
GrOpList
;
class
GrProxyProvider
;
class
GrRenderTargetOpList
;
class
GrRenderTargetProxy
;
class
GrResourceProvider
;
class
GrSurfaceContext
;
class
GrSurfaceProxyPriv
;
class
GrTextureOpList
;
class
GrTextureProxy
;
class
GrIORefProxy
:
public
SkNoncopyable
{
public
:
void
ref
(
)
const
{
this
-
>
validate
(
)
;
+
+
fRefCnt
;
if
(
fTarget
)
{
fTarget
-
>
ref
(
)
;
}
}
void
unref
(
)
const
{
this
-
>
validate
(
)
;
if
(
fTarget
)
{
fTarget
-
>
unref
(
)
;
}
-
-
fRefCnt
;
this
-
>
didRemoveRefOrPendingIO
(
)
;
}
#
ifdef
SK_DEBUG
bool
isUnique_debugOnly
(
)
const
{
SkASSERT
(
fRefCnt
>
=
0
&
&
fPendingWrites
>
=
0
&
&
fPendingReads
>
=
0
)
;
return
1
=
=
fRefCnt
+
fPendingWrites
+
fPendingReads
;
}
#
endif
void
release
(
)
{
SkASSERT
(
0
=
=
fPendingReads
)
;
SkASSERT
(
0
=
=
fPendingWrites
)
;
SkASSERT
(
fRefCnt
=
=
fTarget
-
>
fRefCnt
)
;
SkASSERT
(
!
fTarget
-
>
internalHasPendingIO
(
)
)
;
for
(
int
refs
=
fTarget
-
>
fRefCnt
;
refs
;
-
-
refs
)
{
fTarget
-
>
unref
(
)
;
}
fTarget
=
nullptr
;
}
void
validate
(
)
const
{
#
ifdef
SK_DEBUG
SkASSERT
(
fRefCnt
>
=
0
)
;
SkASSERT
(
fPendingReads
>
=
0
)
;
SkASSERT
(
fPendingWrites
>
=
0
)
;
SkASSERT
(
fRefCnt
+
fPendingReads
+
fPendingWrites
>
=
1
)
;
if
(
fTarget
)
{
SkASSERT
(
fTarget
-
>
fRefCnt
>
=
fRefCnt
)
;
SkASSERT
(
fTarget
-
>
fPendingReads
>
=
fPendingReads
)
;
SkASSERT
(
fTarget
-
>
fPendingWrites
>
=
fPendingWrites
)
;
}
#
endif
}
int32_t
getBackingRefCnt_TestOnly
(
)
const
;
int32_t
getPendingReadCnt_TestOnly
(
)
const
;
int32_t
getPendingWriteCnt_TestOnly
(
)
const
;
void
addPendingRead
(
)
const
{
this
-
>
validate
(
)
;
+
+
fPendingReads
;
if
(
fTarget
)
{
fTarget
-
>
addPendingRead
(
)
;
}
}
void
completedRead
(
)
const
{
this
-
>
validate
(
)
;
if
(
fTarget
)
{
fTarget
-
>
completedRead
(
)
;
}
-
-
fPendingReads
;
this
-
>
didRemoveRefOrPendingIO
(
)
;
}
void
addPendingWrite
(
)
const
{
this
-
>
validate
(
)
;
+
+
fPendingWrites
;
if
(
fTarget
)
{
fTarget
-
>
addPendingWrite
(
)
;
}
}
void
completedWrite
(
)
const
{
this
-
>
validate
(
)
;
if
(
fTarget
)
{
fTarget
-
>
completedWrite
(
)
;
}
-
-
fPendingWrites
;
this
-
>
didRemoveRefOrPendingIO
(
)
;
}
protected
:
GrIORefProxy
(
)
:
fTarget
(
nullptr
)
fRefCnt
(
1
)
fPendingReads
(
0
)
fPendingWrites
(
0
)
{
}
GrIORefProxy
(
sk_sp
<
GrSurface
>
surface
)
:
fRefCnt
(
1
)
fPendingReads
(
0
)
fPendingWrites
(
0
)
{
fTarget
=
surface
.
release
(
)
;
}
virtual
~
GrIORefProxy
(
)
{
}
void
transferRefs
(
)
{
SkASSERT
(
fTarget
)
;
SkASSERT
(
fTarget
-
>
fRefCnt
>
0
)
;
fTarget
-
>
fRefCnt
+
=
(
fRefCnt
-
1
)
;
fTarget
-
>
fPendingReads
+
=
fPendingReads
;
fTarget
-
>
fPendingWrites
+
=
fPendingWrites
;
}
int32_t
internalGetProxyRefCnt
(
)
const
{
return
fRefCnt
;
}
bool
internalHasPendingIO
(
)
const
{
if
(
fTarget
)
{
return
fTarget
-
>
internalHasPendingIO
(
)
;
}
return
SkToBool
(
fPendingWrites
|
fPendingReads
)
;
}
bool
internalHasPendingWrite
(
)
const
{
if
(
fTarget
)
{
return
fTarget
-
>
internalHasPendingWrite
(
)
;
}
return
SkToBool
(
fPendingWrites
)
;
}
GrSurface
*
fTarget
;
private
:
template
<
typename
>
friend
class
GrProxyRef
;
void
didRemoveRefOrPendingIO
(
)
const
{
if
(
0
=
=
fPendingReads
&
&
0
=
=
fPendingWrites
&
&
0
=
=
fRefCnt
)
{
delete
this
;
}
}
mutable
int32_t
fRefCnt
;
mutable
int32_t
fPendingReads
;
mutable
int32_t
fPendingWrites
;
}
;
class
GrSurfaceProxy
:
public
GrIORefProxy
{
public
:
enum
class
LazyInstantiationType
{
kSingleUse
kMultipleUse
kUninstantiate
}
;
enum
class
LazyState
{
kNot
kPartially
kFully
}
;
LazyState
lazyInstantiationState
(
)
const
{
if
(
fTarget
|
|
!
SkToBool
(
fLazyInstantiateCallback
)
)
{
return
LazyState
:
:
kNot
;
}
else
{
if
(
fWidth
<
=
0
)
{
SkASSERT
(
fHeight
<
=
0
)
;
return
LazyState
:
:
kFully
;
}
else
{
SkASSERT
(
fHeight
>
0
)
;
return
LazyState
:
:
kPartially
;
}
}
}
GrPixelConfig
config
(
)
const
{
return
fConfig
;
}
int
width
(
)
const
{
SkASSERT
(
LazyState
:
:
kFully
!
=
this
-
>
lazyInstantiationState
(
)
)
;
return
fWidth
;
}
int
height
(
)
const
{
SkASSERT
(
LazyState
:
:
kFully
!
=
this
-
>
lazyInstantiationState
(
)
)
;
return
fHeight
;
}
SkISize
isize
(
)
const
{
return
{
fWidth
fHeight
}
;
}
int
worstCaseWidth
(
)
const
;
int
worstCaseHeight
(
)
const
;
SkRect
getBoundsRect
(
)
const
{
SkASSERT
(
LazyState
:
:
kFully
!
=
this
-
>
lazyInstantiationState
(
)
)
;
return
SkRect
:
:
MakeIWH
(
this
-
>
width
(
)
this
-
>
height
(
)
)
;
}
SkRect
getWorstCaseBoundsRect
(
)
const
{
SkASSERT
(
LazyState
:
:
kFully
!
=
this
-
>
lazyInstantiationState
(
)
)
;
return
SkRect
:
:
MakeIWH
(
this
-
>
worstCaseWidth
(
)
this
-
>
worstCaseHeight
(
)
)
;
}
GrSurfaceOrigin
origin
(
)
const
{
SkASSERT
(
kTopLeft_GrSurfaceOrigin
=
=
fOrigin
|
|
kBottomLeft_GrSurfaceOrigin
=
=
fOrigin
)
;
return
fOrigin
;
}
class
UniqueID
{
public
:
static
UniqueID
InvalidID
(
)
{
return
UniqueID
(
uint32_t
(
SK_InvalidUniqueID
)
)
;
}
explicit
UniqueID
(
const
GrGpuResource
:
:
UniqueID
&
id
)
:
fID
(
id
.
asUInt
(
)
)
{
}
UniqueID
(
)
:
fID
(
GrGpuResource
:
:
CreateUniqueID
(
)
)
{
}
uint32_t
asUInt
(
)
const
{
return
fID
;
}
bool
operator
=
=
(
const
UniqueID
&
other
)
const
{
return
fID
=
=
other
.
fID
;
}
bool
operator
!
=
(
const
UniqueID
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
void
makeInvalid
(
)
{
fID
=
SK_InvalidUniqueID
;
}
bool
isInvalid
(
)
const
{
return
SK_InvalidUniqueID
=
=
fID
;
}
private
:
explicit
UniqueID
(
uint32_t
id
)
:
fID
(
id
)
{
}
uint32_t
fID
;
}
;
UniqueID
uniqueID
(
)
const
{
return
fUniqueID
;
}
UniqueID
underlyingUniqueID
(
)
const
{
if
(
fTarget
)
{
return
UniqueID
(
fTarget
-
>
uniqueID
(
)
)
;
}
return
fUniqueID
;
}
virtual
bool
instantiate
(
GrResourceProvider
*
resourceProvider
)
=
0
;
void
deInstantiate
(
)
;
virtual
GrTextureProxy
*
asTextureProxy
(
)
{
return
nullptr
;
}
virtual
const
GrTextureProxy
*
asTextureProxy
(
)
const
{
return
nullptr
;
}
virtual
GrRenderTargetProxy
*
asRenderTargetProxy
(
)
{
return
nullptr
;
}
virtual
const
GrRenderTargetProxy
*
asRenderTargetProxy
(
)
const
{
return
nullptr
;
}
bool
isInstantiated
(
)
const
{
return
SkToBool
(
fTarget
)
;
}
GrSurface
*
peekSurface
(
)
const
{
return
fTarget
;
}
GrTexture
*
peekTexture
(
)
const
{
return
fTarget
?
fTarget
-
>
asTexture
(
)
:
nullptr
;
}
GrRenderTarget
*
peekRenderTarget
(
)
const
{
return
fTarget
?
fTarget
-
>
asRenderTarget
(
)
:
nullptr
;
}
SkBudgeted
isBudgeted
(
)
const
{
return
fBudgeted
;
}
void
setLastOpList
(
GrOpList
*
opList
)
;
GrOpList
*
getLastOpList
(
)
{
return
fLastOpList
;
}
GrRenderTargetOpList
*
getLastRenderTargetOpList
(
)
;
GrTextureOpList
*
getLastTextureOpList
(
)
;
size_t
gpuMemorySize
(
)
const
{
SkASSERT
(
LazyState
:
:
kFully
!
=
this
-
>
lazyInstantiationState
(
)
)
;
if
(
fTarget
)
{
return
fTarget
-
>
gpuMemorySize
(
)
;
}
if
(
kInvalidGpuMemorySize
=
=
fGpuMemorySize
)
{
fGpuMemorySize
=
this
-
>
onUninstantiatedGpuMemorySize
(
)
;
SkASSERT
(
kInvalidGpuMemorySize
!
=
fGpuMemorySize
)
;
}
return
fGpuMemorySize
;
}
static
sk_sp
<
GrTextureProxy
>
Copy
(
GrContext
*
GrSurfaceProxy
*
src
GrMipMapped
SkIRect
srcRect
SkBudgeted
)
;
static
sk_sp
<
GrTextureProxy
>
Copy
(
GrContext
*
context
GrSurfaceProxy
*
src
GrMipMapped
SkBudgeted
budgeted
)
;
static
sk_sp
<
GrSurfaceContext
>
TestCopy
(
GrContext
*
context
const
GrSurfaceDesc
&
dstDesc
GrSurfaceOrigin
GrSurfaceProxy
*
srcProxy
)
;
bool
isWrapped_ForTesting
(
)
const
;
SkDEBUGCODE
(
void
validate
(
GrContext
*
)
const
;
)
inline
GrSurfaceProxyPriv
priv
(
)
;
inline
const
GrSurfaceProxyPriv
priv
(
)
const
;
GrInternalSurfaceFlags
testingOnly_getFlags
(
)
const
;
protected
:
GrSurfaceProxy
(
const
GrSurfaceDesc
&
desc
GrSurfaceOrigin
origin
SkBackingFit
fit
SkBudgeted
budgeted
GrInternalSurfaceFlags
surfaceFlags
)
:
GrSurfaceProxy
(
nullptr
LazyInstantiationType
:
:
kSingleUse
desc
origin
fit
budgeted
surfaceFlags
)
{
}
using
LazyInstantiateCallback
=
std
:
:
function
<
sk_sp
<
GrSurface
>
(
GrResourceProvider
*
)
>
;
GrSurfaceProxy
(
LazyInstantiateCallback
&
&
LazyInstantiationType
const
GrSurfaceDesc
&
GrSurfaceOrigin
SkBackingFit
SkBudgeted
GrInternalSurfaceFlags
)
;
GrSurfaceProxy
(
sk_sp
<
GrSurface
>
GrSurfaceOrigin
SkBackingFit
)
;
virtual
~
GrSurfaceProxy
(
)
;
friend
class
GrSurfaceProxyPriv
;
int32_t
getProxyRefCnt
(
)
const
{
return
this
-
>
internalGetProxyRefCnt
(
)
;
}
bool
hasPendingIO
(
)
const
{
return
this
-
>
internalHasPendingIO
(
)
;
}
bool
hasPendingWrite
(
)
const
{
return
this
-
>
internalHasPendingWrite
(
)
;
}
void
computeScratchKey
(
GrScratchKey
*
)
const
;
virtual
sk_sp
<
GrSurface
>
createSurface
(
GrResourceProvider
*
)
const
=
0
;
void
assign
(
sk_sp
<
GrSurface
>
surface
)
;
sk_sp
<
GrSurface
>
createSurfaceImpl
(
GrResourceProvider
*
int
sampleCnt
bool
needsStencil
GrSurfaceDescFlags
GrMipMapped
)
const
;
bool
instantiateImpl
(
GrResourceProvider
*
resourceProvider
int
sampleCnt
bool
needsStencil
GrSurfaceDescFlags
descFlags
GrMipMapped
const
GrUniqueKey
*
)
;
GrInternalSurfaceFlags
fSurfaceFlags
;
private
:
GrPixelConfig
fConfig
;
int
fWidth
;
int
fHeight
;
GrSurfaceOrigin
fOrigin
;
SkBackingFit
fFit
;
mutable
SkBudgeted
fBudgeted
;
const
UniqueID
fUniqueID
;
LazyInstantiateCallback
fLazyInstantiateCallback
;
LazyInstantiationType
fLazyInstantiationType
;
SkDEBUGCODE
(
void
validateSurface
(
const
GrSurface
*
)
;
)
SkDEBUGCODE
(
virtual
void
onValidateSurface
(
const
GrSurface
*
)
=
0
;
)
static
const
size_t
kInvalidGpuMemorySize
=
~
static_cast
<
size_t
>
(
0
)
;
SkDEBUGCODE
(
size_t
getRawGpuMemorySize_debugOnly
(
)
const
{
return
fGpuMemorySize
;
}
)
virtual
size_t
onUninstantiatedGpuMemorySize
(
)
const
=
0
;
bool
fNeedsClear
;
mutable
size_t
fGpuMemorySize
;
GrOpList
*
fLastOpList
;
typedef
GrIORefProxy
INHERITED
;
}
;
#
endif
