#
ifndef
SkUniquePtr_DEFINED
#
define
SkUniquePtr_DEFINED
#
include
"
SkTLogic
.
h
"
#
include
<
cstddef
>
#
include
<
utility
>
#
ifdef
MOZ_SKIA
#
include
"
mozilla
/
UniquePtr
.
h
"
namespace
skstd
{
using
mozilla
:
:
DefaultDelete
;
using
mozilla
:
:
UniquePtr
;
#
define
default_delete
DefaultDelete
#
define
unique_ptr
UniquePtr
}
#
else
namespace
skstd
{
template
<
typename
T
>
struct
default_delete
{
default_delete
(
)
=
default
;
template
<
typename
U
typename
=
enable_if_t
<
is_convertible
<
U
*
T
*
>
:
:
value
>
>
default_delete
(
const
default_delete
<
U
>
&
)
{
}
void
operator
(
)
(
T
*
obj
)
const
{
static_assert
(
sizeof
(
T
)
>
0
"
Deleting
pointer
to
incomplete
type
!
"
)
;
delete
obj
;
}
}
;
template
<
typename
T
>
struct
default_delete
<
T
[
]
>
{
default_delete
(
)
=
default
;
void
operator
(
)
(
T
*
obj
)
const
{
static_assert
(
sizeof
(
T
)
>
0
"
Deleting
pointer
to
incomplete
type
!
"
)
;
delete
[
]
obj
;
}
}
;
template
<
typename
T
typename
D
=
default_delete
<
T
>
>
class
unique_ptr
{
struct
pointer_type_detector
{
template
<
typename
U
>
static
typename
U
:
:
pointer
detector
(
typename
U
:
:
pointer
*
)
;
template
<
typename
U
>
static
T
*
detector
(
.
.
.
)
;
using
type
=
decltype
(
detector
<
remove_reference_t
<
D
>
>
(
0
)
)
;
}
;
public
:
using
pointer
=
typename
pointer_type_detector
:
:
type
;
using
element_type
=
T
;
using
deleter_type
=
D
;
private
:
template
<
typename
B
bool
=
std
:
:
is_empty
<
B
>
:
:
value
>
struct
compressed_base
:
private
B
{
compressed_base
(
)
:
B
(
)
{
}
compressed_base
(
const
B
&
b
)
:
B
(
b
)
{
}
compressed_base
(
B
&
&
b
)
:
B
(
std
:
:
move
(
b
)
)
{
}
B
&
get
(
)
{
return
*
this
;
}
B
const
&
get
(
)
const
{
return
*
this
;
}
void
swap
(
compressed_base
&
)
{
}
}
;
template
<
typename
B
>
struct
compressed_base
<
B
false
>
{
B
fb
;
compressed_base
(
)
:
B
(
)
{
}
compressed_base
(
const
B
&
b
)
:
fb
(
b
)
{
}
compressed_base
(
B
&
&
b
)
:
fb
(
std
:
:
move
(
b
)
)
{
}
B
&
get
(
)
{
return
fb
;
}
B
const
&
get
(
)
const
{
return
fb
;
}
void
swap
(
compressed_base
&
that
)
{
SkTSwap
(
fb
that
.
fB
)
;
}
}
;
struct
compressed_data
:
private
compressed_base
<
deleter_type
>
{
pointer
fPtr
;
compressed_data
(
)
:
compressed_base
<
deleter_type
>
(
)
fPtr
(
)
{
}
compressed_data
(
const
pointer
&
ptr
const
deleter_type
&
d
)
:
compressed_base
<
deleter_type
>
(
d
)
fPtr
(
ptr
)
{
}
template
<
typename
U1
typename
U2
typename
=
enable_if_t
<
is_convertible
<
U1
pointer
>
:
:
value
&
&
is_convertible
<
U2
deleter_type
>
:
:
value
>
>
compressed_data
(
U1
&
&
ptr
U2
&
&
d
)
:
compressed_base
<
deleter_type
>
(
std
:
:
forward
<
U2
>
(
d
)
)
fPtr
(
std
:
:
forward
<
U1
>
(
ptr
)
)
{
}
pointer
&
getPointer
(
)
{
return
fPtr
;
}
pointer
const
&
getPointer
(
)
const
{
return
fPtr
;
}
deleter_type
&
getDeleter
(
)
{
return
compressed_base
<
deleter_type
>
:
:
get
(
)
;
}
deleter_type
const
&
getDeleter
(
)
const
{
return
compressed_base
<
deleter_type
>
:
:
get
(
)
;
}
void
swap
(
compressed_data
&
that
)
{
compressed_base
<
deleter_type
>
:
:
swap
(
static_cast
<
compressed_base
<
deleter_type
>
>
(
that
)
)
;
SkTSwap
(
fPtr
that
.
fPtr
)
;
}
}
;
compressed_data
data
;
public
:
unique_ptr
(
)
:
data
(
)
{
static_assert
(
!
std
:
:
is_pointer
<
deleter_type
>
:
:
value
"
Deleter
nullptr
function
pointer
!
"
)
;
}
unique_ptr
(
std
:
:
nullptr_t
)
:
unique_ptr
(
)
{
}
explicit
unique_ptr
(
pointer
ptr
)
:
data
(
ptr
deleter_type
(
)
)
{
static_assert
(
!
std
:
:
is_pointer
<
deleter_type
>
:
:
value
"
Deleter
nullptr
function
pointer
!
"
)
;
}
unique_ptr
(
pointer
ptr
conditional_t
<
std
:
:
is_reference
<
deleter_type
>
:
:
value
deleter_type
const
deleter_type
&
>
d
)
:
data
(
ptr
d
)
{
}
unique_ptr
(
pointer
ptr
remove_reference_t
<
deleter_type
>
&
&
d
)
:
data
(
std
:
:
move
(
ptr
)
std
:
:
move
(
d
)
)
{
static_assert
(
!
std
:
:
is_reference
<
deleter_type
>
:
:
value
"
Binding
an
rvalue
reference
deleter
as
an
lvalue
reference
deleter
is
not
allowed
.
"
)
;
}
unique_ptr
(
unique_ptr
&
&
that
)
:
data
(
that
.
release
(
)
std
:
:
forward
<
deleter_type
>
(
that
.
get_deleter
(
)
)
)
{
}
template
<
typename
U
typename
ThatD
typename
=
enable_if_t
<
is_convertible
<
typename
unique_ptr
<
U
ThatD
>
:
:
pointer
pointer
>
:
:
value
&
&
!
std
:
:
is_array
<
U
>
:
:
value
&
&
conditional_t
<
std
:
:
is_reference
<
D
>
:
:
value
std
:
:
is_same
<
ThatD
D
>
is_convertible
<
ThatD
D
>
>
:
:
value
>
>
unique_ptr
(
unique_ptr
<
U
ThatD
>
&
&
that
)
:
data
(
that
.
release
(
)
std
:
:
forward
<
ThatD
>
(
that
.
get_deleter
(
)
)
)
{
}
~
unique_ptr
(
)
{
pointer
&
ptr
=
data
.
getPointer
(
)
;
if
(
ptr
!
=
nullptr
)
{
get_deleter
(
)
(
ptr
)
;
}
ptr
=
pointer
(
)
;
}
unique_ptr
&
operator
=
(
unique_ptr
&
&
that
)
{
reset
(
that
.
release
(
)
)
;
get_deleter
(
)
=
std
:
:
forward
<
deleter_type
>
(
that
.
get_deleter
(
)
)
;
return
*
this
;
}
template
<
typename
U
typename
ThatD
>
enable_if_t
<
is_convertible
<
typename
unique_ptr
<
U
ThatD
>
:
:
pointer
pointer
>
:
:
value
&
&
!
std
:
:
is_array
<
U
>
:
:
value
unique_ptr
&
>
operator
=
(
unique_ptr
<
U
ThatD
>
&
&
that
)
{
reset
(
that
.
release
(
)
)
;
get_deleter
(
)
=
std
:
:
forward
<
ThatD
>
(
that
.
get_deleter
(
)
)
;
return
*
this
;
}
unique_ptr
&
operator
=
(
std
:
:
nullptr_t
)
{
reset
(
)
;
return
*
this
;
}
add_lvalue_reference_t
<
element_type
>
operator
*
(
)
const
{
SkASSERT
(
get
(
)
!
=
pointer
(
)
)
;
return
*
get
(
)
;
}
pointer
operator
-
>
(
)
const
{
SkASSERT
(
get
(
)
!
=
pointer
(
)
)
;
return
get
(
)
;
}
pointer
get
(
)
const
{
return
data
.
getPointer
(
)
;
}
deleter_type
&
get_deleter
(
)
{
return
data
.
getDeleter
(
)
;
}
const
deleter_type
&
get_deleter
(
)
const
{
return
data
.
getDeleter
(
)
;
}
bool
is_attached
(
)
const
{
return
get
(
)
=
=
pointer
(
)
?
false
:
true
;
}
pointer
release
(
)
{
pointer
ptr
=
get
(
)
;
data
.
getPointer
(
)
=
pointer
(
)
;
return
ptr
;
}
void
reset
(
pointer
ptr
=
pointer
(
)
)
{
SkTSwap
(
data
.
getPointer
(
)
ptr
)
;
if
(
ptr
!
=
pointer
(
)
)
{
get_deleter
(
)
(
ptr
)
;
}
}
void
swap
(
unique_ptr
&
that
)
{
SkTSwap
(
data
that
.
data
)
;
}
unique_ptr
(
const
unique_ptr
&
)
=
delete
;
unique_ptr
&
operator
=
(
const
unique_ptr
&
)
=
delete
;
}
;
template
<
typename
T
typename
D
>
class
unique_ptr
<
T
[
]
D
>
{
struct
pointer_type_detector
{
template
<
typename
U
>
static
typename
U
:
:
pointer
detector
(
typename
U
:
:
pointer
*
)
;
template
<
typename
U
>
static
T
*
detector
(
.
.
.
)
;
using
type
=
decltype
(
detector
<
remove_reference_t
<
D
>
>
(
0
)
)
;
}
;
public
:
using
pointer
=
typename
pointer_type_detector
:
:
type
;
using
element_type
=
T
;
using
deleter_type
=
D
;
private
:
template
<
typename
B
bool
=
std
:
:
is_empty
<
B
>
:
:
value
>
struct
compressed_base
:
private
B
{
compressed_base
(
)
:
B
(
)
{
}
compressed_base
(
const
B
&
b
)
:
B
(
b
)
{
}
compressed_base
(
B
&
&
b
)
:
B
(
std
:
:
move
(
b
)
)
{
}
B
&
get
(
)
{
return
*
this
;
}
B
const
&
get
(
)
const
{
return
*
this
;
}
void
swap
(
compressed_base
&
)
{
}
}
;
template
<
typename
B
>
struct
compressed_base
<
B
false
>
{
B
fb
;
compressed_base
(
)
:
B
(
)
{
}
compressed_base
(
const
B
&
b
)
:
fb
(
b
)
{
}
compressed_base
(
B
&
&
b
)
:
fb
(
std
:
:
move
(
b
)
)
{
}
B
&
get
(
)
{
return
fb
;
}
B
const
&
get
(
)
const
{
return
fb
;
}
void
swap
(
compressed_base
&
that
)
{
SkTSwap
(
fb
that
.
fB
)
;
}
}
;
struct
compressed_data
:
private
compressed_base
<
deleter_type
>
{
pointer
fPtr
;
compressed_data
(
)
:
compressed_base
<
deleter_type
>
(
)
fPtr
(
)
{
}
compressed_data
(
const
pointer
&
ptr
const
deleter_type
&
d
)
:
compressed_base
<
deleter_type
>
(
d
)
fPtr
(
ptr
)
{
}
template
<
typename
U1
typename
U2
typename
=
enable_if_t
<
is_convertible
<
U1
pointer
>
:
:
value
&
&
is_convertible
<
U2
deleter_type
>
:
:
value
>
>
compressed_data
(
U1
&
&
ptr
U2
&
&
d
)
:
compressed_base
<
deleter_type
>
(
std
:
:
forward
<
U2
>
(
d
)
)
fPtr
(
std
:
:
forward
<
U1
>
(
ptr
)
)
{
}
pointer
&
getPointer
(
)
{
return
fPtr
;
}
pointer
const
&
getPointer
(
)
const
{
return
fPtr
;
}
deleter_type
&
getDeleter
(
)
{
return
compressed_base
<
deleter_type
>
:
:
get
(
)
;
}
deleter_type
const
&
getDeleter
(
)
const
{
return
compressed_base
<
deleter_type
>
:
:
get
(
)
;
}
void
swap
(
compressed_data
&
that
)
{
compressed_base
<
deleter_type
>
:
:
swap
(
static_cast
<
compressed_base
<
deleter_type
>
>
(
that
)
)
;
SkTSwap
(
fPtr
that
.
fPtr
)
;
}
}
;
compressed_data
data
;
public
:
unique_ptr
(
)
:
data
(
)
{
static_assert
(
!
std
:
:
is_pointer
<
deleter_type
>
:
:
value
"
Deleter
nullptr
function
pointer
!
"
)
;
}
unique_ptr
(
std
:
:
nullptr_t
)
:
unique_ptr
(
)
{
}
explicit
unique_ptr
(
pointer
ptr
)
:
data
(
ptr
deleter_type
(
)
)
{
static_assert
(
!
std
:
:
is_pointer
<
deleter_type
>
:
:
value
"
Deleter
nullptr
function
pointer
!
"
)
;
}
unique_ptr
(
pointer
ptr
conditional_t
<
std
:
:
is_reference
<
deleter_type
>
:
:
value
deleter_type
const
deleter_type
&
>
d
)
:
data
(
ptr
d
)
{
}
unique_ptr
(
pointer
ptr
remove_reference_t
<
deleter_type
>
&
&
d
)
:
data
(
std
:
:
move
(
ptr
)
std
:
:
move
(
d
)
)
{
static_assert
(
!
std
:
:
is_reference
<
deleter_type
>
:
:
value
"
Binding
an
rvalue
reference
deleter
as
an
lvalue
reference
deleter
is
not
allowed
.
"
)
;
}
unique_ptr
(
unique_ptr
&
&
that
)
:
data
(
that
.
release
(
)
std
:
:
forward
<
deleter_type
>
(
that
.
get_deleter
(
)
)
)
{
}
~
unique_ptr
(
)
{
pointer
&
ptr
=
data
.
getPointer
(
)
;
if
(
ptr
!
=
nullptr
)
{
get_deleter
(
)
(
ptr
)
;
}
ptr
=
pointer
(
)
;
}
unique_ptr
&
operator
=
(
unique_ptr
&
&
that
)
{
reset
(
that
.
release
(
)
)
;
get_deleter
(
)
=
std
:
:
forward
<
deleter_type
>
(
that
.
get_deleter
(
)
)
;
return
*
this
;
}
unique_ptr
&
operator
=
(
std
:
:
nullptr_t
)
{
reset
(
)
;
return
*
this
;
}
add_lvalue_reference_t
<
element_type
>
operator
[
]
(
size_t
i
)
const
{
SkASSERT
(
get
(
)
!
=
pointer
(
)
)
;
return
get
(
)
[
i
]
;
}
pointer
get
(
)
const
{
return
data
.
getPointer
(
)
;
}
deleter_type
&
get_deleter
(
)
{
return
data
.
getDeleter
(
)
;
}
const
deleter_type
&
get_deleter
(
)
const
{
return
data
.
getDeleter
(
)
;
}
bool
is_attached
(
)
const
{
return
get
(
)
=
=
pointer
(
)
?
false
:
true
;
}
pointer
release
(
)
{
pointer
ptr
=
get
(
)
;
data
.
getPointer
(
)
=
pointer
(
)
;
return
ptr
;
}
void
reset
(
pointer
ptr
=
pointer
(
)
)
{
SkTSwap
(
data
.
getPointer
(
)
ptr
)
;
if
(
ptr
!
=
pointer
(
)
)
{
get_deleter
(
)
(
ptr
)
;
}
}
template
<
typename
U
>
void
reset
(
U
*
)
=
delete
;
void
swap
(
unique_ptr
&
that
)
{
data
.
swap
(
that
.
data
)
;
}
unique_ptr
(
const
unique_ptr
&
)
=
delete
;
unique_ptr
&
operator
=
(
const
unique_ptr
&
)
=
delete
;
}
;
template
<
typename
T
typename
D
>
inline
void
swap
(
unique_ptr
<
T
D
>
&
a
unique_ptr
<
T
D
>
&
b
)
{
a
.
swap
(
b
)
;
}
template
<
typename
T
typename
D
typename
U
typename
ThatD
>
inline
bool
operator
=
=
(
const
unique_ptr
<
T
D
>
&
a
const
unique_ptr
<
U
ThatD
>
&
b
)
{
return
a
.
get
(
)
=
=
b
.
get
(
)
;
}
template
<
typename
T
typename
D
>
inline
bool
operator
=
=
(
const
unique_ptr
<
T
D
>
&
a
std
:
:
nullptr_t
)
{
return
!
a
.
is_attached
(
)
;
}
template
<
typename
T
typename
D
>
inline
bool
operator
=
=
(
std
:
:
nullptr_t
const
unique_ptr
<
T
D
>
&
b
)
{
return
!
b
.
is_attached
(
)
;
}
template
<
typename
T
typename
D
typename
U
typename
ThatD
>
inline
bool
operator
!
=
(
const
unique_ptr
<
T
D
>
&
a
const
unique_ptr
<
U
ThatD
>
&
b
)
{
return
a
.
get
(
)
!
=
b
.
get
(
)
;
}
template
<
typename
T
typename
D
>
inline
bool
operator
!
=
(
const
unique_ptr
<
T
D
>
&
a
std
:
:
nullptr_t
)
{
return
a
.
is_attached
(
)
;
}
template
<
typename
T
typename
D
>
inline
bool
operator
!
=
(
std
:
:
nullptr_t
const
unique_ptr
<
T
D
>
&
b
)
{
return
b
.
is_attached
(
)
;
}
}
#
endif
#
endif
