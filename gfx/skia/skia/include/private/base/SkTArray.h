#
ifndef
SkTArray_DEFINED
#
define
SkTArray_DEFINED
#
include
"
include
/
private
/
base
/
SkAlignedStorage
.
h
"
#
include
"
include
/
private
/
base
/
SkAssert
.
h
"
#
include
"
include
/
private
/
base
/
SkAttributes
.
h
"
#
include
"
include
/
private
/
base
/
SkContainers
.
h
"
#
include
"
include
/
private
/
base
/
SkMalloc
.
h
"
#
include
"
include
/
private
/
base
/
SkMath
.
h
"
#
include
"
include
/
private
/
base
/
SkSpan_impl
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
include
/
private
/
base
/
SkTypeTraits
.
h
"
#
include
<
algorithm
>
#
include
<
climits
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
initializer_list
>
#
include
<
new
>
#
include
<
utility
>
namespace
skia_private
{
template
<
typename
T
bool
MEM_MOVE
=
sk_is_trivially_relocatable_v
<
T
>
>
class
TArray
{
public
:
using
value_type
=
T
;
TArray
(
)
:
fOwnMemory
(
true
)
fCapacity
{
0
}
{
}
explicit
TArray
(
int
reserveCount
)
:
TArray
(
)
{
this
-
>
reserve_back
(
reserveCount
)
;
}
TArray
(
const
TArray
&
that
)
:
TArray
(
that
.
fData
that
.
fSize
)
{
}
TArray
(
TArray
&
&
that
)
{
if
(
that
.
fOwnMemory
)
{
this
-
>
setData
(
that
)
;
that
.
setData
(
{
}
)
;
}
else
{
this
-
>
initData
(
that
.
fSize
)
;
that
.
move
(
fData
)
;
}
fSize
=
std
:
:
exchange
(
that
.
fSize
0
)
;
}
TArray
(
const
T
*
array
int
count
)
{
this
-
>
initData
(
count
)
;
this
-
>
copy
(
array
)
;
}
TArray
(
std
:
:
initializer_list
<
T
>
data
)
:
TArray
(
data
.
begin
(
)
data
.
size
(
)
)
{
}
TArray
&
operator
=
(
const
TArray
&
that
)
{
if
(
this
=
=
&
that
)
{
return
*
this
;
}
this
-
>
clear
(
)
;
this
-
>
checkRealloc
(
that
.
size
(
)
kExactFit
)
;
fSize
=
that
.
fSize
;
this
-
>
copy
(
that
.
fData
)
;
return
*
this
;
}
TArray
&
operator
=
(
TArray
&
&
that
)
{
if
(
this
!
=
&
that
)
{
this
-
>
clear
(
)
;
if
(
that
.
fOwnMemory
)
{
if
(
fOwnMemory
)
{
sk_free
(
fData
)
;
}
fData
=
std
:
:
exchange
(
that
.
fData
nullptr
)
;
fCapacity
=
that
.
fCapacity
;
that
.
fCapacity
=
0
;
fOwnMemory
=
true
;
}
else
{
this
-
>
checkRealloc
(
that
.
size
(
)
kExactFit
)
;
that
.
move
(
fData
)
;
}
fSize
=
std
:
:
exchange
(
that
.
fSize
0
)
;
}
return
*
this
;
}
~
TArray
(
)
{
this
-
>
destroyAll
(
)
;
if
(
fOwnMemory
)
{
sk_free
(
fData
)
;
}
}
void
reset
(
int
n
)
{
SkASSERT
(
n
>
=
0
)
;
this
-
>
clear
(
)
;
this
-
>
checkRealloc
(
n
kExactFit
)
;
fSize
=
n
;
for
(
int
i
=
0
;
i
<
this
-
>
size
(
)
;
+
+
i
)
{
new
(
fData
+
i
)
T
;
}
}
void
reset
(
const
T
*
array
int
count
)
{
SkASSERT
(
count
>
=
0
)
;
this
-
>
clear
(
)
;
this
-
>
checkRealloc
(
count
kExactFit
)
;
fSize
=
count
;
this
-
>
copy
(
array
)
;
}
void
reserve
(
int
n
)
{
SkASSERT
(
n
>
=
0
)
;
if
(
n
>
this
-
>
size
(
)
)
{
this
-
>
checkRealloc
(
n
-
this
-
>
size
(
)
kGrowing
)
;
}
}
void
reserve_back
(
int
n
)
{
SkASSERT
(
n
>
=
0
)
;
if
(
n
>
0
)
{
this
-
>
checkRealloc
(
n
kExactFit
)
;
}
}
void
removeShuffle
(
int
n
)
{
SkASSERT
(
n
<
this
-
>
size
(
)
)
;
int
newCount
=
fSize
-
1
;
fSize
=
newCount
;
fData
[
n
]
.
~
T
(
)
;
if
(
n
!
=
newCount
)
{
this
-
>
move
(
n
newCount
)
;
}
}
bool
empty
(
)
const
{
return
fSize
=
=
0
;
}
T
&
push_back
(
)
{
void
*
newT
=
this
-
>
push_back_raw
(
1
)
;
return
*
new
(
newT
)
T
;
}
T
&
push_back
(
const
T
&
t
)
{
void
*
newT
=
this
-
>
push_back_raw
(
1
)
;
return
*
new
(
newT
)
T
(
t
)
;
}
T
&
push_back
(
T
&
&
t
)
{
void
*
newT
=
this
-
>
push_back_raw
(
1
)
;
return
*
new
(
newT
)
T
(
std
:
:
move
(
t
)
)
;
}
template
<
class
.
.
.
Args
>
T
&
emplace_back
(
Args
&
&
.
.
.
args
)
{
void
*
newT
=
this
-
>
push_back_raw
(
1
)
;
return
*
new
(
newT
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
}
T
*
push_back_n
(
int
n
)
{
SkASSERT
(
n
>
=
0
)
;
T
*
newTs
=
TCast
(
this
-
>
push_back_raw
(
n
)
)
;
for
(
int
i
=
0
;
i
<
n
;
+
+
i
)
{
new
(
&
newTs
[
i
]
)
T
;
}
return
newTs
;
}
T
*
push_back_n
(
int
n
const
T
&
t
)
{
SkASSERT
(
n
>
=
0
)
;
T
*
newTs
=
TCast
(
this
-
>
push_back_raw
(
n
)
)
;
for
(
int
i
=
0
;
i
<
n
;
+
+
i
)
{
new
(
&
newTs
[
i
]
)
T
(
t
)
;
}
return
static_cast
<
T
*
>
(
newTs
)
;
}
T
*
push_back_n
(
int
n
const
T
t
[
]
)
{
SkASSERT
(
n
>
=
0
)
;
this
-
>
checkRealloc
(
n
kGrowing
)
;
T
*
end
=
this
-
>
end
(
)
;
for
(
int
i
=
0
;
i
<
n
;
+
+
i
)
{
new
(
end
+
i
)
T
(
t
[
i
]
)
;
}
fSize
+
=
n
;
return
end
;
}
T
*
move_back_n
(
int
n
T
*
t
)
{
SkASSERT
(
n
>
=
0
)
;
this
-
>
checkRealloc
(
n
kGrowing
)
;
T
*
end
=
this
-
>
end
(
)
;
for
(
int
i
=
0
;
i
<
n
;
+
+
i
)
{
new
(
end
+
i
)
T
(
std
:
:
move
(
t
[
i
]
)
)
;
}
fSize
+
=
n
;
return
end
;
}
void
pop_back
(
)
{
SkASSERT
(
fSize
>
0
)
;
-
-
fSize
;
fData
[
fSize
]
.
~
T
(
)
;
}
void
pop_back_n
(
int
n
)
{
SkASSERT
(
n
>
=
0
)
;
SkASSERT
(
this
-
>
size
(
)
>
=
n
)
;
int
i
=
fSize
;
while
(
i
-
-
>
fSize
-
n
)
{
(
*
this
)
[
i
]
.
~
T
(
)
;
}
fSize
-
=
n
;
}
void
resize_back
(
int
newCount
)
{
SkASSERT
(
newCount
>
=
0
)
;
if
(
newCount
>
this
-
>
size
(
)
)
{
this
-
>
push_back_n
(
newCount
-
fSize
)
;
}
else
if
(
newCount
<
this
-
>
size
(
)
)
{
this
-
>
pop_back_n
(
fSize
-
newCount
)
;
}
}
void
swap
(
TArray
&
that
)
{
using
std
:
:
swap
;
if
(
this
=
=
&
that
)
{
return
;
}
if
(
fOwnMemory
&
&
that
.
fOwnMemory
)
{
swap
(
fData
that
.
fData
)
;
swap
(
fSize
that
.
fSize
)
;
auto
allocCount
=
fCapacity
;
fCapacity
=
that
.
fCapacity
;
that
.
fCapacity
=
allocCount
;
}
else
{
TArray
copy
(
std
:
:
move
(
that
)
)
;
that
=
std
:
:
move
(
*
this
)
;
*
this
=
std
:
:
move
(
copy
)
;
}
}
T
*
begin
(
)
{
return
fData
;
}
const
T
*
begin
(
)
const
{
return
fData
;
}
T
*
end
(
)
{
if
(
fData
=
=
nullptr
)
{
SkASSERT
(
fSize
=
=
0
)
;
}
return
fData
+
fSize
;
}
const
T
*
end
(
)
const
{
if
(
fData
=
=
nullptr
)
{
SkASSERT
(
fSize
=
=
0
)
;
}
return
fData
+
fSize
;
}
T
*
data
(
)
{
return
fData
;
}
const
T
*
data
(
)
const
{
return
fData
;
}
int
size
(
)
const
{
return
fSize
;
}
size_t
size_bytes
(
)
const
{
return
this
-
>
bytes
(
fSize
)
;
}
void
resize
(
size_t
count
)
{
this
-
>
resize_back
(
(
int
)
count
)
;
}
void
clear
(
)
{
this
-
>
destroyAll
(
)
;
fSize
=
0
;
}
void
shrink_to_fit
(
)
{
if
(
!
fOwnMemory
|
|
fSize
=
=
fCapacity
)
{
return
;
}
if
(
fSize
=
=
0
)
{
sk_free
(
fData
)
;
fData
=
nullptr
;
fCapacity
=
0
;
}
else
{
SkSpan
<
std
:
:
byte
>
allocation
=
Allocate
(
fSize
)
;
this
-
>
move
(
TCast
(
allocation
.
data
(
)
)
)
;
if
(
fOwnMemory
)
{
sk_free
(
fData
)
;
}
this
-
>
setDataFromBytes
(
allocation
)
;
}
}
T
&
operator
[
]
(
int
i
)
{
SkASSERT
(
i
<
this
-
>
size
(
)
)
;
SkASSERT
(
i
>
=
0
)
;
return
fData
[
i
]
;
}
const
T
&
operator
[
]
(
int
i
)
const
{
SkASSERT
(
i
<
this
-
>
size
(
)
)
;
SkASSERT
(
i
>
=
0
)
;
return
fData
[
i
]
;
}
T
&
at
(
int
i
)
{
return
(
*
this
)
[
i
]
;
}
const
T
&
at
(
int
i
)
const
{
return
(
*
this
)
[
i
]
;
}
T
&
front
(
)
{
SkASSERT
(
fSize
>
0
)
;
return
fData
[
0
]
;
}
const
T
&
front
(
)
const
{
SkASSERT
(
fSize
>
0
)
;
return
fData
[
0
]
;
}
T
&
back
(
)
{
SkASSERT
(
fSize
)
;
return
fData
[
fSize
-
1
]
;
}
const
T
&
back
(
)
const
{
SkASSERT
(
fSize
>
0
)
;
return
fData
[
fSize
-
1
]
;
}
T
&
fromBack
(
int
i
)
{
SkASSERT
(
i
>
=
0
)
;
SkASSERT
(
i
<
this
-
>
size
(
)
)
;
return
fData
[
fSize
-
i
-
1
]
;
}
const
T
&
fromBack
(
int
i
)
const
{
SkASSERT
(
i
>
=
0
)
;
SkASSERT
(
i
<
this
-
>
size
(
)
)
;
return
fData
[
fSize
-
i
-
1
]
;
}
bool
operator
=
=
(
const
TArray
<
T
MEM_MOVE
>
&
right
)
const
{
int
leftCount
=
this
-
>
size
(
)
;
if
(
leftCount
!
=
right
.
size
(
)
)
{
return
false
;
}
for
(
int
index
=
0
;
index
<
leftCount
;
+
+
index
)
{
if
(
fData
[
index
]
!
=
right
.
fData
[
index
]
)
{
return
false
;
}
}
return
true
;
}
bool
operator
!
=
(
const
TArray
<
T
MEM_MOVE
>
&
right
)
const
{
return
!
(
*
this
=
=
right
)
;
}
int
capacity
(
)
const
{
return
fCapacity
;
}
protected
:
template
<
int
InitialCapacity
>
TArray
(
SkAlignedSTStorage
<
InitialCapacity
T
>
*
storage
int
size
=
0
)
{
static_assert
(
InitialCapacity
>
=
0
)
;
SkASSERT
(
size
>
=
0
)
;
SkASSERT
(
storage
-
>
get
(
)
!
=
nullptr
)
;
if
(
size
>
InitialCapacity
)
{
this
-
>
initData
(
size
)
;
}
else
{
this
-
>
setDataFromBytes
(
*
storage
)
;
fSize
=
size
;
fOwnMemory
=
false
;
}
}
template
<
int
InitialCapacity
>
TArray
(
const
T
*
array
int
size
SkAlignedSTStorage
<
InitialCapacity
T
>
*
storage
)
:
TArray
{
storage
size
}
{
this
-
>
copy
(
array
)
;
}
private
:
static
constexpr
double
kExactFit
=
1
.
0
;
static
constexpr
double
kGrowing
=
1
.
5
;
static
constexpr
int
kMinHeapAllocCount
=
8
;
static_assert
(
SkIsPow2
(
kMinHeapAllocCount
)
"
min
alloc
count
not
power
of
two
.
"
)
;
static
constexpr
int
kMaxCapacity
=
SkToInt
(
std
:
:
min
(
SIZE_MAX
/
sizeof
(
T
)
(
size_t
)
INT_MAX
)
)
;
void
setDataFromBytes
(
SkSpan
<
std
:
:
byte
>
allocation
)
{
T
*
data
=
TCast
(
allocation
.
data
(
)
)
;
size_t
size
=
std
:
:
min
(
allocation
.
size
(
)
/
sizeof
(
T
)
SkToSizeT
(
kMaxCapacity
)
)
;
setData
(
SkSpan
<
T
>
(
data
size
)
)
;
}
void
setData
(
SkSpan
<
T
>
array
)
{
fData
=
array
.
data
(
)
;
fCapacity
=
SkToU32
(
array
.
size
(
)
)
;
fOwnMemory
=
true
;
}
#
ifdef
__clang__
SK_NO_SANITIZE
(
"
cfi
"
)
#
elif
defined
(
__GNUC__
)
SK_ATTRIBUTE
(
no_sanitize_undefined
)
#
endif
static
T
*
TCast
(
void
*
buffer
)
{
return
(
T
*
)
buffer
;
}
size_t
bytes
(
int
n
)
const
{
SkASSERT
(
n
<
=
kMaxCapacity
)
;
return
SkToSizeT
(
n
)
*
sizeof
(
T
)
;
}
static
SkSpan
<
std
:
:
byte
>
Allocate
(
int
capacity
double
growthFactor
=
1
.
0
)
{
return
SkContainerAllocator
{
sizeof
(
T
)
kMaxCapacity
}
.
allocate
(
capacity
growthFactor
)
;
}
void
initData
(
int
count
)
{
this
-
>
setDataFromBytes
(
Allocate
(
count
)
)
;
fSize
=
count
;
}
void
destroyAll
(
)
{
if
(
!
this
-
>
empty
(
)
)
{
T
*
cursor
=
this
-
>
begin
(
)
;
T
*
const
end
=
this
-
>
end
(
)
;
do
{
cursor
-
>
~
T
(
)
;
cursor
+
+
;
}
while
(
cursor
<
end
)
;
}
}
void
copy
(
const
T
*
src
)
{
if
constexpr
(
std
:
:
is_trivially_copyable_v
<
T
>
)
{
if
(
!
this
-
>
empty
(
)
&
&
src
!
=
nullptr
)
{
sk_careful_memcpy
(
fData
src
this
-
>
size_bytes
(
)
)
;
}
}
else
{
for
(
int
i
=
0
;
i
<
this
-
>
size
(
)
;
+
+
i
)
{
new
(
fData
+
i
)
T
(
src
[
i
]
)
;
}
}
}
void
move
(
int
dst
int
src
)
{
if
constexpr
(
MEM_MOVE
)
{
memcpy
(
static_cast
<
void
*
>
(
&
fData
[
dst
]
)
static_cast
<
const
void
*
>
(
&
fData
[
src
]
)
sizeof
(
T
)
)
;
}
else
{
new
(
&
fData
[
dst
]
)
T
(
std
:
:
move
(
fData
[
src
]
)
)
;
fData
[
src
]
.
~
T
(
)
;
}
}
void
move
(
void
*
dst
)
{
if
constexpr
(
MEM_MOVE
)
{
sk_careful_memcpy
(
dst
fData
this
-
>
bytes
(
fSize
)
)
;
}
else
{
for
(
int
i
=
0
;
i
<
this
-
>
size
(
)
;
+
+
i
)
{
new
(
static_cast
<
char
*
>
(
dst
)
+
this
-
>
bytes
(
i
)
)
T
(
std
:
:
move
(
fData
[
i
]
)
)
;
fData
[
i
]
.
~
T
(
)
;
}
}
}
void
*
push_back_raw
(
int
n
)
{
this
-
>
checkRealloc
(
n
kGrowing
)
;
void
*
ptr
=
fData
+
fSize
;
fSize
+
=
n
;
return
ptr
;
}
void
checkRealloc
(
int
delta
double
growthFactor
)
{
SkASSERT
(
delta
>
=
0
)
;
SkASSERT
(
fSize
>
=
0
)
;
SkASSERT
(
fCapacity
>
=
0
)
;
if
(
this
-
>
capacity
(
)
-
fSize
>
=
delta
)
{
return
;
}
if
(
delta
>
kMaxCapacity
-
fSize
)
{
sk_report_container_overflow_and_die
(
)
;
}
const
int
newCount
=
fSize
+
delta
;
SkSpan
<
std
:
:
byte
>
allocation
=
Allocate
(
newCount
growthFactor
)
;
this
-
>
move
(
TCast
(
allocation
.
data
(
)
)
)
;
if
(
fOwnMemory
)
{
sk_free
(
fData
)
;
}
this
-
>
setDataFromBytes
(
allocation
)
;
SkASSERT
(
this
-
>
capacity
(
)
>
=
newCount
)
;
SkASSERT
(
fData
!
=
nullptr
)
;
}
T
*
fData
{
nullptr
}
;
int
fSize
{
0
}
;
uint32_t
fOwnMemory
:
1
;
uint32_t
fCapacity
:
31
;
}
;
template
<
typename
T
bool
M
>
static
inline
void
swap
(
TArray
<
T
M
>
&
a
TArray
<
T
M
>
&
b
)
{
a
.
swap
(
b
)
;
}
}
template
<
int
N
typename
T
bool
MEM_MOVE
=
sk_is_trivially_relocatable_v
<
T
>
>
class
SkSTArray
:
private
SkAlignedSTStorage
<
N
T
>
public
skia_private
:
:
TArray
<
T
MEM_MOVE
>
{
private
:
static_assert
(
N
>
0
)
;
using
STORAGE
=
SkAlignedSTStorage
<
N
T
>
;
using
INHERITED
=
skia_private
:
:
TArray
<
T
MEM_MOVE
>
;
public
:
SkSTArray
(
)
:
STORAGE
{
}
INHERITED
(
static_cast
<
STORAGE
*
>
(
this
)
)
{
}
SkSTArray
(
const
T
*
array
int
count
)
:
STORAGE
{
}
INHERITED
(
array
count
static_cast
<
STORAGE
*
>
(
this
)
)
{
}
SkSTArray
(
std
:
:
initializer_list
<
T
>
data
)
:
SkSTArray
(
data
.
begin
(
)
SkToInt
(
data
.
size
(
)
)
)
{
}
explicit
SkSTArray
(
int
reserveCount
)
:
SkSTArray
(
)
{
this
-
>
reserve_back
(
reserveCount
)
;
}
SkSTArray
(
const
SkSTArray
&
that
)
:
SkSTArray
(
)
{
*
this
=
that
;
}
explicit
SkSTArray
(
const
INHERITED
&
that
)
:
SkSTArray
(
)
{
*
this
=
that
;
}
SkSTArray
(
SkSTArray
&
&
that
)
:
SkSTArray
(
)
{
*
this
=
std
:
:
move
(
that
)
;
}
explicit
SkSTArray
(
INHERITED
&
&
that
)
:
SkSTArray
(
)
{
*
this
=
std
:
:
move
(
that
)
;
}
SkSTArray
&
operator
=
(
const
SkSTArray
&
that
)
{
INHERITED
:
:
operator
=
(
that
)
;
return
*
this
;
}
SkSTArray
&
operator
=
(
const
INHERITED
&
that
)
{
INHERITED
:
:
operator
=
(
that
)
;
return
*
this
;
}
SkSTArray
&
operator
=
(
SkSTArray
&
&
that
)
{
INHERITED
:
:
operator
=
(
std
:
:
move
(
that
)
)
;
return
*
this
;
}
SkSTArray
&
operator
=
(
INHERITED
&
&
that
)
{
INHERITED
:
:
operator
=
(
std
:
:
move
(
that
)
)
;
return
*
this
;
}
using
INHERITED
:
:
data
;
using
INHERITED
:
:
size
;
}
;
template
<
typename
T
bool
MEM_MOVE
=
sk_is_trivially_relocatable_v
<
T
>
>
using
SkTArray
=
skia_private
:
:
TArray
<
T
MEM_MOVE
>
;
#
endif
