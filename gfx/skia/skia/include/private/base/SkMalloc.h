#
ifndef
SkMalloc_DEFINED
#
define
SkMalloc_DEFINED
#
include
<
cstring
>
#
include
"
include
/
private
/
base
/
SkAPI
.
h
"
SK_API
extern
void
sk_free
(
void
*
)
;
SK_API
extern
void
sk_out_of_memory
(
void
)
;
enum
{
SK_MALLOC_ZERO_INITIALIZE
=
1
<
<
0
SK_MALLOC_THROW
=
1
<
<
1
}
;
SK_API
extern
void
*
sk_malloc_flags
(
size_t
size
unsigned
flags
)
;
SK_API
extern
void
*
sk_realloc_throw
(
void
*
buffer
size_t
size
)
;
static
inline
void
*
sk_malloc_throw
(
size_t
size
)
{
return
sk_malloc_flags
(
size
SK_MALLOC_THROW
)
;
}
static
inline
void
*
sk_calloc_throw
(
size_t
size
)
{
return
sk_malloc_flags
(
size
SK_MALLOC_THROW
|
SK_MALLOC_ZERO_INITIALIZE
)
;
}
static
inline
void
*
sk_calloc_canfail
(
size_t
size
)
{
#
if
defined
(
SK_BUILD_FOR_FUZZER
)
if
(
size
>
200000
)
{
return
nullptr
;
}
#
endif
return
sk_malloc_flags
(
size
SK_MALLOC_ZERO_INITIALIZE
)
;
}
SK_API
extern
void
*
sk_calloc_throw
(
size_t
count
size_t
elemSize
)
;
SK_API
extern
void
*
sk_malloc_throw
(
size_t
count
size_t
elemSize
)
;
SK_API
extern
void
*
sk_realloc_throw
(
void
*
buffer
size_t
count
size_t
elemSize
)
;
static
inline
void
*
sk_malloc_canfail
(
size_t
size
)
{
#
if
defined
(
SK_BUILD_FOR_FUZZER
)
if
(
size
>
200000
)
{
return
nullptr
;
}
#
endif
return
sk_malloc_flags
(
size
0
)
;
}
SK_API
extern
void
*
sk_malloc_canfail
(
size_t
count
size_t
elemSize
)
;
static
inline
void
sk_bzero
(
void
*
buffer
size_t
size
)
{
if
(
size
)
{
memset
(
buffer
0
size
)
;
}
}
static
inline
void
*
sk_careful_memcpy
(
void
*
dst
const
void
*
src
size_t
len
)
{
if
(
len
)
{
memcpy
(
dst
src
len
)
;
}
return
dst
;
}
static
inline
void
*
sk_careful_memmove
(
void
*
dst
const
void
*
src
size_t
len
)
{
if
(
len
)
{
memmove
(
dst
src
len
)
;
}
return
dst
;
}
static
inline
int
sk_careful_memcmp
(
const
void
*
a
const
void
*
b
size_t
len
)
{
if
(
len
=
=
0
)
{
return
0
;
}
return
memcmp
(
a
b
len
)
;
}
#
endif
