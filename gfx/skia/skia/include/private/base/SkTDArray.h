#
ifndef
SkTDArray_DEFINED
#
define
SkTDArray_DEFINED
#
include
"
include
/
private
/
base
/
SkAPI
.
h
"
#
include
"
include
/
private
/
base
/
SkAssert
.
h
"
#
include
"
include
/
private
/
base
/
SkDebug
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
initializer_list
>
class
SK_SPI
SkTDStorage
{
public
:
explicit
SkTDStorage
(
int
sizeOfT
)
;
SkTDStorage
(
const
void
*
src
int
size
int
sizeOfT
)
;
SkTDStorage
(
const
SkTDStorage
&
that
)
;
SkTDStorage
&
operator
=
(
const
SkTDStorage
&
that
)
;
SkTDStorage
(
SkTDStorage
&
&
that
)
;
SkTDStorage
&
operator
=
(
SkTDStorage
&
&
that
)
;
~
SkTDStorage
(
)
;
void
reset
(
)
;
void
swap
(
SkTDStorage
&
that
)
;
bool
empty
(
)
const
{
return
fSize
=
=
0
;
}
void
clear
(
)
{
fSize
=
0
;
}
int
size
(
)
const
{
return
fSize
;
}
void
resize
(
int
newSize
)
;
size_t
size_bytes
(
)
const
{
return
this
-
>
bytes
(
fSize
)
;
}
int
capacity
(
)
const
{
return
fCapacity
;
}
void
reserve
(
int
newCapacity
)
;
void
shrink_to_fit
(
)
;
void
*
data
(
)
{
return
fStorage
;
}
const
void
*
data
(
)
const
{
return
fStorage
;
}
void
erase
(
int
index
int
count
)
;
void
removeShuffle
(
int
index
)
;
void
*
prepend
(
)
;
void
append
(
)
;
void
append
(
int
count
)
;
void
*
append
(
const
void
*
src
int
count
)
;
void
*
insert
(
int
index
)
;
void
*
insert
(
int
index
int
count
const
void
*
src
)
;
void
pop_back
(
)
{
SkASSERT
(
fSize
>
0
)
;
fSize
-
-
;
}
friend
bool
operator
=
=
(
const
SkTDStorage
&
a
const
SkTDStorage
&
b
)
;
friend
bool
operator
!
=
(
const
SkTDStorage
&
a
const
SkTDStorage
&
b
)
{
return
!
(
a
=
=
b
)
;
}
private
:
size_t
bytes
(
int
n
)
const
{
return
SkToSizeT
(
n
*
fSizeOfT
)
;
}
void
*
address
(
int
n
)
{
return
fStorage
+
this
-
>
bytes
(
n
)
;
}
int
calculateSizeOrDie
(
int
delta
)
;
void
moveTail
(
int
dstIndex
int
tailStart
int
tailEnd
)
;
void
copySrc
(
int
dstIndex
const
void
*
src
int
count
)
;
const
int
fSizeOfT
;
std
:
:
byte
*
fStorage
{
nullptr
}
;
int
fCapacity
{
0
}
;
int
fSize
{
0
}
;
}
;
static
inline
void
swap
(
SkTDStorage
&
a
SkTDStorage
&
b
)
{
a
.
swap
(
b
)
;
}
template
<
typename
T
>
class
SkTDArray
{
public
:
SkTDArray
(
)
:
fStorage
{
sizeof
(
T
)
}
{
}
SkTDArray
(
const
T
src
[
]
int
count
)
:
fStorage
{
src
count
sizeof
(
T
)
}
{
}
SkTDArray
(
const
std
:
:
initializer_list
<
T
>
&
list
)
:
SkTDArray
(
list
.
begin
(
)
list
.
size
(
)
)
{
}
SkTDArray
(
const
SkTDArray
<
T
>
&
src
)
:
SkTDArray
(
src
.
data
(
)
src
.
size
(
)
)
{
}
SkTDArray
<
T
>
&
operator
=
(
const
SkTDArray
<
T
>
&
src
)
{
fStorage
=
src
.
fStorage
;
return
*
this
;
}
SkTDArray
(
SkTDArray
<
T
>
&
&
src
)
:
fStorage
{
std
:
:
move
(
src
.
fStorage
)
}
{
}
SkTDArray
<
T
>
&
operator
=
(
SkTDArray
<
T
>
&
&
src
)
{
fStorage
=
std
:
:
move
(
src
.
fStorage
)
;
return
*
this
;
}
friend
bool
operator
=
=
(
const
SkTDArray
<
T
>
&
a
const
SkTDArray
<
T
>
&
b
)
{
return
a
.
fStorage
=
=
b
.
fStorage
;
}
friend
bool
operator
!
=
(
const
SkTDArray
<
T
>
&
a
const
SkTDArray
<
T
>
&
b
)
{
return
!
(
a
=
=
b
)
;
}
void
swap
(
SkTDArray
<
T
>
&
that
)
{
using
std
:
:
swap
;
swap
(
fStorage
that
.
fStorage
)
;
}
bool
empty
(
)
const
{
return
fStorage
.
empty
(
)
;
}
int
size
(
)
const
{
return
fStorage
.
size
(
)
;
}
int
capacity
(
)
const
{
return
fStorage
.
capacity
(
)
;
}
size_t
size_bytes
(
)
const
{
return
fStorage
.
size_bytes
(
)
;
}
T
*
data
(
)
{
return
static_cast
<
T
*
>
(
fStorage
.
data
(
)
)
;
}
const
T
*
data
(
)
const
{
return
static_cast
<
const
T
*
>
(
fStorage
.
data
(
)
)
;
}
T
*
begin
(
)
{
return
this
-
>
data
(
)
;
}
const
T
*
begin
(
)
const
{
return
this
-
>
data
(
)
;
}
T
*
end
(
)
{
return
this
-
>
data
(
)
+
this
-
>
size
(
)
;
}
const
T
*
end
(
)
const
{
return
this
-
>
data
(
)
+
this
-
>
size
(
)
;
}
T
&
operator
[
]
(
int
index
)
{
return
this
-
>
data
(
)
[
sk_collection_check_bounds
(
index
this
-
>
size
(
)
)
]
;
}
const
T
&
operator
[
]
(
int
index
)
const
{
return
this
-
>
data
(
)
[
sk_collection_check_bounds
(
index
this
-
>
size
(
)
)
]
;
}
const
T
&
back
(
)
const
{
sk_collection_not_empty
(
this
-
>
empty
(
)
)
;
return
this
-
>
data
(
)
[
this
-
>
size
(
)
-
1
]
;
}
T
&
back
(
)
{
sk_collection_not_empty
(
this
-
>
empty
(
)
)
;
return
this
-
>
data
(
)
[
this
-
>
size
(
)
-
1
]
;
}
void
reset
(
)
{
fStorage
.
reset
(
)
;
}
void
clear
(
)
{
fStorage
.
clear
(
)
;
}
void
resize
(
int
count
)
{
fStorage
.
resize
(
count
)
;
}
void
reserve
(
int
n
)
{
fStorage
.
reserve
(
n
)
;
}
T
*
append
(
)
{
fStorage
.
append
(
)
;
return
this
-
>
end
(
)
-
1
;
}
T
*
append
(
int
count
)
{
fStorage
.
append
(
count
)
;
return
this
-
>
end
(
)
-
count
;
}
T
*
append
(
int
count
const
T
*
src
)
{
return
static_cast
<
T
*
>
(
fStorage
.
append
(
src
count
)
)
;
}
T
*
insert
(
int
index
)
{
return
static_cast
<
T
*
>
(
fStorage
.
insert
(
index
)
)
;
}
T
*
insert
(
int
index
int
count
const
T
*
src
=
nullptr
)
{
return
static_cast
<
T
*
>
(
fStorage
.
insert
(
index
count
src
)
)
;
}
void
remove
(
int
index
int
count
=
1
)
{
fStorage
.
erase
(
index
count
)
;
}
void
removeShuffle
(
int
index
)
{
fStorage
.
removeShuffle
(
index
)
;
}
void
push_back
(
const
T
&
v
)
{
this
-
>
append
(
)
;
this
-
>
back
(
)
=
v
;
}
void
pop_back
(
)
{
fStorage
.
pop_back
(
)
;
}
void
shrink_to_fit
(
)
{
fStorage
.
shrink_to_fit
(
)
;
}
private
:
SkTDStorage
fStorage
;
}
;
template
<
typename
T
>
static
inline
void
swap
(
SkTDArray
<
T
>
&
a
SkTDArray
<
T
>
&
b
)
{
a
.
swap
(
b
)
;
}
#
endif
