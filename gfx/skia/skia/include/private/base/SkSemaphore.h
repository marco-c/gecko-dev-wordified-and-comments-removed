#
ifndef
SkSemaphore_DEFINED
#
define
SkSemaphore_DEFINED
#
include
"
include
/
private
/
base
/
SkAPI
.
h
"
#
include
"
include
/
private
/
base
/
SkOnce
.
h
"
#
include
"
include
/
private
/
base
/
SkThreadAnnotations
.
h
"
#
include
<
algorithm
>
#
include
<
atomic
>
class
SkSemaphore
{
public
:
constexpr
SkSemaphore
(
int
count
=
0
)
:
fCount
(
count
)
fOSSemaphore
(
nullptr
)
{
}
SK_SPI
~
SkSemaphore
(
)
;
void
signal
(
int
n
=
1
)
;
void
wait
(
)
;
SK_SPI
bool
try_wait
(
)
;
private
:
struct
OSSemaphore
;
SK_SPI
void
osSignal
(
int
n
)
;
SK_SPI
void
osWait
(
)
;
std
:
:
atomic
<
int
>
fCount
;
SkOnce
fOSSemaphoreOnce
;
OSSemaphore
*
fOSSemaphore
;
}
;
inline
void
SkSemaphore
:
:
signal
(
int
n
)
{
int
prev
=
fCount
.
fetch_add
(
n
std
:
:
memory_order_release
)
;
int
toSignal
=
std
:
:
min
(
-
prev
n
)
;
if
(
toSignal
>
0
)
{
this
-
>
osSignal
(
toSignal
)
;
}
}
inline
void
SkSemaphore
:
:
wait
(
)
{
if
(
fCount
.
fetch_sub
(
1
std
:
:
memory_order_acquire
)
<
=
0
)
{
SK_POTENTIALLY_BLOCKING_REGION_BEGIN
;
this
-
>
osWait
(
)
;
SK_POTENTIALLY_BLOCKING_REGION_END
;
}
}
#
endif
