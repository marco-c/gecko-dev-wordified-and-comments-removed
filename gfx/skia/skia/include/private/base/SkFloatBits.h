#
ifndef
SkFloatBits_DEFINED
#
define
SkFloatBits_DEFINED
#
include
"
include
/
private
/
base
/
SkMath
.
h
"
#
include
<
cstdint
>
static
inline
int32_t
SkSignBitTo2sCompliment
(
int32_t
x
)
{
if
(
x
<
0
)
{
x
&
=
0x7FFFFFFF
;
x
=
-
x
;
}
return
x
;
}
static
inline
int32_t
Sk2sComplimentToSignBit
(
int32_t
x
)
{
int
sign
=
x
>
>
31
;
x
=
(
x
^
sign
)
-
sign
;
x
|
=
SkLeftShift
(
sign
31
)
;
return
x
;
}
union
SkFloatIntUnion
{
float
fFloat
;
int32_t
fSignBitInt
;
}
;
static
inline
int32_t
SkFloat2Bits
(
float
x
)
{
SkFloatIntUnion
data
;
data
.
fFloat
=
x
;
return
data
.
fSignBitInt
;
}
static
inline
float
SkBits2Float
(
int32_t
floatAsBits
)
{
SkFloatIntUnion
data
;
data
.
fSignBitInt
=
floatAsBits
;
return
data
.
fFloat
;
}
constexpr
int32_t
gFloatBits_exponent_mask
=
0x7F800000
;
constexpr
int32_t
gFloatBits_matissa_mask
=
0x007FFFFF
;
static
inline
bool
SkFloatBits_IsFinite
(
int32_t
bits
)
{
return
(
bits
&
gFloatBits_exponent_mask
)
!
=
gFloatBits_exponent_mask
;
}
static
inline
bool
SkFloatBits_IsInf
(
int32_t
bits
)
{
return
(
(
bits
&
gFloatBits_exponent_mask
)
=
=
gFloatBits_exponent_mask
)
&
&
(
bits
&
gFloatBits_matissa_mask
)
=
=
0
;
}
static
inline
int32_t
SkFloatAs2sCompliment
(
float
x
)
{
return
SkSignBitTo2sCompliment
(
SkFloat2Bits
(
x
)
)
;
}
static
inline
float
Sk2sComplimentAsFloat
(
int32_t
x
)
{
return
SkBits2Float
(
Sk2sComplimentToSignBit
(
x
)
)
;
}
#
define
SkScalarAs2sCompliment
(
x
)
SkFloatAs2sCompliment
(
x
)
#
endif
