#
ifndef
SkFloatingPoint_DEFINED
#
define
SkFloatingPoint_DEFINED
#
include
"
include
/
private
/
base
/
SkAttributes
.
h
"
#
include
"
include
/
private
/
base
/
SkFloatBits
.
h
"
#
include
"
include
/
private
/
base
/
SkMath
.
h
"
#
include
<
cmath
>
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
limits
>
inline
constexpr
float
SK_FloatSqrt2
=
1
.
41421356f
;
inline
constexpr
float
SK_FloatPI
=
3
.
14159265f
;
inline
constexpr
double
SK_DoublePI
=
3
.
14159265358979323846264338327950288
;
static
inline
float
sk_float_sqrt
(
float
x
)
{
return
std
:
:
sqrt
(
x
)
;
}
static
inline
float
sk_float_sin
(
float
x
)
{
return
std
:
:
sin
(
x
)
;
}
static
inline
float
sk_float_cos
(
float
x
)
{
return
std
:
:
cos
(
x
)
;
}
static
inline
float
sk_float_tan
(
float
x
)
{
return
std
:
:
tan
(
x
)
;
}
static
inline
float
sk_float_floor
(
float
x
)
{
return
std
:
:
floor
(
x
)
;
}
static
inline
float
sk_float_ceil
(
float
x
)
{
return
std
:
:
ceil
(
x
)
;
}
static
inline
float
sk_float_trunc
(
float
x
)
{
return
std
:
:
trunc
(
x
)
;
}
static
inline
float
sk_float_acos
(
float
x
)
{
return
std
:
:
acos
(
x
)
;
}
static
inline
float
sk_float_asin
(
float
x
)
{
return
std
:
:
asin
(
x
)
;
}
static
inline
float
sk_float_atan2
(
float
y
float
x
)
{
return
std
:
:
atan2
(
y
x
)
;
}
static
inline
float
sk_float_abs
(
float
x
)
{
return
std
:
:
fabs
(
x
)
;
}
static
inline
float
sk_float_copysign
(
float
x
float
y
)
{
return
std
:
:
copysign
(
x
y
)
;
}
static
inline
float
sk_float_mod
(
float
x
float
y
)
{
return
std
:
:
fmod
(
x
y
)
;
}
static
inline
float
sk_float_pow
(
float
x
float
y
)
{
return
std
:
:
pow
(
x
y
)
;
}
static
inline
float
sk_float_exp
(
float
x
)
{
return
std
:
:
exp
(
x
)
;
}
static
inline
float
sk_float_log
(
float
x
)
{
return
std
:
:
log
(
x
)
;
}
static
inline
float
sk_float_log2
(
float
x
)
{
return
std
:
:
log2
(
x
)
;
}
static
constexpr
int
sk_float_sgn
(
float
x
)
{
return
(
0
.
0f
<
x
)
-
(
x
<
0
.
0f
)
;
}
static
constexpr
float
sk_float_degrees_to_radians
(
float
degrees
)
{
return
degrees
*
(
SK_FloatPI
/
180
)
;
}
static
constexpr
float
sk_float_radians_to_degrees
(
float
radians
)
{
return
radians
*
(
180
/
SK_FloatPI
)
;
}
#
define
sk_float_round
(
x
)
(
float
)
sk_double_round
(
(
double
)
(
x
)
)
static
inline
bool
sk_float_isfinite
(
float
x
)
{
return
SkFloatBits_IsFinite
(
SkFloat2Bits
(
x
)
)
;
}
static
inline
bool
sk_floats_are_finite
(
float
a
float
b
)
{
return
sk_float_isfinite
(
a
)
&
&
sk_float_isfinite
(
b
)
;
}
static
inline
bool
sk_floats_are_finite
(
const
float
array
[
]
int
count
)
{
float
prod
=
0
;
for
(
int
i
=
0
;
i
<
count
;
+
+
i
)
{
prod
*
=
array
[
i
]
;
}
return
prod
=
=
0
;
}
static
inline
bool
sk_float_isinf
(
float
x
)
{
return
SkFloatBits_IsInf
(
SkFloat2Bits
(
x
)
)
;
}
#
ifdef
SK_BUILD_FOR_WIN
#
define
sk_float_isnan
(
x
)
_isnan
(
x
)
#
elif
defined
(
__clang__
)
|
|
defined
(
__GNUC__
)
#
define
sk_float_isnan
(
x
)
__builtin_isnan
(
x
)
#
else
#
define
sk_float_isnan
(
x
)
isnan
(
x
)
#
endif
#
define
sk_double_isnan
(
a
)
sk_float_isnan
(
a
)
inline
constexpr
int
SK_MaxS32FitsInFloat
=
2147483520
;
inline
constexpr
int
SK_MinS32FitsInFloat
=
-
SK_MaxS32FitsInFloat
;
inline
constexpr
int64_t
SK_MaxS64FitsInFloat
=
SK_MaxS64
>
>
(
63
-
24
)
<
<
(
63
-
24
)
;
inline
constexpr
int64_t
SK_MinS64FitsInFloat
=
-
SK_MaxS64FitsInFloat
;
static
constexpr
int
sk_float_saturate2int
(
float
x
)
{
x
=
x
<
SK_MaxS32FitsInFloat
?
x
:
SK_MaxS32FitsInFloat
;
x
=
x
>
SK_MinS32FitsInFloat
?
x
:
SK_MinS32FitsInFloat
;
return
(
int
)
x
;
}
static
constexpr
int
sk_double_saturate2int
(
double
x
)
{
x
=
x
<
SK_MaxS32
?
x
:
SK_MaxS32
;
x
=
x
>
SK_MinS32
?
x
:
SK_MinS32
;
return
(
int
)
x
;
}
static
constexpr
int64_t
sk_float_saturate2int64
(
float
x
)
{
x
=
x
<
SK_MaxS64FitsInFloat
?
x
:
SK_MaxS64FitsInFloat
;
x
=
x
>
SK_MinS64FitsInFloat
?
x
:
SK_MinS64FitsInFloat
;
return
(
int64_t
)
x
;
}
#
define
sk_float_floor2int
(
x
)
sk_float_saturate2int
(
sk_float_floor
(
x
)
)
#
define
sk_float_round2int
(
x
)
sk_float_saturate2int
(
sk_float_round
(
x
)
)
#
define
sk_float_ceil2int
(
x
)
sk_float_saturate2int
(
sk_float_ceil
(
x
)
)
#
define
sk_float_floor2int_no_saturate
(
x
)
(
int
)
sk_float_floor
(
x
)
#
define
sk_float_round2int_no_saturate
(
x
)
(
int
)
sk_float_round
(
x
)
#
define
sk_float_ceil2int_no_saturate
(
x
)
(
int
)
sk_float_ceil
(
x
)
#
define
sk_double_floor
(
x
)
floor
(
x
)
#
define
sk_double_round
(
x
)
floor
(
(
x
)
+
0
.
5
)
#
define
sk_double_ceil
(
x
)
ceil
(
x
)
#
define
sk_double_floor2int
(
x
)
(
int
)
sk_double_floor
(
x
)
#
define
sk_double_round2int
(
x
)
(
int
)
sk_double_round
(
x
)
#
define
sk_double_ceil2int
(
x
)
(
int
)
sk_double_ceil
(
x
)
#
ifdef
__clang__
SK_NO_SANITIZE
(
"
float
-
cast
-
overflow
"
)
#
elif
defined
(
__GNUC__
)
SK_ATTRIBUTE
(
no_sanitize_undefined
)
#
endif
static
constexpr
float
sk_double_to_float
(
double
x
)
{
return
static_cast
<
float
>
(
x
)
;
}
inline
constexpr
float
SK_FloatNaN
=
std
:
:
numeric_limits
<
float
>
:
:
quiet_NaN
(
)
;
inline
constexpr
float
SK_FloatInfinity
=
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
;
inline
constexpr
float
SK_FloatNegativeInfinity
=
-
SK_FloatInfinity
;
inline
constexpr
double
SK_DoubleNaN
=
std
:
:
numeric_limits
<
double
>
:
:
quiet_NaN
(
)
;
static
constexpr
float
sk_float_midpoint
(
float
a
float
b
)
{
return
static_cast
<
float
>
(
0
.
5
*
(
static_cast
<
double
>
(
a
)
+
b
)
)
;
}
bool
sk_floats_are_unit
(
const
float
array
[
]
size_t
count
)
;
static
inline
float
sk_float_rsqrt_portable
(
float
x
)
{
return
1
.
0f
/
sk_float_sqrt
(
x
)
;
}
static
inline
float
sk_float_rsqrt
(
float
x
)
{
return
1
.
0f
/
sk_float_sqrt
(
x
)
;
}
inline
constexpr
int
SK_FLT_DECIMAL_DIG
=
std
:
:
numeric_limits
<
float
>
:
:
max_digits10
;
#
ifdef
SK_BUILD_FOR_WIN
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4723
)
#
endif
#
ifdef
__clang__
SK_NO_SANITIZE
(
"
float
-
divide
-
by
-
zero
"
)
#
elif
defined
(
__GNUC__
)
SK_ATTRIBUTE
(
no_sanitize_undefined
)
#
endif
static
constexpr
float
sk_ieee_float_divide
(
float
numer
float
denom
)
{
return
numer
/
denom
;
}
#
ifdef
__clang__
SK_NO_SANITIZE
(
"
float
-
divide
-
by
-
zero
"
)
#
elif
defined
(
__GNUC__
)
SK_ATTRIBUTE
(
no_sanitize_undefined
)
#
endif
static
constexpr
double
sk_ieee_double_divide
(
double
numer
double
denom
)
{
return
numer
/
denom
;
}
#
ifdef
SK_BUILD_FOR_WIN
#
pragma
warning
(
pop
)
#
endif
static
inline
float
sk_fmaf
(
float
a
float
b
float
c
)
{
return
std
:
:
fma
(
a
b
c
)
;
}
bool
sk_double_nearly_zero
(
double
a
)
;
bool
sk_doubles_nearly_equal_ulps
(
double
a
double
b
uint8_t
maxUlpsDiff
=
16
)
;
#
endif
