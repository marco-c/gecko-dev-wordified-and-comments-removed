#
ifndef
SkMacros_DEFINED
#
define
SkMacros_DEFINED
#
define
SK_MACRO_CONCAT
(
X
Y
)
SK_MACRO_CONCAT_IMPL_PRIV
(
X
Y
)
#
define
SK_MACRO_CONCAT_IMPL_PRIV
(
X
Y
)
X
#
#
Y
#
define
SK_MACRO_APPEND_LINE
(
name
)
SK_MACRO_CONCAT
(
name
__LINE__
)
#
define
SK_MACRO_APPEND_COUNTER
(
name
)
SK_MACRO_CONCAT
(
name
__COUNTER__
)
#
if
defined
(
__clang__
)
#
define
SK_BEGIN_REQUIRE_DENSE
_Pragma
(
"
GCC
diagnostic
push
"
)
\
_Pragma
(
"
GCC
diagnostic
error
\
"
-
Wpadded
\
"
"
)
#
define
SK_END_REQUIRE_DENSE
_Pragma
(
"
GCC
diagnostic
pop
"
)
#
else
#
define
SK_BEGIN_REQUIRE_DENSE
#
define
SK_END_REQUIRE_DENSE
#
endif
#
ifdef
MOZ_SKIA
#
ifdef
MOZ_ASAN
#
include
"
mozilla
/
MemoryChecking
.
h
"
#
define
SK_INTENTIONALLY_LEAKED
(
X
)
MOZ_LSAN_INTENTIONALLY_LEAK_OBJECT
(
X
)
#
else
#
define
SK_INTENTIONALLY_LEAKED
(
x
)
(
(
void
)
0
)
#
endif
#
else
#
if
defined
(
__clang__
)
&
&
defined
(
__has_feature
)
#
if
__has_feature
(
leak_sanitizer
)
|
|
__has_feature
(
address_sanitizer
)
extern
"
C
"
{
void
__lsan_ignore_object
(
const
void
*
p
)
;
}
#
define
SK_INTENTIONALLY_LEAKED
(
X
)
__lsan_ignore_object
(
X
)
#
else
#
define
SK_INTENTIONALLY_LEAKED
(
X
)
(
(
void
)
0
)
#
endif
#
else
#
define
SK_INTENTIONALLY_LEAKED
(
X
)
(
(
void
)
0
)
#
endif
#
endif
#
define
SK_INIT_TO_AVOID_WARNING
=
0
#
define
SK_MAKE_BITFIELD_OPS
(
X
)
\
inline
X
operator
~
(
X
a
)
{
\
using
U
=
std
:
:
underlying_type_t
<
X
>
;
\
return
(
X
)
(
~
static_cast
<
U
>
(
a
)
)
;
\
}
\
inline
X
operator
|
(
X
a
X
b
)
{
\
using
U
=
std
:
:
underlying_type_t
<
X
>
;
\
return
(
X
)
(
static_cast
<
U
>
(
a
)
|
static_cast
<
U
>
(
b
)
)
;
\
}
\
inline
X
&
operator
|
=
(
X
&
a
X
b
)
{
\
return
(
a
=
a
|
b
)
;
\
}
\
inline
X
operator
&
(
X
a
X
b
)
{
\
using
U
=
std
:
:
underlying_type_t
<
X
>
;
\
return
(
X
)
(
static_cast
<
U
>
(
a
)
&
static_cast
<
U
>
(
b
)
)
;
\
}
\
inline
X
&
operator
&
=
(
X
&
a
X
b
)
{
\
return
(
a
=
a
&
b
)
;
\
}
#
define
SK_DECL_BITFIELD_OPS_FRIENDS
(
X
)
\
friend
X
operator
~
(
X
a
)
;
\
friend
X
operator
|
(
X
a
X
b
)
;
\
friend
X
&
operator
|
=
(
X
&
a
X
b
)
;
\
\
friend
X
operator
&
(
X
a
X
b
)
;
\
friend
X
&
operator
&
=
(
X
&
a
X
b
)
;
#
endif
