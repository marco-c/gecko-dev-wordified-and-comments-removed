#
ifndef
SkTLogic_DEFINED
#
define
SkTLogic_DEFINED
#
include
"
SkTypes
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
utility
>
#
if
SKIA_IMPLEMENTATION
#
include
<
algorithm
>
#
endif
#
ifdef
MOZ_SKIA
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
if
SKIA_IMPLEMENTATION
#
include
"
mozilla
/
Function
.
h
"
#
endif
namespace
std
{
using
mozilla
:
:
Forward
;
#
define
forward
Forward
#
if
SKIA_IMPLEMENTATION
using
mozilla
:
:
IntegralConstant
;
using
mozilla
:
:
IsEmpty
;
using
mozilla
:
:
FalseType
;
using
mozilla
:
:
TrueType
;
#
define
integral_constant
IntegralConstant
#
define
is_empty
IsEmpty
#
define
false_type
FalseType
#
define
true_type
TrueType
using
mozilla
:
:
Function
;
#
define
function
Function
#
endif
}
namespace
skstd
{
template
<
bool
B
>
using
bool_constant
=
mozilla
:
:
IntegralConstant
<
bool
B
>
;
template
<
bool
B
typename
T
typename
F
>
using
conditional_t
=
typename
mozilla
:
:
Conditional
<
B
T
F
>
:
:
Type
;
template
<
bool
B
typename
T
=
void
>
using
enable_if_t
=
typename
mozilla
:
:
EnableIf
<
B
T
>
:
:
Type
;
}
#
else
#
include
<
type_traits
>
#
include
<
functional
>
namespace
skstd
{
template
<
bool
B
>
using
bool_constant
=
std
:
:
integral_constant
<
bool
B
>
;
template
<
bool
B
typename
T
typename
F
>
using
conditional_t
=
typename
std
:
:
conditional
<
B
T
F
>
:
:
type
;
template
<
bool
B
typename
T
=
void
>
using
enable_if_t
=
typename
std
:
:
enable_if
<
B
T
>
:
:
type
;
template
<
typename
T
>
using
remove_const_t
=
typename
std
:
:
remove_const
<
T
>
:
:
type
;
template
<
typename
T
>
using
remove_volatile_t
=
typename
std
:
:
remove_volatile
<
T
>
:
:
type
;
template
<
typename
T
>
using
remove_cv_t
=
typename
std
:
:
remove_cv
<
T
>
:
:
type
;
template
<
typename
T
>
using
remove_pointer_t
=
typename
std
:
:
remove_pointer
<
T
>
:
:
type
;
template
<
typename
T
>
using
remove_reference_t
=
typename
std
:
:
remove_reference
<
T
>
:
:
type
;
template
<
typename
T
>
using
remove_extent_t
=
typename
std
:
:
remove_extent
<
T
>
:
:
type
;
template
<
typename
>
struct
is_function
:
std
:
:
false_type
{
}
;
#
if
!
defined
(
SK_BUILD_FOR_WIN
)
template
<
typename
R
typename
.
.
.
Args
>
struct
is_function
<
R
(
Args
.
.
.
)
>
:
std
:
:
true_type
{
}
;
#
else
template
<
typename
R
typename
.
.
.
Args
>
struct
is_function
<
R
__cdecl
(
Args
.
.
.
)
>
:
std
:
:
true_type
{
}
;
#
if
defined
(
_M_IX86
)
template
<
typename
R
typename
.
.
.
Args
>
struct
is_function
<
R
__stdcall
(
Args
.
.
.
)
>
:
std
:
:
true_type
{
}
;
template
<
typename
R
typename
.
.
.
Args
>
struct
is_function
<
R
__fastcall
(
Args
.
.
.
)
>
:
std
:
:
true_type
{
}
;
#
endif
#
if
defined
(
_MSC_VER
)
&
&
SK_CPU_SSE_LEVEL
>
=
SK_CPU_SSE_LEVEL_SSE2
template
<
typename
R
typename
.
.
.
Args
>
struct
is_function
<
R
__vectorcall
(
Args
.
.
.
)
>
:
std
:
:
true_type
{
}
;
#
endif
#
endif
template
<
typename
R
typename
.
.
.
Args
>
struct
is_function
<
R
(
Args
.
.
.
.
.
.
)
>
:
std
:
:
true_type
{
}
;
template
<
typename
T
>
using
add_const_t
=
typename
std
:
:
add_const
<
T
>
:
:
type
;
template
<
typename
T
>
using
add_volatile_t
=
typename
std
:
:
add_volatile
<
T
>
:
:
type
;
template
<
typename
T
>
using
add_cv_t
=
typename
std
:
:
add_cv
<
T
>
:
:
type
;
template
<
typename
T
>
using
add_pointer_t
=
typename
std
:
:
add_pointer
<
T
>
:
:
type
;
template
<
typename
T
>
using
add_lvalue_reference_t
=
typename
std
:
:
add_lvalue_reference
<
T
>
:
:
type
;
template
<
typename
S
typename
D
bool
=
std
:
:
is_void
<
S
>
:
:
value
|
|
is_function
<
D
>
:
:
value
|
|
std
:
:
is_array
<
D
>
:
:
value
>
struct
is_convertible_detector
{
static
const
bool
value
=
std
:
:
is_void
<
D
>
:
:
value
;
}
;
template
<
typename
S
typename
D
>
struct
is_convertible_detector
<
S
D
false
>
{
using
yes_type
=
uint8_t
;
using
no_type
=
uint16_t
;
template
<
typename
To
>
static
void
param_convertable_to
(
To
)
;
template
<
typename
From
typename
To
>
static
decltype
(
param_convertable_to
<
To
>
(
std
:
:
declval
<
From
>
(
)
)
yes_type
(
)
)
convertible
(
int
)
;
template
<
typename
typename
>
static
no_type
convertible
(
.
.
.
)
;
static
const
bool
value
=
sizeof
(
convertible
<
S
D
>
(
0
)
)
=
=
sizeof
(
yes_type
)
;
}
;
template
<
typename
S
typename
D
>
struct
is_convertible
:
bool_constant
<
is_convertible_detector
<
S
D
>
:
:
value
>
{
}
;
}
namespace
sknonstd
{
template
<
typename
D
typename
S
>
struct
copy_const
{
using
type
=
skstd
:
:
conditional_t
<
std
:
:
is_const
<
S
>
:
:
value
skstd
:
:
add_const_t
<
D
>
D
>
;
}
;
template
<
typename
D
typename
S
>
using
copy_const_t
=
typename
copy_const
<
D
S
>
:
:
type
;
template
<
typename
D
typename
S
>
struct
copy_volatile
{
using
type
=
skstd
:
:
conditional_t
<
std
:
:
is_volatile
<
S
>
:
:
value
skstd
:
:
add_volatile_t
<
D
>
D
>
;
}
;
template
<
typename
D
typename
S
>
using
copy_volatile_t
=
typename
copy_volatile
<
D
S
>
:
:
type
;
template
<
typename
D
typename
S
>
struct
copy_cv
{
using
type
=
copy_volatile_t
<
copy_const_t
<
D
S
>
S
>
;
}
;
template
<
typename
D
typename
S
>
using
copy_cv_t
=
typename
copy_cv
<
D
S
>
:
:
type
;
template
<
typename
D
typename
S
>
using
same_const
=
copy_const
<
skstd
:
:
remove_const_t
<
D
>
S
>
;
template
<
typename
D
typename
S
>
using
same_const_t
=
typename
same_const
<
D
S
>
:
:
type
;
template
<
typename
D
typename
S
>
using
same_volatile
=
copy_volatile
<
skstd
:
:
remove_volatile_t
<
D
>
S
>
;
template
<
typename
D
typename
S
>
using
same_volatile_t
=
typename
same_volatile
<
D
S
>
:
:
type
;
template
<
typename
D
typename
S
>
using
same_cv
=
copy_cv
<
skstd
:
:
remove_cv_t
<
D
>
S
>
;
template
<
typename
D
typename
S
>
using
same_cv_t
=
typename
same_cv
<
D
S
>
:
:
type
;
}
#
endif
#
define
SK_WHEN
(
condition
T
)
skstd
:
:
enable_if_t
<
!
!
(
condition
)
T
>
#
endif
