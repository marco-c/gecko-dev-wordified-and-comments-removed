#
ifndef
SkColorPriv_DEFINED
#
define
SkColorPriv_DEFINED
#
include
"
SkColor
.
h
"
#
include
"
SkMath
.
h
"
static
inline
unsigned
SkAlpha255To256
(
U8CPU
alpha
)
{
SkASSERT
(
SkToU8
(
alpha
)
=
=
alpha
)
;
return
alpha
+
1
;
}
#
define
SkAlphaMul
(
value
alpha256
)
(
(
(
value
)
*
(
alpha256
)
)
>
>
8
)
static
inline
U8CPU
SkUnitScalarClampToByte
(
SkScalar
x
)
{
return
static_cast
<
U8CPU
>
(
SkScalarPin
(
x
0
1
)
*
255
+
0
.
5
)
;
}
#
define
SK_A32_BITS
8
#
define
SK_R32_BITS
8
#
define
SK_G32_BITS
8
#
define
SK_B32_BITS
8
#
define
SK_A32_MASK
(
(
1
<
<
SK_A32_BITS
)
-
1
)
#
define
SK_R32_MASK
(
(
1
<
<
SK_R32_BITS
)
-
1
)
#
define
SK_G32_MASK
(
(
1
<
<
SK_G32_BITS
)
-
1
)
#
define
SK_B32_MASK
(
(
1
<
<
SK_B32_BITS
)
-
1
)
#
define
SK_RGBA_R32_SHIFT
0
#
define
SK_RGBA_G32_SHIFT
8
#
define
SK_RGBA_B32_SHIFT
16
#
define
SK_RGBA_A32_SHIFT
24
#
define
SkGetPackedA32
(
packed
)
(
(
uint32_t
)
(
(
packed
)
<
<
(
24
-
SK_A32_SHIFT
)
)
>
>
24
)
#
define
SkGetPackedR32
(
packed
)
(
(
uint32_t
)
(
(
packed
)
<
<
(
24
-
SK_R32_SHIFT
)
)
>
>
24
)
#
define
SkGetPackedG32
(
packed
)
(
(
uint32_t
)
(
(
packed
)
<
<
(
24
-
SK_G32_SHIFT
)
)
>
>
24
)
#
define
SkGetPackedB32
(
packed
)
(
(
uint32_t
)
(
(
packed
)
<
<
(
24
-
SK_B32_SHIFT
)
)
>
>
24
)
#
define
SkA32Assert
(
a
)
SkASSERT
(
(
unsigned
)
(
a
)
<
=
SK_A32_MASK
)
#
define
SkR32Assert
(
r
)
SkASSERT
(
(
unsigned
)
(
r
)
<
=
SK_R32_MASK
)
#
define
SkG32Assert
(
g
)
SkASSERT
(
(
unsigned
)
(
g
)
<
=
SK_G32_MASK
)
#
define
SkB32Assert
(
b
)
SkASSERT
(
(
unsigned
)
(
b
)
<
=
SK_B32_MASK
)
static
inline
SkPMColor
SkPackARGB32
(
U8CPU
a
U8CPU
r
U8CPU
g
U8CPU
b
)
{
SkA32Assert
(
a
)
;
SkASSERT
(
r
<
=
a
)
;
SkASSERT
(
g
<
=
a
)
;
SkASSERT
(
b
<
=
a
)
;
return
(
a
<
<
SK_A32_SHIFT
)
|
(
r
<
<
SK_R32_SHIFT
)
|
(
g
<
<
SK_G32_SHIFT
)
|
(
b
<
<
SK_B32_SHIFT
)
;
}
static
inline
SkPMColor
SkPackARGB32NoCheck
(
U8CPU
a
U8CPU
r
U8CPU
g
U8CPU
b
)
{
return
(
a
<
<
SK_A32_SHIFT
)
|
(
r
<
<
SK_R32_SHIFT
)
|
(
g
<
<
SK_G32_SHIFT
)
|
(
b
<
<
SK_B32_SHIFT
)
;
}
static
inline
SkPMColor
SkPremultiplyARGBInline
(
U8CPU
a
U8CPU
r
U8CPU
g
U8CPU
b
)
{
SkA32Assert
(
a
)
;
SkR32Assert
(
r
)
;
SkG32Assert
(
g
)
;
SkB32Assert
(
b
)
;
if
(
a
!
=
255
)
{
r
=
SkMulDiv255Round
(
r
a
)
;
g
=
SkMulDiv255Round
(
g
a
)
;
b
=
SkMulDiv255Round
(
b
a
)
;
}
return
SkPackARGB32
(
a
r
g
b
)
;
}
static
SK_ALWAYS_INLINE
uint32_t
SkAlphaMulQ
(
uint32_t
c
unsigned
scale
)
{
uint32_t
mask
=
0xFF00FF
;
uint32_t
rb
=
(
(
c
&
mask
)
*
scale
)
>
>
8
;
uint32_t
ag
=
(
(
c
>
>
8
)
&
mask
)
*
scale
;
return
(
rb
&
mask
)
|
(
ag
&
~
mask
)
;
}
static
inline
SkPMColor
SkPMSrcOver
(
SkPMColor
src
SkPMColor
dst
)
{
return
src
+
SkAlphaMulQ
(
dst
SkAlpha255To256
(
255
-
SkGetPackedA32
(
src
)
)
)
;
}
#
define
SK_R16_BITS
5
#
define
SK_G16_BITS
6
#
define
SK_B16_BITS
5
#
define
SK_R16_SHIFT
(
SK_B16_BITS
+
SK_G16_BITS
)
#
define
SK_G16_SHIFT
(
SK_B16_BITS
)
#
define
SK_B16_SHIFT
0
#
define
SK_R16_MASK
(
(
1
<
<
SK_R16_BITS
)
-
1
)
#
define
SK_G16_MASK
(
(
1
<
<
SK_G16_BITS
)
-
1
)
#
define
SK_B16_MASK
(
(
1
<
<
SK_B16_BITS
)
-
1
)
#
define
SkGetPackedR16
(
color
)
(
(
(
unsigned
)
(
color
)
>
>
SK_R16_SHIFT
)
&
SK_R16_MASK
)
#
define
SkGetPackedG16
(
color
)
(
(
(
unsigned
)
(
color
)
>
>
SK_G16_SHIFT
)
&
SK_G16_MASK
)
#
define
SkGetPackedB16
(
color
)
(
(
(
unsigned
)
(
color
)
>
>
SK_B16_SHIFT
)
&
SK_B16_MASK
)
static
inline
unsigned
SkR16ToR32
(
unsigned
r
)
{
return
(
r
<
<
(
8
-
SK_R16_BITS
)
)
|
(
r
>
>
(
2
*
SK_R16_BITS
-
8
)
)
;
}
static
inline
unsigned
SkG16ToG32
(
unsigned
g
)
{
return
(
g
<
<
(
8
-
SK_G16_BITS
)
)
|
(
g
>
>
(
2
*
SK_G16_BITS
-
8
)
)
;
}
static
inline
unsigned
SkB16ToB32
(
unsigned
b
)
{
return
(
b
<
<
(
8
-
SK_B16_BITS
)
)
|
(
b
>
>
(
2
*
SK_B16_BITS
-
8
)
)
;
}
#
define
SkPacked16ToR32
(
c
)
SkR16ToR32
(
SkGetPackedR16
(
c
)
)
#
define
SkPacked16ToG32
(
c
)
SkG16ToG32
(
SkGetPackedG16
(
c
)
)
#
define
SkPacked16ToB32
(
c
)
SkB16ToB32
(
SkGetPackedB16
(
c
)
)
#
endif
