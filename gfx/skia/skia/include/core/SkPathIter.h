#
ifndef
SkPathIter_DEFINED
#
define
SkPathIter_DEFINED
#
include
"
include
/
core
/
SkPathTypes
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkSpan
.
h
"
#
include
<
array
>
#
include
<
cstddef
>
#
include
<
optional
>
class
SK_API
SkPathIter
{
public
:
struct
Rec
{
SkSpan
<
const
SkPoint
>
fPoints
;
float
fConicWeight
;
SkPathVerb
fVerb
;
float
conicWeight
(
)
const
{
SkASSERT
(
fVerb
=
=
SkPathVerb
:
:
kConic
)
;
return
fConicWeight
;
}
}
;
SkPathIter
(
SkSpan
<
const
SkPoint
>
pts
SkSpan
<
const
SkPathVerb
>
vbs
SkSpan
<
const
float
>
cns
)
:
pIndex
(
0
)
vIndex
(
0
)
cIndex
(
0
)
fPoints
(
pts
)
fVerbs
(
vbs
)
fConics
(
cns
)
{
if
(
!
vbs
.
empty
(
)
&
&
vbs
.
back
(
)
=
=
SkPathVerb
:
:
kMove
)
{
fVerbs
=
vbs
.
first
(
vbs
.
size
(
)
-
1
)
;
}
}
std
:
:
optional
<
Rec
>
next
(
)
;
std
:
:
optional
<
SkPathVerb
>
peekNextVerb
(
)
const
{
if
(
vIndex
<
fVerbs
.
size
(
)
)
{
return
fVerbs
[
vIndex
]
;
}
return
{
}
;
}
private
:
size_t
pIndex
vIndex
cIndex
;
SkSpan
<
const
SkPoint
>
fPoints
;
SkSpan
<
const
SkPathVerb
>
fVerbs
;
SkSpan
<
const
float
>
fConics
;
std
:
:
array
<
SkPoint
2
>
fClosePointStorage
;
}
;
class
SkPathContourIter
{
public
:
struct
Rec
{
SkSpan
<
const
SkPoint
>
fPoints
;
SkSpan
<
const
SkPathVerb
>
fVerbs
;
SkSpan
<
const
float
>
fConics
;
}
;
SkPathContourIter
(
SkSpan
<
const
SkPoint
>
pts
SkSpan
<
const
SkPathVerb
>
vbs
SkSpan
<
const
float
>
cns
)
:
fPoints
(
pts
)
fVerbs
(
vbs
)
fConics
(
cns
)
{
}
std
:
:
optional
<
Rec
>
next
(
)
;
private
:
SkSpan
<
const
SkPoint
>
fPoints
;
SkSpan
<
const
SkPathVerb
>
fVerbs
;
SkSpan
<
const
float
>
fConics
;
}
;
#
endif
