#
ifndef
SkImageDecoder_DEFINED
#
define
SkImageDecoder_DEFINED
#
include
"
SkBitmap
.
h
"
#
include
"
SkImage
.
h
"
#
include
"
SkPngChunkReader
.
h
"
#
include
"
SkRect
.
h
"
#
include
"
SkRefCnt
.
h
"
#
include
"
SkTRegistry
.
h
"
#
include
"
SkTypes
.
h
"
class
SkStream
;
class
SkStreamRewindable
;
class
SkImageDecoder
:
SkNoncopyable
{
public
:
virtual
~
SkImageDecoder
(
)
;
enum
Format
{
kUnknown_Format
kBMP_Format
kGIF_Format
kICO_Format
kJPEG_Format
kPNG_Format
kWBMP_Format
kWEBP_Format
kPKM_Format
kKTX_Format
kASTC_Format
kLastKnownFormat
=
kKTX_Format
}
;
virtual
Format
getFormat
(
)
const
;
bool
decodeYUV8Planes
(
SkStream
*
stream
SkISize
componentSizes
[
3
]
void
*
planes
[
3
]
size_t
rowBytes
[
3
]
SkYUVColorSpace
*
)
;
static
Format
GetStreamFormat
(
SkStreamRewindable
*
)
;
static
const
char
*
GetFormatName
(
Format
)
;
const
char
*
getFormatName
(
)
const
;
bool
getSkipWritingZeroes
(
)
const
{
return
fSkipWritingZeroes
;
}
void
setSkipWritingZeroes
(
bool
skip
)
{
fSkipWritingZeroes
=
skip
;
}
bool
getDitherImage
(
)
const
{
return
fDitherImage
;
}
void
setDitherImage
(
bool
dither
)
{
fDitherImage
=
dither
;
}
bool
getPreferQualityOverSpeed
(
)
const
{
return
fPreferQualityOverSpeed
;
}
void
setPreferQualityOverSpeed
(
bool
qualityOverSpeed
)
{
fPreferQualityOverSpeed
=
qualityOverSpeed
;
}
void
setRequireUnpremultipliedColors
(
bool
request
)
{
fRequireUnpremultipliedColors
=
request
;
}
bool
getRequireUnpremultipliedColors
(
)
const
{
return
fRequireUnpremultipliedColors
;
}
SkPngChunkReader
*
getPeeker
(
)
const
{
return
fPeeker
;
}
SkPngChunkReader
*
setPeeker
(
SkPngChunkReader
*
)
;
void
setPreserveSrcDepth
(
bool
preserve
)
{
fPreserveSrcDepth
=
preserve
;
}
SkBitmap
:
:
Allocator
*
getAllocator
(
)
const
{
return
fAllocator
;
}
SkBitmap
:
:
Allocator
*
setAllocator
(
SkBitmap
:
:
Allocator
*
)
;
int
getSampleSize
(
)
const
{
return
fSampleSize
;
}
void
setSampleSize
(
int
size
)
;
void
resetSampleSize
(
)
{
this
-
>
setSampleSize
(
1
)
;
}
void
cancelDecode
(
)
{
fShouldCancelDecode
=
true
;
}
enum
Mode
{
kDecodeBounds_Mode
kDecodePixels_Mode
}
;
enum
Result
{
kFailure
=
0
kPartialSuccess
=
1
kSuccess
=
2
}
;
Result
decode
(
SkStream
*
SkBitmap
*
bitmap
SkColorType
pref
Mode
)
;
Result
decode
(
SkStream
*
stream
SkBitmap
*
bitmap
Mode
mode
)
{
return
this
-
>
decode
(
stream
bitmap
kUnknown_SkColorType
mode
)
;
}
static
SkImageDecoder
*
Factory
(
SkStreamRewindable
*
)
;
static
bool
DecodeFile
(
const
char
file
[
]
SkBitmap
*
bitmap
SkColorType
pref
Mode
Format
*
format
=
NULL
)
;
static
bool
DecodeFile
(
const
char
file
[
]
SkBitmap
*
bitmap
)
{
return
DecodeFile
(
file
bitmap
kUnknown_SkColorType
kDecodePixels_Mode
NULL
)
;
}
static
bool
DecodeMemory
(
const
void
*
buffer
size_t
size
SkBitmap
*
bitmap
SkColorType
pref
Mode
Format
*
format
=
NULL
)
;
static
bool
DecodeMemory
(
const
void
*
buffer
size_t
size
SkBitmap
*
bitmap
)
{
return
DecodeMemory
(
buffer
size
bitmap
kUnknown_SkColorType
kDecodePixels_Mode
NULL
)
;
}
static
bool
DecodeStream
(
SkStreamRewindable
*
stream
SkBitmap
*
bitmap
SkColorType
pref
Mode
Format
*
format
=
NULL
)
;
static
bool
DecodeStream
(
SkStreamRewindable
*
stream
SkBitmap
*
bitmap
)
{
return
DecodeStream
(
stream
bitmap
kUnknown_SkColorType
kDecodePixels_Mode
NULL
)
;
}
protected
:
virtual
Result
onDecode
(
SkStream
*
SkBitmap
*
bitmap
Mode
)
=
0
;
virtual
bool
onDecodeYUV8Planes
(
SkStream
*
SkISize
[
3
]
void
*
[
3
]
size_t
[
3
]
SkYUVColorSpace
*
)
{
return
false
;
}
void
copyFieldsToOther
(
SkImageDecoder
*
other
)
;
public
:
bool
shouldCancelDecode
(
)
const
{
return
fShouldCancelDecode
;
}
protected
:
SkImageDecoder
(
)
;
SkColorType
getDefaultPref
(
)
{
return
fDefaultPref
;
}
bool
allocPixelRef
(
SkBitmap
*
SkColorTable
*
)
const
;
enum
SrcDepth
{
kIndex_SrcDepth
k8BitGray_SrcDepth
k32Bit_SrcDepth
}
;
SkColorType
getPrefColorType
(
SrcDepth
bool
hasAlpha
)
const
;
private
:
SkPngChunkReader
*
fPeeker
;
SkBitmap
:
:
Allocator
*
fAllocator
;
int
fSampleSize
;
SkColorType
fDefaultPref
;
bool
fPreserveSrcDepth
;
bool
fDitherImage
;
bool
fSkipWritingZeroes
;
mutable
bool
fShouldCancelDecode
;
bool
fPreferQualityOverSpeed
;
bool
fRequireUnpremultipliedColors
;
}
;
class
SkImageDecoderFactory
:
public
SkRefCnt
{
public
:
virtual
SkImageDecoder
*
newDecoder
(
SkStreamRewindable
*
)
=
0
;
private
:
typedef
SkRefCnt
INHERITED
;
}
;
class
SkDefaultImageDecoderFactory
:
SkImageDecoderFactory
{
public
:
virtual
SkImageDecoder
*
newDecoder
(
SkStreamRewindable
*
stream
)
{
return
SkImageDecoder
:
:
Factory
(
stream
)
;
}
}
;
#
define
DECLARE_DECODER_CREATOR
(
codec
)
\
SkImageDecoder
*
Create
#
#
codec
(
)
;
#
define
DEFINE_DECODER_CREATOR
(
codec
)
\
SkImageDecoder
*
Create
#
#
codec
(
)
{
return
new
Sk
#
#
codec
;
}
DECLARE_DECODER_CREATOR
(
BMPImageDecoder
)
;
DECLARE_DECODER_CREATOR
(
GIFImageDecoder
)
;
DECLARE_DECODER_CREATOR
(
ICOImageDecoder
)
;
DECLARE_DECODER_CREATOR
(
JPEGImageDecoder
)
;
DECLARE_DECODER_CREATOR
(
PNGImageDecoder
)
;
DECLARE_DECODER_CREATOR
(
WBMPImageDecoder
)
;
DECLARE_DECODER_CREATOR
(
WEBPImageDecoder
)
;
DECLARE_DECODER_CREATOR
(
PKMImageDecoder
)
;
DECLARE_DECODER_CREATOR
(
KTXImageDecoder
)
;
DECLARE_DECODER_CREATOR
(
ASTCImageDecoder
)
;
typedef
SkTRegistry
<
SkImageDecoder
*
(
*
)
(
SkStreamRewindable
*
)
>
SkImageDecoder_DecodeReg
;
typedef
SkTRegistry
<
SkImageDecoder
:
:
Format
(
*
)
(
SkStreamRewindable
*
)
>
SkImageDecoder_FormatReg
;
#
endif
