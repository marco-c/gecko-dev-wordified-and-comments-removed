#
ifndef
SkImage_DEFINED
#
define
SkImage_DEFINED
#
include
"
SkFilterQuality
.
h
"
#
include
"
SkImageInfo
.
h
"
#
include
"
SkImageEncoder
.
h
"
#
include
"
SkRefCnt
.
h
"
#
include
"
SkScalar
.
h
"
#
include
"
SkShader
.
h
"
class
SkData
;
class
SkCanvas
;
class
SkColorTable
;
class
SkImageGenerator
;
class
SkPaint
;
class
SkPicture
;
class
SkPixelSerializer
;
class
SkString
;
class
SkSurface
;
class
GrContext
;
class
GrContextThreadSafeProxy
;
class
GrTexture
;
class
SK_API
SkImage
:
public
SkRefCnt
{
public
:
typedef
SkImageInfo
Info
;
typedef
void
*
ReleaseContext
;
static
sk_sp
<
SkImage
>
MakeRasterCopy
(
const
SkPixmap
&
)
;
static
sk_sp
<
SkImage
>
MakeRasterData
(
const
Info
&
sk_sp
<
SkData
>
pixels
size_t
rowBytes
)
;
typedef
void
(
*
RasterReleaseProc
)
(
const
void
*
pixels
ReleaseContext
)
;
static
sk_sp
<
SkImage
>
MakeFromRaster
(
const
SkPixmap
&
RasterReleaseProc
ReleaseContext
)
;
static
sk_sp
<
SkImage
>
MakeFromBitmap
(
const
SkBitmap
&
)
;
static
sk_sp
<
SkImage
>
MakeFromGenerator
(
SkImageGenerator
*
const
SkIRect
*
subset
=
nullptr
)
;
static
sk_sp
<
SkImage
>
MakeFromEncoded
(
sk_sp
<
SkData
>
encoded
const
SkIRect
*
subset
=
nullptr
)
;
static
sk_sp
<
SkImage
>
MakeFromTexture
(
GrContext
*
ctx
const
GrBackendTextureDesc
&
desc
)
{
return
MakeFromTexture
(
ctx
desc
kPremul_SkAlphaType
nullptr
nullptr
nullptr
)
;
}
static
sk_sp
<
SkImage
>
MakeFromTexture
(
GrContext
*
ctx
const
GrBackendTextureDesc
&
de
SkAlphaType
at
)
{
return
MakeFromTexture
(
ctx
de
at
nullptr
nullptr
nullptr
)
;
}
typedef
void
(
*
TextureReleaseProc
)
(
ReleaseContext
)
;
static
sk_sp
<
SkImage
>
MakeFromTexture
(
GrContext
*
ctx
const
GrBackendTextureDesc
&
desc
SkAlphaType
at
TextureReleaseProc
trp
ReleaseContext
rc
)
{
return
MakeFromTexture
(
ctx
desc
at
nullptr
trp
rc
)
;
}
static
sk_sp
<
SkImage
>
MakeFromTexture
(
GrContext
*
const
GrBackendTextureDesc
&
SkAlphaType
sk_sp
<
SkColorSpace
>
TextureReleaseProc
ReleaseContext
)
;
static
sk_sp
<
SkImage
>
MakeFromAdoptedTexture
(
GrContext
*
const
GrBackendTextureDesc
&
SkAlphaType
=
kPremul_SkAlphaType
sk_sp
<
SkColorSpace
>
=
nullptr
)
;
static
sk_sp
<
SkImage
>
MakeFromYUVTexturesCopy
(
GrContext
*
SkYUVColorSpace
const
GrBackendObject
yuvTextureHandles
[
3
]
const
SkISize
yuvSizes
[
3
]
GrSurfaceOrigin
sk_sp
<
SkColorSpace
>
=
nullptr
)
;
static
sk_sp
<
SkImage
>
MakeFromNV12TexturesCopy
(
GrContext
*
SkYUVColorSpace
const
GrBackendObject
nv12TextureHandles
[
2
]
const
SkISize
nv12Sizes
[
2
]
GrSurfaceOrigin
sk_sp
<
SkColorSpace
>
=
nullptr
)
;
static
sk_sp
<
SkImage
>
MakeFromPicture
(
sk_sp
<
SkPicture
>
const
SkISize
&
dimensions
const
SkMatrix
*
const
SkPaint
*
)
;
static
sk_sp
<
SkImage
>
MakeTextureFromPixmap
(
GrContext
*
const
SkPixmap
&
SkBudgeted
budgeted
)
;
int
width
(
)
const
{
return
fWidth
;
}
int
height
(
)
const
{
return
fHeight
;
}
SkISize
dimensions
(
)
const
{
return
SkISize
:
:
Make
(
fWidth
fHeight
)
;
}
SkIRect
bounds
(
)
const
{
return
SkIRect
:
:
MakeWH
(
fWidth
fHeight
)
;
}
uint32_t
uniqueID
(
)
const
{
return
fUniqueID
;
}
SkAlphaType
alphaType
(
)
const
;
bool
isOpaque
(
)
const
{
return
SkAlphaTypeIsOpaque
(
this
-
>
alphaType
(
)
)
;
}
bool
readYUV8Planes
(
const
SkISize
[
3
]
void
*
const
planes
[
3
]
const
size_t
rowBytes
[
3
]
SkYUVColorSpace
)
const
;
#
ifdef
SK_SUPPORT_LEGACY_CREATESHADER_PTR
SkShader
*
newShader
(
SkShader
:
:
TileMode
SkShader
:
:
TileMode
const
SkMatrix
*
localMatrix
=
nullptr
)
const
;
#
endif
sk_sp
<
SkShader
>
makeShader
(
SkShader
:
:
TileMode
SkShader
:
:
TileMode
const
SkMatrix
*
localMatrix
=
nullptr
)
const
;
bool
peekPixels
(
SkPixmap
*
pixmap
)
const
;
#
ifdef
SK_SUPPORT_LEGACY_PEEKPIXELS_PARMS
const
void
*
peekPixels
(
SkImageInfo
*
info
size_t
*
rowBytes
)
const
;
#
endif
void
preroll
(
GrContext
*
=
nullptr
)
const
;
GrTexture
*
getTexture
(
)
const
;
bool
isTextureBacked
(
)
const
;
GrBackendObject
getTextureHandle
(
bool
flushPendingGrContextIO
)
const
;
enum
CachingHint
{
kAllow_CachingHint
kDisallow_CachingHint
}
;
bool
readPixels
(
const
SkImageInfo
&
dstInfo
void
*
dstPixels
size_t
dstRowBytes
int
srcX
int
srcY
CachingHint
=
kAllow_CachingHint
)
const
;
bool
readPixels
(
const
SkPixmap
&
dst
int
srcX
int
srcY
CachingHint
=
kAllow_CachingHint
)
const
;
bool
scalePixels
(
const
SkPixmap
&
dst
SkFilterQuality
CachingHint
=
kAllow_CachingHint
)
const
;
SkData
*
encode
(
SkImageEncoder
:
:
Type
int
quality
)
const
;
SkData
*
encode
(
SkPixelSerializer
*
=
nullptr
)
const
;
SkData
*
refEncoded
(
)
const
;
const
char
*
toString
(
SkString
*
)
const
;
sk_sp
<
SkImage
>
makeSubset
(
const
SkIRect
&
subset
)
const
;
sk_sp
<
SkImage
>
makeTextureImage
(
GrContext
*
)
const
;
sk_sp
<
SkImage
>
makeNonTextureImage
(
)
const
;
sk_sp
<
SkImage
>
makeWithFilter
(
const
SkImageFilter
*
filter
const
SkIRect
&
subset
const
SkIRect
&
clipBounds
SkIRect
*
outSubset
SkIPoint
*
offset
)
const
;
struct
DeferredTextureImageUsageParams
{
DeferredTextureImageUsageParams
(
const
SkMatrix
matrix
const
SkFilterQuality
quality
int
preScaleMipLevel
)
:
fMatrix
(
matrix
)
fQuality
(
quality
)
fPreScaleMipLevel
(
preScaleMipLevel
)
{
}
SkMatrix
fMatrix
;
SkFilterQuality
fQuality
;
int
fPreScaleMipLevel
;
}
;
size_t
getDeferredTextureImageData
(
const
GrContextThreadSafeProxy
&
const
DeferredTextureImageUsageParams
[
]
int
paramCnt
void
*
buffer
SkSourceGammaTreatment
treatment
=
SkSourceGammaTreatment
:
:
kIgnore
)
const
;
static
sk_sp
<
SkImage
>
MakeFromDeferredTextureImageData
(
GrContext
*
const
void
*
SkBudgeted
)
;
enum
LegacyBitmapMode
{
kRO_LegacyBitmapMode
kRW_LegacyBitmapMode
}
;
bool
asLegacyBitmap
(
SkBitmap
*
LegacyBitmapMode
)
const
;
bool
isLazyGenerated
(
)
const
;
#
ifdef
SK_SUPPORT_LEGACY_IMAGEFACTORY
static
SkImage
*
NewRasterCopy
(
const
Info
&
const
void
*
pixels
size_t
rowBytes
SkColorTable
*
ctable
=
nullptr
)
;
static
SkImage
*
NewRasterData
(
const
Info
&
SkData
*
pixels
size_t
rowBytes
)
;
static
SkImage
*
NewFromRaster
(
const
Info
&
const
void
*
pixels
size_t
rowBytes
RasterReleaseProc
ReleaseContext
)
;
static
SkImage
*
NewFromBitmap
(
const
SkBitmap
&
)
;
static
SkImage
*
NewFromGenerator
(
SkImageGenerator
*
const
SkIRect
*
subset
=
nullptr
)
;
static
SkImage
*
NewFromEncoded
(
SkData
*
encoded
const
SkIRect
*
subset
=
nullptr
)
;
static
SkImage
*
NewFromTexture
(
GrContext
*
ctx
const
GrBackendTextureDesc
&
desc
)
{
return
NewFromTexture
(
ctx
desc
kPremul_SkAlphaType
nullptr
nullptr
)
;
}
static
SkImage
*
NewFromTexture
(
GrContext
*
ctx
const
GrBackendTextureDesc
&
de
SkAlphaType
at
)
{
return
NewFromTexture
(
ctx
de
at
nullptr
nullptr
)
;
}
static
SkImage
*
NewFromTexture
(
GrContext
*
const
GrBackendTextureDesc
&
SkAlphaType
TextureReleaseProc
ReleaseContext
)
;
static
SkImage
*
NewFromAdoptedTexture
(
GrContext
*
const
GrBackendTextureDesc
&
SkAlphaType
=
kPremul_SkAlphaType
)
;
static
SkImage
*
NewFromYUVTexturesCopy
(
GrContext
*
SkYUVColorSpace
const
GrBackendObject
yuvTextureHandles
[
3
]
const
SkISize
yuvSizes
[
3
]
GrSurfaceOrigin
)
;
static
SkImage
*
NewFromPicture
(
const
SkPicture
*
const
SkISize
&
dimensions
const
SkMatrix
*
const
SkPaint
*
)
;
static
SkImage
*
NewTextureFromPixmap
(
GrContext
*
const
SkPixmap
&
SkBudgeted
budgeted
)
;
static
SkImage
*
NewFromDeferredTextureImageData
(
GrContext
*
const
void
*
SkBudgeted
)
;
SkImage
*
newSubset
(
const
SkIRect
&
subset
)
const
{
return
this
-
>
makeSubset
(
subset
)
.
release
(
)
;
}
SkImage
*
newTextureImage
(
GrContext
*
ctx
)
const
{
return
this
-
>
makeTextureImage
(
ctx
)
.
release
(
)
;
}
#
endif
protected
:
SkImage
(
int
width
int
height
uint32_t
uniqueID
)
;
private
:
static
sk_sp
<
SkImage
>
MakeTextureFromMipMap
(
GrContext
*
const
SkImageInfo
&
const
GrMipLevel
*
texels
int
mipLevelCount
SkBudgeted
SkSourceGammaTreatment
)
;
const
int
fWidth
;
const
int
fHeight
;
const
uint32_t
fUniqueID
;
typedef
SkRefCnt
INHERITED
;
}
;
#
endif
