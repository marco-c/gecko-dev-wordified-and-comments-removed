#
ifndef
SkShader_DEFINED
#
define
SkShader_DEFINED
#
include
"
SkBitmap
.
h
"
#
include
"
SkFlattenable
.
h
"
#
include
"
SkImageInfo
.
h
"
#
include
"
SkMask
.
h
"
#
include
"
SkMatrix
.
h
"
#
include
"
SkPaint
.
h
"
#
include
"
.
.
/
gpu
/
GrColor
.
h
"
class
SkColorFilter
;
class
SkColorSpace
;
class
SkImage
;
class
SkPath
;
class
SkPicture
;
class
SkXfermode
;
class
GrContext
;
class
GrFragmentProcessor
;
class
SK_API
SkShader
:
public
SkFlattenable
{
public
:
SkShader
(
const
SkMatrix
*
localMatrix
=
NULL
)
;
virtual
~
SkShader
(
)
;
const
SkMatrix
&
getLocalMatrix
(
)
const
{
return
fLocalMatrix
;
}
enum
TileMode
{
kClamp_TileMode
kRepeat_TileMode
kMirror_TileMode
#
if
0
kDecal_TileMode
#
endif
}
;
enum
{
kTileModeCount
=
kMirror_TileMode
+
1
}
;
enum
Flags
{
kOpaqueAlpha_Flag
=
1
<
<
0
kConstInY32_Flag
=
1
<
<
1
kPrefers4f_Flag
=
1
<
<
2
}
;
virtual
bool
isOpaque
(
)
const
{
return
false
;
}
struct
ContextRec
{
enum
DstType
{
kPMColor_DstType
kPM4f_DstType
}
;
ContextRec
(
const
SkPaint
&
paint
const
SkMatrix
&
matrix
const
SkMatrix
*
localM
DstType
dstType
)
:
fPaint
(
&
paint
)
fMatrix
(
&
matrix
)
fLocalMatrix
(
localM
)
fPreferredDstType
(
dstType
)
{
}
const
SkPaint
*
fPaint
;
const
SkMatrix
*
fMatrix
;
const
SkMatrix
*
fLocalMatrix
;
const
DstType
fPreferredDstType
;
}
;
class
Context
:
public
:
:
SkNoncopyable
{
public
:
Context
(
const
SkShader
&
shader
const
ContextRec
&
)
;
virtual
~
Context
(
)
;
virtual
uint32_t
getFlags
(
)
const
{
return
0
;
}
virtual
void
shadeSpan
(
int
x
int
y
SkPMColor
[
]
int
count
)
=
0
;
virtual
void
shadeSpan4f
(
int
x
int
y
SkPM4f
[
]
int
count
)
;
struct
BlitState
;
typedef
void
(
*
BlitBW
)
(
BlitState
*
int
x
int
y
const
SkPixmap
&
int
count
)
;
typedef
void
(
*
BlitAA
)
(
BlitState
*
int
x
int
y
const
SkPixmap
&
int
count
const
SkAlpha
[
]
)
;
struct
BlitState
{
Context
*
fCtx
;
SkXfermode
*
fXfer
;
enum
{
N
=
2
}
;
void
*
fStorage
[
N
]
;
BlitBW
fBlitBW
;
BlitAA
fBlitAA
;
}
;
bool
chooseBlitProcs
(
const
SkImageInfo
&
info
BlitState
*
state
)
{
state
-
>
fBlitBW
=
nullptr
;
state
-
>
fBlitAA
=
nullptr
;
if
(
this
-
>
onChooseBlitProcs
(
info
state
)
)
{
SkASSERT
(
state
-
>
fBlitBW
|
|
state
-
>
fBlitAA
)
;
return
true
;
}
return
false
;
}
typedef
void
(
*
ShadeProc
)
(
const
void
*
ctx
int
x
int
y
SkPMColor
[
]
int
count
)
;
virtual
ShadeProc
asAShadeProc
(
void
*
*
ctx
)
;
virtual
void
shadeSpanAlpha
(
int
x
int
y
uint8_t
alpha
[
]
int
count
)
;
virtual
void
set3DMask
(
const
SkMask
*
)
{
}
protected
:
const
SkShader
&
fShader
;
enum
MatrixClass
{
kLinear_MatrixClass
kFixedStepInX_MatrixClass
kPerspective_MatrixClass
}
;
static
MatrixClass
ComputeMatrixClass
(
const
SkMatrix
&
)
;
uint8_t
getPaintAlpha
(
)
const
{
return
fPaintAlpha
;
}
const
SkMatrix
&
getTotalInverse
(
)
const
{
return
fTotalInverse
;
}
MatrixClass
getInverseClass
(
)
const
{
return
(
MatrixClass
)
fTotalInverseClass
;
}
const
SkMatrix
&
getCTM
(
)
const
{
return
fCTM
;
}
virtual
bool
onChooseBlitProcs
(
const
SkImageInfo
&
BlitState
*
)
{
return
false
;
}
private
:
SkMatrix
fCTM
;
SkMatrix
fTotalInverse
;
uint8_t
fPaintAlpha
;
uint8_t
fTotalInverseClass
;
typedef
SkNoncopyable
INHERITED
;
}
;
Context
*
createContext
(
const
ContextRec
&
void
*
storage
)
const
;
size_t
contextSize
(
const
ContextRec
&
)
const
;
#
ifdef
SK_SUPPORT_LEGACY_SHADER_ISABITMAP
bool
isABitmap
(
SkBitmap
*
outTexture
SkMatrix
*
outMatrix
TileMode
xy
[
2
]
)
const
{
return
this
-
>
onIsABitmap
(
outTexture
outMatrix
xy
)
;
}
bool
isABitmap
(
)
const
{
return
this
-
>
isABitmap
(
nullptr
nullptr
nullptr
)
;
}
#
endif
SkImage
*
isAImage
(
SkMatrix
*
localMatrix
TileMode
xy
[
2
]
)
const
{
return
this
-
>
onIsAImage
(
localMatrix
xy
)
;
}
bool
isAImage
(
)
const
{
return
this
-
>
isAImage
(
nullptr
nullptr
)
!
=
nullptr
;
}
enum
GradientType
{
kNone_GradientType
kColor_GradientType
kLinear_GradientType
kRadial_GradientType
kSweep_GradientType
kConical_GradientType
kLast_GradientType
=
kConical_GradientType
}
;
struct
GradientInfo
{
int
fColorCount
;
SkColor
*
fColors
;
SkScalar
*
fColorOffsets
;
SkPoint
fPoint
[
2
]
;
SkScalar
fRadius
[
2
]
;
TileMode
fTileMode
;
uint32_t
fGradientFlags
;
}
;
virtual
GradientType
asAGradient
(
GradientInfo
*
info
)
const
;
struct
ComposeRec
{
const
SkShader
*
fShaderA
;
const
SkShader
*
fShaderB
;
const
SkXfermode
*
fMode
;
}
;
virtual
bool
asACompose
(
ComposeRec
*
)
const
{
return
false
;
}
#
if
SK_SUPPORT_GPU
struct
AsFPArgs
{
AsFPArgs
(
GrContext
*
context
const
SkMatrix
*
viewMatrix
const
SkMatrix
*
localMatrix
SkFilterQuality
filterQuality
SkColorSpace
*
dstColorSpace
SkSourceGammaTreatment
gammaTreatment
)
:
fContext
(
context
)
fViewMatrix
(
viewMatrix
)
fLocalMatrix
(
localMatrix
)
fFilterQuality
(
filterQuality
)
fDstColorSpace
(
dstColorSpace
)
fGammaTreatment
(
gammaTreatment
)
{
}
GrContext
*
fContext
;
const
SkMatrix
*
fViewMatrix
;
const
SkMatrix
*
fLocalMatrix
;
SkFilterQuality
fFilterQuality
;
SkColorSpace
*
fDstColorSpace
;
SkSourceGammaTreatment
fGammaTreatment
;
}
;
virtual
sk_sp
<
GrFragmentProcessor
>
asFragmentProcessor
(
const
AsFPArgs
&
)
const
;
#
endif
bool
asLuminanceColor
(
SkColor
*
)
const
;
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
virtual
bool
asACustomShader
(
void
*
*
)
const
{
return
false
;
}
#
endif
sk_sp
<
SkShader
>
makeWithLocalMatrix
(
const
SkMatrix
&
)
const
;
sk_sp
<
SkShader
>
makeWithColorFilter
(
sk_sp
<
SkColorFilter
>
)
const
;
static
sk_sp
<
SkShader
>
MakeEmptyShader
(
)
;
static
sk_sp
<
SkShader
>
MakeColorShader
(
SkColor
)
;
static
sk_sp
<
SkShader
>
MakeColorShader
(
const
SkColor4f
&
sk_sp
<
SkColorSpace
>
)
;
static
sk_sp
<
SkShader
>
MakeComposeShader
(
sk_sp
<
SkShader
>
dst
sk_sp
<
SkShader
>
src
SkXfermode
:
:
Mode
)
;
#
ifdef
SK_SUPPORT_LEGACY_CREATESHADER_PTR
static
SkShader
*
CreateEmptyShader
(
)
{
return
MakeEmptyShader
(
)
.
release
(
)
;
}
static
SkShader
*
CreateColorShader
(
SkColor
c
)
{
return
MakeColorShader
(
c
)
.
release
(
)
;
}
static
SkShader
*
CreateBitmapShader
(
const
SkBitmap
&
src
TileMode
tmx
TileMode
tmy
const
SkMatrix
*
localMatrix
=
nullptr
)
{
return
MakeBitmapShader
(
src
tmx
tmy
localMatrix
)
.
release
(
)
;
}
static
SkShader
*
CreateComposeShader
(
SkShader
*
dst
SkShader
*
src
SkXfermode
:
:
Mode
mode
)
;
static
SkShader
*
CreateComposeShader
(
SkShader
*
dst
SkShader
*
src
SkXfermode
*
xfer
)
;
static
SkShader
*
CreatePictureShader
(
const
SkPicture
*
src
TileMode
tmx
TileMode
tmy
const
SkMatrix
*
localMatrix
const
SkRect
*
tile
)
;
SkShader
*
newWithLocalMatrix
(
const
SkMatrix
&
matrix
)
const
{
return
this
-
>
makeWithLocalMatrix
(
matrix
)
.
release
(
)
;
}
SkShader
*
newWithColorFilter
(
SkColorFilter
*
filter
)
const
;
#
endif
static
sk_sp
<
SkShader
>
MakeComposeShader
(
sk_sp
<
SkShader
>
dst
sk_sp
<
SkShader
>
src
sk_sp
<
SkXfermode
>
xfer
)
;
#
ifdef
SK_SUPPORT_LEGACY_XFERMODE_PTR
static
sk_sp
<
SkShader
>
MakeComposeShader
(
sk_sp
<
SkShader
>
dst
sk_sp
<
SkShader
>
src
SkXfermode
*
xfer
)
;
#
endif
static
sk_sp
<
SkShader
>
MakeBitmapShader
(
const
SkBitmap
&
src
TileMode
tmx
TileMode
tmy
const
SkMatrix
*
localMatrix
=
nullptr
)
;
static
sk_sp
<
SkShader
>
MakePictureShader
(
sk_sp
<
SkPicture
>
src
TileMode
tmx
TileMode
tmy
const
SkMatrix
*
localMatrix
const
SkRect
*
tile
)
;
virtual
SkShader
*
refAsALocalMatrixShader
(
SkMatrix
*
localMatrix
)
const
;
SK_TO_STRING_VIRT
(
)
SK_DEFINE_FLATTENABLE_TYPE
(
SkShader
)
SK_DECLARE_FLATTENABLE_REGISTRAR_GROUP
(
)
protected
:
void
flatten
(
SkWriteBuffer
&
)
const
override
;
bool
computeTotalInverse
(
const
ContextRec
&
SkMatrix
*
totalInverse
)
const
;
virtual
Context
*
onCreateContext
(
const
ContextRec
&
void
*
storage
)
const
;
virtual
size_t
onContextSize
(
const
ContextRec
&
)
const
;
virtual
bool
onAsLuminanceColor
(
SkColor
*
)
const
{
return
false
;
}
#
ifdef
SK_SUPPORT_LEGACY_SHADER_ISABITMAP
virtual
bool
onIsABitmap
(
SkBitmap
*
SkMatrix
*
TileMode
[
2
]
)
const
{
return
false
;
}
#
endif
virtual
SkImage
*
onIsAImage
(
SkMatrix
*
TileMode
[
2
]
)
const
{
return
nullptr
;
}
private
:
SkMatrix
fLocalMatrix
;
friend
class
SkLocalMatrixShader
;
friend
class
SkBitmapProcLegacyShader
;
typedef
SkFlattenable
INHERITED
;
}
;
#
endif
