#
ifndef
SkColorFilter_DEFINED
#
define
SkColorFilter_DEFINED
#
include
"
SkBlendMode
.
h
"
#
include
"
SkColor
.
h
"
#
include
"
SkFlattenable
.
h
"
#
include
"
SkRefCnt
.
h
"
class
GrContext
;
class
GrColorSpaceInfo
;
class
GrFragmentProcessor
;
class
SkArenaAlloc
;
class
SkBitmap
;
class
SkColorSpace
;
class
SkColorSpaceXformer
;
class
SkRasterPipeline
;
class
SK_API
SkColorFilter
:
public
SkFlattenable
{
public
:
virtual
bool
asColorMode
(
SkColor
*
color
SkBlendMode
*
bmode
)
const
;
virtual
bool
asColorMatrix
(
SkScalar
matrix
[
20
]
)
const
;
virtual
bool
asComponentTable
(
SkBitmap
*
table
)
const
;
void
appendStages
(
SkRasterPipeline
*
SkColorSpace
*
SkArenaAlloc
*
bool
shaderIsOpaque
)
const
;
enum
Flags
{
kAlphaUnchanged_Flag
=
1
<
<
0
}
;
virtual
uint32_t
getFlags
(
)
const
{
return
0
;
}
SkColor
filterColor
(
SkColor
)
const
;
SkColor4f
filterColor4f
(
const
SkColor4f
&
)
const
;
static
sk_sp
<
SkColorFilter
>
MakeModeFilter
(
SkColor
c
SkBlendMode
mode
)
;
sk_sp
<
SkColorFilter
>
makeComposed
(
sk_sp
<
SkColorFilter
>
inner
)
const
;
static
sk_sp
<
SkColorFilter
>
MakeComposeFilter
(
sk_sp
<
SkColorFilter
>
outer
sk_sp
<
SkColorFilter
>
inner
)
{
return
outer
?
outer
-
>
makeComposed
(
inner
)
:
inner
;
}
static
sk_sp
<
SkColorFilter
>
MakeMatrixFilterRowMajor255
(
const
SkScalar
array
[
20
]
)
;
static
sk_sp
<
SkColorFilter
>
MakeLinearToSRGBGamma
(
)
;
static
sk_sp
<
SkColorFilter
>
MakeSRGBToLinearGamma
(
)
;
#
if
SK_SUPPORT_GPU
virtual
std
:
:
unique_ptr
<
GrFragmentProcessor
>
asFragmentProcessor
(
GrContext
*
const
GrColorSpaceInfo
&
dstColorSpaceInfo
)
const
;
#
endif
bool
affectsTransparentBlack
(
)
const
{
return
this
-
>
filterColor
(
0
)
!
=
0
;
}
SK_TO_STRING_PUREVIRT
(
)
SK_DECLARE_FLATTENABLE_REGISTRAR_GROUP
(
)
SK_DEFINE_FLATTENABLE_TYPE
(
SkColorFilter
)
protected
:
SkColorFilter
(
)
{
}
sk_sp
<
SkColorFilter
>
makeColorSpace
(
SkColorSpaceXformer
*
xformer
)
const
{
return
this
-
>
onMakeColorSpace
(
xformer
)
;
}
virtual
sk_sp
<
SkColorFilter
>
onMakeColorSpace
(
SkColorSpaceXformer
*
)
const
{
return
sk_ref_sp
(
const_cast
<
SkColorFilter
*
>
(
this
)
)
;
}
virtual
sk_sp
<
SkColorFilter
>
onMakeComposed
(
sk_sp
<
SkColorFilter
>
)
const
{
return
nullptr
;
}
private
:
virtual
int
privateComposedFilterCount
(
)
const
{
return
1
;
}
virtual
void
onAppendStages
(
SkRasterPipeline
*
SkColorSpace
*
SkArenaAlloc
*
bool
shaderIsOpaque
)
const
=
0
;
friend
class
SkColorSpaceXformer
;
friend
class
SkComposeColorFilter
;
typedef
SkFlattenable
INHERITED
;
}
;
#
endif
