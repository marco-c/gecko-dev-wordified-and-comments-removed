#
ifndef
SkRWBuffer_DEFINED
#
define
SkRWBuffer_DEFINED
#
include
"
SkRefCnt
.
h
"
struct
SkBufferBlock
;
struct
SkBufferHead
;
class
SkRWBuffer
;
class
SkStreamAsset
;
class
SK_API
SkROBuffer
:
public
SkRefCnt
{
public
:
size_t
size
(
)
const
{
return
fAvailable
;
}
class
SK_API
Iter
{
public
:
Iter
(
const
SkROBuffer
*
)
;
Iter
(
const
sk_sp
<
SkROBuffer
>
&
)
;
void
reset
(
const
SkROBuffer
*
)
;
const
void
*
data
(
)
const
;
size_t
size
(
)
const
;
bool
next
(
)
;
private
:
const
SkBufferBlock
*
fBlock
;
size_t
fRemaining
;
const
SkROBuffer
*
fBuffer
;
}
;
private
:
SkROBuffer
(
const
SkBufferHead
*
head
size_t
available
const
SkBufferBlock
*
fTail
)
;
virtual
~
SkROBuffer
(
)
;
const
SkBufferHead
*
fHead
;
const
size_t
fAvailable
;
const
SkBufferBlock
*
fTail
;
friend
class
SkRWBuffer
;
}
;
class
SK_API
SkRWBuffer
{
public
:
SkRWBuffer
(
size_t
initialCapacity
=
0
)
;
~
SkRWBuffer
(
)
;
size_t
size
(
)
const
{
return
fTotalUsed
;
}
void
append
(
const
void
*
buffer
size_t
length
size_t
reserve
=
0
)
;
sk_sp
<
SkROBuffer
>
makeROBufferSnapshot
(
)
const
{
return
sk_sp
<
SkROBuffer
>
(
new
SkROBuffer
(
fHead
fTotalUsed
fTail
)
)
;
}
std
:
:
unique_ptr
<
SkStreamAsset
>
makeStreamSnapshot
(
)
const
;
#
ifdef
SK_DEBUG
void
validate
(
)
const
;
#
else
void
validate
(
)
const
{
}
#
endif
private
:
SkBufferHead
*
fHead
;
SkBufferBlock
*
fTail
;
size_t
fTotalUsed
;
}
;
#
endif
