#
ifndef
SkPath_DEFINED
#
define
SkPath_DEFINED
#
include
"
SkMatrix
.
h
"
#
include
"
.
.
/
private
/
SkPathRef
.
h
"
#
include
"
.
.
/
private
/
SkTo
.
h
"
#
include
<
initializer_list
>
class
SkAutoPathBoundsUpdate
;
class
SkData
;
class
SkRRect
;
class
SkWStream
;
class
SK_API
SkPath
{
public
:
enum
Direction
{
kCW_Direction
kCCW_Direction
}
;
SkPath
(
)
;
SkPath
(
const
SkPath
&
path
)
;
~
SkPath
(
)
;
SkPath
&
operator
=
(
const
SkPath
&
path
)
;
friend
SK_API
bool
operator
=
=
(
const
SkPath
&
a
const
SkPath
&
b
)
;
friend
bool
operator
!
=
(
const
SkPath
&
a
const
SkPath
&
b
)
{
return
!
(
a
=
=
b
)
;
}
bool
isInterpolatable
(
const
SkPath
&
compare
)
const
;
bool
interpolate
(
const
SkPath
&
ending
SkScalar
weight
SkPath
*
out
)
const
;
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
bool
unique
(
)
const
{
return
fPathRef
-
>
unique
(
)
;
}
#
endif
enum
FillType
{
kWinding_FillType
kEvenOdd_FillType
kInverseWinding_FillType
kInverseEvenOdd_FillType
}
;
FillType
getFillType
(
)
const
{
return
(
FillType
)
fFillType
;
}
void
setFillType
(
FillType
ft
)
{
fFillType
=
SkToU8
(
ft
)
;
}
bool
isInverseFillType
(
)
const
{
return
IsInverseFillType
(
(
FillType
)
fFillType
)
;
}
void
toggleInverseFillType
(
)
{
fFillType
^
=
2
;
}
enum
Convexity
:
uint8_t
{
kUnknown_Convexity
kConvex_Convexity
kConcave_Convexity
}
;
Convexity
getConvexity
(
)
const
{
for
(
Convexity
convexity
=
fConvexity
.
load
(
)
;
kUnknown_Convexity
!
=
convexity
;
)
{
return
convexity
;
}
return
this
-
>
internalGetConvexity
(
)
;
}
Convexity
getConvexityOrUnknown
(
)
const
{
return
(
Convexity
)
fConvexity
;
}
void
setConvexity
(
Convexity
convexity
)
;
bool
isConvex
(
)
const
{
return
kConvex_Convexity
=
=
this
-
>
getConvexity
(
)
;
}
bool
isOval
(
SkRect
*
bounds
)
const
;
bool
isRRect
(
SkRRect
*
rrect
)
const
;
SkPath
&
reset
(
)
;
SkPath
&
rewind
(
)
;
bool
isEmpty
(
)
const
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
return
0
=
=
fPathRef
-
>
countVerbs
(
)
;
}
bool
isLastContourClosed
(
)
const
;
bool
isFinite
(
)
const
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
return
fPathRef
-
>
isFinite
(
)
;
}
bool
isVolatile
(
)
const
{
return
SkToBool
(
fIsVolatile
)
;
}
void
setIsVolatile
(
bool
isVolatile
)
{
fIsVolatile
=
isVolatile
;
}
static
bool
IsLineDegenerate
(
const
SkPoint
&
p1
const
SkPoint
&
p2
bool
exact
)
;
static
bool
IsQuadDegenerate
(
const
SkPoint
&
p1
const
SkPoint
&
p2
const
SkPoint
&
p3
bool
exact
)
;
static
bool
IsCubicDegenerate
(
const
SkPoint
&
p1
const
SkPoint
&
p2
const
SkPoint
&
p3
const
SkPoint
&
p4
bool
exact
)
;
bool
isLine
(
SkPoint
line
[
2
]
)
const
;
int
countPoints
(
)
const
;
SkPoint
getPoint
(
int
index
)
const
;
int
getPoints
(
SkPoint
points
[
]
int
max
)
const
;
int
countVerbs
(
)
const
;
int
getVerbs
(
uint8_t
verbs
[
]
int
max
)
const
;
void
swap
(
SkPath
&
other
)
;
const
SkRect
&
getBounds
(
)
const
{
return
fPathRef
-
>
getBounds
(
)
;
}
void
updateBoundsCache
(
)
const
{
this
-
>
getBounds
(
)
;
}
SkRect
computeTightBounds
(
)
const
;
bool
conservativelyContainsRect
(
const
SkRect
&
rect
)
const
;
void
incReserve
(
int
extraPtCount
)
;
void
shrinkToFit
(
)
;
SkPath
&
moveTo
(
SkScalar
x
SkScalar
y
)
;
SkPath
&
moveTo
(
const
SkPoint
&
p
)
{
return
this
-
>
moveTo
(
p
.
fX
p
.
fY
)
;
}
SkPath
&
rMoveTo
(
SkScalar
dx
SkScalar
dy
)
;
SkPath
&
lineTo
(
SkScalar
x
SkScalar
y
)
;
SkPath
&
lineTo
(
const
SkPoint
&
p
)
{
return
this
-
>
lineTo
(
p
.
fX
p
.
fY
)
;
}
SkPath
&
rLineTo
(
SkScalar
dx
SkScalar
dy
)
;
SkPath
&
quadTo
(
SkScalar
x1
SkScalar
y1
SkScalar
x2
SkScalar
y2
)
;
SkPath
&
quadTo
(
const
SkPoint
&
p1
const
SkPoint
&
p2
)
{
return
this
-
>
quadTo
(
p1
.
fX
p1
.
fY
p2
.
fX
p2
.
fY
)
;
}
SkPath
&
rQuadTo
(
SkScalar
dx1
SkScalar
dy1
SkScalar
dx2
SkScalar
dy2
)
;
SkPath
&
conicTo
(
SkScalar
x1
SkScalar
y1
SkScalar
x2
SkScalar
y2
SkScalar
w
)
;
SkPath
&
conicTo
(
const
SkPoint
&
p1
const
SkPoint
&
p2
SkScalar
w
)
{
return
this
-
>
conicTo
(
p1
.
fX
p1
.
fY
p2
.
fX
p2
.
fY
w
)
;
}
SkPath
&
rConicTo
(
SkScalar
dx1
SkScalar
dy1
SkScalar
dx2
SkScalar
dy2
SkScalar
w
)
;
SkPath
&
cubicTo
(
SkScalar
x1
SkScalar
y1
SkScalar
x2
SkScalar
y2
SkScalar
x3
SkScalar
y3
)
;
SkPath
&
cubicTo
(
const
SkPoint
&
p1
const
SkPoint
&
p2
const
SkPoint
&
p3
)
{
return
this
-
>
cubicTo
(
p1
.
fX
p1
.
fY
p2
.
fX
p2
.
fY
p3
.
fX
p3
.
fY
)
;
}
SkPath
&
rCubicTo
(
SkScalar
x1
SkScalar
y1
SkScalar
x2
SkScalar
y2
SkScalar
x3
SkScalar
y3
)
;
SkPath
&
arcTo
(
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
bool
forceMoveTo
)
;
SkPath
&
arcTo
(
SkScalar
x1
SkScalar
y1
SkScalar
x2
SkScalar
y2
SkScalar
radius
)
;
SkPath
&
arcTo
(
const
SkPoint
p1
const
SkPoint
p2
SkScalar
radius
)
{
return
this
-
>
arcTo
(
p1
.
fX
p1
.
fY
p2
.
fX
p2
.
fY
radius
)
;
}
enum
ArcSize
{
kSmall_ArcSize
kLarge_ArcSize
}
;
SkPath
&
arcTo
(
SkScalar
rx
SkScalar
ry
SkScalar
xAxisRotate
ArcSize
largeArc
Direction
sweep
SkScalar
x
SkScalar
y
)
;
SkPath
&
arcTo
(
const
SkPoint
r
SkScalar
xAxisRotate
ArcSize
largeArc
Direction
sweep
const
SkPoint
xy
)
{
return
this
-
>
arcTo
(
r
.
fX
r
.
fY
xAxisRotate
largeArc
sweep
xy
.
fX
xy
.
fY
)
;
}
SkPath
&
rArcTo
(
SkScalar
rx
SkScalar
ry
SkScalar
xAxisRotate
ArcSize
largeArc
Direction
sweep
SkScalar
dx
SkScalar
dy
)
;
SkPath
&
close
(
)
;
static
bool
IsInverseFillType
(
FillType
fill
)
{
static_assert
(
0
=
=
kWinding_FillType
"
fill_type_mismatch
"
)
;
static_assert
(
1
=
=
kEvenOdd_FillType
"
fill_type_mismatch
"
)
;
static_assert
(
2
=
=
kInverseWinding_FillType
"
fill_type_mismatch
"
)
;
static_assert
(
3
=
=
kInverseEvenOdd_FillType
"
fill_type_mismatch
"
)
;
return
(
fill
&
2
)
!
=
0
;
}
static
FillType
ConvertToNonInverseFillType
(
FillType
fill
)
{
static_assert
(
0
=
=
kWinding_FillType
"
fill_type_mismatch
"
)
;
static_assert
(
1
=
=
kEvenOdd_FillType
"
fill_type_mismatch
"
)
;
static_assert
(
2
=
=
kInverseWinding_FillType
"
fill_type_mismatch
"
)
;
static_assert
(
3
=
=
kInverseEvenOdd_FillType
"
fill_type_mismatch
"
)
;
return
(
FillType
)
(
fill
&
1
)
;
}
static
int
ConvertConicToQuads
(
const
SkPoint
&
p0
const
SkPoint
&
p1
const
SkPoint
&
p2
SkScalar
w
SkPoint
pts
[
]
int
pow2
)
;
bool
isRect
(
SkRect
*
rect
bool
*
isClosed
=
nullptr
Direction
*
direction
=
nullptr
)
const
;
bool
isNestedFillRects
(
SkRect
rect
[
2
]
Direction
dirs
[
2
]
=
nullptr
)
const
;
SkPath
&
addRect
(
const
SkRect
&
rect
Direction
dir
=
kCW_Direction
)
;
SkPath
&
addRect
(
const
SkRect
&
rect
Direction
dir
unsigned
start
)
;
SkPath
&
addRect
(
SkScalar
left
SkScalar
top
SkScalar
right
SkScalar
bottom
Direction
dir
=
kCW_Direction
)
;
SkPath
&
addOval
(
const
SkRect
&
oval
Direction
dir
=
kCW_Direction
)
;
SkPath
&
addOval
(
const
SkRect
&
oval
Direction
dir
unsigned
start
)
;
SkPath
&
addCircle
(
SkScalar
x
SkScalar
y
SkScalar
radius
Direction
dir
=
kCW_Direction
)
;
SkPath
&
addArc
(
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
)
;
SkPath
&
addRoundRect
(
const
SkRect
&
rect
SkScalar
rx
SkScalar
ry
Direction
dir
=
kCW_Direction
)
;
SkPath
&
addRoundRect
(
const
SkRect
&
rect
const
SkScalar
radii
[
]
Direction
dir
=
kCW_Direction
)
;
SkPath
&
addRRect
(
const
SkRRect
&
rrect
Direction
dir
=
kCW_Direction
)
;
SkPath
&
addRRect
(
const
SkRRect
&
rrect
Direction
dir
unsigned
start
)
;
SkPath
&
addPoly
(
const
SkPoint
pts
[
]
int
count
bool
close
)
;
SkPath
&
addPoly
(
const
std
:
:
initializer_list
<
SkPoint
>
&
list
bool
close
)
{
return
this
-
>
addPoly
(
list
.
begin
(
)
SkToInt
(
list
.
size
(
)
)
close
)
;
}
enum
AddPathMode
{
kAppend_AddPathMode
kExtend_AddPathMode
}
;
SkPath
&
addPath
(
const
SkPath
&
src
SkScalar
dx
SkScalar
dy
AddPathMode
mode
=
kAppend_AddPathMode
)
;
SkPath
&
addPath
(
const
SkPath
&
src
AddPathMode
mode
=
kAppend_AddPathMode
)
{
SkMatrix
m
;
m
.
reset
(
)
;
return
this
-
>
addPath
(
src
m
mode
)
;
}
SkPath
&
addPath
(
const
SkPath
&
src
const
SkMatrix
&
matrix
AddPathMode
mode
=
kAppend_AddPathMode
)
;
SkPath
&
reverseAddPath
(
const
SkPath
&
src
)
;
void
offset
(
SkScalar
dx
SkScalar
dy
SkPath
*
dst
)
const
;
void
offset
(
SkScalar
dx
SkScalar
dy
)
{
this
-
>
offset
(
dx
dy
this
)
;
}
void
transform
(
const
SkMatrix
&
matrix
SkPath
*
dst
)
const
;
void
transform
(
const
SkMatrix
&
matrix
)
{
this
-
>
transform
(
matrix
this
)
;
}
bool
getLastPt
(
SkPoint
*
lastPt
)
const
;
void
setLastPt
(
SkScalar
x
SkScalar
y
)
;
void
setLastPt
(
const
SkPoint
&
p
)
{
this
-
>
setLastPt
(
p
.
fX
p
.
fY
)
;
}
enum
SegmentMask
{
kLine_SegmentMask
=
1
<
<
0
kQuad_SegmentMask
=
1
<
<
1
kConic_SegmentMask
=
1
<
<
2
kCubic_SegmentMask
=
1
<
<
3
}
;
uint32_t
getSegmentMasks
(
)
const
{
return
fPathRef
-
>
getSegmentMasks
(
)
;
}
enum
Verb
{
kMove_Verb
kLine_Verb
kQuad_Verb
kConic_Verb
kCubic_Verb
kClose_Verb
kDone_Verb
}
;
class
SK_API
Iter
{
public
:
Iter
(
)
;
Iter
(
const
SkPath
&
path
bool
forceClose
)
;
void
setPath
(
const
SkPath
&
path
bool
forceClose
)
;
Verb
next
(
SkPoint
pts
[
4
]
bool
doConsumeDegenerates
=
true
bool
exact
=
false
)
{
if
(
doConsumeDegenerates
)
{
this
-
>
consumeDegenerateSegments
(
exact
)
;
}
return
this
-
>
doNext
(
pts
)
;
}
SkScalar
conicWeight
(
)
const
{
return
*
fConicWeights
;
}
bool
isCloseLine
(
)
const
{
return
SkToBool
(
fCloseLine
)
;
}
bool
isClosedContour
(
)
const
;
private
:
const
SkPoint
*
fPts
;
const
uint8_t
*
fVerbs
;
const
uint8_t
*
fVerbStop
;
const
SkScalar
*
fConicWeights
;
SkPoint
fMoveTo
;
SkPoint
fLastPt
;
bool
fForceClose
;
bool
fNeedClose
;
bool
fCloseLine
;
enum
SegmentState
:
uint8_t
{
kEmptyContour_SegmentState
kAfterMove_SegmentState
kAfterPrimitive_SegmentState
}
;
SegmentState
fSegmentState
;
inline
const
SkPoint
&
cons_moveTo
(
)
;
Verb
autoClose
(
SkPoint
pts
[
2
]
)
;
void
consumeDegenerateSegments
(
bool
exact
)
;
Verb
doNext
(
SkPoint
pts
[
4
]
)
;
}
;
class
SK_API
RawIter
{
public
:
RawIter
(
)
{
}
RawIter
(
const
SkPath
&
path
)
{
setPath
(
path
)
;
}
void
setPath
(
const
SkPath
&
path
)
{
fRawIter
.
setPathRef
(
*
path
.
fPathRef
.
get
(
)
)
;
}
Verb
next
(
SkPoint
pts
[
4
]
)
{
return
(
Verb
)
fRawIter
.
next
(
pts
)
;
}
Verb
peek
(
)
const
{
return
(
Verb
)
fRawIter
.
peek
(
)
;
}
SkScalar
conicWeight
(
)
const
{
return
fRawIter
.
conicWeight
(
)
;
}
private
:
SkPathRef
:
:
Iter
fRawIter
;
friend
class
SkPath
;
}
;
bool
contains
(
SkScalar
x
SkScalar
y
)
const
;
void
dump
(
SkWStream
*
stream
bool
forceClose
bool
dumpAsHex
)
const
;
void
dump
(
)
const
;
void
dumpHex
(
)
const
;
size_t
writeToMemory
(
void
*
buffer
)
const
;
sk_sp
<
SkData
>
serialize
(
)
const
;
size_t
readFromMemory
(
const
void
*
buffer
size_t
length
)
;
uint32_t
getGenerationID
(
)
const
;
#
ifdef
SK_SUPPORT_DIRECT_PATHREF_VALIDATION
bool
isValid
(
)
const
{
return
this
-
>
isValidImpl
(
)
&
&
fPathRef
-
>
isValid
(
)
;
}
#
else
bool
isValid
(
)
const
{
return
this
-
>
isValidImpl
(
)
;
}
bool
pathRefIsValid
(
)
const
{
return
fPathRef
-
>
isValid
(
)
;
}
#
endif
private
:
sk_sp
<
SkPathRef
>
fPathRef
;
int
fLastMoveToIndex
;
mutable
SkAtomic
<
Convexity
sk_memory_order_relaxed
>
fConvexity
;
mutable
SkAtomic
<
uint8_t
sk_memory_order_relaxed
>
fFirstDirection
;
uint8_t
fFillType
:
2
;
uint8_t
fIsVolatile
:
1
;
uint8_t
fIsBadForDAA
:
1
;
void
resetFields
(
)
;
void
copyFields
(
const
SkPath
&
that
)
;
size_t
writeToMemoryAsRRect
(
void
*
buffer
)
const
;
size_t
readAsRRect
(
const
void
*
size_t
)
;
size_t
readFromMemory_LE3
(
const
void
*
size_t
)
;
size_t
readFromMemory_EQ4
(
const
void
*
size_t
)
;
friend
class
Iter
;
friend
class
SkPathPriv
;
friend
class
SkPathStroker
;
SkPath
&
reversePathTo
(
const
SkPath
&
)
;
inline
void
injectMoveToIfNeeded
(
)
;
inline
bool
hasOnlyMoveTos
(
)
const
;
Convexity
internalGetConvexity
(
)
const
;
SkDEBUGCODE
(
void
validate
(
)
const
{
SkASSERT
(
this
-
>
isValidImpl
(
)
)
;
}
)
bool
isValidImpl
(
)
const
;
SkDEBUGCODE
(
void
validateRef
(
)
const
{
fPathRef
-
>
validate
(
)
;
}
)
bool
isRectContour
(
bool
allowPartial
int
*
currVerb
const
SkPoint
*
*
pts
bool
*
isClosed
Direction
*
direction
SkRect
*
rect
)
const
;
bool
isZeroLengthSincePoint
(
int
startPtIndex
)
const
;
bool
hasComputedBounds
(
)
const
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
return
fPathRef
-
>
hasComputedBounds
(
)
;
}
void
setBounds
(
const
SkRect
&
rect
)
{
SkPathRef
:
:
Editor
ed
(
&
fPathRef
)
;
ed
.
setBounds
(
rect
)
;
}
void
setPt
(
int
index
SkScalar
x
SkScalar
y
)
;
friend
class
SkAutoPathBoundsUpdate
;
friend
class
SkAutoDisableOvalCheck
;
friend
class
SkAutoDisableDirectionCheck
;
friend
class
SkPathWriter
;
friend
class
SkOpBuilder
;
friend
class
SkBench_AddPathTest
;
friend
class
PathTest_Private
;
friend
class
ForceIsRRect_Private
;
friend
class
FuzzPath
;
}
;
#
endif
