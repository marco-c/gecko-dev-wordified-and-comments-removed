#
ifndef
SkPath_DEFINED
#
define
SkPath_DEFINED
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkPathTypes
.
h
"
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkDebug
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
"
include
/
private
/
base
/
SkTypeTraits
.
h
"
#
include
<
atomic
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
initializer_list
>
#
include
<
tuple
>
#
include
<
type_traits
>
class
SkData
;
class
SkPathRef
;
class
SkRRect
;
class
SkWStream
;
enum
class
SkPathConvexity
;
enum
class
SkPathFirstDirection
;
class
SK_API
SkPath
{
public
:
static
SkPath
Make
(
const
SkPoint
[
]
int
pointCount
const
uint8_t
[
]
int
verbCount
const
SkScalar
[
]
int
conicWeightCount
SkPathFillType
bool
isVolatile
=
false
)
;
static
SkPath
Rect
(
const
SkRect
&
SkPathDirection
=
SkPathDirection
:
:
kCW
unsigned
startIndex
=
0
)
;
static
SkPath
Oval
(
const
SkRect
&
SkPathDirection
=
SkPathDirection
:
:
kCW
)
;
static
SkPath
Oval
(
const
SkRect
&
SkPathDirection
unsigned
startIndex
)
;
static
SkPath
Circle
(
SkScalar
center_x
SkScalar
center_y
SkScalar
radius
SkPathDirection
dir
=
SkPathDirection
:
:
kCW
)
;
static
SkPath
RRect
(
const
SkRRect
&
SkPathDirection
dir
=
SkPathDirection
:
:
kCW
)
;
static
SkPath
RRect
(
const
SkRRect
&
SkPathDirection
unsigned
startIndex
)
;
static
SkPath
RRect
(
const
SkRect
&
bounds
SkScalar
rx
SkScalar
ry
SkPathDirection
dir
=
SkPathDirection
:
:
kCW
)
;
static
SkPath
Polygon
(
const
SkPoint
pts
[
]
int
count
bool
isClosed
SkPathFillType
=
SkPathFillType
:
:
kWinding
bool
isVolatile
=
false
)
;
static
SkPath
Polygon
(
const
std
:
:
initializer_list
<
SkPoint
>
&
list
bool
isClosed
SkPathFillType
fillType
=
SkPathFillType
:
:
kWinding
bool
isVolatile
=
false
)
{
return
Polygon
(
list
.
begin
(
)
SkToInt
(
list
.
size
(
)
)
isClosed
fillType
isVolatile
)
;
}
static
SkPath
Line
(
const
SkPoint
a
const
SkPoint
b
)
{
return
Polygon
(
{
a
b
}
false
)
;
}
SkPath
(
)
;
SkPath
(
const
SkPath
&
path
)
;
~
SkPath
(
)
;
SkPath
&
operator
=
(
const
SkPath
&
path
)
;
friend
SK_API
bool
operator
=
=
(
const
SkPath
&
a
const
SkPath
&
b
)
;
friend
bool
operator
!
=
(
const
SkPath
&
a
const
SkPath
&
b
)
{
return
!
(
a
=
=
b
)
;
}
bool
isInterpolatable
(
const
SkPath
&
compare
)
const
;
bool
interpolate
(
const
SkPath
&
ending
SkScalar
weight
SkPath
*
out
)
const
;
SkPathFillType
getFillType
(
)
const
{
return
(
SkPathFillType
)
fFillType
;
}
void
setFillType
(
SkPathFillType
ft
)
{
fFillType
=
SkToU8
(
ft
)
;
}
bool
isInverseFillType
(
)
const
{
return
SkPathFillType_IsInverse
(
this
-
>
getFillType
(
)
)
;
}
void
toggleInverseFillType
(
)
{
fFillType
^
=
2
;
}
bool
isConvex
(
)
const
;
bool
isOval
(
SkRect
*
bounds
)
const
;
bool
isRRect
(
SkRRect
*
rrect
)
const
;
SkPath
&
reset
(
)
;
SkPath
&
rewind
(
)
;
bool
isEmpty
(
)
const
;
bool
isLastContourClosed
(
)
const
;
bool
isFinite
(
)
const
;
bool
isVolatile
(
)
const
{
return
SkToBool
(
fIsVolatile
)
;
}
SkPath
&
setIsVolatile
(
bool
isVolatile
)
{
fIsVolatile
=
isVolatile
;
return
*
this
;
}
static
bool
IsLineDegenerate
(
const
SkPoint
&
p1
const
SkPoint
&
p2
bool
exact
)
;
static
bool
IsQuadDegenerate
(
const
SkPoint
&
p1
const
SkPoint
&
p2
const
SkPoint
&
p3
bool
exact
)
;
static
bool
IsCubicDegenerate
(
const
SkPoint
&
p1
const
SkPoint
&
p2
const
SkPoint
&
p3
const
SkPoint
&
p4
bool
exact
)
;
bool
isLine
(
SkPoint
line
[
2
]
)
const
;
int
countPoints
(
)
const
;
SkPoint
getPoint
(
int
index
)
const
;
int
getPoints
(
SkPoint
points
[
]
int
max
)
const
;
int
countVerbs
(
)
const
;
int
getVerbs
(
uint8_t
verbs
[
]
int
max
)
const
;
size_t
approximateBytesUsed
(
)
const
;
void
swap
(
SkPath
&
other
)
;
const
SkRect
&
getBounds
(
)
const
;
void
updateBoundsCache
(
)
const
{
this
-
>
getBounds
(
)
;
}
SkRect
computeTightBounds
(
)
const
;
bool
conservativelyContainsRect
(
const
SkRect
&
rect
)
const
;
void
incReserve
(
int
extraPtCount
)
;
#
ifdef
SK_HIDE_PATH_EDIT_METHODS
private
:
#
endif
SkPath
&
moveTo
(
SkScalar
x
SkScalar
y
)
;
SkPath
&
moveTo
(
const
SkPoint
&
p
)
{
return
this
-
>
moveTo
(
p
.
fX
p
.
fY
)
;
}
SkPath
&
rMoveTo
(
SkScalar
dx
SkScalar
dy
)
;
SkPath
&
lineTo
(
SkScalar
x
SkScalar
y
)
;
SkPath
&
lineTo
(
const
SkPoint
&
p
)
{
return
this
-
>
lineTo
(
p
.
fX
p
.
fY
)
;
}
SkPath
&
rLineTo
(
SkScalar
dx
SkScalar
dy
)
;
SkPath
&
quadTo
(
SkScalar
x1
SkScalar
y1
SkScalar
x2
SkScalar
y2
)
;
SkPath
&
quadTo
(
const
SkPoint
&
p1
const
SkPoint
&
p2
)
{
return
this
-
>
quadTo
(
p1
.
fX
p1
.
fY
p2
.
fX
p2
.
fY
)
;
}
SkPath
&
rQuadTo
(
SkScalar
dx1
SkScalar
dy1
SkScalar
dx2
SkScalar
dy2
)
;
SkPath
&
conicTo
(
SkScalar
x1
SkScalar
y1
SkScalar
x2
SkScalar
y2
SkScalar
w
)
;
SkPath
&
conicTo
(
const
SkPoint
&
p1
const
SkPoint
&
p2
SkScalar
w
)
{
return
this
-
>
conicTo
(
p1
.
fX
p1
.
fY
p2
.
fX
p2
.
fY
w
)
;
}
SkPath
&
rConicTo
(
SkScalar
dx1
SkScalar
dy1
SkScalar
dx2
SkScalar
dy2
SkScalar
w
)
;
SkPath
&
cubicTo
(
SkScalar
x1
SkScalar
y1
SkScalar
x2
SkScalar
y2
SkScalar
x3
SkScalar
y3
)
;
SkPath
&
cubicTo
(
const
SkPoint
&
p1
const
SkPoint
&
p2
const
SkPoint
&
p3
)
{
return
this
-
>
cubicTo
(
p1
.
fX
p1
.
fY
p2
.
fX
p2
.
fY
p3
.
fX
p3
.
fY
)
;
}
SkPath
&
rCubicTo
(
SkScalar
dx1
SkScalar
dy1
SkScalar
dx2
SkScalar
dy2
SkScalar
dx3
SkScalar
dy3
)
;
SkPath
&
arcTo
(
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
bool
forceMoveTo
)
;
SkPath
&
arcTo
(
SkScalar
x1
SkScalar
y1
SkScalar
x2
SkScalar
y2
SkScalar
radius
)
;
SkPath
&
arcTo
(
const
SkPoint
p1
const
SkPoint
p2
SkScalar
radius
)
{
return
this
-
>
arcTo
(
p1
.
fX
p1
.
fY
p2
.
fX
p2
.
fY
radius
)
;
}
enum
ArcSize
{
kSmall_ArcSize
kLarge_ArcSize
}
;
SkPath
&
arcTo
(
SkScalar
rx
SkScalar
ry
SkScalar
xAxisRotate
ArcSize
largeArc
SkPathDirection
sweep
SkScalar
x
SkScalar
y
)
;
SkPath
&
arcTo
(
const
SkPoint
r
SkScalar
xAxisRotate
ArcSize
largeArc
SkPathDirection
sweep
const
SkPoint
xy
)
{
return
this
-
>
arcTo
(
r
.
fX
r
.
fY
xAxisRotate
largeArc
sweep
xy
.
fX
xy
.
fY
)
;
}
SkPath
&
rArcTo
(
SkScalar
rx
SkScalar
ry
SkScalar
xAxisRotate
ArcSize
largeArc
SkPathDirection
sweep
SkScalar
dx
SkScalar
dy
)
;
SkPath
&
close
(
)
;
#
ifdef
SK_HIDE_PATH_EDIT_METHODS
public
:
#
endif
static
int
ConvertConicToQuads
(
const
SkPoint
&
p0
const
SkPoint
&
p1
const
SkPoint
&
p2
SkScalar
w
SkPoint
pts
[
]
int
pow2
)
;
bool
isRect
(
SkRect
*
rect
bool
*
isClosed
=
nullptr
SkPathDirection
*
direction
=
nullptr
)
const
;
#
ifdef
SK_HIDE_PATH_EDIT_METHODS
private
:
#
endif
SkPath
&
addRect
(
const
SkRect
&
rect
SkPathDirection
dir
unsigned
start
)
;
SkPath
&
addRect
(
const
SkRect
&
rect
SkPathDirection
dir
=
SkPathDirection
:
:
kCW
)
{
return
this
-
>
addRect
(
rect
dir
0
)
;
}
SkPath
&
addRect
(
SkScalar
left
SkScalar
top
SkScalar
right
SkScalar
bottom
SkPathDirection
dir
=
SkPathDirection
:
:
kCW
)
{
return
this
-
>
addRect
(
{
left
top
right
bottom
}
dir
0
)
;
}
SkPath
&
addOval
(
const
SkRect
&
oval
SkPathDirection
dir
=
SkPathDirection
:
:
kCW
)
;
SkPath
&
addOval
(
const
SkRect
&
oval
SkPathDirection
dir
unsigned
start
)
;
SkPath
&
addCircle
(
SkScalar
x
SkScalar
y
SkScalar
radius
SkPathDirection
dir
=
SkPathDirection
:
:
kCW
)
;
SkPath
&
addArc
(
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
)
;
SkPath
&
addRoundRect
(
const
SkRect
&
rect
SkScalar
rx
SkScalar
ry
SkPathDirection
dir
=
SkPathDirection
:
:
kCW
)
;
SkPath
&
addRoundRect
(
const
SkRect
&
rect
const
SkScalar
radii
[
]
SkPathDirection
dir
=
SkPathDirection
:
:
kCW
)
;
SkPath
&
addRRect
(
const
SkRRect
&
rrect
SkPathDirection
dir
=
SkPathDirection
:
:
kCW
)
;
SkPath
&
addRRect
(
const
SkRRect
&
rrect
SkPathDirection
dir
unsigned
start
)
;
SkPath
&
addPoly
(
const
SkPoint
pts
[
]
int
count
bool
close
)
;
SkPath
&
addPoly
(
const
std
:
:
initializer_list
<
SkPoint
>
&
list
bool
close
)
{
return
this
-
>
addPoly
(
list
.
begin
(
)
SkToInt
(
list
.
size
(
)
)
close
)
;
}
#
ifdef
SK_HIDE_PATH_EDIT_METHODS
public
:
#
endif
enum
AddPathMode
{
kAppend_AddPathMode
kExtend_AddPathMode
}
;
SkPath
&
addPath
(
const
SkPath
&
src
SkScalar
dx
SkScalar
dy
AddPathMode
mode
=
kAppend_AddPathMode
)
;
SkPath
&
addPath
(
const
SkPath
&
src
AddPathMode
mode
=
kAppend_AddPathMode
)
{
SkMatrix
m
;
m
.
reset
(
)
;
return
this
-
>
addPath
(
src
m
mode
)
;
}
SkPath
&
addPath
(
const
SkPath
&
src
const
SkMatrix
&
matrix
AddPathMode
mode
=
kAppend_AddPathMode
)
;
SkPath
&
reverseAddPath
(
const
SkPath
&
src
)
;
void
offset
(
SkScalar
dx
SkScalar
dy
SkPath
*
dst
)
const
;
void
offset
(
SkScalar
dx
SkScalar
dy
)
{
this
-
>
offset
(
dx
dy
this
)
;
}
void
transform
(
const
SkMatrix
&
matrix
SkPath
*
dst
SkApplyPerspectiveClip
pc
=
SkApplyPerspectiveClip
:
:
kYes
)
const
;
void
transform
(
const
SkMatrix
&
matrix
SkApplyPerspectiveClip
pc
=
SkApplyPerspectiveClip
:
:
kYes
)
{
this
-
>
transform
(
matrix
this
pc
)
;
}
SkPath
makeTransform
(
const
SkMatrix
&
m
SkApplyPerspectiveClip
pc
=
SkApplyPerspectiveClip
:
:
kYes
)
const
{
SkPath
dst
;
this
-
>
transform
(
m
&
dst
pc
)
;
return
dst
;
}
SkPath
makeScale
(
SkScalar
sx
SkScalar
sy
)
{
return
this
-
>
makeTransform
(
SkMatrix
:
:
Scale
(
sx
sy
)
SkApplyPerspectiveClip
:
:
kNo
)
;
}
bool
getLastPt
(
SkPoint
*
lastPt
)
const
;
void
setLastPt
(
SkScalar
x
SkScalar
y
)
;
void
setLastPt
(
const
SkPoint
&
p
)
{
this
-
>
setLastPt
(
p
.
fX
p
.
fY
)
;
}
enum
SegmentMask
{
kLine_SegmentMask
=
kLine_SkPathSegmentMask
kQuad_SegmentMask
=
kQuad_SkPathSegmentMask
kConic_SegmentMask
=
kConic_SkPathSegmentMask
kCubic_SegmentMask
=
kCubic_SkPathSegmentMask
}
;
uint32_t
getSegmentMasks
(
)
const
;
enum
Verb
{
kMove_Verb
=
static_cast
<
int
>
(
SkPathVerb
:
:
kMove
)
kLine_Verb
=
static_cast
<
int
>
(
SkPathVerb
:
:
kLine
)
kQuad_Verb
=
static_cast
<
int
>
(
SkPathVerb
:
:
kQuad
)
kConic_Verb
=
static_cast
<
int
>
(
SkPathVerb
:
:
kConic
)
kCubic_Verb
=
static_cast
<
int
>
(
SkPathVerb
:
:
kCubic
)
kClose_Verb
=
static_cast
<
int
>
(
SkPathVerb
:
:
kClose
)
kDone_Verb
=
kClose_Verb
+
1
}
;
class
SK_API
Iter
{
public
:
Iter
(
)
;
Iter
(
const
SkPath
&
path
bool
forceClose
)
;
void
setPath
(
const
SkPath
&
path
bool
forceClose
)
;
Verb
next
(
SkPoint
pts
[
4
]
)
;
SkScalar
conicWeight
(
)
const
{
return
*
fConicWeights
;
}
bool
isCloseLine
(
)
const
{
return
SkToBool
(
fCloseLine
)
;
}
bool
isClosedContour
(
)
const
;
private
:
const
SkPoint
*
fPts
;
const
uint8_t
*
fVerbs
;
const
uint8_t
*
fVerbStop
;
const
SkScalar
*
fConicWeights
;
SkPoint
fMoveTo
;
SkPoint
fLastPt
;
bool
fForceClose
;
bool
fNeedClose
;
bool
fCloseLine
;
Verb
autoClose
(
SkPoint
pts
[
2
]
)
;
}
;
private
:
class
RangeIter
{
public
:
RangeIter
(
)
=
default
;
RangeIter
(
const
uint8_t
*
verbs
const
SkPoint
*
points
const
SkScalar
*
weights
)
:
fVerb
(
verbs
)
fPoints
(
points
)
fWeights
(
weights
)
{
SkDEBUGCODE
(
fInitialPoints
=
fPoints
;
)
}
bool
operator
!
=
(
const
RangeIter
&
that
)
const
{
return
fVerb
!
=
that
.
fVerb
;
}
bool
operator
=
=
(
const
RangeIter
&
that
)
const
{
return
fVerb
=
=
that
.
fVerb
;
}
RangeIter
&
operator
+
+
(
)
{
auto
verb
=
static_cast
<
SkPathVerb
>
(
*
fVerb
+
+
)
;
fPoints
+
=
pts_advance_after_verb
(
verb
)
;
if
(
verb
=
=
SkPathVerb
:
:
kConic
)
{
+
+
fWeights
;
}
return
*
this
;
}
RangeIter
operator
+
+
(
int
)
{
RangeIter
copy
=
*
this
;
this
-
>
operator
+
+
(
)
;
return
copy
;
}
SkPathVerb
peekVerb
(
)
const
{
return
static_cast
<
SkPathVerb
>
(
*
fVerb
)
;
}
std
:
:
tuple
<
SkPathVerb
const
SkPoint
*
const
SkScalar
*
>
operator
*
(
)
const
{
SkPathVerb
verb
=
this
-
>
peekVerb
(
)
;
int
backset
=
pts_backset_for_verb
(
verb
)
;
SkASSERT
(
fPoints
+
backset
>
=
fInitialPoints
)
;
return
{
verb
fPoints
+
backset
fWeights
}
;
}
private
:
constexpr
static
int
pts_advance_after_verb
(
SkPathVerb
verb
)
{
switch
(
verb
)
{
case
SkPathVerb
:
:
kMove
:
return
1
;
case
SkPathVerb
:
:
kLine
:
return
1
;
case
SkPathVerb
:
:
kQuad
:
return
2
;
case
SkPathVerb
:
:
kConic
:
return
2
;
case
SkPathVerb
:
:
kCubic
:
return
3
;
case
SkPathVerb
:
:
kClose
:
return
0
;
}
SkUNREACHABLE
;
}
constexpr
static
int
pts_backset_for_verb
(
SkPathVerb
verb
)
{
switch
(
verb
)
{
case
SkPathVerb
:
:
kMove
:
return
0
;
case
SkPathVerb
:
:
kLine
:
return
-
1
;
case
SkPathVerb
:
:
kQuad
:
return
-
1
;
case
SkPathVerb
:
:
kConic
:
return
-
1
;
case
SkPathVerb
:
:
kCubic
:
return
-
1
;
case
SkPathVerb
:
:
kClose
:
return
-
1
;
}
SkUNREACHABLE
;
}
const
uint8_t
*
fVerb
=
nullptr
;
const
SkPoint
*
fPoints
=
nullptr
;
const
SkScalar
*
fWeights
=
nullptr
;
SkDEBUGCODE
(
const
SkPoint
*
fInitialPoints
=
nullptr
;
)
}
;
public
:
class
SK_API
RawIter
{
public
:
RawIter
(
)
{
}
RawIter
(
const
SkPath
&
path
)
{
setPath
(
path
)
;
}
void
setPath
(
const
SkPath
&
)
;
Verb
next
(
SkPoint
[
4
]
)
;
Verb
peek
(
)
const
{
return
(
fIter
!
=
fEnd
)
?
static_cast
<
Verb
>
(
std
:
:
get
<
0
>
(
*
fIter
)
)
:
kDone_Verb
;
}
SkScalar
conicWeight
(
)
const
{
return
fConicWeight
;
}
private
:
RangeIter
fIter
;
RangeIter
fEnd
;
SkScalar
fConicWeight
=
0
;
friend
class
SkPath
;
}
;
bool
contains
(
SkScalar
x
SkScalar
y
)
const
;
void
dump
(
SkWStream
*
stream
bool
dumpAsHex
)
const
;
void
dump
(
)
const
{
this
-
>
dump
(
nullptr
false
)
;
}
void
dumpHex
(
)
const
{
this
-
>
dump
(
nullptr
true
)
;
}
void
dumpArrays
(
SkWStream
*
stream
bool
dumpAsHex
)
const
;
void
dumpArrays
(
)
const
{
this
-
>
dumpArrays
(
nullptr
false
)
;
}
size_t
writeToMemory
(
void
*
buffer
)
const
;
sk_sp
<
SkData
>
serialize
(
)
const
;
size_t
readFromMemory
(
const
void
*
buffer
size_t
length
)
;
uint32_t
getGenerationID
(
)
const
;
bool
isValid
(
)
const
;
using
sk_is_trivially_relocatable
=
std
:
:
true_type
;
private
:
SkPath
(
sk_sp
<
SkPathRef
>
SkPathFillType
bool
isVolatile
SkPathConvexity
SkPathFirstDirection
firstDirection
)
;
sk_sp
<
SkPathRef
>
fPathRef
;
int
fLastMoveToIndex
;
mutable
std
:
:
atomic
<
uint8_t
>
fConvexity
;
mutable
std
:
:
atomic
<
uint8_t
>
fFirstDirection
;
uint8_t
fFillType
:
2
;
uint8_t
fIsVolatile
:
1
;
static_assert
(
:
:
sk_is_trivially_relocatable
<
decltype
(
fPathRef
)
>
:
:
value
)
;
void
resetFields
(
)
;
void
copyFields
(
const
SkPath
&
that
)
;
size_t
writeToMemoryAsRRect
(
void
*
buffer
)
const
;
size_t
readAsRRect
(
const
void
*
size_t
)
;
size_t
readFromMemory_EQ4Or5
(
const
void
*
size_t
)
;
friend
class
Iter
;
friend
class
SkPathPriv
;
friend
class
SkPathStroker
;
SkPath
&
reversePathTo
(
const
SkPath
&
)
;
inline
void
injectMoveToIfNeeded
(
)
;
inline
bool
hasOnlyMoveTos
(
)
const
;
SkPathConvexity
computeConvexity
(
)
const
;
bool
isValidImpl
(
)
const
;
#
ifdef
SK_DEBUG
void
validate
(
)
const
;
void
validateRef
(
)
const
;
#
endif
bool
isZeroLengthSincePoint
(
int
startPtIndex
)
const
;
bool
hasComputedBounds
(
)
const
;
void
setBounds
(
const
SkRect
&
rect
)
;
void
setPt
(
int
index
SkScalar
x
SkScalar
y
)
;
SkPath
&
dirtyAfterEdit
(
)
;
void
setConvexity
(
SkPathConvexity
)
const
;
void
setFirstDirection
(
SkPathFirstDirection
)
const
;
SkPathFirstDirection
getFirstDirection
(
)
const
;
SkPathConvexity
getConvexity
(
)
const
;
SkPathConvexity
getConvexityOrUnknown
(
)
const
;
bool
isConvexityAccurate
(
)
const
;
void
setConvexity
(
SkPathConvexity
convexity
)
;
void
shrinkToFit
(
)
;
friend
class
SkAutoPathBoundsUpdate
;
friend
class
SkAutoDisableOvalCheck
;
friend
class
SkAutoDisableDirectionCheck
;
friend
class
SkPathBuilder
;
friend
class
SkPathEdgeIter
;
friend
class
SkPathWriter
;
friend
class
SkOpBuilder
;
friend
class
SkBench_AddPathTest
;
friend
class
PathTest_Private
;
friend
class
ForceIsRRect_Private
;
friend
class
FuzzPath
;
}
;
#
endif
