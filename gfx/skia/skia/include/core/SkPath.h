#
ifndef
SkPath_DEFINED
#
define
SkPath_DEFINED
#
include
"
SkMatrix
.
h
"
#
include
"
SkPathRef
.
h
"
#
include
"
SkRefCnt
.
h
"
class
SkReader32
;
class
SkWriter32
;
class
SkAutoPathBoundsUpdate
;
class
SkString
;
class
SkRRect
;
class
SkWStream
;
class
SK_API
SkPath
{
public
:
enum
Direction
{
kCW_Direction
kCCW_Direction
}
;
SkPath
(
)
;
SkPath
(
const
SkPath
&
)
;
~
SkPath
(
)
;
SkPath
&
operator
=
(
const
SkPath
&
)
;
friend
SK_API
bool
operator
=
=
(
const
SkPath
&
const
SkPath
&
)
;
friend
bool
operator
!
=
(
const
SkPath
&
a
const
SkPath
&
b
)
{
return
!
(
a
=
=
b
)
;
}
bool
isInterpolatable
(
const
SkPath
&
compare
)
const
;
bool
interpolate
(
const
SkPath
&
ending
SkScalar
weight
SkPath
*
out
)
const
;
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
bool
unique
(
)
const
{
return
fPathRef
-
>
unique
(
)
;
}
#
endif
enum
FillType
{
kWinding_FillType
kEvenOdd_FillType
kInverseWinding_FillType
kInverseEvenOdd_FillType
}
;
FillType
getFillType
(
)
const
{
return
(
FillType
)
fFillType
;
}
void
setFillType
(
FillType
ft
)
{
fFillType
=
SkToU8
(
ft
)
;
}
bool
isInverseFillType
(
)
const
{
return
IsInverseFillType
(
(
FillType
)
fFillType
)
;
}
void
toggleInverseFillType
(
)
{
fFillType
^
=
2
;
}
enum
Convexity
{
kUnknown_Convexity
kConvex_Convexity
kConcave_Convexity
}
;
Convexity
getConvexity
(
)
const
{
if
(
kUnknown_Convexity
!
=
fConvexity
)
{
return
static_cast
<
Convexity
>
(
fConvexity
)
;
}
else
{
return
this
-
>
internalGetConvexity
(
)
;
}
}
Convexity
getConvexityOrUnknown
(
)
const
{
return
(
Convexity
)
fConvexity
;
}
void
setConvexity
(
Convexity
)
;
bool
isConvex
(
)
const
{
return
kConvex_Convexity
=
=
this
-
>
getConvexity
(
)
;
}
SK_ATTR_DEPRECATED
(
"
use
setConvexity
"
)
void
setIsConvex
(
bool
isConvex
)
{
this
-
>
setConvexity
(
isConvex
?
kConvex_Convexity
:
kConcave_Convexity
)
;
}
bool
isOval
(
SkRect
*
rect
Direction
*
dir
=
nullptr
unsigned
*
start
=
nullptr
)
const
{
bool
isCCW
=
false
;
bool
result
=
fPathRef
-
>
isOval
(
rect
&
isCCW
start
)
;
if
(
dir
&
&
result
)
{
*
dir
=
isCCW
?
kCCW_Direction
:
kCW_Direction
;
}
return
result
;
}
bool
isRRect
(
SkRRect
*
rrect
Direction
*
dir
=
nullptr
unsigned
*
start
=
nullptr
)
const
{
bool
isCCW
=
false
;
bool
result
=
fPathRef
-
>
isRRect
(
rrect
&
isCCW
start
)
;
if
(
dir
&
&
result
)
{
*
dir
=
isCCW
?
kCCW_Direction
:
kCW_Direction
;
}
return
result
;
}
void
reset
(
)
;
void
rewind
(
)
;
bool
isEmpty
(
)
const
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
return
0
=
=
fPathRef
-
>
countVerbs
(
)
;
}
bool
isLastContourClosed
(
)
const
;
bool
isFinite
(
)
const
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
return
fPathRef
-
>
isFinite
(
)
;
}
bool
isVolatile
(
)
const
{
return
SkToBool
(
fIsVolatile
)
;
}
void
setIsVolatile
(
bool
isVolatile
)
{
fIsVolatile
=
isVolatile
;
}
static
bool
IsLineDegenerate
(
const
SkPoint
&
p1
const
SkPoint
&
p2
bool
exact
)
{
return
exact
?
p1
=
=
p2
:
p1
.
equalsWithinTolerance
(
p2
)
;
}
static
bool
IsQuadDegenerate
(
const
SkPoint
&
p1
const
SkPoint
&
p2
const
SkPoint
&
p3
bool
exact
)
{
return
exact
?
p1
=
=
p2
&
&
p2
=
=
p3
:
p1
.
equalsWithinTolerance
(
p2
)
&
&
p2
.
equalsWithinTolerance
(
p3
)
;
}
static
bool
IsCubicDegenerate
(
const
SkPoint
&
p1
const
SkPoint
&
p2
const
SkPoint
&
p3
const
SkPoint
&
p4
bool
exact
)
{
return
exact
?
p1
=
=
p2
&
&
p2
=
=
p3
&
&
p3
=
=
p4
:
p1
.
equalsWithinTolerance
(
p2
)
&
&
p2
.
equalsWithinTolerance
(
p3
)
&
&
p3
.
equalsWithinTolerance
(
p4
)
;
}
bool
isLine
(
SkPoint
line
[
2
]
)
const
;
int
countPoints
(
)
const
;
SkPoint
getPoint
(
int
index
)
const
;
int
getPoints
(
SkPoint
points
[
]
int
max
)
const
;
int
countVerbs
(
)
const
;
int
getVerbs
(
uint8_t
verbs
[
]
int
max
)
const
;
void
swap
(
SkPath
&
other
)
;
const
SkRect
&
getBounds
(
)
const
{
return
fPathRef
-
>
getBounds
(
)
;
}
void
updateBoundsCache
(
)
const
{
this
-
>
getBounds
(
)
;
}
SkRect
computeTightBounds
(
)
const
;
bool
conservativelyContainsRect
(
const
SkRect
&
rect
)
const
;
void
incReserve
(
unsigned
extraPtCount
)
;
void
moveTo
(
SkScalar
x
SkScalar
y
)
;
void
moveTo
(
const
SkPoint
&
p
)
{
this
-
>
moveTo
(
p
.
fX
p
.
fY
)
;
}
void
rMoveTo
(
SkScalar
dx
SkScalar
dy
)
;
void
lineTo
(
SkScalar
x
SkScalar
y
)
;
void
lineTo
(
const
SkPoint
&
p
)
{
this
-
>
lineTo
(
p
.
fX
p
.
fY
)
;
}
void
rLineTo
(
SkScalar
dx
SkScalar
dy
)
;
void
quadTo
(
SkScalar
x1
SkScalar
y1
SkScalar
x2
SkScalar
y2
)
;
void
quadTo
(
const
SkPoint
&
p1
const
SkPoint
&
p2
)
{
this
-
>
quadTo
(
p1
.
fX
p1
.
fY
p2
.
fX
p2
.
fY
)
;
}
void
rQuadTo
(
SkScalar
dx1
SkScalar
dy1
SkScalar
dx2
SkScalar
dy2
)
;
void
conicTo
(
SkScalar
x1
SkScalar
y1
SkScalar
x2
SkScalar
y2
SkScalar
w
)
;
void
conicTo
(
const
SkPoint
&
p1
const
SkPoint
&
p2
SkScalar
w
)
{
this
-
>
conicTo
(
p1
.
fX
p1
.
fY
p2
.
fX
p2
.
fY
w
)
;
}
void
rConicTo
(
SkScalar
dx1
SkScalar
dy1
SkScalar
dx2
SkScalar
dy2
SkScalar
w
)
;
void
cubicTo
(
SkScalar
x1
SkScalar
y1
SkScalar
x2
SkScalar
y2
SkScalar
x3
SkScalar
y3
)
;
void
cubicTo
(
const
SkPoint
&
p1
const
SkPoint
&
p2
const
SkPoint
&
p3
)
{
this
-
>
cubicTo
(
p1
.
fX
p1
.
fY
p2
.
fX
p2
.
fY
p3
.
fX
p3
.
fY
)
;
}
void
rCubicTo
(
SkScalar
x1
SkScalar
y1
SkScalar
x2
SkScalar
y2
SkScalar
x3
SkScalar
y3
)
;
void
arcTo
(
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
bool
forceMoveTo
)
;
void
arcTo
(
SkScalar
x1
SkScalar
y1
SkScalar
x2
SkScalar
y2
SkScalar
radius
)
;
void
arcTo
(
const
SkPoint
p1
const
SkPoint
p2
SkScalar
radius
)
{
this
-
>
arcTo
(
p1
.
fX
p1
.
fY
p2
.
fX
p2
.
fY
radius
)
;
}
enum
ArcSize
{
kSmall_ArcSize
kLarge_ArcSize
}
;
void
arcTo
(
SkScalar
rx
SkScalar
ry
SkScalar
xAxisRotate
ArcSize
largeArc
Direction
sweep
SkScalar
x
SkScalar
y
)
;
void
arcTo
(
const
SkPoint
r
SkScalar
xAxisRotate
ArcSize
largeArc
Direction
sweep
const
SkPoint
xy
)
{
this
-
>
arcTo
(
r
.
fX
r
.
fY
xAxisRotate
largeArc
sweep
xy
.
fX
xy
.
fY
)
;
}
void
rArcTo
(
SkScalar
rx
SkScalar
ry
SkScalar
xAxisRotate
ArcSize
largeArc
Direction
sweep
SkScalar
dx
SkScalar
dy
)
;
void
close
(
)
;
static
bool
IsInverseFillType
(
FillType
fill
)
{
static_assert
(
0
=
=
kWinding_FillType
"
fill_type_mismatch
"
)
;
static_assert
(
1
=
=
kEvenOdd_FillType
"
fill_type_mismatch
"
)
;
static_assert
(
2
=
=
kInverseWinding_FillType
"
fill_type_mismatch
"
)
;
static_assert
(
3
=
=
kInverseEvenOdd_FillType
"
fill_type_mismatch
"
)
;
return
(
fill
&
2
)
!
=
0
;
}
static
FillType
ConvertToNonInverseFillType
(
FillType
fill
)
{
static_assert
(
0
=
=
kWinding_FillType
"
fill_type_mismatch
"
)
;
static_assert
(
1
=
=
kEvenOdd_FillType
"
fill_type_mismatch
"
)
;
static_assert
(
2
=
=
kInverseWinding_FillType
"
fill_type_mismatch
"
)
;
static_assert
(
3
=
=
kInverseEvenOdd_FillType
"
fill_type_mismatch
"
)
;
return
(
FillType
)
(
fill
&
1
)
;
}
static
int
ConvertConicToQuads
(
const
SkPoint
&
p0
const
SkPoint
&
p1
const
SkPoint
&
p2
SkScalar
w
SkPoint
pts
[
]
int
pow2
)
;
bool
isRect
(
SkRect
*
rect
bool
*
isClosed
=
NULL
Direction
*
direction
=
NULL
)
const
;
bool
isNestedFillRects
(
SkRect
rect
[
2
]
Direction
dirs
[
2
]
=
NULL
)
const
;
void
addRect
(
const
SkRect
&
rect
Direction
dir
=
kCW_Direction
)
;
void
addRect
(
const
SkRect
&
rect
Direction
dir
unsigned
start
)
;
void
addRect
(
SkScalar
left
SkScalar
top
SkScalar
right
SkScalar
bottom
Direction
dir
=
kCW_Direction
)
;
void
addOval
(
const
SkRect
&
oval
Direction
dir
=
kCW_Direction
)
;
void
addOval
(
const
SkRect
&
oval
Direction
dir
unsigned
start
)
;
void
addCircle
(
SkScalar
x
SkScalar
y
SkScalar
radius
Direction
dir
=
kCW_Direction
)
;
void
addArc
(
const
SkRect
&
oval
SkScalar
startAngle
SkScalar
sweepAngle
)
;
void
addRoundRect
(
const
SkRect
&
rect
SkScalar
rx
SkScalar
ry
Direction
dir
=
kCW_Direction
)
;
void
addRoundRect
(
const
SkRect
&
rect
const
SkScalar
radii
[
]
Direction
dir
=
kCW_Direction
)
;
void
addRRect
(
const
SkRRect
&
rrect
Direction
dir
=
kCW_Direction
)
;
void
addRRect
(
const
SkRRect
&
rrect
Direction
dir
unsigned
start
)
;
void
addPoly
(
const
SkPoint
pts
[
]
int
count
bool
close
)
;
enum
AddPathMode
{
kAppend_AddPathMode
kExtend_AddPathMode
}
;
void
addPath
(
const
SkPath
&
src
SkScalar
dx
SkScalar
dy
AddPathMode
mode
=
kAppend_AddPathMode
)
;
void
addPath
(
const
SkPath
&
src
AddPathMode
mode
=
kAppend_AddPathMode
)
{
SkMatrix
m
;
m
.
reset
(
)
;
this
-
>
addPath
(
src
m
mode
)
;
}
void
addPath
(
const
SkPath
&
src
const
SkMatrix
&
matrix
AddPathMode
mode
=
kAppend_AddPathMode
)
;
void
reverseAddPath
(
const
SkPath
&
src
)
;
void
offset
(
SkScalar
dx
SkScalar
dy
SkPath
*
dst
)
const
;
void
offset
(
SkScalar
dx
SkScalar
dy
)
{
this
-
>
offset
(
dx
dy
this
)
;
}
void
transform
(
const
SkMatrix
&
matrix
SkPath
*
dst
)
const
;
void
transform
(
const
SkMatrix
&
matrix
)
{
this
-
>
transform
(
matrix
this
)
;
}
bool
getLastPt
(
SkPoint
*
lastPt
)
const
;
void
setLastPt
(
SkScalar
x
SkScalar
y
)
;
void
setLastPt
(
const
SkPoint
&
p
)
{
this
-
>
setLastPt
(
p
.
fX
p
.
fY
)
;
}
enum
SegmentMask
{
kLine_SegmentMask
=
1
<
<
0
kQuad_SegmentMask
=
1
<
<
1
kConic_SegmentMask
=
1
<
<
2
kCubic_SegmentMask
=
1
<
<
3
}
;
uint32_t
getSegmentMasks
(
)
const
{
return
fPathRef
-
>
getSegmentMasks
(
)
;
}
enum
Verb
{
kMove_Verb
kLine_Verb
kQuad_Verb
kConic_Verb
kCubic_Verb
kClose_Verb
kDone_Verb
}
;
class
SK_API
Iter
{
public
:
Iter
(
)
;
Iter
(
const
SkPath
&
bool
forceClose
)
;
void
setPath
(
const
SkPath
&
bool
forceClose
)
;
Verb
next
(
SkPoint
pts
[
4
]
bool
doConsumeDegerates
=
true
bool
exact
=
false
)
{
if
(
doConsumeDegerates
)
{
this
-
>
consumeDegenerateSegments
(
exact
)
;
}
return
this
-
>
doNext
(
pts
)
;
}
SkScalar
conicWeight
(
)
const
{
return
*
fConicWeights
;
}
bool
isCloseLine
(
)
const
{
return
SkToBool
(
fCloseLine
)
;
}
bool
isClosedContour
(
)
const
;
private
:
const
SkPoint
*
fPts
;
const
uint8_t
*
fVerbs
;
const
uint8_t
*
fVerbStop
;
const
SkScalar
*
fConicWeights
;
SkPoint
fMoveTo
;
SkPoint
fLastPt
;
SkBool8
fForceClose
;
SkBool8
fNeedClose
;
SkBool8
fCloseLine
;
SkBool8
fSegmentState
;
inline
const
SkPoint
&
cons_moveTo
(
)
;
Verb
autoClose
(
SkPoint
pts
[
2
]
)
;
void
consumeDegenerateSegments
(
bool
exact
)
;
Verb
doNext
(
SkPoint
pts
[
4
]
)
;
}
;
class
SK_API
RawIter
{
public
:
RawIter
(
)
{
}
RawIter
(
const
SkPath
&
path
)
{
setPath
(
path
)
;
}
void
setPath
(
const
SkPath
&
path
)
{
fRawIter
.
setPathRef
(
*
path
.
fPathRef
.
get
(
)
)
;
}
Verb
next
(
SkPoint
pts
[
4
]
)
{
return
(
Verb
)
fRawIter
.
next
(
pts
)
;
}
Verb
peek
(
)
const
{
return
(
Verb
)
fRawIter
.
peek
(
)
;
}
SkScalar
conicWeight
(
)
const
{
return
fRawIter
.
conicWeight
(
)
;
}
private
:
SkPathRef
:
:
Iter
fRawIter
;
friend
class
SkPath
;
}
;
bool
contains
(
SkScalar
x
SkScalar
y
)
const
;
void
dump
(
SkWStream
*
bool
forceClose
bool
dumpAsHex
)
const
;
void
dump
(
)
const
;
void
dumpHex
(
)
const
;
size_t
writeToMemory
(
void
*
buffer
)
const
;
size_t
readFromMemory
(
const
void
*
buffer
size_t
length
)
;
uint32_t
getGenerationID
(
)
const
;
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
static
const
int
kPathRefGenIDBitCnt
=
30
;
#
else
static
const
int
kPathRefGenIDBitCnt
=
32
;
#
endif
SkDEBUGCODE
(
void
validate
(
)
const
;
)
SkDEBUGCODE
(
void
experimentalValidateRef
(
)
const
{
fPathRef
-
>
validate
(
)
;
}
)
private
:
enum
SerializationOffsets
{
kUnused1_SerializationShift
=
28
kDirection_SerializationShift
=
26
kIsVolatile_SerializationShift
=
25
kConvexity_SerializationShift
=
16
kFillType_SerializationShift
=
8
}
;
enum
SerializationVersions
{
kPathPrivFirstDirection_Version
=
1
kPathPrivLastMoveToIndex_Version
=
2
kCurrent_Version
=
2
}
;
sk_sp
<
SkPathRef
>
fPathRef
;
int
fLastMoveToIndex
;
uint8_t
fFillType
;
mutable
uint8_t
fConvexity
;
mutable
SkAtomic
<
uint8_t
sk_memory_order_relaxed
>
fFirstDirection
;
SkBool8
fIsVolatile
;
void
resetFields
(
)
;
void
copyFields
(
const
SkPath
&
that
)
;
friend
class
Iter
;
friend
class
SkPathPriv
;
friend
class
SkPathStroker
;
void
reversePathTo
(
const
SkPath
&
)
;
inline
void
injectMoveToIfNeeded
(
)
;
inline
bool
hasOnlyMoveTos
(
)
const
;
Convexity
internalGetConvexity
(
)
const
;
bool
isRectContour
(
bool
allowPartial
int
*
currVerb
const
SkPoint
*
*
pts
bool
*
isClosed
Direction
*
direction
)
const
;
bool
isZeroLength
(
)
const
;
bool
hasComputedBounds
(
)
const
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
return
fPathRef
-
>
hasComputedBounds
(
)
;
}
void
setBounds
(
const
SkRect
&
rect
)
{
SkPathRef
:
:
Editor
ed
(
&
fPathRef
)
;
ed
.
setBounds
(
rect
)
;
}
void
setPt
(
int
index
SkScalar
x
SkScalar
y
)
;
friend
class
SkAutoPathBoundsUpdate
;
friend
class
SkAutoDisableOvalCheck
;
friend
class
SkAutoDisableDirectionCheck
;
friend
class
SkPathWriter
;
friend
class
SkOpBuilder
;
friend
class
SkBench_AddPathTest
;
friend
class
PathTest_Private
;
friend
class
ForceIsRRect_Private
;
}
;
#
endif
