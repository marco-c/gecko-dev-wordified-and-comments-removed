#
ifndef
SkTypes_DEFINED
#
define
SkTypes_DEFINED
#
if
defined
(
MOZ_B2G
)
&
&
defined
(
__GNUC__
)
&
&
__GNUC__
=
=
4
typedef
float
float32_t
;
#
include
<
memory
>
#
endif
#
include
"
SkPreConfig
.
h
"
#
include
"
SkUserConfig
.
h
"
#
include
"
SkPostConfig
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
if
defined
(
SK_ARM_HAS_NEON
)
#
include
<
arm_neon
.
h
>
#
elif
SK_CPU_SSE_LEVEL
>
=
SK_CPU_SSE_LEVEL_SSE2
#
include
<
immintrin
.
h
>
#
endif
#
include
<
string
.
h
>
static
inline
void
*
sk_careful_memcpy
(
void
*
dst
const
void
*
src
size_t
len
)
{
if
(
len
)
{
memcpy
(
dst
src
len
)
;
}
return
dst
;
}
#
define
SKIA_VERSION_MAJOR
1
#
define
SKIA_VERSION_MINOR
0
#
define
SKIA_VERSION_PATCH
0
SK_API
extern
void
sk_out_of_memory
(
void
)
;
SK_API
extern
void
sk_abort_no_print
(
void
)
;
enum
{
SK_MALLOC_TEMP
=
0x01
SK_MALLOC_THROW
=
0x02
}
;
SK_API
extern
void
*
sk_malloc_flags
(
size_t
size
unsigned
flags
)
;
SK_API
extern
void
*
sk_malloc_throw
(
size_t
size
)
;
SK_API
extern
void
*
sk_realloc_throw
(
void
*
buffer
size_t
size
)
;
SK_API
extern
void
sk_free
(
void
*
)
;
SK_API
extern
void
*
sk_calloc
(
size_t
size
)
;
SK_API
extern
void
*
sk_calloc_throw
(
size_t
size
)
;
static
inline
void
sk_bzero
(
void
*
buffer
size_t
size
)
{
if
(
size
)
{
memset
(
buffer
0
size
)
;
}
}
#
ifdef
override_GLOBAL_NEW
#
include
<
new
>
inline
void
*
operator
new
(
size_t
size
)
{
return
sk_malloc_throw
(
size
)
;
}
inline
void
operator
delete
(
void
*
p
)
{
sk_free
(
p
)
;
}
#
endif
#
define
SK_INIT_TO_AVOID_WARNING
=
0
#
ifndef
SkDebugf
SK_API
void
SkDebugf
(
const
char
format
[
]
.
.
.
)
;
#
endif
#
define
SkASSERT_RELEASE
(
cond
)
if
(
!
(
cond
)
)
{
SK_ABORT
(
#
cond
)
;
}
#
ifdef
SK_DEBUG
#
define
SkASSERT
(
cond
)
SkASSERT_RELEASE
(
cond
)
#
define
SkDEBUGFAIL
(
message
)
SkASSERT
(
false
&
&
message
)
#
define
SkDEBUGFAILF
(
fmt
.
.
.
)
SkASSERTF
(
false
fmt
#
#
__VA_ARGS__
)
#
define
SkDEBUGCODE
(
code
)
code
#
define
SkDECLAREPARAM
(
type
var
)
type
var
#
define
SkPARAM
(
var
)
var
#
define
SkDEBUGF
(
args
)
SkDebugf
args
#
define
SkAssertResult
(
cond
)
SkASSERT
(
cond
)
#
else
#
define
SkASSERT
(
cond
)
#
define
SkDEBUGFAIL
(
message
)
#
define
SkDEBUGCODE
(
code
)
#
define
SkDEBUGF
(
args
)
#
define
SkDECLAREPARAM
(
type
var
)
#
define
SkPARAM
(
var
)
#
define
SkAssertResult
(
cond
)
cond
#
endif
#
define
SkFAIL
(
message
)
SK_ABORT
(
message
)
#
define
sk_throw
(
)
SK_ABORT
(
"
sk_throw
"
)
#
define
SkASSERTF
(
cond
fmt
.
.
.
)
SkASSERT
(
(
cond
)
|
|
(
SkDebugf
(
fmt
"
\
n
"
__VA_ARGS__
)
false
)
)
#
ifdef
SK_DEVELOPER
#
define
SkDEVCODE
(
code
)
code
#
else
#
define
SkDEVCODE
(
code
)
#
endif
#
ifdef
SK_IGNORE_TO_STRING
#
define
SK_TO_STRING_NONVIRT
(
)
#
define
SK_TO_STRING_VIRT
(
)
#
define
SK_TO_STRING_PUREVIRT
(
)
#
define
SK_TO_STRING_OVERRIDE
(
)
#
else
class
SkString
;
#
define
SK_TO_STRING_NONVIRT
(
)
void
toString
(
SkString
*
str
)
const
;
#
define
SK_TO_STRING_VIRT
(
)
virtual
void
toString
(
SkString
*
str
)
const
;
#
define
SK_TO_STRING_PUREVIRT
(
)
virtual
void
toString
(
SkString
*
str
)
const
=
0
;
#
define
SK_TO_STRING_OVERRIDE
(
)
void
toString
(
SkString
*
str
)
const
override
;
#
endif
#
define
SK_MACRO_CONCAT
(
X
Y
)
SK_MACRO_CONCAT_IMPL_PRIV
(
X
Y
)
#
define
SK_MACRO_CONCAT_IMPL_PRIV
(
X
Y
)
X
#
#
Y
#
define
SK_MACRO_APPEND_LINE
(
name
)
SK_MACRO_CONCAT
(
name
__LINE__
)
#
define
SK_REQUIRE_LOCAL_VAR
(
classname
)
\
static_assert
(
false
"
missing
name
for
"
#
classname
)
typedef
int
S8CPU
;
typedef
unsigned
U8CPU
;
typedef
int
S16CPU
;
typedef
unsigned
U16CPU
;
typedef
uint8_t
SkBool8
;
#
include
"
.
.
/
private
/
SkTFitsIn
.
h
"
template
<
typename
D
typename
S
>
D
SkTo
(
S
s
)
{
SkASSERT
(
SkTFitsIn
<
D
>
(
s
)
)
;
return
static_cast
<
D
>
(
s
)
;
}
#
define
SkToS8
(
x
)
SkTo
<
int8_t
>
(
x
)
#
define
SkToU8
(
x
)
SkTo
<
uint8_t
>
(
x
)
#
define
SkToS16
(
x
)
SkTo
<
int16_t
>
(
x
)
#
define
SkToU16
(
x
)
SkTo
<
uint16_t
>
(
x
)
#
define
SkToS32
(
x
)
SkTo
<
int32_t
>
(
x
)
#
define
SkToU32
(
x
)
SkTo
<
uint32_t
>
(
x
)
#
define
SkToInt
(
x
)
SkTo
<
int
>
(
x
)
#
define
SkToUInt
(
x
)
SkTo
<
unsigned
>
(
x
)
#
define
SkToSizeT
(
x
)
SkTo
<
size_t
>
(
x
)
#
define
SkToBool
(
cond
)
(
!
!
(
cond
)
)
#
define
SK_MaxS16
32767
#
define
SK_MinS16
-
32767
#
define
SK_MaxU16
0xFFFF
#
define
SK_MinU16
0
#
define
SK_MaxS32
0x7FFFFFFF
#
define
SK_MinS32
-
SK_MaxS32
#
define
SK_MaxU32
0xFFFFFFFF
#
define
SK_MinU32
0
#
define
SK_NaN32
(
(
int
)
(
1U
<
<
31
)
)
static
inline
bool
SkIsS16
(
long
x
)
{
return
(
int16_t
)
x
=
=
x
;
}
static
inline
bool
SkIsU16
(
long
x
)
{
return
(
uint16_t
)
x
=
=
x
;
}
static
inline
int32_t
SkLeftShift
(
int32_t
value
int32_t
shift
)
{
return
(
int32_t
)
(
(
uint32_t
)
value
<
<
shift
)
;
}
static
inline
int64_t
SkLeftShift
(
int64_t
value
int32_t
shift
)
{
return
(
int64_t
)
(
(
uint64_t
)
value
<
<
shift
)
;
}
template
<
typename
T
size_t
N
>
char
(
&
SkArrayCountHelper
(
T
(
&
array
)
[
N
]
)
)
[
N
]
;
#
define
SK_ARRAY_COUNT
(
array
)
(
sizeof
(
SkArrayCountHelper
(
array
)
)
)
#
if
defined
(
__clang__
)
#
define
SK_BEGIN_REQUIRE_DENSE
_Pragma
(
"
GCC
diagnostic
push
"
)
\
_Pragma
(
"
GCC
diagnostic
error
\
"
-
Wpadded
\
"
"
)
#
define
SK_END_REQUIRE_DENSE
_Pragma
(
"
GCC
diagnostic
pop
"
)
#
else
#
define
SK_BEGIN_REQUIRE_DENSE
#
define
SK_END_REQUIRE_DENSE
#
endif
#
define
SkAlign2
(
x
)
(
(
(
x
)
+
1
)
>
>
1
<
<
1
)
#
define
SkIsAlign2
(
x
)
(
0
=
=
(
(
x
)
&
1
)
)
#
define
SkAlign4
(
x
)
(
(
(
x
)
+
3
)
>
>
2
<
<
2
)
#
define
SkIsAlign4
(
x
)
(
0
=
=
(
(
x
)
&
3
)
)
#
define
SkAlign8
(
x
)
(
(
(
x
)
+
7
)
>
>
3
<
<
3
)
#
define
SkIsAlign8
(
x
)
(
0
=
=
(
(
x
)
&
7
)
)
#
define
SkAlign16
(
x
)
(
(
(
x
)
+
15
)
>
>
4
<
<
4
)
#
define
SkIsAlign16
(
x
)
(
0
=
=
(
(
x
)
&
15
)
)
#
define
SkAlignPtr
(
x
)
(
sizeof
(
void
*
)
=
=
8
?
SkAlign8
(
x
)
:
SkAlign4
(
x
)
)
#
define
SkIsAlignPtr
(
x
)
(
sizeof
(
void
*
)
=
=
8
?
SkIsAlign8
(
x
)
:
SkIsAlign4
(
x
)
)
typedef
uint32_t
SkFourByteTag
;
#
define
SkSetFourByteTag
(
a
b
c
d
)
(
(
(
a
)
<
<
24
)
|
(
(
b
)
<
<
16
)
|
(
(
c
)
<
<
8
)
|
(
d
)
)
typedef
int32_t
SkUnichar
;
typedef
uint32_t
SkMSec
;
#
define
SK_MSec1
1000
#
define
SK_MSecMax
0x7FFFFFFF
#
define
SkMSec_LT
(
a
b
)
(
(
int32_t
)
(
a
)
-
(
int32_t
)
(
b
)
<
0
)
#
define
SkMSec_LE
(
a
b
)
(
(
int32_t
)
(
a
)
-
(
int32_t
)
(
b
)
<
=
0
)
#
define
SK_InvalidGenID
0
#
define
SK_InvalidUniqueID
0
#
ifdef
__cplusplus
static
inline
int
Sk32ToBool
(
uint32_t
n
)
{
return
(
n
|
(
0
-
n
)
)
>
>
31
;
}
template
<
typename
T
>
inline
void
SkTSwap
(
T
&
a
T
&
b
)
{
T
c
(
a
)
;
a
=
b
;
b
=
c
;
}
static
inline
int32_t
SkAbs32
(
int32_t
value
)
{
SkASSERT
(
value
!
=
SK_NaN32
)
;
if
(
value
<
0
)
{
value
=
-
value
;
}
return
value
;
}
template
<
typename
T
>
inline
T
SkTAbs
(
T
value
)
{
if
(
value
<
0
)
{
value
=
-
value
;
}
return
value
;
}
static
inline
int32_t
SkMax32
(
int32_t
a
int32_t
b
)
{
if
(
a
<
b
)
a
=
b
;
return
a
;
}
static
inline
int32_t
SkMin32
(
int32_t
a
int32_t
b
)
{
if
(
a
>
b
)
a
=
b
;
return
a
;
}
template
<
typename
T
>
const
T
&
SkTMin
(
const
T
&
a
const
T
&
b
)
{
return
(
a
<
b
)
?
a
:
b
;
}
template
<
typename
T
>
const
T
&
SkTMax
(
const
T
&
a
const
T
&
b
)
{
return
(
b
<
a
)
?
a
:
b
;
}
static
inline
int32_t
SkSign32
(
int32_t
a
)
{
return
(
a
>
>
31
)
|
(
(
unsigned
)
-
a
>
>
31
)
;
}
static
inline
int32_t
SkFastMin32
(
int32_t
value
int32_t
max
)
{
if
(
value
>
max
)
{
value
=
max
;
}
return
value
;
}
template
<
typename
T
>
static
inline
const
T
&
SkTPin
(
const
T
&
value
const
T
&
min
const
T
&
max
)
{
return
SkTMax
(
SkTMin
(
value
max
)
min
)
;
}
enum
class
SkBudgeted
:
bool
{
kNo
=
false
kYes
=
true
}
;
template
<
typename
T
>
T
SkTBitOr
(
T
a
T
b
)
{
return
(
T
)
(
a
|
b
)
;
}
template
<
typename
Dst
>
Dst
SkTCast
(
const
void
*
ptr
)
{
union
{
const
void
*
src
;
Dst
dst
;
}
data
;
data
.
src
=
ptr
;
return
data
.
dst
;
}
class
SK_API
SkNoncopyable
{
public
:
SkNoncopyable
(
)
{
}
private
:
SkNoncopyable
(
const
SkNoncopyable
&
)
;
SkNoncopyable
&
operator
=
(
const
SkNoncopyable
&
)
;
}
;
class
SkAutoFree
:
SkNoncopyable
{
public
:
SkAutoFree
(
)
:
fPtr
(
NULL
)
{
}
explicit
SkAutoFree
(
void
*
ptr
)
:
fPtr
(
ptr
)
{
}
~
SkAutoFree
(
)
{
sk_free
(
fPtr
)
;
}
void
*
get
(
)
const
{
return
fPtr
;
}
void
*
set
(
void
*
ptr
)
{
void
*
prev
=
fPtr
;
fPtr
=
ptr
;
return
prev
;
}
void
*
release
(
)
{
return
this
-
>
set
(
NULL
)
;
}
void
reset
(
)
{
sk_free
(
fPtr
)
;
fPtr
=
NULL
;
}
private
:
void
*
fPtr
;
SkAutoFree
(
const
SkAutoFree
&
)
;
SkAutoFree
&
operator
=
(
const
SkAutoFree
&
)
;
}
;
#
define
SkAutoFree
(
.
.
.
)
SK_REQUIRE_LOCAL_VAR
(
SkAutoFree
)
class
SkAutoMalloc
:
SkNoncopyable
{
public
:
explicit
SkAutoMalloc
(
size_t
size
=
0
)
{
fPtr
=
size
?
sk_malloc_throw
(
size
)
:
NULL
;
fSize
=
size
;
}
~
SkAutoMalloc
(
)
{
sk_free
(
fPtr
)
;
}
enum
OnShrink
{
kAlloc_OnShrink
kReuse_OnShrink
}
;
void
*
reset
(
size_t
size
=
0
OnShrink
shrink
=
kAlloc_OnShrink
bool
*
didChangeAlloc
=
NULL
)
{
if
(
size
=
=
fSize
|
|
(
kReuse_OnShrink
=
=
shrink
&
&
size
<
fSize
)
)
{
if
(
didChangeAlloc
)
{
*
didChangeAlloc
=
false
;
}
return
fPtr
;
}
sk_free
(
fPtr
)
;
fPtr
=
size
?
sk_malloc_throw
(
size
)
:
NULL
;
fSize
=
size
;
if
(
didChangeAlloc
)
{
*
didChangeAlloc
=
true
;
}
return
fPtr
;
}
void
*
get
(
)
{
return
fPtr
;
}
const
void
*
get
(
)
const
{
return
fPtr
;
}
void
*
release
(
)
{
void
*
ptr
=
fPtr
;
fPtr
=
NULL
;
fSize
=
0
;
return
ptr
;
}
private
:
void
*
fPtr
;
size_t
fSize
;
}
;
#
define
SkAutoMalloc
(
.
.
.
)
SK_REQUIRE_LOCAL_VAR
(
SkAutoMalloc
)
template
<
size_t
kSizeRequested
>
class
SkAutoSMalloc
:
SkNoncopyable
{
public
:
SkAutoSMalloc
(
)
{
fPtr
=
fStorage
;
fSize
=
kSize
;
}
explicit
SkAutoSMalloc
(
size_t
size
)
{
fPtr
=
fStorage
;
fSize
=
kSize
;
this
-
>
reset
(
size
)
;
}
~
SkAutoSMalloc
(
)
{
if
(
fPtr
!
=
(
void
*
)
fStorage
)
{
sk_free
(
fPtr
)
;
}
}
void
*
get
(
)
const
{
return
fPtr
;
}
void
*
reset
(
size_t
size
SkAutoMalloc
:
:
OnShrink
shrink
=
SkAutoMalloc
:
:
kAlloc_OnShrink
bool
*
didChangeAlloc
=
NULL
)
{
size
=
(
size
<
kSize
)
?
kSize
:
size
;
bool
alloc
=
size
!
=
fSize
&
&
(
SkAutoMalloc
:
:
kAlloc_OnShrink
=
=
shrink
|
|
size
>
fSize
)
;
if
(
didChangeAlloc
)
{
*
didChangeAlloc
=
alloc
;
}
if
(
alloc
)
{
if
(
fPtr
!
=
(
void
*
)
fStorage
)
{
sk_free
(
fPtr
)
;
}
if
(
size
=
=
kSize
)
{
SkASSERT
(
fPtr
!
=
fStorage
)
;
fPtr
=
fStorage
;
}
else
{
fPtr
=
sk_malloc_flags
(
size
SK_MALLOC_THROW
|
SK_MALLOC_TEMP
)
;
}
fSize
=
size
;
}
SkASSERT
(
fSize
>
=
size
&
&
fSize
>
=
kSize
)
;
SkASSERT
(
(
fPtr
=
=
fStorage
)
|
|
fSize
>
kSize
)
;
return
fPtr
;
}
private
:
static
const
size_t
kSizeAlign4
=
SkAlign4
(
kSizeRequested
)
;
#
if
defined
(
GOOGLE3
)
static
const
size_t
kMaxBytes
=
4
*
1024
;
static
const
size_t
kSize
=
kSizeRequested
>
kMaxBytes
?
kMaxBytes
:
kSizeAlign4
;
#
else
static
const
size_t
kSize
=
kSizeAlign4
;
#
endif
void
*
fPtr
;
size_t
fSize
;
uint32_t
fStorage
[
kSize
>
>
2
]
;
}
;
#
endif
#
endif
