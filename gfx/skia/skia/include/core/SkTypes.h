#
ifndef
SkTypes_DEFINED
#
define
SkTypes_DEFINED
#
include
"
include
/
core
/
SkPreConfig
.
h
"
#
if
defined
(
SK_USER_CONFIG_HEADER
)
#
include
SK_USER_CONFIG_HEADER
#
else
#
include
"
include
/
config
/
SkUserConfig
.
h
"
#
endif
#
include
"
include
/
core
/
SkPostConfig
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
SK_API
extern
void
sk_abort_no_print
(
void
)
;
SK_API
extern
bool
sk_abort_is_enabled
(
)
;
#
ifndef
SkDebugf
SK_API
void
SkDebugf
(
const
char
format
[
]
.
.
.
)
;
#
endif
#
define
SkASSERT_RELEASE
(
cond
)
\
static_cast
<
void
>
(
(
cond
)
?
(
void
)
0
:
[
]
{
SK_ABORT
(
"
assert
(
"
#
cond
"
)
"
)
;
}
(
)
)
#
ifdef
SK_DEBUG
#
define
SkASSERT
(
cond
)
SkASSERT_RELEASE
(
cond
)
#
define
SkASSERTF
(
cond
fmt
.
.
.
)
static_cast
<
void
>
(
(
cond
)
?
(
void
)
0
:
[
&
]
{
\
SkDebugf
(
fmt
"
\
n
"
__VA_ARGS__
)
;
\
SK_ABORT
(
"
assert
(
"
#
cond
"
)
"
)
;
\
}
(
)
)
#
define
SkDEBUGFAIL
(
message
)
SK_ABORT
(
message
)
#
define
SkDEBUGFAILF
(
fmt
.
.
.
)
SkASSERTF
(
false
fmt
#
#
__VA_ARGS__
)
#
define
SkDEBUGCODE
(
.
.
.
)
__VA_ARGS__
#
define
SkDEBUGF
(
.
.
.
)
SkDebugf
(
__VA_ARGS__
)
#
define
SkAssertResult
(
cond
)
SkASSERT
(
cond
)
#
else
#
define
SkASSERT
(
cond
)
static_cast
<
void
>
(
0
)
#
define
SkASSERTF
(
cond
fmt
.
.
.
)
static_cast
<
void
>
(
0
)
#
define
SkDEBUGFAIL
(
message
)
#
define
SkDEBUGFAILF
(
fmt
.
.
.
)
#
define
SkDEBUGCODE
(
.
.
.
)
#
define
SkDEBUGF
(
.
.
.
)
#
define
SkAssertResult
(
cond
)
if
(
cond
)
{
}
do
{
}
while
(
false
)
#
endif
typedef
unsigned
U8CPU
;
typedef
unsigned
U16CPU
;
template
<
typename
T
>
static
constexpr
bool
SkToBool
(
const
T
&
x
)
{
return
0
!
=
x
;
}
static
constexpr
int16_t
SK_MaxS16
=
INT16_MAX
;
static
constexpr
int16_t
SK_MinS16
=
-
SK_MaxS16
;
static
constexpr
int32_t
SK_MaxS32
=
INT32_MAX
;
static
constexpr
int32_t
SK_MinS32
=
-
SK_MaxS32
;
static
constexpr
int32_t
SK_NaN32
=
INT32_MIN
;
static
constexpr
int64_t
SK_MaxS64
=
INT64_MAX
;
static
constexpr
int64_t
SK_MinS64
=
-
SK_MaxS64
;
static
inline
constexpr
int32_t
SkLeftShift
(
int32_t
value
int32_t
shift
)
{
return
(
int32_t
)
(
(
uint32_t
)
value
<
<
shift
)
;
}
static
inline
constexpr
int64_t
SkLeftShift
(
int64_t
value
int32_t
shift
)
{
return
(
int64_t
)
(
(
uint64_t
)
value
<
<
shift
)
;
}
template
<
typename
T
size_t
N
>
char
(
&
SkArrayCountHelper
(
T
(
&
array
)
[
N
]
)
)
[
N
]
;
#
define
SK_ARRAY_COUNT
(
array
)
(
sizeof
(
SkArrayCountHelper
(
array
)
)
)
template
<
typename
T
>
static
constexpr
T
SkAlign2
(
T
x
)
{
return
(
x
+
1
)
>
>
1
<
<
1
;
}
template
<
typename
T
>
static
constexpr
T
SkAlign4
(
T
x
)
{
return
(
x
+
3
)
>
>
2
<
<
2
;
}
template
<
typename
T
>
static
constexpr
T
SkAlign8
(
T
x
)
{
return
(
x
+
7
)
>
>
3
<
<
3
;
}
template
<
typename
T
>
static
constexpr
bool
SkIsAlign2
(
T
x
)
{
return
0
=
=
(
x
&
1
)
;
}
template
<
typename
T
>
static
constexpr
bool
SkIsAlign4
(
T
x
)
{
return
0
=
=
(
x
&
3
)
;
}
template
<
typename
T
>
static
constexpr
bool
SkIsAlign8
(
T
x
)
{
return
0
=
=
(
x
&
7
)
;
}
template
<
typename
T
>
static
constexpr
T
SkAlignPtr
(
T
x
)
{
return
sizeof
(
void
*
)
=
=
8
?
SkAlign8
(
x
)
:
SkAlign4
(
x
)
;
}
template
<
typename
T
>
static
constexpr
bool
SkIsAlignPtr
(
T
x
)
{
return
sizeof
(
void
*
)
=
=
8
?
SkIsAlign8
(
x
)
:
SkIsAlign4
(
x
)
;
}
typedef
uint32_t
SkFourByteTag
;
static
inline
constexpr
SkFourByteTag
SkSetFourByteTag
(
char
a
char
b
char
c
char
d
)
{
return
(
(
(
uint8_t
)
a
<
<
24
)
|
(
(
uint8_t
)
b
<
<
16
)
|
(
(
uint8_t
)
c
<
<
8
)
|
(
uint8_t
)
d
)
;
}
typedef
int32_t
SkUnichar
;
typedef
uint16_t
SkGlyphID
;
typedef
uint32_t
SkMSec
;
static
constexpr
SkMSec
SK_MSecMax
=
INT32_MAX
;
static
constexpr
uint32_t
SK_InvalidGenID
=
0
;
static
constexpr
uint32_t
SK_InvalidUniqueID
=
0
;
static
inline
int32_t
SkAbs32
(
int32_t
value
)
{
SkASSERT
(
value
!
=
SK_NaN32
)
;
if
(
value
<
0
)
{
value
=
-
value
;
}
return
value
;
}
template
<
typename
T
>
static
inline
T
SkTAbs
(
T
value
)
{
if
(
value
<
0
)
{
value
=
-
value
;
}
return
value
;
}
static
inline
int32_t
SkMax32
(
int32_t
a
int32_t
b
)
{
if
(
a
<
b
)
a
=
b
;
return
a
;
}
static
inline
int32_t
SkMin32
(
int32_t
a
int32_t
b
)
{
if
(
a
>
b
)
a
=
b
;
return
a
;
}
template
<
typename
T
>
constexpr
const
T
&
SkTMin
(
const
T
&
a
const
T
&
b
)
{
return
(
a
<
b
)
?
a
:
b
;
}
template
<
typename
T
>
constexpr
const
T
&
SkTMax
(
const
T
&
a
const
T
&
b
)
{
return
(
b
<
a
)
?
a
:
b
;
}
template
<
typename
T
>
constexpr
const
T
&
SkTClamp
(
const
T
&
x
const
T
&
lo
const
T
&
hi
)
{
return
(
x
<
lo
)
?
lo
:
SkTMin
(
x
hi
)
;
}
template
<
typename
T
>
static
constexpr
const
T
&
SkTPin
(
const
T
&
value
const
T
&
min
const
T
&
max
)
{
return
SkTMax
(
SkTMin
(
value
max
)
min
)
;
}
enum
class
SkBudgeted
:
bool
{
kNo
=
false
kYes
=
true
}
;
enum
class
SkBackingFit
{
kApprox
kExact
}
;
#
endif
