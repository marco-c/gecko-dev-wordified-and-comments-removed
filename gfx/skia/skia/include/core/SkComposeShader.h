#
ifndef
SkComposeShader_DEFINED
#
define
SkComposeShader_DEFINED
#
include
"
SkShader
.
h
"
class
SkXfermode
;
class
SK_API
SkComposeShader
:
public
SkShader
{
public
:
SkComposeShader
(
SkShader
*
sA
SkShader
*
sB
SkXfermode
*
mode
=
NULL
)
;
virtual
~
SkComposeShader
(
)
;
size_t
contextSize
(
)
const
override
;
#
if
SK_SUPPORT_GPU
const
GrFragmentProcessor
*
asFragmentProcessor
(
GrContext
*
const
SkMatrix
&
viewM
const
SkMatrix
*
localMatrix
SkFilterQuality
)
const
override
;
#
endif
class
ComposeShaderContext
:
public
SkShader
:
:
Context
{
public
:
ComposeShaderContext
(
const
SkComposeShader
&
const
ContextRec
&
SkShader
:
:
Context
*
contextA
SkShader
:
:
Context
*
contextB
)
;
SkShader
:
:
Context
*
getShaderContextA
(
)
const
{
return
fShaderContextA
;
}
SkShader
:
:
Context
*
getShaderContextB
(
)
const
{
return
fShaderContextB
;
}
virtual
~
ComposeShaderContext
(
)
;
void
shadeSpan
(
int
x
int
y
SkPMColor
[
]
int
count
)
override
;
private
:
SkShader
:
:
Context
*
fShaderContextA
;
SkShader
:
:
Context
*
fShaderContextB
;
typedef
SkShader
:
:
Context
INHERITED
;
}
;
#
ifdef
SK_DEBUG
SkShader
*
getShaderA
(
)
{
return
fShaderA
;
}
SkShader
*
getShaderB
(
)
{
return
fShaderB
;
}
#
endif
bool
asACompose
(
ComposeRec
*
rec
)
const
override
;
SK_TO_STRING_OVERRIDE
(
)
SK_DECLARE_PUBLIC_FLATTENABLE_DESERIALIZATION_PROCS
(
SkComposeShader
)
protected
:
SkComposeShader
(
SkReadBuffer
&
)
;
void
flatten
(
SkWriteBuffer
&
)
const
override
;
Context
*
onCreateContext
(
const
ContextRec
&
void
*
)
const
override
;
private
:
SkShader
*
fShaderA
;
SkShader
*
fShaderB
;
SkXfermode
*
fMode
;
typedef
SkShader
INHERITED
;
}
;
#
endif
