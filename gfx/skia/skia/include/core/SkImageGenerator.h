#
ifndef
SkImageGenerator_DEFINED
#
define
SkImageGenerator_DEFINED
#
include
"
SkBitmap
.
h
"
#
include
"
SkColor
.
h
"
#
include
"
SkImageInfo
.
h
"
#
include
"
SkYUVSizeInfo
.
h
"
class
GrContext
;
class
GrTexture
;
class
GrTextureParams
;
class
SkBitmap
;
class
SkData
;
class
SkImageGenerator
;
class
SkMatrix
;
class
SkPaint
;
class
SkPicture
;
#
ifdef
SK_SUPPORT_LEGACY_REFENCODEDDATA_NOCTX
#
define
SK_REFENCODEDDATA_CTXPARAM
#
else
#
define
SK_REFENCODEDDATA_CTXPARAM
GrContext
*
ctx
#
endif
SK_API
bool
SkDEPRECATED_InstallDiscardablePixelRef
(
SkImageGenerator
*
SkBitmap
*
destination
)
;
SK_API
bool
SkDEPRECATED_InstallDiscardablePixelRef
(
SkData
*
encoded
SkBitmap
*
destination
)
;
class
SK_API
SkImageGenerator
:
public
SkNoncopyable
{
public
:
virtual
~
SkImageGenerator
(
)
{
}
uint32_t
uniqueID
(
)
const
{
return
fUniqueID
;
}
SkData
*
refEncodedData
(
GrContext
*
ctx
=
nullptr
)
{
#
ifdef
SK_SUPPORT_LEGACY_REFENCODEDDATA_NOCTX
return
this
-
>
onRefEncodedData
(
)
;
#
else
return
this
-
>
onRefEncodedData
(
ctx
)
;
#
endif
}
const
SkImageInfo
&
getInfo
(
)
const
{
return
fInfo
;
}
bool
getPixels
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
SkPMColor
ctable
[
]
int
*
ctableCount
)
;
bool
getPixels
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
)
;
bool
queryYUV8
(
SkYUVSizeInfo
*
sizeInfo
SkYUVColorSpace
*
colorSpace
)
const
;
bool
getYUV8Planes
(
const
SkYUVSizeInfo
&
sizeInfo
void
*
planes
[
3
]
)
;
GrTexture
*
generateTexture
(
GrContext
*
const
SkIRect
*
subset
=
nullptr
)
;
struct
SupportedSizes
{
SkISize
fSizes
[
2
]
;
}
;
bool
computeScaledDimensions
(
SkScalar
scale
SupportedSizes
*
)
;
bool
generateScaledPixels
(
const
SkISize
&
scaledSize
const
SkIPoint
&
subsetOrigin
const
SkPixmap
&
subsetPixels
)
;
bool
generateScaledPixels
(
const
SkPixmap
&
scaledPixels
)
{
return
this
-
>
generateScaledPixels
(
SkISize
:
:
Make
(
scaledPixels
.
width
(
)
scaledPixels
.
height
(
)
)
SkIPoint
:
:
Make
(
0
0
)
scaledPixels
)
;
}
static
SkImageGenerator
*
NewFromEncoded
(
SkData
*
)
;
static
SkImageGenerator
*
NewFromPicture
(
const
SkISize
&
const
SkPicture
*
const
SkMatrix
*
const
SkPaint
*
)
;
bool
tryGenerateBitmap
(
SkBitmap
*
bm
)
{
return
this
-
>
tryGenerateBitmap
(
bm
nullptr
nullptr
)
;
}
bool
tryGenerateBitmap
(
SkBitmap
*
bm
const
SkImageInfo
&
info
SkBitmap
:
:
Allocator
*
allocator
)
{
return
this
-
>
tryGenerateBitmap
(
bm
&
info
allocator
)
;
}
void
generateBitmap
(
SkBitmap
*
bm
)
{
if
(
!
this
-
>
tryGenerateBitmap
(
bm
nullptr
nullptr
)
)
{
sk_throw
(
)
;
}
}
void
generateBitmap
(
SkBitmap
*
bm
const
SkImageInfo
&
info
)
{
if
(
!
this
-
>
tryGenerateBitmap
(
bm
&
info
nullptr
)
)
{
sk_throw
(
)
;
}
}
protected
:
SkImageGenerator
(
const
SkImageInfo
&
info
)
;
virtual
SkData
*
onRefEncodedData
(
SK_REFENCODEDDATA_CTXPARAM
)
;
virtual
bool
onGetPixels
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
SkPMColor
ctable
[
]
int
*
ctableCount
)
;
virtual
bool
onQueryYUV8
(
SkYUVSizeInfo
*
SkYUVColorSpace
*
)
const
{
return
false
;
}
virtual
bool
onGetYUV8Planes
(
const
SkYUVSizeInfo
&
void
*
[
3
]
)
{
return
false
;
}
virtual
GrTexture
*
onGenerateTexture
(
GrContext
*
const
SkIRect
*
)
{
return
nullptr
;
}
virtual
bool
onComputeScaledDimensions
(
SkScalar
SupportedSizes
*
)
{
return
false
;
}
virtual
bool
onGenerateScaledPixels
(
const
SkISize
&
const
SkIPoint
&
const
SkPixmap
&
)
{
return
false
;
}
bool
tryGenerateBitmap
(
SkBitmap
*
bm
const
SkImageInfo
*
optionalInfo
SkBitmap
:
:
Allocator
*
)
;
private
:
const
SkImageInfo
fInfo
;
const
uint32_t
fUniqueID
;
static
SkImageGenerator
*
NewFromEncodedImpl
(
SkData
*
)
;
}
;
#
endif
