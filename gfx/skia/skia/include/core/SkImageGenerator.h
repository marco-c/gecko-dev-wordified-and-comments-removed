#
ifndef
SkImageGenerator_DEFINED
#
define
SkImageGenerator_DEFINED
#
include
"
SkBitmap
.
h
"
#
include
"
SkColor
.
h
"
#
include
"
SkImage
.
h
"
#
include
"
SkImageInfo
.
h
"
#
include
"
SkYUVSizeInfo
.
h
"
class
GrContext
;
class
GrContextThreadSafeProxy
;
class
GrTextureProxy
;
class
GrSamplerParams
;
class
SkBitmap
;
class
SkData
;
class
SkMatrix
;
class
SkPaint
;
class
SkPicture
;
class
SK_API
SkImageGenerator
:
public
SkNoncopyable
{
public
:
virtual
~
SkImageGenerator
(
)
{
}
uint32_t
uniqueID
(
)
const
{
return
fUniqueID
;
}
SkData
*
refEncodedData
(
GrContext
*
ctx
=
nullptr
)
{
return
this
-
>
onRefEncodedData
(
ctx
)
;
}
const
SkImageInfo
&
getInfo
(
)
const
{
return
fInfo
;
}
bool
getPixels
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
SkPMColor
ctable
[
]
int
*
ctableCount
)
;
bool
getPixels
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
)
;
bool
queryYUV8
(
SkYUVSizeInfo
*
sizeInfo
SkYUVColorSpace
*
colorSpace
)
const
;
bool
getYUV8Planes
(
const
SkYUVSizeInfo
&
sizeInfo
void
*
planes
[
3
]
)
;
#
if
SK_SUPPORT_GPU
sk_sp
<
GrTextureProxy
>
generateTexture
(
GrContext
*
const
SkImageInfo
&
info
const
SkIPoint
&
origin
)
;
#
endif
static
std
:
:
unique_ptr
<
SkImageGenerator
>
MakeFromEncoded
(
sk_sp
<
SkData
>
)
;
static
std
:
:
unique_ptr
<
SkImageGenerator
>
MakeFromPicture
(
const
SkISize
&
sk_sp
<
SkPicture
>
const
SkMatrix
*
const
SkPaint
*
SkImage
:
:
BitDepth
sk_sp
<
SkColorSpace
>
)
;
protected
:
enum
{
kNeedNewImageUniqueID
=
0
}
;
SkImageGenerator
(
const
SkImageInfo
&
info
uint32_t
uniqueId
=
kNeedNewImageUniqueID
)
;
virtual
SkData
*
onRefEncodedData
(
GrContext
*
ctx
)
;
virtual
bool
onGetPixels
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
SkPMColor
ctable
[
]
int
*
ctableCount
)
;
virtual
bool
onQueryYUV8
(
SkYUVSizeInfo
*
SkYUVColorSpace
*
)
const
{
return
false
;
}
virtual
bool
onGetYUV8Planes
(
const
SkYUVSizeInfo
&
void
*
[
3
]
)
{
return
false
;
}
struct
Options
{
Options
(
)
:
fColorTable
(
nullptr
)
fColorTableCount
(
nullptr
)
fBehavior
(
SkTransferFunctionBehavior
:
:
kRespect
)
{
}
SkPMColor
*
fColorTable
;
int
*
fColorTableCount
;
SkTransferFunctionBehavior
fBehavior
;
}
;
bool
getPixels
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
const
Options
*
opts
)
;
virtual
bool
onGetPixels
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
const
Options
&
opts
)
{
return
this
-
>
onGetPixels
(
info
pixels
rowBytes
opts
.
fColorTable
opts
.
fColorTableCount
)
;
}
#
if
SK_SUPPORT_GPU
virtual
sk_sp
<
GrTextureProxy
>
onGenerateTexture
(
GrContext
*
const
SkImageInfo
&
const
SkIPoint
&
)
;
#
endif
private
:
const
SkImageInfo
fInfo
;
const
uint32_t
fUniqueID
;
friend
class
SkImageCacherator
;
static
std
:
:
unique_ptr
<
SkImageGenerator
>
MakeFromEncodedImpl
(
sk_sp
<
SkData
>
)
;
}
;
#
endif
