#
ifndef
SkRefCnt_DEFINED
#
define
SkRefCnt_DEFINED
#
include
"
.
.
/
private
/
SkTLogic
.
h
"
#
include
"
SkTypes
.
h
"
#
include
<
atomic
>
#
include
<
functional
>
#
include
<
memory
>
#
include
<
type_traits
>
#
include
<
utility
>
class
SK_API
SkRefCntBase
:
SkNoncopyable
{
public
:
SkRefCntBase
(
)
:
fRefCnt
(
1
)
{
}
virtual
~
SkRefCntBase
(
)
{
#
ifdef
SK_DEBUG
SkASSERTF
(
getRefCnt
(
)
=
=
1
"
fRefCnt
was
%
d
"
getRefCnt
(
)
)
;
fRefCnt
.
store
(
0
std
:
:
memory_order_relaxed
)
;
#
endif
}
int32_t
getRefCnt
(
)
const
{
return
fRefCnt
.
load
(
std
:
:
memory_order_relaxed
)
;
}
#
ifdef
SK_DEBUG
void
validate
(
)
const
{
SkASSERT
(
getRefCnt
(
)
>
0
)
;
}
#
endif
bool
unique
(
)
const
{
if
(
1
=
=
fRefCnt
.
load
(
std
:
:
memory_order_acquire
)
)
{
return
true
;
}
return
false
;
}
void
ref
(
)
const
{
SkASSERT
(
getRefCnt
(
)
>
0
)
;
(
void
)
fRefCnt
.
fetch_add
(
+
1
std
:
:
memory_order_relaxed
)
;
}
void
unref
(
)
const
{
SkASSERT
(
getRefCnt
(
)
>
0
)
;
if
(
1
=
=
fRefCnt
.
fetch_add
(
-
1
std
:
:
memory_order_acq_rel
)
)
{
this
-
>
internal_dispose
(
)
;
}
}
protected
:
void
internal_dispose_restore_refcnt_to_1
(
)
const
{
SkASSERT
(
0
=
=
getRefCnt
(
)
)
;
fRefCnt
.
store
(
1
std
:
:
memory_order_relaxed
)
;
}
private
:
virtual
void
internal_dispose
(
)
const
{
this
-
>
internal_dispose_restore_refcnt_to_1
(
)
;
delete
this
;
}
friend
class
SkWeakRefCnt
;
mutable
std
:
:
atomic
<
int32_t
>
fRefCnt
;
typedef
SkNoncopyable
INHERITED
;
}
;
#
ifdef
SK_REF_CNT_MIXIN_INCLUDE
#
include
SK_REF_CNT_MIXIN_INCLUDE
#
else
class
SK_API
SkRefCnt
:
public
SkRefCntBase
{
#
if
defined
(
GOOGLE3
)
public
:
void
deref
(
)
const
{
this
-
>
unref
(
)
;
}
#
endif
}
;
#
endif
#
if
defined
(
SK_BUILD_FOR_ANDROID_FRAMEWORK
)
#
define
SkRefCnt_SafeAssign
(
dst
src
)
\
do
{
\
typedef
typename
std
:
:
remove_reference
<
decltype
(
dst
)
>
:
:
type
\
SkRefCntPtrT
;
\
SkRefCntPtrT
old_dst
=
*
const_cast
<
SkRefCntPtrT
volatile
*
>
(
&
dst
)
;
\
if
(
src
)
src
-
>
ref
(
)
;
\
if
(
old_dst
)
old_dst
-
>
unref
(
)
;
\
if
(
old_dst
!
=
*
const_cast
<
SkRefCntPtrT
volatile
*
>
(
&
dst
)
)
{
\
SkDebugf
(
"
Detected
racing
Skia
calls
at
%
s
:
%
d
\
n
"
\
__FILE__
__LINE__
)
;
\
}
\
dst
=
src
;
\
}
while
(
0
)
#
else
#
define
SkRefCnt_SafeAssign
(
dst
src
)
\
do
{
\
if
(
src
)
src
-
>
ref
(
)
;
\
if
(
dst
)
dst
-
>
unref
(
)
;
\
dst
=
src
;
\
}
while
(
0
)
#
endif
template
<
typename
T
>
static
inline
T
*
SkRef
(
T
*
obj
)
{
SkASSERT
(
obj
)
;
obj
-
>
ref
(
)
;
return
obj
;
}
template
<
typename
T
>
static
inline
T
*
SkSafeRef
(
T
*
obj
)
{
if
(
obj
)
{
obj
-
>
ref
(
)
;
}
return
obj
;
}
template
<
typename
T
>
static
inline
void
SkSafeUnref
(
T
*
obj
)
{
if
(
obj
)
{
obj
-
>
unref
(
)
;
}
}
template
<
typename
T
>
static
inline
void
SkSafeSetNull
(
T
*
&
obj
)
{
if
(
obj
)
{
obj
-
>
unref
(
)
;
obj
=
nullptr
;
}
}
template
<
typename
Derived
>
class
SkNVRefCnt
:
SkNoncopyable
{
public
:
SkNVRefCnt
(
)
:
fRefCnt
(
1
)
{
}
~
SkNVRefCnt
(
)
{
SkASSERTF
(
1
=
=
getRefCnt
(
)
"
NVRefCnt
was
%
d
"
getRefCnt
(
)
)
;
}
bool
unique
(
)
const
{
return
1
=
=
fRefCnt
.
load
(
std
:
:
memory_order_acquire
)
;
}
void
ref
(
)
const
{
(
void
)
fRefCnt
.
fetch_add
(
+
1
std
:
:
memory_order_relaxed
)
;
}
void
unref
(
)
const
{
if
(
1
=
=
fRefCnt
.
fetch_add
(
-
1
std
:
:
memory_order_acq_rel
)
)
{
SkDEBUGCODE
(
fRefCnt
.
store
(
1
std
:
:
memory_order_relaxed
)
)
;
delete
(
const
Derived
*
)
this
;
}
}
void
deref
(
)
const
{
this
-
>
unref
(
)
;
}
private
:
mutable
std
:
:
atomic
<
int32_t
>
fRefCnt
;
int32_t
getRefCnt
(
)
const
{
return
fRefCnt
.
load
(
std
:
:
memory_order_relaxed
)
;
}
}
;
template
<
typename
T
>
class
sk_sp
{
using
unspecified_bool_type
=
T
*
sk_sp
:
:
*
;
public
:
using
element_type
=
T
;
constexpr
sk_sp
(
)
:
fPtr
(
nullptr
)
{
}
constexpr
sk_sp
(
std
:
:
nullptr_t
)
:
fPtr
(
nullptr
)
{
}
sk_sp
(
const
sk_sp
<
T
>
&
that
)
:
fPtr
(
SkSafeRef
(
that
.
get
(
)
)
)
{
}
template
<
typename
U
typename
=
skstd
:
:
enable_if_t
<
std
:
:
is_convertible
<
U
*
T
*
>
:
:
value
>
>
sk_sp
(
const
sk_sp
<
U
>
&
that
)
:
fPtr
(
SkSafeRef
(
that
.
get
(
)
)
)
{
}
sk_sp
(
sk_sp
<
T
>
&
&
that
)
:
fPtr
(
that
.
release
(
)
)
{
}
template
<
typename
U
typename
=
skstd
:
:
enable_if_t
<
std
:
:
is_convertible
<
U
*
T
*
>
:
:
value
>
>
sk_sp
(
sk_sp
<
U
>
&
&
that
)
:
fPtr
(
that
.
release
(
)
)
{
}
explicit
sk_sp
(
T
*
obj
)
:
fPtr
(
obj
)
{
}
~
sk_sp
(
)
{
SkSafeUnref
(
fPtr
)
;
SkDEBUGCODE
(
fPtr
=
nullptr
)
;
}
sk_sp
<
T
>
&
operator
=
(
std
:
:
nullptr_t
)
{
this
-
>
reset
(
)
;
return
*
this
;
}
sk_sp
<
T
>
&
operator
=
(
const
sk_sp
<
T
>
&
that
)
{
this
-
>
reset
(
SkSafeRef
(
that
.
get
(
)
)
)
;
return
*
this
;
}
template
<
typename
U
typename
=
skstd
:
:
enable_if_t
<
std
:
:
is_convertible
<
U
*
T
*
>
:
:
value
>
>
sk_sp
<
T
>
&
operator
=
(
const
sk_sp
<
U
>
&
that
)
{
this
-
>
reset
(
SkSafeRef
(
that
.
get
(
)
)
)
;
return
*
this
;
}
sk_sp
<
T
>
&
operator
=
(
sk_sp
<
T
>
&
&
that
)
{
this
-
>
reset
(
that
.
release
(
)
)
;
return
*
this
;
}
template
<
typename
U
typename
=
skstd
:
:
enable_if_t
<
std
:
:
is_convertible
<
U
*
T
*
>
:
:
value
>
>
sk_sp
<
T
>
&
operator
=
(
sk_sp
<
U
>
&
&
that
)
{
this
-
>
reset
(
that
.
release
(
)
)
;
return
*
this
;
}
T
&
operator
*
(
)
const
{
SkASSERT
(
this
-
>
get
(
)
!
=
nullptr
)
;
return
*
this
-
>
get
(
)
;
}
operator
unspecified_bool_type
(
)
const
{
return
this
-
>
get
(
)
?
&
sk_sp
:
:
fPtr
:
nullptr
;
}
bool
operator
!
(
)
const
{
return
this
-
>
get
(
)
=
=
nullptr
;
}
T
*
get
(
)
const
{
return
fPtr
;
}
T
*
operator
-
>
(
)
const
{
return
fPtr
;
}
void
reset
(
T
*
ptr
=
nullptr
)
{
T
*
oldPtr
=
fPtr
;
fPtr
=
ptr
;
SkSafeUnref
(
oldPtr
)
;
}
T
*
SK_WARN_UNUSED_RESULT
release
(
)
{
T
*
ptr
=
fPtr
;
fPtr
=
nullptr
;
return
ptr
;
}
void
swap
(
sk_sp
<
T
>
&
that
)
{
using
std
:
:
swap
;
swap
(
fPtr
that
.
fPtr
)
;
}
private
:
T
*
fPtr
;
}
;
template
<
typename
T
>
inline
void
swap
(
sk_sp
<
T
>
&
a
sk_sp
<
T
>
&
b
)
{
a
.
swap
(
b
)
;
}
template
<
typename
T
typename
U
>
inline
bool
operator
=
=
(
const
sk_sp
<
T
>
&
a
const
sk_sp
<
U
>
&
b
)
{
return
a
.
get
(
)
=
=
b
.
get
(
)
;
}
template
<
typename
T
>
inline
bool
operator
=
=
(
const
sk_sp
<
T
>
&
a
std
:
:
nullptr_t
)
{
return
!
a
;
}
template
<
typename
T
>
inline
bool
operator
=
=
(
std
:
:
nullptr_t
const
sk_sp
<
T
>
&
b
)
{
return
!
b
;
}
template
<
typename
T
typename
U
>
inline
bool
operator
!
=
(
const
sk_sp
<
T
>
&
a
const
sk_sp
<
U
>
&
b
)
{
return
a
.
get
(
)
!
=
b
.
get
(
)
;
}
template
<
typename
T
>
inline
bool
operator
!
=
(
const
sk_sp
<
T
>
&
a
std
:
:
nullptr_t
)
{
return
static_cast
<
bool
>
(
a
)
;
}
template
<
typename
T
>
inline
bool
operator
!
=
(
std
:
:
nullptr_t
const
sk_sp
<
T
>
&
b
)
{
return
static_cast
<
bool
>
(
b
)
;
}
template
<
typename
T
typename
U
>
inline
bool
operator
<
(
const
sk_sp
<
T
>
&
a
const
sk_sp
<
U
>
&
b
)
{
return
std
:
:
less
<
skstd
:
:
common_type_t
<
T
*
U
*
>
>
(
)
(
a
.
get
(
)
b
.
get
(
)
)
;
}
template
<
typename
T
>
inline
bool
operator
<
(
const
sk_sp
<
T
>
&
a
std
:
:
nullptr_t
)
{
return
std
:
:
less
<
T
*
>
(
)
(
a
.
get
(
)
nullptr
)
;
}
template
<
typename
T
>
inline
bool
operator
<
(
std
:
:
nullptr_t
const
sk_sp
<
T
>
&
b
)
{
return
std
:
:
less
<
T
*
>
(
)
(
nullptr
b
.
get
(
)
)
;
}
template
<
typename
T
typename
U
>
inline
bool
operator
<
=
(
const
sk_sp
<
T
>
&
a
const
sk_sp
<
U
>
&
b
)
{
return
!
(
b
<
a
)
;
}
template
<
typename
T
>
inline
bool
operator
<
=
(
const
sk_sp
<
T
>
&
a
std
:
:
nullptr_t
)
{
return
!
(
nullptr
<
a
)
;
}
template
<
typename
T
>
inline
bool
operator
<
=
(
std
:
:
nullptr_t
const
sk_sp
<
T
>
&
b
)
{
return
!
(
b
<
nullptr
)
;
}
template
<
typename
T
typename
U
>
inline
bool
operator
>
(
const
sk_sp
<
T
>
&
a
const
sk_sp
<
U
>
&
b
)
{
return
b
<
a
;
}
template
<
typename
T
>
inline
bool
operator
>
(
const
sk_sp
<
T
>
&
a
std
:
:
nullptr_t
)
{
return
nullptr
<
a
;
}
template
<
typename
T
>
inline
bool
operator
>
(
std
:
:
nullptr_t
const
sk_sp
<
T
>
&
b
)
{
return
b
<
nullptr
;
}
template
<
typename
T
typename
U
>
inline
bool
operator
>
=
(
const
sk_sp
<
T
>
&
a
const
sk_sp
<
U
>
&
b
)
{
return
!
(
a
<
b
)
;
}
template
<
typename
T
>
inline
bool
operator
>
=
(
const
sk_sp
<
T
>
&
a
std
:
:
nullptr_t
)
{
return
!
(
a
<
nullptr
)
;
}
template
<
typename
T
>
inline
bool
operator
>
=
(
std
:
:
nullptr_t
const
sk_sp
<
T
>
&
b
)
{
return
!
(
nullptr
<
b
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
sk_sp
<
T
>
sk_make_sp
(
Args
&
&
.
.
.
args
)
{
return
sk_sp
<
T
>
(
new
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
;
}
template
<
typename
T
>
sk_sp
<
T
>
sk_ref_sp
(
T
*
obj
)
{
return
sk_sp
<
T
>
(
SkSafeRef
(
obj
)
)
;
}
#
endif
