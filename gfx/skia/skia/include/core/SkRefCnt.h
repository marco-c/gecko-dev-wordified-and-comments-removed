#
ifndef
SkRefCnt_DEFINED
#
define
SkRefCnt_DEFINED
#
include
"
.
.
/
private
/
SkAtomics
.
h
"
#
include
"
.
.
/
private
/
SkUniquePtr
.
h
"
#
include
"
SkTypes
.
h
"
class
SK_API
SkRefCntBase
:
SkNoncopyable
{
public
:
SkRefCntBase
(
)
:
fRefCnt
(
1
)
{
}
virtual
~
SkRefCntBase
(
)
{
#
ifdef
SK_DEBUG
SkASSERTF
(
fRefCnt
=
=
1
"
fRefCnt
was
%
d
"
fRefCnt
)
;
fRefCnt
=
0
;
#
endif
}
int32_t
getRefCnt
(
)
const
{
return
fRefCnt
;
}
bool
unique
(
)
const
{
if
(
1
=
=
sk_atomic_load
(
&
fRefCnt
sk_memory_order_acquire
)
)
{
return
true
;
}
return
false
;
}
void
ref
(
)
const
{
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
SkASSERT
(
fRefCnt
>
=
0
)
;
#
else
SkASSERT
(
fRefCnt
>
0
)
;
#
endif
(
void
)
sk_atomic_fetch_add
(
&
fRefCnt
+
1
sk_memory_order_relaxed
)
;
}
void
unref
(
)
const
{
SkASSERT
(
fRefCnt
>
0
)
;
if
(
1
=
=
sk_atomic_fetch_add
(
&
fRefCnt
-
1
sk_memory_order_acq_rel
)
)
{
this
-
>
internal_dispose
(
)
;
}
}
#
ifdef
SK_DEBUG
void
validate
(
)
const
{
SkASSERT
(
fRefCnt
>
0
)
;
}
#
endif
protected
:
void
internal_dispose_restore_refcnt_to_1
(
)
const
{
#
ifdef
SK_DEBUG
SkASSERT
(
0
=
=
fRefCnt
)
;
fRefCnt
=
1
;
#
endif
}
private
:
virtual
void
internal_dispose
(
)
const
{
this
-
>
internal_dispose_restore_refcnt_to_1
(
)
;
delete
this
;
}
friend
class
SkWeakRefCnt
;
mutable
int32_t
fRefCnt
;
typedef
SkNoncopyable
INHERITED
;
}
;
#
ifdef
SK_REF_CNT_MIXIN_INCLUDE
#
include
SK_REF_CNT_MIXIN_INCLUDE
#
else
class
SK_API
SkRefCnt
:
public
SkRefCntBase
{
}
;
#
endif
#
define
SkRefCnt_SafeAssign
(
dst
src
)
\
do
{
\
if
(
src
)
src
-
>
ref
(
)
;
\
if
(
dst
)
dst
-
>
unref
(
)
;
\
dst
=
src
;
\
}
while
(
0
)
template
<
typename
T
>
static
inline
T
*
SkRef
(
T
*
obj
)
{
SkASSERT
(
obj
)
;
obj
-
>
ref
(
)
;
return
obj
;
}
template
<
typename
T
>
static
inline
T
*
SkSafeRef
(
T
*
obj
)
{
if
(
obj
)
{
obj
-
>
ref
(
)
;
}
return
obj
;
}
template
<
typename
T
>
static
inline
void
SkSafeUnref
(
T
*
obj
)
{
if
(
obj
)
{
obj
-
>
unref
(
)
;
}
}
template
<
typename
T
>
static
inline
void
SkSafeSetNull
(
T
*
&
obj
)
{
if
(
obj
)
{
obj
-
>
unref
(
)
;
obj
=
nullptr
;
}
}
template
<
typename
T
>
struct
SkTUnref
{
void
operator
(
)
(
T
*
t
)
{
t
-
>
unref
(
)
;
}
}
;
template
<
typename
T
>
class
SkAutoTUnref
:
public
skstd
:
:
unique_ptr
<
T
SkTUnref
<
T
>
>
{
public
:
explicit
SkAutoTUnref
(
T
*
obj
=
nullptr
)
:
skstd
:
:
unique_ptr
<
T
SkTUnref
<
T
>
>
(
obj
)
{
}
T
*
detach
(
)
{
return
this
-
>
release
(
)
;
}
operator
T
*
(
)
const
{
return
this
-
>
get
(
)
;
}
}
;
class
SkAutoUnref
:
public
SkAutoTUnref
<
SkRefCnt
>
{
public
:
SkAutoUnref
(
SkRefCnt
*
obj
)
:
SkAutoTUnref
<
SkRefCnt
>
(
obj
)
{
}
}
;
#
define
SkAutoUnref
(
.
.
.
)
SK_REQUIRE_LOCAL_VAR
(
SkAutoUnref
)
template
<
typename
Derived
>
class
SkNVRefCnt
:
SkNoncopyable
{
public
:
SkNVRefCnt
(
)
:
fRefCnt
(
1
)
{
}
~
SkNVRefCnt
(
)
{
SkASSERTF
(
1
=
=
fRefCnt
"
NVRefCnt
was
%
d
"
fRefCnt
)
;
}
bool
unique
(
)
const
{
return
1
=
=
sk_atomic_load
(
&
fRefCnt
sk_memory_order_acquire
)
;
}
void
ref
(
)
const
{
(
void
)
sk_atomic_fetch_add
(
&
fRefCnt
+
1
sk_memory_order_relaxed
)
;
}
void
unref
(
)
const
{
if
(
1
=
=
sk_atomic_fetch_add
(
&
fRefCnt
-
1
sk_memory_order_acq_rel
)
)
{
SkDEBUGCODE
(
fRefCnt
=
1
;
)
delete
(
const
Derived
*
)
this
;
}
}
void
deref
(
)
const
{
this
-
>
unref
(
)
;
}
private
:
mutable
int32_t
fRefCnt
;
}
;
#
endif
