#
ifndef
SkSurfaceCharacterization_DEFINED
#
define
SkSurfaceCharacterization_DEFINED
#
include
"
include
/
core
/
SkColorSpace
.
h
"
#
include
"
include
/
core
/
SkImageInfo
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSurfaceProps
.
h
"
class
SkColorSpace
;
#
if
defined
(
SK_GANESH
)
#
include
"
include
/
gpu
/
GrBackendSurface
.
h
"
#
include
"
include
/
gpu
/
GrContextThreadSafeProxy
.
h
"
#
include
"
include
/
gpu
/
GrTypes
.
h
"
class
SK_API
SkSurfaceCharacterization
{
public
:
enum
class
Textureable
:
bool
{
kNo
=
false
kYes
=
true
}
;
enum
class
MipMapped
:
bool
{
kNo
=
false
kYes
=
true
}
;
enum
class
UsesGLFBO0
:
bool
{
kNo
=
false
kYes
=
true
}
;
enum
class
VkRTSupportsInputAttachment
:
bool
{
kNo
=
false
kYes
=
true
}
;
enum
class
VulkanSecondaryCBCompatible
:
bool
{
kNo
=
false
kYes
=
true
}
;
SkSurfaceCharacterization
(
)
:
fCacheMaxResourceBytes
(
0
)
fOrigin
(
kBottomLeft_GrSurfaceOrigin
)
fSampleCnt
(
0
)
fIsTextureable
(
Textureable
:
:
kYes
)
fIsMipMapped
(
MipMapped
:
:
kYes
)
fUsesGLFBO0
(
UsesGLFBO0
:
:
kNo
)
fVulkanSecondaryCBCompatible
(
VulkanSecondaryCBCompatible
:
:
kNo
)
fIsProtected
(
GrProtected
:
:
kNo
)
fSurfaceProps
(
0
kUnknown_SkPixelGeometry
)
{
}
SkSurfaceCharacterization
(
SkSurfaceCharacterization
&
&
)
=
default
;
SkSurfaceCharacterization
&
operator
=
(
SkSurfaceCharacterization
&
&
)
=
default
;
SkSurfaceCharacterization
(
const
SkSurfaceCharacterization
&
)
=
default
;
SkSurfaceCharacterization
&
operator
=
(
const
SkSurfaceCharacterization
&
other
)
=
default
;
bool
operator
=
=
(
const
SkSurfaceCharacterization
&
other
)
const
;
bool
operator
!
=
(
const
SkSurfaceCharacterization
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
SkSurfaceCharacterization
createResized
(
int
width
int
height
)
const
;
SkSurfaceCharacterization
createColorSpace
(
sk_sp
<
SkColorSpace
>
)
const
;
SkSurfaceCharacterization
createBackendFormat
(
SkColorType
colorType
const
GrBackendFormat
&
backendFormat
)
const
;
SkSurfaceCharacterization
createFBO0
(
bool
usesGLFBO0
)
const
;
GrContextThreadSafeProxy
*
contextInfo
(
)
const
{
return
fContextInfo
.
get
(
)
;
}
sk_sp
<
GrContextThreadSafeProxy
>
refContextInfo
(
)
const
{
return
fContextInfo
;
}
size_t
cacheMaxResourceBytes
(
)
const
{
return
fCacheMaxResourceBytes
;
}
bool
isValid
(
)
const
{
return
kUnknown_SkColorType
!
=
fImageInfo
.
colorType
(
)
;
}
const
SkImageInfo
&
imageInfo
(
)
const
{
return
fImageInfo
;
}
const
GrBackendFormat
&
backendFormat
(
)
const
{
return
fBackendFormat
;
}
GrSurfaceOrigin
origin
(
)
const
{
return
fOrigin
;
}
SkISize
dimensions
(
)
const
{
return
fImageInfo
.
dimensions
(
)
;
}
int
width
(
)
const
{
return
fImageInfo
.
width
(
)
;
}
int
height
(
)
const
{
return
fImageInfo
.
height
(
)
;
}
SkColorType
colorType
(
)
const
{
return
fImageInfo
.
colorType
(
)
;
}
int
sampleCount
(
)
const
{
return
fSampleCnt
;
}
bool
isTextureable
(
)
const
{
return
Textureable
:
:
kYes
=
=
fIsTextureable
;
}
bool
isMipMapped
(
)
const
{
return
MipMapped
:
:
kYes
=
=
fIsMipMapped
;
}
bool
usesGLFBO0
(
)
const
{
return
UsesGLFBO0
:
:
kYes
=
=
fUsesGLFBO0
;
}
bool
vkRTSupportsInputAttachment
(
)
const
{
return
VkRTSupportsInputAttachment
:
:
kYes
=
=
fVkRTSupportsInputAttachment
;
}
bool
vulkanSecondaryCBCompatible
(
)
const
{
return
VulkanSecondaryCBCompatible
:
:
kYes
=
=
fVulkanSecondaryCBCompatible
;
}
GrProtected
isProtected
(
)
const
{
return
fIsProtected
;
}
SkColorSpace
*
colorSpace
(
)
const
{
return
fImageInfo
.
colorSpace
(
)
;
}
sk_sp
<
SkColorSpace
>
refColorSpace
(
)
const
{
return
fImageInfo
.
refColorSpace
(
)
;
}
const
SkSurfaceProps
&
surfaceProps
(
)
const
{
return
fSurfaceProps
;
}
bool
isCompatible
(
const
GrBackendTexture
&
)
const
;
private
:
friend
class
SkSurface_Gpu
;
friend
class
GrVkSecondaryCBDrawContext
;
friend
class
GrContextThreadSafeProxy
;
friend
class
SkDeferredDisplayListRecorder
;
friend
class
SkSurface
;
SkDEBUGCODE
(
void
validate
(
)
const
;
)
SkSurfaceCharacterization
(
sk_sp
<
GrContextThreadSafeProxy
>
contextInfo
size_t
cacheMaxResourceBytes
const
SkImageInfo
&
ii
const
GrBackendFormat
&
backendFormat
GrSurfaceOrigin
origin
int
sampleCnt
Textureable
isTextureable
MipMapped
isMipMapped
UsesGLFBO0
usesGLFBO0
VkRTSupportsInputAttachment
vkRTSupportsInputAttachment
VulkanSecondaryCBCompatible
vulkanSecondaryCBCompatible
GrProtected
isProtected
const
SkSurfaceProps
&
surfaceProps
)
:
fContextInfo
(
std
:
:
move
(
contextInfo
)
)
fCacheMaxResourceBytes
(
cacheMaxResourceBytes
)
fImageInfo
(
ii
)
fBackendFormat
(
backendFormat
)
fOrigin
(
origin
)
fSampleCnt
(
sampleCnt
)
fIsTextureable
(
isTextureable
)
fIsMipMapped
(
isMipMapped
)
fUsesGLFBO0
(
usesGLFBO0
)
fVkRTSupportsInputAttachment
(
vkRTSupportsInputAttachment
)
fVulkanSecondaryCBCompatible
(
vulkanSecondaryCBCompatible
)
fIsProtected
(
isProtected
)
fSurfaceProps
(
surfaceProps
)
{
if
(
fSurfaceProps
.
flags
(
)
&
SkSurfaceProps
:
:
kDynamicMSAA_Flag
)
{
*
this
=
{
}
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
}
void
set
(
sk_sp
<
GrContextThreadSafeProxy
>
contextInfo
size_t
cacheMaxResourceBytes
const
SkImageInfo
&
ii
const
GrBackendFormat
&
backendFormat
GrSurfaceOrigin
origin
int
sampleCnt
Textureable
isTextureable
MipMapped
isMipMapped
UsesGLFBO0
usesGLFBO0
VkRTSupportsInputAttachment
vkRTSupportsInputAttachment
VulkanSecondaryCBCompatible
vulkanSecondaryCBCompatible
GrProtected
isProtected
const
SkSurfaceProps
&
surfaceProps
)
{
if
(
surfaceProps
.
flags
(
)
&
SkSurfaceProps
:
:
kDynamicMSAA_Flag
)
{
*
this
=
{
}
;
}
else
{
fContextInfo
=
contextInfo
;
fCacheMaxResourceBytes
=
cacheMaxResourceBytes
;
fImageInfo
=
ii
;
fBackendFormat
=
backendFormat
;
fOrigin
=
origin
;
fSampleCnt
=
sampleCnt
;
fIsTextureable
=
isTextureable
;
fIsMipMapped
=
isMipMapped
;
fUsesGLFBO0
=
usesGLFBO0
;
fVkRTSupportsInputAttachment
=
vkRTSupportsInputAttachment
;
fVulkanSecondaryCBCompatible
=
vulkanSecondaryCBCompatible
;
fIsProtected
=
isProtected
;
fSurfaceProps
=
surfaceProps
;
}
SkDEBUGCODE
(
this
-
>
validate
(
)
)
;
}
sk_sp
<
GrContextThreadSafeProxy
>
fContextInfo
;
size_t
fCacheMaxResourceBytes
;
SkImageInfo
fImageInfo
;
GrBackendFormat
fBackendFormat
;
GrSurfaceOrigin
fOrigin
;
int
fSampleCnt
;
Textureable
fIsTextureable
;
MipMapped
fIsMipMapped
;
UsesGLFBO0
fUsesGLFBO0
;
VkRTSupportsInputAttachment
fVkRTSupportsInputAttachment
;
VulkanSecondaryCBCompatible
fVulkanSecondaryCBCompatible
;
GrProtected
fIsProtected
;
SkSurfaceProps
fSurfaceProps
;
}
;
#
else
class
GrBackendFormat
;
class
SK_API
SkSurfaceCharacterization
{
public
:
SkSurfaceCharacterization
(
)
:
fSurfaceProps
(
0
kUnknown_SkPixelGeometry
)
{
}
SkSurfaceCharacterization
createResized
(
int
width
int
height
)
const
{
return
*
this
;
}
SkSurfaceCharacterization
createColorSpace
(
sk_sp
<
SkColorSpace
>
)
const
{
return
*
this
;
}
SkSurfaceCharacterization
createBackendFormat
(
SkColorType
const
GrBackendFormat
&
)
const
{
return
*
this
;
}
SkSurfaceCharacterization
createFBO0
(
bool
usesGLFBO0
)
const
{
return
*
this
;
}
bool
operator
=
=
(
const
SkSurfaceCharacterization
&
other
)
const
{
return
false
;
}
bool
operator
!
=
(
const
SkSurfaceCharacterization
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
size_t
cacheMaxResourceBytes
(
)
const
{
return
0
;
}
bool
isValid
(
)
const
{
return
false
;
}
int
width
(
)
const
{
return
0
;
}
int
height
(
)
const
{
return
0
;
}
int
stencilCount
(
)
const
{
return
0
;
}
bool
isTextureable
(
)
const
{
return
false
;
}
bool
isMipMapped
(
)
const
{
return
false
;
}
bool
usesGLFBO0
(
)
const
{
return
false
;
}
bool
vkRTSupportsAttachmentInput
(
)
const
{
return
false
;
}
bool
vulkanSecondaryCBCompatible
(
)
const
{
return
false
;
}
SkColorSpace
*
colorSpace
(
)
const
{
return
nullptr
;
}
sk_sp
<
SkColorSpace
>
refColorSpace
(
)
const
{
return
nullptr
;
}
const
SkSurfaceProps
&
surfaceProps
(
)
const
{
return
fSurfaceProps
;
}
private
:
SkSurfaceProps
fSurfaceProps
;
}
;
#
endif
#
endif
