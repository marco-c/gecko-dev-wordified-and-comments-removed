#
ifndef
SkImageInfo_DEFINED
#
define
SkImageInfo_DEFINED
#
include
"
include
/
core
/
SkAlphaType
.
h
"
#
include
"
include
/
core
/
SkColorType
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSize
.
h
"
#
include
"
include
/
private
/
base
/
SkAPI
.
h
"
#
include
"
include
/
private
/
base
/
SkDebug
.
h
"
#
include
"
include
/
private
/
base
/
SkMath
.
h
"
#
include
"
include
/
private
/
base
/
SkTFitsIn
.
h
"
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
utility
>
class
SkColorSpace
;
SK_API
int
SkColorTypeBytesPerPixel
(
SkColorType
ct
)
;
SK_API
bool
SkColorTypeIsAlwaysOpaque
(
SkColorType
ct
)
;
SK_API
bool
SkColorTypeValidateAlphaType
(
SkColorType
colorType
SkAlphaType
alphaType
SkAlphaType
*
canonical
=
nullptr
)
;
enum
SkYUVColorSpace
:
int
{
kJPEG_Full_SkYUVColorSpace
kRec601_Limited_SkYUVColorSpace
kRec709_Full_SkYUVColorSpace
kRec709_Limited_SkYUVColorSpace
kBT2020_8bit_Full_SkYUVColorSpace
kBT2020_8bit_Limited_SkYUVColorSpace
kBT2020_10bit_Full_SkYUVColorSpace
kBT2020_10bit_Limited_SkYUVColorSpace
kBT2020_12bit_Full_SkYUVColorSpace
kBT2020_12bit_Limited_SkYUVColorSpace
kIdentity_SkYUVColorSpace
kLastEnum_SkYUVColorSpace
=
kIdentity_SkYUVColorSpace
kJPEG_SkYUVColorSpace
=
kJPEG_Full_SkYUVColorSpace
kRec601_SkYUVColorSpace
=
kRec601_Limited_SkYUVColorSpace
kRec709_SkYUVColorSpace
=
kRec709_Limited_SkYUVColorSpace
kBT2020_SkYUVColorSpace
=
kBT2020_8bit_Limited_SkYUVColorSpace
}
;
class
SK_API
SkColorInfo
{
public
:
SkColorInfo
(
)
;
~
SkColorInfo
(
)
;
SkColorInfo
(
SkColorType
ct
SkAlphaType
at
sk_sp
<
SkColorSpace
>
cs
)
;
SkColorInfo
(
const
SkColorInfo
&
)
;
SkColorInfo
(
SkColorInfo
&
&
)
;
SkColorInfo
&
operator
=
(
const
SkColorInfo
&
)
;
SkColorInfo
&
operator
=
(
SkColorInfo
&
&
)
;
SkColorSpace
*
colorSpace
(
)
const
;
sk_sp
<
SkColorSpace
>
refColorSpace
(
)
const
;
SkColorType
colorType
(
)
const
{
return
fColorType
;
}
SkAlphaType
alphaType
(
)
const
{
return
fAlphaType
;
}
bool
isOpaque
(
)
const
{
return
SkAlphaTypeIsOpaque
(
fAlphaType
)
|
|
SkColorTypeIsAlwaysOpaque
(
fColorType
)
;
}
bool
gammaCloseToSRGB
(
)
const
;
bool
operator
=
=
(
const
SkColorInfo
&
other
)
const
;
bool
operator
!
=
(
const
SkColorInfo
&
other
)
const
;
SkColorInfo
makeAlphaType
(
SkAlphaType
newAlphaType
)
const
;
SkColorInfo
makeColorType
(
SkColorType
newColorType
)
const
;
SkColorInfo
makeColorSpace
(
sk_sp
<
SkColorSpace
>
cs
)
const
;
int
bytesPerPixel
(
)
const
;
int
shiftPerPixel
(
)
const
;
private
:
sk_sp
<
SkColorSpace
>
fColorSpace
;
SkColorType
fColorType
=
kUnknown_SkColorType
;
SkAlphaType
fAlphaType
=
kUnknown_SkAlphaType
;
}
;
struct
SK_API
SkImageInfo
{
public
:
SkImageInfo
(
)
=
default
;
static
SkImageInfo
Make
(
int
width
int
height
SkColorType
ct
SkAlphaType
at
)
;
static
SkImageInfo
Make
(
int
width
int
height
SkColorType
ct
SkAlphaType
at
sk_sp
<
SkColorSpace
>
cs
)
;
static
SkImageInfo
Make
(
SkISize
dimensions
SkColorType
ct
SkAlphaType
at
)
;
static
SkImageInfo
Make
(
SkISize
dimensions
SkColorType
ct
SkAlphaType
at
sk_sp
<
SkColorSpace
>
cs
)
;
static
SkImageInfo
Make
(
SkISize
dimensions
const
SkColorInfo
&
colorInfo
)
{
return
SkImageInfo
(
dimensions
colorInfo
)
;
}
static
SkImageInfo
Make
(
SkISize
dimensions
SkColorInfo
&
&
colorInfo
)
{
return
SkImageInfo
(
dimensions
std
:
:
move
(
colorInfo
)
)
;
}
static
SkImageInfo
MakeN32
(
int
width
int
height
SkAlphaType
at
)
;
static
SkImageInfo
MakeN32
(
int
width
int
height
SkAlphaType
at
sk_sp
<
SkColorSpace
>
cs
)
;
static
SkImageInfo
MakeS32
(
int
width
int
height
SkAlphaType
at
)
;
static
SkImageInfo
MakeN32Premul
(
int
width
int
height
)
;
static
SkImageInfo
MakeN32Premul
(
int
width
int
height
sk_sp
<
SkColorSpace
>
cs
)
;
static
SkImageInfo
MakeN32Premul
(
SkISize
dimensions
)
;
static
SkImageInfo
MakeN32Premul
(
SkISize
dimensions
sk_sp
<
SkColorSpace
>
cs
)
;
static
SkImageInfo
MakeA8
(
int
width
int
height
)
;
static
SkImageInfo
MakeA8
(
SkISize
dimensions
)
;
static
SkImageInfo
MakeUnknown
(
int
width
int
height
)
;
static
SkImageInfo
MakeUnknown
(
)
{
return
MakeUnknown
(
0
0
)
;
}
int
width
(
)
const
{
return
fDimensions
.
width
(
)
;
}
int
height
(
)
const
{
return
fDimensions
.
height
(
)
;
}
SkColorType
colorType
(
)
const
{
return
fColorInfo
.
colorType
(
)
;
}
SkAlphaType
alphaType
(
)
const
{
return
fColorInfo
.
alphaType
(
)
;
}
SkColorSpace
*
colorSpace
(
)
const
;
sk_sp
<
SkColorSpace
>
refColorSpace
(
)
const
;
bool
isEmpty
(
)
const
{
return
fDimensions
.
isEmpty
(
)
;
}
const
SkColorInfo
&
colorInfo
(
)
const
{
return
fColorInfo
;
}
bool
isOpaque
(
)
const
{
return
fColorInfo
.
isOpaque
(
)
;
}
SkISize
dimensions
(
)
const
{
return
fDimensions
;
}
SkIRect
bounds
(
)
const
{
return
SkIRect
:
:
MakeSize
(
fDimensions
)
;
}
bool
gammaCloseToSRGB
(
)
const
{
return
fColorInfo
.
gammaCloseToSRGB
(
)
;
}
SkImageInfo
makeWH
(
int
newWidth
int
newHeight
)
const
{
return
Make
(
{
newWidth
newHeight
}
fColorInfo
)
;
}
SkImageInfo
makeDimensions
(
SkISize
newSize
)
const
{
return
Make
(
newSize
fColorInfo
)
;
}
SkImageInfo
makeAlphaType
(
SkAlphaType
newAlphaType
)
const
{
return
Make
(
fDimensions
fColorInfo
.
makeAlphaType
(
newAlphaType
)
)
;
}
SkImageInfo
makeColorType
(
SkColorType
newColorType
)
const
{
return
Make
(
fDimensions
fColorInfo
.
makeColorType
(
newColorType
)
)
;
}
SkImageInfo
makeColorSpace
(
sk_sp
<
SkColorSpace
>
cs
)
const
;
int
bytesPerPixel
(
)
const
{
return
fColorInfo
.
bytesPerPixel
(
)
;
}
int
shiftPerPixel
(
)
const
{
return
fColorInfo
.
shiftPerPixel
(
)
;
}
uint64_t
minRowBytes64
(
)
const
{
return
(
uint64_t
)
sk_64_mul
(
this
-
>
width
(
)
this
-
>
bytesPerPixel
(
)
)
;
}
size_t
minRowBytes
(
)
const
{
uint64_t
minRowBytes
=
this
-
>
minRowBytes64
(
)
;
if
(
!
SkTFitsIn
<
int32_t
>
(
minRowBytes
)
)
{
return
0
;
}
return
(
size_t
)
minRowBytes
;
}
size_t
computeOffset
(
int
x
int
y
size_t
rowBytes
)
const
;
bool
operator
=
=
(
const
SkImageInfo
&
other
)
const
{
return
fDimensions
=
=
other
.
fDimensions
&
&
fColorInfo
=
=
other
.
fColorInfo
;
}
bool
operator
!
=
(
const
SkImageInfo
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
size_t
computeByteSize
(
size_t
rowBytes
)
const
;
size_t
computeMinByteSize
(
)
const
{
return
this
-
>
computeByteSize
(
this
-
>
minRowBytes
(
)
)
;
}
static
bool
ByteSizeOverflowed
(
size_t
byteSize
)
{
return
SIZE_MAX
=
=
byteSize
;
}
bool
validRowBytes
(
size_t
rowBytes
)
const
{
if
(
rowBytes
<
this
-
>
minRowBytes64
(
)
)
{
return
false
;
}
int
shift
=
this
-
>
shiftPerPixel
(
)
;
size_t
alignedRowBytes
=
rowBytes
>
>
shift
<
<
shift
;
return
alignedRowBytes
=
=
rowBytes
;
}
void
reset
(
)
{
*
this
=
{
}
;
}
SkDEBUGCODE
(
void
validate
(
)
const
;
)
private
:
SkColorInfo
fColorInfo
;
SkISize
fDimensions
=
{
0
0
}
;
SkImageInfo
(
SkISize
dimensions
const
SkColorInfo
&
colorInfo
)
:
fColorInfo
(
colorInfo
)
fDimensions
(
dimensions
)
{
}
SkImageInfo
(
SkISize
dimensions
SkColorInfo
&
&
colorInfo
)
:
fColorInfo
(
std
:
:
move
(
colorInfo
)
)
fDimensions
(
dimensions
)
{
}
}
;
#
endif
