#
ifndef
SkImageInfo_DEFINED
#
define
SkImageInfo_DEFINED
#
include
"
include
/
core
/
SkColorSpace
.
h
"
#
include
"
include
/
core
/
SkMath
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkSize
.
h
"
#
include
"
include
/
private
/
SkTFitsIn
.
h
"
#
include
"
include
/
private
/
SkTo
.
h
"
class
SkReadBuffer
;
class
SkWriteBuffer
;
enum
SkAlphaType
{
kUnknown_SkAlphaType
kOpaque_SkAlphaType
kPremul_SkAlphaType
kUnpremul_SkAlphaType
kLastEnum_SkAlphaType
=
kUnpremul_SkAlphaType
}
;
static
inline
bool
SkAlphaTypeIsOpaque
(
SkAlphaType
at
)
{
return
kOpaque_SkAlphaType
=
=
at
;
}
#
define
SK_EXTENDED_COLOR_TYPES
enum
SkColorType
{
kUnknown_SkColorType
kAlpha_8_SkColorType
kRGB_565_SkColorType
kARGB_4444_SkColorType
kRGBA_8888_SkColorType
kRGB_888x_SkColorType
kBGRA_8888_SkColorType
kRGBA_1010102_SkColorType
kRGB_101010x_SkColorType
kGray_8_SkColorType
kRGBA_F16Norm_SkColorType
kRGBA_F16_SkColorType
kRGBA_F32_SkColorType
kR8G8_unorm_SkColorType
kA16_float_SkColorType
kR16G16_float_SkColorType
kA16_unorm_SkColorType
kR16G16_unorm_SkColorType
kR16G16B16A16_unorm_SkColorType
kLastEnum_SkColorType
=
kR16G16B16A16_unorm_SkColorType
#
if
SK_PMCOLOR_BYTE_ORDER
(
B
G
R
A
)
kN32_SkColorType
=
kBGRA_8888_SkColorType
#
elif
SK_PMCOLOR_BYTE_ORDER
(
R
G
B
A
)
kN32_SkColorType
=
kRGBA_8888_SkColorType
#
else
kN32_SkColorType
=
kBGRA_8888_SkColorType
#
endif
}
;
SK_API
int
SkColorTypeBytesPerPixel
(
SkColorType
ct
)
;
SK_API
bool
SkColorTypeIsAlwaysOpaque
(
SkColorType
ct
)
;
SK_API
bool
SkColorTypeValidateAlphaType
(
SkColorType
colorType
SkAlphaType
alphaType
SkAlphaType
*
canonical
=
nullptr
)
;
enum
SkYUVColorSpace
{
kJPEG_SkYUVColorSpace
kRec601_SkYUVColorSpace
kRec709_SkYUVColorSpace
kIdentity_SkYUVColorSpace
kLastEnum_SkYUVColorSpace
=
kIdentity_SkYUVColorSpace
}
;
class
SK_API
SkColorInfo
{
public
:
SkColorInfo
(
)
=
default
;
SkColorInfo
(
SkColorType
ct
SkAlphaType
at
sk_sp
<
SkColorSpace
>
cs
)
:
fColorSpace
(
std
:
:
move
(
cs
)
)
fColorType
(
ct
)
fAlphaType
(
at
)
{
}
SkColorInfo
(
const
SkColorInfo
&
)
=
default
;
SkColorInfo
(
SkColorInfo
&
&
)
=
default
;
SkColorInfo
&
operator
=
(
const
SkColorInfo
&
)
=
default
;
SkColorInfo
&
operator
=
(
SkColorInfo
&
&
)
=
default
;
SkColorSpace
*
colorSpace
(
)
const
{
return
fColorSpace
.
get
(
)
;
}
sk_sp
<
SkColorSpace
>
refColorSpace
(
)
const
{
return
fColorSpace
;
}
SkColorType
colorType
(
)
const
{
return
fColorType
;
}
SkAlphaType
alphaType
(
)
const
{
return
fAlphaType
;
}
bool
isOpaque
(
)
const
{
return
SkAlphaTypeIsOpaque
(
fAlphaType
)
;
}
bool
gammaCloseToSRGB
(
)
const
{
return
fColorSpace
&
&
fColorSpace
-
>
gammaCloseToSRGB
(
)
;
}
bool
operator
=
=
(
const
SkColorInfo
&
other
)
const
{
return
fColorType
=
=
other
.
fColorType
&
&
fAlphaType
=
=
other
.
fAlphaType
&
&
SkColorSpace
:
:
Equals
(
fColorSpace
.
get
(
)
other
.
fColorSpace
.
get
(
)
)
;
}
bool
operator
!
=
(
const
SkColorInfo
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
SkColorInfo
makeAlphaType
(
SkAlphaType
newAlphaType
)
const
{
return
SkColorInfo
(
this
-
>
colorType
(
)
newAlphaType
this
-
>
refColorSpace
(
)
)
;
}
SkColorInfo
makeColorType
(
SkColorType
newColorType
)
const
{
return
SkColorInfo
(
newColorType
this
-
>
alphaType
(
)
this
-
>
refColorSpace
(
)
)
;
}
SkColorInfo
makeColorSpace
(
sk_sp
<
SkColorSpace
>
cs
)
const
{
return
SkColorInfo
(
this
-
>
colorType
(
)
this
-
>
alphaType
(
)
std
:
:
move
(
cs
)
)
;
}
int
bytesPerPixel
(
)
const
;
int
shiftPerPixel
(
)
const
;
private
:
sk_sp
<
SkColorSpace
>
fColorSpace
;
SkColorType
fColorType
=
kUnknown_SkColorType
;
SkAlphaType
fAlphaType
=
kUnknown_SkAlphaType
;
}
;
struct
SK_API
SkImageInfo
{
public
:
SkImageInfo
(
)
=
default
;
static
SkImageInfo
Make
(
int
width
int
height
SkColorType
ct
SkAlphaType
at
sk_sp
<
SkColorSpace
>
cs
=
nullptr
)
{
return
SkImageInfo
(
{
width
height
}
{
ct
at
std
:
:
move
(
cs
)
}
)
;
}
static
SkImageInfo
Make
(
SkISize
dimensions
SkColorType
ct
SkAlphaType
at
sk_sp
<
SkColorSpace
>
cs
=
nullptr
)
{
return
SkImageInfo
(
dimensions
{
ct
at
std
:
:
move
(
cs
)
}
)
;
}
static
SkImageInfo
Make
(
SkISize
dimensions
const
SkColorInfo
&
colorInfo
)
{
return
SkImageInfo
(
dimensions
colorInfo
)
;
}
static
SkImageInfo
Make
(
SkISize
dimensions
SkColorInfo
&
&
colorInfo
)
{
return
SkImageInfo
(
dimensions
std
:
:
move
(
colorInfo
)
)
;
}
static
SkImageInfo
MakeN32
(
int
width
int
height
SkAlphaType
at
sk_sp
<
SkColorSpace
>
cs
=
nullptr
)
{
return
Make
(
{
width
height
}
kN32_SkColorType
at
std
:
:
move
(
cs
)
)
;
}
static
SkImageInfo
MakeS32
(
int
width
int
height
SkAlphaType
at
)
;
static
SkImageInfo
MakeN32Premul
(
int
width
int
height
sk_sp
<
SkColorSpace
>
cs
=
nullptr
)
{
return
Make
(
{
width
height
}
kN32_SkColorType
kPremul_SkAlphaType
std
:
:
move
(
cs
)
)
;
}
static
SkImageInfo
MakeN32Premul
(
const
SkISize
&
size
)
{
return
MakeN32Premul
(
size
.
width
(
)
size
.
height
(
)
)
;
}
static
SkImageInfo
MakeA8
(
int
width
int
height
)
{
return
Make
(
{
width
height
}
kAlpha_8_SkColorType
kPremul_SkAlphaType
nullptr
)
;
}
static
SkImageInfo
MakeUnknown
(
int
width
int
height
)
{
return
Make
(
{
width
height
}
kUnknown_SkColorType
kUnknown_SkAlphaType
nullptr
)
;
}
static
SkImageInfo
MakeUnknown
(
)
{
return
MakeUnknown
(
0
0
)
;
}
int
width
(
)
const
{
return
fDimensions
.
width
(
)
;
}
int
height
(
)
const
{
return
fDimensions
.
height
(
)
;
}
SkColorType
colorType
(
)
const
{
return
fColorInfo
.
colorType
(
)
;
}
SkAlphaType
alphaType
(
)
const
{
return
fColorInfo
.
alphaType
(
)
;
}
SkColorSpace
*
colorSpace
(
)
const
{
return
fColorInfo
.
colorSpace
(
)
;
}
sk_sp
<
SkColorSpace
>
refColorSpace
(
)
const
{
return
fColorInfo
.
refColorSpace
(
)
;
}
bool
isEmpty
(
)
const
{
return
fDimensions
.
isEmpty
(
)
;
}
const
SkColorInfo
&
colorInfo
(
)
const
{
return
fColorInfo
;
}
bool
isOpaque
(
)
const
{
return
fColorInfo
.
isOpaque
(
)
;
}
SkISize
dimensions
(
)
const
{
return
fDimensions
;
}
SkIRect
bounds
(
)
const
{
return
SkIRect
:
:
MakeSize
(
fDimensions
)
;
}
bool
gammaCloseToSRGB
(
)
const
{
return
fColorInfo
.
gammaCloseToSRGB
(
)
;
}
SkImageInfo
makeWH
(
int
newWidth
int
newHeight
)
const
{
return
Make
(
{
newWidth
newHeight
}
fColorInfo
)
;
}
SkImageInfo
makeDimensions
(
SkISize
newSize
)
const
{
return
Make
(
newSize
fColorInfo
)
;
}
SkImageInfo
makeAlphaType
(
SkAlphaType
newAlphaType
)
const
{
return
Make
(
fDimensions
fColorInfo
.
makeAlphaType
(
newAlphaType
)
)
;
}
SkImageInfo
makeColorType
(
SkColorType
newColorType
)
const
{
return
Make
(
fDimensions
fColorInfo
.
makeColorType
(
newColorType
)
)
;
}
SkImageInfo
makeColorSpace
(
sk_sp
<
SkColorSpace
>
cs
)
const
{
return
Make
(
fDimensions
fColorInfo
.
makeColorSpace
(
std
:
:
move
(
cs
)
)
)
;
}
int
bytesPerPixel
(
)
const
{
return
fColorInfo
.
bytesPerPixel
(
)
;
}
int
shiftPerPixel
(
)
const
{
return
fColorInfo
.
shiftPerPixel
(
)
;
}
uint64_t
minRowBytes64
(
)
const
{
return
sk_64_mul
(
this
-
>
width
(
)
this
-
>
bytesPerPixel
(
)
)
;
}
size_t
minRowBytes
(
)
const
{
uint64_t
minRowBytes
=
this
-
>
minRowBytes64
(
)
;
if
(
!
SkTFitsIn
<
int32_t
>
(
minRowBytes
)
)
{
return
0
;
}
return
SkTo
<
int32_t
>
(
minRowBytes
)
;
}
size_t
computeOffset
(
int
x
int
y
size_t
rowBytes
)
const
;
bool
operator
=
=
(
const
SkImageInfo
&
other
)
const
{
return
fDimensions
=
=
other
.
fDimensions
&
&
fColorInfo
=
=
other
.
fColorInfo
;
}
bool
operator
!
=
(
const
SkImageInfo
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
size_t
computeByteSize
(
size_t
rowBytes
)
const
;
size_t
computeMinByteSize
(
)
const
{
return
this
-
>
computeByteSize
(
this
-
>
minRowBytes
(
)
)
;
}
static
bool
ByteSizeOverflowed
(
size_t
byteSize
)
{
return
SIZE_MAX
=
=
byteSize
;
}
bool
validRowBytes
(
size_t
rowBytes
)
const
{
return
rowBytes
>
=
this
-
>
minRowBytes64
(
)
;
}
void
reset
(
)
{
*
this
=
{
}
;
}
SkDEBUGCODE
(
void
validate
(
)
const
;
)
private
:
SkColorInfo
fColorInfo
;
SkISize
fDimensions
=
{
0
0
}
;
SkImageInfo
(
SkISize
dimensions
const
SkColorInfo
&
colorInfo
)
:
fColorInfo
(
colorInfo
)
fDimensions
(
dimensions
)
{
}
SkImageInfo
(
SkISize
dimensions
SkColorInfo
&
&
colorInfo
)
:
fColorInfo
(
std
:
:
move
(
colorInfo
)
)
fDimensions
(
dimensions
)
{
}
}
;
#
endif
