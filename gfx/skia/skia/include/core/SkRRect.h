#
ifndef
SkRRect_DEFINED
#
define
SkRRect_DEFINED
#
include
"
SkRect
.
h
"
#
include
"
SkPoint
.
h
"
class
SkPath
;
class
SkMatrix
;
class
SK_API
SkRRect
{
public
:
enum
Type
{
kEmpty_Type
kRect_Type
kOval_Type
kSimple_Type
kNinePatch_Type
kComplex_Type
}
;
Type
getType
(
)
const
{
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
return
static_cast
<
Type
>
(
fType
)
;
}
Type
type
(
)
const
{
return
this
-
>
getType
(
)
;
}
inline
bool
isEmpty
(
)
const
{
return
kEmpty_Type
=
=
this
-
>
getType
(
)
;
}
inline
bool
isRect
(
)
const
{
return
kRect_Type
=
=
this
-
>
getType
(
)
;
}
inline
bool
isOval
(
)
const
{
return
kOval_Type
=
=
this
-
>
getType
(
)
;
}
inline
bool
isSimple
(
)
const
{
return
kSimple_Type
=
=
this
-
>
getType
(
)
;
}
inline
bool
isSimpleCircular
(
)
const
{
return
this
-
>
isSimple
(
)
&
&
SkScalarNearlyEqual
(
fRadii
[
0
]
.
fX
fRadii
[
0
]
.
fY
)
;
}
inline
bool
isCircle
(
)
const
{
return
this
-
>
isOval
(
)
&
&
SkScalarNearlyEqual
(
fRadii
[
0
]
.
fX
fRadii
[
0
]
.
fY
)
;
}
inline
bool
isNinePatch
(
)
const
{
return
kNinePatch_Type
=
=
this
-
>
getType
(
)
;
}
inline
bool
isComplex
(
)
const
{
return
kComplex_Type
=
=
this
-
>
getType
(
)
;
}
bool
allCornersCircular
(
)
const
;
SkScalar
width
(
)
const
{
return
fRect
.
width
(
)
;
}
SkScalar
height
(
)
const
{
return
fRect
.
height
(
)
;
}
void
setEmpty
(
)
{
fRect
.
setEmpty
(
)
;
memset
(
fRadii
0
sizeof
(
fRadii
)
)
;
fType
=
kEmpty_Type
;
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
void
setRect
(
const
SkRect
&
rect
)
{
fRect
=
rect
;
fRect
.
sort
(
)
;
if
(
fRect
.
isEmpty
(
)
)
{
this
-
>
setEmpty
(
)
;
return
;
}
memset
(
fRadii
0
sizeof
(
fRadii
)
)
;
fType
=
kRect_Type
;
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
static
SkRRect
MakeRect
(
const
SkRect
&
r
)
{
SkRRect
rr
;
rr
.
setRect
(
r
)
;
return
rr
;
}
static
SkRRect
MakeOval
(
const
SkRect
&
oval
)
{
SkRRect
rr
;
rr
.
setOval
(
oval
)
;
return
rr
;
}
static
SkRRect
MakeRectXY
(
const
SkRect
&
rect
SkScalar
xRad
SkScalar
yRad
)
{
SkRRect
rr
;
rr
.
setRectXY
(
rect
xRad
yRad
)
;
return
rr
;
}
void
setOval
(
const
SkRect
&
oval
)
{
fRect
=
oval
;
fRect
.
sort
(
)
;
if
(
fRect
.
isEmpty
(
)
)
{
this
-
>
setEmpty
(
)
;
return
;
}
SkScalar
xRad
=
SkScalarHalf
(
fRect
.
width
(
)
)
;
SkScalar
yRad
=
SkScalarHalf
(
fRect
.
height
(
)
)
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
fRadii
[
i
]
.
set
(
xRad
yRad
)
;
}
fType
=
kOval_Type
;
SkDEBUGCODE
(
this
-
>
validate
(
)
;
)
}
void
setRectXY
(
const
SkRect
&
rect
SkScalar
xRad
SkScalar
yRad
)
;
void
setNinePatch
(
const
SkRect
&
rect
SkScalar
leftRad
SkScalar
topRad
SkScalar
rightRad
SkScalar
bottomRad
)
;
void
setRectRadii
(
const
SkRect
&
rect
const
SkVector
radii
[
4
]
)
;
enum
Corner
{
kUpperLeft_Corner
kUpperRight_Corner
kLowerRight_Corner
kLowerLeft_Corner
}
;
const
SkRect
&
rect
(
)
const
{
return
fRect
;
}
const
SkVector
&
radii
(
Corner
corner
)
const
{
return
fRadii
[
corner
]
;
}
const
SkRect
&
getBounds
(
)
const
{
return
fRect
;
}
const
SkVector
&
getSimpleRadii
(
)
const
{
SkASSERT
(
!
this
-
>
isComplex
(
)
)
;
return
fRadii
[
0
]
;
}
friend
bool
operator
=
=
(
const
SkRRect
&
a
const
SkRRect
&
b
)
{
return
a
.
fRect
=
=
b
.
fRect
&
&
SkScalarsEqual
(
a
.
fRadii
[
0
]
.
asScalars
(
)
b
.
fRadii
[
0
]
.
asScalars
(
)
8
)
;
}
friend
bool
operator
!
=
(
const
SkRRect
&
a
const
SkRRect
&
b
)
{
return
a
.
fRect
!
=
b
.
fRect
|
|
!
SkScalarsEqual
(
a
.
fRadii
[
0
]
.
asScalars
(
)
b
.
fRadii
[
0
]
.
asScalars
(
)
8
)
;
}
void
inset
(
SkScalar
dx
SkScalar
dy
SkRRect
*
dst
)
const
;
void
inset
(
SkScalar
dx
SkScalar
dy
)
{
this
-
>
inset
(
dx
dy
this
)
;
}
void
outset
(
SkScalar
dx
SkScalar
dy
SkRRect
*
dst
)
const
{
this
-
>
inset
(
-
dx
-
dy
dst
)
;
}
void
outset
(
SkScalar
dx
SkScalar
dy
)
{
this
-
>
inset
(
-
dx
-
dy
this
)
;
}
void
offset
(
SkScalar
dx
SkScalar
dy
)
{
fRect
.
offset
(
dx
dy
)
;
}
bool
contains
(
const
SkRect
&
rect
)
const
;
SkDEBUGCODE
(
void
validate
(
)
const
;
)
enum
{
kSizeInMemory
=
12
*
sizeof
(
SkScalar
)
}
;
size_t
writeToMemory
(
void
*
buffer
)
const
;
size_t
readFromMemory
(
const
void
*
buffer
size_t
length
)
;
bool
transform
(
const
SkMatrix
&
matrix
SkRRect
*
dst
)
const
;
void
dump
(
bool
asHex
)
const
;
void
dump
(
)
const
{
this
-
>
dump
(
false
)
;
}
void
dumpHex
(
)
const
{
this
-
>
dump
(
true
)
;
}
private
:
SkRect
fRect
;
SkVector
fRadii
[
4
]
;
int32_t
fType
;
void
computeType
(
)
;
bool
checkCornerContainment
(
SkScalar
x
SkScalar
y
)
const
;
void
scaleRadii
(
)
;
friend
class
SkPath
;
}
;
#
endif
