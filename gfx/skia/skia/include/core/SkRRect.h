#
ifndef
SkRRect_DEFINED
#
define
SkRRect_DEFINED
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkRect
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
<
cstdint
>
#
include
<
cstring
>
class
SkMatrix
;
class
SkString
;
class
SK_API
SkRRect
{
public
:
SkRRect
(
)
=
default
;
SkRRect
(
const
SkRRect
&
rrect
)
=
default
;
SkRRect
&
operator
=
(
const
SkRRect
&
rrect
)
=
default
;
enum
Type
{
kEmpty_Type
kRect_Type
kOval_Type
kSimple_Type
kNinePatch_Type
kComplex_Type
kLastType
=
kComplex_Type
}
;
Type
getType
(
)
const
{
SkASSERT
(
this
-
>
isValid
(
)
)
;
return
static_cast
<
Type
>
(
fType
)
;
}
Type
type
(
)
const
{
return
this
-
>
getType
(
)
;
}
inline
bool
isEmpty
(
)
const
{
return
kEmpty_Type
=
=
this
-
>
getType
(
)
;
}
inline
bool
isRect
(
)
const
{
return
kRect_Type
=
=
this
-
>
getType
(
)
;
}
inline
bool
isOval
(
)
const
{
return
kOval_Type
=
=
this
-
>
getType
(
)
;
}
inline
bool
isSimple
(
)
const
{
return
kSimple_Type
=
=
this
-
>
getType
(
)
;
}
inline
bool
isNinePatch
(
)
const
{
return
kNinePatch_Type
=
=
this
-
>
getType
(
)
;
}
inline
bool
isComplex
(
)
const
{
return
kComplex_Type
=
=
this
-
>
getType
(
)
;
}
SkScalar
width
(
)
const
{
return
fRect
.
width
(
)
;
}
SkScalar
height
(
)
const
{
return
fRect
.
height
(
)
;
}
SkVector
getSimpleRadii
(
)
const
{
return
fRadii
[
0
]
;
}
void
setEmpty
(
)
{
*
this
=
SkRRect
(
)
;
}
void
setRect
(
const
SkRect
&
rect
)
{
if
(
!
this
-
>
initializeRect
(
rect
)
)
{
return
;
}
memset
(
fRadii
0
sizeof
(
fRadii
)
)
;
fType
=
kRect_Type
;
SkASSERT
(
this
-
>
isValid
(
)
)
;
}
static
SkRRect
MakeEmpty
(
)
{
return
SkRRect
(
)
;
}
static
SkRRect
MakeRect
(
const
SkRect
&
r
)
{
SkRRect
rr
;
rr
.
setRect
(
r
)
;
return
rr
;
}
static
SkRRect
MakeOval
(
const
SkRect
&
oval
)
{
SkRRect
rr
;
rr
.
setOval
(
oval
)
;
return
rr
;
}
static
SkRRect
MakeRectXY
(
const
SkRect
&
rect
SkScalar
xRad
SkScalar
yRad
)
{
SkRRect
rr
;
rr
.
setRectXY
(
rect
xRad
yRad
)
;
return
rr
;
}
void
setOval
(
const
SkRect
&
oval
)
;
void
setRectXY
(
const
SkRect
&
rect
SkScalar
xRad
SkScalar
yRad
)
;
void
setNinePatch
(
const
SkRect
&
rect
SkScalar
leftRad
SkScalar
topRad
SkScalar
rightRad
SkScalar
bottomRad
)
;
void
setRectRadii
(
const
SkRect
&
rect
const
SkVector
radii
[
4
]
)
;
enum
Corner
{
kUpperLeft_Corner
kUpperRight_Corner
kLowerRight_Corner
kLowerLeft_Corner
}
;
const
SkRect
&
rect
(
)
const
{
return
fRect
;
}
SkVector
radii
(
Corner
corner
)
const
{
return
fRadii
[
corner
]
;
}
const
SkRect
&
getBounds
(
)
const
{
return
fRect
;
}
friend
bool
operator
=
=
(
const
SkRRect
&
a
const
SkRRect
&
b
)
{
return
a
.
fRect
=
=
b
.
fRect
&
&
SkScalarsEqual
(
&
a
.
fRadii
[
0
]
.
fX
&
b
.
fRadii
[
0
]
.
fX
8
)
;
}
friend
bool
operator
!
=
(
const
SkRRect
&
a
const
SkRRect
&
b
)
{
return
a
.
fRect
!
=
b
.
fRect
|
|
!
SkScalarsEqual
(
&
a
.
fRadii
[
0
]
.
fX
&
b
.
fRadii
[
0
]
.
fX
8
)
;
}
void
inset
(
SkScalar
dx
SkScalar
dy
SkRRect
*
dst
)
const
;
void
inset
(
SkScalar
dx
SkScalar
dy
)
{
this
-
>
inset
(
dx
dy
this
)
;
}
void
outset
(
SkScalar
dx
SkScalar
dy
SkRRect
*
dst
)
const
{
this
-
>
inset
(
-
dx
-
dy
dst
)
;
}
void
outset
(
SkScalar
dx
SkScalar
dy
)
{
this
-
>
inset
(
-
dx
-
dy
this
)
;
}
void
offset
(
SkScalar
dx
SkScalar
dy
)
{
fRect
.
offset
(
dx
dy
)
;
}
SkRRect
SK_WARN_UNUSED_RESULT
makeOffset
(
SkScalar
dx
SkScalar
dy
)
const
{
return
SkRRect
(
fRect
.
makeOffset
(
dx
dy
)
fRadii
fType
)
;
}
bool
contains
(
const
SkRect
&
rect
)
const
;
bool
isValid
(
)
const
;
static
constexpr
size_t
kSizeInMemory
=
12
*
sizeof
(
SkScalar
)
;
size_t
writeToMemory
(
void
*
buffer
)
const
;
size_t
readFromMemory
(
const
void
*
buffer
size_t
length
)
;
bool
transform
(
const
SkMatrix
&
matrix
SkRRect
*
dst
)
const
;
void
dump
(
bool
asHex
)
const
;
SkString
dumpToString
(
bool
asHex
)
const
;
void
dump
(
)
const
{
this
-
>
dump
(
false
)
;
}
void
dumpHex
(
)
const
{
this
-
>
dump
(
true
)
;
}
private
:
static
bool
AreRectAndRadiiValid
(
const
SkRect
&
const
SkVector
[
4
]
)
;
SkRRect
(
const
SkRect
&
rect
const
SkVector
radii
[
4
]
int32_t
type
)
:
fRect
(
rect
)
fRadii
{
radii
[
0
]
radii
[
1
]
radii
[
2
]
radii
[
3
]
}
fType
(
type
)
{
}
bool
initializeRect
(
const
SkRect
&
)
;
void
computeType
(
)
;
bool
checkCornerContainment
(
SkScalar
x
SkScalar
y
)
const
;
bool
scaleRadii
(
)
;
SkRect
fRect
=
SkRect
:
:
MakeEmpty
(
)
;
SkVector
fRadii
[
4
]
=
{
{
0
0
}
{
0
0
}
{
0
0
}
{
0
0
}
}
;
int32_t
fType
=
kEmpty_Type
;
friend
class
SkPath
;
friend
class
SkRRectPriv
;
}
;
#
endif
