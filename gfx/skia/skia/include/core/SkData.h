#
ifndef
SkData_DEFINED
#
define
SkData_DEFINED
#
include
<
stdio
.
h
>
#
include
"
SkRefCnt
.
h
"
class
SkStream
;
#
define
SK_SUPPORT_LEGACY_DATA_FACTORIES
class
SK_API
SkData
:
public
SkRefCnt
{
public
:
size_t
size
(
)
const
{
return
fSize
;
}
bool
isEmpty
(
)
const
{
return
0
=
=
fSize
;
}
const
void
*
data
(
)
const
{
return
fPtr
;
}
const
uint8_t
*
bytes
(
)
const
{
return
reinterpret_cast
<
const
uint8_t
*
>
(
fPtr
)
;
}
void
*
writable_data
(
)
{
if
(
fSize
)
{
SkASSERT
(
this
-
>
unique
(
)
)
;
}
return
fPtr
;
}
size_t
copyRange
(
size_t
offset
size_t
length
void
*
buffer
)
const
;
bool
equals
(
const
SkData
*
other
)
const
;
bool
equals
(
sk_sp
<
const
SkData
>
&
other
)
const
{
return
this
-
>
equals
(
other
.
get
(
)
)
;
}
typedef
void
(
*
ReleaseProc
)
(
const
void
*
ptr
void
*
context
)
;
static
sk_sp
<
SkData
>
MakeWithCopy
(
const
void
*
data
size_t
length
)
;
static
sk_sp
<
SkData
>
MakeUninitialized
(
size_t
length
)
;
static
sk_sp
<
SkData
>
MakeWithCString
(
const
char
cstr
[
]
)
;
static
sk_sp
<
SkData
>
MakeWithProc
(
const
void
*
ptr
size_t
length
ReleaseProc
proc
void
*
ctx
)
;
static
sk_sp
<
SkData
>
MakeWithoutCopy
(
const
void
*
data
size_t
length
)
{
return
MakeWithProc
(
data
length
DummyReleaseProc
nullptr
)
;
}
static
sk_sp
<
SkData
>
MakeFromMalloc
(
const
void
*
data
size_t
length
)
;
static
sk_sp
<
SkData
>
MakeFromFileName
(
const
char
path
[
]
)
;
static
sk_sp
<
SkData
>
MakeFromFILE
(
FILE
*
f
)
;
static
sk_sp
<
SkData
>
MakeFromFD
(
int
fd
)
;
static
sk_sp
<
SkData
>
MakeFromStream
(
SkStream
*
size_t
size
)
;
static
sk_sp
<
SkData
>
MakeSubset
(
const
SkData
*
src
size_t
offset
size_t
length
)
;
static
sk_sp
<
SkData
>
MakeEmpty
(
)
;
#
ifdef
SK_SUPPORT_LEGACY_DATA_FACTORIES
static
SkData
*
NewWithCopy
(
const
void
*
data
size_t
length
)
{
return
MakeWithCopy
(
data
length
)
.
release
(
)
;
}
static
SkData
*
NewUninitialized
(
size_t
length
)
{
return
MakeUninitialized
(
length
)
.
release
(
)
;
}
static
SkData
*
NewWithCString
(
const
char
cstr
[
]
)
{
return
MakeWithCString
(
cstr
)
.
release
(
)
;
}
static
SkData
*
NewWithProc
(
const
void
*
ptr
size_t
length
ReleaseProc
proc
void
*
context
)
{
return
MakeWithProc
(
ptr
length
proc
context
)
.
release
(
)
;
}
static
SkData
*
NewWithoutCopy
(
const
void
*
data
size_t
length
)
{
return
MakeWithoutCopy
(
data
length
)
.
release
(
)
;
}
static
SkData
*
NewFromMalloc
(
const
void
*
data
size_t
length
)
{
return
MakeFromMalloc
(
data
length
)
.
release
(
)
;
}
static
SkData
*
NewFromFileName
(
const
char
path
[
]
)
{
return
MakeFromFileName
(
path
)
.
release
(
)
;
}
static
SkData
*
NewFromFILE
(
FILE
*
f
)
{
return
MakeFromFILE
(
f
)
.
release
(
)
;
}
static
SkData
*
NewFromFD
(
int
fd
)
{
return
MakeFromFD
(
fd
)
.
release
(
)
;
}
static
SkData
*
NewFromStream
(
SkStream
*
stream
size_t
size
)
{
return
MakeFromStream
(
stream
size
)
.
release
(
)
;
}
static
SkData
*
NewSubset
(
const
SkData
*
src
size_t
offset
size_t
length
)
{
return
MakeSubset
(
src
offset
length
)
.
release
(
)
;
}
static
SkData
*
NewEmpty
(
)
{
return
MakeEmpty
(
)
.
release
(
)
;
}
#
endif
private
:
ReleaseProc
fReleaseProc
;
void
*
fReleaseProcContext
;
void
*
fPtr
;
size_t
fSize
;
SkData
(
const
void
*
ptr
size_t
size
ReleaseProc
void
*
context
)
;
explicit
SkData
(
size_t
size
)
;
virtual
~
SkData
(
)
;
void
*
operator
new
(
size_t
size
)
{
return
sk_malloc_throw
(
size
)
;
}
void
*
operator
new
(
size_t
void
*
p
)
{
return
p
;
}
void
operator
delete
(
void
*
p
)
{
sk_free
(
p
)
;
}
friend
SkData
*
sk_new_empty_data
(
)
;
static
sk_sp
<
SkData
>
PrivateNewWithCopy
(
const
void
*
srcOrNull
size_t
length
)
;
static
void
DummyReleaseProc
(
const
void
*
void
*
)
{
}
typedef
SkRefCnt
INHERITED
;
}
;
#
ifdef
SK_SUPPORT_LEGACY_DATA_FACTORIES
typedef
SkAutoTUnref
<
SkData
>
SkAutoDataUnref
;
#
endif
#
endif
