#
ifndef
SkSurface_DEFINED
#
define
SkSurface_DEFINED
#
include
"
SkRefCnt
.
h
"
#
include
"
SkImage
.
h
"
#
include
"
SkSurfaceProps
.
h
"
class
SkCanvas
;
class
SkPaint
;
class
GrContext
;
class
GrRenderTarget
;
class
SK_API
SkSurface
:
public
SkRefCnt
{
public
:
static
sk_sp
<
SkSurface
>
MakeRasterDirect
(
const
SkImageInfo
&
void
*
pixels
size_t
rowBytes
const
SkSurfaceProps
*
=
nullptr
)
;
static
sk_sp
<
SkSurface
>
MakeRasterDirectReleaseProc
(
const
SkImageInfo
&
void
*
pixels
size_t
rowBytes
void
(
*
releaseProc
)
(
void
*
pixels
void
*
context
)
void
*
context
const
SkSurfaceProps
*
=
nullptr
)
;
static
sk_sp
<
SkSurface
>
MakeRaster
(
const
SkImageInfo
&
size_t
rowBytes
const
SkSurfaceProps
*
)
;
static
sk_sp
<
SkSurface
>
MakeRaster
(
const
SkImageInfo
&
info
const
SkSurfaceProps
*
props
=
nullptr
)
{
return
MakeRaster
(
info
0
props
)
;
}
static
sk_sp
<
SkSurface
>
MakeRasterN32Premul
(
int
width
int
height
const
SkSurfaceProps
*
props
=
nullptr
)
{
return
MakeRaster
(
SkImageInfo
:
:
MakeN32Premul
(
width
height
)
props
)
;
}
static
sk_sp
<
SkSurface
>
MakeFromBackendTexture
(
GrContext
*
const
GrBackendTextureDesc
&
sk_sp
<
SkColorSpace
>
const
SkSurfaceProps
*
)
;
static
sk_sp
<
SkSurface
>
MakeFromBackendRenderTarget
(
GrContext
*
const
GrBackendRenderTargetDesc
&
sk_sp
<
SkColorSpace
>
const
SkSurfaceProps
*
)
;
static
sk_sp
<
SkSurface
>
MakeFromBackendTextureAsRenderTarget
(
GrContext
*
const
GrBackendTextureDesc
&
sk_sp
<
SkColorSpace
>
const
SkSurfaceProps
*
)
;
static
sk_sp
<
SkSurface
>
MakeFromBackendTexture
(
GrContext
*
ctx
const
GrBackendTextureDesc
&
desc
const
SkSurfaceProps
*
props
)
{
return
MakeFromBackendTexture
(
ctx
desc
nullptr
props
)
;
}
static
sk_sp
<
SkSurface
>
MakeFromBackendRenderTarget
(
GrContext
*
ctx
const
GrBackendRenderTargetDesc
&
desc
const
SkSurfaceProps
*
props
)
{
return
MakeFromBackendRenderTarget
(
ctx
desc
nullptr
props
)
;
}
static
sk_sp
<
SkSurface
>
MakeFromBackendTextureAsRenderTarget
(
GrContext
*
ctx
const
GrBackendTextureDesc
&
desc
const
SkSurfaceProps
*
props
)
{
return
MakeFromBackendTextureAsRenderTarget
(
ctx
desc
nullptr
props
)
;
}
static
sk_sp
<
SkSurface
>
MakeRenderTarget
(
GrContext
*
SkBudgeted
const
SkImageInfo
&
int
sampleCount
GrSurfaceOrigin
const
SkSurfaceProps
*
)
;
static
sk_sp
<
SkSurface
>
MakeRenderTarget
(
GrContext
*
context
SkBudgeted
budgeted
const
SkImageInfo
&
info
int
sampleCount
const
SkSurfaceProps
*
props
)
{
return
MakeRenderTarget
(
context
budgeted
info
sampleCount
kBottomLeft_GrSurfaceOrigin
props
)
;
}
static
sk_sp
<
SkSurface
>
MakeRenderTarget
(
GrContext
*
gr
SkBudgeted
b
const
SkImageInfo
&
info
)
{
return
MakeRenderTarget
(
gr
b
info
0
kBottomLeft_GrSurfaceOrigin
nullptr
)
;
}
#
ifdef
SK_SUPPORT_LEGACY_NEW_SURFACE_API
static
SkSurface
*
NewRasterDirect
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
const
SkSurfaceProps
*
props
=
NULL
)
{
return
MakeRasterDirect
(
info
pixels
rowBytes
props
)
.
release
(
)
;
}
static
SkSurface
*
NewRasterDirectReleaseProc
(
const
SkImageInfo
&
info
void
*
pixels
size_t
rowBytes
void
(
*
releaseProc
)
(
void
*
pixels
void
*
context
)
void
*
context
const
SkSurfaceProps
*
props
=
NULL
)
{
return
MakeRasterDirectReleaseProc
(
info
pixels
rowBytes
releaseProc
context
props
)
.
release
(
)
;
}
static
SkSurface
*
NewRaster
(
const
SkImageInfo
&
info
size_t
rowBytes
const
SkSurfaceProps
*
props
)
{
return
MakeRaster
(
info
rowBytes
props
)
.
release
(
)
;
}
static
SkSurface
*
NewRaster
(
const
SkImageInfo
&
info
const
SkSurfaceProps
*
props
=
NULL
)
{
return
MakeRaster
(
info
props
)
.
release
(
)
;
}
static
SkSurface
*
NewRasterN32Premul
(
int
width
int
height
const
SkSurfaceProps
*
props
=
NULL
)
{
return
NewRaster
(
SkImageInfo
:
:
MakeN32Premul
(
width
height
)
props
)
;
}
static
SkSurface
*
NewFromBackendTexture
(
GrContext
*
ctx
const
GrBackendTextureDesc
&
desc
const
SkSurfaceProps
*
props
)
{
return
MakeFromBackendTexture
(
ctx
desc
props
)
.
release
(
)
;
}
static
SkSurface
*
NewWrappedRenderTarget
(
GrContext
*
ctx
const
GrBackendTextureDesc
&
desc
const
SkSurfaceProps
*
props
)
{
return
NewFromBackendTexture
(
ctx
desc
props
)
;
}
static
SkSurface
*
NewFromBackendRenderTarget
(
GrContext
*
ctx
const
GrBackendRenderTargetDesc
&
d
const
SkSurfaceProps
*
props
)
{
return
MakeFromBackendRenderTarget
(
ctx
d
props
)
.
release
(
)
;
}
static
SkSurface
*
NewFromBackendTextureAsRenderTarget
(
GrContext
*
ctx
const
GrBackendTextureDesc
&
desc
const
SkSurfaceProps
*
props
)
{
return
MakeFromBackendTextureAsRenderTarget
(
ctx
desc
props
)
.
release
(
)
;
}
static
SkSurface
*
NewRenderTarget
(
GrContext
*
ctx
SkBudgeted
b
const
SkImageInfo
&
info
int
sampleCount
const
SkSurfaceProps
*
props
=
NULL
)
{
return
MakeRenderTarget
(
ctx
b
info
sampleCount
props
)
.
release
(
)
;
}
static
SkSurface
*
NewRenderTarget
(
GrContext
*
gr
SkBudgeted
b
const
SkImageInfo
&
info
)
{
return
NewRenderTarget
(
gr
b
info
0
)
;
}
SkSurface
*
newSurface
(
const
SkImageInfo
&
info
)
{
return
this
-
>
makeSurface
(
info
)
.
release
(
)
;
}
#
endif
int
width
(
)
const
{
return
fWidth
;
}
int
height
(
)
const
{
return
fHeight
;
}
uint32_t
generationID
(
)
;
enum
ContentChangeMode
{
kDiscard_ContentChangeMode
kRetain_ContentChangeMode
}
;
void
notifyContentWillChange
(
ContentChangeMode
mode
)
;
enum
BackendHandleAccess
{
kFlushRead_BackendHandleAccess
kFlushWrite_BackendHandleAccess
kDiscardWrite_BackendHandleAccess
}
;
static
const
BackendHandleAccess
kFlushRead_TextureHandleAccess
=
kFlushRead_BackendHandleAccess
;
static
const
BackendHandleAccess
kFlushWrite_TextureHandleAccess
=
kFlushWrite_BackendHandleAccess
;
static
const
BackendHandleAccess
kDiscardWrite_TextureHandleAccess
=
kDiscardWrite_BackendHandleAccess
;
GrBackendObject
getTextureHandle
(
BackendHandleAccess
)
;
bool
getRenderTargetHandle
(
GrBackendObject
*
BackendHandleAccess
)
;
SkCanvas
*
getCanvas
(
)
;
sk_sp
<
SkSurface
>
makeSurface
(
const
SkImageInfo
&
)
;
sk_sp
<
SkImage
>
makeImageSnapshot
(
SkBudgeted
=
SkBudgeted
:
:
kYes
)
;
enum
ForceUnique
{
kNo_ForceUnique
kYes_ForceUnique
}
;
sk_sp
<
SkImage
>
makeImageSnapshot
(
SkBudgeted
ForceUnique
)
;
#
ifdef
SK_SUPPORT_LEGACY_IMAGEFACTORY
SkImage
*
newImageSnapshot
(
SkBudgeted
budgeted
=
SkBudgeted
:
:
kYes
)
{
return
this
-
>
makeImageSnapshot
(
budgeted
)
.
release
(
)
;
}
SkImage
*
newImageSnapshot
(
SkBudgeted
budgeted
ForceUnique
force
)
{
return
this
-
>
makeImageSnapshot
(
budgeted
force
)
.
release
(
)
;
}
#
endif
void
draw
(
SkCanvas
*
SkScalar
x
SkScalar
y
const
SkPaint
*
)
;
bool
peekPixels
(
SkPixmap
*
)
;
#
ifdef
SK_SUPPORT_LEGACY_PEEKPIXELS_PARMS
const
void
*
peekPixels
(
SkImageInfo
*
info
size_t
*
rowBytes
)
;
#
endif
bool
readPixels
(
const
SkImageInfo
&
dstInfo
void
*
dstPixels
size_t
dstRowBytes
int
srcX
int
srcY
)
;
const
SkSurfaceProps
&
props
(
)
const
{
return
fProps
;
}
void
prepareForExternalIO
(
)
;
protected
:
SkSurface
(
int
width
int
height
const
SkSurfaceProps
*
)
;
SkSurface
(
const
SkImageInfo
&
const
SkSurfaceProps
*
)
;
void
dirtyGenerationID
(
)
{
fGenerationID
=
0
;
}
private
:
const
SkSurfaceProps
fProps
;
const
int
fWidth
;
const
int
fHeight
;
uint32_t
fGenerationID
;
typedef
SkRefCnt
INHERITED
;
}
;
#
endif
