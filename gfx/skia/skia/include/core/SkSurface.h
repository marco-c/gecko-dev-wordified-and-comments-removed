#
ifndef
SkSurface_DEFINED
#
define
SkSurface_DEFINED
#
include
"
include
/
core
/
SkImage
.
h
"
#
include
"
include
/
core
/
SkImageInfo
.
h
"
#
include
"
include
/
core
/
SkPixmap
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSamplingOptions
.
h
"
#
include
"
include
/
core
/
SkScalar
.
h
"
#
include
"
include
/
core
/
SkSurfaceProps
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
if
defined
(
SK_GANESH
)
#
include
"
include
/
gpu
/
GrTypes
.
h
"
#
else
enum
GrSurfaceOrigin
:
int
;
#
endif
#
if
defined
(
SK_GRAPHITE
)
#
include
"
include
/
gpu
/
GpuTypes
.
h
"
namespace
skgpu
:
:
graphite
{
class
BackendTexture
;
}
#
endif
#
if
defined
(
SK_BUILD_FOR_ANDROID
)
&
&
__ANDROID_API__
>
=
26
#
include
<
android
/
hardware_buffer
.
h
>
class
GrDirectContext
;
#
endif
#
if
defined
(
SK_GANESH
)
&
&
defined
(
SK_METAL
)
#
include
"
include
/
gpu
/
mtl
/
GrMtlTypes
.
h
"
#
endif
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
memory
>
class
GrBackendRenderTarget
;
class
GrBackendSemaphore
;
class
GrBackendTexture
;
class
GrRecordingContext
;
class
SkBitmap
;
class
SkCanvas
;
class
SkCapabilities
;
class
SkColorSpace
;
class
SkDeferredDisplayList
;
class
SkPaint
;
class
SkSurfaceCharacterization
;
enum
SkColorType
:
int
;
struct
SkIRect
;
struct
SkISize
;
namespace
skgpu
{
class
MutableTextureState
;
enum
class
Budgeted
:
bool
;
}
namespace
skgpu
:
:
graphite
{
class
Recorder
;
}
class
SK_API
SkSurface
:
public
SkRefCnt
{
public
:
static
sk_sp
<
SkSurface
>
MakeRasterDirect
(
const
SkImageInfo
&
imageInfo
void
*
pixels
size_t
rowBytes
const
SkSurfaceProps
*
surfaceProps
=
nullptr
)
;
static
sk_sp
<
SkSurface
>
MakeRasterDirect
(
const
SkPixmap
&
pm
const
SkSurfaceProps
*
props
=
nullptr
)
{
return
MakeRasterDirect
(
pm
.
info
(
)
pm
.
writable_addr
(
)
pm
.
rowBytes
(
)
props
)
;
}
static
sk_sp
<
SkSurface
>
MakeRasterDirectReleaseProc
(
const
SkImageInfo
&
imageInfo
void
*
pixels
size_t
rowBytes
void
(
*
releaseProc
)
(
void
*
pixels
void
*
context
)
void
*
context
const
SkSurfaceProps
*
surfaceProps
=
nullptr
)
;
static
sk_sp
<
SkSurface
>
MakeRaster
(
const
SkImageInfo
&
imageInfo
size_t
rowBytes
const
SkSurfaceProps
*
surfaceProps
)
;
static
sk_sp
<
SkSurface
>
MakeRaster
(
const
SkImageInfo
&
imageInfo
const
SkSurfaceProps
*
props
=
nullptr
)
{
return
MakeRaster
(
imageInfo
0
props
)
;
}
static
sk_sp
<
SkSurface
>
MakeRasterN32Premul
(
int
width
int
height
const
SkSurfaceProps
*
surfaceProps
=
nullptr
)
;
typedef
void
*
ReleaseContext
;
typedef
void
(
*
RenderTargetReleaseProc
)
(
ReleaseContext
releaseContext
)
;
typedef
void
(
*
TextureReleaseProc
)
(
ReleaseContext
releaseContext
)
;
static
sk_sp
<
SkSurface
>
MakeFromBackendTexture
(
GrRecordingContext
*
context
const
GrBackendTexture
&
backendTexture
GrSurfaceOrigin
origin
int
sampleCnt
SkColorType
colorType
sk_sp
<
SkColorSpace
>
colorSpace
const
SkSurfaceProps
*
surfaceProps
TextureReleaseProc
textureReleaseProc
=
nullptr
ReleaseContext
releaseContext
=
nullptr
)
;
static
sk_sp
<
SkSurface
>
MakeFromBackendRenderTarget
(
GrRecordingContext
*
context
const
GrBackendRenderTarget
&
backendRenderTarget
GrSurfaceOrigin
origin
SkColorType
colorType
sk_sp
<
SkColorSpace
>
colorSpace
const
SkSurfaceProps
*
surfaceProps
RenderTargetReleaseProc
releaseProc
=
nullptr
ReleaseContext
releaseContext
=
nullptr
)
;
static
sk_sp
<
SkSurface
>
MakeRenderTarget
(
GrRecordingContext
*
context
skgpu
:
:
Budgeted
budgeted
const
SkImageInfo
&
imageInfo
int
sampleCount
GrSurfaceOrigin
surfaceOrigin
const
SkSurfaceProps
*
surfaceProps
bool
shouldCreateWithMips
=
false
)
;
static
sk_sp
<
SkSurface
>
MakeRenderTarget
(
GrRecordingContext
*
context
skgpu
:
:
Budgeted
budgeted
const
SkImageInfo
&
imageInfo
int
sampleCount
const
SkSurfaceProps
*
surfaceProps
)
{
#
if
defined
(
SK_GANESH
)
return
MakeRenderTarget
(
context
budgeted
imageInfo
sampleCount
kBottomLeft_GrSurfaceOrigin
surfaceProps
)
;
#
else
return
nullptr
;
#
endif
}
static
sk_sp
<
SkSurface
>
MakeRenderTarget
(
GrRecordingContext
*
context
skgpu
:
:
Budgeted
budgeted
const
SkImageInfo
&
imageInfo
)
{
#
if
defined
(
SK_GANESH
)
if
(
!
imageInfo
.
width
(
)
|
|
!
imageInfo
.
height
(
)
)
{
return
nullptr
;
}
return
MakeRenderTarget
(
context
budgeted
imageInfo
0
kBottomLeft_GrSurfaceOrigin
nullptr
)
;
#
else
return
nullptr
;
#
endif
}
static
sk_sp
<
SkSurface
>
MakeRenderTarget
(
GrRecordingContext
*
context
const
SkSurfaceCharacterization
&
characterization
skgpu
:
:
Budgeted
budgeted
)
;
#
if
defined
(
SK_BUILD_FOR_ANDROID
)
&
&
__ANDROID_API__
>
=
26
static
sk_sp
<
SkSurface
>
MakeFromAHardwareBuffer
(
GrDirectContext
*
context
AHardwareBuffer
*
hardwareBuffer
GrSurfaceOrigin
origin
sk_sp
<
SkColorSpace
>
colorSpace
const
SkSurfaceProps
*
surfaceProps
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
bool
fromWindow
=
false
#
endif
)
;
#
endif
#
if
defined
(
SK_GRAPHITE
)
static
sk_sp
<
SkSurface
>
MakeGraphite
(
skgpu
:
:
graphite
:
:
Recorder
*
const
SkImageInfo
&
imageInfo
skgpu
:
:
Mipmapped
=
skgpu
:
:
Mipmapped
:
:
kNo
const
SkSurfaceProps
*
surfaceProps
=
nullptr
)
;
static
sk_sp
<
SkSurface
>
MakeGraphiteFromBackendTexture
(
skgpu
:
:
graphite
:
:
Recorder
*
const
skgpu
:
:
graphite
:
:
BackendTexture
&
SkColorType
colorType
sk_sp
<
SkColorSpace
>
colorSpace
const
SkSurfaceProps
*
props
)
;
#
endif
#
if
defined
(
SK_GANESH
)
&
&
defined
(
SK_METAL
)
static
sk_sp
<
SkSurface
>
MakeFromCAMetalLayer
(
GrRecordingContext
*
context
GrMTLHandle
layer
GrSurfaceOrigin
origin
int
sampleCnt
SkColorType
colorType
sk_sp
<
SkColorSpace
>
colorSpace
const
SkSurfaceProps
*
surfaceProps
GrMTLHandle
*
drawable
)
SK_API_AVAILABLE_CA_METAL_LAYER
;
static
sk_sp
<
SkSurface
>
MakeFromMTKView
(
GrRecordingContext
*
context
GrMTLHandle
mtkView
GrSurfaceOrigin
origin
int
sampleCnt
SkColorType
colorType
sk_sp
<
SkColorSpace
>
colorSpace
const
SkSurfaceProps
*
surfaceProps
)
SK_API_AVAILABLE
(
macos
(
10
.
11
)
ios
(
9
.
0
)
)
;
#
endif
bool
isCompatible
(
const
SkSurfaceCharacterization
&
characterization
)
const
;
static
sk_sp
<
SkSurface
>
MakeNull
(
int
width
int
height
)
;
int
width
(
)
const
{
return
fWidth
;
}
int
height
(
)
const
{
return
fHeight
;
}
virtual
SkImageInfo
imageInfo
(
)
const
{
return
SkImageInfo
:
:
MakeUnknown
(
fWidth
fHeight
)
;
}
uint32_t
generationID
(
)
;
enum
ContentChangeMode
{
kDiscard_ContentChangeMode
kRetain_ContentChangeMode
}
;
void
notifyContentWillChange
(
ContentChangeMode
mode
)
;
GrRecordingContext
*
recordingContext
(
)
;
skgpu
:
:
graphite
:
:
Recorder
*
recorder
(
)
;
#
if
defined
(
SK_GANESH
)
enum
BackendHandleAccess
{
kFlushRead_BackendHandleAccess
kFlushWrite_BackendHandleAccess
kDiscardWrite_BackendHandleAccess
}
;
static
const
BackendHandleAccess
kFlushRead_TextureHandleAccess
=
kFlushRead_BackendHandleAccess
;
static
const
BackendHandleAccess
kFlushWrite_TextureHandleAccess
=
kFlushWrite_BackendHandleAccess
;
static
const
BackendHandleAccess
kDiscardWrite_TextureHandleAccess
=
kDiscardWrite_BackendHandleAccess
;
GrBackendTexture
getBackendTexture
(
BackendHandleAccess
backendHandleAccess
)
;
GrBackendRenderTarget
getBackendRenderTarget
(
BackendHandleAccess
backendHandleAccess
)
;
bool
replaceBackendTexture
(
const
GrBackendTexture
&
backendTexture
GrSurfaceOrigin
origin
ContentChangeMode
mode
=
kRetain_ContentChangeMode
TextureReleaseProc
textureReleaseProc
=
nullptr
ReleaseContext
releaseContext
=
nullptr
)
;
#
endif
SkCanvas
*
getCanvas
(
)
;
sk_sp
<
const
SkCapabilities
>
capabilities
(
)
;
sk_sp
<
SkSurface
>
makeSurface
(
const
SkImageInfo
&
imageInfo
)
;
sk_sp
<
SkSurface
>
makeSurface
(
int
width
int
height
)
;
sk_sp
<
SkImage
>
makeImageSnapshot
(
)
;
sk_sp
<
SkImage
>
makeImageSnapshot
(
const
SkIRect
&
bounds
)
;
#
if
defined
(
SK_GRAPHITE
)
sk_sp
<
SkImage
>
asImage
(
)
;
sk_sp
<
SkImage
>
makeImageCopy
(
const
SkIRect
*
subset
=
nullptr
skgpu
:
:
Mipmapped
mipmapped
=
skgpu
:
:
Mipmapped
:
:
kNo
)
;
#
endif
void
draw
(
SkCanvas
*
canvas
SkScalar
x
SkScalar
y
const
SkSamplingOptions
&
sampling
const
SkPaint
*
paint
)
;
void
draw
(
SkCanvas
*
canvas
SkScalar
x
SkScalar
y
const
SkPaint
*
paint
=
nullptr
)
{
this
-
>
draw
(
canvas
x
y
SkSamplingOptions
(
)
paint
)
;
}
bool
peekPixels
(
SkPixmap
*
pixmap
)
;
bool
readPixels
(
const
SkPixmap
&
dst
int
srcX
int
srcY
)
;
bool
readPixels
(
const
SkImageInfo
&
dstInfo
void
*
dstPixels
size_t
dstRowBytes
int
srcX
int
srcY
)
;
bool
readPixels
(
const
SkBitmap
&
dst
int
srcX
int
srcY
)
;
using
AsyncReadResult
=
SkImage
:
:
AsyncReadResult
;
using
ReadPixelsContext
=
void
*
;
using
ReadPixelsCallback
=
void
(
ReadPixelsContext
std
:
:
unique_ptr
<
const
AsyncReadResult
>
)
;
using
RescaleGamma
=
SkImage
:
:
RescaleGamma
;
using
RescaleMode
=
SkImage
:
:
RescaleMode
;
void
asyncRescaleAndReadPixels
(
const
SkImageInfo
&
info
const
SkIRect
&
srcRect
RescaleGamma
rescaleGamma
RescaleMode
rescaleMode
ReadPixelsCallback
callback
ReadPixelsContext
context
)
;
void
asyncRescaleAndReadPixelsYUV420
(
SkYUVColorSpace
yuvColorSpace
sk_sp
<
SkColorSpace
>
dstColorSpace
const
SkIRect
&
srcRect
const
SkISize
&
dstSize
RescaleGamma
rescaleGamma
RescaleMode
rescaleMode
ReadPixelsCallback
callback
ReadPixelsContext
context
)
;
void
writePixels
(
const
SkPixmap
&
src
int
dstX
int
dstY
)
;
void
writePixels
(
const
SkBitmap
&
src
int
dstX
int
dstY
)
;
const
SkSurfaceProps
&
props
(
)
const
{
return
fProps
;
}
void
flushAndSubmit
(
bool
syncCpu
=
false
)
;
enum
class
BackendSurfaceAccess
{
kNoAccess
kPresent
}
;
#
if
defined
(
SK_GANESH
)
void
resolveMSAA
(
)
;
GrSemaphoresSubmitted
flush
(
BackendSurfaceAccess
access
const
GrFlushInfo
&
info
)
;
GrSemaphoresSubmitted
flush
(
const
GrFlushInfo
&
info
const
skgpu
:
:
MutableTextureState
*
newState
=
nullptr
)
;
#
endif
void
flush
(
)
;
bool
wait
(
int
numSemaphores
const
GrBackendSemaphore
*
waitSemaphores
bool
deleteSemaphoresAfterWait
=
true
)
;
bool
characterize
(
SkSurfaceCharacterization
*
characterization
)
const
;
bool
draw
(
sk_sp
<
const
SkDeferredDisplayList
>
deferredDisplayList
int
xOffset
=
0
int
yOffset
=
0
)
;
protected
:
SkSurface
(
int
width
int
height
const
SkSurfaceProps
*
surfaceProps
)
;
SkSurface
(
const
SkImageInfo
&
imageInfo
const
SkSurfaceProps
*
surfaceProps
)
;
void
dirtyGenerationID
(
)
{
fGenerationID
=
0
;
}
private
:
const
SkSurfaceProps
fProps
;
const
int
fWidth
;
const
int
fHeight
;
uint32_t
fGenerationID
;
using
INHERITED
=
SkRefCnt
;
}
;
#
endif
