#
ifndef
SkSurface_DEFINED
#
define
SkSurface_DEFINED
#
include
"
include
/
core
/
SkImage
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSurfaceProps
.
h
"
#
include
"
include
/
gpu
/
GrTypes
.
h
"
#
if
defined
(
SK_BUILD_FOR_ANDROID
)
&
&
__ANDROID_API__
>
=
26
#
include
<
android
/
hardware_buffer
.
h
>
#
endif
#
ifdef
SK_METAL
#
include
"
include
/
gpu
/
mtl
/
GrMtlTypes
.
h
"
#
endif
class
SkCanvas
;
class
SkDeferredDisplayList
;
class
SkPaint
;
class
SkSurfaceCharacterization
;
class
GrBackendRenderTarget
;
class
GrBackendSemaphore
;
class
GrBackendTexture
;
class
GrContext
;
class
GrRecordingContext
;
class
GrRenderTarget
;
class
SK_API
SkSurface
:
public
SkRefCnt
{
public
:
static
sk_sp
<
SkSurface
>
MakeRasterDirect
(
const
SkImageInfo
&
imageInfo
void
*
pixels
size_t
rowBytes
const
SkSurfaceProps
*
surfaceProps
=
nullptr
)
;
static
sk_sp
<
SkSurface
>
MakeRasterDirectReleaseProc
(
const
SkImageInfo
&
imageInfo
void
*
pixels
size_t
rowBytes
void
(
*
releaseProc
)
(
void
*
pixels
void
*
context
)
void
*
context
const
SkSurfaceProps
*
surfaceProps
=
nullptr
)
;
static
sk_sp
<
SkSurface
>
MakeRaster
(
const
SkImageInfo
&
imageInfo
size_t
rowBytes
const
SkSurfaceProps
*
surfaceProps
)
;
static
sk_sp
<
SkSurface
>
MakeRaster
(
const
SkImageInfo
&
imageInfo
const
SkSurfaceProps
*
props
=
nullptr
)
{
return
MakeRaster
(
imageInfo
0
props
)
;
}
static
sk_sp
<
SkSurface
>
MakeRasterN32Premul
(
int
width
int
height
const
SkSurfaceProps
*
surfaceProps
=
nullptr
)
;
typedef
void
*
ReleaseContext
;
typedef
void
(
*
RenderTargetReleaseProc
)
(
ReleaseContext
releaseContext
)
;
typedef
void
(
*
TextureReleaseProc
)
(
ReleaseContext
releaseContext
)
;
static
sk_sp
<
SkSurface
>
MakeFromBackendTexture
(
GrContext
*
context
const
GrBackendTexture
&
backendTexture
GrSurfaceOrigin
origin
int
sampleCnt
SkColorType
colorType
sk_sp
<
SkColorSpace
>
colorSpace
const
SkSurfaceProps
*
surfaceProps
TextureReleaseProc
textureReleaseProc
=
nullptr
ReleaseContext
releaseContext
=
nullptr
)
;
static
sk_sp
<
SkSurface
>
MakeFromBackendRenderTarget
(
GrContext
*
context
const
GrBackendRenderTarget
&
backendRenderTarget
GrSurfaceOrigin
origin
SkColorType
colorType
sk_sp
<
SkColorSpace
>
colorSpace
const
SkSurfaceProps
*
surfaceProps
RenderTargetReleaseProc
releaseProc
=
nullptr
ReleaseContext
releaseContext
=
nullptr
)
;
static
sk_sp
<
SkSurface
>
MakeFromBackendTextureAsRenderTarget
(
GrContext
*
context
const
GrBackendTexture
&
backendTexture
GrSurfaceOrigin
origin
int
sampleCnt
SkColorType
colorType
sk_sp
<
SkColorSpace
>
colorSpace
const
SkSurfaceProps
*
surfaceProps
)
;
#
if
defined
(
SK_BUILD_FOR_ANDROID
)
&
&
__ANDROID_API__
>
=
26
static
sk_sp
<
SkSurface
>
MakeFromAHardwareBuffer
(
GrContext
*
context
AHardwareBuffer
*
hardwareBuffer
GrSurfaceOrigin
origin
sk_sp
<
SkColorSpace
>
colorSpace
const
SkSurfaceProps
*
surfaceProps
)
;
#
endif
#
ifdef
SK_METAL
static
sk_sp
<
SkSurface
>
MakeFromCAMetalLayer
(
GrContext
*
context
GrMTLHandle
layer
GrSurfaceOrigin
origin
int
sampleCnt
SkColorType
colorType
sk_sp
<
SkColorSpace
>
colorSpace
const
SkSurfaceProps
*
surfaceProps
GrMTLHandle
*
drawable
)
;
#
endif
static
sk_sp
<
SkSurface
>
MakeRenderTarget
(
GrContext
*
context
SkBudgeted
budgeted
const
SkImageInfo
&
imageInfo
int
sampleCount
GrSurfaceOrigin
surfaceOrigin
const
SkSurfaceProps
*
surfaceProps
bool
shouldCreateWithMips
=
false
)
;
static
sk_sp
<
SkSurface
>
MakeRenderTarget
(
GrContext
*
context
SkBudgeted
budgeted
const
SkImageInfo
&
imageInfo
int
sampleCount
const
SkSurfaceProps
*
surfaceProps
)
{
return
MakeRenderTarget
(
context
budgeted
imageInfo
sampleCount
kBottomLeft_GrSurfaceOrigin
surfaceProps
)
;
}
static
sk_sp
<
SkSurface
>
MakeRenderTarget
(
GrContext
*
context
SkBudgeted
budgeted
const
SkImageInfo
&
imageInfo
)
{
if
(
!
imageInfo
.
width
(
)
|
|
!
imageInfo
.
height
(
)
)
{
return
nullptr
;
}
return
MakeRenderTarget
(
context
budgeted
imageInfo
0
kBottomLeft_GrSurfaceOrigin
nullptr
)
;
}
static
sk_sp
<
SkSurface
>
MakeRenderTarget
(
GrRecordingContext
*
context
const
SkSurfaceCharacterization
&
characterization
SkBudgeted
budgeted
)
;
static
sk_sp
<
SkSurface
>
MakeFromBackendTexture
(
GrContext
*
context
const
SkSurfaceCharacterization
&
characterzation
const
GrBackendTexture
&
backendTexture
TextureReleaseProc
textureReleaseProc
=
nullptr
ReleaseContext
releaseContext
=
nullptr
)
;
bool
isCompatible
(
const
SkSurfaceCharacterization
&
characterization
)
const
;
static
sk_sp
<
SkSurface
>
MakeNull
(
int
width
int
height
)
;
int
width
(
)
const
{
return
fWidth
;
}
int
height
(
)
const
{
return
fHeight
;
}
SkImageInfo
imageInfo
(
)
;
uint32_t
generationID
(
)
;
enum
ContentChangeMode
{
kDiscard_ContentChangeMode
kRetain_ContentChangeMode
}
;
void
notifyContentWillChange
(
ContentChangeMode
mode
)
;
enum
BackendHandleAccess
{
kFlushRead_BackendHandleAccess
kFlushWrite_BackendHandleAccess
kDiscardWrite_BackendHandleAccess
}
;
static
const
BackendHandleAccess
kFlushRead_TextureHandleAccess
=
kFlushRead_BackendHandleAccess
;
static
const
BackendHandleAccess
kFlushWrite_TextureHandleAccess
=
kFlushWrite_BackendHandleAccess
;
static
const
BackendHandleAccess
kDiscardWrite_TextureHandleAccess
=
kDiscardWrite_BackendHandleAccess
;
GrBackendTexture
getBackendTexture
(
BackendHandleAccess
backendHandleAccess
)
;
GrBackendRenderTarget
getBackendRenderTarget
(
BackendHandleAccess
backendHandleAccess
)
;
bool
replaceBackendTexture
(
const
GrBackendTexture
&
backendTexture
GrSurfaceOrigin
origin
TextureReleaseProc
textureReleaseProc
=
nullptr
ReleaseContext
releaseContext
=
nullptr
)
;
SkCanvas
*
getCanvas
(
)
;
sk_sp
<
SkSurface
>
makeSurface
(
const
SkImageInfo
&
imageInfo
)
;
sk_sp
<
SkSurface
>
makeSurface
(
int
width
int
height
)
;
sk_sp
<
SkImage
>
makeImageSnapshot
(
)
;
sk_sp
<
SkImage
>
makeImageSnapshot
(
const
SkIRect
&
bounds
)
;
void
draw
(
SkCanvas
*
canvas
SkScalar
x
SkScalar
y
const
SkPaint
*
paint
)
;
bool
peekPixels
(
SkPixmap
*
pixmap
)
;
bool
readPixels
(
const
SkPixmap
&
dst
int
srcX
int
srcY
)
;
bool
readPixels
(
const
SkImageInfo
&
dstInfo
void
*
dstPixels
size_t
dstRowBytes
int
srcX
int
srcY
)
;
bool
readPixels
(
const
SkBitmap
&
dst
int
srcX
int
srcY
)
;
class
AsyncReadResult
{
public
:
AsyncReadResult
(
const
AsyncReadResult
&
)
=
delete
;
AsyncReadResult
(
AsyncReadResult
&
&
)
=
delete
;
AsyncReadResult
&
operator
=
(
const
AsyncReadResult
&
)
=
delete
;
AsyncReadResult
&
operator
=
(
AsyncReadResult
&
&
)
=
delete
;
virtual
~
AsyncReadResult
(
)
=
default
;
virtual
int
count
(
)
const
=
0
;
virtual
const
void
*
data
(
int
i
)
const
=
0
;
virtual
size_t
rowBytes
(
int
i
)
const
=
0
;
protected
:
AsyncReadResult
(
)
=
default
;
}
;
using
ReadPixelsContext
=
void
*
;
using
ReadPixelsCallback
=
void
(
ReadPixelsContext
std
:
:
unique_ptr
<
const
AsyncReadResult
>
)
;
enum
RescaleGamma
:
bool
{
kSrc
kLinear
}
;
void
asyncRescaleAndReadPixels
(
const
SkImageInfo
&
info
const
SkIRect
&
srcRect
RescaleGamma
rescaleGamma
SkFilterQuality
rescaleQuality
ReadPixelsCallback
callback
ReadPixelsContext
context
)
;
using
LegacyReadPixelsCallback
=
void
(
ReadPixelsContext
const
void
*
data
size_t
rowBytes
)
;
void
asyncRescaleAndReadPixels
(
const
SkImageInfo
&
info
const
SkIRect
&
srcRect
RescaleGamma
rescaleGamma
SkFilterQuality
rescaleQuality
LegacyReadPixelsCallback
callback
ReadPixelsContext
context
)
;
void
asyncRescaleAndReadPixelsYUV420
(
SkYUVColorSpace
yuvColorSpace
sk_sp
<
SkColorSpace
>
dstColorSpace
const
SkIRect
&
srcRect
const
SkISize
&
dstSize
RescaleGamma
rescaleGamma
SkFilterQuality
rescaleQuality
ReadPixelsCallback
callback
ReadPixelsContext
)
;
using
LegacyReadPixelsCallbackYUV420
=
void
(
ReadPixelsContext
const
void
*
data
[
3
]
size_t
rowBytes
[
3
]
)
;
void
asyncRescaleAndReadPixelsYUV420
(
SkYUVColorSpace
yuvColorSpace
sk_sp
<
SkColorSpace
>
dstColorSpace
const
SkIRect
&
srcRect
int
dstW
int
dstH
RescaleGamma
rescaleGamma
SkFilterQuality
rescaleQuality
LegacyReadPixelsCallbackYUV420
callback
ReadPixelsContext
)
;
void
writePixels
(
const
SkPixmap
&
src
int
dstX
int
dstY
)
;
void
writePixels
(
const
SkBitmap
&
src
int
dstX
int
dstY
)
;
const
SkSurfaceProps
&
props
(
)
const
{
return
fProps
;
}
void
flush
(
)
;
enum
class
BackendSurfaceAccess
{
kNoAccess
kPresent
}
;
GrSemaphoresSubmitted
flush
(
BackendSurfaceAccess
access
const
GrFlushInfo
&
info
)
;
GrSemaphoresSubmitted
flush
(
BackendSurfaceAccess
access
GrFlushFlags
flags
int
numSemaphores
GrBackendSemaphore
signalSemaphores
[
]
GrGpuFinishedProc
finishedProc
=
nullptr
GrGpuFinishedContext
finishedContext
=
nullptr
)
;
enum
FlushFlags
{
kNone_FlushFlags
=
0
kSyncCpu_FlushFlag
=
0x1
}
;
GrSemaphoresSubmitted
flush
(
BackendSurfaceAccess
access
FlushFlags
flags
int
numSemaphores
GrBackendSemaphore
signalSemaphores
[
]
)
;
GrSemaphoresSubmitted
flushAndSignalSemaphores
(
int
numSemaphores
GrBackendSemaphore
signalSemaphores
[
]
)
;
bool
wait
(
int
numSemaphores
const
GrBackendSemaphore
*
waitSemaphores
)
;
bool
characterize
(
SkSurfaceCharacterization
*
characterization
)
const
;
bool
draw
(
SkDeferredDisplayList
*
deferredDisplayList
)
;
protected
:
SkSurface
(
int
width
int
height
const
SkSurfaceProps
*
surfaceProps
)
;
SkSurface
(
const
SkImageInfo
&
imageInfo
const
SkSurfaceProps
*
surfaceProps
)
;
void
dirtyGenerationID
(
)
{
fGenerationID
=
0
;
}
private
:
const
SkSurfaceProps
fProps
;
const
int
fWidth
;
const
int
fHeight
;
uint32_t
fGenerationID
;
typedef
SkRefCnt
INHERITED
;
}
;
#
endif
