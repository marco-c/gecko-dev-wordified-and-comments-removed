#
ifndef
SkRect_DEFINED
#
define
SkRect_DEFINED
#
include
"
include
/
core
/
SkPoint
.
h
"
#
include
"
include
/
core
/
SkSize
.
h
"
#
include
"
include
/
private
/
SkSafe32
.
h
"
#
include
"
include
/
private
/
SkTFitsIn
.
h
"
#
include
<
utility
>
struct
SkRect
;
struct
SK_API
SkIRect
{
int32_t
fLeft
;
int32_t
fTop
;
int32_t
fRight
;
int32_t
fBottom
;
static
constexpr
SkIRect
SK_WARN_UNUSED_RESULT
MakeEmpty
(
)
{
return
SkIRect
{
0
0
0
0
}
;
}
static
constexpr
SkIRect
SK_WARN_UNUSED_RESULT
MakeWH
(
int32_t
w
int32_t
h
)
{
return
SkIRect
{
0
0
w
h
}
;
}
static
constexpr
SkIRect
SK_WARN_UNUSED_RESULT
MakeSize
(
const
SkISize
&
size
)
{
return
SkIRect
{
0
0
size
.
fWidth
size
.
fHeight
}
;
}
static
constexpr
SkIRect
SK_WARN_UNUSED_RESULT
MakeLTRB
(
int32_t
l
int32_t
t
int32_t
r
int32_t
b
)
{
return
SkIRect
{
l
t
r
b
}
;
}
static
constexpr
SkIRect
SK_WARN_UNUSED_RESULT
MakeXYWH
(
int32_t
x
int32_t
y
int32_t
w
int32_t
h
)
{
return
{
x
y
Sk32_sat_add
(
x
w
)
Sk32_sat_add
(
y
h
)
}
;
}
int32_t
left
(
)
const
{
return
fLeft
;
}
int32_t
top
(
)
const
{
return
fTop
;
}
int32_t
right
(
)
const
{
return
fRight
;
}
int32_t
bottom
(
)
const
{
return
fBottom
;
}
int32_t
x
(
)
const
{
return
fLeft
;
}
int32_t
y
(
)
const
{
return
fTop
;
}
SkIPoint
topLeft
(
)
const
{
return
{
fLeft
fTop
}
;
}
int32_t
width
(
)
const
{
return
Sk32_can_overflow_sub
(
fRight
fLeft
)
;
}
int32_t
height
(
)
const
{
return
Sk32_can_overflow_sub
(
fBottom
fTop
)
;
}
SkISize
size
(
)
const
{
return
SkISize
:
:
Make
(
this
-
>
width
(
)
this
-
>
height
(
)
)
;
}
int64_t
width64
(
)
const
{
return
(
int64_t
)
fRight
-
(
int64_t
)
fLeft
;
}
int64_t
height64
(
)
const
{
return
(
int64_t
)
fBottom
-
(
int64_t
)
fTop
;
}
bool
isEmpty64
(
)
const
{
return
fRight
<
=
fLeft
|
|
fBottom
<
=
fTop
;
}
bool
isEmpty
(
)
const
{
int64_t
w
=
this
-
>
width64
(
)
;
int64_t
h
=
this
-
>
height64
(
)
;
if
(
w
<
=
0
|
|
h
<
=
0
)
{
return
true
;
}
return
!
SkTFitsIn
<
int32_t
>
(
w
|
h
)
;
}
friend
bool
operator
=
=
(
const
SkIRect
&
a
const
SkIRect
&
b
)
{
return
!
memcmp
(
&
a
&
b
sizeof
(
a
)
)
;
}
friend
bool
operator
!
=
(
const
SkIRect
&
a
const
SkIRect
&
b
)
{
return
!
(
a
=
=
b
)
;
}
void
setEmpty
(
)
{
memset
(
this
0
sizeof
(
*
this
)
)
;
}
void
setLTRB
(
int32_t
left
int32_t
top
int32_t
right
int32_t
bottom
)
{
fLeft
=
left
;
fTop
=
top
;
fRight
=
right
;
fBottom
=
bottom
;
}
void
setXYWH
(
int32_t
x
int32_t
y
int32_t
width
int32_t
height
)
{
fLeft
=
x
;
fTop
=
y
;
fRight
=
Sk32_sat_add
(
x
width
)
;
fBottom
=
Sk32_sat_add
(
y
height
)
;
}
void
setWH
(
int32_t
width
int32_t
height
)
{
fLeft
=
0
;
fTop
=
0
;
fRight
=
width
;
fBottom
=
height
;
}
constexpr
SkIRect
makeOffset
(
int32_t
dx
int32_t
dy
)
const
{
return
{
Sk32_sat_add
(
fLeft
dx
)
Sk32_sat_add
(
fTop
dy
)
Sk32_sat_add
(
fRight
dx
)
Sk32_sat_add
(
fBottom
dy
)
}
;
}
constexpr
SkIRect
makeOffset
(
SkIVector
offset
)
const
{
return
this
-
>
makeOffset
(
offset
.
x
(
)
offset
.
y
(
)
)
;
}
SkIRect
makeInset
(
int32_t
dx
int32_t
dy
)
const
{
return
{
Sk32_sat_add
(
fLeft
dx
)
Sk32_sat_add
(
fTop
dy
)
Sk32_sat_sub
(
fRight
dx
)
Sk32_sat_sub
(
fBottom
dy
)
}
;
}
SkIRect
makeOutset
(
int32_t
dx
int32_t
dy
)
const
{
return
{
Sk32_sat_sub
(
fLeft
dx
)
Sk32_sat_sub
(
fTop
dy
)
Sk32_sat_add
(
fRight
dx
)
Sk32_sat_add
(
fBottom
dy
)
}
;
}
void
offset
(
int32_t
dx
int32_t
dy
)
{
fLeft
=
Sk32_sat_add
(
fLeft
dx
)
;
fTop
=
Sk32_sat_add
(
fTop
dy
)
;
fRight
=
Sk32_sat_add
(
fRight
dx
)
;
fBottom
=
Sk32_sat_add
(
fBottom
dy
)
;
}
void
offset
(
const
SkIPoint
&
delta
)
{
this
-
>
offset
(
delta
.
fX
delta
.
fY
)
;
}
void
offsetTo
(
int32_t
newX
int32_t
newY
)
{
fRight
=
Sk64_pin_to_s32
(
(
int64_t
)
fRight
+
newX
-
fLeft
)
;
fBottom
=
Sk64_pin_to_s32
(
(
int64_t
)
fBottom
+
newY
-
fTop
)
;
fLeft
=
newX
;
fTop
=
newY
;
}
void
inset
(
int32_t
dx
int32_t
dy
)
{
fLeft
=
Sk32_sat_add
(
fLeft
dx
)
;
fTop
=
Sk32_sat_add
(
fTop
dy
)
;
fRight
=
Sk32_sat_sub
(
fRight
dx
)
;
fBottom
=
Sk32_sat_sub
(
fBottom
dy
)
;
}
void
outset
(
int32_t
dx
int32_t
dy
)
{
this
-
>
inset
(
-
dx
-
dy
)
;
}
void
adjust
(
int32_t
dL
int32_t
dT
int32_t
dR
int32_t
dB
)
{
fLeft
=
Sk32_sat_add
(
fLeft
dL
)
;
fTop
=
Sk32_sat_add
(
fTop
dT
)
;
fRight
=
Sk32_sat_add
(
fRight
dR
)
;
fBottom
=
Sk32_sat_add
(
fBottom
dB
)
;
}
bool
contains
(
int32_t
x
int32_t
y
)
const
{
return
x
>
=
fLeft
&
&
x
<
fRight
&
&
y
>
=
fTop
&
&
y
<
fBottom
;
}
bool
contains
(
const
SkIRect
&
r
)
const
{
return
!
r
.
isEmpty
(
)
&
&
!
this
-
>
isEmpty
(
)
&
&
fLeft
<
=
r
.
fLeft
&
&
fTop
<
=
r
.
fTop
&
&
fRight
>
=
r
.
fRight
&
&
fBottom
>
=
r
.
fBottom
;
}
inline
bool
contains
(
const
SkRect
&
r
)
const
;
bool
containsNoEmptyCheck
(
const
SkIRect
&
r
)
const
{
SkASSERT
(
fLeft
<
fRight
&
&
fTop
<
fBottom
)
;
SkASSERT
(
r
.
fLeft
<
r
.
fRight
&
&
r
.
fTop
<
r
.
fBottom
)
;
return
fLeft
<
=
r
.
fLeft
&
&
fTop
<
=
r
.
fTop
&
&
fRight
>
=
r
.
fRight
&
&
fBottom
>
=
r
.
fBottom
;
}
bool
intersect
(
const
SkIRect
&
r
)
{
return
this
-
>
intersect
(
*
this
r
)
;
}
bool
SK_WARN_UNUSED_RESULT
intersect
(
const
SkIRect
&
a
const
SkIRect
&
b
)
;
static
bool
Intersects
(
const
SkIRect
&
a
const
SkIRect
&
b
)
{
SkIRect
dummy
;
return
dummy
.
intersect
(
a
b
)
;
}
void
join
(
const
SkIRect
&
r
)
;
void
sort
(
)
{
using
std
:
:
swap
;
if
(
fLeft
>
fRight
)
{
swap
(
fLeft
fRight
)
;
}
if
(
fTop
>
fBottom
)
{
swap
(
fTop
fBottom
)
;
}
}
SkIRect
makeSorted
(
)
const
{
return
MakeLTRB
(
SkMin32
(
fLeft
fRight
)
SkMin32
(
fTop
fBottom
)
SkMax32
(
fLeft
fRight
)
SkMax32
(
fTop
fBottom
)
)
;
}
static
const
SkIRect
&
SK_WARN_UNUSED_RESULT
EmptyIRect
(
)
{
static
const
SkIRect
gEmpty
=
{
0
0
0
0
}
;
return
gEmpty
;
}
}
;
struct
SK_API
SkRect
{
SkScalar
fLeft
;
SkScalar
fTop
;
SkScalar
fRight
;
SkScalar
fBottom
;
static
constexpr
SkRect
SK_WARN_UNUSED_RESULT
MakeEmpty
(
)
{
return
SkRect
{
0
0
0
0
}
;
}
static
constexpr
SkRect
SK_WARN_UNUSED_RESULT
MakeWH
(
SkScalar
w
SkScalar
h
)
{
return
SkRect
{
0
0
w
h
}
;
}
static
SkRect
SK_WARN_UNUSED_RESULT
MakeIWH
(
int
w
int
h
)
{
return
{
0
0
SkIntToScalar
(
w
)
SkIntToScalar
(
h
)
}
;
}
static
constexpr
SkRect
SK_WARN_UNUSED_RESULT
MakeSize
(
const
SkSize
&
size
)
{
return
SkRect
{
0
0
size
.
fWidth
size
.
fHeight
}
;
}
static
constexpr
SkRect
SK_WARN_UNUSED_RESULT
MakeLTRB
(
SkScalar
l
SkScalar
t
SkScalar
r
SkScalar
b
)
{
return
SkRect
{
l
t
r
b
}
;
}
static
constexpr
SkRect
SK_WARN_UNUSED_RESULT
MakeXYWH
(
SkScalar
x
SkScalar
y
SkScalar
w
SkScalar
h
)
{
return
SkRect
{
x
y
x
+
w
y
+
h
}
;
}
static
SkRect
Make
(
const
SkISize
&
size
)
{
return
MakeIWH
(
size
.
width
(
)
size
.
height
(
)
)
;
}
static
SkRect
SK_WARN_UNUSED_RESULT
Make
(
const
SkIRect
&
irect
)
{
return
{
SkIntToScalar
(
irect
.
fLeft
)
SkIntToScalar
(
irect
.
fTop
)
SkIntToScalar
(
irect
.
fRight
)
SkIntToScalar
(
irect
.
fBottom
)
}
;
}
bool
isEmpty
(
)
const
{
return
!
(
fLeft
<
fRight
&
&
fTop
<
fBottom
)
;
}
bool
isSorted
(
)
const
{
return
fLeft
<
=
fRight
&
&
fTop
<
=
fBottom
;
}
bool
isFinite
(
)
const
{
float
accum
=
0
;
accum
*
=
fLeft
;
accum
*
=
fTop
;
accum
*
=
fRight
;
accum
*
=
fBottom
;
SkASSERT
(
0
=
=
accum
|
|
SkScalarIsNaN
(
accum
)
)
;
return
!
SkScalarIsNaN
(
accum
)
;
}
SkScalar
x
(
)
const
{
return
fLeft
;
}
SkScalar
y
(
)
const
{
return
fTop
;
}
SkScalar
left
(
)
const
{
return
fLeft
;
}
SkScalar
top
(
)
const
{
return
fTop
;
}
SkScalar
right
(
)
const
{
return
fRight
;
}
SkScalar
bottom
(
)
const
{
return
fBottom
;
}
SkScalar
width
(
)
const
{
return
fRight
-
fLeft
;
}
SkScalar
height
(
)
const
{
return
fBottom
-
fTop
;
}
SkScalar
centerX
(
)
const
{
return
SkScalarHalf
(
fLeft
)
+
SkScalarHalf
(
fRight
)
;
}
SkScalar
centerY
(
)
const
{
return
SkScalarHalf
(
fTop
)
+
SkScalarHalf
(
fBottom
)
;
}
friend
bool
operator
=
=
(
const
SkRect
&
a
const
SkRect
&
b
)
{
return
SkScalarsEqual
(
(
const
SkScalar
*
)
&
a
(
const
SkScalar
*
)
&
b
4
)
;
}
friend
bool
operator
!
=
(
const
SkRect
&
a
const
SkRect
&
b
)
{
return
!
SkScalarsEqual
(
(
const
SkScalar
*
)
&
a
(
const
SkScalar
*
)
&
b
4
)
;
}
void
toQuad
(
SkPoint
quad
[
4
]
)
const
;
void
setEmpty
(
)
{
*
this
=
MakeEmpty
(
)
;
}
void
set
(
const
SkIRect
&
src
)
{
fLeft
=
SkIntToScalar
(
src
.
fLeft
)
;
fTop
=
SkIntToScalar
(
src
.
fTop
)
;
fRight
=
SkIntToScalar
(
src
.
fRight
)
;
fBottom
=
SkIntToScalar
(
src
.
fBottom
)
;
}
void
setLTRB
(
SkScalar
left
SkScalar
top
SkScalar
right
SkScalar
bottom
)
{
fLeft
=
left
;
fTop
=
top
;
fRight
=
right
;
fBottom
=
bottom
;
}
void
setBounds
(
const
SkPoint
pts
[
]
int
count
)
{
(
void
)
this
-
>
setBoundsCheck
(
pts
count
)
;
}
bool
setBoundsCheck
(
const
SkPoint
pts
[
]
int
count
)
;
void
setBoundsNoCheck
(
const
SkPoint
pts
[
]
int
count
)
;
void
set
(
const
SkPoint
&
p0
const
SkPoint
&
p1
)
{
fLeft
=
SkMinScalar
(
p0
.
fX
p1
.
fX
)
;
fRight
=
SkMaxScalar
(
p0
.
fX
p1
.
fX
)
;
fTop
=
SkMinScalar
(
p0
.
fY
p1
.
fY
)
;
fBottom
=
SkMaxScalar
(
p0
.
fY
p1
.
fY
)
;
}
void
setXYWH
(
SkScalar
x
SkScalar
y
SkScalar
width
SkScalar
height
)
{
fLeft
=
x
;
fTop
=
y
;
fRight
=
x
+
width
;
fBottom
=
y
+
height
;
}
void
setWH
(
SkScalar
width
SkScalar
height
)
{
fLeft
=
0
;
fTop
=
0
;
fRight
=
width
;
fBottom
=
height
;
}
void
setIWH
(
int32_t
width
int32_t
height
)
{
this
-
>
setWH
(
SkIntToScalar
(
width
)
SkIntToScalar
(
height
)
)
;
}
SkRect
makeOffset
(
SkScalar
dx
SkScalar
dy
)
const
{
return
MakeLTRB
(
fLeft
+
dx
fTop
+
dy
fRight
+
dx
fBottom
+
dy
)
;
}
SkRect
makeInset
(
SkScalar
dx
SkScalar
dy
)
const
{
return
MakeLTRB
(
fLeft
+
dx
fTop
+
dy
fRight
-
dx
fBottom
-
dy
)
;
}
SkRect
makeOutset
(
SkScalar
dx
SkScalar
dy
)
const
{
return
MakeLTRB
(
fLeft
-
dx
fTop
-
dy
fRight
+
dx
fBottom
+
dy
)
;
}
void
offset
(
SkScalar
dx
SkScalar
dy
)
{
fLeft
+
=
dx
;
fTop
+
=
dy
;
fRight
+
=
dx
;
fBottom
+
=
dy
;
}
void
offset
(
const
SkPoint
&
delta
)
{
this
-
>
offset
(
delta
.
fX
delta
.
fY
)
;
}
void
offsetTo
(
SkScalar
newX
SkScalar
newY
)
{
fRight
+
=
newX
-
fLeft
;
fBottom
+
=
newY
-
fTop
;
fLeft
=
newX
;
fTop
=
newY
;
}
void
inset
(
SkScalar
dx
SkScalar
dy
)
{
fLeft
+
=
dx
;
fTop
+
=
dy
;
fRight
-
=
dx
;
fBottom
-
=
dy
;
}
void
outset
(
SkScalar
dx
SkScalar
dy
)
{
this
-
>
inset
(
-
dx
-
dy
)
;
}
bool
intersect
(
const
SkRect
&
r
)
;
bool
SK_WARN_UNUSED_RESULT
intersect
(
const
SkRect
&
a
const
SkRect
&
b
)
;
private
:
static
bool
Intersects
(
SkScalar
al
SkScalar
at
SkScalar
ar
SkScalar
ab
SkScalar
bl
SkScalar
bt
SkScalar
br
SkScalar
bb
)
{
SkScalar
L
=
SkMaxScalar
(
al
bl
)
;
SkScalar
R
=
SkMinScalar
(
ar
br
)
;
SkScalar
T
=
SkMaxScalar
(
at
bt
)
;
SkScalar
B
=
SkMinScalar
(
ab
bb
)
;
return
L
<
R
&
&
T
<
B
;
}
public
:
bool
intersects
(
const
SkRect
&
r
)
const
{
return
Intersects
(
fLeft
fTop
fRight
fBottom
r
.
fLeft
r
.
fTop
r
.
fRight
r
.
fBottom
)
;
}
static
bool
Intersects
(
const
SkRect
&
a
const
SkRect
&
b
)
{
return
Intersects
(
a
.
fLeft
a
.
fTop
a
.
fRight
a
.
fBottom
b
.
fLeft
b
.
fTop
b
.
fRight
b
.
fBottom
)
;
}
void
join
(
const
SkRect
&
r
)
;
void
joinNonEmptyArg
(
const
SkRect
&
r
)
{
SkASSERT
(
!
r
.
isEmpty
(
)
)
;
if
(
fLeft
>
=
fRight
|
|
fTop
>
=
fBottom
)
{
*
this
=
r
;
}
else
{
this
-
>
joinPossiblyEmptyRect
(
r
)
;
}
}
void
joinPossiblyEmptyRect
(
const
SkRect
&
r
)
{
fLeft
=
SkMinScalar
(
fLeft
r
.
left
(
)
)
;
fTop
=
SkMinScalar
(
fTop
r
.
top
(
)
)
;
fRight
=
SkMaxScalar
(
fRight
r
.
right
(
)
)
;
fBottom
=
SkMaxScalar
(
fBottom
r
.
bottom
(
)
)
;
}
bool
contains
(
SkScalar
x
SkScalar
y
)
const
{
return
x
>
=
fLeft
&
&
x
<
fRight
&
&
y
>
=
fTop
&
&
y
<
fBottom
;
}
bool
contains
(
const
SkRect
&
r
)
const
{
return
!
r
.
isEmpty
(
)
&
&
!
this
-
>
isEmpty
(
)
&
&
fLeft
<
=
r
.
fLeft
&
&
fTop
<
=
r
.
fTop
&
&
fRight
>
=
r
.
fRight
&
&
fBottom
>
=
r
.
fBottom
;
}
bool
contains
(
const
SkIRect
&
r
)
const
{
return
!
r
.
isEmpty
(
)
&
&
!
this
-
>
isEmpty
(
)
&
&
fLeft
<
=
SkIntToScalar
(
r
.
fLeft
)
&
&
fTop
<
=
SkIntToScalar
(
r
.
fTop
)
&
&
fRight
>
=
SkIntToScalar
(
r
.
fRight
)
&
&
fBottom
>
=
SkIntToScalar
(
r
.
fBottom
)
;
}
void
round
(
SkIRect
*
dst
)
const
{
SkASSERT
(
dst
)
;
dst
-
>
setLTRB
(
SkScalarRoundToInt
(
fLeft
)
SkScalarRoundToInt
(
fTop
)
SkScalarRoundToInt
(
fRight
)
SkScalarRoundToInt
(
fBottom
)
)
;
}
void
roundOut
(
SkIRect
*
dst
)
const
{
SkASSERT
(
dst
)
;
dst
-
>
setLTRB
(
SkScalarFloorToInt
(
fLeft
)
SkScalarFloorToInt
(
fTop
)
SkScalarCeilToInt
(
fRight
)
SkScalarCeilToInt
(
fBottom
)
)
;
}
void
roundOut
(
SkRect
*
dst
)
const
{
dst
-
>
setLTRB
(
SkScalarFloorToScalar
(
fLeft
)
SkScalarFloorToScalar
(
fTop
)
SkScalarCeilToScalar
(
fRight
)
SkScalarCeilToScalar
(
fBottom
)
)
;
}
void
roundIn
(
SkIRect
*
dst
)
const
{
SkASSERT
(
dst
)
;
dst
-
>
setLTRB
(
SkScalarCeilToInt
(
fLeft
)
SkScalarCeilToInt
(
fTop
)
SkScalarFloorToInt
(
fRight
)
SkScalarFloorToInt
(
fBottom
)
)
;
}
SkIRect
round
(
)
const
{
SkIRect
ir
;
this
-
>
round
(
&
ir
)
;
return
ir
;
}
SkIRect
roundOut
(
)
const
{
SkIRect
ir
;
this
-
>
roundOut
(
&
ir
)
;
return
ir
;
}
void
sort
(
)
{
using
std
:
:
swap
;
if
(
fLeft
>
fRight
)
{
swap
(
fLeft
fRight
)
;
}
if
(
fTop
>
fBottom
)
{
swap
(
fTop
fBottom
)
;
}
}
SkRect
makeSorted
(
)
const
{
return
MakeLTRB
(
SkMinScalar
(
fLeft
fRight
)
SkMinScalar
(
fTop
fBottom
)
SkMaxScalar
(
fLeft
fRight
)
SkMaxScalar
(
fTop
fBottom
)
)
;
}
const
SkScalar
*
asScalars
(
)
const
{
return
&
fLeft
;
}
void
dump
(
bool
asHex
)
const
;
void
dump
(
)
const
{
this
-
>
dump
(
false
)
;
}
void
dumpHex
(
)
const
{
this
-
>
dump
(
true
)
;
}
}
;
inline
bool
SkIRect
:
:
contains
(
const
SkRect
&
r
)
const
{
return
!
r
.
isEmpty
(
)
&
&
!
this
-
>
isEmpty
(
)
&
&
(
SkScalar
)
fLeft
<
=
r
.
fLeft
&
&
(
SkScalar
)
fTop
<
=
r
.
fTop
&
&
(
SkScalar
)
fRight
>
=
r
.
fRight
&
&
(
SkScalar
)
fBottom
>
=
r
.
fBottom
;
}
#
endif
