#
ifndef
SkTextBlob_DEFINED
#
define
SkTextBlob_DEFINED
#
include
"
.
.
/
private
/
SkTemplates
.
h
"
#
include
"
.
.
/
private
/
SkAtomics
.
h
"
#
include
"
SkPaint
.
h
"
#
include
"
SkString
.
h
"
#
include
"
SkRefCnt
.
h
"
class
SkReadBuffer
;
class
SkWriteBuffer
;
struct
SkSerialProcs
;
struct
SkDeserialProcs
;
typedef
void
(
*
SkTypefaceCatalogerProc
)
(
SkTypeface
*
void
*
ctx
)
;
typedef
sk_sp
<
SkTypeface
>
(
*
SkTypefaceResolverProc
)
(
uint32_t
id
void
*
ctx
)
;
class
SK_API
SkTextBlob
final
:
public
SkNVRefCnt
<
SkTextBlob
>
{
public
:
const
SkRect
&
bounds
(
)
const
{
return
fBounds
;
}
uint32_t
uniqueID
(
)
const
{
return
fUniqueID
;
}
void
flatten
(
SkWriteBuffer
&
)
const
;
static
sk_sp
<
SkTextBlob
>
MakeFromBuffer
(
SkReadBuffer
&
)
;
enum
GlyphPositioning
:
uint8_t
{
kDefault_Positioning
=
0
kHorizontal_Positioning
=
1
kFull_Positioning
=
2
}
;
sk_sp
<
SkData
>
serialize
(
SkTypefaceCatalogerProc
void
*
ctx
)
const
;
static
sk_sp
<
SkTextBlob
>
Deserialize
(
const
void
*
data
size_t
size
SkTypefaceResolverProc
void
*
ctx
)
;
sk_sp
<
SkData
>
serialize
(
const
SkSerialProcs
&
)
const
;
sk_sp
<
SkData
>
serialize
(
)
const
;
static
sk_sp
<
SkTextBlob
>
Deserialize
(
const
void
*
data
size_t
size
const
SkDeserialProcs
&
)
;
static
sk_sp
<
SkTextBlob
>
Deserialize
(
const
void
*
data
size_t
size
)
;
private
:
friend
class
SkNVRefCnt
<
SkTextBlob
>
;
class
RunRecord
;
explicit
SkTextBlob
(
const
SkRect
&
bounds
)
;
~
SkTextBlob
(
)
;
void
operator
delete
(
void
*
p
)
{
sk_free
(
p
)
;
}
void
*
operator
new
(
size_t
)
{
SK_ABORT
(
"
All
blobs
are
created
by
placement
new
.
"
)
;
return
sk_malloc_throw
(
0
)
;
}
void
*
operator
new
(
size_t
void
*
p
)
{
return
p
;
}
static
unsigned
ScalarsPerGlyph
(
GlyphPositioning
pos
)
;
void
notifyAddedToCache
(
uint32_t
cacheID
)
const
{
fCacheID
.
store
(
cacheID
)
;
}
friend
class
GrTextBlobCache
;
friend
class
SkTextBlobBuilder
;
friend
class
SkTextBlobRunIterator
;
const
SkRect
fBounds
;
const
uint32_t
fUniqueID
;
mutable
SkAtomic
<
uint32_t
>
fCacheID
;
SkDEBUGCODE
(
size_t
fStorageSize
;
)
typedef
SkRefCnt
INHERITED
;
}
;
class
SK_API
SkTextBlobBuilder
{
public
:
SkTextBlobBuilder
(
)
;
~
SkTextBlobBuilder
(
)
;
sk_sp
<
SkTextBlob
>
make
(
)
;
struct
RunBuffer
{
SkGlyphID
*
glyphs
;
SkScalar
*
pos
;
char
*
utf8text
;
uint32_t
*
clusters
;
}
;
const
RunBuffer
&
allocRunText
(
const
SkPaint
&
font
int
count
SkScalar
x
SkScalar
y
int
textByteCount
SkString
lang
const
SkRect
*
bounds
=
nullptr
)
;
const
RunBuffer
&
allocRun
(
const
SkPaint
&
font
int
count
SkScalar
x
SkScalar
y
const
SkRect
*
bounds
=
nullptr
)
{
return
this
-
>
allocRunText
(
font
count
x
y
0
SkString
(
)
bounds
)
;
}
const
RunBuffer
&
allocRunTextPosH
(
const
SkPaint
&
font
int
count
SkScalar
y
int
textByteCount
SkString
lang
const
SkRect
*
bounds
=
nullptr
)
;
const
RunBuffer
&
allocRunPosH
(
const
SkPaint
&
font
int
count
SkScalar
y
const
SkRect
*
bounds
=
nullptr
)
{
return
this
-
>
allocRunTextPosH
(
font
count
y
0
SkString
(
)
bounds
)
;
}
const
RunBuffer
&
allocRunTextPos
(
const
SkPaint
&
font
int
count
int
textByteCount
SkString
lang
const
SkRect
*
bounds
=
nullptr
)
;
const
RunBuffer
&
allocRunPos
(
const
SkPaint
&
font
int
count
const
SkRect
*
bounds
=
nullptr
)
{
return
this
-
>
allocRunTextPos
(
font
count
0
SkString
(
)
bounds
)
;
}
private
:
void
reserve
(
size_t
size
)
;
void
allocInternal
(
const
SkPaint
&
font
SkTextBlob
:
:
GlyphPositioning
positioning
int
count
int
textBytes
SkPoint
offset
const
SkRect
*
bounds
)
;
bool
mergeRun
(
const
SkPaint
&
font
SkTextBlob
:
:
GlyphPositioning
positioning
uint32_t
count
SkPoint
offset
)
;
void
updateDeferredBounds
(
)
;
static
SkRect
ConservativeRunBounds
(
const
SkTextBlob
:
:
RunRecord
&
)
;
static
SkRect
TightRunBounds
(
const
SkTextBlob
:
:
RunRecord
&
)
;
SkAutoTMalloc
<
uint8_t
>
fStorage
;
size_t
fStorageSize
;
size_t
fStorageUsed
;
SkRect
fBounds
;
int
fRunCount
;
bool
fDeferredBounds
;
size_t
fLastRun
;
RunBuffer
fCurrentRunBuffer
;
}
;
#
endif
