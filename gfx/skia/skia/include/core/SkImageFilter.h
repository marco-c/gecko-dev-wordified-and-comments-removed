#
ifndef
SkImageFilter_DEFINED
#
define
SkImageFilter_DEFINED
#
include
"
.
.
/
private
/
SkTArray
.
h
"
#
include
"
.
.
/
private
/
SkTemplates
.
h
"
#
include
"
.
.
/
private
/
SkMutex
.
h
"
#
include
"
SkFilterQuality
.
h
"
#
include
"
SkFlattenable
.
h
"
#
include
"
SkMatrix
.
h
"
#
include
"
SkRect
.
h
"
#
include
"
SkSurfaceProps
.
h
"
class
GrFragmentProcessor
;
class
GrTexture
;
class
SkBaseDevice
;
class
SkBitmap
;
class
SkColorFilter
;
struct
SkIPoint
;
class
SkSpecialImage
;
class
SK_API
SkImageFilter
:
public
SkFlattenable
{
public
:
class
Cache
:
public
SkRefCnt
{
public
:
struct
Key
;
virtual
~
Cache
(
)
{
}
static
Cache
*
Create
(
size_t
maxBytes
)
;
static
Cache
*
Get
(
)
;
virtual
bool
get
(
const
Key
&
key
SkBitmap
*
result
SkIPoint
*
offset
)
const
=
0
;
virtual
SkSpecialImage
*
get
(
const
Key
&
key
SkIPoint
*
offset
)
const
=
0
;
virtual
void
set
(
const
Key
&
key
const
SkBitmap
&
result
const
SkIPoint
&
offset
)
=
0
;
virtual
void
set
(
const
Key
&
key
SkSpecialImage
*
image
const
SkIPoint
&
offset
)
=
0
;
virtual
void
purge
(
)
{
}
virtual
void
purgeByKeys
(
const
Key
[
]
int
)
{
}
}
;
class
Context
{
public
:
Context
(
const
SkMatrix
&
ctm
const
SkIRect
&
clipBounds
Cache
*
cache
)
:
fCTM
(
ctm
)
fClipBounds
(
clipBounds
)
fCache
(
cache
)
{
}
const
SkMatrix
&
ctm
(
)
const
{
return
fCTM
;
}
const
SkIRect
&
clipBounds
(
)
const
{
return
fClipBounds
;
}
Cache
*
cache
(
)
const
{
return
fCache
;
}
private
:
SkMatrix
fCTM
;
SkIRect
fClipBounds
;
Cache
*
fCache
;
}
;
class
CropRect
{
public
:
enum
CropEdge
{
kHasLeft_CropEdge
=
0x01
kHasTop_CropEdge
=
0x02
kHasWidth_CropEdge
=
0x04
kHasHeight_CropEdge
=
0x08
kHasAll_CropEdge
=
0x0F
}
;
CropRect
(
)
{
}
explicit
CropRect
(
const
SkRect
&
rect
uint32_t
flags
=
kHasAll_CropEdge
)
:
fRect
(
rect
)
fFlags
(
flags
)
{
}
uint32_t
flags
(
)
const
{
return
fFlags
;
}
const
SkRect
&
rect
(
)
const
{
return
fRect
;
}
#
ifndef
SK_IGNORE_TO_STRING
void
toString
(
SkString
*
str
)
const
;
#
endif
void
applyTo
(
const
SkIRect
&
imageBounds
const
SkMatrix
&
bool
embiggen
SkIRect
*
cropped
)
const
;
private
:
SkRect
fRect
;
uint32_t
fFlags
;
}
;
enum
TileUsage
{
kPossible_TileUsage
kNever_TileUsage
}
;
class
Proxy
{
public
:
virtual
~
Proxy
(
)
{
}
virtual
SkBaseDevice
*
createDevice
(
int
width
int
height
TileUsage
usage
=
kNever_TileUsage
)
=
0
;
virtual
bool
filterImage
(
const
SkImageFilter
*
const
SkBitmap
&
src
const
SkImageFilter
:
:
Context
&
SkBitmap
*
result
SkIPoint
*
offset
)
=
0
;
}
;
class
DeviceProxy
:
public
Proxy
{
public
:
DeviceProxy
(
SkBaseDevice
*
device
)
:
fDevice
(
device
)
{
}
SkBaseDevice
*
createDevice
(
int
width
int
height
TileUsage
usage
=
kNever_TileUsage
)
override
;
bool
filterImage
(
const
SkImageFilter
*
const
SkBitmap
&
src
const
SkImageFilter
:
:
Context
&
SkBitmap
*
result
SkIPoint
*
offset
)
override
;
private
:
SkBaseDevice
*
fDevice
;
}
;
sk_sp
<
SkSpecialImage
>
filterImage
(
SkSpecialImage
*
src
const
Context
&
SkIPoint
*
offset
)
const
;
enum
MapDirection
{
kForward_MapDirection
kReverse_MapDirection
}
;
SkIRect
filterBounds
(
const
SkIRect
&
src
const
SkMatrix
&
ctm
MapDirection
=
kReverse_MapDirection
)
const
;
virtual
bool
canFilterImageGPU
(
)
const
;
virtual
bool
filterImageGPUDeprecated
(
Proxy
*
const
SkBitmap
&
src
const
Context
&
SkBitmap
*
result
SkIPoint
*
offset
)
const
;
bool
isColorFilterNode
(
SkColorFilter
*
*
filterPtr
)
const
{
return
this
-
>
onIsColorFilterNode
(
filterPtr
)
;
}
bool
asColorFilter
(
SkColorFilter
*
*
filterPtr
)
const
{
return
this
-
>
isColorFilterNode
(
filterPtr
)
;
}
bool
asAColorFilter
(
SkColorFilter
*
*
filterPtr
)
const
;
int
countInputs
(
)
const
{
return
fInputCount
;
}
SkImageFilter
*
getInput
(
int
i
)
const
{
SkASSERT
(
i
<
fInputCount
)
;
return
fInputs
[
i
]
;
}
bool
cropRectIsSet
(
)
const
{
return
fCropRect
.
flags
(
)
!
=
0x0
;
}
CropRect
getCropRect
(
)
const
{
return
fCropRect
;
}
virtual
SkRect
computeFastBounds
(
const
SkRect
&
)
const
;
bool
canComputeFastBounds
(
)
const
;
sk_sp
<
SkImageFilter
>
makeWithLocalMatrix
(
const
SkMatrix
&
)
const
;
#
ifdef
SK_SUPPORT_LEGACY_IMAGEFILTER_PTR
SkImageFilter
*
newWithLocalMatrix
(
const
SkMatrix
&
matrix
)
const
{
return
this
-
>
makeWithLocalMatrix
(
matrix
)
.
release
(
)
;
}
#
endif
static
sk_sp
<
SkImageFilter
>
MakeMatrixFilter
(
const
SkMatrix
&
matrix
SkFilterQuality
sk_sp
<
SkImageFilter
>
input
)
;
#
ifdef
SK_SUPPORT_LEGACY_IMAGEFILTER_PTR
static
SkImageFilter
*
CreateMatrixFilter
(
const
SkMatrix
&
matrix
SkFilterQuality
filterQuality
SkImageFilter
*
input
=
nullptr
)
{
return
MakeMatrixFilter
(
matrix
filterQuality
sk_ref_sp
<
SkImageFilter
>
(
input
)
)
.
release
(
)
;
}
#
endif
sk_sp
<
SkSpecialImage
>
filterInput
(
int
index
SkSpecialImage
*
src
const
Context
&
SkIPoint
*
offset
)
const
;
#
if
SK_SUPPORT_GPU
bool
filterInputGPUDeprecated
(
int
index
SkImageFilter
:
:
Proxy
*
proxy
const
SkBitmap
&
src
const
Context
&
SkBitmap
*
result
SkIPoint
*
offset
)
const
;
#
endif
SK_TO_STRING_PUREVIRT
(
)
SK_DEFINE_FLATTENABLE_TYPE
(
SkImageFilter
)
protected
:
class
Common
{
public
:
bool
unflatten
(
SkReadBuffer
&
int
expectedInputs
)
;
const
CropRect
&
cropRect
(
)
const
{
return
fCropRect
;
}
int
inputCount
(
)
const
{
return
fInputs
.
count
(
)
;
}
sk_sp
<
SkImageFilter
>
*
inputs
(
)
const
{
return
fInputs
.
get
(
)
;
}
sk_sp
<
SkImageFilter
>
getInput
(
int
index
)
const
{
return
fInputs
[
index
]
;
}
void
detachInputs
(
SkImageFilter
*
*
inputs
)
;
private
:
CropRect
fCropRect
;
SkAutoSTArray
<
2
sk_sp
<
SkImageFilter
>
>
fInputs
;
void
allocInputs
(
int
count
)
;
}
;
SkImageFilter
(
int
inputCount
SkImageFilter
*
*
inputs
const
CropRect
*
cropRect
=
nullptr
)
;
SkImageFilter
(
sk_sp
<
SkImageFilter
>
*
inputs
int
inputCount
const
CropRect
*
cropRect
)
;
virtual
~
SkImageFilter
(
)
;
explicit
SkImageFilter
(
int
inputCount
SkReadBuffer
&
rb
)
;
void
flatten
(
SkWriteBuffer
&
)
const
override
;
virtual
bool
onFilterImageDeprecated
(
Proxy
*
const
SkBitmap
&
src
const
Context
&
SkBitmap
*
result
SkIPoint
*
offset
)
const
;
virtual
sk_sp
<
SkSpecialImage
>
onFilterImage
(
SkSpecialImage
*
src
const
Context
&
SkIPoint
*
offset
)
const
;
virtual
SkIRect
onFilterBounds
(
const
SkIRect
&
const
SkMatrix
&
MapDirection
)
const
;
virtual
SkIRect
onFilterNodeBounds
(
const
SkIRect
&
const
SkMatrix
&
MapDirection
)
const
;
bool
filterInputDeprecated
(
int
index
Proxy
*
const
SkBitmap
&
src
const
Context
&
SkBitmap
*
result
SkIPoint
*
offset
)
const
;
virtual
bool
onIsColorFilterNode
(
SkColorFilter
*
*
)
const
{
return
false
;
}
bool
applyCropRect
(
const
Context
&
const
SkIRect
&
srcBounds
SkIRect
*
dstBounds
)
const
;
bool
applyCropRectDeprecated
(
const
Context
&
Proxy
*
proxy
const
SkBitmap
&
src
SkIPoint
*
srcOffset
SkIRect
*
bounds
SkBitmap
*
result
)
const
;
sk_sp
<
SkSpecialImage
>
applyCropRect
(
const
Context
&
SkSpecialImage
*
src
SkIPoint
*
srcOffset
SkIRect
*
bounds
)
const
;
virtual
bool
asFragmentProcessor
(
GrFragmentProcessor
*
*
GrTexture
*
const
SkMatrix
&
const
SkIRect
&
bounds
)
const
;
Context
mapContext
(
const
Context
&
ctx
)
const
;
private
:
friend
class
SkGraphics
;
static
void
PurgeCache
(
)
;
bool
filterImageDeprecated
(
Proxy
*
const
SkBitmap
&
src
const
Context
&
SkBitmap
*
result
SkIPoint
*
offset
)
const
;
bool
usesSrcInput
(
)
const
{
return
fUsesSrcInput
;
}
virtual
bool
affectsTransparentBlack
(
)
const
{
return
false
;
}
typedef
SkFlattenable
INHERITED
;
int
fInputCount
;
SkImageFilter
*
*
fInputs
;
bool
fUsesSrcInput
;
CropRect
fCropRect
;
uint32_t
fUniqueID
;
mutable
SkTArray
<
Cache
:
:
Key
>
fCacheKeys
;
mutable
SkMutex
fMutex
;
}
;
#
define
SK_IMAGEFILTER_UNFLATTEN_COMMON
(
localVar
expectedCount
)
\
Common
localVar
;
\
do
{
\
if
(
!
localVar
.
unflatten
(
buffer
expectedCount
)
)
{
\
return
NULL
;
\
}
\
}
while
(
0
)
#
endif
