#
ifndef
SkImageFilter_DEFINED
#
define
SkImageFilter_DEFINED
#
include
"
.
.
/
private
/
SkTArray
.
h
"
#
include
"
.
.
/
private
/
SkTemplates
.
h
"
#
include
"
.
.
/
private
/
SkMutex
.
h
"
#
include
"
SkColorSpace
.
h
"
#
include
"
SkFilterQuality
.
h
"
#
include
"
SkFlattenable
.
h
"
#
include
"
SkMatrix
.
h
"
#
include
"
SkRect
.
h
"
class
GrContext
;
class
GrFragmentProcessor
;
class
SkColorFilter
;
class
SkColorSpaceXformer
;
struct
SkIPoint
;
class
SkSpecialImage
;
class
SkImageFilterCache
;
struct
SkImageFilterCacheKey
;
class
SK_API
SkImageFilter
:
public
SkFlattenable
{
public
:
class
OutputProperties
{
public
:
explicit
OutputProperties
(
SkColorSpace
*
colorSpace
)
:
fColorSpace
(
colorSpace
)
{
}
SkColorSpace
*
colorSpace
(
)
const
{
return
fColorSpace
;
}
private
:
SkColorSpace
*
fColorSpace
;
}
;
class
Context
{
public
:
Context
(
const
SkMatrix
&
ctm
const
SkIRect
&
clipBounds
SkImageFilterCache
*
cache
const
OutputProperties
&
outputProperties
)
:
fCTM
(
ctm
)
fClipBounds
(
clipBounds
)
fCache
(
cache
)
fOutputProperties
(
outputProperties
)
{
}
const
SkMatrix
&
ctm
(
)
const
{
return
fCTM
;
}
const
SkIRect
&
clipBounds
(
)
const
{
return
fClipBounds
;
}
SkImageFilterCache
*
cache
(
)
const
{
return
fCache
;
}
const
OutputProperties
&
outputProperties
(
)
const
{
return
fOutputProperties
;
}
private
:
SkMatrix
fCTM
;
SkIRect
fClipBounds
;
SkImageFilterCache
*
fCache
;
OutputProperties
fOutputProperties
;
}
;
class
CropRect
{
public
:
enum
CropEdge
{
kHasLeft_CropEdge
=
0x01
kHasTop_CropEdge
=
0x02
kHasWidth_CropEdge
=
0x04
kHasHeight_CropEdge
=
0x08
kHasAll_CropEdge
=
0x0F
}
;
CropRect
(
)
{
}
explicit
CropRect
(
const
SkRect
&
rect
uint32_t
flags
=
kHasAll_CropEdge
)
:
fRect
(
rect
)
fFlags
(
flags
)
{
}
uint32_t
flags
(
)
const
{
return
fFlags
;
}
const
SkRect
&
rect
(
)
const
{
return
fRect
;
}
#
ifndef
SK_IGNORE_TO_STRING
void
toString
(
SkString
*
str
)
const
;
#
endif
void
applyTo
(
const
SkIRect
&
imageBounds
const
SkMatrix
&
bool
embiggen
SkIRect
*
cropped
)
const
;
private
:
SkRect
fRect
;
uint32_t
fFlags
;
}
;
enum
TileUsage
{
kPossible_TileUsage
kNever_TileUsage
}
;
sk_sp
<
SkSpecialImage
>
filterImage
(
SkSpecialImage
*
src
const
Context
&
SkIPoint
*
offset
)
const
;
enum
MapDirection
{
kForward_MapDirection
kReverse_MapDirection
}
;
SkIRect
filterBounds
(
const
SkIRect
&
src
const
SkMatrix
&
ctm
MapDirection
=
kReverse_MapDirection
)
const
;
#
if
SK_SUPPORT_GPU
static
sk_sp
<
SkSpecialImage
>
DrawWithFP
(
GrContext
*
context
sk_sp
<
GrFragmentProcessor
>
fp
const
SkIRect
&
bounds
const
OutputProperties
&
outputProperties
)
;
#
endif
bool
isColorFilterNode
(
SkColorFilter
*
*
filterPtr
)
const
{
return
this
-
>
onIsColorFilterNode
(
filterPtr
)
;
}
bool
asColorFilter
(
SkColorFilter
*
*
filterPtr
)
const
{
return
this
-
>
isColorFilterNode
(
filterPtr
)
;
}
static
sk_sp
<
SkImageFilter
>
MakeBlur
(
SkScalar
sigmaX
SkScalar
sigmaY
sk_sp
<
SkImageFilter
>
input
const
CropRect
*
cropRect
=
nullptr
)
;
bool
asAColorFilter
(
SkColorFilter
*
*
filterPtr
)
const
;
int
countInputs
(
)
const
{
return
fInputs
.
count
(
)
;
}
SkImageFilter
*
getInput
(
int
i
)
const
{
SkASSERT
(
i
<
fInputs
.
count
(
)
)
;
return
fInputs
[
i
]
.
get
(
)
;
}
bool
cropRectIsSet
(
)
const
{
return
fCropRect
.
flags
(
)
!
=
0x0
;
}
CropRect
getCropRect
(
)
const
{
return
fCropRect
;
}
virtual
SkRect
computeFastBounds
(
const
SkRect
&
)
const
;
bool
canComputeFastBounds
(
)
const
;
sk_sp
<
SkImageFilter
>
makeWithLocalMatrix
(
const
SkMatrix
&
)
const
;
bool
canHandleComplexCTM
(
)
const
;
static
sk_sp
<
SkImageFilter
>
MakeMatrixFilter
(
const
SkMatrix
&
matrix
SkFilterQuality
quality
sk_sp
<
SkImageFilter
>
input
)
;
SK_TO_STRING_PUREVIRT
(
)
SK_DEFINE_FLATTENABLE_TYPE
(
SkImageFilter
)
SK_DECLARE_FLATTENABLE_REGISTRAR_GROUP
(
)
protected
:
class
Common
{
public
:
bool
unflatten
(
SkReadBuffer
&
int
expectedInputs
)
;
const
CropRect
&
cropRect
(
)
const
{
return
fCropRect
;
}
int
inputCount
(
)
const
{
return
fInputs
.
count
(
)
;
}
sk_sp
<
SkImageFilter
>
*
inputs
(
)
const
{
return
fInputs
.
get
(
)
;
}
sk_sp
<
SkImageFilter
>
getInput
(
int
index
)
const
{
return
fInputs
[
index
]
;
}
private
:
CropRect
fCropRect
;
SkAutoSTArray
<
2
sk_sp
<
SkImageFilter
>
>
fInputs
;
void
allocInputs
(
int
count
)
;
}
;
SkImageFilter
(
sk_sp
<
SkImageFilter
>
*
inputs
int
inputCount
const
CropRect
*
cropRect
)
;
~
SkImageFilter
(
)
override
;
explicit
SkImageFilter
(
int
inputCount
SkReadBuffer
&
rb
)
;
void
flatten
(
SkWriteBuffer
&
)
const
override
;
const
CropRect
*
getCropRectIfSet
(
)
const
{
return
this
-
>
cropRectIsSet
(
)
?
&
fCropRect
:
nullptr
;
}
virtual
sk_sp
<
SkSpecialImage
>
onFilterImage
(
SkSpecialImage
*
src
const
Context
&
SkIPoint
*
offset
)
const
=
0
;
virtual
SkIRect
onFilterBounds
(
const
SkIRect
&
const
SkMatrix
&
MapDirection
)
const
;
virtual
SkIRect
onFilterNodeBounds
(
const
SkIRect
&
const
SkMatrix
&
MapDirection
)
const
;
sk_sp
<
SkSpecialImage
>
filterInput
(
int
index
SkSpecialImage
*
src
const
Context
&
SkIPoint
*
offset
)
const
;
virtual
bool
onIsColorFilterNode
(
SkColorFilter
*
*
)
const
{
return
false
;
}
virtual
bool
onCanHandleComplexCTM
(
)
const
{
return
false
;
}
bool
applyCropRect
(
const
Context
&
const
SkIRect
&
srcBounds
SkIRect
*
dstBounds
)
const
;
sk_sp
<
SkSpecialImage
>
applyCropRect
(
const
Context
&
SkSpecialImage
*
src
SkIPoint
*
srcOffset
SkIRect
*
bounds
)
const
;
Context
mapContext
(
const
Context
&
ctx
)
const
;
#
if
SK_SUPPORT_GPU
static
sk_sp
<
SkSpecialImage
>
ImageToColorSpace
(
SkSpecialImage
*
src
const
OutputProperties
&
)
;
#
endif
sk_sp
<
SkImageFilter
>
makeColorSpace
(
SkColorSpaceXformer
*
xformer
)
const
{
return
this
-
>
onMakeColorSpace
(
xformer
)
;
}
virtual
sk_sp
<
SkImageFilter
>
onMakeColorSpace
(
SkColorSpaceXformer
*
)
const
{
return
sk_ref_sp
(
const_cast
<
SkImageFilter
*
>
(
this
)
)
;
}
private
:
friend
class
ArithmeticImageFilterImpl
;
friend
class
SkAlphaThresholdFilterImpl
;
friend
class
SkBlurImageFilterImpl
;
friend
class
SkColorFilterImageFilter
;
friend
class
SkColorSpaceXformer
;
friend
class
SkComposeImageFilter
;
friend
class
SkDisplacementMapEffect
;
friend
class
SkDropShadowImageFilter
;
friend
class
SkImageSource
;
friend
class
SkMagnifierImageFilter
;
friend
class
SkMatrixConvolutionImageFilter
;
friend
class
SkMergeImageFilter
;
friend
class
SkMorphologyImageFilter
;
friend
class
SkOffsetImageFilter
;
friend
class
SkTileImageFilter
;
friend
class
SkXfermodeImageFilter_Base
;
friend
class
SkGraphics
;
static
void
PurgeCache
(
)
;
void
init
(
sk_sp
<
SkImageFilter
>
*
inputs
int
inputCount
const
CropRect
*
cropRect
)
;
bool
usesSrcInput
(
)
const
{
return
fUsesSrcInput
;
}
virtual
bool
affectsTransparentBlack
(
)
const
{
return
false
;
}
SkAutoSTArray
<
2
sk_sp
<
SkImageFilter
>
>
fInputs
;
bool
fUsesSrcInput
;
CropRect
fCropRect
;
uint32_t
fUniqueID
;
mutable
SkTArray
<
SkImageFilterCacheKey
>
fCacheKeys
;
mutable
SkMutex
fMutex
;
typedef
SkFlattenable
INHERITED
;
}
;
#
define
SK_IMAGEFILTER_UNFLATTEN_COMMON
(
localVar
expectedCount
)
\
Common
localVar
;
\
do
{
\
if
(
!
localVar
.
unflatten
(
buffer
expectedCount
)
)
{
\
return
NULL
;
\
}
\
}
while
(
0
)
#
endif
