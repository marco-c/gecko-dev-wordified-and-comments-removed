#
ifndef
SkYUVAPixmaps_DEFINED
#
define
SkYUVAPixmaps_DEFINED
#
include
"
include
/
core
/
SkData
.
h
"
#
include
"
include
/
core
/
SkImageInfo
.
h
"
#
include
"
include
/
core
/
SkPixmap
.
h
"
#
include
"
include
/
core
/
SkYUVAInfo
.
h
"
#
include
"
include
/
private
/
base
/
SkTo
.
h
"
#
include
<
array
>
#
include
<
bitset
>
class
GrImageContext
;
class
SK_API
SkYUVAPixmapInfo
{
public
:
static
constexpr
auto
kMaxPlanes
=
SkYUVAInfo
:
:
kMaxPlanes
;
using
PlaneConfig
=
SkYUVAInfo
:
:
PlaneConfig
;
using
Subsampling
=
SkYUVAInfo
:
:
Subsampling
;
enum
class
DataType
{
kUnorm8
kUnorm16
kFloat16
kUnorm10_Unorm2
kLast
=
kUnorm10_Unorm2
}
;
static
constexpr
int
kDataTypeCnt
=
static_cast
<
int
>
(
DataType
:
:
kLast
)
+
1
;
class
SK_API
SupportedDataTypes
{
public
:
constexpr
SupportedDataTypes
(
)
=
default
;
SupportedDataTypes
(
const
GrImageContext
&
)
;
static
constexpr
SupportedDataTypes
All
(
)
;
constexpr
bool
supported
(
PlaneConfig
DataType
)
const
;
void
enableDataType
(
DataType
int
numChannels
)
;
private
:
std
:
:
bitset
<
kDataTypeCnt
*
4
>
fDataTypeSupport
=
{
}
;
}
;
static
constexpr
SkColorType
DefaultColorTypeForDataType
(
DataType
dataType
int
numChannels
)
;
static
std
:
:
tuple
<
int
DataType
>
NumChannelsAndDataType
(
SkColorType
)
;
SkYUVAPixmapInfo
(
)
=
default
;
SkYUVAPixmapInfo
(
const
SkYUVAInfo
&
const
SkColorType
[
kMaxPlanes
]
const
size_t
rowBytes
[
kMaxPlanes
]
)
;
SkYUVAPixmapInfo
(
const
SkYUVAInfo
&
DataType
const
size_t
rowBytes
[
kMaxPlanes
]
)
;
SkYUVAPixmapInfo
(
const
SkYUVAPixmapInfo
&
)
=
default
;
SkYUVAPixmapInfo
&
operator
=
(
const
SkYUVAPixmapInfo
&
)
=
default
;
bool
operator
=
=
(
const
SkYUVAPixmapInfo
&
)
const
;
bool
operator
!
=
(
const
SkYUVAPixmapInfo
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
const
SkYUVAInfo
&
yuvaInfo
(
)
const
{
return
fYUVAInfo
;
}
SkYUVColorSpace
yuvColorSpace
(
)
const
{
return
fYUVAInfo
.
yuvColorSpace
(
)
;
}
int
numPlanes
(
)
const
{
return
fYUVAInfo
.
numPlanes
(
)
;
}
DataType
dataType
(
)
const
{
return
fDataType
;
}
size_t
rowBytes
(
int
i
)
const
{
return
fRowBytes
[
static_cast
<
size_t
>
(
i
)
]
;
}
const
SkImageInfo
&
planeInfo
(
int
i
)
const
{
return
fPlaneInfos
[
static_cast
<
size_t
>
(
i
)
]
;
}
size_t
computeTotalBytes
(
size_t
planeSizes
[
kMaxPlanes
]
=
nullptr
)
const
;
bool
initPixmapsFromSingleAllocation
(
void
*
memory
SkPixmap
pixmaps
[
kMaxPlanes
]
)
const
;
bool
isValid
(
)
const
{
return
fYUVAInfo
.
isValid
(
)
;
}
bool
isSupported
(
const
SupportedDataTypes
&
)
const
;
private
:
SkYUVAInfo
fYUVAInfo
;
std
:
:
array
<
SkImageInfo
kMaxPlanes
>
fPlaneInfos
=
{
}
;
std
:
:
array
<
size_t
kMaxPlanes
>
fRowBytes
=
{
}
;
DataType
fDataType
=
DataType
:
:
kUnorm8
;
static_assert
(
kUnknown_SkColorType
=
=
0
"
default
init
isn
'
t
kUnknown
"
)
;
}
;
class
SK_API
SkYUVAPixmaps
{
public
:
using
DataType
=
SkYUVAPixmapInfo
:
:
DataType
;
static
constexpr
auto
kMaxPlanes
=
SkYUVAPixmapInfo
:
:
kMaxPlanes
;
static
SkColorType
RecommendedRGBAColorType
(
DataType
)
;
static
SkYUVAPixmaps
Allocate
(
const
SkYUVAPixmapInfo
&
yuvaPixmapInfo
)
;
static
SkYUVAPixmaps
FromData
(
const
SkYUVAPixmapInfo
&
sk_sp
<
SkData
>
)
;
static
SkYUVAPixmaps
MakeCopy
(
const
SkYUVAPixmaps
&
src
)
;
static
SkYUVAPixmaps
FromExternalMemory
(
const
SkYUVAPixmapInfo
&
void
*
memory
)
;
static
SkYUVAPixmaps
FromExternalPixmaps
(
const
SkYUVAInfo
&
const
SkPixmap
[
kMaxPlanes
]
)
;
SkYUVAPixmaps
(
)
=
default
;
~
SkYUVAPixmaps
(
)
=
default
;
SkYUVAPixmaps
(
SkYUVAPixmaps
&
&
that
)
=
default
;
SkYUVAPixmaps
&
operator
=
(
SkYUVAPixmaps
&
&
that
)
=
default
;
SkYUVAPixmaps
(
const
SkYUVAPixmaps
&
)
=
default
;
SkYUVAPixmaps
&
operator
=
(
const
SkYUVAPixmaps
&
that
)
=
default
;
bool
isValid
(
)
const
{
return
!
fYUVAInfo
.
dimensions
(
)
.
isEmpty
(
)
;
}
const
SkYUVAInfo
&
yuvaInfo
(
)
const
{
return
fYUVAInfo
;
}
DataType
dataType
(
)
const
{
return
fDataType
;
}
SkYUVAPixmapInfo
pixmapsInfo
(
)
const
;
int
numPlanes
(
)
const
{
return
this
-
>
isValid
(
)
?
fYUVAInfo
.
numPlanes
(
)
:
0
;
}
const
std
:
:
array
<
SkPixmap
kMaxPlanes
>
&
planes
(
)
const
{
return
fPlanes
;
}
const
SkPixmap
&
plane
(
int
i
)
const
{
return
fPlanes
[
SkToSizeT
(
i
)
]
;
}
SkYUVAInfo
:
:
YUVALocations
toYUVALocations
(
)
const
;
bool
ownsStorage
(
)
const
{
return
SkToBool
(
fData
)
;
}
private
:
SkYUVAPixmaps
(
const
SkYUVAPixmapInfo
&
sk_sp
<
SkData
>
)
;
SkYUVAPixmaps
(
const
SkYUVAInfo
&
DataType
const
SkPixmap
[
kMaxPlanes
]
)
;
std
:
:
array
<
SkPixmap
kMaxPlanes
>
fPlanes
=
{
}
;
sk_sp
<
SkData
>
fData
;
SkYUVAInfo
fYUVAInfo
;
DataType
fDataType
;
}
;
constexpr
SkYUVAPixmapInfo
:
:
SupportedDataTypes
SkYUVAPixmapInfo
:
:
SupportedDataTypes
:
:
All
(
)
{
using
ULL
=
unsigned
long
long
;
ULL
bits
=
0
;
for
(
ULL
c
=
1
;
c
<
=
4
;
+
+
c
)
{
for
(
ULL
dt
=
0
;
dt
<
=
ULL
(
kDataTypeCnt
)
;
+
+
dt
)
{
if
(
DefaultColorTypeForDataType
(
static_cast
<
DataType
>
(
dt
)
static_cast
<
int
>
(
c
)
)
!
=
kUnknown_SkColorType
)
{
bits
|
=
ULL
(
1
)
<
<
(
dt
+
static_cast
<
ULL
>
(
kDataTypeCnt
)
*
(
c
-
1
)
)
;
}
}
}
SupportedDataTypes
combinations
;
combinations
.
fDataTypeSupport
=
bits
;
return
combinations
;
}
constexpr
bool
SkYUVAPixmapInfo
:
:
SupportedDataTypes
:
:
supported
(
PlaneConfig
config
DataType
type
)
const
{
int
n
=
SkYUVAInfo
:
:
NumPlanes
(
config
)
;
for
(
int
i
=
0
;
i
<
n
;
+
+
i
)
{
auto
c
=
static_cast
<
size_t
>
(
SkYUVAInfo
:
:
NumChannelsInPlane
(
config
i
)
)
;
SkASSERT
(
c
>
=
1
&
&
c
<
=
4
)
;
if
(
!
fDataTypeSupport
[
static_cast
<
size_t
>
(
type
)
+
(
c
-
1
)
*
static_cast
<
size_t
>
(
kDataTypeCnt
)
]
)
{
return
false
;
}
}
return
true
;
}
constexpr
SkColorType
SkYUVAPixmapInfo
:
:
DefaultColorTypeForDataType
(
DataType
dataType
int
numChannels
)
{
switch
(
numChannels
)
{
case
1
:
switch
(
dataType
)
{
case
DataType
:
:
kUnorm8
:
return
kGray_8_SkColorType
;
case
DataType
:
:
kUnorm16
:
return
kA16_unorm_SkColorType
;
case
DataType
:
:
kFloat16
:
return
kA16_float_SkColorType
;
case
DataType
:
:
kUnorm10_Unorm2
:
return
kUnknown_SkColorType
;
}
break
;
case
2
:
switch
(
dataType
)
{
case
DataType
:
:
kUnorm8
:
return
kR8G8_unorm_SkColorType
;
case
DataType
:
:
kUnorm16
:
return
kR16G16_unorm_SkColorType
;
case
DataType
:
:
kFloat16
:
return
kR16G16_float_SkColorType
;
case
DataType
:
:
kUnorm10_Unorm2
:
return
kUnknown_SkColorType
;
}
break
;
case
3
:
switch
(
dataType
)
{
case
DataType
:
:
kUnorm8
:
return
kRGBA_8888_SkColorType
;
case
DataType
:
:
kUnorm16
:
return
kR16G16B16A16_unorm_SkColorType
;
case
DataType
:
:
kFloat16
:
return
kRGBA_F16_SkColorType
;
case
DataType
:
:
kUnorm10_Unorm2
:
return
kRGBA_1010102_SkColorType
;
}
break
;
case
4
:
switch
(
dataType
)
{
case
DataType
:
:
kUnorm8
:
return
kRGBA_8888_SkColorType
;
case
DataType
:
:
kUnorm16
:
return
kR16G16B16A16_unorm_SkColorType
;
case
DataType
:
:
kFloat16
:
return
kRGBA_F16_SkColorType
;
case
DataType
:
:
kUnorm10_Unorm2
:
return
kRGBA_1010102_SkColorType
;
}
break
;
}
return
kUnknown_SkColorType
;
}
#
endif
