#
ifndef
SkImageGanesh_DEFINED
#
define
SkImageGanesh_DEFINED
#
include
"
include
/
core
/
SkImage
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
gpu
/
GpuTypes
.
h
"
#
include
"
include
/
gpu
/
ganesh
/
GrTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkAPI
.
h
"
#
include
<
functional
>
#
include
<
utility
>
class
GrBackendTexture
;
class
GrDirectContext
;
class
GrRecordingContext
;
class
GrYUVABackendTextures
;
class
SkColorSpace
;
class
SkData
;
class
SkImageFilter
;
struct
SkIPoint
;
class
SkPixmap
;
class
SkYUVAPixmaps
;
enum
SkAlphaType
:
int
;
enum
SkColorType
:
int
;
enum
class
SkTextureCompressionType
;
struct
SkIRect
;
namespace
SkImages
{
using
BackendTextureReleaseProc
=
std
:
:
function
<
void
(
GrBackendTexture
)
>
;
using
TextureReleaseProc
=
void
(
*
)
(
ReleaseContext
)
;
SK_API
sk_sp
<
SkImage
>
AdoptTextureFrom
(
GrRecordingContext
*
context
const
GrBackendTexture
&
backendTexture
GrSurfaceOrigin
textureOrigin
SkColorType
colorType
)
;
SK_API
sk_sp
<
SkImage
>
AdoptTextureFrom
(
GrRecordingContext
*
context
const
GrBackendTexture
&
backendTexture
GrSurfaceOrigin
textureOrigin
SkColorType
colorType
SkAlphaType
alphaType
)
;
SK_API
sk_sp
<
SkImage
>
AdoptTextureFrom
(
GrRecordingContext
*
context
const
GrBackendTexture
&
backendTexture
GrSurfaceOrigin
textureOrigin
SkColorType
colorType
SkAlphaType
alphaType
sk_sp
<
SkColorSpace
>
colorSpace
)
;
SK_API
sk_sp
<
SkImage
>
BorrowTextureFrom
(
GrRecordingContext
*
context
const
GrBackendTexture
&
backendTexture
GrSurfaceOrigin
origin
SkColorType
colorType
SkAlphaType
alphaType
sk_sp
<
SkColorSpace
>
colorSpace
TextureReleaseProc
textureReleaseProc
=
nullptr
ReleaseContext
releaseContext
=
nullptr
)
;
SK_API
sk_sp
<
SkImage
>
CrossContextTextureFromPixmap
(
GrDirectContext
*
context
const
SkPixmap
&
pixmap
bool
buildMips
bool
limitToMaxTextureSize
=
false
)
;
SK_API
sk_sp
<
SkImage
>
TextureFromCompressedTexture
(
GrRecordingContext
*
context
const
GrBackendTexture
&
backendTexture
GrSurfaceOrigin
origin
SkAlphaType
alphaType
sk_sp
<
SkColorSpace
>
colorSpace
TextureReleaseProc
textureReleaseProc
=
nullptr
ReleaseContext
releaseContext
=
nullptr
)
;
SK_API
sk_sp
<
SkImage
>
TextureFromCompressedTextureData
(
GrDirectContext
*
direct
sk_sp
<
SkData
>
data
int
width
int
height
SkTextureCompressionType
type
skgpu
:
:
Mipmapped
mipmapped
=
skgpu
:
:
Mipmapped
:
:
kNo
GrProtected
isProtected
=
GrProtected
:
:
kNo
)
;
SK_API
sk_sp
<
SkImage
>
TextureFromImage
(
GrDirectContext
*
const
SkImage
*
skgpu
:
:
Mipmapped
=
skgpu
:
:
Mipmapped
:
:
kNo
skgpu
:
:
Budgeted
=
skgpu
:
:
Budgeted
:
:
kYes
)
;
inline
sk_sp
<
SkImage
>
TextureFromImage
(
GrDirectContext
*
ctx
const
sk_sp
<
const
SkImage
>
&
img
skgpu
:
:
Mipmapped
m
=
skgpu
:
:
Mipmapped
:
:
kNo
skgpu
:
:
Budgeted
b
=
skgpu
:
:
Budgeted
:
:
kYes
)
{
return
TextureFromImage
(
ctx
img
.
get
(
)
m
b
)
;
}
SK_API
sk_sp
<
SkImage
>
TextureFromYUVAPixmaps
(
GrRecordingContext
*
context
const
SkYUVAPixmaps
&
pixmaps
skgpu
:
:
Mipmapped
buildMips
bool
limitToMaxTextureSize
sk_sp
<
SkColorSpace
>
imageColorSpace
)
;
SK_API
sk_sp
<
SkImage
>
TextureFromYUVAPixmaps
(
GrRecordingContext
*
context
const
SkYUVAPixmaps
&
pixmaps
skgpu
:
:
Mipmapped
buildMips
=
skgpu
:
:
Mipmapped
:
:
kNo
bool
limitToMaxTextureSize
=
false
)
;
SK_API
sk_sp
<
SkImage
>
TextureFromYUVATextures
(
GrRecordingContext
*
context
const
GrYUVABackendTextures
&
yuvaTextures
sk_sp
<
SkColorSpace
>
imageColorSpace
TextureReleaseProc
textureReleaseProc
=
nullptr
ReleaseContext
releaseContext
=
nullptr
)
;
SK_API
sk_sp
<
SkImage
>
TextureFromYUVATextures
(
GrRecordingContext
*
context
const
GrYUVABackendTextures
&
yuvaTextures
)
;
SK_API
bool
GetBackendTextureFromImage
(
const
SkImage
*
img
GrBackendTexture
*
outTexture
bool
flushPendingGrContextIO
GrSurfaceOrigin
*
origin
=
nullptr
)
;
inline
bool
GetBackendTextureFromImage
(
const
sk_sp
<
const
SkImage
>
&
img
GrBackendTexture
*
outTexture
bool
flushPendingGrContextIO
GrSurfaceOrigin
*
origin
=
nullptr
)
{
return
GetBackendTextureFromImage
(
img
.
get
(
)
outTexture
flushPendingGrContextIO
origin
)
;
}
SK_API
bool
MakeBackendTextureFromImage
(
GrDirectContext
*
context
sk_sp
<
SkImage
>
image
GrBackendTexture
*
backendTexture
BackendTextureReleaseProc
*
backendTextureReleaseProc
)
;
inline
bool
GetBackendTextureFromImage
(
GrDirectContext
*
context
sk_sp
<
SkImage
>
image
GrBackendTexture
*
backendTexture
BackendTextureReleaseProc
*
backendTextureReleaseProc
)
{
return
MakeBackendTextureFromImage
(
context
std
:
:
move
(
image
)
backendTexture
backendTextureReleaseProc
)
;
}
SK_API
sk_sp
<
SkImage
>
SubsetTextureFrom
(
GrDirectContext
*
context
const
SkImage
*
img
const
SkIRect
&
subset
)
;
SK_API
sk_sp
<
SkImage
>
MakeWithFilter
(
GrRecordingContext
*
context
sk_sp
<
SkImage
>
src
const
SkImageFilter
*
filter
const
SkIRect
&
subset
const
SkIRect
&
clipBounds
SkIRect
*
outSubset
SkIPoint
*
offset
)
;
}
#
endif
