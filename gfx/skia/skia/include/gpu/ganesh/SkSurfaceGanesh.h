#
ifndef
SkSurfaceGanesh_DEFINED
#
define
SkSurfaceGanesh_DEFINED
#
include
"
include
/
core
/
SkImageInfo
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSurface
.
h
"
#
include
"
include
/
gpu
/
ganesh
/
GrTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkAPI
.
h
"
class
GrBackendRenderTarget
;
class
GrBackendTexture
;
class
GrRecordingContext
;
class
SkColorSpace
;
class
GrSurfaceCharacterization
;
class
SkSurfaceProps
;
enum
SkColorType
:
int
;
namespace
skgpu
{
enum
class
Budgeted
:
bool
;
}
namespace
SkSurfaces
{
using
ReleaseContext
=
void
*
;
using
RenderTargetReleaseProc
=
void
(
*
)
(
ReleaseContext
)
;
using
TextureReleaseProc
=
void
(
*
)
(
ReleaseContext
)
;
SK_API
sk_sp
<
SkSurface
>
RenderTarget
(
GrRecordingContext
*
context
skgpu
:
:
Budgeted
budgeted
const
SkImageInfo
&
imageInfo
int
sampleCount
GrSurfaceOrigin
surfaceOrigin
const
SkSurfaceProps
*
surfaceProps
bool
shouldCreateWithMips
=
false
bool
isProtected
=
false
)
;
inline
sk_sp
<
SkSurface
>
RenderTarget
(
GrRecordingContext
*
context
skgpu
:
:
Budgeted
budgeted
const
SkImageInfo
&
imageInfo
int
sampleCount
const
SkSurfaceProps
*
surfaceProps
)
{
return
RenderTarget
(
context
budgeted
imageInfo
sampleCount
kBottomLeft_GrSurfaceOrigin
surfaceProps
)
;
}
inline
sk_sp
<
SkSurface
>
RenderTarget
(
GrRecordingContext
*
context
skgpu
:
:
Budgeted
budgeted
const
SkImageInfo
&
imageInfo
)
{
if
(
!
imageInfo
.
width
(
)
|
|
!
imageInfo
.
height
(
)
)
{
return
nullptr
;
}
return
RenderTarget
(
context
budgeted
imageInfo
0
kBottomLeft_GrSurfaceOrigin
nullptr
)
;
}
SK_API
sk_sp
<
SkSurface
>
RenderTarget
(
GrRecordingContext
*
context
const
GrSurfaceCharacterization
&
characterization
skgpu
:
:
Budgeted
budgeted
)
;
SK_API
sk_sp
<
SkSurface
>
WrapBackendTexture
(
GrRecordingContext
*
context
const
GrBackendTexture
&
backendTexture
GrSurfaceOrigin
origin
int
sampleCnt
SkColorType
colorType
sk_sp
<
SkColorSpace
>
colorSpace
const
SkSurfaceProps
*
surfaceProps
TextureReleaseProc
textureReleaseProc
=
nullptr
ReleaseContext
releaseContext
=
nullptr
)
;
SK_API
sk_sp
<
SkSurface
>
WrapBackendRenderTarget
(
GrRecordingContext
*
context
const
GrBackendRenderTarget
&
backendRenderTarget
GrSurfaceOrigin
origin
SkColorType
colorType
sk_sp
<
SkColorSpace
>
colorSpace
const
SkSurfaceProps
*
surfaceProps
RenderTargetReleaseProc
releaseProc
=
nullptr
ReleaseContext
releaseContext
=
nullptr
)
;
using
BackendHandleAccess
=
SkSurface
:
:
BackendHandleAccess
;
SK_API
GrBackendTexture
GetBackendTexture
(
SkSurface
*
BackendHandleAccess
)
;
SK_API
GrBackendRenderTarget
GetBackendRenderTarget
(
SkSurface
*
BackendHandleAccess
)
;
SK_API
void
ResolveMSAA
(
SkSurface
*
surface
)
;
inline
void
ResolveMSAA
(
const
sk_sp
<
SkSurface
>
&
surface
)
{
return
ResolveMSAA
(
surface
.
get
(
)
)
;
}
}
namespace
skgpu
:
:
ganesh
{
SK_API
GrSemaphoresSubmitted
Flush
(
sk_sp
<
SkSurface
>
)
;
SK_API
GrSemaphoresSubmitted
Flush
(
SkSurface
*
)
;
SK_API
void
FlushAndSubmit
(
sk_sp
<
SkSurface
>
)
;
SK_API
void
FlushAndSubmit
(
SkSurface
*
)
;
}
#
endif
