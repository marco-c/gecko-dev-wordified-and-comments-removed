#
ifndef
GrContext_DEFINED
#
define
GrContext_DEFINED
#
include
"
include
/
core
/
SkMatrix
.
h
"
#
include
"
include
/
core
/
SkPathEffect
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
gpu
/
GrBackendSurface
.
h
"
#
include
"
include
/
gpu
/
GrContextOptions
.
h
"
#
include
"
include
/
private
/
GrRecordingContext
.
h
"
#
include
"
include
/
core
/
SkUnPreMultiply
.
h
"
class
GrAtlasManager
;
class
GrBackendSemaphore
;
class
GrCaps
;
class
GrClientMappedBufferManager
;
class
GrContextPriv
;
class
GrContextThreadSafeProxy
;
class
GrFragmentProcessor
;
struct
GrGLInterface
;
class
GrGpu
;
struct
GrMockOptions
;
class
GrPath
;
class
GrRenderTargetContext
;
class
GrResourceCache
;
class
GrResourceProvider
;
class
GrSamplerState
;
class
GrSkSLFPFactoryCache
;
class
GrSurfaceProxy
;
class
GrSwizzle
;
class
GrTextContext
;
class
GrTextureProxy
;
struct
GrVkBackendContext
;
class
SkImage
;
class
SkSurfaceCharacterization
;
class
SkSurfaceProps
;
class
SkTaskGroup
;
class
SkTraceMemoryDump
;
class
SK_API
GrContext
:
public
GrRecordingContext
{
public
:
static
sk_sp
<
GrContext
>
MakeGL
(
sk_sp
<
const
GrGLInterface
>
const
GrContextOptions
&
)
;
static
sk_sp
<
GrContext
>
MakeGL
(
sk_sp
<
const
GrGLInterface
>
)
;
static
sk_sp
<
GrContext
>
MakeGL
(
const
GrContextOptions
&
)
;
static
sk_sp
<
GrContext
>
MakeGL
(
)
;
static
sk_sp
<
GrContext
>
MakeVulkan
(
const
GrVkBackendContext
&
const
GrContextOptions
&
)
;
static
sk_sp
<
GrContext
>
MakeVulkan
(
const
GrVkBackendContext
&
)
;
#
ifdef
SK_METAL
static
sk_sp
<
GrContext
>
MakeMetal
(
void
*
device
void
*
queue
const
GrContextOptions
&
options
)
;
static
sk_sp
<
GrContext
>
MakeMetal
(
void
*
device
void
*
queue
)
;
#
endif
#
ifdef
SK_DAWN
static
sk_sp
<
GrContext
>
MakeDawn
(
const
dawn
:
:
Device
&
device
const
GrContextOptions
&
options
)
;
static
sk_sp
<
GrContext
>
MakeDawn
(
const
dawn
:
:
Device
&
device
)
;
#
endif
static
sk_sp
<
GrContext
>
MakeMock
(
const
GrMockOptions
*
const
GrContextOptions
&
)
;
static
sk_sp
<
GrContext
>
MakeMock
(
const
GrMockOptions
*
)
;
~
GrContext
(
)
override
;
sk_sp
<
GrContextThreadSafeProxy
>
threadSafeProxy
(
)
;
void
resetContext
(
uint32_t
state
=
kAll_GrBackendState
)
;
void
resetGLTextureBindings
(
)
;
void
abandonContext
(
)
override
;
using
GrImageContext
:
:
abandoned
;
virtual
void
releaseResourcesAndAbandonContext
(
)
;
void
getResourceCacheLimits
(
int
*
maxResources
size_t
*
maxResourceBytes
)
const
;
size_t
getResourceCacheLimit
(
)
const
;
void
getResourceCacheUsage
(
int
*
resourceCount
size_t
*
resourceBytes
)
const
;
size_t
getResourceCachePurgeableBytes
(
)
const
;
void
setResourceCacheLimits
(
int
maxResources
size_t
maxResourceBytes
)
;
void
setResourceCacheLimit
(
size_t
maxResourceBytes
)
;
virtual
void
freeGpuResources
(
)
;
void
performDeferredCleanup
(
std
:
:
chrono
:
:
milliseconds
msNotUsed
)
;
void
purgeResourcesNotUsedInMs
(
std
:
:
chrono
:
:
milliseconds
msNotUsed
)
{
this
-
>
performDeferredCleanup
(
msNotUsed
)
;
}
void
purgeUnlockedResources
(
size_t
bytesToPurge
bool
preferScratchResources
)
;
void
purgeUnlockedResources
(
bool
scratchResourcesOnly
)
;
int
maxTextureSize
(
)
const
;
int
maxRenderTargetSize
(
)
const
;
bool
colorTypeSupportedAsImage
(
SkColorType
)
const
;
bool
colorTypeSupportedAsSurface
(
SkColorType
colorType
)
const
{
if
(
kR8G8_unorm_SkColorType
=
=
colorType
|
|
kR16G16_unorm_SkColorType
=
=
colorType
|
|
kA16_unorm_SkColorType
=
=
colorType
|
|
kA16_float_SkColorType
=
=
colorType
|
|
kR16G16_float_SkColorType
=
=
colorType
|
|
kR16G16B16A16_unorm_SkColorType
=
=
colorType
|
|
kGray_8_SkColorType
=
=
colorType
)
{
return
false
;
}
return
this
-
>
maxSurfaceSampleCountForColorType
(
colorType
)
>
0
;
}
int
maxSurfaceSampleCountForColorType
(
SkColorType
)
const
;
bool
wait
(
int
numSemaphores
const
GrBackendSemaphore
*
waitSemaphores
)
;
void
flush
(
)
{
this
-
>
flush
(
GrFlushInfo
(
)
GrPrepareForExternalIORequests
(
)
)
;
}
GrSemaphoresSubmitted
flush
(
const
GrFlushInfo
&
info
)
{
return
this
-
>
flush
(
info
GrPrepareForExternalIORequests
(
)
)
;
}
GrSemaphoresSubmitted
flush
(
const
GrFlushInfo
&
const
GrPrepareForExternalIORequests
&
)
;
GrSemaphoresSubmitted
flush
(
GrFlushFlags
flags
int
numSemaphores
GrBackendSemaphore
signalSemaphores
[
]
GrGpuFinishedProc
finishedProc
=
nullptr
GrGpuFinishedContext
finishedContext
=
nullptr
)
{
GrFlushInfo
info
;
info
.
fFlags
=
flags
;
info
.
fNumSemaphores
=
numSemaphores
;
info
.
fSignalSemaphores
=
signalSemaphores
;
info
.
fFinishedProc
=
finishedProc
;
info
.
fFinishedContext
=
finishedContext
;
return
this
-
>
flush
(
info
)
;
}
GrSemaphoresSubmitted
flushAndSignalSemaphores
(
int
numSemaphores
GrBackendSemaphore
signalSemaphores
[
]
)
{
GrFlushInfo
info
;
info
.
fNumSemaphores
=
numSemaphores
;
info
.
fSignalSemaphores
=
signalSemaphores
;
return
this
-
>
flush
(
info
)
;
}
void
checkAsyncWorkCompletion
(
)
;
GrContextPriv
priv
(
)
;
const
GrContextPriv
priv
(
)
const
;
void
dumpMemoryStatistics
(
SkTraceMemoryDump
*
traceMemoryDump
)
const
;
bool
supportsDistanceFieldText
(
)
const
;
void
storeVkPipelineCacheData
(
)
;
static
size_t
ComputeImageSize
(
sk_sp
<
SkImage
>
image
GrMipMapped
bool
useNextPow2
=
false
)
;
GrBackendFormat
defaultBackendFormat
(
SkColorType
ct
GrRenderable
renderable
)
const
{
return
INHERITED
:
:
defaultBackendFormat
(
ct
renderable
)
;
}
GrBackendTexture
createBackendTexture
(
int
width
int
height
const
GrBackendFormat
&
GrMipMapped
GrRenderable
GrProtected
=
GrProtected
:
:
kNo
)
;
GrBackendTexture
createBackendTexture
(
int
width
int
height
SkColorType
GrMipMapped
GrRenderable
GrProtected
=
GrProtected
:
:
kNo
)
;
GrBackendTexture
createBackendTexture
(
const
SkSurfaceCharacterization
&
characterization
)
;
GrBackendTexture
createBackendTexture
(
int
width
int
height
const
GrBackendFormat
&
const
SkColor4f
&
color
GrMipMapped
GrRenderable
GrProtected
=
GrProtected
:
:
kNo
)
;
GrBackendTexture
createBackendTexture
(
int
width
int
height
SkColorType
const
SkColor4f
&
color
GrMipMapped
GrRenderable
GrProtected
=
GrProtected
:
:
kNo
)
;
GrBackendTexture
createBackendTexture
(
const
SkSurfaceCharacterization
&
characterization
const
SkColor4f
&
color
)
;
GrBackendTexture
createBackendTexture
(
const
SkPixmap
srcData
[
]
int
numLevels
GrRenderable
GrProtected
)
;
GrBackendTexture
createBackendTexture
(
const
SkPixmap
&
srcData
GrRenderable
renderable
GrProtected
isProtected
)
{
return
this
-
>
createBackendTexture
(
&
srcData
1
renderable
isProtected
)
;
}
void
deleteBackendTexture
(
GrBackendTexture
)
;
bool
precompileShader
(
const
SkData
&
key
const
SkData
&
data
)
;
#
ifdef
SK_ENABLE_DUMP_GPU
SkString
dump
(
)
const
;
#
endif
protected
:
GrContext
(
GrBackendApi
const
GrContextOptions
&
int32_t
contextID
=
SK_InvalidGenID
)
;
bool
init
(
sk_sp
<
const
GrCaps
>
sk_sp
<
GrSkSLFPFactoryCache
>
)
override
;
GrContext
*
asDirectContext
(
)
override
{
return
this
;
}
virtual
GrAtlasManager
*
onGetAtlasManager
(
)
=
0
;
sk_sp
<
GrContextThreadSafeProxy
>
fThreadSafeProxy
;
private
:
std
:
:
unique_ptr
<
SkTaskGroup
>
fTaskGroup
;
sk_sp
<
GrGpu
>
fGpu
;
GrResourceCache
*
fResourceCache
;
GrResourceProvider
*
fResourceProvider
;
bool
fDidTestPMConversions
;
bool
fPMUPMConversionsRoundTrip
;
GrContextOptions
:
:
PersistentCache
*
fPersistentCache
;
GrContextOptions
:
:
ShaderErrorHandler
*
fShaderErrorHandler
;
std
:
:
unique_ptr
<
GrClientMappedBufferManager
>
fMappedBufferManager
;
friend
class
GrContextPriv
;
typedef
GrRecordingContext
INHERITED
;
}
;
#
endif
