#
ifndef
GrContext_DEFINED
#
define
GrContext_DEFINED
#
include
"
GrCaps
.
h
"
#
include
"
GrClip
.
h
"
#
include
"
GrColor
.
h
"
#
include
"
GrPaint
.
h
"
#
include
"
GrRenderTarget
.
h
"
#
include
"
GrTextureProvider
.
h
"
#
include
"
SkMatrix
.
h
"
#
include
"
.
.
/
private
/
SkMutex
.
h
"
#
include
"
SkPathEffect
.
h
"
#
include
"
SkTypes
.
h
"
struct
GrBatchAtlasConfig
;
class
GrBatchFontCache
;
struct
GrContextOptions
;
class
GrDrawingManager
;
class
GrDrawContext
;
class
GrDrawTarget
;
class
GrFragmentProcessor
;
class
GrGpu
;
class
GrIndexBuffer
;
class
GrLayerCache
;
class
GrOvalRenderer
;
class
GrPath
;
class
GrPipelineBuilder
;
class
GrResourceEntry
;
class
GrResourceCache
;
class
GrResourceProvider
;
class
GrTestTarget
;
class
GrTextBlobCache
;
class
GrTextContext
;
class
GrTextureParams
;
class
GrVertexBuffer
;
class
GrStrokeInfo
;
class
SkTraceMemoryDump
;
class
SK_API
GrContext
:
public
SkRefCnt
{
public
:
static
GrContext
*
Create
(
GrBackend
GrBackendContext
const
GrContextOptions
&
options
)
;
static
GrContext
*
Create
(
GrBackend
GrBackendContext
)
;
static
GrContext
*
CreateMockContext
(
)
;
virtual
~
GrContext
(
)
;
void
resetContext
(
uint32_t
state
=
kAll_GrBackendState
)
;
typedef
void
(
*
PFCleanUpFunc
)
(
const
GrContext
*
context
void
*
info
)
;
void
addCleanUp
(
PFCleanUpFunc
cleanUp
void
*
info
)
{
CleanUpData
*
entry
=
fCleanUpData
.
push
(
)
;
entry
-
>
fFunc
=
cleanUp
;
entry
-
>
fInfo
=
info
;
}
void
abandonContext
(
)
;
void
getResourceCacheLimits
(
int
*
maxResources
size_t
*
maxResourceBytes
)
const
;
void
getResourceCacheUsage
(
int
*
resourceCount
size_t
*
resourceBytes
)
const
;
void
setResourceCacheLimits
(
int
maxResources
size_t
maxResourceBytes
)
;
GrTextureProvider
*
textureProvider
(
)
{
return
fTextureProvider
;
}
const
GrTextureProvider
*
textureProvider
(
)
const
{
return
fTextureProvider
;
}
void
freeGpuResources
(
)
;
void
purgeAllUnlockedResources
(
)
;
const
GrCaps
*
caps
(
)
const
{
return
fCaps
;
}
int
getRecommendedSampleCount
(
GrPixelConfig
config
SkScalar
dpi
)
const
;
GrDrawContext
*
drawContext
(
GrRenderTarget
*
rt
const
SkSurfaceProps
*
surfaceProps
=
NULL
)
;
enum
FlushBits
{
kDiscard_FlushBit
=
0x2
}
;
void
flush
(
int
flagsBitfield
=
0
)
;
void
flushIfNecessary
(
)
{
if
(
fFlushToReduceCacheSize
|
|
this
-
>
caps
(
)
-
>
immediateFlush
(
)
)
{
this
-
>
flush
(
)
;
}
}
enum
PixelOpsFlags
{
kDontFlush_PixelOpsFlag
=
0x1
kFlushWrites_PixelOp
=
0x2
kUnpremul_PixelOpsFlag
=
0x4
}
;
bool
readSurfacePixels
(
GrSurface
*
surface
int
left
int
top
int
width
int
height
GrPixelConfig
config
void
*
buffer
size_t
rowBytes
=
0
uint32_t
pixelOpsFlags
=
0
)
;
bool
writeSurfacePixels
(
GrSurface
*
surface
int
left
int
top
int
width
int
height
GrPixelConfig
config
const
void
*
buffer
size_t
rowBytes
uint32_t
pixelOpsFlags
=
0
)
;
void
copySurface
(
GrSurface
*
dst
GrSurface
*
src
const
SkIRect
&
srcRect
const
SkIPoint
&
dstPoint
uint32_t
pixelOpsFlags
=
0
)
;
bool
copySurface
(
GrSurface
*
dst
GrSurface
*
src
)
{
if
(
NULL
=
=
dst
|
|
NULL
=
=
src
|
|
dst
-
>
width
(
)
!
=
src
-
>
width
(
)
|
|
dst
-
>
height
(
)
!
=
src
-
>
height
(
)
)
{
return
false
;
}
this
-
>
copySurface
(
dst
src
SkIRect
:
:
MakeWH
(
dst
-
>
width
(
)
dst
-
>
height
(
)
)
SkIPoint
:
:
Make
(
0
0
)
)
;
return
true
;
}
void
flushSurfaceWrites
(
GrSurface
*
surface
)
;
void
prepareSurfaceForExternalIO
(
GrSurface
*
)
;
uint32_t
uniqueID
(
)
{
return
fUniqueID
;
}
GrGpu
*
getGpu
(
)
{
return
fGpu
;
}
const
GrGpu
*
getGpu
(
)
const
{
return
fGpu
;
}
GrBatchFontCache
*
getBatchFontCache
(
)
{
return
fBatchFontCache
;
}
GrLayerCache
*
getLayerCache
(
)
{
return
fLayerCache
.
get
(
)
;
}
GrTextBlobCache
*
getTextBlobCache
(
)
{
return
fTextBlobCache
;
}
bool
abandoned
(
)
const
;
GrResourceProvider
*
resourceProvider
(
)
{
return
fResourceProvider
;
}
const
GrResourceProvider
*
resourceProvider
(
)
const
{
return
fResourceProvider
;
}
GrResourceCache
*
getResourceCache
(
)
{
return
fResourceCache
;
}
void
getTestTarget
(
GrTestTarget
*
GrRenderTarget
*
rt
)
;
void
resetGpuStats
(
)
const
;
void
dumpCacheStats
(
SkString
*
)
const
;
void
dumpCacheStatsKeyValuePairs
(
SkTArray
<
SkString
>
*
keys
SkTArray
<
double
>
*
values
)
const
;
void
printCacheStats
(
)
const
;
void
dumpGpuStats
(
SkString
*
)
const
;
void
dumpGpuStatsKeyValuePairs
(
SkTArray
<
SkString
>
*
keys
SkTArray
<
double
>
*
values
)
const
;
void
printGpuStats
(
)
const
;
void
setTextBlobCacheLimit_ForTesting
(
size_t
bytes
)
;
void
setTextContextAtlasSizes_ForTesting
(
const
GrBatchAtlasConfig
*
configs
)
;
void
dumpMemoryStatistics
(
SkTraceMemoryDump
*
traceMemoryDump
)
const
;
void
drawFontCache
(
const
SkRect
&
rect
GrMaskFormat
format
const
SkPaint
&
paint
GrRenderTarget
*
target
)
;
private
:
GrGpu
*
fGpu
;
const
GrCaps
*
fCaps
;
GrResourceCache
*
fResourceCache
;
union
{
GrResourceProvider
*
fResourceProvider
;
GrTextureProvider
*
fTextureProvider
;
}
;
GrBatchFontCache
*
fBatchFontCache
;
SkAutoTDelete
<
GrLayerCache
>
fLayerCache
;
SkAutoTDelete
<
GrTextBlobCache
>
fTextBlobCache
;
bool
fFlushToReduceCacheSize
;
bool
fDidTestPMConversions
;
int
fPMToUPMConversion
;
int
fUPMToPMConversion
;
SkMutex
fReadPixelsMutex
;
SkMutex
fTestPMConversionsMutex
;
struct
CleanUpData
{
PFCleanUpFunc
fFunc
;
void
*
fInfo
;
}
;
SkTDArray
<
CleanUpData
>
fCleanUpData
;
const
uint32_t
fUniqueID
;
SkAutoTDelete
<
GrDrawingManager
>
fDrawingManager
;
friend
class
GrClipMaskManager
;
friend
class
GrDrawingManager
;
GrDrawingManager
*
drawingManager
(
)
{
return
fDrawingManager
;
}
GrContext
(
)
;
bool
init
(
GrBackend
GrBackendContext
const
GrContextOptions
&
options
)
;
void
initMockContext
(
)
;
void
initCommon
(
const
GrContextOptions
&
)
;
const
GrFragmentProcessor
*
createPMToUPMEffect
(
GrTexture
*
bool
swapRAndB
const
SkMatrix
&
)
const
;
const
GrFragmentProcessor
*
createUPMToPMEffect
(
GrTexture
*
bool
swapRAndB
const
SkMatrix
&
)
const
;
void
testPMConversionsIfNecessary
(
uint32_t
flags
)
;
bool
didFailPMUPMConversionTest
(
)
const
;
static
void
OverBudgetCB
(
void
*
data
)
;
static
void
TextBlobCacheOverBudgetCB
(
void
*
data
)
;
typedef
SkRefCnt
INHERITED
;
}
;
#
endif
