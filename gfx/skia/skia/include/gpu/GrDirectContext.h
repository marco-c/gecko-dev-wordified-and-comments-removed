#
ifndef
GrDirectContext_DEFINED
#
define
GrDirectContext_DEFINED
#
include
"
include
/
core
/
SkColor
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
gpu
/
GpuTypes
.
h
"
#
include
"
include
/
gpu
/
GrContextOptions
.
h
"
#
include
"
include
/
gpu
/
GrRecordingContext
.
h
"
#
include
"
include
/
gpu
/
GrTypes
.
h
"
#
include
<
chrono
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
string_view
>
class
GrAtlasManager
;
class
GrBackendSemaphore
;
class
GrBackendFormat
;
class
GrBackendTexture
;
class
GrBackendRenderTarget
;
class
GrClientMappedBufferManager
;
class
GrContextThreadSafeProxy
;
class
GrDirectContextPriv
;
class
GrGpu
;
class
GrResourceCache
;
class
GrResourceProvider
;
class
SkData
;
class
SkPixmap
;
class
SkTaskGroup
;
class
SkTraceMemoryDump
;
enum
SkColorType
:
int
;
enum
class
SkTextureCompressionType
;
struct
GrGLInterface
;
struct
GrMockOptions
;
struct
GrVkBackendContext
;
struct
GrD3DBackendContext
;
struct
GrMtlBackendContext
;
namespace
skgpu
{
class
MutableTextureState
;
#
if
!
defined
(
SK_ENABLE_OPTIMIZE_SIZE
)
namespace
ganesh
{
class
SmallPathAtlasMgr
;
}
#
endif
}
namespace
sktext
{
namespace
gpu
{
class
StrikeCache
;
}
}
namespace
wgpu
{
class
Device
;
}
class
SK_API
GrDirectContext
:
public
GrRecordingContext
{
public
:
#
ifdef
SK_GL
static
sk_sp
<
GrDirectContext
>
MakeGL
(
sk_sp
<
const
GrGLInterface
>
const
GrContextOptions
&
)
;
static
sk_sp
<
GrDirectContext
>
MakeGL
(
sk_sp
<
const
GrGLInterface
>
)
;
static
sk_sp
<
GrDirectContext
>
MakeGL
(
const
GrContextOptions
&
)
;
static
sk_sp
<
GrDirectContext
>
MakeGL
(
)
;
#
endif
#
ifdef
SK_VULKAN
static
sk_sp
<
GrDirectContext
>
MakeVulkan
(
const
GrVkBackendContext
&
const
GrContextOptions
&
)
;
static
sk_sp
<
GrDirectContext
>
MakeVulkan
(
const
GrVkBackendContext
&
)
;
#
endif
#
ifdef
SK_METAL
static
sk_sp
<
GrDirectContext
>
MakeMetal
(
const
GrMtlBackendContext
&
const
GrContextOptions
&
)
;
static
sk_sp
<
GrDirectContext
>
MakeMetal
(
const
GrMtlBackendContext
&
)
;
static
sk_sp
<
GrDirectContext
>
MakeMetal
(
void
*
device
void
*
queue
const
GrContextOptions
&
)
;
static
sk_sp
<
GrDirectContext
>
MakeMetal
(
void
*
device
void
*
queue
)
;
#
endif
#
ifdef
SK_DIRECT3D
static
sk_sp
<
GrDirectContext
>
MakeDirect3D
(
const
GrD3DBackendContext
&
const
GrContextOptions
&
)
;
static
sk_sp
<
GrDirectContext
>
MakeDirect3D
(
const
GrD3DBackendContext
&
)
;
#
endif
#
ifdef
SK_DAWN
static
sk_sp
<
GrDirectContext
>
MakeDawn
(
const
wgpu
:
:
Device
&
const
GrContextOptions
&
)
;
static
sk_sp
<
GrDirectContext
>
MakeDawn
(
const
wgpu
:
:
Device
&
)
;
#
endif
static
sk_sp
<
GrDirectContext
>
MakeMock
(
const
GrMockOptions
*
const
GrContextOptions
&
)
;
static
sk_sp
<
GrDirectContext
>
MakeMock
(
const
GrMockOptions
*
)
;
~
GrDirectContext
(
)
override
;
void
resetContext
(
uint32_t
state
=
kAll_GrBackendState
)
;
void
resetGLTextureBindings
(
)
;
void
abandonContext
(
)
override
;
bool
abandoned
(
)
override
;
sk_sp
<
GrContextThreadSafeProxy
>
threadSafeProxy
(
)
;
bool
oomed
(
)
;
void
releaseResourcesAndAbandonContext
(
)
;
void
getResourceCacheLimits
(
int
*
maxResources
size_t
*
maxResourceBytes
)
const
;
size_t
getResourceCacheLimit
(
)
const
;
void
getResourceCacheUsage
(
int
*
resourceCount
size_t
*
resourceBytes
)
const
;
size_t
getResourceCachePurgeableBytes
(
)
const
;
void
setResourceCacheLimits
(
int
maxResources
size_t
maxResourceBytes
)
;
void
setResourceCacheLimit
(
size_t
maxResourceBytes
)
;
void
freeGpuResources
(
)
;
void
performDeferredCleanup
(
std
:
:
chrono
:
:
milliseconds
msNotUsed
bool
scratchResourcesOnly
=
false
)
;
void
purgeResourcesNotUsedInMs
(
std
:
:
chrono
:
:
milliseconds
msNotUsed
)
{
this
-
>
performDeferredCleanup
(
msNotUsed
)
;
}
void
purgeUnlockedResources
(
size_t
bytesToPurge
bool
preferScratchResources
)
;
void
purgeUnlockedResources
(
bool
scratchResourcesOnly
)
;
using
GrRecordingContext
:
:
maxTextureSize
;
using
GrRecordingContext
:
:
maxRenderTargetSize
;
using
GrRecordingContext
:
:
colorTypeSupportedAsImage
;
using
GrRecordingContext
:
:
colorTypeSupportedAsSurface
;
using
GrRecordingContext
:
:
maxSurfaceSampleCountForColorType
;
bool
wait
(
int
numSemaphores
const
GrBackendSemaphore
*
waitSemaphores
bool
deleteSemaphoresAfterWait
=
true
)
;
void
flushAndSubmit
(
bool
syncCpu
=
false
)
{
this
-
>
flush
(
GrFlushInfo
(
)
)
;
this
-
>
submit
(
syncCpu
)
;
}
GrSemaphoresSubmitted
flush
(
const
GrFlushInfo
&
info
)
;
void
flush
(
)
{
this
-
>
flush
(
{
}
)
;
}
bool
submit
(
bool
syncCpu
=
false
)
;
void
checkAsyncWorkCompletion
(
)
;
void
dumpMemoryStatistics
(
SkTraceMemoryDump
*
traceMemoryDump
)
const
;
bool
supportsDistanceFieldText
(
)
const
;
void
storeVkPipelineCacheData
(
)
;
using
GrRecordingContext
:
:
defaultBackendFormat
;
GrBackendTexture
createBackendTexture
(
int
width
int
height
const
GrBackendFormat
&
GrMipmapped
GrRenderable
GrProtected
=
GrProtected
:
:
kNo
std
:
:
string_view
label
=
{
}
)
;
GrBackendTexture
createBackendTexture
(
int
width
int
height
SkColorType
GrMipmapped
GrRenderable
GrProtected
=
GrProtected
:
:
kNo
std
:
:
string_view
label
=
{
}
)
;
GrBackendTexture
createBackendTexture
(
int
width
int
height
const
GrBackendFormat
&
const
SkColor4f
&
color
GrMipmapped
GrRenderable
GrProtected
=
GrProtected
:
:
kNo
GrGpuFinishedProc
finishedProc
=
nullptr
GrGpuFinishedContext
finishedContext
=
nullptr
std
:
:
string_view
label
=
{
}
)
;
GrBackendTexture
createBackendTexture
(
int
width
int
height
SkColorType
const
SkColor4f
&
color
GrMipmapped
GrRenderable
GrProtected
=
GrProtected
:
:
kNo
GrGpuFinishedProc
finishedProc
=
nullptr
GrGpuFinishedContext
finishedContext
=
nullptr
std
:
:
string_view
label
=
{
}
)
;
GrBackendTexture
createBackendTexture
(
const
SkPixmap
srcData
[
]
int
numLevels
GrSurfaceOrigin
GrRenderable
GrProtected
GrGpuFinishedProc
finishedProc
=
nullptr
GrGpuFinishedContext
finishedContext
=
nullptr
std
:
:
string_view
label
=
{
}
)
;
GrBackendTexture
createBackendTexture
(
const
SkPixmap
&
srcData
GrSurfaceOrigin
textureOrigin
GrRenderable
renderable
GrProtected
isProtected
GrGpuFinishedProc
finishedProc
=
nullptr
GrGpuFinishedContext
finishedContext
=
nullptr
std
:
:
string_view
label
=
{
}
)
;
GrBackendTexture
createBackendTexture
(
const
SkPixmap
srcData
[
]
int
numLevels
GrRenderable
renderable
GrProtected
isProtected
GrGpuFinishedProc
finishedProc
=
nullptr
GrGpuFinishedContext
finishedContext
=
nullptr
std
:
:
string_view
label
=
{
}
)
;
GrBackendTexture
createBackendTexture
(
const
SkPixmap
&
srcData
GrRenderable
renderable
GrProtected
isProtected
GrGpuFinishedProc
finishedProc
=
nullptr
GrGpuFinishedContext
finishedContext
=
nullptr
std
:
:
string_view
label
=
{
}
)
;
bool
updateBackendTexture
(
const
GrBackendTexture
&
const
SkColor4f
&
color
GrGpuFinishedProc
finishedProc
GrGpuFinishedContext
finishedContext
)
;
bool
updateBackendTexture
(
const
GrBackendTexture
&
SkColorType
skColorType
const
SkColor4f
&
color
GrGpuFinishedProc
finishedProc
GrGpuFinishedContext
finishedContext
)
;
bool
updateBackendTexture
(
const
GrBackendTexture
&
const
SkPixmap
srcData
[
]
int
numLevels
GrSurfaceOrigin
=
kTopLeft_GrSurfaceOrigin
GrGpuFinishedProc
finishedProc
=
nullptr
GrGpuFinishedContext
finishedContext
=
nullptr
)
;
bool
updateBackendTexture
(
const
GrBackendTexture
&
texture
const
SkPixmap
&
srcData
GrSurfaceOrigin
textureOrigin
=
kTopLeft_GrSurfaceOrigin
GrGpuFinishedProc
finishedProc
=
nullptr
GrGpuFinishedContext
finishedContext
=
nullptr
)
{
return
this
-
>
updateBackendTexture
(
texture
&
srcData
1
textureOrigin
finishedProc
finishedContext
)
;
}
bool
updateBackendTexture
(
const
GrBackendTexture
&
texture
const
SkPixmap
srcData
[
]
int
numLevels
GrGpuFinishedProc
finishedProc
GrGpuFinishedContext
finishedContext
)
;
using
GrRecordingContext
:
:
compressedBackendFormat
;
GrBackendTexture
createCompressedBackendTexture
(
int
width
int
height
const
GrBackendFormat
&
const
SkColor4f
&
color
GrMipmapped
GrProtected
=
GrProtected
:
:
kNo
GrGpuFinishedProc
finishedProc
=
nullptr
GrGpuFinishedContext
finishedContext
=
nullptr
)
;
GrBackendTexture
createCompressedBackendTexture
(
int
width
int
height
SkTextureCompressionType
const
SkColor4f
&
color
GrMipmapped
GrProtected
=
GrProtected
:
:
kNo
GrGpuFinishedProc
finishedProc
=
nullptr
GrGpuFinishedContext
finishedContext
=
nullptr
)
;
GrBackendTexture
createCompressedBackendTexture
(
int
width
int
height
const
GrBackendFormat
&
const
void
*
data
size_t
dataSize
GrMipmapped
GrProtected
=
GrProtected
:
:
kNo
GrGpuFinishedProc
finishedProc
=
nullptr
GrGpuFinishedContext
finishedContext
=
nullptr
)
;
GrBackendTexture
createCompressedBackendTexture
(
int
width
int
height
SkTextureCompressionType
const
void
*
data
size_t
dataSize
GrMipmapped
GrProtected
=
GrProtected
:
:
kNo
GrGpuFinishedProc
finishedProc
=
nullptr
GrGpuFinishedContext
finishedContext
=
nullptr
)
;
bool
updateCompressedBackendTexture
(
const
GrBackendTexture
&
const
SkColor4f
&
color
GrGpuFinishedProc
finishedProc
GrGpuFinishedContext
finishedContext
)
;
bool
updateCompressedBackendTexture
(
const
GrBackendTexture
&
const
void
*
data
size_t
dataSize
GrGpuFinishedProc
finishedProc
GrGpuFinishedContext
finishedContext
)
;
bool
setBackendTextureState
(
const
GrBackendTexture
&
const
skgpu
:
:
MutableTextureState
&
skgpu
:
:
MutableTextureState
*
previousState
=
nullptr
GrGpuFinishedProc
finishedProc
=
nullptr
GrGpuFinishedContext
finishedContext
=
nullptr
)
;
bool
setBackendRenderTargetState
(
const
GrBackendRenderTarget
&
const
skgpu
:
:
MutableTextureState
&
skgpu
:
:
MutableTextureState
*
previousState
=
nullptr
GrGpuFinishedProc
finishedProc
=
nullptr
GrGpuFinishedContext
finishedContext
=
nullptr
)
;
void
deleteBackendTexture
(
GrBackendTexture
)
;
bool
precompileShader
(
const
SkData
&
key
const
SkData
&
data
)
;
#
ifdef
SK_ENABLE_DUMP_GPU
SkString
dump
(
)
const
;
#
endif
class
DirectContextID
{
public
:
static
GrDirectContext
:
:
DirectContextID
Next
(
)
;
DirectContextID
(
)
:
fID
(
SK_InvalidUniqueID
)
{
}
bool
operator
=
=
(
const
DirectContextID
&
that
)
const
{
return
fID
=
=
that
.
fID
;
}
bool
operator
!
=
(
const
DirectContextID
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
void
makeInvalid
(
)
{
fID
=
SK_InvalidUniqueID
;
}
bool
isValid
(
)
const
{
return
fID
!
=
SK_InvalidUniqueID
;
}
private
:
constexpr
DirectContextID
(
uint32_t
id
)
:
fID
(
id
)
{
}
uint32_t
fID
;
}
;
DirectContextID
directContextID
(
)
const
{
return
fDirectContextID
;
}
GrDirectContextPriv
priv
(
)
;
const
GrDirectContextPriv
priv
(
)
const
;
protected
:
GrDirectContext
(
GrBackendApi
backend
const
GrContextOptions
&
options
)
;
bool
init
(
)
override
;
GrAtlasManager
*
onGetAtlasManager
(
)
{
return
fAtlasManager
.
get
(
)
;
}
#
if
!
defined
(
SK_ENABLE_OPTIMIZE_SIZE
)
skgpu
:
:
ganesh
:
:
SmallPathAtlasMgr
*
onGetSmallPathAtlasMgr
(
)
;
#
endif
GrDirectContext
*
asDirectContext
(
)
override
{
return
this
;
}
private
:
void
syncAllOutstandingGpuWork
(
bool
shouldExecuteWhileAbandoned
)
;
class
DeleteCallbackHelper
{
public
:
DeleteCallbackHelper
(
GrDirectContextDestroyedContext
context
GrDirectContextDestroyedProc
proc
)
:
fContext
(
context
)
fProc
(
proc
)
{
}
~
DeleteCallbackHelper
(
)
{
if
(
fProc
)
{
fProc
(
fContext
)
;
}
}
private
:
GrDirectContextDestroyedContext
fContext
;
GrDirectContextDestroyedProc
fProc
;
}
;
std
:
:
unique_ptr
<
DeleteCallbackHelper
>
fDeleteCallbackHelper
;
const
DirectContextID
fDirectContextID
;
std
:
:
unique_ptr
<
SkTaskGroup
>
fTaskGroup
;
std
:
:
unique_ptr
<
sktext
:
:
gpu
:
:
StrikeCache
>
fStrikeCache
;
sk_sp
<
GrGpu
>
fGpu
;
std
:
:
unique_ptr
<
GrResourceCache
>
fResourceCache
;
std
:
:
unique_ptr
<
GrResourceProvider
>
fResourceProvider
;
int
fInsideReleaseProcCnt
=
0
;
bool
fDidTestPMConversions
;
bool
fPMUPMConversionsRoundTrip
;
GrContextOptions
:
:
PersistentCache
*
fPersistentCache
;
std
:
:
unique_ptr
<
GrClientMappedBufferManager
>
fMappedBufferManager
;
std
:
:
unique_ptr
<
GrAtlasManager
>
fAtlasManager
;
#
if
!
defined
(
SK_ENABLE_OPTIMIZE_SIZE
)
std
:
:
unique_ptr
<
skgpu
:
:
ganesh
:
:
SmallPathAtlasMgr
>
fSmallPathAtlasMgr
;
#
endif
friend
class
GrDirectContextPriv
;
}
;
#
endif
