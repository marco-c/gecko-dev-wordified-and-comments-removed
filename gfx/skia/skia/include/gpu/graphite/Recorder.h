#
ifndef
skgpu_graphite_Recorder_DEFINED
#
define
skgpu_graphite_Recorder_DEFINED
#
include
"
include
/
core
/
SkCPURecorder
.
h
"
#
include
"
include
/
core
/
SkRecorder
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
gpu
/
graphite
/
GraphiteTypes
.
h
"
#
include
"
include
/
gpu
/
graphite
/
Recording
.
h
"
#
include
"
include
/
private
/
base
/
SingleOwner
.
h
"
#
include
"
include
/
private
/
base
/
SkAPI
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
include
/
private
/
base
/
SkTDArray
.
h
"
#
include
<
chrono
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
optional
>
class
SkCanvas
;
class
SkPixmap
;
class
SkTraceMemoryDump
;
struct
SkISize
;
struct
SkImageInfo
;
#
if
defined
(
SK_BUILD_FOR_ANDROID
)
struct
AHardwareBuffer
;
#
endif
namespace
skgpu
{
enum
class
BackendApi
:
unsigned
int
;
class
RefCntedCallback
;
class
TokenTracker
;
}
namespace
sktext
:
:
gpu
{
class
StrikeCache
;
class
TextBlobRedrawCoordinator
;
}
namespace
skgpu
:
:
graphite
{
class
AtlasProvider
;
class
BackendTexture
;
class
Context
;
class
Device
;
class
DrawBufferManager
;
class
FloatStorageManager
;
class
ImageProvider
;
class
ProxyReadCountMap
;
class
RecorderPriv
;
class
ResourceProvider
;
class
RuntimeEffectDictionary
;
class
SharedContext
;
class
TaskList
;
class
TextureInfo
;
class
UploadBufferManager
;
class
UploadList
;
struct
RecorderOptionsPriv
;
struct
SK_API
RecorderOptions
final
{
RecorderOptions
(
)
;
RecorderOptions
(
const
RecorderOptions
&
)
;
~
RecorderOptions
(
)
;
sk_sp
<
ImageProvider
>
fImageProvider
;
static
constexpr
size_t
kDefaultRecorderBudget
=
256
*
(
1
<
<
20
)
;
size_t
fGpuBudgetInBytes
=
kDefaultRecorderBudget
;
std
:
:
optional
<
bool
>
fRequireOrderedRecordings
;
RecorderOptionsPriv
*
fRecorderOptionsPriv
=
nullptr
;
}
;
class
SK_API
Recorder
final
:
public
SkRecorder
{
public
:
Recorder
(
const
Recorder
&
)
=
delete
;
Recorder
(
Recorder
&
&
)
=
delete
;
Recorder
&
operator
=
(
const
Recorder
&
)
=
delete
;
Recorder
&
operator
=
(
Recorder
&
&
)
=
delete
;
~
Recorder
(
)
override
;
BackendApi
backend
(
)
const
;
Type
type
(
)
const
override
{
return
SkRecorder
:
:
Type
:
:
kGraphite
;
}
skcpu
:
:
Recorder
*
cpuRecorder
(
)
override
;
std
:
:
unique_ptr
<
Recording
>
snap
(
)
;
ImageProvider
*
clientImageProvider
(
)
{
return
fClientImageProvider
.
get
(
)
;
}
const
ImageProvider
*
clientImageProvider
(
)
const
{
return
fClientImageProvider
.
get
(
)
;
}
int
maxTextureSize
(
)
const
;
BackendTexture
createBackendTexture
(
SkISize
dimensions
const
TextureInfo
&
)
;
#
ifdef
SK_BUILD_FOR_ANDROID
BackendTexture
createBackendTexture
(
AHardwareBuffer
*
bool
isRenderable
bool
isProtectedContent
SkISize
dimensions
bool
fromAndroidWindow
=
false
)
const
;
#
endif
bool
updateBackendTexture
(
const
BackendTexture
&
const
SkPixmap
srcData
[
]
int
numLevels
GpuFinishedProc
=
nullptr
GpuFinishedContext
=
nullptr
)
;
bool
updateCompressedBackendTexture
(
const
BackendTexture
&
const
void
*
data
size_t
dataSize
GpuFinishedProc
=
nullptr
GpuFinishedContext
=
nullptr
)
;
void
deleteBackendTexture
(
const
BackendTexture
&
)
;
void
addFinishInfo
(
const
InsertFinishInfo
&
)
;
SkCanvas
*
makeDeferredCanvas
(
const
SkImageInfo
&
const
TextureInfo
&
)
;
void
freeGpuResources
(
)
;
void
performDeferredCleanup
(
std
:
:
chrono
:
:
milliseconds
msNotUsed
)
;
size_t
currentBudgetedBytes
(
)
const
;
size_t
currentPurgeableBytes
(
)
const
;
size_t
maxBudgetedBytes
(
)
const
;
void
setMaxBudgetedBytes
(
size_t
bytes
)
;
void
dumpMemoryStatistics
(
SkTraceMemoryDump
*
traceMemoryDump
)
const
;
RecorderPriv
priv
(
)
;
const
RecorderPriv
priv
(
)
const
;
private
:
friend
class
Context
;
friend
class
Device
;
friend
class
RecorderPriv
;
Recorder
(
sk_sp
<
SharedContext
>
const
RecorderOptions
&
const
Context
*
)
;
SingleOwner
*
singleOwner
(
)
const
{
return
&
fSingleOwner
;
}
void
registerDevice
(
sk_sp
<
Device
>
)
;
void
deregisterDevice
(
const
Device
*
)
;
SkCanvas
*
makeCaptureCanvas
(
SkCanvas
*
)
override
;
sk_sp
<
SharedContext
>
fSharedContext
;
ResourceProvider
*
fResourceProvider
;
std
:
:
unique_ptr
<
ResourceProvider
>
fOwnedResourceProvider
;
sk_sp
<
RuntimeEffectDictionary
>
fRuntimeEffectDict
;
std
:
:
unique_ptr
<
TaskList
>
fRootTaskList
;
std
:
:
unique_ptr
<
UploadList
>
fRootUploads
;
std
:
:
unique_ptr
<
DrawBufferManager
>
fDrawBufferManager
;
std
:
:
unique_ptr
<
UploadBufferManager
>
fUploadBufferManager
;
sk_sp
<
FloatStorageManager
>
fFloatStorageManager
;
std
:
:
unique_ptr
<
ProxyReadCountMap
>
fProxyReadCounts
;
skia_private
:
:
TArray
<
sk_sp
<
Device
>
>
fTrackedDevices
;
int
fFlushingDevicesIndex
=
-
1
;
uint32_t
fUniqueID
;
uint32_t
fNextRecordingID
=
1
;
const
bool
fRequireOrderedRecordings
;
std
:
:
unique_ptr
<
AtlasProvider
>
fAtlasProvider
;
std
:
:
unique_ptr
<
TokenTracker
>
fTokenTracker
;
std
:
:
unique_ptr
<
sktext
:
:
gpu
:
:
StrikeCache
>
fStrikeCache
;
std
:
:
unique_ptr
<
sktext
:
:
gpu
:
:
TextBlobRedrawCoordinator
>
fTextBlobCache
;
sk_sp
<
ImageProvider
>
fClientImageProvider
;
mutable
SingleOwner
fSingleOwner
;
sk_sp
<
Device
>
fTargetProxyDevice
;
std
:
:
unique_ptr
<
SkCanvas
>
fTargetProxyCanvas
;
std
:
:
unique_ptr
<
Recording
:
:
LazyProxyData
>
fTargetProxyData
;
skia_private
:
:
TArray
<
sk_sp
<
RefCntedCallback
>
>
fFinishedProcs
;
#
if
defined
(
GPU_TEST_UTILS
)
Context
*
fContext
=
nullptr
;
#
endif
#
if
defined
(
SK_DUMP_TASKS
)
void
dumpTasks
(
TaskList
*
)
const
;
SkTDArray
<
const
char
*
>
fFlushSources
;
#
endif
}
;
}
#
endif
