#
ifndef
skgpu_graphite_Recorder_DEFINED
#
define
skgpu_graphite_Recorder_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSize
.
h
"
#
include
"
include
/
gpu
/
graphite
/
GraphiteTypes
.
h
"
#
include
"
include
/
gpu
/
graphite
/
Recording
.
h
"
#
include
"
include
/
private
/
base
/
SingleOwner
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
<
vector
>
class
SkCanvas
;
struct
SkImageInfo
;
class
SkPixmap
;
namespace
skgpu
{
class
RefCntedCallback
;
class
TokenTracker
;
}
namespace
sktext
:
:
gpu
{
class
StrikeCache
;
class
TextBlobRedrawCoordinator
;
}
namespace
skgpu
:
:
graphite
{
class
AtlasManager
;
class
BackendTexture
;
class
Caps
;
class
Context
;
class
Device
;
class
DrawBufferManager
;
class
GlobalCache
;
class
ImageProvider
;
class
RecorderPriv
;
class
ResourceProvider
;
class
RuntimeEffectDictionary
;
class
SharedContext
;
class
Task
;
class
TaskGraph
;
class
TextureDataBlock
;
class
TextureInfo
;
class
UniformDataBlock
;
class
UploadBufferManager
;
template
<
typename
T
>
class
PipelineDataCache
;
using
UniformDataCache
=
PipelineDataCache
<
UniformDataBlock
>
;
using
TextureDataCache
=
PipelineDataCache
<
TextureDataBlock
>
;
struct
SK_API
RecorderOptions
final
{
RecorderOptions
(
)
;
RecorderOptions
(
const
RecorderOptions
&
)
;
~
RecorderOptions
(
)
;
sk_sp
<
ImageProvider
>
fImageProvider
;
}
;
class
SK_API
Recorder
final
{
public
:
Recorder
(
const
Recorder
&
)
=
delete
;
Recorder
(
Recorder
&
&
)
=
delete
;
Recorder
&
operator
=
(
const
Recorder
&
)
=
delete
;
Recorder
&
operator
=
(
Recorder
&
&
)
=
delete
;
~
Recorder
(
)
;
std
:
:
unique_ptr
<
Recording
>
snap
(
)
;
ImageProvider
*
clientImageProvider
(
)
{
return
fClientImageProvider
.
get
(
)
;
}
const
ImageProvider
*
clientImageProvider
(
)
const
{
return
fClientImageProvider
.
get
(
)
;
}
BackendTexture
createBackendTexture
(
SkISize
dimensions
const
TextureInfo
&
)
;
bool
updateBackendTexture
(
const
BackendTexture
&
const
SkPixmap
srcData
[
]
int
numLevels
)
;
void
deleteBackendTexture
(
BackendTexture
&
)
;
void
addFinishInfo
(
const
InsertFinishInfo
&
)
;
SkCanvas
*
makeDeferredCanvas
(
const
SkImageInfo
&
const
TextureInfo
&
)
;
RecorderPriv
priv
(
)
;
const
RecorderPriv
priv
(
)
const
;
#
if
GR_TEST_UTILS
bool
deviceIsRegistered
(
Device
*
)
;
#
endif
private
:
friend
class
Context
;
friend
class
Device
;
friend
class
RecorderPriv
;
Recorder
(
sk_sp
<
SharedContext
>
const
RecorderOptions
&
)
;
SingleOwner
*
singleOwner
(
)
const
{
return
&
fSingleOwner
;
}
BackendApi
backend
(
)
const
;
void
registerDevice
(
Device
*
)
;
void
deregisterDevice
(
const
Device
*
)
;
sk_sp
<
SharedContext
>
fSharedContext
;
std
:
:
unique_ptr
<
ResourceProvider
>
fResourceProvider
;
std
:
:
unique_ptr
<
RuntimeEffectDictionary
>
fRuntimeEffectDict
;
std
:
:
unique_ptr
<
TaskGraph
>
fGraph
;
std
:
:
unique_ptr
<
UniformDataCache
>
fUniformDataCache
;
std
:
:
unique_ptr
<
TextureDataCache
>
fTextureDataCache
;
std
:
:
unique_ptr
<
DrawBufferManager
>
fDrawBufferManager
;
std
:
:
unique_ptr
<
UploadBufferManager
>
fUploadBufferManager
;
std
:
:
vector
<
Device
*
>
fTrackedDevices
;
uint32_t
fRecorderID
;
std
:
:
unique_ptr
<
AtlasManager
>
fAtlasManager
;
std
:
:
unique_ptr
<
TokenTracker
>
fTokenTracker
;
std
:
:
unique_ptr
<
sktext
:
:
gpu
:
:
StrikeCache
>
fStrikeCache
;
std
:
:
unique_ptr
<
sktext
:
:
gpu
:
:
TextBlobRedrawCoordinator
>
fTextBlobCache
;
sk_sp
<
ImageProvider
>
fClientImageProvider
;
mutable
SingleOwner
fSingleOwner
;
sk_sp
<
Device
>
fTargetProxyDevice
;
std
:
:
unique_ptr
<
SkCanvas
>
fTargetProxyCanvas
;
std
:
:
unique_ptr
<
Recording
:
:
LazyProxyData
>
fTargetProxyData
;
SkTArray
<
sk_sp
<
RefCntedCallback
>
>
fFinishedProcs
;
#
if
GRAPHITE_TEST_UTILS
Context
*
fContext
=
nullptr
;
#
endif
}
;
}
#
endif
