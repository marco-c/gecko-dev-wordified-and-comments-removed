#
ifndef
skgpu_graphite_Image_DEFINED
#
define
skgpu_graphite_Image_DEFINED
#
include
"
include
/
core
/
SkColorSpace
.
h
"
#
include
"
include
/
core
/
SkImage
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSpan
.
h
"
#
include
"
include
/
gpu
/
GpuTypes
.
h
"
class
SkYUVAInfo
;
class
SkYUVAPixmaps
;
struct
SkIRect
;
namespace
skgpu
:
:
graphite
{
class
BackendTexture
;
class
Recorder
;
class
TextureInfo
;
class
YUVABackendTextureInfo
;
class
YUVABackendTextures
;
enum
class
Volatile
:
bool
;
}
namespace
SkImages
{
enum
class
GenerateMipmapsFromBase
:
bool
{
kNo
kYes
}
;
using
TextureReleaseProc
=
void
(
*
)
(
ReleaseContext
)
;
using
GraphitePromiseImageContext
=
void
*
;
using
GraphitePromiseTextureContext
=
void
*
;
using
GraphitePromiseTextureReleaseContext
=
void
*
;
using
GraphitePromiseImageFulfillProc
=
std
:
:
tuple
<
skgpu
:
:
graphite
:
:
BackendTexture
GraphitePromiseTextureReleaseContext
>
(
*
)
(
GraphitePromiseImageContext
)
;
using
GraphitePromiseImageYUVAFulfillProc
=
std
:
:
tuple
<
skgpu
:
:
graphite
:
:
BackendTexture
GraphitePromiseTextureReleaseContext
>
(
*
)
(
GraphitePromiseTextureContext
)
;
using
GraphitePromiseImageReleaseProc
=
void
(
*
)
(
GraphitePromiseImageContext
)
;
using
GraphitePromiseTextureReleaseProc
=
void
(
*
)
(
GraphitePromiseTextureReleaseContext
)
;
SK_API
sk_sp
<
SkImage
>
WrapTexture
(
skgpu
:
:
graphite
:
:
Recorder
*
const
skgpu
:
:
graphite
:
:
BackendTexture
&
SkColorType
colorType
SkAlphaType
alphaType
sk_sp
<
SkColorSpace
>
colorSpace
skgpu
:
:
Origin
origin
GenerateMipmapsFromBase
generateMipmapsFromBase
TextureReleaseProc
=
nullptr
ReleaseContext
=
nullptr
)
;
SK_API
sk_sp
<
SkImage
>
WrapTexture
(
skgpu
:
:
graphite
:
:
Recorder
*
const
skgpu
:
:
graphite
:
:
BackendTexture
&
SkColorType
colorType
SkAlphaType
alphaType
sk_sp
<
SkColorSpace
>
colorSpace
skgpu
:
:
Origin
origin
TextureReleaseProc
=
nullptr
ReleaseContext
=
nullptr
)
;
SK_API
sk_sp
<
SkImage
>
WrapTexture
(
skgpu
:
:
graphite
:
:
Recorder
*
const
skgpu
:
:
graphite
:
:
BackendTexture
&
SkColorType
colorType
SkAlphaType
alphaType
sk_sp
<
SkColorSpace
>
colorSpace
TextureReleaseProc
=
nullptr
ReleaseContext
=
nullptr
)
;
#
if
!
defined
(
SK_DISABLE_LEGACY_GRAPHITE_IMAGES
)
inline
sk_sp
<
SkImage
>
AdoptTextureFrom
(
skgpu
:
:
graphite
:
:
Recorder
*
recorder
const
skgpu
:
:
graphite
:
:
BackendTexture
&
tex
SkColorType
colorType
SkAlphaType
alphaType
sk_sp
<
SkColorSpace
>
colorSpace
skgpu
:
:
Origin
origin
TextureReleaseProc
trProc
=
nullptr
ReleaseContext
ctx
=
nullptr
)
{
return
WrapTexture
(
recorder
tex
colorType
alphaType
colorSpace
origin
trProc
ctx
)
;
}
inline
sk_sp
<
SkImage
>
AdoptTextureFrom
(
skgpu
:
:
graphite
:
:
Recorder
*
recorder
const
skgpu
:
:
graphite
:
:
BackendTexture
&
tex
SkColorType
colorType
SkAlphaType
alphaType
sk_sp
<
SkColorSpace
>
colorSpace
TextureReleaseProc
trProc
=
nullptr
ReleaseContext
ctx
=
nullptr
)
{
return
WrapTexture
(
recorder
tex
colorType
alphaType
colorSpace
trProc
ctx
)
;
}
#
endif
SK_API
sk_sp
<
SkImage
>
PromiseTextureFrom
(
skgpu
:
:
graphite
:
:
Recorder
*
SkISize
dimensions
const
skgpu
:
:
graphite
:
:
TextureInfo
&
const
SkColorInfo
&
skgpu
:
:
Origin
origin
skgpu
:
:
graphite
:
:
Volatile
GraphitePromiseImageFulfillProc
GraphitePromiseImageReleaseProc
GraphitePromiseTextureReleaseProc
GraphitePromiseImageContext
)
;
SK_API
sk_sp
<
SkImage
>
PromiseTextureFrom
(
skgpu
:
:
graphite
:
:
Recorder
*
SkISize
dimensions
const
skgpu
:
:
graphite
:
:
TextureInfo
&
const
SkColorInfo
&
skgpu
:
:
graphite
:
:
Volatile
GraphitePromiseImageFulfillProc
GraphitePromiseImageReleaseProc
GraphitePromiseTextureReleaseProc
GraphitePromiseImageContext
)
;
SK_API
sk_sp
<
SkImage
>
PromiseTextureFromYUVA
(
skgpu
:
:
graphite
:
:
Recorder
*
const
skgpu
:
:
graphite
:
:
YUVABackendTextureInfo
&
sk_sp
<
SkColorSpace
>
imageColorSpace
skgpu
:
:
graphite
:
:
Volatile
GraphitePromiseImageYUVAFulfillProc
GraphitePromiseImageReleaseProc
GraphitePromiseTextureReleaseProc
GraphitePromiseImageContext
imageContext
GraphitePromiseTextureContext
textureContexts
[
]
)
;
SK_API
sk_sp
<
SkImage
>
TextureFromImage
(
skgpu
:
:
graphite
:
:
Recorder
*
const
SkImage
*
SkImage
:
:
RequiredProperties
=
{
}
)
;
inline
sk_sp
<
SkImage
>
TextureFromImage
(
skgpu
:
:
graphite
:
:
Recorder
*
r
const
sk_sp
<
const
SkImage
>
&
img
SkImage
:
:
RequiredProperties
props
=
{
}
)
{
return
TextureFromImage
(
r
img
.
get
(
)
props
)
;
}
SK_API
sk_sp
<
SkImage
>
TextureFromYUVAPixmaps
(
skgpu
:
:
graphite
:
:
Recorder
*
const
SkYUVAPixmaps
&
pixmaps
SkImage
:
:
RequiredProperties
=
{
}
bool
limitToMaxTextureSize
=
false
sk_sp
<
SkColorSpace
>
imgColorSpace
=
nullptr
)
;
SK_API
sk_sp
<
SkImage
>
TextureFromYUVATextures
(
skgpu
:
:
graphite
:
:
Recorder
*
recorder
const
skgpu
:
:
graphite
:
:
YUVABackendTextures
&
yuvaBackendTextures
sk_sp
<
SkColorSpace
>
imageColorSpace
TextureReleaseProc
=
nullptr
ReleaseContext
=
nullptr
)
;
SK_API
sk_sp
<
SkImage
>
TextureFromYUVAImages
(
skgpu
:
:
graphite
:
:
Recorder
*
recorder
const
SkYUVAInfo
&
yuvaInfo
SkSpan
<
const
sk_sp
<
SkImage
>
>
images
sk_sp
<
SkColorSpace
>
imageColorSpace
)
;
SK_API
sk_sp
<
SkImage
>
SubsetTextureFrom
(
skgpu
:
:
graphite
:
:
Recorder
*
recorder
const
SkImage
*
img
const
SkIRect
&
subset
SkImage
:
:
RequiredProperties
props
=
{
}
)
;
SK_API
sk_sp
<
SkImage
>
MakeWithFilter
(
skgpu
:
:
graphite
:
:
Recorder
*
recorder
sk_sp
<
SkImage
>
src
const
SkImageFilter
*
filter
const
SkIRect
&
subset
const
SkIRect
&
clipBounds
SkIRect
*
outSubset
SkIPoint
*
offset
)
;
}
#
endif
