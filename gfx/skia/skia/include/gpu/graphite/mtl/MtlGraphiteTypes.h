#
ifndef
skgpu_graphite_MtlGraphiteTypes_DEFINED
#
define
skgpu_graphite_MtlGraphiteTypes_DEFINED
#
if
__OBJC__
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
gpu
/
graphite
/
GraphiteTypes
.
h
"
#
include
"
include
/
gpu
/
graphite
/
TextureInfo
.
h
"
#
include
"
include
/
gpu
/
graphite
/
mtl
/
MtlGraphiteTypes_cpp
.
h
"
#
include
"
include
/
private
/
base
/
SkAPI
.
h
"
#
import
<
CoreFoundation
/
CoreFoundation
.
h
>
#
import
<
Metal
/
Metal
.
h
>
#
import
<
TargetConditionals
.
h
>
class
SkStream
;
class
SkWStream
;
namespace
skgpu
:
:
graphite
{
class
SK_API
MtlTextureInfo
final
:
public
TextureInfo
:
:
Data
{
public
:
MTLPixelFormat
fFormat
=
MTLPixelFormatInvalid
;
MTLTextureUsage
fUsage
=
MTLTextureUsageUnknown
;
MTLStorageMode
fStorageMode
=
MTLStorageModeShared
;
bool
fFramebufferOnly
=
false
;
MtlTextureInfo
(
)
=
default
;
MtlTextureInfo
(
CFTypeRef
mtlTexture
)
;
MtlTextureInfo
(
uint32_t
sampleCount
skgpu
:
:
Mipmapped
mipmapped
MTLPixelFormat
format
MTLTextureUsage
usage
MTLStorageMode
storageMode
bool
framebufferOnly
)
:
Data
(
sampleCount
mipmapped
)
fFormat
(
format
)
fUsage
(
usage
)
fStorageMode
(
storageMode
)
fFramebufferOnly
(
framebufferOnly
)
{
}
private
:
friend
class
TextureInfo
;
friend
class
TextureInfoPriv
;
static
constexpr
skgpu
:
:
BackendApi
kBackend
=
skgpu
:
:
BackendApi
:
:
kMetal
;
Protected
isProtected
(
)
const
{
return
Protected
:
:
kNo
;
}
TextureFormat
viewFormat
(
)
const
;
bool
serialize
(
SkWStream
*
)
const
;
bool
deserialize
(
SkStream
*
)
;
SkString
toBackendString
(
)
const
override
;
void
copyTo
(
TextureInfo
:
:
AnyTextureInfoData
&
dstData
)
const
override
{
dstData
.
emplace
<
MtlTextureInfo
>
(
*
this
)
;
}
bool
isCompatible
(
const
TextureInfo
&
that
bool
requireExact
)
const
override
;
}
;
}
#
endif
#
endif
