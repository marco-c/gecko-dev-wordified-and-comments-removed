#
ifndef
skgpu_graphite_TextureInfo_DEFINED
#
define
skgpu_graphite_TextureInfo_DEFINED
#
include
"
include
/
core
/
SkString
.
h
"
#
include
"
include
/
core
/
SkTextureCompressionType
.
h
"
#
include
"
include
/
gpu
/
graphite
/
GraphiteTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkAPI
.
h
"
#
include
"
include
/
private
/
base
/
SkAnySubclass
.
h
"
struct
SkISize
;
namespace
skgpu
:
:
graphite
{
enum
class
TextureFormat
:
uint8_t
;
class
SK_API
TextureInfo
{
private
:
class
Data
;
friend
class
MtlTextureInfo
;
friend
class
DawnTextureInfo
;
friend
class
VulkanTextureInfo
;
inline
constexpr
static
size_t
kMaxSubclassSize
=
112
;
using
AnyTextureInfoData
=
SkAnySubclass
<
Data
kMaxSubclassSize
>
;
class
Data
{
public
:
virtual
~
Data
(
)
=
default
;
Data
(
uint32_t
sampleCount
skgpu
:
:
Mipmapped
mipmapped
)
:
fSampleCount
(
sampleCount
)
fMipmapped
(
mipmapped
)
{
}
Data
(
)
=
default
;
Data
(
const
Data
&
)
=
default
;
Data
&
operator
=
(
const
Data
&
)
=
default
;
uint32_t
fSampleCount
=
1
;
Mipmapped
fMipmapped
=
Mipmapped
:
:
kNo
;
private
:
friend
class
TextureInfo
;
friend
class
TextureInfoPriv
;
virtual
SkString
toBackendString
(
)
const
=
0
;
virtual
void
copyTo
(
AnyTextureInfoData
&
)
const
=
0
;
virtual
bool
isCompatible
(
const
TextureInfo
&
that
bool
requireExact
)
const
=
0
;
}
;
public
:
TextureInfo
(
)
=
default
;
~
TextureInfo
(
)
=
default
;
TextureInfo
(
const
TextureInfo
&
)
;
TextureInfo
&
operator
=
(
const
TextureInfo
&
)
;
bool
operator
=
=
(
const
TextureInfo
&
that
)
const
{
return
this
-
>
isCompatible
(
that
true
)
;
}
bool
operator
!
=
(
const
TextureInfo
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
bool
isValid
(
)
const
{
return
fData
.
has_value
(
)
;
}
BackendApi
backend
(
)
const
{
SkASSERT
(
fData
.
has_value
(
)
|
|
fBackend
=
=
BackendApi
:
:
kUnsupported
)
;
return
fBackend
;
}
uint32_t
numSamples
(
)
const
{
return
fData
.
has_value
(
)
?
fData
-
>
fSampleCount
:
1
;
}
Mipmapped
mipmapped
(
)
const
{
return
fData
.
has_value
(
)
?
fData
-
>
fMipmapped
:
Mipmapped
:
:
kNo
;
}
Protected
isProtected
(
)
const
{
return
fProtected
;
}
bool
canBeFulfilledBy
(
const
TextureInfo
&
that
)
const
{
return
this
-
>
isCompatible
(
that
false
)
;
}
SkString
toString
(
)
const
;
private
:
friend
class
TextureInfoPriv
;
template
<
typename
BackendTextureData
std
:
:
enable_if_t
<
std
:
:
is_base_of_v
<
Data
BackendTextureData
>
bool
>
=
true
>
explicit
TextureInfo
(
const
BackendTextureData
&
data
)
:
fBackend
(
BackendTextureData
:
:
kBackend
)
fViewFormat
(
data
.
viewFormat
(
)
)
fProtected
(
data
.
isProtected
(
)
)
{
fData
.
emplace
<
BackendTextureData
>
(
data
)
;
}
bool
isCompatible
(
const
TextureInfo
&
that
bool
requireExact
)
const
;
skgpu
:
:
BackendApi
fBackend
=
BackendApi
:
:
kUnsupported
;
AnyTextureInfoData
fData
;
TextureFormat
fViewFormat
;
Protected
fProtected
=
Protected
:
:
kNo
;
}
;
}
#
endif
