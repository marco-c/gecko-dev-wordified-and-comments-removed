#
ifndef
skgpu_graphite_Context_DEFINED
#
define
skgpu_graphite_Context_DEFINED
#
include
"
include
/
core
/
SkImage
.
h
"
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkShader
.
h
"
#
include
"
include
/
gpu
/
graphite
/
ContextOptions
.
h
"
#
include
"
include
/
gpu
/
graphite
/
GraphiteTypes
.
h
"
#
include
"
include
/
gpu
/
graphite
/
Recorder
.
h
"
#
include
"
include
/
private
/
base
/
SingleOwner
.
h
"
#
include
<
chrono
>
#
include
<
functional
>
#
include
<
memory
>
class
SkColorSpace
;
class
SkRuntimeEffect
;
class
SkTraceMemoryDump
;
namespace
skgpu
:
:
graphite
{
class
BackendTexture
;
class
Buffer
;
class
ClientMappedBufferManager
;
class
Context
;
class
ContextPriv
;
class
GlobalCache
;
class
PaintOptions
;
class
PlotUploadTracker
;
class
QueueManager
;
class
Recording
;
class
ResourceProvider
;
class
SharedContext
;
class
TextureProxy
;
class
SK_API
Context
final
{
public
:
Context
(
const
Context
&
)
=
delete
;
Context
(
Context
&
&
)
=
delete
;
Context
&
operator
=
(
const
Context
&
)
=
delete
;
Context
&
operator
=
(
Context
&
&
)
=
delete
;
~
Context
(
)
;
BackendApi
backend
(
)
const
;
std
:
:
unique_ptr
<
Recorder
>
makeRecorder
(
const
RecorderOptions
&
=
{
}
)
;
bool
insertRecording
(
const
InsertRecordingInfo
&
)
;
bool
submit
(
SyncToCpu
=
SyncToCpu
:
:
kNo
)
;
bool
hasUnfinishedGpuWork
(
)
const
;
void
asyncRescaleAndReadPixels
(
const
SkImage
*
image
const
SkImageInfo
&
dstImageInfo
const
SkIRect
&
srcRect
SkImage
:
:
RescaleGamma
rescaleGamma
SkImage
:
:
RescaleMode
rescaleMode
SkImage
:
:
ReadPixelsCallback
callback
SkImage
:
:
ReadPixelsContext
context
)
;
void
asyncRescaleAndReadPixels
(
const
SkSurface
*
surface
const
SkImageInfo
&
dstImageInfo
const
SkIRect
&
srcRect
SkImage
:
:
RescaleGamma
rescaleGamma
SkImage
:
:
RescaleMode
rescaleMode
SkImage
:
:
ReadPixelsCallback
callback
SkImage
:
:
ReadPixelsContext
context
)
;
void
asyncRescaleAndReadPixelsYUV420
(
const
SkImage
*
SkYUVColorSpace
yuvColorSpace
sk_sp
<
SkColorSpace
>
dstColorSpace
const
SkIRect
&
srcRect
const
SkISize
&
dstSize
SkImage
:
:
RescaleGamma
rescaleGamma
SkImage
:
:
RescaleMode
rescaleMode
SkImage
:
:
ReadPixelsCallback
callback
SkImage
:
:
ReadPixelsContext
context
)
;
void
asyncRescaleAndReadPixelsYUV420
(
const
SkSurface
*
SkYUVColorSpace
yuvColorSpace
sk_sp
<
SkColorSpace
>
dstColorSpace
const
SkIRect
&
srcRect
const
SkISize
&
dstSize
SkImage
:
:
RescaleGamma
rescaleGamma
SkImage
:
:
RescaleMode
rescaleMode
SkImage
:
:
ReadPixelsCallback
callback
SkImage
:
:
ReadPixelsContext
context
)
;
void
asyncRescaleAndReadPixelsYUVA420
(
const
SkImage
*
SkYUVColorSpace
yuvColorSpace
sk_sp
<
SkColorSpace
>
dstColorSpace
const
SkIRect
&
srcRect
const
SkISize
&
dstSize
SkImage
:
:
RescaleGamma
rescaleGamma
SkImage
:
:
RescaleMode
rescaleMode
SkImage
:
:
ReadPixelsCallback
callback
SkImage
:
:
ReadPixelsContext
context
)
;
void
asyncRescaleAndReadPixelsYUVA420
(
const
SkSurface
*
SkYUVColorSpace
yuvColorSpace
sk_sp
<
SkColorSpace
>
dstColorSpace
const
SkIRect
&
srcRect
const
SkISize
&
dstSize
SkImage
:
:
RescaleGamma
rescaleGamma
SkImage
:
:
RescaleMode
rescaleMode
SkImage
:
:
ReadPixelsCallback
callback
SkImage
:
:
ReadPixelsContext
context
)
;
void
checkAsyncWorkCompletion
(
)
;
void
deleteBackendTexture
(
const
BackendTexture
&
)
;
void
freeGpuResources
(
)
;
void
performDeferredCleanup
(
std
:
:
chrono
:
:
milliseconds
msNotUsed
)
;
size_t
currentBudgetedBytes
(
)
const
;
size_t
maxBudgetedBytes
(
)
const
;
void
dumpMemoryStatistics
(
SkTraceMemoryDump
*
traceMemoryDump
)
const
;
bool
isDeviceLost
(
)
const
;
int
maxTextureSize
(
)
const
;
bool
supportsProtectedContent
(
)
const
;
ContextPriv
priv
(
)
;
const
ContextPriv
priv
(
)
const
;
class
ContextID
{
public
:
static
Context
:
:
ContextID
Next
(
)
;
ContextID
(
)
:
fID
(
SK_InvalidUniqueID
)
{
}
bool
operator
=
=
(
const
ContextID
&
that
)
const
{
return
fID
=
=
that
.
fID
;
}
bool
operator
!
=
(
const
ContextID
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
void
makeInvalid
(
)
{
fID
=
SK_InvalidUniqueID
;
}
bool
isValid
(
)
const
{
return
fID
!
=
SK_InvalidUniqueID
;
}
private
:
constexpr
ContextID
(
uint32_t
id
)
:
fID
(
id
)
{
}
uint32_t
fID
;
}
;
ContextID
contextID
(
)
const
{
return
fContextID
;
}
protected
:
Context
(
sk_sp
<
SharedContext
>
std
:
:
unique_ptr
<
QueueManager
>
const
ContextOptions
&
)
;
private
:
friend
class
ContextPriv
;
friend
class
ContextCtorAccessor
;
struct
PixelTransferResult
{
using
ConversionFn
=
void
(
void
*
dst
const
void
*
mappedBuffer
)
;
sk_sp
<
Buffer
>
fTransferBuffer
;
SkISize
fSize
;
size_t
fRowBytes
;
std
:
:
function
<
ConversionFn
>
fPixelConverter
;
}
;
SingleOwner
*
singleOwner
(
)
const
{
return
&
fSingleOwner
;
}
bool
finishInitialization
(
)
;
void
checkForFinishedWork
(
SyncToCpu
)
;
void
asyncRescaleAndReadPixelsYUV420Impl
(
const
SkImage
*
SkYUVColorSpace
yuvColorSpace
bool
readAlpha
sk_sp
<
SkColorSpace
>
dstColorSpace
const
SkIRect
&
srcRect
const
SkISize
&
dstSize
SkImage
:
:
RescaleGamma
rescaleGamma
SkImage
:
:
RescaleMode
rescaleMode
SkImage
:
:
ReadPixelsCallback
callback
SkImage
:
:
ReadPixelsContext
context
)
;
void
asyncReadPixels
(
const
TextureProxy
*
textureProxy
const
SkImageInfo
&
srcImageInfo
const
SkColorInfo
&
dstColorInfo
const
SkIRect
&
srcRect
SkImage
:
:
ReadPixelsCallback
callback
SkImage
:
:
ReadPixelsContext
context
)
;
void
asyncReadPixelsYUV420
(
Recorder
*
const
SkImage
*
SkYUVColorSpace
yuvColorSpace
bool
readAlpha
const
SkIRect
&
srcRect
SkImage
:
:
ReadPixelsCallback
callback
SkImage
:
:
ReadPixelsContext
context
)
;
void
finalizeAsyncReadPixels
(
SkSpan
<
PixelTransferResult
>
SkImage
:
:
ReadPixelsCallback
callback
SkImage
:
:
ReadPixelsContext
callbackContext
)
;
PixelTransferResult
transferPixels
(
const
TextureProxy
*
const
SkImageInfo
&
srcImageInfo
const
SkColorInfo
&
dstColorInfo
const
SkIRect
&
srcRect
)
;
sk_sp
<
SharedContext
>
fSharedContext
;
std
:
:
unique_ptr
<
ResourceProvider
>
fResourceProvider
;
std
:
:
unique_ptr
<
QueueManager
>
fQueueManager
;
std
:
:
unique_ptr
<
ClientMappedBufferManager
>
fMappedBufferManager
;
mutable
SingleOwner
fSingleOwner
;
#
if
defined
(
GRAPHITE_TEST_UTILS
)
bool
fStoreContextRefInRecorder
=
false
;
std
:
:
vector
<
Recorder
*
>
fTrackedRecorders
;
#
endif
const
ContextID
fContextID
;
}
;
}
#
endif
