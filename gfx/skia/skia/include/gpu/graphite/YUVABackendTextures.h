#
ifndef
skgpu_graphite_YUVABackendTextures_DEFINED
#
define
skgpu_graphite_YUVABackendTextures_DEFINED
#
include
"
include
/
core
/
SkSpan
.
h
"
#
include
"
include
/
core
/
SkYUVAInfo
.
h
"
#
include
"
include
/
gpu
/
graphite
/
BackendTexture
.
h
"
#
include
<
tuple
>
namespace
skgpu
:
:
graphite
{
class
Recorder
;
class
SK_API
YUVABackendTextureInfo
{
public
:
static
constexpr
auto
kMaxPlanes
=
SkYUVAInfo
:
:
kMaxPlanes
;
YUVABackendTextureInfo
(
)
=
default
;
YUVABackendTextureInfo
(
const
YUVABackendTextureInfo
&
)
=
default
;
YUVABackendTextureInfo
&
operator
=
(
const
YUVABackendTextureInfo
&
)
=
default
;
YUVABackendTextureInfo
(
const
SkYUVAInfo
&
SkSpan
<
const
TextureInfo
>
Mipmapped
)
;
YUVABackendTextureInfo
(
Recorder
*
const
SkYUVAInfo
&
yuvaInfo
SkSpan
<
const
TextureInfo
>
textures
Mipmapped
mipmapped
)
:
YUVABackendTextureInfo
(
yuvaInfo
textures
mipmapped
)
{
}
bool
operator
=
=
(
const
YUVABackendTextureInfo
&
)
const
;
bool
operator
!
=
(
const
YUVABackendTextureInfo
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
const
TextureInfo
&
planeTextureInfo
(
int
i
)
const
{
SkASSERT
(
i
>
=
0
)
;
return
fPlaneTextureInfos
[
static_cast
<
size_t
>
(
i
)
]
;
}
const
SkYUVAInfo
&
yuvaInfo
(
)
const
{
return
fYUVAInfo
;
}
SkYUVColorSpace
yuvColorSpace
(
)
const
{
return
fYUVAInfo
.
yuvColorSpace
(
)
;
}
Mipmapped
mipmapped
(
)
const
{
return
fMipmapped
;
}
int
numPlanes
(
)
const
{
return
fYUVAInfo
.
numPlanes
(
)
;
}
bool
isValid
(
)
const
{
return
fYUVAInfo
.
isValid
(
)
;
}
SkYUVAInfo
:
:
YUVALocations
toYUVALocations
(
)
const
;
private
:
SkYUVAInfo
fYUVAInfo
;
std
:
:
array
<
TextureInfo
kMaxPlanes
>
fPlaneTextureInfos
;
std
:
:
array
<
uint32_t
kMaxPlanes
>
fPlaneChannelMasks
;
Mipmapped
fMipmapped
=
Mipmapped
:
:
kNo
;
}
;
class
SK_API
YUVABackendTextures
{
public
:
static
constexpr
auto
kMaxPlanes
=
SkYUVAInfo
:
:
kMaxPlanes
;
YUVABackendTextures
(
)
=
default
;
YUVABackendTextures
(
const
YUVABackendTextures
&
)
=
delete
;
YUVABackendTextures
&
operator
=
(
const
YUVABackendTextures
&
)
=
delete
;
YUVABackendTextures
(
const
SkYUVAInfo
&
SkSpan
<
const
BackendTexture
>
)
;
YUVABackendTextures
(
Recorder
*
const
SkYUVAInfo
&
yuvaInfo
SkSpan
<
const
BackendTexture
>
textures
)
:
YUVABackendTextures
(
yuvaInfo
textures
)
{
}
SkSpan
<
const
BackendTexture
>
planeTextures
(
)
const
{
return
SkSpan
<
const
BackendTexture
>
(
fPlaneTextures
)
;
}
BackendTexture
planeTexture
(
int
i
)
const
{
SkASSERT
(
i
>
=
0
)
;
return
fPlaneTextures
[
static_cast
<
size_t
>
(
i
)
]
;
}
const
SkYUVAInfo
&
yuvaInfo
(
)
const
{
return
fYUVAInfo
;
}
SkYUVColorSpace
yuvColorSpace
(
)
const
{
return
fYUVAInfo
.
yuvColorSpace
(
)
;
}
int
numPlanes
(
)
const
{
return
fYUVAInfo
.
numPlanes
(
)
;
}
bool
isValid
(
)
const
{
return
fYUVAInfo
.
isValid
(
)
;
}
SkYUVAInfo
:
:
YUVALocations
toYUVALocations
(
)
const
;
private
:
SkYUVAInfo
fYUVAInfo
;
std
:
:
array
<
BackendTexture
kMaxPlanes
>
fPlaneTextures
;
std
:
:
array
<
uint32_t
kMaxPlanes
>
fPlaneChannelMasks
;
}
;
}
#
endif
