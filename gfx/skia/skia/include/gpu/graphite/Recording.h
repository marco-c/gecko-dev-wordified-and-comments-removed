#
ifndef
skgpu_graphite_Recording_DEFINED
#
define
skgpu_graphite_Recording_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
private
/
SkChecksum
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
<
memory
>
#
include
<
unordered_set
>
#
include
<
vector
>
namespace
skgpu
{
class
RefCntedCallback
;
}
namespace
skgpu
:
:
graphite
{
class
CommandBuffer
;
class
RecordingPriv
;
class
Resource
;
class
ResourceProvider
;
class
TaskGraph
;
class
Texture
;
class
TextureInfo
;
class
TextureProxy
;
class
Recording
final
{
public
:
~
Recording
(
)
;
RecordingPriv
priv
(
)
;
#
if
GRAPHITE_TEST_UTILS
bool
isTargetProxyInstantiated
(
)
const
;
#
endif
private
:
friend
class
Recorder
;
friend
class
RecordingPriv
;
class
LazyProxyData
{
public
:
LazyProxyData
(
const
TextureInfo
&
)
;
TextureProxy
*
lazyProxy
(
)
;
sk_sp
<
TextureProxy
>
refLazyProxy
(
)
;
bool
lazyInstantiate
(
ResourceProvider
*
sk_sp
<
Texture
>
)
;
private
:
sk_sp
<
Texture
>
fTarget
;
sk_sp
<
TextureProxy
>
fTargetProxy
;
}
;
struct
ProxyHash
{
std
:
:
size_t
operator
(
)
(
const
sk_sp
<
TextureProxy
>
&
proxy
)
const
{
return
SkGoodHash
(
)
(
proxy
.
get
(
)
)
;
}
}
;
Recording
(
std
:
:
unique_ptr
<
TaskGraph
>
std
:
:
unordered_set
<
sk_sp
<
TextureProxy
>
ProxyHash
>
&
&
nonVolatileLazyProxies
std
:
:
unordered_set
<
sk_sp
<
TextureProxy
>
ProxyHash
>
&
&
volatileLazyProxies
std
:
:
unique_ptr
<
LazyProxyData
>
targetProxyData
SkTArray
<
sk_sp
<
RefCntedCallback
>
>
&
&
finishedProcs
)
;
bool
addCommands
(
CommandBuffer
*
ResourceProvider
*
)
;
void
addResourceRef
(
sk_sp
<
Resource
>
)
;
std
:
:
unique_ptr
<
TaskGraph
>
fGraph
;
std
:
:
vector
<
sk_sp
<
Resource
>
>
fExtraResourceRefs
;
std
:
:
unordered_set
<
sk_sp
<
TextureProxy
>
ProxyHash
>
fNonVolatileLazyProxies
;
std
:
:
unordered_set
<
sk_sp
<
TextureProxy
>
ProxyHash
>
fVolatileLazyProxies
;
std
:
:
unique_ptr
<
LazyProxyData
>
fTargetProxyData
;
SkTArray
<
sk_sp
<
RefCntedCallback
>
>
fFinishedProcs
;
}
;
}
#
endif
