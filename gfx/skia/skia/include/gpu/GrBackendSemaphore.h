#
ifndef
GrBackendSemaphore_DEFINED
#
define
GrBackendSemaphore_DEFINED
#
include
"
include
/
gpu
/
GrTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkAPI
.
h
"
#
include
"
include
/
private
/
base
/
SkAnySubclass
.
h
"
#
ifdef
SK_DIRECT3D
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrD3DTypesMinimal
.
h
"
#
endif
#
include
<
cstddef
>
class
GrBackendSemaphoreData
;
class
SK_API
GrBackendSemaphore
{
public
:
GrBackendSemaphore
(
)
;
~
GrBackendSemaphore
(
)
;
GrBackendSemaphore
(
const
GrBackendSemaphore
&
)
;
GrBackendSemaphore
&
operator
=
(
const
GrBackendSemaphore
&
)
;
#
ifdef
SK_DIRECT3D
void
initDirect3D
(
const
GrD3DFenceInfo
&
info
)
{
fBackend
=
GrBackendApi
:
:
kDirect3D
;
this
-
>
assignD3DFenceInfo
(
info
)
;
fIsInitialized
=
true
;
}
#
endif
bool
isInitialized
(
)
const
{
return
fIsInitialized
;
}
GrBackendApi
backend
(
)
const
{
return
fBackend
;
}
#
ifdef
SK_DIRECT3D
bool
getD3DFenceInfo
(
GrD3DFenceInfo
*
outInfo
)
const
;
#
endif
private
:
friend
class
GrBackendSemaphorePriv
;
friend
class
GrBackendSemaphoreData
;
inline
constexpr
static
size_t
kMaxSubclassSize
=
24
;
using
AnySemaphoreData
=
SkAnySubclass
<
GrBackendSemaphoreData
kMaxSubclassSize
>
;
template
<
typename
SemaphoreData
>
GrBackendSemaphore
(
GrBackendApi
api
SemaphoreData
data
)
:
fBackend
(
api
)
fIsInitialized
(
true
)
{
fSemaphoreData
.
emplace
<
SemaphoreData
>
(
data
)
;
}
#
ifdef
SK_DIRECT3D
void
assignD3DFenceInfo
(
const
GrD3DFenceInfo
&
info
)
;
#
endif
GrBackendApi
fBackend
;
AnySemaphoreData
fSemaphoreData
;
union
{
void
*
fPlaceholder
;
#
ifdef
SK_DIRECT3D
GrD3DFenceInfo
*
fD3DFenceInfo
;
#
endif
}
;
bool
fIsInitialized
;
}
;
#
endif
