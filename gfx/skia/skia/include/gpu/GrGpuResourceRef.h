#
ifndef
GrGpuResourceRef_DEFINED
#
define
GrGpuResourceRef_DEFINED
#
include
"
GrGpuResource
.
h
"
#
include
"
GrRenderTarget
.
h
"
#
include
"
GrTexture
.
h
"
#
include
"
SkRefCnt
.
h
"
class
GrGpuResourceRef
:
SkNoncopyable
{
public
:
~
GrGpuResourceRef
(
)
;
GrGpuResource
*
getResource
(
)
const
{
return
fResource
;
}
bool
ownsPendingIO
(
)
const
{
return
fPendingIO
;
}
void
reset
(
)
;
protected
:
GrGpuResourceRef
(
)
;
GrGpuResourceRef
(
GrGpuResource
*
GrIOType
)
;
void
setResource
(
GrGpuResource
*
GrIOType
)
;
private
:
void
markPendingIO
(
)
const
;
void
removeRef
(
)
const
;
void
pendingIOComplete
(
)
const
;
friend
class
GrProgramElement
;
GrGpuResource
*
fResource
;
mutable
bool
fOwnRef
;
mutable
bool
fPendingIO
;
GrIOType
fIOType
;
typedef
SkNoncopyable
INHERITED
;
}
;
template
<
typename
T
>
class
GrTGpuResourceRef
:
public
GrGpuResourceRef
{
public
:
GrTGpuResourceRef
(
)
{
}
GrTGpuResourceRef
(
T
*
resource
GrIOType
ioType
)
:
INHERITED
(
resource
ioType
)
{
}
T
*
get
(
)
const
{
return
static_cast
<
T
*
>
(
this
-
>
getResource
(
)
)
;
}
void
set
(
T
*
resource
GrIOType
ioType
)
{
this
-
>
setResource
(
resource
ioType
)
;
}
private
:
typedef
GrGpuResourceRef
INHERITED
;
}
;
template
<
>
class
GrTGpuResourceRef
<
GrTexture
>
:
public
GrGpuResourceRef
{
public
:
GrTGpuResourceRef
(
)
{
}
GrTGpuResourceRef
(
GrTexture
*
texture
GrIOType
ioType
)
:
INHERITED
(
texture
ioType
)
{
}
GrTexture
*
get
(
)
const
{
GrSurface
*
surface
=
static_cast
<
GrSurface
*
>
(
this
-
>
getResource
(
)
)
;
if
(
surface
)
{
return
surface
-
>
asTexture
(
)
;
}
else
{
return
NULL
;
}
}
void
set
(
GrTexture
*
texture
GrIOType
ioType
)
{
this
-
>
setResource
(
texture
ioType
)
;
}
private
:
typedef
GrGpuResourceRef
INHERITED
;
}
;
template
<
>
class
GrTGpuResourceRef
<
GrRenderTarget
>
:
public
GrGpuResourceRef
{
public
:
GrTGpuResourceRef
(
)
{
}
GrTGpuResourceRef
(
GrRenderTarget
*
rt
GrIOType
ioType
)
:
INHERITED
(
rt
ioType
)
{
}
GrRenderTarget
*
get
(
)
const
{
GrSurface
*
surface
=
static_cast
<
GrSurface
*
>
(
this
-
>
getResource
(
)
)
;
if
(
surface
)
{
return
surface
-
>
asRenderTarget
(
)
;
}
else
{
return
NULL
;
}
}
void
set
(
GrRenderTarget
*
rt
GrIOType
ioType
)
{
this
-
>
setResource
(
rt
ioType
)
;
}
private
:
typedef
GrGpuResourceRef
INHERITED
;
}
;
template
<
typename
T
GrIOType
IO_TYPE
>
class
GrPendingIOResource
:
SkNoncopyable
{
public
:
GrPendingIOResource
(
T
*
resource
=
NULL
)
:
fResource
(
NULL
)
{
this
-
>
reset
(
resource
)
;
}
void
reset
(
T
*
resource
)
{
if
(
resource
)
{
switch
(
IO_TYPE
)
{
case
kRead_GrIOType
:
resource
-
>
addPendingRead
(
)
;
break
;
case
kWrite_GrIOType
:
resource
-
>
addPendingWrite
(
)
;
break
;
case
kRW_GrIOType
:
resource
-
>
addPendingRead
(
)
;
resource
-
>
addPendingWrite
(
)
;
break
;
}
}
this
-
>
release
(
)
;
fResource
=
resource
;
}
~
GrPendingIOResource
(
)
{
this
-
>
release
(
)
;
}
explicit
operator
bool
(
)
const
{
return
SkToBool
(
fResource
)
;
}
bool
operator
=
=
(
const
GrPendingIOResource
&
other
)
const
{
return
fResource
=
=
other
.
fResource
;
}
T
*
get
(
)
const
{
return
fResource
;
}
private
:
void
release
(
)
{
if
(
fResource
)
{
switch
(
IO_TYPE
)
{
case
kRead_GrIOType
:
fResource
-
>
completedRead
(
)
;
break
;
case
kWrite_GrIOType
:
fResource
-
>
completedWrite
(
)
;
break
;
case
kRW_GrIOType
:
fResource
-
>
completedRead
(
)
;
fResource
-
>
completedWrite
(
)
;
break
;
}
}
}
T
*
fResource
;
}
;
#
endif
