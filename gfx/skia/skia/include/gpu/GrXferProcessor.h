#
ifndef
GrXferProcessor_DEFINED
#
define
GrXferProcessor_DEFINED
#
include
"
GrBlend
.
h
"
#
include
"
GrColor
.
h
"
#
include
"
GrProcessor
.
h
"
#
include
"
GrTexture
.
h
"
#
include
"
GrTypes
.
h
"
#
include
"
SkXfermode
.
h
"
class
GrShaderCaps
;
class
GrGLSLCaps
;
class
GrGLSLXferProcessor
;
class
GrProcOptInfo
;
struct
GrPipelineOptimizations
;
enum
GrXferBarrierType
{
kNone_GrXferBarrierType
=
0
kTexture_GrXferBarrierType
kBlend_GrXferBarrierType
}
;
GR_STATIC_ASSERT
(
SkToBool
(
kNone_GrXferBarrierType
)
=
=
false
)
;
class
GrXferProcessor
:
public
GrProcessor
{
public
:
class
DstTexture
{
public
:
DstTexture
(
)
{
fOffset
.
set
(
0
0
)
;
}
DstTexture
(
const
DstTexture
&
other
)
{
*
this
=
other
;
}
DstTexture
(
GrTexture
*
texture
const
SkIPoint
&
offset
)
:
fTexture
(
SkSafeRef
(
texture
)
)
fOffset
(
offset
)
{
}
DstTexture
&
operator
=
(
const
DstTexture
&
other
)
{
fTexture
.
reset
(
SkSafeRef
(
other
.
fTexture
.
get
(
)
)
)
;
fOffset
=
other
.
fOffset
;
return
*
this
;
}
const
SkIPoint
&
offset
(
)
const
{
return
fOffset
;
}
void
setOffset
(
const
SkIPoint
&
offset
)
{
fOffset
=
offset
;
}
void
setOffset
(
int
ox
int
oy
)
{
fOffset
.
set
(
ox
oy
)
;
}
GrTexture
*
texture
(
)
const
{
return
fTexture
.
get
(
)
;
}
GrTexture
*
setTexture
(
GrTexture
*
texture
)
{
fTexture
.
reset
(
SkSafeRef
(
texture
)
)
;
return
texture
;
}
private
:
SkAutoTUnref
<
GrTexture
>
fTexture
;
SkIPoint
fOffset
;
}
;
void
getGLSLProcessorKey
(
const
GrGLSLCaps
&
caps
GrProcessorKeyBuilder
*
b
)
const
;
virtual
GrGLSLXferProcessor
*
createGLSLInstance
(
)
const
=
0
;
enum
OptFlags
{
kSkipDraw_OptFlag
=
0x1
kIgnoreColor_OptFlag
=
0x2
kIgnoreCoverage_OptFlag
=
0x4
kOverrideColor_OptFlag
=
0x8
kCanTweakAlphaForCoverage_OptFlag
=
0x20
}
;
static
const
OptFlags
kNone_OptFlags
=
(
OptFlags
)
0
;
GR_DECL_BITFIELD_OPS_FRIENDS
(
OptFlags
)
;
OptFlags
getOptimizations
(
const
GrPipelineOptimizations
&
optimizations
bool
doesStencilWrite
GrColor
*
overrideColor
const
GrCaps
&
caps
)
const
;
GrXferBarrierType
xferBarrierType
(
const
GrRenderTarget
*
rt
const
GrCaps
&
caps
)
const
;
struct
BlendInfo
{
void
reset
(
)
{
fEquation
=
kAdd_GrBlendEquation
;
fSrcBlend
=
kOne_GrBlendCoeff
;
fDstBlend
=
kZero_GrBlendCoeff
;
fBlendConstant
=
0
;
fWriteColor
=
true
;
}
SkDEBUGCODE
(
SkString
dump
(
)
const
;
)
GrBlendEquation
fEquation
;
GrBlendCoeff
fSrcBlend
;
GrBlendCoeff
fDstBlend
;
GrColor
fBlendConstant
;
bool
fWriteColor
;
}
;
void
getBlendInfo
(
BlendInfo
*
blendInfo
)
const
;
bool
willReadDstColor
(
)
const
{
return
fWillReadDstColor
;
}
const
GrTexture
*
getDstTexture
(
)
const
{
return
fDstTexture
.
getTexture
(
)
;
}
const
SkIPoint
&
dstTextureOffset
(
)
const
{
SkASSERT
(
this
-
>
getDstTexture
(
)
)
;
return
fDstTextureOffset
;
}
bool
dstReadUsesMixedSamples
(
)
const
{
return
fDstReadUsesMixedSamples
;
}
bool
hasSecondaryOutput
(
)
const
;
bool
isEqual
(
const
GrXferProcessor
&
that
)
const
{
if
(
this
-
>
classID
(
)
!
=
that
.
classID
(
)
)
{
return
false
;
}
if
(
this
-
>
fWillReadDstColor
!
=
that
.
fWillReadDstColor
)
{
return
false
;
}
if
(
this
-
>
fDstTexture
.
getTexture
(
)
!
=
that
.
fDstTexture
.
getTexture
(
)
)
{
return
false
;
}
if
(
this
-
>
fDstTextureOffset
!
=
that
.
fDstTextureOffset
)
{
return
false
;
}
if
(
this
-
>
fDstReadUsesMixedSamples
!
=
that
.
fDstReadUsesMixedSamples
)
{
return
false
;
}
return
this
-
>
onIsEqual
(
that
)
;
}
protected
:
GrXferProcessor
(
)
;
GrXferProcessor
(
const
DstTexture
*
bool
willReadDstColor
bool
hasMixedSamples
)
;
private
:
void
notifyRefCntIsZero
(
)
const
final
{
}
virtual
OptFlags
onGetOptimizations
(
const
GrPipelineOptimizations
&
optimizations
bool
doesStencilWrite
GrColor
*
overrideColor
const
GrCaps
&
caps
)
const
=
0
;
virtual
void
onGetGLSLProcessorKey
(
const
GrGLSLCaps
&
caps
GrProcessorKeyBuilder
*
b
)
const
=
0
;
virtual
GrXferBarrierType
onXferBarrier
(
const
GrRenderTarget
*
const
GrCaps
&
)
const
{
return
kNone_GrXferBarrierType
;
}
virtual
bool
onHasSecondaryOutput
(
)
const
{
return
false
;
}
virtual
void
onGetBlendInfo
(
BlendInfo
*
)
const
{
}
virtual
bool
onIsEqual
(
const
GrXferProcessor
&
)
const
=
0
;
bool
fWillReadDstColor
;
bool
fDstReadUsesMixedSamples
;
SkIPoint
fDstTextureOffset
;
GrTextureAccess
fDstTexture
;
typedef
GrFragmentProcessor
INHERITED
;
}
;
GR_MAKE_BITFIELD_OPS
(
GrXferProcessor
:
:
OptFlags
)
;
class
GrXPFactory
:
public
SkRefCnt
{
public
:
typedef
GrXferProcessor
:
:
DstTexture
DstTexture
;
GrXferProcessor
*
createXferProcessor
(
const
GrPipelineOptimizations
&
optimizations
bool
hasMixedSamples
const
DstTexture
*
const
GrCaps
&
caps
)
const
;
struct
InvariantBlendedColor
{
bool
fWillBlendWithDst
;
GrColor
fKnownColor
;
GrColorComponentFlags
fKnownColorFlags
;
}
;
virtual
void
getInvariantBlendedColor
(
const
GrProcOptInfo
&
colorPOI
InvariantBlendedColor
*
)
const
=
0
;
bool
willNeedDstTexture
(
const
GrCaps
&
caps
const
GrPipelineOptimizations
&
optimizations
)
const
;
bool
isEqual
(
const
GrXPFactory
&
that
)
const
{
if
(
this
-
>
classID
(
)
!
=
that
.
classID
(
)
)
{
return
false
;
}
return
this
-
>
onIsEqual
(
that
)
;
}
template
<
typename
T
>
const
T
&
cast
(
)
const
{
return
*
static_cast
<
const
T
*
>
(
this
)
;
}
uint32_t
classID
(
)
const
{
SkASSERT
(
kIllegalXPFClassID
!
=
fClassID
)
;
return
fClassID
;
}
protected
:
GrXPFactory
(
)
:
fClassID
(
kIllegalXPFClassID
)
{
}
template
<
typename
XPF_SUBCLASS
>
void
initClassID
(
)
{
static
uint32_t
kClassID
=
GenClassID
(
)
;
fClassID
=
kClassID
;
}
uint32_t
fClassID
;
private
:
virtual
GrXferProcessor
*
onCreateXferProcessor
(
const
GrCaps
&
caps
const
GrPipelineOptimizations
&
optimizations
bool
hasMixedSamples
const
DstTexture
*
)
const
=
0
;
virtual
bool
onIsEqual
(
const
GrXPFactory
&
)
const
=
0
;
bool
willReadDstColor
(
const
GrCaps
&
const
GrPipelineOptimizations
&
)
const
;
virtual
bool
onWillReadDstColor
(
const
GrCaps
&
const
GrPipelineOptimizations
&
)
const
=
0
;
static
uint32_t
GenClassID
(
)
{
uint32_t
id
=
static_cast
<
uint32_t
>
(
sk_atomic_inc
(
&
gCurrXPFClassID
)
)
+
1
;
if
(
!
id
)
{
SkFAIL
(
"
This
should
never
wrap
as
it
should
only
be
called
once
for
each
GrXPFactory
"
"
subclass
.
"
)
;
}
return
id
;
}
enum
{
kIllegalXPFClassID
=
0
}
;
static
int32_t
gCurrXPFClassID
;
typedef
GrProgramElement
INHERITED
;
}
;
#
endif
