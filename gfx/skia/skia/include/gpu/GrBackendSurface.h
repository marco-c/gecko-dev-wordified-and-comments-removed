#
ifndef
GrBackendSurface_DEFINED
#
define
GrBackendSurface_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkSize
.
h
"
#
include
"
include
/
gpu
/
GpuTypes
.
h
"
#
include
"
include
/
gpu
/
GrTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkAPI
.
h
"
#
include
"
include
/
private
/
base
/
SkAnySubclass
.
h
"
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrTypesPriv
.
h
"
#
include
"
include
/
gpu
/
mock
/
GrMockTypes
.
h
"
enum
class
SkTextureCompressionType
;
class
GrBackendFormatData
;
class
GrBackendTextureData
;
class
GrBackendRenderTargetData
;
namespace
skgpu
{
class
MutableTextureState
;
}
#
ifdef
SK_DIRECT3D
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrD3DTypesMinimal
.
h
"
class
GrD3DResourceState
;
#
endif
#
if
defined
(
SK_DEBUG
)
|
|
defined
(
GR_TEST_UTILS
)
class
SkString
;
#
endif
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
string
>
#
include
<
string_view
>
class
SK_API
GrBackendFormat
{
public
:
GrBackendFormat
(
)
;
GrBackendFormat
(
const
GrBackendFormat
&
)
;
GrBackendFormat
&
operator
=
(
const
GrBackendFormat
&
)
;
~
GrBackendFormat
(
)
;
#
ifdef
SK_DIRECT3D
static
GrBackendFormat
MakeDxgi
(
DXGI_FORMAT
format
)
{
return
GrBackendFormat
(
format
)
;
}
#
endif
static
GrBackendFormat
MakeMock
(
GrColorType
colorType
SkTextureCompressionType
compression
bool
isStencilFormat
=
false
)
;
bool
operator
=
=
(
const
GrBackendFormat
&
that
)
const
;
bool
operator
!
=
(
const
GrBackendFormat
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
GrBackendApi
backend
(
)
const
{
return
fBackend
;
}
GrTextureType
textureType
(
)
const
{
return
fTextureType
;
}
uint32_t
channelMask
(
)
const
;
GrColorFormatDesc
desc
(
)
const
;
#
ifdef
SK_DIRECT3D
bool
asDxgiFormat
(
DXGI_FORMAT
*
)
const
;
#
endif
GrColorType
asMockColorType
(
)
const
;
SkTextureCompressionType
asMockCompressionType
(
)
const
;
bool
isMockStencilFormat
(
)
const
;
GrBackendFormat
makeTexture2D
(
)
const
;
bool
isValid
(
)
const
{
return
fValid
;
}
#
if
defined
(
SK_DEBUG
)
|
|
defined
(
GR_TEST_UTILS
)
SkString
toStr
(
)
const
;
#
endif
private
:
inline
constexpr
static
size_t
kMaxSubclassSize
=
80
;
using
AnyFormatData
=
SkAnySubclass
<
GrBackendFormatData
kMaxSubclassSize
>
;
friend
class
GrBackendSurfacePriv
;
friend
class
GrBackendFormatData
;
template
<
typename
FormatData
>
GrBackendFormat
(
GrTextureType
textureType
GrBackendApi
api
const
FormatData
&
formatData
)
:
fBackend
(
api
)
fValid
(
true
)
fTextureType
(
textureType
)
{
fFormatData
.
emplace
<
FormatData
>
(
formatData
)
;
}
#
ifdef
SK_DIRECT3D
GrBackendFormat
(
DXGI_FORMAT
dxgiFormat
)
;
#
endif
GrBackendFormat
(
GrColorType
SkTextureCompressionType
bool
isStencilFormat
)
;
#
ifdef
SK_DEBUG
bool
validateMock
(
)
const
;
#
endif
GrBackendApi
fBackend
=
GrBackendApi
:
:
kMock
;
bool
fValid
=
false
;
AnyFormatData
fFormatData
;
union
{
#
ifdef
SK_DIRECT3D
DXGI_FORMAT
fDxgiFormat
;
#
endif
struct
{
GrColorType
fColorType
;
SkTextureCompressionType
fCompressionType
;
bool
fIsStencilFormat
;
}
fMock
;
}
;
GrTextureType
fTextureType
=
GrTextureType
:
:
kNone
;
}
;
class
SK_API
GrBackendTexture
{
public
:
GrBackendTexture
(
)
;
#
ifdef
SK_DIRECT3D
GrBackendTexture
(
int
width
int
height
const
GrD3DTextureResourceInfo
&
d3dInfo
std
:
:
string_view
label
=
{
}
)
;
#
endif
GrBackendTexture
(
int
width
int
height
skgpu
:
:
Mipmapped
const
GrMockTextureInfo
&
mockInfo
std
:
:
string_view
label
=
{
}
)
;
GrBackendTexture
(
const
GrBackendTexture
&
that
)
;
~
GrBackendTexture
(
)
;
GrBackendTexture
&
operator
=
(
const
GrBackendTexture
&
that
)
;
SkISize
dimensions
(
)
const
{
return
{
fWidth
fHeight
}
;
}
int
width
(
)
const
{
return
fWidth
;
}
int
height
(
)
const
{
return
fHeight
;
}
std
:
:
string_view
getLabel
(
)
const
{
return
fLabel
;
}
skgpu
:
:
Mipmapped
mipmapped
(
)
const
{
return
fMipmapped
;
}
bool
hasMipmaps
(
)
const
{
return
fMipmapped
=
=
skgpu
:
:
Mipmapped
:
:
kYes
;
}
GrBackendApi
backend
(
)
const
{
return
fBackend
;
}
GrTextureType
textureType
(
)
const
{
return
fTextureType
;
}
#
ifdef
SK_DIRECT3D
bool
getD3DTextureResourceInfo
(
GrD3DTextureResourceInfo
*
)
const
;
void
setD3DResourceState
(
GrD3DResourceStateEnum
)
;
#
endif
GrBackendFormat
getBackendFormat
(
)
const
;
bool
getMockTextureInfo
(
GrMockTextureInfo
*
)
const
;
void
setMutableState
(
const
skgpu
:
:
MutableTextureState
&
)
;
bool
isProtected
(
)
const
;
bool
isValid
(
)
const
{
return
fIsValid
;
}
bool
isSameTexture
(
const
GrBackendTexture
&
)
;
#
if
defined
(
GR_TEST_UTILS
)
static
bool
TestingOnly_Equals
(
const
GrBackendTexture
&
const
GrBackendTexture
&
)
;
#
endif
private
:
inline
constexpr
static
size_t
kMaxSubclassSize
=
176
;
using
AnyTextureData
=
SkAnySubclass
<
GrBackendTextureData
kMaxSubclassSize
>
;
friend
class
GrBackendSurfacePriv
;
friend
class
GrBackendTextureData
;
template
<
typename
TextureData
>
GrBackendTexture
(
int
width
int
height
std
:
:
string_view
label
skgpu
:
:
Mipmapped
mipped
GrBackendApi
backend
GrTextureType
texture
const
TextureData
&
textureData
)
:
fIsValid
(
true
)
fWidth
(
width
)
fHeight
(
height
)
fLabel
(
label
)
fMipmapped
(
mipped
)
fBackend
(
backend
)
fTextureType
(
texture
)
{
fTextureData
.
emplace
<
TextureData
>
(
textureData
)
;
}
friend
class
GrVkGpu
;
sk_sp
<
skgpu
:
:
MutableTextureState
>
getMutableState
(
)
const
;
#
ifdef
SK_DIRECT3D
friend
class
GrD3DTexture
;
friend
class
GrD3DGpu
;
GrBackendTexture
(
int
width
int
height
const
GrD3DTextureResourceInfo
&
vkInfo
sk_sp
<
GrD3DResourceState
>
state
std
:
:
string_view
label
=
{
}
)
;
sk_sp
<
GrD3DResourceState
>
getGrD3DResourceState
(
)
const
;
#
endif
void
cleanup
(
)
;
bool
fIsValid
;
int
fWidth
;
int
fHeight
;
const
std
:
:
string
fLabel
;
skgpu
:
:
Mipmapped
fMipmapped
;
GrBackendApi
fBackend
;
GrTextureType
fTextureType
;
AnyTextureData
fTextureData
;
union
{
GrMockTextureInfo
fMockInfo
;
#
ifdef
SK_DIRECT3D
GrD3DBackendSurfaceInfo
fD3DInfo
;
#
endif
}
;
}
;
class
SK_API
GrBackendRenderTarget
{
public
:
GrBackendRenderTarget
(
)
;
#
ifdef
SK_DIRECT3D
GrBackendRenderTarget
(
int
width
int
height
const
GrD3DTextureResourceInfo
&
d3dInfo
)
;
#
endif
GrBackendRenderTarget
(
int
width
int
height
int
sampleCnt
int
stencilBits
const
GrMockRenderTargetInfo
&
mockInfo
)
;
~
GrBackendRenderTarget
(
)
;
GrBackendRenderTarget
(
const
GrBackendRenderTarget
&
that
)
;
GrBackendRenderTarget
&
operator
=
(
const
GrBackendRenderTarget
&
)
;
SkISize
dimensions
(
)
const
{
return
{
fWidth
fHeight
}
;
}
int
width
(
)
const
{
return
fWidth
;
}
int
height
(
)
const
{
return
fHeight
;
}
int
sampleCnt
(
)
const
{
return
fSampleCnt
;
}
int
stencilBits
(
)
const
{
return
fStencilBits
;
}
GrBackendApi
backend
(
)
const
{
return
fBackend
;
}
bool
isFramebufferOnly
(
)
const
{
return
fFramebufferOnly
;
}
#
ifdef
SK_DIRECT3D
bool
getD3DTextureResourceInfo
(
GrD3DTextureResourceInfo
*
)
const
;
void
setD3DResourceState
(
GrD3DResourceStateEnum
)
;
#
endif
GrBackendFormat
getBackendFormat
(
)
const
;
bool
getMockRenderTargetInfo
(
GrMockRenderTargetInfo
*
)
const
;
void
setMutableState
(
const
skgpu
:
:
MutableTextureState
&
)
;
bool
isProtected
(
)
const
;
bool
isValid
(
)
const
{
return
fIsValid
;
}
#
if
defined
(
GR_TEST_UTILS
)
static
bool
TestingOnly_Equals
(
const
GrBackendRenderTarget
&
const
GrBackendRenderTarget
&
)
;
#
endif
private
:
inline
constexpr
static
size_t
kMaxSubclassSize
=
176
;
using
AnyRenderTargetData
=
SkAnySubclass
<
GrBackendRenderTargetData
kMaxSubclassSize
>
;
friend
class
GrBackendSurfacePriv
;
friend
class
GrBackendRenderTargetData
;
template
<
typename
RenderTargetData
>
GrBackendRenderTarget
(
int
width
int
height
int
sampleCnt
int
stencilBits
GrBackendApi
backend
bool
framebufferOnly
const
RenderTargetData
&
rtData
)
:
fIsValid
(
true
)
fFramebufferOnly
(
framebufferOnly
)
fWidth
(
width
)
fHeight
(
height
)
fSampleCnt
(
sampleCnt
)
fStencilBits
(
stencilBits
)
fBackend
(
backend
)
{
fRTData
.
emplace
<
RenderTargetData
>
(
rtData
)
;
}
friend
class
GrVkGpu
;
sk_sp
<
skgpu
:
:
MutableTextureState
>
getMutableState
(
)
const
;
#
ifdef
SK_DIRECT3D
friend
class
GrD3DGpu
;
friend
class
GrD3DRenderTarget
;
GrBackendRenderTarget
(
int
width
int
height
const
GrD3DTextureResourceInfo
&
d3dInfo
sk_sp
<
GrD3DResourceState
>
state
)
;
sk_sp
<
GrD3DResourceState
>
getGrD3DResourceState
(
)
const
;
#
endif
void
cleanup
(
)
;
bool
fIsValid
;
bool
fFramebufferOnly
=
false
;
int
fWidth
;
int
fHeight
;
int
fSampleCnt
;
int
fStencilBits
;
GrBackendApi
fBackend
;
AnyRenderTargetData
fRTData
;
union
{
GrMockRenderTargetInfo
fMockInfo
;
#
ifdef
SK_DIRECT3D
GrD3DBackendSurfaceInfo
fD3DInfo
;
#
endif
}
;
}
;
#
endif
