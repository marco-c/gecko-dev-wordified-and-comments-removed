#
ifndef
GrTexture_DEFINED
#
define
GrTexture_DEFINED
#
include
"
GrBackendSurface
.
h
"
#
include
"
GrSamplerState
.
h
"
#
include
"
GrSurface
.
h
"
#
include
"
SkImage
.
h
"
#
include
"
SkPoint
.
h
"
#
include
"
SkRefCnt
.
h
"
#
include
"
.
.
/
private
/
GrTypesPriv
.
h
"
class
GrTexturePriv
;
class
SK_API
GrTexture
:
virtual
public
GrSurface
{
public
:
GrTexture
*
asTexture
(
)
override
{
return
this
;
}
const
GrTexture
*
asTexture
(
)
const
override
{
return
this
;
}
virtual
GrBackendTexture
getBackendTexture
(
)
const
=
0
;
virtual
void
textureParamsModified
(
)
=
0
;
static
bool
StealBackendTexture
(
sk_sp
<
GrTexture
>
GrBackendTexture
*
SkImage
:
:
BackendTextureReleaseProc
*
)
;
#
ifdef
SK_DEBUG
void
validate
(
)
const
{
this
-
>
INHERITED
:
:
validate
(
)
;
}
#
endif
enum
class
IdleState
{
kFlushed
kFinished
}
;
virtual
void
addIdleProc
(
sk_sp
<
GrRefCntedCallback
>
idleProc
IdleState
)
{
fIdleProcs
.
push_back
(
std
:
:
move
(
idleProc
)
)
;
}
void
addIdleProc
(
GrRefCntedCallback
:
:
Callback
callback
GrRefCntedCallback
:
:
Context
context
IdleState
state
)
{
this
-
>
addIdleProc
(
sk_make_sp
<
GrRefCntedCallback
>
(
callback
context
)
state
)
;
}
inline
GrTexturePriv
texturePriv
(
)
;
inline
const
GrTexturePriv
texturePriv
(
)
const
;
protected
:
GrTexture
(
GrGpu
*
const
GrSurfaceDesc
&
GrTextureType
GrMipMapsStatus
)
;
virtual
bool
onStealBackendTexture
(
GrBackendTexture
*
SkImage
:
:
BackendTextureReleaseProc
*
)
=
0
;
SkTArray
<
sk_sp
<
GrRefCntedCallback
>
>
fIdleProcs
;
void
willRemoveLastRefOrPendingIO
(
)
override
{
fIdleProcs
.
reset
(
)
;
}
private
:
void
computeScratchKey
(
GrScratchKey
*
)
const
override
;
size_t
onGpuMemorySize
(
)
const
override
;
void
markMipMapsDirty
(
)
;
void
markMipMapsClean
(
)
;
GrTextureType
fTextureType
;
GrMipMapsStatus
fMipMapsStatus
;
int
fMaxMipMapLevel
;
friend
class
GrTexturePriv
;
typedef
GrSurface
INHERITED
;
}
;
#
endif
