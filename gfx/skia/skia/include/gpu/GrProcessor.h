#
ifndef
GrProcessor_DEFINED
#
define
GrProcessor_DEFINED
#
include
"
GrColor
.
h
"
#
include
"
GrProcessorUnitTest
.
h
"
#
include
"
GrProgramElement
.
h
"
#
include
"
GrTextureAccess
.
h
"
#
include
"
GrBufferAccess
.
h
"
#
include
"
SkMath
.
h
"
#
include
"
SkString
.
h
"
#
include
"
.
.
/
private
/
SkAtomics
.
h
"
class
GrContext
;
class
GrCoordTransform
;
class
GrInvariantOutput
;
class
GrProcessorKeyBuilder
{
public
:
GrProcessorKeyBuilder
(
SkTArray
<
unsigned
char
true
>
*
data
)
:
fData
(
data
)
fCount
(
0
)
{
SkASSERT
(
0
=
=
fData
-
>
count
(
)
%
sizeof
(
uint32_t
)
)
;
}
void
add32
(
uint32_t
v
)
{
+
+
fCount
;
fData
-
>
push_back_n
(
4
reinterpret_cast
<
uint8_t
*
>
(
&
v
)
)
;
}
uint32_t
*
SK_WARN_UNUSED_RESULT
add32n
(
int
count
)
{
SkASSERT
(
count
>
0
)
;
fCount
+
=
count
;
return
reinterpret_cast
<
uint32_t
*
>
(
fData
-
>
push_back_n
(
4
*
count
)
)
;
}
size_t
size
(
)
const
{
return
sizeof
(
uint32_t
)
*
fCount
;
}
private
:
SkTArray
<
uint8_t
true
>
*
fData
;
int
fCount
;
}
;
class
GrProcessor
:
public
GrProgramElement
{
public
:
virtual
~
GrProcessor
(
)
;
virtual
const
char
*
name
(
)
const
=
0
;
virtual
SkString
dumpInfo
(
)
const
{
SkString
str
;
str
.
appendf
(
"
Missing
data
"
)
;
return
str
;
}
int
numTextures
(
)
const
{
return
fTextureAccesses
.
count
(
)
;
}
const
GrTextureAccess
&
textureAccess
(
int
index
)
const
{
return
*
fTextureAccesses
[
index
]
;
}
GrTexture
*
texture
(
int
index
)
const
{
return
this
-
>
textureAccess
(
index
)
.
getTexture
(
)
;
}
int
numBuffers
(
)
const
{
return
fBufferAccesses
.
count
(
)
;
}
const
GrBufferAccess
&
bufferAccess
(
int
index
)
const
{
return
*
fBufferAccesses
[
index
]
;
}
enum
RequiredFeatures
{
kNone_RequiredFeatures
=
0
kFragmentPosition_RequiredFeature
=
1
<
<
0
kSampleLocations_RequiredFeature
=
1
<
<
1
}
;
GR_DECL_BITFIELD_OPS_FRIENDS
(
RequiredFeatures
)
;
RequiredFeatures
requiredFeatures
(
)
const
{
return
fRequiredFeatures
;
}
void
*
operator
new
(
size_t
size
)
;
void
operator
delete
(
void
*
target
)
;
void
*
operator
new
(
size_t
size
void
*
placement
)
{
return
:
:
operator
new
(
size
placement
)
;
}
void
operator
delete
(
void
*
target
void
*
placement
)
{
:
:
operator
delete
(
target
placement
)
;
}
template
<
typename
T
>
const
T
&
cast
(
)
const
{
return
*
static_cast
<
const
T
*
>
(
this
)
;
}
uint32_t
classID
(
)
const
{
SkASSERT
(
kIllegalProcessorClassID
!
=
fClassID
)
;
return
fClassID
;
}
protected
:
GrProcessor
(
)
:
fClassID
(
kIllegalProcessorClassID
)
fRequiredFeatures
(
kNone_RequiredFeatures
)
{
}
virtual
void
addTextureAccess
(
const
GrTextureAccess
*
textureAccess
)
;
virtual
void
addBufferAccess
(
const
GrBufferAccess
*
bufferAccess
)
;
bool
hasSameSamplers
(
const
GrProcessor
&
)
const
;
void
setWillReadFragmentPosition
(
)
{
fRequiredFeatures
|
=
kFragmentPosition_RequiredFeature
;
}
void
setWillUseSampleLocations
(
)
{
fRequiredFeatures
|
=
kSampleLocations_RequiredFeature
;
}
void
combineRequiredFeatures
(
const
GrProcessor
&
other
)
{
fRequiredFeatures
|
=
other
.
fRequiredFeatures
;
}
template
<
typename
PROC_SUBCLASS
>
void
initClassID
(
)
{
static
uint32_t
kClassID
=
GenClassID
(
)
;
fClassID
=
kClassID
;
}
uint32_t
fClassID
;
SkSTArray
<
4
const
GrTextureAccess
*
true
>
fTextureAccesses
;
SkSTArray
<
2
const
GrBufferAccess
*
true
>
fBufferAccesses
;
private
:
static
uint32_t
GenClassID
(
)
{
uint32_t
id
=
static_cast
<
uint32_t
>
(
sk_atomic_inc
(
&
gCurrProcessorClassID
)
)
+
1
;
if
(
!
id
)
{
SkFAIL
(
"
This
should
never
wrap
as
it
should
only
be
called
once
for
each
GrProcessor
"
"
subclass
.
"
)
;
}
return
id
;
}
enum
{
kIllegalProcessorClassID
=
0
}
;
static
int32_t
gCurrProcessorClassID
;
RequiredFeatures
fRequiredFeatures
;
typedef
GrProgramElement
INHERITED
;
}
;
GR_MAKE_BITFIELD_OPS
(
GrProcessor
:
:
RequiredFeatures
)
;
#
endif
