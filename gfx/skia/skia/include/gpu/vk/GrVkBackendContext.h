#
ifndef
GrVkBackendContext_DEFINED
#
define
GrVkBackendContext_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
gpu
/
vk
/
GrVkTypes
.
h
"
#
include
"
include
/
gpu
/
vk
/
VulkanMemoryAllocator
.
h
"
namespace
skgpu
{
class
VulkanExtensions
;
}
enum
GrVkExtensionFlags
{
kEXT_debug_report_GrVkExtensionFlag
=
0x0001
kNV_glsl_shader_GrVkExtensionFlag
=
0x0002
kKHR_surface_GrVkExtensionFlag
=
0x0004
kKHR_swapchain_GrVkExtensionFlag
=
0x0008
kKHR_win32_surface_GrVkExtensionFlag
=
0x0010
kKHR_android_surface_GrVkExtensionFlag
=
0x0020
kKHR_xcb_surface_GrVkExtensionFlag
=
0x0040
}
;
enum
GrVkFeatureFlags
{
kGeometryShader_GrVkFeatureFlag
=
0x0001
kDualSrcBlend_GrVkFeatureFlag
=
0x0002
kSampleRateShading_GrVkFeatureFlag
=
0x0004
}
;
struct
VkPhysicalDeviceFeatures2
;
struct
SK_API
GrVkBackendContext
{
VkInstance
fInstance
=
VK_NULL_HANDLE
;
VkPhysicalDevice
fPhysicalDevice
=
VK_NULL_HANDLE
;
VkDevice
fDevice
=
VK_NULL_HANDLE
;
VkQueue
fQueue
=
VK_NULL_HANDLE
;
uint32_t
fGraphicsQueueIndex
=
0
;
uint32_t
fMinAPIVersion
=
0
;
uint32_t
fInstanceVersion
=
0
;
uint32_t
fMaxAPIVersion
=
0
;
uint32_t
fExtensions
=
0
;
const
skgpu
:
:
VulkanExtensions
*
fVkExtensions
=
nullptr
;
uint32_t
fFeatures
=
0
;
const
VkPhysicalDeviceFeatures
*
fDeviceFeatures
=
nullptr
;
const
VkPhysicalDeviceFeatures2
*
fDeviceFeatures2
=
nullptr
;
sk_sp
<
skgpu
:
:
VulkanMemoryAllocator
>
fMemoryAllocator
;
skgpu
:
:
VulkanGetProc
fGetProc
=
nullptr
;
bool
fOwnsInstanceAndDevice
=
false
;
skgpu
:
:
Protected
fProtectedContext
=
skgpu
:
:
Protected
:
:
kNo
;
}
;
#
endif
