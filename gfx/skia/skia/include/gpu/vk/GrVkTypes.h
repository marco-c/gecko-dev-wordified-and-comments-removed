#
ifndef
GrVkTypes_DEFINED
#
define
GrVkTypes_DEFINED
#
include
"
include
/
gpu
/
GpuTypes
.
h
"
#
include
"
include
/
gpu
/
vk
/
VulkanTypes
.
h
"
using
GrVkBackendMemory
=
skgpu
:
:
VulkanBackendMemory
;
using
GrVkAlloc
=
skgpu
:
:
VulkanAlloc
;
struct
GrVkYcbcrConversionInfo
{
bool
operator
=
=
(
const
GrVkYcbcrConversionInfo
&
that
)
const
{
if
(
!
this
-
>
isValid
(
)
&
&
!
that
.
isValid
(
)
)
{
return
true
;
}
return
this
-
>
fFormat
=
=
that
.
fFormat
&
&
this
-
>
fExternalFormat
=
=
that
.
fExternalFormat
&
&
this
-
>
fYcbcrModel
=
=
that
.
fYcbcrModel
&
&
this
-
>
fYcbcrRange
=
=
that
.
fYcbcrRange
&
&
this
-
>
fXChromaOffset
=
=
that
.
fXChromaOffset
&
&
this
-
>
fYChromaOffset
=
=
that
.
fYChromaOffset
&
&
this
-
>
fChromaFilter
=
=
that
.
fChromaFilter
&
&
this
-
>
fForceExplicitReconstruction
=
=
that
.
fForceExplicitReconstruction
;
}
bool
operator
!
=
(
const
GrVkYcbcrConversionInfo
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
bool
isValid
(
)
const
{
return
fYcbcrModel
!
=
VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY
;
}
VkFormat
fFormat
=
VK_FORMAT_UNDEFINED
;
uint64_t
fExternalFormat
=
0
;
VkSamplerYcbcrModelConversion
fYcbcrModel
=
VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY
;
VkSamplerYcbcrRange
fYcbcrRange
=
VK_SAMPLER_YCBCR_RANGE_ITU_FULL
;
VkChromaLocation
fXChromaOffset
=
VK_CHROMA_LOCATION_COSITED_EVEN
;
VkChromaLocation
fYChromaOffset
=
VK_CHROMA_LOCATION_COSITED_EVEN
;
VkFilter
fChromaFilter
=
VK_FILTER_NEAREST
;
VkBool32
fForceExplicitReconstruction
=
false
;
VkFormatFeatureFlags
fFormatFeatures
=
0
;
}
;
struct
GrVkImageInfo
{
VkImage
fImage
=
VK_NULL_HANDLE
;
skgpu
:
:
VulkanAlloc
fAlloc
;
VkImageTiling
fImageTiling
=
VK_IMAGE_TILING_OPTIMAL
;
VkImageLayout
fImageLayout
=
VK_IMAGE_LAYOUT_UNDEFINED
;
VkFormat
fFormat
=
VK_FORMAT_UNDEFINED
;
VkImageUsageFlags
fImageUsageFlags
=
0
;
uint32_t
fSampleCount
=
1
;
uint32_t
fLevelCount
=
0
;
uint32_t
fCurrentQueueFamily
=
VK_QUEUE_FAMILY_IGNORED
;
skgpu
:
:
Protected
fProtected
=
skgpu
:
:
Protected
:
:
kNo
;
GrVkYcbcrConversionInfo
fYcbcrConversionInfo
;
VkSharingMode
fSharingMode
=
VK_SHARING_MODE_EXCLUSIVE
;
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
bool
fPartOfSwapchainOrAndroidWindow
=
false
;
#
endif
#
if
GR_TEST_UTILS
bool
operator
=
=
(
const
GrVkImageInfo
&
that
)
const
{
bool
equal
=
fImage
=
=
that
.
fImage
&
&
fAlloc
=
=
that
.
fAlloc
&
&
fImageTiling
=
=
that
.
fImageTiling
&
&
fImageLayout
=
=
that
.
fImageLayout
&
&
fFormat
=
=
that
.
fFormat
&
&
fImageUsageFlags
=
=
that
.
fImageUsageFlags
&
&
fSampleCount
=
=
that
.
fSampleCount
&
&
fLevelCount
=
=
that
.
fLevelCount
&
&
fCurrentQueueFamily
=
=
that
.
fCurrentQueueFamily
&
&
fProtected
=
=
that
.
fProtected
&
&
fYcbcrConversionInfo
=
=
that
.
fYcbcrConversionInfo
&
&
fSharingMode
=
=
that
.
fSharingMode
;
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
equal
=
equal
&
&
(
fPartOfSwapchainOrAndroidWindow
=
=
that
.
fPartOfSwapchainOrAndroidWindow
)
;
#
endif
return
equal
;
}
#
endif
}
;
using
GrVkGetProc
=
skgpu
:
:
VulkanGetProc
;
struct
GrVkDrawableInfo
{
VkCommandBuffer
fSecondaryCommandBuffer
;
uint32_t
fColorAttachmentIndex
;
VkRenderPass
fCompatibleRenderPass
;
VkFormat
fFormat
;
VkRect2D
*
fDrawBounds
;
#
ifdef
SK_BUILD_FOR_ANDROID_FRAMEWORK
bool
fFromSwapchainOrAndroidWindow
;
#
endif
}
;
struct
GrVkSurfaceInfo
{
uint32_t
fSampleCount
=
1
;
uint32_t
fLevelCount
=
0
;
skgpu
:
:
Protected
fProtected
=
skgpu
:
:
Protected
:
:
kNo
;
VkImageTiling
fImageTiling
=
VK_IMAGE_TILING_OPTIMAL
;
VkFormat
fFormat
=
VK_FORMAT_UNDEFINED
;
VkImageUsageFlags
fImageUsageFlags
=
0
;
GrVkYcbcrConversionInfo
fYcbcrConversionInfo
;
VkSharingMode
fSharingMode
=
VK_SHARING_MODE_EXCLUSIVE
;
}
;
#
endif
