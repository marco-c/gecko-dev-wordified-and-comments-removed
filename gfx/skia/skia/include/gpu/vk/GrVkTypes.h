#
ifndef
GrVkTypes_DEFINED
#
define
GrVkTypes_DEFINED
#
include
"
SkTypes
.
h
"
#
include
"
GrVkVulkan
.
h
"
#
ifndef
VK_VERSION_1_1
#
error
Skia
requires
the
use
of
Vulkan
1
.
1
headers
#
endif
#
include
<
functional
>
#
include
"
GrTypes
.
h
"
typedef
intptr_t
GrVkBackendMemory
;
struct
GrVkAlloc
{
GrVkAlloc
(
)
:
fMemory
(
VK_NULL_HANDLE
)
fOffset
(
0
)
fSize
(
0
)
fFlags
(
0
)
fBackendMemory
(
0
)
fUsesSystemHeap
(
false
)
{
}
GrVkAlloc
(
VkDeviceMemory
memory
VkDeviceSize
offset
VkDeviceSize
size
uint32_t
flags
)
:
fMemory
(
memory
)
fOffset
(
offset
)
fSize
(
size
)
fFlags
(
flags
)
fBackendMemory
(
0
)
fUsesSystemHeap
(
false
)
{
}
VkDeviceMemory
fMemory
;
VkDeviceSize
fOffset
;
VkDeviceSize
fSize
;
uint32_t
fFlags
;
GrVkBackendMemory
fBackendMemory
;
enum
Flag
{
kNoncoherent_Flag
=
0x1
kMappable_Flag
=
0x2
}
;
bool
operator
=
=
(
const
GrVkAlloc
&
that
)
const
{
return
fMemory
=
=
that
.
fMemory
&
&
fOffset
=
=
that
.
fOffset
&
&
fSize
=
=
that
.
fSize
&
&
fFlags
=
=
that
.
fFlags
&
&
fUsesSystemHeap
=
=
that
.
fUsesSystemHeap
;
}
private
:
friend
class
GrVkHeap
;
bool
fUsesSystemHeap
;
}
;
struct
GrVkYcbcrConversionInfo
{
GrVkYcbcrConversionInfo
(
)
:
fYcbcrModel
(
VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY
)
fYcbcrRange
(
VK_SAMPLER_YCBCR_RANGE_ITU_FULL
)
fXChromaOffset
(
VK_CHROMA_LOCATION_COSITED_EVEN
)
fYChromaOffset
(
VK_CHROMA_LOCATION_COSITED_EVEN
)
fChromaFilter
(
VK_FILTER_NEAREST
)
fForceExplicitReconstruction
(
false
)
fExternalFormat
(
0
)
fExternalFormatFeatures
(
0
)
{
}
GrVkYcbcrConversionInfo
(
VkSamplerYcbcrModelConversion
ycbcrModel
VkSamplerYcbcrRange
ycbcrRange
VkChromaLocation
xChromaOffset
VkChromaLocation
yChromaOffset
VkFilter
chromaFilter
VkBool32
forceExplicitReconstruction
uint64_t
externalFormat
VkFormatFeatureFlags
externalFormatFeatures
)
:
fYcbcrModel
(
ycbcrModel
)
fYcbcrRange
(
ycbcrRange
)
fXChromaOffset
(
xChromaOffset
)
fYChromaOffset
(
yChromaOffset
)
fChromaFilter
(
chromaFilter
)
fForceExplicitReconstruction
(
forceExplicitReconstruction
)
fExternalFormat
(
externalFormat
)
fExternalFormatFeatures
(
externalFormatFeatures
)
{
SkASSERT
(
fExternalFormat
)
;
}
bool
operator
=
=
(
const
GrVkYcbcrConversionInfo
&
that
)
const
{
if
(
!
this
-
>
isValid
(
)
&
&
!
that
.
isValid
(
)
)
{
return
true
;
}
return
this
-
>
fYcbcrModel
=
=
that
.
fYcbcrModel
&
&
this
-
>
fYcbcrRange
=
=
that
.
fYcbcrRange
&
&
this
-
>
fXChromaOffset
=
=
that
.
fXChromaOffset
&
&
this
-
>
fYChromaOffset
=
=
that
.
fYChromaOffset
&
&
this
-
>
fChromaFilter
=
=
that
.
fChromaFilter
&
&
this
-
>
fForceExplicitReconstruction
=
=
that
.
fForceExplicitReconstruction
&
&
this
-
>
fExternalFormat
=
=
that
.
fExternalFormat
;
}
bool
operator
!
=
(
const
GrVkYcbcrConversionInfo
&
that
)
const
{
return
!
(
*
this
=
=
that
)
;
}
bool
isValid
(
)
const
{
return
fExternalFormat
!
=
0
;
}
VkSamplerYcbcrModelConversion
fYcbcrModel
;
VkSamplerYcbcrRange
fYcbcrRange
;
VkChromaLocation
fXChromaOffset
;
VkChromaLocation
fYChromaOffset
;
VkFilter
fChromaFilter
;
VkBool32
fForceExplicitReconstruction
;
uint64_t
fExternalFormat
;
VkFormatFeatureFlags
fExternalFormatFeatures
;
}
;
struct
GrVkImageInfo
{
VkImage
fImage
;
GrVkAlloc
fAlloc
;
VkImageTiling
fImageTiling
;
VkImageLayout
fImageLayout
;
VkFormat
fFormat
;
uint32_t
fLevelCount
;
uint32_t
fCurrentQueueFamily
;
GrVkYcbcrConversionInfo
fYcbcrConversionInfo
;
GrVkImageInfo
(
)
:
fImage
(
VK_NULL_HANDLE
)
fAlloc
(
)
fImageTiling
(
VK_IMAGE_TILING_OPTIMAL
)
fImageLayout
(
VK_IMAGE_LAYOUT_UNDEFINED
)
fFormat
(
VK_FORMAT_UNDEFINED
)
fLevelCount
(
0
)
fCurrentQueueFamily
(
VK_QUEUE_FAMILY_IGNORED
)
fYcbcrConversionInfo
(
)
{
}
GrVkImageInfo
(
VkImage
image
GrVkAlloc
alloc
VkImageTiling
imageTiling
VkImageLayout
layout
VkFormat
format
uint32_t
levelCount
uint32_t
currentQueueFamily
=
VK_QUEUE_FAMILY_IGNORED
GrVkYcbcrConversionInfo
ycbcrConversionInfo
=
GrVkYcbcrConversionInfo
(
)
)
:
fImage
(
image
)
fAlloc
(
alloc
)
fImageTiling
(
imageTiling
)
fImageLayout
(
layout
)
fFormat
(
format
)
fLevelCount
(
levelCount
)
fCurrentQueueFamily
(
currentQueueFamily
)
fYcbcrConversionInfo
(
ycbcrConversionInfo
)
{
}
GrVkImageInfo
(
const
GrVkImageInfo
&
info
VkImageLayout
layout
)
:
fImage
(
info
.
fImage
)
fAlloc
(
info
.
fAlloc
)
fImageTiling
(
info
.
fImageTiling
)
fImageLayout
(
layout
)
fFormat
(
info
.
fFormat
)
fLevelCount
(
info
.
fLevelCount
)
fCurrentQueueFamily
(
info
.
fCurrentQueueFamily
)
fYcbcrConversionInfo
(
info
.
fYcbcrConversionInfo
)
{
}
void
updateImageLayout
(
VkImageLayout
layout
)
{
fImageLayout
=
layout
;
}
bool
operator
=
=
(
const
GrVkImageInfo
&
that
)
const
{
return
fImage
=
=
that
.
fImage
&
&
fAlloc
=
=
that
.
fAlloc
&
&
fImageTiling
=
=
that
.
fImageTiling
&
&
fImageLayout
=
=
that
.
fImageLayout
&
&
fFormat
=
=
that
.
fFormat
&
&
fLevelCount
=
=
that
.
fLevelCount
&
&
fCurrentQueueFamily
=
=
that
.
fCurrentQueueFamily
&
&
fYcbcrConversionInfo
=
=
that
.
fYcbcrConversionInfo
;
}
}
;
using
GrVkGetProc
=
std
:
:
function
<
PFN_vkVoidFunction
(
const
char
*
VkInstance
VkDevice
)
>
;
struct
GrVkDrawableInfo
{
VkCommandBuffer
fSecondaryCommandBuffer
;
uint32_t
fColorAttachmentIndex
;
VkRenderPass
fCompatibleRenderPass
;
VkFormat
fFormat
;
VkRect2D
*
fDrawBounds
;
VkImage
fImage
;
}
;
#
endif
