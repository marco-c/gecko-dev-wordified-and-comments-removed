#
ifndef
GrTextureProvider_DEFINED
#
define
GrTextureProvider_DEFINED
#
include
"
GrTexture
.
h
"
#
include
"
SkImageFilter
.
h
"
class
SK_API
GrTextureProvider
{
public
:
GrTexture
*
createTexture
(
const
GrSurfaceDesc
&
desc
bool
budgeted
const
void
*
srcData
size_t
rowBytes
)
;
GrTexture
*
createTexture
(
const
GrSurfaceDesc
&
desc
bool
budgeted
)
{
return
this
-
>
createTexture
(
desc
budgeted
NULL
0
)
;
}
void
assignUniqueKeyToTexture
(
const
GrUniqueKey
&
key
GrTexture
*
texture
)
{
this
-
>
assignUniqueKeyToResource
(
key
texture
)
;
}
GrTexture
*
findAndRefTextureByUniqueKey
(
const
GrUniqueKey
&
key
)
{
GrGpuResource
*
resource
=
this
-
>
findAndRefResourceByUniqueKey
(
key
)
;
if
(
resource
)
{
GrTexture
*
texture
=
static_cast
<
GrSurface
*
>
(
resource
)
-
>
asTexture
(
)
;
SkASSERT
(
texture
)
;
return
texture
;
}
return
NULL
;
}
bool
existsTextureWithUniqueKey
(
const
GrUniqueKey
&
key
)
const
{
return
this
-
>
existsResourceWithUniqueKey
(
key
)
;
}
GrTexture
*
createApproxTexture
(
const
GrSurfaceDesc
&
)
;
enum
SizeConstraint
{
kExact_SizeConstraint
kApprox_SizeConstraint
}
;
GrTexture
*
createTexture
(
const
GrSurfaceDesc
&
desc
SizeConstraint
constraint
)
{
switch
(
constraint
)
{
case
kExact_SizeConstraint
:
return
this
-
>
createTexture
(
desc
true
)
;
case
kApprox_SizeConstraint
:
return
this
-
>
createApproxTexture
(
desc
)
;
}
sk_throw
(
)
;
return
nullptr
;
}
static
SizeConstraint
FromImageFilter
(
SkImageFilter
:
:
SizeConstraint
constraint
)
{
if
(
SkImageFilter
:
:
kExact_SizeConstraint
=
=
constraint
)
{
return
kExact_SizeConstraint
;
}
else
{
SkASSERT
(
SkImageFilter
:
:
kApprox_SizeConstraint
=
=
constraint
)
;
return
kApprox_SizeConstraint
;
}
}
enum
ScratchTexMatch
{
kExact_ScratchTexMatch
kApprox_ScratchTexMatch
}
;
GrTexture
*
refScratchTexture
(
const
GrSurfaceDesc
&
desc
ScratchTexMatch
match
)
{
if
(
kApprox_ScratchTexMatch
=
=
match
)
{
return
this
-
>
createApproxTexture
(
desc
)
;
}
else
{
return
this
-
>
createTexture
(
desc
true
)
;
}
}
GrTexture
*
wrapBackendTexture
(
const
GrBackendTextureDesc
&
desc
GrWrapOwnership
=
kBorrow_GrWrapOwnership
)
;
GrRenderTarget
*
wrapBackendRenderTarget
(
const
GrBackendRenderTargetDesc
&
desc
)
;
protected
:
GrTextureProvider
(
GrGpu
*
gpu
GrResourceCache
*
cache
)
:
fCache
(
cache
)
fGpu
(
gpu
)
{
}
void
assignUniqueKeyToResource
(
const
GrUniqueKey
&
GrGpuResource
*
)
;
GrGpuResource
*
findAndRefResourceByUniqueKey
(
const
GrUniqueKey
&
)
;
bool
existsResourceWithUniqueKey
(
const
GrUniqueKey
&
key
)
const
;
enum
ScratchTextureFlags
{
kExact_ScratchTextureFlag
=
0x1
kNoPendingIO_ScratchTextureFlag
=
0x2
kNoCreate_ScratchTextureFlag
=
0x4
}
;
GrTexture
*
internalCreateApproxTexture
(
const
GrSurfaceDesc
&
desc
uint32_t
scratchTextureFlags
)
;
GrTexture
*
refScratchTexture
(
const
GrSurfaceDesc
&
uint32_t
scratchTextureFlags
)
;
void
abandon
(
)
{
fCache
=
NULL
;
fGpu
=
NULL
;
}
GrResourceCache
*
cache
(
)
{
return
fCache
;
}
const
GrResourceCache
*
cache
(
)
const
{
return
fCache
;
}
GrGpu
*
gpu
(
)
{
return
fGpu
;
}
const
GrGpu
*
gpu
(
)
const
{
return
fGpu
;
}
bool
isAbandoned
(
)
const
{
SkASSERT
(
SkToBool
(
fGpu
)
=
=
SkToBool
(
fCache
)
)
;
return
!
SkToBool
(
fCache
)
;
}
private
:
GrResourceCache
*
fCache
;
GrGpu
*
fGpu
;
}
;
#
endif
