#
ifndef
GrTextureProvider_DEFINED
#
define
GrTextureProvider_DEFINED
#
include
"
GrTexture
.
h
"
#
include
"
SkImageFilter
.
h
"
class
GrSingleOwner
;
class
SK_API
GrTextureProvider
{
public
:
GrTexture
*
createTexture
(
const
GrSurfaceDesc
&
desc
bool
budgeted
const
void
*
srcData
size_t
rowBytes
)
;
GrTexture
*
createTexture
(
const
GrSurfaceDesc
&
desc
bool
budgeted
)
{
return
this
-
>
createTexture
(
desc
budgeted
NULL
0
)
;
}
void
assignUniqueKeyToTexture
(
const
GrUniqueKey
&
key
GrTexture
*
texture
)
{
this
-
>
assignUniqueKeyToResource
(
key
texture
)
;
}
GrTexture
*
findAndRefTextureByUniqueKey
(
const
GrUniqueKey
&
key
)
;
bool
existsTextureWithUniqueKey
(
const
GrUniqueKey
&
key
)
const
{
return
this
-
>
existsResourceWithUniqueKey
(
key
)
;
}
GrTexture
*
createApproxTexture
(
const
GrSurfaceDesc
&
)
;
enum
ScratchTexMatch
{
kExact_ScratchTexMatch
kApprox_ScratchTexMatch
}
;
GrTexture
*
refScratchTexture
(
const
GrSurfaceDesc
&
desc
ScratchTexMatch
match
)
{
if
(
kApprox_ScratchTexMatch
=
=
match
)
{
return
this
-
>
createApproxTexture
(
desc
)
;
}
else
{
return
this
-
>
createTexture
(
desc
true
)
;
}
}
GrTexture
*
wrapBackendTexture
(
const
GrBackendTextureDesc
&
desc
GrWrapOwnership
=
kBorrow_GrWrapOwnership
)
;
GrRenderTarget
*
wrapBackendRenderTarget
(
const
GrBackendRenderTargetDesc
&
desc
)
;
protected
:
GrTextureProvider
(
GrGpu
*
gpu
GrResourceCache
*
cache
GrSingleOwner
*
singleOwner
)
;
void
assignUniqueKeyToResource
(
const
GrUniqueKey
&
GrGpuResource
*
)
;
GrGpuResource
*
findAndRefResourceByUniqueKey
(
const
GrUniqueKey
&
)
;
bool
existsResourceWithUniqueKey
(
const
GrUniqueKey
&
key
)
const
;
enum
ScratchTextureFlags
{
kExact_ScratchTextureFlag
=
0x1
kNoPendingIO_ScratchTextureFlag
=
0x2
kNoCreate_ScratchTextureFlag
=
0x4
}
;
GrTexture
*
internalCreateApproxTexture
(
const
GrSurfaceDesc
&
desc
uint32_t
scratchTextureFlags
)
;
GrTexture
*
refScratchTexture
(
const
GrSurfaceDesc
&
uint32_t
scratchTextureFlags
)
;
void
abandon
(
)
{
fCache
=
NULL
;
fGpu
=
NULL
;
}
GrResourceCache
*
cache
(
)
{
return
fCache
;
}
const
GrResourceCache
*
cache
(
)
const
{
return
fCache
;
}
GrGpu
*
gpu
(
)
{
return
fGpu
;
}
const
GrGpu
*
gpu
(
)
const
{
return
fGpu
;
}
bool
isAbandoned
(
)
const
{
SkASSERT
(
SkToBool
(
fGpu
)
=
=
SkToBool
(
fCache
)
)
;
return
!
SkToBool
(
fCache
)
;
}
private
:
GrResourceCache
*
fCache
;
GrGpu
*
fGpu
;
SkDEBUGCODE
(
mutable
GrSingleOwner
*
fSingleOwner
;
)
}
;
#
endif
