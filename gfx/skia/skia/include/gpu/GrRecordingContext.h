#
ifndef
GrRecordingContext_DEFINED
#
define
GrRecordingContext_DEFINED
#
include
"
include
/
core
/
SkRefCnt
.
h
"
#
include
"
include
/
core
/
SkTypes
.
h
"
#
include
"
include
/
private
/
base
/
SkTArray
.
h
"
#
include
"
include
/
private
/
gpu
/
ganesh
/
GrImageContext
.
h
"
#
if
GR_GPU_STATS
&
&
GR_TEST_UTILS
#
include
<
map
>
#
include
<
string
>
#
endif
class
GrAuditTrail
;
class
GrBackendFormat
;
class
GrDrawingManager
;
class
GrOnFlushCallbackObject
;
class
GrMemoryPool
;
class
GrProgramDesc
;
class
GrProgramInfo
;
class
GrProxyProvider
;
class
GrRecordingContextPriv
;
class
GrSurfaceProxy
;
class
GrThreadSafeCache
;
class
SkArenaAlloc
;
class
SkCapabilities
;
class
SkJSONWriter
;
namespace
sktext
:
:
gpu
{
class
SubRunAllocator
;
class
TextBlobRedrawCoordinator
;
}
#
if
GR_TEST_UTILS
class
SkString
;
#
endif
class
GrRecordingContext
:
public
GrImageContext
{
public
:
~
GrRecordingContext
(
)
override
;
SK_API
GrBackendFormat
defaultBackendFormat
(
SkColorType
ct
GrRenderable
renderable
)
const
{
return
INHERITED
:
:
defaultBackendFormat
(
ct
renderable
)
;
}
bool
abandoned
(
)
override
{
return
INHERITED
:
:
abandoned
(
)
;
}
SK_API
bool
colorTypeSupportedAsSurface
(
SkColorType
colorType
)
const
{
if
(
kR16G16_unorm_SkColorType
=
=
colorType
|
|
kA16_unorm_SkColorType
=
=
colorType
|
|
kA16_float_SkColorType
=
=
colorType
|
|
kR16G16_float_SkColorType
=
=
colorType
|
|
kR16G16B16A16_unorm_SkColorType
=
=
colorType
|
|
kGray_8_SkColorType
=
=
colorType
)
{
return
false
;
}
return
this
-
>
maxSurfaceSampleCountForColorType
(
colorType
)
>
0
;
}
SK_API
int
maxTextureSize
(
)
const
;
SK_API
int
maxRenderTargetSize
(
)
const
;
SK_API
bool
colorTypeSupportedAsImage
(
SkColorType
)
const
;
SK_API
int
maxSurfaceSampleCountForColorType
(
SkColorType
colorType
)
const
{
return
INHERITED
:
:
maxSurfaceSampleCountForColorType
(
colorType
)
;
}
SK_API
sk_sp
<
const
SkCapabilities
>
skCapabilities
(
)
const
;
GrRecordingContextPriv
priv
(
)
;
const
GrRecordingContextPriv
priv
(
)
const
;
class
Arenas
{
public
:
Arenas
(
SkArenaAlloc
*
sktext
:
:
gpu
:
:
SubRunAllocator
*
)
;
SkArenaAlloc
*
recordTimeAllocator
(
)
{
return
fRecordTimeAllocator
;
}
sktext
:
:
gpu
:
:
SubRunAllocator
*
recordTimeSubRunAllocator
(
)
{
return
fRecordTimeSubRunAllocator
;
}
private
:
SkArenaAlloc
*
fRecordTimeAllocator
;
sktext
:
:
gpu
:
:
SubRunAllocator
*
fRecordTimeSubRunAllocator
;
}
;
protected
:
friend
class
GrRecordingContextPriv
;
friend
class
SkDeferredDisplayList
;
friend
class
SkDeferredDisplayListPriv
;
class
OwnedArenas
{
public
:
OwnedArenas
(
bool
ddlRecording
)
;
~
OwnedArenas
(
)
;
Arenas
get
(
)
;
OwnedArenas
&
operator
=
(
OwnedArenas
&
&
)
;
private
:
bool
fDDLRecording
;
std
:
:
unique_ptr
<
SkArenaAlloc
>
fRecordTimeAllocator
;
std
:
:
unique_ptr
<
sktext
:
:
gpu
:
:
SubRunAllocator
>
fRecordTimeSubRunAllocator
;
}
;
GrRecordingContext
(
sk_sp
<
GrContextThreadSafeProxy
>
bool
ddlRecording
)
;
bool
init
(
)
override
;
void
abandonContext
(
)
override
;
GrDrawingManager
*
drawingManager
(
)
;
void
destroyDrawingManager
(
)
;
Arenas
arenas
(
)
{
return
fArenas
.
get
(
)
;
}
OwnedArenas
&
&
detachArenas
(
)
;
GrProxyProvider
*
proxyProvider
(
)
{
return
fProxyProvider
.
get
(
)
;
}
const
GrProxyProvider
*
proxyProvider
(
)
const
{
return
fProxyProvider
.
get
(
)
;
}
struct
ProgramData
{
ProgramData
(
std
:
:
unique_ptr
<
const
GrProgramDesc
>
const
GrProgramInfo
*
)
;
ProgramData
(
ProgramData
&
&
)
;
ProgramData
(
const
ProgramData
&
)
=
delete
;
~
ProgramData
(
)
;
const
GrProgramDesc
&
desc
(
)
const
{
return
*
fDesc
;
}
const
GrProgramInfo
&
info
(
)
const
{
return
*
fInfo
;
}
private
:
std
:
:
unique_ptr
<
const
GrProgramDesc
>
fDesc
;
const
GrProgramInfo
*
fInfo
=
nullptr
;
}
;
virtual
void
recordProgramInfo
(
const
GrProgramInfo
*
)
{
}
virtual
void
detachProgramData
(
SkTArray
<
ProgramData
>
*
)
{
}
sktext
:
:
gpu
:
:
TextBlobRedrawCoordinator
*
getTextBlobRedrawCoordinator
(
)
;
const
sktext
:
:
gpu
:
:
TextBlobRedrawCoordinator
*
getTextBlobRedrawCoordinator
(
)
const
;
GrThreadSafeCache
*
threadSafeCache
(
)
;
const
GrThreadSafeCache
*
threadSafeCache
(
)
const
;
void
addOnFlushCallbackObject
(
GrOnFlushCallbackObject
*
)
;
GrRecordingContext
*
asRecordingContext
(
)
override
{
return
this
;
}
class
Stats
{
public
:
Stats
(
)
=
default
;
#
if
GR_GPU_STATS
void
reset
(
)
{
*
this
=
{
}
;
}
int
numPathMasksGenerated
(
)
const
{
return
fNumPathMasksGenerated
;
}
void
incNumPathMasksGenerated
(
)
{
fNumPathMasksGenerated
+
+
;
}
int
numPathMaskCacheHits
(
)
const
{
return
fNumPathMaskCacheHits
;
}
void
incNumPathMasksCacheHits
(
)
{
fNumPathMaskCacheHits
+
+
;
}
#
if
GR_TEST_UTILS
void
dump
(
SkString
*
out
)
const
;
void
dumpKeyValuePairs
(
SkTArray
<
SkString
>
*
keys
SkTArray
<
double
>
*
values
)
const
;
#
endif
private
:
int
fNumPathMasksGenerated
{
0
}
;
int
fNumPathMaskCacheHits
{
0
}
;
#
else
void
incNumPathMasksGenerated
(
)
{
}
void
incNumPathMasksCacheHits
(
)
{
}
#
if
GR_TEST_UTILS
void
dump
(
SkString
*
)
const
{
}
void
dumpKeyValuePairs
(
SkTArray
<
SkString
>
*
keys
SkTArray
<
double
>
*
values
)
const
{
}
#
endif
#
endif
}
fStats
;
#
if
GR_GPU_STATS
&
&
GR_TEST_UTILS
struct
DMSAAStats
{
void
dumpKeyValuePairs
(
SkTArray
<
SkString
>
*
keys
SkTArray
<
double
>
*
values
)
const
;
void
dump
(
)
const
;
void
merge
(
const
DMSAAStats
&
)
;
int
fNumRenderPasses
=
0
;
int
fNumMultisampleRenderPasses
=
0
;
std
:
:
map
<
std
:
:
string
int
>
fTriggerCounts
;
}
;
DMSAAStats
fDMSAAStats
;
#
endif
Stats
*
stats
(
)
{
return
&
fStats
;
}
const
Stats
*
stats
(
)
const
{
return
&
fStats
;
}
void
dumpJSON
(
SkJSONWriter
*
)
const
;
protected
:
std
:
:
unique_ptr
<
GrAuditTrail
>
fAuditTrail
;
private
:
OwnedArenas
fArenas
;
std
:
:
unique_ptr
<
GrDrawingManager
>
fDrawingManager
;
std
:
:
unique_ptr
<
GrProxyProvider
>
fProxyProvider
;
#
if
GR_TEST_UTILS
int
fSuppressWarningMessages
=
0
;
#
endif
using
INHERITED
=
GrImageContext
;
}
;
static
inline
GrDirectContext
*
GrAsDirectContext
(
GrContext_Base
*
base
)
{
return
base
?
base
-
>
asDirectContext
(
)
:
nullptr
;
}
#
endif
