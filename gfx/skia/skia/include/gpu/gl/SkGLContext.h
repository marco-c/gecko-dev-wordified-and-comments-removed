#
ifndef
SkGLContext_DEFINED
#
define
SkGLContext_DEFINED
#
include
"
GrGLInterface
.
h
"
#
include
"
.
.
/
private
/
SkGpuFenceSync
.
h
"
class
SK_API
SkGLContext
:
public
SkRefCnt
{
public
:
~
SkGLContext
(
)
override
;
bool
isValid
(
)
const
{
return
NULL
!
=
gl
(
)
;
}
const
GrGLInterface
*
gl
(
)
const
{
return
fGL
.
get
(
)
;
}
bool
fenceSyncSupport
(
)
const
{
return
SkToBool
(
fFenceSync
)
;
}
bool
getMaxGpuFrameLag
(
int
*
maxFrameLag
)
const
{
if
(
!
fFenceSync
)
{
return
false
;
}
*
maxFrameLag
=
kMaxFrameLag
;
return
true
;
}
void
makeCurrent
(
)
const
;
virtual
GrEGLImage
texture2DToEGLImage
(
GrGLuint
)
const
{
return
0
;
}
virtual
void
destroyEGLImage
(
GrEGLImage
)
const
{
}
virtual
GrGLuint
eglImageToExternalTexture
(
GrEGLImage
)
const
{
return
0
;
}
void
swapBuffers
(
)
;
void
testAbandon
(
)
;
virtual
SkGLContext
*
createNew
(
)
const
{
return
nullptr
;
}
class
GLFenceSync
;
protected
:
SkGLContext
(
)
;
void
init
(
const
GrGLInterface
*
SkGpuFenceSync
*
=
NULL
)
;
void
teardown
(
)
;
virtual
void
onPlatformMakeCurrent
(
)
const
=
0
;
virtual
void
onPlatformSwapBuffers
(
)
const
=
0
;
virtual
GrGLFuncPtr
onPlatformGetProcAddress
(
const
char
*
)
const
=
0
;
private
:
enum
{
kMaxFrameLag
=
3
}
;
SkAutoTDelete
<
SkGpuFenceSync
>
fFenceSync
;
SkPlatformGpuFence
fFrameFences
[
kMaxFrameLag
-
1
]
;
int
fCurrentFenceIdx
;
SkAutoTUnref
<
const
GrGLInterface
>
fGL
;
friend
class
GLFenceSync
;
typedef
SkRefCnt
INHERITED
;
}
;
SK_API
SkGLContext
*
SkCreatePlatformGLContext
(
GrGLStandard
forcedGpuAPI
)
;
#
define
SK_GL
(
ctx
X
)
(
ctx
)
.
gl
(
)
-
>
fFunctions
.
f
#
#
X
;
\
SkASSERT
(
0
=
=
(
ctx
)
.
gl
(
)
-
>
fFunctions
.
fGetError
(
)
)
#
define
SK_GL_RET
(
ctx
RET
X
)
(
RET
)
=
(
ctx
)
.
gl
(
)
-
>
fFunctions
.
f
#
#
X
;
\
SkASSERT
(
0
=
=
(
ctx
)
.
gl
(
)
-
>
fFunctions
.
fGetError
(
)
)
#
define
SK_GL_NOERRCHECK
(
ctx
X
)
(
ctx
)
.
gl
(
)
-
>
fFunctions
.
f
#
#
X
#
define
SK_GL_RET_NOERRCHECK
(
ctx
RET
X
)
(
RET
)
=
(
ctx
)
.
gl
(
)
-
>
fFunctions
.
f
#
#
X
#
endif
