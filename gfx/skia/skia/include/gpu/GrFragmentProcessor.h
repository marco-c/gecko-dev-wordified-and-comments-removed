#
ifndef
GrFragmentProcessor_DEFINED
#
define
GrFragmentProcessor_DEFINED
#
include
"
GrProcessor
.
h
"
class
GrCoordTransform
;
class
GrGLSLFragmentProcessor
;
class
GrInvariantOutput
;
class
GrPipeline
;
class
GrProcessorKeyBuilder
;
class
GrShaderCaps
;
class
GrSwizzle
;
class
GrFragmentProcessor
:
public
GrResourceIOProcessor
public
GrProgramElement
{
public
:
static
sk_sp
<
GrFragmentProcessor
>
MulOutputByInputAlpha
(
sk_sp
<
GrFragmentProcessor
>
)
;
static
sk_sp
<
GrFragmentProcessor
>
MakeInputPremulAndMulByOutput
(
sk_sp
<
GrFragmentProcessor
>
)
;
static
sk_sp
<
GrFragmentProcessor
>
OverrideInput
(
sk_sp
<
GrFragmentProcessor
>
GrColor4f
)
;
static
sk_sp
<
GrFragmentProcessor
>
PremulInput
(
sk_sp
<
GrFragmentProcessor
>
)
;
static
sk_sp
<
GrFragmentProcessor
>
PremulOutput
(
sk_sp
<
GrFragmentProcessor
>
)
;
static
sk_sp
<
GrFragmentProcessor
>
UnpremulOutput
(
sk_sp
<
GrFragmentProcessor
>
)
;
static
sk_sp
<
GrFragmentProcessor
>
SwizzleOutput
(
sk_sp
<
GrFragmentProcessor
>
const
GrSwizzle
&
)
;
static
sk_sp
<
GrFragmentProcessor
>
RunInSeries
(
sk_sp
<
GrFragmentProcessor
>
*
int
cnt
)
;
~
GrFragmentProcessor
(
)
override
;
GrGLSLFragmentProcessor
*
createGLSLInstance
(
)
const
;
void
getGLSLProcessorKey
(
const
GrShaderCaps
&
caps
GrProcessorKeyBuilder
*
b
)
const
{
this
-
>
onGetGLSLProcessorKey
(
caps
b
)
;
for
(
int
i
=
0
;
i
<
fChildProcessors
.
count
(
)
;
+
+
i
)
{
fChildProcessors
[
i
]
-
>
getGLSLProcessorKey
(
caps
b
)
;
}
}
int
numCoordTransforms
(
)
const
{
return
fCoordTransforms
.
count
(
)
;
}
const
GrCoordTransform
&
coordTransform
(
int
index
)
const
{
return
*
fCoordTransforms
[
index
]
;
}
const
SkTArray
<
const
GrCoordTransform
*
true
>
&
coordTransforms
(
)
const
{
return
fCoordTransforms
;
}
int
numChildProcessors
(
)
const
{
return
fChildProcessors
.
count
(
)
;
}
const
GrFragmentProcessor
&
childProcessor
(
int
index
)
const
{
return
*
fChildProcessors
[
index
]
;
}
bool
usesLocalCoords
(
)
const
{
return
SkToBool
(
fFlags
&
kUsesLocalCoords_Flag
)
;
}
bool
usesDistanceVectorField
(
)
const
{
return
SkToBool
(
fFlags
&
kUsesDistanceVectorField_Flag
)
;
}
bool
compatibleWithCoverageAsAlpha
(
)
const
{
return
SkToBool
(
fFlags
&
kCompatibleWithCoverageAsAlpha_OptimizationFlag
)
;
}
bool
preservesOpaqueInput
(
)
const
{
return
SkToBool
(
fFlags
&
kPreservesOpaqueInput_OptimizationFlag
)
;
}
bool
hasConstantOutputForConstantInput
(
GrColor4f
inputColor
GrColor4f
*
outputColor
)
const
{
if
(
fFlags
&
kConstantOutputForConstantInput_OptimizationFlag
)
{
*
outputColor
=
this
-
>
constantOutputForConstantInput
(
inputColor
)
;
return
true
;
}
return
false
;
}
bool
hasConstantOutputForConstantInput
(
)
const
{
return
SkToBool
(
fFlags
&
kConstantOutputForConstantInput_OptimizationFlag
)
;
}
bool
isEqual
(
const
GrFragmentProcessor
&
that
)
const
;
class
Iter
:
public
SkNoncopyable
{
public
:
explicit
Iter
(
const
GrFragmentProcessor
*
fp
)
{
fFPStack
.
push_back
(
fp
)
;
}
explicit
Iter
(
const
GrPipeline
&
pipeline
)
;
const
GrFragmentProcessor
*
next
(
)
;
private
:
SkSTArray
<
4
const
GrFragmentProcessor
*
true
>
fFPStack
;
}
;
template
<
typename
T
typename
BASE
int
(
BASE
:
:
*
COUNT
)
(
)
const
const
T
&
(
BASE
:
:
*
GET
)
(
int
)
const
>
class
FPItemIter
:
public
SkNoncopyable
{
public
:
explicit
FPItemIter
(
const
GrFragmentProcessor
*
fp
)
:
fCurrFP
(
nullptr
)
fCTIdx
(
0
)
fFPIter
(
fp
)
{
fCurrFP
=
fFPIter
.
next
(
)
;
}
explicit
FPItemIter
(
const
GrPipeline
&
pipeline
)
:
fCurrFP
(
nullptr
)
fCTIdx
(
0
)
fFPIter
(
pipeline
)
{
fCurrFP
=
fFPIter
.
next
(
)
;
}
const
T
*
next
(
)
{
if
(
!
fCurrFP
)
{
return
nullptr
;
}
while
(
fCTIdx
=
=
(
fCurrFP
-
>
*
COUNT
)
(
)
)
{
fCTIdx
=
0
;
fCurrFP
=
fFPIter
.
next
(
)
;
if
(
!
fCurrFP
)
{
return
nullptr
;
}
}
return
&
(
fCurrFP
-
>
*
GET
)
(
fCTIdx
+
+
)
;
}
private
:
const
GrFragmentProcessor
*
fCurrFP
;
int
fCTIdx
;
GrFragmentProcessor
:
:
Iter
fFPIter
;
}
;
using
CoordTransformIter
=
FPItemIter
<
GrCoordTransform
GrFragmentProcessor
&
GrFragmentProcessor
:
:
numCoordTransforms
&
GrFragmentProcessor
:
:
coordTransform
>
;
using
TextureAccessIter
=
FPItemIter
<
TextureSampler
GrResourceIOProcessor
&
GrResourceIOProcessor
:
:
numTextureSamplers
&
GrResourceIOProcessor
:
:
textureSampler
>
;
protected
:
enum
OptimizationFlags
:
uint32_t
{
kNone_OptimizationFlags
kCompatibleWithCoverageAsAlpha_OptimizationFlag
=
0x1
kPreservesOpaqueInput_OptimizationFlag
=
0x2
kConstantOutputForConstantInput_OptimizationFlag
=
0x4
kAll_OptimizationFlags
=
kCompatibleWithCoverageAsAlpha_OptimizationFlag
|
kPreservesOpaqueInput_OptimizationFlag
|
kConstantOutputForConstantInput_OptimizationFlag
}
;
GR_DECL_BITFIELD_OPS_FRIENDS
(
OptimizationFlags
)
GrFragmentProcessor
(
OptimizationFlags
optimizationFlags
)
:
fFlags
(
optimizationFlags
)
{
SkASSERT
(
(
fFlags
&
~
kAll_OptimizationFlags
)
=
=
0
)
;
}
OptimizationFlags
optimizationFlags
(
)
const
{
return
static_cast
<
OptimizationFlags
>
(
kAll_OptimizationFlags
&
fFlags
)
;
}
static
GrColor4f
ConstantOutputForConstantInput
(
const
GrFragmentProcessor
&
fp
GrColor4f
input
)
{
SkASSERT
(
fp
.
hasConstantOutputForConstantInput
(
)
)
;
return
fp
.
constantOutputForConstantInput
(
input
)
;
}
void
addCoordTransform
(
const
GrCoordTransform
*
)
;
int
registerChildProcessor
(
sk_sp
<
GrFragmentProcessor
>
child
)
;
void
setWillUseDistanceVectorField
(
)
{
fFlags
|
=
kUsesDistanceVectorField_Flag
;
}
private
:
void
addPendingIOs
(
)
const
override
{
GrResourceIOProcessor
:
:
addPendingIOs
(
)
;
}
void
removeRefs
(
)
const
override
{
GrResourceIOProcessor
:
:
removeRefs
(
)
;
}
void
pendingIOComplete
(
)
const
override
{
GrResourceIOProcessor
:
:
pendingIOComplete
(
)
;
}
void
notifyRefCntIsZero
(
)
const
final
;
virtual
GrColor4f
constantOutputForConstantInput
(
GrColor4f
)
const
{
SkFAIL
(
"
Subclass
must
override
this
if
advertising
this
optimization
.
"
)
;
return
GrColor4f
:
:
TransparentBlack
(
)
;
}
virtual
GrGLSLFragmentProcessor
*
onCreateGLSLInstance
(
)
const
=
0
;
virtual
void
onGetGLSLProcessorKey
(
const
GrShaderCaps
&
GrProcessorKeyBuilder
*
)
const
=
0
;
virtual
bool
onIsEqual
(
const
GrFragmentProcessor
&
)
const
=
0
;
bool
hasSameTransforms
(
const
GrFragmentProcessor
&
)
const
;
enum
PrivateFlags
{
kFirstPrivateFlag
=
kAll_OptimizationFlags
+
1
kUsesLocalCoords_Flag
=
kFirstPrivateFlag
kUsesDistanceVectorField_Flag
=
kFirstPrivateFlag
<
<
1
}
;
mutable
uint32_t
fFlags
=
0
;
SkSTArray
<
4
const
GrCoordTransform
*
true
>
fCoordTransforms
;
SkSTArray
<
1
GrFragmentProcessor
*
true
>
fChildProcessors
;
typedef
GrProcessor
INHERITED
;
}
;
GR_MAKE_BITFIELD_OPS
(
GrFragmentProcessor
:
:
OptimizationFlags
)
#
endif
