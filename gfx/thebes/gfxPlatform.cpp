#
include
"
mozilla
/
FontPropertyTypes
.
h
"
#
include
"
mozilla
/
RDDProcessManager
.
h
"
#
include
"
mozilla
/
image
/
ImageMemoryReporter
.
h
"
#
include
"
mozilla
/
layers
/
CompositorManagerChild
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
webrender
/
RenderThread
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
mozilla
/
webrender
/
webrender_ffi
.
h
"
#
include
"
mozilla
/
layers
/
PaintThread
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessManager
.
h
"
#
include
"
mozilla
/
gfx
/
GraphicsMessages
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
gfxCrashReporterUtils
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
gfxEnv
.
h
"
#
include
"
gfxTextRun
.
h
"
#
include
"
gfxUserFontSet
.
h
"
#
include
"
gfxConfig
.
h
"
#
include
"
VRProcessManager
.
h
"
#
include
"
VRThread
.
h
"
#
ifdef
XP_WIN
#
include
<
process
.
h
>
#
define
getpid
_getpid
#
else
#
include
<
unistd
.
h
>
#
endif
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
gfxWindowsPlatform
.
h
"
#
elif
defined
(
XP_MACOSX
)
#
include
"
gfxPlatformMac
.
h
"
#
include
"
gfxQuartzSurface
.
h
"
#
include
"
nsCocoaFeatures
.
h
"
#
elif
defined
(
MOZ_WIDGET_GTK
)
#
include
"
gfxPlatformGtk
.
h
"
#
elif
defined
(
ANDROID
)
#
include
"
gfxAndroidPlatform
.
h
"
#
endif
#
if
defined
(
MOZ_WIDGET_ANDROID
)
#
include
"
mozilla
/
jni
/
Utils
.
h
"
#
endif
#
ifdef
XP_WIN
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
mozilla
/
gfx
/
DeviceManagerDx
.
h
"
#
endif
#
include
"
nsGkAtoms
.
h
"
#
include
"
gfxPlatformFontList
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxImageSurface
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
harfbuzz
/
hb
.
h
"
#
include
"
gfxGraphiteShaper
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxGradientCache
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
gfxFontMissingGlyphs
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsUnicodeRange
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
cairo
.
h
"
#
include
"
qcms
.
h
"
#
include
"
imgITools
.
h
"
#
include
"
plstr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
GLContextProvider
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
ifdef
USE_SKIA
#
ifdef
__GNUC__
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wshadow
"
#
endif
#
include
"
skia
/
include
/
core
/
SkGraphics
.
h
"
#
ifdef
USE_SKIA_GPU
#
include
"
skia
/
include
/
gpu
/
GrContext
.
h
"
#
include
"
skia
/
include
/
gpu
/
gl
/
GrGLInterface
.
h
"
#
include
"
SkiaGLGlue
.
h
"
#
endif
#
ifdef
MOZ_ENABLE_FREETYPE
#
include
"
skia
/
include
/
ports
/
SkTypeface_cairo
.
h
"
#
endif
#
include
"
mozilla
/
gfx
/
SkMemoryReporter
.
h
"
#
ifdef
__GNUC__
#
pragma
GCC
diagnostic
pop
/
/
-
Wshadow
#
endif
static
const
uint32_t
kDefaultGlyphCacheSize
=
-
1
;
#
endif
#
if
!
defined
(
USE_SKIA
)
|
|
!
defined
(
USE_SKIA_GPU
)
class
mozilla
:
:
gl
:
:
SkiaGLGlue
:
public
GenericAtomicRefCounted
{
}
;
#
endif
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsIGfxInfo
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
VsyncSource
.
h
"
#
include
"
SoftwareVsyncSource
.
h
"
#
include
"
nscore
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
TouchEvent
.
h
"
#
include
"
gfxVR
.
h
"
#
include
"
VRManagerChild
.
h
"
#
include
"
mozilla
/
gfx
/
GPUParent
.
h
"
#
include
"
mozilla
/
layers
/
MemoryReportingMLGPU
.
h
"
#
include
"
prsystem
.
h
"
namespace
mozilla
{
namespace
layers
{
void
ShutdownTileCache
(
)
;
}
}
using
namespace
mozilla
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
gl
;
using
namespace
mozilla
:
:
gfx
;
gfxPlatform
*
gPlatform
=
nullptr
;
static
bool
gEverInitialized
=
false
;
static
int32_t
gLastUsedFrameRate
=
-
1
;
const
ContentDeviceData
*
gContentDeviceInitData
=
nullptr
;
static
Mutex
*
gGfxPlatformPrefsLock
=
nullptr
;
static
qcms_profile
*
gCMSOutputProfile
=
nullptr
;
static
qcms_profile
*
gCMSsRGBProfile
=
nullptr
;
static
bool
gCMSRGBTransformFailed
=
false
;
static
qcms_transform
*
gCMSRGBTransform
=
nullptr
;
static
qcms_transform
*
gCMSInverseRGBTransform
=
nullptr
;
static
qcms_transform
*
gCMSRGBATransform
=
nullptr
;
static
bool
gCMSInitialized
=
false
;
static
eCMSMode
gCMSMode
=
eCMSMode_Off
;
static
void
ShutdownCMS
(
)
;
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
SourceSurfaceCairo
.
h
"
using
namespace
mozilla
:
:
gfx
;
class
SRGBOverrideObserver
final
:
public
nsIObserver
public
nsSupportsWeakReference
{
~
SRGBOverrideObserver
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
}
;
class
CrashStatsLogForwarder
:
public
mozilla
:
:
gfx
:
:
LogForwarder
{
public
:
explicit
CrashStatsLogForwarder
(
CrashReporter
:
:
Annotation
aKey
)
;
void
Log
(
const
std
:
:
string
&
aString
)
override
;
void
CrashAction
(
LogReason
aReason
)
override
;
bool
UpdateStringsVector
(
const
std
:
:
string
&
aString
)
override
;
LoggingRecord
LoggingRecordCopy
(
)
override
;
void
SetCircularBufferSize
(
uint32_t
aCapacity
)
;
private
:
void
UpdateCrashReport
(
)
;
private
:
LoggingRecord
mBuffer
;
CrashReporter
:
:
Annotation
mCrashCriticalKey
;
uint32_t
mMaxCapacity
;
int32_t
mIndex
;
Mutex
mMutex
;
}
;
CrashStatsLogForwarder
:
:
CrashStatsLogForwarder
(
CrashReporter
:
:
Annotation
aKey
)
:
mBuffer
(
)
mCrashCriticalKey
(
aKey
)
mMaxCapacity
(
0
)
mIndex
(
-
1
)
mMutex
(
"
CrashStatsLogForwarder
"
)
{
}
void
CrashStatsLogForwarder
:
:
SetCircularBufferSize
(
uint32_t
aCapacity
)
{
MutexAutoLock
lock
(
mMutex
)
;
mMaxCapacity
=
aCapacity
;
mBuffer
.
reserve
(
static_cast
<
size_t
>
(
aCapacity
)
)
;
}
LoggingRecord
CrashStatsLogForwarder
:
:
LoggingRecordCopy
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mBuffer
;
}
bool
CrashStatsLogForwarder
:
:
UpdateStringsVector
(
const
std
:
:
string
&
aString
)
{
if
(
mMaxCapacity
<
2
)
{
return
false
;
}
mIndex
+
=
1
;
MOZ_ASSERT
(
mIndex
>
=
0
)
;
int32_t
index
=
mIndex
?
(
mIndex
-
1
)
%
(
mMaxCapacity
-
1
)
+
1
:
0
;
MOZ_ASSERT
(
index
>
=
0
&
&
index
<
(
int32_t
)
mMaxCapacity
)
;
MOZ_ASSERT
(
index
<
=
mIndex
&
&
index
<
=
(
int32_t
)
mBuffer
.
size
(
)
)
;
double
tStamp
=
(
TimeStamp
:
:
NowLoRes
(
)
-
TimeStamp
:
:
ProcessCreation
(
)
)
.
ToSecondsSigDigits
(
)
;
LoggingRecordEntry
newEntry
(
mIndex
aString
tStamp
)
;
if
(
index
>
=
static_cast
<
int32_t
>
(
mBuffer
.
size
(
)
)
)
{
mBuffer
.
push_back
(
newEntry
)
;
}
else
{
mBuffer
[
index
]
=
newEntry
;
}
return
true
;
}
void
CrashStatsLogForwarder
:
:
UpdateCrashReport
(
)
{
std
:
:
stringstream
message
;
std
:
:
string
logAnnotation
;
switch
(
XRE_GetProcessType
(
)
)
{
case
GeckoProcessType_Default
:
logAnnotation
=
"
|
[
"
;
break
;
case
GeckoProcessType_Content
:
logAnnotation
=
"
|
[
C
"
;
break
;
case
GeckoProcessType_GPU
:
logAnnotation
=
"
|
[
G
"
;
break
;
default
:
logAnnotation
=
"
|
[
X
"
;
break
;
}
for
(
auto
&
it
:
mBuffer
)
{
message
<
<
logAnnotation
<
<
Get
<
0
>
(
it
)
<
<
"
]
"
<
<
Get
<
1
>
(
it
)
<
<
"
(
t
=
"
<
<
Get
<
2
>
(
it
)
<
<
"
)
"
;
}
nsCString
reportString
(
message
.
str
(
)
.
c_str
(
)
)
;
nsresult
annotated
=
CrashReporter
:
:
AnnotateCrashReport
(
mCrashCriticalKey
reportString
)
;
if
(
annotated
!
=
NS_OK
)
{
printf
(
"
Crash
Annotation
%
s
:
%
s
"
CrashReporter
:
:
AnnotationToString
(
mCrashCriticalKey
)
message
.
str
(
)
.
c_str
(
)
)
;
}
}
class
LogForwarderEvent
:
public
Runnable
{
~
LogForwarderEvent
(
)
override
=
default
;
public
:
NS_INLINE_DECL_REFCOUNTING_INHERITED
(
LogForwarderEvent
Runnable
)
explicit
LogForwarderEvent
(
const
nsCString
&
aMessage
)
:
mozilla
:
:
Runnable
(
"
LogForwarderEvent
"
)
mMessage
(
aMessage
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
&
&
(
XRE_IsContentProcess
(
)
|
|
XRE_IsGPUProcess
(
)
)
)
;
if
(
XRE_IsContentProcess
(
)
)
{
dom
:
:
ContentChild
*
cc
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
Unused
<
<
cc
-
>
SendGraphicsError
(
mMessage
)
;
}
else
if
(
XRE_IsGPUProcess
(
)
)
{
GPUParent
*
gp
=
GPUParent
:
:
GetSingleton
(
)
;
Unused
<
<
gp
-
>
SendGraphicsError
(
mMessage
)
;
}
return
NS_OK
;
}
protected
:
nsCString
mMessage
;
}
;
void
CrashStatsLogForwarder
:
:
Log
(
const
std
:
:
string
&
aString
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
UpdateStringsVector
(
aString
)
)
{
UpdateCrashReport
(
)
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
nsCString
stringToSend
(
aString
.
c_str
(
)
)
;
if
(
NS_IsMainThread
(
)
)
{
if
(
XRE_IsContentProcess
(
)
)
{
dom
:
:
ContentChild
*
cc
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
Unused
<
<
cc
-
>
SendGraphicsError
(
stringToSend
)
;
}
else
if
(
XRE_IsGPUProcess
(
)
)
{
GPUParent
*
gp
=
GPUParent
:
:
GetSingleton
(
)
;
Unused
<
<
gp
-
>
SendGraphicsError
(
stringToSend
)
;
}
}
else
{
nsCOMPtr
<
nsIRunnable
>
r1
=
new
LogForwarderEvent
(
stringToSend
)
;
NS_DispatchToMainThread
(
r1
)
;
}
}
}
class
CrashTelemetryEvent
:
public
Runnable
{
~
CrashTelemetryEvent
(
)
override
=
default
;
public
:
NS_INLINE_DECL_REFCOUNTING_INHERITED
(
CrashTelemetryEvent
Runnable
)
explicit
CrashTelemetryEvent
(
uint32_t
aReason
)
:
mozilla
:
:
Runnable
(
"
CrashTelemetryEvent
"
)
mReason
(
aReason
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GFX_CRASH
mReason
)
;
return
NS_OK
;
}
protected
:
uint32_t
mReason
;
}
;
void
CrashStatsLogForwarder
:
:
CrashAction
(
LogReason
aReason
)
{
#
ifndef
RELEASE_OR_BETA
static
bool
useTelemetry
=
gfxEnv
:
:
GfxDevCrashTelemetry
(
)
;
#
else
static
bool
useTelemetry
=
!
gfxEnv
:
:
GfxDevCrashMozCrash
(
)
;
#
endif
if
(
useTelemetry
)
{
if
(
NS_IsMainThread
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GFX_CRASH
(
uint32_t
)
aReason
)
;
}
else
{
nsCOMPtr
<
nsIRunnable
>
r1
=
new
CrashTelemetryEvent
(
(
uint32_t
)
aReason
)
;
NS_DispatchToMainThread
(
r1
)
;
}
}
else
{
MOZ_CRASH
(
"
GFX_CRASH
"
)
;
}
}
NS_IMPL_ISUPPORTS
(
SRGBOverrideObserver
nsIObserver
nsISupportsWeakReference
)
#
define
GFX_DOWNLOADABLE_FONTS_ENABLED
"
gfx
.
downloadable_fonts
.
enabled
"
#
define
GFX_PREF_FALLBACK_USE_CMAPS
\
"
gfx
.
font_rendering
.
fallback
.
always_use_cmaps
"
#
define
GFX_PREF_OPENTYPE_SVG
"
gfx
.
font_rendering
.
opentype_svg
.
enabled
"
#
define
GFX_PREF_WORD_CACHE_CHARLIMIT
"
gfx
.
font_rendering
.
wordcache
.
charlimit
"
#
define
GFX_PREF_WORD_CACHE_MAXENTRIES
"
gfx
.
font_rendering
.
wordcache
.
maxentries
"
#
define
GFX_PREF_GRAPHITE_SHAPING
"
gfx
.
font_rendering
.
graphite
.
enabled
"
#
define
BIDI_NUMERAL_PREF
"
bidi
.
numeral
"
#
define
GFX_PREF_CMS_FORCE_SRGB
"
gfx
.
color_management
.
force_srgb
"
#
define
FONT_VARIATIONS_PREF
"
layout
.
css
.
font
-
variations
.
enabled
"
NS_IMETHODIMP
SRGBOverrideObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
someData
)
{
NS_ASSERTION
(
NS_strcmp
(
someData
(
u
"
"
GFX_PREF_CMS_FORCE_SRGB
)
)
=
=
0
"
Restarting
CMS
on
wrong
pref
!
"
)
;
ShutdownCMS
(
)
;
gfxPlatform
:
:
CreateCMSOutputProfile
(
)
;
return
NS_OK
;
}
static
const
char
*
kObservedPrefs
[
]
=
{
"
gfx
.
downloadable_fonts
.
"
"
gfx
.
font_rendering
.
"
BIDI_NUMERAL_PREF
nullptr
}
;
static
void
FontPrefChanged
(
const
char
*
aPref
void
*
aData
)
{
MOZ_ASSERT
(
aPref
)
;
NS_ASSERTION
(
gfxPlatform
:
:
GetPlatform
(
)
"
the
singleton
instance
has
gone
"
)
;
gfxPlatform
:
:
GetPlatform
(
)
-
>
FontsPrefsChanged
(
aPref
)
;
}
void
gfxPlatform
:
:
OnMemoryPressure
(
layers
:
:
MemoryPressureReason
aWhy
)
{
Factory
:
:
PurgeAllCaches
(
)
;
gfxGradientCache
:
:
PurgeAllCaches
(
)
;
gfxFontMissingGlyphs
:
:
Purge
(
)
;
PurgeSkiaFontCache
(
)
;
PurgeSkiaGPUCache
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
layers
:
:
CompositorManagerChild
*
manager
=
CompositorManagerChild
:
:
GetInstance
(
)
;
if
(
manager
)
{
manager
-
>
SendNotifyMemoryPressure
(
)
;
}
}
}
gfxPlatform
:
:
gfxPlatform
(
)
:
mHasVariationFontSupport
(
false
)
mAzureCanvasBackendCollector
(
this
&
gfxPlatform
:
:
GetAzureBackendInfo
)
mApzSupportCollector
(
this
&
gfxPlatform
:
:
GetApzSupportInfo
)
mTilesInfoCollector
(
this
&
gfxPlatform
:
:
GetTilesSupportInfo
)
mFrameStatsCollector
(
this
&
gfxPlatform
:
:
GetFrameStats
)
mCompositorBackend
(
layers
:
:
LayersBackend
:
:
LAYERS_NONE
)
mScreenDepth
(
0
)
{
mAllowDownloadableFonts
=
UNINITIALIZED_VALUE
;
mFallbackUsesCmaps
=
UNINITIALIZED_VALUE
;
mWordCacheCharLimit
=
UNINITIALIZED_VALUE
;
mWordCacheMaxEntries
=
UNINITIALIZED_VALUE
;
mGraphiteShapingEnabled
=
UNINITIALIZED_VALUE
;
mOpenTypeSVGEnabled
=
UNINITIALIZED_VALUE
;
mBidiNumeralOption
=
UNINITIALIZED_VALUE
;
mSkiaGlue
=
nullptr
;
InitBackendPrefs
(
GetBackendPrefs
(
)
)
;
mTotalSystemMemory
=
PR_GetPhysicalMemorySize
(
)
;
VRManager
:
:
ManagerInit
(
)
;
}
gfxPlatform
*
gfxPlatform
:
:
GetPlatform
(
)
{
if
(
!
gPlatform
)
{
MOZ_RELEASE_ASSERT
(
!
XRE_IsContentProcess
(
)
"
Content
Process
should
have
called
InitChild
(
)
before
"
"
first
GetPlatform
(
)
"
)
;
Init
(
)
;
}
return
gPlatform
;
}
bool
gfxPlatform
:
:
Initialized
(
)
{
return
!
!
gPlatform
;
}
void
gfxPlatform
:
:
InitChild
(
const
ContentDeviceData
&
aData
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
gPlatform
"
InitChild
(
)
should
be
called
before
first
GetPlatform
(
)
"
)
;
gContentDeviceInitData
=
&
aData
;
Init
(
)
;
gContentDeviceInitData
=
nullptr
;
}
void
RecordingPrefChanged
(
const
char
*
aPrefName
void
*
aClosure
)
{
if
(
Preferences
:
:
GetBool
(
"
gfx
.
2d
.
recording
"
false
)
)
{
nsAutoCString
fileName
;
nsAutoString
prefFileName
;
nsresult
rv
=
Preferences
:
:
GetString
(
"
gfx
.
2d
.
recordingfile
"
prefFileName
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
CopyUTF16toUTF8
(
prefFileName
fileName
)
;
}
else
{
nsCOMPtr
<
nsIFile
>
tmpFile
;
if
(
NS_FAILED
(
NS_GetSpecialDirectory
(
NS_OS_TEMP_DIR
getter_AddRefs
(
tmpFile
)
)
)
)
{
return
;
}
fileName
.
AppendPrintf
(
"
moz2drec_
%
i_
%
i
.
aer
"
XRE_GetProcessType
(
)
getpid
(
)
)
;
nsresult
rv
=
tmpFile
-
>
AppendNative
(
fileName
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
#
ifdef
XP_WIN
rv
=
tmpFile
-
>
GetPath
(
prefFileName
)
;
CopyUTF16toUTF8
(
prefFileName
fileName
)
;
#
else
rv
=
tmpFile
-
>
GetNativePath
(
fileName
)
;
#
endif
if
(
NS_FAILED
(
rv
)
)
return
;
}
#
ifdef
XP_WIN
gPlatform
-
>
mRecorder
=
Factory
:
:
CreateEventRecorderForFile
(
prefFileName
.
BeginReading
(
)
)
;
#
else
gPlatform
-
>
mRecorder
=
Factory
:
:
CreateEventRecorderForFile
(
fileName
.
BeginReading
(
)
)
;
#
endif
printf_stderr
(
"
Recording
to
%
s
\
n
"
fileName
.
get
(
)
)
;
Factory
:
:
SetGlobalEventRecorder
(
gPlatform
-
>
mRecorder
)
;
}
else
{
Factory
:
:
SetGlobalEventRecorder
(
nullptr
)
;
}
}
#
define
WR_DEBUG_PREF
"
gfx
.
webrender
.
debug
"
void
WebRenderDebugPrefChangeCallback
(
const
char
*
aPrefName
void
*
)
{
int32_t
flags
=
0
;
#
define
GFX_WEBRENDER_DEBUG
(
suffix
bit
)
\
if
(
Preferences
:
:
GetBool
(
WR_DEBUG_PREF
suffix
false
)
)
{
\
flags
|
=
(
bit
)
;
\
}
GFX_WEBRENDER_DEBUG
(
"
.
profiler
"
1
<
<
0
)
GFX_WEBRENDER_DEBUG
(
"
.
render
-
targets
"
1
<
<
1
)
GFX_WEBRENDER_DEBUG
(
"
.
texture
-
cache
"
1
<
<
2
)
GFX_WEBRENDER_DEBUG
(
"
.
gpu
-
time
-
queries
"
1
<
<
3
)
GFX_WEBRENDER_DEBUG
(
"
.
gpu
-
sample
-
queries
"
1
<
<
4
)
GFX_WEBRENDER_DEBUG
(
"
.
disable
-
batching
"
1
<
<
5
)
GFX_WEBRENDER_DEBUG
(
"
.
epochs
"
1
<
<
6
)
GFX_WEBRENDER_DEBUG
(
"
.
compact
-
profiler
"
1
<
<
7
)
GFX_WEBRENDER_DEBUG
(
"
.
echo
-
driver
-
messages
"
1
<
<
8
)
GFX_WEBRENDER_DEBUG
(
"
.
new
-
frame
-
indicator
"
1
<
<
9
)
GFX_WEBRENDER_DEBUG
(
"
.
new
-
scene
-
indicator
"
1
<
<
10
)
GFX_WEBRENDER_DEBUG
(
"
.
show
-
overdraw
"
1
<
<
11
)
GFX_WEBRENDER_DEBUG
(
"
.
gpu
-
cache
"
1
<
<
12
)
GFX_WEBRENDER_DEBUG
(
"
.
slow
-
frame
-
indicator
"
1
<
<
13
)
GFX_WEBRENDER_DEBUG
(
"
.
texture
-
cache
.
clear
-
evicted
"
1
<
<
14
)
GFX_WEBRENDER_DEBUG
(
"
.
picture
-
caching
"
1
<
<
15
)
GFX_WEBRENDER_DEBUG
(
"
.
texture
-
cache
.
disable
-
shrink
"
1
<
<
16
)
GFX_WEBRENDER_DEBUG
(
"
.
primitives
"
1
<
<
17
)
#
undef
GFX_WEBRENDER_DEBUG
gfx
:
:
gfxVars
:
:
SetWebRenderDebugFlags
(
flags
)
;
}
#
if
defined
(
USE_SKIA
)
static
uint32_t
GetSkiaGlyphCacheSize
(
)
{
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
uint32_t
cacheSize
=
gfxPrefs
:
:
SkiaContentFontCacheSize
(
)
*
1024
*
1024
;
if
(
mozilla
:
:
BrowserTabsRemoteAutostart
(
)
)
{
return
XRE_IsContentProcess
(
)
?
cacheSize
:
kDefaultGlyphCacheSize
;
}
return
cacheSize
;
#
else
return
kDefaultGlyphCacheSize
;
#
endif
}
#
endif
class
WebRenderMemoryReporter
final
:
public
nsIMemoryReporter
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIMEMORYREPORTER
private
:
~
WebRenderMemoryReporter
(
)
=
default
;
}
;
struct
WebRenderMemoryReporterHelper
{
WebRenderMemoryReporterHelper
(
nsIHandleReportCallback
*
aCallback
nsISupports
*
aData
)
:
mCallback
(
aCallback
)
mData
(
aData
)
{
}
nsCOMPtr
<
nsIHandleReportCallback
>
mCallback
;
nsCOMPtr
<
nsISupports
>
mData
;
void
Report
(
size_t
aBytes
const
char
*
aName
)
const
{
nsPrintfCString
path
(
"
explicit
/
gfx
/
webrender
/
%
s
"
aName
)
;
nsCString
desc
(
NS_LITERAL_CSTRING
(
"
CPU
heap
memory
used
by
WebRender
"
)
)
;
ReportInternal
(
aBytes
path
desc
nsIMemoryReporter
:
:
KIND_HEAP
)
;
}
void
ReportTexture
(
size_t
aBytes
const
char
*
aName
)
const
{
nsPrintfCString
path
(
"
gfx
/
webrender
/
textures
/
%
s
"
aName
)
;
nsCString
desc
(
NS_LITERAL_CSTRING
(
"
GPU
texture
memory
used
by
WebRender
"
)
)
;
ReportInternal
(
aBytes
path
desc
nsIMemoryReporter
:
:
KIND_OTHER
)
;
}
void
ReportTotalGPUBytes
(
size_t
aBytes
)
const
{
nsCString
path
(
NS_LITERAL_CSTRING
(
"
gfx
/
webrender
/
total
-
gpu
-
bytes
"
)
)
;
nsCString
desc
(
NS_LITERAL_CSTRING
(
"
Total
GPU
bytes
used
by
WebRender
(
should
match
textures
/
sum
)
"
)
)
;
ReportInternal
(
aBytes
path
desc
nsIMemoryReporter
:
:
KIND_OTHER
)
;
}
void
ReportInternal
(
size_t
aBytes
nsACString
&
aPath
nsACString
&
aDesc
int32_t
aKind
)
const
{
nsAutoCString
processName
;
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
)
{
GPUParent
:
:
GetGPUProcessName
(
processName
)
;
}
mCallback
-
>
Callback
(
processName
aPath
aKind
nsIMemoryReporter
:
:
UNITS_BYTES
aBytes
aDesc
mData
)
;
}
}
;
static
void
FinishAsyncMemoryReport
(
)
{
nsCOMPtr
<
nsIMemoryReporterManager
>
imgr
=
do_GetService
(
"
mozilla
.
org
/
memory
-
reporter
-
manager
;
1
"
)
;
if
(
imgr
)
{
imgr
-
>
EndReport
(
)
;
}
}
#
define
REPORT_INTERNER
(
id
)
\
helper
.
Report
(
aReport
.
interning
.
interners
.
id
\
"
interning
/
"
#
id
"
/
interners
"
)
;
#
define
REPORT_DATA_STORE
(
id
)
\
helper
.
Report
(
aReport
.
interning
.
data_stores
.
id
\
"
interning
/
"
#
id
"
/
data
-
stores
"
)
;
NS_IMPL_ISUPPORTS
(
WebRenderMemoryReporter
nsIMemoryReporter
)
NS_IMETHODIMP
WebRenderMemoryReporter
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
layers
:
:
CompositorManagerChild
*
manager
=
CompositorManagerChild
:
:
GetInstance
(
)
;
if
(
!
manager
)
{
FinishAsyncMemoryReport
(
)
;
return
NS_OK
;
}
WebRenderMemoryReporterHelper
helper
(
aHandleReport
aData
)
;
manager
-
>
SendReportMemory
(
[
=
]
(
wr
:
:
MemoryReport
aReport
)
{
helper
.
Report
(
aReport
.
clip_stores
"
clip
-
stores
"
)
;
helper
.
Report
(
aReport
.
gpu_cache_metadata
"
gpu
-
cache
/
metadata
"
)
;
helper
.
Report
(
aReport
.
gpu_cache_cpu_mirror
"
gpu
-
cache
/
cpu
-
mirror
"
)
;
helper
.
Report
(
aReport
.
render_tasks
"
render
-
tasks
"
)
;
helper
.
Report
(
aReport
.
hit_testers
"
hit
-
testers
"
)
;
helper
.
Report
(
aReport
.
fonts
"
resource
-
cache
/
fonts
"
)
;
helper
.
Report
(
aReport
.
images
"
resource
-
cache
/
images
"
)
;
helper
.
Report
(
aReport
.
rasterized_blobs
"
resource
-
cache
/
rasterized
-
blobs
"
)
;
helper
.
Report
(
aReport
.
shader_cache
"
shader
-
cache
"
)
;
WEBRENDER_FOR_EACH_INTERNER
(
REPORT_INTERNER
)
;
WEBRENDER_FOR_EACH_INTERNER
(
REPORT_DATA_STORE
)
;
helper
.
ReportTexture
(
aReport
.
gpu_cache_textures
"
gpu
-
cache
"
)
;
helper
.
ReportTexture
(
aReport
.
vertex_data_textures
"
vertex
-
data
"
)
;
helper
.
ReportTexture
(
aReport
.
render_target_textures
"
render
-
targets
"
)
;
helper
.
ReportTexture
(
aReport
.
texture_cache_textures
"
texture
-
cache
"
)
;
helper
.
ReportTexture
(
aReport
.
depth_target_textures
"
depth
-
targets
"
)
;
helper
.
ReportTexture
(
aReport
.
swap_chain
"
swap
-
chains
"
)
;
FinishAsyncMemoryReport
(
)
;
}
[
]
(
mozilla
:
:
ipc
:
:
ResponseRejectReason
&
&
aReason
)
{
FinishAsyncMemoryReport
(
)
;
}
)
;
return
NS_OK
;
}
#
undef
REPORT_INTERNER
#
undef
REPORT_DATA_STORE
static
const
char
*
const
WR_ROLLOUT_PREF
=
"
gfx
.
webrender
.
all
.
qualified
"
;
static
const
char
*
const
WR_ROLLOUT_PREF_DEFAULT
=
"
gfx
.
webrender
.
all
.
qualified
.
default
"
;
static
const
char
*
const
WR_ROLLOUT_PREF_OVERRIDE
=
"
gfx
.
webrender
.
all
.
qualified
.
gfxPref
-
default
-
override
"
;
static
const
char
*
const
WR_ROLLOUT_HW_QUALIFIED_OVERRIDE
=
"
gfx
.
webrender
.
all
.
qualified
.
hardware
-
override
"
;
static
const
char
*
const
PROFILE_BEFORE_CHANGE_TOPIC
=
"
profile
-
before
-
change
"
;
class
WrRolloutPrefShutdownSaver
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_IMETHOD
Observe
(
nsISupports
*
const
char
*
aTopic
const
char16_t
*
)
override
{
if
(
strcmp
(
PROFILE_BEFORE_CHANGE_TOPIC
aTopic
)
!
=
0
)
{
return
NS_OK
;
}
SaveRolloutPref
(
)
;
RefPtr
<
WrRolloutPrefShutdownSaver
>
kungFuDeathGrip
(
this
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
observerService
)
)
{
return
NS_ERROR_FAILURE
;
}
observerService
-
>
RemoveObserver
(
this
PROFILE_BEFORE_CHANGE_TOPIC
)
;
return
NS_OK
;
}
static
void
AddShutdownObserver
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
observerService
)
)
{
return
;
}
RefPtr
<
WrRolloutPrefShutdownSaver
>
wrRolloutSaver
=
new
WrRolloutPrefShutdownSaver
(
)
;
observerService
-
>
AddObserver
(
wrRolloutSaver
PROFILE_BEFORE_CHANGE_TOPIC
false
)
;
}
private
:
virtual
~
WrRolloutPrefShutdownSaver
(
)
=
default
;
void
SaveRolloutPref
(
)
{
if
(
Preferences
:
:
HasUserValue
(
WR_ROLLOUT_PREF
)
|
|
Preferences
:
:
GetType
(
WR_ROLLOUT_PREF
)
=
=
nsIPrefBranch
:
:
PREF_INVALID
)
{
return
;
}
bool
defaultValue
=
Preferences
:
:
GetBool
(
WR_ROLLOUT_PREF
false
PrefValueKind
:
:
Default
)
;
Preferences
:
:
SetBool
(
WR_ROLLOUT_PREF_DEFAULT
defaultValue
)
;
}
}
;
NS_IMPL_ISUPPORTS
(
WrRolloutPrefShutdownSaver
nsIObserver
)
void
gfxPlatform
:
:
Init
(
)
{
MOZ_RELEASE_ASSERT
(
!
XRE_IsGPUProcess
(
)
"
GFX
:
Not
allowed
in
GPU
process
.
"
)
;
MOZ_RELEASE_ASSERT
(
!
XRE_IsRDDProcess
(
)
"
GFX
:
Not
allowed
in
RDD
process
.
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
"
GFX
:
Not
in
main
thread
.
"
)
;
if
(
gEverInitialized
)
{
MOZ_CRASH
(
"
Already
started
?
?
?
"
)
;
}
gEverInitialized
=
true
;
gfxPrefs
:
:
GetSingleton
(
)
;
gfxVars
:
:
Initialize
(
)
;
gfxConfig
:
:
Init
(
)
;
if
(
XRE_IsParentProcess
(
)
|
|
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
GPUProcessManager
:
:
Initialize
(
)
;
RDDProcessManager
:
:
Initialize
(
)
;
if
(
Preferences
:
:
GetBool
(
"
media
.
wmf
.
skip
-
blacklist
"
)
)
{
gfxVars
:
:
SetPDMWMFDisableD3D11Dlls
(
nsCString
(
)
)
;
gfxVars
:
:
SetPDMWMFDisableD3D9Dlls
(
nsCString
(
)
)
;
}
else
{
nsAutoCString
d3d11
;
Preferences
:
:
GetCString
(
"
media
.
wmf
.
disable
-
d3d11
-
for
-
dlls
"
d3d11
)
;
gfxVars
:
:
SetPDMWMFDisableD3D11Dlls
(
d3d11
)
;
nsAutoCString
d3d9
;
Preferences
:
:
GetCString
(
"
media
.
wmf
.
disable
-
d3d9
-
for
-
dlls
"
d3d9
)
;
gfxVars
:
:
SetPDMWMFDisableD3D9Dlls
(
d3d9
)
;
}
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_GRE_DIR
getter_AddRefs
(
file
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
gfxVars
:
:
SetGREDirectory
(
nsString
(
)
)
;
}
else
{
nsAutoString
path
;
file
-
>
GetPath
(
path
)
;
gfxVars
:
:
SetGREDirectory
(
nsString
(
path
)
)
;
}
}
if
(
XRE_IsParentProcess
(
)
)
{
WrRolloutPrefShutdownSaver
:
:
AddShutdownObserver
(
)
;
}
{
nsAutoCString
forcedPrefs
;
forcedPrefs
.
AppendPrintf
(
"
FP
(
D
%
d
%
d
"
gfxPrefs
:
:
Direct2DDisabled
(
)
gfxPrefs
:
:
Direct2DForceEnabled
(
)
)
;
forcedPrefs
.
AppendPrintf
(
"
-
L
%
d
%
d
%
d
%
d
"
gfxPrefs
:
:
LayersAMDSwitchableGfxEnabled
(
)
gfxPrefs
:
:
LayersAccelerationDisabledDoNotUseDirectly
(
)
gfxPrefs
:
:
LayersAccelerationForceEnabledDoNotUseDirectly
(
)
gfxPrefs
:
:
LayersD3D11ForceWARP
(
)
)
;
forcedPrefs
.
AppendPrintf
(
"
-
W
%
d
%
d
%
d
%
d
%
d
%
d
%
d
%
d
"
gfxPrefs
:
:
WebGLANGLEForceD3D11
(
)
gfxPrefs
:
:
WebGLANGLEForceWARP
(
)
gfxPrefs
:
:
WebGLDisabled
(
)
gfxPrefs
:
:
WebGLDisableANGLE
(
)
gfxPrefs
:
:
WebGLDXGLEnabled
(
)
gfxPrefs
:
:
WebGLForceEnabled
(
)
gfxPrefs
:
:
WebGLForceLayersReadback
(
)
gfxPrefs
:
:
WebGLForceMSAA
(
)
)
;
forcedPrefs
.
AppendPrintf
(
"
-
T
%
d
%
d
%
d
)
"
gfxPrefs
:
:
AndroidRGB16Force
(
)
gfxPrefs
:
:
CanvasAzureAccelerated
(
)
gfxPrefs
:
:
ForceShmemTiles
(
)
)
;
ScopedGfxFeatureReporter
:
:
AppNote
(
forcedPrefs
)
;
}
InitMoz2DLogging
(
)
;
gGfxPlatformPrefsLock
=
new
Mutex
(
"
gfxPlatform
:
:
gGfxPlatformPrefsLock
"
)
;
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
;
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetDXInterop2Blocked
(
IsDXInterop2Blocked
(
)
)
;
gfxVars
:
:
SetDXNV12Blocked
(
IsDXNV12Blocked
(
)
)
;
gfxVars
:
:
SetDXP010Blocked
(
IsDXP010Blocked
(
)
)
;
gfxVars
:
:
SetDXP016Blocked
(
IsDXP016Blocked
(
)
)
;
}
#
if
defined
(
XP_WIN
)
gPlatform
=
new
gfxWindowsPlatform
;
#
elif
defined
(
XP_MACOSX
)
gPlatform
=
new
gfxPlatformMac
;
#
elif
defined
(
MOZ_WIDGET_GTK
)
gPlatform
=
new
gfxPlatformGtk
;
#
elif
defined
(
ANDROID
)
gPlatform
=
new
gfxAndroidPlatform
;
#
else
#
error
"
No
gfxPlatform
implementation
available
"
#
endif
gPlatform
-
>
InitAcceleration
(
)
;
gPlatform
-
>
InitWebRenderConfig
(
)
;
if
(
!
gfxVars
:
:
UseWebRender
(
)
)
{
gPlatform
-
>
EnsureDevicesInitialized
(
)
;
}
gPlatform
-
>
InitOMTPConfig
(
)
;
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
)
{
GPUProcessManager
*
gpu
=
GPUProcessManager
:
:
Get
(
)
;
gpu
-
>
LaunchGPUProcess
(
)
;
}
gLastUsedFrameRate
=
ForceSoftwareVsync
(
)
?
GetSoftwareVsyncRate
(
)
:
-
1
;
auto
updateFrameRateCallback
=
[
]
(
const
GfxPrefValue
&
aValue
)
-
>
void
{
int32_t
newRate
=
ForceSoftwareVsync
(
)
?
GetSoftwareVsyncRate
(
)
:
-
1
;
if
(
newRate
!
=
gLastUsedFrameRate
)
{
gLastUsedFrameRate
=
newRate
;
ReInitFrameRate
(
)
;
}
}
;
gfxPrefs
:
:
SetLayoutFrameRateChangeCallback
(
updateFrameRateCallback
)
;
gfxPrefs
:
:
SetIsLowEndMachineDoNotUseDirectlyChangeCallback
(
updateFrameRateCallback
)
;
gfxPrefs
:
:
SetAdjustToMachineChangeCallback
(
updateFrameRateCallback
)
;
gfxPrefs
:
:
SetResistFingerprintingChangeCallback
(
updateFrameRateCallback
)
;
ReInitFrameRate
(
)
;
#
ifdef
USE_SKIA
SkGraphics
:
:
Init
(
)
;
#
ifdef
MOZ_ENABLE_FREETYPE
SkInitCairoFT
(
gPlatform
-
>
FontHintingEnabled
(
)
)
;
#
endif
#
endif
InitLayersIPC
(
)
;
gPlatform
-
>
PopulateScreenInfo
(
)
;
gPlatform
-
>
ComputeTileSize
(
)
;
#
ifdef
MOZ_ENABLE_FREETYPE
Factory
:
:
SetFTLibrary
(
gPlatform
-
>
GetFTLibrary
(
)
)
;
#
endif
gPlatform
-
>
mHasVariationFontSupport
=
gPlatform
-
>
CheckVariationFontSupport
(
)
;
nsresult
rv
;
rv
=
gfxPlatformFontList
:
:
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_CRASH
(
"
Could
not
initialize
gfxPlatformFontList
"
)
;
}
gPlatform
-
>
mScreenReferenceSurface
=
gPlatform
-
>
CreateOffscreenSurface
(
IntSize
(
1
1
)
SurfaceFormat
:
:
A8R8G8B8_UINT32
)
;
if
(
!
gPlatform
-
>
mScreenReferenceSurface
)
{
MOZ_CRASH
(
"
Could
not
initialize
mScreenReferenceSurface
"
)
;
}
gPlatform
-
>
mScreenReferenceDrawTarget
=
gPlatform
-
>
CreateOffscreenContentDrawTarget
(
IntSize
(
1
1
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
gPlatform
-
>
mScreenReferenceDrawTarget
|
|
!
gPlatform
-
>
mScreenReferenceDrawTarget
-
>
IsValid
(
)
)
{
if
(
!
gPlatform
-
>
DidRenderingDeviceReset
(
)
)
{
gfxCriticalError
(
)
<
<
"
Could
not
initialize
mScreenReferenceDrawTarget
"
;
}
}
rv
=
gfxFontCache
:
:
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_CRASH
(
"
Could
not
initialize
gfxFontCache
"
)
;
}
gPlatform
-
>
mSRGBOverrideObserver
=
new
SRGBOverrideObserver
(
)
;
Preferences
:
:
AddWeakObserver
(
gPlatform
-
>
mSRGBOverrideObserver
GFX_PREF_CMS_FORCE_SRGB
)
;
Preferences
:
:
RegisterPrefixCallbacks
(
FontPrefChanged
kObservedPrefs
)
;
GLContext
:
:
PlatformStartup
(
)
;
Preferences
:
:
RegisterCallbackAndCall
(
RecordingPrefChanged
"
gfx
.
2d
.
recording
"
)
;
CreateCMSOutputProfile
(
)
;
gPlatform
-
>
mMemoryPressureObserver
=
layers
:
:
MemoryPressureObserver
:
:
Create
(
gPlatform
)
;
nsCOMPtr
<
imgITools
>
imgTools
=
do_GetService
(
"
mozilla
.
org
/
image
/
tools
;
1
"
)
;
if
(
!
imgTools
)
{
MOZ_CRASH
(
"
Could
not
initialize
ImageLib
"
)
;
}
RegisterStrongMemoryReporter
(
new
GfxMemoryImageReporter
(
)
)
;
if
(
XRE_IsParentProcess
(
)
&
&
gfxVars
:
:
UseWebRender
(
)
)
{
RegisterStrongAsyncMemoryReporter
(
new
WebRenderMemoryReporter
(
)
)
;
}
#
ifdef
USE_SKIA
RegisterStrongMemoryReporter
(
new
SkMemoryReporter
(
)
)
;
#
endif
mlg
:
:
InitializeMemoryReporters
(
)
;
#
ifdef
USE_SKIA
uint32_t
skiaCacheSize
=
GetSkiaGlyphCacheSize
(
)
;
if
(
skiaCacheSize
!
=
kDefaultGlyphCacheSize
)
{
SkGraphics
:
:
SetFontCacheLimit
(
skiaCacheSize
)
;
}
#
endif
InitNullMetadata
(
)
;
InitOpenGLConfig
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
Preferences
:
:
Unlock
(
FONT_VARIATIONS_PREF
)
;
if
(
!
gPlatform
-
>
HasVariationFontSupport
(
)
)
{
Preferences
:
:
SetBool
(
FONT_VARIATIONS_PREF
false
PrefValueKind
:
:
Default
)
;
Preferences
:
:
SetBool
(
FONT_VARIATIONS_PREF
false
)
;
Preferences
:
:
Lock
(
FONT_VARIATIONS_PREF
)
;
}
nsCOMPtr
<
nsIFile
>
profDir
;
rv
=
NS_GetSpecialDirectory
(
NS_APP_PROFILE_DIR_STARTUP
getter_AddRefs
(
profDir
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
gfxVars
:
:
SetProfDirectory
(
nsString
(
)
)
;
}
else
{
nsAutoString
path
;
profDir
-
>
GetPath
(
path
)
;
gfxVars
:
:
SetProfDirectory
(
nsString
(
path
)
)
;
}
gfxUtils
:
:
RemoveShaderCacheFromDiskIfNecessary
(
)
;
}
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
nullptr
"
gfx
-
features
-
ready
"
nullptr
)
;
}
}
bool
IsFeatureSupported
(
long
aFeature
)
{
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
nsCString
blockId
;
int32_t
status
;
if
(
!
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
aFeature
blockId
&
status
)
)
)
{
return
true
;
}
return
status
!
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
;
}
bool
gfxPlatform
:
:
IsDXInterop2Blocked
(
)
{
return
IsFeatureSupported
(
nsIGfxInfo
:
:
FEATURE_DX_INTEROP2
)
;
}
bool
gfxPlatform
:
:
IsDXNV12Blocked
(
)
{
return
IsFeatureSupported
(
nsIGfxInfo
:
:
FEATURE_DX_NV12
)
;
}
bool
gfxPlatform
:
:
IsDXP010Blocked
(
)
{
return
IsFeatureSupported
(
nsIGfxInfo
:
:
FEATURE_DX_P010
)
;
}
bool
gfxPlatform
:
:
IsDXP016Blocked
(
)
{
return
IsFeatureSupported
(
nsIGfxInfo
:
:
FEATURE_DX_P016
)
;
}
int32_t
gfxPlatform
:
:
MaxTextureSize
(
)
{
const
int32_t
kMinSizePref
=
2048
;
return
std
:
:
max
(
kMinSizePref
gfxPrefs
:
:
MaxTextureSizeDoNotUseDirectly
(
)
)
;
}
int32_t
gfxPlatform
:
:
MaxAllocSize
(
)
{
const
int32_t
kMinAllocPref
=
10000000
;
return
std
:
:
max
(
kMinAllocPref
gfxPrefs
:
:
MaxAllocSizeDoNotUseDirectly
(
)
)
;
}
void
gfxPlatform
:
:
InitMoz2DLogging
(
)
{
auto
fwd
=
new
CrashStatsLogForwarder
(
CrashReporter
:
:
Annotation
:
:
GraphicsCriticalError
)
;
fwd
-
>
SetCircularBufferSize
(
gfxPrefs
:
:
GfxLoggingCrashLength
(
)
)
;
mozilla
:
:
gfx
:
:
Config
cfg
;
cfg
.
mLogForwarder
=
fwd
;
cfg
.
mMaxTextureSize
=
gfxPlatform
:
:
MaxTextureSize
(
)
;
cfg
.
mMaxAllocSize
=
gfxPlatform
:
:
MaxAllocSize
(
)
;
gfx
:
:
Factory
:
:
Init
(
cfg
)
;
}
bool
gfxPlatform
:
:
IsHeadless
(
)
{
static
bool
initialized
=
false
;
static
bool
headless
=
false
;
if
(
!
initialized
)
{
initialized
=
true
;
headless
=
PR_GetEnv
(
"
MOZ_HEADLESS
"
)
;
}
return
headless
;
}
static
bool
sLayersIPCIsUp
=
false
;
void
gfxPlatform
:
:
InitNullMetadata
(
)
{
ScrollMetadata
:
:
sNullMetadata
=
new
ScrollMetadata
(
)
;
ClearOnShutdown
(
&
ScrollMetadata
:
:
sNullMetadata
)
;
}
void
gfxPlatform
:
:
Shutdown
(
)
{
if
(
!
gPlatform
)
{
return
;
}
MOZ_ASSERT
(
!
sLayersIPCIsUp
)
;
gfxFontCache
:
:
Shutdown
(
)
;
gfxGradientCache
:
:
Shutdown
(
)
;
gfxAlphaBoxBlur
:
:
ShutdownBlurCache
(
)
;
gfxGraphiteShaper
:
:
Shutdown
(
)
;
gfxPlatformFontList
:
:
Shutdown
(
)
;
gfxFontMissingGlyphs
:
:
Shutdown
(
)
;
ShutdownTileCache
(
)
;
ShutdownCMS
(
)
;
NS_ASSERTION
(
gPlatform
-
>
mSRGBOverrideObserver
"
mSRGBOverrideObserver
has
alreay
gone
"
)
;
Preferences
:
:
RemoveObserver
(
gPlatform
-
>
mSRGBOverrideObserver
GFX_PREF_CMS_FORCE_SRGB
)
;
gPlatform
-
>
mSRGBOverrideObserver
=
nullptr
;
Preferences
:
:
UnregisterPrefixCallbacks
(
FontPrefChanged
kObservedPrefs
)
;
NS_ASSERTION
(
gPlatform
-
>
mMemoryPressureObserver
"
mMemoryPressureObserver
has
already
gone
"
)
;
if
(
gPlatform
-
>
mMemoryPressureObserver
)
{
gPlatform
-
>
mMemoryPressureObserver
-
>
Unregister
(
)
;
gPlatform
-
>
mMemoryPressureObserver
=
nullptr
;
}
gPlatform
-
>
mSkiaGlue
=
nullptr
;
if
(
XRE_IsParentProcess
(
)
)
{
gPlatform
-
>
mVsyncSource
-
>
Shutdown
(
)
;
}
gPlatform
-
>
mVsyncSource
=
nullptr
;
GLContextProvider
:
:
Shutdown
(
)
;
#
if
defined
(
XP_WIN
)
GLContextProviderEGL
:
:
Shutdown
(
)
;
#
endif
if
(
XRE_IsParentProcess
(
)
)
{
GPUProcessManager
:
:
Shutdown
(
)
;
VRProcessManager
:
:
Shutdown
(
)
;
RDDProcessManager
:
:
Shutdown
(
)
;
}
gfx
:
:
Factory
:
:
ShutDown
(
)
;
delete
gGfxPlatformPrefsLock
;
gfxVars
:
:
Shutdown
(
)
;
gfxPrefs
:
:
DestroySingleton
(
)
;
gfxFont
:
:
DestroySingletons
(
)
;
gfxConfig
:
:
Shutdown
(
)
;
gPlatform
-
>
WillShutdown
(
)
;
delete
gPlatform
;
gPlatform
=
nullptr
;
}
void
gfxPlatform
:
:
InitLayersIPC
(
)
{
if
(
sLayersIPCIsUp
)
{
return
;
}
sLayersIPCIsUp
=
true
;
if
(
XRE_IsContentProcess
(
)
)
{
if
(
gfxVars
:
:
UseOMTP
(
)
&
&
!
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
layers
:
:
PaintThread
:
:
Start
(
)
;
}
}
if
(
XRE_IsParentProcess
(
)
|
|
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
if
(
!
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
&
&
gfxVars
:
:
UseWebRender
(
)
)
{
wr
:
:
RenderThread
:
:
Start
(
)
;
image
:
:
ImageMemoryReporter
:
:
InitForWebRender
(
)
;
}
layers
:
:
CompositorThreadHolder
:
:
Start
(
)
;
}
}
void
gfxPlatform
:
:
ShutdownLayersIPC
(
)
{
if
(
!
sLayersIPCIsUp
)
{
return
;
}
sLayersIPCIsUp
=
false
;
if
(
XRE_IsContentProcess
(
)
)
{
gfx
:
:
VRManagerChild
:
:
ShutDown
(
)
;
if
(
gfxPrefs
:
:
ChildProcessShutdown
(
)
)
{
layers
:
:
CompositorManagerChild
:
:
Shutdown
(
)
;
layers
:
:
ImageBridgeChild
:
:
ShutDown
(
)
;
}
if
(
gfxVars
:
:
UseOMTP
(
)
&
&
!
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
layers
:
:
PaintThread
:
:
Shutdown
(
)
;
}
}
else
if
(
XRE_IsParentProcess
(
)
)
{
gfx
:
:
VRManagerChild
:
:
ShutDown
(
)
;
layers
:
:
CompositorManagerChild
:
:
Shutdown
(
)
;
layers
:
:
ImageBridgeChild
:
:
ShutDown
(
)
;
layers
:
:
CompositorThreadHolder
:
:
Shutdown
(
)
;
image
:
:
ImageMemoryReporter
:
:
ShutdownForWebRender
(
)
;
if
(
wr
:
:
RenderThread
:
:
Get
(
)
)
{
wr
:
:
RenderThread
:
:
ShutDown
(
)
;
Preferences
:
:
UnregisterCallback
(
WebRenderDebugPrefChangeCallback
WR_DEBUG_PREF
)
;
}
}
else
{
}
}
void
gfxPlatform
:
:
WillShutdown
(
)
{
mScreenReferenceSurface
=
nullptr
;
mScreenReferenceDrawTarget
=
nullptr
;
}
gfxPlatform
:
:
~
gfxPlatform
(
)
{
#
ifdef
NS_FREE_PERMANENT_DATA
#
ifdef
USE_SKIA
SkGraphics
:
:
PurgeFontCache
(
)
;
#
endif
#
if
MOZ_TREE_CAIRO
cairo_debug_reset_static_data
(
)
;
#
endif
#
endif
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateDrawTargetForSurface
(
gfxASurface
*
aSurface
const
IntSize
&
aSize
)
{
SurfaceFormat
format
=
aSurface
-
>
GetSurfaceFormat
(
)
;
RefPtr
<
DrawTarget
>
drawTarget
=
Factory
:
:
CreateDrawTargetForCairoSurface
(
aSurface
-
>
CairoSurface
(
)
aSize
&
format
)
;
if
(
!
drawTarget
)
{
gfxWarning
(
)
<
<
"
gfxPlatform
:
:
CreateDrawTargetForSurface
failed
in
"
"
CreateDrawTargetForCairoSurface
"
;
return
nullptr
;
}
return
drawTarget
.
forget
(
)
;
}
cairo_user_data_key_t
kSourceSurface
;
struct
SourceSurfaceUserData
{
RefPtr
<
SourceSurface
>
mSrcSurface
;
BackendType
mBackendType
;
}
;
void
SourceBufferDestroy
(
void
*
srcSurfUD
)
{
delete
static_cast
<
SourceSurfaceUserData
*
>
(
srcSurfUD
)
;
}
UserDataKey
kThebesSurface
;
struct
DependentSourceSurfaceUserData
{
RefPtr
<
gfxASurface
>
mSurface
;
}
;
void
SourceSurfaceDestroyed
(
void
*
aData
)
{
delete
static_cast
<
DependentSourceSurfaceUserData
*
>
(
aData
)
;
}
void
gfxPlatform
:
:
ClearSourceSurfaceForSurface
(
gfxASurface
*
aSurface
)
{
aSurface
-
>
SetData
(
&
kSourceSurface
nullptr
nullptr
)
;
}
already_AddRefed
<
SourceSurface
>
gfxPlatform
:
:
GetSourceSurfaceForSurface
(
RefPtr
<
DrawTarget
>
aTarget
gfxASurface
*
aSurface
bool
aIsPlugin
)
{
if
(
!
aSurface
-
>
CairoSurface
(
)
|
|
aSurface
-
>
CairoStatus
(
)
)
{
return
nullptr
;
}
if
(
!
aTarget
)
{
aTarget
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
;
}
void
*
userData
=
aSurface
-
>
GetData
(
&
kSourceSurface
)
;
if
(
userData
)
{
SourceSurfaceUserData
*
surf
=
static_cast
<
SourceSurfaceUserData
*
>
(
userData
)
;
if
(
surf
-
>
mSrcSurface
-
>
IsValid
(
)
&
&
surf
-
>
mBackendType
=
=
aTarget
-
>
GetBackendType
(
)
)
{
RefPtr
<
SourceSurface
>
srcSurface
(
surf
-
>
mSrcSurface
)
;
return
srcSurface
.
forget
(
)
;
}
}
SurfaceFormat
format
=
aSurface
-
>
GetSurfaceFormat
(
)
;
if
(
aTarget
-
>
GetBackendType
(
)
=
=
BackendType
:
:
CAIRO
)
{
return
Factory
:
:
CreateSourceSurfaceForCairoSurface
(
aSurface
-
>
CairoSurface
(
)
aSurface
-
>
GetSize
(
)
format
)
;
}
RefPtr
<
SourceSurface
>
srcBuffer
;
if
(
!
srcBuffer
)
{
RefPtr
<
DataSourceSurface
>
surf
=
GetWrappedDataSourceSurface
(
aSurface
)
;
if
(
surf
)
{
srcBuffer
=
aIsPlugin
?
aTarget
-
>
OptimizeSourceSurfaceForUnknownAlpha
(
surf
)
:
aTarget
-
>
OptimizeSourceSurface
(
surf
)
;
if
(
srcBuffer
=
=
surf
)
{
return
srcBuffer
.
forget
(
)
;
}
}
}
if
(
!
srcBuffer
)
{
MOZ_ASSERT
(
aTarget
-
>
GetBackendType
(
)
!
=
BackendType
:
:
CAIRO
"
We
already
tried
CreateSourceSurfaceFromNativeSurface
with
a
"
"
DrawTargetCairo
above
"
)
;
srcBuffer
=
Factory
:
:
CreateSourceSurfaceForCairoSurface
(
aSurface
-
>
CairoSurface
(
)
aSurface
-
>
GetSize
(
)
format
)
;
if
(
srcBuffer
)
{
srcBuffer
=
aTarget
-
>
OptimizeSourceSurface
(
srcBuffer
)
;
}
}
if
(
!
srcBuffer
)
{
return
nullptr
;
}
if
(
(
srcBuffer
-
>
GetType
(
)
=
=
SurfaceType
:
:
CAIRO
&
&
static_cast
<
SourceSurfaceCairo
*
>
(
srcBuffer
.
get
(
)
)
-
>
GetSurface
(
)
=
=
aSurface
-
>
CairoSurface
(
)
)
|
|
(
srcBuffer
-
>
GetType
(
)
=
=
SurfaceType
:
:
CAIRO_IMAGE
&
&
static_cast
<
DataSourceSurfaceCairo
*
>
(
srcBuffer
.
get
(
)
)
-
>
GetSurface
(
)
=
=
aSurface
-
>
CairoSurface
(
)
)
)
{
return
srcBuffer
.
forget
(
)
;
}
auto
*
srcSurfUD
=
new
SourceSurfaceUserData
;
srcSurfUD
-
>
mBackendType
=
aTarget
-
>
GetBackendType
(
)
;
srcSurfUD
-
>
mSrcSurface
=
srcBuffer
;
aSurface
-
>
SetData
(
&
kSourceSurface
srcSurfUD
SourceBufferDestroy
)
;
return
srcBuffer
.
forget
(
)
;
}
already_AddRefed
<
DataSourceSurface
>
gfxPlatform
:
:
GetWrappedDataSourceSurface
(
gfxASurface
*
aSurface
)
{
RefPtr
<
gfxImageSurface
>
image
=
aSurface
-
>
GetAsImageSurface
(
)
;
if
(
!
image
)
{
return
nullptr
;
}
RefPtr
<
DataSourceSurface
>
result
=
Factory
:
:
CreateWrappingDataSourceSurface
(
image
-
>
Data
(
)
image
-
>
Stride
(
)
image
-
>
GetSize
(
)
ImageFormatToSurfaceFormat
(
image
-
>
Format
(
)
)
)
;
if
(
!
result
)
{
return
nullptr
;
}
auto
*
srcSurfUD
=
new
DependentSourceSurfaceUserData
;
srcSurfUD
-
>
mSurface
=
aSurface
;
result
-
>
AddUserData
(
&
kThebesSurface
srcSurfUD
SourceSurfaceDestroyed
)
;
return
result
.
forget
(
)
;
}
void
gfxPlatform
:
:
ComputeTileSize
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
int32_t
w
=
gfxPrefs
:
:
LayersTileWidth
(
)
;
int32_t
h
=
gfxPrefs
:
:
LayersTileHeight
(
)
;
if
(
gfxPrefs
:
:
LayersTilesAdjust
(
)
)
{
gfx
:
:
IntSize
screenSize
=
GetScreenSize
(
)
;
if
(
screenSize
.
width
>
0
)
{
w
=
h
=
clamped
(
int32_t
(
RoundUpPow2
(
screenSize
.
width
)
)
/
4
256
1024
)
;
}
}
MOZ_ASSERT
(
gfxVars
:
:
TileSize
(
)
.
width
=
=
-
1
&
&
gfxVars
:
:
TileSize
(
)
.
height
=
=
-
1
)
;
gfxVars
:
:
SetTileSize
(
IntSize
(
w
h
)
)
;
}
void
gfxPlatform
:
:
PopulateScreenInfo
(
)
{
nsCOMPtr
<
nsIScreenManager
>
manager
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
;
MOZ_ASSERT
(
manager
"
failed
to
get
nsIScreenManager
"
)
;
nsCOMPtr
<
nsIScreen
>
screen
;
manager
-
>
GetPrimaryScreen
(
getter_AddRefs
(
screen
)
)
;
if
(
!
screen
)
{
return
;
}
screen
-
>
GetColorDepth
(
&
mScreenDepth
)
;
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetScreenDepth
(
mScreenDepth
)
;
}
int
left
top
;
screen
-
>
GetRect
(
&
left
&
top
&
mScreenSize
.
width
&
mScreenSize
.
height
)
;
}
bool
gfxPlatform
:
:
SupportsAzureContentForDrawTarget
(
DrawTarget
*
aTarget
)
{
if
(
!
aTarget
|
|
!
aTarget
-
>
IsValid
(
)
)
{
return
false
;
}
#
ifdef
USE_SKIA_GPU
if
(
(
aTarget
-
>
GetType
(
)
=
=
DrawTargetType
:
:
HARDWARE_RASTER
)
&
&
(
aTarget
-
>
GetBackendType
(
)
=
=
BackendType
:
:
SKIA
)
)
{
return
false
;
}
#
endif
return
SupportsAzureContentForType
(
aTarget
-
>
GetBackendType
(
)
)
;
}
bool
gfxPlatform
:
:
AllowOpenGLCanvas
(
)
{
bool
correctBackend
=
!
XRE_IsParentProcess
(
)
|
|
(
mCompositorBackend
=
=
LayersBackend
:
:
LAYERS_OPENGL
&
&
(
GetContentBackendFor
(
mCompositorBackend
)
=
=
BackendType
:
:
SKIA
)
)
;
if
(
gfxPrefs
:
:
CanvasAzureAccelerated
(
)
&
&
correctBackend
)
{
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
info
;
1
"
)
;
int32_t
status
;
nsCString
discardFailureId
;
return
!
gfxInfo
|
|
(
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_CANVAS2D_ACCELERATION
discardFailureId
&
status
)
)
&
&
status
=
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
)
;
}
return
false
;
}
void
gfxPlatform
:
:
InitializeSkiaCacheLimits
(
)
{
if
(
AllowOpenGLCanvas
(
)
)
{
#
ifdef
USE_SKIA_GPU
bool
usingDynamicCache
=
gfxPrefs
:
:
CanvasSkiaGLDynamicCache
(
)
;
int
cacheItemLimit
=
gfxPrefs
:
:
CanvasSkiaGLCacheItems
(
)
;
uint64_t
cacheSizeLimit
=
std
:
:
max
(
gfxPrefs
:
:
CanvasSkiaGLCacheSize
(
)
(
int32_t
)
0
)
;
cacheSizeLimit
*
=
1024
*
1024
;
if
(
usingDynamicCache
)
{
if
(
mTotalSystemMemory
<
512
*
1024
*
1024
)
{
cacheSizeLimit
=
2
*
1024
*
1024
;
}
else
if
(
mTotalSystemMemory
>
0
)
{
cacheSizeLimit
=
mTotalSystemMemory
/
16
;
}
}
cacheSizeLimit
=
std
:
:
min
(
cacheSizeLimit
(
uint64_t
)
SIZE_MAX
)
;
#
ifdef
DEBUG
printf_stderr
(
"
Determined
SkiaGL
cache
limits
:
Size
%
"
PRIu64
"
Items
:
%
i
\
n
"
cacheSizeLimit
cacheItemLimit
)
;
#
endif
mSkiaGlue
-
>
GetGrContext
(
)
-
>
setResourceCacheLimits
(
cacheItemLimit
(
size_t
)
cacheSizeLimit
)
;
#
endif
}
}
SkiaGLGlue
*
gfxPlatform
:
:
GetSkiaGLGlue
(
)
{
#
ifdef
USE_SKIA_GPU
if
(
!
mSkiaGlue
&
&
!
AllowOpenGLCanvas
(
)
)
{
return
nullptr
;
}
if
(
!
mSkiaGlue
)
{
RefPtr
<
GLContext
>
glContext
;
nsCString
discardFailureId
;
glContext
=
GLContextProvider
:
:
CreateHeadless
(
CreateContextFlags
:
:
REQUIRE_COMPAT_PROFILE
|
CreateContextFlags
:
:
ALLOW_OFFLINE_RENDERER
&
discardFailureId
)
;
if
(
!
glContext
)
{
printf_stderr
(
"
Failed
to
create
GLContext
for
SkiaGL
!
\
n
"
)
;
return
nullptr
;
}
mSkiaGlue
=
new
SkiaGLGlue
(
glContext
)
;
MOZ_ASSERT
(
mSkiaGlue
-
>
GetGrContext
(
)
"
No
GrContext
"
)
;
InitializeSkiaCacheLimits
(
)
;
}
#
endif
return
mSkiaGlue
;
}
void
gfxPlatform
:
:
PurgeSkiaFontCache
(
)
{
#
ifdef
USE_SKIA
if
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetDefaultContentBackend
(
)
=
=
BackendType
:
:
SKIA
)
{
SkGraphics
:
:
PurgeFontCache
(
)
;
}
#
endif
}
void
gfxPlatform
:
:
PurgeSkiaGPUCache
(
)
{
#
ifdef
USE_SKIA_GPU
if
(
!
mSkiaGlue
)
return
;
mSkiaGlue
-
>
GetGrContext
(
)
-
>
freeGpuResources
(
)
;
mSkiaGlue
-
>
GetGLContext
(
)
-
>
MakeCurrent
(
)
;
mSkiaGlue
-
>
GetGLContext
(
)
-
>
fFlush
(
)
;
#
endif
}
bool
gfxPlatform
:
:
HasEnoughTotalSystemMemoryForSkiaGL
(
)
{
return
true
;
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateDrawTargetForBackend
(
BackendType
aBackend
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
if
(
aBackend
=
=
BackendType
:
:
CAIRO
)
{
RefPtr
<
gfxASurface
>
surf
=
CreateOffscreenSurface
(
aSize
SurfaceFormatToImageFormat
(
aFormat
)
)
;
if
(
!
surf
|
|
surf
-
>
CairoStatus
(
)
)
{
return
nullptr
;
}
return
CreateDrawTargetForSurface
(
surf
aSize
)
;
}
return
Factory
:
:
CreateDrawTarget
(
aBackend
aSize
aFormat
)
;
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateOffscreenCanvasDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
NS_ASSERTION
(
mPreferredCanvasBackend
!
=
BackendType
:
:
NONE
"
No
backend
.
"
)
;
RefPtr
<
DrawTarget
>
target
=
CreateDrawTargetForBackend
(
mPreferredCanvasBackend
aSize
aFormat
)
;
if
(
target
|
|
mFallbackCanvasBackend
=
=
BackendType
:
:
NONE
)
{
return
target
.
forget
(
)
;
}
#
ifdef
XP_WIN
return
Factory
:
:
CreateDrawTarget
(
mFallbackCanvasBackend
aSize
aFormat
)
;
#
else
return
CreateDrawTargetForBackend
(
mFallbackCanvasBackend
aSize
aFormat
)
;
#
endif
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateOffscreenContentDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
bool
aFallback
)
{
BackendType
backend
=
(
aFallback
)
?
mSoftwareBackend
:
mContentBackend
;
NS_ASSERTION
(
backend
!
=
BackendType
:
:
NONE
"
No
backend
.
"
)
;
return
CreateDrawTargetForBackend
(
backend
aSize
aFormat
)
;
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateSimilarSoftwareDrawTarget
(
DrawTarget
*
aDT
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
RefPtr
<
DrawTarget
>
dt
;
if
(
Factory
:
:
DoesBackendSupportDataDrawtarget
(
aDT
-
>
GetBackendType
(
)
)
)
{
dt
=
aDT
-
>
CreateSimilarDrawTarget
(
aSize
aFormat
)
;
}
else
{
#
ifdef
USE_SKIA
BackendType
backendType
=
BackendType
:
:
SKIA
;
#
else
BackendType
backendType
=
BackendType
:
:
CAIRO
;
#
endif
dt
=
Factory
:
:
CreateDrawTarget
(
backendType
aSize
aFormat
)
;
}
return
dt
.
forget
(
)
;
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateDrawTargetForData
(
unsigned
char
*
aData
const
IntSize
&
aSize
int32_t
aStride
SurfaceFormat
aFormat
bool
aUninitialized
)
{
BackendType
backendType
=
gfxVars
:
:
ContentBackend
(
)
;
NS_ASSERTION
(
backendType
!
=
BackendType
:
:
NONE
"
No
backend
.
"
)
;
if
(
!
Factory
:
:
DoesBackendSupportDataDrawtarget
(
backendType
)
)
{
#
ifdef
USE_SKIA
backendType
=
BackendType
:
:
SKIA
;
#
else
backendType
=
BackendType
:
:
CAIRO
;
#
endif
}
RefPtr
<
DrawTarget
>
dt
=
Factory
:
:
CreateDrawTargetForData
(
backendType
aData
aSize
aStride
aFormat
aUninitialized
)
;
return
dt
.
forget
(
)
;
}
BackendType
gfxPlatform
:
:
BackendTypeForName
(
const
nsCString
&
aName
)
{
if
(
aName
.
EqualsLiteral
(
"
cairo
"
)
)
return
BackendType
:
:
CAIRO
;
if
(
aName
.
EqualsLiteral
(
"
skia
"
)
)
return
BackendType
:
:
SKIA
;
if
(
aName
.
EqualsLiteral
(
"
direct2d
"
)
)
return
BackendType
:
:
DIRECT2D
;
if
(
aName
.
EqualsLiteral
(
"
direct2d1
.
1
"
)
)
return
BackendType
:
:
DIRECT2D1_1
;
return
BackendType
:
:
NONE
;
}
nsresult
gfxPlatform
:
:
GetFontList
(
nsAtom
*
aLangGroup
const
nsACString
&
aGenericFamily
nsTArray
<
nsString
>
&
aListOfFonts
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
GetFontList
(
aLangGroup
aGenericFamily
aListOfFonts
)
;
return
NS_OK
;
}
nsresult
gfxPlatform
:
:
UpdateFontList
(
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
UpdateFontList
(
)
;
return
NS_OK
;
}
void
gfxPlatform
:
:
GetStandardFamilyName
(
const
nsCString
&
aFontName
nsACString
&
aFamilyName
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
GetStandardFamilyName
(
aFontName
aFamilyName
)
;
}
nsAutoCString
gfxPlatform
:
:
GetDefaultFontName
(
const
nsACString
&
aLangGroup
const
nsACString
&
aGenericFamily
)
{
nsAutoCString
result
;
gfxFontFamily
*
fontFamily
=
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
GetDefaultFontFamily
(
aLangGroup
aGenericFamily
)
;
if
(
fontFamily
)
{
fontFamily
-
>
LocalizedName
(
result
)
;
}
return
result
;
}
bool
gfxPlatform
:
:
DownloadableFontsEnabled
(
)
{
if
(
mAllowDownloadableFonts
=
=
UNINITIALIZED_VALUE
)
{
mAllowDownloadableFonts
=
Preferences
:
:
GetBool
(
GFX_DOWNLOADABLE_FONTS_ENABLED
false
)
;
}
return
mAllowDownloadableFonts
;
}
bool
gfxPlatform
:
:
UseCmapsDuringSystemFallback
(
)
{
if
(
mFallbackUsesCmaps
=
=
UNINITIALIZED_VALUE
)
{
mFallbackUsesCmaps
=
Preferences
:
:
GetBool
(
GFX_PREF_FALLBACK_USE_CMAPS
false
)
;
}
return
mFallbackUsesCmaps
;
}
bool
gfxPlatform
:
:
OpenTypeSVGEnabled
(
)
{
if
(
mOpenTypeSVGEnabled
=
=
UNINITIALIZED_VALUE
)
{
mOpenTypeSVGEnabled
=
Preferences
:
:
GetBool
(
GFX_PREF_OPENTYPE_SVG
false
)
;
}
return
mOpenTypeSVGEnabled
>
0
;
}
uint32_t
gfxPlatform
:
:
WordCacheCharLimit
(
)
{
if
(
mWordCacheCharLimit
=
=
UNINITIALIZED_VALUE
)
{
mWordCacheCharLimit
=
Preferences
:
:
GetInt
(
GFX_PREF_WORD_CACHE_CHARLIMIT
32
)
;
if
(
mWordCacheCharLimit
<
0
)
{
mWordCacheCharLimit
=
32
;
}
}
return
uint32_t
(
mWordCacheCharLimit
)
;
}
uint32_t
gfxPlatform
:
:
WordCacheMaxEntries
(
)
{
if
(
mWordCacheMaxEntries
=
=
UNINITIALIZED_VALUE
)
{
mWordCacheMaxEntries
=
Preferences
:
:
GetInt
(
GFX_PREF_WORD_CACHE_MAXENTRIES
10000
)
;
if
(
mWordCacheMaxEntries
<
0
)
{
mWordCacheMaxEntries
=
10000
;
}
}
return
uint32_t
(
mWordCacheMaxEntries
)
;
}
bool
gfxPlatform
:
:
UseGraphiteShaping
(
)
{
if
(
mGraphiteShapingEnabled
=
=
UNINITIALIZED_VALUE
)
{
mGraphiteShapingEnabled
=
Preferences
:
:
GetBool
(
GFX_PREF_GRAPHITE_SHAPING
false
)
;
}
return
mGraphiteShapingEnabled
;
}
bool
gfxPlatform
:
:
IsFontFormatSupported
(
uint32_t
aFormatFlags
)
{
MOZ_ASSERT
(
!
(
aFormatFlags
&
gfxUserFontSet
:
:
FLAG_FORMAT_NOT_USED
)
"
strange
font
format
hint
set
"
)
;
if
(
aFormatFlags
&
gfxUserFontSet
:
:
FLAG_FORMATS_COMMON
)
{
return
true
;
}
if
(
aFormatFlags
!
=
0
)
{
return
false
;
}
return
true
;
}
gfxFontEntry
*
gfxPlatform
:
:
LookupLocalFont
(
const
nsACString
&
aFontName
WeightRange
aWeightForEntry
StretchRange
aStretchForEntry
SlantStyleRange
aStyleForEntry
)
{
return
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
LookupLocalFont
(
aFontName
aWeightForEntry
aStretchForEntry
aStyleForEntry
)
;
}
gfxFontEntry
*
gfxPlatform
:
:
MakePlatformFont
(
const
nsACString
&
aFontName
WeightRange
aWeightForEntry
StretchRange
aStretchForEntry
SlantStyleRange
aStyleForEntry
const
uint8_t
*
aFontData
uint32_t
aLength
)
{
return
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
MakePlatformFont
(
aFontName
aWeightForEntry
aStretchForEntry
aStyleForEntry
aFontData
aLength
)
;
}
mozilla
:
:
layers
:
:
DiagnosticTypes
gfxPlatform
:
:
GetLayerDiagnosticTypes
(
)
{
mozilla
:
:
layers
:
:
DiagnosticTypes
type
=
DiagnosticTypes
:
:
NO_DIAGNOSTIC
;
if
(
gfxPrefs
:
:
DrawLayerBorders
(
)
)
{
type
|
=
mozilla
:
:
layers
:
:
DiagnosticTypes
:
:
LAYER_BORDERS
;
}
if
(
gfxPrefs
:
:
DrawTileBorders
(
)
)
{
type
|
=
mozilla
:
:
layers
:
:
DiagnosticTypes
:
:
TILE_BORDERS
;
}
if
(
gfxPrefs
:
:
DrawBigImageBorders
(
)
)
{
type
|
=
mozilla
:
:
layers
:
:
DiagnosticTypes
:
:
BIGIMAGE_BORDERS
;
}
if
(
gfxPrefs
:
:
FlashLayerBorders
(
)
)
{
type
|
=
mozilla
:
:
layers
:
:
DiagnosticTypes
:
:
FLASH_BORDERS
;
}
return
type
;
}
BackendPrefsData
gfxPlatform
:
:
GetBackendPrefs
(
)
const
{
BackendPrefsData
data
;
data
.
mCanvasBitmask
=
BackendTypeBit
(
BackendType
:
:
CAIRO
)
;
data
.
mContentBitmask
=
BackendTypeBit
(
BackendType
:
:
CAIRO
)
;
#
ifdef
USE_SKIA
data
.
mCanvasBitmask
|
=
BackendTypeBit
(
BackendType
:
:
SKIA
)
;
data
.
mContentBitmask
|
=
BackendTypeBit
(
BackendType
:
:
SKIA
)
;
#
endif
data
.
mCanvasDefault
=
BackendType
:
:
CAIRO
;
data
.
mContentDefault
=
BackendType
:
:
CAIRO
;
return
data
;
}
void
gfxPlatform
:
:
InitBackendPrefs
(
BackendPrefsData
&
&
aPrefsData
)
{
mPreferredCanvasBackend
=
GetCanvasBackendPref
(
aPrefsData
.
mCanvasBitmask
)
;
if
(
mPreferredCanvasBackend
=
=
BackendType
:
:
NONE
)
{
mPreferredCanvasBackend
=
aPrefsData
.
mCanvasDefault
;
}
if
(
mPreferredCanvasBackend
=
=
BackendType
:
:
DIRECT2D1_1
)
{
mFallbackCanvasBackend
=
GetCanvasBackendPref
(
aPrefsData
.
mCanvasBitmask
&
~
(
BackendTypeBit
(
mPreferredCanvasBackend
)
|
BackendTypeBit
(
BackendType
:
:
DIRECT2D
)
)
)
;
}
else
{
mFallbackCanvasBackend
=
GetCanvasBackendPref
(
aPrefsData
.
mCanvasBitmask
&
~
BackendTypeBit
(
mPreferredCanvasBackend
)
)
;
}
mContentBackendBitmask
=
aPrefsData
.
mContentBitmask
;
mContentBackend
=
GetContentBackendPref
(
mContentBackendBitmask
)
;
if
(
mContentBackend
=
=
BackendType
:
:
NONE
)
{
mContentBackend
=
aPrefsData
.
mContentDefault
;
mContentBackendBitmask
|
=
BackendTypeBit
(
aPrefsData
.
mContentDefault
)
;
}
uint32_t
swBackendBits
=
BackendTypeBit
(
BackendType
:
:
SKIA
)
|
BackendTypeBit
(
BackendType
:
:
CAIRO
)
;
mSoftwareBackend
=
GetContentBackendPref
(
swBackendBits
)
;
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetContentBackend
(
mContentBackend
)
;
gfxVars
:
:
SetSoftwareBackend
(
mSoftwareBackend
)
;
}
}
BackendType
gfxPlatform
:
:
GetCanvasBackendPref
(
uint32_t
aBackendBitmask
)
{
return
GetBackendPref
(
"
gfx
.
canvas
.
azure
.
backends
"
aBackendBitmask
)
;
}
BackendType
gfxPlatform
:
:
GetContentBackendPref
(
uint32_t
&
aBackendBitmask
)
{
return
GetBackendPref
(
"
gfx
.
content
.
azure
.
backends
"
aBackendBitmask
)
;
}
BackendType
gfxPlatform
:
:
GetBackendPref
(
const
char
*
aBackendPrefName
uint32_t
&
aBackendBitmask
)
{
nsTArray
<
nsCString
>
backendList
;
nsAutoCString
prefString
;
if
(
NS_SUCCEEDED
(
Preferences
:
:
GetCString
(
aBackendPrefName
prefString
)
)
)
{
ParseString
(
prefString
'
'
backendList
)
;
}
uint32_t
allowedBackends
=
0
;
BackendType
result
=
BackendType
:
:
NONE
;
for
(
uint32_t
i
=
0
;
i
<
backendList
.
Length
(
)
;
+
+
i
)
{
BackendType
type
=
BackendTypeForName
(
backendList
[
i
]
)
;
if
(
BackendTypeBit
(
type
)
&
aBackendBitmask
)
{
allowedBackends
|
=
BackendTypeBit
(
type
)
;
if
(
result
=
=
BackendType
:
:
NONE
)
{
result
=
type
;
}
}
}
aBackendBitmask
=
allowedBackends
;
return
result
;
}
bool
gfxPlatform
:
:
InSafeMode
(
)
{
static
bool
sSafeModeInitialized
=
false
;
static
bool
sInSafeMode
=
false
;
if
(
!
sSafeModeInitialized
)
{
sSafeModeInitialized
=
true
;
nsCOMPtr
<
nsIXULRuntime
>
xr
=
do_GetService
(
"
mozilla
.
org
/
xre
/
runtime
;
1
"
)
;
if
(
xr
)
{
xr
-
>
GetInSafeMode
(
&
sInSafeMode
)
;
}
}
return
sInSafeMode
;
}
bool
gfxPlatform
:
:
OffMainThreadCompositingEnabled
(
)
{
return
UsesOffMainThreadCompositing
(
)
;
}
eCMSMode
gfxPlatform
:
:
GetCMSMode
(
)
{
if
(
!
gCMSInitialized
)
{
int32_t
mode
=
gfxPrefs
:
:
CMSMode
(
)
;
if
(
mode
>
=
0
&
&
mode
<
eCMSMode_AllCount
)
{
gCMSMode
=
static_cast
<
eCMSMode
>
(
mode
)
;
}
bool
enableV4
=
gfxPrefs
:
:
CMSEnableV4
(
)
;
if
(
enableV4
)
{
qcms_enable_iccv4
(
)
;
}
gCMSInitialized
=
true
;
}
return
gCMSMode
;
}
int
gfxPlatform
:
:
GetRenderingIntent
(
)
{
MOZ_ASSERT
(
QCMS_INTENT_DEFAULT
=
=
0
)
;
int32_t
pIntent
=
gfxPrefs
:
:
CMSRenderingIntent
(
)
;
if
(
(
pIntent
<
QCMS_INTENT_MIN
)
|
|
(
pIntent
>
QCMS_INTENT_MAX
)
)
{
pIntent
=
-
1
;
}
return
pIntent
;
}
void
gfxPlatform
:
:
TransformPixel
(
const
Color
&
in
Color
&
out
qcms_transform
*
transform
)
{
if
(
transform
)
{
#
ifdef
IS_LITTLE_ENDIAN
uint32_t
packed
=
in
.
ToABGR
(
)
;
qcms_transform_data
(
transform
(
uint8_t
*
)
&
packed
(
uint8_t
*
)
&
packed
1
)
;
out
=
Color
:
:
FromABGR
(
packed
)
;
#
else
uint32_t
packed
=
in
.
UnusualToARGB
(
)
;
qcms_transform_data
(
transform
(
uint8_t
*
)
&
packed
+
1
(
uint8_t
*
)
&
packed
+
1
1
)
;
out
=
Color
:
:
UnusualFromARGB
(
packed
)
;
#
endif
}
else
if
(
&
out
!
=
&
in
)
out
=
in
;
}
void
gfxPlatform
:
:
GetPlatformCMSOutputProfile
(
void
*
&
mem
size_t
&
size
)
{
mem
=
nullptr
;
size
=
0
;
}
void
gfxPlatform
:
:
GetCMSOutputProfileData
(
void
*
&
mem
size_t
&
size
)
{
nsAutoCString
fname
;
Preferences
:
:
GetCString
(
"
gfx
.
color_management
.
display_profile
"
fname
)
;
mem
=
nullptr
;
if
(
!
fname
.
IsEmpty
(
)
)
{
qcms_data_from_path
(
fname
.
get
(
)
&
mem
&
size
)
;
}
if
(
mem
=
=
nullptr
)
{
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetPlatformCMSOutputProfile
(
mem
size
)
;
}
}
void
gfxPlatform
:
:
CreateCMSOutputProfile
(
)
{
if
(
!
gCMSOutputProfile
)
{
if
(
Preferences
:
:
GetBool
(
GFX_PREF_CMS_FORCE_SRGB
false
)
)
{
gCMSOutputProfile
=
GetCMSsRGBProfile
(
)
;
}
if
(
!
gCMSOutputProfile
)
{
void
*
mem
=
nullptr
;
size_t
size
=
0
;
GetCMSOutputProfileData
(
mem
size
)
;
if
(
(
mem
!
=
nullptr
)
&
&
(
size
>
0
)
)
{
gCMSOutputProfile
=
qcms_profile_from_memory
(
mem
size
)
;
free
(
mem
)
;
}
}
if
(
gCMSOutputProfile
&
&
qcms_profile_is_bogus
(
gCMSOutputProfile
)
)
{
NS_ASSERTION
(
gCMSOutputProfile
!
=
GetCMSsRGBProfile
(
)
"
Builtin
sRGB
profile
tagged
as
bogus
!
!
!
"
)
;
qcms_profile_release
(
gCMSOutputProfile
)
;
gCMSOutputProfile
=
nullptr
;
}
if
(
!
gCMSOutputProfile
)
{
gCMSOutputProfile
=
GetCMSsRGBProfile
(
)
;
}
qcms_profile_precache_output_transform
(
gCMSOutputProfile
)
;
}
}
qcms_profile
*
gfxPlatform
:
:
GetCMSOutputProfile
(
)
{
return
gCMSOutputProfile
;
}
qcms_profile
*
gfxPlatform
:
:
GetCMSsRGBProfile
(
)
{
if
(
!
gCMSsRGBProfile
)
{
gCMSsRGBProfile
=
qcms_profile_sRGB
(
)
;
}
return
gCMSsRGBProfile
;
}
qcms_transform
*
gfxPlatform
:
:
GetCMSRGBTransform
(
)
{
if
(
!
gCMSRGBTransform
&
&
!
gCMSRGBTransformFailed
)
{
qcms_profile
*
inProfile
*
outProfile
;
outProfile
=
GetCMSOutputProfile
(
)
;
inProfile
=
GetCMSsRGBProfile
(
)
;
if
(
!
inProfile
|
|
!
outProfile
)
return
nullptr
;
gCMSRGBTransform
=
qcms_transform_create
(
inProfile
QCMS_DATA_RGB_8
outProfile
QCMS_DATA_RGB_8
QCMS_INTENT_PERCEPTUAL
)
;
if
(
!
gCMSRGBTransform
)
{
gCMSRGBTransformFailed
=
true
;
}
}
return
gCMSRGBTransform
;
}
qcms_transform
*
gfxPlatform
:
:
GetCMSInverseRGBTransform
(
)
{
if
(
!
gCMSInverseRGBTransform
)
{
qcms_profile
*
inProfile
*
outProfile
;
inProfile
=
GetCMSOutputProfile
(
)
;
outProfile
=
GetCMSsRGBProfile
(
)
;
if
(
!
inProfile
|
|
!
outProfile
)
return
nullptr
;
gCMSInverseRGBTransform
=
qcms_transform_create
(
inProfile
QCMS_DATA_RGB_8
outProfile
QCMS_DATA_RGB_8
QCMS_INTENT_PERCEPTUAL
)
;
}
return
gCMSInverseRGBTransform
;
}
qcms_transform
*
gfxPlatform
:
:
GetCMSRGBATransform
(
)
{
if
(
!
gCMSRGBATransform
)
{
qcms_profile
*
inProfile
*
outProfile
;
outProfile
=
GetCMSOutputProfile
(
)
;
inProfile
=
GetCMSsRGBProfile
(
)
;
if
(
!
inProfile
|
|
!
outProfile
)
return
nullptr
;
gCMSRGBATransform
=
qcms_transform_create
(
inProfile
QCMS_DATA_RGBA_8
outProfile
QCMS_DATA_RGBA_8
QCMS_INTENT_PERCEPTUAL
)
;
}
return
gCMSRGBATransform
;
}
static
void
ShutdownCMS
(
)
{
if
(
gCMSRGBTransform
)
{
qcms_transform_release
(
gCMSRGBTransform
)
;
gCMSRGBTransform
=
nullptr
;
}
if
(
gCMSInverseRGBTransform
)
{
qcms_transform_release
(
gCMSInverseRGBTransform
)
;
gCMSInverseRGBTransform
=
nullptr
;
}
if
(
gCMSRGBATransform
)
{
qcms_transform_release
(
gCMSRGBATransform
)
;
gCMSRGBATransform
=
nullptr
;
}
if
(
gCMSOutputProfile
)
{
qcms_profile_release
(
gCMSOutputProfile
)
;
if
(
gCMSsRGBProfile
=
=
gCMSOutputProfile
)
gCMSsRGBProfile
=
nullptr
;
gCMSOutputProfile
=
nullptr
;
}
if
(
gCMSsRGBProfile
)
{
qcms_profile_release
(
gCMSsRGBProfile
)
;
gCMSsRGBProfile
=
nullptr
;
}
gCMSMode
=
eCMSMode_Off
;
gCMSInitialized
=
false
;
}
void
gfxPlatform
:
:
SetupClusterBoundaries
(
gfxTextRun
*
aTextRun
const
char16_t
*
aString
)
{
if
(
aTextRun
-
>
GetFlags
(
)
&
gfx
:
:
ShapedTextFlags
:
:
TEXT_IS_8BIT
)
{
return
;
}
aTextRun
-
>
SetupClusterBoundaries
(
0
aString
aTextRun
-
>
GetLength
(
)
)
;
}
int32_t
gfxPlatform
:
:
GetBidiNumeralOption
(
)
{
if
(
mBidiNumeralOption
=
=
UNINITIALIZED_VALUE
)
{
mBidiNumeralOption
=
Preferences
:
:
GetInt
(
BIDI_NUMERAL_PREF
0
)
;
}
return
mBidiNumeralOption
;
}
void
gfxPlatform
:
:
FlushFontAndWordCaches
(
)
{
gfxFontCache
*
fontCache
=
gfxFontCache
:
:
GetCache
(
)
;
if
(
fontCache
)
{
fontCache
-
>
AgeAllGenerations
(
)
;
fontCache
-
>
FlushShapedWordCaches
(
)
;
}
gfxPlatform
:
:
PurgeSkiaFontCache
(
)
;
}
void
gfxPlatform
:
:
ForceGlobalReflow
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
XRE_IsParentProcess
(
)
)
{
static
const
char
kPrefName
[
]
=
"
font
.
internaluseonly
.
changed
"
;
bool
fontInternalChange
=
Preferences
:
:
GetBool
(
kPrefName
false
)
;
Preferences
:
:
SetBool
(
kPrefName
!
fontInternalChange
)
;
}
else
{
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
nullptr
"
font
-
info
-
updated
"
nullptr
)
;
}
}
}
void
gfxPlatform
:
:
FontsPrefsChanged
(
const
char
*
aPref
)
{
NS_ASSERTION
(
aPref
!
=
nullptr
"
null
preference
"
)
;
if
(
!
strcmp
(
GFX_DOWNLOADABLE_FONTS_ENABLED
aPref
)
)
{
mAllowDownloadableFonts
=
UNINITIALIZED_VALUE
;
}
else
if
(
!
strcmp
(
GFX_PREF_FALLBACK_USE_CMAPS
aPref
)
)
{
mFallbackUsesCmaps
=
UNINITIALIZED_VALUE
;
}
else
if
(
!
strcmp
(
GFX_PREF_WORD_CACHE_CHARLIMIT
aPref
)
)
{
mWordCacheCharLimit
=
UNINITIALIZED_VALUE
;
FlushFontAndWordCaches
(
)
;
}
else
if
(
!
strcmp
(
GFX_PREF_WORD_CACHE_MAXENTRIES
aPref
)
)
{
mWordCacheMaxEntries
=
UNINITIALIZED_VALUE
;
FlushFontAndWordCaches
(
)
;
}
else
if
(
!
strcmp
(
GFX_PREF_GRAPHITE_SHAPING
aPref
)
)
{
mGraphiteShapingEnabled
=
UNINITIALIZED_VALUE
;
FlushFontAndWordCaches
(
)
;
}
else
if
(
!
strcmp
(
BIDI_NUMERAL_PREF
aPref
)
)
{
mBidiNumeralOption
=
UNINITIALIZED_VALUE
;
}
else
if
(
!
strcmp
(
GFX_PREF_OPENTYPE_SVG
aPref
)
)
{
mOpenTypeSVGEnabled
=
UNINITIALIZED_VALUE
;
gfxFontCache
:
:
GetCache
(
)
-
>
AgeAllGenerations
(
)
;
gfxFontCache
:
:
GetCache
(
)
-
>
NotifyGlyphsChanged
(
)
;
}
}
mozilla
:
:
LogModule
*
gfxPlatform
:
:
GetLog
(
eGfxLog
aWhichLog
)
{
static
LazyLogModule
sFontlistLog
(
"
fontlist
"
)
;
static
LazyLogModule
sFontInitLog
(
"
fontinit
"
)
;
static
LazyLogModule
sTextrunLog
(
"
textrun
"
)
;
static
LazyLogModule
sTextrunuiLog
(
"
textrunui
"
)
;
static
LazyLogModule
sCmapDataLog
(
"
cmapdata
"
)
;
static
LazyLogModule
sTextPerfLog
(
"
textperf
"
)
;
switch
(
aWhichLog
)
{
case
eGfxLog_fontlist
:
return
sFontlistLog
;
case
eGfxLog_fontinit
:
return
sFontInitLog
;
case
eGfxLog_textrun
:
return
sTextrunLog
;
case
eGfxLog_textrunui
:
return
sTextrunuiLog
;
case
eGfxLog_cmapdata
:
return
sCmapDataLog
;
case
eGfxLog_textperf
:
return
sTextPerfLog
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
log
type
"
)
;
return
nullptr
;
}
RefPtr
<
mozilla
:
:
gfx
:
:
DrawTarget
>
gfxPlatform
:
:
ScreenReferenceDrawTarget
(
)
{
return
(
mScreenReferenceDrawTarget
)
?
mScreenReferenceDrawTarget
:
gPlatform
-
>
CreateOffscreenContentDrawTarget
(
IntSize
(
1
1
)
SurfaceFormat
:
:
B8G8R8A8
true
)
;
}
mozilla
:
:
gfx
:
:
SurfaceFormat
gfxPlatform
:
:
Optimal2DFormatForContent
(
gfxContentType
aContent
)
{
switch
(
aContent
)
{
case
gfxContentType
:
:
COLOR
:
switch
(
GetOffscreenFormat
(
)
)
{
case
SurfaceFormat
:
:
A8R8G8B8_UINT32
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
case
SurfaceFormat
:
:
X8R8G8B8_UINT32
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8X8
;
case
SurfaceFormat
:
:
R5G6B5_UINT16
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
R5G6B5_UINT16
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unknown
gfxImageFormat
for
"
"
gfxContentType
:
:
COLOR
"
)
;
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
}
case
gfxContentType
:
:
ALPHA
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
A8
;
case
gfxContentType
:
:
COLOR_ALPHA
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unknown
gfxContentType
"
)
;
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
}
}
gfxImageFormat
gfxPlatform
:
:
OptimalFormatForContent
(
gfxContentType
aContent
)
{
switch
(
aContent
)
{
case
gfxContentType
:
:
COLOR
:
return
GetOffscreenFormat
(
)
;
case
gfxContentType
:
:
ALPHA
:
return
SurfaceFormat
:
:
A8
;
case
gfxContentType
:
:
COLOR_ALPHA
:
return
SurfaceFormat
:
:
A8R8G8B8_UINT32
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unknown
gfxContentType
"
)
;
return
SurfaceFormat
:
:
A8R8G8B8_UINT32
;
}
}
static
mozilla
:
:
Atomic
<
bool
>
sLayersSupportsHardwareVideoDecoding
(
false
)
;
static
bool
sLayersHardwareVideoDecodingFailed
=
false
;
static
bool
sBufferRotationCheckPref
=
true
;
static
mozilla
:
:
Atomic
<
bool
>
sLayersAccelerationPrefsInitialized
(
false
)
;
void
VideoDecodingFailedChangedCallback
(
const
char
*
aPref
void
*
)
{
sLayersHardwareVideoDecodingFailed
=
Preferences
:
:
GetBool
(
aPref
false
)
;
gfxPlatform
:
:
GetPlatform
(
)
-
>
UpdateCanUseHardwareVideoDecoding
(
)
;
}
void
gfxPlatform
:
:
UpdateCanUseHardwareVideoDecoding
(
)
{
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetCanUseHardwareVideoDecoding
(
CanUseHardwareVideoDecoding
(
)
)
;
}
}
void
gfxPlatform
:
:
InitAcceleration
(
)
{
if
(
sLayersAccelerationPrefsInitialized
)
{
return
;
}
InitCompositorAccelerationPrefs
(
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
can
only
initialize
prefs
on
the
main
thread
"
)
;
gfxPrefs
:
:
GetSingleton
(
)
;
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
nsCString
discardFailureId
;
int32_t
status
;
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetBrowserTabsRemoteAutostart
(
BrowserTabsRemoteAutostart
(
)
)
;
gfxVars
:
:
SetOffscreenFormat
(
GetOffscreenFormat
(
)
)
;
gfxVars
:
:
SetRequiresAcceleratedGLContextForCompositorOGL
(
RequiresAcceleratedGLContextForCompositorOGL
(
)
)
;
#
ifdef
XP_WIN
if
(
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_D3D11_KEYED_MUTEX
discardFailureId
&
status
)
)
)
{
gfxVars
:
:
SetAllowD3D11KeyedMutex
(
status
=
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
)
;
}
else
{
gfxCriticalNote
<
<
"
Cannot
evaluate
keyed
mutex
feature
status
"
;
gfxVars
:
:
SetAllowD3D11KeyedMutex
(
true
)
;
}
#
endif
}
if
(
Preferences
:
:
GetBool
(
"
media
.
hardware
-
video
-
decoding
.
enabled
"
false
)
&
&
#
ifdef
XP_WIN
Preferences
:
:
GetBool
(
"
media
.
wmf
.
dxva
.
enabled
"
true
)
&
&
#
endif
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_HARDWARE_VIDEO_DECODING
discardFailureId
&
status
)
)
)
{
if
(
status
=
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
|
|
gfxPrefs
:
:
HardwareVideoDecodingForceEnabled
(
)
)
{
sLayersSupportsHardwareVideoDecoding
=
true
;
}
}
sLayersAccelerationPrefsInitialized
=
true
;
if
(
XRE_IsParentProcess
(
)
)
{
Preferences
:
:
RegisterCallbackAndCall
(
VideoDecodingFailedChangedCallback
"
media
.
hardware
-
video
-
decoding
.
failed
"
)
;
InitGPUProcessPrefs
(
)
;
}
}
void
gfxPlatform
:
:
InitGPUProcessPrefs
(
)
{
if
(
!
gfxPrefs
:
:
GPUProcessEnabled
(
)
&
&
!
gfxPrefs
:
:
GPUProcessForceEnabled
(
)
)
{
return
;
}
FeatureState
&
gpuProc
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
GPU_PROCESS
)
;
if
(
!
BrowserTabsRemoteAutostart
(
)
)
{
gpuProc
.
DisableByDefault
(
FeatureStatus
:
:
Unavailable
"
Multi
-
process
mode
is
not
enabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_NO_E10S
"
)
)
;
}
else
{
gpuProc
.
SetDefaultFromPref
(
gfxPrefs
:
:
GetGPUProcessEnabledPrefName
(
)
true
gfxPrefs
:
:
GetGPUProcessEnabledPrefDefault
(
)
)
;
}
if
(
gfxPrefs
:
:
GPUProcessForceEnabled
(
)
)
{
gpuProc
.
UserForceEnable
(
"
User
force
-
enabled
via
pref
"
)
;
}
if
(
IsHeadless
(
)
)
{
gpuProc
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
Headless
mode
is
enabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_HEADLESS_MODE
"
)
)
;
return
;
}
if
(
InSafeMode
(
)
)
{
gpuProc
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
Safe
-
mode
is
enabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_SAFE_MODE
"
)
)
;
return
;
}
if
(
gfxPrefs
:
:
LayerScopeEnabled
(
)
)
{
gpuProc
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
LayerScope
does
not
work
in
the
GPU
process
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_LAYERSCOPE
"
)
)
;
return
;
}
}
void
gfxPlatform
:
:
InitCompositorAccelerationPrefs
(
)
{
const
char
*
acceleratedEnv
=
PR_GetEnv
(
"
MOZ_ACCELERATED
"
)
;
FeatureState
&
feature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
HW_COMPOSITING
)
;
if
(
feature
.
SetDefault
(
AccelerateLayersByDefault
(
)
FeatureStatus
:
:
Blocked
"
Acceleration
blocked
by
platform
"
)
)
{
if
(
gfxPrefs
:
:
LayersAccelerationDisabledDoNotUseDirectly
(
)
)
{
feature
.
UserDisable
(
"
Disabled
by
pref
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_PREF
"
)
)
;
}
else
if
(
acceleratedEnv
&
&
*
acceleratedEnv
=
=
'
0
'
)
{
feature
.
UserDisable
(
"
Disabled
by
envvar
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_ENV
"
)
)
;
}
}
else
{
if
(
acceleratedEnv
&
&
*
acceleratedEnv
=
=
'
1
'
)
{
feature
.
UserEnable
(
"
Enabled
by
envvar
"
)
;
}
}
if
(
gfxPrefs
:
:
LayersAccelerationForceEnabledDoNotUseDirectly
(
)
)
{
feature
.
UserForceEnable
(
"
Force
-
enabled
by
pref
"
)
;
}
if
(
InSafeMode
(
)
)
{
feature
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
Acceleration
blocked
by
safe
-
mode
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_SAFEMODE
"
)
)
;
}
if
(
IsHeadless
(
)
)
{
feature
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
Acceleration
blocked
by
headless
mode
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_HEADLESSMODE
"
)
)
;
}
if
(
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
feature
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
Acceleration
blocked
by
recording
/
replaying
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_RECORDREPLAY
"
)
)
;
}
}
bool
gfxPlatform
:
:
WebRenderPrefEnabled
(
)
{
return
gfxPrefs
:
:
WebRenderAll
(
)
|
|
gfxPrefs
:
:
WebRenderEnabledDoNotUseDirectly
(
)
;
}
bool
gfxPlatform
:
:
WebRenderEnvvarEnabled
(
)
{
const
char
*
env
=
PR_GetEnv
(
"
MOZ_WEBRENDER
"
)
;
return
(
env
&
&
*
env
=
=
'
1
'
)
;
}
static
bool
WebRenderEnvvarDisabled
(
)
{
const
char
*
env
=
PR_GetEnv
(
"
MOZ_WEBRENDER
"
)
;
return
(
env
&
&
*
env
=
=
'
0
'
)
;
}
static
bool
CalculateWrQualifiedPrefValue
(
)
{
auto
clearPrefOnExit
=
MakeScopeExit
(
[
]
(
)
{
Preferences
:
:
ClearUser
(
WR_ROLLOUT_PREF_DEFAULT
)
;
}
)
;
if
(
!
Preferences
:
:
HasUserValue
(
WR_ROLLOUT_PREF
)
&
&
Preferences
:
:
HasUserValue
(
WR_ROLLOUT_PREF_DEFAULT
)
)
{
return
gfxPrefs
:
:
WebRenderAllQualifiedDefault
(
)
;
}
if
(
Preferences
:
:
HasUserValue
(
WR_ROLLOUT_PREF_OVERRIDE
)
)
{
return
Preferences
:
:
GetBool
(
WR_ROLLOUT_PREF_OVERRIDE
)
;
}
return
gfxPrefs
:
:
WebRenderAllQualified
(
)
;
}
static
FeatureState
&
WebRenderHardwareQualificationStatus
(
bool
aHasBattery
nsCString
&
aOutFailureId
)
{
FeatureState
&
featureWebRenderQualified
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
WEBRENDER_QUALIFIED
)
;
featureWebRenderQualified
.
EnableByDefault
(
)
;
if
(
Preferences
:
:
HasUserValue
(
WR_ROLLOUT_HW_QUALIFIED_OVERRIDE
)
)
{
if
(
!
Preferences
:
:
GetBool
(
WR_ROLLOUT_HW_QUALIFIED_OVERRIDE
)
)
{
featureWebRenderQualified
.
Disable
(
FeatureStatus
:
:
Blocked
"
HW
qualification
pref
override
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_WR_QUALIFICATION_OVERRIDE
"
)
)
;
}
return
featureWebRenderQualified
;
}
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
int32_t
status
;
if
(
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_WEBRENDER
aOutFailureId
&
status
)
)
)
{
if
(
status
!
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
)
{
featureWebRenderQualified
.
Disable
(
FeatureStatus
:
:
Blocked
"
No
qualified
hardware
"
aOutFailureId
)
;
}
else
if
(
aHasBattery
)
{
featureWebRenderQualified
.
Disable
(
FeatureStatus
:
:
Blocked
"
Has
battery
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_WR_HAS_BATTERY
"
)
)
;
}
else
{
nsAutoString
adapterVendorID
;
gfxInfo
-
>
GetAdapterVendorID
(
adapterVendorID
)
;
nsAutoString
adapterDeviceID
;
gfxInfo
-
>
GetAdapterDeviceID
(
adapterDeviceID
)
;
nsresult
valid
;
int32_t
deviceID
=
adapterDeviceID
.
ToInteger
(
&
valid
16
)
;
if
(
valid
!
=
NS_OK
)
{
featureWebRenderQualified
.
Disable
(
FeatureStatus
:
:
Blocked
"
Bad
device
id
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_BAD_DEVICE_ID
"
)
)
;
}
else
{
if
(
adapterVendorID
=
=
u
"
0x10de
"
)
{
if
(
deviceID
<
0x6c0
)
{
featureWebRenderQualified
.
Disable
(
FeatureStatus
:
:
Blocked
"
Device
too
old
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_DEVICE_TOO_OLD
"
)
)
;
}
#
ifdef
NIGHTLY_BUILD
}
else
if
(
adapterVendorID
=
=
u
"
0x1002
"
)
{
if
(
(
deviceID
>
=
0x6640
&
&
deviceID
<
0x6660
)
|
|
(
deviceID
>
=
0x67a0
&
&
deviceID
<
0x6800
)
|
|
(
deviceID
>
=
0x6860
&
&
deviceID
<
0x6880
)
|
|
(
deviceID
>
=
0x6900
&
&
deviceID
<
0x6a00
)
|
|
(
deviceID
=
=
0x7300
)
|
|
(
deviceID
>
=
0x9830
&
&
deviceID
<
0x9870
)
)
{
}
else
{
featureWebRenderQualified
.
Disable
(
FeatureStatus
:
:
Blocked
"
Device
too
old
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_DEVICE_TOO_OLD
"
)
)
;
}
}
else
if
(
adapterVendorID
=
=
u
"
0x8086
"
)
{
const
uint16_t
supportedDevices
[
]
=
{
0x191d
0x192d
0x1912
0x5912
0x3e92
}
;
bool
supported
=
false
;
for
(
uint16_t
id
:
supportedDevices
)
{
if
(
deviceID
=
=
id
)
{
supported
=
true
;
}
}
if
(
!
supported
)
{
featureWebRenderQualified
.
Disable
(
FeatureStatus
:
:
Blocked
"
Device
too
old
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_DEVICE_TOO_OLD
"
)
)
;
}
#
endif
}
else
{
featureWebRenderQualified
.
Disable
(
FeatureStatus
:
:
Blocked
"
Unsupported
vendor
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_UNSUPPORTED_VENDOR
"
)
)
;
}
}
}
}
else
{
featureWebRenderQualified
.
Disable
(
FeatureStatus
:
:
Blocked
"
gfxInfo
is
broken
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_WR_NO_GFX_INFO
"
)
)
;
}
return
featureWebRenderQualified
;
}
void
gfxPlatform
:
:
InitWebRenderConfig
(
)
{
bool
prefEnabled
=
WebRenderPrefEnabled
(
)
;
bool
envvarEnabled
=
WebRenderEnvvarEnabled
(
)
;
ScopedGfxFeatureReporter
reporter
(
"
WR
"
prefEnabled
|
|
envvarEnabled
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
if
(
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
gfxVars
:
:
SetUseWebRender
(
false
)
;
}
if
(
gfxVars
:
:
UseWebRender
(
)
)
{
reporter
.
SetSuccessful
(
)
;
}
return
;
}
nsCString
failureId
;
FeatureState
&
featureWebRenderQualified
=
WebRenderHardwareQualificationStatus
(
HasBattery
(
)
failureId
)
;
FeatureState
&
featureWebRender
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
WEBRENDER
)
;
featureWebRender
.
DisableByDefault
(
FeatureStatus
:
:
OptIn
"
WebRender
is
an
opt
-
in
feature
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_DEFAULT_OFF
"
)
)
;
const
bool
wrQualifiedAll
=
CalculateWrQualifiedPrefValue
(
)
;
if
(
envvarEnabled
)
{
featureWebRender
.
UserEnable
(
"
Force
enabled
by
envvar
"
)
;
}
else
if
(
prefEnabled
)
{
featureWebRender
.
UserEnable
(
"
Force
enabled
by
pref
"
)
;
}
else
if
(
wrQualifiedAll
&
&
featureWebRenderQualified
.
IsEnabled
(
)
)
{
featureWebRender
.
UserEnable
(
"
Qualified
enabled
by
pref
"
)
;
}
if
(
gfxPrefs
:
:
WebRenderForceDisabled
(
)
|
|
WebRenderEnvvarDisabled
(
)
)
{
featureWebRender
.
UserDisable
(
"
User
force
-
disabled
WR
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_USER_FORCE_DISABLED
"
)
)
;
}
if
(
!
gfxConfig
:
:
IsEnabled
(
Feature
:
:
HW_COMPOSITING
)
)
{
featureWebRender
.
ForceDisable
(
FeatureStatus
:
:
Unavailable
"
Hardware
compositing
is
disabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_WEBRENDER_NEED_HWCOMP
"
)
)
;
}
#
ifdef
XP_WIN
if
(
!
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
)
{
featureWebRender
.
ForceDisable
(
FeatureStatus
:
:
Unavailable
"
GPU
Process
is
disabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_GPU_PROCESS_DISABLED
"
)
)
;
}
#
endif
if
(
InSafeMode
(
)
)
{
featureWebRender
.
ForceDisable
(
FeatureStatus
:
:
Unavailable
"
Safe
-
mode
is
enabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_SAFE_MODE
"
)
)
;
}
#
ifndef
MOZ_BUILD_WEBRENDER
featureWebRender
.
ForceDisable
(
FeatureStatus
:
:
Unavailable
"
Build
doesn
'
t
include
WebRender
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_NO_WEBRENDER
"
)
)
;
#
endif
#
ifdef
XP_WIN
if
(
Preferences
:
:
GetBool
(
"
gfx
.
webrender
.
force
-
angle
"
false
)
)
{
if
(
!
gfxConfig
:
:
IsEnabled
(
Feature
:
:
D3D11_HW_ANGLE
)
)
{
featureWebRender
.
ForceDisable
(
FeatureStatus
:
:
Unavailable
"
ANGLE
is
disabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_ANGLE_DISABLED
"
)
)
;
}
else
{
gfxVars
:
:
SetUseWebRenderANGLE
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER
)
)
;
}
}
#
endif
if
(
Preferences
:
:
GetBool
(
"
gfx
.
webrender
.
program
-
binary
"
false
)
)
{
gfxVars
:
:
SetUseWebRenderProgramBinary
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER
)
)
;
if
(
Preferences
:
:
GetBool
(
"
gfx
.
webrender
.
program
-
binary
-
disk
"
false
)
)
{
gfxVars
:
:
SetUseWebRenderProgramBinaryDisk
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER
)
)
;
}
}
#
ifdef
MOZ_WIDGET_ANDROID
if
(
jni
:
:
IsFennec
(
)
)
{
featureWebRender
.
ForceDisable
(
FeatureStatus
:
:
Unavailable
"
WebRender
not
ready
for
use
on
non
-
e10s
Android
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_ANDROID
"
)
)
;
}
#
endif
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER
)
)
{
gfxVars
:
:
SetUseWebRender
(
true
)
;
reporter
.
SetSuccessful
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
Preferences
:
:
RegisterPrefixCallbackAndCall
(
WebRenderDebugPrefChangeCallback
WR_DEBUG_PREF
)
;
}
}
#
ifdef
XP_WIN
if
(
Preferences
:
:
GetBool
(
"
gfx
.
webrender
.
dcomp
-
win
.
enabled
"
false
)
)
{
if
(
IsWin10OrLater
(
)
&
&
gfxVars
:
:
UseWebRender
(
)
&
&
gfxVars
:
:
UseWebRenderANGLE
(
)
)
{
gfxVars
:
:
SetUseWebRenderDCompWin
(
true
)
;
}
}
if
(
Preferences
:
:
GetBool
(
"
gfx
.
webrender
.
dcomp
-
win
-
triple
-
buffering
.
enabled
"
false
)
)
{
if
(
gfxVars
:
:
UseWebRenderDCompWin
(
)
)
{
gfxVars
:
:
SetUseWebRenderDCompWinTripleBuffering
(
true
)
;
}
}
#
endif
}
void
gfxPlatform
:
:
InitOMTPConfig
(
)
{
ScopedGfxFeatureReporter
reporter
(
"
OMTP
"
)
;
FeatureState
&
omtp
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
OMTP
)
;
int32_t
paintWorkerCount
=
PaintThread
:
:
CalculatePaintWorkerCount
(
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
if
(
gfxVars
:
:
UseOMTP
(
)
)
{
reporter
.
SetSuccessful
(
paintWorkerCount
)
;
}
return
;
}
omtp
.
SetDefaultFromPref
(
"
layers
.
omtp
.
enabled
"
true
Preferences
:
:
GetBool
(
"
layers
.
omtp
.
enabled
"
false
PrefValueKind
:
:
Default
)
)
;
if
(
mContentBackend
=
=
BackendType
:
:
CAIRO
)
{
omtp
.
ForceDisable
(
FeatureStatus
:
:
Broken
"
OMTP
is
not
supported
when
using
cairo
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_PREF
"
)
)
;
}
#
ifdef
XP_MACOSX
if
(
!
nsCocoaFeatures
:
:
OnYosemiteOrLater
(
)
)
{
omtp
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
OMTP
blocked
before
OSX
10
.
10
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_OMTP_OSX_MAVERICKS
"
)
)
;
}
#
endif
if
(
InSafeMode
(
)
)
{
omtp
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
OMTP
blocked
by
safe
-
mode
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_SAFEMODE
"
)
)
;
}
if
(
omtp
.
IsEnabled
(
)
)
{
gfxVars
:
:
SetUseOMTP
(
true
)
;
reporter
.
SetSuccessful
(
paintWorkerCount
)
;
}
}
bool
gfxPlatform
:
:
CanUseHardwareVideoDecoding
(
)
{
MOZ_ASSERT
(
sLayersAccelerationPrefsInitialized
)
;
return
sLayersSupportsHardwareVideoDecoding
&
&
!
sLayersHardwareVideoDecodingFailed
;
}
bool
gfxPlatform
:
:
AccelerateLayersByDefault
(
)
{
#
if
defined
(
MOZ_GL_PROVIDER
)
|
|
defined
(
MOZ_WIDGET_UIKIT
)
return
true
;
#
else
return
false
;
#
endif
}
bool
gfxPlatform
:
:
BufferRotationEnabled
(
)
{
MutexAutoLock
autoLock
(
*
gGfxPlatformPrefsLock
)
;
return
sBufferRotationCheckPref
&
&
gfxPrefs
:
:
BufferRotationEnabled
(
)
;
}
void
gfxPlatform
:
:
DisableBufferRotation
(
)
{
MutexAutoLock
autoLock
(
*
gGfxPlatformPrefsLock
)
;
sBufferRotationCheckPref
=
false
;
}
bool
gfxPlatform
:
:
UsesOffMainThreadCompositing
(
)
{
if
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_GPU
)
{
return
true
;
}
static
bool
firstTime
=
true
;
static
bool
result
=
false
;
if
(
firstTime
)
{
MOZ_ASSERT
(
sLayersAccelerationPrefsInitialized
)
;
result
=
gfxVars
:
:
BrowserTabsRemoteAutostart
(
)
|
|
!
gfxPrefs
:
:
LayersOffMainThreadCompositionForceDisabled
(
)
;
#
if
defined
(
MOZ_WIDGET_GTK
)
result
|
=
gfxPrefs
:
:
LayersAccelerationForceEnabledDoNotUseDirectly
(
)
;
#
endif
firstTime
=
false
;
}
return
result
;
}
bool
gfxPlatform
:
:
UsesTiling
(
)
const
{
bool
usesSkia
=
GetDefaultContentBackend
(
)
=
=
BackendType
:
:
SKIA
;
bool
usesPOMTP
=
XRE_IsContentProcess
(
)
&
&
gfxVars
:
:
UseOMTP
(
)
&
&
(
gfxPrefs
:
:
LayersOMTPPaintWorkers
(
)
=
=
-
1
|
|
gfxPrefs
:
:
LayersOMTPPaintWorkers
(
)
>
1
)
;
return
gfxPrefs
:
:
LayersTilesEnabled
(
)
|
|
(
gfxPrefs
:
:
LayersTilesEnabledIfSkiaPOMTP
(
)
&
&
usesSkia
&
&
usesPOMTP
)
;
}
bool
gfxPlatform
:
:
ContentUsesTiling
(
)
const
{
BackendPrefsData
data
=
GetBackendPrefs
(
)
;
BackendType
contentBackend
=
GetContentBackendPref
(
data
.
mContentBitmask
)
;
if
(
contentBackend
=
=
BackendType
:
:
NONE
)
{
contentBackend
=
data
.
mContentDefault
;
}
bool
contentUsesSkia
=
contentBackend
=
=
BackendType
:
:
SKIA
;
bool
contentUsesPOMTP
=
gfxVars
:
:
UseOMTP
(
)
&
&
(
gfxPrefs
:
:
LayersOMTPPaintWorkers
(
)
=
=
-
1
|
|
gfxPrefs
:
:
LayersOMTPPaintWorkers
(
)
>
1
)
;
return
gfxPrefs
:
:
LayersTilesEnabled
(
)
|
|
(
gfxPrefs
:
:
LayersTilesEnabledIfSkiaPOMTP
(
)
&
&
contentUsesSkia
&
&
contentUsesPOMTP
)
;
}
bool
gfxPlatform
:
:
ShouldAdjustForLowEndMachine
(
)
{
return
gfxPrefs
:
:
AdjustToMachine
(
)
&
&
!
gfxPrefs
:
:
ResistFingerprinting
(
)
&
&
gfxPrefs
:
:
IsLowEndMachineDoNotUseDirectly
(
)
;
}
already_AddRefed
<
mozilla
:
:
gfx
:
:
VsyncSource
>
gfxPlatform
:
:
CreateHardwareVsyncSource
(
)
{
RefPtr
<
mozilla
:
:
gfx
:
:
VsyncSource
>
softwareVsync
=
new
SoftwareVsyncSource
(
)
;
return
softwareVsync
.
forget
(
)
;
}
bool
gfxPlatform
:
:
IsInLayoutAsapMode
(
)
{
return
gfxPrefs
:
:
LayoutFrameRate
(
)
=
=
0
;
}
bool
gfxPlatform
:
:
ForceSoftwareVsync
(
)
{
return
ShouldAdjustForLowEndMachine
(
)
|
|
gfxPrefs
:
:
LayoutFrameRate
(
)
>
0
|
|
recordreplay
:
:
IsRecordingOrReplaying
(
)
;
}
int
gfxPlatform
:
:
GetSoftwareVsyncRate
(
)
{
int
preferenceRate
=
gfxPrefs
:
:
LayoutFrameRate
(
)
;
if
(
preferenceRate
<
=
0
)
{
return
gfxPlatform
:
:
GetDefaultFrameRate
(
)
;
}
return
preferenceRate
;
}
int
gfxPlatform
:
:
GetDefaultFrameRate
(
)
{
return
ShouldAdjustForLowEndMachine
(
)
?
30
:
60
;
}
void
gfxPlatform
:
:
ReInitFrameRate
(
)
{
if
(
XRE_IsParentProcess
(
)
|
|
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
RefPtr
<
VsyncSource
>
oldSource
=
gPlatform
-
>
mVsyncSource
;
if
(
gfxPlatform
:
:
ForceSoftwareVsync
(
)
)
{
gPlatform
-
>
mVsyncSource
=
(
gPlatform
)
-
>
gfxPlatform
:
:
CreateHardwareVsyncSource
(
)
;
}
else
{
gPlatform
-
>
mVsyncSource
=
gPlatform
-
>
CreateHardwareVsyncSource
(
)
;
}
if
(
oldSource
)
{
oldSource
-
>
MoveListenersToNewSource
(
gPlatform
-
>
mVsyncSource
)
;
oldSource
-
>
Shutdown
(
)
;
}
}
}
void
gfxPlatform
:
:
GetAzureBackendInfo
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
)
{
aObj
.
DefineProperty
(
"
AzureCanvasBackend
(
UI
Process
)
"
GetBackendName
(
mPreferredCanvasBackend
)
)
;
aObj
.
DefineProperty
(
"
AzureFallbackCanvasBackend
(
UI
Process
)
"
GetBackendName
(
mFallbackCanvasBackend
)
)
;
aObj
.
DefineProperty
(
"
AzureContentBackend
(
UI
Process
)
"
GetBackendName
(
mContentBackend
)
)
;
BackendPrefsData
data
=
GetBackendPrefs
(
)
;
BackendType
canvasBackend
=
GetCanvasBackendPref
(
data
.
mCanvasBitmask
)
;
if
(
canvasBackend
=
=
BackendType
:
:
NONE
)
{
canvasBackend
=
data
.
mCanvasDefault
;
}
BackendType
contentBackend
=
GetContentBackendPref
(
data
.
mContentBitmask
)
;
if
(
contentBackend
=
=
BackendType
:
:
NONE
)
{
contentBackend
=
data
.
mContentDefault
;
}
aObj
.
DefineProperty
(
"
AzureCanvasBackend
"
GetBackendName
(
canvasBackend
)
)
;
aObj
.
DefineProperty
(
"
AzureContentBackend
"
GetBackendName
(
contentBackend
)
)
;
}
else
{
aObj
.
DefineProperty
(
"
AzureCanvasBackend
"
GetBackendName
(
mPreferredCanvasBackend
)
)
;
aObj
.
DefineProperty
(
"
AzureFallbackCanvasBackend
"
GetBackendName
(
mFallbackCanvasBackend
)
)
;
aObj
.
DefineProperty
(
"
AzureContentBackend
"
GetBackendName
(
mContentBackend
)
)
;
}
aObj
.
DefineProperty
(
"
AzureCanvasAccelerated
"
AllowOpenGLCanvas
(
)
)
;
}
void
gfxPlatform
:
:
GetApzSupportInfo
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
if
(
!
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
)
{
return
;
}
if
(
SupportsApzWheelInput
(
)
)
{
aObj
.
DefineProperty
(
"
ApzWheelInput
"
1
)
;
}
if
(
SupportsApzTouchInput
(
)
)
{
aObj
.
DefineProperty
(
"
ApzTouchInput
"
1
)
;
}
if
(
SupportsApzDragInput
(
)
)
{
aObj
.
DefineProperty
(
"
ApzDragInput
"
1
)
;
}
if
(
SupportsApzKeyboardInput
(
)
&
&
!
gfxPrefs
:
:
AccessibilityBrowseWithCaret
(
)
)
{
aObj
.
DefineProperty
(
"
ApzKeyboardInput
"
1
)
;
}
if
(
SupportsApzAutoscrolling
(
)
)
{
aObj
.
DefineProperty
(
"
ApzAutoscrollInput
"
1
)
;
}
}
void
gfxPlatform
:
:
GetTilesSupportInfo
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
if
(
!
gfxPrefs
:
:
LayersTilesEnabled
(
)
)
{
return
;
}
IntSize
tileSize
=
gfxVars
:
:
TileSize
(
)
;
aObj
.
DefineProperty
(
"
TileHeight
"
tileSize
.
height
)
;
aObj
.
DefineProperty
(
"
TileWidth
"
tileSize
.
width
)
;
}
void
gfxPlatform
:
:
GetFrameStats
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
uint32_t
i
=
0
;
for
(
FrameStats
&
f
:
mFrameStats
)
{
nsPrintfCString
name
(
"
Slow
Frame
#
%
02u
"
+
+
i
)
;
nsPrintfCString
value
(
"
Frame
%
"
PRIu64
"
(
%
s
)
CONTENT_FRAME_TIME
%
d
-
Transaction
start
%
f
main
-
thread
time
"
"
%
f
full
paint
time
%
f
Skipped
composites
%
u
Composite
start
%
f
"
"
Resource
upload
time
%
f
GPU
cache
upload
time
%
f
Render
time
%
f
"
"
Composite
time
%
f
"
f
.
id
(
)
.
mId
f
.
url
(
)
.
get
(
)
f
.
contentFrameTime
(
)
(
f
.
transactionStart
(
)
-
f
.
refreshStart
(
)
)
.
ToMilliseconds
(
)
(
f
.
fwdTime
(
)
-
f
.
transactionStart
(
)
)
.
ToMilliseconds
(
)
f
.
sceneBuiltTime
(
)
?
(
f
.
sceneBuiltTime
(
)
-
f
.
transactionStart
(
)
)
.
ToMilliseconds
(
)
:
0
.
0
f
.
skippedComposites
(
)
(
f
.
compositeStart
(
)
-
f
.
refreshStart
(
)
)
.
ToMilliseconds
(
)
f
.
resourceUploadTime
(
)
f
.
gpuCacheUploadTime
(
)
(
f
.
compositeEnd
(
)
-
f
.
renderStart
(
)
)
.
ToMilliseconds
(
)
(
f
.
compositeEnd
(
)
-
f
.
compositeStart
(
)
)
.
ToMilliseconds
(
)
)
;
aObj
.
DefineProperty
(
name
.
get
(
)
value
.
get
(
)
)
;
}
}
class
FrameStatsComparator
{
public
:
bool
Equals
(
const
FrameStats
&
aA
const
FrameStats
&
aB
)
const
{
return
aA
.
contentFrameTime
(
)
=
=
aB
.
contentFrameTime
(
)
;
}
bool
LessThan
(
const
FrameStats
&
aA
const
FrameStats
&
aB
)
const
{
return
aA
.
contentFrameTime
(
)
>
aB
.
contentFrameTime
(
)
;
}
}
;
void
gfxPlatform
:
:
NotifyFrameStats
(
nsTArray
<
FrameStats
>
&
&
aFrameStats
)
{
FrameStatsComparator
comp
;
for
(
FrameStats
&
f
:
aFrameStats
)
{
mFrameStats
.
InsertElementSorted
(
f
comp
)
;
}
if
(
mFrameStats
.
Length
(
)
>
10
)
{
mFrameStats
.
SetLength
(
10
)
;
}
}
uint32_t
gfxPlatform
:
:
TargetFrameRate
(
)
{
if
(
gPlatform
&
&
gPlatform
-
>
mVsyncSource
)
{
VsyncSource
:
:
Display
&
display
=
gPlatform
-
>
mVsyncSource
-
>
GetGlobalDisplay
(
)
;
return
round
(
1000
.
0
/
display
.
GetVsyncRate
(
)
.
ToMilliseconds
(
)
)
;
}
return
0
;
}
bool
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
{
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
&
&
!
defined
(
MOZ_WIDGET_UIKIT
)
if
(
!
BrowserTabsRemoteAutostart
(
)
)
{
return
false
;
}
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
return
true
;
#
else
if
(
!
gfxPrefs
:
:
SingletonExists
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
gfxPrefs
:
:
GetSingleton
(
)
;
}
return
gfxPrefs
:
:
AsyncPanZoomEnabledDoNotUseDirectly
(
)
;
#
endif
}
bool
gfxPlatform
:
:
PerfWarnings
(
)
{
return
gfxPrefs
:
:
PerfWarnings
(
)
;
}
void
gfxPlatform
:
:
GetAcceleratedCompositorBackends
(
nsTArray
<
LayersBackend
>
&
aBackends
)
{
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
OPENGL_COMPOSITING
)
)
{
aBackends
.
AppendElement
(
LayersBackend
:
:
LAYERS_OPENGL
)
;
}
else
{
static
int
tell_me_once
=
0
;
if
(
!
tell_me_once
)
{
NS_WARNING
(
"
OpenGL
-
accelerated
layers
are
not
supported
on
this
system
"
)
;
tell_me_once
=
1
;
}
#
ifdef
MOZ_WIDGET_ANDROID
MOZ_CRASH
(
"
OpenGL
-
accelerated
layers
are
a
hard
requirement
on
this
platform
.
"
"
Cannot
continue
without
support
for
them
"
)
;
#
endif
}
}
void
gfxPlatform
:
:
GetCompositorBackends
(
bool
useAcceleration
nsTArray
<
mozilla
:
:
layers
:
:
LayersBackend
>
&
aBackends
)
{
if
(
useAcceleration
)
{
GetAcceleratedCompositorBackends
(
aBackends
)
;
}
aBackends
.
AppendElement
(
LayersBackend
:
:
LAYERS_BASIC
)
;
}
void
gfxPlatform
:
:
NotifyCompositorCreated
(
LayersBackend
aBackend
)
{
if
(
mCompositorBackend
=
=
aBackend
)
{
return
;
}
if
(
mCompositorBackend
!
=
LayersBackend
:
:
LAYERS_NONE
)
{
gfxCriticalNote
<
<
"
Compositors
might
be
mixed
(
"
<
<
int
(
mCompositorBackend
)
<
<
"
"
<
<
int
(
aBackend
)
<
<
"
)
"
;
}
mCompositorBackend
=
aBackend
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
gfxPlatform
:
:
NotifyCompositorCreated
"
[
]
{
if
(
nsCOMPtr
<
nsIObserverService
>
obsvc
=
services
:
:
GetObserverService
(
)
)
{
obsvc
-
>
NotifyObservers
(
nullptr
"
compositor
:
created
"
nullptr
)
;
}
}
)
)
;
}
void
gfxPlatform
:
:
NotifyGPUProcessDisabled
(
)
{
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER
)
)
{
gfxConfig
:
:
GetFeature
(
Feature
:
:
WEBRENDER
)
.
ForceDisable
(
FeatureStatus
:
:
Unavailable
"
GPU
Process
is
disabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_GPU_PROCESS_DISABLED
"
)
)
;
gfxVars
:
:
SetUseWebRender
(
false
)
;
}
}
void
gfxPlatform
:
:
FetchAndImportContentDeviceData
(
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
if
(
gContentDeviceInitData
)
{
ImportContentDeviceData
(
*
gContentDeviceInitData
)
;
return
;
}
mozilla
:
:
dom
:
:
ContentChild
*
cc
=
mozilla
:
:
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
mozilla
:
:
gfx
:
:
ContentDeviceData
data
;
cc
-
>
SendGetGraphicsDeviceInitData
(
&
data
)
;
ImportContentDeviceData
(
data
)
;
}
void
gfxPlatform
:
:
ImportContentDeviceData
(
const
mozilla
:
:
gfx
:
:
ContentDeviceData
&
aData
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
const
DevicePrefs
&
prefs
=
aData
.
prefs
(
)
;
gfxConfig
:
:
Inherit
(
Feature
:
:
HW_COMPOSITING
prefs
.
hwCompositing
(
)
)
;
gfxConfig
:
:
Inherit
(
Feature
:
:
OPENGL_COMPOSITING
prefs
.
oglCompositing
(
)
)
;
}
void
gfxPlatform
:
:
BuildContentDeviceData
(
mozilla
:
:
gfx
:
:
ContentDeviceData
*
aOut
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
GPUProcessManager
:
:
Get
(
)
-
>
EnsureGPUReady
(
)
;
aOut
-
>
prefs
(
)
.
hwCompositing
(
)
=
gfxConfig
:
:
GetValue
(
Feature
:
:
HW_COMPOSITING
)
;
aOut
-
>
prefs
(
)
.
oglCompositing
(
)
=
gfxConfig
:
:
GetValue
(
Feature
:
:
OPENGL_COMPOSITING
)
;
}
void
gfxPlatform
:
:
ImportGPUDeviceData
(
const
mozilla
:
:
gfx
:
:
GPUDeviceData
&
aData
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
gfxConfig
:
:
ImportChange
(
Feature
:
:
OPENGL_COMPOSITING
aData
.
oglCompositing
(
)
)
;
gfxConfig
:
:
ImportChange
(
Feature
:
:
ADVANCED_LAYERS
aData
.
advancedLayers
(
)
)
;
}
bool
gfxPlatform
:
:
SupportsApzTouchInput
(
)
const
{
return
dom
:
:
TouchEvent
:
:
PrefEnabled
(
nullptr
)
;
}
bool
gfxPlatform
:
:
SupportsApzDragInput
(
)
const
{
return
gfxPrefs
:
:
APZDragEnabled
(
)
;
}
bool
gfxPlatform
:
:
SupportsApzKeyboardInput
(
)
const
{
return
gfxPrefs
:
:
APZKeyboardEnabled
(
)
;
}
bool
gfxPlatform
:
:
SupportsApzAutoscrolling
(
)
const
{
return
gfxPrefs
:
:
APZAutoscrollEnabled
(
)
;
}
void
gfxPlatform
:
:
InitOpenGLConfig
(
)
{
#
ifdef
XP_WIN
if
(
!
Preferences
:
:
GetBool
(
"
layers
.
prefer
-
opengl
"
)
)
{
return
;
}
#
endif
FeatureState
&
openGLFeature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
OPENGL_COMPOSITING
)
;
if
(
!
gfxConfig
:
:
IsEnabled
(
Feature
:
:
HW_COMPOSITING
)
)
{
openGLFeature
.
DisableByDefault
(
FeatureStatus
:
:
Unavailable
"
Hardware
compositing
is
disabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_OPENGL_NEED_HWCOMP
"
)
)
;
return
;
}
#
ifdef
XP_WIN
openGLFeature
.
SetDefaultFromPref
(
gfxPrefs
:
:
GetLayersPreferOpenGLPrefName
(
)
true
gfxPrefs
:
:
GetLayersPreferOpenGLPrefDefault
(
)
)
;
#
else
openGLFeature
.
EnableByDefault
(
)
;
#
endif
if
(
gfxPrefs
:
:
LayersAccelerationForceEnabledDoNotUseDirectly
(
)
)
{
openGLFeature
.
UserForceEnable
(
"
Force
-
enabled
by
pref
"
)
;
return
;
}
nsCString
message
;
nsCString
failureId
;
if
(
!
IsGfxInfoStatusOkay
(
nsIGfxInfo
:
:
FEATURE_OPENGL_LAYERS
&
message
failureId
)
)
{
openGLFeature
.
Disable
(
FeatureStatus
:
:
Blacklisted
message
.
get
(
)
failureId
)
;
}
}
bool
gfxPlatform
:
:
IsGfxInfoStatusOkay
(
int32_t
aFeature
nsCString
*
aOutMessage
nsCString
&
aFailureId
)
{
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
if
(
!
gfxInfo
)
{
return
true
;
}
int32_t
status
;
if
(
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
aFeature
aFailureId
&
status
)
)
&
&
status
!
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
)
{
aOutMessage
-
>
AssignLiteral
(
"
#
BLOCKLIST_
"
)
;
aOutMessage
-
>
AppendASCII
(
aFailureId
.
get
(
)
)
;
return
false
;
}
return
true
;
}
