#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
webrender
/
RenderThread
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessManager
.
h
"
#
include
"
mozilla
/
gfx
/
GraphicsMessages
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
gfxCrashReporterUtils
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
gfxEnv
.
h
"
#
include
"
gfxTextRun
.
h
"
#
include
"
gfxConfig
.
h
"
#
include
"
MediaPrefs
.
h
"
#
ifdef
XP_WIN
#
include
<
process
.
h
>
#
define
getpid
_getpid
#
else
#
include
<
unistd
.
h
>
#
endif
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
gfxWindowsPlatform
.
h
"
#
elif
defined
(
XP_MACOSX
)
#
include
"
gfxPlatformMac
.
h
"
#
include
"
gfxQuartzSurface
.
h
"
#
elif
defined
(
MOZ_WIDGET_GTK
)
#
include
"
gfxPlatformGtk
.
h
"
#
elif
defined
(
ANDROID
)
#
include
"
gfxAndroidPlatform
.
h
"
#
endif
#
ifdef
XP_WIN
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
mozilla
/
gfx
/
DeviceManagerDx
.
h
"
#
endif
#
include
"
nsGkAtoms
.
h
"
#
include
"
gfxPlatformFontList
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxImageSurface
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
harfbuzz
/
hb
.
h
"
#
include
"
gfxGraphiteShaper
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxGradientCache
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
nsUnicodeRange
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
FrameMetrics
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
ifdef
MOZ_CRASHREPORTER
#
include
"
nsExceptionHandler
.
h
"
#
endif
#
include
"
nsWeakReference
.
h
"
#
include
"
cairo
.
h
"
#
include
"
qcms
.
h
"
#
include
"
imgITools
.
h
"
#
include
"
plstr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
GLContextProvider
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
TexturePoolOGL
.
h
"
#
endif
#
ifdef
USE_SKIA
#
ifdef
__GNUC__
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wshadow
"
#
endif
#
include
"
skia
/
include
/
core
/
SkGraphics
.
h
"
#
ifdef
USE_SKIA_GPU
#
include
"
skia
/
include
/
gpu
/
GrContext
.
h
"
#
include
"
skia
/
include
/
gpu
/
gl
/
GrGLInterface
.
h
"
#
include
"
SkiaGLGlue
.
h
"
#
endif
#
ifdef
MOZ_ENABLE_FREETYPE
#
include
"
skia
/
include
/
ports
/
SkTypeface_cairo
.
h
"
#
endif
#
ifdef
__GNUC__
#
pragma
GCC
diagnostic
pop
/
/
-
Wshadow
#
endif
static
const
uint32_t
kDefaultGlyphCacheSize
=
-
1
;
#
endif
#
if
!
defined
(
USE_SKIA
)
|
|
!
defined
(
USE_SKIA_GPU
)
class
mozilla
:
:
gl
:
:
SkiaGLGlue
:
public
GenericAtomicRefCounted
{
}
;
#
endif
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsIGfxInfo
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
VsyncSource
.
h
"
#
include
"
SoftwareVsyncSource
.
h
"
#
include
"
nscore
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
TouchEvent
.
h
"
#
include
"
gfxVR
.
h
"
#
include
"
VRManagerChild
.
h
"
#
include
"
mozilla
/
gfx
/
GPUParent
.
h
"
#
include
"
prsystem
.
h
"
namespace
mozilla
{
namespace
layers
{
void
ShutdownTileCache
(
)
;
}
}
using
namespace
mozilla
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
gl
;
using
namespace
mozilla
:
:
gfx
;
gfxPlatform
*
gPlatform
=
nullptr
;
static
bool
gEverInitialized
=
false
;
const
ContentDeviceData
*
gContentDeviceInitData
=
nullptr
;
static
Mutex
*
gGfxPlatformPrefsLock
=
nullptr
;
static
qcms_profile
*
gCMSOutputProfile
=
nullptr
;
static
qcms_profile
*
gCMSsRGBProfile
=
nullptr
;
static
qcms_transform
*
gCMSRGBTransform
=
nullptr
;
static
qcms_transform
*
gCMSInverseRGBTransform
=
nullptr
;
static
qcms_transform
*
gCMSRGBATransform
=
nullptr
;
static
bool
gCMSInitialized
=
false
;
static
eCMSMode
gCMSMode
=
eCMSMode_Off
;
static
void
ShutdownCMS
(
)
;
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
SourceSurfaceCairo
.
h
"
using
namespace
mozilla
:
:
gfx
;
class
SRGBOverrideObserver
final
:
public
nsIObserver
public
nsSupportsWeakReference
{
~
SRGBOverrideObserver
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
}
;
class
CrashStatsLogForwarder
:
public
mozilla
:
:
gfx
:
:
LogForwarder
{
public
:
explicit
CrashStatsLogForwarder
(
const
char
*
aKey
)
;
void
Log
(
const
std
:
:
string
&
aString
)
override
;
void
CrashAction
(
LogReason
aReason
)
override
;
bool
UpdateStringsVector
(
const
std
:
:
string
&
aString
)
override
;
LoggingRecord
LoggingRecordCopy
(
)
override
;
void
SetCircularBufferSize
(
uint32_t
aCapacity
)
;
private
:
void
UpdateCrashReport
(
)
;
private
:
LoggingRecord
mBuffer
;
nsCString
mCrashCriticalKey
;
uint32_t
mMaxCapacity
;
int32_t
mIndex
;
Mutex
mMutex
;
}
;
CrashStatsLogForwarder
:
:
CrashStatsLogForwarder
(
const
char
*
aKey
)
:
mBuffer
(
)
mCrashCriticalKey
(
aKey
)
mMaxCapacity
(
0
)
mIndex
(
-
1
)
mMutex
(
"
CrashStatsLogForwarder
"
)
{
}
void
CrashStatsLogForwarder
:
:
SetCircularBufferSize
(
uint32_t
aCapacity
)
{
MutexAutoLock
lock
(
mMutex
)
;
mMaxCapacity
=
aCapacity
;
mBuffer
.
reserve
(
static_cast
<
size_t
>
(
aCapacity
)
)
;
}
LoggingRecord
CrashStatsLogForwarder
:
:
LoggingRecordCopy
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mBuffer
;
}
bool
CrashStatsLogForwarder
:
:
UpdateStringsVector
(
const
std
:
:
string
&
aString
)
{
if
(
mMaxCapacity
<
2
)
{
return
false
;
}
mIndex
+
=
1
;
MOZ_ASSERT
(
mIndex
>
=
0
)
;
int32_t
index
=
mIndex
?
(
mIndex
-
1
)
%
(
mMaxCapacity
-
1
)
+
1
:
0
;
MOZ_ASSERT
(
index
>
=
0
&
&
index
<
(
int32_t
)
mMaxCapacity
)
;
MOZ_ASSERT
(
index
<
=
mIndex
&
&
index
<
=
(
int32_t
)
mBuffer
.
size
(
)
)
;
double
tStamp
=
(
TimeStamp
:
:
NowLoRes
(
)
-
TimeStamp
:
:
ProcessCreation
(
)
)
.
ToSecondsSigDigits
(
)
;
LoggingRecordEntry
newEntry
(
mIndex
aString
tStamp
)
;
if
(
index
>
=
static_cast
<
int32_t
>
(
mBuffer
.
size
(
)
)
)
{
mBuffer
.
push_back
(
newEntry
)
;
}
else
{
mBuffer
[
index
]
=
newEntry
;
}
return
true
;
}
void
CrashStatsLogForwarder
:
:
UpdateCrashReport
(
)
{
std
:
:
stringstream
message
;
std
:
:
string
logAnnotation
;
switch
(
XRE_GetProcessType
(
)
)
{
case
GeckoProcessType_Default
:
logAnnotation
=
"
|
[
"
;
break
;
case
GeckoProcessType_Content
:
logAnnotation
=
"
|
[
C
"
;
break
;
case
GeckoProcessType_GPU
:
logAnnotation
=
"
|
[
G
"
;
break
;
default
:
logAnnotation
=
"
|
[
X
"
;
break
;
}
for
(
auto
&
it
:
mBuffer
)
{
message
<
<
logAnnotation
<
<
Get
<
0
>
(
it
)
<
<
"
]
"
<
<
Get
<
1
>
(
it
)
<
<
"
(
t
=
"
<
<
Get
<
2
>
(
it
)
<
<
"
)
"
;
}
#
ifdef
MOZ_CRASHREPORTER
nsCString
reportString
(
message
.
str
(
)
.
c_str
(
)
)
;
nsresult
annotated
=
CrashReporter
:
:
AnnotateCrashReport
(
mCrashCriticalKey
reportString
)
;
#
else
nsresult
annotated
=
NS_ERROR_NOT_IMPLEMENTED
;
#
endif
if
(
annotated
!
=
NS_OK
)
{
printf
(
"
Crash
Annotation
%
s
:
%
s
"
mCrashCriticalKey
.
get
(
)
message
.
str
(
)
.
c_str
(
)
)
;
}
}
class
LogForwarderEvent
:
public
Runnable
{
~
LogForwarderEvent
(
)
override
=
default
;
NS_DECL_ISUPPORTS_INHERITED
explicit
LogForwarderEvent
(
const
nsCString
&
aMessage
)
:
mMessage
(
aMessage
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
&
&
(
XRE_IsContentProcess
(
)
|
|
XRE_IsGPUProcess
(
)
)
)
;
if
(
XRE_IsContentProcess
(
)
)
{
dom
:
:
ContentChild
*
cc
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
Unused
<
<
cc
-
>
SendGraphicsError
(
mMessage
)
;
}
else
if
(
XRE_IsGPUProcess
(
)
)
{
GPUParent
*
gp
=
GPUParent
:
:
GetSingleton
(
)
;
Unused
<
<
gp
-
>
SendGraphicsError
(
mMessage
)
;
}
return
NS_OK
;
}
protected
:
nsCString
mMessage
;
}
;
NS_IMPL_ISUPPORTS_INHERITED0
(
LogForwarderEvent
Runnable
)
;
void
CrashStatsLogForwarder
:
:
Log
(
const
std
:
:
string
&
aString
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
UpdateStringsVector
(
aString
)
)
{
UpdateCrashReport
(
)
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
nsCString
stringToSend
(
aString
.
c_str
(
)
)
;
if
(
NS_IsMainThread
(
)
)
{
if
(
XRE_IsContentProcess
(
)
)
{
dom
:
:
ContentChild
*
cc
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
Unused
<
<
cc
-
>
SendGraphicsError
(
stringToSend
)
;
}
else
if
(
XRE_IsGPUProcess
(
)
)
{
GPUParent
*
gp
=
GPUParent
:
:
GetSingleton
(
)
;
Unused
<
<
gp
-
>
SendGraphicsError
(
stringToSend
)
;
}
}
else
{
nsCOMPtr
<
nsIRunnable
>
r1
=
new
LogForwarderEvent
(
stringToSend
)
;
NS_DispatchToMainThread
(
r1
)
;
}
}
}
class
CrashTelemetryEvent
:
public
Runnable
{
~
CrashTelemetryEvent
(
)
override
=
default
;
NS_DECL_ISUPPORTS_INHERITED
explicit
CrashTelemetryEvent
(
uint32_t
aReason
)
:
mReason
(
aReason
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GFX_CRASH
mReason
)
;
return
NS_OK
;
}
protected
:
uint32_t
mReason
;
}
;
NS_IMPL_ISUPPORTS_INHERITED0
(
CrashTelemetryEvent
Runnable
)
;
void
CrashStatsLogForwarder
:
:
CrashAction
(
LogReason
aReason
)
{
#
ifndef
RELEASE_OR_BETA
static
bool
useTelemetry
=
gfxEnv
:
:
GfxDevCrashTelemetry
(
)
;
#
else
static
bool
useTelemetry
=
!
gfxEnv
:
:
GfxDevCrashMozCrash
(
)
;
#
endif
if
(
useTelemetry
)
{
if
(
NS_IsMainThread
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GFX_CRASH
(
uint32_t
)
aReason
)
;
}
else
{
nsCOMPtr
<
nsIRunnable
>
r1
=
new
CrashTelemetryEvent
(
(
uint32_t
)
aReason
)
;
NS_DispatchToMainThread
(
r1
)
;
}
}
else
{
MOZ_CRASH
(
"
GFX_CRASH
"
)
;
}
}
NS_IMPL_ISUPPORTS
(
SRGBOverrideObserver
nsIObserver
nsISupportsWeakReference
)
#
define
GFX_DOWNLOADABLE_FONTS_ENABLED
"
gfx
.
downloadable_fonts
.
enabled
"
#
define
GFX_PREF_FALLBACK_USE_CMAPS
"
gfx
.
font_rendering
.
fallback
.
always_use_cmaps
"
#
define
GFX_PREF_OPENTYPE_SVG
"
gfx
.
font_rendering
.
opentype_svg
.
enabled
"
#
define
GFX_PREF_WORD_CACHE_CHARLIMIT
"
gfx
.
font_rendering
.
wordcache
.
charlimit
"
#
define
GFX_PREF_WORD_CACHE_MAXENTRIES
"
gfx
.
font_rendering
.
wordcache
.
maxentries
"
#
define
GFX_PREF_GRAPHITE_SHAPING
"
gfx
.
font_rendering
.
graphite
.
enabled
"
#
define
BIDI_NUMERAL_PREF
"
bidi
.
numeral
"
#
define
GFX_PREF_CMS_FORCE_SRGB
"
gfx
.
color_management
.
force_srgb
"
NS_IMETHODIMP
SRGBOverrideObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
someData
)
{
NS_ASSERTION
(
NS_strcmp
(
someData
(
u
"
"
GFX_PREF_CMS_FORCE_SRGB
)
)
=
=
0
"
Restarting
CMS
on
wrong
pref
!
"
)
;
ShutdownCMS
(
)
;
gfxPlatform
:
:
CreateCMSOutputProfile
(
)
;
return
NS_OK
;
}
static
const
char
*
kObservedPrefs
[
]
=
{
"
gfx
.
downloadable_fonts
.
"
"
gfx
.
font_rendering
.
"
BIDI_NUMERAL_PREF
nullptr
}
;
class
FontPrefsObserver
final
:
public
nsIObserver
{
~
FontPrefsObserver
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
}
;
NS_IMPL_ISUPPORTS
(
FontPrefsObserver
nsIObserver
)
NS_IMETHODIMP
FontPrefsObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
someData
)
{
if
(
!
someData
)
{
NS_ERROR
(
"
font
pref
observer
code
broken
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
NS_ASSERTION
(
gfxPlatform
:
:
GetPlatform
(
)
"
the
singleton
instance
has
gone
"
)
;
gfxPlatform
:
:
GetPlatform
(
)
-
>
FontsPrefsChanged
(
NS_ConvertUTF16toUTF8
(
someData
)
.
get
(
)
)
;
return
NS_OK
;
}
class
MemoryPressureObserver
final
:
public
nsIObserver
{
~
MemoryPressureObserver
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
}
;
NS_IMPL_ISUPPORTS
(
MemoryPressureObserver
nsIObserver
)
NS_IMETHODIMP
MemoryPressureObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
someData
)
{
NS_ASSERTION
(
strcmp
(
aTopic
"
memory
-
pressure
"
)
=
=
0
"
unexpected
event
topic
"
)
;
Factory
:
:
PurgeAllCaches
(
)
;
gfxGradientCache
:
:
PurgeAllCaches
(
)
;
gfxPlatform
:
:
PurgeSkiaFontCache
(
)
;
gfxPlatform
:
:
GetPlatform
(
)
-
>
PurgeSkiaGPUCache
(
)
;
return
NS_OK
;
}
gfxPlatform
:
:
gfxPlatform
(
)
:
mAzureCanvasBackendCollector
(
this
&
gfxPlatform
:
:
GetAzureBackendInfo
)
mApzSupportCollector
(
this
&
gfxPlatform
:
:
GetApzSupportInfo
)
mTilesInfoCollector
(
this
&
gfxPlatform
:
:
GetTilesSupportInfo
)
mCompositorBackend
(
layers
:
:
LayersBackend
:
:
LAYERS_NONE
)
mScreenDepth
(
0
)
{
mAllowDownloadableFonts
=
UNINITIALIZED_VALUE
;
mFallbackUsesCmaps
=
UNINITIALIZED_VALUE
;
mWordCacheCharLimit
=
UNINITIALIZED_VALUE
;
mWordCacheMaxEntries
=
UNINITIALIZED_VALUE
;
mGraphiteShapingEnabled
=
UNINITIALIZED_VALUE
;
mOpenTypeSVGEnabled
=
UNINITIALIZED_VALUE
;
mBidiNumeralOption
=
UNINITIALIZED_VALUE
;
mSkiaGlue
=
nullptr
;
uint32_t
canvasMask
=
BackendTypeBit
(
BackendType
:
:
CAIRO
)
;
uint32_t
contentMask
=
BackendTypeBit
(
BackendType
:
:
CAIRO
)
;
#
ifdef
USE_SKIA
canvasMask
|
=
BackendTypeBit
(
BackendType
:
:
SKIA
)
;
contentMask
|
=
BackendTypeBit
(
BackendType
:
:
SKIA
)
;
#
endif
InitBackendPrefs
(
canvasMask
BackendType
:
:
CAIRO
contentMask
BackendType
:
:
CAIRO
)
;
mTotalSystemMemory
=
PR_GetPhysicalMemorySize
(
)
;
VRManager
:
:
ManagerInit
(
)
;
}
gfxPlatform
*
gfxPlatform
:
:
GetPlatform
(
)
{
if
(
!
gPlatform
)
{
MOZ_RELEASE_ASSERT
(
!
XRE_IsContentProcess
(
)
"
Content
Process
should
have
called
InitChild
(
)
before
first
GetPlatform
(
)
"
)
;
Init
(
)
;
}
return
gPlatform
;
}
bool
gfxPlatform
:
:
Initialized
(
)
{
return
!
!
gPlatform
;
}
void
gfxPlatform
:
:
InitChild
(
const
ContentDeviceData
&
aData
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
gPlatform
"
InitChild
(
)
should
be
called
before
first
GetPlatform
(
)
"
)
;
gContentDeviceInitData
=
&
aData
;
Init
(
)
;
gContentDeviceInitData
=
nullptr
;
}
void
RecordingPrefChanged
(
const
char
*
aPrefName
void
*
aClosure
)
{
if
(
Preferences
:
:
GetBool
(
"
gfx
.
2d
.
recording
"
false
)
)
{
nsAutoCString
fileName
;
nsAdoptingString
prefFileName
=
Preferences
:
:
GetString
(
"
gfx
.
2d
.
recordingfile
"
)
;
if
(
prefFileName
)
{
fileName
.
Append
(
NS_ConvertUTF16toUTF8
(
prefFileName
)
)
;
}
else
{
nsCOMPtr
<
nsIFile
>
tmpFile
;
if
(
NS_FAILED
(
NS_GetSpecialDirectory
(
NS_OS_TEMP_DIR
getter_AddRefs
(
tmpFile
)
)
)
)
{
return
;
}
fileName
.
AppendPrintf
(
"
moz2drec_
%
i_
%
i
.
aer
"
XRE_GetProcessType
(
)
getpid
(
)
)
;
nsresult
rv
=
tmpFile
-
>
AppendNative
(
fileName
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
rv
=
tmpFile
-
>
GetNativePath
(
fileName
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
}
gPlatform
-
>
mRecorder
=
Factory
:
:
CreateEventRecorderForFile
(
fileName
.
BeginReading
(
)
)
;
printf_stderr
(
"
Recording
to
%
s
\
n
"
fileName
.
get
(
)
)
;
Factory
:
:
SetGlobalEventRecorder
(
gPlatform
-
>
mRecorder
)
;
}
else
{
Factory
:
:
SetGlobalEventRecorder
(
nullptr
)
;
}
}
#
if
defined
(
USE_SKIA
)
static
uint32_t
GetSkiaGlyphCacheSize
(
)
{
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
uint32_t
cacheSize
=
10
*
1024
*
1024
;
if
(
mozilla
:
:
BrowserTabsRemoteAutostart
(
)
)
{
return
XRE_IsContentProcess
(
)
?
cacheSize
:
kDefaultGlyphCacheSize
;
}
return
cacheSize
;
#
else
return
kDefaultGlyphCacheSize
;
#
endif
}
#
endif
void
gfxPlatform
:
:
Init
(
)
{
MOZ_RELEASE_ASSERT
(
!
XRE_IsGPUProcess
(
)
"
GFX
:
Not
allowed
in
GPU
process
.
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
"
GFX
:
Not
in
main
thread
.
"
)
;
if
(
gEverInitialized
)
{
MOZ_CRASH
(
"
Already
started
?
?
?
"
)
;
}
gEverInitialized
=
true
;
gfxPrefs
:
:
GetSingleton
(
)
;
MediaPrefs
:
:
GetSingleton
(
)
;
gfxVars
:
:
Initialize
(
)
;
gfxConfig
:
:
Init
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
GPUProcessManager
:
:
Initialize
(
)
;
if
(
Preferences
:
:
GetBool
(
"
media
.
wmf
.
skip
-
blacklist
"
)
)
{
gfxVars
:
:
SetPDMWMFDisableD3D11Dlls
(
nsCString
(
)
)
;
gfxVars
:
:
SetPDMWMFDisableD3D9Dlls
(
nsCString
(
)
)
;
}
else
{
gfxVars
:
:
SetPDMWMFDisableD3D11Dlls
(
Preferences
:
:
GetCString
(
"
media
.
wmf
.
disable
-
d3d11
-
for
-
dlls
"
)
)
;
gfxVars
:
:
SetPDMWMFDisableD3D9Dlls
(
Preferences
:
:
GetCString
(
"
media
.
wmf
.
disable
-
d3d9
-
for
-
dlls
"
)
)
;
}
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_GRE_DIR
getter_AddRefs
(
file
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
gfxVars
:
:
SetGREDirectory
(
nsCString
(
)
)
;
}
else
{
nsAutoCString
nativePath
;
file
-
>
GetNativePath
(
nativePath
)
;
gfxVars
:
:
SetGREDirectory
(
nsCString
(
nativePath
)
)
;
}
}
{
nsAutoCString
forcedPrefs
;
forcedPrefs
.
AppendPrintf
(
"
FP
(
D
%
d
%
d
"
gfxPrefs
:
:
Direct2DDisabled
(
)
gfxPrefs
:
:
Direct2DForceEnabled
(
)
)
;
forcedPrefs
.
AppendPrintf
(
"
-
L
%
d
%
d
%
d
%
d
"
gfxPrefs
:
:
LayersAMDSwitchableGfxEnabled
(
)
gfxPrefs
:
:
LayersAccelerationDisabledDoNotUseDirectly
(
)
gfxPrefs
:
:
LayersAccelerationForceEnabledDoNotUseDirectly
(
)
gfxPrefs
:
:
LayersD3D11ForceWARP
(
)
)
;
forcedPrefs
.
AppendPrintf
(
"
-
W
%
d
%
d
%
d
%
d
%
d
%
d
%
d
%
d
"
gfxPrefs
:
:
WebGLANGLEForceD3D11
(
)
gfxPrefs
:
:
WebGLANGLEForceWARP
(
)
gfxPrefs
:
:
WebGLDisabled
(
)
gfxPrefs
:
:
WebGLDisableANGLE
(
)
gfxPrefs
:
:
WebGLDXGLEnabled
(
)
gfxPrefs
:
:
WebGLForceEnabled
(
)
gfxPrefs
:
:
WebGLForceLayersReadback
(
)
gfxPrefs
:
:
WebGLForceMSAA
(
)
)
;
forcedPrefs
.
AppendPrintf
(
"
-
T
%
d
%
d
%
d
)
"
gfxPrefs
:
:
AndroidRGB16Force
(
)
gfxPrefs
:
:
CanvasAzureAccelerated
(
)
gfxPrefs
:
:
ForceShmemTiles
(
)
)
;
ScopedGfxFeatureReporter
:
:
AppNote
(
forcedPrefs
)
;
}
InitMoz2DLogging
(
)
;
gGfxPlatformPrefsLock
=
new
Mutex
(
"
gfxPlatform
:
:
gGfxPlatformPrefsLock
"
)
;
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
;
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
#
if
defined
(
XP_WIN
)
gPlatform
=
new
gfxWindowsPlatform
;
#
elif
defined
(
XP_MACOSX
)
gPlatform
=
new
gfxPlatformMac
;
#
elif
defined
(
MOZ_WIDGET_GTK
)
gPlatform
=
new
gfxPlatformGtk
;
#
elif
defined
(
ANDROID
)
gPlatform
=
new
gfxAndroidPlatform
;
#
else
#
error
"
No
gfxPlatform
implementation
available
"
#
endif
gPlatform
-
>
InitAcceleration
(
)
;
gPlatform
-
>
InitWebRenderConfig
(
)
;
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
)
{
GPUProcessManager
*
gpu
=
GPUProcessManager
:
:
Get
(
)
;
gpu
-
>
LaunchGPUProcess
(
)
;
}
#
ifdef
USE_SKIA
SkGraphics
:
:
Init
(
)
;
#
ifdef
MOZ_ENABLE_FREETYPE
SkInitCairoFT
(
gPlatform
-
>
FontHintingEnabled
(
)
)
;
#
endif
#
endif
#
ifdef
MOZ_GL_DEBUG
GLContext
:
:
StaticInit
(
)
;
#
endif
InitLayersIPC
(
)
;
gPlatform
-
>
PopulateScreenInfo
(
)
;
gPlatform
-
>
ComputeTileSize
(
)
;
nsresult
rv
;
rv
=
gfxPlatformFontList
:
:
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_CRASH
(
"
Could
not
initialize
gfxPlatformFontList
"
)
;
}
gPlatform
-
>
mScreenReferenceSurface
=
gPlatform
-
>
CreateOffscreenSurface
(
IntSize
(
1
1
)
SurfaceFormat
:
:
A8R8G8B8_UINT32
)
;
if
(
!
gPlatform
-
>
mScreenReferenceSurface
)
{
MOZ_CRASH
(
"
Could
not
initialize
mScreenReferenceSurface
"
)
;
}
gPlatform
-
>
mScreenReferenceDrawTarget
=
gPlatform
-
>
CreateOffscreenContentDrawTarget
(
IntSize
(
1
1
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
gPlatform
-
>
mScreenReferenceDrawTarget
|
|
!
gPlatform
-
>
mScreenReferenceDrawTarget
-
>
IsValid
(
)
)
{
MOZ_CRASH
(
"
Could
not
initialize
mScreenReferenceDrawTarget
"
)
;
}
rv
=
gfxFontCache
:
:
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_CRASH
(
"
Could
not
initialize
gfxFontCache
"
)
;
}
#
ifdef
MOZ_ENABLE_FREETYPE
Factory
:
:
SetFTLibrary
(
gPlatform
-
>
GetFTLibrary
(
)
)
;
#
endif
gPlatform
-
>
mSRGBOverrideObserver
=
new
SRGBOverrideObserver
(
)
;
Preferences
:
:
AddWeakObserver
(
gPlatform
-
>
mSRGBOverrideObserver
GFX_PREF_CMS_FORCE_SRGB
)
;
gPlatform
-
>
mFontPrefsObserver
=
new
FontPrefsObserver
(
)
;
Preferences
:
:
AddStrongObservers
(
gPlatform
-
>
mFontPrefsObserver
kObservedPrefs
)
;
GLContext
:
:
PlatformStartup
(
)
;
#
ifdef
MOZ_WIDGET_ANDROID
TexturePoolOGL
:
:
Init
(
)
;
#
endif
Preferences
:
:
RegisterCallbackAndCall
(
RecordingPrefChanged
"
gfx
.
2d
.
recording
"
)
;
CreateCMSOutputProfile
(
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
gPlatform
-
>
mMemoryPressureObserver
=
new
MemoryPressureObserver
(
)
;
obs
-
>
AddObserver
(
gPlatform
-
>
mMemoryPressureObserver
"
memory
-
pressure
"
false
)
;
}
nsCOMPtr
<
imgITools
>
imgTools
=
do_GetService
(
"
mozilla
.
org
/
image
/
tools
;
1
"
)
;
if
(
!
imgTools
)
{
MOZ_CRASH
(
"
Could
not
initialize
ImageLib
"
)
;
}
RegisterStrongMemoryReporter
(
new
GfxMemoryImageReporter
(
)
)
;
if
(
XRE_IsParentProcess
(
)
)
{
if
(
gfxPlatform
:
:
ForceSoftwareVsync
(
)
)
{
gPlatform
-
>
mVsyncSource
=
(
gPlatform
)
-
>
gfxPlatform
:
:
CreateHardwareVsyncSource
(
)
;
}
else
{
gPlatform
-
>
mVsyncSource
=
gPlatform
-
>
CreateHardwareVsyncSource
(
)
;
}
}
#
ifdef
USE_SKIA
uint32_t
skiaCacheSize
=
GetSkiaGlyphCacheSize
(
)
;
if
(
skiaCacheSize
!
=
kDefaultGlyphCacheSize
)
{
SkGraphics
:
:
SetFontCacheLimit
(
skiaCacheSize
)
;
}
#
endif
InitNullMetadata
(
)
;
InitOpenGLConfig
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetDXInterop2Blocked
(
IsDXInterop2Blocked
(
)
)
;
}
if
(
obs
)
{
obs
-
>
NotifyObservers
(
nullptr
"
gfx
-
features
-
ready
"
nullptr
)
;
}
}
bool
gfxPlatform
:
:
IsDXInterop2Blocked
(
)
{
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
nsCString
blockId
;
int32_t
status
;
if
(
!
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_DX_INTEROP2
blockId
&
status
)
)
)
{
return
true
;
}
return
status
!
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
;
}
void
gfxPlatform
:
:
InitMoz2DLogging
(
)
{
auto
fwd
=
new
CrashStatsLogForwarder
(
"
GraphicsCriticalError
"
)
;
fwd
-
>
SetCircularBufferSize
(
gfxPrefs
:
:
GfxLoggingCrashLength
(
)
)
;
mozilla
:
:
gfx
:
:
Config
cfg
;
cfg
.
mLogForwarder
=
fwd
;
cfg
.
mMaxTextureSize
=
gfxPrefs
:
:
MaxTextureSize
(
)
;
cfg
.
mMaxAllocSize
=
gfxPrefs
:
:
MaxAllocSize
(
)
;
gfx
:
:
Factory
:
:
Init
(
cfg
)
;
}
bool
gfxPlatform
:
:
IsHeadless
(
)
{
return
PR_GetEnv
(
"
MOZ_HEADLESS
"
)
;
}
static
bool
sLayersIPCIsUp
=
false
;
void
gfxPlatform
:
:
InitNullMetadata
(
)
{
ScrollMetadata
:
:
sNullMetadata
=
new
ScrollMetadata
(
)
;
ClearOnShutdown
(
&
ScrollMetadata
:
:
sNullMetadata
)
;
}
void
gfxPlatform
:
:
Shutdown
(
)
{
if
(
!
gPlatform
)
{
return
;
}
MOZ_ASSERT
(
!
sLayersIPCIsUp
)
;
gfxFontCache
:
:
Shutdown
(
)
;
gfxFontGroup
:
:
Shutdown
(
)
;
gfxGradientCache
:
:
Shutdown
(
)
;
gfxAlphaBoxBlur
:
:
ShutdownBlurCache
(
)
;
gfxGraphiteShaper
:
:
Shutdown
(
)
;
gfxPlatformFontList
:
:
Shutdown
(
)
;
ShutdownTileCache
(
)
;
ShutdownCMS
(
)
;
NS_ASSERTION
(
gPlatform
-
>
mSRGBOverrideObserver
"
mSRGBOverrideObserver
has
alreay
gone
"
)
;
Preferences
:
:
RemoveObserver
(
gPlatform
-
>
mSRGBOverrideObserver
GFX_PREF_CMS_FORCE_SRGB
)
;
gPlatform
-
>
mSRGBOverrideObserver
=
nullptr
;
NS_ASSERTION
(
gPlatform
-
>
mFontPrefsObserver
"
mFontPrefsObserver
has
alreay
gone
"
)
;
Preferences
:
:
RemoveObservers
(
gPlatform
-
>
mFontPrefsObserver
kObservedPrefs
)
;
gPlatform
-
>
mFontPrefsObserver
=
nullptr
;
NS_ASSERTION
(
gPlatform
-
>
mMemoryPressureObserver
"
mMemoryPressureObserver
has
already
gone
"
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
gPlatform
-
>
mMemoryPressureObserver
"
memory
-
pressure
"
)
;
}
gPlatform
-
>
mMemoryPressureObserver
=
nullptr
;
gPlatform
-
>
mSkiaGlue
=
nullptr
;
if
(
XRE_IsParentProcess
(
)
)
{
gPlatform
-
>
mVsyncSource
-
>
Shutdown
(
)
;
}
gPlatform
-
>
mVsyncSource
=
nullptr
;
#
ifdef
MOZ_WIDGET_ANDROID
TexturePoolOGL
:
:
Shutdown
(
)
;
#
endif
GLContextProvider
:
:
Shutdown
(
)
;
#
if
defined
(
XP_WIN
)
GLContextProviderEGL
:
:
Shutdown
(
)
;
#
endif
if
(
XRE_IsParentProcess
(
)
)
{
GPUProcessManager
:
:
Shutdown
(
)
;
}
gfx
:
:
Factory
:
:
ShutDown
(
)
;
delete
gGfxPlatformPrefsLock
;
gfxVars
:
:
Shutdown
(
)
;
gfxPrefs
:
:
DestroySingleton
(
)
;
gfxFont
:
:
DestroySingletons
(
)
;
gfxConfig
:
:
Shutdown
(
)
;
gPlatform
-
>
WillShutdown
(
)
;
delete
gPlatform
;
gPlatform
=
nullptr
;
}
void
gfxPlatform
:
:
InitLayersIPC
(
)
{
if
(
sLayersIPCIsUp
)
{
return
;
}
sLayersIPCIsUp
=
true
;
if
(
XRE_IsParentProcess
(
)
)
{
if
(
gfxVars
:
:
UseWebRender
(
)
)
{
wr
:
:
RenderThread
:
:
Start
(
)
;
}
layers
:
:
CompositorThreadHolder
:
:
Start
(
)
;
}
}
void
gfxPlatform
:
:
ShutdownLayersIPC
(
)
{
if
(
!
sLayersIPCIsUp
)
{
return
;
}
sLayersIPCIsUp
=
false
;
if
(
XRE_IsContentProcess
(
)
)
{
gfx
:
:
VRManagerChild
:
:
ShutDown
(
)
;
if
(
gfxPrefs
:
:
ChildProcessShutdown
(
)
)
{
layers
:
:
CompositorBridgeChild
:
:
ShutDown
(
)
;
layers
:
:
ImageBridgeChild
:
:
ShutDown
(
)
;
}
}
else
if
(
XRE_IsParentProcess
(
)
)
{
gfx
:
:
VRManagerChild
:
:
ShutDown
(
)
;
layers
:
:
CompositorBridgeChild
:
:
ShutDown
(
)
;
layers
:
:
ImageBridgeChild
:
:
ShutDown
(
)
;
layers
:
:
CompositorThreadHolder
:
:
Shutdown
(
)
;
if
(
gfxVars
:
:
UseWebRender
(
)
)
{
wr
:
:
RenderThread
:
:
ShutDown
(
)
;
}
}
else
{
}
}
void
gfxPlatform
:
:
WillShutdown
(
)
{
mScreenReferenceSurface
=
nullptr
;
mScreenReferenceDrawTarget
=
nullptr
;
}
gfxPlatform
:
:
~
gfxPlatform
(
)
{
#
ifdef
NS_FREE_PERMANENT_DATA
#
ifdef
USE_SKIA
SkGraphics
:
:
PurgeFontCache
(
)
;
#
endif
#
if
MOZ_TREE_CAIRO
cairo_debug_reset_static_data
(
)
;
#
endif
#
endif
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateDrawTargetForSurface
(
gfxASurface
*
aSurface
const
IntSize
&
aSize
)
{
SurfaceFormat
format
=
aSurface
-
>
GetSurfaceFormat
(
)
;
RefPtr
<
DrawTarget
>
drawTarget
=
Factory
:
:
CreateDrawTargetForCairoSurface
(
aSurface
-
>
CairoSurface
(
)
aSize
&
format
)
;
if
(
!
drawTarget
)
{
gfxWarning
(
)
<
<
"
gfxPlatform
:
:
CreateDrawTargetForSurface
failed
in
CreateDrawTargetForCairoSurface
"
;
return
nullptr
;
}
return
drawTarget
.
forget
(
)
;
}
cairo_user_data_key_t
kSourceSurface
;
struct
SourceSurfaceUserData
{
RefPtr
<
SourceSurface
>
mSrcSurface
;
BackendType
mBackendType
;
}
;
void
SourceBufferDestroy
(
void
*
srcSurfUD
)
{
delete
static_cast
<
SourceSurfaceUserData
*
>
(
srcSurfUD
)
;
}
UserDataKey
kThebesSurface
;
struct
DependentSourceSurfaceUserData
{
RefPtr
<
gfxASurface
>
mSurface
;
}
;
void
SourceSurfaceDestroyed
(
void
*
aData
)
{
delete
static_cast
<
DependentSourceSurfaceUserData
*
>
(
aData
)
;
}
void
gfxPlatform
:
:
ClearSourceSurfaceForSurface
(
gfxASurface
*
aSurface
)
{
aSurface
-
>
SetData
(
&
kSourceSurface
nullptr
nullptr
)
;
}
already_AddRefed
<
SourceSurface
>
gfxPlatform
:
:
GetSourceSurfaceForSurface
(
DrawTarget
*
aTarget
gfxASurface
*
aSurface
bool
aIsPlugin
)
{
if
(
!
aSurface
-
>
CairoSurface
(
)
|
|
aSurface
-
>
CairoStatus
(
)
)
{
return
nullptr
;
}
if
(
!
aTarget
)
{
aTarget
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
;
}
void
*
userData
=
aSurface
-
>
GetData
(
&
kSourceSurface
)
;
if
(
userData
)
{
SourceSurfaceUserData
*
surf
=
static_cast
<
SourceSurfaceUserData
*
>
(
userData
)
;
if
(
surf
-
>
mSrcSurface
-
>
IsValid
(
)
&
&
surf
-
>
mBackendType
=
=
aTarget
-
>
GetBackendType
(
)
)
{
RefPtr
<
SourceSurface
>
srcSurface
(
surf
-
>
mSrcSurface
)
;
return
srcSurface
.
forget
(
)
;
}
}
SurfaceFormat
format
=
aSurface
-
>
GetSurfaceFormat
(
)
;
if
(
aTarget
-
>
GetBackendType
(
)
=
=
BackendType
:
:
CAIRO
)
{
return
Factory
:
:
CreateSourceSurfaceForCairoSurface
(
aSurface
-
>
CairoSurface
(
)
aSurface
-
>
GetSize
(
)
format
)
;
}
RefPtr
<
SourceSurface
>
srcBuffer
;
if
(
!
srcBuffer
)
{
RefPtr
<
DataSourceSurface
>
surf
=
GetWrappedDataSourceSurface
(
aSurface
)
;
if
(
surf
)
{
srcBuffer
=
aIsPlugin
?
aTarget
-
>
OptimizeSourceSurfaceForUnknownAlpha
(
surf
)
:
aTarget
-
>
OptimizeSourceSurface
(
surf
)
;
if
(
srcBuffer
=
=
surf
)
{
return
srcBuffer
.
forget
(
)
;
}
}
}
if
(
!
srcBuffer
)
{
MOZ_ASSERT
(
aTarget
-
>
GetBackendType
(
)
!
=
BackendType
:
:
CAIRO
"
We
already
tried
CreateSourceSurfaceFromNativeSurface
with
a
"
"
DrawTargetCairo
above
"
)
;
srcBuffer
=
Factory
:
:
CreateSourceSurfaceForCairoSurface
(
aSurface
-
>
CairoSurface
(
)
aSurface
-
>
GetSize
(
)
format
)
;
if
(
srcBuffer
)
{
srcBuffer
=
aTarget
-
>
OptimizeSourceSurface
(
srcBuffer
)
;
}
}
if
(
!
srcBuffer
)
{
return
nullptr
;
}
if
(
(
srcBuffer
-
>
GetType
(
)
=
=
SurfaceType
:
:
CAIRO
&
&
static_cast
<
SourceSurfaceCairo
*
>
(
srcBuffer
.
get
(
)
)
-
>
GetSurface
(
)
=
=
aSurface
-
>
CairoSurface
(
)
)
|
|
(
srcBuffer
-
>
GetType
(
)
=
=
SurfaceType
:
:
CAIRO_IMAGE
&
&
static_cast
<
DataSourceSurfaceCairo
*
>
(
srcBuffer
.
get
(
)
)
-
>
GetSurface
(
)
=
=
aSurface
-
>
CairoSurface
(
)
)
)
{
return
srcBuffer
.
forget
(
)
;
}
auto
*
srcSurfUD
=
new
SourceSurfaceUserData
;
srcSurfUD
-
>
mBackendType
=
aTarget
-
>
GetBackendType
(
)
;
srcSurfUD
-
>
mSrcSurface
=
srcBuffer
;
aSurface
-
>
SetData
(
&
kSourceSurface
srcSurfUD
SourceBufferDestroy
)
;
return
srcBuffer
.
forget
(
)
;
}
already_AddRefed
<
DataSourceSurface
>
gfxPlatform
:
:
GetWrappedDataSourceSurface
(
gfxASurface
*
aSurface
)
{
RefPtr
<
gfxImageSurface
>
image
=
aSurface
-
>
GetAsImageSurface
(
)
;
if
(
!
image
)
{
return
nullptr
;
}
RefPtr
<
DataSourceSurface
>
result
=
Factory
:
:
CreateWrappingDataSourceSurface
(
image
-
>
Data
(
)
image
-
>
Stride
(
)
image
-
>
GetSize
(
)
ImageFormatToSurfaceFormat
(
image
-
>
Format
(
)
)
)
;
if
(
!
result
)
{
return
nullptr
;
}
auto
*
srcSurfUD
=
new
DependentSourceSurfaceUserData
;
srcSurfUD
-
>
mSurface
=
aSurface
;
result
-
>
AddUserData
(
&
kThebesSurface
srcSurfUD
SourceSurfaceDestroyed
)
;
return
result
.
forget
(
)
;
}
already_AddRefed
<
ScaledFont
>
gfxPlatform
:
:
GetScaledFontForFont
(
DrawTarget
*
aTarget
gfxFont
*
aFont
)
{
NativeFont
nativeFont
;
nativeFont
.
mType
=
NativeFontType
:
:
CAIRO_FONT_FACE
;
nativeFont
.
mFont
=
aFont
-
>
GetCairoScaledFont
(
)
;
return
Factory
:
:
CreateScaledFontForNativeFont
(
nativeFont
aFont
-
>
GetUnscaledFont
(
)
aFont
-
>
GetAdjustedSize
(
)
)
;
}
void
gfxPlatform
:
:
ComputeTileSize
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
int32_t
w
=
gfxPrefs
:
:
LayersTileWidth
(
)
;
int32_t
h
=
gfxPrefs
:
:
LayersTileHeight
(
)
;
if
(
gfxPrefs
:
:
LayersTilesAdjust
(
)
)
{
gfx
:
:
IntSize
screenSize
=
GetScreenSize
(
)
;
if
(
screenSize
.
width
>
0
)
{
w
=
h
=
clamped
(
int32_t
(
RoundUpPow2
(
screenSize
.
width
)
)
/
4
256
1024
)
;
}
}
MOZ_ASSERT
(
gfxVars
:
:
TileSize
(
)
.
width
=
=
-
1
&
&
gfxVars
:
:
TileSize
(
)
.
height
=
=
-
1
)
;
gfxVars
:
:
SetTileSize
(
IntSize
(
w
h
)
)
;
}
void
gfxPlatform
:
:
PopulateScreenInfo
(
)
{
nsCOMPtr
<
nsIScreenManager
>
manager
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
;
MOZ_ASSERT
(
manager
"
failed
to
get
nsIScreenManager
"
)
;
nsCOMPtr
<
nsIScreen
>
screen
;
manager
-
>
GetPrimaryScreen
(
getter_AddRefs
(
screen
)
)
;
if
(
!
screen
)
{
return
;
}
screen
-
>
GetColorDepth
(
&
mScreenDepth
)
;
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetScreenDepth
(
mScreenDepth
)
;
}
int
left
top
;
screen
-
>
GetRect
(
&
left
&
top
&
mScreenSize
.
width
&
mScreenSize
.
height
)
;
}
bool
gfxPlatform
:
:
SupportsAzureContentForDrawTarget
(
DrawTarget
*
aTarget
)
{
if
(
!
aTarget
|
|
!
aTarget
-
>
IsValid
(
)
)
{
return
false
;
}
#
ifdef
USE_SKIA_GPU
if
(
(
aTarget
-
>
GetType
(
)
=
=
DrawTargetType
:
:
HARDWARE_RASTER
)
&
&
(
aTarget
-
>
GetBackendType
(
)
=
=
BackendType
:
:
SKIA
)
)
{
return
false
;
}
#
endif
return
SupportsAzureContentForType
(
aTarget
-
>
GetBackendType
(
)
)
;
}
bool
gfxPlatform
:
:
AllowOpenGLCanvas
(
)
{
bool
correctBackend
=
!
XRE_IsParentProcess
(
)
|
|
(
(
mCompositorBackend
=
=
LayersBackend
:
:
LAYERS_OPENGL
)
&
&
(
GetContentBackendFor
(
mCompositorBackend
)
=
=
BackendType
:
:
SKIA
)
)
;
if
(
gfxPrefs
:
:
CanvasAzureAccelerated
(
)
&
&
correctBackend
)
{
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
info
;
1
"
)
;
int32_t
status
;
nsCString
discardFailureId
;
return
!
gfxInfo
|
|
(
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_CANVAS2D_ACCELERATION
discardFailureId
&
status
)
)
&
&
status
=
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
)
;
}
return
false
;
}
void
gfxPlatform
:
:
InitializeSkiaCacheLimits
(
)
{
if
(
AllowOpenGLCanvas
(
)
)
{
#
ifdef
USE_SKIA_GPU
bool
usingDynamicCache
=
gfxPrefs
:
:
CanvasSkiaGLDynamicCache
(
)
;
int
cacheItemLimit
=
gfxPrefs
:
:
CanvasSkiaGLCacheItems
(
)
;
uint64_t
cacheSizeLimit
=
std
:
:
max
(
gfxPrefs
:
:
CanvasSkiaGLCacheSize
(
)
(
int32_t
)
0
)
;
cacheSizeLimit
*
=
1024
*
1024
;
if
(
usingDynamicCache
)
{
if
(
mTotalSystemMemory
<
512
*
1024
*
1024
)
{
cacheSizeLimit
=
2
*
1024
*
1024
;
}
else
if
(
mTotalSystemMemory
>
0
)
{
cacheSizeLimit
=
mTotalSystemMemory
/
16
;
}
}
cacheSizeLimit
=
std
:
:
min
(
cacheSizeLimit
(
uint64_t
)
SIZE_MAX
)
;
#
ifdef
DEBUG
printf_stderr
(
"
Determined
SkiaGL
cache
limits
:
Size
%
"
PRIu64
"
Items
:
%
i
\
n
"
cacheSizeLimit
cacheItemLimit
)
;
#
endif
mSkiaGlue
-
>
GetGrContext
(
)
-
>
setResourceCacheLimits
(
cacheItemLimit
(
size_t
)
cacheSizeLimit
)
;
#
endif
}
}
SkiaGLGlue
*
gfxPlatform
:
:
GetSkiaGLGlue
(
)
{
#
ifdef
USE_SKIA_GPU
if
(
!
mSkiaGlue
&
&
!
AllowOpenGLCanvas
(
)
)
{
return
nullptr
;
}
if
(
!
mSkiaGlue
)
{
RefPtr
<
GLContext
>
glContext
;
nsCString
discardFailureId
;
glContext
=
GLContextProvider
:
:
CreateHeadless
(
CreateContextFlags
:
:
REQUIRE_COMPAT_PROFILE
|
CreateContextFlags
:
:
ALLOW_OFFLINE_RENDERER
&
discardFailureId
)
;
if
(
!
glContext
)
{
printf_stderr
(
"
Failed
to
create
GLContext
for
SkiaGL
!
\
n
"
)
;
return
nullptr
;
}
mSkiaGlue
=
new
SkiaGLGlue
(
glContext
)
;
MOZ_ASSERT
(
mSkiaGlue
-
>
GetGrContext
(
)
"
No
GrContext
"
)
;
InitializeSkiaCacheLimits
(
)
;
}
#
endif
return
mSkiaGlue
;
}
void
gfxPlatform
:
:
PurgeSkiaFontCache
(
)
{
#
ifdef
USE_SKIA
if
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetDefaultContentBackend
(
)
=
=
BackendType
:
:
SKIA
)
{
SkGraphics
:
:
PurgeFontCache
(
)
;
}
#
endif
}
void
gfxPlatform
:
:
PurgeSkiaGPUCache
(
)
{
#
ifdef
USE_SKIA_GPU
if
(
!
mSkiaGlue
)
return
;
mSkiaGlue
-
>
GetGrContext
(
)
-
>
freeGpuResources
(
)
;
mSkiaGlue
-
>
GetGLContext
(
)
-
>
MakeCurrent
(
)
;
mSkiaGlue
-
>
GetGLContext
(
)
-
>
fFlush
(
)
;
#
endif
}
bool
gfxPlatform
:
:
HasEnoughTotalSystemMemoryForSkiaGL
(
)
{
return
true
;
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateDrawTargetForBackend
(
BackendType
aBackend
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
if
(
aBackend
=
=
BackendType
:
:
CAIRO
)
{
RefPtr
<
gfxASurface
>
surf
=
CreateOffscreenSurface
(
aSize
SurfaceFormatToImageFormat
(
aFormat
)
)
;
if
(
!
surf
|
|
surf
-
>
CairoStatus
(
)
)
{
return
nullptr
;
}
return
CreateDrawTargetForSurface
(
surf
aSize
)
;
}
return
Factory
:
:
CreateDrawTarget
(
aBackend
aSize
aFormat
)
;
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateOffscreenCanvasDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
NS_ASSERTION
(
mPreferredCanvasBackend
!
=
BackendType
:
:
NONE
"
No
backend
.
"
)
;
RefPtr
<
DrawTarget
>
target
=
CreateDrawTargetForBackend
(
mPreferredCanvasBackend
aSize
aFormat
)
;
if
(
target
|
|
mFallbackCanvasBackend
=
=
BackendType
:
:
NONE
)
{
return
target
.
forget
(
)
;
}
#
ifdef
XP_WIN
return
Factory
:
:
CreateDrawTarget
(
mFallbackCanvasBackend
aSize
aFormat
)
;
#
else
return
CreateDrawTargetForBackend
(
mFallbackCanvasBackend
aSize
aFormat
)
;
#
endif
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateOffscreenContentDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
NS_ASSERTION
(
mContentBackend
!
=
BackendType
:
:
NONE
"
No
backend
.
"
)
;
return
CreateDrawTargetForBackend
(
mContentBackend
aSize
aFormat
)
;
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateSimilarSoftwareDrawTarget
(
DrawTarget
*
aDT
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
RefPtr
<
DrawTarget
>
dt
;
if
(
Factory
:
:
DoesBackendSupportDataDrawtarget
(
aDT
-
>
GetBackendType
(
)
)
)
{
dt
=
aDT
-
>
CreateSimilarDrawTarget
(
aSize
aFormat
)
;
}
else
{
#
ifdef
USE_SKIA
BackendType
backendType
=
BackendType
:
:
SKIA
;
#
else
BackendType
backendType
=
BackendType
:
:
CAIRO
;
#
endif
dt
=
Factory
:
:
CreateDrawTarget
(
backendType
aSize
aFormat
)
;
}
return
dt
.
forget
(
)
;
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateDrawTargetForData
(
unsigned
char
*
aData
const
IntSize
&
aSize
int32_t
aStride
SurfaceFormat
aFormat
bool
aUninitialized
)
{
BackendType
backendType
=
gfxVars
:
:
ContentBackend
(
)
;
NS_ASSERTION
(
backendType
!
=
BackendType
:
:
NONE
"
No
backend
.
"
)
;
if
(
!
Factory
:
:
DoesBackendSupportDataDrawtarget
(
backendType
)
)
{
#
ifdef
USE_SKIA
backendType
=
BackendType
:
:
SKIA
;
#
else
backendType
=
BackendType
:
:
CAIRO
;
#
endif
}
RefPtr
<
DrawTarget
>
dt
=
Factory
:
:
CreateDrawTargetForData
(
backendType
aData
aSize
aStride
aFormat
aUninitialized
)
;
return
dt
.
forget
(
)
;
}
BackendType
gfxPlatform
:
:
BackendTypeForName
(
const
nsCString
&
aName
)
{
if
(
aName
.
EqualsLiteral
(
"
cairo
"
)
)
return
BackendType
:
:
CAIRO
;
if
(
aName
.
EqualsLiteral
(
"
skia
"
)
)
return
BackendType
:
:
SKIA
;
if
(
aName
.
EqualsLiteral
(
"
direct2d
"
)
)
return
BackendType
:
:
DIRECT2D
;
if
(
aName
.
EqualsLiteral
(
"
direct2d1
.
1
"
)
)
return
BackendType
:
:
DIRECT2D1_1
;
return
BackendType
:
:
NONE
;
}
nsresult
gfxPlatform
:
:
GetFontList
(
nsIAtom
*
aLangGroup
const
nsACString
&
aGenericFamily
nsTArray
<
nsString
>
&
aListOfFonts
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
GetFontList
(
aLangGroup
aGenericFamily
aListOfFonts
)
;
return
NS_OK
;
}
nsresult
gfxPlatform
:
:
UpdateFontList
(
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
UpdateFontList
(
)
;
return
NS_OK
;
}
nsresult
gfxPlatform
:
:
GetStandardFamilyName
(
const
nsAString
&
aFontName
nsAString
&
aFamilyName
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
GetStandardFamilyName
(
aFontName
aFamilyName
)
;
return
NS_OK
;
}
nsString
gfxPlatform
:
:
GetDefaultFontName
(
const
nsACString
&
aLangGroup
const
nsACString
&
aGenericFamily
)
{
gfxFontFamily
*
fontFamily
=
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
GetDefaultFontFamily
(
aLangGroup
aGenericFamily
)
;
if
(
!
fontFamily
)
{
return
EmptyString
(
)
;
}
nsAutoString
result
;
fontFamily
-
>
LocalizedName
(
result
)
;
return
result
;
}
bool
gfxPlatform
:
:
DownloadableFontsEnabled
(
)
{
if
(
mAllowDownloadableFonts
=
=
UNINITIALIZED_VALUE
)
{
mAllowDownloadableFonts
=
Preferences
:
:
GetBool
(
GFX_DOWNLOADABLE_FONTS_ENABLED
false
)
;
}
return
mAllowDownloadableFonts
;
}
bool
gfxPlatform
:
:
UseCmapsDuringSystemFallback
(
)
{
if
(
mFallbackUsesCmaps
=
=
UNINITIALIZED_VALUE
)
{
mFallbackUsesCmaps
=
Preferences
:
:
GetBool
(
GFX_PREF_FALLBACK_USE_CMAPS
false
)
;
}
return
mFallbackUsesCmaps
;
}
bool
gfxPlatform
:
:
OpenTypeSVGEnabled
(
)
{
if
(
mOpenTypeSVGEnabled
=
=
UNINITIALIZED_VALUE
)
{
mOpenTypeSVGEnabled
=
Preferences
:
:
GetBool
(
GFX_PREF_OPENTYPE_SVG
false
)
;
}
return
mOpenTypeSVGEnabled
>
0
|
|
(
XRE_IsParentProcess
(
)
&
&
BrowserTabsRemoteAutostart
(
)
)
;
}
uint32_t
gfxPlatform
:
:
WordCacheCharLimit
(
)
{
if
(
mWordCacheCharLimit
=
=
UNINITIALIZED_VALUE
)
{
mWordCacheCharLimit
=
Preferences
:
:
GetInt
(
GFX_PREF_WORD_CACHE_CHARLIMIT
32
)
;
if
(
mWordCacheCharLimit
<
0
)
{
mWordCacheCharLimit
=
32
;
}
}
return
uint32_t
(
mWordCacheCharLimit
)
;
}
uint32_t
gfxPlatform
:
:
WordCacheMaxEntries
(
)
{
if
(
mWordCacheMaxEntries
=
=
UNINITIALIZED_VALUE
)
{
mWordCacheMaxEntries
=
Preferences
:
:
GetInt
(
GFX_PREF_WORD_CACHE_MAXENTRIES
10000
)
;
if
(
mWordCacheMaxEntries
<
0
)
{
mWordCacheMaxEntries
=
10000
;
}
}
return
uint32_t
(
mWordCacheMaxEntries
)
;
}
bool
gfxPlatform
:
:
UseGraphiteShaping
(
)
{
if
(
mGraphiteShapingEnabled
=
=
UNINITIALIZED_VALUE
)
{
mGraphiteShapingEnabled
=
Preferences
:
:
GetBool
(
GFX_PREF_GRAPHITE_SHAPING
false
)
;
}
return
mGraphiteShapingEnabled
;
}
gfxFontEntry
*
gfxPlatform
:
:
LookupLocalFont
(
const
nsAString
&
aFontName
uint16_t
aWeight
int16_t
aStretch
uint8_t
aStyle
)
{
return
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
LookupLocalFont
(
aFontName
aWeight
aStretch
aStyle
)
;
}
gfxFontEntry
*
gfxPlatform
:
:
MakePlatformFont
(
const
nsAString
&
aFontName
uint16_t
aWeight
int16_t
aStretch
uint8_t
aStyle
const
uint8_t
*
aFontData
uint32_t
aLength
)
{
return
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
MakePlatformFont
(
aFontName
aWeight
aStretch
aStyle
aFontData
aLength
)
;
}
mozilla
:
:
layers
:
:
DiagnosticTypes
gfxPlatform
:
:
GetLayerDiagnosticTypes
(
)
{
mozilla
:
:
layers
:
:
DiagnosticTypes
type
=
DiagnosticTypes
:
:
NO_DIAGNOSTIC
;
if
(
gfxPrefs
:
:
DrawLayerBorders
(
)
)
{
type
|
=
mozilla
:
:
layers
:
:
DiagnosticTypes
:
:
LAYER_BORDERS
;
}
if
(
gfxPrefs
:
:
DrawTileBorders
(
)
)
{
type
|
=
mozilla
:
:
layers
:
:
DiagnosticTypes
:
:
TILE_BORDERS
;
}
if
(
gfxPrefs
:
:
DrawBigImageBorders
(
)
)
{
type
|
=
mozilla
:
:
layers
:
:
DiagnosticTypes
:
:
BIGIMAGE_BORDERS
;
}
if
(
gfxPrefs
:
:
FlashLayerBorders
(
)
)
{
type
|
=
mozilla
:
:
layers
:
:
DiagnosticTypes
:
:
FLASH_BORDERS
;
}
return
type
;
}
void
gfxPlatform
:
:
InitBackendPrefs
(
uint32_t
aCanvasBitmask
BackendType
aCanvasDefault
uint32_t
aContentBitmask
BackendType
aContentDefault
)
{
mPreferredCanvasBackend
=
GetCanvasBackendPref
(
aCanvasBitmask
)
;
if
(
mPreferredCanvasBackend
=
=
BackendType
:
:
NONE
)
{
mPreferredCanvasBackend
=
aCanvasDefault
;
}
if
(
mPreferredCanvasBackend
=
=
BackendType
:
:
DIRECT2D1_1
)
{
mFallbackCanvasBackend
=
GetCanvasBackendPref
(
aCanvasBitmask
&
~
(
BackendTypeBit
(
mPreferredCanvasBackend
)
|
BackendTypeBit
(
BackendType
:
:
DIRECT2D
)
)
)
;
}
else
{
mFallbackCanvasBackend
=
GetCanvasBackendPref
(
aCanvasBitmask
&
~
BackendTypeBit
(
mPreferredCanvasBackend
)
)
;
}
mContentBackendBitmask
=
aContentBitmask
;
mContentBackend
=
GetContentBackendPref
(
mContentBackendBitmask
)
;
if
(
mContentBackend
=
=
BackendType
:
:
NONE
)
{
mContentBackend
=
aContentDefault
;
mContentBackendBitmask
|
=
BackendTypeBit
(
aContentDefault
)
;
}
uint32_t
swBackendBits
=
BackendTypeBit
(
BackendType
:
:
SKIA
)
|
BackendTypeBit
(
BackendType
:
:
CAIRO
)
;
mSoftwareBackend
=
GetContentBackendPref
(
swBackendBits
)
;
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetContentBackend
(
mContentBackend
)
;
gfxVars
:
:
SetSoftwareBackend
(
mSoftwareBackend
)
;
}
}
BackendType
gfxPlatform
:
:
GetCanvasBackendPref
(
uint32_t
aBackendBitmask
)
{
return
GetBackendPref
(
"
gfx
.
canvas
.
azure
.
backends
"
aBackendBitmask
)
;
}
BackendType
gfxPlatform
:
:
GetContentBackendPref
(
uint32_t
&
aBackendBitmask
)
{
return
GetBackendPref
(
"
gfx
.
content
.
azure
.
backends
"
aBackendBitmask
)
;
}
BackendType
gfxPlatform
:
:
GetBackendPref
(
const
char
*
aBackendPrefName
uint32_t
&
aBackendBitmask
)
{
nsTArray
<
nsCString
>
backendList
;
nsCString
prefString
;
if
(
NS_SUCCEEDED
(
Preferences
:
:
GetCString
(
aBackendPrefName
&
prefString
)
)
)
{
ParseString
(
prefString
'
'
backendList
)
;
}
uint32_t
allowedBackends
=
0
;
BackendType
result
=
BackendType
:
:
NONE
;
for
(
uint32_t
i
=
0
;
i
<
backendList
.
Length
(
)
;
+
+
i
)
{
BackendType
type
=
BackendTypeForName
(
backendList
[
i
]
)
;
if
(
BackendTypeBit
(
type
)
&
aBackendBitmask
)
{
allowedBackends
|
=
BackendTypeBit
(
type
)
;
if
(
result
=
=
BackendType
:
:
NONE
)
{
result
=
type
;
}
}
}
aBackendBitmask
=
allowedBackends
;
return
result
;
}
bool
gfxPlatform
:
:
InSafeMode
(
)
{
static
bool
sSafeModeInitialized
=
false
;
static
bool
sInSafeMode
=
false
;
if
(
!
sSafeModeInitialized
)
{
sSafeModeInitialized
=
true
;
nsCOMPtr
<
nsIXULRuntime
>
xr
=
do_GetService
(
"
mozilla
.
org
/
xre
/
runtime
;
1
"
)
;
if
(
xr
)
{
xr
-
>
GetInSafeMode
(
&
sInSafeMode
)
;
}
}
return
sInSafeMode
;
}
bool
gfxPlatform
:
:
OffMainThreadCompositingEnabled
(
)
{
return
UsesOffMainThreadCompositing
(
)
;
}
eCMSMode
gfxPlatform
:
:
GetCMSMode
(
)
{
if
(
!
gCMSInitialized
)
{
int32_t
mode
=
gfxPrefs
:
:
CMSMode
(
)
;
if
(
mode
>
=
0
&
&
mode
<
eCMSMode_AllCount
)
{
gCMSMode
=
static_cast
<
eCMSMode
>
(
mode
)
;
}
bool
enableV4
=
gfxPrefs
:
:
CMSEnableV4
(
)
;
if
(
enableV4
)
{
qcms_enable_iccv4
(
)
;
}
gCMSInitialized
=
true
;
}
return
gCMSMode
;
}
int
gfxPlatform
:
:
GetRenderingIntent
(
)
{
MOZ_ASSERT
(
QCMS_INTENT_DEFAULT
=
=
0
)
;
int32_t
pIntent
=
gfxPrefs
:
:
CMSRenderingIntent
(
)
;
if
(
(
pIntent
<
QCMS_INTENT_MIN
)
|
|
(
pIntent
>
QCMS_INTENT_MAX
)
)
{
pIntent
=
-
1
;
}
return
pIntent
;
}
void
gfxPlatform
:
:
TransformPixel
(
const
Color
&
in
Color
&
out
qcms_transform
*
transform
)
{
if
(
transform
)
{
#
ifdef
IS_LITTLE_ENDIAN
uint32_t
packed
=
in
.
ToABGR
(
)
;
qcms_transform_data
(
transform
(
uint8_t
*
)
&
packed
(
uint8_t
*
)
&
packed
1
)
;
out
=
Color
:
:
FromABGR
(
packed
)
;
#
else
uint32_t
packed
=
in
.
UnusualToARGB
(
)
;
qcms_transform_data
(
transform
(
uint8_t
*
)
&
packed
+
1
(
uint8_t
*
)
&
packed
+
1
1
)
;
out
=
Color
:
:
UnusualFromARGB
(
packed
)
;
#
endif
}
else
if
(
&
out
!
=
&
in
)
out
=
in
;
}
void
gfxPlatform
:
:
GetPlatformCMSOutputProfile
(
void
*
&
mem
size_t
&
size
)
{
mem
=
nullptr
;
size
=
0
;
}
void
gfxPlatform
:
:
GetCMSOutputProfileData
(
void
*
&
mem
size_t
&
size
)
{
nsAdoptingCString
fname
=
Preferences
:
:
GetCString
(
"
gfx
.
color_management
.
display_profile
"
)
;
if
(
!
fname
.
IsEmpty
(
)
)
{
qcms_data_from_path
(
fname
&
mem
&
size
)
;
}
else
{
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetPlatformCMSOutputProfile
(
mem
size
)
;
}
}
void
gfxPlatform
:
:
CreateCMSOutputProfile
(
)
{
if
(
!
gCMSOutputProfile
)
{
if
(
Preferences
:
:
GetBool
(
GFX_PREF_CMS_FORCE_SRGB
false
)
)
{
gCMSOutputProfile
=
GetCMSsRGBProfile
(
)
;
}
if
(
!
gCMSOutputProfile
)
{
void
*
mem
=
nullptr
;
size_t
size
=
0
;
GetCMSOutputProfileData
(
mem
size
)
;
if
(
(
mem
!
=
nullptr
)
&
&
(
size
>
0
)
)
{
gCMSOutputProfile
=
qcms_profile_from_memory
(
mem
size
)
;
free
(
mem
)
;
}
}
if
(
gCMSOutputProfile
&
&
qcms_profile_is_bogus
(
gCMSOutputProfile
)
)
{
NS_ASSERTION
(
gCMSOutputProfile
!
=
GetCMSsRGBProfile
(
)
"
Builtin
sRGB
profile
tagged
as
bogus
!
!
!
"
)
;
qcms_profile_release
(
gCMSOutputProfile
)
;
gCMSOutputProfile
=
nullptr
;
}
if
(
!
gCMSOutputProfile
)
{
gCMSOutputProfile
=
GetCMSsRGBProfile
(
)
;
}
qcms_profile_precache_output_transform
(
gCMSOutputProfile
)
;
}
}
qcms_profile
*
gfxPlatform
:
:
GetCMSOutputProfile
(
)
{
return
gCMSOutputProfile
;
}
qcms_profile
*
gfxPlatform
:
:
GetCMSsRGBProfile
(
)
{
if
(
!
gCMSsRGBProfile
)
{
gCMSsRGBProfile
=
qcms_profile_sRGB
(
)
;
}
return
gCMSsRGBProfile
;
}
qcms_transform
*
gfxPlatform
:
:
GetCMSRGBTransform
(
)
{
if
(
!
gCMSRGBTransform
)
{
qcms_profile
*
inProfile
*
outProfile
;
outProfile
=
GetCMSOutputProfile
(
)
;
inProfile
=
GetCMSsRGBProfile
(
)
;
if
(
!
inProfile
|
|
!
outProfile
)
return
nullptr
;
gCMSRGBTransform
=
qcms_transform_create
(
inProfile
QCMS_DATA_RGB_8
outProfile
QCMS_DATA_RGB_8
QCMS_INTENT_PERCEPTUAL
)
;
}
return
gCMSRGBTransform
;
}
qcms_transform
*
gfxPlatform
:
:
GetCMSInverseRGBTransform
(
)
{
if
(
!
gCMSInverseRGBTransform
)
{
qcms_profile
*
inProfile
*
outProfile
;
inProfile
=
GetCMSOutputProfile
(
)
;
outProfile
=
GetCMSsRGBProfile
(
)
;
if
(
!
inProfile
|
|
!
outProfile
)
return
nullptr
;
gCMSInverseRGBTransform
=
qcms_transform_create
(
inProfile
QCMS_DATA_RGB_8
outProfile
QCMS_DATA_RGB_8
QCMS_INTENT_PERCEPTUAL
)
;
}
return
gCMSInverseRGBTransform
;
}
qcms_transform
*
gfxPlatform
:
:
GetCMSRGBATransform
(
)
{
if
(
!
gCMSRGBATransform
)
{
qcms_profile
*
inProfile
*
outProfile
;
outProfile
=
GetCMSOutputProfile
(
)
;
inProfile
=
GetCMSsRGBProfile
(
)
;
if
(
!
inProfile
|
|
!
outProfile
)
return
nullptr
;
gCMSRGBATransform
=
qcms_transform_create
(
inProfile
QCMS_DATA_RGBA_8
outProfile
QCMS_DATA_RGBA_8
QCMS_INTENT_PERCEPTUAL
)
;
}
return
gCMSRGBATransform
;
}
static
void
ShutdownCMS
(
)
{
if
(
gCMSRGBTransform
)
{
qcms_transform_release
(
gCMSRGBTransform
)
;
gCMSRGBTransform
=
nullptr
;
}
if
(
gCMSInverseRGBTransform
)
{
qcms_transform_release
(
gCMSInverseRGBTransform
)
;
gCMSInverseRGBTransform
=
nullptr
;
}
if
(
gCMSRGBATransform
)
{
qcms_transform_release
(
gCMSRGBATransform
)
;
gCMSRGBATransform
=
nullptr
;
}
if
(
gCMSOutputProfile
)
{
qcms_profile_release
(
gCMSOutputProfile
)
;
if
(
gCMSsRGBProfile
=
=
gCMSOutputProfile
)
gCMSsRGBProfile
=
nullptr
;
gCMSOutputProfile
=
nullptr
;
}
if
(
gCMSsRGBProfile
)
{
qcms_profile_release
(
gCMSsRGBProfile
)
;
gCMSsRGBProfile
=
nullptr
;
}
gCMSMode
=
eCMSMode_Off
;
gCMSInitialized
=
false
;
}
void
gfxPlatform
:
:
SetupClusterBoundaries
(
gfxTextRun
*
aTextRun
const
char16_t
*
aString
)
{
if
(
aTextRun
-
>
GetFlags
(
)
&
gfx
:
:
ShapedTextFlags
:
:
TEXT_IS_8BIT
)
{
return
;
}
aTextRun
-
>
SetupClusterBoundaries
(
0
aString
aTextRun
-
>
GetLength
(
)
)
;
}
int32_t
gfxPlatform
:
:
GetBidiNumeralOption
(
)
{
if
(
mBidiNumeralOption
=
=
UNINITIALIZED_VALUE
)
{
mBidiNumeralOption
=
Preferences
:
:
GetInt
(
BIDI_NUMERAL_PREF
0
)
;
}
return
mBidiNumeralOption
;
}
void
gfxPlatform
:
:
FlushFontAndWordCaches
(
)
{
gfxFontCache
*
fontCache
=
gfxFontCache
:
:
GetCache
(
)
;
if
(
fontCache
)
{
fontCache
-
>
AgeAllGenerations
(
)
;
fontCache
-
>
FlushShapedWordCaches
(
)
;
}
gfxPlatform
:
:
PurgeSkiaFontCache
(
)
;
}
void
gfxPlatform
:
:
FontsPrefsChanged
(
const
char
*
aPref
)
{
NS_ASSERTION
(
aPref
!
=
nullptr
"
null
preference
"
)
;
if
(
!
strcmp
(
GFX_DOWNLOADABLE_FONTS_ENABLED
aPref
)
)
{
mAllowDownloadableFonts
=
UNINITIALIZED_VALUE
;
}
else
if
(
!
strcmp
(
GFX_PREF_FALLBACK_USE_CMAPS
aPref
)
)
{
mFallbackUsesCmaps
=
UNINITIALIZED_VALUE
;
}
else
if
(
!
strcmp
(
GFX_PREF_WORD_CACHE_CHARLIMIT
aPref
)
)
{
mWordCacheCharLimit
=
UNINITIALIZED_VALUE
;
FlushFontAndWordCaches
(
)
;
}
else
if
(
!
strcmp
(
GFX_PREF_WORD_CACHE_MAXENTRIES
aPref
)
)
{
mWordCacheMaxEntries
=
UNINITIALIZED_VALUE
;
FlushFontAndWordCaches
(
)
;
}
else
if
(
!
strcmp
(
GFX_PREF_GRAPHITE_SHAPING
aPref
)
)
{
mGraphiteShapingEnabled
=
UNINITIALIZED_VALUE
;
FlushFontAndWordCaches
(
)
;
}
else
if
(
!
strcmp
(
BIDI_NUMERAL_PREF
aPref
)
)
{
mBidiNumeralOption
=
UNINITIALIZED_VALUE
;
}
else
if
(
!
strcmp
(
GFX_PREF_OPENTYPE_SVG
aPref
)
)
{
mOpenTypeSVGEnabled
=
UNINITIALIZED_VALUE
;
gfxFontCache
:
:
GetCache
(
)
-
>
AgeAllGenerations
(
)
;
}
}
mozilla
:
:
LogModule
*
gfxPlatform
:
:
GetLog
(
eGfxLog
aWhichLog
)
{
static
LazyLogModule
sFontlistLog
(
"
fontlist
"
)
;
static
LazyLogModule
sFontInitLog
(
"
fontinit
"
)
;
static
LazyLogModule
sTextrunLog
(
"
textrun
"
)
;
static
LazyLogModule
sTextrunuiLog
(
"
textrunui
"
)
;
static
LazyLogModule
sCmapDataLog
(
"
cmapdata
"
)
;
static
LazyLogModule
sTextPerfLog
(
"
textperf
"
)
;
switch
(
aWhichLog
)
{
case
eGfxLog_fontlist
:
return
sFontlistLog
;
case
eGfxLog_fontinit
:
return
sFontInitLog
;
case
eGfxLog_textrun
:
return
sTextrunLog
;
case
eGfxLog_textrunui
:
return
sTextrunuiLog
;
case
eGfxLog_cmapdata
:
return
sCmapDataLog
;
case
eGfxLog_textperf
:
return
sTextPerfLog
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
log
type
"
)
;
return
nullptr
;
}
mozilla
:
:
gfx
:
:
SurfaceFormat
gfxPlatform
:
:
Optimal2DFormatForContent
(
gfxContentType
aContent
)
{
switch
(
aContent
)
{
case
gfxContentType
:
:
COLOR
:
switch
(
GetOffscreenFormat
(
)
)
{
case
SurfaceFormat
:
:
A8R8G8B8_UINT32
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
case
SurfaceFormat
:
:
X8R8G8B8_UINT32
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8X8
;
case
SurfaceFormat
:
:
R5G6B5_UINT16
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
R5G6B5_UINT16
;
default
:
NS_NOTREACHED
(
"
unknown
gfxImageFormat
for
gfxContentType
:
:
COLOR
"
)
;
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
}
case
gfxContentType
:
:
ALPHA
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
A8
;
case
gfxContentType
:
:
COLOR_ALPHA
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
default
:
NS_NOTREACHED
(
"
unknown
gfxContentType
"
)
;
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
}
}
gfxImageFormat
gfxPlatform
:
:
OptimalFormatForContent
(
gfxContentType
aContent
)
{
switch
(
aContent
)
{
case
gfxContentType
:
:
COLOR
:
return
GetOffscreenFormat
(
)
;
case
gfxContentType
:
:
ALPHA
:
return
SurfaceFormat
:
:
A8
;
case
gfxContentType
:
:
COLOR_ALPHA
:
return
SurfaceFormat
:
:
A8R8G8B8_UINT32
;
default
:
NS_NOTREACHED
(
"
unknown
gfxContentType
"
)
;
return
SurfaceFormat
:
:
A8R8G8B8_UINT32
;
}
}
static
mozilla
:
:
Atomic
<
bool
>
sLayersSupportsHardwareVideoDecoding
(
false
)
;
static
bool
sLayersHardwareVideoDecodingFailed
=
false
;
static
bool
sBufferRotationCheckPref
=
true
;
static
mozilla
:
:
Atomic
<
bool
>
sLayersAccelerationPrefsInitialized
(
false
)
;
void
VideoDecodingFailedChangedCallback
(
const
char
*
aPref
void
*
)
{
sLayersHardwareVideoDecodingFailed
=
Preferences
:
:
GetBool
(
aPref
false
)
;
gfxPlatform
:
:
GetPlatform
(
)
-
>
UpdateCanUseHardwareVideoDecoding
(
)
;
}
void
gfxPlatform
:
:
UpdateCanUseHardwareVideoDecoding
(
)
{
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetCanUseHardwareVideoDecoding
(
CanUseHardwareVideoDecoding
(
)
)
;
}
}
void
gfxPlatform
:
:
InitAcceleration
(
)
{
if
(
sLayersAccelerationPrefsInitialized
)
{
return
;
}
InitCompositorAccelerationPrefs
(
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
can
only
initialize
prefs
on
the
main
thread
"
)
;
gfxPrefs
:
:
GetSingleton
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetBrowserTabsRemoteAutostart
(
BrowserTabsRemoteAutostart
(
)
)
;
gfxVars
:
:
SetOffscreenFormat
(
GetOffscreenFormat
(
)
)
;
gfxVars
:
:
SetRequiresAcceleratedGLContextForCompositorOGL
(
RequiresAcceleratedGLContextForCompositorOGL
(
)
)
;
}
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
nsCString
discardFailureId
;
int32_t
status
;
if
(
Preferences
:
:
GetBool
(
"
media
.
hardware
-
video
-
decoding
.
enabled
"
false
)
&
&
#
ifdef
XP_WIN
Preferences
:
:
GetBool
(
"
media
.
windows
-
media
-
foundation
.
use
-
dxva
"
true
)
&
&
#
endif
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_HARDWARE_VIDEO_DECODING
discardFailureId
&
status
)
)
)
{
if
(
status
=
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
|
|
gfxPrefs
:
:
HardwareVideoDecodingForceEnabled
(
)
)
{
sLayersSupportsHardwareVideoDecoding
=
true
;
}
}
sLayersAccelerationPrefsInitialized
=
true
;
if
(
XRE_IsParentProcess
(
)
)
{
Preferences
:
:
RegisterCallbackAndCall
(
VideoDecodingFailedChangedCallback
"
media
.
hardware
-
video
-
decoding
.
failed
"
)
;
InitGPUProcessPrefs
(
)
;
}
}
void
gfxPlatform
:
:
InitGPUProcessPrefs
(
)
{
if
(
!
gfxPrefs
:
:
GPUProcessEnabled
(
)
&
&
!
gfxPrefs
:
:
GPUProcessForceEnabled
(
)
)
{
return
;
}
FeatureState
&
gpuProc
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
GPU_PROCESS
)
;
if
(
!
BrowserTabsRemoteAutostart
(
)
)
{
gpuProc
.
DisableByDefault
(
FeatureStatus
:
:
Unavailable
"
Multi
-
process
mode
is
not
enabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_NO_E10S
"
)
)
;
}
else
{
gpuProc
.
SetDefaultFromPref
(
gfxPrefs
:
:
GetGPUProcessEnabledPrefName
(
)
true
gfxPrefs
:
:
GetGPUProcessEnabledPrefDefault
(
)
)
;
}
if
(
gfxPrefs
:
:
GPUProcessForceEnabled
(
)
)
{
gpuProc
.
UserForceEnable
(
"
User
force
-
enabled
via
pref
"
)
;
}
if
(
InSafeMode
(
)
)
{
gpuProc
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
Safe
-
mode
is
enabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_SAFE_MODE
"
)
)
;
return
;
}
if
(
gfxPrefs
:
:
LayerScopeEnabled
(
)
)
{
gpuProc
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
LayerScope
does
not
work
in
the
GPU
process
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_LAYERSCOPE
"
)
)
;
return
;
}
}
void
gfxPlatform
:
:
InitCompositorAccelerationPrefs
(
)
{
const
char
*
acceleratedEnv
=
PR_GetEnv
(
"
MOZ_ACCELERATED
"
)
;
FeatureState
&
feature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
HW_COMPOSITING
)
;
if
(
feature
.
SetDefault
(
AccelerateLayersByDefault
(
)
FeatureStatus
:
:
Blocked
"
Acceleration
blocked
by
platform
"
)
)
{
if
(
gfxPrefs
:
:
LayersAccelerationDisabledDoNotUseDirectly
(
)
)
{
feature
.
UserDisable
(
"
Disabled
by
pref
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_PREF
"
)
)
;
}
else
if
(
acceleratedEnv
&
&
*
acceleratedEnv
=
=
'
0
'
)
{
feature
.
UserDisable
(
"
Disabled
by
envvar
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_ENV
"
)
)
;
}
}
else
{
if
(
acceleratedEnv
&
&
*
acceleratedEnv
=
=
'
1
'
)
{
feature
.
UserEnable
(
"
Enabled
by
envvar
"
)
;
}
}
if
(
gfxPrefs
:
:
LayersAccelerationForceEnabledDoNotUseDirectly
(
)
)
{
feature
.
UserForceEnable
(
"
Force
-
enabled
by
pref
"
)
;
}
if
(
InSafeMode
(
)
)
{
feature
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
Acceleration
blocked
by
safe
-
mode
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_SAFEMODE
"
)
)
;
}
}
void
gfxPlatform
:
:
InitWebRenderConfig
(
)
{
bool
prefEnabled
=
Preferences
:
:
GetBool
(
"
gfx
.
webrender
.
enabled
"
false
)
;
ScopedGfxFeatureReporter
reporter
(
"
WR
"
prefEnabled
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
if
(
gfxVars
:
:
UseWebRender
(
)
)
{
reporter
.
SetSuccessful
(
)
;
}
return
;
}
FeatureState
&
featureWebRender
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
WEBRENDER
)
;
featureWebRender
.
DisableByDefault
(
FeatureStatus
:
:
OptIn
"
WebRender
is
an
opt
-
in
feature
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_DEFAULT_OFF
"
)
)
;
if
(
prefEnabled
)
{
featureWebRender
.
UserEnable
(
"
Enabled
by
pref
"
)
;
}
#
ifdef
XP_WIN
if
(
!
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
)
{
featureWebRender
.
ForceDisable
(
FeatureStatus
:
:
Unavailable
"
GPU
Process
is
disabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_GPU_PROCESS_DISABLED
"
)
)
;
}
#
endif
if
(
InSafeMode
(
)
)
{
featureWebRender
.
ForceDisable
(
FeatureStatus
:
:
Unavailable
"
Safe
-
mode
is
enabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_SAFE_MODE
"
)
)
;
}
#
ifndef
MOZ_BUILD_WEBRENDER
featureWebRender
.
ForceDisable
(
FeatureStatus
:
:
Unavailable
"
Build
doesn
'
t
include
WebRender
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_NO_WEBRENDER
"
)
)
;
#
endif
#
ifdef
XP_WIN
if
(
Preferences
:
:
GetBool
(
"
gfx
.
webrender
.
force
-
angle
"
false
)
)
{
if
(
!
gfxConfig
:
:
IsEnabled
(
Feature
:
:
D3D11_HW_ANGLE
)
)
{
featureWebRender
.
ForceDisable
(
FeatureStatus
:
:
Unavailable
"
ANGLE
is
disabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_ANGLE_DISABLED
"
)
)
;
}
else
{
gfxVars
:
:
SetUseWebRenderANGLE
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER
)
)
;
}
}
#
endif
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER
)
)
{
gfxVars
:
:
SetUseWebRender
(
true
)
;
reporter
.
SetSuccessful
(
)
;
}
}
bool
gfxPlatform
:
:
CanUseHardwareVideoDecoding
(
)
{
MOZ_ASSERT
(
sLayersAccelerationPrefsInitialized
)
;
return
sLayersSupportsHardwareVideoDecoding
&
&
!
sLayersHardwareVideoDecodingFailed
;
}
bool
gfxPlatform
:
:
AccelerateLayersByDefault
(
)
{
#
if
defined
(
MOZ_GL_PROVIDER
)
|
|
defined
(
MOZ_WIDGET_UIKIT
)
return
true
;
#
else
return
false
;
#
endif
}
bool
gfxPlatform
:
:
BufferRotationEnabled
(
)
{
MutexAutoLock
autoLock
(
*
gGfxPlatformPrefsLock
)
;
return
sBufferRotationCheckPref
&
&
gfxPrefs
:
:
BufferRotationEnabled
(
)
;
}
void
gfxPlatform
:
:
DisableBufferRotation
(
)
{
MutexAutoLock
autoLock
(
*
gGfxPlatformPrefsLock
)
;
sBufferRotationCheckPref
=
false
;
}
already_AddRefed
<
ScaledFont
>
gfxPlatform
:
:
GetScaledFontForFontWithCairoSkia
(
DrawTarget
*
aTarget
gfxFont
*
aFont
)
{
NativeFont
nativeFont
;
if
(
aTarget
-
>
GetBackendType
(
)
=
=
BackendType
:
:
CAIRO
|
|
aTarget
-
>
GetBackendType
(
)
=
=
BackendType
:
:
SKIA
)
{
nativeFont
.
mType
=
NativeFontType
:
:
CAIRO_FONT_FACE
;
nativeFont
.
mFont
=
aFont
-
>
GetCairoScaledFont
(
)
;
return
Factory
:
:
CreateScaledFontForNativeFont
(
nativeFont
aFont
-
>
GetUnscaledFont
(
)
aFont
-
>
GetAdjustedSize
(
)
)
;
}
return
nullptr
;
}
bool
gfxPlatform
:
:
UsesOffMainThreadCompositing
(
)
{
if
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_GPU
)
{
return
true
;
}
static
bool
firstTime
=
true
;
static
bool
result
=
false
;
if
(
firstTime
)
{
MOZ_ASSERT
(
sLayersAccelerationPrefsInitialized
)
;
result
=
gfxVars
:
:
BrowserTabsRemoteAutostart
(
)
|
|
!
gfxPrefs
:
:
LayersOffMainThreadCompositionForceDisabled
(
)
;
#
if
defined
(
MOZ_WIDGET_GTK
)
result
|
=
gfxPrefs
:
:
LayersAccelerationForceEnabledDoNotUseDirectly
(
)
;
#
endif
firstTime
=
false
;
}
return
result
;
}
already_AddRefed
<
mozilla
:
:
gfx
:
:
VsyncSource
>
gfxPlatform
:
:
CreateHardwareVsyncSource
(
)
{
RefPtr
<
mozilla
:
:
gfx
:
:
VsyncSource
>
softwareVsync
=
new
SoftwareVsyncSource
(
)
;
return
softwareVsync
.
forget
(
)
;
}
bool
gfxPlatform
:
:
IsInLayoutAsapMode
(
)
{
return
gfxPrefs
:
:
LayoutFrameRate
(
)
=
=
0
;
}
bool
gfxPlatform
:
:
ForceSoftwareVsync
(
)
{
return
gfxPrefs
:
:
LayoutFrameRate
(
)
>
0
;
}
int
gfxPlatform
:
:
GetSoftwareVsyncRate
(
)
{
int
preferenceRate
=
gfxPrefs
:
:
LayoutFrameRate
(
)
;
if
(
preferenceRate
<
=
0
)
{
return
gfxPlatform
:
:
GetDefaultFrameRate
(
)
;
}
return
preferenceRate
;
}
int
gfxPlatform
:
:
GetDefaultFrameRate
(
)
{
return
60
;
}
void
gfxPlatform
:
:
GetAzureBackendInfo
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
)
{
aObj
.
DefineProperty
(
"
AzureCanvasBackend
(
UI
Process
)
"
GetBackendName
(
mPreferredCanvasBackend
)
)
;
aObj
.
DefineProperty
(
"
AzureFallbackCanvasBackend
(
UI
Process
)
"
GetBackendName
(
mFallbackCanvasBackend
)
)
;
aObj
.
DefineProperty
(
"
AzureContentBackend
(
UI
Process
)
"
GetBackendName
(
mContentBackend
)
)
;
if
(
gfxConfig
:
:
IsEnabled
(
gfx
:
:
Feature
:
:
DIRECT2D
)
)
{
aObj
.
DefineProperty
(
"
AzureCanvasBackend
"
"
Direct2D
1
.
1
"
)
;
aObj
.
DefineProperty
(
"
AzureContentBackend
"
"
Direct2D
1
.
1
"
)
;
}
}
else
{
aObj
.
DefineProperty
(
"
AzureCanvasBackend
"
GetBackendName
(
mPreferredCanvasBackend
)
)
;
aObj
.
DefineProperty
(
"
AzureFallbackCanvasBackend
"
GetBackendName
(
mFallbackCanvasBackend
)
)
;
aObj
.
DefineProperty
(
"
AzureContentBackend
"
GetBackendName
(
mContentBackend
)
)
;
}
aObj
.
DefineProperty
(
"
AzureCanvasAccelerated
"
AllowOpenGLCanvas
(
)
)
;
}
void
gfxPlatform
:
:
GetApzSupportInfo
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
if
(
!
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
)
{
return
;
}
if
(
SupportsApzWheelInput
(
)
)
{
aObj
.
DefineProperty
(
"
ApzWheelInput
"
1
)
;
}
if
(
SupportsApzTouchInput
(
)
)
{
aObj
.
DefineProperty
(
"
ApzTouchInput
"
1
)
;
}
if
(
SupportsApzDragInput
(
)
)
{
aObj
.
DefineProperty
(
"
ApzDragInput
"
1
)
;
}
}
void
gfxPlatform
:
:
GetTilesSupportInfo
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
if
(
!
gfxPrefs
:
:
LayersTilesEnabled
(
)
)
{
return
;
}
IntSize
tileSize
=
gfxVars
:
:
TileSize
(
)
;
aObj
.
DefineProperty
(
"
TileHeight
"
tileSize
.
height
)
;
aObj
.
DefineProperty
(
"
TileWidth
"
tileSize
.
width
)
;
}
bool
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
{
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
&
&
!
defined
(
MOZ_WIDGET_UIKIT
)
if
(
!
BrowserTabsRemoteAutostart
(
)
)
{
return
false
;
}
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
return
true
;
#
else
if
(
!
gfxPrefs
:
:
SingletonExists
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
gfxPrefs
:
:
GetSingleton
(
)
;
}
return
gfxPrefs
:
:
AsyncPanZoomEnabledDoNotUseDirectly
(
)
;
#
endif
}
bool
gfxPlatform
:
:
PerfWarnings
(
)
{
return
gfxPrefs
:
:
PerfWarnings
(
)
;
}
void
gfxPlatform
:
:
GetAcceleratedCompositorBackends
(
nsTArray
<
LayersBackend
>
&
aBackends
)
{
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
OPENGL_COMPOSITING
)
)
{
aBackends
.
AppendElement
(
LayersBackend
:
:
LAYERS_OPENGL
)
;
}
else
{
static
int
tell_me_once
=
0
;
if
(
!
tell_me_once
)
{
NS_WARNING
(
"
OpenGL
-
accelerated
layers
are
not
supported
on
this
system
"
)
;
tell_me_once
=
1
;
}
#
ifdef
MOZ_WIDGET_ANDROID
MOZ_CRASH
(
"
OpenGL
-
accelerated
layers
are
a
hard
requirement
on
this
platform
.
"
"
Cannot
continue
without
support
for
them
"
)
;
#
endif
}
}
void
gfxPlatform
:
:
GetCompositorBackends
(
bool
useAcceleration
nsTArray
<
mozilla
:
:
layers
:
:
LayersBackend
>
&
aBackends
)
{
if
(
useAcceleration
)
{
GetAcceleratedCompositorBackends
(
aBackends
)
;
}
aBackends
.
AppendElement
(
LayersBackend
:
:
LAYERS_BASIC
)
;
}
void
gfxPlatform
:
:
NotifyCompositorCreated
(
LayersBackend
aBackend
)
{
if
(
mCompositorBackend
=
=
aBackend
)
{
return
;
}
if
(
mCompositorBackend
!
=
LayersBackend
:
:
LAYERS_NONE
)
{
gfxCriticalNote
<
<
"
Compositors
might
be
mixed
(
"
<
<
int
(
mCompositorBackend
)
<
<
"
"
<
<
int
(
aBackend
)
<
<
"
)
"
;
}
mCompositorBackend
=
aBackend
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
[
]
{
if
(
nsCOMPtr
<
nsIObserverService
>
obsvc
=
services
:
:
GetObserverService
(
)
)
{
obsvc
-
>
NotifyObservers
(
nullptr
"
compositor
:
created
"
nullptr
)
;
}
}
)
)
;
}
void
gfxPlatform
:
:
NotifyGPUProcessDisabled
(
)
{
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER
)
)
{
gfxConfig
:
:
GetFeature
(
Feature
:
:
WEBRENDER
)
.
ForceDisable
(
FeatureStatus
:
:
Unavailable
"
GPU
Process
is
disabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_GPU_PROCESS_DISABLED
"
)
)
;
gfxVars
:
:
SetUseWebRender
(
false
)
;
}
}
void
gfxPlatform
:
:
FetchAndImportContentDeviceData
(
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
if
(
gContentDeviceInitData
)
{
ImportContentDeviceData
(
*
gContentDeviceInitData
)
;
return
;
}
mozilla
:
:
dom
:
:
ContentChild
*
cc
=
mozilla
:
:
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
mozilla
:
:
gfx
:
:
ContentDeviceData
data
;
cc
-
>
SendGetGraphicsDeviceInitData
(
&
data
)
;
ImportContentDeviceData
(
data
)
;
}
void
gfxPlatform
:
:
ImportContentDeviceData
(
const
mozilla
:
:
gfx
:
:
ContentDeviceData
&
aData
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
const
DevicePrefs
&
prefs
=
aData
.
prefs
(
)
;
gfxConfig
:
:
Inherit
(
Feature
:
:
HW_COMPOSITING
prefs
.
hwCompositing
(
)
)
;
gfxConfig
:
:
Inherit
(
Feature
:
:
OPENGL_COMPOSITING
prefs
.
oglCompositing
(
)
)
;
}
void
gfxPlatform
:
:
BuildContentDeviceData
(
mozilla
:
:
gfx
:
:
ContentDeviceData
*
aOut
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
GPUProcessManager
:
:
Get
(
)
-
>
EnsureGPUReady
(
)
;
aOut
-
>
prefs
(
)
.
hwCompositing
(
)
=
gfxConfig
:
:
GetValue
(
Feature
:
:
HW_COMPOSITING
)
;
aOut
-
>
prefs
(
)
.
oglCompositing
(
)
=
gfxConfig
:
:
GetValue
(
Feature
:
:
OPENGL_COMPOSITING
)
;
}
void
gfxPlatform
:
:
ImportGPUDeviceData
(
const
mozilla
:
:
gfx
:
:
GPUDeviceData
&
aData
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
gfxConfig
:
:
ImportChange
(
Feature
:
:
OPENGL_COMPOSITING
aData
.
oglCompositing
(
)
)
;
}
bool
gfxPlatform
:
:
SupportsApzTouchInput
(
)
const
{
return
dom
:
:
TouchEvent
:
:
PrefEnabled
(
nullptr
)
;
}
bool
gfxPlatform
:
:
SupportsApzDragInput
(
)
const
{
return
gfxPrefs
:
:
APZDragEnabled
(
)
;
}
void
gfxPlatform
:
:
InitOpenGLConfig
(
)
{
#
ifdef
XP_WIN
if
(
!
Preferences
:
:
GetBool
(
"
layers
.
prefer
-
opengl
"
)
)
{
return
;
}
#
endif
FeatureState
&
openGLFeature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
OPENGL_COMPOSITING
)
;
if
(
!
gfxConfig
:
:
IsEnabled
(
Feature
:
:
HW_COMPOSITING
)
)
{
openGLFeature
.
DisableByDefault
(
FeatureStatus
:
:
Unavailable
"
Hardware
compositing
is
disabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_OPENGL_NEED_HWCOMP
"
)
)
;
return
;
}
#
ifdef
XP_WIN
openGLFeature
.
SetDefaultFromPref
(
gfxPrefs
:
:
GetLayersPreferOpenGLPrefName
(
)
true
gfxPrefs
:
:
GetLayersPreferOpenGLPrefDefault
(
)
)
;
#
else
openGLFeature
.
EnableByDefault
(
)
;
#
endif
if
(
gfxPrefs
:
:
LayersAccelerationForceEnabledDoNotUseDirectly
(
)
)
{
openGLFeature
.
UserForceEnable
(
"
Force
-
enabled
by
pref
"
)
;
return
;
}
nsCString
message
;
nsCString
failureId
;
if
(
!
IsGfxInfoStatusOkay
(
nsIGfxInfo
:
:
FEATURE_OPENGL_LAYERS
&
message
failureId
)
)
{
openGLFeature
.
Disable
(
FeatureStatus
:
:
Blacklisted
message
.
get
(
)
failureId
)
;
}
}
bool
gfxPlatform
:
:
IsGfxInfoStatusOkay
(
int32_t
aFeature
nsCString
*
aOutMessage
nsCString
&
aFailureId
)
{
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
if
(
!
gfxInfo
)
{
return
true
;
}
int32_t
status
;
if
(
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
aFeature
aFailureId
&
status
)
)
&
&
status
!
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
)
{
aOutMessage
-
>
AssignLiteral
(
"
#
BLOCKLIST_
"
)
;
aOutMessage
-
>
AppendASCII
(
aFailureId
.
get
(
)
)
;
return
false
;
}
return
true
;
}
