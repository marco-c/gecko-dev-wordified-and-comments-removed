#
include
"
mozilla
/
FontPropertyTypes
.
h
"
#
include
"
mozilla
/
RDDProcessManager
.
h
"
#
include
"
mozilla
/
image
/
ImageMemoryReporter
.
h
"
#
include
"
mozilla
/
layers
/
CompositorManagerChild
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
TiledContentClient
.
h
"
#
include
"
mozilla
/
webrender
/
RenderThread
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
mozilla
/
webrender
/
webrender_ffi
.
h
"
#
include
"
mozilla
/
layers
/
PaintThread
.
h
"
#
include
"
mozilla
/
gfx
/
gfxConfigManager
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessManager
.
h
"
#
include
"
mozilla
/
gfx
/
GraphicsMessages
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
StaticPrefs_accessibility
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
StaticPrefs_layers
.
h
"
#
include
"
mozilla
/
StaticPrefs_media
.
h
"
#
include
"
mozilla
/
StaticPrefs_webgl
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
gfxCrashReporterUtils
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxEnv
.
h
"
#
include
"
gfxTextRun
.
h
"
#
include
"
gfxUserFontSet
.
h
"
#
include
"
gfxConfig
.
h
"
#
include
"
GfxDriverInfo
.
h
"
#
include
"
VRProcessManager
.
h
"
#
include
"
VRThread
.
h
"
#
include
"
mozilla
/
SSE
.
h
"
#
include
"
mozilla
/
arm
.
h
"
#
ifdef
XP_WIN
#
include
<
process
.
h
>
#
define
getpid
_getpid
#
else
#
include
<
unistd
.
h
>
#
endif
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
gfxWindowsPlatform
.
h
"
#
elif
defined
(
XP_MACOSX
)
#
include
"
gfxPlatformMac
.
h
"
#
include
"
gfxQuartzSurface
.
h
"
#
include
"
nsCocoaFeatures
.
h
"
#
elif
defined
(
MOZ_WIDGET_GTK
)
#
include
"
gfxPlatformGtk
.
h
"
#
elif
defined
(
ANDROID
)
#
include
"
gfxAndroidPlatform
.
h
"
#
endif
#
if
defined
(
MOZ_WIDGET_ANDROID
)
#
include
"
mozilla
/
jni
/
Utils
.
h
"
#
endif
#
ifdef
XP_WIN
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
endif
#
ifdef
MOZ_WAYLAND
#
include
"
mozilla
/
widget
/
nsWaylandDisplay
.
h
"
#
endif
#
include
"
nsGkAtoms
.
h
"
#
include
"
gfxPlatformFontList
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxImageSurface
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
harfbuzz
/
hb
.
h
"
#
include
"
gfxGraphiteShaper
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxGradientCache
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
gfxFontMissingGlyphs
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
cairo
.
h
"
#
include
"
qcms
.
h
"
#
include
"
imgITools
.
h
"
#
include
"
plstr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
GLContextProvider
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
ifdef
USE_SKIA
#
ifdef
__GNUC__
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wshadow
"
#
endif
#
include
"
skia
/
include
/
core
/
SkGraphics
.
h
"
#
ifdef
MOZ_ENABLE_FREETYPE
#
include
"
skia
/
include
/
ports
/
SkTypeface_cairo
.
h
"
#
endif
#
include
"
mozilla
/
gfx
/
SkMemoryReporter
.
h
"
#
ifdef
__GNUC__
#
pragma
GCC
diagnostic
pop
/
/
-
Wshadow
#
endif
static
const
uint32_t
kDefaultGlyphCacheSize
=
-
1
;
#
endif
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsIGfxInfo
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
VsyncSource
.
h
"
#
include
"
SoftwareVsyncSource
.
h
"
#
include
"
nscore
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
TouchEvent
.
h
"
#
include
"
gfxVR
.
h
"
#
include
"
VRManager
.
h
"
#
include
"
VRManagerChild
.
h
"
#
include
"
mozilla
/
gfx
/
GPUParent
.
h
"
#
include
"
mozilla
/
layers
/
MemoryReportingMLGPU
.
h
"
#
include
"
prsystem
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
gl
;
using
namespace
mozilla
:
:
gfx
;
gfxPlatform
*
gPlatform
=
nullptr
;
static
bool
gEverInitialized
=
false
;
static
int32_t
gLastUsedFrameRate
=
-
1
;
const
ContentDeviceData
*
gContentDeviceInitData
=
nullptr
;
static
Mutex
*
gGfxPlatformPrefsLock
=
nullptr
;
static
qcms_profile
*
gCMSOutputProfile
=
nullptr
;
static
qcms_profile
*
gCMSsRGBProfile
=
nullptr
;
static
bool
gCMSRGBTransformFailed
=
false
;
static
qcms_transform
*
gCMSRGBTransform
=
nullptr
;
static
qcms_transform
*
gCMSInverseRGBTransform
=
nullptr
;
static
qcms_transform
*
gCMSRGBATransform
=
nullptr
;
static
qcms_transform
*
gCMSBGRATransform
=
nullptr
;
static
bool
gCMSInitialized
=
false
;
static
eCMSMode
gCMSMode
=
eCMSMode_Off
;
static
void
ShutdownCMS
(
)
;
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
SourceSurfaceCairo
.
h
"
class
SRGBOverrideObserver
final
:
public
nsIObserver
public
nsSupportsWeakReference
{
~
SRGBOverrideObserver
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
}
;
class
CrashStatsLogForwarder
:
public
mozilla
:
:
gfx
:
:
LogForwarder
{
public
:
explicit
CrashStatsLogForwarder
(
CrashReporter
:
:
Annotation
aKey
)
;
void
Log
(
const
std
:
:
string
&
aString
)
override
;
void
CrashAction
(
LogReason
aReason
)
override
;
bool
UpdateStringsVector
(
const
std
:
:
string
&
aString
)
override
;
LoggingRecord
LoggingRecordCopy
(
)
override
;
void
SetCircularBufferSize
(
uint32_t
aCapacity
)
;
private
:
void
UpdateCrashReport
(
)
;
private
:
LoggingRecord
mBuffer
;
CrashReporter
:
:
Annotation
mCrashCriticalKey
;
uint32_t
mMaxCapacity
;
int32_t
mIndex
;
Mutex
mMutex
;
}
;
CrashStatsLogForwarder
:
:
CrashStatsLogForwarder
(
CrashReporter
:
:
Annotation
aKey
)
:
mBuffer
(
)
mCrashCriticalKey
(
aKey
)
mMaxCapacity
(
0
)
mIndex
(
-
1
)
mMutex
(
"
CrashStatsLogForwarder
"
)
{
}
void
CrashStatsLogForwarder
:
:
SetCircularBufferSize
(
uint32_t
aCapacity
)
{
MutexAutoLock
lock
(
mMutex
)
;
mMaxCapacity
=
aCapacity
;
mBuffer
.
reserve
(
static_cast
<
size_t
>
(
aCapacity
)
)
;
}
LoggingRecord
CrashStatsLogForwarder
:
:
LoggingRecordCopy
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mBuffer
;
}
bool
CrashStatsLogForwarder
:
:
UpdateStringsVector
(
const
std
:
:
string
&
aString
)
{
if
(
mMaxCapacity
<
2
)
{
return
false
;
}
mIndex
+
=
1
;
MOZ_ASSERT
(
mIndex
>
=
0
)
;
int32_t
index
=
mIndex
?
(
mIndex
-
1
)
%
(
mMaxCapacity
-
1
)
+
1
:
0
;
MOZ_ASSERT
(
index
>
=
0
&
&
index
<
(
int32_t
)
mMaxCapacity
)
;
MOZ_ASSERT
(
index
<
=
mIndex
&
&
index
<
=
(
int32_t
)
mBuffer
.
size
(
)
)
;
double
tStamp
=
(
TimeStamp
:
:
NowLoRes
(
)
-
TimeStamp
:
:
ProcessCreation
(
)
)
.
ToSecondsSigDigits
(
)
;
LoggingRecordEntry
newEntry
(
mIndex
aString
tStamp
)
;
if
(
index
>
=
static_cast
<
int32_t
>
(
mBuffer
.
size
(
)
)
)
{
mBuffer
.
push_back
(
newEntry
)
;
}
else
{
mBuffer
[
index
]
=
newEntry
;
}
return
true
;
}
void
CrashStatsLogForwarder
:
:
UpdateCrashReport
(
)
{
std
:
:
stringstream
message
;
std
:
:
string
logAnnotation
;
switch
(
XRE_GetProcessType
(
)
)
{
case
GeckoProcessType_Default
:
logAnnotation
=
"
|
[
"
;
break
;
case
GeckoProcessType_Content
:
logAnnotation
=
"
|
[
C
"
;
break
;
case
GeckoProcessType_GPU
:
logAnnotation
=
"
|
[
G
"
;
break
;
default
:
logAnnotation
=
"
|
[
X
"
;
break
;
}
for
(
auto
&
it
:
mBuffer
)
{
message
<
<
logAnnotation
<
<
Get
<
0
>
(
it
)
<
<
"
]
"
<
<
Get
<
1
>
(
it
)
<
<
"
(
t
=
"
<
<
Get
<
2
>
(
it
)
<
<
"
)
"
;
}
nsCString
reportString
(
message
.
str
(
)
.
c_str
(
)
)
;
nsresult
annotated
=
CrashReporter
:
:
AnnotateCrashReport
(
mCrashCriticalKey
reportString
)
;
if
(
annotated
!
=
NS_OK
)
{
printf
(
"
Crash
Annotation
%
s
:
%
s
"
CrashReporter
:
:
AnnotationToString
(
mCrashCriticalKey
)
message
.
str
(
)
.
c_str
(
)
)
;
}
}
class
LogForwarderEvent
:
public
Runnable
{
virtual
~
LogForwarderEvent
(
)
=
default
;
public
:
NS_INLINE_DECL_REFCOUNTING_INHERITED
(
LogForwarderEvent
Runnable
)
explicit
LogForwarderEvent
(
const
nsCString
&
aMessage
)
:
mozilla
:
:
Runnable
(
"
LogForwarderEvent
"
)
mMessage
(
aMessage
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
&
&
(
XRE_IsContentProcess
(
)
|
|
XRE_IsGPUProcess
(
)
)
)
;
if
(
XRE_IsContentProcess
(
)
)
{
dom
:
:
ContentChild
*
cc
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
Unused
<
<
cc
-
>
SendGraphicsError
(
mMessage
)
;
}
else
if
(
XRE_IsGPUProcess
(
)
)
{
GPUParent
*
gp
=
GPUParent
:
:
GetSingleton
(
)
;
Unused
<
<
gp
-
>
SendGraphicsError
(
mMessage
)
;
}
return
NS_OK
;
}
protected
:
nsCString
mMessage
;
}
;
void
CrashStatsLogForwarder
:
:
Log
(
const
std
:
:
string
&
aString
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
UpdateStringsVector
(
aString
)
)
{
UpdateCrashReport
(
)
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
nsCString
stringToSend
(
aString
.
c_str
(
)
)
;
if
(
NS_IsMainThread
(
)
)
{
if
(
XRE_IsContentProcess
(
)
)
{
dom
:
:
ContentChild
*
cc
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
Unused
<
<
cc
-
>
SendGraphicsError
(
stringToSend
)
;
}
else
if
(
XRE_IsGPUProcess
(
)
)
{
GPUParent
*
gp
=
GPUParent
:
:
GetSingleton
(
)
;
Unused
<
<
gp
-
>
SendGraphicsError
(
stringToSend
)
;
}
}
else
{
nsCOMPtr
<
nsIRunnable
>
r1
=
new
LogForwarderEvent
(
stringToSend
)
;
NS_DispatchToMainThread
(
r1
)
;
}
}
}
class
CrashTelemetryEvent
:
public
Runnable
{
virtual
~
CrashTelemetryEvent
(
)
=
default
;
public
:
NS_INLINE_DECL_REFCOUNTING_INHERITED
(
CrashTelemetryEvent
Runnable
)
explicit
CrashTelemetryEvent
(
uint32_t
aReason
)
:
mozilla
:
:
Runnable
(
"
CrashTelemetryEvent
"
)
mReason
(
aReason
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GFX_CRASH
mReason
)
;
return
NS_OK
;
}
protected
:
uint32_t
mReason
;
}
;
void
CrashStatsLogForwarder
:
:
CrashAction
(
LogReason
aReason
)
{
#
ifndef
RELEASE_OR_BETA
static
bool
useTelemetry
=
gfxEnv
:
:
GfxDevCrashTelemetry
(
)
;
#
else
static
bool
useTelemetry
=
!
gfxEnv
:
:
GfxDevCrashMozCrash
(
)
;
#
endif
if
(
useTelemetry
)
{
if
(
NS_IsMainThread
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GFX_CRASH
(
uint32_t
)
aReason
)
;
}
else
{
nsCOMPtr
<
nsIRunnable
>
r1
=
new
CrashTelemetryEvent
(
(
uint32_t
)
aReason
)
;
NS_DispatchToMainThread
(
r1
)
;
}
}
else
{
MOZ_CRASH
(
"
GFX_CRASH
"
)
;
}
}
NS_IMPL_ISUPPORTS
(
SRGBOverrideObserver
nsIObserver
nsISupportsWeakReference
)
#
define
GFX_DOWNLOADABLE_FONTS_ENABLED
"
gfx
.
downloadable_fonts
.
enabled
"
#
define
GFX_PREF_FALLBACK_USE_CMAPS
\
"
gfx
.
font_rendering
.
fallback
.
always_use_cmaps
"
#
define
GFX_PREF_OPENTYPE_SVG
"
gfx
.
font_rendering
.
opentype_svg
.
enabled
"
#
define
GFX_PREF_WORD_CACHE_CHARLIMIT
"
gfx
.
font_rendering
.
wordcache
.
charlimit
"
#
define
GFX_PREF_WORD_CACHE_MAXENTRIES
"
gfx
.
font_rendering
.
wordcache
.
maxentries
"
#
define
GFX_PREF_GRAPHITE_SHAPING
"
gfx
.
font_rendering
.
graphite
.
enabled
"
#
if
defined
(
XP_MACOSX
)
#
define
GFX_PREF_CORETEXT_SHAPING
"
gfx
.
font_rendering
.
coretext
.
enabled
"
#
endif
#
define
BIDI_NUMERAL_PREF
"
bidi
.
numeral
"
#
define
GFX_PREF_CMS_FORCE_SRGB
"
gfx
.
color_management
.
force_srgb
"
#
define
FONT_VARIATIONS_PREF
"
layout
.
css
.
font
-
variations
.
enabled
"
NS_IMETHODIMP
SRGBOverrideObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
someData
)
{
NS_ASSERTION
(
NS_strcmp
(
someData
(
u
"
"
GFX_PREF_CMS_FORCE_SRGB
)
)
=
=
0
"
Restarting
CMS
on
wrong
pref
!
"
)
;
ShutdownCMS
(
)
;
gfxPlatform
:
:
CreateCMSOutputProfile
(
)
;
gfxPlatform
:
:
GetCMSRGBTransform
(
)
;
gfxPlatform
:
:
GetCMSRGBATransform
(
)
;
gfxPlatform
:
:
GetCMSBGRATransform
(
)
;
return
NS_OK
;
}
static
const
char
*
kObservedPrefs
[
]
=
{
"
gfx
.
downloadable_fonts
.
"
"
gfx
.
font_rendering
.
"
BIDI_NUMERAL_PREF
nullptr
}
;
static
void
FontPrefChanged
(
const
char
*
aPref
void
*
aData
)
{
MOZ_ASSERT
(
aPref
)
;
NS_ASSERTION
(
gfxPlatform
:
:
GetPlatform
(
)
"
the
singleton
instance
has
gone
"
)
;
gfxPlatform
:
:
GetPlatform
(
)
-
>
FontsPrefsChanged
(
aPref
)
;
}
void
gfxPlatform
:
:
OnMemoryPressure
(
layers
:
:
MemoryPressureReason
aWhy
)
{
Factory
:
:
PurgeAllCaches
(
)
;
gfxGradientCache
:
:
PurgeAllCaches
(
)
;
gfxFontMissingGlyphs
:
:
Purge
(
)
;
PurgeSkiaFontCache
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
layers
:
:
CompositorManagerChild
*
manager
=
CompositorManagerChild
:
:
GetInstance
(
)
;
if
(
manager
)
{
manager
-
>
SendNotifyMemoryPressure
(
)
;
}
}
}
gfxPlatform
:
:
gfxPlatform
(
)
:
mHasVariationFontSupport
(
false
)
mAzureCanvasBackendCollector
(
this
&
gfxPlatform
:
:
GetAzureBackendInfo
)
mApzSupportCollector
(
this
&
gfxPlatform
:
:
GetApzSupportInfo
)
mTilesInfoCollector
(
this
&
gfxPlatform
:
:
GetTilesSupportInfo
)
mFrameStatsCollector
(
this
&
gfxPlatform
:
:
GetFrameStats
)
mCMSInfoCollector
(
this
&
gfxPlatform
:
:
GetCMSSupportInfo
)
mDisplayInfoCollector
(
this
&
gfxPlatform
:
:
GetDisplayInfo
)
mCompositorBackend
(
layers
:
:
LayersBackend
:
:
LAYERS_NONE
)
mScreenDepth
(
0
)
mScreenPixels
(
0
)
{
mAllowDownloadableFonts
=
UNINITIALIZED_VALUE
;
mFallbackUsesCmaps
=
UNINITIALIZED_VALUE
;
mWordCacheCharLimit
=
UNINITIALIZED_VALUE
;
mWordCacheMaxEntries
=
UNINITIALIZED_VALUE
;
mGraphiteShapingEnabled
=
UNINITIALIZED_VALUE
;
mOpenTypeSVGEnabled
=
UNINITIALIZED_VALUE
;
mBidiNumeralOption
=
UNINITIALIZED_VALUE
;
InitBackendPrefs
(
GetBackendPrefs
(
)
)
;
mTotalSystemMemory
=
PR_GetPhysicalMemorySize
(
)
;
VRManager
:
:
ManagerInit
(
)
;
}
gfxPlatform
*
gfxPlatform
:
:
GetPlatform
(
)
{
if
(
!
gPlatform
)
{
MOZ_RELEASE_ASSERT
(
!
XRE_IsContentProcess
(
)
"
Content
Process
should
have
called
InitChild
(
)
before
"
"
first
GetPlatform
(
)
"
)
;
Init
(
)
;
}
return
gPlatform
;
}
bool
gfxPlatform
:
:
Initialized
(
)
{
return
!
!
gPlatform
;
}
void
gfxPlatform
:
:
InitChild
(
const
ContentDeviceData
&
aData
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
gPlatform
"
InitChild
(
)
should
be
called
before
first
GetPlatform
(
)
"
)
;
gContentDeviceInitData
=
&
aData
;
Init
(
)
;
gContentDeviceInitData
=
nullptr
;
}
void
RecordingPrefChanged
(
const
char
*
aPrefName
void
*
aClosure
)
{
if
(
Preferences
:
:
GetBool
(
"
gfx
.
2d
.
recording
"
false
)
)
{
nsAutoCString
fileName
;
nsAutoString
prefFileName
;
nsresult
rv
=
Preferences
:
:
GetString
(
"
gfx
.
2d
.
recordingfile
"
prefFileName
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
CopyUTF16toUTF8
(
prefFileName
fileName
)
;
}
else
{
nsCOMPtr
<
nsIFile
>
tmpFile
;
if
(
NS_FAILED
(
NS_GetSpecialDirectory
(
NS_OS_TEMP_DIR
getter_AddRefs
(
tmpFile
)
)
)
)
{
return
;
}
fileName
.
AppendPrintf
(
"
moz2drec_
%
i_
%
i
.
aer
"
XRE_GetProcessType
(
)
getpid
(
)
)
;
nsresult
rv
=
tmpFile
-
>
AppendNative
(
fileName
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
#
ifdef
XP_WIN
rv
=
tmpFile
-
>
GetPath
(
prefFileName
)
;
CopyUTF16toUTF8
(
prefFileName
fileName
)
;
#
else
rv
=
tmpFile
-
>
GetNativePath
(
fileName
)
;
#
endif
if
(
NS_FAILED
(
rv
)
)
return
;
}
#
ifdef
XP_WIN
gPlatform
-
>
mRecorder
=
Factory
:
:
CreateEventRecorderForFile
(
prefFileName
.
BeginReading
(
)
)
;
#
else
gPlatform
-
>
mRecorder
=
Factory
:
:
CreateEventRecorderForFile
(
fileName
.
BeginReading
(
)
)
;
#
endif
printf_stderr
(
"
Recording
to
%
s
\
n
"
fileName
.
get
(
)
)
;
Factory
:
:
SetGlobalEventRecorder
(
gPlatform
-
>
mRecorder
)
;
}
else
{
Factory
:
:
SetGlobalEventRecorder
(
nullptr
)
;
}
}
#
define
WR_DEBUG_PREF
"
gfx
.
webrender
.
debug
"
static
void
WebRenderDebugPrefChangeCallback
(
const
char
*
aPrefName
void
*
)
{
wr
:
:
DebugFlags
flags
{
0
}
;
#
define
GFX_WEBRENDER_DEBUG
(
suffix
bit
)
\
if
(
Preferences
:
:
GetBool
(
WR_DEBUG_PREF
suffix
false
)
)
{
\
flags
|
=
(
bit
)
;
\
}
GFX_WEBRENDER_DEBUG
(
"
.
profiler
"
wr
:
:
DebugFlags
:
:
PROFILER_DBG
)
GFX_WEBRENDER_DEBUG
(
"
.
render
-
targets
"
wr
:
:
DebugFlags
:
:
RENDER_TARGET_DBG
)
GFX_WEBRENDER_DEBUG
(
"
.
texture
-
cache
"
wr
:
:
DebugFlags
:
:
TEXTURE_CACHE_DBG
)
GFX_WEBRENDER_DEBUG
(
"
.
gpu
-
time
-
queries
"
wr
:
:
DebugFlags
:
:
GPU_TIME_QUERIES
)
GFX_WEBRENDER_DEBUG
(
"
.
gpu
-
sample
-
queries
"
wr
:
:
DebugFlags
:
:
GPU_SAMPLE_QUERIES
)
GFX_WEBRENDER_DEBUG
(
"
.
disable
-
batching
"
wr
:
:
DebugFlags
:
:
DISABLE_BATCHING
)
GFX_WEBRENDER_DEBUG
(
"
.
epochs
"
wr
:
:
DebugFlags
:
:
EPOCHS
)
GFX_WEBRENDER_DEBUG
(
"
.
compact
-
profiler
"
wr
:
:
DebugFlags
:
:
COMPACT_PROFILER
)
GFX_WEBRENDER_DEBUG
(
"
.
smart
-
profiler
"
wr
:
:
DebugFlags
:
:
SMART_PROFILER
)
GFX_WEBRENDER_DEBUG
(
"
.
echo
-
driver
-
messages
"
wr
:
:
DebugFlags
:
:
ECHO_DRIVER_MESSAGES
)
GFX_WEBRENDER_DEBUG
(
"
.
new
-
frame
-
indicator
"
wr
:
:
DebugFlags
:
:
NEW_FRAME_INDICATOR
)
GFX_WEBRENDER_DEBUG
(
"
.
new
-
scene
-
indicator
"
wr
:
:
DebugFlags
:
:
NEW_SCENE_INDICATOR
)
GFX_WEBRENDER_DEBUG
(
"
.
show
-
overdraw
"
wr
:
:
DebugFlags
:
:
SHOW_OVERDRAW
)
GFX_WEBRENDER_DEBUG
(
"
.
gpu
-
cache
"
wr
:
:
DebugFlags
:
:
GPU_CACHE_DBG
)
GFX_WEBRENDER_DEBUG
(
"
.
slow
-
frame
-
indicator
"
wr
:
:
DebugFlags
:
:
SLOW_FRAME_INDICATOR
)
GFX_WEBRENDER_DEBUG
(
"
.
texture
-
cache
.
clear
-
evicted
"
wr
:
:
DebugFlags
:
:
TEXTURE_CACHE_DBG_CLEAR_EVICTED
)
GFX_WEBRENDER_DEBUG
(
"
.
picture
-
caching
"
wr
:
:
DebugFlags
:
:
PICTURE_CACHING_DBG
)
GFX_WEBRENDER_DEBUG
(
"
.
tile
-
cache
-
logging
"
wr
:
:
DebugFlags
:
:
TILE_CACHE_LOGGING_DBG
)
GFX_WEBRENDER_DEBUG
(
"
.
primitives
"
wr
:
:
DebugFlags
:
:
PRIMITIVE_DBG
)
GFX_WEBRENDER_DEBUG
(
"
.
small
-
screen
"
wr
:
:
DebugFlags
:
:
SMALL_SCREEN
)
GFX_WEBRENDER_DEBUG
(
"
.
disable
-
opaque
-
pass
"
wr
:
:
DebugFlags
:
:
DISABLE_OPAQUE_PASS
)
GFX_WEBRENDER_DEBUG
(
"
.
disable
-
alpha
-
pass
"
wr
:
:
DebugFlags
:
:
DISABLE_ALPHA_PASS
)
GFX_WEBRENDER_DEBUG
(
"
.
disable
-
clip
-
masks
"
wr
:
:
DebugFlags
:
:
DISABLE_CLIP_MASKS
)
GFX_WEBRENDER_DEBUG
(
"
.
disable
-
text
-
prims
"
wr
:
:
DebugFlags
:
:
DISABLE_TEXT_PRIMS
)
GFX_WEBRENDER_DEBUG
(
"
.
disable
-
gradient
-
prims
"
wr
:
:
DebugFlags
:
:
DISABLE_GRADIENT_PRIMS
)
GFX_WEBRENDER_DEBUG
(
"
.
obscure
-
images
"
wr
:
:
DebugFlags
:
:
OBSCURE_IMAGES
)
GFX_WEBRENDER_DEBUG
(
"
.
glyph
-
flashing
"
wr
:
:
DebugFlags
:
:
GLYPH_FLASHING
)
GFX_WEBRENDER_DEBUG
(
"
.
disable
-
raster
-
root
-
scaling
"
wr
:
:
DebugFlags
:
:
DISABLE_RASTER_ROOT_SCALING
)
#
undef
GFX_WEBRENDER_DEBUG
gfx
:
:
gfxVars
:
:
SetWebRenderDebugFlags
(
flags
.
bits
)
;
}
static
void
WebRenderQualityPrefChangeCallback
(
const
char
*
aPref
void
*
)
{
gfxPlatform
:
:
GetPlatform
(
)
-
>
UpdateForceSubpixelAAWherePossible
(
)
;
}
static
void
WebRenderMultithreadingPrefChangeCallback
(
const
char
*
aPrefName
void
*
)
{
bool
enable
=
Preferences
:
:
GetBool
(
StaticPrefs
:
:
GetPrefName_gfx_webrender_enable_multithreading
(
)
true
)
;
gfx
:
:
gfxVars
:
:
SetUseWebRenderMultithreading
(
enable
)
;
}
static
void
WebRenderBatchingPrefChangeCallback
(
const
char
*
aPrefName
void
*
)
{
uint32_t
count
=
Preferences
:
:
GetUint
(
StaticPrefs
:
:
GetPrefName_gfx_webrender_batching_lookback
(
)
10
)
;
gfx
:
:
gfxVars
:
:
SetWebRenderBatchingLookback
(
count
)
;
}
#
if
defined
(
USE_SKIA
)
static
uint32_t
GetSkiaGlyphCacheSize
(
)
{
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
uint32_t
cacheSize
=
StaticPrefs
:
:
gfx_content_skia_font_cache_size_AtStartup
(
)
*
1024
*
1024
;
if
(
mozilla
:
:
BrowserTabsRemoteAutostart
(
)
)
{
return
XRE_IsContentProcess
(
)
?
cacheSize
:
kDefaultGlyphCacheSize
;
}
return
cacheSize
;
#
else
return
kDefaultGlyphCacheSize
;
#
endif
}
#
endif
class
WebRenderMemoryReporter
final
:
public
nsIMemoryReporter
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIMEMORYREPORTER
private
:
~
WebRenderMemoryReporter
(
)
=
default
;
}
;
struct
WebRenderMemoryReporterHelper
{
WebRenderMemoryReporterHelper
(
nsIHandleReportCallback
*
aCallback
nsISupports
*
aData
)
:
mCallback
(
aCallback
)
mData
(
aData
)
{
}
nsCOMPtr
<
nsIHandleReportCallback
>
mCallback
;
nsCOMPtr
<
nsISupports
>
mData
;
void
Report
(
size_t
aBytes
const
char
*
aName
)
const
{
nsPrintfCString
path
(
"
explicit
/
gfx
/
webrender
/
%
s
"
aName
)
;
nsCString
desc
(
NS_LITERAL_CSTRING
(
"
CPU
heap
memory
used
by
WebRender
"
)
)
;
ReportInternal
(
aBytes
path
desc
nsIMemoryReporter
:
:
KIND_HEAP
)
;
}
void
ReportTexture
(
size_t
aBytes
const
char
*
aName
)
const
{
nsPrintfCString
path
(
"
gfx
/
webrender
/
textures
/
%
s
"
aName
)
;
nsCString
desc
(
NS_LITERAL_CSTRING
(
"
GPU
texture
memory
used
by
WebRender
"
)
)
;
ReportInternal
(
aBytes
path
desc
nsIMemoryReporter
:
:
KIND_OTHER
)
;
}
void
ReportTotalGPUBytes
(
size_t
aBytes
)
const
{
nsCString
path
(
NS_LITERAL_CSTRING
(
"
gfx
/
webrender
/
total
-
gpu
-
bytes
"
)
)
;
nsCString
desc
(
NS_LITERAL_CSTRING
(
"
Total
GPU
bytes
used
by
WebRender
(
should
match
textures
/
sum
)
"
)
)
;
ReportInternal
(
aBytes
path
desc
nsIMemoryReporter
:
:
KIND_OTHER
)
;
}
void
ReportInternal
(
size_t
aBytes
nsACString
&
aPath
nsACString
&
aDesc
int32_t
aKind
)
const
{
nsAutoCString
processName
;
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
)
{
GPUParent
:
:
GetGPUProcessName
(
processName
)
;
}
mCallback
-
>
Callback
(
processName
aPath
aKind
nsIMemoryReporter
:
:
UNITS_BYTES
aBytes
aDesc
mData
)
;
}
}
;
static
void
FinishAsyncMemoryReport
(
)
{
nsCOMPtr
<
nsIMemoryReporterManager
>
imgr
=
do_GetService
(
"
mozilla
.
org
/
memory
-
reporter
-
manager
;
1
"
)
;
if
(
imgr
)
{
imgr
-
>
EndReport
(
)
;
}
}
#
define
REPORT_INTERNER
(
id
)
\
helper
.
Report
(
aReport
.
interning
.
interners
.
id
\
"
interning
/
"
#
id
"
/
interners
"
)
;
#
define
REPORT_DATA_STORE
(
id
)
\
helper
.
Report
(
aReport
.
interning
.
data_stores
.
id
\
"
interning
/
"
#
id
"
/
data
-
stores
"
)
;
NS_IMPL_ISUPPORTS
(
WebRenderMemoryReporter
nsIMemoryReporter
)
NS_IMETHODIMP
WebRenderMemoryReporter
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
layers
:
:
CompositorManagerChild
*
manager
=
CompositorManagerChild
:
:
GetInstance
(
)
;
if
(
!
manager
)
{
FinishAsyncMemoryReport
(
)
;
return
NS_OK
;
}
WebRenderMemoryReporterHelper
helper
(
aHandleReport
aData
)
;
manager
-
>
SendReportMemory
(
[
=
]
(
wr
:
:
MemoryReport
aReport
)
{
helper
.
Report
(
aReport
.
clip_stores
"
clip
-
stores
"
)
;
helper
.
Report
(
aReport
.
gpu_cache_metadata
"
gpu
-
cache
/
metadata
"
)
;
helper
.
Report
(
aReport
.
gpu_cache_cpu_mirror
"
gpu
-
cache
/
cpu
-
mirror
"
)
;
helper
.
Report
(
aReport
.
render_tasks
"
render
-
tasks
"
)
;
helper
.
Report
(
aReport
.
hit_testers
"
hit
-
testers
"
)
;
helper
.
Report
(
aReport
.
fonts
"
resource
-
cache
/
fonts
"
)
;
helper
.
Report
(
aReport
.
images
"
resource
-
cache
/
images
"
)
;
helper
.
Report
(
aReport
.
rasterized_blobs
"
resource
-
cache
/
rasterized
-
blobs
"
)
;
helper
.
Report
(
aReport
.
shader_cache
"
shader
-
cache
"
)
;
helper
.
Report
(
aReport
.
display_list
"
display
-
list
"
)
;
WEBRENDER_FOR_EACH_INTERNER
(
REPORT_INTERNER
)
;
WEBRENDER_FOR_EACH_INTERNER
(
REPORT_DATA_STORE
)
;
helper
.
ReportTexture
(
aReport
.
gpu_cache_textures
"
gpu
-
cache
"
)
;
helper
.
ReportTexture
(
aReport
.
vertex_data_textures
"
vertex
-
data
"
)
;
helper
.
ReportTexture
(
aReport
.
render_target_textures
"
render
-
targets
"
)
;
helper
.
ReportTexture
(
aReport
.
texture_cache_textures
"
texture
-
cache
"
)
;
helper
.
ReportTexture
(
aReport
.
depth_target_textures
"
depth
-
targets
"
)
;
helper
.
ReportTexture
(
aReport
.
swap_chain
"
swap
-
chains
"
)
;
FinishAsyncMemoryReport
(
)
;
}
[
]
(
mozilla
:
:
ipc
:
:
ResponseRejectReason
&
&
aReason
)
{
FinishAsyncMemoryReport
(
)
;
}
)
;
return
NS_OK
;
}
#
undef
REPORT_INTERNER
#
undef
REPORT_DATA_STORE
static
void
FrameRatePrefChanged
(
const
char
*
aPref
void
*
)
{
int32_t
newRate
=
gfxPlatform
:
:
ForceSoftwareVsync
(
)
?
gfxPlatform
:
:
GetSoftwareVsyncRate
(
)
:
-
1
;
if
(
newRate
!
=
gLastUsedFrameRate
)
{
gLastUsedFrameRate
=
newRate
;
gfxPlatform
:
:
ReInitFrameRate
(
)
;
}
}
void
gfxPlatform
:
:
Init
(
)
{
MOZ_RELEASE_ASSERT
(
!
XRE_IsGPUProcess
(
)
"
GFX
:
Not
allowed
in
GPU
process
.
"
)
;
MOZ_RELEASE_ASSERT
(
!
XRE_IsRDDProcess
(
)
"
GFX
:
Not
allowed
in
RDD
process
.
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
"
GFX
:
Not
in
main
thread
.
"
)
;
if
(
gEverInitialized
)
{
MOZ_CRASH
(
"
Already
started
?
?
?
"
)
;
}
gEverInitialized
=
true
;
gfxVars
:
:
Initialize
(
)
;
gfxConfig
:
:
Init
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
GPUProcessManager
:
:
Initialize
(
)
;
RDDProcessManager
:
:
Initialize
(
)
;
if
(
Preferences
:
:
GetBool
(
"
media
.
wmf
.
skip
-
blacklist
"
)
)
{
gfxVars
:
:
SetPDMWMFDisableD3D11Dlls
(
nsCString
(
)
)
;
gfxVars
:
:
SetPDMWMFDisableD3D9Dlls
(
nsCString
(
)
)
;
}
else
{
nsAutoCString
d3d11
;
Preferences
:
:
GetCString
(
"
media
.
wmf
.
disable
-
d3d11
-
for
-
dlls
"
d3d11
)
;
gfxVars
:
:
SetPDMWMFDisableD3D11Dlls
(
d3d11
)
;
nsAutoCString
d3d9
;
Preferences
:
:
GetCString
(
"
media
.
wmf
.
disable
-
d3d9
-
for
-
dlls
"
d3d9
)
;
gfxVars
:
:
SetPDMWMFDisableD3D9Dlls
(
d3d9
)
;
}
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_GRE_DIR
getter_AddRefs
(
file
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
gfxVars
:
:
SetGREDirectory
(
nsString
(
)
)
;
}
else
{
nsAutoString
path
;
file
-
>
GetPath
(
path
)
;
gfxVars
:
:
SetGREDirectory
(
nsString
(
path
)
)
;
}
}
if
(
XRE_IsParentProcess
(
)
)
{
nsCOMPtr
<
nsIFile
>
profDir
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_PROFILE_DIR_STARTUP
getter_AddRefs
(
profDir
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
gfxVars
:
:
SetProfDirectory
(
nsString
(
)
)
;
}
else
{
nsAutoString
path
;
profDir
-
>
GetPath
(
path
)
;
gfxVars
:
:
SetProfDirectory
(
nsString
(
path
)
)
;
}
nsAutoCString
path
;
Preferences
:
:
GetCString
(
"
layers
.
windowrecording
.
path
"
path
)
;
gfxVars
:
:
SetLayersWindowRecordingPath
(
path
)
;
}
{
nsAutoCString
forcedPrefs
;
forcedPrefs
.
AppendPrintf
(
"
FP
(
D
%
d
%
d
"
StaticPrefs
:
:
gfx_direct2d_disabled_AtStartup
(
)
StaticPrefs
:
:
gfx_direct2d_force_enabled_AtStartup
(
)
)
;
forcedPrefs
.
AppendPrintf
(
"
-
L
%
d
%
d
%
d
%
d
"
StaticPrefs
:
:
layers_amd_switchable_gfx_enabled_AtStartup
(
)
StaticPrefs
:
:
layers_acceleration_disabled_AtStartup_DoNotUseDirectly
(
)
StaticPrefs
:
:
layers_acceleration_force_enabled_AtStartup_DoNotUseDirectly
(
)
StaticPrefs
:
:
layers_d3d11_force_warp_AtStartup
(
)
)
;
forcedPrefs
.
AppendPrintf
(
"
-
W
%
d
%
d
%
d
%
d
%
d
%
d
%
d
%
d
"
StaticPrefs
:
:
webgl_angle_force_d3d11
(
)
StaticPrefs
:
:
webgl_angle_force_warp
(
)
StaticPrefs
:
:
webgl_disabled
(
)
StaticPrefs
:
:
webgl_disable_angle
(
)
StaticPrefs
:
:
webgl_dxgl_enabled
(
)
StaticPrefs
:
:
webgl_force_enabled
(
)
StaticPrefs
:
:
webgl_force_layers_readback
(
)
StaticPrefs
:
:
webgl_msaa_force
(
)
)
;
forcedPrefs
.
AppendPrintf
(
"
-
T
%
d
%
d
%
d
)
"
StaticPrefs
:
:
gfx_android_rgb16_force_AtStartup
(
)
0
StaticPrefs
:
:
layers_force_shmem_tiles_AtStartup
(
)
)
;
ScopedGfxFeatureReporter
:
:
AppNote
(
forcedPrefs
)
;
}
InitMoz2DLogging
(
)
;
gGfxPlatformPrefsLock
=
new
Mutex
(
"
gfxPlatform
:
:
gGfxPlatformPrefsLock
"
)
;
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
;
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetDXInterop2Blocked
(
IsDXInterop2Blocked
(
)
)
;
gfxVars
:
:
SetDXNV12Blocked
(
IsDXNV12Blocked
(
)
)
;
gfxVars
:
:
SetDXP010Blocked
(
IsDXP010Blocked
(
)
)
;
gfxVars
:
:
SetDXP016Blocked
(
IsDXP016Blocked
(
)
)
;
}
#
if
defined
(
XP_WIN
)
gPlatform
=
new
gfxWindowsPlatform
;
#
elif
defined
(
XP_MACOSX
)
gPlatform
=
new
gfxPlatformMac
;
#
elif
defined
(
MOZ_WIDGET_GTK
)
gPlatform
=
new
gfxPlatformGtk
;
#
elif
defined
(
ANDROID
)
gPlatform
=
new
gfxAndroidPlatform
;
#
else
#
error
"
No
gfxPlatform
implementation
available
"
#
endif
gPlatform
-
>
PopulateScreenInfo
(
)
;
gPlatform
-
>
InitAcceleration
(
)
;
gPlatform
-
>
InitWebRenderConfig
(
)
;
gPlatform
-
>
InitWebGPUConfig
(
)
;
if
(
!
UseWebRender
(
)
#
if
defined
(
XP_WIN
)
&
&
defined
(
NIGHTLY_BUILD
)
|
|
(
UseWebRender
(
)
&
&
XRE_IsParentProcess
(
)
&
&
!
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
&
&
StaticPrefs
:
:
gfx_webrender_enabled_no_gpu_process_with_angle_win_AtStartup
(
)
)
#
endif
)
{
gPlatform
-
>
EnsureDevicesInitialized
(
)
;
}
gPlatform
-
>
InitOMTPConfig
(
)
;
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
)
{
GPUProcessManager
*
gpu
=
GPUProcessManager
:
:
Get
(
)
;
gpu
-
>
LaunchGPUProcess
(
)
;
}
gLastUsedFrameRate
=
ForceSoftwareVsync
(
)
?
GetSoftwareVsyncRate
(
)
:
-
1
;
Preferences
:
:
RegisterCallback
(
FrameRatePrefChanged
nsDependentCString
(
StaticPrefs
:
:
GetPrefName_layout_frame_rate
(
)
)
)
;
ReInitFrameRate
(
)
;
#
ifdef
USE_SKIA
SkGraphics
:
:
Init
(
)
;
#
ifdef
MOZ_ENABLE_FREETYPE
SkInitCairoFT
(
gPlatform
-
>
FontHintingEnabled
(
)
)
;
#
endif
#
endif
InitLayersIPC
(
)
;
gPlatform
-
>
ComputeTileSize
(
)
;
gPlatform
-
>
mHasVariationFontSupport
=
gPlatform
-
>
CheckVariationFontSupport
(
)
;
nsresult
rv
;
rv
=
gfxPlatformFontList
:
:
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_CRASH
(
"
Could
not
initialize
gfxPlatformFontList
"
)
;
}
gPlatform
-
>
mScreenReferenceSurface
=
gPlatform
-
>
CreateOffscreenSurface
(
IntSize
(
1
1
)
SurfaceFormat
:
:
A8R8G8B8_UINT32
)
;
if
(
!
gPlatform
-
>
mScreenReferenceSurface
)
{
MOZ_CRASH
(
"
Could
not
initialize
mScreenReferenceSurface
"
)
;
}
gPlatform
-
>
mScreenReferenceDrawTarget
=
gPlatform
-
>
CreateOffscreenContentDrawTarget
(
IntSize
(
1
1
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
gPlatform
-
>
mScreenReferenceDrawTarget
|
|
!
gPlatform
-
>
mScreenReferenceDrawTarget
-
>
IsValid
(
)
)
{
if
(
!
gPlatform
-
>
DidRenderingDeviceReset
(
)
)
{
gfxCriticalError
(
)
<
<
"
Could
not
initialize
mScreenReferenceDrawTarget
"
;
}
}
rv
=
gfxFontCache
:
:
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_CRASH
(
"
Could
not
initialize
gfxFontCache
"
)
;
}
gPlatform
-
>
mSRGBOverrideObserver
=
new
SRGBOverrideObserver
(
)
;
Preferences
:
:
AddWeakObserver
(
gPlatform
-
>
mSRGBOverrideObserver
GFX_PREF_CMS_FORCE_SRGB
)
;
Preferences
:
:
RegisterPrefixCallbacks
(
FontPrefChanged
kObservedPrefs
)
;
GLContext
:
:
PlatformStartup
(
)
;
Preferences
:
:
RegisterCallbackAndCall
(
RecordingPrefChanged
"
gfx
.
2d
.
recording
"
)
;
CreateCMSOutputProfile
(
)
;
GetCMSRGBTransform
(
)
;
GetCMSRGBATransform
(
)
;
GetCMSBGRATransform
(
)
;
gPlatform
-
>
mMemoryPressureObserver
=
layers
:
:
MemoryPressureObserver
:
:
Create
(
gPlatform
)
;
nsCOMPtr
<
imgITools
>
imgTools
=
do_GetService
(
"
mozilla
.
org
/
image
/
tools
;
1
"
)
;
if
(
!
imgTools
)
{
MOZ_CRASH
(
"
Could
not
initialize
ImageLib
"
)
;
}
RegisterStrongMemoryReporter
(
new
GfxMemoryImageReporter
(
)
)
;
if
(
XRE_IsParentProcess
(
)
&
&
UseWebRender
(
)
)
{
RegisterStrongAsyncMemoryReporter
(
new
WebRenderMemoryReporter
(
)
)
;
}
#
ifdef
USE_SKIA
RegisterStrongMemoryReporter
(
new
SkMemoryReporter
(
)
)
;
#
endif
mlg
:
:
InitializeMemoryReporters
(
)
;
#
ifdef
USE_SKIA
uint32_t
skiaCacheSize
=
GetSkiaGlyphCacheSize
(
)
;
if
(
skiaCacheSize
!
=
kDefaultGlyphCacheSize
)
{
SkGraphics
:
:
SetFontCacheLimit
(
skiaCacheSize
)
;
}
#
endif
InitNullMetadata
(
)
;
InitOpenGLConfig
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
Preferences
:
:
Unlock
(
FONT_VARIATIONS_PREF
)
;
if
(
!
gPlatform
-
>
HasVariationFontSupport
(
)
)
{
Preferences
:
:
SetBool
(
FONT_VARIATIONS_PREF
false
PrefValueKind
:
:
Default
)
;
Preferences
:
:
SetBool
(
FONT_VARIATIONS_PREF
false
)
;
Preferences
:
:
Lock
(
FONT_VARIATIONS_PREF
)
;
}
}
if
(
XRE_IsParentProcess
(
)
)
{
ReportTelemetry
(
)
;
}
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
nullptr
"
gfx
-
features
-
ready
"
nullptr
)
;
}
}
void
gfxPlatform
:
:
ReportTelemetry
(
)
{
MOZ_RELEASE_ASSERT
(
XRE_IsParentProcess
(
)
"
GFX
:
Only
allowed
to
be
called
from
parent
process
.
"
)
;
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
nsTArray
<
uint32_t
>
displayWidths
;
nsTArray
<
uint32_t
>
displayHeights
;
gfxInfo
-
>
GetDisplayWidth
(
displayWidths
)
;
gfxInfo
-
>
GetDisplayHeight
(
displayHeights
)
;
uint32_t
displayCount
=
displayWidths
.
Length
(
)
;
uint32_t
displayWidth
=
displayWidths
.
Length
(
)
>
0
?
displayWidths
[
0
]
:
0
;
uint32_t
displayHeight
=
displayHeights
.
Length
(
)
>
0
?
displayHeights
[
0
]
:
0
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_DISPLAY_COUNT
displayCount
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_DISPLAY_PRIMARY_HEIGHT
displayHeight
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_DISPLAY_PRIMARY_WIDTH
displayWidth
)
;
nsString
adapterDesc
;
gfxInfo
-
>
GetAdapterDescription
(
adapterDesc
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_ADAPTER_DESCRIPTION
adapterDesc
)
;
nsString
adapterVendorId
;
gfxInfo
-
>
GetAdapterVendorID
(
adapterVendorId
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_ADAPTER_VENDOR_ID
adapterVendorId
)
;
nsString
adapterDeviceId
;
gfxInfo
-
>
GetAdapterDeviceID
(
adapterDeviceId
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_ADAPTER_DEVICE_ID
adapterDeviceId
)
;
nsString
adapterSubsystemId
;
gfxInfo
-
>
GetAdapterSubsysID
(
adapterSubsystemId
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_ADAPTER_SUBSYSTEM_ID
adapterSubsystemId
)
;
uint32_t
adapterRam
=
0
;
gfxInfo
-
>
GetAdapterRAM
(
&
adapterRam
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_ADAPTER_RAM
adapterRam
)
;
nsString
adapterDriver
;
gfxInfo
-
>
GetAdapterDriver
(
adapterDriver
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_ADAPTER_DRIVER_FILES
adapterDriver
)
;
nsString
adapterDriverVendor
;
gfxInfo
-
>
GetAdapterDriverVendor
(
adapterDriverVendor
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_ADAPTER_DRIVER_VENDOR
adapterDriverVendor
)
;
nsString
adapterDriverVersion
;
gfxInfo
-
>
GetAdapterDriverVersion
(
adapterDriverVersion
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_ADAPTER_DRIVER_VERSION
adapterDriverVersion
)
;
nsString
adapterDriverDate
;
gfxInfo
-
>
GetAdapterDriverDate
(
adapterDriverDate
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_ADAPTER_DRIVER_DATE
adapterDriverDate
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_HEADLESS
IsHeadless
(
)
)
;
}
static
bool
IsFeatureSupported
(
long
aFeature
bool
aDefault
)
{
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
nsCString
blockId
;
int32_t
status
;
if
(
!
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
aFeature
blockId
&
status
)
)
)
{
return
aDefault
;
}
return
status
=
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
;
}
bool
gfxPlatform
:
:
IsDXInterop2Blocked
(
)
{
return
!
IsFeatureSupported
(
nsIGfxInfo
:
:
FEATURE_DX_INTEROP2
false
)
;
}
bool
gfxPlatform
:
:
IsDXNV12Blocked
(
)
{
return
!
IsFeatureSupported
(
nsIGfxInfo
:
:
FEATURE_DX_NV12
false
)
;
}
bool
gfxPlatform
:
:
IsDXP010Blocked
(
)
{
return
!
IsFeatureSupported
(
nsIGfxInfo
:
:
FEATURE_DX_P010
false
)
;
}
bool
gfxPlatform
:
:
IsDXP016Blocked
(
)
{
return
!
IsFeatureSupported
(
nsIGfxInfo
:
:
FEATURE_DX_P016
false
)
;
}
int32_t
gfxPlatform
:
:
MaxTextureSize
(
)
{
const
int32_t
kMinSizePref
=
2048
;
return
std
:
:
max
(
kMinSizePref
StaticPrefs
:
:
gfx_max_texture_size_AtStartup_DoNotUseDirectly
(
)
)
;
}
int32_t
gfxPlatform
:
:
MaxAllocSize
(
)
{
const
int32_t
kMinAllocPref
=
10000000
;
return
std
:
:
max
(
kMinAllocPref
StaticPrefs
:
:
gfx_max_alloc_size_AtStartup_DoNotUseDirectly
(
)
)
;
}
void
gfxPlatform
:
:
InitMoz2DLogging
(
)
{
auto
fwd
=
new
CrashStatsLogForwarder
(
CrashReporter
:
:
Annotation
:
:
GraphicsCriticalError
)
;
fwd
-
>
SetCircularBufferSize
(
StaticPrefs
:
:
gfx_logging_crash_length_AtStartup
(
)
)
;
mozilla
:
:
gfx
:
:
Config
cfg
;
cfg
.
mLogForwarder
=
fwd
;
cfg
.
mMaxTextureSize
=
gfxPlatform
:
:
MaxTextureSize
(
)
;
cfg
.
mMaxAllocSize
=
gfxPlatform
:
:
MaxAllocSize
(
)
;
gfx
:
:
Factory
:
:
Init
(
cfg
)
;
}
bool
gfxPlatform
:
:
IsHeadless
(
)
{
static
bool
initialized
=
false
;
static
bool
headless
=
false
;
if
(
!
initialized
)
{
initialized
=
true
;
headless
=
PR_GetEnv
(
"
MOZ_HEADLESS
"
)
;
}
return
headless
;
}
bool
gfxPlatform
:
:
UseWebRender
(
)
{
return
gfx
:
:
gfxVars
:
:
UseWebRender
(
)
;
}
bool
gfxPlatform
:
:
CanMigrateMacGPUs
(
)
{
int32_t
pMigration
=
StaticPrefs
:
:
gfx_compositor_gpu_migration
(
)
;
bool
forceDisable
=
pMigration
=
=
0
;
bool
forceEnable
=
pMigration
=
=
2
;
bool
blocked
=
UseWebRender
(
)
;
return
forceEnable
|
|
(
!
forceDisable
&
&
!
blocked
)
;
}
static
bool
sLayersIPCIsUp
=
false
;
void
gfxPlatform
:
:
InitNullMetadata
(
)
{
ScrollMetadata
:
:
sNullMetadata
=
new
ScrollMetadata
(
)
;
ClearOnShutdown
(
&
ScrollMetadata
:
:
sNullMetadata
)
;
}
void
gfxPlatform
:
:
Shutdown
(
)
{
if
(
!
gPlatform
)
{
return
;
}
MOZ_ASSERT
(
!
sLayersIPCIsUp
)
;
gfxFontCache
:
:
Shutdown
(
)
;
gfxGradientCache
:
:
Shutdown
(
)
;
gfxAlphaBoxBlur
:
:
ShutdownBlurCache
(
)
;
gfxGraphiteShaper
:
:
Shutdown
(
)
;
gfxPlatformFontList
:
:
Shutdown
(
)
;
gfxFontMissingGlyphs
:
:
Shutdown
(
)
;
ShutdownTileCache
(
)
;
ShutdownCMS
(
)
;
NS_ASSERTION
(
gPlatform
-
>
mSRGBOverrideObserver
"
mSRGBOverrideObserver
has
alreay
gone
"
)
;
Preferences
:
:
RemoveObserver
(
gPlatform
-
>
mSRGBOverrideObserver
GFX_PREF_CMS_FORCE_SRGB
)
;
gPlatform
-
>
mSRGBOverrideObserver
=
nullptr
;
Preferences
:
:
UnregisterPrefixCallbacks
(
FontPrefChanged
kObservedPrefs
)
;
NS_ASSERTION
(
gPlatform
-
>
mMemoryPressureObserver
"
mMemoryPressureObserver
has
already
gone
"
)
;
if
(
gPlatform
-
>
mMemoryPressureObserver
)
{
gPlatform
-
>
mMemoryPressureObserver
-
>
Unregister
(
)
;
gPlatform
-
>
mMemoryPressureObserver
=
nullptr
;
}
if
(
XRE_IsParentProcess
(
)
)
{
gPlatform
-
>
mVsyncSource
-
>
Shutdown
(
)
;
}
gPlatform
-
>
mVsyncSource
=
nullptr
;
GLContextProvider
:
:
Shutdown
(
)
;
#
if
defined
(
XP_WIN
)
GLContextProviderEGL
:
:
Shutdown
(
)
;
#
endif
if
(
XRE_IsParentProcess
(
)
)
{
GPUProcessManager
:
:
Shutdown
(
)
;
VRProcessManager
:
:
Shutdown
(
)
;
RDDProcessManager
:
:
Shutdown
(
)
;
}
gfx
:
:
Factory
:
:
ShutDown
(
)
;
delete
gGfxPlatformPrefsLock
;
gfxVars
:
:
Shutdown
(
)
;
gfxFont
:
:
DestroySingletons
(
)
;
gfxConfig
:
:
Shutdown
(
)
;
gPlatform
-
>
WillShutdown
(
)
;
delete
gPlatform
;
gPlatform
=
nullptr
;
}
void
gfxPlatform
:
:
InitLayersIPC
(
)
{
if
(
sLayersIPCIsUp
)
{
return
;
}
sLayersIPCIsUp
=
true
;
if
(
XRE_IsContentProcess
(
)
)
{
if
(
gfxVars
:
:
UseOMTP
(
)
)
{
layers
:
:
PaintThread
:
:
Start
(
)
;
}
}
if
(
XRE_IsParentProcess
(
)
)
{
if
(
!
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
&
&
UseWebRender
(
)
)
{
wr
:
:
RenderThread
:
:
Start
(
)
;
image
:
:
ImageMemoryReporter
:
:
InitForWebRender
(
)
;
}
layers
:
:
CompositorThreadHolder
:
:
Start
(
)
;
}
}
void
gfxPlatform
:
:
ShutdownLayersIPC
(
)
{
if
(
!
sLayersIPCIsUp
)
{
return
;
}
sLayersIPCIsUp
=
false
;
#
ifdef
MOZ_WAYLAND
widget
:
:
WaylandDisplayShutdown
(
)
;
#
endif
if
(
XRE_IsContentProcess
(
)
)
{
gfx
:
:
VRManagerChild
:
:
ShutDown
(
)
;
if
(
StaticPrefs
:
:
layers_child_process_shutdown
(
)
)
{
layers
:
:
CompositorManagerChild
:
:
Shutdown
(
)
;
layers
:
:
ImageBridgeChild
:
:
ShutDown
(
)
;
}
if
(
gfxVars
:
:
UseOMTP
(
)
)
{
layers
:
:
PaintThread
:
:
Shutdown
(
)
;
}
}
else
if
(
XRE_IsParentProcess
(
)
)
{
gfx
:
:
VRManagerChild
:
:
ShutDown
(
)
;
layers
:
:
CompositorManagerChild
:
:
Shutdown
(
)
;
layers
:
:
ImageBridgeChild
:
:
ShutDown
(
)
;
layers
:
:
CompositorThreadHolder
:
:
Shutdown
(
)
;
image
:
:
ImageMemoryReporter
:
:
ShutdownForWebRender
(
)
;
if
(
wr
:
:
RenderThread
:
:
Get
(
)
)
{
wr
:
:
RenderThread
:
:
ShutDown
(
)
;
Preferences
:
:
UnregisterCallback
(
WebRenderDebugPrefChangeCallback
WR_DEBUG_PREF
)
;
}
}
else
{
}
}
void
gfxPlatform
:
:
WillShutdown
(
)
{
mScreenReferenceSurface
=
nullptr
;
mScreenReferenceDrawTarget
=
nullptr
;
#
ifdef
USE_SKIA
SkGraphics
:
:
PurgeFontCache
(
)
;
#
endif
#
ifdef
NS_FREE_PERMANENT_DATA
#
if
MOZ_TREE_CAIRO
cairo_debug_reset_static_data
(
)
;
#
endif
#
endif
}
gfxPlatform
:
:
~
gfxPlatform
(
)
=
default
;
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateDrawTargetForSurface
(
gfxASurface
*
aSurface
const
IntSize
&
aSize
)
{
SurfaceFormat
format
=
aSurface
-
>
GetSurfaceFormat
(
)
;
RefPtr
<
DrawTarget
>
drawTarget
=
Factory
:
:
CreateDrawTargetForCairoSurface
(
aSurface
-
>
CairoSurface
(
)
aSize
&
format
)
;
if
(
!
drawTarget
)
{
gfxWarning
(
)
<
<
"
gfxPlatform
:
:
CreateDrawTargetForSurface
failed
in
"
"
CreateDrawTargetForCairoSurface
"
;
return
nullptr
;
}
return
drawTarget
.
forget
(
)
;
}
cairo_user_data_key_t
kSourceSurface
;
struct
SourceSurfaceUserData
{
RefPtr
<
SourceSurface
>
mSrcSurface
;
BackendType
mBackendType
;
}
;
static
void
SourceBufferDestroy
(
void
*
srcSurfUD
)
{
delete
static_cast
<
SourceSurfaceUserData
*
>
(
srcSurfUD
)
;
}
UserDataKey
kThebesSurface
;
struct
DependentSourceSurfaceUserData
{
RefPtr
<
gfxASurface
>
mSurface
;
}
;
static
void
SourceSurfaceDestroyed
(
void
*
aData
)
{
delete
static_cast
<
DependentSourceSurfaceUserData
*
>
(
aData
)
;
}
void
gfxPlatform
:
:
ClearSourceSurfaceForSurface
(
gfxASurface
*
aSurface
)
{
aSurface
-
>
SetData
(
&
kSourceSurface
nullptr
nullptr
)
;
}
already_AddRefed
<
SourceSurface
>
gfxPlatform
:
:
GetSourceSurfaceForSurface
(
RefPtr
<
DrawTarget
>
aTarget
gfxASurface
*
aSurface
bool
aIsPlugin
)
{
if
(
!
aSurface
-
>
CairoSurface
(
)
|
|
aSurface
-
>
CairoStatus
(
)
)
{
return
nullptr
;
}
if
(
!
aTarget
)
{
aTarget
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
;
}
void
*
userData
=
aSurface
-
>
GetData
(
&
kSourceSurface
)
;
if
(
userData
)
{
SourceSurfaceUserData
*
surf
=
static_cast
<
SourceSurfaceUserData
*
>
(
userData
)
;
if
(
surf
-
>
mSrcSurface
-
>
IsValid
(
)
&
&
surf
-
>
mBackendType
=
=
aTarget
-
>
GetBackendType
(
)
)
{
RefPtr
<
SourceSurface
>
srcSurface
(
surf
-
>
mSrcSurface
)
;
return
srcSurface
.
forget
(
)
;
}
}
SurfaceFormat
format
=
aSurface
-
>
GetSurfaceFormat
(
)
;
if
(
aTarget
-
>
GetBackendType
(
)
=
=
BackendType
:
:
CAIRO
)
{
return
Factory
:
:
CreateSourceSurfaceForCairoSurface
(
aSurface
-
>
CairoSurface
(
)
aSurface
-
>
GetSize
(
)
format
)
;
}
RefPtr
<
SourceSurface
>
srcBuffer
;
if
(
!
srcBuffer
)
{
RefPtr
<
DataSourceSurface
>
surf
=
GetWrappedDataSourceSurface
(
aSurface
)
;
if
(
surf
)
{
srcBuffer
=
aIsPlugin
?
aTarget
-
>
OptimizeSourceSurfaceForUnknownAlpha
(
surf
)
:
aTarget
-
>
OptimizeSourceSurface
(
surf
)
;
if
(
srcBuffer
=
=
surf
)
{
return
srcBuffer
.
forget
(
)
;
}
}
}
if
(
!
srcBuffer
)
{
MOZ_ASSERT
(
aTarget
-
>
GetBackendType
(
)
!
=
BackendType
:
:
CAIRO
"
We
already
tried
CreateSourceSurfaceFromNativeSurface
with
a
"
"
DrawTargetCairo
above
"
)
;
srcBuffer
=
Factory
:
:
CreateSourceSurfaceForCairoSurface
(
aSurface
-
>
CairoSurface
(
)
aSurface
-
>
GetSize
(
)
format
)
;
if
(
srcBuffer
)
{
srcBuffer
=
aTarget
-
>
OptimizeSourceSurface
(
srcBuffer
)
;
}
}
if
(
!
srcBuffer
)
{
return
nullptr
;
}
if
(
(
srcBuffer
-
>
GetType
(
)
=
=
SurfaceType
:
:
CAIRO
&
&
static_cast
<
SourceSurfaceCairo
*
>
(
srcBuffer
.
get
(
)
)
-
>
GetSurface
(
)
=
=
aSurface
-
>
CairoSurface
(
)
)
|
|
(
srcBuffer
-
>
GetType
(
)
=
=
SurfaceType
:
:
CAIRO_IMAGE
&
&
static_cast
<
DataSourceSurfaceCairo
*
>
(
srcBuffer
.
get
(
)
)
-
>
GetSurface
(
)
=
=
aSurface
-
>
CairoSurface
(
)
)
)
{
return
srcBuffer
.
forget
(
)
;
}
auto
*
srcSurfUD
=
new
SourceSurfaceUserData
;
srcSurfUD
-
>
mBackendType
=
aTarget
-
>
GetBackendType
(
)
;
srcSurfUD
-
>
mSrcSurface
=
srcBuffer
;
aSurface
-
>
SetData
(
&
kSourceSurface
srcSurfUD
SourceBufferDestroy
)
;
return
srcBuffer
.
forget
(
)
;
}
already_AddRefed
<
DataSourceSurface
>
gfxPlatform
:
:
GetWrappedDataSourceSurface
(
gfxASurface
*
aSurface
)
{
RefPtr
<
gfxImageSurface
>
image
=
aSurface
-
>
GetAsImageSurface
(
)
;
if
(
!
image
)
{
return
nullptr
;
}
RefPtr
<
DataSourceSurface
>
result
=
Factory
:
:
CreateWrappingDataSourceSurface
(
image
-
>
Data
(
)
image
-
>
Stride
(
)
image
-
>
GetSize
(
)
ImageFormatToSurfaceFormat
(
image
-
>
Format
(
)
)
)
;
if
(
!
result
)
{
return
nullptr
;
}
auto
*
srcSurfUD
=
new
DependentSourceSurfaceUserData
;
srcSurfUD
-
>
mSurface
=
aSurface
;
result
-
>
AddUserData
(
&
kThebesSurface
srcSurfUD
SourceSurfaceDestroyed
)
;
return
result
.
forget
(
)
;
}
void
gfxPlatform
:
:
ComputeTileSize
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
int32_t
w
=
StaticPrefs
:
:
layers_tile_width_AtStartup
(
)
;
int32_t
h
=
StaticPrefs
:
:
layers_tile_height_AtStartup
(
)
;
if
(
StaticPrefs
:
:
layers_tiles_adjust_AtStartup
(
)
)
{
gfx
:
:
IntSize
screenSize
=
GetScreenSize
(
)
;
if
(
screenSize
.
width
>
0
)
{
w
=
h
=
clamped
(
int32_t
(
RoundUpPow2
(
screenSize
.
width
)
)
/
4
256
1024
)
;
}
}
MOZ_ASSERT
(
gfxVars
:
:
TileSize
(
)
.
width
=
=
-
1
&
&
gfxVars
:
:
TileSize
(
)
.
height
=
=
-
1
)
;
gfxVars
:
:
SetTileSize
(
IntSize
(
w
h
)
)
;
}
void
gfxPlatform
:
:
PopulateScreenInfo
(
)
{
nsCOMPtr
<
nsIScreenManager
>
manager
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
;
MOZ_ASSERT
(
manager
"
failed
to
get
nsIScreenManager
"
)
;
manager
-
>
GetTotalScreenPixels
(
&
mScreenPixels
)
;
nsCOMPtr
<
nsIScreen
>
screen
;
manager
-
>
GetPrimaryScreen
(
getter_AddRefs
(
screen
)
)
;
if
(
!
screen
)
{
return
;
}
screen
-
>
GetColorDepth
(
&
mScreenDepth
)
;
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetScreenDepth
(
mScreenDepth
)
;
}
int
left
top
;
screen
-
>
GetRect
(
&
left
&
top
&
mScreenSize
.
width
&
mScreenSize
.
height
)
;
}
bool
gfxPlatform
:
:
SupportsAzureContentForDrawTarget
(
DrawTarget
*
aTarget
)
{
if
(
!
aTarget
|
|
!
aTarget
-
>
IsValid
(
)
)
{
return
false
;
}
return
SupportsAzureContentForType
(
aTarget
-
>
GetBackendType
(
)
)
;
}
void
gfxPlatform
:
:
PurgeSkiaFontCache
(
)
{
#
ifdef
USE_SKIA
if
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetDefaultContentBackend
(
)
=
=
BackendType
:
:
SKIA
)
{
SkGraphics
:
:
PurgeFontCache
(
)
;
}
#
endif
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateDrawTargetForBackend
(
BackendType
aBackend
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
if
(
aBackend
=
=
BackendType
:
:
CAIRO
)
{
RefPtr
<
gfxASurface
>
surf
=
CreateOffscreenSurface
(
aSize
SurfaceFormatToImageFormat
(
aFormat
)
)
;
if
(
!
surf
|
|
surf
-
>
CairoStatus
(
)
)
{
return
nullptr
;
}
return
CreateDrawTargetForSurface
(
surf
aSize
)
;
}
return
Factory
:
:
CreateDrawTarget
(
aBackend
aSize
aFormat
)
;
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateOffscreenCanvasDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
NS_ASSERTION
(
mPreferredCanvasBackend
!
=
BackendType
:
:
NONE
"
No
backend
.
"
)
;
RefPtr
<
DrawTarget
>
target
=
CreateDrawTargetForBackend
(
mPreferredCanvasBackend
aSize
aFormat
)
;
if
(
target
|
|
mFallbackCanvasBackend
=
=
BackendType
:
:
NONE
)
{
return
target
.
forget
(
)
;
}
#
ifdef
XP_WIN
return
Factory
:
:
CreateDrawTarget
(
mFallbackCanvasBackend
aSize
aFormat
)
;
#
else
return
CreateDrawTargetForBackend
(
mFallbackCanvasBackend
aSize
aFormat
)
;
#
endif
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateOffscreenContentDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
bool
aFallback
)
{
BackendType
backend
=
(
aFallback
)
?
mSoftwareBackend
:
mContentBackend
;
NS_ASSERTION
(
backend
!
=
BackendType
:
:
NONE
"
No
backend
.
"
)
;
RefPtr
<
DrawTarget
>
dt
=
CreateDrawTargetForBackend
(
backend
aSize
aFormat
)
;
if
(
!
dt
)
{
return
nullptr
;
}
dt
-
>
ClearRect
(
gfx
:
:
Rect
(
)
)
;
if
(
!
dt
-
>
IsValid
(
)
)
{
return
nullptr
;
}
return
dt
.
forget
(
)
;
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateSimilarSoftwareDrawTarget
(
DrawTarget
*
aDT
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
RefPtr
<
DrawTarget
>
dt
;
if
(
Factory
:
:
DoesBackendSupportDataDrawtarget
(
aDT
-
>
GetBackendType
(
)
)
)
{
dt
=
aDT
-
>
CreateSimilarDrawTarget
(
aSize
aFormat
)
;
}
else
{
#
ifdef
USE_SKIA
BackendType
backendType
=
BackendType
:
:
SKIA
;
#
else
BackendType
backendType
=
BackendType
:
:
CAIRO
;
#
endif
dt
=
Factory
:
:
CreateDrawTarget
(
backendType
aSize
aFormat
)
;
}
return
dt
.
forget
(
)
;
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateDrawTargetForData
(
unsigned
char
*
aData
const
IntSize
&
aSize
int32_t
aStride
SurfaceFormat
aFormat
bool
aUninitialized
)
{
BackendType
backendType
=
gfxVars
:
:
ContentBackend
(
)
;
NS_ASSERTION
(
backendType
!
=
BackendType
:
:
NONE
"
No
backend
.
"
)
;
if
(
!
Factory
:
:
DoesBackendSupportDataDrawtarget
(
backendType
)
)
{
#
ifdef
USE_SKIA
backendType
=
BackendType
:
:
SKIA
;
#
else
backendType
=
BackendType
:
:
CAIRO
;
#
endif
}
RefPtr
<
DrawTarget
>
dt
=
Factory
:
:
CreateDrawTargetForData
(
backendType
aData
aSize
aStride
aFormat
aUninitialized
)
;
return
dt
.
forget
(
)
;
}
BackendType
gfxPlatform
:
:
BackendTypeForName
(
const
nsCString
&
aName
)
{
if
(
aName
.
EqualsLiteral
(
"
cairo
"
)
)
return
BackendType
:
:
CAIRO
;
if
(
aName
.
EqualsLiteral
(
"
skia
"
)
)
return
BackendType
:
:
SKIA
;
if
(
aName
.
EqualsLiteral
(
"
direct2d
"
)
)
return
BackendType
:
:
DIRECT2D
;
if
(
aName
.
EqualsLiteral
(
"
direct2d1
.
1
"
)
)
return
BackendType
:
:
DIRECT2D1_1
;
return
BackendType
:
:
NONE
;
}
nsresult
gfxPlatform
:
:
GetFontList
(
nsAtom
*
aLangGroup
const
nsACString
&
aGenericFamily
nsTArray
<
nsString
>
&
aListOfFonts
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
GetFontList
(
aLangGroup
aGenericFamily
aListOfFonts
)
;
return
NS_OK
;
}
nsresult
gfxPlatform
:
:
UpdateFontList
(
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
UpdateFontList
(
)
;
return
NS_OK
;
}
void
gfxPlatform
:
:
GetStandardFamilyName
(
const
nsCString
&
aFontName
nsACString
&
aFamilyName
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
GetStandardFamilyName
(
aFontName
aFamilyName
)
;
}
nsAutoCString
gfxPlatform
:
:
GetDefaultFontName
(
const
nsACString
&
aLangGroup
const
nsACString
&
aGenericFamily
)
{
nsAutoCString
result
;
FamilyAndGeneric
fam
=
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
GetDefaultFontFamily
(
aLangGroup
aGenericFamily
)
;
if
(
fam
.
mFamily
.
mIsShared
)
{
if
(
fam
.
mFamily
.
mShared
)
{
fontlist
:
:
FontList
*
fontList
=
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
SharedFontList
(
)
;
result
=
fam
.
mFamily
.
mShared
-
>
DisplayName
(
)
.
AsString
(
fontList
)
;
}
}
else
if
(
fam
.
mFamily
.
mUnshared
)
{
fam
.
mFamily
.
mUnshared
-
>
LocalizedName
(
result
)
;
}
return
result
;
}
bool
gfxPlatform
:
:
DownloadableFontsEnabled
(
)
{
if
(
mAllowDownloadableFonts
=
=
UNINITIALIZED_VALUE
)
{
mAllowDownloadableFonts
=
Preferences
:
:
GetBool
(
GFX_DOWNLOADABLE_FONTS_ENABLED
false
)
;
}
return
mAllowDownloadableFonts
;
}
bool
gfxPlatform
:
:
UseCmapsDuringSystemFallback
(
)
{
if
(
mFallbackUsesCmaps
=
=
UNINITIALIZED_VALUE
)
{
mFallbackUsesCmaps
=
Preferences
:
:
GetBool
(
GFX_PREF_FALLBACK_USE_CMAPS
false
)
;
}
return
mFallbackUsesCmaps
;
}
bool
gfxPlatform
:
:
OpenTypeSVGEnabled
(
)
{
if
(
mOpenTypeSVGEnabled
=
=
UNINITIALIZED_VALUE
)
{
mOpenTypeSVGEnabled
=
Preferences
:
:
GetBool
(
GFX_PREF_OPENTYPE_SVG
false
)
;
}
return
mOpenTypeSVGEnabled
>
0
;
}
uint32_t
gfxPlatform
:
:
WordCacheCharLimit
(
)
{
if
(
mWordCacheCharLimit
=
=
UNINITIALIZED_VALUE
)
{
mWordCacheCharLimit
=
Preferences
:
:
GetInt
(
GFX_PREF_WORD_CACHE_CHARLIMIT
32
)
;
if
(
mWordCacheCharLimit
<
0
)
{
mWordCacheCharLimit
=
32
;
}
}
return
uint32_t
(
mWordCacheCharLimit
)
;
}
uint32_t
gfxPlatform
:
:
WordCacheMaxEntries
(
)
{
if
(
mWordCacheMaxEntries
=
=
UNINITIALIZED_VALUE
)
{
mWordCacheMaxEntries
=
Preferences
:
:
GetInt
(
GFX_PREF_WORD_CACHE_MAXENTRIES
10000
)
;
if
(
mWordCacheMaxEntries
<
0
)
{
mWordCacheMaxEntries
=
10000
;
}
}
return
uint32_t
(
mWordCacheMaxEntries
)
;
}
bool
gfxPlatform
:
:
UseGraphiteShaping
(
)
{
if
(
mGraphiteShapingEnabled
=
=
UNINITIALIZED_VALUE
)
{
mGraphiteShapingEnabled
=
Preferences
:
:
GetBool
(
GFX_PREF_GRAPHITE_SHAPING
false
)
;
}
return
mGraphiteShapingEnabled
;
}
bool
gfxPlatform
:
:
IsFontFormatSupported
(
uint32_t
aFormatFlags
)
{
MOZ_ASSERT
(
!
(
aFormatFlags
&
gfxUserFontSet
:
:
FLAG_FORMAT_NOT_USED
)
"
strange
font
format
hint
set
"
)
;
if
(
aFormatFlags
&
gfxUserFontSet
:
:
FLAG_FORMATS_COMMON
)
{
return
true
;
}
if
(
aFormatFlags
!
=
0
)
{
return
false
;
}
return
true
;
}
gfxFontGroup
*
gfxPlatform
:
:
CreateFontGroup
(
const
FontFamilyList
&
aFontFamilyList
const
gfxFontStyle
*
aStyle
gfxTextPerfMetrics
*
aTextPerf
FontMatchingStats
*
aFontMatchingStats
gfxUserFontSet
*
aUserFontSet
gfxFloat
aDevToCssSize
)
const
{
return
new
gfxFontGroup
(
aFontFamilyList
aStyle
aTextPerf
aFontMatchingStats
aUserFontSet
aDevToCssSize
)
;
}
gfxFontEntry
*
gfxPlatform
:
:
LookupLocalFont
(
const
nsACString
&
aFontName
WeightRange
aWeightForEntry
StretchRange
aStretchForEntry
SlantStyleRange
aStyleForEntry
)
{
return
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
LookupLocalFont
(
aFontName
aWeightForEntry
aStretchForEntry
aStyleForEntry
)
;
}
gfxFontEntry
*
gfxPlatform
:
:
MakePlatformFont
(
const
nsACString
&
aFontName
WeightRange
aWeightForEntry
StretchRange
aStretchForEntry
SlantStyleRange
aStyleForEntry
const
uint8_t
*
aFontData
uint32_t
aLength
)
{
return
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
MakePlatformFont
(
aFontName
aWeightForEntry
aStretchForEntry
aStyleForEntry
aFontData
aLength
)
;
}
mozilla
:
:
layers
:
:
DiagnosticTypes
gfxPlatform
:
:
GetLayerDiagnosticTypes
(
)
{
mozilla
:
:
layers
:
:
DiagnosticTypes
type
=
DiagnosticTypes
:
:
NO_DIAGNOSTIC
;
if
(
StaticPrefs
:
:
layers_draw_borders
(
)
)
{
type
|
=
mozilla
:
:
layers
:
:
DiagnosticTypes
:
:
LAYER_BORDERS
;
}
if
(
StaticPrefs
:
:
layers_draw_tile_borders
(
)
)
{
type
|
=
mozilla
:
:
layers
:
:
DiagnosticTypes
:
:
TILE_BORDERS
;
}
if
(
StaticPrefs
:
:
layers_draw_bigimage_borders
(
)
)
{
type
|
=
mozilla
:
:
layers
:
:
DiagnosticTypes
:
:
BIGIMAGE_BORDERS
;
}
if
(
StaticPrefs
:
:
layers_flash_borders
(
)
)
{
type
|
=
mozilla
:
:
layers
:
:
DiagnosticTypes
:
:
FLASH_BORDERS
;
}
return
type
;
}
BackendPrefsData
gfxPlatform
:
:
GetBackendPrefs
(
)
const
{
BackendPrefsData
data
;
data
.
mCanvasBitmask
=
BackendTypeBit
(
BackendType
:
:
SKIA
)
;
data
.
mContentBitmask
=
BackendTypeBit
(
BackendType
:
:
SKIA
)
;
#
ifdef
MOZ_WIDGET_GTK
data
.
mCanvasBitmask
|
=
BackendTypeBit
(
BackendType
:
:
CAIRO
)
;
data
.
mContentBitmask
|
=
BackendTypeBit
(
BackendType
:
:
CAIRO
)
;
#
endif
data
.
mCanvasDefault
=
BackendType
:
:
SKIA
;
data
.
mContentDefault
=
BackendType
:
:
SKIA
;
return
data
;
}
void
gfxPlatform
:
:
InitBackendPrefs
(
BackendPrefsData
&
&
aPrefsData
)
{
mPreferredCanvasBackend
=
GetCanvasBackendPref
(
aPrefsData
.
mCanvasBitmask
)
;
if
(
mPreferredCanvasBackend
=
=
BackendType
:
:
NONE
)
{
mPreferredCanvasBackend
=
aPrefsData
.
mCanvasDefault
;
}
if
(
mPreferredCanvasBackend
=
=
BackendType
:
:
DIRECT2D1_1
)
{
mFallbackCanvasBackend
=
GetCanvasBackendPref
(
aPrefsData
.
mCanvasBitmask
&
~
(
BackendTypeBit
(
mPreferredCanvasBackend
)
|
BackendTypeBit
(
BackendType
:
:
DIRECT2D
)
)
)
;
}
else
{
mFallbackCanvasBackend
=
GetCanvasBackendPref
(
aPrefsData
.
mCanvasBitmask
&
~
BackendTypeBit
(
mPreferredCanvasBackend
)
)
;
}
mContentBackendBitmask
=
aPrefsData
.
mContentBitmask
;
mContentBackend
=
GetContentBackendPref
(
mContentBackendBitmask
)
;
if
(
mContentBackend
=
=
BackendType
:
:
NONE
)
{
mContentBackend
=
aPrefsData
.
mContentDefault
;
mContentBackendBitmask
|
=
BackendTypeBit
(
aPrefsData
.
mContentDefault
)
;
}
uint32_t
swBackendBits
=
BackendTypeBit
(
BackendType
:
:
SKIA
)
;
#
ifdef
MOZ_WIDGET_GTK
swBackendBits
|
=
BackendTypeBit
(
BackendType
:
:
CAIRO
)
;
#
endif
mSoftwareBackend
=
GetContentBackendPref
(
swBackendBits
)
;
if
(
mSoftwareBackend
=
=
BackendType
:
:
NONE
)
{
mSoftwareBackend
=
BackendType
:
:
SKIA
;
}
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetContentBackend
(
mContentBackend
)
;
gfxVars
:
:
SetSoftwareBackend
(
mSoftwareBackend
)
;
}
}
BackendType
gfxPlatform
:
:
GetCanvasBackendPref
(
uint32_t
aBackendBitmask
)
{
return
GetBackendPref
(
"
gfx
.
canvas
.
azure
.
backends
"
aBackendBitmask
)
;
}
BackendType
gfxPlatform
:
:
GetContentBackendPref
(
uint32_t
&
aBackendBitmask
)
{
return
GetBackendPref
(
"
gfx
.
content
.
azure
.
backends
"
aBackendBitmask
)
;
}
BackendType
gfxPlatform
:
:
GetBackendPref
(
const
char
*
aBackendPrefName
uint32_t
&
aBackendBitmask
)
{
nsTArray
<
nsCString
>
backendList
;
nsAutoCString
prefString
;
if
(
NS_SUCCEEDED
(
Preferences
:
:
GetCString
(
aBackendPrefName
prefString
)
)
)
{
ParseString
(
prefString
'
'
backendList
)
;
}
uint32_t
allowedBackends
=
0
;
BackendType
result
=
BackendType
:
:
NONE
;
for
(
uint32_t
i
=
0
;
i
<
backendList
.
Length
(
)
;
+
+
i
)
{
BackendType
type
=
BackendTypeForName
(
backendList
[
i
]
)
;
if
(
BackendTypeBit
(
type
)
&
aBackendBitmask
)
{
allowedBackends
|
=
BackendTypeBit
(
type
)
;
if
(
result
=
=
BackendType
:
:
NONE
)
{
result
=
type
;
}
}
}
aBackendBitmask
=
allowedBackends
;
return
result
;
}
bool
gfxPlatform
:
:
InSafeMode
(
)
{
static
bool
sSafeModeInitialized
=
false
;
static
bool
sInSafeMode
=
false
;
if
(
!
sSafeModeInitialized
)
{
sSafeModeInitialized
=
true
;
nsCOMPtr
<
nsIXULRuntime
>
xr
=
do_GetService
(
"
mozilla
.
org
/
xre
/
runtime
;
1
"
)
;
if
(
xr
)
{
xr
-
>
GetInSafeMode
(
&
sInSafeMode
)
;
}
}
return
sInSafeMode
;
}
bool
gfxPlatform
:
:
OffMainThreadCompositingEnabled
(
)
{
return
UsesOffMainThreadCompositing
(
)
;
}
eCMSMode
gfxPlatform
:
:
GetCMSMode
(
)
{
if
(
!
gCMSInitialized
)
{
int32_t
mode
=
StaticPrefs
:
:
gfx_color_management_mode
(
)
;
if
(
mode
>
=
0
&
&
mode
<
eCMSMode_AllCount
)
{
gCMSMode
=
static_cast
<
eCMSMode
>
(
mode
)
;
}
bool
enableV4
=
StaticPrefs
:
:
gfx_color_management_enablev4
(
)
;
if
(
enableV4
)
{
qcms_enable_iccv4
(
)
;
}
#
ifdef
MOZILLA_MAY_SUPPORT_AVX
if
(
mozilla
:
:
supports_avx
(
)
)
{
qcms_enable_avx
(
)
;
}
#
endif
#
ifdef
MOZILLA_MAY_SUPPORT_NEON
if
(
mozilla
:
:
supports_neon
(
)
)
{
qcms_enable_neon
(
)
;
}
#
endif
gCMSInitialized
=
true
;
}
return
gCMSMode
;
}
void
gfxPlatform
:
:
SetCMSModeOverride
(
eCMSMode
aMode
)
{
MOZ_ASSERT
(
gCMSInitialized
)
;
gCMSMode
=
aMode
;
}
int
gfxPlatform
:
:
GetRenderingIntent
(
)
{
MOZ_ASSERT
(
QCMS_INTENT_DEFAULT
=
=
0
)
;
int32_t
pIntent
=
StaticPrefs
:
:
gfx_color_management_rendering_intent
(
)
;
if
(
(
pIntent
<
QCMS_INTENT_MIN
)
|
|
(
pIntent
>
QCMS_INTENT_MAX
)
)
{
pIntent
=
-
1
;
}
return
pIntent
;
}
DeviceColor
gfxPlatform
:
:
TransformPixel
(
const
sRGBColor
&
in
qcms_transform
*
transform
)
{
if
(
transform
)
{
#
ifdef
IS_LITTLE_ENDIAN
uint32_t
packed
=
in
.
ToABGR
(
)
;
qcms_transform_data
(
transform
(
uint8_t
*
)
&
packed
(
uint8_t
*
)
&
packed
1
)
;
auto
out
=
DeviceColor
:
:
FromABGR
(
packed
)
;
#
else
uint32_t
packed
=
in
.
UnusualToARGB
(
)
;
qcms_transform_data
(
transform
(
uint8_t
*
)
&
packed
+
1
(
uint8_t
*
)
&
packed
+
1
1
)
;
auto
out
=
DeviceColor
:
:
UnusualFromARGB
(
packed
)
;
#
endif
out
.
a
=
in
.
a
;
return
out
;
}
return
DeviceColor
(
in
.
r
in
.
g
in
.
b
in
.
a
)
;
}
nsTArray
<
uint8_t
>
gfxPlatform
:
:
GetPlatformCMSOutputProfileData
(
)
{
return
GetPrefCMSOutputProfileData
(
)
;
}
nsTArray
<
uint8_t
>
gfxPlatform
:
:
GetPrefCMSOutputProfileData
(
)
{
nsAutoCString
fname
;
Preferences
:
:
GetCString
(
"
gfx
.
color_management
.
display_profile
"
fname
)
;
if
(
fname
.
IsEmpty
(
)
)
{
return
nsTArray
<
uint8_t
>
(
)
;
}
void
*
mem
=
nullptr
;
size_t
size
=
0
;
qcms_data_from_path
(
fname
.
get
(
)
&
mem
&
size
)
;
nsTArray
<
uint8_t
>
result
;
if
(
mem
)
{
result
.
AppendElements
(
static_cast
<
uint8_t
*
>
(
mem
)
size
)
;
free
(
mem
)
;
}
return
result
;
}
const
mozilla
:
:
gfx
:
:
ContentDeviceData
*
gfxPlatform
:
:
GetInitContentDeviceData
(
)
{
return
gContentDeviceInitData
;
}
void
gfxPlatform
:
:
CreateCMSOutputProfile
(
)
{
if
(
!
gCMSOutputProfile
)
{
if
(
Preferences
:
:
GetBool
(
GFX_PREF_CMS_FORCE_SRGB
false
)
)
{
gCMSOutputProfile
=
GetCMSsRGBProfile
(
)
;
}
if
(
!
gCMSOutputProfile
)
{
nsTArray
<
uint8_t
>
outputProfileData
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetPlatformCMSOutputProfileData
(
)
;
if
(
!
outputProfileData
.
IsEmpty
(
)
)
{
gCMSOutputProfile
=
qcms_profile_from_memory
(
outputProfileData
.
Elements
(
)
outputProfileData
.
Length
(
)
)
;
}
}
if
(
gCMSOutputProfile
&
&
qcms_profile_is_bogus
(
gCMSOutputProfile
)
)
{
NS_ASSERTION
(
gCMSOutputProfile
!
=
GetCMSsRGBProfile
(
)
"
Builtin
sRGB
profile
tagged
as
bogus
!
!
!
"
)
;
qcms_profile_release
(
gCMSOutputProfile
)
;
gCMSOutputProfile
=
nullptr
;
}
if
(
!
gCMSOutputProfile
)
{
gCMSOutputProfile
=
GetCMSsRGBProfile
(
)
;
}
qcms_profile_precache_output_transform
(
gCMSOutputProfile
)
;
}
}
qcms_profile
*
gfxPlatform
:
:
GetCMSOutputProfile
(
)
{
return
gCMSOutputProfile
;
}
qcms_profile
*
gfxPlatform
:
:
GetCMSsRGBProfile
(
)
{
if
(
!
gCMSsRGBProfile
)
{
gCMSsRGBProfile
=
qcms_profile_sRGB
(
)
;
}
return
gCMSsRGBProfile
;
}
qcms_transform
*
gfxPlatform
:
:
GetCMSRGBTransform
(
)
{
if
(
!
gCMSRGBTransform
&
&
!
gCMSRGBTransformFailed
)
{
qcms_profile
*
inProfile
*
outProfile
;
outProfile
=
GetCMSOutputProfile
(
)
;
inProfile
=
GetCMSsRGBProfile
(
)
;
if
(
!
inProfile
|
|
!
outProfile
)
return
nullptr
;
gCMSRGBTransform
=
qcms_transform_create
(
inProfile
QCMS_DATA_RGB_8
outProfile
QCMS_DATA_RGB_8
QCMS_INTENT_PERCEPTUAL
)
;
if
(
!
gCMSRGBTransform
)
{
gCMSRGBTransformFailed
=
true
;
}
}
return
gCMSRGBTransform
;
}
qcms_transform
*
gfxPlatform
:
:
GetCMSInverseRGBTransform
(
)
{
if
(
!
gCMSInverseRGBTransform
)
{
qcms_profile
*
inProfile
*
outProfile
;
inProfile
=
GetCMSOutputProfile
(
)
;
outProfile
=
GetCMSsRGBProfile
(
)
;
if
(
!
inProfile
|
|
!
outProfile
)
return
nullptr
;
gCMSInverseRGBTransform
=
qcms_transform_create
(
inProfile
QCMS_DATA_RGB_8
outProfile
QCMS_DATA_RGB_8
QCMS_INTENT_PERCEPTUAL
)
;
}
return
gCMSInverseRGBTransform
;
}
qcms_transform
*
gfxPlatform
:
:
GetCMSRGBATransform
(
)
{
if
(
!
gCMSRGBATransform
)
{
qcms_profile
*
inProfile
*
outProfile
;
outProfile
=
GetCMSOutputProfile
(
)
;
inProfile
=
GetCMSsRGBProfile
(
)
;
if
(
!
inProfile
|
|
!
outProfile
)
return
nullptr
;
gCMSRGBATransform
=
qcms_transform_create
(
inProfile
QCMS_DATA_RGBA_8
outProfile
QCMS_DATA_RGBA_8
QCMS_INTENT_PERCEPTUAL
)
;
}
return
gCMSRGBATransform
;
}
qcms_transform
*
gfxPlatform
:
:
GetCMSBGRATransform
(
)
{
if
(
!
gCMSBGRATransform
)
{
qcms_profile
*
inProfile
*
outProfile
;
outProfile
=
GetCMSOutputProfile
(
)
;
inProfile
=
GetCMSsRGBProfile
(
)
;
if
(
!
inProfile
|
|
!
outProfile
)
return
nullptr
;
gCMSBGRATransform
=
qcms_transform_create
(
inProfile
QCMS_DATA_BGRA_8
outProfile
QCMS_DATA_BGRA_8
QCMS_INTENT_PERCEPTUAL
)
;
}
return
gCMSBGRATransform
;
}
qcms_transform
*
gfxPlatform
:
:
GetCMSOSRGBATransform
(
)
{
switch
(
SurfaceFormat
:
:
OS_RGBA
)
{
case
SurfaceFormat
:
:
B8G8R8A8
:
return
GetCMSBGRATransform
(
)
;
case
SurfaceFormat
:
:
R8G8B8A8
:
return
GetCMSRGBATransform
(
)
;
default
:
return
nullptr
;
}
}
qcms_data_type
gfxPlatform
:
:
GetCMSOSRGBAType
(
)
{
switch
(
SurfaceFormat
:
:
OS_RGBA
)
{
case
SurfaceFormat
:
:
B8G8R8A8
:
return
QCMS_DATA_BGRA_8
;
case
SurfaceFormat
:
:
R8G8B8A8
:
return
QCMS_DATA_RGBA_8
;
default
:
return
QCMS_DATA_RGBA_8
;
}
}
static
void
ShutdownCMS
(
)
{
if
(
gCMSRGBTransform
)
{
qcms_transform_release
(
gCMSRGBTransform
)
;
gCMSRGBTransform
=
nullptr
;
}
if
(
gCMSInverseRGBTransform
)
{
qcms_transform_release
(
gCMSInverseRGBTransform
)
;
gCMSInverseRGBTransform
=
nullptr
;
}
if
(
gCMSRGBATransform
)
{
qcms_transform_release
(
gCMSRGBATransform
)
;
gCMSRGBATransform
=
nullptr
;
}
if
(
gCMSBGRATransform
)
{
qcms_transform_release
(
gCMSBGRATransform
)
;
gCMSBGRATransform
=
nullptr
;
}
if
(
gCMSOutputProfile
)
{
qcms_profile_release
(
gCMSOutputProfile
)
;
if
(
gCMSsRGBProfile
=
=
gCMSOutputProfile
)
gCMSsRGBProfile
=
nullptr
;
gCMSOutputProfile
=
nullptr
;
}
if
(
gCMSsRGBProfile
)
{
qcms_profile_release
(
gCMSsRGBProfile
)
;
gCMSsRGBProfile
=
nullptr
;
}
gCMSMode
=
eCMSMode_Off
;
gCMSInitialized
=
false
;
}
int32_t
gfxPlatform
:
:
GetBidiNumeralOption
(
)
{
if
(
mBidiNumeralOption
=
=
UNINITIALIZED_VALUE
)
{
mBidiNumeralOption
=
Preferences
:
:
GetInt
(
BIDI_NUMERAL_PREF
0
)
;
}
return
mBidiNumeralOption
;
}
void
gfxPlatform
:
:
FlushFontAndWordCaches
(
)
{
gfxFontCache
*
fontCache
=
gfxFontCache
:
:
GetCache
(
)
;
if
(
fontCache
)
{
fontCache
-
>
Flush
(
)
;
}
gfxPlatform
:
:
PurgeSkiaFontCache
(
)
;
}
void
gfxPlatform
:
:
ForceGlobalReflow
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
XRE_IsParentProcess
(
)
)
{
static
const
char
kPrefName
[
]
=
"
font
.
internaluseonly
.
changed
"
;
bool
fontInternalChange
=
Preferences
:
:
GetBool
(
kPrefName
false
)
;
Preferences
:
:
SetBool
(
kPrefName
!
fontInternalChange
)
;
}
else
{
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
nullptr
"
font
-
info
-
updated
"
nullptr
)
;
}
}
}
void
gfxPlatform
:
:
FontsPrefsChanged
(
const
char
*
aPref
)
{
NS_ASSERTION
(
aPref
!
=
nullptr
"
null
preference
"
)
;
if
(
!
strcmp
(
GFX_DOWNLOADABLE_FONTS_ENABLED
aPref
)
)
{
mAllowDownloadableFonts
=
UNINITIALIZED_VALUE
;
}
else
if
(
!
strcmp
(
GFX_PREF_FALLBACK_USE_CMAPS
aPref
)
)
{
mFallbackUsesCmaps
=
UNINITIALIZED_VALUE
;
}
else
if
(
!
strcmp
(
GFX_PREF_WORD_CACHE_CHARLIMIT
aPref
)
)
{
mWordCacheCharLimit
=
UNINITIALIZED_VALUE
;
FlushFontAndWordCaches
(
)
;
}
else
if
(
!
strcmp
(
GFX_PREF_WORD_CACHE_MAXENTRIES
aPref
)
)
{
mWordCacheMaxEntries
=
UNINITIALIZED_VALUE
;
FlushFontAndWordCaches
(
)
;
}
else
if
(
!
strcmp
(
GFX_PREF_GRAPHITE_SHAPING
aPref
)
)
{
mGraphiteShapingEnabled
=
UNINITIALIZED_VALUE
;
FlushFontAndWordCaches
(
)
;
}
else
if
(
#
if
defined
(
XP_MACOSX
)
!
strcmp
(
GFX_PREF_CORETEXT_SHAPING
aPref
)
|
|
#
endif
!
strcmp
(
"
gfx
.
font_rendering
.
ahem_antialias_none
"
aPref
)
)
{
FlushFontAndWordCaches
(
)
;
}
else
if
(
!
strcmp
(
BIDI_NUMERAL_PREF
aPref
)
)
{
mBidiNumeralOption
=
UNINITIALIZED_VALUE
;
}
else
if
(
!
strcmp
(
GFX_PREF_OPENTYPE_SVG
aPref
)
)
{
mOpenTypeSVGEnabled
=
UNINITIALIZED_VALUE
;
gfxFontCache
:
:
GetCache
(
)
-
>
AgeAllGenerations
(
)
;
gfxFontCache
:
:
GetCache
(
)
-
>
NotifyGlyphsChanged
(
)
;
}
}
mozilla
:
:
LogModule
*
gfxPlatform
:
:
GetLog
(
eGfxLog
aWhichLog
)
{
static
LazyLogModule
sFontlistLog
(
"
fontlist
"
)
;
static
LazyLogModule
sFontInitLog
(
"
fontinit
"
)
;
static
LazyLogModule
sTextrunLog
(
"
textrun
"
)
;
static
LazyLogModule
sTextrunuiLog
(
"
textrunui
"
)
;
static
LazyLogModule
sCmapDataLog
(
"
cmapdata
"
)
;
static
LazyLogModule
sTextPerfLog
(
"
textperf
"
)
;
switch
(
aWhichLog
)
{
case
eGfxLog_fontlist
:
return
sFontlistLog
;
case
eGfxLog_fontinit
:
return
sFontInitLog
;
case
eGfxLog_textrun
:
return
sTextrunLog
;
case
eGfxLog_textrunui
:
return
sTextrunuiLog
;
case
eGfxLog_cmapdata
:
return
sCmapDataLog
;
case
eGfxLog_textperf
:
return
sTextPerfLog
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
log
type
"
)
;
return
nullptr
;
}
RefPtr
<
mozilla
:
:
gfx
:
:
DrawTarget
>
gfxPlatform
:
:
ScreenReferenceDrawTarget
(
)
{
return
(
mScreenReferenceDrawTarget
)
?
mScreenReferenceDrawTarget
:
gPlatform
-
>
CreateOffscreenContentDrawTarget
(
IntSize
(
1
1
)
SurfaceFormat
:
:
B8G8R8A8
true
)
;
}
mozilla
:
:
gfx
:
:
SurfaceFormat
gfxPlatform
:
:
Optimal2DFormatForContent
(
gfxContentType
aContent
)
{
switch
(
aContent
)
{
case
gfxContentType
:
:
COLOR
:
switch
(
GetOffscreenFormat
(
)
)
{
case
SurfaceFormat
:
:
A8R8G8B8_UINT32
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
case
SurfaceFormat
:
:
X8R8G8B8_UINT32
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8X8
;
case
SurfaceFormat
:
:
R5G6B5_UINT16
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
R5G6B5_UINT16
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unknown
gfxImageFormat
for
"
"
gfxContentType
:
:
COLOR
"
)
;
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
}
case
gfxContentType
:
:
ALPHA
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
A8
;
case
gfxContentType
:
:
COLOR_ALPHA
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unknown
gfxContentType
"
)
;
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
}
}
gfxImageFormat
gfxPlatform
:
:
OptimalFormatForContent
(
gfxContentType
aContent
)
{
switch
(
aContent
)
{
case
gfxContentType
:
:
COLOR
:
return
GetOffscreenFormat
(
)
;
case
gfxContentType
:
:
ALPHA
:
return
SurfaceFormat
:
:
A8
;
case
gfxContentType
:
:
COLOR_ALPHA
:
return
SurfaceFormat
:
:
A8R8G8B8_UINT32
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unknown
gfxContentType
"
)
;
return
SurfaceFormat
:
:
A8R8G8B8_UINT32
;
}
}
static
mozilla
:
:
Atomic
<
bool
>
sLayersSupportsHardwareVideoDecoding
(
false
)
;
static
bool
sLayersHardwareVideoDecodingFailed
=
false
;
static
bool
sBufferRotationCheckPref
=
true
;
static
mozilla
:
:
Atomic
<
bool
>
sLayersAccelerationPrefsInitialized
(
false
)
;
static
void
VideoDecodingFailedChangedCallback
(
const
char
*
aPref
void
*
)
{
sLayersHardwareVideoDecodingFailed
=
Preferences
:
:
GetBool
(
aPref
false
)
;
gfxPlatform
:
:
GetPlatform
(
)
-
>
UpdateCanUseHardwareVideoDecoding
(
)
;
}
void
gfxPlatform
:
:
UpdateCanUseHardwareVideoDecoding
(
)
{
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetCanUseHardwareVideoDecoding
(
CanUseHardwareVideoDecoding
(
)
)
;
}
}
void
gfxPlatform
:
:
UpdateForceSubpixelAAWherePossible
(
)
{
bool
forceSubpixelAAWherePossible
=
StaticPrefs
:
:
gfx_webrender_quality_force_subpixel_aa_where_possible
(
)
;
gfxVars
:
:
SetForceSubpixelAAWherePossible
(
forceSubpixelAAWherePossible
)
;
}
void
gfxPlatform
:
:
InitAcceleration
(
)
{
if
(
sLayersAccelerationPrefsInitialized
)
{
return
;
}
InitCompositorAccelerationPrefs
(
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
can
only
initialize
prefs
on
the
main
thread
"
)
;
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
nsCString
discardFailureId
;
int32_t
status
;
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetBrowserTabsRemoteAutostart
(
BrowserTabsRemoteAutostart
(
)
)
;
gfxVars
:
:
SetOffscreenFormat
(
GetOffscreenFormat
(
)
)
;
gfxVars
:
:
SetRequiresAcceleratedGLContextForCompositorOGL
(
RequiresAcceleratedGLContextForCompositorOGL
(
)
)
;
#
ifdef
XP_WIN
if
(
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_D3D11_KEYED_MUTEX
discardFailureId
&
status
)
)
)
{
gfxVars
:
:
SetAllowD3D11KeyedMutex
(
status
=
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
)
;
}
else
{
gfxCriticalNote
<
<
"
Cannot
evaluate
keyed
mutex
feature
status
"
;
gfxVars
:
:
SetAllowD3D11KeyedMutex
(
true
)
;
}
if
(
StaticPrefs
:
:
gfx_direct3d11_use_double_buffering
(
)
&
&
IsWin10OrLater
(
)
)
{
gfxVars
:
:
SetUseDoubleBufferingWithCompositor
(
true
)
;
}
#
endif
}
if
(
Preferences
:
:
GetBool
(
"
media
.
hardware
-
video
-
decoding
.
enabled
"
false
)
&
&
#
ifdef
XP_WIN
Preferences
:
:
GetBool
(
"
media
.
wmf
.
dxva
.
enabled
"
true
)
&
&
#
endif
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_HARDWARE_VIDEO_DECODING
discardFailureId
&
status
)
)
)
{
if
(
status
=
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
|
|
StaticPrefs
:
:
media_hardware_video_decoding_force_enabled_AtStartup
(
)
)
{
sLayersSupportsHardwareVideoDecoding
=
true
;
}
}
sLayersAccelerationPrefsInitialized
=
true
;
if
(
XRE_IsParentProcess
(
)
)
{
Preferences
:
:
RegisterCallbackAndCall
(
VideoDecodingFailedChangedCallback
"
media
.
hardware
-
video
-
decoding
.
failed
"
)
;
InitGPUProcessPrefs
(
)
;
gfxVars
:
:
SetRemoteCanvasEnabled
(
StaticPrefs
:
:
gfx_canvas_remote
(
)
&
&
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
)
;
}
}
void
gfxPlatform
:
:
InitGPUProcessPrefs
(
)
{
if
(
!
StaticPrefs
:
:
layers_gpu_process_enabled_AtStartup
(
)
&
&
!
StaticPrefs
:
:
layers_gpu_process_force_enabled_AtStartup
(
)
)
{
return
;
}
FeatureState
&
gpuProc
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
GPU_PROCESS
)
;
if
(
!
BrowserTabsRemoteAutostart
(
)
)
{
gpuProc
.
DisableByDefault
(
FeatureStatus
:
:
Unavailable
"
Multi
-
process
mode
is
not
enabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_NO_E10S
"
)
)
;
}
else
{
gpuProc
.
SetDefaultFromPref
(
StaticPrefs
:
:
GetPrefName_layers_gpu_process_enabled
(
)
true
StaticPrefs
:
:
GetPrefDefault_layers_gpu_process_enabled
(
)
)
;
}
if
(
StaticPrefs
:
:
layers_gpu_process_force_enabled_AtStartup
(
)
)
{
gpuProc
.
UserForceEnable
(
"
User
force
-
enabled
via
pref
"
)
;
}
if
(
IsHeadless
(
)
)
{
gpuProc
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
Headless
mode
is
enabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_HEADLESS_MODE
"
)
)
;
return
;
}
if
(
InSafeMode
(
)
)
{
gpuProc
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
Safe
-
mode
is
enabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_SAFE_MODE
"
)
)
;
return
;
}
if
(
StaticPrefs
:
:
gfx_layerscope_enabled
(
)
)
{
gpuProc
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
LayerScope
does
not
work
in
the
GPU
process
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_LAYERSCOPE
"
)
)
;
return
;
}
InitPlatformGPUProcessPrefs
(
)
;
}
void
gfxPlatform
:
:
InitCompositorAccelerationPrefs
(
)
{
const
char
*
acceleratedEnv
=
PR_GetEnv
(
"
MOZ_ACCELERATED
"
)
;
FeatureState
&
feature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
HW_COMPOSITING
)
;
if
(
feature
.
SetDefault
(
AccelerateLayersByDefault
(
)
FeatureStatus
:
:
Blocked
"
Acceleration
blocked
by
platform
"
)
)
{
if
(
StaticPrefs
:
:
layers_acceleration_disabled_AtStartup_DoNotUseDirectly
(
)
)
{
feature
.
UserDisable
(
"
Disabled
by
pref
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_PREF
"
)
)
;
}
else
if
(
acceleratedEnv
&
&
*
acceleratedEnv
=
=
'
0
'
)
{
feature
.
UserDisable
(
"
Disabled
by
envvar
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_ENV
"
)
)
;
}
}
else
{
if
(
acceleratedEnv
&
&
*
acceleratedEnv
=
=
'
1
'
)
{
feature
.
UserEnable
(
"
Enabled
by
envvar
"
)
;
}
}
if
(
StaticPrefs
:
:
layers_acceleration_force_enabled_AtStartup_DoNotUseDirectly
(
)
)
{
feature
.
UserForceEnable
(
"
Force
-
enabled
by
pref
"
)
;
}
if
(
InSafeMode
(
)
)
{
feature
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
Acceleration
blocked
by
safe
-
mode
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_SAFEMODE
"
)
)
;
}
if
(
IsHeadless
(
)
)
{
feature
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
Acceleration
blocked
by
headless
mode
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_HEADLESSMODE
"
)
)
;
}
}
bool
gfxPlatform
:
:
WebRenderPrefEnabled
(
)
{
return
StaticPrefs
:
:
gfx_webrender_all_AtStartup
(
)
|
|
StaticPrefs
:
:
gfx_webrender_enabled_AtStartup_DoNotUseDirectly
(
)
;
}
bool
gfxPlatform
:
:
WebRenderEnvvarEnabled
(
)
{
const
char
*
env
=
PR_GetEnv
(
"
MOZ_WEBRENDER
"
)
;
return
(
env
&
&
*
env
=
=
'
1
'
)
;
}
bool
gfxPlatform
:
:
WebRenderEnvvarDisabled
(
)
{
const
char
*
env
=
PR_GetEnv
(
"
MOZ_WEBRENDER
"
)
;
return
(
env
&
&
*
env
=
=
'
0
'
)
;
}
void
gfxPlatform
:
:
InitWebRenderConfig
(
)
{
bool
prefEnabled
=
WebRenderPrefEnabled
(
)
;
bool
envvarEnabled
=
WebRenderEnvvarEnabled
(
)
;
gfxVars
:
:
AddReceiver
(
&
nsCSSProps
:
:
GfxVarReceiver
(
)
)
;
ScopedGfxFeatureReporter
reporter
(
"
WR
"
prefEnabled
|
|
envvarEnabled
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
if
(
gfxVars
:
:
UseWebRender
(
)
)
{
nsCSSProps
:
:
RecomputeEnabledState
(
"
layout
.
css
.
backdrop
-
filter
.
enabled
"
)
;
reporter
.
SetSuccessful
(
)
;
}
return
;
}
gfxConfigManager
manager
;
manager
.
Init
(
)
;
manager
.
ConfigureWebRender
(
)
;
#
ifdef
XP_WIN
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER_ANGLE
)
)
{
gfxVars
:
:
SetUseWebRenderANGLE
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER
)
)
;
}
#
endif
if
(
Preferences
:
:
GetBool
(
"
gfx
.
webrender
.
program
-
binary
-
disk
"
false
)
)
{
gfxVars
:
:
SetUseWebRenderProgramBinaryDisk
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER
)
)
;
}
if
(
StaticPrefs
:
:
gfx_webrender_use_optimized_shaders_AtStartup
(
)
)
{
gfxVars
:
:
SetUseWebRenderOptimizedShaders
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER
)
)
;
}
if
(
Preferences
:
:
GetBool
(
"
gfx
.
webrender
.
software
"
false
)
)
{
gfxVars
:
:
SetUseSoftwareWebRender
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER
)
)
;
}
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER
)
)
{
gfxVars
:
:
SetUseWebRender
(
true
)
;
reporter
.
SetSuccessful
(
)
;
Preferences
:
:
RegisterPrefixCallbackAndCall
(
WebRenderDebugPrefChangeCallback
WR_DEBUG_PREF
)
;
Preferences
:
:
RegisterCallback
(
WebRenderQualityPrefChangeCallback
nsDependentCString
(
StaticPrefs
:
:
GetPrefName_gfx_webrender_quality_force_subpixel_aa_where_possible
(
)
)
)
;
Preferences
:
:
RegisterCallback
(
WebRenderMultithreadingPrefChangeCallback
nsDependentCString
(
StaticPrefs
:
:
GetPrefName_gfx_webrender_enable_multithreading
(
)
)
)
;
Preferences
:
:
RegisterCallback
(
WebRenderBatchingPrefChangeCallback
nsDependentCString
(
StaticPrefs
:
:
GetPrefName_gfx_webrender_batching_lookback
(
)
)
)
;
UpdateForceSubpixelAAWherePossible
(
)
;
}
#
ifdef
XP_WIN
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER_DCOMP_PRESENT
)
)
{
gfxVars
:
:
SetUseWebRenderDCompWin
(
true
)
;
}
if
(
Preferences
:
:
GetBool
(
"
gfx
.
webrender
.
flip
-
sequential
"
false
)
)
{
if
(
IsWin10OrLater
(
)
&
&
UseWebRender
(
)
&
&
gfxVars
:
:
UseWebRenderANGLE
(
)
)
{
gfxVars
:
:
SetUseWebRenderFlipSequentialWin
(
true
)
;
}
}
if
(
Preferences
:
:
GetBool
(
"
gfx
.
webrender
.
triple
-
buffering
.
enabled
"
false
)
)
{
if
(
gfxVars
:
:
UseWebRenderDCompWin
(
)
|
|
gfxVars
:
:
UseWebRenderFlipSequentialWin
(
)
)
{
gfxVars
:
:
SetUseWebRenderTripleBufferingWin
(
true
)
;
}
}
#
endif
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER_COMPOSITOR
)
)
{
gfxVars
:
:
SetUseWebRenderCompositor
(
true
)
;
}
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_OS_COMPOSITOR
gfx
:
:
gfxConfig
:
:
IsEnabled
(
gfx
:
:
Feature
:
:
WEBRENDER_COMPOSITOR
)
)
;
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER_PARTIAL
)
)
{
gfxVars
:
:
SetWebRenderMaxPartialPresentRects
(
StaticPrefs
:
:
gfx_webrender_max_partial_present_rects_AtStartup
(
)
)
;
}
gfxVars
:
:
SetUseGLSwizzle
(
IsFeatureSupported
(
nsIGfxInfo
:
:
FEATURE_GL_SWIZZLE
true
)
)
;
gfxVars
:
:
SetUseWebRenderScissoredCacheClears
(
IsFeatureSupported
(
nsIGfxInfo
:
:
FEATURE_WEBRENDER_SCISSORED_CACHE_CLEARS
true
)
)
;
gfxUtils
:
:
RemoveShaderCacheFromDiskIfNecessary
(
)
;
}
void
gfxPlatform
:
:
InitWebGPUConfig
(
)
{
FeatureState
&
feature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
WEBGPU
)
;
feature
.
SetDefaultFromPref
(
"
dom
.
webgpu
.
enabled
"
true
false
)
;
#
ifndef
NIGHTLY_BUILD
feature
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
WebGPU
can
only
be
enabled
in
nightly
"
NS_LITERAL_CSTRING
(
"
WEBGPU_DISABLE_NON_NIGHTLY
"
)
)
;
#
endif
}
void
gfxPlatform
:
:
InitOMTPConfig
(
)
{
ScopedGfxFeatureReporter
reporter
(
"
OMTP
"
)
;
FeatureState
&
omtp
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
OMTP
)
;
int32_t
paintWorkerCount
=
PaintThread
:
:
CalculatePaintWorkerCount
(
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
if
(
gfxVars
:
:
UseOMTP
(
)
)
{
reporter
.
SetSuccessful
(
paintWorkerCount
)
;
}
return
;
}
omtp
.
SetDefaultFromPref
(
"
layers
.
omtp
.
enabled
"
true
Preferences
:
:
GetBool
(
"
layers
.
omtp
.
enabled
"
false
PrefValueKind
:
:
Default
)
)
;
if
(
sizeof
(
void
*
)
<
=
sizeof
(
uint32_t
)
)
{
int32_t
cpuCores
=
PR_GetNumberOfProcessors
(
)
;
const
uint64_t
kMinSystemMemory
=
2147483648
;
if
(
cpuCores
<
=
2
)
{
omtp
.
ForceDisable
(
FeatureStatus
:
:
Broken
"
OMTP
is
not
supported
on
32
-
bit
with
<
=
2
cores
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_OMTP_32BIT_CORES
"
)
)
;
}
else
if
(
mTotalSystemMemory
<
kMinSystemMemory
)
{
omtp
.
ForceDisable
(
FeatureStatus
:
:
Broken
"
OMTP
is
not
supported
on
32
-
bit
with
<
2
GB
RAM
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_OMTP_32BIT_MEM
"
)
)
;
}
}
if
(
mContentBackend
=
=
BackendType
:
:
CAIRO
)
{
omtp
.
ForceDisable
(
FeatureStatus
:
:
Broken
"
OMTP
is
not
supported
when
using
cairo
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_PREF
"
)
)
;
}
#
ifdef
XP_MACOSX
if
(
!
nsCocoaFeatures
:
:
OnYosemiteOrLater
(
)
)
{
omtp
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
OMTP
blocked
before
OSX
10
.
10
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_OMTP_OSX_MAVERICKS
"
)
)
;
}
#
endif
if
(
InSafeMode
(
)
)
{
omtp
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
OMTP
blocked
by
safe
-
mode
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_SAFEMODE
"
)
)
;
}
if
(
omtp
.
IsEnabled
(
)
)
{
gfxVars
:
:
SetUseOMTP
(
true
)
;
reporter
.
SetSuccessful
(
paintWorkerCount
)
;
}
}
bool
gfxPlatform
:
:
CanUseHardwareVideoDecoding
(
)
{
MOZ_ASSERT
(
sLayersAccelerationPrefsInitialized
)
;
return
sLayersSupportsHardwareVideoDecoding
&
&
!
sLayersHardwareVideoDecodingFailed
;
}
bool
gfxPlatform
:
:
AccelerateLayersByDefault
(
)
{
#
if
defined
(
MOZ_GL_PROVIDER
)
|
|
defined
(
MOZ_WIDGET_UIKIT
)
return
true
;
#
else
return
false
;
#
endif
}
bool
gfxPlatform
:
:
BufferRotationEnabled
(
)
{
MutexAutoLock
autoLock
(
*
gGfxPlatformPrefsLock
)
;
return
sBufferRotationCheckPref
&
&
StaticPrefs
:
:
layers_bufferrotation_enabled_AtStartup
(
)
;
}
void
gfxPlatform
:
:
DisableBufferRotation
(
)
{
MutexAutoLock
autoLock
(
*
gGfxPlatformPrefsLock
)
;
sBufferRotationCheckPref
=
false
;
}
bool
gfxPlatform
:
:
UsesOffMainThreadCompositing
(
)
{
if
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_GPU
)
{
return
true
;
}
static
bool
firstTime
=
true
;
static
bool
result
=
false
;
if
(
firstTime
)
{
MOZ_ASSERT
(
sLayersAccelerationPrefsInitialized
)
;
result
=
gfxVars
:
:
BrowserTabsRemoteAutostart
(
)
|
|
!
StaticPrefs
:
:
layers_offmainthreadcomposition_force_disabled_AtStartup
(
)
;
#
if
defined
(
MOZ_WIDGET_GTK
)
result
|
=
StaticPrefs
:
:
layers_acceleration_force_enabled_AtStartup_DoNotUseDirectly
(
)
;
#
endif
firstTime
=
false
;
}
return
result
;
}
bool
gfxPlatform
:
:
UsesTiling
(
)
const
{
bool
usesSkia
=
GetDefaultContentBackend
(
)
=
=
BackendType
:
:
SKIA
;
bool
usesPOMTP
=
XRE_IsContentProcess
(
)
&
&
gfxVars
:
:
UseOMTP
(
)
&
&
(
StaticPrefs
:
:
layers_omtp_paint_workers_AtStartup
(
)
=
=
-
1
|
|
StaticPrefs
:
:
layers_omtp_paint_workers_AtStartup
(
)
>
1
)
;
return
StaticPrefs
:
:
layers_enable_tiles_AtStartup
(
)
|
|
(
StaticPrefs
:
:
layers_enable_tiles_if_skia_pomtp_AtStartup
(
)
&
&
usesSkia
&
&
usesPOMTP
)
;
}
bool
gfxPlatform
:
:
ContentUsesTiling
(
)
const
{
BackendPrefsData
data
=
GetBackendPrefs
(
)
;
BackendType
contentBackend
=
GetContentBackendPref
(
data
.
mContentBitmask
)
;
if
(
contentBackend
=
=
BackendType
:
:
NONE
)
{
contentBackend
=
data
.
mContentDefault
;
}
bool
contentUsesSkia
=
contentBackend
=
=
BackendType
:
:
SKIA
;
bool
contentUsesPOMTP
=
gfxVars
:
:
UseOMTP
(
)
&
&
(
StaticPrefs
:
:
layers_omtp_paint_workers_AtStartup
(
)
=
=
-
1
|
|
StaticPrefs
:
:
layers_omtp_paint_workers_AtStartup
(
)
>
1
)
;
return
StaticPrefs
:
:
layers_enable_tiles_AtStartup
(
)
|
|
(
StaticPrefs
:
:
layers_enable_tiles_if_skia_pomtp_AtStartup
(
)
&
&
contentUsesSkia
&
&
contentUsesPOMTP
)
;
}
already_AddRefed
<
mozilla
:
:
gfx
:
:
VsyncSource
>
gfxPlatform
:
:
CreateHardwareVsyncSource
(
)
{
RefPtr
<
mozilla
:
:
gfx
:
:
VsyncSource
>
softwareVsync
=
new
SoftwareVsyncSource
(
)
;
return
softwareVsync
.
forget
(
)
;
}
bool
gfxPlatform
:
:
IsInLayoutAsapMode
(
)
{
return
StaticPrefs
:
:
layout_frame_rate
(
)
=
=
0
;
}
bool
gfxPlatform
:
:
ForceSoftwareVsync
(
)
{
return
StaticPrefs
:
:
layout_frame_rate
(
)
>
0
;
}
int
gfxPlatform
:
:
GetSoftwareVsyncRate
(
)
{
int
preferenceRate
=
StaticPrefs
:
:
layout_frame_rate
(
)
;
if
(
preferenceRate
<
=
0
)
{
return
gfxPlatform
:
:
GetDefaultFrameRate
(
)
;
}
return
preferenceRate
;
}
int
gfxPlatform
:
:
GetDefaultFrameRate
(
)
{
return
60
;
}
void
gfxPlatform
:
:
ReInitFrameRate
(
)
{
if
(
XRE_IsParentProcess
(
)
)
{
RefPtr
<
VsyncSource
>
oldSource
=
gPlatform
-
>
mVsyncSource
;
if
(
gfxPlatform
:
:
ForceSoftwareVsync
(
)
)
{
gPlatform
-
>
mVsyncSource
=
(
gPlatform
)
-
>
gfxPlatform
:
:
CreateHardwareVsyncSource
(
)
;
}
else
{
gPlatform
-
>
mVsyncSource
=
gPlatform
-
>
CreateHardwareVsyncSource
(
)
;
}
if
(
oldSource
)
{
oldSource
-
>
MoveListenersToNewSource
(
gPlatform
-
>
mVsyncSource
)
;
oldSource
-
>
Shutdown
(
)
;
}
}
}
void
gfxPlatform
:
:
GetAzureBackendInfo
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
)
{
aObj
.
DefineProperty
(
"
AzureCanvasBackend
(
UI
Process
)
"
GetBackendName
(
mPreferredCanvasBackend
)
)
;
aObj
.
DefineProperty
(
"
AzureFallbackCanvasBackend
(
UI
Process
)
"
GetBackendName
(
mFallbackCanvasBackend
)
)
;
aObj
.
DefineProperty
(
"
AzureContentBackend
(
UI
Process
)
"
GetBackendName
(
mContentBackend
)
)
;
BackendPrefsData
data
=
GetBackendPrefs
(
)
;
BackendType
canvasBackend
=
GetCanvasBackendPref
(
data
.
mCanvasBitmask
)
;
if
(
canvasBackend
=
=
BackendType
:
:
NONE
)
{
canvasBackend
=
data
.
mCanvasDefault
;
}
BackendType
contentBackend
=
GetContentBackendPref
(
data
.
mContentBitmask
)
;
if
(
contentBackend
=
=
BackendType
:
:
NONE
)
{
contentBackend
=
data
.
mContentDefault
;
}
aObj
.
DefineProperty
(
"
AzureCanvasBackend
"
GetBackendName
(
canvasBackend
)
)
;
aObj
.
DefineProperty
(
"
AzureContentBackend
"
GetBackendName
(
contentBackend
)
)
;
}
else
{
aObj
.
DefineProperty
(
"
AzureCanvasBackend
"
GetBackendName
(
mPreferredCanvasBackend
)
)
;
aObj
.
DefineProperty
(
"
AzureFallbackCanvasBackend
"
GetBackendName
(
mFallbackCanvasBackend
)
)
;
aObj
.
DefineProperty
(
"
AzureContentBackend
"
GetBackendName
(
mContentBackend
)
)
;
}
}
void
gfxPlatform
:
:
GetApzSupportInfo
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
if
(
!
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
)
{
return
;
}
if
(
SupportsApzWheelInput
(
)
)
{
aObj
.
DefineProperty
(
"
ApzWheelInput
"
1
)
;
}
if
(
SupportsApzTouchInput
(
)
)
{
aObj
.
DefineProperty
(
"
ApzTouchInput
"
1
)
;
}
if
(
SupportsApzDragInput
(
)
)
{
aObj
.
DefineProperty
(
"
ApzDragInput
"
1
)
;
}
if
(
SupportsApzKeyboardInput
(
)
&
&
!
StaticPrefs
:
:
accessibility_browsewithcaret
(
)
)
{
aObj
.
DefineProperty
(
"
ApzKeyboardInput
"
1
)
;
}
if
(
SupportsApzAutoscrolling
(
)
)
{
aObj
.
DefineProperty
(
"
ApzAutoscrollInput
"
1
)
;
}
if
(
SupportsApzZooming
(
)
)
{
aObj
.
DefineProperty
(
"
ApzZoomingInput
"
1
)
;
}
}
void
gfxPlatform
:
:
GetTilesSupportInfo
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
if
(
!
StaticPrefs
:
:
layers_enable_tiles_AtStartup
(
)
)
{
return
;
}
IntSize
tileSize
=
gfxVars
:
:
TileSize
(
)
;
aObj
.
DefineProperty
(
"
TileHeight
"
tileSize
.
height
)
;
aObj
.
DefineProperty
(
"
TileWidth
"
tileSize
.
width
)
;
}
void
gfxPlatform
:
:
GetFrameStats
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
uint32_t
i
=
0
;
for
(
FrameStats
&
f
:
mFrameStats
)
{
nsPrintfCString
name
(
"
Slow
Frame
#
%
02u
"
+
+
i
)
;
nsPrintfCString
value
(
"
Frame
%
"
PRIu64
"
(
%
s
)
CONTENT_FRAME_TIME
%
d
-
Transaction
start
%
f
main
-
thread
time
"
"
%
f
full
paint
time
%
f
Skipped
composites
%
u
Composite
start
%
f
"
"
Resource
upload
time
%
f
GPU
cache
upload
time
%
f
Render
time
%
f
"
"
Composite
time
%
f
"
f
.
id
(
)
.
mId
f
.
url
(
)
.
get
(
)
f
.
contentFrameTime
(
)
(
f
.
transactionStart
(
)
-
f
.
refreshStart
(
)
)
.
ToMilliseconds
(
)
(
f
.
fwdTime
(
)
-
f
.
transactionStart
(
)
)
.
ToMilliseconds
(
)
f
.
sceneBuiltTime
(
)
?
(
f
.
sceneBuiltTime
(
)
-
f
.
transactionStart
(
)
)
.
ToMilliseconds
(
)
:
0
.
0
f
.
skippedComposites
(
)
(
f
.
compositeStart
(
)
-
f
.
refreshStart
(
)
)
.
ToMilliseconds
(
)
f
.
resourceUploadTime
(
)
f
.
gpuCacheUploadTime
(
)
(
f
.
compositeEnd
(
)
-
f
.
renderStart
(
)
)
.
ToMilliseconds
(
)
(
f
.
compositeEnd
(
)
-
f
.
compositeStart
(
)
)
.
ToMilliseconds
(
)
)
;
aObj
.
DefineProperty
(
name
.
get
(
)
value
.
get
(
)
)
;
}
}
void
gfxPlatform
:
:
GetCMSSupportInfo
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
nsTArray
<
uint8_t
>
outputProfileData
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetPlatformCMSOutputProfileData
(
)
;
if
(
outputProfileData
.
IsEmpty
(
)
)
{
nsPrintfCString
msg
(
"
Empty
profile
data
"
)
;
aObj
.
DefineProperty
(
"
CMSOutputProfile
"
msg
.
get
(
)
)
;
return
;
}
const
size_t
kMaxProfileSize
=
8192
;
if
(
outputProfileData
.
Length
(
)
>
=
kMaxProfileSize
)
{
nsPrintfCString
msg
(
"
%
zu
bytes
too
large
"
outputProfileData
.
Length
(
)
)
;
aObj
.
DefineProperty
(
"
CMSOutputProfile
"
msg
.
get
(
)
)
;
return
;
}
char
*
encodedProfile
=
nullptr
;
nsresult
rv
=
Base64Encode
(
reinterpret_cast
<
char
*
>
(
outputProfileData
.
Elements
(
)
)
outputProfileData
.
Length
(
)
&
encodedProfile
)
;
if
(
!
NS_SUCCEEDED
(
rv
)
)
{
nsPrintfCString
msg
(
"
base64
encode
failed
0x
%
08x
"
static_cast
<
uint32_t
>
(
rv
)
)
;
aObj
.
DefineProperty
(
"
CMSOutputProfile
"
msg
.
get
(
)
)
;
return
;
}
aObj
.
DefineProperty
(
"
CMSOutputProfile
"
encodedProfile
)
;
free
(
encodedProfile
)
;
}
void
gfxPlatform
:
:
GetDisplayInfo
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
nsTArray
<
nsString
>
displayInfo
;
auto
rv
=
gfxInfo
-
>
GetDisplayInfo
(
displayInfo
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
size_t
displayCount
=
displayInfo
.
Length
(
)
;
aObj
.
DefineProperty
(
"
DisplayCount
"
displayCount
)
;
for
(
size_t
i
=
0
;
i
<
displayCount
;
i
+
+
)
{
nsPrintfCString
name
(
"
Display
%
zu
"
i
)
;
aObj
.
DefineProperty
(
name
.
get
(
)
displayInfo
[
i
]
)
;
}
}
}
class
FrameStatsComparator
{
public
:
bool
Equals
(
const
FrameStats
&
aA
const
FrameStats
&
aB
)
const
{
return
aA
.
contentFrameTime
(
)
=
=
aB
.
contentFrameTime
(
)
;
}
bool
LessThan
(
const
FrameStats
&
aA
const
FrameStats
&
aB
)
const
{
return
aA
.
contentFrameTime
(
)
>
aB
.
contentFrameTime
(
)
;
}
}
;
void
gfxPlatform
:
:
NotifyFrameStats
(
nsTArray
<
FrameStats
>
&
&
aFrameStats
)
{
if
(
!
StaticPrefs
:
:
gfx_logging_slow_frames_enabled_AtStartup
(
)
)
{
return
;
}
FrameStatsComparator
comp
;
for
(
FrameStats
&
f
:
aFrameStats
)
{
mFrameStats
.
InsertElementSorted
(
f
comp
)
;
}
if
(
mFrameStats
.
Length
(
)
>
10
)
{
mFrameStats
.
SetLength
(
10
)
;
}
}
uint32_t
gfxPlatform
:
:
TargetFrameRate
(
)
{
if
(
gPlatform
&
&
gPlatform
-
>
mVsyncSource
)
{
VsyncSource
:
:
Display
&
display
=
gPlatform
-
>
mVsyncSource
-
>
GetGlobalDisplay
(
)
;
return
round
(
1000
.
0
/
display
.
GetVsyncRate
(
)
.
ToMilliseconds
(
)
)
;
}
return
0
;
}
bool
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
{
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
&
&
!
defined
(
MOZ_WIDGET_UIKIT
)
if
(
!
BrowserTabsRemoteAutostart
(
)
)
{
return
false
;
}
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
return
true
;
#
else
return
StaticPrefs
:
:
layers_async_pan_zoom_enabled_AtStartup_DoNotUseDirectly
(
)
;
#
endif
}
bool
gfxPlatform
:
:
PerfWarnings
(
)
{
return
StaticPrefs
:
:
gfx_perf_warnings_enabled
(
)
;
}
void
gfxPlatform
:
:
GetAcceleratedCompositorBackends
(
nsTArray
<
LayersBackend
>
&
aBackends
)
{
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
OPENGL_COMPOSITING
)
)
{
aBackends
.
AppendElement
(
LayersBackend
:
:
LAYERS_OPENGL
)
;
}
else
{
static
int
tell_me_once
=
0
;
if
(
!
tell_me_once
)
{
NS_WARNING
(
"
OpenGL
-
accelerated
layers
are
not
supported
on
this
system
"
)
;
tell_me_once
=
1
;
}
#
ifdef
MOZ_WIDGET_ANDROID
MOZ_CRASH
(
"
OpenGL
-
accelerated
layers
are
a
hard
requirement
on
this
platform
.
"
"
Cannot
continue
without
support
for
them
"
)
;
#
endif
}
}
void
gfxPlatform
:
:
GetCompositorBackends
(
bool
useAcceleration
nsTArray
<
mozilla
:
:
layers
:
:
LayersBackend
>
&
aBackends
)
{
if
(
useAcceleration
)
{
GetAcceleratedCompositorBackends
(
aBackends
)
;
}
aBackends
.
AppendElement
(
LayersBackend
:
:
LAYERS_BASIC
)
;
}
void
gfxPlatform
:
:
NotifyCompositorCreated
(
LayersBackend
aBackend
)
{
if
(
mCompositorBackend
=
=
aBackend
)
{
return
;
}
if
(
mCompositorBackend
!
=
LayersBackend
:
:
LAYERS_NONE
)
{
gfxCriticalNote
<
<
"
Compositors
might
be
mixed
(
"
<
<
int
(
mCompositorBackend
)
<
<
"
"
<
<
int
(
aBackend
)
<
<
"
)
"
;
}
mCompositorBackend
=
aBackend
;
if
(
XRE_IsParentProcess
(
)
)
{
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_COMPOSITOR
NS_ConvertUTF8toUTF16
(
GetLayersBackendName
(
mCompositorBackend
)
)
)
;
}
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
gfxPlatform
:
:
NotifyCompositorCreated
"
[
]
{
if
(
nsCOMPtr
<
nsIObserverService
>
obsvc
=
services
:
:
GetObserverService
(
)
)
{
obsvc
-
>
NotifyObservers
(
nullptr
"
compositor
:
created
"
nullptr
)
;
}
}
)
)
;
}
void
gfxPlatform
:
:
NotifyGPUProcessDisabled
(
)
{
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER
)
)
{
gfxConfig
:
:
GetFeature
(
Feature
:
:
WEBRENDER
)
.
ForceDisable
(
FeatureStatus
:
:
Unavailable
"
GPU
Process
is
disabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_GPU_PROCESS_DISABLED
"
)
)
;
gfxVars
:
:
SetUseWebRender
(
false
)
;
}
gfxVars
:
:
SetRemoteCanvasEnabled
(
false
)
;
}
void
gfxPlatform
:
:
FetchAndImportContentDeviceData
(
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
if
(
gContentDeviceInitData
)
{
ImportContentDeviceData
(
*
gContentDeviceInitData
)
;
return
;
}
mozilla
:
:
dom
:
:
ContentChild
*
cc
=
mozilla
:
:
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
mozilla
:
:
gfx
:
:
ContentDeviceData
data
;
cc
-
>
SendGetGraphicsDeviceInitData
(
&
data
)
;
ImportContentDeviceData
(
data
)
;
}
void
gfxPlatform
:
:
ImportContentDeviceData
(
const
mozilla
:
:
gfx
:
:
ContentDeviceData
&
aData
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
const
DevicePrefs
&
prefs
=
aData
.
prefs
(
)
;
gfxConfig
:
:
Inherit
(
Feature
:
:
HW_COMPOSITING
prefs
.
hwCompositing
(
)
)
;
gfxConfig
:
:
Inherit
(
Feature
:
:
OPENGL_COMPOSITING
prefs
.
oglCompositing
(
)
)
;
}
void
gfxPlatform
:
:
BuildContentDeviceData
(
mozilla
:
:
gfx
:
:
ContentDeviceData
*
aOut
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
GPUProcessManager
:
:
Get
(
)
-
>
EnsureGPUReady
(
)
;
aOut
-
>
prefs
(
)
.
hwCompositing
(
)
=
gfxConfig
:
:
GetValue
(
Feature
:
:
HW_COMPOSITING
)
;
aOut
-
>
prefs
(
)
.
oglCompositing
(
)
=
gfxConfig
:
:
GetValue
(
Feature
:
:
OPENGL_COMPOSITING
)
;
}
void
gfxPlatform
:
:
ImportGPUDeviceData
(
const
mozilla
:
:
gfx
:
:
GPUDeviceData
&
aData
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
gfxConfig
:
:
ImportChange
(
Feature
:
:
OPENGL_COMPOSITING
aData
.
oglCompositing
(
)
)
;
gfxConfig
:
:
ImportChange
(
Feature
:
:
ADVANCED_LAYERS
aData
.
advancedLayers
(
)
)
;
}
bool
gfxPlatform
:
:
SupportsApzTouchInput
(
)
const
{
return
dom
:
:
TouchEvent
:
:
PrefEnabled
(
nullptr
)
;
}
bool
gfxPlatform
:
:
SupportsApzDragInput
(
)
const
{
return
StaticPrefs
:
:
apz_drag_enabled
(
)
;
}
bool
gfxPlatform
:
:
SupportsApzKeyboardInput
(
)
const
{
return
StaticPrefs
:
:
apz_keyboard_enabled_AtStartup
(
)
;
}
bool
gfxPlatform
:
:
SupportsApzAutoscrolling
(
)
const
{
return
StaticPrefs
:
:
apz_autoscroll_enabled
(
)
;
}
bool
gfxPlatform
:
:
SupportsApzZooming
(
)
const
{
return
StaticPrefs
:
:
apz_allow_zooming
(
)
;
}
void
gfxPlatform
:
:
InitOpenGLConfig
(
)
{
#
ifdef
XP_WIN
if
(
!
Preferences
:
:
GetBool
(
"
layers
.
prefer
-
opengl
"
)
)
{
return
;
}
#
endif
FeatureState
&
openGLFeature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
OPENGL_COMPOSITING
)
;
if
(
!
gfxConfig
:
:
IsEnabled
(
Feature
:
:
HW_COMPOSITING
)
)
{
openGLFeature
.
DisableByDefault
(
FeatureStatus
:
:
Unavailable
"
Hardware
compositing
is
disabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_OPENGL_NEED_HWCOMP
"
)
)
;
return
;
}
#
ifdef
XP_WIN
openGLFeature
.
SetDefaultFromPref
(
StaticPrefs
:
:
GetPrefName_layers_prefer_opengl
(
)
true
StaticPrefs
:
:
GetPrefDefault_layers_prefer_opengl
(
)
)
;
#
else
openGLFeature
.
EnableByDefault
(
)
;
#
endif
if
(
StaticPrefs
:
:
layers_acceleration_force_enabled_AtStartup_DoNotUseDirectly
(
)
)
{
openGLFeature
.
UserForceEnable
(
"
Force
-
enabled
by
pref
"
)
;
return
;
}
nsCString
message
;
nsCString
failureId
;
if
(
!
IsGfxInfoStatusOkay
(
nsIGfxInfo
:
:
FEATURE_OPENGL_LAYERS
&
message
failureId
)
)
{
openGLFeature
.
Disable
(
FeatureStatus
:
:
Blacklisted
message
.
get
(
)
failureId
)
;
}
}
bool
gfxPlatform
:
:
IsGfxInfoStatusOkay
(
int32_t
aFeature
nsCString
*
aOutMessage
nsCString
&
aFailureId
)
{
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
if
(
!
gfxInfo
)
{
return
true
;
}
int32_t
status
;
if
(
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
aFeature
aFailureId
&
status
)
)
&
&
status
!
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
)
{
aOutMessage
-
>
AssignLiteral
(
"
#
BLOCKLIST_
"
)
;
aOutMessage
-
>
AppendASCII
(
aFailureId
.
get
(
)
)
;
return
false
;
}
return
true
;
}
