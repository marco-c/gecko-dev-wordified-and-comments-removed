#
include
"
mozilla
/
FontPropertyTypes
.
h
"
#
include
"
mozilla
/
RDDProcessManager
.
h
"
#
include
"
mozilla
/
image
/
ImageMemoryReporter
.
h
"
#
include
"
mozilla
/
layers
/
CompositorManagerChild
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
TiledContentClient
.
h
"
#
include
"
mozilla
/
webrender
/
RenderThread
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
mozilla
/
webrender
/
webrender_ffi
.
h
"
#
include
"
mozilla
/
layers
/
PaintThread
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessManager
.
h
"
#
include
"
mozilla
/
gfx
/
GraphicsMessages
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
StaticPrefs_accessibility
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
StaticPrefs_layers
.
h
"
#
include
"
mozilla
/
StaticPrefs_media
.
h
"
#
include
"
mozilla
/
StaticPrefs_webgl
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
gfxCrashReporterUtils
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxEnv
.
h
"
#
include
"
gfxTextRun
.
h
"
#
include
"
gfxUserFontSet
.
h
"
#
include
"
gfxConfig
.
h
"
#
include
"
VRProcessManager
.
h
"
#
include
"
VRThread
.
h
"
#
include
"
mozilla
/
arm
.
h
"
#
ifdef
XP_WIN
#
include
<
process
.
h
>
#
define
getpid
_getpid
#
else
#
include
<
unistd
.
h
>
#
endif
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
gfxWindowsPlatform
.
h
"
#
elif
defined
(
XP_MACOSX
)
#
include
"
gfxPlatformMac
.
h
"
#
include
"
gfxQuartzSurface
.
h
"
#
include
"
nsCocoaFeatures
.
h
"
#
elif
defined
(
MOZ_WIDGET_GTK
)
#
include
"
gfxPlatformGtk
.
h
"
#
elif
defined
(
ANDROID
)
#
include
"
gfxAndroidPlatform
.
h
"
#
endif
#
if
defined
(
MOZ_WIDGET_ANDROID
)
#
include
"
mozilla
/
jni
/
Utils
.
h
"
#
endif
#
ifdef
XP_WIN
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
mozilla
/
gfx
/
DeviceManagerDx
.
h
"
#
endif
#
ifdef
MOZ_WAYLAND
#
include
"
mozilla
/
widget
/
nsWaylandDisplay
.
h
"
#
endif
#
include
"
nsGkAtoms
.
h
"
#
include
"
gfxPlatformFontList
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxImageSurface
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
harfbuzz
/
hb
.
h
"
#
include
"
gfxGraphiteShaper
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxGradientCache
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
gfxFontMissingGlyphs
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
cairo
.
h
"
#
include
"
qcms
.
h
"
#
include
"
imgITools
.
h
"
#
include
"
plstr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
GLContextProvider
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
ifdef
USE_SKIA
#
ifdef
__GNUC__
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wshadow
"
#
endif
#
include
"
skia
/
include
/
core
/
SkGraphics
.
h
"
#
ifdef
MOZ_ENABLE_FREETYPE
#
include
"
skia
/
include
/
ports
/
SkTypeface_cairo
.
h
"
#
endif
#
include
"
mozilla
/
gfx
/
SkMemoryReporter
.
h
"
#
ifdef
__GNUC__
#
pragma
GCC
diagnostic
pop
/
/
-
Wshadow
#
endif
static
const
uint32_t
kDefaultGlyphCacheSize
=
-
1
;
#
endif
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsIGfxInfo
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
VsyncSource
.
h
"
#
include
"
SoftwareVsyncSource
.
h
"
#
include
"
nscore
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
TouchEvent
.
h
"
#
include
"
gfxVR
.
h
"
#
include
"
VRManagerChild
.
h
"
#
include
"
mozilla
/
gfx
/
GPUParent
.
h
"
#
include
"
mozilla
/
layers
/
MemoryReportingMLGPU
.
h
"
#
include
"
prsystem
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
gl
;
using
namespace
mozilla
:
:
gfx
;
gfxPlatform
*
gPlatform
=
nullptr
;
static
bool
gEverInitialized
=
false
;
static
int32_t
gLastUsedFrameRate
=
-
1
;
const
ContentDeviceData
*
gContentDeviceInitData
=
nullptr
;
static
Mutex
*
gGfxPlatformPrefsLock
=
nullptr
;
static
qcms_profile
*
gCMSOutputProfile
=
nullptr
;
static
qcms_profile
*
gCMSsRGBProfile
=
nullptr
;
static
bool
gCMSRGBTransformFailed
=
false
;
static
qcms_transform
*
gCMSRGBTransform
=
nullptr
;
static
qcms_transform
*
gCMSInverseRGBTransform
=
nullptr
;
static
qcms_transform
*
gCMSRGBATransform
=
nullptr
;
static
qcms_transform
*
gCMSBGRATransform
=
nullptr
;
static
bool
gCMSInitialized
=
false
;
static
eCMSMode
gCMSMode
=
eCMSMode_Off
;
static
void
ShutdownCMS
(
)
;
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
SourceSurfaceCairo
.
h
"
using
namespace
mozilla
:
:
gfx
;
class
SRGBOverrideObserver
final
:
public
nsIObserver
public
nsSupportsWeakReference
{
~
SRGBOverrideObserver
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
}
;
class
CrashStatsLogForwarder
:
public
mozilla
:
:
gfx
:
:
LogForwarder
{
public
:
explicit
CrashStatsLogForwarder
(
CrashReporter
:
:
Annotation
aKey
)
;
void
Log
(
const
std
:
:
string
&
aString
)
override
;
void
CrashAction
(
LogReason
aReason
)
override
;
bool
UpdateStringsVector
(
const
std
:
:
string
&
aString
)
override
;
LoggingRecord
LoggingRecordCopy
(
)
override
;
void
SetCircularBufferSize
(
uint32_t
aCapacity
)
;
private
:
void
UpdateCrashReport
(
)
;
private
:
LoggingRecord
mBuffer
;
CrashReporter
:
:
Annotation
mCrashCriticalKey
;
uint32_t
mMaxCapacity
;
int32_t
mIndex
;
Mutex
mMutex
;
}
;
CrashStatsLogForwarder
:
:
CrashStatsLogForwarder
(
CrashReporter
:
:
Annotation
aKey
)
:
mBuffer
(
)
mCrashCriticalKey
(
aKey
)
mMaxCapacity
(
0
)
mIndex
(
-
1
)
mMutex
(
"
CrashStatsLogForwarder
"
)
{
}
void
CrashStatsLogForwarder
:
:
SetCircularBufferSize
(
uint32_t
aCapacity
)
{
MutexAutoLock
lock
(
mMutex
)
;
mMaxCapacity
=
aCapacity
;
mBuffer
.
reserve
(
static_cast
<
size_t
>
(
aCapacity
)
)
;
}
LoggingRecord
CrashStatsLogForwarder
:
:
LoggingRecordCopy
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mBuffer
;
}
bool
CrashStatsLogForwarder
:
:
UpdateStringsVector
(
const
std
:
:
string
&
aString
)
{
if
(
mMaxCapacity
<
2
)
{
return
false
;
}
mIndex
+
=
1
;
MOZ_ASSERT
(
mIndex
>
=
0
)
;
int32_t
index
=
mIndex
?
(
mIndex
-
1
)
%
(
mMaxCapacity
-
1
)
+
1
:
0
;
MOZ_ASSERT
(
index
>
=
0
&
&
index
<
(
int32_t
)
mMaxCapacity
)
;
MOZ_ASSERT
(
index
<
=
mIndex
&
&
index
<
=
(
int32_t
)
mBuffer
.
size
(
)
)
;
double
tStamp
=
(
TimeStamp
:
:
NowLoRes
(
)
-
TimeStamp
:
:
ProcessCreation
(
)
)
.
ToSecondsSigDigits
(
)
;
LoggingRecordEntry
newEntry
(
mIndex
aString
tStamp
)
;
if
(
index
>
=
static_cast
<
int32_t
>
(
mBuffer
.
size
(
)
)
)
{
mBuffer
.
push_back
(
newEntry
)
;
}
else
{
mBuffer
[
index
]
=
newEntry
;
}
return
true
;
}
void
CrashStatsLogForwarder
:
:
UpdateCrashReport
(
)
{
std
:
:
stringstream
message
;
std
:
:
string
logAnnotation
;
switch
(
XRE_GetProcessType
(
)
)
{
case
GeckoProcessType_Default
:
logAnnotation
=
"
|
[
"
;
break
;
case
GeckoProcessType_Content
:
logAnnotation
=
"
|
[
C
"
;
break
;
case
GeckoProcessType_GPU
:
logAnnotation
=
"
|
[
G
"
;
break
;
default
:
logAnnotation
=
"
|
[
X
"
;
break
;
}
for
(
auto
&
it
:
mBuffer
)
{
message
<
<
logAnnotation
<
<
Get
<
0
>
(
it
)
<
<
"
]
"
<
<
Get
<
1
>
(
it
)
<
<
"
(
t
=
"
<
<
Get
<
2
>
(
it
)
<
<
"
)
"
;
}
nsCString
reportString
(
message
.
str
(
)
.
c_str
(
)
)
;
nsresult
annotated
=
CrashReporter
:
:
AnnotateCrashReport
(
mCrashCriticalKey
reportString
)
;
if
(
annotated
!
=
NS_OK
)
{
printf
(
"
Crash
Annotation
%
s
:
%
s
"
CrashReporter
:
:
AnnotationToString
(
mCrashCriticalKey
)
message
.
str
(
)
.
c_str
(
)
)
;
}
}
class
LogForwarderEvent
:
public
Runnable
{
virtual
~
LogForwarderEvent
(
)
=
default
;
public
:
NS_INLINE_DECL_REFCOUNTING_INHERITED
(
LogForwarderEvent
Runnable
)
explicit
LogForwarderEvent
(
const
nsCString
&
aMessage
)
:
mozilla
:
:
Runnable
(
"
LogForwarderEvent
"
)
mMessage
(
aMessage
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
&
&
(
XRE_IsContentProcess
(
)
|
|
XRE_IsGPUProcess
(
)
)
)
;
if
(
XRE_IsContentProcess
(
)
)
{
dom
:
:
ContentChild
*
cc
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
Unused
<
<
cc
-
>
SendGraphicsError
(
mMessage
)
;
}
else
if
(
XRE_IsGPUProcess
(
)
)
{
GPUParent
*
gp
=
GPUParent
:
:
GetSingleton
(
)
;
Unused
<
<
gp
-
>
SendGraphicsError
(
mMessage
)
;
}
return
NS_OK
;
}
protected
:
nsCString
mMessage
;
}
;
void
CrashStatsLogForwarder
:
:
Log
(
const
std
:
:
string
&
aString
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
UpdateStringsVector
(
aString
)
)
{
UpdateCrashReport
(
)
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
nsCString
stringToSend
(
aString
.
c_str
(
)
)
;
if
(
NS_IsMainThread
(
)
)
{
if
(
XRE_IsContentProcess
(
)
)
{
dom
:
:
ContentChild
*
cc
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
Unused
<
<
cc
-
>
SendGraphicsError
(
stringToSend
)
;
}
else
if
(
XRE_IsGPUProcess
(
)
)
{
GPUParent
*
gp
=
GPUParent
:
:
GetSingleton
(
)
;
Unused
<
<
gp
-
>
SendGraphicsError
(
stringToSend
)
;
}
}
else
{
nsCOMPtr
<
nsIRunnable
>
r1
=
new
LogForwarderEvent
(
stringToSend
)
;
NS_DispatchToMainThread
(
r1
)
;
}
}
}
class
CrashTelemetryEvent
:
public
Runnable
{
virtual
~
CrashTelemetryEvent
(
)
=
default
;
public
:
NS_INLINE_DECL_REFCOUNTING_INHERITED
(
CrashTelemetryEvent
Runnable
)
explicit
CrashTelemetryEvent
(
uint32_t
aReason
)
:
mozilla
:
:
Runnable
(
"
CrashTelemetryEvent
"
)
mReason
(
aReason
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GFX_CRASH
mReason
)
;
return
NS_OK
;
}
protected
:
uint32_t
mReason
;
}
;
void
CrashStatsLogForwarder
:
:
CrashAction
(
LogReason
aReason
)
{
#
ifndef
RELEASE_OR_BETA
static
bool
useTelemetry
=
gfxEnv
:
:
GfxDevCrashTelemetry
(
)
;
#
else
static
bool
useTelemetry
=
!
gfxEnv
:
:
GfxDevCrashMozCrash
(
)
;
#
endif
if
(
useTelemetry
)
{
if
(
NS_IsMainThread
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GFX_CRASH
(
uint32_t
)
aReason
)
;
}
else
{
nsCOMPtr
<
nsIRunnable
>
r1
=
new
CrashTelemetryEvent
(
(
uint32_t
)
aReason
)
;
NS_DispatchToMainThread
(
r1
)
;
}
}
else
{
MOZ_CRASH
(
"
GFX_CRASH
"
)
;
}
}
NS_IMPL_ISUPPORTS
(
SRGBOverrideObserver
nsIObserver
nsISupportsWeakReference
)
#
define
GFX_DOWNLOADABLE_FONTS_ENABLED
"
gfx
.
downloadable_fonts
.
enabled
"
#
define
GFX_PREF_FALLBACK_USE_CMAPS
\
"
gfx
.
font_rendering
.
fallback
.
always_use_cmaps
"
#
define
GFX_PREF_OPENTYPE_SVG
"
gfx
.
font_rendering
.
opentype_svg
.
enabled
"
#
define
GFX_PREF_WORD_CACHE_CHARLIMIT
"
gfx
.
font_rendering
.
wordcache
.
charlimit
"
#
define
GFX_PREF_WORD_CACHE_MAXENTRIES
"
gfx
.
font_rendering
.
wordcache
.
maxentries
"
#
define
GFX_PREF_GRAPHITE_SHAPING
"
gfx
.
font_rendering
.
graphite
.
enabled
"
#
if
defined
(
XP_MACOSX
)
#
define
GFX_PREF_CORETEXT_SHAPING
"
gfx
.
font_rendering
.
coretext
.
enabled
"
#
endif
#
define
BIDI_NUMERAL_PREF
"
bidi
.
numeral
"
#
define
GFX_PREF_CMS_FORCE_SRGB
"
gfx
.
color_management
.
force_srgb
"
#
define
FONT_VARIATIONS_PREF
"
layout
.
css
.
font
-
variations
.
enabled
"
NS_IMETHODIMP
SRGBOverrideObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
someData
)
{
NS_ASSERTION
(
NS_strcmp
(
someData
(
u
"
"
GFX_PREF_CMS_FORCE_SRGB
)
)
=
=
0
"
Restarting
CMS
on
wrong
pref
!
"
)
;
ShutdownCMS
(
)
;
gfxPlatform
:
:
CreateCMSOutputProfile
(
)
;
return
NS_OK
;
}
static
const
char
*
kObservedPrefs
[
]
=
{
"
gfx
.
downloadable_fonts
.
"
"
gfx
.
font_rendering
.
"
BIDI_NUMERAL_PREF
nullptr
}
;
static
void
FontPrefChanged
(
const
char
*
aPref
void
*
aData
)
{
MOZ_ASSERT
(
aPref
)
;
NS_ASSERTION
(
gfxPlatform
:
:
GetPlatform
(
)
"
the
singleton
instance
has
gone
"
)
;
gfxPlatform
:
:
GetPlatform
(
)
-
>
FontsPrefsChanged
(
aPref
)
;
}
void
gfxPlatform
:
:
OnMemoryPressure
(
layers
:
:
MemoryPressureReason
aWhy
)
{
Factory
:
:
PurgeAllCaches
(
)
;
gfxGradientCache
:
:
PurgeAllCaches
(
)
;
gfxFontMissingGlyphs
:
:
Purge
(
)
;
PurgeSkiaFontCache
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
layers
:
:
CompositorManagerChild
*
manager
=
CompositorManagerChild
:
:
GetInstance
(
)
;
if
(
manager
)
{
manager
-
>
SendNotifyMemoryPressure
(
)
;
}
}
}
gfxPlatform
:
:
gfxPlatform
(
)
:
mHasVariationFontSupport
(
false
)
mAzureCanvasBackendCollector
(
this
&
gfxPlatform
:
:
GetAzureBackendInfo
)
mApzSupportCollector
(
this
&
gfxPlatform
:
:
GetApzSupportInfo
)
mTilesInfoCollector
(
this
&
gfxPlatform
:
:
GetTilesSupportInfo
)
mFrameStatsCollector
(
this
&
gfxPlatform
:
:
GetFrameStats
)
mCMSInfoCollector
(
this
&
gfxPlatform
:
:
GetCMSSupportInfo
)
mDisplayInfoCollector
(
this
&
gfxPlatform
:
:
GetDisplayInfo
)
mCompositorBackend
(
layers
:
:
LayersBackend
:
:
LAYERS_NONE
)
mScreenDepth
(
0
)
mScreenPixels
(
0
)
{
mAllowDownloadableFonts
=
UNINITIALIZED_VALUE
;
mFallbackUsesCmaps
=
UNINITIALIZED_VALUE
;
mWordCacheCharLimit
=
UNINITIALIZED_VALUE
;
mWordCacheMaxEntries
=
UNINITIALIZED_VALUE
;
mGraphiteShapingEnabled
=
UNINITIALIZED_VALUE
;
mOpenTypeSVGEnabled
=
UNINITIALIZED_VALUE
;
mBidiNumeralOption
=
UNINITIALIZED_VALUE
;
InitBackendPrefs
(
GetBackendPrefs
(
)
)
;
mTotalSystemMemory
=
PR_GetPhysicalMemorySize
(
)
;
VRManager
:
:
ManagerInit
(
)
;
}
gfxPlatform
*
gfxPlatform
:
:
GetPlatform
(
)
{
if
(
!
gPlatform
)
{
MOZ_RELEASE_ASSERT
(
!
XRE_IsContentProcess
(
)
"
Content
Process
should
have
called
InitChild
(
)
before
"
"
first
GetPlatform
(
)
"
)
;
Init
(
)
;
}
return
gPlatform
;
}
bool
gfxPlatform
:
:
Initialized
(
)
{
return
!
!
gPlatform
;
}
void
gfxPlatform
:
:
InitChild
(
const
ContentDeviceData
&
aData
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
gPlatform
"
InitChild
(
)
should
be
called
before
first
GetPlatform
(
)
"
)
;
gContentDeviceInitData
=
&
aData
;
Init
(
)
;
gContentDeviceInitData
=
nullptr
;
}
void
RecordingPrefChanged
(
const
char
*
aPrefName
void
*
aClosure
)
{
if
(
Preferences
:
:
GetBool
(
"
gfx
.
2d
.
recording
"
false
)
)
{
nsAutoCString
fileName
;
nsAutoString
prefFileName
;
nsresult
rv
=
Preferences
:
:
GetString
(
"
gfx
.
2d
.
recordingfile
"
prefFileName
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
CopyUTF16toUTF8
(
prefFileName
fileName
)
;
}
else
{
nsCOMPtr
<
nsIFile
>
tmpFile
;
if
(
NS_FAILED
(
NS_GetSpecialDirectory
(
NS_OS_TEMP_DIR
getter_AddRefs
(
tmpFile
)
)
)
)
{
return
;
}
fileName
.
AppendPrintf
(
"
moz2drec_
%
i_
%
i
.
aer
"
XRE_GetProcessType
(
)
getpid
(
)
)
;
nsresult
rv
=
tmpFile
-
>
AppendNative
(
fileName
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
#
ifdef
XP_WIN
rv
=
tmpFile
-
>
GetPath
(
prefFileName
)
;
CopyUTF16toUTF8
(
prefFileName
fileName
)
;
#
else
rv
=
tmpFile
-
>
GetNativePath
(
fileName
)
;
#
endif
if
(
NS_FAILED
(
rv
)
)
return
;
}
#
ifdef
XP_WIN
gPlatform
-
>
mRecorder
=
Factory
:
:
CreateEventRecorderForFile
(
prefFileName
.
BeginReading
(
)
)
;
#
else
gPlatform
-
>
mRecorder
=
Factory
:
:
CreateEventRecorderForFile
(
fileName
.
BeginReading
(
)
)
;
#
endif
printf_stderr
(
"
Recording
to
%
s
\
n
"
fileName
.
get
(
)
)
;
Factory
:
:
SetGlobalEventRecorder
(
gPlatform
-
>
mRecorder
)
;
}
else
{
Factory
:
:
SetGlobalEventRecorder
(
nullptr
)
;
}
}
#
define
WR_DEBUG_PREF
"
gfx
.
webrender
.
debug
"
static
void
WebRenderDebugPrefChangeCallback
(
const
char
*
aPrefName
void
*
)
{
wr
:
:
DebugFlags
flags
{
0
}
;
#
define
GFX_WEBRENDER_DEBUG
(
suffix
bit
)
\
if
(
Preferences
:
:
GetBool
(
WR_DEBUG_PREF
suffix
false
)
)
{
\
flags
|
=
(
bit
)
;
\
}
GFX_WEBRENDER_DEBUG
(
"
.
profiler
"
wr
:
:
DebugFlags_PROFILER_DBG
)
GFX_WEBRENDER_DEBUG
(
"
.
render
-
targets
"
wr
:
:
DebugFlags_RENDER_TARGET_DBG
)
GFX_WEBRENDER_DEBUG
(
"
.
texture
-
cache
"
wr
:
:
DebugFlags_TEXTURE_CACHE_DBG
)
GFX_WEBRENDER_DEBUG
(
"
.
gpu
-
time
-
queries
"
wr
:
:
DebugFlags_GPU_TIME_QUERIES
)
GFX_WEBRENDER_DEBUG
(
"
.
gpu
-
sample
-
queries
"
wr
:
:
DebugFlags_GPU_SAMPLE_QUERIES
)
GFX_WEBRENDER_DEBUG
(
"
.
disable
-
batching
"
wr
:
:
DebugFlags_DISABLE_BATCHING
)
GFX_WEBRENDER_DEBUG
(
"
.
epochs
"
wr
:
:
DebugFlags_EPOCHS
)
GFX_WEBRENDER_DEBUG
(
"
.
compact
-
profiler
"
wr
:
:
DebugFlags_COMPACT_PROFILER
)
GFX_WEBRENDER_DEBUG
(
"
.
smart
-
profiler
"
wr
:
:
DebugFlags_SMART_PROFILER
)
GFX_WEBRENDER_DEBUG
(
"
.
echo
-
driver
-
messages
"
wr
:
:
DebugFlags_ECHO_DRIVER_MESSAGES
)
GFX_WEBRENDER_DEBUG
(
"
.
new
-
frame
-
indicator
"
wr
:
:
DebugFlags_NEW_FRAME_INDICATOR
)
GFX_WEBRENDER_DEBUG
(
"
.
new
-
scene
-
indicator
"
wr
:
:
DebugFlags_NEW_SCENE_INDICATOR
)
GFX_WEBRENDER_DEBUG
(
"
.
show
-
overdraw
"
wr
:
:
DebugFlags_SHOW_OVERDRAW
)
GFX_WEBRENDER_DEBUG
(
"
.
gpu
-
cache
"
wr
:
:
DebugFlags_GPU_CACHE_DBG
)
GFX_WEBRENDER_DEBUG
(
"
.
slow
-
frame
-
indicator
"
wr
:
:
DebugFlags_SLOW_FRAME_INDICATOR
)
GFX_WEBRENDER_DEBUG
(
"
.
texture
-
cache
.
clear
-
evicted
"
wr
:
:
DebugFlags_TEXTURE_CACHE_DBG_CLEAR_EVICTED
)
GFX_WEBRENDER_DEBUG
(
"
.
picture
-
caching
"
wr
:
:
DebugFlags_PICTURE_CACHING_DBG
)
GFX_WEBRENDER_DEBUG
(
"
.
primitives
"
wr
:
:
DebugFlags_PRIMITIVE_DBG
)
GFX_WEBRENDER_DEBUG
(
"
.
small
-
screen
"
wr
:
:
DebugFlags_SMALL_SCREEN
)
GFX_WEBRENDER_DEBUG
(
"
.
disable
-
opaque
-
pass
"
wr
:
:
DebugFlags_DISABLE_OPAQUE_PASS
)
GFX_WEBRENDER_DEBUG
(
"
.
disable
-
alpha
-
pass
"
wr
:
:
DebugFlags_DISABLE_ALPHA_PASS
)
GFX_WEBRENDER_DEBUG
(
"
.
disable
-
clip
-
masks
"
wr
:
:
DebugFlags_DISABLE_CLIP_MASKS
)
GFX_WEBRENDER_DEBUG
(
"
.
disable
-
text
-
prims
"
wr
:
:
DebugFlags_DISABLE_TEXT_PRIMS
)
GFX_WEBRENDER_DEBUG
(
"
.
disable
-
gradient
-
prims
"
wr
:
:
DebugFlags_DISABLE_GRADIENT_PRIMS
)
GFX_WEBRENDER_DEBUG
(
"
.
obscure
-
images
"
wr
:
:
DebugFlags_OBSCURE_IMAGES
)
GFX_WEBRENDER_DEBUG
(
"
.
glyph
-
flashing
"
wr
:
:
DebugFlags_GLYPH_FLASHING
)
#
undef
GFX_WEBRENDER_DEBUG
gfx
:
:
gfxVars
:
:
SetWebRenderDebugFlags
(
flags
.
bits
)
;
}
#
if
defined
(
USE_SKIA
)
static
uint32_t
GetSkiaGlyphCacheSize
(
)
{
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
uint32_t
cacheSize
=
StaticPrefs
:
:
gfx_content_skia_font_cache_size_AtStartup
(
)
*
1024
*
1024
;
if
(
mozilla
:
:
BrowserTabsRemoteAutostart
(
)
)
{
return
XRE_IsContentProcess
(
)
?
cacheSize
:
kDefaultGlyphCacheSize
;
}
return
cacheSize
;
#
else
return
kDefaultGlyphCacheSize
;
#
endif
}
#
endif
class
WebRenderMemoryReporter
final
:
public
nsIMemoryReporter
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIMEMORYREPORTER
private
:
~
WebRenderMemoryReporter
(
)
=
default
;
}
;
struct
WebRenderMemoryReporterHelper
{
WebRenderMemoryReporterHelper
(
nsIHandleReportCallback
*
aCallback
nsISupports
*
aData
)
:
mCallback
(
aCallback
)
mData
(
aData
)
{
}
nsCOMPtr
<
nsIHandleReportCallback
>
mCallback
;
nsCOMPtr
<
nsISupports
>
mData
;
void
Report
(
size_t
aBytes
const
char
*
aName
)
const
{
nsPrintfCString
path
(
"
explicit
/
gfx
/
webrender
/
%
s
"
aName
)
;
nsCString
desc
(
NS_LITERAL_CSTRING
(
"
CPU
heap
memory
used
by
WebRender
"
)
)
;
ReportInternal
(
aBytes
path
desc
nsIMemoryReporter
:
:
KIND_HEAP
)
;
}
void
ReportTexture
(
size_t
aBytes
const
char
*
aName
)
const
{
nsPrintfCString
path
(
"
gfx
/
webrender
/
textures
/
%
s
"
aName
)
;
nsCString
desc
(
NS_LITERAL_CSTRING
(
"
GPU
texture
memory
used
by
WebRender
"
)
)
;
ReportInternal
(
aBytes
path
desc
nsIMemoryReporter
:
:
KIND_OTHER
)
;
}
void
ReportTotalGPUBytes
(
size_t
aBytes
)
const
{
nsCString
path
(
NS_LITERAL_CSTRING
(
"
gfx
/
webrender
/
total
-
gpu
-
bytes
"
)
)
;
nsCString
desc
(
NS_LITERAL_CSTRING
(
"
Total
GPU
bytes
used
by
WebRender
(
should
match
textures
/
sum
)
"
)
)
;
ReportInternal
(
aBytes
path
desc
nsIMemoryReporter
:
:
KIND_OTHER
)
;
}
void
ReportInternal
(
size_t
aBytes
nsACString
&
aPath
nsACString
&
aDesc
int32_t
aKind
)
const
{
nsAutoCString
processName
;
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
)
{
GPUParent
:
:
GetGPUProcessName
(
processName
)
;
}
mCallback
-
>
Callback
(
processName
aPath
aKind
nsIMemoryReporter
:
:
UNITS_BYTES
aBytes
aDesc
mData
)
;
}
}
;
static
void
FinishAsyncMemoryReport
(
)
{
nsCOMPtr
<
nsIMemoryReporterManager
>
imgr
=
do_GetService
(
"
mozilla
.
org
/
memory
-
reporter
-
manager
;
1
"
)
;
if
(
imgr
)
{
imgr
-
>
EndReport
(
)
;
}
}
#
define
REPORT_INTERNER
(
id
)
\
helper
.
Report
(
aReport
.
interning
.
interners
.
id
\
"
interning
/
"
#
id
"
/
interners
"
)
;
#
define
REPORT_DATA_STORE
(
id
)
\
helper
.
Report
(
aReport
.
interning
.
data_stores
.
id
\
"
interning
/
"
#
id
"
/
data
-
stores
"
)
;
NS_IMPL_ISUPPORTS
(
WebRenderMemoryReporter
nsIMemoryReporter
)
NS_IMETHODIMP
WebRenderMemoryReporter
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
layers
:
:
CompositorManagerChild
*
manager
=
CompositorManagerChild
:
:
GetInstance
(
)
;
if
(
!
manager
)
{
FinishAsyncMemoryReport
(
)
;
return
NS_OK
;
}
WebRenderMemoryReporterHelper
helper
(
aHandleReport
aData
)
;
manager
-
>
SendReportMemory
(
[
=
]
(
wr
:
:
MemoryReport
aReport
)
{
helper
.
Report
(
aReport
.
clip_stores
"
clip
-
stores
"
)
;
helper
.
Report
(
aReport
.
gpu_cache_metadata
"
gpu
-
cache
/
metadata
"
)
;
helper
.
Report
(
aReport
.
gpu_cache_cpu_mirror
"
gpu
-
cache
/
cpu
-
mirror
"
)
;
helper
.
Report
(
aReport
.
render_tasks
"
render
-
tasks
"
)
;
helper
.
Report
(
aReport
.
hit_testers
"
hit
-
testers
"
)
;
helper
.
Report
(
aReport
.
fonts
"
resource
-
cache
/
fonts
"
)
;
helper
.
Report
(
aReport
.
images
"
resource
-
cache
/
images
"
)
;
helper
.
Report
(
aReport
.
rasterized_blobs
"
resource
-
cache
/
rasterized
-
blobs
"
)
;
helper
.
Report
(
aReport
.
shader_cache
"
shader
-
cache
"
)
;
WEBRENDER_FOR_EACH_INTERNER
(
REPORT_INTERNER
)
;
WEBRENDER_FOR_EACH_INTERNER
(
REPORT_DATA_STORE
)
;
helper
.
ReportTexture
(
aReport
.
gpu_cache_textures
"
gpu
-
cache
"
)
;
helper
.
ReportTexture
(
aReport
.
vertex_data_textures
"
vertex
-
data
"
)
;
helper
.
ReportTexture
(
aReport
.
render_target_textures
"
render
-
targets
"
)
;
helper
.
ReportTexture
(
aReport
.
texture_cache_textures
"
texture
-
cache
"
)
;
helper
.
ReportTexture
(
aReport
.
depth_target_textures
"
depth
-
targets
"
)
;
helper
.
ReportTexture
(
aReport
.
swap_chain
"
swap
-
chains
"
)
;
FinishAsyncMemoryReport
(
)
;
}
[
]
(
mozilla
:
:
ipc
:
:
ResponseRejectReason
&
&
aReason
)
{
FinishAsyncMemoryReport
(
)
;
}
)
;
return
NS_OK
;
}
#
undef
REPORT_INTERNER
#
undef
REPORT_DATA_STORE
static
const
char
*
const
WR_ROLLOUT_PREF
=
"
gfx
.
webrender
.
all
.
qualified
"
;
static
const
bool
WR_ROLLOUT_PREF_DEFAULTVALUE
=
true
;
static
const
char
*
const
WR_ROLLOUT_DEFAULT_PREF
=
"
gfx
.
webrender
.
all
.
qualified
.
default
"
;
static
const
bool
WR_ROLLOUT_DEFAULT_PREF_DEFAULTVALUE
=
false
;
static
const
char
*
const
WR_ROLLOUT_PREF_OVERRIDE
=
"
gfx
.
webrender
.
all
.
qualified
.
gfxPref
-
default
-
override
"
;
static
const
char
*
const
WR_ROLLOUT_HW_QUALIFIED_OVERRIDE
=
"
gfx
.
webrender
.
all
.
qualified
.
hardware
-
override
"
;
static
const
char
*
const
PROFILE_BEFORE_CHANGE_TOPIC
=
"
profile
-
before
-
change
"
;
class
WrRolloutPrefShutdownSaver
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_IMETHOD
Observe
(
nsISupports
*
const
char
*
aTopic
const
char16_t
*
)
override
{
if
(
strcmp
(
PROFILE_BEFORE_CHANGE_TOPIC
aTopic
)
!
=
0
)
{
return
NS_OK
;
}
SaveRolloutPref
(
)
;
RefPtr
<
WrRolloutPrefShutdownSaver
>
kungFuDeathGrip
(
this
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
observerService
)
)
{
return
NS_ERROR_FAILURE
;
}
observerService
-
>
RemoveObserver
(
this
PROFILE_BEFORE_CHANGE_TOPIC
)
;
return
NS_OK
;
}
static
void
AddShutdownObserver
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
observerService
)
)
{
return
;
}
RefPtr
<
WrRolloutPrefShutdownSaver
>
wrRolloutSaver
=
new
WrRolloutPrefShutdownSaver
(
)
;
observerService
-
>
AddObserver
(
wrRolloutSaver
PROFILE_BEFORE_CHANGE_TOPIC
false
)
;
}
private
:
virtual
~
WrRolloutPrefShutdownSaver
(
)
=
default
;
void
SaveRolloutPref
(
)
{
if
(
Preferences
:
:
HasUserValue
(
WR_ROLLOUT_PREF
)
|
|
Preferences
:
:
GetType
(
WR_ROLLOUT_PREF
)
=
=
nsIPrefBranch
:
:
PREF_INVALID
)
{
return
;
}
bool
defaultValue
=
Preferences
:
:
GetBool
(
WR_ROLLOUT_PREF
false
PrefValueKind
:
:
Default
)
;
Preferences
:
:
SetBool
(
WR_ROLLOUT_DEFAULT_PREF
defaultValue
)
;
}
}
;
static
void
FrameRatePrefChanged
(
const
char
*
aPref
void
*
)
{
int32_t
newRate
=
gfxPlatform
:
:
ForceSoftwareVsync
(
)
?
gfxPlatform
:
:
GetSoftwareVsyncRate
(
)
:
-
1
;
if
(
newRate
!
=
gLastUsedFrameRate
)
{
gLastUsedFrameRate
=
newRate
;
gfxPlatform
:
:
ReInitFrameRate
(
)
;
}
}
NS_IMPL_ISUPPORTS
(
WrRolloutPrefShutdownSaver
nsIObserver
)
void
gfxPlatform
:
:
Init
(
)
{
MOZ_RELEASE_ASSERT
(
!
XRE_IsGPUProcess
(
)
"
GFX
:
Not
allowed
in
GPU
process
.
"
)
;
MOZ_RELEASE_ASSERT
(
!
XRE_IsRDDProcess
(
)
"
GFX
:
Not
allowed
in
RDD
process
.
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
"
GFX
:
Not
in
main
thread
.
"
)
;
if
(
gEverInitialized
)
{
MOZ_CRASH
(
"
Already
started
?
?
?
"
)
;
}
gEverInitialized
=
true
;
gfxVars
:
:
Initialize
(
)
;
gfxConfig
:
:
Init
(
)
;
if
(
XRE_IsParentProcess
(
)
|
|
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
GPUProcessManager
:
:
Initialize
(
)
;
RDDProcessManager
:
:
Initialize
(
)
;
if
(
Preferences
:
:
GetBool
(
"
media
.
wmf
.
skip
-
blacklist
"
)
)
{
gfxVars
:
:
SetPDMWMFDisableD3D11Dlls
(
nsCString
(
)
)
;
gfxVars
:
:
SetPDMWMFDisableD3D9Dlls
(
nsCString
(
)
)
;
}
else
{
nsAutoCString
d3d11
;
Preferences
:
:
GetCString
(
"
media
.
wmf
.
disable
-
d3d11
-
for
-
dlls
"
d3d11
)
;
gfxVars
:
:
SetPDMWMFDisableD3D11Dlls
(
d3d11
)
;
nsAutoCString
d3d9
;
Preferences
:
:
GetCString
(
"
media
.
wmf
.
disable
-
d3d9
-
for
-
dlls
"
d3d9
)
;
gfxVars
:
:
SetPDMWMFDisableD3D9Dlls
(
d3d9
)
;
}
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_GRE_DIR
getter_AddRefs
(
file
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
gfxVars
:
:
SetGREDirectory
(
nsString
(
)
)
;
}
else
{
nsAutoString
path
;
file
-
>
GetPath
(
path
)
;
gfxVars
:
:
SetGREDirectory
(
nsString
(
path
)
)
;
}
}
if
(
XRE_IsParentProcess
(
)
)
{
WrRolloutPrefShutdownSaver
:
:
AddShutdownObserver
(
)
;
nsCOMPtr
<
nsIFile
>
profDir
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_PROFILE_DIR_STARTUP
getter_AddRefs
(
profDir
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
gfxVars
:
:
SetProfDirectory
(
nsString
(
)
)
;
}
else
{
nsAutoString
path
;
profDir
-
>
GetPath
(
path
)
;
gfxVars
:
:
SetProfDirectory
(
nsString
(
path
)
)
;
}
nsAutoCString
path
;
Preferences
:
:
GetCString
(
"
layers
.
windowrecording
.
path
"
path
)
;
gfxVars
:
:
SetLayersWindowRecordingPath
(
path
)
;
}
{
nsAutoCString
forcedPrefs
;
forcedPrefs
.
AppendPrintf
(
"
FP
(
D
%
d
%
d
"
StaticPrefs
:
:
gfx_direct2d_disabled_AtStartup
(
)
StaticPrefs
:
:
gfx_direct2d_force_enabled_AtStartup
(
)
)
;
forcedPrefs
.
AppendPrintf
(
"
-
L
%
d
%
d
%
d
%
d
"
StaticPrefs
:
:
layers_amd_switchable_gfx_enabled_AtStartup
(
)
StaticPrefs
:
:
layers_acceleration_disabled_AtStartup_DoNotUseDirectly
(
)
StaticPrefs
:
:
layers_acceleration_force_enabled_AtStartup_DoNotUseDirectly
(
)
StaticPrefs
:
:
layers_d3d11_force_warp_AtStartup
(
)
)
;
forcedPrefs
.
AppendPrintf
(
"
-
W
%
d
%
d
%
d
%
d
%
d
%
d
%
d
%
d
"
StaticPrefs
:
:
webgl_angle_force_d3d11
(
)
StaticPrefs
:
:
webgl_angle_force_warp
(
)
StaticPrefs
:
:
webgl_disabled
(
)
StaticPrefs
:
:
webgl_disable_angle
(
)
StaticPrefs
:
:
webgl_dxgl_enabled
(
)
StaticPrefs
:
:
webgl_force_enabled
(
)
StaticPrefs
:
:
webgl_force_layers_readback
(
)
StaticPrefs
:
:
webgl_msaa_force
(
)
)
;
forcedPrefs
.
AppendPrintf
(
"
-
T
%
d
%
d
%
d
)
"
StaticPrefs
:
:
gfx_android_rgb16_force_AtStartup
(
)
0
StaticPrefs
:
:
layers_force_shmem_tiles_AtStartup
(
)
)
;
ScopedGfxFeatureReporter
:
:
AppNote
(
forcedPrefs
)
;
}
InitMoz2DLogging
(
)
;
gGfxPlatformPrefsLock
=
new
Mutex
(
"
gfxPlatform
:
:
gGfxPlatformPrefsLock
"
)
;
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
;
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetDXInterop2Blocked
(
IsDXInterop2Blocked
(
)
)
;
gfxVars
:
:
SetDXNV12Blocked
(
IsDXNV12Blocked
(
)
)
;
gfxVars
:
:
SetDXP010Blocked
(
IsDXP010Blocked
(
)
)
;
gfxVars
:
:
SetDXP016Blocked
(
IsDXP016Blocked
(
)
)
;
}
#
if
defined
(
XP_WIN
)
gPlatform
=
new
gfxWindowsPlatform
;
#
elif
defined
(
XP_MACOSX
)
gPlatform
=
new
gfxPlatformMac
;
#
elif
defined
(
MOZ_WIDGET_GTK
)
gPlatform
=
new
gfxPlatformGtk
;
#
elif
defined
(
ANDROID
)
gPlatform
=
new
gfxAndroidPlatform
;
#
else
#
error
"
No
gfxPlatform
implementation
available
"
#
endif
gPlatform
-
>
PopulateScreenInfo
(
)
;
gPlatform
-
>
InitAcceleration
(
)
;
gPlatform
-
>
InitWebRenderConfig
(
)
;
gPlatform
-
>
InitWebGPUConfig
(
)
;
if
(
!
UseWebRender
(
)
)
{
gPlatform
-
>
EnsureDevicesInitialized
(
)
;
}
gPlatform
-
>
InitOMTPConfig
(
)
;
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
)
{
GPUProcessManager
*
gpu
=
GPUProcessManager
:
:
Get
(
)
;
gpu
-
>
LaunchGPUProcess
(
)
;
}
gLastUsedFrameRate
=
ForceSoftwareVsync
(
)
?
GetSoftwareVsyncRate
(
)
:
-
1
;
Preferences
:
:
RegisterCallback
(
FrameRatePrefChanged
nsDependentCString
(
StaticPrefs
:
:
GetPrefName_layout_frame_rate
(
)
)
)
;
ReInitFrameRate
(
)
;
#
ifdef
USE_SKIA
SkGraphics
:
:
Init
(
)
;
#
ifdef
MOZ_ENABLE_FREETYPE
SkInitCairoFT
(
gPlatform
-
>
FontHintingEnabled
(
)
)
;
#
endif
#
endif
InitLayersIPC
(
)
;
gPlatform
-
>
ComputeTileSize
(
)
;
gPlatform
-
>
mHasVariationFontSupport
=
gPlatform
-
>
CheckVariationFontSupport
(
)
;
nsresult
rv
;
rv
=
gfxPlatformFontList
:
:
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_CRASH
(
"
Could
not
initialize
gfxPlatformFontList
"
)
;
}
gPlatform
-
>
mScreenReferenceSurface
=
gPlatform
-
>
CreateOffscreenSurface
(
IntSize
(
1
1
)
SurfaceFormat
:
:
A8R8G8B8_UINT32
)
;
if
(
!
gPlatform
-
>
mScreenReferenceSurface
)
{
MOZ_CRASH
(
"
Could
not
initialize
mScreenReferenceSurface
"
)
;
}
gPlatform
-
>
mScreenReferenceDrawTarget
=
gPlatform
-
>
CreateOffscreenContentDrawTarget
(
IntSize
(
1
1
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
gPlatform
-
>
mScreenReferenceDrawTarget
|
|
!
gPlatform
-
>
mScreenReferenceDrawTarget
-
>
IsValid
(
)
)
{
if
(
!
gPlatform
-
>
DidRenderingDeviceReset
(
)
)
{
gfxCriticalError
(
)
<
<
"
Could
not
initialize
mScreenReferenceDrawTarget
"
;
}
}
rv
=
gfxFontCache
:
:
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_CRASH
(
"
Could
not
initialize
gfxFontCache
"
)
;
}
gPlatform
-
>
mSRGBOverrideObserver
=
new
SRGBOverrideObserver
(
)
;
Preferences
:
:
AddWeakObserver
(
gPlatform
-
>
mSRGBOverrideObserver
GFX_PREF_CMS_FORCE_SRGB
)
;
Preferences
:
:
RegisterPrefixCallbacks
(
FontPrefChanged
kObservedPrefs
)
;
GLContext
:
:
PlatformStartup
(
)
;
Preferences
:
:
RegisterCallbackAndCall
(
RecordingPrefChanged
"
gfx
.
2d
.
recording
"
)
;
CreateCMSOutputProfile
(
)
;
gPlatform
-
>
mMemoryPressureObserver
=
layers
:
:
MemoryPressureObserver
:
:
Create
(
gPlatform
)
;
nsCOMPtr
<
imgITools
>
imgTools
=
do_GetService
(
"
mozilla
.
org
/
image
/
tools
;
1
"
)
;
if
(
!
imgTools
)
{
MOZ_CRASH
(
"
Could
not
initialize
ImageLib
"
)
;
}
RegisterStrongMemoryReporter
(
new
GfxMemoryImageReporter
(
)
)
;
if
(
XRE_IsParentProcess
(
)
&
&
UseWebRender
(
)
)
{
RegisterStrongAsyncMemoryReporter
(
new
WebRenderMemoryReporter
(
)
)
;
}
#
ifdef
USE_SKIA
RegisterStrongMemoryReporter
(
new
SkMemoryReporter
(
)
)
;
#
endif
mlg
:
:
InitializeMemoryReporters
(
)
;
#
ifdef
USE_SKIA
uint32_t
skiaCacheSize
=
GetSkiaGlyphCacheSize
(
)
;
if
(
skiaCacheSize
!
=
kDefaultGlyphCacheSize
)
{
SkGraphics
:
:
SetFontCacheLimit
(
skiaCacheSize
)
;
}
#
endif
InitNullMetadata
(
)
;
InitOpenGLConfig
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
Preferences
:
:
Unlock
(
FONT_VARIATIONS_PREF
)
;
if
(
!
gPlatform
-
>
HasVariationFontSupport
(
)
)
{
Preferences
:
:
SetBool
(
FONT_VARIATIONS_PREF
false
PrefValueKind
:
:
Default
)
;
Preferences
:
:
SetBool
(
FONT_VARIATIONS_PREF
false
)
;
Preferences
:
:
Lock
(
FONT_VARIATIONS_PREF
)
;
}
}
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
nullptr
"
gfx
-
features
-
ready
"
nullptr
)
;
}
}
static
bool
IsFeatureSupported
(
long
aFeature
bool
aDefault
)
{
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
nsCString
blockId
;
int32_t
status
;
if
(
!
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
aFeature
blockId
&
status
)
)
)
{
return
aDefault
;
}
return
status
=
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
;
}
bool
gfxPlatform
:
:
IsDXInterop2Blocked
(
)
{
return
!
IsFeatureSupported
(
nsIGfxInfo
:
:
FEATURE_DX_INTEROP2
false
)
;
}
bool
gfxPlatform
:
:
IsDXNV12Blocked
(
)
{
return
!
IsFeatureSupported
(
nsIGfxInfo
:
:
FEATURE_DX_NV12
false
)
;
}
bool
gfxPlatform
:
:
IsDXP010Blocked
(
)
{
return
!
IsFeatureSupported
(
nsIGfxInfo
:
:
FEATURE_DX_P010
false
)
;
}
bool
gfxPlatform
:
:
IsDXP016Blocked
(
)
{
return
!
IsFeatureSupported
(
nsIGfxInfo
:
:
FEATURE_DX_P016
false
)
;
}
int32_t
gfxPlatform
:
:
MaxTextureSize
(
)
{
const
int32_t
kMinSizePref
=
2048
;
return
std
:
:
max
(
kMinSizePref
StaticPrefs
:
:
gfx_max_texture_size_AtStartup_DoNotUseDirectly
(
)
)
;
}
int32_t
gfxPlatform
:
:
MaxAllocSize
(
)
{
const
int32_t
kMinAllocPref
=
10000000
;
return
std
:
:
max
(
kMinAllocPref
StaticPrefs
:
:
gfx_max_alloc_size_AtStartup_DoNotUseDirectly
(
)
)
;
}
void
gfxPlatform
:
:
InitMoz2DLogging
(
)
{
auto
fwd
=
new
CrashStatsLogForwarder
(
CrashReporter
:
:
Annotation
:
:
GraphicsCriticalError
)
;
fwd
-
>
SetCircularBufferSize
(
StaticPrefs
:
:
gfx_logging_crash_length_AtStartup
(
)
)
;
mozilla
:
:
gfx
:
:
Config
cfg
;
cfg
.
mLogForwarder
=
fwd
;
cfg
.
mMaxTextureSize
=
gfxPlatform
:
:
MaxTextureSize
(
)
;
cfg
.
mMaxAllocSize
=
gfxPlatform
:
:
MaxAllocSize
(
)
;
gfx
:
:
Factory
:
:
Init
(
cfg
)
;
}
bool
gfxPlatform
:
:
IsHeadless
(
)
{
static
bool
initialized
=
false
;
static
bool
headless
=
false
;
if
(
!
initialized
)
{
initialized
=
true
;
headless
=
PR_GetEnv
(
"
MOZ_HEADLESS
"
)
;
}
return
headless
;
}
bool
gfxPlatform
:
:
UseWebRender
(
)
{
return
gfx
:
:
gfxVars
:
:
UseWebRender
(
)
;
}
static
bool
sLayersIPCIsUp
=
false
;
void
gfxPlatform
:
:
InitNullMetadata
(
)
{
ScrollMetadata
:
:
sNullMetadata
=
new
ScrollMetadata
(
)
;
ClearOnShutdown
(
&
ScrollMetadata
:
:
sNullMetadata
)
;
}
void
gfxPlatform
:
:
Shutdown
(
)
{
if
(
!
gPlatform
)
{
return
;
}
MOZ_ASSERT
(
!
sLayersIPCIsUp
)
;
gfxFontCache
:
:
Shutdown
(
)
;
gfxGradientCache
:
:
Shutdown
(
)
;
gfxAlphaBoxBlur
:
:
ShutdownBlurCache
(
)
;
gfxGraphiteShaper
:
:
Shutdown
(
)
;
gfxPlatformFontList
:
:
Shutdown
(
)
;
gfxFontMissingGlyphs
:
:
Shutdown
(
)
;
ShutdownTileCache
(
)
;
ShutdownCMS
(
)
;
NS_ASSERTION
(
gPlatform
-
>
mSRGBOverrideObserver
"
mSRGBOverrideObserver
has
alreay
gone
"
)
;
Preferences
:
:
RemoveObserver
(
gPlatform
-
>
mSRGBOverrideObserver
GFX_PREF_CMS_FORCE_SRGB
)
;
gPlatform
-
>
mSRGBOverrideObserver
=
nullptr
;
Preferences
:
:
UnregisterPrefixCallbacks
(
FontPrefChanged
kObservedPrefs
)
;
NS_ASSERTION
(
gPlatform
-
>
mMemoryPressureObserver
"
mMemoryPressureObserver
has
already
gone
"
)
;
if
(
gPlatform
-
>
mMemoryPressureObserver
)
{
gPlatform
-
>
mMemoryPressureObserver
-
>
Unregister
(
)
;
gPlatform
-
>
mMemoryPressureObserver
=
nullptr
;
}
if
(
XRE_IsParentProcess
(
)
)
{
gPlatform
-
>
mVsyncSource
-
>
Shutdown
(
)
;
}
gPlatform
-
>
mVsyncSource
=
nullptr
;
GLContextProvider
:
:
Shutdown
(
)
;
#
if
defined
(
XP_WIN
)
GLContextProviderEGL
:
:
Shutdown
(
)
;
#
endif
if
(
XRE_IsParentProcess
(
)
)
{
GPUProcessManager
:
:
Shutdown
(
)
;
VRProcessManager
:
:
Shutdown
(
)
;
RDDProcessManager
:
:
Shutdown
(
)
;
}
gfx
:
:
Factory
:
:
ShutDown
(
)
;
delete
gGfxPlatformPrefsLock
;
gfxVars
:
:
Shutdown
(
)
;
gfxFont
:
:
DestroySingletons
(
)
;
gfxConfig
:
:
Shutdown
(
)
;
gPlatform
-
>
WillShutdown
(
)
;
delete
gPlatform
;
gPlatform
=
nullptr
;
}
void
gfxPlatform
:
:
InitLayersIPC
(
)
{
if
(
sLayersIPCIsUp
)
{
return
;
}
sLayersIPCIsUp
=
true
;
if
(
XRE_IsContentProcess
(
)
)
{
if
(
gfxVars
:
:
UseOMTP
(
)
&
&
!
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
layers
:
:
PaintThread
:
:
Start
(
)
;
}
}
if
(
XRE_IsParentProcess
(
)
|
|
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
if
(
!
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
&
&
UseWebRender
(
)
)
{
wr
:
:
RenderThread
:
:
Start
(
)
;
image
:
:
ImageMemoryReporter
:
:
InitForWebRender
(
)
;
}
layers
:
:
CompositorThreadHolder
:
:
Start
(
)
;
}
}
void
gfxPlatform
:
:
ShutdownLayersIPC
(
)
{
if
(
!
sLayersIPCIsUp
)
{
return
;
}
sLayersIPCIsUp
=
false
;
if
(
XRE_IsContentProcess
(
)
)
{
gfx
:
:
VRManagerChild
:
:
ShutDown
(
)
;
if
(
StaticPrefs
:
:
layers_child_process_shutdown
(
)
)
{
layers
:
:
CompositorManagerChild
:
:
Shutdown
(
)
;
layers
:
:
ImageBridgeChild
:
:
ShutDown
(
)
;
}
if
(
gfxVars
:
:
UseOMTP
(
)
&
&
!
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
layers
:
:
PaintThread
:
:
Shutdown
(
)
;
}
}
else
if
(
XRE_IsParentProcess
(
)
)
{
#
ifdef
MOZ_WAYLAND
widget
:
:
WaylandDisplayShutdown
(
)
;
#
endif
gfx
:
:
VRManagerChild
:
:
ShutDown
(
)
;
layers
:
:
CompositorManagerChild
:
:
Shutdown
(
)
;
layers
:
:
ImageBridgeChild
:
:
ShutDown
(
)
;
layers
:
:
CompositorThreadHolder
:
:
Shutdown
(
)
;
image
:
:
ImageMemoryReporter
:
:
ShutdownForWebRender
(
)
;
if
(
wr
:
:
RenderThread
:
:
Get
(
)
)
{
wr
:
:
RenderThread
:
:
ShutDown
(
)
;
Preferences
:
:
UnregisterCallback
(
WebRenderDebugPrefChangeCallback
WR_DEBUG_PREF
)
;
}
}
else
{
}
}
void
gfxPlatform
:
:
WillShutdown
(
)
{
mScreenReferenceSurface
=
nullptr
;
mScreenReferenceDrawTarget
=
nullptr
;
#
ifdef
USE_SKIA
SkGraphics
:
:
PurgeFontCache
(
)
;
#
endif
#
ifdef
NS_FREE_PERMANENT_DATA
#
if
MOZ_TREE_CAIRO
cairo_debug_reset_static_data
(
)
;
#
endif
#
endif
}
gfxPlatform
:
:
~
gfxPlatform
(
)
{
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateDrawTargetForSurface
(
gfxASurface
*
aSurface
const
IntSize
&
aSize
)
{
SurfaceFormat
format
=
aSurface
-
>
GetSurfaceFormat
(
)
;
RefPtr
<
DrawTarget
>
drawTarget
=
Factory
:
:
CreateDrawTargetForCairoSurface
(
aSurface
-
>
CairoSurface
(
)
aSize
&
format
)
;
if
(
!
drawTarget
)
{
gfxWarning
(
)
<
<
"
gfxPlatform
:
:
CreateDrawTargetForSurface
failed
in
"
"
CreateDrawTargetForCairoSurface
"
;
return
nullptr
;
}
return
drawTarget
.
forget
(
)
;
}
cairo_user_data_key_t
kSourceSurface
;
struct
SourceSurfaceUserData
{
RefPtr
<
SourceSurface
>
mSrcSurface
;
BackendType
mBackendType
;
}
;
static
void
SourceBufferDestroy
(
void
*
srcSurfUD
)
{
delete
static_cast
<
SourceSurfaceUserData
*
>
(
srcSurfUD
)
;
}
UserDataKey
kThebesSurface
;
struct
DependentSourceSurfaceUserData
{
RefPtr
<
gfxASurface
>
mSurface
;
}
;
static
void
SourceSurfaceDestroyed
(
void
*
aData
)
{
delete
static_cast
<
DependentSourceSurfaceUserData
*
>
(
aData
)
;
}
void
gfxPlatform
:
:
ClearSourceSurfaceForSurface
(
gfxASurface
*
aSurface
)
{
aSurface
-
>
SetData
(
&
kSourceSurface
nullptr
nullptr
)
;
}
already_AddRefed
<
SourceSurface
>
gfxPlatform
:
:
GetSourceSurfaceForSurface
(
RefPtr
<
DrawTarget
>
aTarget
gfxASurface
*
aSurface
bool
aIsPlugin
)
{
if
(
!
aSurface
-
>
CairoSurface
(
)
|
|
aSurface
-
>
CairoStatus
(
)
)
{
return
nullptr
;
}
if
(
!
aTarget
)
{
aTarget
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
;
}
void
*
userData
=
aSurface
-
>
GetData
(
&
kSourceSurface
)
;
if
(
userData
)
{
SourceSurfaceUserData
*
surf
=
static_cast
<
SourceSurfaceUserData
*
>
(
userData
)
;
if
(
surf
-
>
mSrcSurface
-
>
IsValid
(
)
&
&
surf
-
>
mBackendType
=
=
aTarget
-
>
GetBackendType
(
)
)
{
RefPtr
<
SourceSurface
>
srcSurface
(
surf
-
>
mSrcSurface
)
;
return
srcSurface
.
forget
(
)
;
}
}
SurfaceFormat
format
=
aSurface
-
>
GetSurfaceFormat
(
)
;
if
(
aTarget
-
>
GetBackendType
(
)
=
=
BackendType
:
:
CAIRO
)
{
return
Factory
:
:
CreateSourceSurfaceForCairoSurface
(
aSurface
-
>
CairoSurface
(
)
aSurface
-
>
GetSize
(
)
format
)
;
}
RefPtr
<
SourceSurface
>
srcBuffer
;
if
(
!
srcBuffer
)
{
RefPtr
<
DataSourceSurface
>
surf
=
GetWrappedDataSourceSurface
(
aSurface
)
;
if
(
surf
)
{
srcBuffer
=
aIsPlugin
?
aTarget
-
>
OptimizeSourceSurfaceForUnknownAlpha
(
surf
)
:
aTarget
-
>
OptimizeSourceSurface
(
surf
)
;
if
(
srcBuffer
=
=
surf
)
{
return
srcBuffer
.
forget
(
)
;
}
}
}
if
(
!
srcBuffer
)
{
MOZ_ASSERT
(
aTarget
-
>
GetBackendType
(
)
!
=
BackendType
:
:
CAIRO
"
We
already
tried
CreateSourceSurfaceFromNativeSurface
with
a
"
"
DrawTargetCairo
above
"
)
;
srcBuffer
=
Factory
:
:
CreateSourceSurfaceForCairoSurface
(
aSurface
-
>
CairoSurface
(
)
aSurface
-
>
GetSize
(
)
format
)
;
if
(
srcBuffer
)
{
srcBuffer
=
aTarget
-
>
OptimizeSourceSurface
(
srcBuffer
)
;
}
}
if
(
!
srcBuffer
)
{
return
nullptr
;
}
if
(
(
srcBuffer
-
>
GetType
(
)
=
=
SurfaceType
:
:
CAIRO
&
&
static_cast
<
SourceSurfaceCairo
*
>
(
srcBuffer
.
get
(
)
)
-
>
GetSurface
(
)
=
=
aSurface
-
>
CairoSurface
(
)
)
|
|
(
srcBuffer
-
>
GetType
(
)
=
=
SurfaceType
:
:
CAIRO_IMAGE
&
&
static_cast
<
DataSourceSurfaceCairo
*
>
(
srcBuffer
.
get
(
)
)
-
>
GetSurface
(
)
=
=
aSurface
-
>
CairoSurface
(
)
)
)
{
return
srcBuffer
.
forget
(
)
;
}
auto
*
srcSurfUD
=
new
SourceSurfaceUserData
;
srcSurfUD
-
>
mBackendType
=
aTarget
-
>
GetBackendType
(
)
;
srcSurfUD
-
>
mSrcSurface
=
srcBuffer
;
aSurface
-
>
SetData
(
&
kSourceSurface
srcSurfUD
SourceBufferDestroy
)
;
return
srcBuffer
.
forget
(
)
;
}
already_AddRefed
<
DataSourceSurface
>
gfxPlatform
:
:
GetWrappedDataSourceSurface
(
gfxASurface
*
aSurface
)
{
RefPtr
<
gfxImageSurface
>
image
=
aSurface
-
>
GetAsImageSurface
(
)
;
if
(
!
image
)
{
return
nullptr
;
}
RefPtr
<
DataSourceSurface
>
result
=
Factory
:
:
CreateWrappingDataSourceSurface
(
image
-
>
Data
(
)
image
-
>
Stride
(
)
image
-
>
GetSize
(
)
ImageFormatToSurfaceFormat
(
image
-
>
Format
(
)
)
)
;
if
(
!
result
)
{
return
nullptr
;
}
auto
*
srcSurfUD
=
new
DependentSourceSurfaceUserData
;
srcSurfUD
-
>
mSurface
=
aSurface
;
result
-
>
AddUserData
(
&
kThebesSurface
srcSurfUD
SourceSurfaceDestroyed
)
;
return
result
.
forget
(
)
;
}
void
gfxPlatform
:
:
ComputeTileSize
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
int32_t
w
=
StaticPrefs
:
:
layers_tile_width_AtStartup
(
)
;
int32_t
h
=
StaticPrefs
:
:
layers_tile_height_AtStartup
(
)
;
if
(
StaticPrefs
:
:
layers_tiles_adjust_AtStartup
(
)
)
{
gfx
:
:
IntSize
screenSize
=
GetScreenSize
(
)
;
if
(
screenSize
.
width
>
0
)
{
w
=
h
=
clamped
(
int32_t
(
RoundUpPow2
(
screenSize
.
width
)
)
/
4
256
1024
)
;
}
}
MOZ_ASSERT
(
gfxVars
:
:
TileSize
(
)
.
width
=
=
-
1
&
&
gfxVars
:
:
TileSize
(
)
.
height
=
=
-
1
)
;
gfxVars
:
:
SetTileSize
(
IntSize
(
w
h
)
)
;
}
void
gfxPlatform
:
:
PopulateScreenInfo
(
)
{
nsCOMPtr
<
nsIScreenManager
>
manager
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
;
MOZ_ASSERT
(
manager
"
failed
to
get
nsIScreenManager
"
)
;
manager
-
>
GetTotalScreenPixels
(
&
mScreenPixels
)
;
nsCOMPtr
<
nsIScreen
>
screen
;
manager
-
>
GetPrimaryScreen
(
getter_AddRefs
(
screen
)
)
;
if
(
!
screen
)
{
return
;
}
screen
-
>
GetColorDepth
(
&
mScreenDepth
)
;
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetScreenDepth
(
mScreenDepth
)
;
}
int
left
top
;
screen
-
>
GetRect
(
&
left
&
top
&
mScreenSize
.
width
&
mScreenSize
.
height
)
;
}
bool
gfxPlatform
:
:
SupportsAzureContentForDrawTarget
(
DrawTarget
*
aTarget
)
{
if
(
!
aTarget
|
|
!
aTarget
-
>
IsValid
(
)
)
{
return
false
;
}
return
SupportsAzureContentForType
(
aTarget
-
>
GetBackendType
(
)
)
;
}
void
gfxPlatform
:
:
PurgeSkiaFontCache
(
)
{
#
ifdef
USE_SKIA
if
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetDefaultContentBackend
(
)
=
=
BackendType
:
:
SKIA
)
{
SkGraphics
:
:
PurgeFontCache
(
)
;
}
#
endif
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateDrawTargetForBackend
(
BackendType
aBackend
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
if
(
aBackend
=
=
BackendType
:
:
CAIRO
)
{
RefPtr
<
gfxASurface
>
surf
=
CreateOffscreenSurface
(
aSize
SurfaceFormatToImageFormat
(
aFormat
)
)
;
if
(
!
surf
|
|
surf
-
>
CairoStatus
(
)
)
{
return
nullptr
;
}
return
CreateDrawTargetForSurface
(
surf
aSize
)
;
}
return
Factory
:
:
CreateDrawTarget
(
aBackend
aSize
aFormat
)
;
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateOffscreenCanvasDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
NS_ASSERTION
(
mPreferredCanvasBackend
!
=
BackendType
:
:
NONE
"
No
backend
.
"
)
;
RefPtr
<
DrawTarget
>
target
=
CreateDrawTargetForBackend
(
mPreferredCanvasBackend
aSize
aFormat
)
;
if
(
target
|
|
mFallbackCanvasBackend
=
=
BackendType
:
:
NONE
)
{
return
target
.
forget
(
)
;
}
#
ifdef
XP_WIN
return
Factory
:
:
CreateDrawTarget
(
mFallbackCanvasBackend
aSize
aFormat
)
;
#
else
return
CreateDrawTargetForBackend
(
mFallbackCanvasBackend
aSize
aFormat
)
;
#
endif
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateOffscreenContentDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
bool
aFallback
)
{
BackendType
backend
=
(
aFallback
)
?
mSoftwareBackend
:
mContentBackend
;
NS_ASSERTION
(
backend
!
=
BackendType
:
:
NONE
"
No
backend
.
"
)
;
RefPtr
<
DrawTarget
>
dt
=
CreateDrawTargetForBackend
(
backend
aSize
aFormat
)
;
if
(
!
dt
)
{
return
nullptr
;
}
dt
-
>
ClearRect
(
gfx
:
:
Rect
(
)
)
;
if
(
!
dt
-
>
IsValid
(
)
)
{
return
nullptr
;
}
return
dt
.
forget
(
)
;
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateSimilarSoftwareDrawTarget
(
DrawTarget
*
aDT
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
RefPtr
<
DrawTarget
>
dt
;
if
(
Factory
:
:
DoesBackendSupportDataDrawtarget
(
aDT
-
>
GetBackendType
(
)
)
)
{
dt
=
aDT
-
>
CreateSimilarDrawTarget
(
aSize
aFormat
)
;
}
else
{
#
ifdef
USE_SKIA
BackendType
backendType
=
BackendType
:
:
SKIA
;
#
else
BackendType
backendType
=
BackendType
:
:
CAIRO
;
#
endif
dt
=
Factory
:
:
CreateDrawTarget
(
backendType
aSize
aFormat
)
;
}
return
dt
.
forget
(
)
;
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateDrawTargetForData
(
unsigned
char
*
aData
const
IntSize
&
aSize
int32_t
aStride
SurfaceFormat
aFormat
bool
aUninitialized
)
{
BackendType
backendType
=
gfxVars
:
:
ContentBackend
(
)
;
NS_ASSERTION
(
backendType
!
=
BackendType
:
:
NONE
"
No
backend
.
"
)
;
if
(
!
Factory
:
:
DoesBackendSupportDataDrawtarget
(
backendType
)
)
{
#
ifdef
USE_SKIA
backendType
=
BackendType
:
:
SKIA
;
#
else
backendType
=
BackendType
:
:
CAIRO
;
#
endif
}
RefPtr
<
DrawTarget
>
dt
=
Factory
:
:
CreateDrawTargetForData
(
backendType
aData
aSize
aStride
aFormat
aUninitialized
)
;
return
dt
.
forget
(
)
;
}
BackendType
gfxPlatform
:
:
BackendTypeForName
(
const
nsCString
&
aName
)
{
if
(
aName
.
EqualsLiteral
(
"
cairo
"
)
)
return
BackendType
:
:
CAIRO
;
if
(
aName
.
EqualsLiteral
(
"
skia
"
)
)
return
BackendType
:
:
SKIA
;
if
(
aName
.
EqualsLiteral
(
"
direct2d
"
)
)
return
BackendType
:
:
DIRECT2D
;
if
(
aName
.
EqualsLiteral
(
"
direct2d1
.
1
"
)
)
return
BackendType
:
:
DIRECT2D1_1
;
return
BackendType
:
:
NONE
;
}
nsresult
gfxPlatform
:
:
GetFontList
(
nsAtom
*
aLangGroup
const
nsACString
&
aGenericFamily
nsTArray
<
nsString
>
&
aListOfFonts
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
GetFontList
(
aLangGroup
aGenericFamily
aListOfFonts
)
;
return
NS_OK
;
}
nsresult
gfxPlatform
:
:
UpdateFontList
(
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
UpdateFontList
(
)
;
return
NS_OK
;
}
void
gfxPlatform
:
:
GetStandardFamilyName
(
const
nsCString
&
aFontName
nsACString
&
aFamilyName
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
GetStandardFamilyName
(
aFontName
aFamilyName
)
;
}
nsAutoCString
gfxPlatform
:
:
GetDefaultFontName
(
const
nsACString
&
aLangGroup
const
nsACString
&
aGenericFamily
)
{
nsAutoCString
result
;
FamilyAndGeneric
fam
=
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
GetDefaultFontFamily
(
aLangGroup
aGenericFamily
)
;
if
(
fam
.
mFamily
.
mIsShared
)
{
if
(
fam
.
mFamily
.
mShared
)
{
fontlist
:
:
FontList
*
fontList
=
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
SharedFontList
(
)
;
result
=
fam
.
mFamily
.
mShared
-
>
DisplayName
(
)
.
AsString
(
fontList
)
;
}
}
else
if
(
fam
.
mFamily
.
mUnshared
)
{
fam
.
mFamily
.
mUnshared
-
>
LocalizedName
(
result
)
;
}
return
result
;
}
bool
gfxPlatform
:
:
DownloadableFontsEnabled
(
)
{
if
(
mAllowDownloadableFonts
=
=
UNINITIALIZED_VALUE
)
{
mAllowDownloadableFonts
=
Preferences
:
:
GetBool
(
GFX_DOWNLOADABLE_FONTS_ENABLED
false
)
;
}
return
mAllowDownloadableFonts
;
}
bool
gfxPlatform
:
:
UseCmapsDuringSystemFallback
(
)
{
if
(
mFallbackUsesCmaps
=
=
UNINITIALIZED_VALUE
)
{
mFallbackUsesCmaps
=
Preferences
:
:
GetBool
(
GFX_PREF_FALLBACK_USE_CMAPS
false
)
;
}
return
mFallbackUsesCmaps
;
}
bool
gfxPlatform
:
:
OpenTypeSVGEnabled
(
)
{
if
(
mOpenTypeSVGEnabled
=
=
UNINITIALIZED_VALUE
)
{
mOpenTypeSVGEnabled
=
Preferences
:
:
GetBool
(
GFX_PREF_OPENTYPE_SVG
false
)
;
}
return
mOpenTypeSVGEnabled
>
0
;
}
uint32_t
gfxPlatform
:
:
WordCacheCharLimit
(
)
{
if
(
mWordCacheCharLimit
=
=
UNINITIALIZED_VALUE
)
{
mWordCacheCharLimit
=
Preferences
:
:
GetInt
(
GFX_PREF_WORD_CACHE_CHARLIMIT
32
)
;
if
(
mWordCacheCharLimit
<
0
)
{
mWordCacheCharLimit
=
32
;
}
}
return
uint32_t
(
mWordCacheCharLimit
)
;
}
uint32_t
gfxPlatform
:
:
WordCacheMaxEntries
(
)
{
if
(
mWordCacheMaxEntries
=
=
UNINITIALIZED_VALUE
)
{
mWordCacheMaxEntries
=
Preferences
:
:
GetInt
(
GFX_PREF_WORD_CACHE_MAXENTRIES
10000
)
;
if
(
mWordCacheMaxEntries
<
0
)
{
mWordCacheMaxEntries
=
10000
;
}
}
return
uint32_t
(
mWordCacheMaxEntries
)
;
}
bool
gfxPlatform
:
:
UseGraphiteShaping
(
)
{
if
(
mGraphiteShapingEnabled
=
=
UNINITIALIZED_VALUE
)
{
mGraphiteShapingEnabled
=
Preferences
:
:
GetBool
(
GFX_PREF_GRAPHITE_SHAPING
false
)
;
}
return
mGraphiteShapingEnabled
;
}
bool
gfxPlatform
:
:
IsFontFormatSupported
(
uint32_t
aFormatFlags
)
{
MOZ_ASSERT
(
!
(
aFormatFlags
&
gfxUserFontSet
:
:
FLAG_FORMAT_NOT_USED
)
"
strange
font
format
hint
set
"
)
;
if
(
aFormatFlags
&
gfxUserFontSet
:
:
FLAG_FORMATS_COMMON
)
{
return
true
;
}
if
(
aFormatFlags
!
=
0
)
{
return
false
;
}
return
true
;
}
gfxFontEntry
*
gfxPlatform
:
:
LookupLocalFont
(
const
nsACString
&
aFontName
WeightRange
aWeightForEntry
StretchRange
aStretchForEntry
SlantStyleRange
aStyleForEntry
)
{
return
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
LookupLocalFont
(
aFontName
aWeightForEntry
aStretchForEntry
aStyleForEntry
)
;
}
gfxFontEntry
*
gfxPlatform
:
:
MakePlatformFont
(
const
nsACString
&
aFontName
WeightRange
aWeightForEntry
StretchRange
aStretchForEntry
SlantStyleRange
aStyleForEntry
const
uint8_t
*
aFontData
uint32_t
aLength
)
{
return
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
MakePlatformFont
(
aFontName
aWeightForEntry
aStretchForEntry
aStyleForEntry
aFontData
aLength
)
;
}
mozilla
:
:
layers
:
:
DiagnosticTypes
gfxPlatform
:
:
GetLayerDiagnosticTypes
(
)
{
mozilla
:
:
layers
:
:
DiagnosticTypes
type
=
DiagnosticTypes
:
:
NO_DIAGNOSTIC
;
if
(
StaticPrefs
:
:
layers_draw_borders
(
)
)
{
type
|
=
mozilla
:
:
layers
:
:
DiagnosticTypes
:
:
LAYER_BORDERS
;
}
if
(
StaticPrefs
:
:
layers_draw_tile_borders
(
)
)
{
type
|
=
mozilla
:
:
layers
:
:
DiagnosticTypes
:
:
TILE_BORDERS
;
}
if
(
StaticPrefs
:
:
layers_draw_bigimage_borders
(
)
)
{
type
|
=
mozilla
:
:
layers
:
:
DiagnosticTypes
:
:
BIGIMAGE_BORDERS
;
}
if
(
StaticPrefs
:
:
layers_flash_borders
(
)
)
{
type
|
=
mozilla
:
:
layers
:
:
DiagnosticTypes
:
:
FLASH_BORDERS
;
}
return
type
;
}
BackendPrefsData
gfxPlatform
:
:
GetBackendPrefs
(
)
const
{
BackendPrefsData
data
;
data
.
mCanvasBitmask
=
BackendTypeBit
(
BackendType
:
:
SKIA
)
;
data
.
mContentBitmask
=
BackendTypeBit
(
BackendType
:
:
SKIA
)
;
#
ifdef
MOZ_WIDGET_GTK
data
.
mCanvasBitmask
|
=
BackendTypeBit
(
BackendType
:
:
CAIRO
)
;
data
.
mContentBitmask
|
=
BackendTypeBit
(
BackendType
:
:
CAIRO
)
;
#
endif
data
.
mCanvasDefault
=
BackendType
:
:
SKIA
;
data
.
mContentDefault
=
BackendType
:
:
SKIA
;
return
data
;
}
void
gfxPlatform
:
:
InitBackendPrefs
(
BackendPrefsData
&
&
aPrefsData
)
{
mPreferredCanvasBackend
=
GetCanvasBackendPref
(
aPrefsData
.
mCanvasBitmask
)
;
if
(
mPreferredCanvasBackend
=
=
BackendType
:
:
NONE
)
{
mPreferredCanvasBackend
=
aPrefsData
.
mCanvasDefault
;
}
if
(
mPreferredCanvasBackend
=
=
BackendType
:
:
DIRECT2D1_1
)
{
mFallbackCanvasBackend
=
GetCanvasBackendPref
(
aPrefsData
.
mCanvasBitmask
&
~
(
BackendTypeBit
(
mPreferredCanvasBackend
)
|
BackendTypeBit
(
BackendType
:
:
DIRECT2D
)
)
)
;
}
else
{
mFallbackCanvasBackend
=
GetCanvasBackendPref
(
aPrefsData
.
mCanvasBitmask
&
~
BackendTypeBit
(
mPreferredCanvasBackend
)
)
;
}
mContentBackendBitmask
=
aPrefsData
.
mContentBitmask
;
mContentBackend
=
GetContentBackendPref
(
mContentBackendBitmask
)
;
if
(
mContentBackend
=
=
BackendType
:
:
NONE
)
{
mContentBackend
=
aPrefsData
.
mContentDefault
;
mContentBackendBitmask
|
=
BackendTypeBit
(
aPrefsData
.
mContentDefault
)
;
}
uint32_t
swBackendBits
=
BackendTypeBit
(
BackendType
:
:
SKIA
)
;
#
ifdef
MOZ_WIDGET_GTK
swBackendBits
|
=
BackendTypeBit
(
BackendType
:
:
CAIRO
)
;
#
endif
mSoftwareBackend
=
GetContentBackendPref
(
swBackendBits
)
;
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetContentBackend
(
mContentBackend
)
;
gfxVars
:
:
SetSoftwareBackend
(
mSoftwareBackend
)
;
}
}
BackendType
gfxPlatform
:
:
GetCanvasBackendPref
(
uint32_t
aBackendBitmask
)
{
return
GetBackendPref
(
"
gfx
.
canvas
.
azure
.
backends
"
aBackendBitmask
)
;
}
BackendType
gfxPlatform
:
:
GetContentBackendPref
(
uint32_t
&
aBackendBitmask
)
{
return
GetBackendPref
(
"
gfx
.
content
.
azure
.
backends
"
aBackendBitmask
)
;
}
BackendType
gfxPlatform
:
:
GetBackendPref
(
const
char
*
aBackendPrefName
uint32_t
&
aBackendBitmask
)
{
nsTArray
<
nsCString
>
backendList
;
nsAutoCString
prefString
;
if
(
NS_SUCCEEDED
(
Preferences
:
:
GetCString
(
aBackendPrefName
prefString
)
)
)
{
ParseString
(
prefString
'
'
backendList
)
;
}
uint32_t
allowedBackends
=
0
;
BackendType
result
=
BackendType
:
:
NONE
;
for
(
uint32_t
i
=
0
;
i
<
backendList
.
Length
(
)
;
+
+
i
)
{
BackendType
type
=
BackendTypeForName
(
backendList
[
i
]
)
;
if
(
BackendTypeBit
(
type
)
&
aBackendBitmask
)
{
allowedBackends
|
=
BackendTypeBit
(
type
)
;
if
(
result
=
=
BackendType
:
:
NONE
)
{
result
=
type
;
}
}
}
aBackendBitmask
=
allowedBackends
;
return
result
;
}
bool
gfxPlatform
:
:
InSafeMode
(
)
{
static
bool
sSafeModeInitialized
=
false
;
static
bool
sInSafeMode
=
false
;
if
(
!
sSafeModeInitialized
)
{
sSafeModeInitialized
=
true
;
nsCOMPtr
<
nsIXULRuntime
>
xr
=
do_GetService
(
"
mozilla
.
org
/
xre
/
runtime
;
1
"
)
;
if
(
xr
)
{
xr
-
>
GetInSafeMode
(
&
sInSafeMode
)
;
}
}
return
sInSafeMode
;
}
bool
gfxPlatform
:
:
OffMainThreadCompositingEnabled
(
)
{
return
UsesOffMainThreadCompositing
(
)
;
}
eCMSMode
gfxPlatform
:
:
GetCMSMode
(
)
{
if
(
!
gCMSInitialized
)
{
int32_t
mode
=
StaticPrefs
:
:
gfx_color_management_mode
(
)
;
if
(
mode
>
=
0
&
&
mode
<
eCMSMode_AllCount
)
{
gCMSMode
=
static_cast
<
eCMSMode
>
(
mode
)
;
}
bool
enableV4
=
StaticPrefs
:
:
gfx_color_management_enablev4
(
)
;
if
(
enableV4
)
{
qcms_enable_iccv4
(
)
;
}
#
ifdef
MOZILLA_MAY_SUPPORT_NEON
if
(
mozilla
:
:
supports_neon
(
)
)
{
qcms_enable_neon
(
)
;
}
#
endif
gCMSInitialized
=
true
;
}
return
gCMSMode
;
}
int
gfxPlatform
:
:
GetRenderingIntent
(
)
{
MOZ_ASSERT
(
QCMS_INTENT_DEFAULT
=
=
0
)
;
int32_t
pIntent
=
StaticPrefs
:
:
gfx_color_management_rendering_intent
(
)
;
if
(
(
pIntent
<
QCMS_INTENT_MIN
)
|
|
(
pIntent
>
QCMS_INTENT_MAX
)
)
{
pIntent
=
-
1
;
}
return
pIntent
;
}
void
gfxPlatform
:
:
TransformPixel
(
const
Color
&
in
Color
&
out
qcms_transform
*
transform
)
{
if
(
transform
)
{
#
ifdef
IS_LITTLE_ENDIAN
uint32_t
packed
=
in
.
ToABGR
(
)
;
qcms_transform_data
(
transform
(
uint8_t
*
)
&
packed
(
uint8_t
*
)
&
packed
1
)
;
out
=
Color
:
:
FromABGR
(
packed
)
;
#
else
uint32_t
packed
=
in
.
UnusualToARGB
(
)
;
qcms_transform_data
(
transform
(
uint8_t
*
)
&
packed
+
1
(
uint8_t
*
)
&
packed
+
1
1
)
;
out
=
Color
:
:
UnusualFromARGB
(
packed
)
;
#
endif
}
else
if
(
&
out
!
=
&
in
)
out
=
in
;
}
void
gfxPlatform
:
:
GetPlatformCMSOutputProfile
(
void
*
&
mem
size_t
&
size
)
{
mem
=
nullptr
;
size
=
0
;
}
void
gfxPlatform
:
:
GetCMSOutputProfileData
(
void
*
&
mem
size_t
&
size
)
{
nsAutoCString
fname
;
Preferences
:
:
GetCString
(
"
gfx
.
color_management
.
display_profile
"
fname
)
;
mem
=
nullptr
;
if
(
!
fname
.
IsEmpty
(
)
)
{
qcms_data_from_path
(
fname
.
get
(
)
&
mem
&
size
)
;
}
if
(
mem
=
=
nullptr
)
{
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetPlatformCMSOutputProfile
(
mem
size
)
;
}
}
void
gfxPlatform
:
:
CreateCMSOutputProfile
(
)
{
if
(
!
gCMSOutputProfile
)
{
if
(
Preferences
:
:
GetBool
(
GFX_PREF_CMS_FORCE_SRGB
false
)
)
{
gCMSOutputProfile
=
GetCMSsRGBProfile
(
)
;
}
if
(
!
gCMSOutputProfile
)
{
void
*
mem
=
nullptr
;
size_t
size
=
0
;
GetCMSOutputProfileData
(
mem
size
)
;
if
(
(
mem
!
=
nullptr
)
&
&
(
size
>
0
)
)
{
gCMSOutputProfile
=
qcms_profile_from_memory
(
mem
size
)
;
free
(
mem
)
;
}
}
if
(
gCMSOutputProfile
&
&
qcms_profile_is_bogus
(
gCMSOutputProfile
)
)
{
NS_ASSERTION
(
gCMSOutputProfile
!
=
GetCMSsRGBProfile
(
)
"
Builtin
sRGB
profile
tagged
as
bogus
!
!
!
"
)
;
qcms_profile_release
(
gCMSOutputProfile
)
;
gCMSOutputProfile
=
nullptr
;
}
if
(
!
gCMSOutputProfile
)
{
gCMSOutputProfile
=
GetCMSsRGBProfile
(
)
;
}
qcms_profile_precache_output_transform
(
gCMSOutputProfile
)
;
}
}
qcms_profile
*
gfxPlatform
:
:
GetCMSOutputProfile
(
)
{
return
gCMSOutputProfile
;
}
qcms_profile
*
gfxPlatform
:
:
GetCMSsRGBProfile
(
)
{
if
(
!
gCMSsRGBProfile
)
{
gCMSsRGBProfile
=
qcms_profile_sRGB
(
)
;
}
return
gCMSsRGBProfile
;
}
qcms_transform
*
gfxPlatform
:
:
GetCMSRGBTransform
(
)
{
if
(
!
gCMSRGBTransform
&
&
!
gCMSRGBTransformFailed
)
{
qcms_profile
*
inProfile
*
outProfile
;
outProfile
=
GetCMSOutputProfile
(
)
;
inProfile
=
GetCMSsRGBProfile
(
)
;
if
(
!
inProfile
|
|
!
outProfile
)
return
nullptr
;
gCMSRGBTransform
=
qcms_transform_create
(
inProfile
QCMS_DATA_RGB_8
outProfile
QCMS_DATA_RGB_8
QCMS_INTENT_PERCEPTUAL
)
;
if
(
!
gCMSRGBTransform
)
{
gCMSRGBTransformFailed
=
true
;
}
}
return
gCMSRGBTransform
;
}
qcms_transform
*
gfxPlatform
:
:
GetCMSInverseRGBTransform
(
)
{
if
(
!
gCMSInverseRGBTransform
)
{
qcms_profile
*
inProfile
*
outProfile
;
inProfile
=
GetCMSOutputProfile
(
)
;
outProfile
=
GetCMSsRGBProfile
(
)
;
if
(
!
inProfile
|
|
!
outProfile
)
return
nullptr
;
gCMSInverseRGBTransform
=
qcms_transform_create
(
inProfile
QCMS_DATA_RGB_8
outProfile
QCMS_DATA_RGB_8
QCMS_INTENT_PERCEPTUAL
)
;
}
return
gCMSInverseRGBTransform
;
}
qcms_transform
*
gfxPlatform
:
:
GetCMSRGBATransform
(
)
{
if
(
!
gCMSRGBATransform
)
{
qcms_profile
*
inProfile
*
outProfile
;
outProfile
=
GetCMSOutputProfile
(
)
;
inProfile
=
GetCMSsRGBProfile
(
)
;
if
(
!
inProfile
|
|
!
outProfile
)
return
nullptr
;
gCMSRGBATransform
=
qcms_transform_create
(
inProfile
QCMS_DATA_RGBA_8
outProfile
QCMS_DATA_RGBA_8
QCMS_INTENT_PERCEPTUAL
)
;
}
return
gCMSRGBATransform
;
}
qcms_transform
*
gfxPlatform
:
:
GetCMSBGRATransform
(
)
{
if
(
!
gCMSBGRATransform
)
{
qcms_profile
*
inProfile
*
outProfile
;
outProfile
=
GetCMSOutputProfile
(
)
;
inProfile
=
GetCMSsRGBProfile
(
)
;
if
(
!
inProfile
|
|
!
outProfile
)
return
nullptr
;
gCMSBGRATransform
=
qcms_transform_create
(
inProfile
QCMS_DATA_BGRA_8
outProfile
QCMS_DATA_BGRA_8
QCMS_INTENT_PERCEPTUAL
)
;
}
return
gCMSBGRATransform
;
}
static
void
ShutdownCMS
(
)
{
if
(
gCMSRGBTransform
)
{
qcms_transform_release
(
gCMSRGBTransform
)
;
gCMSRGBTransform
=
nullptr
;
}
if
(
gCMSInverseRGBTransform
)
{
qcms_transform_release
(
gCMSInverseRGBTransform
)
;
gCMSInverseRGBTransform
=
nullptr
;
}
if
(
gCMSRGBATransform
)
{
qcms_transform_release
(
gCMSRGBATransform
)
;
gCMSRGBATransform
=
nullptr
;
}
if
(
gCMSBGRATransform
)
{
qcms_transform_release
(
gCMSBGRATransform
)
;
gCMSBGRATransform
=
nullptr
;
}
if
(
gCMSOutputProfile
)
{
qcms_profile_release
(
gCMSOutputProfile
)
;
if
(
gCMSsRGBProfile
=
=
gCMSOutputProfile
)
gCMSsRGBProfile
=
nullptr
;
gCMSOutputProfile
=
nullptr
;
}
if
(
gCMSsRGBProfile
)
{
qcms_profile_release
(
gCMSsRGBProfile
)
;
gCMSsRGBProfile
=
nullptr
;
}
gCMSMode
=
eCMSMode_Off
;
gCMSInitialized
=
false
;
}
int32_t
gfxPlatform
:
:
GetBidiNumeralOption
(
)
{
if
(
mBidiNumeralOption
=
=
UNINITIALIZED_VALUE
)
{
mBidiNumeralOption
=
Preferences
:
:
GetInt
(
BIDI_NUMERAL_PREF
0
)
;
}
return
mBidiNumeralOption
;
}
void
gfxPlatform
:
:
FlushFontAndWordCaches
(
)
{
gfxFontCache
*
fontCache
=
gfxFontCache
:
:
GetCache
(
)
;
if
(
fontCache
)
{
fontCache
-
>
Flush
(
)
;
}
gfxPlatform
:
:
PurgeSkiaFontCache
(
)
;
}
void
gfxPlatform
:
:
ForceGlobalReflow
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
XRE_IsParentProcess
(
)
)
{
static
const
char
kPrefName
[
]
=
"
font
.
internaluseonly
.
changed
"
;
bool
fontInternalChange
=
Preferences
:
:
GetBool
(
kPrefName
false
)
;
Preferences
:
:
SetBool
(
kPrefName
!
fontInternalChange
)
;
}
else
{
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
nullptr
"
font
-
info
-
updated
"
nullptr
)
;
}
}
}
void
gfxPlatform
:
:
FontsPrefsChanged
(
const
char
*
aPref
)
{
NS_ASSERTION
(
aPref
!
=
nullptr
"
null
preference
"
)
;
if
(
!
strcmp
(
GFX_DOWNLOADABLE_FONTS_ENABLED
aPref
)
)
{
mAllowDownloadableFonts
=
UNINITIALIZED_VALUE
;
}
else
if
(
!
strcmp
(
GFX_PREF_FALLBACK_USE_CMAPS
aPref
)
)
{
mFallbackUsesCmaps
=
UNINITIALIZED_VALUE
;
}
else
if
(
!
strcmp
(
GFX_PREF_WORD_CACHE_CHARLIMIT
aPref
)
)
{
mWordCacheCharLimit
=
UNINITIALIZED_VALUE
;
FlushFontAndWordCaches
(
)
;
}
else
if
(
!
strcmp
(
GFX_PREF_WORD_CACHE_MAXENTRIES
aPref
)
)
{
mWordCacheMaxEntries
=
UNINITIALIZED_VALUE
;
FlushFontAndWordCaches
(
)
;
}
else
if
(
!
strcmp
(
GFX_PREF_GRAPHITE_SHAPING
aPref
)
)
{
mGraphiteShapingEnabled
=
UNINITIALIZED_VALUE
;
FlushFontAndWordCaches
(
)
;
}
else
if
(
#
if
defined
(
XP_MACOSX
)
!
strcmp
(
GFX_PREF_CORETEXT_SHAPING
aPref
)
|
|
#
endif
!
strcmp
(
"
gfx
.
font_rendering
.
ahem_antialias_none
"
aPref
)
)
{
FlushFontAndWordCaches
(
)
;
}
else
if
(
!
strcmp
(
BIDI_NUMERAL_PREF
aPref
)
)
{
mBidiNumeralOption
=
UNINITIALIZED_VALUE
;
}
else
if
(
!
strcmp
(
GFX_PREF_OPENTYPE_SVG
aPref
)
)
{
mOpenTypeSVGEnabled
=
UNINITIALIZED_VALUE
;
gfxFontCache
:
:
GetCache
(
)
-
>
AgeAllGenerations
(
)
;
gfxFontCache
:
:
GetCache
(
)
-
>
NotifyGlyphsChanged
(
)
;
}
}
mozilla
:
:
LogModule
*
gfxPlatform
:
:
GetLog
(
eGfxLog
aWhichLog
)
{
static
LazyLogModule
sFontlistLog
(
"
fontlist
"
)
;
static
LazyLogModule
sFontInitLog
(
"
fontinit
"
)
;
static
LazyLogModule
sTextrunLog
(
"
textrun
"
)
;
static
LazyLogModule
sTextrunuiLog
(
"
textrunui
"
)
;
static
LazyLogModule
sCmapDataLog
(
"
cmapdata
"
)
;
static
LazyLogModule
sTextPerfLog
(
"
textperf
"
)
;
switch
(
aWhichLog
)
{
case
eGfxLog_fontlist
:
return
sFontlistLog
;
case
eGfxLog_fontinit
:
return
sFontInitLog
;
case
eGfxLog_textrun
:
return
sTextrunLog
;
case
eGfxLog_textrunui
:
return
sTextrunuiLog
;
case
eGfxLog_cmapdata
:
return
sCmapDataLog
;
case
eGfxLog_textperf
:
return
sTextPerfLog
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
log
type
"
)
;
return
nullptr
;
}
RefPtr
<
mozilla
:
:
gfx
:
:
DrawTarget
>
gfxPlatform
:
:
ScreenReferenceDrawTarget
(
)
{
return
(
mScreenReferenceDrawTarget
)
?
mScreenReferenceDrawTarget
:
gPlatform
-
>
CreateOffscreenContentDrawTarget
(
IntSize
(
1
1
)
SurfaceFormat
:
:
B8G8R8A8
true
)
;
}
mozilla
:
:
gfx
:
:
SurfaceFormat
gfxPlatform
:
:
Optimal2DFormatForContent
(
gfxContentType
aContent
)
{
switch
(
aContent
)
{
case
gfxContentType
:
:
COLOR
:
switch
(
GetOffscreenFormat
(
)
)
{
case
SurfaceFormat
:
:
A8R8G8B8_UINT32
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
case
SurfaceFormat
:
:
X8R8G8B8_UINT32
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8X8
;
case
SurfaceFormat
:
:
R5G6B5_UINT16
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
R5G6B5_UINT16
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unknown
gfxImageFormat
for
"
"
gfxContentType
:
:
COLOR
"
)
;
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
}
case
gfxContentType
:
:
ALPHA
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
A8
;
case
gfxContentType
:
:
COLOR_ALPHA
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unknown
gfxContentType
"
)
;
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
}
}
gfxImageFormat
gfxPlatform
:
:
OptimalFormatForContent
(
gfxContentType
aContent
)
{
switch
(
aContent
)
{
case
gfxContentType
:
:
COLOR
:
return
GetOffscreenFormat
(
)
;
case
gfxContentType
:
:
ALPHA
:
return
SurfaceFormat
:
:
A8
;
case
gfxContentType
:
:
COLOR_ALPHA
:
return
SurfaceFormat
:
:
A8R8G8B8_UINT32
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unknown
gfxContentType
"
)
;
return
SurfaceFormat
:
:
A8R8G8B8_UINT32
;
}
}
static
mozilla
:
:
Atomic
<
bool
>
sLayersSupportsHardwareVideoDecoding
(
false
)
;
static
bool
sLayersHardwareVideoDecodingFailed
=
false
;
static
bool
sBufferRotationCheckPref
=
true
;
static
mozilla
:
:
Atomic
<
bool
>
sLayersAccelerationPrefsInitialized
(
false
)
;
static
void
VideoDecodingFailedChangedCallback
(
const
char
*
aPref
void
*
)
{
sLayersHardwareVideoDecodingFailed
=
Preferences
:
:
GetBool
(
aPref
false
)
;
gfxPlatform
:
:
GetPlatform
(
)
-
>
UpdateCanUseHardwareVideoDecoding
(
)
;
}
void
gfxPlatform
:
:
UpdateCanUseHardwareVideoDecoding
(
)
{
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetCanUseHardwareVideoDecoding
(
CanUseHardwareVideoDecoding
(
)
)
;
}
}
void
gfxPlatform
:
:
InitAcceleration
(
)
{
if
(
sLayersAccelerationPrefsInitialized
)
{
return
;
}
InitCompositorAccelerationPrefs
(
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
can
only
initialize
prefs
on
the
main
thread
"
)
;
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
nsCString
discardFailureId
;
int32_t
status
;
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetBrowserTabsRemoteAutostart
(
BrowserTabsRemoteAutostart
(
)
)
;
gfxVars
:
:
SetOffscreenFormat
(
GetOffscreenFormat
(
)
)
;
gfxVars
:
:
SetRequiresAcceleratedGLContextForCompositorOGL
(
RequiresAcceleratedGLContextForCompositorOGL
(
)
)
;
#
ifdef
XP_WIN
if
(
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_D3D11_KEYED_MUTEX
discardFailureId
&
status
)
)
)
{
gfxVars
:
:
SetAllowD3D11KeyedMutex
(
status
=
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
)
;
}
else
{
gfxCriticalNote
<
<
"
Cannot
evaluate
keyed
mutex
feature
status
"
;
gfxVars
:
:
SetAllowD3D11KeyedMutex
(
true
)
;
}
if
(
StaticPrefs
:
:
gfx_direct3d11_use_double_buffering
(
)
&
&
IsWin10OrLater
(
)
)
{
gfxVars
:
:
SetUseDoubleBufferingWithCompositor
(
true
)
;
}
#
endif
}
if
(
Preferences
:
:
GetBool
(
"
media
.
hardware
-
video
-
decoding
.
enabled
"
false
)
&
&
#
ifdef
XP_WIN
Preferences
:
:
GetBool
(
"
media
.
wmf
.
dxva
.
enabled
"
true
)
&
&
#
endif
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_HARDWARE_VIDEO_DECODING
discardFailureId
&
status
)
)
)
{
if
(
status
=
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
|
|
StaticPrefs
:
:
media_hardware_video_decoding_force_enabled_AtStartup
(
)
)
{
sLayersSupportsHardwareVideoDecoding
=
true
;
}
}
sLayersAccelerationPrefsInitialized
=
true
;
if
(
XRE_IsParentProcess
(
)
)
{
Preferences
:
:
RegisterCallbackAndCall
(
VideoDecodingFailedChangedCallback
"
media
.
hardware
-
video
-
decoding
.
failed
"
)
;
InitGPUProcessPrefs
(
)
;
gfxVars
:
:
SetRemoteCanvasEnabled
(
StaticPrefs
:
:
gfx_canvas_remote
(
)
&
&
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
)
;
}
}
void
gfxPlatform
:
:
InitGPUProcessPrefs
(
)
{
if
(
!
StaticPrefs
:
:
layers_gpu_process_enabled_AtStartup
(
)
&
&
!
StaticPrefs
:
:
layers_gpu_process_force_enabled_AtStartup
(
)
)
{
return
;
}
FeatureState
&
gpuProc
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
GPU_PROCESS
)
;
if
(
!
BrowserTabsRemoteAutostart
(
)
)
{
gpuProc
.
DisableByDefault
(
FeatureStatus
:
:
Unavailable
"
Multi
-
process
mode
is
not
enabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_NO_E10S
"
)
)
;
}
else
{
gpuProc
.
SetDefaultFromPref
(
StaticPrefs
:
:
GetPrefName_layers_gpu_process_enabled
(
)
true
StaticPrefs
:
:
GetPrefDefault_layers_gpu_process_enabled
(
)
)
;
}
if
(
StaticPrefs
:
:
layers_gpu_process_force_enabled_AtStartup
(
)
)
{
gpuProc
.
UserForceEnable
(
"
User
force
-
enabled
via
pref
"
)
;
}
if
(
IsHeadless
(
)
)
{
gpuProc
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
Headless
mode
is
enabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_HEADLESS_MODE
"
)
)
;
return
;
}
if
(
InSafeMode
(
)
)
{
gpuProc
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
Safe
-
mode
is
enabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_SAFE_MODE
"
)
)
;
return
;
}
if
(
StaticPrefs
:
:
gfx_layerscope_enabled
(
)
)
{
gpuProc
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
LayerScope
does
not
work
in
the
GPU
process
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_LAYERSCOPE
"
)
)
;
return
;
}
InitPlatformGPUProcessPrefs
(
)
;
}
void
gfxPlatform
:
:
InitCompositorAccelerationPrefs
(
)
{
const
char
*
acceleratedEnv
=
PR_GetEnv
(
"
MOZ_ACCELERATED
"
)
;
FeatureState
&
feature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
HW_COMPOSITING
)
;
if
(
feature
.
SetDefault
(
AccelerateLayersByDefault
(
)
FeatureStatus
:
:
Blocked
"
Acceleration
blocked
by
platform
"
)
)
{
if
(
StaticPrefs
:
:
layers_acceleration_disabled_AtStartup_DoNotUseDirectly
(
)
)
{
feature
.
UserDisable
(
"
Disabled
by
pref
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_PREF
"
)
)
;
}
else
if
(
acceleratedEnv
&
&
*
acceleratedEnv
=
=
'
0
'
)
{
feature
.
UserDisable
(
"
Disabled
by
envvar
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_ENV
"
)
)
;
}
}
else
{
if
(
acceleratedEnv
&
&
*
acceleratedEnv
=
=
'
1
'
)
{
feature
.
UserEnable
(
"
Enabled
by
envvar
"
)
;
}
}
if
(
StaticPrefs
:
:
layers_acceleration_force_enabled_AtStartup_DoNotUseDirectly
(
)
)
{
feature
.
UserForceEnable
(
"
Force
-
enabled
by
pref
"
)
;
}
if
(
InSafeMode
(
)
)
{
feature
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
Acceleration
blocked
by
safe
-
mode
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_SAFEMODE
"
)
)
;
}
if
(
IsHeadless
(
)
)
{
feature
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
Acceleration
blocked
by
headless
mode
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_HEADLESSMODE
"
)
)
;
}
if
(
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
feature
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
Acceleration
blocked
by
recording
/
replaying
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_RECORDREPLAY
"
)
)
;
}
}
bool
gfxPlatform
:
:
WebRenderPrefEnabled
(
)
{
return
StaticPrefs
:
:
gfx_webrender_all_AtStartup
(
)
|
|
StaticPrefs
:
:
gfx_webrender_enabled_AtStartup_DoNotUseDirectly
(
)
;
}
bool
gfxPlatform
:
:
WebRenderEnvvarEnabled
(
)
{
const
char
*
env
=
PR_GetEnv
(
"
MOZ_WEBRENDER
"
)
;
return
(
env
&
&
*
env
=
=
'
1
'
)
;
}
static
bool
WebRenderEnvvarDisabled
(
)
{
const
char
*
env
=
PR_GetEnv
(
"
MOZ_WEBRENDER
"
)
;
return
(
env
&
&
*
env
=
=
'
0
'
)
;
}
static
bool
InMarionetteRolloutTest
(
)
{
return
Preferences
:
:
HasUserValue
(
WR_ROLLOUT_HW_QUALIFIED_OVERRIDE
)
;
}
static
bool
CalculateWrQualifiedPrefValue
(
)
{
auto
clearPrefOnExit
=
MakeScopeExit
(
[
]
(
)
{
Preferences
:
:
ClearUser
(
WR_ROLLOUT_DEFAULT_PREF
)
;
}
)
;
if
(
!
Preferences
:
:
HasUserValue
(
WR_ROLLOUT_PREF
)
&
&
Preferences
:
:
HasUserValue
(
WR_ROLLOUT_DEFAULT_PREF
)
)
{
return
Preferences
:
:
GetBool
(
WR_ROLLOUT_DEFAULT_PREF
WR_ROLLOUT_DEFAULT_PREF_DEFAULTVALUE
)
;
}
if
(
Preferences
:
:
HasUserValue
(
WR_ROLLOUT_PREF_OVERRIDE
)
)
{
return
Preferences
:
:
GetBool
(
WR_ROLLOUT_PREF_OVERRIDE
)
;
}
return
Preferences
:
:
GetBool
(
WR_ROLLOUT_PREF
WR_ROLLOUT_PREF_DEFAULTVALUE
)
;
}
#
ifndef
MOZ_WIDGET_ANDROID
static
void
HardwareTooOldForWR
(
FeatureState
&
aFeature
)
{
aFeature
.
Disable
(
FeatureStatus
:
:
BlockedDeviceTooOld
"
Device
too
old
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_DEVICE_TOO_OLD
"
)
)
;
}
static
void
UpdateWRQualificationForNvidia
(
FeatureState
&
aFeature
int32_t
aDeviceId
bool
*
aOutGuardedByQualifiedPref
)
{
bool
supported
=
aDeviceId
>
=
0x6c0
;
if
(
!
supported
)
{
HardwareTooOldForWR
(
aFeature
)
;
return
;
}
#
if
defined
(
XP_WIN
)
*
aOutGuardedByQualifiedPref
=
false
;
#
elif
defined
(
NIGHTLY_BUILD
)
#
else
aFeature
.
Disable
(
FeatureStatus
:
:
BlockedReleaseChannelNvidia
"
Release
channel
and
Nvidia
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_RELEASE_CHANNEL_NVIDIA
"
)
)
;
#
endif
}
static
void
UpdateWRQualificationForAMD
(
FeatureState
&
aFeature
int32_t
aDeviceId
bool
*
aOutGuardedByQualifiedPref
)
{
bool
supported
=
(
aDeviceId
>
=
0x6600
&
&
aDeviceId
<
0x66b0
)
|
|
(
aDeviceId
>
=
0x6700
&
&
aDeviceId
<
0x6720
)
|
|
(
aDeviceId
>
=
0x6780
&
&
aDeviceId
<
0x6840
)
|
|
(
aDeviceId
>
=
0x6860
&
&
aDeviceId
<
0x6880
)
|
|
(
aDeviceId
>
=
0x6900
&
&
aDeviceId
<
0x6a00
)
|
|
(
aDeviceId
=
=
0x7300
)
|
|
(
aDeviceId
>
=
0x7310
&
&
aDeviceId
<
0x7320
)
|
|
(
aDeviceId
>
=
0x9830
&
&
aDeviceId
<
0x9870
)
|
|
(
aDeviceId
>
=
0x9900
&
&
aDeviceId
<
0x9a00
)
;
if
(
!
supported
)
{
HardwareTooOldForWR
(
aFeature
)
;
return
;
}
#
if
defined
(
XP_WIN
)
*
aOutGuardedByQualifiedPref
=
false
;
#
elif
defined
(
NIGHTLY_BUILD
)
#
else
aFeature
.
Disable
(
FeatureStatus
:
:
BlockedReleaseChannelAMD
"
Release
channel
and
AMD
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_RELEASE_CHANNEL_AMD
"
)
)
;
#
endif
}
static
void
UpdateWRQualificationForIntel
(
FeatureState
&
aFeature
int32_t
aDeviceId
int64_t
aScreenPixels
bool
*
aOutGuardedByQualifiedPref
)
{
const
uint16_t
supportedDevices
[
]
=
{
0x1912
0x1913
0x1915
0x1916
0x1917
0x191a
0x191b
0x191d
0x191e
0x1921
0x1923
0x1926
0x1927
0x192b
0x1932
0x193b
0x193d
0x5912
0x5916
0x5917
0x591a
0x591b
0x591c
0x591d
0x591e
0x5921
0x5926
0x5923
0x5927
0x593b
0x3e91
0x3e92
0x3e96
0x3e98
0x3e9a
0x3e9b
0x3e94
0x3ea0
0x3ea9
0x3ea2
0x3ea6
0x3ea7
0x3ea8
0x3ea5
0x1612
0x1616
0x161a
0x161b
0x161d
0x161e
0x1622
0x1626
0x162a
0x162b
0x162d
0x162e
0x1632
0x1636
0x163a
0x163b
0x163d
0x163e
0x0412
0x0416
0x041a
0x041b
0x041e
0x0a12
0x0a16
0x0a1a
0x0a1b
0x0a1e
}
;
bool
supported
=
false
;
for
(
uint16_t
id
:
supportedDevices
)
{
if
(
aDeviceId
=
=
id
)
{
supported
=
true
;
break
;
}
}
if
(
!
supported
)
{
HardwareTooOldForWR
(
aFeature
)
;
return
;
}
#
if
defined
(
XP_WIN
)
&
&
defined
(
NIGHTLY_BUILD
)
#
else
#
if
defined
(
XP_WIN
)
const
int64_t
kMaxPixels
=
1920
*
1200
;
#
else
const
int64_t
kMaxPixels
=
3440
*
1440
;
#
endif
if
(
aScreenPixels
>
kMaxPixels
)
{
aFeature
.
Disable
(
FeatureStatus
:
:
BlockedScreenTooLarge
"
Screen
size
too
large
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_SCREEN_SIZE_TOO_LARGE
"
)
)
;
return
;
}
if
(
aScreenPixels
<
=
0
)
{
aFeature
.
Disable
(
FeatureStatus
:
:
BlockedScreenUnknown
"
Screen
size
unknown
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_SCREEN_SIZE_UNKNOWN
"
)
)
;
return
;
}
#
endif
#
if
(
defined
(
XP_WIN
)
|
|
(
defined
(
MOZ_WIDGET_GTK
)
&
&
defined
(
NIGHTLY_BUILD
)
)
)
#
else
aFeature
.
Disable
(
FeatureStatus
:
:
BlockedReleaseChannelIntel
"
Release
channel
and
Intel
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_RELEASE_CHANNEL_INTEL
"
)
)
;
#
endif
}
#
endif
static
FeatureState
&
WebRenderHardwareQualificationStatus
(
int64_t
aScreenPixels
bool
aHasBattery
bool
*
aOutGuardedByQualifiedPref
)
{
FeatureState
&
featureWebRenderQualified
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
WEBRENDER_QUALIFIED
)
;
featureWebRenderQualified
.
EnableByDefault
(
)
;
MOZ_ASSERT
(
aOutGuardedByQualifiedPref
&
&
*
aOutGuardedByQualifiedPref
)
;
if
(
Preferences
:
:
HasUserValue
(
WR_ROLLOUT_HW_QUALIFIED_OVERRIDE
)
)
{
if
(
!
Preferences
:
:
GetBool
(
WR_ROLLOUT_HW_QUALIFIED_OVERRIDE
)
)
{
featureWebRenderQualified
.
Disable
(
FeatureStatus
:
:
BlockedOverride
"
HW
qualification
pref
override
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_WR_QUALIFICATION_OVERRIDE
"
)
)
;
}
return
featureWebRenderQualified
;
}
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
nsCString
failureId
;
int32_t
status
;
if
(
NS_FAILED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_WEBRENDER
failureId
&
status
)
)
)
{
featureWebRenderQualified
.
Disable
(
FeatureStatus
:
:
BlockedNoGfxInfo
"
gfxInfo
is
broken
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_WR_NO_GFX_INFO
"
)
)
;
return
featureWebRenderQualified
;
}
if
(
status
!
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
)
{
featureWebRenderQualified
.
Disable
(
FeatureStatus
:
:
Blacklisted
"
No
qualified
hardware
"
failureId
)
;
return
featureWebRenderQualified
;
}
#
ifndef
MOZ_WIDGET_ANDROID
nsAutoString
adapterVendorID
;
gfxInfo
-
>
GetAdapterVendorID
(
adapterVendorID
)
;
nsAutoString
adapterDeviceID
;
gfxInfo
-
>
GetAdapterDeviceID
(
adapterDeviceID
)
;
nsresult
valid
;
int32_t
deviceID
=
adapterDeviceID
.
ToInteger
(
&
valid
16
)
;
if
(
valid
!
=
NS_OK
)
{
featureWebRenderQualified
.
Disable
(
FeatureStatus
:
:
BlockedDeviceUnknown
"
Bad
device
id
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_BAD_DEVICE_ID
"
)
)
;
return
featureWebRenderQualified
;
}
if
(
adapterVendorID
=
=
u
"
0x10de
"
)
{
UpdateWRQualificationForNvidia
(
featureWebRenderQualified
deviceID
aOutGuardedByQualifiedPref
)
;
}
else
if
(
adapterVendorID
=
=
u
"
0x1002
"
)
{
UpdateWRQualificationForAMD
(
featureWebRenderQualified
deviceID
aOutGuardedByQualifiedPref
)
;
}
else
if
(
adapterVendorID
=
=
u
"
0x8086
"
)
{
UpdateWRQualificationForIntel
(
featureWebRenderQualified
deviceID
aScreenPixels
aOutGuardedByQualifiedPref
)
;
}
else
{
featureWebRenderQualified
.
Disable
(
FeatureStatus
:
:
BlockedVendorUnsupported
"
Unsupported
vendor
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_UNSUPPORTED_VENDOR
"
)
)
;
}
if
(
!
featureWebRenderQualified
.
IsEnabled
(
)
)
{
MOZ_ASSERT
(
*
aOutGuardedByQualifiedPref
)
;
return
featureWebRenderQualified
;
}
if
(
aHasBattery
)
{
#
ifndef
XP_WIN
MOZ_ASSERT
(
false
)
;
#
endif
*
aOutGuardedByQualifiedPref
=
true
;
const
int64_t
kMaxPixelsBattery
=
1920
*
1200
;
if
(
aScreenPixels
>
0
&
&
aScreenPixels
<
=
kMaxPixelsBattery
)
{
#
ifndef
NIGHTLY_BUILD
featureWebRenderQualified
.
Disable
(
FeatureStatus
:
:
BlockedReleaseChannelBattery
"
Release
channel
and
battery
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_RELEASE_CHANNEL_BATTERY
"
)
)
;
#
endif
}
else
{
featureWebRenderQualified
.
Disable
(
FeatureStatus
:
:
BlockedHasBattery
"
Has
battery
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_WR_HAS_BATTERY
"
)
)
;
}
}
#
else
#
ifndef
NIGHTLY_BUILD
featureWebRenderQualified
.
Disable
(
FeatureStatus
:
:
BlockedReleaseChannelAndroid
"
Release
channel
and
Android
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_RELEASE_CHANNEL_ANDROID
"
)
)
;
#
endif
#
endif
return
featureWebRenderQualified
;
}
void
gfxPlatform
:
:
InitWebRenderConfig
(
)
{
bool
prefEnabled
=
WebRenderPrefEnabled
(
)
;
bool
envvarEnabled
=
WebRenderEnvvarEnabled
(
)
;
ScopedGfxFeatureReporter
reporter
(
"
WR
"
prefEnabled
|
|
envvarEnabled
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
if
(
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
gfxVars
:
:
SetUseWebRender
(
false
)
;
}
if
(
UseWebRender
(
)
)
{
reporter
.
SetSuccessful
(
)
;
}
return
;
}
bool
guardedByQualifiedPref
=
true
;
FeatureState
&
featureWebRenderQualified
=
WebRenderHardwareQualificationStatus
(
mScreenPixels
HasBattery
(
)
&
guardedByQualifiedPref
)
;
FeatureState
&
featureWebRender
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
WEBRENDER
)
;
featureWebRender
.
DisableByDefault
(
FeatureStatus
:
:
OptIn
"
WebRender
is
an
opt
-
in
feature
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_DEFAULT_OFF
"
)
)
;
const
bool
wrQualifiedAll
=
CalculateWrQualifiedPrefValue
(
)
;
if
(
envvarEnabled
)
{
featureWebRender
.
UserEnable
(
"
Force
enabled
by
envvar
"
)
;
}
else
if
(
prefEnabled
)
{
featureWebRender
.
UserEnable
(
"
Force
enabled
by
pref
"
)
;
}
else
if
(
featureWebRenderQualified
.
IsEnabled
(
)
)
{
if
(
!
guardedByQualifiedPref
)
{
featureWebRender
.
UserEnable
(
"
Qualified
in
release
"
)
;
}
else
if
(
wrQualifiedAll
)
{
featureWebRender
.
UserEnable
(
"
Qualified
enabled
by
pref
"
)
;
}
}
if
(
StaticPrefs
:
:
gfx_webrender_force_disabled_AtStartup
(
)
|
|
(
WebRenderEnvvarDisabled
(
)
&
&
!
InMarionetteRolloutTest
(
)
)
)
{
featureWebRender
.
UserDisable
(
"
User
force
-
disabled
WR
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_USER_FORCE_DISABLED
"
)
)
;
}
if
(
!
gfxConfig
:
:
IsEnabled
(
Feature
:
:
HW_COMPOSITING
)
)
{
featureWebRender
.
ForceDisable
(
FeatureStatus
:
:
UnavailableNoHwCompositing
"
Hardware
compositing
is
disabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_WEBRENDER_NEED_HWCOMP
"
)
)
;
}
#
ifdef
XP_WIN
if
(
!
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
)
{
featureWebRender
.
ForceDisable
(
FeatureStatus
:
:
UnavailableNoGpuProcess
"
GPU
Process
is
disabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_GPU_PROCESS_DISABLED
"
)
)
;
}
#
endif
if
(
InSafeMode
(
)
)
{
featureWebRender
.
ForceDisable
(
FeatureStatus
:
:
UnavailableInSafeMode
"
Safe
-
mode
is
enabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_SAFE_MODE
"
)
)
;
}
#
ifdef
XP_WIN
if
(
Preferences
:
:
GetBool
(
"
gfx
.
webrender
.
force
-
angle
"
false
)
)
{
if
(
!
gfxConfig
:
:
IsEnabled
(
Feature
:
:
D3D11_HW_ANGLE
)
)
{
featureWebRender
.
ForceDisable
(
FeatureStatus
:
:
UnavailableNoAngle
"
ANGLE
is
disabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_ANGLE_DISABLED
"
)
)
;
}
else
{
gfxVars
:
:
SetUseWebRenderANGLE
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER
)
)
;
}
}
#
endif
if
(
Preferences
:
:
GetBool
(
"
gfx
.
webrender
.
program
-
binary
-
disk
"
false
)
)
{
gfxVars
:
:
SetUseWebRenderProgramBinaryDisk
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER
)
)
;
}
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER
)
)
{
gfxVars
:
:
SetUseWebRender
(
true
)
;
reporter
.
SetSuccessful
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
Preferences
:
:
RegisterPrefixCallbackAndCall
(
WebRenderDebugPrefChangeCallback
WR_DEBUG_PREF
)
;
}
}
#
if
defined
(
MOZ_WIDGET_GTK
)
else
{
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
HW_COMPOSITING
)
)
{
gfxConfig
:
:
Disable
(
Feature
:
:
HW_COMPOSITING
FeatureStatus
:
:
Blocked
"
Acceleration
blocked
by
platform
"
)
;
}
if
(
!
gfxConfig
:
:
IsEnabled
(
Feature
:
:
HW_COMPOSITING
)
&
&
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
&
&
!
StaticPrefs
:
:
layers_gpu_process_allow_software_AtStartup
(
)
)
{
gfxConfig
:
:
Disable
(
Feature
:
:
GPU_PROCESS
FeatureStatus
:
:
Unavailable
"
Hardware
compositing
is
unavailable
.
"
)
;
}
}
#
endif
#
ifdef
XP_WIN
if
(
Preferences
:
:
GetBool
(
"
gfx
.
webrender
.
flip
-
sequential
"
false
)
)
{
if
(
IsWin10OrLater
(
)
&
&
UseWebRender
(
)
&
&
gfxVars
:
:
UseWebRenderANGLE
(
)
)
{
gfxVars
:
:
SetUseWebRenderFlipSequentialWin
(
true
)
;
}
}
if
(
Preferences
:
:
GetBool
(
"
gfx
.
webrender
.
dcomp
-
win
.
enabled
"
false
)
)
{
if
(
IsWin10OrLater
(
)
&
&
UseWebRender
(
)
&
&
gfxVars
:
:
UseWebRenderANGLE
(
)
)
{
gfxVars
:
:
SetUseWebRenderDCompWin
(
true
)
;
}
}
if
(
Preferences
:
:
GetBool
(
"
gfx
.
webrender
.
triple
-
buffering
.
enabled
"
false
)
)
{
if
(
gfxVars
:
:
UseWebRenderDCompWin
(
)
|
|
gfxVars
:
:
UseWebRenderFlipSequentialWin
(
)
)
{
gfxVars
:
:
SetUseWebRenderTripleBufferingWin
(
true
)
;
}
}
#
endif
gfxVars
:
:
SetUseGLSwizzle
(
IsFeatureSupported
(
nsIGfxInfo
:
:
FEATURE_GL_SWIZZLE
true
)
)
;
gfxUtils
:
:
RemoveShaderCacheFromDiskIfNecessary
(
)
;
}
void
gfxPlatform
:
:
InitWebGPUConfig
(
)
{
FeatureState
&
feature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
WEBGPU
)
;
feature
.
SetDefaultFromPref
(
"
dom
.
webgpu
.
enable
"
true
false
)
;
}
void
gfxPlatform
:
:
InitOMTPConfig
(
)
{
ScopedGfxFeatureReporter
reporter
(
"
OMTP
"
)
;
FeatureState
&
omtp
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
OMTP
)
;
int32_t
paintWorkerCount
=
PaintThread
:
:
CalculatePaintWorkerCount
(
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
if
(
gfxVars
:
:
UseOMTP
(
)
)
{
reporter
.
SetSuccessful
(
paintWorkerCount
)
;
}
return
;
}
omtp
.
SetDefaultFromPref
(
"
layers
.
omtp
.
enabled
"
true
Preferences
:
:
GetBool
(
"
layers
.
omtp
.
enabled
"
false
PrefValueKind
:
:
Default
)
)
;
if
(
mContentBackend
=
=
BackendType
:
:
CAIRO
)
{
omtp
.
ForceDisable
(
FeatureStatus
:
:
Broken
"
OMTP
is
not
supported
when
using
cairo
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_PREF
"
)
)
;
}
#
ifdef
XP_MACOSX
if
(
!
nsCocoaFeatures
:
:
OnYosemiteOrLater
(
)
)
{
omtp
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
OMTP
blocked
before
OSX
10
.
10
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_OMTP_OSX_MAVERICKS
"
)
)
;
}
#
endif
if
(
InSafeMode
(
)
)
{
omtp
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
OMTP
blocked
by
safe
-
mode
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_COMP_SAFEMODE
"
)
)
;
}
if
(
omtp
.
IsEnabled
(
)
)
{
gfxVars
:
:
SetUseOMTP
(
true
)
;
reporter
.
SetSuccessful
(
paintWorkerCount
)
;
}
}
bool
gfxPlatform
:
:
CanUseHardwareVideoDecoding
(
)
{
MOZ_ASSERT
(
sLayersAccelerationPrefsInitialized
)
;
return
sLayersSupportsHardwareVideoDecoding
&
&
!
sLayersHardwareVideoDecodingFailed
;
}
bool
gfxPlatform
:
:
AccelerateLayersByDefault
(
)
{
#
if
defined
(
MOZ_GL_PROVIDER
)
|
|
defined
(
MOZ_WIDGET_UIKIT
)
return
true
;
#
else
return
false
;
#
endif
}
bool
gfxPlatform
:
:
BufferRotationEnabled
(
)
{
MutexAutoLock
autoLock
(
*
gGfxPlatformPrefsLock
)
;
return
sBufferRotationCheckPref
&
&
StaticPrefs
:
:
layers_bufferrotation_enabled_AtStartup
(
)
;
}
void
gfxPlatform
:
:
DisableBufferRotation
(
)
{
MutexAutoLock
autoLock
(
*
gGfxPlatformPrefsLock
)
;
sBufferRotationCheckPref
=
false
;
}
bool
gfxPlatform
:
:
UsesOffMainThreadCompositing
(
)
{
if
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_GPU
)
{
return
true
;
}
static
bool
firstTime
=
true
;
static
bool
result
=
false
;
if
(
firstTime
)
{
MOZ_ASSERT
(
sLayersAccelerationPrefsInitialized
)
;
result
=
gfxVars
:
:
BrowserTabsRemoteAutostart
(
)
|
|
!
StaticPrefs
:
:
layers_offmainthreadcomposition_force_disabled_AtStartup
(
)
;
#
if
defined
(
MOZ_WIDGET_GTK
)
result
|
=
StaticPrefs
:
:
layers_acceleration_force_enabled_AtStartup_DoNotUseDirectly
(
)
;
#
endif
firstTime
=
false
;
}
return
result
;
}
bool
gfxPlatform
:
:
UsesTiling
(
)
const
{
bool
usesSkia
=
GetDefaultContentBackend
(
)
=
=
BackendType
:
:
SKIA
;
bool
usesPOMTP
=
XRE_IsContentProcess
(
)
&
&
gfxVars
:
:
UseOMTP
(
)
&
&
(
StaticPrefs
:
:
layers_omtp_paint_workers_AtStartup
(
)
=
=
-
1
|
|
StaticPrefs
:
:
layers_omtp_paint_workers_AtStartup
(
)
>
1
)
;
return
StaticPrefs
:
:
layers_enable_tiles_AtStartup
(
)
|
|
(
StaticPrefs
:
:
layers_enable_tiles_if_skia_pomtp_AtStartup
(
)
&
&
usesSkia
&
&
usesPOMTP
)
;
}
bool
gfxPlatform
:
:
ContentUsesTiling
(
)
const
{
BackendPrefsData
data
=
GetBackendPrefs
(
)
;
BackendType
contentBackend
=
GetContentBackendPref
(
data
.
mContentBitmask
)
;
if
(
contentBackend
=
=
BackendType
:
:
NONE
)
{
contentBackend
=
data
.
mContentDefault
;
}
bool
contentUsesSkia
=
contentBackend
=
=
BackendType
:
:
SKIA
;
bool
contentUsesPOMTP
=
gfxVars
:
:
UseOMTP
(
)
&
&
(
StaticPrefs
:
:
layers_omtp_paint_workers_AtStartup
(
)
=
=
-
1
|
|
StaticPrefs
:
:
layers_omtp_paint_workers_AtStartup
(
)
>
1
)
;
return
StaticPrefs
:
:
layers_enable_tiles_AtStartup
(
)
|
|
(
StaticPrefs
:
:
layers_enable_tiles_if_skia_pomtp_AtStartup
(
)
&
&
contentUsesSkia
&
&
contentUsesPOMTP
)
;
}
already_AddRefed
<
mozilla
:
:
gfx
:
:
VsyncSource
>
gfxPlatform
:
:
CreateHardwareVsyncSource
(
)
{
RefPtr
<
mozilla
:
:
gfx
:
:
VsyncSource
>
softwareVsync
=
new
SoftwareVsyncSource
(
)
;
return
softwareVsync
.
forget
(
)
;
}
bool
gfxPlatform
:
:
IsInLayoutAsapMode
(
)
{
return
StaticPrefs
:
:
layout_frame_rate
(
)
=
=
0
;
}
bool
gfxPlatform
:
:
ForceSoftwareVsync
(
)
{
return
StaticPrefs
:
:
layout_frame_rate
(
)
>
0
|
|
recordreplay
:
:
IsRecordingOrReplaying
(
)
;
}
int
gfxPlatform
:
:
GetSoftwareVsyncRate
(
)
{
int
preferenceRate
=
StaticPrefs
:
:
layout_frame_rate
(
)
;
if
(
preferenceRate
<
=
0
)
{
return
gfxPlatform
:
:
GetDefaultFrameRate
(
)
;
}
return
preferenceRate
;
}
int
gfxPlatform
:
:
GetDefaultFrameRate
(
)
{
return
60
;
}
void
gfxPlatform
:
:
ReInitFrameRate
(
)
{
if
(
XRE_IsParentProcess
(
)
|
|
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
RefPtr
<
VsyncSource
>
oldSource
=
gPlatform
-
>
mVsyncSource
;
if
(
gfxPlatform
:
:
ForceSoftwareVsync
(
)
)
{
gPlatform
-
>
mVsyncSource
=
(
gPlatform
)
-
>
gfxPlatform
:
:
CreateHardwareVsyncSource
(
)
;
}
else
{
gPlatform
-
>
mVsyncSource
=
gPlatform
-
>
CreateHardwareVsyncSource
(
)
;
}
if
(
oldSource
)
{
oldSource
-
>
MoveListenersToNewSource
(
gPlatform
-
>
mVsyncSource
)
;
oldSource
-
>
Shutdown
(
)
;
}
}
}
void
gfxPlatform
:
:
GetAzureBackendInfo
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
)
{
aObj
.
DefineProperty
(
"
AzureCanvasBackend
(
UI
Process
)
"
GetBackendName
(
mPreferredCanvasBackend
)
)
;
aObj
.
DefineProperty
(
"
AzureFallbackCanvasBackend
(
UI
Process
)
"
GetBackendName
(
mFallbackCanvasBackend
)
)
;
aObj
.
DefineProperty
(
"
AzureContentBackend
(
UI
Process
)
"
GetBackendName
(
mContentBackend
)
)
;
BackendPrefsData
data
=
GetBackendPrefs
(
)
;
BackendType
canvasBackend
=
GetCanvasBackendPref
(
data
.
mCanvasBitmask
)
;
if
(
canvasBackend
=
=
BackendType
:
:
NONE
)
{
canvasBackend
=
data
.
mCanvasDefault
;
}
BackendType
contentBackend
=
GetContentBackendPref
(
data
.
mContentBitmask
)
;
if
(
contentBackend
=
=
BackendType
:
:
NONE
)
{
contentBackend
=
data
.
mContentDefault
;
}
aObj
.
DefineProperty
(
"
AzureCanvasBackend
"
GetBackendName
(
canvasBackend
)
)
;
aObj
.
DefineProperty
(
"
AzureContentBackend
"
GetBackendName
(
contentBackend
)
)
;
}
else
{
aObj
.
DefineProperty
(
"
AzureCanvasBackend
"
GetBackendName
(
mPreferredCanvasBackend
)
)
;
aObj
.
DefineProperty
(
"
AzureFallbackCanvasBackend
"
GetBackendName
(
mFallbackCanvasBackend
)
)
;
aObj
.
DefineProperty
(
"
AzureContentBackend
"
GetBackendName
(
mContentBackend
)
)
;
}
}
void
gfxPlatform
:
:
GetApzSupportInfo
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
if
(
!
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
)
{
return
;
}
if
(
SupportsApzWheelInput
(
)
)
{
aObj
.
DefineProperty
(
"
ApzWheelInput
"
1
)
;
}
if
(
SupportsApzTouchInput
(
)
)
{
aObj
.
DefineProperty
(
"
ApzTouchInput
"
1
)
;
}
if
(
SupportsApzDragInput
(
)
)
{
aObj
.
DefineProperty
(
"
ApzDragInput
"
1
)
;
}
if
(
SupportsApzKeyboardInput
(
)
&
&
!
StaticPrefs
:
:
accessibility_browsewithcaret
(
)
)
{
aObj
.
DefineProperty
(
"
ApzKeyboardInput
"
1
)
;
}
if
(
SupportsApzAutoscrolling
(
)
)
{
aObj
.
DefineProperty
(
"
ApzAutoscrollInput
"
1
)
;
}
}
void
gfxPlatform
:
:
GetTilesSupportInfo
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
if
(
!
StaticPrefs
:
:
layers_enable_tiles_AtStartup
(
)
)
{
return
;
}
IntSize
tileSize
=
gfxVars
:
:
TileSize
(
)
;
aObj
.
DefineProperty
(
"
TileHeight
"
tileSize
.
height
)
;
aObj
.
DefineProperty
(
"
TileWidth
"
tileSize
.
width
)
;
}
void
gfxPlatform
:
:
GetFrameStats
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
uint32_t
i
=
0
;
for
(
FrameStats
&
f
:
mFrameStats
)
{
nsPrintfCString
name
(
"
Slow
Frame
#
%
02u
"
+
+
i
)
;
nsPrintfCString
value
(
"
Frame
%
"
PRIu64
"
(
%
s
)
CONTENT_FRAME_TIME
%
d
-
Transaction
start
%
f
main
-
thread
time
"
"
%
f
full
paint
time
%
f
Skipped
composites
%
u
Composite
start
%
f
"
"
Resource
upload
time
%
f
GPU
cache
upload
time
%
f
Render
time
%
f
"
"
Composite
time
%
f
"
f
.
id
(
)
.
mId
f
.
url
(
)
.
get
(
)
f
.
contentFrameTime
(
)
(
f
.
transactionStart
(
)
-
f
.
refreshStart
(
)
)
.
ToMilliseconds
(
)
(
f
.
fwdTime
(
)
-
f
.
transactionStart
(
)
)
.
ToMilliseconds
(
)
f
.
sceneBuiltTime
(
)
?
(
f
.
sceneBuiltTime
(
)
-
f
.
transactionStart
(
)
)
.
ToMilliseconds
(
)
:
0
.
0
f
.
skippedComposites
(
)
(
f
.
compositeStart
(
)
-
f
.
refreshStart
(
)
)
.
ToMilliseconds
(
)
f
.
resourceUploadTime
(
)
f
.
gpuCacheUploadTime
(
)
(
f
.
compositeEnd
(
)
-
f
.
renderStart
(
)
)
.
ToMilliseconds
(
)
(
f
.
compositeEnd
(
)
-
f
.
compositeStart
(
)
)
.
ToMilliseconds
(
)
)
;
aObj
.
DefineProperty
(
name
.
get
(
)
value
.
get
(
)
)
;
}
}
void
gfxPlatform
:
:
GetCMSSupportInfo
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
void
*
profile
=
nullptr
;
size_t
size
=
0
;
GetCMSOutputProfileData
(
profile
size
)
;
if
(
!
profile
)
{
return
;
}
const
size_t
kMaxProfileSize
=
8192
;
if
(
size
<
kMaxProfileSize
)
{
char
*
encodedProfile
=
nullptr
;
nsresult
rv
=
Base64Encode
(
reinterpret_cast
<
char
*
>
(
profile
)
size
&
encodedProfile
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aObj
.
DefineProperty
(
"
CMSOutputProfile
"
encodedProfile
)
;
free
(
encodedProfile
)
;
}
else
{
nsPrintfCString
msg
(
"
base64
encode
failed
0x
%
08x
"
static_cast
<
uint32_t
>
(
rv
)
)
;
aObj
.
DefineProperty
(
"
CMSOutputProfile
"
msg
.
get
(
)
)
;
}
}
else
{
nsPrintfCString
msg
(
"
%
zu
bytes
too
large
"
size
)
;
aObj
.
DefineProperty
(
"
CMSOutputProfile
"
msg
.
get
(
)
)
;
}
free
(
profile
)
;
}
void
gfxPlatform
:
:
GetDisplayInfo
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
nsTArray
<
nsString
>
displayInfo
;
auto
rv
=
gfxInfo
-
>
GetDisplayInfo
(
displayInfo
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
size_t
displayCount
=
displayInfo
.
Length
(
)
;
aObj
.
DefineProperty
(
"
DisplayCount
"
displayCount
)
;
for
(
size_t
i
=
0
;
i
<
displayCount
;
i
+
+
)
{
nsPrintfCString
name
(
"
Display
%
zu
"
i
)
;
aObj
.
DefineProperty
(
name
.
get
(
)
displayInfo
[
i
]
)
;
}
}
}
class
FrameStatsComparator
{
public
:
bool
Equals
(
const
FrameStats
&
aA
const
FrameStats
&
aB
)
const
{
return
aA
.
contentFrameTime
(
)
=
=
aB
.
contentFrameTime
(
)
;
}
bool
LessThan
(
const
FrameStats
&
aA
const
FrameStats
&
aB
)
const
{
return
aA
.
contentFrameTime
(
)
>
aB
.
contentFrameTime
(
)
;
}
}
;
void
gfxPlatform
:
:
NotifyFrameStats
(
nsTArray
<
FrameStats
>
&
&
aFrameStats
)
{
if
(
!
StaticPrefs
:
:
gfx_logging_slow_frames_enabled_AtStartup
(
)
)
{
return
;
}
FrameStatsComparator
comp
;
for
(
FrameStats
&
f
:
aFrameStats
)
{
mFrameStats
.
InsertElementSorted
(
f
comp
)
;
}
if
(
mFrameStats
.
Length
(
)
>
10
)
{
mFrameStats
.
SetLength
(
10
)
;
}
}
uint32_t
gfxPlatform
:
:
TargetFrameRate
(
)
{
if
(
gPlatform
&
&
gPlatform
-
>
mVsyncSource
)
{
VsyncSource
:
:
Display
&
display
=
gPlatform
-
>
mVsyncSource
-
>
GetGlobalDisplay
(
)
;
return
round
(
1000
.
0
/
display
.
GetVsyncRate
(
)
.
ToMilliseconds
(
)
)
;
}
return
0
;
}
bool
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
{
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
&
&
!
defined
(
MOZ_WIDGET_UIKIT
)
if
(
!
BrowserTabsRemoteAutostart
(
)
)
{
return
false
;
}
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
return
true
;
#
else
return
StaticPrefs
:
:
layers_async_pan_zoom_enabled_AtStartup_DoNotUseDirectly
(
)
;
#
endif
}
bool
gfxPlatform
:
:
PerfWarnings
(
)
{
return
StaticPrefs
:
:
gfx_perf_warnings_enabled
(
)
;
}
void
gfxPlatform
:
:
GetAcceleratedCompositorBackends
(
nsTArray
<
LayersBackend
>
&
aBackends
)
{
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
OPENGL_COMPOSITING
)
)
{
aBackends
.
AppendElement
(
LayersBackend
:
:
LAYERS_OPENGL
)
;
}
else
{
static
int
tell_me_once
=
0
;
if
(
!
tell_me_once
)
{
NS_WARNING
(
"
OpenGL
-
accelerated
layers
are
not
supported
on
this
system
"
)
;
tell_me_once
=
1
;
}
#
ifdef
MOZ_WIDGET_ANDROID
MOZ_CRASH
(
"
OpenGL
-
accelerated
layers
are
a
hard
requirement
on
this
platform
.
"
"
Cannot
continue
without
support
for
them
"
)
;
#
endif
}
}
void
gfxPlatform
:
:
GetCompositorBackends
(
bool
useAcceleration
nsTArray
<
mozilla
:
:
layers
:
:
LayersBackend
>
&
aBackends
)
{
if
(
useAcceleration
)
{
GetAcceleratedCompositorBackends
(
aBackends
)
;
}
aBackends
.
AppendElement
(
LayersBackend
:
:
LAYERS_BASIC
)
;
}
void
gfxPlatform
:
:
NotifyCompositorCreated
(
LayersBackend
aBackend
)
{
if
(
mCompositorBackend
=
=
aBackend
)
{
return
;
}
if
(
mCompositorBackend
!
=
LayersBackend
:
:
LAYERS_NONE
)
{
gfxCriticalNote
<
<
"
Compositors
might
be
mixed
(
"
<
<
int
(
mCompositorBackend
)
<
<
"
"
<
<
int
(
aBackend
)
<
<
"
)
"
;
}
mCompositorBackend
=
aBackend
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
gfxPlatform
:
:
NotifyCompositorCreated
"
[
]
{
if
(
nsCOMPtr
<
nsIObserverService
>
obsvc
=
services
:
:
GetObserverService
(
)
)
{
obsvc
-
>
NotifyObservers
(
nullptr
"
compositor
:
created
"
nullptr
)
;
}
}
)
)
;
}
void
gfxPlatform
:
:
NotifyGPUProcessDisabled
(
)
{
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER
)
)
{
gfxConfig
:
:
GetFeature
(
Feature
:
:
WEBRENDER
)
.
ForceDisable
(
FeatureStatus
:
:
Unavailable
"
GPU
Process
is
disabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_GPU_PROCESS_DISABLED
"
)
)
;
gfxVars
:
:
SetUseWebRender
(
false
)
;
}
gfxVars
:
:
SetRemoteCanvasEnabled
(
false
)
;
}
void
gfxPlatform
:
:
FetchAndImportContentDeviceData
(
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
if
(
gContentDeviceInitData
)
{
ImportContentDeviceData
(
*
gContentDeviceInitData
)
;
return
;
}
mozilla
:
:
dom
:
:
ContentChild
*
cc
=
mozilla
:
:
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
mozilla
:
:
gfx
:
:
ContentDeviceData
data
;
cc
-
>
SendGetGraphicsDeviceInitData
(
&
data
)
;
ImportContentDeviceData
(
data
)
;
}
void
gfxPlatform
:
:
ImportContentDeviceData
(
const
mozilla
:
:
gfx
:
:
ContentDeviceData
&
aData
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
const
DevicePrefs
&
prefs
=
aData
.
prefs
(
)
;
gfxConfig
:
:
Inherit
(
Feature
:
:
HW_COMPOSITING
prefs
.
hwCompositing
(
)
)
;
gfxConfig
:
:
Inherit
(
Feature
:
:
OPENGL_COMPOSITING
prefs
.
oglCompositing
(
)
)
;
}
void
gfxPlatform
:
:
BuildContentDeviceData
(
mozilla
:
:
gfx
:
:
ContentDeviceData
*
aOut
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
GPUProcessManager
:
:
Get
(
)
-
>
EnsureGPUReady
(
)
;
aOut
-
>
prefs
(
)
.
hwCompositing
(
)
=
gfxConfig
:
:
GetValue
(
Feature
:
:
HW_COMPOSITING
)
;
aOut
-
>
prefs
(
)
.
oglCompositing
(
)
=
gfxConfig
:
:
GetValue
(
Feature
:
:
OPENGL_COMPOSITING
)
;
}
void
gfxPlatform
:
:
ImportGPUDeviceData
(
const
mozilla
:
:
gfx
:
:
GPUDeviceData
&
aData
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
gfxConfig
:
:
ImportChange
(
Feature
:
:
OPENGL_COMPOSITING
aData
.
oglCompositing
(
)
)
;
gfxConfig
:
:
ImportChange
(
Feature
:
:
ADVANCED_LAYERS
aData
.
advancedLayers
(
)
)
;
}
bool
gfxPlatform
:
:
SupportsApzTouchInput
(
)
const
{
return
dom
:
:
TouchEvent
:
:
PrefEnabled
(
nullptr
)
;
}
bool
gfxPlatform
:
:
SupportsApzDragInput
(
)
const
{
return
StaticPrefs
:
:
apz_drag_enabled
(
)
;
}
bool
gfxPlatform
:
:
SupportsApzKeyboardInput
(
)
const
{
return
StaticPrefs
:
:
apz_keyboard_enabled_AtStartup
(
)
;
}
bool
gfxPlatform
:
:
SupportsApzAutoscrolling
(
)
const
{
return
StaticPrefs
:
:
apz_autoscroll_enabled
(
)
;
}
void
gfxPlatform
:
:
InitOpenGLConfig
(
)
{
#
ifdef
XP_WIN
if
(
!
Preferences
:
:
GetBool
(
"
layers
.
prefer
-
opengl
"
)
)
{
return
;
}
#
endif
FeatureState
&
openGLFeature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
OPENGL_COMPOSITING
)
;
if
(
!
gfxConfig
:
:
IsEnabled
(
Feature
:
:
HW_COMPOSITING
)
)
{
openGLFeature
.
DisableByDefault
(
FeatureStatus
:
:
Unavailable
"
Hardware
compositing
is
disabled
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_OPENGL_NEED_HWCOMP
"
)
)
;
return
;
}
#
ifdef
XP_WIN
openGLFeature
.
SetDefaultFromPref
(
StaticPrefs
:
:
GetPrefName_layers_prefer_opengl
(
)
true
StaticPrefs
:
:
GetPrefDefault_layers_prefer_opengl
(
)
)
;
#
else
openGLFeature
.
EnableByDefault
(
)
;
#
endif
if
(
StaticPrefs
:
:
layers_acceleration_force_enabled_AtStartup_DoNotUseDirectly
(
)
)
{
openGLFeature
.
UserForceEnable
(
"
Force
-
enabled
by
pref
"
)
;
return
;
}
nsCString
message
;
nsCString
failureId
;
if
(
!
IsGfxInfoStatusOkay
(
nsIGfxInfo
:
:
FEATURE_OPENGL_LAYERS
&
message
failureId
)
)
{
openGLFeature
.
Disable
(
FeatureStatus
:
:
Blacklisted
message
.
get
(
)
failureId
)
;
}
}
bool
gfxPlatform
:
:
IsGfxInfoStatusOkay
(
int32_t
aFeature
nsCString
*
aOutMessage
nsCString
&
aFailureId
)
{
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
if
(
!
gfxInfo
)
{
return
true
;
}
int32_t
status
;
if
(
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
aFeature
aFailureId
&
status
)
)
&
&
status
!
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
)
{
aOutMessage
-
>
AssignLiteral
(
"
#
BLOCKLIST_
"
)
;
aOutMessage
-
>
AppendASCII
(
aFailureId
.
get
(
)
)
;
return
false
;
}
return
true
;
}
