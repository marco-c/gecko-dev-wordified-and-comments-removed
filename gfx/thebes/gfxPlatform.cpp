#
include
"
mozilla
/
layers
/
AsyncTransactionTracker
.
h
"
#
include
"
mozilla
/
layers
/
CompositorChild
.
h
"
#
include
"
mozilla
/
layers
/
CompositorParent
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
SharedBufferManagerChild
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
prprf
.
h
"
#
include
"
gfxCrashReporterUtils
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
gfxEnv
.
h
"
#
include
"
gfxTextRun
.
h
"
#
ifdef
XP_WIN
#
include
<
process
.
h
>
#
define
getpid
_getpid
#
else
#
include
<
unistd
.
h
>
#
endif
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
gfxWindowsPlatform
.
h
"
#
elif
defined
(
XP_MACOSX
)
#
include
"
gfxPlatformMac
.
h
"
#
include
"
gfxQuartzSurface
.
h
"
#
elif
defined
(
MOZ_WIDGET_GTK
)
#
include
"
gfxPlatformGtk
.
h
"
#
elif
defined
(
MOZ_WIDGET_QT
)
#
include
"
gfxQtPlatform
.
h
"
#
elif
defined
(
ANDROID
)
#
include
"
gfxAndroidPlatform
.
h
"
#
endif
#
ifdef
XP_WIN
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
endif
#
include
"
nsGkAtoms
.
h
"
#
include
"
gfxPlatformFontList
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxImageSurface
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
harfbuzz
/
hb
.
h
"
#
include
"
gfxGraphiteShaper
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxGradientCache
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
nsUnicodeRange
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsILocaleService
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
ifdef
MOZ_CRASHREPORTER
#
include
"
nsExceptionHandler
.
h
"
#
endif
#
include
"
nsWeakReference
.
h
"
#
include
"
cairo
.
h
"
#
include
"
qcms
.
h
"
#
include
"
imgITools
.
h
"
#
include
"
plstr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
GLContextProvider
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
if
defined
(
MOZ_WIDGET_GTK
)
#
include
"
gfxPlatformGtk
.
h
"
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
TexturePoolOGL
.
h
"
#
endif
#
ifdef
MOZ_WIDGET_GONK
#
include
"
mozilla
/
layers
/
GrallocTextureHost
.
h
"
#
endif
#
include
"
mozilla
/
Hal
.
h
"
#
ifdef
USE_SKIA
#
ifdef
__GNUC__
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wshadow
"
#
endif
#
include
"
skia
/
include
/
core
/
SkGraphics
.
h
"
#
ifdef
USE_SKIA_GPU
#
include
"
skia
/
include
/
gpu
/
GrContext
.
h
"
#
include
"
skia
/
include
/
gpu
/
gl
/
GrGLInterface
.
h
"
#
include
"
SkiaGLGlue
.
h
"
#
endif
#
ifdef
__GNUC__
#
pragma
GCC
diagnostic
pop
/
/
-
Wshadow
#
endif
#
endif
#
if
!
defined
(
USE_SKIA
)
|
|
!
defined
(
USE_SKIA_GPU
)
class
mozilla
:
:
gl
:
:
SkiaGLGlue
:
public
GenericAtomicRefCounted
{
}
;
#
endif
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsIGfxInfo
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
VsyncSource
.
h
"
#
include
"
SoftwareVsyncSource
.
h
"
#
include
"
nscore
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
gfxVR
.
h
"
#
include
"
VRManagerChild
.
h
"
namespace
mozilla
{
namespace
layers
{
#
ifdef
MOZ_WIDGET_GONK
void
InitGralloc
(
)
;
#
endif
void
ShutdownTileCache
(
)
;
}
}
using
namespace
mozilla
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
gl
;
gfxPlatform
*
gPlatform
=
nullptr
;
static
bool
gEverInitialized
=
false
;
static
Mutex
*
gGfxPlatformPrefsLock
=
nullptr
;
static
qcms_profile
*
gCMSOutputProfile
=
nullptr
;
static
qcms_profile
*
gCMSsRGBProfile
=
nullptr
;
static
qcms_transform
*
gCMSRGBTransform
=
nullptr
;
static
qcms_transform
*
gCMSInverseRGBTransform
=
nullptr
;
static
qcms_transform
*
gCMSRGBATransform
=
nullptr
;
static
bool
gCMSInitialized
=
false
;
static
eCMSMode
gCMSMode
=
eCMSMode_Off
;
static
void
ShutdownCMS
(
)
;
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
SourceSurfaceCairo
.
h
"
using
namespace
mozilla
:
:
gfx
;
void
InitLayersAccelerationPrefs
(
)
;
class
SRGBOverrideObserver
final
:
public
nsIObserver
public
nsSupportsWeakReference
{
~
SRGBOverrideObserver
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
}
;
class
CrashStatsLogForwarder
:
public
mozilla
:
:
gfx
:
:
LogForwarder
{
public
:
explicit
CrashStatsLogForwarder
(
const
char
*
aKey
)
;
virtual
void
Log
(
const
std
:
:
string
&
aString
)
override
;
virtual
void
CrashAction
(
LogReason
aReason
)
override
;
virtual
LoggingRecord
LoggingRecordCopy
(
)
override
;
void
SetCircularBufferSize
(
uint32_t
aCapacity
)
;
private
:
bool
UpdateStringsVector
(
const
std
:
:
string
&
aString
)
;
void
UpdateCrashReport
(
)
;
private
:
LoggingRecord
mBuffer
;
nsCString
mCrashCriticalKey
;
uint32_t
mMaxCapacity
;
int32_t
mIndex
;
Mutex
mMutex
;
}
;
CrashStatsLogForwarder
:
:
CrashStatsLogForwarder
(
const
char
*
aKey
)
:
mBuffer
(
)
mCrashCriticalKey
(
aKey
)
mMaxCapacity
(
0
)
mIndex
(
-
1
)
mMutex
(
"
CrashStatsLogForwarder
"
)
{
}
void
CrashStatsLogForwarder
:
:
SetCircularBufferSize
(
uint32_t
aCapacity
)
{
MutexAutoLock
lock
(
mMutex
)
;
mMaxCapacity
=
aCapacity
;
mBuffer
.
reserve
(
static_cast
<
size_t
>
(
aCapacity
)
)
;
}
LoggingRecord
CrashStatsLogForwarder
:
:
LoggingRecordCopy
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mBuffer
;
}
bool
CrashStatsLogForwarder
:
:
UpdateStringsVector
(
const
std
:
:
string
&
aString
)
{
if
(
mMaxCapacity
<
2
)
{
return
false
;
}
mIndex
+
=
1
;
MOZ_ASSERT
(
mIndex
>
=
0
)
;
int32_t
index
=
mIndex
?
(
mIndex
-
1
)
%
(
mMaxCapacity
-
1
)
+
1
:
0
;
MOZ_ASSERT
(
index
>
=
0
&
&
index
<
(
int32_t
)
mMaxCapacity
)
;
MOZ_ASSERT
(
index
<
=
mIndex
&
&
index
<
=
(
int32_t
)
mBuffer
.
size
(
)
)
;
bool
ignored
;
double
tStamp
=
(
TimeStamp
:
:
NowLoRes
(
)
-
TimeStamp
:
:
ProcessCreation
(
ignored
)
)
.
ToSecondsSigDigits
(
)
;
LoggingRecordEntry
newEntry
(
mIndex
aString
tStamp
)
;
if
(
index
>
=
static_cast
<
int32_t
>
(
mBuffer
.
size
(
)
)
)
{
mBuffer
.
push_back
(
newEntry
)
;
}
else
{
mBuffer
[
index
]
=
newEntry
;
}
return
true
;
}
void
CrashStatsLogForwarder
:
:
UpdateCrashReport
(
)
{
std
:
:
stringstream
message
;
for
(
LoggingRecord
:
:
iterator
it
=
mBuffer
.
begin
(
)
;
it
!
=
mBuffer
.
end
(
)
;
+
+
it
)
{
message
<
<
"
|
[
"
<
<
Get
<
0
>
(
*
it
)
<
<
"
]
"
<
<
Get
<
1
>
(
*
it
)
<
<
"
(
t
=
"
<
<
Get
<
2
>
(
*
it
)
<
<
"
)
"
;
}
#
ifdef
MOZ_CRASHREPORTER
nsCString
reportString
(
message
.
str
(
)
.
c_str
(
)
)
;
nsresult
annotated
=
CrashReporter
:
:
AnnotateCrashReport
(
mCrashCriticalKey
reportString
)
;
#
else
nsresult
annotated
=
NS_ERROR_NOT_IMPLEMENTED
;
#
endif
if
(
annotated
!
=
NS_OK
)
{
printf
(
"
Crash
Annotation
%
s
:
%
s
"
mCrashCriticalKey
.
get
(
)
message
.
str
(
)
.
c_str
(
)
)
;
}
}
void
CrashStatsLogForwarder
:
:
Log
(
const
std
:
:
string
&
aString
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
UpdateStringsVector
(
aString
)
)
{
UpdateCrashReport
(
)
;
}
}
class
CrashTelemetryEvent
:
public
nsRunnable
{
virtual
~
CrashTelemetryEvent
(
)
{
}
NS_DECL_ISUPPORTS_INHERITED
explicit
CrashTelemetryEvent
(
uint32_t
aReason
)
:
mReason
(
aReason
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GFX_CRASH
mReason
)
;
return
NS_OK
;
}
protected
:
uint32_t
mReason
;
}
;
NS_IMPL_ISUPPORTS_INHERITED0
(
CrashTelemetryEvent
nsRunnable
)
;
void
CrashStatsLogForwarder
:
:
CrashAction
(
LogReason
aReason
)
{
#
ifndef
RELEASE_BUILD
static
bool
useTelemetry
=
gfxEnv
:
:
GfxDevCrashTelemetry
(
)
;
#
else
static
bool
useTelemetry
=
!
gfxEnv
:
:
GfxDevCrashMozCrash
(
)
;
#
endif
if
(
useTelemetry
)
{
if
(
NS_IsMainThread
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GFX_CRASH
(
uint32_t
)
aReason
)
;
}
else
{
nsCOMPtr
<
nsIRunnable
>
r1
=
new
CrashTelemetryEvent
(
(
uint32_t
)
aReason
)
;
NS_DispatchToMainThread
(
r1
)
;
}
}
else
{
MOZ_CRASH
(
"
GFX_CRASH
"
)
;
}
}
NS_IMPL_ISUPPORTS
(
SRGBOverrideObserver
nsIObserver
nsISupportsWeakReference
)
#
define
GFX_DOWNLOADABLE_FONTS_ENABLED
"
gfx
.
downloadable_fonts
.
enabled
"
#
define
GFX_PREF_FALLBACK_USE_CMAPS
"
gfx
.
font_rendering
.
fallback
.
always_use_cmaps
"
#
define
GFX_PREF_OPENTYPE_SVG
"
gfx
.
font_rendering
.
opentype_svg
.
enabled
"
#
define
GFX_PREF_WORD_CACHE_CHARLIMIT
"
gfx
.
font_rendering
.
wordcache
.
charlimit
"
#
define
GFX_PREF_WORD_CACHE_MAXENTRIES
"
gfx
.
font_rendering
.
wordcache
.
maxentries
"
#
define
GFX_PREF_GRAPHITE_SHAPING
"
gfx
.
font_rendering
.
graphite
.
enabled
"
#
define
BIDI_NUMERAL_PREF
"
bidi
.
numeral
"
#
define
GFX_PREF_CMS_FORCE_SRGB
"
gfx
.
color_management
.
force_srgb
"
NS_IMETHODIMP
SRGBOverrideObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
someData
)
{
NS_ASSERTION
(
NS_strcmp
(
someData
MOZ_UTF16
(
GFX_PREF_CMS_FORCE_SRGB
)
)
=
=
0
"
Restarting
CMS
on
wrong
pref
!
"
)
;
ShutdownCMS
(
)
;
gfxPlatform
:
:
CreateCMSOutputProfile
(
)
;
return
NS_OK
;
}
static
const
char
*
kObservedPrefs
[
]
=
{
"
gfx
.
downloadable_fonts
.
"
"
gfx
.
font_rendering
.
"
BIDI_NUMERAL_PREF
nullptr
}
;
class
FontPrefsObserver
final
:
public
nsIObserver
{
~
FontPrefsObserver
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
}
;
NS_IMPL_ISUPPORTS
(
FontPrefsObserver
nsIObserver
)
NS_IMETHODIMP
FontPrefsObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
someData
)
{
if
(
!
someData
)
{
NS_ERROR
(
"
font
pref
observer
code
broken
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
NS_ASSERTION
(
gfxPlatform
:
:
GetPlatform
(
)
"
the
singleton
instance
has
gone
"
)
;
gfxPlatform
:
:
GetPlatform
(
)
-
>
FontsPrefsChanged
(
NS_ConvertUTF16toUTF8
(
someData
)
.
get
(
)
)
;
return
NS_OK
;
}
class
MemoryPressureObserver
final
:
public
nsIObserver
{
~
MemoryPressureObserver
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
}
;
NS_IMPL_ISUPPORTS
(
MemoryPressureObserver
nsIObserver
)
NS_IMETHODIMP
MemoryPressureObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
someData
)
{
NS_ASSERTION
(
strcmp
(
aTopic
"
memory
-
pressure
"
)
=
=
0
"
unexpected
event
topic
"
)
;
Factory
:
:
PurgeAllCaches
(
)
;
gfxGradientCache
:
:
PurgeAllCaches
(
)
;
gfxPlatform
:
:
GetPlatform
(
)
-
>
PurgeSkiaCache
(
)
;
return
NS_OK
;
}
gfxPlatform
:
:
gfxPlatform
(
)
:
mTileWidth
(
-
1
)
mTileHeight
(
-
1
)
mAzureCanvasBackendCollector
(
this
&
gfxPlatform
:
:
GetAzureBackendInfo
)
mApzSupportCollector
(
this
&
gfxPlatform
:
:
GetApzSupportInfo
)
mCompositorBackend
(
layers
:
:
LayersBackend
:
:
LAYERS_NONE
)
mScreenDepth
(
0
)
{
mAllowDownloadableFonts
=
UNINITIALIZED_VALUE
;
mFallbackUsesCmaps
=
UNINITIALIZED_VALUE
;
mWordCacheCharLimit
=
UNINITIALIZED_VALUE
;
mWordCacheMaxEntries
=
UNINITIALIZED_VALUE
;
mGraphiteShapingEnabled
=
UNINITIALIZED_VALUE
;
mOpenTypeSVGEnabled
=
UNINITIALIZED_VALUE
;
mBidiNumeralOption
=
UNINITIALIZED_VALUE
;
mSkiaGlue
=
nullptr
;
uint32_t
canvasMask
=
BackendTypeBit
(
BackendType
:
:
CAIRO
)
|
BackendTypeBit
(
BackendType
:
:
SKIA
)
;
uint32_t
contentMask
=
BackendTypeBit
(
BackendType
:
:
CAIRO
)
;
InitBackendPrefs
(
canvasMask
BackendType
:
:
CAIRO
contentMask
BackendType
:
:
CAIRO
)
;
mTotalSystemMemory
=
mozilla
:
:
hal
:
:
GetTotalSystemMemory
(
)
;
VRManager
:
:
ManagerInit
(
)
;
}
gfxPlatform
*
gfxPlatform
:
:
GetPlatform
(
)
{
if
(
!
gPlatform
)
{
Init
(
)
;
}
return
gPlatform
;
}
bool
gfxPlatform
:
:
Initialized
(
)
{
return
!
!
gPlatform
;
}
void
RecordingPrefChanged
(
const
char
*
aPrefName
void
*
aClosure
)
{
if
(
Preferences
:
:
GetBool
(
"
gfx
.
2d
.
recording
"
false
)
)
{
nsAutoCString
fileName
;
nsAdoptingString
prefFileName
=
Preferences
:
:
GetString
(
"
gfx
.
2d
.
recordingfile
"
)
;
if
(
prefFileName
)
{
fileName
.
Append
(
NS_ConvertUTF16toUTF8
(
prefFileName
)
)
;
}
else
{
nsCOMPtr
<
nsIFile
>
tmpFile
;
if
(
NS_FAILED
(
NS_GetSpecialDirectory
(
NS_OS_TEMP_DIR
getter_AddRefs
(
tmpFile
)
)
)
)
{
return
;
}
fileName
.
AppendPrintf
(
"
moz2drec_
%
i_
%
i
.
aer
"
XRE_GetProcessType
(
)
getpid
(
)
)
;
nsresult
rv
=
tmpFile
-
>
AppendNative
(
fileName
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
rv
=
tmpFile
-
>
GetNativePath
(
fileName
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
}
gPlatform
-
>
mRecorder
=
Factory
:
:
CreateEventRecorderForFile
(
fileName
.
BeginReading
(
)
)
;
printf_stderr
(
"
Recording
to
%
s
\
n
"
fileName
.
get
(
)
)
;
Factory
:
:
SetGlobalEventRecorder
(
gPlatform
-
>
mRecorder
)
;
}
else
{
Factory
:
:
SetGlobalEventRecorder
(
nullptr
)
;
}
}
void
gfxPlatform
:
:
Init
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
gEverInitialized
)
{
NS_RUNTIMEABORT
(
"
Already
started
?
?
?
"
)
;
}
gEverInitialized
=
true
;
gfxPrefs
:
:
GetSingleton
(
)
;
auto
fwd
=
new
CrashStatsLogForwarder
(
"
GraphicsCriticalError
"
)
;
fwd
-
>
SetCircularBufferSize
(
gfxPrefs
:
:
GfxLoggingCrashLength
(
)
)
;
{
nsAutoCString
forcedPrefs
;
forcedPrefs
.
AppendPrintf
(
"
FP
(
D
%
d
%
d
%
d
"
gfxPrefs
:
:
Direct2DDisabled
(
)
gfxPrefs
:
:
Direct2DForceEnabled
(
)
gfxPrefs
:
:
DirectWriteFontRenderingForceEnabled
(
)
)
;
forcedPrefs
.
AppendPrintf
(
"
-
L
%
d
%
d
%
d
%
d
%
d
%
d
"
gfxPrefs
:
:
LayersAMDSwitchableGfxEnabled
(
)
gfxPrefs
:
:
LayersAccelerationDisabled
(
)
gfxPrefs
:
:
LayersAccelerationForceEnabled
(
)
gfxPrefs
:
:
LayersD3D11DisableWARP
(
)
gfxPrefs
:
:
LayersD3D11ForceWARP
(
)
gfxPrefs
:
:
LayersOffMainThreadCompositionForceEnabled
(
)
)
;
forcedPrefs
.
AppendPrintf
(
"
-
W
%
d
%
d
%
d
%
d
%
d
%
d
%
d
%
d
"
gfxPrefs
:
:
WebGLANGLEForceD3D11
(
)
gfxPrefs
:
:
WebGLANGLEForceWARP
(
)
gfxPrefs
:
:
WebGLDisabled
(
)
gfxPrefs
:
:
WebGLDisableANGLE
(
)
gfxPrefs
:
:
WebGLDXGLEnabled
(
)
gfxPrefs
:
:
WebGLForceEnabled
(
)
gfxPrefs
:
:
WebGLForceLayersReadback
(
)
gfxPrefs
:
:
WebGLForceMSAA
(
)
)
;
forcedPrefs
.
AppendPrintf
(
"
-
T
%
d
%
d
%
d
%
d
)
"
gfxPrefs
:
:
AndroidRGB16Force
(
)
gfxPrefs
:
:
CanvasAzureAccelerated
(
)
gfxPrefs
:
:
DisableGralloc
(
)
gfxPrefs
:
:
ForceShmemTiles
(
)
)
;
ScopedGfxFeatureReporter
:
:
AppNote
(
forcedPrefs
)
;
}
mozilla
:
:
gfx
:
:
Config
cfg
;
cfg
.
mLogForwarder
=
fwd
;
cfg
.
mMaxTextureSize
=
gfxPrefs
:
:
MaxTextureSize
(
)
;
cfg
.
mMaxAllocSize
=
gfxPrefs
:
:
MaxAllocSize
(
)
;
gfx
:
:
Factory
:
:
Init
(
cfg
)
;
gGfxPlatformPrefsLock
=
new
Mutex
(
"
gfxPlatform
:
:
gGfxPlatformPrefsLock
"
)
;
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
;
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
#
if
defined
(
XP_WIN
)
gPlatform
=
new
gfxWindowsPlatform
;
#
elif
defined
(
XP_MACOSX
)
gPlatform
=
new
gfxPlatformMac
;
#
elif
defined
(
MOZ_WIDGET_GTK
)
gPlatform
=
new
gfxPlatformGtk
;
#
elif
defined
(
MOZ_WIDGET_QT
)
gPlatform
=
new
gfxQtPlatform
;
#
elif
defined
(
ANDROID
)
gPlatform
=
new
gfxAndroidPlatform
;
#
else
#
error
"
No
gfxPlatform
implementation
available
"
#
endif
#
ifdef
USE_SKIA
SkGraphics
:
:
Init
(
)
;
#
endif
#
ifdef
MOZ_GL_DEBUG
GLContext
:
:
StaticInit
(
)
;
#
endif
InitLayersAccelerationPrefs
(
)
;
InitLayersIPC
(
)
;
gPlatform
-
>
PopulateScreenInfo
(
)
;
gPlatform
-
>
ComputeTileSize
(
)
;
nsresult
rv
;
bool
usePlatformFontList
=
true
;
#
if
defined
(
MOZ_WIDGET_GTK
)
usePlatformFontList
=
gfxPlatformGtk
:
:
UseFcFontList
(
)
;
#
elif
defined
(
MOZ_WIDGET_QT
)
usePlatformFontList
=
false
;
#
endif
if
(
usePlatformFontList
)
{
rv
=
gfxPlatformFontList
:
:
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_RUNTIMEABORT
(
"
Could
not
initialize
gfxPlatformFontList
"
)
;
}
}
gPlatform
-
>
mScreenReferenceSurface
=
gPlatform
-
>
CreateOffscreenSurface
(
IntSize
(
1
1
)
SurfaceFormat
:
:
A8R8G8B8_UINT32
)
;
if
(
!
gPlatform
-
>
mScreenReferenceSurface
)
{
NS_RUNTIMEABORT
(
"
Could
not
initialize
mScreenReferenceSurface
"
)
;
}
gPlatform
-
>
mScreenReferenceDrawTarget
=
gPlatform
-
>
CreateOffscreenContentDrawTarget
(
IntSize
(
1
1
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
gPlatform
-
>
mScreenReferenceDrawTarget
)
{
NS_RUNTIMEABORT
(
"
Could
not
initialize
mScreenReferenceDrawTarget
"
)
;
}
rv
=
gfxFontCache
:
:
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_RUNTIMEABORT
(
"
Could
not
initialize
gfxFontCache
"
)
;
}
gPlatform
-
>
mSRGBOverrideObserver
=
new
SRGBOverrideObserver
(
)
;
Preferences
:
:
AddWeakObserver
(
gPlatform
-
>
mSRGBOverrideObserver
GFX_PREF_CMS_FORCE_SRGB
)
;
gPlatform
-
>
mFontPrefsObserver
=
new
FontPrefsObserver
(
)
;
Preferences
:
:
AddStrongObservers
(
gPlatform
-
>
mFontPrefsObserver
kObservedPrefs
)
;
GLContext
:
:
PlatformStartup
(
)
;
#
ifdef
MOZ_WIDGET_ANDROID
TexturePoolOGL
:
:
Init
(
)
;
#
endif
#
ifdef
MOZ_WIDGET_GONK
mozilla
:
:
layers
:
:
InitGralloc
(
)
;
#
endif
Preferences
:
:
RegisterCallbackAndCall
(
RecordingPrefChanged
"
gfx
.
2d
.
recording
"
nullptr
)
;
CreateCMSOutputProfile
(
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
gPlatform
-
>
mMemoryPressureObserver
=
new
MemoryPressureObserver
(
)
;
obs
-
>
AddObserver
(
gPlatform
-
>
mMemoryPressureObserver
"
memory
-
pressure
"
false
)
;
}
nsCOMPtr
<
imgITools
>
imgTools
=
do_GetService
(
"
mozilla
.
org
/
image
/
tools
;
1
"
)
;
if
(
!
imgTools
)
{
NS_RUNTIMEABORT
(
"
Could
not
initialize
ImageLib
"
)
;
}
RegisterStrongMemoryReporter
(
new
GfxMemoryImageReporter
(
)
)
;
if
(
XRE_IsParentProcess
(
)
)
{
if
(
gfxPlatform
:
:
ForceSoftwareVsync
(
)
)
{
gPlatform
-
>
mVsyncSource
=
(
gPlatform
)
-
>
gfxPlatform
:
:
CreateHardwareVsyncSource
(
)
;
}
else
{
gPlatform
-
>
mVsyncSource
=
gPlatform
-
>
CreateHardwareVsyncSource
(
)
;
}
}
}
static
bool
sLayersIPCIsUp
=
false
;
void
gfxPlatform
:
:
Shutdown
(
)
{
if
(
!
gPlatform
)
{
return
;
}
MOZ_ASSERT
(
!
sLayersIPCIsUp
)
;
gfxFontCache
:
:
Shutdown
(
)
;
gfxFontGroup
:
:
Shutdown
(
)
;
gfxGradientCache
:
:
Shutdown
(
)
;
gfxAlphaBoxBlur
:
:
ShutdownBlurCache
(
)
;
gfxGraphiteShaper
:
:
Shutdown
(
)
;
gfxPlatformFontList
:
:
Shutdown
(
)
;
ShutdownTileCache
(
)
;
ShutdownCMS
(
)
;
if
(
gPlatform
)
{
NS_ASSERTION
(
gPlatform
-
>
mSRGBOverrideObserver
"
mSRGBOverrideObserver
has
alreay
gone
"
)
;
Preferences
:
:
RemoveObserver
(
gPlatform
-
>
mSRGBOverrideObserver
GFX_PREF_CMS_FORCE_SRGB
)
;
gPlatform
-
>
mSRGBOverrideObserver
=
nullptr
;
NS_ASSERTION
(
gPlatform
-
>
mFontPrefsObserver
"
mFontPrefsObserver
has
alreay
gone
"
)
;
Preferences
:
:
RemoveObservers
(
gPlatform
-
>
mFontPrefsObserver
kObservedPrefs
)
;
gPlatform
-
>
mFontPrefsObserver
=
nullptr
;
NS_ASSERTION
(
gPlatform
-
>
mMemoryPressureObserver
"
mMemoryPressureObserver
has
already
gone
"
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
gPlatform
-
>
mMemoryPressureObserver
"
memory
-
pressure
"
)
;
}
gPlatform
-
>
mMemoryPressureObserver
=
nullptr
;
gPlatform
-
>
mSkiaGlue
=
nullptr
;
gPlatform
-
>
mVsyncSource
=
nullptr
;
}
#
ifdef
MOZ_WIDGET_ANDROID
TexturePoolOGL
:
:
Shutdown
(
)
;
#
endif
GLContextProvider
:
:
Shutdown
(
)
;
#
if
defined
(
XP_WIN
)
GLContextProviderEGL
:
:
Shutdown
(
)
;
#
endif
delete
mozilla
:
:
gfx
:
:
Factory
:
:
GetLogForwarder
(
)
;
mozilla
:
:
gfx
:
:
Factory
:
:
SetLogForwarder
(
nullptr
)
;
gfx
:
:
Factory
:
:
ShutDown
(
)
;
delete
gGfxPlatformPrefsLock
;
gfxPrefs
:
:
DestroySingleton
(
)
;
gfxFont
:
:
DestroySingletons
(
)
;
delete
gPlatform
;
gPlatform
=
nullptr
;
}
void
gfxPlatform
:
:
InitLayersIPC
(
)
{
if
(
sLayersIPCIsUp
)
{
return
;
}
sLayersIPCIsUp
=
true
;
AsyncTransactionTrackersHolder
:
:
Initialize
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
mozilla
:
:
layers
:
:
CompositorParent
:
:
StartUp
(
)
;
#
ifdef
MOZ_WIDGET_GONK
SharedBufferManagerChild
:
:
StartUp
(
)
;
#
endif
mozilla
:
:
layers
:
:
ImageBridgeChild
:
:
StartUp
(
)
;
gfx
:
:
VRManagerChild
:
:
StartUpSameProcess
(
)
;
}
}
void
gfxPlatform
:
:
ShutdownLayersIPC
(
)
{
if
(
!
sLayersIPCIsUp
)
{
return
;
}
sLayersIPCIsUp
=
false
;
if
(
XRE_IsParentProcess
(
)
)
{
gfx
:
:
VRManagerChild
:
:
ShutDown
(
)
;
layers
:
:
ImageBridgeChild
:
:
ShutDown
(
)
;
#
ifdef
MOZ_WIDGET_GONK
layers
:
:
SharedBufferManagerChild
:
:
ShutDown
(
)
;
#
endif
layers
:
:
CompositorParent
:
:
ShutDown
(
)
;
}
else
if
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Content
)
{
gfx
:
:
VRManagerChild
:
:
ShutDown
(
)
;
}
}
gfxPlatform
:
:
~
gfxPlatform
(
)
{
mScreenReferenceSurface
=
nullptr
;
mScreenReferenceDrawTarget
=
nullptr
;
#
ifdef
NS_FREE_PERMANENT_DATA
#
ifdef
USE_SKIA
SkGraphics
:
:
PurgeFontCache
(
)
;
#
endif
#
if
MOZ_TREE_CAIRO
cairo_debug_reset_static_data
(
)
;
#
endif
#
endif
}
cairo_user_data_key_t
kDrawTarget
;
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateDrawTargetForSurface
(
gfxASurface
*
aSurface
const
IntSize
&
aSize
)
{
SurfaceFormat
format
=
aSurface
-
>
GetSurfaceFormat
(
)
;
RefPtr
<
DrawTarget
>
drawTarget
=
Factory
:
:
CreateDrawTargetForCairoSurface
(
aSurface
-
>
CairoSurface
(
)
aSize
&
format
)
;
if
(
!
drawTarget
)
{
gfxWarning
(
)
<
<
"
gfxPlatform
:
:
CreateDrawTargetForSurface
failed
in
CreateDrawTargetForCairoSurface
"
;
return
nullptr
;
}
aSurface
-
>
SetData
(
&
kDrawTarget
drawTarget
nullptr
)
;
return
drawTarget
.
forget
(
)
;
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateDrawTargetForUpdateSurface
(
gfxASurface
*
aSurface
const
IntSize
&
aSize
)
{
#
ifdef
XP_MACOSX
if
(
aSurface
-
>
GetType
(
)
=
=
gfxSurfaceType
:
:
Quartz
)
{
return
Factory
:
:
CreateDrawTargetForCairoCGContext
(
static_cast
<
gfxQuartzSurface
*
>
(
aSurface
)
-
>
GetCGContext
(
)
aSize
)
;
}
#
endif
MOZ_CRASH
(
"
GFX
:
unused
function
"
)
;
return
nullptr
;
}
cairo_user_data_key_t
kSourceSurface
;
struct
SourceSurfaceUserData
{
RefPtr
<
SourceSurface
>
mSrcSurface
;
BackendType
mBackendType
;
}
;
void
SourceBufferDestroy
(
void
*
srcSurfUD
)
{
delete
static_cast
<
SourceSurfaceUserData
*
>
(
srcSurfUD
)
;
}
UserDataKey
kThebesSurface
;
struct
DependentSourceSurfaceUserData
{
RefPtr
<
gfxASurface
>
mSurface
;
}
;
void
SourceSurfaceDestroyed
(
void
*
aData
)
{
delete
static_cast
<
DependentSourceSurfaceUserData
*
>
(
aData
)
;
}
void
gfxPlatform
:
:
ClearSourceSurfaceForSurface
(
gfxASurface
*
aSurface
)
{
aSurface
-
>
SetData
(
&
kSourceSurface
nullptr
nullptr
)
;
}
already_AddRefed
<
SourceSurface
>
gfxPlatform
:
:
GetSourceSurfaceForSurface
(
DrawTarget
*
aTarget
gfxASurface
*
aSurface
)
{
if
(
!
aSurface
-
>
CairoSurface
(
)
|
|
aSurface
-
>
CairoStatus
(
)
)
{
return
nullptr
;
}
if
(
!
aTarget
)
{
aTarget
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
;
if
(
!
aTarget
)
{
return
nullptr
;
}
}
void
*
userData
=
aSurface
-
>
GetData
(
&
kSourceSurface
)
;
if
(
userData
)
{
SourceSurfaceUserData
*
surf
=
static_cast
<
SourceSurfaceUserData
*
>
(
userData
)
;
if
(
surf
-
>
mSrcSurface
-
>
IsValid
(
)
&
&
surf
-
>
mBackendType
=
=
aTarget
-
>
GetBackendType
(
)
)
{
RefPtr
<
SourceSurface
>
srcSurface
(
surf
-
>
mSrcSurface
)
;
return
srcSurface
.
forget
(
)
;
}
}
SurfaceFormat
format
=
aSurface
-
>
GetSurfaceFormat
(
)
;
if
(
aTarget
-
>
GetBackendType
(
)
=
=
BackendType
:
:
CAIRO
)
{
return
Factory
:
:
CreateSourceSurfaceForCairoSurface
(
aSurface
-
>
CairoSurface
(
)
aSurface
-
>
GetSize
(
)
format
)
;
}
RefPtr
<
SourceSurface
>
srcBuffer
;
if
(
!
srcBuffer
)
{
RefPtr
<
DataSourceSurface
>
surf
=
GetWrappedDataSourceSurface
(
aSurface
)
;
if
(
surf
)
{
srcBuffer
=
aTarget
-
>
OptimizeSourceSurface
(
surf
)
;
if
(
srcBuffer
=
=
surf
)
{
return
srcBuffer
.
forget
(
)
;
}
}
}
if
(
!
srcBuffer
)
{
MOZ_ASSERT
(
aTarget
-
>
GetBackendType
(
)
!
=
BackendType
:
:
CAIRO
"
We
already
tried
CreateSourceSurfaceFromNativeSurface
with
a
"
"
DrawTargetCairo
above
"
)
;
srcBuffer
=
Factory
:
:
CreateSourceSurfaceForCairoSurface
(
aSurface
-
>
CairoSurface
(
)
aSurface
-
>
GetSize
(
)
format
)
;
if
(
srcBuffer
)
{
srcBuffer
=
aTarget
-
>
OptimizeSourceSurface
(
srcBuffer
)
;
}
}
if
(
!
srcBuffer
)
{
return
nullptr
;
}
if
(
(
srcBuffer
-
>
GetType
(
)
=
=
SurfaceType
:
:
CAIRO
&
&
static_cast
<
SourceSurfaceCairo
*
>
(
srcBuffer
.
get
(
)
)
-
>
GetSurface
(
)
=
=
aSurface
-
>
CairoSurface
(
)
)
|
|
(
srcBuffer
-
>
GetType
(
)
=
=
SurfaceType
:
:
CAIRO_IMAGE
&
&
static_cast
<
DataSourceSurfaceCairo
*
>
(
srcBuffer
.
get
(
)
)
-
>
GetSurface
(
)
=
=
aSurface
-
>
CairoSurface
(
)
)
)
{
return
srcBuffer
.
forget
(
)
;
}
SourceSurfaceUserData
*
srcSurfUD
=
new
SourceSurfaceUserData
;
srcSurfUD
-
>
mBackendType
=
aTarget
-
>
GetBackendType
(
)
;
srcSurfUD
-
>
mSrcSurface
=
srcBuffer
;
aSurface
-
>
SetData
(
&
kSourceSurface
srcSurfUD
SourceBufferDestroy
)
;
return
srcBuffer
.
forget
(
)
;
}
already_AddRefed
<
DataSourceSurface
>
gfxPlatform
:
:
GetWrappedDataSourceSurface
(
gfxASurface
*
aSurface
)
{
RefPtr
<
gfxImageSurface
>
image
=
aSurface
-
>
GetAsImageSurface
(
)
;
if
(
!
image
)
{
return
nullptr
;
}
RefPtr
<
DataSourceSurface
>
result
=
Factory
:
:
CreateWrappingDataSourceSurface
(
image
-
>
Data
(
)
image
-
>
Stride
(
)
image
-
>
GetSize
(
)
ImageFormatToSurfaceFormat
(
image
-
>
Format
(
)
)
)
;
if
(
!
result
)
{
return
nullptr
;
}
DependentSourceSurfaceUserData
*
srcSurfUD
=
new
DependentSourceSurfaceUserData
;
srcSurfUD
-
>
mSurface
=
aSurface
;
result
-
>
AddUserData
(
&
kThebesSurface
srcSurfUD
SourceSurfaceDestroyed
)
;
return
result
.
forget
(
)
;
}
already_AddRefed
<
ScaledFont
>
gfxPlatform
:
:
GetScaledFontForFont
(
DrawTarget
*
aTarget
gfxFont
*
aFont
)
{
NativeFont
nativeFont
;
nativeFont
.
mType
=
NativeFontType
:
:
CAIRO_FONT_FACE
;
nativeFont
.
mFont
=
aFont
-
>
GetCairoScaledFont
(
)
;
return
Factory
:
:
CreateScaledFontForNativeFont
(
nativeFont
aFont
-
>
GetAdjustedSize
(
)
)
;
}
int
gfxPlatform
:
:
GetTileWidth
(
)
{
MOZ_ASSERT
(
mTileWidth
!
=
-
1
)
;
return
mTileWidth
;
}
int
gfxPlatform
:
:
GetTileHeight
(
)
{
MOZ_ASSERT
(
mTileHeight
!
=
-
1
)
;
return
mTileHeight
;
}
void
gfxPlatform
:
:
SetTileSize
(
int
aWidth
int
aHeight
)
{
MOZ_ASSERT
(
(
mTileWidth
=
=
-
1
&
&
mTileHeight
=
=
-
1
)
|
|
(
mTileWidth
=
=
aWidth
&
&
mTileHeight
=
=
aHeight
)
)
;
mTileWidth
=
aWidth
;
mTileHeight
=
aHeight
;
}
void
gfxPlatform
:
:
ComputeTileSize
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
int32_t
w
=
gfxPrefs
:
:
LayersTileWidth
(
)
;
int32_t
h
=
gfxPrefs
:
:
LayersTileHeight
(
)
;
if
(
gfxPrefs
:
:
LayersTilesAdjust
(
)
)
{
gfx
:
:
IntSize
screenSize
=
GetScreenSize
(
)
;
if
(
screenSize
.
width
>
0
)
{
w
=
h
=
clamped
(
NextPowerOfTwo
(
screenSize
.
width
)
/
4
256
1024
)
;
}
#
ifdef
MOZ_WIDGET_GONK
android
:
:
sp
<
android
:
:
GraphicBuffer
>
alloc
=
new
android
:
:
GraphicBuffer
(
w
h
android
:
:
PIXEL_FORMAT_RGBA_8888
android
:
:
GraphicBuffer
:
:
USAGE_SW_READ_OFTEN
|
android
:
:
GraphicBuffer
:
:
USAGE_SW_WRITE_OFTEN
|
android
:
:
GraphicBuffer
:
:
USAGE_HW_TEXTURE
)
;
if
(
alloc
.
get
(
)
)
{
w
=
alloc
-
>
getStride
(
)
;
}
#
endif
}
SetTileSize
(
w
h
)
;
}
void
gfxPlatform
:
:
PopulateScreenInfo
(
)
{
nsCOMPtr
<
nsIScreenManager
>
manager
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
;
MOZ_ASSERT
(
manager
"
failed
to
get
nsIScreenManager
"
)
;
nsCOMPtr
<
nsIScreen
>
screen
;
manager
-
>
GetPrimaryScreen
(
getter_AddRefs
(
screen
)
)
;
if
(
!
screen
)
{
return
;
}
screen
-
>
GetColorDepth
(
&
mScreenDepth
)
;
int
left
top
;
screen
-
>
GetRect
(
&
left
&
top
&
mScreenSize
.
width
&
mScreenSize
.
height
)
;
}
bool
gfxPlatform
:
:
SupportsAzureContentForDrawTarget
(
DrawTarget
*
aTarget
)
{
if
(
!
aTarget
)
{
return
false
;
}
#
ifdef
USE_SKIA_GPU
if
(
(
aTarget
-
>
GetType
(
)
=
=
DrawTargetType
:
:
HARDWARE_RASTER
)
&
&
(
aTarget
-
>
GetBackendType
(
)
=
=
BackendType
:
:
SKIA
)
)
{
return
false
;
}
#
endif
return
SupportsAzureContentForType
(
aTarget
-
>
GetBackendType
(
)
)
;
}
bool
gfxPlatform
:
:
UseAcceleratedSkiaCanvas
(
)
{
return
gfxPrefs
:
:
CanvasAzureAccelerated
(
)
&
&
mPreferredCanvasBackend
=
=
BackendType
:
:
SKIA
;
}
bool
gfxPlatform
:
:
HaveChoiceOfHWAndSWCanvas
(
)
{
return
mPreferredCanvasBackend
=
=
BackendType
:
:
SKIA
;
}
void
gfxPlatform
:
:
InitializeSkiaCacheLimits
(
)
{
if
(
UseAcceleratedSkiaCanvas
(
)
)
{
#
ifdef
USE_SKIA_GPU
bool
usingDynamicCache
=
gfxPrefs
:
:
CanvasSkiaGLDynamicCache
(
)
;
int
cacheItemLimit
=
gfxPrefs
:
:
CanvasSkiaGLCacheItems
(
)
;
int
cacheSizeLimit
=
gfxPrefs
:
:
CanvasSkiaGLCacheSize
(
)
;
cacheSizeLimit
*
=
1024
*
1024
;
if
(
usingDynamicCache
)
{
if
(
mTotalSystemMemory
<
512
*
1024
*
1024
)
{
cacheSizeLimit
=
2
*
1024
*
1024
;
}
else
if
(
mTotalSystemMemory
>
0
)
{
cacheSizeLimit
=
mTotalSystemMemory
/
16
;
}
}
#
ifdef
DEBUG
printf_stderr
(
"
Determined
SkiaGL
cache
limits
:
Size
%
i
Items
:
%
i
\
n
"
cacheSizeLimit
cacheItemLimit
)
;
#
endif
mSkiaGlue
-
>
GetGrContext
(
)
-
>
setResourceCacheLimits
(
cacheItemLimit
cacheSizeLimit
)
;
#
endif
}
}
SkiaGLGlue
*
gfxPlatform
:
:
GetSkiaGLGlue
(
)
{
#
ifdef
USE_SKIA_GPU
if
(
!
gfxPlatform
:
:
GetPlatform
(
)
-
>
UseAcceleratedSkiaCanvas
(
)
)
{
gfxCriticalNote
<
<
"
Accelerated
Skia
canvas
is
disabled
"
;
return
nullptr
;
}
if
(
!
mSkiaGlue
)
{
RefPtr
<
GLContext
>
glContext
;
glContext
=
GLContextProvider
:
:
CreateHeadless
(
CreateContextFlags
:
:
REQUIRE_COMPAT_PROFILE
|
CreateContextFlags
:
:
ALLOW_OFFLINE_RENDERER
)
;
if
(
!
glContext
)
{
printf_stderr
(
"
Failed
to
create
GLContext
for
SkiaGL
!
\
n
"
)
;
return
nullptr
;
}
mSkiaGlue
=
new
SkiaGLGlue
(
glContext
)
;
MOZ_ASSERT
(
mSkiaGlue
-
>
GetGrContext
(
)
"
No
GrContext
"
)
;
InitializeSkiaCacheLimits
(
)
;
}
#
endif
return
mSkiaGlue
;
}
void
gfxPlatform
:
:
PurgeSkiaCache
(
)
{
#
ifdef
USE_SKIA_GPU
if
(
!
mSkiaGlue
)
return
;
mSkiaGlue
-
>
GetGrContext
(
)
-
>
freeGpuResources
(
)
;
mSkiaGlue
-
>
GetGLContext
(
)
-
>
MakeCurrent
(
)
;
mSkiaGlue
-
>
GetGLContext
(
)
-
>
fFlush
(
)
;
#
endif
}
bool
gfxPlatform
:
:
HasEnoughTotalSystemMemoryForSkiaGL
(
)
{
#
ifdef
MOZ_WIDGET_GONK
if
(
mTotalSystemMemory
<
250
*
1024
*
1024
)
{
return
false
;
}
#
endif
return
true
;
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateDrawTargetForBackend
(
BackendType
aBackend
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
if
(
aBackend
=
=
BackendType
:
:
CAIRO
)
{
RefPtr
<
gfxASurface
>
surf
=
CreateOffscreenSurface
(
aSize
SurfaceFormatToImageFormat
(
aFormat
)
)
;
if
(
!
surf
|
|
surf
-
>
CairoStatus
(
)
)
{
return
nullptr
;
}
return
CreateDrawTargetForSurface
(
surf
aSize
)
;
}
else
{
return
Factory
:
:
CreateDrawTarget
(
aBackend
aSize
aFormat
)
;
}
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateOffscreenCanvasDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
NS_ASSERTION
(
mPreferredCanvasBackend
!
=
BackendType
:
:
NONE
"
No
backend
.
"
)
;
RefPtr
<
DrawTarget
>
target
=
CreateDrawTargetForBackend
(
mPreferredCanvasBackend
aSize
aFormat
)
;
if
(
target
|
|
mFallbackCanvasBackend
=
=
BackendType
:
:
NONE
)
{
return
target
.
forget
(
)
;
}
#
ifdef
XP_WIN
return
Factory
:
:
CreateDrawTarget
(
mFallbackCanvasBackend
aSize
aFormat
)
;
#
else
return
CreateDrawTargetForBackend
(
mFallbackCanvasBackend
aSize
aFormat
)
;
#
endif
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateOffscreenContentDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
NS_ASSERTION
(
mPreferredCanvasBackend
!
=
BackendType
:
:
NONE
"
No
backend
.
"
)
;
return
CreateDrawTargetForBackend
(
mContentBackend
aSize
aFormat
)
;
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateDrawTargetForData
(
unsigned
char
*
aData
const
IntSize
&
aSize
int32_t
aStride
SurfaceFormat
aFormat
)
{
NS_ASSERTION
(
mContentBackend
!
=
BackendType
:
:
NONE
"
No
backend
.
"
)
;
BackendType
backendType
=
mContentBackend
;
if
(
!
Factory
:
:
DoesBackendSupportDataDrawtarget
(
mContentBackend
)
)
{
backendType
=
BackendType
:
:
CAIRO
;
}
RefPtr
<
DrawTarget
>
dt
=
Factory
:
:
CreateDrawTargetForData
(
backendType
aData
aSize
aStride
aFormat
)
;
return
dt
.
forget
(
)
;
}
BackendType
gfxPlatform
:
:
BackendTypeForName
(
const
nsCString
&
aName
)
{
if
(
aName
.
EqualsLiteral
(
"
cairo
"
)
)
return
BackendType
:
:
CAIRO
;
if
(
aName
.
EqualsLiteral
(
"
skia
"
)
)
return
BackendType
:
:
SKIA
;
if
(
aName
.
EqualsLiteral
(
"
direct2d
"
)
)
return
BackendType
:
:
DIRECT2D
;
if
(
aName
.
EqualsLiteral
(
"
direct2d1
.
1
"
)
)
return
BackendType
:
:
DIRECT2D1_1
;
if
(
aName
.
EqualsLiteral
(
"
cg
"
)
)
return
BackendType
:
:
COREGRAPHICS
;
return
BackendType
:
:
NONE
;
}
nsresult
gfxPlatform
:
:
GetFontList
(
nsIAtom
*
aLangGroup
const
nsACString
&
aGenericFamily
nsTArray
<
nsString
>
&
aListOfFonts
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsresult
gfxPlatform
:
:
UpdateFontList
(
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
bool
gfxPlatform
:
:
DownloadableFontsEnabled
(
)
{
if
(
mAllowDownloadableFonts
=
=
UNINITIALIZED_VALUE
)
{
mAllowDownloadableFonts
=
Preferences
:
:
GetBool
(
GFX_DOWNLOADABLE_FONTS_ENABLED
false
)
;
}
return
mAllowDownloadableFonts
;
}
bool
gfxPlatform
:
:
UseCmapsDuringSystemFallback
(
)
{
if
(
mFallbackUsesCmaps
=
=
UNINITIALIZED_VALUE
)
{
mFallbackUsesCmaps
=
Preferences
:
:
GetBool
(
GFX_PREF_FALLBACK_USE_CMAPS
false
)
;
}
return
mFallbackUsesCmaps
;
}
bool
gfxPlatform
:
:
OpenTypeSVGEnabled
(
)
{
if
(
mOpenTypeSVGEnabled
=
=
UNINITIALIZED_VALUE
)
{
mOpenTypeSVGEnabled
=
Preferences
:
:
GetBool
(
GFX_PREF_OPENTYPE_SVG
false
)
;
}
return
mOpenTypeSVGEnabled
>
0
;
}
uint32_t
gfxPlatform
:
:
WordCacheCharLimit
(
)
{
if
(
mWordCacheCharLimit
=
=
UNINITIALIZED_VALUE
)
{
mWordCacheCharLimit
=
Preferences
:
:
GetInt
(
GFX_PREF_WORD_CACHE_CHARLIMIT
32
)
;
if
(
mWordCacheCharLimit
<
0
)
{
mWordCacheCharLimit
=
32
;
}
}
return
uint32_t
(
mWordCacheCharLimit
)
;
}
uint32_t
gfxPlatform
:
:
WordCacheMaxEntries
(
)
{
if
(
mWordCacheMaxEntries
=
=
UNINITIALIZED_VALUE
)
{
mWordCacheMaxEntries
=
Preferences
:
:
GetInt
(
GFX_PREF_WORD_CACHE_MAXENTRIES
10000
)
;
if
(
mWordCacheMaxEntries
<
0
)
{
mWordCacheMaxEntries
=
10000
;
}
}
return
uint32_t
(
mWordCacheMaxEntries
)
;
}
bool
gfxPlatform
:
:
UseGraphiteShaping
(
)
{
if
(
mGraphiteShapingEnabled
=
=
UNINITIALIZED_VALUE
)
{
mGraphiteShapingEnabled
=
Preferences
:
:
GetBool
(
GFX_PREF_GRAPHITE_SHAPING
false
)
;
}
return
mGraphiteShapingEnabled
;
}
gfxFontEntry
*
gfxPlatform
:
:
MakePlatformFont
(
const
nsAString
&
aFontName
uint16_t
aWeight
int16_t
aStretch
uint8_t
aStyle
const
uint8_t
*
aFontData
uint32_t
aLength
)
{
if
(
aFontData
)
{
free
(
(
void
*
)
aFontData
)
;
}
return
nullptr
;
}
mozilla
:
:
layers
:
:
DiagnosticTypes
gfxPlatform
:
:
GetLayerDiagnosticTypes
(
)
{
mozilla
:
:
layers
:
:
DiagnosticTypes
type
=
DiagnosticTypes
:
:
NO_DIAGNOSTIC
;
if
(
gfxPrefs
:
:
DrawLayerBorders
(
)
)
{
type
|
=
mozilla
:
:
layers
:
:
DiagnosticTypes
:
:
LAYER_BORDERS
;
}
if
(
gfxPrefs
:
:
DrawTileBorders
(
)
)
{
type
|
=
mozilla
:
:
layers
:
:
DiagnosticTypes
:
:
TILE_BORDERS
;
}
if
(
gfxPrefs
:
:
DrawBigImageBorders
(
)
)
{
type
|
=
mozilla
:
:
layers
:
:
DiagnosticTypes
:
:
BIGIMAGE_BORDERS
;
}
if
(
gfxPrefs
:
:
FlashLayerBorders
(
)
)
{
type
|
=
mozilla
:
:
layers
:
:
DiagnosticTypes
:
:
FLASH_BORDERS
;
}
return
type
;
}
void
gfxPlatform
:
:
InitBackendPrefs
(
uint32_t
aCanvasBitmask
BackendType
aCanvasDefault
uint32_t
aContentBitmask
BackendType
aContentDefault
)
{
mPreferredCanvasBackend
=
GetCanvasBackendPref
(
aCanvasBitmask
)
;
if
(
mPreferredCanvasBackend
=
=
BackendType
:
:
NONE
)
{
mPreferredCanvasBackend
=
aCanvasDefault
;
}
if
(
mPreferredCanvasBackend
=
=
BackendType
:
:
DIRECT2D1_1
)
{
mFallbackCanvasBackend
=
GetCanvasBackendPref
(
aCanvasBitmask
&
~
(
BackendTypeBit
(
mPreferredCanvasBackend
)
|
BackendTypeBit
(
BackendType
:
:
DIRECT2D
)
)
)
;
}
else
{
mFallbackCanvasBackend
=
GetCanvasBackendPref
(
aCanvasBitmask
&
~
BackendTypeBit
(
mPreferredCanvasBackend
)
)
;
}
mContentBackendBitmask
=
aContentBitmask
;
mContentBackend
=
GetContentBackendPref
(
mContentBackendBitmask
)
;
if
(
mContentBackend
=
=
BackendType
:
:
NONE
)
{
mContentBackend
=
aContentDefault
;
mContentBackendBitmask
|
=
BackendTypeBit
(
aContentDefault
)
;
}
}
BackendType
gfxPlatform
:
:
GetCanvasBackendPref
(
uint32_t
aBackendBitmask
)
{
return
GetBackendPref
(
"
gfx
.
canvas
.
azure
.
backends
"
aBackendBitmask
)
;
}
BackendType
gfxPlatform
:
:
GetContentBackendPref
(
uint32_t
&
aBackendBitmask
)
{
return
GetBackendPref
(
"
gfx
.
content
.
azure
.
backends
"
aBackendBitmask
)
;
}
BackendType
gfxPlatform
:
:
GetBackendPref
(
const
char
*
aBackendPrefName
uint32_t
&
aBackendBitmask
)
{
nsTArray
<
nsCString
>
backendList
;
nsCString
prefString
;
if
(
NS_SUCCEEDED
(
Preferences
:
:
GetCString
(
aBackendPrefName
&
prefString
)
)
)
{
ParseString
(
prefString
'
'
backendList
)
;
}
uint32_t
allowedBackends
=
0
;
BackendType
result
=
BackendType
:
:
NONE
;
for
(
uint32_t
i
=
0
;
i
<
backendList
.
Length
(
)
;
+
+
i
)
{
BackendType
type
=
BackendTypeForName
(
backendList
[
i
]
)
;
if
(
BackendTypeBit
(
type
)
&
aBackendBitmask
)
{
allowedBackends
|
=
BackendTypeBit
(
type
)
;
if
(
result
=
=
BackendType
:
:
NONE
)
{
result
=
type
;
}
}
}
aBackendBitmask
=
allowedBackends
;
return
result
;
}
bool
gfxPlatform
:
:
InSafeMode
(
)
{
static
bool
sSafeModeInitialized
=
false
;
static
bool
sInSafeMode
=
false
;
if
(
!
sSafeModeInitialized
)
{
sSafeModeInitialized
=
true
;
nsCOMPtr
<
nsIXULRuntime
>
xr
=
do_GetService
(
"
mozilla
.
org
/
xre
/
runtime
;
1
"
)
;
if
(
xr
)
{
xr
-
>
GetInSafeMode
(
&
sInSafeMode
)
;
}
}
return
sInSafeMode
;
}
bool
gfxPlatform
:
:
OffMainThreadCompositingEnabled
(
)
{
return
UsesOffMainThreadCompositing
(
)
;
}
eCMSMode
gfxPlatform
:
:
GetCMSMode
(
)
{
if
(
!
gCMSInitialized
)
{
int32_t
mode
=
gfxPrefs
:
:
CMSMode
(
)
;
if
(
mode
>
=
0
&
&
mode
<
eCMSMode_AllCount
)
{
gCMSMode
=
static_cast
<
eCMSMode
>
(
mode
)
;
}
bool
enableV4
=
gfxPrefs
:
:
CMSEnableV4
(
)
;
if
(
enableV4
)
{
qcms_enable_iccv4
(
)
;
}
gCMSInitialized
=
true
;
}
return
gCMSMode
;
}
int
gfxPlatform
:
:
GetRenderingIntent
(
)
{
MOZ_ASSERT
(
QCMS_INTENT_DEFAULT
=
=
0
)
;
int32_t
pIntent
=
gfxPrefs
:
:
CMSRenderingIntent
(
)
;
if
(
(
pIntent
<
QCMS_INTENT_MIN
)
|
|
(
pIntent
>
QCMS_INTENT_MAX
)
)
{
pIntent
=
-
1
;
}
return
pIntent
;
}
void
gfxPlatform
:
:
TransformPixel
(
const
Color
&
in
Color
&
out
qcms_transform
*
transform
)
{
if
(
transform
)
{
#
ifdef
IS_LITTLE_ENDIAN
uint32_t
packed
=
in
.
ToABGR
(
)
;
qcms_transform_data
(
transform
(
uint8_t
*
)
&
packed
(
uint8_t
*
)
&
packed
1
)
;
out
=
Color
:
:
FromABGR
(
packed
)
;
#
else
uint32_t
packed
=
in
.
UnusualToARGB
(
)
;
qcms_transform_data
(
transform
(
uint8_t
*
)
&
packed
+
1
(
uint8_t
*
)
&
packed
+
1
1
)
;
out
=
Color
:
:
UnusualFromARGB
(
packed
)
;
#
endif
}
else
if
(
&
out
!
=
&
in
)
out
=
in
;
}
void
gfxPlatform
:
:
GetPlatformCMSOutputProfile
(
void
*
&
mem
size_t
&
size
)
{
mem
=
nullptr
;
size
=
0
;
}
void
gfxPlatform
:
:
GetCMSOutputProfileData
(
void
*
&
mem
size_t
&
size
)
{
nsAdoptingCString
fname
=
Preferences
:
:
GetCString
(
"
gfx
.
color_management
.
display_profile
"
)
;
if
(
!
fname
.
IsEmpty
(
)
)
{
qcms_data_from_path
(
fname
&
mem
&
size
)
;
}
else
{
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetPlatformCMSOutputProfile
(
mem
size
)
;
}
}
void
gfxPlatform
:
:
CreateCMSOutputProfile
(
)
{
if
(
!
gCMSOutputProfile
)
{
if
(
Preferences
:
:
GetBool
(
GFX_PREF_CMS_FORCE_SRGB
false
)
)
{
gCMSOutputProfile
=
GetCMSsRGBProfile
(
)
;
}
if
(
!
gCMSOutputProfile
)
{
void
*
mem
=
nullptr
;
size_t
size
=
0
;
GetCMSOutputProfileData
(
mem
size
)
;
if
(
(
mem
!
=
nullptr
)
&
&
(
size
>
0
)
)
{
gCMSOutputProfile
=
qcms_profile_from_memory
(
mem
size
)
;
free
(
mem
)
;
}
}
if
(
gCMSOutputProfile
&
&
qcms_profile_is_bogus
(
gCMSOutputProfile
)
)
{
NS_ASSERTION
(
gCMSOutputProfile
!
=
GetCMSsRGBProfile
(
)
"
Builtin
sRGB
profile
tagged
as
bogus
!
!
!
"
)
;
qcms_profile_release
(
gCMSOutputProfile
)
;
gCMSOutputProfile
=
nullptr
;
}
if
(
!
gCMSOutputProfile
)
{
gCMSOutputProfile
=
GetCMSsRGBProfile
(
)
;
}
qcms_profile_precache_output_transform
(
gCMSOutputProfile
)
;
}
}
qcms_profile
*
gfxPlatform
:
:
GetCMSOutputProfile
(
)
{
return
gCMSOutputProfile
;
}
qcms_profile
*
gfxPlatform
:
:
GetCMSsRGBProfile
(
)
{
if
(
!
gCMSsRGBProfile
)
{
gCMSsRGBProfile
=
qcms_profile_sRGB
(
)
;
}
return
gCMSsRGBProfile
;
}
qcms_transform
*
gfxPlatform
:
:
GetCMSRGBTransform
(
)
{
if
(
!
gCMSRGBTransform
)
{
qcms_profile
*
inProfile
*
outProfile
;
outProfile
=
GetCMSOutputProfile
(
)
;
inProfile
=
GetCMSsRGBProfile
(
)
;
if
(
!
inProfile
|
|
!
outProfile
)
return
nullptr
;
gCMSRGBTransform
=
qcms_transform_create
(
inProfile
QCMS_DATA_RGB_8
outProfile
QCMS_DATA_RGB_8
QCMS_INTENT_PERCEPTUAL
)
;
}
return
gCMSRGBTransform
;
}
qcms_transform
*
gfxPlatform
:
:
GetCMSInverseRGBTransform
(
)
{
if
(
!
gCMSInverseRGBTransform
)
{
qcms_profile
*
inProfile
*
outProfile
;
inProfile
=
GetCMSOutputProfile
(
)
;
outProfile
=
GetCMSsRGBProfile
(
)
;
if
(
!
inProfile
|
|
!
outProfile
)
return
nullptr
;
gCMSInverseRGBTransform
=
qcms_transform_create
(
inProfile
QCMS_DATA_RGB_8
outProfile
QCMS_DATA_RGB_8
QCMS_INTENT_PERCEPTUAL
)
;
}
return
gCMSInverseRGBTransform
;
}
qcms_transform
*
gfxPlatform
:
:
GetCMSRGBATransform
(
)
{
if
(
!
gCMSRGBATransform
)
{
qcms_profile
*
inProfile
*
outProfile
;
outProfile
=
GetCMSOutputProfile
(
)
;
inProfile
=
GetCMSsRGBProfile
(
)
;
if
(
!
inProfile
|
|
!
outProfile
)
return
nullptr
;
gCMSRGBATransform
=
qcms_transform_create
(
inProfile
QCMS_DATA_RGBA_8
outProfile
QCMS_DATA_RGBA_8
QCMS_INTENT_PERCEPTUAL
)
;
}
return
gCMSRGBATransform
;
}
static
void
ShutdownCMS
(
)
{
if
(
gCMSRGBTransform
)
{
qcms_transform_release
(
gCMSRGBTransform
)
;
gCMSRGBTransform
=
nullptr
;
}
if
(
gCMSInverseRGBTransform
)
{
qcms_transform_release
(
gCMSInverseRGBTransform
)
;
gCMSInverseRGBTransform
=
nullptr
;
}
if
(
gCMSRGBATransform
)
{
qcms_transform_release
(
gCMSRGBATransform
)
;
gCMSRGBATransform
=
nullptr
;
}
if
(
gCMSOutputProfile
)
{
qcms_profile_release
(
gCMSOutputProfile
)
;
if
(
gCMSsRGBProfile
=
=
gCMSOutputProfile
)
gCMSsRGBProfile
=
nullptr
;
gCMSOutputProfile
=
nullptr
;
}
if
(
gCMSsRGBProfile
)
{
qcms_profile_release
(
gCMSsRGBProfile
)
;
gCMSsRGBProfile
=
nullptr
;
}
gCMSMode
=
eCMSMode_Off
;
gCMSInitialized
=
false
;
}
void
gfxPlatform
:
:
SetupClusterBoundaries
(
gfxTextRun
*
aTextRun
const
char16_t
*
aString
)
{
if
(
aTextRun
-
>
GetFlags
(
)
&
gfxTextRunFactory
:
:
TEXT_IS_8BIT
)
{
return
;
}
aTextRun
-
>
SetupClusterBoundaries
(
0
aString
aTextRun
-
>
GetLength
(
)
)
;
}
int32_t
gfxPlatform
:
:
GetBidiNumeralOption
(
)
{
if
(
mBidiNumeralOption
=
=
UNINITIALIZED_VALUE
)
{
mBidiNumeralOption
=
Preferences
:
:
GetInt
(
BIDI_NUMERAL_PREF
0
)
;
}
return
mBidiNumeralOption
;
}
void
gfxPlatform
:
:
FlushFontAndWordCaches
(
)
{
gfxFontCache
*
fontCache
=
gfxFontCache
:
:
GetCache
(
)
;
if
(
fontCache
)
{
fontCache
-
>
AgeAllGenerations
(
)
;
fontCache
-
>
FlushShapedWordCaches
(
)
;
}
}
void
gfxPlatform
:
:
FontsPrefsChanged
(
const
char
*
aPref
)
{
NS_ASSERTION
(
aPref
!
=
nullptr
"
null
preference
"
)
;
if
(
!
strcmp
(
GFX_DOWNLOADABLE_FONTS_ENABLED
aPref
)
)
{
mAllowDownloadableFonts
=
UNINITIALIZED_VALUE
;
}
else
if
(
!
strcmp
(
GFX_PREF_FALLBACK_USE_CMAPS
aPref
)
)
{
mFallbackUsesCmaps
=
UNINITIALIZED_VALUE
;
}
else
if
(
!
strcmp
(
GFX_PREF_WORD_CACHE_CHARLIMIT
aPref
)
)
{
mWordCacheCharLimit
=
UNINITIALIZED_VALUE
;
FlushFontAndWordCaches
(
)
;
}
else
if
(
!
strcmp
(
GFX_PREF_WORD_CACHE_MAXENTRIES
aPref
)
)
{
mWordCacheMaxEntries
=
UNINITIALIZED_VALUE
;
FlushFontAndWordCaches
(
)
;
}
else
if
(
!
strcmp
(
GFX_PREF_GRAPHITE_SHAPING
aPref
)
)
{
mGraphiteShapingEnabled
=
UNINITIALIZED_VALUE
;
FlushFontAndWordCaches
(
)
;
}
else
if
(
!
strcmp
(
BIDI_NUMERAL_PREF
aPref
)
)
{
mBidiNumeralOption
=
UNINITIALIZED_VALUE
;
}
else
if
(
!
strcmp
(
GFX_PREF_OPENTYPE_SVG
aPref
)
)
{
mOpenTypeSVGEnabled
=
UNINITIALIZED_VALUE
;
gfxFontCache
:
:
GetCache
(
)
-
>
AgeAllGenerations
(
)
;
}
}
mozilla
:
:
LogModule
*
gfxPlatform
:
:
GetLog
(
eGfxLog
aWhichLog
)
{
static
LazyLogModule
sFontlistLog
(
"
fontlist
"
)
;
static
LazyLogModule
sFontInitLog
(
"
fontinit
"
)
;
static
LazyLogModule
sTextrunLog
(
"
textrun
"
)
;
static
LazyLogModule
sTextrunuiLog
(
"
textrunui
"
)
;
static
LazyLogModule
sCmapDataLog
(
"
cmapdata
"
)
;
static
LazyLogModule
sTextPerfLog
(
"
textperf
"
)
;
switch
(
aWhichLog
)
{
case
eGfxLog_fontlist
:
return
sFontlistLog
;
case
eGfxLog_fontinit
:
return
sFontInitLog
;
case
eGfxLog_textrun
:
return
sTextrunLog
;
case
eGfxLog_textrunui
:
return
sTextrunuiLog
;
case
eGfxLog_cmapdata
:
return
sCmapDataLog
;
case
eGfxLog_textperf
:
return
sTextPerfLog
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
log
type
"
)
;
return
nullptr
;
}
mozilla
:
:
gfx
:
:
SurfaceFormat
gfxPlatform
:
:
Optimal2DFormatForContent
(
gfxContentType
aContent
)
{
switch
(
aContent
)
{
case
gfxContentType
:
:
COLOR
:
switch
(
GetOffscreenFormat
(
)
)
{
case
SurfaceFormat
:
:
A8R8G8B8_UINT32
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
case
SurfaceFormat
:
:
X8R8G8B8_UINT32
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8X8
;
case
SurfaceFormat
:
:
R5G6B5_UINT16
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
R5G6B5_UINT16
;
default
:
NS_NOTREACHED
(
"
unknown
gfxImageFormat
for
gfxContentType
:
:
COLOR
"
)
;
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
}
case
gfxContentType
:
:
ALPHA
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
A8
;
case
gfxContentType
:
:
COLOR_ALPHA
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
default
:
NS_NOTREACHED
(
"
unknown
gfxContentType
"
)
;
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
}
}
gfxImageFormat
gfxPlatform
:
:
OptimalFormatForContent
(
gfxContentType
aContent
)
{
switch
(
aContent
)
{
case
gfxContentType
:
:
COLOR
:
return
GetOffscreenFormat
(
)
;
case
gfxContentType
:
:
ALPHA
:
return
SurfaceFormat
:
:
A8
;
case
gfxContentType
:
:
COLOR_ALPHA
:
return
SurfaceFormat
:
:
A8R8G8B8_UINT32
;
default
:
NS_NOTREACHED
(
"
unknown
gfxContentType
"
)
;
return
SurfaceFormat
:
:
A8R8G8B8_UINT32
;
}
}
static
bool
sLayersSupportsD3D9
=
false
;
static
bool
sLayersSupportsD3D11
=
false
;
bool
gANGLESupportsD3D11
=
false
;
static
bool
sLayersSupportsHardwareVideoDecoding
=
false
;
static
bool
sLayersHardwareVideoDecodingFailed
=
false
;
static
bool
sBufferRotationCheckPref
=
true
;
static
bool
sPrefBrowserTabsRemoteAutostart
=
false
;
static
bool
sLayersAccelerationPrefsInitialized
=
false
;
void
InitLayersAccelerationPrefs
(
)
{
if
(
!
sLayersAccelerationPrefsInitialized
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
can
only
initialize
prefs
on
the
main
thread
"
)
;
gfxPrefs
:
:
GetSingleton
(
)
;
sPrefBrowserTabsRemoteAutostart
=
BrowserTabsRemoteAutostart
(
)
;
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
services
:
:
GetGfxInfo
(
)
;
int32_t
status
;
#
ifdef
XP_WIN
if
(
gfxPrefs
:
:
LayersAccelerationForceEnabled
(
)
)
{
sLayersSupportsD3D9
=
true
;
sLayersSupportsD3D11
=
true
;
}
else
if
(
gfxInfo
)
{
if
(
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_DIRECT3D_9_LAYERS
&
status
)
)
)
{
if
(
status
=
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
)
{
if
(
sPrefBrowserTabsRemoteAutostart
&
&
!
IsVistaOrLater
(
)
)
{
gfxWarning
(
)
<
<
"
Disallowing
D3D9
on
Windows
XP
with
E10S
-
see
bug
1237770
"
;
}
else
{
sLayersSupportsD3D9
=
true
;
}
}
}
if
(
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_DIRECT3D_11_LAYERS
&
status
)
)
)
{
if
(
status
=
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
)
{
sLayersSupportsD3D11
=
true
;
}
}
if
(
!
gfxPrefs
:
:
LayersD3D11DisableWARP
(
)
)
{
sLayersSupportsD3D11
=
true
;
}
if
(
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_DIRECT3D_11_ANGLE
&
status
)
)
)
{
if
(
status
=
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
)
{
gANGLESupportsD3D11
=
true
;
}
}
}
#
endif
if
(
Preferences
:
:
GetBool
(
"
media
.
hardware
-
video
-
decoding
.
enabled
"
false
)
&
&
#
ifdef
XP_WIN
Preferences
:
:
GetBool
(
"
media
.
windows
-
media
-
foundation
.
use
-
dxva
"
true
)
&
&
#
endif
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_HARDWARE_VIDEO_DECODING
&
status
)
)
)
{
if
(
status
=
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
|
|
gfxPrefs
:
:
HardwareVideoDecodingForceEnabled
(
)
)
{
sLayersSupportsHardwareVideoDecoding
=
true
;
}
}
Preferences
:
:
AddBoolVarCache
(
&
sLayersHardwareVideoDecodingFailed
"
media
.
hardware
-
video
-
decoding
.
failed
"
false
)
;
sLayersAccelerationPrefsInitialized
=
true
;
}
}
bool
gfxPlatform
:
:
CanUseDirect3D9
(
)
{
MOZ_ASSERT
(
sLayersAccelerationPrefsInitialized
)
;
return
sLayersSupportsD3D9
;
}
bool
gfxPlatform
:
:
CanUseDirect3D11
(
)
{
MOZ_ASSERT
(
sLayersAccelerationPrefsInitialized
)
;
return
sLayersSupportsD3D11
;
}
bool
gfxPlatform
:
:
CanUseHardwareVideoDecoding
(
)
{
MOZ_ASSERT
(
sLayersAccelerationPrefsInitialized
)
;
return
sLayersSupportsHardwareVideoDecoding
&
&
!
sLayersHardwareVideoDecodingFailed
;
}
bool
gfxPlatform
:
:
CanUseDirect3D11ANGLE
(
)
{
MOZ_ASSERT
(
sLayersAccelerationPrefsInitialized
)
;
return
gANGLESupportsD3D11
;
}
bool
gfxPlatform
:
:
ShouldUseLayersAcceleration
(
)
{
const
char
*
acceleratedEnv
=
PR_GetEnv
(
"
MOZ_ACCELERATED
"
)
;
if
(
gfxPrefs
:
:
LayersAccelerationDisabled
(
)
|
|
InSafeMode
(
)
|
|
(
acceleratedEnv
&
&
*
acceleratedEnv
=
=
'
0
'
)
)
{
return
false
;
}
if
(
gfxPrefs
:
:
LayersAccelerationForceEnabled
(
)
)
{
return
true
;
}
if
(
AccelerateLayersByDefault
(
)
)
{
return
true
;
}
if
(
acceleratedEnv
&
&
*
acceleratedEnv
!
=
'
0
'
)
{
return
true
;
}
return
false
;
}
bool
gfxPlatform
:
:
AccelerateLayersByDefault
(
)
{
#
if
defined
(
MOZ_GL_PROVIDER
)
|
|
defined
(
MOZ_WIDGET_UIKIT
)
return
true
;
#
else
return
false
;
#
endif
}
bool
gfxPlatform
:
:
BufferRotationEnabled
(
)
{
MutexAutoLock
autoLock
(
*
gGfxPlatformPrefsLock
)
;
return
sBufferRotationCheckPref
&
&
gfxPrefs
:
:
BufferRotationEnabled
(
)
;
}
void
gfxPlatform
:
:
DisableBufferRotation
(
)
{
MutexAutoLock
autoLock
(
*
gGfxPlatformPrefsLock
)
;
sBufferRotationCheckPref
=
false
;
}
already_AddRefed
<
ScaledFont
>
gfxPlatform
:
:
GetScaledFontForFontWithCairoSkia
(
DrawTarget
*
aTarget
gfxFont
*
aFont
)
{
NativeFont
nativeFont
;
if
(
aTarget
-
>
GetBackendType
(
)
=
=
BackendType
:
:
CAIRO
|
|
aTarget
-
>
GetBackendType
(
)
=
=
BackendType
:
:
SKIA
)
{
nativeFont
.
mType
=
NativeFontType
:
:
CAIRO_FONT_FACE
;
nativeFont
.
mFont
=
aFont
-
>
GetCairoScaledFont
(
)
;
return
Factory
:
:
CreateScaledFontForNativeFont
(
nativeFont
aFont
-
>
GetAdjustedSize
(
)
)
;
}
return
nullptr
;
}
bool
gfxPlatform
:
:
UsesOffMainThreadCompositing
(
)
{
InitLayersAccelerationPrefs
(
)
;
static
bool
firstTime
=
true
;
static
bool
result
=
false
;
if
(
firstTime
)
{
result
=
sPrefBrowserTabsRemoteAutostart
|
|
gfxPrefs
:
:
LayersOffMainThreadCompositionEnabled
(
)
|
|
gfxPrefs
:
:
LayersOffMainThreadCompositionForceEnabled
(
)
;
#
if
defined
(
MOZ_WIDGET_GTK
)
result
|
=
gfxPrefs
:
:
LayersAccelerationForceEnabled
(
)
;
#
endif
firstTime
=
false
;
}
return
result
;
}
already_AddRefed
<
mozilla
:
:
gfx
:
:
VsyncSource
>
gfxPlatform
:
:
CreateHardwareVsyncSource
(
)
{
NS_WARNING
(
"
Hardware
Vsync
support
not
yet
implemented
.
Falling
back
to
software
timers
"
)
;
RefPtr
<
mozilla
:
:
gfx
:
:
VsyncSource
>
softwareVsync
=
new
SoftwareVsyncSource
(
)
;
return
softwareVsync
.
forget
(
)
;
}
bool
gfxPlatform
:
:
IsInLayoutAsapMode
(
)
{
return
Preferences
:
:
GetInt
(
"
layout
.
frame_rate
"
-
1
)
=
=
0
;
}
bool
gfxPlatform
:
:
ForceSoftwareVsync
(
)
{
return
Preferences
:
:
GetInt
(
"
layout
.
frame_rate
"
-
1
)
>
0
;
}
int
gfxPlatform
:
:
GetSoftwareVsyncRate
(
)
{
int
preferenceRate
=
Preferences
:
:
GetInt
(
"
layout
.
frame_rate
"
gfxPlatform
:
:
GetDefaultFrameRate
(
)
)
;
if
(
preferenceRate
<
=
0
)
{
return
gfxPlatform
:
:
GetDefaultFrameRate
(
)
;
}
return
preferenceRate
;
}
int
gfxPlatform
:
:
GetDefaultFrameRate
(
)
{
return
60
;
}
void
gfxPlatform
:
:
GetApzSupportInfo
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
if
(
!
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
)
{
return
;
}
if
(
SupportsApzWheelInput
(
)
)
{
aObj
.
DefineProperty
(
"
ApzWheelInput
"
1
)
;
}
if
(
SupportsApzTouchInput
(
)
)
{
aObj
.
DefineProperty
(
"
ApzTouchInput
"
1
)
;
}
if
(
SupportsApzDragInput
(
)
)
{
aObj
.
DefineProperty
(
"
ApzDragInput
"
1
)
;
}
}
bool
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
{
#
if
!
defined
(
MOZ_B2G
)
&
&
!
defined
(
MOZ_WIDGET_ANDROID
)
&
&
!
defined
(
MOZ_WIDGET_UIKIT
)
if
(
!
BrowserTabsRemoteAutostart
(
)
)
{
return
false
;
}
#
endif
#
ifdef
MOZ_ANDROID_APZ
return
true
;
#
else
return
gfxPrefs
:
:
AsyncPanZoomEnabledDoNotUseDirectly
(
)
;
#
endif
}
bool
gfxPlatform
:
:
UseProgressivePaint
(
)
{
return
gfxPrefs
:
:
ProgressivePaintDoNotUseDirectly
(
)
;
}
bool
gfxPlatform
:
:
PerfWarnings
(
)
{
return
gfxPrefs
:
:
PerfWarnings
(
)
;
}
static
inline
bool
AllowOpenGL
(
bool
*
aWhitelisted
)
{
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
info
;
1
"
)
;
if
(
gfxInfo
)
{
gfxInfo
-
>
GetData
(
)
;
int32_t
status
;
if
(
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_OPENGL_LAYERS
&
status
)
)
)
{
if
(
status
=
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
)
{
*
aWhitelisted
=
true
;
return
true
;
}
}
}
return
gfxPrefs
:
:
LayersAccelerationForceEnabled
(
)
;
}
void
gfxPlatform
:
:
GetAcceleratedCompositorBackends
(
nsTArray
<
LayersBackend
>
&
aBackends
)
{
bool
whitelisted
=
false
;
if
(
AllowOpenGL
(
&
whitelisted
)
)
{
aBackends
.
AppendElement
(
LayersBackend
:
:
LAYERS_OPENGL
)
;
}
if
(
!
whitelisted
)
{
static
int
tell_me_once
=
0
;
if
(
!
tell_me_once
)
{
NS_WARNING
(
"
OpenGL
-
accelerated
layers
are
not
supported
on
this
system
"
)
;
tell_me_once
=
1
;
}
#
ifdef
MOZ_WIDGET_ANDROID
NS_RUNTIMEABORT
(
"
OpenGL
-
accelerated
layers
are
a
hard
requirement
on
this
platform
.
"
"
Cannot
continue
without
support
for
them
"
)
;
#
endif
}
}
void
gfxPlatform
:
:
GetCompositorBackends
(
bool
useAcceleration
nsTArray
<
mozilla
:
:
layers
:
:
LayersBackend
>
&
aBackends
)
{
if
(
useAcceleration
)
{
GetAcceleratedCompositorBackends
(
aBackends
)
;
}
aBackends
.
AppendElement
(
LayersBackend
:
:
LAYERS_BASIC
)
;
}
void
gfxPlatform
:
:
NotifyCompositorCreated
(
LayersBackend
aBackend
)
{
if
(
mCompositorBackend
=
=
aBackend
)
{
return
;
}
if
(
mCompositorBackend
!
=
LayersBackend
:
:
LAYERS_NONE
)
{
gfxCriticalNote
<
<
"
Compositors
might
be
mixed
(
"
<
<
int
(
mCompositorBackend
)
<
<
"
"
<
<
int
(
aBackend
)
<
<
"
)
"
;
}
mCompositorBackend
=
aBackend
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
[
]
{
if
(
nsCOMPtr
<
nsIObserverService
>
obsvc
=
services
:
:
GetObserverService
(
)
)
{
obsvc
-
>
NotifyObservers
(
nullptr
"
compositor
:
created
"
nullptr
)
;
}
}
)
)
;
}
void
gfxPlatform
:
:
GetDeviceInitData
(
mozilla
:
:
gfx
:
:
DeviceInitData
*
aOut
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
aOut
-
>
useAcceleration
(
)
=
ShouldUseLayersAcceleration
(
)
;
}
void
gfxPlatform
:
:
UpdateDeviceInitData
(
)
{
if
(
XRE_IsParentProcess
(
)
)
{
return
;
}
mozilla
:
:
gfx
:
:
DeviceInitData
data
;
mozilla
:
:
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendGetGraphicsDeviceInitData
(
&
data
)
;
SetDeviceInitData
(
data
)
;
}
bool
gfxPlatform
:
:
SupportsApzDragInput
(
)
const
{
return
gfxPrefs
:
:
APZDragEnabled
(
)
;
}
