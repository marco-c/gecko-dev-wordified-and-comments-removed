#
include
"
mozilla
/
FontPropertyTypes
.
h
"
#
include
"
mozilla
/
RDDProcessManager
.
h
"
#
include
"
mozilla
/
image
/
ImageMemoryReporter
.
h
"
#
include
"
mozilla
/
layers
/
CompositorManagerChild
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
RemoteTextureMap
.
h
"
#
include
"
mozilla
/
webrender
/
RenderThread
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
mozilla
/
webrender
/
webrender_ffi
.
h
"
#
include
"
mozilla
/
gfx
/
BuildConstants
.
h
"
#
include
"
mozilla
/
gfx
/
gfxConfigManager
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessManager
.
h
"
#
include
"
mozilla
/
gfx
/
GraphicsMessages
.
h
"
#
include
"
mozilla
/
gfx
/
CanvasManagerChild
.
h
"
#
include
"
mozilla
/
gfx
/
CanvasManagerParent
.
h
"
#
include
"
mozilla
/
gfx
/
CanvasRenderThread
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
StaticPrefs_accessibility
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
include
"
mozilla
/
StaticPrefs_bidi
.
h
"
#
include
"
mozilla
/
StaticPrefs_canvas
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
StaticPrefs_layers
.
h
"
#
include
"
mozilla
/
StaticPrefs_media
.
h
"
#
include
"
mozilla
/
StaticPrefs_privacy
.
h
"
#
include
"
mozilla
/
StaticPrefs_webgl
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
VsyncDispatcher
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
nsAppRunner
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
gfxCrashReporterUtils
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxPlatformWorker
.
h
"
#
include
"
gfxBlur
.
h
"
#
include
"
gfxEnv
.
h
"
#
include
"
gfxTextRun
.
h
"
#
include
"
gfxUserFontSet
.
h
"
#
include
"
gfxConfig
.
h
"
#
include
"
GfxDriverInfo
.
h
"
#
include
"
VRProcessManager
.
h
"
#
include
"
VRThread
.
h
"
#
ifdef
XP_WIN
#
include
<
process
.
h
>
#
define
getpid
_getpid
#
else
#
include
<
unistd
.
h
>
#
endif
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsIXULAppInfo
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
gfxWindowsPlatform
.
h
"
#
include
"
mozilla
/
widget
/
WinWindowOcclusionTracker
.
h
"
#
elif
defined
(
XP_MACOSX
)
#
include
"
gfxPlatformMac
.
h
"
#
include
"
gfxQuartzSurface
.
h
"
#
include
"
nsCocoaFeatures
.
h
"
#
elif
defined
(
MOZ_WIDGET_GTK
)
#
include
"
gfxPlatformGtk
.
h
"
#
elif
defined
(
ANDROID
)
#
include
"
gfxAndroidPlatform
.
h
"
#
endif
#
if
defined
(
MOZ_WIDGET_ANDROID
)
#
include
"
mozilla
/
jni
/
Utils
.
h
"
#
endif
#
ifdef
XP_WIN
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
WinUtils
.
h
"
#
endif
#
include
"
nsGkAtoms
.
h
"
#
include
"
gfxPlatformFontList
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxImageSurface
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
harfbuzz
/
hb
.
h
"
#
include
"
gfxGraphiteShaper
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxGradientCache
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
gfxFontMissingGlyphs
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
mozilla
/
widget
/
Screen
.
h
"
#
include
"
mozilla
/
widget
/
ScreenManager
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
cairo
.
h
"
#
include
"
qcms
.
h
"
#
include
"
imgITools
.
h
"
#
include
"
plstr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
GLContextProvider
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
ifdef
__GNUC__
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wshadow
"
#
endif
#
include
"
skia
/
include
/
core
/
SkGraphics
.
h
"
#
ifdef
MOZ_ENABLE_FREETYPE
#
include
"
skia
/
include
/
ports
/
SkTypeface_cairo
.
h
"
#
endif
#
include
"
mozilla
/
gfx
/
SkMemoryReporter
.
h
"
#
ifdef
__GNUC__
#
pragma
GCC
diagnostic
pop
/
/
-
Wshadow
#
endif
static
const
uint32_t
kDefaultGlyphCacheSize
=
-
1
;
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsIGfxInfo
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
VsyncSource
.
h
"
#
include
"
SoftwareVsyncSource
.
h
"
#
include
"
nscore
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
TouchEvent
.
h
"
#
include
"
gfxVR
.
h
"
#
include
"
VRManager
.
h
"
#
include
"
VRManagerChild
.
h
"
#
include
"
mozilla
/
gfx
/
GPUParent
.
h
"
#
include
"
prsystem
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
SourceSurfaceCairo
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
gl
;
using
namespace
mozilla
:
:
gfx
;
gfxPlatform
*
gPlatform
=
nullptr
;
static
bool
gEverInitialized
=
false
;
const
ContentDeviceData
*
gContentDeviceInitData
=
nullptr
;
Atomic
<
bool
MemoryOrdering
:
:
ReleaseAcquire
>
gfxPlatform
:
:
gCMSInitialized
;
CMSMode
gfxPlatform
:
:
gCMSMode
=
CMSMode
:
:
Off
;
qcms_profile
*
gfxPlatform
:
:
gCMSOutputProfile
=
nullptr
;
qcms_profile
*
gfxPlatform
:
:
gCMSsRGBProfile
=
nullptr
;
qcms_transform
*
gfxPlatform
:
:
gCMSRGBTransform
=
nullptr
;
qcms_transform
*
gfxPlatform
:
:
gCMSInverseRGBTransform
=
nullptr
;
qcms_transform
*
gfxPlatform
:
:
gCMSRGBATransform
=
nullptr
;
qcms_transform
*
gfxPlatform
:
:
gCMSBGRATransform
=
nullptr
;
class
CrashStatsLogForwarder
:
public
mozilla
:
:
gfx
:
:
LogForwarder
{
public
:
explicit
CrashStatsLogForwarder
(
CrashReporter
:
:
Annotation
aKey
)
;
void
Log
(
const
std
:
:
string
&
aString
)
override
;
void
CrashAction
(
LogReason
aReason
)
override
;
bool
UpdateStringsVector
(
const
std
:
:
string
&
aString
)
override
;
LoggingRecord
LoggingRecordCopy
(
)
override
;
void
SetCircularBufferSize
(
uint32_t
aCapacity
)
;
private
:
void
UpdateCrashReport
(
)
;
private
:
LoggingRecord
mBuffer
;
CrashReporter
:
:
Annotation
mCrashCriticalKey
;
uint32_t
mMaxCapacity
;
int32_t
mIndex
;
Mutex
mMutex
MOZ_UNANNOTATED
;
}
;
CrashStatsLogForwarder
:
:
CrashStatsLogForwarder
(
CrashReporter
:
:
Annotation
aKey
)
:
mBuffer
(
)
mCrashCriticalKey
(
aKey
)
mMaxCapacity
(
0
)
mIndex
(
-
1
)
mMutex
(
"
CrashStatsLogForwarder
"
)
{
}
void
CrashStatsLogForwarder
:
:
SetCircularBufferSize
(
uint32_t
aCapacity
)
{
MutexAutoLock
lock
(
mMutex
)
;
mMaxCapacity
=
aCapacity
;
mBuffer
.
reserve
(
static_cast
<
size_t
>
(
aCapacity
)
)
;
}
LoggingRecord
CrashStatsLogForwarder
:
:
LoggingRecordCopy
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mBuffer
;
}
bool
CrashStatsLogForwarder
:
:
UpdateStringsVector
(
const
std
:
:
string
&
aString
)
{
if
(
mMaxCapacity
<
2
)
{
return
false
;
}
mIndex
+
=
1
;
MOZ_ASSERT
(
mIndex
>
=
0
)
;
int32_t
index
=
mIndex
?
(
mIndex
-
1
)
%
(
mMaxCapacity
-
1
)
+
1
:
0
;
MOZ_ASSERT
(
index
>
=
0
&
&
index
<
(
int32_t
)
mMaxCapacity
)
;
MOZ_ASSERT
(
index
<
=
mIndex
&
&
index
<
=
(
int32_t
)
mBuffer
.
size
(
)
)
;
double
tStamp
=
(
TimeStamp
:
:
NowLoRes
(
)
-
TimeStamp
:
:
ProcessCreation
(
)
)
.
ToSecondsSigDigits
(
)
;
LoggingRecordEntry
newEntry
(
mIndex
aString
tStamp
)
;
if
(
index
>
=
static_cast
<
int32_t
>
(
mBuffer
.
size
(
)
)
)
{
mBuffer
.
push_back
(
newEntry
)
;
}
else
{
mBuffer
[
index
]
=
newEntry
;
}
return
true
;
}
void
CrashStatsLogForwarder
:
:
UpdateCrashReport
(
)
{
std
:
:
stringstream
message
;
std
:
:
string
logAnnotation
;
switch
(
XRE_GetProcessType
(
)
)
{
case
GeckoProcessType_Default
:
logAnnotation
=
"
|
[
"
;
break
;
case
GeckoProcessType_Content
:
logAnnotation
=
"
|
[
C
"
;
break
;
case
GeckoProcessType_GPU
:
logAnnotation
=
"
|
[
G
"
;
break
;
default
:
logAnnotation
=
"
|
[
X
"
;
break
;
}
for
(
auto
&
it
:
mBuffer
)
{
message
<
<
logAnnotation
<
<
Get
<
0
>
(
it
)
<
<
"
]
"
<
<
Get
<
1
>
(
it
)
<
<
"
(
t
=
"
<
<
Get
<
2
>
(
it
)
<
<
"
)
"
;
}
nsCString
reportString
(
message
.
str
(
)
.
c_str
(
)
)
;
nsresult
annotated
=
CrashReporter
:
:
AnnotateCrashReport
(
mCrashCriticalKey
reportString
)
;
if
(
annotated
!
=
NS_OK
)
{
printf
(
"
Crash
Annotation
%
s
:
%
s
"
CrashReporter
:
:
AnnotationToString
(
mCrashCriticalKey
)
message
.
str
(
)
.
c_str
(
)
)
;
}
}
class
LogForwarderEvent
:
public
Runnable
{
virtual
~
LogForwarderEvent
(
)
=
default
;
public
:
NS_INLINE_DECL_REFCOUNTING_INHERITED
(
LogForwarderEvent
Runnable
)
explicit
LogForwarderEvent
(
const
nsCString
&
aMessage
)
:
mozilla
:
:
Runnable
(
"
LogForwarderEvent
"
)
mMessage
(
aMessage
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
&
&
(
XRE_IsContentProcess
(
)
|
|
XRE_IsGPUProcess
(
)
)
)
;
if
(
XRE_IsContentProcess
(
)
)
{
dom
:
:
ContentChild
*
cc
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
Unused
<
<
cc
-
>
SendGraphicsError
(
mMessage
)
;
}
else
if
(
XRE_IsGPUProcess
(
)
)
{
GPUParent
*
gp
=
GPUParent
:
:
GetSingleton
(
)
;
Unused
<
<
gp
-
>
SendGraphicsError
(
mMessage
)
;
}
return
NS_OK
;
}
protected
:
nsCString
mMessage
;
}
;
void
CrashStatsLogForwarder
:
:
Log
(
const
std
:
:
string
&
aString
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
UpdateStringsVector
(
aString
)
)
{
UpdateCrashReport
(
)
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
nsCString
stringToSend
(
aString
.
c_str
(
)
)
;
if
(
NS_IsMainThread
(
)
)
{
if
(
XRE_IsContentProcess
(
)
)
{
dom
:
:
ContentChild
*
cc
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
Unused
<
<
cc
-
>
SendGraphicsError
(
stringToSend
)
;
}
else
if
(
XRE_IsGPUProcess
(
)
)
{
GPUParent
*
gp
=
GPUParent
:
:
GetSingleton
(
)
;
Unused
<
<
gp
-
>
SendGraphicsError
(
stringToSend
)
;
}
}
else
{
nsCOMPtr
<
nsIRunnable
>
r1
=
new
LogForwarderEvent
(
stringToSend
)
;
NS_DispatchToMainThread
(
r1
)
;
}
}
}
class
CrashTelemetryEvent
:
public
Runnable
{
virtual
~
CrashTelemetryEvent
(
)
=
default
;
public
:
NS_INLINE_DECL_REFCOUNTING_INHERITED
(
CrashTelemetryEvent
Runnable
)
explicit
CrashTelemetryEvent
(
uint32_t
aReason
)
:
mozilla
:
:
Runnable
(
"
CrashTelemetryEvent
"
)
mReason
(
aReason
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GFX_CRASH
mReason
)
;
return
NS_OK
;
}
protected
:
uint32_t
mReason
;
}
;
void
CrashStatsLogForwarder
:
:
CrashAction
(
LogReason
aReason
)
{
#
ifndef
RELEASE_OR_BETA
static
bool
useTelemetry
=
gfxEnv
:
:
MOZ_GFX_CRASH_TELEMETRY
(
)
;
#
else
static
bool
useTelemetry
=
!
gfxEnv
:
:
MOZ_GFX_CRASH_MOZ_CRASH
(
)
;
#
endif
if
(
useTelemetry
)
{
if
(
NS_IsMainThread
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GFX_CRASH
(
uint32_t
)
aReason
)
;
}
else
{
nsCOMPtr
<
nsIRunnable
>
r1
=
new
CrashTelemetryEvent
(
(
uint32_t
)
aReason
)
;
NS_DispatchToMainThread
(
r1
)
;
}
}
else
{
MOZ_CRASH
(
"
GFX_CRASH
"
)
;
}
}
#
define
GFX_DOWNLOADABLE_FONTS_ENABLED
"
gfx
.
downloadable_fonts
.
enabled
"
#
define
GFX_PREF_FALLBACK_USE_CMAPS
\
"
gfx
.
font_rendering
.
fallback
.
always_use_cmaps
"
#
define
GFX_PREF_OPENTYPE_SVG
"
gfx
.
font_rendering
.
opentype_svg
.
enabled
"
#
define
GFX_PREF_WORD_CACHE_CHARLIMIT
"
gfx
.
font_rendering
.
wordcache
.
charlimit
"
#
define
GFX_PREF_WORD_CACHE_MAXENTRIES
"
gfx
.
font_rendering
.
wordcache
.
maxentries
"
#
define
GFX_PREF_GRAPHITE_SHAPING
"
gfx
.
font_rendering
.
graphite
.
enabled
"
#
if
defined
(
XP_MACOSX
)
#
define
GFX_PREF_CORETEXT_SHAPING
"
gfx
.
font_rendering
.
coretext
.
enabled
"
#
endif
#
define
FONT_VARIATIONS_PREF
"
layout
.
css
.
font
-
variations
.
enabled
"
static
const
char
*
kObservedPrefs
[
]
=
{
"
gfx
.
downloadable_fonts
.
"
"
gfx
.
font_rendering
.
"
nullptr
}
;
static
void
FontPrefChanged
(
const
char
*
aPref
void
*
aData
)
{
MOZ_ASSERT
(
aPref
)
;
NS_ASSERTION
(
gfxPlatform
:
:
GetPlatform
(
)
"
the
singleton
instance
has
gone
"
)
;
gfxPlatform
:
:
GetPlatform
(
)
-
>
FontsPrefsChanged
(
aPref
)
;
}
void
gfxPlatform
:
:
OnMemoryPressure
(
layers
:
:
MemoryPressureReason
aWhy
)
{
Factory
:
:
PurgeAllCaches
(
)
;
gfxGradientCache
:
:
PurgeAllCaches
(
)
;
gfxFontMissingGlyphs
:
:
Purge
(
)
;
PurgeSkiaFontCache
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
layers
:
:
CompositorManagerChild
*
manager
=
CompositorManagerChild
:
:
GetInstance
(
)
;
if
(
manager
)
{
manager
-
>
SendNotifyMemoryPressure
(
)
;
}
}
}
gfxPlatform
:
:
gfxPlatform
(
)
:
mAzureCanvasBackendCollector
(
this
&
gfxPlatform
:
:
GetAzureBackendInfo
)
mApzSupportCollector
(
this
&
gfxPlatform
:
:
GetApzSupportInfo
)
mFrameStatsCollector
(
this
&
gfxPlatform
:
:
GetFrameStats
)
mCMSInfoCollector
(
this
&
gfxPlatform
:
:
GetCMSSupportInfo
)
mDisplayInfoCollector
(
this
&
gfxPlatform
:
:
GetDisplayInfo
)
mOverlayInfoCollector
(
this
&
gfxPlatform
:
:
GetOverlayInfo
)
mCompositorBackend
(
layers
:
:
LayersBackend
:
:
LAYERS_NONE
)
mScreenDepth
(
0
)
{
mAllowDownloadableFonts
=
UNINITIALIZED_VALUE
;
InitBackendPrefs
(
GetBackendPrefs
(
)
)
;
VRManager
:
:
ManagerInit
(
)
;
}
gfxPlatform
*
gfxPlatform
:
:
GetPlatform
(
)
{
if
(
!
gPlatform
)
{
MOZ_RELEASE_ASSERT
(
!
XRE_IsContentProcess
(
)
"
Content
Process
should
have
called
InitChild
(
)
before
"
"
first
GetPlatform
(
)
"
)
;
Init
(
)
;
}
return
gPlatform
;
}
bool
gfxPlatform
:
:
Initialized
(
)
{
return
!
!
gPlatform
;
}
void
gfxPlatform
:
:
InitChild
(
const
ContentDeviceData
&
aData
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
gPlatform
"
InitChild
(
)
should
be
called
before
first
GetPlatform
(
)
"
)
;
gContentDeviceInitData
=
&
aData
;
Init
(
)
;
gContentDeviceInitData
=
nullptr
;
}
#
define
WR_DEBUG_PREF
"
gfx
.
webrender
.
debug
"
static
void
SwapIntervalPrefChangeCallback
(
const
char
*
aPrefName
void
*
)
{
bool
egl
=
Preferences
:
:
GetBool
(
"
gfx
.
swap
-
interval
.
egl
"
false
)
;
bool
glx
=
Preferences
:
:
GetBool
(
"
gfx
.
swap
-
interval
.
glx
"
false
)
;
gfxVars
:
:
SetSwapIntervalEGL
(
egl
)
;
gfxVars
:
:
SetSwapIntervalGLX
(
glx
)
;
}
static
void
WebRendeProfilerUIPrefChangeCallback
(
const
char
*
aPrefName
void
*
)
{
nsCString
uiString
;
if
(
NS_SUCCEEDED
(
Preferences
:
:
GetCString
(
"
gfx
.
webrender
.
debug
.
profiler
-
ui
"
uiString
)
)
)
{
gfxVars
:
:
SetWebRenderProfilerUI
(
uiString
)
;
}
}
#
define
WR_BOOL_PARAMETER_LIST
(
_
)
\
_
(
"
gfx
.
webrender
.
batched
-
texture
-
uploads
"
\
wr
:
:
BoolParameter
:
:
BatchedUploads
true
)
\
_
(
"
gfx
.
webrender
.
draw
-
calls
-
for
-
texture
-
copy
"
\
wr
:
:
BoolParameter
:
:
DrawCallsForTextureCopy
true
)
\
_
(
"
gfx
.
webrender
.
pbo
-
uploads
"
wr
:
:
BoolParameter
:
:
PboUploads
true
)
\
_
(
"
gfx
.
webrender
.
multithreading
"
wr
:
:
BoolParameter
:
:
Multithreading
true
)
static
void
WebRenderBoolParameterChangeCallback
(
const
char
*
void
*
)
{
uint32_t
bits
=
0
;
#
define
WR_BOOL_PARAMETER
(
name
key
default_val
)
\
if
(
Preferences
:
:
GetBool
(
name
default_val
)
)
{
\
bits
|
=
1
<
<
(
uint32_t
)
key
;
\
}
WR_BOOL_PARAMETER_LIST
(
WR_BOOL_PARAMETER
)
#
undef
WR_BOOL_PARAMETER
gfx
:
:
gfxVars
:
:
SetWebRenderBoolParameters
(
bits
)
;
}
static
void
RegisterWebRenderBoolParamCallback
(
)
{
#
define
WR_BOOL_PARAMETER
(
name
_key
_default_val
)
\
Preferences
:
:
RegisterCallback
(
WebRenderBoolParameterChangeCallback
name
)
;
WR_BOOL_PARAMETER_LIST
(
WR_BOOL_PARAMETER
)
#
undef
WR_BOOL_PARAMETER
WebRenderBoolParameterChangeCallback
(
nullptr
nullptr
)
;
}
static
void
WebRenderDebugPrefChangeCallback
(
const
char
*
aPrefName
void
*
)
{
wr
:
:
DebugFlags
flags
{
0
}
;
#
define
GFX_WEBRENDER_DEBUG
(
suffix
bit
)
\
if
(
Preferences
:
:
GetBool
(
WR_DEBUG_PREF
suffix
false
)
)
{
\
flags
|
=
(
bit
)
;
\
}
GFX_WEBRENDER_DEBUG
(
"
.
profiler
"
wr
:
:
DebugFlags
:
:
PROFILER_DBG
)
GFX_WEBRENDER_DEBUG
(
"
.
render
-
targets
"
wr
:
:
DebugFlags
:
:
RENDER_TARGET_DBG
)
GFX_WEBRENDER_DEBUG
(
"
.
texture
-
cache
"
wr
:
:
DebugFlags
:
:
TEXTURE_CACHE_DBG
)
GFX_WEBRENDER_DEBUG
(
"
.
gpu
-
time
-
queries
"
wr
:
:
DebugFlags
:
:
GPU_TIME_QUERIES
)
GFX_WEBRENDER_DEBUG
(
"
.
gpu
-
sample
-
queries
"
wr
:
:
DebugFlags
:
:
GPU_SAMPLE_QUERIES
)
GFX_WEBRENDER_DEBUG
(
"
.
disable
-
batching
"
wr
:
:
DebugFlags
:
:
DISABLE_BATCHING
)
GFX_WEBRENDER_DEBUG
(
"
.
epochs
"
wr
:
:
DebugFlags
:
:
EPOCHS
)
GFX_WEBRENDER_DEBUG
(
"
.
smart
-
profiler
"
wr
:
:
DebugFlags
:
:
SMART_PROFILER
)
GFX_WEBRENDER_DEBUG
(
"
.
echo
-
driver
-
messages
"
wr
:
:
DebugFlags
:
:
ECHO_DRIVER_MESSAGES
)
GFX_WEBRENDER_DEBUG
(
"
.
show
-
overdraw
"
wr
:
:
DebugFlags
:
:
SHOW_OVERDRAW
)
GFX_WEBRENDER_DEBUG
(
"
.
gpu
-
cache
"
wr
:
:
DebugFlags
:
:
GPU_CACHE_DBG
)
GFX_WEBRENDER_DEBUG
(
"
.
texture
-
cache
.
clear
-
evicted
"
wr
:
:
DebugFlags
:
:
TEXTURE_CACHE_DBG_CLEAR_EVICTED
)
GFX_WEBRENDER_DEBUG
(
"
.
picture
-
caching
"
wr
:
:
DebugFlags
:
:
PICTURE_CACHING_DBG
)
GFX_WEBRENDER_DEBUG
(
"
.
force
-
picture
-
invalidation
"
wr
:
:
DebugFlags
:
:
FORCE_PICTURE_INVALIDATION
)
GFX_WEBRENDER_DEBUG
(
"
.
primitives
"
wr
:
:
DebugFlags
:
:
PRIMITIVE_DBG
)
GFX_WEBRENDER_DEBUG
(
"
.
small
-
screen
"
wr
:
:
DebugFlags
:
:
SMALL_SCREEN
)
GFX_WEBRENDER_DEBUG
(
"
.
disable
-
opaque
-
pass
"
wr
:
:
DebugFlags
:
:
DISABLE_OPAQUE_PASS
)
GFX_WEBRENDER_DEBUG
(
"
.
disable
-
alpha
-
pass
"
wr
:
:
DebugFlags
:
:
DISABLE_ALPHA_PASS
)
GFX_WEBRENDER_DEBUG
(
"
.
disable
-
clip
-
masks
"
wr
:
:
DebugFlags
:
:
DISABLE_CLIP_MASKS
)
GFX_WEBRENDER_DEBUG
(
"
.
disable
-
text
-
prims
"
wr
:
:
DebugFlags
:
:
DISABLE_TEXT_PRIMS
)
GFX_WEBRENDER_DEBUG
(
"
.
disable
-
gradient
-
prims
"
wr
:
:
DebugFlags
:
:
DISABLE_GRADIENT_PRIMS
)
GFX_WEBRENDER_DEBUG
(
"
.
obscure
-
images
"
wr
:
:
DebugFlags
:
:
OBSCURE_IMAGES
)
GFX_WEBRENDER_DEBUG
(
"
.
glyph
-
flashing
"
wr
:
:
DebugFlags
:
:
GLYPH_FLASHING
)
GFX_WEBRENDER_DEBUG
(
"
.
capture
-
profiler
"
wr
:
:
DebugFlags
:
:
PROFILER_CAPTURE
)
GFX_WEBRENDER_DEBUG
(
"
.
window
-
visibility
"
wr
:
:
DebugFlags
:
:
WINDOW_VISIBILITY_DBG
)
#
undef
GFX_WEBRENDER_DEBUG
gfx
:
:
gfxVars
:
:
SetWebRenderDebugFlags
(
flags
.
bits
)
;
}
static
void
WebRenderQualityPrefChangeCallback
(
const
char
*
aPref
void
*
)
{
gfxPlatform
:
:
GetPlatform
(
)
-
>
UpdateForceSubpixelAAWherePossible
(
)
;
}
static
void
WebRenderBatchingPrefChangeCallback
(
const
char
*
aPrefName
void
*
)
{
uint32_t
count
=
Preferences
:
:
GetUint
(
StaticPrefs
:
:
GetPrefName_gfx_webrender_batching_lookback
(
)
10
)
;
gfx
:
:
gfxVars
:
:
SetWebRenderBatchingLookback
(
count
)
;
}
static
void
WebRenderBlobTileSizePrefChangeCallback
(
const
char
*
aPrefName
void
*
)
{
uint32_t
tileSize
=
Preferences
:
:
GetUint
(
StaticPrefs
:
:
GetPrefName_gfx_webrender_blob_tile_size
(
)
256
)
;
gfx
:
:
gfxVars
:
:
SetWebRenderBlobTileSize
(
tileSize
)
;
}
static
void
WebRenderUploadThresholdPrefChangeCallback
(
const
char
*
aPrefName
void
*
)
{
int
value
=
Preferences
:
:
GetInt
(
StaticPrefs
:
:
GetPrefName_gfx_webrender_batched_upload_threshold
(
)
512
*
512
)
;
gfxVars
:
:
SetWebRenderBatchedUploadThreshold
(
value
)
;
}
static
uint32_t
GetSkiaGlyphCacheSize
(
)
{
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
uint32_t
cacheSize
=
StaticPrefs
:
:
gfx_content_skia_font_cache_size_AtStartup
(
)
*
1024
*
1024
;
if
(
mozilla
:
:
BrowserTabsRemoteAutostart
(
)
)
{
return
XRE_IsContentProcess
(
)
?
cacheSize
:
kDefaultGlyphCacheSize
;
}
return
cacheSize
;
#
else
return
kDefaultGlyphCacheSize
;
#
endif
}
class
WebRenderMemoryReporter
final
:
public
nsIMemoryReporter
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIMEMORYREPORTER
private
:
~
WebRenderMemoryReporter
(
)
=
default
;
}
;
struct
WebRenderMemoryReporterHelper
{
WebRenderMemoryReporterHelper
(
nsIHandleReportCallback
*
aCallback
nsISupports
*
aData
)
:
mCallback
(
aCallback
)
mData
(
aData
)
{
}
nsCOMPtr
<
nsIHandleReportCallback
>
mCallback
;
nsCOMPtr
<
nsISupports
>
mData
;
void
Report
(
size_t
aBytes
const
char
*
aName
)
const
{
nsPrintfCString
path
(
"
explicit
/
gfx
/
webrender
/
%
s
"
aName
)
;
nsCString
desc
(
"
CPU
heap
memory
used
by
WebRender
"
_ns
)
;
ReportInternal
(
aBytes
path
desc
nsIMemoryReporter
:
:
KIND_HEAP
)
;
}
void
ReportTexture
(
size_t
aBytes
const
char
*
aName
)
const
{
nsPrintfCString
path
(
"
gfx
/
webrender
/
textures
/
%
s
"
aName
)
;
nsCString
desc
(
"
GPU
texture
memory
used
by
WebRender
"
_ns
)
;
ReportInternal
(
aBytes
path
desc
nsIMemoryReporter
:
:
KIND_OTHER
)
;
}
void
ReportTotalGPUBytes
(
size_t
aBytes
)
const
{
nsCString
path
(
"
gfx
/
webrender
/
total
-
gpu
-
bytes
"
_ns
)
;
nsCString
desc
(
nsLiteralCString
(
"
Total
GPU
bytes
used
by
WebRender
(
should
match
textures
/
sum
)
"
)
)
;
ReportInternal
(
aBytes
path
desc
nsIMemoryReporter
:
:
KIND_OTHER
)
;
}
void
ReportInternal
(
size_t
aBytes
nsACString
&
aPath
nsACString
&
aDesc
int32_t
aKind
)
const
{
nsAutoCString
processName
;
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
)
{
GPUParent
:
:
GetGPUProcessName
(
processName
)
;
}
mCallback
-
>
Callback
(
processName
aPath
aKind
nsIMemoryReporter
:
:
UNITS_BYTES
aBytes
aDesc
mData
)
;
}
}
;
static
void
FinishAsyncMemoryReport
(
)
{
nsCOMPtr
<
nsIMemoryReporterManager
>
imgr
=
do_GetService
(
"
mozilla
.
org
/
memory
-
reporter
-
manager
;
1
"
)
;
if
(
imgr
)
{
imgr
-
>
EndReport
(
)
;
}
}
#
define
REPORT_INTERNER
(
id
)
\
helper
.
Report
(
aReport
.
interning
.
interners
.
id
\
"
interning
/
"
#
id
"
/
interners
"
)
;
#
define
REPORT_DATA_STORE
(
id
)
\
helper
.
Report
(
aReport
.
interning
.
data_stores
.
id
\
"
interning
/
"
#
id
"
/
data
-
stores
"
)
;
NS_IMPL_ISUPPORTS
(
WebRenderMemoryReporter
nsIMemoryReporter
)
NS_IMETHODIMP
WebRenderMemoryReporter
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
layers
:
:
CompositorManagerChild
*
manager
=
CompositorManagerChild
:
:
GetInstance
(
)
;
if
(
!
manager
)
{
FinishAsyncMemoryReport
(
)
;
return
NS_OK
;
}
WebRenderMemoryReporterHelper
helper
(
aHandleReport
aData
)
;
manager
-
>
SendReportMemory
(
[
=
]
(
wr
:
:
MemoryReport
aReport
)
{
helper
.
Report
(
aReport
.
clip_stores
"
clip
-
stores
"
)
;
helper
.
Report
(
aReport
.
gpu_cache_metadata
"
gpu
-
cache
/
metadata
"
)
;
helper
.
Report
(
aReport
.
gpu_cache_cpu_mirror
"
gpu
-
cache
/
cpu
-
mirror
"
)
;
helper
.
Report
(
aReport
.
render_tasks
"
render
-
tasks
"
)
;
helper
.
Report
(
aReport
.
hit_testers
"
hit
-
testers
"
)
;
helper
.
Report
(
aReport
.
fonts
"
resource
-
cache
/
fonts
"
)
;
helper
.
Report
(
aReport
.
weak_fonts
"
resource
-
cache
/
weak
-
fonts
"
)
;
helper
.
Report
(
aReport
.
images
"
resource
-
cache
/
images
"
)
;
helper
.
Report
(
aReport
.
rasterized_blobs
"
resource
-
cache
/
rasterized
-
blobs
"
)
;
helper
.
Report
(
aReport
.
texture_cache_structures
"
texture
-
cache
/
structures
"
)
;
helper
.
Report
(
aReport
.
shader_cache
"
shader
-
cache
"
)
;
helper
.
Report
(
aReport
.
display_list
"
display
-
list
"
)
;
helper
.
Report
(
aReport
.
swgl
"
swgl
"
)
;
helper
.
Report
(
aReport
.
upload_staging_memory
"
upload
-
stagin
-
memory
"
)
;
WEBRENDER_FOR_EACH_INTERNER
(
REPORT_INTERNER
)
;
WEBRENDER_FOR_EACH_INTERNER
(
REPORT_DATA_STORE
)
;
helper
.
ReportTexture
(
aReport
.
gpu_cache_textures
"
gpu
-
cache
"
)
;
helper
.
ReportTexture
(
aReport
.
vertex_data_textures
"
vertex
-
data
"
)
;
helper
.
ReportTexture
(
aReport
.
render_target_textures
"
render
-
targets
"
)
;
helper
.
ReportTexture
(
aReport
.
depth_target_textures
"
depth
-
targets
"
)
;
helper
.
ReportTexture
(
aReport
.
picture_tile_textures
"
picture
-
tiles
"
)
;
helper
.
ReportTexture
(
aReport
.
atlas_textures
"
texture
-
cache
/
atlas
"
)
;
helper
.
ReportTexture
(
aReport
.
standalone_textures
"
texture
-
cache
/
standalone
"
)
;
helper
.
ReportTexture
(
aReport
.
texture_upload_pbos
"
texture
-
upload
-
pbos
"
)
;
helper
.
ReportTexture
(
aReport
.
swap_chain
"
swap
-
chains
"
)
;
helper
.
ReportTexture
(
aReport
.
render_texture_hosts
"
render
-
texture
-
hosts
"
)
;
helper
.
ReportTexture
(
aReport
.
upload_staging_textures
"
upload
-
staging
-
textures
"
)
;
FinishAsyncMemoryReport
(
)
;
}
[
]
(
mozilla
:
:
ipc
:
:
ResponseRejectReason
&
&
aReason
)
{
FinishAsyncMemoryReport
(
)
;
}
)
;
return
NS_OK
;
}
#
undef
REPORT_INTERNER
#
undef
REPORT_DATA_STORE
std
:
:
atomic
<
int8_t
>
gfxPlatform
:
:
sHasVariationFontSupport
=
-
1
;
bool
gfxPlatform
:
:
HasVariationFontSupport
(
)
{
if
(
sHasVariationFontSupport
<
0
)
{
#
if
defined
(
XP_WIN
)
sHasVariationFontSupport
=
gfxWindowsPlatform
:
:
CheckVariationFontSupport
(
)
;
#
elif
defined
(
XP_MACOSX
)
sHasVariationFontSupport
=
gfxPlatformMac
:
:
CheckVariationFontSupport
(
)
;
#
elif
defined
(
MOZ_WIDGET_GTK
)
sHasVariationFontSupport
=
gfxPlatformGtk
:
:
CheckVariationFontSupport
(
)
;
#
elif
defined
(
ANDROID
)
sHasVariationFontSupport
=
gfxAndroidPlatform
:
:
CheckVariationFontSupport
(
)
;
#
else
#
error
"
No
gfxPlatform
implementation
available
"
#
endif
}
return
sHasVariationFontSupport
>
0
;
}
void
gfxPlatform
:
:
Init
(
)
{
MOZ_RELEASE_ASSERT
(
!
XRE_IsGPUProcess
(
)
"
GFX
:
Not
allowed
in
GPU
process
.
"
)
;
MOZ_RELEASE_ASSERT
(
!
XRE_IsRDDProcess
(
)
"
GFX
:
Not
allowed
in
RDD
process
.
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
"
GFX
:
Not
in
main
thread
.
"
)
;
if
(
gEverInitialized
)
{
MOZ_CRASH
(
"
Already
started
?
?
?
"
)
;
}
gEverInitialized
=
true
;
gfxVars
:
:
Initialize
(
)
;
gfxConfig
:
:
Init
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
GPUProcessManager
:
:
Initialize
(
)
;
RDDProcessManager
:
:
Initialize
(
)
;
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_GRE_DIR
getter_AddRefs
(
file
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
gfxVars
:
:
SetGREDirectory
(
nsString
(
)
)
;
}
else
{
nsAutoString
path
;
file
-
>
GetPath
(
path
)
;
gfxVars
:
:
SetGREDirectory
(
nsString
(
path
)
)
;
}
}
if
(
XRE_IsParentProcess
(
)
)
{
nsCOMPtr
<
nsIFile
>
profDir
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_PROFILE_DIR_STARTUP
getter_AddRefs
(
profDir
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
gfxVars
:
:
SetProfDirectory
(
nsString
(
)
)
;
}
else
{
nsAutoString
path
;
profDir
-
>
GetPath
(
path
)
;
gfxVars
:
:
SetProfDirectory
(
nsString
(
path
)
)
;
}
nsAutoCString
path
;
Preferences
:
:
GetCString
(
"
layers
.
windowrecording
.
path
"
path
)
;
gfxVars
:
:
SetLayersWindowRecordingPath
(
path
)
;
if
(
gFxREmbedded
)
{
gfxVars
:
:
SetFxREmbedded
(
true
)
;
}
}
{
nsAutoCString
forcedPrefs
;
forcedPrefs
.
AppendPrintf
(
"
FP
(
D
%
d
%
d
"
StaticPrefs
:
:
gfx_direct2d_disabled_AtStartup
(
)
StaticPrefs
:
:
gfx_direct2d_force_enabled_AtStartup
(
)
)
;
forcedPrefs
.
AppendPrintf
(
"
-
L
%
d
%
d
%
d
%
d
"
StaticPrefs
:
:
layers_amd_switchable_gfx_enabled_AtStartup
(
)
StaticPrefs
:
:
layers_acceleration_disabled_AtStartup_DoNotUseDirectly
(
)
StaticPrefs
:
:
layers_acceleration_force_enabled_AtStartup_DoNotUseDirectly
(
)
StaticPrefs
:
:
layers_d3d11_force_warp_AtStartup
(
)
)
;
forcedPrefs
.
AppendPrintf
(
"
-
W
%
d
%
d
%
d
%
d
%
d
%
d
%
d
%
d
"
StaticPrefs
:
:
webgl_angle_force_d3d11
(
)
StaticPrefs
:
:
webgl_angle_force_warp
(
)
StaticPrefs
:
:
webgl_disabled
(
)
StaticPrefs
:
:
webgl_disable_angle
(
)
StaticPrefs
:
:
webgl_dxgl_enabled
(
)
StaticPrefs
:
:
webgl_force_enabled
(
)
StaticPrefs
:
:
webgl_force_layers_readback
(
)
StaticPrefs
:
:
webgl_msaa_force
(
)
)
;
forcedPrefs
.
AppendPrintf
(
"
-
T
%
d
%
d
%
d
)
"
StaticPrefs
:
:
gfx_android_rgb16_force_AtStartup
(
)
StaticPrefs
:
:
gfx_canvas_accelerated
(
)
StaticPrefs
:
:
layers_force_shmem_tiles_AtStartup
(
)
)
;
ScopedGfxFeatureReporter
:
:
AppNote
(
forcedPrefs
)
;
}
InitMoz2DLogging
(
)
;
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
;
gfxInfo
=
components
:
:
GfxInfo
:
:
Service
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetDXInterop2Blocked
(
IsDXInterop2Blocked
(
)
)
;
gfxVars
:
:
SetDXNV12Blocked
(
IsDXNV12Blocked
(
)
)
;
gfxVars
:
:
SetDXP010Blocked
(
IsDXP010Blocked
(
)
)
;
gfxVars
:
:
SetDXP016Blocked
(
IsDXP016Blocked
(
)
)
;
}
#
if
defined
(
XP_WIN
)
gPlatform
=
new
gfxWindowsPlatform
;
#
elif
defined
(
XP_MACOSX
)
gPlatform
=
new
gfxPlatformMac
;
#
elif
defined
(
MOZ_WIDGET_GTK
)
gPlatform
=
new
gfxPlatformGtk
;
#
elif
defined
(
ANDROID
)
gPlatform
=
new
gfxAndroidPlatform
;
#
else
#
error
"
No
gfxPlatform
implementation
available
"
#
endif
gPlatform
-
>
PopulateScreenInfo
(
)
;
gPlatform
-
>
InitAcceleration
(
)
;
gPlatform
-
>
InitWebRenderConfig
(
)
;
gPlatform
-
>
InitHardwareVideoConfig
(
)
;
gPlatform
-
>
InitWebGLConfig
(
)
;
gPlatform
-
>
InitWebGPUConfig
(
)
;
gPlatform
-
>
InitWindowOcclusionConfig
(
)
;
gPlatform
-
>
InitBackdropFilterConfig
(
)
;
if
(
!
UseWebRender
(
)
#
if
defined
(
XP_WIN
)
|
|
(
UseWebRender
(
)
&
&
XRE_IsParentProcess
(
)
&
&
!
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
&
&
StaticPrefs
:
:
gfx_webrender_enabled_no_gpu_process_with_angle_win_AtStartup
(
)
)
#
endif
)
{
gPlatform
-
>
EnsureDevicesInitialized
(
)
;
}
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
)
{
GPUProcessManager
*
gpu
=
GPUProcessManager
:
:
Get
(
)
;
Unused
<
<
gpu
-
>
LaunchGPUProcess
(
)
;
}
if
(
XRE_IsParentProcess
(
)
)
{
RefPtr
<
VsyncSource
>
vsyncSource
=
gfxPlatform
:
:
ForceSoftwareVsync
(
)
?
gPlatform
-
>
GetSoftwareVsyncSource
(
)
:
gPlatform
-
>
GetGlobalHardwareVsyncSource
(
)
;
gPlatform
-
>
mVsyncDispatcher
=
new
VsyncDispatcher
(
vsyncSource
)
;
Preferences
:
:
RegisterCallback
(
gfxPlatform
:
:
ReInitFrameRate
nsDependentCString
(
StaticPrefs
:
:
GetPrefName_layout_frame_rate
(
)
)
)
;
Preferences
:
:
RegisterCallback
(
gfxPlatform
:
:
ReInitFrameRate
nsDependentCString
(
StaticPrefs
:
:
GetPrefName_privacy_resistFingerprinting
(
)
)
)
;
}
InitializeCMS
(
)
;
SkGraphics
:
:
Init
(
)
;
#
ifdef
MOZ_ENABLE_FREETYPE
SkInitCairoFT
(
gPlatform
-
>
FontHintingEnabled
(
)
)
;
#
endif
gfxGradientCache
:
:
Init
(
)
;
InitLayersIPC
(
)
;
if
(
!
gPlatform
-
>
CreatePlatformFontList
(
)
)
{
MOZ_CRASH
(
"
Could
not
initialize
gfxPlatformFontList
"
)
;
}
gPlatform
-
>
mScreenReferenceDrawTarget
=
gPlatform
-
>
CreateOffscreenContentDrawTarget
(
IntSize
(
1
1
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
gPlatform
-
>
mScreenReferenceDrawTarget
|
|
!
gPlatform
-
>
mScreenReferenceDrawTarget
-
>
IsValid
(
)
)
{
if
(
!
gPlatform
-
>
DidRenderingDeviceReset
(
)
)
{
gfxCriticalError
(
)
<
<
"
Could
not
initialize
mScreenReferenceDrawTarget
"
;
}
}
if
(
NS_FAILED
(
gfxFontCache
:
:
Init
(
)
)
)
{
MOZ_CRASH
(
"
Could
not
initialize
gfxFontCache
"
)
;
}
Preferences
:
:
RegisterPrefixCallbacks
(
FontPrefChanged
kObservedPrefs
)
;
GLContext
:
:
PlatformStartup
(
)
;
gPlatform
-
>
mMemoryPressureObserver
=
layers
:
:
MemoryPressureObserver
:
:
Create
(
gPlatform
)
;
nsCOMPtr
<
imgITools
>
imgTools
=
do_GetService
(
"
mozilla
.
org
/
image
/
tools
;
1
"
)
;
if
(
!
imgTools
)
{
MOZ_CRASH
(
"
Could
not
initialize
ImageLib
"
)
;
}
RegisterStrongMemoryReporter
(
new
GfxMemoryImageReporter
(
)
)
;
if
(
XRE_IsParentProcess
(
)
&
&
UseWebRender
(
)
)
{
RegisterStrongAsyncMemoryReporter
(
new
WebRenderMemoryReporter
(
)
)
;
}
RegisterStrongMemoryReporter
(
new
SkMemoryReporter
(
)
)
;
uint32_t
skiaCacheSize
=
GetSkiaGlyphCacheSize
(
)
;
if
(
skiaCacheSize
!
=
kDefaultGlyphCacheSize
)
{
SkGraphics
:
:
SetFontCacheLimit
(
skiaCacheSize
)
;
}
InitNullMetadata
(
)
;
InitOpenGLConfig
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
Preferences
:
:
Unlock
(
FONT_VARIATIONS_PREF
)
;
if
(
!
gfxPlatform
:
:
HasVariationFontSupport
(
)
)
{
Preferences
:
:
SetBool
(
FONT_VARIATIONS_PREF
false
PrefValueKind
:
:
Default
)
;
Preferences
:
:
SetBool
(
FONT_VARIATIONS_PREF
false
)
;
Preferences
:
:
Lock
(
FONT_VARIATIONS_PREF
)
;
}
}
if
(
XRE_IsParentProcess
(
)
)
{
ReportTelemetry
(
)
;
}
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
nullptr
"
gfx
-
features
-
ready
"
nullptr
)
;
}
}
void
gfxPlatform
:
:
ReportTelemetry
(
)
{
MOZ_RELEASE_ASSERT
(
XRE_IsParentProcess
(
)
"
GFX
:
Only
allowed
to
be
called
from
parent
process
.
"
)
;
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
components
:
:
GfxInfo
:
:
Service
(
)
;
{
auto
&
screenManager
=
widget
:
:
ScreenManager
:
:
GetSingleton
(
)
;
const
uint32_t
screenCount
=
screenManager
.
CurrentScreenList
(
)
.
Length
(
)
;
RefPtr
<
widget
:
:
Screen
>
primaryScreen
=
screenManager
.
GetPrimaryScreen
(
)
;
const
LayoutDeviceIntRect
rect
=
primaryScreen
-
>
GetRect
(
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_DISPLAY_COUNT
screenCount
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_DISPLAY_PRIMARY_HEIGHT
uint32_t
(
rect
.
Height
(
)
)
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_DISPLAY_PRIMARY_WIDTH
uint32_t
(
rect
.
Width
(
)
)
)
;
}
nsString
adapterDesc
;
gfxInfo
-
>
GetAdapterDescription
(
adapterDesc
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_ADAPTER_DESCRIPTION
adapterDesc
)
;
nsString
adapterVendorId
;
gfxInfo
-
>
GetAdapterVendorID
(
adapterVendorId
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_ADAPTER_VENDOR_ID
adapterVendorId
)
;
nsString
adapterDeviceId
;
gfxInfo
-
>
GetAdapterDeviceID
(
adapterDeviceId
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_ADAPTER_DEVICE_ID
adapterDeviceId
)
;
nsString
adapterSubsystemId
;
gfxInfo
-
>
GetAdapterSubsysID
(
adapterSubsystemId
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_ADAPTER_SUBSYSTEM_ID
adapterSubsystemId
)
;
uint32_t
adapterRam
=
0
;
gfxInfo
-
>
GetAdapterRAM
(
&
adapterRam
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_ADAPTER_RAM
adapterRam
)
;
nsString
adapterDriver
;
gfxInfo
-
>
GetAdapterDriver
(
adapterDriver
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_ADAPTER_DRIVER_FILES
adapterDriver
)
;
nsString
adapterDriverVendor
;
gfxInfo
-
>
GetAdapterDriverVendor
(
adapterDriverVendor
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_ADAPTER_DRIVER_VENDOR
adapterDriverVendor
)
;
nsString
adapterDriverVersion
;
gfxInfo
-
>
GetAdapterDriverVersion
(
adapterDriverVersion
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_ADAPTER_DRIVER_VERSION
adapterDriverVersion
)
;
nsString
adapterDriverDate
;
gfxInfo
-
>
GetAdapterDriverDate
(
adapterDriverDate
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_ADAPTER_DRIVER_DATE
adapterDriverDate
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_HEADLESS
IsHeadless
(
)
)
;
}
static
bool
IsFeatureSupported
(
long
aFeature
bool
aDefault
)
{
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
components
:
:
GfxInfo
:
:
Service
(
)
;
nsCString
blockId
;
int32_t
status
;
if
(
!
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
aFeature
blockId
&
status
)
)
)
{
return
aDefault
;
}
return
status
=
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
;
}
bool
gfxPlatform
:
:
IsDXInterop2Blocked
(
)
{
return
!
IsFeatureSupported
(
nsIGfxInfo
:
:
FEATURE_DX_INTEROP2
false
)
;
}
bool
gfxPlatform
:
:
IsDXNV12Blocked
(
)
{
return
!
IsFeatureSupported
(
nsIGfxInfo
:
:
FEATURE_DX_NV12
false
)
;
}
bool
gfxPlatform
:
:
IsDXP010Blocked
(
)
{
return
!
IsFeatureSupported
(
nsIGfxInfo
:
:
FEATURE_DX_P010
false
)
;
}
bool
gfxPlatform
:
:
IsDXP016Blocked
(
)
{
return
!
IsFeatureSupported
(
nsIGfxInfo
:
:
FEATURE_DX_P016
false
)
;
}
int32_t
gfxPlatform
:
:
MaxTextureSize
(
)
{
const
int32_t
kMinSizePref
=
2048
;
return
std
:
:
max
(
kMinSizePref
StaticPrefs
:
:
gfx_max_texture_size_AtStartup_DoNotUseDirectly
(
)
)
;
}
int32_t
gfxPlatform
:
:
MaxAllocSize
(
)
{
const
int32_t
kMinAllocPref
=
10000000
;
return
std
:
:
max
(
kMinAllocPref
StaticPrefs
:
:
gfx_max_alloc_size_AtStartup_DoNotUseDirectly
(
)
)
;
}
void
gfxPlatform
:
:
InitMoz2DLogging
(
)
{
auto
fwd
=
new
CrashStatsLogForwarder
(
CrashReporter
:
:
Annotation
:
:
GraphicsCriticalError
)
;
fwd
-
>
SetCircularBufferSize
(
StaticPrefs
:
:
gfx_logging_crash_length_AtStartup
(
)
)
;
mozilla
:
:
gfx
:
:
Config
cfg
;
cfg
.
mLogForwarder
=
fwd
;
cfg
.
mMaxTextureSize
=
gfxPlatform
:
:
MaxTextureSize
(
)
;
cfg
.
mMaxAllocSize
=
gfxPlatform
:
:
MaxAllocSize
(
)
;
gfx
:
:
Factory
:
:
Init
(
cfg
)
;
}
bool
gfxPlatform
:
:
IsHeadless
(
)
{
static
bool
initialized
=
false
;
static
bool
headless
=
false
;
if
(
!
initialized
)
{
initialized
=
true
;
headless
=
PR_GetEnv
(
"
MOZ_HEADLESS
"
)
;
}
return
headless
;
}
bool
gfxPlatform
:
:
UseWebRender
(
)
{
return
gfx
:
:
gfxVars
:
:
UseWebRender
(
)
;
}
bool
gfxPlatform
:
:
UseRemoteCanvas
(
)
{
return
XRE_IsContentProcess
(
)
&
&
gfx
:
:
gfxVars
:
:
RemoteCanvasEnabled
(
)
;
}
bool
gfxPlatform
:
:
IsBackendAccelerated
(
const
mozilla
:
:
gfx
:
:
BackendType
aBackendType
)
{
return
aBackendType
=
=
BackendType
:
:
DIRECT2D
|
|
aBackendType
=
=
BackendType
:
:
DIRECT2D1_1
;
}
bool
gfxPlatform
:
:
CanMigrateMacGPUs
(
)
{
int32_t
pMigration
=
StaticPrefs
:
:
gfx_compositor_gpu_migration
(
)
;
bool
forceDisable
=
pMigration
=
=
0
;
bool
forceEnable
=
pMigration
=
=
2
;
return
forceEnable
|
|
!
forceDisable
;
}
static
bool
sLayersIPCIsUp
=
false
;
void
gfxPlatform
:
:
InitNullMetadata
(
)
{
ScrollMetadata
:
:
sNullMetadata
=
new
ScrollMetadata
(
)
;
ClearOnShutdown
(
&
ScrollMetadata
:
:
sNullMetadata
)
;
}
void
gfxPlatform
:
:
Shutdown
(
)
{
if
(
!
gPlatform
)
{
return
;
}
MOZ_ASSERT
(
!
sLayersIPCIsUp
)
;
gfxFontCache
:
:
Shutdown
(
)
;
gfxGradientCache
:
:
Shutdown
(
)
;
gfxAlphaBoxBlur
:
:
ShutdownBlurCache
(
)
;
gfxGraphiteShaper
:
:
Shutdown
(
)
;
gfxPlatformFontList
:
:
Shutdown
(
)
;
gfxFontMissingGlyphs
:
:
Shutdown
(
)
;
ShutdownCMS
(
)
;
Preferences
:
:
UnregisterPrefixCallbacks
(
FontPrefChanged
kObservedPrefs
)
;
NS_ASSERTION
(
gPlatform
-
>
mMemoryPressureObserver
"
mMemoryPressureObserver
has
already
gone
"
)
;
if
(
gPlatform
-
>
mMemoryPressureObserver
)
{
gPlatform
-
>
mMemoryPressureObserver
-
>
Unregister
(
)
;
gPlatform
-
>
mMemoryPressureObserver
=
nullptr
;
}
if
(
XRE_IsParentProcess
(
)
)
{
if
(
gPlatform
-
>
mGlobalHardwareVsyncSource
)
{
gPlatform
-
>
mGlobalHardwareVsyncSource
-
>
Shutdown
(
)
;
}
if
(
gPlatform
-
>
mSoftwareVsyncSource
&
&
gPlatform
-
>
mSoftwareVsyncSource
!
=
gPlatform
-
>
mGlobalHardwareVsyncSource
)
{
gPlatform
-
>
mSoftwareVsyncSource
-
>
Shutdown
(
)
;
}
}
gPlatform
-
>
mGlobalHardwareVsyncSource
=
nullptr
;
gPlatform
-
>
mSoftwareVsyncSource
=
nullptr
;
gPlatform
-
>
mVsyncDispatcher
=
nullptr
;
GLContextProvider
:
:
Shutdown
(
)
;
#
if
defined
(
XP_WIN
)
GLContextProviderEGL
:
:
Shutdown
(
)
;
#
endif
if
(
XRE_IsParentProcess
(
)
)
{
GPUProcessManager
:
:
Shutdown
(
)
;
VRProcessManager
:
:
Shutdown
(
)
;
RDDProcessManager
:
:
Shutdown
(
)
;
}
gfx
:
:
Factory
:
:
ShutDown
(
)
;
gfxVars
:
:
Shutdown
(
)
;
gfxFont
:
:
DestroySingletons
(
)
;
gfxConfig
:
:
Shutdown
(
)
;
gPlatform
-
>
WillShutdown
(
)
;
delete
gPlatform
;
gPlatform
=
nullptr
;
}
void
gfxPlatform
:
:
InitLayersIPC
(
)
{
if
(
sLayersIPCIsUp
)
{
return
;
}
sLayersIPCIsUp
=
true
;
if
(
XRE_IsParentProcess
(
)
)
{
#
if
defined
(
XP_WIN
)
if
(
gfxConfig
:
:
IsEnabled
(
gfx
:
:
Feature
:
:
WINDOW_OCCLUSION
)
)
{
widget
:
:
WinWindowOcclusionTracker
:
:
Ensure
(
)
;
}
#
endif
if
(
!
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
&
&
UseWebRender
(
)
)
{
RemoteTextureMap
:
:
Init
(
)
;
if
(
gfxVars
:
:
UseCanvasRenderThread
(
)
)
{
gfx
:
:
CanvasRenderThread
:
:
Start
(
)
;
}
wr
:
:
RenderThread
:
:
Start
(
GPUProcessManager
:
:
Get
(
)
-
>
AllocateNamespace
(
)
)
;
image
:
:
ImageMemoryReporter
:
:
InitForWebRender
(
)
;
}
layers
:
:
CompositorThreadHolder
:
:
Start
(
)
;
}
}
void
gfxPlatform
:
:
ShutdownLayersIPC
(
)
{
if
(
!
sLayersIPCIsUp
)
{
return
;
}
sLayersIPCIsUp
=
false
;
if
(
XRE_IsContentProcess
(
)
)
{
gfx
:
:
VRManagerChild
:
:
ShutDown
(
)
;
gfx
:
:
CanvasManagerChild
:
:
Shutdown
(
)
;
if
(
StaticPrefs
:
:
layers_child_process_shutdown
(
)
)
{
layers
:
:
CompositorManagerChild
:
:
Shutdown
(
)
;
layers
:
:
ImageBridgeChild
:
:
ShutDown
(
)
;
}
}
else
if
(
XRE_IsParentProcess
(
)
)
{
gfx
:
:
VRManagerChild
:
:
ShutDown
(
)
;
gfx
:
:
CanvasManagerChild
:
:
Shutdown
(
)
;
layers
:
:
CompositorManagerChild
:
:
Shutdown
(
)
;
layers
:
:
ImageBridgeChild
:
:
ShutDown
(
)
;
gfx
:
:
CanvasManagerParent
:
:
Shutdown
(
)
;
layers
:
:
CompositorThreadHolder
:
:
Shutdown
(
)
;
RemoteTextureMap
:
:
Shutdown
(
)
;
image
:
:
ImageMemoryReporter
:
:
ShutdownForWebRender
(
)
;
if
(
wr
:
:
RenderThread
:
:
Get
(
)
)
{
wr
:
:
RenderThread
:
:
ShutDown
(
)
;
Preferences
:
:
UnregisterCallback
(
WebRenderDebugPrefChangeCallback
WR_DEBUG_PREF
)
;
Preferences
:
:
UnregisterCallback
(
WebRendeProfilerUIPrefChangeCallback
"
gfx
.
webrender
.
debug
.
profiler
-
ui
"
)
;
Preferences
:
:
UnregisterCallback
(
WebRenderBlobTileSizePrefChangeCallback
nsDependentCString
(
StaticPrefs
:
:
GetPrefName_gfx_webrender_blob_tile_size
(
)
)
)
;
}
if
(
gfx
:
:
CanvasRenderThread
:
:
Get
(
)
)
{
gfx
:
:
CanvasRenderThread
:
:
ShutDown
(
)
;
}
#
if
defined
(
XP_WIN
)
widget
:
:
WinWindowOcclusionTracker
:
:
ShutDown
(
)
;
#
endif
}
else
{
}
}
void
gfxPlatform
:
:
WillShutdown
(
)
{
mScreenReferenceSurface
=
nullptr
;
mScreenReferenceDrawTarget
=
nullptr
;
SkGraphics
:
:
PurgeFontCache
(
)
;
#
ifdef
NS_FREE_PERMANENT_DATA
cairo_debug_reset_static_data
(
)
;
#
endif
}
gfxPlatform
:
:
~
gfxPlatform
(
)
=
default
;
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateDrawTargetForSurface
(
gfxASurface
*
aSurface
const
IntSize
&
aSize
)
{
SurfaceFormat
format
=
aSurface
-
>
GetSurfaceFormat
(
)
;
RefPtr
<
DrawTarget
>
drawTarget
=
Factory
:
:
CreateDrawTargetForCairoSurface
(
aSurface
-
>
CairoSurface
(
)
aSize
&
format
)
;
if
(
!
drawTarget
)
{
gfxWarning
(
)
<
<
"
gfxPlatform
:
:
CreateDrawTargetForSurface
failed
in
"
"
CreateDrawTargetForCairoSurface
"
;
return
nullptr
;
}
return
drawTarget
.
forget
(
)
;
}
cairo_user_data_key_t
kSourceSurface
;
struct
SourceSurfaceUserData
{
RefPtr
<
SourceSurface
>
mSrcSurface
;
BackendType
mBackendType
;
}
;
static
void
SourceBufferDestroy
(
void
*
srcSurfUD
)
{
delete
static_cast
<
SourceSurfaceUserData
*
>
(
srcSurfUD
)
;
}
UserDataKey
kThebesSurface
;
struct
DependentSourceSurfaceUserData
{
RefPtr
<
gfxASurface
>
mSurface
;
}
;
static
void
SourceSurfaceDestroyed
(
void
*
aData
)
{
delete
static_cast
<
DependentSourceSurfaceUserData
*
>
(
aData
)
;
}
void
gfxPlatform
:
:
ClearSourceSurfaceForSurface
(
gfxASurface
*
aSurface
)
{
aSurface
-
>
SetData
(
&
kSourceSurface
nullptr
nullptr
)
;
}
already_AddRefed
<
SourceSurface
>
gfxPlatform
:
:
GetSourceSurfaceForSurface
(
RefPtr
<
DrawTarget
>
aTarget
gfxASurface
*
aSurface
bool
aIsPlugin
)
{
if
(
!
aSurface
-
>
CairoSurface
(
)
|
|
aSurface
-
>
CairoStatus
(
)
)
{
return
nullptr
;
}
if
(
!
aTarget
)
{
aTarget
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
;
}
void
*
userData
=
aSurface
-
>
GetData
(
&
kSourceSurface
)
;
if
(
userData
)
{
SourceSurfaceUserData
*
surf
=
static_cast
<
SourceSurfaceUserData
*
>
(
userData
)
;
if
(
surf
-
>
mSrcSurface
-
>
IsValid
(
)
&
&
surf
-
>
mBackendType
=
=
aTarget
-
>
GetBackendType
(
)
)
{
RefPtr
<
SourceSurface
>
srcSurface
(
surf
-
>
mSrcSurface
)
;
return
srcSurface
.
forget
(
)
;
}
}
SurfaceFormat
format
=
aSurface
-
>
GetSurfaceFormat
(
)
;
if
(
aTarget
-
>
GetBackendType
(
)
=
=
BackendType
:
:
CAIRO
)
{
return
Factory
:
:
CreateSourceSurfaceForCairoSurface
(
aSurface
-
>
CairoSurface
(
)
aSurface
-
>
GetSize
(
)
format
)
;
}
RefPtr
<
SourceSurface
>
srcBuffer
;
if
(
!
srcBuffer
)
{
RefPtr
<
DataSourceSurface
>
surf
=
GetWrappedDataSourceSurface
(
aSurface
)
;
if
(
surf
)
{
srcBuffer
=
aIsPlugin
?
aTarget
-
>
OptimizeSourceSurfaceForUnknownAlpha
(
surf
)
:
aTarget
-
>
OptimizeSourceSurface
(
surf
)
;
if
(
srcBuffer
=
=
surf
)
{
return
srcBuffer
.
forget
(
)
;
}
}
}
if
(
!
srcBuffer
)
{
MOZ_ASSERT
(
aTarget
-
>
GetBackendType
(
)
!
=
BackendType
:
:
CAIRO
"
We
already
tried
CreateSourceSurfaceFromNativeSurface
with
a
"
"
DrawTargetCairo
above
"
)
;
srcBuffer
=
Factory
:
:
CreateSourceSurfaceForCairoSurface
(
aSurface
-
>
CairoSurface
(
)
aSurface
-
>
GetSize
(
)
format
)
;
if
(
srcBuffer
)
{
srcBuffer
=
aTarget
-
>
OptimizeSourceSurface
(
srcBuffer
)
;
}
}
if
(
!
srcBuffer
)
{
return
nullptr
;
}
if
(
(
srcBuffer
-
>
GetType
(
)
=
=
SurfaceType
:
:
CAIRO
&
&
static_cast
<
SourceSurfaceCairo
*
>
(
srcBuffer
.
get
(
)
)
-
>
GetSurface
(
)
=
=
aSurface
-
>
CairoSurface
(
)
)
|
|
(
srcBuffer
-
>
GetType
(
)
=
=
SurfaceType
:
:
CAIRO_IMAGE
&
&
static_cast
<
DataSourceSurfaceCairo
*
>
(
srcBuffer
.
get
(
)
)
-
>
GetSurface
(
)
=
=
aSurface
-
>
CairoSurface
(
)
)
)
{
return
srcBuffer
.
forget
(
)
;
}
auto
*
srcSurfUD
=
new
SourceSurfaceUserData
;
srcSurfUD
-
>
mBackendType
=
aTarget
-
>
GetBackendType
(
)
;
srcSurfUD
-
>
mSrcSurface
=
srcBuffer
;
aSurface
-
>
SetData
(
&
kSourceSurface
srcSurfUD
SourceBufferDestroy
)
;
return
srcBuffer
.
forget
(
)
;
}
already_AddRefed
<
DataSourceSurface
>
gfxPlatform
:
:
GetWrappedDataSourceSurface
(
gfxASurface
*
aSurface
)
{
RefPtr
<
gfxImageSurface
>
image
=
aSurface
-
>
GetAsImageSurface
(
)
;
if
(
!
image
)
{
return
nullptr
;
}
RefPtr
<
DataSourceSurface
>
result
=
Factory
:
:
CreateWrappingDataSourceSurface
(
image
-
>
Data
(
)
image
-
>
Stride
(
)
image
-
>
GetSize
(
)
ImageFormatToSurfaceFormat
(
image
-
>
Format
(
)
)
)
;
if
(
!
result
)
{
return
nullptr
;
}
auto
*
srcSurfUD
=
new
DependentSourceSurfaceUserData
;
srcSurfUD
-
>
mSurface
=
aSurface
;
result
-
>
AddUserData
(
&
kThebesSurface
srcSurfUD
SourceSurfaceDestroyed
)
;
return
result
.
forget
(
)
;
}
void
gfxPlatform
:
:
PopulateScreenInfo
(
)
{
nsCOMPtr
<
nsIScreenManager
>
manager
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
;
MOZ_ASSERT
(
manager
"
failed
to
get
nsIScreenManager
"
)
;
nsCOMPtr
<
nsIScreen
>
screen
;
manager
-
>
GetPrimaryScreen
(
getter_AddRefs
(
screen
)
)
;
if
(
!
screen
)
{
return
;
}
screen
-
>
GetColorDepth
(
&
mScreenDepth
)
;
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetScreenDepth
(
mScreenDepth
)
;
}
int
left
top
;
screen
-
>
GetRect
(
&
left
&
top
&
mScreenSize
.
width
&
mScreenSize
.
height
)
;
}
bool
gfxPlatform
:
:
SupportsAzureContentForDrawTarget
(
DrawTarget
*
aTarget
)
{
if
(
!
aTarget
|
|
!
aTarget
-
>
IsValid
(
)
)
{
return
false
;
}
return
SupportsAzureContentForType
(
aTarget
-
>
GetBackendType
(
)
)
;
}
void
gfxPlatform
:
:
PurgeSkiaFontCache
(
)
{
if
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetDefaultContentBackend
(
)
=
=
BackendType
:
:
SKIA
)
{
SkGraphics
:
:
PurgeFontCache
(
)
;
}
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateDrawTargetForBackend
(
BackendType
aBackend
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
if
(
aBackend
=
=
BackendType
:
:
CAIRO
)
{
RefPtr
<
gfxASurface
>
surf
=
CreateOffscreenSurface
(
aSize
SurfaceFormatToImageFormat
(
aFormat
)
)
;
if
(
!
surf
|
|
surf
-
>
CairoStatus
(
)
)
{
return
nullptr
;
}
return
CreateDrawTargetForSurface
(
surf
aSize
)
;
}
return
Factory
:
:
CreateDrawTarget
(
aBackend
aSize
aFormat
)
;
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateOffscreenCanvasDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
NS_ASSERTION
(
mPreferredCanvasBackend
!
=
BackendType
:
:
NONE
"
No
backend
.
"
)
;
if
(
!
gfxPlatform
:
:
UseRemoteCanvas
(
)
|
|
!
gfxPlatform
:
:
IsBackendAccelerated
(
mPreferredCanvasBackend
)
)
{
RefPtr
<
DrawTarget
>
target
=
CreateDrawTargetForBackend
(
mPreferredCanvasBackend
aSize
aFormat
)
;
if
(
target
|
|
mFallbackCanvasBackend
=
=
BackendType
:
:
NONE
)
{
return
target
.
forget
(
)
;
}
}
#
ifdef
XP_WIN
return
Factory
:
:
CreateDrawTarget
(
mFallbackCanvasBackend
aSize
aFormat
)
;
#
else
return
CreateDrawTargetForBackend
(
mFallbackCanvasBackend
aSize
aFormat
)
;
#
endif
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateOffscreenContentDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
bool
aFallback
)
{
BackendType
backend
=
(
aFallback
)
?
mSoftwareBackend
:
mContentBackend
;
NS_ASSERTION
(
backend
!
=
BackendType
:
:
NONE
"
No
backend
.
"
)
;
RefPtr
<
DrawTarget
>
dt
=
CreateDrawTargetForBackend
(
backend
aSize
aFormat
)
;
if
(
!
dt
)
{
return
nullptr
;
}
dt
-
>
ClearRect
(
gfx
:
:
Rect
(
)
)
;
if
(
!
dt
-
>
IsValid
(
)
)
{
return
nullptr
;
}
return
dt
.
forget
(
)
;
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateSimilarSoftwareDrawTarget
(
DrawTarget
*
aDT
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
RefPtr
<
DrawTarget
>
dt
;
if
(
Factory
:
:
DoesBackendSupportDataDrawtarget
(
aDT
-
>
GetBackendType
(
)
)
)
{
dt
=
aDT
-
>
CreateSimilarDrawTarget
(
aSize
aFormat
)
;
}
else
{
BackendType
backendType
=
BackendType
:
:
SKIA
;
dt
=
Factory
:
:
CreateDrawTarget
(
backendType
aSize
aFormat
)
;
}
return
dt
.
forget
(
)
;
}
already_AddRefed
<
DrawTarget
>
gfxPlatform
:
:
CreateDrawTargetForData
(
unsigned
char
*
aData
const
IntSize
&
aSize
int32_t
aStride
SurfaceFormat
aFormat
bool
aUninitialized
)
{
BackendType
backendType
=
gfxVars
:
:
ContentBackend
(
)
;
NS_ASSERTION
(
backendType
!
=
BackendType
:
:
NONE
"
No
backend
.
"
)
;
if
(
!
Factory
:
:
DoesBackendSupportDataDrawtarget
(
backendType
)
)
{
backendType
=
BackendType
:
:
SKIA
;
}
RefPtr
<
DrawTarget
>
dt
=
Factory
:
:
CreateDrawTargetForData
(
backendType
aData
aSize
aStride
aFormat
aUninitialized
)
;
return
dt
.
forget
(
)
;
}
BackendType
gfxPlatform
:
:
BackendTypeForName
(
const
nsCString
&
aName
)
{
if
(
aName
.
EqualsLiteral
(
"
cairo
"
)
)
return
BackendType
:
:
CAIRO
;
if
(
aName
.
EqualsLiteral
(
"
skia
"
)
)
return
BackendType
:
:
SKIA
;
if
(
aName
.
EqualsLiteral
(
"
direct2d
"
)
)
return
BackendType
:
:
DIRECT2D
;
if
(
aName
.
EqualsLiteral
(
"
direct2d1
.
1
"
)
)
return
BackendType
:
:
DIRECT2D1_1
;
return
BackendType
:
:
NONE
;
}
nsresult
gfxPlatform
:
:
GetFontList
(
nsAtom
*
aLangGroup
const
nsACString
&
aGenericFamily
nsTArray
<
nsString
>
&
aListOfFonts
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
GetFontList
(
aLangGroup
aGenericFamily
aListOfFonts
)
;
return
NS_OK
;
}
nsresult
gfxPlatform
:
:
UpdateFontList
(
bool
aFullRebuild
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
UpdateFontList
(
aFullRebuild
)
;
return
NS_OK
;
}
void
gfxPlatform
:
:
GetStandardFamilyName
(
const
nsCString
&
aFontName
nsACString
&
aFamilyName
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
GetStandardFamilyName
(
aFontName
aFamilyName
)
;
}
nsAutoCString
gfxPlatform
:
:
GetDefaultFontName
(
const
nsACString
&
aLangGroup
const
nsACString
&
aGenericFamily
)
{
nsAutoCString
result
;
auto
*
pfl
=
gfxPlatformFontList
:
:
PlatformFontList
(
)
;
FamilyAndGeneric
fam
=
pfl
-
>
GetDefaultFontFamily
(
aLangGroup
aGenericFamily
)
;
if
(
!
pfl
-
>
GetLocalizedFamilyName
(
fam
.
mFamily
result
)
)
{
NS_WARNING
(
"
missing
default
font
-
family
name
"
)
;
}
return
result
;
}
bool
gfxPlatform
:
:
DownloadableFontsEnabled
(
)
{
if
(
mAllowDownloadableFonts
=
=
UNINITIALIZED_VALUE
)
{
mAllowDownloadableFonts
=
Preferences
:
:
GetBool
(
GFX_DOWNLOADABLE_FONTS_ENABLED
false
)
;
}
return
mAllowDownloadableFonts
;
}
bool
gfxPlatform
:
:
UseCmapsDuringSystemFallback
(
)
{
return
StaticPrefs
:
:
gfx_font_rendering_fallback_always_use_cmaps
(
)
;
}
bool
gfxPlatform
:
:
OpenTypeSVGEnabled
(
)
{
return
StaticPrefs
:
:
gfx_font_rendering_opentype_svg_enabled
(
)
;
}
uint32_t
gfxPlatform
:
:
WordCacheCharLimit
(
)
{
return
StaticPrefs
:
:
gfx_font_rendering_wordcache_charlimit
(
)
;
}
uint32_t
gfxPlatform
:
:
WordCacheMaxEntries
(
)
{
return
StaticPrefs
:
:
gfx_font_rendering_wordcache_maxentries
(
)
;
}
bool
gfxPlatform
:
:
UseGraphiteShaping
(
)
{
return
StaticPrefs
:
:
gfx_font_rendering_graphite_enabled
(
)
;
}
bool
gfxPlatform
:
:
IsFontFormatSupported
(
StyleFontFaceSourceFormatKeyword
aFormatHint
StyleFontFaceSourceTechFlags
aTechFlags
)
{
switch
(
aFormatHint
)
{
case
StyleFontFaceSourceFormatKeyword
:
:
None
:
break
;
case
StyleFontFaceSourceFormatKeyword
:
:
Collection
:
return
false
;
case
StyleFontFaceSourceFormatKeyword
:
:
Opentype
:
case
StyleFontFaceSourceFormatKeyword
:
:
Truetype
:
break
;
case
StyleFontFaceSourceFormatKeyword
:
:
EmbeddedOpentype
:
return
false
;
case
StyleFontFaceSourceFormatKeyword
:
:
Svg
:
return
false
;
case
StyleFontFaceSourceFormatKeyword
:
:
Woff
:
break
;
case
StyleFontFaceSourceFormatKeyword
:
:
Woff2
:
break
;
case
StyleFontFaceSourceFormatKeyword
:
:
Unknown
:
return
false
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
bad
format
hint
!
"
)
;
return
false
;
}
StyleFontFaceSourceTechFlags
unsupportedTechnologies
=
StyleFontFaceSourceTechFlags
:
:
INCREMENTAL
|
StyleFontFaceSourceTechFlags
:
:
PALETTES
|
StyleFontFaceSourceTechFlags
:
:
COLOR_SBIX
;
if
(
!
StaticPrefs
:
:
gfx_downloadable_fonts_keep_color_bitmaps
(
)
)
{
unsupportedTechnologies
|
=
StyleFontFaceSourceTechFlags
:
:
COLOR_CBDT
;
}
if
(
!
StaticPrefs
:
:
gfx_font_rendering_colr_v1_enabled
(
)
)
{
unsupportedTechnologies
|
=
StyleFontFaceSourceTechFlags
:
:
COLOR_COLRV1
;
}
if
(
!
StaticPrefs
:
:
layout_css_font_variations_enabled
(
)
)
{
unsupportedTechnologies
|
=
StyleFontFaceSourceTechFlags
:
:
VARIATIONS
;
}
if
(
aTechFlags
&
unsupportedTechnologies
)
{
return
false
;
}
return
true
;
}
gfxFontGroup
*
gfxPlatform
:
:
CreateFontGroup
(
nsPresContext
*
aPresContext
const
StyleFontFamilyList
&
aFontFamilyList
const
gfxFontStyle
*
aStyle
nsAtom
*
aLanguage
bool
aExplicitLanguage
gfxTextPerfMetrics
*
aTextPerf
gfxUserFontSet
*
aUserFontSet
gfxFloat
aDevToCssSize
)
const
{
return
new
gfxFontGroup
(
aPresContext
aFontFamilyList
aStyle
aLanguage
aExplicitLanguage
aTextPerf
aUserFontSet
aDevToCssSize
)
;
}
gfxFontEntry
*
gfxPlatform
:
:
LookupLocalFont
(
nsPresContext
*
aPresContext
const
nsACString
&
aFontName
WeightRange
aWeightForEntry
StretchRange
aStretchForEntry
SlantStyleRange
aStyleForEntry
)
{
return
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
LookupLocalFont
(
aPresContext
aFontName
aWeightForEntry
aStretchForEntry
aStyleForEntry
)
;
}
gfxFontEntry
*
gfxPlatform
:
:
MakePlatformFont
(
const
nsACString
&
aFontName
WeightRange
aWeightForEntry
StretchRange
aStretchForEntry
SlantStyleRange
aStyleForEntry
const
uint8_t
*
aFontData
uint32_t
aLength
)
{
return
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
MakePlatformFont
(
aFontName
aWeightForEntry
aStretchForEntry
aStyleForEntry
aFontData
aLength
)
;
}
BackendPrefsData
gfxPlatform
:
:
GetBackendPrefs
(
)
const
{
BackendPrefsData
data
;
data
.
mCanvasBitmask
=
BackendTypeBit
(
BackendType
:
:
SKIA
)
;
data
.
mContentBitmask
=
BackendTypeBit
(
BackendType
:
:
SKIA
)
;
#
ifdef
MOZ_WIDGET_GTK
data
.
mCanvasBitmask
|
=
BackendTypeBit
(
BackendType
:
:
CAIRO
)
;
data
.
mContentBitmask
|
=
BackendTypeBit
(
BackendType
:
:
CAIRO
)
;
#
endif
data
.
mCanvasDefault
=
BackendType
:
:
SKIA
;
data
.
mContentDefault
=
BackendType
:
:
SKIA
;
return
data
;
}
void
gfxPlatform
:
:
InitBackendPrefs
(
BackendPrefsData
&
&
aPrefsData
)
{
mPreferredCanvasBackend
=
GetCanvasBackendPref
(
aPrefsData
.
mCanvasBitmask
)
;
if
(
mPreferredCanvasBackend
=
=
BackendType
:
:
NONE
)
{
mPreferredCanvasBackend
=
aPrefsData
.
mCanvasDefault
;
}
if
(
mPreferredCanvasBackend
=
=
BackendType
:
:
DIRECT2D1_1
)
{
mFallbackCanvasBackend
=
GetCanvasBackendPref
(
aPrefsData
.
mCanvasBitmask
&
~
(
BackendTypeBit
(
mPreferredCanvasBackend
)
|
BackendTypeBit
(
BackendType
:
:
DIRECT2D
)
)
)
;
}
else
{
mFallbackCanvasBackend
=
GetCanvasBackendPref
(
aPrefsData
.
mCanvasBitmask
&
~
BackendTypeBit
(
mPreferredCanvasBackend
)
)
;
}
mContentBackendBitmask
=
aPrefsData
.
mContentBitmask
;
mContentBackend
=
GetContentBackendPref
(
mContentBackendBitmask
)
;
if
(
mContentBackend
=
=
BackendType
:
:
NONE
)
{
mContentBackend
=
aPrefsData
.
mContentDefault
;
mContentBackendBitmask
|
=
BackendTypeBit
(
aPrefsData
.
mContentDefault
)
;
}
uint32_t
swBackendBits
=
BackendTypeBit
(
BackendType
:
:
SKIA
)
;
#
ifdef
MOZ_WIDGET_GTK
swBackendBits
|
=
BackendTypeBit
(
BackendType
:
:
CAIRO
)
;
#
endif
mSoftwareBackend
=
GetContentBackendPref
(
swBackendBits
)
;
if
(
mSoftwareBackend
=
=
BackendType
:
:
NONE
)
{
mSoftwareBackend
=
BackendType
:
:
SKIA
;
}
if
(
mFallbackCanvasBackend
=
=
BackendType
:
:
NONE
)
{
mFallbackCanvasBackend
=
mSoftwareBackend
;
}
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetContentBackend
(
mContentBackend
)
;
gfxVars
:
:
SetSoftwareBackend
(
mSoftwareBackend
)
;
}
}
BackendType
gfxPlatform
:
:
GetCanvasBackendPref
(
uint32_t
aBackendBitmask
)
{
return
GetBackendPref
(
"
gfx
.
canvas
.
azure
.
backends
"
aBackendBitmask
)
;
}
BackendType
gfxPlatform
:
:
GetContentBackendPref
(
uint32_t
&
aBackendBitmask
)
{
return
GetBackendPref
(
"
gfx
.
content
.
azure
.
backends
"
aBackendBitmask
)
;
}
BackendType
gfxPlatform
:
:
GetBackendPref
(
const
char
*
aBackendPrefName
uint32_t
&
aBackendBitmask
)
{
nsTArray
<
nsCString
>
backendList
;
nsAutoCString
prefString
;
if
(
NS_SUCCEEDED
(
Preferences
:
:
GetCString
(
aBackendPrefName
prefString
)
)
)
{
ParseString
(
prefString
'
'
backendList
)
;
}
uint32_t
allowedBackends
=
0
;
BackendType
result
=
BackendType
:
:
NONE
;
for
(
uint32_t
i
=
0
;
i
<
backendList
.
Length
(
)
;
+
+
i
)
{
BackendType
type
=
BackendTypeForName
(
backendList
[
i
]
)
;
if
(
BackendTypeBit
(
type
)
&
aBackendBitmask
)
{
allowedBackends
|
=
BackendTypeBit
(
type
)
;
if
(
result
=
=
BackendType
:
:
NONE
)
{
result
=
type
;
}
}
}
aBackendBitmask
=
allowedBackends
;
return
result
;
}
bool
gfxPlatform
:
:
InSafeMode
(
)
{
static
bool
sSafeModeInitialized
=
false
;
static
bool
sInSafeMode
=
false
;
if
(
!
sSafeModeInitialized
)
{
sSafeModeInitialized
=
true
;
nsCOMPtr
<
nsIXULRuntime
>
xr
=
do_GetService
(
"
mozilla
.
org
/
xre
/
runtime
;
1
"
)
;
if
(
xr
)
{
xr
-
>
GetInSafeMode
(
&
sInSafeMode
)
;
}
}
return
sInSafeMode
;
}
bool
gfxPlatform
:
:
OffMainThreadCompositingEnabled
(
)
{
return
UsesOffMainThreadCompositing
(
)
;
}
void
gfxPlatform
:
:
SetCMSModeOverride
(
CMSMode
aMode
)
{
MOZ_ASSERT
(
gCMSInitialized
)
;
gCMSMode
=
aMode
;
}
int
gfxPlatform
:
:
GetRenderingIntent
(
)
{
MOZ_ASSERT
(
QCMS_INTENT_DEFAULT
=
=
0
)
;
int32_t
pIntent
=
StaticPrefs
:
:
gfx_color_management_rendering_intent
(
)
;
if
(
(
pIntent
<
QCMS_INTENT_MIN
)
|
|
(
pIntent
>
QCMS_INTENT_MAX
)
)
{
pIntent
=
-
1
;
}
return
pIntent
;
}
DeviceColor
gfxPlatform
:
:
TransformPixel
(
const
sRGBColor
&
in
qcms_transform
*
transform
)
{
if
(
transform
)
{
#
ifdef
IS_LITTLE_ENDIAN
uint32_t
packed
=
in
.
ToABGR
(
)
;
qcms_transform_data
(
transform
(
uint8_t
*
)
&
packed
(
uint8_t
*
)
&
packed
1
)
;
auto
out
=
DeviceColor
:
:
FromABGR
(
packed
)
;
#
else
uint32_t
packed
=
in
.
UnusualToARGB
(
)
;
qcms_transform_data
(
transform
(
uint8_t
*
)
&
packed
+
1
(
uint8_t
*
)
&
packed
+
1
1
)
;
auto
out
=
DeviceColor
:
:
UnusualFromARGB
(
packed
)
;
#
endif
out
.
a
=
in
.
a
;
return
out
;
}
return
DeviceColor
(
in
.
r
in
.
g
in
.
b
in
.
a
)
;
}
nsTArray
<
uint8_t
>
gfxPlatform
:
:
GetPlatformCMSOutputProfileData
(
)
{
return
GetPrefCMSOutputProfileData
(
)
;
}
nsTArray
<
uint8_t
>
gfxPlatform
:
:
GetPrefCMSOutputProfileData
(
)
{
nsAutoCString
fname
;
Preferences
:
:
GetCString
(
"
gfx
.
color_management
.
display_profile
"
fname
)
;
if
(
fname
.
IsEmpty
(
)
)
{
return
nsTArray
<
uint8_t
>
(
)
;
}
void
*
mem
=
nullptr
;
size_t
size
=
0
;
qcms_data_from_path
(
fname
.
get
(
)
&
mem
&
size
)
;
nsTArray
<
uint8_t
>
result
;
if
(
mem
)
{
result
.
AppendElements
(
static_cast
<
uint8_t
*
>
(
mem
)
size
)
;
free
(
mem
)
;
}
return
result
;
}
const
mozilla
:
:
gfx
:
:
ContentDeviceData
*
gfxPlatform
:
:
GetInitContentDeviceData
(
)
{
return
gContentDeviceInitData
;
}
void
gfxPlatform
:
:
InitializeCMS
(
)
{
if
(
gCMSInitialized
)
{
return
;
}
if
(
XRE_IsGPUProcess
(
)
)
{
gCMSInitialized
=
true
;
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
"
CMS
should
be
initialized
on
the
main
thread
"
)
;
if
(
MOZ_UNLIKELY
(
!
NS_IsMainThread
(
)
)
)
{
return
;
}
{
int32_t
mode
=
StaticPrefs
:
:
gfx_color_management_mode
(
)
;
if
(
mode
>
=
0
&
&
mode
<
int32_t
(
CMSMode
:
:
AllCount
)
)
{
gCMSMode
=
CMSMode
(
mode
)
;
}
}
gCMSsRGBProfile
=
qcms_profile_sRGB
(
)
;
if
(
StaticPrefs
:
:
gfx_color_management_force_srgb
(
)
|
|
StaticPrefs
:
:
gfx_color_management_native_srgb
(
)
)
{
gCMSOutputProfile
=
gCMSsRGBProfile
;
}
if
(
!
gCMSOutputProfile
)
{
nsTArray
<
uint8_t
>
outputProfileData
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetPlatformCMSOutputProfileData
(
)
;
if
(
!
outputProfileData
.
IsEmpty
(
)
)
{
gCMSOutputProfile
=
qcms_profile_from_memory
(
outputProfileData
.
Elements
(
)
outputProfileData
.
Length
(
)
)
;
}
}
if
(
gCMSOutputProfile
&
&
qcms_profile_is_bogus
(
gCMSOutputProfile
)
)
{
NS_ASSERTION
(
gCMSOutputProfile
!
=
gCMSsRGBProfile
"
Builtin
sRGB
profile
tagged
as
bogus
!
!
!
"
)
;
qcms_profile_release
(
gCMSOutputProfile
)
;
gCMSOutputProfile
=
nullptr
;
}
if
(
!
gCMSOutputProfile
)
{
gCMSOutputProfile
=
gCMSsRGBProfile
;
}
qcms_profile_precache_output_transform
(
gCMSOutputProfile
)
;
gCMSRGBTransform
=
qcms_transform_create
(
gCMSsRGBProfile
QCMS_DATA_RGB_8
gCMSOutputProfile
QCMS_DATA_RGB_8
QCMS_INTENT_PERCEPTUAL
)
;
gCMSInverseRGBTransform
=
qcms_transform_create
(
gCMSOutputProfile
QCMS_DATA_RGB_8
gCMSsRGBProfile
QCMS_DATA_RGB_8
QCMS_INTENT_PERCEPTUAL
)
;
gCMSRGBATransform
=
qcms_transform_create
(
gCMSsRGBProfile
QCMS_DATA_RGBA_8
gCMSOutputProfile
QCMS_DATA_RGBA_8
QCMS_INTENT_PERCEPTUAL
)
;
gCMSBGRATransform
=
qcms_transform_create
(
gCMSsRGBProfile
QCMS_DATA_BGRA_8
gCMSOutputProfile
QCMS_DATA_BGRA_8
QCMS_INTENT_PERCEPTUAL
)
;
if
(
StaticPrefs
:
:
gfx_color_management_enablev4
(
)
)
{
qcms_enable_iccv4
(
)
;
}
gCMSInitialized
=
true
;
}
qcms_transform
*
gfxPlatform
:
:
GetCMSOSRGBATransform
(
)
{
switch
(
SurfaceFormat
:
:
OS_RGBA
)
{
case
SurfaceFormat
:
:
B8G8R8A8
:
return
GetCMSBGRATransform
(
)
;
case
SurfaceFormat
:
:
R8G8B8A8
:
return
GetCMSRGBATransform
(
)
;
default
:
return
nullptr
;
}
}
qcms_data_type
gfxPlatform
:
:
GetCMSOSRGBAType
(
)
{
switch
(
SurfaceFormat
:
:
OS_RGBA
)
{
case
SurfaceFormat
:
:
B8G8R8A8
:
return
QCMS_DATA_BGRA_8
;
case
SurfaceFormat
:
:
R8G8B8A8
:
return
QCMS_DATA_RGBA_8
;
default
:
return
QCMS_DATA_RGBA_8
;
}
}
void
gfxPlatform
:
:
ShutdownCMS
(
)
{
if
(
gCMSRGBTransform
)
{
qcms_transform_release
(
gCMSRGBTransform
)
;
gCMSRGBTransform
=
nullptr
;
}
if
(
gCMSInverseRGBTransform
)
{
qcms_transform_release
(
gCMSInverseRGBTransform
)
;
gCMSInverseRGBTransform
=
nullptr
;
}
if
(
gCMSRGBATransform
)
{
qcms_transform_release
(
gCMSRGBATransform
)
;
gCMSRGBATransform
=
nullptr
;
}
if
(
gCMSBGRATransform
)
{
qcms_transform_release
(
gCMSBGRATransform
)
;
gCMSBGRATransform
=
nullptr
;
}
if
(
gCMSOutputProfile
)
{
qcms_profile_release
(
gCMSOutputProfile
)
;
if
(
gCMSsRGBProfile
=
=
gCMSOutputProfile
)
{
gCMSsRGBProfile
=
nullptr
;
}
gCMSOutputProfile
=
nullptr
;
}
if
(
gCMSsRGBProfile
)
{
qcms_profile_release
(
gCMSsRGBProfile
)
;
gCMSsRGBProfile
=
nullptr
;
}
gCMSMode
=
CMSMode
:
:
Off
;
gCMSInitialized
=
false
;
}
uint32_t
gfxPlatform
:
:
GetBidiNumeralOption
(
)
{
return
StaticPrefs
:
:
bidi_numeral
(
)
;
}
void
gfxPlatform
:
:
FlushFontAndWordCaches
(
)
{
gfxFontCache
*
fontCache
=
gfxFontCache
:
:
GetCache
(
)
;
if
(
fontCache
)
{
fontCache
-
>
Flush
(
)
;
}
gfxPlatform
:
:
PurgeSkiaFontCache
(
)
;
}
void
gfxPlatform
:
:
ForceGlobalReflow
(
NeedsReframe
aNeedsReframe
BroadcastToChildren
aBroadcastToChildren
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
const
bool
reframe
=
aNeedsReframe
=
=
NeedsReframe
:
:
Yes
;
if
(
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
)
{
char16_t
needsReframe
[
]
=
{
char16_t
(
reframe
)
0
}
;
obs
-
>
NotifyObservers
(
nullptr
"
font
-
info
-
updated
"
needsReframe
)
;
}
if
(
XRE_IsParentProcess
(
)
&
&
aBroadcastToChildren
=
=
BroadcastToChildren
:
:
Yes
)
{
for
(
auto
*
process
:
dom
:
:
ContentParent
:
:
AllProcesses
(
dom
:
:
ContentParent
:
:
eLive
)
)
{
Unused
<
<
process
-
>
SendForceGlobalReflow
(
reframe
)
;
}
}
}
void
gfxPlatform
:
:
FontsPrefsChanged
(
const
char
*
aPref
)
{
NS_ASSERTION
(
aPref
!
=
nullptr
"
null
preference
"
)
;
if
(
!
strcmp
(
GFX_DOWNLOADABLE_FONTS_ENABLED
aPref
)
)
{
mAllowDownloadableFonts
=
UNINITIALIZED_VALUE
;
}
else
if
(
!
strcmp
(
GFX_PREF_WORD_CACHE_CHARLIMIT
aPref
)
|
|
!
strcmp
(
GFX_PREF_WORD_CACHE_MAXENTRIES
aPref
)
|
|
!
strcmp
(
GFX_PREF_GRAPHITE_SHAPING
aPref
)
)
{
FlushFontAndWordCaches
(
)
;
}
else
if
(
#
if
defined
(
XP_MACOSX
)
!
strcmp
(
GFX_PREF_CORETEXT_SHAPING
aPref
)
|
|
#
endif
!
strcmp
(
"
gfx
.
font_rendering
.
ahem_antialias_none
"
aPref
)
)
{
FlushFontAndWordCaches
(
)
;
}
else
if
(
!
strcmp
(
GFX_PREF_OPENTYPE_SVG
aPref
)
)
{
gfxFontCache
:
:
GetCache
(
)
-
>
Flush
(
)
;
gfxFontCache
:
:
GetCache
(
)
-
>
NotifyGlyphsChanged
(
)
;
}
}
mozilla
:
:
LogModule
*
gfxPlatform
:
:
GetLog
(
eGfxLog
aWhichLog
)
{
static
LazyLogModule
sFontlistLog
(
"
fontlist
"
)
;
static
LazyLogModule
sFontInitLog
(
"
fontinit
"
)
;
static
LazyLogModule
sTextrunLog
(
"
textrun
"
)
;
static
LazyLogModule
sTextrunuiLog
(
"
textrunui
"
)
;
static
LazyLogModule
sCmapDataLog
(
"
cmapdata
"
)
;
static
LazyLogModule
sTextPerfLog
(
"
textperf
"
)
;
switch
(
aWhichLog
)
{
case
eGfxLog_fontlist
:
return
sFontlistLog
;
case
eGfxLog_fontinit
:
return
sFontInitLog
;
case
eGfxLog_textrun
:
return
sTextrunLog
;
case
eGfxLog_textrunui
:
return
sTextrunuiLog
;
case
eGfxLog_cmapdata
:
return
sCmapDataLog
;
case
eGfxLog_textperf
:
return
sTextPerfLog
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
log
type
"
)
;
return
nullptr
;
}
RefPtr
<
mozilla
:
:
gfx
:
:
DrawTarget
>
gfxPlatform
:
:
ScreenReferenceDrawTarget
(
)
{
MOZ_ASSERT_IF
(
XRE_IsContentProcess
(
)
NS_IsMainThread
(
)
)
;
return
(
mScreenReferenceDrawTarget
)
?
mScreenReferenceDrawTarget
:
gPlatform
-
>
CreateOffscreenContentDrawTarget
(
IntSize
(
1
1
)
SurfaceFormat
:
:
B8G8R8A8
true
)
;
}
RefPtr
<
mozilla
:
:
gfx
:
:
DrawTarget
>
gfxPlatform
:
:
ThreadLocalScreenReferenceDrawTarget
(
)
{
if
(
NS_IsMainThread
(
)
&
&
gPlatform
)
{
return
gPlatform
-
>
ScreenReferenceDrawTarget
(
)
;
}
gfxPlatformWorker
*
platformWorker
=
gfxPlatformWorker
:
:
Get
(
)
;
if
(
platformWorker
)
{
return
platformWorker
-
>
ScreenReferenceDrawTarget
(
)
;
}
return
Factory
:
:
CreateDrawTarget
(
BackendType
:
:
SKIA
IntSize
(
1
1
)
SurfaceFormat
:
:
B8G8R8A8
)
;
}
mozilla
:
:
gfx
:
:
SurfaceFormat
gfxPlatform
:
:
Optimal2DFormatForContent
(
gfxContentType
aContent
)
{
switch
(
aContent
)
{
case
gfxContentType
:
:
COLOR
:
switch
(
GetOffscreenFormat
(
)
)
{
case
SurfaceFormat
:
:
A8R8G8B8_UINT32
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
case
SurfaceFormat
:
:
X8R8G8B8_UINT32
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8X8
;
case
SurfaceFormat
:
:
R5G6B5_UINT16
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
R5G6B5_UINT16
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unknown
gfxImageFormat
for
"
"
gfxContentType
:
:
COLOR
"
)
;
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
}
case
gfxContentType
:
:
ALPHA
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
A8
;
case
gfxContentType
:
:
COLOR_ALPHA
:
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unknown
gfxContentType
"
)
;
return
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
}
}
gfxImageFormat
gfxPlatform
:
:
OptimalFormatForContent
(
gfxContentType
aContent
)
{
switch
(
aContent
)
{
case
gfxContentType
:
:
COLOR
:
return
GetOffscreenFormat
(
)
;
case
gfxContentType
:
:
ALPHA
:
return
SurfaceFormat
:
:
A8
;
case
gfxContentType
:
:
COLOR_ALPHA
:
return
SurfaceFormat
:
:
A8R8G8B8_UINT32
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unknown
gfxContentType
"
)
;
return
SurfaceFormat
:
:
A8R8G8B8_UINT32
;
}
}
static
mozilla
:
:
Atomic
<
bool
>
sLayersSupportsHardwareVideoDecoding
(
false
)
;
static
bool
sLayersHardwareVideoDecodingFailed
=
false
;
static
mozilla
:
:
Atomic
<
bool
>
sLayersAccelerationPrefsInitialized
(
false
)
;
static
void
VideoDecodingFailedChangedCallback
(
const
char
*
aPref
void
*
)
{
sLayersHardwareVideoDecodingFailed
=
Preferences
:
:
GetBool
(
aPref
false
)
;
gfxPlatform
:
:
GetPlatform
(
)
-
>
UpdateCanUseHardwareVideoDecoding
(
)
;
}
void
gfxPlatform
:
:
UpdateCanUseHardwareVideoDecoding
(
)
{
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetCanUseHardwareVideoDecoding
(
CanUseHardwareVideoDecoding
(
)
)
;
}
}
void
gfxPlatform
:
:
UpdateForceSubpixelAAWherePossible
(
)
{
bool
forceSubpixelAAWherePossible
=
StaticPrefs
:
:
gfx_webrender_quality_force_subpixel_aa_where_possible
(
)
;
gfxVars
:
:
SetForceSubpixelAAWherePossible
(
forceSubpixelAAWherePossible
)
;
}
void
gfxPlatform
:
:
InitAcceleration
(
)
{
if
(
sLayersAccelerationPrefsInitialized
)
{
return
;
}
InitCompositorAccelerationPrefs
(
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
can
only
initialize
prefs
on
the
main
thread
"
)
;
#
ifndef
MOZ_WIDGET_GTK
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
components
:
:
GfxInfo
:
:
Service
(
)
;
nsCString
discardFailureId
;
int32_t
status
;
#
endif
if
(
XRE_IsParentProcess
(
)
)
{
gfxVars
:
:
SetBrowserTabsRemoteAutostart
(
BrowserTabsRemoteAutostart
(
)
)
;
gfxVars
:
:
SetOffscreenFormat
(
GetOffscreenFormat
(
)
)
;
gfxVars
:
:
SetRequiresAcceleratedGLContextForCompositorOGL
(
RequiresAcceleratedGLContextForCompositorOGL
(
)
)
;
#
ifdef
XP_WIN
if
(
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_D3D11_KEYED_MUTEX
discardFailureId
&
status
)
)
)
{
gfxVars
:
:
SetAllowD3D11KeyedMutex
(
status
=
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
)
;
}
else
{
gfxCriticalNote
<
<
"
Cannot
evaluate
keyed
mutex
feature
status
"
;
gfxVars
:
:
SetAllowD3D11KeyedMutex
(
true
)
;
}
if
(
StaticPrefs
:
:
gfx_direct3d11_use_double_buffering
(
)
&
&
IsWin10OrLater
(
)
)
{
gfxVars
:
:
SetUseDoubleBufferingWithCompositor
(
true
)
;
}
#
endif
}
if
(
StaticPrefs
:
:
media_hardware_video_decoding_enabled_AtStartup
(
)
)
{
#
ifdef
MOZ_WIDGET_GTK
sLayersSupportsHardwareVideoDecoding
=
gfxPlatformGtk
:
:
GetPlatform
(
)
-
>
InitVAAPIConfig
(
StaticPrefs
:
:
media_hardware_video_decoding_force_enabled_AtStartup
(
)
|
|
StaticPrefs
:
:
media_ffmpeg_vaapi_enabled
(
)
)
;
#
else
if
(
#
ifdef
XP_WIN
Preferences
:
:
GetBool
(
"
media
.
wmf
.
dxva
.
enabled
"
true
)
&
&
#
endif
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_HARDWARE_VIDEO_DECODING
discardFailureId
&
status
)
)
)
{
if
(
status
=
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
|
|
StaticPrefs
:
:
media_hardware_video_decoding_force_enabled_AtStartup
(
)
)
{
sLayersSupportsHardwareVideoDecoding
=
true
;
}
}
#
endif
}
sLayersAccelerationPrefsInitialized
=
true
;
if
(
XRE_IsParentProcess
(
)
)
{
Preferences
:
:
RegisterCallbackAndCall
(
VideoDecodingFailedChangedCallback
"
media
.
hardware
-
video
-
decoding
.
failed
"
)
;
InitGPUProcessPrefs
(
)
;
gfxVars
:
:
SetRemoteCanvasEnabled
(
StaticPrefs
:
:
gfx_canvas_remote
(
)
&
&
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
)
;
}
}
void
gfxPlatform
:
:
InitGPUProcessPrefs
(
)
{
if
(
!
StaticPrefs
:
:
layers_gpu_process_enabled_AtStartup
(
)
&
&
!
StaticPrefs
:
:
layers_gpu_process_force_enabled_AtStartup
(
)
)
{
return
;
}
FeatureState
&
gpuProc
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
GPU_PROCESS
)
;
if
(
!
BrowserTabsRemoteAutostart
(
)
)
{
gpuProc
.
DisableByDefault
(
FeatureStatus
:
:
Unavailable
"
Multi
-
process
mode
is
not
enabled
"
"
FEATURE_FAILURE_NO_E10S
"
_ns
)
;
}
else
{
gpuProc
.
SetDefaultFromPref
(
StaticPrefs
:
:
GetPrefName_layers_gpu_process_enabled
(
)
true
StaticPrefs
:
:
GetPrefDefault_layers_gpu_process_enabled
(
)
)
;
}
if
(
StaticPrefs
:
:
layers_gpu_process_force_enabled_AtStartup
(
)
)
{
gpuProc
.
UserForceEnable
(
"
User
force
-
enabled
via
pref
"
)
;
}
nsCString
message
;
nsCString
failureId
;
if
(
!
gfxPlatform
:
:
IsGfxInfoStatusOkay
(
nsIGfxInfo
:
:
FEATURE_GPU_PROCESS
&
message
failureId
)
)
{
gpuProc
.
Disable
(
FeatureStatus
:
:
Blocklisted
message
.
get
(
)
failureId
)
;
return
;
}
if
(
IsHeadless
(
)
)
{
gpuProc
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
Headless
mode
is
enabled
"
"
FEATURE_FAILURE_HEADLESS_MODE
"
_ns
)
;
return
;
}
if
(
InSafeMode
(
)
)
{
gpuProc
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
Safe
-
mode
is
enabled
"
"
FEATURE_FAILURE_SAFE_MODE
"
_ns
)
;
return
;
}
InitPlatformGPUProcessPrefs
(
)
;
}
void
gfxPlatform
:
:
InitCompositorAccelerationPrefs
(
)
{
const
char
*
acceleratedEnv
=
PR_GetEnv
(
"
MOZ_ACCELERATED
"
)
;
FeatureState
&
feature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
HW_COMPOSITING
)
;
if
(
feature
.
SetDefault
(
AccelerateLayersByDefault
(
)
FeatureStatus
:
:
Blocked
"
Acceleration
blocked
by
platform
"
)
)
{
if
(
StaticPrefs
:
:
layers_acceleration_disabled_AtStartup_DoNotUseDirectly
(
)
)
{
feature
.
UserDisable
(
"
Disabled
by
layers
.
acceleration
.
disabled
=
true
"
"
FEATURE_FAILURE_COMP_PREF
"
_ns
)
;
}
else
if
(
acceleratedEnv
&
&
*
acceleratedEnv
=
=
'
0
'
)
{
feature
.
UserDisable
(
"
Disabled
by
envvar
"
"
FEATURE_FAILURE_COMP_ENV
"
_ns
)
;
}
}
else
{
if
(
acceleratedEnv
&
&
*
acceleratedEnv
=
=
'
1
'
)
{
feature
.
UserEnable
(
"
Enabled
by
envvar
"
)
;
}
}
if
(
StaticPrefs
:
:
layers_acceleration_force_enabled_AtStartup_DoNotUseDirectly
(
)
)
{
feature
.
UserForceEnable
(
"
Force
-
enabled
by
pref
"
)
;
}
if
(
InSafeMode
(
)
)
{
feature
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
Acceleration
blocked
by
safe
-
mode
"
"
FEATURE_FAILURE_COMP_SAFEMODE
"
_ns
)
;
}
if
(
IsHeadless
(
)
)
{
feature
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
Acceleration
blocked
by
headless
mode
"
"
FEATURE_FAILURE_COMP_HEADLESSMODE
"
_ns
)
;
}
}
bool
gfxPlatform
:
:
WebRenderPrefEnabled
(
)
{
return
StaticPrefs
:
:
gfx_webrender_all_AtStartup
(
)
|
|
StaticPrefs
:
:
gfx_webrender_enabled_AtStartup_DoNotUseDirectly
(
)
;
}
bool
gfxPlatform
:
:
WebRenderEnvvarEnabled
(
)
{
const
char
*
env
=
PR_GetEnv
(
"
MOZ_WEBRENDER
"
)
;
return
(
env
&
&
*
env
=
=
'
1
'
)
;
}
const
char
*
gfxPlatform
:
:
WebRenderResourcePathOverride
(
)
{
const
char
*
resourcePath
=
PR_GetEnv
(
"
WR_RESOURCE_PATH
"
)
;
if
(
!
resourcePath
|
|
resourcePath
[
0
]
=
=
'
\
0
'
)
{
return
nullptr
;
}
return
resourcePath
;
}
void
gfxPlatform
:
:
InitWebRenderConfig
(
)
{
bool
prefEnabled
=
WebRenderPrefEnabled
(
)
;
bool
envvarEnabled
=
WebRenderEnvvarEnabled
(
)
;
ScopedGfxFeatureReporter
reporter
(
"
WR
"
prefEnabled
|
|
envvarEnabled
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
if
(
gfxVars
:
:
UseWebRender
(
)
)
{
reporter
.
SetSuccessful
(
)
;
}
return
;
}
gfxConfigManager
manager
;
manager
.
Init
(
)
;
manager
.
ConfigureWebRender
(
)
;
bool
hasHardware
=
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER
)
;
bool
hasSoftware
=
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER_SOFTWARE
)
;
bool
hasWebRender
=
hasHardware
|
|
hasSoftware
;
#
ifdef
MOZ_WIDGET_GTK
if
(
!
gfxConfig
:
:
IsForcedOnByUser
(
Feature
:
:
WEBRENDER
)
&
&
StaticPrefs
:
:
gfx_webrender_reject_software_driver_AtStartup
(
)
)
{
gfxVars
:
:
SetWebRenderRequiresHardwareDriver
(
true
)
;
}
#
endif
#
ifdef
XP_WIN
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER_ANGLE
)
)
{
gfxVars
:
:
SetUseWebRenderANGLE
(
hasWebRender
)
;
}
#
endif
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER_SHADER_CACHE
)
)
{
gfxVars
:
:
SetUseWebRenderProgramBinaryDisk
(
hasWebRender
)
;
}
gfxVars
:
:
SetUseWebRenderOptimizedShaders
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER_OPTIMIZED_SHADERS
)
)
;
gfxVars
:
:
SetUseSoftwareWebRender
(
!
hasHardware
&
&
hasSoftware
)
;
Preferences
:
:
RegisterPrefixCallbackAndCall
(
SwapIntervalPrefChangeCallback
"
gfx
.
swap
-
interval
"
)
;
if
(
hasWebRender
)
{
gfxVars
:
:
SetUseWebRender
(
true
)
;
reporter
.
SetSuccessful
(
)
;
Preferences
:
:
RegisterPrefixCallbackAndCall
(
WebRenderDebugPrefChangeCallback
WR_DEBUG_PREF
)
;
RegisterWebRenderBoolParamCallback
(
)
;
Preferences
:
:
RegisterPrefixCallbackAndCall
(
WebRendeProfilerUIPrefChangeCallback
"
gfx
.
webrender
.
debug
.
profiler
-
ui
"
)
;
Preferences
:
:
RegisterCallback
(
WebRenderQualityPrefChangeCallback
nsDependentCString
(
StaticPrefs
:
:
GetPrefName_gfx_webrender_quality_force_subpixel_aa_where_possible
(
)
)
)
;
Preferences
:
:
RegisterCallback
(
WebRenderBatchingPrefChangeCallback
nsDependentCString
(
StaticPrefs
:
:
GetPrefName_gfx_webrender_batching_lookback
(
)
)
)
;
Preferences
:
:
RegisterCallbackAndCall
(
WebRenderBlobTileSizePrefChangeCallback
nsDependentCString
(
StaticPrefs
:
:
GetPrefName_gfx_webrender_blob_tile_size
(
)
)
)
;
Preferences
:
:
RegisterCallbackAndCall
(
WebRenderUploadThresholdPrefChangeCallback
nsDependentCString
(
StaticPrefs
:
:
GetPrefName_gfx_webrender_batched_upload_threshold
(
)
)
)
;
if
(
WebRenderResourcePathOverride
(
)
)
{
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
IsWebRenderResourcePathOverridden
true
)
;
}
UpdateForceSubpixelAAWherePossible
(
)
;
}
#
ifdef
XP_WIN
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER_DCOMP_PRESENT
)
)
{
gfxVars
:
:
SetUseWebRenderDCompWin
(
true
)
;
}
if
(
StaticPrefs
:
:
gfx_webrender_software_d3d11_AtStartup
(
)
)
{
gfxVars
:
:
SetAllowSoftwareWebRenderD3D11
(
true
)
;
}
bool
useVideoOverlay
=
false
;
if
(
StaticPrefs
:
:
gfx_webrender_dcomp_video_overlay_win_AtStartup
(
)
)
{
if
(
IsWin10AnniversaryUpdateOrLater
(
)
&
&
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER_COMPOSITOR
)
)
{
MOZ_ASSERT
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER_DCOMP_PRESENT
)
)
;
useVideoOverlay
=
true
;
}
if
(
useVideoOverlay
&
&
!
StaticPrefs
:
:
gfx_webrender_dcomp_video_overlay_win_force_enabled_AtStartup
(
)
)
{
nsCString
failureId
;
int32_t
status
;
const
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
components
:
:
GfxInfo
:
:
Service
(
)
;
if
(
NS_FAILED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_VIDEO_OVERLAY
failureId
&
status
)
)
)
{
FeatureState
&
feature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
VIDEO_OVERLAY
)
;
feature
.
DisableByDefault
(
FeatureStatus
:
:
BlockedNoGfxInfo
"
gfxInfo
is
broken
"
"
FEATURE_FAILURE_WR_NO_GFX_INFO
"
_ns
)
;
useVideoOverlay
=
false
;
}
else
{
if
(
status
!
=
nsIGfxInfo
:
:
FEATURE_ALLOW_ALWAYS
)
{
FeatureState
&
feature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
VIDEO_OVERLAY
)
;
feature
.
DisableByDefault
(
FeatureStatus
:
:
Blocked
"
Blocklisted
by
gfxInfo
"
failureId
)
;
useVideoOverlay
=
false
;
}
}
}
}
if
(
useVideoOverlay
)
{
FeatureState
&
feature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
VIDEO_OVERLAY
)
;
feature
.
EnableByDefault
(
)
;
gfxVars
:
:
SetUseWebRenderDCompVideoOverlayWin
(
true
)
;
}
bool
useHwVideoZeroCopy
=
false
;
if
(
StaticPrefs
:
:
media_wmf_zero_copy_nv12_textures_AtStartup
(
)
)
{
if
(
IsWin10OrLater
(
)
&
&
hasHardware
)
{
useHwVideoZeroCopy
=
true
;
}
if
(
useHwVideoZeroCopy
&
&
!
StaticPrefs
:
:
media_wmf_zero_copy_nv12_textures_force_enabled_AtStartup
(
)
)
{
nsCString
failureId
;
int32_t
status
;
const
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
components
:
:
GfxInfo
:
:
Service
(
)
;
if
(
NS_FAILED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_HW_DECODED_VIDEO_ZERO_COPY
failureId
&
status
)
)
)
{
FeatureState
&
feature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
HW_DECODED_VIDEO_ZERO_COPY
)
;
feature
.
DisableByDefault
(
FeatureStatus
:
:
BlockedNoGfxInfo
"
gfxInfo
is
broken
"
"
FEATURE_FAILURE_WR_NO_GFX_INFO
"
_ns
)
;
useHwVideoZeroCopy
=
false
;
}
else
{
if
(
status
!
=
nsIGfxInfo
:
:
FEATURE_ALLOW_ALWAYS
)
{
FeatureState
&
feature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
HW_DECODED_VIDEO_ZERO_COPY
)
;
feature
.
DisableByDefault
(
FeatureStatus
:
:
Blocked
"
Blocklisted
by
gfxInfo
"
failureId
)
;
useHwVideoZeroCopy
=
false
;
}
}
}
}
if
(
useHwVideoZeroCopy
)
{
FeatureState
&
feature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
HW_DECODED_VIDEO_ZERO_COPY
)
;
feature
.
EnableByDefault
(
)
;
gfxVars
:
:
SetHwDecodedVideoZeroCopy
(
true
)
;
}
bool
reuseDecoderDevice
=
false
;
if
(
StaticPrefs
:
:
gfx_direct3d11_reuse_decoder_device_AtStartup
(
)
)
{
reuseDecoderDevice
=
true
;
if
(
reuseDecoderDevice
&
&
!
StaticPrefs
:
:
gfx_direct3d11_reuse_decoder_device_force_enabled_AtStartup
(
)
)
{
nsCString
failureId
;
int32_t
status
;
const
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
components
:
:
GfxInfo
:
:
Service
(
)
;
if
(
NS_FAILED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_REUSE_DECODER_DEVICE
failureId
&
status
)
)
)
{
FeatureState
&
feature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
REUSE_DECODER_DEVICE
)
;
feature
.
DisableByDefault
(
FeatureStatus
:
:
BlockedNoGfxInfo
"
gfxInfo
is
broken
"
"
FEATURE_FAILURE_WR_NO_GFX_INFO
"
_ns
)
;
reuseDecoderDevice
=
false
;
}
else
{
if
(
status
!
=
nsIGfxInfo
:
:
FEATURE_ALLOW_ALWAYS
)
{
FeatureState
&
feature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
REUSE_DECODER_DEVICE
)
;
feature
.
DisableByDefault
(
FeatureStatus
:
:
Blocked
"
Blocklisted
by
gfxInfo
"
failureId
)
;
reuseDecoderDevice
=
false
;
}
}
}
}
if
(
reuseDecoderDevice
)
{
FeatureState
&
feature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
REUSE_DECODER_DEVICE
)
;
feature
.
EnableByDefault
(
)
;
gfxVars
:
:
SetReuseDecoderDevice
(
true
)
;
}
if
(
Preferences
:
:
GetBool
(
"
gfx
.
webrender
.
flip
-
sequential
"
false
)
)
{
if
(
UseWebRender
(
)
&
&
gfxVars
:
:
UseWebRenderANGLE
(
)
)
{
gfxVars
:
:
SetUseWebRenderFlipSequentialWin
(
true
)
;
}
}
if
(
Preferences
:
:
GetBool
(
"
gfx
.
webrender
.
triple
-
buffering
.
enabled
"
false
)
)
{
if
(
gfxVars
:
:
UseWebRenderDCompWin
(
)
|
|
gfxVars
:
:
UseWebRenderFlipSequentialWin
(
)
)
{
gfxVars
:
:
SetUseWebRenderTripleBufferingWin
(
true
)
;
}
}
#
endif
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER_COMPOSITOR
)
)
{
gfxVars
:
:
SetUseWebRenderCompositor
(
true
)
;
}
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_OS_COMPOSITOR
gfx
:
:
gfxConfig
:
:
IsEnabled
(
gfx
:
:
Feature
:
:
WEBRENDER_COMPOSITOR
)
)
;
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER_PARTIAL
)
)
{
gfxVars
:
:
SetWebRenderMaxPartialPresentRects
(
StaticPrefs
:
:
gfx_webrender_max_partial_present_rects_AtStartup
(
)
)
;
}
gfxVars
:
:
SetUseGLSwizzle
(
IsFeatureSupported
(
nsIGfxInfo
:
:
FEATURE_GL_SWIZZLE
true
)
)
;
gfxVars
:
:
SetUseWebRenderScissoredCacheClears
(
IsFeatureSupported
(
nsIGfxInfo
:
:
FEATURE_WEBRENDER_SCISSORED_CACHE_CLEARS
true
)
)
;
gfxUtils
:
:
RemoveShaderCacheFromDiskIfNecessary
(
)
;
}
void
gfxPlatform
:
:
InitHardwareVideoConfig
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
if
(
kIsWayland
|
|
kIsX11
)
{
return
;
}
nsCString
message
;
nsCString
failureId
;
FeatureState
&
featureVP8
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
VP8_HW_DECODE
)
;
featureVP8
.
EnableByDefault
(
)
;
if
(
!
IsGfxInfoStatusOkay
(
nsIGfxInfo
:
:
FEATURE_VP8_HW_DECODE
&
message
failureId
)
)
{
featureVP8
.
Disable
(
FeatureStatus
:
:
Blocklisted
message
.
get
(
)
failureId
)
;
}
gfxVars
:
:
SetUseVP8HwDecode
(
featureVP8
.
IsEnabled
(
)
)
;
FeatureState
&
featureVP9
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
VP9_HW_DECODE
)
;
featureVP9
.
EnableByDefault
(
)
;
if
(
!
IsGfxInfoStatusOkay
(
nsIGfxInfo
:
:
FEATURE_VP9_HW_DECODE
&
message
failureId
)
)
{
featureVP9
.
Disable
(
FeatureStatus
:
:
Blocklisted
message
.
get
(
)
failureId
)
;
}
gfxVars
:
:
SetUseVP9HwDecode
(
featureVP9
.
IsEnabled
(
)
)
;
}
void
gfxPlatform
:
:
InitWebGLConfig
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
return
;
const
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
components
:
:
GfxInfo
:
:
Service
(
)
;
const
auto
IsFeatureOk
=
[
&
]
(
const
int32_t
feature
)
{
nsCString
discardFailureId
;
int32_t
status
;
MOZ_RELEASE_ASSERT
(
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
feature
discardFailureId
&
status
)
)
)
;
return
(
status
=
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
)
;
}
;
gfxVars
:
:
SetAllowWebgl2
(
IsFeatureOk
(
nsIGfxInfo
:
:
FEATURE_WEBGL2
)
)
;
gfxVars
:
:
SetWebglAllowWindowsNativeGl
(
IsFeatureOk
(
nsIGfxInfo
:
:
FEATURE_WEBGL_OPENGL
)
)
;
gfxVars
:
:
SetAllowWebglAccelAngle
(
IsFeatureOk
(
nsIGfxInfo
:
:
FEATURE_WEBGL_ANGLE
)
)
;
if
(
kIsMacOS
)
{
nsString
vendorID
deviceID
;
gfxInfo
-
>
GetAdapterVendorID
(
vendorID
)
;
gfxInfo
-
>
GetAdapterDeviceID
(
deviceID
)
;
if
(
vendorID
.
EqualsLiteral
(
"
0x8086
"
)
&
&
(
deviceID
.
EqualsLiteral
(
"
0x0116
"
)
|
|
deviceID
.
EqualsLiteral
(
"
0x0126
"
)
)
)
{
gfxVars
:
:
SetWebglAllowCoreProfile
(
false
)
;
}
}
bool
allowWebGLOop
=
IsFeatureOk
(
nsIGfxInfo
:
:
FEATURE_ALLOW_WEBGL_OUT_OF_PROCESS
)
;
gfxVars
:
:
SetAllowWebglOop
(
allowWebGLOop
)
;
bool
threadsafeGL
=
IsFeatureOk
(
nsIGfxInfo
:
:
FEATURE_THREADSAFE_GL
)
;
threadsafeGL
|
=
StaticPrefs
:
:
webgl_threadsafe_gl_force_enabled_AtStartup
(
)
;
threadsafeGL
&
=
!
StaticPrefs
:
:
webgl_threadsafe_gl_force_disabled_AtStartup
(
)
;
gfxVars
:
:
SetSupportsThreadsafeGL
(
threadsafeGL
)
;
bool
useCanvasRenderThread
=
threadsafeGL
&
&
StaticPrefs
:
:
webgl_use_canvas_render_thread_AtStartup
(
)
;
gfxVars
:
:
SetUseCanvasRenderThread
(
useCanvasRenderThread
)
;
if
(
kIsAndroid
)
{
nsAutoString
renderer
;
gfxInfo
-
>
GetAdapterDeviceID
(
renderer
)
;
if
(
renderer
.
Find
(
u
"
Adreno
(
TM
)
630
"
)
!
=
-
1
)
{
gfxVars
:
:
SetAllowEglRbab
(
false
)
;
}
}
if
(
kIsWayland
|
|
kIsX11
)
{
nsCString
discardFailureId
;
int32_t
status
;
FeatureState
&
feature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
DMABUF_SURFACE_EXPORT
)
;
if
(
NS_FAILED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_DMABUF_SURFACE_EXPORT
discardFailureId
&
status
)
)
|
|
status
!
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
)
{
feature
.
DisableByDefault
(
FeatureStatus
:
:
Blocked
"
Blocklisted
by
gfxInfo
"
discardFailureId
)
;
gfxVars
:
:
SetUseDMABufSurfaceExport
(
false
)
;
}
else
{
feature
.
EnableByDefault
(
)
;
}
}
}
void
gfxPlatform
:
:
InitWebGPUConfig
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
FeatureState
&
feature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
WEBGPU
)
;
feature
.
SetDefaultFromPref
(
"
dom
.
webgpu
.
enabled
"
true
false
)
;
nsCString
message
;
nsCString
failureId
;
if
(
!
IsGfxInfoStatusOkay
(
nsIGfxInfo
:
:
FEATURE_WEBGPU
&
message
failureId
)
)
{
feature
.
Disable
(
FeatureStatus
:
:
Blocklisted
message
.
get
(
)
failureId
)
;
}
#
ifdef
RELEASE_OR_BETA
feature
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
WebGPU
cannot
be
enabled
in
release
or
beta
"
"
WEBGPU_DISABLE_RELEASE_OR_BETA
"
_ns
)
;
#
else
if
(
StaticPrefs
:
:
gfx_webgpu_force_enabled_AtStartup
(
)
)
{
feature
.
UserForceEnable
(
"
Force
-
enabled
by
pref
"
)
;
}
#
endif
gfxVars
:
:
SetAllowWebGPU
(
feature
.
IsEnabled
(
)
)
;
}
#
ifdef
XP_WIN
static
void
WindowOcclusionPrefChangeCallback
(
const
char
*
aPref
void
*
)
{
const
char
*
env
=
PR_GetEnv
(
"
MOZ_WINDOW_OCCLUSION
"
)
;
if
(
env
)
{
return
;
}
FeatureState
&
feature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
WINDOW_OCCLUSION
)
;
bool
enabled
=
StaticPrefs
:
:
widget_windows_window_occlusion_tracking_enabled
(
)
;
printf_stderr
(
"
Dynamically
enable
window
occlusion
%
d
\
n
"
enabled
)
;
if
(
enabled
)
{
feature
.
UserEnable
(
"
User
enabled
by
pref
"
)
;
}
else
{
feature
.
UserDisable
(
"
User
disabled
via
pref
"
"
FEATURE_FAILURE_PREF_DISABLED
"
_ns
)
;
}
widget
:
:
WinUtils
:
:
EnableWindowOcclusion
(
enabled
)
;
}
#
endif
void
gfxPlatform
:
:
InitWindowOcclusionConfig
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
#
ifdef
XP_WIN
FeatureState
&
feature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
WINDOW_OCCLUSION
)
;
feature
.
SetDefaultFromPref
(
StaticPrefs
:
:
GetPrefName_widget_windows_window_occlusion_tracking_enabled
(
)
true
StaticPrefs
:
:
GetPrefDefault_widget_windows_window_occlusion_tracking_enabled
(
)
)
;
const
char
*
env
=
PR_GetEnv
(
"
MOZ_WINDOW_OCCLUSION
"
)
;
if
(
env
)
{
if
(
*
env
=
=
'
1
'
)
{
feature
.
UserForceEnable
(
"
Force
enabled
by
envvar
"
)
;
}
else
{
feature
.
UserDisable
(
"
Force
disabled
by
envvar
"
"
FEATURE_FAILURE_OCCL_ENV
"
_ns
)
;
}
}
Preferences
:
:
RegisterCallback
(
WindowOcclusionPrefChangeCallback
nsDependentCString
(
StaticPrefs
:
:
GetPrefName_widget_windows_window_occlusion_tracking_enabled
(
)
)
)
;
#
endif
}
static
void
BackdropFilterPrefChangeCallback
(
const
char
*
void
*
)
{
FeatureState
&
feature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
BACKDROP_FILTER
)
;
feature
.
Reset
(
)
;
feature
.
EnableByDefault
(
)
;
if
(
StaticPrefs
:
:
layout_css_backdrop_filter_force_enabled
(
)
)
{
feature
.
UserForceEnable
(
"
Force
enabled
by
pref
"
)
;
}
nsCString
message
;
nsCString
failureId
;
if
(
!
gfxPlatform
:
:
IsGfxInfoStatusOkay
(
nsIGfxInfo
:
:
FEATURE_BACKDROP_FILTER
&
message
failureId
)
)
{
feature
.
Disable
(
FeatureStatus
:
:
Blocklisted
message
.
get
(
)
failureId
)
;
}
gfxVars
:
:
SetAllowBackdropFilter
(
feature
.
IsEnabled
(
)
)
;
}
void
gfxPlatform
:
:
InitBackdropFilterConfig
(
)
{
gfxVars
:
:
AddReceiver
(
&
nsCSSProps
:
:
GfxVarReceiver
(
)
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
nsCSSProps
:
:
RecomputeEnabledState
(
StaticPrefs
:
:
GetPrefName_layout_css_backdrop_filter_enabled
(
)
)
;
return
;
}
BackdropFilterPrefChangeCallback
(
nullptr
nullptr
)
;
Preferences
:
:
RegisterCallback
(
BackdropFilterPrefChangeCallback
nsDependentCString
(
StaticPrefs
:
:
GetPrefName_layout_css_backdrop_filter_force_enabled
(
)
)
)
;
}
bool
gfxPlatform
:
:
CanUseHardwareVideoDecoding
(
)
{
MOZ_ASSERT
(
sLayersAccelerationPrefsInitialized
)
;
return
sLayersSupportsHardwareVideoDecoding
&
&
!
sLayersHardwareVideoDecodingFailed
;
}
bool
gfxPlatform
:
:
AccelerateLayersByDefault
(
)
{
#
if
defined
(
MOZ_GL_PROVIDER
)
|
|
defined
(
MOZ_WIDGET_UIKIT
)
return
true
;
#
else
return
false
;
#
endif
}
bool
gfxPlatform
:
:
UsesOffMainThreadCompositing
(
)
{
if
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_GPU
)
{
return
true
;
}
static
bool
firstTime
=
true
;
static
bool
result
=
false
;
if
(
firstTime
)
{
MOZ_ASSERT
(
sLayersAccelerationPrefsInitialized
)
;
result
=
gfxVars
:
:
BrowserTabsRemoteAutostart
(
)
|
|
!
StaticPrefs
:
:
layers_offmainthreadcomposition_force_disabled_AtStartup
(
)
;
#
if
defined
(
MOZ_WIDGET_GTK
)
result
|
=
StaticPrefs
:
:
layers_acceleration_force_enabled_AtStartup_DoNotUseDirectly
(
)
;
#
endif
firstTime
=
false
;
}
return
result
;
}
RefPtr
<
mozilla
:
:
VsyncDispatcher
>
gfxPlatform
:
:
GetGlobalVsyncDispatcher
(
)
{
MOZ_ASSERT
(
mVsyncDispatcher
"
mVsyncDispatcher
should
have
been
initialized
by
ReInitFrameRate
"
"
during
gfxPlatform
init
"
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
return
mVsyncDispatcher
;
}
already_AddRefed
<
mozilla
:
:
gfx
:
:
VsyncSource
>
gfxPlatform
:
:
GetGlobalHardwareVsyncSource
(
)
{
if
(
!
mGlobalHardwareVsyncSource
)
{
mGlobalHardwareVsyncSource
=
CreateGlobalHardwareVsyncSource
(
)
;
}
return
do_AddRef
(
mGlobalHardwareVsyncSource
)
;
}
already_AddRefed
<
mozilla
:
:
gfx
:
:
VsyncSource
>
gfxPlatform
:
:
GetSoftwareVsyncSource
(
)
{
if
(
!
mSoftwareVsyncSource
)
{
double
rateInMS
=
1000
.
0
/
(
double
)
gfxPlatform
:
:
GetSoftwareVsyncRate
(
)
;
mSoftwareVsyncSource
=
new
mozilla
:
:
gfx
:
:
SoftwareVsyncSource
(
TimeDuration
:
:
FromMilliseconds
(
rateInMS
)
)
;
}
return
do_AddRef
(
mSoftwareVsyncSource
)
;
}
bool
gfxPlatform
:
:
IsInLayoutAsapMode
(
)
{
return
StaticPrefs
:
:
layout_frame_rate
(
)
=
=
0
;
}
static
int
LayoutFrameRateFromPrefs
(
)
{
auto
val
=
StaticPrefs
:
:
layout_frame_rate
(
)
;
if
(
StaticPrefs
:
:
privacy_resistFingerprinting
(
)
)
{
val
=
60
;
}
return
val
;
}
bool
gfxPlatform
:
:
ForceSoftwareVsync
(
)
{
return
LayoutFrameRateFromPrefs
(
)
>
0
;
}
int
gfxPlatform
:
:
GetSoftwareVsyncRate
(
)
{
int
preferenceRate
=
LayoutFrameRateFromPrefs
(
)
;
if
(
preferenceRate
<
=
0
)
{
return
gfxPlatform
:
:
GetDefaultFrameRate
(
)
;
}
return
preferenceRate
;
}
int
gfxPlatform
:
:
GetDefaultFrameRate
(
)
{
return
60
;
}
void
gfxPlatform
:
:
ReInitFrameRate
(
const
char
*
aPrefIgnored
void
*
aDataIgnored
)
{
MOZ_RELEASE_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
gPlatform
-
>
mSoftwareVsyncSource
)
{
double
rateInMS
=
1000
.
0
/
(
double
)
gfxPlatform
:
:
GetSoftwareVsyncRate
(
)
;
gPlatform
-
>
mSoftwareVsyncSource
-
>
SetVsyncRate
(
TimeDuration
:
:
FromMilliseconds
(
rateInMS
)
)
;
}
RefPtr
<
VsyncSource
>
vsyncSource
=
gfxPlatform
:
:
ForceSoftwareVsync
(
)
?
gPlatform
-
>
GetSoftwareVsyncSource
(
)
:
gPlatform
-
>
GetGlobalHardwareVsyncSource
(
)
;
gPlatform
-
>
mVsyncDispatcher
-
>
SetVsyncSource
(
vsyncSource
)
;
}
const
char
*
gfxPlatform
:
:
GetAzureCanvasBackend
(
)
const
{
BackendType
backend
{
}
;
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
)
{
BackendPrefsData
data
=
GetBackendPrefs
(
)
;
backend
=
GetCanvasBackendPref
(
data
.
mCanvasBitmask
)
;
if
(
backend
=
=
BackendType
:
:
NONE
)
{
backend
=
data
.
mCanvasDefault
;
}
}
else
{
backend
=
mPreferredCanvasBackend
;
}
return
GetBackendName
(
backend
)
;
}
const
char
*
gfxPlatform
:
:
GetAzureContentBackend
(
)
const
{
BackendType
backend
{
}
;
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
)
{
BackendPrefsData
data
=
GetBackendPrefs
(
)
;
backend
=
GetContentBackendPref
(
data
.
mContentBitmask
)
;
if
(
backend
=
=
BackendType
:
:
NONE
)
{
backend
=
data
.
mContentDefault
;
}
}
else
{
backend
=
mContentBackend
;
}
return
GetBackendName
(
backend
)
;
}
void
gfxPlatform
:
:
GetAzureBackendInfo
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
)
{
aObj
.
DefineProperty
(
"
AzureCanvasBackend
(
UI
Process
)
"
GetBackendName
(
mPreferredCanvasBackend
)
)
;
aObj
.
DefineProperty
(
"
AzureFallbackCanvasBackend
(
UI
Process
)
"
GetBackendName
(
mFallbackCanvasBackend
)
)
;
aObj
.
DefineProperty
(
"
AzureContentBackend
(
UI
Process
)
"
GetBackendName
(
mContentBackend
)
)
;
}
else
{
aObj
.
DefineProperty
(
"
AzureFallbackCanvasBackend
"
GetBackendName
(
mFallbackCanvasBackend
)
)
;
}
aObj
.
DefineProperty
(
"
AzureCanvasBackend
"
GetAzureCanvasBackend
(
)
)
;
aObj
.
DefineProperty
(
"
AzureContentBackend
"
GetAzureContentBackend
(
)
)
;
}
void
gfxPlatform
:
:
GetApzSupportInfo
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
if
(
!
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
)
{
return
;
}
if
(
SupportsApzWheelInput
(
)
)
{
aObj
.
DefineProperty
(
"
ApzWheelInput
"
1
)
;
}
if
(
SupportsApzTouchInput
(
)
)
{
aObj
.
DefineProperty
(
"
ApzTouchInput
"
1
)
;
}
if
(
SupportsApzDragInput
(
)
)
{
aObj
.
DefineProperty
(
"
ApzDragInput
"
1
)
;
}
if
(
SupportsApzKeyboardInput
(
)
&
&
!
StaticPrefs
:
:
accessibility_browsewithcaret
(
)
)
{
aObj
.
DefineProperty
(
"
ApzKeyboardInput
"
1
)
;
}
if
(
SupportsApzAutoscrolling
(
)
)
{
aObj
.
DefineProperty
(
"
ApzAutoscrollInput
"
1
)
;
}
if
(
SupportsApzZooming
(
)
)
{
aObj
.
DefineProperty
(
"
ApzZoomingInput
"
1
)
;
}
}
void
gfxPlatform
:
:
GetFrameStats
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
uint32_t
i
=
0
;
for
(
FrameStats
&
f
:
mFrameStats
)
{
nsPrintfCString
name
(
"
Slow
Frame
#
%
02u
"
+
+
i
)
;
nsPrintfCString
value
(
"
Frame
%
"
PRIu64
"
(
%
s
)
CONTENT_FRAME_TIME
%
d
-
Transaction
start
%
f
main
-
thread
time
"
"
%
f
full
paint
time
%
f
Skipped
composites
%
u
Composite
start
%
f
"
"
Resource
upload
time
%
f
GPU
cache
upload
time
%
f
Render
time
%
f
"
"
Composite
time
%
f
"
f
.
id
(
)
.
mId
f
.
url
(
)
.
get
(
)
f
.
contentFrameTime
(
)
(
f
.
transactionStart
(
)
-
f
.
refreshStart
(
)
)
.
ToMilliseconds
(
)
(
f
.
fwdTime
(
)
-
f
.
transactionStart
(
)
)
.
ToMilliseconds
(
)
f
.
sceneBuiltTime
(
)
?
(
f
.
sceneBuiltTime
(
)
-
f
.
transactionStart
(
)
)
.
ToMilliseconds
(
)
:
0
.
0
f
.
skippedComposites
(
)
(
f
.
compositeStart
(
)
-
f
.
refreshStart
(
)
)
.
ToMilliseconds
(
)
f
.
resourceUploadTime
(
)
f
.
gpuCacheUploadTime
(
)
(
f
.
compositeEnd
(
)
-
f
.
renderStart
(
)
)
.
ToMilliseconds
(
)
(
f
.
compositeEnd
(
)
-
f
.
compositeStart
(
)
)
.
ToMilliseconds
(
)
)
;
aObj
.
DefineProperty
(
name
.
get
(
)
value
.
get
(
)
)
;
}
}
void
gfxPlatform
:
:
GetCMSSupportInfo
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
nsTArray
<
uint8_t
>
outputProfileData
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetPlatformCMSOutputProfileData
(
)
;
if
(
outputProfileData
.
IsEmpty
(
)
)
{
nsPrintfCString
msg
(
"
Empty
profile
data
"
)
;
aObj
.
DefineProperty
(
"
CMSOutputProfile
"
msg
.
get
(
)
)
;
return
;
}
const
size_t
kMaxProfileSize
=
8192
;
if
(
outputProfileData
.
Length
(
)
>
=
kMaxProfileSize
)
{
nsPrintfCString
msg
(
"
%
zu
bytes
too
large
"
outputProfileData
.
Length
(
)
)
;
aObj
.
DefineProperty
(
"
CMSOutputProfile
"
msg
.
get
(
)
)
;
return
;
}
nsString
encodedProfile
;
nsresult
rv
=
Base64Encode
(
reinterpret_cast
<
const
char
*
>
(
outputProfileData
.
Elements
(
)
)
outputProfileData
.
Length
(
)
encodedProfile
)
;
if
(
!
NS_SUCCEEDED
(
rv
)
)
{
nsPrintfCString
msg
(
"
base64
encode
failed
0x
%
08x
"
static_cast
<
uint32_t
>
(
rv
)
)
;
aObj
.
DefineProperty
(
"
CMSOutputProfile
"
msg
.
get
(
)
)
;
return
;
}
aObj
.
DefineProperty
(
"
CMSOutputProfile
"
encodedProfile
)
;
}
void
gfxPlatform
:
:
GetDisplayInfo
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
auto
&
screens
=
widget
:
:
ScreenManager
:
:
GetSingleton
(
)
.
CurrentScreenList
(
)
;
aObj
.
DefineProperty
(
"
DisplayCount
"
screens
.
Length
(
)
)
;
size_t
i
=
0
;
for
(
auto
&
screen
:
screens
)
{
const
LayoutDeviceIntRect
rect
=
screen
-
>
GetRect
(
)
;
nsPrintfCString
value
(
"
%
dx
%
d
%
dHz
scales
:
%
f
|
%
f
"
rect
.
width
rect
.
height
screen
-
>
GetRefreshRate
(
)
screen
-
>
GetContentsScaleFactor
(
)
screen
-
>
GetDefaultCSSScaleFactor
(
)
)
;
aObj
.
DefineProperty
(
nsPrintfCString
(
"
Display
%
zu
"
i
+
+
)
.
get
(
)
NS_ConvertUTF8toUTF16
(
value
)
)
;
}
if
(
XRE_IsParentProcess
(
)
)
{
GetPlatformDisplayInfo
(
aObj
)
;
}
}
void
gfxPlatform
:
:
GetOverlayInfo
(
mozilla
:
:
widget
:
:
InfoObject
&
aObj
)
{
if
(
mOverlayInfo
.
isNothing
(
)
)
{
return
;
}
auto
toString
=
[
]
(
mozilla
:
:
layers
:
:
OverlaySupportType
aType
)
-
>
const
char
*
{
switch
(
aType
)
{
case
mozilla
:
:
layers
:
:
OverlaySupportType
:
:
None
:
return
"
None
"
;
case
mozilla
:
:
layers
:
:
OverlaySupportType
:
:
Software
:
return
"
Software
"
;
case
mozilla
:
:
layers
:
:
OverlaySupportType
:
:
Direct
:
return
"
Direct
"
;
case
mozilla
:
:
layers
:
:
OverlaySupportType
:
:
Scaling
:
return
"
Scaling
"
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
to
be
called
"
)
;
}
MOZ_CRASH
(
"
Incomplete
switch
"
)
;
}
;
nsPrintfCString
value
(
"
NV12
=
%
s
YUV2
=
%
s
BGRA8
=
%
s
RGB10A2
=
%
s
"
toString
(
mOverlayInfo
.
ref
(
)
.
mNv12Overlay
)
toString
(
mOverlayInfo
.
ref
(
)
.
mYuy2Overlay
)
toString
(
mOverlayInfo
.
ref
(
)
.
mBgra8Overlay
)
toString
(
mOverlayInfo
.
ref
(
)
.
mRgb10a2Overlay
)
)
;
aObj
.
DefineProperty
(
"
OverlaySupport
"
NS_ConvertUTF8toUTF16
(
value
)
)
;
}
class
FrameStatsComparator
{
public
:
bool
Equals
(
const
FrameStats
&
aA
const
FrameStats
&
aB
)
const
{
return
aA
.
contentFrameTime
(
)
=
=
aB
.
contentFrameTime
(
)
;
}
bool
LessThan
(
const
FrameStats
&
aA
const
FrameStats
&
aB
)
const
{
return
aA
.
contentFrameTime
(
)
>
aB
.
contentFrameTime
(
)
;
}
}
;
void
gfxPlatform
:
:
NotifyFrameStats
(
nsTArray
<
FrameStats
>
&
&
aFrameStats
)
{
if
(
!
StaticPrefs
:
:
gfx_logging_slow_frames_enabled_AtStartup
(
)
)
{
return
;
}
FrameStatsComparator
comp
;
for
(
FrameStats
&
f
:
aFrameStats
)
{
mFrameStats
.
InsertElementSorted
(
f
comp
)
;
}
if
(
mFrameStats
.
Length
(
)
>
10
)
{
mFrameStats
.
SetLength
(
10
)
;
}
}
uint32_t
gfxPlatform
:
:
TargetFrameRate
(
)
{
if
(
gPlatform
&
&
gPlatform
-
>
mVsyncDispatcher
)
{
return
round
(
1000
.
0
/
gPlatform
-
>
mVsyncDispatcher
-
>
GetVsyncRate
(
)
.
ToMilliseconds
(
)
)
;
}
return
0
;
}
bool
gfxPlatform
:
:
UseDesktopZoomingScrollbars
(
)
{
return
StaticPrefs
:
:
apz_allow_zooming
(
)
&
&
!
StaticPrefs
:
:
apz_force_disable_desktop_zooming_scrollbars
(
)
;
}
bool
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
{
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
&
&
!
defined
(
MOZ_WIDGET_UIKIT
)
if
(
!
BrowserTabsRemoteAutostart
(
)
)
{
return
false
;
}
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
return
true
;
#
else
if
(
FissionAutostart
(
)
)
{
return
true
;
}
return
StaticPrefs
:
:
layers_async_pan_zoom_enabled_AtStartup_DoNotUseDirectly
(
)
;
#
endif
}
bool
gfxPlatform
:
:
PerfWarnings
(
)
{
return
StaticPrefs
:
:
gfx_perf_warnings_enabled
(
)
;
}
void
gfxPlatform
:
:
NotifyCompositorCreated
(
LayersBackend
aBackend
)
{
if
(
mCompositorBackend
=
=
aBackend
)
{
return
;
}
if
(
mCompositorBackend
!
=
LayersBackend
:
:
LAYERS_NONE
)
{
gfxCriticalNote
<
<
"
Compositors
might
be
mixed
(
"
<
<
int
(
mCompositorBackend
)
<
<
"
"
<
<
int
(
aBackend
)
<
<
"
)
"
;
}
mCompositorBackend
=
aBackend
;
if
(
XRE_IsParentProcess
(
)
)
{
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_COMPOSITOR
NS_ConvertUTF8toUTF16
(
GetLayersBackendName
(
mCompositorBackend
)
)
)
;
nsCString
geckoVersion
;
nsCOMPtr
<
nsIXULAppInfo
>
app
=
do_GetService
(
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
)
;
if
(
app
)
{
app
-
>
GetVersion
(
geckoVersion
)
;
}
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_LAST_COMPOSITOR_GECKO_VERSION
NS_ConvertASCIItoUTF16
(
geckoVersion
)
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_FEATURE_WEBRENDER
NS_ConvertUTF8toUTF16
(
gfxConfig
:
:
GetFeature
(
gfx
:
:
Feature
:
:
WEBRENDER
)
.
GetStatusAndFailureIdString
(
)
)
)
;
}
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
gfxPlatform
:
:
NotifyCompositorCreated
"
[
]
{
if
(
nsCOMPtr
<
nsIObserverService
>
obsvc
=
services
:
:
GetObserverService
(
)
)
{
obsvc
-
>
NotifyObservers
(
nullptr
"
compositor
:
created
"
nullptr
)
;
}
}
)
)
;
}
bool
gfxPlatform
:
:
FallbackFromAcceleration
(
FeatureStatus
aStatus
const
char
*
aMessage
const
nsACString
&
aFailureId
bool
aCrashAfterFinalFallback
)
{
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER
)
)
{
gfxConfig
:
:
GetFeature
(
Feature
:
:
WEBRENDER
)
.
ForceDisable
(
aStatus
aMessage
aFailureId
)
;
}
bool
swglFallbackAllowed
=
!
StaticPrefs
:
:
gfx_webrender_fallback_software_requires_gpu_process_AtStartup
(
)
|
|
gfxConfig
:
:
IsEnabled
(
Feature
:
:
GPU_PROCESS
)
;
#
ifdef
XP_WIN
if
(
StaticPrefs
:
:
gfx_webrender_fallback_software_d3d11_AtStartup
(
)
&
&
swglFallbackAllowed
&
&
gfxVars
:
:
AllowSoftwareWebRenderD3D11
(
)
&
&
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER_SOFTWARE
)
&
&
gfxConfig
:
:
IsEnabled
(
Feature
:
:
D3D11_COMPOSITING
)
&
&
gfxVars
:
:
UseWebRender
(
)
&
&
!
gfxVars
:
:
UseSoftwareWebRender
(
)
)
{
gfxCriticalNote
<
<
"
Fallback
WR
to
SW
-
WR
+
D3D11
"
;
gfxVars
:
:
SetUseSoftwareWebRender
(
true
)
;
return
true
;
}
if
(
StaticPrefs
:
:
gfx_webrender_fallback_software_d3d11_AtStartup
(
)
&
&
swglFallbackAllowed
&
&
gfxVars
:
:
AllowSoftwareWebRenderD3D11
(
)
&
&
gfxVars
:
:
UseSoftwareWebRender
(
)
)
{
gfxCriticalNote
<
<
"
Fallback
SW
-
WR
+
D3D11
to
SW
-
WR
"
;
gfxVars
:
:
SetAllowSoftwareWebRenderD3D11
(
false
)
;
return
true
;
}
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
DIRECT2D
)
)
{
gfxConfig
:
:
GetFeature
(
Feature
:
:
DIRECT2D
)
.
ForceDisable
(
aStatus
aMessage
aFailureId
)
;
}
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
D3D11_COMPOSITING
)
)
{
gfxConfig
:
:
GetFeature
(
Feature
:
:
D3D11_COMPOSITING
)
.
ForceDisable
(
aStatus
aMessage
aFailureId
)
;
if
(
StaticPrefs
:
:
gfx_webrender_fallback_software_AtStartup
(
)
&
&
swglFallbackAllowed
&
&
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER_SOFTWARE
)
&
&
!
gfxVars
:
:
UseWebRender
(
)
)
{
gfxCriticalNote
<
<
"
Fallback
D3D11
to
SW
-
WR
"
;
gfxVars
:
:
SetUseWebRender
(
true
)
;
gfxVars
:
:
SetUseSoftwareWebRender
(
true
)
;
return
true
;
}
}
#
endif
#
ifndef
MOZ_WIDGET_ANDROID
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
HW_COMPOSITING
)
)
{
gfxConfig
:
:
GetFeature
(
Feature
:
:
HW_COMPOSITING
)
.
ForceDisable
(
aStatus
aMessage
aFailureId
)
;
}
#
endif
if
(
!
gfxVars
:
:
UseWebRender
(
)
)
{
return
false
;
}
if
(
StaticPrefs
:
:
gfx_webrender_fallback_software_AtStartup
(
)
&
&
swglFallbackAllowed
&
&
gfxConfig
:
:
IsEnabled
(
Feature
:
:
WEBRENDER_SOFTWARE
)
&
&
!
gfxVars
:
:
UseSoftwareWebRender
(
)
)
{
gfxCriticalNote
<
<
"
Fallback
WR
to
SW
-
WR
"
;
gfxVars
:
:
SetUseSoftwareWebRender
(
true
)
;
return
true
;
}
MOZ_ASSERT
(
gfxVars
:
:
UseWebRender
(
)
)
;
if
(
!
gfxVars
:
:
UseSoftwareWebRender
(
)
)
{
gfxCriticalNoteOnce
<
<
"
Fallback
WR
to
SW
-
WR
forced
"
;
gfxVars
:
:
SetUseSoftwareWebRender
(
true
)
;
return
true
;
}
if
(
aCrashAfterFinalFallback
)
{
MOZ_CRASH
(
"
Fallback
configurations
exhausted
"
)
;
}
gfxCriticalNoteOnce
<
<
"
Fallback
remains
SW
-
WR
"
;
return
false
;
}
void
gfxPlatform
:
:
DisableGPUProcess
(
)
{
gfxVars
:
:
SetRemoteCanvasEnabled
(
false
)
;
RemoteTextureMap
:
:
Init
(
)
;
if
(
gfxVars
:
:
UseWebRender
(
)
)
{
if
(
gfxVars
:
:
UseCanvasRenderThread
(
)
)
{
gfx
:
:
CanvasRenderThread
:
:
Start
(
)
;
}
wr
:
:
RenderThread
:
:
Start
(
GPUProcessManager
:
:
Get
(
)
-
>
AllocateNamespace
(
)
)
;
image
:
:
ImageMemoryReporter
:
:
InitForWebRender
(
)
;
}
}
void
gfxPlatform
:
:
FetchAndImportContentDeviceData
(
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
if
(
gContentDeviceInitData
)
{
ImportContentDeviceData
(
*
gContentDeviceInitData
)
;
return
;
}
mozilla
:
:
dom
:
:
ContentChild
*
cc
=
mozilla
:
:
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
mozilla
:
:
gfx
:
:
ContentDeviceData
data
;
cc
-
>
SendGetGraphicsDeviceInitData
(
&
data
)
;
ImportContentDeviceData
(
data
)
;
}
void
gfxPlatform
:
:
ImportContentDeviceData
(
const
mozilla
:
:
gfx
:
:
ContentDeviceData
&
aData
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
const
DevicePrefs
&
prefs
=
aData
.
prefs
(
)
;
gfxConfig
:
:
Inherit
(
Feature
:
:
HW_COMPOSITING
prefs
.
hwCompositing
(
)
)
;
gfxConfig
:
:
Inherit
(
Feature
:
:
OPENGL_COMPOSITING
prefs
.
oglCompositing
(
)
)
;
}
void
gfxPlatform
:
:
BuildContentDeviceData
(
mozilla
:
:
gfx
:
:
ContentDeviceData
*
aOut
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
GPUProcessManager
:
:
Get
(
)
-
>
EnsureGPUReady
(
)
;
aOut
-
>
prefs
(
)
.
hwCompositing
(
)
=
gfxConfig
:
:
GetValue
(
Feature
:
:
HW_COMPOSITING
)
;
aOut
-
>
prefs
(
)
.
oglCompositing
(
)
=
gfxConfig
:
:
GetValue
(
Feature
:
:
OPENGL_COMPOSITING
)
;
}
void
gfxPlatform
:
:
ImportGPUDeviceData
(
const
mozilla
:
:
gfx
:
:
GPUDeviceData
&
aData
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
gfxConfig
:
:
ImportChange
(
Feature
:
:
OPENGL_COMPOSITING
aData
.
oglCompositing
(
)
)
;
}
bool
gfxPlatform
:
:
SupportsApzTouchInput
(
)
const
{
return
dom
:
:
TouchEvent
:
:
PrefEnabled
(
nullptr
)
;
}
bool
gfxPlatform
:
:
SupportsApzDragInput
(
)
const
{
return
StaticPrefs
:
:
apz_drag_enabled
(
)
;
}
bool
gfxPlatform
:
:
SupportsApzKeyboardInput
(
)
const
{
return
StaticPrefs
:
:
apz_keyboard_enabled_AtStartup
(
)
;
}
bool
gfxPlatform
:
:
SupportsApzAutoscrolling
(
)
const
{
return
StaticPrefs
:
:
apz_autoscroll_enabled
(
)
;
}
bool
gfxPlatform
:
:
SupportsApzZooming
(
)
const
{
return
StaticPrefs
:
:
apz_allow_zooming
(
)
;
}
void
gfxPlatform
:
:
InitOpenGLConfig
(
)
{
#
ifdef
XP_WIN
if
(
!
Preferences
:
:
GetBool
(
"
layers
.
prefer
-
opengl
"
)
)
{
return
;
}
#
endif
FeatureState
&
openGLFeature
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
OPENGL_COMPOSITING
)
;
if
(
!
gfxConfig
:
:
IsEnabled
(
Feature
:
:
HW_COMPOSITING
)
)
{
openGLFeature
.
DisableByDefault
(
FeatureStatus
:
:
Unavailable
"
Hardware
compositing
is
disabled
"
"
FEATURE_FAILURE_OPENGL_NEED_HWCOMP
"
_ns
)
;
return
;
}
#
ifdef
XP_WIN
openGLFeature
.
SetDefaultFromPref
(
StaticPrefs
:
:
GetPrefName_layers_prefer_opengl
(
)
true
StaticPrefs
:
:
GetPrefDefault_layers_prefer_opengl
(
)
)
;
#
else
openGLFeature
.
EnableByDefault
(
)
;
#
endif
if
(
StaticPrefs
:
:
layers_acceleration_force_enabled_AtStartup_DoNotUseDirectly
(
)
)
{
openGLFeature
.
UserForceEnable
(
"
Force
-
enabled
by
pref
"
)
;
return
;
}
nsCString
message
;
nsCString
failureId
;
if
(
!
IsGfxInfoStatusOkay
(
nsIGfxInfo
:
:
FEATURE_OPENGL_LAYERS
&
message
failureId
)
)
{
openGLFeature
.
Disable
(
FeatureStatus
:
:
Blocklisted
message
.
get
(
)
failureId
)
;
}
}
bool
gfxPlatform
:
:
IsGfxInfoStatusOkay
(
int32_t
aFeature
nsCString
*
aOutMessage
nsCString
&
aFailureId
)
{
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
components
:
:
GfxInfo
:
:
Service
(
)
;
if
(
!
gfxInfo
)
{
return
true
;
}
int32_t
status
;
if
(
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
aFeature
aFailureId
&
status
)
)
&
&
status
!
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
)
{
aOutMessage
-
>
AssignLiteral
(
"
#
BLOCKLIST_
"
)
;
aOutMessage
-
>
AppendASCII
(
aFailureId
.
get
(
)
)
;
return
false
;
}
return
true
;
}
