#
ifndef
GFX_FONT_UTILS_H
#
define
GFX_FONT_UTILS_H
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
<
new
>
#
include
<
utility
>
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
EndianUtils
.
h
"
#
include
"
mozilla
/
ServoStyleConstsInlines
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nscore
.
h
"
#
include
"
zlib
.
h
"
class
PickleIterator
;
class
gfxFontEntry
;
struct
gfxFontVariationAxis
;
struct
gfxFontVariationInstance
;
namespace
mozilla
{
class
Encoding
;
class
ServoStyleSet
;
namespace
gfx
{
struct
DeviceColor
;
}
}
#
ifdef
__MINGW32__
#
undef
min
#
undef
max
#
endif
#
undef
ERROR
/
*
defined
by
Windows
.
h
conflicts
with
some
generated
bindings
\
code
when
this
gets
indirectly
included
via
shared
font
list
\
*
/
typedef
struct
hb_blob_t
hb_blob_t
;
class
SharedBitSet
;
namespace
IPC
{
template
<
typename
T
>
struct
ParamTraits
;
}
class
gfxSparseBitSet
{
private
:
friend
class
SharedBitSet
;
enum
{
BLOCK_SIZE
=
32
}
;
enum
{
BLOCK_SIZE_BITS
=
BLOCK_SIZE
*
8
}
;
enum
{
NO_BLOCK
=
0xffff
}
;
struct
Block
{
explicit
Block
(
unsigned
char
memsetValue
=
0
)
{
memset
(
mBits
memsetValue
BLOCK_SIZE
)
;
}
uint8_t
mBits
[
BLOCK_SIZE
]
;
}
;
friend
struct
IPC
:
:
ParamTraits
<
gfxSparseBitSet
>
;
friend
struct
IPC
:
:
ParamTraits
<
Block
>
;
public
:
gfxSparseBitSet
(
)
=
default
;
bool
Equals
(
const
gfxSparseBitSet
*
aOther
)
const
{
if
(
mBlockIndex
.
Length
(
)
!
=
aOther
-
>
mBlockIndex
.
Length
(
)
)
{
return
false
;
}
size_t
n
=
mBlockIndex
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
n
;
+
+
i
)
{
uint32_t
b1
=
mBlockIndex
[
i
]
;
uint32_t
b2
=
aOther
-
>
mBlockIndex
[
i
]
;
if
(
(
b1
=
=
NO_BLOCK
)
!
=
(
b2
=
=
NO_BLOCK
)
)
{
return
false
;
}
if
(
b1
=
=
NO_BLOCK
)
{
continue
;
}
if
(
memcmp
(
&
mBlocks
[
b1
]
.
mBits
&
aOther
-
>
mBlocks
[
b2
]
.
mBits
BLOCK_SIZE
)
!
=
0
)
{
return
false
;
}
}
return
true
;
}
bool
test
(
uint32_t
aIndex
)
const
{
uint32_t
i
=
aIndex
/
BLOCK_SIZE_BITS
;
if
(
i
>
=
mBlockIndex
.
Length
(
)
|
|
mBlockIndex
[
i
]
=
=
NO_BLOCK
)
{
return
false
;
}
const
Block
&
block
=
mBlocks
[
mBlockIndex
[
i
]
]
;
return
(
(
block
.
mBits
[
(
aIndex
>
>
3
)
&
(
BLOCK_SIZE
-
1
)
]
)
&
(
1
<
<
(
aIndex
&
0x7
)
)
)
!
=
0
;
}
void
Dump
(
const
char
*
aPrefix
eGfxLog
aWhichLog
)
const
;
bool
TestRange
(
uint32_t
aStart
uint32_t
aEnd
)
{
uint32_t
startBlock
=
aStart
/
BLOCK_SIZE_BITS
;
uint32_t
blockLen
=
mBlockIndex
.
Length
(
)
;
if
(
startBlock
>
=
blockLen
)
{
return
false
;
}
bool
hasBlocksInRange
=
false
;
uint32_t
endBlock
=
aEnd
/
BLOCK_SIZE_BITS
;
for
(
uint32_t
bi
=
startBlock
;
bi
<
=
endBlock
;
bi
+
+
)
{
if
(
bi
<
blockLen
&
&
mBlockIndex
[
bi
]
!
=
NO_BLOCK
)
{
hasBlocksInRange
=
true
;
break
;
}
}
if
(
!
hasBlocksInRange
)
{
return
false
;
}
if
(
mBlockIndex
[
startBlock
]
!
=
NO_BLOCK
)
{
const
Block
&
block
=
mBlocks
[
mBlockIndex
[
startBlock
]
]
;
uint32_t
start
=
aStart
;
uint32_t
end
=
std
:
:
min
(
aEnd
(
(
startBlock
+
1
)
*
BLOCK_SIZE_BITS
)
-
1
)
;
for
(
uint32_t
i
=
start
;
i
<
=
end
;
i
+
+
)
{
if
(
(
block
.
mBits
[
(
i
>
>
3
)
&
(
BLOCK_SIZE
-
1
)
]
)
&
(
1
<
<
(
i
&
0x7
)
)
)
{
return
true
;
}
}
}
if
(
endBlock
=
=
startBlock
)
{
return
false
;
}
for
(
uint32_t
i
=
startBlock
+
1
;
i
<
endBlock
;
i
+
+
)
{
if
(
i
>
=
blockLen
|
|
mBlockIndex
[
i
]
=
=
NO_BLOCK
)
{
continue
;
}
const
Block
&
block
=
mBlocks
[
mBlockIndex
[
i
]
]
;
for
(
uint32_t
index
=
0
;
index
<
BLOCK_SIZE
;
index
+
+
)
{
if
(
block
.
mBits
[
index
]
)
{
return
true
;
}
}
}
if
(
endBlock
<
blockLen
&
&
mBlockIndex
[
endBlock
]
!
=
NO_BLOCK
)
{
const
Block
&
block
=
mBlocks
[
mBlockIndex
[
endBlock
]
]
;
uint32_t
start
=
endBlock
*
BLOCK_SIZE_BITS
;
uint32_t
end
=
aEnd
;
for
(
uint32_t
i
=
start
;
i
<
=
end
;
i
+
+
)
{
if
(
(
block
.
mBits
[
(
i
>
>
3
)
&
(
BLOCK_SIZE
-
1
)
]
)
&
(
1
<
<
(
i
&
0x7
)
)
)
{
return
true
;
}
}
}
return
false
;
}
void
set
(
uint32_t
aIndex
)
{
uint32_t
i
=
aIndex
/
BLOCK_SIZE_BITS
;
while
(
i
>
=
mBlockIndex
.
Length
(
)
)
{
mBlockIndex
.
AppendElement
(
NO_BLOCK
)
;
}
if
(
mBlockIndex
[
i
]
=
=
NO_BLOCK
)
{
mBlocks
.
AppendElement
(
)
;
MOZ_ASSERT
(
mBlocks
.
Length
(
)
<
0xffff
"
block
index
overflow
!
"
)
;
mBlockIndex
[
i
]
=
static_cast
<
uint16_t
>
(
mBlocks
.
Length
(
)
-
1
)
;
}
Block
&
block
=
mBlocks
[
mBlockIndex
[
i
]
]
;
block
.
mBits
[
(
aIndex
>
>
3
)
&
(
BLOCK_SIZE
-
1
)
]
|
=
1
<
<
(
aIndex
&
0x7
)
;
}
void
set
(
uint32_t
aIndex
bool
aValue
)
{
if
(
aValue
)
{
set
(
aIndex
)
;
}
else
{
clear
(
aIndex
)
;
}
}
void
SetRange
(
uint32_t
aStart
uint32_t
aEnd
)
{
const
uint32_t
startIndex
=
aStart
/
BLOCK_SIZE_BITS
;
const
uint32_t
endIndex
=
aEnd
/
BLOCK_SIZE_BITS
;
while
(
endIndex
>
=
mBlockIndex
.
Length
(
)
)
{
mBlockIndex
.
AppendElement
(
NO_BLOCK
)
;
}
for
(
uint32_t
i
=
startIndex
;
i
<
=
endIndex
;
+
+
i
)
{
const
uint32_t
blockFirstBit
=
i
*
BLOCK_SIZE_BITS
;
const
uint32_t
blockLastBit
=
blockFirstBit
+
BLOCK_SIZE_BITS
-
1
;
if
(
mBlockIndex
[
i
]
=
=
NO_BLOCK
)
{
bool
fullBlock
=
(
aStart
<
=
blockFirstBit
&
&
aEnd
>
=
blockLastBit
)
;
mBlocks
.
AppendElement
(
Block
(
fullBlock
?
0xFF
:
0
)
)
;
MOZ_ASSERT
(
mBlocks
.
Length
(
)
<
0xffff
"
block
index
overflow
!
"
)
;
mBlockIndex
[
i
]
=
static_cast
<
uint16_t
>
(
mBlocks
.
Length
(
)
-
1
)
;
if
(
fullBlock
)
{
continue
;
}
}
Block
&
block
=
mBlocks
[
mBlockIndex
[
i
]
]
;
const
uint32_t
start
=
aStart
>
blockFirstBit
?
aStart
-
blockFirstBit
:
0
;
const
uint32_t
end
=
std
:
:
min
<
uint32_t
>
(
aEnd
-
blockFirstBit
BLOCK_SIZE_BITS
-
1
)
;
for
(
uint32_t
bit
=
start
;
bit
<
=
end
;
+
+
bit
)
{
block
.
mBits
[
bit
>
>
3
]
|
=
1
<
<
(
bit
&
0x7
)
;
}
}
}
void
clear
(
uint32_t
aIndex
)
{
uint32_t
i
=
aIndex
/
BLOCK_SIZE_BITS
;
if
(
i
>
=
mBlockIndex
.
Length
(
)
)
{
return
;
}
if
(
mBlockIndex
[
i
]
=
=
NO_BLOCK
)
{
mBlocks
.
AppendElement
(
)
;
MOZ_ASSERT
(
mBlocks
.
Length
(
)
<
0xffff
"
block
index
overflow
!
"
)
;
mBlockIndex
[
i
]
=
static_cast
<
uint16_t
>
(
mBlocks
.
Length
(
)
-
1
)
;
}
Block
&
block
=
mBlocks
[
mBlockIndex
[
i
]
]
;
block
.
mBits
[
(
aIndex
>
>
3
)
&
(
BLOCK_SIZE
-
1
)
]
&
=
~
(
1
<
<
(
aIndex
&
0x7
)
)
;
}
void
ClearRange
(
uint32_t
aStart
uint32_t
aEnd
)
{
const
uint32_t
startIndex
=
aStart
/
BLOCK_SIZE_BITS
;
const
uint32_t
endIndex
=
aEnd
/
BLOCK_SIZE_BITS
;
for
(
uint32_t
i
=
startIndex
;
i
<
=
endIndex
;
+
+
i
)
{
if
(
i
>
=
mBlockIndex
.
Length
(
)
)
{
return
;
}
if
(
mBlockIndex
[
i
]
=
=
NO_BLOCK
)
{
continue
;
}
const
uint32_t
blockFirstBit
=
i
*
BLOCK_SIZE_BITS
;
Block
&
block
=
mBlocks
[
mBlockIndex
[
i
]
]
;
const
uint32_t
start
=
aStart
>
blockFirstBit
?
aStart
-
blockFirstBit
:
0
;
const
uint32_t
end
=
std
:
:
min
<
uint32_t
>
(
aEnd
-
blockFirstBit
BLOCK_SIZE_BITS
-
1
)
;
for
(
uint32_t
bit
=
start
;
bit
<
=
end
;
+
+
bit
)
{
block
.
mBits
[
bit
>
>
3
]
&
=
~
(
1
<
<
(
bit
&
0x7
)
)
;
}
}
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
mBlocks
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
+
mBlockIndex
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
void
reset
(
)
{
mBlocks
.
Clear
(
)
;
mBlockIndex
.
Clear
(
)
;
}
void
Union
(
const
gfxSparseBitSet
&
aBitset
)
{
uint32_t
blockCount
=
aBitset
.
mBlockIndex
.
Length
(
)
;
while
(
blockCount
>
mBlockIndex
.
Length
(
)
)
{
mBlockIndex
.
AppendElement
(
NO_BLOCK
)
;
}
for
(
uint32_t
i
=
0
;
i
<
blockCount
;
+
+
i
)
{
if
(
aBitset
.
mBlockIndex
[
i
]
=
=
NO_BLOCK
)
{
continue
;
}
if
(
mBlockIndex
[
i
]
=
=
NO_BLOCK
)
{
mBlocks
.
AppendElement
(
aBitset
.
mBlocks
[
aBitset
.
mBlockIndex
[
i
]
]
)
;
MOZ_ASSERT
(
mBlocks
.
Length
(
)
<
0xffff
"
block
index
overflow
!
"
)
;
mBlockIndex
[
i
]
=
static_cast
<
uint16_t
>
(
mBlocks
.
Length
(
)
-
1
)
;
continue
;
}
uint32_t
*
dst
=
reinterpret_cast
<
uint32_t
*
>
(
&
mBlocks
[
mBlockIndex
[
i
]
]
.
mBits
)
;
const
uint32_t
*
src
=
reinterpret_cast
<
const
uint32_t
*
>
(
&
aBitset
.
mBlocks
[
aBitset
.
mBlockIndex
[
i
]
]
.
mBits
)
;
for
(
uint32_t
j
=
0
;
j
<
BLOCK_SIZE
/
4
;
+
+
j
)
{
dst
[
j
]
|
=
src
[
j
]
;
}
}
}
inline
void
Union
(
const
SharedBitSet
&
aBitset
)
;
void
Compact
(
)
{
mBlocks
.
Compact
(
)
;
mBlockIndex
.
Compact
(
)
;
}
uint32_t
GetChecksum
(
)
const
{
uint32_t
check
=
adler32
(
0
reinterpret_cast
<
const
uint8_t
*
>
(
mBlockIndex
.
Elements
(
)
)
mBlockIndex
.
Length
(
)
*
sizeof
(
uint16_t
)
)
;
check
=
adler32
(
check
reinterpret_cast
<
const
uint8_t
*
>
(
mBlocks
.
Elements
(
)
)
mBlocks
.
Length
(
)
*
sizeof
(
Block
)
)
;
return
check
;
}
private
:
CopyableTArray
<
uint16_t
>
mBlockIndex
;
CopyableTArray
<
Block
>
mBlocks
;
}
;
class
SharedBitSet
{
private
:
typedef
gfxSparseBitSet
:
:
Block
Block
;
enum
{
BLOCK_SIZE
=
gfxSparseBitSet
:
:
BLOCK_SIZE
}
;
enum
{
BLOCK_SIZE_BITS
=
gfxSparseBitSet
:
:
BLOCK_SIZE_BITS
}
;
enum
{
NO_BLOCK
=
gfxSparseBitSet
:
:
NO_BLOCK
}
;
public
:
static
const
size_t
kMaxSize
=
147972
;
static
size_t
RequiredSize
(
const
gfxSparseBitSet
&
aBitset
)
{
size_t
total
=
sizeof
(
SharedBitSet
)
;
size_t
len
=
aBitset
.
mBlockIndex
.
Length
(
)
;
total
+
=
len
*
sizeof
(
uint16_t
)
;
for
(
uint16_t
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
aBitset
.
mBlockIndex
[
i
]
!
=
NO_BLOCK
)
{
total
+
=
sizeof
(
Block
)
;
}
}
MOZ_ASSERT
(
total
<
=
kMaxSize
)
;
return
total
;
}
static
SharedBitSet
*
Create
(
void
*
aBuffer
size_t
aBufSize
const
gfxSparseBitSet
&
aBitset
)
{
MOZ_ASSERT
(
aBufSize
>
=
RequiredSize
(
aBitset
)
)
;
return
new
(
aBuffer
)
SharedBitSet
(
aBitset
)
;
}
bool
test
(
uint32_t
aIndex
)
const
{
const
auto
i
=
static_cast
<
uint16_t
>
(
aIndex
/
BLOCK_SIZE_BITS
)
;
if
(
i
>
=
mBlockIndexCount
)
{
return
false
;
}
const
uint16_t
*
const
blockIndex
=
reinterpret_cast
<
const
uint16_t
*
>
(
this
+
1
)
;
if
(
blockIndex
[
i
]
=
=
NO_BLOCK
)
{
return
false
;
}
const
Block
*
const
blocks
=
reinterpret_cast
<
const
Block
*
>
(
blockIndex
+
mBlockIndexCount
)
;
const
Block
&
block
=
blocks
[
blockIndex
[
i
]
]
;
return
(
(
block
.
mBits
[
(
aIndex
>
>
3
)
&
(
BLOCK_SIZE
-
1
)
]
)
&
(
1
<
<
(
aIndex
&
0x7
)
)
)
!
=
0
;
}
bool
Equals
(
const
gfxSparseBitSet
*
aOther
)
const
{
if
(
mBlockIndexCount
!
=
aOther
-
>
mBlockIndex
.
Length
(
)
)
{
return
false
;
}
const
uint16_t
*
const
blockIndex
=
reinterpret_cast
<
const
uint16_t
*
>
(
this
+
1
)
;
const
Block
*
const
blocks
=
reinterpret_cast
<
const
Block
*
>
(
blockIndex
+
mBlockIndexCount
)
;
for
(
uint16_t
i
=
0
;
i
<
mBlockIndexCount
;
+
+
i
)
{
uint16_t
index
=
blockIndex
[
i
]
;
uint16_t
otherIndex
=
aOther
-
>
mBlockIndex
[
i
]
;
if
(
(
index
=
=
NO_BLOCK
)
!
=
(
otherIndex
=
=
NO_BLOCK
)
)
{
return
false
;
}
if
(
index
=
=
NO_BLOCK
)
{
continue
;
}
const
Block
&
b1
=
blocks
[
index
]
;
const
Block
&
b2
=
aOther
-
>
mBlocks
[
otherIndex
]
;
if
(
memcmp
(
&
b1
.
mBits
&
b2
.
mBits
BLOCK_SIZE
)
!
=
0
)
{
return
false
;
}
}
return
true
;
}
private
:
friend
class
gfxSparseBitSet
;
SharedBitSet
(
)
=
delete
;
explicit
SharedBitSet
(
const
gfxSparseBitSet
&
aBitset
)
:
mBlockIndexCount
(
mozilla
:
:
AssertedCast
<
uint16_t
>
(
aBitset
.
mBlockIndex
.
Length
(
)
)
)
mBlockCount
(
0
)
{
uint16_t
*
blockIndex
=
reinterpret_cast
<
uint16_t
*
>
(
this
+
1
)
;
Block
*
blocks
=
reinterpret_cast
<
Block
*
>
(
blockIndex
+
mBlockIndexCount
)
;
for
(
uint16_t
i
=
0
;
i
<
mBlockIndexCount
;
i
+
+
)
{
if
(
aBitset
.
mBlockIndex
[
i
]
!
=
NO_BLOCK
)
{
const
Block
&
srcBlock
=
aBitset
.
mBlocks
[
aBitset
.
mBlockIndex
[
i
]
]
;
std
:
:
memcpy
(
&
blocks
[
mBlockCount
]
&
srcBlock
sizeof
(
Block
)
)
;
blockIndex
[
i
]
=
mBlockCount
;
mBlockCount
+
+
;
}
else
{
blockIndex
[
i
]
=
NO_BLOCK
;
}
}
}
~
SharedBitSet
(
)
=
delete
;
uint16_t
mBlockIndexCount
;
uint16_t
mBlockCount
;
}
;
inline
void
gfxSparseBitSet
:
:
Union
(
const
SharedBitSet
&
aBitset
)
{
while
(
mBlockIndex
.
Length
(
)
<
aBitset
.
mBlockIndexCount
)
{
mBlockIndex
.
AppendElement
(
NO_BLOCK
)
;
}
auto
blockIndex
=
reinterpret_cast
<
const
uint16_t
*
>
(
&
aBitset
+
1
)
;
auto
blocks
=
reinterpret_cast
<
const
Block
*
>
(
blockIndex
+
aBitset
.
mBlockIndexCount
)
;
for
(
uint32_t
i
=
0
;
i
<
aBitset
.
mBlockIndexCount
;
+
+
i
)
{
if
(
blockIndex
[
i
]
=
=
NO_BLOCK
)
{
continue
;
}
if
(
mBlockIndex
[
i
]
=
=
NO_BLOCK
)
{
mBlocks
.
AppendElement
(
blocks
[
blockIndex
[
i
]
]
)
;
MOZ_ASSERT
(
mBlocks
.
Length
(
)
<
0xffff
"
block
index
overflow
"
)
;
mBlockIndex
[
i
]
=
uint16_t
(
mBlocks
.
Length
(
)
-
1
)
;
continue
;
}
uint8_t
*
dst
=
reinterpret_cast
<
uint8_t
*
>
(
&
mBlocks
[
mBlockIndex
[
i
]
]
.
mBits
)
;
const
uint8_t
*
src
=
reinterpret_cast
<
const
uint8_t
*
>
(
&
blocks
[
blockIndex
[
i
]
]
.
mBits
)
;
for
(
uint32_t
j
=
0
;
j
<
BLOCK_SIZE
;
+
+
j
)
{
dst
[
j
]
|
=
src
[
j
]
;
}
}
}
#
define
TRUETYPE_TAG
(
a
b
c
d
)
(
(
a
)
<
<
24
|
(
b
)
<
<
16
|
(
c
)
<
<
8
|
(
d
)
)
namespace
mozilla
{
#
pragma
pack
(
1
)
struct
AutoSwap_PRUint16
{
#
ifdef
__SUNPRO_CC
AutoSwap_PRUint16
&
operator
=
(
const
uint16_t
aValue
)
{
this
-
>
value
=
mozilla
:
:
NativeEndian
:
:
swapToBigEndian
(
aValue
)
;
return
*
this
;
}
#
else
MOZ_IMPLICIT
AutoSwap_PRUint16
(
uint16_t
aValue
)
{
value
=
mozilla
:
:
NativeEndian
:
:
swapToBigEndian
(
aValue
)
;
}
#
endif
operator
uint16_t
(
)
const
{
return
mozilla
:
:
NativeEndian
:
:
swapFromBigEndian
(
value
)
;
}
operator
uint32_t
(
)
const
{
return
mozilla
:
:
NativeEndian
:
:
swapFromBigEndian
(
value
)
;
}
operator
uint64_t
(
)
const
{
return
mozilla
:
:
NativeEndian
:
:
swapFromBigEndian
(
value
)
;
}
private
:
uint16_t
value
;
}
;
struct
AutoSwap_PRInt16
{
#
ifdef
__SUNPRO_CC
AutoSwap_PRInt16
&
operator
=
(
const
int16_t
aValue
)
{
this
-
>
value
=
mozilla
:
:
NativeEndian
:
:
swapToBigEndian
(
aValue
)
;
return
*
this
;
}
#
else
MOZ_IMPLICIT
AutoSwap_PRInt16
(
int16_t
aValue
)
{
value
=
mozilla
:
:
NativeEndian
:
:
swapToBigEndian
(
aValue
)
;
}
#
endif
operator
int16_t
(
)
const
{
return
mozilla
:
:
NativeEndian
:
:
swapFromBigEndian
(
value
)
;
}
operator
uint32_t
(
)
const
{
return
mozilla
:
:
NativeEndian
:
:
swapFromBigEndian
(
value
)
;
}
private
:
int16_t
value
;
}
;
struct
AutoSwap_PRUint32
{
#
ifdef
__SUNPRO_CC
AutoSwap_PRUint32
&
operator
=
(
const
uint32_t
aValue
)
{
this
-
>
value
=
mozilla
:
:
NativeEndian
:
:
swapToBigEndian
(
aValue
)
;
return
*
this
;
}
#
else
MOZ_IMPLICIT
AutoSwap_PRUint32
(
uint32_t
aValue
)
{
value
=
mozilla
:
:
NativeEndian
:
:
swapToBigEndian
(
aValue
)
;
}
#
endif
operator
uint32_t
(
)
const
{
return
mozilla
:
:
NativeEndian
:
:
swapFromBigEndian
(
value
)
;
}
private
:
uint32_t
value
;
}
;
struct
AutoSwap_PRInt32
{
#
ifdef
__SUNPRO_CC
AutoSwap_PRInt32
&
operator
=
(
const
int32_t
aValue
)
{
this
-
>
value
=
mozilla
:
:
NativeEndian
:
:
swapToBigEndian
(
aValue
)
;
return
*
this
;
}
#
else
MOZ_IMPLICIT
AutoSwap_PRInt32
(
int32_t
aValue
)
{
value
=
mozilla
:
:
NativeEndian
:
:
swapToBigEndian
(
aValue
)
;
}
#
endif
operator
int32_t
(
)
const
{
return
mozilla
:
:
NativeEndian
:
:
swapFromBigEndian
(
value
)
;
}
private
:
int32_t
value
;
}
;
struct
AutoSwap_PRUint64
{
#
ifdef
__SUNPRO_CC
AutoSwap_PRUint64
&
operator
=
(
const
uint64_t
aValue
)
{
this
-
>
value
=
mozilla
:
:
NativeEndian
:
:
swapToBigEndian
(
aValue
)
;
return
*
this
;
}
#
else
MOZ_IMPLICIT
AutoSwap_PRUint64
(
uint64_t
aValue
)
{
value
=
mozilla
:
:
NativeEndian
:
:
swapToBigEndian
(
aValue
)
;
}
#
endif
operator
uint64_t
(
)
const
{
return
mozilla
:
:
NativeEndian
:
:
swapFromBigEndian
(
value
)
;
}
private
:
uint64_t
value
;
}
;
struct
AutoSwap_PRUint24
{
operator
uint32_t
(
)
const
{
return
value
[
0
]
<
<
16
|
value
[
1
]
<
<
8
|
value
[
2
]
;
}
private
:
AutoSwap_PRUint24
(
)
=
default
;
uint8_t
value
[
3
]
;
}
;
struct
SFNTHeader
{
AutoSwap_PRUint32
sfntVersion
;
AutoSwap_PRUint16
numTables
;
AutoSwap_PRUint16
searchRange
;
AutoSwap_PRUint16
entrySelector
;
AutoSwap_PRUint16
rangeShift
;
}
;
struct
TTCHeader
{
AutoSwap_PRUint32
ttcTag
;
AutoSwap_PRUint16
majorVersion
;
AutoSwap_PRUint16
minorVersion
;
AutoSwap_PRUint32
numFonts
;
}
;
struct
TableDirEntry
{
AutoSwap_PRUint32
tag
;
AutoSwap_PRUint32
checkSum
;
AutoSwap_PRUint32
offset
;
AutoSwap_PRUint32
length
;
}
;
struct
HeadTable
{
enum
{
HEAD_VERSION
=
0x00010000
HEAD_MAGIC_NUMBER
=
0x5F0F3CF5
HEAD_CHECKSUM_CALC_CONST
=
0xB1B0AFBA
}
;
AutoSwap_PRUint32
tableVersionNumber
;
AutoSwap_PRUint32
fontRevision
;
AutoSwap_PRUint32
checkSumAdjustment
;
AutoSwap_PRUint32
magicNumber
;
AutoSwap_PRUint16
flags
;
AutoSwap_PRUint16
unitsPerEm
;
AutoSwap_PRUint64
created
;
AutoSwap_PRUint64
modified
;
AutoSwap_PRInt16
xMin
;
AutoSwap_PRInt16
yMin
;
AutoSwap_PRInt16
xMax
;
AutoSwap_PRInt16
yMax
;
AutoSwap_PRUint16
macStyle
;
AutoSwap_PRUint16
lowestRecPPEM
;
AutoSwap_PRInt16
fontDirectionHint
;
AutoSwap_PRInt16
indexToLocFormat
;
AutoSwap_PRInt16
glyphDataFormat
;
}
;
struct
OS2Table
{
AutoSwap_PRUint16
version
;
AutoSwap_PRInt16
xAvgCharWidth
;
AutoSwap_PRUint16
usWeightClass
;
AutoSwap_PRUint16
usWidthClass
;
AutoSwap_PRUint16
fsType
;
AutoSwap_PRInt16
ySubscriptXSize
;
AutoSwap_PRInt16
ySubscriptYSize
;
AutoSwap_PRInt16
ySubscriptXOffset
;
AutoSwap_PRInt16
ySubscriptYOffset
;
AutoSwap_PRInt16
ySuperscriptXSize
;
AutoSwap_PRInt16
ySuperscriptYSize
;
AutoSwap_PRInt16
ySuperscriptXOffset
;
AutoSwap_PRInt16
ySuperscriptYOffset
;
AutoSwap_PRInt16
yStrikeoutSize
;
AutoSwap_PRInt16
yStrikeoutPosition
;
AutoSwap_PRInt16
sFamilyClass
;
uint8_t
panose
[
10
]
;
AutoSwap_PRUint32
unicodeRange1
;
AutoSwap_PRUint32
unicodeRange2
;
AutoSwap_PRUint32
unicodeRange3
;
AutoSwap_PRUint32
unicodeRange4
;
uint8_t
achVendID
[
4
]
;
AutoSwap_PRUint16
fsSelection
;
AutoSwap_PRUint16
usFirstCharIndex
;
AutoSwap_PRUint16
usLastCharIndex
;
AutoSwap_PRInt16
sTypoAscender
;
AutoSwap_PRInt16
sTypoDescender
;
AutoSwap_PRInt16
sTypoLineGap
;
AutoSwap_PRUint16
usWinAscent
;
AutoSwap_PRUint16
usWinDescent
;
AutoSwap_PRUint32
codePageRange1
;
AutoSwap_PRUint32
codePageRange2
;
AutoSwap_PRInt16
sxHeight
;
AutoSwap_PRInt16
sCapHeight
;
AutoSwap_PRUint16
usDefaultChar
;
AutoSwap_PRUint16
usBreakChar
;
AutoSwap_PRUint16
usMaxContext
;
}
;
struct
PostTable
{
AutoSwap_PRUint32
version
;
AutoSwap_PRInt32
italicAngle
;
AutoSwap_PRInt16
underlinePosition
;
AutoSwap_PRUint16
underlineThickness
;
AutoSwap_PRUint32
isFixedPitch
;
AutoSwap_PRUint32
minMemType42
;
AutoSwap_PRUint32
maxMemType42
;
AutoSwap_PRUint32
minMemType1
;
AutoSwap_PRUint32
maxMemType1
;
}
;
struct
MetricsHeader
{
AutoSwap_PRUint32
version
;
AutoSwap_PRInt16
ascender
;
AutoSwap_PRInt16
descender
;
AutoSwap_PRInt16
lineGap
;
AutoSwap_PRUint16
advanceWidthMax
;
AutoSwap_PRInt16
minLeftSideBearing
;
AutoSwap_PRInt16
minRightSideBearing
;
AutoSwap_PRInt16
xMaxExtent
;
AutoSwap_PRInt16
caretSlopeRise
;
AutoSwap_PRInt16
caretSlopeRun
;
AutoSwap_PRInt16
caretOffset
;
AutoSwap_PRInt16
reserved1
;
AutoSwap_PRInt16
reserved2
;
AutoSwap_PRInt16
reserved3
;
AutoSwap_PRInt16
reserved4
;
AutoSwap_PRInt16
metricDataFormat
;
AutoSwap_PRUint16
numOfLongMetrics
;
}
;
struct
MaxpTableHeader
{
AutoSwap_PRUint32
version
;
AutoSwap_PRUint16
numGlyphs
;
}
;
struct
KernTableVersion0
{
AutoSwap_PRUint16
version
;
AutoSwap_PRUint16
nTables
;
}
;
struct
KernTableSubtableHeaderVersion0
{
AutoSwap_PRUint16
version
;
AutoSwap_PRUint16
length
;
AutoSwap_PRUint16
coverage
;
}
;
struct
KernTableVersion1
{
AutoSwap_PRUint32
version
;
AutoSwap_PRUint32
nTables
;
}
;
struct
KernTableSubtableHeaderVersion1
{
AutoSwap_PRUint32
length
;
AutoSwap_PRUint16
coverage
;
AutoSwap_PRUint16
tupleIndex
;
}
;
struct
COLRHeader
{
AutoSwap_PRUint16
version
;
AutoSwap_PRUint16
numBaseGlyphRecord
;
AutoSwap_PRUint32
offsetBaseGlyphRecord
;
AutoSwap_PRUint32
offsetLayerRecord
;
AutoSwap_PRUint16
numLayerRecords
;
}
;
struct
CPALHeaderVersion0
{
AutoSwap_PRUint16
version
;
AutoSwap_PRUint16
numPaletteEntries
;
AutoSwap_PRUint16
numPalettes
;
AutoSwap_PRUint16
numColorRecords
;
AutoSwap_PRUint32
offsetFirstColorRecord
;
}
;
#
pragma
pack
(
)
inline
uint32_t
FindHighestBit
(
uint32_t
value
)
{
value
|
=
(
value
>
>
1
)
;
value
|
=
(
value
>
>
2
)
;
value
|
=
(
value
>
>
4
)
;
value
|
=
(
value
>
>
8
)
;
value
|
=
(
value
>
>
16
)
;
return
(
value
&
~
(
value
>
>
1
)
)
;
}
}
struct
FontDataOverlay
{
uint32_t
overlaySrc
;
uint32_t
overlaySrcLen
;
uint32_t
overlayDest
;
}
;
enum
gfxUserFontType
{
GFX_USERFONT_UNKNOWN
=
0
GFX_USERFONT_OPENTYPE
=
1
GFX_USERFONT_SVG
=
2
GFX_USERFONT_WOFF
=
3
GFX_USERFONT_WOFF2
=
4
}
;
extern
const
uint8_t
sCJKCompatSVSTable
[
]
;
class
gfxFontUtils
{
public
:
enum
{
NAME_ID_FAMILY
=
1
NAME_ID_STYLE
=
2
NAME_ID_UNIQUE
=
3
NAME_ID_FULL
=
4
NAME_ID_VERSION
=
5
NAME_ID_POSTSCRIPT
=
6
NAME_ID_PREFERRED_FAMILY
=
16
NAME_ID_PREFERRED_STYLE
=
17
PLATFORM_ALL
=
-
1
PLATFORM_ID_UNICODE
=
0
PLATFORM_ID_MAC
=
1
PLATFORM_ID_ISO
=
2
PLATFORM_ID_MICROSOFT
=
3
ENCODING_ID_MAC_ROMAN
=
0
ENCODING_ID_MAC_JAPANESE
=
1
ENCODING_ID_MAC_TRAD_CHINESE
=
2
ENCODING_ID_MAC_KOREAN
=
3
ENCODING_ID_MAC_ARABIC
=
4
ENCODING_ID_MAC_HEBREW
=
5
ENCODING_ID_MAC_GREEK
=
6
ENCODING_ID_MAC_CYRILLIC
=
7
ENCODING_ID_MAC_DEVANAGARI
=
9
ENCODING_ID_MAC_GURMUKHI
=
10
ENCODING_ID_MAC_GUJARATI
=
11
ENCODING_ID_MAC_SIMP_CHINESE
=
25
ENCODING_ID_MICROSOFT_SYMBOL
=
0
ENCODING_ID_MICROSOFT_UNICODEBMP
=
1
ENCODING_ID_MICROSOFT_SHIFTJIS
=
2
ENCODING_ID_MICROSOFT_PRC
=
3
ENCODING_ID_MICROSOFT_BIG5
=
4
ENCODING_ID_MICROSOFT_WANSUNG
=
5
ENCODING_ID_MICROSOFT_JOHAB
=
6
ENCODING_ID_MICROSOFT_UNICODEFULL
=
10
LANG_ALL
=
-
1
LANG_ID_MAC_ENGLISH
=
0
LANG_ID_MAC_HEBREW
=
10
LANG_ID_MAC_JAPANESE
=
11
LANG_ID_MAC_ARABIC
=
12
LANG_ID_MAC_ICELANDIC
=
15
LANG_ID_MAC_TURKISH
=
17
LANG_ID_MAC_TRAD_CHINESE
=
19
LANG_ID_MAC_URDU
=
20
LANG_ID_MAC_KOREAN
=
23
LANG_ID_MAC_POLISH
=
25
LANG_ID_MAC_FARSI
=
31
LANG_ID_MAC_SIMP_CHINESE
=
33
LANG_ID_MAC_ROMANIAN
=
37
LANG_ID_MAC_CZECH
=
38
LANG_ID_MAC_SLOVAK
=
39
LANG_ID_MICROSOFT_EN_US
=
0x0409
CMAP_MAX_CODEPOINT
=
0x10ffff
}
;
struct
NameHeader
{
mozilla
:
:
AutoSwap_PRUint16
format
;
mozilla
:
:
AutoSwap_PRUint16
count
;
mozilla
:
:
AutoSwap_PRUint16
stringOffset
;
}
;
struct
NameRecord
{
mozilla
:
:
AutoSwap_PRUint16
platformID
;
mozilla
:
:
AutoSwap_PRUint16
encodingID
;
mozilla
:
:
AutoSwap_PRUint16
languageID
;
mozilla
:
:
AutoSwap_PRUint16
nameID
;
mozilla
:
:
AutoSwap_PRUint16
length
;
mozilla
:
:
AutoSwap_PRUint16
offset
;
}
;
static
inline
uint16_t
ReadShortAt
(
const
uint8_t
*
aBuf
uint32_t
aIndex
)
{
return
static_cast
<
uint16_t
>
(
aBuf
[
aIndex
]
<
<
8
)
|
aBuf
[
aIndex
+
1
]
;
}
static
inline
uint16_t
ReadShortAt16
(
const
uint16_t
*
aBuf
uint32_t
aIndex
)
{
const
uint8_t
*
buf
=
reinterpret_cast
<
const
uint8_t
*
>
(
aBuf
)
;
uint32_t
index
=
aIndex
<
<
1
;
return
static_cast
<
uint16_t
>
(
buf
[
index
]
<
<
8
)
|
buf
[
index
+
1
]
;
}
static
inline
uint32_t
ReadUint24At
(
const
uint8_t
*
aBuf
uint32_t
aIndex
)
{
return
(
(
aBuf
[
aIndex
]
<
<
16
)
|
(
aBuf
[
aIndex
+
1
]
<
<
8
)
|
(
aBuf
[
aIndex
+
2
]
)
)
;
}
static
inline
uint32_t
ReadLongAt
(
const
uint8_t
*
aBuf
uint32_t
aIndex
)
{
return
(
(
aBuf
[
aIndex
]
<
<
24
)
|
(
aBuf
[
aIndex
+
1
]
<
<
16
)
|
(
aBuf
[
aIndex
+
2
]
<
<
8
)
|
(
aBuf
[
aIndex
+
3
]
)
)
;
}
static
nsresult
ReadCMAPTableFormat10
(
const
uint8_t
*
aBuf
uint32_t
aLength
gfxSparseBitSet
&
aCharacterMap
)
;
static
nsresult
ReadCMAPTableFormat12or13
(
const
uint8_t
*
aBuf
uint32_t
aLength
gfxSparseBitSet
&
aCharacterMap
)
;
static
nsresult
ReadCMAPTableFormat4
(
const
uint8_t
*
aBuf
uint32_t
aLength
gfxSparseBitSet
&
aCharacterMap
bool
aIsSymbolFont
)
;
static
nsresult
ReadCMAPTableFormat14
(
const
uint8_t
*
aBuf
uint32_t
aLength
const
uint8_t
*
&
aTable
)
;
static
uint32_t
FindPreferredSubtable
(
const
uint8_t
*
aBuf
uint32_t
aBufLength
uint32_t
*
aTableOffset
uint32_t
*
aUVSTableOffset
bool
*
aIsSymbolFont
)
;
static
nsresult
ReadCMAP
(
const
uint8_t
*
aBuf
uint32_t
aBufLength
gfxSparseBitSet
&
aCharacterMap
uint32_t
&
aUVSOffset
)
;
static
uint32_t
MapCharToGlyphFormat4
(
const
uint8_t
*
aBuf
uint32_t
aLength
char16_t
aCh
)
;
static
uint32_t
MapCharToGlyphFormat10
(
const
uint8_t
*
aBuf
uint32_t
aCh
)
;
static
uint32_t
MapCharToGlyphFormat12or13
(
const
uint8_t
*
aBuf
uint32_t
aCh
)
;
static
uint16_t
MapUVSToGlyphFormat14
(
const
uint8_t
*
aBuf
uint32_t
aCh
uint32_t
aVS
)
;
static
MOZ_ALWAYS_INLINE
uint32_t
GetUVSFallback
(
uint32_t
aCh
uint32_t
aVS
)
{
aCh
=
MapUVSToGlyphFormat14
(
sCJKCompatSVSTable
aCh
aVS
)
;
return
aCh
>
=
0xFB00
?
aCh
+
(
0x2F800
-
0xFB00
)
:
aCh
;
}
static
uint32_t
MapCharToGlyph
(
const
uint8_t
*
aCmapBuf
uint32_t
aBufLength
uint32_t
aUnicode
uint32_t
aVarSelector
=
0
)
;
static
MOZ_ALWAYS_INLINE
uint32_t
MapLegacySymbolFontCharToPUA
(
uint32_t
aCh
)
{
return
aCh
>
=
0x20
&
&
aCh
<
=
0xff
?
0xf000
+
aCh
:
0
;
}
#
ifdef
XP_WIN
static
bool
IsCffFont
(
const
uint8_t
*
aFontData
)
;
#
endif
static
gfxUserFontType
DetermineFontDataType
(
const
uint8_t
*
aFontData
uint32_t
aFontDataLength
)
;
static
nsresult
GetFullNameFromSFNT
(
const
uint8_t
*
aFontData
uint32_t
aLength
nsACString
&
aFullName
)
;
static
nsresult
GetFullNameFromTable
(
hb_blob_t
*
aNameTable
nsACString
&
aFullName
)
;
static
nsresult
GetFamilyNameFromTable
(
hb_blob_t
*
aNameTable
nsACString
&
aFamilyName
)
;
static
mozilla
:
:
TableDirEntry
*
FindTableDirEntry
(
const
void
*
aFontData
uint32_t
aTableTag
)
;
static
hb_blob_t
*
GetTableFromFontData
(
const
void
*
aFontData
uint32_t
aTableTag
)
;
static
nsresult
RenameFont
(
const
nsAString
&
aName
const
uint8_t
*
aFontData
uint32_t
aFontDataLength
FallibleTArray
<
uint8_t
>
*
aNewFont
)
;
static
nsresult
ReadNames
(
const
char
*
aNameData
uint32_t
aDataLen
uint32_t
aNameID
int32_t
aPlatformID
nsTArray
<
nsCString
>
&
aNames
)
;
static
nsresult
ReadCanonicalName
(
hb_blob_t
*
aNameTable
uint32_t
aNameID
nsCString
&
aName
)
;
static
nsresult
ReadCanonicalName
(
const
char
*
aNameData
uint32_t
aDataLen
uint32_t
aNameID
nsCString
&
aName
)
;
static
bool
DecodeFontName
(
const
char
*
aBuf
int32_t
aLength
uint32_t
aPlatformCode
uint32_t
aScriptCode
uint32_t
aLangCode
nsACString
&
dest
)
;
static
inline
bool
IsJoinCauser
(
uint32_t
ch
)
{
return
(
ch
=
=
0x200D
)
;
}
static
inline
bool
IsJoinControl
(
uint32_t
ch
)
{
return
(
ch
=
=
0x200C
|
|
ch
=
=
0x200D
|
|
ch
=
=
0x034f
)
;
}
enum
{
kUnicodeVS1
=
0xFE00
kUnicodeVS16
=
0xFE0F
kUnicodeVS17
=
0xE0100
kUnicodeVS256
=
0xE01EF
}
;
static
inline
bool
IsVarSelector
(
uint32_t
ch
)
{
return
(
ch
>
=
kUnicodeVS1
&
&
ch
<
=
kUnicodeVS16
)
|
|
(
ch
>
=
kUnicodeVS17
&
&
ch
<
=
kUnicodeVS256
)
;
}
enum
{
kUnicodeRegionalIndicatorA
=
0x1F1E6
kUnicodeRegionalIndicatorZ
=
0x1F1FF
}
;
static
inline
bool
IsRegionalIndicator
(
uint32_t
aCh
)
{
return
aCh
>
=
kUnicodeRegionalIndicatorA
&
&
aCh
<
=
kUnicodeRegionalIndicatorZ
;
}
static
inline
bool
IsInvalid
(
uint32_t
ch
)
{
return
(
ch
=
=
0xFFFD
)
;
}
enum
{
kUnicodeBidiScriptsStart
=
0x0590
kUnicodeBidiScriptsEnd
=
0x08FF
kUnicodeBidiPresentationStart
=
0xFB1D
kUnicodeBidiPresentationEnd
=
0xFEFC
kUnicodeFirstHighSurrogateBlock
=
0xD800
kUnicodeRLM
=
0x200F
kUnicodeRLE
=
0x202B
kUnicodeRLO
=
0x202E
}
;
static
inline
bool
PotentialRTLChar
(
char16_t
aCh
)
{
if
(
aCh
>
=
kUnicodeBidiScriptsStart
&
&
aCh
<
=
kUnicodeBidiScriptsEnd
)
return
true
;
if
(
aCh
=
=
kUnicodeRLM
|
|
aCh
=
=
kUnicodeRLE
|
|
aCh
=
=
kUnicodeRLO
)
return
true
;
if
(
aCh
>
=
kUnicodeBidiPresentationStart
&
&
aCh
<
=
kUnicodeBidiPresentationEnd
)
return
true
;
if
(
(
aCh
&
0xFF00
)
=
=
kUnicodeFirstHighSurrogateBlock
)
return
true
;
return
false
;
}
static
void
ParseFontList
(
const
nsACString
&
aFamilyList
nsTArray
<
nsCString
>
&
aFontList
)
;
static
void
GetPrefsFontList
(
const
char
*
aPrefName
nsTArray
<
nsCString
>
&
aFontList
bool
aLocalized
=
false
)
;
static
nsresult
MakeUniqueUserFontName
(
nsAString
&
aName
)
;
static
bool
ValidateColorGlyphs
(
hb_blob_t
*
aCOLR
hb_blob_t
*
aCPAL
)
;
static
bool
GetColorGlyphLayers
(
hb_blob_t
*
aCOLR
hb_blob_t
*
aCPAL
uint32_t
aGlyphId
const
mozilla
:
:
gfx
:
:
DeviceColor
&
aDefaultColor
nsTArray
<
uint16_t
>
&
aGlyphs
nsTArray
<
mozilla
:
:
gfx
:
:
DeviceColor
>
&
aColors
)
;
static
bool
HasColorLayersForGlyph
(
hb_blob_t
*
aCOLR
uint32_t
aGlyphId
)
;
static
void
GetVariationData
(
gfxFontEntry
*
aFontEntry
nsTArray
<
gfxFontVariationAxis
>
*
aAxes
nsTArray
<
gfxFontVariationInstance
>
*
aInstances
)
;
static
void
ReadOtherFamilyNamesForFace
(
const
nsACString
&
aFamilyName
const
char
*
aNameData
uint32_t
aDataLength
nsTArray
<
nsCString
>
&
aOtherFamilyNames
bool
useFullName
)
;
static
bool
IsInServoTraversal
(
)
;
static
mozilla
:
:
ServoStyleSet
*
CurrentServoStyleSet
(
)
;
static
void
AssertSafeThreadOrServoFontMetricsLocked
(
)
#
ifdef
DEBUG
;
#
else
{
}
#
endif
protected
:
friend
struct
MacCharsetMappingComparator
;
static
nsresult
ReadNames
(
const
char
*
aNameData
uint32_t
aDataLen
uint32_t
aNameID
int32_t
aLangID
int32_t
aPlatformID
nsTArray
<
nsCString
>
&
aNames
)
;
static
const
mozilla
:
:
Encoding
*
GetCharsetForFontName
(
uint16_t
aPlatform
uint16_t
aScript
uint16_t
aLanguage
)
;
struct
MacFontNameCharsetMapping
{
uint16_t
mScript
;
uint16_t
mLanguage
;
const
mozilla
:
:
Encoding
*
mEncoding
;
bool
operator
<
(
const
MacFontNameCharsetMapping
&
rhs
)
const
{
return
(
mScript
<
rhs
.
mScript
)
|
|
(
(
mScript
=
=
rhs
.
mScript
)
&
&
(
mLanguage
<
rhs
.
mLanguage
)
)
;
}
}
;
static
const
MacFontNameCharsetMapping
gMacFontNameCharsets
[
]
;
static
const
mozilla
:
:
Encoding
*
gISOFontNameCharsets
[
]
;
static
const
mozilla
:
:
Encoding
*
gMSFontNameCharsets
[
]
;
}
;
constexpr
double
kPresentationMismatch
=
1
.
0e12
;
constexpr
double
kStretchFactor
=
1
.
0e8
;
constexpr
double
kStyleFactor
=
1
.
0e4
;
constexpr
double
kWeightFactor
=
1
.
0e0
;
static
inline
double
StyleDistance
(
const
mozilla
:
:
SlantStyleRange
&
aRange
mozilla
:
:
FontSlantStyle
aTargetStyle
)
{
const
mozilla
:
:
FontSlantStyle
minStyle
=
aRange
.
Min
(
)
;
if
(
aTargetStyle
=
=
minStyle
)
{
return
0
.
0
;
}
const
double
kReverse
=
100
.
0
;
const
double
kNegate
=
200
.
0
;
if
(
aTargetStyle
.
IsNormal
(
)
)
{
if
(
minStyle
.
IsOblique
(
)
)
{
const
double
minAngle
=
minStyle
.
ObliqueAngle
(
)
;
if
(
minAngle
>
=
0
.
0
)
{
return
1
.
0
+
minAngle
;
}
const
mozilla
:
:
FontSlantStyle
maxStyle
=
aRange
.
Max
(
)
;
const
double
maxAngle
=
maxStyle
.
ObliqueAngle
(
)
;
if
(
maxAngle
>
=
0
.
0
)
{
return
1
.
0
;
}
return
kNegate
-
maxAngle
;
}
MOZ_ASSERT
(
minStyle
.
IsItalic
(
)
)
;
return
kReverse
;
}
const
double
kDefaultAngle
=
mozilla
:
:
FontSlantStyle
:
:
OBLIQUE
.
ObliqueAngle
(
)
;
if
(
aTargetStyle
.
IsItalic
(
)
)
{
if
(
minStyle
.
IsOblique
(
)
)
{
const
double
minAngle
=
minStyle
.
ObliqueAngle
(
)
;
if
(
minAngle
>
=
kDefaultAngle
)
{
return
1
.
0
+
(
minAngle
-
kDefaultAngle
)
;
}
const
mozilla
:
:
FontSlantStyle
maxStyle
=
aRange
.
Max
(
)
;
const
double
maxAngle
=
maxStyle
.
ObliqueAngle
(
)
;
if
(
maxAngle
>
=
kDefaultAngle
)
{
return
1
.
0
;
}
if
(
maxAngle
>
0
.
0
)
{
return
kReverse
+
(
kDefaultAngle
-
maxAngle
)
;
}
return
kReverse
+
kNegate
+
(
kDefaultAngle
-
maxAngle
)
;
}
MOZ_ASSERT
(
minStyle
.
IsNormal
(
)
)
;
return
kNegate
;
}
const
double
targetAngle
=
aTargetStyle
.
ObliqueAngle
(
)
;
if
(
targetAngle
>
=
kDefaultAngle
)
{
if
(
minStyle
.
IsOblique
(
)
)
{
const
double
minAngle
=
minStyle
.
ObliqueAngle
(
)
;
if
(
minAngle
>
=
targetAngle
)
{
return
minAngle
-
targetAngle
;
}
const
mozilla
:
:
FontSlantStyle
maxStyle
=
aRange
.
Max
(
)
;
const
double
maxAngle
=
maxStyle
.
ObliqueAngle
(
)
;
if
(
maxAngle
>
=
targetAngle
)
{
return
0
.
0
;
}
if
(
maxAngle
>
0
.
0
)
{
return
kReverse
+
(
targetAngle
-
maxAngle
)
;
}
return
kReverse
+
kNegate
+
(
targetAngle
-
maxAngle
)
;
}
if
(
minStyle
.
IsItalic
(
)
)
{
return
kReverse
+
kNegate
;
}
return
kReverse
+
kNegate
+
1
.
0
;
}
if
(
targetAngle
<
=
-
kDefaultAngle
)
{
if
(
minStyle
.
IsOblique
(
)
)
{
const
mozilla
:
:
FontSlantStyle
maxStyle
=
aRange
.
Max
(
)
;
const
double
maxAngle
=
maxStyle
.
ObliqueAngle
(
)
;
if
(
maxAngle
<
=
targetAngle
)
{
return
targetAngle
-
maxAngle
;
}
const
double
minAngle
=
minStyle
.
ObliqueAngle
(
)
;
if
(
minAngle
<
=
targetAngle
)
{
return
0
.
0
;
}
if
(
minAngle
<
0
.
0
)
{
return
kReverse
+
(
minAngle
-
targetAngle
)
;
}
return
kReverse
+
kNegate
+
(
minAngle
-
targetAngle
)
;
}
if
(
minStyle
.
IsItalic
(
)
)
{
return
kReverse
+
kNegate
;
}
return
kReverse
+
kNegate
+
1
.
0
;
}
if
(
targetAngle
>
=
0
.
0
)
{
if
(
minStyle
.
IsOblique
(
)
)
{
const
double
minAngle
=
minStyle
.
ObliqueAngle
(
)
;
if
(
minAngle
>
targetAngle
)
{
return
kReverse
+
(
minAngle
-
targetAngle
)
;
}
const
mozilla
:
:
FontSlantStyle
maxStyle
=
aRange
.
Max
(
)
;
const
double
maxAngle
=
maxStyle
.
ObliqueAngle
(
)
;
if
(
maxAngle
>
=
targetAngle
)
{
return
0
.
0
;
}
if
(
maxAngle
>
0
.
0
)
{
return
targetAngle
-
maxAngle
;
}
return
kReverse
+
kNegate
+
(
targetAngle
-
maxAngle
)
;
}
if
(
minStyle
.
IsItalic
(
)
)
{
return
kReverse
+
kNegate
-
2
.
0
;
}
return
kReverse
+
kNegate
-
1
.
0
;
}
if
(
minStyle
.
IsOblique
(
)
)
{
const
mozilla
:
:
FontSlantStyle
maxStyle
=
aRange
.
Max
(
)
;
const
double
maxAngle
=
maxStyle
.
ObliqueAngle
(
)
;
if
(
maxAngle
<
targetAngle
)
{
return
kReverse
+
(
targetAngle
-
maxAngle
)
;
}
const
double
minAngle
=
minStyle
.
ObliqueAngle
(
)
;
if
(
minAngle
<
=
targetAngle
)
{
return
0
.
0
;
}
if
(
minAngle
<
0
.
0
)
{
return
minAngle
-
targetAngle
;
}
return
kReverse
+
kNegate
+
(
minAngle
-
targetAngle
)
;
}
if
(
minStyle
.
IsItalic
(
)
)
{
return
kReverse
+
kNegate
-
2
.
0
;
}
return
kReverse
+
kNegate
-
1
.
0
;
}
static
inline
double
StretchDistance
(
const
mozilla
:
:
StretchRange
&
aRange
mozilla
:
:
FontStretch
aTargetStretch
)
{
const
double
kReverseDistance
=
1000
.
0
;
mozilla
:
:
FontStretch
minStretch
=
aRange
.
Min
(
)
;
mozilla
:
:
FontStretch
maxStretch
=
aRange
.
Max
(
)
;
if
(
aTargetStretch
<
minStretch
)
{
if
(
aTargetStretch
>
mozilla
:
:
FontStretch
:
:
NORMAL
)
{
return
minStretch
.
ToFloat
(
)
-
aTargetStretch
.
ToFloat
(
)
;
}
return
(
minStretch
.
ToFloat
(
)
-
aTargetStretch
.
ToFloat
(
)
)
+
kReverseDistance
;
}
if
(
aTargetStretch
>
maxStretch
)
{
if
(
aTargetStretch
<
=
mozilla
:
:
FontStretch
:
:
NORMAL
)
{
return
aTargetStretch
.
ToFloat
(
)
-
maxStretch
.
ToFloat
(
)
;
}
return
(
aTargetStretch
.
ToFloat
(
)
-
maxStretch
.
ToFloat
(
)
)
+
kReverseDistance
;
}
return
0
.
0
;
}
static
inline
double
WeightDistance
(
const
mozilla
:
:
WeightRange
&
aRange
mozilla
:
:
FontWeight
aTargetWeight
)
{
const
double
kNotWithinCentralRange
=
100
.
0
;
const
double
kReverseDistance
=
600
.
0
;
mozilla
:
:
FontWeight
minWeight
=
aRange
.
Min
(
)
;
mozilla
:
:
FontWeight
maxWeight
=
aRange
.
Max
(
)
;
if
(
aTargetWeight
>
=
minWeight
&
&
aTargetWeight
<
=
maxWeight
)
{
return
0
.
0
;
}
if
(
aTargetWeight
<
mozilla
:
:
FontWeight
:
:
NORMAL
)
{
if
(
maxWeight
<
aTargetWeight
)
{
return
aTargetWeight
.
ToFloat
(
)
-
maxWeight
.
ToFloat
(
)
;
}
return
(
minWeight
.
ToFloat
(
)
-
aTargetWeight
.
ToFloat
(
)
)
+
kReverseDistance
;
}
if
(
aTargetWeight
>
mozilla
:
:
FontWeight
:
:
FromInt
(
500
)
)
{
if
(
minWeight
>
aTargetWeight
)
{
return
minWeight
.
ToFloat
(
)
-
aTargetWeight
.
ToFloat
(
)
;
}
return
(
aTargetWeight
.
ToFloat
(
)
-
maxWeight
.
ToFloat
(
)
)
+
kReverseDistance
;
}
if
(
minWeight
>
aTargetWeight
)
{
if
(
minWeight
<
=
mozilla
:
:
FontWeight
:
:
FromInt
(
500
)
)
{
return
minWeight
.
ToFloat
(
)
-
aTargetWeight
.
ToFloat
(
)
;
}
return
(
minWeight
.
ToFloat
(
)
-
aTargetWeight
.
ToFloat
(
)
)
+
kReverseDistance
;
}
return
(
aTargetWeight
.
ToFloat
(
)
-
maxWeight
.
ToFloat
(
)
)
+
kNotWithinCentralRange
;
}
#
endif
