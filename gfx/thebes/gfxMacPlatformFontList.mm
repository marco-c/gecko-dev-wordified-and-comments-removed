#
include
"
mozilla
/
Logging
.
h
"
#
include
<
algorithm
>
#
import
<
AppKit
/
AppKit
.
h
>
#
include
"
gfxFontConstants
.
h
"
#
include
"
gfxPlatformMac
.
h
"
#
include
"
gfxMacPlatformFontList
.
h
"
#
include
"
gfxMacFont
.
h
"
#
include
"
gfxUserFontSet
.
h
"
#
include
"
SharedFontList
-
impl
.
h
"
#
include
"
harfbuzz
/
hb
.
h
"
#
include
"
AppleUtils
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsIDirectoryEnumerator
.
h
"
#
include
"
nsCharTraits
.
h
"
#
include
"
nsCocoaFeatures
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
FontPropertyTypes
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
<
unistd
.
h
>
#
include
<
time
.
h
>
#
include
<
dlfcn
.
h
>
#
include
"
StandardFonts
-
macos
.
inc
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
#
define
USE_DEPRECATED_FONT_FAMILY_NAMES
1
#
if
USE_DEPRECATED_FONT_FAMILY_NAMES
constexpr
nsLiteralCString
kDeprecatedFontFamilies
[
]
=
{
"
Hiragino
Kaku
Gothic
Pro
"
_ns
"
Hiragino
Kaku
Gothic
ProN
"
_ns
"
Hiragino
Kaku
Gothic
Std
"
_ns
"
Hiragino
Kaku
Gothic
StdN
"
_ns
"
Hiragino
Maru
Gothic
Pro
"
_ns
"
Hiragino
Mincho
Pro
"
_ns
"
Iowan
Old
Style
"
_ns
"
Noto
Sans
Adlam
"
_ns
"
Noto
Sans
Armenian
"
_ns
"
Noto
Sans
Avestan
"
_ns
"
Noto
Sans
Bamum
"
_ns
"
Noto
Sans
Bassa
Vah
"
_ns
"
Noto
Sans
Batak
"
_ns
"
Noto
Sans
Bhaiksuki
"
_ns
"
Noto
Sans
Brahmi
"
_ns
"
Noto
Sans
Buginese
"
_ns
"
Noto
Sans
Buhid
"
_ns
"
Noto
Sans
Carian
"
_ns
"
Noto
Sans
Caucasian
Albanian
"
_ns
"
Noto
Sans
Chakma
"
_ns
"
Noto
Sans
Cham
"
_ns
"
Noto
Sans
Coptic
"
_ns
"
Noto
Sans
Cuneiform
"
_ns
"
Noto
Sans
Cypriot
"
_ns
"
Noto
Sans
Duployan
"
_ns
"
Noto
Sans
Egyptian
Hieroglyphs
"
_ns
"
Noto
Sans
Elbasan
"
_ns
"
Noto
Sans
Glagolitic
"
_ns
"
Noto
Sans
Gothic
"
_ns
"
Noto
Sans
Gunjala
Gondi
"
_ns
"
Noto
Sans
Hanifi
Rohingya
"
_ns
"
Noto
Sans
Hanunoo
"
_ns
"
Noto
Sans
Hatran
"
_ns
"
Noto
Sans
Imperial
Aramaic
"
_ns
"
Noto
Sans
Inscriptional
Pahlavi
"
_ns
"
Noto
Sans
Inscriptional
Parthian
"
_ns
"
Noto
Sans
Javanese
"
_ns
"
Noto
Sans
Kaithi
"
_ns
"
Noto
Sans
Kayah
Li
"
_ns
"
Noto
Sans
Kharoshthi
"
_ns
"
Noto
Sans
Khojki
"
_ns
"
Noto
Sans
Khudawadi
"
_ns
"
Noto
Sans
Lepcha
"
_ns
"
Noto
Sans
Limbu
"
_ns
"
Noto
Sans
Linear
A
"
_ns
"
Noto
Sans
Linear
B
"
_ns
"
Noto
Sans
Lisu
"
_ns
"
Noto
Sans
Lycian
"
_ns
"
Noto
Sans
Lydian
"
_ns
"
Noto
Sans
Mahajani
"
_ns
"
Noto
Sans
Mandaic
"
_ns
"
Noto
Sans
Manichaean
"
_ns
"
Noto
Sans
Marchen
"
_ns
"
Noto
Sans
Masaram
Gondi
"
_ns
"
Noto
Sans
Meetei
Mayek
"
_ns
"
Noto
Sans
Mende
Kikakui
"
_ns
"
Noto
Sans
Meroitic
"
_ns
"
Noto
Sans
Miao
"
_ns
"
Noto
Sans
Modi
"
_ns
"
Noto
Sans
Mongolian
"
_ns
"
Noto
Sans
Mro
"
_ns
"
Noto
Sans
Multani
"
_ns
"
Noto
Sans
Nabataean
"
_ns
"
Noto
Sans
New
Tai
Lue
"
_ns
"
Noto
Sans
Newa
"
_ns
"
Noto
Sans
NKo
"
_ns
"
Noto
Sans
Ol
Chiki
"
_ns
"
Noto
Sans
Old
Hungarian
"
_ns
"
Noto
Sans
Old
Italic
"
_ns
"
Noto
Sans
Old
North
Arabian
"
_ns
"
Noto
Sans
Old
Permic
"
_ns
"
Noto
Sans
Old
Persian
"
_ns
"
Noto
Sans
Old
South
Arabian
"
_ns
"
Noto
Sans
Old
Turkic
"
_ns
"
Noto
Sans
Osage
"
_ns
"
Noto
Sans
Osmanya
"
_ns
"
Noto
Sans
Pahawh
Hmong
"
_ns
"
Noto
Sans
Palmyrene
"
_ns
"
Noto
Sans
Pau
Cin
Hau
"
_ns
"
Noto
Sans
PhagsPa
"
_ns
"
Noto
Sans
Phoenician
"
_ns
"
Noto
Sans
Psalter
Pahlavi
"
_ns
"
Noto
Sans
Rejang
"
_ns
"
Noto
Sans
Samaritan
"
_ns
"
Noto
Sans
Saurashtra
"
_ns
"
Noto
Sans
Sharada
"
_ns
"
Noto
Sans
Siddham
"
_ns
"
Noto
Sans
Sora
Sompeng
"
_ns
"
Noto
Sans
Sundanese
"
_ns
"
Noto
Sans
Syloti
Nagri
"
_ns
"
Noto
Sans
Syriac
"
_ns
"
Noto
Sans
Tagalog
"
_ns
"
Noto
Sans
Tagbanwa
"
_ns
"
Noto
Sans
Tai
Le
"
_ns
"
Noto
Sans
Tai
Tham
"
_ns
"
Noto
Sans
Tai
Viet
"
_ns
"
Noto
Sans
Takri
"
_ns
"
Noto
Sans
Thaana
"
_ns
"
Noto
Sans
Tifinagh
"
_ns
"
Noto
Sans
Tirhuta
"
_ns
"
Noto
Sans
Ugaritic
"
_ns
"
Noto
Sans
Vai
"
_ns
"
Noto
Sans
Wancho
"
_ns
"
Noto
Sans
Warang
Citi
"
_ns
"
Noto
Sans
Yi
"
_ns
"
Noto
Sans
Zawgyi
"
_ns
"
Noto
Serif
Ahom
"
_ns
"
Noto
Serif
Balinese
"
_ns
"
Noto
Serif
Yezidi
"
_ns
"
Athelas
"
_ns
"
Courier
"
_ns
"
Marion
"
_ns
"
Seravek
"
_ns
"
Superclarendon
"
_ns
"
Times
"
_ns
}
;
#
endif
#
define
INDEX_FONT_POSTSCRIPT_NAME
0
#
define
INDEX_FONT_FACE_NAME
1
#
define
INDEX_FONT_WEIGHT
2
#
define
INDEX_FONT_TRAITS
3
static
const
int
kAppleMaxWeight
=
14
;
static
const
int
kAppleExtraLightWeight
=
3
;
static
const
int
kAppleUltraLightWeight
=
2
;
static
const
int
gAppleWeightToCSSWeight
[
]
=
{
0
1
1
2
3
4
5
6
6
7
8
8
9
9
9
}
;
static
NSFontManager
*
sFontManager
;
static
void
GetStringForNSString
(
const
NSString
*
aSrc
nsAString
&
aDest
)
{
aDest
.
SetLength
(
[
aSrc
length
]
)
;
[
aSrc
getCharacters
:
reinterpret_cast
<
unichar
*
>
(
aDest
.
BeginWriting
(
)
)
range
:
NSMakeRange
(
0
[
aSrc
length
]
)
]
;
}
static
NSString
*
GetNSStringForString
(
const
nsAString
&
aSrc
)
{
return
[
NSString
stringWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
aSrc
.
BeginReading
(
)
)
length
:
aSrc
.
Length
(
)
]
;
}
#
define
LOG_FONTLIST
(
args
)
\
MOZ_LOG
(
gfxPlatform
:
:
GetLog
(
eGfxLog_fontlist
)
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG_FONTLIST_ENABLED
(
)
\
MOZ_LOG_TEST
(
gfxPlatform
:
:
GetLog
(
eGfxLog_fontlist
)
mozilla
:
:
LogLevel
:
:
Debug
)
#
define
LOG_CMAPDATA_ENABLED
(
)
\
MOZ_LOG_TEST
(
gfxPlatform
:
:
GetLog
(
eGfxLog_cmapdata
)
mozilla
:
:
LogLevel
:
:
Debug
)
#
pragma
mark
-
nsresult
MacOSFontEntry
:
:
ReadCMAP
(
FontInfoData
*
aFontInfoData
)
{
if
(
mCharacterMap
|
|
mShmemCharacterMap
)
{
return
NS_OK
;
}
RefPtr
<
gfxCharacterMap
>
charmap
;
nsresult
rv
;
uint32_t
uvsOffset
=
0
;
if
(
aFontInfoData
&
&
(
charmap
=
GetCMAPFromFontInfo
(
aFontInfoData
uvsOffset
)
)
)
{
rv
=
NS_OK
;
}
else
{
uint32_t
kCMAP
=
TRUETYPE_TAG
(
'
c
'
'
m
'
'
a
'
'
p
'
)
;
charmap
=
new
gfxCharacterMap
(
)
;
AutoTable
cmapTable
(
this
kCMAP
)
;
if
(
cmapTable
)
{
uint32_t
cmapLen
;
const
uint8_t
*
cmapData
=
reinterpret_cast
<
const
uint8_t
*
>
(
hb_blob_get_data
(
cmapTable
&
cmapLen
)
)
;
rv
=
gfxFontUtils
:
:
ReadCMAP
(
cmapData
cmapLen
*
charmap
uvsOffset
)
;
}
else
{
rv
=
NS_ERROR_NOT_AVAILABLE
;
}
}
mUVSOffset
.
exchange
(
uvsOffset
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
mIsDataUserFont
&
&
!
HasGraphiteTables
(
)
)
{
bool
hasAATLayout
=
HasFontTable
(
TRUETYPE_TAG
(
'
m
'
'
o
'
'
r
'
'
x
'
)
)
|
|
HasFontTable
(
TRUETYPE_TAG
(
'
m
'
'
o
'
'
r
'
'
t
'
)
)
;
bool
hasAppleKerning
=
HasFontTable
(
TRUETYPE_TAG
(
'
k
'
'
e
'
'
r
'
'
x
'
)
)
;
bool
hasGSUB
=
HasFontTable
(
TRUETYPE_TAG
(
'
G
'
'
S
'
'
U
'
'
B
'
)
)
;
bool
hasGPOS
=
HasFontTable
(
TRUETYPE_TAG
(
'
G
'
'
P
'
'
O
'
'
S
'
)
)
;
if
(
(
hasAATLayout
&
&
!
(
hasGSUB
|
|
hasGPOS
)
)
|
|
hasAppleKerning
)
{
mRequiresAAT
=
true
;
}
for
(
const
ScriptRange
*
sr
=
gfxPlatformFontList
:
:
sComplexScriptRanges
;
sr
-
>
rangeStart
;
sr
+
+
)
{
if
(
charmap
-
>
TestRange
(
sr
-
>
rangeStart
sr
-
>
rangeEnd
)
)
{
if
(
hasAATLayout
)
{
mRequiresAAT
=
true
;
continue
;
}
if
(
hasGSUB
&
&
SupportsScriptInGSUB
(
sr
-
>
tags
sr
-
>
numTags
)
)
{
continue
;
}
charmap
-
>
ClearRange
(
sr
-
>
rangeStart
sr
-
>
rangeEnd
)
;
}
}
if
(
mRequiresAAT
&
&
(
FamilyName
(
)
.
EqualsLiteral
(
"
Songti
SC
"
)
|
|
FamilyName
(
)
.
EqualsLiteral
(
"
Songti
TC
"
)
|
|
FamilyName
(
)
.
EqualsLiteral
(
"
STSong
"
)
|
|
FamilyName
(
)
.
EqualsLiteral
(
"
Kaiti
SC
"
)
|
|
FamilyName
(
)
.
EqualsLiteral
(
"
Kaiti
TC
"
)
|
|
FamilyName
(
)
.
EqualsLiteral
(
"
STKaiti
"
)
)
)
{
charmap
-
>
ClearRange
(
0x0f6b
0x0f70
)
;
charmap
-
>
ClearRange
(
0x0f8c
0x0f8f
)
;
charmap
-
>
clear
(
0x0f98
)
;
charmap
-
>
clear
(
0x0fbd
)
;
charmap
-
>
ClearRange
(
0x0fcd
0x0fff
)
;
charmap
-
>
clear
(
0x0620
)
;
charmap
-
>
clear
(
0x065f
)
;
charmap
-
>
ClearRange
(
0x06ee
0x06ef
)
;
charmap
-
>
clear
(
0x06ff
)
;
}
}
bool
setCharMap
=
true
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
gfxPlatformFontList
*
pfl
=
gfxPlatformFontList
:
:
PlatformFontList
(
)
;
fontlist
:
:
FontList
*
sharedFontList
=
pfl
-
>
SharedFontList
(
)
;
if
(
!
IsUserFont
(
)
&
&
mShmemFace
)
{
mShmemFace
-
>
SetCharacterMap
(
sharedFontList
charmap
)
;
if
(
TrySetShmemCharacterMap
(
)
)
{
setCharMap
=
false
;
}
}
else
{
charmap
=
pfl
-
>
FindCharMap
(
charmap
)
;
}
mHasCmapTable
=
true
;
}
else
{
charmap
=
new
gfxCharacterMap
(
)
;
mHasCmapTable
=
false
;
}
if
(
setCharMap
)
{
if
(
mCharacterMap
.
compareExchange
(
nullptr
charmap
.
get
(
)
)
)
{
charmap
-
>
AddRef
(
)
;
}
}
LOG_FONTLIST
(
(
"
(
fontlist
-
cmap
)
name
:
%
s
size
:
%
zu
hash
:
%
8
.
8x
%
s
\
n
"
mName
.
get
(
)
charmap
-
>
SizeOfIncludingThis
(
moz_malloc_size_of
)
charmap
-
>
mHash
mCharacterMap
=
=
charmap
?
"
new
"
:
"
"
)
)
;
if
(
LOG_CMAPDATA_ENABLED
(
)
)
{
char
prefix
[
256
]
;
SprintfLiteral
(
prefix
"
(
cmapdata
)
name
:
%
.
220s
"
mName
.
get
(
)
)
;
charmap
-
>
Dump
(
prefix
eGfxLog_cmapdata
)
;
}
return
rv
;
}
gfxFont
*
MacOSFontEntry
:
:
CreateFontInstance
(
const
gfxFontStyle
*
aFontStyle
)
{
RefPtr
<
UnscaledFontMac
>
unscaledFont
(
mUnscaledFont
)
;
if
(
!
unscaledFont
)
{
CGFontRef
baseFont
=
GetFontRef
(
)
;
if
(
!
baseFont
)
{
return
nullptr
;
}
unscaledFont
=
new
UnscaledFontMac
(
baseFont
mIsDataUserFont
)
;
mUnscaledFont
=
unscaledFont
;
}
return
new
gfxMacFont
(
unscaledFont
this
aFontStyle
)
;
}
bool
MacOSFontEntry
:
:
HasVariations
(
)
{
if
(
!
mHasVariationsInitialized
)
{
mHasVariationsInitialized
=
true
;
mHasVariations
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
HasVariationFontSupport
(
)
&
&
HasFontTable
(
TRUETYPE_TAG
(
'
f
'
'
v
'
'
a
'
'
r
'
)
)
;
}
return
mHasVariations
;
}
void
MacOSFontEntry
:
:
GetVariationAxes
(
nsTArray
<
gfxFontVariationAxis
>
&
aVariationAxes
)
{
gfxFontUtils
:
:
GetVariationData
(
this
&
aVariationAxes
nullptr
)
;
}
void
MacOSFontEntry
:
:
GetVariationInstances
(
nsTArray
<
gfxFontVariationInstance
>
&
aInstances
)
{
gfxFontUtils
:
:
GetVariationData
(
this
nullptr
&
aInstances
)
;
}
bool
MacOSFontEntry
:
:
IsCFF
(
)
{
if
(
!
mIsCFFInitialized
)
{
mIsCFFInitialized
=
true
;
mIsCFF
=
HasFontTable
(
TRUETYPE_TAG
(
'
C
'
'
F
'
'
F
'
'
'
)
)
;
}
return
mIsCFF
;
}
MacOSFontEntry
:
:
MacOSFontEntry
(
const
nsACString
&
aPostscriptName
WeightRange
aWeight
bool
aIsStandardFace
double
aSizeHint
)
:
gfxFontEntry
(
aPostscriptName
aIsStandardFace
)
mFontRef
(
NULL
)
mSizeHint
(
aSizeHint
)
mFontRefInitialized
(
false
)
mRequiresAAT
(
false
)
mIsCFF
(
false
)
mIsCFFInitialized
(
false
)
mHasVariations
(
false
)
mHasVariationsInitialized
(
false
)
mHasAATSmallCaps
(
false
)
mHasAATSmallCapsInitialized
(
false
)
{
mWeightRange
=
aWeight
;
mOpszAxis
.
mTag
=
0
;
}
MacOSFontEntry
:
:
MacOSFontEntry
(
const
nsACString
&
aPostscriptName
CGFontRef
aFontRef
WeightRange
aWeight
StretchRange
aStretch
SlantStyleRange
aStyle
bool
aIsDataUserFont
bool
aIsLocalUserFont
)
:
gfxFontEntry
(
aPostscriptName
false
)
mFontRef
(
NULL
)
mSizeHint
(
0
.
0
)
mFontRefInitialized
(
false
)
mRequiresAAT
(
false
)
mIsCFF
(
false
)
mIsCFFInitialized
(
false
)
mHasVariations
(
false
)
mHasVariationsInitialized
(
false
)
mHasAATSmallCaps
(
false
)
mHasAATSmallCapsInitialized
(
false
)
{
mFontRef
=
aFontRef
;
mFontRefInitialized
=
true
;
:
:
CFRetain
(
mFontRef
)
;
mWeightRange
=
aWeight
;
mStretchRange
=
aStretch
;
mFixedPitch
=
false
;
mStyleRange
=
aStyle
;
mOpszAxis
.
mTag
=
0
;
NS_ASSERTION
(
!
(
aIsDataUserFont
&
&
aIsLocalUserFont
)
"
userfont
is
either
a
data
font
or
a
local
font
"
)
;
mIsDataUserFont
=
aIsDataUserFont
;
mIsLocalUserFont
=
aIsLocalUserFont
;
}
gfxFontEntry
*
MacOSFontEntry
:
:
Clone
(
)
const
{
MOZ_ASSERT
(
!
IsUserFont
(
)
"
we
can
only
clone
installed
fonts
!
"
)
;
MacOSFontEntry
*
fe
=
new
MacOSFontEntry
(
Name
(
)
Weight
(
)
mStandardFace
mSizeHint
)
;
fe
-
>
mStyleRange
=
mStyleRange
;
fe
-
>
mStretchRange
=
mStretchRange
;
fe
-
>
mFixedPitch
=
mFixedPitch
;
return
fe
;
}
CGFontRef
MacOSFontEntry
:
:
GetFontRef
(
)
{
if
(
!
mFontRefInitialized
)
{
mFontRef
=
CreateOrCopyFontRef
(
)
;
mFontRefInitialized
=
true
;
}
return
mFontRef
;
}
CGFontRef
MacOSFontEntry
:
:
CreateOrCopyFontRef
(
)
{
if
(
mFontRef
)
{
:
:
CGFontRetain
(
mFontRef
)
;
return
mFontRef
;
}
CrashReporter
:
:
AutoAnnotateCrashReport
autoFontName
(
CrashReporter
:
:
Annotation
:
:
FontName
mName
)
;
NSString
*
psname
=
GetNSStringForString
(
NS_ConvertUTF8toUTF16
(
mName
)
)
;
CGFontRef
ref
=
CGFontCreateWithFontName
(
CFStringRef
(
psname
)
)
;
if
(
!
ref
)
{
NSFont
*
font
=
[
NSFont
fontWithName
:
psname
size
:
mSizeHint
]
;
if
(
font
)
{
ref
=
CTFontCopyGraphicsFont
(
(
CTFontRef
)
font
nullptr
)
;
}
}
return
ref
;
}
class
FontTableRec
{
public
:
explicit
FontTableRec
(
CFDataRef
aDataRef
)
:
mDataRef
(
aDataRef
)
{
MOZ_COUNT_CTOR
(
FontTableRec
)
;
}
~
FontTableRec
(
)
{
MOZ_COUNT_DTOR
(
FontTableRec
)
;
:
:
CFRelease
(
mDataRef
)
;
}
private
:
CFDataRef
mDataRef
;
}
;
void
MacOSFontEntry
:
:
DestroyBlobFunc
(
void
*
aUserData
)
{
#
ifdef
NS_BUILD_REFCNT_LOGGING
FontTableRec
*
ftr
=
static_cast
<
FontTableRec
*
>
(
aUserData
)
;
delete
ftr
;
#
else
:
:
CFRelease
(
(
CFDataRef
)
aUserData
)
;
#
endif
}
hb_blob_t
*
MacOSFontEntry
:
:
GetFontTable
(
uint32_t
aTag
)
{
AutoCFRelease
<
CGFontRef
>
fontRef
=
CreateOrCopyFontRef
(
)
;
if
(
!
fontRef
)
{
return
nullptr
;
}
CFDataRef
dataRef
=
:
:
CGFontCopyTableForTag
(
fontRef
aTag
)
;
if
(
dataRef
)
{
return
hb_blob_create
(
(
const
char
*
)
:
:
CFDataGetBytePtr
(
dataRef
)
:
:
CFDataGetLength
(
dataRef
)
HB_MEMORY_MODE_READONLY
#
ifdef
NS_BUILD_REFCNT_LOGGING
new
FontTableRec
(
dataRef
)
#
else
(
void
*
)
dataRef
#
endif
DestroyBlobFunc
)
;
}
return
nullptr
;
}
bool
MacOSFontEntry
:
:
HasFontTable
(
uint32_t
aTableTag
)
{
if
(
mAvailableTables
.
Count
(
)
=
=
0
)
{
nsAutoreleasePool
localPool
;
AutoCFRelease
<
CGFontRef
>
fontRef
=
CreateOrCopyFontRef
(
)
;
if
(
!
fontRef
)
{
return
false
;
}
AutoCFRelease
<
CFArrayRef
>
tags
=
:
:
CGFontCopyTableTags
(
fontRef
)
;
if
(
!
tags
)
{
return
false
;
}
int
numTags
=
(
int
)
:
:
CFArrayGetCount
(
tags
)
;
for
(
int
t
=
0
;
t
<
numTags
;
t
+
+
)
{
uint32_t
tag
=
(
uint32_t
)
(
uintptr_t
)
:
:
CFArrayGetValueAtIndex
(
tags
t
)
;
mAvailableTables
.
PutEntry
(
tag
)
;
}
}
return
mAvailableTables
.
GetEntry
(
aTableTag
)
;
}
static
bool
CheckForAATSmallCaps
(
CFArrayRef
aFeatures
)
{
auto
numFeatures
=
CFArrayGetCount
(
aFeatures
)
;
for
(
auto
f
=
0
;
f
<
numFeatures
;
+
+
f
)
{
auto
featureDict
=
(
CFDictionaryRef
)
CFArrayGetValueAtIndex
(
aFeatures
f
)
;
if
(
!
featureDict
)
{
return
false
;
}
auto
featureNum
=
(
CFNumberRef
)
CFDictionaryGetValue
(
featureDict
CFSTR
(
"
CTFeatureTypeIdentifier
"
)
)
;
if
(
!
featureNum
)
{
return
false
;
}
int16_t
featureType
;
if
(
!
CFNumberGetValue
(
featureNum
kCFNumberSInt16Type
&
featureType
)
)
{
return
false
;
}
if
(
featureType
=
=
kLetterCaseType
|
|
featureType
=
=
kLowerCaseType
)
{
const
uint16_t
smallCaps
=
(
featureType
=
=
kLetterCaseType
)
?
kSmallCapsSelector
:
kLowerCaseSmallCapsSelector
;
auto
selectors
=
(
CFArrayRef
)
CFDictionaryGetValue
(
featureDict
CFSTR
(
"
CTFeatureTypeSelectors
"
)
)
;
if
(
!
selectors
)
{
return
false
;
}
auto
numSelectors
=
CFArrayGetCount
(
selectors
)
;
for
(
auto
s
=
0
;
s
<
numSelectors
;
s
+
+
)
{
auto
selectorDict
=
(
CFDictionaryRef
)
CFArrayGetValueAtIndex
(
selectors
s
)
;
if
(
!
selectorDict
)
{
return
false
;
}
auto
selectorNum
=
(
CFNumberRef
)
CFDictionaryGetValue
(
selectorDict
CFSTR
(
"
CTFeatureSelectorIdentifier
"
)
)
;
if
(
!
selectorNum
)
{
return
false
;
}
int16_t
selectorValue
;
if
(
!
CFNumberGetValue
(
selectorNum
kCFNumberSInt16Type
&
selectorValue
)
)
{
return
false
;
}
if
(
selectorValue
=
=
smallCaps
)
{
return
true
;
}
}
}
}
return
false
;
}
bool
MacOSFontEntry
:
:
SupportsOpenTypeFeature
(
Script
aScript
uint32_t
aFeatureTag
)
{
if
(
RequiresAATLayout
(
)
)
{
if
(
aFeatureTag
!
=
HB_TAG
(
'
s
'
'
m
'
'
c
'
'
p
'
)
)
{
return
false
;
}
if
(
mHasAATSmallCapsInitialized
)
{
return
mHasAATSmallCaps
;
}
mHasAATSmallCapsInitialized
=
true
;
CGFontRef
cgFont
=
GetFontRef
(
)
;
if
(
!
cgFont
)
{
return
mHasAATSmallCaps
;
}
AutoCFRelease
<
CTFontRef
>
ctFont
=
CTFontCreateWithGraphicsFont
(
cgFont
0
.
0
nullptr
nullptr
)
;
if
(
ctFont
)
{
AutoCFRelease
<
CFArrayRef
>
features
=
CTFontCopyFeatures
(
ctFont
)
;
if
(
features
)
{
mHasAATSmallCaps
=
CheckForAATSmallCaps
(
features
)
;
}
}
return
mHasAATSmallCaps
;
}
return
gfxFontEntry
:
:
SupportsOpenTypeFeature
(
aScript
aFeatureTag
)
;
}
void
MacOSFontEntry
:
:
AddSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
FontListSizes
*
aSizes
)
const
{
aSizes
-
>
mFontListSize
+
=
aMallocSizeOf
(
this
)
;
AddSizeOfExcludingThis
(
aMallocSizeOf
aSizes
)
;
}
#
pragma
mark
-
class
gfxMacFontFamily
final
:
public
gfxFontFamily
{
public
:
gfxMacFontFamily
(
const
nsACString
&
aName
FontVisibility
aVisibility
double
aSizeHint
=
0
.
0
)
:
gfxFontFamily
(
aName
aVisibility
)
mSizeHint
(
aSizeHint
)
{
}
virtual
~
gfxMacFontFamily
(
)
=
default
;
void
LocalizedName
(
nsACString
&
aLocalizedName
)
override
;
void
FindStyleVariationsLocked
(
FontInfoData
*
aFontInfoData
=
nullptr
)
REQUIRES
(
mLock
)
override
;
protected
:
double
mSizeHint
;
}
;
void
gfxMacFontFamily
:
:
LocalizedName
(
nsACString
&
aLocalizedName
)
{
nsAutoreleasePool
localPool
;
if
(
NS_IsMainThread
(
)
&
&
!
HasOtherFamilyNames
(
)
)
{
aLocalizedName
=
mName
;
return
;
}
NSString
*
family
=
GetNSStringForString
(
NS_ConvertUTF8toUTF16
(
mName
)
)
;
NSString
*
localized
=
[
sFontManager
localizedNameForFamily
:
family
face
:
nil
]
;
if
(
localized
)
{
nsAutoString
locName
;
GetStringForNSString
(
localized
locName
)
;
CopyUTF16toUTF8
(
locName
aLocalizedName
)
;
return
;
}
aLocalizedName
=
mName
;
}
static
inline
int
GetWeightOverride
(
const
nsAString
&
aPSName
)
{
nsAutoCString
prefName
(
"
font
.
weight
-
override
.
"
)
;
LossyAppendUTF16toASCII
(
aPSName
prefName
)
;
return
Preferences
:
:
GetInt
(
prefName
.
get
(
)
0
)
;
}
void
gfxMacFontFamily
:
:
FindStyleVariationsLocked
(
FontInfoData
*
aFontInfoData
)
{
if
(
mHasStyles
)
{
return
;
}
AUTO_PROFILER_LABEL_DYNAMIC_NSCSTRING
(
"
gfxMacFontFamily
:
:
FindStyleVariations
"
LAYOUT
mName
)
;
nsAutoreleasePool
localPool
;
NSString
*
family
=
GetNSStringForString
(
NS_ConvertUTF8toUTF16
(
mName
)
)
;
NSArray
*
fontfaces
=
[
sFontManager
availableMembersOfFontFamily
:
family
]
;
int
faceCount
=
[
fontfaces
count
]
;
int
faceIndex
;
for
(
faceIndex
=
0
;
faceIndex
<
faceCount
;
faceIndex
+
+
)
{
NSArray
*
face
=
[
fontfaces
objectAtIndex
:
faceIndex
]
;
NSString
*
psname
=
[
face
objectAtIndex
:
INDEX_FONT_POSTSCRIPT_NAME
]
;
int32_t
appKitWeight
=
[
[
face
objectAtIndex
:
INDEX_FONT_WEIGHT
]
unsignedIntValue
]
;
uint32_t
macTraits
=
[
[
face
objectAtIndex
:
INDEX_FONT_TRAITS
]
unsignedIntValue
]
;
NSString
*
facename
=
[
face
objectAtIndex
:
INDEX_FONT_FACE_NAME
]
;
bool
isStandardFace
=
false
;
if
(
appKitWeight
=
=
kAppleExtraLightWeight
)
{
NSRange
range
=
[
facename
rangeOfString
:
"
ultralight
"
options
:
NSCaseInsensitiveSearch
]
;
if
(
range
.
location
!
=
NSNotFound
)
{
appKitWeight
=
kAppleUltraLightWeight
;
}
}
nsAutoString
postscriptFontName
;
GetStringForNSString
(
psname
postscriptFontName
)
;
int32_t
cssWeight
=
gfxMacPlatformFontList
:
:
AppleWeightToCSSWeight
(
appKitWeight
)
;
if
(
!
gfxPlatformFontList
:
:
IsInitFontListThread
(
)
)
{
int32_t
weightOverride
=
GetWeightOverride
(
postscriptFontName
)
;
if
(
weightOverride
)
{
cssWeight
=
(
(
weightOverride
+
50
)
/
100
)
;
cssWeight
=
std
:
:
max
(
1
std
:
:
min
(
cssWeight
9
)
)
;
}
}
cssWeight
*
=
100
;
if
(
[
facename
isEqualToString
:
"
Regular
"
]
|
|
[
facename
isEqualToString
:
"
Bold
"
]
|
|
[
facename
isEqualToString
:
"
Italic
"
]
|
|
[
facename
isEqualToString
:
"
Oblique
"
]
|
|
[
facename
isEqualToString
:
"
Bold
Italic
"
]
|
|
[
facename
isEqualToString
:
"
Bold
Oblique
"
]
)
{
isStandardFace
=
true
;
}
MacOSFontEntry
*
fontEntry
=
new
MacOSFontEntry
(
NS_ConvertUTF16toUTF8
(
postscriptFontName
)
WeightRange
(
FontWeight
:
:
FromInt
(
cssWeight
)
)
isStandardFace
mSizeHint
)
;
if
(
!
fontEntry
)
{
break
;
}
if
(
macTraits
&
(
NSCondensedFontMask
|
NSNarrowFontMask
|
NSCompressedFontMask
)
)
{
fontEntry
-
>
mStretchRange
=
StretchRange
(
FontStretch
:
:
CONDENSED
)
;
}
else
if
(
macTraits
&
NSExpandedFontMask
)
{
fontEntry
-
>
mStretchRange
=
StretchRange
(
FontStretch
:
:
EXPANDED
)
;
}
if
(
(
macTraits
&
NSItalicFontMask
)
|
|
[
facename
hasSuffix
:
"
Italic
"
]
|
|
[
facename
hasSuffix
:
"
Oblique
"
]
)
{
fontEntry
-
>
mStyleRange
=
SlantStyleRange
(
FontSlantStyle
:
:
ITALIC
)
;
}
if
(
macTraits
&
NSFixedPitchFontMask
)
{
fontEntry
-
>
mFixedPitch
=
true
;
}
if
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
HasVariationFontSupport
(
)
)
{
fontEntry
-
>
SetupVariationRanges
(
)
;
}
if
(
LOG_FONTLIST_ENABLED
(
)
)
{
nsAutoCString
weightString
;
fontEntry
-
>
Weight
(
)
.
ToString
(
weightString
)
;
nsAutoCString
stretchString
;
fontEntry
-
>
Stretch
(
)
.
ToString
(
stretchString
)
;
LOG_FONTLIST
(
(
"
(
fontlist
)
added
(
%
s
)
to
family
(
%
s
)
"
"
with
style
:
%
s
weight
:
%
s
stretch
:
%
s
"
"
(
apple
-
weight
:
%
d
macTraits
:
%
8
.
8x
)
"
fontEntry
-
>
Name
(
)
.
get
(
)
Name
(
)
.
get
(
)
fontEntry
-
>
IsItalic
(
)
?
"
italic
"
:
"
normal
"
weightString
.
get
(
)
stretchString
.
get
(
)
appKitWeight
macTraits
)
)
;
}
AddFontEntryLocked
(
fontEntry
)
;
}
SortAvailableFonts
(
)
;
SetHasStyles
(
true
)
;
if
(
mIsBadUnderlineFamily
)
{
SetBadUnderlineFonts
(
)
;
}
CheckForSimpleFamily
(
)
;
}
#
pragma
mark
-
class
gfxSingleFaceMacFontFamily
final
:
public
gfxFontFamily
{
public
:
gfxSingleFaceMacFontFamily
(
const
nsACString
&
aName
FontVisibility
aVisibility
)
:
gfxFontFamily
(
aName
aVisibility
)
{
mFaceNamesInitialized
=
true
;
}
virtual
~
gfxSingleFaceMacFontFamily
(
)
=
default
;
void
FindStyleVariationsLocked
(
FontInfoData
*
aFontInfoData
=
nullptr
)
REQUIRES
(
mLock
)
override
{
}
;
void
LocalizedName
(
nsACString
&
aLocalizedName
)
override
;
void
ReadOtherFamilyNames
(
gfxPlatformFontList
*
aPlatformFontList
)
override
;
bool
IsSingleFaceFamily
(
)
const
override
{
return
true
;
}
}
;
void
gfxSingleFaceMacFontFamily
:
:
LocalizedName
(
nsACString
&
aLocalizedName
)
{
nsAutoreleasePool
localPool
;
AutoReadLock
lock
(
mLock
)
;
if
(
!
HasOtherFamilyNames
(
)
)
{
aLocalizedName
=
mName
;
return
;
}
gfxFontEntry
*
fe
=
mAvailableFonts
[
0
]
;
NSFont
*
font
=
[
NSFont
fontWithName
:
GetNSStringForString
(
NS_ConvertUTF8toUTF16
(
fe
-
>
Name
(
)
)
)
size
:
0
.
0
]
;
if
(
font
)
{
NSString
*
localized
=
[
font
displayName
]
;
if
(
localized
)
{
nsAutoString
locName
;
GetStringForNSString
(
localized
locName
)
;
CopyUTF16toUTF8
(
locName
aLocalizedName
)
;
return
;
}
}
aLocalizedName
=
mName
;
}
void
gfxSingleFaceMacFontFamily
:
:
ReadOtherFamilyNames
(
gfxPlatformFontList
*
aPlatformFontList
)
{
AutoWriteLock
lock
(
mLock
)
;
if
(
mOtherFamilyNamesInitialized
)
{
return
;
}
gfxFontEntry
*
fe
=
mAvailableFonts
[
0
]
;
if
(
!
fe
)
{
return
;
}
const
uint32_t
kNAME
=
TRUETYPE_TAG
(
'
n
'
'
a
'
'
m
'
'
e
'
)
;
gfxFontEntry
:
:
AutoTable
nameTable
(
fe
kNAME
)
;
if
(
!
nameTable
)
{
return
;
}
mHasOtherFamilyNames
=
ReadOtherFamilyNamesForFace
(
aPlatformFontList
nameTable
true
)
;
mOtherFamilyNamesInitialized
=
true
;
}
#
pragma
mark
-
gfxMacPlatformFontList
:
:
gfxMacPlatformFontList
(
)
:
gfxPlatformFontList
(
false
)
mDefaultFont
(
nullptr
)
mUseSizeSensitiveSystemFont
(
false
)
{
CheckFamilyList
(
kBaseFonts
)
;
sFontManager
=
[
NSFontManager
sharedFontManager
]
;
gfxFontUtils
:
:
GetPrefsFontList
(
"
font
.
single
-
face
-
list
"
mSingleFaceFonts
)
;
gfxFontUtils
:
:
GetPrefsFontList
(
"
font
.
preload
-
names
-
list
"
mPreloadFonts
)
;
}
gfxMacPlatformFontList
:
:
~
gfxMacPlatformFontList
(
)
{
AutoLock
lock
(
mLock
)
;
if
(
XRE_IsParentProcess
(
)
)
{
:
:
CFNotificationCenterRemoveObserver
(
:
:
CFNotificationCenterGetLocalCenter
(
)
this
kCTFontManagerRegisteredFontsChangedNotification
0
)
;
}
if
(
mDefaultFont
)
{
:
:
CFRelease
(
mDefaultFont
)
;
}
}
void
gfxMacPlatformFontList
:
:
AddFamily
(
const
nsACString
&
aFamilyName
FontVisibility
aVisibility
)
{
double
sizeHint
=
0
.
0
;
if
(
aVisibility
=
=
FontVisibility
:
:
Hidden
&
&
mUseSizeSensitiveSystemFont
&
&
mSystemDisplayFontFamilyName
.
Equals
(
aFamilyName
)
)
{
sizeHint
=
128
.
0
;
}
nsAutoCString
key
;
ToLowerCase
(
aFamilyName
key
)
;
RefPtr
<
gfxFontFamily
>
familyEntry
=
new
gfxMacFontFamily
(
aFamilyName
aVisibility
sizeHint
)
;
mFontFamilies
.
InsertOrUpdate
(
key
RefPtr
{
familyEntry
}
)
;
if
(
mBadUnderlineFamilyNames
.
ContainsSorted
(
key
)
)
{
familyEntry
-
>
SetBadUnderlineFamily
(
)
;
}
}
FontVisibility
gfxMacPlatformFontList
:
:
GetVisibilityForFamily
(
const
nsACString
&
aName
)
const
{
if
(
aName
[
0
]
=
=
'
.
'
|
|
aName
.
LowerCaseEqualsLiteral
(
"
lastresort
"
)
)
{
return
FontVisibility
:
:
Hidden
;
}
if
(
FamilyInList
(
aName
kBaseFonts
)
)
{
return
FontVisibility
:
:
Base
;
}
return
FontVisibility
:
:
User
;
}
void
gfxMacPlatformFontList
:
:
AddFamily
(
CFStringRef
aFamily
)
{
NSString
*
family
=
(
NSString
*
)
aFamily
;
if
(
!
family
|
|
[
family
caseInsensitiveCompare
:
"
LastResort
"
]
=
=
NSOrderedSame
|
|
[
family
caseInsensitiveCompare
:
"
.
LastResort
"
]
=
=
NSOrderedSame
)
{
return
;
}
nsAutoString
familyName
;
nsCocoaUtils
:
:
GetStringForNSString
(
family
familyName
)
;
NS_ConvertUTF16toUTF8
nameUtf8
(
familyName
)
;
AddFamily
(
nameUtf8
GetVisibilityForFamily
(
nameUtf8
)
)
;
}
void
gfxMacPlatformFontList
:
:
ReadSystemFontList
(
dom
:
:
SystemFontList
*
aList
)
NO_THREAD_SAFETY_ANALYSIS
{
aList
-
>
entries
(
)
.
AppendElement
(
FontFamilyListEntry
(
mSystemTextFontFamilyName
FontVisibility
:
:
Unknown
kTextSizeSystemFontFamily
)
)
;
if
(
mUseSizeSensitiveSystemFont
)
{
aList
-
>
entries
(
)
.
AppendElement
(
FontFamilyListEntry
(
mSystemDisplayFontFamilyName
FontVisibility
:
:
Unknown
kDisplaySizeSystemFontFamily
)
)
;
}
for
(
auto
f
=
mFontFamilies
.
Iter
(
)
;
!
f
.
Done
(
)
;
f
.
Next
(
)
)
{
auto
macFamily
=
f
.
Data
(
)
.
get
(
)
;
if
(
macFamily
-
>
IsSingleFaceFamily
(
)
)
{
continue
;
}
aList
-
>
entries
(
)
.
AppendElement
(
FontFamilyListEntry
(
macFamily
-
>
Name
(
)
macFamily
-
>
Visibility
(
)
kStandardFontFamily
)
)
;
}
}
void
gfxMacPlatformFontList
:
:
PreloadNamesList
(
)
{
uint32_t
numFonts
=
mPreloadFonts
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
numFonts
;
i
+
+
)
{
nsAutoCString
key
;
GenerateFontListKey
(
mPreloadFonts
[
i
]
key
)
;
gfxFontFamily
*
familyEntry
=
mFontFamilies
.
GetWeak
(
key
)
;
if
(
familyEntry
)
{
familyEntry
-
>
ReadOtherFamilyNames
(
this
)
;
}
}
}
#
if
USE_DEPRECATED_FONT_FAMILY_NAMES
static
bool
DeprecatedFamilyIsAvailable
(
const
nsACString
&
aName
)
{
NSString
*
family
=
GetNSStringForString
(
NS_ConvertUTF8toUTF16
(
aName
)
)
;
return
[
[
sFontManager
availableMembersOfFontFamily
:
family
]
count
]
>
0
;
}
#
endif
nsresult
gfxMacPlatformFontList
:
:
InitFontListForPlatform
(
)
{
nsAutoreleasePool
localPool
;
gfxPlatformMac
:
:
WaitForFontRegistration
(
)
;
Telemetry
:
:
AutoTimer
<
Telemetry
:
:
MAC_INITFONTLIST_TOTAL
>
timer
;
InitSystemFontNames
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
static
bool
firstTime
=
true
;
if
(
firstTime
)
{
:
:
CFNotificationCenterAddObserver
(
:
:
CFNotificationCenterGetLocalCenter
(
)
this
RegisteredFontsChangedNotificationCallback
kCTFontManagerRegisteredFontsChangedNotification
0
CFNotificationSuspensionBehaviorDeliverImmediately
)
;
firstTime
=
false
;
}
AutoCFRelease
<
CFArrayRef
>
familyNames
=
CTFontManagerCopyAvailableFontFamilyNames
(
)
;
for
(
NSString
*
familyName
in
(
NSArray
*
)
(
CFArrayRef
)
familyNames
)
{
AddFamily
(
(
CFStringRef
)
familyName
)
;
}
#
if
USE_DEPRECATED_FONT_FAMILY_NAMES
for
(
const
auto
&
name
:
kDeprecatedFontFamilies
)
{
if
(
DeprecatedFamilyIsAvailable
(
name
)
)
{
AddFamily
(
name
GetVisibilityForFamily
(
name
)
)
;
}
}
#
endif
}
else
{
auto
&
fontList
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SystemFontList
(
)
;
for
(
FontFamilyListEntry
&
ffe
:
fontList
.
entries
(
)
)
{
switch
(
ffe
.
entryType
(
)
)
{
case
kStandardFontFamily
:
if
(
nsCocoaFeatures
:
:
OnCatalinaOrLater
(
)
&
&
(
ffe
.
familyName
(
)
=
=
mSystemTextFontFamilyName
|
|
ffe
.
familyName
(
)
=
=
mSystemDisplayFontFamilyName
)
)
{
continue
;
}
AddFamily
(
ffe
.
familyName
(
)
ffe
.
visibility
(
)
)
;
break
;
case
kTextSizeSystemFontFamily
:
mSystemTextFontFamilyName
=
ffe
.
familyName
(
)
;
break
;
case
kDisplaySizeSystemFontFamily
:
mSystemDisplayFontFamilyName
=
ffe
.
familyName
(
)
;
mUseSizeSensitiveSystemFont
=
true
;
break
;
}
}
fontList
.
entries
(
)
.
Clear
(
)
;
}
InitSingleFaceList
(
)
;
PreloadNamesList
(
)
;
GetPrefsAndStartLoader
(
)
;
return
NS_OK
;
}
void
gfxMacPlatformFontList
:
:
InitSharedFontListForPlatform
(
)
{
nsAutoreleasePool
localPool
;
gfxPlatformMac
:
:
WaitForFontRegistration
(
)
;
InitSystemFontNames
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
static
bool
firstTime
=
true
;
if
(
firstTime
)
{
:
:
CFNotificationCenterAddObserver
(
:
:
CFNotificationCenterGetLocalCenter
(
)
this
RegisteredFontsChangedNotificationCallback
kCTFontManagerRegisteredFontsChangedNotification
0
CFNotificationSuspensionBehaviorDeliverImmediately
)
;
firstTime
=
false
;
}
AutoCFRelease
<
CFArrayRef
>
familyNames
=
CTFontManagerCopyAvailableFontFamilyNames
(
)
;
nsTArray
<
fontlist
:
:
Family
:
:
InitData
>
families
;
families
.
SetCapacity
(
CFArrayGetCount
(
familyNames
)
#
if
USE_DEPRECATED_FONT_FAMILY_NAMES
+
ArrayLength
(
kDeprecatedFontFamilies
)
#
endif
)
;
for
(
NSString
*
familyName
in
(
NSArray
*
)
(
CFArrayRef
)
familyNames
)
{
nsAutoString
name16
;
GetStringForNSString
(
familyName
name16
)
;
NS_ConvertUTF16toUTF8
name
(
name16
)
;
nsAutoCString
key
;
GenerateFontListKey
(
name
key
)
;
families
.
AppendElement
(
fontlist
:
:
Family
:
:
InitData
(
key
name
fontlist
:
:
Family
:
:
kNoIndex
GetVisibilityForFamily
(
name
)
)
)
;
}
#
if
USE_DEPRECATED_FONT_FAMILY_NAMES
for
(
const
nsACString
&
name
:
kDeprecatedFontFamilies
)
{
if
(
DeprecatedFamilyIsAvailable
(
name
)
)
{
nsAutoCString
key
;
GenerateFontListKey
(
name
key
)
;
families
.
AppendElement
(
fontlist
:
:
Family
:
:
InitData
(
key
name
fontlist
:
:
Family
:
:
kNoIndex
GetVisibilityForFamily
(
name
)
)
)
;
}
}
#
endif
SharedFontList
(
)
-
>
SetFamilyNames
(
families
)
;
InitAliasesForSingleFaceList
(
)
;
GetPrefsAndStartLoader
(
)
;
}
}
void
gfxMacPlatformFontList
:
:
InitAliasesForSingleFaceList
(
)
{
for
(
const
auto
&
familyName
:
mSingleFaceFonts
)
{
LOG_FONTLIST
(
(
"
(
fontlist
-
singleface
)
face
name
:
%
s
\
n
"
familyName
.
get
(
)
)
)
;
auto
colon
=
familyName
.
FindChar
(
'
:
'
)
;
if
(
colon
=
=
kNotFound
)
{
continue
;
}
nsAutoCString
key
;
GenerateFontListKey
(
Substring
(
familyName
colon
+
1
)
key
)
;
fontlist
:
:
Family
*
family
=
SharedFontList
(
)
-
>
FindFamily
(
key
)
;
if
(
!
family
)
{
continue
;
}
if
(
!
family
-
>
IsInitialized
(
)
)
{
if
(
!
gfxPlatformFontList
:
:
InitializeFamily
(
family
)
)
{
MOZ_ASSERT
(
false
"
failed
to
initialize
font
family
"
)
;
continue
;
}
}
nsAutoCString
aliasName
(
Substring
(
familyName
0
colon
)
)
;
fontlist
:
:
FontList
*
list
=
SharedFontList
(
)
;
const
fontlist
:
:
Pointer
*
facePtrs
=
family
-
>
Faces
(
list
)
;
for
(
size_t
i
=
0
;
i
<
family
-
>
NumFaces
(
)
;
i
+
+
)
{
if
(
facePtrs
[
i
]
.
IsNull
(
)
)
{
continue
;
}
auto
face
=
static_cast
<
const
fontlist
:
:
Face
*
>
(
facePtrs
[
i
]
.
ToPtr
(
list
)
)
;
if
(
face
-
>
mDescriptor
.
AsString
(
list
)
.
Equals
(
aliasName
)
)
{
GenerateFontListKey
(
aliasName
key
)
;
if
(
SharedFontList
(
)
-
>
FindFamily
(
key
)
|
|
mAliasTable
.
Get
(
key
)
)
{
MOZ_ASSERT
(
false
"
single
-
face
family
already
known
"
)
;
break
;
}
auto
aliasData
=
mAliasTable
.
GetOrInsertNew
(
key
)
;
aliasData
-
>
mFaces
.
AppendElement
(
facePtrs
[
i
]
)
;
aliasData
-
>
mBaseFamily
=
aliasName
;
aliasData
-
>
mVisibility
=
family
-
>
Visibility
(
)
;
break
;
}
}
}
if
(
!
mAliasTable
.
IsEmpty
(
)
)
{
SharedFontList
(
)
-
>
SetAliases
(
mAliasTable
)
;
}
}
void
gfxMacPlatformFontList
:
:
InitSingleFaceList
(
)
{
for
(
const
auto
&
familyName
:
mSingleFaceFonts
)
{
LOG_FONTLIST
(
(
"
(
fontlist
-
singleface
)
face
name
:
%
s
\
n
"
familyName
.
get
(
)
)
)
;
auto
colon
=
familyName
.
FindChar
(
'
:
'
)
;
if
(
colon
=
=
kNotFound
)
{
continue
;
}
nsAutoCString
key
(
Substring
(
familyName
colon
+
1
)
)
;
ToLowerCase
(
key
)
;
gfxFontFamily
*
family
=
mFontFamilies
.
GetWeak
(
key
)
;
if
(
!
family
|
|
family
-
>
IsHidden
(
)
)
{
continue
;
}
family
-
>
FindStyleVariations
(
)
;
nsAutoCString
aliasName
(
Substring
(
familyName
0
colon
)
)
;
const
gfxFontEntry
*
fe
=
nullptr
;
family
-
>
ReadLock
(
)
;
for
(
const
auto
&
face
:
family
-
>
GetFontList
(
)
)
{
if
(
face
-
>
Name
(
)
.
Equals
(
aliasName
)
)
{
fe
=
face
;
break
;
}
}
family
-
>
ReadUnlock
(
)
;
if
(
!
fe
)
{
continue
;
}
GenerateFontListKey
(
aliasName
key
)
;
LOG_FONTLIST
(
(
"
(
fontlist
-
singleface
)
family
name
:
%
s
key
:
%
s
\
n
"
aliasName
.
get
(
)
key
.
get
(
)
)
)
;
if
(
!
mFontFamilies
.
GetWeak
(
key
)
)
{
RefPtr
<
gfxFontFamily
>
familyEntry
=
new
gfxSingleFaceMacFontFamily
(
aliasName
family
-
>
Visibility
(
)
)
;
MacOSFontEntry
*
fontEntry
=
new
MacOSFontEntry
(
fe
-
>
Name
(
)
fe
-
>
Weight
(
)
true
static_cast
<
const
MacOSFontEntry
*
>
(
fe
)
-
>
mSizeHint
)
;
familyEntry
-
>
AddFontEntry
(
fontEntry
)
;
familyEntry
-
>
SetHasStyles
(
true
)
;
mFontFamilies
.
InsertOrUpdate
(
key
std
:
:
move
(
familyEntry
)
)
;
LOG_FONTLIST
(
(
"
(
fontlist
-
singleface
)
added
new
family
:
%
s
key
:
%
s
\
n
"
aliasName
.
get
(
)
key
.
get
(
)
)
)
;
}
}
}
static
NSString
*
GetRealFamilyName
(
NSFont
*
aFont
)
{
NSString
*
psName
=
[
[
aFont
fontDescriptor
]
postscriptName
]
;
AutoCFRelease
<
CGFontRef
>
cgFont
=
CGFontCreateWithFontName
(
CFStringRef
(
psName
)
)
;
if
(
!
cgFont
)
{
return
[
aFont
familyName
]
;
}
AutoCFRelease
<
CTFontRef
>
ctFont
=
CTFontCreateWithGraphicsFont
(
cgFont
0
.
0
nullptr
nullptr
)
;
if
(
!
ctFont
)
{
return
[
aFont
familyName
]
;
}
NSString
*
familyName
=
(
NSString
*
)
CTFontCopyFamilyName
(
ctFont
)
;
return
[
familyName
autorelease
]
;
}
static
gfxFontFamily
*
CreateFamilyForSystemFont
(
NSFont
*
aFont
const
nsACString
&
aFamilyName
)
{
gfxFontFamily
*
familyEntry
=
new
gfxMacFontFamily
(
aFamilyName
FontVisibility
:
:
Unknown
)
;
NSString
*
psNameNS
=
[
[
aFont
fontDescriptor
]
postscriptName
]
;
nsAutoString
nameUTF16
;
nsAutoCString
psName
;
nsCocoaUtils
:
:
GetStringForNSString
(
psNameNS
nameUTF16
)
;
CopyUTF16toUTF8
(
nameUTF16
psName
)
;
MacOSFontEntry
*
fe
=
new
MacOSFontEntry
(
psName
WeightRange
(
FontWeight
:
:
NORMAL
)
true
0
.
0
)
;
MOZ_ASSERT
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
HasVariationFontSupport
(
)
)
;
fe
-
>
SetupVariationRanges
(
)
;
familyEntry
-
>
AddFontEntry
(
fe
)
;
familyEntry
-
>
SetHasStyles
(
true
)
;
return
familyEntry
;
}
const
CGFloat
kTextDisplayCrossover
=
20
.
0
;
void
gfxMacPlatformFontList
:
:
InitSystemFontNames
(
)
{
mUseSizeSensitiveSystemFont
=
!
nsCocoaFeatures
:
:
OnCatalinaOrLater
(
)
;
NSFont
*
sys
=
[
NSFont
systemFontOfSize
:
0
.
0
]
;
NSString
*
textFamilyName
=
GetRealFamilyName
(
sys
)
;
nsAutoString
familyName
;
nsCocoaUtils
:
:
GetStringForNSString
(
textFamilyName
familyName
)
;
CopyUTF16toUTF8
(
familyName
mSystemTextFontFamilyName
)
;
if
(
nsCocoaFeatures
:
:
OnCatalinaOrLater
(
)
)
{
RefPtr
<
gfxFontFamily
>
fam
=
CreateFamilyForSystemFont
(
sys
mSystemTextFontFamilyName
)
;
if
(
fam
)
{
nsAutoCString
key
;
GenerateFontListKey
(
mSystemTextFontFamilyName
key
)
;
mFontFamilies
.
InsertOrUpdate
(
key
std
:
:
move
(
fam
)
)
;
}
}
if
(
mUseSizeSensitiveSystemFont
)
{
NSFont
*
displaySys
=
[
NSFont
systemFontOfSize
:
128
.
0
]
;
NSString
*
displayFamilyName
=
GetRealFamilyName
(
displaySys
)
;
if
(
[
displayFamilyName
isEqualToString
:
textFamilyName
]
)
{
mUseSizeSensitiveSystemFont
=
false
;
}
else
{
nsCocoaUtils
:
:
GetStringForNSString
(
displayFamilyName
familyName
)
;
CopyUTF16toUTF8
(
familyName
mSystemDisplayFontFamilyName
)
;
}
}
#
ifdef
DEBUG
NSString
*
sysFamily
=
GetRealFamilyName
(
[
NSFont
systemFontOfSize
:
0
.
0
]
)
;
if
(
[
sysFamily
compare
:
GetRealFamilyName
(
[
NSFont
boldSystemFontOfSize
:
0
.
0
]
)
]
!
=
NSOrderedSame
|
|
[
sysFamily
compare
:
GetRealFamilyName
(
[
NSFont
controlContentFontOfSize
:
0
.
0
]
)
]
!
=
NSOrderedSame
|
|
[
sysFamily
compare
:
GetRealFamilyName
(
[
NSFont
menuBarFontOfSize
:
0
.
0
]
)
]
!
=
NSOrderedSame
|
|
[
sysFamily
compare
:
GetRealFamilyName
(
[
NSFont
toolTipsFontOfSize
:
0
.
0
]
)
]
!
=
NSOrderedSame
)
{
NS_WARNING
(
"
system
font
types
map
to
different
font
families
"
"
-
-
please
log
a
bug
!
!
"
)
;
}
#
endif
}
gfxFontFamily
*
gfxMacPlatformFontList
:
:
FindSystemFontFamily
(
const
nsACString
&
aFamily
)
{
nsAutoCString
key
;
GenerateFontListKey
(
aFamily
key
)
;
gfxFontFamily
*
familyEntry
;
if
(
(
familyEntry
=
mFontFamilies
.
GetWeak
(
key
)
)
)
{
return
CheckFamily
(
familyEntry
)
;
}
return
nullptr
;
}
void
gfxMacPlatformFontList
:
:
RegisteredFontsChangedNotificationCallback
(
CFNotificationCenterRef
center
void
*
observer
CFStringRef
name
const
void
*
object
CFDictionaryRef
userInfo
)
{
if
(
!
:
:
CFEqual
(
name
kCTFontManagerRegisteredFontsChangedNotification
)
)
{
return
;
}
gfxMacPlatformFontList
*
fl
=
static_cast
<
gfxMacPlatformFontList
*
>
(
observer
)
;
if
(
!
fl
-
>
IsInitialized
(
)
)
{
return
;
}
fl
-
>
UpdateFontList
(
)
;
gfxPlatform
:
:
ForceGlobalReflow
(
gfxPlatform
:
:
NeedsReframe
:
:
Yes
)
;
dom
:
:
ContentParent
:
:
NotifyUpdatedFonts
(
true
)
;
}
gfxFontEntry
*
gfxMacPlatformFontList
:
:
PlatformGlobalFontFallback
(
nsPresContext
*
aPresContext
const
uint32_t
aCh
Script
aRunScript
const
gfxFontStyle
*
aMatchStyle
FontFamily
&
aMatchedFamily
)
{
CFStringRef
str
;
UniChar
ch
[
2
]
;
CFIndex
length
=
1
;
if
(
IS_IN_BMP
(
aCh
)
)
{
ch
[
0
]
=
aCh
;
str
=
:
:
CFStringCreateWithCharactersNoCopy
(
kCFAllocatorDefault
ch
1
kCFAllocatorNull
)
;
}
else
{
ch
[
0
]
=
H_SURROGATE
(
aCh
)
;
ch
[
1
]
=
L_SURROGATE
(
aCh
)
;
str
=
:
:
CFStringCreateWithCharactersNoCopy
(
kCFAllocatorDefault
ch
2
kCFAllocatorNull
)
;
if
(
!
str
)
{
return
nullptr
;
}
length
=
2
;
}
gfxFontEntry
*
fontEntry
=
nullptr
;
bool
cantUseFallbackFont
=
false
;
if
(
!
mDefaultFont
)
{
mDefaultFont
=
:
:
CTFontCreateWithName
(
CFSTR
(
"
LucidaGrande
"
)
12
.
f
NULL
)
;
}
AutoCFRelease
<
CTFontRef
>
fallback
=
:
:
CTFontCreateForString
(
mDefaultFont
str
:
:
CFRangeMake
(
0
length
)
)
;
if
(
fallback
)
{
AutoCFRelease
<
CFStringRef
>
familyNameRef
=
:
:
CTFontCopyFamilyName
(
fallback
)
;
if
(
familyNameRef
&
&
:
:
CFStringCompare
(
familyNameRef
CFSTR
(
"
LastResort
"
)
kCFCompareCaseInsensitive
)
!
=
kCFCompareEqualTo
&
&
:
:
CFStringCompare
(
familyNameRef
CFSTR
(
"
.
LastResort
"
)
kCFCompareCaseInsensitive
)
!
=
kCFCompareEqualTo
)
{
AutoTArray
<
UniChar
1024
>
buffer
;
CFIndex
familyNameLen
=
:
:
CFStringGetLength
(
familyNameRef
)
;
buffer
.
SetLength
(
familyNameLen
+
1
)
;
:
:
CFStringGetCharacters
(
familyNameRef
:
:
CFRangeMake
(
0
familyNameLen
)
buffer
.
Elements
(
)
)
;
buffer
[
familyNameLen
]
=
0
;
NS_ConvertUTF16toUTF8
familyNameString
(
reinterpret_cast
<
char16_t
*
>
(
buffer
.
Elements
(
)
)
familyNameLen
)
;
if
(
SharedFontList
(
)
)
{
fontlist
:
:
Family
*
family
=
FindSharedFamily
(
aPresContext
familyNameString
)
;
if
(
family
)
{
fontlist
:
:
Face
*
face
=
family
-
>
FindFaceForStyle
(
SharedFontList
(
)
*
aMatchStyle
)
;
if
(
face
)
{
fontEntry
=
GetOrCreateFontEntryLocked
(
face
family
)
;
}
if
(
fontEntry
)
{
if
(
fontEntry
-
>
HasCharacter
(
aCh
)
)
{
aMatchedFamily
=
FontFamily
(
family
)
;
}
else
{
fontEntry
=
nullptr
;
cantUseFallbackFont
=
true
;
}
}
}
}
if
(
!
fontEntry
)
{
gfxFontFamily
*
family
=
FindSystemFontFamily
(
familyNameString
)
;
if
(
family
)
{
fontEntry
=
family
-
>
FindFontForStyle
(
*
aMatchStyle
)
;
if
(
fontEntry
)
{
if
(
fontEntry
-
>
HasCharacter
(
aCh
)
)
{
aMatchedFamily
=
FontFamily
(
family
)
;
}
else
{
fontEntry
=
nullptr
;
cantUseFallbackFont
=
true
;
}
}
}
}
}
}
if
(
cantUseFallbackFont
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
BAD_FALLBACK_FONT
cantUseFallbackFont
)
;
}
:
:
CFRelease
(
str
)
;
return
fontEntry
;
}
FontFamily
gfxMacPlatformFontList
:
:
GetDefaultFontForPlatform
(
nsPresContext
*
aPresContext
const
gfxFontStyle
*
aStyle
nsAtom
*
aLanguage
)
{
nsAutoreleasePool
localPool
;
NSString
*
defaultFamily
=
[
[
NSFont
userFontOfSize
:
aStyle
-
>
size
]
familyName
]
;
nsAutoString
familyName
;
GetStringForNSString
(
defaultFamily
familyName
)
;
return
FindFamily
(
aPresContext
NS_ConvertUTF16toUTF8
(
familyName
)
)
;
}
int32_t
gfxMacPlatformFontList
:
:
AppleWeightToCSSWeight
(
int32_t
aAppleWeight
)
{
if
(
aAppleWeight
<
1
)
aAppleWeight
=
1
;
else
if
(
aAppleWeight
>
kAppleMaxWeight
)
aAppleWeight
=
kAppleMaxWeight
;
return
gAppleWeightToCSSWeight
[
aAppleWeight
]
;
}
gfxFontEntry
*
gfxMacPlatformFontList
:
:
LookupLocalFont
(
nsPresContext
*
aPresContext
const
nsACString
&
aFontName
WeightRange
aWeightForEntry
StretchRange
aStretchForEntry
SlantStyleRange
aStyleForEntry
)
{
if
(
aFontName
.
IsEmpty
(
)
|
|
aFontName
[
0
]
=
=
'
.
'
)
{
return
nullptr
;
}
AutoLock
lock
(
mLock
)
;
nsAutoreleasePool
localPool
;
NSString
*
faceName
=
GetNSStringForString
(
NS_ConvertUTF8toUTF16
(
aFontName
)
)
;
AutoCFRelease
<
CGFontRef
>
fontRef
=
CGFontCreateWithFontName
(
CFStringRef
(
faceName
)
)
;
if
(
!
fontRef
)
{
return
nullptr
;
}
AutoCFRelease
<
CTFontRef
>
ctFont
=
CTFontCreateWithGraphicsFont
(
fontRef
0
.
0
nullptr
nullptr
)
;
if
(
!
ctFont
)
{
return
nullptr
;
}
AutoCFRelease
<
CFStringRef
>
name
=
CTFontCopyFamilyName
(
ctFont
)
;
nsAutoCString
key
;
key
.
SetLength
(
(
CFStringGetLength
(
name
)
+
1
)
*
3
)
;
if
(
!
CFStringGetCString
(
name
key
.
BeginWriting
(
)
key
.
Length
(
)
kCFStringEncodingUTF8
)
)
{
NS_WARNING
(
"
Failed
to
get
family
name
?
"
)
;
key
.
Truncate
(
0
)
;
}
if
(
key
.
IsEmpty
(
)
)
{
return
nullptr
;
}
key
.
Truncate
(
strlen
(
key
.
get
(
)
)
)
;
ToLowerCase
(
key
)
;
FontFamily
family
=
FindFamily
(
aPresContext
key
)
;
if
(
family
.
IsNull
(
)
)
{
return
nullptr
;
}
return
new
MacOSFontEntry
(
aFontName
fontRef
aWeightForEntry
aStretchForEntry
aStyleForEntry
false
true
)
;
}
static
void
ReleaseData
(
void
*
info
const
void
*
data
size_t
size
)
{
free
(
(
void
*
)
data
)
;
}
gfxFontEntry
*
gfxMacPlatformFontList
:
:
MakePlatformFont
(
const
nsACString
&
aFontName
WeightRange
aWeightForEntry
StretchRange
aStretchForEntry
SlantStyleRange
aStyleForEntry
const
uint8_t
*
aFontData
uint32_t
aLength
)
{
NS_ASSERTION
(
aFontData
"
MakePlatformFont
called
with
null
data
"
)
;
nsAutoString
uniqueName
;
nsresult
rv
=
gfxFontUtils
:
:
MakeUniqueUserFontName
(
uniqueName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
AutoCFRelease
<
CGDataProviderRef
>
provider
=
:
:
CGDataProviderCreateWithData
(
nullptr
aFontData
aLength
&
ReleaseData
)
;
AutoCFRelease
<
CGFontRef
>
fontRef
=
:
:
CGFontCreateWithDataProvider
(
provider
)
;
if
(
!
fontRef
)
{
return
nullptr
;
}
auto
newFontEntry
=
MakeUnique
<
MacOSFontEntry
>
(
NS_ConvertUTF16toUTF8
(
uniqueName
)
fontRef
aWeightForEntry
aStretchForEntry
aStyleForEntry
true
false
)
;
return
newFontEntry
.
release
(
)
;
}
static
const
char
kSystemFont_system
[
]
=
"
-
apple
-
system
"
;
bool
gfxMacPlatformFontList
:
:
FindAndAddFamiliesLocked
(
nsPresContext
*
aPresContext
StyleGenericFontFamily
aGeneric
const
nsACString
&
aFamily
nsTArray
<
FamilyAndGeneric
>
*
aOutput
FindFamiliesFlags
aFlags
gfxFontStyle
*
aStyle
nsAtom
*
aLanguage
gfxFloat
aDevToCssSize
)
{
if
(
aFamily
.
EqualsLiteral
(
kSystemFont_system
)
)
{
const
nsCString
&
systemFontFamilyName
=
mUseSizeSensitiveSystemFont
&
&
aStyle
&
&
(
aStyle
-
>
size
*
aDevToCssSize
)
>
=
kTextDisplayCrossover
?
mSystemDisplayFontFamilyName
:
mSystemTextFontFamilyName
;
if
(
SharedFontList
(
)
&
&
!
nsCocoaFeatures
:
:
OnCatalinaOrLater
(
)
)
{
FindFamiliesFlags
flags
=
aFlags
|
FindFamiliesFlags
:
:
eSearchHiddenFamilies
;
return
gfxPlatformFontList
:
:
FindAndAddFamiliesLocked
(
aPresContext
aGeneric
systemFontFamilyName
aOutput
flags
aStyle
aLanguage
aDevToCssSize
)
;
}
else
{
if
(
auto
*
fam
=
FindSystemFontFamily
(
systemFontFamilyName
)
)
{
aOutput
-
>
AppendElement
(
fam
)
;
return
true
;
}
}
return
false
;
}
return
gfxPlatformFontList
:
:
FindAndAddFamiliesLocked
(
aPresContext
aGeneric
aFamily
aOutput
aFlags
aStyle
aLanguage
aDevToCssSize
)
;
}
void
gfxMacPlatformFontList
:
:
LookupSystemFont
(
LookAndFeel
:
:
FontID
aSystemFontID
nsACString
&
aSystemFontName
gfxFontStyle
&
aFontStyle
)
{
nsAutoreleasePool
localPool
;
NSFont
*
font
=
nullptr
;
char
*
systemFontName
=
nullptr
;
switch
(
aSystemFontID
)
{
case
LookAndFeel
:
:
FontID
:
:
MessageBox
:
case
LookAndFeel
:
:
FontID
:
:
StatusBar
:
case
LookAndFeel
:
:
FontID
:
:
MozList
:
case
LookAndFeel
:
:
FontID
:
:
MozField
:
case
LookAndFeel
:
:
FontID
:
:
MozButton
:
font
=
[
NSFont
systemFontOfSize
:
[
NSFont
smallSystemFontSize
]
]
;
systemFontName
=
(
char
*
)
kSystemFont_system
;
break
;
case
LookAndFeel
:
:
FontID
:
:
SmallCaption
:
font
=
[
NSFont
boldSystemFontOfSize
:
[
NSFont
smallSystemFontSize
]
]
;
systemFontName
=
(
char
*
)
kSystemFont_system
;
break
;
case
LookAndFeel
:
:
FontID
:
:
Icon
:
case
LookAndFeel
:
:
FontID
:
:
MozWorkspace
:
case
LookAndFeel
:
:
FontID
:
:
MozDesktop
:
case
LookAndFeel
:
:
FontID
:
:
MozInfo
:
font
=
[
NSFont
controlContentFontOfSize
:
0
.
0
]
;
systemFontName
=
(
char
*
)
kSystemFont_system
;
break
;
case
LookAndFeel
:
:
FontID
:
:
MozPullDownMenu
:
font
=
[
NSFont
menuBarFontOfSize
:
0
.
0
]
;
systemFontName
=
(
char
*
)
kSystemFont_system
;
break
;
case
LookAndFeel
:
:
FontID
:
:
Caption
:
case
LookAndFeel
:
:
FontID
:
:
Menu
:
case
LookAndFeel
:
:
FontID
:
:
MozDialog
:
default
:
font
=
[
NSFont
systemFontOfSize
:
0
.
0
]
;
systemFontName
=
(
char
*
)
kSystemFont_system
;
break
;
}
NS_ASSERTION
(
font
"
system
font
not
set
"
)
;
NS_ASSERTION
(
systemFontName
"
system
font
name
not
set
"
)
;
if
(
systemFontName
)
{
aSystemFontName
.
AssignASCII
(
systemFontName
)
;
}
NSFontSymbolicTraits
traits
=
[
[
font
fontDescriptor
]
symbolicTraits
]
;
aFontStyle
.
style
=
(
traits
&
NSFontItalicTrait
)
?
FontSlantStyle
:
:
ITALIC
:
FontSlantStyle
:
:
NORMAL
;
aFontStyle
.
weight
=
(
traits
&
NSFontBoldTrait
)
?
FontWeight
:
:
BOLD
:
FontWeight
:
:
NORMAL
;
aFontStyle
.
stretch
=
(
traits
&
NSFontExpandedTrait
)
?
FontStretch
:
:
EXPANDED
:
(
traits
&
NSFontCondensedTrait
)
?
FontStretch
:
:
CONDENSED
:
FontStretch
:
:
NORMAL
;
aFontStyle
.
size
=
[
font
pointSize
]
;
aFontStyle
.
systemFont
=
true
;
}
class
MacFontInfo
final
:
public
FontInfoData
{
public
:
MacFontInfo
(
bool
aLoadOtherNames
bool
aLoadFaceNames
bool
aLoadCmaps
)
:
FontInfoData
(
aLoadOtherNames
aLoadFaceNames
aLoadCmaps
)
{
}
virtual
~
MacFontInfo
(
)
=
default
;
virtual
void
Load
(
)
{
nsAutoreleasePool
localPool
;
FontInfoData
:
:
Load
(
)
;
}
virtual
void
LoadFontFamilyData
(
const
nsACString
&
aFamilyName
)
;
}
;
void
MacFontInfo
:
:
LoadFontFamilyData
(
const
nsACString
&
aFamilyName
)
{
CrashReporter
:
:
AutoAnnotateCrashReport
autoFontName
(
CrashReporter
:
:
Annotation
:
:
FontName
aFamilyName
)
;
NSString
*
famName
=
GetNSStringForString
(
NS_ConvertUTF8toUTF16
(
aFamilyName
)
)
;
CFStringRef
family
=
CFStringRef
(
famName
)
;
AutoCFRelease
<
CFMutableDictionaryRef
>
attr
=
CFDictionaryCreateMutable
(
NULL
0
&
kCFTypeDictionaryKeyCallBacks
&
kCFTypeDictionaryValueCallBacks
)
;
CFDictionaryAddValue
(
attr
kCTFontFamilyNameAttribute
family
)
;
AutoCFRelease
<
CTFontDescriptorRef
>
fd
=
CTFontDescriptorCreateWithAttributes
(
attr
)
;
AutoCFRelease
<
CFArrayRef
>
matchingFonts
=
CTFontDescriptorCreateMatchingFontDescriptors
(
fd
NULL
)
;
if
(
!
matchingFonts
)
{
return
;
}
nsTArray
<
nsCString
>
otherFamilyNames
;
bool
hasOtherFamilyNames
=
true
;
int
f
numFaces
=
(
int
)
CFArrayGetCount
(
matchingFonts
)
;
for
(
f
=
0
;
f
<
numFaces
;
f
+
+
)
{
mLoadStats
.
fonts
+
+
;
CTFontDescriptorRef
faceDesc
=
(
CTFontDescriptorRef
)
CFArrayGetValueAtIndex
(
matchingFonts
f
)
;
if
(
!
faceDesc
)
{
continue
;
}
AutoCFRelease
<
CTFontRef
>
fontRef
=
CTFontCreateWithFontDescriptor
(
faceDesc
0
.
0
nullptr
)
;
if
(
!
fontRef
)
{
NS_WARNING
(
"
failed
to
create
a
CTFontRef
"
)
;
continue
;
}
if
(
mLoadCmaps
)
{
AutoCFRelease
<
CFStringRef
>
faceName
=
(
CFStringRef
)
CTFontDescriptorCopyAttribute
(
faceDesc
kCTFontNameAttribute
)
;
AutoTArray
<
UniChar
1024
>
buffer
;
CFIndex
len
=
CFStringGetLength
(
faceName
)
;
buffer
.
SetLength
(
len
+
1
)
;
CFStringGetCharacters
(
faceName
:
:
CFRangeMake
(
0
len
)
buffer
.
Elements
(
)
)
;
buffer
[
len
]
=
0
;
NS_ConvertUTF16toUTF8
fontName
(
reinterpret_cast
<
char16_t
*
>
(
buffer
.
Elements
(
)
)
len
)
;
FontFaceData
fontData
;
AutoCFRelease
<
CFDataRef
>
cmapTable
=
CTFontCopyTable
(
fontRef
kCTFontTableCmap
kCTFontTableOptionNoOptions
)
;
if
(
cmapTable
)
{
const
uint8_t
*
cmapData
=
(
const
uint8_t
*
)
CFDataGetBytePtr
(
cmapTable
)
;
uint32_t
cmapLen
=
CFDataGetLength
(
cmapTable
)
;
RefPtr
<
gfxCharacterMap
>
charmap
=
new
gfxCharacterMap
(
)
;
uint32_t
offset
;
nsresult
rv
;
rv
=
gfxFontUtils
:
:
ReadCMAP
(
cmapData
cmapLen
*
charmap
offset
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
fontData
.
mCharacterMap
=
charmap
;
fontData
.
mUVSOffset
=
offset
;
mLoadStats
.
cmaps
+
+
;
}
}
mFontFaceData
.
InsertOrUpdate
(
fontName
fontData
)
;
}
if
(
mLoadOtherNames
&
&
hasOtherFamilyNames
)
{
AutoCFRelease
<
CFDataRef
>
nameTable
=
CTFontCopyTable
(
fontRef
kCTFontTableName
kCTFontTableOptionNoOptions
)
;
if
(
nameTable
)
{
const
char
*
nameData
=
(
const
char
*
)
CFDataGetBytePtr
(
nameTable
)
;
uint32_t
nameLen
=
CFDataGetLength
(
nameTable
)
;
gfxFontUtils
:
:
ReadOtherFamilyNamesForFace
(
aFamilyName
nameData
nameLen
otherFamilyNames
false
)
;
hasOtherFamilyNames
=
otherFamilyNames
.
Length
(
)
!
=
0
;
}
}
}
if
(
otherFamilyNames
.
Length
(
)
!
=
0
)
{
mOtherFamilyNames
.
InsertOrUpdate
(
aFamilyName
otherFamilyNames
)
;
mLoadStats
.
othernames
+
=
otherFamilyNames
.
Length
(
)
;
}
}
already_AddRefed
<
FontInfoData
>
gfxMacPlatformFontList
:
:
CreateFontInfoData
(
)
{
bool
loadCmaps
=
!
UsesSystemFallback
(
)
|
|
gfxPlatform
:
:
GetPlatform
(
)
-
>
UseCmapsDuringSystemFallback
(
)
;
mLock
.
AssertCurrentThreadIn
(
)
;
RefPtr
<
MacFontInfo
>
fi
=
new
MacFontInfo
(
true
NeedFullnamePostscriptNames
(
)
loadCmaps
)
;
return
fi
.
forget
(
)
;
}
gfxFontFamily
*
gfxMacPlatformFontList
:
:
CreateFontFamily
(
const
nsACString
&
aName
FontVisibility
aVisibility
)
const
{
return
new
gfxMacFontFamily
(
aName
aVisibility
0
.
0
)
;
}
gfxFontEntry
*
gfxMacPlatformFontList
:
:
CreateFontEntry
(
fontlist
:
:
Face
*
aFace
const
fontlist
:
:
Family
*
aFamily
)
{
MacOSFontEntry
*
fe
=
new
MacOSFontEntry
(
aFace
-
>
mDescriptor
.
AsString
(
SharedFontList
(
)
)
aFace
-
>
mWeight
false
0
.
0
)
;
fe
-
>
InitializeFrom
(
aFace
aFamily
)
;
return
fe
;
}
void
gfxMacPlatformFontList
:
:
GetFacesInitDataForFamily
(
const
fontlist
:
:
Family
*
aFamily
nsTArray
<
fontlist
:
:
Face
:
:
InitData
>
&
aFaces
bool
aLoadCmaps
)
const
{
nsAutoreleasePool
localPool
;
NS_ConvertUTF8toUTF16
name
(
aFamily
-
>
Key
(
)
.
AsString
(
SharedFontList
(
)
)
)
;
NSString
*
family
=
GetNSStringForString
(
name
)
;
NSArray
*
fontfaces
=
[
sFontManager
availableMembersOfFontFamily
:
family
]
;
int
faceCount
=
[
fontfaces
count
]
;
for
(
int
faceIndex
=
0
;
faceIndex
<
faceCount
;
faceIndex
+
+
)
{
NSArray
*
face
=
[
fontfaces
objectAtIndex
:
faceIndex
]
;
NSString
*
psname
=
[
face
objectAtIndex
:
INDEX_FONT_POSTSCRIPT_NAME
]
;
int32_t
appKitWeight
=
[
[
face
objectAtIndex
:
INDEX_FONT_WEIGHT
]
unsignedIntValue
]
;
uint32_t
macTraits
=
[
[
face
objectAtIndex
:
INDEX_FONT_TRAITS
]
unsignedIntValue
]
;
NSString
*
facename
=
[
face
objectAtIndex
:
INDEX_FONT_FACE_NAME
]
;
if
(
appKitWeight
=
=
kAppleExtraLightWeight
)
{
NSRange
range
=
[
facename
rangeOfString
:
"
ultralight
"
options
:
NSCaseInsensitiveSearch
]
;
if
(
range
.
location
!
=
NSNotFound
)
{
appKitWeight
=
kAppleUltraLightWeight
;
}
}
nsAutoString
postscriptFontName
;
GetStringForNSString
(
psname
postscriptFontName
)
;
int32_t
cssWeight
=
gfxMacPlatformFontList
:
:
AppleWeightToCSSWeight
(
appKitWeight
)
;
if
(
PR_GetCurrentThread
(
)
!
=
sInitFontListThread
)
{
int32_t
weightOverride
=
GetWeightOverride
(
postscriptFontName
)
;
if
(
weightOverride
)
{
cssWeight
=
(
(
weightOverride
+
50
)
/
100
)
;
cssWeight
=
std
:
:
max
(
1
std
:
:
min
(
cssWeight
9
)
)
;
}
}
cssWeight
*
=
100
;
StretchRange
stretch
(
FontStretch
:
:
NORMAL
)
;
if
(
macTraits
&
(
NSCondensedFontMask
|
NSNarrowFontMask
|
NSCompressedFontMask
)
)
{
stretch
=
StretchRange
(
FontStretch
:
:
CONDENSED
)
;
}
else
if
(
macTraits
&
NSExpandedFontMask
)
{
stretch
=
StretchRange
(
FontStretch
:
:
EXPANDED
)
;
}
SlantStyleRange
slantStyle
(
FontSlantStyle
:
:
NORMAL
)
;
if
(
(
macTraits
&
NSItalicFontMask
)
|
|
[
facename
hasSuffix
:
"
Italic
"
]
|
|
[
facename
hasSuffix
:
"
Oblique
"
]
)
{
slantStyle
=
SlantStyleRange
(
FontSlantStyle
:
:
ITALIC
)
;
}
bool
fixedPitch
=
(
macTraits
&
NSFixedPitchFontMask
)
?
true
:
false
;
RefPtr
<
gfxCharacterMap
>
charmap
;
if
(
aLoadCmaps
)
{
AutoCFRelease
<
CGFontRef
>
font
=
CGFontCreateWithFontName
(
CFStringRef
(
psname
)
)
;
if
(
font
)
{
uint32_t
kCMAP
=
TRUETYPE_TAG
(
'
c
'
'
m
'
'
a
'
'
p
'
)
;
AutoCFRelease
<
CFDataRef
>
data
=
CGFontCopyTableForTag
(
font
kCMAP
)
;
if
(
data
)
{
uint32_t
offset
;
charmap
=
new
gfxCharacterMap
(
)
;
gfxFontUtils
:
:
ReadCMAP
(
CFDataGetBytePtr
(
data
)
CFDataGetLength
(
data
)
*
charmap
offset
)
;
}
}
}
auto
data
=
fontlist
:
:
Face
:
:
InitData
{
NS_ConvertUTF16toUTF8
(
postscriptFontName
)
0
fixedPitch
WeightRange
(
FontWeight
:
:
FromInt
(
cssWeight
)
)
stretch
slantStyle
charmap
}
;
if
(
[
facename
caseInsensitiveCompare
:
"
Regular
"
]
=
=
NSOrderedSame
)
{
aFaces
.
InsertElementAt
(
0
std
:
:
move
(
data
)
)
;
}
else
{
aFaces
.
AppendElement
(
std
:
:
move
(
data
)
)
;
}
}
}
void
gfxMacPlatformFontList
:
:
ReadFaceNamesForFamily
(
fontlist
:
:
Family
*
aFamily
bool
aNeedFullnamePostscriptNames
)
{
if
(
!
aFamily
-
>
IsInitialized
(
)
)
{
if
(
!
InitializeFamily
(
aFamily
)
)
{
return
;
}
}
const
uint32_t
kNAME
=
TRUETYPE_TAG
(
'
n
'
'
a
'
'
m
'
'
e
'
)
;
fontlist
:
:
FontList
*
list
=
SharedFontList
(
)
;
nsAutoCString
canonicalName
(
aFamily
-
>
DisplayName
(
)
.
AsString
(
list
)
)
;
const
fontlist
:
:
Pointer
*
facePtrs
=
aFamily
-
>
Faces
(
list
)
;
for
(
uint32_t
i
=
0
n
=
aFamily
-
>
NumFaces
(
)
;
i
<
n
;
i
+
+
)
{
auto
face
=
static_cast
<
fontlist
:
:
Face
*
>
(
facePtrs
[
i
]
.
ToPtr
(
list
)
)
;
if
(
!
face
)
{
continue
;
}
nsAutoCString
name
(
face
-
>
mDescriptor
.
AsString
(
list
)
)
;
auto
fe
=
MakeUnique
<
MacOSFontEntry
>
(
name
WeightRange
(
FontWeight
:
:
NORMAL
)
false
16
.
0
)
;
if
(
!
fe
)
{
continue
;
}
gfxFontEntry
:
:
AutoTable
nameTable
(
fe
.
get
(
)
kNAME
)
;
if
(
!
nameTable
)
{
continue
;
}
uint32_t
dataLength
;
const
char
*
nameData
=
hb_blob_get_data
(
nameTable
&
dataLength
)
;
AutoTArray
<
nsCString
4
>
otherFamilyNames
;
gfxFontUtils
:
:
ReadOtherFamilyNamesForFace
(
canonicalName
nameData
dataLength
otherFamilyNames
false
)
;
for
(
const
auto
&
alias
:
otherFamilyNames
)
{
nsAutoCString
key
;
GenerateFontListKey
(
alias
key
)
;
auto
aliasData
=
mAliasTable
.
GetOrInsertNew
(
key
)
;
aliasData
-
>
InitFromFamily
(
aFamily
canonicalName
)
;
aliasData
-
>
mFaces
.
AppendElement
(
facePtrs
[
i
]
)
;
}
}
}
