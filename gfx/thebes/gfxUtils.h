#
ifndef
GFX_UTILS_H
#
define
GFX_UTILS_H
#
include
"
gfxTypes
.
h
"
#
include
"
ImageTypes
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsRegionFwd
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
webrender
/
webrender_ffi
.
h
"
class
gfxASurface
;
class
gfxDrawable
;
class
nsIInputStream
;
class
nsIGfxInfo
;
class
nsIPresShell
;
namespace
mozilla
{
namespace
layers
{
class
WebRenderBridgeChild
;
class
GlyphArray
;
struct
PlanarYCbCrData
;
class
WebRenderCommand
;
}
namespace
image
{
class
ImageRegion
;
}
}
class
gfxUtils
{
public
:
typedef
mozilla
:
:
gfx
:
:
DataSourceSurface
DataSourceSurface
;
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
typedef
mozilla
:
:
gfx
:
:
IntPoint
IntPoint
;
typedef
mozilla
:
:
gfx
:
:
Matrix
Matrix
;
typedef
mozilla
:
:
gfx
:
:
SourceSurface
SourceSurface
;
typedef
mozilla
:
:
gfx
:
:
SurfaceFormat
SurfaceFormat
;
typedef
mozilla
:
:
image
:
:
ImageRegion
ImageRegion
;
static
bool
PremultiplyDataSurface
(
DataSourceSurface
*
srcSurf
DataSourceSurface
*
destSurf
)
;
static
bool
UnpremultiplyDataSurface
(
DataSourceSurface
*
srcSurf
DataSourceSurface
*
destSurf
)
;
static
already_AddRefed
<
DataSourceSurface
>
CreatePremultipliedDataSurface
(
DataSourceSurface
*
srcSurf
)
;
static
already_AddRefed
<
DataSourceSurface
>
CreateUnpremultipliedDataSurface
(
DataSourceSurface
*
srcSurf
)
;
static
void
ConvertBGRAtoRGBA
(
uint8_t
*
aData
uint32_t
aLength
)
;
static
void
DrawPixelSnapped
(
gfxContext
*
aContext
gfxDrawable
*
aDrawable
const
gfxSize
&
aImageSize
const
ImageRegion
&
aRegion
const
mozilla
:
:
gfx
:
:
SurfaceFormat
aFormat
mozilla
:
:
gfx
:
:
SamplingFilter
aSamplingFilter
uint32_t
aImageFlags
=
imgIContainer
:
:
FLAG_NONE
gfxFloat
aOpacity
=
1
.
0
)
;
static
void
ClipToRegion
(
gfxContext
*
aContext
const
nsIntRegion
&
aRegion
)
;
static
void
ClipToRegion
(
mozilla
:
:
gfx
:
:
DrawTarget
*
aTarget
const
nsIntRegion
&
aRegion
)
;
static
int
ImageFormatToDepth
(
gfxImageFormat
aFormat
)
;
static
gfxMatrix
TransformRectToRect
(
const
gfxRect
&
aFrom
const
gfxPoint
&
aToTopLeft
const
gfxPoint
&
aToTopRight
const
gfxPoint
&
aToBottomRight
)
;
static
Matrix
TransformRectToRect
(
const
gfxRect
&
aFrom
const
IntPoint
&
aToTopLeft
const
IntPoint
&
aToTopRight
const
IntPoint
&
aToBottomRight
)
;
static
bool
GfxRectToIntRect
(
const
gfxRect
&
aIn
mozilla
:
:
gfx
:
:
IntRect
*
aOut
)
;
static
gfxFloat
ClampToScaleFactor
(
gfxFloat
aVal
)
;
static
void
ClearThebesSurface
(
gfxASurface
*
aSurface
)
;
static
const
float
*
YuvToRgbMatrix4x3RowMajor
(
mozilla
:
:
YUVColorSpace
aYUVColorSpace
)
;
static
const
float
*
YuvToRgbMatrix3x3ColumnMajor
(
mozilla
:
:
YUVColorSpace
aYUVColorSpace
)
;
static
already_AddRefed
<
DataSourceSurface
>
CopySurfaceToDataSourceSurfaceWithFormat
(
SourceSurface
*
aSurface
SurfaceFormat
aFormat
)
;
static
const
mozilla
:
:
gfx
:
:
Color
&
GetColorForFrameNumber
(
uint64_t
aFrameNumber
)
;
static
const
uint32_t
sNumFrameColors
;
enum
BinaryOrData
{
eBinaryEncode
eDataURIEncode
}
;
static
nsresult
EncodeSourceSurface
(
SourceSurface
*
aSurface
const
nsACString
&
aMimeType
const
nsAString
&
aOutputOptions
BinaryOrData
aBinaryOrData
FILE
*
aFile
)
;
static
void
WriteAsPNG
(
SourceSurface
*
aSurface
const
nsAString
&
aFile
)
;
static
void
WriteAsPNG
(
SourceSurface
*
aSurface
const
char
*
aFile
)
;
static
void
WriteAsPNG
(
DrawTarget
*
aDT
const
nsAString
&
aFile
)
;
static
void
WriteAsPNG
(
DrawTarget
*
aDT
const
char
*
aFile
)
;
static
void
WriteAsPNG
(
nsIPresShell
*
aShell
const
char
*
aFile
)
;
static
void
DumpAsDataURI
(
SourceSurface
*
aSourceSurface
FILE
*
aFile
)
;
static
inline
void
DumpAsDataURI
(
SourceSurface
*
aSourceSurface
)
{
DumpAsDataURI
(
aSourceSurface
stdout
)
;
}
static
void
DumpAsDataURI
(
DrawTarget
*
aDT
FILE
*
aFile
)
;
static
inline
void
DumpAsDataURI
(
DrawTarget
*
aDT
)
{
DumpAsDataURI
(
aDT
stdout
)
;
}
static
nsCString
GetAsDataURI
(
SourceSurface
*
aSourceSurface
)
;
static
nsCString
GetAsDataURI
(
DrawTarget
*
aDT
)
;
static
nsCString
GetAsLZ4Base64Str
(
DataSourceSurface
*
aSourceSurface
)
;
static
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
GetImageBuffer
(
DataSourceSurface
*
aSurface
bool
aIsAlphaPremultiplied
int32_t
*
outFormat
)
;
static
nsresult
GetInputStream
(
DataSourceSurface
*
aSurface
bool
aIsAlphaPremultiplied
const
char
*
aMimeType
const
char16_t
*
aEncoderOptions
nsIInputStream
*
*
outStream
)
;
static
nsresult
ThreadSafeGetFeatureStatus
(
const
nsCOMPtr
<
nsIGfxInfo
>
&
gfxInfo
int32_t
feature
nsACString
&
failureId
int32_t
*
status
)
;
static
void
CopyAsDataURI
(
SourceSurface
*
aSourceSurface
)
;
static
void
CopyAsDataURI
(
DrawTarget
*
aDT
)
;
static
bool
DumpDisplayList
(
)
;
static
FILE
*
sDumpPaintFile
;
}
;
namespace
mozilla
{
namespace
gfx
{
Color
ToDeviceColor
(
Color
aColor
)
;
Color
ToDeviceColor
(
nscolor
aColor
)
;
static
inline
CheckedInt
<
uint32_t
>
SafeBytesForBitmap
(
uint32_t
aWidth
uint32_t
aHeight
unsigned
aBytesPerPixel
)
{
MOZ_ASSERT
(
aBytesPerPixel
>
0
)
;
CheckedInt
<
uint32_t
>
width
=
uint32_t
(
aWidth
)
;
CheckedInt
<
uint32_t
>
height
=
uint32_t
(
aHeight
)
;
return
width
*
height
*
aBytesPerPixel
;
}
class
WebRenderGlyphHelper
final
{
public
:
WebRenderGlyphHelper
(
)
:
mFontData
(
nullptr
)
mFontDataLength
(
0
)
mIndex
(
0
)
mGlyphSize
(
0
.
0
)
{
}
~
WebRenderGlyphHelper
(
)
{
if
(
mFontData
)
{
free
(
mFontData
)
;
}
}
void
BuildWebRenderCommands
(
layers
:
:
WebRenderBridgeChild
*
aChild
nsTArray
<
layers
:
:
WebRenderCommand
>
&
aCommands
const
nsTArray
<
layers
:
:
GlyphArray
>
&
aGlyphs
ScaledFont
*
aFont
const
Point
&
aOffset
const
Rect
&
aBounds
const
Rect
&
aClip
)
;
public
:
uint8_t
*
mFontData
;
uint32_t
mFontDataLength
;
uint32_t
mIndex
;
float
mGlyphSize
;
}
;
}
}
#
endif
