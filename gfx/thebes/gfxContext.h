#
ifndef
GFX_CONTEXT_H
#
define
GFX_CONTEXT_H
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxPattern
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
typedef
struct
_cairo
cairo_t
;
class
GlyphBufferAzure
;
namespace
mozilla
{
namespace
gfx
{
struct
RectCornerRadii
;
}
namespace
layout
{
class
TextDrawTarget
;
}
}
class
ClipExporter
;
class
PatternFromState
{
public
:
explicit
PatternFromState
(
const
gfxContext
*
aContext
)
:
mContext
(
aContext
)
mPattern
(
nullptr
)
{
}
~
PatternFromState
(
)
{
if
(
mPattern
)
{
mPattern
-
>
~
Pattern
(
)
;
}
}
operator
mozilla
:
:
gfx
:
:
Pattern
&
(
)
;
private
:
mozilla
:
:
AlignedStorage2
<
mozilla
:
:
gfx
:
:
ColorPattern
>
mColorPattern
;
const
gfxContext
*
mContext
;
mozilla
:
:
gfx
:
:
Pattern
*
mPattern
;
}
;
class
gfxContext
final
{
#
ifdef
DEBUG
#
define
CURRENTSTATE_CHANGED
(
)
mAzureState
.
mContentChanged
=
true
;
#
else
#
define
CURRENTSTATE_CHANGED
(
)
#
endif
typedef
mozilla
:
:
gfx
:
:
BackendType
BackendType
;
typedef
mozilla
:
:
gfx
:
:
CapStyle
CapStyle
;
typedef
mozilla
:
:
gfx
:
:
CompositionOp
CompositionOp
;
typedef
mozilla
:
:
gfx
:
:
DeviceColor
DeviceColor
;
typedef
mozilla
:
:
gfx
:
:
DrawOptions
DrawOptions
;
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
typedef
mozilla
:
:
gfx
:
:
JoinStyle
JoinStyle
;
typedef
mozilla
:
:
gfx
:
:
FillRule
FillRule
;
typedef
mozilla
:
:
gfx
:
:
Float
Float
;
typedef
mozilla
:
:
gfx
:
:
Matrix
Matrix
;
typedef
mozilla
:
:
gfx
:
:
Path
Path
;
typedef
mozilla
:
:
gfx
:
:
Pattern
Pattern
;
typedef
mozilla
:
:
gfx
:
:
Point
Point
;
typedef
mozilla
:
:
gfx
:
:
Rect
Rect
;
typedef
mozilla
:
:
gfx
:
:
RectCornerRadii
RectCornerRadii
;
typedef
mozilla
:
:
gfx
:
:
Size
Size
;
public
:
MOZ_NONNULL
(
2
)
explicit
gfxContext
(
DrawTarget
*
aTarget
const
Point
&
aDeviceOffset
=
Point
(
)
)
:
mDT
(
aTarget
)
{
mAzureState
.
deviceOffset
=
aDeviceOffset
;
mDT
-
>
SetTransform
(
GetDTTransform
(
)
)
;
}
MOZ_NONNULL
(
2
)
gfxContext
(
DrawTarget
*
aTarget
bool
aPreserveTransform
)
:
mDT
(
aTarget
)
{
if
(
aPreserveTransform
)
{
SetMatrix
(
aTarget
-
>
GetTransform
(
)
)
;
}
else
{
mDT
-
>
SetTransform
(
GetDTTransform
(
)
)
;
}
}
~
gfxContext
(
)
;
static
mozilla
:
:
UniquePtr
<
gfxContext
>
CreateOrNull
(
DrawTarget
*
aTarget
const
Point
&
aDeviceOffset
=
Point
(
)
)
;
DrawTarget
*
GetDrawTarget
(
)
const
{
return
mDT
;
}
mozilla
:
:
layout
:
:
TextDrawTarget
*
GetTextDrawer
(
)
const
;
void
Save
(
)
;
void
Restore
(
)
;
void
Fill
(
)
{
Fill
(
PatternFromState
(
this
)
)
;
}
void
Fill
(
const
Pattern
&
aPattern
)
;
void
NewPath
(
)
{
mPath
=
nullptr
;
mPathBuilder
=
nullptr
;
mPathIsRect
=
false
;
mTransformChanged
=
false
;
}
already_AddRefed
<
Path
>
GetPath
(
)
{
EnsurePath
(
)
;
RefPtr
<
Path
>
path
(
mPath
)
;
return
path
.
forget
(
)
;
}
void
SetPath
(
Path
*
path
)
{
MOZ_ASSERT
(
path
-
>
GetBackendType
(
)
=
=
mDT
-
>
GetBackendType
(
)
|
|
path
-
>
GetBackendType
(
)
=
=
BackendType
:
:
RECORDING
|
|
(
mDT
-
>
GetBackendType
(
)
=
=
BackendType
:
:
DIRECT2D1_1
&
&
path
-
>
GetBackendType
(
)
=
=
BackendType
:
:
DIRECT2D
)
)
;
mPath
=
path
;
mPathBuilder
=
nullptr
;
mPathIsRect
=
false
;
mTransformChanged
=
false
;
}
void
Rectangle
(
const
gfxRect
&
rect
)
{
return
Rectangle
(
rect
false
)
;
}
void
SnappedRectangle
(
const
gfxRect
&
rect
)
{
return
Rectangle
(
rect
true
)
;
}
private
:
void
Rectangle
(
const
gfxRect
&
rect
bool
snapToPixels
)
;
public
:
void
Multiply
(
const
gfxMatrix
&
aMatrix
)
{
Multiply
(
ToMatrix
(
aMatrix
)
)
;
}
void
Multiply
(
const
Matrix
&
aOther
)
{
CURRENTSTATE_CHANGED
(
)
ChangeTransform
(
aOther
*
mAzureState
.
transform
)
;
}
void
SetMatrix
(
const
Matrix
&
aMatrix
)
{
CURRENTSTATE_CHANGED
(
)
ChangeTransform
(
aMatrix
)
;
}
void
SetMatrixDouble
(
const
gfxMatrix
&
aMatrix
)
{
SetMatrix
(
ToMatrix
(
aMatrix
)
)
;
}
void
SetCrossProcessPaintScale
(
float
aScale
)
{
MOZ_ASSERT
(
mCrossProcessPaintScale
=
=
1
.
0f
"
Should
only
be
initialized
once
"
)
;
mCrossProcessPaintScale
=
aScale
;
}
float
GetCrossProcessPaintScale
(
)
const
{
return
mCrossProcessPaintScale
;
}
Matrix
CurrentMatrix
(
)
const
{
return
mAzureState
.
transform
;
}
gfxMatrix
CurrentMatrixDouble
(
)
const
{
return
ThebesMatrix
(
CurrentMatrix
(
)
)
;
}
gfxPoint
DeviceToUser
(
const
gfxPoint
&
aPoint
)
const
{
return
ThebesPoint
(
mAzureState
.
transform
.
Inverse
(
)
.
TransformPoint
(
ToPoint
(
aPoint
)
)
)
;
}
Size
DeviceToUser
(
const
Size
&
aSize
)
const
{
return
mAzureState
.
transform
.
Inverse
(
)
.
TransformSize
(
aSize
)
;
}
gfxRect
DeviceToUser
(
const
gfxRect
&
aRect
)
const
{
return
ThebesRect
(
mAzureState
.
transform
.
Inverse
(
)
.
TransformBounds
(
ToRect
(
aRect
)
)
)
;
}
gfxPoint
UserToDevice
(
const
gfxPoint
&
aPoint
)
const
{
return
ThebesPoint
(
mAzureState
.
transform
.
TransformPoint
(
ToPoint
(
aPoint
)
)
)
;
}
Size
UserToDevice
(
const
Size
&
aSize
)
const
{
const
auto
&
mtx
=
mAzureState
.
transform
;
return
Size
(
aSize
.
width
*
mtx
.
_11
+
aSize
.
height
*
mtx
.
_12
aSize
.
width
*
mtx
.
_21
+
aSize
.
height
*
mtx
.
_22
)
;
}
gfxRect
UserToDevice
(
const
gfxRect
&
rect
)
const
{
return
ThebesRect
(
mAzureState
.
transform
.
TransformBounds
(
ToRect
(
rect
)
)
)
;
}
enum
class
SnapOption
:
uint8_t
{
IgnoreScale
=
1
PrioritizeSize
=
2
}
;
using
SnapOptions
=
mozilla
:
:
EnumSet
<
SnapOption
>
;
bool
UserToDevicePixelSnapped
(
gfxRect
&
rect
SnapOptions
aOptions
=
{
}
)
const
;
bool
UserToDevicePixelSnapped
(
gfxPoint
&
pt
bool
ignoreScale
=
false
)
const
;
void
SetDeviceColor
(
const
DeviceColor
&
aColor
)
{
CURRENTSTATE_CHANGED
(
)
mAzureState
.
pattern
=
nullptr
;
mAzureState
.
color
=
aColor
;
}
bool
GetDeviceColor
(
DeviceColor
&
aColorOut
)
const
;
bool
HasNonOpaqueNonTransparentColor
(
DeviceColor
&
aColorOut
)
const
{
return
GetDeviceColor
(
aColorOut
)
&
&
0
.
f
<
aColorOut
.
a
&
&
aColorOut
.
a
<
1
.
f
;
}
void
SetColor
(
const
mozilla
:
:
gfx
:
:
sRGBColor
&
aColor
)
{
CURRENTSTATE_CHANGED
(
)
mAzureState
.
pattern
=
nullptr
;
mAzureState
.
color
=
ToDeviceColor
(
aColor
)
;
}
void
SetPattern
(
gfxPattern
*
pattern
)
{
CURRENTSTATE_CHANGED
(
)
mAzureState
.
patternTransformChanged
=
false
;
mAzureState
.
pattern
=
pattern
;
}
already_AddRefed
<
gfxPattern
>
GetPattern
(
)
const
;
void
Paint
(
Float
alpha
=
1
.
0
)
const
;
void
SetDash
(
const
Float
*
dashes
int
ndash
Float
offset
Float
devPxScale
)
;
bool
CurrentDash
(
FallibleTArray
<
Float
>
&
dashes
Float
*
offset
)
const
;
void
SetLineWidth
(
Float
width
)
{
CURRENTSTATE_CHANGED
(
)
mAzureState
.
strokeOptions
.
mLineWidth
=
width
;
}
Float
CurrentLineWidth
(
)
const
{
return
mAzureState
.
strokeOptions
.
mLineWidth
;
}
void
SetLineCap
(
CapStyle
cap
)
{
CURRENTSTATE_CHANGED
(
)
mAzureState
.
strokeOptions
.
mLineCap
=
cap
;
}
CapStyle
CurrentLineCap
(
)
const
{
return
mAzureState
.
strokeOptions
.
mLineCap
;
}
void
SetLineJoin
(
JoinStyle
join
)
{
CURRENTSTATE_CHANGED
(
)
mAzureState
.
strokeOptions
.
mLineJoin
=
join
;
}
JoinStyle
CurrentLineJoin
(
)
const
{
return
mAzureState
.
strokeOptions
.
mLineJoin
;
}
void
SetMiterLimit
(
Float
limit
)
{
CURRENTSTATE_CHANGED
(
)
mAzureState
.
strokeOptions
.
mMiterLimit
=
limit
;
}
Float
CurrentMiterLimit
(
)
const
{
return
mAzureState
.
strokeOptions
.
mMiterLimit
;
}
void
SetOp
(
CompositionOp
aOp
)
{
CURRENTSTATE_CHANGED
(
)
mAzureState
.
op
=
aOp
;
}
CompositionOp
CurrentOp
(
)
const
{
return
mAzureState
.
op
;
}
void
SetAntialiasMode
(
mozilla
:
:
gfx
:
:
AntialiasMode
aMode
)
{
CURRENTSTATE_CHANGED
(
)
mAzureState
.
aaMode
=
aMode
;
}
mozilla
:
:
gfx
:
:
AntialiasMode
CurrentAntialiasMode
(
)
const
{
return
mAzureState
.
aaMode
;
}
void
Clip
(
)
;
void
Clip
(
const
gfxRect
&
aRect
)
{
Clip
(
ToRect
(
aRect
)
)
;
}
void
Clip
(
const
Rect
&
rect
)
;
void
SnappedClip
(
const
gfxRect
&
rect
)
;
void
Clip
(
Path
*
aPath
)
;
void
PopClip
(
)
{
MOZ_ASSERT
(
!
mAzureState
.
pushedClips
.
IsEmpty
(
)
)
;
mAzureState
.
pushedClips
.
RemoveLastElement
(
)
;
mDT
-
>
PopClip
(
)
;
}
enum
ClipExtentsSpace
{
eUserSpace
=
0
eDeviceSpace
=
1
}
;
gfxRect
GetClipExtents
(
ClipExtentsSpace
aSpace
=
eUserSpace
)
const
;
bool
ExportClip
(
ClipExporter
&
aExporter
)
const
;
void
PushGroupForBlendBack
(
gfxContentType
content
Float
aOpacity
=
1
.
0f
mozilla
:
:
gfx
:
:
SourceSurface
*
aMask
=
nullptr
const
Matrix
&
aMaskTransform
=
Matrix
(
)
)
const
{
mDT
-
>
PushLayer
(
content
=
=
gfxContentType
:
:
COLOR
aOpacity
aMask
aMaskTransform
)
;
}
void
PopGroupAndBlend
(
)
const
{
mDT
-
>
PopLayer
(
)
;
}
Point
GetDeviceOffset
(
)
const
{
return
mAzureState
.
deviceOffset
;
}
void
SetDeviceOffset
(
const
Point
&
aOffset
)
{
mAzureState
.
deviceOffset
=
aOffset
;
}
#
ifdef
MOZ_DUMP_PAINTING
void
WriteAsPNG
(
const
char
*
aFile
)
;
void
DumpAsDataURI
(
)
;
void
CopyAsDataURI
(
)
;
#
endif
private
:
friend
class
PatternFromState
;
friend
class
GlyphBufferAzure
;
typedef
mozilla
:
:
gfx
:
:
sRGBColor
sRGBColor
;
typedef
mozilla
:
:
gfx
:
:
StrokeOptions
StrokeOptions
;
typedef
mozilla
:
:
gfx
:
:
PathBuilder
PathBuilder
;
typedef
mozilla
:
:
gfx
:
:
SourceSurface
SourceSurface
;
struct
AzureState
{
AzureState
(
)
:
op
(
CompositionOp
:
:
OP_OVER
)
color
(
0
0
0
1
.
0f
)
aaMode
(
mozilla
:
:
gfx
:
:
AntialiasMode
:
:
SUBPIXEL
)
patternTransformChanged
(
false
)
#
ifdef
DEBUG
mContentChanged
(
false
)
#
endif
{
}
CompositionOp
op
;
DeviceColor
color
;
RefPtr
<
gfxPattern
>
pattern
;
Matrix
transform
;
struct
PushedClip
{
RefPtr
<
Path
>
path
;
Rect
rect
;
Matrix
transform
;
}
;
CopyableTArray
<
PushedClip
>
pushedClips
;
CopyableTArray
<
Float
>
dashPattern
;
StrokeOptions
strokeOptions
;
mozilla
:
:
gfx
:
:
AntialiasMode
aaMode
;
bool
patternTransformChanged
;
Matrix
patternTransform
;
DeviceColor
fontSmoothingBackgroundColor
;
Point
deviceOffset
;
#
ifdef
DEBUG
bool
mContentChanged
;
#
endif
}
;
void
EnsurePath
(
)
;
void
EnsurePathBuilder
(
)
;
CompositionOp
GetOp
(
)
const
;
void
ChangeTransform
(
const
Matrix
&
aNewMatrix
bool
aUpdatePatternTransform
=
true
)
;
Rect
GetAzureDeviceSpaceClipBounds
(
)
const
;
Matrix
GetDTTransform
(
)
const
{
Matrix
mat
=
mAzureState
.
transform
;
mat
.
PostTranslate
(
-
mAzureState
.
deviceOffset
)
;
return
mat
;
}
bool
mPathIsRect
=
false
;
bool
mTransformChanged
=
false
;
Matrix
mPathTransform
;
Rect
mRect
;
RefPtr
<
PathBuilder
>
mPathBuilder
;
RefPtr
<
Path
>
mPath
;
AzureState
mAzureState
;
nsTArray
<
AzureState
>
mSavedStates
;
template
<
typename
F
>
void
ForAllClips
(
F
&
&
aLambda
)
const
;
const
AzureState
&
CurrentState
(
)
const
{
return
mAzureState
;
}
RefPtr
<
DrawTarget
>
const
mDT
;
float
mCrossProcessPaintScale
=
1
.
0f
;
#
ifdef
DEBUG
#
undef
CURRENTSTATE_CHANGED
#
endif
}
;
class
MOZ_STACK_CLASS
gfxContextAutoSaveRestore
final
{
public
:
gfxContextAutoSaveRestore
(
)
:
mContext
(
nullptr
)
{
}
explicit
gfxContextAutoSaveRestore
(
gfxContext
*
aContext
)
:
mContext
(
aContext
)
{
mContext
-
>
Save
(
)
;
}
~
gfxContextAutoSaveRestore
(
)
{
Restore
(
)
;
}
void
SetContext
(
gfxContext
*
aContext
)
{
MOZ_ASSERT
(
!
mContext
"
no
context
?
"
)
;
mContext
=
aContext
;
mContext
-
>
Save
(
)
;
}
void
EnsureSaved
(
gfxContext
*
aContext
)
{
MOZ_ASSERT
(
!
mContext
|
|
mContext
=
=
aContext
"
wrong
context
"
)
;
if
(
!
mContext
)
{
mContext
=
aContext
;
mContext
-
>
Save
(
)
;
}
}
void
Restore
(
)
{
if
(
mContext
)
{
mContext
-
>
Restore
(
)
;
mContext
=
nullptr
;
}
}
private
:
gfxContext
*
mContext
;
}
;
class
MOZ_STACK_CLASS
gfxContextMatrixAutoSaveRestore
final
{
public
:
gfxContextMatrixAutoSaveRestore
(
)
:
mContext
(
nullptr
)
{
}
explicit
gfxContextMatrixAutoSaveRestore
(
gfxContext
*
aContext
)
:
mContext
(
aContext
)
mMatrix
(
aContext
-
>
CurrentMatrix
(
)
)
{
}
~
gfxContextMatrixAutoSaveRestore
(
)
{
if
(
mContext
)
{
mContext
-
>
SetMatrix
(
mMatrix
)
;
}
}
void
SetContext
(
gfxContext
*
aContext
)
{
NS_ASSERTION
(
!
mContext
"
Not
going
to
restore
the
matrix
on
some
context
!
"
)
;
mContext
=
aContext
;
mMatrix
=
aContext
-
>
CurrentMatrix
(
)
;
}
void
Restore
(
)
{
if
(
mContext
)
{
mContext
-
>
SetMatrix
(
mMatrix
)
;
mContext
=
nullptr
;
}
}
const
mozilla
:
:
gfx
:
:
Matrix
&
Matrix
(
)
{
MOZ_ASSERT
(
mContext
"
mMatrix
doesn
'
t
contain
a
useful
matrix
"
)
;
return
mMatrix
;
}
bool
HasMatrix
(
)
const
{
return
!
!
mContext
;
}
private
:
gfxContext
*
mContext
;
mozilla
:
:
gfx
:
:
Matrix
mMatrix
;
}
;
class
MOZ_STACK_CLASS
gfxGroupForBlendAutoSaveRestore
final
{
public
:
using
Float
=
mozilla
:
:
gfx
:
:
Float
;
using
Matrix
=
mozilla
:
:
gfx
:
:
Matrix
;
explicit
gfxGroupForBlendAutoSaveRestore
(
gfxContext
*
aContext
)
:
mContext
(
aContext
)
{
}
~
gfxGroupForBlendAutoSaveRestore
(
)
{
if
(
mPushedGroup
)
{
mContext
-
>
PopGroupAndBlend
(
)
;
}
}
void
PushGroupForBlendBack
(
gfxContentType
aContent
Float
aOpacity
=
1
.
0f
mozilla
:
:
gfx
:
:
SourceSurface
*
aMask
=
nullptr
const
Matrix
&
aMaskTransform
=
Matrix
(
)
)
{
MOZ_ASSERT
(
!
mPushedGroup
"
Already
called
PushGroupForBlendBack
once
"
)
;
mContext
-
>
PushGroupForBlendBack
(
aContent
aOpacity
aMask
aMaskTransform
)
;
mPushedGroup
=
true
;
}
private
:
gfxContext
*
mContext
;
bool
mPushedGroup
=
false
;
}
;
class
MOZ_STACK_CLASS
gfxClipAutoSaveRestore
final
{
public
:
using
Rect
=
mozilla
:
:
gfx
:
:
Rect
;
explicit
gfxClipAutoSaveRestore
(
gfxContext
*
aContext
)
:
mContext
(
aContext
)
{
}
void
Clip
(
const
gfxRect
&
aRect
)
{
Clip
(
ToRect
(
aRect
)
)
;
}
void
Clip
(
const
Rect
&
aRect
)
{
MOZ_ASSERT
(
!
mClipped
"
Already
called
Clip
once
"
)
;
mContext
-
>
Clip
(
aRect
)
;
mClipped
=
true
;
}
void
TransformedClip
(
const
gfxMatrix
&
aTransform
const
gfxRect
&
aRect
)
{
MOZ_ASSERT
(
!
mClipped
"
Already
called
Clip
once
"
)
;
if
(
aTransform
.
IsSingular
(
)
)
{
return
;
}
gfxContextMatrixAutoSaveRestore
matrixAutoSaveRestore
(
mContext
)
;
mContext
-
>
Multiply
(
aTransform
)
;
mContext
-
>
Clip
(
aRect
)
;
mClipped
=
true
;
}
~
gfxClipAutoSaveRestore
(
)
{
if
(
mClipped
)
{
mContext
-
>
PopClip
(
)
;
}
}
private
:
gfxContext
*
mContext
;
bool
mClipped
=
false
;
}
;
class
MOZ_STACK_CLASS
DrawTargetAutoDisableSubpixelAntialiasing
final
{
public
:
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
DrawTargetAutoDisableSubpixelAntialiasing
(
DrawTarget
*
aDT
bool
aDisable
)
:
mSubpixelAntialiasingEnabled
(
false
)
{
if
(
aDisable
)
{
mDT
=
aDT
;
mSubpixelAntialiasingEnabled
=
mDT
-
>
GetPermitSubpixelAA
(
)
;
mDT
-
>
SetPermitSubpixelAA
(
false
)
;
}
}
~
DrawTargetAutoDisableSubpixelAntialiasing
(
)
{
if
(
mDT
)
{
mDT
-
>
SetPermitSubpixelAA
(
mSubpixelAntialiasingEnabled
)
;
}
}
private
:
RefPtr
<
DrawTarget
>
mDT
;
bool
mSubpixelAntialiasingEnabled
;
}
;
class
ClipExporter
:
public
mozilla
:
:
gfx
:
:
PathSink
{
public
:
virtual
void
BeginClip
(
const
mozilla
:
:
gfx
:
:
Matrix
&
aMatrix
)
=
0
;
virtual
void
EndClip
(
)
=
0
;
}
;
#
endif
