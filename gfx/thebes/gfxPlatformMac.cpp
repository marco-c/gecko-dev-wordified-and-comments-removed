#
include
"
gfxPlatformMac
.
h
"
#
include
"
gfxQuartzSurface
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
gfxMacPlatformFontList
.
h
"
#
include
"
gfxMacFont
.
h
"
#
include
"
gfxCoreTextShaper
.
h
"
#
include
"
gfxTextRun
.
h
"
#
include
"
gfxUserFontSet
.
h
"
#
include
"
gfxConfig
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
VsyncDispatcher
.
h
"
#
include
"
nsCocoaFeatures
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
qcms
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
<
dlfcn
.
h
>
#
include
<
CoreVideo
/
CoreVideo
.
h
>
#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
SurfacePool
.
h
"
#
include
"
VsyncSource
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
unicode
;
using
mozilla
:
:
dom
:
:
SystemFontListEntry
;
enum
{
kAutoActivationDisabled
=
1
}
;
typedef
uint32_t
AutoActivationSetting
;
static
void
DisableFontActivation
(
)
{
CFBundleRef
mainBundle
=
:
:
CFBundleGetMainBundle
(
)
;
CFStringRef
mainBundleID
=
nullptr
;
if
(
mainBundle
)
{
mainBundleID
=
:
:
CFBundleGetIdentifier
(
mainBundle
)
;
}
if
(
!
mainBundleID
)
{
NS_WARNING
(
"
missing
bundle
ID
packaging
set
up
incorrectly
"
)
;
return
;
}
void
(
*
CTFontManagerSetAutoActivationSettingPtr
)
(
CFStringRef
AutoActivationSetting
)
;
CTFontManagerSetAutoActivationSettingPtr
=
(
void
(
*
)
(
CFStringRef
AutoActivationSetting
)
)
dlsym
(
RTLD_DEFAULT
"
CTFontManagerSetAutoActivationSetting
"
)
;
if
(
CTFontManagerSetAutoActivationSettingPtr
)
{
CTFontManagerSetAutoActivationSettingPtr
(
mainBundleID
kAutoActivationDisabled
)
;
}
}
gfxPlatformMac
:
:
gfxPlatformMac
(
)
{
DisableFontActivation
(
)
;
mFontAntiAliasingThreshold
=
ReadAntiAliasingThreshold
(
)
;
InitBackendPrefs
(
GetBackendPrefs
(
)
)
;
if
(
nsCocoaFeatures
:
:
OnHighSierraOrLater
(
)
)
{
mHasNativeColrFontSupport
=
true
;
}
}
gfxPlatformMac
:
:
~
gfxPlatformMac
(
)
{
gfxCoreTextShaper
:
:
Shutdown
(
)
;
}
BackendPrefsData
gfxPlatformMac
:
:
GetBackendPrefs
(
)
const
{
BackendPrefsData
data
;
data
.
mCanvasBitmask
=
BackendTypeBit
(
BackendType
:
:
SKIA
)
;
data
.
mContentBitmask
=
BackendTypeBit
(
BackendType
:
:
SKIA
)
;
data
.
mCanvasDefault
=
BackendType
:
:
SKIA
;
data
.
mContentDefault
=
BackendType
:
:
SKIA
;
return
data
;
}
bool
gfxPlatformMac
:
:
UsesTiling
(
)
const
{
return
true
;
}
bool
gfxPlatformMac
:
:
ContentUsesTiling
(
)
const
{
return
UsesTiling
(
)
;
}
gfxPlatformFontList
*
gfxPlatformMac
:
:
CreatePlatformFontList
(
)
{
gfxPlatformFontList
*
list
=
new
gfxMacPlatformFontList
(
)
;
if
(
NS_SUCCEEDED
(
list
-
>
InitFontList
(
)
)
)
{
return
list
;
}
gfxPlatformFontList
:
:
Shutdown
(
)
;
return
nullptr
;
}
void
gfxPlatformMac
:
:
ReadSystemFontList
(
nsTArray
<
SystemFontListEntry
>
*
aFontList
)
{
gfxMacPlatformFontList
:
:
PlatformFontList
(
)
-
>
ReadSystemFontList
(
aFontList
)
;
}
already_AddRefed
<
gfxASurface
>
gfxPlatformMac
:
:
CreateOffscreenSurface
(
const
IntSize
&
aSize
gfxImageFormat
aFormat
)
{
if
(
!
Factory
:
:
AllowedSurfaceSize
(
aSize
)
)
{
return
nullptr
;
}
RefPtr
<
gfxASurface
>
newSurface
=
new
gfxQuartzSurface
(
aSize
aFormat
)
;
return
newSurface
.
forget
(
)
;
}
bool
gfxPlatformMac
:
:
IsFontFormatSupported
(
uint32_t
aFormatFlags
)
{
if
(
gfxPlatform
:
:
IsFontFormatSupported
(
aFormatFlags
)
)
{
return
true
;
}
if
(
aFormatFlags
&
gfxUserFontSet
:
:
FLAG_FORMAT_TRUETYPE_AAT
)
{
return
true
;
}
return
false
;
}
static
const
char
kFontArialUnicodeMS
[
]
=
"
Arial
Unicode
MS
"
;
static
const
char
kFontAppleBraille
[
]
=
"
Apple
Braille
"
;
static
const
char
kFontAppleColorEmoji
[
]
=
"
Apple
Color
Emoji
"
;
static
const
char
kFontAppleSymbols
[
]
=
"
Apple
Symbols
"
;
static
const
char
kFontDevanagariSangamMN
[
]
=
"
Devanagari
Sangam
MN
"
;
static
const
char
kFontEuphemiaUCAS
[
]
=
"
Euphemia
UCAS
"
;
static
const
char
kFontGeneva
[
]
=
"
Geneva
"
;
static
const
char
kFontGeezaPro
[
]
=
"
Geeza
Pro
"
;
static
const
char
kFontGujaratiSangamMN
[
]
=
"
Gujarati
Sangam
MN
"
;
static
const
char
kFontGurmukhiMN
[
]
=
"
Gurmukhi
MN
"
;
static
const
char
kFontHelvetica
[
]
=
"
Helvetica
"
;
static
const
char
kFontHiraginoKakuGothic
[
]
=
"
Hiragino
Kaku
Gothic
ProN
"
;
static
const
char
kFontHiraginoSansGB
[
]
=
"
Hiragino
Sans
GB
"
;
static
const
char
kFontKefa
[
]
=
"
Kefa
"
;
static
const
char
kFontKhmerMN
[
]
=
"
Khmer
MN
"
;
static
const
char
kFontLaoMN
[
]
=
"
Lao
MN
"
;
static
const
char
kFontLucidaGrande
[
]
=
"
Lucida
Grande
"
;
static
const
char
kFontMenlo
[
]
=
"
Menlo
"
;
static
const
char
kFontMicrosoftTaiLe
[
]
=
"
Microsoft
Tai
Le
"
;
static
const
char
kFontMingLiUExtB
[
]
=
"
MingLiU
-
ExtB
"
;
static
const
char
kFontMyanmarMN
[
]
=
"
Myanmar
MN
"
;
static
const
char
kFontNotoSansMongolian
[
]
=
"
Noto
Sans
Mongolian
"
;
static
const
char
kFontPlantagenetCherokee
[
]
=
"
Plantagenet
Cherokee
"
;
static
const
char
kFontSimSunExtB
[
]
=
"
SimSun
-
ExtB
"
;
static
const
char
kFontSongtiSC
[
]
=
"
Songti
SC
"
;
static
const
char
kFontSTHeiti
[
]
=
"
STHeiti
"
;
static
const
char
kFontSTIXGeneral
[
]
=
"
STIXGeneral
"
;
static
const
char
kFontTamilMN
[
]
=
"
Tamil
MN
"
;
static
const
char
kFontZapfDingbats
[
]
=
"
Zapf
Dingbats
"
;
void
gfxPlatformMac
:
:
GetCommonFallbackFonts
(
uint32_t
aCh
uint32_t
aNextCh
Script
aRunScript
nsTArray
<
const
char
*
>
&
aFontList
)
{
EmojiPresentation
emoji
=
GetEmojiPresentation
(
aCh
)
;
if
(
emoji
!
=
EmojiPresentation
:
:
TextOnly
)
{
if
(
aNextCh
=
=
kVariationSelector16
|
|
(
aNextCh
!
=
kVariationSelector15
&
&
emoji
=
=
EmojiPresentation
:
:
EmojiDefault
)
)
{
aFontList
.
AppendElement
(
kFontAppleColorEmoji
)
;
}
}
aFontList
.
AppendElement
(
kFontLucidaGrande
)
;
if
(
!
IS_IN_BMP
(
aCh
)
)
{
uint32_t
p
=
aCh
>
>
16
;
if
(
p
=
=
1
)
{
aFontList
.
AppendElement
(
kFontAppleSymbols
)
;
aFontList
.
AppendElement
(
kFontSTIXGeneral
)
;
aFontList
.
AppendElement
(
kFontGeneva
)
;
}
else
if
(
p
=
=
2
)
{
aFontList
.
AppendElement
(
kFontMingLiUExtB
)
;
aFontList
.
AppendElement
(
kFontSimSunExtB
)
;
}
}
else
{
uint32_t
b
=
(
aCh
>
>
8
)
&
0xff
;
switch
(
b
)
{
case
0x03
:
case
0x05
:
aFontList
.
AppendElement
(
kFontGeneva
)
;
break
;
case
0x07
:
aFontList
.
AppendElement
(
kFontGeezaPro
)
;
break
;
case
0x09
:
aFontList
.
AppendElement
(
kFontDevanagariSangamMN
)
;
break
;
case
0x0a
:
aFontList
.
AppendElement
(
kFontGurmukhiMN
)
;
aFontList
.
AppendElement
(
kFontGujaratiSangamMN
)
;
break
;
case
0x0b
:
aFontList
.
AppendElement
(
kFontTamilMN
)
;
break
;
case
0x0e
:
aFontList
.
AppendElement
(
kFontLaoMN
)
;
break
;
case
0x0f
:
aFontList
.
AppendElement
(
kFontSongtiSC
)
;
break
;
case
0x10
:
aFontList
.
AppendElement
(
kFontHelvetica
)
;
aFontList
.
AppendElement
(
kFontMenlo
)
;
aFontList
.
AppendElement
(
kFontMyanmarMN
)
;
break
;
case
0x13
:
aFontList
.
AppendElement
(
kFontPlantagenetCherokee
)
;
aFontList
.
AppendElement
(
kFontKefa
)
;
break
;
case
0x14
:
case
0x15
:
case
0x16
:
aFontList
.
AppendElement
(
kFontEuphemiaUCAS
)
;
aFontList
.
AppendElement
(
kFontGeneva
)
;
break
;
case
0x18
:
aFontList
.
AppendElement
(
kFontNotoSansMongolian
)
;
aFontList
.
AppendElement
(
kFontEuphemiaUCAS
)
;
break
;
case
0x19
:
aFontList
.
AppendElement
(
kFontKhmerMN
)
;
aFontList
.
AppendElement
(
kFontMicrosoftTaiLe
)
;
break
;
case
0x1d
:
case
0x1e
:
aFontList
.
AppendElement
(
kFontGeneva
)
;
break
;
case
0x27
:
aFontList
.
AppendElement
(
kFontZapfDingbats
)
;
[
[
fallthrough
]
]
;
case
0x20
:
case
0x21
:
case
0x22
:
case
0x23
:
case
0x24
:
case
0x25
:
case
0x26
:
case
0x29
:
case
0x2a
:
case
0x2b
:
case
0x2e
:
aFontList
.
AppendElement
(
kFontHiraginoKakuGothic
)
;
aFontList
.
AppendElement
(
kFontAppleSymbols
)
;
aFontList
.
AppendElement
(
kFontMenlo
)
;
aFontList
.
AppendElement
(
kFontSTIXGeneral
)
;
aFontList
.
AppendElement
(
kFontGeneva
)
;
aFontList
.
AppendElement
(
kFontAppleColorEmoji
)
;
break
;
case
0x2c
:
aFontList
.
AppendElement
(
kFontGeneva
)
;
break
;
case
0x2d
:
aFontList
.
AppendElement
(
kFontKefa
)
;
aFontList
.
AppendElement
(
kFontGeneva
)
;
break
;
case
0x28
:
aFontList
.
AppendElement
(
kFontAppleBraille
)
;
break
;
case
0x31
:
aFontList
.
AppendElement
(
kFontHiraginoSansGB
)
;
break
;
case
0x4d
:
aFontList
.
AppendElement
(
kFontAppleSymbols
)
;
break
;
case
0xa0
:
case
0xa1
:
case
0xa2
:
case
0xa3
:
case
0xa4
:
aFontList
.
AppendElement
(
kFontSTHeiti
)
;
break
;
case
0xa6
:
case
0xa7
:
aFontList
.
AppendElement
(
kFontGeneva
)
;
aFontList
.
AppendElement
(
kFontAppleSymbols
)
;
break
;
case
0xab
:
aFontList
.
AppendElement
(
kFontKefa
)
;
break
;
case
0xfc
:
case
0xff
:
aFontList
.
AppendElement
(
kFontAppleSymbols
)
;
break
;
default
:
break
;
}
}
aFontList
.
AppendElement
(
kFontArialUnicodeMS
)
;
}
void
gfxPlatformMac
:
:
LookupSystemFont
(
mozilla
:
:
LookAndFeel
:
:
FontID
aSystemFontID
nsACString
&
aSystemFontName
gfxFontStyle
&
aFontStyle
)
{
gfxMacPlatformFontList
*
pfl
=
gfxMacPlatformFontList
:
:
PlatformFontList
(
)
;
return
pfl
-
>
LookupSystemFont
(
aSystemFontID
aSystemFontName
aFontStyle
)
;
}
uint32_t
gfxPlatformMac
:
:
ReadAntiAliasingThreshold
(
)
{
uint32_t
threshold
=
0
;
bool
useAntiAliasingThreshold
=
Preferences
:
:
GetBool
(
"
gfx
.
use_text_smoothing_setting
"
false
)
;
if
(
!
useAntiAliasingThreshold
)
return
threshold
;
CFNumberRef
prefValue
=
(
CFNumberRef
)
CFPreferencesCopyAppValue
(
CFSTR
(
"
AppleAntiAliasingThreshold
"
)
kCFPreferencesCurrentApplication
)
;
if
(
prefValue
)
{
if
(
!
CFNumberGetValue
(
prefValue
kCFNumberIntType
&
threshold
)
)
{
threshold
=
0
;
}
CFRelease
(
prefValue
)
;
}
return
threshold
;
}
bool
gfxPlatformMac
:
:
AccelerateLayersByDefault
(
)
{
return
true
;
}
static
CVReturn
VsyncCallback
(
CVDisplayLinkRef
aDisplayLink
const
CVTimeStamp
*
aNow
const
CVTimeStamp
*
aOutputTime
CVOptionFlags
aFlagsIn
CVOptionFlags
*
aFlagsOut
void
*
aDisplayLinkContext
)
;
class
OSXVsyncSource
final
:
public
VsyncSource
{
public
:
OSXVsyncSource
(
)
{
}
Display
&
GetGlobalDisplay
(
)
override
{
return
mGlobalDisplay
;
}
class
OSXDisplay
final
:
public
VsyncSource
:
:
Display
{
public
:
OSXDisplay
(
)
:
mDisplayLink
(
nullptr
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mTimer
=
NS_NewTimer
(
)
;
}
virtual
~
OSXDisplay
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
static
void
RetryEnableVsync
(
nsITimer
*
aTimer
void
*
aOsxDisplay
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
OSXDisplay
*
osxDisplay
=
static_cast
<
OSXDisplay
*
>
(
aOsxDisplay
)
;
MOZ_ASSERT
(
osxDisplay
)
;
osxDisplay
-
>
EnableVsync
(
)
;
}
void
EnableVsync
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
IsVsyncEnabled
(
)
)
{
return
;
}
CVReturn
retval
=
CVDisplayLinkCreateWithActiveCGDisplays
(
&
mDisplayLink
)
;
if
(
(
retval
=
=
kCVReturnSuccess
)
&
&
(
CVDisplayLinkGetCurrentCGDisplay
(
mDisplayLink
)
=
=
0
)
)
{
retval
=
kCVReturnInvalidDisplay
;
}
if
(
retval
!
=
kCVReturnSuccess
)
{
NS_WARNING
(
"
Could
not
create
a
display
link
with
all
active
displays
.
"
"
Retrying
"
)
;
CVDisplayLinkRelease
(
mDisplayLink
)
;
mDisplayLink
=
nullptr
;
uint32_t
delay
=
100
;
mTimer
-
>
InitWithNamedFuncCallback
(
RetryEnableVsync
this
delay
nsITimer
:
:
TYPE_ONE_SHOT
"
RetryEnableVsync
"
)
;
return
;
}
if
(
CVDisplayLinkSetOutputCallback
(
mDisplayLink
&
VsyncCallback
this
)
!
=
kCVReturnSuccess
)
{
NS_WARNING
(
"
Could
not
set
displaylink
output
callback
"
)
;
CVDisplayLinkRelease
(
mDisplayLink
)
;
mDisplayLink
=
nullptr
;
return
;
}
mPreviousTimestamp
=
TimeStamp
:
:
Now
(
)
;
if
(
CVDisplayLinkStart
(
mDisplayLink
)
!
=
kCVReturnSuccess
)
{
NS_WARNING
(
"
Could
not
activate
the
display
link
"
)
;
CVDisplayLinkRelease
(
mDisplayLink
)
;
mDisplayLink
=
nullptr
;
}
CVTime
vsyncRate
=
CVDisplayLinkGetNominalOutputVideoRefreshPeriod
(
mDisplayLink
)
;
if
(
vsyncRate
.
flags
&
kCVTimeIsIndefinite
)
{
NS_WARNING
(
"
Could
not
get
vsync
rate
setting
to
60
.
"
)
;
mVsyncRate
=
TimeDuration
:
:
FromMilliseconds
(
1000
.
0
/
60
.
0
)
;
}
else
{
int64_t
timeValue
=
vsyncRate
.
timeValue
;
int64_t
timeScale
=
vsyncRate
.
timeScale
;
const
int
milliseconds
=
1000
;
float
rateInMs
=
(
(
double
)
timeValue
/
(
double
)
timeScale
)
*
milliseconds
;
mVsyncRate
=
TimeDuration
:
:
FromMilliseconds
(
rateInMs
)
;
}
}
void
DisableVsync
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
IsVsyncEnabled
(
)
)
{
return
;
}
if
(
mDisplayLink
)
{
CVDisplayLinkRelease
(
mDisplayLink
)
;
mDisplayLink
=
nullptr
;
}
}
bool
IsVsyncEnabled
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mDisplayLink
!
=
nullptr
;
}
TimeDuration
GetVsyncRate
(
)
override
{
return
mVsyncRate
;
}
void
Shutdown
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
DisableVsync
(
)
;
}
TimeStamp
mPreviousTimestamp
;
private
:
CVDisplayLinkRef
mDisplayLink
;
RefPtr
<
nsITimer
>
mTimer
;
TimeDuration
mVsyncRate
;
}
;
private
:
virtual
~
OSXVsyncSource
(
)
=
default
;
OSXDisplay
mGlobalDisplay
;
}
;
static
CVReturn
VsyncCallback
(
CVDisplayLinkRef
aDisplayLink
const
CVTimeStamp
*
aNow
const
CVTimeStamp
*
aOutputTime
CVOptionFlags
aFlagsIn
CVOptionFlags
*
aFlagsOut
void
*
aDisplayLinkContext
)
{
OSXVsyncSource
:
:
OSXDisplay
*
display
=
(
OSXVsyncSource
:
:
OSXDisplay
*
)
aDisplayLinkContext
;
int64_t
nextVsyncTimestamp
=
aOutputTime
-
>
hostTime
;
mozilla
:
:
TimeStamp
nextVsync
=
mozilla
:
:
TimeStamp
:
:
FromSystemTime
(
nextVsyncTimestamp
)
;
mozilla
:
:
TimeStamp
previousVsync
=
display
-
>
mPreviousTimestamp
;
mozilla
:
:
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
nextVsync
<
=
previousVsync
)
{
nextVsync
=
now
;
previousVsync
=
now
;
}
else
if
(
now
<
previousVsync
)
{
previousVsync
=
now
;
}
display
-
>
mPreviousTimestamp
=
nextVsync
;
display
-
>
NotifyVsync
(
previousVsync
)
;
return
kCVReturnSuccess
;
}
already_AddRefed
<
mozilla
:
:
gfx
:
:
VsyncSource
>
gfxPlatformMac
:
:
CreateHardwareVsyncSource
(
)
{
RefPtr
<
VsyncSource
>
osxVsyncSource
=
new
OSXVsyncSource
(
)
;
VsyncSource
:
:
Display
&
primaryDisplay
=
osxVsyncSource
-
>
GetGlobalDisplay
(
)
;
primaryDisplay
.
EnableVsync
(
)
;
if
(
!
primaryDisplay
.
IsVsyncEnabled
(
)
)
{
NS_WARNING
(
"
OS
X
Vsync
source
not
enabled
.
Falling
back
to
software
vsync
.
"
)
;
return
gfxPlatform
:
:
CreateHardwareVsyncSource
(
)
;
}
primaryDisplay
.
DisableVsync
(
)
;
return
osxVsyncSource
.
forget
(
)
;
}
nsTArray
<
uint8_t
>
gfxPlatformMac
:
:
GetPlatformCMSOutputProfileData
(
)
{
nsTArray
<
uint8_t
>
prefProfileData
=
GetPrefCMSOutputProfileData
(
)
;
if
(
!
prefProfileData
.
IsEmpty
(
)
)
{
return
prefProfileData
;
}
CGColorSpaceRef
cspace
=
:
:
CGDisplayCopyColorSpace
(
:
:
CGMainDisplayID
(
)
)
;
if
(
!
cspace
)
{
cspace
=
:
:
CGColorSpaceCreateDeviceRGB
(
)
;
}
if
(
!
cspace
)
{
return
nsTArray
<
uint8_t
>
(
)
;
}
CFDataRef
iccp
=
:
:
CGColorSpaceCopyICCProfile
(
cspace
)
;
:
:
CFRelease
(
cspace
)
;
if
(
!
iccp
)
{
return
nsTArray
<
uint8_t
>
(
)
;
}
size_t
size
=
static_cast
<
size_t
>
(
:
:
CFDataGetLength
(
iccp
)
)
;
nsTArray
<
uint8_t
>
result
;
if
(
size
>
0
)
{
result
.
AppendElements
(
:
:
CFDataGetBytePtr
(
iccp
)
size
)
;
}
:
:
CFRelease
(
iccp
)
;
return
result
;
}
bool
gfxPlatformMac
:
:
CheckVariationFontSupport
(
)
{
return
nsCocoaFeatures
:
:
OnHighSierraOrLater
(
)
;
}
void
gfxPlatformMac
:
:
InitPlatformGPUProcessPrefs
(
)
{
FeatureState
&
gpuProc
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
GPU_PROCESS
)
;
gpuProc
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
GPU
process
does
not
work
on
Mac
"
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_MAC_GPU_PROC
"
)
)
;
}
