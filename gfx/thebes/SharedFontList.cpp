#
include
"
SharedFontList
-
impl
.
h
"
#
include
"
gfxPlatformFontList
.
h
"
#
include
"
gfxFontUtils
.
h
"
#
include
"
gfxFont
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
prerror
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
define
LOG_FONTLIST
(
args
)
\
MOZ_LOG
(
gfxPlatform
:
:
GetLog
(
eGfxLog_fontlist
)
LogLevel
:
:
Debug
args
)
#
define
LOG_FONTLIST_ENABLED
(
)
\
MOZ_LOG_TEST
(
gfxPlatform
:
:
GetLog
(
eGfxLog_fontlist
)
LogLevel
:
:
Debug
)
namespace
mozilla
{
namespace
fontlist
{
static
double
WSSDistance
(
const
Face
*
aFace
const
gfxFontStyle
&
aStyle
)
{
double
stretchDist
=
StretchDistance
(
aFace
-
>
mStretch
aStyle
.
stretch
)
;
double
styleDist
=
StyleDistance
(
aFace
-
>
mStyle
aStyle
.
style
)
;
double
weightDist
=
WeightDistance
(
aFace
-
>
mWeight
aStyle
.
weight
)
;
MOZ_ASSERT
(
stretchDist
>
=
0
.
0
&
&
stretchDist
<
=
2000
.
0
)
;
MOZ_ASSERT
(
styleDist
>
=
0
.
0
&
&
styleDist
<
=
500
.
0
)
;
MOZ_ASSERT
(
weightDist
>
=
0
.
0
&
&
weightDist
<
=
1600
.
0
)
;
return
stretchDist
*
kStretchFactor
+
styleDist
*
kStyleFactor
+
weightDist
*
kWeightFactor
;
}
void
*
Pointer
:
:
ToPtr
(
FontList
*
aFontList
size_t
aSize
)
const
MOZ_NO_THREAD_SAFETY_ANALYSIS
{
void
*
result
=
nullptr
;
if
(
IsNull
(
)
)
{
return
result
;
}
bool
isMainThread
=
NS_IsMainThread
(
)
;
if
(
!
isMainThread
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
Lock
(
)
;
}
uint32_t
blockIndex
=
Block
(
)
;
auto
&
blocks
=
aFontList
-
>
mBlocks
;
if
(
blockIndex
>
=
blocks
.
Length
(
)
)
{
if
(
MOZ_UNLIKELY
(
XRE_IsParentProcess
(
)
)
)
{
goto
cleanup
;
}
if
(
!
isMainThread
)
{
goto
cleanup
;
}
if
(
MOZ_UNLIKELY
(
!
aFontList
-
>
UpdateShmBlocks
(
true
)
)
)
{
goto
cleanup
;
}
MOZ_ASSERT
(
blockIndex
<
blocks
.
Length
(
)
"
failure
in
UpdateShmBlocks
?
"
)
;
if
(
MOZ_UNLIKELY
(
blockIndex
>
=
blocks
.
Length
(
)
)
)
{
goto
cleanup
;
}
}
{
const
auto
&
block
=
blocks
[
blockIndex
]
;
if
(
MOZ_LIKELY
(
Offset
(
)
+
aSize
<
=
block
-
>
Allocated
(
)
)
)
{
result
=
static_cast
<
char
*
>
(
block
-
>
Memory
(
)
)
+
Offset
(
)
;
}
}
cleanup
:
if
(
!
isMainThread
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
Unlock
(
)
;
}
return
result
;
}
void
String
:
:
Assign
(
const
nsACString
&
aString
FontList
*
aList
)
{
MOZ_ASSERT
(
mPointer
.
IsNull
(
)
)
;
mLength
=
aString
.
Length
(
)
;
mPointer
=
aList
-
>
Alloc
(
mLength
+
1
)
;
auto
*
p
=
mPointer
.
ToArray
<
char
>
(
aList
mLength
)
;
std
:
:
memcpy
(
p
aString
.
BeginReading
(
)
mLength
)
;
p
[
mLength
]
=
'
\
0
'
;
}
Family
:
:
Family
(
FontList
*
aList
const
InitData
&
aData
)
:
mFaceCount
(
0
)
mKey
(
aList
aData
.
mKey
)
mName
(
aList
aData
.
mName
)
mCharacterMap
(
Pointer
:
:
Null
(
)
)
mFaces
(
Pointer
:
:
Null
(
)
)
mIndex
(
aData
.
mIndex
)
mVisibility
(
aData
.
mVisibility
)
mIsSimple
(
false
)
mIsBundled
(
aData
.
mBundled
)
mIsBadUnderlineFamily
(
aData
.
mBadUnderline
)
mIsForceClassic
(
aData
.
mForceClassic
)
mIsAltLocale
(
aData
.
mAltLocale
)
{
}
class
SetCharMapRunnable
:
public
mozilla
:
:
Runnable
{
public
:
SetCharMapRunnable
(
uint32_t
aListGeneration
std
:
:
pair
<
uint32_t
bool
>
aFamilyIndex
uint32_t
aFaceIndex
gfxCharacterMap
*
aCharMap
)
:
Runnable
(
"
SetCharMapRunnable
"
)
mListGeneration
(
aListGeneration
)
mFamilyIndex
(
aFamilyIndex
)
mFaceIndex
(
aFaceIndex
)
mCharMap
(
aCharMap
)
{
}
NS_IMETHOD
Run
(
)
override
{
auto
*
list
=
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
SharedFontList
(
)
;
if
(
!
list
|
|
list
-
>
GetGeneration
(
)
!
=
mListGeneration
)
{
return
NS_OK
;
}
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendSetCharacterMap
(
mListGeneration
mFamilyIndex
.
first
mFamilyIndex
.
second
mFaceIndex
*
mCharMap
)
;
return
NS_OK
;
}
private
:
uint32_t
mListGeneration
;
std
:
:
pair
<
uint32_t
bool
>
mFamilyIndex
;
uint32_t
mFaceIndex
;
RefPtr
<
gfxCharacterMap
>
mCharMap
;
}
;
void
Face
:
:
SetCharacterMap
(
FontList
*
aList
gfxCharacterMap
*
aCharMap
const
Family
*
aFamily
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
Maybe
<
std
:
:
pair
<
uint32_t
bool
>
>
familyIndex
=
aFamily
-
>
FindIndex
(
aList
)
;
if
(
!
familyIndex
)
{
NS_WARNING
(
"
Family
index
not
found
!
Ignoring
SetCharacterMap
"
)
;
return
;
}
const
auto
*
faces
=
aFamily
-
>
Faces
(
aList
)
;
uint32_t
faceIndex
=
0
;
while
(
faceIndex
<
aFamily
-
>
NumFaces
(
)
)
{
if
(
faces
[
faceIndex
]
.
ToPtr
<
Face
>
(
aList
)
=
=
this
)
{
break
;
}
+
+
faceIndex
;
}
if
(
faceIndex
>
=
aFamily
-
>
NumFaces
(
)
)
{
NS_WARNING
(
"
Face
not
found
in
family
!
Ignoring
SetCharacterMap
"
)
;
return
;
}
if
(
NS_IsMainThread
(
)
)
{
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendSetCharacterMap
(
aList
-
>
GetGeneration
(
)
familyIndex
-
>
first
familyIndex
-
>
second
faceIndex
*
aCharMap
)
;
}
else
{
NS_DispatchToMainThread
(
new
SetCharMapRunnable
(
aList
-
>
GetGeneration
(
)
familyIndex
.
value
(
)
faceIndex
aCharMap
)
)
;
}
return
;
}
auto
pfl
=
gfxPlatformFontList
:
:
PlatformFontList
(
)
;
mCharacterMap
=
pfl
-
>
GetShmemCharMap
(
aCharMap
)
;
}
void
Family
:
:
AddFaces
(
FontList
*
aList
const
nsTArray
<
Face
:
:
InitData
>
&
aFaces
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
mFaceCount
>
0
)
{
return
;
}
uint32_t
count
=
aFaces
.
Length
(
)
;
bool
isSimple
=
false
;
const
Face
:
:
InitData
*
slots
[
4
]
=
{
nullptr
nullptr
nullptr
nullptr
}
;
if
(
count
>
=
2
&
&
count
<
=
4
)
{
isSimple
=
true
;
for
(
const
auto
&
f
:
aFaces
)
{
if
(
!
f
.
mWeight
.
IsSingle
(
)
|
|
!
f
.
mStretch
.
IsSingle
(
)
|
|
!
f
.
mStyle
.
IsSingle
(
)
)
{
isSimple
=
false
;
break
;
}
if
(
!
f
.
mStretch
.
Min
(
)
.
IsNormal
(
)
)
{
isSimple
=
false
;
break
;
}
size_t
slot
=
0
;
static_assert
(
(
kBoldMask
|
kItalicMask
)
=
=
0b11
"
bad
bold
/
italic
bits
"
)
;
if
(
f
.
mWeight
.
Min
(
)
.
IsBold
(
)
)
{
slot
|
=
kBoldMask
;
}
if
(
f
.
mStyle
.
Min
(
)
.
IsItalic
(
)
|
|
f
.
mStyle
.
Min
(
)
.
IsOblique
(
)
)
{
slot
|
=
kItalicMask
;
}
if
(
slots
[
slot
]
)
{
isSimple
=
false
;
break
;
}
slots
[
slot
]
=
&
f
;
}
if
(
isSimple
)
{
count
=
4
;
}
}
Pointer
p
=
aList
-
>
Alloc
(
count
*
sizeof
(
Pointer
)
)
;
auto
*
facePtrs
=
p
.
ToArray
<
Pointer
>
(
aList
count
)
;
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
isSimple
&
&
!
slots
[
i
]
)
{
facePtrs
[
i
]
=
Pointer
:
:
Null
(
)
;
}
else
{
const
auto
*
initData
=
isSimple
?
slots
[
i
]
:
&
aFaces
[
i
]
;
Pointer
fp
=
aList
-
>
Alloc
(
sizeof
(
Face
)
)
;
auto
*
face
=
fp
.
ToPtr
<
Face
>
(
aList
)
;
(
void
)
new
(
face
)
Face
(
aList
*
initData
)
;
facePtrs
[
i
]
=
fp
;
if
(
initData
-
>
mCharMap
)
{
face
-
>
SetCharacterMap
(
aList
initData
-
>
mCharMap
this
)
;
}
}
}
mIsSimple
=
isSimple
;
mFaces
=
p
;
mFaceCount
.
store
(
count
)
;
if
(
LOG_FONTLIST_ENABLED
(
)
)
{
const
nsCString
&
fam
=
DisplayName
(
)
.
AsString
(
aList
)
;
for
(
unsigned
j
=
0
;
j
<
aFaces
.
Length
(
)
;
j
+
+
)
{
nsAutoCString
weight
style
stretch
;
aFaces
[
j
]
.
mWeight
.
ToString
(
weight
)
;
aFaces
[
j
]
.
mStyle
.
ToString
(
style
)
;
aFaces
[
j
]
.
mStretch
.
ToString
(
stretch
)
;
LOG_FONTLIST
(
(
"
(
shared
-
fontlist
)
family
(
%
s
)
added
face
(
%
s
)
index
%
u
weight
"
"
%
s
style
%
s
stretch
%
s
"
fam
.
get
(
)
aFaces
[
j
]
.
mDescriptor
.
get
(
)
aFaces
[
j
]
.
mIndex
weight
.
get
(
)
style
.
get
(
)
stretch
.
get
(
)
)
)
;
}
}
}
bool
Family
:
:
FindAllFacesForStyleInternal
(
FontList
*
aList
const
gfxFontStyle
&
aStyle
nsTArray
<
Face
*
>
&
aFaceList
)
const
{
MOZ_ASSERT
(
aFaceList
.
IsEmpty
(
)
)
;
if
(
!
IsInitialized
(
)
)
{
return
false
;
}
Pointer
*
facePtrs
=
Faces
(
aList
)
;
if
(
!
facePtrs
)
{
return
false
;
}
if
(
NumFaces
(
)
=
=
1
)
{
MOZ_ASSERT
(
!
facePtrs
[
0
]
.
IsNull
(
)
)
;
auto
*
face
=
facePtrs
[
0
]
.
ToPtr
<
Face
>
(
aList
)
;
if
(
face
&
&
face
-
>
HasValidDescriptor
(
)
)
{
aFaceList
.
AppendElement
(
face
)
;
#
ifdef
MOZ_WIDGET_GTK
if
(
face
-
>
mSize
)
{
return
true
;
}
#
endif
}
return
false
;
}
if
(
mIsSimple
)
{
bool
wantBold
=
aStyle
.
weight
.
IsBold
(
)
;
bool
wantItalic
=
!
aStyle
.
style
.
IsNormal
(
)
;
uint8_t
faceIndex
=
(
wantItalic
?
kItalicMask
:
0
)
|
(
wantBold
?
kBoldMask
:
0
)
;
auto
*
face
=
facePtrs
[
faceIndex
]
.
ToPtr
<
Face
>
(
aList
)
;
if
(
face
&
&
face
-
>
HasValidDescriptor
(
)
)
{
aFaceList
.
AppendElement
(
face
)
;
#
ifdef
MOZ_WIDGET_GTK
if
(
face
-
>
mSize
)
{
return
true
;
}
#
endif
return
false
;
}
static
const
uint8_t
simpleFallbacks
[
4
]
[
3
]
=
{
{
kBoldFaceIndex
kItalicFaceIndex
kBoldItalicFaceIndex
}
{
kRegularFaceIndex
kBoldItalicFaceIndex
kItalicFaceIndex
}
{
kBoldItalicFaceIndex
kRegularFaceIndex
kBoldFaceIndex
}
{
kItalicFaceIndex
kBoldFaceIndex
kRegularFaceIndex
}
}
;
const
uint8_t
*
order
=
simpleFallbacks
[
faceIndex
]
;
for
(
uint8_t
trial
=
0
;
trial
<
3
;
+
+
trial
)
{
face
=
facePtrs
[
order
[
trial
]
]
.
ToPtr
<
Face
>
(
aList
)
;
if
(
face
&
&
face
-
>
HasValidDescriptor
(
)
)
{
aFaceList
.
AppendElement
(
face
)
;
#
ifdef
MOZ_WIDGET_GTK
if
(
face
-
>
mSize
)
{
return
true
;
}
#
endif
return
false
;
}
}
return
false
;
}
double
minDistance
=
INFINITY
;
Face
*
matched
=
nullptr
;
bool
anyNonScalable
=
false
;
for
(
uint32_t
i
=
0
;
i
<
NumFaces
(
)
;
i
+
+
)
{
auto
*
face
=
facePtrs
[
i
]
.
ToPtr
<
Face
>
(
aList
)
;
if
(
face
)
{
double
distance
=
WSSDistance
(
face
aStyle
)
;
if
(
distance
<
minDistance
)
{
matched
=
face
;
if
(
!
aFaceList
.
IsEmpty
(
)
)
{
aFaceList
.
Clear
(
)
;
}
minDistance
=
distance
;
}
else
if
(
distance
=
=
minDistance
)
{
if
(
matched
)
{
aFaceList
.
AppendElement
(
matched
)
;
#
ifdef
MOZ_WIDGET_GTK
if
(
matched
-
>
mSize
)
{
anyNonScalable
=
true
;
}
#
endif
}
matched
=
face
;
}
}
}
MOZ_ASSERT
(
matched
"
didn
'
t
match
a
font
within
a
family
"
)
;
if
(
matched
)
{
aFaceList
.
AppendElement
(
matched
)
;
#
ifdef
MOZ_WIDGET_GTK
if
(
matched
-
>
mSize
)
{
anyNonScalable
=
true
;
}
#
endif
}
return
anyNonScalable
;
}
void
Family
:
:
FindAllFacesForStyle
(
FontList
*
aList
const
gfxFontStyle
&
aStyle
nsTArray
<
Face
*
>
&
aFaceList
bool
aIgnoreSizeTolerance
)
const
{
#
ifdef
MOZ_WIDGET_GTK
bool
anyNonScalable
=
#
else
Unused
<
<
#
endif
FindAllFacesForStyleInternal
(
aList
aStyle
aFaceList
)
;
#
ifdef
MOZ_WIDGET_GTK
if
(
anyNonScalable
)
{
uint16_t
best
=
0
;
gfxFloat
dist
=
0
.
0
;
for
(
const
auto
&
f
:
aFaceList
)
{
if
(
f
-
>
mSize
=
=
0
)
{
continue
;
}
gfxFloat
d
=
fabs
(
gfxFloat
(
f
-
>
mSize
)
-
aStyle
.
size
)
;
if
(
!
aIgnoreSizeTolerance
&
&
(
d
*
5
.
0
>
f
-
>
mSize
)
)
{
continue
;
}
if
(
!
best
|
|
d
<
dist
)
{
best
=
f
-
>
mSize
;
dist
=
d
;
}
}
aFaceList
.
RemoveElementsBy
(
[
=
]
(
const
auto
&
e
)
{
return
e
-
>
mSize
!
=
best
;
}
)
;
}
#
endif
}
Face
*
Family
:
:
FindFaceForStyle
(
FontList
*
aList
const
gfxFontStyle
&
aStyle
bool
aIgnoreSizeTolerance
)
const
{
AutoTArray
<
Face
*
4
>
faces
;
FindAllFacesForStyle
(
aList
aStyle
faces
aIgnoreSizeTolerance
)
;
return
faces
.
IsEmpty
(
)
?
nullptr
:
faces
[
0
]
;
}
void
Family
:
:
SearchAllFontsForChar
(
FontList
*
aList
GlobalFontMatch
*
aMatchData
)
{
auto
*
charmap
=
mCharacterMap
.
ToPtr
<
const
SharedBitSet
>
(
aList
)
;
if
(
!
charmap
)
{
if
(
!
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
InitializeFamily
(
this
true
)
)
{
return
;
}
charmap
=
mCharacterMap
.
ToPtr
<
const
SharedBitSet
>
(
aList
)
;
}
if
(
charmap
&
&
!
charmap
-
>
test
(
aMatchData
-
>
mCh
)
)
{
return
;
}
uint32_t
numFaces
=
NumFaces
(
)
;
uint32_t
charMapsLoaded
=
0
;
Pointer
*
facePtrs
=
Faces
(
aList
)
;
if
(
!
facePtrs
)
{
return
;
}
for
(
uint32_t
i
=
0
;
i
<
numFaces
;
i
+
+
)
{
auto
*
face
=
facePtrs
[
i
]
.
ToPtr
<
Face
>
(
aList
)
;
if
(
!
face
)
{
continue
;
}
MOZ_ASSERT
(
face
-
>
HasValidDescriptor
(
)
)
;
charmap
=
face
-
>
mCharacterMap
.
ToPtr
<
const
SharedBitSet
>
(
aList
)
;
if
(
charmap
)
{
+
+
charMapsLoaded
;
}
if
(
!
charmap
|
|
charmap
-
>
test
(
aMatchData
-
>
mCh
)
)
{
double
distance
=
WSSDistance
(
face
aMatchData
-
>
mStyle
)
;
if
(
distance
<
aMatchData
-
>
mMatchDistance
)
{
RefPtr
<
gfxFontEntry
>
fe
=
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
GetOrCreateFontEntry
(
face
this
)
;
if
(
!
fe
)
{
continue
;
}
if
(
!
charmap
&
&
!
fe
-
>
HasCharacter
(
aMatchData
-
>
mCh
)
)
{
continue
;
}
if
(
aMatchData
-
>
mPresentation
!
=
eFontPresentation
:
:
Any
)
{
RefPtr
<
gfxFont
>
font
=
fe
-
>
FindOrMakeFont
(
&
aMatchData
-
>
mStyle
)
;
if
(
!
font
)
{
continue
;
}
bool
hasColorGlyph
=
font
-
>
HasColorGlyphFor
(
aMatchData
-
>
mCh
aMatchData
-
>
mNextCh
)
;
if
(
hasColorGlyph
!
=
PrefersColor
(
aMatchData
-
>
mPresentation
)
)
{
distance
+
=
kPresentationMismatch
;
if
(
distance
>
=
aMatchData
-
>
mMatchDistance
)
{
continue
;
}
}
}
aMatchData
-
>
mBestMatch
=
fe
;
aMatchData
-
>
mMatchDistance
=
distance
;
aMatchData
-
>
mMatchedSharedFamily
=
this
;
}
}
}
if
(
mCharacterMap
.
IsNull
(
)
&
&
charMapsLoaded
=
=
numFaces
)
{
SetupFamilyCharMap
(
aList
)
;
}
}
void
Family
:
:
SetFacePtrs
(
FontList
*
aList
nsTArray
<
Pointer
>
&
aFaces
)
{
if
(
aFaces
.
Length
(
)
>
=
2
&
&
aFaces
.
Length
(
)
<
=
4
)
{
bool
isSimple
=
true
;
Pointer
slots
[
4
]
=
{
Pointer
:
:
Null
(
)
Pointer
:
:
Null
(
)
Pointer
:
:
Null
(
)
Pointer
:
:
Null
(
)
}
;
for
(
const
Pointer
&
fp
:
aFaces
)
{
auto
*
f
=
fp
.
ToPtr
<
const
Face
>
(
aList
)
;
if
(
!
f
-
>
mWeight
.
IsSingle
(
)
|
|
!
f
-
>
mStyle
.
IsSingle
(
)
|
|
!
f
-
>
mStretch
.
IsSingle
(
)
)
{
isSimple
=
false
;
break
;
}
if
(
!
f
-
>
mStretch
.
Min
(
)
.
IsNormal
(
)
)
{
isSimple
=
false
;
break
;
}
size_t
slot
=
0
;
if
(
f
-
>
mWeight
.
Min
(
)
.
IsBold
(
)
)
{
slot
|
=
kBoldMask
;
}
if
(
f
-
>
mStyle
.
Min
(
)
.
IsItalic
(
)
|
|
f
-
>
mStyle
.
Min
(
)
.
IsOblique
(
)
)
{
slot
|
=
kItalicMask
;
}
if
(
!
slots
[
slot
]
.
IsNull
(
)
)
{
isSimple
=
false
;
break
;
}
slots
[
slot
]
=
fp
;
}
if
(
isSimple
)
{
size_t
size
=
4
*
sizeof
(
Pointer
)
;
mFaces
=
aList
-
>
Alloc
(
size
)
;
memcpy
(
mFaces
.
ToPtr
(
aList
size
)
slots
size
)
;
mFaceCount
.
store
(
4
)
;
mIsSimple
=
true
;
return
;
}
}
size_t
size
=
aFaces
.
Length
(
)
*
sizeof
(
Pointer
)
;
mFaces
=
aList
-
>
Alloc
(
size
)
;
memcpy
(
mFaces
.
ToPtr
(
aList
size
)
aFaces
.
Elements
(
)
size
)
;
mFaceCount
.
store
(
aFaces
.
Length
(
)
)
;
}
void
Family
:
:
SetupFamilyCharMap
(
FontList
*
aList
)
{
if
(
!
mCharacterMap
.
IsNull
(
)
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
Maybe
<
std
:
:
pair
<
uint32_t
bool
>
>
index
=
FindIndex
(
aList
)
;
if
(
!
index
)
{
NS_WARNING
(
"
Family
index
not
found
!
Ignoring
SetupFamilyCharMap
"
)
;
return
;
}
if
(
NS_IsMainThread
(
)
)
{
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendSetupFamilyCharMap
(
aList
-
>
GetGeneration
(
)
index
-
>
first
index
-
>
second
)
;
return
;
}
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
SetupFamilyCharMap
callback
"
[
gen
=
aList
-
>
GetGeneration
(
)
idx
=
index
-
>
first
alias
=
index
-
>
second
]
{
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendSetupFamilyCharMap
(
gen
idx
alias
)
;
}
)
)
;
return
;
}
gfxSparseBitSet
familyMap
;
Pointer
firstMapShmPointer
;
const
SharedBitSet
*
firstMap
=
nullptr
;
bool
merged
=
false
;
Pointer
*
faces
=
Faces
(
aList
)
;
if
(
!
faces
)
{
return
;
}
for
(
size_t
i
=
0
;
i
<
NumFaces
(
)
;
i
+
+
)
{
auto
*
f
=
faces
[
i
]
.
ToPtr
<
const
Face
>
(
aList
)
;
if
(
!
f
)
{
continue
;
}
auto
*
faceMap
=
f
-
>
mCharacterMap
.
ToPtr
<
const
SharedBitSet
>
(
aList
)
;
if
(
!
faceMap
)
{
continue
;
}
if
(
!
firstMap
)
{
firstMap
=
faceMap
;
firstMapShmPointer
=
f
-
>
mCharacterMap
;
}
else
if
(
faceMap
!
=
firstMap
)
{
if
(
!
merged
)
{
familyMap
.
Union
(
*
firstMap
)
;
merged
=
true
;
}
familyMap
.
Union
(
*
faceMap
)
;
}
}
if
(
merged
|
|
firstMapShmPointer
.
IsNull
(
)
)
{
mCharacterMap
=
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
GetShmemCharMap
(
&
familyMap
)
;
}
else
{
mCharacterMap
=
firstMapShmPointer
;
}
}
Maybe
<
std
:
:
pair
<
uint32_t
bool
>
>
Family
:
:
FindIndex
(
FontList
*
aList
)
const
{
const
auto
*
start
=
aList
-
>
Families
(
)
;
const
auto
*
end
=
start
+
aList
-
>
NumFamilies
(
)
;
if
(
this
>
=
start
&
&
this
<
end
)
{
uint32_t
index
=
this
-
start
;
MOZ_RELEASE_ASSERT
(
start
+
index
=
=
this
"
misaligned
Family
ptr
!
"
)
;
return
Some
(
std
:
:
pair
(
index
false
)
)
;
}
start
=
aList
-
>
AliasFamilies
(
)
;
end
=
start
+
aList
-
>
NumAliases
(
)
;
if
(
this
>
=
start
&
&
this
<
end
)
{
uint32_t
index
=
this
-
start
;
MOZ_RELEASE_ASSERT
(
start
+
index
=
=
this
"
misaligned
AliasFamily
ptr
!
"
)
;
return
Some
(
std
:
:
pair
(
index
true
)
)
;
}
return
Nothing
(
)
;
}
FontList
:
:
FontList
(
uint32_t
aGeneration
)
{
if
(
XRE_IsParentProcess
(
)
)
{
if
(
AppendShmBlock
(
SHM_BLOCK_SIZE
)
)
{
Header
&
header
=
GetHeader
(
)
;
header
.
mBlockHeader
.
mAllocated
.
store
(
sizeof
(
Header
)
)
;
header
.
mGeneration
=
aGeneration
;
header
.
mFamilyCount
=
0
;
header
.
mBlockCount
.
store
(
1
)
;
header
.
mAliasCount
.
store
(
0
)
;
header
.
mLocalFaceCount
.
store
(
0
)
;
header
.
mFamilies
=
Pointer
:
:
Null
(
)
;
header
.
mAliases
=
Pointer
:
:
Null
(
)
;
header
.
mLocalFaces
=
Pointer
:
:
Null
(
)
;
}
else
{
MOZ_CRASH
(
"
parent
:
failed
to
initialize
FontList
"
)
;
}
}
else
{
auto
&
blocks
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SharedFontListBlocks
(
)
;
for
(
auto
&
handle
:
blocks
)
{
auto
newShm
=
MakeUnique
<
base
:
:
SharedMemory
>
(
)
;
if
(
!
newShm
-
>
IsHandleValid
(
handle
)
)
{
break
;
}
if
(
!
newShm
-
>
SetHandle
(
std
:
:
move
(
handle
)
true
)
)
{
MOZ_CRASH
(
"
failed
to
set
shm
handle
"
)
;
}
if
(
!
newShm
-
>
Map
(
SHM_BLOCK_SIZE
)
|
|
!
newShm
-
>
memory
(
)
)
{
MOZ_CRASH
(
"
failed
to
map
shared
memory
"
)
;
}
uint32_t
size
=
static_cast
<
BlockHeader
*
>
(
newShm
-
>
memory
(
)
)
-
>
mBlockSize
;
MOZ_ASSERT
(
size
>
=
SHM_BLOCK_SIZE
)
;
if
(
size
!
=
SHM_BLOCK_SIZE
)
{
newShm
-
>
Unmap
(
)
;
if
(
!
newShm
-
>
Map
(
size
)
|
|
!
newShm
-
>
memory
(
)
)
{
MOZ_CRASH
(
"
failed
to
map
shared
memory
"
)
;
}
}
mBlocks
.
AppendElement
(
new
ShmBlock
(
std
:
:
move
(
newShm
)
)
)
;
}
blocks
.
Clear
(
)
;
for
(
unsigned
retryCount
=
0
;
retryCount
<
3
;
+
+
retryCount
)
{
if
(
UpdateShmBlocks
(
false
)
)
{
return
;
}
DetachShmBlocks
(
)
;
}
NS_WARNING
(
"
child
:
failed
to
initialize
shared
FontList
"
)
;
}
}
FontList
:
:
~
FontList
(
)
{
DetachShmBlocks
(
)
;
}
FontList
:
:
Header
&
FontList
:
:
GetHeader
(
)
const
MOZ_NO_THREAD_SAFETY_ANALYSIS
{
bool
isMainThread
=
NS_IsMainThread
(
)
;
if
(
!
isMainThread
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
Lock
(
)
;
}
MOZ_ASSERT
(
mBlocks
.
Length
(
)
>
0
)
;
auto
&
result
=
*
static_cast
<
Header
*
>
(
mBlocks
[
0
]
-
>
Memory
(
)
)
;
if
(
!
isMainThread
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
Unlock
(
)
;
}
return
result
;
}
bool
FontList
:
:
AppendShmBlock
(
uint32_t
aSizeNeeded
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
uint32_t
size
=
std
:
:
max
(
aSizeNeeded
SHM_BLOCK_SIZE
)
;
auto
newShm
=
MakeUnique
<
base
:
:
SharedMemory
>
(
)
;
if
(
!
newShm
-
>
CreateFreezeable
(
size
)
)
{
MOZ_CRASH
(
"
failed
to
create
shared
memory
"
)
;
return
false
;
}
if
(
!
newShm
-
>
Map
(
size
)
|
|
!
newShm
-
>
memory
(
)
)
{
MOZ_CRASH
(
"
failed
to
map
shared
memory
"
)
;
return
false
;
}
auto
readOnly
=
MakeUnique
<
base
:
:
SharedMemory
>
(
)
;
if
(
!
newShm
-
>
ReadOnlyCopy
(
readOnly
.
get
(
)
)
)
{
MOZ_CRASH
(
"
failed
to
create
read
-
only
copy
"
)
;
return
false
;
}
ShmBlock
*
block
=
new
ShmBlock
(
std
:
:
move
(
newShm
)
)
;
block
-
>
StoreAllocated
(
sizeof
(
BlockHeader
)
)
;
block
-
>
BlockSize
(
)
=
size
;
mBlocks
.
AppendElement
(
block
)
;
GetHeader
(
)
.
mBlockCount
.
store
(
mBlocks
.
Length
(
)
)
;
mReadOnlyShmems
.
AppendElement
(
std
:
:
move
(
readOnly
)
)
;
if
(
mBlocks
.
Length
(
)
>
1
)
{
if
(
NS_IsMainThread
(
)
)
{
dom
:
:
ContentParent
:
:
BroadcastShmBlockAdded
(
GetGeneration
(
)
mBlocks
.
Length
(
)
-
1
)
;
}
else
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
ShmBlockAdded
callback
"
[
generation
=
GetGeneration
(
)
index
=
mBlocks
.
Length
(
)
-
1
]
{
dom
:
:
ContentParent
:
:
BroadcastShmBlockAdded
(
generation
index
)
;
}
)
)
;
}
}
return
true
;
}
void
FontList
:
:
ShmBlockAdded
(
uint32_t
aGeneration
uint32_t
aIndex
base
:
:
SharedMemoryHandle
aHandle
)
{
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
mBlocks
.
Length
(
)
>
0
)
;
auto
newShm
=
MakeUnique
<
base
:
:
SharedMemory
>
(
)
;
if
(
!
newShm
-
>
IsHandleValid
(
aHandle
)
)
{
return
;
}
if
(
!
newShm
-
>
SetHandle
(
std
:
:
move
(
aHandle
)
true
)
)
{
MOZ_CRASH
(
"
failed
to
set
shm
handle
"
)
;
}
if
(
aIndex
!
=
mBlocks
.
Length
(
)
)
{
return
;
}
if
(
aGeneration
!
=
GetGeneration
(
)
)
{
return
;
}
if
(
!
newShm
-
>
Map
(
SHM_BLOCK_SIZE
)
|
|
!
newShm
-
>
memory
(
)
)
{
MOZ_CRASH
(
"
failed
to
map
shared
memory
"
)
;
}
uint32_t
size
=
static_cast
<
BlockHeader
*
>
(
newShm
-
>
memory
(
)
)
-
>
mBlockSize
;
MOZ_ASSERT
(
size
>
=
SHM_BLOCK_SIZE
)
;
if
(
size
!
=
SHM_BLOCK_SIZE
)
{
newShm
-
>
Unmap
(
)
;
if
(
!
newShm
-
>
Map
(
size
)
|
|
!
newShm
-
>
memory
(
)
)
{
MOZ_CRASH
(
"
failed
to
map
shared
memory
"
)
;
}
}
mBlocks
.
AppendElement
(
new
ShmBlock
(
std
:
:
move
(
newShm
)
)
)
;
}
void
FontList
:
:
DetachShmBlocks
(
)
{
for
(
auto
&
i
:
mBlocks
)
{
i
-
>
mShmem
=
nullptr
;
}
mBlocks
.
Clear
(
)
;
mReadOnlyShmems
.
Clear
(
)
;
}
FontList
:
:
ShmBlock
*
FontList
:
:
GetBlockFromParent
(
uint32_t
aIndex
)
{
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
uint32_t
generation
=
aIndex
=
=
0
?
0
:
GetGeneration
(
)
;
base
:
:
SharedMemoryHandle
handle
=
base
:
:
SharedMemory
:
:
NULLHandle
(
)
;
if
(
!
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendGetFontListShmBlock
(
generation
aIndex
&
handle
)
)
{
return
nullptr
;
}
auto
newShm
=
MakeUnique
<
base
:
:
SharedMemory
>
(
)
;
if
(
!
newShm
-
>
IsHandleValid
(
handle
)
)
{
return
nullptr
;
}
if
(
!
newShm
-
>
SetHandle
(
std
:
:
move
(
handle
)
true
)
)
{
MOZ_CRASH
(
"
failed
to
set
shm
handle
"
)
;
}
if
(
!
newShm
-
>
Map
(
SHM_BLOCK_SIZE
)
|
|
!
newShm
-
>
memory
(
)
)
{
MOZ_CRASH
(
"
failed
to
map
shared
memory
"
)
;
}
uint32_t
size
=
static_cast
<
BlockHeader
*
>
(
newShm
-
>
memory
(
)
)
-
>
mBlockSize
;
MOZ_ASSERT
(
size
>
=
SHM_BLOCK_SIZE
)
;
if
(
size
!
=
SHM_BLOCK_SIZE
)
{
newShm
-
>
Unmap
(
)
;
if
(
!
newShm
-
>
Map
(
size
)
|
|
!
newShm
-
>
memory
(
)
)
{
MOZ_CRASH
(
"
failed
to
map
shared
memory
"
)
;
}
}
return
new
ShmBlock
(
std
:
:
move
(
newShm
)
)
;
}
bool
FontList
:
:
UpdateShmBlocks
(
bool
aMustLock
)
MOZ_NO_THREAD_SAFETY_ANALYSIS
{
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
if
(
aMustLock
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
Lock
(
)
;
}
bool
result
=
true
;
while
(
!
mBlocks
.
Length
(
)
|
|
mBlocks
.
Length
(
)
<
GetHeader
(
)
.
mBlockCount
)
{
ShmBlock
*
newBlock
=
GetBlockFromParent
(
mBlocks
.
Length
(
)
)
;
if
(
!
newBlock
)
{
result
=
false
;
break
;
}
mBlocks
.
AppendElement
(
newBlock
)
;
}
if
(
aMustLock
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
Unlock
(
)
;
}
return
result
;
}
void
FontList
:
:
ShareBlocksToProcess
(
nsTArray
<
base
:
:
SharedMemoryHandle
>
*
aBlocks
base
:
:
ProcessId
aPid
)
{
MOZ_RELEASE_ASSERT
(
mReadOnlyShmems
.
Length
(
)
=
=
mBlocks
.
Length
(
)
)
;
for
(
auto
&
shmem
:
mReadOnlyShmems
)
{
auto
handle
=
shmem
-
>
CloneHandle
(
)
;
if
(
!
handle
)
{
aBlocks
-
>
Clear
(
)
;
return
;
}
aBlocks
-
>
AppendElement
(
std
:
:
move
(
handle
)
)
;
}
}
base
:
:
SharedMemoryHandle
FontList
:
:
ShareBlockToProcess
(
uint32_t
aIndex
base
:
:
ProcessId
aPid
)
{
MOZ_RELEASE_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_RELEASE_ASSERT
(
mReadOnlyShmems
.
Length
(
)
=
=
mBlocks
.
Length
(
)
)
;
MOZ_RELEASE_ASSERT
(
aIndex
<
mReadOnlyShmems
.
Length
(
)
)
;
return
mReadOnlyShmems
[
aIndex
]
-
>
CloneHandle
(
)
;
}
Pointer
FontList
:
:
Alloc
(
uint32_t
aSize
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
auto
align
=
[
]
(
uint32_t
aSize
)
-
>
size_t
{
return
(
aSize
+
3u
)
&
~
3u
;
}
;
aSize
=
align
(
aSize
)
;
int32_t
blockIndex
=
-
1
;
uint32_t
curAlloc
size
;
if
(
aSize
<
SHM_BLOCK_SIZE
-
sizeof
(
BlockHeader
)
)
{
const
int32_t
blockCount
=
mBlocks
.
Length
(
)
;
for
(
blockIndex
=
blockCount
-
1
;
blockIndex
>
=
0
;
-
-
blockIndex
)
{
size
=
mBlocks
[
blockIndex
]
-
>
BlockSize
(
)
;
curAlloc
=
mBlocks
[
blockIndex
]
-
>
Allocated
(
)
;
if
(
size
-
curAlloc
>
=
aSize
)
{
break
;
}
}
}
if
(
blockIndex
<
0
)
{
if
(
!
AppendShmBlock
(
aSize
+
sizeof
(
BlockHeader
)
)
)
{
return
Pointer
:
:
Null
(
)
;
}
blockIndex
=
mBlocks
.
Length
(
)
-
1
;
curAlloc
=
mBlocks
[
blockIndex
]
-
>
Allocated
(
)
;
}
mBlocks
[
blockIndex
]
-
>
StoreAllocated
(
curAlloc
+
aSize
)
;
return
Pointer
(
blockIndex
curAlloc
)
;
}
void
FontList
:
:
SetFamilyNames
(
nsTArray
<
Family
:
:
InitData
>
&
aFamilies
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
Header
&
header
=
GetHeader
(
)
;
MOZ_ASSERT
(
!
header
.
mFamilyCount
)
;
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
ApplyWhitelist
(
aFamilies
)
;
aFamilies
.
Sort
(
)
;
size_t
count
=
aFamilies
.
Length
(
)
;
if
(
count
>
1
&
&
aFamilies
[
0
]
.
mKey
.
IsEmpty
(
)
)
{
aFamilies
.
RemoveElementAt
(
0
)
;
-
-
count
;
}
if
(
count
>
1
)
{
for
(
size_t
i
=
1
;
i
<
count
;
+
+
i
)
{
if
(
aFamilies
[
i
]
.
mKey
.
Equals
(
aFamilies
[
i
-
1
]
.
mKey
)
)
{
size_t
discard
=
aFamilies
[
i
]
.
mBundled
&
&
!
aFamilies
[
i
-
1
]
.
mBundled
?
i
-
1
:
i
;
aFamilies
.
RemoveElementAt
(
discard
)
;
-
-
count
;
-
-
i
;
}
}
}
header
.
mFamilies
=
Alloc
(
count
*
sizeof
(
Family
)
)
;
if
(
header
.
mFamilies
.
IsNull
(
)
)
{
return
;
}
auto
*
families
=
header
.
mFamilies
.
ToArray
<
Family
>
(
this
count
)
;
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
(
void
)
new
(
&
families
[
i
]
)
Family
(
this
aFamilies
[
i
]
)
;
LOG_FONTLIST
(
(
"
(
shared
-
fontlist
)
family
%
u
(
%
s
)
"
(
unsigned
)
i
aFamilies
[
i
]
.
mName
.
get
(
)
)
)
;
}
header
.
mFamilyCount
=
count
;
}
void
FontList
:
:
SetAliases
(
nsClassHashtable
<
nsCStringHashKey
AliasData
>
&
aAliasTable
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
Header
&
header
=
GetHeader
(
)
;
nsTArray
<
Family
:
:
InitData
>
aliasArray
;
aliasArray
.
SetCapacity
(
aAliasTable
.
Count
(
)
)
;
for
(
const
auto
&
entry
:
aAliasTable
)
{
aliasArray
.
AppendElement
(
Family
:
:
InitData
(
entry
.
GetKey
(
)
entry
.
GetData
(
)
-
>
mBaseFamily
entry
.
GetData
(
)
-
>
mIndex
entry
.
GetData
(
)
-
>
mVisibility
entry
.
GetData
(
)
-
>
mBundled
entry
.
GetData
(
)
-
>
mBadUnderline
entry
.
GetData
(
)
-
>
mForceClassic
true
)
)
;
}
aliasArray
.
Sort
(
)
;
size_t
count
=
aliasArray
.
Length
(
)
;
if
(
count
&
&
aliasArray
[
0
]
.
mKey
.
IsEmpty
(
)
)
{
aliasArray
.
RemoveElementAt
(
0
)
;
-
-
count
;
}
if
(
count
<
header
.
mAliasCount
)
{
NS_WARNING
(
"
cannot
reduce
number
of
aliases
"
)
;
return
;
}
fontlist
:
:
Pointer
ptr
=
Alloc
(
count
*
sizeof
(
Family
)
)
;
auto
*
aliases
=
ptr
.
ToArray
<
Family
>
(
this
count
)
;
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
(
void
)
new
(
&
aliases
[
i
]
)
Family
(
this
aliasArray
[
i
]
)
;
LOG_FONTLIST
(
(
"
(
shared
-
fontlist
)
alias
family
%
u
(
%
s
:
%
s
)
"
(
unsigned
)
i
aliasArray
[
i
]
.
mKey
.
get
(
)
aliasArray
[
i
]
.
mName
.
get
(
)
)
)
;
aliases
[
i
]
.
SetFacePtrs
(
this
aAliasTable
.
Get
(
aliasArray
[
i
]
.
mKey
)
-
>
mFaces
)
;
if
(
LOG_FONTLIST_ENABLED
(
)
)
{
const
auto
&
faces
=
aAliasTable
.
Get
(
aliasArray
[
i
]
.
mKey
)
-
>
mFaces
;
for
(
unsigned
j
=
0
;
j
<
faces
.
Length
(
)
;
j
+
+
)
{
auto
*
face
=
faces
[
j
]
.
ToPtr
<
const
Face
>
(
this
)
;
const
nsCString
&
desc
=
face
-
>
mDescriptor
.
AsString
(
this
)
;
nsAutoCString
weight
style
stretch
;
face
-
>
mWeight
.
ToString
(
weight
)
;
face
-
>
mStyle
.
ToString
(
style
)
;
face
-
>
mStretch
.
ToString
(
stretch
)
;
LOG_FONTLIST
(
(
"
(
shared
-
fontlist
)
face
(
%
s
)
index
%
u
weight
%
s
style
%
s
"
"
stretch
%
s
"
desc
.
get
(
)
face
-
>
mIndex
weight
.
get
(
)
style
.
get
(
)
stretch
.
get
(
)
)
)
;
}
}
}
header
.
mAliases
=
ptr
;
header
.
mAliasCount
.
store
(
count
)
;
}
void
FontList
:
:
SetLocalNames
(
nsTHashMap
<
nsCStringHashKey
LocalFaceRec
:
:
InitData
>
&
aLocalNameTable
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
Header
&
header
=
GetHeader
(
)
;
if
(
header
.
mLocalFaceCount
>
0
)
{
return
;
}
auto
faceArray
=
ToTArray
<
nsTArray
<
nsCString
>
>
(
aLocalNameTable
.
Keys
(
)
)
;
faceArray
.
Sort
(
)
;
size_t
count
=
faceArray
.
Length
(
)
;
Family
*
families
=
Families
(
)
;
fontlist
:
:
Pointer
ptr
=
Alloc
(
count
*
sizeof
(
LocalFaceRec
)
)
;
auto
*
faces
=
ptr
.
ToArray
<
LocalFaceRec
>
(
this
count
)
;
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
(
void
)
new
(
&
faces
[
i
]
)
LocalFaceRec
(
)
;
const
auto
&
rec
=
aLocalNameTable
.
Get
(
faceArray
[
i
]
)
;
faces
[
i
]
.
mKey
.
Assign
(
faceArray
[
i
]
this
)
;
const
auto
*
family
=
FindFamily
(
rec
.
mFamilyName
true
)
;
if
(
!
family
)
{
continue
;
}
faces
[
i
]
.
mFamilyIndex
=
family
-
families
;
if
(
rec
.
mFaceIndex
=
=
uint32_t
(
-
1
)
)
{
faces
[
i
]
.
mFaceIndex
=
0
;
const
Pointer
*
faceList
=
static_cast
<
const
Pointer
*
>
(
family
-
>
Faces
(
this
)
)
;
for
(
uint32_t
j
=
0
;
j
<
family
-
>
NumFaces
(
)
;
j
+
+
)
{
if
(
!
faceList
[
j
]
.
IsNull
(
)
)
{
auto
*
f
=
faceList
[
j
]
.
ToPtr
<
const
Face
>
(
this
)
;
if
(
f
&
&
rec
.
mFaceDescriptor
=
=
f
-
>
mDescriptor
.
AsString
(
this
)
)
{
faces
[
i
]
.
mFaceIndex
=
j
;
break
;
}
}
}
}
else
{
faces
[
i
]
.
mFaceIndex
=
rec
.
mFaceIndex
;
}
}
header
.
mLocalFaces
=
ptr
;
header
.
mLocalFaceCount
.
store
(
count
)
;
}
nsCString
FontList
:
:
LocalizedFamilyName
(
const
Family
*
aFamily
)
{
if
(
aFamily
-
>
IsAltLocaleFamily
(
)
)
{
if
(
aFamily
-
>
Index
(
)
!
=
Family
:
:
kNoIndex
)
{
const
Family
*
families
=
Families
(
)
;
for
(
uint32_t
i
=
0
;
i
<
NumFamilies
(
)
;
+
+
i
)
{
if
(
families
[
i
]
.
Index
(
)
=
=
aFamily
-
>
Index
(
)
&
&
families
[
i
]
.
IsBundled
(
)
=
=
aFamily
-
>
IsBundled
(
)
&
&
!
families
[
i
]
.
IsAltLocaleFamily
(
)
)
{
return
families
[
i
]
.
DisplayName
(
)
.
AsString
(
this
)
;
}
}
}
}
return
aFamily
-
>
DisplayName
(
)
.
AsString
(
this
)
;
}
Family
*
FontList
:
:
FindFamily
(
const
nsCString
&
aName
bool
aPrimaryNameOnly
)
{
struct
FamilyNameComparator
{
FamilyNameComparator
(
FontList
*
aList
const
nsCString
&
aTarget
)
:
mList
(
aList
)
mTarget
(
aTarget
)
{
}
int
operator
(
)
(
const
Family
&
aVal
)
const
{
return
Compare
(
mTarget
nsDependentCString
(
aVal
.
Key
(
)
.
BeginReading
(
mList
)
)
)
;
}
private
:
FontList
*
mList
;
const
nsCString
&
mTarget
;
}
;
const
Header
&
header
=
GetHeader
(
)
;
Family
*
families
=
Families
(
)
;
if
(
!
families
)
{
return
nullptr
;
}
size_t
match
;
if
(
BinarySearchIf
(
families
0
header
.
mFamilyCount
FamilyNameComparator
(
this
aName
)
&
match
)
)
{
return
&
families
[
match
]
;
}
if
(
aPrimaryNameOnly
)
{
return
nullptr
;
}
if
(
header
.
mAliasCount
)
{
Family
*
aliases
=
AliasFamilies
(
)
;
size_t
match
;
if
(
aliases
&
&
BinarySearchIf
(
aliases
0
header
.
mAliasCount
FamilyNameComparator
(
this
aName
)
&
match
)
)
{
return
&
aliases
[
match
]
;
}
}
#
ifdef
XP_WIN
if
(
aName
.
Contains
(
'
'
)
)
{
auto
pfl
=
gfxPlatformFontList
:
:
PlatformFontList
(
)
;
pfl
-
>
mLock
.
AssertCurrentThreadIn
(
)
;
if
(
header
.
mAliasCount
)
{
pfl
-
>
mAliasTable
.
Clear
(
)
;
pfl
-
>
mLocalNameTable
.
Clear
(
)
;
mFaceNamesRead
.
Clear
(
)
;
return
nullptr
;
}
if
(
auto
lookup
=
pfl
-
>
mAliasTable
.
Lookup
(
aName
)
)
{
return
FindFamily
(
lookup
.
Data
(
)
-
>
mBaseFamily
true
)
;
}
const
char
*
data
=
aName
.
BeginReading
(
)
;
int32_t
index
=
aName
.
Length
(
)
;
while
(
-
-
index
>
0
)
{
if
(
data
[
index
]
=
=
'
'
)
{
break
;
}
}
if
(
index
<
=
0
)
{
return
nullptr
;
}
nsAutoCString
base
(
Substring
(
aName
0
index
)
)
;
auto
familyCount
=
header
.
mFamilyCount
;
if
(
BinarySearchIf
(
families
0
familyCount
FamilyNameComparator
(
this
base
)
&
match
)
)
{
mFaceNamesRead
.
EnsureLengthAtLeast
(
familyCount
)
;
if
(
mFaceNamesRead
[
match
]
)
{
return
nullptr
;
}
Family
*
baseFamily
=
&
families
[
match
]
;
pfl
-
>
ReadFaceNamesForFamily
(
baseFamily
false
)
;
mFaceNamesRead
[
match
]
=
true
;
if
(
auto
lookup
=
pfl
-
>
mAliasTable
.
Lookup
(
aName
)
)
{
if
(
lookup
.
Data
(
)
-
>
mFaces
.
Length
(
)
!
=
baseFamily
-
>
NumFaces
(
)
)
{
pfl
-
>
InitOtherFamilyNames
(
true
)
;
}
return
baseFamily
;
}
}
}
#
endif
return
nullptr
;
}
LocalFaceRec
*
FontList
:
:
FindLocalFace
(
const
nsCString
&
aName
)
{
struct
FaceNameComparator
{
FaceNameComparator
(
FontList
*
aList
const
nsCString
&
aTarget
)
:
mList
(
aList
)
mTarget
(
aTarget
)
{
}
int
operator
(
)
(
const
LocalFaceRec
&
aVal
)
const
{
return
Compare
(
mTarget
nsDependentCString
(
aVal
.
mKey
.
BeginReading
(
mList
)
)
)
;
}
private
:
FontList
*
mList
;
const
nsCString
&
mTarget
;
}
;
Header
&
header
=
GetHeader
(
)
;
LocalFaceRec
*
faces
=
LocalFaces
(
)
;
size_t
match
;
if
(
faces
&
&
BinarySearchIf
(
faces
0
header
.
mLocalFaceCount
FaceNameComparator
(
this
aName
)
&
match
)
)
{
return
&
faces
[
match
]
;
}
return
nullptr
;
}
void
FontList
:
:
SearchForLocalFace
(
const
nsACString
&
aName
Family
*
*
aFamily
Face
*
*
aFace
)
{
Header
&
header
=
GetHeader
(
)
;
MOZ_ASSERT
(
header
.
mLocalFaceCount
=
=
0
"
do
not
use
when
local
face
names
are
already
set
up
!
"
)
;
LOG_FONTLIST
(
(
"
(
shared
-
fontlist
)
local
face
search
for
(
%
s
)
"
aName
.
BeginReading
(
)
)
)
;
char
initial
=
aName
[
0
]
;
Family
*
families
=
Families
(
)
;
if
(
!
families
)
{
return
;
}
for
(
uint32_t
i
=
0
;
i
<
header
.
mFamilyCount
;
i
+
+
)
{
Family
*
family
=
&
families
[
i
]
;
if
(
family
-
>
Key
(
)
.
BeginReading
(
this
)
[
0
]
!
=
initial
)
{
continue
;
}
LOG_FONTLIST
(
(
"
(
shared
-
fontlist
)
checking
family
(
%
s
)
"
family
-
>
Key
(
)
.
AsString
(
this
)
.
BeginReading
(
)
)
)
;
if
(
!
family
-
>
IsInitialized
(
)
)
{
if
(
!
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
InitializeFamily
(
family
)
)
{
continue
;
}
}
Pointer
*
faces
=
family
-
>
Faces
(
this
)
;
if
(
!
faces
)
{
continue
;
}
for
(
uint32_t
j
=
0
;
j
<
family
-
>
NumFaces
(
)
;
j
+
+
)
{
auto
*
face
=
faces
[
j
]
.
ToPtr
<
Face
>
(
this
)
;
if
(
!
face
)
{
continue
;
}
nsAutoCString
psname
fullname
;
if
(
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
ReadFaceNames
(
family
face
psname
fullname
)
)
{
LOG_FONTLIST
(
(
"
(
shared
-
fontlist
)
read
psname
(
%
s
)
fullname
(
%
s
)
"
psname
.
get
(
)
fullname
.
get
(
)
)
)
;
ToLowerCase
(
psname
)
;
ToLowerCase
(
fullname
)
;
if
(
aName
=
=
psname
|
|
aName
=
=
fullname
)
{
*
aFamily
=
family
;
*
aFace
=
face
;
return
;
}
}
}
}
}
size_t
FontList
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
size_t
FontList
:
:
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
result
=
mBlocks
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
const
auto
&
b
:
mBlocks
)
{
result
+
=
aMallocSizeOf
(
b
.
get
(
)
)
+
aMallocSizeOf
(
b
-
>
mShmem
.
get
(
)
)
;
}
return
result
;
}
size_t
FontList
:
:
AllocatedShmemSize
(
)
const
{
size_t
result
=
0
;
for
(
const
auto
&
b
:
mBlocks
)
{
result
+
=
b
-
>
BlockSize
(
)
;
}
return
result
;
}
}
}
