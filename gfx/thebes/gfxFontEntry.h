#
ifndef
GFX_FONTENTRY_H
#
define
GFX_FONTENTRY_H
#
include
<
math
.
h
>
#
include
<
new
>
#
include
<
utility
>
#
include
"
ThebesRLBoxTypes
.
h
"
#
include
"
gfxFontUtils
.
h
"
#
include
"
gfxFontVariations
.
h
"
#
include
"
gfxRect
.
h
"
#
include
"
gfxTypes
.
h
"
#
include
"
harfbuzz
/
hb
.
h
"
#
include
"
ipc
/
EnumSerializer
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
FontPropertyTypes
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsUnicodeScriptCodes
.
h
"
#
include
"
nscore
.
h
"
class
FontInfoData
;
class
gfxContext
;
class
gfxFont
;
class
gfxFontFamily
;
class
gfxPlatformFontList
;
class
gfxSVGGlyphs
;
class
gfxUserFontData
;
class
nsAtom
;
struct
FontListSizes
;
struct
gfxFontFeature
;
struct
gfxFontStyle
;
enum
class
eFontPresentation
:
uint8_t
;
namespace
IPC
{
template
<
class
P
>
struct
ParamTraits
;
}
namespace
mozilla
{
class
SVGContextPaint
;
namespace
fontlist
{
struct
Face
;
struct
Family
;
}
namespace
gfx
{
struct
DeviceColor
;
}
}
typedef
struct
gr_face
gr_face
;
typedef
struct
FT_MM_Var_
FT_MM_Var
;
#
define
NO_FONT_LANGUAGE_OVERRIDE
0
class
gfxCharacterMap
:
public
gfxSparseBitSet
{
public
:
nsrefcnt
AddRef
(
)
{
MOZ_ASSERT
(
int32_t
(
mRefCnt
)
>
=
0
"
illegal
refcnt
"
)
;
+
+
mRefCnt
;
NS_LOG_ADDREF
(
this
mRefCnt
"
gfxCharacterMap
"
sizeof
(
*
this
)
)
;
return
mRefCnt
;
}
nsrefcnt
Release
(
)
{
MOZ_ASSERT
(
0
!
=
mRefCnt
"
dup
release
"
)
;
-
-
mRefCnt
;
NS_LOG_RELEASE
(
this
mRefCnt
"
gfxCharacterMap
"
)
;
if
(
mRefCnt
=
=
0
)
{
NotifyReleased
(
)
;
return
0
;
}
return
mRefCnt
;
}
gfxCharacterMap
(
)
:
mHash
(
0
)
mBuildOnTheFly
(
false
)
mShared
(
false
)
{
}
explicit
gfxCharacterMap
(
const
gfxSparseBitSet
&
aOther
)
:
gfxSparseBitSet
(
aOther
)
mHash
(
0
)
mBuildOnTheFly
(
false
)
mShared
(
false
)
{
}
void
CalcHash
(
)
{
mHash
=
GetChecksum
(
)
;
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
gfxSparseBitSet
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
uint32_t
mHash
;
bool
mBuildOnTheFly
;
bool
mShared
;
protected
:
void
NotifyReleased
(
)
;
nsAutoRefCnt
mRefCnt
;
private
:
gfxCharacterMap
(
const
gfxCharacterMap
&
)
;
gfxCharacterMap
&
operator
=
(
const
gfxCharacterMap
&
)
;
}
;
struct
gfxFontFeatureInfo
{
uint32_t
mTag
;
uint32_t
mScript
;
uint32_t
mLangSys
;
}
;
class
gfxFontEntry
{
public
:
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
typedef
mozilla
:
:
unicode
:
:
Script
Script
;
typedef
mozilla
:
:
FontWeight
FontWeight
;
typedef
mozilla
:
:
FontSlantStyle
FontSlantStyle
;
typedef
mozilla
:
:
FontStretch
FontStretch
;
typedef
mozilla
:
:
WeightRange
WeightRange
;
typedef
mozilla
:
:
SlantStyleRange
SlantStyleRange
;
typedef
mozilla
:
:
StretchRange
StretchRange
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
gfxFontEntry
)
explicit
gfxFontEntry
(
const
nsACString
&
aName
bool
aIsStandardFace
=
false
)
;
virtual
gfxFontEntry
*
Clone
(
)
const
=
0
;
const
nsCString
&
Name
(
)
const
{
return
mName
;
}
const
nsCString
&
FamilyName
(
)
const
{
return
mFamilyName
;
}
virtual
nsCString
RealFaceName
(
)
;
WeightRange
Weight
(
)
const
{
return
mWeightRange
;
}
StretchRange
Stretch
(
)
const
{
return
mStretchRange
;
}
SlantStyleRange
SlantStyle
(
)
const
{
return
mStyleRange
;
}
bool
IsUserFont
(
)
const
{
return
mIsDataUserFont
|
|
mIsLocalUserFont
;
}
bool
IsLocalUserFont
(
)
const
{
return
mIsLocalUserFont
;
}
bool
IsFixedPitch
(
)
const
{
return
mFixedPitch
;
}
bool
IsItalic
(
)
const
{
return
SlantStyle
(
)
.
Min
(
)
.
IsItalic
(
)
;
}
bool
IsOblique
(
)
const
{
return
SlantStyle
(
)
.
Min
(
)
.
IsOblique
(
)
;
}
bool
IsUpright
(
)
const
{
return
SlantStyle
(
)
.
Min
(
)
.
IsNormal
(
)
;
}
inline
bool
SupportsItalic
(
)
;
inline
bool
SupportsBold
(
)
;
bool
IgnoreGDEF
(
)
const
{
return
mIgnoreGDEF
;
}
bool
IgnoreGSUB
(
)
const
{
return
mIgnoreGSUB
;
}
bool
IsNormalStyle
(
)
const
{
return
IsUpright
(
)
&
&
Weight
(
)
.
Min
(
)
<
=
FontWeight
:
:
Normal
(
)
&
&
Weight
(
)
.
Max
(
)
>
=
FontWeight
:
:
Normal
(
)
&
&
Stretch
(
)
.
Min
(
)
<
=
FontStretch
:
:
Normal
(
)
&
&
Stretch
(
)
.
Max
(
)
>
=
FontStretch
:
:
Normal
(
)
;
}
virtual
bool
SupportsOpenTypeFeature
(
Script
aScript
uint32_t
aFeatureTag
)
;
bool
SupportsGraphiteFeature
(
uint32_t
aFeatureTag
)
;
const
hb_set_t
*
InputsForOpenTypeFeature
(
Script
aScript
uint32_t
aFeatureTag
)
;
virtual
bool
HasFontTable
(
uint32_t
aTableTag
)
;
inline
bool
HasGraphiteTables
(
)
{
if
(
!
mCheckedForGraphiteTables
)
{
CheckForGraphiteTables
(
)
;
mCheckedForGraphiteTables
=
true
;
}
return
mHasGraphiteTables
;
}
inline
bool
HasCmapTable
(
)
{
if
(
!
mCharacterMap
&
&
!
mShmemCharacterMap
)
{
ReadCMAP
(
)
;
NS_ASSERTION
(
mCharacterMap
|
|
mShmemCharacterMap
"
failed
to
initialize
character
map
"
)
;
}
return
mHasCmapTable
;
}
inline
bool
HasCharacter
(
uint32_t
ch
)
{
if
(
mShmemCharacterMap
)
{
return
mShmemCharacterMap
-
>
test
(
ch
)
;
}
if
(
mCharacterMap
)
{
if
(
mShmemFace
&
&
TrySetShmemCharacterMap
(
)
)
{
mCharacterMap
=
nullptr
;
return
mShmemCharacterMap
-
>
test
(
ch
)
;
}
if
(
mCharacterMap
-
>
test
(
ch
)
)
{
return
true
;
}
}
return
TestCharacterMap
(
ch
)
;
}
virtual
bool
SkipDuringSystemFallback
(
)
{
return
false
;
}
nsresult
InitializeUVSMap
(
)
;
uint16_t
GetUVSGlyph
(
uint32_t
aCh
uint32_t
aVS
)
;
virtual
nsresult
ReadCMAP
(
FontInfoData
*
aFontInfoData
=
nullptr
)
;
bool
TryGetSVGData
(
gfxFont
*
aFont
)
;
bool
HasSVGGlyph
(
uint32_t
aGlyphId
)
;
bool
GetSVGGlyphExtents
(
DrawTarget
*
aDrawTarget
uint32_t
aGlyphId
gfxFloat
aSize
gfxRect
*
aResult
)
;
void
RenderSVGGlyph
(
gfxContext
*
aContext
uint32_t
aGlyphId
mozilla
:
:
SVGContextPaint
*
aContextPaint
)
;
void
NotifyGlyphsChanged
(
)
;
bool
TryGetColorGlyphs
(
)
;
bool
GetColorLayersInfo
(
uint32_t
aGlyphId
const
mozilla
:
:
gfx
:
:
DeviceColor
&
aDefaultColor
nsTArray
<
uint16_t
>
&
layerGlyphs
nsTArray
<
mozilla
:
:
gfx
:
:
DeviceColor
>
&
layerColors
)
;
bool
HasColorLayersForGlyph
(
uint32_t
aGlyphId
)
{
MOZ_ASSERT
(
mCOLR
)
;
return
gfxFontUtils
:
:
HasColorLayersForGlyph
(
mCOLR
aGlyphId
)
;
}
bool
HasColorBitmapTable
(
)
{
if
(
!
mCheckedForColorBitmapTables
)
{
mHasColorBitmapTable
=
HasFontTable
(
TRUETYPE_TAG
(
'
C
'
'
B
'
'
D
'
'
T
'
)
)
|
|
HasFontTable
(
TRUETYPE_TAG
(
'
s
'
'
b
'
'
i
'
'
x
'
)
)
;
mCheckedForColorBitmapTables
=
true
;
}
return
mHasColorBitmapTable
;
}
virtual
hb_blob_t
*
GetFontTable
(
uint32_t
aTag
)
;
class
AutoTable
{
public
:
AutoTable
(
gfxFontEntry
*
aFontEntry
uint32_t
aTag
)
{
mBlob
=
aFontEntry
-
>
GetFontTable
(
aTag
)
;
}
~
AutoTable
(
)
{
hb_blob_destroy
(
mBlob
)
;
}
operator
hb_blob_t
*
(
)
const
{
return
mBlob
;
}
private
:
hb_blob_t
*
mBlob
;
AutoTable
(
const
AutoTable
&
)
=
delete
;
AutoTable
&
operator
=
(
const
AutoTable
&
)
=
delete
;
}
;
gfxFont
*
FindOrMakeFont
(
const
gfxFontStyle
*
aStyle
gfxCharacterMap
*
aUnicodeRangeMap
=
nullptr
)
;
bool
GetExistingFontTable
(
uint32_t
aTag
hb_blob_t
*
*
aBlob
)
;
hb_blob_t
*
ShareFontTableAndGetBlob
(
uint32_t
aTag
nsTArray
<
uint8_t
>
*
aTable
)
;
uint16_t
UnitsPerEm
(
)
;
enum
{
kMinUPEM
=
16
kMaxUPEM
=
16384
kInvalidUPEM
=
uint16_t
(
-
1
)
}
;
hb_face_t
*
GetHBFace
(
)
;
void
ForgetHBFace
(
)
;
rlbox_sandbox_gr
*
GetGrSandbox
(
)
;
sandbox_callback_gr
<
float
(
*
)
(
const
void
*
uint16_t
)
>
*
GetGrSandboxAdvanceCallbackHandle
(
)
;
tainted_opaque_gr
<
gr_face
*
>
GetGrFace
(
)
;
void
ReleaseGrFace
(
tainted_opaque_gr
<
gr_face
*
>
aFace
)
;
tainted_boolean_hint
HasGraphiteSpaceContextuals
(
)
;
void
DisconnectSVG
(
)
;
void
NotifyFontDestroyed
(
gfxFont
*
aFont
)
;
virtual
void
AddSizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
FontListSizes
*
aSizes
)
const
;
virtual
void
AddSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
FontListSizes
*
aSizes
)
const
;
size_t
ComputedSizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
struct
ScriptRange
{
uint32_t
rangeStart
;
uint32_t
rangeEnd
;
uint32_t
numTags
;
hb_tag_t
tags
[
3
]
;
}
;
bool
SupportsScriptInGSUB
(
const
hb_tag_t
*
aScriptTags
uint32_t
aNumTags
)
;
virtual
bool
HasVariations
(
)
=
0
;
virtual
void
GetVariationAxes
(
nsTArray
<
gfxFontVariationAxis
>
&
aVariationAxes
)
=
0
;
virtual
void
GetVariationInstances
(
nsTArray
<
gfxFontVariationInstance
>
&
aInstances
)
=
0
;
bool
HasBoldVariableWeight
(
)
;
bool
HasItalicVariation
(
)
;
void
CheckForVariationAxes
(
)
;
void
SetupVariationRanges
(
)
;
void
GetVariationsForStyle
(
nsTArray
<
gfxFontVariation
>
&
aResult
const
gfxFontStyle
&
aStyle
)
;
void
GetFeatureInfo
(
nsTArray
<
gfxFontFeatureInfo
>
&
aFeatureInfo
)
;
virtual
FT_MM_Var
*
GetMMVar
(
)
{
return
nullptr
;
}
bool
HasTrackingTable
(
)
;
float
TrackingForCSSPx
(
float
aSize
)
const
;
nsCString
mName
;
nsCString
mFamilyName
;
RefPtr
<
gfxCharacterMap
>
mCharacterMap
;
mozilla
:
:
fontlist
:
:
Face
*
mShmemFace
=
nullptr
;
const
SharedBitSet
*
mShmemCharacterMap
=
nullptr
;
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
mUVSData
;
mozilla
:
:
UniquePtr
<
gfxUserFontData
>
mUserFontData
;
mozilla
:
:
UniquePtr
<
gfxSVGGlyphs
>
mSVGGlyphs
;
nsTArray
<
gfxFont
*
>
mFontsUsingSVGGlyphs
;
nsTArray
<
gfxFontFeature
>
mFeatureSettings
;
nsTArray
<
gfxFontVariation
>
mVariationSettings
;
mozilla
:
:
UniquePtr
<
nsTHashMap
<
nsUint32HashKey
bool
>
>
mSupportedFeatures
;
mozilla
:
:
UniquePtr
<
nsTHashMap
<
nsUint32HashKey
hb_set_t
*
>
>
mFeatureInputs
;
hb_blob_t
*
mCOLR
=
nullptr
;
hb_blob_t
*
mCPAL
=
nullptr
;
uint32_t
mDefaultSubSpaceFeatures
[
(
int
(
Script
:
:
NUM_SCRIPT_CODES
)
+
31
)
/
32
]
;
uint32_t
mNonDefaultSubSpaceFeatures
[
(
int
(
Script
:
:
NUM_SCRIPT_CODES
)
+
31
)
/
32
]
;
uint32_t
mUVSOffset
=
0
;
uint32_t
mLanguageOverride
=
NO_FONT_LANGUAGE_OVERRIDE
;
WeightRange
mWeightRange
=
WeightRange
(
FontWeight
(
500
)
)
;
StretchRange
mStretchRange
=
StretchRange
(
FontStretch
:
:
Normal
(
)
)
;
SlantStyleRange
mStyleRange
=
SlantStyleRange
(
FontSlantStyle
:
:
Normal
(
)
)
;
float
mAscentOverride
=
-
1
.
0
;
float
mDescentOverride
=
-
1
.
0
;
float
mLineGapOverride
=
-
1
.
0
;
enum
class
RangeFlags
:
uint8_t
{
eNoFlags
=
0
eAutoWeight
=
(
1
<
<
0
)
eAutoStretch
=
(
1
<
<
1
)
eAutoSlantStyle
=
(
1
<
<
2
)
eBoldVariableWeight
=
(
1
<
<
3
)
eItalicVariation
=
(
1
<
<
4
)
eNonCSSWeight
=
(
1
<
<
5
)
eNonCSSStretch
=
(
1
<
<
6
)
}
;
RangeFlags
mRangeFlags
=
RangeFlags
:
:
eNoFlags
;
bool
mFixedPitch
:
1
;
bool
mIsBadUnderlineFont
:
1
;
bool
mIsUserFontContainer
:
1
;
bool
mIsDataUserFont
:
1
;
bool
mIsLocalUserFont
:
1
;
bool
mStandardFace
:
1
;
bool
mIgnoreGDEF
:
1
;
bool
mIgnoreGSUB
:
1
;
bool
mSVGInitialized
:
1
;
bool
mHasSpaceFeaturesInitialized
:
1
;
bool
mHasSpaceFeatures
:
1
;
bool
mHasSpaceFeaturesKerning
:
1
;
bool
mHasSpaceFeaturesNonKerning
:
1
;
bool
mSkipDefaultFeatureSpaceCheck
:
1
;
bool
mGraphiteSpaceContextualsInitialized
:
1
;
bool
mHasGraphiteSpaceContextuals
:
1
;
bool
mSpaceGlyphIsInvisible
:
1
;
bool
mSpaceGlyphIsInvisibleInitialized
:
1
;
bool
mHasGraphiteTables
:
1
;
bool
mCheckedForGraphiteTables
:
1
;
bool
mHasCmapTable
:
1
;
bool
mGrFaceInitialized
:
1
;
bool
mCheckedForColorGlyph
:
1
;
bool
mCheckedForVariationAxes
:
1
;
bool
mHasColorBitmapTable
:
1
;
bool
mCheckedForColorBitmapTables
:
1
;
protected
:
friend
class
gfxPlatformFontList
;
friend
class
gfxFontFamily
;
friend
class
gfxUserFontEntry
;
gfxFontEntry
(
)
;
virtual
~
gfxFontEntry
(
)
;
virtual
gfxFont
*
CreateFontInstance
(
const
gfxFontStyle
*
aFontStyle
)
=
0
;
virtual
void
CheckForGraphiteTables
(
)
;
virtual
nsresult
CopyFontTable
(
uint32_t
aTableTag
nsTArray
<
uint8_t
>
&
aBuffer
)
{
MOZ_ASSERT_UNREACHABLE
(
"
forgot
to
override
either
GetFontTable
or
"
"
CopyFontTable
?
"
)
;
return
NS_ERROR_FAILURE
;
}
bool
ParseTrakTable
(
)
;
virtual
already_AddRefed
<
gfxCharacterMap
>
GetCMAPFromFontInfo
(
FontInfoData
*
aFontInfoData
uint32_t
&
aUVSOffset
)
;
virtual
bool
TestCharacterMap
(
uint32_t
aCh
)
;
bool
TrySetShmemCharacterMap
(
)
;
void
InitializeFrom
(
mozilla
:
:
fontlist
:
:
Face
*
aFace
const
mozilla
:
:
fontlist
:
:
Family
*
aFamily
)
;
hb_face_t
*
mHBFace
=
nullptr
;
static
hb_blob_t
*
HBGetTable
(
hb_face_t
*
face
uint32_t
aTag
void
*
aUserData
)
;
static
void
HBFaceDeletedCallback
(
void
*
aUserData
)
;
struct
GrSandboxData
;
GrSandboxData
*
mSandboxData
=
nullptr
;
tainted_opaque_gr
<
gr_face
*
>
mGrFace
;
hb_blob_t
*
const
kTrakTableUninitialized
=
(
hb_blob_t
*
)
(
intptr_t
(
-
1
)
)
;
hb_blob_t
*
mTrakTable
=
kTrakTableUninitialized
;
bool
TrakTableInitialized
(
)
const
{
return
mTrakTable
!
=
kTrakTableUninitialized
;
}
const
mozilla
:
:
AutoSwap_PRInt16
*
mTrakValues
;
const
mozilla
:
:
AutoSwap_PRInt32
*
mTrakSizeTable
;
nsrefcnt
mGrFaceRefCnt
=
0
;
static
tainted_opaque_gr
<
const
void
*
>
GrGetTable
(
rlbox_sandbox_gr
&
sandbox
tainted_opaque_gr
<
const
void
*
>
aAppFaceHandle
tainted_opaque_gr
<
unsigned
int
>
aName
tainted_opaque_gr
<
size_t
*
>
aLen
)
;
static
void
GrReleaseTable
(
rlbox_sandbox_gr
&
sandbox
tainted_opaque_gr
<
const
void
*
>
aAppFaceHandle
tainted_opaque_gr
<
const
void
*
>
aTableBuffer
)
;
uint32_t
mComputedSizeOfUserFont
=
0
;
uint16_t
mUnitsPerEm
=
0
;
uint16_t
mNumTrakSizes
;
private
:
class
FontTableBlobData
;
class
FontTableHashEntry
:
public
nsUint32HashKey
{
public
:
typedef
nsUint32HashKey
KeyClass
;
typedef
KeyClass
:
:
KeyType
KeyType
;
typedef
KeyClass
:
:
KeyTypePointer
KeyTypePointer
;
explicit
FontTableHashEntry
(
KeyTypePointer
aTag
)
:
KeyClass
(
aTag
)
mSharedBlobData
(
nullptr
)
mBlob
(
nullptr
)
{
}
FontTableHashEntry
(
FontTableHashEntry
&
&
toMove
)
:
KeyClass
(
std
:
:
move
(
toMove
)
)
mSharedBlobData
(
std
:
:
move
(
toMove
.
mSharedBlobData
)
)
mBlob
(
std
:
:
move
(
toMove
.
mBlob
)
)
{
toMove
.
mSharedBlobData
=
nullptr
;
toMove
.
mBlob
=
nullptr
;
}
~
FontTableHashEntry
(
)
{
Clear
(
)
;
}
hb_blob_t
*
ShareTableAndGetBlob
(
nsTArray
<
uint8_t
>
&
&
aTable
nsTHashtable
<
FontTableHashEntry
>
*
aHashtable
)
;
hb_blob_t
*
GetBlob
(
)
const
;
void
Clear
(
)
;
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
private
:
static
void
DeleteFontTableBlobData
(
void
*
aBlobData
)
;
FontTableHashEntry
&
operator
=
(
FontTableHashEntry
&
toCopy
)
;
FontTableBlobData
*
mSharedBlobData
;
hb_blob_t
*
mBlob
;
}
;
mozilla
:
:
UniquePtr
<
nsTHashtable
<
FontTableHashEntry
>
>
mFontTableCache
;
gfxFontEntry
(
const
gfxFontEntry
&
)
;
gfxFontEntry
&
operator
=
(
const
gfxFontEntry
&
)
;
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
gfxFontEntry
:
:
RangeFlags
)
inline
bool
gfxFontEntry
:
:
SupportsItalic
(
)
{
return
SlantStyle
(
)
.
Max
(
)
.
IsItalic
(
)
|
|
(
(
mRangeFlags
&
RangeFlags
:
:
eAutoSlantStyle
)
=
=
RangeFlags
:
:
eAutoSlantStyle
&
&
HasItalicVariation
(
)
)
;
}
inline
bool
gfxFontEntry
:
:
SupportsBold
(
)
{
return
Weight
(
)
.
Max
(
)
.
IsBold
(
)
|
|
(
(
mRangeFlags
&
RangeFlags
:
:
eAutoWeight
)
=
=
RangeFlags
:
:
eAutoWeight
&
&
HasBoldVariableWeight
(
)
)
;
}
struct
GlobalFontMatch
{
GlobalFontMatch
(
uint32_t
aCharacter
uint32_t
aNextCh
const
gfxFontStyle
&
aStyle
eFontPresentation
aPresentation
)
:
mStyle
(
aStyle
)
mCh
(
aCharacter
)
mNextCh
(
aNextCh
)
mPresentation
(
aPresentation
)
{
}
RefPtr
<
gfxFontEntry
>
mBestMatch
;
RefPtr
<
gfxFontFamily
>
mMatchedFamily
;
mozilla
:
:
fontlist
:
:
Family
*
mMatchedSharedFamily
=
nullptr
;
const
gfxFontStyle
&
mStyle
;
const
uint32_t
mCh
;
const
uint32_t
mNextCh
;
eFontPresentation
mPresentation
;
uint32_t
mCount
=
0
;
uint32_t
mCmapsTested
=
0
;
double
mMatchDistance
=
INFINITY
;
}
;
enum
class
FontVisibility
:
uint8_t
{
Unknown
=
0
Base
=
1
LangPack
=
2
User
=
3
Hidden
=
4
Webfont
=
5
Count
=
6
}
;
namespace
IPC
{
template
<
>
struct
ParamTraits
<
FontVisibility
>
:
public
ContiguousEnumSerializer
<
FontVisibility
FontVisibility
:
:
Unknown
FontVisibility
:
:
Count
>
{
}
;
}
class
gfxFontFamily
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
gfxFontFamily
)
gfxFontFamily
(
const
nsACString
&
aName
FontVisibility
aVisibility
)
:
mName
(
aName
)
mVisibility
(
aVisibility
)
mOtherFamilyNamesInitialized
(
false
)
mHasOtherFamilyNames
(
false
)
mFaceNamesInitialized
(
false
)
mHasStyles
(
false
)
mIsSimpleFamily
(
false
)
mIsBadUnderlineFamily
(
false
)
mFamilyCharacterMapInitialized
(
false
)
mSkipDefaultFeatureSpaceCheck
(
false
)
mCheckForFallbackFaces
(
false
)
mCheckedForLegacyFamilyNames
(
false
)
{
}
const
nsCString
&
Name
(
)
{
return
mName
;
}
virtual
void
LocalizedName
(
nsACString
&
aLocalizedName
)
;
virtual
bool
HasOtherFamilyNames
(
)
;
bool
CheckForLegacyFamilyNames
(
gfxPlatformFontList
*
aFontList
)
;
nsTArray
<
RefPtr
<
gfxFontEntry
>
>
&
GetFontList
(
)
{
return
mAvailableFonts
;
}
void
AddFontEntry
(
RefPtr
<
gfxFontEntry
>
aFontEntry
)
{
if
(
aFontEntry
-
>
IsItalic
(
)
&
&
!
aFontEntry
-
>
IsUserFont
(
)
&
&
Name
(
)
.
EqualsLiteral
(
"
Times
New
Roman
"
)
)
{
aFontEntry
-
>
mIgnoreGDEF
=
true
;
}
if
(
aFontEntry
-
>
mFamilyName
.
IsEmpty
(
)
)
{
aFontEntry
-
>
mFamilyName
=
Name
(
)
;
}
else
{
MOZ_ASSERT
(
aFontEntry
-
>
mFamilyName
.
Equals
(
Name
(
)
)
)
;
}
aFontEntry
-
>
mSkipDefaultFeatureSpaceCheck
=
mSkipDefaultFeatureSpaceCheck
;
mAvailableFonts
.
AppendElement
(
aFontEntry
)
;
if
(
mIsSimpleFamily
)
{
mAvailableFonts
.
RemoveElementsBy
(
[
]
(
const
auto
&
font
)
{
return
!
font
;
}
)
;
mIsSimpleFamily
=
false
;
}
}
bool
HasStyles
(
)
{
return
mHasStyles
;
}
void
SetHasStyles
(
bool
aHasStyles
)
{
mHasStyles
=
aHasStyles
;
}
gfxFontEntry
*
FindFontForStyle
(
const
gfxFontStyle
&
aFontStyle
bool
aIgnoreSizeTolerance
=
false
)
;
virtual
void
FindAllFontsForStyle
(
const
gfxFontStyle
&
aFontStyle
nsTArray
<
gfxFontEntry
*
>
&
aFontEntryList
bool
aIgnoreSizeTolerance
=
false
)
;
void
FindFontForChar
(
GlobalFontMatch
*
aMatchData
)
;
void
SearchAllFontsForChar
(
GlobalFontMatch
*
aMatchData
)
;
virtual
void
ReadOtherFamilyNames
(
gfxPlatformFontList
*
aPlatformFontList
)
;
void
SetOtherFamilyNamesInitialized
(
)
{
mOtherFamilyNamesInitialized
=
true
;
}
virtual
void
ReadFaceNames
(
gfxPlatformFontList
*
aPlatformFontList
bool
aNeedFullnamePostscriptNames
FontInfoData
*
aFontInfoData
=
nullptr
)
;
virtual
void
FindStyleVariations
(
FontInfoData
*
aFontInfoData
=
nullptr
)
{
}
gfxFontEntry
*
FindFont
(
const
nsACString
&
aPostscriptName
)
;
void
ReadAllCMAPs
(
FontInfoData
*
aFontInfoData
=
nullptr
)
;
bool
TestCharacterMap
(
uint32_t
aCh
)
{
if
(
!
mFamilyCharacterMapInitialized
)
{
ReadAllCMAPs
(
)
;
}
return
mFamilyCharacterMap
.
test
(
aCh
)
;
}
void
ResetCharacterMap
(
)
{
mFamilyCharacterMap
.
reset
(
)
;
mFamilyCharacterMapInitialized
=
false
;
}
void
SetBadUnderlineFamily
(
)
{
mIsBadUnderlineFamily
=
true
;
if
(
mHasStyles
)
{
SetBadUnderlineFonts
(
)
;
}
}
virtual
bool
IsSingleFaceFamily
(
)
const
{
return
false
;
}
bool
IsBadUnderlineFamily
(
)
const
{
return
mIsBadUnderlineFamily
;
}
bool
CheckForFallbackFaces
(
)
const
{
return
mCheckForFallbackFaces
;
}
void
SortAvailableFonts
(
)
;
void
CheckForSimpleFamily
(
)
;
virtual
void
AddSizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
FontListSizes
*
aSizes
)
const
;
virtual
void
AddSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
FontListSizes
*
aSizes
)
const
;
#
ifdef
DEBUG
bool
ContainsFace
(
gfxFontEntry
*
aFontEntry
)
;
#
endif
void
SetSkipSpaceFeatureCheck
(
bool
aSkipCheck
)
{
mSkipDefaultFeatureSpaceCheck
=
aSkipCheck
;
}
virtual
bool
FilterForFontList
(
nsAtom
*
aLangGroup
const
nsACString
&
aGeneric
)
const
{
return
true
;
}
FontVisibility
Visibility
(
)
const
{
return
mVisibility
;
}
bool
IsHidden
(
)
const
{
return
Visibility
(
)
=
=
FontVisibility
:
:
Hidden
;
}
bool
IsWebFontFamily
(
)
const
{
return
Visibility
(
)
=
=
FontVisibility
:
:
Webfont
;
}
protected
:
virtual
~
gfxFontFamily
(
)
;
bool
ReadOtherFamilyNamesForFace
(
gfxPlatformFontList
*
aPlatformFontList
hb_blob_t
*
aNameTable
bool
useFullName
=
false
)
;
void
SetBadUnderlineFonts
(
)
{
uint32_t
i
numFonts
=
mAvailableFonts
.
Length
(
)
;
for
(
i
=
0
;
i
<
numFonts
;
i
+
+
)
{
if
(
mAvailableFonts
[
i
]
)
{
mAvailableFonts
[
i
]
-
>
mIsBadUnderlineFont
=
true
;
}
}
}
nsCString
mName
;
nsTArray
<
RefPtr
<
gfxFontEntry
>
>
mAvailableFonts
;
gfxSparseBitSet
mFamilyCharacterMap
;
FontVisibility
mVisibility
;
bool
mOtherFamilyNamesInitialized
:
1
;
bool
mHasOtherFamilyNames
:
1
;
bool
mFaceNamesInitialized
:
1
;
bool
mHasStyles
:
1
;
bool
mIsSimpleFamily
:
1
;
bool
mIsBadUnderlineFamily
:
1
;
bool
mFamilyCharacterMapInitialized
:
1
;
bool
mSkipDefaultFeatureSpaceCheck
:
1
;
bool
mCheckForFallbackFaces
:
1
;
bool
mCheckedForLegacyFamilyNames
:
1
;
enum
{
kRegularFaceIndex
=
0
kBoldFaceIndex
=
1
kItalicFaceIndex
=
2
kBoldItalicFaceIndex
=
3
kBoldMask
=
0x01
kItalicMask
=
0x02
}
;
}
;
struct
FontFamily
{
FontFamily
(
)
:
mUnshared
(
nullptr
)
mIsShared
(
false
)
{
}
FontFamily
(
const
FontFamily
&
aOther
)
=
default
;
explicit
FontFamily
(
gfxFontFamily
*
aFamily
)
:
mUnshared
(
aFamily
)
mIsShared
(
false
)
{
}
explicit
FontFamily
(
mozilla
:
:
fontlist
:
:
Family
*
aFamily
)
:
mShared
(
aFamily
)
mIsShared
(
true
)
{
}
bool
operator
=
=
(
const
FontFamily
&
aOther
)
const
{
return
mIsShared
=
=
aOther
.
mIsShared
&
&
(
mIsShared
?
mShared
=
=
aOther
.
mShared
:
mUnshared
=
=
aOther
.
mUnshared
)
;
}
bool
IsNull
(
)
const
{
return
mIsShared
?
!
mShared
:
!
mUnshared
;
}
union
{
gfxFontFamily
*
mUnshared
;
mozilla
:
:
fontlist
:
:
Family
*
mShared
;
}
;
bool
mIsShared
;
}
;
struct
FamilyAndGeneric
final
{
FamilyAndGeneric
(
)
:
mFamily
(
)
mGeneric
(
mozilla
:
:
StyleGenericFontFamily
(
0
)
)
{
}
FamilyAndGeneric
(
const
FamilyAndGeneric
&
aOther
)
=
default
;
explicit
FamilyAndGeneric
(
gfxFontFamily
*
aFamily
mozilla
:
:
StyleGenericFontFamily
aGeneric
=
mozilla
:
:
StyleGenericFontFamily
(
0
)
)
:
mFamily
(
aFamily
)
mGeneric
(
aGeneric
)
{
}
explicit
FamilyAndGeneric
(
mozilla
:
:
fontlist
:
:
Family
*
aFamily
mozilla
:
:
StyleGenericFontFamily
aGeneric
=
mozilla
:
:
StyleGenericFontFamily
(
0
)
)
:
mFamily
(
aFamily
)
mGeneric
(
aGeneric
)
{
}
explicit
FamilyAndGeneric
(
const
FontFamily
&
aFamily
mozilla
:
:
StyleGenericFontFamily
aGeneric
=
mozilla
:
:
StyleGenericFontFamily
(
0
)
)
:
mFamily
(
aFamily
)
mGeneric
(
aGeneric
)
{
}
bool
operator
=
=
(
const
FamilyAndGeneric
&
aOther
)
const
{
return
mFamily
=
=
aOther
.
mFamily
&
&
mGeneric
=
=
aOther
.
mGeneric
;
}
FontFamily
mFamily
;
mozilla
:
:
StyleGenericFontFamily
mGeneric
;
}
;
#
endif
