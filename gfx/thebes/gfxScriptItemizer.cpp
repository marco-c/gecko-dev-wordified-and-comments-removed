#
include
"
gfxScriptItemizer
.
h
"
#
include
"
mozilla
/
intl
/
UnicodeProperties
.
h
"
#
include
"
nsCharTraits
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
harfbuzz
/
hb
.
h
"
using
namespace
mozilla
:
:
intl
;
using
namespace
mozilla
:
:
unicode
;
#
define
MOD
(
sp
)
(
(
sp
)
%
PAREN_STACK_DEPTH
)
#
define
LIMIT_INC
(
sp
)
\
(
(
(
sp
)
<
PAREN_STACK_DEPTH
)
?
(
sp
)
+
1
:
PAREN_STACK_DEPTH
)
#
define
INC
(
sp
count
)
(
MOD
(
(
sp
)
+
(
count
)
)
)
#
define
INC1
(
sp
)
(
INC
(
sp
1
)
)
#
define
DEC
(
sp
count
)
(
MOD
(
(
sp
)
+
PAREN_STACK_DEPTH
-
(
count
)
)
)
#
define
DEC1
(
sp
)
(
DEC
(
sp
1
)
)
#
define
STACK_IS_EMPTY
(
)
(
pushCount
<
=
0
)
#
define
STACK_IS_NOT_EMPTY
(
)
(
!
STACK_IS_EMPTY
(
)
)
#
define
TOP
(
)
(
parenStack
[
parenSP
]
)
#
define
SYNC_FIXUP
(
)
(
fixupCount
=
0
)
void
gfxScriptItemizer
:
:
push
(
uint32_t
endPairChar
Script
newScriptCode
)
{
pushCount
=
LIMIT_INC
(
pushCount
)
;
fixupCount
=
LIMIT_INC
(
fixupCount
)
;
parenSP
=
INC1
(
parenSP
)
;
parenStack
[
parenSP
]
.
endPairChar
=
endPairChar
;
parenStack
[
parenSP
]
.
scriptCode
=
newScriptCode
;
}
void
gfxScriptItemizer
:
:
pop
(
)
{
if
(
STACK_IS_EMPTY
(
)
)
{
return
;
}
if
(
fixupCount
>
0
)
{
fixupCount
-
=
1
;
}
pushCount
-
=
1
;
parenSP
=
DEC1
(
parenSP
)
;
if
(
STACK_IS_EMPTY
(
)
)
{
parenSP
=
-
1
;
}
}
void
gfxScriptItemizer
:
:
fixup
(
Script
newScriptCode
)
{
int32_t
fixupSP
=
DEC
(
parenSP
fixupCount
)
;
while
(
fixupCount
-
-
>
0
)
{
fixupSP
=
INC1
(
fixupSP
)
;
parenStack
[
fixupSP
]
.
scriptCode
=
newScriptCode
;
}
}
static
inline
bool
CanMergeWithContext
(
Script
aScript
)
{
return
aScript
<
=
Script
:
:
INHERITED
|
|
aScript
=
=
Script
:
:
UNKNOWN
;
}
static
inline
bool
SameScript
(
Script
runScript
Script
currCharScript
uint32_t
aCurrCh
)
{
return
CanMergeWithContext
(
runScript
)
|
|
CanMergeWithContext
(
currCharScript
)
|
|
currCharScript
=
=
runScript
|
|
IsClusterExtender
(
aCurrCh
)
|
|
UnicodeProperties
:
:
HasScript
(
aCurrCh
runScript
)
;
}
gfxScriptItemizer
:
:
gfxScriptItemizer
(
const
char16_t
*
src
uint32_t
length
)
:
textPtr
(
src
)
textLength
(
length
)
{
reset
(
)
;
}
void
gfxScriptItemizer
:
:
SetText
(
const
char16_t
*
src
uint32_t
length
)
{
textPtr
=
src
;
textLength
=
length
;
reset
(
)
;
}
bool
gfxScriptItemizer
:
:
Next
(
uint32_t
&
aRunStart
uint32_t
&
aRunLimit
Script
&
aRunScript
)
{
if
(
scriptLimit
>
=
textLength
)
{
return
false
;
}
SYNC_FIXUP
(
)
;
scriptCode
=
Script
:
:
COMMON
;
Script
fallbackScript
=
Script
:
:
UNKNOWN
;
for
(
scriptStart
=
scriptLimit
;
scriptLimit
<
textLength
;
scriptLimit
+
=
1
)
{
uint32_t
ch
;
Script
sc
;
uint32_t
startOfChar
=
scriptLimit
;
ch
=
textPtr
[
scriptLimit
]
;
if
(
NS_IS_HIGH_SURROGATE
(
ch
)
&
&
scriptLimit
<
textLength
-
1
)
{
uint32_t
low
=
textPtr
[
scriptLimit
+
1
]
;
if
(
NS_IS_LOW_SURROGATE
(
low
)
)
{
ch
=
SURROGATE_TO_UCS4
(
ch
low
)
;
scriptLimit
+
=
1
;
}
}
uint8_t
gc
=
HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED
;
sc
=
UnicodeProperties
:
:
GetScriptCode
(
ch
)
;
if
(
sc
=
=
Script
:
:
COMMON
)
{
gc
=
GetGeneralCategory
(
ch
)
;
if
(
gc
=
=
HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION
)
{
uint32_t
endPairChar
=
UnicodeProperties
:
:
CharMirror
(
ch
)
;
if
(
endPairChar
!
=
ch
)
{
push
(
endPairChar
scriptCode
)
;
}
}
else
if
(
gc
=
=
HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION
&
&
UnicodeProperties
:
:
IsMirrored
(
ch
)
)
{
while
(
STACK_IS_NOT_EMPTY
(
)
&
&
TOP
(
)
.
endPairChar
!
=
ch
)
{
pop
(
)
;
}
if
(
STACK_IS_NOT_EMPTY
(
)
)
{
sc
=
TOP
(
)
.
scriptCode
;
}
}
}
if
(
sc
=
=
Script
:
:
HIRAGANA
)
{
sc
=
Script
:
:
KATAKANA
;
}
if
(
SameScript
(
scriptCode
sc
ch
)
)
{
if
(
scriptCode
=
=
Script
:
:
COMMON
)
{
if
(
!
CanMergeWithContext
(
sc
)
)
{
scriptCode
=
sc
;
fixup
(
scriptCode
)
;
}
else
if
(
fallbackScript
=
=
Script
:
:
UNKNOWN
)
{
UnicodeProperties
:
:
ScriptExtensionVector
extensions
;
auto
extResult
=
UnicodeProperties
:
:
GetExtensions
(
ch
extensions
)
;
if
(
extResult
.
isOk
(
)
)
{
Script
ext
=
Script
(
extensions
[
0
]
)
;
if
(
!
CanMergeWithContext
(
ext
)
)
{
fallbackScript
=
ext
;
}
}
}
}
if
(
gc
=
=
HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION
&
&
UnicodeProperties
:
:
IsMirrored
(
ch
)
)
{
pop
(
)
;
}
}
else
{
scriptLimit
=
startOfChar
;
break
;
}
}
aRunStart
=
scriptStart
;
aRunLimit
=
scriptLimit
;
if
(
scriptCode
=
=
Script
:
:
COMMON
&
&
fallbackScript
!
=
Script
:
:
UNKNOWN
)
{
aRunScript
=
fallbackScript
;
}
else
{
aRunScript
=
scriptCode
;
}
return
true
;
}
