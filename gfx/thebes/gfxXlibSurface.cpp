#
include
"
gfxXlibSurface
.
h
"
#
include
"
cairo
.
h
"
#
include
"
cairo
-
xlib
.
h
"
#
include
<
X11
/
Xlibint
.
h
>
#
undef
max
/
/
Xlibint
.
h
defines
this
and
it
breaks
std
:
:
max
#
undef
min
/
/
Xlibint
.
h
defines
this
and
it
breaks
std
:
:
min
#
undef
Data
#
include
"
nsTArray
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
CheckedInt
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
gfxXlibSurface
:
:
gfxXlibSurface
(
Display
*
dpy
Drawable
drawable
Visual
*
visual
)
:
mPixmapTaken
(
false
)
mDisplay
(
XlibDisplay
:
:
Borrow
(
dpy
)
)
mDrawable
(
drawable
)
{
const
gfx
:
:
IntSize
size
=
DoSizeQuery
(
)
;
cairo_surface_t
*
surf
=
cairo_xlib_surface_create
(
dpy
drawable
visual
size
.
width
size
.
height
)
;
Init
(
surf
)
;
}
gfxXlibSurface
:
:
gfxXlibSurface
(
Display
*
dpy
Drawable
drawable
Visual
*
visual
const
gfx
:
:
IntSize
&
size
)
:
gfxXlibSurface
(
XlibDisplay
:
:
Borrow
(
dpy
)
drawable
visual
size
)
{
}
gfxXlibSurface
:
:
gfxXlibSurface
(
const
std
:
:
shared_ptr
<
XlibDisplay
>
&
dpy
Drawable
drawable
Visual
*
visual
const
gfx
:
:
IntSize
&
size
)
:
mPixmapTaken
(
false
)
mDisplay
(
dpy
)
mDrawable
(
drawable
)
{
NS_ASSERTION
(
Factory
:
:
CheckSurfaceSize
(
size
XLIB_IMAGE_SIDE_SIZE_LIMIT
)
"
Bad
size
"
)
;
cairo_surface_t
*
surf
=
cairo_xlib_surface_create
(
*
dpy
drawable
visual
size
.
width
size
.
height
)
;
Init
(
surf
)
;
}
gfxXlibSurface
:
:
gfxXlibSurface
(
cairo_surface_t
*
csurf
)
:
mPixmapTaken
(
false
)
{
MOZ_ASSERT
(
cairo_surface_status
(
csurf
)
=
=
0
"
Not
expecting
an
error
surface
"
)
;
mDrawable
=
cairo_xlib_surface_get_drawable
(
csurf
)
;
mDisplay
=
XlibDisplay
:
:
Borrow
(
cairo_xlib_surface_get_display
(
csurf
)
)
;
Init
(
csurf
true
)
;
}
gfxXlibSurface
:
:
~
gfxXlibSurface
(
)
{
if
(
mPixmapTaken
)
{
XFreePixmap
(
*
mDisplay
mDrawable
)
;
}
}
static
Drawable
CreatePixmap
(
Screen
*
screen
const
gfx
:
:
IntSize
&
size
unsigned
int
depth
Drawable
relatedDrawable
)
{
if
(
!
Factory
:
:
CheckSurfaceSize
(
size
XLIB_IMAGE_SIDE_SIZE_LIMIT
)
)
return
X11None
;
if
(
relatedDrawable
=
=
X11None
)
{
relatedDrawable
=
RootWindowOfScreen
(
screen
)
;
}
Display
*
dpy
=
DisplayOfScreen
(
screen
)
;
return
XCreatePixmap
(
dpy
relatedDrawable
std
:
:
max
(
1
size
.
width
)
std
:
:
max
(
1
size
.
height
)
depth
)
;
}
void
gfxXlibSurface
:
:
TakePixmap
(
)
{
NS_ASSERTION
(
!
mPixmapTaken
"
I
already
own
the
Pixmap
!
"
)
;
mPixmapTaken
=
true
;
unsigned
int
bitDepth
=
cairo_xlib_surface_get_depth
(
CairoSurface
(
)
)
;
MOZ_ASSERT
(
(
bitDepth
%
8
)
=
=
0
"
Memory
used
not
recorded
correctly
"
)
;
gfx
:
:
IntSize
size
=
GetSize
(
)
;
CheckedInt32
totalBytes
=
CheckedInt32
(
size
.
width
)
*
CheckedInt32
(
size
.
height
)
*
(
bitDepth
/
8
)
;
MOZ_ASSERT
(
totalBytes
.
isValid
(
)
"
Did
not
expect
to
exceed
2Gb
image
"
)
;
if
(
totalBytes
.
isValid
(
)
)
{
RecordMemoryUsed
(
totalBytes
.
value
(
)
)
;
}
}
Drawable
gfxXlibSurface
:
:
ReleasePixmap
(
)
{
NS_ASSERTION
(
mPixmapTaken
"
I
don
'
t
own
the
Pixmap
!
"
)
;
mPixmapTaken
=
false
;
RecordMemoryFreed
(
)
;
return
mDrawable
;
}
static
cairo_user_data_key_t
gDestroyPixmapKey
;
struct
DestroyPixmapClosure
{
DestroyPixmapClosure
(
Drawable
d
Screen
*
s
)
:
mPixmap
(
d
)
mScreen
(
s
)
{
}
Drawable
mPixmap
;
Screen
*
mScreen
;
}
;
static
void
DestroyPixmap
(
void
*
data
)
{
DestroyPixmapClosure
*
closure
=
static_cast
<
DestroyPixmapClosure
*
>
(
data
)
;
XFreePixmap
(
DisplayOfScreen
(
closure
-
>
mScreen
)
closure
-
>
mPixmap
)
;
delete
closure
;
}
cairo_surface_t
*
gfxXlibSurface
:
:
CreateCairoSurface
(
Screen
*
screen
Visual
*
visual
const
gfx
:
:
IntSize
&
size
Drawable
relatedDrawable
)
{
Drawable
drawable
=
CreatePixmap
(
screen
size
DepthOfVisual
(
screen
visual
)
relatedDrawable
)
;
if
(
!
drawable
)
return
nullptr
;
cairo_surface_t
*
surface
=
cairo_xlib_surface_create
(
DisplayOfScreen
(
screen
)
drawable
visual
size
.
width
size
.
height
)
;
if
(
cairo_surface_status
(
surface
)
)
{
cairo_surface_destroy
(
surface
)
;
XFreePixmap
(
DisplayOfScreen
(
screen
)
drawable
)
;
return
nullptr
;
}
DestroyPixmapClosure
*
closure
=
new
DestroyPixmapClosure
(
drawable
screen
)
;
cairo_surface_set_user_data
(
surface
&
gDestroyPixmapKey
closure
DestroyPixmap
)
;
return
surface
;
}
already_AddRefed
<
gfxXlibSurface
>
gfxXlibSurface
:
:
Create
(
Screen
*
screen
Visual
*
visual
const
gfx
:
:
IntSize
&
size
Drawable
relatedDrawable
)
{
return
Create
(
XlibDisplay
:
:
Borrow
(
DisplayOfScreen
(
screen
)
)
screen
visual
size
relatedDrawable
)
;
}
;
already_AddRefed
<
gfxXlibSurface
>
gfxXlibSurface
:
:
Create
(
const
std
:
:
shared_ptr
<
XlibDisplay
>
&
display
Screen
*
screen
Visual
*
visual
const
gfx
:
:
IntSize
&
size
Drawable
relatedDrawable
)
{
MOZ_ASSERT
(
*
display
=
=
DisplayOfScreen
(
screen
)
)
;
Drawable
drawable
=
CreatePixmap
(
screen
size
DepthOfVisual
(
screen
visual
)
relatedDrawable
)
;
if
(
!
drawable
)
return
nullptr
;
RefPtr
<
gfxXlibSurface
>
result
=
new
gfxXlibSurface
(
display
drawable
visual
size
)
;
result
-
>
TakePixmap
(
)
;
if
(
result
-
>
CairoStatus
(
)
!
=
0
)
return
nullptr
;
return
result
.
forget
(
)
;
}
void
gfxXlibSurface
:
:
Finish
(
)
{
gfxASurface
:
:
Finish
(
)
;
}
const
gfx
:
:
IntSize
gfxXlibSurface
:
:
GetSize
(
)
const
{
if
(
!
mSurfaceValid
)
return
gfx
:
:
IntSize
(
0
0
)
;
return
gfx
:
:
IntSize
(
cairo_xlib_surface_get_width
(
mSurface
)
cairo_xlib_surface_get_height
(
mSurface
)
)
;
}
const
gfx
:
:
IntSize
gfxXlibSurface
:
:
DoSizeQuery
(
)
{
Window
root_ignore
;
int
x_ignore
y_ignore
;
unsigned
int
bwidth_ignore
width
height
depth
;
XGetGeometry
(
*
mDisplay
mDrawable
&
root_ignore
&
x_ignore
&
y_ignore
&
width
&
height
&
bwidth_ignore
&
depth
)
;
return
gfx
:
:
IntSize
(
width
height
)
;
}
class
DisplayTable
{
public
:
static
bool
GetColormapAndVisual
(
Screen
*
screen
Visual
*
visual
Colormap
*
colormap
Visual
*
*
visualForColormap
)
;
private
:
struct
ColormapEntry
{
Screen
*
mScreen
;
Visual
*
mVisual
;
Colormap
mColormap
;
}
;
class
DisplayInfo
{
public
:
explicit
DisplayInfo
(
Display
*
display
)
:
mDisplay
(
display
)
{
}
Display
*
mDisplay
;
nsTArray
<
ColormapEntry
>
mColormapEntries
;
}
;
class
FindDisplay
{
public
:
bool
Equals
(
const
DisplayInfo
&
info
const
Display
*
display
)
const
{
return
info
.
mDisplay
=
=
display
;
}
}
;
static
int
DisplayClosing
(
Display
*
display
XExtCodes
*
codes
)
;
nsTArray
<
DisplayInfo
>
mDisplays
;
static
DisplayTable
*
sDisplayTable
;
}
;
DisplayTable
*
DisplayTable
:
:
sDisplayTable
;
bool
DisplayTable
:
:
GetColormapAndVisual
(
Screen
*
aScreen
Visual
*
aVisual
Colormap
*
aColormap
Visual
*
*
aVisualForColormap
)
{
Display
*
display
=
DisplayOfScreen
(
aScreen
)
;
Visual
*
defaultVisual
=
DefaultVisualOfScreen
(
aScreen
)
;
if
(
aVisual
=
=
defaultVisual
)
{
*
aColormap
=
DefaultColormapOfScreen
(
aScreen
)
;
*
aVisualForColormap
=
defaultVisual
;
return
true
;
}
if
(
!
aVisual
|
|
aVisual
-
>
c_class
!
=
TrueColor
)
return
false
;
if
(
!
sDisplayTable
)
{
sDisplayTable
=
new
DisplayTable
(
)
;
}
nsTArray
<
DisplayInfo
>
*
displays
=
&
sDisplayTable
-
>
mDisplays
;
size_t
d
=
displays
-
>
IndexOf
(
display
0
FindDisplay
(
)
)
;
if
(
d
=
=
displays
-
>
NoIndex
)
{
d
=
displays
-
>
Length
(
)
;
XExtCodes
*
codes
=
XAddExtension
(
display
)
;
if
(
!
codes
)
return
false
;
XESetCloseDisplay
(
display
codes
-
>
extension
DisplayClosing
)
;
displays
-
>
AppendElement
(
display
)
;
}
nsTArray
<
ColormapEntry
>
*
entries
=
&
displays
-
>
ElementAt
(
d
)
.
mColormapEntries
;
for
(
uint32_t
i
=
0
;
i
<
entries
-
>
Length
(
)
;
+
+
i
)
{
const
ColormapEntry
&
entry
=
entries
-
>
ElementAt
(
i
)
;
if
(
aVisual
=
=
entry
.
mVisual
)
{
*
aColormap
=
entry
.
mColormap
;
*
aVisualForColormap
=
entry
.
mVisual
;
return
true
;
}
}
Colormap
colormap
=
XCreateColormap
(
display
RootWindowOfScreen
(
aScreen
)
aVisual
AllocNone
)
;
ColormapEntry
*
newEntry
=
entries
-
>
AppendElement
(
)
;
newEntry
-
>
mScreen
=
aScreen
;
newEntry
-
>
mVisual
=
aVisual
;
newEntry
-
>
mColormap
=
colormap
;
*
aColormap
=
colormap
;
*
aVisualForColormap
=
aVisual
;
return
true
;
}
int
DisplayTable
:
:
DisplayClosing
(
Display
*
display
XExtCodes
*
codes
)
{
sDisplayTable
-
>
mDisplays
.
RemoveElement
(
display
FindDisplay
(
)
)
;
if
(
sDisplayTable
-
>
mDisplays
.
Length
(
)
=
=
0
)
{
delete
sDisplayTable
;
sDisplayTable
=
nullptr
;
}
return
0
;
}
bool
gfxXlibSurface
:
:
GetColormapAndVisual
(
cairo_surface_t
*
aXlibSurface
Colormap
*
aColormap
Visual
*
*
aVisual
)
{
Screen
*
screen
=
cairo_xlib_surface_get_screen
(
aXlibSurface
)
;
Visual
*
visual
=
cairo_xlib_surface_get_visual
(
aXlibSurface
)
;
return
DisplayTable
:
:
GetColormapAndVisual
(
screen
visual
aColormap
aVisual
)
;
}
bool
gfxXlibSurface
:
:
GetColormapAndVisual
(
Colormap
*
aColormap
Visual
*
*
aVisual
)
{
if
(
!
mSurfaceValid
)
return
false
;
return
GetColormapAndVisual
(
CairoSurface
(
)
aColormap
aVisual
)
;
}
int
gfxXlibSurface
:
:
DepthOfVisual
(
const
Screen
*
screen
const
Visual
*
visual
)
{
for
(
int
d
=
0
;
d
<
screen
-
>
ndepths
;
d
+
+
)
{
const
Depth
&
d_info
=
screen
-
>
depths
[
d
]
;
if
(
visual
>
=
&
d_info
.
visuals
[
0
]
&
&
visual
<
&
d_info
.
visuals
[
d_info
.
nvisuals
]
)
return
d_info
.
depth
;
}
NS_ERROR
(
"
Visual
not
on
Screen
.
"
)
;
return
0
;
}
Visual
*
gfxXlibSurface
:
:
FindVisual
(
Screen
*
screen
gfxImageFormat
format
)
{
int
depth
;
unsigned
long
red_mask
green_mask
blue_mask
;
switch
(
format
)
{
case
gfx
:
:
SurfaceFormat
:
:
A8R8G8B8_UINT32
:
depth
=
32
;
red_mask
=
0xff0000
;
green_mask
=
0xff00
;
blue_mask
=
0xff
;
break
;
case
gfx
:
:
SurfaceFormat
:
:
X8R8G8B8_UINT32
:
depth
=
24
;
red_mask
=
0xff0000
;
green_mask
=
0xff00
;
blue_mask
=
0xff
;
break
;
case
gfx
:
:
SurfaceFormat
:
:
R5G6B5_UINT16
:
depth
=
16
;
red_mask
=
0xf800
;
green_mask
=
0x7e0
;
blue_mask
=
0x1f
;
break
;
case
gfx
:
:
SurfaceFormat
:
:
A8
:
default
:
return
nullptr
;
}
for
(
int
d
=
0
;
d
<
screen
-
>
ndepths
;
d
+
+
)
{
const
Depth
&
d_info
=
screen
-
>
depths
[
d
]
;
if
(
d_info
.
depth
!
=
depth
)
continue
;
for
(
int
v
=
0
;
v
<
d_info
.
nvisuals
;
v
+
+
)
{
Visual
*
visual
=
&
d_info
.
visuals
[
v
]
;
if
(
visual
-
>
c_class
=
=
TrueColor
&
&
visual
-
>
red_mask
=
=
red_mask
&
&
visual
-
>
green_mask
=
=
green_mask
&
&
visual
-
>
blue_mask
=
=
blue_mask
)
return
visual
;
}
}
return
nullptr
;
}
Screen
*
gfxXlibSurface
:
:
XScreen
(
)
{
return
cairo_xlib_surface_get_screen
(
CairoSurface
(
)
)
;
}
