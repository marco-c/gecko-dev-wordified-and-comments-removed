#
define
PANGO_ENABLE_BACKEND
#
define
PANGO_ENABLE_ENGINE
#
include
"
gfxPlatformGtk
.
h
"
#
include
<
gtk
/
gtk
.
h
>
#
include
<
fontconfig
/
fontconfig
.
h
>
#
include
"
base
/
task
.
h
"
#
include
"
base
/
thread
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
cairo
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxFcPlatformFontList
.
h
"
#
include
"
gfxConfig
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxImageSurface
.
h
"
#
include
"
gfxUserFontSet
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
gfxFT2FontBase
.
h
"
#
include
"
gfxTextRun
.
h
"
#
include
"
GLContextProvider
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
FontPropertyTypes
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_layers
.
h
"
#
include
"
nsMathUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
VsyncSource
.
h
"
#
ifdef
MOZ_X11
#
include
<
gdk
/
gdkx
.
h
>
#
include
"
cairo
-
xlib
.
h
"
#
include
"
gfxXlibSurface
.
h
"
#
include
"
GLContextGLX
.
h
"
#
include
"
GLXLibrary
.
h
"
#
include
"
mozilla
/
X11Util
.
h
"
#
if
defined
(
__APPLE__
)
&
&
defined
(
Status
)
#
undef
Status
#
endif
#
endif
#
ifdef
MOZ_WAYLAND
#
include
<
gdk
/
gdkwayland
.
h
>
#
include
"
mozilla
/
widget
/
nsWaylandDisplay
.
h
"
#
include
"
mozilla
/
widget
/
DMABufLibWrapper
.
h
"
#
include
"
mozilla
/
StaticPrefs_media
.
h
"
#
endif
#
define
GDK_PIXMAP_SIZE_MAX
32767
#
define
GFX_PREF_MAX_GENERIC_SUBSTITUTIONS
\
"
gfx
.
font_rendering
.
fontconfig
.
max_generic_substitutions
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
unicode
;
using
namespace
mozilla
:
:
widget
;
using
mozilla
:
:
dom
:
:
SystemFontListEntry
;
static
FT_Library
gPlatformFTLibrary
=
nullptr
;
gfxPlatformGtk
:
:
gfxPlatformGtk
(
)
{
if
(
!
gfxPlatform
:
:
IsHeadless
(
)
)
{
gtk_init
(
nullptr
nullptr
)
;
}
mMaxGenericSubstitutions
=
UNINITIALIZED_VALUE
;
mIsX11Display
=
gfxPlatform
:
:
IsHeadless
(
)
?
false
:
GDK_IS_X11_DISPLAY
(
gdk_display_get_default
(
)
)
;
if
(
XRE_IsParentProcess
(
)
)
{
#
ifdef
MOZ_X11
if
(
mIsX11Display
&
&
mozilla
:
:
Preferences
:
:
GetBool
(
"
gfx
.
xrender
.
enabled
"
)
)
{
gfxVars
:
:
SetUseXRender
(
true
)
;
}
#
endif
if
(
IsWaylandDisplay
(
)
|
|
(
mIsX11Display
&
&
PR_GetEnv
(
"
MOZ_X11_EGL
"
)
)
)
{
gfxVars
:
:
SetUseEGL
(
true
)
;
}
}
InitBackendPrefs
(
GetBackendPrefs
(
)
)
;
#
ifdef
MOZ_WAYLAND
mUseWebGLDmabufBackend
=
gfxVars
:
:
UseEGL
(
)
&
&
GetDMABufDevice
(
)
-
>
IsDMABufWebGLEnabled
(
)
;
#
endif
gPlatformFTLibrary
=
Factory
:
:
NewFTLibrary
(
)
;
MOZ_RELEASE_ASSERT
(
gPlatformFTLibrary
)
;
Factory
:
:
SetFTLibrary
(
gPlatformFTLibrary
)
;
}
gfxPlatformGtk
:
:
~
gfxPlatformGtk
(
)
{
Factory
:
:
ReleaseFTLibrary
(
gPlatformFTLibrary
)
;
gPlatformFTLibrary
=
nullptr
;
}
void
gfxPlatformGtk
:
:
FlushContentDrawing
(
)
{
if
(
gfxVars
:
:
UseXRender
(
)
)
{
XFlush
(
DefaultXDisplay
(
)
)
;
}
}
void
gfxPlatformGtk
:
:
InitPlatformGPUProcessPrefs
(
)
{
#
ifdef
MOZ_WAYLAND
if
(
IsWaylandDisplay
(
)
)
{
FeatureState
&
gpuProc
=
gfxConfig
:
:
GetFeature
(
Feature
:
:
GPU_PROCESS
)
;
gpuProc
.
ForceDisable
(
FeatureStatus
:
:
Blocked
"
Wayland
does
not
work
in
the
GPU
process
"
"
FEATURE_FAILURE_WAYLAND
"
_ns
)
;
}
#
endif
}
already_AddRefed
<
gfxASurface
>
gfxPlatformGtk
:
:
CreateOffscreenSurface
(
const
IntSize
&
aSize
gfxImageFormat
aFormat
)
{
if
(
!
Factory
:
:
AllowedSurfaceSize
(
aSize
)
)
{
return
nullptr
;
}
RefPtr
<
gfxASurface
>
newSurface
;
bool
needsClear
=
true
;
#
ifdef
MOZ_X11
GdkScreen
*
gdkScreen
=
gdk_screen_get_default
(
)
;
if
(
gdkScreen
)
{
if
(
gfxVars
:
:
UseXRender
(
)
&
&
!
UseImageOffscreenSurfaces
(
)
)
{
Screen
*
screen
=
gdk_x11_screen_get_xscreen
(
gdkScreen
)
;
XRenderPictFormat
*
xrenderFormat
=
gfxXlibSurface
:
:
FindRenderFormat
(
DisplayOfScreen
(
screen
)
aFormat
)
;
if
(
xrenderFormat
)
{
newSurface
=
gfxXlibSurface
:
:
Create
(
screen
xrenderFormat
aSize
)
;
}
}
else
{
newSurface
=
new
gfxImageSurface
(
aSize
aFormat
)
;
needsClear
=
false
;
}
}
#
endif
if
(
!
newSurface
)
{
newSurface
=
new
gfxImageSurface
(
aSize
aFormat
)
;
}
if
(
newSurface
-
>
CairoStatus
(
)
)
{
newSurface
=
nullptr
;
}
if
(
newSurface
&
&
needsClear
)
{
gfxUtils
:
:
ClearThebesSurface
(
newSurface
)
;
}
return
newSurface
.
forget
(
)
;
}
nsresult
gfxPlatformGtk
:
:
GetFontList
(
nsAtom
*
aLangGroup
const
nsACString
&
aGenericFamily
nsTArray
<
nsString
>
&
aListOfFonts
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
GetFontList
(
aLangGroup
aGenericFamily
aListOfFonts
)
;
return
NS_OK
;
}
nsresult
gfxPlatformGtk
:
:
UpdateFontList
(
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
UpdateFontList
(
)
;
return
NS_OK
;
}
static
const
char
kFontDejaVuSans
[
]
=
"
DejaVu
Sans
"
;
static
const
char
kFontDejaVuSerif
[
]
=
"
DejaVu
Serif
"
;
static
const
char
kFontFreeSans
[
]
=
"
FreeSans
"
;
static
const
char
kFontFreeSerif
[
]
=
"
FreeSerif
"
;
static
const
char
kFontTakaoPGothic
[
]
=
"
TakaoPGothic
"
;
static
const
char
kFontTwemojiMozilla
[
]
=
"
Twemoji
Mozilla
"
;
static
const
char
kFontDroidSansFallback
[
]
=
"
Droid
Sans
Fallback
"
;
static
const
char
kFontWenQuanYiMicroHei
[
]
=
"
WenQuanYi
Micro
Hei
"
;
static
const
char
kFontNanumGothic
[
]
=
"
NanumGothic
"
;
static
const
char
kFontSymbola
[
]
=
"
Symbola
"
;
void
gfxPlatformGtk
:
:
GetCommonFallbackFonts
(
uint32_t
aCh
Script
aRunScript
eFontPresentation
aPresentation
nsTArray
<
const
char
*
>
&
aFontList
)
{
if
(
PrefersColor
(
aPresentation
)
)
{
aFontList
.
AppendElement
(
kFontTwemojiMozilla
)
;
}
aFontList
.
AppendElement
(
kFontDejaVuSerif
)
;
aFontList
.
AppendElement
(
kFontFreeSerif
)
;
aFontList
.
AppendElement
(
kFontDejaVuSans
)
;
aFontList
.
AppendElement
(
kFontFreeSans
)
;
aFontList
.
AppendElement
(
kFontSymbola
)
;
if
(
aCh
>
=
0x3000
&
&
(
(
aCh
<
0xe000
)
|
|
(
aCh
>
=
0xf900
&
&
aCh
<
0xfff0
)
|
|
(
(
aCh
>
>
16
)
=
=
2
)
)
)
{
aFontList
.
AppendElement
(
kFontTakaoPGothic
)
;
aFontList
.
AppendElement
(
kFontDroidSansFallback
)
;
aFontList
.
AppendElement
(
kFontWenQuanYiMicroHei
)
;
aFontList
.
AppendElement
(
kFontNanumGothic
)
;
}
}
void
gfxPlatformGtk
:
:
ReadSystemFontList
(
nsTArray
<
SystemFontListEntry
>
*
retValue
)
{
gfxFcPlatformFontList
:
:
PlatformFontList
(
)
-
>
ReadSystemFontList
(
retValue
)
;
}
gfxPlatformFontList
*
gfxPlatformGtk
:
:
CreatePlatformFontList
(
)
{
gfxPlatformFontList
*
list
=
new
gfxFcPlatformFontList
(
)
;
if
(
NS_SUCCEEDED
(
list
-
>
InitFontList
(
)
)
)
{
return
list
;
}
gfxPlatformFontList
:
:
Shutdown
(
)
;
return
nullptr
;
}
static
int32_t
sDPI
=
0
;
int32_t
gfxPlatformGtk
:
:
GetFontScaleDPI
(
)
{
if
(
MOZ_UNLIKELY
(
!
sDPI
)
)
{
GdkScreen
*
screen
=
gdk_screen_get_default
(
)
;
gtk_settings_get_for_screen
(
screen
)
;
sDPI
=
int32_t
(
round
(
gdk_screen_get_resolution
(
screen
)
)
)
;
if
(
sDPI
<
=
0
)
{
sDPI
=
96
;
}
}
return
sDPI
;
}
double
gfxPlatformGtk
:
:
GetFontScaleFactor
(
)
{
int32_t
dpi
=
GetFontScaleDPI
(
)
;
if
(
dpi
<
120
)
{
return
1
.
0
;
}
if
(
dpi
<
132
)
{
return
1
.
25
;
}
if
(
dpi
<
168
)
{
return
1
.
5
;
}
return
round
(
dpi
/
96
.
0
)
;
}
bool
gfxPlatformGtk
:
:
UseImageOffscreenSurfaces
(
)
{
return
GetDefaultContentBackend
(
)
!
=
mozilla
:
:
gfx
:
:
BackendType
:
:
CAIRO
|
|
StaticPrefs
:
:
layers_use_image_offscreen_surfaces_AtStartup
(
)
;
}
gfxImageFormat
gfxPlatformGtk
:
:
GetOffscreenFormat
(
)
{
GdkScreen
*
screen
=
gdk_screen_get_default
(
)
;
if
(
screen
&
&
gdk_visual_get_depth
(
gdk_visual_get_system
(
)
)
=
=
16
)
{
return
SurfaceFormat
:
:
R5G6B5_UINT16
;
}
return
SurfaceFormat
:
:
X8R8G8B8_UINT32
;
}
void
gfxPlatformGtk
:
:
FontsPrefsChanged
(
const
char
*
aPref
)
{
if
(
strcmp
(
GFX_PREF_MAX_GENERIC_SUBSTITUTIONS
aPref
)
)
{
gfxPlatform
:
:
FontsPrefsChanged
(
aPref
)
;
return
;
}
mMaxGenericSubstitutions
=
UNINITIALIZED_VALUE
;
gfxFcPlatformFontList
*
pfl
=
gfxFcPlatformFontList
:
:
PlatformFontList
(
)
;
pfl
-
>
ClearGenericMappings
(
)
;
FlushFontAndWordCaches
(
)
;
}
uint32_t
gfxPlatformGtk
:
:
MaxGenericSubstitions
(
)
{
if
(
mMaxGenericSubstitutions
=
=
UNINITIALIZED_VALUE
)
{
mMaxGenericSubstitutions
=
Preferences
:
:
GetInt
(
GFX_PREF_MAX_GENERIC_SUBSTITUTIONS
3
)
;
if
(
mMaxGenericSubstitutions
<
0
)
{
mMaxGenericSubstitutions
=
3
;
}
}
return
uint32_t
(
mMaxGenericSubstitutions
)
;
}
bool
gfxPlatformGtk
:
:
AccelerateLayersByDefault
(
)
{
return
true
;
}
#
if
defined
(
MOZ_X11
)
static
nsTArray
<
uint8_t
>
GetDisplayICCProfile
(
Display
*
dpy
Window
&
root
)
{
const
char
kIccProfileAtomName
[
]
=
"
_ICC_PROFILE
"
;
Atom
iccAtom
=
XInternAtom
(
dpy
kIccProfileAtomName
TRUE
)
;
if
(
!
iccAtom
)
{
return
nsTArray
<
uint8_t
>
(
)
;
}
Atom
retAtom
;
int
retFormat
;
unsigned
long
retLength
retAfter
;
unsigned
char
*
retProperty
;
if
(
XGetWindowProperty
(
dpy
root
iccAtom
0
INT_MAX
X11False
AnyPropertyType
&
retAtom
&
retFormat
&
retLength
&
retAfter
&
retProperty
)
!
=
Success
)
{
return
nsTArray
<
uint8_t
>
(
)
;
}
nsTArray
<
uint8_t
>
result
;
if
(
retLength
>
0
)
{
result
.
AppendElements
(
static_cast
<
uint8_t
*
>
(
retProperty
)
retLength
)
;
}
XFree
(
retProperty
)
;
return
result
;
}
nsTArray
<
uint8_t
>
gfxPlatformGtk
:
:
GetPlatformCMSOutputProfileData
(
)
{
nsTArray
<
uint8_t
>
prefProfileData
=
GetPrefCMSOutputProfileData
(
)
;
if
(
!
prefProfileData
.
IsEmpty
(
)
)
{
return
prefProfileData
;
}
if
(
!
mIsX11Display
)
{
return
nsTArray
<
uint8_t
>
(
)
;
}
GdkDisplay
*
display
=
gdk_display_get_default
(
)
;
Display
*
dpy
=
GDK_DISPLAY_XDISPLAY
(
display
)
;
if
(
!
dpy
)
{
return
nsTArray
<
uint8_t
>
(
)
;
}
Window
root
=
gdk_x11_get_default_root_xwindow
(
)
;
nsTArray
<
uint8_t
>
iccResult
=
GetDisplayICCProfile
(
dpy
root
)
;
if
(
!
iccResult
.
IsEmpty
(
)
)
{
return
iccResult
;
}
const
char
kEdid1AtomName
[
]
=
"
XFree86_DDC_EDID1_RAWDATA
"
;
Atom
edidAtom
=
XInternAtom
(
dpy
kEdid1AtomName
TRUE
)
;
if
(
!
edidAtom
)
{
return
nsTArray
<
uint8_t
>
(
)
;
}
Atom
retAtom
;
int
retFormat
;
unsigned
long
retLength
retAfter
;
unsigned
char
*
retProperty
;
if
(
XGetWindowProperty
(
dpy
root
edidAtom
0
32
X11False
AnyPropertyType
&
retAtom
&
retFormat
&
retLength
&
retAfter
&
retProperty
)
!
=
Success
)
{
return
nsTArray
<
uint8_t
>
(
)
;
}
if
(
retLength
!
=
128
)
{
return
nsTArray
<
uint8_t
>
(
)
;
}
float
gamma
=
(
100
+
retProperty
[
0x17
]
)
/
100
.
0f
;
qcms_CIE_xyY
whitePoint
;
whitePoint
.
x
=
(
(
retProperty
[
0x21
]
<
<
2
)
|
(
retProperty
[
0x1a
]
>
>
2
&
3
)
)
/
1024
.
0
;
whitePoint
.
y
=
(
(
retProperty
[
0x22
]
<
<
2
)
|
(
retProperty
[
0x1a
]
>
>
0
&
3
)
)
/
1024
.
0
;
whitePoint
.
Y
=
1
.
0
;
qcms_CIE_xyYTRIPLE
primaries
;
primaries
.
red
.
x
=
(
(
retProperty
[
0x1b
]
<
<
2
)
|
(
retProperty
[
0x19
]
>
>
6
&
3
)
)
/
1024
.
0
;
primaries
.
red
.
y
=
(
(
retProperty
[
0x1c
]
<
<
2
)
|
(
retProperty
[
0x19
]
>
>
4
&
3
)
)
/
1024
.
0
;
primaries
.
red
.
Y
=
1
.
0
;
primaries
.
green
.
x
=
(
(
retProperty
[
0x1d
]
<
<
2
)
|
(
retProperty
[
0x19
]
>
>
2
&
3
)
)
/
1024
.
0
;
primaries
.
green
.
y
=
(
(
retProperty
[
0x1e
]
<
<
2
)
|
(
retProperty
[
0x19
]
>
>
0
&
3
)
)
/
1024
.
0
;
primaries
.
green
.
Y
=
1
.
0
;
primaries
.
blue
.
x
=
(
(
retProperty
[
0x1f
]
<
<
2
)
|
(
retProperty
[
0x1a
]
>
>
6
&
3
)
)
/
1024
.
0
;
primaries
.
blue
.
y
=
(
(
retProperty
[
0x20
]
<
<
2
)
|
(
retProperty
[
0x1a
]
>
>
4
&
3
)
)
/
1024
.
0
;
primaries
.
blue
.
Y
=
1
.
0
;
XFree
(
retProperty
)
;
void
*
mem
=
nullptr
;
size_t
size
=
0
;
qcms_data_create_rgb_with_gamma
(
whitePoint
primaries
gamma
&
mem
&
size
)
;
if
(
!
mem
)
{
return
nsTArray
<
uint8_t
>
(
)
;
}
nsTArray
<
uint8_t
>
result
;
result
.
AppendElements
(
static_cast
<
uint8_t
*
>
(
mem
)
size
)
;
free
(
mem
)
;
return
result
;
}
#
else
nsTArray
<
uint8_t
>
gfxPlatformGtk
:
:
GetPlatformCMSOutputProfileData
(
)
{
return
nsTArray
<
uint8_t
>
(
)
;
}
#
endif
bool
gfxPlatformGtk
:
:
CheckVariationFontSupport
(
)
{
FT_Int
major
minor
patch
;
FT_Library_Version
(
Factory
:
:
GetFTLibrary
(
)
&
major
&
minor
&
patch
)
;
return
major
*
1000000
+
minor
*
1000
+
patch
>
=
2007001
;
}
#
ifdef
MOZ_X11
class
GtkVsyncSource
final
:
public
VsyncSource
{
public
:
GtkVsyncSource
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mGlobalDisplay
=
new
GLXDisplay
(
)
;
}
virtual
~
GtkVsyncSource
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
virtual
Display
&
GetGlobalDisplay
(
)
override
{
return
*
mGlobalDisplay
;
}
class
GLXDisplay
final
:
public
VsyncSource
:
:
Display
{
public
:
GLXDisplay
(
)
:
mGLContext
(
nullptr
)
mXDisplay
(
nullptr
)
mSetupLock
(
"
GLXVsyncSetupLock
"
)
mVsyncThread
(
"
GLXVsyncThread
"
)
mVsyncTask
(
nullptr
)
mVsyncEnabledLock
(
"
GLXVsyncEnabledLock
"
)
mVsyncEnabled
(
false
)
{
}
bool
Setup
(
)
{
MonitorAutoLock
lock
(
mSetupLock
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mVsyncThread
.
Start
(
)
)
return
false
;
RefPtr
<
Runnable
>
vsyncSetup
=
NewRunnableMethod
(
"
GtkVsyncSource
:
:
GLXDisplay
:
:
SetupGLContext
"
this
&
GLXDisplay
:
:
SetupGLContext
)
;
mVsyncThread
.
message_loop
(
)
-
>
PostTask
(
vsyncSetup
.
forget
(
)
)
;
lock
.
Wait
(
)
;
return
mGLContext
!
=
nullptr
;
}
void
SetupGLContext
(
)
{
MonitorAutoLock
lock
(
mSetupLock
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
mGLContext
"
GLContext
already
setup
!
"
)
;
mXDisplay
=
XOpenDisplay
(
nullptr
)
;
if
(
!
mXDisplay
)
{
lock
.
NotifyAll
(
)
;
return
;
}
Window
root
=
DefaultRootWindow
(
mXDisplay
)
;
int
screen
=
DefaultScreen
(
mXDisplay
)
;
ScopedXFree
<
GLXFBConfig
>
cfgs
;
GLXFBConfig
config
;
int
visid
;
bool
forWebRender
=
false
;
if
(
!
gl
:
:
GLContextGLX
:
:
FindFBConfigForWindow
(
mXDisplay
screen
root
&
cfgs
&
config
&
visid
forWebRender
)
)
{
lock
.
NotifyAll
(
)
;
return
;
}
mGLContext
=
gl
:
:
GLContextGLX
:
:
CreateGLContext
(
{
}
mXDisplay
root
config
false
nullptr
)
;
if
(
!
mGLContext
)
{
lock
.
NotifyAll
(
)
;
return
;
}
mGLContext
-
>
MakeCurrent
(
)
;
unsigned
int
syncCounter
=
0
;
if
(
gl
:
:
sGLXLibrary
.
fGetVideoSync
(
&
syncCounter
)
!
=
0
)
{
mGLContext
=
nullptr
;
}
lock
.
NotifyAll
(
)
;
}
virtual
void
EnableVsync
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mGLContext
"
GLContext
not
setup
!
"
)
;
MonitorAutoLock
lock
(
mVsyncEnabledLock
)
;
if
(
mVsyncEnabled
)
{
return
;
}
mVsyncEnabled
=
true
;
if
(
!
mVsyncTask
)
{
mVsyncTask
=
NewRunnableMethod
(
"
GtkVsyncSource
:
:
GLXDisplay
:
:
RunVsync
"
this
&
GLXDisplay
:
:
RunVsync
)
;
RefPtr
<
Runnable
>
addrefedTask
=
mVsyncTask
;
mVsyncThread
.
message_loop
(
)
-
>
PostTask
(
addrefedTask
.
forget
(
)
)
;
}
}
virtual
void
DisableVsync
(
)
override
{
MonitorAutoLock
lock
(
mVsyncEnabledLock
)
;
mVsyncEnabled
=
false
;
}
virtual
bool
IsVsyncEnabled
(
)
override
{
MonitorAutoLock
lock
(
mVsyncEnabledLock
)
;
return
mVsyncEnabled
;
}
virtual
void
Shutdown
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
DisableVsync
(
)
;
RefPtr
<
Runnable
>
shutdownTask
=
NewRunnableMethod
(
"
GtkVsyncSource
:
:
GLXDisplay
:
:
Cleanup
"
this
&
GLXDisplay
:
:
Cleanup
)
;
mVsyncThread
.
message_loop
(
)
-
>
PostTask
(
shutdownTask
.
forget
(
)
)
;
mVsyncThread
.
Stop
(
)
;
}
private
:
virtual
~
GLXDisplay
(
)
=
default
;
void
RunVsync
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mGLContext
-
>
MakeCurrent
(
)
;
unsigned
int
syncCounter
=
0
;
gl
:
:
sGLXLibrary
.
fGetVideoSync
(
&
syncCounter
)
;
for
(
;
;
)
{
{
MonitorAutoLock
lock
(
mVsyncEnabledLock
)
;
if
(
!
mVsyncEnabled
)
{
mVsyncTask
=
nullptr
;
return
;
}
}
TimeStamp
lastVsync
=
TimeStamp
:
:
Now
(
)
;
bool
useSoftware
=
false
;
unsigned
int
nextSync
=
syncCounter
+
1
;
int
status
;
if
(
(
status
=
gl
:
:
sGLXLibrary
.
fWaitVideoSync
(
2
nextSync
%
2
&
syncCounter
)
)
!
=
0
)
{
gfxWarningOnce
(
)
<
<
"
glXWaitVideoSync
returned
"
<
<
status
;
useSoftware
=
true
;
}
if
(
syncCounter
=
=
(
nextSync
-
1
)
)
{
gfxWarningOnce
(
)
<
<
"
glXWaitVideoSync
failed
to
increment
the
sync
counter
.
"
;
useSoftware
=
true
;
}
if
(
useSoftware
)
{
double
remaining
=
(
1000
.
f
/
60
.
f
)
-
(
TimeStamp
:
:
Now
(
)
-
lastVsync
)
.
ToMilliseconds
(
)
;
if
(
remaining
>
0
)
{
PlatformThread
:
:
Sleep
(
remaining
)
;
}
}
lastVsync
=
TimeStamp
:
:
Now
(
)
;
TimeStamp
outputTime
=
lastVsync
+
GetVsyncRate
(
)
;
NotifyVsync
(
lastVsync
outputTime
)
;
}
}
void
Cleanup
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mGLContext
=
nullptr
;
if
(
mXDisplay
)
XCloseDisplay
(
mXDisplay
)
;
}
RefPtr
<
gl
:
:
GLContextGLX
>
mGLContext
;
_XDisplay
*
mXDisplay
;
Monitor
mSetupLock
;
base
:
:
Thread
mVsyncThread
;
RefPtr
<
Runnable
>
mVsyncTask
;
Monitor
mVsyncEnabledLock
;
bool
mVsyncEnabled
;
}
;
private
:
RefPtr
<
GLXDisplay
>
mGlobalDisplay
;
}
;
already_AddRefed
<
gfx
:
:
VsyncSource
>
gfxPlatformGtk
:
:
CreateHardwareVsyncSource
(
)
{
#
ifdef
MOZ_WAYLAND
if
(
IsWaylandDisplay
(
)
)
{
return
gfxPlatform
:
:
CreateHardwareVsyncSource
(
)
;
}
#
endif
if
(
gfxConfig
:
:
IsEnabled
(
Feature
:
:
HW_COMPOSITING
)
)
{
bool
useGlxVsync
=
false
;
if
(
!
gfxVars
:
:
UseEGL
(
)
)
{
useGlxVsync
=
gl
:
:
sGLXLibrary
.
SupportsVideoSync
(
)
;
}
if
(
useGlxVsync
)
{
RefPtr
<
VsyncSource
>
vsyncSource
=
new
GtkVsyncSource
(
)
;
VsyncSource
:
:
Display
&
display
=
vsyncSource
-
>
GetGlobalDisplay
(
)
;
if
(
!
static_cast
<
GtkVsyncSource
:
:
GLXDisplay
&
>
(
display
)
.
Setup
(
)
)
{
NS_WARNING
(
"
Failed
to
setup
GLContext
falling
back
to
software
vsync
.
"
)
;
return
gfxPlatform
:
:
CreateHardwareVsyncSource
(
)
;
}
return
vsyncSource
.
forget
(
)
;
}
NS_WARNING
(
"
SGI_video_sync
unsupported
.
Falling
back
to
software
vsync
.
"
)
;
}
return
gfxPlatform
:
:
CreateHardwareVsyncSource
(
)
;
}
#
endif
#
ifdef
MOZ_WAYLAND
bool
gfxPlatformGtk
:
:
UseDMABufTextures
(
)
{
return
gfxVars
:
:
UseEGL
(
)
&
&
GetDMABufDevice
(
)
-
>
IsDMABufTexturesEnabled
(
)
;
}
bool
gfxPlatformGtk
:
:
UseDMABufVideoTextures
(
)
{
return
gfxVars
:
:
UseEGL
(
)
&
&
(
GetDMABufDevice
(
)
-
>
IsDMABufVideoTexturesEnabled
(
)
|
|
StaticPrefs
:
:
media_ffmpeg_vaapi_enabled
(
)
)
;
}
bool
gfxPlatformGtk
:
:
UseHardwareVideoDecoding
(
)
{
return
gfxPlatform
:
:
CanUseHardwareVideoDecoding
(
)
&
&
StaticPrefs
:
:
media_ffmpeg_vaapi_enabled
(
)
;
}
bool
gfxPlatformGtk
:
:
UseDRMVAAPIDisplay
(
)
{
return
IsX11Display
(
)
|
|
GetDMABufDevice
(
)
-
>
IsDRMVAAPIDisplayEnabled
(
)
;
}
#
endif
