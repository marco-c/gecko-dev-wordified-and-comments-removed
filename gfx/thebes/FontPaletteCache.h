#
ifndef
FONT_PALETTE_CACHE_H
#
define
FONT_PALETTE_CACHE_H
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
MruCache
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsTArray
.
h
"
#
include
<
utility
>
class
gfxFontEntry
;
namespace
mozilla
:
:
gfx
{
class
FontPaletteValueSet
;
class
FontPalette
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
FontPalette
)
;
public
:
FontPalette
(
)
=
default
;
explicit
FontPalette
(
nsTArray
<
mozilla
:
:
gfx
:
:
sRGBColor
>
&
&
aColors
)
:
mColors
(
std
:
:
move
(
aColors
)
)
{
}
const
nsTArray
<
mozilla
:
:
gfx
:
:
sRGBColor
>
*
Colors
(
)
const
{
return
&
mColors
;
}
private
:
~
FontPalette
(
)
=
default
;
nsTArray
<
mozilla
:
:
gfx
:
:
sRGBColor
>
mColors
;
}
;
using
CacheKey
=
std
:
:
pair
<
RefPtr
<
gfxFontEntry
>
RefPtr
<
nsAtom
>
>
;
struct
CacheData
{
CacheKey
mKey
;
RefPtr
<
FontPalette
>
mPalette
;
}
;
class
PaletteCache
:
public
mozilla
:
:
MruCache
<
CacheKey
CacheData
PaletteCache
>
{
public
:
explicit
PaletteCache
(
const
FontPaletteValueSet
*
aPaletteValueSet
=
nullptr
)
:
mPaletteValueSet
(
aPaletteValueSet
)
{
}
void
SetPaletteValueSet
(
const
FontPaletteValueSet
*
aSet
)
;
already_AddRefed
<
FontPalette
>
GetPaletteFor
(
gfxFontEntry
*
aFontEntry
nsAtom
*
aPaletteName
)
;
static
mozilla
:
:
HashNumber
Hash
(
const
CacheKey
&
aKey
)
{
return
mozilla
:
:
HashGeneric
(
aKey
.
first
.
get
(
)
aKey
.
second
.
get
(
)
)
;
}
static
bool
Match
(
const
CacheKey
&
aKey
const
CacheData
&
aVal
)
{
return
aVal
.
mKey
=
=
aKey
;
}
protected
:
const
FontPaletteValueSet
*
mPaletteValueSet
=
nullptr
;
}
;
}
#
endif
