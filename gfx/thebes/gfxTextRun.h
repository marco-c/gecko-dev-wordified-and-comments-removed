#
ifndef
GFX_TEXTRUN_H
#
define
GFX_TEXTRUN_H
#
include
<
stdint
.
h
>
#
include
"
gfxTypes
.
h
"
#
include
"
gfxPoint
.
h
"
#
include
"
gfxFont
.
h
"
#
include
"
gfxFontConstants
.
h
"
#
include
"
gfxSkipChars
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxPlatformFontList
.
h
"
#
include
"
gfxUserFontSet
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTextFrameUtils
.
h
"
#
include
"
DrawMode
.
h
"
#
include
"
harfbuzz
/
hb
.
h
"
#
include
"
nsUnicodeScriptCodes
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
X11UndefineNone
.
h
"
#
ifdef
DEBUG
#
include
<
stdio
.
h
>
#
endif
class
gfxContext
;
class
gfxFontGroup
;
class
nsAtom
;
class
nsLanguageAtomService
;
class
gfxMissingFontRecorder
;
namespace
mozilla
{
class
PostTraversalTask
;
class
SVGContextPaint
;
enum
class
StyleHyphens
:
uint8_t
;
}
;
struct
gfxTextRunDrawCallbacks
{
explicit
gfxTextRunDrawCallbacks
(
bool
aShouldPaintSVGGlyphs
=
false
)
:
mShouldPaintSVGGlyphs
(
aShouldPaintSVGGlyphs
)
{
}
virtual
void
NotifyGlyphPathEmitted
(
)
=
0
;
bool
mShouldPaintSVGGlyphs
;
}
;
class
gfxTextRun
:
public
gfxShapedText
{
NS_INLINE_DECL_REFCOUNTING
(
gfxTextRun
)
;
protected
:
void
operator
delete
(
void
*
p
)
{
free
(
p
)
;
}
virtual
~
gfxTextRun
(
)
;
public
:
typedef
gfxFont
:
:
RunMetrics
Metrics
;
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
bool
IsClusterStart
(
uint32_t
aPos
)
const
{
MOZ_ASSERT
(
aPos
<
GetLength
(
)
)
;
return
mCharacterGlyphs
[
aPos
]
.
IsClusterStart
(
)
;
}
bool
IsLigatureGroupStart
(
uint32_t
aPos
)
const
{
MOZ_ASSERT
(
aPos
<
GetLength
(
)
)
;
return
mCharacterGlyphs
[
aPos
]
.
IsLigatureGroupStart
(
)
;
}
bool
CanBreakLineBefore
(
uint32_t
aPos
)
const
{
return
CanBreakBefore
(
aPos
)
=
=
CompressedGlyph
:
:
FLAG_BREAK_TYPE_NORMAL
;
}
bool
CanHyphenateBefore
(
uint32_t
aPos
)
const
{
return
CanBreakBefore
(
aPos
)
=
=
CompressedGlyph
:
:
FLAG_BREAK_TYPE_HYPHEN
;
}
uint8_t
CanBreakBefore
(
uint32_t
aPos
)
const
{
MOZ_ASSERT
(
aPos
<
GetLength
(
)
)
;
return
mCharacterGlyphs
[
aPos
]
.
CanBreakBefore
(
)
;
}
bool
CharIsSpace
(
uint32_t
aPos
)
const
{
MOZ_ASSERT
(
aPos
<
GetLength
(
)
)
;
return
mCharacterGlyphs
[
aPos
]
.
CharIsSpace
(
)
;
}
bool
CharIsTab
(
uint32_t
aPos
)
const
{
MOZ_ASSERT
(
aPos
<
GetLength
(
)
)
;
return
mCharacterGlyphs
[
aPos
]
.
CharIsTab
(
)
;
}
bool
CharIsNewline
(
uint32_t
aPos
)
const
{
MOZ_ASSERT
(
aPos
<
GetLength
(
)
)
;
return
mCharacterGlyphs
[
aPos
]
.
CharIsNewline
(
)
;
}
bool
CharMayHaveEmphasisMark
(
uint32_t
aPos
)
const
{
MOZ_ASSERT
(
aPos
<
GetLength
(
)
)
;
return
mCharacterGlyphs
[
aPos
]
.
CharMayHaveEmphasisMark
(
)
;
}
bool
CharIsFormattingControl
(
uint32_t
aPos
)
const
{
MOZ_ASSERT
(
aPos
<
GetLength
(
)
)
;
return
mCharacterGlyphs
[
aPos
]
.
CharIsFormattingControl
(
)
;
}
struct
Range
{
uint32_t
start
;
uint32_t
end
;
uint32_t
Length
(
)
const
{
return
end
-
start
;
}
Range
(
)
:
start
(
0
)
end
(
0
)
{
}
Range
(
uint32_t
aStart
uint32_t
aEnd
)
:
start
(
aStart
)
end
(
aEnd
)
{
}
explicit
Range
(
const
gfxTextRun
*
aTextRun
)
:
start
(
0
)
end
(
aTextRun
-
>
GetLength
(
)
)
{
}
}
;
virtual
bool
SetPotentialLineBreaks
(
Range
aRange
const
uint8_t
*
aBreakBefore
)
;
enum
class
HyphenType
:
uint8_t
{
None
Explicit
Soft
AutoWithManualInSameWord
AutoWithoutManualInSameWord
}
;
struct
HyphenationState
{
uint32_t
mostRecentBoundary
=
0
;
bool
hasManualHyphen
=
false
;
bool
hasExplicitHyphen
=
false
;
bool
hasAutoHyphen
=
false
;
}
;
class
PropertyProvider
{
public
:
virtual
void
GetHyphenationBreaks
(
Range
aRange
HyphenType
*
aBreakBefore
)
const
=
0
;
virtual
mozilla
:
:
StyleHyphens
GetHyphensOption
(
)
const
=
0
;
virtual
gfxFloat
GetHyphenWidth
(
)
const
=
0
;
typedef
gfxFont
:
:
Spacing
Spacing
;
virtual
void
GetSpacing
(
Range
aRange
Spacing
*
aSpacing
)
const
=
0
;
virtual
already_AddRefed
<
DrawTarget
>
GetDrawTarget
(
)
const
=
0
;
virtual
uint32_t
GetAppUnitsPerDevUnit
(
)
const
=
0
;
}
;
struct
MOZ_STACK_CLASS
DrawParams
{
gfxContext
*
context
;
DrawMode
drawMode
=
DrawMode
:
:
GLYPH_FILL
;
nscolor
textStrokeColor
=
0
;
gfxPattern
*
textStrokePattern
=
nullptr
;
const
mozilla
:
:
gfx
:
:
StrokeOptions
*
strokeOpts
=
nullptr
;
const
mozilla
:
:
gfx
:
:
DrawOptions
*
drawOpts
=
nullptr
;
PropertyProvider
*
provider
=
nullptr
;
gfxFloat
*
advanceWidth
=
nullptr
;
mozilla
:
:
SVGContextPaint
*
contextPaint
=
nullptr
;
gfxTextRunDrawCallbacks
*
callbacks
=
nullptr
;
explicit
DrawParams
(
gfxContext
*
aContext
)
:
context
(
aContext
)
{
}
}
;
void
Draw
(
Range
aRange
mozilla
:
:
gfx
:
:
Point
aPt
const
DrawParams
&
aParams
)
const
;
void
DrawEmphasisMarks
(
gfxContext
*
aContext
gfxTextRun
*
aMark
gfxFloat
aMarkAdvance
mozilla
:
:
gfx
:
:
Point
aPt
Range
aRange
PropertyProvider
*
aProvider
)
const
;
Metrics
MeasureText
(
Range
aRange
gfxFont
:
:
BoundingBoxType
aBoundingBoxType
DrawTarget
*
aDrawTargetForTightBoundingBox
PropertyProvider
*
aProvider
)
const
;
Metrics
MeasureText
(
gfxFont
:
:
BoundingBoxType
aBoundingBoxType
DrawTarget
*
aDrawTargetForTightBoundingBox
PropertyProvider
*
aProvider
=
nullptr
)
const
{
return
MeasureText
(
Range
(
this
)
aBoundingBoxType
aDrawTargetForTightBoundingBox
aProvider
)
;
}
gfxFloat
GetAdvanceWidth
(
Range
aRange
PropertyProvider
*
aProvider
PropertyProvider
:
:
Spacing
*
aSpacing
=
nullptr
)
const
;
gfxFloat
GetAdvanceWidth
(
)
const
{
return
GetAdvanceWidth
(
Range
(
this
)
nullptr
)
;
}
gfxFloat
GetMinAdvanceWidth
(
Range
aRange
)
;
virtual
bool
SetLineBreaks
(
Range
aRange
bool
aLineBreakBefore
bool
aLineBreakAfter
gfxFloat
*
aAdvanceWidthDelta
)
;
enum
SuppressBreak
{
eNoSuppressBreak
eSuppressInitialBreak
eSuppressAllBreaks
}
;
void
ClassifyAutoHyphenations
(
uint32_t
aStart
Range
aRange
nsTArray
<
HyphenType
>
&
aHyphenBuffer
HyphenationState
*
aWordState
)
;
uint32_t
BreakAndMeasureText
(
uint32_t
aStart
uint32_t
aMaxLength
bool
aLineBreakBefore
gfxFloat
aWidth
PropertyProvider
*
aProvider
SuppressBreak
aSuppressBreak
gfxFloat
*
aTrimWhitespace
bool
aHangWhitespace
Metrics
*
aMetrics
gfxFont
:
:
BoundingBoxType
aBoundingBoxType
DrawTarget
*
aDrawTargetForTightBoundingBox
bool
*
aUsedHyphenation
uint32_t
*
aLastBreak
bool
aCanWordWrap
bool
aCanWhitespaceWrap
gfxBreakPriority
*
aBreakPriority
)
;
void
*
GetUserData
(
)
const
{
return
mUserData
;
}
void
SetUserData
(
void
*
aUserData
)
{
mUserData
=
aUserData
;
}
void
SetFlagBits
(
nsTextFrameUtils
:
:
Flags
aFlags
)
{
mFlags2
|
=
aFlags
;
}
void
ClearFlagBits
(
nsTextFrameUtils
:
:
Flags
aFlags
)
{
mFlags2
&
=
~
aFlags
;
}
const
gfxSkipChars
&
GetSkipChars
(
)
const
{
return
mSkipChars
;
}
gfxFontGroup
*
GetFontGroup
(
)
const
{
return
mFontGroup
;
}
static
already_AddRefed
<
gfxTextRun
>
Create
(
const
gfxTextRunFactory
:
:
Parameters
*
aParams
uint32_t
aLength
gfxFontGroup
*
aFontGroup
mozilla
:
:
gfx
:
:
ShapedTextFlags
aFlags
nsTextFrameUtils
:
:
Flags
aFlags2
)
;
struct
GlyphRun
{
RefPtr
<
gfxFont
>
mFont
;
uint32_t
mCharacterOffset
;
mozilla
:
:
gfx
:
:
ShapedTextFlags
mOrientation
;
FontMatchType
mMatchType
;
bool
mIsCJK
;
void
SetProperties
(
gfxFont
*
aFont
mozilla
:
:
gfx
:
:
ShapedTextFlags
aOrientation
bool
aIsCJK
FontMatchType
aMatchType
)
{
mFont
=
aFont
;
mOrientation
=
aOrientation
;
mIsCJK
=
aIsCJK
;
mMatchType
=
aMatchType
;
}
bool
Matches
(
gfxFont
*
aFont
mozilla
:
:
gfx
:
:
ShapedTextFlags
aOrientation
bool
aIsCJK
FontMatchType
aMatchType
)
{
if
(
mFont
=
=
aFont
&
&
mOrientation
=
=
aOrientation
&
&
mIsCJK
=
=
aIsCJK
)
{
mMatchType
.
kind
|
=
aMatchType
.
kind
;
if
(
mMatchType
.
generic
=
=
mozilla
:
:
StyleGenericFontFamily
:
:
None
)
{
mMatchType
.
generic
=
aMatchType
.
generic
;
}
return
true
;
}
return
false
;
}
}
;
static
inline
bool
IsCJKScript
(
Script
aScript
)
{
switch
(
aScript
)
{
case
Script
:
:
BOPOMOFO
:
case
Script
:
:
HAN
:
case
Script
:
:
HANGUL
:
case
Script
:
:
HIRAGANA
:
case
Script
:
:
KATAKANA
:
case
Script
:
:
KATAKANA_OR_HIRAGANA
:
case
Script
:
:
SIMPLIFIED_HAN
:
case
Script
:
:
TRADITIONAL_HAN
:
case
Script
:
:
JAPANESE
:
case
Script
:
:
KOREAN
:
case
Script
:
:
HAN_WITH_BOPOMOFO
:
case
Script
:
:
JAMO
:
return
true
;
default
:
return
false
;
}
}
class
MOZ_STACK_CLASS
GlyphRunIterator
{
public
:
GlyphRunIterator
(
const
gfxTextRun
*
aTextRun
Range
aRange
bool
aReverse
=
false
)
:
mTextRun
(
aTextRun
)
mDirection
(
aReverse
?
-
1
:
1
)
mStartOffset
(
aRange
.
start
)
mEndOffset
(
aRange
.
end
)
{
mNextIndex
=
mTextRun
-
>
FindFirstGlyphRunContaining
(
aReverse
?
aRange
.
end
-
1
:
aRange
.
start
)
;
}
bool
NextRun
(
)
;
const
GlyphRun
*
GetGlyphRun
(
)
const
{
return
mGlyphRun
;
}
uint32_t
GetStringStart
(
)
const
{
return
mStringStart
;
}
uint32_t
GetStringEnd
(
)
const
{
return
mStringEnd
;
}
private
:
const
gfxTextRun
*
mTextRun
;
MOZ_INIT_OUTSIDE_CTOR
const
GlyphRun
*
mGlyphRun
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
mStringStart
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
mStringEnd
;
const
int32_t
mDirection
;
int32_t
mNextIndex
;
uint32_t
mStartOffset
;
uint32_t
mEndOffset
;
}
;
class
GlyphRunOffsetComparator
{
public
:
bool
Equals
(
const
GlyphRun
&
a
const
GlyphRun
&
b
)
const
{
return
a
.
mCharacterOffset
=
=
b
.
mCharacterOffset
;
}
bool
LessThan
(
const
GlyphRun
&
a
const
GlyphRun
&
b
)
const
{
return
a
.
mCharacterOffset
<
b
.
mCharacterOffset
;
}
}
;
friend
class
GlyphRunIterator
;
friend
class
FontSelector
;
void
AddGlyphRun
(
gfxFont
*
aFont
FontMatchType
aMatchType
uint32_t
aUTF16Offset
bool
aForceNewRun
mozilla
:
:
gfx
:
:
ShapedTextFlags
aOrientation
bool
aIsCJK
)
;
void
ResetGlyphRuns
(
)
{
if
(
mHasGlyphRunArray
)
{
MOZ_ASSERT
(
mGlyphRunArray
.
Length
(
)
>
1
)
;
mGlyphRunArray
.
TruncateLength
(
1
)
;
ConvertFromGlyphRunArray
(
)
;
}
mSingleGlyphRun
.
mFont
=
nullptr
;
}
void
SortGlyphRuns
(
)
;
void
SanitizeGlyphRuns
(
)
;
const
CompressedGlyph
*
GetCharacterGlyphs
(
)
const
final
{
MOZ_ASSERT
(
mCharacterGlyphs
"
failed
to
initialize
mCharacterGlyphs
"
)
;
return
mCharacterGlyphs
;
}
CompressedGlyph
*
GetCharacterGlyphs
(
)
final
{
MOZ_ASSERT
(
mCharacterGlyphs
"
failed
to
initialize
mCharacterGlyphs
"
)
;
return
mCharacterGlyphs
;
}
void
ClearGlyphsAndCharacters
(
)
;
void
SetSpaceGlyph
(
gfxFont
*
aFont
DrawTarget
*
aDrawTarget
uint32_t
aCharIndex
mozilla
:
:
gfx
:
:
ShapedTextFlags
aOrientation
)
;
bool
SetSpaceGlyphIfSimple
(
gfxFont
*
aFont
uint32_t
aCharIndex
char16_t
aSpaceChar
mozilla
:
:
gfx
:
:
ShapedTextFlags
aOrientation
)
;
void
SetIsTab
(
uint32_t
aIndex
)
{
EnsureComplexGlyph
(
aIndex
)
.
SetIsTab
(
)
;
}
void
SetIsNewline
(
uint32_t
aIndex
)
{
EnsureComplexGlyph
(
aIndex
)
.
SetIsNewline
(
)
;
}
void
SetNoEmphasisMark
(
uint32_t
aIndex
)
{
EnsureComplexGlyph
(
aIndex
)
.
SetNoEmphasisMark
(
)
;
}
void
SetIsFormattingControl
(
uint32_t
aIndex
)
{
EnsureComplexGlyph
(
aIndex
)
.
SetIsFormattingControl
(
)
;
}
void
FetchGlyphExtents
(
DrawTarget
*
aRefDrawTarget
)
;
uint32_t
CountMissingGlyphs
(
)
const
;
const
GlyphRun
*
GetGlyphRuns
(
uint32_t
*
aNumGlyphRuns
)
const
{
if
(
mHasGlyphRunArray
)
{
*
aNumGlyphRuns
=
mGlyphRunArray
.
Length
(
)
;
return
mGlyphRunArray
.
Elements
(
)
;
}
else
{
*
aNumGlyphRuns
=
mSingleGlyphRun
.
mFont
?
1
:
0
;
return
&
mSingleGlyphRun
;
}
}
const
GlyphRun
*
TrailingGlyphRun
(
)
const
{
uint32_t
count
;
const
GlyphRun
*
runs
=
GetGlyphRuns
(
&
count
)
;
return
count
?
runs
+
count
-
1
:
nullptr
;
}
uint32_t
FindFirstGlyphRunContaining
(
uint32_t
aOffset
)
const
;
void
CopyGlyphDataFrom
(
gfxShapedWord
*
aSource
uint32_t
aStart
)
;
void
CopyGlyphDataFrom
(
gfxTextRun
*
aSource
Range
aRange
uint32_t
aDest
)
;
void
ReleaseFontGroup
(
)
;
struct
LigatureData
{
Range
mRange
;
gfxFloat
mPartAdvance
;
gfxFloat
mPartWidth
;
bool
mClipBeforePart
;
bool
mClipAfterPart
;
}
;
virtual
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
MOZ_MUST_OVERRIDE
;
virtual
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
MOZ_MUST_OVERRIDE
;
nsTextFrameUtils
:
:
Flags
GetFlags2
(
)
const
{
return
mFlags2
;
}
size_t
MaybeSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
if
(
mFlags2
&
nsTextFrameUtils
:
:
Flags
:
:
RunSizeAccounted
)
{
return
0
;
}
mFlags2
|
=
nsTextFrameUtils
:
:
Flags
:
:
RunSizeAccounted
;
return
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
void
ResetSizeOfAccountingFlags
(
)
{
mFlags2
&
=
~
nsTextFrameUtils
:
:
Flags
:
:
RunSizeAccounted
;
}
enum
ShapingState
:
uint8_t
{
eShapingState_Normal
eShapingState_ShapingWithFeature
eShapingState_ShapingWithFallback
eShapingState_Aborted
eShapingState_ForceFallbackFeature
}
;
ShapingState
GetShapingState
(
)
const
{
return
mShapingState
;
}
void
SetShapingState
(
ShapingState
aShapingState
)
{
mShapingState
=
aShapingState
;
}
int32_t
GetAdvanceForGlyph
(
uint32_t
aIndex
)
const
{
const
CompressedGlyph
&
glyphData
=
mCharacterGlyphs
[
aIndex
]
;
if
(
glyphData
.
IsSimpleGlyph
(
)
)
{
return
glyphData
.
GetSimpleAdvance
(
)
;
}
uint32_t
glyphCount
=
glyphData
.
GetGlyphCount
(
)
;
if
(
!
glyphCount
)
{
return
0
;
}
const
DetailedGlyph
*
details
=
GetDetailedGlyphs
(
aIndex
)
;
int32_t
advance
=
0
;
for
(
uint32_t
j
=
0
;
j
<
glyphCount
;
+
+
j
+
+
details
)
{
advance
+
=
details
-
>
mAdvance
;
}
return
advance
;
}
#
ifdef
DEBUG
void
Dump
(
FILE
*
aOutput
)
;
#
endif
protected
:
gfxTextRun
(
const
gfxTextRunFactory
:
:
Parameters
*
aParams
uint32_t
aLength
gfxFontGroup
*
aFontGroup
mozilla
:
:
gfx
:
:
ShapedTextFlags
aFlags
nsTextFrameUtils
:
:
Flags
aFlags2
)
;
static
void
*
AllocateStorageForTextRun
(
size_t
aSize
uint32_t
aLength
)
;
CompressedGlyph
*
mCharacterGlyphs
;
private
:
int32_t
GetAdvanceForGlyphs
(
Range
aRange
)
const
;
bool
GetAdjustedSpacingArray
(
Range
aRange
PropertyProvider
*
aProvider
Range
aSpacingRange
nsTArray
<
PropertyProvider
:
:
Spacing
>
*
aSpacing
)
const
;
CompressedGlyph
&
EnsureComplexGlyph
(
uint32_t
aIndex
)
{
gfxShapedText
:
:
EnsureComplexGlyph
(
aIndex
mCharacterGlyphs
[
aIndex
]
)
;
return
mCharacterGlyphs
[
aIndex
]
;
}
LigatureData
ComputeLigatureData
(
Range
aPartRange
PropertyProvider
*
aProvider
)
const
;
gfxFloat
ComputePartialLigatureWidth
(
Range
aPartRange
PropertyProvider
*
aProvider
)
const
;
void
DrawPartialLigature
(
gfxFont
*
aFont
Range
aRange
mozilla
:
:
gfx
:
:
Point
*
aPt
PropertyProvider
*
aProvider
TextRunDrawParams
&
aParams
mozilla
:
:
gfx
:
:
ShapedTextFlags
aOrientation
)
const
;
void
ShrinkToLigatureBoundaries
(
Range
*
aRange
)
const
;
gfxFloat
GetPartialLigatureWidth
(
Range
aRange
PropertyProvider
*
aProvider
)
const
;
void
AccumulatePartialLigatureMetrics
(
gfxFont
*
aFont
Range
aRange
gfxFont
:
:
BoundingBoxType
aBoundingBoxType
DrawTarget
*
aRefDrawTarget
PropertyProvider
*
aProvider
mozilla
:
:
gfx
:
:
ShapedTextFlags
aOrientation
Metrics
*
aMetrics
)
const
;
void
AccumulateMetricsForRun
(
gfxFont
*
aFont
Range
aRange
gfxFont
:
:
BoundingBoxType
aBoundingBoxType
DrawTarget
*
aRefDrawTarget
PropertyProvider
*
aProvider
Range
aSpacingRange
mozilla
:
:
gfx
:
:
ShapedTextFlags
aOrientation
Metrics
*
aMetrics
)
const
;
void
DrawGlyphs
(
gfxFont
*
aFont
Range
aRange
mozilla
:
:
gfx
:
:
Point
*
aPt
PropertyProvider
*
aProvider
Range
aSpacingRange
TextRunDrawParams
&
aParams
mozilla
:
:
gfx
:
:
ShapedTextFlags
aOrientation
)
const
;
union
{
GlyphRun
mSingleGlyphRun
;
nsTArray
<
GlyphRun
>
mGlyphRunArray
;
}
;
void
ConvertToGlyphRunArray
(
)
{
MOZ_ASSERT
(
!
mHasGlyphRunArray
&
&
mSingleGlyphRun
.
mFont
)
;
GlyphRun
tmp
=
std
:
:
move
(
mSingleGlyphRun
)
;
mSingleGlyphRun
.
~
GlyphRun
(
)
;
new
(
&
mGlyphRunArray
)
nsTArray
<
GlyphRun
>
(
2
)
;
mGlyphRunArray
.
AppendElement
(
std
:
:
move
(
tmp
)
)
;
mHasGlyphRunArray
=
true
;
}
void
ConvertFromGlyphRunArray
(
)
{
MOZ_ASSERT
(
mHasGlyphRunArray
&
&
mGlyphRunArray
.
Length
(
)
=
=
1
)
;
GlyphRun
tmp
=
std
:
:
move
(
mGlyphRunArray
[
0
]
)
;
mGlyphRunArray
.
~
nsTArray
<
GlyphRun
>
(
)
;
new
(
&
mSingleGlyphRun
)
GlyphRun
(
std
:
:
move
(
tmp
)
)
;
mHasGlyphRunArray
=
false
;
}
void
*
mUserData
;
gfxFontGroup
*
MOZ_OWNING_REF
mFontGroup
;
gfxSkipChars
mSkipChars
;
nsTextFrameUtils
:
:
Flags
mFlags2
;
bool
mSkipDrawing
;
bool
mReleasedFontGroup
;
bool
mHasGlyphRunArray
;
ShapingState
mShapingState
;
}
;
class
gfxFontGroup
final
:
public
gfxTextRunFactory
{
public
:
typedef
mozilla
:
:
unicode
:
:
Script
Script
;
typedef
gfxShapedText
:
:
CompressedGlyph
CompressedGlyph
;
static
void
Shutdown
(
)
;
gfxFontGroup
(
const
mozilla
:
:
FontFamilyList
&
aFontFamilyList
const
gfxFontStyle
*
aStyle
gfxTextPerfMetrics
*
aTextPerf
gfxUserFontSet
*
aUserFontSet
gfxFloat
aDevToCssSize
)
;
virtual
~
gfxFontGroup
(
)
;
gfxFont
*
GetFirstValidFont
(
uint32_t
aCh
=
0x20
mozilla
:
:
StyleGenericFontFamily
*
aGeneric
=
nullptr
)
;
gfxFont
*
GetFirstMathFont
(
)
;
const
gfxFontStyle
*
GetStyle
(
)
const
{
return
&
mStyle
;
}
gfxFontGroup
*
Copy
(
const
gfxFontStyle
*
aStyle
)
;
static
bool
IsInvalidChar
(
uint8_t
ch
)
;
static
bool
IsInvalidChar
(
char16_t
ch
)
;
already_AddRefed
<
gfxTextRun
>
MakeTextRun
(
const
char16_t
*
aString
uint32_t
aLength
const
Parameters
*
aParams
mozilla
:
:
gfx
:
:
ShapedTextFlags
aFlags
nsTextFrameUtils
:
:
Flags
aFlags2
gfxMissingFontRecorder
*
aMFR
)
;
already_AddRefed
<
gfxTextRun
>
MakeTextRun
(
const
uint8_t
*
aString
uint32_t
aLength
const
Parameters
*
aParams
mozilla
:
:
gfx
:
:
ShapedTextFlags
aFlags
nsTextFrameUtils
:
:
Flags
aFlags2
gfxMissingFontRecorder
*
aMFR
)
;
template
<
typename
T
>
already_AddRefed
<
gfxTextRun
>
MakeTextRun
(
const
T
*
aString
uint32_t
aLength
DrawTarget
*
aRefDrawTarget
int32_t
aAppUnitsPerDevUnit
mozilla
:
:
gfx
:
:
ShapedTextFlags
aFlags
nsTextFrameUtils
:
:
Flags
aFlags2
gfxMissingFontRecorder
*
aMFR
)
{
gfxTextRunFactory
:
:
Parameters
params
=
{
aRefDrawTarget
nullptr
nullptr
nullptr
0
aAppUnitsPerDevUnit
}
;
return
MakeTextRun
(
aString
aLength
&
params
aFlags
aFlags2
aMFR
)
;
}
gfxFloat
GetHyphenWidth
(
const
gfxTextRun
:
:
PropertyProvider
*
aProvider
)
;
already_AddRefed
<
gfxTextRun
>
MakeHyphenTextRun
(
DrawTarget
*
aDrawTarget
uint32_t
aAppUnitsPerDevUnit
)
;
bool
HasFont
(
const
gfxFontEntry
*
aFontEntry
)
;
enum
{
UNDERLINE_OFFSET_NOT_SET
=
INT16_MAX
}
;
gfxFloat
GetUnderlineOffset
(
)
;
gfxFont
*
FindFontForChar
(
uint32_t
ch
uint32_t
prevCh
uint32_t
aNextCh
Script
aRunScript
gfxFont
*
aPrevMatchedFont
FontMatchType
*
aMatchType
)
;
gfxUserFontSet
*
GetUserFontSet
(
)
;
uint64_t
GetGeneration
(
)
;
uint64_t
GetRebuildGeneration
(
)
;
gfxTextPerfMetrics
*
GetTextPerfMetrics
(
)
{
return
mTextPerf
;
}
void
SetUserFontSet
(
gfxUserFontSet
*
aUserFontSet
)
;
void
ClearCachedData
(
)
{
mUnderlineOffset
=
UNDERLINE_OFFSET_NOT_SET
;
mSkipDrawing
=
false
;
mHyphenWidth
=
-
1
;
mCachedEllipsisTextRun
=
nullptr
;
}
void
UpdateUserFonts
(
)
;
bool
ContainsUserFont
(
const
gfxUserFontEntry
*
aUserFont
)
;
bool
ShouldSkipDrawing
(
)
const
{
return
mSkipDrawing
;
}
class
LazyReferenceDrawTargetGetter
{
public
:
virtual
already_AddRefed
<
DrawTarget
>
GetRefDrawTarget
(
)
=
0
;
}
;
gfxTextRun
*
GetEllipsisTextRun
(
int32_t
aAppUnitsPerDevPixel
mozilla
:
:
gfx
:
:
ShapedTextFlags
aFlags
LazyReferenceDrawTargetGetter
&
aRefDrawTargetGetter
)
;
void
CheckForUpdatedPlatformList
(
)
{
auto
*
pfl
=
gfxPlatformFontList
:
:
PlatformFontList
(
)
;
if
(
mFontListGeneration
!
=
pfl
-
>
GetGeneration
(
)
)
{
mLastPrefFamily
=
FontFamily
(
)
;
mLastPrefFont
=
nullptr
;
mFonts
.
Clear
(
)
;
BuildFontList
(
)
;
}
}
protected
:
friend
class
mozilla
:
:
PostTraversalTask
;
struct
TextRange
{
TextRange
(
uint32_t
aStart
uint32_t
aEnd
gfxFont
*
aFont
FontMatchType
aMatchType
mozilla
:
:
gfx
:
:
ShapedTextFlags
aOrientation
)
:
start
(
aStart
)
end
(
aEnd
)
font
(
aFont
)
matchType
(
aMatchType
)
orientation
(
aOrientation
)
{
}
uint32_t
Length
(
)
const
{
return
end
-
start
;
}
uint32_t
start
end
;
RefPtr
<
gfxFont
>
font
;
FontMatchType
matchType
;
mozilla
:
:
gfx
:
:
ShapedTextFlags
orientation
;
}
;
gfxFont
*
WhichPrefFontSupportsChar
(
uint32_t
aCh
uint32_t
aNextCh
)
;
gfxFont
*
WhichSystemFontSupportsChar
(
uint32_t
aCh
uint32_t
aNextCh
Script
aRunScript
)
;
template
<
typename
T
>
void
ComputeRanges
(
nsTArray
<
TextRange
>
&
aRanges
const
T
*
aString
uint32_t
aLength
Script
aRunScript
mozilla
:
:
gfx
:
:
ShapedTextFlags
aOrientation
)
;
class
FamilyFace
{
public
:
FamilyFace
(
)
:
mOwnedFamily
(
nullptr
)
mFontEntry
(
nullptr
)
mGeneric
(
mozilla
:
:
StyleGenericFontFamily
:
:
None
)
mFontCreated
(
false
)
mLoading
(
false
)
mInvalid
(
false
)
mCheckForFallbackFaces
(
false
)
mIsSharedFamily
(
false
)
mHasFontEntry
(
false
)
{
}
FamilyFace
(
gfxFontFamily
*
aFamily
gfxFont
*
aFont
mozilla
:
:
StyleGenericFontFamily
aGeneric
)
:
mOwnedFamily
(
aFamily
)
mGeneric
(
aGeneric
)
mFontCreated
(
true
)
mLoading
(
false
)
mInvalid
(
false
)
mCheckForFallbackFaces
(
false
)
mIsSharedFamily
(
false
)
mHasFontEntry
(
false
)
{
NS_ASSERTION
(
aFont
"
font
pointer
must
not
be
null
"
)
;
NS_ASSERTION
(
!
aFamily
|
|
aFamily
-
>
ContainsFace
(
aFont
-
>
GetFontEntry
(
)
)
"
font
is
not
a
member
of
the
given
family
"
)
;
NS_IF_ADDREF
(
aFamily
)
;
mFont
=
aFont
;
NS_ADDREF
(
aFont
)
;
}
FamilyFace
(
gfxFontFamily
*
aFamily
gfxFontEntry
*
aFontEntry
mozilla
:
:
StyleGenericFontFamily
aGeneric
)
:
mOwnedFamily
(
aFamily
)
mGeneric
(
aGeneric
)
mFontCreated
(
false
)
mLoading
(
false
)
mInvalid
(
false
)
mCheckForFallbackFaces
(
false
)
mIsSharedFamily
(
false
)
mHasFontEntry
(
true
)
{
NS_ASSERTION
(
aFontEntry
"
font
entry
pointer
must
not
be
null
"
)
;
NS_ASSERTION
(
!
aFamily
|
|
aFamily
-
>
ContainsFace
(
aFontEntry
)
"
font
is
not
a
member
of
the
given
family
"
)
;
NS_IF_ADDREF
(
aFamily
)
;
mFontEntry
=
aFontEntry
;
NS_ADDREF
(
aFontEntry
)
;
}
FamilyFace
(
mozilla
:
:
fontlist
:
:
Family
*
aFamily
gfxFontEntry
*
aFontEntry
mozilla
:
:
StyleGenericFontFamily
aGeneric
)
:
mSharedFamily
(
aFamily
)
mGeneric
(
aGeneric
)
mFontCreated
(
false
)
mLoading
(
false
)
mInvalid
(
false
)
mCheckForFallbackFaces
(
false
)
mIsSharedFamily
(
true
)
mHasFontEntry
(
true
)
{
MOZ_ASSERT
(
aFamily
&
&
aFontEntry
&
&
aFontEntry
-
>
mShmemFace
)
;
mFontEntry
=
aFontEntry
;
NS_ADDREF
(
aFontEntry
)
;
}
FamilyFace
(
const
FamilyFace
&
aOtherFamilyFace
)
:
mGeneric
(
aOtherFamilyFace
.
mGeneric
)
mFontCreated
(
aOtherFamilyFace
.
mFontCreated
)
mLoading
(
aOtherFamilyFace
.
mLoading
)
mInvalid
(
aOtherFamilyFace
.
mInvalid
)
mCheckForFallbackFaces
(
aOtherFamilyFace
.
mCheckForFallbackFaces
)
mIsSharedFamily
(
aOtherFamilyFace
.
mIsSharedFamily
)
mHasFontEntry
(
aOtherFamilyFace
.
mHasFontEntry
)
{
if
(
mIsSharedFamily
)
{
mSharedFamily
=
aOtherFamilyFace
.
mSharedFamily
;
if
(
mFontCreated
)
{
mFont
=
aOtherFamilyFace
.
mFont
;
NS_ADDREF
(
mFont
)
;
}
else
if
(
mHasFontEntry
)
{
mFontEntry
=
aOtherFamilyFace
.
mFontEntry
;
NS_ADDREF
(
mFontEntry
)
;
}
else
{
mSharedFace
=
aOtherFamilyFace
.
mSharedFace
;
}
}
else
{
mOwnedFamily
=
aOtherFamilyFace
.
mOwnedFamily
;
NS_IF_ADDREF
(
mOwnedFamily
)
;
if
(
mFontCreated
)
{
mFont
=
aOtherFamilyFace
.
mFont
;
NS_ADDREF
(
mFont
)
;
}
else
{
mFontEntry
=
aOtherFamilyFace
.
mFontEntry
;
NS_IF_ADDREF
(
mFontEntry
)
;
}
}
}
~
FamilyFace
(
)
{
if
(
mFontCreated
)
{
NS_RELEASE
(
mFont
)
;
}
if
(
!
mIsSharedFamily
)
{
NS_IF_RELEASE
(
mOwnedFamily
)
;
}
if
(
mHasFontEntry
)
{
NS_RELEASE
(
mFontEntry
)
;
}
}
FamilyFace
&
operator
=
(
const
FamilyFace
&
aOther
)
{
if
(
mFontCreated
)
{
NS_RELEASE
(
mFont
)
;
}
if
(
!
mIsSharedFamily
)
{
NS_IF_RELEASE
(
mOwnedFamily
)
;
}
if
(
mHasFontEntry
)
{
NS_RELEASE
(
mFontEntry
)
;
}
mGeneric
=
aOther
.
mGeneric
;
mFontCreated
=
aOther
.
mFontCreated
;
mLoading
=
aOther
.
mLoading
;
mInvalid
=
aOther
.
mInvalid
;
mIsSharedFamily
=
aOther
.
mIsSharedFamily
;
mHasFontEntry
=
aOther
.
mHasFontEntry
;
if
(
mIsSharedFamily
)
{
mSharedFamily
=
aOther
.
mSharedFamily
;
if
(
mFontCreated
)
{
mFont
=
aOther
.
mFont
;
NS_ADDREF
(
mFont
)
;
}
else
if
(
mHasFontEntry
)
{
mFontEntry
=
aOther
.
mFontEntry
;
NS_ADDREF
(
mFontEntry
)
;
}
else
{
mSharedFace
=
aOther
.
mSharedFace
;
}
}
else
{
mOwnedFamily
=
aOther
.
mOwnedFamily
;
NS_IF_ADDREF
(
mOwnedFamily
)
;
if
(
mFontCreated
)
{
mFont
=
aOther
.
mFont
;
NS_ADDREF
(
mFont
)
;
}
else
{
mFontEntry
=
aOther
.
mFontEntry
;
NS_IF_ADDREF
(
mFontEntry
)
;
}
}
return
*
this
;
}
gfxFontFamily
*
OwnedFamily
(
)
const
{
MOZ_ASSERT
(
!
mIsSharedFamily
)
;
return
mOwnedFamily
;
}
mozilla
:
:
fontlist
:
:
Family
*
SharedFamily
(
)
const
{
MOZ_ASSERT
(
mIsSharedFamily
)
;
return
mSharedFamily
;
}
gfxFont
*
Font
(
)
const
{
return
mFontCreated
?
mFont
:
nullptr
;
}
gfxFontEntry
*
FontEntry
(
)
const
{
if
(
mFontCreated
)
{
return
mFont
-
>
GetFontEntry
(
)
;
}
if
(
mHasFontEntry
)
{
return
mFontEntry
;
}
if
(
mIsSharedFamily
)
{
return
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
GetOrCreateFontEntry
(
mSharedFace
SharedFamily
(
)
)
;
}
return
nullptr
;
}
mozilla
:
:
StyleGenericFontFamily
Generic
(
)
const
{
return
mGeneric
;
}
bool
IsSharedFamily
(
)
const
{
return
mIsSharedFamily
;
}
bool
IsUserFontContainer
(
)
const
{
return
FontEntry
(
)
-
>
mIsUserFontContainer
;
}
bool
IsLoading
(
)
const
{
return
mLoading
;
}
bool
IsInvalid
(
)
const
{
return
mInvalid
;
}
void
CheckState
(
bool
&
aSkipDrawing
)
;
void
SetLoading
(
bool
aIsLoading
)
{
mLoading
=
aIsLoading
;
}
void
SetInvalid
(
)
{
mInvalid
=
true
;
}
bool
CheckForFallbackFaces
(
)
const
{
return
mCheckForFallbackFaces
;
}
void
SetCheckForFallbackFaces
(
)
{
mCheckForFallbackFaces
=
true
;
}
bool
IsLoadingFor
(
uint32_t
aCh
)
{
if
(
!
IsLoading
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
IsUserFontContainer
(
)
)
;
return
static_cast
<
gfxUserFontEntry
*
>
(
FontEntry
(
)
)
-
>
CharacterInUnicodeRange
(
aCh
)
;
}
void
SetFont
(
gfxFont
*
aFont
)
{
NS_ASSERTION
(
aFont
"
font
pointer
must
not
be
null
"
)
;
NS_ADDREF
(
aFont
)
;
if
(
mFontCreated
)
{
NS_RELEASE
(
mFont
)
;
}
else
if
(
mHasFontEntry
)
{
NS_RELEASE
(
mFontEntry
)
;
mHasFontEntry
=
false
;
}
mFont
=
aFont
;
mFontCreated
=
true
;
mLoading
=
false
;
}
bool
EqualsUserFont
(
const
gfxUserFontEntry
*
aUserFont
)
const
;
private
:
union
{
gfxFontFamily
*
MOZ_OWNING_REF
mOwnedFamily
;
mozilla
:
:
fontlist
:
:
Family
*
MOZ_NON_OWNING_REF
mSharedFamily
;
}
;
union
{
gfxFont
*
MOZ_OWNING_REF
mFont
;
gfxFontEntry
*
MOZ_OWNING_REF
mFontEntry
;
mozilla
:
:
fontlist
:
:
Face
*
MOZ_NON_OWNING_REF
mSharedFace
;
}
;
mozilla
:
:
StyleGenericFontFamily
mGeneric
;
bool
mFontCreated
:
1
;
bool
mLoading
:
1
;
bool
mInvalid
:
1
;
bool
mCheckForFallbackFaces
:
1
;
bool
mIsSharedFamily
:
1
;
bool
mHasFontEntry
:
1
;
}
;
mozilla
:
:
FontFamilyList
mFamilyList
;
nsTArray
<
FamilyFace
>
mFonts
;
RefPtr
<
gfxFont
>
mDefaultFont
;
gfxFontStyle
mStyle
;
gfxFloat
mUnderlineOffset
;
gfxFloat
mHyphenWidth
;
gfxFloat
mDevToCssSize
;
RefPtr
<
gfxUserFontSet
>
mUserFontSet
;
uint64_t
mCurrGeneration
;
gfxTextPerfMetrics
*
mTextPerf
;
RefPtr
<
gfxTextRun
>
mCachedEllipsisTextRun
;
FontFamily
mLastPrefFamily
;
RefPtr
<
gfxFont
>
mLastPrefFont
;
eFontPrefLang
mLastPrefLang
;
eFontPrefLang
mPageLang
;
bool
mLastPrefFirstFont
;
bool
mSkipDrawing
;
uint32_t
mFontListGeneration
=
0
;
already_AddRefed
<
gfxTextRun
>
MakeEmptyTextRun
(
const
Parameters
*
aParams
mozilla
:
:
gfx
:
:
ShapedTextFlags
aFlags
nsTextFrameUtils
:
:
Flags
aFlags2
)
;
already_AddRefed
<
gfxTextRun
>
MakeSpaceTextRun
(
const
Parameters
*
aParams
mozilla
:
:
gfx
:
:
ShapedTextFlags
aFlags
nsTextFrameUtils
:
:
Flags
aFlags2
)
;
already_AddRefed
<
gfxTextRun
>
MakeBlankTextRun
(
uint32_t
aLength
const
Parameters
*
aParams
mozilla
:
:
gfx
:
:
ShapedTextFlags
aFlags
nsTextFrameUtils
:
:
Flags
aFlags2
)
;
void
BuildFontList
(
)
;
gfxFont
*
GetFontAt
(
int32_t
i
uint32_t
aCh
bool
*
aLoading
)
;
gfxFont
*
GetFontAt
(
int32_t
i
uint32_t
aCh
=
0x20
)
{
bool
loading
=
false
;
return
GetFontAt
(
i
aCh
&
loading
)
;
}
gfxFont
*
GetDefaultFont
(
)
;
void
InitMetricsForBadFont
(
gfxFont
*
aBadFont
)
;
template
<
typename
T
>
void
InitTextRun
(
DrawTarget
*
aDrawTarget
gfxTextRun
*
aTextRun
const
T
*
aString
uint32_t
aLength
gfxMissingFontRecorder
*
aMFR
)
;
template
<
typename
T
>
void
InitScriptRun
(
DrawTarget
*
aDrawTarget
gfxTextRun
*
aTextRun
const
T
*
aString
uint32_t
aScriptRunStart
uint32_t
aScriptRunEnd
Script
aRunScript
gfxMissingFontRecorder
*
aMFR
)
;
gfxFont
*
FindFallbackFaceForChar
(
const
FamilyFace
&
aFamily
uint32_t
aCh
)
;
gfxFont
*
FindFallbackFaceForChar
(
mozilla
:
:
fontlist
:
:
Family
*
aFamily
uint32_t
aCh
)
;
gfxFont
*
FindFallbackFaceForChar
(
gfxFontFamily
*
aFamily
uint32_t
aCh
)
;
void
AddPlatformFont
(
const
nsACString
&
aName
bool
aQuotedName
nsTArray
<
FamilyAndGeneric
>
&
aFamilyList
)
;
void
AddFamilyToFontList
(
gfxFontFamily
*
aFamily
mozilla
:
:
StyleGenericFontFamily
aGeneric
)
;
void
AddFamilyToFontList
(
mozilla
:
:
fontlist
:
:
Family
*
aFamily
mozilla
:
:
StyleGenericFontFamily
aGeneric
)
;
}
;
#
define
GFX_MISSING_FONTS_NOTIFY_PREF
"
gfx
.
missing_fonts
.
notify
"
class
gfxMissingFontRecorder
{
public
:
gfxMissingFontRecorder
(
)
{
MOZ_COUNT_CTOR
(
gfxMissingFontRecorder
)
;
memset
(
&
mMissingFonts
0
sizeof
(
mMissingFonts
)
)
;
}
~
gfxMissingFontRecorder
(
)
{
#
ifdef
DEBUG
for
(
uint32_t
i
=
0
;
i
<
kNumScriptBitsWords
;
i
+
+
)
{
NS_ASSERTION
(
mMissingFonts
[
i
]
=
=
0
"
failed
to
flush
the
missing
-
font
recorder
"
)
;
}
#
endif
MOZ_COUNT_DTOR
(
gfxMissingFontRecorder
)
;
}
void
RecordScript
(
mozilla
:
:
unicode
:
:
Script
aScriptCode
)
{
mMissingFonts
[
static_cast
<
uint32_t
>
(
aScriptCode
)
>
>
5
]
|
=
(
1
<
<
(
static_cast
<
uint32_t
>
(
aScriptCode
)
&
0x1f
)
)
;
}
void
Flush
(
)
;
void
Clear
(
)
{
memset
(
&
mMissingFonts
0
sizeof
(
mMissingFonts
)
)
;
}
private
:
static
const
uint32_t
kNumScriptBitsWords
=
(
(
static_cast
<
int
>
(
mozilla
:
:
unicode
:
:
Script
:
:
NUM_SCRIPT_CODES
)
+
31
)
/
32
)
;
uint32_t
mMissingFonts
[
kNumScriptBitsWords
]
;
}
;
#
endif
