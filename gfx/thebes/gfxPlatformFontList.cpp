#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
mozilla
/
intl
/
Locale
.
h
"
#
include
"
mozilla
/
intl
/
LocaleService
.
h
"
#
include
"
mozilla
/
intl
/
OSPreferences
.
h
"
#
include
"
gfxPlatformFontList
.
h
"
#
include
"
gfxTextRun
.
h
"
#
include
"
gfxUserFontSet
.
h
"
#
include
"
SharedFontList
-
impl
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
AppShutdown
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
glean
/
GfxMetrics
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
dom
/
BlobImpl
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
ContentProcessMessageManager
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
ipc
/
FileDescriptorUtils
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
base
/
eintr_wrapper
.
h
"
#
include
<
locale
.
h
>
#
include
<
numeric
>
using
namespace
mozilla
;
using
mozilla
:
:
intl
:
:
Locale
;
using
mozilla
:
:
intl
:
:
LocaleParser
;
using
mozilla
:
:
intl
:
:
LocaleService
;
using
mozilla
:
:
intl
:
:
OSPreferences
;
#
define
LOG_FONTLIST
(
args
)
\
MOZ_LOG
(
gfxPlatform
:
:
GetLog
(
eGfxLog_fontlist
)
LogLevel
:
:
Debug
args
)
#
define
LOG_FONTLIST_ENABLED
(
)
\
MOZ_LOG_TEST
(
gfxPlatform
:
:
GetLog
(
eGfxLog_fontlist
)
LogLevel
:
:
Debug
)
#
define
LOG_FONTINIT
(
args
)
\
MOZ_LOG
(
gfxPlatform
:
:
GetLog
(
eGfxLog_fontinit
)
LogLevel
:
:
Debug
args
)
#
define
LOG_FONTINIT_ENABLED
(
)
\
MOZ_LOG_TEST
(
gfxPlatform
:
:
GetLog
(
eGfxLog_fontinit
)
LogLevel
:
:
Debug
)
gfxPlatformFontList
*
gfxPlatformFontList
:
:
sPlatformFontList
=
nullptr
;
const
gfxFontEntry
:
:
ScriptRange
gfxPlatformFontList
:
:
sComplexScriptRanges
[
]
=
{
{
0x0600
0x060B
1
{
TRUETYPE_TAG
(
'
a
'
'
r
'
'
a
'
'
b
'
)
0
0
}
}
{
0x060D
0x061A
1
{
TRUETYPE_TAG
(
'
a
'
'
r
'
'
a
'
'
b
'
)
0
0
}
}
{
0x061C
0x061E
1
{
TRUETYPE_TAG
(
'
a
'
'
r
'
'
a
'
'
b
'
)
0
0
}
}
{
0x0620
0x063F
1
{
TRUETYPE_TAG
(
'
a
'
'
r
'
'
a
'
'
b
'
)
0
0
}
}
{
0x0641
0x06D3
1
{
TRUETYPE_TAG
(
'
a
'
'
r
'
'
a
'
'
b
'
)
0
0
}
}
{
0x06D5
0x06FF
1
{
TRUETYPE_TAG
(
'
a
'
'
r
'
'
a
'
'
b
'
)
0
0
}
}
{
0x0700
0x074F
1
{
TRUETYPE_TAG
(
'
s
'
'
y
'
'
r
'
'
c
'
)
0
0
}
}
{
0x0750
0x077F
1
{
TRUETYPE_TAG
(
'
a
'
'
r
'
'
a
'
'
b
'
)
0
0
}
}
{
0x08A0
0x08FF
1
{
TRUETYPE_TAG
(
'
a
'
'
r
'
'
a
'
'
b
'
)
0
0
}
}
{
0x0900
0x0963
2
{
TRUETYPE_TAG
(
'
d
'
'
e
'
'
v
'
'
2
'
)
TRUETYPE_TAG
(
'
d
'
'
e
'
'
v
'
'
a
'
)
0
}
}
{
0x0966
0x097F
2
{
TRUETYPE_TAG
(
'
d
'
'
e
'
'
v
'
'
2
'
)
TRUETYPE_TAG
(
'
d
'
'
e
'
'
v
'
'
a
'
)
0
}
}
{
0x0980
0x09FF
2
{
TRUETYPE_TAG
(
'
b
'
'
n
'
'
g
'
'
2
'
)
TRUETYPE_TAG
(
'
b
'
'
e
'
'
n
'
'
g
'
)
0
}
}
{
0x0A00
0x0A7F
2
{
TRUETYPE_TAG
(
'
g
'
'
u
'
'
r
'
'
2
'
)
TRUETYPE_TAG
(
'
g
'
'
u
'
'
r
'
'
u
'
)
0
}
}
{
0x0A80
0x0AFF
2
{
TRUETYPE_TAG
(
'
g
'
'
j
'
'
r
'
'
2
'
)
TRUETYPE_TAG
(
'
g
'
'
u
'
'
j
'
'
r
'
)
0
}
}
{
0x0B00
0x0B7F
2
{
TRUETYPE_TAG
(
'
o
'
'
r
'
'
y
'
'
2
'
)
TRUETYPE_TAG
(
'
o
'
'
r
'
'
y
'
'
a
'
)
0
}
}
{
0x0B80
0x0BFF
2
{
TRUETYPE_TAG
(
'
t
'
'
m
'
'
l
'
'
2
'
)
TRUETYPE_TAG
(
'
t
'
'
a
'
'
m
'
'
l
'
)
0
}
}
{
0x0C00
0x0C7F
2
{
TRUETYPE_TAG
(
'
t
'
'
e
'
'
l
'
'
2
'
)
TRUETYPE_TAG
(
'
t
'
'
e
'
'
l
'
'
u
'
)
0
}
}
{
0x0C80
0x0CFF
2
{
TRUETYPE_TAG
(
'
k
'
'
n
'
'
d
'
'
2
'
)
TRUETYPE_TAG
(
'
k
'
'
n
'
'
d
'
'
a
'
)
0
}
}
{
0x0D00
0x0D7F
2
{
TRUETYPE_TAG
(
'
m
'
'
l
'
'
m
'
'
2
'
)
TRUETYPE_TAG
(
'
m
'
'
l
'
'
y
'
'
m
'
)
0
}
}
{
0x0D80
0x0DFF
1
{
TRUETYPE_TAG
(
'
s
'
'
i
'
'
n
'
'
h
'
)
0
0
}
}
{
0x0E80
0x0EFF
1
{
TRUETYPE_TAG
(
'
l
'
'
a
'
'
o
'
'
'
)
0
0
}
}
{
0x0F00
0x0FFF
1
{
TRUETYPE_TAG
(
'
t
'
'
i
'
'
b
'
'
t
'
)
0
0
}
}
{
0x1000
0x109f
2
{
TRUETYPE_TAG
(
'
m
'
'
y
'
'
m
'
'
r
'
)
TRUETYPE_TAG
(
'
m
'
'
y
'
'
m
'
'
2
'
)
0
}
}
{
0x1780
0x17ff
1
{
TRUETYPE_TAG
(
'
k
'
'
h
'
'
m
'
'
r
'
)
0
0
}
}
{
0xaa60
0xaa7f
2
{
TRUETYPE_TAG
(
'
m
'
'
y
'
'
m
'
'
r
'
)
TRUETYPE_TAG
(
'
m
'
'
y
'
'
m
'
'
2
'
)
0
}
}
{
0
0
0
{
0
0
0
}
}
}
;
static
const
char
*
kObservedPrefs
[
]
=
{
"
font
.
"
"
font
.
name
-
list
.
"
"
intl
.
accept_languages
"
"
browser
.
display
.
use_document_fonts
.
icon_font_allowlist
"
nullptr
}
;
static
const
char
kFontSystemWhitelistPref
[
]
=
"
font
.
system
.
whitelist
"
;
static
const
char
kCJKFallbackOrderPref
[
]
=
"
font
.
cjk_pref_fallback_order
"
;
static
const
char
kIconFontsPref
[
]
=
"
browser
.
display
.
use_document_fonts
.
icon_font_allowlist
"
;
static
const
char
*
gPrefLangNames
[
]
=
{
#
define
FONT_PREF_LANG
(
enum_id_
str_
atom_id_
)
str_
#
include
"
gfxFontPrefLangList
.
h
"
#
undef
FONT_PREF_LANG
}
;
static_assert
(
std
:
:
size
(
gPrefLangNames
)
=
=
uint32_t
(
eFontPrefLang_Count
)
"
size
of
pref
lang
name
array
doesn
'
t
match
pref
lang
enum
size
"
)
;
class
gfxFontListPrefObserver
final
:
public
nsIObserver
{
~
gfxFontListPrefObserver
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
}
;
static
void
FontListPrefChanged
(
const
char
*
aPref
void
*
aData
=
nullptr
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
ClearLangGroupPrefFonts
(
)
;
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
LoadIconFontOverrideList
(
)
;
gfxFontCache
:
:
GetCache
(
)
-
>
Flush
(
)
;
}
static
gfxFontListPrefObserver
*
gFontListPrefObserver
=
nullptr
;
NS_IMPL_ISUPPORTS
(
gfxFontListPrefObserver
nsIObserver
)
#
define
LOCALES_CHANGED_TOPIC
"
intl
:
system
-
locales
-
changed
"
NS_IMETHODIMP
gfxFontListPrefObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
NS_ASSERTION
(
!
strcmp
(
aTopic
LOCALES_CHANGED_TOPIC
)
"
invalid
topic
"
)
;
FontListPrefChanged
(
nullptr
)
;
if
(
XRE_IsParentProcess
(
)
)
{
gfxPlatform
:
:
GlobalReflowFlags
flags
=
gfxPlatform
:
:
GlobalReflowFlags
:
:
BroadcastToChildren
|
gfxPlatform
:
:
GlobalReflowFlags
:
:
FontsChanged
;
gfxPlatform
:
:
ForceGlobalReflow
(
flags
)
;
}
return
NS_OK
;
}
MOZ_DEFINE_MALLOC_SIZE_OF
(
FontListMallocSizeOf
)
NS_IMPL_ISUPPORTS
(
gfxPlatformFontList
:
:
MemoryReporter
nsIMemoryReporter
)
NS_IMETHODIMP
gfxPlatformFontList
:
:
MemoryReporter
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
FontListSizes
sizes
;
sizes
.
mFontListSize
=
0
;
sizes
.
mFontTableCacheSize
=
0
;
sizes
.
mCharMapsSize
=
0
;
sizes
.
mLoaderSize
=
0
;
sizes
.
mSharedSize
=
0
;
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
AddSizeOfIncludingThis
(
&
FontListMallocSizeOf
&
sizes
)
;
MOZ_COLLECT_REPORT
(
"
explicit
/
gfx
/
font
-
list
"
KIND_HEAP
UNITS_BYTES
sizes
.
mFontListSize
"
Memory
used
to
manage
the
list
of
font
families
and
faces
.
"
)
;
MOZ_COLLECT_REPORT
(
"
explicit
/
gfx
/
font
-
charmaps
"
KIND_HEAP
UNITS_BYTES
sizes
.
mCharMapsSize
"
Memory
used
to
record
the
character
coverage
of
individual
fonts
.
"
)
;
if
(
sizes
.
mFontTableCacheSize
)
{
MOZ_COLLECT_REPORT
(
"
explicit
/
gfx
/
font
-
tables
"
KIND_HEAP
UNITS_BYTES
sizes
.
mFontTableCacheSize
"
Memory
used
for
cached
font
metrics
and
layout
tables
.
"
)
;
}
if
(
sizes
.
mLoaderSize
)
{
MOZ_COLLECT_REPORT
(
"
explicit
/
gfx
/
font
-
loader
"
KIND_HEAP
UNITS_BYTES
sizes
.
mLoaderSize
"
Memory
used
for
(
platform
-
specific
)
font
loader
.
"
)
;
}
if
(
sizes
.
mSharedSize
)
{
MOZ_COLLECT_REPORT
(
"
font
-
list
-
shmem
"
KIND_NONHEAP
UNITS_BYTES
sizes
.
mSharedSize
"
Shared
memory
for
system
font
list
and
character
coverage
data
.
"
)
;
}
return
NS_OK
;
}
PRThread
*
gfxPlatformFontList
:
:
sInitFontListThread
=
nullptr
;
static
void
InitFontListCallback
(
void
*
aFontList
)
{
AUTO_PROFILER_REGISTER_THREAD
(
"
InitFontList
"
)
;
PR_SetCurrentThreadName
(
"
InitFontList
"
)
;
if
(
!
static_cast
<
gfxPlatformFontList
*
>
(
aFontList
)
-
>
InitFontList
(
)
)
{
gfxPlatformFontList
:
:
Shutdown
(
)
;
}
}
bool
gfxPlatformFontList
:
:
Initialize
(
gfxPlatformFontList
*
aList
)
{
sPlatformFontList
=
aList
;
if
(
XRE_IsParentProcess
(
)
&
&
StaticPrefs
:
:
gfx_font_list_omt_enabled_AtStartup
(
)
&
&
StaticPrefs
:
:
gfx_e10s_font_list_shared_AtStartup
(
)
&
&
!
gfxPlatform
:
:
InSafeMode
(
)
)
{
sInitFontListThread
=
PR_CreateThread
(
PR_USER_THREAD
InitFontListCallback
aList
PR_PRIORITY_NORMAL
PR_GLOBAL_THREAD
PR_JOINABLE_THREAD
0
)
;
return
true
;
}
if
(
aList
-
>
InitFontList
(
)
)
{
return
true
;
}
Shutdown
(
)
;
return
false
;
}
gfxPlatformFontList
:
:
gfxPlatformFontList
(
bool
aNeedFullnamePostscriptNames
)
:
mLock
(
"
gfxPlatformFontList
lock
"
)
mFontFamilies
(
64
)
mOtherFamilyNames
(
16
)
mSharedCmaps
(
8
)
{
if
(
aNeedFullnamePostscriptNames
)
{
mExtraNames
=
MakeUnique
<
ExtraNames
>
(
)
;
}
mLangService
=
nsLanguageAtomService
:
:
GetService
(
)
;
LoadBadUnderlineList
(
)
;
LoadIconFontOverrideList
(
)
;
mFontPrefs
=
MakeUnique
<
FontPrefs
>
(
)
;
gfxFontUtils
:
:
GetPrefsFontList
(
kFontSystemWhitelistPref
mEnabledFontsList
)
;
mFontFamilyWhitelistActive
=
!
mEnabledFontsList
.
IsEmpty
(
)
;
NS_ASSERTION
(
!
gFontListPrefObserver
"
There
has
been
font
list
pref
observer
already
"
)
;
gFontListPrefObserver
=
new
gfxFontListPrefObserver
(
)
;
NS_ADDREF
(
gFontListPrefObserver
)
;
Preferences
:
:
RegisterPrefixCallbacks
(
FontListPrefChanged
kObservedPrefs
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
AddObserver
(
gFontListPrefObserver
LOCALES_CHANGED_TOPIC
false
)
;
}
if
(
XRE_IsParentProcess
(
)
)
{
Preferences
:
:
RegisterCallback
(
FontWhitelistPrefChanged
kFontSystemWhitelistPref
)
;
}
RegisterStrongMemoryReporter
(
new
MemoryReporter
(
)
)
;
mDefaultGenericsLangGroup
.
AppendElements
(
std
:
:
size
(
gPrefLangNames
)
)
;
for
(
uint32_t
i
=
0
;
i
<
std
:
:
size
(
gPrefLangNames
)
;
i
+
+
)
{
nsAutoCString
prefDefaultFontType
(
"
font
.
default
.
"
)
;
prefDefaultFontType
.
Append
(
GetPrefLangName
(
eFontPrefLang
(
i
)
)
)
;
nsAutoCString
serifOrSans
;
Preferences
:
:
GetCString
(
prefDefaultFontType
.
get
(
)
serifOrSans
)
;
if
(
serifOrSans
.
EqualsLiteral
(
"
sans
-
serif
"
)
)
{
mDefaultGenericsLangGroup
[
i
]
=
StyleGenericFontFamily
:
:
SansSerif
;
}
else
{
mDefaultGenericsLangGroup
[
i
]
=
StyleGenericFontFamily
:
:
Serif
;
}
}
}
gfxPlatformFontList
:
:
~
gfxPlatformFontList
(
)
{
AutoLock
lock
(
mLock
)
;
for
(
auto
iter
=
mSharedCmaps
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Get
(
)
-
>
mCharMap
-
>
ClearSharedFlag
(
)
;
}
mSharedCmaps
.
Clear
(
)
;
ClearLangGroupPrefFontsLocked
(
)
;
NS_ASSERTION
(
gFontListPrefObserver
"
There
is
no
font
list
pref
observer
"
)
;
Preferences
:
:
UnregisterPrefixCallbacks
(
FontListPrefChanged
kObservedPrefs
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
gFontListPrefObserver
LOCALES_CHANGED_TOPIC
)
;
}
if
(
XRE_IsParentProcess
(
)
)
{
Preferences
:
:
UnregisterCallback
(
FontWhitelistPrefChanged
kFontSystemWhitelistPref
)
;
}
NS_RELEASE
(
gFontListPrefObserver
)
;
}
FontVisibility
gfxPlatformFontList
:
:
GetFontVisibility
(
nsCString
&
aFont
bool
&
aFound
)
{
AutoLock
lock
(
mLock
)
;
GenerateFontListKey
(
aFont
)
;
if
(
SharedFontList
(
)
)
{
auto
*
font
=
SharedFontList
(
)
-
>
FindFamily
(
aFont
)
;
if
(
font
)
{
aFound
=
true
;
return
font
-
>
Visibility
(
)
;
}
aFound
=
false
;
return
FontVisibility
:
:
Unknown
;
}
{
auto
*
font
=
mFontFamilies
.
GetWeak
(
aFont
)
;
if
(
font
)
{
aFound
=
true
;
return
font
-
>
Visibility
(
)
;
}
}
{
auto
*
font
=
mOtherFamilyNames
.
GetWeak
(
aFont
)
;
if
(
font
)
{
aFound
=
true
;
return
font
-
>
Visibility
(
)
;
}
}
aFound
=
false
;
return
FontVisibility
:
:
Unknown
;
}
bool
gfxPlatformFontList
:
:
GetMissingFonts
(
nsTArray
<
nsCString
>
&
aMissingFonts
)
{
AutoLock
lock
(
mLock
)
;
auto
fontLists
=
GetFilteredPlatformFontLists
(
)
;
if
(
!
fontLists
.
Length
(
)
)
{
return
false
;
}
for
(
unsigned
int
i
=
0
;
i
<
fontLists
.
Length
(
)
;
i
+
+
)
{
for
(
unsigned
int
j
=
0
;
j
<
fontLists
[
i
]
.
second
;
j
+
+
)
{
nsCString
key
(
fontLists
[
i
]
.
first
[
j
]
)
;
GenerateFontListKey
(
key
)
;
bool
found
=
false
;
GetFontVisibility
(
key
found
)
;
if
(
!
found
)
{
aMissingFonts
.
AppendElement
(
key
)
;
}
}
}
return
true
;
}
void
gfxPlatformFontList
:
:
GetMissingFonts
(
nsCString
&
aMissingFonts
)
{
nsTArray
<
nsCString
>
missingFonts
;
bool
fontlistExists
=
GetMissingFonts
(
missingFonts
)
;
if
(
!
fontlistExists
)
{
aMissingFonts
.
AssignLiteral
(
"
No
font
list
available
for
this
device
.
"
)
;
return
;
}
if
(
missingFonts
.
IsEmpty
(
)
)
{
aMissingFonts
.
Append
(
"
All
fonts
are
available
.
"
)
;
return
;
}
missingFonts
.
Sort
(
)
;
aMissingFonts
.
Append
(
StringJoin
(
"
|
"
_ns
missingFonts
)
)
;
}
void
gfxPlatformFontList
:
:
FontWhitelistPrefChanged
(
const
char
*
aPref
void
*
aClosure
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
auto
*
pfl
=
gfxPlatformFontList
:
:
PlatformFontList
(
)
;
pfl
-
>
UpdateFontList
(
true
)
;
dom
:
:
ContentParent
:
:
NotifyUpdatedFonts
(
true
)
;
}
void
gfxPlatformFontList
:
:
ApplyWhitelist
(
)
{
uint32_t
numFonts
=
mEnabledFontsList
.
Length
(
)
;
if
(
!
mFontFamilyWhitelistActive
)
{
return
;
}
nsTHashSet
<
nsCString
>
familyNamesWhitelist
;
for
(
uint32_t
i
=
0
;
i
<
numFonts
;
i
+
+
)
{
nsAutoCString
key
;
ToLowerCase
(
mEnabledFontsList
[
i
]
key
)
;
familyNamesWhitelist
.
Insert
(
key
)
;
}
AutoTArray
<
RefPtr
<
gfxFontFamily
>
128
>
accepted
;
bool
whitelistedFontFound
=
false
;
for
(
const
auto
&
entry
:
mFontFamilies
)
{
nsAutoCString
fontFamilyName
(
entry
.
GetKey
(
)
)
;
ToLowerCase
(
fontFamilyName
)
;
if
(
familyNamesWhitelist
.
Contains
(
fontFamilyName
)
)
{
accepted
.
AppendElement
(
entry
.
GetData
(
)
)
;
whitelistedFontFound
=
true
;
}
}
if
(
!
whitelistedFontFound
)
{
return
;
}
mFontFamilies
.
Clear
(
)
;
for
(
auto
&
f
:
accepted
)
{
nsAutoCString
fontFamilyName
(
f
-
>
Name
(
)
)
;
ToLowerCase
(
fontFamilyName
)
;
mFontFamilies
.
InsertOrUpdate
(
fontFamilyName
std
:
:
move
(
f
)
)
;
}
}
void
gfxPlatformFontList
:
:
ApplyWhitelist
(
nsTArray
<
fontlist
:
:
Family
:
:
InitData
>
&
aFamilies
)
{
mLock
.
AssertCurrentThreadIn
(
)
;
if
(
!
mFontFamilyWhitelistActive
)
{
return
;
}
nsTHashSet
<
nsCString
>
familyNamesWhitelist
;
for
(
const
auto
&
item
:
mEnabledFontsList
)
{
nsAutoCString
key
;
ToLowerCase
(
item
key
)
;
familyNamesWhitelist
.
Insert
(
key
)
;
}
AutoTArray
<
fontlist
:
:
Family
:
:
InitData
128
>
accepted
;
bool
keptNonHidden
=
false
;
for
(
auto
&
f
:
aFamilies
)
{
if
(
familyNamesWhitelist
.
Contains
(
f
.
mKey
)
)
{
accepted
.
AppendElement
(
f
)
;
if
(
f
.
mVisibility
!
=
FontVisibility
:
:
Hidden
)
{
keptNonHidden
=
true
;
}
}
}
if
(
!
keptNonHidden
)
{
return
;
}
aFamilies
=
std
:
:
move
(
accepted
)
;
}
bool
gfxPlatformFontList
:
:
FamilyInList
(
const
nsACString
&
aName
const
char
*
aList
[
]
size_t
aCount
)
{
size_t
result
;
return
BinarySearchIf
(
aList
0
aCount
[
&
]
(
const
char
*
const
aVal
)
-
>
int
{
return
nsCaseInsensitiveUTF8StringComparator
(
aName
.
BeginReading
(
)
aVal
aName
.
Length
(
)
strlen
(
aVal
)
)
;
}
&
result
)
;
}
void
gfxPlatformFontList
:
:
CheckFamilyList
(
const
char
*
aList
[
]
size_t
aCount
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
aCount
>
0
"
empty
font
family
list
?
"
)
;
const
char
*
a
=
aList
[
0
]
;
uint32_t
aLen
=
strlen
(
a
)
;
for
(
size_t
i
=
1
;
i
<
aCount
;
+
+
i
)
{
const
char
*
b
=
aList
[
i
]
;
uint32_t
bLen
=
strlen
(
b
)
;
if
(
nsCaseInsensitiveUTF8StringComparator
(
a
b
aLen
bLen
)
>
=
0
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
incorrectly
sorted
font
family
list
:
%
s
>
=
%
s
"
a
b
)
;
}
a
=
b
;
aLen
=
bLen
;
}
#
endif
}
bool
gfxPlatformFontList
:
:
AddWithLegacyFamilyName
(
const
nsACString
&
aLegacyName
gfxFontEntry
*
aFontEntry
FontVisibility
aVisibility
)
{
mLock
.
AssertCurrentThreadIn
(
)
;
bool
added
=
false
;
nsAutoCString
key
;
ToLowerCase
(
aLegacyName
key
)
;
mOtherFamilyNames
.
LookupOrInsertWith
(
key
[
&
]
{
RefPtr
<
gfxFontFamily
>
family
=
CreateFontFamily
(
aLegacyName
aVisibility
)
;
family
-
>
SetHasStyles
(
true
)
;
family
-
>
SetCheckedForLegacyFamilyNames
(
true
)
;
added
=
true
;
return
family
;
}
)
-
>
AddFontEntry
(
aFontEntry
-
>
Clone
(
)
)
;
return
added
;
}
bool
gfxPlatformFontList
:
:
InitFontList
(
)
{
if
(
sInitFontListThread
&
&
!
IsInitFontListThread
(
)
)
{
PR_JoinThread
(
sInitFontListThread
)
;
sInitFontListThread
=
nullptr
;
}
AutoLock
lock
(
mLock
)
;
if
(
LOG_FONTINIT_ENABLED
(
)
)
{
LOG_FONTINIT
(
(
"
(
fontinit
)
system
fontlist
initialization
\
n
"
)
)
;
}
if
(
IsInitialized
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
gfxFontCache
*
fontCache
=
gfxFontCache
:
:
GetCache
(
)
;
if
(
fontCache
)
{
fontCache
-
>
FlushShapedWordCaches
(
)
;
fontCache
-
>
Flush
(
)
;
}
gfxPlatform
:
:
PurgeSkiaFontCache
(
)
;
gfxPlatform
:
:
GlobalReflowFlags
flags
=
gfxPlatform
:
:
GlobalReflowFlags
:
:
NeedsReframe
|
gfxPlatform
:
:
GlobalReflowFlags
:
:
FontsChanged
;
ForceGlobalReflowLocked
(
flags
)
;
mAliasTable
.
Clear
(
)
;
mLocalNameTable
.
Clear
(
)
;
mIconFontsSet
.
Clear
(
)
;
CancelLoadCmapsTask
(
)
;
mStartedLoadingCmapsFrom
=
0xffffffffu
;
CancelInitOtherFamilyNamesTask
(
)
;
mFontFamilies
.
Clear
(
)
;
mOtherFamilyNames
.
Clear
(
)
;
mOtherFamilyNamesInitialized
=
false
;
if
(
mExtraNames
)
{
mExtraNames
-
>
mFullnames
.
Clear
(
)
;
mExtraNames
-
>
mPostscriptNames
.
Clear
(
)
;
}
mFaceNameListsInitialized
=
false
;
ClearLangGroupPrefFontsLocked
(
)
;
CancelLoader
(
)
;
for
(
auto
&
f
:
mReplacementCharFallbackFamily
)
{
f
=
FontFamily
(
)
;
}
gfxFontUtils
:
:
GetPrefsFontList
(
kFontSystemWhitelistPref
mEnabledFontsList
)
;
mFontFamilyWhitelistActive
=
!
mEnabledFontsList
.
IsEmpty
(
)
;
LoadIconFontOverrideList
(
)
;
}
mFontlistInitCount
+
+
;
InitializeCodepointsWithNoFonts
(
)
;
if
(
StaticPrefs
:
:
gfx_e10s_font_list_shared_AtStartup
(
)
&
&
!
gfxPlatform
:
:
InSafeMode
(
)
)
{
for
(
const
auto
&
entry
:
mFontEntries
.
Values
(
)
)
{
if
(
!
entry
)
{
continue
;
}
AutoWriteLock
lock
(
entry
-
>
mLock
)
;
entry
-
>
mShmemCharacterMap
=
nullptr
;
entry
-
>
mShmemFace
=
nullptr
;
entry
-
>
mFamilyName
.
Truncate
(
)
;
}
mFontEntries
.
Clear
(
)
;
mShmemCharMaps
.
Clear
(
)
;
bool
oldSharedList
=
mSharedFontList
!
=
nullptr
;
mSharedFontList
.
reset
(
new
fontlist
:
:
FontList
(
mFontlistInitCount
)
)
;
InitSharedFontListForPlatform
(
)
;
if
(
mSharedFontList
&
&
mSharedFontList
-
>
Initialized
(
)
)
{
if
(
mLocalNameTable
.
Count
(
)
)
{
SharedFontList
(
)
-
>
SetLocalNames
(
mLocalNameTable
)
;
mLocalNameTable
.
Clear
(
)
;
}
}
else
{
gfxCriticalNote
<
<
"
Failed
to
initialize
shared
font
list
"
"
falling
back
to
in
-
process
list
.
"
;
mSharedFontList
.
reset
(
nullptr
)
;
}
if
(
oldSharedList
&
&
XRE_IsParentProcess
(
)
)
{
if
(
NS_IsMainThread
(
)
)
{
dom
:
:
ContentParent
:
:
NotifyUpdatedFonts
(
true
)
;
}
else
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
NotifyUpdatedFonts
callback
"
[
]
{
dom
:
:
ContentParent
:
:
NotifyUpdatedFonts
(
true
)
;
}
)
)
;
}
}
}
if
(
!
SharedFontList
(
)
)
{
if
(
NS_FAILED
(
InitFontListForPlatform
(
)
)
)
{
mFontlistInitCount
=
0
;
return
false
;
}
ApplyWhitelist
(
)
;
}
gfxFontStyle
defStyle
;
FontFamily
fam
=
GetDefaultFontLocked
(
nullptr
&
defStyle
)
;
gfxFontEntry
*
fe
;
if
(
fam
.
mShared
)
{
auto
face
=
fam
.
mShared
-
>
FindFaceForStyle
(
SharedFontList
(
)
defStyle
)
;
fe
=
face
?
GetOrCreateFontEntryLocked
(
face
fam
.
mShared
)
:
nullptr
;
}
else
{
fe
=
fam
.
mUnshared
-
>
FindFontForStyle
(
defStyle
)
;
}
mDefaultFontEntry
=
fe
;
if
(
XRE_IsParentProcess
(
)
&
&
NS_IsMainThread
(
)
)
{
if
(
nsCOMPtr
<
nsIObserverService
>
obsvc
=
services
:
:
GetObserverService
(
)
)
{
obsvc
-
>
NotifyObservers
(
nullptr
"
font
-
list
-
initialized
"
nullptr
)
;
}
}
return
true
;
}
void
gfxPlatformFontList
:
:
LoadIconFontOverrideList
(
)
{
mIconFontsSet
.
Clear
(
)
;
AutoTArray
<
nsCString
20
>
iconFontsList
;
gfxFontUtils
:
:
GetPrefsFontList
(
kIconFontsPref
iconFontsList
)
;
for
(
auto
&
name
:
iconFontsList
)
{
ToLowerCase
(
name
)
;
mIconFontsSet
.
Insert
(
name
)
;
}
}
void
gfxPlatformFontList
:
:
InitializeCodepointsWithNoFonts
(
)
{
auto
&
first
=
mCodepointsWithNoFonts
[
FontVisibility
(
0
)
]
;
for
(
auto
&
bitset
:
mCodepointsWithNoFonts
)
{
if
(
&
bitset
=
=
&
first
)
{
bitset
.
reset
(
)
;
bitset
.
SetRange
(
0
0x1f
)
;
bitset
.
SetRange
(
0x7f
0x9f
)
;
bitset
.
SetRange
(
0xE000
0xF8FF
)
;
bitset
.
SetRange
(
0xF0000
0x10FFFD
)
;
bitset
.
SetRange
(
0xfdd0
0xfdef
)
;
for
(
unsigned
i
=
0
;
i
<
=
0x100000
;
i
+
=
0x10000
)
{
bitset
.
SetRange
(
i
+
0xfffe
i
+
0xffff
)
;
}
bitset
.
Compact
(
)
;
}
else
{
bitset
=
first
;
}
}
}
void
gfxPlatformFontList
:
:
GenerateFontListKey
(
const
nsACString
&
aKeyName
nsACString
&
aResult
)
{
aResult
=
aKeyName
;
ToLowerCase
(
aResult
)
;
}
void
gfxPlatformFontList
:
:
GenerateFontListKey
(
nsACString
&
aKeyName
)
{
ToLowerCase
(
aKeyName
)
;
}
class
InitOtherFamilyNamesForStylo
:
public
mozilla
:
:
Runnable
{
public
:
explicit
InitOtherFamilyNamesForStylo
(
bool
aDeferOtherFamilyNamesLoading
)
:
Runnable
(
"
gfxPlatformFontList
:
:
InitOtherFamilyNamesForStylo
"
)
mDefer
(
aDeferOtherFamilyNamesLoading
)
{
}
NS_IMETHOD
Run
(
)
override
{
auto
pfl
=
gfxPlatformFontList
:
:
PlatformFontList
(
)
;
auto
list
=
pfl
-
>
SharedFontList
(
)
;
if
(
!
list
)
{
return
NS_OK
;
}
bool
initialized
=
false
;
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendInitOtherFamilyNames
(
list
-
>
GetGeneration
(
)
mDefer
&
initialized
)
;
pfl
-
>
mOtherFamilyNamesInitialized
.
compareExchange
(
false
initialized
)
;
return
NS_OK
;
}
private
:
bool
mDefer
;
}
;
#
define
OTHERNAMES_TIMEOUT
200
bool
gfxPlatformFontList
:
:
InitOtherFamilyNames
(
bool
aDeferOtherFamilyNamesLoading
)
{
if
(
mOtherFamilyNamesInitialized
)
{
return
true
;
}
if
(
SharedFontList
(
)
&
&
!
XRE_IsParentProcess
(
)
)
{
if
(
NS_IsMainThread
(
)
)
{
bool
initialized
;
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendInitOtherFamilyNames
(
SharedFontList
(
)
-
>
GetGeneration
(
)
aDeferOtherFamilyNamesLoading
&
initialized
)
;
mOtherFamilyNamesInitialized
.
compareExchange
(
false
initialized
)
;
}
else
{
NS_DispatchToMainThread
(
new
InitOtherFamilyNamesForStylo
(
aDeferOtherFamilyNamesLoading
)
)
;
}
return
mOtherFamilyNamesInitialized
;
}
if
(
aDeferOtherFamilyNamesLoading
&
&
StaticPrefs
:
:
gfx_font_loader_delay
(
)
>
0
)
{
if
(
!
mPendingOtherFamilyNameTask
)
{
RefPtr
<
mozilla
:
:
CancelableRunnable
>
task
=
new
InitOtherFamilyNamesRunnable
(
)
;
mPendingOtherFamilyNameTask
=
task
;
NS_DispatchToMainThreadQueue
(
task
.
forget
(
)
EventQueuePriority
:
:
Idle
)
;
}
}
else
{
InitOtherFamilyNamesInternal
(
false
)
;
}
return
mOtherFamilyNamesInitialized
;
}
#
define
NAMELIST_TIMEOUT
200
gfxFontEntry
*
gfxPlatformFontList
:
:
SearchFamiliesForFaceName
(
const
nsACString
&
aFaceName
)
{
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
bool
timedOut
=
false
;
char16_t
firstChar
=
0
;
gfxFontEntry
*
lookup
=
nullptr
;
firstChar
=
ToLowerCase
(
aFaceName
.
CharAt
(
0
)
)
;
for
(
const
auto
&
entry
:
mFontFamilies
)
{
nsCStringHashKey
:
:
KeyType
key
=
entry
.
GetKey
(
)
;
const
RefPtr
<
gfxFontFamily
>
&
family
=
entry
.
GetData
(
)
;
if
(
firstChar
&
&
ToLowerCase
(
key
.
CharAt
(
0
)
)
!
=
firstChar
)
{
continue
;
}
family
-
>
ReadFaceNames
(
this
NeedFullnamePostscriptNames
(
)
)
;
TimeDuration
elapsed
=
TimeStamp
:
:
Now
(
)
-
start
;
if
(
elapsed
.
ToMilliseconds
(
)
>
NAMELIST_TIMEOUT
)
{
timedOut
=
true
;
break
;
}
}
lookup
=
FindFaceName
(
aFaceName
)
;
TimeDuration
elapsed
=
TimeStamp
:
:
Now
(
)
-
start
;
glean
:
:
fontlist
:
:
initfacenamelists
.
AccumulateRawDuration
(
elapsed
)
;
if
(
LOG_FONTINIT_ENABLED
(
)
)
{
LOG_FONTINIT
(
(
"
(
fontinit
)
SearchFamiliesForFaceName
took
%
8
.
2f
ms
%
s
%
s
"
elapsed
.
ToMilliseconds
(
)
(
lookup
?
"
found
name
"
:
"
"
)
(
timedOut
?
"
timeout
"
:
"
"
)
)
)
;
}
return
lookup
;
}
gfxFontEntry
*
gfxPlatformFontList
:
:
FindFaceName
(
const
nsACString
&
aFaceName
)
{
gfxFontEntry
*
lookup
;
if
(
mExtraNames
&
&
(
(
lookup
=
mExtraNames
-
>
mPostscriptNames
.
GetWeak
(
aFaceName
)
)
|
|
(
lookup
=
mExtraNames
-
>
mFullnames
.
GetWeak
(
aFaceName
)
)
)
)
{
return
lookup
;
}
return
nullptr
;
}
gfxFontEntry
*
gfxPlatformFontList
:
:
LookupInFaceNameLists
(
const
nsACString
&
aFaceName
)
{
gfxFontEntry
*
lookup
=
nullptr
;
if
(
!
mFaceNameListsInitialized
)
{
lookup
=
SearchFamiliesForFaceName
(
aFaceName
)
;
if
(
lookup
)
{
return
lookup
;
}
}
if
(
!
(
lookup
=
FindFaceName
(
aFaceName
)
)
)
{
if
(
!
mFaceNameListsInitialized
)
{
if
(
!
mFaceNamesMissed
)
{
mFaceNamesMissed
=
MakeUnique
<
nsTHashSet
<
nsCString
>
>
(
2
)
;
}
mFaceNamesMissed
-
>
Insert
(
aFaceName
)
;
}
}
return
lookup
;
}
gfxFontEntry
*
gfxPlatformFontList
:
:
LookupInSharedFaceNameList
(
FontVisibilityProvider
*
aFontVisibilityProvider
const
nsACString
&
aFaceName
WeightRange
aWeightForEntry
StretchRange
aStretchForEntry
SlantStyleRange
aStyleForEntry
)
{
nsAutoCString
keyName
(
aFaceName
)
;
ToLowerCase
(
keyName
)
;
fontlist
:
:
FontList
*
list
=
SharedFontList
(
)
;
fontlist
:
:
Family
*
family
=
nullptr
;
fontlist
:
:
Face
*
face
=
nullptr
;
if
(
list
-
>
NumLocalFaces
(
)
)
{
fontlist
:
:
LocalFaceRec
*
rec
=
list
-
>
FindLocalFace
(
keyName
)
;
if
(
rec
)
{
auto
*
families
=
list
-
>
Families
(
)
;
if
(
families
)
{
family
=
&
families
[
rec
-
>
mFamilyIndex
]
;
face
=
family
-
>
Faces
(
list
)
[
rec
-
>
mFaceIndex
]
.
ToPtr
<
fontlist
:
:
Face
>
(
list
)
;
}
}
}
else
{
list
-
>
SearchForLocalFace
(
keyName
&
family
&
face
)
;
}
if
(
!
face
|
|
!
family
)
{
return
nullptr
;
}
FontVisibility
level
=
aFontVisibilityProvider
?
aFontVisibilityProvider
-
>
GetFontVisibility
(
)
:
FontVisibility
:
:
User
;
if
(
!
IsVisibleToCSS
(
*
family
level
)
)
{
if
(
aFontVisibilityProvider
)
{
aFontVisibilityProvider
-
>
ReportBlockedFontFamily
(
*
family
)
;
}
return
nullptr
;
}
gfxFontEntry
*
fe
=
CreateFontEntry
(
face
family
)
;
if
(
fe
)
{
fe
-
>
mIsLocalUserFont
=
true
;
fe
-
>
mWeightRange
=
aWeightForEntry
;
fe
-
>
mStretchRange
=
aStretchForEntry
;
fe
-
>
mStyleRange
=
aStyleForEntry
;
}
return
fe
;
}
void
gfxPlatformFontList
:
:
MaybeAddToLocalNameTable
(
const
nsACString
&
aName
const
fontlist
:
:
LocalFaceRec
:
:
InitData
&
aData
)
{
auto
nameSimilarity
=
[
]
(
const
nsACString
&
aName
const
nsACString
&
aReference
)
-
>
uint32_t
{
uint32_t
nameIdx
=
0
refIdx
=
0
matchCount
=
0
;
while
(
nameIdx
<
aName
.
Length
(
)
&
&
refIdx
<
aReference
.
Length
(
)
)
{
while
(
nameIdx
<
aName
.
Length
(
)
&
&
IsAscii
(
aName
[
nameIdx
]
)
&
&
!
IsAsciiAlphanumeric
(
aName
[
nameIdx
]
)
)
{
+
+
nameIdx
;
}
while
(
refIdx
<
aReference
.
Length
(
)
&
&
IsAscii
(
aReference
[
refIdx
]
)
&
&
!
IsAsciiAlphanumeric
(
aReference
[
refIdx
]
)
)
{
+
+
refIdx
;
}
if
(
nameIdx
=
=
aName
.
Length
(
)
|
|
refIdx
=
=
aReference
.
Length
(
)
|
|
aName
[
nameIdx
]
!
=
aReference
[
refIdx
]
)
{
break
;
}
+
+
nameIdx
;
+
+
refIdx
;
+
+
matchCount
;
}
return
matchCount
;
}
;
mLocalNameTable
.
WithEntryHandle
(
aName
[
&
]
(
auto
entry
)
-
>
void
{
if
(
entry
)
{
if
(
nameSimilarity
(
aName
aData
.
mFamilyName
)
>
nameSimilarity
(
aName
entry
.
Data
(
)
.
mFamilyName
)
)
{
entry
.
Update
(
aData
)
;
}
}
else
{
entry
.
OrInsert
(
aData
)
;
}
}
)
;
}
void
gfxPlatformFontList
:
:
LoadBadUnderlineList
(
)
{
gfxFontUtils
:
:
GetPrefsFontList
(
"
font
.
blacklist
.
underline_offset
"
mBadUnderlineFamilyNames
)
;
for
(
auto
&
fam
:
mBadUnderlineFamilyNames
)
{
ToLowerCase
(
fam
)
;
}
mBadUnderlineFamilyNames
.
Compact
(
)
;
mBadUnderlineFamilyNames
.
Sort
(
)
;
}
void
gfxPlatformFontList
:
:
UpdateFontList
(
bool
aFullRebuild
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aFullRebuild
)
{
InitFontList
(
)
;
AutoLock
lock
(
mLock
)
;
RebuildLocalFonts
(
)
;
}
else
{
AutoLock
lock
(
mLock
)
;
if
(
mStartedLoadingCmapsFrom
!
=
0xffffffffu
)
{
InitializeCodepointsWithNoFonts
(
)
;
mStartedLoadingCmapsFrom
=
0xffffffffu
;
gfxPlatform
:
:
GlobalReflowFlags
flags
=
gfxPlatform
:
:
GlobalReflowFlags
:
:
FontsChanged
|
gfxPlatform
:
:
GlobalReflowFlags
:
:
BroadcastToChildren
;
ForceGlobalReflowLocked
(
flags
)
;
}
}
}
bool
gfxPlatformFontList
:
:
IsVisibleToCSS
(
const
gfxFontFamily
&
aFamily
FontVisibility
aVisibility
)
const
{
return
aFamily
.
Visibility
(
)
<
=
aVisibility
|
|
IsFontFamilyWhitelistActive
(
)
;
}
bool
gfxPlatformFontList
:
:
IsVisibleToCSS
(
const
fontlist
:
:
Family
&
aFamily
FontVisibility
aVisibility
)
const
{
return
aFamily
.
Visibility
(
)
<
=
aVisibility
|
|
IsFontFamilyWhitelistActive
(
)
;
}
void
gfxPlatformFontList
:
:
GetFontList
(
nsAtom
*
aLangGroup
const
nsACString
&
aGenericFamily
nsTArray
<
nsString
>
&
aListOfFonts
)
{
AutoLock
lock
(
mLock
)
;
if
(
SharedFontList
(
)
)
{
fontlist
:
:
FontList
*
list
=
SharedFontList
(
)
;
const
fontlist
:
:
Family
*
families
=
list
-
>
Families
(
)
;
if
(
families
)
{
for
(
uint32_t
i
=
0
;
i
<
list
-
>
NumFamilies
(
)
;
i
+
+
)
{
auto
&
f
=
families
[
i
]
;
if
(
!
IsVisibleToCSS
(
f
FontVisibility
:
:
User
)
|
|
f
.
IsAltLocaleFamily
(
)
)
{
continue
;
}
aListOfFonts
.
AppendElement
(
NS_ConvertUTF8toUTF16
(
list
-
>
LocalizedFamilyName
(
&
f
)
)
)
;
}
}
return
;
}
for
(
const
RefPtr
<
gfxFontFamily
>
&
family
:
mFontFamilies
.
Values
(
)
)
{
if
(
!
IsVisibleToCSS
(
*
family
FontVisibility
:
:
User
)
)
{
continue
;
}
if
(
family
-
>
FilterForFontList
(
aLangGroup
aGenericFamily
)
)
{
nsAutoCString
localizedFamilyName
;
family
-
>
LocalizedName
(
localizedFamilyName
)
;
aListOfFonts
.
AppendElement
(
NS_ConvertUTF8toUTF16
(
localizedFamilyName
)
)
;
}
}
aListOfFonts
.
Sort
(
)
;
aListOfFonts
.
Compact
(
)
;
}
void
gfxPlatformFontList
:
:
GetFontFamilyList
(
nsTArray
<
RefPtr
<
gfxFontFamily
>
>
&
aFamilyArray
)
{
AutoLock
lock
(
mLock
)
;
MOZ_ASSERT
(
aFamilyArray
.
IsEmpty
(
)
)
;
aFamilyArray
.
SetCapacity
(
mFontFamilies
.
Count
(
)
)
;
for
(
const
auto
&
family
:
mFontFamilies
.
Values
(
)
)
{
aFamilyArray
.
AppendElement
(
family
)
;
}
}
already_AddRefed
<
gfxFont
>
gfxPlatformFontList
:
:
SystemFindFontForChar
(
FontVisibilityProvider
*
aFontVisibilityProvider
uint32_t
aCh
uint32_t
aNextCh
Script
aRunScript
FontPresentation
aPresentation
const
gfxFontStyle
*
aStyle
FontVisibility
*
aVisibility
)
{
AutoLock
lock
(
mLock
)
;
FontVisibility
level
=
aFontVisibilityProvider
?
aFontVisibilityProvider
-
>
GetFontVisibility
(
)
:
FontVisibility
:
:
User
;
MOZ_ASSERT
(
!
mCodepointsWithNoFonts
[
level
]
.
test
(
aCh
)
"
don
'
t
call
for
codepoints
already
known
to
be
unsupported
"
)
;
if
(
aCh
=
=
0xFFFD
)
{
gfxFontEntry
*
fontEntry
=
nullptr
;
auto
&
fallbackFamily
=
mReplacementCharFallbackFamily
[
level
]
;
if
(
fallbackFamily
.
mShared
)
{
fontlist
:
:
Face
*
face
=
fallbackFamily
.
mShared
-
>
FindFaceForStyle
(
SharedFontList
(
)
*
aStyle
)
;
if
(
face
)
{
fontEntry
=
GetOrCreateFontEntryLocked
(
face
fallbackFamily
.
mShared
)
;
*
aVisibility
=
fallbackFamily
.
mShared
-
>
Visibility
(
)
;
}
}
else
if
(
fallbackFamily
.
mUnshared
)
{
fontEntry
=
fallbackFamily
.
mUnshared
-
>
FindFontForStyle
(
*
aStyle
)
;
*
aVisibility
=
fallbackFamily
.
mUnshared
-
>
Visibility
(
)
;
}
if
(
fontEntry
&
&
fontEntry
-
>
HasCharacter
(
aCh
)
)
{
return
fontEntry
-
>
FindOrMakeFont
(
aStyle
)
;
}
}
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
bool
common
=
true
;
FontFamily
fallbackFamily
;
RefPtr
<
gfxFont
>
candidate
=
CommonFontFallback
(
aFontVisibilityProvider
aCh
aNextCh
aRunScript
aPresentation
aStyle
fallbackFamily
)
;
RefPtr
<
gfxFont
>
font
;
if
(
candidate
)
{
if
(
aPresentation
=
=
FontPresentation
:
:
Any
)
{
font
=
std
:
:
move
(
candidate
)
;
}
else
{
bool
hasColorGlyph
=
candidate
-
>
HasColorGlyphFor
(
aCh
aNextCh
)
;
if
(
hasColorGlyph
=
=
PrefersColor
(
aPresentation
)
)
{
font
=
std
:
:
move
(
candidate
)
;
}
}
}
uint32_t
cmapCount
=
0
;
if
(
!
font
)
{
common
=
false
;
font
=
GlobalFontFallback
(
aFontVisibilityProvider
aCh
aNextCh
aRunScript
aPresentation
aStyle
cmapCount
fallbackFamily
)
;
if
(
font
&
&
aPresentation
!
=
FontPresentation
:
:
Any
&
&
candidate
)
{
bool
hasColorGlyph
=
font
-
>
HasColorGlyphFor
(
aCh
aNextCh
)
;
if
(
hasColorGlyph
!
=
PrefersColor
(
aPresentation
)
)
{
font
=
std
:
:
move
(
candidate
)
;
}
}
}
TimeDuration
elapsed
=
TimeStamp
:
:
Now
(
)
-
start
;
LogModule
*
log
=
gfxPlatform
:
:
GetLog
(
eGfxLog_textrun
)
;
if
(
MOZ_UNLIKELY
(
MOZ_LOG_TEST
(
log
LogLevel
:
:
Warning
)
)
)
{
Script
script
=
intl
:
:
UnicodeProperties
:
:
GetScriptCode
(
aCh
)
;
MOZ_LOG
(
log
LogLevel
:
:
Warning
(
"
(
textrun
-
systemfallback
-
%
s
)
char
:
u
+
%
6
.
6x
"
"
script
:
%
d
match
:
[
%
s
]
"
"
time
:
%
dus
cmaps
:
%
d
\
n
"
(
common
?
"
common
"
:
"
global
"
)
aCh
static_cast
<
int
>
(
script
)
(
font
?
font
-
>
GetFontEntry
(
)
-
>
Name
(
)
.
get
(
)
:
"
<
none
>
"
)
int32_t
(
elapsed
.
ToMicroseconds
(
)
)
cmapCount
)
)
;
}
if
(
!
font
)
{
mCodepointsWithNoFonts
[
level
]
.
set
(
aCh
)
;
}
else
{
*
aVisibility
=
fallbackFamily
.
mShared
?
fallbackFamily
.
mShared
-
>
Visibility
(
)
:
fallbackFamily
.
mUnshared
-
>
Visibility
(
)
;
if
(
aCh
=
=
0xFFFD
)
{
mReplacementCharFallbackFamily
[
level
]
=
fallbackFamily
;
}
}
static
bool
first
=
true
;
if
(
first
)
glean
:
:
fontlist
:
:
system_font_fallback_first
.
AccumulateRawDuration
(
elapsed
)
;
else
glean
:
:
fontlist
:
:
system_font_fallback
.
AccumulateRawDuration
(
elapsed
)
;
first
=
false
;
return
font
.
forget
(
)
;
}
#
define
NUM_FALLBACK_FONTS
8
already_AddRefed
<
gfxFont
>
gfxPlatformFontList
:
:
CommonFontFallback
(
FontVisibilityProvider
*
aFontVisibilityProvider
uint32_t
aCh
uint32_t
aNextCh
Script
aRunScript
FontPresentation
aPresentation
const
gfxFontStyle
*
aMatchStyle
FontFamily
&
aMatchedFamily
)
{
AutoTArray
<
const
char
*
NUM_FALLBACK_FONTS
>
defaultFallbacks
;
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetCommonFallbackFonts
(
aCh
aRunScript
aPresentation
defaultFallbacks
)
;
GlobalFontMatch
data
(
aCh
aNextCh
*
aMatchStyle
aPresentation
)
;
FontVisibility
level
=
aFontVisibilityProvider
?
aFontVisibilityProvider
-
>
GetFontVisibility
(
)
:
FontVisibility
:
:
User
;
RefPtr
<
gfxFont
>
candidateFont
;
FontFamily
candidateFamily
;
auto
check
=
[
&
]
(
gfxFontEntry
*
aFontEntry
FontFamily
aFamily
)
-
>
already_AddRefed
<
gfxFont
>
{
RefPtr
<
gfxFont
>
font
=
aFontEntry
-
>
FindOrMakeFont
(
aMatchStyle
)
;
if
(
aPresentation
<
FontPresentation
:
:
EmojiDefault
|
|
font
-
>
HasColorGlyphFor
(
aCh
aNextCh
)
)
{
aMatchedFamily
=
aFamily
;
return
font
.
forget
(
)
;
}
if
(
!
candidateFont
)
{
candidateFont
=
std
:
:
move
(
font
)
;
candidateFamily
=
aFamily
;
}
return
nullptr
;
}
;
if
(
SharedFontList
(
)
)
{
for
(
const
auto
name
:
defaultFallbacks
)
{
fontlist
:
:
Family
*
family
=
FindSharedFamily
(
aFontVisibilityProvider
nsDependentCString
(
name
)
)
;
if
(
!
family
|
|
!
IsVisibleToCSS
(
*
family
level
)
)
{
continue
;
}
family
-
>
SearchAllFontsForChar
(
SharedFontList
(
)
&
data
)
;
if
(
data
.
mBestMatch
)
{
RefPtr
<
gfxFont
>
font
=
check
(
data
.
mBestMatch
FontFamily
(
family
)
)
;
if
(
font
)
{
return
font
.
forget
(
)
;
}
}
}
}
else
{
for
(
const
auto
name
:
defaultFallbacks
)
{
gfxFontFamily
*
fallback
=
FindFamilyByCanonicalName
(
nsDependentCString
(
name
)
)
;
if
(
!
fallback
|
|
!
IsVisibleToCSS
(
*
fallback
level
)
)
{
continue
;
}
fallback
-
>
FindFontForChar
(
&
data
)
;
if
(
data
.
mBestMatch
)
{
RefPtr
<
gfxFont
>
font
=
check
(
data
.
mBestMatch
FontFamily
(
fallback
)
)
;
if
(
font
)
{
return
font
.
forget
(
)
;
}
}
}
}
if
(
candidateFont
)
{
aMatchedFamily
=
candidateFamily
;
return
candidateFont
.
forget
(
)
;
}
return
nullptr
;
}
already_AddRefed
<
gfxFont
>
gfxPlatformFontList
:
:
GlobalFontFallback
(
FontVisibilityProvider
*
aFontVisibilityProvider
uint32_t
aCh
uint32_t
aNextCh
Script
aRunScript
FontPresentation
aPresentation
const
gfxFontStyle
*
aMatchStyle
uint32_t
&
aCmapCount
FontFamily
&
aMatchedFamily
)
{
bool
useCmaps
=
IsFontFamilyWhitelistActive
(
)
|
|
gfxPlatform
:
:
GetPlatform
(
)
-
>
UseCmapsDuringSystemFallback
(
)
;
FontVisibility
level
=
aFontVisibilityProvider
?
aFontVisibilityProvider
-
>
GetFontVisibility
(
)
:
FontVisibility
:
:
User
;
if
(
!
useCmaps
)
{
gfxFontEntry
*
fe
=
PlatformGlobalFontFallback
(
aFontVisibilityProvider
aCh
aRunScript
aMatchStyle
aMatchedFamily
)
;
if
(
fe
)
{
if
(
aMatchedFamily
.
mShared
)
{
if
(
IsVisibleToCSS
(
*
aMatchedFamily
.
mShared
level
)
)
{
RefPtr
<
gfxFont
>
font
=
fe
-
>
FindOrMakeFont
(
aMatchStyle
)
;
if
(
font
)
{
if
(
aPresentation
=
=
FontPresentation
:
:
Any
)
{
return
font
.
forget
(
)
;
}
bool
hasColorGlyph
=
font
-
>
HasColorGlyphFor
(
aCh
aNextCh
)
;
if
(
hasColorGlyph
=
=
PrefersColor
(
aPresentation
)
)
{
return
font
.
forget
(
)
;
}
}
}
}
else
{
if
(
IsVisibleToCSS
(
*
aMatchedFamily
.
mUnshared
level
)
)
{
RefPtr
<
gfxFont
>
font
=
fe
-
>
FindOrMakeFont
(
aMatchStyle
)
;
if
(
font
)
{
if
(
aPresentation
=
=
FontPresentation
:
:
Any
)
{
return
font
.
forget
(
)
;
}
bool
hasColorGlyph
=
font
-
>
HasColorGlyphFor
(
aCh
aNextCh
)
;
if
(
hasColorGlyph
=
=
PrefersColor
(
aPresentation
)
)
{
return
font
.
forget
(
)
;
}
}
}
}
}
}
GlobalFontMatch
data
(
aCh
aNextCh
*
aMatchStyle
aPresentation
)
;
if
(
SharedFontList
(
)
)
{
fontlist
:
:
Family
*
families
=
SharedFontList
(
)
-
>
Families
(
)
;
if
(
families
)
{
for
(
uint32_t
i
=
0
;
i
<
SharedFontList
(
)
-
>
NumFamilies
(
)
;
i
+
+
)
{
fontlist
:
:
Family
&
family
=
families
[
i
]
;
if
(
!
IsVisibleToCSS
(
family
level
)
)
{
continue
;
}
if
(
!
family
.
IsFullyInitialized
(
)
&
&
StaticPrefs
:
:
gfx_font_rendering_fallback_async
(
)
&
&
!
XRE_IsParentProcess
(
)
)
{
StartCmapLoadingFromFamily
(
i
)
;
}
else
{
family
.
SearchAllFontsForChar
(
SharedFontList
(
)
&
data
)
;
if
(
data
.
mMatchDistance
=
=
0
.
0
)
{
break
;
}
}
}
if
(
data
.
mBestMatch
)
{
aMatchedFamily
=
FontFamily
(
data
.
mMatchedSharedFamily
)
;
return
data
.
mBestMatch
-
>
FindOrMakeFont
(
aMatchStyle
)
;
}
}
}
else
{
for
(
const
RefPtr
<
gfxFontFamily
>
&
family
:
mFontFamilies
.
Values
(
)
)
{
if
(
!
IsVisibleToCSS
(
*
family
level
)
)
{
continue
;
}
family
-
>
FindFontForChar
(
&
data
)
;
if
(
data
.
mMatchDistance
=
=
0
.
0
)
{
break
;
}
}
aCmapCount
=
data
.
mCmapsTested
;
if
(
data
.
mBestMatch
)
{
aMatchedFamily
=
FontFamily
(
data
.
mMatchedFamily
)
;
return
data
.
mBestMatch
-
>
FindOrMakeFont
(
aMatchStyle
)
;
}
}
return
nullptr
;
}
class
StartCmapLoadingRunnable
:
public
mozilla
:
:
Runnable
{
public
:
explicit
StartCmapLoadingRunnable
(
uint32_t
aStartIndex
)
:
Runnable
(
"
gfxPlatformFontList
:
:
StartCmapLoadingRunnable
"
)
mStartIndex
(
aStartIndex
)
{
}
NS_IMETHOD
Run
(
)
override
{
auto
*
pfl
=
gfxPlatformFontList
:
:
PlatformFontList
(
)
;
auto
*
list
=
pfl
-
>
SharedFontList
(
)
;
if
(
!
list
)
{
return
NS_OK
;
}
if
(
mStartIndex
>
=
list
-
>
NumFamilies
(
)
)
{
return
NS_OK
;
}
if
(
XRE_IsParentProcess
(
)
)
{
pfl
-
>
StartCmapLoading
(
list
-
>
GetGeneration
(
)
mStartIndex
)
;
}
else
{
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendStartCmapLoading
(
list
-
>
GetGeneration
(
)
mStartIndex
)
;
}
return
NS_OK
;
}
private
:
uint32_t
mStartIndex
;
}
;
void
gfxPlatformFontList
:
:
StartCmapLoadingFromFamily
(
uint32_t
aStartIndex
)
{
AutoLock
lock
(
mLock
)
;
if
(
aStartIndex
>
=
mStartedLoadingCmapsFrom
)
{
return
;
}
mStartedLoadingCmapsFrom
=
aStartIndex
;
if
(
NS_IsMainThread
(
)
)
{
auto
*
list
=
SharedFontList
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
StartCmapLoading
(
list
-
>
GetGeneration
(
)
aStartIndex
)
;
}
else
{
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendStartCmapLoading
(
list
-
>
GetGeneration
(
)
aStartIndex
)
;
}
}
else
{
NS_DispatchToMainThread
(
new
StartCmapLoadingRunnable
(
aStartIndex
)
)
;
}
}
class
LoadCmapsRunnable
final
:
public
IdleRunnable
public
nsIObserver
public
nsSupportsWeakReference
{
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIOBSERVER
private
:
virtual
~
LoadCmapsRunnable
(
)
{
if
(
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
)
{
obs
-
>
RemoveObserver
(
this
NS_XPCOM_WILL_SHUTDOWN_OBSERVER_ID
)
;
}
}
public
:
LoadCmapsRunnable
(
uint32_t
aGeneration
uint32_t
aFamilyIndex
)
:
IdleRunnable
(
"
gfxPlatformFontList
:
:
LoadCmapsRunnable
"
)
mGeneration
(
aGeneration
)
mStartIndex
(
aFamilyIndex
)
mIndex
(
aFamilyIndex
)
{
}
void
SetDeadline
(
TimeStamp
aDeadline
)
override
{
mDeadline
=
aDeadline
;
}
void
MaybeResetIndex
(
uint32_t
aFamilyIndex
)
{
if
(
aFamilyIndex
<
mStartIndex
)
{
mStartIndex
=
aFamilyIndex
;
mIndex
=
aFamilyIndex
;
}
}
void
Cancel
(
)
{
mIsCanceled
=
true
;
}
NS_IMETHOD
Run
(
)
override
{
if
(
mIsCanceled
)
{
return
NS_OK
;
}
auto
*
pfl
=
gfxPlatformFontList
:
:
PlatformFontList
(
)
;
auto
*
list
=
pfl
-
>
SharedFontList
(
)
;
MOZ_ASSERT
(
list
)
;
if
(
!
list
)
{
return
NS_OK
;
}
if
(
mGeneration
!
=
list
-
>
GetGeneration
(
)
)
{
return
NS_OK
;
}
uint32_t
numFamilies
=
list
-
>
NumFamilies
(
)
;
if
(
mIndex
>
=
numFamilies
)
{
return
NS_OK
;
}
auto
*
families
=
list
-
>
Families
(
)
;
while
(
mIndex
<
numFamilies
)
{
auto
&
family
=
families
[
mIndex
+
+
]
;
if
(
family
.
IsFullyInitialized
(
)
)
{
continue
;
}
Unused
<
<
pfl
-
>
InitializeFamily
(
&
family
true
)
;
break
;
}
if
(
mIndex
<
numFamilies
)
{
mDeadline
=
TimeStamp
(
)
;
NS_DispatchToMainThreadQueue
(
do_AddRef
(
this
)
EventQueuePriority
:
:
Idle
)
;
}
else
{
pfl
-
>
Lock
(
)
;
pfl
-
>
CancelLoadCmapsTask
(
)
;
pfl
-
>
InitializeCodepointsWithNoFonts
(
)
;
dom
:
:
ContentParent
:
:
NotifyUpdatedFonts
(
false
)
;
pfl
-
>
Unlock
(
)
;
}
return
NS_OK
;
}
private
:
uint32_t
mGeneration
;
uint32_t
mStartIndex
;
uint32_t
mIndex
;
TimeStamp
mDeadline
;
bool
mIsCanceled
=
false
;
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
LoadCmapsRunnable
IdleRunnable
nsIObserver
nsISupportsWeakReference
)
;
NS_IMETHODIMP
LoadCmapsRunnable
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
MOZ_ASSERT
(
!
nsCRT
:
:
strcmp
(
aTopic
NS_XPCOM_WILL_SHUTDOWN_OBSERVER_ID
)
"
unexpected
topic
"
)
;
Cancel
(
)
;
return
NS_OK
;
}
void
gfxPlatformFontList
:
:
CancelLoadCmapsTask
(
)
{
if
(
mLoadCmapsRunnable
)
{
mLoadCmapsRunnable
-
>
Cancel
(
)
;
mLoadCmapsRunnable
=
nullptr
;
}
}
void
gfxPlatformFontList
:
:
StartCmapLoading
(
uint32_t
aGeneration
uint32_t
aStartIndex
)
{
MOZ_RELEASE_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
aGeneration
!
=
SharedFontList
(
)
-
>
GetGeneration
(
)
)
{
return
;
}
if
(
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
AppShutdownConfirmed
)
)
{
return
;
}
if
(
mLoadCmapsRunnable
)
{
mLoadCmapsRunnable
-
>
MaybeResetIndex
(
aStartIndex
)
;
return
;
}
mLoadCmapsRunnable
=
new
LoadCmapsRunnable
(
aGeneration
aStartIndex
)
;
if
(
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
)
{
obs
-
>
AddObserver
(
mLoadCmapsRunnable
NS_XPCOM_WILL_SHUTDOWN_OBSERVER_ID
true
)
;
}
NS_DispatchToMainThreadQueue
(
do_AddRef
(
mLoadCmapsRunnable
)
EventQueuePriority
:
:
Idle
)
;
}
gfxFontFamily
*
gfxPlatformFontList
:
:
CheckFamily
(
gfxFontFamily
*
aFamily
)
{
if
(
aFamily
&
&
!
aFamily
-
>
HasStyles
(
)
)
{
aFamily
-
>
FindStyleVariations
(
)
;
}
if
(
aFamily
&
&
aFamily
-
>
FontListLength
(
)
=
=
0
)
{
nsAutoCString
key
;
GenerateFontListKey
(
aFamily
-
>
Name
(
)
key
)
;
mFontFamilies
.
Remove
(
key
)
;
return
nullptr
;
}
return
aFamily
;
}
bool
gfxPlatformFontList
:
:
FindAndAddFamilies
(
FontVisibilityProvider
*
aFontVisibilityProvider
StyleGenericFontFamily
aGeneric
const
nsACString
&
aFamily
nsTArray
<
FamilyAndGeneric
>
*
aOutput
FindFamiliesFlags
aFlags
gfxFontStyle
*
aStyle
nsAtom
*
aLanguage
gfxFloat
aDevToCssSize
)
{
AutoLock
lock
(
mLock
)
;
#
ifdef
DEBUG
auto
initialLength
=
aOutput
-
>
Length
(
)
;
#
endif
bool
didFind
=
FindAndAddFamiliesLocked
(
aFontVisibilityProvider
aGeneric
aFamily
aOutput
aFlags
aStyle
aLanguage
aDevToCssSize
)
;
#
ifdef
DEBUG
auto
finalLength
=
aOutput
-
>
Length
(
)
;
MOZ_ASSERT_IF
(
didFind
finalLength
>
initialLength
)
;
MOZ_ASSERT_IF
(
!
didFind
finalLength
=
=
initialLength
)
;
#
endif
return
didFind
;
}
bool
gfxPlatformFontList
:
:
FindAndAddFamiliesLocked
(
FontVisibilityProvider
*
aFontVisibilityProvider
StyleGenericFontFamily
aGeneric
const
nsACString
&
aFamily
nsTArray
<
FamilyAndGeneric
>
*
aOutput
FindFamiliesFlags
aFlags
gfxFontStyle
*
aStyle
nsAtom
*
aLanguage
gfxFloat
aDevToCssSize
)
{
nsAutoCString
key
;
GenerateFontListKey
(
aFamily
key
)
;
bool
allowHidden
=
bool
(
aFlags
&
FindFamiliesFlags
:
:
eSearchHiddenFamilies
)
;
FontVisibility
visibilityLevel
=
aFontVisibilityProvider
?
aFontVisibilityProvider
-
>
GetFontVisibility
(
)
:
FontVisibility
:
:
User
;
if
(
visibilityLevel
<
FontVisibility
:
:
User
&
&
aGeneric
!
=
StyleGenericFontFamily
:
:
None
&
&
!
aFontVisibilityProvider
-
>
ShouldResistFingerprinting
(
RFPTarget
:
:
FontVisibilityRestrictGenerics
)
)
{
visibilityLevel
=
FontVisibility
:
:
User
;
}
if
(
SharedFontList
(
)
)
{
fontlist
:
:
Family
*
family
=
SharedFontList
(
)
-
>
FindFamily
(
key
)
;
if
(
!
family
&
&
!
mOtherFamilyNamesInitialized
)
{
bool
triggerLoading
=
true
;
bool
mayDefer
=
!
(
aFlags
&
FindFamiliesFlags
:
:
eForceOtherFamilyNamesLoading
)
;
if
(
IsAscii
(
key
)
)
{
const
char
*
data
=
key
.
BeginReading
(
)
;
int32_t
index
=
key
.
Length
(
)
;
while
(
-
-
index
>
0
)
{
if
(
data
[
index
]
=
=
'
'
)
{
break
;
}
}
if
(
index
<
=
0
|
|
!
SharedFontList
(
)
-
>
FindFamily
(
nsAutoCString
(
key
.
get
(
)
index
)
)
)
{
triggerLoading
=
false
;
}
}
if
(
triggerLoading
)
{
if
(
InitOtherFamilyNames
(
mayDefer
)
)
{
family
=
SharedFontList
(
)
-
>
FindFamily
(
key
)
;
}
}
if
(
!
family
&
&
!
mOtherFamilyNamesInitialized
&
&
!
(
aFlags
&
FindFamiliesFlags
:
:
eNoAddToNamesMissedWhenSearching
)
)
{
AddToMissedNames
(
key
)
;
}
}
if
(
family
)
{
bool
visible
=
IsVisibleToCSS
(
*
family
visibilityLevel
)
;
if
(
visible
|
|
(
allowHidden
&
&
family
-
>
IsHidden
(
)
)
)
{
aOutput
-
>
AppendElement
(
FamilyAndGeneric
(
family
aGeneric
)
)
;
return
true
;
}
if
(
aFontVisibilityProvider
)
{
aFontVisibilityProvider
-
>
ReportBlockedFontFamily
(
*
family
)
;
}
}
return
false
;
}
NS_ASSERTION
(
mFontFamilies
.
Count
(
)
!
=
0
"
system
font
list
was
not
initialized
correctly
"
)
;
auto
isBlockedByVisibilityLevel
=
[
=
]
(
gfxFontFamily
*
aFamily
)
-
>
bool
{
bool
visible
=
IsVisibleToCSS
(
*
aFamily
visibilityLevel
)
;
if
(
visible
|
|
(
allowHidden
&
&
aFamily
-
>
IsHidden
(
)
)
)
{
return
false
;
}
if
(
aFontVisibilityProvider
)
{
aFontVisibilityProvider
-
>
ReportBlockedFontFamily
(
*
aFamily
)
;
}
return
true
;
}
;
gfxFontFamily
*
familyEntry
=
mFontFamilies
.
GetWeak
(
key
)
;
if
(
familyEntry
)
{
if
(
isBlockedByVisibilityLevel
(
familyEntry
)
)
{
return
false
;
}
}
if
(
!
familyEntry
)
{
familyEntry
=
mOtherFamilyNames
.
GetWeak
(
key
)
;
}
if
(
familyEntry
)
{
if
(
isBlockedByVisibilityLevel
(
familyEntry
)
)
{
return
false
;
}
}
if
(
!
familyEntry
&
&
!
mOtherFamilyNamesInitialized
&
&
!
IsAscii
(
aFamily
)
)
{
InitOtherFamilyNames
(
!
(
aFlags
&
FindFamiliesFlags
:
:
eForceOtherFamilyNamesLoading
)
)
;
familyEntry
=
mOtherFamilyNames
.
GetWeak
(
key
)
;
if
(
!
familyEntry
&
&
!
mOtherFamilyNamesInitialized
&
&
!
(
aFlags
&
FindFamiliesFlags
:
:
eNoAddToNamesMissedWhenSearching
)
)
{
AddToMissedNames
(
key
)
;
}
if
(
familyEntry
)
{
if
(
isBlockedByVisibilityLevel
(
familyEntry
)
)
{
return
false
;
}
}
}
familyEntry
=
CheckFamily
(
familyEntry
)
;
if
(
!
familyEntry
&
&
!
(
aFlags
&
FindFamiliesFlags
:
:
eNoSearchForLegacyFamilyNames
)
)
{
const
char
*
data
=
aFamily
.
BeginReading
(
)
;
int32_t
index
=
aFamily
.
Length
(
)
;
while
(
-
-
index
>
0
)
{
if
(
data
[
index
]
=
=
'
'
)
{
break
;
}
}
if
(
index
>
0
)
{
gfxFontFamily
*
base
=
FindUnsharedFamily
(
aFontVisibilityProvider
Substring
(
aFamily
0
index
)
FindFamiliesFlags
:
:
eNoSearchForLegacyFamilyNames
)
;
if
(
base
&
&
base
-
>
CheckForLegacyFamilyNames
(
this
)
)
{
familyEntry
=
mOtherFamilyNames
.
GetWeak
(
key
)
;
}
if
(
familyEntry
)
{
if
(
isBlockedByVisibilityLevel
(
familyEntry
)
)
{
return
false
;
}
}
}
}
if
(
familyEntry
)
{
aOutput
-
>
AppendElement
(
FamilyAndGeneric
(
familyEntry
aGeneric
)
)
;
return
true
;
}
return
false
;
}
void
gfxPlatformFontList
:
:
AddToMissedNames
(
const
nsCString
&
aKey
)
{
if
(
!
mOtherNamesMissed
)
{
mOtherNamesMissed
=
MakeUnique
<
nsTHashSet
<
nsCString
>
>
(
2
)
;
}
mOtherNamesMissed
-
>
Insert
(
aKey
)
;
}
fontlist
:
:
Family
*
gfxPlatformFontList
:
:
FindSharedFamily
(
FontVisibilityProvider
*
aFontVisibilityProvider
const
nsACString
&
aFamily
FindFamiliesFlags
aFlags
gfxFontStyle
*
aStyle
nsAtom
*
aLanguage
gfxFloat
aDevToCss
)
{
if
(
!
SharedFontList
(
)
)
{
return
nullptr
;
}
AutoTArray
<
FamilyAndGeneric
1
>
families
;
if
(
!
FindAndAddFamiliesLocked
(
aFontVisibilityProvider
StyleGenericFontFamily
:
:
None
aFamily
&
families
aFlags
aStyle
aLanguage
aDevToCss
)
|
|
!
families
[
0
]
.
mFamily
.
mShared
)
{
return
nullptr
;
}
fontlist
:
:
Family
*
family
=
families
[
0
]
.
mFamily
.
mShared
;
if
(
!
family
-
>
IsInitialized
(
)
)
{
if
(
!
InitializeFamily
(
family
)
)
{
return
nullptr
;
}
}
return
family
;
}
class
InitializeFamilyRunnable
:
public
mozilla
:
:
Runnable
{
public
:
explicit
InitializeFamilyRunnable
(
uint32_t
aFamilyIndex
bool
aLoadCmaps
)
:
Runnable
(
"
gfxPlatformFontList
:
:
InitializeFamilyRunnable
"
)
mIndex
(
aFamilyIndex
)
mLoadCmaps
(
aLoadCmaps
)
{
}
NS_IMETHOD
Run
(
)
override
{
auto
list
=
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
SharedFontList
(
)
;
if
(
!
list
)
{
return
NS_OK
;
}
if
(
mIndex
>
=
list
-
>
NumFamilies
(
)
)
{
return
NS_OK
;
}
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendInitializeFamily
(
list
-
>
GetGeneration
(
)
mIndex
mLoadCmaps
)
;
return
NS_OK
;
}
private
:
uint32_t
mIndex
;
bool
mLoadCmaps
;
}
;
bool
gfxPlatformFontList
:
:
InitializeFamily
(
fontlist
:
:
Family
*
aFamily
bool
aLoadCmaps
)
{
MOZ_ASSERT
(
SharedFontList
(
)
)
;
auto
list
=
SharedFontList
(
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
auto
*
families
=
list
-
>
Families
(
)
;
if
(
!
families
)
{
return
false
;
}
uint32_t
index
=
aFamily
-
families
;
if
(
index
>
=
list
-
>
NumFamilies
(
)
)
{
return
false
;
}
if
(
NS_IsMainThread
(
)
)
{
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendInitializeFamily
(
list
-
>
GetGeneration
(
)
index
aLoadCmaps
)
;
}
else
{
NS_DispatchToMainThread
(
new
InitializeFamilyRunnable
(
index
aLoadCmaps
)
)
;
}
return
aFamily
-
>
IsInitialized
(
)
;
}
if
(
!
aFamily
-
>
IsInitialized
(
)
)
{
AutoTArray
<
fontlist
:
:
Face
:
:
InitData
16
>
faceList
;
GetFacesInitDataForFamily
(
aFamily
faceList
aLoadCmaps
)
;
aFamily
-
>
AddFaces
(
list
faceList
)
;
}
else
{
if
(
aLoadCmaps
)
{
auto
*
faces
=
aFamily
-
>
Faces
(
list
)
;
if
(
faces
)
{
for
(
size_t
i
=
0
;
i
<
aFamily
-
>
NumFaces
(
)
;
i
+
+
)
{
auto
*
face
=
faces
[
i
]
.
ToPtr
<
fontlist
:
:
Face
>
(
list
)
;
if
(
face
&
&
face
-
>
mCharacterMap
.
IsNull
(
)
)
{
RefPtr
<
gfxFontEntry
>
fe
=
CreateFontEntry
(
face
aFamily
)
;
if
(
fe
)
{
fe
-
>
ReadCMAP
(
)
;
}
}
}
}
}
}
if
(
aLoadCmaps
&
&
aFamily
-
>
IsInitialized
(
)
)
{
aFamily
-
>
SetupFamilyCharMap
(
list
)
;
}
return
aFamily
-
>
IsInitialized
(
)
;
}
gfxFontEntry
*
gfxPlatformFontList
:
:
FindFontForFamily
(
FontVisibilityProvider
*
aFontVisibilityProvider
const
nsACString
&
aFamily
const
gfxFontStyle
*
aStyle
)
{
AutoLock
lock
(
mLock
)
;
nsAutoCString
key
;
GenerateFontListKey
(
aFamily
key
)
;
FontFamily
family
=
FindFamily
(
aFontVisibilityProvider
key
)
;
if
(
family
.
IsNull
(
)
)
{
return
nullptr
;
}
if
(
family
.
mShared
)
{
auto
face
=
family
.
mShared
-
>
FindFaceForStyle
(
SharedFontList
(
)
*
aStyle
)
;
if
(
!
face
)
{
return
nullptr
;
}
return
GetOrCreateFontEntryLocked
(
face
family
.
mShared
)
;
}
return
family
.
mUnshared
-
>
FindFontForStyle
(
*
aStyle
)
;
}
gfxFontEntry
*
gfxPlatformFontList
:
:
GetOrCreateFontEntryLocked
(
fontlist
:
:
Face
*
aFace
const
fontlist
:
:
Family
*
aFamily
)
{
return
mFontEntries
.
LookupOrInsertWith
(
aFace
[
=
]
{
return
CreateFontEntry
(
aFace
aFamily
)
;
}
)
.
get
(
)
;
}
void
gfxPlatformFontList
:
:
AddOtherFamilyNames
(
gfxFontFamily
*
aFamilyEntry
const
nsTArray
<
nsCString
>
&
aOtherFamilyNames
)
{
AutoLock
lock
(
mLock
)
;
for
(
const
auto
&
name
:
aOtherFamilyNames
)
{
nsAutoCString
key
;
GenerateFontListKey
(
name
key
)
;
mOtherFamilyNames
.
LookupOrInsertWith
(
key
[
&
]
{
LOG_FONTLIST
(
(
"
(
fontlist
-
otherfamily
)
canonical
family
:
%
s
other
family
:
%
s
\
n
"
aFamilyEntry
-
>
Name
(
)
.
get
(
)
name
.
get
(
)
)
)
;
if
(
mBadUnderlineFamilyNames
.
ContainsSorted
(
key
)
)
{
aFamilyEntry
-
>
SetBadUnderlineFamily
(
)
;
}
return
RefPtr
{
aFamilyEntry
}
;
}
)
;
}
}
void
gfxPlatformFontList
:
:
AddFullnameLocked
(
gfxFontEntry
*
aFontEntry
const
nsCString
&
aFullname
)
{
mExtraNames
-
>
mFullnames
.
LookupOrInsertWith
(
aFullname
[
&
]
{
LOG_FONTLIST
(
(
"
(
fontlist
-
fullname
)
name
:
%
s
fullname
:
%
s
\
n
"
aFontEntry
-
>
Name
(
)
.
get
(
)
aFullname
.
get
(
)
)
)
;
return
RefPtr
{
aFontEntry
}
;
}
)
;
}
void
gfxPlatformFontList
:
:
AddPostscriptNameLocked
(
gfxFontEntry
*
aFontEntry
const
nsCString
&
aPostscriptName
)
{
mExtraNames
-
>
mPostscriptNames
.
LookupOrInsertWith
(
aPostscriptName
[
&
]
{
LOG_FONTLIST
(
(
"
(
fontlist
-
postscript
)
name
:
%
s
psname
:
%
s
\
n
"
aFontEntry
-
>
Name
(
)
.
get
(
)
aPostscriptName
.
get
(
)
)
)
;
return
RefPtr
{
aFontEntry
}
;
}
)
;
}
bool
gfxPlatformFontList
:
:
GetStandardFamilyName
(
const
nsCString
&
aFontName
nsACString
&
aFamilyName
)
{
AutoLock
lock
(
mLock
)
;
FontFamily
family
=
FindFamily
(
nullptr
aFontName
)
;
if
(
family
.
IsNull
(
)
)
{
return
false
;
}
return
GetLocalizedFamilyName
(
family
aFamilyName
)
;
}
bool
gfxPlatformFontList
:
:
GetLocalizedFamilyName
(
const
FontFamily
&
aFamily
nsACString
&
aFamilyName
)
{
if
(
aFamily
.
mShared
)
{
aFamilyName
=
SharedFontList
(
)
-
>
LocalizedFamilyName
(
aFamily
.
mShared
)
;
return
true
;
}
if
(
aFamily
.
mUnshared
)
{
aFamily
.
mUnshared
-
>
LocalizedName
(
aFamilyName
)
;
return
true
;
}
return
false
;
}
FamilyAndGeneric
gfxPlatformFontList
:
:
GetDefaultFontFamily
(
const
nsACString
&
aLangGroup
const
nsACString
&
aGenericFamily
)
{
if
(
NS_WARN_IF
(
aLangGroup
.
IsEmpty
(
)
)
|
|
NS_WARN_IF
(
aGenericFamily
.
IsEmpty
(
)
)
)
{
return
FamilyAndGeneric
(
)
;
}
AutoLock
lock
(
mLock
)
;
nsAutoCString
value
;
AutoTArray
<
nsCString
4
>
names
;
if
(
mFontPrefs
-
>
LookupNameList
(
PrefName
(
aGenericFamily
aLangGroup
)
value
)
)
{
gfxFontUtils
:
:
ParseFontList
(
value
names
)
;
}
for
(
const
nsCString
&
name
:
names
)
{
FontFamily
family
=
FindFamily
(
nullptr
name
)
;
if
(
!
family
.
IsNull
(
)
)
{
return
FamilyAndGeneric
(
family
)
;
}
}
return
FamilyAndGeneric
(
)
;
}
ShmemCharMapHashEntry
:
:
ShmemCharMapHashEntry
(
const
gfxSparseBitSet
*
aCharMap
)
:
mList
(
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
SharedFontList
(
)
)
mHash
(
aCharMap
-
>
GetChecksum
(
)
)
{
size_t
len
=
SharedBitSet
:
:
RequiredSize
(
*
aCharMap
)
;
mCharMap
=
mList
-
>
Alloc
(
len
)
;
SharedBitSet
:
:
Create
(
mCharMap
.
ToPtr
(
mList
len
)
len
*
aCharMap
)
;
}
fontlist
:
:
Pointer
gfxPlatformFontList
:
:
GetShmemCharMapLocked
(
const
gfxSparseBitSet
*
aCmap
)
{
auto
*
entry
=
mShmemCharMaps
.
GetEntry
(
aCmap
)
;
if
(
!
entry
)
{
entry
=
mShmemCharMaps
.
PutEntry
(
aCmap
)
;
}
return
entry
-
>
GetCharMap
(
)
;
}
already_AddRefed
<
gfxCharacterMap
>
gfxPlatformFontList
:
:
FindCharMap
(
gfxCharacterMap
*
aCmap
)
{
AutoLock
lock
(
mLock
)
;
aCmap
-
>
CalcHash
(
)
;
aCmap
-
>
mShared
=
true
;
RefPtr
cmap
=
mSharedCmaps
.
PutEntry
(
aCmap
)
-
>
GetKey
(
)
;
if
(
cmap
.
get
(
)
!
=
aCmap
)
{
aCmap
-
>
mShared
=
false
;
}
return
cmap
.
forget
(
)
;
}
void
gfxPlatformFontList
:
:
MaybeRemoveCmap
(
gfxCharacterMap
*
aCharMap
)
{
AutoLock
lock
(
mLock
)
;
if
(
!
mSharedCmaps
.
Count
(
)
)
{
return
;
}
CharMapHashKey
*
found
=
mSharedCmaps
.
GetEntry
(
const_cast
<
gfxCharacterMap
*
>
(
aCharMap
)
)
;
if
(
found
&
&
found
-
>
GetKey
(
)
=
=
aCharMap
&
&
aCharMap
-
>
RefCount
(
)
=
=
1
)
{
Unused
<
<
found
-
>
mCharMap
.
forget
(
)
;
delete
aCharMap
;
NS_LOG_RELEASE
(
aCharMap
0
"
gfxCharacterMap
"
)
;
mSharedCmaps
.
RemoveEntry
(
found
)
;
}
}
static
void
GetSystemUIFontFamilies
(
FontVisibilityProvider
*
aFontVisibilityProvider
[
[
maybe_unused
]
]
nsAtom
*
aLangGroup
nsTArray
<
nsCString
>
&
aFamilies
)
{
nsFont
systemFont
;
gfxFontStyle
fontStyle
;
nsAutoString
systemFontName
;
if
(
aFontVisibilityProvider
?
aFontVisibilityProvider
-
>
ShouldResistFingerprinting
(
RFPTarget
:
:
FontVisibilityRestrictGenerics
)
:
nsContentUtils
:
:
ShouldResistFingerprinting
(
"
aFontVisibilityProvider
not
available
"
RFPTarget
:
:
FontVisibilityRestrictGenerics
)
)
{
#
if
defined
(
XP_MACOSX
)
|
|
defined
(
MOZ_WIDGET_UIKIT
)
*
aFamilies
.
AppendElement
(
)
=
"
-
apple
-
system
"
_ns
;
return
;
#
elif
!
defined
(
MOZ_WIDGET_ANDROID
)
*
aFamilies
.
AppendElement
(
)
=
"
sans
-
serif
"
_ns
;
return
;
#
endif
}
if
(
!
LookAndFeel
:
:
GetFont
(
StyleSystemFont
:
:
Menu
systemFontName
fontStyle
)
)
{
return
;
}
systemFontName
.
Trim
(
"
\
"
'
"
)
;
CopyUTF16toUTF8
(
systemFontName
*
aFamilies
.
AppendElement
(
)
)
;
}
void
gfxPlatformFontList
:
:
ResolveGenericFontNames
(
FontVisibilityProvider
*
aFontVisibilityProvider
StyleGenericFontFamily
aGenericType
eFontPrefLang
aPrefLang
PrefFontList
*
aGenericFamilies
)
{
const
char
*
langGroupStr
=
GetPrefLangName
(
aPrefLang
)
;
const
char
*
generic
=
GetGenericName
(
aGenericType
)
;
if
(
!
generic
)
{
return
;
}
AutoTArray
<
nsCString
4
>
genericFamilies
;
PrefName
prefName
(
generic
langGroupStr
)
;
nsAutoCString
value
;
if
(
mFontPrefs
-
>
LookupName
(
prefName
value
)
)
{
gfxFontUtils
:
:
ParseFontList
(
value
genericFamilies
)
;
}
if
(
mFontPrefs
-
>
LookupNameList
(
prefName
value
)
)
{
gfxFontUtils
:
:
ParseFontList
(
value
genericFamilies
)
;
}
nsAtom
*
langGroup
=
GetLangGroupForPrefLang
(
aPrefLang
)
;
MOZ_ASSERT
(
langGroup
"
null
lang
group
for
pref
lang
"
)
;
if
(
aGenericType
=
=
StyleGenericFontFamily
:
:
SystemUi
)
{
GetSystemUIFontFamilies
(
aFontVisibilityProvider
langGroup
genericFamilies
)
;
}
GetFontFamiliesFromGenericFamilies
(
aFontVisibilityProvider
aGenericType
genericFamilies
langGroup
aGenericFamilies
)
;
#
if
0
printf
(
"
%
s
=
=
=
>
"
NamePref
(
generic
langGroupStr
)
.
get
(
)
)
;
for
(
uint32_t
k
=
0
;
k
<
aGenericFamilies
-
>
Length
(
)
;
k
+
+
)
{
if
(
k
>
0
)
printf
(
"
"
)
;
printf
(
"
%
s
"
(
*
aGenericFamilies
)
[
k
]
.
mIsShared
?
(
*
aGenericFamilies
)
[
k
]
.
mShared
-
>
DisplayName
(
)
.
AsString
(
SharedFontList
(
)
)
.
get
(
)
:
(
*
aGenericFamilies
)
[
k
]
.
mUnshared
-
>
Name
(
)
.
get
(
)
)
;
}
printf
(
"
\
n
"
)
;
#
endif
}
void
gfxPlatformFontList
:
:
ResolveEmojiFontNames
(
FontVisibilityProvider
*
aFontVisibilityProvider
PrefFontList
*
aGenericFamilies
)
{
AutoTArray
<
nsCString
4
>
genericFamilies
;
nsAutoCString
value
;
if
(
mFontPrefs
-
>
LookupNameList
(
PrefName
(
"
emoji
"
"
"
)
value
)
)
{
gfxFontUtils
:
:
ParseFontList
(
value
genericFamilies
)
;
}
GetFontFamiliesFromGenericFamilies
(
aFontVisibilityProvider
StyleGenericFontFamily
:
:
MozEmoji
genericFamilies
nullptr
aGenericFamilies
)
;
}
void
gfxPlatformFontList
:
:
GetFontFamiliesFromGenericFamilies
(
FontVisibilityProvider
*
aFontVisibilityProvider
StyleGenericFontFamily
aGenericType
nsTArray
<
nsCString
>
&
aGenericNameFamilies
nsAtom
*
aLangGroup
PrefFontList
*
aGenericFamilies
)
{
for
(
const
nsCString
&
genericFamily
:
aGenericNameFamilies
)
{
AutoTArray
<
FamilyAndGeneric
10
>
families
;
FindAndAddFamiliesLocked
(
aFontVisibilityProvider
aGenericType
genericFamily
&
families
FindFamiliesFlags
(
0
)
nullptr
aLangGroup
)
;
for
(
const
FamilyAndGeneric
&
f
:
families
)
{
if
(
!
aGenericFamilies
-
>
Contains
(
f
.
mFamily
)
)
{
aGenericFamilies
-
>
AppendElement
(
f
.
mFamily
)
;
}
}
}
}
gfxPlatformFontList
:
:
PrefFontList
*
gfxPlatformFontList
:
:
GetPrefFontsLangGroupLocked
(
FontVisibilityProvider
*
aFontVisibilityProvider
StyleGenericFontFamily
aGenericType
eFontPrefLang
aPrefLang
)
{
if
(
aGenericType
=
=
StyleGenericFontFamily
:
:
MozEmoji
|
|
aPrefLang
=
=
eFontPrefLang_Emoji
)
{
PrefFontList
*
prefFonts
=
mEmojiPrefFont
.
get
(
)
;
if
(
MOZ_UNLIKELY
(
!
prefFonts
)
)
{
prefFonts
=
new
PrefFontList
;
ResolveEmojiFontNames
(
aFontVisibilityProvider
prefFonts
)
;
mEmojiPrefFont
.
reset
(
prefFonts
)
;
}
return
prefFonts
;
}
auto
index
=
static_cast
<
size_t
>
(
aGenericType
)
;
PrefFontList
*
prefFonts
=
mLangGroupPrefFonts
[
aPrefLang
]
[
index
]
.
get
(
)
;
if
(
MOZ_UNLIKELY
(
!
prefFonts
)
)
{
prefFonts
=
new
PrefFontList
;
ResolveGenericFontNames
(
aFontVisibilityProvider
aGenericType
aPrefLang
prefFonts
)
;
mLangGroupPrefFonts
[
aPrefLang
]
[
index
]
.
reset
(
prefFonts
)
;
}
return
prefFonts
;
}
void
gfxPlatformFontList
:
:
AddGenericFonts
(
FontVisibilityProvider
*
aFontVisibilityProvider
StyleGenericFontFamily
aGenericType
nsAtom
*
aLanguage
nsTArray
<
FamilyAndGeneric
>
&
aFamilyList
)
{
AutoLock
lock
(
mLock
)
;
nsAtom
*
langGroup
=
GetLangGroup
(
aLanguage
)
;
eFontPrefLang
prefLang
=
GetFontPrefLangFor
(
langGroup
)
;
PrefFontList
*
prefFonts
=
GetPrefFontsLangGroupLocked
(
aFontVisibilityProvider
aGenericType
prefLang
)
;
if
(
!
prefFonts
-
>
IsEmpty
(
)
)
{
aFamilyList
.
SetCapacity
(
aFamilyList
.
Length
(
)
+
prefFonts
-
>
Length
(
)
)
;
for
(
auto
&
f
:
*
prefFonts
)
{
aFamilyList
.
AppendElement
(
FamilyAndGeneric
(
f
aGenericType
)
)
;
}
}
}
static
nsAtom
*
PrefLangToLangGroups
(
uint32_t
aIndex
)
{
static
nsAtom
*
gPrefLangToLangGroups
[
]
=
{
#
define
FONT_PREF_LANG
(
enum_id_
str_
atom_id_
)
nsGkAtoms
:
:
atom_id_
#
include
"
gfxFontPrefLangList
.
h
"
#
undef
FONT_PREF_LANG
}
;
return
aIndex
<
std
:
:
size
(
gPrefLangToLangGroups
)
?
gPrefLangToLangGroups
[
aIndex
]
:
nsGkAtoms
:
:
Unicode
;
}
eFontPrefLang
gfxPlatformFontList
:
:
GetFontPrefLangFor
(
const
char
*
aLang
)
{
if
(
!
aLang
|
|
!
aLang
[
0
]
)
{
return
eFontPrefLang_Others
;
}
for
(
uint32_t
i
=
0
;
i
<
std
:
:
size
(
gPrefLangNames
)
;
+
+
i
)
{
if
(
!
nsCRT
:
:
strcasecmp
(
gPrefLangNames
[
i
]
aLang
)
)
{
return
eFontPrefLang
(
i
)
;
}
if
(
strlen
(
gPrefLangNames
[
i
]
)
=
=
2
&
&
strlen
(
aLang
)
>
3
&
&
aLang
[
2
]
=
=
'
-
'
&
&
!
nsCRT
:
:
strncasecmp
(
gPrefLangNames
[
i
]
aLang
2
)
)
{
return
eFontPrefLang
(
i
)
;
}
}
return
eFontPrefLang_Others
;
}
eFontPrefLang
gfxPlatformFontList
:
:
GetFontPrefLangFor
(
nsAtom
*
aLang
)
{
if
(
!
aLang
)
return
eFontPrefLang_Others
;
nsAutoCString
lang
;
aLang
-
>
ToUTF8String
(
lang
)
;
return
GetFontPrefLangFor
(
lang
.
get
(
)
)
;
}
nsAtom
*
gfxPlatformFontList
:
:
GetLangGroupForPrefLang
(
eFontPrefLang
aLang
)
{
NS_ASSERTION
(
aLang
!
=
eFontPrefLang_CJKSet
"
unresolved
CJK
set
pref
lang
"
)
;
return
PrefLangToLangGroups
(
uint32_t
(
aLang
)
)
;
}
const
char
*
gfxPlatformFontList
:
:
GetPrefLangName
(
eFontPrefLang
aLang
)
{
if
(
uint32_t
(
aLang
)
<
std
:
:
size
(
gPrefLangNames
)
)
{
return
gPrefLangNames
[
uint32_t
(
aLang
)
]
;
}
return
nullptr
;
}
eFontPrefLang
gfxPlatformFontList
:
:
GetFontPrefLangFor
(
uint32_t
aCh
)
{
switch
(
ublock_getCode
(
aCh
)
)
{
case
UBLOCK_BASIC_LATIN
:
case
UBLOCK_LATIN_1_SUPPLEMENT
:
case
UBLOCK_LATIN_EXTENDED_A
:
case
UBLOCK_LATIN_EXTENDED_B
:
case
UBLOCK_IPA_EXTENSIONS
:
case
UBLOCK_SPACING_MODIFIER_LETTERS
:
case
UBLOCK_LATIN_EXTENDED_ADDITIONAL
:
case
UBLOCK_LATIN_EXTENDED_C
:
case
UBLOCK_LATIN_EXTENDED_D
:
case
UBLOCK_LATIN_EXTENDED_E
:
case
UBLOCK_PHONETIC_EXTENSIONS
:
return
eFontPrefLang_Western
;
case
UBLOCK_GREEK
:
case
UBLOCK_GREEK_EXTENDED
:
return
eFontPrefLang_Greek
;
case
UBLOCK_CYRILLIC
:
case
UBLOCK_CYRILLIC_SUPPLEMENT
:
case
UBLOCK_CYRILLIC_EXTENDED_A
:
case
UBLOCK_CYRILLIC_EXTENDED_B
:
case
UBLOCK_CYRILLIC_EXTENDED_C
:
return
eFontPrefLang_Cyrillic
;
case
UBLOCK_ARMENIAN
:
return
eFontPrefLang_Armenian
;
case
UBLOCK_HEBREW
:
return
eFontPrefLang_Hebrew
;
case
UBLOCK_ARABIC
:
case
UBLOCK_ARABIC_PRESENTATION_FORMS_A
:
case
UBLOCK_ARABIC_PRESENTATION_FORMS_B
:
case
UBLOCK_ARABIC_SUPPLEMENT
:
case
UBLOCK_ARABIC_EXTENDED_A
:
case
UBLOCK_ARABIC_MATHEMATICAL_ALPHABETIC_SYMBOLS
:
return
eFontPrefLang_Arabic
;
case
UBLOCK_DEVANAGARI
:
case
UBLOCK_DEVANAGARI_EXTENDED
:
return
eFontPrefLang_Devanagari
;
case
UBLOCK_BENGALI
:
return
eFontPrefLang_Bengali
;
case
UBLOCK_GURMUKHI
:
return
eFontPrefLang_Gurmukhi
;
case
UBLOCK_GUJARATI
:
return
eFontPrefLang_Gujarati
;
case
UBLOCK_ORIYA
:
return
eFontPrefLang_Oriya
;
case
UBLOCK_TAMIL
:
return
eFontPrefLang_Tamil
;
case
UBLOCK_TELUGU
:
return
eFontPrefLang_Telugu
;
case
UBLOCK_KANNADA
:
return
eFontPrefLang_Kannada
;
case
UBLOCK_MALAYALAM
:
return
eFontPrefLang_Malayalam
;
case
UBLOCK_SINHALA
:
case
UBLOCK_SINHALA_ARCHAIC_NUMBERS
:
return
eFontPrefLang_Sinhala
;
case
UBLOCK_THAI
:
return
eFontPrefLang_Thai
;
case
UBLOCK_TIBETAN
:
return
eFontPrefLang_Tibetan
;
case
UBLOCK_GEORGIAN
:
case
UBLOCK_GEORGIAN_SUPPLEMENT
:
case
UBLOCK_GEORGIAN_EXTENDED
:
return
eFontPrefLang_Georgian
;
case
UBLOCK_HANGUL_JAMO
:
case
UBLOCK_HANGUL_COMPATIBILITY_JAMO
:
case
UBLOCK_HANGUL_SYLLABLES
:
case
UBLOCK_HANGUL_JAMO_EXTENDED_A
:
case
UBLOCK_HANGUL_JAMO_EXTENDED_B
:
return
eFontPrefLang_Korean
;
case
UBLOCK_ETHIOPIC
:
case
UBLOCK_ETHIOPIC_EXTENDED
:
case
UBLOCK_ETHIOPIC_SUPPLEMENT
:
case
UBLOCK_ETHIOPIC_EXTENDED_A
:
return
eFontPrefLang_Ethiopic
;
case
UBLOCK_UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS
:
case
UBLOCK_UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_EXTENDED
:
return
eFontPrefLang_Canadian
;
case
UBLOCK_KHMER
:
case
UBLOCK_KHMER_SYMBOLS
:
return
eFontPrefLang_Khmer
;
case
UBLOCK_CJK_RADICALS_SUPPLEMENT
:
case
UBLOCK_KANGXI_RADICALS
:
case
UBLOCK_IDEOGRAPHIC_DESCRIPTION_CHARACTERS
:
case
UBLOCK_CJK_SYMBOLS_AND_PUNCTUATION
:
case
UBLOCK_HIRAGANA
:
case
UBLOCK_KATAKANA
:
case
UBLOCK_BOPOMOFO
:
case
UBLOCK_KANBUN
:
case
UBLOCK_BOPOMOFO_EXTENDED
:
case
UBLOCK_ENCLOSED_CJK_LETTERS_AND_MONTHS
:
case
UBLOCK_CJK_COMPATIBILITY
:
case
UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A
:
case
UBLOCK_CJK_UNIFIED_IDEOGRAPHS
:
case
UBLOCK_CJK_COMPATIBILITY_IDEOGRAPHS
:
case
UBLOCK_CJK_COMPATIBILITY_FORMS
:
case
UBLOCK_SMALL_FORM_VARIANTS
:
case
UBLOCK_HALFWIDTH_AND_FULLWIDTH_FORMS
:
case
UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B
:
case
UBLOCK_CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT
:
case
UBLOCK_KATAKANA_PHONETIC_EXTENSIONS
:
case
UBLOCK_CJK_STROKES
:
case
UBLOCK_VERTICAL_FORMS
:
case
UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C
:
case
UBLOCK_KANA_SUPPLEMENT
:
case
UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D
:
case
UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_E
:
case
UBLOCK_IDEOGRAPHIC_SYMBOLS_AND_PUNCTUATION
:
case
UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_F
:
case
UBLOCK_KANA_EXTENDED_A
:
return
eFontPrefLang_CJKSet
;
case
UBLOCK_MATHEMATICAL_OPERATORS
:
case
UBLOCK_MATHEMATICAL_ALPHANUMERIC_SYMBOLS
:
case
UBLOCK_MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A
:
case
UBLOCK_MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B
:
case
UBLOCK_SUPPLEMENTAL_MATHEMATICAL_OPERATORS
:
return
eFontPrefLang_Mathematics
;
default
:
return
eFontPrefLang_Others
;
}
}
bool
gfxPlatformFontList
:
:
IsLangCJK
(
eFontPrefLang
aLang
)
{
switch
(
aLang
)
{
case
eFontPrefLang_Japanese
:
case
eFontPrefLang_ChineseTW
:
case
eFontPrefLang_ChineseCN
:
case
eFontPrefLang_ChineseHK
:
case
eFontPrefLang_Korean
:
case
eFontPrefLang_CJKSet
:
return
true
;
default
:
return
false
;
}
}
void
gfxPlatformFontList
:
:
GetLangPrefs
(
eFontPrefLang
aPrefLangs
[
]
uint32_t
&
aLen
eFontPrefLang
aCharLang
eFontPrefLang
aPageLang
)
{
AutoLock
lock
(
mLock
)
;
if
(
IsLangCJK
(
aCharLang
)
)
{
AppendCJKPrefLangs
(
aPrefLangs
aLen
aCharLang
aPageLang
)
;
}
else
{
AppendPrefLang
(
aPrefLangs
aLen
aCharLang
)
;
}
AppendPrefLang
(
aPrefLangs
aLen
eFontPrefLang_Others
)
;
}
void
gfxPlatformFontList
:
:
AppendCJKPrefLangs
(
eFontPrefLang
aPrefLangs
[
]
uint32_t
&
aLen
eFontPrefLang
aCharLang
eFontPrefLang
aPageLang
)
{
if
(
IsLangCJK
(
aPageLang
)
)
{
AppendPrefLang
(
aPrefLangs
aLen
aPageLang
)
;
}
if
(
mCJKPrefLangs
.
Length
(
)
=
=
0
)
{
eFontPrefLang
tempPrefLangs
[
kMaxLenPrefLangList
]
;
uint32_t
tempLen
=
0
;
AutoTArray
<
nsCString
5
>
list
;
gfxFontUtils
:
:
GetPrefsFontList
(
"
intl
.
accept_languages
"
list
true
)
;
for
(
const
auto
&
lang
:
list
)
{
eFontPrefLang
fpl
=
GetFontPrefLangFor
(
lang
.
get
(
)
)
;
switch
(
fpl
)
{
case
eFontPrefLang_Japanese
:
case
eFontPrefLang_Korean
:
case
eFontPrefLang_ChineseCN
:
case
eFontPrefLang_ChineseHK
:
case
eFontPrefLang_ChineseTW
:
AppendPrefLang
(
tempPrefLangs
tempLen
fpl
)
;
break
;
default
:
break
;
}
}
nsAutoCString
localeStr
;
LocaleService
:
:
GetInstance
(
)
-
>
GetAppLocaleAsBCP47
(
localeStr
)
;
{
Locale
locale
;
if
(
LocaleParser
:
:
TryParse
(
localeStr
locale
)
.
isOk
(
)
&
&
locale
.
Canonicalize
(
)
.
isOk
(
)
)
{
if
(
locale
.
Language
(
)
.
EqualTo
(
"
ja
"
)
)
{
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_Japanese
)
;
}
else
if
(
locale
.
Language
(
)
.
EqualTo
(
"
zh
"
)
)
{
if
(
locale
.
Region
(
)
.
EqualTo
(
"
CN
"
)
)
{
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_ChineseCN
)
;
}
else
if
(
locale
.
Region
(
)
.
EqualTo
(
"
TW
"
)
)
{
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_ChineseTW
)
;
}
else
if
(
locale
.
Region
(
)
.
EqualTo
(
"
HK
"
)
)
{
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_ChineseHK
)
;
}
}
else
if
(
locale
.
Language
(
)
.
EqualTo
(
"
ko
"
)
)
{
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_Korean
)
;
}
}
}
AutoTArray
<
nsCString
5
>
prefLocales
;
prefLocales
.
AppendElement
(
"
ja
"
_ns
)
;
prefLocales
.
AppendElement
(
"
zh
-
CN
"
_ns
)
;
prefLocales
.
AppendElement
(
"
zh
-
TW
"
_ns
)
;
prefLocales
.
AppendElement
(
"
zh
-
HK
"
_ns
)
;
prefLocales
.
AppendElement
(
"
ko
"
_ns
)
;
AutoTArray
<
nsCString
16
>
sysLocales
;
AutoTArray
<
nsCString
16
>
negLocales
;
if
(
NS_SUCCEEDED
(
OSPreferences
:
:
GetInstance
(
)
-
>
GetSystemLocales
(
sysLocales
)
)
)
{
LocaleService
:
:
GetInstance
(
)
-
>
NegotiateLanguages
(
sysLocales
prefLocales
"
"
_ns
LocaleService
:
:
kLangNegStrategyFiltering
negLocales
)
;
for
(
const
auto
&
localeStr
:
negLocales
)
{
Locale
locale
;
if
(
LocaleParser
:
:
TryParse
(
localeStr
locale
)
.
isOk
(
)
&
&
locale
.
Canonicalize
(
)
.
isOk
(
)
)
{
if
(
locale
.
Language
(
)
.
EqualTo
(
"
ja
"
)
)
{
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_Japanese
)
;
}
else
if
(
locale
.
Language
(
)
.
EqualTo
(
"
zh
"
)
)
{
if
(
locale
.
Region
(
)
.
EqualTo
(
"
CN
"
)
)
{
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_ChineseCN
)
;
}
else
if
(
locale
.
Region
(
)
.
EqualTo
(
"
TW
"
)
)
{
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_ChineseTW
)
;
}
else
if
(
locale
.
Region
(
)
.
EqualTo
(
"
HK
"
)
)
{
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_ChineseHK
)
;
}
}
else
if
(
locale
.
Language
(
)
.
EqualTo
(
"
ko
"
)
)
{
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_Korean
)
;
}
}
}
}
gfxFontUtils
:
:
GetPrefsFontList
(
kCJKFallbackOrderPref
list
)
;
for
(
const
auto
&
item
:
list
)
{
eFontPrefLang
fpl
=
GetFontPrefLangFor
(
item
.
get
(
)
)
;
switch
(
fpl
)
{
case
eFontPrefLang_Japanese
:
case
eFontPrefLang_Korean
:
case
eFontPrefLang_ChineseCN
:
case
eFontPrefLang_ChineseHK
:
case
eFontPrefLang_ChineseTW
:
AppendPrefLang
(
tempPrefLangs
tempLen
fpl
)
;
break
;
default
:
break
;
}
}
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_ChineseCN
)
;
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_ChineseHK
)
;
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_ChineseTW
)
;
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_Japanese
)
;
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_Korean
)
;
for
(
const
auto
lang
:
Span
<
eFontPrefLang
>
(
tempPrefLangs
tempLen
)
)
{
mCJKPrefLangs
.
AppendElement
(
lang
)
;
}
}
for
(
const
auto
lang
:
mCJKPrefLangs
)
{
AppendPrefLang
(
aPrefLangs
aLen
eFontPrefLang
(
lang
)
)
;
}
}
void
gfxPlatformFontList
:
:
AppendPrefLang
(
eFontPrefLang
aPrefLangs
[
]
uint32_t
&
aLen
eFontPrefLang
aAddLang
)
{
if
(
aLen
>
=
kMaxLenPrefLangList
)
{
return
;
}
for
(
const
auto
lang
:
Span
<
eFontPrefLang
>
(
aPrefLangs
aLen
)
)
{
if
(
lang
=
=
aAddLang
)
{
return
;
}
}
aPrefLangs
[
aLen
+
+
]
=
aAddLang
;
}
StyleGenericFontFamily
gfxPlatformFontList
:
:
GetDefaultGeneric
(
eFontPrefLang
aLang
)
{
if
(
aLang
=
=
eFontPrefLang_Emoji
)
{
return
StyleGenericFontFamily
:
:
MozEmoji
;
}
AutoLock
lock
(
mLock
)
;
if
(
uint32_t
(
aLang
)
<
std
:
:
size
(
gPrefLangNames
)
)
{
return
mDefaultGenericsLangGroup
[
uint32_t
(
aLang
)
]
;
}
return
StyleGenericFontFamily
:
:
Serif
;
}
FontFamily
gfxPlatformFontList
:
:
GetDefaultFont
(
FontVisibilityProvider
*
aFontVisibilityProvider
const
gfxFontStyle
*
aStyle
)
{
AutoLock
lock
(
mLock
)
;
return
GetDefaultFontLocked
(
aFontVisibilityProvider
aStyle
)
;
}
FontFamily
gfxPlatformFontList
:
:
GetDefaultFontLocked
(
FontVisibilityProvider
*
aFontVisibilityProvider
const
gfxFontStyle
*
aStyle
)
{
FontFamily
family
=
GetDefaultFontForPlatform
(
aFontVisibilityProvider
aStyle
)
;
if
(
!
family
.
IsNull
(
)
)
{
return
family
;
}
if
(
SharedFontList
(
)
)
{
MOZ_RELEASE_ASSERT
(
SharedFontList
(
)
-
>
NumFamilies
(
)
>
0
)
;
return
FontFamily
(
SharedFontList
(
)
-
>
Families
(
)
)
;
}
MOZ_RELEASE_ASSERT
(
mFontFamilies
.
Count
(
)
>
0
)
;
return
FontFamily
(
mFontFamilies
.
ConstIter
(
)
.
Data
(
)
)
;
}
void
gfxPlatformFontList
:
:
GetFontFamilyNames
(
nsTArray
<
nsCString
>
&
aFontFamilyNames
)
{
if
(
SharedFontList
(
)
)
{
fontlist
:
:
FontList
*
list
=
SharedFontList
(
)
;
const
fontlist
:
:
Family
*
families
=
list
-
>
Families
(
)
;
if
(
families
)
{
for
(
uint32_t
i
=
0
n
=
list
-
>
NumFamilies
(
)
;
i
<
n
;
i
+
+
)
{
const
fontlist
:
:
Family
&
family
=
families
[
i
]
;
if
(
!
family
.
IsHidden
(
)
)
{
aFontFamilyNames
.
AppendElement
(
family
.
DisplayName
(
)
.
AsString
(
list
)
)
;
}
}
}
}
else
{
for
(
const
RefPtr
<
gfxFontFamily
>
&
family
:
mFontFamilies
.
Values
(
)
)
{
if
(
!
family
-
>
IsHidden
(
)
)
{
aFontFamilyNames
.
AppendElement
(
family
-
>
Name
(
)
)
;
}
}
}
}
nsAtom
*
gfxPlatformFontList
:
:
GetLangGroup
(
nsAtom
*
aLanguage
)
{
nsAtom
*
langGroup
=
nullptr
;
if
(
aLanguage
)
{
langGroup
=
mLangService
-
>
GetLanguageGroup
(
aLanguage
)
;
}
if
(
!
langGroup
)
{
langGroup
=
nsGkAtoms
:
:
Unicode
;
}
return
langGroup
;
}
const
char
*
gfxPlatformFontList
:
:
GetGenericName
(
StyleGenericFontFamily
aGenericType
)
{
switch
(
aGenericType
)
{
case
StyleGenericFontFamily
:
:
Serif
:
return
"
serif
"
;
case
StyleGenericFontFamily
:
:
SansSerif
:
return
"
sans
-
serif
"
;
case
StyleGenericFontFamily
:
:
Monospace
:
return
"
monospace
"
;
case
StyleGenericFontFamily
:
:
Cursive
:
return
"
cursive
"
;
case
StyleGenericFontFamily
:
:
Fantasy
:
return
"
fantasy
"
;
case
StyleGenericFontFamily
:
:
SystemUi
:
return
"
system
-
ui
"
;
case
StyleGenericFontFamily
:
:
MozEmoji
:
return
"
-
moz
-
emoji
"
;
case
StyleGenericFontFamily
:
:
None
:
break
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
generic
"
)
;
return
nullptr
;
}
void
gfxPlatformFontList
:
:
InitLoader
(
)
{
GetFontFamilyNames
(
mFontInfo
-
>
mFontFamiliesToLoad
)
;
mStartIndex
=
0
;
mNumFamilies
=
mFontInfo
-
>
mFontFamiliesToLoad
.
Length
(
)
;
memset
(
&
(
mFontInfo
-
>
mLoadStats
)
0
sizeof
(
mFontInfo
-
>
mLoadStats
)
)
;
}
#
define
FONT_LOADER_MAX_TIMESLICE
\
20
/
/
max
time
for
one
pass
through
RunLoader
=
20ms
bool
gfxPlatformFontList
:
:
LoadFontInfo
(
)
{
AutoLock
lock
(
mLock
)
;
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
uint32_t
i
endIndex
=
mNumFamilies
;
fontlist
:
:
FontList
*
list
=
SharedFontList
(
)
;
bool
loadCmaps
=
!
list
&
&
(
!
UsesSystemFallback
(
)
|
|
gfxPlatform
:
:
GetPlatform
(
)
-
>
UseCmapsDuringSystemFallback
(
)
)
;
for
(
i
=
mStartIndex
;
i
<
endIndex
;
i
+
+
)
{
nsAutoCString
key
;
GenerateFontListKey
(
mFontInfo
-
>
mFontFamiliesToLoad
[
i
]
key
)
;
if
(
list
)
{
fontlist
:
:
Family
*
family
=
list
-
>
FindFamily
(
key
)
;
if
(
!
family
)
{
continue
;
}
ReadFaceNamesForFamily
(
family
NeedFullnamePostscriptNames
(
)
)
;
}
else
{
gfxFontFamily
*
familyEntry
=
mFontFamilies
.
GetWeak
(
key
)
;
if
(
!
familyEntry
)
{
continue
;
}
familyEntry
-
>
ReadFaceNames
(
this
NeedFullnamePostscriptNames
(
)
mFontInfo
)
;
if
(
loadCmaps
)
{
familyEntry
-
>
ReadAllCMAPs
(
mFontInfo
)
;
}
}
if
(
StaticPrefs
:
:
gfx_font_loader_delay
(
)
>
0
)
{
TimeDuration
elapsed
=
TimeStamp
:
:
Now
(
)
-
start
;
if
(
elapsed
.
ToMilliseconds
(
)
>
FONT_LOADER_MAX_TIMESLICE
&
&
i
+
1
!
=
endIndex
)
{
endIndex
=
i
+
1
;
break
;
}
}
}
mStartIndex
=
endIndex
;
bool
done
=
mStartIndex
>
=
mNumFamilies
;
if
(
LOG_FONTINIT_ENABLED
(
)
)
{
TimeDuration
elapsed
=
TimeStamp
:
:
Now
(
)
-
start
;
LOG_FONTINIT
(
(
"
(
fontinit
)
fontloader
load
pass
%
8
.
2f
ms
done
%
s
\
n
"
elapsed
.
ToMilliseconds
(
)
(
done
?
"
true
"
:
"
false
"
)
)
)
;
}
if
(
done
)
{
mOtherFamilyNamesInitialized
=
true
;
CancelInitOtherFamilyNamesTask
(
)
;
mFaceNameListsInitialized
=
true
;
}
return
done
;
}
void
gfxPlatformFontList
:
:
CleanupLoader
(
)
{
AutoLock
lock
(
mLock
)
;
mFontFamiliesToLoad
.
Clear
(
)
;
mNumFamilies
=
0
;
bool
rebuilt
=
false
forceReflow
=
false
;
if
(
mFaceNamesMissed
)
{
rebuilt
=
std
:
:
any_of
(
mFaceNamesMissed
-
>
cbegin
(
)
mFaceNamesMissed
-
>
cend
(
)
[
&
]
(
const
auto
&
key
)
{
mLock
.
AssertCurrentThreadIn
(
)
;
return
FindFaceName
(
key
)
;
}
)
;
if
(
rebuilt
)
{
RebuildLocalFonts
(
)
;
}
mFaceNamesMissed
=
nullptr
;
}
if
(
mOtherNamesMissed
)
{
forceReflow
=
std
:
:
any_of
(
mOtherNamesMissed
-
>
cbegin
(
)
mOtherNamesMissed
-
>
cend
(
)
[
&
]
(
const
auto
&
key
)
{
mLock
.
AssertCurrentThreadIn
(
)
;
return
FindUnsharedFamily
(
nullptr
key
(
FindFamiliesFlags
:
:
eForceOtherFamilyNamesLoading
|
FindFamiliesFlags
:
:
eNoAddToNamesMissedWhenSearching
)
)
;
}
)
;
if
(
forceReflow
)
{
gfxPlatform
:
:
GlobalReflowFlags
flags
=
gfxPlatform
:
:
GlobalReflowFlags
:
:
FontsChanged
;
ForceGlobalReflowLocked
(
flags
)
;
}
mOtherNamesMissed
=
nullptr
;
}
if
(
LOG_FONTINIT_ENABLED
(
)
&
&
mFontInfo
)
{
LOG_FONTINIT
(
(
"
(
fontinit
)
fontloader
load
thread
took
%
8
.
2f
ms
"
"
%
d
families
%
d
fonts
%
d
cmaps
"
"
%
d
facenames
%
d
othernames
%
s
%
s
"
mLoadTime
.
ToMilliseconds
(
)
mFontInfo
-
>
mLoadStats
.
families
mFontInfo
-
>
mLoadStats
.
fonts
mFontInfo
-
>
mLoadStats
.
cmaps
mFontInfo
-
>
mLoadStats
.
facenames
mFontInfo
-
>
mLoadStats
.
othernames
(
rebuilt
?
"
(
userfont
sets
rebuilt
)
"
:
"
"
)
(
forceReflow
?
"
(
global
reflow
)
"
:
"
"
)
)
)
;
}
gfxFontInfoLoader
:
:
CleanupLoader
(
)
;
}
void
gfxPlatformFontList
:
:
ForceGlobalReflow
(
gfxPlatform
:
:
GlobalReflowFlags
aFlags
)
{
if
(
!
NS_IsMainThread
(
)
)
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
gfxPlatformFontList
:
:
ForceGlobalReflow
"
[
this
aFlags
]
{
this
-
>
ForceGlobalReflow
(
aFlags
)
;
}
)
)
;
return
;
}
if
(
aFlags
&
gfxPlatform
:
:
GlobalReflowFlags
:
:
FontsChanged
)
{
AutoLock
lock
(
mLock
)
;
InitializeCodepointsWithNoFonts
(
)
;
if
(
SharedFontList
(
)
)
{
RebuildLocalFonts
(
true
)
;
}
}
gfxPlatform
:
:
ForceGlobalReflow
(
aFlags
)
;
}
void
gfxPlatformFontList
:
:
ForceGlobalReflowLocked
(
gfxPlatform
:
:
GlobalReflowFlags
aFlags
)
{
if
(
!
NS_IsMainThread
(
)
)
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
gfxPlatformFontList
:
:
ForceGlobalReflow
"
[
this
aFlags
]
{
this
-
>
ForceGlobalReflow
(
aFlags
)
;
}
)
)
;
return
;
}
if
(
aFlags
&
gfxPlatform
:
:
GlobalReflowFlags
:
:
FontsChanged
)
{
InitializeCodepointsWithNoFonts
(
)
;
if
(
SharedFontList
(
)
)
{
RebuildLocalFonts
(
true
)
;
}
}
AutoUnlock
unlock
(
mLock
)
;
gfxPlatform
:
:
ForceGlobalReflow
(
aFlags
)
;
}
void
gfxPlatformFontList
:
:
GetPrefsAndStartLoader
(
)
{
if
(
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
AppShutdownConfirmed
)
)
{
return
;
}
uint32_t
delay
=
std
:
:
max
(
1u
StaticPrefs
:
:
gfx_font_loader_delay
(
)
)
;
if
(
NS_IsMainThread
(
)
)
{
StartLoader
(
delay
)
;
}
else
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
StartLoader
callback
"
[
delay
fontList
=
this
]
{
fontList
-
>
Lock
(
)
;
fontList
-
>
StartLoader
(
delay
)
;
fontList
-
>
Unlock
(
)
;
}
)
)
;
}
}
void
gfxPlatformFontList
:
:
RebuildLocalFonts
(
bool
aForgetLocalFaces
)
{
AutoTArray
<
RefPtr
<
gfxUserFontSet
>
16
>
fontSets
;
fontSets
.
SetCapacity
(
mUserFontSetList
.
Count
(
)
)
;
for
(
auto
*
fontset
:
mUserFontSetList
)
{
fontSets
.
AppendElement
(
fontset
)
;
}
AutoUnlock
unlock
(
mLock
)
;
for
(
auto
fontset
:
fontSets
)
{
if
(
aForgetLocalFaces
)
{
fontset
-
>
ForgetLocalFaces
(
)
;
}
fontset
-
>
RebuildLocalRules
(
)
;
}
}
void
gfxPlatformFontList
:
:
ClearLangGroupPrefFontsLocked
(
)
{
for
(
uint32_t
i
=
eFontPrefLang_First
;
i
<
eFontPrefLang_First
+
eFontPrefLang_Count
;
i
+
+
)
{
auto
&
prefFontsLangGroup
=
mLangGroupPrefFonts
[
i
]
;
for
(
auto
&
pref
:
prefFontsLangGroup
)
{
pref
=
nullptr
;
}
}
mCJKPrefLangs
.
Clear
(
)
;
mEmojiPrefFont
=
nullptr
;
mFontPrefs
=
MakeUnique
<
FontPrefs
>
(
)
;
}
size_t
gfxPlatformFontList
:
:
SizeOfFontFamilyTableExcludingThis
(
const
FontFamilyTable
&
aTable
MallocSizeOf
aMallocSizeOf
)
{
return
std
:
:
accumulate
(
aTable
.
Keys
(
)
.
cbegin
(
)
aTable
.
Keys
(
)
.
cend
(
)
aTable
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
[
&
]
(
size_t
oldValue
const
nsACString
&
key
)
{
return
oldValue
+
key
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
)
;
}
size_t
gfxPlatformFontList
:
:
SizeOfFontEntryTableExcludingThis
(
const
FontEntryTable
&
aTable
MallocSizeOf
aMallocSizeOf
)
{
return
std
:
:
accumulate
(
aTable
.
Keys
(
)
.
cbegin
(
)
aTable
.
Keys
(
)
.
cend
(
)
aTable
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
[
&
]
(
size_t
oldValue
const
nsACString
&
key
)
{
return
oldValue
+
key
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
)
;
}
void
gfxPlatformFontList
:
:
AddSizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
FontListSizes
*
aSizes
)
const
{
AutoLock
lock
(
mLock
)
;
aSizes
-
>
mFontListSize
+
=
mFontFamilies
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
const
auto
&
entry
:
mFontFamilies
)
{
aSizes
-
>
mFontListSize
+
=
entry
.
GetKey
(
)
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
entry
.
GetData
(
)
-
>
AddSizeOfIncludingThis
(
aMallocSizeOf
aSizes
)
;
}
aSizes
-
>
mFontListSize
+
=
SizeOfFontFamilyTableExcludingThis
(
mOtherFamilyNames
aMallocSizeOf
)
;
if
(
mExtraNames
)
{
aSizes
-
>
mFontListSize
+
=
SizeOfFontEntryTableExcludingThis
(
mExtraNames
-
>
mFullnames
aMallocSizeOf
)
;
aSizes
-
>
mFontListSize
+
=
SizeOfFontEntryTableExcludingThis
(
mExtraNames
-
>
mPostscriptNames
aMallocSizeOf
)
;
}
for
(
uint32_t
i
=
eFontPrefLang_First
;
i
<
eFontPrefLang_First
+
eFontPrefLang_Count
;
i
+
+
)
{
auto
&
prefFontsLangGroup
=
mLangGroupPrefFonts
[
i
]
;
for
(
const
UniquePtr
<
PrefFontList
>
&
pf
:
prefFontsLangGroup
)
{
if
(
pf
)
{
aSizes
-
>
mFontListSize
+
=
pf
-
>
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
}
}
for
(
const
auto
&
bitset
:
mCodepointsWithNoFonts
)
{
aSizes
-
>
mFontListSize
+
=
bitset
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
aSizes
-
>
mFontListSize
+
=
mFontFamiliesToLoad
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
aSizes
-
>
mFontListSize
+
=
mBadUnderlineFamilyNames
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
const
auto
&
i
:
mBadUnderlineFamilyNames
)
{
aSizes
-
>
mFontListSize
+
=
i
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
aSizes
-
>
mFontListSize
+
=
mSharedCmaps
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
const
auto
&
entry
:
mSharedCmaps
)
{
aSizes
-
>
mCharMapsSize
+
=
entry
.
GetKey
(
)
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
aSizes
-
>
mFontListSize
+
=
mFontEntries
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
const
auto
&
entry
:
mFontEntries
.
Values
(
)
)
{
if
(
entry
)
{
entry
-
>
AddSizeOfIncludingThis
(
aMallocSizeOf
aSizes
)
;
}
}
if
(
SharedFontList
(
)
)
{
aSizes
-
>
mFontListSize
+
=
SharedFontList
(
)
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
if
(
XRE_IsParentProcess
(
)
)
{
aSizes
-
>
mSharedSize
+
=
SharedFontList
(
)
-
>
AllocatedShmemSize
(
)
;
}
}
}
void
gfxPlatformFontList
:
:
AddSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
FontListSizes
*
aSizes
)
const
{
aSizes
-
>
mFontListSize
+
=
aMallocSizeOf
(
this
)
;
AddSizeOfExcludingThis
(
aMallocSizeOf
aSizes
)
;
}
void
gfxPlatformFontList
:
:
InitOtherFamilyNamesInternal
(
bool
aDeferOtherFamilyNamesLoading
)
{
if
(
mOtherFamilyNamesInitialized
)
{
return
;
}
AutoLock
lock
(
mLock
)
;
if
(
aDeferOtherFamilyNamesLoading
)
{
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
bool
timedOut
=
false
;
auto
list
=
SharedFontList
(
)
;
if
(
list
)
{
if
(
mState
=
=
stateInitial
|
|
mState
=
=
stateTimerOnDelay
)
{
StartLoader
(
0
)
;
timedOut
=
true
;
}
}
else
{
for
(
const
RefPtr
<
gfxFontFamily
>
&
family
:
mFontFamilies
.
Values
(
)
)
{
family
-
>
ReadOtherFamilyNames
(
this
)
;
TimeDuration
elapsed
=
TimeStamp
:
:
Now
(
)
-
start
;
if
(
elapsed
.
ToMilliseconds
(
)
>
OTHERNAMES_TIMEOUT
)
{
timedOut
=
true
;
break
;
}
}
}
if
(
!
timedOut
)
{
mOtherFamilyNamesInitialized
=
true
;
CancelInitOtherFamilyNamesTask
(
)
;
}
TimeDuration
elapsed
=
TimeStamp
:
:
Now
(
)
-
start
;
glean
:
:
fontlist
:
:
initotherfamilynames
.
AccumulateRawDuration
(
elapsed
)
;
if
(
LOG_FONTINIT_ENABLED
(
)
)
{
LOG_FONTINIT
(
(
"
(
fontinit
)
InitOtherFamilyNames
took
%
8
.
2f
ms
%
s
"
elapsed
.
ToMilliseconds
(
)
(
timedOut
?
"
timeout
"
:
"
"
)
)
)
;
}
}
else
{
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
auto
list
=
SharedFontList
(
)
;
if
(
list
)
{
for
(
auto
&
f
:
mozilla
:
:
Range
<
fontlist
:
:
Family
>
(
list
-
>
Families
(
)
list
-
>
NumFamilies
(
)
)
)
{
ReadFaceNamesForFamily
(
&
f
false
)
;
}
}
else
{
for
(
const
RefPtr
<
gfxFontFamily
>
&
family
:
mFontFamilies
.
Values
(
)
)
{
family
-
>
ReadOtherFamilyNames
(
this
)
;
}
}
mOtherFamilyNamesInitialized
=
true
;
CancelInitOtherFamilyNamesTask
(
)
;
TimeDuration
elapsed
=
TimeStamp
:
:
Now
(
)
-
start
;
glean
:
:
fontlist
:
:
initotherfamilynames_no_deferring
.
AccumulateRawDuration
(
elapsed
)
;
if
(
LOG_FONTINIT_ENABLED
(
)
)
{
LOG_FONTINIT
(
(
"
(
fontinit
)
InitOtherFamilyNames
without
deferring
took
%
8
.
2f
ms
"
elapsed
.
ToMilliseconds
(
)
)
)
;
}
}
}
void
gfxPlatformFontList
:
:
CancelInitOtherFamilyNamesTask
(
)
{
if
(
mPendingOtherFamilyNameTask
)
{
mPendingOtherFamilyNameTask
-
>
Cancel
(
)
;
mPendingOtherFamilyNameTask
=
nullptr
;
}
auto
list
=
SharedFontList
(
)
;
if
(
list
&
&
XRE_IsParentProcess
(
)
)
{
bool
forceReflow
=
false
;
if
(
!
mAliasTable
.
IsEmpty
(
)
)
{
list
-
>
SetAliases
(
mAliasTable
)
;
mAliasTable
.
Clear
(
)
;
forceReflow
=
true
;
}
if
(
mLocalNameTable
.
Count
(
)
)
{
list
-
>
SetLocalNames
(
mLocalNameTable
)
;
mLocalNameTable
.
Clear
(
)
;
forceReflow
=
true
;
}
if
(
forceReflow
&
&
!
mLoadCmapsRunnable
)
{
gfxPlatform
:
:
GlobalReflowFlags
flags
=
gfxPlatform
:
:
GlobalReflowFlags
:
:
BroadcastToChildren
|
gfxPlatform
:
:
GlobalReflowFlags
:
:
FontsChanged
;
gfxPlatform
:
:
ForceGlobalReflow
(
flags
)
;
}
}
}
void
gfxPlatformFontList
:
:
ShareFontListShmBlockToProcess
(
uint32_t
aGeneration
uint32_t
aIndex
base
:
:
ProcessId
aPid
mozilla
:
:
ipc
:
:
ReadOnlySharedMemoryHandle
*
aOut
)
{
auto
list
=
SharedFontList
(
)
;
if
(
!
list
)
{
return
;
}
if
(
!
aGeneration
|
|
list
-
>
GetGeneration
(
)
=
=
aGeneration
)
{
list
-
>
ShareShmBlockToProcess
(
aIndex
aPid
aOut
)
;
}
else
{
*
aOut
=
nullptr
;
}
}
void
gfxPlatformFontList
:
:
ShareFontListToProcess
(
nsTArray
<
mozilla
:
:
ipc
:
:
ReadOnlySharedMemoryHandle
>
*
aBlocks
base
:
:
ProcessId
aPid
)
{
auto
list
=
SharedFontList
(
)
;
if
(
list
)
{
list
-
>
ShareBlocksToProcess
(
aBlocks
aPid
)
;
}
}
mozilla
:
:
ipc
:
:
ReadOnlySharedMemoryHandle
gfxPlatformFontList
:
:
ShareShmBlockToProcess
(
uint32_t
aIndex
base
:
:
ProcessId
aPid
)
{
MOZ_RELEASE_ASSERT
(
SharedFontList
(
)
)
;
return
SharedFontList
(
)
-
>
ShareBlockToProcess
(
aIndex
aPid
)
;
}
void
gfxPlatformFontList
:
:
ShmBlockAdded
(
uint32_t
aGeneration
uint32_t
aIndex
mozilla
:
:
ipc
:
:
ReadOnlySharedMemoryHandle
aHandle
)
{
if
(
SharedFontList
(
)
)
{
AutoLock
lock
(
mLock
)
;
SharedFontList
(
)
-
>
ShmBlockAdded
(
aGeneration
aIndex
std
:
:
move
(
aHandle
)
)
;
}
}
void
gfxPlatformFontList
:
:
InitializeFamily
(
uint32_t
aGeneration
uint32_t
aFamilyIndex
bool
aLoadCmaps
)
{
auto
list
=
SharedFontList
(
)
;
MOZ_ASSERT
(
list
)
;
if
(
!
list
)
{
return
;
}
if
(
list
-
>
GetGeneration
(
)
!
=
aGeneration
)
{
return
;
}
if
(
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
AppShutdownConfirmed
)
)
{
return
;
}
if
(
aFamilyIndex
>
=
list
-
>
NumFamilies
(
)
)
{
return
;
}
fontlist
:
:
Family
*
family
=
list
-
>
Families
(
)
+
aFamilyIndex
;
if
(
!
family
-
>
IsInitialized
(
)
|
|
aLoadCmaps
)
{
Unused
<
<
InitializeFamily
(
family
aLoadCmaps
)
;
}
}
void
gfxPlatformFontList
:
:
SetCharacterMap
(
uint32_t
aGeneration
uint32_t
aFamilyIndex
bool
aAlias
uint32_t
aFaceIndex
const
gfxSparseBitSet
&
aMap
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
auto
list
=
SharedFontList
(
)
;
MOZ_ASSERT
(
list
)
;
if
(
!
list
)
{
return
;
}
if
(
list
-
>
GetGeneration
(
)
!
=
aGeneration
)
{
return
;
}
if
(
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
AppShutdownConfirmed
)
)
{
return
;
}
const
fontlist
:
:
Family
*
family
;
if
(
aAlias
)
{
if
(
aFamilyIndex
>
=
list
-
>
NumAliases
(
)
)
{
MOZ_ASSERT
(
false
"
AliasFamily
index
out
of
range
"
)
;
return
;
}
family
=
list
-
>
AliasFamilies
(
)
+
aFamilyIndex
;
}
else
{
if
(
aFamilyIndex
>
=
list
-
>
NumFamilies
(
)
)
{
MOZ_ASSERT
(
false
"
Family
index
out
of
range
"
)
;
return
;
}
family
=
list
-
>
Families
(
)
+
aFamilyIndex
;
}
if
(
aFaceIndex
>
=
family
-
>
NumFaces
(
)
)
{
MOZ_ASSERT
(
false
"
Face
index
out
of
range
"
)
;
return
;
}
if
(
auto
*
face
=
family
-
>
Faces
(
list
)
[
aFaceIndex
]
.
ToPtr
<
fontlist
:
:
Face
>
(
list
)
)
{
face
-
>
mCharacterMap
=
GetShmemCharMap
(
&
aMap
)
;
}
}
void
gfxPlatformFontList
:
:
SetupFamilyCharMap
(
uint32_t
aGeneration
uint32_t
aIndex
bool
aAlias
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
auto
list
=
SharedFontList
(
)
;
MOZ_ASSERT
(
list
)
;
if
(
!
list
)
{
return
;
}
if
(
list
-
>
GetGeneration
(
)
!
=
aGeneration
)
{
return
;
}
if
(
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
AppShutdownConfirmed
)
)
{
return
;
}
if
(
aAlias
)
{
if
(
aIndex
>
=
list
-
>
NumAliases
(
)
)
{
MOZ_ASSERT
(
false
"
AliasFamily
index
out
of
range
"
)
;
return
;
}
list
-
>
AliasFamilies
(
)
[
aIndex
]
.
SetupFamilyCharMap
(
list
)
;
return
;
}
if
(
aIndex
>
=
list
-
>
NumFamilies
(
)
)
{
MOZ_ASSERT
(
false
"
Family
index
out
of
range
"
)
;
return
;
}
list
-
>
Families
(
)
[
aIndex
]
.
SetupFamilyCharMap
(
list
)
;
}
bool
gfxPlatformFontList
:
:
InitOtherFamilyNames
(
uint32_t
aGeneration
bool
aDefer
)
{
auto
list
=
SharedFontList
(
)
;
MOZ_ASSERT
(
list
)
;
if
(
!
list
)
{
return
false
;
}
if
(
list
-
>
GetGeneration
(
)
!
=
aGeneration
)
{
return
false
;
}
if
(
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
AppShutdownConfirmed
)
)
{
return
false
;
}
return
InitOtherFamilyNames
(
aDefer
)
;
}
uint32_t
gfxPlatformFontList
:
:
GetGeneration
(
)
const
{
return
SharedFontList
(
)
?
SharedFontList
(
)
-
>
GetGeneration
(
)
:
0
;
}
gfxPlatformFontList
:
:
FontPrefs
:
:
FontPrefs
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Init
(
)
;
}
void
gfxPlatformFontList
:
:
FontPrefs
:
:
Init
(
)
{
if
(
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
XPCOMShutdownFinal
)
)
{
return
;
}
nsIPrefBranch
*
prefRootBranch
=
Preferences
:
:
GetRootBranch
(
)
;
if
(
!
prefRootBranch
)
{
return
;
}
nsTArray
<
nsCString
>
prefNames
;
if
(
NS_SUCCEEDED
(
prefRootBranch
-
>
GetChildList
(
kNamePrefix
prefNames
)
)
)
{
for
(
auto
&
prefName
:
prefNames
)
{
nsAutoCString
value
;
if
(
NS_SUCCEEDED
(
Preferences
:
:
GetCString
(
prefName
.
get
(
)
value
)
)
)
{
nsAutoCString
pref
(
Substring
(
prefName
sizeof
(
kNamePrefix
)
-
1
)
)
;
mFontName
.
InsertOrUpdate
(
pref
value
)
;
}
}
}
if
(
NS_SUCCEEDED
(
prefRootBranch
-
>
GetChildList
(
kNameListPrefix
prefNames
)
)
)
{
for
(
auto
&
prefName
:
prefNames
)
{
nsAutoCString
value
;
if
(
NS_SUCCEEDED
(
Preferences
:
:
GetCString
(
prefName
.
get
(
)
value
)
)
)
{
nsAutoCString
pref
(
Substring
(
prefName
sizeof
(
kNameListPrefix
)
-
1
)
)
;
mFontNameList
.
InsertOrUpdate
(
pref
value
)
;
}
}
}
mEmojiHasUserValue
=
Preferences
:
:
HasUserValue
(
"
font
.
name
-
list
.
emoji
"
)
;
}
bool
gfxPlatformFontList
:
:
FontPrefs
:
:
LookupName
(
const
nsACString
&
aPref
nsACString
&
aValue
)
const
{
if
(
const
auto
&
value
=
mFontName
.
Lookup
(
aPref
)
)
{
aValue
=
*
value
;
return
true
;
}
return
false
;
}
bool
gfxPlatformFontList
:
:
FontPrefs
:
:
LookupNameList
(
const
nsACString
&
aPref
nsACString
&
aValue
)
const
{
if
(
const
auto
&
value
=
mFontNameList
.
Lookup
(
aPref
)
)
{
aValue
=
*
value
;
return
true
;
}
return
false
;
}
bool
gfxPlatformFontList
:
:
IsKnownIconFontFamily
(
const
nsAtom
*
aFamilyName
)
const
{
nsAtomCString
fam
(
aFamilyName
)
;
ToLowerCase
(
fam
)
;
return
mIconFontsSet
.
Contains
(
fam
)
;
}
#
undef
LOG
#
undef
LOG_ENABLED
