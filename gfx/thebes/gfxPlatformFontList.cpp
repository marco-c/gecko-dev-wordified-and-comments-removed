#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
intl
/
LocaleService
.
h
"
#
include
"
mozilla
/
intl
/
MozLocale
.
h
"
#
include
"
mozilla
/
intl
/
OSPreferences
.
h
"
#
include
"
gfxPlatformFontList
.
h
"
#
include
"
gfxTextRun
.
h
"
#
include
"
gfxUserFontSet
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsUnicodeRange
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
<
locale
.
h
>
using
namespace
mozilla
;
using
mozilla
:
:
intl
:
:
Locale
;
using
mozilla
:
:
intl
:
:
LocaleService
;
using
mozilla
:
:
intl
:
:
OSPreferences
;
#
define
LOG_FONTLIST
(
args
)
\
MOZ_LOG
(
gfxPlatform
:
:
GetLog
(
eGfxLog_fontlist
)
LogLevel
:
:
Debug
args
)
#
define
LOG_FONTLIST_ENABLED
(
)
\
MOZ_LOG_TEST
(
gfxPlatform
:
:
GetLog
(
eGfxLog_fontlist
)
LogLevel
:
:
Debug
)
#
define
LOG_FONTINIT
(
args
)
\
MOZ_LOG
(
gfxPlatform
:
:
GetLog
(
eGfxLog_fontinit
)
LogLevel
:
:
Debug
args
)
#
define
LOG_FONTINIT_ENABLED
(
)
\
MOZ_LOG_TEST
(
gfxPlatform
:
:
GetLog
(
eGfxLog_fontinit
)
LogLevel
:
:
Debug
)
gfxPlatformFontList
*
gfxPlatformFontList
:
:
sPlatformFontList
=
nullptr
;
const
gfxFontEntry
:
:
ScriptRange
gfxPlatformFontList
:
:
sComplexScriptRanges
[
]
=
{
{
0x0600
0x06FF
1
{
TRUETYPE_TAG
(
'
a
'
'
r
'
'
a
'
'
b
'
)
0
0
}
}
{
0x0700
0x074F
1
{
TRUETYPE_TAG
(
'
s
'
'
y
'
'
r
'
'
c
'
)
0
0
}
}
{
0x0750
0x077F
1
{
TRUETYPE_TAG
(
'
a
'
'
r
'
'
a
'
'
b
'
)
0
0
}
}
{
0x08A0
0x08FF
1
{
TRUETYPE_TAG
(
'
a
'
'
r
'
'
a
'
'
b
'
)
0
0
}
}
{
0x0900
0x097F
2
{
TRUETYPE_TAG
(
'
d
'
'
e
'
'
v
'
'
2
'
)
TRUETYPE_TAG
(
'
d
'
'
e
'
'
v
'
'
a
'
)
0
}
}
{
0x0980
0x09FF
2
{
TRUETYPE_TAG
(
'
b
'
'
n
'
'
g
'
'
2
'
)
TRUETYPE_TAG
(
'
b
'
'
e
'
'
n
'
'
g
'
)
0
}
}
{
0x0A00
0x0A7F
2
{
TRUETYPE_TAG
(
'
g
'
'
u
'
'
r
'
'
2
'
)
TRUETYPE_TAG
(
'
g
'
'
u
'
'
r
'
'
u
'
)
0
}
}
{
0x0A80
0x0AFF
2
{
TRUETYPE_TAG
(
'
g
'
'
j
'
'
r
'
'
2
'
)
TRUETYPE_TAG
(
'
g
'
'
u
'
'
j
'
'
r
'
)
0
}
}
{
0x0B00
0x0B7F
2
{
TRUETYPE_TAG
(
'
o
'
'
r
'
'
y
'
'
2
'
)
TRUETYPE_TAG
(
'
o
'
'
r
'
'
y
'
'
a
'
)
0
}
}
{
0x0B80
0x0BFF
2
{
TRUETYPE_TAG
(
'
t
'
'
m
'
'
l
'
'
2
'
)
TRUETYPE_TAG
(
'
t
'
'
a
'
'
m
'
'
l
'
)
0
}
}
{
0x0C00
0x0C7F
2
{
TRUETYPE_TAG
(
'
t
'
'
e
'
'
l
'
'
2
'
)
TRUETYPE_TAG
(
'
t
'
'
e
'
'
l
'
'
u
'
)
0
}
}
{
0x0C80
0x0CFF
2
{
TRUETYPE_TAG
(
'
k
'
'
n
'
'
d
'
'
2
'
)
TRUETYPE_TAG
(
'
k
'
'
n
'
'
d
'
'
a
'
)
0
}
}
{
0x0D00
0x0D7F
2
{
TRUETYPE_TAG
(
'
m
'
'
l
'
'
m
'
'
2
'
)
TRUETYPE_TAG
(
'
m
'
'
l
'
'
y
'
'
m
'
)
0
}
}
{
0x0D80
0x0DFF
1
{
TRUETYPE_TAG
(
'
s
'
'
i
'
'
n
'
'
h
'
)
0
0
}
}
{
0x0E80
0x0EFF
1
{
TRUETYPE_TAG
(
'
l
'
'
a
'
'
o
'
'
'
)
0
0
}
}
{
0x0F00
0x0FFF
1
{
TRUETYPE_TAG
(
'
t
'
'
i
'
'
b
'
'
t
'
)
0
0
}
}
{
0x1000
0x109f
2
{
TRUETYPE_TAG
(
'
m
'
'
y
'
'
m
'
'
r
'
)
TRUETYPE_TAG
(
'
m
'
'
y
'
'
m
'
'
2
'
)
0
}
}
{
0x1780
0x17ff
1
{
TRUETYPE_TAG
(
'
k
'
'
h
'
'
m
'
'
r
'
)
0
0
}
}
{
0xaa60
0xaa7f
2
{
TRUETYPE_TAG
(
'
m
'
'
y
'
'
m
'
'
r
'
)
TRUETYPE_TAG
(
'
m
'
'
y
'
'
m
'
'
2
'
)
0
}
}
{
0
0
0
{
0
0
0
}
}
}
;
#
define
FONT_LOADER_DELAY_PREF
"
gfx
.
font_loader
.
delay
"
#
define
FONT_LOADER_INTERVAL_PREF
"
gfx
.
font_loader
.
interval
"
static
const
char
*
kObservedPrefs
[
]
=
{
"
font
.
"
"
font
.
name
-
list
.
"
"
intl
.
accept_languages
"
nullptr
}
;
static
const
char
kFontSystemWhitelistPref
[
]
=
"
font
.
system
.
whitelist
"
;
static
const
char
*
gPrefLangNames
[
]
=
{
#
define
FONT_PREF_LANG
(
enum_id_
str_
atom_id_
)
str_
#
include
"
gfxFontPrefLangList
.
h
"
#
undef
FONT_PREF_LANG
}
;
static_assert
(
MOZ_ARRAY_LENGTH
(
gPrefLangNames
)
=
=
uint32_t
(
eFontPrefLang_Count
)
"
size
of
pref
lang
name
array
doesn
'
t
match
pref
lang
enum
size
"
)
;
class
gfxFontListPrefObserver
final
:
public
nsIObserver
{
~
gfxFontListPrefObserver
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
}
;
static
void
FontListPrefChanged
(
const
char
*
aPref
void
*
aData
=
nullptr
)
{
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
ClearLangGroupPrefFonts
(
)
;
gfxFontCache
:
:
GetCache
(
)
-
>
AgeAllGenerations
(
)
;
}
static
gfxFontListPrefObserver
*
gFontListPrefObserver
=
nullptr
;
NS_IMPL_ISUPPORTS
(
gfxFontListPrefObserver
nsIObserver
)
#
define
LOCALES_CHANGED_TOPIC
"
intl
:
system
-
locales
-
changed
"
NS_IMETHODIMP
gfxFontListPrefObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
NS_ASSERTION
(
!
strcmp
(
aTopic
LOCALES_CHANGED_TOPIC
)
"
invalid
topic
"
)
;
FontListPrefChanged
(
nullptr
)
;
if
(
XRE_IsParentProcess
(
)
)
{
gfxPlatform
:
:
ForceGlobalReflow
(
)
;
}
return
NS_OK
;
}
MOZ_DEFINE_MALLOC_SIZE_OF
(
FontListMallocSizeOf
)
NS_IMPL_ISUPPORTS
(
gfxPlatformFontList
:
:
MemoryReporter
nsIMemoryReporter
)
NS_IMETHODIMP
gfxPlatformFontList
:
:
MemoryReporter
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
FontListSizes
sizes
;
sizes
.
mFontListSize
=
0
;
sizes
.
mFontTableCacheSize
=
0
;
sizes
.
mCharMapsSize
=
0
;
sizes
.
mLoaderSize
=
0
;
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
AddSizeOfIncludingThis
(
&
FontListMallocSizeOf
&
sizes
)
;
MOZ_COLLECT_REPORT
(
"
explicit
/
gfx
/
font
-
list
"
KIND_HEAP
UNITS_BYTES
sizes
.
mFontListSize
"
Memory
used
to
manage
the
list
of
font
families
and
faces
.
"
)
;
MOZ_COLLECT_REPORT
(
"
explicit
/
gfx
/
font
-
charmaps
"
KIND_HEAP
UNITS_BYTES
sizes
.
mCharMapsSize
"
Memory
used
to
record
the
character
coverage
of
individual
fonts
.
"
)
;
if
(
sizes
.
mFontTableCacheSize
)
{
MOZ_COLLECT_REPORT
(
"
explicit
/
gfx
/
font
-
tables
"
KIND_HEAP
UNITS_BYTES
sizes
.
mFontTableCacheSize
"
Memory
used
for
cached
font
metrics
and
layout
tables
.
"
)
;
}
if
(
sizes
.
mLoaderSize
)
{
MOZ_COLLECT_REPORT
(
"
explicit
/
gfx
/
font
-
loader
"
KIND_HEAP
UNITS_BYTES
sizes
.
mLoaderSize
"
Memory
used
for
(
platform
-
specific
)
font
loader
.
"
)
;
}
return
NS_OK
;
}
gfxPlatformFontList
:
:
gfxPlatformFontList
(
bool
aNeedFullnamePostscriptNames
)
:
mFontFamiliesMutex
(
"
gfxPlatformFontList
:
:
mFontFamiliesMutex
"
)
mFontFamilies
(
64
)
mOtherFamilyNames
(
16
)
mSharedCmaps
(
8
)
mStartIndex
(
0
)
mNumFamilies
(
0
)
mFontlistInitCount
(
0
)
mFontFamilyWhitelistActive
(
false
)
{
mOtherFamilyNamesInitialized
=
false
;
if
(
aNeedFullnamePostscriptNames
)
{
mExtraNames
=
MakeUnique
<
ExtraNames
>
(
)
;
}
mFaceNameListsInitialized
=
false
;
mLangService
=
nsLanguageAtomService
:
:
GetService
(
)
;
LoadBadUnderlineList
(
)
;
NS_ASSERTION
(
!
gFontListPrefObserver
"
There
has
been
font
list
pref
observer
already
"
)
;
gFontListPrefObserver
=
new
gfxFontListPrefObserver
(
)
;
NS_ADDREF
(
gFontListPrefObserver
)
;
Preferences
:
:
RegisterPrefixCallbacks
(
FontListPrefChanged
kObservedPrefs
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
AddObserver
(
gFontListPrefObserver
LOCALES_CHANGED_TOPIC
false
)
;
}
if
(
XRE_IsParentProcess
(
)
)
{
Preferences
:
:
RegisterCallback
(
FontWhitelistPrefChanged
kFontSystemWhitelistPref
)
;
}
RegisterStrongMemoryReporter
(
new
MemoryReporter
(
)
)
;
}
gfxPlatformFontList
:
:
~
gfxPlatformFontList
(
)
{
mSharedCmaps
.
Clear
(
)
;
ClearLangGroupPrefFonts
(
)
;
NS_ASSERTION
(
gFontListPrefObserver
"
There
is
no
font
list
pref
observer
"
)
;
Preferences
:
:
UnregisterPrefixCallbacks
(
FontListPrefChanged
kObservedPrefs
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
gFontListPrefObserver
LOCALES_CHANGED_TOPIC
)
;
}
if
(
XRE_IsParentProcess
(
)
)
{
Preferences
:
:
UnregisterCallback
(
FontWhitelistPrefChanged
kFontSystemWhitelistPref
)
;
}
NS_RELEASE
(
gFontListPrefObserver
)
;
}
void
gfxPlatformFontList
:
:
FontWhitelistPrefChanged
(
const
char
*
aPref
void
*
aClosure
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
UpdateFontList
(
)
;
mozilla
:
:
dom
:
:
ContentParent
:
:
NotifyUpdatedFonts
(
)
;
}
const
uint32_t
kNumGenerics
=
5
;
void
gfxPlatformFontList
:
:
ApplyWhitelist
(
)
{
nsTArray
<
nsCString
>
list
;
gfxFontUtils
:
:
GetPrefsFontList
(
kFontSystemWhitelistPref
list
)
;
uint32_t
numFonts
=
list
.
Length
(
)
;
mFontFamilyWhitelistActive
=
(
numFonts
>
0
)
;
if
(
!
mFontFamilyWhitelistActive
)
{
return
;
}
nsTHashtable
<
nsCStringHashKey
>
familyNamesWhitelist
;
for
(
uint32_t
i
=
0
;
i
<
numFonts
;
i
+
+
)
{
nsAutoCString
key
;
ToLowerCase
(
list
[
i
]
key
)
;
familyNamesWhitelist
.
PutEntry
(
key
)
;
}
for
(
auto
iter
=
mFontFamilies
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
mFontFamilies
.
Count
(
)
=
=
1
)
{
break
;
}
nsAutoCString
fontFamilyName
(
iter
.
Key
(
)
)
;
ToLowerCase
(
fontFamilyName
)
;
if
(
!
familyNamesWhitelist
.
Contains
(
fontFamilyName
)
)
{
iter
.
Remove
(
)
;
}
}
}
bool
gfxPlatformFontList
:
:
AddWithLegacyFamilyName
(
const
nsACString
&
aLegacyName
gfxFontEntry
*
aFontEntry
)
{
bool
added
=
false
;
nsAutoCString
key
;
ToLowerCase
(
aLegacyName
key
)
;
gfxFontFamily
*
family
=
mOtherFamilyNames
.
GetWeak
(
key
)
;
if
(
!
family
)
{
family
=
CreateFontFamily
(
aLegacyName
)
;
family
-
>
SetHasStyles
(
true
)
;
mOtherFamilyNames
.
Put
(
key
family
)
;
added
=
true
;
}
family
-
>
AddFontEntry
(
aFontEntry
-
>
Clone
(
)
)
;
return
added
;
}
nsresult
gfxPlatformFontList
:
:
InitFontList
(
)
{
mFontlistInitCount
+
+
;
if
(
LOG_FONTINIT_ENABLED
(
)
)
{
LOG_FONTINIT
(
(
"
(
fontinit
)
system
fontlist
initialization
\
n
"
)
)
;
}
gfxFontCache
*
fontCache
=
gfxFontCache
:
:
GetCache
(
)
;
if
(
fontCache
)
{
fontCache
-
>
AgeAllGenerations
(
)
;
fontCache
-
>
FlushShapedWordCaches
(
)
;
}
gfxPlatform
:
:
PurgeSkiaFontCache
(
)
;
CancelInitOtherFamilyNamesTask
(
)
;
MutexAutoLock
lock
(
mFontFamiliesMutex
)
;
mFontFamilies
.
Clear
(
)
;
mOtherFamilyNames
.
Clear
(
)
;
mOtherFamilyNamesInitialized
=
false
;
if
(
mExtraNames
)
{
mExtraNames
-
>
mFullnames
.
Clear
(
)
;
mExtraNames
-
>
mPostscriptNames
.
Clear
(
)
;
}
mFaceNameListsInitialized
=
false
;
ClearLangGroupPrefFonts
(
)
;
mReplacementCharFallbackFamily
=
nullptr
;
CancelLoader
(
)
;
mCodepointsWithNoFonts
.
reset
(
)
;
mCodepointsWithNoFonts
.
SetRange
(
0
0x1f
)
;
mCodepointsWithNoFonts
.
SetRange
(
0x7f
0x9f
)
;
sPlatformFontList
=
this
;
nsresult
rv
=
InitFontListForPlatform
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
ApplyWhitelist
(
)
;
return
NS_OK
;
}
void
gfxPlatformFontList
:
:
GenerateFontListKey
(
const
nsACString
&
aKeyName
nsACString
&
aResult
)
{
aResult
=
aKeyName
;
ToLowerCase
(
aResult
)
;
}
#
define
OTHERNAMES_TIMEOUT
200
void
gfxPlatformFontList
:
:
InitOtherFamilyNames
(
bool
aDeferOtherFamilyNamesLoading
)
{
if
(
mOtherFamilyNamesInitialized
)
{
return
;
}
if
(
aDeferOtherFamilyNamesLoading
&
&
Preferences
:
:
GetUint
(
FONT_LOADER_DELAY_PREF
)
>
0
)
{
if
(
!
mPendingOtherFamilyNameTask
)
{
RefPtr
<
mozilla
:
:
CancelableRunnable
>
task
=
new
InitOtherFamilyNamesRunnable
(
)
;
mPendingOtherFamilyNameTask
=
task
;
NS_DispatchToMainThreadQueue
(
task
.
forget
(
)
EventQueuePriority
:
:
Idle
)
;
}
}
else
{
InitOtherFamilyNamesInternal
(
false
)
;
}
}
#
define
NAMELIST_TIMEOUT
200
gfxFontEntry
*
gfxPlatformFontList
:
:
SearchFamiliesForFaceName
(
const
nsACString
&
aFaceName
)
{
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
bool
timedOut
=
false
;
char16_t
firstChar
=
0
;
gfxFontEntry
*
lookup
=
nullptr
;
firstChar
=
ToLowerCase
(
aFaceName
.
CharAt
(
0
)
)
;
for
(
auto
iter
=
mFontFamilies
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsCStringHashKey
:
:
KeyType
key
=
iter
.
Key
(
)
;
RefPtr
<
gfxFontFamily
>
&
family
=
iter
.
Data
(
)
;
if
(
firstChar
&
&
ToLowerCase
(
key
.
CharAt
(
0
)
)
!
=
firstChar
)
{
continue
;
}
family
-
>
ReadFaceNames
(
this
NeedFullnamePostscriptNames
(
)
)
;
TimeDuration
elapsed
=
TimeStamp
:
:
Now
(
)
-
start
;
if
(
elapsed
.
ToMilliseconds
(
)
>
NAMELIST_TIMEOUT
)
{
timedOut
=
true
;
break
;
}
}
lookup
=
FindFaceName
(
aFaceName
)
;
TimeStamp
end
=
TimeStamp
:
:
Now
(
)
;
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
FONTLIST_INITFACENAMELISTS
start
end
)
;
if
(
LOG_FONTINIT_ENABLED
(
)
)
{
TimeDuration
elapsed
=
end
-
start
;
LOG_FONTINIT
(
(
"
(
fontinit
)
SearchFamiliesForFaceName
took
%
8
.
2f
ms
%
s
%
s
"
elapsed
.
ToMilliseconds
(
)
(
lookup
?
"
found
name
"
:
"
"
)
(
timedOut
?
"
timeout
"
:
"
"
)
)
)
;
}
return
lookup
;
}
gfxFontEntry
*
gfxPlatformFontList
:
:
FindFaceName
(
const
nsACString
&
aFaceName
)
{
gfxFontEntry
*
lookup
;
if
(
mExtraNames
&
&
(
(
lookup
=
mExtraNames
-
>
mPostscriptNames
.
GetWeak
(
aFaceName
)
)
|
|
(
lookup
=
mExtraNames
-
>
mFullnames
.
GetWeak
(
aFaceName
)
)
)
)
{
return
lookup
;
}
return
nullptr
;
}
gfxFontEntry
*
gfxPlatformFontList
:
:
LookupInFaceNameLists
(
const
nsACString
&
aFaceName
)
{
gfxFontEntry
*
lookup
=
nullptr
;
if
(
!
mFaceNameListsInitialized
)
{
lookup
=
SearchFamiliesForFaceName
(
aFaceName
)
;
if
(
lookup
)
{
return
lookup
;
}
}
if
(
!
(
lookup
=
FindFaceName
(
aFaceName
)
)
)
{
if
(
!
mFaceNameListsInitialized
)
{
if
(
!
mFaceNamesMissed
)
{
mFaceNamesMissed
=
MakeUnique
<
nsTHashtable
<
nsCStringHashKey
>
>
(
2
)
;
}
mFaceNamesMissed
-
>
PutEntry
(
aFaceName
)
;
}
}
return
lookup
;
}
void
gfxPlatformFontList
:
:
PreloadNamesList
(
)
{
AutoTArray
<
nsCString
10
>
preloadFonts
;
gfxFontUtils
:
:
GetPrefsFontList
(
"
font
.
preload
-
names
-
list
"
preloadFonts
)
;
uint32_t
numFonts
=
preloadFonts
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
numFonts
;
i
+
+
)
{
nsAutoCString
key
;
GenerateFontListKey
(
preloadFonts
[
i
]
key
)
;
gfxFontFamily
*
familyEntry
=
mFontFamilies
.
GetWeak
(
key
)
;
if
(
familyEntry
)
{
familyEntry
-
>
ReadOtherFamilyNames
(
this
)
;
}
}
}
void
gfxPlatformFontList
:
:
LoadBadUnderlineList
(
)
{
gfxFontUtils
:
:
GetPrefsFontList
(
"
font
.
blacklist
.
underline_offset
"
mBadUnderlineFamilyNames
)
;
for
(
auto
&
fam
:
mBadUnderlineFamilyNames
)
{
ToLowerCase
(
fam
)
;
}
mBadUnderlineFamilyNames
.
Compact
(
)
;
mBadUnderlineFamilyNames
.
Sort
(
)
;
}
void
gfxPlatformFontList
:
:
UpdateFontList
(
)
{
InitFontList
(
)
;
RebuildLocalFonts
(
)
;
}
void
gfxPlatformFontList
:
:
GetFontList
(
nsAtom
*
aLangGroup
const
nsACString
&
aGenericFamily
nsTArray
<
nsString
>
&
aListOfFonts
)
{
MutexAutoLock
lock
(
mFontFamiliesMutex
)
;
for
(
auto
iter
=
mFontFamilies
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
gfxFontFamily
>
&
family
=
iter
.
Data
(
)
;
if
(
family
-
>
FilterForFontList
(
aLangGroup
aGenericFamily
)
)
{
nsAutoCString
localizedFamilyName
;
family
-
>
LocalizedName
(
localizedFamilyName
)
;
aListOfFonts
.
AppendElement
(
NS_ConvertUTF8toUTF16
(
localizedFamilyName
)
)
;
}
}
aListOfFonts
.
Sort
(
)
;
aListOfFonts
.
Compact
(
)
;
}
void
gfxPlatformFontList
:
:
GetFontFamilyList
(
nsTArray
<
RefPtr
<
gfxFontFamily
>
>
&
aFamilyArray
)
{
for
(
auto
iter
=
mFontFamilies
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
gfxFontFamily
>
&
family
=
iter
.
Data
(
)
;
aFamilyArray
.
AppendElement
(
family
)
;
}
}
gfxFontEntry
*
gfxPlatformFontList
:
:
SystemFindFontForChar
(
uint32_t
aCh
uint32_t
aNextCh
Script
aRunScript
const
gfxFontStyle
*
aStyle
)
{
gfxFontEntry
*
fontEntry
=
nullptr
;
if
(
mCodepointsWithNoFonts
.
test
(
aCh
)
)
{
return
nullptr
;
}
if
(
aCh
=
=
0xFFFD
&
&
mReplacementCharFallbackFamily
)
{
fontEntry
=
mReplacementCharFallbackFamily
-
>
FindFontForStyle
(
*
aStyle
)
;
if
(
fontEntry
&
&
fontEntry
-
>
HasCharacter
(
aCh
)
)
{
return
fontEntry
;
}
}
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
bool
common
=
true
;
gfxFontFamily
*
fallbackFamily
=
nullptr
;
fontEntry
=
CommonFontFallback
(
aCh
aNextCh
aRunScript
aStyle
&
fallbackFamily
)
;
uint32_t
cmapCount
=
0
;
if
(
!
fontEntry
)
{
common
=
false
;
fontEntry
=
GlobalFontFallback
(
aCh
aRunScript
aStyle
cmapCount
&
fallbackFamily
)
;
}
TimeDuration
elapsed
=
TimeStamp
:
:
Now
(
)
-
start
;
LogModule
*
log
=
gfxPlatform
:
:
GetLog
(
eGfxLog_textrun
)
;
if
(
MOZ_UNLIKELY
(
MOZ_LOG_TEST
(
log
LogLevel
:
:
Warning
)
)
)
{
uint32_t
unicodeRange
=
FindCharUnicodeRange
(
aCh
)
;
Script
script
=
mozilla
:
:
unicode
:
:
GetScriptCode
(
aCh
)
;
MOZ_LOG
(
log
LogLevel
:
:
Warning
(
"
(
textrun
-
systemfallback
-
%
s
)
char
:
u
+
%
6
.
6x
"
"
unicode
-
range
:
%
d
script
:
%
d
match
:
[
%
s
]
"
"
time
:
%
dus
cmaps
:
%
d
\
n
"
(
common
?
"
common
"
:
"
global
"
)
aCh
unicodeRange
static_cast
<
int
>
(
script
)
(
fontEntry
?
fontEntry
-
>
Name
(
)
.
get
(
)
:
"
<
none
>
"
)
int32_t
(
elapsed
.
ToMicroseconds
(
)
)
cmapCount
)
)
;
}
if
(
!
fontEntry
)
{
mCodepointsWithNoFonts
.
set
(
aCh
)
;
}
else
if
(
aCh
=
=
0xFFFD
&
&
fontEntry
&
&
fallbackFamily
)
{
mReplacementCharFallbackFamily
=
fallbackFamily
;
}
static
bool
first
=
true
;
int32_t
intElapsed
=
int32_t
(
first
?
elapsed
.
ToMilliseconds
(
)
:
elapsed
.
ToMicroseconds
(
)
)
;
Telemetry
:
:
Accumulate
(
(
first
?
Telemetry
:
:
SYSTEM_FONT_FALLBACK_FIRST
:
Telemetry
:
:
SYSTEM_FONT_FALLBACK
)
intElapsed
)
;
first
=
false
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SYSTEM_FONT_FALLBACK_SCRIPT
int
(
aRunScript
)
+
1
)
;
return
fontEntry
;
}
#
define
NUM_FALLBACK_FONTS
8
gfxFontEntry
*
gfxPlatformFontList
:
:
CommonFontFallback
(
uint32_t
aCh
uint32_t
aNextCh
Script
aRunScript
const
gfxFontStyle
*
aMatchStyle
gfxFontFamily
*
*
aMatchedFamily
)
{
AutoTArray
<
const
char
*
NUM_FALLBACK_FONTS
>
defaultFallbacks
;
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetCommonFallbackFonts
(
aCh
aNextCh
aRunScript
defaultFallbacks
)
;
GlobalFontMatch
data
(
aCh
*
aMatchStyle
)
;
for
(
const
auto
name
:
defaultFallbacks
)
{
gfxFontFamily
*
fallback
=
FindFamilyByCanonicalName
(
nsDependentCString
(
name
)
)
;
if
(
fallback
)
{
fallback
-
>
FindFontForChar
(
&
data
)
;
if
(
data
.
mBestMatch
)
{
*
aMatchedFamily
=
fallback
;
return
data
.
mBestMatch
;
}
}
}
return
nullptr
;
}
gfxFontEntry
*
gfxPlatformFontList
:
:
GlobalFontFallback
(
const
uint32_t
aCh
Script
aRunScript
const
gfxFontStyle
*
aMatchStyle
uint32_t
&
aCmapCount
gfxFontFamily
*
*
aMatchedFamily
)
{
bool
useCmaps
=
IsFontFamilyWhitelistActive
(
)
|
|
gfxPlatform
:
:
GetPlatform
(
)
-
>
UseCmapsDuringSystemFallback
(
)
;
if
(
!
useCmaps
)
{
gfxFontEntry
*
fe
=
PlatformGlobalFontFallback
(
aCh
aRunScript
aMatchStyle
aMatchedFamily
)
;
if
(
fe
)
{
return
fe
;
}
}
GlobalFontMatch
data
(
aCh
*
aMatchStyle
)
;
for
(
auto
iter
=
mFontFamilies
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
gfxFontFamily
>
&
family
=
iter
.
Data
(
)
;
family
-
>
FindFontForChar
(
&
data
)
;
}
aCmapCount
=
data
.
mCmapsTested
;
*
aMatchedFamily
=
data
.
mMatchedFamily
;
return
data
.
mBestMatch
;
}
gfxFontFamily
*
gfxPlatformFontList
:
:
CheckFamily
(
gfxFontFamily
*
aFamily
)
{
if
(
aFamily
&
&
!
aFamily
-
>
HasStyles
(
)
)
{
aFamily
-
>
FindStyleVariations
(
)
;
aFamily
-
>
CheckForSimpleFamily
(
)
;
}
if
(
aFamily
&
&
aFamily
-
>
GetFontList
(
)
.
Length
(
)
=
=
0
)
{
nsAutoCString
key
;
GenerateFontListKey
(
aFamily
-
>
Name
(
)
key
)
;
mFontFamilies
.
Remove
(
key
)
;
return
nullptr
;
}
return
aFamily
;
}
bool
gfxPlatformFontList
:
:
FindAndAddFamilies
(
const
nsACString
&
aFamily
nsTArray
<
FamilyAndGeneric
>
*
aOutput
FindFamiliesFlags
aFlags
gfxFontStyle
*
aStyle
gfxFloat
aDevToCssSize
)
{
nsAutoCString
key
;
GenerateFontListKey
(
aFamily
key
)
;
NS_ASSERTION
(
mFontFamilies
.
Count
(
)
!
=
0
"
system
font
list
was
not
initialized
correctly
"
)
;
gfxFontFamily
*
familyEntry
=
mFontFamilies
.
GetWeak
(
key
)
;
if
(
!
familyEntry
)
{
familyEntry
=
mOtherFamilyNames
.
GetWeak
(
key
)
;
}
if
(
!
familyEntry
&
&
!
mOtherFamilyNamesInitialized
&
&
!
IsASCII
(
aFamily
)
)
{
InitOtherFamilyNames
(
!
(
aFlags
&
FindFamiliesFlags
:
:
eForceOtherFamilyNamesLoading
)
)
;
familyEntry
=
mOtherFamilyNames
.
GetWeak
(
key
)
;
if
(
!
familyEntry
&
&
!
mOtherFamilyNamesInitialized
&
&
!
(
aFlags
&
FindFamiliesFlags
:
:
eNoAddToNamesMissedWhenSearching
)
)
{
if
(
!
mOtherNamesMissed
)
{
mOtherNamesMissed
=
MakeUnique
<
nsTHashtable
<
nsCStringHashKey
>
>
(
2
)
;
}
mOtherNamesMissed
-
>
PutEntry
(
key
)
;
}
}
familyEntry
=
CheckFamily
(
familyEntry
)
;
if
(
!
familyEntry
&
&
!
(
aFlags
&
FindFamiliesFlags
:
:
eNoSearchForLegacyFamilyNames
)
)
{
const
char
*
data
=
aFamily
.
BeginReading
(
)
;
int32_t
index
=
aFamily
.
Length
(
)
;
while
(
-
-
index
>
0
)
{
if
(
data
[
index
]
=
=
'
'
)
{
break
;
}
}
if
(
index
>
0
)
{
gfxFontFamily
*
base
=
FindFamily
(
Substring
(
aFamily
0
index
)
FindFamiliesFlags
:
:
eNoSearchForLegacyFamilyNames
)
;
if
(
base
&
&
base
-
>
CheckForLegacyFamilyNames
(
this
)
)
{
familyEntry
=
mOtherFamilyNames
.
GetWeak
(
key
)
;
}
}
}
if
(
familyEntry
)
{
aOutput
-
>
AppendElement
(
FamilyAndGeneric
(
familyEntry
)
)
;
return
true
;
}
return
false
;
}
gfxFontEntry
*
gfxPlatformFontList
:
:
FindFontForFamily
(
const
nsACString
&
aFamily
const
gfxFontStyle
*
aStyle
)
{
gfxFontFamily
*
familyEntry
=
FindFamily
(
aFamily
)
;
if
(
familyEntry
)
return
familyEntry
-
>
FindFontForStyle
(
*
aStyle
)
;
return
nullptr
;
}
void
gfxPlatformFontList
:
:
AddOtherFamilyName
(
gfxFontFamily
*
aFamilyEntry
nsCString
&
aOtherFamilyName
)
{
nsAutoCString
key
;
GenerateFontListKey
(
aOtherFamilyName
key
)
;
if
(
!
mOtherFamilyNames
.
GetWeak
(
key
)
)
{
mOtherFamilyNames
.
Put
(
key
aFamilyEntry
)
;
LOG_FONTLIST
(
(
"
(
fontlist
-
otherfamily
)
canonical
family
:
%
s
"
"
other
family
:
%
s
\
n
"
aFamilyEntry
-
>
Name
(
)
.
get
(
)
aOtherFamilyName
.
get
(
)
)
)
;
if
(
mBadUnderlineFamilyNames
.
ContainsSorted
(
key
)
)
{
aFamilyEntry
-
>
SetBadUnderlineFamily
(
)
;
}
}
}
void
gfxPlatformFontList
:
:
AddFullname
(
gfxFontEntry
*
aFontEntry
const
nsCString
&
aFullname
)
{
if
(
!
mExtraNames
-
>
mFullnames
.
GetWeak
(
aFullname
)
)
{
mExtraNames
-
>
mFullnames
.
Put
(
aFullname
aFontEntry
)
;
LOG_FONTLIST
(
(
"
(
fontlist
-
fullname
)
name
:
%
s
fullname
:
%
s
\
n
"
aFontEntry
-
>
Name
(
)
.
get
(
)
aFullname
.
get
(
)
)
)
;
}
}
void
gfxPlatformFontList
:
:
AddPostscriptName
(
gfxFontEntry
*
aFontEntry
const
nsCString
&
aPostscriptName
)
{
if
(
!
mExtraNames
-
>
mPostscriptNames
.
GetWeak
(
aPostscriptName
)
)
{
mExtraNames
-
>
mPostscriptNames
.
Put
(
aPostscriptName
aFontEntry
)
;
LOG_FONTLIST
(
(
"
(
fontlist
-
postscript
)
name
:
%
s
psname
:
%
s
\
n
"
aFontEntry
-
>
Name
(
)
.
get
(
)
aPostscriptName
.
get
(
)
)
)
;
}
}
bool
gfxPlatformFontList
:
:
GetStandardFamilyName
(
const
nsCString
&
aFontName
nsACString
&
aFamilyName
)
{
aFamilyName
.
Truncate
(
)
;
gfxFontFamily
*
ff
=
FindFamily
(
aFontName
)
;
if
(
!
ff
)
{
return
false
;
}
aFamilyName
=
ff
-
>
Name
(
)
;
return
true
;
}
gfxFontFamily
*
gfxPlatformFontList
:
:
GetDefaultFontFamily
(
const
nsACString
&
aLangGroup
const
nsACString
&
aGenericFamily
)
{
if
(
NS_WARN_IF
(
aLangGroup
.
IsEmpty
(
)
)
|
|
NS_WARN_IF
(
aGenericFamily
.
IsEmpty
(
)
)
)
{
return
nullptr
;
}
AutoTArray
<
nsCString
4
>
names
;
gfxFontUtils
:
:
AppendPrefsFontList
(
NameListPref
(
aGenericFamily
aLangGroup
)
.
get
(
)
names
)
;
for
(
const
nsCString
&
name
:
names
)
{
gfxFontFamily
*
fontFamily
=
FindFamily
(
name
)
;
if
(
fontFamily
)
{
return
fontFamily
;
}
}
return
nullptr
;
}
gfxCharacterMap
*
gfxPlatformFontList
:
:
FindCharMap
(
gfxCharacterMap
*
aCmap
)
{
aCmap
-
>
CalcHash
(
)
;
gfxCharacterMap
*
cmap
=
AddCmap
(
aCmap
)
;
cmap
-
>
mShared
=
true
;
return
cmap
;
}
gfxCharacterMap
*
gfxPlatformFontList
:
:
AddCmap
(
const
gfxCharacterMap
*
aCharMap
)
{
CharMapHashKey
*
found
=
mSharedCmaps
.
PutEntry
(
const_cast
<
gfxCharacterMap
*
>
(
aCharMap
)
)
;
return
found
-
>
GetKey
(
)
;
}
void
gfxPlatformFontList
:
:
RemoveCmap
(
const
gfxCharacterMap
*
aCharMap
)
{
if
(
mSharedCmaps
.
Count
(
)
=
=
0
)
{
return
;
}
CharMapHashKey
*
found
=
mSharedCmaps
.
GetEntry
(
const_cast
<
gfxCharacterMap
*
>
(
aCharMap
)
)
;
if
(
found
&
&
found
-
>
GetKey
(
)
=
=
aCharMap
)
{
mSharedCmaps
.
RemoveEntry
(
found
)
;
}
}
void
gfxPlatformFontList
:
:
ResolveGenericFontNames
(
FontFamilyType
aGenericType
eFontPrefLang
aPrefLang
nsTArray
<
RefPtr
<
gfxFontFamily
>
>
*
aGenericFamilies
)
{
const
char
*
langGroupStr
=
GetPrefLangName
(
aPrefLang
)
;
const
char
*
generic
=
GetGenericName
(
aGenericType
)
;
if
(
!
generic
)
{
return
;
}
AutoTArray
<
nsCString
4
>
genericFamilies
;
gfxFontUtils
:
:
AppendPrefsFontList
(
NamePref
(
generic
langGroupStr
)
.
get
(
)
genericFamilies
)
;
gfxFontUtils
:
:
AppendPrefsFontList
(
NameListPref
(
generic
langGroupStr
)
.
get
(
)
genericFamilies
)
;
nsAtom
*
langGroup
=
GetLangGroupForPrefLang
(
aPrefLang
)
;
NS_ASSERTION
(
langGroup
"
null
lang
group
for
pref
lang
"
)
;
gfxPlatformFontList
:
:
GetFontFamiliesFromGenericFamilies
(
genericFamilies
langGroup
aGenericFamilies
)
;
#
if
0
printf
(
"
%
s
=
=
=
>
"
prefFontName
.
get
(
)
)
;
for
(
uint32_t
k
=
0
;
k
<
aGenericFamilies
-
>
Length
(
)
;
k
+
+
)
{
if
(
k
>
0
)
printf
(
"
"
)
;
printf
(
"
%
s
"
aGenericFamilies
[
k
]
-
>
Name
(
)
.
get
(
)
)
;
}
printf
(
"
\
n
"
)
;
#
endif
}
void
gfxPlatformFontList
:
:
ResolveEmojiFontNames
(
nsTArray
<
RefPtr
<
gfxFontFamily
>
>
*
aGenericFamilies
)
{
AutoTArray
<
nsCString
4
>
genericFamilies
;
nsAutoCString
prefFontListName
(
"
font
.
name
-
list
.
emoji
"
)
;
gfxFontUtils
:
:
AppendPrefsFontList
(
prefFontListName
.
get
(
)
genericFamilies
)
;
gfxPlatformFontList
:
:
GetFontFamiliesFromGenericFamilies
(
genericFamilies
nullptr
aGenericFamilies
)
;
}
void
gfxPlatformFontList
:
:
GetFontFamiliesFromGenericFamilies
(
nsTArray
<
nsCString
>
&
aGenericNameFamilies
nsAtom
*
aLangGroup
nsTArray
<
RefPtr
<
gfxFontFamily
>
>
*
aGenericFamilies
)
{
for
(
const
nsCString
&
genericFamily
:
aGenericNameFamilies
)
{
gfxFontStyle
style
;
style
.
language
=
aLangGroup
;
style
.
systemFont
=
false
;
AutoTArray
<
FamilyAndGeneric
10
>
families
;
FindAndAddFamilies
(
genericFamily
&
families
FindFamiliesFlags
(
0
)
&
style
)
;
for
(
const
FamilyAndGeneric
&
f
:
families
)
{
if
(
!
aGenericFamilies
-
>
Contains
(
f
.
mFamily
)
)
{
aGenericFamilies
-
>
AppendElement
(
f
.
mFamily
)
;
}
}
}
}
nsTArray
<
RefPtr
<
gfxFontFamily
>
>
*
gfxPlatformFontList
:
:
GetPrefFontsLangGroup
(
mozilla
:
:
FontFamilyType
aGenericType
eFontPrefLang
aPrefLang
)
{
if
(
aGenericType
=
=
eFamily_moz_fixed
)
{
aGenericType
=
eFamily_monospace
;
}
if
(
aGenericType
=
=
eFamily_moz_emoji
)
{
PrefFontList
*
prefFonts
=
mEmojiPrefFont
.
get
(
)
;
if
(
MOZ_UNLIKELY
(
!
prefFonts
)
)
{
prefFonts
=
new
PrefFontList
;
ResolveEmojiFontNames
(
prefFonts
)
;
mEmojiPrefFont
.
reset
(
prefFonts
)
;
}
return
prefFonts
;
}
PrefFontList
*
prefFonts
=
mLangGroupPrefFonts
[
aPrefLang
]
[
aGenericType
]
.
get
(
)
;
if
(
MOZ_UNLIKELY
(
!
prefFonts
)
)
{
prefFonts
=
new
PrefFontList
;
ResolveGenericFontNames
(
aGenericType
aPrefLang
prefFonts
)
;
mLangGroupPrefFonts
[
aPrefLang
]
[
aGenericType
]
.
reset
(
prefFonts
)
;
}
return
prefFonts
;
}
void
gfxPlatformFontList
:
:
AddGenericFonts
(
mozilla
:
:
FontFamilyType
aGenericType
nsAtom
*
aLanguage
nsTArray
<
FamilyAndGeneric
>
&
aFamilyList
)
{
nsAtom
*
langGroup
=
GetLangGroup
(
aLanguage
)
;
eFontPrefLang
prefLang
=
GetFontPrefLangFor
(
langGroup
)
;
nsTArray
<
RefPtr
<
gfxFontFamily
>
>
*
prefFonts
=
GetPrefFontsLangGroup
(
aGenericType
prefLang
)
;
if
(
!
prefFonts
-
>
IsEmpty
(
)
)
{
aFamilyList
.
SetCapacity
(
aFamilyList
.
Length
(
)
+
prefFonts
-
>
Length
(
)
)
;
for
(
auto
&
f
:
*
prefFonts
)
{
aFamilyList
.
AppendElement
(
FamilyAndGeneric
(
f
.
get
(
)
aGenericType
)
)
;
}
}
}
static
nsAtom
*
PrefLangToLangGroups
(
uint32_t
aIndex
)
{
static
nsAtom
*
gPrefLangToLangGroups
[
]
=
{
#
define
FONT_PREF_LANG
(
enum_id_
str_
atom_id_
)
nsGkAtoms
:
:
atom_id_
#
include
"
gfxFontPrefLangList
.
h
"
#
undef
FONT_PREF_LANG
}
;
return
aIndex
<
ArrayLength
(
gPrefLangToLangGroups
)
?
gPrefLangToLangGroups
[
aIndex
]
:
nsGkAtoms
:
:
Unicode
;
}
eFontPrefLang
gfxPlatformFontList
:
:
GetFontPrefLangFor
(
const
char
*
aLang
)
{
if
(
!
aLang
|
|
!
aLang
[
0
]
)
{
return
eFontPrefLang_Others
;
}
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
gPrefLangNames
)
;
+
+
i
)
{
if
(
!
PL_strcasecmp
(
gPrefLangNames
[
i
]
aLang
)
)
{
return
eFontPrefLang
(
i
)
;
}
}
return
eFontPrefLang_Others
;
}
eFontPrefLang
gfxPlatformFontList
:
:
GetFontPrefLangFor
(
nsAtom
*
aLang
)
{
if
(
!
aLang
)
return
eFontPrefLang_Others
;
nsAutoCString
lang
;
aLang
-
>
ToUTF8String
(
lang
)
;
return
GetFontPrefLangFor
(
lang
.
get
(
)
)
;
}
nsAtom
*
gfxPlatformFontList
:
:
GetLangGroupForPrefLang
(
eFontPrefLang
aLang
)
{
NS_ASSERTION
(
aLang
!
=
eFontPrefLang_CJKSet
"
unresolved
CJK
set
pref
lang
"
)
;
return
PrefLangToLangGroups
(
uint32_t
(
aLang
)
)
;
}
const
char
*
gfxPlatformFontList
:
:
GetPrefLangName
(
eFontPrefLang
aLang
)
{
if
(
uint32_t
(
aLang
)
<
ArrayLength
(
gPrefLangNames
)
)
{
return
gPrefLangNames
[
uint32_t
(
aLang
)
]
;
}
return
nullptr
;
}
eFontPrefLang
gfxPlatformFontList
:
:
GetFontPrefLangFor
(
uint8_t
aUnicodeRange
)
{
switch
(
aUnicodeRange
)
{
case
kRangeSetLatin
:
return
eFontPrefLang_Western
;
case
kRangeCyrillic
:
return
eFontPrefLang_Cyrillic
;
case
kRangeGreek
:
return
eFontPrefLang_Greek
;
case
kRangeHebrew
:
return
eFontPrefLang_Hebrew
;
case
kRangeArabic
:
return
eFontPrefLang_Arabic
;
case
kRangeThai
:
return
eFontPrefLang_Thai
;
case
kRangeKorean
:
return
eFontPrefLang_Korean
;
case
kRangeJapanese
:
return
eFontPrefLang_Japanese
;
case
kRangeSChinese
:
return
eFontPrefLang_ChineseCN
;
case
kRangeTChinese
:
return
eFontPrefLang_ChineseTW
;
case
kRangeDevanagari
:
return
eFontPrefLang_Devanagari
;
case
kRangeTamil
:
return
eFontPrefLang_Tamil
;
case
kRangeArmenian
:
return
eFontPrefLang_Armenian
;
case
kRangeBengali
:
return
eFontPrefLang_Bengali
;
case
kRangeCanadian
:
return
eFontPrefLang_Canadian
;
case
kRangeEthiopic
:
return
eFontPrefLang_Ethiopic
;
case
kRangeGeorgian
:
return
eFontPrefLang_Georgian
;
case
kRangeGujarati
:
return
eFontPrefLang_Gujarati
;
case
kRangeGurmukhi
:
return
eFontPrefLang_Gurmukhi
;
case
kRangeKhmer
:
return
eFontPrefLang_Khmer
;
case
kRangeMalayalam
:
return
eFontPrefLang_Malayalam
;
case
kRangeOriya
:
return
eFontPrefLang_Oriya
;
case
kRangeTelugu
:
return
eFontPrefLang_Telugu
;
case
kRangeKannada
:
return
eFontPrefLang_Kannada
;
case
kRangeSinhala
:
return
eFontPrefLang_Sinhala
;
case
kRangeTibetan
:
return
eFontPrefLang_Tibetan
;
case
kRangeSetCJK
:
return
eFontPrefLang_CJKSet
;
default
:
return
eFontPrefLang_Others
;
}
}
bool
gfxPlatformFontList
:
:
IsLangCJK
(
eFontPrefLang
aLang
)
{
switch
(
aLang
)
{
case
eFontPrefLang_Japanese
:
case
eFontPrefLang_ChineseTW
:
case
eFontPrefLang_ChineseCN
:
case
eFontPrefLang_ChineseHK
:
case
eFontPrefLang_Korean
:
case
eFontPrefLang_CJKSet
:
return
true
;
default
:
return
false
;
}
}
void
gfxPlatformFontList
:
:
GetLangPrefs
(
eFontPrefLang
aPrefLangs
[
]
uint32_t
&
aLen
eFontPrefLang
aCharLang
eFontPrefLang
aPageLang
)
{
if
(
IsLangCJK
(
aCharLang
)
)
{
AppendCJKPrefLangs
(
aPrefLangs
aLen
aCharLang
aPageLang
)
;
}
else
{
AppendPrefLang
(
aPrefLangs
aLen
aCharLang
)
;
}
AppendPrefLang
(
aPrefLangs
aLen
eFontPrefLang_Others
)
;
}
void
gfxPlatformFontList
:
:
AppendCJKPrefLangs
(
eFontPrefLang
aPrefLangs
[
]
uint32_t
&
aLen
eFontPrefLang
aCharLang
eFontPrefLang
aPageLang
)
{
if
(
IsLangCJK
(
aPageLang
)
)
{
AppendPrefLang
(
aPrefLangs
aLen
aPageLang
)
;
}
if
(
mCJKPrefLangs
.
Length
(
)
=
=
0
)
{
eFontPrefLang
tempPrefLangs
[
kMaxLenPrefLangList
]
;
uint32_t
tempLen
=
0
;
nsAutoCString
list
;
Preferences
:
:
GetLocalizedCString
(
"
intl
.
accept_languages
"
list
)
;
if
(
!
list
.
IsEmpty
(
)
)
{
const
char
kComma
=
'
'
;
const
char
*
p
*
p_end
;
list
.
BeginReading
(
p
)
;
list
.
EndReading
(
p_end
)
;
while
(
p
<
p_end
)
{
while
(
nsCRT
:
:
IsAsciiSpace
(
*
p
)
)
{
if
(
+
+
p
=
=
p_end
)
break
;
}
if
(
p
=
=
p_end
)
break
;
const
char
*
start
=
p
;
while
(
+
+
p
!
=
p_end
&
&
*
p
!
=
kComma
)
;
nsAutoCString
lang
(
Substring
(
start
p
)
)
;
lang
.
CompressWhitespace
(
false
true
)
;
eFontPrefLang
fpl
=
gfxPlatformFontList
:
:
GetFontPrefLangFor
(
lang
.
get
(
)
)
;
switch
(
fpl
)
{
case
eFontPrefLang_Japanese
:
case
eFontPrefLang_Korean
:
case
eFontPrefLang_ChineseCN
:
case
eFontPrefLang_ChineseHK
:
case
eFontPrefLang_ChineseTW
:
AppendPrefLang
(
tempPrefLangs
tempLen
fpl
)
;
break
;
default
:
break
;
}
p
+
+
;
}
}
nsAutoCString
localeStr
;
LocaleService
:
:
GetInstance
(
)
-
>
GetAppLocaleAsLangTag
(
localeStr
)
;
{
Locale
locale
(
localeStr
)
;
if
(
locale
.
GetLanguage
(
)
.
Equals
(
"
ja
"
)
)
{
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_Japanese
)
;
}
else
if
(
locale
.
GetLanguage
(
)
.
Equals
(
"
zh
"
)
)
{
if
(
locale
.
GetRegion
(
)
.
Equals
(
"
CN
"
)
)
{
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_ChineseCN
)
;
}
else
if
(
locale
.
GetRegion
(
)
.
Equals
(
"
TW
"
)
)
{
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_ChineseTW
)
;
}
else
if
(
locale
.
GetRegion
(
)
.
Equals
(
"
HK
"
)
)
{
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_ChineseHK
)
;
}
}
else
if
(
locale
.
GetLanguage
(
)
.
Equals
(
"
ko
"
)
)
{
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_Korean
)
;
}
}
AutoTArray
<
nsCString
5
>
prefLocales
;
prefLocales
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
ja
"
)
)
;
prefLocales
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
zh
-
CN
"
)
)
;
prefLocales
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
zh
-
TW
"
)
)
;
prefLocales
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
zh
-
HK
"
)
)
;
prefLocales
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
ko
"
)
)
;
AutoTArray
<
nsCString
16
>
sysLocales
;
AutoTArray
<
nsCString
16
>
negLocales
;
if
(
NS_SUCCEEDED
(
OSPreferences
:
:
GetInstance
(
)
-
>
GetSystemLocales
(
sysLocales
)
)
)
{
LocaleService
:
:
GetInstance
(
)
-
>
NegotiateLanguages
(
sysLocales
prefLocales
NS_LITERAL_CSTRING
(
"
"
)
LocaleService
:
:
kLangNegStrategyFiltering
negLocales
)
;
for
(
const
auto
&
localeStr
:
negLocales
)
{
Locale
locale
(
localeStr
)
;
if
(
locale
.
GetLanguage
(
)
.
Equals
(
"
ja
"
)
)
{
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_Japanese
)
;
}
else
if
(
locale
.
GetLanguage
(
)
.
Equals
(
"
zh
"
)
)
{
if
(
locale
.
GetRegion
(
)
.
Equals
(
"
CN
"
)
)
{
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_ChineseCN
)
;
}
else
if
(
locale
.
GetRegion
(
)
.
Equals
(
"
TW
"
)
)
{
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_ChineseTW
)
;
}
else
if
(
locale
.
GetRegion
(
)
.
Equals
(
"
HK
"
)
)
{
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_ChineseHK
)
;
}
}
else
if
(
locale
.
GetLanguage
(
)
.
Equals
(
"
ko
"
)
)
{
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_Korean
)
;
}
}
}
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_Japanese
)
;
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_Korean
)
;
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_ChineseCN
)
;
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_ChineseHK
)
;
AppendPrefLang
(
tempPrefLangs
tempLen
eFontPrefLang_ChineseTW
)
;
uint32_t
j
;
for
(
j
=
0
;
j
<
tempLen
;
j
+
+
)
{
mCJKPrefLangs
.
AppendElement
(
tempPrefLangs
[
j
]
)
;
}
}
uint32_t
i
numCJKlangs
=
mCJKPrefLangs
.
Length
(
)
;
for
(
i
=
0
;
i
<
numCJKlangs
;
i
+
+
)
{
AppendPrefLang
(
aPrefLangs
aLen
(
eFontPrefLang
)
(
mCJKPrefLangs
[
i
]
)
)
;
}
}
void
gfxPlatformFontList
:
:
AppendPrefLang
(
eFontPrefLang
aPrefLangs
[
]
uint32_t
&
aLen
eFontPrefLang
aAddLang
)
{
if
(
aLen
>
=
kMaxLenPrefLangList
)
return
;
uint32_t
i
=
0
;
while
(
i
<
aLen
&
&
aPrefLangs
[
i
]
!
=
aAddLang
)
{
i
+
+
;
}
if
(
i
=
=
aLen
)
{
aPrefLangs
[
aLen
]
=
aAddLang
;
aLen
+
+
;
}
}
mozilla
:
:
FontFamilyType
gfxPlatformFontList
:
:
GetDefaultGeneric
(
eFontPrefLang
aLang
)
{
if
(
aLang
=
=
eFontPrefLang_Emoji
)
{
return
eFamily_moz_emoji
;
}
if
(
MOZ_UNLIKELY
(
mDefaultGenericsLangGroup
.
IsEmpty
(
)
)
)
{
mDefaultGenericsLangGroup
.
AppendElements
(
ArrayLength
(
gPrefLangNames
)
)
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
gPrefLangNames
)
;
i
+
+
)
{
nsAutoCString
prefDefaultFontType
(
"
font
.
default
.
"
)
;
prefDefaultFontType
.
Append
(
GetPrefLangName
(
eFontPrefLang
(
i
)
)
)
;
nsAutoCString
serifOrSans
;
Preferences
:
:
GetCString
(
prefDefaultFontType
.
get
(
)
serifOrSans
)
;
if
(
serifOrSans
.
EqualsLiteral
(
"
sans
-
serif
"
)
)
{
mDefaultGenericsLangGroup
[
i
]
=
eFamily_sans_serif
;
}
else
{
mDefaultGenericsLangGroup
[
i
]
=
eFamily_serif
;
}
}
}
if
(
uint32_t
(
aLang
)
<
ArrayLength
(
gPrefLangNames
)
)
{
return
mDefaultGenericsLangGroup
[
uint32_t
(
aLang
)
]
;
}
return
eFamily_serif
;
}
gfxFontFamily
*
gfxPlatformFontList
:
:
GetDefaultFont
(
const
gfxFontStyle
*
aStyle
)
{
gfxFontFamily
*
family
=
GetDefaultFontForPlatform
(
aStyle
)
;
if
(
family
)
{
return
family
;
}
return
mFontFamilies
.
Iter
(
)
.
Data
(
)
;
}
void
gfxPlatformFontList
:
:
GetFontFamilyNames
(
nsTArray
<
nsCString
>
&
aFontFamilyNames
)
{
for
(
auto
iter
=
mFontFamilies
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
gfxFontFamily
>
&
family
=
iter
.
Data
(
)
;
aFontFamilyNames
.
AppendElement
(
family
-
>
Name
(
)
)
;
}
}
nsAtom
*
gfxPlatformFontList
:
:
GetLangGroup
(
nsAtom
*
aLanguage
)
{
nsAtom
*
langGroup
=
nullptr
;
if
(
aLanguage
)
{
langGroup
=
mLangService
-
>
GetLanguageGroup
(
aLanguage
)
;
}
if
(
!
langGroup
)
{
langGroup
=
nsGkAtoms
:
:
Unicode
;
}
return
langGroup
;
}
const
char
*
gfxPlatformFontList
:
:
GetGenericName
(
FontFamilyType
aGenericType
)
{
static
const
char
kGeneric_serif
[
]
=
"
serif
"
;
static
const
char
kGeneric_sans_serif
[
]
=
"
sans
-
serif
"
;
static
const
char
kGeneric_monospace
[
]
=
"
monospace
"
;
static
const
char
kGeneric_cursive
[
]
=
"
cursive
"
;
static
const
char
kGeneric_fantasy
[
]
=
"
fantasy
"
;
NS_ASSERTION
(
aGenericType
>
=
eFamily_serif
&
&
aGenericType
<
=
eFamily_fantasy
"
standard
generic
font
family
type
required
"
)
;
const
char
*
generic
=
nullptr
;
switch
(
aGenericType
)
{
case
eFamily_serif
:
generic
=
kGeneric_serif
;
break
;
case
eFamily_sans_serif
:
generic
=
kGeneric_sans_serif
;
break
;
case
eFamily_monospace
:
generic
=
kGeneric_monospace
;
break
;
case
eFamily_cursive
:
generic
=
kGeneric_cursive
;
break
;
case
eFamily_fantasy
:
generic
=
kGeneric_fantasy
;
break
;
default
:
break
;
}
return
generic
;
}
void
gfxPlatformFontList
:
:
InitLoader
(
)
{
GetFontFamilyNames
(
mFontInfo
-
>
mFontFamiliesToLoad
)
;
mStartIndex
=
0
;
mNumFamilies
=
mFontInfo
-
>
mFontFamiliesToLoad
.
Length
(
)
;
memset
(
&
(
mFontInfo
-
>
mLoadStats
)
0
sizeof
(
mFontInfo
-
>
mLoadStats
)
)
;
}
#
define
FONT_LOADER_MAX_TIMESLICE
\
100
/
/
max
time
for
one
pass
through
RunLoader
=
100ms
bool
gfxPlatformFontList
:
:
LoadFontInfo
(
)
{
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
uint32_t
i
endIndex
=
mNumFamilies
;
bool
loadCmaps
=
!
UsesSystemFallback
(
)
|
|
gfxPlatform
:
:
GetPlatform
(
)
-
>
UseCmapsDuringSystemFallback
(
)
;
for
(
i
=
mStartIndex
;
i
<
endIndex
;
i
+
+
)
{
nsAutoCString
key
;
gfxFontFamily
*
familyEntry
;
GenerateFontListKey
(
mFontInfo
-
>
mFontFamiliesToLoad
[
i
]
key
)
;
if
(
!
(
familyEntry
=
mFontFamilies
.
GetWeak
(
key
)
)
)
{
continue
;
}
familyEntry
-
>
ReadFaceNames
(
this
NeedFullnamePostscriptNames
(
)
mFontInfo
)
;
if
(
loadCmaps
)
{
familyEntry
-
>
ReadAllCMAPs
(
mFontInfo
)
;
}
TimeDuration
elapsed
=
TimeStamp
:
:
Now
(
)
-
start
;
if
(
elapsed
.
ToMilliseconds
(
)
>
FONT_LOADER_MAX_TIMESLICE
&
&
i
+
1
!
=
endIndex
)
{
endIndex
=
i
+
1
;
break
;
}
}
mStartIndex
=
endIndex
;
bool
done
=
mStartIndex
>
=
mNumFamilies
;
if
(
LOG_FONTINIT_ENABLED
(
)
)
{
TimeDuration
elapsed
=
TimeStamp
:
:
Now
(
)
-
start
;
LOG_FONTINIT
(
(
"
(
fontinit
)
fontloader
load
pass
%
8
.
2f
ms
done
%
s
\
n
"
elapsed
.
ToMilliseconds
(
)
(
done
?
"
true
"
:
"
false
"
)
)
)
;
}
if
(
done
)
{
mOtherFamilyNamesInitialized
=
true
;
CancelInitOtherFamilyNamesTask
(
)
;
mFaceNameListsInitialized
=
true
;
}
return
done
;
}
void
gfxPlatformFontList
:
:
CleanupLoader
(
)
{
mFontFamiliesToLoad
.
Clear
(
)
;
mNumFamilies
=
0
;
bool
rebuilt
=
false
forceReflow
=
false
;
if
(
mFaceNamesMissed
)
{
for
(
auto
it
=
mFaceNamesMissed
-
>
Iter
(
)
;
!
it
.
Done
(
)
;
it
.
Next
(
)
)
{
if
(
FindFaceName
(
it
.
Get
(
)
-
>
GetKey
(
)
)
)
{
rebuilt
=
true
;
RebuildLocalFonts
(
)
;
break
;
}
}
mFaceNamesMissed
=
nullptr
;
}
if
(
mOtherNamesMissed
)
{
for
(
auto
it
=
mOtherNamesMissed
-
>
Iter
(
)
;
!
it
.
Done
(
)
;
it
.
Next
(
)
)
{
if
(
FindFamily
(
it
.
Get
(
)
-
>
GetKey
(
)
(
FindFamiliesFlags
:
:
eForceOtherFamilyNamesLoading
|
FindFamiliesFlags
:
:
eNoAddToNamesMissedWhenSearching
)
)
)
{
forceReflow
=
true
;
ForceGlobalReflow
(
)
;
break
;
}
}
mOtherNamesMissed
=
nullptr
;
}
if
(
LOG_FONTINIT_ENABLED
(
)
&
&
mFontInfo
)
{
LOG_FONTINIT
(
(
"
(
fontinit
)
fontloader
load
thread
took
%
8
.
2f
ms
"
"
%
d
families
%
d
fonts
%
d
cmaps
"
"
%
d
facenames
%
d
othernames
%
s
%
s
"
mLoadTime
.
ToMilliseconds
(
)
mFontInfo
-
>
mLoadStats
.
families
mFontInfo
-
>
mLoadStats
.
fonts
mFontInfo
-
>
mLoadStats
.
cmaps
mFontInfo
-
>
mLoadStats
.
facenames
mFontInfo
-
>
mLoadStats
.
othernames
(
rebuilt
?
"
(
userfont
sets
rebuilt
)
"
:
"
"
)
(
forceReflow
?
"
(
global
reflow
)
"
:
"
"
)
)
)
;
}
gfxFontInfoLoader
:
:
CleanupLoader
(
)
;
}
void
gfxPlatformFontList
:
:
GetPrefsAndStartLoader
(
)
{
uint32_t
delay
=
std
:
:
max
(
1u
Preferences
:
:
GetUint
(
FONT_LOADER_DELAY_PREF
)
)
;
uint32_t
interval
=
std
:
:
max
(
1u
Preferences
:
:
GetUint
(
FONT_LOADER_INTERVAL_PREF
)
)
;
StartLoader
(
delay
interval
)
;
}
void
gfxPlatformFontList
:
:
RebuildLocalFonts
(
)
{
for
(
auto
it
=
mUserFontSetList
.
Iter
(
)
;
!
it
.
Done
(
)
;
it
.
Next
(
)
)
{
it
.
Get
(
)
-
>
GetKey
(
)
-
>
RebuildLocalRules
(
)
;
}
}
void
gfxPlatformFontList
:
:
ClearLangGroupPrefFonts
(
)
{
for
(
uint32_t
i
=
eFontPrefLang_First
;
i
<
eFontPrefLang_First
+
eFontPrefLang_Count
;
i
+
+
)
{
auto
&
prefFontsLangGroup
=
mLangGroupPrefFonts
[
i
]
;
for
(
uint32_t
j
=
eFamily_generic_first
;
j
<
eFamily_generic_first
+
eFamily_generic_count
;
j
+
+
)
{
prefFontsLangGroup
[
j
]
=
nullptr
;
}
}
mCJKPrefLangs
.
Clear
(
)
;
mEmojiPrefFont
=
nullptr
;
}
size_t
gfxPlatformFontList
:
:
SizeOfFontFamilyTableExcludingThis
(
const
FontFamilyTable
&
aTable
MallocSizeOf
aMallocSizeOf
)
{
size_t
n
=
aTable
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
aTable
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
n
+
=
iter
.
Key
(
)
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
return
n
;
}
size_t
gfxPlatformFontList
:
:
SizeOfFontEntryTableExcludingThis
(
const
FontEntryTable
&
aTable
MallocSizeOf
aMallocSizeOf
)
{
size_t
n
=
aTable
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
aTable
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
n
+
=
iter
.
Key
(
)
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
return
n
;
}
void
gfxPlatformFontList
:
:
AddSizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
FontListSizes
*
aSizes
)
const
{
aSizes
-
>
mFontListSize
+
=
mFontFamilies
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
mFontFamilies
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
aSizes
-
>
mFontListSize
+
=
iter
.
Key
(
)
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
iter
.
Data
(
)
-
>
AddSizeOfIncludingThis
(
aMallocSizeOf
aSizes
)
;
}
aSizes
-
>
mFontListSize
+
=
SizeOfFontFamilyTableExcludingThis
(
mOtherFamilyNames
aMallocSizeOf
)
;
if
(
mExtraNames
)
{
aSizes
-
>
mFontListSize
+
=
SizeOfFontEntryTableExcludingThis
(
mExtraNames
-
>
mFullnames
aMallocSizeOf
)
;
aSizes
-
>
mFontListSize
+
=
SizeOfFontEntryTableExcludingThis
(
mExtraNames
-
>
mPostscriptNames
aMallocSizeOf
)
;
}
for
(
uint32_t
i
=
eFontPrefLang_First
;
i
<
eFontPrefLang_First
+
eFontPrefLang_Count
;
i
+
+
)
{
auto
&
prefFontsLangGroup
=
mLangGroupPrefFonts
[
i
]
;
for
(
uint32_t
j
=
eFamily_generic_first
;
j
<
eFamily_generic_first
+
eFamily_generic_count
;
j
+
+
)
{
PrefFontList
*
pf
=
prefFontsLangGroup
[
j
]
.
get
(
)
;
if
(
pf
)
{
aSizes
-
>
mFontListSize
+
=
pf
-
>
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
}
}
aSizes
-
>
mFontListSize
+
=
mCodepointsWithNoFonts
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
aSizes
-
>
mFontListSize
+
=
mFontFamiliesToLoad
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
aSizes
-
>
mFontListSize
+
=
mBadUnderlineFamilyNames
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
const
auto
&
i
:
mBadUnderlineFamilyNames
)
{
aSizes
-
>
mFontListSize
+
=
i
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
aSizes
-
>
mFontListSize
+
=
mSharedCmaps
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
mSharedCmaps
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
aSizes
-
>
mCharMapsSize
+
=
iter
.
Get
(
)
-
>
GetKey
(
)
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
}
void
gfxPlatformFontList
:
:
AddSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
FontListSizes
*
aSizes
)
const
{
aSizes
-
>
mFontListSize
+
=
aMallocSizeOf
(
this
)
;
AddSizeOfExcludingThis
(
aMallocSizeOf
aSizes
)
;
}
bool
gfxPlatformFontList
:
:
IsFontFamilyWhitelistActive
(
)
{
return
mFontFamilyWhitelistActive
;
}
void
gfxPlatformFontList
:
:
InitOtherFamilyNamesInternal
(
bool
aDeferOtherFamilyNamesLoading
)
{
if
(
mOtherFamilyNamesInitialized
)
{
return
;
}
if
(
aDeferOtherFamilyNamesLoading
)
{
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
bool
timedOut
=
false
;
for
(
auto
iter
=
mFontFamilies
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
gfxFontFamily
>
&
family
=
iter
.
Data
(
)
;
family
-
>
ReadOtherFamilyNames
(
this
)
;
TimeDuration
elapsed
=
TimeStamp
:
:
Now
(
)
-
start
;
if
(
elapsed
.
ToMilliseconds
(
)
>
OTHERNAMES_TIMEOUT
)
{
timedOut
=
true
;
break
;
}
}
if
(
!
timedOut
)
{
mOtherFamilyNamesInitialized
=
true
;
CancelInitOtherFamilyNamesTask
(
)
;
}
TimeStamp
end
=
TimeStamp
:
:
Now
(
)
;
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
FONTLIST_INITOTHERFAMILYNAMES
start
end
)
;
if
(
LOG_FONTINIT_ENABLED
(
)
)
{
TimeDuration
elapsed
=
end
-
start
;
LOG_FONTINIT
(
(
"
(
fontinit
)
InitOtherFamilyNames
took
%
8
.
2f
ms
%
s
"
elapsed
.
ToMilliseconds
(
)
(
timedOut
?
"
timeout
"
:
"
"
)
)
)
;
}
}
else
{
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
for
(
auto
iter
=
mFontFamilies
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
gfxFontFamily
>
&
family
=
iter
.
Data
(
)
;
family
-
>
ReadOtherFamilyNames
(
this
)
;
}
mOtherFamilyNamesInitialized
=
true
;
CancelInitOtherFamilyNamesTask
(
)
;
TimeStamp
end
=
TimeStamp
:
:
Now
(
)
;
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
FONTLIST_INITOTHERFAMILYNAMES_NO_DEFERRING
start
end
)
;
if
(
LOG_FONTINIT_ENABLED
(
)
)
{
TimeDuration
elapsed
=
end
-
start
;
LOG_FONTINIT
(
(
"
(
fontinit
)
InitOtherFamilyNames
without
deferring
took
%
8
.
2f
ms
"
elapsed
.
ToMilliseconds
(
)
)
)
;
}
}
}
void
gfxPlatformFontList
:
:
CancelInitOtherFamilyNamesTask
(
)
{
if
(
mPendingOtherFamilyNameTask
)
{
mPendingOtherFamilyNameTask
-
>
Cancel
(
)
;
mPendingOtherFamilyNameTask
=
nullptr
;
}
}
#
undef
LOG
#
undef
LOG_ENABLED
