#
include
"
gfxGradientCache
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
PLDHashTable
.
h
"
#
include
"
nsExpirationTracker
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
<
time
.
h
>
namespace
mozilla
{
namespace
gfx
{
using
namespace
mozilla
;
struct
GradientCacheKey
:
public
PLDHashEntryHdr
{
typedef
const
GradientCacheKey
&
KeyType
;
typedef
const
GradientCacheKey
*
KeyTypePointer
;
enum
{
ALLOW_MEMMOVE
=
true
}
;
const
CopyableTArray
<
GradientStop
>
mStops
;
ExtendMode
mExtend
;
BackendType
mBackendType
;
GradientCacheKey
(
const
nsTArray
<
GradientStop
>
&
aStops
ExtendMode
aExtend
BackendType
aBackendType
)
:
mStops
(
aStops
)
mExtend
(
aExtend
)
mBackendType
(
aBackendType
)
{
}
explicit
GradientCacheKey
(
const
GradientCacheKey
*
aOther
)
:
mStops
(
aOther
-
>
mStops
)
mExtend
(
aOther
-
>
mExtend
)
mBackendType
(
aOther
-
>
mBackendType
)
{
}
GradientCacheKey
(
GradientCacheKey
&
&
aOther
)
=
default
;
union
FloatUint32
{
float
f
;
uint32_t
u
;
}
;
static
PLDHashNumber
HashKey
(
const
KeyTypePointer
aKey
)
{
PLDHashNumber
hash
=
0
;
FloatUint32
convert
;
hash
=
AddToHash
(
hash
int
(
aKey
-
>
mBackendType
)
)
;
hash
=
AddToHash
(
hash
int
(
aKey
-
>
mExtend
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aKey
-
>
mStops
.
Length
(
)
;
i
+
+
)
{
hash
=
AddToHash
(
hash
aKey
-
>
mStops
[
i
]
.
color
.
ToABGR
(
)
)
;
convert
.
f
=
aKey
-
>
mStops
[
i
]
.
offset
;
hash
=
AddToHash
(
hash
convert
.
f
?
convert
.
u
:
0
)
;
}
return
hash
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
bool
sameStops
=
true
;
if
(
aKey
-
>
mStops
.
Length
(
)
!
=
mStops
.
Length
(
)
)
{
sameStops
=
false
;
}
else
{
for
(
uint32_t
i
=
0
;
i
<
mStops
.
Length
(
)
;
i
+
+
)
{
if
(
mStops
[
i
]
.
color
.
ToABGR
(
)
!
=
aKey
-
>
mStops
[
i
]
.
color
.
ToABGR
(
)
|
|
mStops
[
i
]
.
offset
!
=
aKey
-
>
mStops
[
i
]
.
offset
)
{
sameStops
=
false
;
break
;
}
}
}
return
sameStops
&
&
(
aKey
-
>
mBackendType
=
=
mBackendType
)
&
&
(
aKey
-
>
mExtend
=
=
mExtend
)
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
&
aKey
;
}
}
;
struct
GradientCacheData
{
GradientCacheData
(
GradientStops
*
aStops
GradientCacheKey
&
&
aKey
)
:
mStops
(
aStops
)
mKey
(
std
:
:
move
(
aKey
)
)
{
}
GradientCacheData
(
GradientCacheData
&
&
aOther
)
=
default
;
nsExpirationState
*
GetExpirationState
(
)
{
return
&
mExpirationState
;
}
nsExpirationState
mExpirationState
;
const
RefPtr
<
GradientStops
>
mStops
;
GradientCacheKey
mKey
;
}
;
class
GradientCache
;
using
GradientCacheMutex
=
StaticDataMutex
<
UniquePtr
<
GradientCache
>
>
;
class
MOZ_RAII
LockedInstance
{
public
:
explicit
LockedInstance
(
GradientCacheMutex
&
aDataMutex
)
:
mAutoLock
(
aDataMutex
.
Lock
(
)
)
{
}
UniquePtr
<
GradientCache
>
&
operator
-
>
(
)
const
&
{
return
mAutoLock
.
ref
(
)
;
}
UniquePtr
<
GradientCache
>
&
operator
-
>
(
)
const
&
&
=
delete
;
UniquePtr
<
GradientCache
>
&
operator
*
(
)
const
&
{
return
mAutoLock
.
ref
(
)
;
}
UniquePtr
<
GradientCache
>
&
operator
*
(
)
const
&
&
=
delete
;
explicit
operator
bool
(
)
const
{
return
!
!
mAutoLock
.
ref
(
)
;
}
private
:
GradientCacheMutex
:
:
AutoLock
mAutoLock
;
}
;
class
GradientCache
final
:
public
ExpirationTrackerImpl
<
GradientCacheData
4
GradientCacheMutex
LockedInstance
>
{
public
:
GradientCache
(
)
:
ExpirationTrackerImpl
<
GradientCacheData
4
GradientCacheMutex
LockedInstance
>
(
MAX_GENERATION_MS
"
GradientCache
"
)
{
}
static
bool
EnsureInstance
(
)
{
LockedInstance
lockedInstance
(
sInstanceMutex
)
;
return
EnsureInstanceLocked
(
lockedInstance
)
;
}
static
void
DestroyInstance
(
)
{
LockedInstance
lockedInstance
(
sInstanceMutex
)
;
if
(
lockedInstance
)
{
*
lockedInstance
=
nullptr
;
}
}
static
void
AgeAllGenerations
(
)
{
LockedInstance
lockedInstance
(
sInstanceMutex
)
;
if
(
!
lockedInstance
)
{
return
;
}
lockedInstance
-
>
AgeAllGenerationsLocked
(
lockedInstance
)
;
lockedInstance
-
>
NotifyHandlerEndLocked
(
lockedInstance
)
;
}
template
<
typename
CreateFunc
>
static
already_AddRefed
<
GradientStops
>
LookupOrInsert
(
const
GradientCacheKey
&
aKey
CreateFunc
aCreateFunc
)
{
uint32_t
numberOfEntries
;
RefPtr
<
GradientStops
>
stops
;
{
LockedInstance
lockedInstance
(
sInstanceMutex
)
;
if
(
!
EnsureInstanceLocked
(
lockedInstance
)
)
{
return
aCreateFunc
(
)
;
}
GradientCacheData
*
gradientData
=
lockedInstance
-
>
mHashEntries
.
Get
(
aKey
)
;
if
(
gradientData
)
{
if
(
gradientData
-
>
mStops
&
&
gradientData
-
>
mStops
-
>
IsValid
(
)
)
{
lockedInstance
-
>
MarkUsedLocked
(
gradientData
lockedInstance
)
;
return
do_AddRef
(
gradientData
-
>
mStops
)
;
}
lockedInstance
-
>
NotifyExpiredLocked
(
gradientData
lockedInstance
)
;
lockedInstance
-
>
NotifyHandlerEndLocked
(
lockedInstance
)
;
}
stops
=
aCreateFunc
(
)
;
if
(
!
stops
)
{
return
nullptr
;
}
auto
data
=
MakeUnique
<
GradientCacheData
>
(
stops
GradientCacheKey
(
&
aKey
)
)
;
nsresult
rv
=
lockedInstance
-
>
AddObjectLocked
(
data
.
get
(
)
lockedInstance
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
stops
.
forget
(
)
;
}
lockedInstance
-
>
mHashEntries
.
InsertOrUpdate
(
aKey
std
:
:
move
(
data
)
)
;
numberOfEntries
=
lockedInstance
-
>
mHashEntries
.
Count
(
)
;
}
if
(
numberOfEntries
>
MAX_ENTRIES
)
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
GradientCache
:
:
OnMaxEntriesBreached
"
[
]
{
LockedInstance
lockedInstance
(
sInstanceMutex
)
;
if
(
!
lockedInstance
)
{
return
;
}
lockedInstance
-
>
AgeOneGenerationLocked
(
lockedInstance
)
;
lockedInstance
-
>
NotifyHandlerEndLocked
(
lockedInstance
)
;
}
)
)
;
}
return
stops
.
forget
(
)
;
}
GradientCacheMutex
&
GetMutex
(
)
final
{
return
sInstanceMutex
;
}
void
NotifyExpiredLocked
(
GradientCacheData
*
aObject
const
LockedInstance
&
aLockedInstance
)
final
{
RemoveObjectLocked
(
aObject
aLockedInstance
)
;
Maybe
<
UniquePtr
<
GradientCacheData
>
>
gradientData
=
mHashEntries
.
Extract
(
aObject
-
>
mKey
)
;
if
(
gradientData
.
isSome
(
)
)
{
mRemovedGradientData
.
AppendElement
(
std
:
:
move
(
*
gradientData
)
)
;
}
}
void
NotifyHandlerEndLocked
(
const
LockedInstance
&
)
final
{
NS_DispatchToCurrentThread
(
NS_NewRunnableFunction
(
"
GradientCache
:
:
DestroyRemovedGradientStops
"
[
stops
=
std
:
:
move
(
mRemovedGradientData
)
]
{
}
)
)
;
}
private
:
static
const
uint32_t
MAX_GENERATION_MS
=
10000
;
static
const
uint32_t
MAX_ENTRIES
=
4000
;
static
GradientCacheMutex
sInstanceMutex
;
[
[
nodiscard
]
]
static
bool
EnsureInstanceLocked
(
LockedInstance
&
aLockedInstance
)
{
if
(
!
aLockedInstance
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
false
;
}
*
aLockedInstance
=
MakeUnique
<
GradientCache
>
(
)
;
}
return
true
;
}
nsClassHashtable
<
GradientCacheKey
GradientCacheData
>
mHashEntries
;
nsTArray
<
UniquePtr
<
GradientCacheData
>
>
mRemovedGradientData
;
}
;
GradientCacheMutex
GradientCache
:
:
sInstanceMutex
(
"
GradientCache
"
)
;
void
gfxGradientCache
:
:
Init
(
)
{
MOZ_RELEASE_ASSERT
(
GradientCache
:
:
EnsureInstance
(
)
"
First
call
must
be
on
main
thread
.
"
)
;
}
already_AddRefed
<
GradientStops
>
gfxGradientCache
:
:
GetOrCreateGradientStops
(
const
DrawTarget
*
aDT
nsTArray
<
GradientStop
>
&
aStops
ExtendMode
aExtend
)
{
if
(
aDT
-
>
IsRecording
(
)
)
{
return
aDT
-
>
CreateGradientStops
(
aStops
.
Elements
(
)
aStops
.
Length
(
)
aExtend
)
;
}
return
GradientCache
:
:
LookupOrInsert
(
GradientCacheKey
(
aStops
aExtend
aDT
-
>
GetBackendType
(
)
)
[
&
]
(
)
-
>
already_AddRefed
<
GradientStops
>
{
return
aDT
-
>
CreateGradientStops
(
aStops
.
Elements
(
)
aStops
.
Length
(
)
aExtend
)
;
}
)
;
}
void
gfxGradientCache
:
:
PurgeAllCaches
(
)
{
GradientCache
:
:
AgeAllGenerations
(
)
;
}
void
gfxGradientCache
:
:
Shutdown
(
)
{
GradientCache
:
:
DestroyInstance
(
)
;
}
}
}
