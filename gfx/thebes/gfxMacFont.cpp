#
include
"
gfxMacFont
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
gfxCoreTextShaper
.
h
"
#
include
<
algorithm
>
#
include
"
gfxPlatformMac
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxFontUtils
.
h
"
#
include
"
gfxHarfBuzzShaper
.
h
"
#
include
"
gfxMacPlatformFontList
.
h
"
#
include
"
gfxFontConstants
.
h
"
#
include
"
gfxTextRun
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
nsCocoaFeatures
.
h
"
#
include
"
AppleUtils
.
h
"
#
include
"
cairo
-
quartz
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
template
<
class
T
>
struct
TagEquals
{
bool
Equals
(
const
T
&
aIter
uint32_t
aTag
)
const
{
return
aIter
.
mTag
=
=
aTag
;
}
}
;
gfxMacFont
:
:
gfxMacFont
(
const
RefPtr
<
UnscaledFontMac
>
&
aUnscaledFont
MacOSFontEntry
*
aFontEntry
const
gfxFontStyle
*
aFontStyle
)
:
gfxFont
(
aUnscaledFont
aFontEntry
aFontStyle
)
mCGFont
(
nullptr
)
mCTFont
(
nullptr
)
mFontSmoothingBackgroundColor
(
aFontStyle
-
>
fontSmoothingBackgroundColor
)
mVariationFont
(
aFontEntry
-
>
HasVariations
(
)
)
{
mApplySyntheticBold
=
aFontStyle
-
>
NeedsSyntheticBold
(
aFontEntry
)
;
if
(
mVariationFont
)
{
CGFontRef
baseFont
=
aUnscaledFont
-
>
GetFont
(
)
;
if
(
!
baseFont
)
{
mIsValid
=
false
;
return
;
}
AutoTArray
<
gfxFontVariation
4
>
vars
;
aFontEntry
-
>
GetVariationsForStyle
(
vars
*
aFontStyle
)
;
if
(
aFontEntry
-
>
HasOpticalSize
(
)
)
{
const
uint32_t
kOpszTag
=
HB_TAG
(
'
o
'
'
p
'
'
s
'
'
z
'
)
;
const
float
kOpszFudgeAmount
=
0
.
01f
;
if
(
!
aFontEntry
-
>
mOpszAxis
.
mTag
)
{
AutoTArray
<
gfxFontVariationAxis
4
>
axes
;
aFontEntry
-
>
GetVariationAxes
(
axes
)
;
auto
index
=
axes
.
IndexOf
(
kOpszTag
0
TagEquals
<
gfxFontVariationAxis
>
(
)
)
;
MOZ_ASSERT
(
index
!
=
axes
.
NoIndex
)
;
if
(
index
!
=
axes
.
NoIndex
)
{
const
auto
&
axis
=
axes
[
index
]
;
aFontEntry
-
>
mOpszAxis
=
axis
;
aFontEntry
-
>
mAdjustedDefaultOpsz
=
axis
.
mDefaultValue
=
=
axis
.
mMinValue
?
axis
.
mDefaultValue
+
kOpszFudgeAmount
:
axis
.
mDefaultValue
-
kOpszFudgeAmount
;
}
}
auto
index
=
vars
.
IndexOf
(
kOpszTag
0
TagEquals
<
gfxFontVariation
>
(
)
)
;
if
(
index
=
=
vars
.
NoIndex
)
{
vars
.
AppendElement
(
gfxFontVariation
{
kOpszTag
aFontEntry
-
>
mAdjustedDefaultOpsz
}
)
;
}
else
{
auto
&
value
=
vars
[
index
]
.
mValue
;
auto
&
axis
=
aFontEntry
-
>
mOpszAxis
;
value
=
fmin
(
fmax
(
value
axis
.
mMinValue
)
axis
.
mMaxValue
)
;
if
(
std
:
:
abs
(
value
-
axis
.
mDefaultValue
)
<
kOpszFudgeAmount
)
{
value
=
aFontEntry
-
>
mAdjustedDefaultOpsz
;
}
}
}
mCGFont
=
UnscaledFontMac
:
:
CreateCGFontWithVariations
(
baseFont
aUnscaledFont
-
>
CGAxesCache
(
)
aUnscaledFont
-
>
CTAxesCache
(
)
vars
.
Length
(
)
vars
.
Elements
(
)
)
;
if
(
!
mCGFont
)
{
:
:
CFRetain
(
baseFont
)
;
mCGFont
=
baseFont
;
}
}
else
{
mCGFont
=
aUnscaledFont
-
>
GetFont
(
)
;
if
(
!
mCGFont
)
{
mIsValid
=
false
;
return
;
}
:
:
CFRetain
(
mCGFont
)
;
}
InitMetrics
(
)
;
if
(
!
mIsValid
)
{
return
;
}
if
(
mAdjustedSize
<
=
(
gfxFloat
)
gfxPlatformMac
:
:
GetPlatform
(
)
-
>
GetAntiAliasingThreshold
(
)
)
{
mAntialiasOption
=
kAntialiasNone
;
}
else
if
(
mStyle
.
useGrayscaleAntialiasing
)
{
mAntialiasOption
=
kAntialiasGrayscale
;
}
}
gfxMacFont
:
:
~
gfxMacFont
(
)
{
if
(
mCGFont
)
{
:
:
CFRelease
(
mCGFont
)
;
}
if
(
mCTFont
)
{
:
:
CFRelease
(
mCTFont
)
;
}
}
bool
gfxMacFont
:
:
ShapeText
(
DrawTarget
*
aDrawTarget
const
char16_t
*
aText
uint32_t
aOffset
uint32_t
aLength
Script
aScript
nsAtom
*
aLanguage
bool
aVertical
RoundingFlags
aRounding
gfxShapedText
*
aShapedText
)
{
if
(
!
mIsValid
)
{
NS_WARNING
(
"
invalid
font
!
expect
incorrect
text
rendering
"
)
;
return
false
;
}
auto
macFontEntry
=
static_cast
<
MacOSFontEntry
*
>
(
GetFontEntry
(
)
)
;
if
(
macFontEntry
-
>
RequiresAATLayout
(
)
&
&
!
aVertical
&
&
StaticPrefs
:
:
gfx_font_rendering_coretext_enabled
(
)
)
{
if
(
!
mCoreTextShaper
)
{
mCoreTextShaper
=
MakeUnique
<
gfxCoreTextShaper
>
(
this
)
;
}
if
(
mCoreTextShaper
-
>
ShapeText
(
aDrawTarget
aText
aOffset
aLength
aScript
aLanguage
aVertical
aRounding
aShapedText
)
)
{
PostShapingFixup
(
aDrawTarget
aText
aOffset
aLength
aVertical
aShapedText
)
;
if
(
GetFontEntry
(
)
-
>
HasTrackingTable
(
)
)
{
float
trackSize
=
GetAdjustedSize
(
)
*
aShapedText
-
>
GetAppUnitsPerDevUnit
(
)
/
AppUnitsPerCSSPixel
(
)
;
float
tracking
=
GetFontEntry
(
)
-
>
TrackingForCSSPx
(
trackSize
)
*
mFUnitsConvFactor
;
aShapedText
-
>
AdjustAdvancesForSyntheticBold
(
tracking
aOffset
aLength
)
;
}
return
true
;
}
}
return
gfxFont
:
:
ShapeText
(
aDrawTarget
aText
aOffset
aLength
aScript
aLanguage
aVertical
aRounding
aShapedText
)
;
}
gfxFont
:
:
RunMetrics
gfxMacFont
:
:
Measure
(
const
gfxTextRun
*
aTextRun
uint32_t
aStart
uint32_t
aEnd
BoundingBoxType
aBoundingBoxType
DrawTarget
*
aRefDrawTarget
Spacing
*
aSpacing
gfx
:
:
ShapedTextFlags
aOrientation
)
{
gfxFont
:
:
RunMetrics
metrics
=
gfxFont
:
:
Measure
(
aTextRun
aStart
aEnd
aBoundingBoxType
aRefDrawTarget
aSpacing
aOrientation
)
;
if
(
aBoundingBoxType
!
=
TIGHT_HINTED_OUTLINE_EXTENTS
&
&
metrics
.
mBoundingBox
.
width
>
0
)
{
metrics
.
mBoundingBox
.
x
-
=
aTextRun
-
>
GetAppUnitsPerDevUnit
(
)
;
metrics
.
mBoundingBox
.
width
+
=
aTextRun
-
>
GetAppUnitsPerDevUnit
(
)
*
2
;
}
return
metrics
;
}
void
gfxMacFont
:
:
InitMetrics
(
)
{
mIsValid
=
false
;
:
:
memset
(
&
mMetrics
0
sizeof
(
mMetrics
)
)
;
uint32_t
upem
=
0
;
AutoCFRelease
<
CFDataRef
>
headData
=
:
:
CGFontCopyTableForTag
(
mCGFont
TRUETYPE_TAG
(
'
h
'
'
e
'
'
a
'
'
d
'
)
)
;
if
(
headData
)
{
if
(
size_t
(
:
:
CFDataGetLength
(
headData
)
)
>
=
sizeof
(
HeadTable
)
)
{
const
HeadTable
*
head
=
reinterpret_cast
<
const
HeadTable
*
>
(
:
:
CFDataGetBytePtr
(
headData
)
)
;
upem
=
head
-
>
unitsPerEm
;
}
}
if
(
!
upem
)
{
upem
=
:
:
CGFontGetUnitsPerEm
(
mCGFont
)
;
}
if
(
upem
<
16
|
|
upem
>
16384
)
{
#
ifdef
DEBUG
char
warnBuf
[
1024
]
;
SprintfLiteral
(
warnBuf
"
Bad
font
metrics
for
:
%
s
(
invalid
unitsPerEm
value
)
"
mFontEntry
-
>
Name
(
)
.
get
(
)
)
;
NS_WARNING
(
warnBuf
)
;
#
endif
return
;
}
mAdjustedSize
=
GetAdjustedSize
(
)
;
mFUnitsConvFactor
=
mAdjustedSize
/
upem
;
gfxFloat
cgConvFactor
;
if
(
static_cast
<
MacOSFontEntry
*
>
(
mFontEntry
.
get
(
)
)
-
>
IsCFF
(
)
)
{
cgConvFactor
=
mAdjustedSize
/
:
:
CGFontGetUnitsPerEm
(
mCGFont
)
;
}
else
{
cgConvFactor
=
mFUnitsConvFactor
;
}
if
(
!
InitMetricsFromSfntTables
(
mMetrics
)
&
&
(
!
mFontEntry
-
>
IsUserFont
(
)
|
|
mFontEntry
-
>
IsLocalUserFont
(
)
)
)
{
InitMetricsFromPlatform
(
)
;
}
if
(
!
mIsValid
)
{
return
;
}
if
(
mMetrics
.
xHeight
=
=
0
.
0
)
{
mMetrics
.
xHeight
=
:
:
CGFontGetXHeight
(
mCGFont
)
*
cgConvFactor
;
}
if
(
mMetrics
.
capHeight
=
=
0
.
0
)
{
mMetrics
.
capHeight
=
:
:
CGFontGetCapHeight
(
mCGFont
)
*
cgConvFactor
;
}
AutoCFRelease
<
CFDataRef
>
cmap
=
:
:
CGFontCopyTableForTag
(
mCGFont
TRUETYPE_TAG
(
'
c
'
'
m
'
'
a
'
'
p
'
)
)
;
uint32_t
glyphID
;
mMetrics
.
zeroWidth
=
GetCharWidth
(
cmap
'
0
'
&
glyphID
cgConvFactor
)
;
if
(
glyphID
=
=
0
)
{
mMetrics
.
zeroWidth
=
-
1
.
0
;
}
if
(
FontSizeAdjust
:
:
Tag
(
mStyle
.
sizeAdjustBasis
)
!
=
FontSizeAdjust
:
:
Tag
:
:
None
&
&
mStyle
.
sizeAdjust
>
=
0
.
0
&
&
GetAdjustedSize
(
)
>
0
.
0
)
{
gfxFloat
aspect
;
switch
(
FontSizeAdjust
:
:
Tag
(
mStyle
.
sizeAdjustBasis
)
)
{
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unhandled
sizeAdjustBasis
?
"
)
;
aspect
=
0
.
0
;
break
;
case
FontSizeAdjust
:
:
Tag
:
:
ExHeight
:
aspect
=
mMetrics
.
xHeight
/
mAdjustedSize
;
break
;
case
FontSizeAdjust
:
:
Tag
:
:
CapHeight
:
aspect
=
mMetrics
.
capHeight
/
mAdjustedSize
;
break
;
case
FontSizeAdjust
:
:
Tag
:
:
ChWidth
:
aspect
=
mMetrics
.
zeroWidth
<
0
.
0
?
0
.
5
:
mMetrics
.
zeroWidth
/
mAdjustedSize
;
break
;
case
FontSizeAdjust
:
:
Tag
:
:
IcWidth
:
case
FontSizeAdjust
:
:
Tag
:
:
IcHeight
:
{
bool
vertical
=
FontSizeAdjust
:
:
Tag
(
mStyle
.
sizeAdjustBasis
)
=
=
FontSizeAdjust
:
:
Tag
:
:
IcHeight
;
gfxFloat
advance
=
GetCharAdvance
(
kWaterIdeograph
vertical
)
;
aspect
=
advance
>
0
.
0
?
advance
/
mAdjustedSize
:
1
.
0
;
break
;
}
}
if
(
aspect
>
0
.
0
)
{
delete
mHarfBuzzShaper
.
exchange
(
nullptr
)
;
mAdjustedSize
=
mStyle
.
GetAdjustedSize
(
aspect
)
;
mFUnitsConvFactor
=
mAdjustedSize
/
upem
;
if
(
static_cast
<
MacOSFontEntry
*
>
(
mFontEntry
.
get
(
)
)
-
>
IsCFF
(
)
)
{
cgConvFactor
=
mAdjustedSize
/
:
:
CGFontGetUnitsPerEm
(
mCGFont
)
;
}
else
{
cgConvFactor
=
mFUnitsConvFactor
;
}
mMetrics
.
xHeight
=
0
.
0
;
if
(
!
InitMetricsFromSfntTables
(
mMetrics
)
&
&
(
!
mFontEntry
-
>
IsUserFont
(
)
|
|
mFontEntry
-
>
IsLocalUserFont
(
)
)
)
{
InitMetricsFromPlatform
(
)
;
}
if
(
!
mIsValid
)
{
return
;
}
if
(
mMetrics
.
xHeight
=
=
0
.
0
)
{
mMetrics
.
xHeight
=
:
:
CGFontGetXHeight
(
mCGFont
)
*
cgConvFactor
;
}
if
(
mMetrics
.
capHeight
=
=
0
.
0
)
{
mMetrics
.
capHeight
=
:
:
CGFontGetCapHeight
(
mCGFont
)
*
cgConvFactor
;
}
mMetrics
.
zeroWidth
=
GetCharWidth
(
cmap
'
0
'
&
glyphID
cgConvFactor
)
;
if
(
glyphID
=
=
0
)
{
mMetrics
.
zeroWidth
=
-
1
.
0
;
}
}
}
mMetrics
.
emHeight
=
mAdjustedSize
;
if
(
mMetrics
.
aveCharWidth
<
=
0
)
{
mMetrics
.
aveCharWidth
=
GetCharWidth
(
cmap
'
x
'
&
glyphID
cgConvFactor
)
;
if
(
glyphID
=
=
0
)
{
mMetrics
.
aveCharWidth
=
mMetrics
.
maxAdvance
;
}
}
mMetrics
.
spaceWidth
=
GetCharWidth
(
cmap
'
'
&
glyphID
cgConvFactor
)
;
if
(
glyphID
=
=
0
)
{
mMetrics
.
spaceWidth
=
mMetrics
.
aveCharWidth
;
}
mSpaceGlyph
=
glyphID
;
mMetrics
.
ideographicWidth
=
GetCharWidth
(
cmap
kWaterIdeograph
&
glyphID
cgConvFactor
)
;
if
(
glyphID
=
=
0
)
{
mMetrics
.
ideographicWidth
=
-
1
.
0
;
}
CalculateDerivedMetrics
(
mMetrics
)
;
SanitizeMetrics
(
&
mMetrics
mFontEntry
-
>
mIsBadUnderlineFont
)
;
if
(
ApplySyntheticBold
(
)
)
{
auto
delta
=
GetSyntheticBoldOffset
(
)
;
mMetrics
.
spaceWidth
+
=
delta
;
mMetrics
.
aveCharWidth
+
=
delta
;
mMetrics
.
maxAdvance
+
=
delta
;
if
(
mMetrics
.
zeroWidth
>
0
)
{
mMetrics
.
zeroWidth
+
=
delta
;
}
if
(
mMetrics
.
ideographicWidth
>
0
)
{
mMetrics
.
ideographicWidth
+
=
delta
;
}
}
#
if
0
fprintf
(
stderr
"
Font
:
%
p
(
%
s
)
size
:
%
f
\
n
"
this
NS_ConvertUTF16toUTF8
(
GetName
(
)
)
.
get
(
)
mStyle
.
size
)
;
fprintf
(
stderr
"
emHeight
:
%
f
emAscent
:
%
f
emDescent
:
%
f
\
n
"
mMetrics
.
emHeight
mMetrics
.
emAscent
mMetrics
.
emDescent
)
;
fprintf
(
stderr
"
maxAscent
:
%
f
maxDescent
:
%
f
maxAdvance
:
%
f
\
n
"
mMetrics
.
maxAscent
mMetrics
.
maxDescent
mMetrics
.
maxAdvance
)
;
fprintf
(
stderr
"
internalLeading
:
%
f
externalLeading
:
%
f
\
n
"
mMetrics
.
internalLeading
mMetrics
.
externalLeading
)
;
fprintf
(
stderr
"
spaceWidth
:
%
f
aveCharWidth
:
%
f
xHeight
:
%
f
capHeight
:
%
f
\
n
"
mMetrics
.
spaceWidth
mMetrics
.
aveCharWidth
mMetrics
.
xHeight
mMetrics
.
capHeight
)
;
fprintf
(
stderr
"
uOff
:
%
f
uSize
:
%
f
stOff
:
%
f
stSize
:
%
f
\
n
"
mMetrics
.
underlineOffset
mMetrics
.
underlineSize
mMetrics
.
strikeoutOffset
mMetrics
.
strikeoutSize
)
;
#
endif
}
gfxFloat
gfxMacFont
:
:
GetCharWidth
(
CFDataRef
aCmap
char16_t
aUniChar
uint32_t
*
aGlyphID
gfxFloat
aConvFactor
)
{
CGGlyph
glyph
=
0
;
if
(
aCmap
)
{
glyph
=
gfxFontUtils
:
:
MapCharToGlyph
(
:
:
CFDataGetBytePtr
(
aCmap
)
:
:
CFDataGetLength
(
aCmap
)
aUniChar
)
;
}
if
(
aGlyphID
)
{
*
aGlyphID
=
glyph
;
}
if
(
glyph
)
{
int
advance
;
if
(
:
:
CGFontGetGlyphAdvances
(
mCGFont
&
glyph
1
&
advance
)
)
{
return
advance
*
aConvFactor
;
}
}
return
0
;
}
CTFontRef
gfxMacFont
:
:
CreateCTFontFromCGFontWithVariations
(
CGFontRef
aCGFont
CGFloat
aSize
bool
aInstalledFont
CTFontDescriptorRef
aFontDesc
)
{
CTFontRef
ctFont
;
if
(
nsCocoaFeatures
:
:
OnSierraExactly
(
)
|
|
(
aInstalledFont
&
&
nsCocoaFeatures
:
:
OnHighSierraOrLater
(
)
)
)
{
AutoCFRelease
<
CFDictionaryRef
>
variations
=
:
:
CGFontCopyVariations
(
aCGFont
)
;
if
(
variations
)
{
AutoCFRelease
<
CFDictionaryRef
>
varAttr
=
:
:
CFDictionaryCreate
(
nullptr
(
const
void
*
*
)
&
kCTFontVariationAttribute
(
const
void
*
*
)
&
variations
1
&
kCFTypeDictionaryKeyCallBacks
&
kCFTypeDictionaryValueCallBacks
)
;
AutoCFRelease
<
CTFontDescriptorRef
>
varDesc
=
aFontDesc
?
:
:
CTFontDescriptorCreateCopyWithAttributes
(
aFontDesc
varAttr
)
:
:
:
CTFontDescriptorCreateWithAttributes
(
varAttr
)
;
ctFont
=
:
:
CTFontCreateWithGraphicsFont
(
aCGFont
aSize
nullptr
varDesc
)
;
}
else
{
ctFont
=
:
:
CTFontCreateWithGraphicsFont
(
aCGFont
aSize
nullptr
aFontDesc
)
;
}
}
else
{
ctFont
=
:
:
CTFontCreateWithGraphicsFont
(
aCGFont
aSize
nullptr
aFontDesc
)
;
}
return
ctFont
;
}
int32_t
gfxMacFont
:
:
GetGlyphWidth
(
uint16_t
aGID
)
{
if
(
mVariationFont
)
{
int
cgAdvance
;
if
(
:
:
CGFontGetGlyphAdvances
(
mCGFont
&
aGID
1
&
cgAdvance
)
)
{
return
cgAdvance
*
mFUnitsConvFactor
*
0x10000
;
}
}
if
(
!
mCTFont
)
{
bool
isInstalledFont
=
!
mFontEntry
-
>
IsUserFont
(
)
|
|
mFontEntry
-
>
IsLocalUserFont
(
)
;
mCTFont
=
CreateCTFontFromCGFontWithVariations
(
mCGFont
mAdjustedSize
isInstalledFont
)
;
if
(
!
mCTFont
)
{
NS_WARNING
(
"
failed
to
create
CTFontRef
to
measure
glyph
width
"
)
;
return
0
;
}
}
CGSize
advance
;
:
:
CTFontGetAdvancesForGlyphs
(
mCTFont
kCTFontOrientationDefault
&
aGID
&
advance
1
)
;
return
advance
.
width
*
0x10000
;
}
bool
gfxMacFont
:
:
GetGlyphBounds
(
uint16_t
aGID
gfxRect
*
aBounds
bool
aTight
)
const
{
CGRect
bb
;
if
(
!
:
:
CGFontGetGlyphBBoxes
(
mCGFont
&
aGID
1
&
bb
)
)
{
return
false
;
}
if
(
bb
.
origin
.
x
=
=
-
32767
&
&
bb
.
origin
.
y
=
=
-
32767
&
&
bb
.
size
.
width
=
=
65534
&
&
bb
.
size
.
height
=
=
65534
)
{
*
aBounds
=
gfxRect
(
0
0
0
0
)
;
return
true
;
}
gfxRect
bounds
(
bb
.
origin
.
x
-
(
bb
.
origin
.
y
+
bb
.
size
.
height
)
bb
.
size
.
width
bb
.
size
.
height
)
;
bounds
.
Scale
(
mFUnitsConvFactor
)
;
*
aBounds
=
bounds
;
return
true
;
}
void
gfxMacFont
:
:
InitMetricsFromPlatform
(
)
{
AutoCFRelease
<
CTFontRef
>
ctFont
=
:
:
CTFontCreateWithGraphicsFont
(
mCGFont
mAdjustedSize
nullptr
nullptr
)
;
if
(
!
ctFont
)
{
return
;
}
mMetrics
.
underlineOffset
=
:
:
CTFontGetUnderlinePosition
(
ctFont
)
;
mMetrics
.
underlineSize
=
:
:
CTFontGetUnderlineThickness
(
ctFont
)
;
mMetrics
.
externalLeading
=
:
:
CTFontGetLeading
(
ctFont
)
;
mMetrics
.
maxAscent
=
:
:
CTFontGetAscent
(
ctFont
)
;
mMetrics
.
maxDescent
=
:
:
CTFontGetDescent
(
ctFont
)
;
CGRect
r
=
:
:
CTFontGetBoundingBox
(
ctFont
)
;
mMetrics
.
maxAdvance
=
r
.
size
.
width
;
mMetrics
.
aveCharWidth
=
0
;
mMetrics
.
xHeight
=
:
:
CTFontGetXHeight
(
ctFont
)
;
mMetrics
.
capHeight
=
:
:
CTFontGetCapHeight
(
ctFont
)
;
mIsValid
=
true
;
}
already_AddRefed
<
ScaledFont
>
gfxMacFont
:
:
GetScaledFont
(
const
TextRunDrawParams
&
aRunParams
)
{
if
(
ScaledFont
*
scaledFont
=
mAzureScaledFont
)
{
return
do_AddRef
(
scaledFont
)
;
}
gfxFontEntry
*
fe
=
GetFontEntry
(
)
;
bool
hasColorGlyphs
=
fe
-
>
HasColorBitmapTable
(
)
|
|
fe
-
>
TryGetColorGlyphs
(
)
;
RefPtr
<
ScaledFont
>
newScaledFont
=
Factory
:
:
CreateScaledFontForMacFont
(
GetCGFontRef
(
)
GetUnscaledFont
(
)
GetAdjustedSize
(
)
ToDeviceColor
(
mFontSmoothingBackgroundColor
)
!
mStyle
.
useGrayscaleAntialiasing
ApplySyntheticBold
(
)
hasColorGlyphs
)
;
if
(
!
newScaledFont
)
{
return
nullptr
;
}
InitializeScaledFont
(
newScaledFont
)
;
if
(
mAzureScaledFont
.
compareExchange
(
nullptr
newScaledFont
.
get
(
)
)
)
{
Unused
<
<
newScaledFont
.
forget
(
)
;
}
ScaledFont
*
scaledFont
=
mAzureScaledFont
;
return
do_AddRef
(
scaledFont
)
;
}
bool
gfxMacFont
:
:
ShouldRoundXOffset
(
cairo_t
*
aCairo
)
const
{
return
aCairo
&
&
cairo_surface_get_type
(
cairo_get_target
(
aCairo
)
)
!
=
CAIRO_SURFACE_TYPE_QUARTZ
;
}
void
gfxMacFont
:
:
AddSizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
FontCacheSizes
*
aSizes
)
const
{
gfxFont
:
:
AddSizeOfExcludingThis
(
aMallocSizeOf
aSizes
)
;
}
void
gfxMacFont
:
:
AddSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
FontCacheSizes
*
aSizes
)
const
{
aSizes
-
>
mFontInstances
+
=
aMallocSizeOf
(
this
)
;
AddSizeOfExcludingThis
(
aMallocSizeOf
aSizes
)
;
}
