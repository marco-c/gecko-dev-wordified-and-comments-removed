#
ifndef
SharedFontList_impl_h
#
define
SharedFontList_impl_h
#
include
"
SharedFontList
.
h
"
#
include
"
base
/
shared_memory
.
h
"
#
include
"
gfxFontUtils
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
namespace
mozilla
{
namespace
fontlist
{
struct
AliasData
{
nsTArray
<
Pointer
>
mFaces
;
nsCString
mBaseFamily
;
uint32_t
mIndex
=
0
;
FontVisibility
mVisibility
=
FontVisibility
:
:
Unknown
;
bool
mBundled
=
false
;
bool
mBadUnderline
=
false
;
bool
mForceClassic
=
false
;
void
InitFromFamily
(
const
Family
*
aFamily
const
nsCString
&
aBaseFamily
)
{
mBaseFamily
=
aBaseFamily
;
mIndex
=
aFamily
-
>
Index
(
)
;
mVisibility
=
aFamily
-
>
Visibility
(
)
;
mBundled
=
aFamily
-
>
IsBundled
(
)
;
mBadUnderline
=
aFamily
-
>
IsBadUnderlineFamily
(
)
;
mForceClassic
=
aFamily
-
>
IsForceClassic
(
)
;
}
}
;
class
FontList
{
public
:
friend
struct
Pointer
;
explicit
FontList
(
uint32_t
aGeneration
)
;
~
FontList
(
)
;
void
SetFamilyNames
(
nsTArray
<
Family
:
:
InitData
>
&
aFamilies
)
;
void
SetAliases
(
nsClassHashtable
<
nsCStringHashKey
AliasData
>
&
aAliasTable
)
;
void
SetLocalNames
(
nsDataHashtable
<
nsCStringHashKey
LocalFaceRec
:
:
InitData
>
&
aLocalNameTable
)
;
Family
*
FindFamily
(
const
nsCString
&
aName
)
;
LocalFaceRec
*
FindLocalFace
(
const
nsCString
&
aName
)
;
void
SearchForLocalFace
(
const
nsACString
&
aName
Family
*
*
aFamily
Face
*
*
aFace
)
;
nsCString
LocalizedFamilyName
(
const
Family
*
aFamily
)
;
bool
Initialized
(
)
{
return
mBlocks
.
Length
(
)
>
0
&
&
NumFamilies
(
)
>
0
;
}
uint32_t
NumFamilies
(
)
{
return
GetHeader
(
)
.
mFamilyCount
;
}
Family
*
Families
(
)
{
return
static_cast
<
Family
*
>
(
GetHeader
(
)
.
mFamilies
.
ToPtr
(
this
)
)
;
}
uint32_t
NumAliases
(
)
{
return
GetHeader
(
)
.
mAliasCount
;
}
Family
*
AliasFamilies
(
)
{
return
static_cast
<
Family
*
>
(
GetHeader
(
)
.
mAliases
.
ToPtr
(
this
)
)
;
}
uint32_t
NumLocalFaces
(
)
{
return
GetHeader
(
)
.
mLocalFaceCount
;
}
LocalFaceRec
*
LocalFaces
(
)
{
return
static_cast
<
LocalFaceRec
*
>
(
GetHeader
(
)
.
mLocalFaces
.
ToPtr
(
this
)
)
;
}
void
LoadCharMapFor
(
Face
&
aFace
const
Family
*
aFamily
)
;
Pointer
Alloc
(
uint32_t
aSize
)
;
Pointer
ToSharedPointer
(
const
void
*
aPtr
)
;
uint32_t
GetGeneration
(
)
{
return
GetHeader
(
)
.
mGeneration
;
}
struct
BlockHeader
{
uint32_t
mAllocated
;
uint32_t
mBlockSize
;
}
;
struct
Header
{
BlockHeader
mBlockHeader
;
uint32_t
mGeneration
;
uint32_t
mFamilyCount
;
std
:
:
atomic
<
uint32_t
>
mBlockCount
;
std
:
:
atomic
<
uint32_t
>
mAliasCount
;
std
:
:
atomic
<
uint32_t
>
mLocalFaceCount
;
Pointer
mFamilies
;
Pointer
mAliases
;
Pointer
mLocalFaces
;
}
;
void
ShareShmBlockToProcess
(
uint32_t
aIndex
base
:
:
ProcessId
aPid
base
:
:
SharedMemoryHandle
*
aOut
)
{
MOZ_RELEASE_ASSERT
(
mReadOnlyShmems
.
Length
(
)
=
=
mBlocks
.
Length
(
)
)
;
if
(
aIndex
>
=
mReadOnlyShmems
.
Length
(
)
)
{
*
aOut
=
base
:
:
SharedMemory
:
:
NULLHandle
(
)
;
}
if
(
!
mReadOnlyShmems
[
aIndex
]
-
>
ShareToProcess
(
aPid
aOut
)
)
{
MOZ_CRASH
(
"
failed
to
share
block
"
)
;
}
}
void
ShareBlocksToProcess
(
nsTArray
<
base
:
:
SharedMemoryHandle
>
*
aBlocks
base
:
:
ProcessId
aPid
)
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
size_t
AllocatedShmemSize
(
)
const
;
#
if
ANDROID
static
constexpr
uint32_t
SHM_BLOCK_SIZE
=
64
*
1024
;
#
else
static
constexpr
uint32_t
SHM_BLOCK_SIZE
=
256
*
1024
;
#
endif
static_assert
(
SHM_BLOCK_SIZE
<
=
(
1
<
<
Pointer
:
:
kBlockShift
)
"
SHM_BLOCK_SIZE
too
large
"
)
;
private
:
struct
ShmBlock
{
explicit
ShmBlock
(
mozilla
:
:
UniquePtr
<
base
:
:
SharedMemory
>
&
&
aShmem
)
:
mShmem
(
std
:
:
move
(
aShmem
)
)
{
}
void
*
Memory
(
)
const
{
return
mShmem
-
>
memory
(
)
;
}
uint32_t
&
Allocated
(
)
const
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
return
static_cast
<
BlockHeader
*
>
(
Memory
(
)
)
-
>
mAllocated
;
}
uint32_t
&
BlockSize
(
)
const
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
return
static_cast
<
BlockHeader
*
>
(
Memory
(
)
)
-
>
mBlockSize
;
}
mozilla
:
:
UniquePtr
<
base
:
:
SharedMemory
>
mShmem
;
}
;
Header
&
GetHeader
(
)
{
MOZ_ASSERT
(
mBlocks
.
Length
(
)
>
0
)
;
return
*
static_cast
<
Header
*
>
(
Pointer
(
0
0
)
.
ToPtr
(
this
)
)
;
}
bool
AppendShmBlock
(
uint32_t
aSizeNeeded
)
;
[
[
nodiscard
]
]
bool
UpdateShmBlocks
(
)
;
ShmBlock
*
GetBlockFromParent
(
uint32_t
aIndex
)
;
void
DetachShmBlocks
(
)
;
nsTArray
<
mozilla
:
:
UniquePtr
<
ShmBlock
>
>
mBlocks
;
nsTArray
<
mozilla
:
:
UniquePtr
<
base
:
:
SharedMemory
>
>
mReadOnlyShmems
;
}
;
}
}
#
endif
