#
ifndef
SharedFontList_impl_h
#
define
SharedFontList_impl_h
#
include
"
SharedFontList
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemoryBasic
.
h
"
#
include
"
gfxFontUtils
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsDataHashtable
.
h
"
namespace
mozilla
{
namespace
fontlist
{
struct
AliasData
{
nsTArray
<
Pointer
>
mFaces
;
uint32_t
mIndex
=
0
;
FontVisibility
mVisibility
=
FontVisibility
:
:
Unknown
;
bool
mBundled
=
false
;
bool
mBadUnderline
=
false
;
bool
mForceClassic
=
false
;
void
InitFromFamily
(
const
Family
*
aFamily
)
{
mIndex
=
aFamily
-
>
Index
(
)
;
mVisibility
=
aFamily
-
>
Visibility
(
)
;
mBundled
=
aFamily
-
>
IsBundled
(
)
;
mBadUnderline
=
aFamily
-
>
IsBadUnderlineFamily
(
)
;
mForceClassic
=
aFamily
-
>
IsForceClassic
(
)
;
}
}
;
class
FontList
{
public
:
friend
struct
Pointer
;
explicit
FontList
(
uint32_t
aGeneration
)
;
~
FontList
(
)
;
void
SetFamilyNames
(
const
nsTArray
<
Family
:
:
InitData
>
&
aFamilies
)
;
void
SetAliases
(
nsClassHashtable
<
nsCStringHashKey
AliasData
>
&
aAliasTable
)
;
void
SetLocalNames
(
nsDataHashtable
<
nsCStringHashKey
LocalFaceRec
:
:
InitData
>
&
aLocalNameTable
)
;
Family
*
FindFamily
(
const
nsCString
&
aName
bool
aAllowHidden
=
false
)
;
LocalFaceRec
*
FindLocalFace
(
const
nsCString
&
aName
)
;
void
SearchForLocalFace
(
const
nsACString
&
aName
Family
*
*
aFamily
Face
*
*
aFace
)
;
bool
Initialized
(
)
{
return
mBlocks
.
Length
(
)
>
0
&
&
NumFamilies
(
)
>
0
;
}
uint32_t
NumFamilies
(
)
{
return
GetHeader
(
)
.
mFamilyCount
;
}
Family
*
Families
(
)
{
return
static_cast
<
Family
*
>
(
GetHeader
(
)
.
mFamilies
.
ToPtr
(
this
)
)
;
}
uint32_t
NumAliases
(
)
{
return
GetHeader
(
)
.
mAliasCount
;
}
Family
*
AliasFamilies
(
)
{
return
static_cast
<
Family
*
>
(
GetHeader
(
)
.
mAliases
.
ToPtr
(
this
)
)
;
}
uint32_t
NumLocalFaces
(
)
{
return
GetHeader
(
)
.
mLocalFaceCount
;
}
LocalFaceRec
*
LocalFaces
(
)
{
return
static_cast
<
LocalFaceRec
*
>
(
GetHeader
(
)
.
mLocalFaces
.
ToPtr
(
this
)
)
;
}
void
LoadCharMapFor
(
Face
&
aFace
const
Family
*
aFamily
)
;
Pointer
Alloc
(
uint32_t
aSize
)
;
Pointer
ToSharedPointer
(
const
void
*
aPtr
)
;
uint32_t
GetGeneration
(
)
{
return
GetHeader
(
)
.
mGeneration
;
}
struct
Header
{
std
:
:
atomic
<
uint32_t
>
mAllocated
;
uint32_t
mGeneration
;
uint32_t
mFamilyCount
;
std
:
:
atomic
<
uint32_t
>
mBlockCount
;
std
:
:
atomic
<
uint32_t
>
mAliasCount
;
std
:
:
atomic
<
uint32_t
>
mLocalFaceCount
;
Pointer
mFamilies
;
Pointer
mAliases
;
Pointer
mLocalFaces
;
}
;
void
ShareShmBlockToProcess
(
uint32_t
aIndex
base
:
:
ProcessId
aPid
mozilla
:
:
ipc
:
:
SharedMemoryBasic
:
:
Handle
*
aOut
)
{
if
(
aIndex
>
=
mBlocks
.
Length
(
)
)
{
*
aOut
=
mozilla
:
:
ipc
:
:
SharedMemoryBasic
:
:
NULLHandle
(
)
;
}
if
(
!
mBlocks
[
aIndex
]
-
>
mShmem
-
>
ShareToProcess
(
aPid
aOut
)
)
{
MOZ_CRASH
(
"
failed
to
share
block
"
)
;
}
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
result
=
mBlocks
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
const
auto
&
b
:
mBlocks
)
{
result
+
=
aMallocSizeOf
(
b
.
get
(
)
)
+
aMallocSizeOf
(
b
-
>
mShmem
)
;
}
return
result
;
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
size_t
AllocatedShmemSize
(
)
const
{
return
mBlocks
.
Length
(
)
*
SHM_BLOCK_SIZE
;
}
static
const
size_t
SHM_BLOCK_SIZE
=
256
*
1024
;
static_assert
(
SHM_BLOCK_SIZE
<
=
(
1
<
<
Pointer
:
:
kBlockShift
)
"
SHM_BLOCK_SIZE
too
large
"
)
;
static_assert
(
SHM_BLOCK_SIZE
>
=
SharedBitSet
:
:
kMaxSize
+
4
"
SHM_BLOCK_SIZE
too
small
"
)
;
private
:
struct
ShmBlock
{
ShmBlock
(
mozilla
:
:
ipc
:
:
SharedMemoryBasic
*
aShmem
void
*
aAddr
)
:
mShmem
(
aShmem
)
mAddr
(
aAddr
)
{
}
std
:
:
atomic
<
uint32_t
>
&
Allocated
(
)
const
{
return
*
static_cast
<
std
:
:
atomic
<
uint32_t
>
*
>
(
mAddr
)
;
}
RefPtr
<
mozilla
:
:
ipc
:
:
SharedMemoryBasic
>
mShmem
;
void
*
mAddr
;
}
;
Header
&
GetHeader
(
)
{
MOZ_ASSERT
(
mBlocks
.
Length
(
)
>
0
)
;
return
*
static_cast
<
Header
*
>
(
Pointer
(
0
0
)
.
ToPtr
(
this
)
)
;
}
bool
AppendShmBlock
(
)
;
[
[
nodiscard
]
]
bool
UpdateShmBlocks
(
)
;
ShmBlock
*
GetBlockFromParent
(
uint32_t
aIndex
)
;
void
DetachShmBlocks
(
)
;
nsTArray
<
mozilla
:
:
UniquePtr
<
ShmBlock
>
>
mBlocks
;
}
;
}
}
#
endif
