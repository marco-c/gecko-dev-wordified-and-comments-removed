#
ifndef
GFX_FT2FONTBASE_H
#
define
GFX_FT2FONTBASE_H
#
include
"
gfxContext
.
h
"
#
include
"
gfxFont
.
h
"
#
include
"
gfxFontEntry
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
UnscaledFontFreeType
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsHashKeys
.
h
"
class
gfxFT2FontEntryBase
:
public
gfxFontEntry
{
public
:
explicit
gfxFT2FontEntryBase
(
const
nsACString
&
aName
)
:
gfxFontEntry
(
aName
)
{
}
struct
CmapCacheSlot
{
CmapCacheSlot
(
)
:
mCharCode
(
0
)
mGlyphIndex
(
0
)
{
}
uint32_t
mCharCode
;
uint32_t
mGlyphIndex
;
}
;
CmapCacheSlot
*
GetCmapCacheSlot
(
uint32_t
aCharCode
)
;
static
bool
FaceHasTable
(
mozilla
:
:
gfx
:
:
SharedFTFace
*
uint32_t
aTableTag
)
;
static
nsresult
CopyFaceTable
(
mozilla
:
:
gfx
:
:
SharedFTFace
*
uint32_t
aTableTag
nsTArray
<
uint8_t
>
&
)
;
private
:
enum
{
kNumCmapCacheSlots
=
256
}
;
mozilla
:
:
UniquePtr
<
CmapCacheSlot
[
]
>
mCmapCache
;
}
;
class
gfxFT2FontBase
:
public
gfxFont
{
public
:
gfxFT2FontBase
(
const
RefPtr
<
mozilla
:
:
gfx
:
:
UnscaledFontFreeType
>
&
aUnscaledFont
RefPtr
<
mozilla
:
:
gfx
:
:
SharedFTFace
>
&
&
aFTFace
gfxFontEntry
*
aFontEntry
const
gfxFontStyle
*
aFontStyle
int
aLoadFlags
bool
aEmbolden
)
;
virtual
~
gfxFT2FontBase
(
)
;
uint32_t
GetGlyph
(
uint32_t
aCharCode
)
;
bool
ProvidesGetGlyph
(
)
const
override
{
return
true
;
}
virtual
uint32_t
GetGlyph
(
uint32_t
unicode
uint32_t
variation_selector
)
override
;
bool
ProvidesGlyphWidths
(
)
const
override
{
return
true
;
}
int32_t
GetGlyphWidth
(
uint16_t
aGID
)
override
;
bool
GetGlyphBounds
(
uint16_t
aGID
gfxRect
*
aBounds
bool
aTight
)
override
;
FontType
GetType
(
)
const
override
{
return
FONT_TYPE_FT2
;
}
bool
ShouldRoundXOffset
(
cairo_t
*
aCairo
)
const
override
;
static
void
SetupVarCoords
(
FT_MM_Var
*
aMMVar
const
nsTArray
<
gfxFontVariation
>
&
aVariations
FT_Face
aFTFace
)
;
FT_Face
LockFTFace
(
)
;
void
UnlockFTFace
(
)
;
private
:
uint32_t
GetCharExtents
(
uint32_t
aChar
gfxFloat
*
aWidth
gfxRect
*
aBounds
=
nullptr
)
;
bool
GetFTGlyphExtents
(
uint16_t
aGID
int32_t
*
aWidth
mozilla
:
:
gfx
:
:
IntRect
*
aBounds
=
nullptr
)
;
protected
:
void
InitMetrics
(
)
;
const
Metrics
&
GetHorizontalMetrics
(
)
override
;
FT_Vector
GetEmboldenStrength
(
FT_Face
aFace
)
;
RefPtr
<
mozilla
:
:
gfx
:
:
SharedFTFace
>
mFTFace
;
Metrics
mMetrics
;
int
mFTLoadFlags
;
bool
mEmbolden
;
gfxFloat
mFTSize
;
nsTArray
<
FT_Fixed
>
mCoords
;
struct
GlyphMetrics
{
enum
{
INVALID
=
INT16_MIN
LARGE
=
INT16_MAX
}
;
GlyphMetrics
(
)
:
mAdvance
(
0
)
mX
(
INVALID
)
mY
(
0
)
mWidth
(
0
)
mHeight
(
0
)
{
}
bool
HasValidBounds
(
)
const
{
return
mX
!
=
INVALID
;
}
bool
HasCachedBounds
(
)
const
{
return
mX
!
=
LARGE
;
}
void
SetBounds
(
const
mozilla
:
:
gfx
:
:
IntRect
&
aBounds
)
{
if
(
aBounds
.
x
>
INT16_MIN
&
&
aBounds
.
x
<
INT16_MAX
&
&
aBounds
.
y
>
INT16_MIN
&
&
aBounds
.
y
<
INT16_MAX
&
&
aBounds
.
width
<
=
UINT16_MAX
&
&
aBounds
.
height
<
=
UINT16_MAX
)
{
mX
=
aBounds
.
x
;
mY
=
aBounds
.
y
;
mWidth
=
aBounds
.
width
;
mHeight
=
aBounds
.
height
;
}
else
{
mX
=
LARGE
;
}
}
mozilla
:
:
gfx
:
:
IntRect
GetBounds
(
)
const
{
return
mozilla
:
:
gfx
:
:
IntRect
(
mX
mY
mWidth
mHeight
)
;
}
int32_t
mAdvance
;
int16_t
mX
;
int16_t
mY
;
uint16_t
mWidth
;
uint16_t
mHeight
;
}
;
const
GlyphMetrics
&
GetCachedGlyphMetrics
(
uint16_t
aGID
mozilla
:
:
gfx
:
:
IntRect
*
aBounds
=
nullptr
)
;
mozilla
:
:
UniquePtr
<
nsTHashMap
<
nsUint32HashKey
GlyphMetrics
>
>
mGlyphMetrics
;
}
;
class
FTUserFontData
final
:
public
mozilla
:
:
gfx
:
:
SharedFTFaceRefCountedData
<
FTUserFontData
>
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
FTUserFontData
)
FTUserFontData
(
const
uint8_t
*
aData
uint32_t
aLength
)
:
mFontData
(
aData
)
mLength
(
aLength
)
{
}
const
uint8_t
*
FontData
(
)
const
{
return
mFontData
;
}
already_AddRefed
<
mozilla
:
:
gfx
:
:
SharedFTFace
>
CloneFace
(
int
aFaceIndex
=
0
)
override
;
private
:
~
FTUserFontData
(
)
{
if
(
mFontData
)
{
free
(
(
void
*
)
mFontData
)
;
}
}
const
uint8_t
*
mFontData
;
uint32_t
mLength
;
}
;
#
endif
