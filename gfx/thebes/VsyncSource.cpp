#
include
"
VsyncSource
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
VsyncDispatcher
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
gfxPlatform
.
h
"
#
ifdef
MOZ_WAYLAND
#
include
"
WaylandVsyncSource
.
h
"
#
endif
namespace
mozilla
{
namespace
gfx
{
VsyncSource
:
:
VsyncSource
(
)
:
mState
(
"
VsyncSource
:
:
State
"
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
VsyncSource
:
:
~
VsyncSource
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
void
VsyncSource
:
:
NotifyVsync
(
const
TimeStamp
&
aVsyncTimestamp
const
TimeStamp
&
aOutputTimestamp
)
{
VsyncId
vsyncId
;
nsTArray
<
DispatcherRefWithCount
>
dispatchers
;
{
auto
state
=
mState
.
Lock
(
)
;
vsyncId
=
state
-
>
mVsyncId
.
Next
(
)
;
dispatchers
=
state
-
>
mDispatchers
.
Clone
(
)
;
state
-
>
mVsyncId
=
vsyncId
;
}
const
VsyncEvent
event
(
vsyncId
aVsyncTimestamp
aOutputTimestamp
)
;
for
(
const
auto
&
dispatcher
:
dispatchers
)
{
dispatcher
.
mDispatcher
-
>
NotifyVsync
(
event
)
;
}
}
void
VsyncSource
:
:
AddVsyncDispatcher
(
VsyncDispatcher
*
aVsyncDispatcher
)
{
MOZ_ASSERT
(
aVsyncDispatcher
)
;
{
auto
state
=
mState
.
Lock
(
)
;
bool
found
=
false
;
for
(
auto
&
dispatcherRefWithCount
:
state
-
>
mDispatchers
)
{
if
(
dispatcherRefWithCount
.
mDispatcher
=
=
aVsyncDispatcher
)
{
dispatcherRefWithCount
.
mCount
+
+
;
found
=
true
;
break
;
}
}
if
(
!
found
)
{
state
-
>
mDispatchers
.
AppendElement
(
DispatcherRefWithCount
{
aVsyncDispatcher
1
}
)
;
}
}
UpdateVsyncStatus
(
)
;
}
void
VsyncSource
:
:
RemoveVsyncDispatcher
(
VsyncDispatcher
*
aVsyncDispatcher
)
{
MOZ_ASSERT
(
aVsyncDispatcher
)
;
{
auto
state
=
mState
.
Lock
(
)
;
for
(
auto
it
=
state
-
>
mDispatchers
.
begin
(
)
;
it
!
=
state
-
>
mDispatchers
.
end
(
)
;
+
+
it
)
{
if
(
it
-
>
mDispatcher
=
=
aVsyncDispatcher
)
{
it
-
>
mCount
-
-
;
if
(
it
-
>
mCount
=
=
0
)
{
state
-
>
mDispatchers
.
RemoveElementAt
(
it
)
;
}
break
;
}
}
}
UpdateVsyncStatus
(
)
;
}
TimeDuration
VsyncSource
:
:
GetVsyncRate
(
)
{
return
TimeDuration
:
:
FromMilliseconds
(
1000
.
0
/
60
.
0
)
;
}
void
VsyncSource
:
:
UpdateVsyncStatus
(
)
{
if
(
!
NS_IsMainThread
(
)
)
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
VsyncSource
:
:
UpdateVsyncStatus
"
[
self
=
RefPtr
{
this
}
]
{
self
-
>
UpdateVsyncStatus
(
)
;
}
)
)
;
return
;
}
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
bool
enableVsync
=
false
;
{
auto
state
=
mState
.
Lock
(
)
;
enableVsync
=
!
state
-
>
mDispatchers
.
IsEmpty
(
)
;
}
if
(
enableVsync
)
{
EnableVsync
(
)
;
}
else
{
DisableVsync
(
)
;
}
if
(
IsVsyncEnabled
(
)
!
=
enableVsync
)
{
NS_WARNING
(
"
Vsync
status
did
not
change
.
"
)
;
}
}
Maybe
<
TimeDuration
>
VsyncSource
:
:
GetFastestVsyncRate
(
)
{
Maybe
<
TimeDuration
>
retVal
;
if
(
!
gfxPlatform
:
:
Initialized
(
)
)
{
return
retVal
;
}
RefPtr
<
VsyncDispatcher
>
vsyncDispatcher
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetGlobalVsyncDispatcher
(
)
;
RefPtr
<
VsyncSource
>
vsyncSource
=
vsyncDispatcher
-
>
GetCurrentVsyncSource
(
)
;
if
(
vsyncSource
-
>
IsVsyncEnabled
(
)
)
{
retVal
.
emplace
(
vsyncSource
-
>
GetVsyncRate
(
)
)
;
#
ifdef
MOZ_WAYLAND
Maybe
<
TimeDuration
>
waylandRate
=
WaylandVsyncSource
:
:
GetFastestVsyncRate
(
)
;
if
(
waylandRate
)
{
if
(
!
retVal
)
{
retVal
.
emplace
(
*
waylandRate
)
;
}
else
if
(
*
waylandRate
<
*
retVal
)
{
retVal
=
waylandRate
;
}
}
#
endif
}
return
retVal
;
}
}
}
