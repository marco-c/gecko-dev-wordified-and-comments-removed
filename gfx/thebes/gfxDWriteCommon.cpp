#
include
"
gfxDWriteCommon
.
h
"
#
include
<
unordered_map
>
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
class
gfxDWriteFontFileStream
;
static
mozilla
:
:
StaticMutex
sFontFileStreamsMutex
MOZ_UNANNOTATED
;
static
uint64_t
sNextFontFileKey
=
0
;
MOZ_RUNINIT
static
std
:
:
unordered_map
<
uint64_t
gfxDWriteFontFileStream
*
>
sFontFileStreams
;
IDWriteFontFileLoader
*
gfxDWriteFontFileLoader
:
:
mInstance
=
nullptr
;
class
gfxDWriteFontFileStream
final
:
public
IDWriteFontFileStream
{
public
:
gfxDWriteFontFileStream
(
const
uint8_t
*
aData
uint32_t
aLength
uint64_t
aFontFileKey
)
;
~
gfxDWriteFontFileStream
(
)
;
IFACEMETHOD
(
QueryInterface
)
(
IID
const
&
iid
OUT
void
*
*
ppObject
)
{
if
(
iid
=
=
__uuidof
(
IDWriteFontFileStream
)
)
{
*
ppObject
=
static_cast
<
IDWriteFontFileStream
*
>
(
this
)
;
return
S_OK
;
}
else
if
(
iid
=
=
__uuidof
(
IUnknown
)
)
{
*
ppObject
=
static_cast
<
IUnknown
*
>
(
this
)
;
return
S_OK
;
}
else
{
return
E_NOINTERFACE
;
}
}
IFACEMETHOD_
(
ULONG
AddRef
)
(
)
{
MOZ_ASSERT
(
int32_t
(
mRefCnt
)
>
=
0
"
illegal
refcnt
"
)
;
return
+
+
mRefCnt
;
}
IFACEMETHOD_
(
ULONG
Release
)
(
)
{
MOZ_ASSERT
(
0
!
=
mRefCnt
"
dup
release
"
)
;
uint32_t
count
=
-
-
mRefCnt
;
if
(
count
=
=
0
)
{
mozilla
:
:
StaticMutexAutoLock
lock
(
sFontFileStreamsMutex
)
;
if
(
0
!
=
mRefCnt
)
{
return
mRefCnt
;
}
delete
this
;
}
return
count
;
}
virtual
HRESULT
STDMETHODCALLTYPE
ReadFileFragment
(
void
const
*
*
fragmentStart
UINT64
fileOffset
UINT64
fragmentSize
OUT
void
*
*
fragmentContext
)
;
virtual
void
STDMETHODCALLTYPE
ReleaseFileFragment
(
void
*
fragmentContext
)
;
virtual
HRESULT
STDMETHODCALLTYPE
GetFileSize
(
OUT
UINT64
*
fileSize
)
;
virtual
HRESULT
STDMETHODCALLTYPE
GetLastWriteTime
(
OUT
UINT64
*
lastWriteTime
)
;
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mData
.
ShallowSizeOfExcludingThis
(
mallocSizeOf
)
;
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
mallocSizeOf
)
;
}
private
:
FallibleTArray
<
uint8_t
>
mData
;
mozilla
:
:
Atomic
<
uint32_t
>
mRefCnt
;
uint64_t
mFontFileKey
;
}
;
gfxDWriteFontFileStream
:
:
gfxDWriteFontFileStream
(
const
uint8_t
*
aData
uint32_t
aLength
uint64_t
aFontFileKey
)
:
mFontFileKey
(
aFontFileKey
)
{
if
(
!
mData
.
AppendElements
(
aData
aLength
mozilla
:
:
fallible_t
(
)
)
)
{
NS_WARNING
(
"
Failed
to
store
data
in
gfxDWriteFontFileStream
"
)
;
}
}
gfxDWriteFontFileStream
:
:
~
gfxDWriteFontFileStream
(
)
{
sFontFileStreams
.
erase
(
mFontFileKey
)
;
}
HRESULT
STDMETHODCALLTYPE
gfxDWriteFontFileStream
:
:
GetFileSize
(
UINT64
*
fileSize
)
{
*
fileSize
=
mData
.
Length
(
)
;
return
S_OK
;
}
HRESULT
STDMETHODCALLTYPE
gfxDWriteFontFileStream
:
:
GetLastWriteTime
(
UINT64
*
lastWriteTime
)
{
return
E_NOTIMPL
;
}
HRESULT
STDMETHODCALLTYPE
gfxDWriteFontFileStream
:
:
ReadFileFragment
(
const
void
*
*
fragmentStart
UINT64
fileOffset
UINT64
fragmentSize
void
*
*
fragmentContext
)
{
if
(
fileOffset
+
fragmentSize
>
(
UINT64
)
mData
.
Length
(
)
)
{
return
E_FAIL
;
}
*
fragmentStart
=
&
mData
[
fileOffset
]
;
*
fragmentContext
=
nullptr
;
return
S_OK
;
}
void
STDMETHODCALLTYPE
gfxDWriteFontFileStream
:
:
ReleaseFileFragment
(
void
*
fragmentContext
)
{
}
HRESULT
STDMETHODCALLTYPE
gfxDWriteFontFileLoader
:
:
CreateStreamFromKey
(
const
void
*
fontFileReferenceKey
UINT32
fontFileReferenceKeySize
IDWriteFontFileStream
*
*
fontFileStream
)
{
if
(
!
fontFileReferenceKey
|
|
!
fontFileStream
)
{
return
E_POINTER
;
}
mozilla
:
:
StaticMutexAutoLock
lock
(
sFontFileStreamsMutex
)
;
uint64_t
fontFileKey
=
*
static_cast
<
const
uint64_t
*
>
(
fontFileReferenceKey
)
;
auto
found
=
sFontFileStreams
.
find
(
fontFileKey
)
;
if
(
found
=
=
sFontFileStreams
.
end
(
)
)
{
*
fontFileStream
=
nullptr
;
return
E_FAIL
;
}
found
-
>
second
-
>
AddRef
(
)
;
*
fontFileStream
=
found
-
>
second
;
return
S_OK
;
}
HRESULT
gfxDWriteFontFileLoader
:
:
CreateCustomFontFile
(
const
uint8_t
*
aFontData
uint32_t
aLength
IDWriteFontFile
*
*
aFontFile
IDWriteFontFileStream
*
*
aFontFileStream
)
{
MOZ_ASSERT
(
aFontFile
)
;
MOZ_ASSERT
(
aFontFileStream
)
;
RefPtr
<
IDWriteFactory
>
factory
=
mozilla
:
:
gfx
:
:
Factory
:
:
GetDWriteFactory
(
)
;
if
(
!
factory
)
{
gfxCriticalError
(
)
<
<
"
Failed
to
get
DWrite
Factory
in
CreateCustomFontFile
.
"
;
return
E_FAIL
;
}
sFontFileStreamsMutex
.
Lock
(
)
;
uint64_t
fontFileKey
=
sNextFontFileKey
+
+
;
RefPtr
<
gfxDWriteFontFileStream
>
ffsRef
=
new
gfxDWriteFontFileStream
(
aFontData
aLength
fontFileKey
)
;
sFontFileStreams
[
fontFileKey
]
=
ffsRef
;
sFontFileStreamsMutex
.
Unlock
(
)
;
RefPtr
<
IDWriteFontFile
>
fontFile
;
HRESULT
hr
=
factory
-
>
CreateCustomFontFileReference
(
&
fontFileKey
sizeof
(
fontFileKey
)
Instance
(
)
getter_AddRefs
(
fontFile
)
)
;
if
(
FAILED
(
hr
)
)
{
NS_WARNING
(
"
Failed
to
load
font
file
from
data
!
"
)
;
return
hr
;
}
fontFile
.
forget
(
aFontFile
)
;
ffsRef
.
forget
(
aFontFileStream
)
;
return
S_OK
;
}
size_t
gfxDWriteFontFileLoader
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
sizes
=
mallocSizeOf
(
this
)
;
MOZ_ASSERT
(
this
=
=
mInstance
)
;
for
(
const
auto
&
entry
:
sFontFileStreams
)
{
gfxDWriteFontFileStream
*
fileStream
=
entry
.
second
;
sizes
+
=
fileStream
-
>
SizeOfIncludingThis
(
mallocSizeOf
)
;
}
return
sizes
;
}
