#
include
"
gfxBlur
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Blur
.
h
"
#
include
"
mozilla
/
gfx
/
PathHelpers
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
nsExpirationTracker
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
gfxUtils
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
gfxAlphaBoxBlur
:
:
gfxAlphaBoxBlur
(
)
{
}
gfxAlphaBoxBlur
:
:
~
gfxAlphaBoxBlur
(
)
{
mContext
=
nullptr
;
}
gfxContext
*
gfxAlphaBoxBlur
:
:
Init
(
const
gfxRect
&
aRect
const
IntSize
&
aSpreadRadius
const
IntSize
&
aBlurRadius
const
gfxRect
*
aDirtyRect
const
gfxRect
*
aSkipRect
)
{
mozilla
:
:
gfx
:
:
Rect
rect
(
Float
(
aRect
.
x
)
Float
(
aRect
.
y
)
Float
(
aRect
.
width
)
Float
(
aRect
.
height
)
)
;
IntSize
spreadRadius
(
aSpreadRadius
.
width
aSpreadRadius
.
height
)
;
IntSize
blurRadius
(
aBlurRadius
.
width
aBlurRadius
.
height
)
;
UniquePtr
<
Rect
>
dirtyRect
;
if
(
aDirtyRect
)
{
dirtyRect
=
MakeUnique
<
Rect
>
(
Float
(
aDirtyRect
-
>
x
)
Float
(
aDirtyRect
-
>
y
)
Float
(
aDirtyRect
-
>
width
)
Float
(
aDirtyRect
-
>
height
)
)
;
}
UniquePtr
<
Rect
>
skipRect
;
if
(
aSkipRect
)
{
skipRect
=
MakeUnique
<
Rect
>
(
Float
(
aSkipRect
-
>
x
)
Float
(
aSkipRect
-
>
y
)
Float
(
aSkipRect
-
>
width
)
Float
(
aSkipRect
-
>
height
)
)
;
}
mBlur
=
MakeUnique
<
AlphaBoxBlur
>
(
rect
spreadRadius
blurRadius
dirtyRect
.
get
(
)
skipRect
.
get
(
)
)
;
size_t
blurDataSize
=
mBlur
-
>
GetSurfaceAllocationSize
(
)
;
if
(
blurDataSize
=
=
0
)
return
nullptr
;
IntSize
size
=
mBlur
-
>
GetSize
(
)
;
mData
=
MakeUniqueFallible
<
unsigned
char
[
]
>
(
blurDataSize
)
;
if
(
!
mData
)
{
return
nullptr
;
}
memset
(
mData
.
get
(
)
0
blurDataSize
)
;
RefPtr
<
DrawTarget
>
dt
=
gfxPlatform
:
:
CreateDrawTargetForData
(
mData
.
get
(
)
size
mBlur
-
>
GetStride
(
)
SurfaceFormat
:
:
A8
)
;
if
(
!
dt
|
|
!
dt
-
>
IsValid
(
)
)
{
return
nullptr
;
}
IntRect
irect
=
mBlur
-
>
GetRect
(
)
;
gfxPoint
topleft
(
irect
.
TopLeft
(
)
.
x
irect
.
TopLeft
(
)
.
y
)
;
mContext
=
gfxContext
:
:
CreateOrNull
(
dt
)
;
MOZ_ASSERT
(
mContext
)
;
mContext
-
>
SetMatrix
(
gfxMatrix
:
:
Translation
(
-
topleft
)
)
;
return
mContext
;
}
void
DrawBlur
(
gfxContext
*
aDestinationCtx
SourceSurface
*
aBlur
const
IntPoint
&
aTopLeft
const
Rect
*
aDirtyRect
)
{
DrawTarget
*
dest
=
aDestinationCtx
-
>
GetDrawTarget
(
)
;
RefPtr
<
gfxPattern
>
thebesPat
=
aDestinationCtx
-
>
GetPattern
(
)
;
Pattern
*
pat
=
thebesPat
-
>
GetPattern
(
dest
nullptr
)
;
Matrix
oldTransform
=
dest
-
>
GetTransform
(
)
;
Matrix
newTransform
=
oldTransform
;
newTransform
.
PreTranslate
(
aTopLeft
.
x
aTopLeft
.
y
)
;
if
(
aDirtyRect
)
{
dest
-
>
PushClipRect
(
*
aDirtyRect
)
;
}
dest
-
>
SetTransform
(
newTransform
)
;
dest
-
>
MaskSurface
(
*
pat
aBlur
Point
(
0
0
)
)
;
dest
-
>
SetTransform
(
oldTransform
)
;
if
(
aDirtyRect
)
{
dest
-
>
PopClip
(
)
;
}
}
already_AddRefed
<
SourceSurface
>
gfxAlphaBoxBlur
:
:
DoBlur
(
DrawTarget
*
aDT
IntPoint
*
aTopLeft
)
{
mBlur
-
>
Blur
(
mData
.
get
(
)
)
;
*
aTopLeft
=
mBlur
-
>
GetRect
(
)
.
TopLeft
(
)
;
return
aDT
-
>
CreateSourceSurfaceFromData
(
mData
.
get
(
)
mBlur
-
>
GetSize
(
)
mBlur
-
>
GetStride
(
)
SurfaceFormat
:
:
A8
)
;
}
void
gfxAlphaBoxBlur
:
:
Paint
(
gfxContext
*
aDestinationCtx
)
{
if
(
!
mContext
)
return
;
DrawTarget
*
dest
=
aDestinationCtx
-
>
GetDrawTarget
(
)
;
if
(
!
dest
)
{
NS_WARNING
(
"
Blurring
not
supported
for
Thebes
contexts
!
"
)
;
return
;
}
Rect
*
dirtyRect
=
mBlur
-
>
GetDirtyRect
(
)
;
IntPoint
topLeft
;
RefPtr
<
SourceSurface
>
mask
=
DoBlur
(
dest
&
topLeft
)
;
if
(
!
mask
)
{
NS_ERROR
(
"
Failed
to
create
mask
!
"
)
;
return
;
}
DrawBlur
(
aDestinationCtx
mask
topLeft
dirtyRect
)
;
}
IntSize
gfxAlphaBoxBlur
:
:
CalculateBlurRadius
(
const
gfxPoint
&
aStd
)
{
mozilla
:
:
gfx
:
:
Point
std
(
Float
(
aStd
.
x
)
Float
(
aStd
.
y
)
)
;
IntSize
size
=
AlphaBoxBlur
:
:
CalculateBlurRadius
(
std
)
;
return
IntSize
(
size
.
width
size
.
height
)
;
}
struct
BlurCacheKey
:
public
PLDHashEntryHdr
{
typedef
const
BlurCacheKey
&
KeyType
;
typedef
const
BlurCacheKey
*
KeyTypePointer
;
enum
{
ALLOW_MEMMOVE
=
true
}
;
IntSize
mMinSize
;
IntSize
mBlurRadius
;
Color
mShadowColor
;
BackendType
mBackend
;
RectCornerRadii
mCornerRadii
;
bool
mIsInset
;
bool
mHasBorderRadius
;
IntSize
mInnerMinSize
;
BlurCacheKey
(
IntSize
aMinSize
IntSize
aBlurRadius
RectCornerRadii
*
aCornerRadii
const
Color
&
aShadowColor
BackendType
aBackendType
)
:
BlurCacheKey
(
aMinSize
IntSize
(
0
0
)
aBlurRadius
aCornerRadii
aShadowColor
false
false
aBackendType
)
{
}
explicit
BlurCacheKey
(
const
BlurCacheKey
*
aOther
)
:
mMinSize
(
aOther
-
>
mMinSize
)
mBlurRadius
(
aOther
-
>
mBlurRadius
)
mShadowColor
(
aOther
-
>
mShadowColor
)
mBackend
(
aOther
-
>
mBackend
)
mCornerRadii
(
aOther
-
>
mCornerRadii
)
mIsInset
(
aOther
-
>
mIsInset
)
mHasBorderRadius
(
aOther
-
>
mHasBorderRadius
)
mInnerMinSize
(
aOther
-
>
mInnerMinSize
)
{
}
explicit
BlurCacheKey
(
IntSize
aOuterMinSize
IntSize
aInnerMinSize
IntSize
aBlurRadius
const
RectCornerRadii
*
aCornerRadii
const
Color
&
aShadowColor
bool
aIsInset
bool
aHasBorderRadius
BackendType
aBackendType
)
:
mMinSize
(
aOuterMinSize
)
mBlurRadius
(
aBlurRadius
)
mShadowColor
(
aShadowColor
)
mBackend
(
aBackendType
)
mCornerRadii
(
aCornerRadii
?
*
aCornerRadii
:
RectCornerRadii
(
)
)
mIsInset
(
aIsInset
)
mHasBorderRadius
(
aHasBorderRadius
)
mInnerMinSize
(
aInnerMinSize
)
{
}
static
PLDHashNumber
HashKey
(
const
KeyTypePointer
aKey
)
{
PLDHashNumber
hash
=
0
;
hash
=
AddToHash
(
hash
aKey
-
>
mMinSize
.
width
aKey
-
>
mMinSize
.
height
)
;
hash
=
AddToHash
(
hash
aKey
-
>
mBlurRadius
.
width
aKey
-
>
mBlurRadius
.
height
)
;
hash
=
AddToHash
(
hash
HashBytes
(
&
aKey
-
>
mShadowColor
.
r
sizeof
(
aKey
-
>
mShadowColor
.
r
)
)
)
;
hash
=
AddToHash
(
hash
HashBytes
(
&
aKey
-
>
mShadowColor
.
g
sizeof
(
aKey
-
>
mShadowColor
.
g
)
)
)
;
hash
=
AddToHash
(
hash
HashBytes
(
&
aKey
-
>
mShadowColor
.
b
sizeof
(
aKey
-
>
mShadowColor
.
b
)
)
)
;
hash
=
AddToHash
(
hash
HashBytes
(
&
aKey
-
>
mShadowColor
.
a
sizeof
(
aKey
-
>
mShadowColor
.
a
)
)
)
;
for
(
int
i
=
0
;
i
<
4
;
i
+
+
)
{
hash
=
AddToHash
(
hash
aKey
-
>
mCornerRadii
[
i
]
.
width
aKey
-
>
mCornerRadii
[
i
]
.
height
)
;
}
hash
=
AddToHash
(
hash
(
uint32_t
)
aKey
-
>
mBackend
)
;
if
(
aKey
-
>
mIsInset
)
{
hash
=
AddToHash
(
hash
aKey
-
>
mInnerMinSize
.
width
aKey
-
>
mInnerMinSize
.
height
)
;
hash
=
AddToHash
(
hash
HashBytes
(
&
aKey
-
>
mHasBorderRadius
sizeof
(
bool
)
)
)
;
}
return
hash
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
if
(
aKey
-
>
mMinSize
=
=
mMinSize
&
&
aKey
-
>
mBlurRadius
=
=
mBlurRadius
&
&
aKey
-
>
mCornerRadii
=
=
mCornerRadii
&
&
aKey
-
>
mShadowColor
=
=
mShadowColor
&
&
aKey
-
>
mBackend
=
=
mBackend
)
{
if
(
mIsInset
)
{
return
(
mHasBorderRadius
=
=
aKey
-
>
mHasBorderRadius
)
&
&
(
mInnerMinSize
=
=
aKey
-
>
mInnerMinSize
)
;
}
return
true
;
}
return
false
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
&
aKey
;
}
}
;
struct
BlurCacheData
{
BlurCacheData
(
SourceSurface
*
aBlur
IntMargin
aExtendDestBy
const
BlurCacheKey
&
aKey
)
:
mBlur
(
aBlur
)
mExtendDest
(
aExtendDestBy
)
mKey
(
aKey
)
{
}
BlurCacheData
(
const
BlurCacheData
&
aOther
)
:
mBlur
(
aOther
.
mBlur
)
mExtendDest
(
aOther
.
mExtendDest
)
mKey
(
aOther
.
mKey
)
{
}
nsExpirationState
*
GetExpirationState
(
)
{
return
&
mExpirationState
;
}
nsExpirationState
mExpirationState
;
RefPtr
<
SourceSurface
>
mBlur
;
IntMargin
mExtendDest
;
BlurCacheKey
mKey
;
}
;
class
BlurCache
final
:
public
nsExpirationTracker
<
BlurCacheData
4
>
{
public
:
BlurCache
(
)
:
nsExpirationTracker
<
BlurCacheData
4
>
(
GENERATION_MS
"
BlurCache
"
)
{
}
virtual
void
NotifyExpired
(
BlurCacheData
*
aObject
)
{
RemoveObject
(
aObject
)
;
mHashEntries
.
Remove
(
aObject
-
>
mKey
)
;
}
BlurCacheData
*
Lookup
(
const
IntSize
aMinSize
const
IntSize
&
aBlurRadius
RectCornerRadii
*
aCornerRadii
const
Color
&
aShadowColor
BackendType
aBackendType
)
{
BlurCacheData
*
blur
=
mHashEntries
.
Get
(
BlurCacheKey
(
aMinSize
aBlurRadius
aCornerRadii
aShadowColor
aBackendType
)
)
;
if
(
blur
)
{
MarkUsed
(
blur
)
;
}
return
blur
;
}
BlurCacheData
*
LookupInsetBoxShadow
(
const
IntSize
aOuterMinSize
const
IntSize
aInnerMinSize
const
IntSize
&
aBlurRadius
const
RectCornerRadii
*
aCornerRadii
const
Color
&
aShadowColor
const
bool
&
aHasBorderRadius
BackendType
aBackendType
)
{
bool
insetBoxShadow
=
true
;
BlurCacheKey
key
(
aOuterMinSize
aInnerMinSize
aBlurRadius
aCornerRadii
aShadowColor
insetBoxShadow
aHasBorderRadius
aBackendType
)
;
BlurCacheData
*
blur
=
mHashEntries
.
Get
(
key
)
;
if
(
blur
)
{
MarkUsed
(
blur
)
;
}
return
blur
;
}
bool
RegisterEntry
(
BlurCacheData
*
aValue
)
{
nsresult
rv
=
AddObject
(
aValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
mHashEntries
.
Put
(
aValue
-
>
mKey
aValue
)
;
return
true
;
}
protected
:
static
const
uint32_t
GENERATION_MS
=
1000
;
nsClassHashtable
<
BlurCacheKey
BlurCacheData
>
mHashEntries
;
}
;
static
BlurCache
*
gBlurCache
=
nullptr
;
static
IntSize
ComputeMinSizeForShadowShape
(
RectCornerRadii
*
aCornerRadii
IntSize
aBlurRadius
IntMargin
&
aSlice
const
IntSize
&
aRectSize
)
{
float
cornerWidth
=
0
;
float
cornerHeight
=
0
;
if
(
aCornerRadii
)
{
RectCornerRadii
corners
=
*
aCornerRadii
;
for
(
size_t
i
=
0
;
i
<
4
;
i
+
+
)
{
cornerWidth
=
std
:
:
max
(
cornerWidth
corners
[
i
]
.
width
)
;
cornerHeight
=
std
:
:
max
(
cornerHeight
corners
[
i
]
.
height
)
;
}
}
aSlice
=
IntMargin
(
ceil
(
cornerHeight
)
+
aBlurRadius
.
height
ceil
(
cornerWidth
)
+
aBlurRadius
.
width
ceil
(
cornerHeight
)
+
aBlurRadius
.
height
ceil
(
cornerWidth
)
+
aBlurRadius
.
width
)
;
IntSize
minSize
(
aSlice
.
LeftRight
(
)
+
1
aSlice
.
TopBottom
(
)
+
1
)
;
if
(
aRectSize
.
width
<
minSize
.
width
)
{
minSize
.
width
=
aRectSize
.
width
;
aSlice
.
left
=
0
;
aSlice
.
right
=
0
;
}
if
(
aRectSize
.
height
<
minSize
.
height
)
{
minSize
.
height
=
aRectSize
.
height
;
aSlice
.
top
=
0
;
aSlice
.
bottom
=
0
;
}
MOZ_ASSERT
(
aSlice
.
LeftRight
(
)
<
=
minSize
.
width
)
;
MOZ_ASSERT
(
aSlice
.
TopBottom
(
)
<
=
minSize
.
height
)
;
return
minSize
;
}
void
CacheBlur
(
DrawTarget
&
aDT
const
IntSize
&
aMinSize
const
IntSize
&
aBlurRadius
RectCornerRadii
*
aCornerRadii
const
Color
&
aShadowColor
IntMargin
aExtendDest
SourceSurface
*
aBoxShadow
)
{
BlurCacheKey
key
(
aMinSize
aBlurRadius
aCornerRadii
aShadowColor
aDT
.
GetBackendType
(
)
)
;
BlurCacheData
*
data
=
new
BlurCacheData
(
aBoxShadow
aExtendDest
key
)
;
if
(
!
gBlurCache
-
>
RegisterEntry
(
data
)
)
{
delete
data
;
}
}
static
already_AddRefed
<
SourceSurface
>
CreateBlurMask
(
const
IntSize
&
aMinSize
RectCornerRadii
*
aCornerRadii
IntSize
aBlurRadius
IntMargin
&
aExtendDestBy
IntMargin
&
aSliceBorder
DrawTarget
&
aDestDrawTarget
)
{
gfxAlphaBoxBlur
blur
;
IntRect
minRect
(
IntPoint
(
)
aMinSize
)
;
gfxContext
*
blurCtx
=
blur
.
Init
(
ThebesRect
(
Rect
(
minRect
)
)
IntSize
(
)
aBlurRadius
nullptr
nullptr
)
;
if
(
!
blurCtx
)
{
return
nullptr
;
}
DrawTarget
*
blurDT
=
blurCtx
-
>
GetDrawTarget
(
)
;
ColorPattern
black
(
Color
(
0
.
f
0
.
f
0
.
f
1
.
f
)
)
;
if
(
aCornerRadii
)
{
RefPtr
<
Path
>
roundedRect
=
MakePathForRoundedRect
(
*
blurDT
Rect
(
minRect
)
*
aCornerRadii
)
;
blurDT
-
>
Fill
(
roundedRect
black
)
;
}
else
{
blurDT
-
>
FillRect
(
Rect
(
minRect
)
black
)
;
}
IntPoint
topLeft
;
RefPtr
<
SourceSurface
>
result
=
blur
.
DoBlur
(
&
aDestDrawTarget
&
topLeft
)
;
if
(
!
result
)
{
return
nullptr
;
}
IntRect
expandedMinRect
(
topLeft
result
-
>
GetSize
(
)
)
;
aExtendDestBy
=
expandedMinRect
-
minRect
;
aSliceBorder
+
=
aExtendDestBy
;
MOZ_ASSERT
(
aSliceBorder
.
LeftRight
(
)
<
=
expandedMinRect
.
width
)
;
MOZ_ASSERT
(
aSliceBorder
.
TopBottom
(
)
<
=
expandedMinRect
.
height
)
;
return
result
.
forget
(
)
;
}
static
already_AddRefed
<
SourceSurface
>
CreateBoxShadow
(
SourceSurface
*
aBlurMask
const
Color
&
aShadowColor
)
{
IntSize
blurredSize
=
aBlurMask
-
>
GetSize
(
)
;
gfxPlatform
*
platform
=
gfxPlatform
:
:
GetPlatform
(
)
;
RefPtr
<
DrawTarget
>
boxShadowDT
=
platform
-
>
CreateOffscreenContentDrawTarget
(
blurredSize
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
boxShadowDT
)
{
return
nullptr
;
}
ColorPattern
shadowColor
(
ToDeviceColor
(
aShadowColor
)
)
;
boxShadowDT
-
>
MaskSurface
(
shadowColor
aBlurMask
Point
(
0
0
)
)
;
return
boxShadowDT
-
>
Snapshot
(
)
;
}
static
already_AddRefed
<
SourceSurface
>
GetBlur
(
gfxContext
*
aDestinationCtx
const
IntSize
&
aRectSize
const
IntSize
&
aBlurRadius
RectCornerRadii
*
aCornerRadii
const
Color
&
aShadowColor
IntMargin
&
aExtendDestBy
IntMargin
&
aSlice
)
{
if
(
!
gBlurCache
)
{
gBlurCache
=
new
BlurCache
(
)
;
}
IntSize
minSize
=
ComputeMinSizeForShadowShape
(
aCornerRadii
aBlurRadius
aSlice
aRectSize
)
;
Matrix
destMatrix
=
ToMatrix
(
aDestinationCtx
-
>
CurrentMatrix
(
)
)
;
bool
useDestRect
=
!
destMatrix
.
IsRectilinear
(
)
|
|
destMatrix
.
HasNonIntegerTranslation
(
)
;
if
(
useDestRect
)
{
minSize
=
aRectSize
;
}
DrawTarget
&
destDT
=
*
aDestinationCtx
-
>
GetDrawTarget
(
)
;
BlurCacheData
*
cached
=
gBlurCache
-
>
Lookup
(
minSize
aBlurRadius
aCornerRadii
aShadowColor
destDT
.
GetBackendType
(
)
)
;
if
(
cached
&
&
!
useDestRect
)
{
aExtendDestBy
=
cached
-
>
mExtendDest
;
aSlice
=
aSlice
+
aExtendDestBy
;
RefPtr
<
SourceSurface
>
blur
=
cached
-
>
mBlur
;
return
blur
.
forget
(
)
;
}
RefPtr
<
SourceSurface
>
blurMask
=
CreateBlurMask
(
minSize
aCornerRadii
aBlurRadius
aExtendDestBy
aSlice
destDT
)
;
if
(
!
blurMask
)
{
return
nullptr
;
}
RefPtr
<
SourceSurface
>
boxShadow
=
CreateBoxShadow
(
blurMask
aShadowColor
)
;
if
(
!
boxShadow
)
{
return
nullptr
;
}
if
(
useDestRect
)
{
aSlice
.
SizeTo
(
0
0
0
0
)
;
}
else
{
CacheBlur
(
destDT
minSize
aBlurRadius
aCornerRadii
aShadowColor
aExtendDestBy
boxShadow
)
;
}
return
boxShadow
.
forget
(
)
;
}
void
gfxAlphaBoxBlur
:
:
ShutdownBlurCache
(
)
{
delete
gBlurCache
;
gBlurCache
=
nullptr
;
}
static
Rect
RectWithEdgesTRBL
(
Float
aTop
Float
aRight
Float
aBottom
Float
aLeft
)
{
return
Rect
(
aLeft
aTop
aRight
-
aLeft
aBottom
-
aTop
)
;
}
static
void
RepeatOrStretchSurface
(
DrawTarget
&
aDT
SourceSurface
*
aSurface
const
Rect
&
aDest
const
Rect
&
aSrc
Rect
&
aSkipRect
)
{
if
(
aSkipRect
.
Contains
(
aDest
)
)
{
return
;
}
if
(
(
!
aDT
.
GetTransform
(
)
.
IsRectilinear
(
)
&
&
aDT
.
GetBackendType
(
)
!
=
BackendType
:
:
CAIRO
)
|
|
(
aDT
.
GetBackendType
(
)
=
=
BackendType
:
:
DIRECT2D1_1
)
)
{
aDT
.
DrawSurface
(
aSurface
aDest
aSrc
)
;
return
;
}
SurfacePattern
pattern
(
aSurface
ExtendMode
:
:
REPEAT
Matrix
:
:
Translation
(
aDest
.
TopLeft
(
)
-
aSrc
.
TopLeft
(
)
)
SamplingFilter
:
:
GOOD
RoundedToInt
(
aSrc
)
)
;
aDT
.
FillRect
(
aDest
pattern
)
;
}
static
void
DrawCorner
(
DrawTarget
&
aDT
SourceSurface
*
aSurface
const
Rect
&
aDest
const
Rect
&
aSrc
Rect
&
aSkipRect
)
{
if
(
aSkipRect
.
Contains
(
aDest
)
)
{
return
;
}
aDT
.
DrawSurface
(
aSurface
aDest
aSrc
)
;
}
static
void
DrawBoxShadows
(
DrawTarget
&
aDestDrawTarget
SourceSurface
*
aSourceBlur
Rect
aDstOuter
Rect
aDstInner
Rect
aSrcOuter
Rect
aSrcInner
Rect
aSkipRect
)
{
DrawCorner
(
aDestDrawTarget
aSourceBlur
RectWithEdgesTRBL
(
aDstOuter
.
Y
(
)
aDstInner
.
X
(
)
aDstInner
.
Y
(
)
aDstOuter
.
X
(
)
)
RectWithEdgesTRBL
(
aSrcOuter
.
Y
(
)
aSrcInner
.
X
(
)
aSrcInner
.
Y
(
)
aSrcOuter
.
X
(
)
)
aSkipRect
)
;
DrawCorner
(
aDestDrawTarget
aSourceBlur
RectWithEdgesTRBL
(
aDstOuter
.
Y
(
)
aDstOuter
.
XMost
(
)
aDstInner
.
Y
(
)
aDstInner
.
XMost
(
)
)
RectWithEdgesTRBL
(
aSrcOuter
.
Y
(
)
aSrcOuter
.
XMost
(
)
aSrcInner
.
Y
(
)
aSrcInner
.
XMost
(
)
)
aSkipRect
)
;
DrawCorner
(
aDestDrawTarget
aSourceBlur
RectWithEdgesTRBL
(
aDstInner
.
YMost
(
)
aDstInner
.
X
(
)
aDstOuter
.
YMost
(
)
aDstOuter
.
X
(
)
)
RectWithEdgesTRBL
(
aSrcInner
.
YMost
(
)
aSrcInner
.
X
(
)
aSrcOuter
.
YMost
(
)
aSrcOuter
.
X
(
)
)
aSkipRect
)
;
DrawCorner
(
aDestDrawTarget
aSourceBlur
RectWithEdgesTRBL
(
aDstInner
.
YMost
(
)
aDstOuter
.
XMost
(
)
aDstOuter
.
YMost
(
)
aDstInner
.
XMost
(
)
)
RectWithEdgesTRBL
(
aSrcInner
.
YMost
(
)
aSrcOuter
.
XMost
(
)
aSrcOuter
.
YMost
(
)
aSrcInner
.
XMost
(
)
)
aSkipRect
)
;
RepeatOrStretchSurface
(
aDestDrawTarget
aSourceBlur
RectWithEdgesTRBL
(
aDstOuter
.
Y
(
)
aDstInner
.
XMost
(
)
aDstInner
.
Y
(
)
aDstInner
.
X
(
)
)
RectWithEdgesTRBL
(
aSrcOuter
.
Y
(
)
aSrcInner
.
XMost
(
)
aSrcInner
.
Y
(
)
aSrcInner
.
X
(
)
)
aSkipRect
)
;
RepeatOrStretchSurface
(
aDestDrawTarget
aSourceBlur
RectWithEdgesTRBL
(
aDstInner
.
Y
(
)
aDstInner
.
X
(
)
aDstInner
.
YMost
(
)
aDstOuter
.
X
(
)
)
RectWithEdgesTRBL
(
aSrcInner
.
Y
(
)
aSrcInner
.
X
(
)
aSrcInner
.
YMost
(
)
aSrcOuter
.
X
(
)
)
aSkipRect
)
;
RepeatOrStretchSurface
(
aDestDrawTarget
aSourceBlur
RectWithEdgesTRBL
(
aDstInner
.
Y
(
)
aDstOuter
.
XMost
(
)
aDstInner
.
YMost
(
)
aDstInner
.
XMost
(
)
)
RectWithEdgesTRBL
(
aSrcInner
.
Y
(
)
aSrcOuter
.
XMost
(
)
aSrcInner
.
YMost
(
)
aSrcInner
.
XMost
(
)
)
aSkipRect
)
;
RepeatOrStretchSurface
(
aDestDrawTarget
aSourceBlur
RectWithEdgesTRBL
(
aDstInner
.
YMost
(
)
aDstInner
.
XMost
(
)
aDstOuter
.
YMost
(
)
aDstInner
.
X
(
)
)
RectWithEdgesTRBL
(
aSrcInner
.
YMost
(
)
aSrcInner
.
XMost
(
)
aSrcOuter
.
YMost
(
)
aSrcInner
.
X
(
)
)
aSkipRect
)
;
}
void
gfxAlphaBoxBlur
:
:
BlurRectangle
(
gfxContext
*
aDestinationCtx
const
gfxRect
&
aRect
RectCornerRadii
*
aCornerRadii
const
gfxPoint
&
aBlurStdDev
const
Color
&
aShadowColor
const
gfxRect
&
aDirtyRect
const
gfxRect
&
aSkipRect
)
{
IntSize
blurRadius
=
CalculateBlurRadius
(
aBlurStdDev
)
;
IntRect
rect
=
RoundedToInt
(
ToRect
(
aRect
)
)
;
IntMargin
extendDestBy
;
IntMargin
slice
;
RefPtr
<
SourceSurface
>
boxShadow
=
GetBlur
(
aDestinationCtx
rect
.
Size
(
)
blurRadius
aCornerRadii
aShadowColor
extendDestBy
slice
)
;
if
(
!
boxShadow
)
{
return
;
}
DrawTarget
&
destDrawTarget
=
*
aDestinationCtx
-
>
GetDrawTarget
(
)
;
destDrawTarget
.
PushClipRect
(
ToRect
(
aDirtyRect
)
)
;
Rect
srcOuter
(
Point
(
)
Size
(
boxShadow
-
>
GetSize
(
)
)
)
;
Rect
srcInner
=
srcOuter
;
srcInner
.
Deflate
(
Margin
(
slice
)
)
;
rect
.
Inflate
(
extendDestBy
)
;
Rect
dstOuter
(
rect
)
;
Rect
dstInner
(
rect
)
;
dstInner
.
Deflate
(
Margin
(
slice
)
)
;
Rect
skipRect
=
ToRect
(
aSkipRect
)
;
if
(
srcInner
.
IsEqualInterior
(
srcOuter
)
)
{
MOZ_ASSERT
(
dstInner
.
IsEqualInterior
(
dstOuter
)
)
;
destDrawTarget
.
DrawSurface
(
boxShadow
dstInner
srcInner
)
;
}
else
{
DrawBoxShadows
(
destDrawTarget
boxShadow
dstOuter
dstInner
srcOuter
srcInner
skipRect
)
;
RepeatOrStretchSurface
(
destDrawTarget
boxShadow
RectWithEdgesTRBL
(
dstInner
.
Y
(
)
dstInner
.
XMost
(
)
dstInner
.
YMost
(
)
dstInner
.
X
(
)
)
RectWithEdgesTRBL
(
srcInner
.
Y
(
)
srcInner
.
XMost
(
)
srcInner
.
YMost
(
)
srcInner
.
X
(
)
)
skipRect
)
;
}
destDrawTarget
.
PopClip
(
)
;
}
static
already_AddRefed
<
Path
>
GetBoxShadowInsetPath
(
DrawTarget
*
aDrawTarget
const
Rect
aOuterRect
const
Rect
aInnerRect
const
bool
aHasBorderRadius
const
RectCornerRadii
&
aInnerClipRadii
)
{
RefPtr
<
PathBuilder
>
builder
=
aDrawTarget
-
>
CreatePathBuilder
(
FillRule
:
:
FILL_EVEN_ODD
)
;
AppendRectToPath
(
builder
aOuterRect
true
)
;
if
(
aHasBorderRadius
)
{
AppendRoundedRectToPath
(
builder
aInnerRect
aInnerClipRadii
false
)
;
}
else
{
AppendRectToPath
(
builder
aInnerRect
false
)
;
}
return
builder
-
>
Finish
(
)
;
}
static
void
FillDestinationPath
(
gfxContext
*
aDestinationCtx
const
Rect
aDestinationRect
const
Rect
aShadowClipRect
const
Color
&
aShadowColor
const
bool
aHasBorderRadius
const
RectCornerRadii
&
aInnerClipRadii
)
{
aDestinationCtx
-
>
SetColor
(
aShadowColor
)
;
DrawTarget
*
destDrawTarget
=
aDestinationCtx
-
>
GetDrawTarget
(
)
;
RefPtr
<
Path
>
shadowPath
=
GetBoxShadowInsetPath
(
destDrawTarget
aDestinationRect
aShadowClipRect
aHasBorderRadius
aInnerClipRadii
)
;
aDestinationCtx
-
>
SetPath
(
shadowPath
)
;
aDestinationCtx
-
>
Fill
(
)
;
}
static
void
CacheInsetBlur
(
const
IntSize
aMinOuterSize
const
IntSize
aMinInnerSize
const
IntSize
&
aBlurRadius
const
RectCornerRadii
*
aCornerRadii
const
Color
&
aShadowColor
const
bool
&
aHasBorderRadius
BackendType
aBackendType
SourceSurface
*
aBoxShadow
)
{
bool
isInsetBlur
=
true
;
BlurCacheKey
key
(
aMinOuterSize
aMinInnerSize
aBlurRadius
aCornerRadii
aShadowColor
isInsetBlur
aHasBorderRadius
aBackendType
)
;
IntMargin
extendDestBy
(
0
0
0
0
)
;
BlurCacheData
*
data
=
new
BlurCacheData
(
aBoxShadow
extendDestBy
key
)
;
if
(
!
gBlurCache
-
>
RegisterEntry
(
data
)
)
{
delete
data
;
}
}
already_AddRefed
<
mozilla
:
:
gfx
:
:
SourceSurface
>
gfxAlphaBoxBlur
:
:
GetInsetBlur
(
const
mozilla
:
:
gfx
:
:
Rect
aOuterRect
const
mozilla
:
:
gfx
:
:
Rect
aWhitespaceRect
const
bool
aIsDestRect
const
mozilla
:
:
gfx
:
:
Color
&
aShadowColor
const
mozilla
:
:
gfx
:
:
IntSize
&
aBlurRadius
const
bool
aHasBorderRadius
const
RectCornerRadii
&
aInnerClipRadii
DrawTarget
*
aDestDrawTarget
)
{
if
(
!
gBlurCache
)
{
gBlurCache
=
new
BlurCache
(
)
;
}
IntSize
outerSize
(
(
int
)
aOuterRect
.
width
(
int
)
aOuterRect
.
height
)
;
IntSize
whitespaceSize
(
(
int
)
aWhitespaceRect
.
width
(
int
)
aWhitespaceRect
.
height
)
;
BlurCacheData
*
cached
=
gBlurCache
-
>
LookupInsetBoxShadow
(
outerSize
whitespaceSize
aBlurRadius
&
aInnerClipRadii
aShadowColor
aHasBorderRadius
aDestDrawTarget
-
>
GetBackendType
(
)
)
;
if
(
cached
&
&
!
aIsDestRect
)
{
RefPtr
<
SourceSurface
>
cachedBlur
=
cached
-
>
mBlur
;
return
cachedBlur
.
forget
(
)
;
}
Rect
blurRect
=
aIsDestRect
?
aOuterRect
:
aWhitespaceRect
;
IntSize
zeroSpread
(
0
0
)
;
gfxContext
*
minGfxContext
=
Init
(
ThebesRect
(
blurRect
)
zeroSpread
aBlurRadius
nullptr
nullptr
)
;
if
(
!
minGfxContext
)
{
return
nullptr
;
}
if
(
!
aIsDestRect
)
{
minGfxContext
-
>
SetMatrix
(
gfxMatrix
(
)
)
;
}
DrawTarget
*
minDrawTarget
=
minGfxContext
-
>
GetDrawTarget
(
)
;
RefPtr
<
Path
>
maskPath
=
GetBoxShadowInsetPath
(
minDrawTarget
aOuterRect
aWhitespaceRect
aHasBorderRadius
aInnerClipRadii
)
;
Color
black
(
0
.
f
0
.
f
0
.
f
1
.
f
)
;
minGfxContext
-
>
SetColor
(
black
)
;
minGfxContext
-
>
SetPath
(
maskPath
)
;
minGfxContext
-
>
Fill
(
)
;
IntPoint
topLeft
;
RefPtr
<
SourceSurface
>
minMask
=
DoBlur
(
minDrawTarget
&
topLeft
)
;
if
(
!
minMask
)
{
return
nullptr
;
}
RefPtr
<
SourceSurface
>
minInsetBlur
=
CreateBoxShadow
(
minMask
aShadowColor
)
;
if
(
!
minInsetBlur
)
{
return
nullptr
;
}
if
(
!
aIsDestRect
)
{
CacheInsetBlur
(
outerSize
whitespaceSize
aBlurRadius
&
aInnerClipRadii
aShadowColor
aHasBorderRadius
aDestDrawTarget
-
>
GetBackendType
(
)
minInsetBlur
)
;
}
return
minInsetBlur
.
forget
(
)
;
}
static
void
GetBlurMargins
(
const
bool
aHasBorderRadius
const
RectCornerRadii
&
aInnerClipRadii
const
IntSize
aBlurRadius
Margin
&
aOutBlurMargin
Margin
&
aOutInnerMargin
)
{
float
cornerWidth
=
0
;
float
cornerHeight
=
0
;
if
(
aHasBorderRadius
)
{
for
(
size_t
i
=
0
;
i
<
4
;
i
+
+
)
{
cornerWidth
=
std
:
:
max
(
cornerWidth
aInnerClipRadii
[
i
]
.
width
)
;
cornerHeight
=
std
:
:
max
(
cornerHeight
aInnerClipRadii
[
i
]
.
height
)
;
}
}
int
width
=
cornerWidth
+
aBlurRadius
.
width
;
int
height
=
cornerHeight
+
aBlurRadius
.
height
;
aOutInnerMargin
.
SizeTo
(
height
width
height
width
)
;
aOutBlurMargin
.
SizeTo
(
aBlurRadius
.
height
aBlurRadius
.
width
aBlurRadius
.
height
aBlurRadius
.
width
)
;
}
static
bool
GetInsetBoxShadowRects
(
const
Margin
aBlurMargin
const
Margin
aInnerMargin
const
Rect
aShadowClipRect
const
Rect
aDestinationRect
Rect
&
aOutWhitespaceRect
Rect
&
aOutOuterRect
)
{
Rect
insideWhiteSpace
(
aBlurMargin
.
left
aBlurMargin
.
top
aInnerMargin
.
LeftRight
(
)
+
1
aInnerMargin
.
TopBottom
(
)
+
1
)
;
bool
useDestRect
=
(
aShadowClipRect
.
width
<
=
aInnerMargin
.
LeftRight
(
)
)
|
|
(
aShadowClipRect
.
height
<
=
aInnerMargin
.
TopBottom
(
)
)
;
if
(
useDestRect
)
{
aOutWhitespaceRect
=
aShadowClipRect
;
aOutOuterRect
=
aDestinationRect
;
}
else
{
aOutWhitespaceRect
=
insideWhiteSpace
;
aOutOuterRect
=
aOutWhitespaceRect
;
aOutOuterRect
.
Inflate
(
aBlurMargin
)
;
}
return
useDestRect
;
}
void
gfxAlphaBoxBlur
:
:
BlurInsetBox
(
gfxContext
*
aDestinationCtx
const
Rect
aDestinationRect
const
Rect
aShadowClipRect
const
IntSize
aBlurRadius
const
IntSize
aSpreadRadius
const
Color
&
aShadowColor
bool
aHasBorderRadius
const
RectCornerRadii
&
aInnerClipRadii
const
Rect
aSkipRect
const
Point
aShadowOffset
)
{
if
(
(
aBlurRadius
.
width
=
=
0
&
&
aBlurRadius
.
height
=
=
0
)
|
|
aShadowClipRect
.
IsEmpty
(
)
)
{
FillDestinationPath
(
aDestinationCtx
aDestinationRect
aShadowClipRect
aShadowColor
aHasBorderRadius
aInnerClipRadii
)
;
return
;
}
DrawTarget
*
destDrawTarget
=
aDestinationCtx
-
>
GetDrawTarget
(
)
;
Margin
innerMargin
;
Margin
blurMargin
;
GetBlurMargins
(
aHasBorderRadius
aInnerClipRadii
aBlurRadius
blurMargin
innerMargin
)
;
Rect
whitespaceRect
;
Rect
outerRect
;
bool
useDestRect
=
GetInsetBoxShadowRects
(
blurMargin
innerMargin
aShadowClipRect
aDestinationRect
whitespaceRect
outerRect
)
;
RefPtr
<
SourceSurface
>
minBlur
=
GetInsetBlur
(
outerRect
whitespaceRect
useDestRect
aShadowColor
aBlurRadius
aHasBorderRadius
aInnerClipRadii
destDrawTarget
)
;
if
(
!
minBlur
)
{
return
;
}
if
(
useDestRect
)
{
IntSize
blurSize
=
minBlur
-
>
GetSize
(
)
;
Rect
srcBlur
(
0
0
blurSize
.
width
blurSize
.
height
)
;
Rect
destBlur
=
aDestinationRect
;
destBlur
.
Inflate
(
blurMargin
)
;
MOZ_ASSERT
(
srcBlur
.
Size
(
)
=
=
destBlur
.
Size
(
)
)
;
destDrawTarget
-
>
DrawSurface
(
minBlur
destBlur
srcBlur
)
;
}
else
{
Rect
srcOuter
(
outerRect
)
;
Rect
srcInner
(
srcOuter
)
;
srcInner
.
Deflate
(
blurMargin
)
;
srcInner
.
Deflate
(
innerMargin
)
;
Rect
outerFillRect
(
aShadowClipRect
)
;
outerFillRect
.
Inflate
(
blurMargin
)
;
FillDestinationPath
(
aDestinationCtx
aDestinationRect
outerFillRect
aShadowColor
false
RectCornerRadii
(
)
)
;
Rect
destRect
(
aShadowClipRect
)
;
destRect
.
Inflate
(
blurMargin
)
;
Rect
destInnerRect
(
aShadowClipRect
)
;
destInnerRect
.
Deflate
(
innerMargin
)
;
DrawBoxShadows
(
*
destDrawTarget
minBlur
destRect
destInnerRect
srcOuter
srcInner
aSkipRect
)
;
}
}
