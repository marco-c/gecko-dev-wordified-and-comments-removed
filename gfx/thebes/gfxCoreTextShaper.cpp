#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
gfxCoreTextShaper
.
h
"
#
include
"
gfxMacFont
.
h
"
#
include
"
gfxFontUtils
.
h
"
#
include
"
gfxTextRun
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
<
algorithm
>
#
include
<
dlfcn
.
h
>
using
namespace
mozilla
;
CTFontDescriptorRef
gfxCoreTextShaper
:
:
sFeaturesDescriptor
[
kMaxFontInstances
]
;
CFDictionaryRef
gfxCoreTextShaper
:
:
CreateAttrDict
(
bool
aRightToLeft
)
{
SInt16
dirOverride
=
kCTWritingDirectionOverride
|
(
aRightToLeft
?
kCTWritingDirectionRightToLeft
:
kCTWritingDirectionLeftToRight
)
;
CFNumberRef
dirNumber
=
:
:
CFNumberCreate
(
kCFAllocatorDefault
kCFNumberSInt16Type
&
dirOverride
)
;
CFArrayRef
dirArray
=
:
:
CFArrayCreate
(
kCFAllocatorDefault
(
const
void
*
*
)
&
dirNumber
1
&
kCFTypeArrayCallBacks
)
;
:
:
CFRelease
(
dirNumber
)
;
CFTypeRef
attrs
[
]
=
{
kCTFontAttributeName
kCTWritingDirectionAttributeName
}
;
CFTypeRef
values
[
]
=
{
mCTFont
[
0
]
dirArray
}
;
CFDictionaryRef
attrDict
=
:
:
CFDictionaryCreate
(
kCFAllocatorDefault
attrs
values
ArrayLength
(
attrs
)
&
kCFTypeDictionaryKeyCallBacks
&
kCFTypeDictionaryValueCallBacks
)
;
:
:
CFRelease
(
dirArray
)
;
return
attrDict
;
}
gfxCoreTextShaper
:
:
gfxCoreTextShaper
(
gfxMacFont
*
aFont
)
:
gfxFontShaper
(
aFont
)
mAttributesDictLTR
(
nullptr
)
mAttributesDictRTL
(
nullptr
)
{
for
(
size_t
i
=
0
;
i
<
kMaxFontInstances
;
i
+
+
)
{
mCTFont
[
i
]
=
nullptr
;
}
mCTFont
[
0
]
=
CreateCTFontWithFeatures
(
aFont
-
>
GetAdjustedSize
(
)
GetFeaturesDescriptor
(
kDefaultFeatures
)
)
;
}
gfxCoreTextShaper
:
:
~
gfxCoreTextShaper
(
)
{
if
(
mAttributesDictLTR
)
{
:
:
CFRelease
(
mAttributesDictLTR
)
;
}
if
(
mAttributesDictRTL
)
{
:
:
CFRelease
(
mAttributesDictRTL
)
;
}
for
(
size_t
i
=
0
;
i
<
kMaxFontInstances
;
i
+
+
)
{
if
(
mCTFont
[
i
]
)
{
:
:
CFRelease
(
mCTFont
[
i
]
)
;
}
}
}
static
bool
IsBuggyIndicScript
(
unicode
:
:
Script
aScript
)
{
return
aScript
=
=
unicode
:
:
Script
:
:
BENGALI
|
|
aScript
=
=
unicode
:
:
Script
:
:
KANNADA
|
|
aScript
=
=
unicode
:
:
Script
:
:
ORIYA
|
|
aScript
=
=
unicode
:
:
Script
:
:
KHMER
;
}
bool
gfxCoreTextShaper
:
:
ShapeText
(
DrawTarget
*
aDrawTarget
const
char16_t
*
aText
uint32_t
aOffset
uint32_t
aLength
Script
aScript
nsAtom
*
aLanguage
bool
aVertical
RoundingFlags
aRounding
gfxShapedText
*
aShapedText
)
{
bool
isRightToLeft
=
aShapedText
-
>
IsRightToLeft
(
)
;
const
UniChar
*
text
=
reinterpret_cast
<
const
UniChar
*
>
(
aText
)
;
CFStringRef
stringObj
=
:
:
CFStringCreateWithCharactersNoCopy
(
kCFAllocatorDefault
text
aLength
kCFAllocatorNull
)
;
const
gfxFontStyle
*
style
=
mFont
-
>
GetStyle
(
)
;
gfxFontEntry
*
entry
=
mFont
-
>
GetFontEntry
(
)
;
auto
handleFeatureTag
=
[
]
(
const
uint32_t
&
aTag
uint32_t
&
aValue
void
*
aUserArg
)
-
>
void
{
if
(
aTag
=
=
HB_TAG
(
'
s
'
'
m
'
'
c
'
'
p
'
)
&
&
aValue
)
{
*
static_cast
<
bool
*
>
(
aUserArg
)
=
true
;
}
}
;
bool
addSmallCaps
=
false
;
MergeFontFeatures
(
style
entry
-
>
mFeatureSettings
false
entry
-
>
FamilyName
(
)
false
handleFeatureTag
&
addSmallCaps
)
;
CFDictionaryRef
attrObj
=
isRightToLeft
?
mAttributesDictRTL
:
mAttributesDictLTR
;
if
(
!
attrObj
)
{
attrObj
=
CreateAttrDict
(
isRightToLeft
)
;
(
isRightToLeft
?
mAttributesDictRTL
:
mAttributesDictLTR
)
=
attrObj
;
}
FeatureFlags
featureFlags
=
kDefaultFeatures
;
if
(
IsBuggyIndicScript
(
aScript
)
)
{
featureFlags
|
=
kIndicFeatures
;
}
if
(
aShapedText
-
>
DisableLigatures
(
)
)
{
featureFlags
|
=
kDisableLigatures
;
}
if
(
addSmallCaps
)
{
featureFlags
|
=
kAddSmallCaps
;
}
CFMutableDictionaryRef
mutableAttr
=
nullptr
;
if
(
featureFlags
!
=
0
)
{
if
(
!
mCTFont
[
featureFlags
]
)
{
mCTFont
[
featureFlags
]
=
CreateCTFontWithFeatures
(
mFont
-
>
GetAdjustedSize
(
)
GetFeaturesDescriptor
(
featureFlags
)
)
;
}
mutableAttr
=
:
:
CFDictionaryCreateMutableCopy
(
kCFAllocatorDefault
2
attrObj
)
;
:
:
CFDictionaryReplaceValue
(
mutableAttr
kCTFontAttributeName
mCTFont
[
featureFlags
]
)
;
attrObj
=
mutableAttr
;
}
CFAttributedStringRef
attrStringObj
=
:
:
CFAttributedStringCreate
(
kCFAllocatorDefault
stringObj
attrObj
)
;
:
:
CFRelease
(
stringObj
)
;
CTLineRef
line
=
:
:
CTLineCreateWithAttributedString
(
attrStringObj
)
;
:
:
CFRelease
(
attrStringObj
)
;
CFArrayRef
glyphRuns
=
:
:
CTLineGetGlyphRuns
(
line
)
;
uint32_t
numRuns
=
:
:
CFArrayGetCount
(
glyphRuns
)
;
bool
success
=
true
;
for
(
uint32_t
runIndex
=
0
;
runIndex
<
numRuns
;
runIndex
+
+
)
{
CTRunRef
aCTRun
=
(
CTRunRef
)
:
:
CFArrayGetValueAtIndex
(
glyphRuns
runIndex
)
;
CFRange
range
=
:
:
CTRunGetStringRange
(
aCTRun
)
;
CFDictionaryRef
runAttr
=
:
:
CTRunGetAttributes
(
aCTRun
)
;
if
(
runAttr
!
=
attrObj
)
{
const
void
*
font1
=
:
:
CFDictionaryGetValue
(
attrObj
kCTFontAttributeName
)
;
const
void
*
font2
=
:
:
CFDictionaryGetValue
(
runAttr
kCTFontAttributeName
)
;
if
(
font1
!
=
font2
)
{
if
(
range
.
length
=
=
1
)
{
char16_t
ch
=
aText
[
range
.
location
]
;
if
(
gfxFontUtils
:
:
IsJoinControl
(
ch
)
|
|
gfxFontUtils
:
:
IsVarSelector
(
ch
)
)
{
continue
;
}
}
NS_WARNING
(
"
unexpected
font
fallback
in
Core
Text
"
)
;
success
=
false
;
break
;
}
}
if
(
SetGlyphsFromRun
(
aShapedText
aOffset
aLength
aCTRun
)
!
=
NS_OK
)
{
success
=
false
;
break
;
}
}
if
(
mutableAttr
)
{
:
:
CFRelease
(
mutableAttr
)
;
}
:
:
CFRelease
(
line
)
;
return
success
;
}
#
define
SMALL_GLYPH_RUN
\
128
/
/
preallocated
size
of
our
auto
arrays
for
per
-
glyph
data
;
nsresult
gfxCoreTextShaper
:
:
SetGlyphsFromRun
(
gfxShapedText
*
aShapedText
uint32_t
aOffset
uint32_t
aLength
CTRunRef
aCTRun
)
{
typedef
gfxShapedText
:
:
CompressedGlyph
CompressedGlyph
;
int32_t
direction
=
aShapedText
-
>
IsRightToLeft
(
)
?
-
1
:
1
;
int32_t
numGlyphs
=
:
:
CTRunGetGlyphCount
(
aCTRun
)
;
if
(
numGlyphs
=
=
0
)
{
return
NS_OK
;
}
int32_t
wordLength
=
aLength
;
CFRange
stringRange
=
:
:
CTRunGetStringRange
(
aCTRun
)
;
if
(
stringRange
.
location
+
stringRange
.
length
<
=
0
|
|
stringRange
.
location
>
=
wordLength
)
{
return
NS_OK
;
}
UniquePtr
<
CGGlyph
[
]
>
glyphsArray
;
UniquePtr
<
CGPoint
[
]
>
positionsArray
;
UniquePtr
<
CFIndex
[
]
>
glyphToCharArray
;
const
CGGlyph
*
glyphs
=
nullptr
;
const
CGPoint
*
positions
=
nullptr
;
const
CFIndex
*
glyphToChar
=
nullptr
;
glyphs
=
:
:
CTRunGetGlyphsPtr
(
aCTRun
)
;
if
(
!
glyphs
)
{
glyphsArray
=
MakeUniqueFallible
<
CGGlyph
[
]
>
(
numGlyphs
)
;
if
(
!
glyphsArray
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
:
:
CTRunGetGlyphs
(
aCTRun
:
:
CFRangeMake
(
0
0
)
glyphsArray
.
get
(
)
)
;
glyphs
=
glyphsArray
.
get
(
)
;
}
positions
=
:
:
CTRunGetPositionsPtr
(
aCTRun
)
;
if
(
!
positions
)
{
positionsArray
=
MakeUniqueFallible
<
CGPoint
[
]
>
(
numGlyphs
)
;
if
(
!
positionsArray
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
:
:
CTRunGetPositions
(
aCTRun
:
:
CFRangeMake
(
0
0
)
positionsArray
.
get
(
)
)
;
positions
=
positionsArray
.
get
(
)
;
}
glyphToChar
=
:
:
CTRunGetStringIndicesPtr
(
aCTRun
)
;
if
(
!
glyphToChar
)
{
glyphToCharArray
=
MakeUniqueFallible
<
CFIndex
[
]
>
(
numGlyphs
)
;
if
(
!
glyphToCharArray
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
:
:
CTRunGetStringIndices
(
aCTRun
:
:
CFRangeMake
(
0
0
)
glyphToCharArray
.
get
(
)
)
;
glyphToChar
=
glyphToCharArray
.
get
(
)
;
}
double
runWidth
=
:
:
CTRunGetTypographicBounds
(
aCTRun
:
:
CFRangeMake
(
0
0
)
nullptr
nullptr
nullptr
)
;
AutoTArray
<
gfxShapedText
:
:
DetailedGlyph
1
>
detailedGlyphs
;
CompressedGlyph
*
charGlyphs
=
aShapedText
-
>
GetCharacterGlyphs
(
)
+
aOffset
;
static
const
int32_t
NO_GLYPH
=
-
1
;
AutoTArray
<
int32_t
SMALL_GLYPH_RUN
>
charToGlyphArray
;
if
(
!
charToGlyphArray
.
SetLength
(
stringRange
.
length
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
int32_t
*
charToGlyph
=
charToGlyphArray
.
Elements
(
)
;
for
(
int32_t
offset
=
0
;
offset
<
stringRange
.
length
;
+
+
offset
)
{
charToGlyph
[
offset
]
=
NO_GLYPH
;
}
for
(
int32_t
i
=
0
;
i
<
numGlyphs
;
+
+
i
)
{
int32_t
loc
=
glyphToChar
[
i
]
-
stringRange
.
location
;
if
(
loc
>
=
0
&
&
loc
<
stringRange
.
length
)
{
charToGlyph
[
loc
]
=
i
;
}
}
bool
isRightToLeft
=
aShapedText
-
>
IsRightToLeft
(
)
;
int32_t
glyphStart
=
0
;
int32_t
charStart
=
isRightToLeft
?
stringRange
.
length
-
1
:
0
;
while
(
glyphStart
<
numGlyphs
)
{
bool
inOrder
=
true
;
int32_t
charEnd
=
glyphToChar
[
glyphStart
]
-
stringRange
.
location
;
NS_WARNING_ASSERTION
(
charEnd
>
=
0
&
&
charEnd
<
stringRange
.
length
"
glyph
-
to
-
char
mapping
points
outside
string
range
"
)
;
charEnd
=
std
:
:
max
(
charEnd
0
)
;
charEnd
=
std
:
:
min
(
charEnd
int32_t
(
stringRange
.
length
)
)
;
int32_t
glyphEnd
=
glyphStart
;
int32_t
charLimit
=
isRightToLeft
?
-
1
:
stringRange
.
length
;
do
{
NS_ASSERTION
(
(
direction
>
0
&
&
charEnd
<
charLimit
)
|
|
(
direction
<
0
&
&
charEnd
>
charLimit
)
"
no
characters
left
in
range
?
"
)
;
charEnd
+
=
direction
;
while
(
charEnd
!
=
charLimit
&
&
charToGlyph
[
charEnd
]
=
=
NO_GLYPH
)
{
charEnd
+
=
direction
;
}
if
(
isRightToLeft
)
{
for
(
int32_t
i
=
charStart
;
i
>
charEnd
;
-
-
i
)
{
if
(
charToGlyph
[
i
]
!
=
NO_GLYPH
)
{
glyphEnd
=
std
:
:
max
(
glyphEnd
charToGlyph
[
i
]
+
1
)
;
}
}
}
else
{
for
(
int32_t
i
=
charStart
;
i
<
charEnd
;
+
+
i
)
{
if
(
charToGlyph
[
i
]
!
=
NO_GLYPH
)
{
glyphEnd
=
std
:
:
max
(
glyphEnd
charToGlyph
[
i
]
+
1
)
;
}
}
}
if
(
glyphEnd
=
=
glyphStart
+
1
)
{
break
;
}
if
(
glyphEnd
=
=
glyphStart
)
{
continue
;
}
bool
allGlyphsAreWithinCluster
=
true
;
int32_t
prevGlyphCharIndex
=
charStart
;
for
(
int32_t
i
=
glyphStart
;
i
<
glyphEnd
;
+
+
i
)
{
int32_t
glyphCharIndex
=
glyphToChar
[
i
]
-
stringRange
.
location
;
if
(
isRightToLeft
)
{
if
(
glyphCharIndex
>
charStart
|
|
glyphCharIndex
<
=
charEnd
)
{
allGlyphsAreWithinCluster
=
false
;
break
;
}
if
(
glyphCharIndex
>
prevGlyphCharIndex
)
{
inOrder
=
false
;
}
prevGlyphCharIndex
=
glyphCharIndex
;
}
else
{
if
(
glyphCharIndex
<
charStart
|
|
glyphCharIndex
>
=
charEnd
)
{
allGlyphsAreWithinCluster
=
false
;
break
;
}
if
(
glyphCharIndex
<
prevGlyphCharIndex
)
{
inOrder
=
false
;
}
prevGlyphCharIndex
=
glyphCharIndex
;
}
}
if
(
allGlyphsAreWithinCluster
)
{
break
;
}
}
while
(
charEnd
!
=
charLimit
)
;
NS_WARNING_ASSERTION
(
glyphStart
<
glyphEnd
"
character
/
glyph
clump
contains
no
glyphs
!
"
)
;
if
(
glyphStart
=
=
glyphEnd
)
{
+
+
glyphStart
;
charStart
=
charEnd
;
continue
;
}
NS_WARNING_ASSERTION
(
charStart
!
=
charEnd
"
character
/
glyph
clump
contains
no
characters
!
"
)
;
if
(
charStart
=
=
charEnd
)
{
glyphStart
=
glyphEnd
;
continue
;
}
int32_t
baseCharIndex
endCharIndex
;
if
(
isRightToLeft
)
{
while
(
charEnd
>
=
0
&
&
charToGlyph
[
charEnd
]
=
=
NO_GLYPH
)
{
charEnd
-
-
;
}
baseCharIndex
=
charEnd
+
stringRange
.
location
+
1
;
endCharIndex
=
charStart
+
stringRange
.
location
+
1
;
}
else
{
while
(
charEnd
<
stringRange
.
length
&
&
charToGlyph
[
charEnd
]
=
=
NO_GLYPH
)
{
charEnd
+
+
;
}
baseCharIndex
=
charStart
+
stringRange
.
location
;
endCharIndex
=
charEnd
+
stringRange
.
location
;
}
if
(
endCharIndex
<
=
0
|
|
baseCharIndex
>
=
wordLength
)
{
glyphStart
=
glyphEnd
;
charStart
=
charEnd
;
continue
;
}
baseCharIndex
=
std
:
:
max
(
baseCharIndex
0
)
;
endCharIndex
=
std
:
:
min
(
endCharIndex
wordLength
)
;
int32_t
appUnitsPerDevUnit
=
aShapedText
-
>
GetAppUnitsPerDevUnit
(
)
;
double
toNextGlyph
;
if
(
glyphStart
<
numGlyphs
-
1
)
{
toNextGlyph
=
positions
[
glyphStart
+
1
]
.
x
-
positions
[
glyphStart
]
.
x
;
}
else
{
toNextGlyph
=
positions
[
0
]
.
x
+
runWidth
-
positions
[
glyphStart
]
.
x
;
}
int32_t
advance
=
int32_t
(
toNextGlyph
*
appUnitsPerDevUnit
)
;
int32_t
glyphsInClump
=
glyphEnd
-
glyphStart
;
if
(
glyphsInClump
=
=
1
&
&
gfxTextRun
:
:
CompressedGlyph
:
:
IsSimpleGlyphID
(
glyphs
[
glyphStart
]
)
&
&
gfxTextRun
:
:
CompressedGlyph
:
:
IsSimpleAdvance
(
advance
)
&
&
charGlyphs
[
baseCharIndex
]
.
IsClusterStart
(
)
&
&
positions
[
glyphStart
]
.
y
=
=
0
.
0
)
{
charGlyphs
[
baseCharIndex
]
.
SetSimpleGlyph
(
advance
glyphs
[
glyphStart
]
)
;
}
else
{
while
(
true
)
{
gfxTextRun
:
:
DetailedGlyph
*
details
=
detailedGlyphs
.
AppendElement
(
)
;
details
-
>
mGlyphID
=
glyphs
[
glyphStart
]
;
details
-
>
mOffset
.
y
=
-
positions
[
glyphStart
]
.
y
*
appUnitsPerDevUnit
;
details
-
>
mAdvance
=
advance
;
if
(
+
+
glyphStart
>
=
glyphEnd
)
{
break
;
}
if
(
glyphStart
<
numGlyphs
-
1
)
{
toNextGlyph
=
positions
[
glyphStart
+
1
]
.
x
-
positions
[
glyphStart
]
.
x
;
}
else
{
toNextGlyph
=
positions
[
0
]
.
x
+
runWidth
-
positions
[
glyphStart
]
.
x
;
}
advance
=
int32_t
(
toNextGlyph
*
appUnitsPerDevUnit
)
;
}
aShapedText
-
>
SetDetailedGlyphs
(
aOffset
+
baseCharIndex
detailedGlyphs
.
Length
(
)
detailedGlyphs
.
Elements
(
)
)
;
detailedGlyphs
.
Clear
(
)
;
}
while
(
+
+
baseCharIndex
!
=
endCharIndex
&
&
baseCharIndex
<
wordLength
)
{
CompressedGlyph
&
shapedTextGlyph
=
charGlyphs
[
baseCharIndex
]
;
NS_ASSERTION
(
!
shapedTextGlyph
.
IsSimpleGlyph
(
)
"
overwriting
a
simple
glyph
"
)
;
shapedTextGlyph
.
SetComplex
(
inOrder
&
&
shapedTextGlyph
.
IsClusterStart
(
)
false
)
;
}
glyphStart
=
glyphEnd
;
charStart
=
charEnd
;
}
return
NS_OK
;
}
#
undef
SMALL_GLYPH_RUN
#
define
MAX_FEATURES
5
/
/
max
used
by
any
of
our
Get
*
Descriptor
functions
CTFontDescriptorRef
gfxCoreTextShaper
:
:
CreateFontFeaturesDescriptor
(
const
std
:
:
pair
<
SInt16
SInt16
>
*
aFeatures
size_t
aCount
)
{
MOZ_ASSERT
(
aCount
<
=
MAX_FEATURES
)
;
CFDictionaryRef
featureSettings
[
MAX_FEATURES
]
;
for
(
size_t
i
=
0
;
i
<
aCount
;
i
+
+
)
{
CFNumberRef
type
=
:
:
CFNumberCreate
(
kCFAllocatorDefault
kCFNumberSInt16Type
&
aFeatures
[
i
]
.
first
)
;
CFNumberRef
selector
=
:
:
CFNumberCreate
(
kCFAllocatorDefault
kCFNumberSInt16Type
&
aFeatures
[
i
]
.
second
)
;
CFTypeRef
keys
[
]
=
{
kCTFontFeatureTypeIdentifierKey
kCTFontFeatureSelectorIdentifierKey
}
;
CFTypeRef
values
[
]
=
{
type
selector
}
;
featureSettings
[
i
]
=
:
:
CFDictionaryCreate
(
kCFAllocatorDefault
(
const
void
*
*
)
keys
(
const
void
*
*
)
values
ArrayLength
(
keys
)
&
kCFTypeDictionaryKeyCallBacks
&
kCFTypeDictionaryValueCallBacks
)
;
:
:
CFRelease
(
selector
)
;
:
:
CFRelease
(
type
)
;
}
CFArrayRef
featuresArray
=
:
:
CFArrayCreate
(
kCFAllocatorDefault
(
const
void
*
*
)
featureSettings
aCount
&
kCFTypeArrayCallBacks
)
;
for
(
size_t
i
=
0
;
i
<
aCount
;
i
+
+
)
{
:
:
CFRelease
(
featureSettings
[
i
]
)
;
}
const
CFTypeRef
attrKeys
[
]
=
{
kCTFontFeatureSettingsAttribute
}
;
const
CFTypeRef
attrValues
[
]
=
{
featuresArray
}
;
CFDictionaryRef
attributesDict
=
:
:
CFDictionaryCreate
(
kCFAllocatorDefault
(
const
void
*
*
)
attrKeys
(
const
void
*
*
)
attrValues
ArrayLength
(
attrKeys
)
&
kCFTypeDictionaryKeyCallBacks
&
kCFTypeDictionaryValueCallBacks
)
;
:
:
CFRelease
(
featuresArray
)
;
CTFontDescriptorRef
descriptor
=
:
:
CTFontDescriptorCreateWithAttributes
(
attributesDict
)
;
:
:
CFRelease
(
attributesDict
)
;
return
descriptor
;
}
CTFontDescriptorRef
gfxCoreTextShaper
:
:
GetFeaturesDescriptor
(
FeatureFlags
aFeatureFlags
)
{
MOZ_ASSERT
(
aFeatureFlags
<
kMaxFontInstances
)
;
if
(
!
sFeaturesDescriptor
[
aFeatureFlags
]
)
{
typedef
std
:
:
pair
<
SInt16
SInt16
>
FeatT
;
AutoTArray
<
FeatT
MAX_FEATURES
>
features
;
features
.
AppendElement
(
FeatT
(
kSmartSwashType
kLineFinalSwashesOffSelector
)
)
;
if
(
(
aFeatureFlags
&
kIndicFeatures
)
=
=
0
)
{
features
.
AppendElement
(
FeatT
(
kSmartSwashType
kLineInitialSwashesOffSelector
)
)
;
}
if
(
aFeatureFlags
&
kAddSmallCaps
)
{
features
.
AppendElement
(
FeatT
(
kLetterCaseType
kSmallCapsSelector
)
)
;
features
.
AppendElement
(
FeatT
(
kLowerCaseType
kLowerCaseSmallCapsSelector
)
)
;
}
if
(
aFeatureFlags
&
kDisableLigatures
)
{
features
.
AppendElement
(
FeatT
(
kLigaturesType
kCommonLigaturesOffSelector
)
)
;
}
MOZ_ASSERT
(
features
.
Length
(
)
<
=
MAX_FEATURES
)
;
sFeaturesDescriptor
[
aFeatureFlags
]
=
CreateFontFeaturesDescriptor
(
features
.
Elements
(
)
features
.
Length
(
)
)
;
}
return
sFeaturesDescriptor
[
aFeatureFlags
]
;
}
CTFontRef
gfxCoreTextShaper
:
:
CreateCTFontWithFeatures
(
CGFloat
aSize
CTFontDescriptorRef
aDescriptor
)
{
const
gfxFontEntry
*
fe
=
mFont
-
>
GetFontEntry
(
)
;
bool
isInstalledFont
=
!
fe
-
>
IsUserFont
(
)
|
|
fe
-
>
IsLocalUserFont
(
)
;
CGFontRef
cgFont
=
static_cast
<
gfxMacFont
*
>
(
mFont
)
-
>
GetCGFontRef
(
)
;
return
gfxMacFont
:
:
CreateCTFontFromCGFontWithVariations
(
cgFont
aSize
isInstalledFont
aDescriptor
)
;
}
void
gfxCoreTextShaper
:
:
Shutdown
(
)
{
for
(
size_t
i
=
0
;
i
<
kMaxFontInstances
;
i
+
+
)
{
if
(
sFeaturesDescriptor
[
i
]
!
=
nullptr
)
{
:
:
CFRelease
(
sFeaturesDescriptor
[
i
]
)
;
sFeaturesDescriptor
[
i
]
=
nullptr
;
}
}
}
