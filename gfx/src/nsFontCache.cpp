#
include
"
nsFontCache
.
h
"
#
include
"
gfxTextRun
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
ServoUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsPresContext
.
h
"
using
mozilla
:
:
services
:
:
GetObserverService
;
NS_IMPL_ISUPPORTS
(
nsFontCache
nsIObserver
)
static
mozilla
:
:
LazyLogModule
gFingerprinterDetection
(
"
FingerprinterDetection
"
)
;
void
nsFontCache
:
:
Init
(
nsPresContext
*
aContext
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
mContext
=
aContext
;
nsCOMPtr
<
nsIObserverService
>
obs
=
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
AddObserver
(
this
"
memory
-
pressure
"
false
)
;
}
mLocaleLanguage
=
nsLanguageAtomService
:
:
GetService
(
)
-
>
GetLocaleLanguage
(
)
;
if
(
!
mLocaleLanguage
)
{
mLocaleLanguage
=
NS_Atomize
(
"
x
-
western
"
)
;
}
}
void
nsFontCache
:
:
Destroy
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
this
"
memory
-
pressure
"
)
;
}
Flush
(
)
;
}
NS_IMETHODIMP
nsFontCache
:
:
Observe
(
nsISupports
*
const
char
*
aTopic
const
char16_t
*
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
memory
-
pressure
"
)
)
{
Compact
(
)
;
}
return
NS_OK
;
}
already_AddRefed
<
nsFontMetrics
>
nsFontCache
:
:
GetMetricsFor
(
const
nsFont
&
aFont
const
nsFontMetrics
:
:
Params
&
aParams
)
{
mozilla
:
:
AssertIsMainThreadOrServoFontMetricsLocked
(
)
;
nsAtom
*
language
=
aParams
.
language
&
&
!
aParams
.
language
-
>
IsEmpty
(
)
?
aParams
.
language
:
mLocaleLanguage
.
get
(
)
;
const
int32_t
n
=
mFontMetrics
.
Length
(
)
-
1
;
for
(
int32_t
i
=
n
;
i
>
=
0
;
-
-
i
)
{
nsFontMetrics
*
fm
=
mFontMetrics
.
Elements
(
)
[
i
]
;
if
(
fm
-
>
Font
(
)
.
Equals
(
aFont
)
&
&
fm
-
>
GetUserFontSet
(
)
=
=
aParams
.
userFontSet
&
&
fm
-
>
Language
(
)
=
=
language
&
&
fm
-
>
Orientation
(
)
=
=
aParams
.
orientation
&
&
#
ifdef
XP_WIN
fm
-
>
AllowForceGDIClassic
(
)
=
=
aParams
.
allowForceGDIClassic
&
&
#
endif
fm
-
>
ExplicitLanguage
(
)
=
=
aParams
.
explicitLanguage
)
{
if
(
i
!
=
n
)
{
mFontMetrics
.
RemoveElementAtUnsafe
(
i
)
;
mFontMetrics
.
AppendElement
(
fm
)
;
}
fm
-
>
GetThebesFontGroup
(
)
-
>
UpdateUserFonts
(
)
;
return
do_AddRef
(
fm
)
;
}
}
DetectFontFingerprinting
(
aFont
)
;
if
(
n
>
=
kMaxCacheEntries
-
1
&
&
!
mFlushPending
)
{
if
(
NS_IsMainThread
(
)
)
{
Flush
(
mFontMetrics
.
Length
(
)
-
kMaxCacheEntries
/
2
)
;
}
else
{
mFlushPending
=
true
;
nsCOMPtr
<
nsIRunnable
>
flushTask
=
new
FlushFontMetricsTask
(
this
)
;
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
flushTask
)
)
;
}
}
nsFontMetrics
:
:
Params
params
=
aParams
;
params
.
language
=
language
;
RefPtr
<
nsFontMetrics
>
fm
=
new
nsFontMetrics
(
aFont
params
mContext
)
;
mFontMetrics
.
AppendElement
(
do_AddRef
(
fm
)
.
take
(
)
)
;
return
fm
.
forget
(
)
;
}
void
nsFontCache
:
:
DetectFontFingerprinting
(
const
nsFont
&
aFont
)
{
if
(
aFont
.
family
.
families
.
list
.
IsEmpty
(
)
)
{
return
;
}
if
(
!
MOZ_LOG_TEST
(
gFingerprinterDetection
mozilla
:
:
LogLevel
:
:
Info
)
&
&
mReportedProbableFingerprinting
)
{
return
;
}
PRTime
now
=
PR_Now
(
)
;
nsAutoString
key
;
for
(
const
auto
&
family
:
aFont
.
family
.
families
.
list
.
AsSpan
(
)
)
{
if
(
family
.
IsGeneric
(
)
)
{
continue
;
}
key
.
Append
(
family
.
AsFamilyName
(
)
.
name
.
AsAtom
(
)
-
>
GetUTF16String
(
)
)
;
}
if
(
key
.
IsEmpty
(
)
)
{
return
;
}
auto
missedFonts
=
mMissedFontFamilyNames
.
Lock
(
)
;
missedFonts
-
>
InsertOrUpdate
(
key
now
)
;
if
(
missedFonts
-
>
Count
(
)
<
=
kFingerprintingCacheMissThreshold
)
{
return
;
}
uint16_t
fontsMissedRecently
=
0
;
bool
clearMissedFonts
=
false
;
if
(
!
mReportedProbableFingerprinting
)
{
for
(
auto
iter
=
missedFonts
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
now
-
kFingerprintingLastNSec
<
=
iter
.
Data
(
)
)
{
if
(
+
+
fontsMissedRecently
>
kFingerprintingCacheMissThreshold
)
{
mContext
-
>
Document
(
)
-
>
RecordFontFingerprinting
(
)
;
mReportedProbableFingerprinting
=
true
;
clearMissedFonts
=
true
;
break
;
}
}
else
{
iter
.
Remove
(
)
;
}
}
if
(
mReportedProbableFingerprinting
)
{
for
(
auto
iter
=
missedFonts
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
MOZ_LOG
(
gFingerprinterDetection
mozilla
:
:
LogLevel
:
:
Info
(
"
Font
Fingerprinting
Tripped
|
Document
%
p
|
Font
Family
|
%
s
"
mContext
-
>
Document
(
)
NS_ConvertUTF16toUTF8
(
iter
.
Key
(
)
)
.
get
(
)
)
)
;
}
}
}
else
{
MOZ_LOG
(
gFingerprinterDetection
mozilla
:
:
LogLevel
:
:
Info
(
"
Font
Fingerprinting
Tripped
|
Document
%
p
|
Font
Family
|
%
s
"
mContext
-
>
Document
(
)
NS_ConvertUTF16toUTF8
(
key
)
.
get
(
)
)
)
;
}
if
(
!
MOZ_LOG_TEST
(
gFingerprinterDetection
mozilla
:
:
LogLevel
:
:
Info
)
&
&
clearMissedFonts
)
{
missedFonts
-
>
Clear
(
)
;
}
}
void
nsFontCache
:
:
UpdateUserFonts
(
gfxUserFontSet
*
aUserFontSet
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
nsFontMetrics
*
fm
:
mFontMetrics
)
{
gfxFontGroup
*
fg
=
fm
-
>
GetThebesFontGroup
(
)
;
if
(
fg
-
>
GetUserFontSet
(
)
=
=
aUserFontSet
)
{
fg
-
>
UpdateUserFonts
(
)
;
}
}
}
void
nsFontCache
:
:
FontMetricsDeleted
(
const
nsFontMetrics
*
aFontMetrics
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
mFontMetrics
.
RemoveElement
(
aFontMetrics
)
;
}
void
nsFontCache
:
:
Compact
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
int32_t
i
=
mFontMetrics
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
nsFontMetrics
*
fm
=
mFontMetrics
[
i
]
;
nsFontMetrics
*
oldfm
=
fm
;
NS_RELEASE
(
fm
)
;
if
(
mFontMetrics
.
IndexOf
(
oldfm
)
!
=
mFontMetrics
.
NoIndex
)
{
NS_ADDREF
(
oldfm
)
;
}
}
auto
missedFonts
=
mMissedFontFamilyNames
.
Lock
(
)
;
missedFonts
-
>
Clear
(
)
;
}
void
nsFontCache
:
:
Flush
(
int32_t
aFlushCount
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
int32_t
n
=
aFlushCount
<
0
?
mFontMetrics
.
Length
(
)
:
std
:
:
min
<
int32_t
>
(
aFlushCount
mFontMetrics
.
Length
(
)
)
;
for
(
int32_t
i
=
n
-
1
;
i
>
=
0
;
-
-
i
)
{
nsFontMetrics
*
fm
=
mFontMetrics
[
i
]
;
fm
-
>
Destroy
(
)
;
NS_RELEASE
(
fm
)
;
}
mFontMetrics
.
RemoveElementsAt
(
0
n
)
;
}
