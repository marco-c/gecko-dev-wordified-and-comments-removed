#
ifndef
mozilla_X11Util_h
#
define
mozilla_X11Util_h
#
if
defined
(
MOZ_WIDGET_GTK
)
#
include
<
gdk
/
gdk
.
h
>
#
include
<
gdk
/
gdkx
.
h
>
#
include
"
X11UndefineNone
.
h
"
#
else
#
error
Unknown
toolkit
#
endif
#
include
<
string
.
h
>
#
include
"
mozilla
/
Scoped
.
h
"
namespace
mozilla
{
inline
Display
*
DefaultXDisplay
(
)
{
#
if
defined
(
MOZ_WIDGET_GTK
)
GdkDisplay
*
gdkDisplay
=
gdk_display_get_default
(
)
;
if
(
GDK_IS_X11_DISPLAY
(
gdkDisplay
)
)
{
return
GDK_DISPLAY_XDISPLAY
(
gdkDisplay
)
;
}
#
endif
return
nullptr
;
}
void
FindVisualAndDepth
(
Display
*
aDisplay
VisualID
aVisualID
Visual
*
*
aVisual
int
*
aDepth
)
;
void
FinishX
(
Display
*
aDisplay
)
;
template
<
typename
T
>
struct
ScopedXFreePtrTraits
{
typedef
T
*
type
;
static
T
*
empty
(
)
{
return
nullptr
;
}
static
void
release
(
T
*
ptr
)
{
if
(
ptr
!
=
nullptr
)
XFree
(
ptr
)
;
}
}
;
SCOPED_TEMPLATE
(
ScopedXFree
ScopedXFreePtrTraits
)
class
ScopedXErrorHandler
{
public
:
struct
ErrorEvent
{
XErrorEvent
mError
;
ErrorEvent
(
)
{
memset
(
this
0
sizeof
(
ErrorEvent
)
)
;
}
}
;
private
:
ErrorEvent
mXError
;
static
ErrorEvent
*
sXErrorPtr
;
ErrorEvent
*
mOldXErrorPtr
;
int
(
*
mOldErrorHandler
)
(
Display
*
XErrorEvent
*
)
;
public
:
static
int
ErrorHandler
(
Display
*
XErrorEvent
*
ev
)
;
explicit
ScopedXErrorHandler
(
bool
aAllowOffMainThread
=
false
)
;
~
ScopedXErrorHandler
(
)
;
bool
SyncAndGetError
(
Display
*
dpy
XErrorEvent
*
ev
=
nullptr
)
;
}
;
class
OffMainThreadScopedXErrorHandler
:
public
ScopedXErrorHandler
{
public
:
OffMainThreadScopedXErrorHandler
(
)
:
ScopedXErrorHandler
(
true
)
{
}
}
;
}
#
endif
