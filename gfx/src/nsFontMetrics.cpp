#
include
"
nsFontMetrics
.
h
"
#
include
<
math
.
h
>
#
include
<
algorithm
>
#
include
"
gfxContext
.
h
"
#
include
"
gfxFontConstants
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxPoint
.
h
"
#
include
"
gfxRect
.
h
"
#
include
"
gfxTextRun
.
h
"
#
include
"
gfxTypes
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsBoundingMetrics
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsMathUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
class
gfxUserFontSet
;
using
namespace
mozilla
;
namespace
{
class
AutoTextRun
{
public
:
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
AutoTextRun
(
nsFontMetrics
*
aMetrics
DrawTarget
*
aDrawTarget
const
char
*
aString
int32_t
aLength
)
{
mTextRun
=
aMetrics
-
>
GetThebesFontGroup
(
)
-
>
MakeTextRun
(
reinterpret_cast
<
const
uint8_t
*
>
(
aString
)
aLength
aDrawTarget
aMetrics
-
>
AppUnitsPerDevPixel
(
)
ComputeFlags
(
aMetrics
)
nsTextFrameUtils
:
:
Flags
(
)
nullptr
)
;
}
AutoTextRun
(
nsFontMetrics
*
aMetrics
DrawTarget
*
aDrawTarget
const
char16_t
*
aString
int32_t
aLength
)
{
mTextRun
=
aMetrics
-
>
GetThebesFontGroup
(
)
-
>
MakeTextRun
(
aString
aLength
aDrawTarget
aMetrics
-
>
AppUnitsPerDevPixel
(
)
ComputeFlags
(
aMetrics
)
nsTextFrameUtils
:
:
Flags
(
)
nullptr
)
;
}
gfxTextRun
*
get
(
)
{
return
mTextRun
.
get
(
)
;
}
gfxTextRun
*
operator
-
>
(
)
{
return
mTextRun
.
get
(
)
;
}
private
:
static
gfx
:
:
ShapedTextFlags
ComputeFlags
(
nsFontMetrics
*
aMetrics
)
{
gfx
:
:
ShapedTextFlags
flags
=
gfx
:
:
ShapedTextFlags
(
)
;
if
(
aMetrics
-
>
GetTextRunRTL
(
)
)
{
flags
|
=
gfx
:
:
ShapedTextFlags
:
:
TEXT_IS_RTL
;
}
if
(
aMetrics
-
>
GetVertical
(
)
)
{
switch
(
aMetrics
-
>
GetTextOrientation
(
)
)
{
case
StyleTextOrientation
:
:
Mixed
:
flags
|
=
gfx
:
:
ShapedTextFlags
:
:
TEXT_ORIENT_VERTICAL_MIXED
;
break
;
case
StyleTextOrientation
:
:
Upright
:
flags
|
=
gfx
:
:
ShapedTextFlags
:
:
TEXT_ORIENT_VERTICAL_UPRIGHT
;
break
;
case
StyleTextOrientation
:
:
Sideways
:
flags
|
=
gfx
:
:
ShapedTextFlags
:
:
TEXT_ORIENT_VERTICAL_SIDEWAYS_RIGHT
;
break
;
}
}
return
flags
;
}
RefPtr
<
gfxTextRun
>
mTextRun
;
}
;
class
StubPropertyProvider
final
:
public
gfxTextRun
:
:
PropertyProvider
{
public
:
void
GetHyphenationBreaks
(
gfxTextRun
:
:
Range
aRange
gfxTextRun
:
:
HyphenType
*
aBreakBefore
)
const
override
{
NS_ERROR
(
"
This
shouldn
'
t
be
called
because
we
never
call
BreakAndMeasureText
"
)
;
}
mozilla
:
:
StyleHyphens
GetHyphensOption
(
)
const
override
{
NS_ERROR
(
"
This
shouldn
'
t
be
called
because
we
never
call
BreakAndMeasureText
"
)
;
return
mozilla
:
:
StyleHyphens
:
:
None
;
}
gfxFloat
GetHyphenWidth
(
)
const
override
{
NS_ERROR
(
"
This
shouldn
'
t
be
called
because
we
never
enable
hyphens
"
)
;
return
0
;
}
already_AddRefed
<
mozilla
:
:
gfx
:
:
DrawTarget
>
GetDrawTarget
(
)
const
override
{
NS_ERROR
(
"
This
shouldn
'
t
be
called
because
we
never
enable
hyphens
"
)
;
return
nullptr
;
}
uint32_t
GetAppUnitsPerDevUnit
(
)
const
override
{
NS_ERROR
(
"
This
shouldn
'
t
be
called
because
we
never
enable
hyphens
"
)
;
return
60
;
}
void
GetSpacing
(
gfxTextRun
:
:
Range
aRange
Spacing
*
aSpacing
)
const
override
{
NS_ERROR
(
"
This
shouldn
'
t
be
called
because
we
never
enable
spacing
"
)
;
}
gfx
:
:
ShapedTextFlags
GetShapedTextFlags
(
)
const
override
{
NS_ERROR
(
"
This
shouldn
'
t
be
called
because
we
never
enable
hyphens
"
)
;
return
gfx
:
:
ShapedTextFlags
(
)
;
}
}
;
}
nsFontMetrics
:
:
nsFontMetrics
(
const
nsFont
&
aFont
const
Params
&
aParams
nsPresContext
*
aContext
)
:
mFont
(
aFont
)
mLanguage
(
aParams
.
language
)
mPresContext
(
aContext
)
mP2A
(
aContext
-
>
DeviceContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
mOrientation
(
aParams
.
orientation
)
mExplicitLanguage
(
aParams
.
explicitLanguage
)
mTextRunRTL
(
false
)
mVertical
(
false
)
mTextOrientation
(
mozilla
:
:
StyleTextOrientation
:
:
Mixed
)
{
gfxFontStyle
style
(
aFont
.
style
aFont
.
weight
aFont
.
stretch
gfxFloat
(
aFont
.
size
.
ToAppUnits
(
)
)
/
mP2A
aFont
.
sizeAdjust
aFont
.
family
.
is_system_font
aContext
-
>
DeviceContext
(
)
-
>
IsPrinterContext
(
)
aFont
.
synthesis
&
NS_FONT_SYNTHESIS_WEIGHT
aFont
.
synthesis
&
NS_FONT_SYNTHESIS_STYLE
aFont
.
synthesis
&
NS_FONT_SYNTHESIS_SMALL_CAPS
aFont
.
languageOverride
)
;
aFont
.
AddFontFeaturesToStyle
(
&
style
mOrientation
=
=
eVertical
)
;
style
.
featureValueLookup
=
aParams
.
featureValueLookup
;
aFont
.
AddFontVariationsToStyle
(
&
style
)
;
gfxFloat
devToCssSize
=
gfxFloat
(
mP2A
)
/
gfxFloat
(
AppUnitsPerCSSPixel
(
)
)
;
mFontGroup
=
new
gfxFontGroup
(
mPresContext
aFont
.
family
.
families
&
style
mLanguage
mExplicitLanguage
aParams
.
textPerf
aParams
.
userFontSet
devToCssSize
aFont
.
variantEmoji
)
;
}
nsFontMetrics
:
:
~
nsFontMetrics
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mPresContext
)
{
mPresContext
-
>
FontMetricsDeleted
(
this
)
;
}
}
void
nsFontMetrics
:
:
Destroy
(
)
{
mPresContext
=
nullptr
;
}
#
define
ROUND_TO_TWIPS
(
x
)
(
nscoord
)
floor
(
(
(
x
)
*
mP2A
)
+
0
.
5
)
#
define
CEIL_TO_TWIPS
(
x
)
(
nscoord
)
ceil
(
(
x
)
*
mP2A
)
static
const
gfxFont
:
:
Metrics
&
GetMetrics
(
nsFontMetrics
*
aFontMetrics
nsFontMetrics
:
:
FontOrientation
aOrientation
)
{
RefPtr
<
gfxFont
>
font
=
aFontMetrics
-
>
GetThebesFontGroup
(
)
-
>
GetFirstValidFont
(
)
;
return
font
-
>
GetMetrics
(
aOrientation
)
;
}
static
const
gfxFont
:
:
Metrics
&
GetMetrics
(
nsFontMetrics
*
aFontMetrics
)
{
return
GetMetrics
(
aFontMetrics
aFontMetrics
-
>
Orientation
(
)
)
;
}
nscoord
nsFontMetrics
:
:
XHeight
(
)
{
return
ROUND_TO_TWIPS
(
GetMetrics
(
this
)
.
xHeight
)
;
}
nscoord
nsFontMetrics
:
:
CapHeight
(
)
{
return
ROUND_TO_TWIPS
(
GetMetrics
(
this
)
.
capHeight
)
;
}
nscoord
nsFontMetrics
:
:
SuperscriptOffset
(
)
{
return
ROUND_TO_TWIPS
(
GetMetrics
(
this
)
.
emHeight
*
NS_FONT_SUPERSCRIPT_OFFSET_RATIO
)
;
}
nscoord
nsFontMetrics
:
:
SubscriptOffset
(
)
{
return
ROUND_TO_TWIPS
(
GetMetrics
(
this
)
.
emHeight
*
NS_FONT_SUBSCRIPT_OFFSET_RATIO
)
;
}
void
nsFontMetrics
:
:
GetStrikeout
(
nscoord
&
aOffset
nscoord
&
aSize
)
{
aOffset
=
ROUND_TO_TWIPS
(
GetMetrics
(
this
)
.
strikeoutOffset
)
;
aSize
=
ROUND_TO_TWIPS
(
GetMetrics
(
this
)
.
strikeoutSize
)
;
}
void
nsFontMetrics
:
:
GetUnderline
(
nscoord
&
aOffset
nscoord
&
aSize
)
{
aOffset
=
ROUND_TO_TWIPS
(
mFontGroup
-
>
GetUnderlineOffset
(
)
)
;
aSize
=
ROUND_TO_TWIPS
(
GetMetrics
(
this
)
.
underlineSize
)
;
}
static
gfxFloat
ComputeMaxDescent
(
const
gfxFont
:
:
Metrics
&
aMetrics
gfxFontGroup
*
aFontGroup
)
{
gfxFloat
offset
=
floor
(
-
aFontGroup
-
>
GetUnderlineOffset
(
)
+
0
.
5
)
;
gfxFloat
size
=
NS_round
(
aMetrics
.
underlineSize
)
;
gfxFloat
minDescent
=
offset
+
size
;
return
floor
(
std
:
:
max
(
minDescent
aMetrics
.
maxDescent
)
+
0
.
5
)
;
}
static
gfxFloat
ComputeMaxAscent
(
const
gfxFont
:
:
Metrics
&
aMetrics
)
{
return
floor
(
aMetrics
.
maxAscent
+
0
.
5
)
;
}
nscoord
nsFontMetrics
:
:
InternalLeading
(
)
{
return
ROUND_TO_TWIPS
(
GetMetrics
(
this
)
.
internalLeading
)
;
}
nscoord
nsFontMetrics
:
:
ExternalLeading
(
)
{
return
ROUND_TO_TWIPS
(
GetMetrics
(
this
)
.
externalLeading
)
;
}
nscoord
nsFontMetrics
:
:
EmHeight
(
)
{
return
ROUND_TO_TWIPS
(
GetMetrics
(
this
)
.
emHeight
)
;
}
nscoord
nsFontMetrics
:
:
EmAscent
(
)
{
return
ROUND_TO_TWIPS
(
GetMetrics
(
this
)
.
emAscent
)
;
}
nscoord
nsFontMetrics
:
:
EmDescent
(
)
{
return
ROUND_TO_TWIPS
(
GetMetrics
(
this
)
.
emDescent
)
;
}
nscoord
nsFontMetrics
:
:
MaxHeight
(
)
{
return
CEIL_TO_TWIPS
(
ComputeMaxAscent
(
GetMetrics
(
this
)
)
)
+
CEIL_TO_TWIPS
(
ComputeMaxDescent
(
GetMetrics
(
this
)
mFontGroup
)
)
;
}
nscoord
nsFontMetrics
:
:
MaxAscent
(
)
{
return
CEIL_TO_TWIPS
(
ComputeMaxAscent
(
GetMetrics
(
this
)
)
)
;
}
nscoord
nsFontMetrics
:
:
MaxDescent
(
)
{
return
CEIL_TO_TWIPS
(
ComputeMaxDescent
(
GetMetrics
(
this
)
mFontGroup
)
)
;
}
nscoord
nsFontMetrics
:
:
MaxAdvance
(
)
{
return
CEIL_TO_TWIPS
(
GetMetrics
(
this
)
.
maxAdvance
)
;
}
nscoord
nsFontMetrics
:
:
AveCharWidth
(
)
{
return
CEIL_TO_TWIPS
(
GetMetrics
(
this
)
.
aveCharWidth
)
;
}
nscoord
nsFontMetrics
:
:
SpaceWidth
(
)
{
return
CEIL_TO_TWIPS
(
GetMetrics
(
this
mVertical
&
&
mTextOrientation
=
=
StyleTextOrientation
:
:
Upright
?
eVertical
:
eHorizontal
)
.
spaceWidth
)
;
}
int32_t
nsFontMetrics
:
:
GetMaxStringLength
(
)
{
const
gfxFont
:
:
Metrics
&
m
=
GetMetrics
(
this
)
;
const
double
x
=
32767
.
0
/
std
:
:
max
(
1
.
0
m
.
maxAdvance
)
;
int32_t
len
=
(
int32_t
)
floor
(
x
)
;
return
std
:
:
max
(
1
len
)
;
}
nscoord
nsFontMetrics
:
:
GetWidth
(
const
char
*
aString
uint32_t
aLength
DrawTarget
*
aDrawTarget
)
{
if
(
aLength
=
=
0
)
return
0
;
if
(
aLength
=
=
1
&
&
aString
[
0
]
=
=
'
'
)
return
SpaceWidth
(
)
;
StubPropertyProvider
provider
;
AutoTextRun
textRun
(
this
aDrawTarget
aString
aLength
)
;
if
(
textRun
.
get
(
)
)
{
return
NSToCoordRound
(
textRun
-
>
GetAdvanceWidth
(
gfxTextRun
:
:
Range
(
0
aLength
)
&
provider
)
)
;
}
return
0
;
}
nscoord
nsFontMetrics
:
:
GetWidth
(
const
char16_t
*
aString
uint32_t
aLength
DrawTarget
*
aDrawTarget
)
{
if
(
aLength
=
=
0
)
return
0
;
if
(
aLength
=
=
1
&
&
aString
[
0
]
=
=
'
'
)
return
SpaceWidth
(
)
;
StubPropertyProvider
provider
;
AutoTextRun
textRun
(
this
aDrawTarget
aString
aLength
)
;
if
(
textRun
.
get
(
)
)
{
return
NSToCoordRound
(
textRun
-
>
GetAdvanceWidth
(
gfxTextRun
:
:
Range
(
0
aLength
)
&
provider
)
)
;
}
return
0
;
}
void
nsFontMetrics
:
:
DrawString
(
const
char
*
aString
uint32_t
aLength
nscoord
aX
nscoord
aY
gfxContext
*
aContext
)
{
if
(
aLength
=
=
0
)
return
;
StubPropertyProvider
provider
;
AutoTextRun
textRun
(
this
aContext
-
>
GetDrawTarget
(
)
aString
aLength
)
;
if
(
!
textRun
.
get
(
)
)
{
return
;
}
gfx
:
:
Point
pt
(
aX
aY
)
;
gfxTextRun
:
:
Range
range
(
0
aLength
)
;
if
(
mTextRunRTL
)
{
if
(
mVertical
)
{
pt
.
y
+
=
textRun
-
>
GetAdvanceWidth
(
range
&
provider
)
;
}
else
{
pt
.
x
+
=
textRun
-
>
GetAdvanceWidth
(
range
&
provider
)
;
}
}
gfxTextRun
:
:
DrawParams
params
(
aContext
)
;
params
.
provider
=
&
provider
;
textRun
-
>
Draw
(
range
pt
params
)
;
}
void
nsFontMetrics
:
:
DrawString
(
const
char16_t
*
aString
uint32_t
aLength
nscoord
aX
nscoord
aY
gfxContext
*
aContext
DrawTarget
*
aTextRunConstructionDrawTarget
)
{
if
(
aLength
=
=
0
)
return
;
StubPropertyProvider
provider
;
AutoTextRun
textRun
(
this
aTextRunConstructionDrawTarget
aString
aLength
)
;
if
(
!
textRun
.
get
(
)
)
{
return
;
}
gfx
:
:
Point
pt
(
aX
aY
)
;
gfxTextRun
:
:
Range
range
(
0
aLength
)
;
if
(
mTextRunRTL
)
{
if
(
mVertical
)
{
pt
.
y
+
=
textRun
-
>
GetAdvanceWidth
(
range
&
provider
)
;
}
else
{
pt
.
x
+
=
textRun
-
>
GetAdvanceWidth
(
range
&
provider
)
;
}
}
gfxTextRun
:
:
DrawParams
params
(
aContext
)
;
params
.
provider
=
&
provider
;
textRun
-
>
Draw
(
range
pt
params
)
;
}
static
nsBoundingMetrics
GetTextBoundingMetrics
(
nsFontMetrics
*
aMetrics
const
char16_t
*
aString
uint32_t
aLength
mozilla
:
:
gfx
:
:
DrawTarget
*
aDrawTarget
gfxFont
:
:
BoundingBoxType
aType
)
{
if
(
aLength
=
=
0
)
return
nsBoundingMetrics
(
)
;
StubPropertyProvider
provider
;
AutoTextRun
textRun
(
aMetrics
aDrawTarget
aString
aLength
)
;
nsBoundingMetrics
m
;
if
(
textRun
.
get
(
)
)
{
gfxTextRun
:
:
Metrics
theMetrics
=
textRun
-
>
MeasureText
(
gfxTextRun
:
:
Range
(
0
aLength
)
aType
aDrawTarget
&
provider
)
;
m
.
leftBearing
=
NSToCoordFloor
(
theMetrics
.
mBoundingBox
.
X
(
)
)
;
m
.
rightBearing
=
NSToCoordCeil
(
theMetrics
.
mBoundingBox
.
XMost
(
)
)
;
m
.
ascent
=
NSToCoordCeil
(
-
theMetrics
.
mBoundingBox
.
Y
(
)
)
;
m
.
descent
=
NSToCoordCeil
(
theMetrics
.
mBoundingBox
.
YMost
(
)
)
;
m
.
width
=
NSToCoordRound
(
theMetrics
.
mAdvanceWidth
)
;
}
return
m
;
}
nsBoundingMetrics
nsFontMetrics
:
:
GetBoundingMetrics
(
const
char16_t
*
aString
uint32_t
aLength
DrawTarget
*
aDrawTarget
)
{
return
GetTextBoundingMetrics
(
this
aString
aLength
aDrawTarget
gfxFont
:
:
TIGHT_HINTED_OUTLINE_EXTENTS
)
;
}
nsBoundingMetrics
nsFontMetrics
:
:
GetInkBoundsForInkOverflow
(
const
char16_t
*
aString
uint32_t
aLength
DrawTarget
*
aDrawTarget
)
{
return
GetTextBoundingMetrics
(
this
aString
aLength
aDrawTarget
gfxFont
:
:
LOOSE_INK_EXTENTS
)
;
}
gfxUserFontSet
*
nsFontMetrics
:
:
GetUserFontSet
(
)
const
{
return
mFontGroup
-
>
GetUserFontSet
(
)
;
}
