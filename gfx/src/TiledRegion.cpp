#
include
"
TiledRegion
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
fallible
.
h
"
namespace
mozilla
{
namespace
gfx
{
static
const
int32_t
kTileSize
=
256
;
static
const
size_t
kMaxTiles
=
1000
;
static
pixman_box32_t
IntersectionOfNonEmptyBoxes
(
const
pixman_box32_t
&
aBox1
const
pixman_box32_t
&
aBox2
)
{
return
pixman_box32_t
{
std
:
:
max
(
aBox1
.
x1
aBox2
.
x1
)
std
:
:
max
(
aBox1
.
y1
aBox2
.
y1
)
std
:
:
min
(
aBox1
.
x2
aBox2
.
x2
)
std
:
:
min
(
aBox1
.
y2
aBox2
.
y2
)
}
;
}
class
TileIterator
{
public
:
TileIterator
(
const
pixman_box32_t
&
aTileBounds
const
IntPoint
&
aPosition
)
:
mTileBounds
(
aTileBounds
)
mPos
(
aPosition
)
{
}
bool
operator
!
=
(
const
TileIterator
&
aOther
)
{
return
mPos
!
=
aOther
.
mPos
;
}
bool
operator
=
=
(
const
TileIterator
&
aOther
)
{
return
mPos
=
=
aOther
.
mPos
;
}
IntPoint
operator
*
(
)
const
{
return
mPos
;
}
const
TileIterator
&
operator
+
+
(
)
{
mPos
.
x
+
=
kTileSize
;
if
(
mPos
.
x
>
=
mTileBounds
.
x2
)
{
mPos
.
x
=
mTileBounds
.
x1
;
mPos
.
y
+
=
kTileSize
;
}
return
*
this
;
}
TileIterator
&
operator
=
(
const
IntPoint
&
aPosition
)
{
mPos
=
aPosition
;
return
*
this
;
}
bool
IsBeforeTileContainingPoint
(
const
IntPoint
&
aPoint
)
const
{
return
(
mPos
.
y
+
kTileSize
)
<
=
aPoint
.
y
|
|
(
mPos
.
y
<
=
aPoint
.
y
&
&
(
mPos
.
x
+
kTileSize
)
<
=
aPoint
.
x
)
;
}
bool
IsAtTileContainingPoint
(
const
IntPoint
&
aPoint
)
const
{
return
mPos
.
y
<
=
aPoint
.
y
&
&
aPoint
.
y
<
(
mPos
.
y
+
kTileSize
)
&
&
mPos
.
x
<
=
aPoint
.
x
&
&
aPoint
.
x
<
(
mPos
.
x
+
kTileSize
)
;
}
pixman_box32_t
IntersectionWith
(
const
pixman_box32_t
&
aRect
)
const
{
pixman_box32_t
tile
=
{
mPos
.
x
mPos
.
y
mPos
.
x
+
kTileSize
mPos
.
y
+
kTileSize
}
;
return
IntersectionOfNonEmptyBoxes
(
tile
aRect
)
;
}
private
:
const
pixman_box32_t
&
mTileBounds
;
IntPoint
mPos
;
}
;
class
TileRange
{
public
:
TileRange
(
const
pixman_box32_t
&
aTileBounds
const
IntPoint
&
aStart
const
IntPoint
&
aEnd
)
:
mTileBounds
(
aTileBounds
)
mStart
(
aStart
)
mEnd
(
aEnd
)
{
}
explicit
TileRange
(
const
pixman_box32_t
&
aTileBounds
)
:
mTileBounds
(
aTileBounds
)
mStart
(
mTileBounds
.
x1
mTileBounds
.
y1
)
mEnd
(
mTileBounds
.
x1
mTileBounds
.
y2
)
{
}
TileIterator
Begin
(
)
const
{
return
TileIterator
(
mTileBounds
mStart
)
;
}
TileIterator
End
(
)
const
{
return
TileIterator
(
mTileBounds
mEnd
)
;
}
size_t
Length
(
)
const
{
if
(
mEnd
.
y
=
=
mStart
.
y
)
{
return
(
mEnd
.
x
-
mStart
.
x
)
/
kTileSize
;
}
int64_t
numberOfFullRows
=
(
(
(
int64_t
)
mEnd
.
y
-
(
int64_t
)
mStart
.
y
)
/
kTileSize
)
-
1
;
int64_t
tilesInFirstRow
=
(
(
int64_t
)
mTileBounds
.
x2
-
(
int64_t
)
mStart
.
x
)
/
kTileSize
;
int64_t
tilesInLastRow
=
(
(
int64_t
)
mEnd
.
x
-
(
int64_t
)
mTileBounds
.
x1
)
/
kTileSize
;
int64_t
tilesInFullRow
=
(
(
int64_t
)
mTileBounds
.
x2
-
(
int64_t
)
mTileBounds
.
x1
)
/
kTileSize
;
int64_t
total
=
tilesInFirstRow
+
(
tilesInFullRow
*
numberOfFullRows
)
+
tilesInLastRow
;
MOZ_ASSERT
(
total
>
0
)
;
return
(
(
uint64_t
)
total
>
(
uint64_t
)
SIZE_MAX
)
?
SIZE_MAX
:
(
size_t
)
total
;
}
IntPoint
MoveIntoBounds
(
const
IntPoint
&
aTileOrigin
)
const
{
IntPoint
p
=
aTileOrigin
;
if
(
p
.
x
<
mTileBounds
.
x1
)
{
p
.
x
=
mTileBounds
.
x1
;
}
else
if
(
p
.
x
>
=
mTileBounds
.
x2
)
{
p
.
x
=
mTileBounds
.
x1
;
p
.
y
+
=
kTileSize
;
}
if
(
p
.
y
<
mTileBounds
.
y1
)
{
p
.
y
=
mTileBounds
.
y1
;
p
.
x
=
mTileBounds
.
x1
;
}
else
if
(
p
.
y
>
=
mTileBounds
.
y2
)
{
p
.
x
=
mTileBounds
.
x1
;
p
.
y
=
mTileBounds
.
y2
;
}
return
p
;
}
private
:
const
pixman_box32_t
&
mTileBounds
;
const
IntPoint
mStart
;
const
IntPoint
mEnd
;
}
;
static
IntPoint
TileContainingPoint
(
const
IntPoint
&
aPoint
)
{
return
IntPoint
(
RoundDownToMultiple
(
aPoint
.
x
kTileSize
)
RoundDownToMultiple
(
aPoint
.
y
kTileSize
)
)
;
}
enum
class
IterationAction
:
uint8_t
{
CONTINUE
STOP
}
;
enum
class
IterationEndReason
:
uint8_t
{
NOT_STOPPED
STOPPED
}
;
template
<
typename
HandleEmptyTilesFunction
typename
HandleNonEmptyTileFunction
typename
RectArrayT
>
IterationEndReason
ProcessIntersectedTiles
(
const
pixman_box32_t
&
aRect
RectArrayT
&
aRectArray
HandleEmptyTilesFunction
aHandleEmptyTiles
HandleNonEmptyTileFunction
aHandleNonEmptyTile
)
{
pixman_box32_t
tileBounds
=
{
RoundDownToMultiple
(
aRect
.
x1
kTileSize
)
RoundDownToMultiple
(
aRect
.
y1
kTileSize
)
RoundUpToMultiple
(
aRect
.
x2
kTileSize
)
RoundUpToMultiple
(
aRect
.
y2
kTileSize
)
}
;
if
(
tileBounds
.
x2
<
tileBounds
.
x1
|
|
tileBounds
.
y2
<
tileBounds
.
y1
)
{
return
IterationEndReason
:
:
STOPPED
;
}
TileRange
tileRange
(
tileBounds
)
;
TileIterator
rangeEnd
=
tileRange
.
End
(
)
;
TileIterator
tileIterator
=
tileRange
.
Begin
(
)
;
for
(
size_t
i
=
0
;
i
<
aRectArray
.
Length
(
)
&
&
tileIterator
!
=
rangeEnd
;
i
+
+
)
{
MOZ_ASSERT
(
aRectArray
[
i
]
.
x1
<
aRectArray
[
i
]
.
x2
&
&
aRectArray
[
i
]
.
y1
<
aRectArray
[
i
]
.
y2
"
empty
rect
"
)
;
IntPoint
rectOrigin
(
aRectArray
[
i
]
.
x1
aRectArray
[
i
]
.
y1
)
;
if
(
tileIterator
.
IsBeforeTileContainingPoint
(
rectOrigin
)
)
{
IntPoint
tileOrigin
=
TileContainingPoint
(
rectOrigin
)
;
IntPoint
afterEmptyTiles
=
tileRange
.
MoveIntoBounds
(
tileOrigin
)
;
TileRange
emptyTiles
(
tileBounds
*
tileIterator
afterEmptyTiles
)
;
if
(
aHandleEmptyTiles
(
aRectArray
i
emptyTiles
)
=
=
IterationAction
:
:
STOP
)
{
return
IterationEndReason
:
:
STOPPED
;
}
tileIterator
=
afterEmptyTiles
;
if
(
tileIterator
=
=
rangeEnd
)
{
return
IterationEndReason
:
:
NOT_STOPPED
;
}
}
if
(
tileIterator
.
IsAtTileContainingPoint
(
rectOrigin
)
)
{
pixman_box32_t
rectIntersection
=
tileIterator
.
IntersectionWith
(
aRect
)
;
if
(
aHandleNonEmptyTile
(
aRectArray
i
rectIntersection
)
=
=
IterationAction
:
:
STOP
)
{
return
IterationEndReason
:
:
STOPPED
;
}
+
+
tileIterator
;
}
}
if
(
tileIterator
!
=
rangeEnd
)
{
size_t
endIndex
=
aRectArray
.
Length
(
)
;
TileRange
emptyTiles
(
tileBounds
*
tileIterator
*
rangeEnd
)
;
if
(
aHandleEmptyTiles
(
aRectArray
endIndex
emptyTiles
)
=
=
IterationAction
:
:
STOP
)
{
return
IterationEndReason
:
:
STOPPED
;
}
}
return
IterationEndReason
:
:
NOT_STOPPED
;
}
static
pixman_box32_t
UnionBoundsOfNonEmptyBoxes
(
const
pixman_box32_t
&
aBox1
const
pixman_box32_t
&
aBox2
)
{
return
{
std
:
:
min
(
aBox1
.
x1
aBox2
.
x1
)
std
:
:
min
(
aBox1
.
y1
aBox2
.
y1
)
std
:
:
max
(
aBox1
.
x2
aBox2
.
x2
)
std
:
:
max
(
aBox1
.
y2
aBox2
.
y2
)
}
;
}
bool
TiledRegionImpl
:
:
AddRect
(
const
pixman_box32_t
&
aRect
)
{
return
ProcessIntersectedTiles
(
aRect
mRects
[
&
aRect
]
(
nsTArray
<
pixman_box32_t
>
&
rects
size_t
&
rectIndex
TileRange
emptyTiles
)
{
if
(
rects
.
Length
(
)
+
emptyTiles
.
Length
(
)
>
=
kMaxTiles
|
|
!
rects
.
InsertElementsAt
(
rectIndex
emptyTiles
.
Length
(
)
fallible
)
)
{
return
IterationAction
:
:
STOP
;
}
for
(
TileIterator
tileIt
=
emptyTiles
.
Begin
(
)
;
tileIt
!
=
emptyTiles
.
End
(
)
;
+
+
tileIt
+
+
rectIndex
)
{
rects
[
rectIndex
]
=
tileIt
.
IntersectionWith
(
aRect
)
;
}
return
IterationAction
:
:
CONTINUE
;
}
[
]
(
nsTArray
<
pixman_box32_t
>
&
rects
size_t
rectIndex
const
pixman_box32_t
&
rectIntersectionWithTile
)
{
rects
[
rectIndex
]
=
UnionBoundsOfNonEmptyBoxes
(
rects
[
rectIndex
]
rectIntersectionWithTile
)
;
return
IterationAction
:
:
CONTINUE
;
}
)
=
=
IterationEndReason
:
:
NOT_STOPPED
;
}
static
bool
NonEmptyBoxesIntersect
(
const
pixman_box32_t
&
aBox1
const
pixman_box32_t
&
aBox2
)
{
return
aBox1
.
x1
<
aBox2
.
x2
&
&
aBox2
.
x1
<
aBox1
.
x2
&
&
aBox1
.
y1
<
aBox2
.
y2
&
&
aBox2
.
y1
<
aBox1
.
y2
;
}
bool
TiledRegionImpl
:
:
Intersects
(
const
pixman_box32_t
&
aRect
)
const
{
return
ProcessIntersectedTiles
(
aRect
mRects
[
]
(
const
nsTArray
<
pixman_box32_t
>
&
rects
size_t
&
rectIndex
TileRange
emptyTiles
)
{
return
IterationAction
:
:
CONTINUE
;
}
[
]
(
const
nsTArray
<
pixman_box32_t
>
&
rects
size_t
rectIndex
const
pixman_box32_t
&
rectIntersectionWithTile
)
{
if
(
NonEmptyBoxesIntersect
(
rects
[
rectIndex
]
rectIntersectionWithTile
)
)
{
return
IterationAction
:
:
STOP
;
}
return
IterationAction
:
:
CONTINUE
;
}
)
=
=
IterationEndReason
:
:
STOPPED
;
}
static
bool
NonEmptyBoxContainsNonEmptyBox
(
const
pixman_box32_t
&
aBox1
const
pixman_box32_t
&
aBox2
)
{
return
aBox1
.
x1
<
=
aBox2
.
x1
&
&
aBox2
.
x2
<
=
aBox1
.
x2
&
&
aBox1
.
y1
<
=
aBox2
.
y1
&
&
aBox2
.
y2
<
=
aBox1
.
y2
;
}
bool
TiledRegionImpl
:
:
Contains
(
const
pixman_box32_t
&
aRect
)
const
{
return
ProcessIntersectedTiles
(
aRect
mRects
[
]
(
const
nsTArray
<
pixman_box32_t
>
&
rects
size_t
&
rectIndex
TileRange
emptyTiles
)
{
return
IterationAction
:
:
STOP
;
}
[
]
(
const
nsTArray
<
pixman_box32_t
>
&
rects
size_t
rectIndex
const
pixman_box32_t
&
rectIntersectionWithTile
)
{
if
(
!
NonEmptyBoxContainsNonEmptyBox
(
rects
[
rectIndex
]
rectIntersectionWithTile
)
)
{
return
IterationAction
:
:
STOP
;
}
return
IterationAction
:
:
CONTINUE
;
}
)
=
=
IterationEndReason
:
:
NOT_STOPPED
;
}
}
}
