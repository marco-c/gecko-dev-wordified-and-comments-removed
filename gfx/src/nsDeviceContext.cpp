#
include
"
nsDeviceContext
.
h
"
#
include
<
algorithm
>
#
include
"
gfxASurface
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxFont
.
h
"
#
include
"
gfxImageSurface
.
h
"
#
include
"
gfxPoint
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
gfx
/
PathHelpers
.
h
"
#
include
"
mozilla
/
gfx
/
PrintTarget
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsFont
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsIAtom
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIDeviceContextSpec
.
h
"
#
include
"
nsILanguageAtomService
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIScreen
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
mozilla
:
:
services
:
:
GetObserverService
;
class
nsFontCache
final
:
public
nsIObserver
{
public
:
nsFontCache
(
)
{
MOZ_COUNT_CTOR
(
nsFontCache
)
;
}
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
void
Init
(
nsDeviceContext
*
aContext
)
;
void
Destroy
(
)
;
already_AddRefed
<
nsFontMetrics
>
GetMetricsFor
(
const
nsFont
&
aFont
const
nsFontMetrics
:
:
Params
&
aParams
)
;
void
FontMetricsDeleted
(
const
nsFontMetrics
*
aFontMetrics
)
;
void
Compact
(
)
;
void
Flush
(
)
;
protected
:
~
nsFontCache
(
)
{
MOZ_COUNT_DTOR
(
nsFontCache
)
;
}
nsDeviceContext
*
mContext
;
nsCOMPtr
<
nsIAtom
>
mLocaleLanguage
;
nsTArray
<
nsFontMetrics
*
>
mFontMetrics
;
}
;
NS_IMPL_ISUPPORTS
(
nsFontCache
nsIObserver
)
void
nsFontCache
:
:
Init
(
nsDeviceContext
*
aContext
)
{
mContext
=
aContext
;
nsCOMPtr
<
nsIObserverService
>
obs
=
GetObserverService
(
)
;
if
(
obs
)
obs
-
>
AddObserver
(
this
"
memory
-
pressure
"
false
)
;
nsCOMPtr
<
nsILanguageAtomService
>
langService
;
langService
=
do_GetService
(
NS_LANGUAGEATOMSERVICE_CONTRACTID
)
;
if
(
langService
)
{
mLocaleLanguage
=
langService
-
>
GetLocaleLanguage
(
)
;
}
if
(
!
mLocaleLanguage
)
{
mLocaleLanguage
=
NS_Atomize
(
"
x
-
western
"
)
;
}
}
void
nsFontCache
:
:
Destroy
(
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
GetObserverService
(
)
;
if
(
obs
)
obs
-
>
RemoveObserver
(
this
"
memory
-
pressure
"
)
;
Flush
(
)
;
}
NS_IMETHODIMP
nsFontCache
:
:
Observe
(
nsISupports
*
const
char
*
aTopic
const
char16_t
*
)
{
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
memory
-
pressure
"
)
)
Compact
(
)
;
return
NS_OK
;
}
already_AddRefed
<
nsFontMetrics
>
nsFontCache
:
:
GetMetricsFor
(
const
nsFont
&
aFont
const
nsFontMetrics
:
:
Params
&
aParams
)
{
nsIAtom
*
language
=
aParams
.
language
?
aParams
.
language
:
mLocaleLanguage
.
get
(
)
;
int32_t
n
=
mFontMetrics
.
Length
(
)
-
1
;
for
(
int32_t
i
=
n
;
i
>
=
0
;
-
-
i
)
{
nsFontMetrics
*
fm
=
mFontMetrics
[
i
]
;
if
(
fm
-
>
Font
(
)
.
Equals
(
aFont
)
&
&
fm
-
>
GetUserFontSet
(
)
=
=
aParams
.
userFontSet
&
&
fm
-
>
Language
(
)
=
=
language
&
&
fm
-
>
Orientation
(
)
=
=
aParams
.
orientation
)
{
if
(
i
!
=
n
)
{
mFontMetrics
.
RemoveElementAt
(
i
)
;
mFontMetrics
.
AppendElement
(
fm
)
;
}
fm
-
>
GetThebesFontGroup
(
)
-
>
UpdateUserFonts
(
)
;
return
do_AddRef
(
fm
)
;
}
}
nsFontMetrics
:
:
Params
params
=
aParams
;
params
.
language
=
language
;
RefPtr
<
nsFontMetrics
>
fm
=
new
nsFontMetrics
(
aFont
params
mContext
)
;
mFontMetrics
.
AppendElement
(
do_AddRef
(
fm
.
get
(
)
)
.
take
(
)
)
;
return
fm
.
forget
(
)
;
}
void
nsFontCache
:
:
FontMetricsDeleted
(
const
nsFontMetrics
*
aFontMetrics
)
{
mFontMetrics
.
RemoveElement
(
aFontMetrics
)
;
}
void
nsFontCache
:
:
Compact
(
)
{
for
(
int32_t
i
=
mFontMetrics
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
nsFontMetrics
*
fm
=
mFontMetrics
[
i
]
;
nsFontMetrics
*
oldfm
=
fm
;
NS_RELEASE
(
fm
)
;
if
(
mFontMetrics
.
IndexOf
(
oldfm
)
!
=
mFontMetrics
.
NoIndex
)
{
NS_ADDREF
(
oldfm
)
;
}
}
}
void
nsFontCache
:
:
Flush
(
)
{
for
(
int32_t
i
=
mFontMetrics
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
nsFontMetrics
*
fm
=
mFontMetrics
[
i
]
;
fm
-
>
Destroy
(
)
;
NS_RELEASE
(
fm
)
;
}
mFontMetrics
.
Clear
(
)
;
}
nsDeviceContext
:
:
nsDeviceContext
(
)
:
mWidth
(
0
)
mHeight
(
0
)
mDepth
(
0
)
mAppUnitsPerDevPixel
(
-
1
)
mAppUnitsPerDevPixelAtUnitFullZoom
(
-
1
)
mAppUnitsPerPhysicalInch
(
-
1
)
mFullZoom
(
1
.
0f
)
mPrintingScale
(
1
.
0f
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
nsDeviceContext
created
off
main
thread
"
)
;
}
nsDeviceContext
:
:
~
nsDeviceContext
(
)
{
if
(
mFontCache
)
{
mFontCache
-
>
Destroy
(
)
;
}
}
already_AddRefed
<
nsFontMetrics
>
nsDeviceContext
:
:
GetMetricsFor
(
const
nsFont
&
aFont
const
nsFontMetrics
:
:
Params
&
aParams
)
{
if
(
!
mFontCache
)
{
mFontCache
=
new
nsFontCache
(
)
;
mFontCache
-
>
Init
(
this
)
;
}
return
mFontCache
-
>
GetMetricsFor
(
aFont
aParams
)
;
}
nsresult
nsDeviceContext
:
:
FlushFontCache
(
void
)
{
if
(
mFontCache
)
mFontCache
-
>
Flush
(
)
;
return
NS_OK
;
}
nsresult
nsDeviceContext
:
:
FontMetricsDeleted
(
const
nsFontMetrics
*
aFontMetrics
)
{
if
(
mFontCache
)
{
mFontCache
-
>
FontMetricsDeleted
(
aFontMetrics
)
;
}
return
NS_OK
;
}
bool
nsDeviceContext
:
:
IsPrinterSurface
(
)
{
return
mPrintTarget
!
=
nullptr
;
}
void
nsDeviceContext
:
:
SetDPI
(
double
*
aScale
)
{
float
dpi
=
-
1
.
0f
;
if
(
mDeviceContextSpec
)
{
dpi
=
mDeviceContextSpec
-
>
GetDPI
(
)
;
mPrintingScale
=
mDeviceContextSpec
-
>
GetPrintingScale
(
)
;
mAppUnitsPerDevPixelAtUnitFullZoom
=
NS_lround
(
(
AppUnitsPerCSSPixel
(
)
*
96
)
/
dpi
)
;
}
else
{
int32_t
prefDPI
=
Preferences
:
:
GetInt
(
"
layout
.
css
.
dpi
"
-
1
)
;
if
(
prefDPI
>
0
)
{
dpi
=
prefDPI
;
}
else
if
(
mWidget
)
{
dpi
=
mWidget
-
>
GetDPI
(
)
;
if
(
prefDPI
<
0
)
{
dpi
=
std
:
:
max
(
96
.
0f
dpi
)
;
}
}
else
{
dpi
=
96
.
0f
;
}
double
devPixelsPerCSSPixel
;
if
(
aScale
&
&
*
aScale
>
0
.
0
)
{
devPixelsPerCSSPixel
=
*
aScale
;
}
else
{
CSSToLayoutDeviceScale
scale
=
mWidget
?
mWidget
-
>
GetDefaultScale
(
)
:
CSSToLayoutDeviceScale
(
1
.
0
)
;
devPixelsPerCSSPixel
=
scale
.
scale
;
if
(
aScale
)
{
*
aScale
=
devPixelsPerCSSPixel
;
}
}
mAppUnitsPerDevPixelAtUnitFullZoom
=
std
:
:
max
(
1
NS_lround
(
AppUnitsPerCSSPixel
(
)
/
devPixelsPerCSSPixel
)
)
;
}
NS_ASSERTION
(
dpi
!
=
-
1
.
0
"
no
dpi
set
"
)
;
mAppUnitsPerPhysicalInch
=
NS_lround
(
dpi
*
mAppUnitsPerDevPixelAtUnitFullZoom
)
;
UpdateAppUnitsForFullZoom
(
)
;
}
nsresult
nsDeviceContext
:
:
Init
(
nsIWidget
*
aWidget
)
{
nsresult
rv
=
NS_OK
;
if
(
mScreenManager
&
&
mWidget
=
=
aWidget
)
return
rv
;
mWidget
=
aWidget
;
SetDPI
(
)
;
if
(
mScreenManager
)
return
rv
;
mScreenManager
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
&
rv
)
;
return
rv
;
}
already_AddRefed
<
gfxContext
>
nsDeviceContext
:
:
CreateRenderingContext
(
)
{
MOZ_ASSERT
(
IsPrinterSurface
(
)
)
;
MOZ_ASSERT
(
mWidth
>
0
&
&
mHeight
>
0
)
;
RefPtr
<
PrintTarget
>
printingTarget
=
mPrintTarget
;
#
ifdef
XP_MACOSX
if
(
!
printingTarget
)
{
printingTarget
=
mCachedPrintTarget
;
}
#
endif
RefPtr
<
DrawEventRecorder
>
recorder
;
mDeviceContextSpec
-
>
GetDrawEventRecorder
(
getter_AddRefs
(
recorder
)
)
;
RefPtr
<
gfx
:
:
DrawTarget
>
dt
=
printingTarget
-
>
MakeDrawTarget
(
gfx
:
:
IntSize
(
mWidth
mHeight
)
recorder
)
;
if
(
!
dt
|
|
!
dt
-
>
IsValid
(
)
)
{
gfxCriticalNote
<
<
"
Failed
to
create
draw
target
in
device
context
sized
"
<
<
mWidth
<
<
"
x
"
<
<
mHeight
<
<
"
and
pointers
"
<
<
hexa
(
mPrintTarget
)
<
<
"
and
"
<
<
hexa
(
printingTarget
)
;
return
nullptr
;
}
#
ifdef
XP_MACOSX
dt
-
>
AddUserData
(
&
gfxContext
:
:
sDontUseAsSourceKey
dt
nullptr
)
;
#
endif
dt
-
>
AddUserData
(
&
sDisablePixelSnapping
(
void
*
)
0x1
nullptr
)
;
RefPtr
<
gfxContext
>
pContext
=
gfxContext
:
:
CreateOrNull
(
dt
)
;
MOZ_ASSERT
(
pContext
)
;
gfxMatrix
transform
;
if
(
printingTarget
-
>
RotateNeededForLandscape
(
)
)
{
IntSize
size
=
printingTarget
-
>
GetSize
(
)
;
transform
.
Translate
(
gfxPoint
(
0
size
.
width
)
)
;
gfxMatrix
rotate
(
0
-
1
1
0
0
0
)
;
transform
=
rotate
*
transform
;
}
transform
.
Scale
(
mPrintingScale
mPrintingScale
)
;
pContext
-
>
SetMatrix
(
transform
)
;
return
pContext
.
forget
(
)
;
}
nsresult
nsDeviceContext
:
:
GetDepth
(
uint32_t
&
aDepth
)
{
if
(
mDepth
=
=
0
&
&
mScreenManager
)
{
nsCOMPtr
<
nsIScreen
>
primaryScreen
;
mScreenManager
-
>
GetPrimaryScreen
(
getter_AddRefs
(
primaryScreen
)
)
;
primaryScreen
-
>
GetColorDepth
(
reinterpret_cast
<
int32_t
*
>
(
&
mDepth
)
)
;
}
aDepth
=
mDepth
;
return
NS_OK
;
}
nsresult
nsDeviceContext
:
:
GetDeviceSurfaceDimensions
(
nscoord
&
aWidth
nscoord
&
aHeight
)
{
if
(
mPrintTarget
)
{
aWidth
=
mWidth
;
aHeight
=
mHeight
;
}
else
{
nsRect
area
;
ComputeFullAreaUsingScreen
(
&
area
)
;
aWidth
=
area
.
width
;
aHeight
=
area
.
height
;
}
return
NS_OK
;
}
nsresult
nsDeviceContext
:
:
GetRect
(
nsRect
&
aRect
)
{
if
(
mPrintTarget
)
{
aRect
.
x
=
0
;
aRect
.
y
=
0
;
aRect
.
width
=
mWidth
;
aRect
.
height
=
mHeight
;
}
else
ComputeFullAreaUsingScreen
(
&
aRect
)
;
return
NS_OK
;
}
nsresult
nsDeviceContext
:
:
GetClientRect
(
nsRect
&
aRect
)
{
if
(
mPrintTarget
)
{
aRect
.
x
=
0
;
aRect
.
y
=
0
;
aRect
.
width
=
mWidth
;
aRect
.
height
=
mHeight
;
}
else
ComputeClientRectUsingScreen
(
&
aRect
)
;
return
NS_OK
;
}
nsresult
nsDeviceContext
:
:
InitForPrinting
(
nsIDeviceContextSpec
*
aDevice
)
{
NS_ENSURE_ARG_POINTER
(
aDevice
)
;
mDeviceContextSpec
=
aDevice
;
mPrintTarget
=
aDevice
-
>
MakePrintTarget
(
)
;
if
(
!
mPrintTarget
)
{
return
NS_ERROR_FAILURE
;
}
Init
(
nullptr
)
;
if
(
!
CalcPrintingSize
(
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
nsDeviceContext
:
:
BeginDocument
(
const
nsAString
&
aTitle
const
nsAString
&
aPrintToFileName
int32_t
aStartPage
int32_t
aEndPage
)
{
nsresult
rv
=
mPrintTarget
-
>
BeginPrinting
(
aTitle
aPrintToFileName
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
mDeviceContextSpec
)
{
rv
=
mDeviceContextSpec
-
>
BeginDocument
(
aTitle
aPrintToFileName
aStartPage
aEndPage
)
;
}
return
rv
;
}
nsresult
nsDeviceContext
:
:
EndDocument
(
void
)
{
nsresult
rv
=
NS_OK
;
if
(
mPrintTarget
)
{
rv
=
mPrintTarget
-
>
EndPrinting
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
mPrintTarget
-
>
Finish
(
)
;
}
if
(
mDeviceContextSpec
)
mDeviceContextSpec
-
>
EndDocument
(
)
;
return
rv
;
}
nsresult
nsDeviceContext
:
:
AbortDocument
(
void
)
{
nsresult
rv
=
mPrintTarget
-
>
AbortPrinting
(
)
;
if
(
mDeviceContextSpec
)
mDeviceContextSpec
-
>
EndDocument
(
)
;
return
rv
;
}
nsresult
nsDeviceContext
:
:
BeginPage
(
void
)
{
nsresult
rv
=
NS_OK
;
if
(
mDeviceContextSpec
)
rv
=
mDeviceContextSpec
-
>
BeginPage
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
#
ifdef
XP_MACOSX
mPrintTarget
=
mDeviceContextSpec
-
>
MakePrintTarget
(
)
;
#
endif
rv
=
mPrintTarget
-
>
BeginPage
(
)
;
return
rv
;
}
nsresult
nsDeviceContext
:
:
EndPage
(
void
)
{
nsresult
rv
=
mPrintTarget
-
>
EndPage
(
)
;
#
ifdef
XP_MACOSX
mCachedPrintTarget
=
mPrintTarget
;
mPrintTarget
=
nullptr
;
#
endif
if
(
mDeviceContextSpec
)
mDeviceContextSpec
-
>
EndPage
(
)
;
return
rv
;
}
void
nsDeviceContext
:
:
ComputeClientRectUsingScreen
(
nsRect
*
outRect
)
{
nsCOMPtr
<
nsIScreen
>
screen
;
FindScreen
(
getter_AddRefs
(
screen
)
)
;
if
(
screen
)
{
int32_t
x
y
width
height
;
screen
-
>
GetAvailRect
(
&
x
&
y
&
width
&
height
)
;
outRect
-
>
y
=
NSIntPixelsToAppUnits
(
y
AppUnitsPerDevPixel
(
)
)
;
outRect
-
>
x
=
NSIntPixelsToAppUnits
(
x
AppUnitsPerDevPixel
(
)
)
;
outRect
-
>
width
=
NSIntPixelsToAppUnits
(
width
AppUnitsPerDevPixel
(
)
)
;
outRect
-
>
height
=
NSIntPixelsToAppUnits
(
height
AppUnitsPerDevPixel
(
)
)
;
}
}
void
nsDeviceContext
:
:
ComputeFullAreaUsingScreen
(
nsRect
*
outRect
)
{
nsCOMPtr
<
nsIScreen
>
screen
;
FindScreen
(
getter_AddRefs
(
screen
)
)
;
if
(
screen
)
{
int32_t
x
y
width
height
;
screen
-
>
GetRect
(
&
x
&
y
&
width
&
height
)
;
outRect
-
>
y
=
NSIntPixelsToAppUnits
(
y
AppUnitsPerDevPixel
(
)
)
;
outRect
-
>
x
=
NSIntPixelsToAppUnits
(
x
AppUnitsPerDevPixel
(
)
)
;
outRect
-
>
width
=
NSIntPixelsToAppUnits
(
width
AppUnitsPerDevPixel
(
)
)
;
outRect
-
>
height
=
NSIntPixelsToAppUnits
(
height
AppUnitsPerDevPixel
(
)
)
;
mWidth
=
outRect
-
>
width
;
mHeight
=
outRect
-
>
height
;
}
}
void
nsDeviceContext
:
:
FindScreen
(
nsIScreen
*
*
outScreen
)
{
if
(
!
mWidget
|
|
!
mScreenManager
)
{
return
;
}
CheckDPIChange
(
)
;
if
(
mWidget
-
>
GetOwningTabChild
(
)
)
{
mScreenManager
-
>
ScreenForNativeWidget
(
(
void
*
)
mWidget
-
>
GetOwningTabChild
(
)
outScreen
)
;
}
else
if
(
mWidget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
)
{
mScreenManager
-
>
ScreenForNativeWidget
(
mWidget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
outScreen
)
;
}
else
{
mScreenManager
-
>
GetPrimaryScreen
(
outScreen
)
;
}
}
bool
nsDeviceContext
:
:
CalcPrintingSize
(
)
{
if
(
!
mPrintTarget
)
{
return
(
mWidth
>
0
&
&
mHeight
>
0
)
;
}
gfxSize
size
=
mPrintTarget
-
>
GetSize
(
)
;
mWidth
=
NSToCoordRound
(
size
.
width
*
AppUnitsPerPhysicalInch
(
)
/
POINTS_PER_INCH_FLOAT
)
;
mHeight
=
NSToCoordRound
(
size
.
height
*
AppUnitsPerPhysicalInch
(
)
/
POINTS_PER_INCH_FLOAT
)
;
return
(
mWidth
>
0
&
&
mHeight
>
0
)
;
}
bool
nsDeviceContext
:
:
CheckDPIChange
(
double
*
aScale
)
{
int32_t
oldDevPixels
=
mAppUnitsPerDevPixelAtUnitFullZoom
;
int32_t
oldInches
=
mAppUnitsPerPhysicalInch
;
SetDPI
(
aScale
)
;
return
oldDevPixels
!
=
mAppUnitsPerDevPixelAtUnitFullZoom
|
|
oldInches
!
=
mAppUnitsPerPhysicalInch
;
}
bool
nsDeviceContext
:
:
SetFullZoom
(
float
aScale
)
{
if
(
aScale
<
=
0
)
{
NS_NOTREACHED
(
"
Invalid
full
zoom
value
"
)
;
return
false
;
}
int32_t
oldAppUnitsPerDevPixel
=
mAppUnitsPerDevPixel
;
mFullZoom
=
aScale
;
UpdateAppUnitsForFullZoom
(
)
;
return
oldAppUnitsPerDevPixel
!
=
mAppUnitsPerDevPixel
;
}
void
nsDeviceContext
:
:
UpdateAppUnitsForFullZoom
(
)
{
mAppUnitsPerDevPixel
=
std
:
:
max
(
1
NSToIntRound
(
float
(
mAppUnitsPerDevPixelAtUnitFullZoom
)
/
mFullZoom
)
)
;
mFullZoom
=
float
(
mAppUnitsPerDevPixelAtUnitFullZoom
)
/
mAppUnitsPerDevPixel
;
}
DesktopToLayoutDeviceScale
nsDeviceContext
:
:
GetDesktopToDeviceScale
(
)
{
nsCOMPtr
<
nsIScreen
>
screen
;
FindScreen
(
getter_AddRefs
(
screen
)
)
;
if
(
screen
)
{
double
scale
;
screen
-
>
GetContentsScaleFactor
(
&
scale
)
;
return
DesktopToLayoutDeviceScale
(
scale
)
;
}
return
DesktopToLayoutDeviceScale
(
1
.
0
)
;
}
