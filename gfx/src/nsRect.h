#
ifndef
NSRECT_H
#
define
NSRECT_H
#
include
<
stdio
.
h
>
#
include
<
stdint
.
h
>
#
include
<
algorithm
>
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsMargin
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
nscore
.
h
"
typedef
mozilla
:
:
gfx
:
:
IntRect
nsIntRect
;
struct
nsRect
:
public
mozilla
:
:
gfx
:
:
BaseRect
<
nscoord
nsRect
nsPoint
nsSize
nsMargin
>
{
typedef
mozilla
:
:
gfx
:
:
BaseRect
<
nscoord
nsRect
nsPoint
nsSize
nsMargin
>
Super
;
static
void
VERIFY_COORD
(
nscoord
aValue
)
{
:
:
VERIFY_COORD
(
aValue
)
;
}
nsRect
(
)
:
Super
(
)
{
MOZ_COUNT_CTOR
(
nsRect
)
;
}
nsRect
(
const
nsRect
&
aRect
)
:
Super
(
aRect
)
{
MOZ_COUNT_CTOR
(
nsRect
)
;
}
nsRect
(
const
nsPoint
&
aOrigin
const
nsSize
&
aSize
)
:
Super
(
aOrigin
aSize
)
{
MOZ_COUNT_CTOR
(
nsRect
)
;
}
nsRect
(
nscoord
aX
nscoord
aY
nscoord
aWidth
nscoord
aHeight
)
:
Super
(
aX
aY
aWidth
aHeight
)
{
MOZ_COUNT_CTOR
(
nsRect
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
~
nsRect
(
)
{
MOZ_COUNT_DTOR
(
nsRect
)
;
}
#
endif
MOZ_MUST_USE
nsRect
SaturatingUnion
(
const
nsRect
&
aRect
)
const
{
if
(
IsEmpty
(
)
)
{
return
aRect
;
}
else
if
(
aRect
.
IsEmpty
(
)
)
{
return
*
static_cast
<
const
nsRect
*
>
(
this
)
;
}
else
{
return
SaturatingUnionEdges
(
aRect
)
;
}
}
MOZ_MUST_USE
nsRect
SaturatingUnionEdges
(
const
nsRect
&
aRect
)
const
{
#
ifdef
NS_COORD_IS_FLOAT
return
UnionEdges
(
aRect
)
;
#
else
nscoord
resultX
=
std
:
:
min
(
aRect
.
X
(
)
x
)
;
int64_t
w
=
std
:
:
max
(
int64_t
(
aRect
.
X
(
)
)
+
aRect
.
Width
(
)
int64_t
(
x
)
+
width
)
-
resultX
;
if
(
MOZ_UNLIKELY
(
w
>
nscoord_MAX
)
)
{
resultX
=
std
:
:
max
(
resultX
nscoord_MIN
/
2
)
;
w
=
std
:
:
max
(
int64_t
(
aRect
.
X
(
)
)
+
aRect
.
Width
(
)
int64_t
(
x
)
+
width
)
-
resultX
;
if
(
MOZ_UNLIKELY
(
w
>
nscoord_MAX
)
)
{
w
=
nscoord_MAX
;
}
}
nscoord
resultY
=
std
:
:
min
(
aRect
.
y
y
)
;
int64_t
h
=
std
:
:
max
(
int64_t
(
aRect
.
Y
(
)
)
+
aRect
.
Height
(
)
int64_t
(
y
)
+
height
)
-
resultY
;
if
(
MOZ_UNLIKELY
(
h
>
nscoord_MAX
)
)
{
resultY
=
std
:
:
max
(
resultY
nscoord_MIN
/
2
)
;
h
=
std
:
:
max
(
int64_t
(
aRect
.
Y
(
)
)
+
aRect
.
Height
(
)
int64_t
(
y
)
+
height
)
-
resultY
;
if
(
MOZ_UNLIKELY
(
h
>
nscoord_MAX
)
)
{
h
=
nscoord_MAX
;
}
}
return
nsRect
(
resultX
resultY
nscoord
(
w
)
nscoord
(
h
)
)
;
#
endif
}
#
ifndef
NS_COORD_IS_FLOAT
MOZ_MUST_USE
nsRect
UnionEdges
(
const
nsRect
&
aRect
)
const
{
return
SaturatingUnionEdges
(
aRect
)
;
}
void
UnionRectEdges
(
const
nsRect
&
aRect1
const
nsRect
&
aRect2
)
{
*
this
=
aRect1
.
UnionEdges
(
aRect2
)
;
}
MOZ_MUST_USE
nsRect
Union
(
const
nsRect
&
aRect
)
const
{
return
SaturatingUnion
(
aRect
)
;
}
MOZ_MUST_USE
nsRect
UnsafeUnion
(
const
nsRect
&
aRect
)
const
{
return
Super
:
:
Union
(
aRect
)
;
}
void
UnionRect
(
const
nsRect
&
aRect1
const
nsRect
&
aRect2
)
{
*
this
=
aRect1
.
Union
(
aRect2
)
;
}
#
endif
void
SaturatingUnionRect
(
const
nsRect
&
aRect1
const
nsRect
&
aRect2
)
{
*
this
=
aRect1
.
SaturatingUnion
(
aRect2
)
;
}
void
SaturatingUnionRectEdges
(
const
nsRect
&
aRect1
const
nsRect
&
aRect2
)
{
*
this
=
aRect1
.
SaturatingUnionEdges
(
aRect2
)
;
}
bool
Overflows
(
)
const
;
MOZ_MUST_USE
inline
nsRect
ScaleToOtherAppUnitsRoundOut
(
int32_t
aFromAPP
int32_t
aToAPP
)
const
;
MOZ_MUST_USE
inline
nsRect
ScaleToOtherAppUnitsRoundIn
(
int32_t
aFromAPP
int32_t
aToAPP
)
const
;
MOZ_MUST_USE
inline
mozilla
:
:
gfx
:
:
IntRect
ScaleToNearestPixels
(
float
aXScale
float
aYScale
nscoord
aAppUnitsPerPixel
)
const
;
MOZ_MUST_USE
inline
mozilla
:
:
gfx
:
:
IntRect
ToNearestPixels
(
nscoord
aAppUnitsPerPixel
)
const
;
MOZ_MUST_USE
inline
mozilla
:
:
gfx
:
:
IntRect
ScaleToOutsidePixels
(
float
aXScale
float
aYScale
nscoord
aAppUnitsPerPixel
)
const
;
MOZ_MUST_USE
inline
mozilla
:
:
gfx
:
:
IntRect
ToOutsidePixels
(
nscoord
aAppUnitsPerPixel
)
const
;
MOZ_MUST_USE
inline
mozilla
:
:
gfx
:
:
IntRect
ScaleToInsidePixels
(
float
aXScale
float
aYScale
nscoord
aAppUnitsPerPixel
)
const
;
MOZ_MUST_USE
inline
mozilla
:
:
gfx
:
:
IntRect
ToInsidePixels
(
nscoord
aAppUnitsPerPixel
)
const
;
bool
operator
=
=
(
const
nsRect
&
aRect
)
const
{
return
IsEqualEdges
(
aRect
)
;
}
MOZ_MUST_USE
inline
nsRect
RemoveResolution
(
const
float
aResolution
)
const
;
}
;
inline
nsRect
nsRect
:
:
ScaleToOtherAppUnitsRoundOut
(
int32_t
aFromAPP
int32_t
aToAPP
)
const
{
if
(
aFromAPP
=
=
aToAPP
)
{
return
*
this
;
}
nsRect
rect
;
rect
.
SetBox
(
NSToCoordFloor
(
NSCoordScale
(
x
aFromAPP
aToAPP
)
)
NSToCoordFloor
(
NSCoordScale
(
y
aFromAPP
aToAPP
)
)
NSToCoordCeil
(
NSCoordScale
(
XMost
(
)
aFromAPP
aToAPP
)
)
NSToCoordCeil
(
NSCoordScale
(
YMost
(
)
aFromAPP
aToAPP
)
)
)
;
return
rect
;
}
inline
nsRect
nsRect
:
:
ScaleToOtherAppUnitsRoundIn
(
int32_t
aFromAPP
int32_t
aToAPP
)
const
{
if
(
aFromAPP
=
=
aToAPP
)
{
return
*
this
;
}
nsRect
rect
;
rect
.
SetBox
(
NSToCoordCeil
(
NSCoordScale
(
x
aFromAPP
aToAPP
)
)
NSToCoordCeil
(
NSCoordScale
(
y
aFromAPP
aToAPP
)
)
NSToCoordFloor
(
NSCoordScale
(
XMost
(
)
aFromAPP
aToAPP
)
)
NSToCoordFloor
(
NSCoordScale
(
YMost
(
)
aFromAPP
aToAPP
)
)
)
;
return
rect
;
}
inline
mozilla
:
:
gfx
:
:
IntRect
nsRect
:
:
ScaleToNearestPixels
(
float
aXScale
float
aYScale
nscoord
aAppUnitsPerPixel
)
const
{
mozilla
:
:
gfx
:
:
IntRect
rect
;
rect
.
SetNonEmptyBox
(
NSToIntRoundUp
(
NSAppUnitsToDoublePixels
(
x
aAppUnitsPerPixel
)
*
aXScale
)
NSToIntRoundUp
(
NSAppUnitsToDoublePixels
(
y
aAppUnitsPerPixel
)
*
aYScale
)
NSToIntRoundUp
(
NSAppUnitsToDoublePixels
(
XMost
(
)
aAppUnitsPerPixel
)
*
aXScale
)
NSToIntRoundUp
(
NSAppUnitsToDoublePixels
(
YMost
(
)
aAppUnitsPerPixel
)
*
aYScale
)
)
;
return
rect
;
}
inline
mozilla
:
:
gfx
:
:
IntRect
nsRect
:
:
ScaleToOutsidePixels
(
float
aXScale
float
aYScale
nscoord
aAppUnitsPerPixel
)
const
{
mozilla
:
:
gfx
:
:
IntRect
rect
;
rect
.
SetNonEmptyBox
(
NSToIntFloor
(
NSAppUnitsToFloatPixels
(
x
float
(
aAppUnitsPerPixel
)
)
*
aXScale
)
NSToIntFloor
(
NSAppUnitsToFloatPixels
(
y
float
(
aAppUnitsPerPixel
)
)
*
aYScale
)
NSToIntCeil
(
NSAppUnitsToFloatPixels
(
XMost
(
)
float
(
aAppUnitsPerPixel
)
)
*
aXScale
)
NSToIntCeil
(
NSAppUnitsToFloatPixels
(
YMost
(
)
float
(
aAppUnitsPerPixel
)
)
*
aYScale
)
)
;
return
rect
;
}
inline
mozilla
:
:
gfx
:
:
IntRect
nsRect
:
:
ScaleToInsidePixels
(
float
aXScale
float
aYScale
nscoord
aAppUnitsPerPixel
)
const
{
mozilla
:
:
gfx
:
:
IntRect
rect
;
rect
.
SetNonEmptyBox
(
NSToIntCeil
(
NSAppUnitsToFloatPixels
(
x
float
(
aAppUnitsPerPixel
)
)
*
aXScale
)
NSToIntCeil
(
NSAppUnitsToFloatPixels
(
y
float
(
aAppUnitsPerPixel
)
)
*
aYScale
)
NSToIntFloor
(
NSAppUnitsToFloatPixels
(
XMost
(
)
float
(
aAppUnitsPerPixel
)
)
*
aXScale
)
NSToIntFloor
(
NSAppUnitsToFloatPixels
(
YMost
(
)
float
(
aAppUnitsPerPixel
)
)
*
aYScale
)
)
;
return
rect
;
}
inline
mozilla
:
:
gfx
:
:
IntRect
nsRect
:
:
ToNearestPixels
(
nscoord
aAppUnitsPerPixel
)
const
{
return
ScaleToNearestPixels
(
1
.
0f
1
.
0f
aAppUnitsPerPixel
)
;
}
inline
mozilla
:
:
gfx
:
:
IntRect
nsRect
:
:
ToOutsidePixels
(
nscoord
aAppUnitsPerPixel
)
const
{
return
ScaleToOutsidePixels
(
1
.
0f
1
.
0f
aAppUnitsPerPixel
)
;
}
inline
mozilla
:
:
gfx
:
:
IntRect
nsRect
:
:
ToInsidePixels
(
nscoord
aAppUnitsPerPixel
)
const
{
return
ScaleToInsidePixels
(
1
.
0f
1
.
0f
aAppUnitsPerPixel
)
;
}
inline
nsRect
nsRect
:
:
RemoveResolution
(
const
float
aResolution
)
const
{
MOZ_ASSERT
(
aResolution
>
0
.
0f
)
;
nsRect
rect
;
rect
.
MoveTo
(
NSToCoordRound
(
NSCoordToFloat
(
x
)
/
aResolution
)
NSToCoordRound
(
NSCoordToFloat
(
y
)
/
aResolution
)
)
;
if
(
width
=
=
1
&
&
height
=
=
1
)
{
rect
.
SizeTo
(
1
1
)
;
}
else
{
rect
.
SizeTo
(
NSToCoordCeil
(
NSCoordToFloat
(
width
)
/
aResolution
)
NSToCoordCeil
(
NSCoordToFloat
(
height
)
/
aResolution
)
)
;
}
return
rect
;
}
const
mozilla
:
:
gfx
:
:
IntRect
&
GetMaxSizedIntRect
(
)
;
template
<
class
units
>
nsRect
ToAppUnits
(
const
mozilla
:
:
gfx
:
:
IntRectTyped
<
units
>
&
aRect
nscoord
aAppUnitsPerPixel
)
{
return
nsRect
(
NSIntPixelsToAppUnits
(
aRect
.
X
(
)
aAppUnitsPerPixel
)
NSIntPixelsToAppUnits
(
aRect
.
Y
(
)
aAppUnitsPerPixel
)
NSIntPixelsToAppUnits
(
aRect
.
Width
(
)
aAppUnitsPerPixel
)
NSIntPixelsToAppUnits
(
aRect
.
Height
(
)
aAppUnitsPerPixel
)
)
;
}
#
ifdef
DEBUG
extern
FILE
*
operator
<
<
(
FILE
*
out
const
nsRect
&
rect
)
;
#
endif
#
endif
