#
include
"
mozilla
/
EndianUtils
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
mozilla
/
gfx
/
Swizzle
.
h
"
#
include
"
YCbCrUtils
.
h
"
#
include
"
yuv_convert
.
h
"
#
include
"
ycbcr_to_rgb565
.
h
"
namespace
mozilla
{
namespace
gfx
{
void
GetYCbCrToRGBDestFormatAndSize
(
const
layers
:
:
PlanarYCbCrData
&
aData
SurfaceFormat
&
aSuggestedFormat
IntSize
&
aSuggestedSize
)
{
YUVType
yuvtype
=
TypeFromSize
(
aData
.
mYSize
.
width
aData
.
mYSize
.
height
aData
.
mCbCrSize
.
width
aData
.
mCbCrSize
.
height
)
;
bool
prescale
=
aSuggestedSize
.
width
>
0
&
&
aSuggestedSize
.
height
>
0
&
&
aSuggestedSize
!
=
aData
.
mPicSize
;
if
(
aSuggestedFormat
=
=
SurfaceFormat
:
:
R5G6B5_UINT16
)
{
#
if
defined
(
HAVE_YCBCR_TO_RGB565
)
if
(
prescale
&
&
!
IsScaleYCbCrToRGB565Fast
(
aData
.
mPicX
aData
.
mPicY
aData
.
mPicSize
.
width
aData
.
mPicSize
.
height
aSuggestedSize
.
width
aSuggestedSize
.
height
yuvtype
FILTER_BILINEAR
)
&
&
IsConvertYCbCrToRGB565Fast
(
aData
.
mPicX
aData
.
mPicY
aData
.
mPicSize
.
width
aData
.
mPicSize
.
height
yuvtype
)
)
{
prescale
=
false
;
}
#
else
aSuggestedFormat
=
SurfaceFormat
:
:
B8G8R8X8
;
#
endif
}
else
if
(
aSuggestedFormat
!
=
SurfaceFormat
:
:
B8G8R8X8
)
{
aSuggestedFormat
=
SurfaceFormat
:
:
B8G8R8X8
;
}
if
(
aSuggestedFormat
=
=
SurfaceFormat
:
:
B8G8R8X8
)
{
if
(
aData
.
mPicX
!
=
0
|
|
aData
.
mPicY
!
=
0
|
|
yuvtype
=
=
YV24
)
prescale
=
false
;
}
if
(
!
prescale
)
{
aSuggestedSize
=
aData
.
mPicSize
;
}
}
static
inline
void
ConvertYCbCr16to8Line
(
uint8_t
*
aDst
int
aStride
const
uint16_t
*
aSrc
int
aStride16
int
aWidth
int
aHeight
int
aBitDepth
)
{
uint16_t
mask
=
(
1
<
<
aBitDepth
)
-
1
;
for
(
int
i
=
0
;
i
<
aHeight
;
i
+
+
)
{
for
(
int
j
=
0
;
j
<
aWidth
;
j
+
+
)
{
uint16_t
val
=
(
aSrc
[
j
]
&
mask
)
>
>
(
aBitDepth
-
8
)
;
aDst
[
j
]
=
val
;
}
aDst
+
=
aStride
;
aSrc
+
=
aStride16
;
}
}
void
ConvertYCbCrToRGBInternal
(
const
layers
:
:
PlanarYCbCrData
&
aData
const
SurfaceFormat
&
aDestFormat
const
IntSize
&
aDestSize
unsigned
char
*
aDestBuffer
int32_t
aStride
)
{
MOZ_ASSERT
(
aData
.
mCbCrSize
.
width
=
=
aData
.
mYSize
.
width
|
|
aData
.
mCbCrSize
.
width
=
=
(
aData
.
mYSize
.
width
+
1
)
>
>
1
|
|
aData
.
mCbCrSize
.
width
=
=
0
)
;
MOZ_ASSERT
(
aData
.
mCbCrSize
.
height
=
=
aData
.
mYSize
.
height
|
|
aData
.
mCbCrSize
.
height
=
=
(
aData
.
mYSize
.
height
+
1
)
>
>
1
|
|
aData
.
mCbCrSize
.
height
=
=
0
)
;
UniquePtr
<
uint8_t
[
]
>
yChannel
;
UniquePtr
<
uint8_t
[
]
>
cbChannel
;
UniquePtr
<
uint8_t
[
]
>
crChannel
;
layers
:
:
PlanarYCbCrData
dstData
;
const
layers
:
:
PlanarYCbCrData
&
srcData
=
aData
.
mColorDepth
=
=
ColorDepth
:
:
COLOR_8
?
aData
:
dstData
;
if
(
aData
.
mColorDepth
!
=
ColorDepth
:
:
COLOR_8
)
{
dstData
.
mPicSize
=
aData
.
mPicSize
;
dstData
.
mPicX
=
aData
.
mPicX
;
dstData
.
mPicY
=
aData
.
mPicY
;
dstData
.
mYSize
=
aData
.
mYSize
;
dstData
.
mYStride
=
(
aData
.
mYSize
.
width
+
31
)
&
~
31
;
dstData
.
mCbCrSize
=
aData
.
mCbCrSize
;
dstData
.
mCbCrStride
=
(
aData
.
mCbCrSize
.
width
+
31
)
&
~
31
;
dstData
.
mYUVColorSpace
=
aData
.
mYUVColorSpace
;
dstData
.
mColorDepth
=
ColorDepth
:
:
COLOR_8
;
size_t
ySize
=
GetAlignedStride
<
1
>
(
dstData
.
mYStride
aData
.
mYSize
.
height
)
;
size_t
cbcrSize
=
GetAlignedStride
<
1
>
(
dstData
.
mCbCrStride
aData
.
mCbCrSize
.
height
)
;
if
(
ySize
=
=
0
)
{
MOZ_DIAGNOSTIC_ASSERT
(
cbcrSize
=
=
0
"
CbCr
without
Y
makes
no
sense
"
)
;
return
;
}
yChannel
=
MakeUnique
<
uint8_t
[
]
>
(
ySize
)
;
dstData
.
mYChannel
=
yChannel
.
get
(
)
;
int
bitDepth
=
BitDepthForColorDepth
(
aData
.
mColorDepth
)
;
ConvertYCbCr16to8Line
(
dstData
.
mYChannel
dstData
.
mYStride
reinterpret_cast
<
uint16_t
*
>
(
aData
.
mYChannel
)
aData
.
mYStride
/
2
aData
.
mYSize
.
width
aData
.
mYSize
.
height
bitDepth
)
;
if
(
cbcrSize
)
{
cbChannel
=
MakeUnique
<
uint8_t
[
]
>
(
cbcrSize
)
;
crChannel
=
MakeUnique
<
uint8_t
[
]
>
(
cbcrSize
)
;
dstData
.
mCbChannel
=
cbChannel
.
get
(
)
;
dstData
.
mCrChannel
=
crChannel
.
get
(
)
;
ConvertYCbCr16to8Line
(
dstData
.
mCbChannel
dstData
.
mCbCrStride
reinterpret_cast
<
uint16_t
*
>
(
aData
.
mCbChannel
)
aData
.
mCbCrStride
/
2
aData
.
mCbCrSize
.
width
aData
.
mCbCrSize
.
height
bitDepth
)
;
ConvertYCbCr16to8Line
(
dstData
.
mCrChannel
dstData
.
mCbCrStride
reinterpret_cast
<
uint16_t
*
>
(
aData
.
mCrChannel
)
aData
.
mCbCrStride
/
2
aData
.
mCbCrSize
.
width
aData
.
mCbCrSize
.
height
bitDepth
)
;
}
}
YUVType
yuvtype
=
TypeFromSize
(
srcData
.
mYSize
.
width
srcData
.
mYSize
.
height
srcData
.
mCbCrSize
.
width
srcData
.
mCbCrSize
.
height
)
;
if
(
aDestSize
!
=
srcData
.
mPicSize
)
{
#
if
defined
(
HAVE_YCBCR_TO_RGB565
)
if
(
aDestFormat
=
=
SurfaceFormat
:
:
R5G6B5_UINT16
)
{
ScaleYCbCrToRGB565
(
srcData
.
mYChannel
srcData
.
mCbChannel
srcData
.
mCrChannel
aDestBuffer
srcData
.
mPicX
srcData
.
mPicY
srcData
.
mPicSize
.
width
srcData
.
mPicSize
.
height
aDestSize
.
width
aDestSize
.
height
srcData
.
mYStride
srcData
.
mCbCrStride
aStride
yuvtype
FILTER_BILINEAR
)
;
}
else
#
endif
ScaleYCbCrToRGB32
(
srcData
.
mYChannel
srcData
.
mCbChannel
srcData
.
mCrChannel
aDestBuffer
srcData
.
mPicSize
.
width
srcData
.
mPicSize
.
height
aDestSize
.
width
aDestSize
.
height
srcData
.
mYStride
srcData
.
mCbCrStride
aStride
yuvtype
srcData
.
mYUVColorSpace
FILTER_BILINEAR
)
;
}
else
{
#
if
defined
(
HAVE_YCBCR_TO_RGB565
)
if
(
aDestFormat
=
=
SurfaceFormat
:
:
R5G6B5_UINT16
)
{
ConvertYCbCrToRGB565
(
srcData
.
mYChannel
srcData
.
mCbChannel
srcData
.
mCrChannel
aDestBuffer
srcData
.
mPicX
srcData
.
mPicY
srcData
.
mPicSize
.
width
srcData
.
mPicSize
.
height
srcData
.
mYStride
srcData
.
mCbCrStride
aStride
yuvtype
)
;
}
else
#
endif
ConvertYCbCrToRGB32
(
srcData
.
mYChannel
srcData
.
mCbChannel
srcData
.
mCrChannel
aDestBuffer
srcData
.
mPicX
srcData
.
mPicY
srcData
.
mPicSize
.
width
srcData
.
mPicSize
.
height
srcData
.
mYStride
srcData
.
mCbCrStride
aStride
yuvtype
srcData
.
mYUVColorSpace
)
;
}
}
void
ConvertYCbCrToRGB
(
const
layers
:
:
PlanarYCbCrData
&
aData
const
SurfaceFormat
&
aDestFormat
const
IntSize
&
aDestSize
unsigned
char
*
aDestBuffer
int32_t
aStride
)
{
ConvertYCbCrToRGBInternal
(
aData
aDestFormat
aDestSize
aDestBuffer
aStride
)
;
#
if
MOZ_BIG_ENDIAN
(
)
if
(
aDestFormat
!
=
SurfaceFormat
:
:
R5G6B5_UINT16
)
gfx
:
:
SwizzleData
(
aDestBuffer
aStride
gfx
:
:
SurfaceFormat
:
:
X8R8G8B8
aDestBuffer
aStride
gfx
:
:
SurfaceFormat
:
:
B8G8R8X8
aData
.
mPicSize
)
;
#
endif
}
void
FillAlphaToRGBA
(
const
uint8_t
*
aAlpha
const
int32_t
aAlphaStride
uint8_t
*
aBuffer
const
int32_t
aWidth
const
int32_t
aHeight
const
gfx
:
:
SurfaceFormat
&
aFormat
)
{
MOZ_ASSERT
(
aAlphaStride
>
=
aWidth
)
;
MOZ_ASSERT
(
aFormat
=
=
SurfaceFormat
:
:
B8G8R8A8
)
;
const
int
bpp
=
BytesPerPixel
(
aFormat
)
;
const
size_t
rgbaStride
=
aWidth
*
bpp
;
const
uint8_t
*
src
=
aAlpha
;
for
(
int32_t
h
=
0
;
h
<
aHeight
;
+
+
h
)
{
size_t
offset
=
static_cast
<
size_t
>
(
SurfaceFormatBit
:
:
OS_A
)
/
8
;
for
(
int32_t
w
=
0
;
w
<
aWidth
;
+
+
w
)
{
aBuffer
[
offset
]
=
src
[
w
]
;
offset
+
=
bpp
;
}
src
+
=
aAlphaStride
;
aBuffer
+
=
rgbaStride
;
}
}
void
ConvertYCbCrAToARGB
(
const
layers
:
:
PlanarYCbCrAData
&
aData
const
SurfaceFormat
&
aDestFormat
const
IntSize
&
aDestSize
unsigned
char
*
aDestBuffer
int32_t
aStride
)
{
MOZ_ASSERT
(
aDestFormat
=
=
SurfaceFormat
:
:
B8G8R8A8
)
;
MOZ_ASSERT
(
aData
.
mAlphaSize
=
=
aData
.
mYSize
)
;
YUVType
yuvtype
=
TypeFromSize
(
aData
.
mYSize
.
width
aData
.
mYSize
.
height
aData
.
mCbCrSize
.
width
aData
.
mCbCrSize
.
height
)
;
if
(
yuvtype
=
=
YV12
)
{
ConvertI420AlphaToARGB
(
aData
.
mYChannel
aData
.
mCbChannel
aData
.
mCrChannel
aData
.
mAlphaChannel
aData
.
mYStride
aData
.
mCbCrStride
aDestBuffer
aStride
aData
.
mPicSize
.
width
aData
.
mPicSize
.
height
)
;
return
;
}
ConvertYCbCrToRGBInternal
(
aData
aDestFormat
aDestSize
aDestBuffer
aStride
)
;
FillAlphaToRGBA
(
aData
.
mAlphaChannel
aData
.
mYStride
aDestBuffer
aData
.
mPicSize
.
width
aData
.
mPicSize
.
height
aDestFormat
)
;
ARGBAttenuate
(
aDestBuffer
aStride
aDestBuffer
aStride
aData
.
mPicSize
.
width
aData
.
mPicSize
.
height
)
;
#
if
MOZ_BIG_ENDIAN
(
)
gfx
:
:
SwizzleData
(
aDestBuffer
aStride
gfx
:
:
SurfaceFormat
:
:
A8R8G8B8
aDestBuffer
aStride
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
aData
.
mPicSize
)
;
#
endif
}
void
ConvertI420AlphaToARGB
(
const
uint8_t
*
aSrcY
const
uint8_t
*
aSrcU
const
uint8_t
*
aSrcV
const
uint8_t
*
aSrcA
int
aSrcStrideYA
int
aSrcStrideUV
uint8_t
*
aDstARGB
int
aDstStrideARGB
int
aWidth
int
aHeight
)
{
ConvertI420AlphaToARGB32
(
aSrcY
aSrcU
aSrcV
aSrcA
aDstARGB
aWidth
aHeight
aSrcStrideYA
aSrcStrideUV
aDstStrideARGB
)
;
#
if
MOZ_BIG_ENDIAN
(
)
gfx
:
:
SwizzleData
(
aDstARGB
aDstStrideARGB
gfx
:
:
SurfaceFormat
:
:
A8R8G8B8
aDstARGB
aDstStrideARGB
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
IntSize
(
aWidth
aHeight
)
)
;
#
endif
}
}
}
