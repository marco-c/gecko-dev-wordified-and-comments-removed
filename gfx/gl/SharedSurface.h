#
ifndef
SHARED_SURFACE_H_
#
define
SHARED_SURFACE_H_
#
include
<
queue
>
#
include
<
set
>
#
include
<
stdint
.
h
>
#
include
"
GLContext
.
h
"
#
include
"
GLContextTypes
.
h
"
#
include
"
GLDefs
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
SurfaceTypes
.
h
"
class
nsIThread
;
namespace
mozilla
{
namespace
gfx
{
class
DataSourceSurface
;
class
DrawTarget
;
}
namespace
layers
{
class
KnowsCompositor
;
enum
class
LayersBackend
:
int8_t
;
class
LayersIPCChannel
;
class
SharedSurfaceTextureClient
;
class
SurfaceDescriptor
;
class
TextureClient
;
enum
class
TextureFlags
:
uint32_t
;
enum
class
TextureType
:
int8_t
;
}
namespace
gl
{
class
MozFramebuffer
;
struct
ScopedBindFramebuffer
;
class
SurfaceFactory
;
struct
PartialSharedSurfaceDesc
{
const
WeakPtr
<
GLContext
>
gl
;
const
SharedSurfaceType
type
;
const
layers
:
:
TextureType
consumerType
;
const
bool
canRecycle
;
}
;
struct
SharedSurfaceDesc
:
public
PartialSharedSurfaceDesc
{
gfx
:
:
IntSize
size
=
{
}
;
}
;
class
SharedSurface
{
public
:
const
SharedSurfaceDesc
mDesc
;
const
UniquePtr
<
MozFramebuffer
>
mFb
;
protected
:
bool
mIsLocked
=
false
;
bool
mIsProducerAcquired
=
false
;
SharedSurface
(
const
SharedSurfaceDesc
&
UniquePtr
<
MozFramebuffer
>
)
;
public
:
virtual
~
SharedSurface
(
)
;
bool
IsLocked
(
)
const
{
return
mIsLocked
;
}
bool
IsProducerAcquired
(
)
const
{
return
mIsProducerAcquired
;
}
void
LockProd
(
)
;
void
UnlockProd
(
)
;
virtual
void
Commit
(
)
{
}
protected
:
virtual
void
LockProdImpl
(
)
{
}
;
virtual
void
UnlockProdImpl
(
)
{
}
;
virtual
void
ProducerAcquireImpl
(
)
{
}
;
virtual
void
ProducerReleaseImpl
(
)
{
}
;
virtual
void
ProducerReadAcquireImpl
(
)
{
ProducerAcquireImpl
(
)
;
}
virtual
void
ProducerReadReleaseImpl
(
)
{
ProducerReleaseImpl
(
)
;
}
public
:
void
ProducerAcquire
(
)
{
MOZ_ASSERT
(
!
mIsProducerAcquired
)
;
ProducerAcquireImpl
(
)
;
mIsProducerAcquired
=
true
;
}
void
ProducerRelease
(
)
{
MOZ_ASSERT
(
mIsProducerAcquired
)
;
ProducerReleaseImpl
(
)
;
mIsProducerAcquired
=
false
;
}
void
ProducerReadAcquire
(
)
{
MOZ_ASSERT
(
!
mIsProducerAcquired
)
;
ProducerReadAcquireImpl
(
)
;
mIsProducerAcquired
=
true
;
}
void
ProducerReadRelease
(
)
{
MOZ_ASSERT
(
mIsProducerAcquired
)
;
ProducerReadReleaseImpl
(
)
;
mIsProducerAcquired
=
false
;
}
virtual
void
WaitForBufferOwnership
(
)
{
}
virtual
bool
IsBufferAvailable
(
)
const
{
return
true
;
}
virtual
bool
NeedsIndirectReads
(
)
const
{
return
false
;
}
virtual
Maybe
<
layers
:
:
SurfaceDescriptor
>
ToSurfaceDescriptor
(
)
=
0
;
virtual
bool
ReadbackBySharedHandle
(
gfx
:
:
DataSourceSurface
*
out_surface
)
{
return
false
;
}
}
;
class
SurfaceFactory
{
public
:
const
PartialSharedSurfaceDesc
mDesc
;
protected
:
Mutex
mMutex
;
public
:
static
UniquePtr
<
SurfaceFactory
>
Create
(
GLContext
*
layers
:
:
TextureType
)
;
protected
:
explicit
SurfaceFactory
(
const
PartialSharedSurfaceDesc
&
)
;
public
:
virtual
~
SurfaceFactory
(
)
;
protected
:
virtual
UniquePtr
<
SharedSurface
>
CreateSharedImpl
(
const
SharedSurfaceDesc
&
)
=
0
;
public
:
UniquePtr
<
SharedSurface
>
CreateShared
(
const
gfx
:
:
IntSize
&
size
)
{
return
CreateSharedImpl
(
{
mDesc
size
}
)
;
}
}
;
template
<
typename
T
>
inline
UniquePtr
<
T
>
AsUnique
(
T
*
const
p
)
{
return
UniquePtr
<
T
>
(
p
)
;
}
}
}
#
endif
