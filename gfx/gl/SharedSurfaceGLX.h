#
ifndef
SHARED_SURFACE_GLX_H_
#
define
SHARED_SURFACE_GLX_H_
#
include
"
SharedSurface
.
h
"
#
include
"
mozilla
/
nsRefPtr
.
h
"
class
gfxXlibSurface
;
namespace
mozilla
{
namespace
gl
{
class
SharedSurface_GLXDrawable
:
public
SharedSurface
{
public
:
static
UniquePtr
<
SharedSurface_GLXDrawable
>
Create
(
GLContext
*
prodGL
const
SurfaceCaps
&
caps
const
gfx
:
:
IntSize
&
size
bool
deallocateClient
bool
inSameProcess
)
;
virtual
void
Fence
(
)
override
;
virtual
bool
WaitSync
(
)
override
{
return
true
;
}
virtual
bool
PollSync
(
)
override
{
return
true
;
}
virtual
void
LockProdImpl
(
)
override
;
virtual
void
UnlockProdImpl
(
)
override
;
virtual
bool
ToSurfaceDescriptor
(
layers
:
:
SurfaceDescriptor
*
const
out_descriptor
)
override
;
virtual
bool
ReadbackBySharedHandle
(
gfx
:
:
DataSourceSurface
*
out_surface
)
override
;
private
:
SharedSurface_GLXDrawable
(
GLContext
*
gl
const
gfx
:
:
IntSize
&
size
bool
inSameProcess
const
nsRefPtr
<
gfxXlibSurface
>
&
xlibSurface
)
;
nsRefPtr
<
gfxXlibSurface
>
mXlibSurface
;
bool
mInSameProcess
;
}
;
class
SurfaceFactory_GLXDrawable
:
public
SurfaceFactory
{
public
:
static
UniquePtr
<
SurfaceFactory_GLXDrawable
>
Create
(
GLContext
*
prodGL
const
SurfaceCaps
&
caps
const
nsRefPtr
<
layers
:
:
ISurfaceAllocator
>
&
allocator
const
layers
:
:
TextureFlags
&
flags
)
;
virtual
UniquePtr
<
SharedSurface
>
CreateShared
(
const
gfx
:
:
IntSize
&
size
)
override
;
private
:
SurfaceFactory_GLXDrawable
(
GLContext
*
prodGL
const
SurfaceCaps
&
caps
const
nsRefPtr
<
layers
:
:
ISurfaceAllocator
>
&
allocator
const
layers
:
:
TextureFlags
&
flags
)
:
SurfaceFactory
(
SharedSurfaceType
:
:
GLXDrawable
prodGL
caps
allocator
flags
)
{
}
}
;
}
}
#
endif
