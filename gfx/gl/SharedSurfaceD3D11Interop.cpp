#
include
"
SharedSurfaceD3D11Interop
.
h
"
#
include
<
d3d11
.
h
>
#
include
"
GLContext
.
h
"
#
include
"
WGLLibrary
.
h
"
namespace
mozilla
{
namespace
gl
{
class
DXGLDevice
:
public
RefCounted
<
DXGLDevice
>
{
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
DXGLDevice
)
WGLLibrary
*
const
mWGL
;
const
RefPtr
<
ID3D11Device
>
mD3D
;
const
HANDLE
mDXGLDeviceHandle
;
static
already_AddRefed
<
DXGLDevice
>
Open
(
WGLLibrary
*
wgl
)
{
MOZ_ASSERT
(
wgl
-
>
HasDXInterop2
(
)
)
;
gfxWindowsPlatform
*
plat
=
gfxWindowsPlatform
:
:
GetPlatform
(
)
;
RefPtr
<
ID3D11Device
>
d3d
=
plat
-
>
GetD3D11ContentDevice
(
)
;
if
(
!
d3d
)
{
NS_WARNING
(
"
Failed
to
create
D3D11
device
.
"
)
;
return
nullptr
;
}
HANDLE
dxglDeviceHandle
=
wgl
-
>
fDXOpenDevice
(
d3d
)
;
if
(
!
dxglDeviceHandle
)
{
NS_WARNING
(
"
Failed
to
open
D3D
device
for
use
by
WGL
.
"
)
;
return
nullptr
;
}
return
MakeAndAddRef
<
DXGLDevice
>
(
wgl
d3d
dxglDeviceHandle
)
;
}
DXGLDevice
(
WGLLibrary
*
wgl
const
RefPtr
<
ID3D11Device
>
&
d3d
HANDLE
dxglDeviceHandle
)
:
mWGL
(
wgl
)
mD3D
(
d3d
)
mDXGLDeviceHandle
(
dxglDeviceHandle
)
{
}
~
DXGLDevice
(
)
{
if
(
!
mWGL
-
>
fDXCloseDevice
(
mDXGLDeviceHandle
)
)
{
#
ifdef
DEBUG
uint32_t
error
=
GetLastError
(
)
;
printf_stderr
(
"
wglDXCloseDevice
(
0x
%
x
)
failed
:
GetLastError
(
)
:
0x
%
x
\
n
"
mDXGLDeviceHandle
error
)
;
#
endif
MOZ_CRASH
(
)
;
}
}
HANDLE
RegisterObject
(
void
*
dxObject
GLuint
name
GLenum
type
GLenum
access
)
const
{
HANDLE
ret
=
mWGL
-
>
fDXRegisterObject
(
mDXGLDeviceHandle
dxObject
name
type
access
)
;
if
(
!
ret
)
{
#
ifdef
DEBUG
uint32_t
error
=
GetLastError
(
)
;
printf_stderr
(
"
wglDXRegisterObject
(
0x
%
x
0x
%
x
%
u
0x
%
x
0x
%
x
)
failed
:
"
"
GetLastError
(
)
:
0x
%
x
\
n
"
mDXGLDeviceHandle
dxObject
name
type
access
error
)
;
#
endif
MOZ_CRASH
(
)
;
}
return
ret
;
}
bool
UnregisterObject
(
HANDLE
hObject
)
const
{
bool
ret
=
mWGL
-
>
fDXUnregisterObject
(
mDXGLDeviceHandle
hObject
)
;
if
(
!
ret
)
{
#
ifdef
DEBUG
uint32_t
error
=
GetLastError
(
)
;
printf_stderr
(
"
wglDXUnregisterObject
(
0x
%
x
0x
%
x
)
failed
:
GetLastError
(
)
:
"
"
0x
%
x
\
n
"
mDXGLDeviceHandle
hObject
error
)
;
#
endif
MOZ_CRASH
(
)
;
}
return
ret
;
}
bool
LockObject
(
HANDLE
hObject
)
const
{
bool
ret
=
mWGL
-
>
fDXLockObjects
(
mDXGLDeviceHandle
1
&
hObject
)
;
if
(
!
ret
)
{
#
ifdef
DEBUG
uint32_t
error
=
GetLastError
(
)
;
printf_stderr
(
"
wglDXLockObjects
(
0x
%
x
1
{
0x
%
x
}
)
failed
:
GetLastError
(
)
:
"
"
0x
%
x
\
n
"
mDXGLDeviceHandle
hObject
error
)
;
#
endif
MOZ_CRASH
(
)
;
}
return
ret
;
}
bool
UnlockObject
(
HANDLE
hObject
)
const
{
bool
ret
=
mWGL
-
>
fDXUnlockObjects
(
mDXGLDeviceHandle
1
&
hObject
)
;
if
(
!
ret
)
{
#
ifdef
DEBUG
uint32_t
error
=
GetLastError
(
)
;
printf_stderr
(
"
wglDXUnlockObjects
(
0x
%
x
1
{
0x
%
x
}
)
failed
:
GetLastError
(
)
:
"
"
0x
%
x
\
n
"
mDXGLDeviceHandle
hObject
error
)
;
#
endif
MOZ_CRASH
(
)
;
}
return
ret
;
}
}
;
UniquePtr
<
SharedSurface_D3D11Interop
>
SharedSurface_D3D11Interop
:
:
Create
(
const
RefPtr
<
DXGLDevice
>
&
dxgl
GLContext
*
gl
const
gfx
:
:
IntSize
&
size
bool
hasAlpha
)
{
auto
&
d3d
=
*
dxgl
-
>
mD3D
;
DXGI_FORMAT
format
=
hasAlpha
?
DXGI_FORMAT_B8G8R8A8_UNORM
:
DXGI_FORMAT_B8G8R8X8_UNORM
;
CD3D11_TEXTURE2D_DESC
desc
(
format
size
.
width
size
.
height
1
1
)
;
desc
.
MiscFlags
=
D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX
;
RefPtr
<
ID3D11Texture2D
>
textureD3D
;
HRESULT
hr
=
d3d
.
CreateTexture2D
(
&
desc
nullptr
getter_AddRefs
(
textureD3D
)
)
;
if
(
FAILED
(
hr
)
)
{
NS_WARNING
(
"
Failed
to
create
texture
for
CanvasLayer
!
"
)
;
return
nullptr
;
}
RefPtr
<
IDXGIResource
>
textureDXGI
;
hr
=
textureD3D
-
>
QueryInterface
(
__uuidof
(
IDXGIResource
)
getter_AddRefs
(
textureDXGI
)
)
;
if
(
FAILED
(
hr
)
)
{
NS_WARNING
(
"
Failed
to
open
texture
for
sharing
!
"
)
;
return
nullptr
;
}
RefPtr
<
IDXGIKeyedMutex
>
keyedMutex
;
hr
=
textureD3D
-
>
QueryInterface
(
(
IDXGIKeyedMutex
*
*
)
getter_AddRefs
(
keyedMutex
)
)
;
if
(
FAILED
(
hr
)
)
{
NS_WARNING
(
"
Failed
to
obtained
keyed
mutex
from
texture
!
"
)
;
return
nullptr
;
}
HANDLE
sharedHandle
;
textureDXGI
-
>
GetSharedHandle
(
&
sharedHandle
)
;
GLuint
renderbufferGL
=
0
;
gl
-
>
MakeCurrent
(
)
;
gl
-
>
fGenRenderbuffers
(
1
&
renderbufferGL
)
;
HANDLE
objectWGL
=
dxgl
-
>
RegisterObject
(
textureD3D
renderbufferGL
LOCAL_GL_RENDERBUFFER
LOCAL_WGL_ACCESS_WRITE_DISCARD_NV
)
;
if
(
!
objectWGL
)
{
NS_WARNING
(
"
Failed
to
register
D3D
object
with
WGL
.
"
)
;
return
nullptr
;
}
GLuint
fence
=
0
;
if
(
gl
-
>
IsExtensionSupported
(
GLContext
:
:
NV_fence
)
)
{
gl
-
>
MakeCurrent
(
)
;
gl
-
>
fGenFences
(
1
&
fence
)
;
}
typedef
SharedSurface_D3D11Interop
ptrT
;
UniquePtr
<
ptrT
>
ret
(
new
ptrT
(
gl
size
hasAlpha
renderbufferGL
dxgl
objectWGL
textureD3D
sharedHandle
keyedMutex
fence
)
)
;
return
Move
(
ret
)
;
}
SharedSurface_D3D11Interop
:
:
SharedSurface_D3D11Interop
(
GLContext
*
gl
const
gfx
:
:
IntSize
&
size
bool
hasAlpha
GLuint
renderbufferGL
const
RefPtr
<
DXGLDevice
>
&
dxgl
HANDLE
objectWGL
const
RefPtr
<
ID3D11Texture2D
>
&
textureD3D
HANDLE
sharedHandle
const
RefPtr
<
IDXGIKeyedMutex
>
&
keyedMutex
GLuint
fence
)
:
SharedSurface
(
SharedSurfaceType
:
:
DXGLInterop2
AttachmentType
:
:
GLRenderbuffer
gl
size
hasAlpha
true
)
mProdRB
(
renderbufferGL
)
mDXGL
(
dxgl
)
mObjectWGL
(
objectWGL
)
mTextureD3D
(
textureD3D
)
mSharedHandle
(
sharedHandle
)
mKeyedMutex
(
keyedMutex
)
mFence
(
fence
)
mLockedForGL
(
false
)
{
}
SharedSurface_D3D11Interop
:
:
~
SharedSurface_D3D11Interop
(
)
{
MOZ_ASSERT
(
!
mLockedForGL
)
;
mGL
-
>
fDeleteRenderbuffers
(
1
&
mProdRB
)
;
if
(
!
mDXGL
-
>
UnregisterObject
(
mObjectWGL
)
)
{
NS_WARNING
(
"
Failed
to
release
a
DXGL
object
possibly
leaking
it
.
"
)
;
}
if
(
mFence
)
{
mGL
-
>
MakeCurrent
(
)
;
mGL
-
>
fDeleteFences
(
1
&
mFence
)
;
}
}
void
SharedSurface_D3D11Interop
:
:
LockProdImpl
(
)
{
}
void
SharedSurface_D3D11Interop
:
:
UnlockProdImpl
(
)
{
}
void
SharedSurface_D3D11Interop
:
:
Fence
(
)
{
mGL
-
>
fFinish
(
)
;
}
bool
SharedSurface_D3D11Interop
:
:
WaitSync
(
)
{
return
true
;
}
bool
SharedSurface_D3D11Interop
:
:
PollSync
(
)
{
return
true
;
}
void
SharedSurface_D3D11Interop
:
:
ProducerAcquireImpl
(
)
{
MOZ_ASSERT
(
!
mLockedForGL
)
;
if
(
mKeyedMutex
)
{
const
uint64_t
keyValue
=
0
;
const
DWORD
timeoutMs
=
10000
;
HRESULT
hr
=
mKeyedMutex
-
>
AcquireSync
(
keyValue
timeoutMs
)
;
if
(
hr
=
=
WAIT_TIMEOUT
)
{
MOZ_CRASH
(
"
d3d11Interop
timeout
"
)
;
}
}
MOZ_ALWAYS_TRUE
(
mDXGL
-
>
LockObject
(
mObjectWGL
)
)
;
mLockedForGL
=
true
;
}
void
SharedSurface_D3D11Interop
:
:
ProducerReleaseImpl
(
)
{
MOZ_ASSERT
(
mLockedForGL
)
;
mGL
-
>
fFlush
(
)
;
MOZ_ALWAYS_TRUE
(
mDXGL
-
>
UnlockObject
(
mObjectWGL
)
)
;
mLockedForGL
=
false
;
if
(
mKeyedMutex
)
{
mKeyedMutex
-
>
ReleaseSync
(
0
)
;
}
Fence
(
)
;
}
void
SharedSurface_D3D11Interop
:
:
ConsumerAcquireImpl
(
)
{
if
(
!
mConsumerTexture
)
{
RefPtr
<
ID3D11Texture2D
>
tex
;
RefPtr
<
ID3D11Device
>
device
=
gfxWindowsPlatform
:
:
GetPlatform
(
)
-
>
GetD3D11Device
(
)
;
HRESULT
hr
=
device
-
>
OpenSharedResource
(
mSharedHandle
__uuidof
(
ID3D11Texture2D
)
(
void
*
*
)
(
ID3D11Texture2D
*
*
)
getter_AddRefs
(
tex
)
)
;
if
(
SUCCEEDED
(
hr
)
)
{
mConsumerTexture
=
tex
;
RefPtr
<
IDXGIKeyedMutex
>
mutex
;
hr
=
tex
-
>
QueryInterface
(
(
IDXGIKeyedMutex
*
*
)
getter_AddRefs
(
mutex
)
)
;
if
(
SUCCEEDED
(
hr
)
)
{
mConsumerKeyedMutex
=
mutex
;
}
}
}
if
(
mConsumerKeyedMutex
)
{
const
uint64_t
keyValue
=
0
;
const
DWORD
timeoutMs
=
10000
;
HRESULT
hr
=
mConsumerKeyedMutex
-
>
AcquireSync
(
keyValue
timeoutMs
)
;
if
(
hr
=
=
WAIT_TIMEOUT
)
{
MOZ_CRASH
(
)
;
}
}
}
void
SharedSurface_D3D11Interop
:
:
ConsumerReleaseImpl
(
)
{
if
(
mConsumerKeyedMutex
)
{
mConsumerKeyedMutex
-
>
ReleaseSync
(
0
)
;
}
}
void
SharedSurface_D3D11Interop
:
:
Fence_ContentThread_Impl
(
)
{
if
(
mFence
)
{
MOZ_ASSERT
(
mGL
-
>
IsExtensionSupported
(
GLContext
:
:
NV_fence
)
)
;
mGL
-
>
fSetFence
(
mFence
LOCAL_GL_ALL_COMPLETED_NV
)
;
mGL
-
>
fFlush
(
)
;
return
;
}
Fence
(
)
;
}
bool
SharedSurface_D3D11Interop
:
:
WaitSync_ContentThread_Impl
(
)
{
if
(
mFence
)
{
mGL
-
>
MakeCurrent
(
)
;
mGL
-
>
fFinishFence
(
mFence
)
;
return
true
;
}
return
WaitSync
(
)
;
}
bool
SharedSurface_D3D11Interop
:
:
PollSync_ContentThread_Impl
(
)
{
if
(
mFence
)
{
mGL
-
>
MakeCurrent
(
)
;
return
mGL
-
>
fTestFence
(
mFence
)
;
}
return
PollSync
(
)
;
}
bool
SharedSurface_D3D11Interop
:
:
ToSurfaceDescriptor
(
layers
:
:
SurfaceDescriptor
*
const
out_descriptor
)
{
gfx
:
:
SurfaceFormat
format
=
mHasAlpha
?
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8X8
;
*
out_descriptor
=
layers
:
:
SurfaceDescriptorD3D10
(
(
WindowsHandle
)
GetSharedHandle
(
)
format
mSize
)
;
return
true
;
}
UniquePtr
<
SurfaceFactory_D3D11Interop
>
SurfaceFactory_D3D11Interop
:
:
Create
(
GLContext
*
gl
const
SurfaceCaps
&
caps
const
RefPtr
<
layers
:
:
ISurfaceAllocator
>
&
allocator
const
layers
:
:
TextureFlags
&
flags
)
{
WGLLibrary
*
wgl
=
&
sWGLLib
;
if
(
!
wgl
|
|
!
wgl
-
>
HasDXInterop2
(
)
)
return
nullptr
;
RefPtr
<
DXGLDevice
>
dxgl
=
DXGLDevice
:
:
Open
(
wgl
)
;
if
(
!
dxgl
)
{
NS_WARNING
(
"
Failed
to
open
D3D
device
for
use
by
WGL
.
"
)
;
return
nullptr
;
}
typedef
SurfaceFactory_D3D11Interop
ptrT
;
UniquePtr
<
ptrT
>
ret
(
new
ptrT
(
gl
caps
allocator
flags
dxgl
)
)
;
return
Move
(
ret
)
;
}
SurfaceFactory_D3D11Interop
:
:
SurfaceFactory_D3D11Interop
(
GLContext
*
gl
const
SurfaceCaps
&
caps
const
RefPtr
<
layers
:
:
ISurfaceAllocator
>
&
allocator
const
layers
:
:
TextureFlags
&
flags
const
RefPtr
<
DXGLDevice
>
&
dxgl
)
:
SurfaceFactory
(
SharedSurfaceType
:
:
DXGLInterop2
gl
caps
allocator
flags
)
mDXGL
(
dxgl
)
{
}
SurfaceFactory_D3D11Interop
:
:
~
SurfaceFactory_D3D11Interop
(
)
{
}
}
}
