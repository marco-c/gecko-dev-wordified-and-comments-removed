#
include
"
SharedSurfaceEGL
.
h
"
#
include
"
GLBlitHelper
.
h
"
#
include
"
GLContextEGL
.
h
"
#
include
"
GLContextProvider
.
h
"
#
include
"
GLLibraryEGL
.
h
"
#
include
"
GLReadTexImageHelper
.
h
"
#
include
"
MozFramebuffer
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
SharedSurface
.
h
"
#
if
defined
(
MOZ_WIDGET_ANDROID
)
#
include
"
AndroidNativeWindow
.
h
"
#
include
"
mozilla
/
java
/
SurfaceAllocatorWrappers
.
h
"
#
endif
namespace
mozilla
{
namespace
gl
{
static
bool
HasEglImageExtensions
(
const
GLContextEGL
&
gl
)
{
const
auto
&
egl
=
*
(
gl
.
mEgl
)
;
return
egl
.
HasKHRImageBase
(
)
&
&
egl
.
IsExtensionSupported
(
GLLibraryEGL
:
:
KHR_gl_texture_2D_image
)
&
&
(
gl
.
IsExtensionSupported
(
GLContext
:
:
OES_EGL_image_external
)
|
|
gl
.
IsExtensionSupported
(
GLContext
:
:
OES_EGL_image
)
)
;
}
UniquePtr
<
SurfaceFactory_EGLImage
>
SurfaceFactory_EGLImage
:
:
Create
(
GLContext
&
gl_
)
{
auto
&
gl
=
*
GLContextEGL
:
:
Cast
(
&
gl_
)
;
if
(
!
HasEglImageExtensions
(
gl
)
)
return
nullptr
;
const
auto
partialDesc
=
PartialSharedSurfaceDesc
{
&
gl
SharedSurfaceType
:
:
EGLImageShare
layers
:
:
TextureType
:
:
EGLImage
false
}
;
return
AsUnique
(
new
SurfaceFactory_EGLImage
(
partialDesc
)
)
;
}
UniquePtr
<
SharedSurface_EGLImage
>
SharedSurface_EGLImage
:
:
Create
(
const
SharedSurfaceDesc
&
desc
)
{
const
auto
&
gle
=
GLContextEGL
:
:
Cast
(
desc
.
gl
)
;
const
auto
&
context
=
gle
-
>
mContext
;
const
auto
&
egl
=
*
(
gle
-
>
mEgl
)
;
auto
fb
=
MozFramebuffer
:
:
Create
(
desc
.
gl
desc
.
size
0
false
)
;
if
(
!
fb
)
return
nullptr
;
const
auto
buffer
=
reinterpret_cast
<
EGLClientBuffer
>
(
fb
-
>
ColorTex
(
)
)
;
const
auto
image
=
egl
.
fCreateImage
(
egl
.
Display
(
)
context
LOCAL_EGL_GL_TEXTURE_2D
buffer
nullptr
)
;
if
(
!
image
)
return
nullptr
;
return
AsUnique
(
new
SharedSurface_EGLImage
(
desc
std
:
:
move
(
fb
)
image
)
)
;
}
SharedSurface_EGLImage
:
:
SharedSurface_EGLImage
(
const
SharedSurfaceDesc
&
desc
UniquePtr
<
MozFramebuffer
>
&
&
fb
const
EGLImage
image
)
:
SharedSurface
(
desc
std
:
:
move
(
fb
)
)
mMutex
(
"
SharedSurface_EGLImage
mutex
"
)
mImage
(
image
)
{
}
SharedSurface_EGLImage
:
:
~
SharedSurface_EGLImage
(
)
{
const
auto
&
gle
=
GLContextEGL
:
:
Cast
(
mDesc
.
gl
)
;
const
auto
&
egl
=
gle
-
>
mEgl
;
egl
-
>
fDestroyImage
(
egl
-
>
Display
(
)
mImage
)
;
if
(
mSync
)
{
egl
-
>
fDestroySync
(
egl
-
>
Display
(
)
mSync
)
;
mSync
=
0
;
}
}
void
SharedSurface_EGLImage
:
:
ProducerReleaseImpl
(
)
{
const
auto
&
gl
=
GLContextEGL
:
:
Cast
(
mDesc
.
gl
)
;
const
auto
&
egl
=
gl
-
>
mEgl
;
MutexAutoLock
lock
(
mMutex
)
;
gl
-
>
MakeCurrent
(
)
;
if
(
egl
-
>
IsExtensionSupported
(
GLLibraryEGL
:
:
KHR_fence_sync
)
&
&
gl
-
>
IsExtensionSupported
(
GLContext
:
:
OES_EGL_sync
)
)
{
if
(
mSync
)
{
MOZ_RELEASE_ASSERT
(
false
"
GFX
:
Non
-
recycleable
should
not
Fence
twice
.
"
)
;
MOZ_ALWAYS_TRUE
(
egl
-
>
fDestroySync
(
egl
-
>
Display
(
)
mSync
)
)
;
mSync
=
0
;
}
mSync
=
egl
-
>
fCreateSync
(
egl
-
>
Display
(
)
LOCAL_EGL_SYNC_FENCE
nullptr
)
;
if
(
mSync
)
{
gl
-
>
fFlush
(
)
;
return
;
}
}
MOZ_ASSERT
(
!
mSync
)
;
gl
-
>
fFinish
(
)
;
}
void
SharedSurface_EGLImage
:
:
ProducerReadAcquireImpl
(
)
{
const
auto
&
gle
=
GLContextEGL
:
:
Cast
(
mDesc
.
gl
)
;
const
auto
&
egl
=
gle
-
>
mEgl
;
if
(
mSync
)
{
egl
-
>
fClientWaitSync
(
egl
-
>
Display
(
)
mSync
0
LOCAL_EGL_FOREVER
)
;
}
}
Maybe
<
layers
:
:
SurfaceDescriptor
>
SharedSurface_EGLImage
:
:
ToSurfaceDescriptor
(
)
{
return
Some
(
layers
:
:
EGLImageDescriptor
(
(
uintptr_t
)
mImage
(
uintptr_t
)
mSync
mDesc
.
size
true
)
)
;
}
bool
SharedSurface_EGLImage
:
:
ReadbackBySharedHandle
(
gfx
:
:
DataSourceSurface
*
out_surface
)
{
const
auto
&
gle
=
GLContextEGL
:
:
Cast
(
mDesc
.
gl
)
;
const
auto
&
egl
=
gle
-
>
mEgl
;
MOZ_ASSERT
(
out_surface
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
egl
-
>
ReadbackEGLImage
(
mImage
out_surface
)
;
}
#
ifdef
MOZ_WIDGET_ANDROID
UniquePtr
<
SharedSurface_SurfaceTexture
>
SharedSurface_SurfaceTexture
:
:
Create
(
const
SharedSurfaceDesc
&
desc
)
{
const
auto
&
size
=
desc
.
size
;
jni
:
:
Object
:
:
LocalRef
surfaceObj
=
java
:
:
SurfaceAllocator
:
:
AcquireSurface
(
size
.
width
size
.
height
true
)
;
if
(
!
surfaceObj
)
{
surfaceObj
=
java
:
:
SurfaceAllocator
:
:
AcquireSurface
(
size
.
width
size
.
height
false
)
;
}
if
(
!
surfaceObj
)
{
NS_WARNING
(
"
Failed
to
allocate
SurfaceTexture
!
"
)
;
return
nullptr
;
}
const
auto
surface
=
java
:
:
GeckoSurface
:
:
Ref
:
:
From
(
surfaceObj
)
;
AndroidNativeWindow
window
(
surface
)
;
const
auto
&
gle
=
GLContextEGL
:
:
Cast
(
desc
.
gl
)
;
MOZ_ASSERT
(
gle
)
;
const
auto
eglSurface
=
gle
-
>
CreateCompatibleSurface
(
window
.
NativeWindow
(
)
)
;
if
(
!
eglSurface
)
return
nullptr
;
return
AsUnique
(
new
SharedSurface_SurfaceTexture
(
desc
surface
eglSurface
)
)
;
}
SharedSurface_SurfaceTexture
:
:
SharedSurface_SurfaceTexture
(
const
SharedSurfaceDesc
&
desc
java
:
:
GeckoSurface
:
:
Param
surface
const
EGLSurface
eglSurface
)
:
SharedSurface
(
desc
nullptr
)
mSurface
(
surface
)
mEglSurface
(
eglSurface
)
{
}
SharedSurface_SurfaceTexture
:
:
~
SharedSurface_SurfaceTexture
(
)
{
if
(
mOrigEglSurface
)
{
UnlockProd
(
)
;
}
GLContextProviderEGL
:
:
DestroyEGLSurface
(
mEglSurface
)
;
java
:
:
SurfaceAllocator
:
:
DisposeSurface
(
mSurface
)
;
}
void
SharedSurface_SurfaceTexture
:
:
LockProdImpl
(
)
{
MOZ_RELEASE_ASSERT
(
mSurface
-
>
GetAvailable
(
)
)
;
GLContextEGL
*
gl
=
GLContextEGL
:
:
Cast
(
mDesc
.
gl
)
;
mOrigEglSurface
=
gl
-
>
GetEGLSurfaceOverride
(
)
;
gl
-
>
SetEGLSurfaceOverride
(
mEglSurface
)
;
}
void
SharedSurface_SurfaceTexture
:
:
UnlockProdImpl
(
)
{
MOZ_RELEASE_ASSERT
(
mSurface
-
>
GetAvailable
(
)
)
;
GLContextEGL
*
gl
=
GLContextEGL
:
:
Cast
(
mDesc
.
gl
)
;
MOZ_ASSERT
(
gl
-
>
GetEGLSurfaceOverride
(
)
=
=
mEglSurface
)
;
gl
-
>
SetEGLSurfaceOverride
(
mOrigEglSurface
)
;
mOrigEglSurface
=
nullptr
;
}
void
SharedSurface_SurfaceTexture
:
:
Commit
(
)
{
MOZ_RELEASE_ASSERT
(
mSurface
-
>
GetAvailable
(
)
)
;
LockProdImpl
(
)
;
mDesc
.
gl
-
>
SwapBuffers
(
)
;
UnlockProdImpl
(
)
;
mSurface
-
>
SetAvailable
(
false
)
;
}
void
SharedSurface_SurfaceTexture
:
:
WaitForBufferOwnership
(
)
{
mSurface
-
>
SetAvailable
(
true
)
;
}
bool
SharedSurface_SurfaceTexture
:
:
IsBufferAvailable
(
)
const
{
return
mSurface
-
>
GetAvailable
(
)
;
}
Maybe
<
layers
:
:
SurfaceDescriptor
>
SharedSurface_SurfaceTexture
:
:
ToSurfaceDescriptor
(
)
{
return
Some
(
layers
:
:
SurfaceTextureDescriptor
(
mSurface
-
>
GetHandle
(
)
mDesc
.
size
gfx
:
:
SurfaceFormat
:
:
R8G8B8A8
false
false
)
)
;
}
SurfaceFactory_SurfaceTexture
:
:
SurfaceFactory_SurfaceTexture
(
GLContext
&
gl
)
:
SurfaceFactory
(
{
&
gl
SharedSurfaceType
:
:
AndroidSurfaceTexture
layers
:
:
TextureType
:
:
AndroidNativeWindow
true
}
)
{
}
#
endif
}
}
