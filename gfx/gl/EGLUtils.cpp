#
include
"
EGLUtils
.
h
"
#
include
"
GLContextEGL
.
h
"
#
include
"
GLLibraryEGL
.
h
"
namespace
mozilla
{
namespace
gl
{
bool
DoesEGLContextSupportSharingWithEGLImage
(
GLContext
*
gl
)
{
const
auto
&
gle
=
GLContextEGL
:
:
Cast
(
gl
)
;
const
auto
&
egl
=
gle
-
>
mEgl
;
return
egl
-
>
HasKHRImageBase
(
)
&
&
egl
-
>
HasKHRImageTexture2D
(
)
&
&
gl
-
>
IsExtensionSupported
(
GLContext
:
:
OES_EGL_image
)
;
}
EGLImage
CreateEGLImage
(
GLContext
*
gl
GLuint
tex
)
{
MOZ_ASSERT
(
DoesEGLContextSupportSharingWithEGLImage
(
gl
)
)
;
const
auto
&
gle
=
GLContextEGL
:
:
Cast
(
gl
)
;
const
auto
&
egl
=
gle
-
>
mEgl
;
EGLClientBuffer
clientBuffer
=
(
EGLClientBuffer
)
(
(
uint64_t
)
tex
)
;
EGLImage
image
=
egl
-
>
fCreateImage
(
egl
-
>
Display
(
)
gle
-
>
mContext
LOCAL_EGL_GL_TEXTURE_2D
clientBuffer
nullptr
)
;
return
image
;
}
EGLImageWrapper
*
EGLImageWrapper
:
:
Create
(
GLContext
*
gl
GLuint
tex
)
{
MOZ_ASSERT
(
DoesEGLContextSupportSharingWithEGLImage
(
gl
)
)
;
const
auto
&
gle
=
GLContextEGL
:
:
Cast
(
gl
)
;
const
auto
&
egl
=
gle
-
>
mEgl
;
const
auto
&
display
=
egl
-
>
Display
(
)
;
EGLClientBuffer
clientBuffer
=
(
EGLClientBuffer
)
(
(
uint64_t
)
tex
)
;
EGLImage
image
=
egl
-
>
fCreateImage
(
display
gle
-
>
mContext
LOCAL_EGL_GL_TEXTURE_2D
clientBuffer
nullptr
)
;
if
(
!
image
)
{
#
ifdef
DEBUG
printf_stderr
(
"
Could
not
create
EGL
images
:
ERROR
(
0x
%
04x
)
\
n
"
egl
-
>
fGetError
(
)
)
;
#
endif
return
nullptr
;
}
return
new
EGLImageWrapper
(
egl
display
image
)
;
}
EGLImageWrapper
:
:
EGLImageWrapper
(
GLLibraryEGL
*
library
EGLDisplay
display
EGLImage
image
)
:
mLibrary
(
library
)
mDisplay
(
display
)
mImage
(
image
)
mSync
(
0
)
{
MOZ_ASSERT
(
mImage
)
;
}
EGLImageWrapper
:
:
~
EGLImageWrapper
(
)
{
mLibrary
-
>
fDestroyImage
(
mDisplay
mImage
)
;
}
bool
EGLImageWrapper
:
:
FenceSync
(
GLContext
*
gl
)
{
MOZ_ASSERT
(
!
mSync
)
;
if
(
mLibrary
-
>
IsExtensionSupported
(
GLLibraryEGL
:
:
KHR_fence_sync
)
)
{
mSync
=
mLibrary
-
>
fCreateSync
(
mDisplay
LOCAL_EGL_SYNC_FENCE
nullptr
)
;
gl
-
>
fFlush
(
)
;
}
if
(
!
mSync
)
{
gl
-
>
fFinish
(
)
;
}
return
true
;
}
bool
EGLImageWrapper
:
:
ClientWaitSync
(
)
{
if
(
!
mSync
)
{
return
true
;
}
const
uint64_t
ns_per_ms
=
1000
*
1000
;
EGLTime
timeout
=
1000
*
ns_per_ms
;
EGLint
result
=
mLibrary
-
>
fClientWaitSync
(
mDisplay
mSync
0
timeout
)
;
mLibrary
-
>
fDestroySync
(
mDisplay
mSync
)
;
mSync
=
nullptr
;
return
result
=
=
LOCAL_EGL_CONDITION_SATISFIED
;
}
}
}
