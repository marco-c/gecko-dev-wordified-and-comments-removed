#
include
"
GLContextProvider
.
h
"
#
include
"
GLContextCGL
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
<
OpenGL
/
gl
.
h
>
#
include
"
gfxFailure
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
StaticPrefs_gl
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
prenv
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
MozFramebuffer
.
h
"
#
include
"
mozilla
/
layers
/
CompositorOptions
.
h
"
#
include
"
mozilla
/
widget
/
CompositorWidget
.
h
"
#
include
"
ScopedGLHelpers
.
h
"
#
include
<
OpenGL
/
OpenGL
.
h
>
namespace
mozilla
{
namespace
gl
{
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
widget
;
class
CGLLibrary
{
public
:
bool
EnsureInitialized
(
)
{
if
(
mInitialized
)
{
return
true
;
}
if
(
!
mOGLLibrary
)
{
mOGLLibrary
=
PR_LoadLibrary
(
"
/
System
/
Library
/
Frameworks
/
OpenGL
.
framework
/
OpenGL
"
)
;
if
(
!
mOGLLibrary
)
{
NS_WARNING
(
"
Couldn
'
t
load
OpenGL
Framework
.
"
)
;
return
false
;
}
}
mInitialized
=
true
;
return
true
;
}
const
auto
&
Library
(
)
const
{
return
mOGLLibrary
;
}
private
:
bool
mInitialized
=
false
;
PRLibrary
*
mOGLLibrary
=
nullptr
;
}
;
CGLLibrary
sCGLLibrary
;
GLContextCGL
:
:
GLContextCGL
(
CreateContextFlags
flags
const
SurfaceCaps
&
caps
NSOpenGLContext
*
context
bool
isOffscreen
)
:
GLContext
(
flags
caps
nullptr
isOffscreen
)
mContext
(
context
)
{
CGDisplayRegisterReconfigurationCallback
(
DisplayReconfigurationCallback
this
)
;
}
GLContextCGL
:
:
~
GLContextCGL
(
)
{
MarkDestroyed
(
)
;
CGDisplayRemoveReconfigurationCallback
(
DisplayReconfigurationCallback
this
)
;
if
(
mContext
)
{
if
(
[
NSOpenGLContext
currentContext
]
=
=
mContext
)
{
[
NSOpenGLContext
clearCurrentContext
]
;
}
[
mContext
release
]
;
}
}
CGLContextObj
GLContextCGL
:
:
GetCGLContext
(
)
const
{
return
static_cast
<
CGLContextObj
>
(
[
mContext
CGLContextObj
]
)
;
}
bool
GLContextCGL
:
:
MakeCurrentImpl
(
)
const
{
if
(
mContext
)
{
[
mContext
makeCurrentContext
]
;
MOZ_ASSERT
(
IsCurrentImpl
(
)
)
;
GLint
swapInt
=
StaticPrefs
:
:
layout_frame_rate
(
)
=
=
0
?
0
:
1
;
[
mContext
setValues
:
&
swapInt
forParameter
:
NSOpenGLCPSwapInterval
]
;
}
return
true
;
}
bool
GLContextCGL
:
:
IsCurrentImpl
(
)
const
{
return
[
NSOpenGLContext
currentContext
]
=
=
mContext
;
}
void
GLContextCGL
:
:
DisplayReconfigurationCallback
(
CGDirectDisplayID
aDisplay
CGDisplayChangeSummaryFlags
aFlags
void
*
aUserInfo
)
{
if
(
aFlags
&
kCGDisplaySetModeFlag
)
{
static_cast
<
GLContextCGL
*
>
(
aUserInfo
)
-
>
mActiveGPUSwitchMayHaveOccurred
=
true
;
}
}
static
NSOpenGLContext
*
CreateWithFormat
(
const
NSOpenGLPixelFormatAttribute
*
attribs
)
{
NSOpenGLPixelFormat
*
format
=
[
[
NSOpenGLPixelFormat
alloc
]
initWithAttributes
:
attribs
]
;
if
(
!
format
)
{
NS_WARNING
(
"
Failed
to
create
NSOpenGLPixelFormat
.
"
)
;
return
nullptr
;
}
NSOpenGLContext
*
context
=
[
[
NSOpenGLContext
alloc
]
initWithFormat
:
format
shareContext
:
nullptr
]
;
[
format
release
]
;
return
context
;
}
static
CGOpenGLDisplayMask
GetFreshContextDisplayMask
(
)
{
NSOpenGLPixelFormatAttribute
attribs
[
]
=
{
NSOpenGLPFAAllowOfflineRenderers
0
}
;
NSOpenGLPixelFormat
*
pixelFormat
=
[
[
NSOpenGLPixelFormat
alloc
]
initWithAttributes
:
attribs
]
;
MOZ_RELEASE_ASSERT
(
pixelFormat
)
;
NSOpenGLContext
*
context
=
[
[
NSOpenGLContext
alloc
]
initWithFormat
:
pixelFormat
shareContext
:
nullptr
]
;
GLint
displayMask
=
0
;
[
pixelFormat
getValues
:
&
displayMask
forAttribute
:
NSOpenGLPFAScreenMask
forVirtualScreen
:
[
context
currentVirtualScreen
]
]
;
[
pixelFormat
release
]
;
[
context
release
]
;
return
static_cast
<
CGOpenGLDisplayMask
>
(
displayMask
)
;
}
static
bool
IsSameGPU
(
CGOpenGLDisplayMask
mask1
CGOpenGLDisplayMask
mask2
)
{
if
(
(
mask1
&
mask2
)
!
=
0
)
{
return
true
;
}
return
!
mask1
&
&
!
mask2
;
}
static
NSOpenGLPixelFormat
*
GetPixelFormatForContext
(
NSOpenGLContext
*
aContext
)
{
if
(
[
aContext
respondsToSelector
:
selector
(
pixelFormat
)
]
)
{
return
[
aContext
pixelFormat
]
;
}
return
[
[
[
NSOpenGLPixelFormat
alloc
]
initWithCGLPixelFormatObj
:
CGLGetPixelFormat
(
[
aContext
CGLContextObj
]
)
]
autorelease
]
;
}
void
GLContextCGL
:
:
MigrateToActiveGPU
(
)
{
if
(
!
mActiveGPUSwitchMayHaveOccurred
.
compareExchange
(
true
false
)
)
{
return
;
}
CGOpenGLDisplayMask
newPreferredDisplayMask
=
GetFreshContextDisplayMask
(
)
;
NSOpenGLPixelFormat
*
pixelFormat
=
GetPixelFormatForContext
(
mContext
)
;
GLint
currentVirtualScreen
=
[
mContext
currentVirtualScreen
]
;
GLint
currentDisplayMask
=
0
;
[
pixelFormat
getValues
:
&
currentDisplayMask
forAttribute
:
NSOpenGLPFAScreenMask
forVirtualScreen
:
currentVirtualScreen
]
;
if
(
IsSameGPU
(
currentDisplayMask
newPreferredDisplayMask
)
)
{
return
;
}
for
(
const
auto
i
:
IntegerRange
(
[
pixelFormat
numberOfVirtualScreens
]
)
)
{
GLint
displayMask
=
0
;
[
pixelFormat
getValues
:
&
displayMask
forAttribute
:
NSOpenGLPFAScreenMask
forVirtualScreen
:
i
]
;
if
(
IsSameGPU
(
displayMask
newPreferredDisplayMask
)
)
{
CGLSetVirtualScreen
(
[
mContext
CGLContextObj
]
i
)
;
return
;
}
}
}
GLenum
GLContextCGL
:
:
GetPreferredARGB32Format
(
)
const
{
return
LOCAL_GL_BGRA
;
}
bool
GLContextCGL
:
:
SwapBuffers
(
)
{
AUTO_PROFILER_LABEL
(
"
GLContextCGL
:
:
SwapBuffers
"
GRAPHICS
)
;
fFlush
(
)
;
return
true
;
}
void
GLContextCGL
:
:
GetWSIInfo
(
nsCString
*
const
out
)
const
{
out
-
>
AppendLiteral
(
"
CGL
"
)
;
}
Maybe
<
SymbolLoader
>
GLContextCGL
:
:
GetSymbolLoader
(
)
const
{
const
auto
&
lib
=
sCGLLibrary
.
Library
(
)
;
return
Some
(
SymbolLoader
(
*
lib
)
)
;
}
already_AddRefed
<
GLContext
>
GLContextProviderCGL
:
:
CreateWrappingExisting
(
void
*
void
*
)
{
return
nullptr
;
}
already_AddRefed
<
GLContext
>
GLContextProviderCGL
:
:
CreateForCompositorWidget
(
CompositorWidget
*
aCompositorWidget
bool
aWebRender
bool
aForceAccelerated
)
{
CreateContextFlags
flags
=
CreateContextFlags
:
:
ALLOW_OFFLINE_RENDERER
;
if
(
aForceAccelerated
)
{
flags
|
=
CreateContextFlags
:
:
FORCE_ENABLE_HARDWARE
;
}
if
(
!
aWebRender
)
{
flags
|
=
CreateContextFlags
:
:
REQUIRE_COMPAT_PROFILE
;
}
nsCString
failureUnused
;
return
CreateHeadless
(
flags
&
failureUnused
)
;
}
static
already_AddRefed
<
GLContextCGL
>
CreateOffscreenFBOContext
(
CreateContextFlags
flags
)
{
if
(
!
sCGLLibrary
.
EnsureInitialized
(
)
)
{
return
nullptr
;
}
NSOpenGLContext
*
context
=
nullptr
;
std
:
:
vector
<
NSOpenGLPixelFormatAttribute
>
attribs
;
if
(
!
StaticPrefs
:
:
gl_allow_high_power
(
)
)
{
flags
&
=
~
CreateContextFlags
:
:
HIGH_POWER
;
}
if
(
flags
&
CreateContextFlags
:
:
ALLOW_OFFLINE_RENDERER
|
|
!
(
flags
&
CreateContextFlags
:
:
HIGH_POWER
)
)
{
attribs
.
push_back
(
NSOpenGLPFAAllowOfflineRenderers
)
;
}
if
(
flags
&
CreateContextFlags
:
:
FORCE_ENABLE_HARDWARE
)
{
attribs
.
push_back
(
NSOpenGLPFAAccelerated
)
;
}
if
(
!
(
flags
&
CreateContextFlags
:
:
REQUIRE_COMPAT_PROFILE
)
)
{
auto
coreAttribs
=
attribs
;
coreAttribs
.
push_back
(
NSOpenGLPFAOpenGLProfile
)
;
coreAttribs
.
push_back
(
NSOpenGLProfileVersion3_2Core
)
;
coreAttribs
.
push_back
(
0
)
;
context
=
CreateWithFormat
(
coreAttribs
.
data
(
)
)
;
}
if
(
!
context
)
{
attribs
.
push_back
(
0
)
;
context
=
CreateWithFormat
(
attribs
.
data
(
)
)
;
}
if
(
!
context
)
{
NS_WARNING
(
"
Failed
to
create
NSOpenGLContext
.
"
)
;
return
nullptr
;
}
RefPtr
<
GLContextCGL
>
glContext
=
new
GLContextCGL
(
flags
SurfaceCaps
:
:
Any
(
)
context
true
)
;
if
(
flags
&
CreateContextFlags
:
:
PREFER_MULTITHREADED
)
{
CGLEnable
(
glContext
-
>
GetCGLContext
(
)
kCGLCEMPEngine
)
;
}
return
glContext
.
forget
(
)
;
}
already_AddRefed
<
GLContext
>
GLContextProviderCGL
:
:
CreateHeadless
(
CreateContextFlags
flags
nsACString
*
const
out_failureId
)
{
RefPtr
<
GLContextCGL
>
gl
;
gl
=
CreateOffscreenFBOContext
(
flags
)
;
if
(
!
gl
)
{
*
out_failureId
=
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_CGL_FBO
"
)
;
return
nullptr
;
}
if
(
!
gl
-
>
Init
(
)
)
{
*
out_failureId
=
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_CGL_INIT
"
)
;
NS_WARNING
(
"
Failed
during
Init
.
"
)
;
return
nullptr
;
}
return
gl
.
forget
(
)
;
}
already_AddRefed
<
GLContext
>
GLContextProviderCGL
:
:
CreateOffscreen
(
const
IntSize
&
size
const
SurfaceCaps
&
minCaps
CreateContextFlags
flags
nsACString
*
const
out_failureId
)
{
RefPtr
<
GLContext
>
gl
=
CreateHeadless
(
flags
out_failureId
)
;
if
(
!
gl
)
{
return
nullptr
;
}
if
(
!
gl
-
>
InitOffscreen
(
size
minCaps
)
)
{
*
out_failureId
=
NS_LITERAL_CSTRING
(
"
FEATURE_FAILURE_CGL_INIT
"
)
;
return
nullptr
;
}
return
gl
.
forget
(
)
;
}
static
RefPtr
<
GLContext
>
gGlobalContext
;
GLContext
*
GLContextProviderCGL
:
:
GetGlobalContext
(
)
{
static
bool
triedToCreateContext
=
false
;
if
(
!
triedToCreateContext
)
{
triedToCreateContext
=
true
;
MOZ_RELEASE_ASSERT
(
!
gGlobalContext
)
;
nsCString
discardFailureId
;
RefPtr
<
GLContext
>
temp
=
CreateHeadless
(
CreateContextFlags
:
:
NONE
&
discardFailureId
)
;
gGlobalContext
=
temp
;
if
(
!
gGlobalContext
)
{
NS_WARNING
(
"
Couldn
'
t
init
gGlobalContext
.
"
)
;
}
}
return
gGlobalContext
;
}
void
GLContextProviderCGL
:
:
Shutdown
(
)
{
gGlobalContext
=
nullptr
;
}
}
}
