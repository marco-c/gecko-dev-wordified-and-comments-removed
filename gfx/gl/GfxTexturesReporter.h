#
ifndef
GFXTEXTURESREPORTER_H_
#
define
GFXTEXTURESREPORTER_H_
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
GLTypes
.
h
"
namespace
mozilla
{
namespace
gl
{
class
GfxTexturesReporter
final
:
public
nsIMemoryReporter
{
~
GfxTexturesReporter
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
GfxTexturesReporter
(
)
{
#
ifdef
DEBUG
static
bool
hasRun
=
false
;
MOZ_ASSERT
(
!
hasRun
)
;
hasRun
=
true
;
#
endif
}
enum
MemoryUse
{
MemoryAllocated
MemoryFreed
}
;
static
void
UpdateAmount
(
MemoryUse
action
size_t
amount
)
;
static
void
UpdateWasteAmount
(
int32_t
delta
)
{
if
(
delta
>
=
0
)
{
sTileWasteAmount
+
=
static_cast
<
size_t
>
(
delta
)
;
}
else
{
sTileWasteAmount
-
=
static_cast
<
size_t
>
(
-
delta
)
;
}
}
NS_IMETHOD
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
override
{
MOZ_COLLECT_REPORT
(
"
gfx
-
tiles
-
waste
"
KIND_OTHER
UNITS_BYTES
int64_t
(
sTileWasteAmount
)
"
Memory
lost
due
to
tiles
extending
past
content
boundaries
"
)
;
MOZ_COLLECT_REPORT
(
"
gfx
-
textures
"
KIND_OTHER
UNITS_BYTES
int64_t
(
sAmount
)
"
Memory
used
for
storing
GL
textures
.
"
)
;
MOZ_COLLECT_REPORT
(
"
gfx
-
textures
-
peak
"
KIND_OTHER
UNITS_BYTES
int64_t
(
sPeakAmount
)
"
Peak
memory
used
for
storing
GL
textures
.
"
)
;
return
NS_OK
;
}
private
:
static
Atomic
<
size_t
>
sAmount
;
static
Atomic
<
size_t
>
sPeakAmount
;
static
Atomic
<
size_t
>
sTileWasteAmount
;
}
;
class
GfxTextureWasteTracker
{
public
:
GfxTextureWasteTracker
(
)
:
mBytes
(
0
)
{
MOZ_COUNT_CTOR
(
GfxTextureWasteTracker
)
;
}
void
Update
(
int32_t
aPixelArea
int32_t
aBytesPerPixel
)
{
GfxTexturesReporter
:
:
UpdateWasteAmount
(
-
mBytes
)
;
mBytes
=
aPixelArea
*
aBytesPerPixel
;
GfxTexturesReporter
:
:
UpdateWasteAmount
(
mBytes
)
;
}
~
GfxTextureWasteTracker
(
)
{
GfxTexturesReporter
:
:
UpdateWasteAmount
(
-
mBytes
)
;
MOZ_COUNT_DTOR
(
GfxTextureWasteTracker
)
;
}
private
:
GfxTextureWasteTracker
(
const
GfxTextureWasteTracker
&
aRef
)
;
int32_t
mBytes
;
}
;
}
}
#
endif
