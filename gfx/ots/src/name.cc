#
include
"
name
.
h
"
#
include
<
algorithm
>
#
include
<
cstring
>
namespace
{
bool
ValidInPsName
(
char
c
)
{
return
(
c
>
0x20
&
&
c
<
0x7f
&
&
!
std
:
:
strchr
(
"
[
]
(
)
{
}
<
>
/
%
"
c
)
)
;
}
bool
CheckPsNameAscii
(
const
std
:
:
string
&
name
)
{
for
(
unsigned
i
=
0
;
i
<
name
.
size
(
)
;
+
+
i
)
{
if
(
!
ValidInPsName
(
name
[
i
]
)
)
{
return
false
;
}
}
return
true
;
}
bool
CheckPsNameUtf16Be
(
const
std
:
:
string
&
name
)
{
if
(
(
name
.
size
(
)
&
1
)
!
=
0
)
return
false
;
for
(
unsigned
i
=
0
;
i
<
name
.
size
(
)
;
i
+
=
2
)
{
if
(
name
[
i
]
!
=
0
)
{
return
false
;
}
if
(
!
ValidInPsName
(
name
[
i
+
1
]
)
)
{
return
false
;
}
}
return
true
;
}
void
AssignToUtf16BeFromAscii
(
std
:
:
string
*
target
const
std
:
:
string
&
source
)
{
target
-
>
resize
(
source
.
size
(
)
*
2
)
;
for
(
unsigned
i
=
0
j
=
0
;
i
<
source
.
size
(
)
;
i
+
+
)
{
(
*
target
)
[
j
+
+
]
=
'
\
0
'
;
(
*
target
)
[
j
+
+
]
=
source
[
i
]
;
}
}
}
namespace
ots
{
bool
OpenTypeNAME
:
:
Parse
(
const
uint8_t
*
data
size_t
length
)
{
Buffer
table
(
data
length
)
;
uint16_t
format
=
0
;
if
(
!
table
.
ReadU16
(
&
format
)
|
|
format
>
1
)
{
return
Error
(
"
Failed
to
read
table
format
or
bad
format
%
d
"
format
)
;
}
uint16_t
count
=
0
;
if
(
!
table
.
ReadU16
(
&
count
)
)
{
return
Error
(
"
Failed
to
read
name
count
"
)
;
}
uint16_t
string_offset
=
0
;
if
(
!
table
.
ReadU16
(
&
string_offset
)
|
|
string_offset
>
length
)
{
return
Error
(
"
Failed
to
read
or
bad
stringOffset
"
)
;
}
const
char
*
string_base
=
reinterpret_cast
<
const
char
*
>
(
data
)
+
string_offset
;
bool
sort_required
=
false
;
for
(
unsigned
i
=
0
;
i
<
count
;
+
+
i
)
{
NameRecord
rec
;
uint16_t
name_length
name_offset
=
0
;
if
(
!
table
.
ReadU16
(
&
rec
.
platform_id
)
|
|
!
table
.
ReadU16
(
&
rec
.
encoding_id
)
|
|
!
table
.
ReadU16
(
&
rec
.
language_id
)
|
|
!
table
.
ReadU16
(
&
rec
.
name_id
)
|
|
!
table
.
ReadU16
(
&
name_length
)
|
|
!
table
.
ReadU16
(
&
name_offset
)
)
{
return
Error
(
"
Failed
to
read
name
entry
%
d
"
i
)
;
}
switch
(
rec
.
platform_id
)
{
case
0
:
if
(
rec
.
encoding_id
>
6
)
{
continue
;
}
break
;
case
1
:
if
(
rec
.
encoding_id
>
32
)
{
continue
;
}
break
;
case
2
:
if
(
rec
.
encoding_id
>
2
)
{
continue
;
}
break
;
case
3
:
if
(
rec
.
encoding_id
>
6
&
&
rec
.
encoding_id
!
=
10
)
{
continue
;
}
break
;
case
4
:
if
(
rec
.
encoding_id
>
255
)
{
continue
;
}
break
;
default
:
continue
;
}
const
unsigned
name_end
=
static_cast
<
unsigned
>
(
string_offset
)
+
name_offset
+
name_length
;
if
(
name_end
>
length
)
{
continue
;
}
rec
.
text
.
resize
(
name_length
)
;
rec
.
text
.
assign
(
string_base
+
name_offset
name_length
)
;
if
(
rec
.
name_id
=
=
6
)
{
if
(
rec
.
platform_id
=
=
1
)
{
if
(
!
CheckPsNameAscii
(
rec
.
text
)
)
{
continue
;
}
}
else
if
(
rec
.
platform_id
=
=
0
|
|
rec
.
platform_id
=
=
3
)
{
if
(
!
CheckPsNameUtf16Be
(
rec
.
text
)
)
{
continue
;
}
}
}
if
(
!
this
-
>
names
.
empty
(
)
&
&
!
(
this
-
>
names
.
back
(
)
<
rec
)
)
{
Warning
(
"
name
records
are
not
sorted
.
"
)
;
sort_required
=
true
;
}
this
-
>
names
.
push_back
(
rec
)
;
}
if
(
format
=
=
1
)
{
uint16_t
lang_tag_count
;
if
(
!
table
.
ReadU16
(
&
lang_tag_count
)
)
{
return
Error
(
"
Failed
to
read
langTagCount
"
)
;
}
for
(
unsigned
i
=
0
;
i
<
lang_tag_count
;
+
+
i
)
{
uint16_t
tag_length
=
0
;
uint16_t
tag_offset
=
0
;
if
(
!
table
.
ReadU16
(
&
tag_length
)
|
|
!
table
.
ReadU16
(
&
tag_offset
)
)
{
return
Error
(
"
Faile
to
read
length
or
offset
for
langTagRecord
%
d
"
i
)
;
}
const
unsigned
tag_end
=
static_cast
<
unsigned
>
(
string_offset
)
+
tag_offset
+
tag_length
;
if
(
tag_end
>
length
)
{
return
Error
(
"
bad
end
of
tag
%
d
>
%
ld
for
langTagRecord
%
d
"
tag_end
length
i
)
;
}
std
:
:
string
tag
(
string_base
+
tag_offset
tag_length
)
;
this
-
>
lang_tags
.
push_back
(
tag
)
;
}
}
if
(
table
.
offset
(
)
>
string_offset
)
{
return
Error
(
"
Bad
table
offset
%
ld
>
%
d
"
table
.
offset
(
)
string_offset
)
;
}
static
const
uint16_t
kStdNameCount
=
7
;
static
const
char
*
kStdNames
[
kStdNameCount
]
=
{
NULL
"
OTS
derived
font
"
"
Unspecified
"
NULL
"
OTS
derived
font
"
"
1
.
000
"
"
OTS
-
derived
-
font
"
}
;
bool
mac_name
[
kStdNameCount
]
=
{
0
}
;
bool
win_name
[
kStdNameCount
]
=
{
0
}
;
for
(
std
:
:
vector
<
NameRecord
>
:
:
iterator
name_iter
=
this
-
>
names
.
begin
(
)
;
name_iter
!
=
this
-
>
names
.
end
(
)
;
+
+
name_iter
)
{
const
uint16_t
id
=
name_iter
-
>
name_id
;
if
(
id
>
=
kStdNameCount
|
|
kStdNames
[
id
]
=
=
NULL
)
{
continue
;
}
if
(
name_iter
-
>
platform_id
=
=
1
)
{
mac_name
[
id
]
=
true
;
continue
;
}
if
(
name_iter
-
>
platform_id
=
=
3
)
{
win_name
[
id
]
=
true
;
continue
;
}
}
for
(
uint16_t
i
=
0
;
i
<
kStdNameCount
;
+
+
i
)
{
if
(
kStdNames
[
i
]
=
=
NULL
)
{
continue
;
}
if
(
!
mac_name
[
i
]
&
&
!
win_name
[
i
]
)
{
NameRecord
mac_rec
(
1
0
0
i
)
;
mac_rec
.
text
.
assign
(
kStdNames
[
i
]
)
;
NameRecord
win_rec
(
3
1
1033
i
)
;
AssignToUtf16BeFromAscii
(
&
win_rec
.
text
std
:
:
string
(
kStdNames
[
i
]
)
)
;
this
-
>
names
.
push_back
(
mac_rec
)
;
this
-
>
names
.
push_back
(
win_rec
)
;
sort_required
=
true
;
}
}
if
(
sort_required
)
{
std
:
:
sort
(
this
-
>
names
.
begin
(
)
this
-
>
names
.
end
(
)
)
;
}
return
true
;
}
bool
OpenTypeNAME
:
:
Serialize
(
OTSStream
*
out
)
{
uint16_t
name_count
=
static_cast
<
uint16_t
>
(
this
-
>
names
.
size
(
)
)
;
uint16_t
lang_tag_count
=
static_cast
<
uint16_t
>
(
this
-
>
lang_tags
.
size
(
)
)
;
uint16_t
format
=
0
;
size_t
string_offset
=
6
+
name_count
*
12
;
if
(
this
-
>
lang_tags
.
size
(
)
>
0
)
{
format
=
1
;
string_offset
+
=
2
+
lang_tag_count
*
4
;
}
if
(
string_offset
>
0xffff
)
{
return
Error
(
"
Bad
stringOffset
:
%
ld
"
string_offset
)
;
}
if
(
!
out
-
>
WriteU16
(
format
)
|
|
!
out
-
>
WriteU16
(
name_count
)
|
|
!
out
-
>
WriteU16
(
static_cast
<
uint16_t
>
(
string_offset
)
)
)
{
return
Error
(
"
Failed
to
write
name
header
"
)
;
}
std
:
:
string
string_data
;
for
(
std
:
:
vector
<
NameRecord
>
:
:
const_iterator
name_iter
=
this
-
>
names
.
begin
(
)
;
name_iter
!
=
this
-
>
names
.
end
(
)
;
+
+
name_iter
)
{
const
NameRecord
&
rec
=
*
name_iter
;
if
(
string_data
.
size
(
)
+
rec
.
text
.
size
(
)
>
std
:
:
numeric_limits
<
uint16_t
>
:
:
max
(
)
|
|
!
out
-
>
WriteU16
(
rec
.
platform_id
)
|
|
!
out
-
>
WriteU16
(
rec
.
encoding_id
)
|
|
!
out
-
>
WriteU16
(
rec
.
language_id
)
|
|
!
out
-
>
WriteU16
(
rec
.
name_id
)
|
|
!
out
-
>
WriteU16
(
static_cast
<
uint16_t
>
(
rec
.
text
.
size
(
)
)
)
|
|
!
out
-
>
WriteU16
(
static_cast
<
uint16_t
>
(
string_data
.
size
(
)
)
)
)
{
return
Error
(
"
Faile
to
write
nameRecord
"
)
;
}
string_data
.
append
(
rec
.
text
)
;
}
if
(
format
=
=
1
)
{
if
(
!
out
-
>
WriteU16
(
lang_tag_count
)
)
{
return
Error
(
"
Faile
to
write
langTagCount
"
)
;
}
for
(
std
:
:
vector
<
std
:
:
string
>
:
:
const_iterator
tag_iter
=
this
-
>
lang_tags
.
begin
(
)
;
tag_iter
!
=
this
-
>
lang_tags
.
end
(
)
;
+
+
tag_iter
)
{
if
(
string_data
.
size
(
)
+
tag_iter
-
>
size
(
)
>
std
:
:
numeric_limits
<
uint16_t
>
:
:
max
(
)
|
|
!
out
-
>
WriteU16
(
static_cast
<
uint16_t
>
(
tag_iter
-
>
size
(
)
)
)
|
|
!
out
-
>
WriteU16
(
static_cast
<
uint16_t
>
(
string_data
.
size
(
)
)
)
)
{
return
Error
(
"
Failed
to
write
langTagRecord
"
)
;
}
string_data
.
append
(
*
tag_iter
)
;
}
}
if
(
!
out
-
>
Write
(
string_data
.
data
(
)
string_data
.
size
(
)
)
)
{
return
Error
(
"
Faile
to
write
string
data
"
)
;
}
return
true
;
}
}
