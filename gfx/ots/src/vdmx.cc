#
include
"
vdmx
.
h
"
#
include
<
set
>
namespace
ots
{
#
define
TABLE_NAME
"
VDMX
"
bool
OpenTypeVDMX
:
:
Parse
(
const
uint8_t
*
data
size_t
length
)
{
Buffer
table
(
data
length
)
;
ots
:
:
Font
*
font
=
this
-
>
GetFont
(
)
;
if
(
!
table
.
ReadU16
(
&
this
-
>
version
)
|
|
!
table
.
ReadU16
(
&
this
-
>
num_recs
)
|
|
!
table
.
ReadU16
(
&
this
-
>
num_ratios
)
)
{
return
Drop
(
"
Failed
to
read
table
header
"
)
;
}
if
(
this
-
>
version
>
1
)
{
return
Drop
(
"
Unsupported
table
version
:
%
u
"
this
-
>
version
)
;
}
this
-
>
rat_ranges
.
reserve
(
this
-
>
num_ratios
)
;
for
(
unsigned
i
=
0
;
i
<
this
-
>
num_ratios
;
+
+
i
)
{
OpenTypeVDMXRatioRecord
rec
;
if
(
!
table
.
ReadU8
(
&
rec
.
charset
)
|
|
!
table
.
ReadU8
(
&
rec
.
x_ratio
)
|
|
!
table
.
ReadU8
(
&
rec
.
y_start_ratio
)
|
|
!
table
.
ReadU8
(
&
rec
.
y_end_ratio
)
)
{
return
Drop
(
"
Failed
to
read
RatioRange
record
%
d
"
i
)
;
}
if
(
rec
.
charset
>
1
)
{
return
Drop
(
"
Unsupported
character
set
:
%
u
"
rec
.
charset
)
;
}
if
(
rec
.
y_start_ratio
>
rec
.
y_end_ratio
)
{
return
Drop
(
"
Bad
y
ratio
"
)
;
}
if
(
(
i
<
this
-
>
num_ratios
-
1u
)
&
&
(
rec
.
x_ratio
=
=
0
)
&
&
(
rec
.
y_start_ratio
=
=
0
)
&
&
(
rec
.
y_end_ratio
=
=
0
)
)
{
return
Drop
(
"
Superfluous
terminator
found
"
)
;
}
this
-
>
rat_ranges
.
push_back
(
rec
)
;
}
this
-
>
offsets
.
reserve
(
this
-
>
num_ratios
)
;
const
size_t
current_offset
=
table
.
offset
(
)
;
std
:
:
set
<
uint16_t
>
unique_offsets
;
for
(
unsigned
i
=
0
;
i
<
this
-
>
num_ratios
;
+
+
i
)
{
uint16_t
offset
;
if
(
!
table
.
ReadU16
(
&
offset
)
)
{
return
Drop
(
"
Failed
to
read
ratio
offset
%
d
"
i
)
;
}
if
(
current_offset
+
offset
>
=
length
)
{
return
Drop
(
"
Bad
ratio
offset
%
d
for
ration
%
d
"
offset
i
)
;
}
this
-
>
offsets
.
push_back
(
offset
)
;
unique_offsets
.
insert
(
offset
)
;
}
if
(
unique_offsets
.
size
(
)
>
this
-
>
num_recs
)
{
OTS_WARNING
(
"
increasing
num_recs
(
%
u
is
too
small
for
%
u
unique
offsets
)
"
this
-
>
num_recs
unique_offsets
.
size
(
)
)
;
this
-
>
num_recs
=
unique_offsets
.
size
(
)
;
}
this
-
>
groups
.
reserve
(
this
-
>
num_recs
)
;
for
(
unsigned
i
=
0
;
i
<
this
-
>
num_recs
;
+
+
i
)
{
OpenTypeVDMXGroup
group
;
if
(
!
table
.
ReadU16
(
&
group
.
recs
)
|
|
!
table
.
ReadU8
(
&
group
.
startsz
)
|
|
!
table
.
ReadU8
(
&
group
.
endsz
)
)
{
return
Drop
(
"
Failed
to
read
record
header
%
d
"
i
)
;
}
group
.
entries
.
reserve
(
group
.
recs
)
;
for
(
unsigned
j
=
0
;
j
<
group
.
recs
;
+
+
j
)
{
OpenTypeVDMXVTable
vt
;
if
(
!
table
.
ReadU16
(
&
vt
.
y_pel_height
)
|
|
!
table
.
ReadS16
(
&
vt
.
y_max
)
|
|
!
table
.
ReadS16
(
&
vt
.
y_min
)
)
{
return
Drop
(
"
Failed
to
read
record
%
d
group
%
d
"
i
j
)
;
}
if
(
vt
.
y_max
<
vt
.
y_min
)
{
return
Drop
(
"
bad
y
min
/
max
"
)
;
}
if
(
(
j
!
=
0
)
&
&
(
group
.
entries
[
j
-
1
]
.
y_pel_height
>
=
vt
.
y_pel_height
)
)
{
return
Drop
(
"
The
table
is
not
sorted
"
)
;
}
group
.
entries
.
push_back
(
vt
)
;
}
this
-
>
groups
.
push_back
(
group
)
;
}
return
true
;
}
bool
OpenTypeVDMX
:
:
ShouldSerialize
(
)
{
return
Table
:
:
ShouldSerialize
(
)
&
&
GetFont
(
)
-
>
GetTable
(
OTS_TAG_GLYF
)
!
=
NULL
;
}
bool
OpenTypeVDMX
:
:
Serialize
(
OTSStream
*
out
)
{
if
(
!
out
-
>
WriteU16
(
this
-
>
version
)
|
|
!
out
-
>
WriteU16
(
this
-
>
num_recs
)
|
|
!
out
-
>
WriteU16
(
this
-
>
num_ratios
)
)
{
return
Error
(
"
Failed
to
write
table
header
"
)
;
}
for
(
unsigned
i
=
0
;
i
<
this
-
>
rat_ranges
.
size
(
)
;
+
+
i
)
{
const
OpenTypeVDMXRatioRecord
&
rec
=
this
-
>
rat_ranges
[
i
]
;
if
(
!
out
-
>
Write
(
&
rec
.
charset
1
)
|
|
!
out
-
>
Write
(
&
rec
.
x_ratio
1
)
|
|
!
out
-
>
Write
(
&
rec
.
y_start_ratio
1
)
|
|
!
out
-
>
Write
(
&
rec
.
y_end_ratio
1
)
)
{
return
Error
(
"
Failed
to
write
RatioRange
record
%
d
"
i
)
;
}
}
for
(
unsigned
i
=
0
;
i
<
this
-
>
offsets
.
size
(
)
;
+
+
i
)
{
if
(
!
out
-
>
WriteU16
(
this
-
>
offsets
[
i
]
)
)
{
return
Error
(
"
Failed
to
write
ratio
offset
%
d
"
i
)
;
}
}
for
(
unsigned
i
=
0
;
i
<
this
-
>
groups
.
size
(
)
;
+
+
i
)
{
const
OpenTypeVDMXGroup
&
group
=
this
-
>
groups
[
i
]
;
if
(
!
out
-
>
WriteU16
(
group
.
recs
)
|
|
!
out
-
>
Write
(
&
group
.
startsz
1
)
|
|
!
out
-
>
Write
(
&
group
.
endsz
1
)
)
{
return
Error
(
"
Failed
to
write
group
%
d
"
i
)
;
}
for
(
unsigned
j
=
0
;
j
<
group
.
entries
.
size
(
)
;
+
+
j
)
{
const
OpenTypeVDMXVTable
&
vt
=
group
.
entries
[
j
]
;
if
(
!
out
-
>
WriteU16
(
vt
.
y_pel_height
)
|
|
!
out
-
>
WriteS16
(
vt
.
y_max
)
|
|
!
out
-
>
WriteS16
(
vt
.
y_min
)
)
{
return
Error
(
"
Failed
to
write
group
%
d
entry
%
d
"
i
j
)
;
}
}
}
return
true
;
}
#
undef
TABLE_NAME
}
