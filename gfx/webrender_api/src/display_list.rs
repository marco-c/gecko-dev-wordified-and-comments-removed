use
bincode
;
use
euclid
:
:
SideOffsets2D
;
#
[
cfg
(
feature
=
"
deserialize
"
)
]
use
serde
:
:
de
:
:
Deserializer
;
#
[
cfg
(
feature
=
"
serialize
"
)
]
use
serde
:
:
ser
:
:
{
Serializer
SerializeSeq
}
;
use
serde
:
:
{
Deserialize
Serialize
}
;
use
std
:
:
io
:
:
{
Read
Write
}
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
{
io
mem
ptr
slice
}
;
use
time
:
:
precise_time_ns
;
use
{
AlphaType
BorderDetails
BorderDisplayItem
BorderRadius
BorderWidths
BoxShadowClipMode
}
;
use
{
BoxShadowDisplayItem
ClipAndScrollInfo
ClipChainId
ClipChainItem
ClipDisplayItem
ClipId
}
;
use
{
ColorF
ComplexClipRegion
DisplayItem
ExtendMode
ExternalScrollId
FilterOp
}
;
use
{
FontInstanceKey
GlyphInstance
GlyphOptions
GlyphRasterSpace
Gradient
}
;
use
{
GradientDisplayItem
GradientStop
IframeDisplayItem
ImageDisplayItem
ImageKey
ImageMask
}
;
use
{
ImageRendering
LayoutPoint
LayoutPrimitiveInfo
LayoutRect
LayoutSize
LayoutTransform
}
;
use
{
LayoutVector2D
LineDisplayItem
LineOrientation
LineStyle
MixBlendMode
PipelineId
}
;
use
{
PropertyBinding
PushReferenceFrameDisplayListItem
PushStackingContextDisplayItem
}
;
use
{
RadialGradient
RadialGradientDisplayItem
RectangleDisplayItem
ReferenceFrame
}
;
use
{
ScrollFrameDisplayItem
ScrollSensitivity
Shadow
SpecificDisplayItem
StackingContext
}
;
use
{
StickyFrameDisplayItem
StickyOffsetBounds
TextDisplayItem
TransformStyle
YuvColorSpace
}
;
use
{
YuvData
YuvImageDisplayItem
}
;
pub
const
MAX_TEXT_RUN_LENGTH
:
usize
=
2040
;
const
FIRST_CLIP_ID
:
usize
=
2
;
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Deserialize
Eq
Hash
PartialEq
Serialize
)
]
pub
struct
ItemRange
<
T
>
{
start
:
usize
length
:
usize
_boo
:
PhantomData
<
T
>
}
impl
<
T
>
Default
for
ItemRange
<
T
>
{
fn
default
(
)
-
>
Self
{
ItemRange
{
start
:
0
length
:
0
_boo
:
PhantomData
}
}
}
impl
<
T
>
ItemRange
<
T
>
{
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
length
<
=
mem
:
:
size_of
:
:
<
u64
>
(
)
}
}
#
[
derive
(
Clone
Default
)
]
pub
struct
BuiltDisplayList
{
data
:
Vec
<
u8
>
descriptor
:
BuiltDisplayListDescriptor
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Default
Deserialize
Serialize
)
]
pub
struct
BuiltDisplayListDescriptor
{
builder_start_time
:
u64
builder_finish_time
:
u64
send_start_time
:
u64
total_clip_ids
:
usize
}
pub
struct
BuiltDisplayListIter
<
'
a
>
{
list
:
&
'
a
BuiltDisplayList
data
:
&
'
a
[
u8
]
cur_item
:
DisplayItem
cur_stops
:
ItemRange
<
GradientStop
>
cur_glyphs
:
ItemRange
<
GlyphInstance
>
cur_filters
:
ItemRange
<
FilterOp
>
cur_clip_chain_items
:
ItemRange
<
ClipId
>
cur_complex_clip
:
(
ItemRange
<
ComplexClipRegion
>
usize
)
peeking
:
Peek
}
pub
struct
DisplayItemRef
<
'
a
:
'
b
'
b
>
{
iter
:
&
'
b
BuiltDisplayListIter
<
'
a
>
}
#
[
derive
(
PartialEq
)
]
enum
Peek
{
StartPeeking
IsPeeking
NotPeeking
}
#
[
derive
(
Clone
)
]
pub
struct
AuxIter
<
'
a
T
>
{
data
:
&
'
a
[
u8
]
size
:
usize
_boo
:
PhantomData
<
T
>
}
impl
BuiltDisplayListDescriptor
{
}
impl
BuiltDisplayList
{
pub
fn
from_data
(
data
:
Vec
<
u8
>
descriptor
:
BuiltDisplayListDescriptor
)
-
>
BuiltDisplayList
{
BuiltDisplayList
{
data
descriptor
}
}
pub
fn
into_data
(
mut
self
)
-
>
(
Vec
<
u8
>
BuiltDisplayListDescriptor
)
{
self
.
descriptor
.
send_start_time
=
precise_time_ns
(
)
;
(
self
.
data
self
.
descriptor
)
}
pub
fn
data
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
data
[
.
.
]
}
pub
fn
item_slice
(
&
self
)
-
>
&
[
u8
]
{
&
self
.
data
[
.
.
]
}
pub
fn
descriptor
(
&
self
)
-
>
&
BuiltDisplayListDescriptor
{
&
self
.
descriptor
}
pub
fn
times
(
&
self
)
-
>
(
u64
u64
u64
)
{
(
self
.
descriptor
.
builder_start_time
self
.
descriptor
.
builder_finish_time
self
.
descriptor
.
send_start_time
)
}
pub
fn
total_clip_ids
(
&
self
)
-
>
usize
{
self
.
descriptor
.
total_clip_ids
}
pub
fn
iter
(
&
self
)
-
>
BuiltDisplayListIter
{
BuiltDisplayListIter
:
:
new
(
self
)
}
pub
fn
get
<
'
de
T
:
Deserialize
<
'
de
>
>
(
&
self
range
:
ItemRange
<
T
>
)
-
>
AuxIter
<
T
>
{
AuxIter
:
:
new
(
&
self
.
data
[
range
.
start
.
.
range
.
start
+
range
.
length
]
)
}
}
fn
skip_slice
<
T
:
for
<
'
de
>
Deserialize
<
'
de
>
>
(
list
:
&
BuiltDisplayList
mut
data
:
&
mut
&
[
u8
]
)
-
>
(
ItemRange
<
T
>
usize
)
{
let
base
=
list
.
data
.
as_ptr
(
)
as
usize
;
let
byte_size
:
usize
=
bincode
:
:
deserialize_from
(
&
mut
data
)
.
expect
(
"
MEH
:
malicious
input
?
"
)
;
let
start
=
data
.
as_ptr
(
)
as
usize
;
let
item_count
:
usize
=
bincode
:
:
deserialize_from
(
&
mut
data
)
.
expect
(
"
MEH
:
malicious
input
?
"
)
;
let
item_count_size
=
data
.
as_ptr
(
)
as
usize
-
start
;
let
range
=
ItemRange
{
start
:
start
-
base
length
:
byte_size
+
item_count_size
_boo
:
PhantomData
}
;
*
data
=
&
data
[
byte_size
.
.
]
;
(
range
item_count
)
}
impl
<
'
a
>
BuiltDisplayListIter
<
'
a
>
{
pub
fn
new
(
list
:
&
'
a
BuiltDisplayList
)
-
>
Self
{
Self
:
:
new_with_list_and_data
(
list
list
.
item_slice
(
)
)
}
pub
fn
new_with_list_and_data
(
list
:
&
'
a
BuiltDisplayList
data
:
&
'
a
[
u8
]
)
-
>
Self
{
BuiltDisplayListIter
{
list
data
cur_item
:
DisplayItem
{
item
:
SpecificDisplayItem
:
:
PopStackingContext
clip_and_scroll
:
ClipAndScrollInfo
:
:
simple
(
ClipId
:
:
root_scroll_node
(
PipelineId
:
:
dummy
(
)
)
)
info
:
LayoutPrimitiveInfo
:
:
new
(
LayoutRect
:
:
zero
(
)
)
}
cur_stops
:
ItemRange
:
:
default
(
)
cur_glyphs
:
ItemRange
:
:
default
(
)
cur_filters
:
ItemRange
:
:
default
(
)
cur_clip_chain_items
:
ItemRange
:
:
default
(
)
cur_complex_clip
:
(
ItemRange
:
:
default
(
)
0
)
peeking
:
Peek
:
:
NotPeeking
}
}
pub
fn
display_list
(
&
self
)
-
>
&
'
a
BuiltDisplayList
{
self
.
list
}
pub
fn
next
<
'
b
>
(
&
'
b
mut
self
)
-
>
Option
<
DisplayItemRef
<
'
a
'
b
>
>
{
use
SpecificDisplayItem
:
:
*
;
match
self
.
peeking
{
Peek
:
:
IsPeeking
=
>
{
self
.
peeking
=
Peek
:
:
NotPeeking
;
return
Some
(
self
.
as_ref
(
)
)
;
}
Peek
:
:
StartPeeking
=
>
{
self
.
peeking
=
Peek
:
:
IsPeeking
;
}
Peek
:
:
NotPeeking
=
>
{
}
}
self
.
cur_stops
=
ItemRange
:
:
default
(
)
;
self
.
cur_complex_clip
=
(
ItemRange
:
:
default
(
)
0
)
;
self
.
cur_clip_chain_items
=
ItemRange
:
:
default
(
)
;
loop
{
self
.
next_raw
(
)
?
;
if
let
SetGradientStops
=
self
.
cur_item
.
item
{
continue
;
}
break
;
}
Some
(
self
.
as_ref
(
)
)
}
pub
fn
next_raw
<
'
b
>
(
&
'
b
mut
self
)
-
>
Option
<
DisplayItemRef
<
'
a
'
b
>
>
{
use
SpecificDisplayItem
:
:
*
;
if
self
.
data
.
is_empty
(
)
{
return
None
;
}
{
let
reader
=
bincode
:
:
IoReader
:
:
new
(
UnsafeReader
:
:
new
(
&
mut
self
.
data
)
)
;
bincode
:
:
deserialize_in_place
(
reader
&
mut
self
.
cur_item
)
.
expect
(
"
MEH
:
malicious
process
?
"
)
;
}
match
self
.
cur_item
.
item
{
SetGradientStops
=
>
{
self
.
cur_stops
=
skip_slice
:
:
<
GradientStop
>
(
self
.
list
&
mut
self
.
data
)
.
0
;
}
ClipChain
(
_
)
=
>
{
self
.
cur_clip_chain_items
=
skip_slice
:
:
<
ClipId
>
(
self
.
list
&
mut
self
.
data
)
.
0
;
}
Clip
(
_
)
|
ScrollFrame
(
_
)
=
>
{
self
.
cur_complex_clip
=
self
.
skip_slice
:
:
<
ComplexClipRegion
>
(
)
}
Text
(
_
)
=
>
self
.
cur_glyphs
=
self
.
skip_slice
:
:
<
GlyphInstance
>
(
)
.
0
PushStackingContext
(
_
)
=
>
self
.
cur_filters
=
self
.
skip_slice
:
:
<
FilterOp
>
(
)
.
0
_
=
>
{
}
}
Some
(
self
.
as_ref
(
)
)
}
fn
skip_slice
<
T
:
for
<
'
de
>
Deserialize
<
'
de
>
>
(
&
mut
self
)
-
>
(
ItemRange
<
T
>
usize
)
{
skip_slice
:
:
<
T
>
(
self
.
list
&
mut
self
.
data
)
}
pub
fn
as_ref
<
'
b
>
(
&
'
b
self
)
-
>
DisplayItemRef
<
'
a
'
b
>
{
DisplayItemRef
{
iter
:
self
}
}
pub
fn
starting_stacking_context
(
&
mut
self
)
-
>
Option
<
(
StackingContext
LayoutRect
ItemRange
<
FilterOp
>
)
>
{
self
.
next
(
)
.
and_then
(
|
item
|
match
*
item
.
item
(
)
{
SpecificDisplayItem
:
:
PushStackingContext
(
ref
specific_item
)
=
>
Some
(
(
specific_item
.
stacking_context
item
.
rect
(
)
item
.
filters
(
)
)
)
_
=
>
None
}
)
}
pub
fn
skip_current_stacking_context
(
&
mut
self
)
{
let
mut
depth
=
0
;
while
let
Some
(
item
)
=
self
.
next
(
)
{
match
*
item
.
item
(
)
{
SpecificDisplayItem
:
:
PushStackingContext
(
.
.
)
=
>
depth
+
=
1
SpecificDisplayItem
:
:
PopStackingContext
if
depth
=
=
0
=
>
return
SpecificDisplayItem
:
:
PopStackingContext
=
>
depth
-
=
1
_
=
>
{
}
}
debug_assert
!
(
depth
>
=
0
)
;
}
}
pub
fn
current_stacking_context_empty
(
&
mut
self
)
-
>
bool
{
match
self
.
peek
(
)
{
Some
(
item
)
=
>
*
item
.
item
(
)
=
=
SpecificDisplayItem
:
:
PopStackingContext
None
=
>
true
}
}
pub
fn
peek
<
'
b
>
(
&
'
b
mut
self
)
-
>
Option
<
DisplayItemRef
<
'
a
'
b
>
>
{
if
self
.
peeking
=
=
Peek
:
:
NotPeeking
{
self
.
peeking
=
Peek
:
:
StartPeeking
;
self
.
next
(
)
}
else
{
Some
(
self
.
as_ref
(
)
)
}
}
}
impl
<
'
a
'
b
>
DisplayItemRef
<
'
a
'
b
>
{
pub
fn
display_item
(
&
self
)
-
>
&
DisplayItem
{
&
self
.
iter
.
cur_item
}
pub
fn
rect
(
&
self
)
-
>
LayoutRect
{
self
.
iter
.
cur_item
.
info
.
rect
}
pub
fn
get_layout_primitive_info
(
&
self
offset
:
&
LayoutVector2D
)
-
>
LayoutPrimitiveInfo
{
let
info
=
self
.
iter
.
cur_item
.
info
;
LayoutPrimitiveInfo
{
rect
:
info
.
rect
.
translate
(
offset
)
clip_rect
:
info
.
clip_rect
.
translate
(
offset
)
is_backface_visible
:
info
.
is_backface_visible
tag
:
info
.
tag
}
}
pub
fn
clip_rect
(
&
self
)
-
>
&
LayoutRect
{
&
self
.
iter
.
cur_item
.
info
.
clip_rect
}
pub
fn
clip_and_scroll
(
&
self
)
-
>
ClipAndScrollInfo
{
self
.
iter
.
cur_item
.
clip_and_scroll
}
pub
fn
item
(
&
self
)
-
>
&
SpecificDisplayItem
{
&
self
.
iter
.
cur_item
.
item
}
pub
fn
complex_clip
(
&
self
)
-
>
(
ItemRange
<
ComplexClipRegion
>
usize
)
{
self
.
iter
.
cur_complex_clip
}
pub
fn
gradient_stops
(
&
self
)
-
>
ItemRange
<
GradientStop
>
{
self
.
iter
.
cur_stops
}
pub
fn
glyphs
(
&
self
)
-
>
ItemRange
<
GlyphInstance
>
{
self
.
iter
.
cur_glyphs
}
pub
fn
filters
(
&
self
)
-
>
ItemRange
<
FilterOp
>
{
self
.
iter
.
cur_filters
}
pub
fn
clip_chain_items
(
&
self
)
-
>
ItemRange
<
ClipId
>
{
self
.
iter
.
cur_clip_chain_items
}
pub
fn
display_list
(
&
self
)
-
>
&
BuiltDisplayList
{
self
.
iter
.
display_list
(
)
}
pub
fn
is_backface_visible
(
&
self
)
-
>
bool
{
self
.
iter
.
cur_item
.
info
.
is_backface_visible
}
pub
fn
sub_iter
(
&
self
)
-
>
BuiltDisplayListIter
<
'
a
>
{
BuiltDisplayListIter
:
:
new_with_list_and_data
(
self
.
iter
.
list
self
.
iter
.
data
)
}
}
impl
<
'
de
'
a
T
:
Deserialize
<
'
de
>
>
AuxIter
<
'
a
T
>
{
pub
fn
new
(
mut
data
:
&
'
a
[
u8
]
)
-
>
Self
{
let
size
:
usize
=
if
data
.
is_empty
(
)
{
0
}
else
{
bincode
:
:
deserialize_from
(
&
mut
UnsafeReader
:
:
new
(
&
mut
data
)
)
.
expect
(
"
MEH
:
malicious
input
?
"
)
}
;
AuxIter
{
data
size
_boo
:
PhantomData
}
}
}
impl
<
'
a
T
:
for
<
'
de
>
Deserialize
<
'
de
>
>
Iterator
for
AuxIter
<
'
a
T
>
{
type
Item
=
T
;
fn
next
(
&
mut
self
)
-
>
Option
<
T
>
{
if
self
.
size
=
=
0
{
None
}
else
{
self
.
size
-
=
1
;
Some
(
bincode
:
:
deserialize_from
(
&
mut
UnsafeReader
:
:
new
(
&
mut
self
.
data
)
)
.
expect
(
"
MEH
:
malicious
input
?
"
)
)
}
}
fn
size_hint
(
&
self
)
-
>
(
usize
Option
<
usize
>
)
{
(
self
.
size
Some
(
self
.
size
)
)
}
}
impl
<
'
a
T
:
for
<
'
de
>
Deserialize
<
'
de
>
>
:
:
std
:
:
iter
:
:
ExactSizeIterator
for
AuxIter
<
'
a
T
>
{
}
#
[
cfg
(
feature
=
"
serialize
"
)
]
impl
Serialize
for
BuiltDisplayList
{
fn
serialize
<
S
:
Serializer
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
{
use
display_item
:
:
CompletelySpecificDisplayItem
:
:
*
;
use
display_item
:
:
GenericDisplayItem
;
let
mut
seq
=
serializer
.
serialize_seq
(
None
)
?
;
let
mut
traversal
=
self
.
iter
(
)
;
while
let
Some
(
item
)
=
traversal
.
next_raw
(
)
{
let
display_item
=
item
.
display_item
(
)
;
let
serial_di
=
GenericDisplayItem
{
item
:
match
display_item
.
item
{
SpecificDisplayItem
:
:
Clip
(
v
)
=
>
Clip
(
v
item
.
iter
.
list
.
get
(
item
.
iter
.
cur_complex_clip
.
0
)
.
collect
(
)
)
SpecificDisplayItem
:
:
ClipChain
(
v
)
=
>
ClipChain
(
v
item
.
iter
.
list
.
get
(
item
.
iter
.
cur_clip_chain_items
)
.
collect
(
)
)
SpecificDisplayItem
:
:
ScrollFrame
(
v
)
=
>
ScrollFrame
(
v
item
.
iter
.
list
.
get
(
item
.
iter
.
cur_complex_clip
.
0
)
.
collect
(
)
)
SpecificDisplayItem
:
:
StickyFrame
(
v
)
=
>
StickyFrame
(
v
)
SpecificDisplayItem
:
:
Rectangle
(
v
)
=
>
Rectangle
(
v
)
SpecificDisplayItem
:
:
ClearRectangle
=
>
ClearRectangle
SpecificDisplayItem
:
:
Line
(
v
)
=
>
Line
(
v
)
SpecificDisplayItem
:
:
Text
(
v
)
=
>
Text
(
v
item
.
iter
.
list
.
get
(
item
.
iter
.
cur_glyphs
)
.
collect
(
)
)
SpecificDisplayItem
:
:
Image
(
v
)
=
>
Image
(
v
)
SpecificDisplayItem
:
:
YuvImage
(
v
)
=
>
YuvImage
(
v
)
SpecificDisplayItem
:
:
Border
(
v
)
=
>
Border
(
v
)
SpecificDisplayItem
:
:
BoxShadow
(
v
)
=
>
BoxShadow
(
v
)
SpecificDisplayItem
:
:
Gradient
(
v
)
=
>
Gradient
(
v
)
SpecificDisplayItem
:
:
RadialGradient
(
v
)
=
>
RadialGradient
(
v
)
SpecificDisplayItem
:
:
Iframe
(
v
)
=
>
Iframe
(
v
)
SpecificDisplayItem
:
:
PushStackingContext
(
v
)
=
>
PushStackingContext
(
v
item
.
iter
.
list
.
get
(
item
.
iter
.
cur_filters
)
.
collect
(
)
)
SpecificDisplayItem
:
:
PopStackingContext
=
>
PopStackingContext
SpecificDisplayItem
:
:
PushReferenceFrame
(
v
)
=
>
PushReferenceFrame
(
v
)
SpecificDisplayItem
:
:
PopReferenceFrame
=
>
PopReferenceFrame
SpecificDisplayItem
:
:
SetGradientStops
=
>
SetGradientStops
(
item
.
iter
.
list
.
get
(
item
.
iter
.
cur_stops
)
.
collect
(
)
)
SpecificDisplayItem
:
:
PushShadow
(
v
)
=
>
PushShadow
(
v
)
SpecificDisplayItem
:
:
PopAllShadows
=
>
PopAllShadows
}
clip_and_scroll
:
display_item
.
clip_and_scroll
info
:
display_item
.
info
}
;
seq
.
serialize_element
(
&
serial_di
)
?
}
seq
.
end
(
)
}
}
#
[
cfg
(
feature
=
"
deserialize
"
)
]
impl
<
'
de
>
Deserialize
<
'
de
>
for
BuiltDisplayList
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
Deserializer
<
'
de
>
{
use
display_item
:
:
CompletelySpecificDisplayItem
:
:
*
;
use
display_item
:
:
{
CompletelySpecificDisplayItem
GenericDisplayItem
}
;
let
list
=
Vec
:
:
<
GenericDisplayItem
<
CompletelySpecificDisplayItem
>
>
:
:
deserialize
(
deserializer
)
?
;
let
mut
data
=
Vec
:
:
new
(
)
;
let
mut
temp
=
Vec
:
:
new
(
)
;
let
mut
total_clip_ids
=
FIRST_CLIP_ID
;
for
complete
in
list
{
let
item
=
DisplayItem
{
item
:
match
complete
.
item
{
Clip
(
specific_item
complex_clips
)
=
>
{
total_clip_ids
+
=
1
;
DisplayListBuilder
:
:
push_iter_impl
(
&
mut
temp
complex_clips
)
;
SpecificDisplayItem
:
:
Clip
(
specific_item
)
}
ClipChain
(
specific_item
clip_chain_ids
)
=
>
{
DisplayListBuilder
:
:
push_iter_impl
(
&
mut
temp
clip_chain_ids
)
;
SpecificDisplayItem
:
:
ClipChain
(
specific_item
)
}
ScrollFrame
(
specific_item
complex_clips
)
=
>
{
total_clip_ids
+
=
2
;
DisplayListBuilder
:
:
push_iter_impl
(
&
mut
temp
complex_clips
)
;
SpecificDisplayItem
:
:
ScrollFrame
(
specific_item
)
}
StickyFrame
(
specific_item
)
=
>
{
total_clip_ids
+
=
1
;
SpecificDisplayItem
:
:
StickyFrame
(
specific_item
)
}
Rectangle
(
specific_item
)
=
>
SpecificDisplayItem
:
:
Rectangle
(
specific_item
)
ClearRectangle
=
>
SpecificDisplayItem
:
:
ClearRectangle
Line
(
specific_item
)
=
>
SpecificDisplayItem
:
:
Line
(
specific_item
)
Text
(
specific_item
glyphs
)
=
>
{
DisplayListBuilder
:
:
push_iter_impl
(
&
mut
temp
glyphs
)
;
SpecificDisplayItem
:
:
Text
(
specific_item
)
}
Image
(
specific_item
)
=
>
SpecificDisplayItem
:
:
Image
(
specific_item
)
YuvImage
(
specific_item
)
=
>
SpecificDisplayItem
:
:
YuvImage
(
specific_item
)
Border
(
specific_item
)
=
>
SpecificDisplayItem
:
:
Border
(
specific_item
)
BoxShadow
(
specific_item
)
=
>
SpecificDisplayItem
:
:
BoxShadow
(
specific_item
)
Gradient
(
specific_item
)
=
>
SpecificDisplayItem
:
:
Gradient
(
specific_item
)
RadialGradient
(
specific_item
)
=
>
SpecificDisplayItem
:
:
RadialGradient
(
specific_item
)
Iframe
(
specific_item
)
=
>
{
total_clip_ids
+
=
1
;
SpecificDisplayItem
:
:
Iframe
(
specific_item
)
}
PushStackingContext
(
specific_item
filters
)
=
>
{
DisplayListBuilder
:
:
push_iter_impl
(
&
mut
temp
filters
)
;
SpecificDisplayItem
:
:
PushStackingContext
(
specific_item
)
}
PopStackingContext
=
>
SpecificDisplayItem
:
:
PopStackingContext
PushReferenceFrame
(
specific_item
)
=
>
{
total_clip_ids
+
=
1
;
SpecificDisplayItem
:
:
PushReferenceFrame
(
specific_item
)
}
PopReferenceFrame
=
>
SpecificDisplayItem
:
:
PopReferenceFrame
SetGradientStops
(
stops
)
=
>
{
DisplayListBuilder
:
:
push_iter_impl
(
&
mut
temp
stops
)
;
SpecificDisplayItem
:
:
SetGradientStops
}
PushShadow
(
specific_item
)
=
>
SpecificDisplayItem
:
:
PushShadow
(
specific_item
)
PopAllShadows
=
>
SpecificDisplayItem
:
:
PopAllShadows
}
clip_and_scroll
:
complete
.
clip_and_scroll
info
:
complete
.
info
}
;
serialize_fast
(
&
mut
data
&
item
)
;
data
.
extend
(
temp
.
drain
(
.
.
)
)
;
}
Ok
(
BuiltDisplayList
{
data
descriptor
:
BuiltDisplayListDescriptor
{
builder_start_time
:
0
builder_finish_time
:
1
send_start_time
:
0
total_clip_ids
}
}
)
}
}
struct
UnsafeVecWriter
(
*
mut
u8
)
;
impl
Write
for
UnsafeVecWriter
{
#
[
inline
(
always
)
]
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
unsafe
{
ptr
:
:
copy_nonoverlapping
(
buf
.
as_ptr
(
)
self
.
0
buf
.
len
(
)
)
;
self
.
0
=
self
.
0
.
offset
(
buf
.
len
(
)
as
isize
)
;
}
Ok
(
buf
.
len
(
)
)
}
#
[
inline
(
always
)
]
fn
write_all
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
(
)
>
{
unsafe
{
ptr
:
:
copy_nonoverlapping
(
buf
.
as_ptr
(
)
self
.
0
buf
.
len
(
)
)
;
self
.
0
=
self
.
0
.
offset
(
buf
.
len
(
)
as
isize
)
;
}
Ok
(
(
)
)
}
#
[
inline
(
always
)
]
fn
flush
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
Ok
(
(
)
)
}
}
struct
SizeCounter
(
usize
)
;
impl
<
'
a
>
Write
for
SizeCounter
{
#
[
inline
(
always
)
]
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
0
+
=
buf
.
len
(
)
;
Ok
(
buf
.
len
(
)
)
}
#
[
inline
(
always
)
]
fn
write_all
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
0
+
=
buf
.
len
(
)
;
Ok
(
(
)
)
}
#
[
inline
(
always
)
]
fn
flush
(
&
mut
self
)
-
>
io
:
:
Result
<
(
)
>
{
Ok
(
(
)
)
}
}
fn
serialize_fast
<
T
:
Serialize
>
(
vec
:
&
mut
Vec
<
u8
>
e
:
&
T
)
{
let
mut
size
=
SizeCounter
(
0
)
;
bincode
:
:
serialize_into
(
&
mut
size
e
)
.
unwrap
(
)
;
vec
.
reserve
(
size
.
0
)
;
let
old_len
=
vec
.
len
(
)
;
let
ptr
=
unsafe
{
vec
.
as_mut_ptr
(
)
.
offset
(
old_len
as
isize
)
}
;
let
mut
w
=
UnsafeVecWriter
(
ptr
)
;
bincode
:
:
serialize_into
(
&
mut
w
e
)
.
unwrap
(
)
;
unsafe
{
vec
.
set_len
(
old_len
+
size
.
0
)
;
}
debug_assert_eq
!
(
(
(
w
.
0
as
usize
)
-
(
vec
.
as_ptr
(
)
as
usize
)
)
vec
.
len
(
)
)
;
}
fn
serialize_iter_fast
<
I
>
(
vec
:
&
mut
Vec
<
u8
>
iter
:
I
)
-
>
usize
where
I
:
ExactSizeIterator
+
Clone
I
:
:
Item
:
Serialize
{
let
mut
size
=
SizeCounter
(
0
)
;
let
mut
count1
=
0
;
for
e
in
iter
.
clone
(
)
{
bincode
:
:
serialize_into
(
&
mut
size
&
e
)
.
unwrap
(
)
;
count1
+
=
1
;
}
vec
.
reserve
(
size
.
0
)
;
let
old_len
=
vec
.
len
(
)
;
let
ptr
=
unsafe
{
vec
.
as_mut_ptr
(
)
.
offset
(
old_len
as
isize
)
}
;
let
mut
w
=
UnsafeVecWriter
(
ptr
)
;
let
mut
count2
=
0
;
for
e
in
iter
{
bincode
:
:
serialize_into
(
&
mut
w
&
e
)
.
unwrap
(
)
;
count2
+
=
1
;
}
unsafe
{
vec
.
set_len
(
old_len
+
size
.
0
)
;
}
debug_assert_eq
!
(
(
(
w
.
0
as
usize
)
-
(
vec
.
as_ptr
(
)
as
usize
)
)
vec
.
len
(
)
)
;
debug_assert_eq
!
(
count1
count2
)
;
count1
}
struct
UnsafeReader
<
'
a
:
'
b
'
b
>
{
start
:
*
const
u8
end
:
*
const
u8
slice
:
&
'
b
mut
&
'
a
[
u8
]
}
impl
<
'
a
'
b
>
UnsafeReader
<
'
a
'
b
>
{
#
[
inline
(
always
)
]
fn
new
(
buf
:
&
'
b
mut
&
'
a
[
u8
]
)
-
>
UnsafeReader
<
'
a
'
b
>
{
unsafe
{
let
end
=
buf
.
as_ptr
(
)
.
offset
(
buf
.
len
(
)
as
isize
)
;
let
start
=
buf
.
as_ptr
(
)
;
UnsafeReader
{
start
end
slice
:
buf
}
}
}
#
[
inline
(
always
)
]
fn
read_internal
(
&
mut
self
buf
:
&
mut
[
u8
]
)
{
unsafe
{
assert
!
(
self
.
start
.
offset
(
buf
.
len
(
)
as
isize
)
<
=
self
.
end
"
UnsafeReader
:
read
past
end
of
target
"
)
;
ptr
:
:
copy_nonoverlapping
(
self
.
start
buf
.
as_mut_ptr
(
)
buf
.
len
(
)
)
;
self
.
start
=
self
.
start
.
offset
(
buf
.
len
(
)
as
isize
)
;
}
}
}
impl
<
'
a
'
b
>
Drop
for
UnsafeReader
<
'
a
'
b
>
{
#
[
inline
(
always
)
]
fn
drop
(
&
mut
self
)
{
unsafe
{
*
self
.
slice
=
slice
:
:
from_raw_parts
(
self
.
start
(
self
.
end
as
usize
)
-
(
self
.
start
as
usize
)
)
;
}
}
}
impl
<
'
a
'
b
>
Read
for
UnsafeReader
<
'
a
'
b
>
{
#
[
inline
(
always
)
]
fn
read
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
usize
>
{
self
.
read_internal
(
buf
)
;
Ok
(
buf
.
len
(
)
)
}
#
[
inline
(
always
)
]
fn
read_exact
(
&
mut
self
buf
:
&
mut
[
u8
]
)
-
>
io
:
:
Result
<
(
)
>
{
self
.
read_internal
(
buf
)
;
Ok
(
(
)
)
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
SaveState
{
dl_len
:
usize
clip_stack_len
:
usize
next_clip_id
:
usize
next_clip_chain_id
:
u64
}
#
[
derive
(
Clone
)
]
pub
struct
DisplayListBuilder
{
pub
data
:
Vec
<
u8
>
pub
pipeline_id
:
PipelineId
clip_stack
:
Vec
<
ClipAndScrollInfo
>
next_clip_id
:
usize
next_clip_chain_id
:
u64
builder_start_time
:
u64
content_size
:
LayoutSize
save_state
:
Option
<
SaveState
>
}
impl
DisplayListBuilder
{
pub
fn
new
(
pipeline_id
:
PipelineId
content_size
:
LayoutSize
)
-
>
Self
{
Self
:
:
with_capacity
(
pipeline_id
content_size
0
)
}
pub
fn
with_capacity
(
pipeline_id
:
PipelineId
content_size
:
LayoutSize
capacity
:
usize
)
-
>
Self
{
let
start_time
=
precise_time_ns
(
)
;
DisplayListBuilder
{
data
:
Vec
:
:
with_capacity
(
capacity
)
pipeline_id
clip_stack
:
vec
!
[
ClipAndScrollInfo
:
:
simple
(
ClipId
:
:
root_scroll_node
(
pipeline_id
)
)
]
next_clip_id
:
FIRST_CLIP_ID
next_clip_chain_id
:
0
builder_start_time
:
start_time
content_size
save_state
:
None
}
}
pub
fn
content_size
(
&
self
)
-
>
LayoutSize
{
self
.
content_size
}
pub
fn
save
(
&
mut
self
)
{
assert
!
(
self
.
save_state
.
is_none
(
)
"
DisplayListBuilder
doesn
'
t
support
nested
saves
"
)
;
self
.
save_state
=
Some
(
SaveState
{
clip_stack_len
:
self
.
clip_stack
.
len
(
)
dl_len
:
self
.
data
.
len
(
)
next_clip_id
:
self
.
next_clip_id
next_clip_chain_id
:
self
.
next_clip_chain_id
}
)
;
}
pub
fn
restore
(
&
mut
self
)
{
let
state
=
self
.
save_state
.
take
(
)
.
expect
(
"
No
save
to
restore
DisplayListBuilder
from
"
)
;
self
.
clip_stack
.
truncate
(
state
.
clip_stack_len
)
;
self
.
data
.
truncate
(
state
.
dl_len
)
;
self
.
next_clip_id
=
state
.
next_clip_id
;
self
.
next_clip_chain_id
=
state
.
next_clip_chain_id
;
}
pub
fn
clear_save
(
&
mut
self
)
{
self
.
save_state
.
take
(
)
.
expect
(
"
No
save
to
clear
in
DisplayListBuilder
"
)
;
}
pub
fn
print_display_list
(
&
mut
self
)
{
let
mut
temp
=
BuiltDisplayList
:
:
default
(
)
;
mem
:
:
swap
(
&
mut
temp
.
data
&
mut
self
.
data
)
;
{
let
mut
iter
=
BuiltDisplayListIter
:
:
new
(
&
temp
)
;
while
let
Some
(
item
)
=
iter
.
next_raw
(
)
{
println
!
(
"
{
:
?
}
"
item
.
display_item
(
)
)
;
}
}
self
.
data
=
temp
.
data
;
}
fn
push_item
(
&
mut
self
item
:
SpecificDisplayItem
info
:
&
LayoutPrimitiveInfo
)
{
serialize_fast
(
&
mut
self
.
data
&
DisplayItem
{
item
clip_and_scroll
:
*
self
.
clip_stack
.
last
(
)
.
unwrap
(
)
info
:
*
info
}
)
}
fn
push_item_with_clip_scroll_info
(
&
mut
self
item
:
SpecificDisplayItem
info
:
&
LayoutPrimitiveInfo
scrollinfo
:
ClipAndScrollInfo
)
{
serialize_fast
(
&
mut
self
.
data
&
DisplayItem
{
item
clip_and_scroll
:
scrollinfo
info
:
*
info
}
)
}
fn
push_new_empty_item
(
&
mut
self
item
:
SpecificDisplayItem
)
{
let
info
=
LayoutPrimitiveInfo
:
:
new
(
LayoutRect
:
:
zero
(
)
)
;
serialize_fast
(
&
mut
self
.
data
&
DisplayItem
{
item
clip_and_scroll
:
*
self
.
clip_stack
.
last
(
)
.
unwrap
(
)
info
}
)
}
fn
push_iter_impl
<
I
>
(
data
:
&
mut
Vec
<
u8
>
iter_source
:
I
)
where
I
:
IntoIterator
I
:
:
IntoIter
:
ExactSizeIterator
+
Clone
I
:
:
Item
:
Serialize
{
let
iter
=
iter_source
.
into_iter
(
)
;
let
len
=
iter
.
len
(
)
;
let
byte_size_offset
=
data
.
len
(
)
;
serialize_fast
(
data
&
0usize
)
;
serialize_fast
(
data
&
len
)
;
let
payload_offset
=
data
.
len
(
)
;
let
count
=
serialize_iter_fast
(
data
iter
)
;
let
final_offset
=
data
.
len
(
)
;
let
byte_size
=
final_offset
-
payload_offset
;
bincode
:
:
serialize_into
(
&
mut
&
mut
data
[
byte_size_offset
.
.
]
&
byte_size
)
.
unwrap
(
)
;
debug_assert_eq
!
(
len
count
)
;
}
fn
push_iter
<
I
>
(
&
mut
self
iter
:
I
)
where
I
:
IntoIterator
I
:
:
IntoIter
:
ExactSizeIterator
+
Clone
I
:
:
Item
:
Serialize
{
Self
:
:
push_iter_impl
(
&
mut
self
.
data
iter
)
;
}
pub
fn
push_rect
(
&
mut
self
info
:
&
LayoutPrimitiveInfo
color
:
ColorF
)
{
let
item
=
SpecificDisplayItem
:
:
Rectangle
(
RectangleDisplayItem
{
color
}
)
;
self
.
push_item
(
item
info
)
;
}
pub
fn
push_clear_rect
(
&
mut
self
info
:
&
LayoutPrimitiveInfo
)
{
self
.
push_item
(
SpecificDisplayItem
:
:
ClearRectangle
info
)
;
}
pub
fn
push_line
(
&
mut
self
info
:
&
LayoutPrimitiveInfo
wavy_line_thickness
:
f32
orientation
:
LineOrientation
color
:
&
ColorF
style
:
LineStyle
)
{
let
item
=
SpecificDisplayItem
:
:
Line
(
LineDisplayItem
{
wavy_line_thickness
orientation
color
:
*
color
style
}
)
;
self
.
push_item
(
item
info
)
;
}
pub
fn
push_image
(
&
mut
self
info
:
&
LayoutPrimitiveInfo
stretch_size
:
LayoutSize
tile_spacing
:
LayoutSize
image_rendering
:
ImageRendering
alpha_type
:
AlphaType
key
:
ImageKey
)
{
let
item
=
SpecificDisplayItem
:
:
Image
(
ImageDisplayItem
{
image_key
:
key
stretch_size
tile_spacing
image_rendering
alpha_type
}
)
;
self
.
push_item
(
item
info
)
;
}
pub
fn
push_yuv_image
(
&
mut
self
info
:
&
LayoutPrimitiveInfo
yuv_data
:
YuvData
color_space
:
YuvColorSpace
image_rendering
:
ImageRendering
)
{
let
item
=
SpecificDisplayItem
:
:
YuvImage
(
YuvImageDisplayItem
{
yuv_data
color_space
image_rendering
}
)
;
self
.
push_item
(
item
info
)
;
}
pub
fn
push_text
(
&
mut
self
info
:
&
LayoutPrimitiveInfo
glyphs
:
&
[
GlyphInstance
]
font_key
:
FontInstanceKey
color
:
ColorF
glyph_options
:
Option
<
GlyphOptions
>
)
{
let
item
=
SpecificDisplayItem
:
:
Text
(
TextDisplayItem
{
color
font_key
glyph_options
}
)
;
for
split_glyphs
in
glyphs
.
chunks
(
MAX_TEXT_RUN_LENGTH
)
{
self
.
push_item
(
item
info
)
;
self
.
push_iter
(
split_glyphs
)
;
}
}
fn
normalize_stops
(
stops
:
&
mut
Vec
<
GradientStop
>
extend_mode
:
ExtendMode
)
-
>
(
f32
f32
)
{
assert
!
(
stops
.
len
(
)
>
=
2
)
;
let
first
=
*
stops
.
first
(
)
.
unwrap
(
)
;
let
last
=
*
stops
.
last
(
)
.
unwrap
(
)
;
assert
!
(
first
.
offset
<
=
last
.
offset
)
;
let
stops_delta
=
last
.
offset
-
first
.
offset
;
if
stops_delta
>
0
.
000001
{
for
stop
in
stops
{
stop
.
offset
=
(
stop
.
offset
-
first
.
offset
)
/
stops_delta
;
}
(
first
.
offset
last
.
offset
)
}
else
{
stops
.
clear
(
)
;
match
extend_mode
{
ExtendMode
:
:
Clamp
=
>
{
stops
.
push
(
GradientStop
{
color
:
first
.
color
offset
:
0
.
0
}
)
;
stops
.
push
(
GradientStop
{
color
:
first
.
color
offset
:
0
.
5
}
)
;
stops
.
push
(
GradientStop
{
color
:
last
.
color
offset
:
0
.
5
}
)
;
stops
.
push
(
GradientStop
{
color
:
last
.
color
offset
:
1
.
0
}
)
;
let
offset
=
last
.
offset
;
(
offset
-
0
.
5
offset
+
0
.
5
)
}
ExtendMode
:
:
Repeat
=
>
{
stops
.
push
(
GradientStop
{
color
:
last
.
color
offset
:
0
.
0
}
)
;
stops
.
push
(
GradientStop
{
color
:
last
.
color
offset
:
1
.
0
}
)
;
(
0
.
0
1
.
0
)
}
}
}
}
pub
fn
create_gradient
(
&
mut
self
start_point
:
LayoutPoint
end_point
:
LayoutPoint
mut
stops
:
Vec
<
GradientStop
>
extend_mode
:
ExtendMode
)
-
>
Gradient
{
let
(
start_offset
end_offset
)
=
DisplayListBuilder
:
:
normalize_stops
(
&
mut
stops
extend_mode
)
;
let
start_to_end
=
end_point
-
start_point
;
self
.
push_stops
(
&
stops
)
;
Gradient
{
start_point
:
start_point
+
start_to_end
*
start_offset
end_point
:
start_point
+
start_to_end
*
end_offset
extend_mode
}
}
pub
fn
create_radial_gradient
(
&
mut
self
center
:
LayoutPoint
radius
:
LayoutSize
mut
stops
:
Vec
<
GradientStop
>
extend_mode
:
ExtendMode
)
-
>
RadialGradient
{
if
radius
.
width
<
=
0
.
0
|
|
radius
.
height
<
=
0
.
0
{
let
last_color
=
stops
.
last
(
)
.
unwrap
(
)
.
color
;
let
stops
=
[
GradientStop
{
offset
:
0
.
0
color
:
last_color
}
GradientStop
{
offset
:
1
.
0
color
:
last_color
}
]
;
self
.
push_stops
(
&
stops
)
;
return
RadialGradient
{
center
radius
:
LayoutSize
:
:
new
(
1
.
0
1
.
0
)
start_offset
:
0
.
0
end_offset
:
1
.
0
extend_mode
}
;
}
let
(
start_offset
end_offset
)
=
DisplayListBuilder
:
:
normalize_stops
(
&
mut
stops
extend_mode
)
;
self
.
push_stops
(
&
stops
)
;
RadialGradient
{
center
radius
start_offset
end_offset
extend_mode
}
}
pub
fn
push_border
(
&
mut
self
info
:
&
LayoutPrimitiveInfo
widths
:
BorderWidths
details
:
BorderDetails
)
{
let
item
=
SpecificDisplayItem
:
:
Border
(
BorderDisplayItem
{
details
widths
}
)
;
self
.
push_item
(
item
info
)
;
}
pub
fn
push_box_shadow
(
&
mut
self
info
:
&
LayoutPrimitiveInfo
box_bounds
:
LayoutRect
offset
:
LayoutVector2D
color
:
ColorF
blur_radius
:
f32
spread_radius
:
f32
border_radius
:
BorderRadius
clip_mode
:
BoxShadowClipMode
)
{
let
item
=
SpecificDisplayItem
:
:
BoxShadow
(
BoxShadowDisplayItem
{
box_bounds
offset
color
blur_radius
spread_radius
border_radius
clip_mode
}
)
;
self
.
push_item
(
item
info
)
;
}
pub
fn
push_gradient
(
&
mut
self
info
:
&
LayoutPrimitiveInfo
gradient
:
Gradient
tile_size
:
LayoutSize
tile_spacing
:
LayoutSize
)
{
let
item
=
SpecificDisplayItem
:
:
Gradient
(
GradientDisplayItem
{
gradient
tile_size
tile_spacing
}
)
;
self
.
push_item
(
item
info
)
;
}
pub
fn
push_radial_gradient
(
&
mut
self
info
:
&
LayoutPrimitiveInfo
gradient
:
RadialGradient
tile_size
:
LayoutSize
tile_spacing
:
LayoutSize
)
{
let
item
=
SpecificDisplayItem
:
:
RadialGradient
(
RadialGradientDisplayItem
{
gradient
tile_size
tile_spacing
}
)
;
self
.
push_item
(
item
info
)
;
}
pub
fn
push_reference_frame
(
&
mut
self
info
:
&
LayoutPrimitiveInfo
transform
:
Option
<
PropertyBinding
<
LayoutTransform
>
>
perspective
:
Option
<
LayoutTransform
>
)
-
>
ClipId
{
let
id
=
self
.
generate_clip_id
(
)
;
let
item
=
SpecificDisplayItem
:
:
PushReferenceFrame
(
PushReferenceFrameDisplayListItem
{
reference_frame
:
ReferenceFrame
{
transform
perspective
id
}
}
)
;
self
.
push_item
(
item
info
)
;
id
}
pub
fn
pop_reference_frame
(
&
mut
self
)
{
self
.
push_new_empty_item
(
SpecificDisplayItem
:
:
PopReferenceFrame
)
;
}
pub
fn
push_stacking_context
(
&
mut
self
info
:
&
LayoutPrimitiveInfo
clip_node_id
:
Option
<
ClipId
>
transform_style
:
TransformStyle
mix_blend_mode
:
MixBlendMode
filters
:
Vec
<
FilterOp
>
glyph_raster_space
:
GlyphRasterSpace
)
{
let
item
=
SpecificDisplayItem
:
:
PushStackingContext
(
PushStackingContextDisplayItem
{
stacking_context
:
StackingContext
{
transform_style
mix_blend_mode
clip_node_id
glyph_raster_space
}
}
)
;
self
.
push_item
(
item
info
)
;
self
.
push_iter
(
&
filters
)
;
}
pub
fn
pop_stacking_context
(
&
mut
self
)
{
self
.
push_new_empty_item
(
SpecificDisplayItem
:
:
PopStackingContext
)
;
}
pub
fn
push_stops
(
&
mut
self
stops
:
&
[
GradientStop
]
)
{
if
stops
.
is_empty
(
)
{
return
;
}
self
.
push_new_empty_item
(
SpecificDisplayItem
:
:
SetGradientStops
)
;
self
.
push_iter
(
stops
)
;
}
fn
generate_clip_id
(
&
mut
self
)
-
>
ClipId
{
self
.
next_clip_id
+
=
1
;
ClipId
:
:
Clip
(
self
.
next_clip_id
-
1
self
.
pipeline_id
)
}
fn
generate_clip_chain_id
(
&
mut
self
)
-
>
ClipChainId
{
self
.
next_clip_chain_id
+
=
1
;
ClipChainId
(
self
.
next_clip_chain_id
-
1
self
.
pipeline_id
)
}
pub
fn
define_scroll_frame
<
I
>
(
&
mut
self
external_id
:
Option
<
ExternalScrollId
>
content_rect
:
LayoutRect
clip_rect
:
LayoutRect
complex_clips
:
I
image_mask
:
Option
<
ImageMask
>
scroll_sensitivity
:
ScrollSensitivity
)
-
>
ClipId
where
I
:
IntoIterator
<
Item
=
ComplexClipRegion
>
I
:
:
IntoIter
:
ExactSizeIterator
+
Clone
{
let
parent
=
self
.
clip_stack
.
last
(
)
.
unwrap
(
)
.
scroll_node_id
;
self
.
define_scroll_frame_with_parent
(
parent
external_id
content_rect
clip_rect
complex_clips
image_mask
scroll_sensitivity
)
}
pub
fn
define_scroll_frame_with_parent
<
I
>
(
&
mut
self
parent
:
ClipId
external_id
:
Option
<
ExternalScrollId
>
content_rect
:
LayoutRect
clip_rect
:
LayoutRect
complex_clips
:
I
image_mask
:
Option
<
ImageMask
>
scroll_sensitivity
:
ScrollSensitivity
)
-
>
ClipId
where
I
:
IntoIterator
<
Item
=
ComplexClipRegion
>
I
:
:
IntoIter
:
ExactSizeIterator
+
Clone
{
let
clip_id
=
self
.
generate_clip_id
(
)
;
let
scroll_frame_id
=
self
.
generate_clip_id
(
)
;
let
item
=
SpecificDisplayItem
:
:
ScrollFrame
(
ScrollFrameDisplayItem
{
clip_id
scroll_frame_id
external_id
image_mask
scroll_sensitivity
}
)
;
self
.
push_item_with_clip_scroll_info
(
item
&
LayoutPrimitiveInfo
:
:
with_clip_rect
(
content_rect
clip_rect
)
ClipAndScrollInfo
:
:
simple
(
parent
)
)
;
self
.
push_iter
(
complex_clips
)
;
scroll_frame_id
}
pub
fn
define_clip_chain
<
I
>
(
&
mut
self
parent
:
Option
<
ClipChainId
>
clips
:
I
)
-
>
ClipChainId
where
I
:
IntoIterator
<
Item
=
ClipId
>
I
:
:
IntoIter
:
ExactSizeIterator
+
Clone
{
let
id
=
self
.
generate_clip_chain_id
(
)
;
self
.
push_new_empty_item
(
SpecificDisplayItem
:
:
ClipChain
(
ClipChainItem
{
id
parent
}
)
)
;
self
.
push_iter
(
clips
)
;
id
}
pub
fn
define_clip
<
I
>
(
&
mut
self
clip_rect
:
LayoutRect
complex_clips
:
I
image_mask
:
Option
<
ImageMask
>
)
-
>
ClipId
where
I
:
IntoIterator
<
Item
=
ComplexClipRegion
>
I
:
:
IntoIter
:
ExactSizeIterator
+
Clone
{
let
parent
=
self
.
clip_stack
.
last
(
)
.
unwrap
(
)
.
scroll_node_id
;
self
.
define_clip_with_parent
(
parent
clip_rect
complex_clips
image_mask
)
}
pub
fn
define_clip_with_parent
<
I
>
(
&
mut
self
parent
:
ClipId
clip_rect
:
LayoutRect
complex_clips
:
I
image_mask
:
Option
<
ImageMask
>
)
-
>
ClipId
where
I
:
IntoIterator
<
Item
=
ComplexClipRegion
>
I
:
:
IntoIter
:
ExactSizeIterator
+
Clone
{
let
id
=
self
.
generate_clip_id
(
)
;
let
item
=
SpecificDisplayItem
:
:
Clip
(
ClipDisplayItem
{
id
image_mask
}
)
;
let
info
=
LayoutPrimitiveInfo
:
:
new
(
clip_rect
)
;
let
scrollinfo
=
ClipAndScrollInfo
:
:
simple
(
parent
)
;
self
.
push_item_with_clip_scroll_info
(
item
&
info
scrollinfo
)
;
self
.
push_iter
(
complex_clips
)
;
id
}
pub
fn
define_sticky_frame
(
&
mut
self
frame_rect
:
LayoutRect
margins
:
SideOffsets2D
<
Option
<
f32
>
>
vertical_offset_bounds
:
StickyOffsetBounds
horizontal_offset_bounds
:
StickyOffsetBounds
previously_applied_offset
:
LayoutVector2D
)
-
>
ClipId
{
let
id
=
self
.
generate_clip_id
(
)
;
let
item
=
SpecificDisplayItem
:
:
StickyFrame
(
StickyFrameDisplayItem
{
id
margins
vertical_offset_bounds
horizontal_offset_bounds
previously_applied_offset
}
)
;
let
info
=
LayoutPrimitiveInfo
:
:
new
(
frame_rect
)
;
self
.
push_item
(
item
&
info
)
;
id
}
pub
fn
push_clip_id
(
&
mut
self
id
:
ClipId
)
{
self
.
clip_stack
.
push
(
ClipAndScrollInfo
:
:
simple
(
id
)
)
;
}
pub
fn
push_clip_and_scroll_info
(
&
mut
self
info
:
ClipAndScrollInfo
)
{
self
.
clip_stack
.
push
(
info
)
;
}
pub
fn
pop_clip_id
(
&
mut
self
)
{
self
.
clip_stack
.
pop
(
)
;
if
let
Some
(
save_state
)
=
self
.
save_state
.
as_ref
(
)
{
assert
!
(
self
.
clip_stack
.
len
(
)
>
=
save_state
.
clip_stack_len
"
Cannot
pop
clips
that
were
pushed
before
the
DisplayListBuilder
save
.
"
)
;
}
assert
!
(
!
self
.
clip_stack
.
is_empty
(
)
)
;
}
pub
fn
push_iframe
(
&
mut
self
info
:
&
LayoutPrimitiveInfo
pipeline_id
:
PipelineId
ignore_missing_pipeline
:
bool
)
{
let
item
=
SpecificDisplayItem
:
:
Iframe
(
IframeDisplayItem
{
clip_id
:
self
.
generate_clip_id
(
)
pipeline_id
ignore_missing_pipeline
}
)
;
self
.
push_item
(
item
info
)
;
}
pub
fn
push_shadow
(
&
mut
self
info
:
&
LayoutPrimitiveInfo
shadow
:
Shadow
)
{
self
.
push_item
(
SpecificDisplayItem
:
:
PushShadow
(
shadow
)
info
)
;
}
pub
fn
pop_all_shadows
(
&
mut
self
)
{
self
.
push_new_empty_item
(
SpecificDisplayItem
:
:
PopAllShadows
)
;
}
pub
fn
finalize
(
self
)
-
>
(
PipelineId
LayoutSize
BuiltDisplayList
)
{
assert
!
(
self
.
save_state
.
is_none
(
)
"
Finalized
DisplayListBuilder
with
a
pending
save
"
)
;
let
end_time
=
precise_time_ns
(
)
;
(
self
.
pipeline_id
self
.
content_size
BuiltDisplayList
{
descriptor
:
BuiltDisplayListDescriptor
{
builder_start_time
:
self
.
builder_start_time
builder_finish_time
:
end_time
send_start_time
:
0
total_clip_ids
:
self
.
next_clip_id
}
data
:
self
.
data
}
)
}
}
