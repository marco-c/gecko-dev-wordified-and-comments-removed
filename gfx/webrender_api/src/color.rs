use
std
:
:
hash
:
:
{
Hash
Hasher
}
;
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Deserialize
PartialEq
Serialize
)
]
pub
struct
ColorF
{
pub
r
:
f32
pub
g
:
f32
pub
b
:
f32
pub
a
:
f32
}
impl
ColorF
{
pub
fn
new
(
r
:
f32
g
:
f32
b
:
f32
a
:
f32
)
-
>
ColorF
{
ColorF
{
r
g
b
a
}
}
pub
fn
scale_rgb
(
&
self
scale
:
f32
)
-
>
ColorF
{
ColorF
{
r
:
self
.
r
*
scale
g
:
self
.
g
*
scale
b
:
self
.
b
*
scale
a
:
self
.
a
}
}
pub
fn
to_array
(
&
self
)
-
>
[
f32
;
4
]
{
[
self
.
r
self
.
g
self
.
b
self
.
a
]
}
pub
fn
premultiplied
(
&
self
)
-
>
ColorF
{
self
.
scale_rgb
(
self
.
a
)
}
}
impl
Eq
for
ColorF
{
}
impl
Hash
for
ColorF
{
fn
hash
<
H
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
r
.
_to_bits
(
)
.
hash
(
state
)
;
self
.
g
.
_to_bits
(
)
.
hash
(
state
)
;
self
.
b
.
_to_bits
(
)
.
hash
(
state
)
;
self
.
a
.
_to_bits
(
)
.
hash
(
state
)
;
}
}
pub
trait
ToBits
{
fn
_to_bits
(
self
)
-
>
u32
;
}
impl
ToBits
for
f32
{
fn
_to_bits
(
self
)
-
>
u32
{
unsafe
{
:
:
std
:
:
mem
:
:
transmute
(
self
)
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Hash
Eq
Debug
Deserialize
PartialEq
PartialOrd
Ord
Serialize
)
]
pub
struct
ColorU
{
pub
r
:
u8
pub
g
:
u8
pub
b
:
u8
pub
a
:
u8
}
impl
ColorU
{
pub
fn
new
(
r
:
u8
g
:
u8
b
:
u8
a
:
u8
)
-
>
ColorU
{
ColorU
{
r
g
b
a
}
}
}
fn
round_to_int
(
x
:
f32
)
-
>
u8
{
debug_assert
!
(
(
0
.
0
<
=
x
)
&
&
(
x
<
=
1
.
0
)
)
;
let
f
=
(
255
.
0
*
x
)
+
0
.
5
;
let
val
=
f
.
floor
(
)
;
debug_assert
!
(
val
<
=
255
.
0
)
;
val
as
u8
}
impl
From
<
ColorF
>
for
ColorU
{
fn
from
(
color
:
ColorF
)
-
>
ColorU
{
ColorU
{
r
:
round_to_int
(
color
.
r
)
g
:
round_to_int
(
color
.
g
)
b
:
round_to_int
(
color
.
b
)
a
:
round_to_int
(
color
.
a
)
}
}
}
impl
From
<
ColorU
>
for
ColorF
{
fn
from
(
color
:
ColorU
)
-
>
ColorF
{
ColorF
{
r
:
color
.
r
as
f32
/
255
.
0
g
:
color
.
g
as
f32
/
255
.
0
b
:
color
.
b
as
f32
/
255
.
0
a
:
color
.
a
as
f32
/
255
.
0
}
}
}
