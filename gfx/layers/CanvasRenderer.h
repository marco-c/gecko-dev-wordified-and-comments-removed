#
ifndef
GFX_CANVASRENDERER_H
#
define
GFX_CANVASRENDERER_H
#
include
<
stdint
.
h
>
#
include
"
GLContextTypes
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxTypes
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsISupportsImpl
.
h
"
namespace
mozilla
{
namespace
layers
{
class
AsyncCanvasRenderer
;
class
ClientCanvasRenderer
;
class
CopyableCanvasRenderer
;
class
PersistentBufferProvider
;
class
WebRenderCanvasRendererAsync
;
struct
CanvasInitializeData
final
{
CanvasInitializeData
(
)
;
~
CanvasInitializeData
(
)
;
RefPtr
<
PersistentBufferProvider
>
mBufferProvider
;
RefPtr
<
mozilla
:
:
gl
:
:
GLContext
>
mGLContext
;
RefPtr
<
AsyncCanvasRenderer
>
mRenderer
;
typedef
void
(
*
TransactionCallback
)
(
void
*
closureData
)
;
TransactionCallback
mPreTransCallback
=
nullptr
;
void
*
mPreTransCallbackData
=
nullptr
;
TransactionCallback
mDidTransCallback
=
nullptr
;
void
*
mDidTransCallbackData
=
nullptr
;
gfx
:
:
IntSize
mSize
=
{
0
0
}
;
bool
mHasAlpha
=
false
;
bool
mIsGLAlphaPremult
=
true
;
}
;
class
CanvasRenderer
{
public
:
CanvasRenderer
(
)
;
virtual
~
CanvasRenderer
(
)
;
public
:
virtual
void
Initialize
(
const
CanvasInitializeData
&
aData
)
;
virtual
bool
IsDataValid
(
const
CanvasInitializeData
&
aData
)
{
return
true
;
}
virtual
void
ClearCachedResources
(
)
{
}
virtual
void
Destroy
(
)
{
}
const
gfx
:
:
IntSize
&
GetSize
(
)
const
{
return
mSize
;
}
void
SetDirty
(
)
{
mDirty
=
true
;
}
void
ResetDirty
(
)
{
mDirty
=
false
;
}
bool
IsDirty
(
)
const
{
return
mDirty
;
}
virtual
CopyableCanvasRenderer
*
AsCopyableCanvasRenderer
(
)
{
return
nullptr
;
}
virtual
ClientCanvasRenderer
*
AsClientCanvasRenderer
(
)
{
return
nullptr
;
}
virtual
WebRenderCanvasRendererAsync
*
AsWebRenderCanvasRendererAsync
(
)
{
return
nullptr
;
}
protected
:
void
FirePreTransactionCallback
(
)
{
if
(
mPreTransCallback
)
{
mPreTransCallback
(
mPreTransCallbackData
)
;
}
}
void
FireDidTransactionCallback
(
)
{
if
(
mDidTransCallback
)
{
mDidTransCallback
(
mDidTransCallbackData
)
;
}
}
typedef
void
(
*
TransactionCallback
)
(
void
*
closureData
)
;
TransactionCallback
mPreTransCallback
;
void
*
mPreTransCallbackData
;
TransactionCallback
mDidTransCallback
;
void
*
mDidTransCallbackData
;
gfx
:
:
IntSize
mSize
;
private
:
bool
mDirty
;
}
;
}
}
#
endif
