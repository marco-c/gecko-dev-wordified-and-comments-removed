#
ifndef
GFX_CANVASRENDERER_H
#
define
GFX_CANVASRENDERER_H
#
include
<
memory
>
#
include
<
stdint
.
h
>
#
include
"
GLContextTypes
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxTypes
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
nsISupportsImpl
.
h
"
class
nsICanvasRenderingContextInternal
;
namespace
mozilla
{
namespace
layers
{
class
KnowsCompositor
;
class
PersistentBufferProvider
;
class
WebRenderCanvasRendererAsync
;
TextureType
TexTypeForWebgl
(
KnowsCompositor
*
)
;
struct
CanvasRendererData
final
{
CanvasRendererData
(
)
;
~
CanvasRendererData
(
)
;
std
:
:
weak_ptr
<
nsICanvasRenderingContextInternal
*
const
>
mContext
;
gfx
:
:
IntSize
mSize
=
{
0
0
}
;
bool
mDoPaintCallbacks
=
false
;
bool
mIsOpaque
=
true
;
bool
mIsAlphaPremult
=
true
;
gl
:
:
OriginPos
mOriginPos
=
gl
:
:
OriginPos
:
:
TopLeft
;
nsICanvasRenderingContextInternal
*
GetContext
(
)
const
{
const
auto
ptrToPtr
=
mContext
.
lock
(
)
;
if
(
!
ptrToPtr
)
return
nullptr
;
return
*
ptrToPtr
;
}
}
;
class
BorrowedSourceSurface
final
{
public
:
const
WeakPtr
<
PersistentBufferProvider
>
mReturnTo
;
const
RefPtr
<
gfx
:
:
SourceSurface
>
mSurf
;
BorrowedSourceSurface
(
PersistentBufferProvider
*
RefPtr
<
gfx
:
:
SourceSurface
>
)
;
~
BorrowedSourceSurface
(
)
;
}
;
class
CanvasRenderer
:
public
RefCounted
<
CanvasRenderer
>
{
friend
class
CanvasRendererSourceSurface
;
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
CanvasRenderer
)
private
:
bool
mDirty
=
false
;
protected
:
CanvasRendererData
mData
;
public
:
explicit
CanvasRenderer
(
)
;
virtual
~
CanvasRenderer
(
)
;
public
:
virtual
void
Initialize
(
const
CanvasRendererData
&
)
;
virtual
bool
IsDataValid
(
const
CanvasRendererData
&
)
const
;
virtual
void
ClearCachedResources
(
)
{
}
virtual
void
DisconnectClient
(
)
{
}
const
gfx
:
:
IntSize
&
GetSize
(
)
const
{
return
mData
.
mSize
;
}
bool
IsOpaque
(
)
const
{
return
mData
.
mIsOpaque
;
}
bool
YIsDown
(
)
const
{
return
mData
.
mOriginPos
=
=
gl
:
:
OriginPos
:
:
TopLeft
;
}
void
SetDirty
(
)
{
mDirty
=
true
;
}
void
ResetDirty
(
)
{
mDirty
=
false
;
}
bool
IsDirty
(
)
const
{
return
mDirty
;
}
virtual
WebRenderCanvasRendererAsync
*
AsWebRenderCanvasRendererAsync
(
)
{
return
nullptr
;
}
std
:
:
shared_ptr
<
BorrowedSourceSurface
>
BorrowSnapshot
(
bool
requireAlphaPremult
=
true
)
const
;
void
FirePreTransactionCallback
(
)
const
;
void
FireDidTransactionCallback
(
)
const
;
}
;
}
}
#
endif
