#
ifndef
GFX_GPU_VIDEO_IMAGE_H
#
define
GFX_GPU_VIDEO_IMAGE_H
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
mozilla
/
layers
/
GPUVideoTextureClient
.
h
"
#
include
"
mozilla
/
layers
/
CompositableClient
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeChild
.
h
"
namespace
mozilla
{
namespace
gl
{
class
GLBlitHelper
;
}
namespace
layers
{
class
IGPUVideoSurfaceManager
{
protected
:
virtual
~
IGPUVideoSurfaceManager
(
)
{
}
;
public
:
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
virtual
already_AddRefed
<
gfx
:
:
SourceSurface
>
Readback
(
const
SurfaceDescriptorGPUVideo
&
aSD
)
=
0
;
virtual
void
DeallocateSurfaceDescriptor
(
const
SurfaceDescriptorGPUVideo
&
aSD
)
=
0
;
}
;
class
GPUVideoImage
final
:
public
Image
{
friend
class
gl
:
:
GLBlitHelper
;
public
:
GPUVideoImage
(
IGPUVideoSurfaceManager
*
aManager
const
SurfaceDescriptorGPUVideo
&
aSD
const
gfx
:
:
IntSize
&
aSize
)
:
Image
(
nullptr
ImageFormat
:
:
GPU_VIDEO
)
mSize
(
aSize
)
{
mTextureClient
=
TextureClient
:
:
CreateWithData
(
new
GPUVideoTextureData
(
aManager
aSD
aSize
)
TextureFlags
:
:
RECYCLE
ImageBridgeChild
:
:
GetSingleton
(
)
.
get
(
)
)
;
}
virtual
~
GPUVideoImage
(
)
=
default
;
gfx
:
:
IntSize
GetSize
(
)
const
override
{
return
mSize
;
}
private
:
GPUVideoTextureData
*
GetData
(
)
const
{
if
(
!
mTextureClient
)
{
return
nullptr
;
}
TextureData
*
data
=
mTextureClient
-
>
GetInternalData
(
)
;
if
(
!
data
)
{
return
nullptr
;
}
return
data
-
>
AsGPUVideoTextureData
(
)
;
}
public
:
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetAsSourceSurface
(
)
override
{
GPUVideoTextureData
*
data
=
GetData
(
)
;
if
(
!
data
)
{
return
nullptr
;
}
return
data
-
>
GetAsSourceSurface
(
)
;
}
TextureClient
*
GetTextureClient
(
KnowsCompositor
*
aKnowsCompositor
)
override
{
MOZ_ASSERT
(
aKnowsCompositor
=
=
ImageBridgeChild
:
:
GetSingleton
(
)
"
Must
only
use
GPUVideo
on
ImageBridge
"
)
;
return
mTextureClient
;
}
private
:
gfx
:
:
IntSize
mSize
;
RefPtr
<
TextureClient
>
mTextureClient
;
}
;
}
}
#
endif
