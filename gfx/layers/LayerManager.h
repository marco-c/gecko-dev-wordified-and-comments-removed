#
ifndef
GFX_LAYERMANAGER_H
#
define
GFX_LAYERMANAGER_H
#
include
<
cstdint
>
#
include
<
iosfwd
>
#
include
<
new
>
#
include
<
unordered_set
>
#
include
<
utility
>
#
include
"
FrameMetrics
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
Animation
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
gfx
/
UserData
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
ScrollableLayerGuid
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
class
gfxContext
;
extern
uint8_t
gLayerManagerLayerBuilder
;
namespace
mozilla
{
class
FrameLayerBuilder
;
class
LogModule
;
class
ScrollPositionUpdate
;
namespace
gfx
{
class
DrawTarget
;
}
namespace
layers
{
class
AsyncPanZoomController
;
class
BasicLayerManager
;
class
ClientLayerManager
;
class
HostLayerManager
;
class
Layer
;
class
LayerMetricsWrapper
;
class
PaintedLayer
;
class
ContainerLayer
;
class
ImageLayer
;
class
ColorLayer
;
class
CompositorBridgeChild
;
class
CanvasLayer
;
class
ReadbackLayer
;
class
ReadbackProcessor
;
class
RefLayer
;
class
HostLayer
;
class
FocusTarget
;
class
KnowsCompositor
;
class
ShadowableLayer
;
class
ShadowLayerForwarder
;
class
LayerManagerComposite
;
class
TransactionIdAllocator
;
class
FrameUniformityData
;
class
PersistentBufferProvider
;
class
GlyphArray
;
class
WebRenderLayerManager
;
struct
LayerPolygon
;
struct
AnimData
;
namespace
layerscope
{
class
LayersPacket
;
}
class
LayerUserData
;
class
DidCompositeObserver
{
public
:
virtual
void
DidComposite
(
)
=
0
;
}
;
class
FrameRecorder
{
public
:
virtual
uint32_t
StartFrameTimeRecording
(
int32_t
aBufferSize
)
;
virtual
void
StopFrameTimeRecording
(
uint32_t
aStartIndex
nsTArray
<
float
>
&
aFrameIntervals
)
;
void
RecordFrame
(
)
;
private
:
struct
FramesTimingRecording
{
FramesTimingRecording
(
)
:
mNextIndex
(
0
)
mLatestStartIndex
(
0
)
mCurrentRunStartIndex
(
0
)
mIsPaused
(
true
)
{
}
nsTArray
<
float
>
mIntervals
;
TimeStamp
mLastFrameTime
;
uint32_t
mNextIndex
;
uint32_t
mLatestStartIndex
;
uint32_t
mCurrentRunStartIndex
;
bool
mIsPaused
;
}
;
FramesTimingRecording
mRecording
;
}
;
class
LayerManager
:
public
FrameRecorder
{
NS_INLINE_DECL_REFCOUNTING
(
LayerManager
)
protected
:
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
typedef
mozilla
:
:
gfx
:
:
IntSize
IntSize
;
typedef
mozilla
:
:
gfx
:
:
SurfaceFormat
SurfaceFormat
;
public
:
LayerManager
(
)
;
virtual
void
Destroy
(
)
;
bool
IsDestroyed
(
)
{
return
mDestroyed
;
}
virtual
ShadowLayerForwarder
*
AsShadowForwarder
(
)
{
return
nullptr
;
}
virtual
KnowsCompositor
*
AsKnowsCompositor
(
)
{
return
nullptr
;
}
virtual
LayerManagerComposite
*
AsLayerManagerComposite
(
)
{
return
nullptr
;
}
virtual
ClientLayerManager
*
AsClientLayerManager
(
)
{
return
nullptr
;
}
virtual
BasicLayerManager
*
AsBasicLayerManager
(
)
{
return
nullptr
;
}
virtual
HostLayerManager
*
AsHostLayerManager
(
)
{
return
nullptr
;
}
virtual
WebRenderLayerManager
*
AsWebRenderLayerManager
(
)
{
return
nullptr
;
}
virtual
bool
IsWidgetLayerManager
(
)
{
return
true
;
}
virtual
bool
IsInactiveLayerManager
(
)
{
return
false
;
}
virtual
bool
BeginTransaction
(
const
nsCString
&
aURL
=
nsCString
(
)
)
=
0
;
virtual
bool
BeginTransactionWithTarget
(
gfxContext
*
aTarget
const
nsCString
&
aURL
=
nsCString
(
)
)
=
0
;
enum
EndTransactionFlags
{
END_DEFAULT
=
0
END_NO_IMMEDIATE_REDRAW
=
1
<
<
0
END_NO_COMPOSITE
=
1
<
<
1
END_NO_REMOTE_COMPOSITE
=
1
<
<
2
}
;
FrameLayerBuilder
*
GetLayerBuilder
(
)
{
return
reinterpret_cast
<
FrameLayerBuilder
*
>
(
GetUserData
(
&
gLayerManagerLayerBuilder
)
)
;
}
virtual
bool
EndEmptyTransaction
(
EndTransactionFlags
aFlags
=
END_DEFAULT
)
=
0
;
typedef
void
(
*
DrawPaintedLayerCallback
)
(
PaintedLayer
*
aLayer
gfxContext
*
aContext
const
nsIntRegion
&
aRegionToDraw
const
nsIntRegion
&
aDirtyRegion
DrawRegionClip
aClip
const
nsIntRegion
&
aRegionToInvalidate
void
*
aCallbackData
)
;
virtual
void
EndTransaction
(
DrawPaintedLayerCallback
aCallback
void
*
aCallbackData
EndTransactionFlags
aFlags
=
END_DEFAULT
)
=
0
;
virtual
void
ScheduleComposite
(
)
{
}
virtual
void
SetNeedsComposite
(
bool
aNeedsComposite
)
{
}
virtual
bool
NeedsComposite
(
)
const
{
return
false
;
}
virtual
bool
HasShadowManagerInternal
(
)
const
{
return
false
;
}
bool
HasShadowManager
(
)
const
{
return
HasShadowManagerInternal
(
)
;
}
virtual
void
StorePluginWidgetConfigurations
(
const
nsTArray
<
nsIWidget
:
:
Configuration
>
&
aConfigurations
)
{
}
bool
IsSnappingEffectiveTransforms
(
)
{
return
mSnapEffectiveTransforms
;
}
static
bool
LayersComponentAlphaEnabled
(
)
;
virtual
bool
AreComponentAlphaLayersEnabled
(
)
;
virtual
bool
BlendingRequiresIntermediateSurface
(
)
{
return
false
;
}
virtual
void
SetRoot
(
Layer
*
aLayer
)
=
0
;
Layer
*
GetRoot
(
)
{
return
mRoot
;
}
ScrollableLayerGuid
:
:
ViewID
GetRootScrollableLayerId
(
)
;
LayerMetricsWrapper
GetRootContentLayer
(
)
;
virtual
void
Mutated
(
Layer
*
aLayer
)
{
}
virtual
void
MutatedSimple
(
Layer
*
aLayer
)
{
}
enum
PaintedLayerCreationHint
{
NONE
SCROLLABLE
}
;
virtual
already_AddRefed
<
PaintedLayer
>
CreatePaintedLayer
(
)
=
0
;
virtual
already_AddRefed
<
PaintedLayer
>
CreatePaintedLayerWithHint
(
PaintedLayerCreationHint
)
{
return
CreatePaintedLayer
(
)
;
}
virtual
already_AddRefed
<
ContainerLayer
>
CreateContainerLayer
(
)
=
0
;
virtual
already_AddRefed
<
ImageLayer
>
CreateImageLayer
(
)
=
0
;
virtual
already_AddRefed
<
ColorLayer
>
CreateColorLayer
(
)
=
0
;
virtual
already_AddRefed
<
CanvasLayer
>
CreateCanvasLayer
(
)
=
0
;
virtual
already_AddRefed
<
ReadbackLayer
>
CreateReadbackLayer
(
)
{
return
nullptr
;
}
virtual
already_AddRefed
<
RefLayer
>
CreateRefLayer
(
)
{
return
nullptr
;
}
static
already_AddRefed
<
ImageContainer
>
CreateImageContainer
(
ImageContainer
:
:
Mode
flag
=
ImageContainer
:
:
SYNCHRONOUS
)
;
virtual
LayersBackend
GetBackendType
(
)
=
0
;
virtual
LayersBackend
GetCompositorBackendType
(
)
{
return
GetBackendType
(
)
;
}
virtual
already_AddRefed
<
DrawTarget
>
CreateOptimalDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
imageFormat
)
;
virtual
already_AddRefed
<
DrawTarget
>
CreateOptimalMaskDrawTarget
(
const
IntSize
&
aSize
)
;
virtual
already_AddRefed
<
mozilla
:
:
gfx
:
:
DrawTarget
>
CreateDrawTarget
(
const
mozilla
:
:
gfx
:
:
IntSize
&
aSize
mozilla
:
:
gfx
:
:
SurfaceFormat
aFormat
)
;
virtual
already_AddRefed
<
PersistentBufferProvider
>
CreatePersistentBufferProvider
(
const
mozilla
:
:
gfx
:
:
IntSize
&
aSize
mozilla
:
:
gfx
:
:
SurfaceFormat
aFormat
)
;
virtual
bool
CanUseCanvasLayerForSize
(
const
gfx
:
:
IntSize
&
aSize
)
{
return
true
;
}
virtual
int32_t
GetMaxTextureSize
(
)
const
=
0
;
virtual
void
GetBackendName
(
nsAString
&
aName
)
=
0
;
void
SetUserData
(
void
*
aKey
LayerUserData
*
aData
)
{
mUserData
.
Add
(
static_cast
<
gfx
:
:
UserDataKey
*
>
(
aKey
)
aData
LayerUserDataDestroy
)
;
}
UniquePtr
<
LayerUserData
>
RemoveUserData
(
void
*
aKey
)
;
bool
HasUserData
(
void
*
aKey
)
{
return
mUserData
.
Has
(
static_cast
<
gfx
:
:
UserDataKey
*
>
(
aKey
)
)
;
}
LayerUserData
*
GetUserData
(
void
*
aKey
)
const
{
return
static_cast
<
LayerUserData
*
>
(
mUserData
.
Get
(
static_cast
<
gfx
:
:
UserDataKey
*
>
(
aKey
)
)
)
;
}
virtual
void
ClearCachedResources
(
Layer
*
aSubtree
=
nullptr
)
{
}
virtual
void
SetIsFirstPaint
(
)
{
}
virtual
bool
GetIsFirstPaint
(
)
const
{
return
false
;
}
virtual
void
SetFocusTarget
(
const
FocusTarget
&
aFocusTarget
)
{
}
virtual
void
FlushRendering
(
)
{
}
virtual
void
WaitOnTransactionProcessed
(
)
{
}
virtual
void
SendInvalidRegion
(
const
nsIntRegion
&
aRegion
)
{
}
virtual
bool
NeedsWidgetInvalidation
(
)
{
return
true
;
}
virtual
const
char
*
Name
(
)
const
{
return
"
?
?
?
"
;
}
void
Dump
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
=
"
"
bool
aDumpHtml
=
false
bool
aSorted
=
false
)
;
void
DumpSelf
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
=
"
"
bool
aSorted
=
false
)
;
void
Dump
(
bool
aSorted
=
false
)
;
void
Dump
(
layerscope
:
:
LayersPacket
*
aPacket
)
;
void
Log
(
const
char
*
aPrefix
=
"
"
)
;
void
LogSelf
(
const
char
*
aPrefix
=
"
"
)
;
static
bool
IsLogEnabled
(
)
;
static
mozilla
:
:
LogModule
*
GetLog
(
)
;
bool
IsCompositingCheap
(
LayersBackend
aBackend
)
{
return
LayersBackend
:
:
LAYERS_BASIC
!
=
aBackend
&
&
LayersBackend
:
:
LAYERS_NONE
!
=
aBackend
;
}
virtual
bool
IsCompositingCheap
(
)
{
return
true
;
}
bool
IsInTransaction
(
)
const
{
return
mInTransaction
;
}
virtual
void
GetFrameUniformity
(
FrameUniformityData
*
aOutData
)
{
}
virtual
void
SetRegionToClear
(
const
nsIntRegion
&
aRegion
)
{
mRegionToClear
=
aRegion
;
}
virtual
float
RequestProperty
(
const
nsAString
&
property
)
{
return
-
1
;
}
const
TimeStamp
&
GetAnimationReadyTime
(
)
const
{
return
mAnimationReadyTime
;
}
virtual
bool
AsyncPanZoomEnabled
(
)
const
{
return
false
;
}
static
void
LayerUserDataDestroy
(
void
*
data
)
;
void
AddPaintedPixelCount
(
int32_t
aCount
)
{
mPaintedPixelCount
+
=
aCount
;
}
uint32_t
GetAndClearPaintedPixelCount
(
)
{
uint32_t
count
=
mPaintedPixelCount
;
mPaintedPixelCount
=
0
;
return
count
;
}
virtual
void
SetLayersObserverEpoch
(
LayersObserverEpoch
aEpoch
)
{
}
virtual
void
DidComposite
(
TransactionId
aTransactionId
const
mozilla
:
:
TimeStamp
&
aCompositeStart
const
mozilla
:
:
TimeStamp
&
aCompositeEnd
)
{
}
virtual
void
AddDidCompositeObserver
(
DidCompositeObserver
*
aObserver
)
{
MOZ_CRASH
(
"
GFX
:
LayerManager
"
)
;
}
virtual
void
RemoveDidCompositeObserver
(
DidCompositeObserver
*
aObserver
)
{
MOZ_CRASH
(
"
GFX
:
LayerManager
"
)
;
}
virtual
void
UpdateTextureFactoryIdentifier
(
const
TextureFactoryIdentifier
&
aNewIdentifier
)
{
}
virtual
TextureFactoryIdentifier
GetTextureFactoryIdentifier
(
)
{
return
TextureFactoryIdentifier
(
)
;
}
virtual
void
SetTransactionIdAllocator
(
TransactionIdAllocator
*
aAllocator
)
{
}
virtual
TransactionId
GetLastTransactionId
(
)
{
return
TransactionId
{
0
}
;
}
virtual
CompositorBridgeChild
*
GetCompositorBridgeChild
(
)
{
return
nullptr
;
}
void
RegisterPayload
(
const
CompositionPayload
&
aPayload
)
{
mPayload
.
AppendElement
(
aPayload
)
;
MOZ_ASSERT
(
mPayload
.
Length
(
)
<
10000
)
;
}
void
RegisterPayloads
(
const
nsTArray
<
CompositionPayload
>
&
aPayload
)
{
mPayload
.
AppendElements
(
aPayload
)
;
MOZ_ASSERT
(
mPayload
.
Length
(
)
<
10000
)
;
}
virtual
void
PayloadPresented
(
const
TimeStamp
&
aTimeStamp
)
;
void
SetContainsSVG
(
bool
aContainsSVG
)
{
mContainsSVG
=
aContainsSVG
;
}
void
AddPartialPrerenderedAnimation
(
uint64_t
aCompositorAnimationId
dom
:
:
Animation
*
aAnimation
)
;
void
RemovePartialPrerenderedAnimation
(
uint64_t
aCompositorAnimationId
dom
:
:
Animation
*
aAnimation
)
;
void
UpdatePartialPrerenderedAnimations
(
const
nsTArray
<
uint64_t
>
&
aJankedAnimations
)
;
protected
:
RefPtr
<
Layer
>
mRoot
;
gfx
:
:
UserData
mUserData
;
bool
mDestroyed
;
bool
mSnapEffectiveTransforms
;
nsIntRegion
mRegionToClear
;
virtual
~
LayerManager
(
)
;
virtual
void
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
;
virtual
void
DumpPacket
(
layerscope
:
:
LayersPacket
*
aPacket
)
;
uint64_t
mId
;
bool
mInTransaction
;
bool
mContainsSVG
;
TimeStamp
mAnimationReadyTime
;
uint32_t
mPaintedPixelCount
;
nsTArray
<
CompositionPayload
>
mPayload
;
nsRefPtrHashtable
<
nsUint64HashKey
dom
:
:
Animation
>
mPartialPrerenderedAnimations
;
public
:
virtual
bool
AddPendingScrollUpdateForNextTransaction
(
ScrollableLayerGuid
:
:
ViewID
aScrollId
const
ScrollPositionUpdate
&
aUpdateInfo
)
;
Maybe
<
nsTArray
<
ScrollPositionUpdate
>
>
GetPendingScrollInfoUpdate
(
ScrollableLayerGuid
:
:
ViewID
aScrollId
)
;
std
:
:
unordered_set
<
ScrollableLayerGuid
:
:
ViewID
>
ClearPendingScrollInfoUpdate
(
)
;
protected
:
ScrollUpdatesMap
mPendingScrollUpdates
;
}
;
}
}
#
endif
