#
ifndef
MOZILLA_GFX_COMPOSITOR_H
#
define
MOZILLA_GFX_COMPOSITOR_H
#
include
"
Units
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
MatrixFwd
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
FenceUtils
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRegion
.
h
"
#
include
<
vector
>
#
include
"
mozilla
/
WidgetUtils
.
h
"
class
nsIWidget
;
namespace
mozilla
{
namespace
gfx
{
class
Matrix
;
class
DrawTarget
;
}
namespace
layers
{
struct
Effect
;
struct
EffectChain
;
class
Image
;
class
ImageHostOverlay
;
class
Layer
;
class
TextureSource
;
class
DataTextureSource
;
class
CompositingRenderTarget
;
class
PCompositorParent
;
class
LayerManagerComposite
;
enum
SurfaceInitMode
{
INIT_MODE_NONE
INIT_MODE_CLEAR
}
;
class
Compositor
{
protected
:
virtual
~
Compositor
(
)
{
}
public
:
NS_INLINE_DECL_REFCOUNTING
(
Compositor
)
explicit
Compositor
(
PCompositorParent
*
aParent
=
nullptr
)
:
mCompositorID
(
0
)
mDiagnosticTypes
(
DiagnosticTypes
:
:
NO_DIAGNOSTIC
)
mParent
(
aParent
)
mScreenRotation
(
ROTATION_0
)
{
}
virtual
already_AddRefed
<
DataTextureSource
>
CreateDataTextureSource
(
TextureFlags
aFlags
=
TextureFlags
:
:
NO_FLAGS
)
=
0
;
virtual
bool
Initialize
(
)
=
0
;
virtual
void
Destroy
(
)
=
0
;
virtual
bool
SupportsEffect
(
EffectTypes
aEffect
)
{
return
true
;
}
virtual
TextureFactoryIdentifier
GetTextureFactoryIdentifier
(
)
=
0
;
virtual
bool
CanUseCanvasLayerForSize
(
const
gfx
:
:
IntSize
&
aSize
)
=
0
;
virtual
int32_t
GetMaxTextureSize
(
)
const
=
0
;
void
SetTargetContext
(
gfx
:
:
DrawTarget
*
aTarget
const
gfx
:
:
IntRect
&
aRect
)
{
mTarget
=
aTarget
;
mTargetBounds
=
aRect
;
}
gfx
:
:
DrawTarget
*
GetTargetContext
(
)
const
{
return
mTarget
;
}
void
ClearTargetContext
(
)
{
mTarget
=
nullptr
;
}
typedef
uint32_t
MakeCurrentFlags
;
static
const
MakeCurrentFlags
ForceMakeCurrent
=
0x1
;
virtual
void
MakeCurrent
(
MakeCurrentFlags
aFlags
=
0
)
=
0
;
virtual
already_AddRefed
<
CompositingRenderTarget
>
CreateRenderTarget
(
const
gfx
:
:
IntRect
&
aRect
SurfaceInitMode
aInit
)
=
0
;
virtual
already_AddRefed
<
CompositingRenderTarget
>
CreateRenderTargetFromSource
(
const
gfx
:
:
IntRect
&
aRect
const
CompositingRenderTarget
*
aSource
const
gfx
:
:
IntPoint
&
aSourcePoint
)
=
0
;
virtual
void
SetRenderTarget
(
CompositingRenderTarget
*
aSurface
)
=
0
;
virtual
CompositingRenderTarget
*
GetCurrentRenderTarget
(
)
const
=
0
;
virtual
void
SetDestinationSurfaceSize
(
const
gfx
:
:
IntSize
&
aSize
)
=
0
;
virtual
void
SetScreenRenderOffset
(
const
ScreenPoint
&
aOffset
)
=
0
;
virtual
void
DrawQuad
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
Rect
&
aClipRect
const
EffectChain
&
aEffectChain
gfx
:
:
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfx
:
:
Rect
&
aVisibleRect
)
=
0
;
void
DrawQuad
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
Rect
&
aClipRect
const
EffectChain
&
aEffectChain
gfx
:
:
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
)
{
DrawQuad
(
aRect
aClipRect
aEffectChain
aOpacity
aTransform
aRect
)
;
}
void
SlowDrawRect
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
Color
&
color
const
gfx
:
:
Rect
&
aClipRect
=
gfx
:
:
Rect
(
)
const
gfx
:
:
Matrix4x4
&
aTransform
=
gfx
:
:
Matrix4x4
(
)
int
aStrokeWidth
=
1
)
;
void
FillRect
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
Color
&
color
const
gfx
:
:
Rect
&
aClipRect
=
gfx
:
:
Rect
(
)
const
gfx
:
:
Matrix4x4
&
aTransform
=
gfx
:
:
Matrix4x4
(
)
)
;
virtual
void
ClearRect
(
const
gfx
:
:
Rect
&
aRect
)
=
0
;
virtual
void
BeginFrame
(
const
nsIntRegion
&
aInvalidRegion
const
gfx
:
:
Rect
*
aClipRectIn
const
gfx
:
:
Rect
&
aRenderBounds
gfx
:
:
Rect
*
aClipRectOut
=
nullptr
gfx
:
:
Rect
*
aRenderBoundsOut
=
nullptr
)
=
0
;
virtual
void
EndFrame
(
)
=
0
;
virtual
void
SetDispAcquireFence
(
Layer
*
aLayer
nsIWidget
*
aWidget
)
;
virtual
FenceHandle
GetReleaseFence
(
)
;
virtual
void
EndFrameForExternalComposition
(
const
gfx
:
:
Matrix
&
aTransform
)
=
0
;
virtual
bool
SupportsPartialTextureUpdate
(
)
=
0
;
void
SetDiagnosticTypes
(
DiagnosticTypes
aDiagnostics
)
{
mDiagnosticTypes
=
aDiagnostics
;
}
DiagnosticTypes
GetDiagnosticTypes
(
)
const
{
return
mDiagnosticTypes
;
}
void
DrawDiagnostics
(
DiagnosticFlags
aFlags
const
gfx
:
:
Rect
&
visibleRect
const
gfx
:
:
Rect
&
aClipRect
const
gfx
:
:
Matrix4x4
&
transform
uint32_t
aFlashCounter
=
DIAGNOSTIC_FLASH_COUNTER_MAX
)
;
void
DrawDiagnostics
(
DiagnosticFlags
aFlags
const
nsIntRegion
&
visibleRegion
const
gfx
:
:
Rect
&
aClipRect
const
gfx
:
:
Matrix4x4
&
transform
uint32_t
aFlashCounter
=
DIAGNOSTIC_FLASH_COUNTER_MAX
)
;
#
ifdef
MOZ_DUMP_PAINTING
virtual
const
char
*
Name
(
)
const
=
0
;
#
endif
virtual
LayersBackend
GetBackendType
(
)
const
=
0
;
uint32_t
GetCompositorID
(
)
const
{
return
mCompositorID
;
}
void
SetCompositorID
(
uint32_t
aID
)
{
MOZ_ASSERT
(
mCompositorID
=
=
0
"
The
compositor
ID
must
be
set
only
once
.
"
)
;
mCompositorID
=
aID
;
}
virtual
void
Pause
(
)
{
}
virtual
bool
Resume
(
)
{
return
true
;
}
virtual
bool
Ready
(
)
{
return
true
;
}
virtual
nsIWidget
*
GetWidget
(
)
const
{
return
nullptr
;
}
virtual
bool
HasImageHostOverlays
(
)
{
return
false
;
}
virtual
void
AddImageHostOverlay
(
ImageHostOverlay
*
aOverlay
)
{
}
virtual
void
RemoveImageHostOverlay
(
ImageHostOverlay
*
aOverlay
)
{
}
static
void
AssertOnCompositorThread
(
)
;
size_t
GetFillRatio
(
)
{
float
fillRatio
=
0
;
if
(
mPixelsFilled
>
0
&
&
mPixelsPerFrame
>
0
)
{
fillRatio
=
100
.
0f
*
float
(
mPixelsFilled
)
/
float
(
mPixelsPerFrame
)
;
if
(
fillRatio
>
999
.
0f
)
{
fillRatio
=
999
.
0f
;
}
}
return
fillRatio
;
}
ScreenRotation
GetScreenRotation
(
)
const
{
return
mScreenRotation
;
}
void
SetScreenRotation
(
ScreenRotation
aRotation
)
{
mScreenRotation
=
aRotation
;
}
TimeStamp
GetCompositionTime
(
)
const
{
return
mCompositionTime
;
}
void
SetCompositionTime
(
TimeStamp
aTimeStamp
)
{
mCompositionTime
=
aTimeStamp
;
if
(
!
mCompositionTime
.
IsNull
(
)
&
&
!
mCompositeUntilTime
.
IsNull
(
)
&
&
mCompositionTime
>
=
mCompositeUntilTime
)
{
mCompositeUntilTime
=
TimeStamp
(
)
;
}
}
void
CompositeUntil
(
TimeStamp
aTimeStamp
)
{
if
(
mCompositeUntilTime
.
IsNull
(
)
|
|
mCompositeUntilTime
<
aTimeStamp
)
{
mCompositeUntilTime
=
aTimeStamp
;
}
}
TimeStamp
GetCompositeUntilTime
(
)
const
{
return
mCompositeUntilTime
;
}
protected
:
void
DrawDiagnosticsInternal
(
DiagnosticFlags
aFlags
const
gfx
:
:
Rect
&
aVisibleRect
const
gfx
:
:
Rect
&
aClipRect
const
gfx
:
:
Matrix4x4
&
transform
uint32_t
aFlashCounter
)
;
bool
ShouldDrawDiagnostics
(
DiagnosticFlags
)
;
gfx
:
:
IntRect
ComputeBackdropCopyRect
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
Rect
&
aClipRect
const
gfx
:
:
Matrix4x4
&
aTransform
)
;
TimeStamp
mCompositionTime
;
TimeStamp
mCompositeUntilTime
;
uint32_t
mCompositorID
;
DiagnosticTypes
mDiagnosticTypes
;
PCompositorParent
*
mParent
;
size_t
mPixelsPerFrame
;
size_t
mPixelsFilled
;
ScreenRotation
mScreenRotation
;
RefPtr
<
gfx
:
:
DrawTarget
>
mTarget
;
gfx
:
:
IntRect
mTargetBounds
;
#
if
defined
(
MOZ_WIDGET_GONK
)
&
&
ANDROID_VERSION
>
=
17
FenceHandle
mReleaseFenceHandle
;
#
endif
private
:
static
LayersBackend
sBackend
;
}
;
typedef
gfx
:
:
Rect
decomposedRectArrayT
[
4
]
;
size_t
DecomposeIntoNoRepeatRects
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
Rect
&
aTexCoordRect
decomposedRectArrayT
*
aLayerRects
decomposedRectArrayT
*
aTextureRects
)
;
static
inline
bool
BlendOpIsMixBlendMode
(
gfx
:
:
CompositionOp
aOp
)
{
switch
(
aOp
)
{
case
gfx
:
:
CompositionOp
:
:
OP_MULTIPLY
:
case
gfx
:
:
CompositionOp
:
:
OP_SCREEN
:
case
gfx
:
:
CompositionOp
:
:
OP_OVERLAY
:
case
gfx
:
:
CompositionOp
:
:
OP_DARKEN
:
case
gfx
:
:
CompositionOp
:
:
OP_LIGHTEN
:
case
gfx
:
:
CompositionOp
:
:
OP_COLOR_DODGE
:
case
gfx
:
:
CompositionOp
:
:
OP_COLOR_BURN
:
case
gfx
:
:
CompositionOp
:
:
OP_HARD_LIGHT
:
case
gfx
:
:
CompositionOp
:
:
OP_SOFT_LIGHT
:
case
gfx
:
:
CompositionOp
:
:
OP_DIFFERENCE
:
case
gfx
:
:
CompositionOp
:
:
OP_EXCLUSION
:
case
gfx
:
:
CompositionOp
:
:
OP_HUE
:
case
gfx
:
:
CompositionOp
:
:
OP_SATURATION
:
case
gfx
:
:
CompositionOp
:
:
OP_COLOR
:
case
gfx
:
:
CompositionOp
:
:
OP_LUMINOSITY
:
return
true
;
default
:
return
false
;
}
}
}
}
#
endif
