#
ifndef
MOZILLA_GFX_COMPOSITOR_H
#
define
MOZILLA_GFX_COMPOSITOR_H
#
include
"
Units
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
MatrixFwd
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Polygon
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
gfx
/
Triangle
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
widget
/
CompositorWidget
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRegion
.
h
"
#
include
<
vector
>
#
include
"
mozilla
/
WidgetUtils
.
h
"
class
nsIWidget
;
namespace
mozilla
{
namespace
gfx
{
class
Matrix
;
class
DrawTarget
;
class
DataSourceSurface
;
}
namespace
layers
{
struct
Effect
;
struct
EffectChain
;
class
Image
;
class
Layer
;
class
TextureSource
;
class
DataTextureSource
;
class
CompositingRenderTarget
;
class
CompositorBridgeParent
;
class
LayerManagerComposite
;
class
CompositorOGL
;
class
CompositorD3D9
;
class
CompositorD3D11
;
class
BasicCompositor
;
class
TextureHost
;
class
TextureReadLock
;
class
WebRenderCompositorOGL
;
enum
SurfaceInitMode
{
INIT_MODE_NONE
INIT_MODE_CLEAR
}
;
class
Compositor
{
protected
:
virtual
~
Compositor
(
)
;
public
:
NS_INLINE_DECL_REFCOUNTING
(
Compositor
)
explicit
Compositor
(
widget
:
:
CompositorWidget
*
aWidget
CompositorBridgeParent
*
aParent
=
nullptr
)
;
virtual
already_AddRefed
<
DataTextureSource
>
CreateDataTextureSource
(
TextureFlags
aFlags
=
TextureFlags
:
:
NO_FLAGS
)
=
0
;
virtual
already_AddRefed
<
DataTextureSource
>
CreateDataTextureSourceAround
(
gfx
:
:
DataSourceSurface
*
aSurface
)
{
return
nullptr
;
}
virtual
already_AddRefed
<
DataTextureSource
>
CreateDataTextureSourceAroundYCbCr
(
TextureHost
*
aTexture
)
{
return
nullptr
;
}
virtual
bool
Initialize
(
nsCString
*
const
out_failureReason
)
=
0
;
virtual
void
Destroy
(
)
;
bool
IsDestroyed
(
)
const
{
return
mIsDestroyed
;
}
virtual
void
DetachWidget
(
)
{
mWidget
=
nullptr
;
}
virtual
bool
SupportsEffect
(
EffectTypes
aEffect
)
{
return
true
;
}
virtual
TextureFactoryIdentifier
GetTextureFactoryIdentifier
(
)
=
0
;
virtual
bool
CanUseCanvasLayerForSize
(
const
gfx
:
:
IntSize
&
aSize
)
=
0
;
virtual
int32_t
GetMaxTextureSize
(
)
const
=
0
;
void
SetTargetContext
(
gfx
:
:
DrawTarget
*
aTarget
const
gfx
:
:
IntRect
&
aRect
)
{
mTarget
=
aTarget
;
mTargetBounds
=
aRect
;
}
gfx
:
:
DrawTarget
*
GetTargetContext
(
)
const
{
return
mTarget
;
}
void
ClearTargetContext
(
)
{
mTarget
=
nullptr
;
}
typedef
uint32_t
MakeCurrentFlags
;
static
const
MakeCurrentFlags
ForceMakeCurrent
=
0x1
;
virtual
void
MakeCurrent
(
MakeCurrentFlags
aFlags
=
0
)
=
0
;
virtual
already_AddRefed
<
CompositingRenderTarget
>
CreateRenderTarget
(
const
gfx
:
:
IntRect
&
aRect
SurfaceInitMode
aInit
)
=
0
;
virtual
already_AddRefed
<
CompositingRenderTarget
>
CreateRenderTargetFromSource
(
const
gfx
:
:
IntRect
&
aRect
const
CompositingRenderTarget
*
aSource
const
gfx
:
:
IntPoint
&
aSourcePoint
)
=
0
;
virtual
void
SetRenderTarget
(
CompositingRenderTarget
*
aSurface
)
=
0
;
virtual
CompositingRenderTarget
*
GetCurrentRenderTarget
(
)
const
=
0
;
virtual
void
SetDestinationSurfaceSize
(
const
gfx
:
:
IntSize
&
aSize
)
=
0
;
virtual
void
SetScreenRenderOffset
(
const
ScreenPoint
&
aOffset
)
=
0
;
void
DrawGeometry
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
IntRect
&
aClipRect
const
EffectChain
&
aEffectChain
gfx
:
:
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfx
:
:
Rect
&
aVisibleRect
const
Maybe
<
gfx
:
:
Polygon3D
>
&
aGeometry
)
;
void
DrawGeometry
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
IntRect
&
aClipRect
const
EffectChain
&
aEffectChain
gfx
:
:
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
Maybe
<
gfx
:
:
Polygon3D
>
&
aGeometry
)
{
DrawGeometry
(
aRect
aClipRect
aEffectChain
aOpacity
aTransform
aRect
aGeometry
)
;
}
virtual
void
DrawQuad
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
IntRect
&
aClipRect
const
EffectChain
&
aEffectChain
gfx
:
:
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfx
:
:
Rect
&
aVisibleRect
)
=
0
;
void
DrawQuad
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
IntRect
&
aClipRect
const
EffectChain
&
aEffectChain
gfx
:
:
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
)
{
DrawQuad
(
aRect
aClipRect
aEffectChain
aOpacity
aTransform
aRect
)
;
}
virtual
void
DrawTriangle
(
const
gfx
:
:
TexturedTriangle
&
aTriangle
const
gfx
:
:
IntRect
&
aClipRect
const
EffectChain
&
aEffectChain
gfx
:
:
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfx
:
:
Rect
&
aVisibleRect
)
{
MOZ_CRASH
(
"
Compositor
:
:
DrawTriangle
is
not
implemented
for
the
current
platform
!
"
)
;
}
void
SlowDrawRect
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
Color
&
color
const
gfx
:
:
IntRect
&
aClipRect
=
gfx
:
:
IntRect
(
)
const
gfx
:
:
Matrix4x4
&
aTransform
=
gfx
:
:
Matrix4x4
(
)
int
aStrokeWidth
=
1
)
;
void
FillRect
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
Color
&
color
const
gfx
:
:
IntRect
&
aClipRect
=
gfx
:
:
IntRect
(
)
const
gfx
:
:
Matrix4x4
&
aTransform
=
gfx
:
:
Matrix4x4
(
)
)
;
void
SetClearColor
(
const
gfx
:
:
Color
&
aColor
)
{
mClearColor
=
aColor
;
}
void
SetDefaultClearColor
(
const
gfx
:
:
Color
&
aColor
)
{
mDefaultClearColor
=
aColor
;
}
void
SetClearColorToDefault
(
)
{
mClearColor
=
mDefaultClearColor
;
}
virtual
void
ClearRect
(
const
gfx
:
:
Rect
&
aRect
)
=
0
;
virtual
void
BeginFrame
(
const
nsIntRegion
&
aInvalidRegion
const
gfx
:
:
IntRect
*
aClipRectIn
const
gfx
:
:
IntRect
&
aRenderBounds
const
nsIntRegion
&
aOpaqueRegion
gfx
:
:
IntRect
*
aClipRectOut
=
nullptr
gfx
:
:
IntRect
*
aRenderBoundsOut
=
nullptr
)
=
0
;
virtual
void
EndFrame
(
)
;
virtual
void
CancelFrame
(
)
{
ReadUnlockTextures
(
)
;
}
virtual
void
SetDispAcquireFence
(
Layer
*
aLayer
)
;
virtual
bool
SupportsPartialTextureUpdate
(
)
=
0
;
void
SetDiagnosticTypes
(
DiagnosticTypes
aDiagnostics
)
{
mDiagnosticTypes
=
aDiagnostics
;
}
DiagnosticTypes
GetDiagnosticTypes
(
)
const
{
return
mDiagnosticTypes
;
}
void
DrawDiagnostics
(
DiagnosticFlags
aFlags
const
gfx
:
:
Rect
&
visibleRect
const
gfx
:
:
IntRect
&
aClipRect
const
gfx
:
:
Matrix4x4
&
transform
uint32_t
aFlashCounter
=
DIAGNOSTIC_FLASH_COUNTER_MAX
)
;
void
DrawDiagnostics
(
DiagnosticFlags
aFlags
const
nsIntRegion
&
visibleRegion
const
gfx
:
:
IntRect
&
aClipRect
const
gfx
:
:
Matrix4x4
&
transform
uint32_t
aFlashCounter
=
DIAGNOSTIC_FLASH_COUNTER_MAX
)
;
#
ifdef
MOZ_DUMP_PAINTING
virtual
const
char
*
Name
(
)
const
=
0
;
#
endif
virtual
LayersBackend
GetBackendType
(
)
const
=
0
;
virtual
CompositorOGL
*
AsCompositorOGL
(
)
{
return
nullptr
;
}
virtual
CompositorD3D9
*
AsCompositorD3D9
(
)
{
return
nullptr
;
}
virtual
CompositorD3D11
*
AsCompositorD3D11
(
)
{
return
nullptr
;
}
virtual
BasicCompositor
*
AsBasicCompositor
(
)
{
return
nullptr
;
}
virtual
WebRenderCompositorOGL
*
AsWebRenderCompositorOGL
(
)
{
return
nullptr
;
}
uint32_t
GetCompositorID
(
)
const
{
return
mCompositorID
;
}
void
SetCompositorID
(
uint32_t
aID
)
{
MOZ_ASSERT
(
mCompositorID
=
=
0
"
The
compositor
ID
must
be
set
only
once
.
"
)
;
mCompositorID
=
aID
;
}
virtual
void
Pause
(
)
{
}
virtual
bool
Resume
(
)
{
return
true
;
}
virtual
bool
Ready
(
)
{
return
true
;
}
virtual
void
ForcePresent
(
)
{
}
virtual
bool
IsPendingComposite
(
)
{
return
false
;
}
virtual
void
FinishPendingComposite
(
)
{
}
widget
:
:
CompositorWidget
*
GetWidget
(
)
const
{
return
mWidget
;
}
static
void
AssertOnCompositorThread
(
)
;
size_t
GetFillRatio
(
)
{
float
fillRatio
=
0
;
if
(
mPixelsFilled
>
0
&
&
mPixelsPerFrame
>
0
)
{
fillRatio
=
100
.
0f
*
float
(
mPixelsFilled
)
/
float
(
mPixelsPerFrame
)
;
if
(
fillRatio
>
999
.
0f
)
{
fillRatio
=
999
.
0f
;
}
}
return
fillRatio
;
}
ScreenRotation
GetScreenRotation
(
)
const
{
return
mScreenRotation
;
}
void
SetScreenRotation
(
ScreenRotation
aRotation
)
{
mScreenRotation
=
aRotation
;
}
TimeStamp
GetCompositionTime
(
)
const
{
return
mCompositionTime
;
}
void
SetCompositionTime
(
TimeStamp
aTimeStamp
)
{
mCompositionTime
=
aTimeStamp
;
if
(
!
mCompositionTime
.
IsNull
(
)
&
&
!
mCompositeUntilTime
.
IsNull
(
)
&
&
mCompositionTime
>
=
mCompositeUntilTime
)
{
mCompositeUntilTime
=
TimeStamp
(
)
;
}
}
virtual
void
CompositeUntil
(
TimeStamp
aTimeStamp
)
{
if
(
mCompositeUntilTime
.
IsNull
(
)
|
|
mCompositeUntilTime
<
aTimeStamp
)
{
mCompositeUntilTime
=
aTimeStamp
;
}
}
TimeStamp
GetCompositeUntilTime
(
)
const
{
return
mCompositeUntilTime
;
}
void
SetInvalid
(
)
;
virtual
bool
IsValid
(
)
const
;
CompositorBridgeParent
*
GetCompositorBridgeParent
(
)
const
{
return
mParent
;
}
void
UnlockAfterComposition
(
TextureHost
*
aTexture
)
;
void
NotifyNotUsedAfterComposition
(
TextureHost
*
aTextureHost
)
;
void
FlushPendingNotifyNotUsed
(
)
;
protected
:
void
DrawDiagnosticsInternal
(
DiagnosticFlags
aFlags
const
gfx
:
:
Rect
&
aVisibleRect
const
gfx
:
:
IntRect
&
aClipRect
const
gfx
:
:
Matrix4x4
&
transform
uint32_t
aFlashCounter
)
;
bool
ShouldDrawDiagnostics
(
DiagnosticFlags
)
;
void
ReadUnlockTextures
(
)
;
gfx
:
:
IntRect
ComputeBackdropCopyRect
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
IntRect
&
aClipRect
const
gfx
:
:
Matrix4x4
&
aTransform
gfx
:
:
Matrix4x4
*
aOutTransform
gfx
:
:
Rect
*
aOutLayerQuad
=
nullptr
)
;
gfx
:
:
IntRect
ComputeBackdropCopyRect
(
const
gfx
:
:
Triangle
&
aTriangle
const
gfx
:
:
IntRect
&
aClipRect
const
gfx
:
:
Matrix4x4
&
aTransform
gfx
:
:
Matrix4x4
*
aOutTransform
gfx
:
:
Rect
*
aOutLayerQuad
=
nullptr
)
;
nsTArray
<
RefPtr
<
TextureHost
>
>
mUnlockAfterComposition
;
nsTArray
<
RefPtr
<
TextureHost
>
>
mNotifyNotUsedAfterComposition
;
TimeStamp
mLastCompositionEndTime
;
TimeStamp
mCompositionTime
;
TimeStamp
mCompositeUntilTime
;
uint32_t
mCompositorID
;
DiagnosticTypes
mDiagnosticTypes
;
CompositorBridgeParent
*
mParent
;
size_t
mPixelsPerFrame
;
size_t
mPixelsFilled
;
ScreenRotation
mScreenRotation
;
RefPtr
<
gfx
:
:
DrawTarget
>
mTarget
;
gfx
:
:
IntRect
mTargetBounds
;
widget
:
:
CompositorWidget
*
mWidget
;
bool
mIsDestroyed
;
gfx
:
:
Color
mClearColor
;
gfx
:
:
Color
mDefaultClearColor
;
private
:
static
LayersBackend
sBackend
;
}
;
typedef
gfx
:
:
Rect
decomposedRectArrayT
[
4
]
;
size_t
DecomposeIntoNoRepeatRects
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
Rect
&
aTexCoordRect
decomposedRectArrayT
*
aLayerRects
decomposedRectArrayT
*
aTextureRects
)
;
static
inline
bool
BlendOpIsMixBlendMode
(
gfx
:
:
CompositionOp
aOp
)
{
switch
(
aOp
)
{
case
gfx
:
:
CompositionOp
:
:
OP_MULTIPLY
:
case
gfx
:
:
CompositionOp
:
:
OP_SCREEN
:
case
gfx
:
:
CompositionOp
:
:
OP_OVERLAY
:
case
gfx
:
:
CompositionOp
:
:
OP_DARKEN
:
case
gfx
:
:
CompositionOp
:
:
OP_LIGHTEN
:
case
gfx
:
:
CompositionOp
:
:
OP_COLOR_DODGE
:
case
gfx
:
:
CompositionOp
:
:
OP_COLOR_BURN
:
case
gfx
:
:
CompositionOp
:
:
OP_HARD_LIGHT
:
case
gfx
:
:
CompositionOp
:
:
OP_SOFT_LIGHT
:
case
gfx
:
:
CompositionOp
:
:
OP_DIFFERENCE
:
case
gfx
:
:
CompositionOp
:
:
OP_EXCLUSION
:
case
gfx
:
:
CompositionOp
:
:
OP_HUE
:
case
gfx
:
:
CompositionOp
:
:
OP_SATURATION
:
case
gfx
:
:
CompositionOp
:
:
OP_COLOR
:
case
gfx
:
:
CompositionOp
:
:
OP_LUMINOSITY
:
return
true
;
default
:
return
false
;
}
}
}
}
#
endif
