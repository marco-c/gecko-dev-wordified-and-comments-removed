#
ifndef
MOZILLA_GFX_COMPOSITOR_H
#
define
MOZILLA_GFX_COMPOSITOR_H
#
include
"
Units
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
MatrixFwd
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Polygon
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
gfx
/
Triangle
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
SurfacePool
.
h
"
#
include
"
mozilla
/
layers
/
TextureSourceProvider
.
h
"
#
include
"
mozilla
/
widget
/
CompositorWidget
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRegion
.
h
"
#
include
<
vector
>
#
include
"
mozilla
/
WidgetUtils
.
h
"
class
nsIWidget
;
namespace
mozilla
{
namespace
gfx
{
class
DrawTarget
;
class
DataSourceSurface
;
}
namespace
layers
{
struct
Effect
;
struct
EffectChain
;
class
Image
;
class
Layer
;
class
TextureSource
;
class
DataTextureSource
;
class
CompositingRenderTarget
;
class
CompositorBridgeParent
;
class
NativeLayer
;
class
CompositorOGL
;
class
CompositorD3D11
;
class
BasicCompositor
;
class
TextureReadLock
;
struct
GPUStats
;
class
AsyncReadbackBuffer
;
class
RecordedFrame
;
enum
SurfaceInitMode
{
INIT_MODE_NONE
INIT_MODE_CLEAR
}
;
class
Compositor
:
public
TextureSourceProvider
{
protected
:
virtual
~
Compositor
(
)
;
public
:
explicit
Compositor
(
widget
:
:
CompositorWidget
*
aWidget
CompositorBridgeParent
*
aParent
=
nullptr
)
;
virtual
bool
Initialize
(
nsCString
*
const
out_failureReason
)
=
0
;
void
Destroy
(
)
override
;
bool
IsDestroyed
(
)
const
{
return
mIsDestroyed
;
}
virtual
TextureFactoryIdentifier
GetTextureFactoryIdentifier
(
)
=
0
;
virtual
bool
CanUseCanvasLayerForSize
(
const
gfx
:
:
IntSize
&
aSize
)
=
0
;
typedef
uint32_t
MakeCurrentFlags
;
static
const
MakeCurrentFlags
ForceMakeCurrent
=
0x1
;
virtual
void
MakeCurrent
(
MakeCurrentFlags
aFlags
=
0
)
=
0
;
virtual
already_AddRefed
<
CompositingRenderTarget
>
CreateRenderTarget
(
const
gfx
:
:
IntRect
&
aRect
SurfaceInitMode
aInit
)
=
0
;
virtual
already_AddRefed
<
CompositingRenderTarget
>
CreateRenderTargetFromSource
(
const
gfx
:
:
IntRect
&
aRect
const
CompositingRenderTarget
*
aSource
const
gfx
:
:
IntPoint
&
aSourcePoint
)
=
0
;
virtual
bool
ReadbackRenderTarget
(
CompositingRenderTarget
*
aSource
AsyncReadbackBuffer
*
aDest
)
{
return
false
;
}
virtual
already_AddRefed
<
AsyncReadbackBuffer
>
CreateAsyncReadbackBuffer
(
const
gfx
:
:
IntSize
&
aSize
)
{
return
nullptr
;
}
virtual
bool
BlitRenderTarget
(
CompositingRenderTarget
*
aSource
const
gfx
:
:
IntSize
&
aSourceSize
const
gfx
:
:
IntSize
&
aDestSize
)
{
return
false
;
}
virtual
void
SetRenderTarget
(
CompositingRenderTarget
*
aSurface
)
=
0
;
virtual
already_AddRefed
<
CompositingRenderTarget
>
GetCurrentRenderTarget
(
)
const
=
0
;
virtual
already_AddRefed
<
CompositingRenderTarget
>
GetWindowRenderTarget
(
)
const
{
return
nullptr
;
}
virtual
void
SetDestinationSurfaceSize
(
const
gfx
:
:
IntSize
&
aSize
)
=
0
;
void
DrawGeometry
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
IntRect
&
aClipRect
const
EffectChain
&
aEffectChain
gfx
:
:
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfx
:
:
Rect
&
aVisibleRect
const
Maybe
<
gfx
:
:
Polygon
>
&
aGeometry
)
;
void
DrawGeometry
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
IntRect
&
aClipRect
const
EffectChain
&
aEffectChain
gfx
:
:
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
Maybe
<
gfx
:
:
Polygon
>
&
aGeometry
)
{
DrawGeometry
(
aRect
aClipRect
aEffectChain
aOpacity
aTransform
aRect
aGeometry
)
;
}
virtual
void
DrawQuad
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
IntRect
&
aClipRect
const
EffectChain
&
aEffectChain
gfx
:
:
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfx
:
:
Rect
&
aVisibleRect
)
=
0
;
void
DrawQuad
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
IntRect
&
aClipRect
const
EffectChain
&
aEffectChain
gfx
:
:
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
)
{
DrawQuad
(
aRect
aClipRect
aEffectChain
aOpacity
aTransform
aRect
)
;
}
virtual
void
DrawTriangle
(
const
gfx
:
:
TexturedTriangle
&
aTriangle
const
gfx
:
:
IntRect
&
aClipRect
const
EffectChain
&
aEffectChain
gfx
:
:
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfx
:
:
Rect
&
aVisibleRect
)
{
MOZ_CRASH
(
"
Compositor
:
:
DrawTriangle
is
not
implemented
for
the
current
"
"
platform
!
"
)
;
}
virtual
bool
SupportsLayerGeometry
(
)
const
{
return
false
;
}
void
SlowDrawRect
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
DeviceColor
&
color
const
gfx
:
:
IntRect
&
aClipRect
=
gfx
:
:
IntRect
(
)
const
gfx
:
:
Matrix4x4
&
aTransform
=
gfx
:
:
Matrix4x4
(
)
int
aStrokeWidth
=
1
)
;
void
FillRect
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
DeviceColor
&
color
const
gfx
:
:
IntRect
&
aClipRect
=
gfx
:
:
IntRect
(
)
const
gfx
:
:
Matrix4x4
&
aTransform
=
gfx
:
:
Matrix4x4
(
)
)
;
void
SetClearColor
(
const
gfx
:
:
DeviceColor
&
aColor
)
{
mClearColor
=
aColor
;
}
void
SetDefaultClearColor
(
const
gfx
:
:
DeviceColor
&
aColor
)
{
mDefaultClearColor
=
aColor
;
}
void
SetClearColorToDefault
(
)
{
mClearColor
=
mDefaultClearColor
;
}
virtual
void
ClearRect
(
const
gfx
:
:
Rect
&
aRect
)
=
0
;
virtual
Maybe
<
gfx
:
:
IntRect
>
BeginFrameForWindow
(
const
nsIntRegion
&
aInvalidRegion
const
Maybe
<
gfx
:
:
IntRect
>
&
aClipRect
const
gfx
:
:
IntRect
&
aRenderBounds
const
nsIntRegion
&
aOpaqueRegion
)
=
0
;
virtual
Maybe
<
gfx
:
:
IntRect
>
BeginFrameForTarget
(
const
nsIntRegion
&
aInvalidRegion
const
Maybe
<
gfx
:
:
IntRect
>
&
aClipRect
const
gfx
:
:
IntRect
&
aRenderBounds
const
nsIntRegion
&
aOpaqueRegion
gfx
:
:
DrawTarget
*
aTarget
const
gfx
:
:
IntRect
&
aTargetBounds
)
=
0
;
virtual
void
BeginFrameForNativeLayers
(
)
=
0
;
virtual
Maybe
<
gfx
:
:
IntRect
>
BeginRenderingToNativeLayer
(
const
nsIntRegion
&
aInvalidRegion
const
Maybe
<
gfx
:
:
IntRect
>
&
aClipRect
const
nsIntRegion
&
aOpaqueRegion
NativeLayer
*
aNativeLayer
)
=
0
;
virtual
void
EndRenderingToNativeLayer
(
)
=
0
;
virtual
void
NormalDrawingDone
(
)
{
}
virtual
void
EndFrame
(
)
;
virtual
void
CancelFrame
(
bool
aNeedFlush
=
true
)
{
ReadUnlockTextures
(
)
;
}
virtual
void
WaitForGPU
(
)
{
}
virtual
RefPtr
<
SurfacePoolHandle
>
GetSurfacePoolHandle
(
)
{
return
nullptr
;
}
virtual
bool
SupportsPartialTextureUpdate
(
)
=
0
;
#
ifdef
MOZ_DUMP_PAINTING
virtual
const
char
*
Name
(
)
const
=
0
;
#
endif
virtual
LayersBackend
GetBackendType
(
)
const
=
0
;
virtual
CompositorD3D11
*
AsCompositorD3D11
(
)
{
return
nullptr
;
}
Compositor
*
AsCompositor
(
)
override
{
return
this
;
}
TimeStamp
GetLastCompositionEndTime
(
)
const
override
{
return
mLastCompositionEndTime
;
}
void
UnlockAfterComposition
(
TextureHost
*
aTexture
)
override
;
bool
NotifyNotUsedAfterComposition
(
TextureHost
*
aTextureHost
)
override
;
virtual
void
Pause
(
)
{
}
virtual
bool
Resume
(
)
{
return
true
;
}
virtual
bool
Ready
(
)
{
return
true
;
}
virtual
void
ForcePresent
(
)
{
}
virtual
bool
IsPendingComposite
(
)
{
return
false
;
}
virtual
void
FinishPendingComposite
(
)
{
}
widget
:
:
CompositorWidget
*
GetWidget
(
)
const
{
return
mWidget
;
}
virtual
void
GetFrameStats
(
GPUStats
*
aStats
)
;
ScreenRotation
GetScreenRotation
(
)
const
{
return
mScreenRotation
;
}
void
SetScreenRotation
(
ScreenRotation
aRotation
)
{
mScreenRotation
=
aRotation
;
}
void
SetInvalid
(
)
;
bool
IsValid
(
)
const
override
;
CompositorBridgeParent
*
GetCompositorBridgeParent
(
)
const
{
return
mParent
;
}
virtual
void
RequestAllowFrameRecording
(
bool
aWillRecord
)
{
mRecordFrames
=
aWillRecord
;
}
already_AddRefed
<
RecordedFrame
>
RecordFrame
(
const
TimeStamp
&
aTimeStamp
)
;
protected
:
gfx
:
:
IntRect
ComputeBackdropCopyRect
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
IntRect
&
aClipRect
const
gfx
:
:
Matrix4x4
&
aTransform
gfx
:
:
Matrix4x4
*
aOutTransform
gfx
:
:
Rect
*
aOutLayerQuad
=
nullptr
)
;
gfx
:
:
IntRect
ComputeBackdropCopyRect
(
const
gfx
:
:
Triangle
&
aTriangle
const
gfx
:
:
IntRect
&
aClipRect
const
gfx
:
:
Matrix4x4
&
aTransform
gfx
:
:
Matrix4x4
*
aOutTransform
gfx
:
:
Rect
*
aOutLayerQuad
=
nullptr
)
;
virtual
void
DrawTriangles
(
const
nsTArray
<
gfx
:
:
TexturedTriangle
>
&
aTriangles
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
IntRect
&
aClipRect
const
EffectChain
&
aEffectChain
gfx
:
:
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfx
:
:
Rect
&
aVisibleRect
)
;
virtual
void
DrawPolygon
(
const
gfx
:
:
Polygon
&
aPolygon
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
IntRect
&
aClipRect
const
EffectChain
&
aEffectChain
gfx
:
:
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfx
:
:
Rect
&
aVisibleRect
)
;
bool
ShouldRecordFrames
(
)
const
;
TimeStamp
mLastCompositionEndTime
;
CompositorBridgeParent
*
mParent
;
size_t
mPixelsPerFrame
;
size_t
mPixelsFilled
;
ScreenRotation
mScreenRotation
;
widget
:
:
CompositorWidget
*
mWidget
;
bool
mIsDestroyed
;
gfx
:
:
DeviceColor
mClearColor
;
gfx
:
:
DeviceColor
mDefaultClearColor
;
bool
mRecordFrames
=
false
;
private
:
static
LayersBackend
sBackend
;
}
;
typedef
gfx
:
:
Rect
decomposedRectArrayT
[
4
]
;
size_t
DecomposeIntoNoRepeatRects
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
Rect
&
aTexCoordRect
decomposedRectArrayT
*
aLayerRects
decomposedRectArrayT
*
aTextureRects
)
;
static
inline
bool
BlendOpIsMixBlendMode
(
gfx
:
:
CompositionOp
aOp
)
{
switch
(
aOp
)
{
case
gfx
:
:
CompositionOp
:
:
OP_MULTIPLY
:
case
gfx
:
:
CompositionOp
:
:
OP_SCREEN
:
case
gfx
:
:
CompositionOp
:
:
OP_OVERLAY
:
case
gfx
:
:
CompositionOp
:
:
OP_DARKEN
:
case
gfx
:
:
CompositionOp
:
:
OP_LIGHTEN
:
case
gfx
:
:
CompositionOp
:
:
OP_COLOR_DODGE
:
case
gfx
:
:
CompositionOp
:
:
OP_COLOR_BURN
:
case
gfx
:
:
CompositionOp
:
:
OP_HARD_LIGHT
:
case
gfx
:
:
CompositionOp
:
:
OP_SOFT_LIGHT
:
case
gfx
:
:
CompositionOp
:
:
OP_DIFFERENCE
:
case
gfx
:
:
CompositionOp
:
:
OP_EXCLUSION
:
case
gfx
:
:
CompositionOp
:
:
OP_HUE
:
case
gfx
:
:
CompositionOp
:
:
OP_SATURATION
:
case
gfx
:
:
CompositionOp
:
:
OP_COLOR
:
case
gfx
:
:
CompositionOp
:
:
OP_LUMINOSITY
:
return
true
;
default
:
return
false
;
}
}
class
AsyncReadbackBuffer
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
AsyncReadbackBuffer
)
gfx
:
:
IntSize
GetSize
(
)
const
{
return
mSize
;
}
virtual
bool
MapAndCopyInto
(
gfx
:
:
DataSourceSurface
*
aSurface
const
gfx
:
:
IntSize
&
aReadSize
)
const
=
0
;
protected
:
explicit
AsyncReadbackBuffer
(
const
gfx
:
:
IntSize
&
aSize
)
:
mSize
(
aSize
)
{
}
virtual
~
AsyncReadbackBuffer
(
)
=
default
;
gfx
:
:
IntSize
mSize
;
}
;
struct
TexturedVertex
{
float
position
[
2
]
;
float
texCoords
[
2
]
;
}
;
nsTArray
<
TexturedVertex
>
TexturedTrianglesToVertexArray
(
const
nsTArray
<
gfx
:
:
TexturedTriangle
>
&
aTriangles
)
;
}
}
#
endif
