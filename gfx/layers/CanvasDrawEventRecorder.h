#
ifndef
mozilla_layers_CanvasDrawEventRecorder_h
#
define
mozilla_layers_CanvasDrawEventRecorder_h
#
include
"
mozilla
/
gfx
/
DrawEventRecorder
.
h
"
#
include
"
mozilla
/
ipc
/
CrossProcessSemaphore
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemoryBasic
.
h
"
namespace
mozilla
{
namespace
layers
{
class
CanvasEventRingBuffer
final
:
public
gfx
:
:
EventRingBuffer
{
public
:
CanvasEventRingBuffer
(
)
{
}
bool
InitWriter
(
base
:
:
ProcessId
aOtherPid
ipc
:
:
SharedMemoryBasic
:
:
Handle
*
aReadHandle
CrossProcessSemaphoreHandle
*
aReaderSem
CrossProcessSemaphoreHandle
*
aWriterSem
const
std
:
:
function
<
void
(
)
>
&
aResumeReaderCallback
)
;
bool
InitReader
(
const
ipc
:
:
SharedMemoryBasic
:
:
Handle
&
aReadHandle
const
CrossProcessSemaphoreHandle
&
aReaderSem
const
CrossProcessSemaphoreHandle
&
aWriterSem
)
;
bool
good
(
)
const
final
{
return
mGood
;
}
void
write
(
const
char
*
const
aData
const
size_t
aSize
)
final
;
bool
HasDataToRead
(
)
;
bool
StopIfEmpty
(
)
;
bool
WaitForDataToRead
(
TimeDuration
aTimeout
)
;
int32_t
ReadNextEvent
(
)
;
void
read
(
char
*
const
aOut
const
size_t
aSize
)
final
;
uint32_t
CreateCheckpoint
(
)
;
bool
WaitForCheckpoint
(
uint32_t
aCheckpoint
TimeDuration
aTimeout
)
;
void
ReturnWrite
(
const
char
*
aData
size_t
aSize
)
;
void
ReturnRead
(
char
*
aOut
size_t
aSize
)
;
protected
:
bool
WaitForAndRecalculateAvailableSpace
(
)
final
;
void
UpdateWriteTotalsBy
(
uint32_t
aCount
)
final
;
private
:
enum
class
State
:
uint32_t
{
Processing
AboutToWait
Waiting
Stopped
}
;
struct
ReadFooter
{
Atomic
<
uint32_t
ReleaseAcquire
>
count
;
Atomic
<
uint32_t
ReleaseAcquire
>
returnCount
;
Atomic
<
State
ReleaseAcquire
>
state
;
}
;
struct
WriteFooter
{
Atomic
<
uint32_t
ReleaseAcquire
>
count
;
Atomic
<
uint32_t
ReleaseAcquire
>
returnCount
;
Atomic
<
uint32_t
ReleaseAcquire
>
requiredDifference
;
Atomic
<
State
ReleaseAcquire
>
state
;
}
;
CanvasEventRingBuffer
(
const
CanvasEventRingBuffer
&
)
=
delete
;
void
operator
=
(
const
CanvasEventRingBuffer
&
)
=
delete
;
void
IncrementWriteCountBy
(
uint32_t
aCount
)
;
bool
WaitForReadCount
(
uint32_t
aReadCount
TimeDuration
aTimeout
)
;
bool
WaitForAndRecalculateAvailableData
(
)
;
void
UpdateReadTotalsBy
(
uint32_t
aCount
)
;
void
IncrementReadCountBy
(
uint32_t
aCount
)
;
void
CheckAndSignalReader
(
)
;
void
CheckAndSignalWriter
(
)
;
uint32_t
WaitForBytesToWrite
(
)
;
uint32_t
WaitForBytesToRead
(
)
;
RefPtr
<
ipc
:
:
SharedMemoryBasic
>
mSharedMemory
;
UniquePtr
<
CrossProcessSemaphore
>
mReaderSemaphore
;
UniquePtr
<
CrossProcessSemaphore
>
mWriterSemaphore
;
std
:
:
function
<
void
(
)
>
mResumeReaderCallback
;
char
*
mBuf
=
nullptr
;
uint32_t
mOurCount
=
0
;
WriteFooter
*
mWrite
=
nullptr
;
ReadFooter
*
mRead
=
nullptr
;
bool
mGood
=
false
;
}
;
class
CanvasDrawEventRecorder
final
:
public
gfx
:
:
DrawEventRecorderPrivate
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
CanvasDrawEventRecorder
final
)
explicit
CanvasDrawEventRecorder
(
)
{
}
;
bool
Init
(
base
:
:
ProcessId
aOtherPid
ipc
:
:
SharedMemoryBasic
:
:
Handle
*
aHandle
CrossProcessSemaphoreHandle
*
aReaderSem
CrossProcessSemaphoreHandle
*
aWriterSem
const
std
:
:
function
<
void
(
)
>
&
aResumeReaderCallback
)
{
return
mOutputStream
.
InitWriter
(
aOtherPid
aHandle
aReaderSem
aWriterSem
aResumeReaderCallback
)
;
}
void
RecordEvent
(
const
gfx
:
:
RecordedEvent
&
aEvent
)
final
{
if
(
!
mOutputStream
.
good
(
)
)
{
return
;
}
aEvent
.
RecordToStream
(
mOutputStream
)
;
}
void
Flush
(
)
final
{
}
void
ReturnRead
(
char
*
aOut
size_t
aSize
)
{
mOutputStream
.
ReturnRead
(
aOut
aSize
)
;
}
uint32_t
CreateCheckpoint
(
)
{
return
mOutputStream
.
CreateCheckpoint
(
)
;
}
bool
WaitForCheckpoint
(
uint32_t
aCheckpoint
TimeDuration
aTimeout
)
{
return
mOutputStream
.
WaitForCheckpoint
(
aCheckpoint
aTimeout
)
;
}
private
:
CanvasEventRingBuffer
mOutputStream
;
}
;
}
}
#
endif
