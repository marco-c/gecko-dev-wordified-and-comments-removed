#
ifndef
mozilla_layers_CanvasDrawEventRecorder_h
#
define
mozilla_layers_CanvasDrawEventRecorder_h
#
include
"
mozilla
/
gfx
/
DrawEventRecorder
.
h
"
#
include
"
mozilla
/
ipc
/
CrossProcessSemaphore
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemoryBasic
.
h
"
namespace
mozilla
{
namespace
layers
{
static
const
uint8_t
kCheckpointEventType
=
-
1
;
static
const
uint8_t
kDropBufferEventType
=
-
2
;
class
CanvasEventRingBuffer
final
:
public
gfx
:
:
EventRingBuffer
{
public
:
class
WriterServices
{
public
:
virtual
~
WriterServices
(
)
=
default
;
virtual
bool
ReaderClosed
(
)
=
0
;
virtual
void
ResumeReader
(
)
=
0
;
}
;
class
ReaderServices
{
public
:
virtual
~
ReaderServices
(
)
=
default
;
virtual
bool
WriterClosed
(
)
=
0
;
}
;
CanvasEventRingBuffer
(
)
{
}
bool
InitBuffer
(
base
:
:
ProcessId
aOtherPid
ipc
:
:
SharedMemoryBasic
:
:
Handle
*
aReadHandle
)
;
bool
InitWriter
(
base
:
:
ProcessId
aOtherPid
ipc
:
:
SharedMemoryBasic
:
:
Handle
*
aReadHandle
CrossProcessSemaphoreHandle
*
aReaderSem
CrossProcessSemaphoreHandle
*
aWriterSem
UniquePtr
<
WriterServices
>
aWriterServices
)
;
bool
InitReader
(
ipc
:
:
SharedMemoryBasic
:
:
Handle
aReadHandle
CrossProcessSemaphoreHandle
aReaderSem
CrossProcessSemaphoreHandle
aWriterSem
UniquePtr
<
ReaderServices
>
aReaderServices
)
;
bool
SetNewBuffer
(
ipc
:
:
SharedMemoryBasic
:
:
Handle
aReadHandle
)
;
bool
IsValid
(
)
const
{
return
mSharedMemory
;
}
bool
good
(
)
const
final
{
return
mGood
;
}
bool
WriterFailed
(
)
const
{
return
mWrite
&
&
mWrite
-
>
state
=
=
State
:
:
Failed
;
}
void
SetIsBad
(
)
final
{
mGood
=
false
;
mRead
-
>
state
=
State
:
:
Failed
;
}
void
write
(
const
char
*
const
aData
const
size_t
aSize
)
final
;
bool
HasDataToRead
(
)
;
bool
StopIfEmpty
(
)
;
bool
WaitForDataToRead
(
TimeDuration
aTimeout
int32_t
aRetryCount
)
;
uint8_t
ReadNextEvent
(
)
;
void
read
(
char
*
const
aOut
const
size_t
aSize
)
final
;
uint32_t
CreateCheckpoint
(
)
;
bool
WaitForCheckpoint
(
uint32_t
aCheckpoint
)
;
bool
SwitchBuffer
(
base
:
:
ProcessId
aOtherPid
ipc
:
:
SharedMemoryBasic
:
:
Handle
*
aHandle
)
;
void
ReturnWrite
(
const
char
*
aData
size_t
aSize
)
;
void
ReturnRead
(
char
*
aOut
size_t
aSize
)
;
bool
UsingLargeStream
(
)
{
return
mLargeStream
;
}
protected
:
bool
WaitForAndRecalculateAvailableSpace
(
)
final
;
void
UpdateWriteTotalsBy
(
uint32_t
aCount
)
final
;
private
:
enum
class
State
:
uint32_t
{
Processing
AboutToWait
Waiting
Stopped
Failed
}
;
struct
ReadFooter
{
Atomic
<
uint32_t
>
count
;
Atomic
<
uint32_t
>
returnCount
;
Atomic
<
State
>
state
;
}
;
struct
WriteFooter
{
Atomic
<
uint32_t
>
count
;
Atomic
<
uint32_t
>
returnCount
;
Atomic
<
uint32_t
>
requiredDifference
;
Atomic
<
State
>
state
;
}
;
CanvasEventRingBuffer
(
const
CanvasEventRingBuffer
&
)
=
delete
;
void
operator
=
(
const
CanvasEventRingBuffer
&
)
=
delete
;
void
IncrementWriteCountBy
(
uint32_t
aCount
)
;
bool
WaitForReadCount
(
uint32_t
aReadCount
TimeDuration
aTimeout
)
;
bool
WaitForAndRecalculateAvailableData
(
)
;
void
UpdateReadTotalsBy
(
uint32_t
aCount
)
;
void
IncrementReadCountBy
(
uint32_t
aCount
)
;
void
CheckAndSignalReader
(
)
;
void
CheckAndSignalWriter
(
)
;
uint32_t
WaitForBytesToWrite
(
)
;
uint32_t
WaitForBytesToRead
(
)
;
uint32_t
StreamSize
(
)
;
RefPtr
<
ipc
:
:
SharedMemoryBasic
>
mSharedMemory
;
UniquePtr
<
CrossProcessSemaphore
>
mReaderSemaphore
;
UniquePtr
<
CrossProcessSemaphore
>
mWriterSemaphore
;
UniquePtr
<
WriterServices
>
mWriterServices
;
UniquePtr
<
ReaderServices
>
mReaderServices
;
char
*
mBuf
=
nullptr
;
uint32_t
mOurCount
=
0
;
WriteFooter
*
mWrite
=
nullptr
;
ReadFooter
*
mRead
=
nullptr
;
bool
mGood
=
false
;
bool
mLargeStream
=
true
;
}
;
class
CanvasDrawEventRecorder
final
:
public
gfx
:
:
DrawEventRecorderPrivate
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
CanvasDrawEventRecorder
final
)
explicit
CanvasDrawEventRecorder
(
)
{
}
;
bool
Init
(
base
:
:
ProcessId
aOtherPid
ipc
:
:
SharedMemoryBasic
:
:
Handle
*
aHandle
CrossProcessSemaphoreHandle
*
aReaderSem
CrossProcessSemaphoreHandle
*
aWriterSem
UniquePtr
<
CanvasEventRingBuffer
:
:
WriterServices
>
aWriterServices
)
{
return
mOutputStream
.
InitWriter
(
aOtherPid
aHandle
aReaderSem
aWriterSem
std
:
:
move
(
aWriterServices
)
)
;
}
void
RecordEvent
(
const
gfx
:
:
RecordedEvent
&
aEvent
)
final
{
if
(
!
mOutputStream
.
good
(
)
)
{
return
;
}
aEvent
.
RecordToStream
(
mOutputStream
)
;
}
void
StoreSourceSurfaceRecording
(
gfx
:
:
SourceSurface
*
aSurface
const
char
*
aReason
)
final
;
void
Flush
(
)
final
{
}
void
ReturnRead
(
char
*
aOut
size_t
aSize
)
{
mOutputStream
.
ReturnRead
(
aOut
aSize
)
;
}
uint32_t
CreateCheckpoint
(
)
{
return
mOutputStream
.
CreateCheckpoint
(
)
;
}
bool
WaitForCheckpoint
(
uint32_t
aCheckpoint
)
{
return
mOutputStream
.
WaitForCheckpoint
(
aCheckpoint
)
;
}
bool
UsingLargeStream
(
)
{
return
mOutputStream
.
UsingLargeStream
(
)
;
}
bool
SwitchBuffer
(
base
:
:
ProcessId
aOtherPid
ipc
:
:
SharedMemoryBasic
:
:
Handle
*
aHandle
)
{
return
mOutputStream
.
SwitchBuffer
(
aOtherPid
aHandle
)
;
}
private
:
CanvasEventRingBuffer
mOutputStream
;
}
;
}
}
#
endif
