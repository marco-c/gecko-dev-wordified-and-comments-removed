#
ifndef
GFX_CONTENTHOST_H
#
define
GFX_CONTENTHOST_H
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
"
mozilla
-
config
.
h
"
#
include
"
CompositableHost
.
h
"
#
include
"
RotatedBuffer
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
BasePoint
.
h
"
#
include
"
mozilla
/
gfx
/
MatrixFwd
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Polygon
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
ContentClient
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nscore
.
h
"
namespace
mozilla
{
namespace
layers
{
class
Compositor
;
class
ThebesBufferData
;
struct
EffectChain
;
struct
TexturedEffect
;
class
ContentHost
:
public
CompositableHost
{
public
:
virtual
bool
UpdateThebes
(
const
ThebesBufferData
&
aData
const
nsIntRegion
&
aUpdated
const
nsIntRegion
&
aOldValidRegionBack
)
override
=
0
;
virtual
void
SetPaintWillResample
(
bool
aResample
)
{
mPaintWillResample
=
aResample
;
}
bool
PaintWillResample
(
)
{
return
mPaintWillResample
;
}
virtual
void
AddAnimationInvalidation
(
nsIntRegion
&
aRegion
)
{
}
virtual
gfx
:
:
IntRect
GetBufferRect
(
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Must
be
implemented
in
derived
class
"
)
;
return
gfx
:
:
IntRect
(
)
;
}
ContentHost
*
AsContentHost
(
)
override
{
return
this
;
}
protected
:
explicit
ContentHost
(
const
TextureInfo
&
aTextureInfo
)
:
CompositableHost
(
aTextureInfo
)
mPaintWillResample
(
false
)
{
}
bool
mPaintWillResample
;
}
;
class
ContentHostBase
:
public
ContentHost
{
public
:
typedef
ContentClient
:
:
ContentType
ContentType
;
typedef
ContentClient
:
:
PaintState
PaintState
;
explicit
ContentHostBase
(
const
TextureInfo
&
aTextureInfo
)
;
virtual
~
ContentHostBase
(
)
;
gfx
:
:
IntRect
GetBufferRect
(
)
override
{
return
mBufferRect
;
}
virtual
nsIntPoint
GetOriginOffset
(
)
{
return
mBufferRect
.
TopLeft
(
)
-
mBufferRotation
;
}
gfx
:
:
IntPoint
GetBufferRotation
(
)
{
return
mBufferRotation
.
ToUnknownPoint
(
)
;
}
protected
:
gfx
:
:
IntRect
mBufferRect
;
nsIntPoint
mBufferRotation
;
bool
mInitialised
;
}
;
class
ContentHostTexture
:
public
ContentHostBase
{
public
:
explicit
ContentHostTexture
(
const
TextureInfo
&
aTextureInfo
)
:
ContentHostBase
(
aTextureInfo
)
mLocked
(
false
)
mReceivedNewHost
(
false
)
{
}
void
Composite
(
Compositor
*
aCompositor
LayerComposite
*
aLayer
EffectChain
&
aEffectChain
float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfx
:
:
SamplingFilter
aSamplingFilter
const
gfx
:
:
IntRect
&
aClipRect
const
nsIntRegion
*
aVisibleRegion
=
nullptr
const
Maybe
<
gfx
:
:
Polygon
>
&
aGeometry
=
Nothing
(
)
)
override
;
void
SetTextureSourceProvider
(
TextureSourceProvider
*
aProvider
)
override
;
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
GetAsSurface
(
)
override
;
void
Dump
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
=
"
"
bool
aDumpHtml
=
false
)
override
;
void
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
override
;
void
UseTextureHost
(
const
nsTArray
<
TimedTexture
>
&
aTextures
)
override
;
void
UseComponentAlphaTextures
(
TextureHost
*
aTextureOnBlack
TextureHost
*
aTextureOnWhite
)
override
;
bool
Lock
(
)
override
{
MOZ_ASSERT
(
!
mLocked
)
;
if
(
!
mTextureHost
)
{
return
false
;
}
if
(
!
mTextureHost
-
>
Lock
(
)
)
{
return
false
;
}
if
(
mTextureHostOnWhite
&
&
!
mTextureHostOnWhite
-
>
Lock
(
)
)
{
return
false
;
}
mLocked
=
true
;
return
true
;
}
void
Unlock
(
)
override
{
MOZ_ASSERT
(
mLocked
)
;
mTextureHost
-
>
Unlock
(
)
;
if
(
mTextureHostOnWhite
)
{
mTextureHostOnWhite
-
>
Unlock
(
)
;
}
mLocked
=
false
;
}
bool
HasComponentAlpha
(
)
const
{
return
!
!
mTextureHostOnWhite
;
}
RefPtr
<
TextureSource
>
AcquireTextureSource
(
)
;
RefPtr
<
TextureSource
>
AcquireTextureSourceOnWhite
(
)
;
ContentHostTexture
*
AsContentHostTexture
(
)
override
{
return
this
;
}
already_AddRefed
<
TexturedEffect
>
GenEffect
(
const
gfx
:
:
SamplingFilter
aSamplingFilter
)
override
;
protected
:
CompositableTextureHostRef
mTextureHost
;
CompositableTextureHostRef
mTextureHostOnWhite
;
CompositableTextureSourceRef
mTextureSource
;
CompositableTextureSourceRef
mTextureSourceOnWhite
;
bool
mLocked
;
bool
mReceivedNewHost
;
}
;
class
ContentHostDoubleBuffered
:
public
ContentHostTexture
{
public
:
explicit
ContentHostDoubleBuffered
(
const
TextureInfo
&
aTextureInfo
)
:
ContentHostTexture
(
aTextureInfo
)
{
}
virtual
~
ContentHostDoubleBuffered
(
)
=
default
;
CompositableType
GetType
(
)
override
{
return
CompositableType
:
:
CONTENT_DOUBLE
;
}
virtual
bool
UpdateThebes
(
const
ThebesBufferData
&
aData
const
nsIntRegion
&
aUpdated
const
nsIntRegion
&
aOldValidRegionBack
)
override
;
protected
:
nsIntRegion
mValidRegionForNextBackBuffer
;
}
;
class
ContentHostSingleBuffered
:
public
ContentHostTexture
{
public
:
explicit
ContentHostSingleBuffered
(
const
TextureInfo
&
aTextureInfo
)
:
ContentHostTexture
(
aTextureInfo
)
{
}
virtual
~
ContentHostSingleBuffered
(
)
=
default
;
CompositableType
GetType
(
)
override
{
return
CompositableType
:
:
CONTENT_SINGLE
;
}
bool
UpdateThebes
(
const
ThebesBufferData
&
aData
const
nsIntRegion
&
aUpdated
const
nsIntRegion
&
aOldValidRegionBack
)
override
;
}
;
}
}
#
endif
