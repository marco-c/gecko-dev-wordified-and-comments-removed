#
include
"
mozilla
/
layers
/
AsyncCompositionManager
.
h
"
#
include
<
stdint
.
h
>
#
include
"
apz
/
src
/
AsyncPanZoomController
.
h
"
#
include
"
FrameMetrics
.
h
"
#
include
"
LayerManagerComposite
.
h
"
#
include
"
Layers
.
h
"
#
include
"
gfxPoint
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
WidgetUtils
.
h
"
#
include
"
mozilla
/
gfx
/
BaseRect
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
ScaleFactor
.
h
"
#
include
"
mozilla
/
layers
/
AnimationHelper
.
h
"
#
include
"
mozilla
/
layers
/
APZUtils
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
LayerAnimationUtils
.
h
"
#
include
"
mozilla
/
layers
/
LayerMetricsWrapper
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsMathUtils
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
#
include
"
UnitTransforms
.
h
"
#
include
"
gfxPrefs
.
h
"
#
if
defined
(
MOZ_WIDGET_ANDROID
)
#
include
<
android
/
log
.
h
>
#
include
"
mozilla
/
layers
/
UiCompositorControllerParent
.
h
"
#
include
"
mozilla
/
widget
/
AndroidCompositorWidget
.
h
"
#
endif
#
include
"
GeckoProfiler
.
h
"
#
include
"
FrameUniformityData
.
h
"
#
include
"
TreeTraversal
.
h
"
#
include
"
VsyncSource
.
h
"
struct
nsCSSValueSharedList
;
namespace
mozilla
{
namespace
layers
{
using
namespace
mozilla
:
:
gfx
;
static
bool
IsSameDimension
(
dom
:
:
ScreenOrientationInternal
o1
dom
:
:
ScreenOrientationInternal
o2
)
{
bool
isO1portrait
=
(
o1
=
=
dom
:
:
eScreenOrientation_PortraitPrimary
|
|
o1
=
=
dom
:
:
eScreenOrientation_PortraitSecondary
)
;
bool
isO2portrait
=
(
o2
=
=
dom
:
:
eScreenOrientation_PortraitPrimary
|
|
o2
=
=
dom
:
:
eScreenOrientation_PortraitSecondary
)
;
return
!
(
isO1portrait
^
isO2portrait
)
;
}
static
bool
ContentMightReflowOnOrientationChange
(
const
IntRect
&
rect
)
{
return
rect
.
Width
(
)
!
=
rect
.
Height
(
)
;
}
AsyncCompositionManager
:
:
AsyncCompositionManager
(
CompositorBridgeParent
*
aParent
HostLayerManager
*
aManager
)
:
mLayerManager
(
aManager
)
mIsFirstPaint
(
true
)
mLayersUpdated
(
false
)
mReadyForCompose
(
true
)
mCompositorBridge
(
aParent
)
{
}
AsyncCompositionManager
:
:
~
AsyncCompositionManager
(
)
{
}
void
AsyncCompositionManager
:
:
ResolveRefLayers
(
CompositorBridgeParent
*
aCompositor
bool
*
aHasRemoteContent
bool
*
aResolvePlugins
)
{
if
(
aHasRemoteContent
)
{
*
aHasRemoteContent
=
false
;
}
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
bool
resolvePlugins
=
(
aCompositor
&
&
aResolvePlugins
&
&
*
aResolvePlugins
)
;
#
endif
if
(
!
mLayerManager
-
>
GetRoot
(
)
)
{
if
(
aResolvePlugins
)
{
*
aResolvePlugins
=
false
;
}
return
;
}
mReadyForCompose
=
true
;
bool
hasRemoteContent
=
false
;
bool
didResolvePlugins
=
false
;
ForEachNode
<
ForwardIterator
>
(
mLayerManager
-
>
GetRoot
(
)
[
&
]
(
Layer
*
layer
)
{
RefLayer
*
refLayer
=
layer
-
>
AsRefLayer
(
)
;
if
(
!
refLayer
)
{
return
;
}
hasRemoteContent
=
true
;
const
CompositorBridgeParent
:
:
LayerTreeState
*
state
=
CompositorBridgeParent
:
:
GetIndirectShadowTree
(
refLayer
-
>
GetReferentId
(
)
)
;
if
(
!
state
)
{
return
;
}
Layer
*
referent
=
state
-
>
mRoot
;
if
(
!
referent
)
{
return
;
}
if
(
!
refLayer
-
>
GetLocalVisibleRegion
(
)
.
IsEmpty
(
)
)
{
dom
:
:
ScreenOrientationInternal
chromeOrientation
=
mTargetConfig
.
orientation
(
)
;
dom
:
:
ScreenOrientationInternal
contentOrientation
=
state
-
>
mTargetConfig
.
orientation
(
)
;
if
(
!
IsSameDimension
(
chromeOrientation
contentOrientation
)
&
&
ContentMightReflowOnOrientationChange
(
mTargetConfig
.
naturalBounds
(
)
)
)
{
mReadyForCompose
=
false
;
}
}
refLayer
-
>
ConnectReferentLayer
(
referent
)
;
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
if
(
resolvePlugins
)
{
didResolvePlugins
|
=
aCompositor
-
>
UpdatePluginWindowState
(
refLayer
-
>
GetReferentId
(
)
)
;
}
#
endif
}
)
;
if
(
aHasRemoteContent
)
{
*
aHasRemoteContent
=
hasRemoteContent
;
}
if
(
aResolvePlugins
)
{
*
aResolvePlugins
=
didResolvePlugins
;
}
}
void
AsyncCompositionManager
:
:
DetachRefLayers
(
)
{
if
(
!
mLayerManager
-
>
GetRoot
(
)
)
{
return
;
}
mReadyForCompose
=
false
;
ForEachNodePostOrder
<
ForwardIterator
>
(
mLayerManager
-
>
GetRoot
(
)
[
&
]
(
Layer
*
layer
)
{
RefLayer
*
refLayer
=
layer
-
>
AsRefLayer
(
)
;
if
(
!
refLayer
)
{
return
;
}
const
CompositorBridgeParent
:
:
LayerTreeState
*
state
=
CompositorBridgeParent
:
:
GetIndirectShadowTree
(
refLayer
-
>
GetReferentId
(
)
)
;
if
(
!
state
)
{
return
;
}
Layer
*
referent
=
state
-
>
mRoot
;
if
(
referent
)
{
refLayer
-
>
DetachReferentLayer
(
referent
)
;
}
}
)
;
}
void
AsyncCompositionManager
:
:
ComputeRotation
(
)
{
if
(
!
mTargetConfig
.
naturalBounds
(
)
.
IsEmpty
(
)
)
{
mWorldTransform
=
ComputeTransformForRotation
(
mTargetConfig
.
naturalBounds
(
)
mTargetConfig
.
rotation
(
)
)
;
}
}
#
ifdef
DEBUG
static
void
GetBaseTransform
(
Layer
*
aLayer
Matrix4x4
*
aTransform
)
{
*
aTransform
=
(
aLayer
-
>
AsHostLayer
(
)
-
>
GetShadowTransformSetByAnimation
(
)
?
aLayer
-
>
GetLocalTransform
(
)
:
aLayer
-
>
GetTransform
(
)
)
;
}
#
endif
static
void
TransformClipRect
(
Layer
*
aLayer
const
ParentLayerToParentLayerMatrix4x4
&
aTransform
)
{
MOZ_ASSERT
(
aTransform
.
Is2D
(
)
)
;
const
Maybe
<
ParentLayerIntRect
>
&
clipRect
=
aLayer
-
>
AsHostLayer
(
)
-
>
GetShadowClipRect
(
)
;
if
(
clipRect
)
{
ParentLayerIntRect
transformed
=
TransformBy
(
aTransform
*
clipRect
)
;
aLayer
-
>
AsHostLayer
(
)
-
>
SetShadowClipRect
(
Some
(
transformed
)
)
;
}
}
static
void
TransformFixedClip
(
Layer
*
aLayer
const
ParentLayerToParentLayerMatrix4x4
&
aTransform
AsyncCompositionManager
:
:
ClipParts
&
aClipParts
)
{
MOZ_ASSERT
(
aTransform
.
Is2D
(
)
)
;
if
(
aClipParts
.
mFixedClip
)
{
*
aClipParts
.
mFixedClip
=
TransformBy
(
aTransform
*
aClipParts
.
mFixedClip
)
;
aLayer
-
>
AsHostLayer
(
)
-
>
SetShadowClipRect
(
aClipParts
.
Intersect
(
)
)
;
}
}
static
void
SetShadowTransform
(
Layer
*
aLayer
LayerToParentLayerMatrix4x4
aTransform
)
{
if
(
ContainerLayer
*
c
=
aLayer
-
>
AsContainerLayer
(
)
)
{
aTransform
.
PreScale
(
1
.
0f
/
c
-
>
GetPreXScale
(
)
1
.
0f
/
c
-
>
GetPreYScale
(
)
1
)
;
}
aTransform
.
PostScale
(
1
.
0f
/
aLayer
-
>
GetPostXScale
(
)
1
.
0f
/
aLayer
-
>
GetPostYScale
(
)
1
)
;
aLayer
-
>
AsHostLayer
(
)
-
>
SetShadowBaseTransform
(
aTransform
.
ToUnknownMatrix
(
)
)
;
}
static
void
TranslateShadowLayer
(
Layer
*
aLayer
const
ParentLayerPoint
&
aTranslation
bool
aAdjustClipRect
AsyncCompositionManager
:
:
ClipPartsCache
*
aClipPartsCache
)
{
LayerToParentLayerMatrix4x4
layerTransform
=
aLayer
-
>
GetLocalTransformTyped
(
)
;
layerTransform
.
PostTranslate
(
aTranslation
)
;
SetShadowTransform
(
aLayer
layerTransform
)
;
aLayer
-
>
AsHostLayer
(
)
-
>
SetShadowTransformSetByAnimation
(
false
)
;
if
(
aAdjustClipRect
)
{
auto
transform
=
ParentLayerToParentLayerMatrix4x4
:
:
Translation
(
aTranslation
)
;
if
(
aClipPartsCache
)
{
auto
iter
=
aClipPartsCache
-
>
find
(
aLayer
)
;
MOZ_ASSERT
(
iter
!
=
aClipPartsCache
-
>
end
(
)
)
;
TransformFixedClip
(
aLayer
transform
iter
-
>
second
)
;
}
else
{
TransformClipRect
(
aLayer
transform
)
;
}
if
(
Layer
*
maskLayer
=
aLayer
-
>
GetMaskLayer
(
)
)
{
TranslateShadowLayer
(
maskLayer
aTranslation
false
aClipPartsCache
)
;
}
}
}
#
ifdef
DEBUG
static
void
AccumulateLayerTransforms
(
Layer
*
aLayer
Layer
*
aAncestor
Matrix4x4
&
aMatrix
)
{
for
(
Layer
*
l
=
aLayer
;
l
&
&
l
!
=
aAncestor
;
l
=
l
-
>
GetParent
(
)
)
{
Matrix4x4
transform
;
GetBaseTransform
(
l
&
transform
)
;
aMatrix
*
=
transform
;
}
}
#
endif
static
LayerPoint
GetLayerFixedMarginsOffset
(
Layer
*
aLayer
const
ScreenMargin
&
aFixedLayerMargins
)
{
LayerPoint
translation
;
int32_t
sides
=
aLayer
-
>
GetFixedPositionSides
(
)
;
if
(
(
sides
&
eSideBitsLeftRight
)
=
=
eSideBitsLeftRight
)
{
translation
.
x
+
=
(
aFixedLayerMargins
.
left
-
aFixedLayerMargins
.
right
)
/
2
;
}
else
if
(
sides
&
eSideBitsRight
)
{
translation
.
x
-
=
aFixedLayerMargins
.
right
;
}
else
if
(
sides
&
eSideBitsLeft
)
{
translation
.
x
+
=
aFixedLayerMargins
.
left
;
}
if
(
(
sides
&
eSideBitsTopBottom
)
=
=
eSideBitsTopBottom
)
{
translation
.
y
+
=
(
aFixedLayerMargins
.
top
-
aFixedLayerMargins
.
bottom
)
/
2
;
}
else
if
(
sides
&
eSideBitsBottom
)
{
translation
.
y
-
=
aFixedLayerMargins
.
bottom
;
}
else
if
(
sides
&
eSideBitsTop
)
{
translation
.
y
+
=
aFixedLayerMargins
.
top
;
}
return
translation
;
}
static
gfxFloat
IntervalOverlap
(
gfxFloat
aTranslation
gfxFloat
aMin
gfxFloat
aMax
)
{
if
(
aTranslation
>
0
)
{
return
std
:
:
max
(
0
.
0
std
:
:
min
(
aMax
aTranslation
)
-
std
:
:
max
(
aMin
0
.
0
)
)
;
}
else
{
return
std
:
:
min
(
0
.
0
std
:
:
max
(
aMin
aTranslation
)
-
std
:
:
min
(
aMax
0
.
0
)
)
;
}
}
static
LayerMetricsWrapper
FindMetricsWithScrollId
(
Layer
*
aLayer
FrameMetrics
:
:
ViewID
aScrollId
)
{
for
(
uint64_t
i
=
0
;
i
<
aLayer
-
>
GetScrollMetadataCount
(
)
;
+
+
i
)
{
if
(
aLayer
-
>
GetFrameMetrics
(
i
)
.
GetScrollId
(
)
=
=
aScrollId
)
{
return
LayerMetricsWrapper
(
aLayer
i
)
;
}
}
return
LayerMetricsWrapper
(
)
;
}
static
bool
AsyncTransformShouldBeUnapplied
(
Layer
*
aFixedLayer
FrameMetrics
:
:
ViewID
aFixedWithRespectTo
Layer
*
aTransformedLayer
FrameMetrics
:
:
ViewID
aTransformedMetrics
)
{
LayerMetricsWrapper
transformed
=
FindMetricsWithScrollId
(
aTransformedLayer
aTransformedMetrics
)
;
if
(
!
transformed
.
IsValid
(
)
)
{
return
false
;
}
LayerMetricsWrapper
current
(
aFixedLayer
LayerMetricsWrapper
:
:
StartAt
:
:
BOTTOM
)
;
bool
encounteredTransformedLayer
=
false
;
while
(
current
)
{
if
(
!
encounteredTransformedLayer
&
&
current
=
=
transformed
)
{
encounteredTransformedLayer
=
true
;
}
if
(
current
.
Metrics
(
)
.
GetScrollId
(
)
=
=
aFixedWithRespectTo
)
{
return
encounteredTransformedLayer
;
}
current
=
current
.
GetParent
(
)
;
if
(
current
&
&
current
.
AsRefLayer
(
)
!
=
nullptr
)
{
break
;
}
}
return
false
;
}
static
Maybe
<
FrameMetrics
:
:
ViewID
>
IsFixedOrSticky
(
Layer
*
aLayer
)
{
bool
isRootOfFixedSubtree
=
aLayer
-
>
GetIsFixedPosition
(
)
&
&
!
aLayer
-
>
GetParent
(
)
-
>
GetIsFixedPosition
(
)
;
if
(
isRootOfFixedSubtree
)
{
return
Some
(
aLayer
-
>
GetFixedPositionScrollContainerId
(
)
)
;
}
if
(
aLayer
-
>
GetIsStickyPosition
(
)
)
{
return
Some
(
aLayer
-
>
GetStickyScrollContainerId
(
)
)
;
}
return
Nothing
(
)
;
}
void
AsyncCompositionManager
:
:
AlignFixedAndStickyLayers
(
Layer
*
aTransformedSubtreeRoot
Layer
*
aStartTraversalAt
FrameMetrics
:
:
ViewID
aTransformScrollId
const
LayerToParentLayerMatrix4x4
&
aPreviousTransformForRoot
const
LayerToParentLayerMatrix4x4
&
aCurrentTransformForRoot
const
ScreenMargin
&
aFixedLayerMargins
ClipPartsCache
*
aClipPartsCache
)
{
if
(
aCurrentTransformForRoot
.
IsSingular
(
)
)
{
return
;
}
Layer
*
layer
=
aStartTraversalAt
;
bool
needsAsyncTransformUnapplied
=
false
;
if
(
Maybe
<
FrameMetrics
:
:
ViewID
>
fixedTo
=
IsFixedOrSticky
(
layer
)
)
{
needsAsyncTransformUnapplied
=
AsyncTransformShouldBeUnapplied
(
layer
*
fixedTo
aTransformedSubtreeRoot
aTransformScrollId
)
;
}
if
(
!
needsAsyncTransformUnapplied
)
{
for
(
Layer
*
child
=
layer
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
AlignFixedAndStickyLayers
(
aTransformedSubtreeRoot
child
aTransformScrollId
aPreviousTransformForRoot
aCurrentTransformForRoot
aFixedLayerMargins
aClipPartsCache
)
;
}
return
;
}
#
ifdef
DEBUG
Matrix4x4
ancestorTransform
;
if
(
layer
!
=
aTransformedSubtreeRoot
)
{
AccumulateLayerTransforms
(
layer
-
>
GetParent
(
)
aTransformedSubtreeRoot
ancestorTransform
)
;
}
ancestorTransform
.
NudgeToIntegersFixedEpsilon
(
)
;
MOZ_ASSERT
(
ancestorTransform
.
IsIdentity
(
)
)
;
#
endif
#
ifdef
DEBUG
Matrix4x4
localTransform
;
GetBaseTransform
(
layer
&
localTransform
)
;
localTransform
.
NudgeToIntegersFixedEpsilon
(
)
;
MOZ_ASSERT
(
localTransform
.
IsIdentity
(
)
)
;
#
endif
LayerPoint
anchor
=
layer
-
>
GetFixedPositionAnchor
(
)
;
LayerPoint
offsetAnchor
=
anchor
+
GetLayerFixedMarginsOffset
(
layer
aFixedLayerMargins
)
;
ParentLayerPoint
offsetAnchorInSubtreeRootSpace
=
aPreviousTransformForRoot
.
TransformPoint
(
offsetAnchor
)
;
LayerPoint
transformedAnchor
=
aCurrentTransformForRoot
.
Inverse
(
)
.
TransformPoint
(
offsetAnchorInSubtreeRootSpace
)
;
LayerPoint
translation
=
transformedAnchor
-
anchor
;
LayerPoint
unconsumedTranslation
;
if
(
layer
-
>
GetIsStickyPosition
(
)
)
{
const
LayerBox
&
stickyOuter
=
layer
-
>
GetStickyScrollRangeOuter
(
)
;
const
LayerBox
&
stickyInner
=
layer
-
>
GetStickyScrollRangeInner
(
)
;
LayerPoint
originalTranslation
=
translation
;
translation
.
y
=
IntervalOverlap
(
translation
.
y
stickyOuter
.
Y
(
)
stickyOuter
.
YMost
(
)
)
-
IntervalOverlap
(
translation
.
y
stickyInner
.
Y
(
)
stickyInner
.
YMost
(
)
)
;
translation
.
x
=
IntervalOverlap
(
translation
.
x
stickyOuter
.
X
(
)
stickyOuter
.
XMost
(
)
)
-
IntervalOverlap
(
translation
.
x
stickyInner
.
X
(
)
stickyInner
.
XMost
(
)
)
;
unconsumedTranslation
=
translation
-
originalTranslation
;
}
TranslateShadowLayer
(
layer
ViewAs
<
ParentLayerPixel
>
(
translation
PixelCastJustification
:
:
NoTransformOnLayer
)
true
aClipPartsCache
)
;
if
(
unconsumedTranslation
!
=
LayerPoint
(
)
)
{
LayerPoint
newTransformedAnchor
=
unconsumedTranslation
+
anchor
;
ParentLayerPoint
newTransformedAnchorInSubtreeRootSpace
=
aPreviousTransformForRoot
.
TransformPoint
(
newTransformedAnchor
)
;
LayerToParentLayerMatrix4x4
newTransform
=
aPreviousTransformForRoot
;
newTransform
.
PostTranslate
(
newTransformedAnchorInSubtreeRootSpace
-
offsetAnchorInSubtreeRootSpace
)
;
for
(
Layer
*
child
=
layer
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
AlignFixedAndStickyLayers
(
aTransformedSubtreeRoot
child
aTransformScrollId
aPreviousTransformForRoot
newTransform
aFixedLayerMargins
aClipPartsCache
)
;
}
}
}
static
void
ApplyAnimatedValue
(
Layer
*
aLayer
CompositorAnimationStorage
*
aStorage
nsCSSPropertyID
aProperty
const
AnimationData
&
aAnimationData
const
AnimationValue
&
aValue
)
{
if
(
aValue
.
IsNull
(
)
)
{
return
;
}
HostLayer
*
layerCompositor
=
aLayer
-
>
AsHostLayer
(
)
;
switch
(
aProperty
)
{
case
eCSSProperty_opacity
:
{
layerCompositor
-
>
SetShadowOpacity
(
aValue
.
GetOpacity
(
)
)
;
layerCompositor
-
>
SetShadowOpacitySetByAnimation
(
true
)
;
aStorage
-
>
SetAnimatedValue
(
aLayer
-
>
GetCompositorAnimationsId
(
)
aValue
.
GetOpacity
(
)
)
;
break
;
}
case
eCSSProperty_transform
:
{
RefPtr
<
const
nsCSSValueSharedList
>
list
=
aValue
.
GetTransformList
(
)
;
const
TransformData
&
transformData
=
aAnimationData
.
get_TransformData
(
)
;
nsPoint
origin
=
transformData
.
origin
(
)
;
Point3D
transformOrigin
=
transformData
.
transformOrigin
(
)
;
nsDisplayTransform
:
:
FrameTransformProperties
props
(
Move
(
list
)
transformOrigin
)
;
Matrix4x4
transform
=
nsDisplayTransform
:
:
GetResultingTransformMatrix
(
props
origin
transformData
.
appUnitsPerDevPixel
(
)
0
&
transformData
.
bounds
(
)
)
;
Matrix4x4
frameTransform
=
transform
;
if
(
!
aLayer
-
>
GetParent
(
)
|
|
!
aLayer
-
>
GetParent
(
)
-
>
GetTransformIsPerspective
(
)
)
{
nsLayoutUtils
:
:
PostTranslate
(
transform
origin
transformData
.
appUnitsPerDevPixel
(
)
true
)
;
}
if
(
ContainerLayer
*
c
=
aLayer
-
>
AsContainerLayer
(
)
)
{
transform
.
PostScale
(
c
-
>
GetInheritedXScale
(
)
c
-
>
GetInheritedYScale
(
)
1
)
;
}
layerCompositor
-
>
SetShadowBaseTransform
(
transform
)
;
layerCompositor
-
>
SetShadowTransformSetByAnimation
(
true
)
;
aStorage
-
>
SetAnimatedValue
(
aLayer
-
>
GetCompositorAnimationsId
(
)
Move
(
transform
)
Move
(
frameTransform
)
transformData
)
;
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unhandled
animated
property
"
)
;
}
}
static
AnimationProcessTypes
SampleAnimations
(
Layer
*
aLayer
CompositorAnimationStorage
*
aStorage
TimeStamp
aTime
uint64_t
*
aLayerAreaAnimated
)
{
RefLayer
*
ancestorRefLayer
=
nullptr
;
AnimationProcessTypes
animProcess
=
AnimationProcessTypes
:
:
eNone
;
ForEachNode
<
ForwardIterator
>
(
aLayer
[
&
]
(
Layer
*
layer
)
{
if
(
!
ancestorRefLayer
)
{
ancestorRefLayer
=
layer
-
>
AsRefLayer
(
)
;
}
bool
hasInEffectAnimations
=
false
;
AnimationValue
animationValue
=
layer
-
>
GetBaseAnimationStyle
(
)
;
if
(
AnimationHelper
:
:
SampleAnimationForEachNode
(
aTime
layer
-
>
GetAnimations
(
)
layer
-
>
GetAnimationData
(
)
animationValue
hasInEffectAnimations
)
)
{
animProcess
|
=
(
ancestorRefLayer
?
AnimationProcessTypes
:
:
eContent
:
AnimationProcessTypes
:
:
eChrome
)
;
}
if
(
hasInEffectAnimations
)
{
Animation
&
animation
=
layer
-
>
GetAnimations
(
)
.
LastElement
(
)
;
ApplyAnimatedValue
(
layer
aStorage
animation
.
property
(
)
animation
.
data
(
)
animationValue
)
;
if
(
aLayerAreaAnimated
)
{
*
aLayerAreaAnimated
+
=
(
layer
-
>
GetVisibleRegion
(
)
.
Area
(
)
)
;
}
}
}
[
&
ancestorRefLayer
]
(
Layer
*
aLayer
)
{
if
(
ancestorRefLayer
&
&
aLayer
-
>
AsRefLayer
(
)
=
=
ancestorRefLayer
)
{
ancestorRefLayer
=
nullptr
;
}
}
)
;
return
animProcess
;
}
static
bool
SampleAPZAnimations
(
const
LayerMetricsWrapper
&
aLayer
TimeStamp
aSampleTime
)
{
bool
activeAnimations
=
false
;
ForEachNodePostOrder
<
ForwardIterator
>
(
aLayer
[
&
activeAnimations
&
aSampleTime
]
(
LayerMetricsWrapper
aLayerMetrics
)
{
if
(
AsyncPanZoomController
*
apzc
=
aLayerMetrics
.
GetApzc
(
)
)
{
apzc
-
>
ReportCheckerboard
(
aSampleTime
)
;
activeAnimations
|
=
apzc
-
>
AdvanceAnimations
(
aSampleTime
)
;
}
}
)
;
return
activeAnimations
;
}
void
AsyncCompositionManager
:
:
RecordShadowTransforms
(
Layer
*
aLayer
)
{
MOZ_ASSERT
(
gfxPrefs
:
:
CollectScrollTransforms
(
)
)
;
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
ForEachNodePostOrder
<
ForwardIterator
>
(
aLayer
[
this
]
(
Layer
*
layer
)
{
for
(
uint32_t
i
=
0
;
i
<
layer
-
>
GetScrollMetadataCount
(
)
;
i
+
+
)
{
AsyncPanZoomController
*
apzc
=
layer
-
>
GetAsyncPanZoomController
(
i
)
;
if
(
!
apzc
)
{
continue
;
}
gfx
:
:
Matrix4x4
shadowTransform
=
layer
-
>
AsHostLayer
(
)
-
>
GetShadowBaseTransform
(
)
;
if
(
!
shadowTransform
.
Is2D
(
)
)
{
continue
;
}
Matrix
transform
=
shadowTransform
.
As2D
(
)
;
if
(
transform
.
IsTranslation
(
)
&
&
!
shadowTransform
.
IsIdentity
(
)
)
{
Point
translation
=
transform
.
GetTranslation
(
)
;
mLayerTransformRecorder
.
RecordTransform
(
layer
translation
)
;
return
;
}
}
}
)
;
}
static
AsyncTransformComponentMatrix
AdjustForClip
(
const
AsyncTransformComponentMatrix
&
asyncTransform
Layer
*
aLayer
)
{
AsyncTransformComponentMatrix
result
=
asyncTransform
;
if
(
const
Maybe
<
ParentLayerIntRect
>
&
shadowClipRect
=
aLayer
-
>
AsHostLayer
(
)
-
>
GetShadowClipRect
(
)
)
{
if
(
shadowClipRect
-
>
TopLeft
(
)
!
=
ParentLayerIntPoint
(
)
)
{
result
.
ChangeBasis
(
shadowClipRect
-
>
X
(
)
shadowClipRect
-
>
Y
(
)
0
)
;
}
}
return
result
;
}
static
void
ExpandRootClipRect
(
Layer
*
aLayer
const
ScreenMargin
&
aFixedLayerMargins
)
{
Maybe
<
ParentLayerIntRect
>
rootClipRect
=
aLayer
-
>
AsHostLayer
(
)
-
>
GetShadowClipRect
(
)
;
if
(
rootClipRect
&
&
aFixedLayerMargins
!
=
ScreenMargin
(
)
)
{
#
ifndef
MOZ_WIDGET_ANDROID
MOZ_ASSERT
(
false
)
;
#
endif
ParentLayerRect
rect
(
rootClipRect
.
value
(
)
)
;
rect
.
Deflate
(
ViewAs
<
ParentLayerPixel
>
(
aFixedLayerMargins
PixelCastJustification
:
:
ScreenIsParentLayerForRoot
)
)
;
aLayer
-
>
AsHostLayer
(
)
-
>
SetShadowClipRect
(
Some
(
RoundedOut
(
rect
)
)
)
;
}
}
#
ifdef
MOZ_WIDGET_ANDROID
static
void
MoveScrollbarForLayerMargin
(
Layer
*
aRoot
FrameMetrics
:
:
ViewID
aRootScrollId
const
ScreenMargin
&
aFixedLayerMargins
)
{
Layer
*
scrollbar
=
BreadthFirstSearch
<
ReverseIterator
>
(
aRoot
[
aRootScrollId
]
(
Layer
*
aNode
)
{
return
(
aNode
-
>
GetScrollThumbData
(
)
.
mDirection
.
isSome
(
)
&
&
*
aNode
-
>
GetScrollThumbData
(
)
.
mDirection
=
=
ScrollDirection
:
:
eHorizontal
&
&
aNode
-
>
GetScrollbarTargetContainerId
(
)
=
=
aRootScrollId
)
;
}
)
;
if
(
scrollbar
)
{
TranslateShadowLayer
(
scrollbar
ParentLayerPoint
(
0
-
aFixedLayerMargins
.
bottom
)
true
nullptr
)
;
if
(
scrollbar
-
>
GetParent
(
)
)
{
ExpandRootClipRect
(
scrollbar
-
>
GetParent
(
)
aFixedLayerMargins
)
;
}
}
}
#
endif
bool
AsyncCompositionManager
:
:
ApplyAsyncContentTransformToTree
(
Layer
*
aLayer
bool
*
aOutFoundRoot
)
{
bool
appliedTransform
=
false
;
std
:
:
stack
<
Maybe
<
ParentLayerIntRect
>
>
stackDeferredClips
;
ClipPartsCache
clipPartsCache
;
ForEachNode
<
ForwardIterator
>
(
aLayer
[
&
stackDeferredClips
]
(
Layer
*
layer
)
{
stackDeferredClips
.
push
(
Maybe
<
ParentLayerIntRect
>
(
)
)
;
}
[
this
&
aOutFoundRoot
&
stackDeferredClips
&
appliedTransform
&
clipPartsCache
]
(
Layer
*
layer
)
{
Maybe
<
ParentLayerIntRect
>
clipDeferredFromChildren
=
stackDeferredClips
.
top
(
)
;
stackDeferredClips
.
pop
(
)
;
LayerToParentLayerMatrix4x4
oldTransform
=
layer
-
>
GetTransformTyped
(
)
*
AsyncTransformMatrix
(
)
;
AsyncTransformComponentMatrix
combinedAsyncTransform
;
bool
hasAsyncTransform
=
false
;
ScreenMargin
fixedLayerMargins
;
ClipParts
&
clipParts
=
clipPartsCache
[
layer
]
;
clipParts
.
mFixedClip
=
layer
-
>
GetClipRect
(
)
;
clipParts
.
mScrolledClip
=
layer
-
>
GetScrolledClipRect
(
)
;
clipParts
.
mScrolledClip
=
IntersectMaybeRects
(
clipDeferredFromChildren
clipParts
.
mScrolledClip
)
;
nsTArray
<
Layer
*
>
ancestorMaskLayers
;
if
(
const
Maybe
<
LayerClip
>
&
scrolledClip
=
layer
-
>
GetScrolledClip
(
)
)
{
if
(
scrolledClip
-
>
GetMaskLayerIndex
(
)
)
{
ancestorMaskLayers
.
AppendElement
(
layer
-
>
GetAncestorMaskLayerAt
(
*
scrolledClip
-
>
GetMaskLayerIndex
(
)
)
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
layer
-
>
GetScrollMetadataCount
(
)
;
i
+
+
)
{
AsyncPanZoomController
*
controller
=
layer
-
>
GetAsyncPanZoomController
(
i
)
;
if
(
!
controller
)
{
continue
;
}
hasAsyncTransform
=
true
;
AsyncTransform
asyncTransformWithoutOverscroll
=
controller
-
>
GetCurrentAsyncTransform
(
AsyncPanZoomController
:
:
eForCompositing
)
;
AsyncTransformComponentMatrix
overscrollTransform
=
controller
-
>
GetOverscrollTransform
(
AsyncPanZoomController
:
:
eForCompositing
)
;
AsyncTransformComponentMatrix
asyncTransform
=
AsyncTransformComponentMatrix
(
asyncTransformWithoutOverscroll
)
*
overscrollTransform
;
if
(
!
layer
-
>
IsScrollableWithoutContent
(
)
)
{
controller
-
>
MarkAsyncTransformAppliedToContent
(
)
;
}
const
ScrollMetadata
&
scrollMetadata
=
layer
-
>
GetScrollMetadata
(
i
)
;
const
FrameMetrics
&
metrics
=
scrollMetadata
.
GetMetrics
(
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
if
(
!
(
*
aOutFoundRoot
)
)
{
*
aOutFoundRoot
=
metrics
.
IsRootContent
(
)
|
|
(
layer
-
>
GetParent
(
)
=
=
nullptr
&
&
i
+
1
>
=
layer
-
>
GetScrollMetadataCount
(
)
)
;
if
(
*
aOutFoundRoot
)
{
mRootScrollableId
=
metrics
.
GetScrollId
(
)
;
Compositor
*
compositor
=
mLayerManager
-
>
GetCompositor
(
)
;
if
(
CompositorBridgeParent
*
bridge
=
compositor
-
>
GetCompositorBridgeParent
(
)
)
{
AndroidDynamicToolbarAnimator
*
animator
=
bridge
-
>
GetAPZCTreeManager
(
)
-
>
GetAndroidDynamicToolbarAnimator
(
)
;
MOZ_ASSERT
(
animator
)
;
if
(
mIsFirstPaint
)
{
animator
-
>
UpdateRootFrameMetrics
(
metrics
)
;
animator
-
>
FirstPaint
(
)
;
mIsFirstPaint
=
false
;
}
if
(
mLayersUpdated
)
{
animator
-
>
NotifyLayersUpdated
(
)
;
mLayersUpdated
=
false
;
}
if
(
!
metrics
.
IsRootContent
(
)
)
{
animator
-
>
MaybeUpdateCompositionSizeAndRootFrameMetrics
(
metrics
)
;
}
}
fixedLayerMargins
=
mFixedLayerMargins
;
}
}
#
else
*
aOutFoundRoot
=
false
;
mIsFirstPaint
=
false
;
#
endif
if
(
!
scrollMetadata
.
UsesContainerScrolling
(
)
)
{
MOZ_ASSERT
(
asyncTransform
.
Is2D
(
)
)
;
if
(
clipParts
.
mFixedClip
)
{
*
clipParts
.
mFixedClip
=
TransformBy
(
asyncTransform
*
clipParts
.
mFixedClip
)
;
}
if
(
clipParts
.
mScrolledClip
)
{
*
clipParts
.
mScrolledClip
=
TransformBy
(
asyncTransform
*
clipParts
.
mScrolledClip
)
;
}
}
combinedAsyncTransform
*
=
asyncTransform
;
LayerToParentLayerMatrix4x4
transformWithoutOverscrollOrOmta
=
layer
-
>
GetTransformTyped
(
)
*
CompleteAsyncTransform
(
AdjustForClip
(
asyncTransformWithoutOverscroll
layer
)
)
;
AlignFixedAndStickyLayers
(
layer
layer
metrics
.
GetScrollId
(
)
oldTransform
transformWithoutOverscrollOrOmta
fixedLayerMargins
&
clipPartsCache
)
;
if
(
scrollMetadata
.
HasScrollClip
(
)
)
{
ParentLayerIntRect
clip
=
scrollMetadata
.
ScrollClip
(
)
.
GetClipRect
(
)
;
if
(
layer
-
>
GetParent
(
)
&
&
layer
-
>
GetParent
(
)
-
>
GetTransformIsPerspective
(
)
)
{
MOZ_ASSERT
(
!
stackDeferredClips
.
top
(
)
)
;
stackDeferredClips
.
top
(
)
.
emplace
(
clip
)
;
}
else
{
clipParts
.
mScrolledClip
=
IntersectMaybeRects
(
Some
(
clip
)
clipParts
.
mScrolledClip
)
;
}
}
for
(
Layer
*
ancestorMaskLayer
:
ancestorMaskLayers
)
{
SetShadowTransform
(
ancestorMaskLayer
ancestorMaskLayer
-
>
GetLocalTransformTyped
(
)
*
asyncTransform
)
;
}
if
(
scrollMetadata
.
HasScrollClip
(
)
)
{
const
LayerClip
&
scrollClip
=
scrollMetadata
.
ScrollClip
(
)
;
if
(
scrollClip
.
GetMaskLayerIndex
(
)
)
{
size_t
maskLayerIndex
=
scrollClip
.
GetMaskLayerIndex
(
)
.
value
(
)
;
Layer
*
ancestorMaskLayer
=
layer
-
>
GetAncestorMaskLayerAt
(
maskLayerIndex
)
;
ancestorMaskLayers
.
AppendElement
(
ancestorMaskLayer
)
;
}
}
}
bool
clipChanged
=
(
hasAsyncTransform
|
|
clipDeferredFromChildren
|
|
layer
-
>
GetScrolledClipRect
(
)
)
;
if
(
clipChanged
)
{
layer
-
>
AsHostLayer
(
)
-
>
SetShadowClipRect
(
clipParts
.
Intersect
(
)
)
;
}
if
(
hasAsyncTransform
)
{
SetShadowTransform
(
layer
layer
-
>
GetLocalTransformTyped
(
)
*
AdjustForClip
(
combinedAsyncTransform
layer
)
)
;
if
(
Layer
*
maskLayer
=
layer
-
>
GetMaskLayer
(
)
)
{
SetShadowTransform
(
maskLayer
maskLayer
-
>
GetLocalTransformTyped
(
)
*
combinedAsyncTransform
)
;
}
appliedTransform
=
true
;
}
ExpandRootClipRect
(
layer
fixedLayerMargins
)
;
if
(
layer
-
>
GetScrollThumbData
(
)
.
mDirection
.
isSome
(
)
)
{
ApplyAsyncTransformToScrollbar
(
layer
)
;
}
}
)
;
return
appliedTransform
;
}
static
bool
LayerIsScrollbarTarget
(
const
LayerMetricsWrapper
&
aTarget
Layer
*
aScrollbar
)
{
AsyncPanZoomController
*
apzc
=
aTarget
.
GetApzc
(
)
;
if
(
!
apzc
)
{
return
false
;
}
const
FrameMetrics
&
metrics
=
aTarget
.
Metrics
(
)
;
if
(
metrics
.
GetScrollId
(
)
!
=
aScrollbar
-
>
GetScrollbarTargetContainerId
(
)
)
{
return
false
;
}
return
!
metrics
.
IsScrollInfoLayer
(
)
;
}
static
void
ApplyAsyncTransformToScrollbarForContent
(
Layer
*
aScrollbar
const
LayerMetricsWrapper
&
aContent
bool
aScrollbarIsDescendant
)
{
AsyncTransformComponentMatrix
clipTransform
;
LayerToParentLayerMatrix4x4
transform
=
AsyncCompositionManager
:
:
ComputeTransformForScrollThumb
(
aScrollbar
-
>
GetLocalTransformTyped
(
)
aContent
.
GetTransform
(
)
aContent
.
GetApzc
(
)
aContent
.
Metrics
(
)
aScrollbar
-
>
GetScrollThumbData
(
)
aScrollbarIsDescendant
&
clipTransform
)
;
if
(
aScrollbarIsDescendant
)
{
for
(
Layer
*
ancestor
=
aScrollbar
;
ancestor
!
=
aContent
.
GetLayer
(
)
;
ancestor
=
ancestor
-
>
GetParent
(
)
)
{
TransformClipRect
(
ancestor
clipTransform
)
;
}
}
SetShadowTransform
(
aScrollbar
transform
)
;
}
LayerToParentLayerMatrix4x4
AsyncCompositionManager
:
:
ComputeTransformForScrollThumb
(
const
LayerToParentLayerMatrix4x4
&
aCurrentTransform
const
Matrix4x4
&
aScrollableContentTransform
AsyncPanZoomController
*
aApzc
const
FrameMetrics
&
aMetrics
const
ScrollThumbData
&
aThumbData
bool
aScrollbarIsDescendant
AsyncTransformComponentMatrix
*
aOutClipTransform
)
{
if
(
aMetrics
.
IsScrollInfoLayer
(
)
)
{
return
LayerToParentLayerMatrix4x4
{
}
;
}
MOZ_RELEASE_ASSERT
(
aApzc
)
;
AsyncTransformComponentMatrix
asyncTransform
=
aApzc
-
>
GetCurrentAsyncTransform
(
AsyncPanZoomController
:
:
eForCompositing
)
;
AsyncTransformComponentMatrix
scrollbarTransform
;
if
(
*
aThumbData
.
mDirection
=
=
ScrollDirection
:
:
eVertical
)
{
const
ParentLayerCoord
asyncScrollY
=
asyncTransform
.
_42
;
const
float
asyncZoomY
=
asyncTransform
.
_22
;
const
float
yScale
=
1
.
f
/
asyncZoomY
;
const
CSSToParentLayerScale
effectiveZoom
(
aMetrics
.
GetZoom
(
)
.
yScale
*
asyncZoomY
)
;
const
float
ratio
=
aThumbData
.
mThumbRatio
/
(
aMetrics
.
GetPresShellResolution
(
)
*
asyncZoomY
)
;
ParentLayerCoord
yTranslation
=
-
asyncScrollY
*
ratio
;
const
CSSCoord
thumbOrigin
=
(
aMetrics
.
GetScrollOffset
(
)
.
y
*
ratio
)
;
const
CSSCoord
thumbOriginScaled
=
thumbOrigin
*
yScale
;
const
CSSCoord
thumbOriginDelta
=
thumbOriginScaled
-
thumbOrigin
;
const
ParentLayerCoord
thumbOriginDeltaPL
=
thumbOriginDelta
*
effectiveZoom
;
yTranslation
-
=
thumbOriginDeltaPL
;
if
(
aMetrics
.
IsRootContent
(
)
)
{
yTranslation
*
=
aMetrics
.
GetPresShellResolution
(
)
;
}
scrollbarTransform
.
PostScale
(
1
.
f
yScale
1
.
f
)
;
scrollbarTransform
.
PostTranslate
(
0
yTranslation
0
)
;
}
if
(
*
aThumbData
.
mDirection
=
=
ScrollDirection
:
:
eHorizontal
)
{
const
ParentLayerCoord
asyncScrollX
=
asyncTransform
.
_41
;
const
float
asyncZoomX
=
asyncTransform
.
_11
;
const
float
xScale
=
1
.
f
/
asyncZoomX
;
const
CSSToParentLayerScale
effectiveZoom
(
aMetrics
.
GetZoom
(
)
.
xScale
*
asyncZoomX
)
;
const
float
ratio
=
aThumbData
.
mThumbRatio
/
(
aMetrics
.
GetPresShellResolution
(
)
*
asyncZoomX
)
;
ParentLayerCoord
xTranslation
=
-
asyncScrollX
*
ratio
;
const
CSSCoord
thumbOrigin
=
(
aMetrics
.
GetScrollOffset
(
)
.
x
*
ratio
)
;
const
CSSCoord
thumbOriginScaled
=
thumbOrigin
*
xScale
;
const
CSSCoord
thumbOriginDelta
=
thumbOriginScaled
-
thumbOrigin
;
const
ParentLayerCoord
thumbOriginDeltaPL
=
thumbOriginDelta
*
effectiveZoom
;
xTranslation
-
=
thumbOriginDeltaPL
;
if
(
aMetrics
.
IsRootContent
(
)
)
{
xTranslation
*
=
aMetrics
.
GetPresShellResolution
(
)
;
}
scrollbarTransform
.
PostScale
(
xScale
1
.
f
1
.
f
)
;
scrollbarTransform
.
PostTranslate
(
xTranslation
0
0
)
;
}
LayerToParentLayerMatrix4x4
transform
=
aCurrentTransform
*
scrollbarTransform
;
AsyncTransformComponentMatrix
compensation
;
if
(
aMetrics
.
IsRootContent
(
)
)
{
compensation
=
AsyncTransformComponentMatrix
:
:
Scaling
(
aMetrics
.
GetPresShellResolution
(
)
aMetrics
.
GetPresShellResolution
(
)
1
.
0f
)
.
Inverse
(
)
;
}
if
(
aScrollbarIsDescendant
)
{
AsyncTransformComponentMatrix
overscroll
=
aApzc
-
>
GetOverscrollTransform
(
AsyncPanZoomController
:
:
eForCompositing
)
;
Matrix4x4
asyncUntransform
=
(
asyncTransform
*
overscroll
)
.
Inverse
(
)
.
ToUnknownMatrix
(
)
;
Matrix4x4
contentTransform
=
aScrollableContentTransform
;
Matrix4x4
contentUntransform
=
contentTransform
.
Inverse
(
)
;
AsyncTransformComponentMatrix
asyncCompensation
=
ViewAs
<
AsyncTransformComponentMatrix
>
(
contentTransform
*
asyncUntransform
*
contentUntransform
)
;
compensation
=
compensation
*
asyncCompensation
;
if
(
aOutClipTransform
)
{
*
aOutClipTransform
=
asyncCompensation
;
}
}
transform
=
transform
*
compensation
;
return
transform
;
}
static
LayerMetricsWrapper
FindScrolledLayerForScrollbar
(
Layer
*
aScrollbar
bool
*
aOutIsAncestor
)
{
LayerMetricsWrapper
root
(
aScrollbar
-
>
Manager
(
)
-
>
GetRoot
(
)
)
;
LayerMetricsWrapper
prevAncestor
(
aScrollbar
)
;
LayerMetricsWrapper
scrolledLayer
;
for
(
LayerMetricsWrapper
ancestor
(
aScrollbar
)
;
ancestor
;
ancestor
=
ancestor
.
GetParent
(
)
)
{
if
(
ancestor
.
AsRefLayer
(
)
)
{
root
=
prevAncestor
;
break
;
}
prevAncestor
=
ancestor
;
if
(
LayerIsScrollbarTarget
(
ancestor
aScrollbar
)
)
{
*
aOutIsAncestor
=
true
;
return
ancestor
;
}
}
ForEachNode
<
ForwardIterator
>
(
root
[
&
root
&
scrolledLayer
&
aScrollbar
]
(
LayerMetricsWrapper
aLayerMetrics
)
{
if
(
root
!
=
aLayerMetrics
&
&
aLayerMetrics
.
AsRefLayer
(
)
)
{
return
TraversalFlag
:
:
Skip
;
}
if
(
LayerIsScrollbarTarget
(
aLayerMetrics
aScrollbar
)
)
{
scrolledLayer
=
aLayerMetrics
;
return
TraversalFlag
:
:
Abort
;
}
return
TraversalFlag
:
:
Continue
;
}
)
;
return
scrolledLayer
;
}
void
AsyncCompositionManager
:
:
ApplyAsyncTransformToScrollbar
(
Layer
*
aLayer
)
{
bool
isAncestor
=
false
;
const
LayerMetricsWrapper
&
scrollTarget
=
FindScrolledLayerForScrollbar
(
aLayer
&
isAncestor
)
;
if
(
scrollTarget
)
{
ApplyAsyncTransformToScrollbarForContent
(
aLayer
scrollTarget
isAncestor
)
;
}
}
void
AsyncCompositionManager
:
:
GetFrameUniformity
(
FrameUniformityData
*
aOutData
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
mLayerTransformRecorder
.
EndTest
(
aOutData
)
;
}
bool
AsyncCompositionManager
:
:
TransformShadowTree
(
TimeStamp
aCurrentFrame
TimeDuration
aVsyncRate
TransformsToSkip
aSkip
)
{
AUTO_PROFILER_LABEL
(
"
AsyncCompositionManager
:
:
TransformShadowTree
"
GRAPHICS
)
;
Layer
*
root
=
mLayerManager
-
>
GetRoot
(
)
;
if
(
!
root
)
{
return
false
;
}
CompositorAnimationStorage
*
storage
=
mCompositorBridge
-
>
GetAnimationStorage
(
)
;
uint64_t
layerAreaAnimated
=
0
;
AnimationProcessTypes
animationProcess
=
SampleAnimations
(
root
storage
!
mPreviousFrameTimeStamp
.
IsNull
(
)
?
mPreviousFrameTimeStamp
:
aCurrentFrame
&
layerAreaAnimated
)
;
bool
wantNextFrame
=
(
animationProcess
!
=
AnimationProcessTypes
:
:
eNone
)
;
mAnimationMetricsTracker
.
UpdateAnimationInProgress
(
animationProcess
layerAreaAnimated
aVsyncRate
)
;
if
(
!
wantNextFrame
)
{
storage
-
>
Clear
(
)
;
}
TimeStamp
nextFrame
=
aCurrentFrame
;
MOZ_ASSERT
(
aVsyncRate
!
=
TimeDuration
:
:
Forever
(
)
)
;
if
(
aVsyncRate
!
=
TimeDuration
:
:
Forever
(
)
)
{
nextFrame
+
=
aVsyncRate
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
Compositor
*
compositor
=
mLayerManager
-
>
GetCompositor
(
)
;
if
(
CompositorBridgeParent
*
bridge
=
compositor
-
>
GetCompositorBridgeParent
(
)
)
{
AndroidDynamicToolbarAnimator
*
animator
=
bridge
-
>
GetAPZCTreeManager
(
)
-
>
GetAndroidDynamicToolbarAnimator
(
)
;
MOZ_ASSERT
(
animator
)
;
wantNextFrame
|
=
animator
-
>
UpdateAnimation
(
nextFrame
)
;
}
#
endif
mPreviousFrameTimeStamp
=
wantNextFrame
?
aCurrentFrame
:
TimeStamp
(
)
;
if
(
!
(
aSkip
&
TransformsToSkip
:
:
APZ
)
)
{
bool
foundRoot
=
false
;
if
(
ApplyAsyncContentTransformToTree
(
root
&
foundRoot
)
)
{
#
if
defined
(
MOZ_WIDGET_ANDROID
)
MOZ_ASSERT
(
foundRoot
)
;
if
(
foundRoot
&
&
mFixedLayerMargins
!
=
ScreenMargin
(
)
)
{
MoveScrollbarForLayerMargin
(
root
mRootScrollableId
mFixedLayerMargins
)
;
}
#
endif
}
bool
apzAnimating
=
SampleAPZAnimations
(
LayerMetricsWrapper
(
root
)
nextFrame
)
;
mAnimationMetricsTracker
.
UpdateApzAnimationInProgress
(
apzAnimating
aVsyncRate
)
;
wantNextFrame
|
=
apzAnimating
;
}
HostLayer
*
rootComposite
=
root
-
>
AsHostLayer
(
)
;
gfx
:
:
Matrix4x4
trans
=
rootComposite
-
>
GetShadowBaseTransform
(
)
;
trans
*
=
gfx
:
:
Matrix4x4
:
:
From2D
(
mWorldTransform
)
;
rootComposite
-
>
SetShadowBaseTransform
(
trans
)
;
if
(
gfxPrefs
:
:
CollectScrollTransforms
(
)
)
{
RecordShadowTransforms
(
root
)
;
}
return
wantNextFrame
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
void
AsyncCompositionManager
:
:
SetFixedLayerMargins
(
ScreenIntCoord
aTop
ScreenIntCoord
aBottom
)
{
mFixedLayerMargins
.
top
=
aTop
;
mFixedLayerMargins
.
bottom
=
aBottom
;
}
#
endif
}
}
