#
include
"
mozilla
/
layers
/
AsyncCompositionManager
.
h
"
#
include
<
stdint
.
h
>
#
include
"
LayerManagerComposite
.
h
"
#
include
"
Layers
.
h
"
#
include
"
gfxPoint
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
WidgetUtils
.
h
"
#
include
"
mozilla
/
gfx
/
BaseRect
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
ScaleFactor
.
h
"
#
include
"
mozilla
/
layers
/
AnimationHelper
.
h
"
#
include
"
mozilla
/
layers
/
APZSampler
.
h
"
#
include
"
mozilla
/
layers
/
APZUtils
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
LayerAnimationUtils
.
h
"
#
include
"
mozilla
/
layers
/
LayerMetricsWrapper
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsMathUtils
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
#
include
"
UnitTransforms
.
h
"
#
include
"
gfxPrefs
.
h
"
#
if
defined
(
MOZ_WIDGET_ANDROID
)
#
include
<
android
/
log
.
h
>
#
include
"
mozilla
/
layers
/
UiCompositorControllerParent
.
h
"
#
include
"
mozilla
/
widget
/
AndroidCompositorWidget
.
h
"
#
endif
#
include
"
GeckoProfiler
.
h
"
#
include
"
FrameUniformityData
.
h
"
#
include
"
TreeTraversal
.
h
"
#
include
"
VsyncSource
.
h
"
struct
nsCSSValueSharedList
;
namespace
mozilla
{
namespace
layers
{
using
namespace
mozilla
:
:
gfx
;
static
bool
IsSameDimension
(
hal
:
:
ScreenOrientation
o1
hal
:
:
ScreenOrientation
o2
)
{
bool
isO1portrait
=
(
o1
=
=
hal
:
:
eScreenOrientation_PortraitPrimary
|
|
o1
=
=
hal
:
:
eScreenOrientation_PortraitSecondary
)
;
bool
isO2portrait
=
(
o2
=
=
hal
:
:
eScreenOrientation_PortraitPrimary
|
|
o2
=
=
hal
:
:
eScreenOrientation_PortraitSecondary
)
;
return
!
(
isO1portrait
^
isO2portrait
)
;
}
static
bool
ContentMightReflowOnOrientationChange
(
const
IntRect
&
rect
)
{
return
rect
.
Width
(
)
!
=
rect
.
Height
(
)
;
}
AsyncCompositionManager
:
:
AsyncCompositionManager
(
CompositorBridgeParent
*
aParent
HostLayerManager
*
aManager
)
:
mLayerManager
(
aManager
)
mIsFirstPaint
(
true
)
mLayersUpdated
(
false
)
mReadyForCompose
(
true
)
mCompositorBridge
(
aParent
)
{
MOZ_ASSERT
(
mCompositorBridge
)
;
}
AsyncCompositionManager
:
:
~
AsyncCompositionManager
(
)
{
}
void
AsyncCompositionManager
:
:
ResolveRefLayers
(
CompositorBridgeParent
*
aCompositor
bool
*
aHasRemoteContent
bool
*
aResolvePlugins
)
{
if
(
aHasRemoteContent
)
{
*
aHasRemoteContent
=
false
;
}
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
bool
resolvePlugins
=
(
aCompositor
&
&
aResolvePlugins
&
&
*
aResolvePlugins
)
;
#
endif
if
(
!
mLayerManager
-
>
GetRoot
(
)
)
{
if
(
aResolvePlugins
)
{
*
aResolvePlugins
=
false
;
}
return
;
}
mReadyForCompose
=
true
;
bool
hasRemoteContent
=
false
;
bool
didResolvePlugins
=
false
;
ForEachNode
<
ForwardIterator
>
(
mLayerManager
-
>
GetRoot
(
)
[
&
]
(
Layer
*
layer
)
{
RefLayer
*
refLayer
=
layer
-
>
AsRefLayer
(
)
;
if
(
!
refLayer
)
{
return
;
}
hasRemoteContent
=
true
;
const
CompositorBridgeParent
:
:
LayerTreeState
*
state
=
CompositorBridgeParent
:
:
GetIndirectShadowTree
(
refLayer
-
>
GetReferentId
(
)
)
;
if
(
!
state
)
{
return
;
}
Layer
*
referent
=
state
-
>
mRoot
;
if
(
!
referent
)
{
return
;
}
if
(
!
refLayer
-
>
GetLocalVisibleRegion
(
)
.
IsEmpty
(
)
)
{
hal
:
:
ScreenOrientation
chromeOrientation
=
mTargetConfig
.
orientation
(
)
;
hal
:
:
ScreenOrientation
contentOrientation
=
state
-
>
mTargetConfig
.
orientation
(
)
;
if
(
!
IsSameDimension
(
chromeOrientation
contentOrientation
)
&
&
ContentMightReflowOnOrientationChange
(
mTargetConfig
.
naturalBounds
(
)
)
)
{
mReadyForCompose
=
false
;
}
}
refLayer
-
>
ConnectReferentLayer
(
referent
)
;
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
if
(
resolvePlugins
)
{
didResolvePlugins
|
=
aCompositor
-
>
UpdatePluginWindowState
(
refLayer
-
>
GetReferentId
(
)
)
;
}
#
endif
}
)
;
if
(
aHasRemoteContent
)
{
*
aHasRemoteContent
=
hasRemoteContent
;
}
if
(
aResolvePlugins
)
{
*
aResolvePlugins
=
didResolvePlugins
;
}
}
void
AsyncCompositionManager
:
:
DetachRefLayers
(
)
{
if
(
!
mLayerManager
-
>
GetRoot
(
)
)
{
return
;
}
mReadyForCompose
=
false
;
ForEachNodePostOrder
<
ForwardIterator
>
(
mLayerManager
-
>
GetRoot
(
)
[
&
]
(
Layer
*
layer
)
{
RefLayer
*
refLayer
=
layer
-
>
AsRefLayer
(
)
;
if
(
!
refLayer
)
{
return
;
}
const
CompositorBridgeParent
:
:
LayerTreeState
*
state
=
CompositorBridgeParent
:
:
GetIndirectShadowTree
(
refLayer
-
>
GetReferentId
(
)
)
;
if
(
!
state
)
{
return
;
}
Layer
*
referent
=
state
-
>
mRoot
;
if
(
referent
)
{
refLayer
-
>
DetachReferentLayer
(
referent
)
;
}
}
)
;
}
void
AsyncCompositionManager
:
:
ComputeRotation
(
)
{
if
(
!
mTargetConfig
.
naturalBounds
(
)
.
IsEmpty
(
)
)
{
mWorldTransform
=
ComputeTransformForRotation
(
mTargetConfig
.
naturalBounds
(
)
mTargetConfig
.
rotation
(
)
)
;
}
}
static
void
GetBaseTransform
(
Layer
*
aLayer
Matrix4x4
*
aTransform
)
{
*
aTransform
=
(
aLayer
-
>
AsHostLayer
(
)
-
>
GetShadowTransformSetByAnimation
(
)
?
aLayer
-
>
GetLocalTransform
(
)
:
aLayer
-
>
GetTransform
(
)
)
;
}
static
void
TransformClipRect
(
Layer
*
aLayer
const
ParentLayerToParentLayerMatrix4x4
&
aTransform
)
{
MOZ_ASSERT
(
aTransform
.
Is2D
(
)
)
;
const
Maybe
<
ParentLayerIntRect
>
&
clipRect
=
aLayer
-
>
AsHostLayer
(
)
-
>
GetShadowClipRect
(
)
;
if
(
clipRect
)
{
ParentLayerIntRect
transformed
=
TransformBy
(
aTransform
*
clipRect
)
;
aLayer
-
>
AsHostLayer
(
)
-
>
SetShadowClipRect
(
Some
(
transformed
)
)
;
}
}
static
void
TransformFixedClip
(
Layer
*
aLayer
const
ParentLayerToParentLayerMatrix4x4
&
aTransform
AsyncCompositionManager
:
:
ClipParts
&
aClipParts
)
{
MOZ_ASSERT
(
aTransform
.
Is2D
(
)
)
;
if
(
aClipParts
.
mFixedClip
)
{
*
aClipParts
.
mFixedClip
=
TransformBy
(
aTransform
*
aClipParts
.
mFixedClip
)
;
aLayer
-
>
AsHostLayer
(
)
-
>
SetShadowClipRect
(
aClipParts
.
Intersect
(
)
)
;
}
}
static
void
SetShadowTransform
(
Layer
*
aLayer
LayerToParentLayerMatrix4x4
aTransform
)
{
if
(
ContainerLayer
*
c
=
aLayer
-
>
AsContainerLayer
(
)
)
{
aTransform
.
PreScale
(
1
.
0f
/
c
-
>
GetPreXScale
(
)
1
.
0f
/
c
-
>
GetPreYScale
(
)
1
)
;
}
aTransform
.
PostScale
(
1
.
0f
/
aLayer
-
>
GetPostXScale
(
)
1
.
0f
/
aLayer
-
>
GetPostYScale
(
)
1
)
;
aLayer
-
>
AsHostLayer
(
)
-
>
SetShadowBaseTransform
(
aTransform
.
ToUnknownMatrix
(
)
)
;
}
static
void
TranslateShadowLayer
(
Layer
*
aLayer
const
ParentLayerPoint
&
aTranslation
bool
aAdjustClipRect
AsyncCompositionManager
:
:
ClipPartsCache
*
aClipPartsCache
)
{
LayerToParentLayerMatrix4x4
layerTransform
=
aLayer
-
>
GetLocalTransformTyped
(
)
;
layerTransform
.
PostTranslate
(
aTranslation
)
;
SetShadowTransform
(
aLayer
layerTransform
)
;
aLayer
-
>
AsHostLayer
(
)
-
>
SetShadowTransformSetByAnimation
(
false
)
;
if
(
aAdjustClipRect
)
{
auto
transform
=
ParentLayerToParentLayerMatrix4x4
:
:
Translation
(
aTranslation
)
;
if
(
aClipPartsCache
)
{
auto
iter
=
aClipPartsCache
-
>
find
(
aLayer
)
;
MOZ_ASSERT
(
iter
!
=
aClipPartsCache
-
>
end
(
)
)
;
TransformFixedClip
(
aLayer
transform
iter
-
>
second
)
;
}
else
{
TransformClipRect
(
aLayer
transform
)
;
}
if
(
Layer
*
maskLayer
=
aLayer
-
>
GetMaskLayer
(
)
)
{
TranslateShadowLayer
(
maskLayer
aTranslation
false
aClipPartsCache
)
;
}
}
}
static
void
AccumulateLayerTransforms
(
Layer
*
aLayer
Layer
*
aAncestor
Matrix4x4
&
aMatrix
)
{
for
(
Layer
*
l
=
aLayer
;
l
&
&
l
!
=
aAncestor
;
l
=
l
-
>
GetParent
(
)
)
{
Matrix4x4
transform
;
GetBaseTransform
(
l
&
transform
)
;
aMatrix
*
=
transform
;
}
}
static
LayerPoint
GetLayerFixedMarginsOffset
(
Layer
*
aLayer
const
ScreenMargin
&
aFixedLayerMargins
)
{
LayerPoint
translation
;
int32_t
sides
=
aLayer
-
>
GetFixedPositionSides
(
)
;
if
(
(
sides
&
eSideBitsLeftRight
)
=
=
eSideBitsLeftRight
)
{
translation
.
x
+
=
(
aFixedLayerMargins
.
left
-
aFixedLayerMargins
.
right
)
/
2
;
}
else
if
(
sides
&
eSideBitsRight
)
{
translation
.
x
-
=
aFixedLayerMargins
.
right
;
}
else
if
(
sides
&
eSideBitsLeft
)
{
translation
.
x
+
=
aFixedLayerMargins
.
left
;
}
if
(
(
sides
&
eSideBitsTopBottom
)
=
=
eSideBitsTopBottom
)
{
translation
.
y
+
=
(
aFixedLayerMargins
.
top
-
aFixedLayerMargins
.
bottom
)
/
2
;
}
else
if
(
sides
&
eSideBitsBottom
)
{
translation
.
y
-
=
aFixedLayerMargins
.
bottom
;
}
else
if
(
sides
&
eSideBitsTop
)
{
translation
.
y
+
=
aFixedLayerMargins
.
top
;
}
return
translation
;
}
static
gfxFloat
IntervalOverlap
(
gfxFloat
aTranslation
gfxFloat
aMin
gfxFloat
aMax
)
{
if
(
aTranslation
>
0
)
{
return
std
:
:
max
(
0
.
0
std
:
:
min
(
aMax
aTranslation
)
-
std
:
:
max
(
aMin
0
.
0
)
)
;
}
else
{
return
std
:
:
min
(
0
.
0
std
:
:
max
(
aMin
aTranslation
)
-
std
:
:
min
(
aMax
0
.
0
)
)
;
}
}
static
LayerMetricsWrapper
FindMetricsWithScrollId
(
Layer
*
aLayer
ScrollableLayerGuid
:
:
ViewID
aScrollId
)
{
for
(
uint64_t
i
=
0
;
i
<
aLayer
-
>
GetScrollMetadataCount
(
)
;
+
+
i
)
{
if
(
aLayer
-
>
GetFrameMetrics
(
i
)
.
GetScrollId
(
)
=
=
aScrollId
)
{
return
LayerMetricsWrapper
(
aLayer
i
)
;
}
}
return
LayerMetricsWrapper
(
)
;
}
static
bool
AsyncTransformShouldBeUnapplied
(
Layer
*
aFixedLayer
ScrollableLayerGuid
:
:
ViewID
aFixedWithRespectTo
Layer
*
aTransformedLayer
ScrollableLayerGuid
:
:
ViewID
aTransformedMetrics
)
{
LayerMetricsWrapper
transformed
=
FindMetricsWithScrollId
(
aTransformedLayer
aTransformedMetrics
)
;
if
(
!
transformed
.
IsValid
(
)
)
{
return
false
;
}
LayerMetricsWrapper
current
(
aFixedLayer
LayerMetricsWrapper
:
:
StartAt
:
:
BOTTOM
)
;
bool
encounteredTransformedLayer
=
false
;
while
(
current
)
{
if
(
!
encounteredTransformedLayer
&
&
current
=
=
transformed
)
{
encounteredTransformedLayer
=
true
;
}
if
(
current
.
Metrics
(
)
.
GetScrollId
(
)
=
=
aFixedWithRespectTo
)
{
return
encounteredTransformedLayer
;
}
current
=
current
.
GetParent
(
)
;
if
(
current
&
&
current
.
AsRefLayer
(
)
!
=
nullptr
)
{
break
;
}
}
return
false
;
}
static
Maybe
<
ScrollableLayerGuid
:
:
ViewID
>
IsFixedOrSticky
(
Layer
*
aLayer
)
{
bool
isRootOfFixedSubtree
=
aLayer
-
>
GetIsFixedPosition
(
)
&
&
!
aLayer
-
>
GetParent
(
)
-
>
GetIsFixedPosition
(
)
;
if
(
isRootOfFixedSubtree
)
{
return
Some
(
aLayer
-
>
GetFixedPositionScrollContainerId
(
)
)
;
}
if
(
aLayer
-
>
GetIsStickyPosition
(
)
)
{
return
Some
(
aLayer
-
>
GetStickyScrollContainerId
(
)
)
;
}
return
Nothing
(
)
;
}
void
AsyncCompositionManager
:
:
AlignFixedAndStickyLayers
(
Layer
*
aTransformedSubtreeRoot
Layer
*
aStartTraversalAt
ScrollableLayerGuid
:
:
ViewID
aTransformScrollId
const
LayerToParentLayerMatrix4x4
&
aPreviousTransformForRoot
const
LayerToParentLayerMatrix4x4
&
aCurrentTransformForRoot
const
ScreenMargin
&
aFixedLayerMargins
ClipPartsCache
&
aClipPartsCache
)
{
Layer
*
layer
=
aStartTraversalAt
;
bool
needsAsyncTransformUnapplied
=
false
;
if
(
Maybe
<
ScrollableLayerGuid
:
:
ViewID
>
fixedTo
=
IsFixedOrSticky
(
layer
)
)
{
needsAsyncTransformUnapplied
=
AsyncTransformShouldBeUnapplied
(
layer
*
fixedTo
aTransformedSubtreeRoot
aTransformScrollId
)
;
}
if
(
!
needsAsyncTransformUnapplied
)
{
for
(
Layer
*
child
=
layer
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
AlignFixedAndStickyLayers
(
aTransformedSubtreeRoot
child
aTransformScrollId
aPreviousTransformForRoot
aCurrentTransformForRoot
aFixedLayerMargins
aClipPartsCache
)
;
}
return
;
}
AdjustFixedOrStickyLayer
(
aTransformedSubtreeRoot
layer
aTransformScrollId
aPreviousTransformForRoot
aCurrentTransformForRoot
aFixedLayerMargins
aClipPartsCache
)
;
}
void
AsyncCompositionManager
:
:
AdjustFixedOrStickyLayer
(
Layer
*
aTransformedSubtreeRoot
Layer
*
aFixedOrSticky
ScrollableLayerGuid
:
:
ViewID
aTransformScrollId
const
LayerToParentLayerMatrix4x4
&
aPreviousTransformForRoot
const
LayerToParentLayerMatrix4x4
&
aCurrentTransformForRoot
const
ScreenMargin
&
aFixedLayerMargins
ClipPartsCache
&
aClipPartsCache
)
{
Layer
*
layer
=
aFixedOrSticky
;
Matrix4x4
ancestorTransform
;
if
(
layer
!
=
aTransformedSubtreeRoot
)
{
AccumulateLayerTransforms
(
layer
-
>
GetParent
(
)
aTransformedSubtreeRoot
ancestorTransform
)
;
}
ancestorTransform
.
NudgeToIntegersFixedEpsilon
(
)
;
if
(
layer
-
>
GetIsFixedPosition
(
)
)
{
MOZ_ASSERT
(
ancestorTransform
.
IsIdentity
(
)
)
;
}
auto
oldCumulativeTransform
=
ViewAs
<
LayerToParentLayerMatrix4x4
>
(
ancestorTransform
*
aPreviousTransformForRoot
.
ToUnknownMatrix
(
)
)
;
auto
newCumulativeTransform
=
ViewAs
<
LayerToParentLayerMatrix4x4
>
(
ancestorTransform
*
aCurrentTransformForRoot
.
ToUnknownMatrix
(
)
)
;
if
(
newCumulativeTransform
.
IsSingular
(
)
)
{
return
;
}
#
ifdef
DEBUG
Matrix4x4
localTransform
;
GetBaseTransform
(
layer
&
localTransform
)
;
localTransform
.
NudgeToIntegersFixedEpsilon
(
)
;
MOZ_ASSERT
(
localTransform
.
IsIdentity
(
)
)
;
#
endif
LayerPoint
anchor
=
layer
-
>
GetFixedPositionAnchor
(
)
;
LayerPoint
offsetAnchor
=
anchor
+
GetLayerFixedMarginsOffset
(
layer
aFixedLayerMargins
)
;
ParentLayerPoint
offsetAnchorInSubtreeRootSpace
=
oldCumulativeTransform
.
TransformPoint
(
offsetAnchor
)
;
LayerPoint
transformedAnchor
=
newCumulativeTransform
.
Inverse
(
)
.
TransformPoint
(
offsetAnchorInSubtreeRootSpace
)
;
LayerPoint
translation
=
transformedAnchor
-
anchor
;
LayerPoint
unconsumedTranslation
;
if
(
layer
-
>
GetIsStickyPosition
(
)
)
{
const
LayerRectAbsolute
&
stickyOuter
=
layer
-
>
GetStickyScrollRangeOuter
(
)
;
const
LayerRectAbsolute
&
stickyInner
=
layer
-
>
GetStickyScrollRangeInner
(
)
;
LayerPoint
originalTranslation
=
translation
;
translation
.
y
=
IntervalOverlap
(
translation
.
y
stickyOuter
.
Y
(
)
stickyOuter
.
YMost
(
)
)
-
IntervalOverlap
(
translation
.
y
stickyInner
.
Y
(
)
stickyInner
.
YMost
(
)
)
;
translation
.
x
=
IntervalOverlap
(
translation
.
x
stickyOuter
.
X
(
)
stickyOuter
.
XMost
(
)
)
-
IntervalOverlap
(
translation
.
x
stickyInner
.
X
(
)
stickyInner
.
XMost
(
)
)
;
unconsumedTranslation
=
translation
-
originalTranslation
;
}
TranslateShadowLayer
(
layer
ViewAs
<
ParentLayerPixel
>
(
translation
PixelCastJustification
:
:
NoTransformOnLayer
)
true
&
aClipPartsCache
)
;
if
(
unconsumedTranslation
!
=
LayerPoint
(
)
)
{
LayerPoint
newTransformedAnchor
=
unconsumedTranslation
+
anchor
;
ParentLayerPoint
newTransformedAnchorInSubtreeRootSpace
=
oldCumulativeTransform
.
TransformPoint
(
newTransformedAnchor
)
;
LayerToParentLayerMatrix4x4
newTransform
=
aPreviousTransformForRoot
;
newTransform
.
PostTranslate
(
newTransformedAnchorInSubtreeRootSpace
-
offsetAnchorInSubtreeRootSpace
)
;
for
(
Layer
*
child
=
layer
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
AlignFixedAndStickyLayers
(
aTransformedSubtreeRoot
child
aTransformScrollId
aPreviousTransformForRoot
newTransform
aFixedLayerMargins
aClipPartsCache
)
;
}
}
}
static
Matrix4x4
FrameTransformToTransformInDevice
(
const
Matrix4x4
&
aFrameTransform
Layer
*
aLayer
const
TransformData
&
aTransformData
)
{
Matrix4x4
transformInDevice
=
aFrameTransform
;
if
(
!
aLayer
-
>
GetParent
(
)
|
|
!
aLayer
-
>
GetParent
(
)
-
>
GetTransformIsPerspective
(
)
)
{
nsLayoutUtils
:
:
PostTranslate
(
transformInDevice
aTransformData
.
origin
(
)
aTransformData
.
appUnitsPerDevPixel
(
)
true
)
;
}
if
(
ContainerLayer
*
c
=
aLayer
-
>
AsContainerLayer
(
)
)
{
transformInDevice
.
PostScale
(
c
-
>
GetInheritedXScale
(
)
c
-
>
GetInheritedYScale
(
)
1
)
;
}
return
transformInDevice
;
}
static
void
ApplyAnimatedValue
(
Layer
*
aLayer
CompositorAnimationStorage
*
aStorage
nsCSSPropertyID
aProperty
const
Maybe
<
TransformData
>
&
aAnimationData
const
nsTArray
<
RefPtr
<
RawServoAnimationValue
>
>
&
aValues
)
{
MOZ_ASSERT
(
!
aValues
.
IsEmpty
(
)
)
;
HostLayer
*
layerCompositor
=
aLayer
-
>
AsHostLayer
(
)
;
switch
(
aProperty
)
{
case
eCSSProperty_background_color
:
{
MOZ_ASSERT
(
aValues
.
Length
(
)
=
=
1
)
;
nscolor
color
=
Servo_AnimationValue_GetColor
(
aValues
[
0
]
NS_RGBA
(
0
0
0
0
)
)
;
aLayer
-
>
AsColorLayer
(
)
-
>
SetColor
(
gfx
:
:
Color
:
:
FromABGR
(
color
)
)
;
aStorage
-
>
SetAnimatedValue
(
aLayer
-
>
GetCompositorAnimationsId
(
)
color
)
;
layerCompositor
-
>
SetShadowOpacity
(
aLayer
-
>
GetOpacity
(
)
)
;
layerCompositor
-
>
SetShadowOpacitySetByAnimation
(
false
)
;
layerCompositor
-
>
SetShadowBaseTransform
(
aLayer
-
>
GetBaseTransform
(
)
)
;
layerCompositor
-
>
SetShadowTransformSetByAnimation
(
false
)
;
break
;
}
case
eCSSProperty_opacity
:
{
MOZ_ASSERT
(
aValues
.
Length
(
)
=
=
1
)
;
float
opacity
=
Servo_AnimationValue_GetOpacity
(
aValues
[
0
]
)
;
layerCompositor
-
>
SetShadowOpacity
(
opacity
)
;
layerCompositor
-
>
SetShadowOpacitySetByAnimation
(
true
)
;
aStorage
-
>
SetAnimatedValue
(
aLayer
-
>
GetCompositorAnimationsId
(
)
opacity
)
;
layerCompositor
-
>
SetShadowBaseTransform
(
aLayer
-
>
GetBaseTransform
(
)
)
;
layerCompositor
-
>
SetShadowTransformSetByAnimation
(
false
)
;
break
;
}
case
eCSSProperty_rotate
:
case
eCSSProperty_scale
:
case
eCSSProperty_translate
:
case
eCSSProperty_transform
:
{
const
TransformData
&
transformData
=
aAnimationData
.
ref
(
)
;
Matrix4x4
frameTransform
=
AnimationHelper
:
:
ServoAnimationValueToMatrix4x4
(
aValues
transformData
)
;
Matrix4x4
transform
=
FrameTransformToTransformInDevice
(
frameTransform
aLayer
transformData
)
;
layerCompositor
-
>
SetShadowBaseTransform
(
transform
)
;
layerCompositor
-
>
SetShadowTransformSetByAnimation
(
true
)
;
aStorage
-
>
SetAnimatedValue
(
aLayer
-
>
GetCompositorAnimationsId
(
)
std
:
:
move
(
transform
)
std
:
:
move
(
frameTransform
)
transformData
)
;
layerCompositor
-
>
SetShadowOpacity
(
aLayer
-
>
GetOpacity
(
)
)
;
layerCompositor
-
>
SetShadowOpacitySetByAnimation
(
false
)
;
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unhandled
animated
property
"
)
;
}
}
static
bool
SampleAnimations
(
Layer
*
aLayer
CompositorAnimationStorage
*
aStorage
TimeStamp
aPreviousFrameTime
TimeStamp
aCurrentFrameTime
)
{
bool
isAnimating
=
false
;
ForEachNode
<
ForwardIterator
>
(
aLayer
[
&
]
(
Layer
*
layer
)
{
auto
&
propertyAnimationGroups
=
layer
-
>
GetPropertyAnimationGroups
(
)
;
if
(
propertyAnimationGroups
.
IsEmpty
(
)
)
{
return
;
}
isAnimating
=
true
;
AnimatedValue
*
previousValue
=
aStorage
-
>
GetAnimatedValue
(
layer
-
>
GetCompositorAnimationsId
(
)
)
;
nsTArray
<
RefPtr
<
RawServoAnimationValue
>
>
animationValues
;
AnimationHelper
:
:
SampleResult
sampleResult
=
AnimationHelper
:
:
SampleAnimationForEachNode
(
aPreviousFrameTime
aCurrentFrameTime
previousValue
propertyAnimationGroups
animationValues
)
;
const
PropertyAnimationGroup
&
lastPropertyAnimationGroup
=
propertyAnimationGroups
.
LastElement
(
)
;
switch
(
sampleResult
)
{
case
AnimationHelper
:
:
SampleResult
:
:
Sampled
:
ApplyAnimatedValue
(
layer
aStorage
lastPropertyAnimationGroup
.
mProperty
lastPropertyAnimationGroup
.
mAnimationData
animationValues
)
;
break
;
case
AnimationHelper
:
:
SampleResult
:
:
Skipped
:
switch
(
lastPropertyAnimationGroup
.
mProperty
)
{
case
eCSSProperty_background_color
:
case
eCSSProperty_opacity
:
{
if
(
lastPropertyAnimationGroup
.
mProperty
=
=
eCSSProperty_opacity
)
{
MOZ_ASSERT
(
layer
-
>
AsHostLayer
(
)
-
>
GetShadowOpacitySetByAnimation
(
)
)
;
#
ifdef
DEBUG
#
endif
}
HostLayer
*
layerCompositor
=
layer
-
>
AsHostLayer
(
)
;
layerCompositor
-
>
SetShadowBaseTransform
(
layer
-
>
GetBaseTransform
(
)
)
;
layerCompositor
-
>
SetShadowTransformSetByAnimation
(
false
)
;
break
;
}
case
eCSSProperty_rotate
:
case
eCSSProperty_scale
:
case
eCSSProperty_translate
:
case
eCSSProperty_transform
:
{
MOZ_ASSERT
(
layer
-
>
AsHostLayer
(
)
-
>
GetShadowTransformSetByAnimation
(
)
)
;
MOZ_ASSERT
(
previousValue
)
;
#
ifdef
DEBUG
const
TransformData
&
transformData
=
lastPropertyAnimationGroup
.
mAnimationData
.
ref
(
)
;
Matrix4x4
frameTransform
=
AnimationHelper
:
:
ServoAnimationValueToMatrix4x4
(
animationValues
transformData
)
;
Matrix4x4
transformInDevice
=
FrameTransformToTransformInDevice
(
frameTransform
layer
transformData
)
;
MOZ_ASSERT
(
previousValue
-
>
mTransform
.
mTransformInDevSpace
.
FuzzyEqualsMultiplicative
(
transformInDevice
)
)
;
#
endif
HostLayer
*
layerCompositor
=
layer
-
>
AsHostLayer
(
)
;
layerCompositor
-
>
SetShadowBaseTransform
(
previousValue
?
previousValue
-
>
mTransform
.
mTransformInDevSpace
:
layer
-
>
GetBaseTransform
(
)
)
;
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
properties
"
)
;
break
;
}
break
;
case
AnimationHelper
:
:
SampleResult
:
:
None
:
{
HostLayer
*
layerCompositor
=
layer
-
>
AsHostLayer
(
)
;
layerCompositor
-
>
SetShadowBaseTransform
(
layer
-
>
GetBaseTransform
(
)
)
;
layerCompositor
-
>
SetShadowTransformSetByAnimation
(
false
)
;
layerCompositor
-
>
SetShadowOpacity
(
layer
-
>
GetOpacity
(
)
)
;
layerCompositor
-
>
SetShadowOpacitySetByAnimation
(
false
)
;
break
;
}
default
:
break
;
}
}
)
;
return
isAnimating
;
}
void
AsyncCompositionManager
:
:
RecordShadowTransforms
(
Layer
*
aLayer
)
{
MOZ_ASSERT
(
gfxPrefs
:
:
CollectScrollTransforms
(
)
)
;
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
ForEachNodePostOrder
<
ForwardIterator
>
(
aLayer
[
this
]
(
Layer
*
layer
)
{
for
(
uint32_t
i
=
0
;
i
<
layer
-
>
GetScrollMetadataCount
(
)
;
i
+
+
)
{
if
(
!
layer
-
>
GetFrameMetrics
(
i
)
.
IsScrollable
(
)
)
{
continue
;
}
gfx
:
:
Matrix4x4
shadowTransform
=
layer
-
>
AsHostLayer
(
)
-
>
GetShadowBaseTransform
(
)
;
if
(
!
shadowTransform
.
Is2D
(
)
)
{
continue
;
}
Matrix
transform
=
shadowTransform
.
As2D
(
)
;
if
(
transform
.
IsTranslation
(
)
&
&
!
shadowTransform
.
IsIdentity
(
)
)
{
Point
translation
=
transform
.
GetTranslation
(
)
;
mLayerTransformRecorder
.
RecordTransform
(
layer
translation
)
;
return
;
}
}
}
)
;
}
static
AsyncTransformComponentMatrix
AdjustForClip
(
const
AsyncTransformComponentMatrix
&
asyncTransform
Layer
*
aLayer
)
{
AsyncTransformComponentMatrix
result
=
asyncTransform
;
if
(
const
Maybe
<
ParentLayerIntRect
>
&
shadowClipRect
=
aLayer
-
>
AsHostLayer
(
)
-
>
GetShadowClipRect
(
)
)
{
if
(
shadowClipRect
-
>
TopLeft
(
)
!
=
ParentLayerIntPoint
(
)
)
{
result
.
ChangeBasis
(
shadowClipRect
-
>
X
(
)
shadowClipRect
-
>
Y
(
)
0
)
;
}
}
return
result
;
}
static
void
ExpandRootClipRect
(
Layer
*
aLayer
const
ScreenMargin
&
aFixedLayerMargins
)
{
Maybe
<
ParentLayerIntRect
>
rootClipRect
=
aLayer
-
>
AsHostLayer
(
)
-
>
GetShadowClipRect
(
)
;
if
(
rootClipRect
&
&
aFixedLayerMargins
!
=
ScreenMargin
(
)
)
{
#
ifndef
MOZ_WIDGET_ANDROID
MOZ_ASSERT
(
false
)
;
#
endif
ParentLayerRect
rect
(
rootClipRect
.
value
(
)
)
;
rect
.
Deflate
(
ViewAs
<
ParentLayerPixel
>
(
aFixedLayerMargins
PixelCastJustification
:
:
ScreenIsParentLayerForRoot
)
)
;
aLayer
-
>
AsHostLayer
(
)
-
>
SetShadowClipRect
(
Some
(
RoundedOut
(
rect
)
)
)
;
}
}
#
ifdef
MOZ_WIDGET_ANDROID
static
void
MoveScrollbarForLayerMargin
(
Layer
*
aRoot
ScrollableLayerGuid
:
:
ViewID
aRootScrollId
const
ScreenMargin
&
aFixedLayerMargins
)
{
Layer
*
scrollbar
=
BreadthFirstSearch
<
ReverseIterator
>
(
aRoot
[
aRootScrollId
]
(
Layer
*
aNode
)
{
return
(
aNode
-
>
GetScrollbarData
(
)
.
IsThumb
(
)
&
&
aNode
-
>
GetScrollbarData
(
)
.
mDirection
.
isSome
(
)
&
&
*
aNode
-
>
GetScrollbarData
(
)
.
mDirection
=
=
ScrollDirection
:
:
eHorizontal
&
&
aNode
-
>
GetScrollbarData
(
)
.
mTargetViewId
=
=
aRootScrollId
)
;
}
)
;
if
(
scrollbar
)
{
TranslateShadowLayer
(
scrollbar
ParentLayerPoint
(
0
-
aFixedLayerMargins
.
bottom
)
true
nullptr
)
;
if
(
scrollbar
-
>
GetParent
(
)
)
{
ExpandRootClipRect
(
scrollbar
-
>
GetParent
(
)
aFixedLayerMargins
)
;
}
}
}
#
endif
bool
AsyncCompositionManager
:
:
ApplyAsyncContentTransformToTree
(
Layer
*
aLayer
bool
*
aOutFoundRoot
)
{
bool
appliedTransform
=
false
;
std
:
:
stack
<
Maybe
<
ParentLayerIntRect
>
>
stackDeferredClips
;
ClipPartsCache
clipPartsCache
;
Layer
*
zoomContainer
=
nullptr
;
Maybe
<
LayerMetricsWrapper
>
zoomedMetrics
;
ForEachNode
<
ForwardIterator
>
(
aLayer
[
&
]
(
Layer
*
layer
)
{
stackDeferredClips
.
push
(
Maybe
<
ParentLayerIntRect
>
(
)
)
;
if
(
Maybe
<
ScrollableLayerGuid
:
:
ViewID
>
zoomedScrollId
=
layer
-
>
IsAsyncZoomContainer
(
)
)
{
zoomContainer
=
layer
;
ForEachNode
<
ForwardIterator
>
(
LayerMetricsWrapper
(
layer
)
[
zoomedScrollId
&
zoomedMetrics
]
(
LayerMetricsWrapper
aWrapper
)
{
if
(
aWrapper
.
AsRefLayer
(
)
)
{
return
TraversalFlag
:
:
Skip
;
}
if
(
aWrapper
.
Metrics
(
)
.
GetScrollId
(
)
=
=
*
zoomedScrollId
)
{
zoomedMetrics
=
Some
(
aWrapper
)
;
MOZ_ASSERT
(
zoomedMetrics
-
>
GetApzc
(
)
)
;
return
TraversalFlag
:
:
Abort
;
}
return
TraversalFlag
:
:
Continue
;
}
)
;
}
}
[
&
]
(
Layer
*
layer
)
{
Maybe
<
ParentLayerIntRect
>
clipDeferredFromChildren
=
stackDeferredClips
.
top
(
)
;
stackDeferredClips
.
pop
(
)
;
LayerToParentLayerMatrix4x4
oldTransform
=
layer
-
>
GetTransformTyped
(
)
*
AsyncTransformMatrix
(
)
;
AsyncTransformComponentMatrix
combinedAsyncTransform
;
bool
hasAsyncTransform
=
false
;
ScreenMargin
fixedLayerMargins
;
ClipParts
&
clipParts
=
clipPartsCache
[
layer
]
;
clipParts
.
mFixedClip
=
layer
-
>
GetClipRect
(
)
;
clipParts
.
mScrolledClip
=
layer
-
>
GetScrolledClipRect
(
)
;
clipParts
.
mScrolledClip
=
IntersectMaybeRects
(
clipDeferredFromChildren
clipParts
.
mScrolledClip
)
;
nsTArray
<
Layer
*
>
ancestorMaskLayers
;
if
(
const
Maybe
<
LayerClip
>
&
scrolledClip
=
layer
-
>
GetScrolledClip
(
)
)
{
if
(
scrolledClip
-
>
GetMaskLayerIndex
(
)
)
{
ancestorMaskLayers
.
AppendElement
(
layer
-
>
GetAncestorMaskLayerAt
(
*
scrolledClip
-
>
GetMaskLayerIndex
(
)
)
)
;
}
}
if
(
RefPtr
<
APZSampler
>
sampler
=
mCompositorBridge
-
>
GetAPZSampler
(
)
)
{
for
(
uint32_t
i
=
0
;
i
<
layer
-
>
GetScrollMetadataCount
(
)
;
i
+
+
)
{
LayerMetricsWrapper
wrapper
(
layer
i
)
;
if
(
!
wrapper
.
GetApzc
(
)
)
{
continue
;
}
const
FrameMetrics
&
metrics
=
wrapper
.
Metrics
(
)
;
MOZ_ASSERT
(
metrics
.
IsScrollable
(
)
)
;
hasAsyncTransform
=
true
;
AsyncTransformComponents
asyncTransformComponents
=
(
zoomedMetrics
&
&
sampler
-
>
GetGuid
(
*
zoomedMetrics
)
=
=
sampler
-
>
GetGuid
(
wrapper
)
)
?
AsyncTransformComponents
{
AsyncTransformComponent
:
:
eLayout
}
:
LayoutAndVisual
;
AsyncTransform
asyncTransformWithoutOverscroll
=
sampler
-
>
GetCurrentAsyncTransform
(
wrapper
asyncTransformComponents
)
;
AsyncTransformComponentMatrix
overscrollTransform
=
sampler
-
>
GetOverscrollTransform
(
wrapper
)
;
AsyncTransformComponentMatrix
asyncTransform
=
AsyncTransformComponentMatrix
(
asyncTransformWithoutOverscroll
)
*
overscrollTransform
;
if
(
!
layer
-
>
IsScrollableWithoutContent
(
)
)
{
sampler
-
>
MarkAsyncTransformAppliedToContent
(
wrapper
)
;
}
const
ScrollMetadata
&
scrollMetadata
=
wrapper
.
Metadata
(
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
if
(
!
(
*
aOutFoundRoot
)
)
{
*
aOutFoundRoot
=
metrics
.
IsRootContent
(
)
|
|
(
layer
-
>
GetParent
(
)
=
=
nullptr
&
&
i
+
1
>
=
layer
-
>
GetScrollMetadataCount
(
)
)
;
if
(
*
aOutFoundRoot
)
{
mRootScrollableId
=
metrics
.
GetScrollId
(
)
;
Compositor
*
compositor
=
mLayerManager
-
>
GetCompositor
(
)
;
if
(
CompositorBridgeParent
*
bridge
=
compositor
-
>
GetCompositorBridgeParent
(
)
)
{
AndroidDynamicToolbarAnimator
*
animator
=
bridge
-
>
GetAndroidDynamicToolbarAnimator
(
)
;
LayersId
rootLayerTreeId
=
bridge
-
>
RootLayerTreeId
(
)
;
if
(
mIsFirstPaint
|
|
FrameMetricsHaveUpdated
(
metrics
)
)
{
if
(
animator
)
{
animator
-
>
UpdateRootFrameMetrics
(
metrics
)
;
}
else
if
(
RefPtr
<
UiCompositorControllerParent
>
uiController
=
UiCompositorControllerParent
:
:
GetFromRootLayerTreeId
(
rootLayerTreeId
)
)
{
uiController
-
>
NotifyUpdateScreenMetrics
(
metrics
)
;
}
mLastMetrics
=
metrics
;
}
if
(
mIsFirstPaint
)
{
if
(
animator
)
{
animator
-
>
FirstPaint
(
)
;
}
if
(
RefPtr
<
UiCompositorControllerParent
>
uiController
=
UiCompositorControllerParent
:
:
GetFromRootLayerTreeId
(
rootLayerTreeId
)
)
{
uiController
-
>
NotifyFirstPaint
(
)
;
}
mIsFirstPaint
=
false
;
}
if
(
mLayersUpdated
)
{
LayersId
rootLayerTreeId
=
bridge
-
>
RootLayerTreeId
(
)
;
if
(
RefPtr
<
UiCompositorControllerParent
>
uiController
=
UiCompositorControllerParent
:
:
GetFromRootLayerTreeId
(
rootLayerTreeId
)
)
{
uiController
-
>
NotifyLayersUpdated
(
)
;
}
mLayersUpdated
=
false
;
}
if
(
animator
&
&
!
metrics
.
IsRootContent
(
)
)
{
animator
-
>
MaybeUpdateCompositionSizeAndRootFrameMetrics
(
metrics
)
;
}
}
fixedLayerMargins
=
mFixedLayerMargins
;
}
}
#
else
*
aOutFoundRoot
=
false
;
mIsFirstPaint
=
false
;
#
endif
if
(
!
scrollMetadata
.
UsesContainerScrolling
(
)
)
{
MOZ_ASSERT
(
asyncTransform
.
Is2D
(
)
)
;
if
(
clipParts
.
mFixedClip
)
{
*
clipParts
.
mFixedClip
=
TransformBy
(
asyncTransform
*
clipParts
.
mFixedClip
)
;
}
if
(
clipParts
.
mScrolledClip
)
{
*
clipParts
.
mScrolledClip
=
TransformBy
(
asyncTransform
*
clipParts
.
mScrolledClip
)
;
}
}
combinedAsyncTransform
*
=
asyncTransform
;
AsyncTransform
asyncTransformForFixedAdjustment
=
sampler
-
>
GetCurrentAsyncTransformForFixedAdjustment
(
wrapper
)
;
LayerToParentLayerMatrix4x4
transformWithoutOverscrollOrOmta
=
layer
-
>
GetTransformTyped
(
)
*
CompleteAsyncTransform
(
AdjustForClip
(
asyncTransformForFixedAdjustment
layer
)
)
;
AlignFixedAndStickyLayers
(
layer
layer
metrics
.
GetScrollId
(
)
oldTransform
transformWithoutOverscrollOrOmta
fixedLayerMargins
clipPartsCache
)
;
if
(
scrollMetadata
.
HasScrollClip
(
)
)
{
ParentLayerIntRect
clip
=
scrollMetadata
.
ScrollClip
(
)
.
GetClipRect
(
)
;
if
(
layer
-
>
GetParent
(
)
&
&
layer
-
>
GetParent
(
)
-
>
GetTransformIsPerspective
(
)
)
{
MOZ_ASSERT
(
!
stackDeferredClips
.
top
(
)
)
;
stackDeferredClips
.
top
(
)
.
emplace
(
clip
)
;
}
else
{
clipParts
.
mScrolledClip
=
IntersectMaybeRects
(
Some
(
clip
)
clipParts
.
mScrolledClip
)
;
}
}
for
(
Layer
*
ancestorMaskLayer
:
ancestorMaskLayers
)
{
SetShadowTransform
(
ancestorMaskLayer
ancestorMaskLayer
-
>
GetLocalTransformTyped
(
)
*
asyncTransform
)
;
}
if
(
scrollMetadata
.
HasScrollClip
(
)
)
{
const
LayerClip
&
scrollClip
=
scrollMetadata
.
ScrollClip
(
)
;
if
(
scrollClip
.
GetMaskLayerIndex
(
)
)
{
size_t
maskLayerIndex
=
scrollClip
.
GetMaskLayerIndex
(
)
.
value
(
)
;
Layer
*
ancestorMaskLayer
=
layer
-
>
GetAncestorMaskLayerAt
(
maskLayerIndex
)
;
ancestorMaskLayers
.
AppendElement
(
ancestorMaskLayer
)
;
}
}
}
if
(
Maybe
<
ScrollableLayerGuid
:
:
ViewID
>
zoomedScrollId
=
layer
-
>
IsAsyncZoomContainer
(
)
)
{
if
(
zoomedMetrics
)
{
AsyncTransform
zoomTransform
=
sampler
-
>
GetCurrentAsyncTransform
(
*
zoomedMetrics
{
AsyncTransformComponent
:
:
eVisual
}
)
;
hasAsyncTransform
=
true
;
combinedAsyncTransform
*
=
AsyncTransformComponentMatrix
(
zoomTransform
)
;
}
else
{
}
}
}
bool
clipChanged
=
(
hasAsyncTransform
|
|
clipDeferredFromChildren
|
|
layer
-
>
GetScrolledClipRect
(
)
)
;
if
(
clipChanged
)
{
layer
-
>
AsHostLayer
(
)
-
>
SetShadowClipRect
(
clipParts
.
Intersect
(
)
)
;
}
if
(
hasAsyncTransform
)
{
SetShadowTransform
(
layer
layer
-
>
GetLocalTransformTyped
(
)
*
AdjustForClip
(
combinedAsyncTransform
layer
)
)
;
if
(
Layer
*
maskLayer
=
layer
-
>
GetMaskLayer
(
)
)
{
SetShadowTransform
(
maskLayer
maskLayer
-
>
GetLocalTransformTyped
(
)
*
combinedAsyncTransform
)
;
}
appliedTransform
=
true
;
}
ExpandRootClipRect
(
layer
fixedLayerMargins
)
;
if
(
layer
-
>
GetScrollbarData
(
)
.
mScrollbarLayerType
=
=
layers
:
:
ScrollbarLayerType
:
:
Thumb
)
{
ApplyAsyncTransformToScrollbar
(
layer
)
;
}
}
)
;
return
appliedTransform
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
bool
AsyncCompositionManager
:
:
FrameMetricsHaveUpdated
(
const
FrameMetrics
&
aMetrics
)
{
return
RoundedToInt
(
mLastMetrics
.
GetScrollOffset
(
)
)
!
=
RoundedToInt
(
aMetrics
.
GetScrollOffset
(
)
)
|
|
mLastMetrics
.
GetZoom
(
)
!
=
aMetrics
.
GetZoom
(
)
;
;
}
#
endif
static
bool
LayerIsScrollbarTarget
(
const
LayerMetricsWrapper
&
aTarget
Layer
*
aScrollbar
)
{
if
(
!
aTarget
.
GetApzc
(
)
)
{
return
false
;
}
const
FrameMetrics
&
metrics
=
aTarget
.
Metrics
(
)
;
MOZ_ASSERT
(
metrics
.
IsScrollable
(
)
)
;
if
(
metrics
.
GetScrollId
(
)
!
=
aScrollbar
-
>
GetScrollbarData
(
)
.
mTargetViewId
)
{
return
false
;
}
return
!
metrics
.
IsScrollInfoLayer
(
)
;
}
static
void
ApplyAsyncTransformToScrollbarForContent
(
const
RefPtr
<
APZSampler
>
&
aSampler
Layer
*
aScrollbar
const
LayerMetricsWrapper
&
aContent
bool
aScrollbarIsDescendant
)
{
AsyncTransformComponentMatrix
clipTransform
;
MOZ_ASSERT
(
aSampler
)
;
LayerToParentLayerMatrix4x4
transform
=
aSampler
-
>
ComputeTransformForScrollThumb
(
aScrollbar
-
>
GetLocalTransformTyped
(
)
aContent
aScrollbar
-
>
GetScrollbarData
(
)
aScrollbarIsDescendant
&
clipTransform
)
;
if
(
aScrollbarIsDescendant
)
{
for
(
Layer
*
ancestor
=
aScrollbar
;
ancestor
!
=
aContent
.
GetLayer
(
)
;
ancestor
=
ancestor
-
>
GetParent
(
)
)
{
TransformClipRect
(
ancestor
clipTransform
)
;
}
}
SetShadowTransform
(
aScrollbar
transform
)
;
}
static
LayerMetricsWrapper
FindScrolledLayerForScrollbar
(
Layer
*
aScrollbar
bool
*
aOutIsAncestor
)
{
LayerMetricsWrapper
root
(
aScrollbar
-
>
Manager
(
)
-
>
GetRoot
(
)
)
;
LayerMetricsWrapper
prevAncestor
(
aScrollbar
)
;
LayerMetricsWrapper
scrolledLayer
;
for
(
LayerMetricsWrapper
ancestor
(
aScrollbar
)
;
ancestor
;
ancestor
=
ancestor
.
GetParent
(
)
)
{
if
(
ancestor
.
AsRefLayer
(
)
)
{
root
=
prevAncestor
;
break
;
}
prevAncestor
=
ancestor
;
if
(
LayerIsScrollbarTarget
(
ancestor
aScrollbar
)
)
{
*
aOutIsAncestor
=
true
;
return
ancestor
;
}
}
ForEachNode
<
ForwardIterator
>
(
root
[
&
root
&
scrolledLayer
&
aScrollbar
]
(
LayerMetricsWrapper
aLayerMetrics
)
{
if
(
root
!
=
aLayerMetrics
&
&
aLayerMetrics
.
AsRefLayer
(
)
)
{
return
TraversalFlag
:
:
Skip
;
}
if
(
LayerIsScrollbarTarget
(
aLayerMetrics
aScrollbar
)
)
{
scrolledLayer
=
aLayerMetrics
;
return
TraversalFlag
:
:
Abort
;
}
return
TraversalFlag
:
:
Continue
;
}
)
;
return
scrolledLayer
;
}
void
AsyncCompositionManager
:
:
ApplyAsyncTransformToScrollbar
(
Layer
*
aLayer
)
{
bool
isAncestor
=
false
;
const
LayerMetricsWrapper
&
scrollTarget
=
FindScrolledLayerForScrollbar
(
aLayer
&
isAncestor
)
;
if
(
scrollTarget
)
{
ApplyAsyncTransformToScrollbarForContent
(
mCompositorBridge
-
>
GetAPZSampler
(
)
aLayer
scrollTarget
isAncestor
)
;
}
}
void
AsyncCompositionManager
:
:
GetFrameUniformity
(
FrameUniformityData
*
aOutData
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
mLayerTransformRecorder
.
EndTest
(
aOutData
)
;
}
bool
AsyncCompositionManager
:
:
TransformShadowTree
(
TimeStamp
aCurrentFrame
TimeDuration
aVsyncRate
CompositorBridgeParentBase
:
:
TransformsToSkip
aSkip
)
{
AUTO_PROFILER_LABEL
(
"
AsyncCompositionManager
:
:
TransformShadowTree
"
GRAPHICS
)
;
Layer
*
root
=
mLayerManager
-
>
GetRoot
(
)
;
if
(
!
root
)
{
return
false
;
}
CompositorAnimationStorage
*
storage
=
mCompositorBridge
-
>
GetAnimationStorage
(
)
;
bool
wantNextFrame
=
SampleAnimations
(
root
storage
mPreviousFrameTimeStamp
aCurrentFrame
)
;
if
(
!
wantNextFrame
)
{
storage
-
>
Clear
(
)
;
}
TimeStamp
nextFrame
=
aCurrentFrame
;
MOZ_ASSERT
(
aVsyncRate
!
=
TimeDuration
:
:
Forever
(
)
)
;
if
(
aVsyncRate
!
=
TimeDuration
:
:
Forever
(
)
)
{
nextFrame
+
=
aVsyncRate
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
Compositor
*
compositor
=
mLayerManager
-
>
GetCompositor
(
)
;
if
(
CompositorBridgeParent
*
bridge
=
compositor
-
>
GetCompositorBridgeParent
(
)
)
{
if
(
AndroidDynamicToolbarAnimator
*
animator
=
bridge
-
>
GetAndroidDynamicToolbarAnimator
(
)
)
{
wantNextFrame
|
=
animator
-
>
UpdateAnimation
(
nextFrame
)
;
}
}
#
endif
mPreviousFrameTimeStamp
=
wantNextFrame
?
aCurrentFrame
:
TimeStamp
(
)
;
if
(
!
(
aSkip
&
CompositorBridgeParentBase
:
:
TransformsToSkip
:
:
APZ
)
)
{
bool
foundRoot
=
false
;
if
(
ApplyAsyncContentTransformToTree
(
root
&
foundRoot
)
)
{
#
if
defined
(
MOZ_WIDGET_ANDROID
)
MOZ_ASSERT
(
foundRoot
)
;
if
(
foundRoot
&
&
mFixedLayerMargins
!
=
ScreenMargin
(
)
)
{
MoveScrollbarForLayerMargin
(
root
mRootScrollableId
mFixedLayerMargins
)
;
}
#
endif
}
bool
apzAnimating
=
false
;
if
(
RefPtr
<
APZSampler
>
apz
=
mCompositorBridge
-
>
GetAPZSampler
(
)
)
{
apzAnimating
=
apz
-
>
SampleAnimations
(
LayerMetricsWrapper
(
root
)
nextFrame
)
;
}
wantNextFrame
|
=
apzAnimating
;
}
HostLayer
*
rootComposite
=
root
-
>
AsHostLayer
(
)
;
gfx
:
:
Matrix4x4
trans
=
rootComposite
-
>
GetShadowBaseTransform
(
)
;
trans
*
=
gfx
:
:
Matrix4x4
:
:
From2D
(
mWorldTransform
)
;
rootComposite
-
>
SetShadowBaseTransform
(
trans
)
;
if
(
gfxPrefs
:
:
CollectScrollTransforms
(
)
)
{
RecordShadowTransforms
(
root
)
;
}
return
wantNextFrame
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
void
AsyncCompositionManager
:
:
SetFixedLayerMargins
(
ScreenIntCoord
aTop
ScreenIntCoord
aBottom
)
{
mFixedLayerMargins
.
top
=
aTop
;
mFixedLayerMargins
.
bottom
=
aBottom
;
}
#
endif
}
}
