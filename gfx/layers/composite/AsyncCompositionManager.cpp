#
include
"
mozilla
/
layers
/
AsyncCompositionManager
.
h
"
#
include
<
stdint
.
h
>
#
include
"
apz
/
src
/
AsyncPanZoomController
.
h
"
#
include
"
FrameMetrics
.
h
"
#
include
"
LayerManagerComposite
.
h
"
#
include
"
Layers
.
h
"
#
include
"
gfxPoint
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
WidgetUtils
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffectReadOnly
.
h
"
#
include
"
mozilla
/
dom
/
AnimationEffectReadOnlyBinding
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffectBinding
.
h
"
#
include
"
mozilla
/
gfx
/
BaseRect
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
ScaleFactor
.
h
"
#
include
"
mozilla
/
layers
/
APZUtils
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
LayerAnimationUtils
.
h
"
#
include
"
mozilla
/
layers
/
LayerMetricsWrapper
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsMathUtils
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
#
include
"
UnitTransforms
.
h
"
#
include
"
gfxPrefs
.
h
"
#
if
defined
(
MOZ_WIDGET_ANDROID
)
#
include
<
android
/
log
.
h
>
#
include
"
mozilla
/
widget
/
AndroidCompositorWidget
.
h
"
#
endif
#
include
"
GeckoProfiler
.
h
"
#
include
"
FrameUniformityData
.
h
"
#
include
"
TreeTraversal
.
h
"
#
include
"
VsyncSource
.
h
"
struct
nsCSSValueSharedList
;
namespace
mozilla
{
namespace
layers
{
using
namespace
mozilla
:
:
gfx
;
static
bool
IsSameDimension
(
dom
:
:
ScreenOrientationInternal
o1
dom
:
:
ScreenOrientationInternal
o2
)
{
bool
isO1portrait
=
(
o1
=
=
dom
:
:
eScreenOrientation_PortraitPrimary
|
|
o1
=
=
dom
:
:
eScreenOrientation_PortraitSecondary
)
;
bool
isO2portrait
=
(
o2
=
=
dom
:
:
eScreenOrientation_PortraitPrimary
|
|
o2
=
=
dom
:
:
eScreenOrientation_PortraitSecondary
)
;
return
!
(
isO1portrait
^
isO2portrait
)
;
}
static
bool
ContentMightReflowOnOrientationChange
(
const
IntRect
&
rect
)
{
return
rect
.
width
!
=
rect
.
height
;
}
AsyncCompositionManager
:
:
AsyncCompositionManager
(
LayerManagerComposite
*
aManager
)
:
mLayerManager
(
aManager
)
mIsFirstPaint
(
true
)
mLayersUpdated
(
false
)
mPaintSyncId
(
0
)
mReadyForCompose
(
true
)
{
}
AsyncCompositionManager
:
:
~
AsyncCompositionManager
(
)
{
}
void
AsyncCompositionManager
:
:
ResolveRefLayers
(
CompositorBridgeParent
*
aCompositor
bool
*
aHasRemoteContent
bool
*
aResolvePlugins
)
{
if
(
aHasRemoteContent
)
{
*
aHasRemoteContent
=
false
;
}
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
bool
resolvePlugins
=
(
aCompositor
&
&
aResolvePlugins
&
&
*
aResolvePlugins
)
;
#
endif
if
(
!
mLayerManager
-
>
GetRoot
(
)
)
{
if
(
aResolvePlugins
)
{
*
aResolvePlugins
=
false
;
}
return
;
}
mReadyForCompose
=
true
;
bool
hasRemoteContent
=
false
;
bool
didResolvePlugins
=
false
;
ForEachNode
<
ForwardIterator
>
(
mLayerManager
-
>
GetRoot
(
)
[
&
]
(
Layer
*
layer
)
{
RefLayer
*
refLayer
=
layer
-
>
AsRefLayer
(
)
;
if
(
!
refLayer
)
{
return
;
}
hasRemoteContent
=
true
;
const
CompositorBridgeParent
:
:
LayerTreeState
*
state
=
CompositorBridgeParent
:
:
GetIndirectShadowTree
(
refLayer
-
>
GetReferentId
(
)
)
;
if
(
!
state
)
{
return
;
}
Layer
*
referent
=
state
-
>
mRoot
;
if
(
!
referent
)
{
return
;
}
if
(
!
refLayer
-
>
GetLocalVisibleRegion
(
)
.
IsEmpty
(
)
)
{
dom
:
:
ScreenOrientationInternal
chromeOrientation
=
mTargetConfig
.
orientation
(
)
;
dom
:
:
ScreenOrientationInternal
contentOrientation
=
state
-
>
mTargetConfig
.
orientation
(
)
;
if
(
!
IsSameDimension
(
chromeOrientation
contentOrientation
)
&
&
ContentMightReflowOnOrientationChange
(
mTargetConfig
.
naturalBounds
(
)
)
)
{
mReadyForCompose
=
false
;
}
}
refLayer
-
>
ConnectReferentLayer
(
referent
)
;
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
if
(
resolvePlugins
)
{
didResolvePlugins
|
=
aCompositor
-
>
UpdatePluginWindowState
(
refLayer
-
>
GetReferentId
(
)
)
;
}
#
endif
}
)
;
if
(
aHasRemoteContent
)
{
*
aHasRemoteContent
=
hasRemoteContent
;
}
if
(
aResolvePlugins
)
{
*
aResolvePlugins
=
didResolvePlugins
;
}
}
void
AsyncCompositionManager
:
:
DetachRefLayers
(
)
{
if
(
!
mLayerManager
-
>
GetRoot
(
)
)
{
return
;
}
mReadyForCompose
=
false
;
ForEachNodePostOrder
<
ForwardIterator
>
(
mLayerManager
-
>
GetRoot
(
)
[
&
]
(
Layer
*
layer
)
{
RefLayer
*
refLayer
=
layer
-
>
AsRefLayer
(
)
;
if
(
!
refLayer
)
{
return
;
}
const
CompositorBridgeParent
:
:
LayerTreeState
*
state
=
CompositorBridgeParent
:
:
GetIndirectShadowTree
(
refLayer
-
>
GetReferentId
(
)
)
;
if
(
!
state
)
{
return
;
}
Layer
*
referent
=
state
-
>
mRoot
;
if
(
referent
)
{
refLayer
-
>
DetachReferentLayer
(
referent
)
;
}
}
)
;
}
void
AsyncCompositionManager
:
:
ComputeRotation
(
)
{
if
(
!
mTargetConfig
.
naturalBounds
(
)
.
IsEmpty
(
)
)
{
mWorldTransform
=
ComputeTransformForRotation
(
mTargetConfig
.
naturalBounds
(
)
mTargetConfig
.
rotation
(
)
)
;
}
}
#
ifdef
DEBUG
static
void
GetBaseTransform
(
Layer
*
aLayer
Matrix4x4
*
aTransform
)
{
*
aTransform
=
(
aLayer
-
>
AsLayerComposite
(
)
-
>
GetShadowTransformSetByAnimation
(
)
?
aLayer
-
>
GetLocalTransform
(
)
:
aLayer
-
>
GetTransform
(
)
)
;
}
#
endif
static
void
TransformClipRect
(
Layer
*
aLayer
const
ParentLayerToParentLayerMatrix4x4
&
aTransform
)
{
MOZ_ASSERT
(
aTransform
.
Is2D
(
)
)
;
const
Maybe
<
ParentLayerIntRect
>
&
clipRect
=
aLayer
-
>
AsLayerComposite
(
)
-
>
GetShadowClipRect
(
)
;
if
(
clipRect
)
{
ParentLayerIntRect
transformed
=
TransformBy
(
aTransform
*
clipRect
)
;
aLayer
-
>
AsLayerComposite
(
)
-
>
SetShadowClipRect
(
Some
(
transformed
)
)
;
}
}
static
void
TransformFixedClip
(
Layer
*
aLayer
const
ParentLayerToParentLayerMatrix4x4
&
aTransform
AsyncCompositionManager
:
:
ClipParts
&
aClipParts
)
{
MOZ_ASSERT
(
aTransform
.
Is2D
(
)
)
;
if
(
aClipParts
.
mFixedClip
)
{
*
aClipParts
.
mFixedClip
=
TransformBy
(
aTransform
*
aClipParts
.
mFixedClip
)
;
aLayer
-
>
AsLayerComposite
(
)
-
>
SetShadowClipRect
(
aClipParts
.
Intersect
(
)
)
;
}
}
static
void
SetShadowTransform
(
Layer
*
aLayer
LayerToParentLayerMatrix4x4
aTransform
)
{
if
(
ContainerLayer
*
c
=
aLayer
-
>
AsContainerLayer
(
)
)
{
aTransform
.
PreScale
(
1
.
0f
/
c
-
>
GetPreXScale
(
)
1
.
0f
/
c
-
>
GetPreYScale
(
)
1
)
;
}
aTransform
.
PostScale
(
1
.
0f
/
aLayer
-
>
GetPostXScale
(
)
1
.
0f
/
aLayer
-
>
GetPostYScale
(
)
1
)
;
aLayer
-
>
AsLayerComposite
(
)
-
>
SetShadowBaseTransform
(
aTransform
.
ToUnknownMatrix
(
)
)
;
}
static
void
TranslateShadowLayer
(
Layer
*
aLayer
const
ParentLayerPoint
&
aTranslation
bool
aAdjustClipRect
AsyncCompositionManager
:
:
ClipPartsCache
*
aClipPartsCache
)
{
LayerToParentLayerMatrix4x4
layerTransform
=
aLayer
-
>
GetLocalTransformTyped
(
)
;
layerTransform
.
PostTranslate
(
aTranslation
)
;
SetShadowTransform
(
aLayer
layerTransform
)
;
aLayer
-
>
AsLayerComposite
(
)
-
>
SetShadowTransformSetByAnimation
(
false
)
;
if
(
aAdjustClipRect
)
{
auto
transform
=
ParentLayerToParentLayerMatrix4x4
:
:
Translation
(
aTranslation
)
;
if
(
aClipPartsCache
)
{
auto
iter
=
aClipPartsCache
-
>
find
(
aLayer
)
;
MOZ_ASSERT
(
iter
!
=
aClipPartsCache
-
>
end
(
)
)
;
TransformFixedClip
(
aLayer
transform
iter
-
>
second
)
;
}
else
{
TransformClipRect
(
aLayer
transform
)
;
}
if
(
Layer
*
maskLayer
=
aLayer
-
>
GetMaskLayer
(
)
)
{
TranslateShadowLayer
(
maskLayer
aTranslation
false
aClipPartsCache
)
;
}
}
}
#
ifdef
DEBUG
static
void
AccumulateLayerTransforms
(
Layer
*
aLayer
Layer
*
aAncestor
Matrix4x4
&
aMatrix
)
{
for
(
Layer
*
l
=
aLayer
;
l
&
&
l
!
=
aAncestor
;
l
=
l
-
>
GetParent
(
)
)
{
Matrix4x4
transform
;
GetBaseTransform
(
l
&
transform
)
;
aMatrix
*
=
transform
;
}
}
#
endif
static
LayerPoint
GetLayerFixedMarginsOffset
(
Layer
*
aLayer
const
ScreenMargin
&
aFixedLayerMargins
)
{
LayerPoint
translation
;
int32_t
sides
=
aLayer
-
>
GetFixedPositionSides
(
)
;
if
(
(
sides
&
eSideBitsLeftRight
)
=
=
eSideBitsLeftRight
)
{
translation
.
x
+
=
(
aFixedLayerMargins
.
left
-
aFixedLayerMargins
.
right
)
/
2
;
}
else
if
(
sides
&
eSideBitsRight
)
{
translation
.
x
-
=
aFixedLayerMargins
.
right
;
}
else
if
(
sides
&
eSideBitsLeft
)
{
translation
.
x
+
=
aFixedLayerMargins
.
left
;
}
if
(
(
sides
&
eSideBitsTopBottom
)
=
=
eSideBitsTopBottom
)
{
translation
.
y
+
=
(
aFixedLayerMargins
.
top
-
aFixedLayerMargins
.
bottom
)
/
2
;
}
else
if
(
sides
&
eSideBitsBottom
)
{
translation
.
y
-
=
aFixedLayerMargins
.
bottom
;
}
else
if
(
sides
&
eSideBitsTop
)
{
translation
.
y
+
=
aFixedLayerMargins
.
top
;
}
return
translation
;
}
static
gfxFloat
IntervalOverlap
(
gfxFloat
aTranslation
gfxFloat
aMin
gfxFloat
aMax
)
{
if
(
aTranslation
>
0
)
{
return
std
:
:
max
(
0
.
0
std
:
:
min
(
aMax
aTranslation
)
-
std
:
:
max
(
aMin
0
.
0
)
)
;
}
else
{
return
std
:
:
min
(
0
.
0
std
:
:
max
(
aMin
aTranslation
)
-
std
:
:
min
(
aMax
0
.
0
)
)
;
}
}
static
LayerMetricsWrapper
FindMetricsWithScrollId
(
Layer
*
aLayer
FrameMetrics
:
:
ViewID
aScrollId
)
{
for
(
uint64_t
i
=
0
;
i
<
aLayer
-
>
GetScrollMetadataCount
(
)
;
+
+
i
)
{
if
(
aLayer
-
>
GetFrameMetrics
(
i
)
.
GetScrollId
(
)
=
=
aScrollId
)
{
return
LayerMetricsWrapper
(
aLayer
i
)
;
}
}
return
LayerMetricsWrapper
(
)
;
}
static
bool
AsyncTransformShouldBeUnapplied
(
Layer
*
aFixedLayer
FrameMetrics
:
:
ViewID
aFixedWithRespectTo
Layer
*
aTransformedLayer
FrameMetrics
:
:
ViewID
aTransformedMetrics
)
{
LayerMetricsWrapper
transformed
=
FindMetricsWithScrollId
(
aTransformedLayer
aTransformedMetrics
)
;
if
(
!
transformed
.
IsValid
(
)
)
{
return
false
;
}
LayerMetricsWrapper
current
(
aFixedLayer
LayerMetricsWrapper
:
:
StartAt
:
:
BOTTOM
)
;
bool
encounteredTransformedLayer
=
false
;
while
(
current
)
{
if
(
!
encounteredTransformedLayer
&
&
current
=
=
transformed
)
{
encounteredTransformedLayer
=
true
;
}
if
(
current
.
Metrics
(
)
.
GetScrollId
(
)
=
=
aFixedWithRespectTo
)
{
return
encounteredTransformedLayer
;
}
current
=
current
.
GetParent
(
)
;
if
(
current
&
&
current
.
AsRefLayer
(
)
!
=
nullptr
)
{
break
;
}
}
return
false
;
}
static
Maybe
<
FrameMetrics
:
:
ViewID
>
IsFixedOrSticky
(
Layer
*
aLayer
)
{
bool
isRootOfFixedSubtree
=
aLayer
-
>
GetIsFixedPosition
(
)
&
&
!
aLayer
-
>
GetParent
(
)
-
>
GetIsFixedPosition
(
)
;
if
(
isRootOfFixedSubtree
)
{
return
Some
(
aLayer
-
>
GetFixedPositionScrollContainerId
(
)
)
;
}
if
(
aLayer
-
>
GetIsStickyPosition
(
)
)
{
return
Some
(
aLayer
-
>
GetStickyScrollContainerId
(
)
)
;
}
return
Nothing
(
)
;
}
void
AsyncCompositionManager
:
:
AlignFixedAndStickyLayers
(
Layer
*
aTransformedSubtreeRoot
Layer
*
aStartTraversalAt
FrameMetrics
:
:
ViewID
aTransformScrollId
const
LayerToParentLayerMatrix4x4
&
aPreviousTransformForRoot
const
LayerToParentLayerMatrix4x4
&
aCurrentTransformForRoot
const
ScreenMargin
&
aFixedLayerMargins
ClipPartsCache
*
aClipPartsCache
)
{
if
(
aCurrentTransformForRoot
.
IsSingular
(
)
)
{
return
;
}
Layer
*
layer
=
aStartTraversalAt
;
bool
needsAsyncTransformUnapplied
=
false
;
if
(
Maybe
<
FrameMetrics
:
:
ViewID
>
fixedTo
=
IsFixedOrSticky
(
layer
)
)
{
needsAsyncTransformUnapplied
=
AsyncTransformShouldBeUnapplied
(
layer
*
fixedTo
aTransformedSubtreeRoot
aTransformScrollId
)
;
}
if
(
!
needsAsyncTransformUnapplied
)
{
for
(
Layer
*
child
=
layer
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
AlignFixedAndStickyLayers
(
aTransformedSubtreeRoot
child
aTransformScrollId
aPreviousTransformForRoot
aCurrentTransformForRoot
aFixedLayerMargins
aClipPartsCache
)
;
}
return
;
}
#
ifdef
DEBUG
Matrix4x4
ancestorTransform
;
if
(
layer
!
=
aTransformedSubtreeRoot
)
{
AccumulateLayerTransforms
(
layer
-
>
GetParent
(
)
aTransformedSubtreeRoot
ancestorTransform
)
;
}
MOZ_ASSERT
(
ancestorTransform
.
IsIdentity
(
)
)
;
#
endif
#
ifdef
DEBUG
Matrix4x4
localTransform
;
GetBaseTransform
(
layer
&
localTransform
)
;
MOZ_ASSERT
(
localTransform
.
IsIdentity
(
)
)
;
#
endif
LayerPoint
anchor
=
layer
-
>
GetFixedPositionAnchor
(
)
;
LayerPoint
offsetAnchor
=
anchor
+
GetLayerFixedMarginsOffset
(
layer
aFixedLayerMargins
)
;
ParentLayerPoint
offsetAnchorInSubtreeRootSpace
=
aPreviousTransformForRoot
.
TransformPoint
(
offsetAnchor
)
;
LayerPoint
transformedAnchor
=
aCurrentTransformForRoot
.
Inverse
(
)
.
TransformPoint
(
offsetAnchorInSubtreeRootSpace
)
;
LayerPoint
translation
=
transformedAnchor
-
anchor
;
LayerPoint
unconsumedTranslation
;
if
(
layer
-
>
GetIsStickyPosition
(
)
)
{
const
LayerRect
&
stickyOuter
=
layer
-
>
GetStickyScrollRangeOuter
(
)
;
const
LayerRect
&
stickyInner
=
layer
-
>
GetStickyScrollRangeInner
(
)
;
LayerPoint
originalTranslation
=
translation
;
translation
.
y
=
IntervalOverlap
(
translation
.
y
stickyOuter
.
y
stickyOuter
.
YMost
(
)
)
-
IntervalOverlap
(
translation
.
y
stickyInner
.
y
stickyInner
.
YMost
(
)
)
;
translation
.
x
=
IntervalOverlap
(
translation
.
x
stickyOuter
.
x
stickyOuter
.
XMost
(
)
)
-
IntervalOverlap
(
translation
.
x
stickyInner
.
x
stickyInner
.
XMost
(
)
)
;
unconsumedTranslation
=
translation
-
originalTranslation
;
}
TranslateShadowLayer
(
layer
ViewAs
<
ParentLayerPixel
>
(
translation
PixelCastJustification
:
:
NoTransformOnLayer
)
true
aClipPartsCache
)
;
if
(
unconsumedTranslation
!
=
LayerPoint
(
)
)
{
LayerPoint
newTransformedAnchor
=
unconsumedTranslation
+
anchor
;
ParentLayerPoint
newTransformedAnchorInSubtreeRootSpace
=
aPreviousTransformForRoot
.
TransformPoint
(
newTransformedAnchor
)
;
LayerToParentLayerMatrix4x4
newTransform
=
aPreviousTransformForRoot
;
newTransform
.
PostTranslate
(
newTransformedAnchorInSubtreeRootSpace
-
offsetAnchorInSubtreeRootSpace
)
;
for
(
Layer
*
child
=
layer
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
AlignFixedAndStickyLayers
(
aTransformedSubtreeRoot
child
aTransformScrollId
aPreviousTransformForRoot
newTransform
aFixedLayerMargins
aClipPartsCache
)
;
}
}
return
;
}
static
void
SampleValue
(
float
aPortion
Animation
&
aAnimation
const
StyleAnimationValue
&
aStart
const
StyleAnimationValue
&
aEnd
const
StyleAnimationValue
&
aLastValue
uint64_t
aCurrentIteration
Animatable
*
aValue
Layer
*
aLayer
)
{
NS_ASSERTION
(
aStart
.
GetUnit
(
)
=
=
aEnd
.
GetUnit
(
)
|
|
aStart
.
GetUnit
(
)
=
=
StyleAnimationValue
:
:
eUnit_None
|
|
aEnd
.
GetUnit
(
)
=
=
StyleAnimationValue
:
:
eUnit_None
"
Must
have
same
unit
"
)
;
StyleAnimationValue
startValue
=
aStart
;
StyleAnimationValue
endValue
=
aEnd
;
if
(
static_cast
<
dom
:
:
IterationCompositeOperation
>
(
aAnimation
.
iterationComposite
(
)
)
=
=
dom
:
:
IterationCompositeOperation
:
:
Accumulate
&
&
aCurrentIteration
>
0
)
{
DebugOnly
<
bool
>
accumulateResult
=
StyleAnimationValue
:
:
Accumulate
(
aAnimation
.
property
(
)
startValue
aLastValue
aCurrentIteration
)
;
MOZ_ASSERT
(
accumulateResult
"
could
not
accumulate
value
"
)
;
accumulateResult
=
StyleAnimationValue
:
:
Accumulate
(
aAnimation
.
property
(
)
endValue
aLastValue
aCurrentIteration
)
;
MOZ_ASSERT
(
accumulateResult
"
could
not
accumulate
value
"
)
;
}
StyleAnimationValue
interpolatedValue
;
DebugOnly
<
bool
>
uncomputeResult
=
StyleAnimationValue
:
:
Interpolate
(
aAnimation
.
property
(
)
startValue
endValue
aPortion
interpolatedValue
)
;
MOZ_ASSERT
(
uncomputeResult
"
could
not
uncompute
value
"
)
;
if
(
aAnimation
.
property
(
)
=
=
eCSSProperty_opacity
)
{
*
aValue
=
interpolatedValue
.
GetFloatValue
(
)
;
return
;
}
nsCSSValueSharedList
*
interpolatedList
=
interpolatedValue
.
GetCSSValueSharedListValue
(
)
;
TransformData
&
data
=
aAnimation
.
data
(
)
.
get_TransformData
(
)
;
nsPoint
origin
=
data
.
origin
(
)
;
Point3D
transformOrigin
=
data
.
transformOrigin
(
)
;
nsDisplayTransform
:
:
FrameTransformProperties
props
(
interpolatedList
transformOrigin
)
;
uint32_t
flags
=
0
;
if
(
!
aLayer
-
>
GetParent
(
)
|
|
!
aLayer
-
>
GetParent
(
)
-
>
GetTransformIsPerspective
(
)
)
{
flags
=
nsDisplayTransform
:
:
OFFSET_BY_ORIGIN
;
}
Matrix4x4
transform
=
nsDisplayTransform
:
:
GetResultingTransformMatrix
(
props
origin
data
.
appUnitsPerDevPixel
(
)
flags
&
data
.
bounds
(
)
)
;
InfallibleTArray
<
TransformFunction
>
functions
;
functions
.
AppendElement
(
TransformMatrix
(
transform
)
)
;
*
aValue
=
functions
;
}
static
bool
SampleAnimations
(
Layer
*
aLayer
TimeStamp
aPoint
)
{
bool
activeAnimations
=
false
;
ForEachNode
<
ForwardIterator
>
(
aLayer
[
&
activeAnimations
&
aPoint
]
(
Layer
*
layer
)
{
AnimationArray
&
animations
=
layer
-
>
GetAnimations
(
)
;
InfallibleTArray
<
AnimData
>
&
animationData
=
layer
-
>
GetAnimationData
(
)
;
for
(
size_t
i
=
0
iEnd
=
animations
.
Length
(
)
;
i
<
iEnd
;
+
+
i
)
{
Animation
&
animation
=
animations
[
i
]
;
AnimData
&
animData
=
animationData
[
i
]
;
activeAnimations
=
true
;
MOZ_ASSERT
(
!
animation
.
startTime
(
)
.
IsNull
(
)
"
Failed
to
resolve
start
time
of
pending
animations
"
)
;
TimeDuration
elapsedDuration
=
(
aPoint
-
animation
.
startTime
(
)
)
.
MultDouble
(
animation
.
playbackRate
(
)
)
;
if
(
elapsedDuration
.
ToSeconds
(
)
<
0
)
{
continue
;
}
TimingParams
timing
;
timing
.
mDuration
.
emplace
(
animation
.
duration
(
)
)
;
timing
.
mDelay
=
TimeDuration
(
0
)
;
timing
.
mIterations
=
animation
.
iterations
(
)
;
timing
.
mIterationStart
=
animation
.
iterationStart
(
)
;
timing
.
mDirection
=
static_cast
<
dom
:
:
PlaybackDirection
>
(
animation
.
direction
(
)
)
;
timing
.
mFill
=
dom
:
:
FillMode
:
:
Both
;
timing
.
mFunction
=
AnimationUtils
:
:
TimingFunctionToComputedTimingFunction
(
animation
.
easingFunction
(
)
)
;
ComputedTiming
computedTiming
=
dom
:
:
AnimationEffectReadOnly
:
:
GetComputedTimingAt
(
Nullable
<
TimeDuration
>
(
elapsedDuration
)
timing
animation
.
playbackRate
(
)
)
;
MOZ_ASSERT
(
!
computedTiming
.
mProgress
.
IsNull
(
)
"
iteration
progress
should
not
be
null
"
)
;
uint32_t
segmentIndex
=
0
;
size_t
segmentSize
=
animation
.
segments
(
)
.
Length
(
)
;
AnimationSegment
*
segment
=
animation
.
segments
(
)
.
Elements
(
)
;
while
(
segment
-
>
endPortion
(
)
<
computedTiming
.
mProgress
.
Value
(
)
&
&
segmentIndex
<
segmentSize
-
1
)
{
+
+
segment
;
+
+
segmentIndex
;
}
double
positionInSegment
=
(
computedTiming
.
mProgress
.
Value
(
)
-
segment
-
>
startPortion
(
)
)
/
(
segment
-
>
endPortion
(
)
-
segment
-
>
startPortion
(
)
)
;
double
portion
=
ComputedTimingFunction
:
:
GetPortion
(
animData
.
mFunctions
[
segmentIndex
]
positionInSegment
computedTiming
.
mBeforeFlag
)
;
Animatable
interpolatedValue
;
SampleValue
(
portion
animation
animData
.
mStartValues
[
segmentIndex
]
animData
.
mEndValues
[
segmentIndex
]
animData
.
mEndValues
.
LastElement
(
)
computedTiming
.
mCurrentIteration
&
interpolatedValue
layer
)
;
LayerComposite
*
layerComposite
=
layer
-
>
AsLayerComposite
(
)
;
switch
(
animation
.
property
(
)
)
{
case
eCSSProperty_opacity
:
{
layerComposite
-
>
SetShadowOpacity
(
interpolatedValue
.
get_float
(
)
)
;
layerComposite
-
>
SetShadowOpacitySetByAnimation
(
true
)
;
break
;
}
case
eCSSProperty_transform
:
{
Matrix4x4
matrix
=
interpolatedValue
.
get_ArrayOfTransformFunction
(
)
[
0
]
.
get_TransformMatrix
(
)
.
value
(
)
;
if
(
ContainerLayer
*
c
=
layer
-
>
AsContainerLayer
(
)
)
{
matrix
.
PostScale
(
c
-
>
GetInheritedXScale
(
)
c
-
>
GetInheritedYScale
(
)
1
)
;
}
layerComposite
-
>
SetShadowBaseTransform
(
matrix
)
;
layerComposite
-
>
SetShadowTransformSetByAnimation
(
true
)
;
break
;
}
default
:
NS_WARNING
(
"
Unhandled
animated
property
"
)
;
}
}
}
)
;
return
activeAnimations
;
}
static
bool
SampleAPZAnimations
(
const
LayerMetricsWrapper
&
aLayer
TimeStamp
aSampleTime
)
{
bool
activeAnimations
=
false
;
for
(
LayerMetricsWrapper
child
=
aLayer
.
GetFirstChild
(
)
;
child
;
child
=
child
.
GetNextSibling
(
)
)
{
activeAnimations
|
=
SampleAPZAnimations
(
child
aSampleTime
)
;
}
if
(
AsyncPanZoomController
*
apzc
=
aLayer
.
GetApzc
(
)
)
{
apzc
-
>
ReportCheckerboard
(
aSampleTime
)
;
activeAnimations
|
=
apzc
-
>
AdvanceAnimations
(
aSampleTime
)
;
}
return
activeAnimations
;
}
void
AsyncCompositionManager
:
:
RecordShadowTransforms
(
Layer
*
aLayer
)
{
MOZ_ASSERT
(
gfxPrefs
:
:
CollectScrollTransforms
(
)
)
;
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
ForEachNodePostOrder
<
ForwardIterator
>
(
aLayer
[
this
]
(
Layer
*
layer
)
{
for
(
uint32_t
i
=
0
;
i
<
layer
-
>
GetScrollMetadataCount
(
)
;
i
+
+
)
{
AsyncPanZoomController
*
apzc
=
layer
-
>
GetAsyncPanZoomController
(
i
)
;
if
(
!
apzc
)
{
continue
;
}
gfx
:
:
Matrix4x4
shadowTransform
=
layer
-
>
AsLayerComposite
(
)
-
>
GetShadowBaseTransform
(
)
;
if
(
!
shadowTransform
.
Is2D
(
)
)
{
continue
;
}
Matrix
transform
=
shadowTransform
.
As2D
(
)
;
if
(
transform
.
IsTranslation
(
)
&
&
!
shadowTransform
.
IsIdentity
(
)
)
{
Point
translation
=
transform
.
GetTranslation
(
)
;
mLayerTransformRecorder
.
RecordTransform
(
layer
translation
)
;
return
;
}
}
}
)
;
}
static
AsyncTransformComponentMatrix
AdjustForClip
(
const
AsyncTransformComponentMatrix
&
asyncTransform
Layer
*
aLayer
)
{
AsyncTransformComponentMatrix
result
=
asyncTransform
;
if
(
const
Maybe
<
ParentLayerIntRect
>
&
shadowClipRect
=
aLayer
-
>
AsLayerComposite
(
)
-
>
GetShadowClipRect
(
)
)
{
if
(
shadowClipRect
-
>
TopLeft
(
)
!
=
ParentLayerIntPoint
(
)
)
{
result
.
ChangeBasis
(
shadowClipRect
-
>
x
shadowClipRect
-
>
y
0
)
;
}
}
return
result
;
}
static
void
ExpandRootClipRect
(
Layer
*
aLayer
const
ScreenMargin
&
aFixedLayerMargins
)
{
Maybe
<
ParentLayerIntRect
>
rootClipRect
=
aLayer
-
>
AsLayerComposite
(
)
-
>
GetShadowClipRect
(
)
;
if
(
rootClipRect
&
&
aFixedLayerMargins
!
=
ScreenMargin
(
)
)
{
#
ifndef
MOZ_WIDGET_ANDROID
MOZ_ASSERT
(
false
)
;
#
endif
ParentLayerRect
rect
(
rootClipRect
.
value
(
)
)
;
rect
.
Deflate
(
ViewAs
<
ParentLayerPixel
>
(
aFixedLayerMargins
PixelCastJustification
:
:
ScreenIsParentLayerForRoot
)
)
;
aLayer
-
>
AsLayerComposite
(
)
-
>
SetShadowClipRect
(
Some
(
RoundedOut
(
rect
)
)
)
;
}
}
#
ifdef
MOZ_WIDGET_ANDROID
static
void
MoveScrollbarForLayerMargin
(
Layer
*
aRoot
FrameMetrics
:
:
ViewID
aRootScrollId
const
ScreenMargin
&
aFixedLayerMargins
)
{
Layer
*
scrollbar
=
BreadthFirstSearch
<
ReverseIterator
>
(
aRoot
[
aRootScrollId
]
(
Layer
*
aNode
)
{
return
(
aNode
-
>
GetScrollbarDirection
(
)
=
=
Layer
:
:
HORIZONTAL
&
&
aNode
-
>
GetScrollbarTargetContainerId
(
)
=
=
aRootScrollId
)
;
}
)
;
if
(
scrollbar
)
{
TranslateShadowLayer
(
scrollbar
ParentLayerPoint
(
0
-
aFixedLayerMargins
.
bottom
)
true
nullptr
)
;
if
(
scrollbar
-
>
GetParent
(
)
)
{
ExpandRootClipRect
(
scrollbar
-
>
GetParent
(
)
aFixedLayerMargins
)
;
}
}
}
#
endif
bool
AsyncCompositionManager
:
:
ApplyAsyncContentTransformToTree
(
Layer
*
aLayer
bool
*
aOutFoundRoot
)
{
bool
appliedTransform
=
false
;
std
:
:
stack
<
Maybe
<
ParentLayerIntRect
>
>
stackDeferredClips
;
ClipPartsCache
clipPartsCache
;
ForEachNode
<
ForwardIterator
>
(
aLayer
[
&
stackDeferredClips
]
(
Layer
*
layer
)
{
stackDeferredClips
.
push
(
Maybe
<
ParentLayerIntRect
>
(
)
)
;
}
[
this
&
aOutFoundRoot
&
stackDeferredClips
&
appliedTransform
&
clipPartsCache
]
(
Layer
*
layer
)
{
Maybe
<
ParentLayerIntRect
>
clipDeferredFromChildren
=
stackDeferredClips
.
top
(
)
;
stackDeferredClips
.
pop
(
)
;
LayerToParentLayerMatrix4x4
oldTransform
=
layer
-
>
GetTransformTyped
(
)
*
AsyncTransformMatrix
(
)
;
AsyncTransformComponentMatrix
combinedAsyncTransform
;
bool
hasAsyncTransform
=
false
;
ScreenMargin
fixedLayerMargins
;
ClipParts
&
clipParts
=
clipPartsCache
[
layer
]
;
clipParts
.
mFixedClip
=
layer
-
>
GetClipRect
(
)
;
clipParts
.
mScrolledClip
=
layer
-
>
GetScrolledClipRect
(
)
;
clipParts
.
mScrolledClip
=
IntersectMaybeRects
(
clipDeferredFromChildren
clipParts
.
mScrolledClip
)
;
nsTArray
<
Layer
*
>
ancestorMaskLayers
;
if
(
const
Maybe
<
LayerClip
>
&
scrolledClip
=
layer
-
>
GetScrolledClip
(
)
)
{
if
(
scrolledClip
-
>
GetMaskLayerIndex
(
)
)
{
ancestorMaskLayers
.
AppendElement
(
layer
-
>
GetAncestorMaskLayerAt
(
*
scrolledClip
-
>
GetMaskLayerIndex
(
)
)
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
layer
-
>
GetScrollMetadataCount
(
)
;
i
+
+
)
{
AsyncPanZoomController
*
controller
=
layer
-
>
GetAsyncPanZoomController
(
i
)
;
if
(
!
controller
)
{
continue
;
}
hasAsyncTransform
=
true
;
AsyncTransform
asyncTransformWithoutOverscroll
=
controller
-
>
GetCurrentAsyncTransform
(
AsyncPanZoomController
:
:
RESPECT_FORCE_DISABLE
)
;
AsyncTransformComponentMatrix
overscrollTransform
=
controller
-
>
GetOverscrollTransform
(
AsyncPanZoomController
:
:
RESPECT_FORCE_DISABLE
)
;
AsyncTransformComponentMatrix
asyncTransform
=
AsyncTransformComponentMatrix
(
asyncTransformWithoutOverscroll
)
*
overscrollTransform
;
if
(
!
layer
-
>
IsScrollInfoLayer
(
)
)
{
controller
-
>
MarkAsyncTransformAppliedToContent
(
)
;
}
const
ScrollMetadata
&
scrollMetadata
=
layer
-
>
GetScrollMetadata
(
i
)
;
const
FrameMetrics
&
metrics
=
scrollMetadata
.
GetMetrics
(
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
if
(
!
(
*
aOutFoundRoot
)
)
{
*
aOutFoundRoot
=
metrics
.
IsRootContent
(
)
|
|
(
layer
-
>
GetParent
(
)
=
=
nullptr
&
&
i
+
1
>
=
layer
-
>
GetScrollMetadataCount
(
)
)
;
if
(
*
aOutFoundRoot
)
{
mRootScrollableId
=
metrics
.
GetScrollId
(
)
;
CSSToLayerScale
geckoZoom
=
metrics
.
LayersPixelsPerCSSPixel
(
)
.
ToScaleFactor
(
)
;
if
(
mIsFirstPaint
)
{
LayerIntPoint
scrollOffsetLayerPixels
=
RoundedToInt
(
metrics
.
GetScrollOffset
(
)
*
geckoZoom
)
;
mContentRect
=
metrics
.
GetScrollableRect
(
)
;
SetFirstPaintViewport
(
scrollOffsetLayerPixels
geckoZoom
mContentRect
)
;
}
else
{
ParentLayerPoint
scrollOffset
=
controller
-
>
GetCurrentAsyncScrollOffset
(
AsyncPanZoomController
:
:
RESPECT_FORCE_DISABLE
)
;
CSSRect
displayPort
(
metrics
.
GetCriticalDisplayPort
(
)
.
IsEmpty
(
)
?
metrics
.
GetDisplayPort
(
)
:
metrics
.
GetCriticalDisplayPort
(
)
)
;
displayPort
+
=
metrics
.
GetScrollOffset
(
)
;
SyncFrameMetrics
(
scrollOffset
geckoZoom
*
asyncTransformWithoutOverscroll
.
mScale
metrics
.
GetScrollableRect
(
)
displayPort
geckoZoom
mLayersUpdated
mPaintSyncId
fixedLayerMargins
)
;
mFixedLayerMargins
=
fixedLayerMargins
;
mLayersUpdated
=
false
;
}
mIsFirstPaint
=
false
;
mPaintSyncId
=
0
;
}
}
#
else
mIsFirstPaint
=
false
;
#
endif
if
(
!
scrollMetadata
.
UsesContainerScrolling
(
)
)
{
MOZ_ASSERT
(
asyncTransform
.
Is2D
(
)
)
;
if
(
clipParts
.
mFixedClip
)
{
*
clipParts
.
mFixedClip
=
TransformBy
(
asyncTransform
*
clipParts
.
mFixedClip
)
;
}
if
(
clipParts
.
mScrolledClip
)
{
*
clipParts
.
mScrolledClip
=
TransformBy
(
asyncTransform
*
clipParts
.
mScrolledClip
)
;
}
}
combinedAsyncTransform
*
=
asyncTransform
;
LayerToParentLayerMatrix4x4
transformWithoutOverscrollOrOmta
=
layer
-
>
GetTransformTyped
(
)
*
CompleteAsyncTransform
(
AdjustForClip
(
asyncTransformWithoutOverscroll
layer
)
)
;
AlignFixedAndStickyLayers
(
layer
layer
metrics
.
GetScrollId
(
)
oldTransform
transformWithoutOverscrollOrOmta
fixedLayerMargins
&
clipPartsCache
)
;
if
(
scrollMetadata
.
HasScrollClip
(
)
)
{
ParentLayerIntRect
clip
=
scrollMetadata
.
ScrollClip
(
)
.
GetClipRect
(
)
;
if
(
layer
-
>
GetParent
(
)
&
&
layer
-
>
GetParent
(
)
-
>
GetTransformIsPerspective
(
)
)
{
MOZ_ASSERT
(
!
stackDeferredClips
.
top
(
)
)
;
stackDeferredClips
.
top
(
)
.
emplace
(
clip
)
;
}
else
{
clipParts
.
mScrolledClip
=
IntersectMaybeRects
(
Some
(
clip
)
clipParts
.
mScrolledClip
)
;
}
}
for
(
Layer
*
ancestorMaskLayer
:
ancestorMaskLayers
)
{
SetShadowTransform
(
ancestorMaskLayer
ancestorMaskLayer
-
>
GetLocalTransformTyped
(
)
*
asyncTransform
)
;
}
if
(
scrollMetadata
.
HasScrollClip
(
)
)
{
const
LayerClip
&
scrollClip
=
scrollMetadata
.
ScrollClip
(
)
;
if
(
scrollClip
.
GetMaskLayerIndex
(
)
)
{
size_t
maskLayerIndex
=
scrollClip
.
GetMaskLayerIndex
(
)
.
value
(
)
;
Layer
*
ancestorMaskLayer
=
layer
-
>
GetAncestorMaskLayerAt
(
maskLayerIndex
)
;
ancestorMaskLayers
.
AppendElement
(
ancestorMaskLayer
)
;
}
}
}
bool
clipChanged
=
(
hasAsyncTransform
|
|
clipDeferredFromChildren
|
|
layer
-
>
GetScrolledClipRect
(
)
)
;
if
(
clipChanged
)
{
layer
-
>
AsLayerComposite
(
)
-
>
SetShadowClipRect
(
clipParts
.
Intersect
(
)
)
;
}
if
(
hasAsyncTransform
)
{
SetShadowTransform
(
layer
layer
-
>
GetLocalTransformTyped
(
)
*
AdjustForClip
(
combinedAsyncTransform
layer
)
)
;
if
(
Layer
*
maskLayer
=
layer
-
>
GetMaskLayer
(
)
)
{
SetShadowTransform
(
maskLayer
maskLayer
-
>
GetLocalTransformTyped
(
)
*
combinedAsyncTransform
)
;
}
appliedTransform
=
true
;
}
ExpandRootClipRect
(
layer
fixedLayerMargins
)
;
if
(
layer
-
>
GetScrollbarDirection
(
)
!
=
Layer
:
:
NONE
)
{
ApplyAsyncTransformToScrollbar
(
layer
)
;
}
}
)
;
return
appliedTransform
;
}
static
bool
LayerIsScrollbarTarget
(
const
LayerMetricsWrapper
&
aTarget
Layer
*
aScrollbar
)
{
AsyncPanZoomController
*
apzc
=
aTarget
.
GetApzc
(
)
;
if
(
!
apzc
)
{
return
false
;
}
const
FrameMetrics
&
metrics
=
aTarget
.
Metrics
(
)
;
if
(
metrics
.
GetScrollId
(
)
!
=
aScrollbar
-
>
GetScrollbarTargetContainerId
(
)
)
{
return
false
;
}
return
!
aTarget
.
IsScrollInfoLayer
(
)
;
}
static
void
ApplyAsyncTransformToScrollbarForContent
(
Layer
*
aScrollbar
const
LayerMetricsWrapper
&
aContent
bool
aScrollbarIsDescendant
)
{
if
(
aContent
.
IsScrollInfoLayer
(
)
)
{
return
;
}
const
FrameMetrics
&
metrics
=
aContent
.
Metrics
(
)
;
AsyncPanZoomController
*
apzc
=
aContent
.
GetApzc
(
)
;
MOZ_RELEASE_ASSERT
(
apzc
)
;
AsyncTransformComponentMatrix
asyncTransform
=
apzc
-
>
GetCurrentAsyncTransform
(
AsyncPanZoomController
:
:
RESPECT_FORCE_DISABLE
)
;
AsyncTransformComponentMatrix
scrollbarTransform
;
if
(
aScrollbar
-
>
GetScrollbarDirection
(
)
=
=
Layer
:
:
VERTICAL
)
{
const
ParentLayerCoord
asyncScrollY
=
asyncTransform
.
_42
;
const
float
asyncZoomY
=
asyncTransform
.
_22
;
const
float
yScale
=
1
.
f
/
asyncZoomY
;
const
CSSToParentLayerScale
effectiveZoom
(
metrics
.
GetZoom
(
)
.
yScale
*
asyncZoomY
)
;
const
float
ratio
=
aScrollbar
-
>
GetScrollbarThumbRatio
(
)
/
(
metrics
.
GetPresShellResolution
(
)
*
asyncZoomY
)
;
ParentLayerCoord
yTranslation
=
-
asyncScrollY
*
ratio
;
const
CSSCoord
thumbOrigin
=
(
metrics
.
GetScrollOffset
(
)
.
y
*
ratio
)
;
const
CSSCoord
thumbOriginScaled
=
thumbOrigin
*
yScale
;
const
CSSCoord
thumbOriginDelta
=
thumbOriginScaled
-
thumbOrigin
;
const
ParentLayerCoord
thumbOriginDeltaPL
=
thumbOriginDelta
*
effectiveZoom
;
yTranslation
-
=
thumbOriginDeltaPL
;
if
(
metrics
.
IsRootContent
(
)
)
{
yTranslation
*
=
metrics
.
GetPresShellResolution
(
)
;
}
scrollbarTransform
.
PostScale
(
1
.
f
yScale
1
.
f
)
;
scrollbarTransform
.
PostTranslate
(
0
yTranslation
0
)
;
}
if
(
aScrollbar
-
>
GetScrollbarDirection
(
)
=
=
Layer
:
:
HORIZONTAL
)
{
const
ParentLayerCoord
asyncScrollX
=
asyncTransform
.
_41
;
const
float
asyncZoomX
=
asyncTransform
.
_11
;
const
float
xScale
=
1
.
f
/
asyncZoomX
;
const
CSSToParentLayerScale
effectiveZoom
(
metrics
.
GetZoom
(
)
.
xScale
*
asyncZoomX
)
;
const
float
ratio
=
aScrollbar
-
>
GetScrollbarThumbRatio
(
)
/
(
metrics
.
GetPresShellResolution
(
)
*
asyncZoomX
)
;
ParentLayerCoord
xTranslation
=
-
asyncScrollX
*
ratio
;
const
CSSCoord
thumbOrigin
=
(
metrics
.
GetScrollOffset
(
)
.
x
*
ratio
)
;
const
CSSCoord
thumbOriginScaled
=
thumbOrigin
*
xScale
;
const
CSSCoord
thumbOriginDelta
=
thumbOriginScaled
-
thumbOrigin
;
const
ParentLayerCoord
thumbOriginDeltaPL
=
thumbOriginDelta
*
effectiveZoom
;
xTranslation
-
=
thumbOriginDeltaPL
;
if
(
metrics
.
IsRootContent
(
)
)
{
xTranslation
*
=
metrics
.
GetPresShellResolution
(
)
;
}
scrollbarTransform
.
PostScale
(
xScale
1
.
f
1
.
f
)
;
scrollbarTransform
.
PostTranslate
(
xTranslation
0
0
)
;
}
LayerToParentLayerMatrix4x4
transform
=
aScrollbar
-
>
GetLocalTransformTyped
(
)
*
scrollbarTransform
;
AsyncTransformComponentMatrix
compensation
;
if
(
metrics
.
IsRootContent
(
)
)
{
compensation
=
AsyncTransformComponentMatrix
:
:
Scaling
(
metrics
.
GetPresShellResolution
(
)
metrics
.
GetPresShellResolution
(
)
1
.
0f
)
.
Inverse
(
)
;
}
if
(
aScrollbarIsDescendant
)
{
AsyncTransformComponentMatrix
overscroll
=
apzc
-
>
GetOverscrollTransform
(
AsyncPanZoomController
:
:
RESPECT_FORCE_DISABLE
)
;
Matrix4x4
asyncUntransform
=
(
asyncTransform
*
overscroll
)
.
Inverse
(
)
.
ToUnknownMatrix
(
)
;
Matrix4x4
contentTransform
=
aContent
.
GetTransform
(
)
;
Matrix4x4
contentUntransform
=
contentTransform
.
Inverse
(
)
;
AsyncTransformComponentMatrix
asyncCompensation
=
ViewAs
<
AsyncTransformComponentMatrix
>
(
contentTransform
*
asyncUntransform
*
contentUntransform
)
;
compensation
=
compensation
*
asyncCompensation
;
for
(
Layer
*
ancestor
=
aScrollbar
;
ancestor
!
=
aContent
.
GetLayer
(
)
;
ancestor
=
ancestor
-
>
GetParent
(
)
)
{
TransformClipRect
(
ancestor
asyncCompensation
)
;
}
}
transform
=
transform
*
compensation
;
SetShadowTransform
(
aScrollbar
transform
)
;
}
static
LayerMetricsWrapper
FindScrolledLayerRecursive
(
Layer
*
aScrollbar
const
LayerMetricsWrapper
&
aSubtreeRoot
)
{
if
(
LayerIsScrollbarTarget
(
aSubtreeRoot
aScrollbar
)
)
{
return
aSubtreeRoot
;
}
for
(
LayerMetricsWrapper
child
=
aSubtreeRoot
.
GetFirstChild
(
)
;
child
;
child
=
child
.
GetNextSibling
(
)
)
{
if
(
child
.
AsRefLayer
(
)
)
{
continue
;
}
LayerMetricsWrapper
target
=
FindScrolledLayerRecursive
(
aScrollbar
child
)
;
if
(
target
)
{
return
target
;
}
}
return
LayerMetricsWrapper
(
)
;
}
static
LayerMetricsWrapper
FindScrolledLayerForScrollbar
(
Layer
*
aScrollbar
bool
*
aOutIsAncestor
)
{
LayerMetricsWrapper
root
(
aScrollbar
-
>
Manager
(
)
-
>
GetRoot
(
)
)
;
LayerMetricsWrapper
prevAncestor
(
aScrollbar
)
;
for
(
LayerMetricsWrapper
ancestor
(
aScrollbar
)
;
ancestor
;
ancestor
=
ancestor
.
GetParent
(
)
)
{
if
(
ancestor
.
AsRefLayer
(
)
)
{
root
=
prevAncestor
;
break
;
}
prevAncestor
=
ancestor
;
if
(
LayerIsScrollbarTarget
(
ancestor
aScrollbar
)
)
{
*
aOutIsAncestor
=
true
;
return
ancestor
;
}
}
return
FindScrolledLayerRecursive
(
aScrollbar
root
)
;
}
void
AsyncCompositionManager
:
:
ApplyAsyncTransformToScrollbar
(
Layer
*
aLayer
)
{
bool
isAncestor
=
false
;
const
LayerMetricsWrapper
&
scrollTarget
=
FindScrolledLayerForScrollbar
(
aLayer
&
isAncestor
)
;
if
(
scrollTarget
)
{
ApplyAsyncTransformToScrollbarForContent
(
aLayer
scrollTarget
isAncestor
)
;
}
}
void
AsyncCompositionManager
:
:
TransformScrollableLayer
(
Layer
*
aLayer
)
{
FrameMetrics
metrics
=
LayerMetricsWrapper
:
:
TopmostScrollableMetrics
(
aLayer
)
;
if
(
!
metrics
.
IsScrollable
(
)
)
{
metrics
=
LayerMetricsWrapper
:
:
BottommostMetrics
(
aLayer
)
;
}
LayerToParentLayerMatrix4x4
oldTransform
=
aLayer
-
>
GetTransformTyped
(
)
*
AsyncTransformMatrix
(
)
;
CSSToLayerScale
geckoZoom
=
metrics
.
LayersPixelsPerCSSPixel
(
)
.
ToScaleFactor
(
)
;
LayerIntPoint
scrollOffsetLayerPixels
=
RoundedToInt
(
metrics
.
GetScrollOffset
(
)
*
geckoZoom
)
;
if
(
mIsFirstPaint
)
{
mContentRect
=
metrics
.
GetScrollableRect
(
)
;
SetFirstPaintViewport
(
scrollOffsetLayerPixels
geckoZoom
mContentRect
)
;
mIsFirstPaint
=
false
;
}
else
if
(
!
metrics
.
GetScrollableRect
(
)
.
IsEqualEdges
(
mContentRect
)
)
{
mContentRect
=
metrics
.
GetScrollableRect
(
)
;
SetPageRect
(
mContentRect
)
;
}
LayerIntRect
displayPort
=
RoundedToInt
(
(
metrics
.
GetCriticalDisplayPort
(
)
.
IsEmpty
(
)
?
metrics
.
GetDisplayPort
(
)
:
metrics
.
GetCriticalDisplayPort
(
)
)
*
geckoZoom
)
;
displayPort
+
=
scrollOffsetLayerPixels
;
ScreenMargin
fixedLayerMargins
(
0
0
0
0
)
;
CSSToParentLayerScale
userZoom
(
metrics
.
GetDevPixelsPerCSSPixel
(
)
*
metrics
.
GetCumulativeResolution
(
)
.
ToScaleFactor
(
)
*
LayerToParentLayerScale
(
1
)
)
;
ParentLayerRect
userRect
(
metrics
.
GetScrollOffset
(
)
*
userZoom
metrics
.
GetCompositionBounds
(
)
.
Size
(
)
)
;
SyncViewportInfo
(
displayPort
geckoZoom
mLayersUpdated
mPaintSyncId
userRect
userZoom
fixedLayerMargins
)
;
mLayersUpdated
=
false
;
mPaintSyncId
=
0
;
ParentLayerPoint
geckoScroll
(
0
0
)
;
if
(
metrics
.
IsScrollable
(
)
)
{
geckoScroll
=
metrics
.
GetScrollOffset
(
)
*
userZoom
;
}
LayerToParentLayerScale
asyncZoom
=
userZoom
/
metrics
.
LayersPixelsPerCSSPixel
(
)
.
ToScaleFactor
(
)
;
ParentLayerPoint
translation
=
userRect
.
TopLeft
(
)
-
geckoScroll
;
AsyncTransformComponentMatrix
treeTransform
=
AsyncTransform
(
asyncZoom
-
translation
)
;
SetShadowTransform
(
aLayer
aLayer
-
>
GetLocalTransformTyped
(
)
*
treeTransform
)
;
ParentLayerRect
contentScreenRect
=
mContentRect
*
userZoom
;
Point3D
overscrollTranslation
;
if
(
userRect
.
x
<
contentScreenRect
.
x
)
{
overscrollTranslation
.
x
=
contentScreenRect
.
x
-
userRect
.
x
;
}
else
if
(
userRect
.
XMost
(
)
>
contentScreenRect
.
XMost
(
)
)
{
overscrollTranslation
.
x
=
contentScreenRect
.
XMost
(
)
-
userRect
.
XMost
(
)
;
}
if
(
userRect
.
y
<
contentScreenRect
.
y
)
{
overscrollTranslation
.
y
=
contentScreenRect
.
y
-
userRect
.
y
;
}
else
if
(
userRect
.
YMost
(
)
>
contentScreenRect
.
YMost
(
)
)
{
overscrollTranslation
.
y
=
contentScreenRect
.
YMost
(
)
-
userRect
.
YMost
(
)
;
}
oldTransform
.
PreTranslate
(
overscrollTranslation
.
x
overscrollTranslation
.
y
overscrollTranslation
.
z
)
;
gfx
:
:
Size
underZoomScale
(
1
.
0f
1
.
0f
)
;
if
(
mContentRect
.
width
*
userZoom
.
scale
<
metrics
.
GetCompositionBounds
(
)
.
width
)
{
underZoomScale
.
width
=
(
mContentRect
.
width
*
userZoom
.
scale
)
/
metrics
.
GetCompositionBounds
(
)
.
width
;
}
if
(
mContentRect
.
height
*
userZoom
.
scale
<
metrics
.
GetCompositionBounds
(
)
.
height
)
{
underZoomScale
.
height
=
(
mContentRect
.
height
*
userZoom
.
scale
)
/
metrics
.
GetCompositionBounds
(
)
.
height
;
}
oldTransform
.
PreScale
(
underZoomScale
.
width
underZoomScale
.
height
1
)
;
AlignFixedAndStickyLayers
(
aLayer
aLayer
metrics
.
GetScrollId
(
)
oldTransform
aLayer
-
>
GetLocalTransformTyped
(
)
fixedLayerMargins
nullptr
)
;
ExpandRootClipRect
(
aLayer
fixedLayerMargins
)
;
}
void
AsyncCompositionManager
:
:
GetFrameUniformity
(
FrameUniformityData
*
aOutData
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
mLayerTransformRecorder
.
EndTest
(
aOutData
)
;
}
bool
AsyncCompositionManager
:
:
TransformShadowTree
(
TimeStamp
aCurrentFrame
TimeDuration
aVsyncRate
TransformsToSkip
aSkip
)
{
PROFILER_LABEL
(
"
AsyncCompositionManager
"
"
TransformShadowTree
"
js
:
:
ProfileEntry
:
:
Category
:
:
GRAPHICS
)
;
Layer
*
root
=
mLayerManager
-
>
GetRoot
(
)
;
if
(
!
root
)
{
return
false
;
}
bool
wantNextFrame
=
SampleAnimations
(
root
!
mPreviousFrameTimeStamp
.
IsNull
(
)
?
mPreviousFrameTimeStamp
:
aCurrentFrame
)
;
mPreviousFrameTimeStamp
=
wantNextFrame
?
aCurrentFrame
:
TimeStamp
(
)
;
if
(
!
(
aSkip
&
TransformsToSkip
:
:
APZ
)
)
{
bool
foundRoot
=
false
;
if
(
ApplyAsyncContentTransformToTree
(
root
&
foundRoot
)
)
{
#
if
defined
(
MOZ_WIDGET_ANDROID
)
MOZ_ASSERT
(
foundRoot
)
;
if
(
foundRoot
&
&
mFixedLayerMargins
!
=
ScreenMargin
(
)
)
{
MoveScrollbarForLayerMargin
(
root
mRootScrollableId
mFixedLayerMargins
)
;
}
#
endif
}
else
{
AutoTArray
<
Layer
*
1
>
scrollableLayers
;
#
ifdef
MOZ_WIDGET_ANDROID
mLayerManager
-
>
GetRootScrollableLayers
(
scrollableLayers
)
;
#
else
mLayerManager
-
>
GetScrollableLayers
(
scrollableLayers
)
;
#
endif
for
(
uint32_t
i
=
0
;
i
<
scrollableLayers
.
Length
(
)
;
i
+
+
)
{
if
(
scrollableLayers
[
i
]
)
{
TransformScrollableLayer
(
scrollableLayers
[
i
]
)
;
}
}
}
TimeStamp
nextFrame
=
aCurrentFrame
;
MOZ_ASSERT
(
aVsyncRate
!
=
TimeDuration
:
:
Forever
(
)
)
;
if
(
aVsyncRate
!
=
TimeDuration
:
:
Forever
(
)
)
{
nextFrame
+
=
aVsyncRate
;
}
wantNextFrame
|
=
SampleAPZAnimations
(
LayerMetricsWrapper
(
root
)
nextFrame
)
;
}
LayerComposite
*
rootComposite
=
root
-
>
AsLayerComposite
(
)
;
gfx
:
:
Matrix4x4
trans
=
rootComposite
-
>
GetShadowBaseTransform
(
)
;
trans
*
=
gfx
:
:
Matrix4x4
:
:
From2D
(
mWorldTransform
)
;
rootComposite
-
>
SetShadowBaseTransform
(
trans
)
;
if
(
gfxPrefs
:
:
CollectScrollTransforms
(
)
)
{
RecordShadowTransforms
(
root
)
;
}
return
wantNextFrame
;
}
void
AsyncCompositionManager
:
:
SetFirstPaintViewport
(
const
LayerIntPoint
&
aOffset
const
CSSToLayerScale
&
aZoom
const
CSSRect
&
aCssPageRect
)
{
#
ifdef
MOZ_WIDGET_ANDROID
widget
:
:
AndroidCompositorWidget
*
widget
=
mLayerManager
-
>
GetCompositor
(
)
-
>
GetWidget
(
)
-
>
AsAndroid
(
)
;
if
(
!
widget
)
{
return
;
}
widget
-
>
SetFirstPaintViewport
(
aOffset
aZoom
aCssPageRect
)
;
#
endif
}
void
AsyncCompositionManager
:
:
SetPageRect
(
const
CSSRect
&
aCssPageRect
)
{
#
ifdef
MOZ_WIDGET_ANDROID
widget
:
:
AndroidCompositorWidget
*
widget
=
mLayerManager
-
>
GetCompositor
(
)
-
>
GetWidget
(
)
-
>
AsAndroid
(
)
;
if
(
!
widget
)
{
return
;
}
widget
-
>
SetPageRect
(
aCssPageRect
)
;
#
endif
}
void
AsyncCompositionManager
:
:
SyncViewportInfo
(
const
LayerIntRect
&
aDisplayPort
const
CSSToLayerScale
&
aDisplayResolution
bool
aLayersUpdated
int32_t
aPaintSyncId
ParentLayerRect
&
aScrollRect
CSSToParentLayerScale
&
aScale
ScreenMargin
&
aFixedLayerMargins
)
{
#
ifdef
MOZ_WIDGET_ANDROID
widget
:
:
AndroidCompositorWidget
*
widget
=
mLayerManager
-
>
GetCompositor
(
)
-
>
GetWidget
(
)
-
>
AsAndroid
(
)
;
if
(
!
widget
)
{
return
;
}
widget
-
>
SyncViewportInfo
(
aDisplayPort
aDisplayResolution
aLayersUpdated
aPaintSyncId
aScrollRect
aScale
aFixedLayerMargins
)
;
#
endif
}
void
AsyncCompositionManager
:
:
SyncFrameMetrics
(
const
ParentLayerPoint
&
aScrollOffset
const
CSSToParentLayerScale
&
aZoom
const
CSSRect
&
aCssPageRect
const
CSSRect
&
aDisplayPort
const
CSSToLayerScale
&
aPaintedResolution
bool
aLayersUpdated
int32_t
aPaintSyncId
ScreenMargin
&
aFixedLayerMargins
)
{
#
ifdef
MOZ_WIDGET_ANDROID
widget
:
:
AndroidCompositorWidget
*
widget
=
mLayerManager
-
>
GetCompositor
(
)
-
>
GetWidget
(
)
-
>
AsAndroid
(
)
;
if
(
!
widget
)
{
return
;
}
widget
-
>
SyncFrameMetrics
(
aScrollOffset
aZoom
aCssPageRect
aDisplayPort
aPaintedResolution
aLayersUpdated
aPaintSyncId
aFixedLayerMargins
)
;
#
endif
}
}
}
