#
include
"
TextureHost
.
h
"
#
include
"
CompositableHost
.
h
"
#
include
"
LayerScope
.
h
"
#
include
"
LayersLogging
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
ipc
/
Shmem
.
h
"
#
include
"
mozilla
/
layers
/
CompositableTransactionParent
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
TextureHostOGL
.
h
"
#
include
"
mozilla
/
layers
/
ImageDataSerializer
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
layers
/
PTextureParent
.
h
"
#
include
"
mozilla
/
unused
.
h
"
#
include
<
limits
>
#
include
"
.
.
/
opengl
/
CompositorOGL
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
IPDLActor
.
h
"
#
ifdef
MOZ_ENABLE_D3D10_LAYER
#
include
"
.
.
/
d3d11
/
CompositorD3D11
.
h
"
#
endif
#
ifdef
MOZ_WIDGET_GONK
#
include
"
.
.
/
opengl
/
GrallocTextureClient
.
h
"
#
include
"
.
.
/
opengl
/
GrallocTextureHost
.
h
"
#
endif
#
ifdef
MOZ_X11
#
include
"
mozilla
/
layers
/
X11TextureHost
.
h
"
#
endif
#
ifdef
XP_MACOSX
#
include
"
.
.
/
opengl
/
MacIOSurfaceTextureHostOGL
.
h
"
#
endif
#
ifdef
XP_WIN
#
include
"
mozilla
/
layers
/
TextureDIB
.
h
"
#
endif
#
if
0
#
define
RECYCLE_LOG
(
.
.
.
)
printf_stderr
(
__VA_ARGS__
)
#
else
#
define
RECYCLE_LOG
(
.
.
.
)
do
{
}
while
(
0
)
#
endif
namespace
mozilla
{
namespace
layers
{
class
TextureParent
:
public
ParentActor
<
PTextureParent
>
{
public
:
explicit
TextureParent
(
CompositableParentManager
*
aManager
)
;
~
TextureParent
(
)
;
bool
Init
(
const
SurfaceDescriptor
&
aSharedData
const
LayersBackend
&
aLayersBackend
const
TextureFlags
&
aFlags
)
;
void
CompositorRecycle
(
)
;
virtual
bool
RecvClientRecycle
(
)
override
;
virtual
bool
RecvRecycleTexture
(
const
TextureFlags
&
aTextureFlags
)
override
;
TextureHost
*
GetTextureHost
(
)
{
return
mTextureHost
;
}
virtual
void
Destroy
(
)
override
;
CompositableParentManager
*
mCompositableManager
;
RefPtr
<
TextureHost
>
mWaitForClientRecycle
;
RefPtr
<
TextureHost
>
mTextureHost
;
}
;
PTextureParent
*
TextureHost
:
:
CreateIPDLActor
(
CompositableParentManager
*
aManager
const
SurfaceDescriptor
&
aSharedData
LayersBackend
aLayersBackend
TextureFlags
aFlags
)
{
if
(
aSharedData
.
type
(
)
=
=
SurfaceDescriptor
:
:
TSurfaceDescriptorBuffer
&
&
aSharedData
.
get_SurfaceDescriptorBuffer
(
)
.
data
(
)
.
type
(
)
=
=
MemoryOrShmem
:
:
Tuintptr_t
&
&
!
aManager
-
>
IsSameProcess
(
)
)
{
NS_ERROR
(
"
A
client
process
is
trying
to
peek
at
our
address
space
using
a
MemoryTexture
!
"
)
;
return
nullptr
;
}
TextureParent
*
actor
=
new
TextureParent
(
aManager
)
;
if
(
!
actor
-
>
Init
(
aSharedData
aLayersBackend
aFlags
)
)
{
delete
actor
;
return
nullptr
;
}
return
actor
;
}
bool
TextureHost
:
:
DestroyIPDLActor
(
PTextureParent
*
actor
)
{
delete
actor
;
return
true
;
}
bool
TextureHost
:
:
SendDeleteIPDLActor
(
PTextureParent
*
actor
)
{
return
PTextureParent
:
:
Send__delete__
(
actor
)
;
}
TextureHost
*
TextureHost
:
:
AsTextureHost
(
PTextureParent
*
actor
)
{
if
(
!
actor
)
{
return
nullptr
;
}
return
static_cast
<
TextureParent
*
>
(
actor
)
-
>
mTextureHost
;
}
PTextureParent
*
TextureHost
:
:
GetIPDLActor
(
)
{
return
mActor
;
}
bool
TextureHost
:
:
SetReleaseFenceHandle
(
const
FenceHandle
&
aReleaseFenceHandle
)
{
if
(
!
aReleaseFenceHandle
.
IsValid
(
)
)
{
return
false
;
}
mReleaseFenceHandle
.
Merge
(
aReleaseFenceHandle
)
;
return
true
;
}
FenceHandle
TextureHost
:
:
GetAndResetReleaseFenceHandle
(
)
{
FenceHandle
fence
;
mReleaseFenceHandle
.
TransferToAnotherFenceHandle
(
fence
)
;
return
fence
;
}
void
TextureHost
:
:
SetAcquireFenceHandle
(
const
FenceHandle
&
aAcquireFenceHandle
)
{
mAcquireFenceHandle
=
aAcquireFenceHandle
;
}
FenceHandle
TextureHost
:
:
GetAndResetAcquireFenceHandle
(
)
{
RefPtr
<
FenceHandle
:
:
FdObj
>
fdObj
=
mAcquireFenceHandle
.
GetAndResetFdObj
(
)
;
return
FenceHandle
(
fdObj
)
;
}
already_AddRefed
<
TextureHost
>
CreateTextureHostOGL
(
const
SurfaceDescriptor
&
aDesc
ISurfaceAllocator
*
aDeallocator
TextureFlags
aFlags
)
;
already_AddRefed
<
TextureHost
>
CreateTextureHostBasic
(
const
SurfaceDescriptor
&
aDesc
ISurfaceAllocator
*
aDeallocator
TextureFlags
aFlags
)
;
already_AddRefed
<
TextureHost
>
CreateTextureHostD3D11
(
const
SurfaceDescriptor
&
aDesc
ISurfaceAllocator
*
aDeallocator
TextureFlags
aFlags
)
;
already_AddRefed
<
TextureHost
>
CreateTextureHostD3D9
(
const
SurfaceDescriptor
&
aDesc
ISurfaceAllocator
*
aDeallocator
TextureFlags
aFlags
)
;
already_AddRefed
<
TextureHost
>
TextureHost
:
:
Create
(
const
SurfaceDescriptor
&
aDesc
ISurfaceAllocator
*
aDeallocator
LayersBackend
aBackend
TextureFlags
aFlags
)
{
switch
(
aDesc
.
type
(
)
)
{
case
SurfaceDescriptor
:
:
TSurfaceDescriptorBuffer
:
case
SurfaceDescriptor
:
:
TSurfaceDescriptorDIB
:
case
SurfaceDescriptor
:
:
TSurfaceDescriptorFileMapping
:
return
CreateBackendIndependentTextureHost
(
aDesc
aDeallocator
aFlags
)
;
case
SurfaceDescriptor
:
:
TEGLImageDescriptor
:
case
SurfaceDescriptor
:
:
TSurfaceTextureDescriptor
:
case
SurfaceDescriptor
:
:
TSurfaceDescriptorSharedGLTexture
:
return
CreateTextureHostOGL
(
aDesc
aDeallocator
aFlags
)
;
case
SurfaceDescriptor
:
:
TSurfaceDescriptorGralloc
:
case
SurfaceDescriptor
:
:
TSurfaceDescriptorMacIOSurface
:
if
(
aBackend
=
=
LayersBackend
:
:
LAYERS_OPENGL
)
{
return
CreateTextureHostOGL
(
aDesc
aDeallocator
aFlags
)
;
}
else
{
return
CreateTextureHostBasic
(
aDesc
aDeallocator
aFlags
)
;
}
#
ifdef
MOZ_X11
case
SurfaceDescriptor
:
:
TSurfaceDescriptorX11
:
{
const
SurfaceDescriptorX11
&
desc
=
aDesc
.
get_SurfaceDescriptorX11
(
)
;
return
MakeAndAddRef
<
X11TextureHost
>
(
aFlags
desc
)
;
}
#
endif
#
ifdef
XP_WIN
case
SurfaceDescriptor
:
:
TSurfaceDescriptorD3D9
:
return
CreateTextureHostD3D9
(
aDesc
aDeallocator
aFlags
)
;
case
SurfaceDescriptor
:
:
TSurfaceDescriptorD3D10
:
case
SurfaceDescriptor
:
:
TSurfaceDescriptorDXGIYCbCr
:
if
(
aBackend
=
=
LayersBackend
:
:
LAYERS_D3D9
)
{
return
CreateTextureHostD3D9
(
aDesc
aDeallocator
aFlags
)
;
}
else
{
return
CreateTextureHostD3D11
(
aDesc
aDeallocator
aFlags
)
;
}
#
endif
default
:
MOZ_CRASH
(
"
GFX
:
Unsupported
Surface
type
host
"
)
;
}
}
already_AddRefed
<
TextureHost
>
CreateBackendIndependentTextureHost
(
const
SurfaceDescriptor
&
aDesc
ISurfaceAllocator
*
aDeallocator
TextureFlags
aFlags
)
{
RefPtr
<
TextureHost
>
result
;
switch
(
aDesc
.
type
(
)
)
{
case
SurfaceDescriptor
:
:
TSurfaceDescriptorBuffer
:
{
const
SurfaceDescriptorBuffer
&
bufferDesc
=
aDesc
.
get_SurfaceDescriptorBuffer
(
)
;
const
MemoryOrShmem
&
data
=
bufferDesc
.
data
(
)
;
switch
(
data
.
type
(
)
)
{
case
MemoryOrShmem
:
:
TShmem
:
{
result
=
new
ShmemTextureHost
(
data
.
get_Shmem
(
)
bufferDesc
.
desc
(
)
aDeallocator
aFlags
)
;
break
;
}
case
MemoryOrShmem
:
:
Tuintptr_t
:
{
result
=
new
MemoryTextureHost
(
reinterpret_cast
<
uint8_t
*
>
(
data
.
get_uintptr_t
(
)
)
bufferDesc
.
desc
(
)
aFlags
)
;
break
;
}
default
:
MOZ_CRASH
(
)
;
}
break
;
}
#
ifdef
XP_WIN
case
SurfaceDescriptor
:
:
TSurfaceDescriptorDIB
:
{
result
=
new
DIBTextureHost
(
aFlags
aDesc
)
;
break
;
}
case
SurfaceDescriptor
:
:
TSurfaceDescriptorFileMapping
:
{
result
=
new
TextureHostFileMapping
(
aFlags
aDesc
)
;
break
;
}
#
endif
default
:
{
NS_WARNING
(
"
No
backend
independent
TextureHost
for
this
descriptor
type
"
)
;
}
}
return
result
.
forget
(
)
;
}
void
TextureHost
:
:
CompositorRecycle
(
)
{
if
(
!
mActor
)
{
return
;
}
static_cast
<
TextureParent
*
>
(
mActor
)
-
>
CompositorRecycle
(
)
;
}
TextureHost
:
:
TextureHost
(
TextureFlags
aFlags
)
:
mActor
(
nullptr
)
mFlags
(
aFlags
)
mCompositableCount
(
0
)
{
MOZ_COUNT_CTOR
(
TextureHost
)
;
}
TextureHost
:
:
~
TextureHost
(
)
{
MOZ_COUNT_DTOR
(
TextureHost
)
;
}
void
TextureHost
:
:
Finalize
(
)
{
if
(
!
(
GetFlags
(
)
&
TextureFlags
:
:
DEALLOCATE_CLIENT
)
)
{
DeallocateSharedData
(
)
;
DeallocateDeviceData
(
)
;
}
}
void
TextureHost
:
:
RecycleTexture
(
TextureFlags
aFlags
)
{
MOZ_ASSERT
(
GetFlags
(
)
&
TextureFlags
:
:
RECYCLE
)
;
MOZ_ASSERT
(
aFlags
&
TextureFlags
:
:
RECYCLE
)
;
MOZ_ASSERT
(
!
HasRecycleCallback
(
)
)
;
mFlags
=
aFlags
;
}
void
TextureHost
:
:
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
{
aStream
<
<
aPrefix
;
aStream
<
<
nsPrintfCString
(
"
%
s
(
0x
%
p
)
"
Name
(
)
this
)
.
get
(
)
;
if
(
Lock
(
)
)
{
AppendToString
(
aStream
GetSize
(
)
"
[
size
=
"
"
]
"
)
;
AppendToString
(
aStream
GetFormat
(
)
"
[
format
=
"
"
]
"
)
;
Unlock
(
)
;
}
AppendToString
(
aStream
mFlags
"
[
flags
=
"
"
]
"
)
;
#
ifdef
MOZ_DUMP_PAINTING
if
(
gfxPrefs
:
:
LayersDumpTexture
(
)
|
|
profiler_feature_active
(
"
layersdump
"
)
)
{
nsAutoCString
pfx
(
aPrefix
)
;
pfx
+
=
"
"
;
aStream
<
<
"
\
n
"
<
<
pfx
.
get
(
)
<
<
"
Surface
:
"
;
RefPtr
<
gfx
:
:
DataSourceSurface
>
dSurf
=
GetAsSurface
(
)
;
if
(
dSurf
)
{
aStream
<
<
gfxUtils
:
:
GetAsLZ4Base64Str
(
dSurf
)
.
get
(
)
;
}
}
#
endif
}
void
TextureHost
:
:
Updated
(
const
nsIntRegion
*
aRegion
)
{
LayerScope
:
:
ContentChanged
(
this
)
;
UpdatedInternal
(
aRegion
)
;
}
TextureSource
:
:
TextureSource
(
)
:
mCompositableCount
(
0
)
{
MOZ_COUNT_CTOR
(
TextureSource
)
;
}
TextureSource
:
:
~
TextureSource
(
)
{
MOZ_COUNT_DTOR
(
TextureSource
)
;
}
const
char
*
TextureSource
:
:
Name
(
)
const
{
MOZ_CRASH
(
"
TextureSource
without
class
name
"
)
;
return
"
TextureSource
"
;
}
BufferTextureHost
:
:
BufferTextureHost
(
const
BufferDescriptor
&
aDesc
TextureFlags
aFlags
)
:
TextureHost
(
aFlags
)
mCompositor
(
nullptr
)
mUpdateSerial
(
1
)
mLocked
(
false
)
mNeedsFullUpdate
(
false
)
{
mDescriptor
=
aDesc
;
switch
(
mDescriptor
.
type
(
)
)
{
case
BufferDescriptor
:
:
TYCbCrDescriptor
:
{
const
YCbCrDescriptor
&
ycbcr
=
mDescriptor
.
get_YCbCrDescriptor
(
)
;
mSize
=
ycbcr
.
ySize
(
)
;
mFormat
=
gfx
:
:
SurfaceFormat
:
:
YUV
;
break
;
}
case
BufferDescriptor
:
:
TRGBDescriptor
:
{
const
RGBDescriptor
&
rgb
=
mDescriptor
.
get_RGBDescriptor
(
)
;
mSize
=
rgb
.
size
(
)
;
mFormat
=
rgb
.
format
(
)
;
break
;
}
default
:
MOZ_CRASH
(
)
;
}
if
(
aFlags
&
TextureFlags
:
:
COMPONENT_ALPHA
)
{
mNeedsFullUpdate
=
true
;
}
}
BufferTextureHost
:
:
~
BufferTextureHost
(
)
{
}
void
BufferTextureHost
:
:
UpdatedInternal
(
const
nsIntRegion
*
aRegion
)
{
+
+
mUpdateSerial
;
if
(
aRegion
&
&
!
mNeedsFullUpdate
)
{
mMaybeUpdatedRegion
.
OrWith
(
*
aRegion
)
;
}
else
{
mNeedsFullUpdate
=
true
;
}
if
(
GetFlags
(
)
&
TextureFlags
:
:
IMMEDIATE_UPLOAD
)
{
DebugOnly
<
bool
>
result
=
MaybeUpload
(
!
mNeedsFullUpdate
?
&
mMaybeUpdatedRegion
:
nullptr
)
;
NS_WARN_IF_FALSE
(
result
"
Failed
to
upload
a
texture
"
)
;
}
}
void
BufferTextureHost
:
:
SetCompositor
(
Compositor
*
aCompositor
)
{
MOZ_ASSERT
(
aCompositor
)
;
if
(
mCompositor
=
=
aCompositor
)
{
return
;
}
RefPtr
<
TextureSource
>
it
=
mFirstSource
;
while
(
it
)
{
it
-
>
SetCompositor
(
aCompositor
)
;
it
=
it
-
>
GetNextSibling
(
)
;
}
if
(
mFirstSource
&
&
mFirstSource
-
>
IsOwnedBy
(
this
)
)
{
mFirstSource
-
>
SetOwner
(
nullptr
)
;
}
mFirstSource
=
nullptr
;
mCompositor
=
aCompositor
;
}
void
BufferTextureHost
:
:
DeallocateDeviceData
(
)
{
if
(
mFirstSource
&
&
mFirstSource
-
>
NumCompositableRefs
(
)
>
0
)
{
return
;
}
if
(
!
mFirstSource
|
|
!
mFirstSource
-
>
IsOwnedBy
(
this
)
)
{
mFirstSource
=
nullptr
;
return
;
}
mFirstSource
-
>
SetOwner
(
nullptr
)
;
RefPtr
<
TextureSource
>
it
=
mFirstSource
;
while
(
it
)
{
it
-
>
DeallocateDeviceData
(
)
;
it
=
it
-
>
GetNextSibling
(
)
;
}
}
bool
BufferTextureHost
:
:
Lock
(
)
{
MOZ_ASSERT
(
!
mLocked
)
;
if
(
!
MaybeUpload
(
!
mNeedsFullUpdate
?
&
mMaybeUpdatedRegion
:
nullptr
)
)
{
return
false
;
}
mLocked
=
!
!
mFirstSource
;
return
mLocked
;
}
void
BufferTextureHost
:
:
Unlock
(
)
{
MOZ_ASSERT
(
mLocked
)
;
mLocked
=
false
;
}
void
BufferTextureHost
:
:
PrepareTextureSource
(
CompositableTextureSourceRef
&
aTexture
)
{
if
(
mFirstSource
&
&
mFirstSource
-
>
IsOwnedBy
(
this
)
)
{
aTexture
=
mFirstSource
.
get
(
)
;
return
;
}
mFirstSource
=
nullptr
;
DataTextureSource
*
texture
=
aTexture
.
get
(
)
?
aTexture
-
>
AsDataTextureSource
(
)
:
nullptr
;
bool
compatibleFormats
=
texture
&
&
(
mFormat
=
=
texture
-
>
GetFormat
(
)
|
|
(
mFormat
=
=
gfx
:
:
SurfaceFormat
:
:
YUV
&
&
mCompositor
-
>
SupportsEffect
(
EffectTypes
:
:
YCBCR
)
&
&
texture
-
>
GetNextSibling
(
)
)
|
|
(
mFormat
=
=
gfx
:
:
SurfaceFormat
:
:
YUV
&
&
!
mCompositor
-
>
SupportsEffect
(
EffectTypes
:
:
YCBCR
)
&
&
texture
-
>
GetFormat
(
)
=
=
gfx
:
:
SurfaceFormat
:
:
B8G8R8X8
)
)
;
bool
shouldCreateTexture
=
!
compatibleFormats
|
|
texture
-
>
NumCompositableRefs
(
)
>
1
|
|
texture
-
>
HasOwner
(
)
|
|
texture
-
>
GetSize
(
)
!
=
mSize
;
if
(
!
shouldCreateTexture
)
{
mFirstSource
=
texture
;
mFirstSource
-
>
SetOwner
(
this
)
;
}
}
bool
BufferTextureHost
:
:
BindTextureSource
(
CompositableTextureSourceRef
&
aTexture
)
{
MOZ_ASSERT
(
mLocked
)
;
MOZ_ASSERT
(
mFirstSource
)
;
aTexture
=
mFirstSource
;
return
!
!
aTexture
;
}
gfx
:
:
SurfaceFormat
BufferTextureHost
:
:
GetFormat
(
)
const
{
if
(
mFormat
=
=
gfx
:
:
SurfaceFormat
:
:
YUV
&
&
mCompositor
&
&
!
mCompositor
-
>
SupportsEffect
(
EffectTypes
:
:
YCBCR
)
)
{
return
gfx
:
:
SurfaceFormat
:
:
R8G8B8X8
;
}
return
mFormat
;
}
bool
BufferTextureHost
:
:
MaybeUpload
(
nsIntRegion
*
aRegion
)
{
auto
serial
=
mFirstSource
?
mFirstSource
-
>
GetUpdateSerial
(
)
:
0
;
if
(
serial
=
=
mUpdateSerial
)
{
return
true
;
}
if
(
serial
=
=
0
)
{
aRegion
=
nullptr
;
}
if
(
!
Upload
(
aRegion
)
)
{
return
false
;
}
mNeedsFullUpdate
=
false
;
mMaybeUpdatedRegion
.
SetEmpty
(
)
;
mFirstSource
-
>
SetUpdateSerial
(
mUpdateSerial
)
;
return
true
;
}
bool
BufferTextureHost
:
:
Upload
(
nsIntRegion
*
aRegion
)
{
uint8_t
*
buf
=
GetBuffer
(
)
;
if
(
!
buf
)
{
return
false
;
}
if
(
!
mCompositor
)
{
return
false
;
}
if
(
mFormat
=
=
gfx
:
:
SurfaceFormat
:
:
UNKNOWN
)
{
NS_WARNING
(
"
BufferTextureHost
:
unsupported
format
!
"
)
;
return
false
;
}
else
if
(
mFormat
=
=
gfx
:
:
SurfaceFormat
:
:
YUV
)
{
const
YCbCrDescriptor
&
desc
=
mDescriptor
.
get_YCbCrDescriptor
(
)
;
if
(
!
mCompositor
-
>
SupportsEffect
(
EffectTypes
:
:
YCBCR
)
)
{
RefPtr
<
gfx
:
:
DataSourceSurface
>
surf
=
ImageDataSerializer
:
:
DataSourceSurfaceFromYCbCrDescriptor
(
buf
mDescriptor
.
get_YCbCrDescriptor
(
)
)
;
if
(
NS_WARN_IF
(
!
surf
)
)
{
return
false
;
}
if
(
!
mFirstSource
)
{
mFirstSource
=
mCompositor
-
>
CreateDataTextureSource
(
mFlags
)
;
mFirstSource
-
>
SetOwner
(
this
)
;
}
mFirstSource
-
>
Update
(
surf
aRegion
)
;
return
true
;
}
RefPtr
<
DataTextureSource
>
srcY
;
RefPtr
<
DataTextureSource
>
srcU
;
RefPtr
<
DataTextureSource
>
srcV
;
if
(
!
mFirstSource
)
{
srcY
=
mCompositor
-
>
CreateDataTextureSource
(
mFlags
|
TextureFlags
:
:
DISALLOW_BIGIMAGE
)
;
srcU
=
mCompositor
-
>
CreateDataTextureSource
(
mFlags
|
TextureFlags
:
:
DISALLOW_BIGIMAGE
)
;
srcV
=
mCompositor
-
>
CreateDataTextureSource
(
mFlags
|
TextureFlags
:
:
DISALLOW_BIGIMAGE
)
;
mFirstSource
=
srcY
;
mFirstSource
-
>
SetOwner
(
this
)
;
srcY
-
>
SetNextSibling
(
srcU
)
;
srcU
-
>
SetNextSibling
(
srcV
)
;
}
else
{
MOZ_ASSERT
(
mFirstSource
-
>
GetNextSibling
(
)
)
;
MOZ_ASSERT
(
mFirstSource
-
>
GetNextSibling
(
)
-
>
GetNextSibling
(
)
)
;
srcY
=
mFirstSource
;
srcU
=
mFirstSource
-
>
GetNextSibling
(
)
-
>
AsDataTextureSource
(
)
;
srcV
=
mFirstSource
-
>
GetNextSibling
(
)
-
>
GetNextSibling
(
)
-
>
AsDataTextureSource
(
)
;
}
RefPtr
<
gfx
:
:
DataSourceSurface
>
tempY
=
gfx
:
:
Factory
:
:
CreateWrappingDataSourceSurface
(
ImageDataSerializer
:
:
GetYChannel
(
buf
desc
)
desc
.
ySize
(
)
.
width
desc
.
ySize
(
)
gfx
:
:
SurfaceFormat
:
:
A8
)
;
RefPtr
<
gfx
:
:
DataSourceSurface
>
tempCb
=
gfx
:
:
Factory
:
:
CreateWrappingDataSourceSurface
(
ImageDataSerializer
:
:
GetCbChannel
(
buf
desc
)
desc
.
cbCrSize
(
)
.
width
desc
.
cbCrSize
(
)
gfx
:
:
SurfaceFormat
:
:
A8
)
;
RefPtr
<
gfx
:
:
DataSourceSurface
>
tempCr
=
gfx
:
:
Factory
:
:
CreateWrappingDataSourceSurface
(
ImageDataSerializer
:
:
GetCrChannel
(
buf
desc
)
desc
.
cbCrSize
(
)
.
width
desc
.
cbCrSize
(
)
gfx
:
:
SurfaceFormat
:
:
A8
)
;
NS_ASSERTION
(
!
aRegion
"
Unsupported
partial
updates
for
YCbCr
textures
"
)
;
if
(
!
tempY
|
|
!
tempCb
|
|
!
tempCr
|
|
!
srcY
-
>
Update
(
tempY
)
|
|
!
srcU
-
>
Update
(
tempCb
)
|
|
!
srcV
-
>
Update
(
tempCr
)
)
{
NS_WARNING
(
"
failed
to
update
the
DataTextureSource
"
)
;
return
false
;
}
}
else
{
nsIntRegion
*
regionToUpdate
=
aRegion
;
if
(
!
mFirstSource
)
{
mFirstSource
=
mCompositor
-
>
CreateDataTextureSource
(
mFlags
)
;
mFirstSource
-
>
SetOwner
(
this
)
;
if
(
mFlags
&
TextureFlags
:
:
COMPONENT_ALPHA
)
{
regionToUpdate
=
nullptr
;
}
}
RefPtr
<
gfx
:
:
DataSourceSurface
>
surf
=
gfx
:
:
Factory
:
:
CreateWrappingDataSourceSurface
(
GetBuffer
(
)
ImageDataSerializer
:
:
ComputeRGBStride
(
mFormat
mSize
.
width
)
mSize
mFormat
)
;
if
(
!
surf
)
{
return
false
;
}
if
(
!
mFirstSource
-
>
Update
(
surf
.
get
(
)
regionToUpdate
)
)
{
NS_WARNING
(
"
failed
to
update
the
DataTextureSource
"
)
;
return
false
;
}
}
MOZ_ASSERT
(
mFirstSource
)
;
return
true
;
}
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
BufferTextureHost
:
:
GetAsSurface
(
)
{
RefPtr
<
gfx
:
:
DataSourceSurface
>
result
;
if
(
mFormat
=
=
gfx
:
:
SurfaceFormat
:
:
UNKNOWN
)
{
NS_WARNING
(
"
BufferTextureHost
:
unsupported
format
!
"
)
;
return
nullptr
;
}
else
if
(
mFormat
=
=
gfx
:
:
SurfaceFormat
:
:
YUV
)
{
result
=
ImageDataSerializer
:
:
DataSourceSurfaceFromYCbCrDescriptor
(
GetBuffer
(
)
mDescriptor
.
get_YCbCrDescriptor
(
)
)
;
if
(
NS_WARN_IF
(
!
result
)
)
{
return
nullptr
;
}
}
else
{
result
=
gfx
:
:
Factory
:
:
CreateWrappingDataSourceSurface
(
GetBuffer
(
)
ImageDataSerializer
:
:
GetRGBStride
(
mDescriptor
.
get_RGBDescriptor
(
)
)
mSize
mFormat
)
;
}
return
result
.
forget
(
)
;
}
ShmemTextureHost
:
:
ShmemTextureHost
(
const
ipc
:
:
Shmem
&
aShmem
const
BufferDescriptor
&
aDesc
ISurfaceAllocator
*
aDeallocator
TextureFlags
aFlags
)
:
BufferTextureHost
(
aDesc
aFlags
)
mDeallocator
(
aDeallocator
)
{
if
(
aShmem
.
IsReadable
(
)
)
{
mShmem
=
MakeUnique
<
ipc
:
:
Shmem
>
(
aShmem
)
;
}
else
{
gfxCriticalError
(
)
<
<
"
Failed
to
create
a
valid
ShmemTextureHost
"
;
}
MOZ_COUNT_CTOR
(
ShmemTextureHost
)
;
}
ShmemTextureHost
:
:
~
ShmemTextureHost
(
)
{
MOZ_ASSERT
(
!
mShmem
|
|
(
mFlags
&
TextureFlags
:
:
DEALLOCATE_CLIENT
)
"
Leaking
our
buffer
"
)
;
DeallocateDeviceData
(
)
;
MOZ_COUNT_DTOR
(
ShmemTextureHost
)
;
}
void
ShmemTextureHost
:
:
DeallocateSharedData
(
)
{
if
(
mShmem
)
{
MOZ_ASSERT
(
mDeallocator
"
Shared
memory
would
leak
without
a
ISurfaceAllocator
"
)
;
mDeallocator
-
>
DeallocShmem
(
*
mShmem
)
;
mShmem
=
nullptr
;
}
}
void
ShmemTextureHost
:
:
ForgetSharedData
(
)
{
if
(
mShmem
)
{
mShmem
=
nullptr
;
}
}
void
ShmemTextureHost
:
:
OnShutdown
(
)
{
mShmem
=
nullptr
;
}
uint8_t
*
ShmemTextureHost
:
:
GetBuffer
(
)
{
return
mShmem
?
mShmem
-
>
get
<
uint8_t
>
(
)
:
nullptr
;
}
size_t
ShmemTextureHost
:
:
GetBufferSize
(
)
{
return
mShmem
?
mShmem
-
>
Size
<
uint8_t
>
(
)
:
0
;
}
MemoryTextureHost
:
:
MemoryTextureHost
(
uint8_t
*
aBuffer
const
BufferDescriptor
&
aDesc
TextureFlags
aFlags
)
:
BufferTextureHost
(
aDesc
aFlags
)
mBuffer
(
aBuffer
)
{
MOZ_COUNT_CTOR
(
MemoryTextureHost
)
;
}
MemoryTextureHost
:
:
~
MemoryTextureHost
(
)
{
MOZ_ASSERT
(
!
mBuffer
|
|
(
mFlags
&
TextureFlags
:
:
DEALLOCATE_CLIENT
)
"
Leaking
our
buffer
"
)
;
DeallocateDeviceData
(
)
;
MOZ_COUNT_DTOR
(
MemoryTextureHost
)
;
}
void
MemoryTextureHost
:
:
DeallocateSharedData
(
)
{
if
(
mBuffer
)
{
GfxMemoryImageReporter
:
:
WillFree
(
mBuffer
)
;
}
delete
[
]
mBuffer
;
mBuffer
=
nullptr
;
}
void
MemoryTextureHost
:
:
ForgetSharedData
(
)
{
mBuffer
=
nullptr
;
}
uint8_t
*
MemoryTextureHost
:
:
GetBuffer
(
)
{
return
mBuffer
;
}
size_t
MemoryTextureHost
:
:
GetBufferSize
(
)
{
return
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
;
}
TextureParent
:
:
TextureParent
(
CompositableParentManager
*
aCompositableManager
)
:
mCompositableManager
(
aCompositableManager
)
{
MOZ_COUNT_CTOR
(
TextureParent
)
;
}
TextureParent
:
:
~
TextureParent
(
)
{
MOZ_COUNT_DTOR
(
TextureParent
)
;
if
(
mTextureHost
)
{
mTextureHost
-
>
ClearRecycleCallback
(
)
;
}
}
static
void
RecycleCallback
(
TextureHost
*
void
*
aClosure
)
{
TextureParent
*
tp
=
reinterpret_cast
<
TextureParent
*
>
(
aClosure
)
;
tp
-
>
CompositorRecycle
(
)
;
}
void
TextureParent
:
:
CompositorRecycle
(
)
{
mTextureHost
-
>
ClearRecycleCallback
(
)
;
if
(
mTextureHost
-
>
GetFlags
(
)
&
TextureFlags
:
:
RECYCLE
)
{
mozilla
:
:
Unused
<
<
SendCompositorRecycle
(
)
;
mWaitForClientRecycle
=
mTextureHost
;
}
}
bool
TextureParent
:
:
RecvClientRecycle
(
)
{
mTextureHost
-
>
SetRecycleCallback
(
RecycleCallback
this
)
;
if
(
!
mWaitForClientRecycle
)
{
RECYCLE_LOG
(
"
Not
a
recycable
tile
"
)
;
}
mWaitForClientRecycle
=
nullptr
;
return
true
;
}
bool
TextureParent
:
:
Init
(
const
SurfaceDescriptor
&
aSharedData
const
LayersBackend
&
aBackend
const
TextureFlags
&
aFlags
)
{
mTextureHost
=
TextureHost
:
:
Create
(
aSharedData
mCompositableManager
aBackend
aFlags
)
;
if
(
mTextureHost
)
{
mTextureHost
-
>
mActor
=
this
;
if
(
aFlags
&
TextureFlags
:
:
RECYCLE
)
{
mWaitForClientRecycle
=
mTextureHost
;
RECYCLE_LOG
(
"
Setup
recycling
for
tile
%
p
\
n
"
this
)
;
}
}
return
!
!
mTextureHost
;
}
void
TextureParent
:
:
Destroy
(
)
{
if
(
!
mTextureHost
)
{
return
;
}
if
(
mTextureHost
-
>
GetFlags
(
)
&
TextureFlags
:
:
RECYCLE
)
{
RECYCLE_LOG
(
"
clear
recycling
for
tile
%
p
\
n
"
this
)
;
mTextureHost
-
>
ClearRecycleCallback
(
)
;
}
if
(
mTextureHost
-
>
GetFlags
(
)
&
TextureFlags
:
:
DEALLOCATE_CLIENT
)
{
mTextureHost
-
>
ForgetSharedData
(
)
;
}
mTextureHost
-
>
ClearRecycleCallback
(
)
;
mWaitForClientRecycle
=
nullptr
;
mTextureHost
-
>
mActor
=
nullptr
;
mTextureHost
=
nullptr
;
}
void
TextureHost
:
:
ReceivedDestroy
(
PTextureParent
*
aActor
)
{
static_cast
<
TextureParent
*
>
(
aActor
)
-
>
RecvDestroy
(
)
;
}
bool
TextureParent
:
:
RecvRecycleTexture
(
const
TextureFlags
&
aTextureFlags
)
{
if
(
!
mTextureHost
)
{
return
true
;
}
mTextureHost
-
>
RecycleTexture
(
aTextureFlags
)
;
return
true
;
}
}
}
