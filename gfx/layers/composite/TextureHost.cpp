#
include
"
TextureHost
.
h
"
#
include
"
CompositableHost
.
h
"
#
include
"
LayerScope
.
h
"
#
include
"
LayersLogging
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
ipc
/
Shmem
.
h
"
#
include
"
mozilla
/
layers
/
CompositableTransactionParent
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
TextureHostBasic
.
h
"
#
include
"
mozilla
/
layers
/
TextureHostOGL
.
h
"
#
include
"
mozilla
/
layers
/
ImageDataSerializer
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
layers
/
GPUVideoTextureHost
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderTextureHost
.
h
"
#
include
"
mozilla
/
webrender
/
RenderBufferTextureHost
.
h
"
#
include
"
mozilla
/
webrender
/
RenderThread
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
layers
/
PTextureParent
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
<
limits
>
#
include
"
.
.
/
opengl
/
CompositorOGL
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
IPDLActor
.
h
"
#
ifdef
MOZ_ENABLE_D3D10_LAYER
#
include
"
.
.
/
d3d11
/
CompositorD3D11
.
h
"
#
endif
#
ifdef
MOZ_X11
#
include
"
mozilla
/
layers
/
X11TextureHost
.
h
"
#
endif
#
ifdef
XP_MACOSX
#
include
"
.
.
/
opengl
/
MacIOSurfaceTextureHostOGL
.
h
"
#
endif
#
ifdef
XP_WIN
#
include
"
mozilla
/
layers
/
TextureDIB
.
h
"
#
endif
#
if
0
#
define
RECYCLE_LOG
(
.
.
.
)
printf_stderr
(
__VA_ARGS__
)
#
else
#
define
RECYCLE_LOG
(
.
.
.
)
do
{
}
while
(
0
)
#
endif
namespace
mozilla
{
namespace
layers
{
class
TextureParent
:
public
ParentActor
<
PTextureParent
>
{
public
:
explicit
TextureParent
(
HostIPCAllocator
*
aAllocator
uint64_t
aSerial
const
wr
:
:
MaybeExternalImageId
&
aExternalImageId
)
;
~
TextureParent
(
)
;
bool
Init
(
const
SurfaceDescriptor
&
aSharedData
const
LayersBackend
&
aLayersBackend
const
TextureFlags
&
aFlags
)
;
void
NotifyNotUsed
(
uint64_t
aTransactionId
)
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvRecycleTexture
(
const
TextureFlags
&
aTextureFlags
)
override
;
TextureHost
*
GetTextureHost
(
)
{
return
mTextureHost
;
}
virtual
void
Destroy
(
)
override
;
uint64_t
GetSerial
(
)
const
{
return
mSerial
;
}
HostIPCAllocator
*
mSurfaceAllocator
;
RefPtr
<
TextureHost
>
mTextureHost
;
const
uint64_t
mSerial
;
wr
:
:
MaybeExternalImageId
mExternalImageId
;
}
;
static
bool
WrapWithWebRenderTextureHost
(
ISurfaceAllocator
*
aDeallocator
LayersBackend
aBackend
TextureFlags
aFlags
)
{
if
(
(
aFlags
&
TextureFlags
:
:
SNAPSHOT
)
|
|
(
aBackend
!
=
LayersBackend
:
:
LAYERS_WR
)
|
|
(
!
aDeallocator
-
>
UsesImageBridge
(
)
&
&
!
aDeallocator
-
>
AsCompositorBridgeParentBase
(
)
)
)
{
return
false
;
}
return
true
;
}
PTextureParent
*
TextureHost
:
:
CreateIPDLActor
(
HostIPCAllocator
*
aAllocator
const
SurfaceDescriptor
&
aSharedData
LayersBackend
aLayersBackend
TextureFlags
aFlags
uint64_t
aSerial
const
wr
:
:
MaybeExternalImageId
&
aExternalImageId
)
{
if
(
aSharedData
.
type
(
)
=
=
SurfaceDescriptor
:
:
TSurfaceDescriptorBuffer
&
&
aSharedData
.
get_SurfaceDescriptorBuffer
(
)
.
data
(
)
.
type
(
)
=
=
MemoryOrShmem
:
:
Tuintptr_t
&
&
!
aAllocator
-
>
IsSameProcess
(
)
)
{
NS_ERROR
(
"
A
client
process
is
trying
to
peek
at
our
address
space
using
a
MemoryTexture
!
"
)
;
return
nullptr
;
}
TextureParent
*
actor
=
new
TextureParent
(
aAllocator
aSerial
aExternalImageId
)
;
if
(
!
actor
-
>
Init
(
aSharedData
aLayersBackend
aFlags
)
)
{
delete
actor
;
return
nullptr
;
}
return
actor
;
}
bool
TextureHost
:
:
DestroyIPDLActor
(
PTextureParent
*
actor
)
{
delete
actor
;
return
true
;
}
bool
TextureHost
:
:
SendDeleteIPDLActor
(
PTextureParent
*
actor
)
{
return
PTextureParent
:
:
Send__delete__
(
actor
)
;
}
TextureHost
*
TextureHost
:
:
AsTextureHost
(
PTextureParent
*
actor
)
{
if
(
!
actor
)
{
return
nullptr
;
}
return
static_cast
<
TextureParent
*
>
(
actor
)
-
>
mTextureHost
;
}
uint64_t
TextureHost
:
:
GetTextureSerial
(
PTextureParent
*
actor
)
{
if
(
!
actor
)
{
return
UINT64_MAX
;
}
return
static_cast
<
TextureParent
*
>
(
actor
)
-
>
mSerial
;
}
PTextureParent
*
TextureHost
:
:
GetIPDLActor
(
)
{
return
mActor
;
}
void
TextureHost
:
:
SetLastFwdTransactionId
(
uint64_t
aTransactionId
)
{
MOZ_ASSERT
(
mFwdTransactionId
<
=
aTransactionId
)
;
mFwdTransactionId
=
aTransactionId
;
}
already_AddRefed
<
TextureHost
>
CreateTextureHostOGL
(
const
SurfaceDescriptor
&
aDesc
ISurfaceAllocator
*
aDeallocator
LayersBackend
aBackend
TextureFlags
aFlags
)
;
already_AddRefed
<
TextureHost
>
CreateTextureHostBasic
(
const
SurfaceDescriptor
&
aDesc
ISurfaceAllocator
*
aDeallocator
LayersBackend
aBackend
TextureFlags
aFlags
)
;
already_AddRefed
<
TextureHost
>
CreateTextureHostD3D11
(
const
SurfaceDescriptor
&
aDesc
ISurfaceAllocator
*
aDeallocator
LayersBackend
aBackend
TextureFlags
aFlags
)
;
already_AddRefed
<
TextureHost
>
TextureHost
:
:
Create
(
const
SurfaceDescriptor
&
aDesc
ISurfaceAllocator
*
aDeallocator
LayersBackend
aBackend
TextureFlags
aFlags
wr
:
:
MaybeExternalImageId
&
aExternalImageId
)
{
RefPtr
<
TextureHost
>
result
;
switch
(
aDesc
.
type
(
)
)
{
case
SurfaceDescriptor
:
:
TSurfaceDescriptorBuffer
:
case
SurfaceDescriptor
:
:
TSurfaceDescriptorDIB
:
case
SurfaceDescriptor
:
:
TSurfaceDescriptorFileMapping
:
case
SurfaceDescriptor
:
:
TSurfaceDescriptorGPUVideo
:
result
=
CreateBackendIndependentTextureHost
(
aDesc
aDeallocator
aBackend
aFlags
)
;
break
;
case
SurfaceDescriptor
:
:
TEGLImageDescriptor
:
case
SurfaceDescriptor
:
:
TSurfaceTextureDescriptor
:
case
SurfaceDescriptor
:
:
TSurfaceDescriptorSharedGLTexture
:
result
=
CreateTextureHostOGL
(
aDesc
aDeallocator
aBackend
aFlags
)
;
break
;
case
SurfaceDescriptor
:
:
TSurfaceDescriptorMacIOSurface
:
if
(
aBackend
=
=
LayersBackend
:
:
LAYERS_OPENGL
|
|
aBackend
=
=
LayersBackend
:
:
LAYERS_WR
)
{
result
=
CreateTextureHostOGL
(
aDesc
aDeallocator
aBackend
aFlags
)
;
break
;
}
else
{
result
=
CreateTextureHostBasic
(
aDesc
aDeallocator
aBackend
aFlags
)
;
break
;
}
#
ifdef
MOZ_X11
case
SurfaceDescriptor
:
:
TSurfaceDescriptorX11
:
{
const
SurfaceDescriptorX11
&
desc
=
aDesc
.
get_SurfaceDescriptorX11
(
)
;
result
=
MakeAndAddRef
<
X11TextureHost
>
(
aFlags
desc
)
;
break
;
}
#
endif
#
ifdef
XP_WIN
case
SurfaceDescriptor
:
:
TSurfaceDescriptorD3D10
:
case
SurfaceDescriptor
:
:
TSurfaceDescriptorDXGIYCbCr
:
result
=
CreateTextureHostD3D11
(
aDesc
aDeallocator
aBackend
aFlags
)
;
break
;
#
endif
default
:
MOZ_CRASH
(
"
GFX
:
Unsupported
Surface
type
host
"
)
;
}
if
(
WrapWithWebRenderTextureHost
(
aDeallocator
aBackend
aFlags
)
)
{
MOZ_ASSERT
(
aExternalImageId
.
isSome
(
)
)
;
result
=
new
WebRenderTextureHost
(
aDesc
aFlags
result
aExternalImageId
.
ref
(
)
)
;
}
return
result
.
forget
(
)
;
}
already_AddRefed
<
TextureHost
>
CreateBackendIndependentTextureHost
(
const
SurfaceDescriptor
&
aDesc
ISurfaceAllocator
*
aDeallocator
LayersBackend
aBackend
TextureFlags
aFlags
)
{
RefPtr
<
TextureHost
>
result
;
switch
(
aDesc
.
type
(
)
)
{
case
SurfaceDescriptor
:
:
TSurfaceDescriptorBuffer
:
{
const
SurfaceDescriptorBuffer
&
bufferDesc
=
aDesc
.
get_SurfaceDescriptorBuffer
(
)
;
const
MemoryOrShmem
&
data
=
bufferDesc
.
data
(
)
;
switch
(
data
.
type
(
)
)
{
case
MemoryOrShmem
:
:
TShmem
:
{
result
=
new
ShmemTextureHost
(
data
.
get_Shmem
(
)
bufferDesc
.
desc
(
)
aDeallocator
aFlags
)
;
break
;
}
case
MemoryOrShmem
:
:
Tuintptr_t
:
{
result
=
new
MemoryTextureHost
(
reinterpret_cast
<
uint8_t
*
>
(
data
.
get_uintptr_t
(
)
)
bufferDesc
.
desc
(
)
aFlags
)
;
break
;
}
default
:
gfxCriticalError
(
)
<
<
"
Failed
texture
host
for
backend
"
<
<
(
int
)
data
.
type
(
)
;
MOZ_CRASH
(
"
GFX
:
No
texture
host
for
backend
"
)
;
}
break
;
}
case
SurfaceDescriptor
:
:
TSurfaceDescriptorGPUVideo
:
{
result
=
new
GPUVideoTextureHost
(
aFlags
aDesc
.
get_SurfaceDescriptorGPUVideo
(
)
)
;
break
;
}
#
ifdef
XP_WIN
case
SurfaceDescriptor
:
:
TSurfaceDescriptorDIB
:
{
result
=
new
DIBTextureHost
(
aFlags
aDesc
)
;
break
;
}
case
SurfaceDescriptor
:
:
TSurfaceDescriptorFileMapping
:
{
result
=
new
TextureHostFileMapping
(
aFlags
aDesc
)
;
break
;
}
#
endif
default
:
{
NS_WARNING
(
"
No
backend
independent
TextureHost
for
this
descriptor
type
"
)
;
}
}
return
result
.
forget
(
)
;
}
TextureHost
:
:
TextureHost
(
TextureFlags
aFlags
)
:
AtomicRefCountedWithFinalize
(
"
TextureHost
"
)
mActor
(
nullptr
)
mFlags
(
aFlags
)
mCompositableCount
(
0
)
mFwdTransactionId
(
0
)
{
}
TextureHost
:
:
~
TextureHost
(
)
{
ReadUnlock
(
)
;
}
void
TextureHost
:
:
Finalize
(
)
{
if
(
!
(
GetFlags
(
)
&
TextureFlags
:
:
DEALLOCATE_CLIENT
)
)
{
DeallocateSharedData
(
)
;
DeallocateDeviceData
(
)
;
}
}
void
TextureHost
:
:
UnbindTextureSource
(
)
{
if
(
mReadLock
)
{
if
(
mProvider
)
{
mProvider
-
>
UnlockAfterComposition
(
this
)
;
}
else
{
ReadUnlock
(
)
;
}
}
}
void
TextureHost
:
:
RecycleTexture
(
TextureFlags
aFlags
)
{
MOZ_ASSERT
(
GetFlags
(
)
&
TextureFlags
:
:
RECYCLE
)
;
MOZ_ASSERT
(
aFlags
&
TextureFlags
:
:
RECYCLE
)
;
mFlags
=
aFlags
;
}
void
TextureHost
:
:
NotifyNotUsed
(
)
{
if
(
!
mActor
)
{
return
;
}
if
(
!
(
GetFlags
(
)
&
TextureFlags
:
:
RECYCLE
)
)
{
return
;
}
if
(
!
mProvider
|
|
HasIntermediateBuffer
(
)
|
|
!
mProvider
-
>
NotifyNotUsedAfterComposition
(
this
)
)
{
static_cast
<
TextureParent
*
>
(
mActor
)
-
>
NotifyNotUsed
(
mFwdTransactionId
)
;
return
;
}
}
void
TextureHost
:
:
CallNotifyNotUsed
(
)
{
if
(
!
mActor
)
{
return
;
}
static_cast
<
TextureParent
*
>
(
mActor
)
-
>
NotifyNotUsed
(
mFwdTransactionId
)
;
}
void
TextureHost
:
:
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
{
aStream
<
<
aPrefix
;
aStream
<
<
nsPrintfCString
(
"
%
s
(
0x
%
p
)
"
Name
(
)
this
)
.
get
(
)
;
if
(
Lock
(
)
)
{
AppendToString
(
aStream
GetSize
(
)
"
[
size
=
"
"
]
"
)
;
AppendToString
(
aStream
GetFormat
(
)
"
[
format
=
"
"
]
"
)
;
Unlock
(
)
;
}
AppendToString
(
aStream
mFlags
"
[
flags
=
"
"
]
"
)
;
#
ifdef
MOZ_DUMP_PAINTING
if
(
gfxPrefs
:
:
LayersDumpTexture
(
)
|
|
profiler_feature_active
(
ProfilerFeature
:
:
LayersDump
)
)
{
nsAutoCString
pfx
(
aPrefix
)
;
pfx
+
=
"
"
;
aStream
<
<
"
\
n
"
<
<
pfx
.
get
(
)
<
<
"
Surface
:
"
;
RefPtr
<
gfx
:
:
DataSourceSurface
>
dSurf
=
GetAsSurface
(
)
;
if
(
dSurf
)
{
aStream
<
<
gfxUtils
:
:
GetAsLZ4Base64Str
(
dSurf
)
.
get
(
)
;
}
}
#
endif
}
void
TextureHost
:
:
Updated
(
const
nsIntRegion
*
aRegion
)
{
LayerScope
:
:
ContentChanged
(
this
)
;
UpdatedInternal
(
aRegion
)
;
}
TextureSource
:
:
TextureSource
(
)
:
mCompositableCount
(
0
)
{
}
TextureSource
:
:
~
TextureSource
(
)
{
}
const
char
*
TextureSource
:
:
Name
(
)
const
{
MOZ_CRASH
(
"
GFX
:
TextureSource
without
class
name
"
)
;
return
"
TextureSource
"
;
}
BufferTextureHost
:
:
BufferTextureHost
(
const
BufferDescriptor
&
aDesc
TextureFlags
aFlags
)
:
TextureHost
(
aFlags
)
mUpdateSerial
(
1
)
mLocked
(
false
)
mNeedsFullUpdate
(
false
)
{
mDescriptor
=
aDesc
;
switch
(
mDescriptor
.
type
(
)
)
{
case
BufferDescriptor
:
:
TYCbCrDescriptor
:
{
const
YCbCrDescriptor
&
ycbcr
=
mDescriptor
.
get_YCbCrDescriptor
(
)
;
mSize
=
ycbcr
.
ySize
(
)
;
mFormat
=
gfx
:
:
SurfaceFormat
:
:
YUV
;
mHasIntermediateBuffer
=
ycbcr
.
hasIntermediateBuffer
(
)
;
break
;
}
case
BufferDescriptor
:
:
TRGBDescriptor
:
{
const
RGBDescriptor
&
rgb
=
mDescriptor
.
get_RGBDescriptor
(
)
;
mSize
=
rgb
.
size
(
)
;
mFormat
=
rgb
.
format
(
)
;
mHasIntermediateBuffer
=
rgb
.
hasIntermediateBuffer
(
)
;
break
;
}
default
:
gfxCriticalError
(
)
<
<
"
Bad
buffer
host
descriptor
"
<
<
(
int
)
mDescriptor
.
type
(
)
;
MOZ_CRASH
(
"
GFX
:
Bad
descriptor
"
)
;
}
if
(
aFlags
&
TextureFlags
:
:
COMPONENT_ALPHA
)
{
mNeedsFullUpdate
=
true
;
}
}
BufferTextureHost
:
:
~
BufferTextureHost
(
)
{
}
void
BufferTextureHost
:
:
UpdatedInternal
(
const
nsIntRegion
*
aRegion
)
{
+
+
mUpdateSerial
;
if
(
aRegion
&
&
!
mNeedsFullUpdate
)
{
mMaybeUpdatedRegion
.
OrWith
(
*
aRegion
)
;
}
else
{
mNeedsFullUpdate
=
true
;
}
if
(
GetFlags
(
)
&
TextureFlags
:
:
IMMEDIATE_UPLOAD
)
{
DebugOnly
<
bool
>
result
=
MaybeUpload
(
!
mNeedsFullUpdate
?
&
mMaybeUpdatedRegion
:
nullptr
)
;
NS_WARNING_ASSERTION
(
result
"
Failed
to
upload
a
texture
"
)
;
}
}
void
BufferTextureHost
:
:
SetTextureSourceProvider
(
TextureSourceProvider
*
aProvider
)
{
if
(
mProvider
=
=
aProvider
)
{
return
;
}
if
(
mFirstSource
&
&
mFirstSource
-
>
IsOwnedBy
(
this
)
)
{
mFirstSource
-
>
SetOwner
(
nullptr
)
;
}
if
(
mFirstSource
)
{
mFirstSource
=
nullptr
;
mNeedsFullUpdate
=
true
;
}
mProvider
=
aProvider
;
}
void
BufferTextureHost
:
:
DeallocateDeviceData
(
)
{
if
(
mFirstSource
&
&
mFirstSource
-
>
NumCompositableRefs
(
)
>
0
)
{
return
;
}
if
(
!
mFirstSource
|
|
!
mFirstSource
-
>
IsOwnedBy
(
this
)
)
{
mFirstSource
=
nullptr
;
return
;
}
mFirstSource
-
>
SetOwner
(
nullptr
)
;
RefPtr
<
TextureSource
>
it
=
mFirstSource
;
while
(
it
)
{
it
-
>
DeallocateDeviceData
(
)
;
it
=
it
-
>
GetNextSibling
(
)
;
}
}
bool
BufferTextureHost
:
:
Lock
(
)
{
MOZ_ASSERT
(
!
mLocked
)
;
if
(
!
UploadIfNeeded
(
)
)
{
return
false
;
}
mLocked
=
!
!
mFirstSource
;
return
mLocked
;
}
void
BufferTextureHost
:
:
Unlock
(
)
{
MOZ_ASSERT
(
mLocked
)
;
mLocked
=
false
;
}
void
BufferTextureHost
:
:
CreateRenderTexture
(
const
wr
:
:
ExternalImageId
&
aExternalImageId
)
{
RefPtr
<
wr
:
:
RenderTextureHost
>
texture
=
new
wr
:
:
RenderBufferTextureHost
(
GetBuffer
(
)
GetBufferDescriptor
(
)
)
;
wr
:
:
RenderThread
:
:
Get
(
)
-
>
RegisterExternalImage
(
wr
:
:
AsUint64
(
aExternalImageId
)
texture
.
forget
(
)
)
;
}
uint32_t
BufferTextureHost
:
:
NumSubTextures
(
)
const
{
if
(
GetFormat
(
)
=
=
gfx
:
:
SurfaceFormat
:
:
YUV
)
{
return
3
;
}
return
1
;
}
void
BufferTextureHost
:
:
PushResourceUpdates
(
wr
:
:
ResourceUpdateQueue
&
aResources
ResourceUpdateOp
aOp
const
Range
<
wr
:
:
ImageKey
>
&
aImageKeys
const
wr
:
:
ExternalImageId
&
aExtID
)
{
auto
method
=
aOp
=
=
TextureHost
:
:
ADD_IMAGE
?
&
wr
:
:
ResourceUpdateQueue
:
:
AddExternalImage
:
&
wr
:
:
ResourceUpdateQueue
:
:
UpdateExternalImage
;
auto
bufferType
=
wr
:
:
WrExternalImageBufferType
:
:
ExternalBuffer
;
if
(
GetFormat
(
)
!
=
gfx
:
:
SurfaceFormat
:
:
YUV
)
{
MOZ_ASSERT
(
aImageKeys
.
length
(
)
=
=
1
)
;
wr
:
:
ImageDescriptor
descriptor
(
GetSize
(
)
ImageDataSerializer
:
:
ComputeRGBStride
(
GetFormat
(
)
GetSize
(
)
.
width
)
GetFormat
(
)
)
;
(
aResources
.
*
method
)
(
aImageKeys
[
0
]
descriptor
aExtID
bufferType
0
)
;
}
else
{
MOZ_ASSERT
(
aImageKeys
.
length
(
)
=
=
3
)
;
const
layers
:
:
YCbCrDescriptor
&
desc
=
mDescriptor
.
get_YCbCrDescriptor
(
)
;
wr
:
:
ImageDescriptor
yDescriptor
(
desc
.
ySize
(
)
desc
.
ySize
(
)
.
width
gfx
:
:
SurfaceFormat
:
:
A8
)
;
wr
:
:
ImageDescriptor
cbcrDescriptor
(
desc
.
cbCrSize
(
)
desc
.
cbCrSize
(
)
.
width
gfx
:
:
SurfaceFormat
:
:
A8
)
;
(
aResources
.
*
method
)
(
aImageKeys
[
0
]
yDescriptor
aExtID
bufferType
0
)
;
(
aResources
.
*
method
)
(
aImageKeys
[
1
]
cbcrDescriptor
aExtID
bufferType
1
)
;
(
aResources
.
*
method
)
(
aImageKeys
[
2
]
cbcrDescriptor
aExtID
bufferType
2
)
;
}
}
void
BufferTextureHost
:
:
PushDisplayItems
(
wr
:
:
DisplayListBuilder
&
aBuilder
const
wr
:
:
LayoutRect
&
aBounds
const
wr
:
:
LayoutRect
&
aClip
wr
:
:
ImageRendering
aFilter
const
Range
<
wr
:
:
ImageKey
>
&
aImageKeys
)
{
if
(
GetFormat
(
)
!
=
gfx
:
:
SurfaceFormat
:
:
YUV
)
{
MOZ_ASSERT
(
aImageKeys
.
length
(
)
=
=
1
)
;
aBuilder
.
PushImage
(
aBounds
aClip
true
aFilter
aImageKeys
[
0
]
)
;
}
else
{
MOZ_ASSERT
(
aImageKeys
.
length
(
)
=
=
3
)
;
aBuilder
.
PushYCbCrPlanarImage
(
aBounds
aClip
true
aImageKeys
[
0
]
aImageKeys
[
1
]
aImageKeys
[
2
]
wr
:
:
WrYuvColorSpace
:
:
Rec601
aFilter
)
;
}
}
void
TextureHost
:
:
DeserializeReadLock
(
const
ReadLockDescriptor
&
aDesc
ISurfaceAllocator
*
aAllocator
)
{
RefPtr
<
TextureReadLock
>
lock
=
TextureReadLock
:
:
Deserialize
(
aDesc
aAllocator
)
;
if
(
!
lock
)
{
return
;
}
MOZ_ASSERT
(
!
mReadLock
)
;
mReadLock
=
lock
.
forget
(
)
;
}
void
TextureHost
:
:
SetReadLock
(
TextureReadLock
*
aReadLock
)
{
if
(
!
aReadLock
)
{
return
;
}
MOZ_ASSERT
(
!
mReadLock
)
;
mReadLock
=
aReadLock
;
}
void
TextureHost
:
:
ReadUnlock
(
)
{
if
(
mReadLock
)
{
mReadLock
-
>
ReadUnlock
(
)
;
mReadLock
=
nullptr
;
}
}
bool
BufferTextureHost
:
:
EnsureWrappingTextureSource
(
)
{
MOZ_ASSERT
(
!
mHasIntermediateBuffer
)
;
if
(
mFirstSource
&
&
mFirstSource
-
>
IsOwnedBy
(
this
)
)
{
return
true
;
}
if
(
mFirstSource
)
{
mNeedsFullUpdate
=
true
;
mFirstSource
=
nullptr
;
}
if
(
!
mProvider
)
{
return
false
;
}
if
(
mFormat
=
=
gfx
:
:
SurfaceFormat
:
:
YUV
)
{
mFirstSource
=
mProvider
-
>
CreateDataTextureSourceAroundYCbCr
(
this
)
;
}
else
{
RefPtr
<
gfx
:
:
DataSourceSurface
>
surf
=
gfx
:
:
Factory
:
:
CreateWrappingDataSourceSurface
(
GetBuffer
(
)
ImageDataSerializer
:
:
ComputeRGBStride
(
mFormat
mSize
.
width
)
mSize
mFormat
)
;
if
(
!
surf
)
{
return
false
;
}
mFirstSource
=
mProvider
-
>
CreateDataTextureSourceAround
(
surf
)
;
}
if
(
!
mFirstSource
)
{
NS_WARNING
(
"
Failed
to
use
a
BufferTextureHost
without
intermediate
buffer
"
)
;
return
false
;
}
mFirstSource
-
>
SetUpdateSerial
(
mUpdateSerial
)
;
mFirstSource
-
>
SetOwner
(
this
)
;
return
true
;
}
static
bool
IsCompatibleTextureSource
(
TextureSource
*
aTexture
const
BufferDescriptor
&
aDescriptor
TextureSourceProvider
*
aProvider
)
{
if
(
!
aProvider
)
{
return
false
;
}
switch
(
aDescriptor
.
type
(
)
)
{
case
BufferDescriptor
:
:
TYCbCrDescriptor
:
{
const
YCbCrDescriptor
&
ycbcr
=
aDescriptor
.
get_YCbCrDescriptor
(
)
;
if
(
!
aProvider
-
>
SupportsEffect
(
EffectTypes
:
:
YCBCR
)
)
{
return
aTexture
-
>
GetFormat
(
)
=
=
gfx
:
:
SurfaceFormat
:
:
B8G8R8X8
&
&
aTexture
-
>
GetSize
(
)
=
=
ycbcr
.
ySize
(
)
;
}
if
(
aTexture
-
>
GetFormat
(
)
!
=
gfx
:
:
SurfaceFormat
:
:
A8
|
|
aTexture
-
>
GetSize
(
)
!
=
ycbcr
.
ySize
(
)
)
{
return
false
;
}
auto
cbTexture
=
aTexture
-
>
GetSubSource
(
1
)
;
if
(
!
cbTexture
|
|
cbTexture
-
>
GetFormat
(
)
!
=
gfx
:
:
SurfaceFormat
:
:
A8
|
|
cbTexture
-
>
GetSize
(
)
!
=
ycbcr
.
cbCrSize
(
)
)
{
return
false
;
}
auto
crTexture
=
aTexture
-
>
GetSubSource
(
2
)
;
if
(
!
crTexture
|
|
crTexture
-
>
GetFormat
(
)
!
=
gfx
:
:
SurfaceFormat
:
:
A8
|
|
crTexture
-
>
GetSize
(
)
!
=
ycbcr
.
cbCrSize
(
)
)
{
return
false
;
}
return
true
;
}
case
BufferDescriptor
:
:
TRGBDescriptor
:
{
const
RGBDescriptor
&
rgb
=
aDescriptor
.
get_RGBDescriptor
(
)
;
return
aTexture
-
>
GetFormat
(
)
=
=
rgb
.
format
(
)
&
&
aTexture
-
>
GetSize
(
)
=
=
rgb
.
size
(
)
;
}
default
:
{
return
false
;
}
}
}
void
BufferTextureHost
:
:
PrepareTextureSource
(
CompositableTextureSourceRef
&
aTexture
)
{
if
(
mFormat
=
=
gfx
:
:
SurfaceFormat
:
:
YUV
&
&
!
mHasIntermediateBuffer
&
&
aTexture
.
get
(
)
&
&
aTexture
-
>
AsWrappingTextureSourceYCbCrBasic
(
)
&
&
aTexture
-
>
NumCompositableRefs
(
)
<
=
1
&
&
aTexture
-
>
GetSize
(
)
=
=
GetSize
(
)
)
{
aTexture
-
>
AsSourceBasic
(
)
-
>
SetBufferTextureHost
(
this
)
;
aTexture
-
>
AsDataTextureSource
(
)
-
>
SetOwner
(
this
)
;
mFirstSource
=
aTexture
-
>
AsDataTextureSource
(
)
;
mNeedsFullUpdate
=
true
;
}
if
(
!
mHasIntermediateBuffer
)
{
EnsureWrappingTextureSource
(
)
;
}
if
(
mFirstSource
&
&
mFirstSource
-
>
IsOwnedBy
(
this
)
)
{
aTexture
=
mFirstSource
.
get
(
)
;
return
;
}
if
(
mFirstSource
)
{
mNeedsFullUpdate
=
true
;
mFirstSource
=
nullptr
;
}
DataTextureSource
*
texture
=
aTexture
.
get
(
)
?
aTexture
-
>
AsDataTextureSource
(
)
:
nullptr
;
bool
compatibleFormats
=
texture
&
&
IsCompatibleTextureSource
(
texture
mDescriptor
mProvider
)
;
bool
shouldCreateTexture
=
!
compatibleFormats
|
|
texture
-
>
NumCompositableRefs
(
)
>
1
|
|
texture
-
>
HasOwner
(
)
;
if
(
!
shouldCreateTexture
)
{
mFirstSource
=
texture
;
mFirstSource
-
>
SetOwner
(
this
)
;
mNeedsFullUpdate
=
true
;
RefPtr
<
TextureSource
>
it
=
mFirstSource
;
while
(
it
)
{
it
-
>
SetTextureSourceProvider
(
mProvider
)
;
it
=
it
-
>
GetNextSibling
(
)
;
}
}
}
bool
BufferTextureHost
:
:
BindTextureSource
(
CompositableTextureSourceRef
&
aTexture
)
{
MOZ_ASSERT
(
mLocked
)
;
MOZ_ASSERT
(
mFirstSource
)
;
aTexture
=
mFirstSource
;
return
!
!
aTexture
;
}
bool
BufferTextureHost
:
:
AcquireTextureSource
(
CompositableTextureSourceRef
&
aTexture
)
{
if
(
!
UploadIfNeeded
(
)
)
{
return
false
;
}
aTexture
=
mFirstSource
;
return
!
!
mFirstSource
;
}
void
BufferTextureHost
:
:
UnbindTextureSource
(
)
{
if
(
mFirstSource
&
&
mFirstSource
-
>
IsOwnedBy
(
this
)
)
{
mFirstSource
-
>
Unbind
(
)
;
}
ReadUnlock
(
)
;
}
gfx
:
:
SurfaceFormat
BufferTextureHost
:
:
GetFormat
(
)
const
{
if
(
mFormat
=
=
gfx
:
:
SurfaceFormat
:
:
YUV
&
&
mProvider
&
&
!
mProvider
-
>
SupportsEffect
(
EffectTypes
:
:
YCBCR
)
)
{
return
gfx
:
:
SurfaceFormat
:
:
R8G8B8X8
;
}
return
mFormat
;
}
YUVColorSpace
BufferTextureHost
:
:
GetYUVColorSpace
(
)
const
{
if
(
mFormat
=
=
gfx
:
:
SurfaceFormat
:
:
YUV
)
{
const
YCbCrDescriptor
&
desc
=
mDescriptor
.
get_YCbCrDescriptor
(
)
;
return
desc
.
yUVColorSpace
(
)
;
}
return
YUVColorSpace
:
:
UNKNOWN
;
}
uint32_t
BufferTextureHost
:
:
GetBitDepth
(
)
const
{
if
(
mFormat
=
=
gfx
:
:
SurfaceFormat
:
:
YUV
)
{
const
YCbCrDescriptor
&
desc
=
mDescriptor
.
get_YCbCrDescriptor
(
)
;
return
desc
.
bitDepth
(
)
;
}
return
8
;
}
bool
BufferTextureHost
:
:
UploadIfNeeded
(
)
{
return
MaybeUpload
(
!
mNeedsFullUpdate
?
&
mMaybeUpdatedRegion
:
nullptr
)
;
}
bool
BufferTextureHost
:
:
MaybeUpload
(
nsIntRegion
*
aRegion
)
{
auto
serial
=
mFirstSource
?
mFirstSource
-
>
GetUpdateSerial
(
)
:
0
;
if
(
serial
=
=
mUpdateSerial
)
{
return
true
;
}
if
(
serial
=
=
0
)
{
aRegion
=
nullptr
;
}
if
(
!
Upload
(
aRegion
)
)
{
return
false
;
}
if
(
mHasIntermediateBuffer
)
{
ReadUnlock
(
)
;
}
mNeedsFullUpdate
=
false
;
mMaybeUpdatedRegion
.
SetEmpty
(
)
;
mFirstSource
-
>
SetUpdateSerial
(
mUpdateSerial
)
;
return
true
;
}
bool
BufferTextureHost
:
:
Upload
(
nsIntRegion
*
aRegion
)
{
uint8_t
*
buf
=
GetBuffer
(
)
;
if
(
!
buf
)
{
return
false
;
}
if
(
!
mProvider
)
{
return
false
;
}
if
(
!
mHasIntermediateBuffer
&
&
EnsureWrappingTextureSource
(
)
)
{
return
true
;
}
if
(
mFormat
=
=
gfx
:
:
SurfaceFormat
:
:
UNKNOWN
)
{
NS_WARNING
(
"
BufferTextureHost
:
unsupported
format
!
"
)
;
return
false
;
}
else
if
(
mFormat
=
=
gfx
:
:
SurfaceFormat
:
:
YUV
)
{
const
YCbCrDescriptor
&
desc
=
mDescriptor
.
get_YCbCrDescriptor
(
)
;
if
(
!
mProvider
-
>
SupportsEffect
(
EffectTypes
:
:
YCBCR
)
)
{
RefPtr
<
gfx
:
:
DataSourceSurface
>
surf
=
ImageDataSerializer
:
:
DataSourceSurfaceFromYCbCrDescriptor
(
buf
mDescriptor
.
get_YCbCrDescriptor
(
)
)
;
if
(
NS_WARN_IF
(
!
surf
)
)
{
return
false
;
}
if
(
!
mFirstSource
)
{
mFirstSource
=
mProvider
-
>
CreateDataTextureSource
(
mFlags
|
TextureFlags
:
:
RGB_FROM_YCBCR
)
;
mFirstSource
-
>
SetOwner
(
this
)
;
}
mFirstSource
-
>
Update
(
surf
aRegion
)
;
return
true
;
}
RefPtr
<
DataTextureSource
>
srcY
;
RefPtr
<
DataTextureSource
>
srcU
;
RefPtr
<
DataTextureSource
>
srcV
;
if
(
!
mFirstSource
)
{
srcY
=
mProvider
-
>
CreateDataTextureSource
(
mFlags
|
TextureFlags
:
:
DISALLOW_BIGIMAGE
)
;
srcU
=
mProvider
-
>
CreateDataTextureSource
(
mFlags
|
TextureFlags
:
:
DISALLOW_BIGIMAGE
)
;
srcV
=
mProvider
-
>
CreateDataTextureSource
(
mFlags
|
TextureFlags
:
:
DISALLOW_BIGIMAGE
)
;
mFirstSource
=
srcY
;
mFirstSource
-
>
SetOwner
(
this
)
;
srcY
-
>
SetNextSibling
(
srcU
)
;
srcU
-
>
SetNextSibling
(
srcV
)
;
}
else
{
MOZ_ASSERT
(
mFirstSource
-
>
GetNextSibling
(
)
)
;
MOZ_ASSERT
(
mFirstSource
-
>
GetNextSibling
(
)
-
>
GetNextSibling
(
)
)
;
srcY
=
mFirstSource
;
srcU
=
mFirstSource
-
>
GetNextSibling
(
)
-
>
AsDataTextureSource
(
)
;
srcV
=
mFirstSource
-
>
GetNextSibling
(
)
-
>
GetNextSibling
(
)
-
>
AsDataTextureSource
(
)
;
}
RefPtr
<
gfx
:
:
DataSourceSurface
>
tempY
=
gfx
:
:
Factory
:
:
CreateWrappingDataSourceSurface
(
ImageDataSerializer
:
:
GetYChannel
(
buf
desc
)
desc
.
yStride
(
)
desc
.
ySize
(
)
SurfaceFormatForAlphaBitDepth
(
desc
.
bitDepth
(
)
)
)
;
RefPtr
<
gfx
:
:
DataSourceSurface
>
tempCb
=
gfx
:
:
Factory
:
:
CreateWrappingDataSourceSurface
(
ImageDataSerializer
:
:
GetCbChannel
(
buf
desc
)
desc
.
cbCrStride
(
)
desc
.
cbCrSize
(
)
SurfaceFormatForAlphaBitDepth
(
desc
.
bitDepth
(
)
)
)
;
RefPtr
<
gfx
:
:
DataSourceSurface
>
tempCr
=
gfx
:
:
Factory
:
:
CreateWrappingDataSourceSurface
(
ImageDataSerializer
:
:
GetCrChannel
(
buf
desc
)
desc
.
cbCrStride
(
)
desc
.
cbCrSize
(
)
SurfaceFormatForAlphaBitDepth
(
desc
.
bitDepth
(
)
)
)
;
NS_ASSERTION
(
!
aRegion
"
Unsupported
partial
updates
for
YCbCr
textures
"
)
;
if
(
!
tempY
|
|
!
tempCb
|
|
!
tempCr
|
|
!
srcY
-
>
Update
(
tempY
)
|
|
!
srcU
-
>
Update
(
tempCb
)
|
|
!
srcV
-
>
Update
(
tempCr
)
)
{
NS_WARNING
(
"
failed
to
update
the
DataTextureSource
"
)
;
return
false
;
}
}
else
{
nsIntRegion
*
regionToUpdate
=
aRegion
;
if
(
!
mFirstSource
)
{
mFirstSource
=
mProvider
-
>
CreateDataTextureSource
(
mFlags
)
;
mFirstSource
-
>
SetOwner
(
this
)
;
if
(
mFlags
&
TextureFlags
:
:
COMPONENT_ALPHA
)
{
regionToUpdate
=
nullptr
;
}
}
RefPtr
<
gfx
:
:
DataSourceSurface
>
surf
=
gfx
:
:
Factory
:
:
CreateWrappingDataSourceSurface
(
GetBuffer
(
)
ImageDataSerializer
:
:
ComputeRGBStride
(
mFormat
mSize
.
width
)
mSize
mFormat
)
;
if
(
!
surf
)
{
return
false
;
}
if
(
!
mFirstSource
-
>
Update
(
surf
.
get
(
)
regionToUpdate
)
)
{
NS_WARNING
(
"
failed
to
update
the
DataTextureSource
"
)
;
return
false
;
}
}
MOZ_ASSERT
(
mFirstSource
)
;
return
true
;
}
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
BufferTextureHost
:
:
GetAsSurface
(
)
{
RefPtr
<
gfx
:
:
DataSourceSurface
>
result
;
if
(
mFormat
=
=
gfx
:
:
SurfaceFormat
:
:
UNKNOWN
)
{
NS_WARNING
(
"
BufferTextureHost
:
unsupported
format
!
"
)
;
return
nullptr
;
}
else
if
(
mFormat
=
=
gfx
:
:
SurfaceFormat
:
:
YUV
)
{
result
=
ImageDataSerializer
:
:
DataSourceSurfaceFromYCbCrDescriptor
(
GetBuffer
(
)
mDescriptor
.
get_YCbCrDescriptor
(
)
)
;
if
(
NS_WARN_IF
(
!
result
)
)
{
return
nullptr
;
}
}
else
{
result
=
gfx
:
:
Factory
:
:
CreateWrappingDataSourceSurface
(
GetBuffer
(
)
ImageDataSerializer
:
:
GetRGBStride
(
mDescriptor
.
get_RGBDescriptor
(
)
)
mSize
mFormat
)
;
}
return
result
.
forget
(
)
;
}
ShmemTextureHost
:
:
ShmemTextureHost
(
const
ipc
:
:
Shmem
&
aShmem
const
BufferDescriptor
&
aDesc
ISurfaceAllocator
*
aDeallocator
TextureFlags
aFlags
)
:
BufferTextureHost
(
aDesc
aFlags
)
mDeallocator
(
aDeallocator
)
{
if
(
aShmem
.
IsReadable
(
)
)
{
mShmem
=
MakeUnique
<
ipc
:
:
Shmem
>
(
aShmem
)
;
}
else
{
gfxCriticalNote
<
<
"
Failed
to
create
a
valid
ShmemTextureHost
"
;
}
MOZ_COUNT_CTOR
(
ShmemTextureHost
)
;
}
ShmemTextureHost
:
:
~
ShmemTextureHost
(
)
{
MOZ_ASSERT
(
!
mShmem
|
|
(
mFlags
&
TextureFlags
:
:
DEALLOCATE_CLIENT
)
"
Leaking
our
buffer
"
)
;
DeallocateDeviceData
(
)
;
MOZ_COUNT_DTOR
(
ShmemTextureHost
)
;
}
void
ShmemTextureHost
:
:
DeallocateSharedData
(
)
{
if
(
mShmem
)
{
MOZ_ASSERT
(
mDeallocator
"
Shared
memory
would
leak
without
a
ISurfaceAllocator
"
)
;
mDeallocator
-
>
AsShmemAllocator
(
)
-
>
DeallocShmem
(
*
mShmem
)
;
mShmem
=
nullptr
;
}
}
void
ShmemTextureHost
:
:
ForgetSharedData
(
)
{
if
(
mShmem
)
{
mShmem
=
nullptr
;
}
}
void
ShmemTextureHost
:
:
OnShutdown
(
)
{
mShmem
=
nullptr
;
}
uint8_t
*
ShmemTextureHost
:
:
GetBuffer
(
)
{
return
mShmem
?
mShmem
-
>
get
<
uint8_t
>
(
)
:
nullptr
;
}
size_t
ShmemTextureHost
:
:
GetBufferSize
(
)
{
return
mShmem
?
mShmem
-
>
Size
<
uint8_t
>
(
)
:
0
;
}
MemoryTextureHost
:
:
MemoryTextureHost
(
uint8_t
*
aBuffer
const
BufferDescriptor
&
aDesc
TextureFlags
aFlags
)
:
BufferTextureHost
(
aDesc
aFlags
)
mBuffer
(
aBuffer
)
{
MOZ_COUNT_CTOR
(
MemoryTextureHost
)
;
}
MemoryTextureHost
:
:
~
MemoryTextureHost
(
)
{
MOZ_ASSERT
(
!
mBuffer
|
|
(
mFlags
&
TextureFlags
:
:
DEALLOCATE_CLIENT
)
"
Leaking
our
buffer
"
)
;
DeallocateDeviceData
(
)
;
MOZ_COUNT_DTOR
(
MemoryTextureHost
)
;
}
void
MemoryTextureHost
:
:
DeallocateSharedData
(
)
{
if
(
mBuffer
)
{
GfxMemoryImageReporter
:
:
WillFree
(
mBuffer
)
;
}
delete
[
]
mBuffer
;
mBuffer
=
nullptr
;
}
void
MemoryTextureHost
:
:
ForgetSharedData
(
)
{
mBuffer
=
nullptr
;
}
uint8_t
*
MemoryTextureHost
:
:
GetBuffer
(
)
{
return
mBuffer
;
}
size_t
MemoryTextureHost
:
:
GetBufferSize
(
)
{
return
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
;
}
TextureParent
:
:
TextureParent
(
HostIPCAllocator
*
aSurfaceAllocator
uint64_t
aSerial
const
wr
:
:
MaybeExternalImageId
&
aExternalImageId
)
:
mSurfaceAllocator
(
aSurfaceAllocator
)
mSerial
(
aSerial
)
mExternalImageId
(
aExternalImageId
)
{
MOZ_COUNT_CTOR
(
TextureParent
)
;
}
TextureParent
:
:
~
TextureParent
(
)
{
MOZ_COUNT_DTOR
(
TextureParent
)
;
}
void
TextureParent
:
:
NotifyNotUsed
(
uint64_t
aTransactionId
)
{
if
(
!
mTextureHost
)
{
return
;
}
mSurfaceAllocator
-
>
NotifyNotUsed
(
this
aTransactionId
)
;
}
bool
TextureParent
:
:
Init
(
const
SurfaceDescriptor
&
aSharedData
const
LayersBackend
&
aBackend
const
TextureFlags
&
aFlags
)
{
mTextureHost
=
TextureHost
:
:
Create
(
aSharedData
mSurfaceAllocator
aBackend
aFlags
mExternalImageId
)
;
if
(
mTextureHost
)
{
mTextureHost
-
>
mActor
=
this
;
}
return
!
!
mTextureHost
;
}
void
TextureParent
:
:
Destroy
(
)
{
if
(
!
mTextureHost
)
{
return
;
}
mTextureHost
-
>
ReadUnlock
(
)
;
if
(
mTextureHost
-
>
GetFlags
(
)
&
TextureFlags
:
:
DEALLOCATE_CLIENT
)
{
mTextureHost
-
>
ForgetSharedData
(
)
;
}
mTextureHost
-
>
mActor
=
nullptr
;
mTextureHost
=
nullptr
;
}
void
TextureHost
:
:
ReceivedDestroy
(
PTextureParent
*
aActor
)
{
static_cast
<
TextureParent
*
>
(
aActor
)
-
>
RecvDestroy
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
TextureParent
:
:
RecvRecycleTexture
(
const
TextureFlags
&
aTextureFlags
)
{
if
(
!
mTextureHost
)
{
return
IPC_OK
(
)
;
}
mTextureHost
-
>
RecycleTexture
(
aTextureFlags
)
;
return
IPC_OK
(
)
;
}
}
}
