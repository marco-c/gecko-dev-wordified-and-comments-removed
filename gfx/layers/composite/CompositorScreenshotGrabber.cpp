#
include
"
CompositorScreenshotGrabber
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
layers
/
ProfilerScreenshots
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
using
namespace
gfx
;
namespace
layers
{
class
CompositorScreenshotGrabberImpl
final
{
public
:
explicit
CompositorScreenshotGrabberImpl
(
const
IntSize
&
aBufferSize
)
;
~
CompositorScreenshotGrabberImpl
(
)
;
void
GrabScreenshot
(
Compositor
*
aCompositor
)
;
void
ProcessQueue
(
)
;
private
:
struct
QueueItem
final
{
mozilla
:
:
TimeStamp
mTimeStamp
;
RefPtr
<
AsyncReadbackBuffer
>
mScreenshotBuffer
;
gfx
:
:
IntSize
mScreenshotSize
;
gfx
:
:
IntSize
mWindowSize
;
uintptr_t
mWindowIdentifier
;
}
;
RefPtr
<
CompositingRenderTarget
>
ScaleDownWindowTargetToSize
(
Compositor
*
aCompositor
const
gfx
:
:
IntSize
&
aDestSize
CompositingRenderTarget
*
aWindowTarget
size_t
aLevel
)
;
already_AddRefed
<
AsyncReadbackBuffer
>
TakeNextBuffer
(
Compositor
*
aCompositor
)
;
void
ReturnBuffer
(
AsyncReadbackBuffer
*
aBuffer
)
;
nsTArray
<
RefPtr
<
CompositingRenderTarget
>
>
mTargets
;
nsTArray
<
RefPtr
<
AsyncReadbackBuffer
>
>
mAvailableBuffers
;
Maybe
<
QueueItem
>
mCurrentFrameQueueItem
;
nsTArray
<
QueueItem
>
mQueue
;
RefPtr
<
ProfilerScreenshots
>
mProfilerScreenshots
;
const
IntSize
mBufferSize
;
}
;
CompositorScreenshotGrabber
:
:
CompositorScreenshotGrabber
(
)
=
default
;
CompositorScreenshotGrabber
:
:
~
CompositorScreenshotGrabber
(
)
=
default
;
void
CompositorScreenshotGrabber
:
:
MaybeGrabScreenshot
(
Compositor
*
aCompositor
)
{
if
(
ProfilerScreenshots
:
:
IsEnabled
(
)
)
{
if
(
!
mImpl
)
{
mImpl
=
MakeUnique
<
CompositorScreenshotGrabberImpl
>
(
ProfilerScreenshots
:
:
ScreenshotSize
(
)
)
;
}
mImpl
-
>
GrabScreenshot
(
aCompositor
)
;
}
else
if
(
mImpl
)
{
Destroy
(
)
;
}
}
void
CompositorScreenshotGrabber
:
:
MaybeProcessQueue
(
)
{
if
(
ProfilerScreenshots
:
:
IsEnabled
(
)
)
{
if
(
!
mImpl
)
{
mImpl
=
MakeUnique
<
CompositorScreenshotGrabberImpl
>
(
ProfilerScreenshots
:
:
ScreenshotSize
(
)
)
;
}
mImpl
-
>
ProcessQueue
(
)
;
}
else
if
(
mImpl
)
{
Destroy
(
)
;
}
}
void
CompositorScreenshotGrabber
:
:
NotifyEmptyFrame
(
)
{
#
ifdef
MOZ_GECKO_PROFILER
PROFILER_ADD_MARKER
(
"
NoCompositorScreenshot
because
nothing
changed
"
GRAPHICS
)
;
#
endif
}
void
CompositorScreenshotGrabber
:
:
Destroy
(
)
{
mImpl
=
nullptr
;
}
CompositorScreenshotGrabberImpl
:
:
CompositorScreenshotGrabberImpl
(
const
IntSize
&
aBufferSize
)
:
mBufferSize
(
aBufferSize
)
{
}
CompositorScreenshotGrabberImpl
:
:
~
CompositorScreenshotGrabberImpl
(
)
{
}
RefPtr
<
CompositingRenderTarget
>
CompositorScreenshotGrabberImpl
:
:
ScaleDownWindowTargetToSize
(
Compositor
*
aCompositor
const
IntSize
&
aDestSize
CompositingRenderTarget
*
aWindowTarget
size_t
aLevel
)
{
if
(
aLevel
=
=
mTargets
.
Length
(
)
)
{
mTargets
.
AppendElement
(
aCompositor
-
>
CreateRenderTarget
(
IntRect
(
IntPoint
(
)
mBufferSize
*
(
1
<
<
aLevel
)
)
INIT_MODE_NONE
)
)
;
}
MOZ_RELEASE_ASSERT
(
aLevel
<
mTargets
.
Length
(
)
)
;
RefPtr
<
CompositingRenderTarget
>
sourceTarget
=
aWindowTarget
;
IntSize
sourceSize
=
aWindowTarget
-
>
GetSize
(
)
;
if
(
aWindowTarget
-
>
GetSize
(
)
.
width
>
aDestSize
.
width
*
2
)
{
sourceSize
=
aDestSize
*
2
;
sourceTarget
=
ScaleDownWindowTargetToSize
(
aCompositor
sourceSize
aWindowTarget
aLevel
+
1
)
;
}
if
(
sourceTarget
)
{
aCompositor
-
>
SetRenderTarget
(
mTargets
[
aLevel
]
)
;
if
(
aCompositor
-
>
BlitRenderTarget
(
sourceTarget
sourceSize
aDestSize
)
)
{
return
mTargets
[
aLevel
]
;
}
}
return
nullptr
;
}
void
CompositorScreenshotGrabberImpl
:
:
GrabScreenshot
(
Compositor
*
aCompositor
)
{
RefPtr
<
CompositingRenderTarget
>
previousTarget
=
aCompositor
-
>
GetCurrentRenderTarget
(
)
;
RefPtr
<
CompositingRenderTarget
>
windowTarget
=
aCompositor
-
>
GetWindowRenderTarget
(
)
;
if
(
!
windowTarget
)
{
PROFILER_ADD_MARKER
(
"
NoCompositorScreenshot
because
of
unsupported
compositor
"
"
configuration
"
GRAPHICS
)
;
return
;
}
Size
windowSize
(
windowTarget
-
>
GetSize
(
)
)
;
float
scale
=
std
:
:
min
(
mBufferSize
.
width
/
windowSize
.
width
mBufferSize
.
height
/
windowSize
.
height
)
;
IntSize
scaledSize
=
IntSize
:
:
Round
(
windowSize
*
scale
)
;
RefPtr
<
CompositingRenderTarget
>
scaledTarget
=
ScaleDownWindowTargetToSize
(
aCompositor
scaledSize
windowTarget
0
)
;
aCompositor
-
>
SetRenderTarget
(
previousTarget
)
;
if
(
!
scaledTarget
)
{
PROFILER_ADD_MARKER
(
"
NoCompositorScreenshot
because
ScaleDownWindowTargetToSize
failed
"
GRAPHICS
)
;
return
;
}
RefPtr
<
AsyncReadbackBuffer
>
buffer
=
TakeNextBuffer
(
aCompositor
)
;
if
(
!
buffer
)
{
PROFILER_ADD_MARKER
(
"
NoCompositorScreenshot
because
AsyncReadbackBuffer
creation
failed
"
GRAPHICS
)
;
return
;
}
aCompositor
-
>
ReadbackRenderTarget
(
scaledTarget
buffer
)
;
mCurrentFrameQueueItem
=
Some
(
QueueItem
{
TimeStamp
:
:
Now
(
)
std
:
:
move
(
buffer
)
scaledSize
windowTarget
-
>
GetSize
(
)
reinterpret_cast
<
uintptr_t
>
(
static_cast
<
void
*
>
(
this
)
)
}
)
;
}
already_AddRefed
<
AsyncReadbackBuffer
>
CompositorScreenshotGrabberImpl
:
:
TakeNextBuffer
(
Compositor
*
aCompositor
)
{
if
(
!
mAvailableBuffers
.
IsEmpty
(
)
)
{
RefPtr
<
AsyncReadbackBuffer
>
buffer
=
mAvailableBuffers
[
0
]
;
mAvailableBuffers
.
RemoveElementAt
(
0
)
;
return
buffer
.
forget
(
)
;
}
return
aCompositor
-
>
CreateAsyncReadbackBuffer
(
mBufferSize
)
;
}
void
CompositorScreenshotGrabberImpl
:
:
ReturnBuffer
(
AsyncReadbackBuffer
*
aBuffer
)
{
mAvailableBuffers
.
AppendElement
(
aBuffer
)
;
}
void
CompositorScreenshotGrabberImpl
:
:
ProcessQueue
(
)
{
if
(
!
mQueue
.
IsEmpty
(
)
)
{
if
(
!
mProfilerScreenshots
)
{
mProfilerScreenshots
=
new
ProfilerScreenshots
(
)
;
}
for
(
const
auto
&
item
:
mQueue
)
{
mProfilerScreenshots
-
>
SubmitScreenshot
(
item
.
mWindowIdentifier
item
.
mWindowSize
item
.
mScreenshotSize
item
.
mTimeStamp
[
&
item
]
(
DataSourceSurface
*
aTargetSurface
)
{
return
item
.
mScreenshotBuffer
-
>
MapAndCopyInto
(
aTargetSurface
item
.
mScreenshotSize
)
;
}
)
;
ReturnBuffer
(
item
.
mScreenshotBuffer
)
;
}
}
mQueue
.
Clear
(
)
;
if
(
mCurrentFrameQueueItem
)
{
mQueue
.
AppendElement
(
std
:
:
move
(
*
mCurrentFrameQueueItem
)
)
;
mCurrentFrameQueueItem
=
Nothing
(
)
;
}
}
}
}
