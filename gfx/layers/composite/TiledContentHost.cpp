#
include
"
TiledContentHost
.
h
"
#
include
"
mozilla
/
gfx
/
BaseSize
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
layers
/
Effects
.
h
"
#
include
"
mozilla
/
layers
/
LayerMetricsWrapper
.
h
"
#
include
"
mozilla
/
layers
/
PTextureParent
.
h
"
#
include
"
mozilla
/
layers
/
TextureHostOGL
.
h
"
#
ifdef
XP_DARWIN
#
include
"
mozilla
/
layers
/
TextureSync
.
h
"
#
endif
#
include
"
nsAString
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
mozilla
/
StaticPrefs_layers
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
namespace
mozilla
{
using
namespace
gfx
;
namespace
layers
{
class
Layer
;
float
TileHost
:
:
GetFadeInOpacity
(
float
aOpacity
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
!
StaticPrefs
:
:
layers_tiles_fade_in_enabled
(
)
|
|
mFadeStart
.
IsNull
(
)
|
|
now
<
mFadeStart
)
{
return
aOpacity
;
}
float
duration
=
StaticPrefs
:
:
layers_tiles_fade_in_duration_ms
(
)
;
float
elapsed
=
(
now
-
mFadeStart
)
.
ToMilliseconds
(
)
;
if
(
elapsed
>
duration
)
{
mFadeStart
=
TimeStamp
(
)
;
return
aOpacity
;
}
return
aOpacity
*
(
elapsed
/
duration
)
;
}
RefPtr
<
TextureSource
>
TileHost
:
:
AcquireTextureSource
(
)
const
{
if
(
!
mTextureHost
|
|
!
mTextureHost
-
>
AcquireTextureSource
(
mTextureSource
)
)
{
return
nullptr
;
}
return
mTextureSource
.
get
(
)
;
}
RefPtr
<
TextureSource
>
TileHost
:
:
AcquireTextureSourceOnWhite
(
)
const
{
if
(
!
mTextureHostOnWhite
|
|
!
mTextureHostOnWhite
-
>
AcquireTextureSource
(
mTextureSourceOnWhite
)
)
{
return
nullptr
;
}
return
mTextureSourceOnWhite
.
get
(
)
;
}
TiledLayerBufferComposite
:
:
TiledLayerBufferComposite
(
)
:
mFrameResolution
(
)
{
}
TiledLayerBufferComposite
:
:
~
TiledLayerBufferComposite
(
)
{
Clear
(
)
;
}
void
TiledLayerBufferComposite
:
:
SetTextureSourceProvider
(
TextureSourceProvider
*
aProvider
)
{
MOZ_ASSERT
(
aProvider
)
;
for
(
TileHost
&
tile
:
mRetainedTiles
)
{
if
(
tile
.
IsPlaceholderTile
(
)
)
continue
;
tile
.
mTextureHost
-
>
SetTextureSourceProvider
(
aProvider
)
;
if
(
tile
.
mTextureHostOnWhite
)
{
tile
.
mTextureHostOnWhite
-
>
SetTextureSourceProvider
(
aProvider
)
;
}
}
}
void
TiledLayerBufferComposite
:
:
AddAnimationInvalidation
(
nsIntRegion
&
aRegion
)
{
for
(
size_t
i
=
0
;
i
<
mRetainedTiles
.
Length
(
)
;
i
+
+
)
{
if
(
!
mRetainedTiles
[
i
]
.
mFadeStart
.
IsNull
(
)
)
{
TileCoordIntPoint
coord
=
mTiles
.
TileCoord
(
i
)
;
IntPoint
offset
=
GetTileOffset
(
coord
)
;
nsIntRegion
tileRegion
=
IntRect
(
offset
GetScaledTileSize
(
)
)
;
aRegion
.
OrWith
(
tileRegion
)
;
}
}
}
TiledContentHost
:
:
TiledContentHost
(
const
TextureInfo
&
aTextureInfo
)
:
ContentHost
(
aTextureInfo
)
mTiledBuffer
(
TiledLayerBufferComposite
(
)
)
mLowPrecisionTiledBuffer
(
TiledLayerBufferComposite
(
)
)
{
MOZ_COUNT_CTOR
(
TiledContentHost
)
;
}
TiledContentHost
:
:
~
TiledContentHost
(
)
{
MOZ_COUNT_DTOR
(
TiledContentHost
)
;
}
already_AddRefed
<
TexturedEffect
>
TiledContentHost
:
:
GenEffect
(
const
gfx
:
:
SamplingFilter
aSamplingFilter
)
{
MOZ_ASSERT
(
mTiledBuffer
.
GetTileCount
(
)
=
=
1
&
&
mLowPrecisionTiledBuffer
.
GetTileCount
(
)
=
=
0
)
;
MOZ_ASSERT
(
mTiledBuffer
.
GetTile
(
0
)
.
mTextureHost
)
;
TileHost
&
tile
=
mTiledBuffer
.
GetTile
(
0
)
;
if
(
!
tile
.
mTextureHost
-
>
BindTextureSource
(
tile
.
mTextureSource
)
)
{
return
nullptr
;
}
return
CreateTexturedEffect
(
tile
.
mTextureSource
nullptr
aSamplingFilter
true
)
;
}
void
TiledContentHost
:
:
Attach
(
Layer
*
aLayer
TextureSourceProvider
*
aProvider
AttachFlags
aFlags
)
{
CompositableHost
:
:
Attach
(
aLayer
aProvider
aFlags
)
;
}
void
TiledContentHost
:
:
Detach
(
Layer
*
aLayer
AttachFlags
aFlags
)
{
if
(
!
mKeepAttached
|
|
aLayer
=
=
mLayer
|
|
aFlags
&
FORCE_DETACH
)
{
mTiledBuffer
.
Clear
(
)
;
mLowPrecisionTiledBuffer
.
Clear
(
)
;
}
CompositableHost
:
:
Detach
(
aLayer
aFlags
)
;
}
bool
TiledContentHost
:
:
UseTiledLayerBuffer
(
ISurfaceAllocator
*
aAllocator
const
SurfaceDescriptorTiles
&
aTiledDescriptor
)
{
return
false
;
}
class
TextureSourceRecycler
{
public
:
explicit
TextureSourceRecycler
(
nsTArray
<
TileHost
>
&
&
aTileSet
)
:
mTiles
(
std
:
:
move
(
aTileSet
)
)
mFirstPossibility
(
0
)
{
}
void
RecycleTextureSourceForTile
(
TileHost
&
aTile
)
{
for
(
size_t
i
=
mFirstPossibility
;
i
<
mTiles
.
Length
(
)
;
i
+
+
)
{
if
(
!
mTiles
[
i
]
.
mTextureSource
)
{
if
(
i
=
=
mFirstPossibility
)
{
mFirstPossibility
+
+
;
}
continue
;
}
if
(
aTile
.
mTextureHost
=
=
mTiles
[
i
]
.
mTextureHost
)
{
aTile
.
mTextureSource
=
std
:
:
move
(
mTiles
[
i
]
.
mTextureSource
)
;
if
(
aTile
.
mTextureHostOnWhite
)
{
aTile
.
mTextureSourceOnWhite
=
std
:
:
move
(
mTiles
[
i
]
.
mTextureSourceOnWhite
)
;
}
break
;
}
}
}
void
RecycleTextureSource
(
TileHost
&
aTile
)
{
for
(
size_t
i
=
mFirstPossibility
;
i
<
mTiles
.
Length
(
)
;
i
+
+
)
{
if
(
!
mTiles
[
i
]
.
mTextureSource
)
{
if
(
i
=
=
mFirstPossibility
)
{
mFirstPossibility
+
+
;
}
continue
;
}
if
(
mTiles
[
i
]
.
mTextureSource
&
&
mTiles
[
i
]
.
mTextureHost
-
>
GetFormat
(
)
=
=
aTile
.
mTextureHost
-
>
GetFormat
(
)
)
{
aTile
.
mTextureSource
=
std
:
:
move
(
mTiles
[
i
]
.
mTextureSource
)
;
if
(
aTile
.
mTextureHostOnWhite
)
{
aTile
.
mTextureSourceOnWhite
=
std
:
:
move
(
mTiles
[
i
]
.
mTextureSourceOnWhite
)
;
}
break
;
}
}
}
void
RecycleTileFading
(
TileHost
&
aTile
)
{
for
(
size_t
i
=
0
;
i
<
mTiles
.
Length
(
)
;
i
+
+
)
{
if
(
mTiles
[
i
]
.
mTextureHost
=
=
aTile
.
mTextureHost
)
{
aTile
.
mFadeStart
=
mTiles
[
i
]
.
mFadeStart
;
}
}
}
protected
:
nsTArray
<
TileHost
>
mTiles
;
size_t
mFirstPossibility
;
}
;
void
TiledLayerBufferComposite
:
:
Clear
(
)
{
mRetainedTiles
.
Clear
(
)
;
mTiles
.
mFirst
=
TileCoordIntPoint
(
)
;
mTiles
.
mSize
=
TileCoordIntSize
(
)
;
mValidRegion
=
nsIntRegion
(
)
;
mResolution
=
1
.
0
;
}
void
TiledContentHost
:
:
Composite
(
Compositor
*
aCompositor
LayerComposite
*
aLayer
EffectChain
&
aEffectChain
float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfx
:
:
SamplingFilter
aSamplingFilter
const
gfx
:
:
IntRect
&
aClipRect
const
nsIntRegion
*
aVisibleRegion
const
Maybe
<
gfx
:
:
Polygon
>
&
aGeometry
)
{
DeviceColor
backgroundColor
;
if
(
aOpacity
=
=
1
.
0f
&
&
StaticPrefs
:
:
layers_low_precision_opacity
(
)
<
1
.
0f
)
{
for
(
LayerMetricsWrapper
ancestor
(
GetLayer
(
)
LayerMetricsWrapper
:
:
StartAt
:
:
BOTTOM
)
;
ancestor
;
ancestor
=
ancestor
.
GetParent
(
)
)
{
if
(
ancestor
.
Metrics
(
)
.
IsScrollable
(
)
)
{
backgroundColor
=
ancestor
.
Metadata
(
)
.
GetBackgroundColor
(
)
;
break
;
}
}
}
float
lowPrecisionOpacityReduction
=
(
aOpacity
=
=
1
.
0f
&
&
backgroundColor
.
a
=
=
1
.
0f
)
?
StaticPrefs
:
:
layers_low_precision_opacity
(
)
:
1
.
0f
;
nsIntRegion
tmpRegion
;
const
nsIntRegion
*
renderRegion
=
aVisibleRegion
;
#
ifndef
MOZ_IGNORE_PAINT_WILL_RESAMPLE
if
(
PaintWillResample
(
)
)
{
tmpRegion
=
aVisibleRegion
-
>
GetBounds
(
)
;
renderRegion
=
&
tmpRegion
;
}
#
endif
RenderLayerBuffer
(
mLowPrecisionTiledBuffer
aCompositor
lowPrecisionOpacityReduction
<
1
.
0f
?
&
backgroundColor
:
nullptr
aEffectChain
lowPrecisionOpacityReduction
*
aOpacity
aSamplingFilter
aClipRect
*
renderRegion
aTransform
aGeometry
)
;
RenderLayerBuffer
(
mTiledBuffer
aCompositor
nullptr
aEffectChain
aOpacity
aSamplingFilter
aClipRect
*
renderRegion
aTransform
aGeometry
)
;
}
void
TiledContentHost
:
:
RenderTile
(
TileHost
&
aTile
Compositor
*
aCompositor
EffectChain
&
aEffectChain
float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfx
:
:
SamplingFilter
aSamplingFilter
const
gfx
:
:
IntRect
&
aClipRect
const
nsIntRegion
&
aScreenRegion
const
IntPoint
&
aTextureOffset
const
IntSize
&
aTextureBounds
const
gfx
:
:
Rect
&
aVisibleRect
const
Maybe
<
gfx
:
:
Polygon
>
&
aGeometry
)
{
MOZ_ASSERT
(
!
aTile
.
IsPlaceholderTile
(
)
)
;
AutoLockTextureHost
autoLock
(
aTile
.
mTextureHost
)
;
AutoLockTextureHost
autoLockOnWhite
(
aTile
.
mTextureHostOnWhite
)
;
if
(
autoLock
.
Failed
(
)
|
|
autoLockOnWhite
.
Failed
(
)
)
{
NS_WARNING
(
"
Failed
to
lock
tile
"
)
;
return
;
}
if
(
!
aTile
.
mTextureHost
-
>
BindTextureSource
(
aTile
.
mTextureSource
)
)
{
return
;
}
if
(
aTile
.
mTextureHostOnWhite
&
&
!
aTile
.
mTextureHostOnWhite
-
>
BindTextureSource
(
aTile
.
mTextureSourceOnWhite
)
)
{
return
;
}
RefPtr
<
TexturedEffect
>
effect
=
CreateTexturedEffect
(
aTile
.
mTextureSource
aTile
.
mTextureSourceOnWhite
aSamplingFilter
true
)
;
if
(
!
effect
)
{
return
;
}
float
opacity
=
aTile
.
GetFadeInOpacity
(
aOpacity
)
;
aEffectChain
.
mPrimaryEffect
=
effect
;
for
(
auto
iter
=
aScreenRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
IntRect
&
rect
=
iter
.
Get
(
)
;
Rect
graphicsRect
(
rect
.
X
(
)
rect
.
Y
(
)
rect
.
Width
(
)
rect
.
Height
(
)
)
;
Rect
textureRect
(
rect
.
X
(
)
-
aTextureOffset
.
x
rect
.
Y
(
)
-
aTextureOffset
.
y
rect
.
Width
(
)
rect
.
Height
(
)
)
;
effect
-
>
mTextureCoords
.
SetRect
(
textureRect
.
X
(
)
/
aTextureBounds
.
width
textureRect
.
Y
(
)
/
aTextureBounds
.
height
textureRect
.
Width
(
)
/
aTextureBounds
.
width
textureRect
.
Height
(
)
/
aTextureBounds
.
height
)
;
aCompositor
-
>
DrawGeometry
(
graphicsRect
aClipRect
aEffectChain
opacity
aTransform
aVisibleRect
aGeometry
)
;
}
DiagnosticFlags
flags
=
DiagnosticFlags
:
:
CONTENT
|
DiagnosticFlags
:
:
TILE
;
if
(
aTile
.
mTextureHostOnWhite
)
{
flags
|
=
DiagnosticFlags
:
:
COMPONENT_ALPHA
;
}
aCompositor
-
>
DrawDiagnostics
(
flags
aScreenRegion
aClipRect
aTransform
mFlashCounter
)
;
}
void
TiledContentHost
:
:
RenderLayerBuffer
(
TiledLayerBufferComposite
&
aLayerBuffer
Compositor
*
aCompositor
const
DeviceColor
*
aBackgroundColor
EffectChain
&
aEffectChain
float
aOpacity
const
gfx
:
:
SamplingFilter
aSamplingFilter
const
gfx
:
:
IntRect
&
aClipRect
nsIntRegion
aVisibleRegion
gfx
:
:
Matrix4x4
aTransform
const
Maybe
<
Polygon
>
&
aGeometry
)
{
float
resolution
=
aLayerBuffer
.
GetResolution
(
)
;
gfx
:
:
Size
layerScale
(
1
1
)
;
if
(
aLayerBuffer
.
GetFrameResolution
(
)
!
=
mTiledBuffer
.
GetFrameResolution
(
)
)
{
const
CSSToParentLayerScale2D
&
layerResolution
=
aLayerBuffer
.
GetFrameResolution
(
)
;
const
CSSToParentLayerScale2D
&
localResolution
=
mTiledBuffer
.
GetFrameResolution
(
)
;
layerScale
.
width
=
layerResolution
.
xScale
/
localResolution
.
xScale
;
layerScale
.
height
=
layerResolution
.
yScale
/
localResolution
.
yScale
;
aVisibleRegion
.
ScaleRoundOut
(
layerScale
.
width
layerScale
.
height
)
;
}
nsIntRegion
maskRegion
;
if
(
resolution
!
=
mTiledBuffer
.
GetResolution
(
)
)
{
maskRegion
=
mTiledBuffer
.
GetValidRegion
(
)
;
maskRegion
.
ScaleRoundOut
(
layerScale
.
width
layerScale
.
height
)
;
}
aTransform
.
PreScale
(
1
/
(
resolution
*
layerScale
.
width
)
1
/
(
resolution
*
layerScale
.
height
)
1
)
;
DiagnosticFlags
componentAlphaDiagnostic
=
DiagnosticFlags
:
:
NO_DIAGNOSTIC
;
nsIntRegion
compositeRegion
=
aLayerBuffer
.
GetValidRegion
(
)
;
compositeRegion
.
AndWith
(
aVisibleRegion
)
;
compositeRegion
.
SubOut
(
maskRegion
)
;
IntRect
visibleRect
=
aVisibleRegion
.
GetBounds
(
)
;
if
(
compositeRegion
.
IsEmpty
(
)
)
{
return
;
}
if
(
aBackgroundColor
)
{
nsIntRegion
backgroundRegion
=
compositeRegion
;
backgroundRegion
.
ScaleRoundOut
(
resolution
resolution
)
;
EffectChain
effect
;
effect
.
mPrimaryEffect
=
new
EffectSolidColor
(
*
aBackgroundColor
)
;
for
(
auto
iter
=
backgroundRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
IntRect
&
rect
=
iter
.
Get
(
)
;
Rect
graphicsRect
(
rect
.
X
(
)
rect
.
Y
(
)
rect
.
Width
(
)
rect
.
Height
(
)
)
;
aCompositor
-
>
DrawGeometry
(
graphicsRect
aClipRect
effect
1
.
0
aTransform
aGeometry
)
;
}
}
for
(
size_t
i
=
0
;
i
<
aLayerBuffer
.
GetTileCount
(
)
;
+
+
i
)
{
TileHost
&
tile
=
aLayerBuffer
.
GetTile
(
i
)
;
if
(
tile
.
IsPlaceholderTile
(
)
)
{
continue
;
}
TileCoordIntPoint
tileCoord
=
aLayerBuffer
.
GetPlacement
(
)
.
TileCoord
(
i
)
;
MOZ_ASSERT
(
tileCoord
.
x
=
=
tile
.
mTileCoord
.
x
&
&
tileCoord
.
y
=
=
tile
.
mTileCoord
.
y
)
;
IntPoint
tileOffset
=
aLayerBuffer
.
GetTileOffset
(
tileCoord
)
;
nsIntRegion
tileDrawRegion
=
IntRect
(
tileOffset
aLayerBuffer
.
GetScaledTileSize
(
)
)
;
tileDrawRegion
.
AndWith
(
compositeRegion
)
;
if
(
tileDrawRegion
.
IsEmpty
(
)
)
{
continue
;
}
tileDrawRegion
.
ScaleRoundOut
(
resolution
resolution
)
;
RenderTile
(
tile
aCompositor
aEffectChain
aOpacity
aTransform
aSamplingFilter
aClipRect
tileDrawRegion
tileOffset
*
resolution
aLayerBuffer
.
GetTileSize
(
)
gfx
:
:
Rect
(
visibleRect
.
X
(
)
visibleRect
.
Y
(
)
visibleRect
.
Width
(
)
visibleRect
.
Height
(
)
)
aGeometry
)
;
if
(
tile
.
mTextureHostOnWhite
)
{
componentAlphaDiagnostic
=
DiagnosticFlags
:
:
COMPONENT_ALPHA
;
}
}
gfx
:
:
Rect
rect
(
visibleRect
.
X
(
)
visibleRect
.
Y
(
)
visibleRect
.
Width
(
)
visibleRect
.
Height
(
)
)
;
aCompositor
-
>
DrawDiagnostics
(
DiagnosticFlags
:
:
CONTENT
|
componentAlphaDiagnostic
rect
aClipRect
aTransform
mFlashCounter
)
;
}
void
TiledContentHost
:
:
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
{
aStream
<
<
aPrefix
;
aStream
<
<
nsPrintfCString
(
"
TiledContentHost
(
0x
%
p
)
"
this
)
.
get
(
)
;
#
if
defined
(
MOZ_DUMP_PAINTING
)
if
(
StaticPrefs
:
:
layers_dump_texture
(
)
)
{
nsAutoCString
pfx
(
aPrefix
)
;
pfx
+
=
"
"
;
Dump
(
aStream
pfx
.
get
(
)
false
)
;
}
#
endif
}
void
TiledContentHost
:
:
Dump
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
bool
aDumpHtml
)
{
mTiledBuffer
.
Dump
(
aStream
aPrefix
aDumpHtml
TextureDumpMode
:
:
DoNotCompress
)
;
}
void
TiledContentHost
:
:
AddAnimationInvalidation
(
nsIntRegion
&
aRegion
)
{
return
mTiledBuffer
.
AddAnimationInvalidation
(
aRegion
)
;
}
}
}
