#
ifndef
MOZILLA_GFX_IMAGEHOST_H
#
define
MOZILLA_GFX_IMAGEHOST_H
#
include
<
stdio
.
h
>
#
include
"
CompositableHost
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
MatrixFwd
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Polygon
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
ImageComposite
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRegionFwd
.
h
"
#
include
"
nscore
.
h
"
namespace
mozilla
{
namespace
layers
{
class
Compositor
;
struct
EffectChain
;
class
HostLayerManager
;
class
ImageHost
:
public
CompositableHost
public
ImageComposite
{
public
:
explicit
ImageHost
(
const
TextureInfo
&
aTextureInfo
)
;
virtual
~
ImageHost
(
)
;
CompositableType
GetType
(
)
override
{
return
mTextureInfo
.
mCompositableType
;
}
ImageHost
*
AsImageHost
(
)
override
{
return
this
;
}
void
Composite
(
Compositor
*
aCompositor
LayerComposite
*
aLayer
EffectChain
&
aEffectChain
float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfx
:
:
SamplingFilter
aSamplingFilter
const
gfx
:
:
IntRect
&
aClipRect
const
nsIntRegion
*
aVisibleRegion
=
nullptr
const
Maybe
<
gfx
:
:
Polygon
>
&
aGeometry
=
Nothing
(
)
)
override
;
void
UseTextureHost
(
const
nsTArray
<
TimedTexture
>
&
aTextures
)
override
;
void
RemoveTextureHost
(
TextureHost
*
aTexture
)
override
;
TextureHost
*
GetAsTextureHost
(
gfx
:
:
IntRect
*
aPictureRect
=
nullptr
)
override
;
void
Attach
(
Layer
*
aLayer
TextureSourceProvider
*
aProvider
AttachFlags
aFlags
=
NO_FLAGS
)
override
;
void
SetTextureSourceProvider
(
TextureSourceProvider
*
aProvider
)
override
;
gfx
:
:
IntSize
GetImageSize
(
)
override
;
void
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
override
;
void
Dump
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
=
"
"
bool
aDumpHtml
=
false
)
override
;
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
GetAsSurface
(
)
override
;
bool
Lock
(
)
override
;
void
Unlock
(
)
override
;
already_AddRefed
<
TexturedEffect
>
GenEffect
(
const
gfx
:
:
SamplingFilter
aSamplingFilter
)
override
;
void
SetCurrentTextureHost
(
TextureHost
*
aTexture
)
;
void
CleanupResources
(
)
override
;
bool
IsOpaque
(
)
;
uint32_t
GetDroppedFrames
(
)
override
{
return
GetDroppedFramesAndReset
(
)
;
}
struct
RenderInfo
{
int
imageIndex
;
const
TimedImage
*
img
;
RefPtr
<
TextureHost
>
host
;
RenderInfo
(
)
:
imageIndex
(
-
1
)
img
(
nullptr
)
{
}
}
;
bool
PrepareToRender
(
TextureSourceProvider
*
aProvider
RenderInfo
*
aOutInfo
)
;
RefPtr
<
TextureSource
>
AcquireTextureSource
(
const
RenderInfo
&
aInfo
)
;
void
FinishRendering
(
const
RenderInfo
&
aInfo
)
;
TextureHost
*
CurrentTextureHost
(
)
const
{
MOZ_ASSERT
(
mCurrentTextureHost
)
;
return
mCurrentTextureHost
;
}
protected
:
TimeStamp
GetCompositionTime
(
)
const
override
;
CompositionOpportunityId
GetCompositionOpportunityId
(
)
const
override
;
void
AppendImageCompositeNotification
(
const
ImageCompositeNotificationInfo
&
aInfo
)
const
override
;
RefPtr
<
TextureHost
>
mCurrentTextureHost
;
CompositableTextureSourceRef
mCurrentTextureSource
;
RefPtr
<
TextureSource
>
mExtraTextureSource
;
bool
mLocked
;
}
;
}
}
#
endif
