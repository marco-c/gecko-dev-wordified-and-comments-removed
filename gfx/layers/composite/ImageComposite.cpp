#
include
"
ImageComposite
.
h
"
namespace
mozilla
{
using
namespace
gfx
;
namespace
layers
{
const
float
ImageComposite
:
:
BIAS_TIME_MS
=
1
.
0f
;
ImageComposite
:
:
ImageComposite
(
)
:
mLastFrameID
(
-
1
)
mLastProducerID
(
-
1
)
mBias
(
BIAS_NONE
)
mDroppedFrames
(
0
)
mLastChosenImageIndex
(
0
)
{
}
ImageComposite
:
:
~
ImageComposite
(
)
{
}
TimeStamp
ImageComposite
:
:
GetBiasedTime
(
const
TimeStamp
&
aInput
)
const
{
switch
(
mBias
)
{
case
ImageComposite
:
:
BIAS_NEGATIVE
:
return
aInput
-
TimeDuration
:
:
FromMilliseconds
(
BIAS_TIME_MS
)
;
case
ImageComposite
:
:
BIAS_POSITIVE
:
return
aInput
+
TimeDuration
:
:
FromMilliseconds
(
BIAS_TIME_MS
)
;
default
:
return
aInput
;
}
}
void
ImageComposite
:
:
UpdateBias
(
size_t
aImageIndex
)
{
MOZ_ASSERT
(
aImageIndex
<
ImagesCount
(
)
)
;
TimeStamp
compositionTime
=
GetCompositionTime
(
)
;
TimeStamp
compositedImageTime
=
mImages
[
aImageIndex
]
.
mTimeStamp
;
TimeStamp
nextImageTime
=
aImageIndex
+
1
<
ImagesCount
(
)
?
mImages
[
aImageIndex
+
1
]
.
mTimeStamp
:
TimeStamp
(
)
;
if
(
compositedImageTime
.
IsNull
(
)
)
{
mBias
=
ImageComposite
:
:
BIAS_NONE
;
return
;
}
TimeDuration
threshold
=
TimeDuration
:
:
FromMilliseconds
(
1
.
0
)
;
if
(
compositionTime
-
compositedImageTime
<
threshold
&
&
compositionTime
-
compositedImageTime
>
-
threshold
)
{
mBias
=
ImageComposite
:
:
BIAS_NEGATIVE
;
return
;
}
if
(
!
nextImageTime
.
IsNull
(
)
&
&
nextImageTime
-
compositionTime
<
threshold
&
&
nextImageTime
-
compositionTime
>
-
threshold
)
{
mBias
=
ImageComposite
:
:
BIAS_POSITIVE
;
return
;
}
mBias
=
ImageComposite
:
:
BIAS_NONE
;
}
int
ImageComposite
:
:
ChooseImageIndex
(
)
{
if
(
mImages
.
IsEmpty
(
)
)
{
return
-
1
;
}
TimeStamp
now
=
GetCompositionTime
(
)
;
if
(
now
.
IsNull
(
)
)
{
for
(
uint32_t
i
=
0
;
i
<
mImages
.
Length
(
)
;
+
+
i
)
{
if
(
mImages
[
i
]
.
mFrameID
=
=
mLastFrameID
&
&
mImages
[
i
]
.
mProducerID
=
=
mLastProducerID
)
{
return
i
;
}
}
return
-
1
;
}
uint32_t
result
=
mLastChosenImageIndex
;
while
(
result
+
1
<
mImages
.
Length
(
)
&
&
GetBiasedTime
(
mImages
[
result
+
1
]
.
mTimeStamp
)
<
=
now
)
{
+
+
result
;
}
if
(
result
-
mLastChosenImageIndex
>
1
)
{
mDroppedFrames
+
=
result
-
mLastChosenImageIndex
-
1
;
PROFILER_ADD_MARKER
(
"
Video
frames
dropped
"
GRAPHICS
)
;
}
mLastChosenImageIndex
=
result
;
return
result
;
}
const
ImageComposite
:
:
TimedImage
*
ImageComposite
:
:
ChooseImage
(
)
{
int
index
=
ChooseImageIndex
(
)
;
return
index
>
=
0
?
&
mImages
[
index
]
:
nullptr
;
}
void
ImageComposite
:
:
RemoveImagesWithTextureHost
(
TextureHost
*
aTexture
)
{
for
(
int32_t
i
=
mImages
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
mImages
[
i
]
.
mTextureHost
=
=
aTexture
)
{
aTexture
-
>
UnbindTextureSource
(
)
;
mImages
.
RemoveElementAt
(
i
)
;
}
}
}
void
ImageComposite
:
:
ClearImages
(
)
{
mImages
.
Clear
(
)
;
mLastChosenImageIndex
=
0
;
}
uint32_t
ImageComposite
:
:
ScanForLastFrameIndex
(
const
nsTArray
<
TimedImage
>
&
aNewImages
)
{
if
(
mImages
.
IsEmpty
(
)
)
{
return
0
;
}
uint32_t
i
=
mLastChosenImageIndex
;
uint32_t
newIndex
=
0
;
uint32_t
dropped
=
0
;
uint32_t
j
=
0
;
while
(
i
<
mImages
.
Length
(
)
&
&
j
<
aNewImages
.
Length
(
)
)
{
if
(
mImages
[
i
]
.
mProducerID
!
=
aNewImages
[
j
]
.
mProducerID
)
{
newIndex
=
j
;
break
;
}
int32_t
oldFrameID
=
mImages
[
i
]
.
mFrameID
;
int32_t
newFrameID
=
aNewImages
[
j
]
.
mFrameID
;
if
(
oldFrameID
>
newFrameID
)
{
newIndex
=
+
+
j
;
continue
;
}
if
(
oldFrameID
<
mLastFrameID
)
{
i
+
+
;
continue
;
}
if
(
oldFrameID
<
newFrameID
)
{
for
(
+
+
i
;
i
<
mImages
.
Length
(
)
&
&
mImages
[
i
]
.
mFrameID
<
newFrameID
&
&
mImages
[
i
]
.
mProducerID
=
=
aNewImages
[
j
]
.
mProducerID
;
i
+
+
)
{
dropped
+
+
;
}
break
;
}
i
+
+
;
j
+
+
;
}
if
(
dropped
>
0
)
{
mDroppedFrames
+
=
dropped
;
PROFILER_ADD_MARKER
(
"
Video
frames
dropped
"
GRAPHICS
)
;
}
if
(
newIndex
>
=
aNewImages
.
Length
(
)
)
{
newIndex
=
aNewImages
.
Length
(
)
-
1
;
}
return
newIndex
;
}
void
ImageComposite
:
:
SetImages
(
nsTArray
<
TimedImage
>
&
&
aNewImages
)
{
mLastChosenImageIndex
=
ScanForLastFrameIndex
(
aNewImages
)
;
mImages
=
std
:
:
move
(
aNewImages
)
;
}
const
ImageComposite
:
:
TimedImage
*
ImageComposite
:
:
GetImage
(
size_t
aIndex
)
const
{
if
(
aIndex
>
=
mImages
.
Length
(
)
)
{
return
nullptr
;
}
return
&
mImages
[
aIndex
]
;
}
}
}
