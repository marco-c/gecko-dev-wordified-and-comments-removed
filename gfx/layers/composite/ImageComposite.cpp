#
include
"
ImageComposite
.
h
"
#
include
<
inttypes
.
h
>
#
include
"
GeckoProfiler
.
h
"
#
include
"
gfxPlatform
.
h
"
namespace
mozilla
{
using
namespace
gfx
;
namespace
layers
{
const
float
ImageComposite
:
:
BIAS_TIME_MS
=
1
.
0f
;
ImageComposite
:
:
ImageComposite
(
)
=
default
;
ImageComposite
:
:
~
ImageComposite
(
)
=
default
;
TimeStamp
ImageComposite
:
:
GetBiasedTime
(
const
TimeStamp
&
aInput
)
const
{
switch
(
mBias
)
{
case
ImageComposite
:
:
BIAS_NEGATIVE
:
return
aInput
-
TimeDuration
:
:
FromMilliseconds
(
BIAS_TIME_MS
)
;
case
ImageComposite
:
:
BIAS_POSITIVE
:
return
aInput
+
TimeDuration
:
:
FromMilliseconds
(
BIAS_TIME_MS
)
;
default
:
return
aInput
;
}
}
void
ImageComposite
:
:
UpdateBias
(
size_t
aImageIndex
)
{
MOZ_ASSERT
(
aImageIndex
<
ImagesCount
(
)
)
;
TimeStamp
compositionTime
=
GetCompositionTime
(
)
;
TimeStamp
compositedImageTime
=
mImages
[
aImageIndex
]
.
mTimeStamp
;
TimeStamp
nextImageTime
=
aImageIndex
+
1
<
ImagesCount
(
)
?
mImages
[
aImageIndex
+
1
]
.
mTimeStamp
:
TimeStamp
(
)
;
if
(
compositedImageTime
.
IsNull
(
)
)
{
mBias
=
ImageComposite
:
:
BIAS_NONE
;
return
;
}
TimeDuration
threshold
=
TimeDuration
:
:
FromMilliseconds
(
1
.
0
)
;
if
(
compositionTime
-
compositedImageTime
<
threshold
&
&
compositionTime
-
compositedImageTime
>
-
threshold
)
{
mBias
=
ImageComposite
:
:
BIAS_NEGATIVE
;
return
;
}
if
(
!
nextImageTime
.
IsNull
(
)
&
&
nextImageTime
-
compositionTime
<
threshold
&
&
nextImageTime
-
compositionTime
>
-
threshold
)
{
mBias
=
ImageComposite
:
:
BIAS_POSITIVE
;
return
;
}
mBias
=
ImageComposite
:
:
BIAS_NONE
;
}
int
ImageComposite
:
:
ChooseImageIndex
(
)
{
if
(
mImages
.
IsEmpty
(
)
)
{
return
-
1
;
}
TimeStamp
now
=
GetCompositionTime
(
)
;
if
(
now
.
IsNull
(
)
)
{
for
(
uint32_t
i
=
0
;
i
<
mImages
.
Length
(
)
;
+
+
i
)
{
if
(
mImages
[
i
]
.
mFrameID
=
=
mLastFrameID
&
&
mImages
[
i
]
.
mProducerID
=
=
mLastProducerID
)
{
return
i
;
}
}
return
-
1
;
}
uint32_t
result
=
mLastChosenImageIndex
;
while
(
result
+
1
<
mImages
.
Length
(
)
&
&
GetBiasedTime
(
mImages
[
result
+
1
]
.
mTimeStamp
)
<
=
now
)
{
+
+
result
;
}
if
(
result
-
mLastChosenImageIndex
>
1
)
{
for
(
size_t
idx
=
mLastChosenImageIndex
;
idx
<
=
result
;
idx
+
+
)
{
if
(
IsImagesUpdateRateFasterThanCompositedRate
(
mImages
[
result
]
mImages
[
idx
]
)
)
{
continue
;
}
mDroppedFrames
+
+
;
PROFILER_ADD_MARKER
(
"
Video
frames
dropped
"
GRAPHICS
)
;
}
}
mLastChosenImageIndex
=
result
;
return
result
;
}
const
ImageComposite
:
:
TimedImage
*
ImageComposite
:
:
ChooseImage
(
)
{
int
index
=
ChooseImageIndex
(
)
;
return
index
>
=
0
?
&
mImages
[
index
]
:
nullptr
;
}
void
ImageComposite
:
:
RemoveImagesWithTextureHost
(
TextureHost
*
aTexture
)
{
for
(
int32_t
i
=
mImages
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
mImages
[
i
]
.
mTextureHost
=
=
aTexture
)
{
aTexture
-
>
UnbindTextureSource
(
)
;
mImages
.
RemoveElementAt
(
i
)
;
}
}
}
void
ImageComposite
:
:
ClearImages
(
)
{
mImages
.
Clear
(
)
;
mLastChosenImageIndex
=
0
;
}
uint32_t
ImageComposite
:
:
ScanForLastFrameIndex
(
const
nsTArray
<
TimedImage
>
&
aNewImages
)
{
if
(
mImages
.
IsEmpty
(
)
)
{
return
0
;
}
uint32_t
i
=
mLastChosenImageIndex
;
uint32_t
newIndex
=
0
;
uint32_t
dropped
=
0
;
uint32_t
j
=
0
;
while
(
i
<
mImages
.
Length
(
)
&
&
j
<
aNewImages
.
Length
(
)
)
{
if
(
mImages
[
i
]
.
mProducerID
!
=
aNewImages
[
j
]
.
mProducerID
)
{
newIndex
=
j
;
break
;
}
int32_t
oldFrameID
=
mImages
[
i
]
.
mFrameID
;
int32_t
newFrameID
=
aNewImages
[
j
]
.
mFrameID
;
if
(
oldFrameID
>
newFrameID
)
{
newIndex
=
+
+
j
;
continue
;
}
if
(
oldFrameID
<
mLastFrameID
)
{
i
+
+
;
continue
;
}
if
(
oldFrameID
<
newFrameID
)
{
for
(
+
+
i
;
i
<
mImages
.
Length
(
)
&
&
mImages
[
i
]
.
mFrameID
<
newFrameID
&
&
mImages
[
i
]
.
mProducerID
=
=
aNewImages
[
j
]
.
mProducerID
;
i
+
+
)
{
if
(
IsImagesUpdateRateFasterThanCompositedRate
(
aNewImages
[
j
]
mImages
[
i
]
)
)
{
continue
;
}
dropped
+
+
;
}
break
;
}
i
+
+
;
j
+
+
;
}
if
(
dropped
>
0
)
{
mDroppedFrames
+
=
dropped
;
PROFILER_ADD_MARKER
(
"
Video
frames
dropped
"
GRAPHICS
)
;
}
if
(
newIndex
>
=
aNewImages
.
Length
(
)
)
{
newIndex
=
aNewImages
.
Length
(
)
-
1
;
}
return
newIndex
;
}
void
ImageComposite
:
:
SetImages
(
nsTArray
<
TimedImage
>
&
&
aNewImages
)
{
if
(
!
aNewImages
.
IsEmpty
(
)
)
{
DetectTimeStampJitter
(
&
aNewImages
[
0
]
)
;
}
mLastChosenImageIndex
=
ScanForLastFrameIndex
(
aNewImages
)
;
mImages
=
std
:
:
move
(
aNewImages
)
;
}
void
ImageComposite
:
:
UpdateCompositedFrame
(
int
aImageIndex
const
TimedImage
*
aImage
base
:
:
ProcessId
aProcessId
const
CompositableHandle
&
aHandle
)
{
TimeStamp
compositionTime
=
GetCompositionTime
(
)
;
MOZ_RELEASE_ASSERT
(
compositionTime
"
Should
only
be
called
during
a
composition
"
)
;
#
if
MOZ_GECKO_PROFILER
nsCString
descr
;
if
(
profiler_can_accept_markers
(
)
)
{
nsCString
relativeTimeString
;
if
(
aImage
-
>
mTimeStamp
)
{
relativeTimeString
.
AppendPrintf
(
"
[
relative
timestamp
%
.
1lfms
]
"
(
aImage
-
>
mTimeStamp
-
compositionTime
)
.
ToMilliseconds
(
)
)
;
}
static
const
char
*
kBiasStrings
[
]
=
{
"
NONE
"
"
NEGATIVE
"
"
POSITIVE
"
}
;
descr
.
AppendPrintf
(
"
frameID
%
"
PRId32
"
(
producerID
%
"
PRId32
"
)
[
bias
%
s
]
%
s
"
aImage
-
>
mFrameID
aImage
-
>
mProducerID
kBiasStrings
[
mBias
]
relativeTimeString
.
get
(
)
)
;
if
(
mLastProducerID
!
=
aImage
-
>
mProducerID
)
{
descr
.
AppendPrintf
(
"
previous
producerID
:
%
"
PRId32
mLastProducerID
)
;
}
else
if
(
mLastFrameID
!
=
aImage
-
>
mFrameID
)
{
descr
.
AppendPrintf
(
"
previous
frameID
:
%
"
PRId32
mLastFrameID
)
;
}
else
{
descr
.
AppendLiteral
(
"
no
change
"
)
;
}
}
AUTO_PROFILER_TEXT_MARKER_CAUSE
(
"
UpdateCompositedFrame
"
descr
GRAPHICS
Nothing
(
)
nullptr
)
;
#
endif
if
(
mLastFrameID
=
=
aImage
-
>
mFrameID
&
&
mLastProducerID
=
=
aImage
-
>
mProducerID
)
{
return
;
}
mLastFrameID
=
aImage
-
>
mFrameID
;
mLastProducerID
=
aImage
-
>
mProducerID
;
if
(
aHandle
)
{
ImageCompositeNotificationInfo
info
;
info
.
mImageBridgeProcessId
=
aProcessId
;
info
.
mNotification
=
ImageCompositeNotification
(
aHandle
aImage
-
>
mTimeStamp
GetCompositionTime
(
)
mLastFrameID
mLastProducerID
)
;
AppendImageCompositeNotification
(
info
)
;
}
UpdateBias
(
aImageIndex
)
;
}
const
ImageComposite
:
:
TimedImage
*
ImageComposite
:
:
GetImage
(
size_t
aIndex
)
const
{
if
(
aIndex
>
=
mImages
.
Length
(
)
)
{
return
nullptr
;
}
return
&
mImages
[
aIndex
]
;
}
bool
ImageComposite
:
:
IsImagesUpdateRateFasterThanCompositedRate
(
const
TimedImage
&
aNewImage
const
TimedImage
&
aOldImage
)
const
{
MOZ_ASSERT
(
aNewImage
.
mFrameID
>
=
aOldImage
.
mFrameID
)
;
const
uint32_t
compositedRate
=
gfxPlatform
:
:
TargetFrameRate
(
)
;
if
(
compositedRate
=
=
0
)
{
return
true
;
}
const
double
compositedInterval
=
1
.
0
/
compositedRate
;
return
aNewImage
.
mTimeStamp
-
aOldImage
.
mTimeStamp
<
TimeDuration
:
:
FromSeconds
(
compositedInterval
)
;
}
void
ImageComposite
:
:
DetectTimeStampJitter
(
const
TimedImage
*
aNewImage
)
{
#
if
MOZ_GECKO_PROFILER
if
(
!
profiler_can_accept_markers
(
)
)
{
return
;
}
Maybe
<
TimeDuration
>
jitter
;
for
(
const
auto
&
img
:
mImages
)
{
if
(
img
.
mProducerID
=
=
aNewImage
-
>
mProducerID
&
&
img
.
mFrameID
=
=
aNewImage
-
>
mFrameID
)
{
jitter
=
Some
(
aNewImage
-
>
mTimeStamp
-
img
.
mTimeStamp
)
;
break
;
}
}
if
(
jitter
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
nsPrintfCString
text
(
"
%
.
2lfms
"
jitter
-
>
ToMilliseconds
(
)
)
;
profiler_add_text_marker
(
"
VideoFrameTimeStampJitter
"
text
JS
:
:
ProfilingCategoryPair
:
:
GRAPHICS
now
now
)
;
}
#
endif
}
}
}
