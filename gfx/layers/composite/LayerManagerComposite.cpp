#
include
"
LayerManagerComposite
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
CanvasLayerComposite
.
h
"
#
include
"
ColorLayerComposite
.
h
"
#
include
"
CompositableHost
.
h
"
#
include
"
ContainerLayerComposite
.
h
"
#
include
"
Diagnostics
.
h
"
#
include
"
FPSCounter
.
h
"
#
include
"
FrameMetrics
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
ImageLayerComposite
.
h
"
#
include
"
Layers
.
h
"
#
include
"
LayerScope
.
h
"
#
include
"
protobuf
/
LayerScopePacket
.
pb
.
h
"
#
include
"
PaintedLayerComposite
.
h
"
#
include
"
TiledContentHost
.
h
"
#
include
"
Units
.
h
"
#
include
"
UnitTransforms
.
h
"
#
include
"
apz
/
src
/
AsyncPanZoomController
.
h
"
#
include
"
gfxEnv
.
h
"
#
ifdef
XP_MACOSX
#
include
"
gfxPlatformMac
.
h
"
#
endif
#
include
"
gfxRect
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
StaticPrefs_layers
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
Effects
.
h
"
#
include
"
mozilla
/
layers
/
LayerMetricsWrapper
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
widget
/
CompositorWidget
.
h
"
#
include
"
ipc
/
CompositorBench
.
h
"
#
include
"
ipc
/
ShadowLayerUtils
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAppRunner
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRegion
.
h
"
#
if
defined
(
MOZ_WIDGET_ANDROID
)
#
include
<
android
/
log
.
h
>
#
include
<
android
/
native_window
.
h
>
#
include
"
mozilla
/
jni
/
Utils
.
h
"
#
include
"
mozilla
/
widget
/
AndroidCompositorWidget
.
h
"
#
include
"
opengl
/
CompositorOGL
.
h
"
#
include
"
GLConsts
.
h
"
#
include
"
GLContextEGL
.
h
"
#
include
"
GLContextProvider
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
ScopedGLHelpers
.
h
"
#
endif
#
include
"
GeckoProfiler
.
h
"
#
include
"
TextRenderer
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
"
TreeTraversal
.
h
"
#
include
"
CompositionRecorder
.
h
"
#
ifdef
USE_SKIA
#
include
"
PaintCounter
.
h
"
#
endif
class
gfxContext
;
namespace
mozilla
{
namespace
layers
{
class
ImageLayer
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
gl
;
static
LayerComposite
*
ToLayerComposite
(
Layer
*
aLayer
)
{
return
static_cast
<
LayerComposite
*
>
(
aLayer
-
>
ImplData
(
)
)
;
}
static
void
ClearSubtree
(
Layer
*
aLayer
)
{
ForEachNode
<
ForwardIterator
>
(
aLayer
[
]
(
Layer
*
layer
)
{
ToLayerComposite
(
layer
)
-
>
CleanupResources
(
)
;
}
)
;
}
void
LayerManagerComposite
:
:
ClearCachedResources
(
Layer
*
aSubtree
)
{
MOZ_ASSERT
(
!
aSubtree
|
|
aSubtree
-
>
Manager
(
)
=
=
this
)
;
Layer
*
subtree
=
aSubtree
?
aSubtree
:
mRoot
.
get
(
)
;
if
(
!
subtree
)
{
return
;
}
ClearSubtree
(
subtree
)
;
}
HostLayerManager
:
:
HostLayerManager
(
)
:
mDebugOverlayWantsNextFrame
(
false
)
mWarningLevel
(
0
.
0f
)
mCompositorBridgeID
(
0
)
mWindowOverlayChanged
(
false
)
mLastPaintTime
(
TimeDuration
:
:
Forever
(
)
)
mRenderStartTime
(
TimeStamp
:
:
Now
(
)
)
{
}
HostLayerManager
:
:
~
HostLayerManager
(
)
{
}
void
HostLayerManager
:
:
RecordPaintTimes
(
const
PaintTiming
&
aTiming
)
{
mDiagnostics
-
>
RecordPaintTimes
(
aTiming
)
;
}
void
HostLayerManager
:
:
RecordUpdateTime
(
float
aValue
)
{
mDiagnostics
-
>
RecordUpdateTime
(
aValue
)
;
}
void
HostLayerManager
:
:
WriteCollectedFrames
(
)
{
if
(
mCompositionRecorder
)
{
mCompositionRecorder
-
>
WriteCollectedFrames
(
)
;
mCompositionRecorder
=
nullptr
;
}
}
LayerManagerComposite
:
:
LayerManagerComposite
(
Compositor
*
aCompositor
)
:
mUnusedApzTransformWarning
(
false
)
mDisabledApzWarning
(
false
)
mCompositor
(
aCompositor
)
mInTransaction
(
false
)
mIsCompositorReady
(
false
)
#
if
defined
(
MOZ_WIDGET_ANDROID
)
mScreenPixelsTarget
(
nullptr
)
#
endif
{
mTextRenderer
=
new
TextRenderer
(
)
;
mDiagnostics
=
MakeUnique
<
Diagnostics
>
(
)
;
MOZ_ASSERT
(
aCompositor
)
;
mNativeLayerRoot
=
aCompositor
-
>
GetWidget
(
)
-
>
GetNativeLayerRoot
(
)
;
if
(
mNativeLayerRoot
)
{
mNativeLayerForEntireWindow
=
mNativeLayerRoot
-
>
CreateLayer
(
)
;
mNativeLayerRoot
-
>
AppendLayer
(
mNativeLayerForEntireWindow
)
;
}
#
ifdef
USE_SKIA
mPaintCounter
=
nullptr
;
#
endif
}
LayerManagerComposite
:
:
~
LayerManagerComposite
(
)
{
Destroy
(
)
;
}
void
LayerManagerComposite
:
:
Destroy
(
)
{
if
(
!
mDestroyed
)
{
mCompositor
-
>
GetWidget
(
)
-
>
CleanupWindowEffects
(
)
;
if
(
mRoot
)
{
RootLayer
(
)
-
>
Destroy
(
)
;
}
mCompositor
-
>
CancelFrame
(
)
;
mRoot
=
nullptr
;
mClonedLayerTreeProperties
=
nullptr
;
mProfilerScreenshotGrabber
.
Destroy
(
)
;
if
(
mNativeLayerRoot
)
{
mNativeLayerRoot
-
>
RemoveLayer
(
mNativeLayerForEntireWindow
)
;
mNativeLayerForEntireWindow
=
nullptr
;
mNativeLayerRoot
=
nullptr
;
}
mDestroyed
=
true
;
#
ifdef
USE_SKIA
mPaintCounter
=
nullptr
;
#
endif
}
}
void
LayerManagerComposite
:
:
UpdateRenderBounds
(
const
IntRect
&
aRect
)
{
mRenderBounds
=
aRect
;
}
bool
LayerManagerComposite
:
:
AreComponentAlphaLayersEnabled
(
)
{
return
mCompositor
-
>
GetBackendType
(
)
!
=
LayersBackend
:
:
LAYERS_BASIC
&
&
mCompositor
-
>
SupportsEffect
(
EffectTypes
:
:
COMPONENT_ALPHA
)
&
&
LayerManager
:
:
AreComponentAlphaLayersEnabled
(
)
;
}
bool
LayerManagerComposite
:
:
BeginTransaction
(
const
nsCString
&
aURL
)
{
mInTransaction
=
true
;
if
(
!
mCompositor
-
>
Ready
(
)
)
{
return
false
;
}
mIsCompositorReady
=
true
;
return
true
;
}
void
LayerManagerComposite
:
:
BeginTransactionWithDrawTarget
(
DrawTarget
*
aTarget
const
IntRect
&
aRect
)
{
mInTransaction
=
true
;
if
(
!
mCompositor
-
>
Ready
(
)
)
{
return
;
}
#
ifdef
MOZ_LAYERS_HAVE_LOG
MOZ_LAYERS_LOG
(
(
"
[
-
-
-
-
-
BeginTransaction
"
)
)
;
Log
(
)
;
#
endif
if
(
mDestroyed
)
{
NS_WARNING
(
"
Call
on
destroyed
layer
manager
"
)
;
return
;
}
mIsCompositorReady
=
true
;
mCompositor
-
>
SetTargetContext
(
aTarget
aRect
)
;
mTarget
=
aTarget
;
mTargetBounds
=
aRect
;
}
template
<
typename
Units
>
static
IntRectTyped
<
Units
>
TransformRect
(
const
IntRectTyped
<
Units
>
&
aRect
const
Matrix
&
aTransform
bool
aRoundIn
=
false
)
{
if
(
aRect
.
IsEmpty
(
)
)
{
return
IntRectTyped
<
Units
>
(
)
;
}
Rect
rect
(
aRect
.
X
(
)
aRect
.
Y
(
)
aRect
.
Width
(
)
aRect
.
Height
(
)
)
;
rect
=
aTransform
.
TransformBounds
(
rect
)
;
if
(
aRoundIn
)
{
MOZ_ASSERT
(
aTransform
.
PreservesAxisAlignedRectangles
(
)
)
;
rect
.
RoundIn
(
)
;
}
else
{
rect
.
RoundOut
(
)
;
}
IntRect
intRect
;
if
(
!
rect
.
ToIntRect
(
&
intRect
)
)
{
intRect
=
IntRect
:
:
MaxIntRect
(
)
;
}
return
ViewAs
<
Units
>
(
intRect
)
;
}
template
<
typename
Units
>
static
IntRectTyped
<
Units
>
TransformRect
(
const
IntRectTyped
<
Units
>
&
aRect
const
Matrix4x4
&
aTransform
bool
aRoundIn
=
false
)
{
if
(
aRect
.
IsEmpty
(
)
)
{
return
IntRectTyped
<
Units
>
(
)
;
}
Rect
rect
(
aRect
.
X
(
)
aRect
.
Y
(
)
aRect
.
Width
(
)
aRect
.
Height
(
)
)
;
rect
=
aTransform
.
TransformAndClipBounds
(
rect
Rect
:
:
MaxIntRect
(
)
)
;
if
(
aRoundIn
)
{
rect
.
RoundIn
(
)
;
}
else
{
rect
.
RoundOut
(
)
;
}
IntRect
intRect
;
if
(
!
rect
.
ToIntRect
(
&
intRect
)
)
{
intRect
=
IntRect
:
:
MaxIntRect
(
)
;
}
return
ViewAs
<
Units
>
(
intRect
)
;
}
template
<
typename
Units
typename
MatrixType
>
static
IntRectTyped
<
Units
>
TransformRectRoundIn
(
const
IntRectTyped
<
Units
>
&
aRect
const
MatrixType
&
aTransform
)
{
return
TransformRect
(
aRect
aTransform
true
)
;
}
template
<
typename
Units
typename
MatrixType
>
static
void
AddTransformedRegion
(
IntRegionTyped
<
Units
>
&
aDest
const
IntRegionTyped
<
Units
>
&
aSource
const
MatrixType
&
aTransform
)
{
for
(
auto
iter
=
aSource
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
aDest
.
Or
(
aDest
TransformRect
(
iter
.
Get
(
)
aTransform
)
)
;
}
aDest
.
SimplifyOutward
(
20
)
;
}
template
<
typename
Units
typename
MatrixType
>
static
void
AddTransformedRegionRoundIn
(
IntRegionTyped
<
Units
>
&
aDest
const
IntRegionTyped
<
Units
>
&
aSource
const
MatrixType
&
aTransform
)
{
for
(
auto
iter
=
aSource
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
aDest
.
Or
(
aDest
TransformRectRoundIn
(
iter
.
Get
(
)
aTransform
)
)
;
}
}
void
LayerManagerComposite
:
:
PostProcessLayers
(
nsIntRegion
&
aOpaqueRegion
)
{
LayerIntRegion
visible
;
LayerComposite
*
rootComposite
=
static_cast
<
LayerComposite
*
>
(
mRoot
-
>
AsHostLayer
(
)
)
;
PostProcessLayers
(
mRoot
aOpaqueRegion
visible
ViewAs
<
RenderTargetPixel
>
(
rootComposite
-
>
GetShadowClipRect
(
)
PixelCastJustification
:
:
RenderTargetIsParentLayerForRoot
)
Nothing
(
)
true
)
;
}
static
bool
ShouldProcessLayer
(
Layer
*
aLayer
)
{
if
(
!
aLayer
-
>
AsContainerLayer
(
)
)
{
return
true
;
}
return
aLayer
-
>
AsContainerLayer
(
)
-
>
UseIntermediateSurface
(
)
;
}
void
LayerManagerComposite
:
:
PostProcessLayers
(
Layer
*
aLayer
nsIntRegion
&
aOpaqueRegion
LayerIntRegion
&
aVisibleRegion
const
Maybe
<
RenderTargetIntRect
>
&
aRenderTargetClip
const
Maybe
<
ParentLayerIntRect
>
&
aClipFromAncestors
bool
aCanContributeOpaque
)
{
LayerComposite
*
composite
=
static_cast
<
LayerComposite
*
>
(
aLayer
-
>
AsHostLayer
(
)
)
;
Maybe
<
ParentLayerIntRect
>
layerClip
=
composite
-
>
GetShadowClipRect
(
)
;
MOZ_ASSERT
(
!
layerClip
|
|
!
aLayer
-
>
Combines3DTransformWithAncestors
(
)
"
The
layer
with
a
clip
should
not
participate
"
"
a
3D
rendering
context
"
)
;
Maybe
<
ParentLayerIntRect
>
outsideClip
=
IntersectMaybeRects
(
layerClip
aClipFromAncestors
)
;
Maybe
<
LayerIntRect
>
insideClip
;
if
(
aLayer
-
>
Extend3DContext
(
)
)
{
if
(
outsideClip
)
{
insideClip
=
Some
(
ViewAs
<
LayerPixel
>
(
*
outsideClip
PixelCastJustification
:
:
MovingDownToChildren
)
)
;
}
}
else
if
(
outsideClip
)
{
Matrix4x4
localTransform
=
aLayer
-
>
ComputeTransformToPreserve3DRoot
(
)
;
if
(
!
localTransform
.
HasPerspectiveComponent
(
)
&
&
localTransform
.
Invert
(
)
)
{
LayerRect
insideClipFloat
=
UntransformBy
(
ViewAs
<
ParentLayerToLayerMatrix4x4
>
(
localTransform
)
ParentLayerRect
(
*
outsideClip
)
LayerRect
:
:
MaxIntRect
(
)
)
.
valueOr
(
LayerRect
(
)
)
;
insideClipFloat
.
RoundOut
(
)
;
LayerIntRect
insideClipInt
;
if
(
insideClipFloat
.
ToIntRect
(
&
insideClipInt
)
)
{
insideClip
=
Some
(
insideClipInt
)
;
}
}
}
Maybe
<
ParentLayerIntRect
>
ancestorClipForChildren
;
if
(
insideClip
)
{
ancestorClipForChildren
=
Some
(
ViewAs
<
ParentLayerPixel
>
(
*
insideClip
PixelCastJustification
:
:
MovingDownToChildren
)
)
;
}
nsIntRegion
dummy
;
nsIntRegion
&
opaqueRegion
=
aOpaqueRegion
;
if
(
aLayer
-
>
Extend3DContext
(
)
|
|
aLayer
-
>
Combines3DTransformWithAncestors
(
)
)
{
opaqueRegion
=
dummy
;
}
if
(
!
ShouldProcessLayer
(
aLayer
)
)
{
MOZ_ASSERT
(
aLayer
-
>
AsContainerLayer
(
)
&
&
!
aLayer
-
>
AsContainerLayer
(
)
-
>
UseIntermediateSurface
(
)
)
;
for
(
Layer
*
child
=
aLayer
-
>
GetLastChild
(
)
;
child
;
child
=
child
-
>
GetPrevSibling
(
)
)
{
LayerComposite
*
childComposite
=
static_cast
<
LayerComposite
*
>
(
child
-
>
AsHostLayer
(
)
)
;
Maybe
<
RenderTargetIntRect
>
renderTargetClip
=
aRenderTargetClip
;
if
(
childComposite
-
>
GetShadowClipRect
(
)
)
{
RenderTargetIntRect
clip
=
TransformBy
(
ViewAs
<
ParentLayerToRenderTargetMatrix4x4
>
(
aLayer
-
>
GetEffectiveTransform
(
)
PixelCastJustification
:
:
RenderTargetIsParentLayerForRoot
)
*
childComposite
-
>
GetShadowClipRect
(
)
)
;
renderTargetClip
=
IntersectMaybeRects
(
renderTargetClip
Some
(
clip
)
)
;
}
PostProcessLayers
(
child
opaqueRegion
aVisibleRegion
renderTargetClip
ancestorClipForChildren
aCanContributeOpaque
&
!
(
aLayer
-
>
GetContentFlags
(
)
&
Layer
:
:
CONTENT_BACKFACE_HIDDEN
)
)
;
}
return
;
}
nsIntRegion
localOpaque
;
Matrix4x4
transform
=
aLayer
-
>
GetEffectiveTransform
(
)
;
Matrix
transform2d
;
bool
canTransformOpaqueRegion
=
false
;
if
(
aCanContributeOpaque
&
&
!
(
aLayer
-
>
GetContentFlags
(
)
&
Layer
:
:
CONTENT_BACKFACE_HIDDEN
)
&
&
transform
.
Is2D
(
&
transform2d
)
&
&
transform2d
.
PreservesAxisAlignedRectangles
(
)
)
{
Matrix
inverse
=
transform2d
;
inverse
.
Invert
(
)
;
AddTransformedRegionRoundIn
(
localOpaque
opaqueRegion
inverse
)
;
canTransformOpaqueRegion
=
true
;
}
nsIntRegion
obscured
=
localOpaque
;
LayerIntRegion
descendantsVisibleRegion
;
bool
hasPreserve3DChild
=
false
;
for
(
Layer
*
child
=
aLayer
-
>
GetLastChild
(
)
;
child
;
child
=
child
-
>
GetPrevSibling
(
)
)
{
MOZ_ASSERT
(
aLayer
-
>
AsContainerLayer
(
)
-
>
UseIntermediateSurface
(
)
)
;
LayerComposite
*
childComposite
=
static_cast
<
LayerComposite
*
>
(
child
-
>
AsHostLayer
(
)
)
;
PostProcessLayers
(
child
localOpaque
descendantsVisibleRegion
ViewAs
<
RenderTargetPixel
>
(
childComposite
-
>
GetShadowClipRect
(
)
PixelCastJustification
:
:
RenderTargetIsParentLayerForRoot
)
ancestorClipForChildren
true
)
;
if
(
child
-
>
Extend3DContext
(
)
)
{
hasPreserve3DChild
=
true
;
}
}
LayerIntRegion
visible
=
composite
-
>
GetShadowVisibleRegion
(
)
;
if
(
aLayer
-
>
GetFirstChild
(
)
&
&
!
hasPreserve3DChild
)
{
visible
=
descendantsVisibleRegion
;
}
if
(
!
obscured
.
IsEmpty
(
)
)
{
visible
.
SubOut
(
LayerIntRegion
:
:
FromUnknownRegion
(
obscured
)
)
;
}
if
(
insideClip
)
{
visible
.
AndWith
(
*
insideClip
)
;
}
composite
-
>
SetShadowVisibleRegion
(
visible
)
;
ParentLayerIntRegion
visibleParentSpace
=
TransformBy
(
ViewAs
<
LayerToParentLayerMatrix4x4
>
(
transform
)
visible
)
;
aVisibleRegion
.
OrWith
(
ViewAs
<
LayerPixel
>
(
visibleParentSpace
PixelCastJustification
:
:
MovingDownToChildren
)
)
;
if
(
canTransformOpaqueRegion
&
&
!
aLayer
-
>
HasMaskLayers
(
)
&
&
aLayer
-
>
IsOpaqueForVisibility
(
)
)
{
if
(
aLayer
-
>
IsOpaque
(
)
)
{
localOpaque
.
OrWith
(
composite
-
>
GetFullyRenderedRegion
(
)
)
;
}
nsIntRegion
parentSpaceOpaque
;
AddTransformedRegionRoundIn
(
parentSpaceOpaque
localOpaque
transform2d
)
;
if
(
aRenderTargetClip
)
{
parentSpaceOpaque
.
AndWith
(
aRenderTargetClip
-
>
ToUnknownRect
(
)
)
;
}
opaqueRegion
.
OrWith
(
parentSpaceOpaque
)
;
}
}
void
LayerManagerComposite
:
:
EndTransaction
(
const
TimeStamp
&
aTimeStamp
EndTransactionFlags
aFlags
)
{
NS_ASSERTION
(
mInTransaction
"
Didn
'
t
call
BeginTransaction
?
"
)
;
NS_ASSERTION
(
!
(
aFlags
&
END_NO_COMPOSITE
)
"
Shouldn
'
t
get
END_NO_COMPOSITE
here
"
)
;
mInTransaction
=
false
;
mRenderStartTime
=
TimeStamp
:
:
Now
(
)
;
if
(
!
mIsCompositorReady
)
{
return
;
}
mIsCompositorReady
=
false
;
#
ifdef
MOZ_LAYERS_HAVE_LOG
MOZ_LAYERS_LOG
(
(
"
-
-
-
-
-
(
beginning
paint
)
"
)
)
;
Log
(
)
;
#
endif
if
(
mDestroyed
)
{
NS_WARNING
(
"
Call
on
destroyed
layer
manager
"
)
;
return
;
}
SetCompositionTime
(
aTimeStamp
)
;
if
(
mRoot
&
&
!
(
aFlags
&
END_NO_IMMEDIATE_REDRAW
)
)
{
MOZ_ASSERT
(
!
aTimeStamp
.
IsNull
(
)
)
;
UpdateAndRender
(
)
;
mCompositor
-
>
FlushPendingNotifyNotUsed
(
)
;
}
mCompositor
-
>
ClearTargetContext
(
)
;
mTarget
=
nullptr
;
#
ifdef
MOZ_LAYERS_HAVE_LOG
Log
(
)
;
MOZ_LAYERS_LOG
(
(
"
]
-
-
-
-
-
EndTransaction
"
)
)
;
#
endif
}
void
LayerManagerComposite
:
:
UpdateAndRender
(
)
{
if
(
gfxEnv
:
:
SkipComposition
(
)
)
{
mInvalidRegion
.
SetEmpty
(
)
;
return
;
}
mRoot
-
>
ComputeEffectiveTransforms
(
gfx
:
:
Matrix4x4
(
)
)
;
nsIntRegion
opaque
;
PostProcessLayers
(
opaque
)
;
if
(
mClonedLayerTreeProperties
)
{
nsIntRegion
changed
;
const
bool
overflowed
=
!
mClonedLayerTreeProperties
-
>
ComputeDifferences
(
mRoot
changed
nullptr
)
;
if
(
overflowed
)
{
changed
=
mRenderBounds
;
}
mInvalidRegion
.
Or
(
mInvalidRegion
changed
)
;
}
nsIntRegion
invalid
;
if
(
mTarget
)
{
invalid
=
mTargetBounds
;
}
else
{
if
(
!
mClonedLayerTreeProperties
)
{
mInvalidRegion
=
mRenderBounds
;
}
invalid
=
mInvalidRegion
;
}
if
(
invalid
.
IsEmpty
(
)
&
&
!
mWindowOverlayChanged
)
{
mClonedLayerTreeProperties
=
LayerProperties
:
:
CloneFrom
(
GetRoot
(
)
)
;
mProfilerScreenshotGrabber
.
NotifyEmptyFrame
(
)
;
mPayload
.
Clear
(
)
;
return
;
}
InvalidateDebugOverlay
(
invalid
mRenderBounds
)
;
bool
rendered
=
Render
(
invalid
opaque
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
RenderToPresentationSurface
(
)
;
#
endif
if
(
!
mTarget
&
&
rendered
)
{
mInvalidRegion
.
SetEmpty
(
)
;
mWindowOverlayChanged
=
false
;
}
mClonedLayerTreeProperties
=
LayerProperties
:
:
CloneFrom
(
GetRoot
(
)
)
;
}
already_AddRefed
<
DrawTarget
>
LayerManagerComposite
:
:
CreateOptimalMaskDrawTarget
(
const
IntSize
&
aSize
)
{
MOZ_CRASH
(
"
Should
only
be
called
on
the
drawing
side
"
)
;
return
nullptr
;
}
LayerComposite
*
LayerManagerComposite
:
:
RootLayer
(
)
const
{
if
(
mDestroyed
)
{
NS_WARNING
(
"
Call
on
destroyed
layer
manager
"
)
;
return
nullptr
;
}
return
ToLayerComposite
(
mRoot
)
;
}
void
LayerManagerComposite
:
:
InvalidateDebugOverlay
(
nsIntRegion
&
aInvalidRegion
const
IntRect
&
aBounds
)
{
bool
drawFps
=
StaticPrefs
:
:
layers_acceleration_draw_fps
(
)
;
bool
drawFrameColorBars
=
StaticPrefs
:
:
gfx_draw_color_bars
(
)
;
if
(
drawFps
)
{
aInvalidRegion
.
Or
(
aInvalidRegion
nsIntRect
(
0
0
650
400
)
)
;
}
if
(
drawFrameColorBars
)
{
aInvalidRegion
.
Or
(
aInvalidRegion
nsIntRect
(
0
0
10
aBounds
.
Height
(
)
)
)
;
}
#
ifdef
USE_SKIA
bool
drawPaintTimes
=
StaticPrefs
:
:
gfx_content_always_paint
(
)
;
if
(
drawPaintTimes
)
{
aInvalidRegion
.
Or
(
aInvalidRegion
nsIntRect
(
PaintCounter
:
:
GetPaintRect
(
)
)
)
;
}
#
endif
}
#
ifdef
USE_SKIA
void
LayerManagerComposite
:
:
DrawPaintTimes
(
Compositor
*
aCompositor
)
{
if
(
!
mPaintCounter
)
{
mPaintCounter
=
new
PaintCounter
(
)
;
}
TimeDuration
compositeTime
=
TimeStamp
:
:
Now
(
)
-
mRenderStartTime
;
mPaintCounter
-
>
Draw
(
aCompositor
mLastPaintTime
compositeTime
)
;
}
#
endif
static
uint16_t
sFrameCount
=
0
;
void
LayerManagerComposite
:
:
RenderDebugOverlay
(
const
IntRect
&
aBounds
)
{
bool
drawFps
=
StaticPrefs
:
:
layers_acceleration_draw_fps
(
)
;
bool
drawFrameColorBars
=
StaticPrefs
:
:
gfx_draw_color_bars
(
)
;
if
(
mTarget
)
{
return
;
}
if
(
drawFps
)
{
float
alpha
=
1
;
#
ifdef
ANDROID
int
width
;
int
border
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
!
mWarnTime
.
IsNull
(
)
&
&
(
now
-
mWarnTime
)
.
ToMilliseconds
(
)
<
kVisualWarningDuration
)
{
EffectChain
effects
;
border
=
4
;
width
=
6
;
effects
.
mPrimaryEffect
=
new
EffectSolidColor
(
gfx
:
:
Color
(
0
0
0
1
)
)
;
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
border
border
aBounds
.
Width
(
)
-
2
*
border
width
)
aBounds
effects
alpha
gfx
:
:
Matrix4x4
(
)
)
;
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
border
aBounds
.
Height
(
)
-
border
-
width
aBounds
.
Width
(
)
-
2
*
border
width
)
aBounds
effects
alpha
gfx
:
:
Matrix4x4
(
)
)
;
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
border
border
+
width
width
aBounds
.
Height
(
)
-
2
*
border
-
width
*
2
)
aBounds
effects
alpha
gfx
:
:
Matrix4x4
(
)
)
;
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
aBounds
.
Width
(
)
-
border
-
width
border
+
width
width
aBounds
.
Height
(
)
-
2
*
border
-
2
*
width
)
aBounds
effects
alpha
gfx
:
:
Matrix4x4
(
)
)
;
border
=
5
;
width
=
4
;
effects
.
mPrimaryEffect
=
new
EffectSolidColor
(
gfx
:
:
Color
(
1
1
.
f
-
mWarningLevel
0
1
)
)
;
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
border
border
aBounds
.
Width
(
)
-
2
*
border
width
)
aBounds
effects
alpha
gfx
:
:
Matrix4x4
(
)
)
;
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
border
aBounds
.
height
-
border
-
width
aBounds
.
Width
(
)
-
2
*
border
width
)
aBounds
effects
alpha
gfx
:
:
Matrix4x4
(
)
)
;
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
border
border
+
width
width
aBounds
.
Height
(
)
-
2
*
border
-
width
*
2
)
aBounds
effects
alpha
gfx
:
:
Matrix4x4
(
)
)
;
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
aBounds
.
Width
(
)
-
border
-
width
border
+
width
width
aBounds
.
Height
(
)
-
2
*
border
-
2
*
width
)
aBounds
effects
alpha
gfx
:
:
Matrix4x4
(
)
)
;
SetDebugOverlayWantsNextFrame
(
true
)
;
}
#
endif
GPUStats
stats
;
stats
.
mScreenPixels
=
mRenderBounds
.
Width
(
)
*
mRenderBounds
.
Height
(
)
;
mCompositor
-
>
GetFrameStats
(
&
stats
)
;
std
:
:
string
text
=
mDiagnostics
-
>
GetFrameOverlayString
(
stats
)
;
mTextRenderer
-
>
RenderText
(
mCompositor
text
IntPoint
(
2
5
)
Matrix4x4
(
)
24
600
TextRenderer
:
:
FontType
:
:
FixedWidth
)
;
if
(
mUnusedApzTransformWarning
)
{
EffectChain
effects
;
effects
.
mPrimaryEffect
=
new
EffectSolidColor
(
gfx
:
:
Color
(
1
0
0
1
)
)
;
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
aBounds
.
Width
(
)
-
20
0
20
20
)
aBounds
effects
alpha
gfx
:
:
Matrix4x4
(
)
)
;
mUnusedApzTransformWarning
=
false
;
SetDebugOverlayWantsNextFrame
(
true
)
;
}
if
(
mDisabledApzWarning
)
{
EffectChain
effects
;
effects
.
mPrimaryEffect
=
new
EffectSolidColor
(
gfx
:
:
Color
(
1
1
0
1
)
)
;
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
aBounds
.
Width
(
)
-
40
0
20
20
)
aBounds
effects
alpha
gfx
:
:
Matrix4x4
(
)
)
;
mDisabledApzWarning
=
false
;
SetDebugOverlayWantsNextFrame
(
true
)
;
}
}
if
(
drawFrameColorBars
)
{
gfx
:
:
IntRect
sideRect
(
0
0
10
aBounds
.
Height
(
)
)
;
EffectChain
effects
;
effects
.
mPrimaryEffect
=
new
EffectSolidColor
(
gfxUtils
:
:
GetColorForFrameNumber
(
sFrameCount
)
)
;
mCompositor
-
>
DrawQuad
(
Rect
(
sideRect
)
sideRect
effects
1
.
0
gfx
:
:
Matrix4x4
(
)
)
;
}
if
(
drawFrameColorBars
)
{
sFrameCount
+
+
;
}
#
ifdef
USE_SKIA
bool
drawPaintTimes
=
StaticPrefs
:
:
gfx_content_always_paint
(
)
;
if
(
drawPaintTimes
)
{
DrawPaintTimes
(
mCompositor
)
;
}
#
endif
}
RefPtr
<
CompositingRenderTarget
>
LayerManagerComposite
:
:
PushGroupForLayerEffects
(
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
layers_effect_invert
(
)
|
|
StaticPrefs
:
:
layers_effect_grayscale
(
)
|
|
StaticPrefs
:
:
layers_effect_contrast
(
)
!
=
0
.
0
)
;
RefPtr
<
CompositingRenderTarget
>
previousTarget
=
mCompositor
-
>
GetCurrentRenderTarget
(
)
;
IntRect
rect
(
previousTarget
-
>
GetOrigin
(
)
previousTarget
-
>
GetSize
(
)
)
;
MOZ_ASSERT
(
rect
.
IsEqualXY
(
0
0
)
)
;
if
(
!
mTwoPassTmpTarget
|
|
mTwoPassTmpTarget
-
>
GetSize
(
)
!
=
previousTarget
-
>
GetSize
(
)
|
|
mTwoPassTmpTarget
-
>
GetOrigin
(
)
!
=
previousTarget
-
>
GetOrigin
(
)
)
{
mTwoPassTmpTarget
=
mCompositor
-
>
CreateRenderTarget
(
rect
INIT_MODE_NONE
)
;
}
MOZ_ASSERT
(
mTwoPassTmpTarget
)
;
mCompositor
-
>
SetRenderTarget
(
mTwoPassTmpTarget
)
;
return
previousTarget
;
}
void
LayerManagerComposite
:
:
PopGroupForLayerEffects
(
RefPtr
<
CompositingRenderTarget
>
aPreviousTarget
IntRect
aClipRect
bool
aGrayscaleEffect
bool
aInvertEffect
float
aContrastEffect
)
{
MOZ_ASSERT
(
mTwoPassTmpTarget
)
;
MOZ_ASSERT
(
aInvertEffect
|
|
aGrayscaleEffect
|
|
aContrastEffect
!
=
0
.
0
)
;
mCompositor
-
>
SetRenderTarget
(
aPreviousTarget
)
;
EffectChain
effectChain
(
RootLayer
(
)
)
;
Matrix5x4
effectMatrix
;
if
(
aGrayscaleEffect
)
{
Matrix5x4
grayscaleMatrix
(
0
.
2126f
0
.
2126f
0
.
2126f
0
0
.
7152f
0
.
7152f
0
.
7152f
0
0
.
0722f
0
.
0722f
0
.
0722f
0
0
0
0
1
0
0
0
0
)
;
effectMatrix
=
grayscaleMatrix
;
}
if
(
aInvertEffect
)
{
Matrix5x4
colorInvertMatrix
(
-
1
0
0
0
0
-
1
0
0
0
0
-
1
0
0
0
0
1
1
1
1
0
)
;
effectMatrix
=
effectMatrix
*
colorInvertMatrix
;
}
if
(
aContrastEffect
!
=
0
.
0
)
{
float
cP1
=
aContrastEffect
+
1
;
float
hc
=
0
.
5
*
aContrastEffect
;
Matrix5x4
contrastMatrix
(
cP1
0
0
0
0
cP1
0
0
0
0
cP1
0
0
0
0
1
-
hc
-
hc
-
hc
0
)
;
effectMatrix
=
effectMatrix
*
contrastMatrix
;
}
effectChain
.
mPrimaryEffect
=
new
EffectRenderTarget
(
mTwoPassTmpTarget
)
;
effectChain
.
mSecondaryEffects
[
EffectTypes
:
:
COLOR_MATRIX
]
=
new
EffectColorMatrix
(
effectMatrix
)
;
mCompositor
-
>
DrawQuad
(
Rect
(
Point
(
0
0
)
Size
(
mTwoPassTmpTarget
-
>
GetSize
(
)
)
)
aClipRect
effectChain
1
.
Matrix4x4
(
)
)
;
}
static
void
ClearLayerFlags
(
Layer
*
aLayer
)
{
ForEachNode
<
ForwardIterator
>
(
aLayer
[
]
(
Layer
*
layer
)
{
if
(
layer
-
>
AsHostLayer
(
)
)
{
static_cast
<
LayerComposite
*
>
(
layer
-
>
AsHostLayer
(
)
)
-
>
SetLayerComposited
(
false
)
;
}
}
)
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
class
ScopedCompositorRenderOffset
{
public
:
ScopedCompositorRenderOffset
(
CompositorOGL
*
aCompositor
const
ScreenPoint
&
aOffset
)
:
mCompositor
(
aCompositor
)
mOriginalOffset
(
mCompositor
-
>
GetScreenRenderOffset
(
)
)
mOriginalProjection
(
mCompositor
-
>
GetProjMatrix
(
)
)
{
ScreenPoint
offset
(
mOriginalOffset
.
x
+
aOffset
.
x
mOriginalOffset
.
y
+
aOffset
.
y
)
;
mCompositor
-
>
SetScreenRenderOffset
(
offset
)
;
gfx
:
:
Matrix4x4
mat
=
mOriginalProjection
;
mat
.
PreTranslate
(
aOffset
.
x
aOffset
.
y
0
.
0f
)
;
mCompositor
-
>
SetProjMatrix
(
mat
)
;
}
~
ScopedCompositorRenderOffset
(
)
{
mCompositor
-
>
SetScreenRenderOffset
(
mOriginalOffset
)
;
mCompositor
-
>
SetProjMatrix
(
mOriginalProjection
)
;
}
private
:
CompositorOGL
*
const
mCompositor
;
const
ScreenPoint
mOriginalOffset
;
const
gfx
:
:
Matrix4x4
mOriginalProjection
;
}
;
#
endif
bool
LayerManagerComposite
:
:
Render
(
const
nsIntRegion
&
aInvalidRegion
const
nsIntRegion
&
aOpaqueRegion
)
{
AUTO_PROFILER_LABEL
(
"
LayerManagerComposite
:
:
Render
"
GRAPHICS
)
;
if
(
mDestroyed
|
|
!
mCompositor
|
|
mCompositor
-
>
IsDestroyed
(
)
)
{
NS_WARNING
(
"
Call
on
destroyed
layer
manager
"
)
;
return
false
;
}
mCompositor
-
>
RequestAllowFrameRecording
(
!
!
mCompositionRecorder
)
;
ClearLayerFlags
(
mRoot
)
;
bool
invertVal
=
StaticPrefs
:
:
layers_effect_invert
(
)
;
bool
grayscaleVal
=
StaticPrefs
:
:
layers_effect_grayscale
(
)
;
float
contrastVal
=
StaticPrefs
:
:
layers_effect_contrast
(
)
;
bool
haveLayerEffects
=
(
invertVal
|
|
grayscaleVal
|
|
contrastVal
!
=
0
.
0
)
;
LayerScopeAutoFrame
frame
(
PR_Now
(
)
)
;
if
(
LayerScope
:
:
CheckSendable
(
)
)
{
auto
packet
=
MakeUnique
<
layerscope
:
:
Packet
>
(
)
;
layerscope
:
:
LayersPacket
*
layersPacket
=
packet
-
>
mutable_layers
(
)
;
this
-
>
Dump
(
layersPacket
)
;
LayerScope
:
:
SendLayerDump
(
std
:
:
move
(
packet
)
)
;
}
mozilla
:
:
widget
:
:
WidgetRenderingContext
widgetContext
;
#
if
defined
(
XP_MACOSX
)
widgetContext
.
mLayerManager
=
this
;
#
elif
defined
(
MOZ_WIDGET_ANDROID
)
widgetContext
.
mCompositor
=
GetCompositor
(
)
;
#
endif
{
AUTO_PROFILER_LABEL
(
"
LayerManagerComposite
:
:
Render
:
Prerender
"
GRAPHICS
)
;
if
(
!
mCompositor
-
>
GetWidget
(
)
-
>
PreRender
(
&
widgetContext
)
)
{
return
false
;
}
}
ParentLayerIntRect
clipRect
;
IntRect
actualBounds
;
CompositorBench
(
mCompositor
mRenderBounds
)
;
MOZ_ASSERT
(
mRoot
-
>
GetOpacity
(
)
=
=
1
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
LayerMetricsWrapper
wrapper
=
GetRootContentLayer
(
)
;
if
(
wrapper
)
{
mCompositor
-
>
SetClearColor
(
wrapper
.
Metadata
(
)
.
GetBackgroundColor
(
)
)
;
}
else
{
mCompositor
-
>
SetClearColorToDefault
(
)
;
}
#
endif
if
(
mNativeLayerForEntireWindow
)
{
mNativeLayerForEntireWindow
-
>
SetRect
(
mRenderBounds
)
;
#
ifdef
XP_MACOSX
mNativeLayerForEntireWindow
-
>
SetOpaqueRegion
(
mCompositor
-
>
GetWidget
(
)
-
>
GetOpaqueWidgetRegion
(
)
.
ToUnknownRegion
(
)
)
;
#
endif
}
if
(
mRoot
-
>
GetClipRect
(
)
)
{
clipRect
=
*
mRoot
-
>
GetClipRect
(
)
;
IntRect
rect
(
clipRect
.
X
(
)
clipRect
.
Y
(
)
clipRect
.
Width
(
)
clipRect
.
Height
(
)
)
;
mCompositor
-
>
BeginFrame
(
aInvalidRegion
&
rect
mRenderBounds
aOpaqueRegion
mNativeLayerForEntireWindow
&
actualBounds
)
;
}
else
{
mCompositor
-
>
BeginFrame
(
aInvalidRegion
nullptr
mRenderBounds
aOpaqueRegion
mNativeLayerForEntireWindow
&
actualBounds
)
;
clipRect
=
ParentLayerIntRect
:
:
FromUnknownRect
(
actualBounds
)
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
ScreenCoord
offset
=
GetContentShiftForToolbar
(
)
;
ScopedCompositorRenderOffset
scopedOffset
(
mCompositor
-
>
AsCompositorOGL
(
)
ScreenPoint
(
0
.
0f
offset
)
)
;
#
endif
if
(
actualBounds
.
IsEmpty
(
)
)
{
mProfilerScreenshotGrabber
.
NotifyEmptyFrame
(
)
;
mCompositor
-
>
GetWidget
(
)
-
>
PostRender
(
&
widgetContext
)
;
mPayload
.
Clear
(
)
;
return
true
;
}
RefPtr
<
CompositingRenderTarget
>
previousTarget
;
if
(
haveLayerEffects
)
{
previousTarget
=
PushGroupForLayerEffects
(
)
;
}
else
{
mTwoPassTmpTarget
=
nullptr
;
}
{
Diagnostics
:
:
Record
record
(
mRenderStartTime
)
;
RootLayer
(
)
-
>
Prepare
(
ViewAs
<
RenderTargetPixel
>
(
clipRect
PixelCastJustification
:
:
RenderTargetIsParentLayerForRoot
)
)
;
if
(
record
.
Recording
(
)
)
{
mDiagnostics
-
>
RecordPrepareTime
(
record
.
Duration
(
)
)
;
}
}
{
Diagnostics
:
:
Record
record
;
RootLayer
(
)
-
>
RenderLayer
(
clipRect
.
ToUnknownRect
(
)
Nothing
(
)
)
;
if
(
record
.
Recording
(
)
)
{
mDiagnostics
-
>
RecordCompositeTime
(
record
.
Duration
(
)
)
;
}
}
RootLayer
(
)
-
>
Cleanup
(
)
;
if
(
!
mRegionToClear
.
IsEmpty
(
)
)
{
for
(
auto
iter
=
mRegionToClear
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
IntRect
&
r
=
iter
.
Get
(
)
;
mCompositor
-
>
ClearRect
(
Rect
(
r
.
X
(
)
r
.
Y
(
)
r
.
Width
(
)
r
.
Height
(
)
)
)
;
}
}
if
(
mTwoPassTmpTarget
)
{
MOZ_ASSERT
(
haveLayerEffects
)
;
PopGroupForLayerEffects
(
previousTarget
clipRect
.
ToUnknownRect
(
)
grayscaleVal
invertVal
contrastVal
)
;
}
mCompositor
-
>
GetWidget
(
)
-
>
DrawWindowOverlay
(
&
widgetContext
LayoutDeviceIntRect
:
:
FromUnknownRect
(
actualBounds
)
)
;
mCompositor
-
>
NormalDrawingDone
(
)
;
mProfilerScreenshotGrabber
.
MaybeGrabScreenshot
(
mCompositor
)
;
if
(
mCompositionRecorder
)
{
bool
hasContentPaint
=
std
:
:
any_of
(
mPayload
.
begin
(
)
mPayload
.
end
(
)
[
]
(
CompositionPayload
&
payload
)
{
return
payload
.
mType
=
=
CompositionPayloadType
:
:
eContentPaint
;
}
)
;
if
(
hasContentPaint
)
{
if
(
RefPtr
<
RecordedFrame
>
frame
=
mCompositor
-
>
RecordFrame
(
TimeStamp
:
:
Now
(
)
)
)
{
mCompositionRecorder
-
>
RecordFrame
(
frame
)
;
}
}
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
if
(
jni
:
:
IsFennec
(
)
)
{
RenderToolbar
(
)
;
}
HandlePixelsTarget
(
)
;
#
endif
RenderDebugOverlay
(
actualBounds
)
;
{
AUTO_PROFILER_LABEL
(
"
LayerManagerComposite
:
:
Render
:
EndFrame
"
GRAPHICS
)
;
mCompositor
-
>
EndFrame
(
)
;
}
mCompositor
-
>
GetWidget
(
)
-
>
PostRender
(
&
widgetContext
)
;
mProfilerScreenshotGrabber
.
MaybeProcessQueue
(
)
;
RecordFrame
(
)
;
PayloadPresented
(
)
;
mPayload
.
Clear
(
)
;
mCompositor
-
>
WaitForGPU
(
)
;
return
true
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
class
ScopedCompostitorSurfaceSize
{
public
:
ScopedCompostitorSurfaceSize
(
CompositorOGL
*
aCompositor
const
gfx
:
:
IntSize
&
aSize
)
:
mCompositor
(
aCompositor
)
mOriginalSize
(
mCompositor
-
>
GetDestinationSurfaceSize
(
)
)
{
mCompositor
-
>
SetDestinationSurfaceSize
(
aSize
)
;
}
~
ScopedCompostitorSurfaceSize
(
)
{
mCompositor
-
>
SetDestinationSurfaceSize
(
mOriginalSize
)
;
}
private
:
CompositorOGL
*
const
mCompositor
;
const
gfx
:
:
IntSize
mOriginalSize
;
}
;
class
ScopedContextSurfaceOverride
{
public
:
ScopedContextSurfaceOverride
(
GLContextEGL
*
aContext
void
*
aSurface
)
:
mContext
(
aContext
)
{
MOZ_ASSERT
(
aSurface
)
;
mContext
-
>
SetEGLSurfaceOverride
(
aSurface
)
;
mContext
-
>
MakeCurrent
(
true
)
;
}
~
ScopedContextSurfaceOverride
(
)
{
mContext
-
>
SetEGLSurfaceOverride
(
EGL_NO_SURFACE
)
;
mContext
-
>
MakeCurrent
(
true
)
;
}
private
:
GLContextEGL
*
const
mContext
;
}
;
void
LayerManagerComposite
:
:
RenderToPresentationSurface
(
)
{
if
(
!
mCompositor
)
{
return
;
}
widget
:
:
CompositorWidget
*
const
widget
=
mCompositor
-
>
GetWidget
(
)
;
if
(
!
widget
)
{
return
;
}
ANativeWindow
*
window
=
widget
-
>
AsAndroid
(
)
-
>
GetPresentationANativeWindow
(
)
;
if
(
!
window
)
{
return
;
}
CompositorOGL
*
compositor
=
mCompositor
-
>
AsCompositorOGL
(
)
;
GLContext
*
gl
=
compositor
-
>
gl
(
)
;
GLContextEGL
*
egl
=
GLContextEGL
:
:
Cast
(
gl
)
;
if
(
!
egl
)
{
return
;
}
EGLSurface
surface
=
widget
-
>
AsAndroid
(
)
-
>
GetPresentationEGLSurface
(
)
;
if
(
!
surface
)
{
surface
=
egl
-
>
CreateCompatibleSurface
(
window
)
;
if
(
!
surface
)
{
return
;
}
widget
-
>
AsAndroid
(
)
-
>
SetPresentationEGLSurface
(
surface
)
;
}
const
IntSize
windowSize
(
ANativeWindow_getWidth
(
window
)
ANativeWindow_getHeight
(
window
)
)
;
if
(
(
windowSize
.
width
<
=
0
)
|
|
(
windowSize
.
height
<
=
0
)
)
{
return
;
}
ScreenRotation
rotation
=
compositor
-
>
GetScreenRotation
(
)
;
const
int
actualWidth
=
windowSize
.
width
;
const
int
actualHeight
=
windowSize
.
height
;
const
gfx
:
:
IntSize
originalSize
=
compositor
-
>
GetDestinationSurfaceSize
(
)
;
const
nsIntRect
originalRect
=
nsIntRect
(
0
0
originalSize
.
width
originalSize
.
height
)
;
int
pageWidth
=
originalSize
.
width
;
int
pageHeight
=
originalSize
.
height
;
if
(
rotation
=
=
ROTATION_90
|
|
rotation
=
=
ROTATION_270
)
{
pageWidth
=
originalSize
.
height
;
pageHeight
=
originalSize
.
width
;
}
float
scale
=
1
.
0
;
if
(
(
pageWidth
>
actualWidth
)
|
|
(
pageHeight
>
actualHeight
)
)
{
const
float
scaleWidth
=
(
float
)
actualWidth
/
(
float
)
pageWidth
;
const
float
scaleHeight
=
(
float
)
actualHeight
/
(
float
)
pageHeight
;
scale
=
scaleWidth
<
=
scaleHeight
?
scaleWidth
:
scaleHeight
;
}
const
gfx
:
:
IntSize
actualSize
(
actualWidth
actualHeight
)
;
ScopedCompostitorSurfaceSize
overrideSurfaceSize
(
compositor
actualSize
)
;
const
ScreenPoint
offset
(
(
actualWidth
-
(
int
)
(
scale
*
pageWidth
)
)
/
2
0
)
;
ScopedContextSurfaceOverride
overrideSurface
(
egl
surface
)
;
Matrix
viewMatrix
=
ComputeTransformForRotation
(
originalRect
rotation
)
;
viewMatrix
.
Invert
(
)
;
viewMatrix
.
PostScale
(
scale
scale
)
;
viewMatrix
.
PostTranslate
(
offset
.
x
offset
.
y
)
;
Matrix4x4
matrix
=
Matrix4x4
:
:
From2D
(
viewMatrix
)
;
mRoot
-
>
ComputeEffectiveTransforms
(
matrix
)
;
nsIntRegion
opaque
;
PostProcessLayers
(
opaque
)
;
nsIntRegion
invalid
;
IntRect
bounds
=
IntRect
:
:
Truncate
(
0
0
scale
*
pageWidth
actualHeight
)
;
IntRect
actualBounds
;
MOZ_ASSERT
(
mRoot
-
>
GetOpacity
(
)
=
=
1
)
;
mCompositor
-
>
BeginFrame
(
invalid
nullptr
bounds
nsIntRegion
(
)
nullptr
&
actualBounds
)
;
ScopedScissorRect
scissorRect
(
egl
0
0
actualWidth
actualHeight
)
;
egl
-
>
fClearColor
(
0
.
0
0
.
0
0
.
0
0
.
0
)
;
egl
-
>
fClear
(
LOCAL_GL_COLOR_BUFFER_BIT
)
;
const
IntRect
clipRect
=
IntRect
:
:
Truncate
(
0
0
actualWidth
actualHeight
)
;
RootLayer
(
)
-
>
Prepare
(
RenderTargetIntRect
:
:
FromUnknownRect
(
clipRect
)
)
;
RootLayer
(
)
-
>
RenderLayer
(
clipRect
Nothing
(
)
)
;
mCompositor
-
>
EndFrame
(
)
;
}
ScreenCoord
LayerManagerComposite
:
:
GetContentShiftForToolbar
(
)
{
ScreenCoord
result
(
0
.
0f
)
;
if
(
!
jni
:
:
IsFennec
(
)
)
{
return
result
;
}
if
(
mCompositor
-
>
GetTargetContext
(
)
!
=
nullptr
)
{
return
result
;
}
if
(
CompositorBridgeParent
*
bridge
=
mCompositor
-
>
GetCompositorBridgeParent
(
)
)
{
AndroidDynamicToolbarAnimator
*
animator
=
bridge
-
>
GetAndroidDynamicToolbarAnimator
(
)
;
MOZ_RELEASE_ASSERT
(
animator
)
;
result
.
value
=
(
float
)
animator
-
>
GetCurrentContentOffset
(
)
.
value
;
}
return
result
;
}
void
LayerManagerComposite
:
:
RenderToolbar
(
)
{
if
(
mCompositor
-
>
GetTargetContext
(
)
!
=
nullptr
)
{
return
;
}
if
(
CompositorBridgeParent
*
bridge
=
mCompositor
-
>
GetCompositorBridgeParent
(
)
)
{
AndroidDynamicToolbarAnimator
*
animator
=
bridge
-
>
GetAndroidDynamicToolbarAnimator
(
)
;
MOZ_RELEASE_ASSERT
(
animator
)
;
animator
-
>
UpdateToolbarSnapshotTexture
(
mCompositor
-
>
AsCompositorOGL
(
)
)
;
int32_t
toolbarHeight
=
animator
-
>
GetCurrentToolbarHeight
(
)
;
if
(
toolbarHeight
=
=
0
)
{
return
;
}
EffectChain
effects
;
effects
.
mPrimaryEffect
=
animator
-
>
GetToolbarEffect
(
)
;
if
(
effects
.
mPrimaryEffect
)
{
ScopedCompositorRenderOffset
toolbarOffset
(
mCompositor
-
>
AsCompositorOGL
(
)
ScreenPoint
(
0
.
0f
-
animator
-
>
GetCurrentContentOffset
(
)
)
)
;
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
0
0
mRenderBounds
.
width
toolbarHeight
)
IntRect
(
0
0
mRenderBounds
.
width
toolbarHeight
)
effects
1
.
0
gfx
:
:
Matrix4x4
(
)
)
;
}
}
}
void
LayerManagerComposite
:
:
HandlePixelsTarget
(
)
{
if
(
!
mScreenPixelsTarget
)
{
return
;
}
int32_t
bufferWidth
=
mRenderBounds
.
width
;
int32_t
bufferHeight
=
mRenderBounds
.
height
;
ipc
:
:
Shmem
mem
;
if
(
!
mScreenPixelsTarget
-
>
AllocPixelBuffer
(
bufferWidth
*
bufferHeight
*
sizeof
(
uint32_t
)
&
mem
)
)
{
return
;
}
CompositorOGL
*
compositor
=
mCompositor
-
>
AsCompositorOGL
(
)
;
GLContext
*
gl
=
compositor
-
>
gl
(
)
;
MOZ_ASSERT
(
gl
)
;
gl
-
>
fReadPixels
(
0
0
bufferWidth
bufferHeight
LOCAL_GL_RGBA
LOCAL_GL_UNSIGNED_BYTE
mem
.
get
<
uint8_t
>
(
)
)
;
Unused
<
<
mScreenPixelsTarget
-
>
SendScreenPixels
(
std
:
:
move
(
mem
)
ScreenIntSize
(
bufferWidth
bufferHeight
)
)
;
mScreenPixelsTarget
=
nullptr
;
}
#
endif
already_AddRefed
<
PaintedLayer
>
LayerManagerComposite
:
:
CreatePaintedLayer
(
)
{
if
(
mDestroyed
)
{
NS_WARNING
(
"
Call
on
destroyed
layer
manager
"
)
;
return
nullptr
;
}
return
RefPtr
<
PaintedLayer
>
(
new
PaintedLayerComposite
(
this
)
)
.
forget
(
)
;
}
already_AddRefed
<
ContainerLayer
>
LayerManagerComposite
:
:
CreateContainerLayer
(
)
{
if
(
mDestroyed
)
{
NS_WARNING
(
"
Call
on
destroyed
layer
manager
"
)
;
return
nullptr
;
}
return
RefPtr
<
ContainerLayer
>
(
new
ContainerLayerComposite
(
this
)
)
.
forget
(
)
;
}
already_AddRefed
<
ImageLayer
>
LayerManagerComposite
:
:
CreateImageLayer
(
)
{
if
(
mDestroyed
)
{
NS_WARNING
(
"
Call
on
destroyed
layer
manager
"
)
;
return
nullptr
;
}
return
RefPtr
<
ImageLayer
>
(
new
ImageLayerComposite
(
this
)
)
.
forget
(
)
;
}
already_AddRefed
<
ColorLayer
>
LayerManagerComposite
:
:
CreateColorLayer
(
)
{
if
(
LayerManagerComposite
:
:
mDestroyed
)
{
NS_WARNING
(
"
Call
on
destroyed
layer
manager
"
)
;
return
nullptr
;
}
return
RefPtr
<
ColorLayer
>
(
new
ColorLayerComposite
(
this
)
)
.
forget
(
)
;
}
already_AddRefed
<
CanvasLayer
>
LayerManagerComposite
:
:
CreateCanvasLayer
(
)
{
if
(
LayerManagerComposite
:
:
mDestroyed
)
{
NS_WARNING
(
"
Call
on
destroyed
layer
manager
"
)
;
return
nullptr
;
}
return
RefPtr
<
CanvasLayer
>
(
new
CanvasLayerComposite
(
this
)
)
.
forget
(
)
;
}
already_AddRefed
<
RefLayer
>
LayerManagerComposite
:
:
CreateRefLayer
(
)
{
if
(
LayerManagerComposite
:
:
mDestroyed
)
{
NS_WARNING
(
"
Call
on
destroyed
layer
manager
"
)
;
return
nullptr
;
}
return
RefPtr
<
RefLayer
>
(
new
RefLayerComposite
(
this
)
)
.
forget
(
)
;
}
LayerManagerComposite
:
:
AutoAddMaskEffect
:
:
AutoAddMaskEffect
(
Layer
*
aMaskLayer
EffectChain
&
aEffects
)
:
mCompositable
(
nullptr
)
mFailed
(
false
)
{
if
(
!
aMaskLayer
)
{
return
;
}
mCompositable
=
ToLayerComposite
(
aMaskLayer
)
-
>
GetCompositableHost
(
)
;
if
(
!
mCompositable
)
{
NS_WARNING
(
"
Mask
layer
with
no
compositable
host
"
)
;
mFailed
=
true
;
return
;
}
if
(
!
mCompositable
-
>
AddMaskEffect
(
aEffects
aMaskLayer
-
>
GetEffectiveTransform
(
)
)
)
{
mCompositable
=
nullptr
;
mFailed
=
true
;
}
}
LayerManagerComposite
:
:
AutoAddMaskEffect
:
:
~
AutoAddMaskEffect
(
)
{
if
(
!
mCompositable
)
{
return
;
}
mCompositable
-
>
RemoveMaskEffect
(
)
;
}
bool
LayerManagerComposite
:
:
IsCompositingToScreen
(
)
const
{
if
(
!
mCompositor
)
{
return
true
;
}
return
!
mCompositor
-
>
GetTargetContext
(
)
;
}
LayerComposite
:
:
LayerComposite
(
LayerManagerComposite
*
aManager
)
:
HostLayer
(
aManager
)
mCompositeManager
(
aManager
)
mCompositor
(
aManager
-
>
GetCompositor
(
)
)
mDestroyed
(
false
)
mLayerComposited
(
false
)
{
}
LayerComposite
:
:
~
LayerComposite
(
)
{
}
void
LayerComposite
:
:
Destroy
(
)
{
if
(
!
mDestroyed
)
{
mDestroyed
=
true
;
CleanupResources
(
)
;
}
}
void
LayerComposite
:
:
AddBlendModeEffect
(
EffectChain
&
aEffectChain
)
{
gfx
:
:
CompositionOp
blendMode
=
GetLayer
(
)
-
>
GetEffectiveMixBlendMode
(
)
;
if
(
blendMode
=
=
gfx
:
:
CompositionOp
:
:
OP_OVER
)
{
return
;
}
aEffectChain
.
mSecondaryEffects
[
EffectTypes
:
:
BLEND_MODE
]
=
new
EffectBlendMode
(
blendMode
)
;
}
bool
LayerManagerComposite
:
:
CanUseCanvasLayerForSize
(
const
IntSize
&
aSize
)
{
return
mCompositor
-
>
CanUseCanvasLayerForSize
(
gfx
:
:
IntSize
(
aSize
.
width
aSize
.
height
)
)
;
}
void
LayerManagerComposite
:
:
NotifyShadowTreeTransaction
(
)
{
if
(
StaticPrefs
:
:
layers_acceleration_draw_fps
(
)
)
{
mDiagnostics
-
>
AddTxnFrame
(
)
;
}
}
void
LayerComposite
:
:
SetLayerManager
(
HostLayerManager
*
aManager
)
{
HostLayer
:
:
SetLayerManager
(
aManager
)
;
mCompositeManager
=
static_cast
<
LayerManagerComposite
*
>
(
aManager
)
;
mCompositor
=
mCompositeManager
-
>
GetCompositor
(
)
;
}
bool
LayerManagerComposite
:
:
AsyncPanZoomEnabled
(
)
const
{
if
(
CompositorBridgeParent
*
bridge
=
mCompositor
-
>
GetCompositorBridgeParent
(
)
)
{
return
bridge
-
>
GetOptions
(
)
.
UseAPZ
(
)
;
}
return
false
;
}
bool
LayerManagerComposite
:
:
AlwaysScheduleComposite
(
)
const
{
return
!
!
(
mCompositor
-
>
GetDiagnosticTypes
(
)
&
DiagnosticTypes
:
:
FLASH_BORDERS
)
;
}
nsIntRegion
LayerComposite
:
:
GetFullyRenderedRegion
(
)
{
if
(
TiledContentHost
*
tiled
=
GetCompositableHost
(
)
?
GetCompositableHost
(
)
-
>
AsTiledContentHost
(
)
:
nullptr
)
{
nsIntRegion
shadowVisibleRegion
=
GetShadowVisibleRegion
(
)
.
ToUnknownRegion
(
)
;
shadowVisibleRegion
.
And
(
shadowVisibleRegion
tiled
-
>
GetValidRegion
(
)
)
;
return
shadowVisibleRegion
;
}
else
{
return
GetShadowVisibleRegion
(
)
.
ToUnknownRegion
(
)
;
}
}
Matrix4x4
HostLayer
:
:
GetShadowTransform
(
)
{
Matrix4x4
transform
=
mShadowTransform
;
Layer
*
layer
=
GetLayer
(
)
;
transform
.
PostScale
(
layer
-
>
GetPostXScale
(
)
layer
-
>
GetPostYScale
(
)
1
.
0f
)
;
if
(
const
ContainerLayer
*
c
=
layer
-
>
AsContainerLayer
(
)
)
{
transform
.
PreScale
(
c
-
>
GetPreXScale
(
)
c
-
>
GetPreYScale
(
)
1
.
0f
)
;
}
return
transform
;
}
static
void
ComputeVisibleRegionForChildren
(
ContainerLayer
*
aContainer
LayerIntRegion
&
aResult
)
{
for
(
Layer
*
l
=
aContainer
-
>
GetFirstChild
(
)
;
l
;
l
=
l
-
>
GetNextSibling
(
)
)
{
if
(
l
-
>
Extend3DContext
(
)
)
{
MOZ_ASSERT
(
l
-
>
AsContainerLayer
(
)
)
;
ComputeVisibleRegionForChildren
(
l
-
>
AsContainerLayer
(
)
aResult
)
;
}
else
{
AddTransformedRegion
(
aResult
l
-
>
GetLocalVisibleRegion
(
)
l
-
>
ComputeTransformToPreserve3DRoot
(
)
)
;
}
}
}
void
HostLayer
:
:
RecomputeShadowVisibleRegionFromChildren
(
)
{
mShadowVisibleRegion
.
SetEmpty
(
)
;
ContainerLayer
*
container
=
GetLayer
(
)
-
>
AsContainerLayer
(
)
;
MOZ_ASSERT
(
container
)
;
NS_ASSERTION
(
!
GetLayer
(
)
-
>
Extend3DContext
(
)
"
Can
'
t
compute
visible
region
for
layers
that
extend
a
3d
context
"
)
;
if
(
container
&
&
!
GetLayer
(
)
-
>
Extend3DContext
(
)
)
{
ComputeVisibleRegionForChildren
(
container
mShadowVisibleRegion
)
;
}
}
bool
LayerComposite
:
:
HasStaleCompositor
(
)
const
{
return
mCompositeManager
-
>
GetCompositor
(
)
!
=
mCompositor
;
}
#
ifndef
MOZ_HAVE_PLATFORM_SPECIFIC_LAYER_BUFFERS
bool
LayerManagerComposite
:
:
SupportsDirectTexturing
(
)
{
return
false
;
}
void
LayerManagerComposite
:
:
PlatformSyncBeforeReplyUpdate
(
)
{
}
#
endif
}
}
