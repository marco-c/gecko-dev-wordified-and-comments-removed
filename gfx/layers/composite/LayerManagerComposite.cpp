#
include
"
LayerManagerComposite
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
CanvasLayerComposite
.
h
"
#
include
"
ColorLayerComposite
.
h
"
#
include
"
Composer2D
.
h
"
#
include
"
CompositableHost
.
h
"
#
include
"
ContainerLayerComposite
.
h
"
#
include
"
FPSCounter
.
h
"
#
include
"
FrameMetrics
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
ImageLayerComposite
.
h
"
#
include
"
Layers
.
h
"
#
include
"
LayerScope
.
h
"
#
include
"
protobuf
/
LayerScopePacket
.
pb
.
h
"
#
include
"
PaintedLayerComposite
.
h
"
#
include
"
TiledContentHost
.
h
"
#
include
"
Units
.
h
"
#
include
"
UnitTransforms
.
h
"
#
include
"
apz
/
src
/
AsyncPanZoomController
.
h
"
#
include
"
gfxPrefs
.
h
"
#
ifdef
XP_MACOSX
#
include
"
gfxPlatformMac
.
h
"
#
endif
#
include
"
gfxRect
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
Effects
.
h
"
#
include
"
mozilla
/
layers
/
LayerMetricsWrapper
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
ipc
/
CompositorBench
.
h
"
#
include
"
ipc
/
ShadowLayerUtils
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAppRunner
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRegion
.
h
"
#
ifdef
MOZ_WIDGET_ANDROID
#
include
<
android
/
log
.
h
>
#
include
"
AndroidBridge
.
h
"
#
endif
#
if
defined
(
MOZ_WIDGET_ANDROID
)
|
|
defined
(
MOZ_WIDGET_GONK
)
#
include
"
opengl
/
CompositorOGL
.
h
"
#
include
"
GLContextEGL
.
h
"
#
include
"
GLContextProvider
.
h
"
#
include
"
ScopedGLHelpers
.
h
"
#
endif
#
ifdef
MOZ_WIDGET_GONK
#
include
"
nsScreenManagerGonk
.
h
"
#
include
"
nsWindow
.
h
"
#
endif
#
include
"
GeckoProfiler
.
h
"
#
include
"
TextRenderer
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
"
TreeTraversal
.
h
"
class
gfxContext
;
namespace
mozilla
{
namespace
layers
{
class
ImageLayer
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
gl
;
static
LayerComposite
*
ToLayerComposite
(
Layer
*
aLayer
)
{
return
static_cast
<
LayerComposite
*
>
(
aLayer
-
>
ImplData
(
)
)
;
}
static
void
ClearSubtree
(
Layer
*
aLayer
)
{
ForEachNode
<
ForwardIterator
>
(
aLayer
[
]
(
Layer
*
layer
)
{
ToLayerComposite
(
layer
)
-
>
CleanupResources
(
)
;
}
)
;
}
void
LayerManagerComposite
:
:
ClearCachedResources
(
Layer
*
aSubtree
)
{
MOZ_ASSERT
(
!
aSubtree
|
|
aSubtree
-
>
Manager
(
)
=
=
this
)
;
Layer
*
subtree
=
aSubtree
?
aSubtree
:
mRoot
.
get
(
)
;
if
(
!
subtree
)
{
return
;
}
ClearSubtree
(
subtree
)
;
}
LayerManagerComposite
:
:
LayerManagerComposite
(
Compositor
*
aCompositor
)
:
mWarningLevel
(
0
.
0f
)
mUnusedApzTransformWarning
(
false
)
mDisabledApzWarning
(
false
)
mCompositor
(
aCompositor
)
mInTransaction
(
false
)
mIsCompositorReady
(
false
)
mDebugOverlayWantsNextFrame
(
false
)
mGeometryChanged
(
true
)
mLastFrameMissedHWC
(
false
)
mWindowOverlayChanged
(
false
)
{
mTextRenderer
=
new
TextRenderer
(
aCompositor
)
;
MOZ_ASSERT
(
aCompositor
)
;
}
LayerManagerComposite
:
:
~
LayerManagerComposite
(
)
{
Destroy
(
)
;
}
void
LayerManagerComposite
:
:
Destroy
(
)
{
if
(
!
mDestroyed
)
{
mCompositor
-
>
GetWidget
(
)
-
>
CleanupWindowEffects
(
)
;
if
(
mRoot
)
{
RootLayer
(
)
-
>
Destroy
(
)
;
}
mRoot
=
nullptr
;
mClonedLayerTreeProperties
=
nullptr
;
mDestroyed
=
true
;
}
}
void
LayerManagerComposite
:
:
UpdateRenderBounds
(
const
IntRect
&
aRect
)
{
mRenderBounds
=
aRect
;
}
bool
LayerManagerComposite
:
:
AreComponentAlphaLayersEnabled
(
)
{
return
mCompositor
-
>
GetBackendType
(
)
!
=
LayersBackend
:
:
LAYERS_BASIC
&
&
LayerManager
:
:
AreComponentAlphaLayersEnabled
(
)
;
}
void
LayerManagerComposite
:
:
BeginTransaction
(
)
{
mInTransaction
=
true
;
if
(
!
mCompositor
-
>
Ready
(
)
)
{
return
;
}
mIsCompositorReady
=
true
;
}
void
LayerManagerComposite
:
:
BeginTransactionWithDrawTarget
(
DrawTarget
*
aTarget
const
IntRect
&
aRect
)
{
mInTransaction
=
true
;
if
(
!
mCompositor
-
>
Ready
(
)
)
{
return
;
}
#
ifdef
MOZ_LAYERS_HAVE_LOG
MOZ_LAYERS_LOG
(
(
"
[
-
-
-
-
-
BeginTransaction
"
)
)
;
Log
(
)
;
#
endif
if
(
mDestroyed
)
{
NS_WARNING
(
"
Call
on
destroyed
layer
manager
"
)
;
return
;
}
mIsCompositorReady
=
true
;
mCompositor
-
>
SetTargetContext
(
aTarget
aRect
)
;
mTarget
=
aTarget
;
mTargetBounds
=
aRect
;
}
static
Matrix4x4
GetAccTransformIn3DContext
(
Layer
*
aLayer
)
{
Matrix4x4
transform
=
aLayer
-
>
GetLocalTransform
(
)
;
for
(
Layer
*
layer
=
aLayer
-
>
GetParent
(
)
;
layer
&
&
layer
-
>
Extend3DContext
(
)
;
layer
=
layer
-
>
GetParent
(
)
)
{
transform
=
transform
*
layer
-
>
GetLocalTransform
(
)
;
}
return
transform
;
}
void
LayerManagerComposite
:
:
PostProcessLayers
(
Layer
*
aLayer
nsIntRegion
&
aOpaqueRegion
LayerIntRegion
&
aVisibleRegion
const
Maybe
<
ParentLayerIntRect
>
&
aClipFromAncestors
)
{
if
(
aLayer
-
>
Extend3DContext
(
)
)
{
Maybe
<
ParentLayerIntRect
>
layerClip
=
aLayer
-
>
AsLayerComposite
(
)
-
>
GetShadowClipRect
(
)
;
Maybe
<
ParentLayerIntRect
>
ancestorClipForChildren
=
IntersectMaybeRects
(
layerClip
aClipFromAncestors
)
;
MOZ_ASSERT
(
!
layerClip
|
|
!
aLayer
-
>
Combines3DTransformWithAncestors
(
)
"
Only
direct
children
of
the
establisher
could
have
a
clip
"
)
;
for
(
Layer
*
child
=
aLayer
-
>
GetLastChild
(
)
;
child
;
child
=
child
-
>
GetPrevSibling
(
)
)
{
PostProcessLayers
(
child
aOpaqueRegion
aVisibleRegion
ancestorClipForChildren
)
;
}
return
;
}
nsIntRegion
localOpaque
;
Matrix4x4
transform
=
GetAccTransformIn3DContext
(
aLayer
)
;
Matrix
transform2d
;
Maybe
<
IntPoint
>
integerTranslation
;
if
(
transform
.
Is2D
(
&
transform2d
)
)
{
if
(
transform2d
.
IsIntegerTranslation
(
)
)
{
integerTranslation
=
Some
(
IntPoint
:
:
Truncate
(
transform2d
.
GetTranslation
(
)
)
)
;
localOpaque
=
aOpaqueRegion
;
localOpaque
.
MoveBy
(
-
*
integerTranslation
)
;
}
}
LayerComposite
*
composite
=
aLayer
-
>
AsLayerComposite
(
)
;
Maybe
<
ParentLayerIntRect
>
layerClip
=
composite
-
>
GetShadowClipRect
(
)
;
MOZ_ASSERT
(
!
layerClip
|
|
!
aLayer
-
>
Combines3DTransformWithAncestors
(
)
"
The
layer
with
a
clip
should
not
participate
"
"
a
3D
rendering
context
"
)
;
Maybe
<
ParentLayerIntRect
>
outsideClip
=
IntersectMaybeRects
(
layerClip
aClipFromAncestors
)
;
Maybe
<
LayerIntRect
>
insideClip
;
if
(
outsideClip
&
&
!
transform
.
HasPerspectiveComponent
(
)
)
{
Matrix4x4
inverse
=
transform
;
if
(
inverse
.
Invert
(
)
)
{
Maybe
<
LayerRect
>
insideClipFloat
=
UntransformBy
(
ViewAs
<
ParentLayerToLayerMatrix4x4
>
(
inverse
)
ParentLayerRect
(
*
outsideClip
)
LayerRect
:
:
MaxIntRect
(
)
)
;
if
(
insideClipFloat
)
{
insideClipFloat
-
>
RoundOut
(
)
;
LayerIntRect
insideClipInt
;
if
(
insideClipFloat
-
>
ToIntRect
(
&
insideClipInt
)
)
{
insideClip
=
Some
(
insideClipInt
)
;
}
}
}
}
Maybe
<
ParentLayerIntRect
>
ancestorClipForChildren
;
if
(
insideClip
)
{
ancestorClipForChildren
=
Some
(
ViewAs
<
ParentLayerPixel
>
(
*
insideClip
PixelCastJustification
:
:
MovingDownToChildren
)
)
;
}
nsIntRegion
obscured
=
localOpaque
;
LayerIntRegion
descendantsVisibleRegion
;
bool
hasPreserve3DChild
=
false
;
for
(
Layer
*
child
=
aLayer
-
>
GetLastChild
(
)
;
child
;
child
=
child
-
>
GetPrevSibling
(
)
)
{
PostProcessLayers
(
child
localOpaque
descendantsVisibleRegion
ancestorClipForChildren
)
;
if
(
child
-
>
Extend3DContext
(
)
)
{
hasPreserve3DChild
=
true
;
}
}
LayerIntRegion
visible
=
composite
-
>
GetShadowVisibleRegion
(
)
;
if
(
aLayer
-
>
GetFirstChild
(
)
&
&
!
hasPreserve3DChild
)
{
visible
=
descendantsVisibleRegion
;
}
if
(
!
obscured
.
IsEmpty
(
)
)
{
visible
.
SubOut
(
LayerIntRegion
:
:
FromUnknownRegion
(
obscured
)
)
;
}
if
(
insideClip
)
{
visible
.
AndWith
(
*
insideClip
)
;
}
composite
-
>
SetShadowVisibleRegion
(
visible
)
;
ParentLayerIntRegion
visibleParentSpace
=
TransformBy
(
ViewAs
<
LayerToParentLayerMatrix4x4
>
(
transform
)
visible
)
;
if
(
const
Maybe
<
ParentLayerIntRect
>
&
clipRect
=
composite
-
>
GetShadowClipRect
(
)
)
{
visibleParentSpace
.
AndWith
(
*
clipRect
)
;
}
aVisibleRegion
.
OrWith
(
ViewAs
<
LayerPixel
>
(
visibleParentSpace
PixelCastJustification
:
:
MovingDownToChildren
)
)
;
if
(
integerTranslation
&
&
!
aLayer
-
>
HasMaskLayers
(
)
&
&
aLayer
-
>
IsOpaqueForVisibility
(
)
)
{
if
(
aLayer
-
>
IsOpaque
(
)
)
{
localOpaque
.
OrWith
(
composite
-
>
GetFullyRenderedRegion
(
)
)
;
}
localOpaque
.
MoveBy
(
*
integerTranslation
)
;
if
(
layerClip
)
{
localOpaque
.
AndWith
(
layerClip
-
>
ToUnknownRect
(
)
)
;
}
aOpaqueRegion
.
OrWith
(
localOpaque
)
;
}
}
void
LayerManagerComposite
:
:
EndTransaction
(
const
TimeStamp
&
aTimeStamp
EndTransactionFlags
aFlags
)
{
NS_ASSERTION
(
mInTransaction
"
Didn
'
t
call
BeginTransaction
?
"
)
;
NS_ASSERTION
(
!
(
aFlags
&
END_NO_COMPOSITE
)
"
Shouldn
'
t
get
END_NO_COMPOSITE
here
"
)
;
mInTransaction
=
false
;
if
(
!
mIsCompositorReady
)
{
return
;
}
mIsCompositorReady
=
false
;
#
ifdef
MOZ_LAYERS_HAVE_LOG
MOZ_LAYERS_LOG
(
(
"
-
-
-
-
-
(
beginning
paint
)
"
)
)
;
Log
(
)
;
#
endif
if
(
mDestroyed
)
{
NS_WARNING
(
"
Call
on
destroyed
layer
manager
"
)
;
return
;
}
mCompositor
-
>
SetCompositionTime
(
aTimeStamp
)
;
if
(
mRoot
&
&
!
(
aFlags
&
END_NO_IMMEDIATE_REDRAW
)
)
{
MOZ_ASSERT
(
!
aTimeStamp
.
IsNull
(
)
)
;
UpdateAndRender
(
)
;
mCompositor
-
>
FlushPendingNotifyNotUsed
(
)
;
}
else
{
mGeometryChanged
=
true
;
}
mCompositor
-
>
ClearTargetContext
(
)
;
mTarget
=
nullptr
;
#
ifdef
MOZ_LAYERS_HAVE_LOG
Log
(
)
;
MOZ_LAYERS_LOG
(
(
"
]
-
-
-
-
-
EndTransaction
"
)
)
;
#
endif
}
void
LayerManagerComposite
:
:
UpdateAndRender
(
)
{
nsIntRegion
invalid
;
bool
didEffectiveTransforms
=
false
;
nsIntRegion
opaque
;
LayerIntRegion
visible
;
PostProcessLayers
(
mRoot
opaque
visible
Nothing
(
)
)
;
if
(
mClonedLayerTreeProperties
)
{
mRoot
-
>
ComputeEffectiveTransforms
(
gfx
:
:
Matrix4x4
(
)
)
;
didEffectiveTransforms
=
true
;
nsIntRegion
changed
=
mClonedLayerTreeProperties
-
>
ComputeDifferences
(
mRoot
nullptr
&
mGeometryChanged
)
;
if
(
mTarget
)
{
mInvalidRegion
.
Or
(
mInvalidRegion
changed
)
;
}
else
{
invalid
=
Move
(
changed
)
;
}
}
if
(
mTarget
)
{
invalid
.
Or
(
invalid
mTargetBounds
)
;
}
else
{
if
(
!
mClonedLayerTreeProperties
)
{
invalid
.
Or
(
invalid
mRenderBounds
)
;
}
invalid
.
Or
(
invalid
mInvalidRegion
)
;
mInvalidRegion
.
SetEmpty
(
)
;
}
if
(
invalid
.
IsEmpty
(
)
&
&
!
mWindowOverlayChanged
)
{
mClonedLayerTreeProperties
=
LayerProperties
:
:
CloneFrom
(
GetRoot
(
)
)
;
return
;
}
InvalidateDebugOverlay
(
invalid
mRenderBounds
)
;
if
(
!
didEffectiveTransforms
)
{
mRoot
-
>
ComputeEffectiveTransforms
(
gfx
:
:
Matrix4x4
(
)
)
;
}
Render
(
invalid
opaque
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
|
|
defined
(
MOZ_WIDGET_GONK
)
RenderToPresentationSurface
(
)
;
#
endif
mGeometryChanged
=
false
;
mWindowOverlayChanged
=
false
;
mClonedLayerTreeProperties
=
LayerProperties
:
:
CloneFrom
(
GetRoot
(
)
)
;
}
already_AddRefed
<
DrawTarget
>
LayerManagerComposite
:
:
CreateOptimalMaskDrawTarget
(
const
IntSize
&
aSize
)
{
NS_RUNTIMEABORT
(
"
Should
only
be
called
on
the
drawing
side
"
)
;
return
nullptr
;
}
already_AddRefed
<
PaintedLayer
>
LayerManagerComposite
:
:
CreatePaintedLayer
(
)
{
MOZ_ASSERT
(
gIsGtest
"
Unless
you
'
re
testing
the
compositor
using
GTest
"
"
this
should
only
be
called
on
the
drawing
side
"
)
;
RefPtr
<
PaintedLayer
>
layer
=
new
PaintedLayerComposite
(
this
)
;
return
layer
.
forget
(
)
;
}
already_AddRefed
<
ContainerLayer
>
LayerManagerComposite
:
:
CreateContainerLayer
(
)
{
MOZ_ASSERT
(
gIsGtest
"
Unless
you
'
re
testing
the
compositor
using
GTest
"
"
this
should
only
be
called
on
the
drawing
side
"
)
;
RefPtr
<
ContainerLayer
>
layer
=
new
ContainerLayerComposite
(
this
)
;
return
layer
.
forget
(
)
;
}
already_AddRefed
<
ImageLayer
>
LayerManagerComposite
:
:
CreateImageLayer
(
)
{
NS_RUNTIMEABORT
(
"
Should
only
be
called
on
the
drawing
side
"
)
;
return
nullptr
;
}
already_AddRefed
<
ColorLayer
>
LayerManagerComposite
:
:
CreateColorLayer
(
)
{
MOZ_ASSERT
(
gIsGtest
"
Unless
you
'
re
testing
the
compositor
using
GTest
"
"
this
should
only
be
called
on
the
drawing
side
"
)
;
RefPtr
<
ColorLayer
>
layer
=
new
ColorLayerComposite
(
this
)
;
return
layer
.
forget
(
)
;
}
already_AddRefed
<
CanvasLayer
>
LayerManagerComposite
:
:
CreateCanvasLayer
(
)
{
NS_RUNTIMEABORT
(
"
Should
only
be
called
on
the
drawing
side
"
)
;
return
nullptr
;
}
LayerComposite
*
LayerManagerComposite
:
:
RootLayer
(
)
const
{
if
(
mDestroyed
)
{
NS_WARNING
(
"
Call
on
destroyed
layer
manager
"
)
;
return
nullptr
;
}
return
ToLayerComposite
(
mRoot
)
;
}
#
ifdef
MOZ_PROFILING
#
include
"
qrcode_table
.
h
"
#
endif
void
LayerManagerComposite
:
:
InvalidateDebugOverlay
(
nsIntRegion
&
aInvalidRegion
const
IntRect
&
aBounds
)
{
bool
drawFps
=
gfxPrefs
:
:
LayersDrawFPS
(
)
;
bool
drawFrameCounter
=
gfxPrefs
:
:
DrawFrameCounter
(
)
;
bool
drawFrameColorBars
=
gfxPrefs
:
:
CompositorDrawColorBars
(
)
;
if
(
drawFps
|
|
drawFrameCounter
)
{
aInvalidRegion
.
Or
(
aInvalidRegion
nsIntRect
(
0
0
256
256
)
)
;
}
if
(
drawFrameColorBars
)
{
aInvalidRegion
.
Or
(
aInvalidRegion
nsIntRect
(
0
0
10
aBounds
.
height
)
)
;
}
}
static
uint16_t
sFrameCount
=
0
;
void
LayerManagerComposite
:
:
RenderDebugOverlay
(
const
IntRect
&
aBounds
)
{
bool
drawFps
=
gfxPrefs
:
:
LayersDrawFPS
(
)
;
bool
drawFrameCounter
=
gfxPrefs
:
:
DrawFrameCounter
(
)
;
bool
drawFrameColorBars
=
gfxPrefs
:
:
CompositorDrawColorBars
(
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
drawFps
)
{
if
(
!
mFPS
)
{
mFPS
=
MakeUnique
<
FPSState
>
(
)
;
}
float
alpha
=
1
;
#
ifdef
ANDROID
int
width
;
int
border
;
if
(
!
mWarnTime
.
IsNull
(
)
&
&
(
now
-
mWarnTime
)
.
ToMilliseconds
(
)
<
kVisualWarningDuration
)
{
EffectChain
effects
;
border
=
4
;
width
=
6
;
effects
.
mPrimaryEffect
=
new
EffectSolidColor
(
gfx
:
:
Color
(
0
0
0
1
)
)
;
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
border
border
aBounds
.
width
-
2
*
border
width
)
aBounds
effects
alpha
gfx
:
:
Matrix4x4
(
)
)
;
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
border
aBounds
.
height
-
border
-
width
aBounds
.
width
-
2
*
border
width
)
aBounds
effects
alpha
gfx
:
:
Matrix4x4
(
)
)
;
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
border
border
+
width
width
aBounds
.
height
-
2
*
border
-
width
*
2
)
aBounds
effects
alpha
gfx
:
:
Matrix4x4
(
)
)
;
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
aBounds
.
width
-
border
-
width
border
+
width
width
aBounds
.
height
-
2
*
border
-
2
*
width
)
aBounds
effects
alpha
gfx
:
:
Matrix4x4
(
)
)
;
border
=
5
;
width
=
4
;
effects
.
mPrimaryEffect
=
new
EffectSolidColor
(
gfx
:
:
Color
(
1
1
.
f
-
mWarningLevel
0
1
)
)
;
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
border
border
aBounds
.
width
-
2
*
border
width
)
aBounds
effects
alpha
gfx
:
:
Matrix4x4
(
)
)
;
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
border
aBounds
.
height
-
border
-
width
aBounds
.
width
-
2
*
border
width
)
aBounds
effects
alpha
gfx
:
:
Matrix4x4
(
)
)
;
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
border
border
+
width
width
aBounds
.
height
-
2
*
border
-
width
*
2
)
aBounds
effects
alpha
gfx
:
:
Matrix4x4
(
)
)
;
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
aBounds
.
width
-
border
-
width
border
+
width
width
aBounds
.
height
-
2
*
border
-
2
*
width
)
aBounds
effects
alpha
gfx
:
:
Matrix4x4
(
)
)
;
SetDebugOverlayWantsNextFrame
(
true
)
;
}
#
endif
float
fillRatio
=
mCompositor
-
>
GetFillRatio
(
)
;
mFPS
-
>
DrawFPS
(
now
drawFrameColorBars
?
10
:
1
2
unsigned
(
fillRatio
)
mCompositor
)
;
if
(
mUnusedApzTransformWarning
)
{
EffectChain
effects
;
effects
.
mPrimaryEffect
=
new
EffectSolidColor
(
gfx
:
:
Color
(
1
0
0
1
)
)
;
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
aBounds
.
width
-
20
0
20
20
)
aBounds
effects
alpha
gfx
:
:
Matrix4x4
(
)
)
;
mUnusedApzTransformWarning
=
false
;
SetDebugOverlayWantsNextFrame
(
true
)
;
}
if
(
mDisabledApzWarning
)
{
EffectChain
effects
;
effects
.
mPrimaryEffect
=
new
EffectSolidColor
(
gfx
:
:
Color
(
1
1
0
1
)
)
;
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
aBounds
.
width
-
40
0
20
20
)
aBounds
effects
alpha
gfx
:
:
Matrix4x4
(
)
)
;
mDisabledApzWarning
=
false
;
SetDebugOverlayWantsNextFrame
(
true
)
;
}
}
else
{
mFPS
=
nullptr
;
}
if
(
drawFrameColorBars
)
{
gfx
:
:
IntRect
sideRect
(
0
0
10
aBounds
.
height
)
;
EffectChain
effects
;
effects
.
mPrimaryEffect
=
new
EffectSolidColor
(
gfxUtils
:
:
GetColorForFrameNumber
(
sFrameCount
)
)
;
mCompositor
-
>
DrawQuad
(
Rect
(
sideRect
)
sideRect
effects
1
.
0
gfx
:
:
Matrix4x4
(
)
)
;
}
#
ifdef
MOZ_PROFILING
if
(
drawFrameCounter
)
{
profiler_set_frame_number
(
sFrameCount
)
;
const
char
*
qr
=
sQRCodeTable
[
sFrameCount
%
256
]
;
int
size
=
21
;
int
padding
=
2
;
float
opacity
=
1
.
0
;
const
uint16_t
bitWidth
=
5
;
gfx
:
:
IntRect
clip
(
0
0
bitWidth
*
640
bitWidth
*
640
)
;
gfx
:
:
Color
bitColor
(
1
.
0
1
.
0
1
.
0
1
.
0
)
;
EffectChain
effects
;
effects
.
mPrimaryEffect
=
new
EffectSolidColor
(
bitColor
)
;
int
totalSize
=
(
size
+
padding
*
2
)
*
bitWidth
;
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
0
0
totalSize
totalSize
)
clip
effects
opacity
gfx
:
:
Matrix4x4
(
)
)
;
effects
.
mPrimaryEffect
=
new
EffectSolidColor
(
gfx
:
:
Color
(
0
0
0
1
.
0
)
)
;
for
(
int
y
=
0
;
y
<
size
;
y
+
+
)
{
for
(
int
x
=
0
;
x
<
size
;
x
+
+
)
{
int
currBit
=
128
>
>
(
(
x
+
y
*
21
)
%
8
)
;
int
i
=
(
x
+
y
*
21
)
/
8
;
if
(
qr
[
i
]
&
currBit
)
{
mCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
bitWidth
*
(
x
+
padding
)
bitWidth
*
(
y
+
padding
)
bitWidth
bitWidth
)
clip
effects
opacity
gfx
:
:
Matrix4x4
(
)
)
;
}
}
}
}
#
endif
if
(
drawFrameColorBars
|
|
drawFrameCounter
)
{
sFrameCount
+
+
;
}
}
RefPtr
<
CompositingRenderTarget
>
LayerManagerComposite
:
:
PushGroupForLayerEffects
(
)
{
MOZ_ASSERT
(
gfxPrefs
:
:
LayersEffectInvert
(
)
|
|
gfxPrefs
:
:
LayersEffectGrayscale
(
)
|
|
gfxPrefs
:
:
LayersEffectContrast
(
)
!
=
0
.
0
)
;
RefPtr
<
CompositingRenderTarget
>
previousTarget
=
mCompositor
-
>
GetCurrentRenderTarget
(
)
;
IntRect
rect
(
previousTarget
-
>
GetOrigin
(
)
previousTarget
-
>
GetSize
(
)
)
;
MOZ_ASSERT
(
rect
.
x
=
=
0
&
&
rect
.
y
=
=
0
)
;
if
(
!
mTwoPassTmpTarget
|
|
mTwoPassTmpTarget
-
>
GetSize
(
)
!
=
previousTarget
-
>
GetSize
(
)
|
|
mTwoPassTmpTarget
-
>
GetOrigin
(
)
!
=
previousTarget
-
>
GetOrigin
(
)
)
{
mTwoPassTmpTarget
=
mCompositor
-
>
CreateRenderTarget
(
rect
INIT_MODE_NONE
)
;
}
MOZ_ASSERT
(
mTwoPassTmpTarget
)
;
mCompositor
-
>
SetRenderTarget
(
mTwoPassTmpTarget
)
;
return
previousTarget
;
}
void
LayerManagerComposite
:
:
PopGroupForLayerEffects
(
RefPtr
<
CompositingRenderTarget
>
aPreviousTarget
IntRect
aClipRect
bool
aGrayscaleEffect
bool
aInvertEffect
float
aContrastEffect
)
{
MOZ_ASSERT
(
mTwoPassTmpTarget
)
;
MOZ_ASSERT
(
aInvertEffect
|
|
aGrayscaleEffect
|
|
aContrastEffect
!
=
0
.
0
)
;
mCompositor
-
>
SetRenderTarget
(
aPreviousTarget
)
;
EffectChain
effectChain
(
RootLayer
(
)
)
;
Matrix5x4
effectMatrix
;
if
(
aGrayscaleEffect
)
{
Matrix5x4
grayscaleMatrix
(
0
.
2126f
0
.
2126f
0
.
2126f
0
0
.
7152f
0
.
7152f
0
.
7152f
0
0
.
0722f
0
.
0722f
0
.
0722f
0
0
0
0
1
0
0
0
0
)
;
effectMatrix
=
grayscaleMatrix
;
}
if
(
aInvertEffect
)
{
Matrix5x4
colorInvertMatrix
(
-
1
0
0
0
0
-
1
0
0
0
0
-
1
0
0
0
0
1
1
1
1
0
)
;
effectMatrix
=
effectMatrix
*
colorInvertMatrix
;
}
if
(
aContrastEffect
!
=
0
.
0
)
{
float
cP1
=
aContrastEffect
+
1
;
float
hc
=
0
.
5
*
aContrastEffect
;
Matrix5x4
contrastMatrix
(
cP1
0
0
0
0
cP1
0
0
0
0
cP1
0
0
0
0
1
-
hc
-
hc
-
hc
0
)
;
effectMatrix
=
effectMatrix
*
contrastMatrix
;
}
effectChain
.
mPrimaryEffect
=
new
EffectRenderTarget
(
mTwoPassTmpTarget
)
;
effectChain
.
mSecondaryEffects
[
EffectTypes
:
:
COLOR_MATRIX
]
=
new
EffectColorMatrix
(
effectMatrix
)
;
mCompositor
-
>
DrawQuad
(
Rect
(
Point
(
0
0
)
Size
(
mTwoPassTmpTarget
-
>
GetSize
(
)
)
)
aClipRect
effectChain
1
.
Matrix4x4
(
)
)
;
}
static
void
ClearLayerFlags
(
Layer
*
aLayer
)
{
ForEachNode
<
ForwardIterator
>
(
aLayer
[
]
(
Layer
*
layer
)
{
if
(
layer
-
>
AsLayerComposite
(
)
)
{
layer
-
>
AsLayerComposite
(
)
-
>
SetLayerComposited
(
false
)
;
}
}
)
;
}
void
LayerManagerComposite
:
:
Render
(
const
nsIntRegion
&
aInvalidRegion
const
nsIntRegion
&
aOpaqueRegion
)
{
PROFILER_LABEL
(
"
LayerManagerComposite
"
"
Render
"
js
:
:
ProfileEntry
:
:
Category
:
:
GRAPHICS
)
;
if
(
mDestroyed
|
|
!
mCompositor
|
|
mCompositor
-
>
IsDestroyed
(
)
)
{
NS_WARNING
(
"
Call
on
destroyed
layer
manager
"
)
;
return
;
}
ClearLayerFlags
(
mRoot
)
;
bool
invertVal
=
gfxPrefs
:
:
LayersEffectInvert
(
)
;
bool
grayscaleVal
=
gfxPrefs
:
:
LayersEffectGrayscale
(
)
;
float
contrastVal
=
gfxPrefs
:
:
LayersEffectContrast
(
)
;
bool
haveLayerEffects
=
(
invertVal
|
|
grayscaleVal
|
|
contrastVal
!
=
0
.
0
)
;
LayerScopeAutoFrame
frame
(
PR_Now
(
)
)
;
if
(
gfxPrefs
:
:
LayersDump
(
)
)
{
this
-
>
Dump
(
true
)
;
}
else
if
(
profiler_feature_active
(
"
layersdump
"
)
)
{
std
:
:
stringstream
ss
;
Dump
(
ss
)
;
profiler_log
(
ss
.
str
(
)
.
c_str
(
)
)
;
}
if
(
LayerScope
:
:
CheckSendable
(
)
)
{
auto
packet
=
MakeUnique
<
layerscope
:
:
Packet
>
(
)
;
layerscope
:
:
LayersPacket
*
layersPacket
=
packet
-
>
mutable_layers
(
)
;
this
-
>
Dump
(
layersPacket
)
;
LayerScope
:
:
SendLayerDump
(
Move
(
packet
)
)
;
}
RefPtr
<
Composer2D
>
composer2D
;
composer2D
=
mCompositor
-
>
GetWidget
(
)
-
>
GetComposer2D
(
)
;
if
(
!
mTarget
&
&
!
haveLayerEffects
&
&
gfxPrefs
:
:
Composer2DCompositionEnabled
(
)
&
&
composer2D
&
&
composer2D
-
>
HasHwc
(
)
&
&
composer2D
-
>
TryRenderWithHwc
(
mRoot
mCompositor
-
>
GetWidget
(
)
-
>
RealWidget
(
)
mGeometryChanged
mCompositor
-
>
HasImageHostOverlays
(
)
)
)
{
LayerScope
:
:
SetHWComposed
(
)
;
if
(
mFPS
)
{
double
fps
=
mFPS
-
>
mCompositionFps
.
AddFrameAndGetFps
(
TimeStamp
:
:
Now
(
)
)
;
if
(
gfxPrefs
:
:
LayersDrawFPS
(
)
)
{
printf_stderr
(
"
HWComposer
:
FPS
is
%
g
\
n
"
fps
)
;
}
}
mCompositor
-
>
EndFrameForExternalComposition
(
Matrix
(
)
)
;
mLastFrameMissedHWC
=
false
;
return
;
}
else
if
(
!
mTarget
&
&
!
haveLayerEffects
)
{
mLastFrameMissedHWC
=
!
!
composer2D
;
}
{
PROFILER_LABEL
(
"
LayerManagerComposite
"
"
PreRender
"
js
:
:
ProfileEntry
:
:
Category
:
:
GRAPHICS
)
;
if
(
!
mCompositor
-
>
GetWidget
(
)
-
>
PreRender
(
this
)
)
{
return
;
}
}
ParentLayerIntRect
clipRect
;
IntRect
bounds
(
mRenderBounds
.
x
mRenderBounds
.
y
mRenderBounds
.
width
mRenderBounds
.
height
)
;
IntRect
actualBounds
;
CompositorBench
(
mCompositor
bounds
)
;
MOZ_ASSERT
(
mRoot
-
>
GetOpacity
(
)
=
=
1
)
;
if
(
mRoot
-
>
GetClipRect
(
)
)
{
clipRect
=
*
mRoot
-
>
GetClipRect
(
)
;
IntRect
rect
(
clipRect
.
x
clipRect
.
y
clipRect
.
width
clipRect
.
height
)
;
mCompositor
-
>
BeginFrame
(
aInvalidRegion
&
rect
bounds
aOpaqueRegion
nullptr
&
actualBounds
)
;
}
else
{
gfx
:
:
IntRect
rect
;
mCompositor
-
>
BeginFrame
(
aInvalidRegion
nullptr
bounds
aOpaqueRegion
&
rect
&
actualBounds
)
;
clipRect
=
ParentLayerIntRect
(
rect
.
x
rect
.
y
rect
.
width
rect
.
height
)
;
}
if
(
actualBounds
.
IsEmpty
(
)
)
{
mCompositor
-
>
GetWidget
(
)
-
>
PostRender
(
this
)
;
return
;
}
mCompositor
-
>
GetWidget
(
)
-
>
DrawWindowUnderlay
(
this
LayoutDeviceIntRect
:
:
FromUnknownRect
(
actualBounds
)
)
;
RefPtr
<
CompositingRenderTarget
>
previousTarget
;
if
(
haveLayerEffects
)
{
previousTarget
=
PushGroupForLayerEffects
(
)
;
}
else
{
mTwoPassTmpTarget
=
nullptr
;
}
RootLayer
(
)
-
>
Prepare
(
ViewAs
<
RenderTargetPixel
>
(
clipRect
PixelCastJustification
:
:
RenderTargetIsParentLayerForRoot
)
)
;
RootLayer
(
)
-
>
RenderLayer
(
clipRect
.
ToUnknownRect
(
)
)
;
if
(
!
mRegionToClear
.
IsEmpty
(
)
)
{
for
(
auto
iter
=
mRegionToClear
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
IntRect
&
r
=
iter
.
Get
(
)
;
mCompositor
-
>
ClearRect
(
Rect
(
r
.
x
r
.
y
r
.
width
r
.
height
)
)
;
}
}
if
(
mTwoPassTmpTarget
)
{
MOZ_ASSERT
(
haveLayerEffects
)
;
PopGroupForLayerEffects
(
previousTarget
clipRect
.
ToUnknownRect
(
)
grayscaleVal
invertVal
contrastVal
)
;
}
mCompositor
-
>
GetWidget
(
)
-
>
DrawWindowOverlay
(
this
LayoutDeviceIntRect
:
:
FromUnknownRect
(
actualBounds
)
)
;
RenderDebugOverlay
(
actualBounds
)
;
{
PROFILER_LABEL
(
"
LayerManagerComposite
"
"
EndFrame
"
js
:
:
ProfileEntry
:
:
Category
:
:
GRAPHICS
)
;
mCompositor
-
>
EndFrame
(
)
;
mCompositor
-
>
SetDispAcquireFence
(
mRoot
)
;
}
if
(
composer2D
)
{
composer2D
-
>
Render
(
mCompositor
-
>
GetWidget
(
)
-
>
RealWidget
(
)
)
;
}
mCompositor
-
>
GetWidget
(
)
-
>
PostRender
(
this
)
;
RecordFrame
(
)
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
|
|
defined
(
MOZ_WIDGET_GONK
)
class
ScopedCompositorProjMatrix
{
public
:
ScopedCompositorProjMatrix
(
CompositorOGL
*
aCompositor
const
Matrix4x4
&
aProjMatrix
)
:
mCompositor
(
aCompositor
)
mOriginalProjMatrix
(
mCompositor
-
>
GetProjMatrix
(
)
)
{
mCompositor
-
>
SetProjMatrix
(
aProjMatrix
)
;
}
~
ScopedCompositorProjMatrix
(
)
{
mCompositor
-
>
SetProjMatrix
(
mOriginalProjMatrix
)
;
}
private
:
CompositorOGL
*
const
mCompositor
;
const
Matrix4x4
mOriginalProjMatrix
;
}
;
class
ScopedCompostitorSurfaceSize
{
public
:
ScopedCompostitorSurfaceSize
(
CompositorOGL
*
aCompositor
const
gfx
:
:
IntSize
&
aSize
)
:
mCompositor
(
aCompositor
)
mOriginalSize
(
mCompositor
-
>
GetDestinationSurfaceSize
(
)
)
{
mCompositor
-
>
SetDestinationSurfaceSize
(
aSize
)
;
}
~
ScopedCompostitorSurfaceSize
(
)
{
mCompositor
-
>
SetDestinationSurfaceSize
(
mOriginalSize
)
;
}
private
:
CompositorOGL
*
const
mCompositor
;
const
gfx
:
:
IntSize
mOriginalSize
;
}
;
class
ScopedCompositorRenderOffset
{
public
:
ScopedCompositorRenderOffset
(
CompositorOGL
*
aCompositor
const
ScreenPoint
&
aOffset
)
:
mCompositor
(
aCompositor
)
mOriginalOffset
(
mCompositor
-
>
GetScreenRenderOffset
(
)
)
{
mCompositor
-
>
SetScreenRenderOffset
(
aOffset
)
;
}
~
ScopedCompositorRenderOffset
(
)
{
mCompositor
-
>
SetScreenRenderOffset
(
mOriginalOffset
)
;
}
private
:
CompositorOGL
*
const
mCompositor
;
const
ScreenPoint
mOriginalOffset
;
}
;
class
ScopedContextSurfaceOverride
{
public
:
ScopedContextSurfaceOverride
(
GLContextEGL
*
aContext
void
*
aSurface
)
:
mContext
(
aContext
)
{
MOZ_ASSERT
(
aSurface
)
;
mContext
-
>
SetEGLSurfaceOverride
(
aSurface
)
;
mContext
-
>
MakeCurrent
(
true
)
;
}
~
ScopedContextSurfaceOverride
(
)
{
mContext
-
>
SetEGLSurfaceOverride
(
EGL_NO_SURFACE
)
;
mContext
-
>
MakeCurrent
(
true
)
;
}
private
:
GLContextEGL
*
const
mContext
;
}
;
void
LayerManagerComposite
:
:
RenderToPresentationSurface
(
)
{
#
ifdef
MOZ_WIDGET_ANDROID
if
(
!
AndroidBridge
:
:
Bridge
(
)
)
{
return
;
}
void
*
window
=
AndroidBridge
:
:
Bridge
(
)
-
>
GetPresentationWindow
(
)
;
if
(
!
window
)
{
return
;
}
EGLSurface
surface
=
AndroidBridge
:
:
Bridge
(
)
-
>
GetPresentationSurface
(
)
;
if
(
!
surface
)
{
surface
=
GLContextProviderEGL
:
:
CreateEGLSurface
(
window
)
;
if
(
!
surface
)
{
return
;
}
AndroidBridge
:
:
Bridge
(
)
-
>
SetPresentationSurface
(
surface
)
;
}
CompositorOGL
*
compositor
=
mCompositor
-
>
AsCompositorOGL
(
)
;
GLContext
*
gl
=
compositor
-
>
gl
(
)
;
GLContextEGL
*
egl
=
GLContextEGL
:
:
Cast
(
gl
)
;
if
(
!
egl
)
{
return
;
}
const
IntSize
windowSize
=
AndroidBridge
:
:
Bridge
(
)
-
>
GetNativeWindowSize
(
window
)
;
#
elif
defined
(
MOZ_WIDGET_GONK
)
CompositorOGL
*
compositor
=
mCompositor
-
>
AsCompositorOGL
(
)
;
nsScreenGonk
*
screen
=
static_cast
<
nsWindow
*
>
(
mCompositor
-
>
GetWidget
(
)
-
>
RealWidget
(
)
)
-
>
GetScreen
(
)
;
if
(
!
screen
-
>
IsPrimaryScreen
(
)
)
{
return
;
}
nsWindow
*
mirrorScreenWidget
=
screen
-
>
GetMirroringWidget
(
)
;
if
(
!
mirrorScreenWidget
)
{
return
;
}
nsScreenGonk
*
mirrorScreen
=
mirrorScreenWidget
-
>
GetScreen
(
)
;
if
(
!
mirrorScreen
-
>
GetTopWindows
(
)
.
IsEmpty
(
)
)
{
return
;
}
EGLSurface
surface
=
mirrorScreen
-
>
GetEGLSurface
(
)
;
if
(
surface
=
=
LOCAL_EGL_NO_SURFACE
)
{
RefPtr
<
GLContext
>
gl
=
gl
:
:
GLContextProvider
:
:
CreateForWindow
(
mirrorScreenWidget
false
)
;
mirrorScreenWidget
-
>
SetNativeData
(
NS_NATIVE_OPENGL_CONTEXT
reinterpret_cast
<
uintptr_t
>
(
gl
.
get
(
)
)
)
;
surface
=
mirrorScreen
-
>
GetEGLSurface
(
)
;
if
(
surface
=
=
LOCAL_EGL_NO_SURFACE
)
{
return
;
}
}
GLContext
*
gl
=
compositor
-
>
gl
(
)
;
GLContextEGL
*
egl
=
GLContextEGL
:
:
Cast
(
gl
)
;
const
IntSize
windowSize
=
mirrorScreen
-
>
GetNaturalBounds
(
)
.
Size
(
)
.
ToUnknownSize
(
)
;
#
endif
if
(
(
windowSize
.
width
<
=
0
)
|
|
(
windowSize
.
height
<
=
0
)
)
{
return
;
}
ScreenRotation
rotation
=
compositor
-
>
GetScreenRotation
(
)
;
const
int
actualWidth
=
windowSize
.
width
;
const
int
actualHeight
=
windowSize
.
height
;
const
gfx
:
:
IntSize
originalSize
=
compositor
-
>
GetDestinationSurfaceSize
(
)
;
const
nsIntRect
originalRect
=
nsIntRect
(
0
0
originalSize
.
width
originalSize
.
height
)
;
int
pageWidth
=
originalSize
.
width
;
int
pageHeight
=
originalSize
.
height
;
if
(
rotation
=
=
ROTATION_90
|
|
rotation
=
=
ROTATION_270
)
{
pageWidth
=
originalSize
.
height
;
pageHeight
=
originalSize
.
width
;
}
float
scale
=
1
.
0
;
if
(
(
pageWidth
>
actualWidth
)
|
|
(
pageHeight
>
actualHeight
)
)
{
const
float
scaleWidth
=
(
float
)
actualWidth
/
(
float
)
pageWidth
;
const
float
scaleHeight
=
(
float
)
actualHeight
/
(
float
)
pageHeight
;
scale
=
scaleWidth
<
=
scaleHeight
?
scaleWidth
:
scaleHeight
;
}
const
gfx
:
:
IntSize
actualSize
(
actualWidth
actualHeight
)
;
ScopedCompostitorSurfaceSize
overrideSurfaceSize
(
compositor
actualSize
)
;
const
ScreenPoint
offset
(
(
actualWidth
-
(
int
)
(
scale
*
pageWidth
)
)
/
2
0
)
;
ScopedContextSurfaceOverride
overrideSurface
(
egl
surface
)
;
Matrix
viewMatrix
=
ComputeTransformForRotation
(
originalRect
rotation
)
;
viewMatrix
.
Invert
(
)
;
viewMatrix
.
PostScale
(
scale
scale
)
;
viewMatrix
.
PostTranslate
(
offset
.
x
offset
.
y
)
;
Matrix4x4
matrix
=
Matrix4x4
:
:
From2D
(
viewMatrix
)
;
mRoot
-
>
ComputeEffectiveTransforms
(
matrix
)
;
nsIntRegion
opaque
;
LayerIntRegion
visible
;
PostProcessLayers
(
mRoot
opaque
visible
Nothing
(
)
)
;
nsIntRegion
invalid
;
IntRect
bounds
(
0
0
scale
*
pageWidth
actualHeight
)
;
IntRect
rect
actualBounds
;
MOZ_ASSERT
(
mRoot
-
>
GetOpacity
(
)
=
=
1
)
;
mCompositor
-
>
BeginFrame
(
invalid
nullptr
bounds
nsIntRegion
(
)
&
rect
&
actualBounds
)
;
ScopedScissorRect
scissorRect
(
egl
0
0
actualWidth
actualHeight
)
;
egl
-
>
fClearColor
(
0
.
0
0
.
0
0
.
0
0
.
0
)
;
egl
-
>
fClear
(
LOCAL_GL_COLOR_BUFFER_BIT
)
;
const
IntRect
clipRect
=
IntRect
(
0
0
actualWidth
actualHeight
)
;
RootLayer
(
)
-
>
Prepare
(
RenderTargetIntRect
:
:
FromUnknownRect
(
clipRect
)
)
;
RootLayer
(
)
-
>
RenderLayer
(
clipRect
)
;
mCompositor
-
>
EndFrame
(
)
;
#
ifdef
MOZ_WIDGET_GONK
mCompositor
-
>
SetDispAcquireFence
(
mRoot
)
;
RefPtr
<
Composer2D
>
composer2D
;
composer2D
=
mCompositor
-
>
GetWidget
(
)
-
>
GetComposer2D
(
)
;
if
(
composer2D
)
{
composer2D
-
>
Render
(
mirrorScreenWidget
)
;
}
#
endif
}
#
endif
static
void
SubtractTransformedRegion
(
nsIntRegion
&
aRegion
const
nsIntRegion
&
aRegionToSubtract
const
Matrix4x4
&
aTransform
)
{
if
(
aRegionToSubtract
.
IsEmpty
(
)
)
{
return
;
}
for
(
auto
iter
=
aRegionToSubtract
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
IntRect
&
rect
=
iter
.
Get
(
)
;
Rect
incompleteRect
=
aTransform
.
TransformAndClipBounds
(
IntRectToRect
(
rect
)
Rect
:
:
MaxIntRect
(
)
)
;
aRegion
.
Sub
(
aRegion
IntRect
(
incompleteRect
.
x
incompleteRect
.
y
incompleteRect
.
width
incompleteRect
.
height
)
)
;
}
}
void
LayerManagerComposite
:
:
ComputeRenderIntegrityInternal
(
Layer
*
aLayer
nsIntRegion
&
aScreenRegion
nsIntRegion
&
aLowPrecisionScreenRegion
const
Matrix4x4
&
aTransform
)
{
ForEachNode
<
ForwardIterator
>
(
aLayer
[
&
aScreenRegion
&
aLowPrecisionScreenRegion
&
aTransform
]
(
Layer
*
layer
)
{
if
(
layer
-
>
GetOpacity
(
)
<
=
0
.
f
|
|
(
aScreenRegion
.
IsEmpty
(
)
&
&
aLowPrecisionScreenRegion
.
IsEmpty
(
)
)
)
{
return
TraversalFlag
:
:
Skip
;
}
ContainerLayer
*
container
=
layer
-
>
AsContainerLayer
(
)
;
if
(
container
)
{
Matrix4x4
transform
=
aTransform
;
if
(
container
-
>
UseIntermediateSurface
(
)
)
{
transform
=
layer
-
>
GetEffectiveTransform
(
)
;
transform
=
aTransform
*
transform
;
}
return
TraversalFlag
:
:
Continue
;
}
PaintedLayer
*
paintedLayer
=
layer
-
>
AsPaintedLayer
(
)
;
if
(
!
paintedLayer
|
|
!
container
)
{
return
TraversalFlag
:
:
Skip
;
}
nsIntRegion
incompleteRegion
=
layer
-
>
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
;
incompleteRegion
.
Sub
(
incompleteRegion
paintedLayer
-
>
GetValidRegion
(
)
)
;
if
(
!
incompleteRegion
.
IsEmpty
(
)
)
{
Matrix4x4
transformToScreen
=
layer
-
>
GetEffectiveTransform
(
)
;
transformToScreen
=
aTransform
*
transformToScreen
;
SubtractTransformedRegion
(
aScreenRegion
incompleteRegion
transformToScreen
)
;
TiledContentHost
*
composer
=
nullptr
;
LayerComposite
*
shadow
=
layer
-
>
AsLayerComposite
(
)
;
if
(
shadow
)
{
composer
=
shadow
-
>
GetCompositableHost
(
)
-
>
AsTiledContentHost
(
)
;
if
(
composer
)
{
incompleteRegion
.
Sub
(
incompleteRegion
composer
-
>
GetValidLowPrecisionRegion
(
)
)
;
if
(
!
incompleteRegion
.
IsEmpty
(
)
)
{
SubtractTransformedRegion
(
aLowPrecisionScreenRegion
incompleteRegion
transformToScreen
)
;
}
}
}
if
(
!
composer
)
{
SubtractTransformedRegion
(
aLowPrecisionScreenRegion
incompleteRegion
transformToScreen
)
;
}
}
return
TraversalFlag
:
:
Skip
;
}
)
;
}
#
ifdef
MOZ_WIDGET_ANDROID
static
float
GetDisplayportCoverage
(
const
CSSRect
&
aDisplayPort
const
Matrix4x4
&
aTransformToScreen
const
IntRect
&
aScreenRect
)
{
Rect
transformedDisplayport
=
aTransformToScreen
.
TransformBounds
(
aDisplayPort
.
ToUnknownRect
(
)
)
;
transformedDisplayport
.
RoundOut
(
)
;
IntRect
displayport
=
IntRect
(
transformedDisplayport
.
x
transformedDisplayport
.
y
transformedDisplayport
.
width
transformedDisplayport
.
height
)
;
if
(
!
displayport
.
Contains
(
aScreenRect
)
)
{
nsIntRegion
coveredRegion
;
coveredRegion
.
And
(
aScreenRect
displayport
)
;
return
coveredRegion
.
Area
(
)
/
(
float
)
(
aScreenRect
.
width
*
aScreenRect
.
height
)
;
}
return
1
.
0f
;
}
#
endif
float
LayerManagerComposite
:
:
ComputeRenderIntegrity
(
)
{
Layer
*
root
=
GetRoot
(
)
;
if
(
!
gfxPlatform
:
:
GetPlatform
(
)
-
>
UseProgressivePaint
(
)
|
|
!
root
)
{
return
1
.
f
;
}
FrameMetrics
rootMetrics
=
LayerMetricsWrapper
:
:
TopmostScrollableMetrics
(
root
)
;
if
(
!
rootMetrics
.
IsScrollable
(
)
)
{
rootMetrics
=
LayerMetricsWrapper
(
root
)
.
Metrics
(
)
;
}
ParentLayerIntRect
bounds
=
RoundedToInt
(
rootMetrics
.
GetCompositionBounds
(
)
)
;
IntRect
screenRect
(
bounds
.
x
bounds
.
y
bounds
.
width
bounds
.
height
)
;
float
lowPrecisionMultiplier
=
1
.
0f
;
float
highPrecisionMultiplier
=
1
.
0f
;
#
ifdef
MOZ_WIDGET_ANDROID
nsTArray
<
Layer
*
>
rootScrollableLayers
;
GetRootScrollableLayers
(
rootScrollableLayers
)
;
if
(
rootScrollableLayers
.
Length
(
)
>
0
)
{
Layer
*
rootScrollable
=
rootScrollableLayers
[
0
]
;
const
FrameMetrics
&
metrics
=
LayerMetricsWrapper
:
:
TopmostScrollableMetrics
(
rootScrollable
)
;
Matrix4x4
transform
=
rootScrollable
-
>
GetEffectiveTransform
(
)
;
transform
.
PostScale
(
metrics
.
GetPresShellResolution
(
)
metrics
.
GetPresShellResolution
(
)
1
)
;
Rect
documentBounds
=
transform
.
TransformBounds
(
Rect
(
metrics
.
GetScrollableRect
(
)
.
x
-
metrics
.
GetScrollOffset
(
)
.
x
metrics
.
GetScrollableRect
(
)
.
y
-
metrics
.
GetScrollOffset
(
)
.
y
metrics
.
GetScrollableRect
(
)
.
width
metrics
.
GetScrollableRect
(
)
.
height
)
)
;
documentBounds
.
RoundOut
(
)
;
screenRect
=
screenRect
.
Intersect
(
IntRect
(
documentBounds
.
x
documentBounds
.
y
documentBounds
.
width
documentBounds
.
height
)
)
;
if
(
screenRect
.
IsEmpty
(
)
)
{
return
1
.
0f
;
}
bool
hasLowPrecision
=
false
;
if
(
!
metrics
.
GetCriticalDisplayPort
(
)
.
IsEmpty
(
)
)
{
hasLowPrecision
=
true
;
highPrecisionMultiplier
=
GetDisplayportCoverage
(
metrics
.
GetCriticalDisplayPort
(
)
transform
screenRect
)
;
}
if
(
!
metrics
.
GetDisplayPort
(
)
.
IsEmpty
(
)
)
{
if
(
hasLowPrecision
)
{
lowPrecisionMultiplier
=
GetDisplayportCoverage
(
metrics
.
GetDisplayPort
(
)
transform
screenRect
)
;
}
else
{
lowPrecisionMultiplier
=
highPrecisionMultiplier
=
GetDisplayportCoverage
(
metrics
.
GetDisplayPort
(
)
transform
screenRect
)
;
}
}
}
if
(
highPrecisionMultiplier
<
=
0
.
0f
&
&
lowPrecisionMultiplier
<
=
0
.
0f
)
{
return
0
.
0f
;
}
#
endif
nsIntRegion
screenRegion
(
screenRect
)
;
nsIntRegion
lowPrecisionScreenRegion
(
screenRect
)
;
Matrix4x4
transform
;
ComputeRenderIntegrityInternal
(
root
screenRegion
lowPrecisionScreenRegion
transform
)
;
if
(
!
screenRegion
.
IsEqual
(
screenRect
)
)
{
float
screenArea
=
screenRect
.
width
*
screenRect
.
height
;
float
highPrecisionIntegrity
=
screenRegion
.
Area
(
)
/
screenArea
;
float
lowPrecisionIntegrity
=
1
.
f
;
if
(
!
lowPrecisionScreenRegion
.
IsEqual
(
screenRect
)
)
{
lowPrecisionIntegrity
=
lowPrecisionScreenRegion
.
Area
(
)
/
screenArea
;
}
return
(
(
highPrecisionIntegrity
*
highPrecisionMultiplier
)
+
(
lowPrecisionIntegrity
*
lowPrecisionMultiplier
)
)
/
2
;
}
return
1
.
f
;
}
already_AddRefed
<
PaintedLayerComposite
>
LayerManagerComposite
:
:
CreatePaintedLayerComposite
(
)
{
if
(
mDestroyed
)
{
NS_WARNING
(
"
Call
on
destroyed
layer
manager
"
)
;
return
nullptr
;
}
return
RefPtr
<
PaintedLayerComposite
>
(
new
PaintedLayerComposite
(
this
)
)
.
forget
(
)
;
}
already_AddRefed
<
ContainerLayerComposite
>
LayerManagerComposite
:
:
CreateContainerLayerComposite
(
)
{
if
(
mDestroyed
)
{
NS_WARNING
(
"
Call
on
destroyed
layer
manager
"
)
;
return
nullptr
;
}
return
RefPtr
<
ContainerLayerComposite
>
(
new
ContainerLayerComposite
(
this
)
)
.
forget
(
)
;
}
already_AddRefed
<
ImageLayerComposite
>
LayerManagerComposite
:
:
CreateImageLayerComposite
(
)
{
if
(
mDestroyed
)
{
NS_WARNING
(
"
Call
on
destroyed
layer
manager
"
)
;
return
nullptr
;
}
return
RefPtr
<
ImageLayerComposite
>
(
new
ImageLayerComposite
(
this
)
)
.
forget
(
)
;
}
already_AddRefed
<
ColorLayerComposite
>
LayerManagerComposite
:
:
CreateColorLayerComposite
(
)
{
if
(
LayerManagerComposite
:
:
mDestroyed
)
{
NS_WARNING
(
"
Call
on
destroyed
layer
manager
"
)
;
return
nullptr
;
}
return
RefPtr
<
ColorLayerComposite
>
(
new
ColorLayerComposite
(
this
)
)
.
forget
(
)
;
}
already_AddRefed
<
CanvasLayerComposite
>
LayerManagerComposite
:
:
CreateCanvasLayerComposite
(
)
{
if
(
LayerManagerComposite
:
:
mDestroyed
)
{
NS_WARNING
(
"
Call
on
destroyed
layer
manager
"
)
;
return
nullptr
;
}
return
RefPtr
<
CanvasLayerComposite
>
(
new
CanvasLayerComposite
(
this
)
)
.
forget
(
)
;
}
already_AddRefed
<
RefLayerComposite
>
LayerManagerComposite
:
:
CreateRefLayerComposite
(
)
{
if
(
LayerManagerComposite
:
:
mDestroyed
)
{
NS_WARNING
(
"
Call
on
destroyed
layer
manager
"
)
;
return
nullptr
;
}
return
RefPtr
<
RefLayerComposite
>
(
new
RefLayerComposite
(
this
)
)
.
forget
(
)
;
}
LayerManagerComposite
:
:
AutoAddMaskEffect
:
:
AutoAddMaskEffect
(
Layer
*
aMaskLayer
EffectChain
&
aEffects
)
:
mCompositable
(
nullptr
)
mFailed
(
false
)
{
if
(
!
aMaskLayer
)
{
return
;
}
mCompositable
=
ToLayerComposite
(
aMaskLayer
)
-
>
GetCompositableHost
(
)
;
if
(
!
mCompositable
)
{
NS_WARNING
(
"
Mask
layer
with
no
compositable
host
"
)
;
mFailed
=
true
;
return
;
}
if
(
!
mCompositable
-
>
AddMaskEffect
(
aEffects
aMaskLayer
-
>
GetEffectiveTransform
(
)
)
)
{
mCompositable
=
nullptr
;
mFailed
=
true
;
}
}
LayerManagerComposite
:
:
AutoAddMaskEffect
:
:
~
AutoAddMaskEffect
(
)
{
if
(
!
mCompositable
)
{
return
;
}
mCompositable
-
>
RemoveMaskEffect
(
)
;
}
void
LayerManagerComposite
:
:
ChangeCompositor
(
Compositor
*
aNewCompositor
)
{
mCompositor
=
aNewCompositor
;
mTextRenderer
=
new
TextRenderer
(
aNewCompositor
)
;
mTwoPassTmpTarget
=
nullptr
;
}
LayerComposite
:
:
LayerComposite
(
LayerManagerComposite
*
aManager
)
:
mCompositeManager
(
aManager
)
mCompositor
(
aManager
-
>
GetCompositor
(
)
)
mShadowOpacity
(
1
.
0
)
mShadowTransformSetByAnimation
(
false
)
mDestroyed
(
false
)
mLayerComposited
(
false
)
{
}
LayerComposite
:
:
~
LayerComposite
(
)
{
}
void
LayerComposite
:
:
Destroy
(
)
{
if
(
!
mDestroyed
)
{
mDestroyed
=
true
;
CleanupResources
(
)
;
}
}
void
LayerComposite
:
:
AddBlendModeEffect
(
EffectChain
&
aEffectChain
)
{
gfx
:
:
CompositionOp
blendMode
=
GetLayer
(
)
-
>
GetEffectiveMixBlendMode
(
)
;
if
(
blendMode
=
=
gfx
:
:
CompositionOp
:
:
OP_OVER
)
{
return
;
}
aEffectChain
.
mSecondaryEffects
[
EffectTypes
:
:
BLEND_MODE
]
=
new
EffectBlendMode
(
blendMode
)
;
return
;
}
bool
LayerManagerComposite
:
:
CanUseCanvasLayerForSize
(
const
IntSize
&
aSize
)
{
return
mCompositor
-
>
CanUseCanvasLayerForSize
(
gfx
:
:
IntSize
(
aSize
.
width
aSize
.
height
)
)
;
}
void
LayerManagerComposite
:
:
NotifyShadowTreeTransaction
(
)
{
if
(
mFPS
)
{
mFPS
-
>
NotifyShadowTreeTransaction
(
)
;
}
}
void
LayerComposite
:
:
SetLayerManager
(
LayerManagerComposite
*
aManager
)
{
mCompositeManager
=
aManager
;
mCompositor
=
aManager
-
>
GetCompositor
(
)
;
}
bool
LayerManagerComposite
:
:
AsyncPanZoomEnabled
(
)
const
{
if
(
CompositorBridgeParent
*
bridge
=
mCompositor
-
>
GetCompositorBridgeParent
(
)
)
{
return
bridge
-
>
AsyncPanZoomEnabled
(
)
;
}
return
false
;
}
nsIntRegion
LayerComposite
:
:
GetFullyRenderedRegion
(
)
{
if
(
TiledContentHost
*
tiled
=
GetCompositableHost
(
)
?
GetCompositableHost
(
)
-
>
AsTiledContentHost
(
)
:
nullptr
)
{
nsIntRegion
shadowVisibleRegion
=
GetShadowVisibleRegion
(
)
.
ToUnknownRegion
(
)
;
shadowVisibleRegion
.
And
(
shadowVisibleRegion
tiled
-
>
GetValidRegion
(
)
)
;
return
shadowVisibleRegion
;
}
else
{
return
GetShadowVisibleRegion
(
)
.
ToUnknownRegion
(
)
;
}
}
Matrix4x4
LayerComposite
:
:
GetShadowTransform
(
)
{
Matrix4x4
transform
=
mShadowTransform
;
Layer
*
layer
=
GetLayer
(
)
;
transform
.
PostScale
(
layer
-
>
GetPostXScale
(
)
layer
-
>
GetPostYScale
(
)
1
.
0f
)
;
if
(
const
ContainerLayer
*
c
=
layer
-
>
AsContainerLayer
(
)
)
{
transform
.
PreScale
(
c
-
>
GetPreXScale
(
)
c
-
>
GetPreYScale
(
)
1
.
0f
)
;
}
return
transform
;
}
bool
LayerComposite
:
:
HasStaleCompositor
(
)
const
{
return
mCompositeManager
-
>
GetCompositor
(
)
!
=
mCompositor
;
}
static
bool
LayerHasCheckerboardingAPZC
(
Layer
*
aLayer
Color
*
aOutColor
)
{
bool
answer
=
false
;
for
(
LayerMetricsWrapper
i
(
aLayer
LayerMetricsWrapper
:
:
StartAt
:
:
BOTTOM
)
;
i
;
i
=
i
.
GetParent
(
)
)
{
if
(
!
i
.
Metrics
(
)
.
IsScrollable
(
)
)
{
continue
;
}
if
(
i
.
GetApzc
(
)
&
&
i
.
GetApzc
(
)
-
>
IsCurrentlyCheckerboarding
(
)
)
{
if
(
aOutColor
)
{
*
aOutColor
=
i
.
Metadata
(
)
.
GetBackgroundColor
(
)
;
}
answer
=
true
;
break
;
}
break
;
}
return
answer
;
}
bool
LayerComposite
:
:
NeedToDrawCheckerboarding
(
gfx
:
:
Color
*
aOutCheckerboardingColor
)
{
return
GetLayer
(
)
-
>
Manager
(
)
-
>
AsyncPanZoomEnabled
(
)
&
&
(
GetLayer
(
)
-
>
GetContentFlags
(
)
&
Layer
:
:
CONTENT_OPAQUE
)
&
&
GetLayer
(
)
-
>
IsOpaqueForVisibility
(
)
&
&
LayerHasCheckerboardingAPZC
(
GetLayer
(
)
aOutCheckerboardingColor
)
;
}
#
ifndef
MOZ_HAVE_PLATFORM_SPECIFIC_LAYER_BUFFERS
bool
LayerManagerComposite
:
:
SupportsDirectTexturing
(
)
{
return
false
;
}
void
LayerManagerComposite
:
:
PlatformSyncBeforeReplyUpdate
(
)
{
}
#
endif
}
}
