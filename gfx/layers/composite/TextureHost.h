#
ifndef
MOZILLA_GFX_TEXTUREHOST_H
#
define
MOZILLA_GFX_TEXTUREHOST_H
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
gfxTypes
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
FenceUtils
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsTraceRefcnt
.
h
"
#
include
"
nscore
.
h
"
#
include
"
mozilla
/
layers
/
AtomicRefCountedWithFinalize
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
namespace
mozilla
{
namespace
ipc
{
class
Shmem
;
}
namespace
layers
{
class
BufferDescriptor
;
class
BufferTextureHost
;
class
Compositor
;
class
CompositableParentManager
;
class
ReadLockDescriptor
;
class
CompositorBridgeParent
;
class
SurfaceDescriptor
;
class
HostIPCAllocator
;
class
ISurfaceAllocator
;
class
TextureHostOGL
;
class
TextureReadLock
;
class
TextureSourceOGL
;
class
TextureSourceD3D9
;
class
TextureSourceD3D11
;
class
TextureSourceBasic
;
class
DataTextureSource
;
class
PTextureParent
;
class
TextureParent
;
class
WrappingTextureSourceYCbCrBasic
;
class
BigImageIterator
{
public
:
virtual
void
BeginBigImageIteration
(
)
=
0
;
virtual
void
EndBigImageIteration
(
)
{
}
;
virtual
gfx
:
:
IntRect
GetTileRect
(
)
=
0
;
virtual
size_t
GetTileCount
(
)
=
0
;
virtual
bool
NextTile
(
)
=
0
;
}
;
class
TextureSource
:
public
RefCounted
<
TextureSource
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
TextureSource
)
TextureSource
(
)
;
virtual
~
TextureSource
(
)
;
virtual
const
char
*
Name
(
)
const
=
0
;
virtual
void
DeallocateDeviceData
(
)
{
}
virtual
gfx
:
:
IntSize
GetSize
(
)
const
=
0
;
virtual
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
{
return
gfx
:
:
SurfaceFormat
:
:
UNKNOWN
;
}
virtual
TextureSourceOGL
*
AsSourceOGL
(
)
{
gfxCriticalNote
<
<
"
Failed
to
cast
"
<
<
Name
(
)
<
<
"
into
a
TextureSourceOGL
"
;
return
nullptr
;
}
virtual
TextureSourceD3D9
*
AsSourceD3D9
(
)
{
return
nullptr
;
}
virtual
TextureSourceD3D11
*
AsSourceD3D11
(
)
{
return
nullptr
;
}
virtual
TextureSourceBasic
*
AsSourceBasic
(
)
{
return
nullptr
;
}
virtual
DataTextureSource
*
AsDataTextureSource
(
)
{
return
nullptr
;
}
virtual
WrappingTextureSourceYCbCrBasic
*
AsWrappingTextureSourceYCbCrBasic
(
)
{
return
nullptr
;
}
virtual
BigImageIterator
*
AsBigImageIterator
(
)
{
return
nullptr
;
}
virtual
void
SetCompositor
(
Compositor
*
aCompositor
)
{
}
virtual
void
Unbind
(
)
{
}
void
SetNextSibling
(
TextureSource
*
aTexture
)
{
mNextSibling
=
aTexture
;
}
TextureSource
*
GetNextSibling
(
)
const
{
return
mNextSibling
;
}
TextureSource
*
GetSubSource
(
int
index
)
{
switch
(
index
)
{
case
0
:
return
this
;
case
1
:
return
GetNextSibling
(
)
;
case
2
:
return
GetNextSibling
(
)
?
GetNextSibling
(
)
-
>
GetNextSibling
(
)
:
nullptr
;
}
return
nullptr
;
}
void
AddCompositableRef
(
)
{
+
+
mCompositableCount
;
}
void
ReleaseCompositableRef
(
)
{
-
-
mCompositableCount
;
MOZ_ASSERT
(
mCompositableCount
>
=
0
)
;
}
int
NumCompositableRefs
(
)
const
{
return
mCompositableCount
;
}
protected
:
RefPtr
<
TextureSource
>
mNextSibling
;
int
mCompositableCount
;
}
;
template
<
typename
T
>
class
CompositableTextureRef
{
public
:
CompositableTextureRef
(
)
{
}
explicit
CompositableTextureRef
(
const
CompositableTextureRef
&
aOther
)
{
*
this
=
aOther
;
}
explicit
CompositableTextureRef
(
T
*
aOther
)
{
*
this
=
aOther
;
}
~
CompositableTextureRef
(
)
{
if
(
mRef
)
{
mRef
-
>
ReleaseCompositableRef
(
)
;
}
}
CompositableTextureRef
&
operator
=
(
const
CompositableTextureRef
&
aOther
)
{
if
(
aOther
.
get
(
)
)
{
aOther
-
>
AddCompositableRef
(
)
;
}
if
(
mRef
)
{
mRef
-
>
ReleaseCompositableRef
(
)
;
}
mRef
=
aOther
.
get
(
)
;
return
*
this
;
}
CompositableTextureRef
&
operator
=
(
T
*
aOther
)
{
if
(
aOther
)
{
aOther
-
>
AddCompositableRef
(
)
;
}
if
(
mRef
)
{
mRef
-
>
ReleaseCompositableRef
(
)
;
}
mRef
=
aOther
;
return
*
this
;
}
T
*
get
(
)
const
{
return
mRef
;
}
operator
T
*
(
)
const
{
return
mRef
;
}
T
*
operator
-
>
(
)
const
{
return
mRef
;
}
T
&
operator
*
(
)
const
{
return
*
mRef
;
}
private
:
RefPtr
<
T
>
mRef
;
}
;
typedef
CompositableTextureRef
<
TextureSource
>
CompositableTextureSourceRef
;
typedef
CompositableTextureRef
<
TextureHost
>
CompositableTextureHostRef
;
class
DataTextureSource
:
public
TextureSource
{
public
:
DataTextureSource
(
)
:
mOwner
(
0
)
mUpdateSerial
(
0
)
{
}
virtual
const
char
*
Name
(
)
const
override
{
return
"
DataTextureSource
"
;
}
virtual
DataTextureSource
*
AsDataTextureSource
(
)
override
{
return
this
;
}
virtual
bool
Update
(
gfx
:
:
DataSourceSurface
*
aSurface
nsIntRegion
*
aDestRegion
=
nullptr
gfx
:
:
IntPoint
*
aSrcOffset
=
nullptr
)
=
0
;
uint32_t
GetUpdateSerial
(
)
const
{
return
mUpdateSerial
;
}
void
SetUpdateSerial
(
uint32_t
aValue
)
{
mUpdateSerial
=
aValue
;
}
virtual
void
DeallocateDeviceData
(
)
override
{
SetUpdateSerial
(
0
)
;
}
#
ifdef
DEBUG
virtual
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
ReadBack
(
)
{
return
nullptr
;
}
;
#
endif
void
SetOwner
(
TextureHost
*
aOwner
)
{
auto
newOwner
=
(
uintptr_t
)
aOwner
;
if
(
newOwner
!
=
mOwner
)
{
mOwner
=
newOwner
;
SetUpdateSerial
(
0
)
;
}
}
bool
IsOwnedBy
(
TextureHost
*
aOwner
)
const
{
return
mOwner
=
=
(
uintptr_t
)
aOwner
;
}
bool
HasOwner
(
)
const
{
return
!
IsOwnedBy
(
nullptr
)
;
}
private
:
uintptr_t
mOwner
;
uint32_t
mUpdateSerial
;
}
;
class
TextureHost
:
public
AtomicRefCountedWithFinalize
<
TextureHost
>
{
void
Finalize
(
)
;
friend
class
AtomicRefCountedWithFinalize
<
TextureHost
>
;
public
:
explicit
TextureHost
(
TextureFlags
aFlags
)
;
protected
:
virtual
~
TextureHost
(
)
;
public
:
static
already_AddRefed
<
TextureHost
>
Create
(
const
SurfaceDescriptor
&
aDesc
ISurfaceAllocator
*
aDeallocator
LayersBackend
aBackend
TextureFlags
aFlags
)
;
virtual
bool
Lock
(
)
{
return
true
;
}
virtual
void
Unlock
(
)
{
}
virtual
bool
LockWithoutCompositor
(
)
{
return
true
;
}
virtual
void
UnlockWithoutCompositor
(
)
{
}
virtual
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
=
0
;
virtual
gfx
:
:
SurfaceFormat
GetReadFormat
(
)
const
{
return
GetFormat
(
)
;
}
virtual
YUVColorSpace
GetYUVColorSpace
(
)
const
{
return
YUVColorSpace
:
:
UNKNOWN
;
}
virtual
void
PrepareTextureSource
(
CompositableTextureSourceRef
&
aTexture
)
{
}
virtual
bool
BindTextureSource
(
CompositableTextureSourceRef
&
aTexture
)
=
0
;
virtual
void
UnbindTextureSource
(
)
;
void
Updated
(
const
nsIntRegion
*
aRegion
=
nullptr
)
;
virtual
void
SetCompositor
(
Compositor
*
aCompositor
)
{
}
virtual
void
DeallocateDeviceData
(
)
{
}
virtual
void
DeallocateSharedData
(
)
{
}
virtual
void
ForgetSharedData
(
)
{
}
virtual
gfx
:
:
IntSize
GetSize
(
)
const
=
0
;
virtual
void
SetCropRect
(
nsIntRect
aCropRect
)
{
}
virtual
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
GetAsSurface
(
)
=
0
;
void
SetFlags
(
TextureFlags
aFlags
)
{
mFlags
=
aFlags
;
}
void
AddFlag
(
TextureFlags
aFlag
)
{
mFlags
|
=
aFlag
;
}
TextureFlags
GetFlags
(
)
{
return
mFlags
;
}
static
PTextureParent
*
CreateIPDLActor
(
HostIPCAllocator
*
aAllocator
const
SurfaceDescriptor
&
aSharedData
LayersBackend
aLayersBackend
TextureFlags
aFlags
uint64_t
aSerial
)
;
static
bool
DestroyIPDLActor
(
PTextureParent
*
actor
)
;
static
bool
SendDeleteIPDLActor
(
PTextureParent
*
actor
)
;
static
void
ReceivedDestroy
(
PTextureParent
*
actor
)
;
static
TextureHost
*
AsTextureHost
(
PTextureParent
*
actor
)
;
static
uint64_t
GetTextureSerial
(
PTextureParent
*
actor
)
;
PTextureParent
*
GetIPDLActor
(
)
;
virtual
LayerRenderState
GetRenderState
(
)
{
return
LayerRenderState
(
)
;
}
virtual
void
OnShutdown
(
)
{
}
virtual
void
ForgetBufferActor
(
)
{
}
virtual
const
char
*
Name
(
)
{
return
"
TextureHost
"
;
}
virtual
void
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
;
virtual
bool
HasIntermediateBuffer
(
)
const
{
return
false
;
}
void
AddCompositableRef
(
)
{
+
+
mCompositableCount
;
}
void
ReleaseCompositableRef
(
)
{
-
-
mCompositableCount
;
MOZ_ASSERT
(
mCompositableCount
>
=
0
)
;
if
(
mCompositableCount
=
=
0
)
{
UnbindTextureSource
(
)
;
NotifyNotUsed
(
)
;
}
}
int
NumCompositableRefs
(
)
const
{
return
mCompositableCount
;
}
void
SetLastFwdTransactionId
(
uint64_t
aTransactionId
)
;
void
DeserializeReadLock
(
const
ReadLockDescriptor
&
aDesc
ISurfaceAllocator
*
aAllocator
)
;
TextureReadLock
*
GetReadLock
(
)
{
return
mReadLock
;
}
virtual
Compositor
*
GetCompositor
(
)
=
0
;
virtual
BufferTextureHost
*
AsBufferTextureHost
(
)
{
return
nullptr
;
}
protected
:
void
ReadUnlock
(
)
;
void
RecycleTexture
(
TextureFlags
aFlags
)
;
virtual
void
UpdatedInternal
(
const
nsIntRegion
*
Region
)
{
}
void
NotifyNotUsed
(
)
;
void
CallNotifyNotUsed
(
)
;
PTextureParent
*
mActor
;
RefPtr
<
TextureReadLock
>
mReadLock
;
TextureFlags
mFlags
;
int
mCompositableCount
;
uint64_t
mFwdTransactionId
;
friend
class
Compositor
;
friend
class
TextureParent
;
friend
class
TiledLayerBufferComposite
;
}
;
class
BufferTextureHost
:
public
TextureHost
{
public
:
BufferTextureHost
(
const
BufferDescriptor
&
aDescriptor
TextureFlags
aFlags
)
;
~
BufferTextureHost
(
)
;
virtual
uint8_t
*
GetBuffer
(
)
=
0
;
virtual
size_t
GetBufferSize
(
)
=
0
;
virtual
bool
Lock
(
)
override
;
virtual
void
Unlock
(
)
override
;
virtual
void
PrepareTextureSource
(
CompositableTextureSourceRef
&
aTexture
)
override
;
virtual
bool
BindTextureSource
(
CompositableTextureSourceRef
&
aTexture
)
override
;
virtual
void
UnbindTextureSource
(
)
override
;
virtual
void
DeallocateDeviceData
(
)
override
;
virtual
void
SetCompositor
(
Compositor
*
aCompositor
)
override
;
virtual
Compositor
*
GetCompositor
(
)
override
{
return
mCompositor
;
}
virtual
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
override
;
virtual
YUVColorSpace
GetYUVColorSpace
(
)
const
override
;
virtual
gfx
:
:
IntSize
GetSize
(
)
const
override
{
return
mSize
;
}
virtual
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
GetAsSurface
(
)
override
;
virtual
bool
HasIntermediateBuffer
(
)
const
override
{
return
mHasIntermediateBuffer
;
}
virtual
BufferTextureHost
*
AsBufferTextureHost
(
)
override
{
return
this
;
}
const
BufferDescriptor
&
GetBufferDescriptor
(
)
const
{
return
mDescriptor
;
}
protected
:
bool
Upload
(
nsIntRegion
*
aRegion
=
nullptr
)
;
bool
MaybeUpload
(
nsIntRegion
*
aRegion
=
nullptr
)
;
bool
EnsureWrappingTextureSource
(
)
;
virtual
void
UpdatedInternal
(
const
nsIntRegion
*
aRegion
=
nullptr
)
override
;
BufferDescriptor
mDescriptor
;
RefPtr
<
Compositor
>
mCompositor
;
RefPtr
<
DataTextureSource
>
mFirstSource
;
nsIntRegion
mMaybeUpdatedRegion
;
gfx
:
:
IntSize
mSize
;
gfx
:
:
SurfaceFormat
mFormat
;
uint32_t
mUpdateSerial
;
bool
mLocked
;
bool
mNeedsFullUpdate
;
bool
mHasIntermediateBuffer
;
class
DataTextureSourceYCbCrBasic
;
}
;
class
ShmemTextureHost
:
public
BufferTextureHost
{
public
:
ShmemTextureHost
(
const
mozilla
:
:
ipc
:
:
Shmem
&
aShmem
const
BufferDescriptor
&
aDesc
ISurfaceAllocator
*
aDeallocator
TextureFlags
aFlags
)
;
protected
:
~
ShmemTextureHost
(
)
;
public
:
virtual
void
DeallocateSharedData
(
)
override
;
virtual
void
ForgetSharedData
(
)
override
;
virtual
uint8_t
*
GetBuffer
(
)
override
;
virtual
size_t
GetBufferSize
(
)
override
;
virtual
const
char
*
Name
(
)
override
{
return
"
ShmemTextureHost
"
;
}
virtual
void
OnShutdown
(
)
override
;
protected
:
UniquePtr
<
mozilla
:
:
ipc
:
:
Shmem
>
mShmem
;
RefPtr
<
ISurfaceAllocator
>
mDeallocator
;
}
;
class
MemoryTextureHost
:
public
BufferTextureHost
{
public
:
MemoryTextureHost
(
uint8_t
*
aBuffer
const
BufferDescriptor
&
aDesc
TextureFlags
aFlags
)
;
protected
:
~
MemoryTextureHost
(
)
;
public
:
virtual
void
DeallocateSharedData
(
)
override
;
virtual
void
ForgetSharedData
(
)
override
;
virtual
uint8_t
*
GetBuffer
(
)
override
;
virtual
size_t
GetBufferSize
(
)
override
;
virtual
const
char
*
Name
(
)
override
{
return
"
MemoryTextureHost
"
;
}
protected
:
uint8_t
*
mBuffer
;
}
;
class
MOZ_STACK_CLASS
AutoLockTextureHost
{
public
:
explicit
AutoLockTextureHost
(
TextureHost
*
aTexture
)
:
mTexture
(
aTexture
)
{
mLocked
=
mTexture
?
mTexture
-
>
Lock
(
)
:
false
;
}
~
AutoLockTextureHost
(
)
{
if
(
mTexture
&
&
mLocked
)
{
mTexture
-
>
Unlock
(
)
;
}
}
bool
Failed
(
)
{
return
mTexture
&
&
!
mLocked
;
}
private
:
RefPtr
<
TextureHost
>
mTexture
;
bool
mLocked
;
}
;
class
MOZ_STACK_CLASS
AutoLockTextureHostWithoutCompositor
{
public
:
explicit
AutoLockTextureHostWithoutCompositor
(
TextureHost
*
aTexture
)
:
mTexture
(
aTexture
)
{
mLocked
=
mTexture
?
mTexture
-
>
LockWithoutCompositor
(
)
:
false
;
}
~
AutoLockTextureHostWithoutCompositor
(
)
{
if
(
mTexture
&
&
mLocked
)
{
mTexture
-
>
UnlockWithoutCompositor
(
)
;
}
}
bool
Failed
(
)
{
return
mTexture
&
&
!
mLocked
;
}
private
:
RefPtr
<
TextureHost
>
mTexture
;
bool
mLocked
;
}
;
class
CompositingRenderTarget
:
public
TextureSource
{
public
:
explicit
CompositingRenderTarget
(
const
gfx
:
:
IntPoint
&
aOrigin
)
:
mClearOnBind
(
false
)
mOrigin
(
aOrigin
)
mHasComplexProjection
(
false
)
{
}
virtual
~
CompositingRenderTarget
(
)
{
}
virtual
const
char
*
Name
(
)
const
override
{
return
"
CompositingRenderTarget
"
;
}
#
ifdef
MOZ_DUMP_PAINTING
virtual
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
Dump
(
Compositor
*
aCompositor
)
{
return
nullptr
;
}
#
endif
void
ClearOnBind
(
)
{
mClearOnBind
=
true
;
}
const
gfx
:
:
IntPoint
&
GetOrigin
(
)
const
{
return
mOrigin
;
}
gfx
:
:
IntRect
GetRect
(
)
{
return
gfx
:
:
IntRect
(
GetOrigin
(
)
GetSize
(
)
)
;
}
bool
HasComplexProjection
(
)
const
{
return
mHasComplexProjection
;
}
void
ClearProjection
(
)
{
mHasComplexProjection
=
false
;
}
void
SetProjection
(
const
gfx
:
:
Matrix4x4
&
aNewMatrix
bool
aEnableDepthBuffer
float
aZNear
float
aZFar
)
{
mProjectionMatrix
=
aNewMatrix
;
mEnableDepthBuffer
=
aEnableDepthBuffer
;
mZNear
=
aZNear
;
mZFar
=
aZFar
;
mHasComplexProjection
=
true
;
}
void
GetProjection
(
gfx
:
:
Matrix4x4
&
aMatrix
bool
&
aEnableDepth
float
&
aZNear
float
&
aZFar
)
{
MOZ_ASSERT
(
mHasComplexProjection
)
;
aMatrix
=
mProjectionMatrix
;
aEnableDepth
=
mEnableDepthBuffer
;
aZNear
=
mZNear
;
aZFar
=
mZFar
;
}
protected
:
bool
mClearOnBind
;
private
:
gfx
:
:
IntPoint
mOrigin
;
gfx
:
:
Matrix4x4
mProjectionMatrix
;
float
mZNear
mZFar
;
bool
mHasComplexProjection
;
bool
mEnableDepthBuffer
;
}
;
already_AddRefed
<
TextureHost
>
CreateBackendIndependentTextureHost
(
const
SurfaceDescriptor
&
aDesc
ISurfaceAllocator
*
aDeallocator
TextureFlags
aFlags
)
;
}
}
#
endif
