#
include
"
ContainerLayerComposite
.
h
"
#
include
<
algorithm
>
#
include
"
apz
/
src
/
AsyncPanZoomController
.
h
"
#
include
"
FrameMetrics
.
h
"
#
include
"
Units
.
h
"
#
include
"
gfxEnv
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
gfx
/
BaseRect
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
Effects
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
mozilla
/
layers
/
AsyncCompositionManager
.
h
"
#
include
"
mozilla
/
layers
/
LayerMetricsWrapper
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
TextRenderer
.
h
"
#
include
<
vector
>
#
include
"
VRManager
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
ifdef
MOZ_ENABLE_PROFILER_SPS
#
include
"
ProfilerMarkers
.
h
"
#
endif
#
define
CULLING_LOG
(
.
.
.
)
#
define
DUMP
(
.
.
.
)
do
{
if
(
gfxEnv
:
:
DumpDebug
(
)
)
{
printf_stderr
(
__VA_ARGS__
)
;
}
}
while
(
0
)
#
define
XYWH
(
k
)
(
k
)
.
x
(
k
)
.
y
(
k
)
.
width
(
k
)
.
height
#
define
XY
(
k
)
(
k
)
.
x
(
k
)
.
y
#
define
WH
(
k
)
(
k
)
.
width
(
k
)
.
height
namespace
mozilla
{
namespace
layers
{
using
namespace
gfx
;
static
bool
LayerHasCheckerboardingAPZC
(
Layer
*
aLayer
Color
*
aOutColor
)
{
for
(
LayerMetricsWrapper
i
(
aLayer
LayerMetricsWrapper
:
:
StartAt
:
:
BOTTOM
)
;
i
;
i
=
i
.
GetParent
(
)
)
{
if
(
!
i
.
Metrics
(
)
.
IsScrollable
(
)
)
{
continue
;
}
if
(
i
.
GetApzc
(
)
&
&
i
.
GetApzc
(
)
-
>
IsCurrentlyCheckerboarding
(
)
)
{
if
(
aOutColor
)
{
*
aOutColor
=
i
.
Metrics
(
)
.
GetBackgroundColor
(
)
;
}
return
true
;
}
break
;
}
return
false
;
}
static
void
DrawLayerInfo
(
const
RenderTargetIntRect
&
aClipRect
LayerManagerComposite
*
aManager
Layer
*
aLayer
)
{
if
(
aLayer
-
>
GetType
(
)
=
=
Layer
:
:
LayerType
:
:
TYPE_CONTAINER
)
{
return
;
}
std
:
:
stringstream
ss
;
aLayer
-
>
PrintInfo
(
ss
"
"
)
;
LayerIntRegion
visibleRegion
=
aLayer
-
>
GetVisibleRegion
(
)
;
uint32_t
maxWidth
=
std
:
:
min
<
uint32_t
>
(
visibleRegion
.
GetBounds
(
)
.
width
500
)
;
IntPoint
topLeft
=
visibleRegion
.
ToUnknownRegion
(
)
.
GetBounds
(
)
.
TopLeft
(
)
;
aManager
-
>
GetTextRenderer
(
)
-
>
RenderText
(
ss
.
str
(
)
.
c_str
(
)
topLeft
aLayer
-
>
GetEffectiveTransform
(
)
16
maxWidth
)
;
}
template
<
class
ContainerT
>
static
gfx
:
:
IntRect
ContainerVisibleRect
(
ContainerT
*
aContainer
)
{
gfx
:
:
IntRect
surfaceRect
=
aContainer
-
>
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
.
GetBounds
(
)
;
return
surfaceRect
;
}
static
void
PrintUniformityInfo
(
Layer
*
aLayer
)
{
#
ifdef
MOZ_ENABLE_PROFILER_SPS
if
(
!
profiler_is_active
(
)
)
{
return
;
}
if
(
aLayer
-
>
GetLocalVisibleRegion
(
)
.
GetBounds
(
)
.
width
<
300
|
|
aLayer
-
>
GetLocalVisibleRegion
(
)
.
GetBounds
(
)
.
height
<
300
)
{
return
;
}
Matrix4x4
transform
=
aLayer
-
>
AsLayerComposite
(
)
-
>
GetShadowTransform
(
)
;
if
(
!
transform
.
Is2D
(
)
)
{
return
;
}
Point
translation
=
transform
.
As2D
(
)
.
GetTranslation
(
)
;
LayerTranslationPayload
*
payload
=
new
LayerTranslationPayload
(
aLayer
translation
)
;
PROFILER_MARKER_PAYLOAD
(
"
LayerTranslation
"
payload
)
;
#
endif
}
struct
PreparedLayer
{
PreparedLayer
(
LayerComposite
*
aLayer
RenderTargetIntRect
aClipRect
)
:
mLayer
(
aLayer
)
mClipRect
(
aClipRect
)
{
}
LayerComposite
*
mLayer
;
RenderTargetIntRect
mClipRect
;
}
;
template
<
class
ContainerT
>
void
ContainerRenderVR
(
ContainerT
*
aContainer
LayerManagerComposite
*
aManager
const
gfx
:
:
IntRect
&
aClipRect
RefPtr
<
gfx
:
:
VRHMDInfo
>
aHMD
int32_t
aInputFrameID
)
{
int32_t
inputFrameID
=
-
1
;
RefPtr
<
CompositingRenderTarget
>
surface
;
Compositor
*
compositor
=
aManager
-
>
GetCompositor
(
)
;
RefPtr
<
CompositingRenderTarget
>
previousTarget
=
compositor
-
>
GetCurrentRenderTarget
(
)
;
float
opacity
=
aContainer
-
>
GetEffectiveOpacity
(
)
;
gfx
:
:
IntSize
eyeResolution
=
aHMD
-
>
GetDeviceInfo
(
)
.
SuggestedEyeResolution
(
)
;
gfx
:
:
IntRect
eyeRect
[
2
]
;
eyeRect
[
0
]
=
gfx
:
:
IntRect
(
0
0
eyeResolution
.
width
eyeResolution
.
height
)
;
eyeRect
[
1
]
=
gfx
:
:
IntRect
(
eyeResolution
.
width
0
eyeResolution
.
width
eyeResolution
.
height
)
;
gfx
:
:
IntRect
surfaceRect
=
gfx
:
:
IntRect
(
0
0
eyeResolution
.
width
*
2
eyeResolution
.
height
)
;
int32_t
maxTextureSize
=
compositor
-
>
GetMaxTextureSize
(
)
;
surfaceRect
.
width
=
std
:
:
min
(
maxTextureSize
surfaceRect
.
width
)
;
surfaceRect
.
height
=
std
:
:
min
(
maxTextureSize
surfaceRect
.
height
)
;
gfx
:
:
VRHMDRenderingSupport
*
vrRendering
=
aHMD
-
>
GetRenderingSupport
(
)
;
if
(
gfxEnv
:
:
NoVRRendering
(
)
)
vrRendering
=
nullptr
;
if
(
vrRendering
)
{
if
(
!
aContainer
-
>
mVRRenderTargetSet
|
|
aContainer
-
>
mVRRenderTargetSet
-
>
size
!
=
surfaceRect
.
Size
(
)
)
{
aContainer
-
>
mVRRenderTargetSet
=
vrRendering
-
>
CreateRenderTargetSet
(
compositor
surfaceRect
.
Size
(
)
)
;
}
if
(
!
aContainer
-
>
mVRRenderTargetSet
)
{
NS_WARNING
(
"
CreateRenderTargetSet
failed
"
)
;
return
;
}
surface
=
aContainer
-
>
mVRRenderTargetSet
-
>
GetNextRenderTarget
(
)
;
if
(
!
surface
)
{
NS_WARNING
(
"
GetNextRenderTarget
failed
"
)
;
return
;
}
}
else
{
surface
=
compositor
-
>
CreateRenderTarget
(
surfaceRect
INIT_MODE_CLEAR
)
;
if
(
!
surface
)
{
return
;
}
}
gfx
:
:
IntRect
rtBounds
=
previousTarget
-
>
GetRect
(
)
;
DUMP
(
"
eyeResolution
:
%
d
%
d
targetRT
:
%
d
%
d
%
d
%
d
\
n
"
WH
(
eyeResolution
)
XYWH
(
rtBounds
)
)
;
compositor
-
>
SetRenderTarget
(
surface
)
;
AutoTArray
<
Layer
*
12
>
children
;
aContainer
-
>
SortChildrenBy3DZOrder
(
children
)
;
gfx
:
:
Matrix4x4
origTransform
=
aContainer
-
>
GetEffectiveTransform
(
)
;
for
(
uint32_t
i
=
0
;
i
<
children
.
Length
(
)
;
i
+
+
)
{
LayerComposite
*
layerToRender
=
static_cast
<
LayerComposite
*
>
(
children
.
ElementAt
(
i
)
-
>
ImplData
(
)
)
;
Layer
*
layer
=
layerToRender
-
>
GetLayer
(
)
;
uint32_t
contentFlags
=
layer
-
>
GetContentFlags
(
)
;
if
(
layer
-
>
IsBackfaceHidden
(
)
)
{
continue
;
}
if
(
!
layer
-
>
IsVisible
(
)
&
&
!
layer
-
>
AsContainerLayer
(
)
)
{
continue
;
}
if
(
(
contentFlags
&
Layer
:
:
CONTENT_EXTEND_3D_CONTEXT
)
=
=
0
)
{
DUMP
(
"
%
p
Switching
to
pre
-
rendered
VR
\
n
"
aContainer
)
;
compositor
-
>
SetRenderTarget
(
surface
)
;
aContainer
-
>
ReplaceEffectiveTransform
(
origTransform
)
;
Rect
layerBounds
;
if
(
layer
-
>
GetType
(
)
=
=
Layer
:
:
TYPE_CANVAS
)
{
layerBounds
=
IntRectToRect
(
static_cast
<
CanvasLayer
*
>
(
layer
)
-
>
GetBounds
(
)
)
;
}
else
{
layerBounds
=
IntRectToRect
(
layer
-
>
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
.
GetBounds
(
)
)
;
}
const
gfx
:
:
Matrix4x4
childTransform
=
layer
-
>
GetEffectiveTransform
(
)
;
layerBounds
=
childTransform
.
TransformBounds
(
layerBounds
)
;
DUMP
(
"
layer
%
p
[
type
%
d
]
bounds
[
%
f
%
f
%
f
%
f
]
surfaceRect
[
%
d
%
d
%
d
%
d
]
\
n
"
layer
(
int
)
layer
-
>
GetType
(
)
XYWH
(
layerBounds
)
XYWH
(
surfaceRect
)
)
;
bool
restoreTransform
=
false
;
if
(
(
layerBounds
.
width
!
=
0
&
&
layerBounds
.
height
!
=
0
)
&
&
(
layerBounds
.
width
!
=
surfaceRect
.
width
|
|
layerBounds
.
height
!
=
surfaceRect
.
height
)
)
{
DUMP
(
"
layer
%
p
doesn
'
t
match
prescaling
by
%
f
%
f
\
n
"
layer
surfaceRect
.
width
/
float
(
layerBounds
.
width
)
surfaceRect
.
height
/
float
(
layerBounds
.
height
)
)
;
gfx
:
:
Matrix4x4
scaledChildTransform
(
childTransform
)
;
scaledChildTransform
.
PreScale
(
surfaceRect
.
width
/
layerBounds
.
width
surfaceRect
.
height
/
layerBounds
.
height
1
.
0f
)
;
layer
-
>
ReplaceEffectiveTransform
(
scaledChildTransform
)
;
restoreTransform
=
true
;
}
layerToRender
-
>
Prepare
(
RenderTargetIntRect
(
surfaceRect
.
x
surfaceRect
.
y
surfaceRect
.
width
surfaceRect
.
height
)
)
;
layerToRender
-
>
RenderLayer
(
surfaceRect
)
;
CompositableHost
*
ch
=
layerToRender
-
>
GetCompositableHost
(
)
;
if
(
ch
)
{
int32_t
compositableInputFrameID
=
ch
-
>
GetLastInputFrameID
(
)
;
if
(
compositableInputFrameID
!
=
-
1
)
{
inputFrameID
=
compositableInputFrameID
;
}
}
if
(
restoreTransform
)
{
layer
-
>
ReplaceEffectiveTransform
(
childTransform
)
;
}
}
else
{
}
}
DUMP
(
"
-
-
ContainerRenderVR
[
%
p
]
after
child
layers
\
n
"
aContainer
)
;
aContainer
-
>
ReplaceEffectiveTransform
(
origTransform
)
;
compositor
-
>
SetRenderTarget
(
previousTarget
)
;
if
(
vrRendering
)
{
vrRendering
-
>
SubmitFrame
(
aContainer
-
>
mVRRenderTargetSet
inputFrameID
)
;
DUMP
(
"
<
<
<
ContainerRenderVR
[
used
vrRendering
]
[
%
p
]
\
n
"
aContainer
)
;
if
(
!
gfxPrefs
:
:
VRMirrorTextures
(
)
)
{
return
;
}
}
gfx
:
:
Rect
rect
(
surfaceRect
.
x
surfaceRect
.
y
surfaceRect
.
width
surfaceRect
.
height
)
;
gfx
:
:
Rect
clipRect
(
aClipRect
.
x
aClipRect
.
y
aClipRect
.
width
aClipRect
.
height
)
;
EffectChain
solidEffect
(
aContainer
)
;
solidEffect
.
mPrimaryEffect
=
new
EffectSolidColor
(
Color
(
0
.
0
0
.
0
0
.
0
1
.
0
)
)
;
aManager
-
>
GetCompositor
(
)
-
>
DrawQuad
(
rect
rect
solidEffect
1
.
0
gfx
:
:
Matrix4x4
(
)
)
;
EffectChain
vrEffect
(
aContainer
)
;
bool
skipDistortion
=
vrRendering
|
|
gfxEnv
:
:
VRNoDistortion
(
)
;
if
(
skipDistortion
)
{
vrEffect
.
mPrimaryEffect
=
new
EffectRenderTarget
(
surface
)
;
}
else
{
vrEffect
.
mPrimaryEffect
=
new
EffectVRDistortion
(
aHMD
surface
)
;
}
gfx
:
:
Matrix4x4
scaleTransform
=
aContainer
-
>
GetEffectiveTransform
(
)
;
scaleTransform
.
PreScale
(
rtBounds
.
width
/
float
(
surfaceRect
.
width
)
rtBounds
.
height
/
float
(
surfaceRect
.
height
)
1
.
0f
)
;
aManager
-
>
GetCompositor
(
)
-
>
DrawQuad
(
rect
clipRect
vrEffect
opacity
scaleTransform
)
;
DUMP
(
"
<
<
<
ContainerRenderVR
[
%
p
]
\
n
"
aContainer
)
;
}
static
bool
NeedToDrawCheckerboardingForLayer
(
Layer
*
aLayer
Color
*
aOutCheckerboardingColor
)
{
return
(
aLayer
-
>
GetContentFlags
(
)
&
Layer
:
:
CONTENT_OPAQUE
)
&
&
aLayer
-
>
IsOpaqueForVisibility
(
)
&
&
LayerHasCheckerboardingAPZC
(
aLayer
aOutCheckerboardingColor
)
;
}
struct
PreparedData
{
RefPtr
<
CompositingRenderTarget
>
mTmpTarget
;
AutoTArray
<
PreparedLayer
12
>
mLayers
;
bool
mNeedsSurfaceCopy
;
}
;
template
<
class
ContainerT
>
void
ContainerPrepare
(
ContainerT
*
aContainer
LayerManagerComposite
*
aManager
const
RenderTargetIntRect
&
aClipRect
)
{
aContainer
-
>
mPrepared
=
MakeUnique
<
PreparedData
>
(
)
;
aContainer
-
>
mPrepared
-
>
mNeedsSurfaceCopy
=
false
;
RefPtr
<
gfx
:
:
VRHMDInfo
>
hmdInfo
=
gfx
:
:
VRManager
:
:
Get
(
)
-
>
GetDevice
(
aContainer
-
>
GetVRDeviceID
(
)
)
;
if
(
hmdInfo
&
&
hmdInfo
-
>
GetConfiguration
(
)
.
IsValid
(
)
)
{
return
;
}
AutoTArray
<
Layer
*
12
>
children
;
aContainer
-
>
SortChildrenBy3DZOrder
(
children
)
;
for
(
uint32_t
i
=
0
;
i
<
children
.
Length
(
)
;
i
+
+
)
{
LayerComposite
*
layerToRender
=
static_cast
<
LayerComposite
*
>
(
children
.
ElementAt
(
i
)
-
>
ImplData
(
)
)
;
RenderTargetIntRect
clipRect
=
layerToRender
-
>
GetLayer
(
)
-
>
CalculateScissorRect
(
aClipRect
)
;
if
(
layerToRender
-
>
GetLayer
(
)
-
>
IsBackfaceHidden
(
)
)
{
continue
;
}
if
(
!
layerToRender
-
>
GetLayer
(
)
-
>
AsContainerLayer
(
)
)
{
if
(
!
layerToRender
-
>
GetLayer
(
)
-
>
IsVisible
(
)
&
&
!
NeedToDrawCheckerboardingForLayer
(
layerToRender
-
>
GetLayer
(
)
nullptr
)
)
{
CULLING_LOG
(
"
Sublayer
%
p
has
no
effective
visible
region
\
n
"
layerToRender
-
>
GetLayer
(
)
)
;
continue
;
}
if
(
clipRect
.
IsEmpty
(
)
)
{
CULLING_LOG
(
"
Sublayer
%
p
has
an
empty
world
clip
rect
\
n
"
layerToRender
-
>
GetLayer
(
)
)
;
continue
;
}
}
CULLING_LOG
(
"
Preparing
sublayer
%
p
\
n
"
layerToRender
-
>
GetLayer
(
)
)
;
layerToRender
-
>
Prepare
(
clipRect
)
;
aContainer
-
>
mPrepared
-
>
mLayers
.
AppendElement
(
PreparedLayer
(
layerToRender
clipRect
)
)
;
}
CULLING_LOG
(
"
Preparing
container
layer
%
p
\
n
"
aContainer
-
>
GetLayer
(
)
)
;
gfx
:
:
IntRect
surfaceRect
=
ContainerVisibleRect
(
aContainer
)
;
if
(
surfaceRect
.
IsEmpty
(
)
)
{
return
;
}
bool
surfaceCopyNeeded
;
aContainer
-
>
DefaultComputeSupportsComponentAlphaChildren
(
&
surfaceCopyNeeded
)
;
if
(
aContainer
-
>
UseIntermediateSurface
(
)
)
{
if
(
!
surfaceCopyNeeded
)
{
RefPtr
<
CompositingRenderTarget
>
surface
=
nullptr
;
RefPtr
<
CompositingRenderTarget
>
&
lastSurf
=
aContainer
-
>
mLastIntermediateSurface
;
if
(
lastSurf
&
&
!
aContainer
-
>
mChildrenChanged
&
&
lastSurf
-
>
GetRect
(
)
.
IsEqualEdges
(
surfaceRect
)
)
{
surface
=
lastSurf
;
}
if
(
!
surface
)
{
surface
=
CreateOrRecycleTarget
(
aContainer
aManager
)
;
MOZ_PERFORMANCE_WARNING
(
"
gfx
"
"
[
%
p
]
Container
layer
requires
intermediate
surface
rendering
\
n
"
aContainer
)
;
RenderIntermediate
(
aContainer
aManager
aClipRect
.
ToUnknownRect
(
)
surface
)
;
aContainer
-
>
SetChildrenChanged
(
false
)
;
}
aContainer
-
>
mPrepared
-
>
mTmpTarget
=
surface
;
}
else
{
MOZ_PERFORMANCE_WARNING
(
"
gfx
"
"
[
%
p
]
Container
layer
requires
intermediate
surface
copy
\
n
"
aContainer
)
;
aContainer
-
>
mPrepared
-
>
mNeedsSurfaceCopy
=
true
;
aContainer
-
>
mLastIntermediateSurface
=
nullptr
;
}
}
else
{
aContainer
-
>
mLastIntermediateSurface
=
nullptr
;
}
}
template
<
class
ContainerT
>
void
RenderMinimap
(
ContainerT
*
aContainer
LayerManagerComposite
*
aManager
const
RenderTargetIntRect
&
aClipRect
Layer
*
aLayer
)
{
Compositor
*
compositor
=
aManager
-
>
GetCompositor
(
)
;
if
(
aLayer
-
>
GetFrameMetricsCount
(
)
<
1
)
{
return
;
}
AsyncPanZoomController
*
controller
=
aLayer
-
>
GetAsyncPanZoomController
(
0
)
;
if
(
!
controller
)
{
return
;
}
AsyncTransform
asyncTransformWithoutOverscroll
;
ParentLayerPoint
scrollOffset
;
controller
-
>
SampleContentTransformForFrame
(
&
asyncTransformWithoutOverscroll
scrollOffset
)
;
const
int
verticalPadding
=
10
;
const
int
horizontalPadding
=
5
;
gfx
:
:
Color
backgroundColor
(
0
.
3f
0
.
3f
0
.
3f
0
.
3f
)
;
gfx
:
:
Color
tileActiveColor
(
1
1
1
0
.
5f
)
;
gfx
:
:
Color
tileBorderColor
(
0
0
0
0
.
1f
)
;
gfx
:
:
Color
pageBorderColor
(
0
0
0
)
;
gfx
:
:
Color
displayPortColor
(
0
1
.
f
0
)
;
gfx
:
:
Color
viewPortColor
(
0
0
1
.
f
)
;
const
FrameMetrics
&
fm
=
aLayer
-
>
GetFrameMetrics
(
0
)
;
ParentLayerRect
compositionBounds
=
fm
.
GetCompositionBounds
(
)
;
LayerRect
scrollRect
=
fm
.
GetScrollableRect
(
)
*
fm
.
LayersPixelsPerCSSPixel
(
)
;
LayerRect
viewRect
=
ParentLayerRect
(
scrollOffset
compositionBounds
.
Size
(
)
)
/
LayerToParentLayerScale
(
1
)
;
LayerRect
dp
=
(
fm
.
GetDisplayPort
(
)
+
fm
.
GetScrollOffset
(
)
)
*
fm
.
LayersPixelsPerCSSPixel
(
)
;
if
(
viewRect
.
width
<
64
&
&
viewRect
.
height
<
64
)
{
return
;
}
float
scaleFactor
;
float
scaleFactorX
;
float
scaleFactorY
;
scaleFactorX
=
100
.
f
/
scrollRect
.
width
;
scaleFactorY
=
(
(
viewRect
.
height
)
-
2
*
verticalPadding
)
/
scrollRect
.
height
;
scaleFactor
=
std
:
:
min
(
scaleFactorX
scaleFactorY
)
;
Matrix4x4
transform
=
Matrix4x4
:
:
Scaling
(
scaleFactor
scaleFactor
1
)
;
transform
.
PostTranslate
(
horizontalPadding
+
compositionBounds
.
x
verticalPadding
+
compositionBounds
.
y
0
)
;
Rect
clipRect
=
aContainer
-
>
GetEffectiveTransform
(
)
.
TransformBounds
(
transform
.
TransformBounds
(
scrollRect
.
ToUnknownRect
(
)
)
)
;
clipRect
.
width
+
+
;
clipRect
.
height
+
+
;
Rect
r
;
r
=
transform
.
TransformBounds
(
scrollRect
.
ToUnknownRect
(
)
)
;
compositor
-
>
FillRect
(
r
backgroundColor
clipRect
aContainer
-
>
GetEffectiveTransform
(
)
)
;
r
=
transform
.
TransformBounds
(
scrollRect
.
ToUnknownRect
(
)
)
;
compositor
-
>
SlowDrawRect
(
r
pageBorderColor
clipRect
aContainer
-
>
GetEffectiveTransform
(
)
)
;
r
=
transform
.
TransformBounds
(
dp
.
ToUnknownRect
(
)
)
;
compositor
-
>
FillRect
(
r
tileActiveColor
clipRect
aContainer
-
>
GetEffectiveTransform
(
)
)
;
r
=
transform
.
TransformBounds
(
dp
.
ToUnknownRect
(
)
)
;
compositor
-
>
SlowDrawRect
(
r
displayPortColor
clipRect
aContainer
-
>
GetEffectiveTransform
(
)
)
;
r
=
transform
.
TransformBounds
(
viewRect
.
ToUnknownRect
(
)
)
;
compositor
-
>
SlowDrawRect
(
r
viewPortColor
clipRect
aContainer
-
>
GetEffectiveTransform
(
)
2
)
;
}
template
<
class
ContainerT
>
void
RenderLayers
(
ContainerT
*
aContainer
LayerManagerComposite
*
aManager
const
RenderTargetIntRect
&
aClipRect
)
{
Compositor
*
compositor
=
aManager
-
>
GetCompositor
(
)
;
for
(
size_t
i
=
0u
;
i
<
aContainer
-
>
mPrepared
-
>
mLayers
.
Length
(
)
;
i
+
+
)
{
PreparedLayer
&
preparedData
=
aContainer
-
>
mPrepared
-
>
mLayers
[
i
]
;
LayerComposite
*
layerToRender
=
preparedData
.
mLayer
;
const
RenderTargetIntRect
&
clipRect
=
preparedData
.
mClipRect
;
Layer
*
layer
=
layerToRender
-
>
GetLayer
(
)
;
Color
color
;
if
(
NeedToDrawCheckerboardingForLayer
(
layer
&
color
)
)
{
if
(
gfxPrefs
:
:
APZHighlightCheckerboardedAreas
(
)
)
{
color
=
Color
(
255
/
255
.
f
188
/
255
.
f
217
/
255
.
f
1
.
f
)
;
}
gfx
:
:
IntRect
layerBounds
=
layer
-
>
GetLayerBounds
(
)
;
EffectChain
effectChain
(
layer
)
;
effectChain
.
mPrimaryEffect
=
new
EffectSolidColor
(
color
)
;
aManager
-
>
GetCompositor
(
)
-
>
DrawQuad
(
gfx
:
:
Rect
(
layerBounds
.
x
layerBounds
.
y
layerBounds
.
width
layerBounds
.
height
)
gfx
:
:
Rect
(
clipRect
.
ToUnknownRect
(
)
)
effectChain
layer
-
>
GetEffectiveOpacity
(
)
layer
-
>
GetEffectiveTransform
(
)
)
;
}
if
(
layerToRender
-
>
HasLayerBeenComposited
(
)
)
{
gfx
:
:
IntRect
clearRect
=
layerToRender
-
>
GetClearRect
(
)
;
if
(
!
clearRect
.
IsEmpty
(
)
)
{
gfx
:
:
Rect
fbRect
(
clearRect
.
x
clearRect
.
y
clearRect
.
width
clearRect
.
height
)
;
compositor
-
>
ClearRect
(
fbRect
)
;
layerToRender
-
>
SetClearRect
(
gfx
:
:
IntRect
(
0
0
0
0
)
)
;
}
}
else
{
layerToRender
-
>
RenderLayer
(
clipRect
.
ToUnknownRect
(
)
)
;
}
if
(
gfxPrefs
:
:
UniformityInfo
(
)
)
{
PrintUniformityInfo
(
layer
)
;
}
if
(
gfxPrefs
:
:
DrawLayerInfo
(
)
)
{
DrawLayerInfo
(
clipRect
aManager
layer
)
;
}
Matrix4x4
asyncTransform
;
for
(
uint32_t
i
=
layer
-
>
GetFrameMetricsCount
(
)
;
i
>
0
;
-
-
i
)
{
if
(
layer
-
>
GetFrameMetrics
(
i
-
1
)
.
IsScrollable
(
)
)
{
ParentLayerRect
compositionBounds
=
layer
-
>
GetFrameMetrics
(
i
-
1
)
.
GetCompositionBounds
(
)
;
aManager
-
>
GetCompositor
(
)
-
>
DrawDiagnostics
(
DiagnosticFlags
:
:
CONTAINER
compositionBounds
.
ToUnknownRect
(
)
gfx
:
:
Rect
(
aClipRect
.
ToUnknownRect
(
)
)
asyncTransform
*
aContainer
-
>
GetEffectiveTransform
(
)
)
;
if
(
AsyncPanZoomController
*
apzc
=
layer
-
>
GetAsyncPanZoomController
(
i
-
1
)
)
{
asyncTransform
=
apzc
-
>
GetCurrentAsyncTransformWithOverscroll
(
)
.
ToUnknownMatrix
(
)
*
asyncTransform
;
}
}
}
if
(
gfxPrefs
:
:
APZMinimap
(
)
)
{
RenderMinimap
(
aContainer
aManager
aClipRect
layer
)
;
}
}
}
template
<
class
ContainerT
>
RefPtr
<
CompositingRenderTarget
>
CreateOrRecycleTarget
(
ContainerT
*
aContainer
LayerManagerComposite
*
aManager
)
{
Compositor
*
compositor
=
aManager
-
>
GetCompositor
(
)
;
SurfaceInitMode
mode
=
INIT_MODE_CLEAR
;
gfx
:
:
IntRect
surfaceRect
=
ContainerVisibleRect
(
aContainer
)
;
if
(
aContainer
-
>
GetLocalVisibleRegion
(
)
.
GetNumRects
(
)
=
=
1
&
&
(
aContainer
-
>
GetContentFlags
(
)
&
Layer
:
:
CONTENT_OPAQUE
)
)
{
mode
=
INIT_MODE_NONE
;
}
RefPtr
<
CompositingRenderTarget
>
&
lastSurf
=
aContainer
-
>
mLastIntermediateSurface
;
if
(
lastSurf
&
&
lastSurf
-
>
GetRect
(
)
.
IsEqualEdges
(
surfaceRect
)
)
{
if
(
mode
=
=
INIT_MODE_CLEAR
)
{
lastSurf
-
>
ClearOnBind
(
)
;
}
return
lastSurf
;
}
else
{
lastSurf
=
compositor
-
>
CreateRenderTarget
(
surfaceRect
mode
)
;
return
lastSurf
;
}
}
template
<
class
ContainerT
>
RefPtr
<
CompositingRenderTarget
>
CreateTemporaryTargetAndCopyFromBackground
(
ContainerT
*
aContainer
LayerManagerComposite
*
aManager
)
{
Compositor
*
compositor
=
aManager
-
>
GetCompositor
(
)
;
gfx
:
:
IntRect
visibleRect
=
aContainer
-
>
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
.
GetBounds
(
)
;
RefPtr
<
CompositingRenderTarget
>
previousTarget
=
compositor
-
>
GetCurrentRenderTarget
(
)
;
gfx
:
:
IntRect
surfaceRect
=
gfx
:
:
IntRect
(
visibleRect
.
x
visibleRect
.
y
visibleRect
.
width
visibleRect
.
height
)
;
gfx
:
:
IntPoint
sourcePoint
=
gfx
:
:
IntPoint
(
visibleRect
.
x
visibleRect
.
y
)
;
gfx
:
:
Matrix4x4
transform
=
aContainer
-
>
GetEffectiveTransform
(
)
;
DebugOnly
<
gfx
:
:
Matrix
>
transform2d
;
MOZ_ASSERT
(
transform
.
Is2D
(
&
transform2d
)
&
&
!
gfx
:
:
ThebesMatrix
(
transform2d
)
.
HasNonIntegerTranslation
(
)
)
;
sourcePoint
+
=
gfx
:
:
IntPoint
(
transform
.
_41
transform
.
_42
)
;
sourcePoint
-
=
compositor
-
>
GetCurrentRenderTarget
(
)
-
>
GetOrigin
(
)
;
return
compositor
-
>
CreateRenderTargetFromSource
(
surfaceRect
previousTarget
sourcePoint
)
;
}
template
<
class
ContainerT
>
void
RenderIntermediate
(
ContainerT
*
aContainer
LayerManagerComposite
*
aManager
const
gfx
:
:
IntRect
&
aClipRect
RefPtr
<
CompositingRenderTarget
>
surface
)
{
Compositor
*
compositor
=
aManager
-
>
GetCompositor
(
)
;
RefPtr
<
CompositingRenderTarget
>
previousTarget
=
compositor
-
>
GetCurrentRenderTarget
(
)
;
if
(
!
surface
)
{
return
;
}
compositor
-
>
SetRenderTarget
(
surface
)
;
RenderLayers
(
aContainer
aManager
RenderTargetIntRect
:
:
FromUnknownRect
(
aClipRect
)
)
;
compositor
-
>
SetRenderTarget
(
previousTarget
)
;
}
template
<
class
ContainerT
>
void
ContainerRender
(
ContainerT
*
aContainer
LayerManagerComposite
*
aManager
const
gfx
:
:
IntRect
&
aClipRect
)
{
MOZ_ASSERT
(
aContainer
-
>
mPrepared
)
;
RefPtr
<
gfx
:
:
VRHMDInfo
>
hmdInfo
=
gfx
:
:
VRManager
:
:
Get
(
)
-
>
GetDevice
(
aContainer
-
>
GetVRDeviceID
(
)
)
;
if
(
hmdInfo
&
&
hmdInfo
-
>
GetConfiguration
(
)
.
IsValid
(
)
)
{
ContainerRenderVR
(
aContainer
aManager
aClipRect
hmdInfo
aContainer
-
>
GetInputFrameID
(
)
)
;
aContainer
-
>
mPrepared
=
nullptr
;
return
;
}
if
(
aContainer
-
>
UseIntermediateSurface
(
)
)
{
RefPtr
<
CompositingRenderTarget
>
surface
;
if
(
aContainer
-
>
mPrepared
-
>
mNeedsSurfaceCopy
)
{
surface
=
CreateTemporaryTargetAndCopyFromBackground
(
aContainer
aManager
)
;
RenderIntermediate
(
aContainer
aManager
aClipRect
surface
)
;
}
else
{
surface
=
aContainer
-
>
mPrepared
-
>
mTmpTarget
;
}
if
(
!
surface
)
{
aContainer
-
>
mPrepared
=
nullptr
;
return
;
}
gfx
:
:
Rect
visibleRect
(
aContainer
-
>
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
.
GetBounds
(
)
)
;
RefPtr
<
Compositor
>
compositor
=
aManager
-
>
GetCompositor
(
)
;
#
ifdef
MOZ_DUMP_PAINTING
if
(
gfxEnv
:
:
DumpCompositorTextures
(
)
)
{
RefPtr
<
gfx
:
:
DataSourceSurface
>
surf
=
surface
-
>
Dump
(
compositor
)
;
if
(
surf
)
{
WriteSnapshotToDumpFile
(
aContainer
surf
)
;
}
}
#
endif
RefPtr
<
ContainerT
>
container
=
aContainer
;
RenderWithAllMasks
(
aContainer
compositor
aClipRect
[
&
surface
compositor
container
]
(
EffectChain
&
effectChain
const
Rect
&
clipRect
)
{
effectChain
.
mPrimaryEffect
=
new
EffectRenderTarget
(
surface
)
;
compositor
-
>
DrawQuad
(
visibleRect
clipRect
effectChain
container
-
>
GetEffectiveOpacity
(
)
container
-
>
GetEffectiveTransform
(
)
)
;
}
)
;
}
else
{
RenderLayers
(
aContainer
aManager
RenderTargetIntRect
:
:
FromUnknownRect
(
aClipRect
)
)
;
}
aContainer
-
>
mPrepared
=
nullptr
;
if
(
gfxPrefs
:
:
LayersDrawFPS
(
)
&
&
aContainer
-
>
IsScrollInfoLayer
(
)
)
{
for
(
LayerMetricsWrapper
i
(
aContainer
)
;
i
;
i
=
i
.
GetFirstChild
(
)
)
{
if
(
AsyncPanZoomController
*
apzc
=
i
.
GetApzc
(
)
)
{
if
(
!
apzc
-
>
GetAsyncTransformAppliedToContent
(
)
&
&
!
AsyncTransformComponentMatrix
(
apzc
-
>
GetCurrentAsyncTransform
(
)
)
.
IsIdentity
(
)
)
{
aManager
-
>
UnusedApzTransformWarning
(
)
;
break
;
}
}
}
}
}
ContainerLayerComposite
:
:
ContainerLayerComposite
(
LayerManagerComposite
*
aManager
)
:
ContainerLayer
(
aManager
nullptr
)
LayerComposite
(
aManager
)
{
MOZ_COUNT_CTOR
(
ContainerLayerComposite
)
;
mImplData
=
static_cast
<
LayerComposite
*
>
(
this
)
;
}
ContainerLayerComposite
:
:
~
ContainerLayerComposite
(
)
{
MOZ_COUNT_DTOR
(
ContainerLayerComposite
)
;
while
(
mFirstChild
)
{
RemoveChild
(
mFirstChild
)
;
}
}
void
ContainerLayerComposite
:
:
Destroy
(
)
{
if
(
!
mDestroyed
)
{
while
(
mFirstChild
)
{
static_cast
<
LayerComposite
*
>
(
GetFirstChild
(
)
-
>
ImplData
(
)
)
-
>
Destroy
(
)
;
RemoveChild
(
mFirstChild
)
;
}
mDestroyed
=
true
;
}
}
LayerComposite
*
ContainerLayerComposite
:
:
GetFirstChildComposite
(
)
{
if
(
!
mFirstChild
)
{
return
nullptr
;
}
return
static_cast
<
LayerComposite
*
>
(
mFirstChild
-
>
ImplData
(
)
)
;
}
void
ContainerLayerComposite
:
:
RenderLayer
(
const
gfx
:
:
IntRect
&
aClipRect
)
{
ContainerRender
(
this
mCompositeManager
aClipRect
)
;
}
void
ContainerLayerComposite
:
:
Prepare
(
const
RenderTargetIntRect
&
aClipRect
)
{
ContainerPrepare
(
this
mCompositeManager
aClipRect
)
;
}
void
ContainerLayerComposite
:
:
CleanupResources
(
)
{
mLastIntermediateSurface
=
nullptr
;
for
(
Layer
*
l
=
GetFirstChild
(
)
;
l
;
l
=
l
-
>
GetNextSibling
(
)
)
{
LayerComposite
*
layerToCleanup
=
static_cast
<
LayerComposite
*
>
(
l
-
>
ImplData
(
)
)
;
layerToCleanup
-
>
CleanupResources
(
)
;
}
}
RefLayerComposite
:
:
RefLayerComposite
(
LayerManagerComposite
*
aManager
)
:
RefLayer
(
aManager
nullptr
)
LayerComposite
(
aManager
)
{
mImplData
=
static_cast
<
LayerComposite
*
>
(
this
)
;
}
RefLayerComposite
:
:
~
RefLayerComposite
(
)
{
Destroy
(
)
;
}
void
RefLayerComposite
:
:
Destroy
(
)
{
MOZ_ASSERT
(
!
mFirstChild
)
;
mDestroyed
=
true
;
}
LayerComposite
*
RefLayerComposite
:
:
GetFirstChildComposite
(
)
{
if
(
!
mFirstChild
)
{
return
nullptr
;
}
return
static_cast
<
LayerComposite
*
>
(
mFirstChild
-
>
ImplData
(
)
)
;
}
void
RefLayerComposite
:
:
RenderLayer
(
const
gfx
:
:
IntRect
&
aClipRect
)
{
ContainerRender
(
this
mCompositeManager
aClipRect
)
;
}
void
RefLayerComposite
:
:
Prepare
(
const
RenderTargetIntRect
&
aClipRect
)
{
ContainerPrepare
(
this
mCompositeManager
aClipRect
)
;
}
void
RefLayerComposite
:
:
CleanupResources
(
)
{
mLastIntermediateSurface
=
nullptr
;
}
}
}
