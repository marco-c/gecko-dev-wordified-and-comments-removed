#
ifndef
GFX_LayerManagerComposite_H
#
define
GFX_LayerManagerComposite_H
#
include
<
stdint
.
h
>
#
include
"
CompositableHost
.
h
"
#
include
"
GLDefs
.
h
"
#
include
"
Layers
.
h
"
#
include
"
Units
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
CompositionRecorder
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
Effects
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nscore
.
h
"
#
include
"
LayerTreeInvalidation
.
h
"
#
include
"
mozilla
/
layers
/
CompositorScreenshotGrabber
.
h
"
class
gfxContext
;
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
endif
namespace
mozilla
{
namespace
gfx
{
class
DrawTarget
;
}
namespace
layers
{
class
CanvasLayerComposite
;
class
ColorLayerComposite
;
class
Compositor
;
class
ContainerLayerComposite
;
class
Diagnostics
;
struct
EffectChain
;
class
ImageLayer
;
class
ImageLayerComposite
;
class
LayerComposite
;
class
RefLayerComposite
;
class
PaintedLayerComposite
;
class
TextRenderer
;
class
CompositingRenderTarget
;
struct
FPSState
;
class
PaintCounter
;
class
LayerMLGPU
;
class
LayerManagerMLGPU
;
class
UiCompositorControllerParent
;
static
const
int
kVisualWarningDuration
=
150
;
class
HostLayerManager
:
public
LayerManager
{
public
:
HostLayerManager
(
)
;
virtual
~
HostLayerManager
(
)
;
bool
BeginTransactionWithTarget
(
gfxContext
*
aTarget
const
nsCString
&
aURL
)
override
{
MOZ_CRASH
(
"
GFX
:
Use
BeginTransactionWithDrawTarget
"
)
;
}
bool
EndEmptyTransaction
(
EndTransactionFlags
aFlags
=
END_DEFAULT
)
override
{
MOZ_CRASH
(
"
GFX
:
Use
EndTransaction
(
aTimeStamp
)
"
)
;
return
false
;
}
void
EndTransaction
(
DrawPaintedLayerCallback
aCallback
void
*
aCallbackData
EndTransactionFlags
aFlags
=
END_DEFAULT
)
override
{
MOZ_CRASH
(
"
GFX
:
Use
EndTransaction
(
aTimeStamp
)
"
)
;
}
int32_t
GetMaxTextureSize
(
)
const
override
{
MOZ_CRASH
(
"
GFX
:
Call
on
compositor
not
LayerManagerComposite
"
)
;
}
void
GetBackendName
(
nsAString
&
name
)
override
{
MOZ_CRASH
(
"
GFX
:
Shouldn
'
t
be
called
for
composited
layer
manager
"
)
;
}
virtual
void
ForcePresent
(
)
=
0
;
virtual
void
AddInvalidRegion
(
const
nsIntRegion
&
aRegion
)
=
0
;
virtual
void
NotifyShadowTreeTransaction
(
)
{
}
virtual
void
BeginTransactionWithDrawTarget
(
gfx
:
:
DrawTarget
*
aTarget
const
gfx
:
:
IntRect
&
aRect
)
=
0
;
virtual
Compositor
*
GetCompositor
(
)
const
=
0
;
virtual
TextureSourceProvider
*
GetTextureSourceProvider
(
)
const
=
0
;
virtual
void
EndTransaction
(
const
TimeStamp
&
aTimeStamp
EndTransactionFlags
aFlags
=
END_DEFAULT
)
=
0
;
virtual
void
UpdateRenderBounds
(
const
gfx
:
:
IntRect
&
aRect
)
{
}
virtual
void
SetDiagnosticTypes
(
DiagnosticTypes
aDiagnostics
)
{
}
virtual
void
InvalidateAll
(
)
=
0
;
HostLayerManager
*
AsHostLayerManager
(
)
override
{
return
this
;
}
virtual
LayerManagerMLGPU
*
AsLayerManagerMLGPU
(
)
{
return
nullptr
;
}
void
ExtractImageCompositeNotifications
(
nsTArray
<
ImageCompositeNotificationInfo
>
*
aNotifications
)
{
aNotifications
-
>
AppendElements
(
std
:
:
move
(
mImageCompositeNotifications
)
)
;
}
void
AppendImageCompositeNotification
(
const
ImageCompositeNotificationInfo
&
aNotification
)
{
if
(
IsCompositingToScreen
(
)
)
{
mImageCompositeNotifications
.
AppendElement
(
aNotification
)
;
}
}
bool
DebugOverlayWantsNextFrame
(
)
{
return
mDebugOverlayWantsNextFrame
;
}
void
SetDebugOverlayWantsNextFrame
(
bool
aVal
)
{
mDebugOverlayWantsNextFrame
=
aVal
;
}
void
VisualFrameWarning
(
float
severity
)
{
mozilla
:
:
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
mWarnTime
.
IsNull
(
)
|
|
severity
>
mWarningLevel
|
|
mWarnTime
+
TimeDuration
:
:
FromMilliseconds
(
kVisualWarningDuration
)
<
now
)
{
mWarnTime
=
now
;
mWarningLevel
=
severity
;
}
}
void
SetWindowOverlayChanged
(
)
{
mWindowOverlayChanged
=
true
;
}
void
SetPaintTime
(
const
TimeDuration
&
aPaintTime
)
{
mLastPaintTime
=
aPaintTime
;
}
virtual
bool
AlwaysScheduleComposite
(
)
const
{
return
false
;
}
virtual
bool
IsCompositingToScreen
(
)
const
{
return
false
;
}
void
RecordPaintTimes
(
const
PaintTiming
&
aTiming
)
;
void
RecordUpdateTime
(
float
aValue
)
;
TimeStamp
GetCompositionTime
(
)
const
{
return
mCompositionTime
;
}
void
SetCompositionTime
(
TimeStamp
aTimeStamp
)
{
mCompositionTime
=
aTimeStamp
;
if
(
!
mCompositionTime
.
IsNull
(
)
&
&
!
mCompositeUntilTime
.
IsNull
(
)
&
&
mCompositionTime
>
=
mCompositeUntilTime
)
{
mCompositeUntilTime
=
TimeStamp
(
)
;
}
}
void
CompositeUntil
(
TimeStamp
aTimeStamp
)
{
if
(
mCompositeUntilTime
.
IsNull
(
)
|
|
mCompositeUntilTime
<
aTimeStamp
)
{
mCompositeUntilTime
=
aTimeStamp
;
}
}
TimeStamp
GetCompositeUntilTime
(
)
const
{
return
mCompositeUntilTime
;
}
uint64_t
GetCompositorBridgeID
(
)
const
{
return
mCompositorBridgeID
;
}
void
SetCompositorBridgeID
(
uint64_t
aID
)
{
MOZ_ASSERT
(
mCompositorBridgeID
=
=
0
"
The
compositor
ID
must
be
set
only
once
.
"
)
;
mCompositorBridgeID
=
aID
;
}
void
SetCompositionRecorder
(
UniquePtr
<
CompositionRecorder
>
aRecorder
)
{
mCompositionRecorder
=
std
:
:
move
(
aRecorder
)
;
}
void
WriteCollectedFrames
(
)
;
protected
:
bool
mDebugOverlayWantsNextFrame
;
nsTArray
<
ImageCompositeNotificationInfo
>
mImageCompositeNotifications
;
float
mWarningLevel
;
mozilla
:
:
TimeStamp
mWarnTime
;
UniquePtr
<
Diagnostics
>
mDiagnostics
;
uint64_t
mCompositorBridgeID
;
bool
mWindowOverlayChanged
;
TimeDuration
mLastPaintTime
;
TimeStamp
mRenderStartTime
;
UniquePtr
<
CompositionRecorder
>
mCompositionRecorder
=
nullptr
;
TimeStamp
mCompositionTime
;
TimeStamp
mCompositeUntilTime
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
public
:
virtual
void
RequestScreenPixels
(
UiCompositorControllerParent
*
aController
)
{
}
#
endif
}
;
class
LayerManagerComposite
final
:
public
HostLayerManager
{
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
typedef
mozilla
:
:
gfx
:
:
IntSize
IntSize
;
typedef
mozilla
:
:
gfx
:
:
SurfaceFormat
SurfaceFormat
;
public
:
explicit
LayerManagerComposite
(
Compositor
*
aCompositor
)
;
virtual
~
LayerManagerComposite
(
)
;
void
Destroy
(
)
override
;
void
SetClippingRegion
(
const
nsIntRegion
&
aClippingRegion
)
{
mClippingRegion
=
aClippingRegion
;
}
LayerManagerComposite
*
AsLayerManagerComposite
(
)
override
{
return
this
;
}
void
UpdateRenderBounds
(
const
gfx
:
:
IntRect
&
aRect
)
override
;
bool
BeginTransaction
(
const
nsCString
&
aURL
)
override
;
void
BeginTransactionWithDrawTarget
(
gfx
:
:
DrawTarget
*
aTarget
const
gfx
:
:
IntRect
&
aRect
)
override
;
void
EndTransaction
(
const
TimeStamp
&
aTimeStamp
EndTransactionFlags
aFlags
=
END_DEFAULT
)
override
;
virtual
void
EndTransaction
(
DrawPaintedLayerCallback
aCallback
void
*
aCallbackData
EndTransactionFlags
aFlags
=
END_DEFAULT
)
override
{
MOZ_CRASH
(
"
GFX
:
Use
EndTransaction
(
aTimeStamp
)
"
)
;
}
void
SetRoot
(
Layer
*
aLayer
)
override
{
mRoot
=
aLayer
;
}
bool
CanUseCanvasLayerForSize
(
const
gfx
:
:
IntSize
&
aSize
)
override
;
void
ClearCachedResources
(
Layer
*
aSubtree
=
nullptr
)
override
;
already_AddRefed
<
PaintedLayer
>
CreatePaintedLayer
(
)
override
;
already_AddRefed
<
ContainerLayer
>
CreateContainerLayer
(
)
override
;
already_AddRefed
<
ImageLayer
>
CreateImageLayer
(
)
override
;
already_AddRefed
<
ColorLayer
>
CreateColorLayer
(
)
override
;
already_AddRefed
<
CanvasLayer
>
CreateCanvasLayer
(
)
override
;
already_AddRefed
<
RefLayer
>
CreateRefLayer
(
)
override
;
bool
AreComponentAlphaLayersEnabled
(
)
override
;
already_AddRefed
<
DrawTarget
>
CreateOptimalMaskDrawTarget
(
const
IntSize
&
aSize
)
override
;
const
char
*
Name
(
)
const
override
{
return
"
"
;
}
bool
IsCompositingToScreen
(
)
const
override
;
bool
AlwaysScheduleComposite
(
)
const
override
;
void
PostProcessLayers
(
nsIntRegion
&
aOpaqueRegion
)
;
void
PostProcessLayers
(
Layer
*
aLayer
nsIntRegion
&
aOpaqueRegion
LayerIntRegion
&
aVisibleRegion
const
Maybe
<
RenderTargetIntRect
>
&
aRenderTargetClip
const
Maybe
<
ParentLayerIntRect
>
&
aClipFromAncestors
bool
aCanContributeOpaque
)
;
class
AutoAddMaskEffect
{
public
:
AutoAddMaskEffect
(
Layer
*
aMaskLayer
EffectChain
&
aEffect
)
;
~
AutoAddMaskEffect
(
)
;
bool
Failed
(
)
const
{
return
mFailed
;
}
private
:
CompositableHost
*
mCompositable
;
bool
mFailed
;
}
;
static
bool
SupportsDirectTexturing
(
)
;
static
void
PlatformSyncBeforeReplyUpdate
(
)
;
void
AddInvalidRegion
(
const
nsIntRegion
&
aRegion
)
override
{
mInvalidRegion
.
Or
(
mInvalidRegion
aRegion
)
;
}
Compositor
*
GetCompositor
(
)
const
override
{
return
mCompositor
;
}
TextureSourceProvider
*
GetTextureSourceProvider
(
)
const
override
{
return
mCompositor
;
}
void
NotifyShadowTreeTransaction
(
)
override
;
TextRenderer
*
GetTextRenderer
(
)
{
return
mTextRenderer
;
}
void
UnusedApzTransformWarning
(
)
{
mUnusedApzTransformWarning
=
true
;
}
void
DisabledApzWarning
(
)
{
mDisabledApzWarning
=
true
;
}
bool
AsyncPanZoomEnabled
(
)
const
override
;
public
:
TextureFactoryIdentifier
GetTextureFactoryIdentifier
(
)
override
{
return
mCompositor
-
>
GetTextureFactoryIdentifier
(
)
;
}
LayersBackend
GetBackendType
(
)
override
{
return
mCompositor
?
mCompositor
-
>
GetBackendType
(
)
:
LayersBackend
:
:
LAYERS_NONE
;
}
void
SetDiagnosticTypes
(
DiagnosticTypes
aDiagnostics
)
override
{
mCompositor
-
>
SetDiagnosticTypes
(
aDiagnostics
)
;
}
void
InvalidateAll
(
)
override
{
AddInvalidRegion
(
nsIntRegion
(
mRenderBounds
)
)
;
}
void
ForcePresent
(
)
override
{
mCompositor
-
>
ForcePresent
(
)
;
}
private
:
nsIntRegion
mClippingRegion
;
gfx
:
:
IntRect
mRenderBounds
;
LayerComposite
*
RootLayer
(
)
const
;
void
UpdateAndRender
(
)
;
bool
Render
(
const
nsIntRegion
&
aInvalidRegion
const
nsIntRegion
&
aOpaqueRegion
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
void
RenderToPresentationSurface
(
)
;
ScreenCoord
GetContentShiftForToolbar
(
)
;
void
RenderToolbar
(
)
;
void
HandlePixelsTarget
(
)
;
#
endif
void
InvalidateDebugOverlay
(
nsIntRegion
&
aInvalidRegion
const
gfx
:
:
IntRect
&
aBounds
)
;
void
RenderDebugOverlay
(
const
gfx
:
:
IntRect
&
aBounds
)
;
void
DrawBorder
(
const
gfx
:
:
IntRect
&
aOuter
int32_t
aBorderWidth
const
gfx
:
:
Color
&
aColor
const
gfx
:
:
Matrix4x4
&
aTransform
)
;
void
DrawTranslationWarningOverlay
(
const
gfx
:
:
IntRect
&
aBounds
)
;
void
UpdateDebugOverlayNativeLayers
(
)
;
RefPtr
<
CompositingRenderTarget
>
PushGroupForLayerEffects
(
)
;
void
PopGroupForLayerEffects
(
RefPtr
<
CompositingRenderTarget
>
aPreviousTarget
gfx
:
:
IntRect
aClipRect
bool
aGrayscaleEffect
bool
aInvertEffect
float
aContrastEffect
)
;
void
PlaceNativeLayers
(
const
gfx
:
:
IntRegion
&
aRegion
bool
aOpaque
std
:
:
deque
<
RefPtr
<
NativeLayer
>
>
*
aLayersToRecycle
gfx
:
:
IntRegion
*
aWindowInvalidRegion
)
;
void
PlaceNativeLayer
(
const
gfx
:
:
IntRect
&
aRect
bool
aOpaque
std
:
:
deque
<
RefPtr
<
NativeLayer
>
>
*
aLayersToRecycle
gfx
:
:
IntRegion
*
aWindowInvalidRegion
)
;
bool
mUnusedApzTransformWarning
;
bool
mDisabledApzWarning
;
RefPtr
<
Compositor
>
mCompositor
;
UniquePtr
<
LayerProperties
>
mClonedLayerTreeProperties
;
RefPtr
<
gfx
:
:
DrawTarget
>
mTarget
;
gfx
:
:
IntRect
mTargetBounds
;
nsIntRegion
mInvalidRegion
;
bool
mInTransaction
;
bool
mIsCompositorReady
;
RefPtr
<
CompositingRenderTarget
>
mTwoPassTmpTarget
;
CompositorScreenshotGrabber
mProfilerScreenshotGrabber
;
RefPtr
<
TextRenderer
>
mTextRenderer
;
RefPtr
<
NativeLayerRoot
>
mNativeLayerRoot
;
std
:
:
deque
<
RefPtr
<
NativeLayer
>
>
mNativeLayers
;
RefPtr
<
NativeLayer
>
mGPUStatsLayer
;
RefPtr
<
NativeLayer
>
mUnusedTransformWarningLayer
;
RefPtr
<
NativeLayer
>
mDisabledApzWarningLayer
;
#
ifdef
USE_SKIA
void
DrawPaintTimes
(
Compositor
*
aCompositor
)
;
RefPtr
<
PaintCounter
>
mPaintCounter
;
#
endif
#
if
defined
(
MOZ_WIDGET_ANDROID
)
public
:
virtual
void
RequestScreenPixels
(
UiCompositorControllerParent
*
aController
)
override
{
mScreenPixelsTarget
=
aController
;
}
private
:
UiCompositorControllerParent
*
mScreenPixelsTarget
;
#
endif
}
;
class
HostLayer
{
public
:
explicit
HostLayer
(
HostLayerManager
*
aManager
)
:
mCompositorManager
(
aManager
)
mShadowOpacity
(
1
.
0
)
mShadowTransformSetByAnimation
(
false
)
mShadowOpacitySetByAnimation
(
false
)
{
}
virtual
void
SetLayerManager
(
HostLayerManager
*
aManager
)
{
mCompositorManager
=
aManager
;
}
HostLayerManager
*
GetLayerManager
(
)
const
{
return
mCompositorManager
;
}
virtual
~
HostLayer
(
)
=
default
;
virtual
LayerComposite
*
GetFirstChildComposite
(
)
{
return
nullptr
;
}
virtual
Layer
*
GetLayer
(
)
=
0
;
virtual
LayerMLGPU
*
AsLayerMLGPU
(
)
{
return
nullptr
;
}
virtual
bool
SetCompositableHost
(
CompositableHost
*
)
{
NS_WARNING
(
"
called
SetCompositableHost
for
a
layer
type
not
accepting
a
"
"
compositable
"
)
;
return
false
;
}
virtual
CompositableHost
*
GetCompositableHost
(
)
=
0
;
void
SetShadowVisibleRegion
(
const
LayerIntRegion
&
aRegion
)
{
mShadowVisibleRegion
=
aRegion
;
}
void
SetShadowVisibleRegion
(
LayerIntRegion
&
&
aRegion
)
{
mShadowVisibleRegion
=
std
:
:
move
(
aRegion
)
;
}
void
SetShadowOpacity
(
float
aOpacity
)
{
mShadowOpacity
=
aOpacity
;
}
void
SetShadowOpacitySetByAnimation
(
bool
aSetByAnimation
)
{
mShadowOpacitySetByAnimation
=
aSetByAnimation
;
}
void
SetShadowClipRect
(
const
Maybe
<
ParentLayerIntRect
>
&
aRect
)
{
mShadowClipRect
=
aRect
;
}
void
SetShadowBaseTransform
(
const
gfx
:
:
Matrix4x4
&
aMatrix
)
{
mShadowTransform
=
aMatrix
;
}
void
SetShadowTransformSetByAnimation
(
bool
aSetByAnimation
)
{
mShadowTransformSetByAnimation
=
aSetByAnimation
;
}
float
GetShadowOpacity
(
)
{
return
mShadowOpacity
;
}
const
Maybe
<
ParentLayerIntRect
>
&
GetShadowClipRect
(
)
{
return
mShadowClipRect
;
}
virtual
const
LayerIntRegion
&
GetShadowVisibleRegion
(
)
{
return
mShadowVisibleRegion
;
}
const
gfx
:
:
Matrix4x4
&
GetShadowBaseTransform
(
)
{
return
mShadowTransform
;
}
gfx
:
:
Matrix4x4
GetShadowTransform
(
)
;
bool
GetShadowTransformSetByAnimation
(
)
{
return
mShadowTransformSetByAnimation
;
}
bool
GetShadowOpacitySetByAnimation
(
)
{
return
mShadowOpacitySetByAnimation
;
}
void
RecomputeShadowVisibleRegionFromChildren
(
)
;
protected
:
HostLayerManager
*
mCompositorManager
;
gfx
:
:
Matrix4x4
mShadowTransform
;
LayerIntRegion
mShadowVisibleRegion
;
Maybe
<
ParentLayerIntRect
>
mShadowClipRect
;
float
mShadowOpacity
;
bool
mShadowTransformSetByAnimation
;
bool
mShadowOpacitySetByAnimation
;
}
;
class
LayerComposite
:
public
HostLayer
{
public
:
explicit
LayerComposite
(
LayerManagerComposite
*
aManager
)
;
virtual
~
LayerComposite
(
)
;
void
SetLayerManager
(
HostLayerManager
*
aManager
)
override
;
LayerComposite
*
GetFirstChildComposite
(
)
override
{
return
nullptr
;
}
virtual
void
Destroy
(
)
;
virtual
void
Cleanup
(
)
{
}
virtual
void
Prepare
(
const
RenderTargetIntRect
&
aClipRect
)
{
}
virtual
void
RenderLayer
(
const
gfx
:
:
IntRect
&
aClipRect
const
Maybe
<
gfx
:
:
Polygon
>
&
aGeometry
)
=
0
;
bool
SetCompositableHost
(
CompositableHost
*
)
override
{
NS_WARNING
(
"
called
SetCompositableHost
for
a
layer
type
not
accepting
a
"
"
compositable
"
)
;
return
false
;
}
virtual
void
CleanupResources
(
)
=
0
;
virtual
void
DestroyFrontBuffer
(
)
{
}
void
AddBlendModeEffect
(
EffectChain
&
aEffectChain
)
;
virtual
void
GenEffectChain
(
EffectChain
&
aEffect
)
{
}
void
SetLayerComposited
(
bool
value
)
{
mLayerComposited
=
value
;
}
void
SetClearRect
(
const
gfx
:
:
IntRect
&
aRect
)
{
mClearRect
=
aRect
;
}
bool
HasLayerBeenComposited
(
)
{
return
mLayerComposited
;
}
gfx
:
:
IntRect
GetClearRect
(
)
{
return
mClearRect
;
}
bool
HasStaleCompositor
(
)
const
;
virtual
nsIntRegion
GetFullyRenderedRegion
(
)
;
protected
:
LayerManagerComposite
*
mCompositeManager
;
RefPtr
<
Compositor
>
mCompositor
;
bool
mDestroyed
;
bool
mLayerComposited
;
gfx
:
:
IntRect
mClearRect
;
}
;
template
<
typename
RenderCallbackType
>
void
RenderWithAllMasks
(
Layer
*
aLayer
Compositor
*
aCompositor
const
gfx
:
:
IntRect
&
aClipRect
RenderCallbackType
aRenderCallback
)
{
Layer
*
firstMask
=
nullptr
;
size_t
maskLayerCount
=
0
;
size_t
nextAncestorMaskLayer
=
0
;
size_t
ancestorMaskLayerCount
=
aLayer
-
>
GetAncestorMaskLayerCount
(
)
;
if
(
Layer
*
ownMask
=
aLayer
-
>
GetMaskLayer
(
)
)
{
firstMask
=
ownMask
;
maskLayerCount
=
ancestorMaskLayerCount
+
1
;
nextAncestorMaskLayer
=
0
;
}
else
if
(
ancestorMaskLayerCount
>
0
)
{
firstMask
=
aLayer
-
>
GetAncestorMaskLayerAt
(
0
)
;
maskLayerCount
=
ancestorMaskLayerCount
;
nextAncestorMaskLayer
=
1
;
}
else
{
}
if
(
maskLayerCount
<
=
1
)
{
EffectChain
effectChain
(
aLayer
)
;
LayerManagerComposite
:
:
AutoAddMaskEffect
autoMaskEffect
(
firstMask
effectChain
)
;
static_cast
<
LayerComposite
*
>
(
aLayer
-
>
AsHostLayer
(
)
)
-
>
AddBlendModeEffect
(
effectChain
)
;
aRenderCallback
(
effectChain
aClipRect
)
;
return
;
}
gfx
:
:
Rect
visibleRect
(
aLayer
-
>
GetLocalVisibleRegion
(
)
.
GetBounds
(
)
.
ToUnknownRect
(
)
)
;
gfx
:
:
Matrix4x4
transform
=
aLayer
-
>
GetEffectiveTransform
(
)
;
gfx
:
:
IntRect
surfaceRect
=
RoundedOut
(
transform
.
TransformAndClipBounds
(
visibleRect
gfx
:
:
Rect
(
aClipRect
)
)
)
;
if
(
surfaceRect
.
IsEmpty
(
)
)
{
return
;
}
RefPtr
<
CompositingRenderTarget
>
originalTarget
=
aCompositor
-
>
GetCurrentRenderTarget
(
)
;
RefPtr
<
CompositingRenderTarget
>
firstTarget
=
aCompositor
-
>
CreateRenderTarget
(
surfaceRect
INIT_MODE_CLEAR
)
;
if
(
!
firstTarget
)
{
return
;
}
aCompositor
-
>
SetRenderTarget
(
firstTarget
)
;
{
EffectChain
firstEffectChain
(
aLayer
)
;
LayerManagerComposite
:
:
AutoAddMaskEffect
firstMaskEffect
(
firstMask
firstEffectChain
)
;
aRenderCallback
(
firstEffectChain
aClipRect
-
surfaceRect
.
TopLeft
(
)
)
;
}
gfx
:
:
IntRect
intermediateClip
(
surfaceRect
-
surfaceRect
.
TopLeft
(
)
)
;
RefPtr
<
CompositingRenderTarget
>
previousTarget
=
firstTarget
;
for
(
size_t
i
=
nextAncestorMaskLayer
;
i
<
ancestorMaskLayerCount
-
1
;
i
+
+
)
{
Layer
*
intermediateMask
=
aLayer
-
>
GetAncestorMaskLayerAt
(
i
)
;
RefPtr
<
CompositingRenderTarget
>
intermediateTarget
=
aCompositor
-
>
CreateRenderTarget
(
surfaceRect
INIT_MODE_CLEAR
)
;
if
(
!
intermediateTarget
)
{
break
;
}
aCompositor
-
>
SetRenderTarget
(
intermediateTarget
)
;
EffectChain
intermediateEffectChain
(
aLayer
)
;
LayerManagerComposite
:
:
AutoAddMaskEffect
intermediateMaskEffect
(
intermediateMask
intermediateEffectChain
)
;
if
(
intermediateMaskEffect
.
Failed
(
)
)
{
continue
;
}
intermediateEffectChain
.
mPrimaryEffect
=
new
EffectRenderTarget
(
previousTarget
)
;
aCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
surfaceRect
)
intermediateClip
intermediateEffectChain
1
.
0
gfx
:
:
Matrix4x4
(
)
)
;
previousTarget
=
intermediateTarget
;
}
aCompositor
-
>
SetRenderTarget
(
originalTarget
)
;
EffectChain
finalEffectChain
(
aLayer
)
;
finalEffectChain
.
mPrimaryEffect
=
new
EffectRenderTarget
(
previousTarget
)
;
Layer
*
finalMask
=
aLayer
-
>
GetAncestorMaskLayerAt
(
ancestorMaskLayerCount
-
1
)
;
static_cast
<
LayerComposite
*
>
(
aLayer
-
>
AsHostLayer
(
)
)
-
>
AddBlendModeEffect
(
finalEffectChain
)
;
LayerManagerComposite
:
:
AutoAddMaskEffect
autoMaskEffect
(
finalMask
finalEffectChain
)
;
if
(
!
autoMaskEffect
.
Failed
(
)
)
{
aCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
surfaceRect
)
aClipRect
finalEffectChain
1
.
0
gfx
:
:
Matrix4x4
(
)
)
;
}
}
}
}
#
endif
