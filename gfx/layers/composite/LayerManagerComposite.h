#
ifndef
GFX_LayerManagerComposite_H
#
define
GFX_LayerManagerComposite_H
#
include
<
stdint
.
h
>
#
include
"
GLDefs
.
h
"
#
include
"
Layers
.
h
"
#
include
"
Units
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
Effects
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nscore
.
h
"
#
include
"
LayerTreeInvalidation
.
h
"
class
gfxContext
;
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
endif
namespace
mozilla
{
namespace
gfx
{
class
DrawTarget
;
}
namespace
layers
{
class
CanvasLayerComposite
;
class
ColorLayerComposite
;
class
CompositableHost
;
class
Compositor
;
class
ContainerLayerComposite
;
struct
EffectChain
;
class
ImageLayer
;
class
ImageLayerComposite
;
class
LayerComposite
;
class
RefLayerComposite
;
class
PaintedLayerComposite
;
class
TextRenderer
;
class
CompositingRenderTarget
;
struct
FPSState
;
class
PaintCounter
;
static
const
int
kVisualWarningDuration
=
150
;
class
LayerManagerComposite
final
:
public
LayerManager
{
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
typedef
mozilla
:
:
gfx
:
:
IntSize
IntSize
;
typedef
mozilla
:
:
gfx
:
:
SurfaceFormat
SurfaceFormat
;
public
:
explicit
LayerManagerComposite
(
Compositor
*
aCompositor
)
;
~
LayerManagerComposite
(
)
;
virtual
void
Destroy
(
)
override
;
void
SetClippingRegion
(
const
nsIntRegion
&
aClippingRegion
)
{
mClippingRegion
=
aClippingRegion
;
}
virtual
LayerManagerComposite
*
AsLayerManagerComposite
(
)
override
{
return
this
;
}
void
UpdateRenderBounds
(
const
gfx
:
:
IntRect
&
aRect
)
;
virtual
void
BeginTransaction
(
)
override
;
virtual
void
BeginTransactionWithTarget
(
gfxContext
*
aTarget
)
override
{
MOZ_CRASH
(
"
GFX
:
Use
BeginTransactionWithDrawTarget
"
)
;
}
void
BeginTransactionWithDrawTarget
(
gfx
:
:
DrawTarget
*
aTarget
const
gfx
:
:
IntRect
&
aRect
)
;
virtual
bool
EndEmptyTransaction
(
EndTransactionFlags
aFlags
=
END_DEFAULT
)
override
{
MOZ_CRASH
(
"
GFX
:
Use
EndTransaction
(
aTimeStamp
)
"
)
;
return
false
;
}
virtual
void
EndTransaction
(
DrawPaintedLayerCallback
aCallback
void
*
aCallbackData
EndTransactionFlags
aFlags
=
END_DEFAULT
)
override
{
MOZ_CRASH
(
"
GFX
:
Use
EndTransaction
(
aTimeStamp
)
"
)
;
}
void
EndTransaction
(
const
TimeStamp
&
aTimeStamp
EndTransactionFlags
aFlags
=
END_DEFAULT
)
;
virtual
void
SetRoot
(
Layer
*
aLayer
)
override
{
mRoot
=
aLayer
;
}
virtual
bool
CanUseCanvasLayerForSize
(
const
gfx
:
:
IntSize
&
aSize
)
override
;
virtual
int32_t
GetMaxTextureSize
(
)
const
override
{
MOZ_CRASH
(
"
GFX
:
Call
on
compositor
not
LayerManagerComposite
"
)
;
}
virtual
void
ClearCachedResources
(
Layer
*
aSubtree
=
nullptr
)
override
;
virtual
already_AddRefed
<
PaintedLayer
>
CreatePaintedLayer
(
)
override
;
virtual
already_AddRefed
<
ContainerLayer
>
CreateContainerLayer
(
)
override
;
virtual
already_AddRefed
<
ImageLayer
>
CreateImageLayer
(
)
override
;
virtual
already_AddRefed
<
ColorLayer
>
CreateColorLayer
(
)
override
;
virtual
already_AddRefed
<
CanvasLayer
>
CreateCanvasLayer
(
)
override
;
already_AddRefed
<
PaintedLayerComposite
>
CreatePaintedLayerComposite
(
)
;
already_AddRefed
<
ContainerLayerComposite
>
CreateContainerLayerComposite
(
)
;
already_AddRefed
<
ImageLayerComposite
>
CreateImageLayerComposite
(
)
;
already_AddRefed
<
ColorLayerComposite
>
CreateColorLayerComposite
(
)
;
already_AddRefed
<
CanvasLayerComposite
>
CreateCanvasLayerComposite
(
)
;
already_AddRefed
<
RefLayerComposite
>
CreateRefLayerComposite
(
)
;
virtual
LayersBackend
GetBackendType
(
)
override
{
MOZ_CRASH
(
"
GFX
:
Shouldn
'
t
be
called
for
composited
layer
manager
"
)
;
}
virtual
void
GetBackendName
(
nsAString
&
name
)
override
{
MOZ_CRASH
(
"
GFX
:
Shouldn
'
t
be
called
for
composited
layer
manager
"
)
;
}
virtual
bool
AreComponentAlphaLayersEnabled
(
)
override
;
virtual
already_AddRefed
<
DrawTarget
>
CreateOptimalMaskDrawTarget
(
const
IntSize
&
aSize
)
override
;
virtual
const
char
*
Name
(
)
const
override
{
return
"
"
;
}
void
PostProcessLayers
(
Layer
*
aLayer
nsIntRegion
&
aOpaqueRegion
LayerIntRegion
&
aVisibleRegion
const
Maybe
<
ParentLayerIntRect
>
&
aClipFromAncestors
)
;
class
AutoAddMaskEffect
{
public
:
AutoAddMaskEffect
(
Layer
*
aMaskLayer
EffectChain
&
aEffect
)
;
~
AutoAddMaskEffect
(
)
;
bool
Failed
(
)
const
{
return
mFailed
;
}
private
:
CompositableHost
*
mCompositable
;
bool
mFailed
;
}
;
static
bool
SupportsDirectTexturing
(
)
;
static
void
PlatformSyncBeforeReplyUpdate
(
)
;
void
AddInvalidRegion
(
const
nsIntRegion
&
aRegion
)
{
mInvalidRegion
.
Or
(
mInvalidRegion
aRegion
)
;
}
void
ClearApproximatelyVisibleRegions
(
uint64_t
aLayersId
const
Maybe
<
uint32_t
>
&
aPresShellId
)
{
for
(
auto
iter
=
mVisibleRegions
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
iter
.
Key
(
)
.
mLayersId
=
=
aLayersId
&
&
(
!
aPresShellId
|
|
iter
.
Key
(
)
.
mPresShellId
=
=
*
aPresShellId
)
)
{
iter
.
Remove
(
)
;
}
}
}
void
UpdateApproximatelyVisibleRegion
(
const
ScrollableLayerGuid
&
aGuid
const
CSSIntRegion
&
aRegion
)
{
CSSIntRegion
*
regionForScrollFrame
=
mVisibleRegions
.
LookupOrAdd
(
aGuid
)
;
MOZ_ASSERT
(
regionForScrollFrame
)
;
*
regionForScrollFrame
=
aRegion
;
}
CSSIntRegion
*
GetApproximatelyVisibleRegion
(
const
ScrollableLayerGuid
&
aGuid
)
{
return
mVisibleRegions
.
Get
(
aGuid
)
;
}
Compositor
*
GetCompositor
(
)
const
{
return
mCompositor
;
}
void
ChangeCompositor
(
Compositor
*
aNewCompositor
)
;
bool
DebugOverlayWantsNextFrame
(
)
{
return
mDebugOverlayWantsNextFrame
;
}
void
SetDebugOverlayWantsNextFrame
(
bool
aVal
)
{
mDebugOverlayWantsNextFrame
=
aVal
;
}
void
NotifyShadowTreeTransaction
(
)
;
TextRenderer
*
GetTextRenderer
(
)
{
return
mTextRenderer
;
}
void
VisualFrameWarning
(
float
severity
)
{
mozilla
:
:
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
mWarnTime
.
IsNull
(
)
|
|
severity
>
mWarningLevel
|
|
mWarnTime
+
TimeDuration
:
:
FromMilliseconds
(
kVisualWarningDuration
)
<
now
)
{
mWarnTime
=
now
;
mWarningLevel
=
severity
;
}
}
void
UnusedApzTransformWarning
(
)
{
mUnusedApzTransformWarning
=
true
;
}
void
DisabledApzWarning
(
)
{
mDisabledApzWarning
=
true
;
}
bool
LastFrameMissedHWC
(
)
{
return
mLastFrameMissedHWC
;
}
bool
AsyncPanZoomEnabled
(
)
const
override
;
void
AppendImageCompositeNotification
(
const
ImageCompositeNotification
&
aNotification
)
{
if
(
!
mCompositor
-
>
GetTargetContext
(
)
)
{
mImageCompositeNotifications
.
AppendElement
(
aNotification
)
;
}
}
void
ExtractImageCompositeNotifications
(
nsTArray
<
ImageCompositeNotification
>
*
aNotifications
)
{
aNotifications
-
>
AppendElements
(
Move
(
mImageCompositeNotifications
)
)
;
}
void
SetWindowOverlayChanged
(
)
{
mWindowOverlayChanged
=
true
;
}
void
ForcePresent
(
)
{
mCompositor
-
>
ForcePresent
(
)
;
}
void
SetPaintTime
(
const
TimeDuration
&
aPaintTime
)
{
mLastPaintTime
=
aPaintTime
;
}
private
:
nsIntRegion
mClippingRegion
;
gfx
:
:
IntRect
mRenderBounds
;
LayerComposite
*
RootLayer
(
)
const
;
void
UpdateAndRender
(
)
;
void
Render
(
const
nsIntRegion
&
aInvalidRegion
const
nsIntRegion
&
aOpaqueRegion
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
|
|
defined
(
MOZ_WIDGET_GONK
)
void
RenderToPresentationSurface
(
)
;
#
endif
void
DrawPaintTimes
(
Compositor
*
aCompositor
)
;
void
InvalidateDebugOverlay
(
nsIntRegion
&
aInvalidRegion
const
gfx
:
:
IntRect
&
aBounds
)
;
void
RenderDebugOverlay
(
const
gfx
:
:
IntRect
&
aBounds
)
;
RefPtr
<
CompositingRenderTarget
>
PushGroupForLayerEffects
(
)
;
void
PopGroupForLayerEffects
(
RefPtr
<
CompositingRenderTarget
>
aPreviousTarget
gfx
:
:
IntRect
aClipRect
bool
aGrayscaleEffect
bool
aInvertEffect
float
aContrastEffect
)
;
void
ChangeCompositorInternal
(
Compositor
*
aNewCompositor
)
;
float
mWarningLevel
;
mozilla
:
:
TimeStamp
mWarnTime
;
bool
mUnusedApzTransformWarning
;
bool
mDisabledApzWarning
;
RefPtr
<
Compositor
>
mCompositor
;
UniquePtr
<
LayerProperties
>
mClonedLayerTreeProperties
;
nsTArray
<
ImageCompositeNotification
>
mImageCompositeNotifications
;
RefPtr
<
gfx
:
:
DrawTarget
>
mTarget
;
gfx
:
:
IntRect
mTargetBounds
;
nsIntRegion
mInvalidRegion
;
typedef
nsClassHashtable
<
nsGenericHashKey
<
ScrollableLayerGuid
>
CSSIntRegion
>
VisibleRegions
;
VisibleRegions
mVisibleRegions
;
UniquePtr
<
FPSState
>
mFPS
;
bool
mInTransaction
;
bool
mIsCompositorReady
;
bool
mDebugOverlayWantsNextFrame
;
RefPtr
<
CompositingRenderTarget
>
mTwoPassTmpTarget
;
RefPtr
<
TextRenderer
>
mTextRenderer
;
bool
mGeometryChanged
;
bool
mLastFrameMissedHWC
;
bool
mWindowOverlayChanged
;
RefPtr
<
PaintCounter
>
mPaintCounter
;
TimeDuration
mLastPaintTime
;
TimeStamp
mRenderStartTime
;
}
;
class
LayerComposite
{
public
:
explicit
LayerComposite
(
LayerManagerComposite
*
aManager
)
;
virtual
~
LayerComposite
(
)
;
virtual
LayerComposite
*
GetFirstChildComposite
(
)
{
return
nullptr
;
}
virtual
void
Destroy
(
)
;
virtual
Layer
*
GetLayer
(
)
=
0
;
virtual
void
SetLayerManager
(
LayerManagerComposite
*
aManager
)
;
LayerManagerComposite
*
GetLayerManager
(
)
const
{
return
mCompositeManager
;
}
virtual
void
Prepare
(
const
RenderTargetIntRect
&
aClipRect
)
{
}
virtual
void
RenderLayer
(
const
gfx
:
:
IntRect
&
aClipRect
)
=
0
;
virtual
bool
SetCompositableHost
(
CompositableHost
*
)
{
NS_WARNING
(
"
called
SetCompositableHost
for
a
layer
type
not
accepting
a
compositable
"
)
;
return
false
;
}
virtual
CompositableHost
*
GetCompositableHost
(
)
=
0
;
virtual
void
CleanupResources
(
)
=
0
;
virtual
void
DestroyFrontBuffer
(
)
{
}
void
AddBlendModeEffect
(
EffectChain
&
aEffectChain
)
;
virtual
void
GenEffectChain
(
EffectChain
&
aEffect
)
{
}
void
SetShadowVisibleRegion
(
const
LayerIntRegion
&
aRegion
)
{
mShadowVisibleRegion
=
aRegion
;
}
void
SetShadowOpacity
(
float
aOpacity
)
{
mShadowOpacity
=
aOpacity
;
}
void
SetShadowOpacitySetByAnimation
(
bool
aSetByAnimation
)
{
mShadowOpacitySetByAnimation
=
aSetByAnimation
;
}
void
SetShadowClipRect
(
const
Maybe
<
ParentLayerIntRect
>
&
aRect
)
{
mShadowClipRect
=
aRect
;
}
void
SetShadowBaseTransform
(
const
gfx
:
:
Matrix4x4
&
aMatrix
)
{
mShadowTransform
=
aMatrix
;
}
void
SetShadowTransformSetByAnimation
(
bool
aSetByAnimation
)
{
mShadowTransformSetByAnimation
=
aSetByAnimation
;
}
void
SetLayerComposited
(
bool
value
)
{
mLayerComposited
=
value
;
}
void
SetClearRect
(
const
gfx
:
:
IntRect
&
aRect
)
{
mClearRect
=
aRect
;
}
float
GetShadowOpacity
(
)
{
return
mShadowOpacity
;
}
const
Maybe
<
ParentLayerIntRect
>
&
GetShadowClipRect
(
)
{
return
mShadowClipRect
;
}
const
LayerIntRegion
&
GetShadowVisibleRegion
(
)
{
return
mShadowVisibleRegion
;
}
const
gfx
:
:
Matrix4x4
&
GetShadowBaseTransform
(
)
{
return
mShadowTransform
;
}
gfx
:
:
Matrix4x4
GetShadowTransform
(
)
;
bool
GetShadowTransformSetByAnimation
(
)
{
return
mShadowTransformSetByAnimation
;
}
bool
GetShadowOpacitySetByAnimation
(
)
{
return
mShadowOpacitySetByAnimation
;
}
bool
HasLayerBeenComposited
(
)
{
return
mLayerComposited
;
}
gfx
:
:
IntRect
GetClearRect
(
)
{
return
mClearRect
;
}
bool
HasStaleCompositor
(
)
const
;
virtual
nsIntRegion
GetFullyRenderedRegion
(
)
;
bool
NeedToDrawCheckerboarding
(
gfx
:
:
Color
*
aOutCheckerboardingColor
=
nullptr
)
;
protected
:
gfx
:
:
Matrix4x4
mShadowTransform
;
LayerIntRegion
mShadowVisibleRegion
;
Maybe
<
ParentLayerIntRect
>
mShadowClipRect
;
LayerManagerComposite
*
mCompositeManager
;
RefPtr
<
Compositor
>
mCompositor
;
float
mShadowOpacity
;
bool
mShadowTransformSetByAnimation
;
bool
mShadowOpacitySetByAnimation
;
bool
mDestroyed
;
bool
mLayerComposited
;
gfx
:
:
IntRect
mClearRect
;
}
;
template
<
typename
RenderCallbackType
>
void
RenderWithAllMasks
(
Layer
*
aLayer
Compositor
*
aCompositor
const
gfx
:
:
IntRect
&
aClipRect
RenderCallbackType
aRenderCallback
)
{
Layer
*
firstMask
=
nullptr
;
size_t
maskLayerCount
=
0
;
size_t
nextAncestorMaskLayer
=
0
;
size_t
ancestorMaskLayerCount
=
aLayer
-
>
GetAncestorMaskLayerCount
(
)
;
if
(
Layer
*
ownMask
=
aLayer
-
>
GetMaskLayer
(
)
)
{
firstMask
=
ownMask
;
maskLayerCount
=
ancestorMaskLayerCount
+
1
;
nextAncestorMaskLayer
=
0
;
}
else
if
(
ancestorMaskLayerCount
>
0
)
{
firstMask
=
aLayer
-
>
GetAncestorMaskLayerAt
(
0
)
;
maskLayerCount
=
ancestorMaskLayerCount
;
nextAncestorMaskLayer
=
1
;
}
else
{
}
if
(
maskLayerCount
<
=
1
)
{
EffectChain
effectChain
(
aLayer
)
;
LayerManagerComposite
:
:
AutoAddMaskEffect
autoMaskEffect
(
firstMask
effectChain
)
;
aLayer
-
>
AsLayerComposite
(
)
-
>
AddBlendModeEffect
(
effectChain
)
;
aRenderCallback
(
effectChain
aClipRect
)
;
return
;
}
gfx
:
:
Rect
visibleRect
(
aLayer
-
>
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
.
GetBounds
(
)
)
;
gfx
:
:
Matrix4x4
transform
=
aLayer
-
>
GetEffectiveTransform
(
)
;
gfx
:
:
IntRect
surfaceRect
=
RoundedOut
(
transform
.
TransformAndClipBounds
(
visibleRect
gfx
:
:
Rect
(
aClipRect
)
)
)
;
if
(
surfaceRect
.
IsEmpty
(
)
)
{
return
;
}
RefPtr
<
CompositingRenderTarget
>
originalTarget
=
aCompositor
-
>
GetCurrentRenderTarget
(
)
;
RefPtr
<
CompositingRenderTarget
>
firstTarget
=
aCompositor
-
>
CreateRenderTarget
(
surfaceRect
INIT_MODE_CLEAR
)
;
if
(
!
firstTarget
)
{
return
;
}
aCompositor
-
>
SetRenderTarget
(
firstTarget
)
;
{
EffectChain
firstEffectChain
(
aLayer
)
;
LayerManagerComposite
:
:
AutoAddMaskEffect
firstMaskEffect
(
firstMask
firstEffectChain
)
;
aRenderCallback
(
firstEffectChain
aClipRect
-
surfaceRect
.
TopLeft
(
)
)
;
}
gfx
:
:
IntRect
intermediateClip
(
surfaceRect
-
surfaceRect
.
TopLeft
(
)
)
;
RefPtr
<
CompositingRenderTarget
>
previousTarget
=
firstTarget
;
for
(
size_t
i
=
nextAncestorMaskLayer
;
i
<
ancestorMaskLayerCount
-
1
;
i
+
+
)
{
Layer
*
intermediateMask
=
aLayer
-
>
GetAncestorMaskLayerAt
(
i
)
;
RefPtr
<
CompositingRenderTarget
>
intermediateTarget
=
aCompositor
-
>
CreateRenderTarget
(
surfaceRect
INIT_MODE_CLEAR
)
;
if
(
!
intermediateTarget
)
{
break
;
}
aCompositor
-
>
SetRenderTarget
(
intermediateTarget
)
;
EffectChain
intermediateEffectChain
(
aLayer
)
;
LayerManagerComposite
:
:
AutoAddMaskEffect
intermediateMaskEffect
(
intermediateMask
intermediateEffectChain
)
;
if
(
intermediateMaskEffect
.
Failed
(
)
)
{
continue
;
}
intermediateEffectChain
.
mPrimaryEffect
=
new
EffectRenderTarget
(
previousTarget
)
;
aCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
surfaceRect
)
intermediateClip
intermediateEffectChain
1
.
0
gfx
:
:
Matrix4x4
(
)
)
;
previousTarget
=
intermediateTarget
;
}
aCompositor
-
>
SetRenderTarget
(
originalTarget
)
;
EffectChain
finalEffectChain
(
aLayer
)
;
finalEffectChain
.
mPrimaryEffect
=
new
EffectRenderTarget
(
previousTarget
)
;
Layer
*
finalMask
=
aLayer
-
>
GetAncestorMaskLayerAt
(
ancestorMaskLayerCount
-
1
)
;
aLayer
-
>
AsLayerComposite
(
)
-
>
AddBlendModeEffect
(
finalEffectChain
)
;
LayerManagerComposite
:
:
AutoAddMaskEffect
autoMaskEffect
(
finalMask
finalEffectChain
)
;
if
(
!
autoMaskEffect
.
Failed
(
)
)
{
aCompositor
-
>
DrawQuad
(
gfx
:
:
Rect
(
surfaceRect
)
aClipRect
finalEffectChain
1
.
0
gfx
:
:
Matrix4x4
(
)
)
;
}
}
}
}
#
endif
