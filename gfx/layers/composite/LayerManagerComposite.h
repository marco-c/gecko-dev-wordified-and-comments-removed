#
ifndef
GFX_LayerManagerComposite_H
#
define
GFX_LayerManagerComposite_H
#
include
<
cstdint
>
#
include
<
deque
>
#
include
<
new
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
CompositableHost
.
h
"
#
include
"
Units
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Polygon
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
CompositionRecorder
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
LayerManager
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
ScreenshotGrabber
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsRegionFwd
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
class
gfxContext
;
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
endif
namespace
mozilla
{
namespace
layers
{
class
CanvasLayer
;
class
CanvasLayerComposite
;
class
ColorLayer
;
class
ColorLayerComposite
;
class
ContainerLayer
;
class
ContainerLayerComposite
;
class
Diagnostics
;
struct
EffectChain
;
class
ImageLayer
;
class
ImageLayerComposite
;
class
LayerComposite
;
class
NativeLayer
;
class
NativeLayerRoot
;
class
RefLayerComposite
;
class
PaintTiming
;
class
PaintedLayer
;
class
PaintedLayerComposite
;
class
RefLayer
;
class
SurfacePoolHandle
;
class
TextRenderer
;
class
TextureSourceProvider
;
class
CompositingRenderTarget
;
struct
FPSState
;
class
PaintCounter
;
class
UiCompositorControllerParent
;
class
Layer
;
struct
LayerProperties
;
static
const
int
kVisualWarningDuration
=
150
;
class
HostLayerManager
:
public
LayerManager
{
public
:
HostLayerManager
(
)
;
virtual
~
HostLayerManager
(
)
;
bool
BeginTransactionWithTarget
(
gfxContext
*
aTarget
const
nsCString
&
aURL
)
override
{
MOZ_CRASH
(
"
GFX
:
Use
BeginTransactionWithDrawTarget
"
)
;
}
bool
EndEmptyTransaction
(
EndTransactionFlags
aFlags
=
END_DEFAULT
)
override
{
MOZ_CRASH
(
"
GFX
:
Use
EndTransaction
(
aTimeStamp
)
"
)
;
return
false
;
}
void
EndTransaction
(
DrawPaintedLayerCallback
aCallback
void
*
aCallbackData
EndTransactionFlags
aFlags
=
END_DEFAULT
)
override
{
MOZ_CRASH
(
"
GFX
:
Use
EndTransaction
(
aTimeStamp
)
"
)
;
}
int32_t
GetMaxTextureSize
(
)
const
override
{
MOZ_CRASH
(
"
GFX
:
Call
on
compositor
not
LayerManagerComposite
"
)
;
}
void
GetBackendName
(
nsAString
&
name
)
override
{
MOZ_CRASH
(
"
GFX
:
Shouldn
'
t
be
called
for
composited
layer
manager
"
)
;
}
virtual
void
ForcePresent
(
)
=
0
;
virtual
void
AddInvalidRegion
(
const
nsIntRegion
&
aRegion
)
=
0
;
virtual
void
NotifyShadowTreeTransaction
(
)
{
}
virtual
void
BeginTransactionWithDrawTarget
(
gfx
:
:
DrawTarget
*
aTarget
const
gfx
:
:
IntRect
&
aRect
)
=
0
;
virtual
Compositor
*
GetCompositor
(
)
const
=
0
;
virtual
TextureSourceProvider
*
GetTextureSourceProvider
(
)
const
=
0
;
virtual
void
EndTransaction
(
const
TimeStamp
&
aTimeStamp
EndTransactionFlags
aFlags
=
END_DEFAULT
)
=
0
;
virtual
void
UpdateRenderBounds
(
const
gfx
:
:
IntRect
&
aRect
)
{
}
virtual
void
SetDiagnosticTypes
(
DiagnosticTypes
aDiagnostics
)
{
}
virtual
void
InvalidateAll
(
)
=
0
;
HostLayerManager
*
AsHostLayerManager
(
)
override
{
return
this
;
}
void
ExtractImageCompositeNotifications
(
nsTArray
<
ImageCompositeNotificationInfo
>
*
aNotifications
)
{
aNotifications
-
>
AppendElements
(
std
:
:
move
(
mImageCompositeNotifications
)
)
;
}
void
AppendImageCompositeNotification
(
const
ImageCompositeNotificationInfo
&
aNotification
)
{
if
(
IsCompositingToScreen
(
)
)
{
mImageCompositeNotifications
.
AppendElement
(
aNotification
)
;
}
}
bool
DebugOverlayWantsNextFrame
(
)
{
return
mDebugOverlayWantsNextFrame
;
}
void
SetDebugOverlayWantsNextFrame
(
bool
aVal
)
{
mDebugOverlayWantsNextFrame
=
aVal
;
}
void
VisualFrameWarning
(
float
severity
)
{
mozilla
:
:
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
mWarnTime
.
IsNull
(
)
|
|
severity
>
mWarningLevel
|
|
mWarnTime
+
TimeDuration
:
:
FromMilliseconds
(
kVisualWarningDuration
)
<
now
)
{
mWarnTime
=
now
;
mWarningLevel
=
severity
;
}
}
void
SetPaintTime
(
const
TimeDuration
&
aPaintTime
)
{
mLastPaintTime
=
aPaintTime
;
}
virtual
bool
AlwaysScheduleComposite
(
)
const
{
return
false
;
}
virtual
bool
IsCompositingToScreen
(
)
const
{
return
false
;
}
void
RecordPaintTimes
(
const
PaintTiming
&
aTiming
)
;
void
RecordUpdateTime
(
float
aValue
)
;
CompositionOpportunityId
GetCompositionOpportunityId
(
)
const
{
return
mCompositionOpportunityId
;
}
TimeStamp
GetCompositionTime
(
)
const
{
return
mCompositionTime
;
}
void
SetCompositionTime
(
TimeStamp
aTimeStamp
)
{
mCompositionTime
=
aTimeStamp
;
if
(
!
mCompositionTime
.
IsNull
(
)
&
&
!
mCompositeUntilTime
.
IsNull
(
)
&
&
mCompositionTime
>
=
mCompositeUntilTime
)
{
mCompositeUntilTime
=
TimeStamp
(
)
;
}
}
void
CompositeUntil
(
TimeStamp
aTimeStamp
)
{
if
(
mCompositeUntilTime
.
IsNull
(
)
|
|
mCompositeUntilTime
<
aTimeStamp
)
{
mCompositeUntilTime
=
aTimeStamp
;
}
}
TimeStamp
GetCompositeUntilTime
(
)
const
{
return
mCompositeUntilTime
;
}
uint64_t
GetCompositorBridgeID
(
)
const
{
return
mCompositorBridgeID
;
}
void
SetCompositorBridgeID
(
uint64_t
aID
)
{
MOZ_ASSERT
(
mCompositorBridgeID
=
=
0
"
The
compositor
ID
must
be
set
only
once
.
"
)
;
mCompositorBridgeID
=
aID
;
}
void
SetCompositionRecorder
(
UniquePtr
<
CompositionRecorder
>
aRecorder
)
{
mCompositionRecorder
=
std
:
:
move
(
aRecorder
)
;
}
void
WriteCollectedFrames
(
)
;
Maybe
<
CollectedFrames
>
GetCollectedFrames
(
)
;
protected
:
bool
mDebugOverlayWantsNextFrame
;
nsTArray
<
ImageCompositeNotificationInfo
>
mImageCompositeNotifications
;
float
mWarningLevel
;
mozilla
:
:
TimeStamp
mWarnTime
;
UniquePtr
<
Diagnostics
>
mDiagnostics
;
uint64_t
mCompositorBridgeID
;
TimeDuration
mLastPaintTime
;
TimeStamp
mRenderStartTime
;
UniquePtr
<
CompositionRecorder
>
mCompositionRecorder
=
nullptr
;
TimeStamp
mCompositionTime
;
CompositionOpportunityId
mCompositionOpportunityId
;
TimeStamp
mCompositeUntilTime
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
public
:
virtual
void
RequestScreenPixels
(
UiCompositorControllerParent
*
aController
)
{
}
#
endif
}
;
class
LayerManagerComposite
final
:
public
HostLayerManager
{
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
typedef
mozilla
:
:
gfx
:
:
IntSize
IntSize
;
typedef
mozilla
:
:
gfx
:
:
SurfaceFormat
SurfaceFormat
;
public
:
explicit
LayerManagerComposite
(
Compositor
*
aCompositor
)
;
virtual
~
LayerManagerComposite
(
)
;
void
Destroy
(
)
override
;
void
SetClippingRegion
(
const
nsIntRegion
&
aClippingRegion
)
{
mClippingRegion
=
aClippingRegion
;
}
LayerManagerComposite
*
AsLayerManagerComposite
(
)
override
{
return
this
;
}
void
UpdateRenderBounds
(
const
gfx
:
:
IntRect
&
aRect
)
override
;
bool
BeginTransaction
(
const
nsCString
&
aURL
)
override
;
void
BeginTransactionWithDrawTarget
(
gfx
:
:
DrawTarget
*
aTarget
const
gfx
:
:
IntRect
&
aRect
)
override
;
void
EndTransaction
(
const
TimeStamp
&
aTimeStamp
EndTransactionFlags
aFlags
=
END_DEFAULT
)
override
;
virtual
void
EndTransaction
(
DrawPaintedLayerCallback
aCallback
void
*
aCallbackData
EndTransactionFlags
aFlags
=
END_DEFAULT
)
override
{
MOZ_CRASH
(
"
GFX
:
Use
EndTransaction
(
aTimeStamp
)
"
)
;
}
void
SetRoot
(
Layer
*
aLayer
)
override
;
bool
CanUseCanvasLayerForSize
(
const
gfx
:
:
IntSize
&
aSize
)
override
;
void
ClearCachedResources
(
Layer
*
aSubtree
=
nullptr
)
override
;
already_AddRefed
<
PaintedLayer
>
CreatePaintedLayer
(
)
override
;
already_AddRefed
<
ContainerLayer
>
CreateContainerLayer
(
)
override
;
already_AddRefed
<
ImageLayer
>
CreateImageLayer
(
)
override
;
already_AddRefed
<
ColorLayer
>
CreateColorLayer
(
)
override
;
already_AddRefed
<
CanvasLayer
>
CreateCanvasLayer
(
)
override
;
already_AddRefed
<
RefLayer
>
CreateRefLayer
(
)
override
;
bool
AreComponentAlphaLayersEnabled
(
)
override
;
already_AddRefed
<
DrawTarget
>
CreateOptimalMaskDrawTarget
(
const
IntSize
&
aSize
)
override
;
const
char
*
Name
(
)
const
override
{
return
"
"
;
}
bool
IsCompositingToScreen
(
)
const
override
;
bool
AlwaysScheduleComposite
(
)
const
override
;
void
PostProcessLayers
(
nsIntRegion
&
aOpaqueRegion
)
;
void
PostProcessLayers
(
Layer
*
aLayer
nsIntRegion
&
aOpaqueRegion
LayerIntRegion
&
aVisibleRegion
const
Maybe
<
RenderTargetIntRect
>
&
aRenderTargetClip
const
Maybe
<
ParentLayerIntRect
>
&
aClipFromAncestors
bool
aCanContributeOpaque
)
;
class
AutoAddMaskEffect
{
public
:
AutoAddMaskEffect
(
Layer
*
aMaskLayer
EffectChain
&
aEffect
)
;
~
AutoAddMaskEffect
(
)
;
bool
Failed
(
)
const
{
return
mFailed
;
}
private
:
CompositableHost
*
mCompositable
;
bool
mFailed
;
}
;
static
bool
SupportsDirectTexturing
(
)
;
static
void
PlatformSyncBeforeReplyUpdate
(
)
;
void
AddInvalidRegion
(
const
nsIntRegion
&
aRegion
)
override
{
mInvalidRegion
.
Or
(
mInvalidRegion
aRegion
)
;
}
Compositor
*
GetCompositor
(
)
const
override
{
return
mCompositor
;
}
TextureSourceProvider
*
GetTextureSourceProvider
(
)
const
override
{
return
mCompositor
;
}
void
NotifyShadowTreeTransaction
(
)
override
;
TextRenderer
*
GetTextRenderer
(
)
{
return
mTextRenderer
;
}
void
UnusedApzTransformWarning
(
)
{
mUnusedApzTransformWarning
=
true
;
}
void
DisabledApzWarning
(
)
{
mDisabledApzWarning
=
true
;
}
bool
AsyncPanZoomEnabled
(
)
const
override
;
public
:
TextureFactoryIdentifier
GetTextureFactoryIdentifier
(
)
override
{
return
mCompositor
-
>
GetTextureFactoryIdentifier
(
)
;
}
LayersBackend
GetBackendType
(
)
override
{
return
mCompositor
?
mCompositor
-
>
GetBackendType
(
)
:
LayersBackend
:
:
LAYERS_NONE
;
}
void
SetDiagnosticTypes
(
DiagnosticTypes
aDiagnostics
)
override
{
mCompositor
-
>
SetDiagnosticTypes
(
aDiagnostics
)
;
}
void
InvalidateAll
(
)
override
{
AddInvalidRegion
(
nsIntRegion
(
mRenderBounds
)
)
;
}
void
ForcePresent
(
)
override
{
mCompositor
-
>
ForcePresent
(
)
;
}
private
:
nsIntRegion
mClippingRegion
;
gfx
:
:
IntRect
mRenderBounds
;
LayerComposite
*
RootLayer
(
)
const
;
void
UpdateAndRender
(
)
;
bool
Render
(
const
nsIntRegion
&
aInvalidRegion
const
nsIntRegion
&
aOpaqueRegion
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
void
RenderToPresentationSurface
(
)
;
ScreenCoord
GetContentShiftForToolbar
(
)
;
void
RenderToolbar
(
)
;
void
HandlePixelsTarget
(
)
;
#
endif
void
InvalidateDebugOverlay
(
nsIntRegion
&
aInvalidRegion
const
gfx
:
:
IntRect
&
aBounds
)
;
void
RenderDebugOverlay
(
const
gfx
:
:
IntRect
&
aBounds
)
;
void
DrawBorder
(
const
gfx
:
:
IntRect
&
aOuter
int32_t
aBorderWidth
const
gfx
:
:
DeviceColor
&
aColor
const
gfx
:
:
Matrix4x4
&
aTransform
)
;
void
DrawTranslationWarningOverlay
(
const
gfx
:
:
IntRect
&
aBounds
)
;
void
UpdateDebugOverlayNativeLayers
(
)
;
RefPtr
<
CompositingRenderTarget
>
PushGroupForLayerEffects
(
)
;
void
PopGroupForLayerEffects
(
RefPtr
<
CompositingRenderTarget
>
aPreviousTarget
gfx
:
:
IntRect
aClipRect
bool
aGrayscaleEffect
bool
aInvertEffect
float
aContrastEffect
)
;
void
PlaceNativeLayers
(
const
gfx
:
:
IntRegion
&
aRegion
bool
aOpaque
std
:
:
deque
<
RefPtr
<
NativeLayer
>
>
*
aLayersToRecycle
gfx
:
:
IntRegion
*
aWindowInvalidRegion
)
;
void
PlaceNativeLayer
(
const
gfx
:
:
IntRect
&
aRect
bool
aOpaque
std
:
:
deque
<
RefPtr
<
NativeLayer
>
>
*
aLayersToRecycle
gfx
:
:
IntRegion
*
aWindowInvalidRegion
)
;
bool
mUnusedApzTransformWarning
;
bool
mDisabledApzWarning
;
RefPtr
<
Compositor
>
mCompositor
;
UniquePtr
<
LayerProperties
>
mClonedLayerTreeProperties
;
RefPtr
<
gfx
:
:
DrawTarget
>
mTarget
;
gfx
:
:
IntRect
mTargetBounds
;
nsIntRegion
mInvalidRegion
;
bool
mInTransaction
;
bool
mIsCompositorReady
;
RefPtr
<
CompositingRenderTarget
>
mTwoPassTmpTarget
;
ScreenshotGrabber
mProfilerScreenshotGrabber
;
RefPtr
<
TextRenderer
>
mTextRenderer
;
RefPtr
<
NativeLayerRoot
>
mNativeLayerRoot
;
RefPtr
<
SurfacePoolHandle
>
mSurfacePoolHandle
;
std
:
:
deque
<
RefPtr
<
NativeLayer
>
>
mNativeLayers
;
RefPtr
<
NativeLayer
>
mGPUStatsLayer
;
RefPtr
<
NativeLayer
>
mUnusedTransformWarningLayer
;
RefPtr
<
NativeLayer
>
mDisabledApzWarningLayer
;
void
DrawPaintTimes
(
Compositor
*
aCompositor
)
;
RefPtr
<
PaintCounter
>
mPaintCounter
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
public
:
virtual
void
RequestScreenPixels
(
UiCompositorControllerParent
*
aController
)
override
{
mScreenPixelsTarget
=
aController
;
}
private
:
UiCompositorControllerParent
*
mScreenPixelsTarget
;
#
endif
}
;
class
HostLayer
{
public
:
explicit
HostLayer
(
HostLayerManager
*
aManager
)
:
mCompositorManager
(
aManager
)
mShadowOpacity
(
1
.
0
)
mShadowTransformSetByAnimation
(
false
)
mShadowOpacitySetByAnimation
(
false
)
{
}
virtual
void
SetLayerManager
(
HostLayerManager
*
aManager
)
{
mCompositorManager
=
aManager
;
}
HostLayerManager
*
GetLayerManager
(
)
const
{
return
mCompositorManager
;
}
virtual
~
HostLayer
(
)
=
default
;
virtual
LayerComposite
*
GetFirstChildComposite
(
)
{
return
nullptr
;
}
virtual
Layer
*
GetLayer
(
)
=
0
;
virtual
bool
SetCompositableHost
(
CompositableHost
*
)
{
NS_WARNING
(
"
called
SetCompositableHost
for
a
layer
type
not
accepting
a
"
"
compositable
"
)
;
return
false
;
}
virtual
CompositableHost
*
GetCompositableHost
(
)
=
0
;
void
SetShadowVisibleRegion
(
const
LayerIntRegion
&
aRegion
)
{
mShadowVisibleRegion
=
aRegion
;
}
void
SetShadowVisibleRegion
(
LayerIntRegion
&
&
aRegion
)
{
mShadowVisibleRegion
=
std
:
:
move
(
aRegion
)
;
}
void
SetShadowOpacity
(
float
aOpacity
)
{
mShadowOpacity
=
aOpacity
;
}
void
SetShadowOpacitySetByAnimation
(
bool
aSetByAnimation
)
{
mShadowOpacitySetByAnimation
=
aSetByAnimation
;
}
void
SetShadowClipRect
(
const
Maybe
<
ParentLayerIntRect
>
&
aRect
)
{
mShadowClipRect
=
aRect
;
}
void
SetShadowBaseTransform
(
const
gfx
:
:
Matrix4x4
&
aMatrix
)
{
mShadowTransform
=
aMatrix
;
}
void
SetShadowTransformSetByAnimation
(
bool
aSetByAnimation
)
{
mShadowTransformSetByAnimation
=
aSetByAnimation
;
}
float
GetShadowOpacity
(
)
{
return
mShadowOpacity
;
}
const
Maybe
<
ParentLayerIntRect
>
&
GetShadowClipRect
(
)
{
return
mShadowClipRect
;
}
virtual
const
LayerIntRegion
&
GetShadowVisibleRegion
(
)
{
return
mShadowVisibleRegion
;
}
const
gfx
:
:
Matrix4x4
&
GetShadowBaseTransform
(
)
{
return
mShadowTransform
;
}
gfx
:
:
Matrix4x4
GetShadowTransform
(
)
;
bool
GetShadowTransformSetByAnimation
(
)
{
return
mShadowTransformSetByAnimation
;
}
bool
GetShadowOpacitySetByAnimation
(
)
{
return
mShadowOpacitySetByAnimation
;
}
void
RecomputeShadowVisibleRegionFromChildren
(
)
;
protected
:
HostLayerManager
*
mCompositorManager
;
gfx
:
:
Matrix4x4
mShadowTransform
;
LayerIntRegion
mShadowVisibleRegion
;
Maybe
<
ParentLayerIntRect
>
mShadowClipRect
;
float
mShadowOpacity
;
bool
mShadowTransformSetByAnimation
;
bool
mShadowOpacitySetByAnimation
;
}
;
class
LayerComposite
:
public
HostLayer
{
public
:
explicit
LayerComposite
(
LayerManagerComposite
*
aManager
)
;
virtual
~
LayerComposite
(
)
;
void
SetLayerManager
(
HostLayerManager
*
aManager
)
override
;
LayerComposite
*
GetFirstChildComposite
(
)
override
{
return
nullptr
;
}
virtual
void
Destroy
(
)
;
virtual
void
Cleanup
(
)
{
}
virtual
void
Prepare
(
const
RenderTargetIntRect
&
aClipRect
)
{
}
virtual
void
RenderLayer
(
const
gfx
:
:
IntRect
&
aClipRect
const
Maybe
<
gfx
:
:
Polygon
>
&
aGeometry
)
=
0
;
bool
SetCompositableHost
(
CompositableHost
*
)
override
{
NS_WARNING
(
"
called
SetCompositableHost
for
a
layer
type
not
accepting
a
"
"
compositable
"
)
;
return
false
;
}
virtual
void
CleanupResources
(
)
=
0
;
virtual
void
DestroyFrontBuffer
(
)
{
}
void
AddBlendModeEffect
(
EffectChain
&
aEffectChain
)
;
virtual
void
GenEffectChain
(
EffectChain
&
aEffect
)
{
}
void
SetLayerComposited
(
bool
value
)
{
mLayerComposited
=
value
;
}
void
SetClearRect
(
const
gfx
:
:
IntRect
&
aRect
)
{
mClearRect
=
aRect
;
}
bool
HasLayerBeenComposited
(
)
{
return
mLayerComposited
;
}
gfx
:
:
IntRect
GetClearRect
(
)
{
return
mClearRect
;
}
bool
HasStaleCompositor
(
)
const
;
virtual
nsIntRegion
GetFullyRenderedRegion
(
)
;
protected
:
LayerManagerComposite
*
mCompositeManager
;
RefPtr
<
Compositor
>
mCompositor
;
bool
mDestroyed
;
bool
mLayerComposited
;
gfx
:
:
IntRect
mClearRect
;
}
;
class
WindowLMC
:
public
profiler_screenshots
:
:
Window
{
public
:
explicit
WindowLMC
(
Compositor
*
aCompositor
)
:
mCompositor
(
aCompositor
)
{
}
already_AddRefed
<
profiler_screenshots
:
:
RenderSource
>
GetWindowContents
(
const
gfx
:
:
IntSize
&
aWindowSize
)
override
;
already_AddRefed
<
profiler_screenshots
:
:
DownscaleTarget
>
CreateDownscaleTarget
(
const
gfx
:
:
IntSize
&
aSize
)
override
;
already_AddRefed
<
profiler_screenshots
:
:
AsyncReadbackBuffer
>
CreateAsyncReadbackBuffer
(
const
gfx
:
:
IntSize
&
aSize
)
override
;
protected
:
Compositor
*
mCompositor
;
}
;
}
}
#
endif
