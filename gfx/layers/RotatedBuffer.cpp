#
include
"
RotatedBuffer
.
h
"
#
include
<
sys
/
types
.
h
>
#
include
<
algorithm
>
#
include
"
BasicImplData
.
h
"
#
include
"
BasicLayersImpl
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
Layers
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
gfx
/
BasePoint
.
h
"
#
include
"
mozilla
/
gfx
/
BaseRect
.
h
"
#
include
"
mozilla
/
gfx
/
BaseSize
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
ShadowLayers
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
PaintThread
.
h
"
namespace
mozilla
{
using
namespace
gfx
;
namespace
layers
{
void
BorrowDrawTarget
:
:
ReturnDrawTarget
(
gfx
:
:
DrawTarget
*
&
aReturned
)
{
MOZ_ASSERT
(
mLoanedDrawTarget
)
;
MOZ_ASSERT
(
aReturned
=
=
mLoanedDrawTarget
)
;
if
(
mLoanedDrawTarget
)
{
mLoanedDrawTarget
-
>
SetTransform
(
mLoanedTransform
)
;
mLoanedDrawTarget
=
nullptr
;
}
aReturned
=
nullptr
;
}
IntRect
RotatedBuffer
:
:
GetQuadrantRectangle
(
XSide
aXSide
YSide
aYSide
)
const
{
IntPoint
quadrantTranslation
=
-
mBufferRotation
;
quadrantTranslation
.
x
+
=
aXSide
=
=
LEFT
?
mBufferRect
.
Width
(
)
:
0
;
quadrantTranslation
.
y
+
=
aYSide
=
=
TOP
?
mBufferRect
.
Height
(
)
:
0
;
return
mBufferRect
+
quadrantTranslation
;
}
Rect
RotatedBuffer
:
:
GetSourceRectangle
(
XSide
aXSide
YSide
aYSide
)
const
{
Rect
result
;
if
(
aXSide
=
=
LEFT
)
{
result
.
SetBoxX
(
0
mBufferRotation
.
x
)
;
}
else
{
result
.
SetBoxX
(
mBufferRotation
.
x
mBufferRect
.
Width
(
)
)
;
}
if
(
aYSide
=
=
TOP
)
{
result
.
SetBoxY
(
0
mBufferRotation
.
y
)
;
}
else
{
result
.
SetBoxY
(
mBufferRotation
.
y
mBufferRect
.
Height
(
)
)
;
}
return
result
;
}
void
RotatedBuffer
:
:
BeginCapture
(
)
{
RefPtr
<
gfx
:
:
DrawTarget
>
target
=
GetBufferTarget
(
)
;
MOZ_ASSERT
(
!
mCapture
)
;
MOZ_ASSERT
(
target
)
;
mCapture
=
Factory
:
:
CreateCaptureDrawTargetForTarget
(
target
StaticPrefs
:
:
layers_omtp_capture_limit
(
)
)
;
}
RefPtr
<
gfx
:
:
DrawTargetCapture
>
RotatedBuffer
:
:
EndCapture
(
)
{
MOZ_ASSERT
(
mCapture
)
;
return
std
:
:
move
(
mCapture
)
;
}
void
RotatedBuffer
:
:
DrawBufferQuadrant
(
gfx
:
:
DrawTarget
*
aTarget
XSide
aXSide
YSide
aYSide
float
aOpacity
gfx
:
:
CompositionOp
aOperator
gfx
:
:
SourceSurface
*
aMask
const
gfx
:
:
Matrix
*
aMaskTransform
)
const
{
IntRect
quadrantRect
=
GetQuadrantRectangle
(
aXSide
aYSide
)
;
IntRect
fillRect
;
if
(
!
fillRect
.
IntersectRect
(
mBufferRect
quadrantRect
)
)
return
;
gfx
:
:
Point
quadrantTranslation
(
quadrantRect
.
X
(
)
quadrantRect
.
Y
(
)
)
;
RefPtr
<
SourceSurface
>
snapshot
=
GetBufferSource
(
)
;
if
(
!
snapshot
)
{
gfxCriticalError
(
)
<
<
"
Invalid
snapshot
in
RotatedBuffer
:
:
DrawBufferQuadrant
"
;
return
;
}
if
(
(
aTarget
-
>
GetBackendType
(
)
=
=
BackendType
:
:
DIRECT2D
|
|
aTarget
-
>
GetBackendType
(
)
=
=
BackendType
:
:
DIRECT2D1_1
)
&
&
aOperator
=
=
CompositionOp
:
:
OP_SOURCE
)
{
aOperator
=
CompositionOp
:
:
OP_OVER
;
if
(
snapshot
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
B8G8R8A8
)
{
aTarget
-
>
ClearRect
(
IntRectToRect
(
fillRect
)
)
;
}
}
aTarget
-
>
PushClipRect
(
IntRectToRect
(
fillRect
)
)
;
if
(
aMask
)
{
Matrix
oldTransform
=
aTarget
-
>
GetTransform
(
)
;
Matrix
transform
=
Matrix
:
:
Translation
(
quadrantTranslation
.
x
quadrantTranslation
.
y
)
;
Matrix
inverseMask
=
*
aMaskTransform
;
inverseMask
.
Invert
(
)
;
transform
*
=
oldTransform
;
transform
*
=
inverseMask
;
#
ifdef
MOZ_GFX_OPTIMIZE_MOBILE
SurfacePattern
source
(
snapshot
ExtendMode
:
:
CLAMP
transform
SamplingFilter
:
:
POINT
)
;
#
else
SurfacePattern
source
(
snapshot
ExtendMode
:
:
CLAMP
transform
)
;
#
endif
aTarget
-
>
SetTransform
(
*
aMaskTransform
)
;
aTarget
-
>
MaskSurface
(
source
aMask
Point
(
0
0
)
DrawOptions
(
aOpacity
aOperator
)
)
;
aTarget
-
>
SetTransform
(
oldTransform
)
;
}
else
{
#
ifdef
MOZ_GFX_OPTIMIZE_MOBILE
DrawSurfaceOptions
options
(
SamplingFilter
:
:
POINT
)
;
#
else
DrawSurfaceOptions
options
;
#
endif
aTarget
-
>
DrawSurface
(
snapshot
IntRectToRect
(
fillRect
)
GetSourceRectangle
(
aXSide
aYSide
)
options
DrawOptions
(
aOpacity
aOperator
)
)
;
}
aTarget
-
>
PopClip
(
)
;
}
void
RotatedBuffer
:
:
DrawBufferWithRotation
(
gfx
:
:
DrawTarget
*
aTarget
float
aOpacity
gfx
:
:
CompositionOp
aOperator
gfx
:
:
SourceSurface
*
aMask
const
gfx
:
:
Matrix
*
aMaskTransform
)
const
{
AUTO_PROFILER_LABEL
(
"
RotatedBuffer
:
:
DrawBufferWithRotation
"
GRAPHICS
)
;
DrawBufferQuadrant
(
aTarget
LEFT
TOP
aOpacity
aOperator
aMask
aMaskTransform
)
;
DrawBufferQuadrant
(
aTarget
RIGHT
TOP
aOpacity
aOperator
aMask
aMaskTransform
)
;
DrawBufferQuadrant
(
aTarget
LEFT
BOTTOM
aOpacity
aOperator
aMask
aMaskTransform
)
;
DrawBufferQuadrant
(
aTarget
RIGHT
BOTTOM
aOpacity
aOperator
aMask
aMaskTransform
)
;
}
static
bool
IsClippingCheap
(
gfx
:
:
DrawTarget
*
aTarget
const
nsIntRegion
&
aRegion
)
{
return
!
aTarget
-
>
GetTransform
(
)
.
HasNonIntegerTranslation
(
)
&
&
aRegion
.
GetNumRects
(
)
<
=
1
;
}
void
RotatedBuffer
:
:
DrawTo
(
PaintedLayer
*
aLayer
DrawTarget
*
aTarget
float
aOpacity
CompositionOp
aOp
SourceSurface
*
aMask
const
Matrix
*
aMaskTransform
)
{
bool
clipped
=
false
;
if
(
!
aLayer
-
>
GetValidRegion
(
)
.
Contains
(
BufferRect
(
)
)
|
|
(
ToData
(
aLayer
)
-
>
GetClipToVisibleRegion
(
)
&
&
!
aLayer
-
>
GetVisibleRegion
(
)
.
ToUnknownRegion
(
)
.
Contains
(
BufferRect
(
)
)
)
|
|
IsClippingCheap
(
aTarget
aLayer
-
>
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
)
)
{
gfxUtils
:
:
ClipToRegion
(
aTarget
aLayer
-
>
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
)
;
clipped
=
true
;
}
DrawBufferWithRotation
(
aTarget
aOpacity
aOp
aMask
aMaskTransform
)
;
if
(
clipped
)
{
aTarget
-
>
PopClip
(
)
;
}
}
void
RotatedBuffer
:
:
UpdateDestinationFrom
(
const
RotatedBuffer
&
aSource
const
gfx
:
:
IntRect
&
aUpdateRect
)
{
DrawIterator
iter
;
while
(
DrawTarget
*
destDT
=
BorrowDrawTargetForQuadrantUpdate
(
aUpdateRect
&
iter
)
)
{
bool
isClippingCheap
=
IsClippingCheap
(
destDT
iter
.
mDrawRegion
)
;
if
(
isClippingCheap
)
{
gfxUtils
:
:
ClipToRegion
(
destDT
iter
.
mDrawRegion
)
;
}
aSource
.
DrawBufferWithRotation
(
destDT
1
.
0
CompositionOp
:
:
OP_SOURCE
)
;
if
(
isClippingCheap
)
{
destDT
-
>
PopClip
(
)
;
}
ReturnDrawTarget
(
destDT
)
;
}
}
static
void
WrapRotationAxis
(
int32_t
*
aRotationPoint
int32_t
aSize
)
{
if
(
*
aRotationPoint
<
0
)
{
*
aRotationPoint
+
=
aSize
;
}
else
if
(
*
aRotationPoint
>
=
aSize
)
{
*
aRotationPoint
-
=
aSize
;
}
}
bool
RotatedBuffer
:
:
Parameters
:
:
IsRotated
(
)
const
{
return
mBufferRotation
!
=
IntPoint
(
0
0
)
;
}
bool
RotatedBuffer
:
:
Parameters
:
:
RectWrapsBuffer
(
const
gfx
:
:
IntRect
&
aRect
)
const
{
int32_t
xBoundary
=
mBufferRect
.
XMost
(
)
-
mBufferRotation
.
x
;
int32_t
yBoundary
=
mBufferRect
.
YMost
(
)
-
mBufferRotation
.
y
;
return
(
aRect
.
X
(
)
<
xBoundary
&
&
xBoundary
<
aRect
.
XMost
(
)
)
|
|
(
aRect
.
Y
(
)
<
yBoundary
&
&
yBoundary
<
aRect
.
YMost
(
)
)
;
}
void
RotatedBuffer
:
:
Parameters
:
:
SetUnrotated
(
)
{
mBufferRotation
=
IntPoint
(
0
0
)
;
mDidSelfCopy
=
true
;
}
RotatedBuffer
:
:
Parameters
RotatedBuffer
:
:
AdjustedParameters
(
const
gfx
:
:
IntRect
&
aDestBufferRect
)
const
{
IntRect
keepArea
;
if
(
keepArea
.
IntersectRect
(
aDestBufferRect
mBufferRect
)
)
{
IntPoint
newRotation
=
mBufferRotation
+
(
aDestBufferRect
.
TopLeft
(
)
-
mBufferRect
.
TopLeft
(
)
)
;
WrapRotationAxis
(
&
newRotation
.
x
mBufferRect
.
Width
(
)
)
;
WrapRotationAxis
(
&
newRotation
.
y
mBufferRect
.
Height
(
)
)
;
NS_ASSERTION
(
gfx
:
:
IntRect
(
gfx
:
:
IntPoint
(
0
0
)
mBufferRect
.
Size
(
)
)
.
Contains
(
newRotation
)
"
newRotation
out
of
bounds
"
)
;
return
Parameters
{
aDestBufferRect
newRotation
}
;
}
return
Parameters
{
aDestBufferRect
IntPoint
(
0
0
)
}
;
}
bool
RotatedBuffer
:
:
UnrotateBufferTo
(
const
Parameters
&
aParameters
)
{
RefPtr
<
gfx
:
:
DrawTarget
>
drawTarget
=
GetDrawTarget
(
)
;
MOZ_ASSERT
(
drawTarget
&
&
drawTarget
-
>
IsValid
(
)
)
;
if
(
mBufferRotation
=
=
IntPoint
(
0
0
)
)
{
IntRect
srcRect
(
IntPoint
(
0
0
)
mBufferRect
.
Size
(
)
)
;
IntPoint
dest
=
mBufferRect
.
TopLeft
(
)
-
aParameters
.
mBufferRect
.
TopLeft
(
)
;
drawTarget
-
>
CopyRect
(
srcRect
dest
)
;
return
true
;
}
else
{
return
drawTarget
-
>
Unrotate
(
aParameters
.
mBufferRotation
)
;
}
}
void
RotatedBuffer
:
:
SetParameters
(
const
RotatedBuffer
:
:
Parameters
&
aParameters
)
{
mBufferRect
=
aParameters
.
mBufferRect
;
mBufferRotation
=
aParameters
.
mBufferRotation
;
mDidSelfCopy
=
aParameters
.
mDidSelfCopy
;
}
RotatedBuffer
:
:
ContentType
RotatedBuffer
:
:
GetContentType
(
)
const
{
return
ContentForFormat
(
GetFormat
(
)
)
;
}
DrawTarget
*
RotatedBuffer
:
:
BorrowDrawTargetForQuadrantUpdate
(
const
IntRect
&
aBounds
DrawIterator
*
aIter
)
{
IntRect
bounds
=
aBounds
;
if
(
aIter
)
{
aIter
-
>
mDrawRegion
.
SetEmpty
(
)
;
while
(
aIter
-
>
mCount
<
4
)
{
IntRect
quadrant
=
GetQuadrantRectangle
(
(
aIter
-
>
mCount
&
1
)
?
LEFT
:
RIGHT
(
aIter
-
>
mCount
&
2
)
?
TOP
:
BOTTOM
)
;
aIter
-
>
mDrawRegion
.
And
(
aBounds
quadrant
)
;
aIter
-
>
mCount
+
+
;
if
(
!
aIter
-
>
mDrawRegion
.
IsEmpty
(
)
)
{
break
;
}
}
if
(
aIter
-
>
mDrawRegion
.
IsEmpty
(
)
)
{
return
nullptr
;
}
bounds
=
aIter
-
>
mDrawRegion
.
GetBounds
(
)
;
}
MOZ_ASSERT
(
!
mLoanedDrawTarget
"
draw
target
has
been
borrowed
and
not
returned
"
)
;
mLoanedDrawTarget
=
GetDrawTarget
(
)
;
int32_t
xBoundary
=
mBufferRect
.
XMost
(
)
-
mBufferRotation
.
x
;
int32_t
yBoundary
=
mBufferRect
.
YMost
(
)
-
mBufferRotation
.
y
;
XSide
sideX
=
bounds
.
XMost
(
)
<
=
xBoundary
?
RIGHT
:
LEFT
;
YSide
sideY
=
bounds
.
YMost
(
)
<
=
yBoundary
?
BOTTOM
:
TOP
;
IntRect
quadrantRect
=
GetQuadrantRectangle
(
sideX
sideY
)
;
NS_ASSERTION
(
quadrantRect
.
Contains
(
bounds
)
"
Messed
up
quadrants
"
)
;
mLoanedTransform
=
mLoanedDrawTarget
-
>
GetTransform
(
)
;
Matrix
transform
=
Matrix
(
mLoanedTransform
)
.
PreTranslate
(
-
quadrantRect
.
X
(
)
-
quadrantRect
.
Y
(
)
)
;
mLoanedDrawTarget
-
>
SetTransform
(
transform
)
;
return
mLoanedDrawTarget
;
}
gfx
:
:
SurfaceFormat
RemoteRotatedBuffer
:
:
GetFormat
(
)
const
{
return
mClient
-
>
GetFormat
(
)
;
}
bool
RemoteRotatedBuffer
:
:
IsLocked
(
)
{
return
mClient
-
>
IsLocked
(
)
;
}
bool
RemoteRotatedBuffer
:
:
Lock
(
OpenMode
aMode
)
{
MOZ_ASSERT
(
!
mTarget
)
;
MOZ_ASSERT
(
!
mTargetOnWhite
)
;
bool
locked
=
mClient
-
>
Lock
(
aMode
)
&
&
(
!
mClientOnWhite
|
|
mClientOnWhite
-
>
Lock
(
aMode
)
)
;
if
(
!
locked
)
{
Unlock
(
)
;
return
false
;
}
mTarget
=
mClient
-
>
BorrowDrawTarget
(
)
;
if
(
!
mTarget
|
|
!
mTarget
-
>
IsValid
(
)
)
{
gfxCriticalNote
<
<
"
Invalid
draw
target
"
<
<
hexa
(
mTarget
)
<
<
"
in
RemoteRotatedBuffer
:
:
Lock
"
;
Unlock
(
)
;
return
false
;
}
if
(
mClientOnWhite
)
{
mTargetOnWhite
=
mClientOnWhite
-
>
BorrowDrawTarget
(
)
;
if
(
!
mTargetOnWhite
|
|
!
mTargetOnWhite
-
>
IsValid
(
)
)
{
gfxCriticalNote
<
<
"
Invalid
draw
target
(
s
)
"
<
<
hexa
(
mTarget
)
<
<
"
and
"
<
<
hexa
(
mTargetOnWhite
)
<
<
"
in
RemoteRotatedBuffer
:
:
Lock
"
;
Unlock
(
)
;
return
false
;
}
}
if
(
mTargetOnWhite
)
{
mTargetDual
=
Factory
:
:
CreateDualDrawTarget
(
mTarget
mTargetOnWhite
)
;
if
(
!
mTargetDual
|
|
!
mTargetDual
-
>
IsValid
(
)
)
{
gfxCriticalNote
<
<
"
Invalid
dual
draw
target
"
<
<
hexa
(
mTargetDual
)
<
<
"
in
RemoteRotatedBuffer
:
:
Lock
"
;
Unlock
(
)
;
return
false
;
}
}
else
{
mTargetDual
=
mTarget
;
}
return
true
;
}
void
RemoteRotatedBuffer
:
:
Unlock
(
)
{
mTarget
=
nullptr
;
mTargetOnWhite
=
nullptr
;
mTargetDual
=
nullptr
;
if
(
mClient
-
>
IsLocked
(
)
)
{
mClient
-
>
Unlock
(
)
;
}
if
(
mClientOnWhite
&
&
mClientOnWhite
-
>
IsLocked
(
)
)
{
mClientOnWhite
-
>
Unlock
(
)
;
}
}
void
RemoteRotatedBuffer
:
:
SyncWithObject
(
SyncObjectClient
*
aSyncObject
)
{
mClient
-
>
SyncWithObject
(
aSyncObject
)
;
if
(
mClientOnWhite
)
{
mClientOnWhite
-
>
SyncWithObject
(
aSyncObject
)
;
}
}
void
RemoteRotatedBuffer
:
:
Clear
(
)
{
MOZ_ASSERT
(
!
mTarget
&
&
!
mTargetOnWhite
)
;
mClient
=
nullptr
;
mClientOnWhite
=
nullptr
;
}
gfx
:
:
DrawTarget
*
RemoteRotatedBuffer
:
:
GetBufferTarget
(
)
const
{
return
mTargetDual
;
}
gfx
:
:
SurfaceFormat
DrawTargetRotatedBuffer
:
:
GetFormat
(
)
const
{
return
mTarget
-
>
GetFormat
(
)
;
}
gfx
:
:
DrawTarget
*
DrawTargetRotatedBuffer
:
:
GetBufferTarget
(
)
const
{
return
mTargetDual
;
}
gfx
:
:
SurfaceFormat
SourceRotatedBuffer
:
:
GetFormat
(
)
const
{
return
mSource
-
>
GetFormat
(
)
;
}
already_AddRefed
<
SourceSurface
>
SourceRotatedBuffer
:
:
GetBufferSource
(
)
const
{
RefPtr
<
SourceSurface
>
sourceDual
=
mSourceDual
;
return
sourceDual
.
forget
(
)
;
}
}
}
