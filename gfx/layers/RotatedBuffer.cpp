#
include
"
RotatedBuffer
.
h
"
#
include
<
sys
/
types
.
h
>
#
include
<
algorithm
>
#
include
"
BasicImplData
.
h
"
#
include
"
BasicLayersImpl
.
h
"
#
include
"
BufferUnrotate
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
Layers
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
gfx
/
BasePoint
.
h
"
#
include
"
mozilla
/
gfx
/
BaseRect
.
h
"
#
include
"
mozilla
/
gfx
/
BaseSize
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
ShadowLayers
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
PaintThread
.
h
"
namespace
mozilla
{
using
namespace
gfx
;
namespace
layers
{
void
BorrowDrawTarget
:
:
ReturnDrawTarget
(
gfx
:
:
DrawTarget
*
&
aReturned
)
{
MOZ_ASSERT
(
mLoanedDrawTarget
)
;
MOZ_ASSERT
(
aReturned
=
=
mLoanedDrawTarget
)
;
if
(
mLoanedDrawTarget
)
{
if
(
mSetTransform
)
{
mLoanedDrawTarget
-
>
SetTransform
(
mLoanedTransform
)
;
}
mLoanedDrawTarget
=
nullptr
;
}
aReturned
=
nullptr
;
}
IntRect
RotatedBuffer
:
:
GetQuadrantRectangle
(
XSide
aXSide
YSide
aYSide
)
const
{
IntPoint
quadrantTranslation
=
-
mBufferRotation
;
quadrantTranslation
.
x
+
=
aXSide
=
=
LEFT
?
mBufferRect
.
Width
(
)
:
0
;
quadrantTranslation
.
y
+
=
aYSide
=
=
TOP
?
mBufferRect
.
Height
(
)
:
0
;
return
mBufferRect
+
quadrantTranslation
;
}
Rect
RotatedBuffer
:
:
GetSourceRectangle
(
XSide
aXSide
YSide
aYSide
)
const
{
Rect
result
;
if
(
aXSide
=
=
LEFT
)
{
result
.
x
=
0
;
result
.
SetWidth
(
mBufferRotation
.
x
)
;
}
else
{
result
.
x
=
mBufferRotation
.
x
;
result
.
SetWidth
(
mBufferRect
.
Width
(
)
-
mBufferRotation
.
x
)
;
}
if
(
aYSide
=
=
TOP
)
{
result
.
y
=
0
;
result
.
SetHeight
(
mBufferRotation
.
y
)
;
}
else
{
result
.
y
=
mBufferRotation
.
y
;
result
.
SetHeight
(
mBufferRect
.
Height
(
)
-
mBufferRotation
.
y
)
;
}
return
result
;
}
void
RotatedBuffer
:
:
DrawBufferQuadrant
(
gfx
:
:
DrawTarget
*
aTarget
XSide
aXSide
YSide
aYSide
ContextSource
aSource
float
aOpacity
gfx
:
:
CompositionOp
aOperator
gfx
:
:
SourceSurface
*
aMask
const
gfx
:
:
Matrix
*
aMaskTransform
)
const
{
IntRect
quadrantRect
=
GetQuadrantRectangle
(
aXSide
aYSide
)
;
IntRect
fillRect
;
if
(
!
fillRect
.
IntersectRect
(
mBufferRect
quadrantRect
)
)
return
;
gfx
:
:
Point
quadrantTranslation
(
quadrantRect
.
x
quadrantRect
.
y
)
;
MOZ_ASSERT
(
aSource
!
=
BUFFER_BOTH
)
;
RefPtr
<
SourceSurface
>
snapshot
=
GetSourceSurface
(
aSource
)
;
if
(
!
snapshot
)
{
gfxCriticalError
(
)
<
<
"
Invalid
snapshot
in
RotatedBuffer
:
:
DrawBufferQuadrant
"
;
return
;
}
if
(
(
aTarget
-
>
GetBackendType
(
)
=
=
BackendType
:
:
DIRECT2D
|
|
aTarget
-
>
GetBackendType
(
)
=
=
BackendType
:
:
DIRECT2D1_1
)
&
&
aOperator
=
=
CompositionOp
:
:
OP_SOURCE
)
{
aOperator
=
CompositionOp
:
:
OP_OVER
;
if
(
snapshot
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
B8G8R8A8
)
{
aTarget
-
>
ClearRect
(
IntRectToRect
(
fillRect
)
)
;
}
}
aTarget
-
>
PushClipRect
(
IntRectToRect
(
fillRect
)
)
;
if
(
aMask
)
{
Matrix
oldTransform
=
aTarget
-
>
GetTransform
(
)
;
Matrix
transform
=
Matrix
:
:
Translation
(
quadrantTranslation
.
x
quadrantTranslation
.
y
)
;
Matrix
inverseMask
=
*
aMaskTransform
;
inverseMask
.
Invert
(
)
;
transform
*
=
oldTransform
;
transform
*
=
inverseMask
;
#
ifdef
MOZ_GFX_OPTIMIZE_MOBILE
SurfacePattern
source
(
snapshot
ExtendMode
:
:
CLAMP
transform
SamplingFilter
:
:
POINT
)
;
#
else
SurfacePattern
source
(
snapshot
ExtendMode
:
:
CLAMP
transform
)
;
#
endif
aTarget
-
>
SetTransform
(
*
aMaskTransform
)
;
aTarget
-
>
MaskSurface
(
source
aMask
Point
(
0
0
)
DrawOptions
(
aOpacity
aOperator
)
)
;
aTarget
-
>
SetTransform
(
oldTransform
)
;
}
else
{
#
ifdef
MOZ_GFX_OPTIMIZE_MOBILE
DrawSurfaceOptions
options
(
SamplingFilter
:
:
POINT
)
;
#
else
DrawSurfaceOptions
options
;
#
endif
aTarget
-
>
DrawSurface
(
snapshot
IntRectToRect
(
fillRect
)
GetSourceRectangle
(
aXSide
aYSide
)
options
DrawOptions
(
aOpacity
aOperator
)
)
;
}
aTarget
-
>
PopClip
(
)
;
}
void
RotatedBuffer
:
:
DrawBufferWithRotation
(
gfx
:
:
DrawTarget
*
aTarget
ContextSource
aSource
float
aOpacity
gfx
:
:
CompositionOp
aOperator
gfx
:
:
SourceSurface
*
aMask
const
gfx
:
:
Matrix
*
aMaskTransform
)
const
{
AUTO_PROFILER_LABEL
(
"
RotatedBuffer
:
:
DrawBufferWithRotation
"
GRAPHICS
)
;
DrawBufferQuadrant
(
aTarget
LEFT
TOP
aSource
aOpacity
aOperator
aMask
aMaskTransform
)
;
DrawBufferQuadrant
(
aTarget
RIGHT
TOP
aSource
aOpacity
aOperator
aMask
aMaskTransform
)
;
DrawBufferQuadrant
(
aTarget
LEFT
BOTTOM
aSource
aOpacity
aOperator
aMask
aMaskTransform
)
;
DrawBufferQuadrant
(
aTarget
RIGHT
BOTTOM
aSource
aOpacity
aOperator
aMask
aMaskTransform
)
;
}
bool
IsClippingCheap
(
gfx
:
:
DrawTarget
*
aTarget
const
nsIntRegion
&
aRegion
)
{
return
!
aTarget
-
>
GetTransform
(
)
.
HasNonIntegerTranslation
(
)
&
&
aRegion
.
GetNumRects
(
)
<
=
1
;
}
void
RotatedBuffer
:
:
DrawTo
(
PaintedLayer
*
aLayer
DrawTarget
*
aTarget
float
aOpacity
CompositionOp
aOp
SourceSurface
*
aMask
const
Matrix
*
aMaskTransform
)
{
bool
clipped
=
false
;
if
(
!
aLayer
-
>
GetValidRegion
(
)
.
Contains
(
BufferRect
(
)
)
|
|
(
ToData
(
aLayer
)
-
>
GetClipToVisibleRegion
(
)
&
&
!
aLayer
-
>
GetVisibleRegion
(
)
.
ToUnknownRegion
(
)
.
Contains
(
BufferRect
(
)
)
)
|
|
IsClippingCheap
(
aTarget
aLayer
-
>
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
)
)
{
gfxUtils
:
:
ClipToRegion
(
aTarget
aLayer
-
>
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
)
;
clipped
=
true
;
}
DrawBufferWithRotation
(
aTarget
BUFFER_BLACK
aOpacity
aOp
aMask
aMaskTransform
)
;
if
(
clipped
)
{
aTarget
-
>
PopClip
(
)
;
}
}
void
RotatedBuffer
:
:
UpdateDestinationFrom
(
const
RotatedBuffer
&
aSource
const
nsIntRegion
&
aUpdateRegion
)
{
DrawIterator
iter
;
while
(
DrawTarget
*
destDT
=
BorrowDrawTargetForQuadrantUpdate
(
aUpdateRegion
.
GetBounds
(
)
BUFFER_BLACK
&
iter
)
)
{
bool
isClippingCheap
=
IsClippingCheap
(
destDT
iter
.
mDrawRegion
)
;
if
(
isClippingCheap
)
{
gfxUtils
:
:
ClipToRegion
(
destDT
iter
.
mDrawRegion
)
;
}
aSource
.
DrawBufferWithRotation
(
destDT
BUFFER_BLACK
1
.
0
CompositionOp
:
:
OP_SOURCE
)
;
if
(
isClippingCheap
)
{
destDT
-
>
PopClip
(
)
;
}
destDT
-
>
Flush
(
)
;
ReturnDrawTarget
(
destDT
)
;
}
if
(
aSource
.
HaveBufferOnWhite
(
)
)
{
MOZ_ASSERT
(
HaveBufferOnWhite
(
)
)
;
DrawIterator
whiteIter
;
while
(
DrawTarget
*
destDT
=
BorrowDrawTargetForQuadrantUpdate
(
aUpdateRegion
.
GetBounds
(
)
BUFFER_WHITE
&
whiteIter
)
)
{
bool
isClippingCheap
=
IsClippingCheap
(
destDT
whiteIter
.
mDrawRegion
)
;
if
(
isClippingCheap
)
{
gfxUtils
:
:
ClipToRegion
(
destDT
whiteIter
.
mDrawRegion
)
;
}
aSource
.
DrawBufferWithRotation
(
destDT
BUFFER_WHITE
1
.
0
CompositionOp
:
:
OP_SOURCE
)
;
if
(
isClippingCheap
)
{
destDT
-
>
PopClip
(
)
;
}
destDT
-
>
Flush
(
)
;
ReturnDrawTarget
(
destDT
)
;
}
}
}
DrawTarget
*
RotatedBuffer
:
:
BorrowDrawTargetForQuadrantUpdate
(
const
IntRect
&
aBounds
ContextSource
aSource
DrawIterator
*
aIter
bool
aSetTransform
Matrix
*
aOutMatrix
)
{
IntRect
bounds
=
aBounds
;
if
(
aIter
)
{
aIter
-
>
mDrawRegion
.
SetEmpty
(
)
;
while
(
aIter
-
>
mCount
<
4
)
{
IntRect
quadrant
=
GetQuadrantRectangle
(
(
aIter
-
>
mCount
&
1
)
?
LEFT
:
RIGHT
(
aIter
-
>
mCount
&
2
)
?
TOP
:
BOTTOM
)
;
aIter
-
>
mDrawRegion
.
And
(
aBounds
quadrant
)
;
aIter
-
>
mCount
+
+
;
if
(
!
aIter
-
>
mDrawRegion
.
IsEmpty
(
)
)
{
break
;
}
}
if
(
aIter
-
>
mDrawRegion
.
IsEmpty
(
)
)
{
return
nullptr
;
}
bounds
=
aIter
-
>
mDrawRegion
.
GetBounds
(
)
;
}
gfx
:
:
DrawTarget
*
dtBuffer
=
GetDTBuffer
(
)
;
gfx
:
:
DrawTarget
*
dtBufferOnWhite
=
GetDTBufferOnWhite
(
)
;
MOZ_ASSERT
(
!
mLoanedDrawTarget
"
draw
target
has
been
borrowed
and
not
returned
"
)
;
if
(
aSource
=
=
BUFFER_BOTH
&
&
HaveBufferOnWhite
(
)
)
{
MOZ_ASSERT
(
dtBuffer
&
&
dtBuffer
-
>
IsValid
(
)
&
&
dtBufferOnWhite
&
&
dtBufferOnWhite
-
>
IsValid
(
)
)
;
mLoanedDrawTarget
=
Factory
:
:
CreateDualDrawTarget
(
dtBuffer
dtBufferOnWhite
)
;
}
else
if
(
aSource
=
=
BUFFER_WHITE
)
{
mLoanedDrawTarget
=
dtBufferOnWhite
;
}
else
{
mLoanedDrawTarget
=
dtBuffer
;
}
int32_t
xBoundary
=
mBufferRect
.
XMost
(
)
-
mBufferRotation
.
x
;
int32_t
yBoundary
=
mBufferRect
.
YMost
(
)
-
mBufferRotation
.
y
;
XSide
sideX
=
bounds
.
XMost
(
)
<
=
xBoundary
?
RIGHT
:
LEFT
;
YSide
sideY
=
bounds
.
YMost
(
)
<
=
yBoundary
?
BOTTOM
:
TOP
;
IntRect
quadrantRect
=
GetQuadrantRectangle
(
sideX
sideY
)
;
NS_ASSERTION
(
quadrantRect
.
Contains
(
bounds
)
"
Messed
up
quadrants
"
)
;
if
(
aSetTransform
)
{
mLoanedTransform
=
mLoanedDrawTarget
-
>
GetTransform
(
)
;
Matrix
transform
=
Matrix
(
mLoanedTransform
)
.
PreTranslate
(
-
quadrantRect
.
x
-
quadrantRect
.
y
)
;
mLoanedDrawTarget
-
>
SetTransform
(
transform
)
;
mSetTransform
=
true
;
}
else
{
MOZ_ASSERT
(
aOutMatrix
)
;
*
aOutMatrix
=
Matrix
:
:
Translation
(
-
quadrantRect
.
x
-
quadrantRect
.
y
)
;
mSetTransform
=
false
;
}
return
mLoanedDrawTarget
;
}
bool
RemoteRotatedBuffer
:
:
Lock
(
OpenMode
aMode
)
{
MOZ_ASSERT
(
!
mTarget
)
;
MOZ_ASSERT
(
!
mTargetOnWhite
)
;
bool
locked
=
mClient
-
>
Lock
(
aMode
)
&
&
(
!
mClientOnWhite
|
|
mClientOnWhite
-
>
Lock
(
aMode
)
)
;
if
(
!
locked
)
{
Unlock
(
)
;
return
false
;
}
mTarget
=
mClient
-
>
BorrowDrawTarget
(
)
;
if
(
!
mTarget
|
|
!
mTarget
-
>
IsValid
(
)
)
{
gfxCriticalNote
<
<
"
Invalid
draw
target
"
<
<
hexa
(
mTarget
)
<
<
"
in
RemoteRotatedBuffer
:
:
Lock
"
;
Unlock
(
)
;
return
false
;
}
if
(
mClientOnWhite
)
{
mTargetOnWhite
=
mClientOnWhite
-
>
BorrowDrawTarget
(
)
;
if
(
!
mTargetOnWhite
|
|
!
mTargetOnWhite
-
>
IsValid
(
)
)
{
gfxCriticalNote
<
<
"
Invalid
draw
target
(
s
)
"
<
<
hexa
(
mTarget
)
<
<
"
and
"
<
<
hexa
(
mTargetOnWhite
)
<
<
"
in
RemoteRotatedBuffer
:
:
Lock
"
;
Unlock
(
)
;
return
false
;
}
}
return
true
;
}
void
RemoteRotatedBuffer
:
:
Unlock
(
)
{
mTarget
=
nullptr
;
mTargetOnWhite
=
nullptr
;
if
(
mClient
-
>
IsLocked
(
)
)
{
mClient
-
>
Unlock
(
)
;
}
if
(
mClientOnWhite
&
&
mClientOnWhite
-
>
IsLocked
(
)
)
{
mClientOnWhite
-
>
Unlock
(
)
;
}
}
void
RemoteRotatedBuffer
:
:
Clear
(
)
{
MOZ_ASSERT
(
!
mTarget
&
&
!
mTargetOnWhite
)
;
mClient
=
nullptr
;
mClientOnWhite
=
nullptr
;
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
RemoteRotatedBuffer
:
:
GetSourceSurface
(
ContextSource
aSource
)
const
{
if
(
aSource
=
=
ContextSource
:
:
BUFFER_BLACK
)
{
return
mTarget
-
>
Snapshot
(
)
;
}
else
{
MOZ_ASSERT
(
aSource
=
=
ContextSource
:
:
BUFFER_WHITE
)
;
return
mTargetOnWhite
-
>
Snapshot
(
)
;
}
}
gfx
:
:
DrawTarget
*
RemoteRotatedBuffer
:
:
GetDTBuffer
(
)
const
{
return
mTarget
;
}
gfx
:
:
DrawTarget
*
RemoteRotatedBuffer
:
:
GetDTBufferOnWhite
(
)
const
{
return
mTargetOnWhite
;
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
DrawTargetRotatedBuffer
:
:
GetSourceSurface
(
ContextSource
aSource
)
const
{
if
(
aSource
=
=
ContextSource
:
:
BUFFER_BLACK
)
{
return
mTarget
-
>
Snapshot
(
)
;
}
else
{
MOZ_ASSERT
(
aSource
=
=
ContextSource
:
:
BUFFER_WHITE
)
;
return
mTargetOnWhite
-
>
Snapshot
(
)
;
}
}
gfx
:
:
DrawTarget
*
DrawTargetRotatedBuffer
:
:
GetDTBuffer
(
)
const
{
return
mTarget
;
}
gfx
:
:
DrawTarget
*
DrawTargetRotatedBuffer
:
:
GetDTBufferOnWhite
(
)
const
{
return
mTargetOnWhite
;
}
already_AddRefed
<
SourceSurface
>
SourceRotatedBuffer
:
:
GetSourceSurface
(
ContextSource
aSource
)
const
{
RefPtr
<
SourceSurface
>
surf
;
if
(
aSource
=
=
BUFFER_BLACK
)
{
surf
=
mSource
;
}
else
{
MOZ_ASSERT
(
aSource
=
=
BUFFER_WHITE
)
;
surf
=
mSourceOnWhite
;
}
MOZ_ASSERT
(
surf
)
;
return
surf
.
forget
(
)
;
}
gfxContentType
RotatedContentBuffer
:
:
BufferContentType
(
)
{
if
(
mBufferProvider
|
|
(
mDTBuffer
&
&
mDTBuffer
-
>
IsValid
(
)
)
)
{
SurfaceFormat
format
=
SurfaceFormat
:
:
B8G8R8A8
;
if
(
mBufferProvider
)
{
format
=
mBufferProvider
-
>
GetFormat
(
)
;
}
else
if
(
mDTBuffer
&
&
mDTBuffer
-
>
IsValid
(
)
)
{
format
=
mDTBuffer
-
>
GetFormat
(
)
;
}
return
ContentForFormat
(
format
)
;
}
return
gfxContentType
:
:
SENTINEL
;
}
bool
RotatedContentBuffer
:
:
BufferSizeOkFor
(
const
IntSize
&
aSize
)
{
return
(
aSize
=
=
mBufferRect
.
Size
(
)
|
|
(
SizedToVisibleBounds
!
=
mBufferSizePolicy
&
&
aSize
<
mBufferRect
.
Size
(
)
)
)
;
}
bool
RotatedContentBuffer
:
:
EnsureBuffer
(
)
{
NS_ASSERTION
(
!
mLoanedDrawTarget
"
Loaned
draw
target
must
be
returned
"
)
;
if
(
!
mDTBuffer
|
|
!
mDTBuffer
-
>
IsValid
(
)
)
{
if
(
mBufferProvider
)
{
mDTBuffer
=
mBufferProvider
-
>
BorrowDrawTarget
(
)
;
}
}
NS_WARNING_ASSERTION
(
mDTBuffer
&
&
mDTBuffer
-
>
IsValid
(
)
"
no
buffer
"
)
;
return
!
!
mDTBuffer
;
}
bool
RotatedContentBuffer
:
:
EnsureBufferOnWhite
(
)
{
NS_ASSERTION
(
!
mLoanedDrawTarget
"
Loaned
draw
target
must
be
returned
"
)
;
if
(
!
mDTBufferOnWhite
)
{
if
(
mBufferProviderOnWhite
)
{
mDTBufferOnWhite
=
mBufferProviderOnWhite
-
>
BorrowDrawTarget
(
)
;
}
}
NS_WARNING_ASSERTION
(
mDTBufferOnWhite
"
no
buffer
"
)
;
return
!
!
mDTBufferOnWhite
;
}
bool
RotatedContentBuffer
:
:
HaveBuffer
(
)
const
{
return
mBufferProvider
|
|
(
mDTBuffer
&
&
mDTBuffer
-
>
IsValid
(
)
)
;
}
bool
RotatedContentBuffer
:
:
HaveBufferOnWhite
(
)
const
{
return
mBufferProviderOnWhite
|
|
(
mDTBufferOnWhite
&
&
mDTBufferOnWhite
-
>
IsValid
(
)
)
;
}
static
void
WrapRotationAxis
(
int32_t
*
aRotationPoint
int32_t
aSize
)
{
if
(
*
aRotationPoint
<
0
)
{
*
aRotationPoint
+
=
aSize
;
}
else
if
(
*
aRotationPoint
>
=
aSize
)
{
*
aRotationPoint
-
=
aSize
;
}
}
static
IntRect
ComputeBufferRect
(
const
IntRect
&
aRequestedRect
)
{
IntRect
rect
(
aRequestedRect
)
;
rect
.
SetWidth
(
std
:
:
max
(
aRequestedRect
.
Width
(
)
8
)
)
;
return
rect
;
}
void
RotatedContentBuffer
:
:
FlushBuffers
(
)
{
if
(
mDTBuffer
)
{
mDTBuffer
-
>
Flush
(
)
;
}
if
(
mDTBufferOnWhite
)
{
mDTBufferOnWhite
-
>
Flush
(
)
;
}
}
RotatedContentBuffer
:
:
PaintState
RotatedContentBuffer
:
:
BeginPaint
(
PaintedLayer
*
aLayer
uint32_t
aFlags
)
{
PaintState
result
;
bool
canHaveRotation
=
gfxPlatform
:
:
BufferRotationEnabled
(
)
&
&
!
(
aFlags
&
(
PAINT_WILL_RESAMPLE
|
PAINT_NO_ROTATION
)
)
&
&
!
(
aLayer
-
>
Manager
(
)
-
>
AsWebRenderLayerManager
(
)
)
;
nsIntRegion
validRegion
=
aLayer
-
>
GetValidRegion
(
)
;
bool
canUseOpaqueSurface
=
aLayer
-
>
CanUseOpaqueSurface
(
)
;
ContentType
layerContentType
=
canUseOpaqueSurface
?
gfxContentType
:
:
COLOR
:
gfxContentType
:
:
COLOR_ALPHA
;
SurfaceMode
mode
;
nsIntRegion
neededRegion
;
IntRect
destBufferRect
;
bool
canReuseBuffer
=
HaveBuffer
(
)
;
while
(
true
)
{
mode
=
aLayer
-
>
GetSurfaceMode
(
)
;
neededRegion
=
aLayer
-
>
GetVisibleRegion
(
)
.
ToUnknownRegion
(
)
;
canReuseBuffer
&
=
BufferSizeOkFor
(
neededRegion
.
GetBounds
(
)
.
Size
(
)
)
;
result
.
mContentType
=
layerContentType
;
if
(
canReuseBuffer
)
{
if
(
mBufferRect
.
Contains
(
neededRegion
.
GetBounds
(
)
)
)
{
destBufferRect
=
mBufferRect
;
}
else
if
(
neededRegion
.
GetBounds
(
)
.
Size
(
)
<
=
mBufferRect
.
Size
(
)
)
{
destBufferRect
=
IntRect
(
neededRegion
.
GetBounds
(
)
.
TopLeft
(
)
mBufferRect
.
Size
(
)
)
;
}
else
{
destBufferRect
=
neededRegion
.
GetBounds
(
)
;
}
}
else
{
destBufferRect
=
ComputeBufferRect
(
neededRegion
.
GetBounds
(
)
)
;
}
if
(
mode
=
=
SurfaceMode
:
:
SURFACE_COMPONENT_ALPHA
)
{
#
if
defined
(
MOZ_GFX_OPTIMIZE_MOBILE
)
mode
=
SurfaceMode
:
:
SURFACE_SINGLE_CHANNEL_ALPHA
;
#
else
if
(
!
aLayer
-
>
GetParent
(
)
|
|
!
aLayer
-
>
GetParent
(
)
-
>
SupportsComponentAlphaChildren
(
)
|
|
!
aLayer
-
>
AsShadowableLayer
(
)
|
|
!
aLayer
-
>
AsShadowableLayer
(
)
-
>
HasShadow
(
)
)
{
mode
=
SurfaceMode
:
:
SURFACE_SINGLE_CHANNEL_ALPHA
;
}
else
{
result
.
mContentType
=
gfxContentType
:
:
COLOR
;
}
#
endif
}
if
(
(
aFlags
&
PAINT_WILL_RESAMPLE
)
&
&
(
!
neededRegion
.
GetBounds
(
)
.
IsEqualInterior
(
destBufferRect
)
|
|
neededRegion
.
GetNumRects
(
)
>
1
)
)
{
if
(
mode
=
=
SurfaceMode
:
:
SURFACE_OPAQUE
)
{
result
.
mContentType
=
gfxContentType
:
:
COLOR_ALPHA
;
mode
=
SurfaceMode
:
:
SURFACE_SINGLE_CHANNEL_ALPHA
;
}
neededRegion
=
destBufferRect
;
}
if
(
canReuseBuffer
&
&
(
result
.
mContentType
!
=
BufferContentType
(
)
|
|
(
mode
=
=
SurfaceMode
:
:
SURFACE_COMPONENT_ALPHA
)
!
=
HaveBufferOnWhite
(
)
)
)
{
canReuseBuffer
=
false
;
continue
;
}
break
;
}
if
(
HaveBuffer
(
)
&
&
(
result
.
mContentType
!
=
BufferContentType
(
)
|
|
(
mode
=
=
SurfaceMode
:
:
SURFACE_COMPONENT_ALPHA
)
!
=
HaveBufferOnWhite
(
)
)
)
{
canReuseBuffer
=
false
;
result
.
mRegionToInvalidate
=
aLayer
-
>
GetValidRegion
(
)
;
validRegion
.
SetEmpty
(
)
;
Clear
(
)
;
#
if
defined
(
MOZ_DUMP_PAINTING
)
if
(
nsLayoutUtils
:
:
InvalidationDebuggingIsEnabled
(
)
)
{
if
(
result
.
mContentType
!
=
BufferContentType
(
)
)
{
printf_stderr
(
"
Invalidating
entire
rotated
buffer
(
layer
%
p
)
:
content
type
changed
\
n
"
aLayer
)
;
}
else
if
(
(
mode
=
=
SurfaceMode
:
:
SURFACE_COMPONENT_ALPHA
)
!
=
HaveBufferOnWhite
(
)
)
{
printf_stderr
(
"
Invalidating
entire
rotated
buffer
(
layer
%
p
)
:
component
alpha
changed
\
n
"
aLayer
)
;
}
}
#
endif
}
NS_ASSERTION
(
destBufferRect
.
Contains
(
neededRegion
.
GetBounds
(
)
)
"
Destination
rect
doesn
'
t
contain
what
we
need
to
paint
"
)
;
result
.
mRegionToDraw
.
Sub
(
neededRegion
validRegion
)
;
if
(
result
.
mRegionToDraw
.
IsEmpty
(
)
)
return
result
;
if
(
HaveBuffer
(
)
)
{
if
(
LockBuffers
(
)
)
{
FinalizeFrame
(
result
.
mRegionToDraw
)
;
}
else
{
result
.
mRegionToDraw
=
neededRegion
;
canReuseBuffer
=
false
;
Clear
(
)
;
}
}
IntRect
drawBounds
=
result
.
mRegionToDraw
.
GetBounds
(
)
;
RefPtr
<
DrawTarget
>
destDTBuffer
;
RefPtr
<
DrawTarget
>
destDTBufferOnWhite
;
uint32_t
bufferFlags
=
0
;
if
(
mode
=
=
SurfaceMode
:
:
SURFACE_COMPONENT_ALPHA
)
{
bufferFlags
|
=
BUFFER_COMPONENT_ALPHA
;
}
if
(
canReuseBuffer
)
{
if
(
!
EnsureBuffer
(
)
)
{
return
result
;
}
IntRect
keepArea
;
if
(
keepArea
.
IntersectRect
(
destBufferRect
mBufferRect
)
)
{
IntPoint
newRotation
=
mBufferRotation
+
(
destBufferRect
.
TopLeft
(
)
-
mBufferRect
.
TopLeft
(
)
)
;
WrapRotationAxis
(
&
newRotation
.
x
mBufferRect
.
Width
(
)
)
;
WrapRotationAxis
(
&
newRotation
.
y
mBufferRect
.
Height
(
)
)
;
NS_ASSERTION
(
gfx
:
:
IntRect
(
gfx
:
:
IntPoint
(
0
0
)
mBufferRect
.
Size
(
)
)
.
Contains
(
newRotation
)
"
newRotation
out
of
bounds
"
)
;
int32_t
xBoundary
=
destBufferRect
.
XMost
(
)
-
newRotation
.
x
;
int32_t
yBoundary
=
destBufferRect
.
YMost
(
)
-
newRotation
.
y
;
bool
drawWrapsBuffer
=
(
drawBounds
.
x
<
xBoundary
&
&
xBoundary
<
drawBounds
.
XMost
(
)
)
|
|
(
drawBounds
.
y
<
yBoundary
&
&
yBoundary
<
drawBounds
.
YMost
(
)
)
;
if
(
(
drawWrapsBuffer
&
&
!
(
aFlags
&
PAINT_CAN_DRAW_ROTATED
)
)
|
|
(
newRotation
!
=
IntPoint
(
0
0
)
&
&
!
canHaveRotation
)
)
{
if
(
mBufferRotation
=
=
IntPoint
(
0
0
)
)
{
IntRect
srcRect
(
IntPoint
(
0
0
)
mBufferRect
.
Size
(
)
)
;
IntPoint
dest
=
mBufferRect
.
TopLeft
(
)
-
destBufferRect
.
TopLeft
(
)
;
MOZ_ASSERT
(
mDTBuffer
&
&
mDTBuffer
-
>
IsValid
(
)
)
;
mDTBuffer
-
>
CopyRect
(
srcRect
dest
)
;
if
(
mode
=
=
SurfaceMode
:
:
SURFACE_COMPONENT_ALPHA
)
{
if
(
!
EnsureBufferOnWhite
(
)
)
{
return
result
;
}
MOZ_ASSERT
(
mDTBufferOnWhite
&
&
mDTBufferOnWhite
-
>
IsValid
(
)
)
;
mDTBufferOnWhite
-
>
CopyRect
(
srcRect
dest
)
;
}
result
.
mDidSelfCopy
=
true
;
mDidSelfCopy
=
true
;
mBufferRect
=
destBufferRect
;
}
else
{
unsigned
char
*
data
;
IntSize
size
;
int32_t
stride
;
SurfaceFormat
format
;
if
(
mDTBuffer
-
>
LockBits
(
&
data
&
size
&
stride
&
format
)
)
{
uint8_t
bytesPerPixel
=
BytesPerPixel
(
format
)
;
BufferUnrotate
(
data
size
.
width
*
bytesPerPixel
size
.
height
stride
newRotation
.
x
*
bytesPerPixel
newRotation
.
y
)
;
mDTBuffer
-
>
ReleaseBits
(
data
)
;
if
(
mode
=
=
SurfaceMode
:
:
SURFACE_COMPONENT_ALPHA
)
{
if
(
!
EnsureBufferOnWhite
(
)
)
{
return
result
;
}
MOZ_ASSERT
(
mDTBufferOnWhite
&
&
mDTBufferOnWhite
-
>
IsValid
(
)
)
;
mDTBufferOnWhite
-
>
LockBits
(
&
data
&
size
&
stride
&
format
)
;
uint8_t
bytesPerPixel
=
BytesPerPixel
(
format
)
;
BufferUnrotate
(
data
size
.
width
*
bytesPerPixel
size
.
height
stride
newRotation
.
x
*
bytesPerPixel
newRotation
.
y
)
;
mDTBufferOnWhite
-
>
ReleaseBits
(
data
)
;
}
result
.
mDidSelfCopy
=
true
;
mDidSelfCopy
=
true
;
mBufferRect
=
destBufferRect
;
mBufferRotation
=
IntPoint
(
0
0
)
;
}
if
(
!
result
.
mDidSelfCopy
)
{
destBufferRect
=
ComputeBufferRect
(
neededRegion
.
GetBounds
(
)
)
;
CreateBuffer
(
result
.
mContentType
destBufferRect
bufferFlags
&
destDTBuffer
&
destDTBufferOnWhite
)
;
if
(
!
destDTBuffer
|
|
(
!
destDTBufferOnWhite
&
&
(
bufferFlags
&
BUFFER_COMPONENT_ALPHA
)
)
)
{
if
(
Factory
:
:
ReasonableSurfaceSize
(
IntSize
(
destBufferRect
.
Width
(
)
destBufferRect
.
Height
(
)
)
)
)
{
gfxCriticalNote
<
<
"
Failed
1
buffer
db
=
"
<
<
hexa
(
destDTBuffer
.
get
(
)
)
<
<
"
dw
=
"
<
<
hexa
(
destDTBufferOnWhite
.
get
(
)
)
<
<
"
for
"
<
<
destBufferRect
.
x
<
<
"
"
<
<
destBufferRect
.
y
<
<
"
"
<
<
destBufferRect
.
Width
(
)
<
<
"
"
<
<
destBufferRect
.
Height
(
)
;
}
return
result
;
}
}
}
}
else
{
mBufferRect
=
destBufferRect
;
mBufferRotation
=
newRotation
;
}
}
else
{
mBufferRect
=
destBufferRect
;
mBufferRotation
=
IntPoint
(
0
0
)
;
}
}
else
{
CreateBuffer
(
result
.
mContentType
destBufferRect
bufferFlags
&
destDTBuffer
&
destDTBufferOnWhite
)
;
if
(
!
destDTBuffer
|
|
(
!
destDTBufferOnWhite
&
&
(
bufferFlags
&
BUFFER_COMPONENT_ALPHA
)
)
)
{
if
(
Factory
:
:
ReasonableSurfaceSize
(
IntSize
(
destBufferRect
.
Width
(
)
destBufferRect
.
Height
(
)
)
)
)
{
gfxCriticalNote
<
<
"
Failed
2
buffer
db
=
"
<
<
hexa
(
destDTBuffer
.
get
(
)
)
<
<
"
dw
=
"
<
<
hexa
(
destDTBufferOnWhite
.
get
(
)
)
<
<
"
for
"
<
<
destBufferRect
.
x
<
<
"
"
<
<
destBufferRect
.
y
<
<
"
"
<
<
destBufferRect
.
Width
(
)
<
<
"
"
<
<
destBufferRect
.
Height
(
)
;
}
return
result
;
}
}
NS_ASSERTION
(
!
(
aFlags
&
PAINT_WILL_RESAMPLE
)
|
|
destBufferRect
=
=
neededRegion
.
GetBounds
(
)
"
If
we
'
re
resampling
we
need
to
validate
the
entire
buffer
"
)
;
bool
isClear
=
!
HaveBuffer
(
)
;
if
(
destDTBuffer
)
{
if
(
!
isClear
&
&
(
mode
!
=
SurfaceMode
:
:
SURFACE_COMPONENT_ALPHA
|
|
HaveBufferOnWhite
(
)
)
)
{
IntPoint
offset
=
-
destBufferRect
.
TopLeft
(
)
;
Matrix
mat
=
Matrix
:
:
Translation
(
offset
.
x
offset
.
y
)
;
destDTBuffer
-
>
SetTransform
(
mat
)
;
if
(
!
EnsureBuffer
(
)
)
{
return
result
;
}
MOZ_ASSERT
(
mDTBuffer
&
&
mDTBuffer
-
>
IsValid
(
)
"
Have
we
got
a
Thebes
buffer
for
some
reason
?
"
)
;
DrawBufferWithRotation
(
destDTBuffer
BUFFER_BLACK
1
.
0
CompositionOp
:
:
OP_SOURCE
)
;
destDTBuffer
-
>
SetTransform
(
Matrix
(
)
)
;
if
(
mode
=
=
SurfaceMode
:
:
SURFACE_COMPONENT_ALPHA
)
{
if
(
!
destDTBufferOnWhite
|
|
!
EnsureBufferOnWhite
(
)
)
{
return
result
;
}
MOZ_ASSERT
(
mDTBufferOnWhite
&
&
mDTBufferOnWhite
-
>
IsValid
(
)
"
Have
we
got
a
Thebes
buffer
for
some
reason
?
"
)
;
destDTBufferOnWhite
-
>
SetTransform
(
mat
)
;
DrawBufferWithRotation
(
destDTBufferOnWhite
BUFFER_WHITE
1
.
0
CompositionOp
:
:
OP_SOURCE
)
;
destDTBufferOnWhite
-
>
SetTransform
(
Matrix
(
)
)
;
}
}
mDTBuffer
=
destDTBuffer
.
forget
(
)
;
mDTBufferOnWhite
=
destDTBufferOnWhite
.
forget
(
)
;
mBufferRect
=
destBufferRect
;
mBufferRotation
=
IntPoint
(
0
0
)
;
}
NS_ASSERTION
(
canHaveRotation
|
|
mBufferRotation
=
=
IntPoint
(
0
0
)
"
Rotation
disabled
but
we
have
nonzero
rotation
?
"
)
;
nsIntRegion
invalidate
;
invalidate
.
Sub
(
aLayer
-
>
GetValidRegion
(
)
destBufferRect
)
;
result
.
mRegionToInvalidate
.
Or
(
result
.
mRegionToInvalidate
invalidate
)
;
result
.
mClip
=
DrawRegionClip
:
:
DRAW
;
result
.
mMode
=
mode
;
return
result
;
}
RefPtr
<
CapturedPaintState
>
RotatedContentBuffer
:
:
BorrowDrawTargetForRecording
(
PaintState
&
aPaintState
DrawIterator
*
aIter
bool
aSetTransform
)
{
if
(
aPaintState
.
mMode
=
=
SurfaceMode
:
:
SURFACE_NONE
|
|
!
EnsureBuffer
(
)
|
|
(
HaveBufferOnWhite
(
)
&
&
!
EnsureBufferOnWhite
(
)
)
)
{
return
nullptr
;
}
Matrix
transform
;
DrawTarget
*
result
=
BorrowDrawTargetForQuadrantUpdate
(
aPaintState
.
mRegionToDraw
.
GetBounds
(
)
BUFFER_BOTH
aIter
aSetTransform
&
transform
)
;
if
(
!
result
)
{
return
nullptr
;
}
nsIntRegion
regionToDraw
=
ExpandDrawRegion
(
aPaintState
aIter
result
-
>
GetBackendType
(
)
)
;
RefPtr
<
CapturedPaintState
>
state
=
new
CapturedPaintState
(
regionToDraw
result
mDTBufferOnWhite
transform
aPaintState
.
mMode
aPaintState
.
mContentType
)
;
return
state
;
}
bool
RotatedContentBuffer
:
:
PrepareDrawTargetForPainting
(
CapturedPaintState
*
aState
)
{
MOZ_ASSERT
(
aState
)
;
RefPtr
<
DrawTarget
>
target
=
aState
-
>
mTarget
;
RefPtr
<
DrawTarget
>
whiteTarget
=
aState
-
>
mTargetOnWhite
;
if
(
aState
-
>
mSurfaceMode
=
=
SurfaceMode
:
:
SURFACE_COMPONENT_ALPHA
)
{
if
(
!
target
|
|
!
target
-
>
IsValid
(
)
|
|
!
whiteTarget
|
|
!
whiteTarget
-
>
IsValid
(
)
)
{
return
false
;
}
for
(
auto
iter
=
aState
-
>
mRegionToDraw
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
IntRect
&
rect
=
iter
.
Get
(
)
;
target
-
>
FillRect
(
Rect
(
rect
.
x
rect
.
y
rect
.
Width
(
)
rect
.
Height
(
)
)
ColorPattern
(
Color
(
0
.
0
0
.
0
0
.
0
1
.
0
)
)
)
;
whiteTarget
-
>
FillRect
(
Rect
(
rect
.
x
rect
.
y
rect
.
Width
(
)
rect
.
Height
(
)
)
ColorPattern
(
Color
(
1
.
0
1
.
0
1
.
0
1
.
0
)
)
)
;
}
}
else
if
(
aState
-
>
mContentType
=
=
gfxContentType
:
:
COLOR_ALPHA
&
&
target
-
>
IsValid
(
)
)
{
for
(
auto
iter
=
aState
-
>
mRegionToDraw
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
IntRect
&
rect
=
iter
.
Get
(
)
;
target
-
>
ClearRect
(
Rect
(
rect
.
x
rect
.
y
rect
.
Width
(
)
rect
.
Height
(
)
)
)
;
}
}
return
true
;
}
nsIntRegion
RotatedContentBuffer
:
:
ExpandDrawRegion
(
PaintState
&
aPaintState
DrawIterator
*
aIter
BackendType
aBackendType
)
{
nsIntRegion
*
drawPtr
=
&
aPaintState
.
mRegionToDraw
;
if
(
aIter
)
{
aIter
-
>
mDrawRegion
.
And
(
aIter
-
>
mDrawRegion
aPaintState
.
mRegionToDraw
)
;
drawPtr
=
&
aIter
-
>
mDrawRegion
;
}
if
(
aBackendType
=
=
BackendType
:
:
DIRECT2D
|
|
aBackendType
=
=
BackendType
:
:
DIRECT2D1_1
)
{
drawPtr
-
>
SimplifyOutwardByArea
(
100
*
100
)
;
}
return
*
drawPtr
;
}
DrawTarget
*
RotatedContentBuffer
:
:
BorrowDrawTargetForPainting
(
PaintState
&
aPaintState
DrawIterator
*
aIter
)
{
RefPtr
<
CapturedPaintState
>
capturedState
=
BorrowDrawTargetForRecording
(
aPaintState
aIter
true
)
;
if
(
!
capturedState
)
{
return
nullptr
;
}
if
(
!
RotatedContentBuffer
:
:
PrepareDrawTargetForPainting
(
capturedState
)
)
{
return
nullptr
;
}
return
capturedState
-
>
mTarget
;
}
already_AddRefed
<
SourceSurface
>
RotatedContentBuffer
:
:
GetSourceSurface
(
ContextSource
aSource
)
const
{
if
(
!
mDTBuffer
|
|
!
mDTBuffer
-
>
IsValid
(
)
)
{
gfxCriticalNote
<
<
"
Invalid
buffer
in
RotatedContentBuffer
:
:
GetSourceSurface
"
<
<
gfx
:
:
hexa
(
mDTBuffer
)
;
return
nullptr
;
}
if
(
aSource
=
=
BUFFER_BLACK
)
{
return
mDTBuffer
-
>
Snapshot
(
)
;
}
else
{
if
(
!
mDTBufferOnWhite
|
|
!
mDTBufferOnWhite
-
>
IsValid
(
)
)
{
gfxCriticalNote
<
<
"
Invalid
buffer
on
white
in
RotatedContentBuffer
:
:
GetSourceSurface
"
<
<
gfx
:
:
hexa
(
mDTBufferOnWhite
)
;
return
nullptr
;
}
MOZ_ASSERT
(
aSource
=
=
BUFFER_WHITE
)
;
return
mDTBufferOnWhite
-
>
Snapshot
(
)
;
}
}
}
}
