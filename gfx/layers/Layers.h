#
ifndef
GFX_LAYERS_H
#
define
GFX_LAYERS_H
#
include
<
map
>
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
"
FrameMetrics
.
h
"
#
include
"
Units
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxTypes
.
h
"
#
include
"
gfxPoint
.
h
"
#
include
"
gfxRect
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Poison
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
gfx
/
BaseMargin
.
h
"
#
include
"
mozilla
/
gfx
/
BasePoint
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
TiledRegion
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
gfx
/
UserData
.
h
"
#
include
"
mozilla
/
layers
/
AnimationInfo
.
h
"
#
include
"
mozilla
/
layers
/
BSPTree
.
h
"
#
include
"
mozilla
/
layers
/
CanvasRenderer
.
h
"
#
include
"
mozilla
/
layers
/
LayerAttributes
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCSSPropertyID
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
#
include
"
nscore
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
ImageContainer
.
h
"
class
gfxContext
;
class
nsDisplayListBuilder
;
class
nsDisplayItem
;
extern
uint8_t
gLayerManagerLayerBuilder
;
namespace
mozilla
{
class
ComputedTimingFunction
;
class
FrameLayerBuilder
;
namespace
gl
{
class
GLContext
;
}
namespace
gfx
{
class
DrawTarget
;
}
namespace
layers
{
class
Animation
;
class
AsyncCanvasRenderer
;
class
AsyncPanZoomController
;
class
BasicLayerManager
;
class
ClientLayerManager
;
class
HostLayerManager
;
class
Layer
;
class
LayerMetricsWrapper
;
class
PaintedLayer
;
class
ContainerLayer
;
class
ImageLayer
;
class
ColorLayer
;
class
CompositorAnimations
;
class
CompositorBridgeChild
;
class
CanvasLayer
;
class
ReadbackLayer
;
class
ReadbackProcessor
;
class
RefLayer
;
class
HostLayer
;
class
FocusTarget
;
class
KnowsCompositor
;
class
ShadowableLayer
;
class
ShadowLayerForwarder
;
class
LayerManagerComposite
;
class
SpecificLayerAttributes
;
class
TransactionIdAllocator
;
class
Compositor
;
class
FrameUniformityData
;
class
PersistentBufferProvider
;
class
GlyphArray
;
class
WebRenderLayerManager
;
struct
AnimData
;
namespace
layerscope
{
class
LayersPacket
;
}
#
define
MOZ_LAYER_DECL_NAME
(
n
e
)
\
virtual
const
char
*
Name
(
)
const
override
{
return
n
;
}
\
virtual
LayerType
GetType
(
)
const
override
{
return
e
;
}
\
static
LayerType
Type
(
)
{
return
e
;
}
class
LayerUserData
;
class
DidCompositeObserver
{
public
:
virtual
void
DidComposite
(
)
=
0
;
}
;
class
LayerManager
{
NS_INLINE_DECL_REFCOUNTING
(
LayerManager
)
protected
:
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
typedef
mozilla
:
:
gfx
:
:
IntSize
IntSize
;
typedef
mozilla
:
:
gfx
:
:
SurfaceFormat
SurfaceFormat
;
public
:
LayerManager
(
)
:
mDestroyed
(
false
)
mSnapEffectiveTransforms
(
true
)
mId
(
0
)
mInTransaction
(
false
)
mPaintedPixelCount
(
0
)
{
}
virtual
void
Destroy
(
)
{
mDestroyed
=
true
;
mUserData
.
Destroy
(
)
;
mRoot
=
nullptr
;
}
bool
IsDestroyed
(
)
{
return
mDestroyed
;
}
virtual
ShadowLayerForwarder
*
AsShadowForwarder
(
)
{
return
nullptr
;
}
virtual
KnowsCompositor
*
AsKnowsCompositor
(
)
{
return
nullptr
;
}
virtual
LayerManagerComposite
*
AsLayerManagerComposite
(
)
{
return
nullptr
;
}
virtual
ClientLayerManager
*
AsClientLayerManager
(
)
{
return
nullptr
;
}
virtual
BasicLayerManager
*
AsBasicLayerManager
(
)
{
return
nullptr
;
}
virtual
HostLayerManager
*
AsHostLayerManager
(
)
{
return
nullptr
;
}
virtual
WebRenderLayerManager
*
AsWebRenderLayerManager
(
)
{
return
nullptr
;
}
virtual
bool
IsWidgetLayerManager
(
)
{
return
true
;
}
virtual
bool
IsInactiveLayerManager
(
)
{
return
false
;
}
virtual
bool
BeginTransaction
(
)
=
0
;
virtual
bool
BeginTransactionWithTarget
(
gfxContext
*
aTarget
)
=
0
;
enum
EndTransactionFlags
{
END_DEFAULT
=
0
END_NO_IMMEDIATE_REDRAW
=
1
<
<
0
END_NO_COMPOSITE
=
1
<
<
1
END_NO_REMOTE_COMPOSITE
=
1
<
<
2
}
;
FrameLayerBuilder
*
GetLayerBuilder
(
)
{
return
reinterpret_cast
<
FrameLayerBuilder
*
>
(
GetUserData
(
&
gLayerManagerLayerBuilder
)
)
;
}
virtual
bool
EndEmptyTransaction
(
EndTransactionFlags
aFlags
=
END_DEFAULT
)
=
0
;
typedef
void
(
*
DrawPaintedLayerCallback
)
(
PaintedLayer
*
aLayer
gfxContext
*
aContext
const
nsIntRegion
&
aRegionToDraw
const
nsIntRegion
&
aDirtyRegion
DrawRegionClip
aClip
const
nsIntRegion
&
aRegionToInvalidate
void
*
aCallbackData
)
;
virtual
void
EndTransaction
(
DrawPaintedLayerCallback
aCallback
void
*
aCallbackData
EndTransactionFlags
aFlags
=
END_DEFAULT
)
=
0
;
virtual
void
ScheduleComposite
(
)
{
}
virtual
void
SetNeedsComposite
(
bool
aNeedsComposite
)
{
}
virtual
bool
NeedsComposite
(
)
const
{
return
false
;
}
virtual
bool
HasShadowManagerInternal
(
)
const
{
return
false
;
}
bool
HasShadowManager
(
)
const
{
return
HasShadowManagerInternal
(
)
;
}
virtual
void
StorePluginWidgetConfigurations
(
const
nsTArray
<
nsIWidget
:
:
Configuration
>
&
aConfigurations
)
{
}
bool
IsSnappingEffectiveTransforms
(
)
{
return
mSnapEffectiveTransforms
;
}
virtual
bool
AreComponentAlphaLayersEnabled
(
)
;
virtual
bool
BlendingRequiresIntermediateSurface
(
)
{
return
false
;
}
virtual
void
SetRoot
(
Layer
*
aLayer
)
=
0
;
Layer
*
GetRoot
(
)
{
return
mRoot
;
}
FrameMetrics
:
:
ViewID
GetRootScrollableLayerId
(
)
;
LayerMetricsWrapper
GetRootContentLayer
(
)
;
virtual
void
Mutated
(
Layer
*
aLayer
)
{
}
virtual
void
MutatedSimple
(
Layer
*
aLayer
)
{
}
enum
PaintedLayerCreationHint
{
NONE
SCROLLABLE
}
;
virtual
already_AddRefed
<
PaintedLayer
>
CreatePaintedLayer
(
)
=
0
;
virtual
already_AddRefed
<
PaintedLayer
>
CreatePaintedLayerWithHint
(
PaintedLayerCreationHint
)
{
return
CreatePaintedLayer
(
)
;
}
virtual
already_AddRefed
<
ContainerLayer
>
CreateContainerLayer
(
)
=
0
;
virtual
already_AddRefed
<
ImageLayer
>
CreateImageLayer
(
)
=
0
;
virtual
already_AddRefed
<
ColorLayer
>
CreateColorLayer
(
)
=
0
;
virtual
already_AddRefed
<
CanvasLayer
>
CreateCanvasLayer
(
)
=
0
;
virtual
already_AddRefed
<
ReadbackLayer
>
CreateReadbackLayer
(
)
{
return
nullptr
;
}
virtual
already_AddRefed
<
RefLayer
>
CreateRefLayer
(
)
{
return
nullptr
;
}
static
already_AddRefed
<
ImageContainer
>
CreateImageContainer
(
ImageContainer
:
:
Mode
flag
=
ImageContainer
:
:
SYNCHRONOUS
)
;
virtual
LayersBackend
GetBackendType
(
)
=
0
;
virtual
LayersBackend
GetCompositorBackendType
(
)
{
return
GetBackendType
(
)
;
}
virtual
already_AddRefed
<
DrawTarget
>
CreateOptimalDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
imageFormat
)
;
virtual
already_AddRefed
<
DrawTarget
>
CreateOptimalMaskDrawTarget
(
const
IntSize
&
aSize
)
;
virtual
already_AddRefed
<
mozilla
:
:
gfx
:
:
DrawTarget
>
CreateDrawTarget
(
const
mozilla
:
:
gfx
:
:
IntSize
&
aSize
mozilla
:
:
gfx
:
:
SurfaceFormat
aFormat
)
;
virtual
already_AddRefed
<
PersistentBufferProvider
>
CreatePersistentBufferProvider
(
const
mozilla
:
:
gfx
:
:
IntSize
&
aSize
mozilla
:
:
gfx
:
:
SurfaceFormat
aFormat
)
;
virtual
bool
CanUseCanvasLayerForSize
(
const
gfx
:
:
IntSize
&
aSize
)
{
return
true
;
}
virtual
int32_t
GetMaxTextureSize
(
)
const
=
0
;
virtual
void
GetBackendName
(
nsAString
&
aName
)
=
0
;
void
SetUserData
(
void
*
aKey
LayerUserData
*
aData
)
{
mUserData
.
Add
(
static_cast
<
gfx
:
:
UserDataKey
*
>
(
aKey
)
aData
LayerUserDataDestroy
)
;
}
UniquePtr
<
LayerUserData
>
RemoveUserData
(
void
*
aKey
)
;
bool
HasUserData
(
void
*
aKey
)
{
return
mUserData
.
Has
(
static_cast
<
gfx
:
:
UserDataKey
*
>
(
aKey
)
)
;
}
LayerUserData
*
GetUserData
(
void
*
aKey
)
const
{
return
static_cast
<
LayerUserData
*
>
(
mUserData
.
Get
(
static_cast
<
gfx
:
:
UserDataKey
*
>
(
aKey
)
)
)
;
}
virtual
void
ClearCachedResources
(
Layer
*
aSubtree
=
nullptr
)
{
}
virtual
void
SetIsFirstPaint
(
)
{
}
virtual
void
SetFocusTarget
(
const
FocusTarget
&
aFocusTarget
)
{
}
virtual
void
FlushRendering
(
)
{
}
virtual
void
WaitOnTransactionProcessed
(
)
{
}
virtual
void
SendInvalidRegion
(
const
nsIntRegion
&
aRegion
)
{
}
virtual
bool
NeedsWidgetInvalidation
(
)
{
return
true
;
}
virtual
const
char
*
Name
(
)
const
{
return
"
?
?
?
"
;
}
void
Dump
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
=
"
"
bool
aDumpHtml
=
false
bool
aSorted
=
false
)
;
void
DumpSelf
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
=
"
"
bool
aSorted
=
false
)
;
void
Dump
(
bool
aSorted
=
false
)
;
void
Dump
(
layerscope
:
:
LayersPacket
*
aPacket
)
;
void
Log
(
const
char
*
aPrefix
=
"
"
)
;
void
LogSelf
(
const
char
*
aPrefix
=
"
"
)
;
virtual
uint32_t
StartFrameTimeRecording
(
int32_t
aBufferSize
)
;
virtual
void
StopFrameTimeRecording
(
uint32_t
aStartIndex
nsTArray
<
float
>
&
aFrameIntervals
)
;
void
RecordFrame
(
)
;
static
bool
IsLogEnabled
(
)
;
static
mozilla
:
:
LogModule
*
GetLog
(
)
;
bool
IsCompositingCheap
(
LayersBackend
aBackend
)
{
return
LayersBackend
:
:
LAYERS_BASIC
!
=
aBackend
&
&
LayersBackend
:
:
LAYERS_NONE
!
=
aBackend
;
}
virtual
bool
IsCompositingCheap
(
)
{
return
true
;
}
bool
IsInTransaction
(
)
const
{
return
mInTransaction
;
}
virtual
void
GetFrameUniformity
(
FrameUniformityData
*
aOutData
)
{
}
virtual
void
SetRegionToClear
(
const
nsIntRegion
&
aRegion
)
{
mRegionToClear
=
aRegion
;
}
virtual
float
RequestProperty
(
const
nsAString
&
property
)
{
return
-
1
;
}
const
TimeStamp
&
GetAnimationReadyTime
(
)
const
{
return
mAnimationReadyTime
;
}
virtual
bool
AsyncPanZoomEnabled
(
)
const
{
return
false
;
}
static
void
LayerUserDataDestroy
(
void
*
data
)
;
void
AddPaintedPixelCount
(
int32_t
aCount
)
{
mPaintedPixelCount
+
=
aCount
;
}
uint32_t
GetAndClearPaintedPixelCount
(
)
{
uint32_t
count
=
mPaintedPixelCount
;
mPaintedPixelCount
=
0
;
return
count
;
}
virtual
void
SetLayersObserverEpoch
(
LayersObserverEpoch
aEpoch
)
{
}
virtual
void
DidComposite
(
TransactionId
aTransactionId
const
mozilla
:
:
TimeStamp
&
aCompositeStart
const
mozilla
:
:
TimeStamp
&
aCompositeEnd
)
{
}
virtual
void
AddDidCompositeObserver
(
DidCompositeObserver
*
aObserver
)
{
MOZ_CRASH
(
"
GFX
:
LayerManager
"
)
;
}
virtual
void
RemoveDidCompositeObserver
(
DidCompositeObserver
*
aObserver
)
{
MOZ_CRASH
(
"
GFX
:
LayerManager
"
)
;
}
virtual
void
UpdateTextureFactoryIdentifier
(
const
TextureFactoryIdentifier
&
aNewIdentifier
)
{
}
virtual
TextureFactoryIdentifier
GetTextureFactoryIdentifier
(
)
{
return
TextureFactoryIdentifier
(
)
;
}
virtual
void
SetTransactionIdAllocator
(
TransactionIdAllocator
*
aAllocator
)
{
}
virtual
TransactionId
GetLastTransactionId
(
)
{
return
TransactionId
{
0
}
;
}
virtual
CompositorBridgeChild
*
GetCompositorBridgeChild
(
)
{
return
nullptr
;
}
protected
:
RefPtr
<
Layer
>
mRoot
;
gfx
:
:
UserData
mUserData
;
bool
mDestroyed
;
bool
mSnapEffectiveTransforms
;
nsIntRegion
mRegionToClear
;
virtual
~
LayerManager
(
)
{
}
virtual
void
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
;
virtual
void
DumpPacket
(
layerscope
:
:
LayersPacket
*
aPacket
)
;
uint64_t
mId
;
bool
mInTransaction
;
TimeStamp
mAnimationReadyTime
;
uint32_t
mPaintedPixelCount
;
private
:
struct
FramesTimingRecording
{
FramesTimingRecording
(
)
:
mNextIndex
(
0
)
mLatestStartIndex
(
0
)
mCurrentRunStartIndex
(
0
)
mIsPaused
(
true
)
{
}
nsTArray
<
float
>
mIntervals
;
TimeStamp
mLastFrameTime
;
uint32_t
mNextIndex
;
uint32_t
mLatestStartIndex
;
uint32_t
mCurrentRunStartIndex
;
bool
mIsPaused
;
}
;
FramesTimingRecording
mRecording
;
public
:
virtual
bool
SetPendingScrollUpdateForNextTransaction
(
FrameMetrics
:
:
ViewID
aScrollId
const
ScrollUpdateInfo
&
aUpdateInfo
)
;
Maybe
<
ScrollUpdateInfo
>
GetPendingScrollInfoUpdate
(
FrameMetrics
:
:
ViewID
aScrollId
)
;
void
ClearPendingScrollInfoUpdate
(
)
;
protected
:
ScrollUpdatesMap
mPendingScrollUpdates
;
}
;
class
Layer
{
NS_INLINE_DECL_REFCOUNTING
(
Layer
)
typedef
InfallibleTArray
<
Animation
>
AnimationArray
;
public
:
enum
LayerType
{
TYPE_CANVAS
TYPE_COLOR
TYPE_CONTAINER
TYPE_DISPLAYITEM
TYPE_IMAGE
TYPE_READBACK
TYPE_REF
TYPE_SHADOW
TYPE_PAINTED
}
;
LayerManager
*
Manager
(
)
{
return
mManager
;
}
void
SetManager
(
LayerManager
*
aManager
HostLayer
*
aSelf
)
;
enum
{
CONTENT_OPAQUE
=
0x01
CONTENT_COMPONENT_ALPHA
=
0x02
CONTENT_COMPONENT_ALPHA_DESCENDANT
=
0x04
CONTENT_EXTEND_3D_CONTEXT
=
0x08
CONTENT_MAY_CHANGE_TRANSFORM
=
0x10
CONTENT_DISABLE_SUBPIXEL_AA
=
0x20
CONTENT_DISABLE_FLATTENING
=
0x40
CONTENT_BACKFACE_HIDDEN
=
0x80
}
;
void
SetContentFlags
(
uint32_t
aFlags
)
{
NS_ASSERTION
(
(
aFlags
&
(
CONTENT_OPAQUE
|
CONTENT_COMPONENT_ALPHA
)
)
!
=
(
CONTENT_OPAQUE
|
CONTENT_COMPONENT_ALPHA
)
"
Can
'
t
be
opaque
and
require
component
alpha
"
)
;
if
(
mSimpleAttrs
.
SetContentFlags
(
aFlags
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
ContentFlags
"
this
)
)
;
MutatedSimple
(
)
;
}
}
virtual
void
SetVisibleRegion
(
const
LayerIntRegion
&
aRegion
)
{
if
(
!
mVisibleRegion
.
IsEqual
(
aRegion
)
|
|
aRegion
.
IsEmpty
(
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
VisibleRegion
was
%
s
is
%
s
"
this
mVisibleRegion
.
ToString
(
)
.
get
(
)
aRegion
.
ToString
(
)
.
get
(
)
)
)
;
mVisibleRegion
=
aRegion
;
Mutated
(
)
;
}
}
void
SetScrollMetadata
(
const
ScrollMetadata
&
aScrollMetadata
)
{
Manager
(
)
-
>
ClearPendingScrollInfoUpdate
(
)
;
if
(
mScrollMetadata
.
Length
(
)
!
=
1
|
|
mScrollMetadata
[
0
]
!
=
aScrollMetadata
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
FrameMetrics
"
this
)
)
;
mScrollMetadata
.
ReplaceElementsAt
(
0
mScrollMetadata
.
Length
(
)
aScrollMetadata
)
;
ScrollMetadataChanged
(
)
;
Mutated
(
)
;
}
}
void
SetScrollMetadata
(
const
nsTArray
<
ScrollMetadata
>
&
aMetadataArray
)
{
Manager
(
)
-
>
ClearPendingScrollInfoUpdate
(
)
;
if
(
mScrollMetadata
!
=
aMetadataArray
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
FrameMetrics
"
this
)
)
;
mScrollMetadata
=
aMetadataArray
;
ScrollMetadataChanged
(
)
;
Mutated
(
)
;
}
}
void
SetEventRegions
(
const
EventRegions
&
aRegions
)
{
if
(
mEventRegions
!
=
aRegions
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
eventregions
were
%
s
now
%
s
"
this
mEventRegions
.
ToString
(
)
.
get
(
)
aRegions
.
ToString
(
)
.
get
(
)
)
)
;
mEventRegions
=
aRegions
;
Mutated
(
)
;
}
}
void
SetOpacity
(
float
aOpacity
)
{
if
(
mSimpleAttrs
.
SetOpacity
(
aOpacity
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
Opacity
"
this
)
)
;
MutatedSimple
(
)
;
}
}
void
SetMixBlendMode
(
gfx
:
:
CompositionOp
aMixBlendMode
)
{
if
(
mSimpleAttrs
.
SetMixBlendMode
(
aMixBlendMode
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
MixBlendMode
"
this
)
)
;
MutatedSimple
(
)
;
}
}
void
SetForceIsolatedGroup
(
bool
aForceIsolatedGroup
)
{
if
(
mSimpleAttrs
.
SetForceIsolatedGroup
(
aForceIsolatedGroup
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
ForceIsolatedGroup
"
this
)
)
;
MutatedSimple
(
)
;
}
}
bool
GetForceIsolatedGroup
(
)
const
{
return
mSimpleAttrs
.
GetForceIsolatedGroup
(
)
;
}
void
SetClipRect
(
const
Maybe
<
ParentLayerIntRect
>
&
aRect
)
{
if
(
mClipRect
)
{
if
(
!
aRect
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
ClipRect
was
%
d
%
d
%
d
%
d
is
<
none
>
"
this
mClipRect
-
>
X
(
)
mClipRect
-
>
Y
(
)
mClipRect
-
>
Width
(
)
mClipRect
-
>
Height
(
)
)
)
;
mClipRect
.
reset
(
)
;
Mutated
(
)
;
}
else
{
if
(
!
aRect
-
>
IsEqualEdges
(
*
mClipRect
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
ClipRect
was
%
d
%
d
%
d
%
d
is
%
d
%
d
%
d
%
d
"
this
mClipRect
-
>
X
(
)
mClipRect
-
>
Y
(
)
mClipRect
-
>
Width
(
)
mClipRect
-
>
Height
(
)
aRect
-
>
X
(
)
aRect
-
>
Y
(
)
aRect
-
>
Width
(
)
aRect
-
>
Height
(
)
)
)
;
mClipRect
=
aRect
;
Mutated
(
)
;
}
}
}
else
{
if
(
aRect
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
ClipRect
was
<
none
>
is
%
d
%
d
%
d
%
d
"
this
aRect
-
>
X
(
)
aRect
-
>
Y
(
)
aRect
-
>
Width
(
)
aRect
-
>
Height
(
)
)
)
;
mClipRect
=
aRect
;
Mutated
(
)
;
}
}
}
void
SetScrolledClip
(
const
Maybe
<
LayerClip
>
&
aScrolledClip
)
{
if
(
mSimpleAttrs
.
SetScrolledClip
(
aScrolledClip
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
ScrolledClip
"
this
)
)
;
MutatedSimple
(
)
;
}
}
void
SetMaskLayer
(
Layer
*
aMaskLayer
)
{
#
ifdef
DEBUG
if
(
aMaskLayer
)
{
bool
maskIs2D
=
aMaskLayer
-
>
GetTransform
(
)
.
CanDraw2D
(
)
;
NS_ASSERTION
(
maskIs2D
"
Mask
layer
has
invalid
transform
.
"
)
;
}
#
endif
if
(
mMaskLayer
!
=
aMaskLayer
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
MaskLayer
"
this
)
)
;
mMaskLayer
=
aMaskLayer
;
Mutated
(
)
;
}
}
void
SetAncestorMaskLayers
(
const
nsTArray
<
RefPtr
<
Layer
>
>
&
aLayers
)
{
if
(
aLayers
!
=
mAncestorMaskLayers
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
AncestorMaskLayers
"
this
)
)
;
mAncestorMaskLayers
=
aLayers
;
Mutated
(
)
;
}
}
void
AddAncestorMaskLayer
(
const
RefPtr
<
Layer
>
&
aLayer
)
{
mAncestorMaskLayers
.
AppendElement
(
aLayer
)
;
Mutated
(
)
;
}
void
SetBaseTransform
(
const
gfx
:
:
Matrix4x4
&
aMatrix
)
{
NS_ASSERTION
(
!
aMatrix
.
IsSingular
(
)
"
Shouldn
'
t
be
trying
to
draw
with
a
singular
matrix
!
"
)
;
mPendingTransform
=
nullptr
;
if
(
!
mSimpleAttrs
.
SetTransform
(
aMatrix
)
)
{
return
;
}
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
BaseTransform
"
this
)
)
;
MutatedSimple
(
)
;
}
void
SetBaseTransformForNextTransaction
(
const
gfx
:
:
Matrix4x4
&
aMatrix
)
{
mPendingTransform
=
new
gfx
:
:
Matrix4x4
(
aMatrix
)
;
}
void
SetPostScale
(
float
aXScale
float
aYScale
)
{
if
(
!
mSimpleAttrs
.
SetPostScale
(
aXScale
aYScale
)
)
{
return
;
}
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
PostScale
"
this
)
)
;
MutatedSimple
(
)
;
}
void
SetIsFixedPosition
(
bool
aFixedPosition
)
{
if
(
mSimpleAttrs
.
SetIsFixedPosition
(
aFixedPosition
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
IsFixedPosition
"
this
)
)
;
MutatedSimple
(
)
;
}
}
void
SetTransformIsPerspective
(
bool
aTransformIsPerspective
)
{
if
(
mSimpleAttrs
.
SetTransformIsPerspective
(
aTransformIsPerspective
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
TransformIsPerspective
"
this
)
)
;
MutatedSimple
(
)
;
}
}
void
SetCompositorAnimations
(
const
CompositorAnimations
&
aCompositorAnimations
)
;
void
StartPendingAnimations
(
const
TimeStamp
&
aReadyTime
)
;
void
ClearCompositorAnimations
(
)
;
void
SetFixedPositionData
(
FrameMetrics
:
:
ViewID
aScrollId
const
LayerPoint
&
aAnchor
int32_t
aSides
)
{
if
(
mSimpleAttrs
.
SetFixedPositionData
(
aScrollId
aAnchor
aSides
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
FixedPositionData
"
this
)
)
;
MutatedSimple
(
)
;
}
}
void
SetStickyPositionData
(
FrameMetrics
:
:
ViewID
aScrollId
LayerRectAbsolute
aOuter
LayerRectAbsolute
aInner
)
{
if
(
mSimpleAttrs
.
SetStickyPositionData
(
aScrollId
aOuter
aInner
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
StickyPositionData
"
this
)
)
;
MutatedSimple
(
)
;
}
}
void
SetScrollbarData
(
const
ScrollbarData
&
aThumbData
)
{
if
(
mSimpleAttrs
.
SetScrollbarData
(
aThumbData
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
ScrollbarData
"
this
)
)
;
MutatedSimple
(
)
;
}
}
void
SetSimpleAttributes
(
const
SimpleLayerAttributes
&
aAttrs
)
{
mSimpleAttrs
=
aAttrs
;
}
const
SimpleLayerAttributes
&
GetSimpleAttributes
(
)
const
{
return
mSimpleAttrs
;
}
float
GetOpacity
(
)
{
return
mSimpleAttrs
.
GetOpacity
(
)
;
}
gfx
:
:
CompositionOp
GetMixBlendMode
(
)
const
{
return
mSimpleAttrs
.
GetMixBlendMode
(
)
;
}
const
Maybe
<
ParentLayerIntRect
>
&
GetClipRect
(
)
const
{
return
mClipRect
;
}
const
Maybe
<
LayerClip
>
&
GetScrolledClip
(
)
const
{
return
mSimpleAttrs
.
GetScrolledClip
(
)
;
}
Maybe
<
ParentLayerIntRect
>
GetScrolledClipRect
(
)
const
;
uint32_t
GetContentFlags
(
)
{
return
mSimpleAttrs
.
GetContentFlags
(
)
;
}
const
LayerIntRegion
&
GetVisibleRegion
(
)
const
{
return
mVisibleRegion
;
}
const
ScrollMetadata
&
GetScrollMetadata
(
uint32_t
aIndex
)
const
;
const
FrameMetrics
&
GetFrameMetrics
(
uint32_t
aIndex
)
const
;
uint32_t
GetScrollMetadataCount
(
)
const
{
return
mScrollMetadata
.
Length
(
)
;
}
const
nsTArray
<
ScrollMetadata
>
&
GetAllScrollMetadata
(
)
{
return
mScrollMetadata
;
}
bool
HasScrollableFrameMetrics
(
)
const
;
bool
HasRootScrollableFrameMetrics
(
)
const
;
bool
IsScrollableWithoutContent
(
)
const
;
const
EventRegions
&
GetEventRegions
(
)
const
{
return
mEventRegions
;
}
ContainerLayer
*
GetParent
(
)
{
return
mParent
;
}
Layer
*
GetNextSibling
(
)
{
if
(
mNextSibling
)
{
mNextSibling
-
>
CheckCanary
(
)
;
}
return
mNextSibling
;
}
const
Layer
*
GetNextSibling
(
)
const
{
if
(
mNextSibling
)
{
mNextSibling
-
>
CheckCanary
(
)
;
}
return
mNextSibling
;
}
Layer
*
GetPrevSibling
(
)
{
return
mPrevSibling
;
}
const
Layer
*
GetPrevSibling
(
)
const
{
return
mPrevSibling
;
}
virtual
Layer
*
GetFirstChild
(
)
const
{
return
nullptr
;
}
virtual
Layer
*
GetLastChild
(
)
const
{
return
nullptr
;
}
gfx
:
:
Matrix4x4
GetTransform
(
)
const
;
const
CSSTransformMatrix
GetTransformTyped
(
)
const
;
const
gfx
:
:
Matrix4x4
&
GetBaseTransform
(
)
const
{
return
mSimpleAttrs
.
GetTransform
(
)
;
}
virtual
float
GetPostXScale
(
)
const
{
return
mSimpleAttrs
.
GetPostXScale
(
)
;
}
virtual
float
GetPostYScale
(
)
const
{
return
mSimpleAttrs
.
GetPostYScale
(
)
;
}
bool
GetIsFixedPosition
(
)
{
return
mSimpleAttrs
.
IsFixedPosition
(
)
;
}
bool
GetTransformIsPerspective
(
)
const
{
return
mSimpleAttrs
.
GetTransformIsPerspective
(
)
;
}
bool
GetIsStickyPosition
(
)
{
return
mSimpleAttrs
.
IsStickyPosition
(
)
;
}
FrameMetrics
:
:
ViewID
GetFixedPositionScrollContainerId
(
)
{
return
mSimpleAttrs
.
GetFixedPositionScrollContainerId
(
)
;
}
LayerPoint
GetFixedPositionAnchor
(
)
{
return
mSimpleAttrs
.
GetFixedPositionAnchor
(
)
;
}
int32_t
GetFixedPositionSides
(
)
{
return
mSimpleAttrs
.
GetFixedPositionSides
(
)
;
}
FrameMetrics
:
:
ViewID
GetStickyScrollContainerId
(
)
{
return
mSimpleAttrs
.
GetStickyScrollContainerId
(
)
;
}
const
LayerRectAbsolute
&
GetStickyScrollRangeOuter
(
)
{
return
mSimpleAttrs
.
GetStickyScrollRangeOuter
(
)
;
}
const
LayerRectAbsolute
&
GetStickyScrollRangeInner
(
)
{
return
mSimpleAttrs
.
GetStickyScrollRangeInner
(
)
;
}
const
ScrollbarData
&
GetScrollbarData
(
)
const
{
return
mSimpleAttrs
.
GetScrollbarData
(
)
;
}
bool
IsScrollbarContainer
(
)
const
;
Layer
*
GetMaskLayer
(
)
const
{
return
mMaskLayer
;
}
bool
HasPendingTransform
(
)
const
{
return
mPendingTransform
;
}
void
CheckCanary
(
)
const
{
mCanary
.
Check
(
)
;
}
size_t
GetAncestorMaskLayerCount
(
)
const
{
return
mAncestorMaskLayers
.
Length
(
)
;
}
Layer
*
GetAncestorMaskLayerAt
(
size_t
aIndex
)
const
{
return
mAncestorMaskLayers
.
ElementAt
(
aIndex
)
;
}
const
nsTArray
<
RefPtr
<
Layer
>
>
&
GetAllAncestorMaskLayers
(
)
const
{
return
mAncestorMaskLayers
;
}
bool
HasMaskLayers
(
)
const
{
return
GetMaskLayer
(
)
|
|
mAncestorMaskLayers
.
Length
(
)
>
0
;
}
Maybe
<
ParentLayerIntRect
>
GetCombinedClipRect
(
)
const
;
bool
GetVisibleRegionRelativeToRootLayer
(
nsIntRegion
&
aResult
nsIntPoint
*
aLayerOffset
)
;
AnimationArray
&
GetAnimations
(
)
{
return
mAnimationInfo
.
GetAnimations
(
)
;
}
uint64_t
GetCompositorAnimationsId
(
)
{
return
mAnimationInfo
.
GetCompositorAnimationsId
(
)
;
}
InfallibleTArray
<
AnimData
>
&
GetAnimationData
(
)
;
uint64_t
GetAnimationGeneration
(
)
{
return
mAnimationInfo
.
GetAnimationGeneration
(
)
;
}
bool
HasTransformAnimation
(
)
const
;
RawServoAnimationValue
*
GetBaseAnimationStyle
(
)
const
{
return
mAnimationInfo
.
GetBaseAnimationStyle
(
)
;
}
gfx
:
:
Matrix4x4
GetLocalTransform
(
)
;
const
LayerToParentLayerMatrix4x4
GetLocalTransformTyped
(
)
;
float
GetLocalOpacity
(
)
;
void
ApplyPendingUpdatesToSubtree
(
)
;
virtual
void
FillSpecificAttributes
(
SpecificLayerAttributes
&
aAttrs
)
{
}
bool
CanUseOpaqueSurface
(
)
;
SurfaceMode
GetSurfaceMode
(
)
{
if
(
CanUseOpaqueSurface
(
)
)
return
SurfaceMode
:
:
SURFACE_OPAQUE
;
if
(
GetContentFlags
(
)
&
CONTENT_COMPONENT_ALPHA
)
return
SurfaceMode
:
:
SURFACE_COMPONENT_ALPHA
;
return
SurfaceMode
:
:
SURFACE_SINGLE_CHANNEL_ALPHA
;
}
bool
IsOpaqueForVisibility
(
)
;
void
SetUserData
(
void
*
aKey
LayerUserData
*
aData
void
(
*
aDestroy
)
(
void
*
)
=
LayerManager
:
:
LayerUserDataDestroy
)
{
mUserData
.
Add
(
static_cast
<
gfx
:
:
UserDataKey
*
>
(
aKey
)
aData
aDestroy
)
;
}
UniquePtr
<
LayerUserData
>
RemoveUserData
(
void
*
aKey
)
;
bool
HasUserData
(
void
*
aKey
)
{
return
mUserData
.
Has
(
static_cast
<
gfx
:
:
UserDataKey
*
>
(
aKey
)
)
;
}
LayerUserData
*
GetUserData
(
void
*
aKey
)
const
{
return
static_cast
<
LayerUserData
*
>
(
mUserData
.
Get
(
static_cast
<
gfx
:
:
UserDataKey
*
>
(
aKey
)
)
)
;
}
virtual
void
Disconnect
(
)
{
}
virtual
PaintedLayer
*
AsPaintedLayer
(
)
{
return
nullptr
;
}
virtual
ContainerLayer
*
AsContainerLayer
(
)
{
return
nullptr
;
}
virtual
const
ContainerLayer
*
AsContainerLayer
(
)
const
{
return
nullptr
;
}
virtual
RefLayer
*
AsRefLayer
(
)
{
return
nullptr
;
}
virtual
ColorLayer
*
AsColorLayer
(
)
{
return
nullptr
;
}
virtual
CanvasLayer
*
AsCanvasLayer
(
)
{
return
nullptr
;
}
virtual
ImageLayer
*
AsImageLayer
(
)
{
return
nullptr
;
}
virtual
HostLayer
*
AsHostLayer
(
)
{
return
nullptr
;
}
virtual
ShadowableLayer
*
AsShadowableLayer
(
)
{
return
nullptr
;
}
const
Maybe
<
ParentLayerIntRect
>
&
GetLocalClipRect
(
)
;
const
LayerIntRegion
&
GetLocalVisibleRegion
(
)
;
bool
Extend3DContext
(
)
{
return
GetContentFlags
(
)
&
CONTENT_EXTEND_3D_CONTEXT
;
}
bool
Combines3DTransformWithAncestors
(
)
{
return
GetParent
(
)
&
&
reinterpret_cast
<
Layer
*
>
(
GetParent
(
)
)
-
>
Extend3DContext
(
)
;
}
bool
Is3DContextLeaf
(
)
{
return
!
Extend3DContext
(
)
&
&
Combines3DTransformWithAncestors
(
)
;
}
bool
IsBackfaceHidden
(
)
;
bool
IsVisible
(
)
{
return
!
GetLocalVisibleRegion
(
)
.
IsEmpty
(
)
|
|
Extend3DContext
(
)
;
}
virtual
bool
IsOpaque
(
)
{
return
GetContentFlags
(
)
&
CONTENT_OPAQUE
;
}
float
GetEffectiveOpacity
(
)
;
gfx
:
:
CompositionOp
GetEffectiveMixBlendMode
(
)
;
const
gfx
:
:
Matrix4x4
&
GetEffectiveTransform
(
)
const
{
return
mEffectiveTransform
;
}
virtual
const
gfx
:
:
Matrix4x4
&
GetEffectiveTransformForBuffer
(
)
const
{
return
mEffectiveTransform
;
}
gfx
:
:
Matrix4x4
ComputeTransformToPreserve3DRoot
(
)
;
virtual
void
ComputeEffectiveTransforms
(
const
gfx
:
:
Matrix4x4
&
aTransformToSurface
)
=
0
;
void
ComputeEffectiveTransformForMaskLayers
(
const
gfx
:
:
Matrix4x4
&
aTransformToSurface
)
;
static
void
ComputeEffectiveTransformForMaskLayer
(
Layer
*
aMaskLayer
const
gfx
:
:
Matrix4x4
&
aTransformToSurface
)
;
RenderTargetIntRect
CalculateScissorRect
(
const
RenderTargetIntRect
&
aCurrentScissorRect
)
;
virtual
const
char
*
Name
(
)
const
=
0
;
virtual
LayerType
GetType
(
)
const
=
0
;
void
*
ImplData
(
)
{
return
mImplData
;
}
void
SetParent
(
ContainerLayer
*
aParent
)
{
mParent
=
aParent
;
}
void
SetNextSibling
(
Layer
*
aSibling
)
{
mNextSibling
=
aSibling
;
}
void
SetPrevSibling
(
Layer
*
aSibling
)
{
mPrevSibling
=
aSibling
;
}
void
Dump
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
=
"
"
bool
aDumpHtml
=
false
bool
aSorted
=
false
const
Maybe
<
gfx
:
:
Polygon
>
&
aGeometry
=
Nothing
(
)
)
;
void
DumpSelf
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
=
"
"
const
Maybe
<
gfx
:
:
Polygon
>
&
aGeometry
=
Nothing
(
)
)
;
void
Dump
(
layerscope
:
:
LayersPacket
*
aPacket
const
void
*
aParent
)
;
void
Log
(
const
char
*
aPrefix
=
"
"
)
;
void
LogSelf
(
const
char
*
aPrefix
=
"
"
)
;
virtual
void
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
;
virtual
void
DumpPacket
(
layerscope
:
:
LayersPacket
*
aPacket
const
void
*
aParent
)
;
void
SetDisplayListLog
(
const
char
*
log
)
;
void
GetDisplayListLog
(
nsCString
&
log
)
;
static
bool
IsLogEnabled
(
)
{
return
LayerManager
:
:
IsLogEnabled
(
)
;
}
const
virtual
gfx
:
:
TiledIntRegion
&
GetInvalidRegion
(
)
{
return
mInvalidRegion
;
}
void
AddInvalidRegion
(
const
nsIntRegion
&
aRegion
)
{
mInvalidRegion
.
Add
(
aRegion
)
;
}
void
SetInvalidRectToVisibleRegion
(
)
{
mInvalidRegion
.
SetEmpty
(
)
;
mInvalidRegion
.
Add
(
GetVisibleRegion
(
)
.
ToUnknownRegion
(
)
)
;
}
void
AddInvalidRect
(
const
gfx
:
:
IntRect
&
aRect
)
{
mInvalidRegion
.
Add
(
aRect
)
;
}
virtual
void
ClearInvalidRegion
(
)
{
mInvalidRegion
.
SetEmpty
(
)
;
}
void
SetAsyncPanZoomController
(
uint32_t
aIndex
AsyncPanZoomController
*
controller
)
;
AsyncPanZoomController
*
GetAsyncPanZoomController
(
uint32_t
aIndex
)
const
;
virtual
void
ClearCachedResources
(
)
{
}
virtual
bool
SupportsAsyncUpdate
(
)
{
return
false
;
}
private
:
void
ScrollMetadataChanged
(
)
;
public
:
void
ApplyPendingUpdatesForThisTransaction
(
)
;
#
ifdef
DEBUG
void
SetDebugColorIndex
(
uint32_t
aIndex
)
{
mDebugColorIndex
=
aIndex
;
}
uint32_t
GetDebugColorIndex
(
)
{
return
mDebugColorIndex
;
}
#
endif
void
Mutated
(
)
{
mManager
-
>
Mutated
(
this
)
;
}
void
MutatedSimple
(
)
{
mManager
-
>
MutatedSimple
(
this
)
;
}
virtual
int32_t
GetMaxLayerSize
(
)
{
return
Manager
(
)
-
>
GetMaxTextureSize
(
)
;
}
bool
MayResample
(
)
;
RenderTargetRect
TransformRectToRenderTarget
(
const
LayerIntRect
&
aRect
)
;
void
AddExtraDumpInfo
(
const
nsACString
&
aStr
)
{
#
ifdef
MOZ_DUMP_PAINTING
mExtraDumpInfo
.
AppendElement
(
aStr
)
;
#
endif
}
void
ClearExtraDumpInfo
(
)
{
#
ifdef
MOZ_DUMP_PAINTING
mExtraDumpInfo
.
Clear
(
)
;
#
endif
}
AnimationInfo
&
GetAnimationInfo
(
)
{
return
mAnimationInfo
;
}
protected
:
Layer
(
LayerManager
*
aManager
void
*
aImplData
)
;
virtual
~
Layer
(
)
;
gfx
:
:
Matrix4x4
SnapTransformTranslation
(
const
gfx
:
:
Matrix4x4
&
aTransform
gfx
:
:
Matrix
*
aResidualTransform
)
;
gfx
:
:
Matrix4x4
SnapTransformTranslation3D
(
const
gfx
:
:
Matrix4x4
&
aTransform
gfx
:
:
Matrix
*
aResidualTransform
)
;
gfx
:
:
Matrix4x4
SnapTransform
(
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfxRect
&
aSnapRect
gfx
:
:
Matrix
*
aResidualTransform
)
;
LayerManager
*
mManager
;
ContainerLayer
*
mParent
;
Layer
*
mNextSibling
;
Layer
*
mPrevSibling
;
void
*
mImplData
;
RefPtr
<
Layer
>
mMaskLayer
;
nsTArray
<
RefPtr
<
Layer
>
>
mAncestorMaskLayers
;
mozilla
:
:
CorruptionCanary
mCanary
;
gfx
:
:
UserData
mUserData
;
SimpleLayerAttributes
mSimpleAttrs
;
LayerIntRegion
mVisibleRegion
;
nsTArray
<
ScrollMetadata
>
mScrollMetadata
;
EventRegions
mEventRegions
;
nsAutoPtr
<
gfx
:
:
Matrix4x4
>
mPendingTransform
;
gfx
:
:
Matrix4x4
mEffectiveTransform
;
AnimationInfo
mAnimationInfo
;
Maybe
<
ParentLayerIntRect
>
mClipRect
;
gfx
:
:
IntRect
mTileSourceRect
;
gfx
:
:
TiledIntRegion
mInvalidRegion
;
nsTArray
<
RefPtr
<
AsyncPanZoomController
>
>
mApzcs
;
bool
mUseTileSourceRect
;
#
ifdef
DEBUG
uint32_t
mDebugColorIndex
;
#
endif
#
ifdef
MOZ_DUMP_PAINTING
nsTArray
<
nsCString
>
mExtraDumpInfo
;
#
endif
nsCString
mDisplayListLog
;
}
;
class
PaintedLayer
:
public
Layer
{
public
:
virtual
void
InvalidateRegion
(
const
nsIntRegion
&
aRegion
)
=
0
;
void
SetAllowResidualTranslation
(
bool
aAllow
)
{
mAllowResidualTranslation
=
aAllow
;
}
void
SetValidRegion
(
const
nsIntRegion
&
aRegion
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
ValidRegion
"
this
)
)
;
mValidRegion
=
aRegion
;
mValidRegionIsCurrent
=
true
;
Mutated
(
)
;
}
const
nsIntRegion
&
GetValidRegion
(
)
const
{
EnsureValidRegionIsCurrent
(
)
;
return
mValidRegion
;
}
void
InvalidateWholeLayer
(
)
{
mInvalidRegion
.
Add
(
GetValidRegion
(
)
.
GetBounds
(
)
)
;
ClearValidRegion
(
)
;
}
void
ClearValidRegion
(
)
{
mValidRegion
.
SetEmpty
(
)
;
mValidRegionIsCurrent
=
true
;
}
void
AddToValidRegion
(
const
nsIntRegion
&
aRegion
)
{
EnsureValidRegionIsCurrent
(
)
;
mValidRegion
.
OrWith
(
aRegion
)
;
}
void
SubtractFromValidRegion
(
const
nsIntRegion
&
aRegion
)
{
EnsureValidRegionIsCurrent
(
)
;
mValidRegion
.
SubOut
(
aRegion
)
;
}
void
UpdateValidRegionAfterInvalidRegionChanged
(
)
{
mValidRegionIsCurrent
=
false
;
}
void
ClearInvalidRegion
(
)
override
{
EnsureValidRegionIsCurrent
(
)
;
mInvalidRegion
.
SetEmpty
(
)
;
}
virtual
PaintedLayer
*
AsPaintedLayer
(
)
override
{
return
this
;
}
MOZ_LAYER_DECL_NAME
(
"
PaintedLayer
"
TYPE_PAINTED
)
virtual
void
ComputeEffectiveTransforms
(
const
gfx
:
:
Matrix4x4
&
aTransformToSurface
)
override
{
gfx
:
:
Matrix4x4
idealTransform
=
GetLocalTransform
(
)
*
aTransformToSurface
;
gfx
:
:
Matrix
residual
;
mEffectiveTransform
=
SnapTransformTranslation
(
idealTransform
mAllowResidualTranslation
?
&
residual
:
nullptr
)
;
NS_ASSERTION
(
residual
.
IsTranslation
(
)
"
Residual
transform
can
only
be
a
translation
"
)
;
if
(
!
gfx
:
:
ThebesPoint
(
residual
.
GetTranslation
(
)
)
.
WithinEpsilonOf
(
mResidualTranslation
1e
-
3f
)
)
{
mResidualTranslation
=
gfx
:
:
ThebesPoint
(
residual
.
GetTranslation
(
)
)
;
DebugOnly
<
mozilla
:
:
gfx
:
:
Point
>
transformedOrig
=
idealTransform
.
TransformPoint
(
mozilla
:
:
gfx
:
:
Point
(
)
)
;
#
ifdef
DEBUG
DebugOnly
<
mozilla
:
:
gfx
:
:
Point
>
transformed
=
idealTransform
.
TransformPoint
(
mozilla
:
:
gfx
:
:
Point
(
mResidualTranslation
.
x
mResidualTranslation
.
y
)
)
-
*
&
transformedOrig
;
#
endif
NS_ASSERTION
(
-
0
.
5
<
=
(
&
transformed
)
-
>
x
&
&
(
&
transformed
)
-
>
x
<
0
.
5
&
&
-
0
.
5
<
=
(
&
transformed
)
-
>
y
&
&
(
&
transformed
)
-
>
y
<
0
.
5
"
Residual
translation
out
of
range
"
)
;
ClearValidRegion
(
)
;
}
ComputeEffectiveTransformForMaskLayers
(
aTransformToSurface
)
;
}
LayerManager
:
:
PaintedLayerCreationHint
GetCreationHint
(
)
const
{
return
mCreationHint
;
}
bool
UsedForReadback
(
)
{
return
mUsedForReadback
;
}
void
SetUsedForReadback
(
bool
aUsed
)
{
mUsedForReadback
=
aUsed
;
}
virtual
bool
IsOptimizedFor
(
LayerManager
:
:
PaintedLayerCreationHint
aCreationHint
)
{
return
true
;
}
gfxPoint
GetResidualTranslation
(
)
const
{
return
mResidualTranslation
;
}
protected
:
PaintedLayer
(
LayerManager
*
aManager
void
*
aImplData
LayerManager
:
:
PaintedLayerCreationHint
aCreationHint
=
LayerManager
:
:
NONE
)
:
Layer
(
aManager
aImplData
)
mValidRegion
(
)
mValidRegionIsCurrent
(
true
)
mCreationHint
(
aCreationHint
)
mUsedForReadback
(
false
)
mAllowResidualTranslation
(
false
)
{
}
virtual
void
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
override
;
virtual
void
DumpPacket
(
layerscope
:
:
LayersPacket
*
aPacket
const
void
*
aParent
)
override
;
gfxPoint
mResidualTranslation
;
private
:
void
EnsureValidRegionIsCurrent
(
)
const
{
if
(
!
mValidRegionIsCurrent
)
{
if
(
!
mValidRegion
.
IsEmpty
(
)
)
{
mValidRegion
.
SubOut
(
mInvalidRegion
.
GetRegion
(
)
)
;
}
mValidRegionIsCurrent
=
true
;
}
}
mutable
nsIntRegion
mValidRegion
;
mutable
bool
mValidRegionIsCurrent
;
protected
:
const
LayerManager
:
:
PaintedLayerCreationHint
mCreationHint
;
bool
mUsedForReadback
;
bool
mAllowResidualTranslation
;
}
;
class
ContainerLayer
:
public
Layer
{
public
:
~
ContainerLayer
(
)
;
virtual
bool
InsertAfter
(
Layer
*
aChild
Layer
*
aAfter
)
;
virtual
bool
RemoveChild
(
Layer
*
aChild
)
;
virtual
bool
RepositionChild
(
Layer
*
aChild
Layer
*
aAfter
)
;
void
SetPreScale
(
float
aXScale
float
aYScale
)
{
if
(
mPreXScale
=
=
aXScale
&
&
mPreYScale
=
=
aYScale
)
{
return
;
}
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
PreScale
"
this
)
)
;
mPreXScale
=
aXScale
;
mPreYScale
=
aYScale
;
Mutated
(
)
;
}
void
SetInheritedScale
(
float
aXScale
float
aYScale
)
{
if
(
mInheritedXScale
=
=
aXScale
&
&
mInheritedYScale
=
=
aYScale
)
{
return
;
}
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
InheritedScale
"
this
)
)
;
mInheritedXScale
=
aXScale
;
mInheritedYScale
=
aYScale
;
Mutated
(
)
;
}
void
SetScaleToResolution
(
bool
aScaleToResolution
float
aResolution
)
{
if
(
mScaleToResolution
=
=
aScaleToResolution
&
&
mPresShellResolution
=
=
aResolution
)
{
return
;
}
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
ScaleToResolution
"
this
)
)
;
mScaleToResolution
=
aScaleToResolution
;
mPresShellResolution
=
aResolution
;
Mutated
(
)
;
}
virtual
void
FillSpecificAttributes
(
SpecificLayerAttributes
&
aAttrs
)
override
;
enum
class
SortMode
{
WITH_GEOMETRY
WITHOUT_GEOMETRY
}
;
nsTArray
<
LayerPolygon
>
SortChildrenBy3DZOrder
(
SortMode
aSortMode
)
;
virtual
ContainerLayer
*
AsContainerLayer
(
)
override
{
return
this
;
}
virtual
const
ContainerLayer
*
AsContainerLayer
(
)
const
override
{
return
this
;
}
virtual
Layer
*
GetFirstChild
(
)
const
override
{
return
mFirstChild
;
}
virtual
Layer
*
GetLastChild
(
)
const
override
{
return
mLastChild
;
}
float
GetPreXScale
(
)
const
{
return
mPreXScale
;
}
float
GetPreYScale
(
)
const
{
return
mPreYScale
;
}
float
GetInheritedXScale
(
)
const
{
return
mInheritedXScale
;
}
float
GetInheritedYScale
(
)
const
{
return
mInheritedYScale
;
}
float
GetPresShellResolution
(
)
const
{
return
mPresShellResolution
;
}
bool
ScaleToResolution
(
)
const
{
return
mScaleToResolution
;
}
MOZ_LAYER_DECL_NAME
(
"
ContainerLayer
"
TYPE_CONTAINER
)
virtual
void
ComputeEffectiveTransforms
(
const
gfx
:
:
Matrix4x4
&
aTransformToSurface
)
override
=
0
;
bool
UseIntermediateSurface
(
)
{
return
mUseIntermediateSurface
;
}
RenderTargetIntRect
GetIntermediateSurfaceRect
(
)
{
NS_ASSERTION
(
mUseIntermediateSurface
"
Must
have
intermediate
surface
"
)
;
return
RenderTargetIntRect
:
:
FromUnknownRect
(
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
.
GetBounds
(
)
)
;
}
bool
HasMultipleChildren
(
)
;
bool
SupportsComponentAlphaChildren
(
)
{
return
mSupportsComponentAlphaChildren
;
}
static
bool
HasOpaqueAncestorLayer
(
Layer
*
aLayer
)
;
void
SetChildrenChanged
(
bool
aVal
)
{
mChildrenChanged
=
aVal
;
}
virtual
void
SetInvalidCompositeRect
(
const
gfx
:
:
IntRect
*
aRect
)
{
}
protected
:
friend
class
ReadbackProcessor
;
void
RemoveAllChildren
(
)
;
void
DidInsertChild
(
Layer
*
aLayer
)
;
void
DidRemoveChild
(
Layer
*
aLayer
)
;
bool
AnyAncestorOrThisIs3DContextLeaf
(
)
;
void
Collect3DContextLeaves
(
nsTArray
<
Layer
*
>
&
aToSort
)
;
nsTArray
<
Layer
*
>
CollectChildren
(
)
{
nsTArray
<
Layer
*
>
children
;
for
(
Layer
*
layer
=
GetFirstChild
(
)
;
layer
;
layer
=
layer
-
>
GetNextSibling
(
)
)
{
ContainerLayer
*
container
=
layer
-
>
AsContainerLayer
(
)
;
if
(
container
&
&
container
-
>
Extend3DContext
(
)
&
&
!
container
-
>
UseIntermediateSurface
(
)
)
{
container
-
>
Collect3DContextLeaves
(
children
)
;
}
else
{
children
.
AppendElement
(
layer
)
;
}
}
return
children
;
}
ContainerLayer
(
LayerManager
*
aManager
void
*
aImplData
)
;
void
DefaultComputeEffectiveTransforms
(
const
gfx
:
:
Matrix4x4
&
aTransformToSurface
)
;
void
DefaultComputeSupportsComponentAlphaChildren
(
bool
*
aNeedsSurfaceCopy
=
nullptr
)
;
void
ComputeEffectiveTransformsForChildren
(
const
gfx
:
:
Matrix4x4
&
aTransformToSurface
)
;
virtual
void
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
override
;
virtual
void
DumpPacket
(
layerscope
:
:
LayersPacket
*
aPacket
const
void
*
aParent
)
override
;
bool
Creates3DContextWithExtendingChildren
(
)
;
Layer
*
mFirstChild
;
Layer
*
mLastChild
;
float
mPreXScale
;
float
mPreYScale
;
float
mInheritedXScale
;
float
mInheritedYScale
;
float
mPresShellResolution
;
bool
mScaleToResolution
;
bool
mUseIntermediateSurface
;
bool
mSupportsComponentAlphaChildren
;
bool
mMayHaveReadbackChild
;
bool
mChildrenChanged
;
}
;
class
ColorLayer
:
public
Layer
{
public
:
virtual
ColorLayer
*
AsColorLayer
(
)
override
{
return
this
;
}
virtual
void
SetColor
(
const
gfx
:
:
Color
&
aColor
)
{
if
(
mColor
!
=
aColor
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
Color
"
this
)
)
;
mColor
=
aColor
;
Mutated
(
)
;
}
}
void
SetBounds
(
const
gfx
:
:
IntRect
&
aBounds
)
{
if
(
!
mBounds
.
IsEqualEdges
(
aBounds
)
)
{
mBounds
=
aBounds
;
Mutated
(
)
;
}
}
const
gfx
:
:
IntRect
&
GetBounds
(
)
{
return
mBounds
;
}
virtual
const
gfx
:
:
Color
&
GetColor
(
)
{
return
mColor
;
}
MOZ_LAYER_DECL_NAME
(
"
ColorLayer
"
TYPE_COLOR
)
virtual
void
ComputeEffectiveTransforms
(
const
gfx
:
:
Matrix4x4
&
aTransformToSurface
)
override
{
gfx
:
:
Matrix4x4
idealTransform
=
GetLocalTransform
(
)
*
aTransformToSurface
;
mEffectiveTransform
=
SnapTransformTranslation
(
idealTransform
nullptr
)
;
ComputeEffectiveTransformForMaskLayers
(
aTransformToSurface
)
;
}
protected
:
ColorLayer
(
LayerManager
*
aManager
void
*
aImplData
)
:
Layer
(
aManager
aImplData
)
mColor
(
)
{
}
virtual
void
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
override
;
virtual
void
DumpPacket
(
layerscope
:
:
LayersPacket
*
aPacket
const
void
*
aParent
)
override
;
gfx
:
:
IntRect
mBounds
;
gfx
:
:
Color
mColor
;
}
;
class
CanvasLayer
:
public
Layer
{
public
:
void
SetBounds
(
gfx
:
:
IntRect
aBounds
)
{
mBounds
=
aBounds
;
}
virtual
CanvasLayer
*
AsCanvasLayer
(
)
override
{
return
this
;
}
void
Updated
(
)
{
mCanvasRenderer
-
>
SetDirty
(
)
;
SetInvalidRectToVisibleRegion
(
)
;
}
void
Painted
(
)
{
mCanvasRenderer
-
>
ResetDirty
(
)
;
}
bool
IsDirty
(
)
{
if
(
!
mManager
|
|
!
mManager
-
>
IsWidgetLayerManager
(
)
)
{
return
true
;
}
return
mCanvasRenderer
-
>
IsDirty
(
)
;
}
const
nsIntRect
&
GetBounds
(
)
const
{
return
mBounds
;
}
CanvasRenderer
*
CreateOrGetCanvasRenderer
(
)
;
public
:
void
SetSamplingFilter
(
gfx
:
:
SamplingFilter
aSamplingFilter
)
{
if
(
mSamplingFilter
!
=
aSamplingFilter
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
Filter
"
this
)
)
;
mSamplingFilter
=
aSamplingFilter
;
Mutated
(
)
;
}
}
gfx
:
:
SamplingFilter
GetSamplingFilter
(
)
const
{
return
mSamplingFilter
;
}
MOZ_LAYER_DECL_NAME
(
"
CanvasLayer
"
TYPE_CANVAS
)
virtual
void
ComputeEffectiveTransforms
(
const
gfx
:
:
Matrix4x4
&
aTransformToSurface
)
override
{
mEffectiveTransform
=
SnapTransform
(
GetLocalTransform
(
)
gfxRect
(
0
0
mBounds
.
Width
(
)
mBounds
.
Height
(
)
)
nullptr
)
*
SnapTransformTranslation
(
aTransformToSurface
nullptr
)
;
ComputeEffectiveTransformForMaskLayers
(
aTransformToSurface
)
;
}
protected
:
CanvasLayer
(
LayerManager
*
aManager
void
*
aImplData
)
;
virtual
~
CanvasLayer
(
)
;
virtual
void
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
override
;
virtual
void
DumpPacket
(
layerscope
:
:
LayersPacket
*
aPacket
const
void
*
aParent
)
override
;
virtual
CanvasRenderer
*
CreateCanvasRendererInternal
(
)
=
0
;
UniquePtr
<
CanvasRenderer
>
mCanvasRenderer
;
gfx
:
:
SamplingFilter
mSamplingFilter
;
gfx
:
:
IntRect
mBounds
;
}
;
class
RefLayer
:
public
ContainerLayer
{
friend
class
LayerManager
;
private
:
virtual
bool
InsertAfter
(
Layer
*
aChild
Layer
*
aAfter
)
override
{
MOZ_CRASH
(
"
GFX
:
RefLayer
"
)
;
return
false
;
}
virtual
bool
RemoveChild
(
Layer
*
aChild
)
override
{
MOZ_CRASH
(
"
GFX
:
RefLayer
"
)
;
return
false
;
}
virtual
bool
RepositionChild
(
Layer
*
aChild
Layer
*
aAfter
)
override
{
MOZ_CRASH
(
"
GFX
:
RefLayer
"
)
;
return
false
;
}
public
:
void
SetReferentId
(
LayersId
aId
)
{
MOZ_ASSERT
(
aId
.
IsValid
(
)
)
;
if
(
mId
!
=
aId
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
ReferentId
"
this
)
)
;
mId
=
aId
;
Mutated
(
)
;
}
}
void
ConnectReferentLayer
(
Layer
*
aLayer
)
{
MOZ_ASSERT
(
!
mFirstChild
&
&
!
mLastChild
)
;
MOZ_ASSERT
(
!
aLayer
-
>
GetParent
(
)
)
;
if
(
aLayer
-
>
Manager
(
)
!
=
Manager
(
)
)
{
NS_WARNING
(
"
ConnectReferentLayer
failed
-
Incorrect
LayerManager
"
)
;
return
;
}
mFirstChild
=
mLastChild
=
aLayer
;
aLayer
-
>
SetParent
(
this
)
;
}
void
SetEventRegionsOverride
(
EventRegionsOverride
aVal
)
{
if
(
mEventRegionsOverride
=
=
aVal
)
{
return
;
}
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
EventRegionsOverride
"
this
)
)
;
mEventRegionsOverride
=
aVal
;
Mutated
(
)
;
}
EventRegionsOverride
GetEventRegionsOverride
(
)
const
{
return
mEventRegionsOverride
;
}
void
DetachReferentLayer
(
Layer
*
aLayer
)
{
mFirstChild
=
mLastChild
=
nullptr
;
aLayer
-
>
SetParent
(
nullptr
)
;
}
virtual
RefLayer
*
AsRefLayer
(
)
override
{
return
this
;
}
virtual
LayersId
GetReferentId
(
)
{
return
mId
;
}
virtual
void
FillSpecificAttributes
(
SpecificLayerAttributes
&
aAttrs
)
override
;
MOZ_LAYER_DECL_NAME
(
"
RefLayer
"
TYPE_REF
)
protected
:
RefLayer
(
LayerManager
*
aManager
void
*
aImplData
)
:
ContainerLayer
(
aManager
aImplData
)
mId
{
0
}
mEventRegionsOverride
(
EventRegionsOverride
:
:
NoOverride
)
{
}
virtual
void
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
override
;
virtual
void
DumpPacket
(
layerscope
:
:
LayersPacket
*
aPacket
const
void
*
aParent
)
override
;
LayersId
mId
;
EventRegionsOverride
mEventRegionsOverride
;
}
;
void
SetAntialiasingFlags
(
Layer
*
aLayer
gfx
:
:
DrawTarget
*
aTarget
)
;
#
ifdef
MOZ_DUMP_PAINTING
void
WriteSnapshotToDumpFile
(
Layer
*
aLayer
gfx
:
:
DataSourceSurface
*
aSurf
)
;
void
WriteSnapshotToDumpFile
(
LayerManager
*
aManager
gfx
:
:
DataSourceSurface
*
aSurf
)
;
void
WriteSnapshotToDumpFile
(
Compositor
*
aCompositor
gfx
:
:
DrawTarget
*
aTarget
)
;
#
endif
gfx
:
:
IntRect
ToOutsideIntRect
(
const
gfxRect
&
aRect
)
;
}
}
#
endif
