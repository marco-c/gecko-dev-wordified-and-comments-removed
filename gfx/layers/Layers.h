#
ifndef
GFX_LAYERS_H
#
define
GFX_LAYERS_H
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
iosfwd
>
#
include
<
new
>
#
include
<
unordered_set
>
#
include
<
utility
>
#
include
"
FrameMetrics
.
h
"
#
include
"
Units
.
h
"
#
include
"
gfxPoint
.
h
"
#
include
"
gfxRect
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Poison
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
gfx
/
BasePoint
.
h
"
#
include
"
mozilla
/
gfx
/
BaseSize
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Polygon
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
TiledRegion
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
gfx
/
UserData
.
h
"
#
include
"
mozilla
/
layers
/
AnimationInfo
.
h
"
#
include
"
mozilla
/
layers
/
LayerAttributes
.
h
"
#
include
"
mozilla
/
layers
/
LayerManager
.
h
"
#
include
"
mozilla
/
layers
/
ScrollableLayerGuid
.
h
"
#
include
"
mozilla
/
layers
/
BSPTree
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsStringFlags
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
nsDebug
.
h
"
namespace
mozilla
{
namespace
gfx
{
class
DataSourceSurface
;
class
DrawTarget
;
class
Path
;
}
namespace
layers
{
class
Animation
;
class
AsyncPanZoomController
;
class
CompositorAnimations
;
class
SpecificLayerAttributes
;
class
Compositor
;
class
TransformData
;
struct
PropertyAnimationGroup
;
#
define
MOZ_LAYER_DECL_NAME
(
n
e
)
\
const
char
*
Name
(
)
const
override
{
return
n
;
}
\
LayerType
GetType
(
)
const
override
{
return
e
;
}
\
static
LayerType
Type
(
)
{
return
e
;
}
class
Layer
{
NS_INLINE_DECL_REFCOUNTING
(
Layer
)
using
AnimationArray
=
nsTArray
<
layers
:
:
Animation
>
;
public
:
enum
LayerType
{
TYPE_CANVAS
TYPE_COLOR
TYPE_CONTAINER
TYPE_DISPLAYITEM
TYPE_IMAGE
TYPE_SHADOW
TYPE_PAINTED
}
;
LayerManager
*
Manager
(
)
{
return
mManager
;
}
enum
{
CONTENT_OPAQUE
=
0x01
CONTENT_COMPONENT_ALPHA
=
0x02
CONTENT_EXTEND_3D_CONTEXT
=
0x08
CONTENT_DISABLE_SUBPIXEL_AA
=
0x20
CONTENT_DISABLE_FLATTENING
=
0x40
CONTENT_BACKFACE_HIDDEN
=
0x80
CONTENT_SNAP_TO_GRID
=
0x100
}
;
void
SetContentFlags
(
uint32_t
aFlags
)
{
NS_ASSERTION
(
(
aFlags
&
(
CONTENT_OPAQUE
|
CONTENT_COMPONENT_ALPHA
)
)
!
=
(
CONTENT_OPAQUE
|
CONTENT_COMPONENT_ALPHA
)
"
Can
'
t
be
opaque
and
require
component
alpha
"
)
;
if
(
mSimpleAttrs
.
SetContentFlags
(
aFlags
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
ContentFlags
"
this
)
)
;
MutatedSimple
(
)
;
}
}
virtual
void
SetVisibleRegion
(
const
LayerIntRegion
&
aRegion
)
{
if
(
!
mVisibleRegion
.
IsEqual
(
aRegion
)
|
|
aRegion
.
IsEmpty
(
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
VisibleRegion
was
%
s
is
%
s
"
this
mVisibleRegion
.
ToString
(
)
.
get
(
)
aRegion
.
ToString
(
)
.
get
(
)
)
)
;
mVisibleRegion
=
aRegion
;
Mutated
(
)
;
}
}
void
SetScrollMetadata
(
const
ScrollMetadata
&
aScrollMetadata
)
{
Manager
(
)
-
>
ClearPendingScrollInfoUpdate
(
)
;
if
(
mScrollMetadata
.
Length
(
)
!
=
1
|
|
mScrollMetadata
[
0
]
!
=
aScrollMetadata
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
ScrollMetadata
"
this
)
)
;
mScrollMetadata
.
ReplaceElementsAt
(
0
mScrollMetadata
.
Length
(
)
aScrollMetadata
)
;
ScrollMetadataChanged
(
)
;
Mutated
(
)
;
}
}
void
SetScrollMetadata
(
const
nsTArray
<
ScrollMetadata
>
&
aMetadataArray
)
{
Manager
(
)
-
>
ClearPendingScrollInfoUpdate
(
)
;
if
(
mScrollMetadata
!
=
aMetadataArray
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
ScrollMetadata
"
this
)
)
;
mScrollMetadata
=
aMetadataArray
.
Clone
(
)
;
ScrollMetadataChanged
(
)
;
Mutated
(
)
;
}
}
void
SetEventRegions
(
const
EventRegions
&
aRegions
)
;
void
SetOpacity
(
float
aOpacity
)
{
if
(
mSimpleAttrs
.
SetOpacity
(
aOpacity
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
Opacity
"
this
)
)
;
MutatedSimple
(
)
;
}
}
void
SetMixBlendMode
(
gfx
:
:
CompositionOp
aMixBlendMode
)
{
if
(
mSimpleAttrs
.
SetMixBlendMode
(
aMixBlendMode
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
MixBlendMode
"
this
)
)
;
MutatedSimple
(
)
;
}
}
void
SetForceIsolatedGroup
(
bool
aForceIsolatedGroup
)
{
if
(
mSimpleAttrs
.
SetForceIsolatedGroup
(
aForceIsolatedGroup
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
ForceIsolatedGroup
"
this
)
)
;
MutatedSimple
(
)
;
}
}
bool
GetForceIsolatedGroup
(
)
const
{
return
mSimpleAttrs
.
GetForceIsolatedGroup
(
)
;
}
void
SetClipRect
(
const
Maybe
<
ParentLayerIntRect
>
&
aRect
)
{
if
(
mClipRect
)
{
if
(
!
aRect
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
ClipRect
was
%
d
%
d
%
d
%
d
is
<
none
>
"
this
mClipRect
-
>
X
(
)
mClipRect
-
>
Y
(
)
mClipRect
-
>
Width
(
)
mClipRect
-
>
Height
(
)
)
)
;
mClipRect
.
reset
(
)
;
Mutated
(
)
;
}
else
{
if
(
!
aRect
-
>
IsEqualEdges
(
*
mClipRect
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
ClipRect
was
%
d
%
d
%
d
%
d
is
%
d
%
d
%
d
%
d
"
this
mClipRect
-
>
X
(
)
mClipRect
-
>
Y
(
)
mClipRect
-
>
Width
(
)
mClipRect
-
>
Height
(
)
aRect
-
>
X
(
)
aRect
-
>
Y
(
)
aRect
-
>
Width
(
)
aRect
-
>
Height
(
)
)
)
;
mClipRect
=
aRect
;
Mutated
(
)
;
}
}
}
else
{
if
(
aRect
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
ClipRect
was
<
none
>
is
%
d
%
d
%
d
%
d
"
this
aRect
-
>
X
(
)
aRect
-
>
Y
(
)
aRect
-
>
Width
(
)
aRect
-
>
Height
(
)
)
)
;
mClipRect
=
aRect
;
Mutated
(
)
;
}
}
}
void
SetMaskLayer
(
Layer
*
aMaskLayer
)
{
#
ifdef
DEBUG
if
(
aMaskLayer
)
{
bool
maskIs2D
=
aMaskLayer
-
>
GetTransform
(
)
.
CanDraw2D
(
)
;
NS_ASSERTION
(
maskIs2D
"
Mask
layer
has
invalid
transform
.
"
)
;
}
#
endif
if
(
mMaskLayer
!
=
aMaskLayer
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
MaskLayer
"
this
)
)
;
mMaskLayer
=
aMaskLayer
;
Mutated
(
)
;
}
}
void
SetBaseTransform
(
const
gfx
:
:
Matrix4x4
&
aMatrix
)
{
NS_ASSERTION
(
!
aMatrix
.
IsSingular
(
)
"
Shouldn
'
t
be
trying
to
draw
with
a
singular
matrix
!
"
)
;
mPendingTransform
=
nullptr
;
if
(
!
mSimpleAttrs
.
SetTransform
(
aMatrix
)
)
{
return
;
}
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
BaseTransform
"
this
)
)
;
MutatedSimple
(
)
;
}
void
SetBaseTransformForNextTransaction
(
const
gfx
:
:
Matrix4x4
&
aMatrix
)
{
mPendingTransform
=
mozilla
:
:
MakeUnique
<
gfx
:
:
Matrix4x4
>
(
aMatrix
)
;
}
void
SetPostScale
(
float
aXScale
float
aYScale
)
{
if
(
!
mSimpleAttrs
.
SetPostScale
(
aXScale
aYScale
)
)
{
return
;
}
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
PostScale
"
this
)
)
;
MutatedSimple
(
)
;
}
void
SetIsFixedPosition
(
bool
aFixedPosition
)
{
if
(
mSimpleAttrs
.
SetIsFixedPosition
(
aFixedPosition
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
IsFixedPosition
"
this
)
)
;
MutatedSimple
(
)
;
}
}
void
SetAsyncZoomContainerId
(
const
Maybe
<
FrameMetrics
:
:
ViewID
>
&
aViewId
)
{
if
(
mSimpleAttrs
.
SetAsyncZoomContainerId
(
aViewId
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
AsyncZoomContainerId
"
this
)
)
;
MutatedSimple
(
)
;
}
}
void
SetTransformIsPerspective
(
bool
aTransformIsPerspective
)
{
if
(
mSimpleAttrs
.
SetTransformIsPerspective
(
aTransformIsPerspective
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
TransformIsPerspective
"
this
)
)
;
MutatedSimple
(
)
;
}
}
void
SetCompositorAnimations
(
const
LayersId
&
aLayersId
const
CompositorAnimations
&
aCompositorAnimations
)
;
void
StartPendingAnimations
(
const
TimeStamp
&
aReadyTime
)
;
void
ClearCompositorAnimations
(
)
;
void
SetFixedPositionData
(
ScrollableLayerGuid
:
:
ViewID
aScrollId
const
LayerPoint
&
aAnchor
SideBits
aSides
)
{
if
(
mSimpleAttrs
.
SetFixedPositionData
(
aScrollId
aAnchor
aSides
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
FixedPositionData
"
this
)
)
;
MutatedSimple
(
)
;
}
}
void
SetStickyPositionData
(
ScrollableLayerGuid
:
:
ViewID
aScrollId
LayerRectAbsolute
aOuter
LayerRectAbsolute
aInner
)
{
if
(
mSimpleAttrs
.
SetStickyPositionData
(
aScrollId
aOuter
aInner
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
StickyPositionData
"
this
)
)
;
MutatedSimple
(
)
;
}
}
void
SetScrollbarData
(
const
ScrollbarData
&
aThumbData
)
{
if
(
mSimpleAttrs
.
SetScrollbarData
(
aThumbData
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
ScrollbarData
"
this
)
)
;
MutatedSimple
(
)
;
}
}
void
SetSimpleAttributes
(
const
SimpleLayerAttributes
&
aAttrs
)
{
mSimpleAttrs
=
aAttrs
;
}
const
SimpleLayerAttributes
&
GetSimpleAttributes
(
)
const
{
return
mSimpleAttrs
;
}
float
GetOpacity
(
)
{
return
mSimpleAttrs
.
GetOpacity
(
)
;
}
gfx
:
:
CompositionOp
GetMixBlendMode
(
)
const
{
return
mSimpleAttrs
.
GetMixBlendMode
(
)
;
}
const
Maybe
<
ParentLayerIntRect
>
&
GetClipRect
(
)
const
{
return
mClipRect
;
}
uint32_t
GetContentFlags
(
)
{
return
mSimpleAttrs
.
GetContentFlags
(
)
;
}
const
LayerIntRegion
&
GetVisibleRegion
(
)
const
{
return
mVisibleRegion
;
}
const
ScrollMetadata
&
GetScrollMetadata
(
uint32_t
aIndex
)
const
;
const
FrameMetrics
&
GetFrameMetrics
(
uint32_t
aIndex
)
const
;
uint32_t
GetScrollMetadataCount
(
)
const
{
return
mScrollMetadata
.
Length
(
)
;
}
const
nsTArray
<
ScrollMetadata
>
&
GetAllScrollMetadata
(
)
{
return
mScrollMetadata
;
}
bool
HasScrollableFrameMetrics
(
)
const
;
bool
IsScrollableWithoutContent
(
)
const
;
const
EventRegions
&
GetEventRegions
(
)
const
{
return
mEventRegions
;
}
Layer
*
GetParent
(
)
const
{
return
mParent
;
}
Layer
*
GetNextSibling
(
)
{
if
(
mNextSibling
)
{
mNextSibling
-
>
CheckCanary
(
)
;
}
return
mNextSibling
;
}
const
Layer
*
GetNextSibling
(
)
const
{
if
(
mNextSibling
)
{
mNextSibling
-
>
CheckCanary
(
)
;
}
return
mNextSibling
;
}
Layer
*
GetPrevSibling
(
)
{
return
mPrevSibling
;
}
const
Layer
*
GetPrevSibling
(
)
const
{
return
mPrevSibling
;
}
virtual
Layer
*
GetFirstChild
(
)
const
{
return
nullptr
;
}
virtual
Layer
*
GetLastChild
(
)
const
{
return
nullptr
;
}
gfx
:
:
Matrix4x4
GetTransform
(
)
const
;
const
CSSTransformMatrix
GetTransformTyped
(
)
const
;
const
gfx
:
:
Matrix4x4
&
GetBaseTransform
(
)
const
{
return
mSimpleAttrs
.
GetTransform
(
)
;
}
virtual
float
GetPostXScale
(
)
const
{
return
mSimpleAttrs
.
GetPostXScale
(
)
;
}
virtual
float
GetPostYScale
(
)
const
{
return
mSimpleAttrs
.
GetPostYScale
(
)
;
}
bool
GetIsFixedPosition
(
)
{
return
mSimpleAttrs
.
IsFixedPosition
(
)
;
}
Maybe
<
FrameMetrics
:
:
ViewID
>
GetAsyncZoomContainerId
(
)
{
return
mSimpleAttrs
.
GetAsyncZoomContainerId
(
)
;
}
bool
GetTransformIsPerspective
(
)
const
{
return
mSimpleAttrs
.
GetTransformIsPerspective
(
)
;
}
bool
GetIsStickyPosition
(
)
{
return
mSimpleAttrs
.
IsStickyPosition
(
)
;
}
ScrollableLayerGuid
:
:
ViewID
GetFixedPositionScrollContainerId
(
)
{
return
mSimpleAttrs
.
GetFixedPositionScrollContainerId
(
)
;
}
LayerPoint
GetFixedPositionAnchor
(
)
{
return
mSimpleAttrs
.
GetFixedPositionAnchor
(
)
;
}
SideBits
GetFixedPositionSides
(
)
{
return
mSimpleAttrs
.
GetFixedPositionSides
(
)
;
}
ScrollableLayerGuid
:
:
ViewID
GetStickyScrollContainerId
(
)
{
return
mSimpleAttrs
.
GetStickyScrollContainerId
(
)
;
}
const
LayerRectAbsolute
&
GetStickyScrollRangeOuter
(
)
{
return
mSimpleAttrs
.
GetStickyScrollRangeOuter
(
)
;
}
const
LayerRectAbsolute
&
GetStickyScrollRangeInner
(
)
{
return
mSimpleAttrs
.
GetStickyScrollRangeInner
(
)
;
}
const
ScrollbarData
&
GetScrollbarData
(
)
const
{
return
mSimpleAttrs
.
GetScrollbarData
(
)
;
}
bool
IsScrollbarContainer
(
)
const
;
Layer
*
GetMaskLayer
(
)
const
{
return
mMaskLayer
;
}
bool
HasPendingTransform
(
)
const
{
return
!
!
mPendingTransform
;
}
void
CheckCanary
(
)
const
{
mCanary
.
Check
(
)
;
}
bool
GetVisibleRegionRelativeToRootLayer
(
nsIntRegion
&
aResult
nsIntPoint
*
aLayerOffset
)
;
AnimationArray
&
GetAnimations
(
)
{
return
mAnimationInfo
.
GetAnimations
(
)
;
}
uint64_t
GetCompositorAnimationsId
(
)
{
return
mAnimationInfo
.
GetCompositorAnimationsId
(
)
;
}
nsTArray
<
PropertyAnimationGroup
>
&
GetPropertyAnimationGroups
(
)
{
return
mAnimationInfo
.
GetPropertyAnimationGroups
(
)
;
}
const
Maybe
<
TransformData
>
&
GetTransformData
(
)
const
{
return
mAnimationInfo
.
GetTransformData
(
)
;
}
const
LayersId
&
GetAnimationLayersId
(
)
const
{
return
mAnimationInfo
.
GetLayersId
(
)
;
}
Maybe
<
uint64_t
>
GetAnimationGeneration
(
)
const
{
return
mAnimationInfo
.
GetAnimationGeneration
(
)
;
}
gfx
:
:
Path
*
CachedMotionPath
(
)
{
return
mAnimationInfo
.
CachedMotionPath
(
)
;
}
bool
HasTransformAnimation
(
)
const
;
gfx
:
:
Matrix4x4
GetLocalTransform
(
)
;
const
LayerToParentLayerMatrix4x4
GetLocalTransformTyped
(
)
;
float
GetLocalOpacity
(
)
;
std
:
:
unordered_set
<
ScrollableLayerGuid
:
:
ViewID
>
ApplyPendingUpdatesToSubtree
(
)
;
bool
CanUseOpaqueSurface
(
)
;
SurfaceMode
GetSurfaceMode
(
)
{
if
(
CanUseOpaqueSurface
(
)
)
return
SurfaceMode
:
:
SURFACE_OPAQUE
;
if
(
GetContentFlags
(
)
&
CONTENT_COMPONENT_ALPHA
)
return
SurfaceMode
:
:
SURFACE_COMPONENT_ALPHA
;
return
SurfaceMode
:
:
SURFACE_SINGLE_CHANNEL_ALPHA
;
}
bool
IsOpaqueForVisibility
(
)
;
void
SetUserData
(
void
*
aKey
LayerUserData
*
aData
void
(
*
aDestroy
)
(
void
*
)
=
LayerManager
:
:
LayerUserDataDestroy
)
{
mUserData
.
Add
(
static_cast
<
gfx
:
:
UserDataKey
*
>
(
aKey
)
aData
aDestroy
)
;
}
UniquePtr
<
LayerUserData
>
RemoveUserData
(
void
*
aKey
)
;
bool
HasUserData
(
void
*
aKey
)
{
return
mUserData
.
Has
(
static_cast
<
gfx
:
:
UserDataKey
*
>
(
aKey
)
)
;
}
LayerUserData
*
GetUserData
(
void
*
aKey
)
const
{
return
static_cast
<
LayerUserData
*
>
(
mUserData
.
Get
(
static_cast
<
gfx
:
:
UserDataKey
*
>
(
aKey
)
)
)
;
}
virtual
void
Disconnect
(
)
{
}
virtual
Layer
*
AsContainerLayer
(
)
{
return
nullptr
;
}
virtual
const
Layer
*
AsContainerLayer
(
)
const
{
return
nullptr
;
}
const
Maybe
<
ParentLayerIntRect
>
&
GetLocalClipRect
(
)
;
const
LayerIntRegion
&
GetLocalVisibleRegion
(
)
;
bool
Extend3DContext
(
)
{
return
GetContentFlags
(
)
&
CONTENT_EXTEND_3D_CONTEXT
;
}
bool
Combines3DTransformWithAncestors
(
)
{
return
GetParent
(
)
&
&
reinterpret_cast
<
Layer
*
>
(
GetParent
(
)
)
-
>
Extend3DContext
(
)
;
}
bool
Is3DContextLeaf
(
)
{
return
!
Extend3DContext
(
)
&
&
Combines3DTransformWithAncestors
(
)
;
}
bool
IsBackfaceHidden
(
)
;
bool
IsVisible
(
)
{
return
!
GetLocalVisibleRegion
(
)
.
IsEmpty
(
)
|
|
Extend3DContext
(
)
;
}
virtual
bool
IsOpaque
(
)
{
return
GetContentFlags
(
)
&
CONTENT_OPAQUE
;
}
float
GetEffectiveOpacity
(
)
;
gfx
:
:
CompositionOp
GetEffectiveMixBlendMode
(
)
;
const
gfx
:
:
Matrix4x4
&
GetEffectiveTransform
(
)
const
{
return
mEffectiveTransform
;
}
virtual
const
gfx
:
:
Matrix4x4
&
GetEffectiveTransformForBuffer
(
)
const
{
return
mEffectiveTransform
;
}
gfx
:
:
Matrix4x4
ComputeTransformToPreserve3DRoot
(
)
;
virtual
void
ComputeEffectiveTransforms
(
const
gfx
:
:
Matrix4x4
&
aTransformToSurface
)
=
0
;
void
ComputeEffectiveTransformForMaskLayers
(
const
gfx
:
:
Matrix4x4
&
aTransformToSurface
)
;
static
void
ComputeEffectiveTransformForMaskLayer
(
Layer
*
aMaskLayer
const
gfx
:
:
Matrix4x4
&
aTransformToSurface
)
;
RenderTargetIntRect
CalculateScissorRect
(
const
RenderTargetIntRect
&
aCurrentScissorRect
)
;
virtual
const
char
*
Name
(
)
const
=
0
;
virtual
LayerType
GetType
(
)
const
=
0
;
void
*
ImplData
(
)
{
return
mImplData
;
}
void
SetParent
(
Layer
*
aParent
)
{
mParent
=
aParent
;
}
void
SetNextSibling
(
Layer
*
aSibling
)
{
mNextSibling
=
aSibling
;
}
void
SetPrevSibling
(
Layer
*
aSibling
)
{
mPrevSibling
=
aSibling
;
}
void
Log
(
const
char
*
aPrefix
=
"
"
)
;
void
LogSelf
(
const
char
*
aPrefix
=
"
"
)
;
virtual
void
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
;
void
SetDisplayListLog
(
const
char
*
log
)
;
void
GetDisplayListLog
(
nsCString
&
log
)
;
static
bool
IsLogEnabled
(
)
{
return
LayerManager
:
:
IsLogEnabled
(
)
;
}
const
virtual
gfx
:
:
TiledIntRegion
&
GetInvalidRegion
(
)
{
return
mInvalidRegion
;
}
void
AddInvalidRegion
(
const
nsIntRegion
&
aRegion
)
{
mInvalidRegion
.
Add
(
aRegion
)
;
}
void
SetInvalidRectToVisibleRegion
(
)
{
mInvalidRegion
.
SetEmpty
(
)
;
mInvalidRegion
.
Add
(
GetVisibleRegion
(
)
.
ToUnknownRegion
(
)
)
;
}
void
AddInvalidRect
(
const
gfx
:
:
IntRect
&
aRect
)
{
mInvalidRegion
.
Add
(
aRect
)
;
}
virtual
void
ClearInvalidRegion
(
)
{
mInvalidRegion
.
SetEmpty
(
)
;
}
void
SetAsyncPanZoomController
(
uint32_t
aIndex
AsyncPanZoomController
*
controller
)
;
AsyncPanZoomController
*
GetAsyncPanZoomController
(
uint32_t
aIndex
)
const
;
virtual
void
ClearCachedResources
(
)
{
}
virtual
bool
SupportsAsyncUpdate
(
)
{
return
false
;
}
private
:
void
ScrollMetadataChanged
(
)
;
public
:
void
ApplyPendingUpdatesForThisTransaction
(
)
;
#
ifdef
DEBUG
void
SetDebugColorIndex
(
uint32_t
aIndex
)
{
mDebugColorIndex
=
aIndex
;
}
uint32_t
GetDebugColorIndex
(
)
{
return
mDebugColorIndex
;
}
#
endif
void
Mutated
(
)
{
mManager
-
>
Mutated
(
this
)
;
}
void
MutatedSimple
(
)
{
mManager
-
>
MutatedSimple
(
this
)
;
}
virtual
int32_t
GetMaxLayerSize
(
)
{
return
Manager
(
)
-
>
GetMaxTextureSize
(
)
;
}
RenderTargetRect
TransformRectToRenderTarget
(
const
LayerIntRect
&
aRect
)
;
void
AddExtraDumpInfo
(
const
nsACString
&
aStr
)
{
#
ifdef
MOZ_DUMP_PAINTING
mExtraDumpInfo
.
AppendElement
(
aStr
)
;
#
endif
}
void
ClearExtraDumpInfo
(
)
{
#
ifdef
MOZ_DUMP_PAINTING
mExtraDumpInfo
.
Clear
(
)
;
#
endif
}
AnimationInfo
&
GetAnimationInfo
(
)
{
return
mAnimationInfo
;
}
protected
:
Layer
(
LayerManager
*
aManager
void
*
aImplData
)
;
virtual
~
Layer
(
)
;
gfx
:
:
Matrix4x4
SnapTransformTranslation
(
const
gfx
:
:
Matrix4x4
&
aTransform
gfx
:
:
Matrix
*
aResidualTransform
)
;
gfx
:
:
Matrix4x4
SnapTransformTranslation3D
(
const
gfx
:
:
Matrix4x4
&
aTransform
gfx
:
:
Matrix
*
aResidualTransform
)
;
gfx
:
:
Matrix4x4
SnapTransform
(
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfxRect
&
aSnapRect
gfx
:
:
Matrix
*
aResidualTransform
)
;
LayerManager
*
mManager
;
Layer
*
mParent
;
Layer
*
mNextSibling
;
Layer
*
mPrevSibling
;
void
*
mImplData
;
RefPtr
<
Layer
>
mMaskLayer
;
nsTArray
<
RefPtr
<
Layer
>
>
mAncestorMaskLayers
;
mozilla
:
:
CorruptionCanary
mCanary
;
gfx
:
:
UserData
mUserData
;
SimpleLayerAttributes
mSimpleAttrs
;
LayerIntRegion
mVisibleRegion
;
nsTArray
<
ScrollMetadata
>
mScrollMetadata
;
EventRegions
mEventRegions
;
UniquePtr
<
gfx
:
:
Matrix4x4
>
mPendingTransform
;
gfx
:
:
Matrix4x4
mEffectiveTransform
;
AnimationInfo
mAnimationInfo
;
Maybe
<
ParentLayerIntRect
>
mClipRect
;
gfx
:
:
IntRect
mTileSourceRect
;
gfx
:
:
TiledIntRegion
mInvalidRegion
;
nsTArray
<
RefPtr
<
AsyncPanZoomController
>
>
mApzcs
;
bool
mUseTileSourceRect
;
#
ifdef
DEBUG
uint32_t
mDebugColorIndex
;
#
endif
#
ifdef
MOZ_DUMP_PAINTING
nsTArray
<
nsCString
>
mExtraDumpInfo
;
#
endif
nsCString
mDisplayListLog
;
}
;
void
SetAntialiasingFlags
(
Layer
*
aLayer
gfx
:
:
DrawTarget
*
aTarget
)
;
#
ifdef
MOZ_DUMP_PAINTING
void
WriteSnapshotToDumpFile
(
Layer
*
aLayer
gfx
:
:
DataSourceSurface
*
aSurf
)
;
void
WriteSnapshotToDumpFile
(
LayerManager
*
aManager
gfx
:
:
DataSourceSurface
*
aSurf
)
;
void
WriteSnapshotToDumpFile
(
Compositor
*
aCompositor
gfx
:
:
DrawTarget
*
aTarget
)
;
#
endif
gfx
:
:
IntRect
ToOutsideIntRect
(
const
gfxRect
&
aRect
)
;
void
RecordCompositionPayloadsPresented
(
const
TimeStamp
&
aCompositionEndTime
const
nsTArray
<
CompositionPayload
>
&
aPayloads
)
;
}
}
#
endif
