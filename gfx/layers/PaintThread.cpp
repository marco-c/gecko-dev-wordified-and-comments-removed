#
include
"
PaintThread
.
h
"
#
include
<
algorithm
>
#
include
"
base
/
task
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
ShadowLayers
.
h
"
#
include
"
mozilla
/
layers
/
SyncObject
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_layers
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
mozilla
/
SyncRunnable
.
h
"
#
include
"
nsIPropertyBag2
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
prsystem
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
gfx
;
void
PaintTask
:
:
DropTextureClients
(
)
{
mClients
.
Clear
(
)
;
}
StaticAutoPtr
<
PaintThread
>
PaintThread
:
:
sSingleton
;
StaticRefPtr
<
nsIThread
>
PaintThread
:
:
sThread
;
PlatformThreadId
PaintThread
:
:
sThreadId
;
PaintThread
:
:
PaintThread
(
)
{
}
void
PaintThread
:
:
Release
(
)
{
}
void
PaintThread
:
:
AddRef
(
)
{
}
int32_t
PaintThread
:
:
CalculatePaintWorkerCount
(
)
{
int32_t
cpuCores
=
PR_GetNumberOfProcessors
(
)
;
int32_t
workerCount
=
StaticPrefs
:
:
layers_omtp_paint_workers_AtStartup
(
)
;
if
(
workerCount
<
1
)
{
workerCount
=
std
:
:
min
(
std
:
:
max
(
(
cpuCores
*
3
)
/
4
1
)
4
)
;
}
return
workerCount
;
}
void
PaintThread
:
:
Start
(
)
{
PaintThread
:
:
sSingleton
=
new
PaintThread
(
)
;
if
(
!
PaintThread
:
:
sSingleton
-
>
Init
(
)
)
{
gfxCriticalNote
<
<
"
Unable
to
start
paint
thread
"
;
PaintThread
:
:
sSingleton
=
nullptr
;
}
}
bool
PaintThread
:
:
Init
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
nsIThread
>
thread
;
nsresult
rv
=
NS_NewNamedThread
(
"
PaintThread
"
getter_AddRefs
(
thread
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
sThread
=
thread
;
if
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
UsesTiling
(
)
)
{
InitPaintWorkers
(
)
;
}
nsCOMPtr
<
nsIRunnable
>
paintInitTask
=
NewRunnableMethod
(
"
PaintThread
:
:
InitOnPaintThread
"
this
&
PaintThread
:
:
InitOnPaintThread
)
;
SyncRunnable
:
:
DispatchToThread
(
sThread
paintInitTask
)
;
return
true
;
}
void
PaintThread
:
:
InitOnPaintThread
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
sThreadId
=
PlatformThread
:
:
CurrentId
(
)
;
}
void
PaintThread
:
:
InitPaintWorkers
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
int32_t
count
=
PaintThread
:
:
CalculatePaintWorkerCount
(
)
;
if
(
count
!
=
1
)
{
mPaintWorkers
=
SharedThreadPool
:
:
Get
(
NS_LITERAL_CSTRING
(
"
PaintWorker
"
)
count
)
;
}
}
void
DestroyPaintThread
(
UniquePtr
<
PaintThread
>
&
&
pt
)
{
MOZ_ASSERT
(
PaintThread
:
:
IsOnPaintThread
(
)
)
;
pt
-
>
ShutdownOnPaintThread
(
)
;
}
void
PaintThread
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
UniquePtr
<
PaintThread
>
pt
(
sSingleton
.
forget
(
)
)
;
if
(
!
pt
)
{
return
;
}
sThread
-
>
Dispatch
(
NewRunnableFunction
(
"
DestroyPaintThreadRunnable
"
DestroyPaintThread
std
:
:
move
(
pt
)
)
)
;
sThread
-
>
Shutdown
(
)
;
sThread
=
nullptr
;
}
void
PaintThread
:
:
ShutdownOnPaintThread
(
)
{
MOZ_ASSERT
(
IsOnPaintThread
(
)
)
;
}
PaintThread
*
PaintThread
:
:
Get
(
)
{
return
PaintThread
:
:
sSingleton
.
get
(
)
;
}
bool
PaintThread
:
:
IsOnPaintThread
(
)
{
return
sThreadId
=
=
PlatformThread
:
:
CurrentId
(
)
;
}
bool
PaintThread
:
:
IsOnPaintWorkerThread
(
)
{
return
(
mPaintWorkers
&
&
mPaintWorkers
-
>
IsOnCurrentThread
(
)
)
|
|
(
sThreadId
=
=
PlatformThread
:
:
CurrentId
(
)
)
;
}
void
PaintThread
:
:
Dispatch
(
RefPtr
<
Runnable
>
&
aRunnable
)
{
#
ifndef
OMTP_FORCE_SYNC
sThread
-
>
Dispatch
(
aRunnable
.
forget
(
)
)
;
#
else
SyncRunnable
:
:
DispatchToThread
(
sThread
aRunnable
)
;
#
endif
}
void
PaintThread
:
:
UpdateRenderMode
(
)
{
if
(
!
!
mPaintWorkers
!
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
UsesTiling
(
)
)
{
if
(
mPaintWorkers
)
{
mPaintWorkers
=
nullptr
;
}
else
{
InitPaintWorkers
(
)
;
}
}
}
void
PaintThread
:
:
QueuePaintTask
(
UniquePtr
<
PaintTask
>
&
&
aTask
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aTask
)
;
if
(
StaticPrefs
:
:
layers_omtp_dump_capture
(
)
&
&
aTask
-
>
mCapture
)
{
aTask
-
>
mCapture
-
>
Dump
(
)
;
}
MOZ_RELEASE_ASSERT
(
aTask
-
>
mCapture
-
>
hasOneRef
(
)
)
;
RefPtr
<
CompositorBridgeChild
>
cbc
(
CompositorBridgeChild
:
:
Get
(
)
)
;
cbc
-
>
NotifyBeginAsyncPaint
(
aTask
.
get
(
)
)
;
RefPtr
<
PaintThread
>
self
=
this
;
RefPtr
<
Runnable
>
task
=
NS_NewRunnableFunction
(
"
PaintThread
:
:
AsyncPaintTask
"
[
self
cbc
task
=
std
:
:
move
(
aTask
)
]
(
)
-
>
void
{
self
-
>
AsyncPaintTask
(
cbc
task
.
get
(
)
)
;
}
)
;
nsIEventTarget
*
paintThread
=
mPaintWorkers
?
static_cast
<
nsIEventTarget
*
>
(
mPaintWorkers
.
get
(
)
)
:
static_cast
<
nsIEventTarget
*
>
(
sThread
.
get
(
)
)
;
#
ifndef
OMTP_FORCE_SYNC
paintThread
-
>
Dispatch
(
task
.
forget
(
)
)
;
#
else
SyncRunnable
:
:
DispatchToThread
(
paintThread
task
)
;
#
endif
}
void
PaintThread
:
:
AsyncPaintTask
(
CompositorBridgeChild
*
aBridge
PaintTask
*
aTask
)
{
AUTO_PROFILER_LABEL
(
"
PaintThread
:
:
AsyncPaintTask
"
GRAPHICS
)
;
MOZ_ASSERT
(
IsOnPaintWorkerThread
(
)
)
;
MOZ_ASSERT
(
aTask
)
;
gfx
:
:
DrawTargetCapture
*
capture
=
aTask
-
>
mCapture
;
gfx
:
:
DrawTarget
*
target
=
aTask
-
>
mTarget
;
if
(
target
-
>
IsValid
(
)
)
{
target
-
>
DrawCapturedDT
(
capture
Matrix
(
)
)
;
target
-
>
Flush
(
)
;
}
if
(
StaticPrefs
:
:
layers_omtp_release_capture_on_main_thread
(
)
)
{
NS_ReleaseOnMainThreadSystemGroup
(
"
PaintTask
:
:
DrawTargetCapture
"
aTask
-
>
mCapture
.
forget
(
)
)
;
}
if
(
aBridge
-
>
NotifyFinishedAsyncWorkerPaint
(
aTask
)
)
{
AsyncEndLayerTransaction
(
aBridge
)
;
}
}
void
PaintThread
:
:
QueueEndLayerTransaction
(
SyncObjectClient
*
aSyncObject
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
CompositorBridgeChild
>
cbc
(
CompositorBridgeChild
:
:
Get
(
)
)
;
if
(
cbc
-
>
NotifyBeginAsyncEndLayerTransaction
(
aSyncObject
)
)
{
RefPtr
<
PaintThread
>
self
=
this
;
RefPtr
<
Runnable
>
task
=
NS_NewRunnableFunction
(
"
PaintThread
:
:
AsyncEndLayerTransaction
"
[
self
cbc
]
(
)
-
>
void
{
self
-
>
AsyncEndLayerTransaction
(
cbc
)
;
}
)
;
#
ifndef
OMTP_FORCE_SYNC
sThread
-
>
Dispatch
(
task
.
forget
(
)
)
;
#
else
SyncRunnable
:
:
DispatchToThread
(
sThread
task
)
;
#
endif
}
}
void
PaintThread
:
:
AsyncEndLayerTransaction
(
CompositorBridgeChild
*
aBridge
)
{
MOZ_ASSERT
(
IsOnPaintWorkerThread
(
)
)
;
aBridge
-
>
NotifyFinishedAsyncEndLayerTransaction
(
)
;
}
}
}
