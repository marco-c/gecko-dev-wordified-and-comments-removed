#
include
"
mozilla
/
layers
/
NativeLayerRemoteMac
.
h
"
#
include
<
algorithm
>
#
include
<
utility
>
#
include
"
gfxUtils
.
h
"
#
include
"
GLBlitHelper
.
h
"
#
ifdef
XP_MACOSX
#
include
"
GLContextCGL
.
h
"
#
else
#
include
"
GLContextEAGL
.
h
"
#
endif
#
include
"
GLContextProvider
.
h
"
#
include
"
MozFramebuffer
.
h
"
#
include
"
mozilla
/
gfx
/
Swizzle
.
h
"
#
include
"
mozilla
/
glean
/
GfxMetrics
.
h
"
#
include
"
mozilla
/
webrender
/
RenderMacIOSurfaceTextureHost
.
h
"
#
include
"
ScopedGLHelpers
.
h
"
namespace
mozilla
{
namespace
layers
{
using
gfx
:
:
DataSourceSurface
;
using
gfx
:
:
IntPoint
;
using
gfx
:
:
IntRect
;
using
gfx
:
:
IntRegion
;
using
gfx
:
:
IntSize
;
using
gfx
:
:
Matrix4x4
;
using
gfx
:
:
SurfaceFormat
;
using
gl
:
:
GLContext
;
NativeLayerRemoteMac
:
:
NativeLayerRemoteMac
(
const
IntSize
&
aSize
bool
aIsOpaque
SurfacePoolHandleCA
*
aSurfacePoolHandle
)
:
mIsOpaque
(
aIsOpaque
)
{
mSurfaceHandler
.
emplace
(
aSize
aSurfacePoolHandle
)
;
}
NativeLayerRemoteMac
:
:
NativeLayerRemoteMac
(
bool
aIsOpaque
)
:
mIsOpaque
(
aIsOpaque
)
{
}
NativeLayerRemoteMac
:
:
NativeLayerRemoteMac
(
gfx
:
:
DeviceColor
aColor
)
:
mColor
(
aColor
)
mIsOpaque
(
aColor
.
a
>
=
1
.
0f
)
{
}
NativeLayerRemoteMac
:
:
~
NativeLayerRemoteMac
(
)
{
if
(
mCommandQueue
)
{
mCommandQueue
-
>
AppendCommand
(
mozilla
:
:
layers
:
:
CommandLayerDestroyed
(
reinterpret_cast
<
uint64_t
>
(
this
)
)
)
;
}
}
void
NativeLayerRemoteMac
:
:
AttachExternalImage
(
wr
:
:
RenderTextureHost
*
aExternalImage
)
{
MOZ_ASSERT
(
XRE_IsGPUProcess
(
)
)
;
MOZ_ASSERT
(
!
mSurfaceHandler
)
;
wr
:
:
RenderMacIOSurfaceTextureHost
*
texture
=
aExternalImage
-
>
AsRenderMacIOSurfaceTextureHost
(
)
;
MOZ_ASSERT
(
texture
)
;
auto
externalImage
=
texture
-
>
GetSurface
(
)
-
>
GetIOSurfaceRef
(
)
;
bool
changedExternalImage
=
(
mExternalImage
!
=
externalImage
)
;
mExternalImage
=
externalImage
;
auto
texSize
=
texture
-
>
GetSize
(
0
)
;
bool
changedSize
=
(
mSize
!
=
texSize
)
;
mSize
=
texSize
;
auto
displayRect
=
IntRect
(
IntPoint
{
}
mSize
)
;
bool
changedDisplayRect
=
!
mDisplayRect
.
IsEqualInterior
(
displayRect
)
;
mDisplayRect
=
displayRect
;
bool
isDRM
=
aExternalImage
-
>
IsFromDRMSource
(
)
;
bool
changedIsDRM
=
(
mIsDRM
!
=
isDRM
)
;
mIsDRM
=
isDRM
;
bool
isHDR
=
false
;
MacIOSurface
*
macIOSurface
=
texture
-
>
GetSurface
(
)
;
if
(
macIOSurface
-
>
GetYUVColorSpace
(
)
=
=
gfx
:
:
YUVColorSpace
:
:
BT2020
)
{
isHDR
=
true
;
}
if
(
macIOSurface
-
>
GetColorDepth
(
)
=
=
gfx
:
:
ColorDepth
:
:
COLOR_10
)
{
isHDR
=
true
;
}
bool
changedIsHDR
=
(
mIsHDR
!
=
isHDR
)
;
mIsHDR
=
isHDR
;
mDirty
|
=
(
changedExternalImage
|
|
changedSize
|
|
changedDisplayRect
|
|
changedIsDRM
|
|
changedIsHDR
)
;
}
GpuFence
*
NativeLayerRemoteMac
:
:
GetGpuFence
(
)
{
return
nullptr
;
}
IntSize
NativeLayerRemoteMac
:
:
GetSize
(
)
{
if
(
mSurfaceHandler
)
{
return
mSurfaceHandler
-
>
Size
(
)
;
}
return
mSize
;
}
void
NativeLayerRemoteMac
:
:
SetPosition
(
const
IntPoint
&
aPosition
)
{
if
(
mPosition
!
=
aPosition
)
{
mDirty
=
true
;
mPosition
=
aPosition
;
}
}
IntPoint
NativeLayerRemoteMac
:
:
GetPosition
(
)
{
return
mPosition
;
}
void
NativeLayerRemoteMac
:
:
SetTransform
(
const
Matrix4x4
&
aTransform
)
{
MOZ_ASSERT
(
aTransform
.
IsRectilinear
(
)
)
;
if
(
mTransform
!
=
aTransform
)
{
mDirty
=
true
;
mTransform
=
aTransform
;
}
}
void
NativeLayerRemoteMac
:
:
SetSamplingFilter
(
gfx
:
:
SamplingFilter
aSamplingFilter
)
{
if
(
mSamplingFilter
!
=
aSamplingFilter
)
{
mDirty
=
true
;
mSamplingFilter
=
aSamplingFilter
;
}
}
gfx
:
:
SamplingFilter
NativeLayerRemoteMac
:
:
SamplingFilter
(
)
{
return
mSamplingFilter
;
}
Matrix4x4
NativeLayerRemoteMac
:
:
GetTransform
(
)
{
return
mTransform
;
}
IntRect
NativeLayerRemoteMac
:
:
GetRect
(
)
{
IntSize
size
=
mSize
;
if
(
mSurfaceHandler
)
{
size
=
mSurfaceHandler
-
>
Size
(
)
;
}
return
IntRect
(
mPosition
size
)
;
}
bool
NativeLayerRemoteMac
:
:
IsOpaque
(
)
{
return
mIsOpaque
;
}
void
NativeLayerRemoteMac
:
:
SetClipRect
(
const
Maybe
<
gfx
:
:
IntRect
>
&
aClipRect
)
{
if
(
mClipRect
!
=
aClipRect
)
{
mDirty
=
true
;
mClipRect
=
aClipRect
;
}
}
Maybe
<
gfx
:
:
IntRect
>
NativeLayerRemoteMac
:
:
ClipRect
(
)
{
return
mClipRect
;
}
void
NativeLayerRemoteMac
:
:
SetRoundedClipRect
(
const
Maybe
<
gfx
:
:
RoundedRect
>
&
aRoundedClipRect
)
{
if
(
mRoundedClipRect
!
=
aRoundedClipRect
)
{
mDirty
=
true
;
mRoundedClipRect
=
aRoundedClipRect
;
}
}
Maybe
<
gfx
:
:
RoundedRect
>
NativeLayerRemoteMac
:
:
RoundedClipRect
(
)
{
return
mRoundedClipRect
;
}
gfx
:
:
IntRect
NativeLayerRemoteMac
:
:
CurrentSurfaceDisplayRect
(
)
{
if
(
mSurfaceHandler
)
{
return
mSurfaceHandler
-
>
DisplayRect
(
)
;
}
return
mDisplayRect
;
}
void
NativeLayerRemoteMac
:
:
SetSurfaceIsFlipped
(
bool
aIsFlipped
)
{
if
(
SurfaceIsFlipped
(
)
!
=
aIsFlipped
)
{
mDirty
=
true
;
if
(
mSurfaceHandler
)
{
mSurfaceHandler
-
>
SetSurfaceIsFlipped
(
aIsFlipped
)
;
}
else
{
mSurfaceIsFlipped
=
aIsFlipped
;
}
}
}
bool
NativeLayerRemoteMac
:
:
SurfaceIsFlipped
(
)
{
if
(
mSurfaceHandler
)
{
return
mSurfaceHandler
-
>
SurfaceIsFlipped
(
)
;
}
return
mSurfaceIsFlipped
;
}
RefPtr
<
gfx
:
:
DrawTarget
>
NativeLayerRemoteMac
:
:
NextSurfaceAsDrawTarget
(
const
IntRect
&
aDisplayRect
const
IntRegion
&
aUpdateRegion
gfx
:
:
BackendType
aBackendType
)
{
MOZ_ASSERT
(
mSurfaceHandler
)
;
return
mSurfaceHandler
-
>
NextSurfaceAsDrawTarget
(
aDisplayRect
aUpdateRegion
aBackendType
)
;
}
Maybe
<
GLuint
>
NativeLayerRemoteMac
:
:
NextSurfaceAsFramebuffer
(
const
IntRect
&
aDisplayRect
const
IntRegion
&
aUpdateRegion
bool
aNeedsDepth
)
{
MOZ_ASSERT
(
mSurfaceHandler
)
;
return
mSurfaceHandler
-
>
NextSurfaceAsFramebuffer
(
aDisplayRect
aUpdateRegion
aNeedsDepth
)
;
}
Maybe
<
SurfaceWithInvalidRegion
>
NativeLayerRemoteMac
:
:
FrontSurface
(
)
{
if
(
mSurfaceHandler
)
{
return
mSurfaceHandler
-
>
FrontSurface
(
)
;
}
if
(
mExternalImage
)
{
return
Some
(
SurfaceWithInvalidRegion
{
mExternalImage
GetRect
(
)
}
)
;
}
return
Nothing
(
)
;
}
void
NativeLayerRemoteMac
:
:
NotifySurfaceReady
(
)
{
mDirty
=
true
;
MOZ_ASSERT
(
mSurfaceHandler
)
;
mSurfaceHandler
-
>
NotifySurfaceReady
(
)
;
}
void
NativeLayerRemoteMac
:
:
DiscardBackbuffers
(
)
{
MOZ_ASSERT
(
mSurfaceHandler
)
;
mSurfaceHandler
-
>
DiscardBackbuffers
(
)
;
}
void
NativeLayerRemoteMac
:
:
FlushDirtyLayerInfoToCommandQueue
(
)
{
if
(
!
mDirty
)
{
return
;
}
auto
ID
=
reinterpret_cast
<
uint64_t
>
(
this
)
;
uint32_t
surfaceID
=
0
;
auto
surfaceWithInvalidRegion
=
FrontSurface
(
)
;
if
(
surfaceWithInvalidRegion
)
{
auto
surfaceRef
=
surfaceWithInvalidRegion
-
>
mSurface
.
get
(
)
;
surfaceID
=
IOSurfaceGetID
(
surfaceRef
)
;
}
mCommandQueue
-
>
AppendCommand
(
mozilla
:
:
layers
:
:
CommandLayerInfo
(
ID
surfaceID
IsDRM
(
)
IsHDR
(
)
GetPosition
(
)
GetSize
(
)
CurrentSurfaceDisplayRect
(
)
ClipRect
(
)
RoundedClipRect
(
)
GetTransform
(
)
static_cast
<
int8_t
>
(
SamplingFilter
(
)
)
SurfaceIsFlipped
(
)
)
)
;
mDirty
=
false
;
}
}
}
