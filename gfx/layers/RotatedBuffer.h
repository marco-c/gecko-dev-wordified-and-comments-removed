#
ifndef
ROTATEDBUFFER_H_
#
define
ROTATEDBUFFER_H_
#
include
"
gfxTypes
.
h
"
#
include
<
stdint
.
h
>
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
MatrixFwd
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRegion
.
h
"
namespace
mozilla
{
namespace
layers
{
class
PaintedLayer
;
class
ContentClient
;
class
BorrowDrawTarget
{
public
:
void
ReturnDrawTarget
(
gfx
:
:
DrawTarget
*
&
aReturned
)
;
protected
:
RefPtr
<
gfx
:
:
DrawTarget
>
mLoanedDrawTarget
;
gfx
:
:
Matrix
mLoanedTransform
;
}
;
class
RotatedBuffer
:
public
BorrowDrawTarget
{
public
:
typedef
gfxContentType
ContentType
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
RotatedBuffer
)
RotatedBuffer
(
const
gfx
:
:
IntRect
&
aBufferRect
const
gfx
:
:
IntPoint
&
aBufferRotation
)
:
mCapture
(
nullptr
)
mBufferRect
(
aBufferRect
)
mBufferRotation
(
aBufferRotation
)
mDidSelfCopy
(
false
)
{
}
RotatedBuffer
(
)
:
mCapture
(
nullptr
)
mDidSelfCopy
(
false
)
{
}
void
BeginCapture
(
)
;
RefPtr
<
gfx
:
:
DrawTargetCapture
>
EndCapture
(
)
;
bool
IsCapturing
(
)
const
{
return
!
!
mCapture
;
}
void
DrawBufferWithRotation
(
gfx
:
:
DrawTarget
*
aTarget
float
aOpacity
=
1
.
0
gfx
:
:
CompositionOp
aOperator
=
gfx
:
:
CompositionOp
:
:
OP_OVER
gfx
:
:
SourceSurface
*
aMask
=
nullptr
const
gfx
:
:
Matrix
*
aMaskTransform
=
nullptr
)
const
;
void
DrawTo
(
PaintedLayer
*
aLayer
gfx
:
:
DrawTarget
*
aTarget
float
aOpacity
gfx
:
:
CompositionOp
aOp
gfx
:
:
SourceSurface
*
aMask
const
gfx
:
:
Matrix
*
aMaskTransform
)
;
void
UpdateDestinationFrom
(
const
RotatedBuffer
&
aSource
const
gfx
:
:
IntRect
&
aUpdateRect
)
;
struct
DrawIterator
{
friend
class
RotatedBuffer
;
DrawIterator
(
)
:
mCount
(
0
)
{
}
nsIntRegion
mDrawRegion
;
private
:
uint32_t
mCount
;
}
;
gfx
:
:
DrawTarget
*
BorrowDrawTargetForQuadrantUpdate
(
const
gfx
:
:
IntRect
&
aBounds
DrawIterator
*
aIter
)
;
struct
Parameters
{
Parameters
(
const
gfx
:
:
IntRect
&
aBufferRect
const
gfx
:
:
IntPoint
&
aBufferRotation
)
:
mBufferRect
(
aBufferRect
)
mBufferRotation
(
aBufferRotation
)
mDidSelfCopy
(
false
)
{
}
bool
IsRotated
(
)
const
;
bool
RectWrapsBuffer
(
const
gfx
:
:
IntRect
&
aRect
)
const
;
void
SetUnrotated
(
)
;
gfx
:
:
IntRect
mBufferRect
;
gfx
:
:
IntPoint
mBufferRotation
;
bool
mDidSelfCopy
;
}
;
Parameters
AdjustedParameters
(
const
gfx
:
:
IntRect
&
aDestBufferRect
)
const
;
bool
UnrotateBufferTo
(
const
Parameters
&
aParameters
)
;
void
SetParameters
(
const
Parameters
&
aParameters
)
;
const
gfx
:
:
IntRect
&
BufferRect
(
)
const
{
return
mBufferRect
;
}
const
gfx
:
:
IntPoint
&
BufferRotation
(
)
const
{
return
mBufferRotation
;
}
void
SetBufferRect
(
const
gfx
:
:
IntRect
&
aBufferRect
)
{
mBufferRect
=
aBufferRect
;
}
void
SetBufferRotation
(
const
gfx
:
:
IntPoint
&
aBufferRotation
)
{
mBufferRotation
=
aBufferRotation
;
}
bool
DidSelfCopy
(
)
const
{
return
mDidSelfCopy
;
}
void
ClearDidSelfCopy
(
)
{
mDidSelfCopy
=
false
;
}
ContentType
GetContentType
(
)
const
;
virtual
bool
IsLocked
(
)
=
0
;
virtual
bool
Lock
(
OpenMode
aMode
)
=
0
;
virtual
void
Unlock
(
)
=
0
;
virtual
bool
HaveBuffer
(
)
const
=
0
;
virtual
bool
HaveBufferOnWhite
(
)
const
=
0
;
virtual
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
=
0
;
virtual
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetBufferSource
(
)
const
{
return
GetBufferTarget
(
)
-
>
Snapshot
(
)
;
}
virtual
gfx
:
:
DrawTarget
*
GetBufferTarget
(
)
const
=
0
;
virtual
TextureClient
*
GetClient
(
)
const
{
return
nullptr
;
}
virtual
TextureClient
*
GetClientOnWhite
(
)
const
{
return
nullptr
;
}
protected
:
virtual
~
RotatedBuffer
(
)
{
MOZ_ASSERT
(
!
mCapture
)
;
}
enum
XSide
{
LEFT
RIGHT
}
;
enum
YSide
{
TOP
BOTTOM
}
;
gfx
:
:
IntRect
GetQuadrantRectangle
(
XSide
aXSide
YSide
aYSide
)
const
;
gfx
:
:
Rect
GetSourceRectangle
(
XSide
aXSide
YSide
aYSide
)
const
;
gfx
:
:
DrawTarget
*
GetDrawTarget
(
)
const
{
if
(
mCapture
)
{
return
mCapture
;
}
return
GetBufferTarget
(
)
;
}
void
DrawBufferQuadrant
(
gfx
:
:
DrawTarget
*
aTarget
XSide
aXSide
YSide
aYSide
float
aOpacity
gfx
:
:
CompositionOp
aOperator
gfx
:
:
SourceSurface
*
aMask
const
gfx
:
:
Matrix
*
aMaskTransform
)
const
;
RefPtr
<
gfx
:
:
DrawTargetCapture
>
mCapture
;
gfx
:
:
IntRect
mBufferRect
;
gfx
:
:
IntPoint
mBufferRotation
;
bool
mDidSelfCopy
;
}
;
class
RemoteRotatedBuffer
:
public
RotatedBuffer
{
public
:
RemoteRotatedBuffer
(
TextureClient
*
aClient
TextureClient
*
aClientOnWhite
const
gfx
:
:
IntRect
&
aBufferRect
const
gfx
:
:
IntPoint
&
aBufferRotation
)
:
RotatedBuffer
(
aBufferRect
aBufferRotation
)
mClient
(
aClient
)
mClientOnWhite
(
aClientOnWhite
)
{
}
virtual
bool
IsLocked
(
)
override
;
virtual
bool
Lock
(
OpenMode
aMode
)
override
;
virtual
void
Unlock
(
)
override
;
virtual
bool
HaveBuffer
(
)
const
override
{
return
!
!
mClient
;
}
virtual
bool
HaveBufferOnWhite
(
)
const
override
{
return
!
!
mClientOnWhite
;
}
virtual
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
override
;
virtual
gfx
:
:
DrawTarget
*
GetBufferTarget
(
)
const
override
;
virtual
TextureClient
*
GetClient
(
)
const
override
{
return
mClient
;
}
virtual
TextureClient
*
GetClientOnWhite
(
)
const
override
{
return
mClientOnWhite
;
}
void
SyncWithObject
(
RefPtr
<
SyncObjectClient
>
aSyncObject
)
;
void
Clear
(
)
;
private
:
RemoteRotatedBuffer
(
TextureClient
*
aClient
TextureClient
*
aClientOnWhite
gfx
:
:
DrawTarget
*
aTarget
gfx
:
:
DrawTarget
*
aTargetOnWhite
gfx
:
:
DrawTarget
*
aTargetDual
const
gfx
:
:
IntRect
&
aBufferRect
const
gfx
:
:
IntPoint
&
aBufferRotation
)
:
RotatedBuffer
(
aBufferRect
aBufferRotation
)
mClient
(
aClient
)
mClientOnWhite
(
aClientOnWhite
)
mTarget
(
aTarget
)
mTargetOnWhite
(
aTargetOnWhite
)
mTargetDual
(
aTargetDual
)
{
}
RefPtr
<
TextureClient
>
mClient
;
RefPtr
<
TextureClient
>
mClientOnWhite
;
RefPtr
<
gfx
:
:
DrawTarget
>
mTarget
;
RefPtr
<
gfx
:
:
DrawTarget
>
mTargetOnWhite
;
RefPtr
<
gfx
:
:
DrawTarget
>
mTargetDual
;
}
;
class
DrawTargetRotatedBuffer
:
public
RotatedBuffer
{
public
:
DrawTargetRotatedBuffer
(
gfx
:
:
DrawTarget
*
aTarget
gfx
:
:
DrawTarget
*
aTargetOnWhite
const
gfx
:
:
IntRect
&
aBufferRect
const
gfx
:
:
IntPoint
&
aBufferRotation
)
:
RotatedBuffer
(
aBufferRect
aBufferRotation
)
mTarget
(
aTarget
)
mTargetOnWhite
(
aTargetOnWhite
)
{
if
(
mTargetOnWhite
)
{
mTargetDual
=
gfx
:
:
Factory
:
:
CreateDualDrawTarget
(
mTarget
mTargetOnWhite
)
;
}
else
{
mTargetDual
=
mTarget
;
}
}
virtual
bool
IsLocked
(
)
override
{
return
false
;
}
virtual
bool
Lock
(
OpenMode
aMode
)
override
{
return
true
;
}
virtual
void
Unlock
(
)
override
{
}
virtual
bool
HaveBuffer
(
)
const
override
{
return
!
!
mTargetDual
;
}
virtual
bool
HaveBufferOnWhite
(
)
const
override
{
return
!
!
mTargetOnWhite
;
}
virtual
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
override
;
virtual
gfx
:
:
DrawTarget
*
GetBufferTarget
(
)
const
override
;
private
:
RefPtr
<
gfx
:
:
DrawTarget
>
mTarget
;
RefPtr
<
gfx
:
:
DrawTarget
>
mTargetOnWhite
;
RefPtr
<
gfx
:
:
DrawTarget
>
mTargetDual
;
}
;
class
SourceRotatedBuffer
:
public
RotatedBuffer
{
public
:
SourceRotatedBuffer
(
gfx
:
:
SourceSurface
*
aSource
gfx
:
:
SourceSurface
*
aSourceOnWhite
const
gfx
:
:
IntRect
&
aBufferRect
const
gfx
:
:
IntPoint
&
aBufferRotation
)
:
RotatedBuffer
(
aBufferRect
aBufferRotation
)
mSource
(
aSource
)
mSourceOnWhite
(
aSourceOnWhite
)
{
mSourceDual
=
gfx
:
:
Factory
:
:
CreateDualSourceSurface
(
mSource
mSourceOnWhite
)
;
}
virtual
bool
IsLocked
(
)
override
{
return
false
;
}
virtual
bool
Lock
(
OpenMode
aMode
)
override
{
return
false
;
}
virtual
void
Unlock
(
)
override
{
}
virtual
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetBufferSource
(
)
const
override
;
virtual
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
override
;
virtual
bool
HaveBuffer
(
)
const
override
{
return
!
!
mSourceDual
;
}
virtual
bool
HaveBufferOnWhite
(
)
const
override
{
return
!
!
mSourceOnWhite
;
}
virtual
gfx
:
:
DrawTarget
*
GetBufferTarget
(
)
const
override
{
return
nullptr
;
}
private
:
RefPtr
<
gfx
:
:
SourceSurface
>
mSource
;
RefPtr
<
gfx
:
:
SourceSurface
>
mSourceOnWhite
;
RefPtr
<
gfx
:
:
SourceSurface
>
mSourceDual
;
}
;
}
}
#
endif
