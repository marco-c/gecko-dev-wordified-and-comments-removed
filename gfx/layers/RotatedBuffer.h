#
ifndef
ROTATEDBUFFER_H_
#
define
ROTATEDBUFFER_H_
#
include
"
gfxTypes
.
h
"
#
include
<
stdint
.
h
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
MatrixFwd
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
LayersTypes
.
h
"
namespace
mozilla
{
namespace
layers
{
class
CapturedPaintState
;
typedef
bool
(
*
PrepDrawTargetForPaintingCallback
)
(
CapturedPaintState
*
)
;
class
PaintedLayer
;
class
BorrowDrawTarget
{
protected
:
void
ReturnDrawTarget
(
gfx
:
:
DrawTarget
*
&
aReturned
)
;
RefPtr
<
gfx
:
:
DrawTarget
>
mLoanedDrawTarget
;
gfx
:
:
Matrix
mLoanedTransform
;
bool
mSetTransform
;
}
;
class
RotatedBuffer
:
public
BorrowDrawTarget
{
public
:
typedef
gfxContentType
ContentType
;
RotatedBuffer
(
const
gfx
:
:
IntRect
&
aBufferRect
const
gfx
:
:
IntPoint
&
aBufferRotation
)
:
mBufferRect
(
aBufferRect
)
mBufferRotation
(
aBufferRotation
)
mDidSelfCopy
(
false
)
{
}
RotatedBuffer
(
)
:
mDidSelfCopy
(
false
)
{
}
struct
DrawIterator
{
friend
class
RotatedBuffer
;
DrawIterator
(
)
:
mCount
(
0
)
{
}
nsIntRegion
mDrawRegion
;
private
:
uint32_t
mCount
;
}
;
enum
ContextSource
{
BUFFER_BLACK
BUFFER_WHITE
BUFFER_BOTH
}
;
void
DrawBufferWithRotation
(
gfx
:
:
DrawTarget
*
aTarget
ContextSource
aSource
float
aOpacity
=
1
.
0
gfx
:
:
CompositionOp
aOperator
=
gfx
:
:
CompositionOp
:
:
OP_OVER
gfx
:
:
SourceSurface
*
aMask
=
nullptr
const
gfx
:
:
Matrix
*
aMaskTransform
=
nullptr
)
const
;
void
DrawTo
(
PaintedLayer
*
aLayer
gfx
:
:
DrawTarget
*
aTarget
float
aOpacity
gfx
:
:
CompositionOp
aOp
gfx
:
:
SourceSurface
*
aMask
const
gfx
:
:
Matrix
*
aMaskTransform
)
;
void
UpdateDestinationFrom
(
const
RotatedBuffer
&
aSource
const
nsIntRegion
&
aUpdateRegion
)
;
const
gfx
:
:
IntRect
&
BufferRect
(
)
const
{
return
mBufferRect
;
}
const
gfx
:
:
IntPoint
&
BufferRotation
(
)
const
{
return
mBufferRotation
;
}
virtual
bool
HaveBuffer
(
)
const
=
0
;
virtual
bool
HaveBufferOnWhite
(
)
const
=
0
;
virtual
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetSourceSurface
(
ContextSource
aSource
)
const
=
0
;
protected
:
virtual
gfx
:
:
DrawTarget
*
GetDTBuffer
(
)
const
=
0
;
virtual
gfx
:
:
DrawTarget
*
GetDTBufferOnWhite
(
)
const
=
0
;
enum
XSide
{
LEFT
RIGHT
}
;
enum
YSide
{
TOP
BOTTOM
}
;
gfx
:
:
IntRect
GetQuadrantRectangle
(
XSide
aXSide
YSide
aYSide
)
const
;
gfx
:
:
Rect
GetSourceRectangle
(
XSide
aXSide
YSide
aYSide
)
const
;
void
DrawBufferQuadrant
(
gfx
:
:
DrawTarget
*
aTarget
XSide
aXSide
YSide
aYSide
ContextSource
aSource
float
aOpacity
gfx
:
:
CompositionOp
aOperator
gfx
:
:
SourceSurface
*
aMask
const
gfx
:
:
Matrix
*
aMaskTransform
)
const
;
gfx
:
:
DrawTarget
*
BorrowDrawTargetForQuadrantUpdate
(
const
gfx
:
:
IntRect
&
aBounds
ContextSource
aSource
DrawIterator
*
aIter
bool
aSetTransform
=
true
gfx
:
:
Matrix
*
aOutTransform
=
nullptr
)
;
gfx
:
:
IntRect
mBufferRect
;
gfx
:
:
IntPoint
mBufferRotation
;
bool
mDidSelfCopy
;
}
;
class
RemoteRotatedBuffer
:
public
RotatedBuffer
{
public
:
RemoteRotatedBuffer
(
TextureClient
*
aClient
TextureClient
*
aClientOnWhite
const
gfx
:
:
IntRect
&
aBufferRect
const
gfx
:
:
IntPoint
&
aBufferRotation
)
:
RotatedBuffer
(
aBufferRect
aBufferRotation
)
mClient
(
aClient
)
mClientOnWhite
(
aClientOnWhite
)
{
}
bool
Lock
(
OpenMode
aMode
)
;
void
Unlock
(
)
;
void
Clear
(
)
;
TextureClient
*
GetClient
(
)
const
{
return
mClient
;
}
TextureClient
*
GetClientOnWhite
(
)
const
{
return
mClientOnWhite
;
}
virtual
bool
HaveBuffer
(
)
const
override
{
return
!
!
mClient
;
}
virtual
bool
HaveBufferOnWhite
(
)
const
override
{
return
!
!
mClientOnWhite
;
}
virtual
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetSourceSurface
(
ContextSource
aSource
)
const
override
;
protected
:
virtual
gfx
:
:
DrawTarget
*
GetDTBuffer
(
)
const
override
;
virtual
gfx
:
:
DrawTarget
*
GetDTBufferOnWhite
(
)
const
override
;
private
:
RefPtr
<
TextureClient
>
mClient
;
RefPtr
<
TextureClient
>
mClientOnWhite
;
RefPtr
<
gfx
:
:
DrawTarget
>
mTarget
;
RefPtr
<
gfx
:
:
DrawTarget
>
mTargetOnWhite
;
}
;
class
DrawTargetRotatedBuffer
:
public
RotatedBuffer
{
public
:
DrawTargetRotatedBuffer
(
gfx
:
:
DrawTarget
*
aTarget
gfx
:
:
DrawTarget
*
aTargetOnWhite
const
gfx
:
:
IntRect
&
aBufferRect
const
gfx
:
:
IntPoint
&
aBufferRotation
)
:
RotatedBuffer
(
aBufferRect
aBufferRotation
)
mTarget
(
aTarget
)
mTargetOnWhite
(
aTargetOnWhite
)
{
}
virtual
bool
HaveBuffer
(
)
const
override
{
return
!
!
mTarget
;
}
virtual
bool
HaveBufferOnWhite
(
)
const
override
{
return
!
!
mTargetOnWhite
;
}
virtual
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetSourceSurface
(
ContextSource
aSource
)
const
override
;
protected
:
virtual
gfx
:
:
DrawTarget
*
GetDTBuffer
(
)
const
override
;
virtual
gfx
:
:
DrawTarget
*
GetDTBufferOnWhite
(
)
const
override
;
private
:
RefPtr
<
gfx
:
:
DrawTarget
>
mTarget
;
RefPtr
<
gfx
:
:
DrawTarget
>
mTargetOnWhite
;
}
;
class
SourceRotatedBuffer
:
public
RotatedBuffer
{
public
:
SourceRotatedBuffer
(
gfx
:
:
SourceSurface
*
aSource
gfx
:
:
SourceSurface
*
aSourceOnWhite
const
gfx
:
:
IntRect
&
aBufferRect
const
gfx
:
:
IntPoint
&
aBufferRotation
)
:
RotatedBuffer
(
aBufferRect
aBufferRotation
)
mSource
(
aSource
)
mSourceOnWhite
(
aSourceOnWhite
)
{
}
virtual
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetSourceSurface
(
ContextSource
aSource
)
const
;
virtual
bool
HaveBuffer
(
)
const
{
return
!
!
mSource
;
}
virtual
bool
HaveBufferOnWhite
(
)
const
{
return
!
!
mSourceOnWhite
;
}
protected
:
virtual
gfx
:
:
DrawTarget
*
GetDTBuffer
(
)
const
{
return
nullptr
;
}
virtual
gfx
:
:
DrawTarget
*
GetDTBufferOnWhite
(
)
const
{
return
nullptr
;
}
private
:
RefPtr
<
gfx
:
:
SourceSurface
>
mSource
;
RefPtr
<
gfx
:
:
SourceSurface
>
mSourceOnWhite
;
}
;
class
RotatedContentBuffer
:
public
RotatedBuffer
{
public
:
typedef
gfxContentType
ContentType
;
enum
BufferSizePolicy
{
SizedToVisibleBounds
ContainsVisibleBounds
}
;
explicit
RotatedContentBuffer
(
BufferSizePolicy
aBufferSizePolicy
)
:
mBufferProvider
(
nullptr
)
mBufferProviderOnWhite
(
nullptr
)
mBufferSizePolicy
(
aBufferSizePolicy
)
{
MOZ_COUNT_CTOR
(
RotatedContentBuffer
)
;
}
virtual
~
RotatedContentBuffer
(
)
{
MOZ_COUNT_DTOR
(
RotatedContentBuffer
)
;
}
void
Clear
(
)
{
UnlockBuffers
(
)
;
mDTBuffer
=
nullptr
;
mDTBufferOnWhite
=
nullptr
;
mBufferProvider
=
nullptr
;
mBufferProviderOnWhite
=
nullptr
;
mBufferRect
.
SetEmpty
(
)
;
}
struct
PaintState
{
PaintState
(
)
:
mRegionToDraw
(
)
mRegionToInvalidate
(
)
mMode
(
SurfaceMode
:
:
SURFACE_NONE
)
mClip
(
DrawRegionClip
:
:
NONE
)
mContentType
(
gfxContentType
:
:
SENTINEL
)
mDidSelfCopy
(
false
)
{
}
nsIntRegion
mRegionToDraw
;
nsIntRegion
mRegionToInvalidate
;
SurfaceMode
mMode
;
DrawRegionClip
mClip
;
ContentType
mContentType
;
bool
mDidSelfCopy
;
}
;
enum
{
PAINT_WILL_RESAMPLE
=
0x01
PAINT_NO_ROTATION
=
0x02
PAINT_CAN_DRAW_ROTATED
=
0x04
}
;
PaintState
BeginPaint
(
PaintedLayer
*
aLayer
uint32_t
aFlags
)
;
gfx
:
:
DrawTarget
*
BorrowDrawTargetForPainting
(
PaintState
&
aPaintState
DrawIterator
*
aIter
=
nullptr
)
;
RefPtr
<
CapturedPaintState
>
BorrowDrawTargetForRecording
(
PaintState
&
aPaintState
DrawIterator
*
aIter
bool
aSetTransform
=
false
)
;
nsIntRegion
ExpandDrawRegion
(
PaintState
&
aPaintState
DrawIterator
*
aIter
gfx
:
:
BackendType
aBackendType
)
;
static
bool
PrepareDrawTargetForPainting
(
CapturedPaintState
*
)
;
enum
{
BUFFER_COMPONENT_ALPHA
=
0x02
}
;
virtual
void
CreateBuffer
(
ContentType
aType
const
gfx
:
:
IntRect
&
aRect
uint32_t
aFlags
RefPtr
<
gfx
:
:
DrawTarget
>
*
aBlackDT
RefPtr
<
gfx
:
:
DrawTarget
>
*
aWhiteDT
)
=
0
;
virtual
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetSourceSurface
(
ContextSource
aSource
)
const
;
protected
:
void
SetBufferProvider
(
TextureClient
*
aClient
)
{
MOZ_ASSERT
(
!
aClient
|
|
!
mDTBuffer
|
|
!
mDTBuffer
-
>
IsValid
(
)
)
;
mBufferProvider
=
aClient
;
if
(
!
mBufferProvider
)
{
mDTBuffer
=
nullptr
;
}
}
void
SetBufferProviderOnWhite
(
TextureClient
*
aClient
)
{
MOZ_ASSERT
(
!
aClient
|
|
!
mDTBufferOnWhite
|
|
!
mDTBufferOnWhite
-
>
IsValid
(
)
)
;
mBufferProviderOnWhite
=
aClient
;
if
(
!
mBufferProviderOnWhite
)
{
mDTBufferOnWhite
=
nullptr
;
}
}
protected
:
gfxContentType
BufferContentType
(
)
;
bool
BufferSizeOkFor
(
const
gfx
:
:
IntSize
&
aSize
)
;
bool
EnsureBuffer
(
)
;
bool
EnsureBufferOnWhite
(
)
;
void
FlushBuffers
(
)
;
virtual
gfx
:
:
DrawTarget
*
GetDTBuffer
(
)
const
{
return
mDTBuffer
;
}
virtual
gfx
:
:
DrawTarget
*
GetDTBufferOnWhite
(
)
const
{
return
mDTBufferOnWhite
;
}
virtual
bool
HaveBuffer
(
)
const
;
virtual
bool
HaveBufferOnWhite
(
)
const
;
virtual
void
FinalizeFrame
(
const
nsIntRegion
&
aRegionToDraw
)
{
}
virtual
bool
LockBuffers
(
)
{
return
true
;
}
virtual
void
UnlockBuffers
(
)
{
}
RefPtr
<
gfx
:
:
DrawTarget
>
mDTBuffer
;
RefPtr
<
gfx
:
:
DrawTarget
>
mDTBufferOnWhite
;
TextureClient
*
mBufferProvider
;
TextureClient
*
mBufferProviderOnWhite
;
BufferSizePolicy
mBufferSizePolicy
;
}
;
}
}
#
endif
