#
ifndef
ROTATEDBUFFER_H_
#
define
ROTATEDBUFFER_H_
#
include
"
gfxTypes
.
h
"
#
include
<
stdint
.
h
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
MatrixFwd
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
LayersTypes
.
h
"
namespace
mozilla
{
namespace
layers
{
class
CapturedPaintState
;
typedef
bool
(
*
PrepDrawTargetForPaintingCallback
)
(
CapturedPaintState
*
)
;
class
PaintedLayer
;
class
BorrowDrawTarget
{
public
:
void
ReturnDrawTarget
(
gfx
:
:
DrawTarget
*
&
aReturned
)
;
protected
:
RefPtr
<
gfx
:
:
DrawTarget
>
mLoanedDrawTarget
;
gfx
:
:
Matrix
mLoanedTransform
;
bool
mSetTransform
;
}
;
class
RotatedBuffer
:
public
BorrowDrawTarget
{
public
:
typedef
gfxContentType
ContentType
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
RotatedBuffer
)
RotatedBuffer
(
const
gfx
:
:
IntRect
&
aBufferRect
const
gfx
:
:
IntPoint
&
aBufferRotation
)
:
mBufferRect
(
aBufferRect
)
mBufferRotation
(
aBufferRotation
)
mDidSelfCopy
(
false
)
{
}
RotatedBuffer
(
)
:
mDidSelfCopy
(
false
)
{
}
struct
DrawIterator
{
friend
class
RotatedBuffer
;
DrawIterator
(
)
:
mCount
(
0
)
{
}
nsIntRegion
mDrawRegion
;
private
:
uint32_t
mCount
;
}
;
enum
ContextSource
{
BUFFER_BLACK
BUFFER_WHITE
BUFFER_BOTH
}
;
void
DrawBufferWithRotation
(
gfx
:
:
DrawTarget
*
aTarget
ContextSource
aSource
float
aOpacity
=
1
.
0
gfx
:
:
CompositionOp
aOperator
=
gfx
:
:
CompositionOp
:
:
OP_OVER
gfx
:
:
SourceSurface
*
aMask
=
nullptr
const
gfx
:
:
Matrix
*
aMaskTransform
=
nullptr
)
const
;
void
DrawTo
(
PaintedLayer
*
aLayer
gfx
:
:
DrawTarget
*
aTarget
float
aOpacity
gfx
:
:
CompositionOp
aOp
gfx
:
:
SourceSurface
*
aMask
const
gfx
:
:
Matrix
*
aMaskTransform
)
;
void
UpdateDestinationFrom
(
const
RotatedBuffer
&
aSource
const
nsIntRegion
&
aUpdateRegion
)
;
bool
AdjustTo
(
const
gfx
:
:
IntRect
&
aDestBufferRect
const
gfx
:
:
IntRect
&
aDrawBounds
bool
aCanHaveRotation
bool
aCanDrawRotated
)
;
const
gfx
:
:
IntRect
&
BufferRect
(
)
const
{
return
mBufferRect
;
}
const
gfx
:
:
IntPoint
&
BufferRotation
(
)
const
{
return
mBufferRotation
;
}
void
SetBufferRect
(
const
gfx
:
:
IntRect
&
aBufferRect
)
{
mBufferRect
=
aBufferRect
;
}
void
SetBufferRotation
(
const
gfx
:
:
IntPoint
&
aBufferRotation
)
{
mBufferRotation
=
aBufferRotation
;
}
bool
DidSelfCopy
(
)
const
{
return
mDidSelfCopy
;
}
void
ClearDidSelfCopy
(
)
{
mDidSelfCopy
=
false
;
}
virtual
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
=
0
;
virtual
bool
HaveBuffer
(
)
const
=
0
;
virtual
bool
HaveBufferOnWhite
(
)
const
=
0
;
virtual
bool
IsLocked
(
)
=
0
;
virtual
bool
Lock
(
OpenMode
aMode
)
=
0
;
virtual
void
Unlock
(
)
=
0
;
virtual
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetSourceSurface
(
ContextSource
aSource
)
const
=
0
;
gfx
:
:
DrawTarget
*
BorrowDrawTargetForQuadrantUpdate
(
const
gfx
:
:
IntRect
&
aBounds
ContextSource
aSource
DrawIterator
*
aIter
bool
aSetTransform
=
true
gfx
:
:
Matrix
*
aOutTransform
=
nullptr
)
;
virtual
gfx
:
:
DrawTarget
*
GetDTBuffer
(
)
const
=
0
;
virtual
gfx
:
:
DrawTarget
*
GetDTBufferOnWhite
(
)
const
=
0
;
protected
:
virtual
~
RotatedBuffer
(
)
{
}
enum
XSide
{
LEFT
RIGHT
}
;
enum
YSide
{
TOP
BOTTOM
}
;
gfx
:
:
IntRect
GetQuadrantRectangle
(
XSide
aXSide
YSide
aYSide
)
const
;
gfx
:
:
Rect
GetSourceRectangle
(
XSide
aXSide
YSide
aYSide
)
const
;
void
DrawBufferQuadrant
(
gfx
:
:
DrawTarget
*
aTarget
XSide
aXSide
YSide
aYSide
ContextSource
aSource
float
aOpacity
gfx
:
:
CompositionOp
aOperator
gfx
:
:
SourceSurface
*
aMask
const
gfx
:
:
Matrix
*
aMaskTransform
)
const
;
gfx
:
:
IntRect
mBufferRect
;
gfx
:
:
IntPoint
mBufferRotation
;
bool
mDidSelfCopy
;
}
;
class
RemoteRotatedBuffer
:
public
RotatedBuffer
{
public
:
RemoteRotatedBuffer
(
TextureClient
*
aClient
TextureClient
*
aClientOnWhite
const
gfx
:
:
IntRect
&
aBufferRect
const
gfx
:
:
IntPoint
&
aBufferRotation
)
:
RotatedBuffer
(
aBufferRect
aBufferRotation
)
mClient
(
aClient
)
mClientOnWhite
(
aClientOnWhite
)
{
}
virtual
bool
IsLocked
(
)
override
;
virtual
bool
Lock
(
OpenMode
aMode
)
override
;
virtual
void
Unlock
(
)
override
;
void
SyncWithObject
(
SyncObjectClient
*
aSyncObject
)
;
void
Clear
(
)
;
TextureClient
*
GetClient
(
)
const
{
return
mClient
;
}
TextureClient
*
GetClientOnWhite
(
)
const
{
return
mClientOnWhite
;
}
virtual
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
override
;
virtual
bool
HaveBuffer
(
)
const
override
{
return
!
!
mClient
;
}
virtual
bool
HaveBufferOnWhite
(
)
const
override
{
return
!
!
mClientOnWhite
;
}
virtual
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetSourceSurface
(
ContextSource
aSource
)
const
override
;
protected
:
virtual
gfx
:
:
DrawTarget
*
GetDTBuffer
(
)
const
override
;
virtual
gfx
:
:
DrawTarget
*
GetDTBufferOnWhite
(
)
const
override
;
private
:
RefPtr
<
TextureClient
>
mClient
;
RefPtr
<
TextureClient
>
mClientOnWhite
;
RefPtr
<
gfx
:
:
DrawTarget
>
mTarget
;
RefPtr
<
gfx
:
:
DrawTarget
>
mTargetOnWhite
;
}
;
class
DrawTargetRotatedBuffer
:
public
RotatedBuffer
{
public
:
DrawTargetRotatedBuffer
(
gfx
:
:
DrawTarget
*
aTarget
gfx
:
:
DrawTarget
*
aTargetOnWhite
const
gfx
:
:
IntRect
&
aBufferRect
const
gfx
:
:
IntPoint
&
aBufferRotation
)
:
RotatedBuffer
(
aBufferRect
aBufferRotation
)
mTarget
(
aTarget
)
mTargetOnWhite
(
aTargetOnWhite
)
{
}
virtual
bool
IsLocked
(
)
override
{
return
false
;
}
virtual
bool
Lock
(
OpenMode
aMode
)
override
{
return
true
;
}
virtual
void
Unlock
(
)
override
{
}
virtual
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
override
;
virtual
bool
HaveBuffer
(
)
const
override
{
return
!
!
mTarget
;
}
virtual
bool
HaveBufferOnWhite
(
)
const
override
{
return
!
!
mTargetOnWhite
;
}
virtual
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetSourceSurface
(
ContextSource
aSource
)
const
override
;
protected
:
virtual
gfx
:
:
DrawTarget
*
GetDTBuffer
(
)
const
override
;
virtual
gfx
:
:
DrawTarget
*
GetDTBufferOnWhite
(
)
const
override
;
private
:
RefPtr
<
gfx
:
:
DrawTarget
>
mTarget
;
RefPtr
<
gfx
:
:
DrawTarget
>
mTargetOnWhite
;
}
;
class
SourceRotatedBuffer
:
public
RotatedBuffer
{
public
:
SourceRotatedBuffer
(
gfx
:
:
SourceSurface
*
aSource
gfx
:
:
SourceSurface
*
aSourceOnWhite
const
gfx
:
:
IntRect
&
aBufferRect
const
gfx
:
:
IntPoint
&
aBufferRotation
)
:
RotatedBuffer
(
aBufferRect
aBufferRotation
)
mSource
(
aSource
)
mSourceOnWhite
(
aSourceOnWhite
)
{
}
virtual
bool
IsLocked
(
)
override
{
return
false
;
}
virtual
bool
Lock
(
OpenMode
aMode
)
override
{
return
false
;
}
virtual
void
Unlock
(
)
override
{
}
virtual
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetSourceSurface
(
ContextSource
aSource
)
const
;
virtual
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
override
;
virtual
bool
HaveBuffer
(
)
const
{
return
!
!
mSource
;
}
virtual
bool
HaveBufferOnWhite
(
)
const
{
return
!
!
mSourceOnWhite
;
}
protected
:
virtual
gfx
:
:
DrawTarget
*
GetDTBuffer
(
)
const
{
return
nullptr
;
}
virtual
gfx
:
:
DrawTarget
*
GetDTBufferOnWhite
(
)
const
{
return
nullptr
;
}
private
:
RefPtr
<
gfx
:
:
SourceSurface
>
mSource
;
RefPtr
<
gfx
:
:
SourceSurface
>
mSourceOnWhite
;
}
;
}
}
#
endif
