#
include
"
mozilla
/
layers
/
ClipManager
.
h
"
#
include
"
DisplayItemClipChain
.
h
"
#
include
"
FrameMetrics
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
layers
/
StackingContextHelper
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
UnitTransforms
.
h
"
static
mozilla
:
:
LazyLogModule
sClipLog
(
"
wr
.
clip
"
)
;
#
define
CLIP_LOG
(
.
.
.
)
MOZ_LOG
(
sClipLog
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
namespace
mozilla
{
namespace
layers
{
ClipManager
:
:
ClipManager
(
)
:
mManager
(
nullptr
)
mBuilder
(
nullptr
)
{
}
void
ClipManager
:
:
BeginBuild
(
WebRenderLayerManager
*
aManager
wr
:
:
DisplayListBuilder
&
aBuilder
)
{
MOZ_ASSERT
(
!
mManager
)
;
mManager
=
aManager
;
MOZ_ASSERT
(
!
mBuilder
)
;
mBuilder
=
&
aBuilder
;
MOZ_ASSERT
(
mCacheStack
.
empty
(
)
)
;
mCacheStack
.
emplace
(
)
;
MOZ_ASSERT
(
mASROverride
.
empty
(
)
)
;
MOZ_ASSERT
(
mItemClipStack
.
empty
(
)
)
;
}
void
ClipManager
:
:
EndBuild
(
)
{
mBuilder
=
nullptr
;
mManager
=
nullptr
;
mCacheStack
.
pop
(
)
;
MOZ_ASSERT
(
mCacheStack
.
empty
(
)
)
;
MOZ_ASSERT
(
mASROverride
.
empty
(
)
)
;
MOZ_ASSERT
(
mItemClipStack
.
empty
(
)
)
;
}
void
ClipManager
:
:
BeginList
(
const
StackingContextHelper
&
aStackingContext
)
{
CLIP_LOG
(
"
begin
list
%
p
affects
=
%
d
ref
-
frame
=
%
d
\
n
"
&
aStackingContext
aStackingContext
.
AffectsClipPositioning
(
)
aStackingContext
.
ReferenceFrameId
(
)
.
isSome
(
)
)
;
ItemClips
clips
(
nullptr
nullptr
0
false
)
;
if
(
!
mItemClipStack
.
empty
(
)
)
{
clips
=
mItemClipStack
.
top
(
)
;
}
if
(
aStackingContext
.
AffectsClipPositioning
(
)
)
{
if
(
auto
referenceFrameId
=
aStackingContext
.
ReferenceFrameId
(
)
)
{
PushOverrideForASR
(
clips
.
mASR
*
referenceFrameId
)
;
clips
.
mScrollId
=
*
referenceFrameId
;
}
else
{
mCacheStack
.
emplace
(
)
;
}
if
(
clips
.
mChain
)
{
clips
.
mClipChainId
=
DefineClipChain
(
clips
.
mChain
clips
.
mAppUnitsPerDevPixel
)
;
}
}
CLIP_LOG
(
"
push
:
clip
:
%
p
asr
:
%
p
scroll
=
%
"
PRIuPTR
"
clip
=
%
"
PRIu64
"
\
n
"
clips
.
mChain
clips
.
mASR
clips
.
mScrollId
.
id
clips
.
mClipChainId
.
valueOr
(
wr
:
:
WrClipChainId
{
0
}
)
.
id
)
;
mItemClipStack
.
push
(
clips
)
;
}
void
ClipManager
:
:
EndList
(
const
StackingContextHelper
&
aStackingContext
)
{
MOZ_ASSERT
(
!
mItemClipStack
.
empty
(
)
)
;
CLIP_LOG
(
"
end
list
%
p
\
n
"
&
aStackingContext
)
;
mBuilder
-
>
SetClipChainLeaf
(
Nothing
(
)
)
;
mItemClipStack
.
pop
(
)
;
if
(
aStackingContext
.
AffectsClipPositioning
(
)
)
{
if
(
aStackingContext
.
ReferenceFrameId
(
)
)
{
PopOverrideForASR
(
mItemClipStack
.
empty
(
)
?
nullptr
:
mItemClipStack
.
top
(
)
.
mASR
)
;
}
else
{
MOZ_ASSERT
(
!
mCacheStack
.
empty
(
)
)
;
mCacheStack
.
pop
(
)
;
}
}
}
void
ClipManager
:
:
PushOverrideForASR
(
const
ActiveScrolledRoot
*
aASR
const
wr
:
:
WrSpatialId
&
aSpatialId
)
{
wr
:
:
WrSpatialId
space
=
GetScrollLayer
(
aASR
)
;
CLIP_LOG
(
"
Pushing
%
p
override
%
zu
-
>
%
zu
\
n
"
aASR
space
.
id
aSpatialId
.
id
)
;
auto
it
=
mASROverride
.
insert
(
{
space
std
:
:
stack
<
wr
:
:
WrSpatialId
>
(
)
}
)
;
it
.
first
-
>
second
.
push
(
aSpatialId
)
;
mCacheStack
.
emplace
(
)
;
if
(
!
mItemClipStack
.
empty
(
)
)
{
auto
&
top
=
mItemClipStack
.
top
(
)
;
if
(
top
.
mASR
=
=
aASR
)
{
top
.
mScrollId
=
aSpatialId
;
if
(
top
.
mChain
)
{
top
.
mClipChainId
=
DefineClipChain
(
top
.
mChain
top
.
mAppUnitsPerDevPixel
)
;
}
}
}
}
void
ClipManager
:
:
PopOverrideForASR
(
const
ActiveScrolledRoot
*
aASR
)
{
MOZ_ASSERT
(
!
mCacheStack
.
empty
(
)
)
;
mCacheStack
.
pop
(
)
;
wr
:
:
WrSpatialId
space
=
GetScrollLayer
(
aASR
)
;
auto
it
=
mASROverride
.
find
(
space
)
;
if
(
it
=
=
mASROverride
.
end
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Push
/
PopOverrideForASR
should
be
balanced
"
)
;
}
else
{
CLIP_LOG
(
"
Popping
%
p
override
%
zu
-
>
%
zu
\
n
"
aASR
space
.
id
it
-
>
second
.
top
(
)
.
id
)
;
it
-
>
second
.
pop
(
)
;
}
if
(
!
mItemClipStack
.
empty
(
)
)
{
auto
&
top
=
mItemClipStack
.
top
(
)
;
if
(
top
.
mASR
=
=
aASR
)
{
top
.
mScrollId
=
(
it
=
=
mASROverride
.
end
(
)
|
|
it
-
>
second
.
empty
(
)
)
?
space
:
it
-
>
second
.
top
(
)
;
if
(
top
.
mChain
)
{
top
.
mClipChainId
=
DefineClipChain
(
top
.
mChain
top
.
mAppUnitsPerDevPixel
)
;
}
}
}
if
(
it
!
=
mASROverride
.
end
(
)
&
&
it
-
>
second
.
empty
(
)
)
{
mASROverride
.
erase
(
it
)
;
}
}
wr
:
:
WrSpatialId
ClipManager
:
:
SpatialIdAfterOverride
(
const
wr
:
:
WrSpatialId
&
aSpatialId
)
{
auto
it
=
mASROverride
.
find
(
aSpatialId
)
;
if
(
it
=
=
mASROverride
.
end
(
)
)
{
return
aSpatialId
;
}
MOZ_ASSERT
(
!
it
-
>
second
.
empty
(
)
)
;
CLIP_LOG
(
"
Overriding
%
zu
with
%
zu
\
n
"
aSpatialId
.
id
it
-
>
second
.
top
(
)
.
id
)
;
return
it
-
>
second
.
top
(
)
;
}
wr
:
:
WrSpaceAndClipChain
ClipManager
:
:
SwitchItem
(
nsDisplayListBuilder
*
aBuilder
nsDisplayItem
*
aItem
)
{
const
DisplayItemClipChain
*
clip
=
aItem
-
>
GetClipChain
(
)
;
const
DisplayItemClipChain
*
inheritedClipChain
=
mBuilder
-
>
GetInheritedClipChain
(
)
;
if
(
inheritedClipChain
&
&
inheritedClipChain
!
=
clip
)
{
if
(
!
clip
)
{
clip
=
mBuilder
-
>
GetInheritedClipChain
(
)
;
}
else
{
clip
=
aBuilder
-
>
CreateClipChainIntersection
(
mBuilder
-
>
GetInheritedClipChain
(
)
clip
)
;
}
}
const
ActiveScrolledRoot
*
asr
=
aItem
-
>
GetActiveScrolledRoot
(
)
;
DisplayItemType
type
=
aItem
-
>
GetType
(
)
;
if
(
type
=
=
DisplayItemType
:
:
TYPE_STICKY_POSITION
)
{
auto
*
sticky
=
static_cast
<
nsDisplayStickyPosition
*
>
(
aItem
)
;
asr
=
sticky
-
>
GetContainerASR
(
)
;
if
(
sticky
-
>
IsClippedToDisplayPort
(
)
&
&
clip
&
&
clip
-
>
mASR
=
=
asr
)
{
clip
=
clip
-
>
mParent
;
}
}
CLIP_LOG
(
"
processing
item
%
p
(
%
s
)
asr
%
p
clip
%
p
inherited
=
%
p
\
n
"
aItem
DisplayItemTypeName
(
aItem
-
>
GetType
(
)
)
asr
clip
inheritedClipChain
)
;
bool
separateLeaf
=
false
;
if
(
clip
&
&
clip
-
>
mASR
=
=
asr
&
&
clip
-
>
mClip
.
GetRoundedRectCount
(
)
=
=
0
)
{
separateLeaf
=
!
aItem
-
>
GetChildren
(
)
;
}
const
int32_t
auPerDevPixel
=
[
&
]
{
if
(
type
=
=
DisplayItemType
:
:
TYPE_ZOOM
)
{
return
static_cast
<
nsDisplayZoom
*
>
(
aItem
)
-
>
GetParentAppUnitsPerDevPixel
(
)
;
}
return
aItem
-
>
Frame
(
)
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
}
(
)
;
ItemClips
clips
(
asr
clip
auPerDevPixel
separateLeaf
)
;
MOZ_ASSERT
(
!
mItemClipStack
.
empty
(
)
)
;
if
(
clips
.
HasSameInputs
(
mItemClipStack
.
top
(
)
)
)
{
CLIP_LOG
(
"
\
tearly
-
exit
for
%
p
\
n
"
aItem
)
;
return
mItemClipStack
.
top
(
)
.
GetSpaceAndClipChain
(
)
;
}
mItemClipStack
.
pop
(
)
;
if
(
separateLeaf
)
{
CLIP_LOG
(
"
\
tseparate
leaf
detected
ignoring
the
last
clip
\
n
"
)
;
clip
=
clip
-
>
mParent
;
}
const
ActiveScrolledRoot
*
leafmostASR
=
asr
;
if
(
clip
)
{
leafmostASR
=
ActiveScrolledRoot
:
:
PickDescendant
(
leafmostASR
clip
-
>
mASR
)
;
}
Maybe
<
wr
:
:
WrSpatialId
>
leafmostId
=
DefineScrollLayers
(
leafmostASR
aItem
)
;
Unused
<
<
leafmostId
;
clips
.
mClipChainId
=
DefineClipChain
(
clip
auPerDevPixel
)
;
wr
:
:
WrSpatialId
space
=
GetScrollLayer
(
asr
)
;
clips
.
mScrollId
=
SpatialIdAfterOverride
(
space
)
;
CLIP_LOG
(
"
\
tassigning
%
d
-
>
%
d
\
n
"
(
int
)
space
.
id
(
int
)
clips
.
mScrollId
.
id
)
;
clips
.
UpdateSeparateLeaf
(
*
mBuilder
auPerDevPixel
)
;
auto
spaceAndClipChain
=
clips
.
GetSpaceAndClipChain
(
)
;
CLIP_LOG
(
"
push
:
clip
:
%
p
asr
:
%
p
scroll
=
%
"
PRIuPTR
"
clip
=
%
"
PRIu64
"
\
n
"
clips
.
mChain
clips
.
mASR
clips
.
mScrollId
.
id
clips
.
mClipChainId
.
valueOr
(
wr
:
:
WrClipChainId
{
0
}
)
.
id
)
;
mItemClipStack
.
push
(
clips
)
;
CLIP_LOG
(
"
done
setup
for
%
p
\
n
"
aItem
)
;
return
spaceAndClipChain
;
}
wr
:
:
WrSpatialId
ClipManager
:
:
GetScrollLayer
(
const
ActiveScrolledRoot
*
aASR
)
{
for
(
const
ActiveScrolledRoot
*
asr
=
aASR
;
asr
;
asr
=
asr
-
>
mParent
)
{
Maybe
<
wr
:
:
WrSpatialId
>
space
=
mBuilder
-
>
GetScrollIdForDefinedScrollLayer
(
asr
-
>
GetViewId
(
)
)
;
if
(
space
)
{
return
*
space
;
}
}
Maybe
<
wr
:
:
WrSpatialId
>
space
=
mBuilder
-
>
GetScrollIdForDefinedScrollLayer
(
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
)
;
MOZ_ASSERT
(
space
.
isSome
(
)
)
;
return
*
space
;
}
Maybe
<
wr
:
:
WrSpatialId
>
ClipManager
:
:
DefineScrollLayers
(
const
ActiveScrolledRoot
*
aASR
nsDisplayItem
*
aItem
)
{
if
(
!
aASR
)
{
return
Nothing
(
)
;
}
ScrollableLayerGuid
:
:
ViewID
viewId
=
aASR
-
>
GetViewId
(
)
;
Maybe
<
wr
:
:
WrSpatialId
>
space
=
mBuilder
-
>
GetScrollIdForDefinedScrollLayer
(
viewId
)
;
if
(
space
)
{
return
space
;
}
Maybe
<
wr
:
:
WrSpatialId
>
ancestorSpace
=
DefineScrollLayers
(
aASR
-
>
mParent
aItem
)
;
Maybe
<
ScrollMetadata
>
metadata
=
aASR
-
>
mScrollableFrame
-
>
ComputeScrollMetadata
(
mManager
aItem
-
>
Frame
(
)
aItem
-
>
ToReferenceFrame
(
)
)
;
if
(
!
metadata
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Expected
scroll
metadata
to
be
available
!
"
)
;
return
ancestorSpace
;
}
FrameMetrics
&
metrics
=
metadata
-
>
GetMetrics
(
)
;
if
(
!
metrics
.
IsScrollable
(
)
)
{
return
ancestorSpace
;
}
nsIScrollableFrame
*
scrollableFrame
=
aASR
-
>
mScrollableFrame
;
nsIFrame
*
scrollFrame
=
do_QueryFrame
(
scrollableFrame
)
;
nsPoint
offset
=
scrollFrame
-
>
GetOffsetToCrossDoc
(
aItem
-
>
Frame
(
)
)
+
aItem
-
>
ToReferenceFrame
(
)
;
int32_t
auPerDevPixel
=
aItem
-
>
Frame
(
)
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
scrollPort
=
scrollableFrame
-
>
GetScrollPortRect
(
)
+
offset
;
LayoutDeviceRect
clipBounds
=
LayoutDeviceRect
:
:
FromAppUnits
(
scrollPort
auPerDevPixel
)
;
LayoutDeviceRect
contentRect
=
metrics
.
GetExpandedScrollableRect
(
)
*
metrics
.
GetDevPixelsPerCSSPixel
(
)
;
contentRect
.
MoveTo
(
clipBounds
.
TopLeft
(
)
)
;
Maybe
<
wr
:
:
WrSpatialId
>
parent
=
ancestorSpace
;
if
(
parent
)
{
*
parent
=
SpatialIdAfterOverride
(
*
parent
)
;
}
const
bool
useRoundedOffset
=
StaticPrefs
:
:
apz_rounded_external_scroll_offset
(
)
;
LayoutDevicePoint
scrollOffset
=
useRoundedOffset
?
LayoutDevicePoint
:
:
FromAppUnitsRounded
(
scrollableFrame
-
>
GetScrollPosition
(
)
auPerDevPixel
)
:
LayoutDevicePoint
:
:
FromAppUnits
(
scrollableFrame
-
>
GetScrollPosition
(
)
auPerDevPixel
)
;
nsPresContext
*
presContext
=
aItem
-
>
Frame
(
)
-
>
PresContext
(
)
;
const
bool
hasScrollLinkedEffect
=
!
StaticPrefs
:
:
apz_disable_for_scroll_linked_effects
(
)
&
&
presContext
-
>
Document
(
)
-
>
HasScrollLinkedEffect
(
)
;
return
Some
(
mBuilder
-
>
DefineScrollLayer
(
viewId
parent
wr
:
:
ToLayoutRect
(
contentRect
)
wr
:
:
ToLayoutRect
(
clipBounds
)
wr
:
:
ToLayoutVector2D
(
scrollOffset
)
wr
:
:
ToWrAPZScrollGeneration
(
scrollableFrame
-
>
ScrollGenerationOnApz
(
)
)
wr
:
:
ToWrHasScrollLinkedEffect
(
hasScrollLinkedEffect
)
wr
:
:
SpatialKey
(
uint64_t
(
scrollFrame
)
0
wr
:
:
SpatialKeyKind
:
:
Scroll
)
)
)
;
}
Maybe
<
wr
:
:
WrClipChainId
>
ClipManager
:
:
DefineClipChain
(
const
DisplayItemClipChain
*
aChain
int32_t
aAppUnitsPerDevPixel
)
{
MOZ_ASSERT
(
!
mCacheStack
.
empty
(
)
)
;
AutoTArray
<
wr
:
:
WrClipId
6
>
allClipIds
;
ClipIdMap
&
cache
=
mCacheStack
.
top
(
)
;
for
(
const
DisplayItemClipChain
*
chain
=
aChain
;
chain
;
chain
=
chain
-
>
mParent
)
{
MOZ_DIAGNOSTIC_ASSERT
(
chain
-
>
mOnStack
|
|
!
chain
-
>
mASR
|
|
chain
-
>
mASR
-
>
mScrollableFrame
)
;
if
(
!
chain
-
>
mClip
.
HasClip
(
)
)
{
continue
;
}
auto
emplaceResult
=
cache
.
try_emplace
(
chain
)
;
auto
&
chainClipIds
=
emplaceResult
.
first
-
>
second
;
if
(
!
emplaceResult
.
second
)
{
CLIP_LOG
(
"
cache
[
%
p
]
=
>
hit
\
n
"
chain
)
;
allClipIds
.
AppendElements
(
chainClipIds
)
;
continue
;
}
LayoutDeviceRect
clip
=
LayoutDeviceRect
:
:
FromAppUnits
(
chain
-
>
mClip
.
GetClipRect
(
)
aAppUnitsPerDevPixel
)
;
AutoTArray
<
wr
:
:
ComplexClipRegion
6
>
wrRoundedRects
;
chain
-
>
mClip
.
ToComplexClipRegions
(
aAppUnitsPerDevPixel
wrRoundedRects
)
;
wr
:
:
WrSpatialId
space
=
GetScrollLayer
(
chain
-
>
mASR
)
;
space
=
SpatialIdAfterOverride
(
space
)
;
auto
rectClipId
=
mBuilder
-
>
DefineRectClip
(
Some
(
space
)
wr
:
:
ToLayoutRect
(
clip
)
)
;
CLIP_LOG
(
"
cache
[
%
p
]
<
=
%
zu
\
n
"
chain
rectClipId
.
id
)
;
chainClipIds
.
AppendElement
(
rectClipId
)
;
for
(
const
auto
&
complexClip
:
wrRoundedRects
)
{
auto
complexClipId
=
mBuilder
-
>
DefineRoundedRectClip
(
Some
(
space
)
complexClip
)
;
CLIP_LOG
(
"
cache
[
%
p
]
<
=
%
zu
\
n
"
chain
complexClipId
.
id
)
;
chainClipIds
.
AppendElement
(
complexClipId
)
;
}
allClipIds
.
AppendElements
(
chainClipIds
)
;
}
if
(
allClipIds
.
IsEmpty
(
)
)
{
return
Nothing
(
)
;
}
return
Some
(
mBuilder
-
>
DefineClipChain
(
allClipIds
)
)
;
}
ClipManager
:
:
~
ClipManager
(
)
{
MOZ_ASSERT
(
!
mBuilder
)
;
MOZ_ASSERT
(
mCacheStack
.
empty
(
)
)
;
MOZ_ASSERT
(
mItemClipStack
.
empty
(
)
)
;
}
ClipManager
:
:
ItemClips
:
:
ItemClips
(
const
ActiveScrolledRoot
*
aASR
const
DisplayItemClipChain
*
aChain
int32_t
aAppUnitsPerDevPixel
bool
aSeparateLeaf
)
:
mASR
(
aASR
)
mChain
(
aChain
)
mAppUnitsPerDevPixel
(
aAppUnitsPerDevPixel
)
mSeparateLeaf
(
aSeparateLeaf
)
{
mScrollId
=
wr
:
:
wr_root_scroll_node_id
(
)
;
}
void
ClipManager
:
:
ItemClips
:
:
UpdateSeparateLeaf
(
wr
:
:
DisplayListBuilder
&
aBuilder
int32_t
aAppUnitsPerDevPixel
)
{
Maybe
<
wr
:
:
LayoutRect
>
clipLeaf
;
if
(
mSeparateLeaf
)
{
MOZ_ASSERT
(
mChain
)
;
clipLeaf
.
emplace
(
wr
:
:
ToLayoutRect
(
LayoutDeviceRect
:
:
FromAppUnits
(
mChain
-
>
mClip
.
GetClipRect
(
)
aAppUnitsPerDevPixel
)
)
)
;
}
aBuilder
.
SetClipChainLeaf
(
clipLeaf
)
;
}
bool
ClipManager
:
:
ItemClips
:
:
HasSameInputs
(
const
ItemClips
&
aOther
)
{
if
(
mASR
!
=
aOther
.
mASR
|
|
mChain
!
=
aOther
.
mChain
|
|
mSeparateLeaf
!
=
aOther
.
mSeparateLeaf
)
{
return
false
;
}
if
(
mChain
&
&
mAppUnitsPerDevPixel
!
=
aOther
.
mAppUnitsPerDevPixel
)
{
return
false
;
}
return
true
;
}
wr
:
:
WrSpaceAndClipChain
ClipManager
:
:
ItemClips
:
:
GetSpaceAndClipChain
(
)
const
{
auto
spaceAndClipChain
=
wr
:
:
RootScrollNodeWithChain
(
)
;
spaceAndClipChain
.
space
=
mScrollId
;
if
(
mClipChainId
)
{
spaceAndClipChain
.
clip_chain
=
mClipChainId
-
>
id
;
}
return
spaceAndClipChain
;
}
}
}
