#
include
"
mozilla
/
layers
/
ClipManager
.
h
"
#
include
"
DisplayItemClipChain
.
h
"
#
include
"
FrameMetrics
.
h
"
#
include
"
mozilla
/
ScrollContainerFrame
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
layers
/
StackingContextHelper
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
UnitTransforms
.
h
"
static
mozilla
:
:
LazyLogModule
sClipLog
(
"
wr
.
clip
"
)
;
#
define
CLIP_LOG
(
.
.
.
)
MOZ_LOG
(
sClipLog
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
namespace
mozilla
{
namespace
layers
{
ClipManager
:
:
ClipManager
(
)
:
mManager
(
nullptr
)
mBuilder
(
nullptr
)
{
}
void
ClipManager
:
:
BeginBuild
(
WebRenderLayerManager
*
aManager
wr
:
:
DisplayListBuilder
&
aBuilder
)
{
MOZ_ASSERT
(
!
mManager
)
;
mManager
=
aManager
;
MOZ_ASSERT
(
!
mBuilder
)
;
mBuilder
=
&
aBuilder
;
MOZ_ASSERT
(
mCacheStack
.
empty
(
)
)
;
mCacheStack
.
emplace
(
)
;
MOZ_ASSERT
(
mASROverride
.
empty
(
)
)
;
MOZ_ASSERT
(
mItemClipStack
.
empty
(
)
)
;
}
void
ClipManager
:
:
EndBuild
(
)
{
mBuilder
=
nullptr
;
mManager
=
nullptr
;
mCacheStack
.
pop
(
)
;
MOZ_ASSERT
(
mCacheStack
.
empty
(
)
)
;
MOZ_ASSERT
(
mASROverride
.
empty
(
)
)
;
MOZ_ASSERT
(
mItemClipStack
.
empty
(
)
)
;
}
void
ClipManager
:
:
BeginList
(
const
StackingContextHelper
&
aStackingContext
)
{
CLIP_LOG
(
"
begin
list
%
p
affects
=
%
d
ref
-
frame
=
%
d
\
n
"
&
aStackingContext
aStackingContext
.
AffectsClipPositioning
(
)
aStackingContext
.
ReferenceFrameId
(
)
.
isSome
(
)
)
;
ItemClips
clips
(
nullptr
nullptr
0
false
)
;
if
(
!
mItemClipStack
.
empty
(
)
)
{
clips
=
mItemClipStack
.
top
(
)
;
}
if
(
aStackingContext
.
AffectsClipPositioning
(
)
)
{
if
(
auto
referenceFrameId
=
aStackingContext
.
ReferenceFrameId
(
)
)
{
PushOverrideForASR
(
clips
.
mASR
*
referenceFrameId
)
;
clips
.
mScrollId
=
*
referenceFrameId
;
}
else
{
mCacheStack
.
emplace
(
)
;
}
if
(
clips
.
mChain
)
{
clips
.
mClipChainId
=
DefineClipChain
(
clips
.
mChain
clips
.
mAppUnitsPerDevPixel
)
;
}
}
CLIP_LOG
(
"
push
:
clip
:
%
p
asr
:
%
p
scroll
=
%
"
PRIuPTR
"
clip
=
%
"
PRIu64
"
\
n
"
clips
.
mChain
clips
.
mASR
clips
.
mScrollId
.
id
clips
.
mClipChainId
.
valueOr
(
wr
:
:
WrClipChainId
{
0
}
)
.
id
)
;
mItemClipStack
.
push
(
clips
)
;
}
void
ClipManager
:
:
EndList
(
const
StackingContextHelper
&
aStackingContext
)
{
MOZ_ASSERT
(
!
mItemClipStack
.
empty
(
)
)
;
CLIP_LOG
(
"
end
list
%
p
\
n
"
&
aStackingContext
)
;
mBuilder
-
>
SetClipChainLeaf
(
Nothing
(
)
)
;
mItemClipStack
.
pop
(
)
;
if
(
aStackingContext
.
AffectsClipPositioning
(
)
)
{
if
(
aStackingContext
.
ReferenceFrameId
(
)
)
{
PopOverrideForASR
(
mItemClipStack
.
empty
(
)
?
nullptr
:
mItemClipStack
.
top
(
)
.
mASR
)
;
}
else
{
MOZ_ASSERT
(
!
mCacheStack
.
empty
(
)
)
;
mCacheStack
.
pop
(
)
;
}
}
}
void
ClipManager
:
:
PushOverrideForASR
(
const
ActiveScrolledRoot
*
aASR
const
wr
:
:
WrSpatialId
&
aSpatialId
)
{
wr
:
:
WrSpatialId
space
=
GetSpatialId
(
aASR
)
;
CLIP_LOG
(
"
Pushing
%
p
override
%
zu
-
>
%
zu
\
n
"
aASR
space
.
id
aSpatialId
.
id
)
;
auto
it
=
mASROverride
.
insert
(
{
space
std
:
:
stack
<
wr
:
:
WrSpatialId
>
(
)
}
)
;
it
.
first
-
>
second
.
push
(
aSpatialId
)
;
mCacheStack
.
emplace
(
)
;
if
(
!
mItemClipStack
.
empty
(
)
)
{
auto
&
top
=
mItemClipStack
.
top
(
)
;
if
(
top
.
mASR
=
=
aASR
)
{
top
.
mScrollId
=
aSpatialId
;
if
(
top
.
mChain
)
{
top
.
mClipChainId
=
DefineClipChain
(
top
.
mChain
top
.
mAppUnitsPerDevPixel
)
;
}
}
}
}
void
ClipManager
:
:
PopOverrideForASR
(
const
ActiveScrolledRoot
*
aASR
)
{
MOZ_ASSERT
(
!
mCacheStack
.
empty
(
)
)
;
mCacheStack
.
pop
(
)
;
wr
:
:
WrSpatialId
space
=
GetSpatialId
(
aASR
)
;
auto
it
=
mASROverride
.
find
(
space
)
;
if
(
it
=
=
mASROverride
.
end
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Push
/
PopOverrideForASR
should
be
balanced
"
)
;
}
else
{
CLIP_LOG
(
"
Popping
%
p
override
%
zu
-
>
%
zu
\
n
"
aASR
space
.
id
it
-
>
second
.
top
(
)
.
id
)
;
it
-
>
second
.
pop
(
)
;
}
if
(
!
mItemClipStack
.
empty
(
)
)
{
auto
&
top
=
mItemClipStack
.
top
(
)
;
if
(
top
.
mASR
=
=
aASR
)
{
top
.
mScrollId
=
(
it
=
=
mASROverride
.
end
(
)
|
|
it
-
>
second
.
empty
(
)
)
?
space
:
it
-
>
second
.
top
(
)
;
if
(
top
.
mChain
)
{
top
.
mClipChainId
=
DefineClipChain
(
top
.
mChain
top
.
mAppUnitsPerDevPixel
)
;
}
}
}
if
(
it
!
=
mASROverride
.
end
(
)
&
&
it
-
>
second
.
empty
(
)
)
{
mASROverride
.
erase
(
it
)
;
}
}
wr
:
:
WrSpatialId
ClipManager
:
:
SpatialIdAfterOverride
(
const
wr
:
:
WrSpatialId
&
aSpatialId
)
{
auto
it
=
mASROverride
.
find
(
aSpatialId
)
;
if
(
it
=
=
mASROverride
.
end
(
)
)
{
return
aSpatialId
;
}
MOZ_ASSERT
(
!
it
-
>
second
.
empty
(
)
)
;
CLIP_LOG
(
"
Overriding
%
zu
with
%
zu
\
n
"
aSpatialId
.
id
it
-
>
second
.
top
(
)
.
id
)
;
return
it
-
>
second
.
top
(
)
;
}
wr
:
:
WrSpaceAndClipChain
ClipManager
:
:
SwitchItem
(
nsDisplayListBuilder
*
aBuilder
nsDisplayItem
*
aItem
)
{
const
DisplayItemClipChain
*
clip
=
aItem
-
>
GetClipChain
(
)
;
const
DisplayItemClipChain
*
inheritedClipChain
=
mBuilder
-
>
GetInheritedClipChain
(
)
;
if
(
inheritedClipChain
&
&
inheritedClipChain
!
=
clip
)
{
if
(
!
clip
)
{
clip
=
mBuilder
-
>
GetInheritedClipChain
(
)
;
}
else
{
clip
=
aBuilder
-
>
CreateClipChainIntersection
(
mBuilder
-
>
GetInheritedClipChain
(
)
clip
)
;
}
}
const
ActiveScrolledRoot
*
asr
=
aItem
-
>
GetActiveScrolledRoot
(
)
;
DisplayItemType
type
=
aItem
-
>
GetType
(
)
;
const
ActiveScrolledRoot
*
stickyAsr
=
nullptr
;
if
(
type
=
=
DisplayItemType
:
:
TYPE_STICKY_POSITION
)
{
auto
*
sticky
=
static_cast
<
nsDisplayStickyPosition
*
>
(
aItem
)
;
asr
=
sticky
-
>
GetContainerASR
(
)
;
stickyAsr
=
ActiveScrolledRoot
:
:
GetStickyASRFromFrame
(
sticky
-
>
Frame
(
)
)
;
MOZ_ASSERT
(
stickyAsr
)
;
}
CLIP_LOG
(
"
processing
item
%
p
(
%
s
)
asr
%
p
clip
%
p
inherited
=
%
p
\
n
"
aItem
DisplayItemTypeName
(
aItem
-
>
GetType
(
)
)
asr
clip
inheritedClipChain
)
;
bool
separateLeaf
=
false
;
if
(
clip
&
&
clip
-
>
mASR
=
=
asr
&
&
clip
-
>
mClip
.
GetRoundedRectCount
(
)
=
=
0
)
{
separateLeaf
=
!
aItem
-
>
GetChildren
(
)
;
}
const
int32_t
auPerDevPixel
=
[
&
]
{
if
(
type
=
=
DisplayItemType
:
:
TYPE_ZOOM
)
{
return
static_cast
<
nsDisplayZoom
*
>
(
aItem
)
-
>
GetParentAppUnitsPerDevPixel
(
)
;
}
return
aItem
-
>
Frame
(
)
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
}
(
)
;
ItemClips
clips
(
asr
clip
auPerDevPixel
separateLeaf
)
;
MOZ_ASSERT
(
!
mItemClipStack
.
empty
(
)
)
;
if
(
clips
.
HasSameInputs
(
mItemClipStack
.
top
(
)
)
)
{
CLIP_LOG
(
"
\
tearly
-
exit
for
%
p
\
n
"
aItem
)
;
return
mItemClipStack
.
top
(
)
.
GetSpaceAndClipChain
(
)
;
}
mItemClipStack
.
pop
(
)
;
if
(
separateLeaf
)
{
CLIP_LOG
(
"
\
tseparate
leaf
detected
ignoring
the
last
clip
\
n
"
)
;
clip
=
clip
-
>
mParent
;
}
(
void
)
DefineSpatialNodes
(
aBuilder
asr
aItem
)
;
if
(
clip
&
&
clip
-
>
mASR
!
=
asr
)
{
(
void
)
DefineSpatialNodes
(
aBuilder
clip
-
>
mASR
aItem
)
;
}
if
(
stickyAsr
&
&
stickyAsr
!
=
asr
)
{
(
void
)
DefineSpatialNodes
(
aBuilder
stickyAsr
aItem
)
;
}
clips
.
mClipChainId
=
DefineClipChain
(
clip
auPerDevPixel
)
;
wr
:
:
WrSpatialId
space
=
GetSpatialId
(
asr
)
;
clips
.
mScrollId
=
SpatialIdAfterOverride
(
space
)
;
CLIP_LOG
(
"
\
tassigning
%
d
-
>
%
d
\
n
"
(
int
)
space
.
id
(
int
)
clips
.
mScrollId
.
id
)
;
clips
.
UpdateSeparateLeaf
(
*
mBuilder
auPerDevPixel
)
;
auto
spaceAndClipChain
=
clips
.
GetSpaceAndClipChain
(
)
;
CLIP_LOG
(
"
push
:
clip
:
%
p
asr
:
%
p
scroll
=
%
"
PRIuPTR
"
clip
=
%
"
PRIu64
"
\
n
"
clips
.
mChain
clips
.
mASR
clips
.
mScrollId
.
id
clips
.
mClipChainId
.
valueOr
(
wr
:
:
WrClipChainId
{
0
}
)
.
id
)
;
mItemClipStack
.
push
(
clips
)
;
CLIP_LOG
(
"
done
setup
for
%
p
\
n
"
aItem
)
;
return
spaceAndClipChain
;
}
wr
:
:
WrSpatialId
ClipManager
:
:
GetSpatialId
(
const
ActiveScrolledRoot
*
aASR
)
{
for
(
const
ActiveScrolledRoot
*
asr
=
aASR
;
asr
;
asr
=
asr
-
>
mParent
)
{
Maybe
<
wr
:
:
WrSpatialId
>
space
=
Nothing
(
)
;
if
(
asr
-
>
mKind
=
=
ActiveScrolledRoot
:
:
ASRKind
:
:
Sticky
)
{
space
=
mBuilder
-
>
GetSpatialIdForDefinedStickyLayer
(
asr
)
;
}
else
{
space
=
mBuilder
-
>
GetScrollIdForDefinedScrollLayer
(
asr
-
>
GetViewId
(
)
)
;
}
if
(
space
)
{
return
*
space
;
}
}
Maybe
<
wr
:
:
WrSpatialId
>
space
=
mBuilder
-
>
GetScrollIdForDefinedScrollLayer
(
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
)
;
MOZ_ASSERT
(
space
.
isSome
(
)
)
;
return
*
space
;
}
StickyScrollContainer
*
ClipManager
:
:
GetStickyScrollContainer
(
const
ActiveScrolledRoot
*
aASR
)
{
MOZ_ASSERT
(
aASR
-
>
mKind
=
=
ActiveScrolledRoot
:
:
ASRKind
:
:
Sticky
)
;
StickyScrollContainer
*
stickyScrollContainer
=
StickyScrollContainer
:
:
GetOrCreateForFrame
(
aASR
-
>
mFrame
)
;
if
(
stickyScrollContainer
)
{
if
(
!
stickyScrollContainer
-
>
ScrollContainer
(
)
-
>
IsMaybeAsynchronouslyScrolled
(
)
)
{
stickyScrollContainer
=
nullptr
;
}
}
return
stickyScrollContainer
;
}
static
nscoord
DistanceToRange
(
nscoord
min
nscoord
max
)
{
MOZ_ASSERT
(
min
<
=
max
)
;
if
(
max
<
0
)
{
return
max
;
}
if
(
min
>
0
)
{
return
min
;
}
MOZ_ASSERT
(
min
<
=
0
&
&
max
>
=
0
)
;
return
0
;
}
static
nscoord
PositivePart
(
nscoord
min
nscoord
max
)
{
MOZ_ASSERT
(
min
<
=
max
)
;
if
(
min
>
=
0
)
{
return
max
-
min
;
}
if
(
max
>
0
)
{
return
max
;
}
return
0
;
}
static
nscoord
NegativePart
(
nscoord
min
nscoord
max
)
{
MOZ_ASSERT
(
min
<
=
max
)
;
if
(
max
<
=
0
)
{
return
max
-
min
;
}
if
(
min
<
0
)
{
return
0
-
min
;
}
return
0
;
}
Maybe
<
wr
:
:
WrSpatialId
>
ClipManager
:
:
DefineStickyNode
(
nsDisplayListBuilder
*
aBuilder
Maybe
<
wr
:
:
WrSpatialId
>
aParentSpatialId
const
ActiveScrolledRoot
*
aASR
nsDisplayItem
*
aItem
)
{
nsIFrame
*
stickyFrame
=
aASR
-
>
mFrame
;
if
(
Maybe
<
wr
:
:
WrSpatialId
>
space
=
mBuilder
-
>
GetSpatialIdForDefinedStickyLayer
(
aASR
)
)
{
return
space
;
}
StickyScrollContainer
*
stickyScrollContainer
=
GetStickyScrollContainer
(
aASR
)
;
if
(
!
stickyScrollContainer
)
{
return
Nothing
(
)
;
}
if
(
stickyScrollContainer
-
>
ShouldFlattenAway
(
)
)
{
return
Nothing
(
)
;
}
float
auPerDevPixel
=
stickyFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
itemBounds
;
nsRect
scrollPort
=
stickyScrollContainer
-
>
ScrollContainer
(
)
-
>
GetScrollPortRect
(
)
;
const
nsIFrame
*
referenceFrame
=
aBuilder
-
>
FindReferenceFrameFor
(
stickyFrame
-
>
GetParent
(
)
)
;
nsRect
transformedBounds
=
stickyFrame
-
>
GetRectRelativeToSelf
(
)
;
DebugOnly
transformResult
=
nsLayoutUtils
:
:
TransformRect
(
stickyFrame
referenceFrame
transformedBounds
)
;
MOZ_ASSERT
(
transformResult
=
=
nsLayoutUtils
:
:
TRANSFORM_SUCCEEDED
)
;
itemBounds
=
transformedBounds
;
scrollPort
=
scrollPort
+
stickyScrollContainer
-
>
ScrollContainer
(
)
-
>
GetOffsetToCrossDoc
(
referenceFrame
)
;
Maybe
<
float
>
topMargin
;
Maybe
<
float
>
rightMargin
;
Maybe
<
float
>
bottomMargin
;
Maybe
<
float
>
leftMargin
;
wr
:
:
StickyOffsetBounds
vBounds
=
{
0
.
0
0
.
0
}
;
wr
:
:
StickyOffsetBounds
hBounds
=
{
0
.
0
0
.
0
}
;
nsPoint
appliedOffset
;
nsRectAbsolute
outer
;
nsRectAbsolute
inner
;
stickyScrollContainer
-
>
GetScrollRanges
(
stickyFrame
&
outer
&
inner
)
;
if
(
outer
.
YMost
(
)
!
=
inner
.
YMost
(
)
)
{
nscoord
distance
=
DistanceToRange
(
inner
.
YMost
(
)
outer
.
YMost
(
)
)
;
if
(
distance
>
0
)
{
distance
-
=
PositivePart
(
outer
.
Y
(
)
inner
.
Y
(
)
)
;
}
topMargin
=
Some
(
NSAppUnitsToFloatPixels
(
itemBounds
.
y
-
scrollPort
.
y
-
distance
auPerDevPixel
)
)
;
vBounds
.
max
=
NSAppUnitsToFloatPixels
(
outer
.
YMost
(
)
-
inner
.
YMost
(
)
auPerDevPixel
)
;
if
(
inner
.
YMost
(
)
<
0
)
{
appliedOffset
.
y
=
std
:
:
min
(
0
outer
.
YMost
(
)
)
-
inner
.
YMost
(
)
;
MOZ_ASSERT
(
appliedOffset
.
y
>
0
)
;
}
}
if
(
outer
.
Y
(
)
!
=
inner
.
Y
(
)
)
{
nscoord
distance
=
DistanceToRange
(
outer
.
Y
(
)
inner
.
Y
(
)
)
;
if
(
distance
<
0
)
{
distance
+
=
NegativePart
(
inner
.
YMost
(
)
outer
.
YMost
(
)
)
;
}
bottomMargin
=
Some
(
NSAppUnitsToFloatPixels
(
scrollPort
.
YMost
(
)
-
itemBounds
.
YMost
(
)
+
distance
auPerDevPixel
)
)
;
vBounds
.
min
=
NSAppUnitsToFloatPixels
(
outer
.
Y
(
)
-
inner
.
Y
(
)
auPerDevPixel
)
;
if
(
appliedOffset
.
y
=
=
0
&
&
inner
.
Y
(
)
>
0
)
{
appliedOffset
.
y
=
std
:
:
max
(
0
outer
.
Y
(
)
)
-
inner
.
Y
(
)
;
MOZ_ASSERT
(
appliedOffset
.
y
<
0
)
;
}
}
if
(
outer
.
XMost
(
)
!
=
inner
.
XMost
(
)
)
{
nscoord
distance
=
DistanceToRange
(
inner
.
XMost
(
)
outer
.
XMost
(
)
)
;
if
(
distance
>
0
)
{
distance
-
=
PositivePart
(
outer
.
X
(
)
inner
.
X
(
)
)
;
}
leftMargin
=
Some
(
NSAppUnitsToFloatPixels
(
itemBounds
.
x
-
scrollPort
.
x
-
distance
auPerDevPixel
)
)
;
hBounds
.
max
=
NSAppUnitsToFloatPixels
(
outer
.
XMost
(
)
-
inner
.
XMost
(
)
auPerDevPixel
)
;
if
(
inner
.
XMost
(
)
<
0
)
{
appliedOffset
.
x
=
std
:
:
min
(
0
outer
.
XMost
(
)
)
-
inner
.
XMost
(
)
;
MOZ_ASSERT
(
appliedOffset
.
x
>
0
)
;
}
}
if
(
outer
.
X
(
)
!
=
inner
.
X
(
)
)
{
nscoord
distance
=
DistanceToRange
(
outer
.
X
(
)
inner
.
X
(
)
)
;
if
(
distance
<
0
)
{
distance
+
=
NegativePart
(
inner
.
XMost
(
)
outer
.
XMost
(
)
)
;
}
rightMargin
=
Some
(
NSAppUnitsToFloatPixels
(
scrollPort
.
XMost
(
)
-
itemBounds
.
XMost
(
)
+
distance
auPerDevPixel
)
)
;
hBounds
.
min
=
NSAppUnitsToFloatPixels
(
outer
.
X
(
)
-
inner
.
X
(
)
auPerDevPixel
)
;
if
(
appliedOffset
.
x
=
=
0
&
&
inner
.
X
(
)
>
0
)
{
appliedOffset
.
x
=
std
:
:
max
(
0
outer
.
X
(
)
)
-
inner
.
X
(
)
;
MOZ_ASSERT
(
appliedOffset
.
x
<
0
)
;
}
}
LayoutDeviceRect
bounds
=
LayoutDeviceRect
:
:
FromAppUnits
(
itemBounds
auPerDevPixel
)
;
wr
:
:
LayoutVector2D
applied
=
{
NSAppUnitsToFloatPixels
(
appliedOffset
.
x
auPerDevPixel
)
NSAppUnitsToFloatPixels
(
appliedOffset
.
y
auPerDevPixel
)
}
;
bool
needsProp
=
nsDisplayStickyPosition
:
:
ShouldGetStickyAnimationId
(
stickyFrame
)
;
Maybe
<
wr
:
:
WrAnimationProperty
>
prop
;
auto
displayItemKey
=
nsDisplayItem
:
:
GetPerFrameKey
(
0
0
DisplayItemType
:
:
TYPE_STICKY_POSITION
)
;
auto
spatialKey
=
wr
:
:
SpatialKey
(
uint64_t
(
stickyFrame
)
displayItemKey
wr
:
:
SpatialKeyKind
:
:
Sticky
)
;
if
(
needsProp
)
{
RefPtr
<
WebRenderAPZAnimationData
>
animationData
=
mManager
-
>
CommandBuilder
(
)
.
CreateOrRecycleWebRenderUserData
<
WebRenderAPZAnimationData
>
(
displayItemKey
stickyFrame
)
;
uint64_t
animationId
=
animationData
-
>
GetAnimationId
(
)
;
prop
.
emplace
(
)
;
prop
-
>
id
=
animationId
;
prop
-
>
key
=
spatialKey
;
prop
-
>
effect_type
=
wr
:
:
WrAnimationType
:
:
Transform
;
}
wr
:
:
WrSpatialId
spatialId
=
mBuilder
-
>
DefineStickyFrame
(
aASR
aParentSpatialId
wr
:
:
ToLayoutRect
(
bounds
)
topMargin
.
ptrOr
(
nullptr
)
rightMargin
.
ptrOr
(
nullptr
)
bottomMargin
.
ptrOr
(
nullptr
)
leftMargin
.
ptrOr
(
nullptr
)
vBounds
hBounds
applied
spatialKey
prop
.
ptrOr
(
nullptr
)
)
;
return
Some
(
spatialId
)
;
}
Maybe
<
wr
:
:
WrSpatialId
>
ClipManager
:
:
DefineSpatialNodes
(
nsDisplayListBuilder
*
aBuilder
const
ActiveScrolledRoot
*
aASR
nsDisplayItem
*
aItem
)
{
if
(
!
aASR
)
{
return
Nothing
(
)
;
}
ScrollableLayerGuid
:
:
ViewID
viewId
=
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
;
if
(
aASR
-
>
mKind
=
=
ActiveScrolledRoot
:
:
ASRKind
:
:
Scroll
)
{
viewId
=
aASR
-
>
GetViewId
(
)
;
Maybe
<
wr
:
:
WrSpatialId
>
space
=
mBuilder
-
>
GetScrollIdForDefinedScrollLayer
(
viewId
)
;
if
(
space
)
{
return
space
;
}
}
Maybe
<
wr
:
:
WrSpatialId
>
ancestorSpace
=
DefineSpatialNodes
(
aBuilder
aASR
-
>
mParent
aItem
)
;
if
(
aASR
-
>
mKind
=
=
ActiveScrolledRoot
:
:
ASRKind
:
:
Sticky
)
{
Maybe
<
wr
:
:
WrSpatialId
>
parent
=
ancestorSpace
.
map
(
[
this
]
(
wr
:
:
WrSpatialId
&
aId
)
{
return
SpatialIdAfterOverride
(
aId
)
;
}
)
;
return
ClipManager
:
:
DefineStickyNode
(
aBuilder
parent
aASR
aItem
)
;
}
MOZ_ASSERT
(
viewId
!
=
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
)
;
ScrollContainerFrame
*
scrollContainerFrame
=
aASR
-
>
ScrollFrame
(
)
;
Maybe
<
ScrollMetadata
>
metadata
=
scrollContainerFrame
-
>
ComputeScrollMetadata
(
mManager
aItem
-
>
Frame
(
)
aItem
-
>
ToReferenceFrame
(
)
)
;
if
(
!
metadata
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Expected
scroll
metadata
to
be
available
!
"
)
;
return
ancestorSpace
;
}
FrameMetrics
&
metrics
=
metadata
-
>
GetMetrics
(
)
;
if
(
!
metrics
.
IsScrollable
(
)
)
{
return
ancestorSpace
;
}
nsPoint
offset
=
scrollContainerFrame
-
>
GetOffsetToCrossDoc
(
aItem
-
>
Frame
(
)
)
+
aItem
-
>
ToReferenceFrame
(
)
;
int32_t
auPerDevPixel
=
aItem
-
>
Frame
(
)
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
scrollPort
=
scrollContainerFrame
-
>
GetScrollPortRect
(
)
+
offset
;
LayoutDeviceRect
clipBounds
=
LayoutDeviceRect
:
:
FromAppUnits
(
scrollPort
auPerDevPixel
)
;
LayoutDeviceRect
contentRect
=
metrics
.
GetExpandedScrollableRect
(
)
*
metrics
.
GetDevPixelsPerCSSPixel
(
)
;
contentRect
.
MoveTo
(
clipBounds
.
TopLeft
(
)
)
;
Maybe
<
wr
:
:
WrSpatialId
>
parent
=
ancestorSpace
;
if
(
parent
)
{
*
parent
=
SpatialIdAfterOverride
(
*
parent
)
;
}
const
bool
useRoundedOffset
=
StaticPrefs
:
:
apz_rounded_external_scroll_offset
(
)
;
LayoutDevicePoint
scrollOffset
=
useRoundedOffset
?
LayoutDevicePoint
:
:
FromAppUnitsRounded
(
scrollContainerFrame
-
>
GetScrollPosition
(
)
auPerDevPixel
)
:
LayoutDevicePoint
:
:
FromAppUnits
(
scrollContainerFrame
-
>
GetScrollPosition
(
)
auPerDevPixel
)
;
nsPresContext
*
presContext
=
aItem
-
>
Frame
(
)
-
>
PresContext
(
)
;
const
bool
hasScrollLinkedEffect
=
!
StaticPrefs
:
:
apz_disable_for_scroll_linked_effects
(
)
&
&
presContext
-
>
Document
(
)
-
>
HasScrollLinkedEffect
(
)
;
return
Some
(
mBuilder
-
>
DefineScrollLayer
(
viewId
parent
wr
:
:
ToLayoutRect
(
contentRect
)
wr
:
:
ToLayoutRect
(
clipBounds
)
wr
:
:
ToLayoutVector2D
(
scrollOffset
)
wr
:
:
ToWrAPZScrollGeneration
(
scrollContainerFrame
-
>
ScrollGenerationOnApz
(
)
)
wr
:
:
ToWrHasScrollLinkedEffect
(
hasScrollLinkedEffect
)
wr
:
:
SpatialKey
(
uint64_t
(
scrollContainerFrame
)
0
wr
:
:
SpatialKeyKind
:
:
Scroll
)
)
)
;
}
Maybe
<
wr
:
:
WrClipChainId
>
ClipManager
:
:
DefineClipChain
(
const
DisplayItemClipChain
*
aChain
int32_t
aAppUnitsPerDevPixel
)
{
MOZ_ASSERT
(
!
mCacheStack
.
empty
(
)
)
;
AutoTArray
<
wr
:
:
WrClipId
6
>
allClipIds
;
ClipIdMap
&
cache
=
mCacheStack
.
top
(
)
;
for
(
const
DisplayItemClipChain
*
chain
=
aChain
;
chain
;
chain
=
chain
-
>
mParent
)
{
MOZ_DIAGNOSTIC_ASSERT
(
chain
-
>
mOnStack
|
|
!
chain
-
>
mASR
|
|
chain
-
>
mASR
-
>
mFrame
)
;
if
(
!
chain
-
>
mClip
.
HasClip
(
)
)
{
continue
;
}
auto
emplaceResult
=
cache
.
try_emplace
(
chain
)
;
auto
&
chainClipIds
=
emplaceResult
.
first
-
>
second
;
if
(
!
emplaceResult
.
second
)
{
CLIP_LOG
(
"
cache
[
%
p
]
=
>
hit
\
n
"
chain
)
;
allClipIds
.
AppendElements
(
chainClipIds
)
;
continue
;
}
LayoutDeviceRect
clip
=
LayoutDeviceRect
:
:
FromAppUnits
(
chain
-
>
mClip
.
GetClipRect
(
)
aAppUnitsPerDevPixel
)
;
AutoTArray
<
wr
:
:
ComplexClipRegion
6
>
wrRoundedRects
;
chain
-
>
mClip
.
ToComplexClipRegions
(
aAppUnitsPerDevPixel
wrRoundedRects
)
;
wr
:
:
WrSpatialId
space
=
GetSpatialId
(
chain
-
>
mASR
)
;
space
=
SpatialIdAfterOverride
(
space
)
;
auto
rectClipId
=
mBuilder
-
>
DefineRectClip
(
Some
(
space
)
wr
:
:
ToLayoutRect
(
clip
)
)
;
CLIP_LOG
(
"
cache
[
%
p
]
<
=
%
zu
\
n
"
chain
rectClipId
.
id
)
;
chainClipIds
.
AppendElement
(
rectClipId
)
;
for
(
const
auto
&
complexClip
:
wrRoundedRects
)
{
auto
complexClipId
=
mBuilder
-
>
DefineRoundedRectClip
(
Some
(
space
)
complexClip
)
;
CLIP_LOG
(
"
cache
[
%
p
]
<
=
%
zu
\
n
"
chain
complexClipId
.
id
)
;
chainClipIds
.
AppendElement
(
complexClipId
)
;
}
allClipIds
.
AppendElements
(
chainClipIds
)
;
}
if
(
allClipIds
.
IsEmpty
(
)
)
{
return
Nothing
(
)
;
}
return
Some
(
mBuilder
-
>
DefineClipChain
(
allClipIds
)
)
;
}
ClipManager
:
:
~
ClipManager
(
)
{
MOZ_ASSERT
(
!
mBuilder
)
;
MOZ_ASSERT
(
mCacheStack
.
empty
(
)
)
;
MOZ_ASSERT
(
mItemClipStack
.
empty
(
)
)
;
}
ClipManager
:
:
ItemClips
:
:
ItemClips
(
const
ActiveScrolledRoot
*
aASR
const
DisplayItemClipChain
*
aChain
int32_t
aAppUnitsPerDevPixel
bool
aSeparateLeaf
)
:
mASR
(
aASR
)
mChain
(
aChain
)
mAppUnitsPerDevPixel
(
aAppUnitsPerDevPixel
)
mSeparateLeaf
(
aSeparateLeaf
)
{
mScrollId
=
wr
:
:
wr_root_scroll_node_id
(
)
;
}
void
ClipManager
:
:
ItemClips
:
:
UpdateSeparateLeaf
(
wr
:
:
DisplayListBuilder
&
aBuilder
int32_t
aAppUnitsPerDevPixel
)
{
Maybe
<
wr
:
:
LayoutRect
>
clipLeaf
;
if
(
mSeparateLeaf
)
{
MOZ_ASSERT
(
mChain
)
;
clipLeaf
.
emplace
(
wr
:
:
ToLayoutRect
(
LayoutDeviceRect
:
:
FromAppUnits
(
mChain
-
>
mClip
.
GetClipRect
(
)
aAppUnitsPerDevPixel
)
)
)
;
}
aBuilder
.
SetClipChainLeaf
(
clipLeaf
)
;
}
bool
ClipManager
:
:
ItemClips
:
:
HasSameInputs
(
const
ItemClips
&
aOther
)
{
if
(
mASR
!
=
aOther
.
mASR
|
|
mChain
!
=
aOther
.
mChain
|
|
mSeparateLeaf
!
=
aOther
.
mSeparateLeaf
)
{
return
false
;
}
if
(
mChain
&
&
mAppUnitsPerDevPixel
!
=
aOther
.
mAppUnitsPerDevPixel
)
{
return
false
;
}
return
true
;
}
wr
:
:
WrSpaceAndClipChain
ClipManager
:
:
ItemClips
:
:
GetSpaceAndClipChain
(
)
const
{
auto
spaceAndClipChain
=
wr
:
:
RootScrollNodeWithChain
(
)
;
spaceAndClipChain
.
space
=
mScrollId
;
if
(
mClipChainId
)
{
spaceAndClipChain
.
clip_chain
=
mClipChainId
-
>
id
;
}
return
spaceAndClipChain
;
}
}
}
