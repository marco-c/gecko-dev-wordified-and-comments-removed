#
include
"
mozilla
/
layers
/
ClipManager
.
h
"
#
include
"
DisplayItemClipChain
.
h
"
#
include
"
FrameMetrics
.
h
"
#
include
"
LayersLogging
.
h
"
#
include
"
mozilla
/
layers
/
StackingContextHelper
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
UnitTransforms
.
h
"
#
define
CLIP_LOG
(
.
.
.
)
namespace
mozilla
{
namespace
layers
{
ClipManager
:
:
ClipManager
(
)
:
mManager
(
nullptr
)
mBuilder
(
nullptr
)
{
}
void
ClipManager
:
:
BeginBuild
(
WebRenderLayerManager
*
aManager
wr
:
:
DisplayListBuilder
&
aBuilder
)
{
MOZ_ASSERT
(
!
mManager
)
;
mManager
=
aManager
;
MOZ_ASSERT
(
!
mBuilder
)
;
mBuilder
=
&
aBuilder
;
MOZ_ASSERT
(
mCacheStack
.
empty
(
)
)
;
mCacheStack
.
emplace
(
)
;
MOZ_ASSERT
(
mASROverride
.
empty
(
)
)
;
MOZ_ASSERT
(
mItemClipStack
.
empty
(
)
)
;
}
void
ClipManager
:
:
EndBuild
(
)
{
mBuilder
=
nullptr
;
mManager
=
nullptr
;
mCacheStack
.
pop
(
)
;
MOZ_ASSERT
(
mCacheStack
.
empty
(
)
)
;
MOZ_ASSERT
(
mASROverride
.
empty
(
)
)
;
MOZ_ASSERT
(
mItemClipStack
.
empty
(
)
)
;
}
void
ClipManager
:
:
BeginList
(
const
StackingContextHelper
&
aStackingContext
)
{
if
(
aStackingContext
.
AffectsClipPositioning
(
)
)
{
if
(
aStackingContext
.
ReferenceFrameId
(
)
)
{
PushOverrideForASR
(
mItemClipStack
.
empty
(
)
?
nullptr
:
mItemClipStack
.
top
(
)
.
mASR
aStackingContext
.
ReferenceFrameId
(
)
.
ref
(
)
)
;
}
else
{
mCacheStack
.
emplace
(
)
;
}
}
ItemClips
clips
(
nullptr
nullptr
false
)
;
if
(
!
mItemClipStack
.
empty
(
)
)
{
clips
.
CopyOutputsFrom
(
mItemClipStack
.
top
(
)
)
;
}
if
(
aStackingContext
.
ReferenceFrameId
(
)
)
{
clips
.
mScrollId
=
aStackingContext
.
ReferenceFrameId
(
)
.
ref
(
)
;
}
mItemClipStack
.
push
(
clips
)
;
}
void
ClipManager
:
:
EndList
(
const
StackingContextHelper
&
aStackingContext
)
{
MOZ_ASSERT
(
!
mItemClipStack
.
empty
(
)
)
;
mBuilder
-
>
SetClipChainLeaf
(
Nothing
(
)
)
;
mItemClipStack
.
pop
(
)
;
if
(
aStackingContext
.
AffectsClipPositioning
(
)
)
{
if
(
aStackingContext
.
ReferenceFrameId
(
)
)
{
PopOverrideForASR
(
mItemClipStack
.
empty
(
)
?
nullptr
:
mItemClipStack
.
top
(
)
.
mASR
)
;
}
else
{
MOZ_ASSERT
(
!
mCacheStack
.
empty
(
)
)
;
mCacheStack
.
pop
(
)
;
}
}
}
void
ClipManager
:
:
PushOverrideForASR
(
const
ActiveScrolledRoot
*
aASR
const
wr
:
:
WrSpatialId
&
aSpatialId
)
{
Maybe
<
wr
:
:
WrSpaceAndClip
>
spaceAndClip
=
GetScrollLayer
(
aASR
)
;
MOZ_ASSERT
(
spaceAndClip
.
isSome
(
)
)
;
CLIP_LOG
(
"
Pushing
%
p
override
%
zu
-
>
%
s
\
n
"
aASR
spaceAndClip
-
>
space
.
id
Stringify
(
aSpatialId
.
id
)
.
c_str
(
)
)
;
auto
it
=
mASROverride
.
insert
(
{
spaceAndClip
-
>
space
std
:
:
stack
<
wr
:
:
WrSpatialId
>
(
)
}
)
;
it
.
first
-
>
second
.
push
(
aSpatialId
)
;
mCacheStack
.
emplace
(
)
;
}
void
ClipManager
:
:
PopOverrideForASR
(
const
ActiveScrolledRoot
*
aASR
)
{
MOZ_ASSERT
(
!
mCacheStack
.
empty
(
)
)
;
mCacheStack
.
pop
(
)
;
Maybe
<
wr
:
:
WrSpaceAndClip
>
spaceAndClip
=
GetScrollLayer
(
aASR
)
;
MOZ_ASSERT
(
spaceAndClip
.
isSome
(
)
)
;
auto
it
=
mASROverride
.
find
(
spaceAndClip
-
>
space
)
;
CLIP_LOG
(
"
Popping
%
p
override
%
zu
-
>
%
s
\
n
"
aASR
spaceAndClip
-
>
space
.
id
Stringify
(
it
-
>
second
.
top
(
)
.
id
)
.
c_str
(
)
)
;
it
-
>
second
.
pop
(
)
;
if
(
it
-
>
second
.
empty
(
)
)
{
mASROverride
.
erase
(
it
)
;
}
}
wr
:
:
WrSpatialId
ClipManager
:
:
SpatialIdAfterOverride
(
const
wr
:
:
WrSpatialId
&
aSpatialId
)
{
auto
it
=
mASROverride
.
find
(
aSpatialId
)
;
if
(
it
=
=
mASROverride
.
end
(
)
)
{
return
aSpatialId
;
}
MOZ_ASSERT
(
!
it
-
>
second
.
empty
(
)
)
;
CLIP_LOG
(
"
Overriding
%
zu
with
%
s
\
n
"
aSpatialId
.
id
Stringify
(
it
-
>
second
.
top
(
)
.
id
)
.
c_str
(
)
)
;
return
it
-
>
second
.
top
(
)
;
}
wr
:
:
WrSpaceAndClipChain
ClipManager
:
:
SwitchItem
(
nsDisplayItem
*
aItem
)
{
const
DisplayItemClipChain
*
clip
=
aItem
-
>
GetClipChain
(
)
;
const
ActiveScrolledRoot
*
asr
=
aItem
-
>
GetActiveScrolledRoot
(
)
;
CLIP_LOG
(
"
processing
item
%
p
(
%
s
)
asr
%
p
\
n
"
aItem
DisplayItemTypeName
(
aItem
-
>
GetType
(
)
)
asr
)
;
DisplayItemType
type
=
aItem
-
>
GetType
(
)
;
if
(
type
=
=
DisplayItemType
:
:
TYPE_STICKY_POSITION
)
{
asr
=
static_cast
<
nsDisplayStickyPosition
*
>
(
aItem
)
-
>
GetContainerASR
(
)
;
}
bool
separateLeaf
=
false
;
if
(
clip
&
&
clip
-
>
mASR
=
=
asr
&
&
clip
-
>
mClip
.
GetRoundedRectCount
(
)
=
=
0
)
{
if
(
type
=
=
DisplayItemType
:
:
TYPE_TEXT
)
{
separateLeaf
=
!
aItem
-
>
Frame
(
)
-
>
StyleText
(
)
-
>
HasTextShadow
(
)
;
}
else
{
separateLeaf
=
aItem
-
>
GetChildren
(
)
=
=
nullptr
;
}
}
ItemClips
clips
(
asr
clip
separateLeaf
)
;
MOZ_ASSERT
(
!
mItemClipStack
.
empty
(
)
)
;
if
(
clips
.
HasSameInputs
(
mItemClipStack
.
top
(
)
)
)
{
CLIP_LOG
(
"
\
tearly
-
exit
for
%
p
\
n
"
aItem
)
;
return
mItemClipStack
.
top
(
)
.
GetSpaceAndClipChain
(
)
;
}
mItemClipStack
.
pop
(
)
;
int32_t
auPerDevPixel
;
if
(
type
=
=
DisplayItemType
:
:
TYPE_ZOOM
)
{
auPerDevPixel
=
static_cast
<
nsDisplayZoom
*
>
(
aItem
)
-
>
GetParentAppUnitsPerDevPixel
(
)
;
}
else
{
auPerDevPixel
=
aItem
-
>
Frame
(
)
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
}
if
(
separateLeaf
)
{
CLIP_LOG
(
"
\
tseparate
leaf
detected
ignoring
the
last
clip
\
n
"
)
;
clip
=
clip
-
>
mParent
;
}
const
ActiveScrolledRoot
*
leafmostASR
=
asr
;
if
(
clip
)
{
leafmostASR
=
ActiveScrolledRoot
:
:
PickDescendant
(
leafmostASR
clip
-
>
mASR
)
;
}
Maybe
<
wr
:
:
WrSpaceAndClip
>
leafmostId
=
DefineScrollLayers
(
leafmostASR
aItem
)
;
clips
.
mClipChainId
=
DefineClipChain
(
clip
auPerDevPixel
)
;
Maybe
<
wr
:
:
WrSpaceAndClip
>
spaceAndClip
=
GetScrollLayer
(
asr
)
;
MOZ_ASSERT
(
spaceAndClip
.
isSome
(
)
)
;
clips
.
mScrollId
=
SpatialIdAfterOverride
(
spaceAndClip
-
>
space
)
;
CLIP_LOG
(
"
\
tassigning
%
d
-
>
%
d
\
n
"
(
int
)
spaceAndClip
-
>
space
.
id
(
int
)
clips
.
mScrollId
.
id
)
;
clips
.
UpdateSeparateLeaf
(
*
mBuilder
auPerDevPixel
)
;
auto
spaceAndClipChain
=
clips
.
GetSpaceAndClipChain
(
)
;
mItemClipStack
.
push
(
clips
)
;
CLIP_LOG
(
"
done
setup
for
%
p
\
n
"
aItem
)
;
return
spaceAndClipChain
;
}
Maybe
<
wr
:
:
WrSpaceAndClip
>
ClipManager
:
:
GetScrollLayer
(
const
ActiveScrolledRoot
*
aASR
)
{
for
(
const
ActiveScrolledRoot
*
asr
=
aASR
;
asr
;
asr
=
asr
-
>
mParent
)
{
Maybe
<
wr
:
:
WrSpaceAndClip
>
spaceAndClip
=
mBuilder
-
>
GetScrollIdForDefinedScrollLayer
(
asr
-
>
GetViewId
(
)
)
;
if
(
spaceAndClip
)
{
return
spaceAndClip
;
}
}
Maybe
<
wr
:
:
WrSpaceAndClip
>
spaceAndClip
=
mBuilder
-
>
GetScrollIdForDefinedScrollLayer
(
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
)
;
MOZ_ASSERT
(
spaceAndClip
.
isSome
(
)
)
;
return
spaceAndClip
;
}
Maybe
<
wr
:
:
WrSpaceAndClip
>
ClipManager
:
:
DefineScrollLayers
(
const
ActiveScrolledRoot
*
aASR
nsDisplayItem
*
aItem
)
{
if
(
!
aASR
)
{
return
Nothing
(
)
;
}
ScrollableLayerGuid
:
:
ViewID
viewId
=
aASR
-
>
GetViewId
(
)
;
Maybe
<
wr
:
:
WrSpaceAndClip
>
spaceAndClip
=
mBuilder
-
>
GetScrollIdForDefinedScrollLayer
(
viewId
)
;
if
(
spaceAndClip
)
{
return
spaceAndClip
;
}
Maybe
<
wr
:
:
WrSpaceAndClip
>
ancestorSpaceAndClip
=
DefineScrollLayers
(
aASR
-
>
mParent
aItem
)
;
Maybe
<
ScrollMetadata
>
metadata
=
aASR
-
>
mScrollableFrame
-
>
ComputeScrollMetadata
(
mManager
aItem
-
>
ReferenceFrame
(
)
Nothing
(
)
nullptr
)
;
if
(
!
metadata
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Expected
scroll
metadata
to
be
available
!
"
)
;
return
ancestorSpaceAndClip
;
}
FrameMetrics
&
metrics
=
metadata
-
>
GetMetrics
(
)
;
if
(
!
metrics
.
IsScrollable
(
)
)
{
return
ancestorSpaceAndClip
;
}
LayoutDeviceRect
contentRect
=
metrics
.
GetExpandedScrollableRect
(
)
*
metrics
.
GetDevPixelsPerCSSPixel
(
)
;
LayoutDeviceRect
clipBounds
=
LayoutDeviceRect
:
:
FromUnknownRect
(
metrics
.
GetCompositionBounds
(
)
.
ToUnknownRect
(
)
)
;
contentRect
.
MoveTo
(
clipBounds
.
TopLeft
(
)
)
;
Maybe
<
wr
:
:
WrSpaceAndClip
>
parent
=
ancestorSpaceAndClip
;
if
(
parent
)
{
parent
-
>
space
=
SpatialIdAfterOverride
(
parent
-
>
space
)
;
}
LayoutDevicePoint
scrollOffset
=
metrics
.
GetScrollOffset
(
)
*
metrics
.
GetDevPixelsPerCSSPixel
(
)
;
return
Some
(
mBuilder
-
>
DefineScrollLayer
(
viewId
parent
wr
:
:
ToRoundedLayoutRect
(
contentRect
)
wr
:
:
ToRoundedLayoutRect
(
clipBounds
)
wr
:
:
ToLayoutPoint
(
scrollOffset
)
)
)
;
}
Maybe
<
wr
:
:
WrClipChainId
>
ClipManager
:
:
DefineClipChain
(
const
DisplayItemClipChain
*
aChain
int32_t
aAppUnitsPerDevPixel
)
{
AutoTArray
<
wr
:
:
WrClipId
6
>
clipIds
;
for
(
const
DisplayItemClipChain
*
chain
=
aChain
;
chain
;
chain
=
chain
-
>
mParent
)
{
ClipIdMap
&
cache
=
mCacheStack
.
top
(
)
;
auto
it
=
cache
.
find
(
chain
)
;
if
(
it
!
=
cache
.
end
(
)
)
{
CLIP_LOG
(
"
cache
[
%
p
]
=
>
%
zu
\
n
"
chain
it
-
>
second
.
id
)
;
clipIds
.
AppendElement
(
it
-
>
second
)
;
continue
;
}
if
(
!
chain
-
>
mClip
.
HasClip
(
)
)
{
continue
;
}
LayoutDeviceRect
clip
=
LayoutDeviceRect
:
:
FromAppUnits
(
chain
-
>
mClip
.
GetClipRect
(
)
aAppUnitsPerDevPixel
)
;
nsTArray
<
wr
:
:
ComplexClipRegion
>
wrRoundedRects
;
chain
-
>
mClip
.
ToComplexClipRegions
(
aAppUnitsPerDevPixel
wrRoundedRects
)
;
Maybe
<
wr
:
:
WrSpaceAndClip
>
spaceAndClip
=
GetScrollLayer
(
chain
-
>
mASR
)
;
MOZ_ASSERT
(
spaceAndClip
.
isSome
(
)
)
;
spaceAndClip
-
>
space
=
SpatialIdAfterOverride
(
spaceAndClip
-
>
space
)
;
wr
:
:
WrClipId
clipId
=
mBuilder
-
>
DefineClip
(
spaceAndClip
wr
:
:
ToRoundedLayoutRect
(
clip
)
&
wrRoundedRects
)
;
clipIds
.
AppendElement
(
clipId
)
;
cache
[
chain
]
=
clipId
;
CLIP_LOG
(
"
cache
[
%
p
]
<
=
%
zu
\
n
"
chain
clipId
.
id
)
;
}
if
(
clipIds
.
IsEmpty
(
)
)
{
return
Nothing
(
)
;
}
return
Some
(
mBuilder
-
>
DefineClipChain
(
clipIds
)
)
;
}
ClipManager
:
:
~
ClipManager
(
)
{
MOZ_ASSERT
(
!
mBuilder
)
;
MOZ_ASSERT
(
mCacheStack
.
empty
(
)
)
;
MOZ_ASSERT
(
mItemClipStack
.
empty
(
)
)
;
}
ClipManager
:
:
ItemClips
:
:
ItemClips
(
const
ActiveScrolledRoot
*
aASR
const
DisplayItemClipChain
*
aChain
bool
aSeparateLeaf
)
:
mASR
(
aASR
)
mChain
(
aChain
)
mSeparateLeaf
(
aSeparateLeaf
)
{
mScrollId
=
wr
:
:
wr_root_scroll_node_id
(
)
;
}
void
ClipManager
:
:
ItemClips
:
:
UpdateSeparateLeaf
(
wr
:
:
DisplayListBuilder
&
aBuilder
int32_t
aAppUnitsPerDevPixel
)
{
Maybe
<
wr
:
:
LayoutRect
>
clipLeaf
;
if
(
mSeparateLeaf
)
{
MOZ_ASSERT
(
mChain
)
;
clipLeaf
.
emplace
(
wr
:
:
ToRoundedLayoutRect
(
LayoutDeviceRect
:
:
FromAppUnits
(
mChain
-
>
mClip
.
GetClipRect
(
)
aAppUnitsPerDevPixel
)
)
)
;
}
aBuilder
.
SetClipChainLeaf
(
clipLeaf
)
;
}
bool
ClipManager
:
:
ItemClips
:
:
HasSameInputs
(
const
ItemClips
&
aOther
)
{
return
mASR
=
=
aOther
.
mASR
&
&
mChain
=
=
aOther
.
mChain
&
&
mSeparateLeaf
=
=
aOther
.
mSeparateLeaf
;
}
void
ClipManager
:
:
ItemClips
:
:
CopyOutputsFrom
(
const
ItemClips
&
aOther
)
{
mScrollId
=
aOther
.
mScrollId
;
mClipChainId
=
aOther
.
mClipChainId
;
}
wr
:
:
WrSpaceAndClipChain
ClipManager
:
:
ItemClips
:
:
GetSpaceAndClipChain
(
)
const
{
auto
spaceAndClipChain
=
wr
:
:
RootScrollNodeWithChain
(
)
;
spaceAndClipChain
.
space
=
mScrollId
;
if
(
mClipChainId
)
{
spaceAndClipChain
.
clip_chain
=
mClipChainId
-
>
id
;
}
return
spaceAndClipChain
;
}
}
}
