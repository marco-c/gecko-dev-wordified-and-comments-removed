#
include
"
mozilla
/
layers
/
RenderRootStateManager
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
namespace
mozilla
{
namespace
layers
{
void
RenderRootStateManager
:
:
AddRef
(
)
{
mLayerManager
-
>
AddRef
(
)
;
}
void
RenderRootStateManager
:
:
Release
(
)
{
mLayerManager
-
>
Release
(
)
;
}
WebRenderBridgeChild
*
RenderRootStateManager
:
:
WrBridge
(
)
const
{
return
mLayerManager
-
>
WrBridge
(
)
;
}
WebRenderCommandBuilder
&
RenderRootStateManager
:
:
CommandBuilder
(
)
{
return
mLayerManager
-
>
CommandBuilder
(
)
;
}
RenderRootStateManager
:
:
WebRenderUserDataRefTable
*
RenderRootStateManager
:
:
GetWebRenderUserDataTable
(
)
{
return
mLayerManager
-
>
GetWebRenderUserDataTable
(
)
;
}
wr
:
:
IpcResourceUpdateQueue
&
RenderRootStateManager
:
:
AsyncResourceUpdates
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
|
|
mRenderRoot
=
=
wr
:
:
RenderRoot
:
:
Default
)
;
if
(
!
mAsyncResourceUpdates
)
{
mAsyncResourceUpdates
.
emplace
(
WrBridge
(
)
mRenderRoot
)
;
RefPtr
<
Runnable
>
task
=
NewRunnableMethod
(
"
RenderRootStateManager
:
:
FlushAsyncResourceUpdates
"
this
&
RenderRootStateManager
:
:
FlushAsyncResourceUpdates
)
;
NS_DispatchToMainThread
(
task
.
forget
(
)
)
;
}
return
mAsyncResourceUpdates
.
ref
(
)
;
}
void
RenderRootStateManager
:
:
Destroy
(
)
{
ClearAsyncAnimations
(
)
;
if
(
WrBridge
(
)
)
{
DiscardLocalImages
(
)
;
mDiscardedCompositorAnimationsIds
.
Clear
(
)
;
}
mActiveCompositorAnimationIds
.
clear
(
)
;
mDestroyed
=
true
;
}
void
RenderRootStateManager
:
:
FlushAsyncResourceUpdates
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mAsyncResourceUpdates
)
{
return
;
}
if
(
!
IsDestroyed
(
)
&
&
WrBridge
(
)
)
{
WrBridge
(
)
-
>
UpdateResources
(
mAsyncResourceUpdates
.
ref
(
)
mRenderRoot
)
;
}
mAsyncResourceUpdates
.
reset
(
)
;
}
void
RenderRootStateManager
:
:
AddImageKeyForDiscard
(
wr
:
:
ImageKey
key
)
{
mImageKeysToDelete
.
AppendElement
(
key
)
;
}
void
RenderRootStateManager
:
:
AddBlobImageKeyForDiscard
(
wr
:
:
BlobImageKey
key
)
{
mBlobImageKeysToDelete
.
AppendElement
(
key
)
;
}
void
RenderRootStateManager
:
:
DiscardImagesInTransaction
(
wr
:
:
IpcResourceUpdateQueue
&
aResources
)
{
for
(
const
auto
&
key
:
mImageKeysToDelete
)
{
aResources
.
DeleteImage
(
key
)
;
}
for
(
const
auto
&
key
:
mBlobImageKeysToDelete
)
{
aResources
.
DeleteBlobImage
(
key
)
;
}
mImageKeysToDelete
.
Clear
(
)
;
mBlobImageKeysToDelete
.
Clear
(
)
;
}
void
RenderRootStateManager
:
:
DiscardLocalImages
(
)
{
mImageKeysToDelete
.
Clear
(
)
;
mBlobImageKeysToDelete
.
Clear
(
)
;
}
void
RenderRootStateManager
:
:
ClearCachedResources
(
)
{
mActiveCompositorAnimationIds
.
clear
(
)
;
mDiscardedCompositorAnimationsIds
.
Clear
(
)
;
}
void
RenderRootStateManager
:
:
AddActiveCompositorAnimationId
(
uint64_t
aId
)
{
mActiveCompositorAnimationIds
.
insert
(
aId
)
;
}
void
RenderRootStateManager
:
:
AddCompositorAnimationsIdForDiscard
(
uint64_t
aId
)
{
if
(
mActiveCompositorAnimationIds
.
erase
(
aId
)
)
{
mDiscardedCompositorAnimationsIds
.
AppendElement
(
aId
)
;
}
}
void
RenderRootStateManager
:
:
DiscardCompositorAnimations
(
)
{
if
(
WrBridge
(
)
-
>
IPCOpen
(
)
&
&
!
mDiscardedCompositorAnimationsIds
.
IsEmpty
(
)
)
{
WrBridge
(
)
-
>
SendDeleteCompositorAnimations
(
mDiscardedCompositorAnimationsIds
)
;
}
mDiscardedCompositorAnimationsIds
.
Clear
(
)
;
}
void
RenderRootStateManager
:
:
RegisterAsyncAnimation
(
const
wr
:
:
ImageKey
&
aKey
SharedSurfacesAnimation
*
aAnimation
)
{
mAsyncAnimations
.
insert
(
std
:
:
make_pair
(
wr
:
:
AsUint64
(
aKey
)
aAnimation
)
)
;
}
void
RenderRootStateManager
:
:
DeregisterAsyncAnimation
(
const
wr
:
:
ImageKey
&
aKey
)
{
mAsyncAnimations
.
erase
(
wr
:
:
AsUint64
(
aKey
)
)
;
}
void
RenderRootStateManager
:
:
ClearAsyncAnimations
(
)
{
for
(
const
auto
&
i
:
mAsyncAnimations
)
{
i
.
second
-
>
Invalidate
(
this
)
;
}
mAsyncAnimations
.
clear
(
)
;
}
void
RenderRootStateManager
:
:
WrReleasedImages
(
const
nsTArray
<
wr
:
:
ExternalImageKeyPair
>
&
aPairs
)
{
for
(
const
auto
&
pair
:
aPairs
)
{
auto
i
=
mAsyncAnimations
.
find
(
wr
:
:
AsUint64
(
pair
.
key
)
)
;
if
(
i
!
=
mAsyncAnimations
.
end
(
)
)
{
i
-
>
second
-
>
ReleasePreviousFrame
(
this
pair
.
id
)
;
}
}
}
void
RenderRootStateManager
:
:
AddWebRenderParentCommand
(
const
WebRenderParentCommand
&
aCmd
)
{
WrBridge
(
)
-
>
AddWebRenderParentCommand
(
aCmd
mRenderRoot
)
;
}
void
RenderRootStateManager
:
:
UpdateResources
(
wr
:
:
IpcResourceUpdateQueue
&
aResources
)
{
WrBridge
(
)
-
>
UpdateResources
(
aResources
mRenderRoot
)
;
}
void
RenderRootStateManager
:
:
AddPipelineIdForAsyncCompositable
(
const
wr
:
:
PipelineId
&
aPipelineId
const
CompositableHandle
&
aHandle
)
{
WrBridge
(
)
-
>
AddPipelineIdForAsyncCompositable
(
aPipelineId
aHandle
mRenderRoot
)
;
}
void
RenderRootStateManager
:
:
AddPipelineIdForCompositable
(
const
wr
:
:
PipelineId
&
aPipelineId
const
CompositableHandle
&
aHandle
)
{
WrBridge
(
)
-
>
AddPipelineIdForCompositable
(
aPipelineId
aHandle
mRenderRoot
)
;
}
void
RenderRootStateManager
:
:
RemovePipelineIdForCompositable
(
const
wr
:
:
PipelineId
&
aPipelineId
)
{
WrBridge
(
)
-
>
RemovePipelineIdForCompositable
(
aPipelineId
mRenderRoot
)
;
}
void
RenderRootStateManager
:
:
ReleaseTextureOfImage
(
const
wr
:
:
ImageKey
&
aKey
)
{
WrBridge
(
)
-
>
ReleaseTextureOfImage
(
aKey
mRenderRoot
)
;
}
Maybe
<
wr
:
:
FontInstanceKey
>
RenderRootStateManager
:
:
GetFontKeyForScaledFont
(
gfx
:
:
ScaledFont
*
aScaledFont
wr
:
:
IpcResourceUpdateQueue
*
aResources
)
{
return
WrBridge
(
)
-
>
GetFontKeyForScaledFont
(
aScaledFont
mRenderRoot
aResources
)
;
}
Maybe
<
wr
:
:
FontKey
>
RenderRootStateManager
:
:
GetFontKeyForUnscaledFont
(
gfx
:
:
UnscaledFont
*
aUnscaledFont
wr
:
:
IpcResourceUpdateQueue
*
aResources
)
{
return
WrBridge
(
)
-
>
GetFontKeyForUnscaledFont
(
aUnscaledFont
mRenderRoot
aResources
)
;
}
}
}
