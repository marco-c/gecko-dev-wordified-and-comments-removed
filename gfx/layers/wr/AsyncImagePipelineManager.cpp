#
include
"
AsyncImagePipelineManager
.
h
"
#
include
<
algorithm
>
#
include
<
iterator
>
#
include
"
CompositableHost
.
h
"
#
include
"
gfxEnv
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
layers
/
AsyncImagePipelineOp
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
Fence
.
h
"
#
include
"
mozilla
/
layers
/
RemoteTextureHostWrapper
.
h
"
#
include
"
mozilla
/
layers
/
SharedSurfacesParent
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderImageHost
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderTextureHost
.
h
"
#
include
"
mozilla
/
webrender
/
RenderTextureHost
.
h
"
#
include
"
mozilla
/
webrender
/
RenderThread
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderTypes
.
h
"
namespace
mozilla
{
namespace
layers
{
AsyncImagePipelineManager
:
:
ForwardingExternalImage
:
:
~
ForwardingExternalImage
(
)
{
DebugOnly
<
bool
>
released
=
SharedSurfacesParent
:
:
Release
(
mImageId
)
;
MOZ_ASSERT
(
released
)
;
}
AsyncImagePipelineManager
:
:
AsyncImagePipeline
:
:
AsyncImagePipeline
(
wr
:
:
PipelineId
aPipelineId
layers
:
:
WebRenderBackend
aBackend
WebRenderImageHost
*
aImageHost
)
:
mInitialised
(
false
)
mIsChanged
(
false
)
mUseExternalImage
(
false
)
mRotation
(
wr
:
:
WrRotation
:
:
Degree0
)
mFilter
(
wr
:
:
ImageRendering
:
:
Auto
)
mMixBlendMode
(
wr
:
:
MixBlendMode
:
:
Normal
)
mImageHost
(
aImageHost
)
mDLBuilder
(
aPipelineId
aBackend
)
{
}
AsyncImagePipelineManager
:
:
AsyncImagePipelineManager
(
RefPtr
<
wr
:
:
WebRenderAPI
>
&
&
aApi
bool
aUseCompositorWnd
)
:
mApi
(
aApi
)
mUseCompositorWnd
(
aUseCompositorWnd
)
mIdNamespace
(
mApi
-
>
GetNamespace
(
)
)
mUseTripleBuffering
(
mApi
-
>
GetUseTripleBuffering
(
)
)
mResourceId
(
0
)
mAsyncImageEpoch
{
0
}
mWillGenerateFrame
(
false
)
mDestroyed
(
false
)
#
ifdef
XP_WIN
mUseWebRenderDCompVideoHwOverlayWin
(
gfx
:
:
gfxVars
:
:
UseWebRenderDCompVideoHwOverlayWin
(
)
)
mUseWebRenderDCompVideoSwOverlayWin
(
gfx
:
:
gfxVars
:
:
UseWebRenderDCompVideoSwOverlayWin
(
)
)
#
endif
mRenderSubmittedUpdatesLock
(
"
SubmittedUpdatesLock
"
)
mLastCompletedFrameId
(
0
)
{
MOZ_COUNT_CTOR
(
AsyncImagePipelineManager
)
;
}
AsyncImagePipelineManager
:
:
~
AsyncImagePipelineManager
(
)
{
MOZ_COUNT_DTOR
(
AsyncImagePipelineManager
)
;
}
void
AsyncImagePipelineManager
:
:
Destroy
(
)
{
MOZ_ASSERT
(
!
mDestroyed
)
;
mApi
=
nullptr
;
mPipelineTexturesHolders
.
Clear
(
)
;
mDestroyed
=
true
;
}
wr
:
:
ExternalImageId
AsyncImagePipelineManager
:
:
GetNextExternalImageId
(
)
{
static
std
:
:
atomic
<
uint64_t
>
sCounter
=
0
;
uint64_t
id
=
+
+
sCounter
;
MOZ_RELEASE_ASSERT
(
id
!
=
UINT32_MAX
)
;
return
wr
:
:
ToExternalImageId
(
id
)
;
}
void
AsyncImagePipelineManager
:
:
SetWillGenerateFrame
(
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
mWillGenerateFrame
=
true
;
}
bool
AsyncImagePipelineManager
:
:
GetAndResetWillGenerateFrame
(
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
bool
ret
=
mWillGenerateFrame
;
mWillGenerateFrame
=
false
;
return
ret
;
}
void
AsyncImagePipelineManager
:
:
AddPipeline
(
const
wr
:
:
PipelineId
&
aPipelineId
WebRenderBridgeParent
*
aWrBridge
)
{
if
(
mDestroyed
)
{
return
;
}
mPipelineTexturesHolders
.
WithEntryHandle
(
wr
:
:
AsUint64
(
aPipelineId
)
[
&
]
(
auto
&
&
holder
)
{
if
(
holder
)
{
MOZ_ASSERT
(
holder
.
Data
(
)
-
>
mDestroyedEpoch
.
isSome
(
)
)
;
holder
.
Data
(
)
-
>
mDestroyedEpoch
=
Nothing
(
)
;
holder
.
Data
(
)
-
>
mWrBridge
=
aWrBridge
;
return
;
}
holder
.
Insert
(
MakeUnique
<
PipelineTexturesHolder
>
(
)
)
-
>
mWrBridge
=
aWrBridge
;
}
)
;
}
void
AsyncImagePipelineManager
:
:
RemovePipeline
(
const
wr
:
:
PipelineId
&
aPipelineId
const
wr
:
:
Epoch
&
aEpoch
)
{
if
(
mDestroyed
)
{
return
;
}
PipelineTexturesHolder
*
holder
=
mPipelineTexturesHolders
.
Get
(
wr
:
:
AsUint64
(
aPipelineId
)
)
;
MOZ_ASSERT
(
holder
)
;
if
(
!
holder
)
{
return
;
}
holder
-
>
mWrBridge
=
nullptr
;
holder
-
>
mDestroyedEpoch
=
Some
(
aEpoch
)
;
}
WebRenderBridgeParent
*
AsyncImagePipelineManager
:
:
GetWrBridge
(
const
wr
:
:
PipelineId
&
aPipelineId
)
{
if
(
mDestroyed
)
{
return
nullptr
;
}
PipelineTexturesHolder
*
holder
=
mPipelineTexturesHolders
.
Get
(
wr
:
:
AsUint64
(
aPipelineId
)
)
;
if
(
!
holder
)
{
return
nullptr
;
}
if
(
holder
-
>
mWrBridge
)
{
MOZ_ASSERT
(
holder
-
>
mDestroyedEpoch
.
isNothing
(
)
)
;
return
holder
-
>
mWrBridge
;
}
return
nullptr
;
}
void
AsyncImagePipelineManager
:
:
AddAsyncImagePipeline
(
const
wr
:
:
PipelineId
&
aPipelineId
WebRenderImageHost
*
aImageHost
)
{
if
(
mDestroyed
)
{
return
;
}
MOZ_ASSERT
(
aImageHost
)
;
uint64_t
id
=
wr
:
:
AsUint64
(
aPipelineId
)
;
MOZ_ASSERT
(
!
mAsyncImagePipelines
.
Contains
(
id
)
)
;
auto
holder
=
MakeUnique
<
AsyncImagePipeline
>
(
aPipelineId
mApi
-
>
GetBackendType
(
)
aImageHost
)
;
mAsyncImagePipelines
.
InsertOrUpdate
(
id
std
:
:
move
(
holder
)
)
;
AddPipeline
(
aPipelineId
nullptr
)
;
}
void
AsyncImagePipelineManager
:
:
RemoveAsyncImagePipeline
(
const
wr
:
:
PipelineId
&
aPipelineId
AsyncImagePipelineOps
*
aPendingOps
wr
:
:
TransactionBuilder
&
aTxn
)
{
if
(
mDestroyed
)
{
return
;
}
if
(
aPendingOps
)
{
aPendingOps
-
>
mList
.
emplace
(
AsyncImagePipelineOp
:
:
RemoveAsyncImagePipeline
(
this
aPipelineId
)
)
;
return
;
}
uint64_t
id
=
wr
:
:
AsUint64
(
aPipelineId
)
;
if
(
auto
entry
=
mAsyncImagePipelines
.
Lookup
(
id
)
)
{
const
auto
&
holder
=
entry
.
Data
(
)
;
wr
:
:
Epoch
epoch
=
GetNextImageEpoch
(
)
;
aTxn
.
ClearDisplayList
(
epoch
aPipelineId
)
;
for
(
wr
:
:
ImageKey
key
:
holder
-
>
mKeys
)
{
aTxn
.
DeleteImage
(
key
)
;
}
entry
.
Remove
(
)
;
RemovePipeline
(
aPipelineId
epoch
)
;
}
}
void
AsyncImagePipelineManager
:
:
UpdateAsyncImagePipeline
(
const
wr
:
:
PipelineId
&
aPipelineId
const
LayoutDeviceRect
&
aScBounds
const
wr
:
:
WrRotation
aRotation
const
wr
:
:
ImageRendering
&
aFilter
const
wr
:
:
MixBlendMode
&
aMixBlendMode
)
{
if
(
mDestroyed
)
{
return
;
}
AsyncImagePipeline
*
pipeline
=
mAsyncImagePipelines
.
Get
(
wr
:
:
AsUint64
(
aPipelineId
)
)
;
if
(
!
pipeline
)
{
return
;
}
pipeline
-
>
mInitialised
=
true
;
pipeline
-
>
Update
(
aScBounds
aRotation
aFilter
aMixBlendMode
)
;
}
Maybe
<
TextureHost
:
:
ResourceUpdateOp
>
AsyncImagePipelineManager
:
:
UpdateImageKeys
(
const
wr
:
:
Epoch
&
aEpoch
const
wr
:
:
PipelineId
&
aPipelineId
AsyncImagePipeline
*
aPipeline
TextureHost
*
aTexture
nsTArray
<
wr
:
:
ImageKey
>
&
aKeys
wr
:
:
TransactionBuilder
&
aSceneBuilderTxn
wr
:
:
TransactionBuilder
&
aMaybeFastTxn
)
{
MOZ_ASSERT
(
aKeys
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aPipeline
)
;
TextureHost
*
previousTexture
=
aPipeline
-
>
mCurrentTexture
.
get
(
)
;
if
(
aTexture
=
=
previousTexture
)
{
aKeys
=
aPipeline
-
>
mKeys
.
Clone
(
)
;
return
Nothing
(
)
;
}
auto
*
wrapper
=
aTexture
?
aTexture
-
>
AsRemoteTextureHostWrapper
(
)
:
nullptr
;
if
(
wrapper
&
&
!
aPipeline
-
>
mImageHost
-
>
GetAsyncRef
(
)
)
{
RemoteTextureMap
:
:
Get
(
)
-
>
GetRemoteTexture
(
wrapper
)
;
}
if
(
!
aTexture
|
|
aTexture
-
>
NumSubTextures
(
)
=
=
0
)
{
aKeys
=
aPipeline
-
>
mKeys
.
Clone
(
)
;
return
Nothing
(
)
;
}
aPipeline
-
>
mCurrentTexture
=
aTexture
;
WebRenderTextureHost
*
wrTexture
=
aTexture
-
>
AsWebRenderTextureHost
(
)
;
MOZ_ASSERT
(
wrTexture
)
;
if
(
!
wrTexture
)
{
gfxCriticalNote
<
<
"
WebRenderTextureHost
is
not
used
"
;
}
bool
useExternalImage
=
!
!
wrTexture
;
aPipeline
-
>
mUseExternalImage
=
useExternalImage
;
auto
numKeys
=
useExternalImage
?
aTexture
-
>
NumSubTextures
(
)
:
1
;
MOZ_ASSERT
(
numKeys
>
0
)
;
auto
backend
=
aSceneBuilderTxn
.
GetBackendType
(
)
;
bool
videoOverlayDisabled
=
false
;
RefPtr
<
wr
:
:
RenderTextureHostUsageInfo
>
usageInfo
;
const
bool
checkVideoOverlayDisabled
=
!
!
aTexture
-
>
AsDXGITextureHostD3D11
(
)
;
if
(
checkVideoOverlayDisabled
)
{
auto
externalImageKey
=
wrTexture
-
>
GetExternalImageKey
(
)
;
usageInfo
=
wr
:
:
RenderThread
:
:
Get
(
)
-
>
GetOrMergeUsageInfo
(
externalImageKey
aPipeline
-
>
mImageHost
-
>
GetRenderTextureHostUsageInfo
(
)
)
;
if
(
usageInfo
)
{
videoOverlayDisabled
=
usageInfo
-
>
VideoOverlayDisabled
(
)
;
aPipeline
-
>
mImageHost
-
>
SetRenderTextureHostUsageInfo
(
usageInfo
)
;
}
}
MOZ_ASSERT_IF
(
aPipeline
-
>
mVideoOverlayDisabled
videoOverlayDisabled
)
;
bool
canUpdate
=
!
!
previousTexture
&
&
previousTexture
-
>
GetTextureHostType
(
)
=
=
aTexture
-
>
GetTextureHostType
(
)
&
&
previousTexture
-
>
GetSize
(
)
=
=
aTexture
-
>
GetSize
(
)
&
&
previousTexture
-
>
GetFormat
(
)
=
=
aTexture
-
>
GetFormat
(
)
&
&
previousTexture
-
>
GetColorDepth
(
)
=
=
aTexture
-
>
GetColorDepth
(
)
&
&
previousTexture
-
>
NeedsYFlip
(
)
=
=
aTexture
-
>
NeedsYFlip
(
)
&
&
previousTexture
-
>
SupportsExternalCompositing
(
backend
)
=
=
aTexture
-
>
SupportsExternalCompositing
(
backend
)
&
&
aPipeline
-
>
mKeys
.
Length
(
)
=
=
numKeys
&
&
aPipeline
-
>
mVideoOverlayDisabled
=
=
videoOverlayDisabled
;
if
(
videoOverlayDisabled
)
{
MOZ_ASSERT
(
usageInfo
)
;
aPipeline
-
>
mVideoOverlayDisabled
=
true
;
}
if
(
!
canUpdate
)
{
for
(
auto
key
:
aPipeline
-
>
mKeys
)
{
aSceneBuilderTxn
.
DeleteImage
(
key
)
;
}
aPipeline
-
>
mKeys
.
Clear
(
)
;
for
(
uint32_t
i
=
0
;
i
<
numKeys
;
+
+
i
)
{
aPipeline
-
>
mKeys
.
AppendElement
(
GenerateImageKey
(
)
)
;
}
}
aKeys
=
aPipeline
-
>
mKeys
.
Clone
(
)
;
auto
op
=
canUpdate
?
TextureHost
:
:
UPDATE_IMAGE
:
TextureHost
:
:
ADD_IMAGE
;
if
(
!
useExternalImage
)
{
return
UpdateWithoutExternalImage
(
aTexture
aKeys
[
0
]
op
aMaybeFastTxn
)
;
}
wrTexture
-
>
MaybeNotifyForUse
(
aMaybeFastTxn
)
;
Range
<
wr
:
:
ImageKey
>
keys
(
&
aKeys
[
0
]
aKeys
.
Length
(
)
)
;
auto
externalImageKey
=
wrTexture
-
>
GetExternalImageKey
(
)
;
wrTexture
-
>
PushResourceUpdates
(
aMaybeFastTxn
op
keys
externalImageKey
)
;
return
Some
(
op
)
;
}
Maybe
<
TextureHost
:
:
ResourceUpdateOp
>
AsyncImagePipelineManager
:
:
UpdateWithoutExternalImage
(
TextureHost
*
aTexture
wr
:
:
ImageKey
aKey
TextureHost
:
:
ResourceUpdateOp
aOp
wr
:
:
TransactionBuilder
&
aTxn
)
{
MOZ_ASSERT
(
aTexture
)
;
RefPtr
<
gfx
:
:
DataSourceSurface
>
dSurf
=
aTexture
-
>
GetAsSurface
(
)
;
if
(
!
dSurf
)
{
NS_ERROR
(
"
TextureHost
does
not
return
DataSourceSurface
"
)
;
return
Nothing
(
)
;
}
gfx
:
:
DataSourceSurface
:
:
MappedSurface
map
;
if
(
!
dSurf
-
>
Map
(
gfx
:
:
DataSourceSurface
:
:
MapType
:
:
READ
&
map
)
)
{
NS_ERROR
(
"
DataSourceSurface
failed
to
map
"
)
;
return
Nothing
(
)
;
}
gfx
:
:
IntSize
size
=
dSurf
-
>
GetSize
(
)
;
wr
:
:
ImageDescriptor
descriptor
(
size
map
.
mStride
dSurf
-
>
GetFormat
(
)
)
;
wr
:
:
Vec
<
uint8_t
>
bytes
;
bytes
.
PushBytes
(
Range
<
uint8_t
>
(
map
.
mData
size
.
height
*
map
.
mStride
)
)
;
if
(
aOp
=
=
TextureHost
:
:
UPDATE_IMAGE
)
{
aTxn
.
UpdateImageBuffer
(
aKey
descriptor
bytes
)
;
}
else
{
aTxn
.
AddImage
(
aKey
descriptor
bytes
)
;
}
dSurf
-
>
Unmap
(
)
;
return
Some
(
aOp
)
;
}
void
AsyncImagePipelineManager
:
:
ApplyAsyncImagesOfImageBridge
(
wr
:
:
TransactionBuilder
&
aSceneBuilderTxn
wr
:
:
TransactionBuilder
&
aFastTxn
)
{
if
(
mDestroyed
|
|
mAsyncImagePipelines
.
Count
(
)
=
=
0
)
{
return
;
}
#
ifdef
XP_WIN
bool
isChanged
=
(
mUseWebRenderDCompVideoHwOverlayWin
!
=
gfx
:
:
gfxVars
:
:
UseWebRenderDCompVideoHwOverlayWin
(
)
)
|
|
(
mUseWebRenderDCompVideoSwOverlayWin
!
=
gfx
:
:
gfxVars
:
:
UseWebRenderDCompVideoSwOverlayWin
(
)
)
;
if
(
isChanged
)
{
mUseWebRenderDCompVideoHwOverlayWin
=
gfx
:
:
gfxVars
:
:
UseWebRenderDCompVideoHwOverlayWin
(
)
;
mUseWebRenderDCompVideoSwOverlayWin
=
gfx
:
:
gfxVars
:
:
UseWebRenderDCompVideoSwOverlayWin
(
)
;
}
#
endif
wr
:
:
Epoch
epoch
=
GetNextImageEpoch
(
)
;
for
(
const
auto
&
entry
:
mAsyncImagePipelines
)
{
wr
:
:
PipelineId
pipelineId
=
wr
:
:
AsPipelineId
(
entry
.
GetKey
(
)
)
;
AsyncImagePipeline
*
pipeline
=
entry
.
GetWeak
(
)
;
#
ifdef
XP_WIN
if
(
isChanged
)
{
pipeline
-
>
mIsChanged
=
true
;
}
#
endif
if
(
!
pipeline
-
>
mImageHost
-
>
GetAsyncRef
(
)
)
{
continue
;
}
TextureHost
*
texture
=
pipeline
-
>
mImageHost
-
>
GetAsTextureHostForComposite
(
this
)
;
ApplyAsyncImageForPipeline
(
epoch
pipelineId
pipeline
texture
aSceneBuilderTxn
aFastTxn
)
;
}
}
void
AsyncImagePipelineManager
:
:
ApplyAsyncImageForPipeline
(
const
wr
:
:
Epoch
&
aEpoch
const
wr
:
:
PipelineId
&
aPipelineId
AsyncImagePipeline
*
aPipeline
TextureHost
*
aTexture
wr
:
:
TransactionBuilder
&
aSceneBuilderTxn
wr
:
:
TransactionBuilder
&
aMaybeFastTxn
)
{
nsTArray
<
wr
:
:
ImageKey
>
keys
;
auto
op
=
UpdateImageKeys
(
aEpoch
aPipelineId
aPipeline
aTexture
keys
aSceneBuilderTxn
aMaybeFastTxn
)
;
bool
updateDisplayList
=
aPipeline
-
>
mInitialised
&
&
(
aPipeline
-
>
mIsChanged
|
|
op
=
=
Some
(
TextureHost
:
:
ADD_IMAGE
)
)
&
&
!
!
aPipeline
-
>
mCurrentTexture
;
if
(
!
updateDisplayList
)
{
aSceneBuilderTxn
.
UpdateEpoch
(
aPipelineId
aEpoch
)
;
if
(
aPipeline
-
>
mCurrentTexture
)
{
HoldExternalImage
(
aPipelineId
aEpoch
aPipeline
-
>
mCurrentTexture
)
;
}
return
;
}
aPipeline
-
>
mIsChanged
=
false
;
aPipeline
-
>
mDLBuilder
.
Begin
(
)
;
float
opacity
=
1
.
0f
;
wr
:
:
StackingContextParams
params
;
params
.
opacity
=
&
opacity
;
params
.
mix_blend_mode
=
aPipeline
-
>
mMixBlendMode
;
wr
:
:
WrComputedTransformData
computedTransform
;
computedTransform
.
vertical_flip
=
aPipeline
-
>
mCurrentTexture
&
&
aPipeline
-
>
mCurrentTexture
-
>
NeedsYFlip
(
)
;
computedTransform
.
scale_from
=
{
float
(
aPipeline
-
>
mCurrentTexture
-
>
GetSize
(
)
.
width
)
float
(
aPipeline
-
>
mCurrentTexture
-
>
GetSize
(
)
.
height
)
}
;
computedTransform
.
rotation
=
aPipeline
-
>
mRotation
;
computedTransform
.
key
=
wr
:
:
SpatialKey
(
aPipelineId
.
mNamespace
aPipelineId
.
mHandle
wr
:
:
SpatialKeyKind
:
:
APZ
)
;
params
.
computed_transform
=
&
computedTransform
;
Maybe
<
wr
:
:
WrSpatialId
>
referenceFrameId
=
aPipeline
-
>
mDLBuilder
.
PushStackingContext
(
params
wr
:
:
ToLayoutRect
(
aPipeline
-
>
mScBounds
)
wr
:
:
RasterSpace
:
:
Screen
(
)
)
;
Maybe
<
wr
:
:
SpaceAndClipChainHelper
>
spaceAndClipChainHelper
;
if
(
referenceFrameId
)
{
spaceAndClipChainHelper
.
emplace
(
aPipeline
-
>
mDLBuilder
referenceFrameId
.
ref
(
)
)
;
}
if
(
aPipeline
-
>
mCurrentTexture
&
&
!
keys
.
IsEmpty
(
)
)
{
LayoutDeviceRect
rect
(
0
0
aPipeline
-
>
mCurrentTexture
-
>
GetSize
(
)
.
width
aPipeline
-
>
mCurrentTexture
-
>
GetSize
(
)
.
height
)
;
if
(
aPipeline
-
>
mUseExternalImage
)
{
MOZ_ASSERT
(
aPipeline
-
>
mCurrentTexture
-
>
AsWebRenderTextureHost
(
)
)
;
Range
<
wr
:
:
ImageKey
>
range_keys
(
&
keys
[
0
]
keys
.
Length
(
)
)
;
TextureHost
:
:
PushDisplayItemFlagSet
flags
;
flags
+
=
TextureHost
:
:
PushDisplayItemFlag
:
:
PREFER_COMPOSITOR_SURFACE
;
if
(
aPipeline
-
>
mVideoOverlayDisabled
&
&
aPipeline
-
>
mDLBuilder
.
GetBackendType
(
)
!
=
WebRenderBackend
:
:
SOFTWARE
)
{
flags
+
=
TextureHost
:
:
PushDisplayItemFlag
:
:
EXTERNAL_COMPOSITING_DISABLED
;
}
if
(
mApi
-
>
SupportsExternalBufferTextures
(
)
)
{
flags
+
=
TextureHost
:
:
PushDisplayItemFlag
:
:
SUPPORTS_EXTERNAL_BUFFER_TEXTURES
;
}
aPipeline
-
>
mCurrentTexture
-
>
PushDisplayItems
(
aPipeline
-
>
mDLBuilder
wr
:
:
ToLayoutRect
(
rect
)
wr
:
:
ToLayoutRect
(
rect
)
aPipeline
-
>
mFilter
range_keys
flags
)
;
HoldExternalImage
(
aPipelineId
aEpoch
aPipeline
-
>
mCurrentTexture
)
;
}
else
{
MOZ_ASSERT
(
keys
.
Length
(
)
=
=
1
)
;
aPipeline
-
>
mDLBuilder
.
PushImage
(
wr
:
:
ToLayoutRect
(
rect
)
wr
:
:
ToLayoutRect
(
rect
)
true
false
aPipeline
-
>
mFilter
keys
[
0
]
)
;
}
}
spaceAndClipChainHelper
.
reset
(
)
;
aPipeline
-
>
mDLBuilder
.
PopStackingContext
(
referenceFrameId
.
isSome
(
)
)
;
wr
:
:
BuiltDisplayList
dl
;
aPipeline
-
>
mDLBuilder
.
End
(
dl
)
;
aSceneBuilderTxn
.
SetDisplayList
(
aEpoch
aPipelineId
dl
.
dl_desc
dl
.
dl_items
dl
.
dl_cache
dl
.
dl_spatial_tree
)
;
}
void
AsyncImagePipelineManager
:
:
ApplyAsyncImageForPipeline
(
const
wr
:
:
PipelineId
&
aPipelineId
wr
:
:
TransactionBuilder
&
aTxn
wr
:
:
TransactionBuilder
&
aTxnForImageBridge
AsyncImagePipelineOps
*
aPendingOps
RemoteTextureInfoList
*
aPendingRemoteTextures
)
{
AsyncImagePipeline
*
pipeline
=
mAsyncImagePipelines
.
Get
(
wr
:
:
AsUint64
(
aPipelineId
)
)
;
if
(
!
pipeline
)
{
return
;
}
if
(
pipeline
-
>
mImageHost
-
>
GetAsyncRef
(
)
)
{
aPendingRemoteTextures
=
nullptr
;
}
wr
:
:
TransactionBuilder
fastTxn
(
mApi
false
)
;
wr
:
:
AutoTransactionSender
sender
(
mApi
&
fastTxn
)
;
auto
&
sceneBuilderTxn
=
pipeline
-
>
mImageHost
-
>
GetAsyncRef
(
)
?
aTxnForImageBridge
:
aTxn
;
auto
&
maybeFastTxn
=
pipeline
-
>
mImageHost
-
>
GetAsyncRef
(
)
?
fastTxn
:
aTxn
;
wr
:
:
Epoch
epoch
=
GetNextImageEpoch
(
)
;
TextureHost
*
texture
=
pipeline
-
>
mImageHost
-
>
GetAsTextureHostForComposite
(
this
)
;
auto
*
wrapper
=
texture
?
texture
-
>
AsRemoteTextureHostWrapper
(
)
:
nullptr
;
if
(
aPendingRemoteTextures
&
&
texture
&
&
texture
!
=
pipeline
-
>
mCurrentTexture
&
&
wrapper
)
{
aPendingRemoteTextures
-
>
mList
.
emplace
(
wrapper
-
>
GetRemoteTextureInfo
(
)
)
;
}
if
(
aPendingOps
&
&
!
pipeline
-
>
mImageHost
-
>
GetAsyncRef
(
)
)
{
aPendingOps
-
>
mList
.
emplace
(
AsyncImagePipelineOp
:
:
ApplyAsyncImageForPipeline
(
this
aPipelineId
texture
)
)
;
return
;
}
ApplyAsyncImageForPipeline
(
epoch
aPipelineId
pipeline
texture
sceneBuilderTxn
maybeFastTxn
)
;
}
void
AsyncImagePipelineManager
:
:
ApplyAsyncImageForPipeline
(
const
wr
:
:
PipelineId
&
aPipelineId
TextureHost
*
aTexture
wr
:
:
TransactionBuilder
&
aTxn
)
{
AsyncImagePipeline
*
pipeline
=
mAsyncImagePipelines
.
Get
(
wr
:
:
AsUint64
(
aPipelineId
)
)
;
if
(
!
pipeline
)
{
return
;
}
MOZ_ASSERT
(
!
pipeline
-
>
mImageHost
-
>
GetAsyncRef
(
)
)
;
wr
:
:
Epoch
epoch
=
GetNextImageEpoch
(
)
;
ApplyAsyncImageForPipeline
(
epoch
aPipelineId
pipeline
aTexture
aTxn
aTxn
)
;
}
void
AsyncImagePipelineManager
:
:
SetEmptyDisplayList
(
const
wr
:
:
PipelineId
&
aPipelineId
wr
:
:
TransactionBuilder
&
aTxn
wr
:
:
TransactionBuilder
&
aTxnForImageBridge
)
{
AsyncImagePipeline
*
pipeline
=
mAsyncImagePipelines
.
Get
(
wr
:
:
AsUint64
(
aPipelineId
)
)
;
if
(
!
pipeline
)
{
return
;
}
auto
&
txn
=
pipeline
-
>
mImageHost
-
>
GetAsyncRef
(
)
?
aTxnForImageBridge
:
aTxn
;
wr
:
:
Epoch
epoch
=
GetNextImageEpoch
(
)
;
wr
:
:
DisplayListBuilder
builder
(
aPipelineId
mApi
-
>
GetBackendType
(
)
)
;
builder
.
Begin
(
)
;
wr
:
:
BuiltDisplayList
dl
;
builder
.
End
(
dl
)
;
txn
.
SetDisplayList
(
epoch
aPipelineId
dl
.
dl_desc
dl
.
dl_items
dl
.
dl_cache
dl
.
dl_spatial_tree
)
;
}
void
AsyncImagePipelineManager
:
:
HoldExternalImage
(
const
wr
:
:
PipelineId
&
aPipelineId
const
wr
:
:
Epoch
&
aEpoch
TextureHost
*
aTexture
)
{
if
(
mDestroyed
)
{
return
;
}
MOZ_ASSERT
(
aTexture
)
;
PipelineTexturesHolder
*
holder
=
mPipelineTexturesHolders
.
Get
(
wr
:
:
AsUint64
(
aPipelineId
)
)
;
MOZ_ASSERT
(
holder
)
;
if
(
!
holder
)
{
return
;
}
if
(
aTexture
-
>
NeedsDeferredDeletion
(
)
)
{
holder
-
>
mTextureHostsUntilRenderCompleted
.
emplace_back
(
MakeUnique
<
ForwardingTextureHost
>
(
aEpoch
aTexture
)
)
;
}
else
{
holder
-
>
mTextureHostsUntilRenderSubmitted
.
emplace_back
(
aEpoch
aTexture
)
;
}
}
void
AsyncImagePipelineManager
:
:
HoldExternalImage
(
const
wr
:
:
PipelineId
&
aPipelineId
const
wr
:
:
Epoch
&
aEpoch
const
wr
:
:
ExternalImageId
&
aImageId
)
{
if
(
mDestroyed
)
{
SharedSurfacesParent
:
:
Release
(
aImageId
)
;
return
;
}
PipelineTexturesHolder
*
holder
=
mPipelineTexturesHolders
.
Get
(
wr
:
:
AsUint64
(
aPipelineId
)
)
;
MOZ_ASSERT
(
holder
)
;
if
(
!
holder
)
{
SharedSurfacesParent
:
:
Release
(
aImageId
)
;
return
;
}
holder
-
>
mExternalImages
.
emplace_back
(
MakeUnique
<
ForwardingExternalImage
>
(
aEpoch
aImageId
)
)
;
}
void
AsyncImagePipelineManager
:
:
NotifyPipelinesUpdated
(
RefPtr
<
const
wr
:
:
WebRenderPipelineInfo
>
aInfo
wr
:
:
RenderedFrameId
aLatestFrameId
wr
:
:
RenderedFrameId
aLastCompletedFrameId
RefPtr
<
Fence
>
&
&
aFence
)
{
MOZ_ASSERT
(
wr
:
:
RenderThread
:
:
IsInRenderThread
(
)
)
;
MOZ_ASSERT
(
mLastCompletedFrameId
<
=
aLastCompletedFrameId
.
mId
)
;
MOZ_ASSERT
(
aLatestFrameId
.
IsValid
(
)
)
;
mLastCompletedFrameId
=
aLastCompletedFrameId
.
mId
;
{
MutexAutoLock
lock
(
mRenderSubmittedUpdatesLock
)
;
mRenderSubmittedUpdates
.
emplace_back
(
aLatestFrameId
WebRenderPipelineInfoHolder
(
std
:
:
move
(
aInfo
)
std
:
:
move
(
aFence
)
)
)
;
}
layers
:
:
CompositorThread
(
)
-
>
Dispatch
(
NewRunnableMethod
(
"
ProcessPipelineUpdates
"
this
&
AsyncImagePipelineManager
:
:
ProcessPipelineUpdates
)
)
;
}
void
AsyncImagePipelineManager
:
:
ProcessPipelineUpdates
(
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
if
(
mDestroyed
)
{
return
;
}
std
:
:
vector
<
std
:
:
pair
<
wr
:
:
RenderedFrameId
WebRenderPipelineInfoHolder
>
>
submittedUpdates
;
{
MutexAutoLock
lock
(
mRenderSubmittedUpdatesLock
)
;
mRenderSubmittedUpdates
.
swap
(
submittedUpdates
)
;
}
for
(
auto
&
update
:
submittedUpdates
)
{
auto
&
holder
=
update
.
second
;
const
auto
&
info
=
holder
.
mInfo
-
>
Raw
(
)
;
mReadFence
=
std
:
:
move
(
holder
.
mFence
)
;
for
(
auto
&
epoch
:
info
.
epochs
)
{
ProcessPipelineRendered
(
epoch
.
pipeline_id
epoch
.
epoch
update
.
first
)
;
}
for
(
auto
&
removedPipeline
:
info
.
removed_pipelines
)
{
ProcessPipelineRemoved
(
removedPipeline
update
.
first
)
;
}
}
CheckForTextureHostsNotUsedByGPU
(
)
;
}
void
AsyncImagePipelineManager
:
:
ProcessPipelineRendered
(
const
wr
:
:
PipelineId
&
aPipelineId
const
wr
:
:
Epoch
&
aEpoch
wr
:
:
RenderedFrameId
aRenderedFrameId
)
{
if
(
auto
entry
=
mPipelineTexturesHolders
.
Lookup
(
wr
:
:
AsUint64
(
aPipelineId
)
)
)
{
const
auto
&
holder
=
entry
.
Data
(
)
;
auto
firstSubmittedHostToKeep
=
std
:
:
find_if
(
holder
-
>
mTextureHostsUntilRenderSubmitted
.
begin
(
)
holder
-
>
mTextureHostsUntilRenderSubmitted
.
end
(
)
[
&
aEpoch
]
(
const
auto
&
entry
)
{
return
aEpoch
<
=
entry
.
mEpoch
;
}
)
;
for
(
auto
it
=
holder
-
>
mTextureHostsUntilRenderSubmitted
.
begin
(
)
;
it
!
=
firstSubmittedHostToKeep
;
+
+
it
)
{
const
auto
&
entry
=
it
;
if
(
entry
-
>
mTexture
-
>
GetAndroidHardwareBuffer
(
)
&
&
mReadFence
)
{
entry
-
>
mTexture
-
>
SetReadFence
(
mReadFence
)
;
}
}
holder
-
>
mTextureHostsUntilRenderSubmitted
.
erase
(
holder
-
>
mTextureHostsUntilRenderSubmitted
.
begin
(
)
firstSubmittedHostToKeep
)
;
auto
firstCompletedHostToKeep
=
std
:
:
find_if
(
holder
-
>
mTextureHostsUntilRenderCompleted
.
begin
(
)
holder
-
>
mTextureHostsUntilRenderCompleted
.
end
(
)
[
&
aEpoch
]
(
const
auto
&
entry
)
{
return
aEpoch
<
=
entry
-
>
mEpoch
;
}
)
;
for
(
auto
it
=
holder
-
>
mTextureHostsUntilRenderCompleted
.
begin
(
)
;
it
!
=
firstCompletedHostToKeep
;
+
+
it
)
{
const
auto
&
entry
=
*
it
;
auto
*
texture
=
entry
-
>
mTexture
.
get
(
)
;
if
(
texture
&
&
mReadFence
)
{
texture
-
>
SetReadFence
(
mReadFence
)
;
}
}
if
(
firstCompletedHostToKeep
!
=
holder
-
>
mTextureHostsUntilRenderCompleted
.
begin
(
)
)
{
std
:
:
vector
<
UniquePtr
<
ForwardingTextureHost
>
>
hostsUntilCompleted
(
std
:
:
make_move_iterator
(
holder
-
>
mTextureHostsUntilRenderCompleted
.
begin
(
)
)
std
:
:
make_move_iterator
(
firstCompletedHostToKeep
)
)
;
mTexturesInUseByGPU
.
emplace_back
(
aRenderedFrameId
std
:
:
move
(
hostsUntilCompleted
)
)
;
holder
-
>
mTextureHostsUntilRenderCompleted
.
erase
(
holder
-
>
mTextureHostsUntilRenderCompleted
.
begin
(
)
firstCompletedHostToKeep
)
;
}
auto
firstImageToKeep
=
std
:
:
find_if
(
holder
-
>
mExternalImages
.
begin
(
)
holder
-
>
mExternalImages
.
end
(
)
[
&
aEpoch
]
(
const
auto
&
entry
)
{
return
aEpoch
<
=
entry
-
>
mEpoch
;
}
)
;
holder
-
>
mExternalImages
.
erase
(
holder
-
>
mExternalImages
.
begin
(
)
firstImageToKeep
)
;
}
}
void
AsyncImagePipelineManager
:
:
ProcessPipelineRemoved
(
const
wr
:
:
RemovedPipeline
&
aRemovedPipeline
wr
:
:
RenderedFrameId
aRenderedFrameId
)
{
if
(
mDestroyed
)
{
return
;
}
if
(
auto
entry
=
mPipelineTexturesHolders
.
Lookup
(
wr
:
:
AsUint64
(
aRemovedPipeline
.
pipeline_id
)
)
)
{
const
auto
&
holder
=
entry
.
Data
(
)
;
if
(
holder
-
>
mDestroyedEpoch
.
isSome
(
)
)
{
if
(
!
holder
-
>
mTextureHostsUntilRenderCompleted
.
empty
(
)
)
{
mTexturesInUseByGPU
.
emplace_back
(
aRenderedFrameId
std
:
:
move
(
holder
-
>
mTextureHostsUntilRenderCompleted
)
)
;
}
entry
.
Remove
(
)
;
}
}
}
void
AsyncImagePipelineManager
:
:
CheckForTextureHostsNotUsedByGPU
(
)
{
uint64_t
lastCompletedFrameId
=
mLastCompletedFrameId
;
auto
firstTexturesToKeep
=
std
:
:
find_if
(
mTexturesInUseByGPU
.
begin
(
)
mTexturesInUseByGPU
.
end
(
)
[
lastCompletedFrameId
]
(
const
auto
&
entry
)
{
return
lastCompletedFrameId
<
entry
.
first
.
mId
;
}
)
;
mTexturesInUseByGPU
.
erase
(
mTexturesInUseByGPU
.
begin
(
)
firstTexturesToKeep
)
;
}
wr
:
:
Epoch
AsyncImagePipelineManager
:
:
GetNextImageEpoch
(
)
{
mAsyncImageEpoch
.
mHandle
+
+
;
return
mAsyncImageEpoch
;
}
AsyncImagePipelineManager
:
:
WebRenderPipelineInfoHolder
:
:
WebRenderPipelineInfoHolder
(
RefPtr
<
const
wr
:
:
WebRenderPipelineInfo
>
&
&
aInfo
RefPtr
<
Fence
>
&
&
aFence
)
:
mInfo
(
aInfo
)
mFence
(
std
:
:
move
(
aFence
)
)
{
}
AsyncImagePipelineManager
:
:
WebRenderPipelineInfoHolder
:
:
~
WebRenderPipelineInfoHolder
(
)
=
default
;
}
}
