#
include
"
AsyncImagePipelineManager
.
h
"
#
include
<
algorithm
>
#
include
<
iterator
>
#
include
"
CompositableHost
.
h
"
#
include
"
gfxEnv
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
SharedSurfacesParent
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderImageHost
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderTextureHost
.
h
"
#
include
"
mozilla
/
webrender
/
RenderThread
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderTypes
.
h
"
namespace
mozilla
{
namespace
layers
{
AsyncImagePipelineManager
:
:
ForwardingExternalImage
:
:
~
ForwardingExternalImage
(
)
{
DebugOnly
<
bool
>
released
=
SharedSurfacesParent
:
:
Release
(
mImageId
)
;
MOZ_ASSERT
(
released
)
;
}
AsyncImagePipelineManager
:
:
AsyncImagePipeline
:
:
AsyncImagePipeline
(
)
:
mInitialised
(
false
)
mRenderRoot
(
wr
:
:
RenderRoot
:
:
Default
)
mIsChanged
(
false
)
mUseExternalImage
(
false
)
mFilter
(
wr
:
:
ImageRendering
:
:
Auto
)
mMixBlendMode
(
wr
:
:
MixBlendMode
:
:
Normal
)
{
}
AsyncImagePipelineManager
:
:
AsyncImagePipelineManager
(
nsTArray
<
RefPtr
<
wr
:
:
WebRenderAPI
>
>
&
&
aApis
bool
aUseCompositorWnd
)
:
mApis
(
aApis
)
mUseCompositorWnd
(
aUseCompositorWnd
)
mIdNamespace
(
mApis
[
0
]
-
>
GetNamespace
(
)
)
mUseTripleBuffering
(
mApis
[
0
]
-
>
GetUseTripleBuffering
(
)
)
mResourceId
(
0
)
mAsyncImageEpoch
{
0
}
mWillGenerateFrame
{
}
mDestroyed
(
false
)
mRenderSubmittedUpdatesLock
(
"
SubmittedUpdatesLock
"
)
mLastCompletedFrameId
(
0
)
{
MOZ_COUNT_CTOR
(
AsyncImagePipelineManager
)
;
}
AsyncImagePipelineManager
:
:
~
AsyncImagePipelineManager
(
)
{
MOZ_COUNT_DTOR
(
AsyncImagePipelineManager
)
;
}
void
AsyncImagePipelineManager
:
:
Destroy
(
)
{
MOZ_ASSERT
(
!
mDestroyed
)
;
mApis
.
Clear
(
)
;
mPipelineTexturesHolders
.
Clear
(
)
;
mDestroyed
=
true
;
}
void
AsyncImagePipelineManager
:
:
SetWillGenerateFrameAllRenderRoots
(
)
{
for
(
auto
renderRoot
:
wr
:
:
kRenderRoots
)
{
SetWillGenerateFrame
(
renderRoot
)
;
}
}
void
AsyncImagePipelineManager
:
:
SetWillGenerateFrame
(
wr
:
:
RenderRoot
aRenderRoot
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
mWillGenerateFrame
[
aRenderRoot
]
=
true
;
}
bool
AsyncImagePipelineManager
:
:
GetAndResetWillGenerateFrame
(
wr
:
:
RenderRoot
aRenderRoot
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
bool
ret
=
mWillGenerateFrame
[
aRenderRoot
]
;
mWillGenerateFrame
[
aRenderRoot
]
=
false
;
return
ret
;
}
void
AsyncImagePipelineManager
:
:
AddPipeline
(
const
wr
:
:
PipelineId
&
aPipelineId
WebRenderBridgeParent
*
aWrBridge
)
{
if
(
mDestroyed
)
{
return
;
}
uint64_t
id
=
wr
:
:
AsUint64
(
aPipelineId
)
;
PipelineTexturesHolder
*
holder
=
mPipelineTexturesHolders
.
Get
(
wr
:
:
AsUint64
(
aPipelineId
)
)
;
if
(
holder
)
{
MOZ_ASSERT
(
holder
-
>
mDestroyedEpoch
.
isSome
(
)
)
;
holder
-
>
mDestroyedEpoch
=
Nothing
(
)
;
holder
-
>
mWrBridge
=
aWrBridge
;
return
;
}
holder
=
new
PipelineTexturesHolder
(
)
;
holder
-
>
mWrBridge
=
aWrBridge
;
mPipelineTexturesHolders
.
Put
(
id
holder
)
;
}
void
AsyncImagePipelineManager
:
:
RemovePipeline
(
const
wr
:
:
PipelineId
&
aPipelineId
const
wr
:
:
Epoch
&
aEpoch
)
{
if
(
mDestroyed
)
{
return
;
}
PipelineTexturesHolder
*
holder
=
mPipelineTexturesHolders
.
Get
(
wr
:
:
AsUint64
(
aPipelineId
)
)
;
MOZ_ASSERT
(
holder
)
;
if
(
!
holder
)
{
return
;
}
holder
-
>
mWrBridge
=
nullptr
;
holder
-
>
mDestroyedEpoch
=
Some
(
aEpoch
)
;
}
WebRenderBridgeParent
*
AsyncImagePipelineManager
:
:
GetWrBridge
(
const
wr
:
:
PipelineId
&
aPipelineId
)
{
if
(
mDestroyed
)
{
return
nullptr
;
}
PipelineTexturesHolder
*
holder
=
mPipelineTexturesHolders
.
Get
(
wr
:
:
AsUint64
(
aPipelineId
)
)
;
if
(
!
holder
)
{
return
nullptr
;
}
if
(
holder
-
>
mWrBridge
)
{
MOZ_ASSERT
(
holder
-
>
mDestroyedEpoch
.
isNothing
(
)
)
;
return
holder
-
>
mWrBridge
;
}
return
nullptr
;
}
void
AsyncImagePipelineManager
:
:
AddAsyncImagePipeline
(
const
wr
:
:
PipelineId
&
aPipelineId
WebRenderImageHost
*
aImageHost
wr
:
:
RenderRoot
aRenderRoot
)
{
if
(
mDestroyed
)
{
return
;
}
MOZ_ASSERT
(
aImageHost
)
;
uint64_t
id
=
wr
:
:
AsUint64
(
aPipelineId
)
;
MOZ_ASSERT
(
!
mAsyncImagePipelines
.
Get
(
id
)
)
;
AsyncImagePipeline
*
holder
=
new
AsyncImagePipeline
(
)
;
holder
-
>
mRenderRoot
=
aRenderRoot
;
holder
-
>
mImageHost
=
aImageHost
;
mAsyncImagePipelines
.
Put
(
id
holder
)
;
AddPipeline
(
aPipelineId
nullptr
)
;
}
void
AsyncImagePipelineManager
:
:
RemoveAsyncImagePipeline
(
const
wr
:
:
PipelineId
&
aPipelineId
wr
:
:
TransactionBuilder
&
aTxn
)
{
if
(
mDestroyed
)
{
return
;
}
uint64_t
id
=
wr
:
:
AsUint64
(
aPipelineId
)
;
if
(
auto
entry
=
mAsyncImagePipelines
.
Lookup
(
id
)
)
{
AsyncImagePipeline
*
holder
=
entry
.
Data
(
)
;
wr
:
:
Epoch
epoch
=
GetNextImageEpoch
(
)
;
aTxn
.
ClearDisplayList
(
epoch
aPipelineId
)
;
for
(
wr
:
:
ImageKey
key
:
holder
-
>
mKeys
)
{
aTxn
.
DeleteImage
(
key
)
;
}
entry
.
Remove
(
)
;
RemovePipeline
(
aPipelineId
epoch
)
;
}
}
void
AsyncImagePipelineManager
:
:
UpdateAsyncImagePipeline
(
const
wr
:
:
PipelineId
&
aPipelineId
const
LayoutDeviceRect
&
aScBounds
const
gfx
:
:
Matrix4x4
&
aScTransform
const
gfx
:
:
MaybeIntSize
&
aScaleToSize
const
wr
:
:
ImageRendering
&
aFilter
const
wr
:
:
MixBlendMode
&
aMixBlendMode
)
{
if
(
mDestroyed
)
{
return
;
}
AsyncImagePipeline
*
pipeline
=
mAsyncImagePipelines
.
Get
(
wr
:
:
AsUint64
(
aPipelineId
)
)
;
if
(
!
pipeline
)
{
return
;
}
pipeline
-
>
mInitialised
=
true
;
pipeline
-
>
Update
(
aScBounds
aScTransform
aScaleToSize
aFilter
aMixBlendMode
)
;
}
Maybe
<
TextureHost
:
:
ResourceUpdateOp
>
AsyncImagePipelineManager
:
:
UpdateImageKeys
(
const
wr
:
:
Epoch
&
aEpoch
const
wr
:
:
PipelineId
&
aPipelineId
AsyncImagePipeline
*
aPipeline
nsTArray
<
wr
:
:
ImageKey
>
&
aKeys
wr
:
:
TransactionBuilder
&
aSceneBuilderTxn
wr
:
:
TransactionBuilder
&
aMaybeFastTxn
)
{
MOZ_ASSERT
(
aKeys
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aPipeline
)
;
TextureHost
*
texture
=
aPipeline
-
>
mImageHost
-
>
GetAsTextureHostForComposite
(
this
)
;
TextureHost
*
previousTexture
=
aPipeline
-
>
mCurrentTexture
.
get
(
)
;
if
(
texture
=
=
previousTexture
)
{
aKeys
=
aPipeline
-
>
mKeys
;
return
Nothing
(
)
;
}
if
(
!
texture
|
|
texture
-
>
NumSubTextures
(
)
=
=
0
)
{
aKeys
=
aPipeline
-
>
mKeys
;
return
Nothing
(
)
;
}
aPipeline
-
>
mCurrentTexture
=
texture
;
WebRenderTextureHost
*
wrTexture
=
texture
-
>
AsWebRenderTextureHost
(
)
;
MOZ_ASSERT
(
wrTexture
)
;
if
(
!
wrTexture
)
{
gfxCriticalNote
<
<
"
WebRenderTextureHost
is
not
used
"
;
}
bool
useExternalImage
=
!
gfxEnv
:
:
EnableWebRenderRecording
(
)
&
&
wrTexture
;
aPipeline
-
>
mUseExternalImage
=
useExternalImage
;
auto
numKeys
=
useExternalImage
?
texture
-
>
NumSubTextures
(
)
:
1
;
MOZ_ASSERT
(
numKeys
>
0
)
;
bool
canUpdate
=
!
!
previousTexture
&
&
previousTexture
-
>
GetSize
(
)
=
=
texture
-
>
GetSize
(
)
&
&
previousTexture
-
>
GetFormat
(
)
=
=
texture
-
>
GetFormat
(
)
&
&
previousTexture
-
>
NeedsYFlip
(
)
=
=
texture
-
>
NeedsYFlip
(
)
&
&
aPipeline
-
>
mKeys
.
Length
(
)
=
=
numKeys
;
if
(
!
canUpdate
)
{
for
(
auto
key
:
aPipeline
-
>
mKeys
)
{
aSceneBuilderTxn
.
DeleteImage
(
key
)
;
}
aPipeline
-
>
mKeys
.
Clear
(
)
;
for
(
uint32_t
i
=
0
;
i
<
numKeys
;
+
+
i
)
{
aPipeline
-
>
mKeys
.
AppendElement
(
GenerateImageKey
(
)
)
;
}
}
aKeys
=
aPipeline
-
>
mKeys
;
auto
op
=
canUpdate
?
TextureHost
:
:
UPDATE_IMAGE
:
TextureHost
:
:
ADD_IMAGE
;
if
(
!
useExternalImage
)
{
return
UpdateWithoutExternalImage
(
texture
aKeys
[
0
]
op
aMaybeFastTxn
)
;
}
wrTexture
-
>
MaybeNofityForUse
(
aMaybeFastTxn
)
;
Range
<
wr
:
:
ImageKey
>
keys
(
&
aKeys
[
0
]
aKeys
.
Length
(
)
)
;
auto
externalImageKey
=
wrTexture
-
>
GetExternalImageKey
(
)
;
wrTexture
-
>
PushResourceUpdates
(
aMaybeFastTxn
op
keys
externalImageKey
)
;
return
Some
(
op
)
;
}
Maybe
<
TextureHost
:
:
ResourceUpdateOp
>
AsyncImagePipelineManager
:
:
UpdateWithoutExternalImage
(
TextureHost
*
aTexture
wr
:
:
ImageKey
aKey
TextureHost
:
:
ResourceUpdateOp
aOp
wr
:
:
TransactionBuilder
&
aTxn
)
{
MOZ_ASSERT
(
aTexture
)
;
RefPtr
<
gfx
:
:
DataSourceSurface
>
dSurf
=
aTexture
-
>
GetAsSurface
(
)
;
if
(
!
dSurf
)
{
NS_ERROR
(
"
TextureHost
does
not
return
DataSourceSurface
"
)
;
return
Nothing
(
)
;
}
gfx
:
:
DataSourceSurface
:
:
MappedSurface
map
;
if
(
!
dSurf
-
>
Map
(
gfx
:
:
DataSourceSurface
:
:
MapType
:
:
READ
&
map
)
)
{
NS_ERROR
(
"
DataSourceSurface
failed
to
map
"
)
;
return
Nothing
(
)
;
}
gfx
:
:
IntSize
size
=
dSurf
-
>
GetSize
(
)
;
wr
:
:
ImageDescriptor
descriptor
(
size
map
.
mStride
dSurf
-
>
GetFormat
(
)
)
;
wr
:
:
Vec
<
uint8_t
>
bytes
;
bytes
.
PushBytes
(
Range
<
uint8_t
>
(
map
.
mData
size
.
height
*
map
.
mStride
)
)
;
if
(
aOp
=
=
TextureHost
:
:
UPDATE_IMAGE
)
{
aTxn
.
UpdateImageBuffer
(
aKey
descriptor
bytes
)
;
}
else
{
aTxn
.
AddImage
(
aKey
descriptor
bytes
)
;
}
dSurf
-
>
Unmap
(
)
;
return
Some
(
aOp
)
;
}
void
AsyncImagePipelineManager
:
:
ApplyAsyncImagesOfImageBridge
(
wr
:
:
RenderRootArray
<
Maybe
<
wr
:
:
TransactionBuilder
>
>
&
aSceneBuilderTxns
wr
:
:
RenderRootArray
<
Maybe
<
wr
:
:
TransactionBuilder
>
>
&
aFastTxns
)
{
if
(
mDestroyed
|
|
mAsyncImagePipelines
.
Count
(
)
=
=
0
)
{
return
;
}
wr
:
:
Epoch
epoch
=
GetNextImageEpoch
(
)
;
for
(
auto
iter
=
mAsyncImagePipelines
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
wr
:
:
PipelineId
pipelineId
=
wr
:
:
AsPipelineId
(
iter
.
Key
(
)
)
;
AsyncImagePipeline
*
pipeline
=
iter
.
Data
(
)
;
if
(
!
pipeline
-
>
mImageHost
-
>
GetAsyncRef
(
)
)
{
continue
;
}
ApplyAsyncImageForPipeline
(
epoch
pipelineId
pipeline
*
aSceneBuilderTxns
[
pipeline
-
>
mRenderRoot
]
*
aFastTxns
[
pipeline
-
>
mRenderRoot
]
)
;
}
}
void
AsyncImagePipelineManager
:
:
ApplyAsyncImageForPipeline
(
const
wr
:
:
Epoch
&
aEpoch
const
wr
:
:
PipelineId
&
aPipelineId
AsyncImagePipeline
*
aPipeline
wr
:
:
TransactionBuilder
&
aSceneBuilderTxn
wr
:
:
TransactionBuilder
&
aMaybeFastTxn
)
{
nsTArray
<
wr
:
:
ImageKey
>
keys
;
auto
op
=
UpdateImageKeys
(
aEpoch
aPipelineId
aPipeline
keys
aSceneBuilderTxn
aMaybeFastTxn
)
;
bool
updateDisplayList
=
aPipeline
-
>
mInitialised
&
&
(
aPipeline
-
>
mIsChanged
|
|
op
=
=
Some
(
TextureHost
:
:
ADD_IMAGE
)
)
&
&
!
!
aPipeline
-
>
mCurrentTexture
;
if
(
!
updateDisplayList
)
{
aSceneBuilderTxn
.
UpdateEpoch
(
aPipelineId
aEpoch
)
;
if
(
aPipeline
-
>
mCurrentTexture
)
{
HoldExternalImage
(
aPipelineId
aEpoch
aPipeline
-
>
mCurrentTexture
)
;
}
return
;
}
aPipeline
-
>
mIsChanged
=
false
;
gfx
:
:
Matrix4x4
scTransform
=
aPipeline
-
>
mScTransform
;
if
(
aPipeline
-
>
mCurrentTexture
&
&
aPipeline
-
>
mCurrentTexture
-
>
NeedsYFlip
(
)
)
{
scTransform
.
PreTranslate
(
0
aPipeline
-
>
mCurrentTexture
-
>
GetSize
(
)
.
height
0
)
.
PreScale
(
1
-
1
1
)
;
}
wr
:
:
LayoutSize
contentSize
{
aPipeline
-
>
mScBounds
.
Width
(
)
aPipeline
-
>
mScBounds
.
Height
(
)
}
;
wr
:
:
DisplayListBuilder
builder
(
aPipelineId
contentSize
)
;
float
opacity
=
1
.
0f
;
wr
:
:
StackingContextParams
params
;
params
.
opacity
=
&
opacity
;
params
.
mTransformPtr
=
scTransform
.
IsIdentity
(
)
?
nullptr
:
&
scTransform
;
params
.
mix_blend_mode
=
aPipeline
-
>
mMixBlendMode
;
Maybe
<
wr
:
:
WrSpatialId
>
referenceFrameId
=
builder
.
PushStackingContext
(
params
wr
:
:
ToLayoutRect
(
aPipeline
-
>
mScBounds
)
wr
:
:
RasterSpace
:
:
Screen
(
)
)
;
Maybe
<
wr
:
:
SpaceAndClipChainHelper
>
spaceAndClipChainHelper
;
if
(
referenceFrameId
)
{
spaceAndClipChainHelper
.
emplace
(
builder
referenceFrameId
.
ref
(
)
)
;
}
if
(
aPipeline
-
>
mCurrentTexture
&
&
!
keys
.
IsEmpty
(
)
)
{
LayoutDeviceRect
rect
(
0
0
aPipeline
-
>
mCurrentTexture
-
>
GetSize
(
)
.
width
aPipeline
-
>
mCurrentTexture
-
>
GetSize
(
)
.
height
)
;
if
(
aPipeline
-
>
mScaleToSize
.
isSome
(
)
)
{
rect
=
LayoutDeviceRect
(
0
0
aPipeline
-
>
mScaleToSize
.
value
(
)
.
width
aPipeline
-
>
mScaleToSize
.
value
(
)
.
height
)
;
}
if
(
aPipeline
-
>
mUseExternalImage
)
{
MOZ_ASSERT
(
aPipeline
-
>
mCurrentTexture
-
>
AsWebRenderTextureHost
(
)
)
;
Range
<
wr
:
:
ImageKey
>
range_keys
(
&
keys
[
0
]
keys
.
Length
(
)
)
;
aPipeline
-
>
mCurrentTexture
-
>
PushDisplayItems
(
builder
wr
:
:
ToLayoutRect
(
rect
)
wr
:
:
ToLayoutRect
(
rect
)
aPipeline
-
>
mFilter
range_keys
)
;
HoldExternalImage
(
aPipelineId
aEpoch
aPipeline
-
>
mCurrentTexture
)
;
}
else
{
MOZ_ASSERT
(
keys
.
Length
(
)
=
=
1
)
;
builder
.
PushImage
(
wr
:
:
ToLayoutRect
(
rect
)
wr
:
:
ToLayoutRect
(
rect
)
true
aPipeline
-
>
mFilter
keys
[
0
]
)
;
}
}
spaceAndClipChainHelper
.
reset
(
)
;
builder
.
PopStackingContext
(
referenceFrameId
.
isSome
(
)
)
;
wr
:
:
BuiltDisplayList
dl
;
wr
:
:
LayoutSize
builderContentSize
;
builder
.
Finalize
(
builderContentSize
dl
)
;
aSceneBuilderTxn
.
SetDisplayList
(
gfx
:
:
Color
(
0
.
f
0
.
f
0
.
f
0
.
f
)
aEpoch
wr
:
:
ToLayoutSize
(
aPipeline
-
>
mScBounds
.
Size
(
)
)
aPipelineId
builderContentSize
dl
.
dl_desc
dl
.
dl
)
;
}
void
AsyncImagePipelineManager
:
:
ApplyAsyncImageForPipeline
(
const
wr
:
:
PipelineId
&
aPipelineId
wr
:
:
TransactionBuilder
&
aTxn
wr
:
:
TransactionBuilder
&
aTxnForImageBridge
wr
:
:
RenderRoot
aRenderRoot
)
{
AsyncImagePipeline
*
pipeline
=
mAsyncImagePipelines
.
Get
(
wr
:
:
AsUint64
(
aPipelineId
)
)
;
if
(
!
pipeline
)
{
return
;
}
wr
:
:
WebRenderAPI
*
api
=
mApis
[
(
size_t
)
pipeline
-
>
mRenderRoot
]
;
wr
:
:
TransactionBuilder
fastTxn
(
false
)
;
wr
:
:
AutoTransactionSender
sender
(
api
&
fastTxn
)
;
auto
&
sceneBuilderTxn
=
pipeline
-
>
mImageHost
-
>
GetAsyncRef
(
)
?
aTxnForImageBridge
:
aTxn
;
auto
&
maybeFastTxn
=
pipeline
-
>
mImageHost
-
>
GetAsyncRef
(
)
?
fastTxn
:
aTxn
;
wr
:
:
Epoch
epoch
=
GetNextImageEpoch
(
)
;
ApplyAsyncImageForPipeline
(
epoch
aPipelineId
pipeline
sceneBuilderTxn
maybeFastTxn
)
;
}
void
AsyncImagePipelineManager
:
:
SetEmptyDisplayList
(
const
wr
:
:
PipelineId
&
aPipelineId
wr
:
:
TransactionBuilder
&
aTxn
wr
:
:
TransactionBuilder
&
aTxnForImageBridge
)
{
AsyncImagePipeline
*
pipeline
=
mAsyncImagePipelines
.
Get
(
wr
:
:
AsUint64
(
aPipelineId
)
)
;
if
(
!
pipeline
)
{
return
;
}
auto
&
txn
=
pipeline
-
>
mImageHost
-
>
GetAsyncRef
(
)
?
aTxnForImageBridge
:
aTxn
;
wr
:
:
Epoch
epoch
=
GetNextImageEpoch
(
)
;
wr
:
:
LayoutSize
contentSize
{
pipeline
-
>
mScBounds
.
Width
(
)
pipeline
-
>
mScBounds
.
Height
(
)
}
;
wr
:
:
DisplayListBuilder
builder
(
aPipelineId
contentSize
)
;
wr
:
:
BuiltDisplayList
dl
;
wr
:
:
LayoutSize
builderContentSize
;
builder
.
Finalize
(
builderContentSize
dl
)
;
txn
.
SetDisplayList
(
gfx
:
:
Color
(
0
.
f
0
.
f
0
.
f
0
.
f
)
epoch
wr
:
:
ToLayoutSize
(
pipeline
-
>
mScBounds
.
Size
(
)
)
aPipelineId
builderContentSize
dl
.
dl_desc
dl
.
dl
)
;
}
void
AsyncImagePipelineManager
:
:
HoldExternalImage
(
const
wr
:
:
PipelineId
&
aPipelineId
const
wr
:
:
Epoch
&
aEpoch
TextureHost
*
aTexture
)
{
if
(
mDestroyed
)
{
return
;
}
MOZ_ASSERT
(
aTexture
)
;
PipelineTexturesHolder
*
holder
=
mPipelineTexturesHolders
.
Get
(
wr
:
:
AsUint64
(
aPipelineId
)
)
;
MOZ_ASSERT
(
holder
)
;
if
(
!
holder
)
{
return
;
}
if
(
aTexture
-
>
HasIntermediateBuffer
(
)
)
{
holder
-
>
mTextureHostsUntilRenderSubmitted
.
emplace_back
(
aEpoch
aTexture
)
;
}
else
{
holder
-
>
mTextureHostsUntilRenderCompleted
.
emplace_back
(
MakeUnique
<
ForwardingTextureHost
>
(
aEpoch
aTexture
)
)
;
}
}
void
AsyncImagePipelineManager
:
:
HoldExternalImage
(
const
wr
:
:
PipelineId
&
aPipelineId
const
wr
:
:
Epoch
&
aEpoch
const
wr
:
:
ExternalImageId
&
aImageId
)
{
if
(
mDestroyed
)
{
SharedSurfacesParent
:
:
Release
(
aImageId
)
;
return
;
}
PipelineTexturesHolder
*
holder
=
mPipelineTexturesHolders
.
Get
(
wr
:
:
AsUint64
(
aPipelineId
)
)
;
MOZ_ASSERT
(
holder
)
;
if
(
!
holder
)
{
SharedSurfacesParent
:
:
Release
(
aImageId
)
;
return
;
}
holder
-
>
mExternalImages
.
emplace_back
(
MakeUnique
<
ForwardingExternalImage
>
(
aEpoch
aImageId
)
)
;
}
void
AsyncImagePipelineManager
:
:
NotifyPipelinesUpdated
(
RefPtr
<
wr
:
:
WebRenderPipelineInfo
>
aInfo
wr
:
:
RenderedFrameId
aLatestFrameId
wr
:
:
RenderedFrameId
aLastCompletedFrameId
)
{
MOZ_ASSERT
(
wr
:
:
RenderThread
:
:
IsInRenderThread
(
)
)
;
MOZ_ASSERT
(
mLastCompletedFrameId
<
=
aLastCompletedFrameId
.
mId
)
;
mPendingUpdates
.
push_back
(
aInfo
)
;
if
(
aLatestFrameId
.
IsValid
(
)
)
{
mLastCompletedFrameId
=
aLastCompletedFrameId
.
mId
;
{
MutexAutoLock
lock
(
mRenderSubmittedUpdatesLock
)
;
mRenderSubmittedUpdates
.
emplace_back
(
aLatestFrameId
std
:
:
move
(
mPendingUpdates
)
)
;
}
layers
:
:
CompositorThreadHolder
:
:
Loop
(
)
-
>
PostTask
(
NewRunnableMethod
(
"
ProcessPipelineUpdates
"
this
&
AsyncImagePipelineManager
:
:
ProcessPipelineUpdates
)
)
;
}
else
if
(
mLastCompletedFrameId
<
aLastCompletedFrameId
.
mId
)
{
mLastCompletedFrameId
=
aLastCompletedFrameId
.
mId
;
layers
:
:
CompositorThreadHolder
:
:
Loop
(
)
-
>
PostTask
(
NewRunnableMethod
(
"
CheckForTextureHostsNotUsedByGPU
"
this
&
AsyncImagePipelineManager
:
:
CheckForTextureHostsNotUsedByGPU
)
)
;
}
}
void
AsyncImagePipelineManager
:
:
ProcessPipelineUpdates
(
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
if
(
mDestroyed
)
{
return
;
}
std
:
:
vector
<
std
:
:
pair
<
wr
:
:
RenderedFrameId
PipelineInfoVector
>
>
submittedUpdates
;
{
MutexAutoLock
lock
(
mRenderSubmittedUpdatesLock
)
;
mRenderSubmittedUpdates
.
swap
(
submittedUpdates
)
;
}
for
(
auto
update
:
submittedUpdates
)
{
for
(
auto
pipelineInfo
:
update
.
second
)
{
auto
&
info
=
pipelineInfo
-
>
Raw
(
)
;
for
(
uintptr_t
i
=
0
;
i
<
info
.
epochs
.
length
;
i
+
+
)
{
ProcessPipelineRendered
(
info
.
epochs
.
data
[
i
]
.
pipeline_id
info
.
epochs
.
data
[
i
]
.
epoch
update
.
first
)
;
}
for
(
uintptr_t
i
=
0
;
i
<
info
.
removed_pipelines
.
length
;
i
+
+
)
{
ProcessPipelineRemoved
(
info
.
removed_pipelines
.
data
[
i
]
update
.
first
)
;
}
}
}
CheckForTextureHostsNotUsedByGPU
(
)
;
}
void
AsyncImagePipelineManager
:
:
ProcessPipelineRendered
(
const
wr
:
:
PipelineId
&
aPipelineId
const
wr
:
:
Epoch
&
aEpoch
wr
:
:
RenderedFrameId
aRenderedFrameId
)
{
if
(
auto
entry
=
mPipelineTexturesHolders
.
Lookup
(
wr
:
:
AsUint64
(
aPipelineId
)
)
)
{
PipelineTexturesHolder
*
holder
=
entry
.
Data
(
)
;
auto
firstSubmittedHostToKeep
=
std
:
:
find_if
(
holder
-
>
mTextureHostsUntilRenderSubmitted
.
begin
(
)
holder
-
>
mTextureHostsUntilRenderSubmitted
.
end
(
)
[
&
aEpoch
]
(
const
auto
&
entry
)
{
return
aEpoch
<
=
entry
.
mEpoch
;
}
)
;
holder
-
>
mTextureHostsUntilRenderSubmitted
.
erase
(
holder
-
>
mTextureHostsUntilRenderSubmitted
.
begin
(
)
firstSubmittedHostToKeep
)
;
auto
firstCompletedHostToKeep
=
std
:
:
find_if
(
holder
-
>
mTextureHostsUntilRenderCompleted
.
begin
(
)
holder
-
>
mTextureHostsUntilRenderCompleted
.
end
(
)
[
&
aEpoch
]
(
const
auto
&
entry
)
{
return
aEpoch
<
=
entry
-
>
mEpoch
;
}
)
;
if
(
firstCompletedHostToKeep
!
=
holder
-
>
mTextureHostsUntilRenderCompleted
.
begin
(
)
)
{
std
:
:
vector
<
UniquePtr
<
ForwardingTextureHost
>
>
hostsUntilCompleted
(
std
:
:
make_move_iterator
(
holder
-
>
mTextureHostsUntilRenderCompleted
.
begin
(
)
)
std
:
:
make_move_iterator
(
firstCompletedHostToKeep
)
)
;
mTexturesInUseByGPU
.
emplace_back
(
aRenderedFrameId
std
:
:
move
(
hostsUntilCompleted
)
)
;
holder
-
>
mTextureHostsUntilRenderCompleted
.
erase
(
holder
-
>
mTextureHostsUntilRenderCompleted
.
begin
(
)
firstCompletedHostToKeep
)
;
}
auto
firstImageToKeep
=
std
:
:
find_if
(
holder
-
>
mExternalImages
.
begin
(
)
holder
-
>
mExternalImages
.
end
(
)
[
&
aEpoch
]
(
const
auto
&
entry
)
{
return
aEpoch
<
=
entry
-
>
mEpoch
;
}
)
;
holder
-
>
mExternalImages
.
erase
(
holder
-
>
mExternalImages
.
begin
(
)
firstImageToKeep
)
;
}
}
void
AsyncImagePipelineManager
:
:
ProcessPipelineRemoved
(
const
wr
:
:
RemovedPipeline
&
aRemovedPipeline
wr
:
:
RenderedFrameId
aRenderedFrameId
)
{
if
(
mDestroyed
)
{
return
;
}
if
(
auto
entry
=
mPipelineTexturesHolders
.
Lookup
(
wr
:
:
AsUint64
(
aRemovedPipeline
.
pipeline_id
)
)
)
{
PipelineTexturesHolder
*
holder
=
entry
.
Data
(
)
;
if
(
holder
-
>
mDestroyedEpoch
.
isSome
(
)
)
{
if
(
!
holder
-
>
mTextureHostsUntilRenderCompleted
.
empty
(
)
)
{
mTexturesInUseByGPU
.
emplace_back
(
aRenderedFrameId
std
:
:
move
(
holder
-
>
mTextureHostsUntilRenderCompleted
)
)
;
}
entry
.
Remove
(
)
;
}
}
}
void
AsyncImagePipelineManager
:
:
CheckForTextureHostsNotUsedByGPU
(
)
{
uint64_t
lastCompletedFrameId
=
mLastCompletedFrameId
;
auto
firstTexturesToKeep
=
std
:
:
find_if
(
mTexturesInUseByGPU
.
begin
(
)
mTexturesInUseByGPU
.
end
(
)
[
lastCompletedFrameId
]
(
const
auto
&
entry
)
{
return
lastCompletedFrameId
<
entry
.
first
.
mId
;
}
)
;
mTexturesInUseByGPU
.
erase
(
mTexturesInUseByGPU
.
begin
(
)
firstTexturesToKeep
)
;
}
wr
:
:
Epoch
AsyncImagePipelineManager
:
:
GetNextImageEpoch
(
)
{
mAsyncImageEpoch
.
mHandle
+
+
;
return
mAsyncImageEpoch
;
}
}
}
