#
include
"
DisplayItemCache
.
h
"
namespace
mozilla
{
namespace
layers
{
void
DisplayItemCache
:
:
UpdateState
(
const
bool
aPartialDisplayListBuildFailed
const
wr
:
:
PipelineId
&
aPipelineId
)
{
if
(
!
IsEnabled
(
)
)
{
return
;
}
const
bool
clearCache
=
UpdatePipelineId
(
aPipelineId
)
|
|
aPartialDisplayListBuildFailed
;
if
(
clearCache
)
{
memset
(
mCachedItemState
.
Elements
(
)
0
mCachedItemState
.
Length
(
)
*
sizeof
(
CacheEntry
)
)
;
mNextIndex
=
0
;
mFreeList
.
Clear
(
)
;
}
PopulateFreeList
(
clearCache
)
;
}
void
DisplayItemCache
:
:
PopulateFreeList
(
const
bool
aAddAll
)
{
uint16_t
index
=
0
;
for
(
auto
&
state
:
mCachedItemState
)
{
if
(
aAddAll
|
|
(
!
state
.
mUsed
&
&
state
.
mCached
)
)
{
state
.
mCached
=
false
;
mFreeList
.
AppendElement
(
index
)
;
}
state
.
mUsed
=
false
;
index
+
+
;
}
}
static
bool
CanCacheItem
(
const
nsDisplayItem
*
aItem
)
{
if
(
!
aItem
-
>
CanBeReused
(
)
)
{
return
false
;
}
switch
(
aItem
-
>
GetType
(
)
)
{
case
DisplayItemType
:
:
TYPE_BACKGROUND_COLOR
:
MOZ_ASSERT
(
!
aItem
-
>
HasChildren
(
)
)
;
return
true
;
default
:
return
false
;
}
}
void
DisplayItemCache
:
:
MaybeStartCaching
(
nsPaintedDisplayItem
*
aItem
wr
:
:
DisplayListBuilder
&
aBuilder
)
{
if
(
!
IsEnabled
(
)
)
{
return
;
}
Stats
(
)
.
AddTotal
(
)
;
auto
&
index
=
aItem
-
>
CacheIndex
(
)
;
if
(
!
index
)
{
if
(
!
CanCacheItem
(
aItem
)
)
{
return
;
}
index
=
GetNextCacheIndex
(
)
;
if
(
!
index
)
{
return
;
}
}
MOZ_ASSERT
(
!
mCurrentIndex
)
;
mCurrentIndex
=
index
;
MOZ_ASSERT
(
CanCacheItem
(
aItem
)
)
;
MOZ_ASSERT
(
mCurrentIndex
&
&
CurrentCacheSize
(
)
>
*
mCurrentIndex
)
;
auto
&
state
=
mCachedItemState
[
*
mCurrentIndex
]
;
MOZ_ASSERT
(
!
state
.
mCached
)
;
state
.
mCached
=
true
;
MOZ_ASSERT
(
!
state
.
mUsed
)
;
state
.
mUsed
=
true
;
state
.
mSpaceAndClip
=
aBuilder
.
CurrentSpaceAndClipChain
(
)
;
Stats
(
)
.
AddCached
(
)
;
aBuilder
.
StartCachedItem
(
*
mCurrentIndex
)
;
}
void
DisplayItemCache
:
:
MaybeEndCaching
(
wr
:
:
DisplayListBuilder
&
aBuilder
)
{
if
(
IsEnabled
(
)
&
&
mCurrentIndex
)
{
aBuilder
.
EndCachedItem
(
*
mCurrentIndex
)
;
mCurrentIndex
=
Nothing
(
)
;
}
}
bool
DisplayItemCache
:
:
ReuseItem
(
nsPaintedDisplayItem
*
aItem
wr
:
:
DisplayListBuilder
&
aBuilder
)
{
if
(
!
IsEnabled
(
)
)
{
return
false
;
}
auto
&
index
=
aItem
-
>
CacheIndex
(
)
;
if
(
!
index
)
{
return
false
;
}
auto
&
state
=
mCachedItemState
[
*
index
]
;
if
(
!
state
.
mCached
)
{
return
false
;
}
if
(
!
(
aBuilder
.
CurrentSpaceAndClipChain
(
)
=
=
state
.
mSpaceAndClip
)
)
{
state
.
mCached
=
false
;
return
false
;
}
Stats
(
)
.
AddReused
(
)
;
Stats
(
)
.
AddTotal
(
)
;
state
.
mUsed
=
true
;
aBuilder
.
ReuseItem
(
*
index
)
;
return
true
;
}
}
}
