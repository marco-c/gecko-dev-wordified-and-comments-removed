#
include
"
DisplayItemCache
.
h
"
#
include
"
nsDisplayList
.
h
"
namespace
mozilla
{
namespace
layers
{
DisplayItemCache
:
:
DisplayItemCache
(
)
:
mDisplayList
(
nullptr
)
mMaximumSize
(
0
)
mPipelineId
{
}
mCaching
(
false
)
mInvalid
(
false
)
mSuppressed
(
false
)
{
}
void
DisplayItemCache
:
:
SetDisplayList
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
)
{
if
(
!
IsEnabled
(
)
)
{
return
;
}
MOZ_ASSERT
(
aBuilder
)
;
MOZ_ASSERT
(
aList
)
;
const
bool
listChanged
=
mDisplayList
!
=
aList
;
const
bool
partialBuild
=
!
aBuilder
-
>
PartialBuildFailed
(
)
;
if
(
listChanged
&
&
partialBuild
)
{
mDisplayList
=
nullptr
;
return
;
}
if
(
listChanged
|
|
!
partialBuild
)
{
mDisplayList
=
aList
;
mInvalid
=
true
;
}
UpdateState
(
)
;
}
void
DisplayItemCache
:
:
SetPipelineId
(
const
wr
:
:
PipelineId
&
aPipelineId
)
{
mInvalid
=
mInvalid
|
|
!
(
mPipelineId
=
=
aPipelineId
)
;
mPipelineId
=
aPipelineId
;
}
void
DisplayItemCache
:
:
UpdateState
(
)
{
mCaching
=
!
mInvalid
;
#
if
0
Stats
(
)
.
Print
(
)
;
Stats
(
)
.
Reset
(
)
;
#
endif
if
(
IsEmpty
(
)
)
{
mInvalid
=
false
;
return
;
}
if
(
mInvalid
)
{
Clear
(
)
;
}
else
{
FreeUnusedSlots
(
)
;
}
mInvalid
=
false
;
}
void
DisplayItemCache
:
:
Clear
(
)
{
memset
(
mSlots
.
Elements
(
)
0
mSlots
.
Length
(
)
*
sizeof
(
Slot
)
)
;
mFreeSlots
.
ClearAndRetainStorage
(
)
;
for
(
size_t
i
=
0
;
i
<
CurrentSize
(
)
;
+
+
i
)
{
mFreeSlots
.
AppendElement
(
i
)
;
}
}
Maybe
<
uint16_t
>
DisplayItemCache
:
:
GetNextFreeSlot
(
)
{
if
(
mFreeSlots
.
IsEmpty
(
)
&
&
!
GrowIfPossible
(
)
)
{
return
Nothing
(
)
;
}
return
Some
(
mFreeSlots
.
PopLastElement
(
)
)
;
}
bool
DisplayItemCache
:
:
GrowIfPossible
(
)
{
if
(
IsFull
(
)
)
{
return
false
;
}
const
auto
currentSize
=
CurrentSize
(
)
;
MOZ_ASSERT
(
currentSize
<
=
mMaximumSize
)
;
mSlots
.
AppendElement
(
)
;
mFreeSlots
.
AppendElement
(
currentSize
)
;
return
true
;
}
void
DisplayItemCache
:
:
FreeUnusedSlots
(
)
{
for
(
size_t
i
=
0
;
i
<
CurrentSize
(
)
;
+
+
i
)
{
auto
&
slot
=
mSlots
[
i
]
;
if
(
!
slot
.
mUsed
&
&
slot
.
mOccupied
)
{
slot
.
mOccupied
=
false
;
mFreeSlots
.
AppendElement
(
i
)
;
}
slot
.
mUsed
=
false
;
}
}
void
DisplayItemCache
:
:
SetCapacity
(
const
size_t
aInitialSize
const
size_t
aMaximumSize
)
{
mMaximumSize
=
aMaximumSize
;
mSlots
.
SetLength
(
aInitialSize
)
;
mFreeSlots
.
SetCapacity
(
aMaximumSize
)
;
Clear
(
)
;
}
Maybe
<
uint16_t
>
DisplayItemCache
:
:
AssignSlot
(
nsPaintedDisplayItem
*
aItem
)
{
if
(
!
mCaching
|
|
!
aItem
-
>
CanBeReused
(
)
|
|
!
aItem
-
>
CanBeCached
(
)
)
{
return
Nothing
(
)
;
}
auto
&
slot
=
aItem
-
>
CacheIndex
(
)
;
if
(
!
slot
)
{
slot
=
GetNextFreeSlot
(
)
;
if
(
!
slot
)
{
return
Nothing
(
)
;
}
}
MOZ_ASSERT
(
slot
&
&
CurrentSize
(
)
>
*
slot
)
;
return
slot
;
}
void
DisplayItemCache
:
:
MarkSlotOccupied
(
uint16_t
aSlotIndex
const
wr
:
:
WrSpaceAndClipChain
&
aSpaceAndClip
)
{
auto
&
slot
=
mSlots
[
aSlotIndex
]
;
MOZ_ASSERT
(
!
slot
.
mOccupied
)
;
slot
.
mOccupied
=
true
;
MOZ_ASSERT
(
!
slot
.
mUsed
)
;
slot
.
mUsed
=
true
;
slot
.
mSpaceAndClip
=
aSpaceAndClip
;
}
Maybe
<
uint16_t
>
DisplayItemCache
:
:
CanReuseItem
(
nsPaintedDisplayItem
*
aItem
const
wr
:
:
WrSpaceAndClipChain
&
aSpaceAndClip
)
{
auto
&
slotIndex
=
aItem
-
>
CacheIndex
(
)
;
if
(
!
slotIndex
)
{
return
Nothing
(
)
;
}
MOZ_ASSERT
(
slotIndex
&
&
CurrentSize
(
)
>
*
slotIndex
)
;
auto
&
slot
=
mSlots
[
*
slotIndex
]
;
if
(
!
slot
.
mOccupied
)
{
return
Nothing
(
)
;
}
if
(
!
(
aSpaceAndClip
=
=
slot
.
mSpaceAndClip
)
)
{
slot
.
mOccupied
=
false
;
aItem
-
>
SetCantBeCached
(
)
;
slotIndex
=
Nothing
(
)
;
}
else
{
slot
.
mUsed
=
true
;
}
return
slotIndex
;
}
}
}
