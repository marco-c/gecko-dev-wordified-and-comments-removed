#
include
"
DisplayItemCache
.
h
"
namespace
mozilla
{
namespace
layers
{
static
const
size_t
kInitialCacheSize
=
1024
;
static
const
size_t
kMaximumCacheSize
=
10240
;
static
const
size_t
kCacheThreshold
=
1
;
DisplayItemCache
:
:
DisplayItemCache
(
)
:
mMaximumSize
(
0
)
mConsecutivePartialDisplayLists
(
0
)
{
if
(
XRE_IsContentProcess
(
)
&
&
StaticPrefs
:
:
gfx_webrender_enable_item_cache_AtStartup
(
)
)
{
SetCapacity
(
kInitialCacheSize
kMaximumCacheSize
)
;
}
}
void
DisplayItemCache
:
:
ClearCache
(
)
{
memset
(
mSlots
.
Elements
(
)
0
mSlots
.
Length
(
)
*
sizeof
(
Slot
)
)
;
mFreeSlots
.
ClearAndRetainStorage
(
)
;
for
(
size_t
i
=
0
;
i
<
CurrentSize
(
)
;
+
+
i
)
{
mFreeSlots
.
AppendElement
(
i
)
;
}
}
Maybe
<
uint16_t
>
DisplayItemCache
:
:
GetNextFreeSlot
(
)
{
if
(
mFreeSlots
.
IsEmpty
(
)
&
&
!
GrowIfPossible
(
)
)
{
return
Nothing
(
)
;
}
return
Some
(
mFreeSlots
.
PopLastElement
(
)
)
;
}
bool
DisplayItemCache
:
:
GrowIfPossible
(
)
{
if
(
IsFull
(
)
)
{
return
false
;
}
const
auto
currentSize
=
CurrentSize
(
)
;
MOZ_ASSERT
(
currentSize
<
=
mMaximumSize
)
;
mSlots
.
AppendElement
(
)
;
mFreeSlots
.
AppendElement
(
currentSize
)
;
return
true
;
}
void
DisplayItemCache
:
:
FreeUnusedSlots
(
)
{
for
(
size_t
i
=
0
;
i
<
CurrentSize
(
)
;
+
+
i
)
{
auto
&
slot
=
mSlots
[
i
]
;
if
(
!
slot
.
mUsed
&
&
slot
.
mOccupied
)
{
slot
.
mOccupied
=
false
;
mFreeSlots
.
AppendElement
(
i
)
;
}
slot
.
mUsed
=
false
;
}
}
void
DisplayItemCache
:
:
SetCapacity
(
const
size_t
aInitialSize
const
size_t
aMaximumSize
)
{
mMaximumSize
=
aMaximumSize
;
mSlots
.
SetCapacity
(
aMaximumSize
)
;
mSlots
.
SetLength
(
aInitialSize
)
;
mFreeSlots
.
SetCapacity
(
aMaximumSize
)
;
ClearCache
(
)
;
}
Maybe
<
uint16_t
>
DisplayItemCache
:
:
AssignSlot
(
nsPaintedDisplayItem
*
aItem
)
{
if
(
kCacheThreshold
>
mConsecutivePartialDisplayLists
)
{
return
Nothing
(
)
;
}
if
(
!
aItem
-
>
CanBeReused
(
)
|
|
!
aItem
-
>
CanBeCached
(
)
)
{
return
Nothing
(
)
;
}
auto
&
slot
=
aItem
-
>
CacheIndex
(
)
;
if
(
!
slot
)
{
slot
=
GetNextFreeSlot
(
)
;
if
(
!
slot
)
{
return
Nothing
(
)
;
}
}
MOZ_ASSERT
(
slot
&
&
CurrentSize
(
)
>
*
slot
)
;
return
slot
;
}
void
DisplayItemCache
:
:
MarkSlotOccupied
(
uint16_t
aSlotIndex
const
wr
:
:
WrSpaceAndClipChain
&
aSpaceAndClip
)
{
auto
&
slot
=
mSlots
[
aSlotIndex
]
;
MOZ_ASSERT
(
!
slot
.
mOccupied
)
;
slot
.
mOccupied
=
true
;
MOZ_ASSERT
(
!
slot
.
mUsed
)
;
slot
.
mUsed
=
true
;
slot
.
mSpaceAndClip
=
aSpaceAndClip
;
}
Maybe
<
uint16_t
>
DisplayItemCache
:
:
CanReuseItem
(
nsPaintedDisplayItem
*
aItem
const
wr
:
:
WrSpaceAndClipChain
&
aSpaceAndClip
)
{
auto
&
slotIndex
=
aItem
-
>
CacheIndex
(
)
;
if
(
!
slotIndex
)
{
return
Nothing
(
)
;
}
MOZ_ASSERT
(
slotIndex
&
&
CurrentSize
(
)
>
*
slotIndex
)
;
auto
&
slot
=
mSlots
[
*
slotIndex
]
;
if
(
!
slot
.
mOccupied
)
{
return
Nothing
(
)
;
}
if
(
!
(
aSpaceAndClip
=
=
slot
.
mSpaceAndClip
)
)
{
slot
.
mOccupied
=
false
;
aItem
-
>
SetCantBeCached
(
)
;
slotIndex
=
Nothing
(
)
;
}
else
{
slot
.
mUsed
=
true
;
}
return
slotIndex
;
}
void
DisplayItemCache
:
:
UpdateState
(
const
bool
aPartialDisplayListBuildFailed
const
wr
:
:
PipelineId
&
aPipelineId
)
{
const
bool
pipelineIdChanged
=
UpdatePipelineId
(
aPipelineId
)
;
const
bool
invalidate
=
pipelineIdChanged
|
|
aPartialDisplayListBuildFailed
;
mConsecutivePartialDisplayLists
=
invalidate
?
0
:
mConsecutivePartialDisplayLists
+
1
;
if
(
IsEmpty
(
)
)
{
return
;
}
if
(
invalidate
)
{
ClearCache
(
)
;
}
else
{
FreeUnusedSlots
(
)
;
}
}
}
}
