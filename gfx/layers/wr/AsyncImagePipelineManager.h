#
ifndef
MOZILLA_GFX_WEBRENDERCOMPOSITABLE_HOLDER_H
#
define
MOZILLA_GFX_WEBRENDERCOMPOSITABLE_HOLDER_H
#
include
<
queue
>
#
include
"
CompositableHost
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderTypes
.
h
"
#
include
"
nsClassHashtable
.
h
"
namespace
mozilla
{
namespace
wr
{
class
DisplayListBuilder
;
class
WebRenderAPI
;
class
WebRenderPipelineInfo
;
}
namespace
layers
{
class
CompositableHost
;
class
CompositorVsyncScheduler
;
class
WebRenderImageHost
;
class
WebRenderTextureHost
;
class
AsyncImagePipelineManager
final
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
AsyncImagePipelineManager
)
explicit
AsyncImagePipelineManager
(
nsTArray
<
RefPtr
<
wr
:
:
WebRenderAPI
>
>
&
&
aApis
)
;
protected
:
~
AsyncImagePipelineManager
(
)
;
public
:
void
Destroy
(
)
;
void
AddPipeline
(
const
wr
:
:
PipelineId
&
aPipelineId
WebRenderBridgeParent
*
aWrBridge
)
;
void
RemovePipeline
(
const
wr
:
:
PipelineId
&
aPipelineId
const
wr
:
:
Epoch
&
aEpoch
)
;
WebRenderBridgeParent
*
GetWrBridge
(
const
wr
:
:
PipelineId
&
aPipelineId
)
;
void
HoldExternalImage
(
const
wr
:
:
PipelineId
&
aPipelineId
const
wr
:
:
Epoch
&
aEpoch
TextureHost
*
aTexture
)
;
void
HoldExternalImage
(
const
wr
:
:
PipelineId
&
aPipelineId
const
wr
:
:
Epoch
&
aEpoch
const
wr
:
:
ExternalImageId
&
aImageId
)
;
void
NotifyPipelinesUpdated
(
RefPtr
<
wr
:
:
WebRenderPipelineInfo
>
aInfo
bool
aRender
)
;
void
ProcessPipelineUpdates
(
)
;
TimeStamp
GetCompositionTime
(
)
const
{
return
mCompositionTime
;
}
void
SetCompositionTime
(
TimeStamp
aTimeStamp
)
{
mCompositionTime
=
aTimeStamp
;
if
(
!
mCompositionTime
.
IsNull
(
)
&
&
!
mCompositeUntilTime
.
IsNull
(
)
&
&
mCompositionTime
>
=
mCompositeUntilTime
)
{
mCompositeUntilTime
=
TimeStamp
(
)
;
}
}
void
CompositeUntil
(
TimeStamp
aTimeStamp
)
{
if
(
mCompositeUntilTime
.
IsNull
(
)
|
|
mCompositeUntilTime
<
aTimeStamp
)
{
mCompositeUntilTime
=
aTimeStamp
;
}
}
TimeStamp
GetCompositeUntilTime
(
)
const
{
return
mCompositeUntilTime
;
}
void
AddAsyncImagePipeline
(
const
wr
:
:
PipelineId
&
aPipelineId
WebRenderImageHost
*
aImageHost
wr
:
:
RenderRoot
aRenderRoot
)
;
void
RemoveAsyncImagePipeline
(
const
wr
:
:
PipelineId
&
aPipelineId
wr
:
:
TransactionBuilder
&
aTxn
)
;
void
UpdateAsyncImagePipeline
(
const
wr
:
:
PipelineId
&
aPipelineId
const
LayoutDeviceRect
&
aScBounds
const
gfx
:
:
Matrix4x4
&
aScTransform
const
gfx
:
:
MaybeIntSize
&
aScaleToSize
const
wr
:
:
ImageRendering
&
aFilter
const
wr
:
:
MixBlendMode
&
aMixBlendMode
)
;
void
ApplyAsyncImagesOfImageBridge
(
wr
:
:
RenderRootArray
<
Maybe
<
wr
:
:
TransactionBuilder
>
>
&
aSceneBuilderTxns
wr
:
:
RenderRootArray
<
Maybe
<
wr
:
:
TransactionBuilder
>
>
&
aFastTxns
)
;
void
ApplyAsyncImageForPipeline
(
const
wr
:
:
PipelineId
&
aPipelineId
wr
:
:
TransactionBuilder
&
aTxn
wr
:
:
TransactionBuilder
&
aTxnForImageBridge
wr
:
:
RenderRoot
aRenderRoot
)
;
void
SetEmptyDisplayList
(
const
wr
:
:
PipelineId
&
aPipelineId
wr
:
:
TransactionBuilder
&
aTxn
wr
:
:
TransactionBuilder
&
aTxnForImageBridge
)
;
void
AppendImageCompositeNotification
(
const
ImageCompositeNotificationInfo
&
aNotification
)
{
mImageCompositeNotifications
.
AppendElement
(
aNotification
)
;
}
void
FlushImageNotifications
(
nsTArray
<
ImageCompositeNotificationInfo
>
*
aNotifications
)
{
aNotifications
-
>
AppendElements
(
std
:
:
move
(
mImageCompositeNotifications
)
)
;
}
void
SetWillGenerateFrameAllRenderRoots
(
)
;
void
SetWillGenerateFrame
(
wr
:
:
RenderRoot
aRenderRoot
)
;
bool
GetAndResetWillGenerateFrame
(
wr
:
:
RenderRoot
aRenderRoot
)
;
wr
:
:
ExternalImageId
GetNextExternalImageId
(
)
;
private
:
void
ProcessPipelineRendered
(
const
wr
:
:
PipelineId
&
aPipelineId
const
wr
:
:
Epoch
&
aEpoch
const
uint64_t
aUpdatesCount
)
;
void
ProcessPipelineRemoved
(
const
wr
:
:
RemovedPipeline
&
aRemovedPipeline
const
uint64_t
aUpdatesCount
)
;
wr
:
:
Epoch
GetNextImageEpoch
(
)
;
uint32_t
GetNextResourceId
(
)
{
return
+
+
mResourceId
;
}
wr
:
:
IdNamespace
GetNamespace
(
)
{
return
mIdNamespace
;
}
wr
:
:
ImageKey
GenerateImageKey
(
)
{
wr
:
:
ImageKey
key
;
key
.
mNamespace
=
GetNamespace
(
)
;
key
.
mHandle
=
GetNextResourceId
(
)
;
return
key
;
}
struct
ForwardingTextureHost
{
ForwardingTextureHost
(
const
wr
:
:
Epoch
&
aEpoch
TextureHost
*
aTexture
)
:
mEpoch
(
aEpoch
)
mTexture
(
aTexture
)
{
}
wr
:
:
Epoch
mEpoch
;
CompositableTextureHostRef
mTexture
;
}
;
struct
ForwardingExternalImage
{
ForwardingExternalImage
(
const
wr
:
:
Epoch
&
aEpoch
const
wr
:
:
ExternalImageId
&
aImageId
)
:
mEpoch
(
aEpoch
)
mImageId
(
aImageId
)
{
}
~
ForwardingExternalImage
(
)
;
wr
:
:
Epoch
mEpoch
;
wr
:
:
ExternalImageId
mImageId
;
}
;
struct
PipelineTexturesHolder
{
std
:
:
queue
<
ForwardingTextureHost
>
mTextureHosts
;
std
:
:
queue
<
UniquePtr
<
ForwardingExternalImage
>
>
mExternalImages
;
Maybe
<
wr
:
:
Epoch
>
mDestroyedEpoch
;
WebRenderBridgeParent
*
MOZ_NON_OWNING_REF
mWrBridge
=
nullptr
;
}
;
struct
AsyncImagePipeline
{
AsyncImagePipeline
(
)
;
void
Update
(
const
LayoutDeviceRect
&
aScBounds
const
gfx
:
:
Matrix4x4
&
aScTransform
const
gfx
:
:
MaybeIntSize
&
aScaleToSize
const
wr
:
:
ImageRendering
&
aFilter
const
wr
:
:
MixBlendMode
&
aMixBlendMode
)
{
mIsChanged
|
=
!
mScBounds
.
IsEqualEdges
(
aScBounds
)
|
|
mScTransform
!
=
aScTransform
|
|
mScaleToSize
!
=
aScaleToSize
|
|
mFilter
!
=
aFilter
|
|
mMixBlendMode
!
=
aMixBlendMode
;
mScBounds
=
aScBounds
;
mScTransform
=
aScTransform
;
mScaleToSize
=
aScaleToSize
;
mFilter
=
aFilter
;
mMixBlendMode
=
aMixBlendMode
;
}
bool
mInitialised
;
wr
:
:
RenderRoot
mRenderRoot
;
bool
mIsChanged
;
bool
mUseExternalImage
;
LayoutDeviceRect
mScBounds
;
gfx
:
:
Matrix4x4
mScTransform
;
gfx
:
:
MaybeIntSize
mScaleToSize
;
wr
:
:
ImageRendering
mFilter
;
wr
:
:
MixBlendMode
mMixBlendMode
;
RefPtr
<
WebRenderImageHost
>
mImageHost
;
CompositableTextureHostRef
mCurrentTexture
;
nsTArray
<
wr
:
:
ImageKey
>
mKeys
;
}
;
void
ApplyAsyncImageForPipeline
(
const
wr
:
:
Epoch
&
aEpoch
const
wr
:
:
PipelineId
&
aPipelineId
AsyncImagePipeline
*
aPipeline
wr
:
:
TransactionBuilder
&
aSceneBuilderTxn
wr
:
:
TransactionBuilder
&
aMaybeFastTxn
)
;
Maybe
<
TextureHost
:
:
ResourceUpdateOp
>
UpdateImageKeys
(
const
wr
:
:
Epoch
&
aEpoch
const
wr
:
:
PipelineId
&
aPipelineId
AsyncImagePipeline
*
aPipeline
nsTArray
<
wr
:
:
ImageKey
>
&
aKeys
wr
:
:
TransactionBuilder
&
aSceneBuilderTxn
wr
:
:
TransactionBuilder
&
aMaybeFastTxn
)
;
Maybe
<
TextureHost
:
:
ResourceUpdateOp
>
UpdateWithoutExternalImage
(
TextureHost
*
aTexture
wr
:
:
ImageKey
aKey
TextureHost
:
:
ResourceUpdateOp
wr
:
:
TransactionBuilder
&
aTxn
)
;
void
HoldUntilNotUsedByGPU
(
const
CompositableTextureHostRef
&
aTextureHost
uint64_t
aUpdatesCount
)
;
void
CheckForTextureHostsNotUsedByGPU
(
)
;
nsTArray
<
RefPtr
<
wr
:
:
WebRenderAPI
>
>
mApis
;
const
wr
:
:
IdNamespace
mIdNamespace
;
const
bool
mUseTripleBuffering
;
uint32_t
mResourceId
;
nsClassHashtable
<
nsUint64HashKey
PipelineTexturesHolder
>
mPipelineTexturesHolders
;
nsClassHashtable
<
nsUint64HashKey
AsyncImagePipeline
>
mAsyncImagePipelines
;
wr
:
:
Epoch
mAsyncImageEpoch
;
wr
:
:
RenderRootArray
<
bool
>
mWillGenerateFrame
;
bool
mDestroyed
;
TimeStamp
mCompositionTime
;
TimeStamp
mCompositeUntilTime
;
nsTArray
<
ImageCompositeNotificationInfo
>
mImageCompositeNotifications
;
Mutex
mUpdatesLock
;
Atomic
<
uint64_t
>
mUpdatesCount
;
struct
PipelineUpdates
{
PipelineUpdates
(
RefPtr
<
wr
:
:
WebRenderPipelineInfo
>
aPipelineInfo
const
uint64_t
aUpdatesCount
const
bool
aRendered
)
;
bool
NeedsToWait
(
const
uint64_t
aUpdatesCount
)
{
MOZ_ASSERT
(
mUpdatesCount
<
=
aUpdatesCount
)
;
if
(
mUpdatesCount
=
=
aUpdatesCount
&
&
!
mRendered
)
{
return
true
;
}
return
false
;
}
RefPtr
<
wr
:
:
WebRenderPipelineInfo
>
mPipelineInfo
;
const
uint64_t
mUpdatesCount
;
const
bool
mRendered
;
}
;
std
:
:
queue
<
UniquePtr
<
PipelineUpdates
>
>
mUpdatesQueues
;
std
:
:
queue
<
std
:
:
pair
<
uint64_t
CompositableTextureHostRef
>
>
mTexturesInUseByGPU
;
}
;
}
}
#
endif
