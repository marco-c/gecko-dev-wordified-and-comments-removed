#
include
"
mozilla
/
layers
/
OMTASampler
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
layers
/
CompositorAnimationStorage
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
SynchronousTask
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderBridgeParent
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
namespace
mozilla
{
namespace
layers
{
StaticMutex
OMTASampler
:
:
sWindowIdLock
;
StaticAutoPtr
<
std
:
:
unordered_map
<
uint64_t
RefPtr
<
OMTASampler
>
>
>
OMTASampler
:
:
sWindowIdMap
;
OMTASampler
:
:
OMTASampler
(
const
RefPtr
<
CompositorAnimationStorage
>
&
aAnimStorage
)
:
mAnimStorage
(
aAnimStorage
)
mStorageLock
(
"
OMTASampler
:
:
mStorageLock
"
)
mThreadIdLock
(
"
OMTASampler
:
:
mThreadIdLock
"
)
mSampleTimeLock
(
"
OMTASampler
:
:
mSampleTimeLock
"
)
{
}
void
OMTASampler
:
:
Destroy
(
)
{
StaticMutexAutoLock
lock
(
sWindowIdLock
)
;
if
(
mWindowId
)
{
MOZ_ASSERT
(
sWindowIdMap
)
;
sWindowIdMap
-
>
erase
(
wr
:
:
AsUint64
(
*
mWindowId
)
)
;
}
}
void
OMTASampler
:
:
SetWebRenderWindowId
(
const
wr
:
:
WindowId
&
aWindowId
)
{
StaticMutexAutoLock
lock
(
sWindowIdLock
)
;
MOZ_ASSERT
(
!
mWindowId
)
;
mWindowId
=
Some
(
aWindowId
)
;
if
(
!
sWindowIdMap
)
{
sWindowIdMap
=
new
std
:
:
unordered_map
<
uint64_t
RefPtr
<
OMTASampler
>
>
(
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
OMTASampler
:
:
ClearOnShutdown
"
[
]
{
ClearOnShutdown
(
&
sWindowIdMap
)
;
}
)
)
;
}
(
*
sWindowIdMap
)
[
wr
:
:
AsUint64
(
aWindowId
)
]
=
this
;
}
void
OMTASampler
:
:
SetSamplerThread
(
const
wr
:
:
WrWindowId
&
aWindowId
)
{
if
(
RefPtr
<
OMTASampler
>
sampler
=
GetSampler
(
aWindowId
)
)
{
MutexAutoLock
lock
(
sampler
-
>
mThreadIdLock
)
;
sampler
-
>
mSamplerThreadId
=
Some
(
PlatformThread
:
:
CurrentId
(
)
)
;
}
}
void
OMTASampler
:
:
Sample
(
const
wr
:
:
WrWindowId
&
aWindowId
wr
:
:
Transaction
*
aTransaction
)
{
if
(
RefPtr
<
OMTASampler
>
sampler
=
GetSampler
(
aWindowId
)
)
{
wr
:
:
TransactionWrapper
txn
(
aTransaction
)
;
sampler
-
>
Sample
(
txn
)
;
}
}
void
OMTASampler
:
:
SetSampleTime
(
const
TimeStamp
&
aSampleTime
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
const
bool
hasAnimations
=
HasAnimations
(
)
;
MutexAutoLock
lock
(
mSampleTimeLock
)
;
mPreviousSampleTime
=
hasAnimations
?
std
:
:
move
(
mSampleTime
)
:
TimeStamp
(
)
;
mSampleTime
=
aSampleTime
;
}
void
OMTASampler
:
:
ResetPreviousSampleTime
(
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
MutexAutoLock
lock
(
mSampleTimeLock
)
;
mPreviousSampleTime
=
TimeStamp
(
)
;
}
void
OMTASampler
:
:
Sample
(
wr
:
:
TransactionWrapper
&
aTxn
)
{
MOZ_ASSERT
(
IsSamplerThread
(
)
)
;
TimeStamp
sampleTime
;
TimeStamp
previousSampleTime
;
{
MutexAutoLock
lock
(
mSampleTimeLock
)
;
sampleTime
=
mSampleTime
.
IsNull
(
)
?
TimeStamp
:
:
Now
(
)
:
mSampleTime
;
previousSampleTime
=
mPreviousSampleTime
;
}
WrAnimations
animations
=
SampleAnimations
(
previousSampleTime
sampleTime
)
;
aTxn
.
UpdateDynamicProperties
(
animations
.
mOpacityArrays
animations
.
mTransformArrays
animations
.
mColorArrays
)
;
}
WrAnimations
OMTASampler
:
:
SampleAnimations
(
const
TimeStamp
&
aPreviousSampleTime
const
TimeStamp
&
aSampleTime
)
{
MOZ_ASSERT
(
IsSamplerThread
(
)
)
;
MutexAutoLock
lock
(
mStorageLock
)
;
mAnimStorage
-
>
SampleAnimations
(
aPreviousSampleTime
aSampleTime
)
;
return
mAnimStorage
-
>
CollectWebRenderAnimations
(
)
;
}
OMTAValue
OMTASampler
:
:
GetOMTAValue
(
const
uint64_t
&
aId
)
const
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
MutexAutoLock
lock
(
mStorageLock
)
;
return
mAnimStorage
-
>
GetOMTAValue
(
aId
)
;
}
void
OMTASampler
:
:
SampleForTesting
(
const
Maybe
<
TimeStamp
>
&
aTestingSampleTime
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
TimeStamp
sampleTime
;
TimeStamp
previousSampleTime
;
{
MutexAutoLock
timeLock
(
mSampleTimeLock
)
;
if
(
aTestingSampleTime
)
{
sampleTime
=
*
aTestingSampleTime
;
previousSampleTime
=
*
aTestingSampleTime
;
}
else
{
sampleTime
=
mSampleTime
;
previousSampleTime
=
mPreviousSampleTime
;
}
}
MutexAutoLock
storageLock
(
mStorageLock
)
;
mAnimStorage
-
>
SampleAnimations
(
previousSampleTime
sampleTime
)
;
}
void
OMTASampler
:
:
SetAnimations
(
uint64_t
aId
const
LayersId
&
aLayersId
const
nsTArray
<
layers
:
:
Animation
>
&
aAnimations
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
MutexAutoLock
lock
(
mStorageLock
)
;
mAnimStorage
-
>
SetAnimations
(
aId
aLayersId
aAnimations
)
;
}
bool
OMTASampler
:
:
HasAnimations
(
)
const
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
MutexAutoLock
lock
(
mStorageLock
)
;
return
mAnimStorage
-
>
HasAnimations
(
)
;
}
void
OMTASampler
:
:
ClearActiveAnimations
(
std
:
:
unordered_map
<
uint64_t
wr
:
:
Epoch
>
&
aActiveAnimations
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
MutexAutoLock
lock
(
mStorageLock
)
;
for
(
const
auto
&
id
:
aActiveAnimations
)
{
mAnimStorage
-
>
ClearById
(
id
.
first
)
;
}
}
void
OMTASampler
:
:
RemoveEpochDataPriorTo
(
std
:
:
queue
<
CompositorAnimationIdsForEpoch
>
&
aCompositorAnimationsToDelete
std
:
:
unordered_map
<
uint64_t
wr
:
:
Epoch
>
&
aActiveAnimations
const
wr
:
:
Epoch
&
aRenderedEpoch
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
MutexAutoLock
lock
(
mStorageLock
)
;
while
(
!
aCompositorAnimationsToDelete
.
empty
(
)
)
{
if
(
aRenderedEpoch
<
aCompositorAnimationsToDelete
.
front
(
)
.
mEpoch
)
{
break
;
}
for
(
uint64_t
id
:
aCompositorAnimationsToDelete
.
front
(
)
.
mIds
)
{
const
auto
activeAnim
=
aActiveAnimations
.
find
(
id
)
;
if
(
activeAnim
=
=
aActiveAnimations
.
end
(
)
)
{
NS_ERROR
(
"
Tried
to
delete
invalid
animation
"
)
;
continue
;
}
if
(
activeAnim
-
>
second
<
=
aCompositorAnimationsToDelete
.
front
(
)
.
mEpoch
)
{
mAnimStorage
-
>
ClearById
(
id
)
;
aActiveAnimations
.
erase
(
activeAnim
)
;
}
}
aCompositorAnimationsToDelete
.
pop
(
)
;
}
}
bool
OMTASampler
:
:
IsSamplerThread
(
)
const
{
MutexAutoLock
lock
(
mThreadIdLock
)
;
return
mSamplerThreadId
&
&
PlatformThread
:
:
CurrentId
(
)
=
=
*
mSamplerThreadId
;
}
already_AddRefed
<
OMTASampler
>
OMTASampler
:
:
GetSampler
(
const
wr
:
:
WrWindowId
&
aWindowId
)
{
RefPtr
<
OMTASampler
>
sampler
;
StaticMutexAutoLock
lock
(
sWindowIdLock
)
;
if
(
sWindowIdMap
)
{
auto
it
=
sWindowIdMap
-
>
find
(
wr
:
:
AsUint64
(
aWindowId
)
)
;
if
(
it
!
=
sWindowIdMap
-
>
end
(
)
)
{
sampler
=
it
-
>
second
;
}
}
return
sampler
.
forget
(
)
;
}
}
}
void
omta_register_sampler
(
mozilla
:
:
wr
:
:
WrWindowId
aWindowId
)
{
mozilla
:
:
layers
:
:
OMTASampler
:
:
SetSamplerThread
(
aWindowId
)
;
}
void
omta_sample
(
mozilla
:
:
wr
:
:
WrWindowId
aWindowId
mozilla
:
:
wr
:
:
Transaction
*
aTransaction
)
{
mozilla
:
:
layers
:
:
OMTASampler
:
:
Sample
(
aWindowId
aTransaction
)
;
}
void
omta_deregister_sampler
(
mozilla
:
:
wr
:
:
WrWindowId
aWindowId
)
{
}
