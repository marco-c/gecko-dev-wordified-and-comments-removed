#
ifndef
GFX_DISPLAY_ITEM_CACHE_H
#
define
GFX_DISPLAY_ITEM_CACHE_H
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
nsTArray
.
h
"
class
nsPaintedDisplayItem
;
namespace
mozilla
{
namespace
wr
{
class
DisplayListBuilder
;
}
namespace
layers
{
class
CacheStats
{
public
:
CacheStats
(
)
=
default
;
void
Reset
(
)
{
mCached
=
mReused
=
mTotal
=
0
;
}
void
Print
(
)
{
printf
(
"
Cached
:
%
zu
Reused
:
%
zu
Total
:
%
zu
\
n
"
mCached
mReused
mTotal
)
;
}
void
AddCached
(
)
{
mCached
+
+
;
}
void
AddReused
(
)
{
mReused
+
+
;
}
void
AddTotal
(
)
{
mTotal
+
+
;
}
private
:
size_t
mCached
=
0
;
size_t
mReused
=
0
;
size_t
mTotal
=
0
;
}
;
class
DisplayItemCache
final
{
public
:
DisplayItemCache
(
)
:
mMaxCacheSize
(
0
)
mNextIndex
(
0
)
{
}
bool
IsEnabled
(
)
const
{
return
mMaxCacheSize
>
0
;
}
void
UpdateState
(
const
bool
aPartialDisplayListBuildFailed
const
wr
:
:
PipelineId
&
aPipelineId
)
;
size_t
CurrentCacheSize
(
)
const
{
return
IsEnabled
(
)
?
mCachedItemState
.
Length
(
)
:
0
;
}
void
SetCapacity
(
const
size_t
aInitialSize
const
size_t
aMaxSize
)
{
mMaxCacheSize
=
aMaxSize
;
mCachedItemState
.
SetCapacity
(
aMaxSize
)
;
mCachedItemState
.
SetLength
(
aInitialSize
)
;
mFreeList
.
SetCapacity
(
aMaxSize
)
;
}
void
MaybeStartCaching
(
nsPaintedDisplayItem
*
aItem
wr
:
:
DisplayListBuilder
&
aBuilder
)
;
void
MaybeEndCaching
(
wr
:
:
DisplayListBuilder
&
aBuilder
)
;
bool
ReuseItem
(
nsPaintedDisplayItem
*
aItem
wr
:
:
DisplayListBuilder
&
aBuilder
)
;
CacheStats
&
Stats
(
)
{
return
mCacheStats
;
}
private
:
struct
CacheEntry
{
wr
:
:
WrSpaceAndClipChain
mSpaceAndClip
;
bool
mCached
;
bool
mUsed
;
}
;
Maybe
<
uint16_t
>
GetNextCacheIndex
(
)
{
if
(
mFreeList
.
IsEmpty
(
)
)
{
return
Nothing
(
)
;
}
return
Some
(
mFreeList
.
PopLastElement
(
)
)
;
}
void
PopulateFreeList
(
const
bool
aAddAll
)
;
bool
UpdatePipelineId
(
const
wr
:
:
PipelineId
&
aPipelineId
)
{
const
bool
isSame
=
mPreviousPipelineId
.
refOr
(
aPipelineId
)
=
=
aPipelineId
;
mPreviousPipelineId
=
Some
(
aPipelineId
)
;
return
!
isSame
;
}
nsTArray
<
CacheEntry
>
mCachedItemState
;
nsTArray
<
uint16_t
>
mFreeList
;
size_t
mMaxCacheSize
;
uint16_t
mNextIndex
;
Maybe
<
uint16_t
>
mCurrentIndex
;
Maybe
<
wr
:
:
PipelineId
>
mPreviousPipelineId
;
CacheStats
mCacheStats
;
}
;
}
}
#
endif
