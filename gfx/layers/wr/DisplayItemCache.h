#
ifndef
GFX_DISPLAY_ITEM_CACHE_H
#
define
GFX_DISPLAY_ITEM_CACHE_H
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
class
nsDisplayList
;
class
nsDisplayListBuilder
;
class
nsPaintedDisplayItem
;
namespace
wr
{
class
DisplayListBuilder
;
}
namespace
layers
{
class
CacheStats
{
public
:
CacheStats
(
)
=
default
;
void
Reset
(
)
{
mCached
=
mReused
=
mTotal
=
0
;
}
void
Print
(
)
{
static
uint64_t
avgC
=
1
;
static
uint64_t
avgR
=
1
;
static
uint64_t
avgT
=
1
;
avgC
+
=
mCached
;
avgR
+
=
mReused
;
avgT
+
=
mTotal
;
printf
(
"
Cached
:
%
zu
(
avg
:
%
f
)
Reused
:
%
zu
(
avg
:
%
f
)
Total
:
%
zu
\
n
"
mCached
(
double
)
avgC
/
(
double
)
avgT
mReused
(
double
)
avgR
/
(
double
)
avgT
mTotal
)
;
}
void
AddCached
(
)
{
mCached
+
+
;
}
void
AddReused
(
)
{
mReused
+
+
;
}
void
AddTotal
(
)
{
mTotal
+
+
;
}
private
:
size_t
mCached
=
0
;
size_t
mReused
=
0
;
size_t
mTotal
=
0
;
}
;
class
DisplayItemCache
final
{
public
:
DisplayItemCache
(
)
;
void
Clear
(
)
;
void
SetCapacity
(
const
size_t
aInitialSize
const
size_t
aMaximumSize
)
;
void
SetDisplayList
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
)
;
void
SetPipelineId
(
const
wr
:
:
PipelineId
&
aPipelineId
)
;
void
SkipWaitingForPartialDisplayList
(
)
{
mCaching
=
mDisplayList
&
&
!
mInvalid
;
}
bool
IsEnabled
(
)
const
{
return
!
mSuppressed
&
&
mMaximumSize
>
0
;
}
bool
SetSuppressed
(
bool
aSuppressed
)
{
if
(
aSuppressed
=
=
mSuppressed
)
{
return
mSuppressed
;
}
mSuppressed
=
aSuppressed
;
return
!
mSuppressed
;
}
bool
IsEmpty
(
)
const
{
return
mFreeSlots
.
Length
(
)
=
=
CurrentSize
(
)
;
}
bool
IsFull
(
)
const
{
return
mFreeSlots
.
IsEmpty
(
)
&
&
CurrentSize
(
)
=
=
mMaximumSize
;
}
size_t
CurrentSize
(
)
const
{
return
mSlots
.
Length
(
)
;
}
Maybe
<
uint16_t
>
AssignSlot
(
nsPaintedDisplayItem
*
aItem
)
;
void
MarkSlotOccupied
(
uint16_t
slotIndex
const
wr
:
:
WrSpaceAndClipChain
&
aSpaceAndClip
)
;
Maybe
<
uint16_t
>
CanReuseItem
(
nsPaintedDisplayItem
*
aItem
const
wr
:
:
WrSpaceAndClipChain
&
aSpaceAndClip
)
;
CacheStats
&
Stats
(
)
{
return
mCacheStats
;
}
private
:
struct
Slot
{
Slot
(
)
:
mSpaceAndClip
{
}
mOccupied
(
false
)
mUsed
(
false
)
{
}
wr
:
:
WrSpaceAndClipChain
mSpaceAndClip
;
bool
mOccupied
;
bool
mUsed
;
}
;
void
FreeUnusedSlots
(
)
;
Maybe
<
uint16_t
>
GetNextFreeSlot
(
)
;
bool
GrowIfPossible
(
)
;
void
UpdateState
(
)
;
nsDisplayList
*
mDisplayList
;
size_t
mMaximumSize
;
nsTArray
<
Slot
>
mSlots
;
nsTArray
<
uint16_t
>
mFreeSlots
;
wr
:
:
PipelineId
mPipelineId
;
bool
mCaching
;
bool
mInvalid
;
bool
mSuppressed
;
CacheStats
mCacheStats
;
}
;
class
MOZ_RAII
AutoDisplayItemCacheSuppressor
{
public
:
explicit
AutoDisplayItemCacheSuppressor
(
DisplayItemCache
*
aCache
)
:
mCache
(
aCache
)
{
mWasSuppressed
=
mCache
-
>
SetSuppressed
(
true
)
;
}
~
AutoDisplayItemCacheSuppressor
(
)
{
mCache
-
>
SetSuppressed
(
mWasSuppressed
)
;
}
private
:
DisplayItemCache
*
mCache
;
bool
mWasSuppressed
;
}
;
}
}
#
endif
