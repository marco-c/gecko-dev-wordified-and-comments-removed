#
ifndef
GFX_DISPLAY_ITEM_CACHE_H
#
define
GFX_DISPLAY_ITEM_CACHE_H
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
nsTArray
.
h
"
class
nsPaintedDisplayItem
;
namespace
mozilla
{
namespace
wr
{
class
DisplayListBuilder
;
}
namespace
layers
{
class
CacheStats
{
public
:
CacheStats
(
)
=
default
;
void
Reset
(
)
{
mCached
=
mReused
=
mTotal
=
0
;
}
void
Print
(
)
{
static
uint64_t
avgC
=
1
;
static
uint64_t
avgR
=
1
;
static
uint64_t
avgT
=
1
;
avgC
+
=
mCached
;
avgR
+
=
mReused
;
avgT
+
=
mTotal
;
printf
(
"
Cached
:
%
zu
(
avg
:
%
f
)
Reused
:
%
zu
(
avg
:
%
f
)
Total
:
%
zu
\
n
"
mCached
(
double
)
avgC
/
(
double
)
avgT
mReused
(
double
)
avgR
/
(
double
)
avgT
mTotal
)
;
}
void
AddCached
(
)
{
mCached
+
+
;
}
void
AddReused
(
)
{
mReused
+
+
;
}
void
AddTotal
(
)
{
mTotal
+
+
;
}
private
:
size_t
mCached
=
0
;
size_t
mReused
=
0
;
size_t
mTotal
=
0
;
}
;
class
DisplayItemCache
final
{
public
:
DisplayItemCache
(
)
;
bool
IsEnabled
(
)
const
{
return
mMaximumSize
>
0
;
}
bool
IsEmpty
(
)
const
{
return
mFreeSlots
.
Length
(
)
=
=
CurrentSize
(
)
;
}
bool
IsFull
(
)
const
{
return
mFreeSlots
.
IsEmpty
(
)
&
&
CurrentSize
(
)
=
=
mMaximumSize
;
}
void
UpdateState
(
const
bool
aPartialDisplayListBuildFailed
const
wr
:
:
PipelineId
&
aPipelineId
)
;
size_t
CurrentSize
(
)
const
{
return
mSlots
.
Length
(
)
;
}
Maybe
<
uint16_t
>
AssignSlot
(
nsPaintedDisplayItem
*
aItem
)
;
void
MarkSlotOccupied
(
uint16_t
slotIndex
const
wr
:
:
WrSpaceAndClipChain
&
aSpaceAndClip
)
;
Maybe
<
uint16_t
>
CanReuseItem
(
nsPaintedDisplayItem
*
aItem
const
wr
:
:
WrSpaceAndClipChain
&
aSpaceAndClip
)
;
CacheStats
&
Stats
(
)
{
return
mCacheStats
;
}
private
:
struct
Slot
{
Slot
(
)
:
mSpaceAndClip
{
}
mOccupied
(
false
)
mUsed
(
false
)
{
}
wr
:
:
WrSpaceAndClipChain
mSpaceAndClip
;
bool
mOccupied
;
bool
mUsed
;
}
;
void
ClearCache
(
)
;
void
FreeUnusedSlots
(
)
;
bool
GrowIfPossible
(
)
;
Maybe
<
uint16_t
>
GetNextFreeSlot
(
)
;
void
SetCapacity
(
const
size_t
aInitialSize
const
size_t
aMaximumSize
)
;
bool
UpdatePipelineId
(
const
wr
:
:
PipelineId
&
aPipelineId
)
{
const
bool
isSame
=
mPreviousPipelineId
.
refOr
(
aPipelineId
)
=
=
aPipelineId
;
mPreviousPipelineId
=
Some
(
aPipelineId
)
;
return
!
isSame
;
}
size_t
mMaximumSize
;
nsTArray
<
Slot
>
mSlots
;
nsTArray
<
uint16_t
>
mFreeSlots
;
Maybe
<
wr
:
:
PipelineId
>
mPreviousPipelineId
;
size_t
mConsecutivePartialDisplayLists
;
CacheStats
mCacheStats
;
}
;
}
}
#
endif
