#
ifndef
MOZILLA_GFX_WEBRENDERIMAGEHOST_H
#
define
MOZILLA_GFX_WEBRENDERIMAGEHOST_H
#
include
<
deque
>
#
include
<
unordered_map
>
#
include
"
CompositableHost
.
h
"
#
include
"
mozilla
/
layers
/
ImageComposite
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
webrender
/
RenderTextureHost
.
h
"
namespace
mozilla
{
namespace
layers
{
class
AsyncImagePipelineManager
;
class
TextureWrapperD3D11Allocator
;
class
WebRenderBridgeParent
;
class
WebRenderBridgeParentRef
;
class
WebRenderImageHost
:
public
CompositableHost
public
ImageComposite
{
public
:
explicit
WebRenderImageHost
(
const
TextureInfo
&
aTextureInfo
)
;
virtual
~
WebRenderImageHost
(
)
;
void
UseTextureHost
(
const
nsTArray
<
TimedTexture
>
&
aTextures
)
override
;
void
RemoveTextureHost
(
TextureHost
*
aTexture
)
override
;
void
Dump
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
=
"
"
bool
aDumpHtml
=
false
)
override
;
void
CleanupResources
(
)
override
;
void
OnReleased
(
)
override
;
uint32_t
GetDroppedFrames
(
)
override
{
return
GetDroppedFramesAndReset
(
)
;
}
WebRenderImageHost
*
AsWebRenderImageHost
(
)
override
{
return
this
;
}
void
PushPendingRemoteTexture
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
const
gfx
:
:
IntSize
aSize
const
TextureFlags
aFlags
)
;
void
UseRemoteTexture
(
)
;
TextureHost
*
GetAsTextureHostForComposite
(
AsyncImagePipelineManager
*
aAsyncImageManager
)
;
void
SetWrBridge
(
const
wr
:
:
PipelineId
&
aPipelineId
WebRenderBridgeParent
*
aWrBridge
)
;
void
ClearWrBridge
(
const
wr
:
:
PipelineId
&
aPipelineId
WebRenderBridgeParent
*
aWrBridge
)
;
TextureHost
*
GetCurrentTextureHost
(
)
{
return
mCurrentTextureHost
;
}
void
SetRenderTextureHostUsageInfo
(
RefPtr
<
wr
:
:
RenderTextureHostUsageInfo
>
aUsageInfo
)
{
mRenderTextureHostUsageInfo
=
aUsageInfo
;
}
RefPtr
<
wr
:
:
RenderTextureHostUsageInfo
>
GetRenderTextureHostUsageInfo
(
)
const
{
return
mRenderTextureHostUsageInfo
;
}
protected
:
TimeStamp
GetCompositionTime
(
)
const
override
;
CompositionOpportunityId
GetCompositionOpportunityId
(
)
const
override
;
void
AppendImageCompositeNotification
(
const
ImageCompositeNotificationInfo
&
aInfo
)
const
override
;
void
SetCurrentTextureHost
(
TextureHost
*
aTexture
)
;
std
:
:
unordered_map
<
uint64_t
RefPtr
<
WebRenderBridgeParentRef
>
>
mWrBridges
;
AsyncImagePipelineManager
*
mCurrentAsyncImageManager
;
CompositableTextureHostRef
mCurrentTextureHost
;
std
:
:
deque
<
CompositableTextureHostRef
>
mPendingRemoteTextureWrappers
;
bool
mWaitingReadyCallback
=
false
;
bool
mWaitForRemoteTextureOwner
=
true
;
RefPtr
<
wr
:
:
RenderTextureHostUsageInfo
>
mRenderTextureHostUsageInfo
;
#
if
XP_WIN
RefPtr
<
TextureWrapperD3D11Allocator
>
mTextureAllocator
;
#
endif
}
;
}
}
#
endif
