#
include
"
WebRenderCommandBuilder
.
h
"
#
include
"
BasicLayers
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
gfx
/
DrawEventRecorder
.
h
"
#
include
"
mozilla
/
layers
/
ImageClient
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
layers
/
IpcResourceUpdateQueue
.
h
"
#
include
"
mozilla
/
layers
/
ScrollingLayersHelper
.
h
"
#
include
"
mozilla
/
layers
/
StackingContextHelper
.
h
"
#
include
"
mozilla
/
layers
/
UpdateImageHelper
.
h
"
#
include
"
gfxEnv
.
h
"
#
include
"
nsDisplayListInvalidation
.
h
"
#
include
"
WebRenderCanvasRenderer
.
h
"
#
include
"
LayersLogging
.
h
"
#
include
"
LayerTreeInvalidation
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
gfx
;
void
WebRenderCommandBuilder
:
:
Destroy
(
)
{
mLastCanvasDatas
.
Clear
(
)
;
RemoveUnusedAndResetWebRenderUserData
(
)
;
MOZ_RELEASE_ASSERT
(
mWebRenderUserDatas
.
Count
(
)
=
=
0
)
;
}
void
WebRenderCommandBuilder
:
:
EmptyTransaction
(
)
{
for
(
auto
iter
=
mLastCanvasDatas
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
WebRenderCanvasData
>
canvasData
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
WebRenderCanvasRendererAsync
*
canvas
=
canvasData
-
>
GetCanvasRenderer
(
)
;
if
(
canvas
)
{
canvas
-
>
UpdateCompositableClient
(
)
;
}
}
}
bool
WebRenderCommandBuilder
:
:
NeedsEmptyTransaction
(
)
{
return
!
mLastCanvasDatas
.
IsEmpty
(
)
;
}
void
WebRenderCommandBuilder
:
:
BuildWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResourceUpdates
nsDisplayList
*
aDisplayList
nsDisplayListBuilder
*
aDisplayListBuilder
WebRenderScrollData
&
aScrollData
wr
:
:
LayoutSize
&
aContentSize
const
nsTArray
<
wr
:
:
WrFilterOp
>
&
aFilters
)
{
{
StackingContextHelper
sc
;
mParentCommands
.
Clear
(
)
;
aScrollData
=
WebRenderScrollData
(
mManager
)
;
MOZ_ASSERT
(
mLayerScrollData
.
empty
(
)
)
;
mLastCanvasDatas
.
Clear
(
)
;
mLastAsr
=
nullptr
;
mScrollingHelper
.
BeginBuild
(
mManager
aBuilder
)
;
{
StackingContextHelper
pageRootSc
(
sc
aBuilder
aFilters
)
;
CreateWebRenderCommandsFromDisplayList
(
aDisplayList
aDisplayListBuilder
pageRootSc
aBuilder
aResourceUpdates
)
;
}
mLayerScrollData
.
emplace_back
(
)
;
mLayerScrollData
.
back
(
)
.
InitializeRoot
(
mLayerScrollData
.
size
(
)
-
1
)
;
auto
callback
=
[
&
aScrollData
]
(
FrameMetrics
:
:
ViewID
aScrollId
)
-
>
bool
{
return
aScrollData
.
HasMetadataFor
(
aScrollId
)
.
isSome
(
)
;
}
;
if
(
Maybe
<
ScrollMetadata
>
rootMetadata
=
nsLayoutUtils
:
:
GetRootMetadata
(
aDisplayListBuilder
mManager
ContainerLayerParameters
(
)
callback
)
)
{
mLayerScrollData
.
back
(
)
.
AppendScrollMetadata
(
aScrollData
rootMetadata
.
ref
(
)
)
;
}
for
(
auto
i
=
mLayerScrollData
.
crbegin
(
)
;
i
!
=
mLayerScrollData
.
crend
(
)
;
i
+
+
)
{
aScrollData
.
AddLayerData
(
*
i
)
;
}
mLayerScrollData
.
clear
(
)
;
mScrollingHelper
.
EndBuild
(
)
;
RemoveUnusedAndResetWebRenderUserData
(
)
;
}
mManager
-
>
WrBridge
(
)
-
>
AddWebRenderParentCommands
(
mParentCommands
)
;
}
void
WebRenderCommandBuilder
:
:
CreateWebRenderCommandsFromDisplayList
(
nsDisplayList
*
aDisplayList
nsDisplayListBuilder
*
aDisplayListBuilder
const
StackingContextHelper
&
aSc
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
)
{
mScrollingHelper
.
BeginList
(
aSc
)
;
bool
apzEnabled
=
mManager
-
>
AsyncPanZoomEnabled
(
)
;
EventRegions
eventRegions
;
FlattenedDisplayItemIterator
iter
(
aDisplayListBuilder
aDisplayList
)
;
while
(
nsDisplayItem
*
i
=
iter
.
GetNext
(
)
)
{
nsDisplayItem
*
item
=
i
;
DisplayItemType
itemType
=
item
-
>
GetType
(
)
;
if
(
itemType
=
=
DisplayItemType
:
:
TYPE_LAYER_EVENT_REGIONS
)
{
nsDisplayLayerEventRegions
*
eventRegions
=
static_cast
<
nsDisplayLayerEventRegions
*
>
(
item
)
;
if
(
eventRegions
-
>
IsEmpty
(
)
)
{
continue
;
}
}
AutoTArray
<
nsDisplayItem
*
1
>
mergedItems
;
mergedItems
.
AppendElement
(
item
)
;
while
(
nsDisplayItem
*
peek
=
iter
.
PeekNext
(
)
)
{
if
(
!
item
-
>
CanMerge
(
peek
)
)
{
break
;
}
mergedItems
.
AppendElement
(
peek
)
;
i
=
iter
.
GetNext
(
)
;
}
if
(
mergedItems
.
Length
(
)
>
1
)
{
item
=
aDisplayListBuilder
-
>
MergeItems
(
mergedItems
)
;
MOZ_ASSERT
(
item
&
&
itemType
=
=
item
-
>
GetType
(
)
)
;
}
bool
forceNewLayerData
=
false
;
size_t
layerCountBeforeRecursing
=
mLayerScrollData
.
size
(
)
;
if
(
apzEnabled
)
{
forceNewLayerData
=
item
-
>
UpdateScrollData
(
nullptr
nullptr
)
;
const
ActiveScrolledRoot
*
asr
=
item
-
>
GetActiveScrolledRoot
(
)
;
if
(
asr
!
=
mLastAsr
)
{
mLastAsr
=
asr
;
forceNewLayerData
=
true
;
}
if
(
forceNewLayerData
&
&
!
eventRegions
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
!
mLayerScrollData
.
empty
(
)
)
;
mLayerScrollData
.
back
(
)
.
AddEventRegions
(
eventRegions
)
;
eventRegions
.
SetEmpty
(
)
;
}
if
(
itemType
=
=
DisplayItemType
:
:
TYPE_LAYER_EVENT_REGIONS
)
{
nsDisplayLayerEventRegions
*
regionsItem
=
static_cast
<
nsDisplayLayerEventRegions
*
>
(
item
)
;
int32_t
auPerDevPixel
=
item
-
>
Frame
(
)
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
EventRegions
regions
(
regionsItem
-
>
HitRegion
(
)
.
ScaleToOutsidePixels
(
1
.
0f
1
.
0f
auPerDevPixel
)
regionsItem
-
>
MaybeHitRegion
(
)
.
ScaleToOutsidePixels
(
1
.
0f
1
.
0f
auPerDevPixel
)
regionsItem
-
>
DispatchToContentHitRegion
(
)
.
ScaleToOutsidePixels
(
1
.
0f
1
.
0f
auPerDevPixel
)
regionsItem
-
>
NoActionRegion
(
)
.
ScaleToOutsidePixels
(
1
.
0f
1
.
0f
auPerDevPixel
)
regionsItem
-
>
HorizontalPanRegion
(
)
.
ScaleToOutsidePixels
(
1
.
0f
1
.
0f
auPerDevPixel
)
regionsItem
-
>
VerticalPanRegion
(
)
.
ScaleToOutsidePixels
(
1
.
0f
1
.
0f
auPerDevPixel
)
false
)
;
eventRegions
.
OrWith
(
regions
)
;
if
(
mLayerScrollData
.
empty
(
)
)
{
forceNewLayerData
=
true
;
}
}
if
(
forceNewLayerData
)
{
mAsrStack
.
push_back
(
asr
)
;
}
}
mScrollingHelper
.
BeginItem
(
item
aSc
)
;
if
(
itemType
!
=
DisplayItemType
:
:
TYPE_LAYER_EVENT_REGIONS
&
&
!
item
-
>
CreateWebRenderCommands
(
aBuilder
aResources
aSc
mManager
aDisplayListBuilder
)
)
{
PushItemAsImage
(
item
aBuilder
aResources
aSc
aDisplayListBuilder
)
;
}
if
(
apzEnabled
)
{
if
(
forceNewLayerData
)
{
mAsrStack
.
pop_back
(
)
;
const
ActiveScrolledRoot
*
stopAtAsr
=
mAsrStack
.
empty
(
)
?
nullptr
:
mAsrStack
.
back
(
)
;
int32_t
descendants
=
mLayerScrollData
.
size
(
)
-
layerCountBeforeRecursing
;
mLayerScrollData
.
emplace_back
(
)
;
mLayerScrollData
.
back
(
)
.
Initialize
(
mManager
-
>
GetScrollData
(
)
item
descendants
stopAtAsr
)
;
}
else
if
(
mLayerScrollData
.
size
(
)
!
=
layerCountBeforeRecursing
&
&
!
eventRegions
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
layerCountBeforeRecursing
>
0
)
;
mLayerScrollData
[
layerCountBeforeRecursing
-
1
]
.
AddEventRegions
(
eventRegions
)
;
eventRegions
.
SetEmpty
(
)
;
}
}
}
if
(
!
eventRegions
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
apzEnabled
)
;
MOZ_ASSERT
(
!
mLayerScrollData
.
empty
(
)
)
;
mLayerScrollData
.
back
(
)
.
AddEventRegions
(
eventRegions
)
;
}
mScrollingHelper
.
EndList
(
aSc
)
;
}
Maybe
<
wr
:
:
ImageKey
>
WebRenderCommandBuilder
:
:
CreateImageKey
(
nsDisplayItem
*
aItem
ImageContainer
*
aContainer
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
gfx
:
:
IntSize
&
aSize
const
Maybe
<
LayoutDeviceRect
>
&
aAsyncImageBounds
)
{
RefPtr
<
WebRenderImageData
>
imageData
=
CreateOrRecycleWebRenderUserData
<
WebRenderImageData
>
(
aItem
)
;
MOZ_ASSERT
(
imageData
)
;
if
(
aContainer
-
>
IsAsync
(
)
)
{
MOZ_ASSERT
(
aAsyncImageBounds
)
;
LayoutDeviceRect
rect
=
aAsyncImageBounds
.
value
(
)
;
LayoutDeviceRect
scBounds
(
LayoutDevicePoint
(
0
0
)
rect
.
Size
(
)
)
;
gfx
:
:
MaybeIntSize
scaleToSize
;
if
(
!
aContainer
-
>
GetScaleHint
(
)
.
IsEmpty
(
)
)
{
scaleToSize
=
Some
(
aContainer
-
>
GetScaleHint
(
)
)
;
}
imageData
-
>
CreateAsyncImageWebRenderCommands
(
aBuilder
aContainer
aSc
rect
scBounds
gfx
:
:
Matrix4x4
(
)
scaleToSize
wr
:
:
ImageRendering
:
:
Auto
wr
:
:
MixBlendMode
:
:
Normal
!
aItem
-
>
BackfaceIsHidden
(
)
)
;
return
Nothing
(
)
;
}
AutoLockImage
autoLock
(
aContainer
)
;
if
(
!
autoLock
.
HasImage
(
)
)
{
return
Nothing
(
)
;
}
mozilla
:
:
layers
:
:
Image
*
image
=
autoLock
.
GetImage
(
)
;
aSize
=
image
-
>
GetSize
(
)
;
return
imageData
-
>
UpdateImageKey
(
aContainer
aResources
)
;
}
bool
WebRenderCommandBuilder
:
:
PushImage
(
nsDisplayItem
*
aItem
ImageContainer
*
aContainer
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
const
LayoutDeviceRect
&
aRect
)
{
gfx
:
:
IntSize
size
;
Maybe
<
wr
:
:
ImageKey
>
key
=
CreateImageKey
(
aItem
aContainer
aBuilder
aResources
aSc
size
Some
(
aRect
)
)
;
if
(
aContainer
-
>
IsAsync
(
)
)
{
MOZ_ASSERT
(
key
.
isNothing
(
)
)
;
return
true
;
}
if
(
!
key
)
{
return
false
;
}
auto
r
=
aSc
.
ToRelativeLayoutRect
(
aRect
)
;
gfx
:
:
SamplingFilter
sampleFilter
=
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
aItem
-
>
Frame
(
)
)
;
aBuilder
.
PushImage
(
r
r
!
aItem
-
>
BackfaceIsHidden
(
)
wr
:
:
ToImageRendering
(
sampleFilter
)
key
.
value
(
)
)
;
return
true
;
}
static
bool
PaintByLayer
(
nsDisplayItem
*
aItem
nsDisplayListBuilder
*
aDisplayListBuilder
const
RefPtr
<
BasicLayerManager
>
&
aManager
gfxContext
*
aContext
const
gfx
:
:
Size
&
aScale
const
std
:
:
function
<
void
(
)
>
&
aPaintFunc
)
{
UniquePtr
<
LayerProperties
>
props
;
if
(
aManager
-
>
GetRoot
(
)
)
{
props
=
Move
(
LayerProperties
:
:
CloneFrom
(
aManager
-
>
GetRoot
(
)
)
)
;
}
FrameLayerBuilder
*
layerBuilder
=
new
FrameLayerBuilder
(
)
;
layerBuilder
-
>
Init
(
aDisplayListBuilder
aManager
nullptr
true
)
;
layerBuilder
-
>
DidBeginRetainedLayerTransaction
(
aManager
)
;
aManager
-
>
SetDefaultTarget
(
aContext
)
;
aManager
-
>
BeginTransactionWithTarget
(
aContext
)
;
bool
isInvalidated
=
false
;
ContainerLayerParameters
param
(
aScale
.
width
aScale
.
height
)
;
RefPtr
<
Layer
>
root
=
aItem
-
>
BuildLayer
(
aDisplayListBuilder
aManager
param
)
;
if
(
root
)
{
aManager
-
>
SetRoot
(
root
)
;
layerBuilder
-
>
WillEndTransaction
(
)
;
aPaintFunc
(
)
;
nsIntRegion
invalid
;
if
(
props
)
{
props
-
>
ComputeDifferences
(
root
invalid
nullptr
)
;
if
(
!
invalid
.
IsEmpty
(
)
)
{
isInvalidated
=
true
;
}
}
else
{
isInvalidated
=
true
;
}
}
#
ifdef
MOZ_DUMP_PAINTING
if
(
gfxUtils
:
:
DumpDisplayList
(
)
|
|
gfxEnv
:
:
DumpPaint
(
)
)
{
fprintf_stderr
(
gfxUtils
:
:
sDumpPaintFile
"
Basic
layer
tree
for
painting
contents
of
display
item
%
s
(
%
p
)
:
\
n
"
aItem
-
>
Name
(
)
aItem
-
>
Frame
(
)
)
;
std
:
:
stringstream
stream
;
aManager
-
>
Dump
(
stream
"
"
gfxEnv
:
:
DumpPaintToFile
(
)
)
;
fprint_stderr
(
gfxUtils
:
:
sDumpPaintFile
stream
)
;
}
#
endif
if
(
aManager
-
>
InTransaction
(
)
)
{
aManager
-
>
AbortTransaction
(
)
;
}
aManager
-
>
SetTarget
(
nullptr
)
;
aManager
-
>
SetDefaultTarget
(
nullptr
)
;
return
isInvalidated
;
}
static
bool
PaintItemByDrawTarget
(
nsDisplayItem
*
aItem
gfx
:
:
DrawTarget
*
aDT
const
LayerRect
&
aImageRect
const
LayoutDevicePoint
&
aOffset
nsDisplayListBuilder
*
aDisplayListBuilder
const
RefPtr
<
BasicLayerManager
>
&
aManager
const
gfx
:
:
Size
&
aScale
Maybe
<
gfx
:
:
Color
>
&
aHighlight
)
{
MOZ_ASSERT
(
aDT
)
;
bool
isInvalidated
=
false
;
aDT
-
>
ClearRect
(
aImageRect
.
ToUnknownRect
(
)
)
;
RefPtr
<
gfxContext
>
context
=
gfxContext
:
:
CreateOrNull
(
aDT
)
;
MOZ_ASSERT
(
context
)
;
switch
(
aItem
-
>
GetType
(
)
)
{
case
DisplayItemType
:
:
TYPE_MASK
:
context
-
>
SetMatrix
(
context
-
>
CurrentMatrix
(
)
.
PreScale
(
aScale
.
width
aScale
.
height
)
.
PreTranslate
(
-
aOffset
.
x
-
aOffset
.
y
)
)
;
static_cast
<
nsDisplayMask
*
>
(
aItem
)
-
>
PaintMask
(
aDisplayListBuilder
context
)
;
isInvalidated
=
true
;
break
;
case
DisplayItemType
:
:
TYPE_SVG_WRAPPER
:
{
context
-
>
SetMatrix
(
context
-
>
CurrentMatrix
(
)
.
PreTranslate
(
-
aOffset
.
x
-
aOffset
.
y
)
)
;
isInvalidated
=
PaintByLayer
(
aItem
aDisplayListBuilder
aManager
context
aScale
[
&
]
(
)
{
aManager
-
>
EndTransaction
(
FrameLayerBuilder
:
:
DrawPaintedLayer
aDisplayListBuilder
)
;
}
)
;
break
;
}
case
DisplayItemType
:
:
TYPE_FILTER
:
{
context
-
>
SetMatrix
(
context
-
>
CurrentMatrix
(
)
.
PreTranslate
(
-
aOffset
.
x
-
aOffset
.
y
)
)
;
isInvalidated
=
PaintByLayer
(
aItem
aDisplayListBuilder
aManager
context
aScale
[
&
]
(
)
{
static_cast
<
nsDisplayFilter
*
>
(
aItem
)
-
>
PaintAsLayer
(
aDisplayListBuilder
context
aManager
)
;
}
)
;
break
;
}
default
:
context
-
>
SetMatrix
(
context
-
>
CurrentMatrix
(
)
.
PreScale
(
aScale
.
width
aScale
.
height
)
.
PreTranslate
(
-
aOffset
.
x
-
aOffset
.
y
)
)
;
aItem
-
>
Paint
(
aDisplayListBuilder
context
)
;
isInvalidated
=
true
;
break
;
}
if
(
aItem
-
>
GetType
(
)
!
=
DisplayItemType
:
:
TYPE_MASK
)
{
if
(
aHighlight
)
{
aDT
-
>
SetTransform
(
gfx
:
:
Matrix
(
)
)
;
aDT
-
>
FillRect
(
gfx
:
:
Rect
(
0
0
aImageRect
.
Width
(
)
aImageRect
.
Height
(
)
)
gfx
:
:
ColorPattern
(
aHighlight
.
value
(
)
)
)
;
}
if
(
aItem
-
>
Frame
(
)
-
>
PresContext
(
)
-
>
GetPaintFlashing
(
)
&
&
isInvalidated
)
{
aDT
-
>
SetTransform
(
gfx
:
:
Matrix
(
)
)
;
float
r
=
float
(
rand
(
)
)
/
RAND_MAX
;
float
g
=
float
(
rand
(
)
)
/
RAND_MAX
;
float
b
=
float
(
rand
(
)
)
/
RAND_MAX
;
aDT
-
>
FillRect
(
gfx
:
:
Rect
(
0
0
aImageRect
.
Width
(
)
aImageRect
.
Height
(
)
)
gfx
:
:
ColorPattern
(
gfx
:
:
Color
(
r
g
b
0
.
5
)
)
)
;
}
}
return
isInvalidated
;
}
already_AddRefed
<
WebRenderFallbackData
>
WebRenderCommandBuilder
:
:
GenerateFallbackData
(
nsDisplayItem
*
aItem
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
nsDisplayListBuilder
*
aDisplayListBuilder
LayoutDeviceRect
&
aImageRect
)
{
bool
useBlobImage
=
gfxPrefs
:
:
WebRenderBlobImages
(
)
&
&
!
aItem
-
>
MustPaintOnContentSide
(
)
;
Maybe
<
gfx
:
:
Color
>
highlight
=
Nothing
(
)
;
if
(
gfxPrefs
:
:
WebRenderHighlightPaintedLayers
(
)
)
{
highlight
=
Some
(
useBlobImage
?
gfx
:
:
Color
(
1
.
0
0
.
0
0
.
0
0
.
5
)
:
gfx
:
:
Color
(
1
.
0
1
.
0
0
.
0
0
.
5
)
)
;
}
RefPtr
<
WebRenderFallbackData
>
fallbackData
=
CreateOrRecycleWebRenderUserData
<
WebRenderFallbackData
>
(
aItem
)
;
bool
snap
;
nsRect
itemBounds
=
aItem
-
>
GetBounds
(
aDisplayListBuilder
&
snap
)
;
nsRect
paintBounds
=
itemBounds
;
if
(
useBlobImage
|
|
aItem
-
>
MustPaintOnContentSide
(
)
)
{
paintBounds
=
itemBounds
;
}
else
{
paintBounds
=
aItem
-
>
GetClippedBounds
(
aDisplayListBuilder
)
;
}
nsRegion
visibleRegion
(
paintBounds
)
;
aItem
-
>
SetVisibleRect
(
paintBounds
false
)
;
aItem
-
>
ComputeVisibility
(
aDisplayListBuilder
&
visibleRegion
)
;
const
int32_t
appUnitsPerDevPixel
=
aItem
-
>
Frame
(
)
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
LayoutDeviceRect
bounds
=
LayoutDeviceRect
:
:
FromAppUnits
(
paintBounds
appUnitsPerDevPixel
)
;
gfx
:
:
Size
scale
=
aSc
.
GetInheritedScale
(
)
;
gfx
:
:
Size
oldScale
=
fallbackData
-
>
GetScale
(
)
;
bool
differentScale
=
gfx
:
:
FuzzyEqual
(
scale
.
width
oldScale
.
width
1e
-
6f
)
&
&
gfx
:
:
FuzzyEqual
(
scale
.
height
oldScale
.
height
1e
-
6f
)
;
LayerIntSize
paintSize
=
RoundedToInt
(
LayerSize
(
bounds
.
Width
(
)
*
scale
.
width
bounds
.
Height
(
)
*
scale
.
height
)
)
;
if
(
paintSize
.
width
=
=
0
|
|
paintSize
.
height
=
=
0
)
{
return
nullptr
;
}
auto
scaledBounds
=
bounds
*
LayoutDeviceToLayerScale
(
1
)
;
scaledBounds
.
Scale
(
scale
.
width
scale
.
height
)
;
LayerIntSize
dtSize
=
RoundedToInt
(
scaledBounds
)
.
Size
(
)
;
bool
needPaint
=
true
;
LayoutDeviceIntPoint
offset
=
RoundedToInt
(
bounds
.
TopLeft
(
)
)
;
aImageRect
=
LayoutDeviceRect
(
offset
LayoutDeviceSize
(
RoundedToInt
(
bounds
)
.
Size
(
)
)
)
;
LayerRect
paintRect
=
LayerRect
(
LayerPoint
(
0
0
)
LayerSize
(
paintSize
)
)
;
nsDisplayItemGeometry
*
geometry
=
fallbackData
-
>
GetGeometry
(
)
;
if
(
geometry
&
&
!
fallbackData
-
>
IsInvalid
(
)
&
&
aItem
-
>
GetType
(
)
!
=
DisplayItemType
:
:
TYPE_FILTER
&
&
aItem
-
>
GetType
(
)
!
=
DisplayItemType
:
:
TYPE_SVG_WRAPPER
&
&
differentScale
)
{
nsRect
invalid
;
nsRegion
invalidRegion
;
if
(
aItem
-
>
IsInvalid
(
invalid
)
)
{
invalidRegion
.
OrWith
(
paintBounds
)
;
}
else
{
nsPoint
shift
=
itemBounds
.
TopLeft
(
)
-
geometry
-
>
mBounds
.
TopLeft
(
)
;
geometry
-
>
MoveBy
(
shift
)
;
aItem
-
>
ComputeInvalidationRegion
(
aDisplayListBuilder
geometry
&
invalidRegion
)
;
nsRect
lastBounds
=
fallbackData
-
>
GetBounds
(
)
;
lastBounds
.
MoveBy
(
shift
)
;
if
(
!
lastBounds
.
IsEqualInterior
(
paintBounds
)
)
{
invalidRegion
.
OrWith
(
lastBounds
)
;
invalidRegion
.
OrWith
(
paintBounds
)
;
}
}
needPaint
=
!
invalidRegion
.
IsEmpty
(
)
;
}
if
(
needPaint
|
|
!
fallbackData
-
>
GetKey
(
)
)
{
nsAutoPtr
<
nsDisplayItemGeometry
>
newGeometry
;
newGeometry
=
aItem
-
>
AllocateGeometry
(
aDisplayListBuilder
)
;
fallbackData
-
>
SetGeometry
(
Move
(
newGeometry
)
)
;
gfx
:
:
SurfaceFormat
format
=
aItem
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_MASK
?
gfx
:
:
SurfaceFormat
:
:
A8
:
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
if
(
useBlobImage
)
{
bool
snapped
;
bool
isOpaque
=
aItem
-
>
GetOpaqueRegion
(
aDisplayListBuilder
&
snapped
)
.
Contains
(
paintBounds
)
;
RefPtr
<
gfx
:
:
DrawEventRecorderMemory
>
recorder
=
MakeAndAddRef
<
gfx
:
:
DrawEventRecorderMemory
>
(
[
&
]
(
MemStream
&
aStream
std
:
:
vector
<
RefPtr
<
UnscaledFont
>
>
&
aUnscaledFonts
)
{
size_t
count
=
aUnscaledFonts
.
size
(
)
;
aStream
.
write
(
(
const
char
*
)
&
count
sizeof
(
count
)
)
;
for
(
auto
unscaled
:
aUnscaledFonts
)
{
wr
:
:
FontKey
key
=
mManager
-
>
WrBridge
(
)
-
>
GetFontKeyForUnscaledFont
(
unscaled
)
;
aStream
.
write
(
(
const
char
*
)
&
key
sizeof
(
key
)
)
;
}
}
)
;
RefPtr
<
gfx
:
:
DrawTarget
>
dummyDt
=
gfx
:
:
Factory
:
:
CreateDrawTarget
(
gfx
:
:
BackendType
:
:
SKIA
gfx
:
:
IntSize
(
1
1
)
format
)
;
RefPtr
<
gfx
:
:
DrawTarget
>
dt
=
gfx
:
:
Factory
:
:
CreateRecordingDrawTarget
(
recorder
dummyDt
dtSize
.
ToUnknownSize
(
)
)
;
if
(
!
fallbackData
-
>
mBasicLayerManager
)
{
fallbackData
-
>
mBasicLayerManager
=
new
BasicLayerManager
(
BasicLayerManager
:
:
BLM_INACTIVE
)
;
}
bool
isInvalidated
=
PaintItemByDrawTarget
(
aItem
dt
paintRect
offset
aDisplayListBuilder
fallbackData
-
>
mBasicLayerManager
scale
highlight
)
;
recorder
-
>
FlushItem
(
IntRect
(
0
0
paintSize
.
width
paintSize
.
height
)
)
;
recorder
-
>
Finish
(
)
;
if
(
isInvalidated
)
{
Range
<
uint8_t
>
bytes
(
(
uint8_t
*
)
recorder
-
>
mOutputStream
.
mData
recorder
-
>
mOutputStream
.
mLength
)
;
wr
:
:
ImageKey
key
=
mManager
-
>
WrBridge
(
)
-
>
GetNextImageKey
(
)
;
wr
:
:
ImageDescriptor
descriptor
(
dtSize
.
ToUnknownSize
(
)
0
dt
-
>
GetFormat
(
)
isOpaque
)
;
if
(
!
aResources
.
AddBlobImage
(
key
descriptor
bytes
)
)
{
return
nullptr
;
}
fallbackData
-
>
SetKey
(
key
)
;
}
else
{
if
(
!
fallbackData
-
>
GetKey
(
)
.
isSome
(
)
)
{
return
nullptr
;
}
}
}
else
{
fallbackData
-
>
CreateImageClientIfNeeded
(
)
;
RefPtr
<
ImageClient
>
imageClient
=
fallbackData
-
>
GetImageClient
(
)
;
RefPtr
<
ImageContainer
>
imageContainer
=
LayerManager
:
:
CreateImageContainer
(
)
;
bool
isInvalidated
=
false
;
{
UpdateImageHelper
helper
(
imageContainer
imageClient
dtSize
.
ToUnknownSize
(
)
format
)
;
{
RefPtr
<
gfx
:
:
DrawTarget
>
dt
=
helper
.
GetDrawTarget
(
)
;
if
(
!
dt
)
{
return
nullptr
;
}
if
(
!
fallbackData
-
>
mBasicLayerManager
)
{
fallbackData
-
>
mBasicLayerManager
=
new
BasicLayerManager
(
mManager
-
>
GetWidget
(
)
)
;
}
isInvalidated
=
PaintItemByDrawTarget
(
aItem
dt
paintRect
offset
aDisplayListBuilder
fallbackData
-
>
mBasicLayerManager
scale
highlight
)
;
}
if
(
isInvalidated
)
{
if
(
!
helper
.
UpdateImage
(
)
)
{
return
nullptr
;
}
}
else
{
if
(
!
fallbackData
-
>
GetKey
(
)
.
isSome
(
)
)
{
return
nullptr
;
}
}
}
if
(
isInvalidated
&
&
!
fallbackData
-
>
UpdateImageKey
(
imageContainer
aResources
true
)
)
{
return
nullptr
;
}
}
fallbackData
-
>
SetScale
(
scale
)
;
fallbackData
-
>
SetInvalid
(
false
)
;
}
fallbackData
-
>
SetBounds
(
paintBounds
)
;
MOZ_ASSERT
(
fallbackData
-
>
GetKey
(
)
)
;
return
fallbackData
.
forget
(
)
;
}
Maybe
<
wr
:
:
WrImageMask
>
WebRenderCommandBuilder
:
:
BuildWrMaskImage
(
nsDisplayItem
*
aItem
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
nsDisplayListBuilder
*
aDisplayListBuilder
const
LayoutDeviceRect
&
aBounds
)
{
LayoutDeviceRect
imageRect
;
RefPtr
<
WebRenderFallbackData
>
fallbackData
=
GenerateFallbackData
(
aItem
aBuilder
aResources
aSc
aDisplayListBuilder
imageRect
)
;
if
(
!
fallbackData
)
{
return
Nothing
(
)
;
}
wr
:
:
WrImageMask
imageMask
;
imageMask
.
image
=
fallbackData
-
>
GetKey
(
)
.
value
(
)
;
imageMask
.
rect
=
aSc
.
ToRelativeLayoutRect
(
aBounds
)
;
imageMask
.
repeat
=
false
;
return
Some
(
imageMask
)
;
}
bool
WebRenderCommandBuilder
:
:
PushItemAsImage
(
nsDisplayItem
*
aItem
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
LayoutDeviceRect
imageRect
;
RefPtr
<
WebRenderFallbackData
>
fallbackData
=
GenerateFallbackData
(
aItem
aBuilder
aResources
aSc
aDisplayListBuilder
imageRect
)
;
if
(
!
fallbackData
)
{
return
false
;
}
wr
:
:
LayoutRect
dest
=
aSc
.
ToRelativeLayoutRect
(
imageRect
)
;
gfx
:
:
SamplingFilter
sampleFilter
=
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
aItem
-
>
Frame
(
)
)
;
aBuilder
.
PushImage
(
dest
dest
!
aItem
-
>
BackfaceIsHidden
(
)
wr
:
:
ToImageRendering
(
sampleFilter
)
fallbackData
-
>
GetKey
(
)
.
value
(
)
)
;
return
true
;
}
void
WebRenderCommandBuilder
:
:
RemoveUnusedAndResetWebRenderUserData
(
)
{
for
(
auto
iter
=
mWebRenderUserDatas
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
WebRenderUserData
*
data
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
if
(
!
data
-
>
IsUsed
(
)
)
{
nsIFrame
*
frame
=
data
-
>
GetFrame
(
)
;
MOZ_ASSERT
(
frame
-
>
HasProperty
(
WebRenderUserDataProperty
:
:
Key
(
)
)
)
;
WebRenderUserDataTable
*
userDataTable
=
frame
-
>
GetProperty
(
WebRenderUserDataProperty
:
:
Key
(
)
)
;
MOZ_ASSERT
(
userDataTable
-
>
Count
(
)
)
;
userDataTable
-
>
Remove
(
WebRenderUserDataKey
(
data
-
>
GetDisplayItemKey
(
)
data
-
>
GetType
(
)
)
)
;
if
(
!
userDataTable
-
>
Count
(
)
)
{
frame
-
>
RemoveProperty
(
WebRenderUserDataProperty
:
:
Key
(
)
)
;
}
if
(
data
-
>
GetType
(
)
=
=
WebRenderUserData
:
:
UserDataType
:
:
eCanvas
)
{
mLastCanvasDatas
.
RemoveEntry
(
data
-
>
AsCanvasData
(
)
)
;
}
iter
.
Remove
(
)
;
continue
;
}
data
-
>
SetUsed
(
false
)
;
}
}
void
WebRenderCommandBuilder
:
:
ClearCachedResources
(
)
{
for
(
auto
iter
=
mWebRenderUserDatas
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
WebRenderUserData
*
data
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
data
-
>
ClearCachedResources
(
)
;
}
}
}
}
