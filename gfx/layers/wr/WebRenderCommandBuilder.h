#
ifndef
GFX_WEBRENDERCOMMANDBUILDER_H
#
define
GFX_WEBRENDERCOMMANDBUILDER_H
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
mozilla
/
layers
/
ScrollingLayersHelper
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderMessages
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderScrollData
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderUserData
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsIFrame
.
h
"
namespace
mozilla
{
namespace
layers
{
class
CanvasLayer
;
class
ImageClient
;
class
ImageContainer
;
class
WebRenderBridgeChild
;
class
WebRenderCanvasData
;
class
WebRenderCanvasRendererAsync
;
class
WebRenderImageData
;
class
WebRenderFallbackData
;
class
WebRenderParentCommand
;
class
WebRenderUserData
;
class
WebRenderCommandBuilder
{
typedef
nsTHashtable
<
nsRefPtrHashKey
<
WebRenderUserData
>
>
WebRenderUserDataRefTable
;
typedef
nsTHashtable
<
nsRefPtrHashKey
<
WebRenderCanvasData
>
>
CanvasDataSet
;
public
:
explicit
WebRenderCommandBuilder
(
WebRenderLayerManager
*
aManager
)
:
mManager
(
aManager
)
mLastAsr
(
nullptr
)
{
}
void
Destroy
(
)
;
void
EmptyTransaction
(
)
;
bool
NeedsEmptyTransaction
(
)
;
void
BuildWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResourceUpdates
nsDisplayList
*
aDisplayList
nsDisplayListBuilder
*
aDisplayListBuilder
WebRenderScrollData
&
aScrollData
wr
:
:
LayoutSize
&
aContentSize
)
;
Maybe
<
wr
:
:
ImageKey
>
CreateImageKey
(
nsDisplayItem
*
aItem
ImageContainer
*
aContainer
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
gfx
:
:
IntSize
&
aSize
const
Maybe
<
LayoutDeviceRect
>
&
aAsyncImageBounds
)
;
WebRenderUserDataRefTable
*
GetWebRenderUserDataTable
(
)
{
return
&
mWebRenderUserDatas
;
}
bool
PushImage
(
nsDisplayItem
*
aItem
ImageContainer
*
aContainer
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
const
LayoutDeviceRect
&
aRect
)
;
Maybe
<
wr
:
:
WrImageMask
>
BuildWrMaskImage
(
nsDisplayItem
*
aItem
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
nsDisplayListBuilder
*
aDisplayListBuilder
const
LayoutDeviceRect
&
aBounds
)
;
bool
PushItemAsImage
(
nsDisplayItem
*
aItem
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
nsDisplayListBuilder
*
aDisplayListBuilder
)
;
void
CreateWebRenderCommandsFromDisplayList
(
nsDisplayList
*
aDisplayList
nsDisplayListBuilder
*
aDisplayListBuilder
const
StackingContextHelper
&
aSc
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
)
;
already_AddRefed
<
WebRenderFallbackData
>
GenerateFallbackData
(
nsDisplayItem
*
aItem
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
nsDisplayListBuilder
*
aDisplayListBuilder
LayoutDeviceRect
&
aImageRect
)
;
void
RemoveUnusedAndResetWebRenderUserData
(
)
;
void
ClearCachedResources
(
)
;
template
<
class
T
>
already_AddRefed
<
T
>
CreateOrRecycleWebRenderUserData
(
nsDisplayItem
*
aItem
bool
*
aOutIsRecycled
=
nullptr
)
{
MOZ_ASSERT
(
aItem
)
;
nsIFrame
*
frame
=
aItem
-
>
Frame
(
)
;
if
(
aOutIsRecycled
)
{
*
aOutIsRecycled
=
true
;
}
nsIFrame
:
:
WebRenderUserDataTable
*
userDataTable
=
frame
-
>
GetProperty
(
nsIFrame
:
:
WebRenderUserDataProperty
(
)
)
;
if
(
!
userDataTable
)
{
userDataTable
=
new
nsIFrame
:
:
WebRenderUserDataTable
(
)
;
frame
-
>
AddProperty
(
nsIFrame
:
:
WebRenderUserDataProperty
(
)
userDataTable
)
;
}
RefPtr
<
WebRenderUserData
>
&
data
=
userDataTable
-
>
GetOrInsert
(
aItem
-
>
GetPerFrameKey
(
)
)
;
if
(
!
data
|
|
(
data
-
>
GetType
(
)
!
=
T
:
:
Type
(
)
)
|
|
!
data
-
>
IsDataValid
(
mManager
)
)
{
if
(
data
)
{
data
-
>
RemoveFromTable
(
)
;
}
data
=
new
T
(
mManager
aItem
)
;
mWebRenderUserDatas
.
PutEntry
(
data
)
;
if
(
aOutIsRecycled
)
{
*
aOutIsRecycled
=
false
;
}
}
MOZ_ASSERT
(
data
)
;
MOZ_ASSERT
(
data
-
>
GetType
(
)
=
=
T
:
:
Type
(
)
)
;
data
-
>
SetUsed
(
true
)
;
if
(
T
:
:
Type
(
)
=
=
WebRenderUserData
:
:
UserDataType
:
:
eCanvas
)
{
mLastCanvasDatas
.
PutEntry
(
data
-
>
AsCanvasData
(
)
)
;
}
RefPtr
<
T
>
res
=
static_cast
<
T
*
>
(
data
.
get
(
)
)
;
return
res
.
forget
(
)
;
}
template
<
class
T
>
already_AddRefed
<
T
>
GetWebRenderUserData
(
nsIFrame
*
aFrame
uint32_t
aPerFrameKey
)
{
RefPtr
<
T
>
result
;
MOZ_ASSERT
(
aFrame
)
;
nsIFrame
:
:
WebRenderUserDataTable
*
userDataTable
=
aFrame
-
>
GetProperty
(
nsIFrame
:
:
WebRenderUserDataProperty
(
)
)
;
if
(
!
userDataTable
)
{
return
result
.
forget
(
)
;
}
WebRenderUserData
*
data
=
nullptr
;
if
(
userDataTable
-
>
Get
(
aPerFrameKey
&
data
)
)
{
if
(
data
-
>
GetType
(
)
=
=
T
:
:
Type
(
)
&
&
data
-
>
IsDataValid
(
mManager
)
)
{
result
=
static_cast
<
T
*
>
(
data
)
;
}
}
return
result
.
forget
(
)
;
}
private
:
WebRenderLayerManager
*
mManager
;
ScrollingLayersHelper
mScrollingHelper
;
nsTArray
<
WebRenderParentCommand
>
mParentCommands
;
std
:
:
vector
<
WebRenderLayerScrollData
>
mLayerScrollData
;
std
:
:
vector
<
const
ActiveScrolledRoot
*
>
mAsrStack
;
const
ActiveScrolledRoot
*
mLastAsr
;
WebRenderUserDataRefTable
mWebRenderUserDatas
;
CanvasDataSet
mLastCanvasDatas
;
}
;
}
}
#
endif
