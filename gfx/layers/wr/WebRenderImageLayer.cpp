#
include
"
WebRenderImageLayer
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
LayersLogging
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
layers
/
ImageClient
.
h
"
#
include
"
mozilla
/
layers
/
ScrollingLayersHelper
.
h
"
#
include
"
mozilla
/
layers
/
StackingContextHelper
.
h
"
#
include
"
mozilla
/
layers
/
TextureClientRecycleAllocator
.
h
"
#
include
"
mozilla
/
layers
/
TextureWrapperImage
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderBridgeChild
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderTypes
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
gfx
;
WebRenderImageLayer
:
:
WebRenderImageLayer
(
WebRenderLayerManager
*
aLayerManager
)
:
ImageLayer
(
aLayerManager
static_cast
<
WebRenderLayer
*
>
(
this
)
)
mImageClientTypeContainer
(
CompositableType
:
:
UNKNOWN
)
{
MOZ_COUNT_CTOR
(
WebRenderImageLayer
)
;
}
WebRenderImageLayer
:
:
~
WebRenderImageLayer
(
)
{
MOZ_COUNT_DTOR
(
WebRenderImageLayer
)
;
mPipelineIdRequest
.
DisconnectIfExists
(
)
;
if
(
mKey
.
isSome
(
)
)
{
WrManager
(
)
-
>
AddImageKeyForDiscard
(
mKey
.
value
(
)
)
;
}
if
(
mExternalImageId
.
isSome
(
)
)
{
WrBridge
(
)
-
>
DeallocExternalImageId
(
mExternalImageId
.
ref
(
)
)
;
}
}
CompositableType
WebRenderImageLayer
:
:
GetImageClientType
(
)
{
if
(
mImageClientTypeContainer
!
=
CompositableType
:
:
UNKNOWN
)
{
return
mImageClientTypeContainer
;
}
if
(
mContainer
-
>
IsAsync
(
)
)
{
mImageClientTypeContainer
=
CompositableType
:
:
IMAGE_BRIDGE
;
return
mImageClientTypeContainer
;
}
AutoLockImage
autoLock
(
mContainer
)
;
mImageClientTypeContainer
=
autoLock
.
HasImage
(
)
?
CompositableType
:
:
IMAGE
:
CompositableType
:
:
UNKNOWN
;
return
mImageClientTypeContainer
;
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
WebRenderImageLayer
:
:
GetAsSourceSurface
(
)
{
if
(
!
mContainer
)
{
return
nullptr
;
}
AutoLockImage
autoLock
(
mContainer
)
;
Image
*
image
=
autoLock
.
GetImage
(
)
;
if
(
!
image
)
{
return
nullptr
;
}
RefPtr
<
gfx
:
:
SourceSurface
>
surface
=
image
-
>
GetAsSourceSurface
(
)
;
if
(
!
surface
|
|
!
surface
-
>
IsValid
(
)
)
{
return
nullptr
;
}
return
surface
.
forget
(
)
;
}
void
WebRenderImageLayer
:
:
ClearCachedResources
(
)
{
if
(
mImageClient
)
{
mImageClient
-
>
ClearCachedResources
(
)
;
}
}
void
WebRenderImageLayer
:
:
RenderLayer
(
wr
:
:
DisplayListBuilder
&
aBuilder
const
StackingContextHelper
&
aSc
)
{
if
(
!
mContainer
)
{
return
;
}
CompositableType
type
=
GetImageClientType
(
)
;
if
(
type
=
=
CompositableType
:
:
UNKNOWN
)
{
return
;
}
MOZ_ASSERT
(
GetImageClientType
(
)
!
=
CompositableType
:
:
UNKNOWN
)
;
if
(
GetImageClientType
(
)
=
=
CompositableType
:
:
IMAGE_BRIDGE
&
&
mPipelineId
.
isNothing
(
)
&
&
!
mPipelineIdRequest
.
Exists
(
)
)
{
Holder
holder
(
this
)
;
WrManager
(
)
-
>
AllocPipelineId
(
)
-
>
Then
(
AbstractThread
:
:
GetCurrent
(
)
__func__
[
holder
]
(
const
wr
:
:
PipelineId
&
aPipelineId
)
{
holder
-
>
mPipelineIdRequest
.
Complete
(
)
;
holder
-
>
mPipelineId
=
Some
(
aPipelineId
)
;
}
[
holder
]
(
const
ipc
:
:
PromiseRejectReason
&
aReason
)
{
holder
-
>
mPipelineIdRequest
.
Complete
(
)
;
}
)
-
>
Track
(
mPipelineIdRequest
)
;
}
if
(
GetImageClientType
(
)
=
=
CompositableType
:
:
IMAGE
&
&
!
mImageClient
)
{
mImageClient
=
ImageClient
:
:
CreateImageClient
(
CompositableType
:
:
IMAGE
WrBridge
(
)
TextureFlags
:
:
DEFAULT
)
;
if
(
!
mImageClient
)
{
return
;
}
mImageClient
-
>
Connect
(
)
;
}
if
(
mExternalImageId
.
isNothing
(
)
)
{
if
(
GetImageClientType
(
)
=
=
CompositableType
:
:
IMAGE_BRIDGE
)
{
MOZ_ASSERT
(
!
mImageClient
)
;
mExternalImageId
=
Some
(
WrBridge
(
)
-
>
AllocExternalImageId
(
mContainer
-
>
GetAsyncContainerHandle
(
)
)
)
;
}
else
{
MOZ_ASSERT
(
mImageClient
)
;
mExternalImageId
=
Some
(
WrBridge
(
)
-
>
AllocExternalImageIdForCompositable
(
mImageClient
)
)
;
}
}
MOZ_ASSERT
(
mExternalImageId
.
isSome
(
)
)
;
AutoLockImage
autoLock
(
mContainer
)
;
Image
*
image
=
autoLock
.
GetImage
(
)
;
if
(
!
image
)
{
return
;
}
gfx
:
:
IntSize
size
=
image
-
>
GetSize
(
)
;
if
(
GetImageClientType
(
)
=
=
CompositableType
:
:
IMAGE_BRIDGE
)
{
WrImageKey
key
=
GetImageKey
(
)
;
WrBridge
(
)
-
>
AddWebRenderParentCommand
(
OpAddExternalImage
(
mExternalImageId
.
value
(
)
key
)
)
;
WrManager
(
)
-
>
AddImageKeyForDiscard
(
key
)
;
mKey
=
Some
(
key
)
;
}
else
{
MOZ_ASSERT
(
mImageClient
-
>
AsImageClientSingle
(
)
)
;
mKey
=
UpdateImageKey
(
mImageClient
-
>
AsImageClientSingle
(
)
mContainer
mKey
mExternalImageId
.
ref
(
)
)
;
}
if
(
mKey
.
isNothing
(
)
)
{
return
;
}
ScrollingLayersHelper
scroller
(
this
aBuilder
aSc
)
;
StackingContextHelper
sc
(
aSc
aBuilder
this
)
;
LayerRect
rect
(
0
0
size
.
width
size
.
height
)
;
if
(
mScaleMode
!
=
ScaleMode
:
:
SCALE_NONE
)
{
NS_ASSERTION
(
mScaleMode
=
=
ScaleMode
:
:
STRETCH
"
No
other
scalemodes
than
stretch
and
none
supported
yet
.
"
)
;
rect
=
LayerRect
(
0
0
mScaleToSize
.
width
mScaleToSize
.
height
)
;
}
LayerRect
clipRect
=
ClipRect
(
)
.
valueOr
(
rect
)
;
Maybe
<
WrImageMask
>
mask
=
BuildWrMaskLayer
(
&
sc
)
;
WrClipRegionToken
clip
=
aBuilder
.
PushClipRegion
(
sc
.
ToRelativeWrRect
(
clipRect
)
mask
.
ptrOr
(
nullptr
)
)
;
wr
:
:
ImageRendering
filter
=
wr
:
:
ToImageRendering
(
mSamplingFilter
)
;
DumpLayerInfo
(
"
Image
Layer
"
rect
)
;
if
(
gfxPrefs
:
:
LayersDump
(
)
)
{
printf_stderr
(
"
ImageLayer
%
p
texture
-
filter
=
%
s
\
n
"
GetLayer
(
)
Stringify
(
filter
)
.
c_str
(
)
)
;
}
if
(
GetImageClientType
(
)
!
=
CompositableType
:
:
IMAGE_BRIDGE
)
{
aBuilder
.
PushImage
(
sc
.
ToRelativeWrRect
(
rect
)
clip
filter
mKey
.
value
(
)
)
;
}
else
{
#
if
defined
(
XP_WIN
)
aBuilder
.
PushImage
(
sc
.
ToRelativeWrRect
(
rect
)
clip
filter
mKey
.
value
(
)
)
;
#
elif
defined
(
XP_MACOSX
)
if
(
gfx
:
:
gfxVars
:
:
CanUseHardwareVideoDecoding
(
)
)
{
aBuilder
.
PushYCbCrInterleavedImage
(
sc
.
ToRelativeWrRect
(
rect
)
clip
mKey
.
value
(
)
WrYuvColorSpace
:
:
Rec601
)
;
}
else
{
aBuilder
.
PushImage
(
sc
.
ToRelativeWrRect
(
rect
)
clip
filter
mKey
.
value
(
)
)
;
}
#
elif
defined
(
MOZ_WIDGET_GTK
)
aBuilder
.
PushImage
(
sc
.
ToRelativeWrRect
(
rect
)
clip
filter
mKey
.
value
(
)
)
;
#
elif
defined
(
ANDROID
)
aBuilder
.
PushImage
(
sc
.
ToRelativeWrRect
(
rect
)
clip
filter
mKey
.
value
(
)
)
;
#
endif
}
}
Maybe
<
WrImageMask
>
WebRenderImageLayer
:
:
RenderMaskLayer
(
const
gfx
:
:
Matrix4x4
&
aTransform
)
{
if
(
!
mContainer
)
{
return
Nothing
(
)
;
}
CompositableType
type
=
GetImageClientType
(
)
;
if
(
type
=
=
CompositableType
:
:
UNKNOWN
)
{
return
Nothing
(
)
;
}
MOZ_ASSERT
(
GetImageClientType
(
)
=
=
CompositableType
:
:
IMAGE
)
;
if
(
GetImageClientType
(
)
!
=
CompositableType
:
:
IMAGE
)
{
return
Nothing
(
)
;
}
if
(
!
mImageClient
)
{
mImageClient
=
ImageClient
:
:
CreateImageClient
(
CompositableType
:
:
IMAGE
WrBridge
(
)
TextureFlags
:
:
DEFAULT
)
;
if
(
!
mImageClient
)
{
return
Nothing
(
)
;
}
mImageClient
-
>
Connect
(
)
;
}
if
(
mExternalImageId
.
isNothing
(
)
)
{
mExternalImageId
=
Some
(
WrBridge
(
)
-
>
AllocExternalImageIdForCompositable
(
mImageClient
)
)
;
}
AutoLockImage
autoLock
(
mContainer
)
;
Image
*
image
=
autoLock
.
GetImage
(
)
;
if
(
!
image
)
{
return
Nothing
(
)
;
}
MOZ_ASSERT
(
mImageClient
-
>
AsImageClientSingle
(
)
)
;
mKey
=
UpdateImageKey
(
mImageClient
-
>
AsImageClientSingle
(
)
mContainer
mKey
mExternalImageId
.
ref
(
)
)
;
if
(
mKey
.
isNothing
(
)
)
{
return
Nothing
(
)
;
}
gfx
:
:
IntSize
size
=
image
-
>
GetSize
(
)
;
WrImageMask
imageMask
;
imageMask
.
image
=
mKey
.
value
(
)
;
Rect
maskRect
=
aTransform
.
TransformBounds
(
Rect
(
0
0
size
.
width
size
.
height
)
)
;
imageMask
.
rect
=
wr
:
:
ToWrRect
(
maskRect
)
;
imageMask
.
repeat
=
false
;
return
Some
(
imageMask
)
;
}
}
}
