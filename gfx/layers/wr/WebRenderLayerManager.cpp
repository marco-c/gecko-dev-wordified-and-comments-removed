#
include
"
WebRenderLayerManager
.
h
"
#
include
"
Layers
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
include
"
mozilla
/
StaticPrefs_layers
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
gfx
/
DrawEventRecorder
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
StackingContextHelper
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
layers
/
TransactionIdAllocator
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
UpdateImageHelper
.
h
"
#
include
"
mozilla
/
PerfStats
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
WebRenderCanvasRenderer
.
h
"
#
include
"
LayerUserData
.
h
"
#
ifdef
XP_WIN
#
include
"
gfxDWriteFonts
.
h
"
#
include
"
mozilla
/
WindowsProcessMitigations
.
h
"
#
endif
namespace
mozilla
{
using
namespace
gfx
;
namespace
layers
{
WebRenderLayerManager
:
:
WebRenderLayerManager
(
nsIWidget
*
aWidget
)
:
mWidget
(
aWidget
)
mLatestTransactionId
{
0
}
mNeedsComposite
(
false
)
mIsFirstPaint
(
false
)
mDestroyed
(
false
)
mTarget
(
nullptr
)
mPaintSequenceNumber
(
0
)
mWebRenderCommandBuilder
(
this
)
{
MOZ_COUNT_CTOR
(
WebRenderLayerManager
)
;
mStateManager
.
mLayerManager
=
this
;
if
(
XRE_IsContentProcess
(
)
&
&
StaticPrefs
:
:
gfx_webrender_enable_item_cache_AtStartup
(
)
)
{
static
const
size_t
kInitialCacheSize
=
1024
;
static
const
size_t
kMaximumCacheSize
=
10240
;
mDisplayItemCache
.
SetCapacity
(
kInitialCacheSize
kMaximumCacheSize
)
;
}
}
KnowsCompositor
*
WebRenderLayerManager
:
:
AsKnowsCompositor
(
)
{
return
mWrChild
;
}
bool
WebRenderLayerManager
:
:
Initialize
(
PCompositorBridgeChild
*
aCBChild
wr
:
:
PipelineId
aLayersId
TextureFactoryIdentifier
*
aTextureFactoryIdentifier
nsCString
&
aError
)
{
MOZ_ASSERT
(
mWrChild
=
=
nullptr
)
;
MOZ_ASSERT
(
aTextureFactoryIdentifier
)
;
static
bool
hasInitialized
=
false
;
WindowKind
windowKind
;
if
(
mWidget
-
>
WindowType
(
)
!
=
eWindowType_popup
)
{
windowKind
=
WindowKind
:
:
MAIN
;
}
else
{
windowKind
=
WindowKind
:
:
SECONDARY
;
}
LayoutDeviceIntSize
size
=
mWidget
-
>
GetClientSize
(
)
;
if
(
!
wr
:
:
WindowSizeSanityCheck
(
size
.
width
size
.
height
)
)
{
gfxCriticalNoteOnce
<
<
"
Widget
size
is
not
valid
"
<
<
size
<
<
"
isParent
:
"
<
<
XRE_IsParentProcess
(
)
;
}
PWebRenderBridgeChild
*
bridge
=
aCBChild
-
>
SendPWebRenderBridgeConstructor
(
aLayersId
size
windowKind
)
;
if
(
!
bridge
)
{
gfxCriticalNote
<
<
"
Failed
to
create
WebRenderBridgeChild
.
"
;
aError
.
Assign
(
hasInitialized
?
"
FEATURE_FAILURE_WEBRENDER_INITIALIZE_IPDL_POST
"
_ns
:
"
FEATURE_FAILURE_WEBRENDER_INITIALIZE_IPDL_FIRST
"
_ns
)
;
return
false
;
}
mWrChild
=
static_cast
<
WebRenderBridgeChild
*
>
(
bridge
)
;
TextureFactoryIdentifier
textureFactoryIdentifier
;
wr
:
:
MaybeIdNamespace
idNamespace
;
if
(
!
WrBridge
(
)
-
>
SendEnsureConnected
(
&
textureFactoryIdentifier
&
idNamespace
&
aError
)
)
{
gfxCriticalNote
<
<
"
Failed
as
lost
WebRenderBridgeChild
.
"
;
aError
.
Assign
(
hasInitialized
?
"
FEATURE_FAILURE_WEBRENDER_INITIALIZE_SYNC_POST
"
_ns
:
"
FEATURE_FAILURE_WEBRENDER_INITIALIZE_SYNC_FIRST
"
_ns
)
;
return
false
;
}
if
(
textureFactoryIdentifier
.
mParentBackend
=
=
LayersBackend
:
:
LAYERS_NONE
|
|
idNamespace
.
isNothing
(
)
)
{
gfxCriticalNote
<
<
"
Failed
to
connect
WebRenderBridgeChild
.
isParent
=
"
<
<
XRE_IsParentProcess
(
)
;
aError
.
Append
(
hasInitialized
?
"
_POST
"
_ns
:
"
_FIRST
"
_ns
)
;
return
false
;
}
WrBridge
(
)
-
>
SetWebRenderLayerManager
(
this
)
;
WrBridge
(
)
-
>
IdentifyTextureHost
(
textureFactoryIdentifier
)
;
WrBridge
(
)
-
>
SetNamespace
(
idNamespace
.
ref
(
)
)
;
*
aTextureFactoryIdentifier
=
textureFactoryIdentifier
;
mDLBuilder
=
MakeUnique
<
wr
:
:
DisplayListBuilder
>
(
WrBridge
(
)
-
>
GetPipeline
(
)
WrBridge
(
)
-
>
GetWebRenderBackend
(
)
)
;
hasInitialized
=
true
;
return
true
;
}
void
WebRenderLayerManager
:
:
Destroy
(
)
{
DoDestroy
(
false
)
;
}
void
WebRenderLayerManager
:
:
DoDestroy
(
bool
aIsSync
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
IsDestroyed
(
)
)
{
return
;
}
mDLBuilder
=
nullptr
;
mUserData
.
Destroy
(
)
;
mPartialPrerenderedAnimations
.
Clear
(
)
;
mStateManager
.
Destroy
(
)
;
if
(
WrBridge
(
)
)
{
WrBridge
(
)
-
>
Destroy
(
aIsSync
)
;
}
mWebRenderCommandBuilder
.
Destroy
(
)
;
if
(
mTransactionIdAllocator
)
{
RefPtr
<
TransactionIdAllocator
>
allocator
=
mTransactionIdAllocator
;
TransactionId
id
=
mLatestTransactionId
;
RefPtr
<
Runnable
>
task
=
NS_NewRunnableFunction
(
"
TransactionIdAllocator
:
:
NotifyTransactionCompleted
"
[
allocator
id
]
(
)
-
>
void
{
allocator
-
>
ClearPendingTransactions
(
)
;
allocator
-
>
NotifyTransactionCompleted
(
id
)
;
}
)
;
NS_DispatchToMainThread
(
task
.
forget
(
)
)
;
}
mWidget
=
nullptr
;
mDestroyed
=
true
;
}
WebRenderLayerManager
:
:
~
WebRenderLayerManager
(
)
{
Destroy
(
)
;
MOZ_COUNT_DTOR
(
WebRenderLayerManager
)
;
}
CompositorBridgeChild
*
WebRenderLayerManager
:
:
GetCompositorBridgeChild
(
)
{
return
WrBridge
(
)
-
>
GetCompositorBridgeChild
(
)
;
}
void
WebRenderLayerManager
:
:
GetBackendName
(
nsAString
&
name
)
{
if
(
WrBridge
(
)
-
>
UsingSoftwareWebRenderD3D11
(
)
)
{
name
.
AssignLiteral
(
"
WebRender
(
Software
D3D11
)
"
)
;
}
else
if
(
WrBridge
(
)
-
>
UsingSoftwareWebRenderOpenGL
(
)
)
{
name
.
AssignLiteral
(
"
WebRender
(
Software
OpenGL
)
"
)
;
}
else
if
(
WrBridge
(
)
-
>
UsingSoftwareWebRender
(
)
)
{
name
.
AssignLiteral
(
"
WebRender
(
Software
)
"
)
;
}
else
{
name
.
AssignLiteral
(
"
WebRender
"
)
;
}
}
uint32_t
WebRenderLayerManager
:
:
StartFrameTimeRecording
(
int32_t
aBufferSize
)
{
CompositorBridgeChild
*
renderer
=
GetCompositorBridgeChild
(
)
;
if
(
renderer
)
{
uint32_t
startIndex
;
renderer
-
>
SendStartFrameTimeRecording
(
aBufferSize
&
startIndex
)
;
return
startIndex
;
}
return
-
1
;
}
void
WebRenderLayerManager
:
:
StopFrameTimeRecording
(
uint32_t
aStartIndex
nsTArray
<
float
>
&
aFrameIntervals
)
{
CompositorBridgeChild
*
renderer
=
GetCompositorBridgeChild
(
)
;
if
(
renderer
)
{
renderer
-
>
SendStopFrameTimeRecording
(
aStartIndex
&
aFrameIntervals
)
;
}
}
void
WebRenderLayerManager
:
:
TakeCompositionPayloads
(
nsTArray
<
CompositionPayload
>
&
aPayloads
)
{
aPayloads
.
Clear
(
)
;
std
:
:
swap
(
mPayload
aPayloads
)
;
}
bool
WebRenderLayerManager
:
:
BeginTransactionWithTarget
(
gfxContext
*
aTarget
const
nsCString
&
aURL
)
{
mTarget
=
aTarget
;
return
BeginTransaction
(
aURL
)
;
}
bool
WebRenderLayerManager
:
:
BeginTransaction
(
const
nsCString
&
aURL
)
{
if
(
!
WrBridge
(
)
-
>
IPCOpen
(
)
)
{
gfxCriticalNote
<
<
"
IPC
Channel
is
already
torn
down
unexpectedly
\
n
"
;
return
false
;
}
mTransactionStart
=
TimeStamp
:
:
Now
(
)
;
mURL
=
aURL
;
+
+
mPaintSequenceNumber
;
if
(
StaticPrefs
:
:
apz_test_logging_enabled
(
)
)
{
mApzTestData
.
StartNewPaint
(
mPaintSequenceNumber
)
;
}
return
true
;
}
bool
WebRenderLayerManager
:
:
EndEmptyTransaction
(
EndTransactionFlags
aFlags
)
{
if
(
!
WrBridge
(
)
-
>
GetSentDisplayList
(
)
)
{
return
false
;
}
mDisplayItemCache
.
SkipWaitingForPartialDisplayList
(
)
;
mAnimationReadyTime
=
TimeStamp
:
:
Now
(
)
;
mLatestTransactionId
=
mTransactionIdAllocator
-
>
GetTransactionId
(
true
)
;
if
(
aFlags
&
EndTransactionFlags
:
:
END_NO_COMPOSITE
&
&
!
mWebRenderCommandBuilder
.
NeedsEmptyTransaction
(
)
)
{
if
(
mPendingScrollUpdates
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
!
mTarget
)
;
WrBridge
(
)
-
>
SendSetFocusTarget
(
mFocusTarget
)
;
mTransactionIdAllocator
-
>
RevokeTransactionId
(
mLatestTransactionId
)
;
mLatestTransactionId
=
mLatestTransactionId
.
Prev
(
)
;
return
true
;
}
}
LayoutDeviceIntSize
size
=
mWidget
-
>
GetClientSize
(
)
;
WrBridge
(
)
-
>
BeginTransaction
(
)
;
mWebRenderCommandBuilder
.
EmptyTransaction
(
)
;
TimeStamp
refreshStart
=
mTransactionIdAllocator
-
>
GetTransactionStart
(
)
;
if
(
!
refreshStart
)
{
refreshStart
=
mTransactionStart
;
}
if
(
!
gfxPlatform
:
:
GetPlatform
(
)
-
>
DidRenderingDeviceReset
(
)
)
{
if
(
WrBridge
(
)
-
>
GetSyncObject
(
)
&
&
WrBridge
(
)
-
>
GetSyncObject
(
)
-
>
IsSyncObjectValid
(
)
)
{
WrBridge
(
)
-
>
GetSyncObject
(
)
-
>
Synchronize
(
)
;
}
}
GetCompositorBridgeChild
(
)
-
>
EndCanvasTransaction
(
)
;
Maybe
<
TransactionData
>
transactionData
;
if
(
mStateManager
.
mAsyncResourceUpdates
|
|
!
mPendingScrollUpdates
.
IsEmpty
(
)
|
|
WrBridge
(
)
-
>
HasWebRenderParentCommands
(
)
)
{
transactionData
.
emplace
(
)
;
transactionData
-
>
mIdNamespace
=
WrBridge
(
)
-
>
GetNamespace
(
)
;
transactionData
-
>
mPaintSequenceNumber
=
mPaintSequenceNumber
;
if
(
mStateManager
.
mAsyncResourceUpdates
)
{
mStateManager
.
mAsyncResourceUpdates
-
>
Flush
(
transactionData
-
>
mResourceUpdates
transactionData
-
>
mSmallShmems
transactionData
-
>
mLargeShmems
)
;
}
transactionData
-
>
mScrollUpdates
=
std
:
:
move
(
mPendingScrollUpdates
)
;
for
(
const
auto
&
scrollId
:
transactionData
-
>
mScrollUpdates
.
Keys
(
)
)
{
nsLayoutUtils
:
:
NotifyPaintSkipTransaction
(
scrollId
)
;
}
}
Maybe
<
wr
:
:
IpcResourceUpdateQueue
>
nothing
;
WrBridge
(
)
-
>
EndEmptyTransaction
(
mFocusTarget
std
:
:
move
(
transactionData
)
mLatestTransactionId
mTransactionIdAllocator
-
>
GetVsyncId
(
)
mTransactionIdAllocator
-
>
GetVsyncStart
(
)
refreshStart
mTransactionStart
mURL
)
;
mTransactionStart
=
TimeStamp
(
)
;
MakeSnapshotIfRequired
(
size
)
;
return
true
;
}
void
WebRenderLayerManager
:
:
EndTransactionWithoutLayer
(
nsDisplayList
*
aDisplayList
nsDisplayListBuilder
*
aDisplayListBuilder
WrFiltersHolder
&
&
aFilters
WebRenderBackgroundData
*
aBackground
const
double
aGeckoDLBuildTime
)
{
AUTO_PROFILER_TRACING_MARKER
(
"
Paint
"
"
WrDisplayList
"
GRAPHICS
)
;
mAnimationReadyTime
=
TimeStamp
:
:
Now
(
)
;
WrBridge
(
)
-
>
BeginTransaction
(
)
;
LayoutDeviceIntSize
size
=
mWidget
-
>
GetClientSize
(
)
;
mDLBuilder
-
>
Begin
(
&
mDisplayItemCache
)
;
wr
:
:
IpcResourceUpdateQueue
resourceUpdates
(
WrBridge
(
)
)
;
wr
:
:
usize
builderDumpIndex
=
0
;
bool
containsSVGGroup
=
false
;
bool
dumpEnabled
=
mWebRenderCommandBuilder
.
ShouldDumpDisplayList
(
aDisplayListBuilder
)
;
Maybe
<
AutoDisplayItemCacheSuppressor
>
cacheSuppressor
;
if
(
dumpEnabled
)
{
cacheSuppressor
.
emplace
(
&
mDisplayItemCache
)
;
printf_stderr
(
"
-
-
WebRender
display
list
build
-
-
\
n
"
)
;
}
if
(
XRE_IsContentProcess
(
)
&
&
StaticPrefs
:
:
gfx_webrender_debug_dl_dump_content_serialized
(
)
)
{
mDLBuilder
-
>
DumpSerializedDisplayList
(
)
;
}
if
(
aDisplayList
)
{
MOZ_ASSERT
(
aDisplayListBuilder
&
&
!
aBackground
)
;
mDisplayItemCache
.
SetDisplayList
(
aDisplayListBuilder
aDisplayList
)
;
mWebRenderCommandBuilder
.
BuildWebRenderCommands
(
*
mDLBuilder
resourceUpdates
aDisplayList
aDisplayListBuilder
mScrollData
std
:
:
move
(
aFilters
)
)
;
aDisplayListBuilder
-
>
NotifyAndClearScrollFrames
(
)
;
builderDumpIndex
=
mWebRenderCommandBuilder
.
GetBuilderDumpIndex
(
)
;
containsSVGGroup
=
mWebRenderCommandBuilder
.
GetContainsSVGGroup
(
)
;
}
else
{
MOZ_ASSERT
(
!
aDisplayListBuilder
&
&
aBackground
)
;
aBackground
-
>
AddWebRenderCommands
(
*
mDLBuilder
)
;
if
(
dumpEnabled
)
{
printf_stderr
(
"
(
no
display
list
;
background
only
)
\
n
"
)
;
builderDumpIndex
=
mDLBuilder
-
>
Dump
(
1
Some
(
builderDumpIndex
)
Nothing
(
)
)
;
}
}
mWidget
-
>
AddWindowOverlayWebRenderCommands
(
WrBridge
(
)
*
mDLBuilder
resourceUpdates
)
;
if
(
dumpEnabled
)
{
printf_stderr
(
"
(
window
overlay
)
\
n
"
)
;
Unused
<
<
mDLBuilder
-
>
Dump
(
1
Some
(
builderDumpIndex
)
Nothing
(
)
)
;
}
if
(
AsyncPanZoomEnabled
(
)
)
{
if
(
mIsFirstPaint
)
{
mScrollData
.
SetIsFirstPaint
(
)
;
mIsFirstPaint
=
false
;
}
mScrollData
.
SetPaintSequenceNumber
(
mPaintSequenceNumber
)
;
if
(
dumpEnabled
)
{
std
:
:
stringstream
str
;
str
<
<
mScrollData
;
print_stderr
(
str
)
;
}
}
auto
scrollIdsUpdated
=
ClearPendingScrollInfoUpdate
(
)
;
for
(
ScrollableLayerGuid
:
:
ViewID
update
:
scrollIdsUpdated
)
{
nsLayoutUtils
:
:
NotifyPaintSkipTransaction
(
update
)
;
}
mLatestTransactionId
=
mTransactionIdAllocator
-
>
GetTransactionId
(
true
)
;
TimeStamp
refreshStart
=
mTransactionIdAllocator
-
>
GetTransactionStart
(
)
;
if
(
!
refreshStart
)
{
refreshStart
=
mTransactionStart
;
}
if
(
mStateManager
.
mAsyncResourceUpdates
)
{
if
(
resourceUpdates
.
IsEmpty
(
)
)
{
resourceUpdates
.
ReplaceResources
(
std
:
:
move
(
mStateManager
.
mAsyncResourceUpdates
.
ref
(
)
)
)
;
}
else
{
WrBridge
(
)
-
>
UpdateResources
(
mStateManager
.
mAsyncResourceUpdates
.
ref
(
)
)
;
}
mStateManager
.
mAsyncResourceUpdates
.
reset
(
)
;
}
mStateManager
.
DiscardImagesInTransaction
(
resourceUpdates
)
;
WrBridge
(
)
-
>
RemoveExpiredFontKeys
(
resourceUpdates
)
;
if
(
!
gfxPlatform
:
:
GetPlatform
(
)
-
>
DidRenderingDeviceReset
(
)
)
{
if
(
WrBridge
(
)
-
>
GetSyncObject
(
)
&
&
WrBridge
(
)
-
>
GetSyncObject
(
)
-
>
IsSyncObjectValid
(
)
)
{
WrBridge
(
)
-
>
GetSyncObject
(
)
-
>
Synchronize
(
)
;
}
}
GetCompositorBridgeChild
(
)
-
>
EndCanvasTransaction
(
)
;
{
AUTO_PROFILER_TRACING_MARKER
(
"
Paint
"
"
ForwardDPTransaction
"
GRAPHICS
)
;
DisplayListData
dlData
;
mDLBuilder
-
>
End
(
dlData
)
;
resourceUpdates
.
Flush
(
dlData
.
mResourceUpdates
dlData
.
mSmallShmems
dlData
.
mLargeShmems
)
;
dlData
.
mRect
=
LayoutDeviceRect
(
LayoutDevicePoint
(
)
LayoutDeviceSize
(
size
)
)
;
dlData
.
mScrollData
.
emplace
(
std
:
:
move
(
mScrollData
)
)
;
dlData
.
mDLDesc
.
gecko_display_list_type
=
aDisplayListBuilder
&
&
aDisplayListBuilder
-
>
PartialBuildFailed
(
)
?
wr
:
:
GeckoDisplayListType
:
:
Full
(
aGeckoDLBuildTime
)
:
wr
:
:
GeckoDisplayListType
:
:
Partial
(
aGeckoDLBuildTime
)
;
auto
duration
=
TimeDuration
:
:
FromMicroseconds
(
double
(
dlData
.
mDLDesc
.
builder_finish_time
-
dlData
.
mDLDesc
.
builder_start_time
)
/
1000
.
)
;
PerfStats
:
:
RecordMeasurement
(
PerfStats
:
:
Metric
:
:
WrDisplayListBuilding
duration
)
;
bool
ret
=
WrBridge
(
)
-
>
EndTransaction
(
std
:
:
move
(
dlData
)
mLatestTransactionId
containsSVGGroup
mTransactionIdAllocator
-
>
GetVsyncId
(
)
mTransactionIdAllocator
-
>
GetVsyncStart
(
)
refreshStart
mTransactionStart
mURL
)
;
if
(
!
ret
)
{
mDisplayItemCache
.
Clear
(
)
;
}
WrBridge
(
)
-
>
SendSetFocusTarget
(
mFocusTarget
)
;
mFocusTarget
=
FocusTarget
(
)
;
}
mStateManager
.
DiscardCompositorAnimations
(
)
;
mTransactionStart
=
TimeStamp
(
)
;
MakeSnapshotIfRequired
(
size
)
;
mNeedsComposite
=
false
;
}
void
WebRenderLayerManager
:
:
SetFocusTarget
(
const
FocusTarget
&
aFocusTarget
)
{
mFocusTarget
=
aFocusTarget
;
}
bool
WebRenderLayerManager
:
:
AsyncPanZoomEnabled
(
)
const
{
return
mWidget
-
>
AsyncPanZoomEnabled
(
)
;
}
void
WebRenderLayerManager
:
:
MakeSnapshotIfRequired
(
LayoutDeviceIntSize
aSize
)
{
if
(
!
mTarget
|
|
aSize
.
IsEmpty
(
)
)
{
return
;
}
SurfaceFormat
format
=
#
ifdef
MOZ_WIDGET_ANDROID
SurfaceFormat
:
:
R8G8B8A8
;
#
else
SurfaceFormat
:
:
B8G8R8A8
;
#
endif
RefPtr
<
TextureClient
>
texture
=
TextureClient
:
:
CreateForRawBufferAccess
(
WrBridge
(
)
format
aSize
.
ToUnknownSize
(
)
BackendType
:
:
SKIA
TextureFlags
:
:
SNAPSHOT
)
;
if
(
!
texture
)
{
return
;
}
texture
-
>
InitIPDLActor
(
WrBridge
(
)
)
;
if
(
!
texture
-
>
GetIPDLActor
(
)
)
{
return
;
}
IntRect
bounds
=
ToOutsideIntRect
(
mTarget
-
>
GetClipExtents
(
)
)
;
bool
needsYFlip
=
false
;
if
(
!
WrBridge
(
)
-
>
SendGetSnapshot
(
texture
-
>
GetIPDLActor
(
)
&
needsYFlip
)
)
{
return
;
}
TextureClientAutoLock
autoLock
(
texture
OpenMode
:
:
OPEN_READ_ONLY
)
;
if
(
!
autoLock
.
Succeeded
(
)
)
{
return
;
}
RefPtr
<
DrawTarget
>
drawTarget
=
texture
-
>
BorrowDrawTarget
(
)
;
if
(
!
drawTarget
|
|
!
drawTarget
-
>
IsValid
(
)
)
{
return
;
}
RefPtr
<
SourceSurface
>
snapshot
=
drawTarget
-
>
Snapshot
(
)
;
Rect
dst
(
bounds
.
X
(
)
bounds
.
Y
(
)
bounds
.
Width
(
)
bounds
.
Height
(
)
)
;
Rect
src
(
0
0
bounds
.
Width
(
)
bounds
.
Height
(
)
)
;
Matrix
m
;
if
(
needsYFlip
)
{
m
=
Matrix
:
:
Scaling
(
1
.
0
-
1
.
0
)
.
PostTranslate
(
0
.
0
aSize
.
height
)
;
}
SurfacePattern
pattern
(
snapshot
ExtendMode
:
:
CLAMP
m
)
;
DrawTarget
*
dt
=
mTarget
-
>
GetDrawTarget
(
)
;
MOZ_RELEASE_ASSERT
(
dt
)
;
dt
-
>
FillRect
(
dst
pattern
)
;
mTarget
=
nullptr
;
}
void
WebRenderLayerManager
:
:
DiscardImages
(
)
{
wr
:
:
IpcResourceUpdateQueue
resources
(
WrBridge
(
)
)
;
mStateManager
.
DiscardImagesInTransaction
(
resources
)
;
WrBridge
(
)
-
>
UpdateResources
(
resources
)
;
}
void
WebRenderLayerManager
:
:
DiscardLocalImages
(
)
{
mStateManager
.
DiscardLocalImages
(
)
;
}
void
WebRenderLayerManager
:
:
SetLayersObserverEpoch
(
LayersObserverEpoch
aEpoch
)
{
if
(
WrBridge
(
)
-
>
IPCOpen
(
)
)
{
WrBridge
(
)
-
>
SendSetLayersObserverEpoch
(
aEpoch
)
;
}
}
void
WebRenderLayerManager
:
:
DidComposite
(
TransactionId
aTransactionId
const
mozilla
:
:
TimeStamp
&
aCompositeStart
const
mozilla
:
:
TimeStamp
&
aCompositeEnd
)
{
if
(
IsDestroyed
(
)
)
{
return
;
}
MOZ_ASSERT
(
mWidget
)
;
RefPtr
<
WebRenderLayerManager
>
selfRef
=
this
;
if
(
aTransactionId
.
IsValid
(
)
)
{
nsIWidgetListener
*
listener
=
mWidget
-
>
GetWidgetListener
(
)
;
if
(
listener
)
{
listener
-
>
DidCompositeWindow
(
aTransactionId
aCompositeStart
aCompositeEnd
)
;
}
listener
=
mWidget
-
>
GetAttachedWidgetListener
(
)
;
if
(
listener
)
{
listener
-
>
DidCompositeWindow
(
aTransactionId
aCompositeStart
aCompositeEnd
)
;
}
if
(
mTransactionIdAllocator
)
{
mTransactionIdAllocator
-
>
NotifyTransactionCompleted
(
aTransactionId
)
;
}
}
}
void
WebRenderLayerManager
:
:
ClearCachedResources
(
)
{
if
(
!
WrBridge
(
)
-
>
IPCOpen
(
)
)
{
gfxCriticalNote
<
<
"
IPC
Channel
is
already
torn
down
unexpectedly
\
n
"
;
return
;
}
WrBridge
(
)
-
>
BeginClearCachedResources
(
)
;
mStateManager
.
FlushAsyncResourceUpdates
(
)
;
mWebRenderCommandBuilder
.
ClearCachedResources
(
)
;
DiscardImages
(
)
;
mStateManager
.
ClearCachedResources
(
)
;
WrBridge
(
)
-
>
EndClearCachedResources
(
)
;
}
void
WebRenderLayerManager
:
:
ClearAnimationResources
(
)
{
if
(
!
WrBridge
(
)
-
>
IPCOpen
(
)
)
{
gfxCriticalNote
<
<
"
IPC
Channel
is
already
torn
down
unexpectedly
\
n
"
;
return
;
}
WrBridge
(
)
-
>
SendClearAnimationResources
(
)
;
}
void
WebRenderLayerManager
:
:
WrUpdated
(
)
{
ClearAsyncAnimations
(
)
;
mStateManager
.
mAsyncResourceUpdates
.
reset
(
)
;
mWebRenderCommandBuilder
.
ClearCachedResources
(
)
;
DiscardLocalImages
(
)
;
mDisplayItemCache
.
Clear
(
)
;
if
(
mWidget
)
{
if
(
dom
:
:
BrowserChild
*
browserChild
=
mWidget
-
>
GetOwningBrowserChild
(
)
)
{
browserChild
-
>
SchedulePaint
(
)
;
}
}
}
void
WebRenderLayerManager
:
:
UpdateTextureFactoryIdentifier
(
const
TextureFactoryIdentifier
&
aNewIdentifier
)
{
WrBridge
(
)
-
>
IdentifyTextureHost
(
aNewIdentifier
)
;
}
TextureFactoryIdentifier
WebRenderLayerManager
:
:
GetTextureFactoryIdentifier
(
)
{
return
WrBridge
(
)
-
>
GetTextureFactoryIdentifier
(
)
;
}
void
WebRenderLayerManager
:
:
SetTransactionIdAllocator
(
TransactionIdAllocator
*
aAllocator
)
{
if
(
mTransactionIdAllocator
&
&
(
aAllocator
!
=
mTransactionIdAllocator
)
)
{
mTransactionIdAllocator
-
>
ClearPendingTransactions
(
)
;
if
(
aAllocator
)
{
aAllocator
-
>
ResetInitialTransactionId
(
mTransactionIdAllocator
-
>
LastTransactionId
(
)
)
;
}
}
mTransactionIdAllocator
=
aAllocator
;
}
TransactionId
WebRenderLayerManager
:
:
GetLastTransactionId
(
)
{
return
mLatestTransactionId
;
}
void
WebRenderLayerManager
:
:
FlushRendering
(
wr
:
:
RenderReasons
aReasons
)
{
CompositorBridgeChild
*
cBridge
=
GetCompositorBridgeChild
(
)
;
if
(
!
cBridge
)
{
return
;
}
MOZ_ASSERT
(
mWidget
)
;
bool
resizing
=
mWidget
&
&
mWidget
-
>
IsResizingNativeWidget
(
)
.
valueOr
(
true
)
;
if
(
resizing
)
{
aReasons
=
aReasons
|
wr
:
:
RenderReasons
:
:
RESIZE
;
}
if
(
WrBridge
(
)
-
>
GetCompositorUseDComp
(
)
&
&
!
resizing
)
{
cBridge
-
>
SendFlushRenderingAsync
(
aReasons
)
;
}
else
if
(
mWidget
-
>
SynchronouslyRepaintOnResize
(
)
|
|
StaticPrefs
:
:
layers_force_synchronous_resize
(
)
)
{
cBridge
-
>
SendFlushRendering
(
aReasons
)
;
}
else
{
cBridge
-
>
SendFlushRenderingAsync
(
aReasons
)
;
}
}
void
WebRenderLayerManager
:
:
WaitOnTransactionProcessed
(
)
{
CompositorBridgeChild
*
bridge
=
GetCompositorBridgeChild
(
)
;
if
(
bridge
)
{
bridge
-
>
SendWaitOnTransactionProcessed
(
)
;
}
}
void
WebRenderLayerManager
:
:
SendInvalidRegion
(
const
nsIntRegion
&
aRegion
)
{
#
ifdef
XP_WIN
const
bool
needsInvalidate
=
!
gfx
:
:
gfxVars
:
:
DwmCompositionEnabled
(
)
;
#
else
const
bool
needsInvalidate
=
true
;
#
endif
if
(
needsInvalidate
&
&
WrBridge
(
)
)
{
WrBridge
(
)
-
>
SendInvalidateRenderedFrame
(
)
;
}
}
void
WebRenderLayerManager
:
:
ScheduleComposite
(
wr
:
:
RenderReasons
aReasons
)
{
WrBridge
(
)
-
>
SendScheduleComposite
(
aReasons
)
;
}
already_AddRefed
<
PersistentBufferProvider
>
WebRenderLayerManager
:
:
CreatePersistentBufferProvider
(
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
)
{
if
(
!
gfxPlatform
:
:
UseRemoteCanvas
(
)
)
{
#
ifdef
XP_WIN
if
(
!
IsWin32kLockedDown
(
)
)
{
gfxPlatform
:
:
GetPlatform
(
)
-
>
EnsureDevicesInitialized
(
)
;
}
#
else
gfxPlatform
:
:
GetPlatform
(
)
-
>
EnsureDevicesInitialized
(
)
;
#
endif
}
RefPtr
<
PersistentBufferProvider
>
provider
=
PersistentBufferProviderShared
:
:
Create
(
aSize
aFormat
AsKnowsCompositor
(
)
)
;
if
(
provider
)
{
return
provider
.
forget
(
)
;
}
return
WindowRenderer
:
:
CreatePersistentBufferProvider
(
aSize
aFormat
)
;
}
void
WebRenderLayerManager
:
:
ClearAsyncAnimations
(
)
{
mStateManager
.
ClearAsyncAnimations
(
)
;
}
void
WebRenderLayerManager
:
:
WrReleasedImages
(
const
nsTArray
<
wr
:
:
ExternalImageKeyPair
>
&
aPairs
)
{
mStateManager
.
WrReleasedImages
(
aPairs
)
;
}
void
WebRenderLayerManager
:
:
GetFrameUniformity
(
FrameUniformityData
*
aOutData
)
{
WrBridge
(
)
-
>
SendGetFrameUniformity
(
aOutData
)
;
}
void
WebRenderLayerManager
:
:
LayerUserDataDestroy
(
void
*
data
)
{
delete
static_cast
<
LayerUserData
*
>
(
data
)
;
}
UniquePtr
<
LayerUserData
>
WebRenderLayerManager
:
:
RemoveUserData
(
void
*
aKey
)
{
UniquePtr
<
LayerUserData
>
d
(
static_cast
<
LayerUserData
*
>
(
mUserData
.
Remove
(
static_cast
<
gfx
:
:
UserDataKey
*
>
(
aKey
)
)
)
)
;
return
d
;
}
std
:
:
unordered_set
<
ScrollableLayerGuid
:
:
ViewID
>
WebRenderLayerManager
:
:
ClearPendingScrollInfoUpdate
(
)
{
std
:
:
unordered_set
<
ScrollableLayerGuid
:
:
ViewID
>
scrollIds
(
mPendingScrollUpdates
.
Keys
(
)
.
cbegin
(
)
mPendingScrollUpdates
.
Keys
(
)
.
cend
(
)
)
;
mPendingScrollUpdates
.
Clear
(
)
;
return
scrollIds
;
}
}
}
