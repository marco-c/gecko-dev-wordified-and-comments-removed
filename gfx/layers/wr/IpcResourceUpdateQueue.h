#
ifndef
GFX_WR_IPCRESOURCEUPDATEQUEUE_H
#
define
GFX_WR_IPCRESOURCEUPDATEQUEUE_H
#
include
"
mozilla
/
layers
/
WebRenderMessages
.
h
"
#
include
"
mozilla
/
layers
/
RefCountedShmem
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderTypes
.
h
"
namespace
mozilla
{
namespace
ipc
{
class
IShmemAllocator
;
}
namespace
layers
{
class
TextureClient
;
}
namespace
wr
{
class
ShmSegmentsWriter
{
public
:
ShmSegmentsWriter
(
layers
:
:
WebRenderBridgeChild
*
aAllocator
size_t
aChunkSize
)
;
~
ShmSegmentsWriter
(
)
;
ShmSegmentsWriter
(
ShmSegmentsWriter
&
&
aOther
)
noexcept
;
ShmSegmentsWriter
&
operator
=
(
ShmSegmentsWriter
&
&
aOther
)
noexcept
;
ShmSegmentsWriter
(
const
ShmSegmentsWriter
&
aOther
)
=
delete
;
ShmSegmentsWriter
&
operator
=
(
const
ShmSegmentsWriter
&
aOther
)
=
delete
;
layers
:
:
OffsetRange
Write
(
Range
<
uint8_t
>
aBytes
)
;
template
<
typename
T
>
layers
:
:
OffsetRange
WriteAsBytes
(
Range
<
T
>
aValues
)
{
return
Write
(
Range
<
uint8_t
>
(
(
uint8_t
*
)
aValues
.
begin
(
)
.
get
(
)
aValues
.
length
(
)
*
sizeof
(
T
)
)
)
;
}
void
Flush
(
nsTArray
<
layers
:
:
RefCountedShmem
>
&
aSmallAllocs
nsTArray
<
mozilla
:
:
ipc
:
:
Shmem
>
&
aLargeAllocs
)
;
void
Clear
(
)
;
bool
IsEmpty
(
)
const
;
layers
:
:
WebRenderBridgeChild
*
WrBridge
(
)
const
{
return
mShmAllocator
;
}
size_t
ChunkSize
(
)
const
{
return
mChunkSize
;
}
protected
:
bool
AllocChunk
(
)
;
layers
:
:
OffsetRange
AllocLargeChunk
(
size_t
aSize
)
;
nsTArray
<
layers
:
:
RefCountedShmem
>
mSmallAllocs
;
nsTArray
<
mozilla
:
:
ipc
:
:
Shmem
>
mLargeAllocs
;
layers
:
:
WebRenderBridgeChild
*
mShmAllocator
;
size_t
mCursor
;
size_t
mChunkSize
;
}
;
class
ShmSegmentsReader
{
public
:
ShmSegmentsReader
(
const
nsTArray
<
layers
:
:
RefCountedShmem
>
&
aSmallShmems
const
nsTArray
<
mozilla
:
:
ipc
:
:
Shmem
>
&
aLargeShmems
)
;
bool
Read
(
const
layers
:
:
OffsetRange
&
aRange
wr
:
:
Vec
<
uint8_t
>
&
aInto
)
;
protected
:
bool
ReadLarge
(
const
layers
:
:
OffsetRange
&
aRange
wr
:
:
Vec
<
uint8_t
>
&
aInto
)
;
const
nsTArray
<
layers
:
:
RefCountedShmem
>
&
mSmallAllocs
;
const
nsTArray
<
mozilla
:
:
ipc
:
:
Shmem
>
&
mLargeAllocs
;
size_t
mChunkSize
;
}
;
class
IpcResourceUpdateQueue
{
public
:
explicit
IpcResourceUpdateQueue
(
layers
:
:
WebRenderBridgeChild
*
aAllocator
wr
:
:
RenderRoot
aRenderRoot
=
wr
:
:
RenderRoot
:
:
Default
size_t
aChunkSize
=
57328
)
;
IpcResourceUpdateQueue
&
SubQueue
(
wr
:
:
RenderRoot
aRenderRoot
)
{
MOZ_ASSERT
(
mRenderRoot
=
=
wr
:
:
RenderRoot
:
:
Default
)
;
if
(
aRenderRoot
=
=
wr
:
:
RenderRoot
:
:
Default
)
{
MOZ_ASSERT
(
mRenderRoot
=
=
wr
:
:
RenderRoot
:
:
Default
)
;
return
*
this
;
}
if
(
!
mSubQueues
[
aRenderRoot
]
)
{
mSubQueues
[
aRenderRoot
]
=
MakeUnique
<
IpcResourceUpdateQueue
>
(
mWriter
.
WrBridge
(
)
aRenderRoot
mWriter
.
ChunkSize
(
)
)
;
}
return
*
mSubQueues
[
aRenderRoot
]
;
}
bool
HasAnySubQueue
(
)
{
for
(
auto
renderRoot
:
wr
:
:
kNonDefaultRenderRoots
)
{
if
(
mSubQueues
[
renderRoot
]
)
{
return
true
;
}
}
return
false
;
}
bool
HasSubQueue
(
wr
:
:
RenderRoot
aRenderRoot
)
{
return
aRenderRoot
=
=
wr
:
:
RenderRoot
:
:
Default
|
|
!
!
mSubQueues
[
aRenderRoot
]
;
}
wr
:
:
RenderRoot
GetRenderRoot
(
)
{
return
mRenderRoot
;
}
IpcResourceUpdateQueue
(
IpcResourceUpdateQueue
&
&
aOther
)
noexcept
;
IpcResourceUpdateQueue
&
operator
=
(
IpcResourceUpdateQueue
&
&
aOther
)
noexcept
;
IpcResourceUpdateQueue
(
const
IpcResourceUpdateQueue
&
aOther
)
=
delete
;
IpcResourceUpdateQueue
&
operator
=
(
const
IpcResourceUpdateQueue
&
aOther
)
=
delete
;
void
ReplaceResources
(
IpcResourceUpdateQueue
&
&
aOther
)
;
bool
AddImage
(
wr
:
:
ImageKey
aKey
const
ImageDescriptor
&
aDescriptor
Range
<
uint8_t
>
aBytes
)
;
bool
AddBlobImage
(
wr
:
:
BlobImageKey
aKey
const
ImageDescriptor
&
aDescriptor
Range
<
uint8_t
>
aBytes
)
;
void
AddExternalImage
(
wr
:
:
ExternalImageId
aExtId
wr
:
:
ImageKey
aKey
)
;
void
PushExternalImageForTexture
(
wr
:
:
ExternalImageId
aExtId
wr
:
:
ImageKey
aKey
layers
:
:
TextureClient
*
aTexture
bool
aIsUpdate
)
;
bool
UpdateImageBuffer
(
wr
:
:
ImageKey
aKey
const
ImageDescriptor
&
aDescriptor
Range
<
uint8_t
>
aBytes
)
;
bool
UpdateBlobImage
(
wr
:
:
BlobImageKey
aKey
const
ImageDescriptor
&
aDescriptor
Range
<
uint8_t
>
aBytes
ImageIntRect
aDirtyRect
)
;
void
UpdateExternalImage
(
ExternalImageId
aExtID
ImageKey
aKey
ImageIntRect
aDirtyRect
)
;
void
SetBlobImageVisibleArea
(
BlobImageKey
aKey
const
ImageIntRect
&
aArea
)
;
void
DeleteImage
(
wr
:
:
ImageKey
aKey
)
;
void
DeleteBlobImage
(
wr
:
:
BlobImageKey
aKey
)
;
bool
AddRawFont
(
wr
:
:
FontKey
aKey
Range
<
uint8_t
>
aBytes
uint32_t
aIndex
)
;
bool
AddFontDescriptor
(
wr
:
:
FontKey
aKey
Range
<
uint8_t
>
aBytes
uint32_t
aIndex
)
;
void
DeleteFont
(
wr
:
:
FontKey
aKey
)
;
void
AddFontInstance
(
wr
:
:
FontInstanceKey
aKey
wr
:
:
FontKey
aFontKey
float
aGlyphSize
const
wr
:
:
FontInstanceOptions
*
aOptions
const
wr
:
:
FontInstancePlatformOptions
*
aPlatformOptions
Range
<
const
gfx
:
:
FontVariation
>
aVariations
)
;
void
DeleteFontInstance
(
wr
:
:
FontInstanceKey
aKey
)
;
void
Clear
(
)
;
void
Flush
(
nsTArray
<
layers
:
:
OpUpdateResource
>
&
aUpdates
nsTArray
<
layers
:
:
RefCountedShmem
>
&
aSmallAllocs
nsTArray
<
mozilla
:
:
ipc
:
:
Shmem
>
&
aLargeAllocs
)
;
bool
IsEmpty
(
)
const
;
static
void
ReleaseShmems
(
mozilla
:
:
ipc
:
:
IProtocol
*
nsTArray
<
layers
:
:
RefCountedShmem
>
&
aShms
)
;
static
void
ReleaseShmems
(
mozilla
:
:
ipc
:
:
IProtocol
*
nsTArray
<
mozilla
:
:
ipc
:
:
Shmem
>
&
aShms
)
;
protected
:
ShmSegmentsWriter
mWriter
;
nsTArray
<
layers
:
:
OpUpdateResource
>
mUpdates
;
wr
:
:
NonDefaultRenderRootArray
<
UniquePtr
<
IpcResourceUpdateQueue
>
>
mSubQueues
;
wr
:
:
RenderRoot
mRenderRoot
;
}
;
}
}
#
endif
