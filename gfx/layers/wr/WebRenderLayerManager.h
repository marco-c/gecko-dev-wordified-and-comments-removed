#
ifndef
GFX_WEBRENDERLAYERMANAGER_H
#
define
GFX_WEBRENDERLAYERMANAGER_H
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
string
>
#
include
"
Units
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
DisplayItemCache
.
h
"
#
include
"
mozilla
/
layers
/
FocusTarget
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
RenderRootStateManager
.
h
"
#
include
"
mozilla
/
layers
/
ScrollableLayerGuid
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderCommandBuilder
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderScrollData
.
h
"
#
include
"
WindowRenderer
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTHashSet
.
h
"
class
gfxContext
;
class
nsIWidget
;
namespace
mozilla
{
class
nsDisplayList
;
class
nsDisplayListBuilder
;
struct
ActiveScrolledRoot
;
namespace
layers
{
class
APZTestData
;
class
CompositorBridgeChild
;
class
KnowsCompositor
;
class
Layer
;
class
PCompositorBridgeChild
;
class
WebRenderBridgeChild
;
class
WebRenderParentCommand
;
class
TransactionIdAllocator
;
class
LayerUserData
;
class
WebRenderLayerManager
final
:
public
WindowRenderer
{
typedef
nsTHashSet
<
RefPtr
<
WebRenderUserData
>
>
WebRenderUserDataRefTable
;
public
:
explicit
WebRenderLayerManager
(
nsIWidget
*
aWidget
)
;
bool
Initialize
(
PCompositorBridgeChild
*
aCBChild
wr
:
:
PipelineId
aLayersId
TextureFactoryIdentifier
*
aTextureFactoryIdentifier
nsCString
&
aError
)
;
void
Destroy
(
)
override
;
bool
IsDestroyed
(
)
{
return
mDestroyed
;
}
void
DoDestroy
(
bool
aIsSync
)
;
protected
:
virtual
~
WebRenderLayerManager
(
)
;
public
:
KnowsCompositor
*
AsKnowsCompositor
(
)
override
;
WebRenderLayerManager
*
AsWebRender
(
)
override
{
return
this
;
}
CompositorBridgeChild
*
GetCompositorBridgeChild
(
)
override
;
int32_t
GetMaxTextureSize
(
)
const
override
{
return
INT32_MAX
;
}
bool
BeginTransactionWithTarget
(
gfxContext
*
aTarget
const
nsCString
&
aURL
)
;
bool
BeginTransaction
(
const
nsCString
&
aURL
)
override
;
bool
EndEmptyTransaction
(
EndTransactionFlags
aFlags
=
END_DEFAULT
)
override
;
void
EndTransactionWithoutLayer
(
nsDisplayList
*
aDisplayList
nsDisplayListBuilder
*
aDisplayListBuilder
WrFiltersHolder
&
&
aFilters
WebRenderBackgroundData
*
aBackground
const
double
aGeckoDLBuildTime
bool
aRenderOffscreen
)
;
LayersBackend
GetBackendType
(
)
override
{
return
LayersBackend
:
:
LAYERS_WR
;
}
void
GetBackendName
(
nsAString
&
name
)
override
;
bool
NeedsWidgetInvalidation
(
)
override
{
return
false
;
}
bool
AddPendingScrollUpdateForNextTransaction
(
ScrollableLayerGuid
:
:
ViewID
aScrollId
const
ScrollPositionUpdate
&
aUpdateInfo
)
override
;
void
DidComposite
(
TransactionId
aTransactionId
const
mozilla
:
:
TimeStamp
&
aCompositeStart
const
mozilla
:
:
TimeStamp
&
aCompositeEnd
)
;
void
ClearCachedResources
(
)
;
void
UpdateTextureFactoryIdentifier
(
const
TextureFactoryIdentifier
&
aNewIdentifier
)
;
TextureFactoryIdentifier
GetTextureFactoryIdentifier
(
)
;
void
SetTransactionIdAllocator
(
TransactionIdAllocator
*
aAllocator
)
;
TransactionId
GetLastTransactionId
(
)
;
void
FlushRendering
(
wr
:
:
RenderReasons
aReasons
)
override
;
void
WaitOnTransactionProcessed
(
)
override
;
void
SendInvalidRegion
(
const
nsIntRegion
&
aRegion
)
;
void
ScheduleComposite
(
wr
:
:
RenderReasons
aReasons
)
;
void
SetNeedsComposite
(
bool
aNeedsComposite
)
{
mNeedsComposite
=
aNeedsComposite
;
}
bool
NeedsComposite
(
)
const
{
return
mNeedsComposite
;
}
void
SetIsFirstPaint
(
)
{
mIsFirstPaint
=
true
;
}
bool
GetIsFirstPaint
(
)
const
{
return
mIsFirstPaint
;
}
void
SetFocusTarget
(
const
FocusTarget
&
aFocusTarget
)
;
already_AddRefed
<
PersistentBufferProvider
>
CreatePersistentBufferProvider
(
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
bool
aWillReadFrequently
)
override
;
bool
AsyncPanZoomEnabled
(
)
const
;
void
DiscardImages
(
)
;
void
DiscardLocalImages
(
)
;
void
ClearAsyncAnimations
(
)
;
void
WrReleasedImages
(
const
nsTArray
<
wr
:
:
ExternalImageKeyPair
>
&
aPairs
)
;
WebRenderBridgeChild
*
WrBridge
(
)
const
{
return
mWrChild
;
}
void
LogTestDataForCurrentPaint
(
ScrollableLayerGuid
:
:
ViewID
aScrollId
const
std
:
:
string
&
aKey
const
std
:
:
string
&
aValue
)
;
void
LogAdditionalTestData
(
const
std
:
:
string
&
aKey
const
std
:
:
string
&
aValue
)
;
const
APZTestData
&
GetAPZTestData
(
)
const
{
return
*
mApzTestData
.
get
(
)
;
}
WebRenderCommandBuilder
&
CommandBuilder
(
)
{
return
mWebRenderCommandBuilder
;
}
WebRenderUserDataRefTable
*
GetWebRenderUserDataTable
(
)
{
return
mWebRenderCommandBuilder
.
GetWebRenderUserDataTable
(
)
;
}
WebRenderScrollData
&
GetScrollData
(
)
{
return
mScrollData
;
}
void
WrUpdated
(
)
;
nsIWidget
*
GetWidget
(
)
{
return
mWidget
;
}
uint32_t
StartFrameTimeRecording
(
int32_t
aBufferSize
)
override
;
void
StopFrameTimeRecording
(
uint32_t
aStartIndex
nsTArray
<
float
>
&
aFrameIntervals
)
override
;
RenderRootStateManager
*
GetRenderRootStateManager
(
)
{
return
&
mStateManager
;
}
void
TakeCompositionPayloads
(
nsTArray
<
CompositionPayload
>
&
aPayloads
)
;
void
GetFrameUniformity
(
FrameUniformityData
*
aOutData
)
override
;
void
RegisterPayloads
(
nsTArray
<
CompositionPayload
>
&
&
aPayloads
)
{
mPayload
.
AppendElements
(
std
:
:
move
(
aPayloads
)
)
;
MOZ_ASSERT
(
mPayload
.
Length
(
)
<
10000
)
;
}
static
void
LayerUserDataDestroy
(
void
*
data
)
;
void
SetUserData
(
void
*
aKey
LayerUserData
*
aData
)
{
mUserData
.
Add
(
static_cast
<
gfx
:
:
UserDataKey
*
>
(
aKey
)
aData
LayerUserDataDestroy
)
;
}
UniquePtr
<
LayerUserData
>
RemoveUserData
(
void
*
aKey
)
;
bool
HasUserData
(
void
*
aKey
)
{
return
mUserData
.
Has
(
static_cast
<
gfx
:
:
UserDataKey
*
>
(
aKey
)
)
;
}
LayerUserData
*
GetUserData
(
void
*
aKey
)
const
{
return
static_cast
<
LayerUserData
*
>
(
mUserData
.
Get
(
static_cast
<
gfx
:
:
UserDataKey
*
>
(
aKey
)
)
)
;
}
std
:
:
unordered_set
<
ScrollableLayerGuid
:
:
ViewID
>
ClearPendingScrollInfoUpdate
(
)
;
#
ifdef
DEBUG
gfxContext
*
GetTarget
(
)
const
{
return
mTarget
;
}
#
endif
private
:
void
MakeSnapshotIfRequired
(
LayoutDeviceIntSize
aSize
)
;
private
:
nsIWidget
*
MOZ_NON_OWNING_REF
mWidget
;
RefPtr
<
WebRenderBridgeChild
>
mWrChild
;
bool
mHasFlushedThisChild
;
RefPtr
<
TransactionIdAllocator
>
mTransactionIdAllocator
;
TransactionId
mLatestTransactionId
;
gfx
:
:
UserData
mUserData
;
WebRenderScrollData
mScrollData
;
bool
mNeedsComposite
;
bool
mIsFirstPaint
;
bool
mDestroyed
;
FocusTarget
mFocusTarget
;
nsTArray
<
CompositionPayload
>
mPayload
;
gfxContext
*
mTarget
;
uint32_t
mPaintSequenceNumber
;
const
std
:
:
unique_ptr
<
APZTestData
>
mApzTestData
;
TimeStamp
mTransactionStart
;
nsCString
mURL
;
WebRenderCommandBuilder
mWebRenderCommandBuilder
;
RenderRootStateManager
mStateManager
;
DisplayItemCache
mDisplayItemCache
;
UniquePtr
<
wr
:
:
DisplayListBuilder
>
mDLBuilder
;
ScrollUpdatesMap
mPendingScrollUpdates
;
LayoutDeviceIntSize
mFlushWidgetSize
;
}
;
}
}
#
endif
