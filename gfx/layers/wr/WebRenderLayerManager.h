#
ifndef
GFX_WEBRENDERLAYERMANAGER_H
#
define
GFX_WEBRENDERLAYERMANAGER_H
#
include
<
unordered_set
>
#
include
<
vector
>
#
include
"
gfxPrefs
.
h
"
#
include
"
Layers
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
layers
/
APZTestData
.
h
"
#
include
"
mozilla
/
layers
/
FocusTarget
.
h
"
#
include
"
mozilla
/
layers
/
StackingContextHelper
.
h
"
#
include
"
mozilla
/
layers
/
TransactionIdAllocator
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderScrollData
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderUserData
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderTypes
.
h
"
#
include
"
nsDisplayList
.
h
"
class
nsIWidget
;
namespace
mozilla
{
struct
ActiveScrolledRoot
;
namespace
layers
{
class
CompositorBridgeChild
;
class
KnowsCompositor
;
class
PCompositorBridgeChild
;
class
WebRenderBridgeChild
;
class
WebRenderParentCommand
;
class
WebRenderLayerManager
final
:
public
LayerManager
{
typedef
nsTArray
<
RefPtr
<
Layer
>
>
LayerRefArray
;
typedef
nsTHashtable
<
nsRefPtrHashKey
<
WebRenderUserData
>
>
WebRenderUserDataRefTable
;
public
:
explicit
WebRenderLayerManager
(
nsIWidget
*
aWidget
)
;
bool
Initialize
(
PCompositorBridgeChild
*
aCBChild
wr
:
:
PipelineId
aLayersId
TextureFactoryIdentifier
*
aTextureFactoryIdentifier
)
;
virtual
void
Destroy
(
)
override
;
void
DoDestroy
(
bool
aIsSync
)
;
protected
:
virtual
~
WebRenderLayerManager
(
)
;
public
:
virtual
KnowsCompositor
*
AsKnowsCompositor
(
)
override
;
WebRenderLayerManager
*
AsWebRenderLayerManager
(
)
override
{
return
this
;
}
virtual
CompositorBridgeChild
*
GetCompositorBridgeChild
(
)
override
;
virtual
int32_t
GetMaxTextureSize
(
)
const
override
;
virtual
bool
BeginTransactionWithTarget
(
gfxContext
*
aTarget
)
override
;
virtual
bool
BeginTransaction
(
)
override
;
virtual
bool
EndEmptyTransaction
(
EndTransactionFlags
aFlags
=
END_DEFAULT
)
override
;
Maybe
<
wr
:
:
ImageKey
>
CreateImageKey
(
nsDisplayItem
*
aItem
ImageContainer
*
aContainer
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
gfx
:
:
IntSize
&
aSize
)
;
bool
PushImage
(
nsDisplayItem
*
aItem
ImageContainer
*
aContainer
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
const
LayerRect
&
aRect
)
;
already_AddRefed
<
WebRenderFallbackData
>
GenerateFallbackData
(
nsDisplayItem
*
aItem
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResourceUpdates
const
StackingContextHelper
&
aSc
nsDisplayListBuilder
*
aDisplayListBuilder
LayerRect
&
aImageRect
)
;
Maybe
<
wr
:
:
WrImageMask
>
BuildWrMaskImage
(
nsDisplayItem
*
aItem
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
nsDisplayListBuilder
*
aDisplayListBuilder
const
LayerRect
&
aBounds
)
;
bool
PushItemAsImage
(
nsDisplayItem
*
aItem
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
nsDisplayListBuilder
*
aDisplayListBuilder
)
;
void
CreateWebRenderCommandsFromDisplayList
(
nsDisplayList
*
aDisplayList
nsDisplayListBuilder
*
aDisplayListBuilder
const
StackingContextHelper
&
aSc
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
)
;
void
EndTransactionWithoutLayer
(
nsDisplayList
*
aDisplayList
nsDisplayListBuilder
*
aDisplayListBuilder
)
;
bool
IsLayersFreeTransaction
(
)
{
return
mEndTransactionWithoutLayers
;
}
virtual
void
EndTransaction
(
DrawPaintedLayerCallback
aCallback
void
*
aCallbackData
EndTransactionFlags
aFlags
=
END_DEFAULT
)
override
;
virtual
LayersBackend
GetBackendType
(
)
override
{
return
LayersBackend
:
:
LAYERS_WR
;
}
virtual
void
GetBackendName
(
nsAString
&
name
)
override
{
name
.
AssignLiteral
(
"
WebRender
"
)
;
}
virtual
const
char
*
Name
(
)
const
override
{
return
"
WebRender
"
;
}
virtual
void
SetRoot
(
Layer
*
aLayer
)
override
;
virtual
already_AddRefed
<
PaintedLayer
>
CreatePaintedLayer
(
)
override
;
virtual
already_AddRefed
<
ContainerLayer
>
CreateContainerLayer
(
)
override
;
virtual
already_AddRefed
<
ImageLayer
>
CreateImageLayer
(
)
override
;
virtual
already_AddRefed
<
CanvasLayer
>
CreateCanvasLayer
(
)
override
;
virtual
already_AddRefed
<
ReadbackLayer
>
CreateReadbackLayer
(
)
override
;
virtual
already_AddRefed
<
ColorLayer
>
CreateColorLayer
(
)
override
;
virtual
already_AddRefed
<
RefLayer
>
CreateRefLayer
(
)
override
;
virtual
already_AddRefed
<
TextLayer
>
CreateTextLayer
(
)
override
;
virtual
already_AddRefed
<
BorderLayer
>
CreateBorderLayer
(
)
override
;
virtual
already_AddRefed
<
DisplayItemLayer
>
CreateDisplayItemLayer
(
)
override
;
virtual
bool
NeedsWidgetInvalidation
(
)
override
{
return
false
;
}
virtual
void
SetLayerObserverEpoch
(
uint64_t
aLayerObserverEpoch
)
override
;
virtual
void
DidComposite
(
uint64_t
aTransactionId
const
mozilla
:
:
TimeStamp
&
aCompositeStart
const
mozilla
:
:
TimeStamp
&
aCompositeEnd
)
override
;
virtual
void
ClearCachedResources
(
Layer
*
aSubtree
=
nullptr
)
override
;
virtual
void
UpdateTextureFactoryIdentifier
(
const
TextureFactoryIdentifier
&
aNewIdentifier
uint64_t
aDeviceResetSeqNo
)
override
;
virtual
TextureFactoryIdentifier
GetTextureFactoryIdentifier
(
)
override
;
virtual
void
SetTransactionIdAllocator
(
TransactionIdAllocator
*
aAllocator
)
override
{
mTransactionIdAllocator
=
aAllocator
;
}
virtual
void
AddDidCompositeObserver
(
DidCompositeObserver
*
aObserver
)
override
;
virtual
void
RemoveDidCompositeObserver
(
DidCompositeObserver
*
aObserver
)
override
;
virtual
void
FlushRendering
(
)
override
;
virtual
void
WaitOnTransactionProcessed
(
)
override
;
virtual
void
SendInvalidRegion
(
const
nsIntRegion
&
aRegion
)
override
;
virtual
void
ScheduleComposite
(
)
override
;
virtual
void
SetNeedsComposite
(
bool
aNeedsComposite
)
override
{
mNeedsComposite
=
aNeedsComposite
;
}
virtual
bool
NeedsComposite
(
)
const
override
{
return
mNeedsComposite
;
}
virtual
void
SetIsFirstPaint
(
)
override
{
mIsFirstPaint
=
true
;
}
virtual
void
SetFocusTarget
(
const
FocusTarget
&
aFocusTarget
)
override
;
bool
AsyncPanZoomEnabled
(
)
const
override
;
DrawPaintedLayerCallback
GetPaintedLayerCallback
(
)
const
{
return
mPaintedLayerCallback
;
}
void
*
GetPaintedLayerCallbackData
(
)
const
{
return
mPaintedLayerCallbackData
;
}
void
AddImageKeyForDiscard
(
wr
:
:
ImageKey
)
;
void
DiscardImages
(
)
;
void
DiscardLocalImages
(
)
;
void
AddActiveCompositorAnimationId
(
uint64_t
aId
)
;
void
AddCompositorAnimationsIdForDiscard
(
uint64_t
aId
)
;
void
DiscardCompositorAnimations
(
)
;
WebRenderBridgeChild
*
WrBridge
(
)
const
{
return
mWrChild
;
}
virtual
void
Mutated
(
Layer
*
aLayer
)
override
;
virtual
void
MutatedSimple
(
Layer
*
aLayer
)
override
;
void
Hold
(
Layer
*
aLayer
)
;
void
SetTransactionIncomplete
(
)
{
mTransactionIncomplete
=
true
;
}
bool
IsMutatedLayer
(
Layer
*
aLayer
)
;
void
LogTestDataForCurrentPaint
(
FrameMetrics
:
:
ViewID
aScrollId
const
std
:
:
string
&
aKey
const
std
:
:
string
&
aValue
)
{
MOZ_ASSERT
(
gfxPrefs
:
:
APZTestLoggingEnabled
(
)
"
don
'
t
call
me
"
)
;
mApzTestData
.
LogTestDataForPaint
(
mPaintSequenceNumber
aScrollId
aKey
aValue
)
;
}
const
APZTestData
&
GetAPZTestData
(
)
const
{
return
mApzTestData
;
}
template
<
class
T
>
already_AddRefed
<
T
>
CreateOrRecycleWebRenderUserData
(
nsDisplayItem
*
aItem
bool
*
aOutIsRecycled
=
nullptr
)
{
MOZ_ASSERT
(
aItem
)
;
nsIFrame
*
frame
=
aItem
-
>
Frame
(
)
;
if
(
aOutIsRecycled
)
{
*
aOutIsRecycled
=
true
;
}
nsIFrame
:
:
WebRenderUserDataTable
*
userDataTable
=
frame
-
>
GetProperty
(
nsIFrame
:
:
WebRenderUserDataProperty
(
)
)
;
if
(
!
userDataTable
)
{
userDataTable
=
new
nsIFrame
:
:
WebRenderUserDataTable
(
)
;
frame
-
>
AddProperty
(
nsIFrame
:
:
WebRenderUserDataProperty
(
)
userDataTable
)
;
}
RefPtr
<
WebRenderUserData
>
&
data
=
userDataTable
-
>
GetOrInsert
(
aItem
-
>
GetPerFrameKey
(
)
)
;
if
(
!
data
|
|
(
data
-
>
GetType
(
)
!
=
T
:
:
Type
(
)
)
|
|
!
data
-
>
IsDataValid
(
this
)
)
{
if
(
data
)
{
data
-
>
RemoveFromTable
(
)
;
}
data
=
new
T
(
this
aItem
&
mWebRenderUserDatas
)
;
mWebRenderUserDatas
.
PutEntry
(
data
)
;
if
(
aOutIsRecycled
)
{
*
aOutIsRecycled
=
false
;
}
}
MOZ_ASSERT
(
data
)
;
MOZ_ASSERT
(
data
-
>
GetType
(
)
=
=
T
:
:
Type
(
)
)
;
data
-
>
SetUsed
(
true
)
;
if
(
T
:
:
Type
(
)
=
=
WebRenderUserData
:
:
UserDataType
:
:
eCanvas
)
{
mLastCanvasDatas
.
PutEntry
(
data
-
>
AsCanvasData
(
)
)
;
}
RefPtr
<
T
>
res
=
static_cast
<
T
*
>
(
data
.
get
(
)
)
;
return
res
.
forget
(
)
;
}
bool
ShouldNotifyInvalidation
(
)
const
{
return
mShouldNotifyInvalidation
;
}
void
SetNotifyInvalidation
(
bool
aShouldNotifyInvalidation
)
{
mShouldNotifyInvalidation
=
aShouldNotifyInvalidation
;
}
bool
SetPendingScrollUpdateForNextTransaction
(
FrameMetrics
:
:
ViewID
aScrollId
const
ScrollUpdateInfo
&
aUpdateInfo
)
override
;
private
:
void
MakeSnapshotIfRequired
(
LayoutDeviceIntSize
aSize
)
;
void
ClearLayer
(
Layer
*
aLayer
)
;
bool
EndTransactionInternal
(
DrawPaintedLayerCallback
aCallback
void
*
aCallbackData
EndTransactionFlags
aFlags
nsDisplayList
*
aDisplayList
=
nullptr
nsDisplayListBuilder
*
aDisplayListBuilder
=
nullptr
)
;
void
RemoveUnusedAndResetWebRenderUserData
(
)
{
for
(
auto
iter
=
mWebRenderUserDatas
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
WebRenderUserData
*
data
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
if
(
!
data
-
>
IsUsed
(
)
)
{
nsIFrame
*
frame
=
data
-
>
GetFrame
(
)
;
MOZ_ASSERT
(
frame
-
>
HasProperty
(
nsIFrame
:
:
WebRenderUserDataProperty
(
)
)
)
;
nsIFrame
:
:
WebRenderUserDataTable
*
userDataTable
=
frame
-
>
GetProperty
(
nsIFrame
:
:
WebRenderUserDataProperty
(
)
)
;
MOZ_ASSERT
(
userDataTable
-
>
Count
(
)
)
;
userDataTable
-
>
Remove
(
data
-
>
GetDisplayItemKey
(
)
)
;
if
(
!
userDataTable
-
>
Count
(
)
)
{
frame
-
>
RemoveProperty
(
nsIFrame
:
:
WebRenderUserDataProperty
(
)
)
;
}
iter
.
Remove
(
)
;
continue
;
}
data
-
>
SetUsed
(
false
)
;
}
}
private
:
nsIWidget
*
MOZ_NON_OWNING_REF
mWidget
;
nsTArray
<
wr
:
:
ImageKey
>
mImageKeysToDelete
;
nsTArray
<
wr
:
:
ImageKey
>
mImageKeysToDeleteLater
;
std
:
:
unordered_set
<
uint64_t
>
mActiveCompositorAnimationIds
;
nsTArray
<
uint64_t
>
mDiscardedCompositorAnimationsIds
;
DrawPaintedLayerCallback
mPaintedLayerCallback
;
void
*
mPaintedLayerCallbackData
;
RefPtr
<
WebRenderBridgeChild
>
mWrChild
;
RefPtr
<
TransactionIdAllocator
>
mTransactionIdAllocator
;
uint64_t
mLatestTransactionId
;
nsTArray
<
DidCompositeObserver
*
>
mDidCompositeObservers
;
LayerRefArray
mKeepAlive
;
wr
:
:
BuiltDisplayList
mBuiltDisplayList
;
nsTArray
<
WebRenderParentCommand
>
mParentCommands
;
WebRenderScrollData
mScrollData
;
std
:
:
vector
<
WebRenderLayerScrollData
>
mLayerScrollData
;
std
:
:
vector
<
const
ActiveScrolledRoot
*
>
mAsrStack
;
const
ActiveScrolledRoot
*
mLastAsr
;
public
:
typedef
std
:
:
unordered_map
<
const
DisplayItemClipChain
*
wr
:
:
WrClipId
>
ClipIdMap
;
private
:
ClipIdMap
mClipIdCache
;
void
AddMutatedLayer
(
Layer
*
aLayer
)
;
void
ClearMutatedLayers
(
)
;
LayerRefArray
mMutatedLayers
;
bool
mTransactionIncomplete
;
bool
mNeedsComposite
;
bool
mIsFirstPaint
;
FocusTarget
mFocusTarget
;
bool
mEndTransactionWithoutLayers
;
RefPtr
<
gfxContext
>
mTarget
;
uint32_t
mPaintSequenceNumber
;
APZTestData
mApzTestData
;
typedef
nsTHashtable
<
nsRefPtrHashKey
<
WebRenderCanvasData
>
>
CanvasDataSet
;
CanvasDataSet
mLastCanvasDatas
;
bool
mShouldNotifyInvalidation
;
WebRenderUserDataRefTable
mWebRenderUserDatas
;
}
;
}
}
#
endif
