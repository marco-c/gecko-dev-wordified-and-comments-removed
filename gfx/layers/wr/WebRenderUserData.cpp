#
include
"
WebRenderUserData
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
ImageClient
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
RenderRootStateManager
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderMessages
.
h
"
#
include
"
mozilla
/
layers
/
IpcResourceUpdateQueue
.
h
"
#
include
"
mozilla
/
layers
/
SharedSurfacesChild
.
h
"
#
include
"
nsDisplayListInvalidation
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
WebRenderCanvasRenderer
.
h
"
namespace
mozilla
{
namespace
layers
{
void
WebRenderBackgroundData
:
:
AddWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
)
{
aBuilder
.
PushRect
(
mBounds
mBounds
true
mColor
)
;
}
bool
WebRenderUserData
:
:
SupportsAsyncUpdate
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
)
{
return
false
;
}
RefPtr
<
WebRenderImageData
>
data
=
GetWebRenderUserData
<
WebRenderImageData
>
(
aFrame
static_cast
<
uint32_t
>
(
DisplayItemType
:
:
TYPE_VIDEO
)
)
;
if
(
data
)
{
return
data
-
>
IsAsync
(
)
;
}
return
false
;
}
bool
WebRenderUserData
:
:
ProcessInvalidateForImage
(
nsIFrame
*
aFrame
DisplayItemType
aType
ContainerProducerID
aProducerId
)
{
MOZ_ASSERT
(
aFrame
)
;
if
(
!
aFrame
-
>
HasProperty
(
WebRenderUserDataProperty
:
:
Key
(
)
)
)
{
return
false
;
}
auto
type
=
static_cast
<
uint32_t
>
(
aType
)
;
RefPtr
<
WebRenderFallbackData
>
fallback
=
GetWebRenderUserData
<
WebRenderFallbackData
>
(
aFrame
type
)
;
if
(
fallback
)
{
fallback
-
>
SetInvalid
(
true
)
;
aFrame
-
>
SchedulePaint
(
)
;
return
true
;
}
RefPtr
<
WebRenderImageData
>
image
=
GetWebRenderUserData
<
WebRenderImageData
>
(
aFrame
type
)
;
if
(
image
&
&
image
-
>
UsingSharedSurface
(
aProducerId
)
)
{
return
true
;
}
aFrame
-
>
SchedulePaint
(
)
;
return
false
;
}
WebRenderUserData
:
:
WebRenderUserData
(
RenderRootStateManager
*
aManager
uint32_t
aDisplayItemKey
nsIFrame
*
aFrame
)
:
mManager
(
aManager
)
mFrame
(
aFrame
)
mDisplayItemKey
(
aDisplayItemKey
)
mTable
(
aManager
-
>
GetWebRenderUserDataTable
(
)
)
mUsed
(
false
)
{
}
WebRenderUserData
:
:
WebRenderUserData
(
RenderRootStateManager
*
aManager
nsDisplayItem
*
aItem
)
:
mManager
(
aManager
)
mFrame
(
aItem
-
>
Frame
(
)
)
mDisplayItemKey
(
aItem
-
>
GetPerFrameKey
(
)
)
mTable
(
aManager
-
>
GetWebRenderUserDataTable
(
)
)
mUsed
(
false
)
{
}
WebRenderUserData
:
:
~
WebRenderUserData
(
)
{
}
void
WebRenderUserData
:
:
RemoveFromTable
(
)
{
mTable
-
>
RemoveEntry
(
this
)
;
}
WebRenderBridgeChild
*
WebRenderUserData
:
:
WrBridge
(
)
const
{
return
mManager
-
>
WrBridge
(
)
;
}
WebRenderImageData
:
:
WebRenderImageData
(
RenderRootStateManager
*
aManager
nsDisplayItem
*
aItem
)
:
WebRenderUserData
(
aManager
aItem
)
mOwnsKey
(
false
)
{
}
WebRenderImageData
:
:
WebRenderImageData
(
RenderRootStateManager
*
aManager
uint32_t
aDisplayItemKey
nsIFrame
*
aFrame
)
:
WebRenderUserData
(
aManager
aDisplayItemKey
aFrame
)
mOwnsKey
(
false
)
{
}
WebRenderImageData
:
:
~
WebRenderImageData
(
)
{
ClearImageKey
(
)
;
if
(
mPipelineId
)
{
mManager
-
>
RemovePipelineIdForCompositable
(
mPipelineId
.
ref
(
)
)
;
}
}
bool
WebRenderImageData
:
:
UsingSharedSurface
(
ContainerProducerID
aProducerId
)
const
{
if
(
!
mContainer
|
|
!
mKey
|
|
mOwnsKey
)
{
return
false
;
}
wr
:
:
ImageKey
key
;
nsresult
rv
=
SharedSurfacesChild
:
:
Share
(
mContainer
mManager
mManager
-
>
AsyncResourceUpdates
(
)
key
aProducerId
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
mKey
.
ref
(
)
=
=
key
;
}
void
WebRenderImageData
:
:
ClearImageKey
(
)
{
if
(
mKey
)
{
if
(
mOwnsKey
)
{
mManager
-
>
AddImageKeyForDiscard
(
mKey
.
value
(
)
)
;
if
(
mTextureOfImage
)
{
WrBridge
(
)
-
>
ReleaseTextureOfImage
(
mKey
.
value
(
)
)
;
mTextureOfImage
=
nullptr
;
}
}
mKey
.
reset
(
)
;
}
mOwnsKey
=
false
;
MOZ_ASSERT
(
!
mTextureOfImage
)
;
}
Maybe
<
wr
:
:
ImageKey
>
WebRenderImageData
:
:
UpdateImageKey
(
ImageContainer
*
aContainer
wr
:
:
IpcResourceUpdateQueue
&
aResources
bool
aFallback
)
{
MOZ_ASSERT
(
aContainer
)
;
if
(
mContainer
!
=
aContainer
)
{
mContainer
=
aContainer
;
}
wr
:
:
WrImageKey
key
;
if
(
!
aFallback
)
{
nsresult
rv
=
SharedSurfacesChild
:
:
Share
(
aContainer
mManager
aResources
key
kContainerProducerID_Invalid
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
ClearImageKey
(
)
;
mKey
=
Some
(
key
)
;
return
mKey
;
}
if
(
rv
!
=
NS_ERROR_NOT_IMPLEMENTED
)
{
ClearImageKey
(
)
;
return
Nothing
(
)
;
}
}
CreateImageClientIfNeeded
(
)
;
if
(
!
mImageClient
)
{
return
Nothing
(
)
;
}
MOZ_ASSERT
(
mImageClient
-
>
AsImageClientSingle
(
)
)
;
ImageClientSingle
*
imageClient
=
mImageClient
-
>
AsImageClientSingle
(
)
;
uint32_t
oldCounter
=
imageClient
-
>
GetLastUpdateGenerationCounter
(
)
;
bool
ret
=
imageClient
-
>
UpdateImage
(
aContainer
0
)
;
RefPtr
<
TextureClient
>
currentTexture
=
imageClient
-
>
GetForwardedTexture
(
)
;
if
(
!
ret
|
|
!
currentTexture
)
{
ClearImageKey
(
)
;
return
Nothing
(
)
;
}
if
(
!
aFallback
&
&
oldCounter
=
=
imageClient
-
>
GetLastUpdateGenerationCounter
(
)
&
&
mKey
)
{
return
mKey
;
}
bool
useUpdate
=
mKey
.
isSome
(
)
&
&
!
!
mTextureOfImage
&
&
!
!
currentTexture
&
&
mTextureOfImage
-
>
GetSize
(
)
=
=
currentTexture
-
>
GetSize
(
)
&
&
mTextureOfImage
-
>
GetFormat
(
)
=
=
currentTexture
-
>
GetFormat
(
)
;
wr
:
:
MaybeExternalImageId
extId
=
currentTexture
-
>
GetExternalImageKey
(
)
;
MOZ_RELEASE_ASSERT
(
extId
.
isSome
(
)
)
;
if
(
useUpdate
)
{
MOZ_ASSERT
(
mKey
.
isSome
(
)
)
;
MOZ_ASSERT
(
mTextureOfImage
)
;
aResources
.
PushExternalImageForTexture
(
extId
.
ref
(
)
mKey
.
ref
(
)
currentTexture
true
)
;
}
else
{
ClearImageKey
(
)
;
key
=
WrBridge
(
)
-
>
GetNextImageKey
(
)
;
aResources
.
PushExternalImageForTexture
(
extId
.
ref
(
)
key
currentTexture
false
)
;
mKey
=
Some
(
key
)
;
}
mTextureOfImage
=
currentTexture
;
mOwnsKey
=
true
;
return
mKey
;
}
already_AddRefed
<
ImageClient
>
WebRenderImageData
:
:
GetImageClient
(
)
{
RefPtr
<
ImageClient
>
imageClient
=
mImageClient
;
return
imageClient
.
forget
(
)
;
}
void
WebRenderImageData
:
:
CreateAsyncImageWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
ImageContainer
*
aContainer
const
StackingContextHelper
&
aSc
const
LayoutDeviceRect
&
aBounds
const
LayoutDeviceRect
&
aSCBounds
const
gfx
:
:
Matrix4x4
&
aSCTransform
const
gfx
:
:
MaybeIntSize
&
aScaleToSize
const
wr
:
:
ImageRendering
&
aFilter
const
wr
:
:
MixBlendMode
&
aMixBlendMode
bool
aIsBackfaceVisible
)
{
MOZ_ASSERT
(
aContainer
-
>
IsAsync
(
)
)
;
if
(
mPipelineId
.
isSome
(
)
&
&
mContainer
!
=
aContainer
)
{
WrBridge
(
)
-
>
RemovePipelineIdForCompositable
(
mPipelineId
.
ref
(
)
)
;
mPipelineId
.
reset
(
)
;
}
if
(
!
mPipelineId
)
{
mPipelineId
=
Some
(
WrBridge
(
)
-
>
GetCompositorBridgeChild
(
)
-
>
GetNextPipelineId
(
)
)
;
WrBridge
(
)
-
>
AddPipelineIdForAsyncCompositable
(
mPipelineId
.
ref
(
)
aContainer
-
>
GetAsyncContainerHandle
(
)
)
;
mContainer
=
aContainer
;
}
MOZ_ASSERT
(
!
mImageClient
)
;
wr
:
:
LayoutRect
r
=
wr
:
:
ToRoundedLayoutRect
(
aBounds
)
;
aBuilder
.
PushIFrame
(
r
aIsBackfaceVisible
mPipelineId
.
ref
(
)
false
)
;
WrBridge
(
)
-
>
AddWebRenderParentCommand
(
OpUpdateAsyncImagePipeline
(
mPipelineId
.
value
(
)
aSCBounds
aSCTransform
aScaleToSize
aFilter
aMixBlendMode
)
)
;
}
void
WebRenderImageData
:
:
CreateImageClientIfNeeded
(
)
{
if
(
!
mImageClient
)
{
mImageClient
=
ImageClient
:
:
CreateImageClient
(
CompositableType
:
:
IMAGE
WrBridge
(
)
TextureFlags
:
:
DEFAULT
)
;
if
(
!
mImageClient
)
{
return
;
}
mImageClient
-
>
Connect
(
)
;
}
}
WebRenderFallbackData
:
:
WebRenderFallbackData
(
RenderRootStateManager
*
aManager
nsDisplayItem
*
aItem
)
:
WebRenderUserData
(
aManager
aItem
)
mInvalid
(
false
)
{
}
WebRenderFallbackData
:
:
~
WebRenderFallbackData
(
)
{
ClearImageKey
(
)
;
}
void
WebRenderFallbackData
:
:
SetBlobImageKey
(
const
wr
:
:
BlobImageKey
&
aKey
)
{
ClearImageKey
(
)
;
mBlobKey
=
Some
(
aKey
)
;
}
Maybe
<
wr
:
:
ImageKey
>
WebRenderFallbackData
:
:
GetImageKey
(
)
{
if
(
mBlobKey
)
{
return
Some
(
wr
:
:
AsImageKey
(
mBlobKey
.
value
(
)
)
)
;
}
if
(
mImageData
)
{
return
mImageData
-
>
GetImageKey
(
)
;
}
return
Nothing
(
)
;
}
void
WebRenderFallbackData
:
:
ClearImageKey
(
)
{
if
(
mImageData
)
{
mImageData
-
>
ClearImageKey
(
)
;
mImageData
=
nullptr
;
}
if
(
mBlobKey
)
{
mManager
-
>
AddBlobImageKeyForDiscard
(
mBlobKey
.
value
(
)
)
;
mBlobKey
.
reset
(
)
;
}
}
WebRenderImageData
*
WebRenderFallbackData
:
:
PaintIntoImage
(
)
{
if
(
mBlobKey
)
{
mManager
-
>
AddBlobImageKeyForDiscard
(
mBlobKey
.
value
(
)
)
;
mBlobKey
.
reset
(
)
;
}
if
(
mImageData
)
{
return
mImageData
.
get
(
)
;
}
mImageData
=
MakeAndAddRef
<
WebRenderImageData
>
(
mManager
.
get
(
)
mDisplayItemKey
mFrame
)
;
return
mImageData
.
get
(
)
;
}
WebRenderAnimationData
:
:
WebRenderAnimationData
(
RenderRootStateManager
*
aManager
nsDisplayItem
*
aItem
)
:
WebRenderUserData
(
aManager
aItem
)
{
}
WebRenderAnimationData
:
:
~
WebRenderAnimationData
(
)
{
uint64_t
animationId
=
mAnimationInfo
.
GetCompositorAnimationsId
(
)
;
if
(
animationId
)
{
mManager
-
>
AddCompositorAnimationsIdForDiscard
(
animationId
)
;
}
}
WebRenderCanvasData
:
:
WebRenderCanvasData
(
RenderRootStateManager
*
aManager
nsDisplayItem
*
aItem
)
:
WebRenderUserData
(
aManager
aItem
)
{
}
WebRenderCanvasData
:
:
~
WebRenderCanvasData
(
)
{
if
(
mCanvasRenderer
)
{
mCanvasRenderer
-
>
ClearCachedResources
(
)
;
}
}
void
WebRenderCanvasData
:
:
ClearCanvasRenderer
(
)
{
mCanvasRenderer
=
nullptr
;
}
WebRenderCanvasRendererAsync
*
WebRenderCanvasData
:
:
GetCanvasRenderer
(
)
{
return
mCanvasRenderer
.
get
(
)
;
}
WebRenderCanvasRendererAsync
*
WebRenderCanvasData
:
:
CreateCanvasRenderer
(
)
{
mCanvasRenderer
=
MakeUnique
<
WebRenderCanvasRendererAsync
>
(
mManager
)
;
return
mCanvasRenderer
.
get
(
)
;
}
void
DestroyWebRenderUserDataTable
(
WebRenderUserDataTable
*
aTable
)
{
for
(
auto
iter
=
aTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
UserData
(
)
-
>
RemoveFromTable
(
)
;
}
delete
aTable
;
}
}
}
