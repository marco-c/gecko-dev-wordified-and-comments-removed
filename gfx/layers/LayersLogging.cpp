#
include
"
LayersLogging
.
h
"
#
include
<
stdint
.
h
>
#
include
"
FrameMetrics
.
h
"
#
include
"
ImageTypes
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRectAbsolute
.
h
"
#
include
"
base
/
basictypes
.
h
"
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
namespace
layers
{
void
AppendToString
(
std
:
:
stringstream
&
aStream
gfx
:
:
SurfaceType
aType
const
char
*
pfx
const
char
*
sfx
)
{
aStream
<
<
pfx
;
switch
(
aType
)
{
case
SurfaceType
:
:
DATA
:
aStream
<
<
"
SurfaceType
:
:
DATA
"
;
break
;
case
SurfaceType
:
:
D2D1_BITMAP
:
aStream
<
<
"
SurfaceType
:
:
D2D1_BITMAP
"
;
break
;
case
SurfaceType
:
:
D2D1_DRAWTARGET
:
aStream
<
<
"
SurfaceType
:
:
D2D1_DRAWTARGET
"
;
break
;
case
SurfaceType
:
:
CAIRO
:
aStream
<
<
"
SurfaceType
:
:
CAIRO
"
;
break
;
case
SurfaceType
:
:
CAIRO_IMAGE
:
aStream
<
<
"
SurfaceType
:
:
CAIRO_IMAGE
"
;
break
;
case
SurfaceType
:
:
COREGRAPHICS_IMAGE
:
aStream
<
<
"
SurfaceType
:
:
COREGRAPHICS_IMAGE
"
;
break
;
case
SurfaceType
:
:
COREGRAPHICS_CGCONTEXT
:
aStream
<
<
"
SurfaceType
:
:
COREGRAPHICS_CGCONTEXT
"
;
break
;
case
SurfaceType
:
:
SKIA
:
aStream
<
<
"
SurfaceType
:
:
SKIA
"
;
break
;
case
SurfaceType
:
:
DUAL_DT
:
aStream
<
<
"
SurfaceType
:
:
DUAL_DT
"
;
break
;
case
SurfaceType
:
:
D2D1_1_IMAGE
:
aStream
<
<
"
SurfaceType
:
:
D2D1_1_IMAGE
"
;
break
;
case
SurfaceType
:
:
RECORDING
:
aStream
<
<
"
SurfaceType
:
:
RECORDING
"
;
break
;
case
SurfaceType
:
:
WRAP_AND_RECORD
:
aStream
<
<
"
SurfaceType
:
:
WRAP_AND_RECORD
"
;
break
;
case
SurfaceType
:
:
TILED
:
aStream
<
<
"
SurfaceType
:
:
TILED
"
;
break
;
case
SurfaceType
:
:
DATA_SHARED
:
aStream
<
<
"
SurfaceType
:
:
DATA_SHARED
"
;
break
;
case
SurfaceType
:
:
DATA_RECYCLING_SHARED
:
aStream
<
<
"
SurfaceType
:
:
DATA_RECYCLING_SHARED
"
;
break
;
case
SurfaceType
:
:
DATA_ALIGNED
:
aStream
<
<
"
SurfaceType
:
:
DATA_ALIGNED
"
;
break
;
default
:
NS_ERROR
(
"
unknown
surface
type
"
)
;
aStream
<
<
"
?
?
?
"
;
}
aStream
<
<
sfx
;
}
void
AppendToString
(
std
:
:
stringstream
&
aStream
ImageFormat
format
const
char
*
pfx
const
char
*
sfx
)
{
aStream
<
<
pfx
;
switch
(
format
)
{
case
ImageFormat
:
:
PLANAR_YCBCR
:
aStream
<
<
"
ImageFormat
:
:
PLANAR_YCBCR
"
;
break
;
case
ImageFormat
:
:
SHARED_RGB
:
aStream
<
<
"
ImageFormat
:
:
SHARED_RGB
"
;
break
;
case
ImageFormat
:
:
CAIRO_SURFACE
:
aStream
<
<
"
ImageFormat
:
:
CAIRO_SURFACE
"
;
break
;
case
ImageFormat
:
:
MAC_IOSURFACE
:
aStream
<
<
"
ImageFormat
:
:
MAC_IOSURFACE
"
;
break
;
case
ImageFormat
:
:
SURFACE_TEXTURE
:
aStream
<
<
"
ImageFormat
:
:
SURFACE_TEXTURE
"
;
break
;
case
ImageFormat
:
:
D3D9_RGB32_TEXTURE
:
aStream
<
<
"
ImageFormat
:
:
D3D9_RBG32_TEXTURE
"
;
break
;
case
ImageFormat
:
:
OVERLAY_IMAGE
:
aStream
<
<
"
ImageFormat
:
:
OVERLAY_IMAGE
"
;
break
;
case
ImageFormat
:
:
D3D11_SHARE_HANDLE_TEXTURE
:
aStream
<
<
"
ImageFormat
:
:
D3D11_SHARE_HANDLE_TEXTURE
"
;
break
;
default
:
NS_ERROR
(
"
unknown
image
format
"
)
;
aStream
<
<
"
?
?
?
"
;
}
aStream
<
<
sfx
;
}
}
}
void
print_stderr
(
std
:
:
stringstream
&
aStr
)
{
#
if
defined
(
ANDROID
)
std
:
:
string
line
;
while
(
std
:
:
getline
(
aStr
line
)
)
{
printf_stderr
(
"
%
s
\
n
"
line
.
c_str
(
)
)
;
}
#
else
printf_stderr
(
"
%
s
"
aStr
.
str
(
)
.
c_str
(
)
)
;
#
endif
}
void
fprint_stderr
(
FILE
*
aFile
std
:
:
stringstream
&
aStr
)
{
if
(
aFile
=
=
stderr
)
{
print_stderr
(
aStr
)
;
}
else
{
fprintf_stderr
(
aFile
"
%
s
"
aStr
.
str
(
)
.
c_str
(
)
)
;
}
}
