#
ifndef
mozilla_layers_AnimationStorageData_h
#
define
mozilla_layers_AnimationStorageData_h
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
#
include
"
mozilla
/
ComputedTimingFunction
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
TimingParams
.
h
"
#
include
"
X11UndefineNone
.
h
"
namespace
mozilla
{
namespace
dom
{
enum
class
CompositeOperation
:
uint8_t
;
enum
class
IterationCompositeOperation
:
uint8_t
;
}
;
namespace
layers
{
struct
PropertyAnimation
{
struct
SegmentData
{
RefPtr
<
RawServoAnimationValue
>
mStartValue
;
RefPtr
<
RawServoAnimationValue
>
mEndValue
;
Maybe
<
mozilla
:
:
ComputedTimingFunction
>
mFunction
;
float
mStartPortion
;
float
mEndPortion
;
dom
:
:
CompositeOperation
mStartComposite
;
dom
:
:
CompositeOperation
mEndComposite
;
}
;
nsTArray
<
SegmentData
>
mSegments
;
TimingParams
mTiming
;
dom
:
:
Nullable
<
double
>
mProgressOnLastCompose
;
uint64_t
mCurrentIterationOnLastCompose
=
0
;
uint32_t
mSegmentIndexOnLastCompose
=
0
;
dom
:
:
Nullable
<
double
>
mPortionInSegmentOnLastCompose
;
TimeStamp
mOriginTime
;
Maybe
<
TimeDuration
>
mStartTime
;
TimeDuration
mHoldTime
;
float
mPlaybackRate
;
dom
:
:
IterationCompositeOperation
mIterationComposite
;
bool
mIsNotPlaying
;
void
ResetLastCompositionValues
(
)
{
mCurrentIterationOnLastCompose
=
0
;
mSegmentIndexOnLastCompose
=
0
;
mProgressOnLastCompose
.
SetNull
(
)
;
mPortionInSegmentOnLastCompose
.
SetNull
(
)
;
}
}
;
struct
PropertyAnimationGroup
{
nsCSSPropertyID
mProperty
;
nsTArray
<
PropertyAnimation
>
mAnimations
;
RefPtr
<
RawServoAnimationValue
>
mBaseStyle
;
bool
IsEmpty
(
)
const
{
return
mAnimations
.
IsEmpty
(
)
;
}
void
Clear
(
)
{
mAnimations
.
Clear
(
)
;
mBaseStyle
=
nullptr
;
}
void
ResetLastCompositionValues
(
)
{
for
(
PropertyAnimation
&
animation
:
mAnimations
)
{
animation
.
ResetLastCompositionValues
(
)
;
}
}
}
;
struct
AnimationStorageData
{
nsTArray
<
PropertyAnimationGroup
>
mAnimation
;
Maybe
<
TransformData
>
mTransformData
;
RefPtr
<
gfx
:
:
Path
>
mCachedMotionPath
;
LayersId
mLayersId
;
AnimationStorageData
(
)
=
default
;
AnimationStorageData
(
AnimationStorageData
&
&
aOther
)
=
default
;
AnimationStorageData
&
operator
=
(
AnimationStorageData
&
&
aOther
)
=
default
;
AnimationStorageData
(
const
AnimationStorageData
&
aOther
)
=
delete
;
AnimationStorageData
&
operator
=
(
const
AnimationStorageData
&
aOther
)
=
delete
;
bool
IsEmpty
(
)
const
{
return
mAnimation
.
IsEmpty
(
)
;
}
void
Clear
(
)
{
mAnimation
.
Clear
(
)
;
mTransformData
.
reset
(
)
;
mCachedMotionPath
=
nullptr
;
}
}
;
}
}
#
endif
