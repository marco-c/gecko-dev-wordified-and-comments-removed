#
ifndef
GFX_D3DSURFACEIMAGE_H
#
define
GFX_D3DSURFACEIMAGE_H
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
d3d9
.
h
"
#
include
"
mozilla
/
layers
/
TextureClientRecycleAllocator
.
h
"
namespace
mozilla
{
namespace
layers
{
class
TextureClient
;
class
D3D9RecycleAllocator
:
public
TextureClientRecycleAllocator
{
public
:
D3D9RecycleAllocator
(
KnowsCompositor
*
aAllocator
IDirect3DDevice9
*
aDevice
)
:
TextureClientRecycleAllocator
(
aAllocator
)
mDevice
(
aDevice
)
{
}
already_AddRefed
<
TextureClient
>
CreateOrRecycleClient
(
gfx
:
:
SurfaceFormat
aFormat
const
gfx
:
:
IntSize
&
aSize
)
;
protected
:
already_AddRefed
<
TextureClient
>
Allocate
(
gfx
:
:
SurfaceFormat
aFormat
gfx
:
:
IntSize
aSize
BackendSelector
aSelector
TextureFlags
aTextureFlags
TextureAllocationFlags
aAllocFlags
)
override
;
RefPtr
<
IDirect3DDevice9
>
mDevice
;
}
;
class
DXGID3D9TextureData
:
public
TextureData
{
public
:
static
DXGID3D9TextureData
*
Create
(
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
TextureFlags
aFlags
IDirect3DDevice9
*
aDevice
)
;
virtual
~
DXGID3D9TextureData
(
)
;
void
FillInfo
(
TextureData
:
:
Info
&
aInfo
)
const
override
;
bool
Lock
(
OpenMode
)
override
{
return
true
;
}
void
Unlock
(
)
override
{
}
bool
Serialize
(
SurfaceDescriptor
&
aOutDescriptor
)
override
;
void
Deallocate
(
LayersIPCChannel
*
aAllocator
)
override
{
}
IDirect3DDevice9
*
GetD3D9Device
(
)
{
return
mDevice
;
}
IDirect3DTexture9
*
GetD3D9Texture
(
)
{
return
mTexture
;
}
HANDLE
GetShareHandle
(
)
const
{
return
mHandle
;
}
already_AddRefed
<
IDirect3DSurface9
>
GetD3D9Surface
(
)
const
;
const
D3DSURFACE_DESC
&
GetDesc
(
)
const
{
return
mDesc
;
}
gfx
:
:
IntSize
GetSize
(
)
const
{
return
gfx
:
:
IntSize
(
mDesc
.
Width
mDesc
.
Height
)
;
}
protected
:
DXGID3D9TextureData
(
gfx
:
:
SurfaceFormat
aFormat
IDirect3DTexture9
*
aTexture
HANDLE
aHandle
IDirect3DDevice9
*
aDevice
)
;
RefPtr
<
IDirect3DDevice9
>
mDevice
;
RefPtr
<
IDirect3DTexture9
>
mTexture
;
gfx
:
:
SurfaceFormat
mFormat
;
HANDLE
mHandle
;
D3DSURFACE_DESC
mDesc
;
}
;
class
D3D9SurfaceImage
:
public
Image
{
public
:
D3D9SurfaceImage
(
)
;
virtual
~
D3D9SurfaceImage
(
)
;
HRESULT
AllocateAndCopy
(
D3D9RecycleAllocator
*
aAllocator
IDirect3DSurface9
*
aSurface
const
gfx
:
:
IntRect
&
aRegion
)
;
const
D3DSURFACE_DESC
&
GetDesc
(
)
const
;
gfx
:
:
IntSize
GetSize
(
)
const
override
;
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetAsSourceSurface
(
)
override
;
TextureClient
*
GetTextureClient
(
KnowsCompositor
*
aKnowsCompositor
)
override
;
already_AddRefed
<
IDirect3DSurface9
>
GetD3D9Surface
(
)
const
;
HANDLE
GetShareHandle
(
)
const
;
bool
IsValid
(
)
const
override
{
return
mValid
;
}
void
Invalidate
(
)
{
mValid
=
false
;
}
private
:
gfx
:
:
IntSize
mSize
;
RefPtr
<
TextureClient
>
mTextureClient
;
RefPtr
<
IDirect3DTexture9
>
mTexture
;
HANDLE
mShareHandle
;
D3DSURFACE_DESC
mDesc
;
bool
mValid
;
}
;
}
}
#
endif
