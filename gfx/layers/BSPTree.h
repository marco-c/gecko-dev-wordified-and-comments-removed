#
ifndef
MOZILLA_LAYERS_BSPTREE_H
#
define
MOZILLA_LAYERS_BSPTREE_H
#
include
"
mozilla
/
gfx
/
Polygon
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsTArray
.
h
"
#
include
<
deque
>
namespace
mozilla
{
namespace
layers
{
class
Layer
;
struct
LayerPolygon
{
explicit
LayerPolygon
(
Layer
*
aLayer
)
:
layer
(
aLayer
)
{
}
LayerPolygon
(
Layer
*
aLayer
gfx
:
:
Polygon3D
&
&
aGeometry
)
:
layer
(
aLayer
)
geometry
(
Some
(
aGeometry
)
)
{
}
LayerPolygon
(
Layer
*
aLayer
nsTArray
<
gfx
:
:
Point3D
>
&
&
aPoints
const
gfx
:
:
Point3D
&
aNormal
)
:
layer
(
aLayer
)
geometry
(
Some
(
gfx
:
:
Polygon3D
(
Move
(
aPoints
)
aNormal
)
)
)
{
}
Layer
*
layer
;
Maybe
<
gfx
:
:
Polygon3D
>
geometry
;
}
;
LayerPolygon
PopFront
(
std
:
:
deque
<
LayerPolygon
>
&
aLayers
)
;
struct
BSPTreeNode
{
explicit
BSPTreeNode
(
LayerPolygon
&
&
layer
)
{
layers
.
push_back
(
Move
(
layer
)
)
;
}
const
gfx
:
:
Polygon3D
&
First
(
)
const
{
MOZ_ASSERT
(
layers
[
0
]
.
geometry
)
;
return
*
layers
[
0
]
.
geometry
;
}
UniquePtr
<
BSPTreeNode
>
front
;
UniquePtr
<
BSPTreeNode
>
back
;
std
:
:
deque
<
LayerPolygon
>
layers
;
}
;
class
BSPTree
{
public
:
explicit
BSPTree
(
std
:
:
deque
<
LayerPolygon
>
&
aLayers
)
{
MOZ_ASSERT
(
!
aLayers
.
empty
(
)
)
;
mRoot
.
reset
(
new
BSPTreeNode
(
PopFront
(
aLayers
)
)
)
;
BuildTree
(
mRoot
aLayers
)
;
}
const
UniquePtr
<
BSPTreeNode
>
&
GetRoot
(
)
const
{
return
mRoot
;
}
nsTArray
<
LayerPolygon
>
GetDrawOrder
(
)
const
{
nsTArray
<
LayerPolygon
>
layers
;
BuildDrawOrder
(
mRoot
layers
)
;
return
layers
;
}
private
:
UniquePtr
<
BSPTreeNode
>
mRoot
;
void
BuildDrawOrder
(
const
UniquePtr
<
BSPTreeNode
>
&
aNode
nsTArray
<
LayerPolygon
>
&
aLayers
)
const
;
void
BuildTree
(
UniquePtr
<
BSPTreeNode
>
&
aRoot
std
:
:
deque
<
LayerPolygon
>
&
aLayers
)
;
}
;
}
}
#
endif
