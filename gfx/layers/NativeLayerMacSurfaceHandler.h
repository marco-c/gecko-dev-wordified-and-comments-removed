#
ifndef
mozilla_layers_NativeLayerMacSurfaceHandler_h
#
define
mozilla_layers_NativeLayerMacSurfaceHandler_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
gfx
/
MacIOSurface
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
CFTypeRefPtr
.
h
"
#
include
"
GLTypes
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRegion
.
h
"
namespace
mozilla
{
namespace
gl
{
class
GLContext
;
}
namespace
wr
{
class
RenderTextureHost
;
class
RenderMacIOSurfaceTextureHost
;
}
namespace
layers
{
class
SurfacePoolHandleCA
;
struct
SurfaceWithInvalidRegion
{
CFTypeRefPtr
<
IOSurfaceRef
>
mSurface
;
gfx
:
:
IntRegion
mInvalidRegion
;
}
;
struct
SurfaceWithInvalidRegionAndCheckCount
{
SurfaceWithInvalidRegion
mEntry
;
uint32_t
mCheckCount
;
}
;
class
NativeLayerMacSurfaceHandler
{
public
:
NativeLayerMacSurfaceHandler
(
const
gfx
:
:
IntSize
&
aSize
SurfacePoolHandleCA
*
aSurfacePoolHandle
)
;
~
NativeLayerMacSurfaceHandler
(
)
;
gfx
:
:
IntSize
Size
(
)
{
return
mSize
;
}
gfx
:
:
IntRect
DisplayRect
(
)
{
return
mDisplayRect
;
}
void
SetSurfaceIsFlipped
(
bool
aIsFlipped
)
{
mSurfaceIsFlipped
=
aIsFlipped
;
}
bool
SurfaceIsFlipped
(
)
{
return
mSurfaceIsFlipped
;
}
bool
NextSurface
(
)
;
void
InvalidateRegionThroughoutSwapchain
(
const
gfx
:
:
IntRegion
&
aRegion
)
;
template
<
typename
F
>
void
HandlePartialUpdate
(
const
gfx
:
:
IntRect
&
aDisplayRect
const
gfx
:
:
IntRegion
&
aUpdateRegion
F
&
&
aCopyFn
)
;
Maybe
<
SurfaceWithInvalidRegion
>
GetUnusedSurfaceAndCleanUp
(
)
;
RefPtr
<
gfx
:
:
DrawTarget
>
NextSurfaceAsDrawTarget
(
const
gfx
:
:
IntRect
&
aDisplayRect
const
gfx
:
:
IntRegion
&
aUpdateRegion
gfx
:
:
BackendType
aBackendType
)
;
Maybe
<
GLuint
>
NextSurfaceAsFramebuffer
(
const
gfx
:
:
IntRect
&
aDisplayRect
const
gfx
:
:
IntRegion
&
aUpdateRegion
bool
aNeedsDepth
)
;
bool
NotifySurfaceReady
(
)
;
void
DiscardBackbuffers
(
)
;
Maybe
<
SurfaceWithInvalidRegion
>
FrontSurface
(
)
{
return
mFrontSurface
;
}
Maybe
<
SurfaceWithInvalidRegion
>
InProgressSurface
(
)
{
return
mInProgressSurface
;
}
std
:
:
vector
<
SurfaceWithInvalidRegionAndCheckCount
>
Surfaces
(
)
{
return
mSurfaces
;
}
protected
:
friend
class
NativeLayerCA
;
gfx
:
:
IntSize
mSize
;
gfx
:
:
IntRect
mDisplayRect
;
bool
mSurfaceIsFlipped
=
false
;
#
ifdef
NIGHTLY_BUILD
bool
mHasEverAttachExternalImage
=
false
;
bool
mHasEverNotifySurfaceReady
=
false
;
#
endif
Maybe
<
SurfaceWithInvalidRegion
>
mInProgressSurface
;
Maybe
<
gfx
:
:
IntRegion
>
mInProgressUpdateRegion
;
Maybe
<
gfx
:
:
IntRect
>
mInProgressDisplayRect
;
Maybe
<
SurfaceWithInvalidRegion
>
mFrontSurface
;
std
:
:
vector
<
SurfaceWithInvalidRegionAndCheckCount
>
mSurfaces
;
RefPtr
<
MacIOSurface
>
mInProgressLockedIOSurface
;
RefPtr
<
SurfacePoolHandleCA
>
mSurfacePoolHandle
;
}
;
}
}
#
endif
