#
ifndef
MOZILLA_GFX_RemoteTextureMap_H
#
define
MOZILLA_GFX_RemoteTextureMap_H
#
include
<
deque
>
#
include
<
functional
>
#
include
<
list
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
queue
>
#
include
<
unordered_set
>
#
include
<
utility
>
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
ipc
/
Shmem
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
ThreadSafeWeakPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderTypes
.
h
"
class
nsISerialEventTarget
;
namespace
mozilla
{
namespace
ipc
{
class
IProtocol
;
}
namespace
gl
{
class
SharedSurface
;
}
namespace
webgpu
{
class
ExternalTexture
;
}
namespace
layers
{
class
CompositableHost
;
class
RemoteTextureHostWrapper
;
class
TextureData
;
class
TextureHost
;
struct
RemoteTextureInfo
{
RemoteTextureInfo
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
)
:
mTextureId
(
aTextureId
)
mOwnerId
(
aOwnerId
)
mForPid
(
aForPid
)
{
}
const
RemoteTextureId
mTextureId
;
const
RemoteTextureOwnerId
mOwnerId
;
const
base
:
:
ProcessId
mForPid
;
}
;
struct
RemoteTextureInfoList
{
std
:
:
queue
<
RemoteTextureInfo
>
mList
;
}
;
class
SharedResourceWrapper
{
public
:
enum
class
Tag
{
SharedSurface
ExternalTexture
}
;
const
Tag
mTag
;
static
UniquePtr
<
SharedResourceWrapper
>
SharedSurface
(
const
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
&
aSharedSurface
)
{
return
MakeUnique
<
SharedResourceWrapper
>
(
Tag
:
:
SharedSurface
aSharedSurface
)
;
}
static
UniquePtr
<
SharedResourceWrapper
>
ExternalTexture
(
const
std
:
:
shared_ptr
<
webgpu
:
:
ExternalTexture
>
&
aExternalTexture
)
{
return
MakeUnique
<
SharedResourceWrapper
>
(
Tag
:
:
ExternalTexture
aExternalTexture
)
;
}
SharedResourceWrapper
(
const
Tag
aTag
const
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
&
aSharedSurface
)
:
mTag
(
aTag
)
mSharedSurface
(
aSharedSurface
)
{
MOZ_ASSERT
(
mTag
=
=
Tag
:
:
SharedSurface
)
;
}
SharedResourceWrapper
(
const
Tag
aTag
const
std
:
:
shared_ptr
<
webgpu
:
:
ExternalTexture
>
&
aExternalTexture
)
:
mTag
(
aTag
)
mExternalTexture
(
aExternalTexture
)
{
MOZ_ASSERT
(
mTag
=
=
Tag
:
:
ExternalTexture
)
;
}
const
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
mSharedSurface
;
const
std
:
:
shared_ptr
<
webgpu
:
:
ExternalTexture
>
mExternalTexture
;
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
SharedSurface
(
)
{
if
(
mTag
=
=
Tag
:
:
SharedSurface
)
{
return
mSharedSurface
;
}
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
to
be
called
"
)
;
return
nullptr
;
}
std
:
:
shared_ptr
<
webgpu
:
:
ExternalTexture
>
ExternalTexture
(
)
{
if
(
mTag
=
=
Tag
:
:
ExternalTexture
)
{
return
mExternalTexture
;
}
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
to
be
called
"
)
;
return
nullptr
;
}
}
;
class
RemoteTextureRecycleBin
final
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
RemoteTextureRecycleBin
)
explicit
RemoteTextureRecycleBin
(
bool
aIsShared
)
;
private
:
friend
class
RemoteTextureMap
;
~
RemoteTextureRecycleBin
(
)
;
struct
RecycledTextureHolder
{
gfx
:
:
IntSize
mSize
;
gfx
:
:
SurfaceFormat
mFormat
=
gfx
:
:
SurfaceFormat
:
:
UNKNOWN
;
SurfaceDescriptor
:
:
Type
mType
=
SurfaceDescriptor
:
:
Tnull_t
;
UniquePtr
<
TextureData
>
mTextureData
;
UniquePtr
<
SharedResourceWrapper
>
mResourceWrapper
;
}
;
bool
mIsShared
=
false
;
std
:
:
list
<
RecycledTextureHolder
>
mRecycledTextures
;
}
;
class
RemoteTextureTxnScheduler
final
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
RemoteTextureTxnScheduler
)
static
already_AddRefed
<
RemoteTextureTxnScheduler
>
Create
(
mozilla
:
:
ipc
:
:
IProtocol
*
aProtocol
)
;
void
NotifyTxn
(
RemoteTextureTxnId
aTxnId
)
;
private
:
friend
class
RemoteTextureMap
;
RemoteTextureTxnScheduler
(
base
:
:
ProcessId
aForPid
RemoteTextureTxnType
aType
)
:
mForPid
(
aForPid
)
mType
(
aType
)
{
}
~
RemoteTextureTxnScheduler
(
)
;
bool
WaitForTxn
(
const
MonitorAutoLock
&
aProofOfLock
RemoteTextureOwnerId
aOwnerId
RemoteTextureTxnId
aTxnId
)
;
struct
Wait
{
RemoteTextureOwnerId
mOwnerId
;
RemoteTextureTxnId
mTxnId
;
friend
bool
operator
<
(
RemoteTextureTxnId
aTxnId
const
Wait
&
aWait
)
{
return
aTxnId
<
aWait
.
mTxnId
;
}
}
;
base
:
:
ProcessId
mForPid
=
base
:
:
kInvalidProcessId
;
RemoteTextureTxnType
mType
=
0
;
RemoteTextureTxnId
mLastTxnId
=
0
;
std
:
:
deque
<
Wait
>
mWaits
;
}
;
typedef
std
:
:
unordered_set
<
RemoteTextureOwnerId
RemoteTextureOwnerId
:
:
HashFn
>
RemoteTextureOwnerIdSet
;
class
RemoteTextureOwnerClient
final
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
RemoteTextureOwnerClient
)
explicit
RemoteTextureOwnerClient
(
const
base
:
:
ProcessId
aForPid
)
;
bool
IsRegistered
(
const
RemoteTextureOwnerId
aOwnerId
)
;
void
RegisterTextureOwner
(
const
RemoteTextureOwnerId
aOwnerId
bool
aSharedRecycling
=
false
)
;
void
UnregisterTextureOwner
(
const
RemoteTextureOwnerId
aOwnerId
)
;
void
UnregisterAllTextureOwners
(
)
;
void
ClearRecycledTextures
(
)
;
void
NotifyContextLost
(
const
RemoteTextureOwnerIdSet
*
aOwnerIds
=
nullptr
)
;
void
NotifyContextRestored
(
const
RemoteTextureOwnerIdSet
*
aOwnerIds
=
nullptr
)
;
void
PushTexture
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
UniquePtr
<
TextureData
>
&
&
aTextureData
)
;
void
PushTexture
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
const
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
&
aSharedSurface
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
const
SurfaceDescriptor
&
aDesc
)
;
void
PushTexture
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
const
std
:
:
shared_ptr
<
webgpu
:
:
ExternalTexture
>
&
aExternalTexture
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
const
SurfaceDescriptor
&
aDesc
)
;
void
PushDummyTexture
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
)
;
void
GetLatestBufferSnapshot
(
const
RemoteTextureOwnerId
aOwnerId
const
mozilla
:
:
ipc
:
:
Shmem
&
aDestShmem
const
gfx
:
:
IntSize
&
aSize
)
;
UniquePtr
<
TextureData
>
GetRecycledTextureData
(
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
TextureType
aTextureType
RemoteTextureOwnerId
aOwnerId
=
RemoteTextureOwnerId
(
)
)
;
UniquePtr
<
TextureData
>
CreateOrRecycleBufferTextureData
(
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
RemoteTextureOwnerId
aOwnerId
=
RemoteTextureOwnerId
(
)
)
;
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
GetRecycledSharedSurface
(
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
SurfaceDescriptor
:
:
Type
aType
RemoteTextureOwnerId
aOwnerId
=
RemoteTextureOwnerId
(
)
)
;
std
:
:
shared_ptr
<
webgpu
:
:
ExternalTexture
>
GetRecycledExternalTexture
(
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
SurfaceDescriptor
:
:
Type
aType
RemoteTextureOwnerId
aOwnerId
=
RemoteTextureOwnerId
(
)
)
;
const
base
:
:
ProcessId
mForPid
;
protected
:
~
RemoteTextureOwnerClient
(
)
;
RemoteTextureOwnerIdSet
mOwnerIds
;
RefPtr
<
RemoteTextureRecycleBin
>
mSharedRecycleBin
;
}
;
class
RemoteTextureMap
{
public
:
static
void
Init
(
)
;
static
void
Shutdown
(
)
;
static
RemoteTextureMap
*
Get
(
)
{
return
sInstance
;
}
RemoteTextureMap
(
)
;
~
RemoteTextureMap
(
)
;
void
PushTexture
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
UniquePtr
<
TextureData
>
&
&
aTextureData
RefPtr
<
TextureHost
>
&
aTextureHost
UniquePtr
<
SharedResourceWrapper
>
&
&
aResourceWrapper
)
;
bool
RemoveTexture
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
)
;
void
GetLatestBufferSnapshot
(
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
const
mozilla
:
:
ipc
:
:
Shmem
&
aDestShmem
const
gfx
:
:
IntSize
&
aSize
)
;
void
RegisterTextureOwner
(
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
const
RefPtr
<
RemoteTextureRecycleBin
>
&
aRecycleBin
=
nullptr
)
;
void
UnregisterTextureOwner
(
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
)
;
void
UnregisterTextureOwners
(
const
RemoteTextureOwnerIdSet
&
aOwnerIds
const
base
:
:
ProcessId
aForPid
)
;
void
ClearRecycledTextures
(
const
RemoteTextureOwnerIdSet
&
aOwnerIds
const
base
:
:
ProcessId
aForPid
const
RefPtr
<
RemoteTextureRecycleBin
>
&
aRecycleBin
=
nullptr
)
;
void
NotifyContextLost
(
const
RemoteTextureOwnerIdSet
&
aOwnerIds
const
base
:
:
ProcessId
aForPid
)
;
void
NotifyContextRestored
(
const
RemoteTextureOwnerIdSet
&
aOwnerIds
const
base
:
:
ProcessId
aForPid
)
;
bool
GetRemoteTexture
(
RemoteTextureHostWrapper
*
aTextureHostWrapper
std
:
:
function
<
void
(
const
RemoteTextureInfo
&
)
>
&
&
aReadyCallback
bool
aWaitForRemoteTextureOwner
=
false
)
;
bool
WaitForTxn
(
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
RemoteTextureTxnType
aTxnType
RemoteTextureTxnId
aTxnId
)
;
void
ReleaseRemoteTextureHost
(
RemoteTextureHostWrapper
*
aTextureHostWrapper
)
;
RefPtr
<
TextureHost
>
GetOrCreateRemoteTextureHostWrapper
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
const
gfx
:
:
IntSize
&
aSize
const
TextureFlags
aFlags
)
;
void
UnregisterRemoteTextureHostWrapper
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
)
;
bool
CheckRemoteTextureReady
(
const
RemoteTextureInfo
&
aInfo
std
:
:
function
<
void
(
const
RemoteTextureInfo
&
)
>
&
&
aCallback
)
;
bool
WaitRemoteTextureReady
(
const
RemoteTextureInfo
&
aInfo
)
;
void
SuppressRemoteTextureReadyCheck
(
const
RemoteTextureId
aTextureId
const
base
:
:
ProcessId
aForPid
)
;
UniquePtr
<
TextureData
>
GetRecycledTextureData
(
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
const
RefPtr
<
RemoteTextureRecycleBin
>
&
aRecycleBin
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
TextureType
aTextureType
)
;
UniquePtr
<
SharedResourceWrapper
>
GetRecycledSharedTexture
(
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
const
RefPtr
<
RemoteTextureRecycleBin
>
&
aRecycleBin
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
SurfaceDescriptor
:
:
Type
aType
)
;
static
RefPtr
<
TextureHost
>
CreateRemoteTexture
(
TextureData
*
aTextureData
TextureFlags
aTextureFlags
)
;
already_AddRefed
<
RemoteTextureTxnScheduler
>
RegisterTxnScheduler
(
base
:
:
ProcessId
aForPid
RemoteTextureTxnType
aType
)
;
protected
:
friend
class
RemoteTextureTxnScheduler
;
struct
TextureDataHolder
{
TextureDataHolder
(
const
RemoteTextureId
aTextureId
RefPtr
<
TextureHost
>
aTextureHost
UniquePtr
<
TextureData
>
&
&
aTextureData
UniquePtr
<
SharedResourceWrapper
>
&
&
aResourceWrapper
)
;
const
RemoteTextureId
mTextureId
;
RefPtr
<
TextureHost
>
mTextureHost
;
UniquePtr
<
TextureData
>
mTextureData
;
UniquePtr
<
SharedResourceWrapper
>
mResourceWrapper
;
}
;
struct
RenderingReadyCallbackHolder
{
RenderingReadyCallbackHolder
(
const
RemoteTextureId
aTextureId
std
:
:
function
<
void
(
const
RemoteTextureInfo
&
)
>
&
&
aCallback
)
;
const
RemoteTextureId
mTextureId
;
std
:
:
function
<
void
(
const
RemoteTextureInfo
&
)
>
mCallback
;
}
;
struct
TextureOwner
{
bool
mIsContextLost
=
false
;
bool
mWaitForTxn
=
false
;
RefPtr
<
nsISerialEventTarget
>
mDeferUnregister
;
std
:
:
deque
<
UniquePtr
<
TextureDataHolder
>
>
mWaitingTextureDataHolders
;
std
:
:
deque
<
UniquePtr
<
TextureDataHolder
>
>
mUsingTextureDataHolders
;
std
:
:
deque
<
UniquePtr
<
TextureDataHolder
>
>
mReleasingTextureDataHolders
;
std
:
:
deque
<
UniquePtr
<
RenderingReadyCallbackHolder
>
>
mRenderingReadyCallbackHolders
;
RemoteTextureId
mLatestTextureId
=
{
0
}
;
CompositableTextureHostRef
mLatestTextureHost
;
CompositableTextureHostRef
mLatestRenderedTextureHost
;
std
:
:
deque
<
CompositableTextureHostRef
>
mReleasingRenderedTextureHosts
;
RefPtr
<
RemoteTextureRecycleBin
>
mRecycleBin
;
}
;
struct
RemoteTextureHostWrapperHolder
{
explicit
RemoteTextureHostWrapperHolder
(
RefPtr
<
TextureHost
>
aRemoteTextureHostWrapper
)
;
const
RefPtr
<
TextureHost
>
mRemoteTextureHostWrapper
;
CompositableTextureHostRef
mRemoteTextureHost
;
bool
mReadyCheckSuppressed
=
false
;
}
;
void
UpdateTexture
(
const
MonitorAutoLock
&
aProofOfLock
RemoteTextureMap
:
:
TextureOwner
*
aOwner
const
RemoteTextureId
aTextureId
)
;
UniquePtr
<
TextureOwner
>
UnregisterTextureOwner
(
const
MonitorAutoLock
&
aProofOfLock
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
std
:
:
vector
<
RefPtr
<
TextureHost
>
>
&
aReleasingTextures
std
:
:
vector
<
std
:
:
function
<
void
(
const
RemoteTextureInfo
&
)
>
>
&
aRenderingReadyCallbacks
)
;
void
GetRenderingReadyCallbacks
(
const
MonitorAutoLock
&
aProofOfLock
RemoteTextureMap
:
:
TextureOwner
*
aOwner
const
RemoteTextureId
aTextureId
std
:
:
vector
<
std
:
:
function
<
void
(
const
RemoteTextureInfo
&
)
>
>
&
aFunctions
)
;
void
GetAllRenderingReadyCallbacks
(
const
MonitorAutoLock
&
aProofOfLock
RemoteTextureMap
:
:
TextureOwner
*
aOwner
std
:
:
vector
<
std
:
:
function
<
void
(
const
RemoteTextureInfo
&
)
>
>
&
aFunctions
)
;
void
KeepTextureDataAliveForTextureHostIfNecessary
(
const
MonitorAutoLock
&
aProofOfLock
RemoteTextureMap
:
:
TextureOwner
*
aOwner
std
:
:
deque
<
UniquePtr
<
TextureDataHolder
>
>
&
aHolders
)
;
bool
RecycleTexture
(
const
RefPtr
<
RemoteTextureRecycleBin
>
&
aRecycleBin
TextureDataHolder
&
aHolder
bool
aExpireOldTextures
)
;
RemoteTextureMap
:
:
TextureOwner
*
GetTextureOwner
(
const
MonitorAutoLock
&
aProofOfLock
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
)
;
void
NotifyTxn
(
const
MonitorAutoLock
&
aProofOfLock
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
)
;
void
UnregisterTxnScheduler
(
base
:
:
ProcessId
aForPid
RemoteTextureTxnType
aType
)
;
Monitor
mMonitor
MOZ_UNANNOTATED
;
std
:
:
map
<
std
:
:
pair
<
base
:
:
ProcessId
RemoteTextureOwnerId
>
UniquePtr
<
TextureOwner
>
>
mTextureOwners
;
std
:
:
map
<
std
:
:
pair
<
base
:
:
ProcessId
RemoteTextureId
>
UniquePtr
<
RemoteTextureHostWrapperHolder
>
>
mRemoteTextureHostWrapperHolders
;
std
:
:
map
<
std
:
:
pair
<
base
:
:
ProcessId
RemoteTextureTxnType
>
RemoteTextureTxnScheduler
*
>
mTxnSchedulers
;
static
StaticAutoPtr
<
RemoteTextureMap
>
sInstance
;
}
;
}
}
#
endif
