#
ifndef
MOZILLA_GFX_RemoteTextureMap_H
#
define
MOZILLA_GFX_RemoteTextureMap_H
#
include
<
deque
>
#
include
<
functional
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
queue
>
#
include
<
stack
>
#
include
<
unordered_set
>
#
include
<
utility
>
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
ThreadSafeWeakPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderTypes
.
h
"
class
nsISerialEventTarget
;
namespace
mozilla
{
namespace
gl
{
class
SharedSurface
;
}
namespace
layers
{
class
RemoteTextureHostWrapper
;
class
TextureData
;
class
TextureHost
;
class
RemoteTextureOwnerClient
final
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
RemoteTextureOwnerClient
)
explicit
RemoteTextureOwnerClient
(
const
base
:
:
ProcessId
aForPid
)
;
bool
IsRegistered
(
const
RemoteTextureOwnerId
aOwnerId
)
;
void
RegisterTextureOwner
(
const
RemoteTextureOwnerId
aOwnerId
)
;
void
UnregisterTextureOwner
(
const
RemoteTextureOwnerId
aOwnerId
)
;
void
UnregisterAllTextureOwners
(
)
;
void
PushTexture
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
UniquePtr
<
TextureData
>
&
&
aTextureData
const
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
&
aSharedSurface
)
;
UniquePtr
<
TextureData
>
CreateOrRecycleBufferTextureData
(
const
RemoteTextureOwnerId
aOwnerId
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
)
;
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
GetRecycledSharedSurface
(
const
RemoteTextureOwnerId
aOwnerId
)
;
const
base
:
:
ProcessId
mForPid
;
protected
:
~
RemoteTextureOwnerClient
(
)
;
std
:
:
unordered_set
<
RemoteTextureOwnerId
RemoteTextureOwnerId
:
:
HashFn
>
mOwnerIds
;
}
;
class
RemoteTextureMap
{
public
:
static
void
Init
(
)
;
static
void
Shutdown
(
)
;
static
RemoteTextureMap
*
Get
(
)
{
return
sInstance
;
}
RemoteTextureMap
(
)
;
~
RemoteTextureMap
(
)
;
void
PushTexture
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
UniquePtr
<
TextureData
>
&
&
aTextureData
const
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
&
aSharedSurface
)
;
void
RegisterTextureOwner
(
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
)
;
void
UnregisterTextureOwner
(
const
RemoteTextureOwnerId
aOwnerIds
const
base
:
:
ProcessId
aForPid
)
;
void
UnregisterTextureOwners
(
const
std
:
:
unordered_set
<
RemoteTextureOwnerId
RemoteTextureOwnerId
:
:
HashFn
>
&
aOwnerIds
const
base
:
:
ProcessId
aForPid
)
;
void
GetRemoteTextureHost
(
RemoteTextureHostWrapper
*
aTextureHostWrapper
)
;
void
ReleaseRemoteTextureHost
(
RemoteTextureHostWrapper
*
aTextureHostWrapper
)
;
RefPtr
<
TextureHost
>
GetOrCreateRemoteTextureHostWrapper
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
const
gfx
:
:
IntSize
aSize
const
TextureFlags
aFlags
)
;
void
UnregisterRemoteTextureHostWrapper
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
)
;
UniquePtr
<
TextureData
>
GetRecycledBufferTextureData
(
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
)
;
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
GetRecycledSharedSurface
(
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
)
;
protected
:
struct
TextureDataHolder
{
TextureDataHolder
(
const
RemoteTextureId
aTextureId
RefPtr
<
TextureHost
>
aTextureHost
UniquePtr
<
TextureData
>
&
&
aTextureData
const
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
&
aSharedSurface
)
;
const
RemoteTextureId
mTextureId
;
RefPtr
<
TextureHost
>
mTextureHost
;
UniquePtr
<
TextureData
>
mTextureData
;
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
mSharedSurface
;
}
;
struct
TextureOwner
{
std
:
:
queue
<
UniquePtr
<
TextureDataHolder
>
>
mWaitingTextureDataHolders
;
std
:
:
deque
<
UniquePtr
<
TextureDataHolder
>
>
mUsingTextureDataHolders
;
RemoteTextureId
mLatestTextureId
=
{
0
}
;
CompositableTextureHostRef
mLatestTextureHost
;
std
:
:
stack
<
UniquePtr
<
TextureData
>
>
mRecycledTextures
;
std
:
:
stack
<
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
>
mRecycledSharedSurfaces
;
}
;
void
UpdateTexture
(
const
MutexAutoLock
&
aProofOfLock
RemoteTextureMap
:
:
TextureOwner
*
aOwner
const
RemoteTextureId
aTextureId
)
;
void
KeepTextureDataAliveForTextureHostIfNecessary
(
const
MutexAutoLock
&
aProofOfLock
std
:
:
deque
<
UniquePtr
<
TextureDataHolder
>
>
&
aHolders
)
;
RemoteTextureMap
:
:
TextureOwner
*
GetTextureOwner
(
const
MutexAutoLock
&
aProofOfLock
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
)
;
static
RefPtr
<
TextureHost
>
CreateRemoteTexture
(
TextureData
*
aTextureData
)
;
Mutex
mMutex
MOZ_UNANNOTATED
;
std
:
:
map
<
std
:
:
pair
<
base
:
:
ProcessId
RemoteTextureOwnerId
>
UniquePtr
<
TextureOwner
>
>
mTextureOwners
;
std
:
:
map
<
std
:
:
pair
<
base
:
:
ProcessId
RemoteTextureId
>
RefPtr
<
TextureHost
>
>
mRemoteTextureHostWrappers
;
static
StaticAutoPtr
<
RemoteTextureMap
>
sInstance
;
}
;
}
}
#
endif
