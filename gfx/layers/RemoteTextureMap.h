#
ifndef
MOZILLA_GFX_RemoteTextureMap_H
#
define
MOZILLA_GFX_RemoteTextureMap_H
#
include
<
functional
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
queue
>
#
include
<
stack
>
#
include
<
unordered_map
>
#
include
<
unordered_set
>
#
include
<
utility
>
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
ThreadSafeWeakPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
class
nsISerialEventTarget
;
namespace
mozilla
{
namespace
gl
{
class
SharedSurface
;
}
namespace
layers
{
class
TextureData
;
class
TextureHost
;
class
RemoteTextureOwnerClient
final
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
RemoteTextureOwnerClient
)
explicit
RemoteTextureOwnerClient
(
const
base
:
:
ProcessId
aForPid
)
;
bool
IsRegistered
(
const
RemoteTextureOwnerId
aOwnerId
)
;
void
RegisterTextureOwner
(
const
RemoteTextureOwnerId
aOwnerId
)
;
void
UnregisterTextureOwner
(
const
RemoteTextureOwnerId
aOwnerId
)
;
void
UnregisterAllTextureOwners
(
)
;
void
PushTexture
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
UniquePtr
<
TextureData
>
&
&
aTextureData
const
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
&
aSharedSurface
)
;
UniquePtr
<
TextureData
>
CreateOrRecycleBufferTextureData
(
const
RemoteTextureOwnerId
aOwnerId
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
)
;
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
GetRecycledSharedSurface
(
const
RemoteTextureOwnerId
aOwnerId
)
;
const
base
:
:
ProcessId
mForPid
;
protected
:
~
RemoteTextureOwnerClient
(
)
;
std
:
:
unordered_set
<
RemoteTextureOwnerId
RemoteTextureOwnerId
:
:
HashFn
>
mOwnerIds
;
}
;
using
RemoteTextureCallback
=
std
:
:
function
<
void
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
)
>
;
class
RemoteTextureConsumerClient
{
public
:
static
UniquePtr
<
RemoteTextureConsumerClient
>
Create
(
const
RemoteTextureOwnerId
aOwnerId
const
CompositableHandle
&
aHandle
const
base
:
:
ProcessId
aForPid
)
;
RemoteTextureConsumerClient
(
const
RemoteTextureOwnerId
aOwnerId
const
CompositableHandle
&
aHandle
const
base
:
:
ProcessId
aForPid
)
;
~
RemoteTextureConsumerClient
(
)
;
RefPtr
<
TextureHost
>
GetTextureHost
(
const
RemoteTextureId
aTextureId
const
gfx
:
:
IntSize
aSize
const
TextureFlags
aFlags
const
RemoteTextureCallback
&
aCallback
)
;
const
RemoteTextureOwnerId
mOwnerId
;
const
CompositableHandle
mHandle
;
const
base
:
:
ProcessId
mForPid
;
}
;
class
SharedSurfaceWrapper
:
public
SupportsThreadSafeWeakPtr
<
SharedSurfaceWrapper
>
{
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
SharedSurfaceWrapper
)
explicit
SharedSurfaceWrapper
(
const
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
&
aSharedSurface
)
;
virtual
~
SharedSurfaceWrapper
(
)
;
bool
IsUsed
(
)
{
return
mIsUsed
;
}
void
EndUsage
(
)
{
mIsUsed
=
false
;
}
const
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
mSharedSurface
;
protected
:
Atomic
<
bool
>
mIsUsed
{
true
}
;
}
;
class
RemoteTextureMap
{
public
:
static
void
Init
(
)
;
static
void
Shutdown
(
)
;
static
RemoteTextureMap
*
Get
(
)
{
return
sInstance
;
}
RemoteTextureMap
(
)
;
~
RemoteTextureMap
(
)
;
void
PushTexture
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
UniquePtr
<
TextureData
>
&
&
aTextureData
const
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
&
aSharedSurface
)
;
void
RegisterTextureOwner
(
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
)
;
void
UnregisterTextureOwner
(
const
RemoteTextureOwnerId
aOwnerIds
const
base
:
:
ProcessId
aForPid
)
;
void
UnregisterTextureOwners
(
const
std
:
:
unordered_set
<
RemoteTextureOwnerId
RemoteTextureOwnerId
:
:
HashFn
>
&
aOwnerIds
const
base
:
:
ProcessId
aForPid
)
;
UniquePtr
<
RemoteTextureConsumerClient
>
RegisterTextureConsumer
(
const
RemoteTextureOwnerId
aOwnerId
const
CompositableHandle
&
aHandle
const
base
:
:
ProcessId
aForPid
)
;
void
UnregisterTextureConsumer
(
const
RemoteTextureOwnerId
aOwnerId
const
CompositableHandle
&
aHandle
const
base
:
:
ProcessId
aForPid
)
;
RefPtr
<
TextureHost
>
GetTextureHost
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
const
CompositableHandle
&
aHandle
const
base
:
:
ProcessId
aForPid
const
gfx
:
:
IntSize
aSize
const
TextureFlags
aFlags
const
RemoteTextureCallback
&
aCallback
)
;
void
NotifyReleased
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
)
;
UniquePtr
<
TextureData
>
GetRecycledBufferTextureData
(
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
)
;
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
GetRecycledSharedSurface
(
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
)
;
protected
:
struct
TextureDataWrapper
{
TextureDataWrapper
(
const
RemoteTextureId
aTextureId
UniquePtr
<
TextureData
>
&
&
aTextureData
const
ThreadSafeWeakPtr
<
SharedSurfaceWrapper
>
&
aSharedSurface
)
;
const
RemoteTextureId
mTextureId
;
UniquePtr
<
TextureData
>
mTextureData
;
ThreadSafeWeakPtr
<
SharedSurfaceWrapper
>
mSharedSurface
;
}
;
struct
TextureOwner
{
std
:
:
queue
<
UniquePtr
<
TextureDataWrapper
>
>
mTextureDataWrappers
;
RemoteTextureId
mLatestTextureId
=
{
0
}
;
RefPtr
<
TextureHost
>
mLatestTextureHost
;
std
:
:
queue
<
RefPtr
<
SharedSurfaceWrapper
>
>
mSharedSurfaces
;
std
:
:
stack
<
UniquePtr
<
TextureData
>
>
mRecycledTextures
;
std
:
:
stack
<
RefPtr
<
SharedSurfaceWrapper
>
>
mRecycledSharedSurfaces
;
}
;
struct
TextureConsumer
{
explicit
TextureConsumer
(
const
CompositableHandle
&
aHandle
)
:
mHandle
(
aHandle
)
{
}
CompositableHandle
mHandle
;
std
:
:
queue
<
std
:
:
pair
<
RemoteTextureId
RemoteTextureCallback
>
>
mCallbacks
;
}
;
RemoteTextureMap
:
:
TextureOwner
*
GetTextureOwner
(
const
MutexAutoLock
&
aProofOfLock
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
)
;
RemoteTextureMap
:
:
TextureConsumer
*
GetTextureConsumer
(
const
MutexAutoLock
&
aProofOfLock
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
)
;
RefPtr
<
TextureHost
>
CreateRemoteTexture
(
const
gfx
:
:
IntSize
aSize
const
TextureFlags
aFlags
TextureDataWrapper
*
aTextureData
)
;
Mutex
mMutex
MOZ_UNANNOTATED
;
std
:
:
map
<
std
:
:
pair
<
base
:
:
ProcessId
RemoteTextureOwnerId
>
UniquePtr
<
TextureOwner
>
>
mTextureOwners
;
std
:
:
map
<
std
:
:
pair
<
base
:
:
ProcessId
RemoteTextureOwnerId
>
UniquePtr
<
TextureConsumer
>
>
mTextureConsumers
;
std
:
:
map
<
std
:
:
pair
<
base
:
:
ProcessId
RemoteTextureId
>
UniquePtr
<
TextureDataWrapper
>
>
mKeepAlives
;
static
StaticAutoPtr
<
RemoteTextureMap
>
sInstance
;
}
;
}
}
#
endif
