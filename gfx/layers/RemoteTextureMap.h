#
ifndef
MOZILLA_GFX_RemoteTextureMap_H
#
define
MOZILLA_GFX_RemoteTextureMap_H
#
include
<
deque
>
#
include
<
functional
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
queue
>
#
include
<
stack
>
#
include
<
unordered_set
>
#
include
<
utility
>
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
ipc
/
Shmem
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
ThreadSafeWeakPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderTypes
.
h
"
class
nsISerialEventTarget
;
namespace
mozilla
{
namespace
gl
{
class
SharedSurface
;
}
namespace
webgpu
{
class
ExternalTexture
;
}
namespace
layers
{
class
CompositableHost
;
class
RemoteTextureHostWrapper
;
class
TextureData
;
class
TextureHost
;
struct
RemoteTextureInfo
{
RemoteTextureInfo
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
)
:
mTextureId
(
aTextureId
)
mOwnerId
(
aOwnerId
)
mForPid
(
aForPid
)
{
}
const
RemoteTextureId
mTextureId
;
const
RemoteTextureOwnerId
mOwnerId
;
const
base
:
:
ProcessId
mForPid
;
}
;
struct
RemoteTextureInfoList
{
std
:
:
queue
<
RemoteTextureInfo
>
mList
;
}
;
class
SharedResourceWrapper
{
public
:
enum
class
Tag
{
SharedSurface
ExternalTexture
}
;
const
Tag
mTag
;
static
UniquePtr
<
SharedResourceWrapper
>
SharedSurface
(
const
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
&
aSharedSurface
)
{
return
MakeUnique
<
SharedResourceWrapper
>
(
Tag
:
:
SharedSurface
aSharedSurface
)
;
}
static
UniquePtr
<
SharedResourceWrapper
>
ExternalTexture
(
const
std
:
:
shared_ptr
<
webgpu
:
:
ExternalTexture
>
&
aExternalTexture
)
{
return
MakeUnique
<
SharedResourceWrapper
>
(
Tag
:
:
ExternalTexture
aExternalTexture
)
;
}
SharedResourceWrapper
(
const
Tag
aTag
const
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
&
aSharedSurface
)
:
mTag
(
aTag
)
mSharedSurface
(
aSharedSurface
)
{
MOZ_ASSERT
(
mTag
=
=
Tag
:
:
SharedSurface
)
;
}
SharedResourceWrapper
(
const
Tag
aTag
const
std
:
:
shared_ptr
<
webgpu
:
:
ExternalTexture
>
&
aExternalTexture
)
:
mTag
(
aTag
)
mExternalTexture
(
aExternalTexture
)
{
MOZ_ASSERT
(
mTag
=
=
Tag
:
:
ExternalTexture
)
;
}
const
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
mSharedSurface
;
const
std
:
:
shared_ptr
<
webgpu
:
:
ExternalTexture
>
mExternalTexture
;
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
SharedSurface
(
)
{
if
(
mTag
=
=
Tag
:
:
SharedSurface
)
{
return
mSharedSurface
;
}
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
to
be
called
"
)
;
return
nullptr
;
}
std
:
:
shared_ptr
<
webgpu
:
:
ExternalTexture
>
ExternalTexture
(
)
{
if
(
mTag
=
=
Tag
:
:
ExternalTexture
)
{
return
mExternalTexture
;
}
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
to
be
called
"
)
;
return
nullptr
;
}
}
;
class
RemoteTextureOwnerClient
final
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
RemoteTextureOwnerClient
)
explicit
RemoteTextureOwnerClient
(
const
base
:
:
ProcessId
aForPid
)
;
bool
IsRegistered
(
const
RemoteTextureOwnerId
aOwnerId
)
;
void
RegisterTextureOwner
(
const
RemoteTextureOwnerId
aOwnerId
bool
aIsSyncMode
)
;
void
UnregisterTextureOwner
(
const
RemoteTextureOwnerId
aOwnerId
)
;
void
UnregisterAllTextureOwners
(
)
;
void
NotifyContextLost
(
)
;
void
PushTexture
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
UniquePtr
<
TextureData
>
&
&
aTextureData
)
;
void
PushTexture
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
UniquePtr
<
TextureData
>
&
&
aTextureData
const
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
&
aSharedSurface
)
;
void
PushTexture
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
UniquePtr
<
TextureData
>
&
&
aTextureData
const
std
:
:
shared_ptr
<
webgpu
:
:
ExternalTexture
>
&
aExternalTexture
)
;
void
PushDummyTexture
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
)
;
void
GetLatestBufferSnapshot
(
const
RemoteTextureOwnerId
aOwnerId
const
mozilla
:
:
ipc
:
:
Shmem
&
aDestShmem
const
gfx
:
:
IntSize
&
aSize
)
;
UniquePtr
<
TextureData
>
CreateOrRecycleBufferTextureData
(
const
RemoteTextureOwnerId
aOwnerId
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
)
;
std
:
:
shared_ptr
<
gl
:
:
SharedSurface
>
GetRecycledSharedSurface
(
const
RemoteTextureOwnerId
aOwnerId
)
;
std
:
:
shared_ptr
<
webgpu
:
:
ExternalTexture
>
GetRecycledExternalTexture
(
const
RemoteTextureOwnerId
aOwnerId
)
;
const
base
:
:
ProcessId
mForPid
;
protected
:
~
RemoteTextureOwnerClient
(
)
;
std
:
:
unordered_set
<
RemoteTextureOwnerId
RemoteTextureOwnerId
:
:
HashFn
>
mOwnerIds
;
}
;
class
RemoteTextureMap
{
public
:
static
void
Init
(
)
;
static
void
Shutdown
(
)
;
static
RemoteTextureMap
*
Get
(
)
{
return
sInstance
;
}
RemoteTextureMap
(
)
;
~
RemoteTextureMap
(
)
;
void
PushTexture
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
UniquePtr
<
TextureData
>
&
&
aTextureData
RefPtr
<
TextureHost
>
&
aTextureHost
UniquePtr
<
SharedResourceWrapper
>
&
&
aResourceWrapper
)
;
void
GetLatestBufferSnapshot
(
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
const
mozilla
:
:
ipc
:
:
Shmem
&
aDestShmem
const
gfx
:
:
IntSize
&
aSize
)
;
void
RegisterTextureOwner
(
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
bool
aIsSyncMode
)
;
void
UnregisterTextureOwner
(
const
RemoteTextureOwnerId
aOwnerIds
const
base
:
:
ProcessId
aForPid
)
;
void
UnregisterTextureOwners
(
const
std
:
:
unordered_set
<
RemoteTextureOwnerId
RemoteTextureOwnerId
:
:
HashFn
>
&
aOwnerIds
const
base
:
:
ProcessId
aForPid
)
;
void
NotifyContextLost
(
const
std
:
:
unordered_set
<
RemoteTextureOwnerId
RemoteTextureOwnerId
:
:
HashFn
>
&
aOwnerIds
const
base
:
:
ProcessId
aForPid
)
;
bool
GetRemoteTextureForDisplayList
(
RemoteTextureHostWrapper
*
aTextureHostWrapper
std
:
:
function
<
void
(
const
RemoteTextureInfo
&
)
>
&
&
aReadyCallback
)
;
wr
:
:
MaybeExternalImageId
GetExternalImageIdOfRemoteTexture
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
)
;
void
ReleaseRemoteTextureHostForDisplayList
(
RemoteTextureHostWrapper
*
aTextureHostWrapper
)
;
RefPtr
<
TextureHost
>
GetOrCreateRemoteTextureHostWrapper
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
const
gfx
:
:
IntSize
aSize
const
TextureFlags
aFlags
)
;
void
UnregisterRemoteTextureHostWrapper
(
const
RemoteTextureId
aTextureId
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
)
;
void
RegisterRemoteTexturePushListener
(
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
CompositableHost
*
aListener
)
;
void
UnregisterRemoteTexturePushListener
(
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
CompositableHost
*
aListener
)
;
bool
CheckRemoteTextureReady
(
const
RemoteTextureInfo
&
aInfo
std
:
:
function
<
void
(
const
RemoteTextureInfo
&
)
>
&
&
aCallback
)
;
bool
WaitRemoteTextureReady
(
const
RemoteTextureInfo
&
aInfo
)
;
void
SuppressRemoteTextureReadyCheck
(
const
RemoteTextureId
aTextureId
const
base
:
:
ProcessId
aForPid
)
;
UniquePtr
<
TextureData
>
GetRecycledBufferTextureData
(
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
)
;
UniquePtr
<
SharedResourceWrapper
>
GetRecycledSharedTexture
(
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
)
;
static
RefPtr
<
TextureHost
>
CreateRemoteTexture
(
TextureData
*
aTextureData
TextureFlags
aTextureFlags
)
;
protected
:
struct
TextureDataHolder
{
TextureDataHolder
(
const
RemoteTextureId
aTextureId
RefPtr
<
TextureHost
>
aTextureHost
UniquePtr
<
TextureData
>
&
&
aTextureData
UniquePtr
<
SharedResourceWrapper
>
&
&
aResourceWrapper
)
;
const
RemoteTextureId
mTextureId
;
RefPtr
<
TextureHost
>
mTextureHost
;
UniquePtr
<
TextureData
>
mTextureData
;
UniquePtr
<
SharedResourceWrapper
>
mResourceWrapper
;
}
;
struct
RenderingReadyCallbackHolder
{
RenderingReadyCallbackHolder
(
const
RemoteTextureId
aTextureId
std
:
:
function
<
void
(
const
RemoteTextureInfo
&
)
>
&
&
aCallback
)
;
const
RemoteTextureId
mTextureId
;
std
:
:
function
<
void
(
const
RemoteTextureInfo
&
)
>
mCallback
;
}
;
struct
TextureOwner
{
bool
mIsSyncMode
=
true
;
bool
mIsContextLost
=
false
;
std
:
:
deque
<
UniquePtr
<
TextureDataHolder
>
>
mWaitingTextureDataHolders
;
std
:
:
deque
<
UniquePtr
<
TextureDataHolder
>
>
mUsingTextureDataHolders
;
std
:
:
deque
<
UniquePtr
<
RenderingReadyCallbackHolder
>
>
mRenderingReadyCallbackHolders
;
RemoteTextureId
mLatestTextureId
=
{
0
}
;
CompositableTextureHostRef
mLatestTextureHost
;
CompositableTextureHostRef
mLatestRenderedTextureHost
;
std
:
:
deque
<
CompositableTextureHostRef
>
mReleasingRenderedTextureHosts
;
std
:
:
stack
<
UniquePtr
<
TextureData
>
>
mRecycledTextures
;
std
:
:
queue
<
UniquePtr
<
SharedResourceWrapper
>
>
mRecycledSharedTextures
;
}
;
struct
RemoteTextureHostWrapperHolder
{
explicit
RemoteTextureHostWrapperHolder
(
RefPtr
<
TextureHost
>
aRemoteTextureHostWrapper
)
;
const
RefPtr
<
TextureHost
>
mRemoteTextureHostWrapper
;
CompositableTextureHostRef
mAsyncRemoteTextureHost
;
bool
mReadyCheckSuppressed
=
false
;
}
;
void
UpdateTexture
(
const
MonitorAutoLock
&
aProofOfLock
RemoteTextureMap
:
:
TextureOwner
*
aOwner
const
RemoteTextureId
aTextureId
)
;
std
:
:
vector
<
std
:
:
function
<
void
(
const
RemoteTextureInfo
&
)
>
>
GetRenderingReadyCallbacks
(
const
MonitorAutoLock
&
aProofOfLock
RemoteTextureMap
:
:
TextureOwner
*
aOwner
const
RemoteTextureId
aTextureId
)
;
std
:
:
vector
<
std
:
:
function
<
void
(
const
RemoteTextureInfo
&
)
>
>
GetAllRenderingReadyCallbacks
(
const
MonitorAutoLock
&
aProofOfLock
RemoteTextureMap
:
:
TextureOwner
*
aOwner
)
;
void
KeepTextureDataAliveForTextureHostIfNecessary
(
const
MonitorAutoLock
&
aProofOfLock
std
:
:
deque
<
UniquePtr
<
TextureDataHolder
>
>
&
aHolders
)
;
RemoteTextureMap
:
:
TextureOwner
*
GetTextureOwner
(
const
MonitorAutoLock
&
aProofOfLock
const
RemoteTextureOwnerId
aOwnerId
const
base
:
:
ProcessId
aForPid
)
;
Monitor
mMonitor
MOZ_UNANNOTATED
;
std
:
:
map
<
std
:
:
pair
<
base
:
:
ProcessId
RemoteTextureOwnerId
>
UniquePtr
<
TextureOwner
>
>
mTextureOwners
;
std
:
:
map
<
std
:
:
pair
<
base
:
:
ProcessId
RemoteTextureId
>
UniquePtr
<
RemoteTextureHostWrapperHolder
>
>
mRemoteTextureHostWrapperHolders
;
std
:
:
map
<
std
:
:
pair
<
base
:
:
ProcessId
RemoteTextureOwnerId
>
RefPtr
<
CompositableHost
>
>
mRemoteTexturePushListeners
;
static
StaticAutoPtr
<
RemoteTextureMap
>
sInstance
;
}
;
}
}
#
endif
