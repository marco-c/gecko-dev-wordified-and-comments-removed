#
include
"
CopyableCanvasLayer
.
h
"
#
include
"
BasicLayersImpl
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
GLScreenBuffer
.
h
"
#
include
"
SharedSurface
.
h
"
#
include
"
SharedSurfaceGL
.
h
"
#
include
"
gfxPattern
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxRect
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
mozilla
/
gfx
/
BaseSize
.
h
"
#
include
"
mozilla
/
gfx
/
Tools
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
layers
/
AsyncCanvasRenderer
.
h
"
#
include
"
mozilla
/
layers
/
PersistentBufferProvider
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
client
/
TextureClientSharedSurface
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
gl
;
CopyableCanvasLayer
:
:
CopyableCanvasLayer
(
LayerManager
*
aLayerManager
void
*
aImplData
)
:
CanvasLayer
(
aLayerManager
aImplData
)
mGLFrontbuffer
(
nullptr
)
mIsAlphaPremultiplied
(
true
)
mOriginPos
(
gl
:
:
OriginPos
:
:
TopLeft
)
mIsMirror
(
false
)
{
MOZ_COUNT_CTOR
(
CopyableCanvasLayer
)
;
}
CopyableCanvasLayer
:
:
~
CopyableCanvasLayer
(
)
{
MOZ_COUNT_DTOR
(
CopyableCanvasLayer
)
;
}
void
CopyableCanvasLayer
:
:
Initialize
(
const
Data
&
aData
)
{
if
(
aData
.
mGLContext
)
{
mGLContext
=
aData
.
mGLContext
;
mIsAlphaPremultiplied
=
aData
.
mIsGLAlphaPremult
;
mOriginPos
=
gl
:
:
OriginPos
:
:
BottomLeft
;
mIsMirror
=
aData
.
mIsMirror
;
MOZ_ASSERT
(
mGLContext
-
>
IsOffscreen
(
)
"
canvas
gl
context
isn
'
t
offscreen
"
)
;
if
(
aData
.
mFrontbufferGLTex
)
{
gfx
:
:
IntSize
size
(
aData
.
mSize
.
width
aData
.
mSize
.
height
)
;
mGLFrontbuffer
=
SharedSurface_Basic
:
:
Wrap
(
aData
.
mGLContext
size
aData
.
mHasAlpha
aData
.
mFrontbufferGLTex
)
;
mBufferProvider
=
aData
.
mBufferProvider
;
}
}
else
if
(
aData
.
mBufferProvider
)
{
mBufferProvider
=
aData
.
mBufferProvider
;
}
else
if
(
aData
.
mRenderer
)
{
mAsyncRenderer
=
aData
.
mRenderer
;
mOriginPos
=
gl
:
:
OriginPos
:
:
BottomLeft
;
}
else
{
MOZ_CRASH
(
"
GFX
:
CanvasLayer
created
without
BufferProvider
DrawTarget
or
GLContext
?
"
)
;
}
mBounds
.
SetRect
(
0
0
aData
.
mSize
.
width
aData
.
mSize
.
height
)
;
}
bool
CopyableCanvasLayer
:
:
IsDataValid
(
const
Data
&
aData
)
{
return
mGLContext
=
=
aData
.
mGLContext
;
}
DataSourceSurface
*
CopyableCanvasLayer
:
:
GetTempSurface
(
const
IntSize
&
aSize
const
SurfaceFormat
aFormat
)
{
if
(
!
mCachedTempSurface
|
|
aSize
!
=
mCachedTempSurface
-
>
GetSize
(
)
|
|
aFormat
!
=
mCachedTempSurface
-
>
GetFormat
(
)
)
{
uint32_t
stride
=
GetAlignedStride
<
8
>
(
aSize
.
width
BytesPerPixel
(
aFormat
)
)
;
mCachedTempSurface
=
Factory
:
:
CreateDataSourceSurfaceWithStride
(
aSize
aFormat
stride
)
;
}
return
mCachedTempSurface
;
}
}
}
