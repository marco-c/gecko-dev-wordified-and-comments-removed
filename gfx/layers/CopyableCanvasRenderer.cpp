#
include
"
CopyableCanvasRenderer
.
h
"
#
include
"
BasicLayersImpl
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
GLScreenBuffer
.
h
"
#
include
"
SharedSurface
.
h
"
#
include
"
SharedSurfaceGL
.
h
"
#
include
"
gfxPattern
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxRect
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
mozilla
/
gfx
/
BaseSize
.
h
"
#
include
"
mozilla
/
gfx
/
Tools
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
layers
/
AsyncCanvasRenderer
.
h
"
#
include
"
mozilla
/
layers
/
PersistentBufferProvider
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
client
/
TextureClientSharedSurface
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
gl
;
CopyableCanvasRenderer
:
:
CopyableCanvasRenderer
(
)
:
mGLContext
(
nullptr
)
mBufferProvider
(
nullptr
)
mAsyncRenderer
(
nullptr
)
mIsAlphaPremultiplied
(
true
)
mOriginPos
(
gl
:
:
OriginPos
:
:
TopLeft
)
mOpaque
(
true
)
mCachedTempSurface
(
nullptr
)
{
MOZ_COUNT_CTOR
(
CopyableCanvasRenderer
)
;
}
CopyableCanvasRenderer
:
:
~
CopyableCanvasRenderer
(
)
{
Destroy
(
)
;
MOZ_COUNT_DTOR
(
CopyableCanvasRenderer
)
;
}
void
CopyableCanvasRenderer
:
:
Initialize
(
const
CanvasInitializeData
&
aData
)
{
CanvasRenderer
:
:
Initialize
(
aData
)
;
if
(
aData
.
mGLContext
)
{
if
(
aData
.
mGLContext
-
>
IsDestroyed
(
)
)
{
return
;
}
mGLContext
=
aData
.
mGLContext
;
mIsAlphaPremultiplied
=
aData
.
mIsGLAlphaPremult
;
mOriginPos
=
gl
:
:
OriginPos
:
:
BottomLeft
;
MOZ_ASSERT
(
mGLContext
-
>
IsOffscreen
(
)
"
canvas
gl
context
isn
'
t
offscreen
"
)
;
}
else
if
(
aData
.
mBufferProvider
)
{
mBufferProvider
=
aData
.
mBufferProvider
;
}
else
if
(
aData
.
mRenderer
)
{
mAsyncRenderer
=
aData
.
mRenderer
;
mOriginPos
=
gl
:
:
OriginPos
:
:
BottomLeft
;
}
mOpaque
=
!
aData
.
mHasAlpha
;
}
bool
CopyableCanvasRenderer
:
:
IsDataValid
(
const
CanvasInitializeData
&
aData
)
{
return
mGLContext
=
=
aData
.
mGLContext
&
&
mBufferProvider
=
=
aData
.
mBufferProvider
;
}
void
CopyableCanvasRenderer
:
:
ClearCachedResources
(
)
{
SetDirty
(
)
;
if
(
mBufferProvider
)
{
mBufferProvider
-
>
ClearCachedResources
(
)
;
}
mCachedTempSurface
=
nullptr
;
}
void
CopyableCanvasRenderer
:
:
Destroy
(
)
{
if
(
mBufferProvider
)
{
mBufferProvider
-
>
ClearCachedResources
(
)
;
}
mBufferProvider
=
nullptr
;
mCachedTempSurface
=
nullptr
;
}
already_AddRefed
<
SourceSurface
>
CopyableCanvasRenderer
:
:
ReadbackSurface
(
)
{
struct
ScopedFireTransactionCallback
{
explicit
ScopedFireTransactionCallback
(
CopyableCanvasRenderer
*
aRenderer
)
:
mRenderer
(
aRenderer
)
{
mRenderer
-
>
FirePreTransactionCallback
(
)
;
}
~
ScopedFireTransactionCallback
(
)
{
mRenderer
-
>
FireDidTransactionCallback
(
)
;
}
CopyableCanvasRenderer
*
mRenderer
;
}
;
ScopedFireTransactionCallback
callback
(
this
)
;
if
(
mAsyncRenderer
)
{
MOZ_ASSERT
(
!
mBufferProvider
)
;
MOZ_ASSERT
(
!
mGLContext
)
;
return
mAsyncRenderer
-
>
GetSurface
(
)
;
}
if
(
!
mGLContext
)
{
return
nullptr
;
}
SharedSurface
*
frontbuffer
=
nullptr
;
if
(
mGLContext
-
>
Screen
(
)
)
{
const
auto
&
front
=
mGLContext
-
>
Screen
(
)
-
>
Front
(
)
;
if
(
front
)
{
frontbuffer
=
front
-
>
Surf
(
)
;
}
}
if
(
!
frontbuffer
)
{
NS_WARNING
(
"
Null
frame
received
.
"
)
;
return
nullptr
;
}
IntSize
readSize
(
frontbuffer
-
>
mSize
)
;
SurfaceFormat
format
=
frontbuffer
-
>
mHasAlpha
?
SurfaceFormat
:
:
B8G8R8A8
:
SurfaceFormat
:
:
B8G8R8X8
;
bool
needsPremult
=
frontbuffer
-
>
mHasAlpha
&
&
!
mIsAlphaPremultiplied
;
RefPtr
<
DataSourceSurface
>
resultSurf
=
GetTempSurface
(
readSize
format
)
;
if
(
NS_WARN_IF
(
!
resultSurf
)
)
{
return
nullptr
;
}
if
(
!
mGLContext
-
>
Readback
(
frontbuffer
resultSurf
)
)
{
NS_WARNING
(
"
Failed
to
read
back
canvas
surface
.
"
)
;
return
nullptr
;
}
if
(
needsPremult
)
{
gfxUtils
:
:
PremultiplyDataSurface
(
resultSurf
resultSurf
)
;
}
MOZ_ASSERT
(
resultSurf
)
;
return
resultSurf
.
forget
(
)
;
}
DataSourceSurface
*
CopyableCanvasRenderer
:
:
GetTempSurface
(
const
IntSize
&
aSize
const
SurfaceFormat
aFormat
)
{
if
(
!
mCachedTempSurface
|
|
aSize
!
=
mCachedTempSurface
-
>
GetSize
(
)
|
|
aFormat
!
=
mCachedTempSurface
-
>
GetFormat
(
)
)
{
uint32_t
stride
=
GetAlignedStride
<
8
>
(
aSize
.
width
BytesPerPixel
(
aFormat
)
)
;
mCachedTempSurface
=
Factory
:
:
CreateDataSourceSurfaceWithStride
(
aSize
aFormat
stride
)
;
}
return
mCachedTempSurface
;
}
}
}
