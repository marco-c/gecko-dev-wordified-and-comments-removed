#
ifndef
GFX_ANIMATIONINFO_H
#
define
GFX_ANIMATIONINFO_H
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsDisplayItemTypes
.
h
"
struct
RawServoAnimationValue
;
class
nsIFrame
;
namespace
mozilla
{
namespace
layers
{
class
Animation
;
class
CompositorAnimations
;
class
Layer
;
class
LayerManager
;
struct
AnimData
;
class
AnimationInfo
{
typedef
InfallibleTArray
<
Animation
>
AnimationArray
;
public
:
explicit
AnimationInfo
(
LayerManager
*
aManager
)
;
virtual
~
AnimationInfo
(
)
;
void
EnsureAnimationsId
(
)
;
Animation
*
AddAnimation
(
)
;
Animation
*
AddAnimationForNextTransaction
(
)
;
void
SetAnimationGeneration
(
uint64_t
aCount
)
{
mAnimationGeneration
=
aCount
;
}
uint64_t
GetAnimationGeneration
(
)
{
return
mAnimationGeneration
;
}
void
ClearAnimations
(
)
;
void
ClearAnimationsForNextTransaction
(
)
;
void
SetCompositorAnimations
(
const
CompositorAnimations
&
aCompositorAnimations
)
;
bool
StartPendingAnimations
(
const
TimeStamp
&
aReadyTime
)
;
void
TransferMutatedFlagToLayer
(
Layer
*
aLayer
)
;
uint64_t
GetCompositorAnimationsId
(
)
{
return
mCompositorAnimationsId
;
}
RawServoAnimationValue
*
GetBaseAnimationStyle
(
)
const
{
return
mBaseAnimationStyle
;
}
InfallibleTArray
<
AnimData
>
&
GetAnimationData
(
)
{
return
mAnimationData
;
}
AnimationArray
&
GetAnimations
(
)
{
return
mAnimations
;
}
bool
ApplyPendingUpdatesForThisTransaction
(
)
;
bool
HasTransformAnimation
(
)
const
;
static
Maybe
<
uint64_t
>
GetGenerationFromFrame
(
nsIFrame
*
aFrame
DisplayItemType
aDisplayItemKey
)
;
protected
:
LayerManager
*
mManager
;
AnimationArray
mAnimations
;
uint64_t
mCompositorAnimationsId
;
nsAutoPtr
<
AnimationArray
>
mPendingAnimations
;
InfallibleTArray
<
AnimData
>
mAnimationData
;
uint64_t
mAnimationGeneration
;
RefPtr
<
RawServoAnimationValue
>
mBaseAnimationStyle
;
bool
mMutated
;
}
;
}
}
#
endif
