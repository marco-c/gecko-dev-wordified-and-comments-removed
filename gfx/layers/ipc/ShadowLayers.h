#
ifndef
mozilla_layers_ShadowLayers_h
#
define
mozilla_layers_ShadowLayers_h
1
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
gfxTypes
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
WidgetUtils
.
h
"
#
include
"
mozilla
/
dom
/
ScreenOrientation
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemory
.
h
"
#
include
"
mozilla
/
layers
/
CompositableForwarder
.
h
"
#
include
"
mozilla
/
layers
/
TextureForwarder
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
<
vector
>
#
include
"
nsExpirationTracker
.
h
"
namespace
mozilla
{
namespace
layers
{
class
ClientLayerManager
;
class
CompositorBridgeChild
;
class
EditReply
;
class
FixedSizeSmallShmemSectionAllocator
;
class
ImageContainer
;
class
Layer
;
class
PLayerChild
;
class
PLayerTransactionChild
;
class
LayerTransactionChild
;
class
ShadowableLayer
;
class
SurfaceDescriptor
;
class
TextureClient
;
class
ThebesBuffer
;
class
ThebesBufferData
;
class
Transaction
;
class
ActiveResource
{
public
:
virtual
void
NotifyInactive
(
)
=
0
;
nsExpirationState
*
GetExpirationState
(
)
{
return
&
mExpirationState
;
}
bool
IsActivityTracked
(
)
{
return
mExpirationState
.
IsTracked
(
)
;
}
private
:
nsExpirationState
mExpirationState
;
}
;
class
ActiveResourceTracker
:
public
nsExpirationTracker
<
ActiveResource
3
>
{
public
:
ActiveResourceTracker
(
uint32_t
aExpirationCycle
const
char
*
aName
)
:
nsExpirationTracker
(
aExpirationCycle
aName
)
{
}
virtual
void
NotifyExpired
(
ActiveResource
*
aResource
)
override
{
RemoveObject
(
aResource
)
;
aResource
-
>
NotifyInactive
(
)
;
}
}
;
class
ShadowLayerForwarder
final
:
public
LayersIPCActor
public
CompositableForwarder
public
LegacySurfaceDescriptorAllocator
{
friend
class
ClientLayerManager
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ShadowLayerForwarder
override
)
;
void
Connect
(
CompositableClient
*
aCompositable
ImageContainer
*
aImageContainer
)
override
;
void
Attach
(
CompositableClient
*
aCompositable
ShadowableLayer
*
aLayer
)
;
void
AttachAsyncCompositable
(
uint64_t
aCompositableID
ShadowableLayer
*
aLayer
)
;
void
BeginTransaction
(
const
gfx
:
:
IntRect
&
aTargetBounds
ScreenRotation
aRotation
mozilla
:
:
dom
:
:
ScreenOrientationInternal
aOrientation
)
;
void
CreatedPaintedLayer
(
ShadowableLayer
*
aThebes
)
;
void
CreatedContainerLayer
(
ShadowableLayer
*
aContainer
)
;
void
CreatedImageLayer
(
ShadowableLayer
*
aImage
)
;
void
CreatedColorLayer
(
ShadowableLayer
*
aColor
)
;
void
CreatedCanvasLayer
(
ShadowableLayer
*
aCanvas
)
;
void
CreatedRefLayer
(
ShadowableLayer
*
aRef
)
;
void
Mutated
(
ShadowableLayer
*
aMutant
)
;
void
SetRoot
(
ShadowableLayer
*
aRoot
)
;
void
InsertAfter
(
ShadowableLayer
*
aContainer
ShadowableLayer
*
aChild
ShadowableLayer
*
aAfter
=
nullptr
)
;
void
RemoveChild
(
ShadowableLayer
*
aContainer
ShadowableLayer
*
aChild
)
;
void
RepositionChild
(
ShadowableLayer
*
aContainer
ShadowableLayer
*
aChild
ShadowableLayer
*
aAfter
=
nullptr
)
;
void
SetMask
(
ShadowableLayer
*
aLayer
ShadowableLayer
*
aMaskLayer
)
;
void
UseTiledLayerBuffer
(
CompositableClient
*
aCompositable
const
SurfaceDescriptorTiles
&
aTileLayerDescriptor
)
override
;
bool
DestroyInTransaction
(
PTextureChild
*
aTexture
bool
synchronously
)
override
;
bool
DestroyInTransaction
(
PCompositableChild
*
aCompositable
bool
synchronously
)
override
;
virtual
void
RemoveTextureFromCompositable
(
CompositableClient
*
aCompositable
TextureClient
*
aTexture
)
override
;
virtual
void
RemoveTextureFromCompositableAsync
(
AsyncTransactionTracker
*
aAsyncTransactionTracker
CompositableClient
*
aCompositable
TextureClient
*
aTexture
)
override
;
virtual
void
UpdateTextureRegion
(
CompositableClient
*
aCompositable
const
ThebesBufferData
&
aThebesBufferData
const
nsIntRegion
&
aUpdatedRegion
)
override
;
virtual
void
UseTextures
(
CompositableClient
*
aCompositable
const
nsTArray
<
TimedTextureClient
>
&
aTextures
)
override
;
virtual
void
UseComponentAlphaTextures
(
CompositableClient
*
aCompositable
TextureClient
*
aClientOnBlack
TextureClient
*
aClientOnWhite
)
override
;
void
SendPaintTime
(
uint64_t
aId
TimeDuration
aPaintTime
)
;
bool
EndTransaction
(
InfallibleTArray
<
EditReply
>
*
aReplies
const
nsIntRegion
&
aRegionToClear
uint64_t
aId
bool
aScheduleComposite
uint32_t
aPaintSequenceNumber
bool
aIsRepeatTransaction
const
mozilla
:
:
TimeStamp
&
aTransactionStart
bool
*
aSent
)
;
void
SetShadowManager
(
PLayerTransactionChild
*
aShadowManager
)
;
void
StorePluginWidgetConfigurations
(
const
nsTArray
<
nsIWidget
:
:
Configuration
>
&
aConfigurations
)
;
void
StopReceiveAsyncParentMessge
(
)
;
void
ClearCachedResources
(
)
;
void
Composite
(
)
;
bool
HasShadowManager
(
)
const
{
return
!
!
mShadowManager
;
}
LayerTransactionChild
*
GetShadowManager
(
)
const
{
return
mShadowManager
.
get
(
)
;
}
virtual
void
WindowOverlayChanged
(
)
{
mWindowOverlayChanged
=
true
;
}
virtual
bool
IPCOpen
(
)
const
override
;
PLayerChild
*
ConstructShadowFor
(
ShadowableLayer
*
aLayer
)
;
void
SetIsFirstPaint
(
)
{
mIsFirstPaint
=
true
;
}
void
SetPaintSyncId
(
int32_t
aSyncId
)
{
mPaintSyncId
=
aSyncId
;
}
void
SetLayerObserverEpoch
(
uint64_t
aLayerObserverEpoch
)
;
static
void
PlatformSyncBeforeUpdate
(
)
;
virtual
bool
AllocSurfaceDescriptor
(
const
gfx
:
:
IntSize
&
aSize
gfxContentType
aContent
SurfaceDescriptor
*
aBuffer
)
override
;
virtual
bool
AllocSurfaceDescriptorWithCaps
(
const
gfx
:
:
IntSize
&
aSize
gfxContentType
aContent
uint32_t
aCaps
SurfaceDescriptor
*
aBuffer
)
override
;
virtual
void
DestroySurfaceDescriptor
(
SurfaceDescriptor
*
aSurface
)
override
;
virtual
void
UpdateFwdTransactionId
(
)
override
;
virtual
uint64_t
GetFwdTransactionId
(
)
override
;
bool
InForwarderThread
(
)
override
{
return
NS_IsMainThread
(
)
;
}
static
bool
IsShmem
(
SurfaceDescriptor
*
aSurface
)
;
TextureForwarder
*
GetTextureForwarder
(
)
override
{
return
GetCompositorBridgeChild
(
)
;
}
LayersIPCActor
*
GetLayersIPCActor
(
)
override
{
return
this
;
}
ActiveResourceTracker
&
GetActiveResourceTracker
(
)
{
return
*
mActiveResourceTracker
.
get
(
)
;
}
protected
:
virtual
~
ShadowLayerForwarder
(
)
;
explicit
ShadowLayerForwarder
(
ClientLayerManager
*
aClientLayerManager
)
;
#
ifdef
DEBUG
void
CheckSurfaceDescriptor
(
const
SurfaceDescriptor
*
aDescriptor
)
const
;
#
else
void
CheckSurfaceDescriptor
(
const
SurfaceDescriptor
*
aDescriptor
)
const
{
}
#
endif
bool
InWorkerThread
(
)
;
CompositorBridgeChild
*
GetCompositorBridgeChild
(
)
;
RefPtr
<
LayerTransactionChild
>
mShadowManager
;
RefPtr
<
CompositorBridgeChild
>
mCompositorBridgeChild
;
private
:
ClientLayerManager
*
mClientLayerManager
;
Transaction
*
mTxn
;
MessageLoop
*
mMessageLoop
;
DiagnosticTypes
mDiagnosticTypes
;
bool
mIsFirstPaint
;
bool
mWindowOverlayChanged
;
int32_t
mPaintSyncId
;
InfallibleTArray
<
PluginWindowData
>
mPluginWindowData
;
UniquePtr
<
ActiveResourceTracker
>
mActiveResourceTracker
;
}
;
class
CompositableClient
;
class
ShadowableLayer
{
public
:
virtual
~
ShadowableLayer
(
)
{
}
virtual
Layer
*
AsLayer
(
)
=
0
;
bool
HasShadow
(
)
{
return
!
!
mShadow
;
}
PLayerChild
*
GetShadow
(
)
{
return
mShadow
;
}
virtual
CompositableClient
*
GetCompositableClient
(
)
{
return
nullptr
;
}
protected
:
ShadowableLayer
(
)
:
mShadow
(
nullptr
)
{
}
PLayerChild
*
mShadow
;
}
;
}
}
#
endif
