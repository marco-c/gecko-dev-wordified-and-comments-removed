#
ifndef
mozilla_layers_ShadowLayers_h
#
define
mozilla_layers_ShadowLayers_h
1
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
gfxTypes
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
WidgetUtils
.
h
"
#
include
"
mozilla
/
dom
/
ScreenOrientation
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemory
.
h
"
#
include
"
mozilla
/
layers
/
CompositableForwarder
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
<
vector
>
namespace
mozilla
{
namespace
layers
{
class
ClientLayerManager
;
class
CompositorBridgeChild
;
class
EditReply
;
class
FixedSizeSmallShmemSectionAllocator
;
class
ImageContainer
;
class
Layer
;
class
PLayerChild
;
class
PLayerTransactionChild
;
class
LayerTransactionChild
;
class
ShadowableLayer
;
class
SurfaceDescriptor
;
class
TextureClient
;
class
ThebesBuffer
;
class
ThebesBufferData
;
class
Transaction
;
class
ShadowLayerForwarder
final
:
public
CompositableForwarder
public
ShmemAllocator
public
LegacySurfaceDescriptorAllocator
{
friend
class
ClientLayerManager
;
public
:
virtual
~
ShadowLayerForwarder
(
)
;
virtual
ShmemAllocator
*
AsShmemAllocator
(
)
override
{
return
this
;
}
virtual
ShadowLayerForwarder
*
AsLayerForwarder
(
)
override
{
return
this
;
}
virtual
LegacySurfaceDescriptorAllocator
*
AsLegacySurfaceDescriptorAllocator
(
)
override
{
return
this
;
}
FixedSizeSmallShmemSectionAllocator
*
GetTileLockAllocator
(
)
;
virtual
void
Connect
(
CompositableClient
*
aCompositable
ImageContainer
*
aImageContainer
)
override
;
virtual
PTextureChild
*
CreateTexture
(
const
SurfaceDescriptor
&
aSharedData
LayersBackend
aLayersBackend
TextureFlags
aFlags
uint64_t
aSerial
)
override
;
void
Attach
(
CompositableClient
*
aCompositable
ShadowableLayer
*
aLayer
)
;
void
AttachAsyncCompositable
(
uint64_t
aCompositableID
ShadowableLayer
*
aLayer
)
;
void
BeginTransaction
(
const
gfx
:
:
IntRect
&
aTargetBounds
ScreenRotation
aRotation
mozilla
:
:
dom
:
:
ScreenOrientationInternal
aOrientation
)
;
void
CreatedPaintedLayer
(
ShadowableLayer
*
aThebes
)
;
void
CreatedContainerLayer
(
ShadowableLayer
*
aContainer
)
;
void
CreatedImageLayer
(
ShadowableLayer
*
aImage
)
;
void
CreatedColorLayer
(
ShadowableLayer
*
aColor
)
;
void
CreatedCanvasLayer
(
ShadowableLayer
*
aCanvas
)
;
void
CreatedRefLayer
(
ShadowableLayer
*
aRef
)
;
void
Mutated
(
ShadowableLayer
*
aMutant
)
;
void
SetRoot
(
ShadowableLayer
*
aRoot
)
;
void
InsertAfter
(
ShadowableLayer
*
aContainer
ShadowableLayer
*
aChild
ShadowableLayer
*
aAfter
=
nullptr
)
;
void
RemoveChild
(
ShadowableLayer
*
aContainer
ShadowableLayer
*
aChild
)
;
void
RepositionChild
(
ShadowableLayer
*
aContainer
ShadowableLayer
*
aChild
ShadowableLayer
*
aAfter
=
nullptr
)
;
void
SetMask
(
ShadowableLayer
*
aLayer
ShadowableLayer
*
aMaskLayer
)
;
virtual
void
UseTiledLayerBuffer
(
CompositableClient
*
aCompositable
const
SurfaceDescriptorTiles
&
aTileLayerDescriptor
)
override
;
virtual
bool
DestroyInTransaction
(
PTextureChild
*
aTexture
bool
synchronously
)
override
;
virtual
bool
DestroyInTransaction
(
PCompositableChild
*
aCompositable
bool
synchronously
)
override
;
virtual
void
RemoveTextureFromCompositable
(
CompositableClient
*
aCompositable
TextureClient
*
aTexture
)
override
;
virtual
void
RemoveTextureFromCompositableAsync
(
AsyncTransactionTracker
*
aAsyncTransactionTracker
CompositableClient
*
aCompositable
TextureClient
*
aTexture
)
override
;
virtual
void
UpdateTextureRegion
(
CompositableClient
*
aCompositable
const
ThebesBufferData
&
aThebesBufferData
const
nsIntRegion
&
aUpdatedRegion
)
override
;
virtual
void
UseTextures
(
CompositableClient
*
aCompositable
const
nsTArray
<
TimedTextureClient
>
&
aTextures
)
override
;
virtual
void
UseComponentAlphaTextures
(
CompositableClient
*
aCompositable
TextureClient
*
aClientOnBlack
TextureClient
*
aClientOnWhite
)
override
;
#
ifdef
MOZ_WIDGET_GONK
virtual
void
UseOverlaySource
(
CompositableClient
*
aCompositable
const
OverlaySource
&
aOverlay
const
nsIntRect
&
aPictureRect
)
override
;
#
endif
bool
EndTransaction
(
InfallibleTArray
<
EditReply
>
*
aReplies
const
nsIntRegion
&
aRegionToClear
uint64_t
aId
bool
aScheduleComposite
uint32_t
aPaintSequenceNumber
bool
aIsRepeatTransaction
const
mozilla
:
:
TimeStamp
&
aTransactionStart
bool
*
aSent
)
;
void
SetShadowManager
(
PLayerTransactionChild
*
aShadowManager
)
;
void
StorePluginWidgetConfigurations
(
const
nsTArray
<
nsIWidget
:
:
Configuration
>
&
aConfigurations
)
;
void
StopReceiveAsyncParentMessge
(
)
;
void
ClearCachedResources
(
)
;
void
Composite
(
)
;
bool
HasShadowManager
(
)
const
{
return
!
!
mShadowManager
;
}
LayerTransactionChild
*
GetShadowManager
(
)
const
{
return
mShadowManager
.
get
(
)
;
}
virtual
void
WindowOverlayChanged
(
)
{
mWindowOverlayChanged
=
true
;
}
virtual
bool
AllocUnsafeShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
override
;
virtual
bool
AllocShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
override
;
virtual
void
DeallocShmem
(
mozilla
:
:
ipc
:
:
Shmem
&
aShmem
)
override
;
virtual
bool
IPCOpen
(
)
const
override
;
virtual
bool
IsSameProcess
(
)
const
override
;
virtual
MessageLoop
*
GetMessageLoop
(
)
const
override
{
return
mMessageLoop
;
}
virtual
void
CancelWaitForRecycle
(
uint64_t
aTextureId
)
override
;
base
:
:
ProcessId
GetParentPid
(
)
const
;
PLayerChild
*
ConstructShadowFor
(
ShadowableLayer
*
aLayer
)
;
void
SetIsFirstPaint
(
)
{
mIsFirstPaint
=
true
;
}
void
SetPaintSyncId
(
int32_t
aSyncId
)
{
mPaintSyncId
=
aSyncId
;
}
static
void
PlatformSyncBeforeUpdate
(
)
;
virtual
bool
AllocSurfaceDescriptor
(
const
gfx
:
:
IntSize
&
aSize
gfxContentType
aContent
SurfaceDescriptor
*
aBuffer
)
override
;
virtual
bool
AllocSurfaceDescriptorWithCaps
(
const
gfx
:
:
IntSize
&
aSize
gfxContentType
aContent
uint32_t
aCaps
SurfaceDescriptor
*
aBuffer
)
override
;
virtual
void
DestroySurfaceDescriptor
(
SurfaceDescriptor
*
aSurface
)
override
;
virtual
void
UpdateFwdTransactionId
(
)
override
;
virtual
uint64_t
GetFwdTransactionId
(
)
override
;
static
bool
IsShmem
(
SurfaceDescriptor
*
aSurface
)
;
protected
:
explicit
ShadowLayerForwarder
(
ClientLayerManager
*
aClientLayerManager
)
;
#
ifdef
DEBUG
void
CheckSurfaceDescriptor
(
const
SurfaceDescriptor
*
aDescriptor
)
const
;
#
else
void
CheckSurfaceDescriptor
(
const
SurfaceDescriptor
*
aDescriptor
)
const
{
}
#
endif
bool
InWorkerThread
(
)
;
CompositorBridgeChild
*
GetCompositorBridgeChild
(
)
;
RefPtr
<
LayerTransactionChild
>
mShadowManager
;
RefPtr
<
CompositorBridgeChild
>
mCompositorBridgeChild
;
private
:
ClientLayerManager
*
mClientLayerManager
;
Transaction
*
mTxn
;
MessageLoop
*
mMessageLoop
;
DiagnosticTypes
mDiagnosticTypes
;
bool
mIsFirstPaint
;
bool
mWindowOverlayChanged
;
int32_t
mPaintSyncId
;
InfallibleTArray
<
PluginWindowData
>
mPluginWindowData
;
FixedSizeSmallShmemSectionAllocator
*
mSectionAllocator
;
}
;
class
CompositableClient
;
class
ShadowableLayer
{
public
:
virtual
~
ShadowableLayer
(
)
{
}
virtual
Layer
*
AsLayer
(
)
=
0
;
bool
HasShadow
(
)
{
return
!
!
mShadow
;
}
PLayerChild
*
GetShadow
(
)
{
return
mShadow
;
}
virtual
CompositableClient
*
GetCompositableClient
(
)
{
return
nullptr
;
}
protected
:
ShadowableLayer
(
)
:
mShadow
(
nullptr
)
{
}
PLayerChild
*
mShadow
;
}
;
class
FixedSizeSmallShmemSectionAllocator
final
:
public
ShmemSectionAllocator
{
public
:
enum
AllocationStatus
{
STATUS_ALLOCATED
STATUS_FREED
}
;
struct
ShmemSectionHeapHeader
{
Atomic
<
uint32_t
>
mTotalBlocks
;
Atomic
<
uint32_t
>
mAllocatedBlocks
;
}
;
struct
ShmemSectionHeapAllocation
{
Atomic
<
uint32_t
>
mStatus
;
uint32_t
mSize
;
}
;
explicit
FixedSizeSmallShmemSectionAllocator
(
ClientIPCAllocator
*
aShmProvider
)
;
~
FixedSizeSmallShmemSectionAllocator
(
)
;
virtual
bool
AllocShmemSection
(
uint32_t
aSize
ShmemSection
*
aShmemSection
)
override
;
virtual
void
DeallocShmemSection
(
ShmemSection
&
aShmemSection
)
override
;
virtual
void
MemoryPressure
(
)
override
{
ShrinkShmemSectionHeap
(
)
;
}
static
void
FreeShmemSection
(
ShmemSection
&
aShmemSection
)
;
void
ShrinkShmemSectionHeap
(
)
;
ShmemAllocator
*
GetShmAllocator
(
)
{
return
mShmProvider
-
>
AsShmemAllocator
(
)
;
}
bool
IPCOpen
(
)
const
{
return
mShmProvider
-
>
IPCOpen
(
)
;
}
protected
:
std
:
:
vector
<
mozilla
:
:
ipc
:
:
Shmem
>
mUsedShmems
;
ClientIPCAllocator
*
mShmProvider
;
}
;
}
}
#
endif
