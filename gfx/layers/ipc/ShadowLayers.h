#
ifndef
mozilla_layers_ShadowLayers_h
#
define
mozilla_layers_ShadowLayers_h
1
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
gfxTypes
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
WidgetUtils
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemory
.
h
"
#
include
"
mozilla
/
HalScreenConfiguration
.
h
"
#
include
"
mozilla
/
layers
/
CompositableForwarder
.
h
"
#
include
"
mozilla
/
layers
/
FocusTarget
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
TextureForwarder
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
<
vector
>
namespace
mozilla
{
namespace
layers
{
class
ClientLayerManager
;
class
CompositorBridgeChild
;
class
FixedSizeSmallShmemSectionAllocator
;
class
ImageContainer
;
class
Layer
;
class
PLayerTransactionChild
;
class
LayerTransactionChild
;
class
ShadowableLayer
;
class
SurfaceDescriptor
;
class
TextureClient
;
class
ThebesBuffer
;
class
ThebesBufferData
;
class
Transaction
;
class
ShadowLayerForwarder
final
:
public
LayersIPCActor
public
CompositableForwarder
public
LegacySurfaceDescriptorAllocator
{
friend
class
ClientLayerManager
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ShadowLayerForwarder
override
)
;
void
Connect
(
CompositableClient
*
aCompositable
ImageContainer
*
aImageContainer
)
override
;
void
Attach
(
CompositableClient
*
aCompositable
ShadowableLayer
*
aLayer
)
;
void
AttachAsyncCompositable
(
const
CompositableHandle
&
aHandle
ShadowableLayer
*
aLayer
)
;
void
BeginTransaction
(
const
gfx
:
:
IntRect
&
aTargetBounds
ScreenRotation
aRotation
hal
:
:
ScreenOrientation
aOrientation
)
;
void
CreatedPaintedLayer
(
ShadowableLayer
*
aThebes
)
;
void
CreatedContainerLayer
(
ShadowableLayer
*
aContainer
)
;
void
CreatedImageLayer
(
ShadowableLayer
*
aImage
)
;
void
CreatedColorLayer
(
ShadowableLayer
*
aColor
)
;
void
CreatedCanvasLayer
(
ShadowableLayer
*
aCanvas
)
;
void
CreatedRefLayer
(
ShadowableLayer
*
aRef
)
;
void
Mutated
(
ShadowableLayer
*
aMutant
)
;
void
MutatedSimple
(
ShadowableLayer
*
aMutant
)
;
void
SetRoot
(
ShadowableLayer
*
aRoot
)
;
void
InsertAfter
(
ShadowableLayer
*
aContainer
ShadowableLayer
*
aChild
ShadowableLayer
*
aAfter
=
nullptr
)
;
void
RemoveChild
(
ShadowableLayer
*
aContainer
ShadowableLayer
*
aChild
)
;
void
RepositionChild
(
ShadowableLayer
*
aContainer
ShadowableLayer
*
aChild
ShadowableLayer
*
aAfter
=
nullptr
)
;
void
SetMask
(
ShadowableLayer
*
aLayer
ShadowableLayer
*
aMaskLayer
)
;
void
UseTiledLayerBuffer
(
CompositableClient
*
aCompositable
const
SurfaceDescriptorTiles
&
aTileLayerDescriptor
)
override
;
void
ReleaseCompositable
(
const
CompositableHandle
&
aHandle
)
override
;
bool
DestroyInTransaction
(
PTextureChild
*
aTexture
)
override
;
bool
DestroyInTransaction
(
const
CompositableHandle
&
aHandle
)
;
virtual
void
RemoveTextureFromCompositable
(
CompositableClient
*
aCompositable
TextureClient
*
aTexture
)
override
;
virtual
void
UpdateTextureRegion
(
CompositableClient
*
aCompositable
const
ThebesBufferData
&
aThebesBufferData
const
nsIntRegion
&
aUpdatedRegion
)
override
;
virtual
void
UseTextures
(
CompositableClient
*
aCompositable
const
nsTArray
<
TimedTextureClient
>
&
aTextures
)
override
;
virtual
void
UseComponentAlphaTextures
(
CompositableClient
*
aCompositable
TextureClient
*
aClientOnBlack
TextureClient
*
aClientOnWhite
)
override
;
void
SendPaintTime
(
TransactionId
aId
TimeDuration
aPaintTime
)
;
bool
EndTransaction
(
const
nsIntRegion
&
aRegionToClear
TransactionId
aId
bool
aScheduleComposite
uint32_t
aPaintSequenceNumber
bool
aIsRepeatTransaction
const
mozilla
:
:
VsyncId
&
aVsyncId
const
mozilla
:
:
TimeStamp
&
aVsyncTime
const
mozilla
:
:
TimeStamp
&
aRefreshStart
const
mozilla
:
:
TimeStamp
&
aTransactionStart
bool
aContainsSVG
const
nsCString
&
aURL
bool
*
aSent
const
InfallibleTArray
<
CompositionPayload
>
&
aPayload
=
InfallibleTArray
<
CompositionPayload
>
(
)
)
;
void
SetShadowManager
(
PLayerTransactionChild
*
aShadowManager
)
;
void
StorePluginWidgetConfigurations
(
const
nsTArray
<
nsIWidget
:
:
Configuration
>
&
aConfigurations
)
;
void
StopReceiveAsyncParentMessge
(
)
;
void
ClearCachedResources
(
)
;
void
ScheduleComposite
(
)
;
bool
HasShadowManager
(
)
const
{
return
!
!
mShadowManager
;
}
LayerTransactionChild
*
GetShadowManager
(
)
const
{
return
mShadowManager
.
get
(
)
;
}
void
SynchronouslyShutdown
(
)
;
virtual
void
WindowOverlayChanged
(
)
{
mWindowOverlayChanged
=
true
;
}
virtual
bool
IPCOpen
(
)
const
override
;
LayerHandle
ConstructShadowFor
(
ShadowableLayer
*
aLayer
)
;
void
SetIsFirstPaint
(
)
{
mIsFirstPaint
=
true
;
}
bool
GetIsFirstPaint
(
)
const
{
return
mIsFirstPaint
;
}
void
SetFocusTarget
(
const
FocusTarget
&
aFocusTarget
)
{
mFocusTarget
=
aFocusTarget
;
}
void
SetLayersObserverEpoch
(
LayersObserverEpoch
aEpoch
)
;
static
void
PlatformSyncBeforeUpdate
(
)
;
virtual
bool
AllocSurfaceDescriptor
(
const
gfx
:
:
IntSize
&
aSize
gfxContentType
aContent
SurfaceDescriptor
*
aBuffer
)
override
;
virtual
bool
AllocSurfaceDescriptorWithCaps
(
const
gfx
:
:
IntSize
&
aSize
gfxContentType
aContent
uint32_t
aCaps
SurfaceDescriptor
*
aBuffer
)
override
;
virtual
void
DestroySurfaceDescriptor
(
SurfaceDescriptor
*
aSurface
)
override
;
virtual
void
UpdateFwdTransactionId
(
)
override
;
virtual
uint64_t
GetFwdTransactionId
(
)
override
;
void
UpdateTextureLocks
(
)
;
void
SyncTextures
(
const
nsTArray
<
uint64_t
>
&
aSerials
)
;
void
ReleaseLayer
(
const
LayerHandle
&
aHandle
)
;
bool
InForwarderThread
(
)
override
{
return
NS_IsMainThread
(
)
;
}
PaintTiming
&
GetPaintTiming
(
)
{
return
mPaintTiming
;
}
ShadowLayerForwarder
*
AsLayerForwarder
(
)
override
{
return
this
;
}
static
bool
IsShmem
(
SurfaceDescriptor
*
aSurface
)
;
void
SyncWithCompositor
(
)
override
;
TextureForwarder
*
GetTextureForwarder
(
)
override
{
return
GetCompositorBridgeChild
(
)
;
}
LayersIPCActor
*
GetLayersIPCActor
(
)
override
{
return
this
;
}
ActiveResourceTracker
*
GetActiveResourceTracker
(
)
override
{
return
mActiveResourceTracker
.
get
(
)
;
}
CompositorBridgeChild
*
GetCompositorBridgeChild
(
)
;
nsIEventTarget
*
GetEventTarget
(
)
{
return
mEventTarget
;
}
;
virtual
bool
IsThreadSafe
(
)
const
override
{
return
false
;
}
virtual
RefPtr
<
KnowsCompositor
>
GetForMedia
(
)
override
;
protected
:
virtual
~
ShadowLayerForwarder
(
)
;
explicit
ShadowLayerForwarder
(
ClientLayerManager
*
aClientLayerManager
)
;
#
ifdef
DEBUG
void
CheckSurfaceDescriptor
(
const
SurfaceDescriptor
*
aDescriptor
)
const
;
#
else
void
CheckSurfaceDescriptor
(
const
SurfaceDescriptor
*
aDescriptor
)
const
{
}
#
endif
RefPtr
<
CompositableClient
>
FindCompositable
(
const
CompositableHandle
&
aHandle
)
;
bool
InWorkerThread
(
)
;
RefPtr
<
LayerTransactionChild
>
mShadowManager
;
RefPtr
<
CompositorBridgeChild
>
mCompositorBridgeChild
;
private
:
ClientLayerManager
*
mClientLayerManager
;
Transaction
*
mTxn
;
MessageLoop
*
mMessageLoop
;
DiagnosticTypes
mDiagnosticTypes
;
bool
mIsFirstPaint
;
FocusTarget
mFocusTarget
;
bool
mWindowOverlayChanged
;
InfallibleTArray
<
PluginWindowData
>
mPluginWindowData
;
UniquePtr
<
ActiveResourceTracker
>
mActiveResourceTracker
;
uint64_t
mNextLayerHandle
;
nsDataHashtable
<
nsUint64HashKey
CompositableClient
*
>
mCompositables
;
PaintTiming
mPaintTiming
;
nsCOMPtr
<
nsIEventTarget
>
mEventTarget
;
}
;
class
CompositableClient
;
class
ShadowableLayer
{
public
:
virtual
~
ShadowableLayer
(
)
;
virtual
Layer
*
AsLayer
(
)
=
0
;
bool
HasShadow
(
)
{
return
mShadow
.
IsValid
(
)
;
}
const
LayerHandle
&
GetShadow
(
)
{
return
mShadow
;
}
void
SetShadow
(
ShadowLayerForwarder
*
aForwarder
const
LayerHandle
&
aShadow
)
{
MOZ_ASSERT
(
!
mShadow
"
can
'
t
have
two
shadows
(
yet
)
"
)
;
mForwarder
=
aForwarder
;
mShadow
=
aShadow
;
}
virtual
CompositableClient
*
GetCompositableClient
(
)
{
return
nullptr
;
}
protected
:
ShadowableLayer
(
)
{
}
private
:
RefPtr
<
ShadowLayerForwarder
>
mForwarder
;
LayerHandle
mShadow
;
}
;
}
}
#
endif
