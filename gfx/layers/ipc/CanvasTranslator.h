#
ifndef
mozilla_layers_CanvasTranslator_h
#
define
mozilla_layers_CanvasTranslator_h
#
include
<
deque
>
#
include
<
unordered_map
>
#
include
<
vector
>
#
include
"
mozilla
/
dom
/
ipc
/
IdType
.
h
"
#
include
"
mozilla
/
gfx
/
InlineTranslator
.
h
"
#
include
"
mozilla
/
gfx
/
RecordedEvent
.
h
"
#
include
"
CanvasChild
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemoryHandle
.
h
"
#
include
"
mozilla
/
layers
/
CanvasDrawEventRecorder
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
PCanvasParent
.
h
"
#
include
"
mozilla
/
layers
/
RemoteTextureMap
.
h
"
#
include
"
mozilla
/
ipc
/
CrossProcessSemaphore
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemoryMapping
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
namespace
mozilla
{
using
EventType
=
gfx
:
:
RecordedEvent
:
:
EventType
;
class
TaskQueue
;
namespace
gfx
{
class
DataSourceSurfaceWrapper
;
class
DrawTargetWebgl
;
class
SharedContextWebgl
;
}
namespace
layers
{
class
SharedSurfacesHolder
;
class
TextureData
;
class
TextureHost
;
class
VideoProcessorD3D11
;
class
CanvasTranslator
final
:
public
gfx
:
:
InlineTranslator
public
PCanvasParent
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
CanvasTranslator
)
friend
class
PProtocolParent
;
CanvasTranslator
(
layers
:
:
SharedSurfacesHolder
*
aSharedSurfacesHolder
const
dom
:
:
ContentParentId
&
aContentId
uint32_t
aManagerId
)
;
const
dom
:
:
ContentParentId
&
GetContentId
(
)
const
{
return
mContentId
;
}
uint32_t
GetManagerId
(
)
const
{
return
mManagerId
;
}
void
DispatchToTaskQueue
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
;
bool
IsInTaskQueue
(
)
const
;
ipc
:
:
IPCResult
RecvInitTranslator
(
TextureType
aTextureType
TextureType
aWebglTextureType
gfx
:
:
BackendType
aBackendType
ipc
:
:
MutableSharedMemoryHandle
&
&
aReadHandle
nsTArray
<
ipc
:
:
ReadOnlySharedMemoryHandle
>
&
&
aBufferHandles
CrossProcessSemaphoreHandle
&
&
aReaderSem
CrossProcessSemaphoreHandle
&
&
aWriterSem
)
;
ipc
:
:
IPCResult
RecvRestartTranslation
(
)
;
ipc
:
:
IPCResult
RecvAddBuffer
(
ipc
:
:
ReadOnlySharedMemoryHandle
&
&
aBufferHandle
)
;
ipc
:
:
IPCResult
RecvSetDataSurfaceBuffer
(
ipc
:
:
MutableSharedMemoryHandle
&
&
aBufferHandle
)
;
ipc
:
:
IPCResult
RecvClearCachedResources
(
)
;
ipc
:
:
IPCResult
RecvDropFreeBuffersWhenDormant
(
)
;
void
ActorDestroy
(
ActorDestroyReason
why
)
final
;
void
CheckAndSignalWriter
(
)
;
bool
TranslateRecording
(
)
;
void
BeginTransaction
(
)
;
void
EndTransaction
(
)
;
void
Flush
(
)
;
void
DeviceChangeAcknowledged
(
)
;
void
DeviceResetAcknowledged
(
)
;
already_AddRefed
<
gfx
:
:
DrawTarget
>
CreateDrawTarget
(
gfx
:
:
ReferencePtr
aRefPtr
RemoteTextureOwnerId
aTextureOwnerId
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
)
;
already_AddRefed
<
gfx
:
:
DrawTarget
>
CreateDrawTarget
(
gfx
:
:
ReferencePtr
aRefPtr
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
)
final
;
already_AddRefed
<
gfx
:
:
GradientStops
>
GetOrCreateGradientStops
(
gfx
:
:
DrawTarget
*
aDrawTarget
gfx
:
:
GradientStop
*
aRawStops
uint32_t
aNumStops
gfx
:
:
ExtendMode
aExtendMode
)
final
;
void
CheckpointReached
(
)
;
void
PauseTranslation
(
)
;
void
RemoveTexture
(
const
RemoteTextureOwnerId
aTextureOwnerId
RemoteTextureTxnType
aTxnType
=
0
RemoteTextureTxnId
aTxnId
=
0
)
;
bool
LockTexture
(
const
RemoteTextureOwnerId
aTextureOwnerId
OpenMode
aMode
bool
aInvalidContents
=
false
)
;
bool
UnlockTexture
(
const
RemoteTextureOwnerId
aTextureOwnerId
)
;
bool
PresentTexture
(
const
RemoteTextureOwnerId
aTextureOwnerId
RemoteTextureId
aId
)
;
bool
PushRemoteTexture
(
const
RemoteTextureOwnerId
aTextureOwnerId
TextureData
*
aData
RemoteTextureId
aId
RemoteTextureOwnerId
aOwnerId
)
;
void
AddSourceSurface
(
gfx
:
:
ReferencePtr
aRefPtr
gfx
:
:
SourceSurface
*
aSurface
)
final
{
if
(
mMappedSurface
=
=
aRefPtr
)
{
mPreparedMap
=
nullptr
;
mMappedSurface
=
nullptr
;
}
RemoveDataSurface
(
aRefPtr
)
;
InlineTranslator
:
:
AddSourceSurface
(
aRefPtr
aSurface
)
;
}
void
RemoveSourceSurface
(
gfx
:
:
ReferencePtr
aRefPtr
)
final
{
if
(
mMappedSurface
=
=
aRefPtr
)
{
mPreparedMap
=
nullptr
;
mMappedSurface
=
nullptr
;
}
RemoveDataSurface
(
aRefPtr
)
;
InlineTranslator
:
:
RemoveSourceSurface
(
aRefPtr
)
;
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
LookupExternalSurface
(
uint64_t
aKey
)
final
;
already_AddRefed
<
gfx
:
:
SourceSurface
>
LookupSourceSurfaceFromSurfaceDescriptor
(
const
SurfaceDescriptor
&
aDesc
)
final
;
gfx
:
:
DataSourceSurface
*
LookupDataSurface
(
gfx
:
:
ReferencePtr
aRefPtr
)
;
void
AddDataSurface
(
gfx
:
:
ReferencePtr
aRefPtr
RefPtr
<
gfx
:
:
DataSourceSurface
>
&
&
aSurface
)
;
void
RemoveDataSurface
(
gfx
:
:
ReferencePtr
aRefPtr
)
;
void
SetPreparedMap
(
gfx
:
:
ReferencePtr
aSurface
UniquePtr
<
gfx
:
:
DataSourceSurface
:
:
ScopedMap
>
aMap
)
;
UniquePtr
<
gfx
:
:
DataSourceSurface
:
:
ScopedMap
>
GetPreparedMap
(
gfx
:
:
ReferencePtr
aSurface
)
;
void
PrepareShmem
(
const
RemoteTextureOwnerId
aTextureOwnerId
)
;
void
RecycleBuffer
(
)
;
void
NextBuffer
(
)
;
void
GetDataSurface
(
uint64_t
aSurfaceRef
)
;
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
WaitForSurface
(
uintptr_t
aId
)
;
static
void
Shutdown
(
)
;
private
:
~
CanvasTranslator
(
)
;
class
CanvasTranslatorEvent
{
public
:
enum
class
Tag
{
TranslateRecording
AddBuffer
SetDataSurfaceBuffer
ClearCachedResources
DropFreeBuffersWhenDormant
}
;
const
Tag
mTag
;
private
:
Variant
<
ipc
:
:
ReadOnlySharedMemoryHandle
ipc
:
:
MutableSharedMemoryHandle
>
mBufferHandle
;
public
:
explicit
CanvasTranslatorEvent
(
const
Tag
aTag
)
:
mTag
(
aTag
)
mBufferHandle
(
ipc
:
:
ReadOnlySharedMemoryHandle
(
)
)
{
MOZ_ASSERT
(
mTag
=
=
Tag
:
:
TranslateRecording
|
|
mTag
=
=
Tag
:
:
ClearCachedResources
|
|
mTag
=
=
Tag
:
:
DropFreeBuffersWhenDormant
)
;
}
CanvasTranslatorEvent
(
const
Tag
aTag
ipc
:
:
ReadOnlySharedMemoryHandle
&
&
aBufferHandle
)
:
mTag
(
aTag
)
mBufferHandle
(
std
:
:
move
(
aBufferHandle
)
)
{
MOZ_ASSERT
(
mTag
=
=
Tag
:
:
AddBuffer
)
;
}
CanvasTranslatorEvent
(
const
Tag
aTag
ipc
:
:
MutableSharedMemoryHandle
&
&
aBufferHandle
)
:
mTag
(
aTag
)
mBufferHandle
(
std
:
:
move
(
aBufferHandle
)
)
{
MOZ_ASSERT
(
mTag
=
=
Tag
:
:
SetDataSurfaceBuffer
)
;
}
static
UniquePtr
<
CanvasTranslatorEvent
>
TranslateRecording
(
)
{
return
MakeUnique
<
CanvasTranslatorEvent
>
(
Tag
:
:
TranslateRecording
)
;
}
static
UniquePtr
<
CanvasTranslatorEvent
>
AddBuffer
(
ipc
:
:
ReadOnlySharedMemoryHandle
&
&
aBufferHandle
)
{
return
MakeUnique
<
CanvasTranslatorEvent
>
(
Tag
:
:
AddBuffer
std
:
:
move
(
aBufferHandle
)
)
;
}
static
UniquePtr
<
CanvasTranslatorEvent
>
SetDataSurfaceBuffer
(
ipc
:
:
MutableSharedMemoryHandle
&
&
aBufferHandle
)
{
return
MakeUnique
<
CanvasTranslatorEvent
>
(
Tag
:
:
SetDataSurfaceBuffer
std
:
:
move
(
aBufferHandle
)
)
;
}
static
UniquePtr
<
CanvasTranslatorEvent
>
ClearCachedResources
(
)
{
return
MakeUnique
<
CanvasTranslatorEvent
>
(
Tag
:
:
ClearCachedResources
)
;
}
static
UniquePtr
<
CanvasTranslatorEvent
>
DropFreeBuffersWhenDormant
(
)
{
return
MakeUnique
<
CanvasTranslatorEvent
>
(
Tag
:
:
DropFreeBuffersWhenDormant
)
;
}
ipc
:
:
ReadOnlySharedMemoryHandle
TakeBufferHandle
(
)
{
if
(
mTag
=
=
Tag
:
:
AddBuffer
)
{
return
std
:
:
move
(
mBufferHandle
)
.
as
<
ipc
:
:
ReadOnlySharedMemoryHandle
>
(
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
to
be
called
"
)
;
return
nullptr
;
}
ipc
:
:
MutableSharedMemoryHandle
TakeDataSurfaceBufferHandle
(
)
{
if
(
mTag
=
=
Tag
:
:
SetDataSurfaceBuffer
)
{
return
std
:
:
move
(
mBufferHandle
)
.
as
<
ipc
:
:
MutableSharedMemoryHandle
>
(
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
to
be
called
"
)
;
return
nullptr
;
}
}
;
bool
AddBuffer
(
ipc
:
:
ReadOnlySharedMemoryHandle
&
&
aBufferHandle
)
;
bool
SetDataSurfaceBuffer
(
ipc
:
:
MutableSharedMemoryHandle
&
&
aBufferHandle
)
;
bool
ReadNextEvent
(
EventType
&
aEventType
)
;
bool
HasPendingEvent
(
)
;
bool
ReadPendingEvent
(
EventType
&
aEventType
)
;
bool
CheckDeactivated
(
)
;
void
Deactivate
(
)
;
bool
TryDrawTargetWebglFallback
(
const
RemoteTextureOwnerId
aTextureOwnerId
gfx
:
:
DrawTargetWebgl
*
aWebgl
)
;
void
ForceDrawTargetWebglFallback
(
)
;
void
BlockCanvas
(
)
;
UniquePtr
<
TextureData
>
CreateTextureData
(
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
bool
aClear
)
;
void
EnsureRemoteTextureOwner
(
RemoteTextureOwnerId
aOwnerId
=
RemoteTextureOwnerId
(
)
)
;
UniquePtr
<
TextureData
>
CreateOrRecycleTextureData
(
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
)
;
already_AddRefed
<
gfx
:
:
DrawTarget
>
CreateFallbackDrawTarget
(
gfx
:
:
ReferencePtr
aRefPtr
RemoteTextureOwnerId
aTextureOwnerId
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
)
;
void
ClearTextureInfo
(
)
;
bool
HandleExtensionEvent
(
int32_t
aType
)
;
bool
CreateReferenceTexture
(
)
;
bool
CheckForFreshCanvasDevice
(
int
aLineNumber
)
;
void
NotifyDeviceChanged
(
)
;
void
NotifyDeviceReset
(
const
RemoteTextureOwnerIdSet
&
aIds
)
;
bool
EnsureSharedContextWebgl
(
)
;
gfx
:
:
DrawTargetWebgl
*
GetDrawTargetWebgl
(
const
RemoteTextureOwnerId
aTextureOwnerId
bool
aCheckForFallback
=
true
)
const
;
void
NotifyRequiresRefresh
(
const
RemoteTextureOwnerId
aTextureOwnerId
bool
aDispatch
=
true
)
;
void
CacheSnapshotShmem
(
const
RemoteTextureOwnerId
aTextureOwnerId
bool
aDispatch
=
true
)
;
void
CacheDataSnapshots
(
)
;
void
ClearCachedResources
(
)
;
void
DropFreeBuffersWhenDormant
(
)
;
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
MaybeRecycleDataSurfaceForSurfaceDescriptor
(
TextureHost
*
aTextureHost
const
SurfaceDescriptorRemoteDecoder
&
aSurfaceDescriptor
)
;
bool
UsePendingCanvasTranslatorEvents
(
)
;
void
PostCanvasTranslatorEvents
(
const
MutexAutoLock
&
aProofOfLock
)
;
void
HandleCanvasTranslatorEvents
(
)
;
void
NotifyTextureDestruction
(
const
RemoteTextureOwnerId
aTextureOwnerId
)
;
const
RefPtr
<
TaskQueue
>
mTranslationTaskQueue
;
const
RefPtr
<
SharedSurfacesHolder
>
mSharedSurfacesHolder
;
#
if
defined
(
XP_WIN
)
RefPtr
<
ID3D11Device
>
mDevice
;
DataMutex
<
RefPtr
<
VideoProcessorD3D11
>
>
mVideoProcessorD3D11
;
#
endif
static
StaticRefPtr
<
gfx
:
:
SharedContextWebgl
>
sSharedContext
;
RefPtr
<
gfx
:
:
SharedContextWebgl
>
mSharedContext
;
RefPtr
<
RemoteTextureOwnerClient
>
mRemoteTextureOwner
;
size_t
mDefaultBufferSize
=
0
;
uint32_t
mMaxSpinCount
;
TimeDuration
mNextEventTimeout
;
using
State
=
CanvasDrawEventRecorder
:
:
State
;
using
Header
=
CanvasDrawEventRecorder
:
:
Header
;
ipc
:
:
SharedMemoryMapping
mHeaderShmem
;
Header
*
mHeader
=
nullptr
;
int64_t
mFlushCheckpoint
=
0
;
struct
CanvasShmem
{
ipc
:
:
ReadOnlySharedMemoryMapping
shmem
;
bool
IsValid
(
)
const
{
return
shmem
.
IsValid
(
)
;
}
auto
Size
(
)
{
return
shmem
?
shmem
.
Size
(
)
:
0
;
}
gfx
:
:
MemReader
CreateMemReader
(
)
{
if
(
!
shmem
)
{
return
{
nullptr
0
}
;
}
return
{
shmem
.
DataAs
<
char
>
(
)
Size
(
)
}
;
}
}
;
std
:
:
queue
<
CanvasShmem
>
mCanvasShmems
;
CanvasShmem
mCurrentShmem
;
gfx
:
:
MemReader
mCurrentMemReader
{
0
0
}
;
ipc
:
:
SharedMemoryMapping
mDataSurfaceShmem
;
UniquePtr
<
CrossProcessSemaphore
>
mWriterSemaphore
;
UniquePtr
<
CrossProcessSemaphore
>
mReaderSemaphore
;
TextureType
mTextureType
=
TextureType
:
:
Unknown
;
TextureType
mWebglTextureType
=
TextureType
:
:
Unknown
;
UniquePtr
<
TextureData
>
mReferenceTextureData
;
dom
:
:
ContentParentId
mContentId
;
uint32_t
mManagerId
;
gfx
:
:
BackendType
mBackendType
=
gfx
:
:
BackendType
:
:
NONE
;
base
:
:
ProcessId
mOtherPid
=
base
:
:
kInvalidProcessId
;
struct
TextureInfo
{
gfx
:
:
ReferencePtr
mRefPtr
;
UniquePtr
<
TextureData
>
mTextureData
;
RefPtr
<
gfx
:
:
DrawTarget
>
mDrawTarget
;
bool
mNotifiedRequiresRefresh
=
false
;
int32_t
mLocked
=
1
;
OpenMode
mTextureLockMode
=
OpenMode
:
:
OPEN_NONE
;
gfx
:
:
DrawTargetWebgl
*
GetDrawTargetWebgl
(
bool
aCheckForFallback
=
true
)
const
;
}
;
std
:
:
unordered_map
<
RemoteTextureOwnerId
TextureInfo
RemoteTextureOwnerId
:
:
HashFn
>
mTextureInfo
;
nsRefPtrHashtable
<
nsPtrHashKey
<
void
>
gfx
:
:
DataSourceSurface
>
mDataSurfaces
;
gfx
:
:
ReferencePtr
mMappedSurface
;
UniquePtr
<
gfx
:
:
DataSourceSurface
:
:
ScopedMap
>
mPreparedMap
;
Atomic
<
bool
>
mDeactivated
{
false
}
;
Atomic
<
bool
>
mBlocked
{
false
}
;
Atomic
<
bool
>
mIPDLClosed
{
false
}
;
bool
mIsInTransaction
=
false
;
bool
mDeviceResetInProgress
=
false
;
RefPtr
<
gfx
:
:
DataSourceSurface
>
mUsedDataSurfaceForSurfaceDescriptor
;
RefPtr
<
gfx
:
:
DataSourceSurfaceWrapper
>
mUsedWrapperForSurfaceDescriptor
;
Maybe
<
SurfaceDescriptorRemoteDecoder
>
mUsedSurfaceDescriptorForSurfaceDescriptor
;
Mutex
mCanvasTranslatorEventsLock
;
RefPtr
<
nsIRunnable
>
mCanvasTranslatorEventsRunnable
;
std
:
:
deque
<
UniquePtr
<
CanvasTranslatorEvent
>
>
mPendingCanvasTranslatorEvents
;
}
;
}
}
#
endif
