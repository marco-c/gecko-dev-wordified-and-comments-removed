#
ifndef
mozilla_layers_CanvasTranslator_h
#
define
mozilla_layers_CanvasTranslator_h
#
include
<
unordered_map
>
#
include
<
vector
>
#
include
"
mozilla
/
gfx
/
InlineTranslator
.
h
"
#
include
"
mozilla
/
layers
/
CanvasDrawEventRecorder
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
PCanvasParent
.
h
"
#
include
"
mozilla
/
layers
/
RemoteTextureMap
.
h
"
#
include
"
mozilla
/
ipc
/
CrossProcessSemaphore
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
namespace
mozilla
{
class
TaskQueue
;
namespace
gfx
{
class
DrawTargetWebgl
;
class
SharedContextWebgl
;
}
namespace
layers
{
class
TextureData
;
class
CanvasTranslator
final
:
public
gfx
:
:
InlineTranslator
public
PCanvasParent
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
CanvasTranslator
)
friend
class
PProtocolParent
;
CanvasTranslator
(
)
;
void
DispatchToTaskQueue
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
;
bool
IsInTaskQueue
(
)
const
;
ipc
:
:
IPCResult
RecvInitTranslator
(
const
TextureType
&
aTextureType
const
gfx
:
:
BackendType
&
aBackendType
ipc
:
:
SharedMemoryBasic
:
:
Handle
&
&
aReadHandle
CrossProcessSemaphoreHandle
&
&
aReaderSem
CrossProcessSemaphoreHandle
&
&
aWriterSem
const
bool
&
aUseIPDLThread
)
;
ipc
:
:
IPCResult
RecvNewBuffer
(
ipc
:
:
SharedMemoryBasic
:
:
Handle
&
&
aReadHandle
)
;
ipc
:
:
IPCResult
RecvResumeTranslation
(
)
;
void
ActorDestroy
(
ActorDestroyReason
why
)
final
;
bool
TranslateRecording
(
)
;
void
BeginTransaction
(
)
;
void
EndTransaction
(
)
;
void
Flush
(
)
;
void
DeviceChangeAcknowledged
(
)
;
void
ReturnWrite
(
const
uint8_t
*
aData
size_t
aSize
)
{
mStream
-
>
ReturnWrite
(
aData
aSize
)
;
}
void
SetNextTextureId
(
int64_t
aNextTextureId
RemoteTextureOwnerId
aOwnerId
)
{
mNextTextureId
=
aNextTextureId
;
mNextRemoteTextureOwnerId
=
aOwnerId
;
}
already_AddRefed
<
gfx
:
:
DrawTarget
>
CreateDrawTarget
(
gfx
:
:
ReferencePtr
aRefPtr
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
)
final
;
already_AddRefed
<
gfx
:
:
GradientStops
>
GetOrCreateGradientStops
(
gfx
:
:
GradientStop
*
aRawStops
uint32_t
aNumStops
gfx
:
:
ExtendMode
aExtendMode
)
final
;
TextureData
*
LookupTextureData
(
int64_t
aTextureId
)
;
void
RemoveTexture
(
int64_t
aTextureId
)
;
bool
LockTexture
(
int64_t
aTextureId
OpenMode
aMode
RemoteTextureId
aId
)
;
bool
UnlockTexture
(
int64_t
aTextureId
RemoteTextureId
aId
)
;
bool
PushRemoteTexture
(
TextureData
*
aData
RemoteTextureId
aId
RemoteTextureOwnerId
aOwnerId
)
;
void
AddSourceSurface
(
gfx
:
:
ReferencePtr
aRefPtr
gfx
:
:
SourceSurface
*
aSurface
)
final
{
if
(
mMappedSurface
=
=
aRefPtr
)
{
mPreparedMap
=
nullptr
;
mMappedSurface
=
nullptr
;
}
RemoveDataSurface
(
aRefPtr
)
;
InlineTranslator
:
:
AddSourceSurface
(
aRefPtr
aSurface
)
;
}
void
RemoveSourceSurface
(
gfx
:
:
ReferencePtr
aRefPtr
)
final
{
if
(
mMappedSurface
=
=
aRefPtr
)
{
mPreparedMap
=
nullptr
;
mMappedSurface
=
nullptr
;
}
RemoveDataSurface
(
aRefPtr
)
;
InlineTranslator
:
:
RemoveSourceSurface
(
aRefPtr
)
;
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
LookupExternalSurface
(
uint64_t
aKey
)
final
;
gfx
:
:
DataSourceSurface
*
LookupDataSurface
(
gfx
:
:
ReferencePtr
aRefPtr
)
;
void
AddDataSurface
(
gfx
:
:
ReferencePtr
aRefPtr
RefPtr
<
gfx
:
:
DataSourceSurface
>
&
&
aSurface
)
;
void
RemoveDataSurface
(
gfx
:
:
ReferencePtr
aRefPtr
)
;
void
SetPreparedMap
(
gfx
:
:
ReferencePtr
aSurface
UniquePtr
<
gfx
:
:
DataSourceSurface
:
:
ScopedMap
>
aMap
)
;
UniquePtr
<
gfx
:
:
DataSourceSurface
:
:
ScopedMap
>
GetPreparedMap
(
gfx
:
:
ReferencePtr
aSurface
)
;
void
PrepareShmem
(
int64_t
aTextureId
)
;
private
:
~
CanvasTranslator
(
)
;
void
Bind
(
Endpoint
<
PCanvasParent
>
&
&
aEndpoint
)
;
void
StartTranslation
(
)
;
void
FinishShutdown
(
)
;
bool
CheckDeactivated
(
)
;
void
Deactivate
(
)
;
void
BlockCanvas
(
)
;
TextureData
*
CreateTextureData
(
TextureType
aTextureType
gfx
:
:
BackendType
aBackendType
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
)
;
void
ClearTextureInfo
(
)
;
bool
HandleExtensionEvent
(
int32_t
aType
)
;
bool
CreateReferenceTexture
(
)
;
bool
CheckForFreshCanvasDevice
(
int
aLineNumber
)
;
void
NotifyDeviceChanged
(
)
;
bool
EnsureSharedContextWebgl
(
)
;
gfx
:
:
DrawTargetWebgl
*
GetDrawTargetWebgl
(
int64_t
aTextureId
)
const
;
void
NotifyRequiresRefresh
(
int64_t
aTextureId
bool
aDispatch
=
true
)
;
void
CacheSnapshotShmem
(
int64_t
aTextureId
bool
aDispatch
=
true
)
;
RefPtr
<
TaskQueue
>
mTranslationTaskQueue
;
#
if
defined
(
XP_WIN
)
RefPtr
<
ID3D11Device
>
mDevice
;
#
endif
RefPtr
<
gfx
:
:
SharedContextWebgl
>
mSharedContext
;
RefPtr
<
RemoteTextureOwnerClient
>
mRemoteTextureOwner
;
UniquePtr
<
CanvasEventRingBuffer
>
mStream
;
TextureType
mTextureType
=
TextureType
:
:
Unknown
;
UniquePtr
<
TextureData
>
mReferenceTextureData
;
gfx
:
:
BackendType
mBackendType
=
gfx
:
:
BackendType
:
:
NONE
;
struct
TextureInfo
{
UniquePtr
<
TextureData
>
mTextureData
;
RefPtr
<
gfx
:
:
DrawTarget
>
mDrawTarget
;
RemoteTextureOwnerId
mRemoteTextureOwnerId
;
bool
mNotifiedRequiresRefresh
=
false
;
int32_t
mLocked
=
1
;
}
;
std
:
:
unordered_map
<
int64_t
TextureInfo
>
mTextureInfo
;
int64_t
mNextTextureId
=
-
1
;
RemoteTextureOwnerId
mNextRemoteTextureOwnerId
;
nsRefPtrHashtable
<
nsPtrHashKey
<
void
>
gfx
:
:
DataSourceSurface
>
mDataSurfaces
;
gfx
:
:
ReferencePtr
mMappedSurface
;
UniquePtr
<
gfx
:
:
DataSourceSurface
:
:
ScopedMap
>
mPreparedMap
;
Atomic
<
bool
>
mDeactivated
{
false
}
;
Atomic
<
bool
>
mBlocked
{
false
}
;
bool
mIsInTransaction
=
false
;
bool
mDeviceResetInProgress
=
false
;
}
;
}
}
#
endif
