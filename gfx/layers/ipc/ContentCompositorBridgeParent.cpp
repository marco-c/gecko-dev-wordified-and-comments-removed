#
include
"
mozilla
/
layers
/
ContentCompositorBridgeParent
.
h
"
#
include
<
stdint
.
h
>
#
include
"
apz
/
src
/
APZCTreeManager
.
h
"
#
include
"
gfxUtils
.
h
"
#
ifdef
XP_WIN
#
include
"
mozilla
/
gfx
/
DeviceManagerDx
.
h
"
#
include
"
mozilla
/
layers
/
ImageDataSerializer
.
h
"
#
endif
#
include
"
mozilla
/
dom
/
WebGLParent
.
h
"
#
include
"
mozilla
/
ipc
/
Transport
.
h
"
#
include
"
mozilla
/
layers
/
AnimationHelper
.
h
"
#
include
"
mozilla
/
layers
/
APZCTreeManagerParent
.
h
"
#
include
"
mozilla
/
layers
/
APZUpdater
.
h
"
#
include
"
mozilla
/
layers
/
AsyncCompositionManager
.
h
"
#
include
"
mozilla
/
layers
/
CompositorOptions
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
LayerManagerComposite
.
h
"
#
include
"
mozilla
/
layers
/
LayerTreeOwnerTracker
.
h
"
#
include
"
mozilla
/
layers
/
RemoteContentController
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
AsyncImagePipelineManager
.
h
"
#
include
"
mozilla
/
webgpu
/
WebGPUParent
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
BaseProfilerMarkerTypes
.
h
"
#
include
"
GeckoProfiler
.
h
"
namespace
mozilla
{
namespace
layers
{
typedef
std
:
:
map
<
LayersId
CompositorBridgeParent
:
:
LayerTreeState
>
LayerTreeMap
;
extern
LayerTreeMap
sIndirectLayerTrees
;
extern
StaticAutoPtr
<
mozilla
:
:
Monitor
>
sIndirectLayerTreesLock
;
void
UpdateIndirectTree
(
LayersId
aId
Layer
*
aRoot
const
TargetConfig
&
aTargetConfig
)
;
void
EraseLayerState
(
LayersId
aId
)
;
void
ContentCompositorBridgeParent
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
mCanSend
=
false
;
GetCurrentSerialEventTarget
(
)
-
>
Dispatch
(
NewRunnableMethod
(
"
layers
:
:
ContentCompositorBridgeParent
:
:
DeferredDestroy
"
this
&
ContentCompositorBridgeParent
:
:
DeferredDestroy
)
)
;
}
PAPZCTreeManagerParent
*
ContentCompositorBridgeParent
:
:
AllocPAPZCTreeManagerParent
(
const
LayersId
&
aLayersId
)
{
if
(
!
LayerTreeOwnerTracker
:
:
Get
(
)
-
>
IsMapped
(
aLayersId
OtherPid
(
)
)
)
{
NS_ERROR
(
"
Unexpected
layers
id
in
AllocPAPZCTreeManagerParent
;
dropping
"
"
message
.
.
.
"
)
;
return
nullptr
;
}
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
CompositorBridgeParent
:
:
LayerTreeState
&
state
=
sIndirectLayerTrees
[
aLayersId
]
;
if
(
!
state
.
mParent
)
{
LayersId
dummyId
{
0
}
;
const
bool
useWebRender
=
false
;
RefPtr
<
APZCTreeManager
>
temp
=
new
APZCTreeManager
(
dummyId
useWebRender
)
;
RefPtr
<
APZUpdater
>
tempUpdater
=
new
APZUpdater
(
temp
useWebRender
)
;
tempUpdater
-
>
ClearTree
(
dummyId
)
;
return
new
APZCTreeManagerParent
(
aLayersId
temp
tempUpdater
)
;
}
state
.
mParent
-
>
AllocateAPZCTreeManagerParent
(
lock
aLayersId
state
)
;
return
state
.
mApzcTreeManagerParent
;
}
bool
ContentCompositorBridgeParent
:
:
DeallocPAPZCTreeManagerParent
(
PAPZCTreeManagerParent
*
aActor
)
{
APZCTreeManagerParent
*
parent
=
static_cast
<
APZCTreeManagerParent
*
>
(
aActor
)
;
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
auto
iter
=
sIndirectLayerTrees
.
find
(
parent
-
>
GetLayersId
(
)
)
;
if
(
iter
!
=
sIndirectLayerTrees
.
end
(
)
)
{
CompositorBridgeParent
:
:
LayerTreeState
&
state
=
iter
-
>
second
;
MOZ_ASSERT
(
state
.
mApzcTreeManagerParent
=
=
parent
)
;
state
.
mApzcTreeManagerParent
=
nullptr
;
}
delete
parent
;
return
true
;
}
PAPZParent
*
ContentCompositorBridgeParent
:
:
AllocPAPZParent
(
const
LayersId
&
aLayersId
)
{
if
(
!
LayerTreeOwnerTracker
:
:
Get
(
)
-
>
IsMapped
(
aLayersId
OtherPid
(
)
)
)
{
NS_ERROR
(
"
Unexpected
layers
id
in
AllocPAPZParent
;
dropping
message
.
.
.
"
)
;
return
nullptr
;
}
RemoteContentController
*
controller
=
new
RemoteContentController
(
)
;
controller
-
>
AddRef
(
)
;
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
CompositorBridgeParent
:
:
LayerTreeState
&
state
=
sIndirectLayerTrees
[
aLayersId
]
;
MOZ_ASSERT
(
!
state
.
mController
)
;
state
.
mController
=
controller
;
return
controller
;
}
bool
ContentCompositorBridgeParent
:
:
DeallocPAPZParent
(
PAPZParent
*
aActor
)
{
RemoteContentController
*
controller
=
static_cast
<
RemoteContentController
*
>
(
aActor
)
;
controller
-
>
Release
(
)
;
return
true
;
}
PWebRenderBridgeParent
*
ContentCompositorBridgeParent
:
:
AllocPWebRenderBridgeParent
(
const
wr
:
:
PipelineId
&
aPipelineId
const
LayoutDeviceIntSize
&
aSize
const
WindowKind
&
aWindowKind
)
{
LayersId
layersId
=
wr
:
:
AsLayersId
(
aPipelineId
)
;
if
(
!
LayerTreeOwnerTracker
:
:
Get
(
)
-
>
IsMapped
(
layersId
OtherPid
(
)
)
)
{
NS_ERROR
(
"
Unexpected
layers
id
in
AllocPWebRenderBridgeParent
;
dropping
"
"
message
.
.
.
"
)
;
return
nullptr
;
}
RefPtr
<
CompositorBridgeParent
>
cbp
=
nullptr
;
RefPtr
<
WebRenderBridgeParent
>
root
=
nullptr
;
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
MOZ_ASSERT
(
sIndirectLayerTrees
.
find
(
layersId
)
!
=
sIndirectLayerTrees
.
end
(
)
)
;
MOZ_ASSERT
(
sIndirectLayerTrees
[
layersId
]
.
mWrBridge
=
=
nullptr
)
;
cbp
=
sIndirectLayerTrees
[
layersId
]
.
mParent
;
if
(
cbp
)
{
root
=
sIndirectLayerTrees
[
cbp
-
>
RootLayerTreeId
(
)
]
.
mWrBridge
;
}
}
RefPtr
<
wr
:
:
WebRenderAPI
>
api
;
if
(
root
)
{
api
=
root
-
>
GetWebRenderAPI
(
)
;
}
if
(
!
root
|
|
!
api
)
{
NS_WARNING
(
nsPrintfCString
(
"
Created
child
without
a
matching
parent
?
root
%
p
"
root
.
get
(
)
)
.
get
(
)
)
;
nsCString
error
(
"
NO_PARENT
"
)
;
WebRenderBridgeParent
*
parent
=
WebRenderBridgeParent
:
:
CreateDestroyed
(
aPipelineId
std
:
:
move
(
error
)
)
;
parent
-
>
AddRef
(
)
;
return
parent
;
}
api
=
api
-
>
Clone
(
)
;
RefPtr
<
AsyncImagePipelineManager
>
holder
=
root
-
>
AsyncImageManager
(
)
;
WebRenderBridgeParent
*
parent
=
new
WebRenderBridgeParent
(
this
aPipelineId
nullptr
root
-
>
CompositorScheduler
(
)
std
:
:
move
(
api
)
std
:
:
move
(
holder
)
cbp
-
>
GetVsyncInterval
(
)
)
;
parent
-
>
AddRef
(
)
;
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
sIndirectLayerTrees
[
layersId
]
.
mContentCompositorBridgeParent
=
this
;
sIndirectLayerTrees
[
layersId
]
.
mWrBridge
=
parent
;
}
return
parent
;
}
bool
ContentCompositorBridgeParent
:
:
DeallocPWebRenderBridgeParent
(
PWebRenderBridgeParent
*
aActor
)
{
WebRenderBridgeParent
*
parent
=
static_cast
<
WebRenderBridgeParent
*
>
(
aActor
)
;
EraseLayerState
(
wr
:
:
AsLayersId
(
parent
-
>
PipelineId
(
)
)
)
;
parent
-
>
Release
(
)
;
return
true
;
}
webgpu
:
:
PWebGPUParent
*
ContentCompositorBridgeParent
:
:
AllocPWebGPUParent
(
)
{
webgpu
:
:
WebGPUParent
*
parent
=
new
webgpu
:
:
WebGPUParent
(
)
;
parent
-
>
AddRef
(
)
;
return
parent
;
}
bool
ContentCompositorBridgeParent
:
:
DeallocPWebGPUParent
(
webgpu
:
:
PWebGPUParent
*
aActor
)
{
webgpu
:
:
WebGPUParent
*
parent
=
static_cast
<
webgpu
:
:
WebGPUParent
*
>
(
aActor
)
;
parent
-
>
Release
(
)
;
return
true
;
}
mozilla
:
:
ipc
:
:
IPCResult
ContentCompositorBridgeParent
:
:
RecvNotifyChildCreated
(
const
LayersId
&
child
CompositorOptions
*
aOptions
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
for
(
LayerTreeMap
:
:
iterator
it
=
sIndirectLayerTrees
.
begin
(
)
;
it
!
=
sIndirectLayerTrees
.
end
(
)
;
it
+
+
)
{
CompositorBridgeParent
:
:
LayerTreeState
*
lts
=
&
it
-
>
second
;
if
(
lts
-
>
mParent
&
&
lts
-
>
mContentCompositorBridgeParent
=
=
this
)
{
lts
-
>
mParent
-
>
NotifyChildCreated
(
child
)
;
*
aOptions
=
lts
-
>
mParent
-
>
GetOptions
(
)
;
return
IPC_OK
(
)
;
}
}
return
IPC_FAIL_NO_REASON
(
this
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ContentCompositorBridgeParent
:
:
RecvMapAndNotifyChildCreated
(
const
LayersId
&
child
const
base
:
:
ProcessId
&
pid
CompositorOptions
*
aOptions
)
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ContentCompositorBridgeParent
:
:
RecvCheckContentOnlyTDR
(
const
uint32_t
&
sequenceNum
bool
*
isContentOnlyTDR
)
{
*
isContentOnlyTDR
=
false
;
#
ifdef
XP_WIN
gfx
:
:
ContentDeviceData
compositor
;
gfx
:
:
DeviceManagerDx
*
dm
=
gfx
:
:
DeviceManagerDx
:
:
Get
(
)
;
gfx
:
:
D3D11DeviceStatus
status
;
dm
-
>
ExportDeviceInfo
(
&
status
)
;
if
(
sequenceNum
=
=
status
.
sequenceNumber
(
)
&
&
!
dm
-
>
HasDeviceReset
(
)
)
{
*
isContentOnlyTDR
=
true
;
}
#
endif
return
IPC_OK
(
)
;
}
;
void
ContentCompositorBridgeParent
:
:
DidCompositeLocked
(
LayersId
aId
const
VsyncId
&
aVsyncId
TimeStamp
&
aCompositeStart
TimeStamp
&
aCompositeEnd
)
{
sIndirectLayerTreesLock
-
>
AssertCurrentThreadOwns
(
)
;
if
(
sIndirectLayerTrees
[
aId
]
.
mWrBridge
)
{
MOZ_ASSERT
(
false
)
;
}
}
bool
ContentCompositorBridgeParent
:
:
SetTestSampleTime
(
const
LayersId
&
aId
const
TimeStamp
&
aTime
)
{
MOZ_ASSERT
(
aId
.
IsValid
(
)
)
;
const
CompositorBridgeParent
:
:
LayerTreeState
*
state
=
CompositorBridgeParent
:
:
GetIndirectShadowTree
(
aId
)
;
if
(
!
state
)
{
return
false
;
}
MOZ_ASSERT
(
state
-
>
mParent
)
;
return
state
-
>
mParent
-
>
SetTestSampleTime
(
aId
aTime
)
;
}
void
ContentCompositorBridgeParent
:
:
LeaveTestMode
(
const
LayersId
&
aId
)
{
MOZ_ASSERT
(
aId
.
IsValid
(
)
)
;
const
CompositorBridgeParent
:
:
LayerTreeState
*
state
=
CompositorBridgeParent
:
:
GetIndirectShadowTree
(
aId
)
;
if
(
!
state
)
{
return
;
}
MOZ_ASSERT
(
state
-
>
mParent
)
;
state
-
>
mParent
-
>
LeaveTestMode
(
aId
)
;
}
void
ContentCompositorBridgeParent
:
:
SetTestAsyncScrollOffset
(
const
LayersId
&
aLayersId
const
ScrollableLayerGuid
:
:
ViewID
&
aScrollId
const
CSSPoint
&
aPoint
)
{
MOZ_ASSERT
(
aLayersId
.
IsValid
(
)
)
;
const
CompositorBridgeParent
:
:
LayerTreeState
*
state
=
CompositorBridgeParent
:
:
GetIndirectShadowTree
(
aLayersId
)
;
if
(
!
state
)
{
return
;
}
MOZ_ASSERT
(
state
-
>
mParent
)
;
state
-
>
mParent
-
>
SetTestAsyncScrollOffset
(
aLayersId
aScrollId
aPoint
)
;
}
void
ContentCompositorBridgeParent
:
:
SetTestAsyncZoom
(
const
LayersId
&
aLayersId
const
ScrollableLayerGuid
:
:
ViewID
&
aScrollId
const
LayerToParentLayerScale
&
aZoom
)
{
MOZ_ASSERT
(
aLayersId
.
IsValid
(
)
)
;
const
CompositorBridgeParent
:
:
LayerTreeState
*
state
=
CompositorBridgeParent
:
:
GetIndirectShadowTree
(
aLayersId
)
;
if
(
!
state
)
{
return
;
}
MOZ_ASSERT
(
state
-
>
mParent
)
;
state
-
>
mParent
-
>
SetTestAsyncZoom
(
aLayersId
aScrollId
aZoom
)
;
}
void
ContentCompositorBridgeParent
:
:
FlushApzRepaints
(
const
LayersId
&
aLayersId
)
{
MOZ_ASSERT
(
aLayersId
.
IsValid
(
)
)
;
const
CompositorBridgeParent
:
:
LayerTreeState
*
state
=
CompositorBridgeParent
:
:
GetIndirectShadowTree
(
aLayersId
)
;
if
(
!
state
|
|
!
state
-
>
mParent
)
{
return
;
}
state
-
>
mParent
-
>
FlushApzRepaints
(
aLayersId
)
;
}
void
ContentCompositorBridgeParent
:
:
GetAPZTestData
(
const
LayersId
&
aLayersId
APZTestData
*
aOutData
)
{
MOZ_ASSERT
(
aLayersId
.
IsValid
(
)
)
;
const
CompositorBridgeParent
:
:
LayerTreeState
*
state
=
CompositorBridgeParent
:
:
GetIndirectShadowTree
(
aLayersId
)
;
if
(
!
state
|
|
!
state
-
>
mParent
)
{
return
;
}
state
-
>
mParent
-
>
GetAPZTestData
(
aLayersId
aOutData
)
;
}
void
ContentCompositorBridgeParent
:
:
GetFrameUniformity
(
const
LayersId
&
aLayersId
FrameUniformityData
*
aOutData
)
{
MOZ_ASSERT
(
aLayersId
.
IsValid
(
)
)
;
const
CompositorBridgeParent
:
:
LayerTreeState
*
state
=
CompositorBridgeParent
:
:
GetIndirectShadowTree
(
aLayersId
)
;
if
(
!
state
|
|
!
state
-
>
mParent
)
{
return
;
}
state
-
>
mParent
-
>
GetFrameUniformity
(
aLayersId
aOutData
)
;
}
void
ContentCompositorBridgeParent
:
:
SetConfirmedTargetAPZC
(
const
LayersId
&
aLayersId
const
uint64_t
&
aInputBlockId
nsTArray
<
ScrollableLayerGuid
>
&
&
aTargets
)
{
MOZ_ASSERT
(
aLayersId
.
IsValid
(
)
)
;
const
CompositorBridgeParent
:
:
LayerTreeState
*
state
=
CompositorBridgeParent
:
:
GetIndirectShadowTree
(
aLayersId
)
;
if
(
!
state
|
|
!
state
-
>
mParent
)
{
return
;
}
state
-
>
mParent
-
>
SetConfirmedTargetAPZC
(
aLayersId
aInputBlockId
std
:
:
move
(
aTargets
)
)
;
}
void
ContentCompositorBridgeParent
:
:
DeferredDestroy
(
)
{
mSelfRef
=
nullptr
;
}
ContentCompositorBridgeParent
:
:
~
ContentCompositorBridgeParent
(
)
{
MOZ_ASSERT
(
XRE_GetIOMessageLoop
(
)
)
;
}
PTextureParent
*
ContentCompositorBridgeParent
:
:
AllocPTextureParent
(
const
SurfaceDescriptor
&
aSharedData
const
ReadLockDescriptor
&
aReadLock
const
LayersBackend
&
aLayersBackend
const
TextureFlags
&
aFlags
const
LayersId
&
aId
const
uint64_t
&
aSerial
const
wr
:
:
MaybeExternalImageId
&
aExternalImageId
)
{
CompositorBridgeParent
:
:
LayerTreeState
*
state
=
nullptr
;
LayerTreeMap
:
:
iterator
itr
=
sIndirectLayerTrees
.
find
(
aId
)
;
if
(
sIndirectLayerTrees
.
end
(
)
!
=
itr
)
{
state
=
&
itr
-
>
second
;
}
TextureFlags
flags
=
aFlags
;
LayersBackend
actualBackend
=
LayersBackend
:
:
LAYERS_NONE
;
if
(
state
&
&
state
-
>
mLayerManager
)
{
actualBackend
=
state
-
>
mLayerManager
-
>
GetBackendType
(
)
;
}
if
(
!
state
)
{
flags
|
=
TextureFlags
:
:
INVALID_COMPOSITOR
;
}
else
if
(
actualBackend
!
=
LayersBackend
:
:
LAYERS_NONE
&
&
aLayersBackend
!
=
actualBackend
)
{
gfxDevCrash
(
gfx
:
:
LogReason
:
:
PAllocTextureBackendMismatch
)
<
<
"
Texture
backend
is
wrong
"
;
}
return
TextureHost
:
:
CreateIPDLActor
(
this
aSharedData
aReadLock
aLayersBackend
aFlags
aSerial
aExternalImageId
)
;
}
bool
ContentCompositorBridgeParent
:
:
DeallocPTextureParent
(
PTextureParent
*
actor
)
{
return
TextureHost
:
:
DestroyIPDLActor
(
actor
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ContentCompositorBridgeParent
:
:
RecvInitPCanvasParent
(
Endpoint
<
PCanvasParent
>
&
&
aEndpoint
)
{
MOZ_RELEASE_ASSERT
(
!
mCanvasTranslator
"
mCanvasTranslator
must
be
released
before
recreating
.
"
)
;
mCanvasTranslator
=
CanvasTranslator
:
:
Create
(
std
:
:
move
(
aEndpoint
)
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ContentCompositorBridgeParent
:
:
RecvReleasePCanvasParent
(
)
{
MOZ_RELEASE_ASSERT
(
mCanvasTranslator
"
mCanvasTranslator
hasn
'
t
been
created
.
"
)
;
mCanvasTranslator
=
nullptr
;
return
IPC_OK
(
)
;
}
UniquePtr
<
SurfaceDescriptor
>
ContentCompositorBridgeParent
:
:
LookupSurfaceDescriptorForClientTexture
(
const
int64_t
aTextureId
)
{
return
mCanvasTranslator
-
>
WaitForSurfaceDescriptor
(
aTextureId
)
;
}
bool
ContentCompositorBridgeParent
:
:
IsSameProcess
(
)
const
{
return
OtherPid
(
)
=
=
base
:
:
GetCurrentProcId
(
)
;
}
void
ContentCompositorBridgeParent
:
:
ObserveLayersUpdate
(
LayersId
aLayersId
LayersObserverEpoch
aEpoch
bool
aActive
)
{
MOZ_ASSERT
(
aLayersId
.
IsValid
(
)
)
;
CompositorBridgeParent
:
:
LayerTreeState
*
state
=
CompositorBridgeParent
:
:
GetIndirectShadowTree
(
aLayersId
)
;
if
(
!
state
|
|
!
state
-
>
mParent
)
{
return
;
}
Unused
<
<
state
-
>
mParent
-
>
SendObserveLayersUpdate
(
aLayersId
aEpoch
aActive
)
;
}
already_AddRefed
<
dom
:
:
PWebGLParent
>
ContentCompositorBridgeParent
:
:
AllocPWebGLParent
(
)
{
RefPtr
<
dom
:
:
PWebGLParent
>
parent
=
new
dom
:
:
WebGLParent
(
)
;
return
parent
.
forget
(
)
;
}
}
}
