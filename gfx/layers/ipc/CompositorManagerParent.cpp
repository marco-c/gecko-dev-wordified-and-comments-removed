#
include
"
mozilla
/
layers
/
CompositorManagerParent
.
h
"
#
include
"
mozilla
/
gfx
/
GPUParent
.
h
"
#
include
"
mozilla
/
webrender
/
RenderThread
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
CrossProcessCompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
SharedSurfacesParent
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
VsyncSource
.
h
"
namespace
mozilla
{
namespace
layers
{
StaticRefPtr
<
CompositorManagerParent
>
CompositorManagerParent
:
:
sInstance
;
StaticMutex
CompositorManagerParent
:
:
sMutex
;
#
ifdef
COMPOSITOR_MANAGER_PARENT_EXPLICIT_SHUTDOWN
StaticAutoPtr
<
nsTArray
<
CompositorManagerParent
*
>
>
CompositorManagerParent
:
:
sActiveActors
;
#
endif
already_AddRefed
<
CompositorManagerParent
>
CompositorManagerParent
:
:
CreateSameProcess
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
|
|
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
StaticMutexAutoLock
lock
(
sMutex
)
;
if
(
NS_WARN_IF
(
sInstance
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Already
initialized
"
)
;
return
nullptr
;
}
RefPtr
<
CompositorManagerParent
>
parent
=
new
CompositorManagerParent
(
)
;
parent
-
>
SetOtherProcessId
(
base
:
:
GetCurrentProcId
(
)
)
;
return
parent
.
forget
(
)
;
}
void
CompositorManagerParent
:
:
Create
(
Endpoint
<
PCompositorManagerParent
>
&
&
aEndpoint
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aEndpoint
.
OtherPid
(
)
!
=
base
:
:
GetCurrentProcId
(
)
)
;
RefPtr
<
CompositorManagerParent
>
bridge
=
new
CompositorManagerParent
(
)
;
RefPtr
<
Runnable
>
runnable
=
NewRunnableMethod
<
Endpoint
<
PCompositorManagerParent
>
&
&
>
(
"
CompositorManagerParent
:
:
Bind
"
bridge
&
CompositorManagerParent
:
:
Bind
std
:
:
move
(
aEndpoint
)
)
;
CompositorThreadHolder
:
:
Loop
(
)
-
>
PostTask
(
runnable
.
forget
(
)
)
;
}
already_AddRefed
<
CompositorBridgeParent
>
CompositorManagerParent
:
:
CreateSameProcessWidgetCompositorBridge
(
CSSToLayoutDeviceScale
aScale
const
CompositorOptions
&
aOptions
bool
aUseExternalSurfaceSize
const
gfx
:
:
IntSize
&
aSurfaceSize
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
|
|
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
StaticMutexAutoLock
lock
(
sMutex
)
;
if
(
NS_WARN_IF
(
!
sInstance
)
)
{
return
nullptr
;
}
TimeDuration
vsyncRate
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetHardwareVsync
(
)
-
>
GetGlobalDisplay
(
)
.
GetVsyncRate
(
)
;
RefPtr
<
CompositorBridgeParent
>
bridge
=
new
CompositorBridgeParent
(
sInstance
aScale
vsyncRate
aOptions
aUseExternalSurfaceSize
aSurfaceSize
)
;
sInstance
-
>
mPendingCompositorBridges
.
AppendElement
(
bridge
)
;
return
bridge
.
forget
(
)
;
}
CompositorManagerParent
:
:
CompositorManagerParent
(
)
:
mCompositorThreadHolder
(
CompositorThreadHolder
:
:
GetSingleton
(
)
)
{
}
CompositorManagerParent
:
:
~
CompositorManagerParent
(
)
{
}
void
CompositorManagerParent
:
:
Bind
(
Endpoint
<
PCompositorManagerParent
>
&
&
aEndpoint
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
if
(
NS_WARN_IF
(
!
aEndpoint
.
Bind
(
this
)
)
)
{
return
;
}
BindComplete
(
)
;
}
void
CompositorManagerParent
:
:
BindComplete
(
)
{
AddRef
(
)
;
StaticMutexAutoLock
lock
(
sMutex
)
;
if
(
OtherPid
(
)
=
=
base
:
:
GetCurrentProcId
(
)
)
{
sInstance
=
this
;
}
#
ifdef
COMPOSITOR_MANAGER_PARENT_EXPLICIT_SHUTDOWN
if
(
!
sActiveActors
)
{
sActiveActors
=
new
nsTArray
<
CompositorManagerParent
*
>
(
)
;
}
sActiveActors
-
>
AppendElement
(
this
)
;
#
endif
}
void
CompositorManagerParent
:
:
ActorDestroy
(
ActorDestroyReason
aReason
)
{
SharedSurfacesParent
:
:
DestroyProcess
(
OtherPid
(
)
)
;
StaticMutexAutoLock
lock
(
sMutex
)
;
if
(
sInstance
=
=
this
)
{
sInstance
=
nullptr
;
}
}
void
CompositorManagerParent
:
:
DeallocPCompositorManagerParent
(
)
{
MessageLoop
:
:
current
(
)
-
>
PostTask
(
NewRunnableMethod
(
"
layers
:
:
CompositorManagerParent
:
:
DeferredDestroy
"
this
&
CompositorManagerParent
:
:
DeferredDestroy
)
)
;
#
ifdef
COMPOSITOR_MANAGER_PARENT_EXPLICIT_SHUTDOWN
StaticMutexAutoLock
lock
(
sMutex
)
;
if
(
sActiveActors
)
{
sActiveActors
-
>
RemoveElement
(
this
)
;
}
#
endif
Release
(
)
;
}
void
CompositorManagerParent
:
:
DeferredDestroy
(
)
{
mCompositorThreadHolder
=
nullptr
;
}
#
ifdef
COMPOSITOR_MANAGER_PARENT_EXPLICIT_SHUTDOWN
void
CompositorManagerParent
:
:
ShutdownInternal
(
)
{
nsAutoPtr
<
nsTArray
<
CompositorManagerParent
*
>
>
actors
;
{
StaticMutexAutoLock
lock
(
sMutex
)
;
actors
=
sActiveActors
.
forget
(
)
;
}
if
(
actors
)
{
for
(
auto
&
actor
:
*
actors
)
{
actor
-
>
Close
(
)
;
}
}
}
#
endif
void
CompositorManagerParent
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
#
ifdef
COMPOSITOR_MANAGER_PARENT_EXPLICIT_SHUTDOWN
CompositorThreadHolder
:
:
Loop
(
)
-
>
PostTask
(
NS_NewRunnableFunction
(
"
layers
:
:
CompositorManagerParent
:
:
Shutdown
"
[
]
(
)
-
>
void
{
CompositorManagerParent
:
:
ShutdownInternal
(
)
;
}
)
)
;
#
endif
}
PCompositorBridgeParent
*
CompositorManagerParent
:
:
AllocPCompositorBridgeParent
(
const
CompositorBridgeOptions
&
aOpt
)
{
switch
(
aOpt
.
type
(
)
)
{
case
CompositorBridgeOptions
:
:
TContentCompositorOptions
:
{
CrossProcessCompositorBridgeParent
*
bridge
=
new
CrossProcessCompositorBridgeParent
(
this
)
;
bridge
-
>
AddRef
(
)
;
return
bridge
;
}
case
CompositorBridgeOptions
:
:
TWidgetCompositorOptions
:
{
gfx
:
:
GPUParent
*
gpu
=
gfx
:
:
GPUParent
:
:
GetSingleton
(
)
;
if
(
NS_WARN_IF
(
!
gpu
|
|
OtherPid
(
)
!
=
gpu
-
>
OtherPid
(
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Child
cannot
create
widget
compositor
!
"
)
;
break
;
}
const
WidgetCompositorOptions
&
opt
=
aOpt
.
get_WidgetCompositorOptions
(
)
;
CompositorBridgeParent
*
bridge
=
new
CompositorBridgeParent
(
this
opt
.
scale
(
)
opt
.
vsyncRate
(
)
opt
.
options
(
)
opt
.
useExternalSurfaceSize
(
)
opt
.
surfaceSize
(
)
)
;
bridge
-
>
AddRef
(
)
;
return
bridge
;
}
case
CompositorBridgeOptions
:
:
TSameProcessWidgetCompositorOptions
:
{
if
(
NS_WARN_IF
(
OtherPid
(
)
!
=
base
:
:
GetCurrentProcId
(
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Child
cannot
create
same
process
compositor
!
"
)
;
break
;
}
StaticMutexAutoLock
lock
(
sMutex
)
;
if
(
mPendingCompositorBridges
.
IsEmpty
(
)
)
{
break
;
}
CompositorBridgeParent
*
bridge
=
mPendingCompositorBridges
[
0
]
;
bridge
-
>
AddRef
(
)
;
mPendingCompositorBridges
.
RemoveElementAt
(
0
)
;
return
bridge
;
}
default
:
break
;
}
return
nullptr
;
}
bool
CompositorManagerParent
:
:
DeallocPCompositorBridgeParent
(
PCompositorBridgeParent
*
aActor
)
{
static_cast
<
CompositorBridgeParentBase
*
>
(
aActor
)
-
>
Release
(
)
;
return
true
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorManagerParent
:
:
RecvAddSharedSurface
(
const
wr
:
:
ExternalImageId
&
aId
const
SurfaceDescriptorShared
&
aDesc
)
{
SharedSurfacesParent
:
:
Add
(
aId
aDesc
OtherPid
(
)
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorManagerParent
:
:
RecvRemoveSharedSurface
(
const
wr
:
:
ExternalImageId
&
aId
)
{
SharedSurfacesParent
:
:
Remove
(
aId
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorManagerParent
:
:
RecvReportSharedSurfacesMemory
(
ReportSharedSurfacesMemoryResolver
&
&
aResolver
)
{
SharedSurfacesMemoryReport
report
;
SharedSurfacesParent
:
:
AccumulateMemoryReport
(
OtherPid
(
)
report
)
;
aResolver
(
std
:
:
move
(
report
)
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorManagerParent
:
:
RecvNotifyMemoryPressure
(
)
{
nsTArray
<
PCompositorBridgeParent
*
>
compositorBridges
;
ManagedPCompositorBridgeParent
(
compositorBridges
)
;
for
(
auto
bridge
:
compositorBridges
)
{
static_cast
<
CompositorBridgeParentBase
*
>
(
bridge
)
-
>
NotifyMemoryPressure
(
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorManagerParent
:
:
RecvReportMemory
(
ReportMemoryResolver
&
&
aResolver
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
MemoryReport
aggregate
;
PodZero
(
&
aggregate
)
;
nsTArray
<
PCompositorBridgeParent
*
>
compositorBridges
;
ManagedPCompositorBridgeParent
(
compositorBridges
)
;
for
(
auto
bridge
:
compositorBridges
)
{
static_cast
<
CompositorBridgeParentBase
*
>
(
bridge
)
-
>
AccumulateMemoryReport
(
&
aggregate
)
;
}
wr
:
:
RenderThread
:
:
AccumulateMemoryReport
(
aggregate
)
-
>
Then
(
CompositorThreadHolder
:
:
Loop
(
)
-
>
SerialEventTarget
(
)
__func__
[
resolver
=
std
:
:
move
(
aResolver
)
]
(
MemoryReport
aReport
)
{
resolver
(
aReport
)
;
}
[
]
(
bool
)
{
MOZ_ASSERT_UNREACHABLE
(
"
MemoryReport
promises
are
never
rejected
"
)
;
}
)
;
return
IPC_OK
(
)
;
}
}
}
