#
include
"
mozilla
/
layers
/
CompositorManagerParent
.
h
"
#
include
"
mozilla
/
gfx
/
GPUParent
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
CrossProcessCompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
VsyncSource
.
h
"
namespace
mozilla
{
namespace
layers
{
StaticRefPtr
<
CompositorManagerParent
>
CompositorManagerParent
:
:
sInstance
;
StaticMutex
CompositorManagerParent
:
:
sMutex
;
already_AddRefed
<
CompositorManagerParent
>
CompositorManagerParent
:
:
CreateSameProcess
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
StaticMutexAutoLock
lock
(
sMutex
)
;
if
(
NS_WARN_IF
(
sInstance
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Already
initialized
"
)
;
return
nullptr
;
}
RefPtr
<
CompositorManagerParent
>
parent
=
new
CompositorManagerParent
(
)
;
parent
-
>
mCompositorThreadHolder
=
new
CompositorThreadHolderDebug
(
"
CompositorManagerSame
"
)
;
parent
-
>
SetOtherProcessId
(
base
:
:
GetCurrentProcId
(
)
)
;
parent
.
get
(
)
-
>
AddRef
(
)
;
sInstance
=
parent
;
return
parent
.
forget
(
)
;
}
void
CompositorManagerParent
:
:
Create
(
Endpoint
<
PCompositorManagerParent
>
&
&
aEndpoint
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aEndpoint
.
OtherPid
(
)
!
=
base
:
:
GetCurrentProcId
(
)
)
;
RefPtr
<
CompositorManagerParent
>
bridge
=
new
CompositorManagerParent
(
)
;
bridge
-
>
mCompositorThreadHolder
=
new
CompositorThreadHolderDebug
(
"
CompositorManagerContent
"
)
;
RefPtr
<
Runnable
>
runnable
=
NewRunnableMethod
<
Endpoint
<
PCompositorManagerParent
>
&
&
>
(
"
CompositorManagerParent
:
:
Bind
"
bridge
&
CompositorManagerParent
:
:
Bind
Move
(
aEndpoint
)
)
;
CompositorThreadHolder
:
:
Loop
(
)
-
>
PostTask
(
runnable
.
forget
(
)
)
;
}
already_AddRefed
<
CompositorBridgeParent
>
CompositorManagerParent
:
:
CreateSameProcessWidgetCompositorBridge
(
CSSToLayoutDeviceScale
aScale
const
CompositorOptions
&
aOptions
bool
aUseExternalSurfaceSize
const
gfx
:
:
IntSize
&
aSurfaceSize
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
StaticMutexAutoLock
lock
(
sMutex
)
;
if
(
NS_WARN_IF
(
!
sInstance
)
)
{
return
nullptr
;
}
TimeDuration
vsyncRate
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetHardwareVsync
(
)
-
>
GetGlobalDisplay
(
)
.
GetVsyncRate
(
)
;
RefPtr
<
CompositorBridgeParent
>
bridge
=
new
CompositorBridgeParent
(
sInstance
aScale
vsyncRate
aOptions
aUseExternalSurfaceSize
aSurfaceSize
)
;
sInstance
-
>
mPendingCompositorBridges
.
AppendElement
(
bridge
)
;
return
bridge
.
forget
(
)
;
}
CompositorManagerParent
:
:
CompositorManagerParent
(
)
{
}
CompositorManagerParent
:
:
~
CompositorManagerParent
(
)
{
}
void
CompositorManagerParent
:
:
Bind
(
Endpoint
<
PCompositorManagerParent
>
&
&
aEndpoint
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
if
(
NS_WARN_IF
(
!
aEndpoint
.
Bind
(
this
)
)
)
{
return
;
}
AddRef
(
)
;
}
void
CompositorManagerParent
:
:
ActorDestroy
(
ActorDestroyReason
aReason
)
{
StaticMutexAutoLock
lock
(
sMutex
)
;
if
(
sInstance
=
=
this
)
{
sInstance
=
nullptr
;
}
}
void
CompositorManagerParent
:
:
DeallocPCompositorManagerParent
(
)
{
MessageLoop
:
:
current
(
)
-
>
PostTask
(
NewRunnableMethod
(
"
layers
:
:
CompositorManagerParent
:
:
DeferredDestroy
"
this
&
CompositorManagerParent
:
:
DeferredDestroy
)
)
;
Release
(
)
;
}
void
CompositorManagerParent
:
:
DeferredDestroy
(
)
{
mCompositorThreadHolder
=
nullptr
;
}
PCompositorBridgeParent
*
CompositorManagerParent
:
:
AllocPCompositorBridgeParent
(
const
CompositorBridgeOptions
&
aOpt
)
{
switch
(
aOpt
.
type
(
)
)
{
case
CompositorBridgeOptions
:
:
TContentCompositorOptions
:
{
CrossProcessCompositorBridgeParent
*
bridge
=
new
CrossProcessCompositorBridgeParent
(
this
)
;
bridge
-
>
AddRef
(
)
;
return
bridge
;
}
case
CompositorBridgeOptions
:
:
TWidgetCompositorOptions
:
{
gfx
:
:
GPUParent
*
gpu
=
gfx
:
:
GPUParent
:
:
GetSingleton
(
)
;
if
(
NS_WARN_IF
(
!
gpu
|
|
OtherPid
(
)
!
=
gpu
-
>
OtherPid
(
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Child
cannot
create
widget
compositor
!
"
)
;
break
;
}
const
WidgetCompositorOptions
&
opt
=
aOpt
.
get_WidgetCompositorOptions
(
)
;
CompositorBridgeParent
*
bridge
=
new
CompositorBridgeParent
(
this
opt
.
scale
(
)
opt
.
vsyncRate
(
)
opt
.
options
(
)
opt
.
useExternalSurfaceSize
(
)
opt
.
surfaceSize
(
)
)
;
bridge
-
>
AddRef
(
)
;
return
bridge
;
}
case
CompositorBridgeOptions
:
:
TSameProcessWidgetCompositorOptions
:
{
if
(
NS_WARN_IF
(
OtherPid
(
)
!
=
base
:
:
GetCurrentProcId
(
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Child
cannot
create
same
process
compositor
!
"
)
;
break
;
}
StaticMutexAutoLock
lock
(
sMutex
)
;
MOZ_ASSERT
(
!
mPendingCompositorBridges
.
IsEmpty
(
)
)
;
CompositorBridgeParent
*
bridge
=
mPendingCompositorBridges
[
0
]
;
bridge
-
>
AddRef
(
)
;
mPendingCompositorBridges
.
RemoveElementAt
(
0
)
;
return
bridge
;
}
default
:
break
;
}
return
nullptr
;
}
bool
CompositorManagerParent
:
:
DeallocPCompositorBridgeParent
(
PCompositorBridgeParent
*
aActor
)
{
static_cast
<
CompositorBridgeParentBase
*
>
(
aActor
)
-
>
Release
(
)
;
return
true
;
}
}
}
