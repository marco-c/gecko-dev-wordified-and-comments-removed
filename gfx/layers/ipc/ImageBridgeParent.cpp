#
include
"
ImageBridgeParent
.
h
"
#
include
<
stdint
.
h
>
#
include
"
CompositableHost
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
process
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
Hal
.
h
"
#
include
"
mozilla
/
HalTypes
.
h
"
#
include
"
mozilla
/
ipc
/
MessageChannel
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
ipc
/
Transport
.
h
"
#
include
"
mozilla
/
media
/
MediaSystemResourceManagerParent
.
h
"
#
include
"
mozilla
/
layers
/
CompositableTransactionParent
.
h
"
#
include
"
mozilla
/
layers
/
LayerManagerComposite
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
PCompositableParent
.
h
"
#
include
"
mozilla
/
layers
/
PImageBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
TextureHostOGL
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
mozilla
:
:
ipc
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
media
;
std
:
:
map
<
base
:
:
ProcessId
ImageBridgeParent
*
>
ImageBridgeParent
:
:
sImageBridges
;
MessageLoop
*
ImageBridgeParent
:
:
sMainLoop
=
nullptr
;
CompositorThreadHolder
*
GetCompositorThreadHolder
(
)
;
ImageBridgeParent
:
:
ImageBridgeParent
(
MessageLoop
*
aLoop
ProcessId
aChildProcessId
)
:
mMessageLoop
(
aLoop
)
mSetChildThreadPriority
(
false
)
mClosed
(
false
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
sMainLoop
=
MessageLoop
:
:
current
(
)
;
CompositableMap
:
:
Create
(
)
;
sImageBridges
[
aChildProcessId
]
=
this
;
SetOtherProcessId
(
aChildProcessId
)
;
}
ImageBridgeParent
:
:
~
ImageBridgeParent
(
)
{
nsTArray
<
PImageContainerParent
*
>
parents
;
ManagedPImageContainerParent
(
parents
)
;
for
(
PImageContainerParent
*
p
:
parents
)
{
delete
p
;
}
sImageBridges
.
erase
(
OtherPid
(
)
)
;
}
static
StaticRefPtr
<
ImageBridgeParent
>
sImageBridgeParentSingleton
;
void
ReleaseImageBridgeParentSingleton
(
)
{
sImageBridgeParentSingleton
=
nullptr
;
}
ImageBridgeParent
*
ImageBridgeParent
:
:
CreateSameProcess
(
)
{
RefPtr
<
ImageBridgeParent
>
parent
=
new
ImageBridgeParent
(
CompositorThreadHolder
:
:
Loop
(
)
base
:
:
GetCurrentProcId
(
)
)
;
parent
-
>
mSelfRef
=
parent
;
sImageBridgeParentSingleton
=
parent
;
return
parent
;
}
bool
ImageBridgeParent
:
:
CreateForGPUProcess
(
Endpoint
<
PImageBridgeParent
>
&
&
aEndpoint
)
{
MOZ_ASSERT
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_GPU
)
;
MessageLoop
*
loop
=
CompositorThreadHolder
:
:
Loop
(
)
;
RefPtr
<
ImageBridgeParent
>
parent
=
new
ImageBridgeParent
(
loop
aEndpoint
.
OtherPid
(
)
)
;
loop
-
>
PostTask
(
NewRunnableMethod
<
Endpoint
<
PImageBridgeParent
>
&
&
>
(
parent
&
ImageBridgeParent
:
:
Bind
Move
(
aEndpoint
)
)
)
;
sImageBridgeParentSingleton
=
parent
;
return
true
;
}
void
ImageBridgeParent
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
mClosed
=
true
;
MessageLoop
:
:
current
(
)
-
>
PostTask
(
NewRunnableMethod
(
this
&
ImageBridgeParent
:
:
DeferredDestroy
)
)
;
}
bool
ImageBridgeParent
:
:
RecvImageBridgeThreadId
(
const
PlatformThreadId
&
aThreadId
)
{
MOZ_ASSERT
(
!
mSetChildThreadPriority
)
;
if
(
mSetChildThreadPriority
)
{
return
false
;
}
mSetChildThreadPriority
=
true
;
return
true
;
}
class
MOZ_STACK_CLASS
AutoImageBridgeParentAsyncMessageSender
{
public
:
explicit
AutoImageBridgeParentAsyncMessageSender
(
ImageBridgeParent
*
aImageBridge
InfallibleTArray
<
OpDestroy
>
*
aToDestroy
=
nullptr
)
:
mImageBridge
(
aImageBridge
)
mToDestroy
(
aToDestroy
)
{
mImageBridge
-
>
SetAboutToSendAsyncMessages
(
)
;
}
~
AutoImageBridgeParentAsyncMessageSender
(
)
{
mImageBridge
-
>
SendPendingAsyncMessages
(
)
;
if
(
mToDestroy
)
{
for
(
const
auto
&
op
:
*
mToDestroy
)
{
mImageBridge
-
>
DestroyActor
(
op
)
;
}
}
}
private
:
ImageBridgeParent
*
mImageBridge
;
InfallibleTArray
<
OpDestroy
>
*
mToDestroy
;
}
;
bool
ImageBridgeParent
:
:
RecvUpdate
(
EditArray
&
&
aEdits
OpDestroyArray
&
&
aToDestroy
const
uint64_t
&
aFwdTransactionId
EditReplyArray
*
aReply
)
{
AutoImageBridgeParentAsyncMessageSender
autoAsyncMessageSender
(
this
&
aToDestroy
)
;
UpdateFwdTransactionId
(
aFwdTransactionId
)
;
EditReplyVector
replyv
;
for
(
EditArray
:
:
index_type
i
=
0
;
i
<
aEdits
.
Length
(
)
;
+
+
i
)
{
if
(
!
ReceiveCompositableUpdate
(
aEdits
[
i
]
replyv
)
)
{
return
false
;
}
}
aReply
-
>
SetCapacity
(
replyv
.
size
(
)
)
;
if
(
replyv
.
size
(
)
>
0
)
{
aReply
-
>
AppendElements
(
&
replyv
.
front
(
)
replyv
.
size
(
)
)
;
}
if
(
!
IsSameProcess
(
)
)
{
LayerManagerComposite
:
:
PlatformSyncBeforeReplyUpdate
(
)
;
}
return
true
;
}
bool
ImageBridgeParent
:
:
RecvUpdateNoSwap
(
EditArray
&
&
aEdits
OpDestroyArray
&
&
aToDestroy
const
uint64_t
&
aFwdTransactionId
)
{
InfallibleTArray
<
EditReply
>
noReplies
;
bool
success
=
RecvUpdate
(
Move
(
aEdits
)
Move
(
aToDestroy
)
aFwdTransactionId
&
noReplies
)
;
MOZ_ASSERT
(
noReplies
.
Length
(
)
=
=
0
"
RecvUpdateNoSwap
requires
a
sync
Update
to
carry
Edits
"
)
;
return
success
;
}
bool
ImageBridgeParent
:
:
CreateForContent
(
Endpoint
<
PImageBridgeParent
>
&
&
aEndpoint
)
{
MessageLoop
*
loop
=
CompositorThreadHolder
:
:
Loop
(
)
;
RefPtr
<
ImageBridgeParent
>
bridge
=
new
ImageBridgeParent
(
loop
aEndpoint
.
OtherPid
(
)
)
;
loop
-
>
PostTask
(
NewRunnableMethod
<
Endpoint
<
PImageBridgeParent
>
&
&
>
(
bridge
&
ImageBridgeParent
:
:
Bind
Move
(
aEndpoint
)
)
)
;
return
true
;
}
void
ImageBridgeParent
:
:
Bind
(
Endpoint
<
PImageBridgeParent
>
&
&
aEndpoint
)
{
if
(
!
aEndpoint
.
Bind
(
this
)
)
return
;
mSelfRef
=
this
;
}
bool
ImageBridgeParent
:
:
RecvWillClose
(
)
{
InfallibleTArray
<
PTextureParent
*
>
textures
;
ManagedPTextureParent
(
textures
)
;
for
(
unsigned
int
i
=
0
;
i
<
textures
.
Length
(
)
;
+
+
i
)
{
RefPtr
<
TextureHost
>
tex
=
TextureHost
:
:
AsTextureHost
(
textures
[
i
]
)
;
tex
-
>
DeallocateDeviceData
(
)
;
}
return
true
;
}
static
uint64_t
GenImageContainerID
(
)
{
static
uint64_t
sNextImageID
=
1
;
+
+
sNextImageID
;
return
sNextImageID
;
}
PCompositableParent
*
ImageBridgeParent
:
:
AllocPCompositableParent
(
const
TextureInfo
&
aInfo
PImageContainerParent
*
aImageContainer
uint64_t
*
aID
)
{
uint64_t
id
=
GenImageContainerID
(
)
;
*
aID
=
id
;
return
CompositableHost
:
:
CreateIPDLActor
(
this
aInfo
id
aImageContainer
)
;
}
bool
ImageBridgeParent
:
:
DeallocPCompositableParent
(
PCompositableParent
*
aActor
)
{
return
CompositableHost
:
:
DestroyIPDLActor
(
aActor
)
;
}
PTextureParent
*
ImageBridgeParent
:
:
AllocPTextureParent
(
const
SurfaceDescriptor
&
aSharedData
const
LayersBackend
&
aLayersBackend
const
TextureFlags
&
aFlags
const
uint64_t
&
aSerial
)
{
return
TextureHost
:
:
CreateIPDLActor
(
this
aSharedData
aLayersBackend
aFlags
aSerial
)
;
}
bool
ImageBridgeParent
:
:
DeallocPTextureParent
(
PTextureParent
*
actor
)
{
return
TextureHost
:
:
DestroyIPDLActor
(
actor
)
;
}
PMediaSystemResourceManagerParent
*
ImageBridgeParent
:
:
AllocPMediaSystemResourceManagerParent
(
)
{
return
new
mozilla
:
:
media
:
:
MediaSystemResourceManagerParent
(
)
;
}
bool
ImageBridgeParent
:
:
DeallocPMediaSystemResourceManagerParent
(
PMediaSystemResourceManagerParent
*
aActor
)
{
MOZ_ASSERT
(
aActor
)
;
delete
static_cast
<
mozilla
:
:
media
:
:
MediaSystemResourceManagerParent
*
>
(
aActor
)
;
return
true
;
}
PImageContainerParent
*
ImageBridgeParent
:
:
AllocPImageContainerParent
(
)
{
return
new
ImageContainerParent
(
)
;
}
bool
ImageBridgeParent
:
:
DeallocPImageContainerParent
(
PImageContainerParent
*
actor
)
{
delete
actor
;
return
true
;
}
void
ImageBridgeParent
:
:
SendAsyncMessage
(
const
InfallibleTArray
<
AsyncParentMessageData
>
&
aMessage
)
{
mozilla
:
:
Unused
<
<
SendParentAsyncMessages
(
aMessage
)
;
}
class
ProcessIdComparator
{
public
:
bool
Equals
(
const
ImageCompositeNotification
&
aA
const
ImageCompositeNotification
&
aB
)
const
{
return
aA
.
imageContainerParent
(
)
-
>
OtherPid
(
)
=
=
aB
.
imageContainerParent
(
)
-
>
OtherPid
(
)
;
}
bool
LessThan
(
const
ImageCompositeNotification
&
aA
const
ImageCompositeNotification
&
aB
)
const
{
return
aA
.
imageContainerParent
(
)
-
>
OtherPid
(
)
<
aB
.
imageContainerParent
(
)
-
>
OtherPid
(
)
;
}
}
;
bool
ImageBridgeParent
:
:
NotifyImageComposites
(
nsTArray
<
ImageCompositeNotification
>
&
aNotifications
)
{
aNotifications
.
Sort
(
ProcessIdComparator
(
)
)
;
uint32_t
i
=
0
;
bool
ok
=
true
;
while
(
i
<
aNotifications
.
Length
(
)
)
{
AutoTArray
<
ImageCompositeNotification
1
>
notifications
;
notifications
.
AppendElement
(
aNotifications
[
i
]
)
;
uint32_t
end
=
i
+
1
;
MOZ_ASSERT
(
aNotifications
[
i
]
.
imageContainerParent
(
)
)
;
ProcessId
pid
=
aNotifications
[
i
]
.
imageContainerParent
(
)
-
>
OtherPid
(
)
;
while
(
end
<
aNotifications
.
Length
(
)
&
&
aNotifications
[
end
]
.
imageContainerParent
(
)
-
>
OtherPid
(
)
=
=
pid
)
{
notifications
.
AppendElement
(
aNotifications
[
end
]
)
;
+
+
end
;
}
GetInstance
(
pid
)
-
>
SendPendingAsyncMessages
(
)
;
if
(
!
GetInstance
(
pid
)
-
>
SendDidComposite
(
notifications
)
)
{
ok
=
false
;
}
i
=
end
;
}
return
ok
;
}
void
ImageBridgeParent
:
:
DeferredDestroy
(
)
{
mCompositorThreadHolder
=
nullptr
;
mSelfRef
=
nullptr
;
}
ImageBridgeParent
*
ImageBridgeParent
:
:
GetInstance
(
ProcessId
aId
)
{
NS_ASSERTION
(
sImageBridges
.
count
(
aId
)
=
=
1
"
ImageBridgeParent
for
the
process
"
)
;
return
sImageBridges
[
aId
]
;
}
void
ImageBridgeParent
:
:
OnChannelConnected
(
int32_t
aPid
)
{
mCompositorThreadHolder
=
GetCompositorThreadHolder
(
)
;
}
bool
ImageBridgeParent
:
:
AllocShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
if
(
mClosed
)
{
return
false
;
}
return
PImageBridgeParent
:
:
AllocShmem
(
aSize
aType
aShmem
)
;
}
bool
ImageBridgeParent
:
:
AllocUnsafeShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
if
(
mClosed
)
{
return
false
;
}
return
PImageBridgeParent
:
:
AllocUnsafeShmem
(
aSize
aType
aShmem
)
;
}
void
ImageBridgeParent
:
:
DeallocShmem
(
ipc
:
:
Shmem
&
aShmem
)
{
if
(
mClosed
)
{
return
;
}
PImageBridgeParent
:
:
DeallocShmem
(
aShmem
)
;
}
bool
ImageBridgeParent
:
:
IsSameProcess
(
)
const
{
return
OtherPid
(
)
=
=
base
:
:
GetCurrentProcId
(
)
;
}
void
ImageBridgeParent
:
:
ReplyRemoveTexture
(
const
OpReplyRemoveTexture
&
aReply
)
{
mPendingAsyncMessage
.
push_back
(
aReply
)
;
}
void
ImageBridgeParent
:
:
SendFenceHandleToNonRecycle
(
PTextureParent
*
aTexture
)
{
RefPtr
<
TextureHost
>
texture
=
TextureHost
:
:
AsTextureHost
(
aTexture
)
;
if
(
!
texture
)
{
return
;
}
if
(
!
(
texture
-
>
GetFlags
(
)
&
TextureFlags
:
:
RECYCLE
)
&
&
!
texture
-
>
NeedsFenceHandle
(
)
)
{
return
;
}
uint64_t
textureId
=
TextureHost
:
:
GetTextureSerial
(
aTexture
)
;
FenceHandle
fence
=
texture
-
>
GetCompositorReleaseFence
(
)
;
if
(
fence
.
IsValid
(
)
)
{
mPendingAsyncMessage
.
push_back
(
OpDeliverFenceToNonRecycle
(
textureId
fence
)
)
;
}
fence
=
texture
-
>
GetAndResetReleaseFenceHandle
(
)
;
if
(
fence
.
IsValid
(
)
)
{
mPendingAsyncMessage
.
push_back
(
OpDeliverFenceToNonRecycle
(
textureId
fence
)
)
;
}
}
void
ImageBridgeParent
:
:
NotifyNotUsedToNonRecycle
(
PTextureParent
*
aTexture
uint64_t
aTransactionId
)
{
RefPtr
<
TextureHost
>
texture
=
TextureHost
:
:
AsTextureHost
(
aTexture
)
;
if
(
!
texture
)
{
return
;
}
if
(
!
(
texture
-
>
GetFlags
(
)
&
TextureFlags
:
:
RECYCLE
)
&
&
!
texture
-
>
NeedsFenceHandle
(
)
)
{
return
;
}
SendFenceHandleToNonRecycle
(
aTexture
)
;
uint64_t
textureId
=
TextureHost
:
:
GetTextureSerial
(
aTexture
)
;
mPendingAsyncMessage
.
push_back
(
OpNotifyNotUsedToNonRecycle
(
textureId
aTransactionId
)
)
;
}
void
ImageBridgeParent
:
:
NotifyNotUsedToNonRecycle
(
base
:
:
ProcessId
aChildProcessId
PTextureParent
*
aTexture
uint64_t
aTransactionId
)
{
ImageBridgeParent
*
imageBridge
=
ImageBridgeParent
:
:
GetInstance
(
aChildProcessId
)
;
if
(
!
imageBridge
)
{
return
;
}
imageBridge
-
>
NotifyNotUsedToNonRecycle
(
aTexture
aTransactionId
)
;
}
void
ImageBridgeParent
:
:
SetAboutToSendAsyncMessages
(
base
:
:
ProcessId
aChildProcessId
)
{
ImageBridgeParent
*
imageBridge
=
ImageBridgeParent
:
:
GetInstance
(
aChildProcessId
)
;
if
(
!
imageBridge
)
{
return
;
}
imageBridge
-
>
SetAboutToSendAsyncMessages
(
)
;
}
void
ImageBridgeParent
:
:
SendPendingAsyncMessages
(
base
:
:
ProcessId
aChildProcessId
)
{
ImageBridgeParent
*
imageBridge
=
ImageBridgeParent
:
:
GetInstance
(
aChildProcessId
)
;
if
(
!
imageBridge
)
{
return
;
}
imageBridge
-
>
SendPendingAsyncMessages
(
)
;
}
void
ImageBridgeParent
:
:
NotifyNotUsed
(
PTextureParent
*
aTexture
uint64_t
aTransactionId
)
{
RefPtr
<
TextureHost
>
texture
=
TextureHost
:
:
AsTextureHost
(
aTexture
)
;
if
(
!
texture
)
{
return
;
}
if
(
!
(
texture
-
>
GetFlags
(
)
&
TextureFlags
:
:
RECYCLE
)
&
&
!
texture
-
>
NeedsFenceHandle
(
)
)
{
return
;
}
SendFenceHandleIfPresent
(
aTexture
)
;
uint64_t
textureId
=
TextureHost
:
:
GetTextureSerial
(
aTexture
)
;
mPendingAsyncMessage
.
push_back
(
OpNotifyNotUsed
(
textureId
aTransactionId
)
)
;
if
(
!
IsAboutToSendAsyncMessages
(
)
)
{
SendPendingAsyncMessages
(
)
;
}
}
}
}
