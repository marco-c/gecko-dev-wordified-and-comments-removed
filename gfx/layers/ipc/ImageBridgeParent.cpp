#
include
"
ImageBridgeParent
.
h
"
#
include
<
stdint
.
h
>
#
include
"
CompositableHost
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
process
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
Hal
.
h
"
#
include
"
mozilla
/
HalTypes
.
h
"
#
include
"
mozilla
/
ipc
/
MessageChannel
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
ipc
/
Transport
.
h
"
#
include
"
mozilla
/
media
/
MediaSystemResourceManagerParent
.
h
"
#
include
"
mozilla
/
layers
/
CompositableTransactionParent
.
h
"
#
include
"
mozilla
/
layers
/
LayerManagerComposite
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
layers
/
PImageBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
TextureHostOGL
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
mozilla
:
:
ipc
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
media
;
ImageBridgeParent
:
:
ImageBridgeMap
ImageBridgeParent
:
:
sImageBridges
;
StaticAutoPtr
<
mozilla
:
:
Monitor
>
sImageBridgesLock
;
static
StaticRefPtr
<
ImageBridgeParent
>
sImageBridgeParentSingleton
;
CompositorThreadHolder
*
GetCompositorThreadHolder
(
)
;
void
ImageBridgeParent
:
:
Setup
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
sImageBridgesLock
)
{
sImageBridgesLock
=
new
Monitor
(
"
ImageBridges
"
)
;
mozilla
:
:
ClearOnShutdown
(
&
sImageBridgesLock
)
;
}
}
ImageBridgeParent
:
:
ImageBridgeParent
(
MessageLoop
*
aLoop
ProcessId
aChildProcessId
)
:
mMessageLoop
(
aLoop
)
mClosed
(
false
)
mCompositorThreadHolder
(
CompositorThreadHolder
:
:
GetSingleton
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
SetOtherProcessId
(
aChildProcessId
)
;
}
ImageBridgeParent
:
:
~
ImageBridgeParent
(
)
{
}
ImageBridgeParent
*
ImageBridgeParent
:
:
CreateSameProcess
(
)
{
base
:
:
ProcessId
pid
=
base
:
:
GetCurrentProcId
(
)
;
RefPtr
<
ImageBridgeParent
>
parent
=
new
ImageBridgeParent
(
CompositorThreadHolder
:
:
Loop
(
)
pid
)
;
parent
-
>
mSelfRef
=
parent
;
{
MonitorAutoLock
lock
(
*
sImageBridgesLock
)
;
MOZ_RELEASE_ASSERT
(
sImageBridges
.
count
(
pid
)
=
=
0
)
;
sImageBridges
[
pid
]
=
parent
;
}
sImageBridgeParentSingleton
=
parent
;
return
parent
;
}
bool
ImageBridgeParent
:
:
CreateForGPUProcess
(
Endpoint
<
PImageBridgeParent
>
&
&
aEndpoint
)
{
MOZ_ASSERT
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_GPU
)
;
MessageLoop
*
loop
=
CompositorThreadHolder
:
:
Loop
(
)
;
RefPtr
<
ImageBridgeParent
>
parent
=
new
ImageBridgeParent
(
loop
aEndpoint
.
OtherPid
(
)
)
;
loop
-
>
PostTask
(
NewRunnableMethod
<
Endpoint
<
PImageBridgeParent
>
&
&
>
(
"
layers
:
:
ImageBridgeParent
:
:
Bind
"
parent
&
ImageBridgeParent
:
:
Bind
std
:
:
move
(
aEndpoint
)
)
)
;
sImageBridgeParentSingleton
=
parent
;
return
true
;
}
void
ImageBridgeParent
:
:
ShutdownInternal
(
)
{
nsTArray
<
RefPtr
<
ImageBridgeParent
>
>
actors
;
{
MonitorAutoLock
lock
(
*
sImageBridgesLock
)
;
for
(
const
auto
&
iter
:
sImageBridges
)
{
actors
.
AppendElement
(
iter
.
second
)
;
}
}
for
(
auto
const
&
actor
:
actors
)
{
MOZ_RELEASE_ASSERT
(
!
actor
-
>
mClosed
)
;
actor
-
>
Close
(
)
;
}
sImageBridgeParentSingleton
=
nullptr
;
}
void
ImageBridgeParent
:
:
Shutdown
(
)
{
CompositorThreadHolder
:
:
Loop
(
)
-
>
PostTask
(
NS_NewRunnableFunction
(
"
ImageBridgeParent
:
:
Shutdown
"
[
]
(
)
-
>
void
{
ImageBridgeParent
:
:
ShutdownInternal
(
)
;
}
)
)
;
}
void
ImageBridgeParent
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
mClosed
=
true
;
mCompositables
.
clear
(
)
;
{
MonitorAutoLock
lock
(
*
sImageBridgesLock
)
;
sImageBridges
.
erase
(
OtherPid
(
)
)
;
}
MessageLoop
:
:
current
(
)
-
>
PostTask
(
NewRunnableMethod
(
"
layers
:
:
ImageBridgeParent
:
:
DeferredDestroy
"
this
&
ImageBridgeParent
:
:
DeferredDestroy
)
)
;
}
class
MOZ_STACK_CLASS
AutoImageBridgeParentAsyncMessageSender
{
public
:
explicit
AutoImageBridgeParentAsyncMessageSender
(
ImageBridgeParent
*
aImageBridge
InfallibleTArray
<
OpDestroy
>
*
aToDestroy
=
nullptr
)
:
mImageBridge
(
aImageBridge
)
mToDestroy
(
aToDestroy
)
{
mImageBridge
-
>
SetAboutToSendAsyncMessages
(
)
;
}
~
AutoImageBridgeParentAsyncMessageSender
(
)
{
mImageBridge
-
>
SendPendingAsyncMessages
(
)
;
if
(
mToDestroy
)
{
for
(
const
auto
&
op
:
*
mToDestroy
)
{
mImageBridge
-
>
DestroyActor
(
op
)
;
}
}
}
private
:
ImageBridgeParent
*
mImageBridge
;
InfallibleTArray
<
OpDestroy
>
*
mToDestroy
;
}
;
mozilla
:
:
ipc
:
:
IPCResult
ImageBridgeParent
:
:
RecvUpdate
(
EditArray
&
&
aEdits
OpDestroyArray
&
&
aToDestroy
const
uint64_t
&
aFwdTransactionId
)
{
AutoImageBridgeParentAsyncMessageSender
autoAsyncMessageSender
(
this
&
aToDestroy
)
;
UpdateFwdTransactionId
(
aFwdTransactionId
)
;
for
(
const
auto
&
edit
:
aEdits
)
{
RefPtr
<
CompositableHost
>
compositable
=
FindCompositable
(
edit
.
compositable
(
)
)
;
if
(
!
compositable
|
|
!
ReceiveCompositableUpdate
(
edit
.
detail
(
)
WrapNotNull
(
compositable
)
)
)
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
uint32_t
dropped
=
compositable
-
>
GetDroppedFrames
(
)
;
if
(
dropped
)
{
Unused
<
<
SendReportFramesDropped
(
edit
.
compositable
(
)
dropped
)
;
}
}
if
(
!
IsSameProcess
(
)
)
{
LayerManagerComposite
:
:
PlatformSyncBeforeReplyUpdate
(
)
;
}
return
IPC_OK
(
)
;
}
bool
ImageBridgeParent
:
:
CreateForContent
(
Endpoint
<
PImageBridgeParent
>
&
&
aEndpoint
)
{
MessageLoop
*
loop
=
CompositorThreadHolder
:
:
Loop
(
)
;
RefPtr
<
ImageBridgeParent
>
bridge
=
new
ImageBridgeParent
(
loop
aEndpoint
.
OtherPid
(
)
)
;
loop
-
>
PostTask
(
NewRunnableMethod
<
Endpoint
<
PImageBridgeParent
>
&
&
>
(
"
layers
:
:
ImageBridgeParent
:
:
Bind
"
bridge
&
ImageBridgeParent
:
:
Bind
std
:
:
move
(
aEndpoint
)
)
)
;
return
true
;
}
void
ImageBridgeParent
:
:
Bind
(
Endpoint
<
PImageBridgeParent
>
&
&
aEndpoint
)
{
if
(
!
aEndpoint
.
Bind
(
this
)
)
return
;
mSelfRef
=
this
;
RefPtr
<
ImageBridgeParent
>
oldActor
;
{
MonitorAutoLock
lock
(
*
sImageBridgesLock
)
;
ImageBridgeMap
:
:
const_iterator
i
=
sImageBridges
.
find
(
OtherPid
(
)
)
;
if
(
i
!
=
sImageBridges
.
end
(
)
)
{
oldActor
=
i
-
>
second
;
}
}
if
(
oldActor
)
{
MOZ_RELEASE_ASSERT
(
!
oldActor
-
>
mClosed
)
;
oldActor
-
>
Close
(
)
;
}
{
MonitorAutoLock
lock
(
*
sImageBridgesLock
)
;
sImageBridges
[
OtherPid
(
)
]
=
this
;
}
}
mozilla
:
:
ipc
:
:
IPCResult
ImageBridgeParent
:
:
RecvWillClose
(
)
{
InfallibleTArray
<
PTextureParent
*
>
textures
;
ManagedPTextureParent
(
textures
)
;
for
(
unsigned
int
i
=
0
;
i
<
textures
.
Length
(
)
;
+
+
i
)
{
RefPtr
<
TextureHost
>
tex
=
TextureHost
:
:
AsTextureHost
(
textures
[
i
]
)
;
tex
-
>
DeallocateDeviceData
(
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ImageBridgeParent
:
:
RecvNewCompositable
(
const
CompositableHandle
&
aHandle
const
TextureInfo
&
aInfo
const
LayersBackend
&
aLayersBackend
)
{
bool
useWebRender
=
aLayersBackend
=
=
LayersBackend
:
:
LAYERS_WR
;
RefPtr
<
CompositableHost
>
host
=
AddCompositable
(
aHandle
aInfo
useWebRender
)
;
if
(
!
host
)
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
host
-
>
SetAsyncRef
(
AsyncCompositableRef
(
OtherPid
(
)
aHandle
)
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ImageBridgeParent
:
:
RecvReleaseCompositable
(
const
CompositableHandle
&
aHandle
)
{
ReleaseCompositable
(
aHandle
)
;
return
IPC_OK
(
)
;
}
PTextureParent
*
ImageBridgeParent
:
:
AllocPTextureParent
(
const
SurfaceDescriptor
&
aSharedData
const
ReadLockDescriptor
&
aReadLock
const
LayersBackend
&
aLayersBackend
const
TextureFlags
&
aFlags
const
uint64_t
&
aSerial
const
wr
:
:
MaybeExternalImageId
&
aExternalImageId
)
{
return
TextureHost
:
:
CreateIPDLActor
(
this
aSharedData
aReadLock
aLayersBackend
aFlags
aSerial
aExternalImageId
)
;
}
bool
ImageBridgeParent
:
:
DeallocPTextureParent
(
PTextureParent
*
actor
)
{
return
TextureHost
:
:
DestroyIPDLActor
(
actor
)
;
}
PMediaSystemResourceManagerParent
*
ImageBridgeParent
:
:
AllocPMediaSystemResourceManagerParent
(
)
{
return
new
mozilla
:
:
media
:
:
MediaSystemResourceManagerParent
(
)
;
}
bool
ImageBridgeParent
:
:
DeallocPMediaSystemResourceManagerParent
(
PMediaSystemResourceManagerParent
*
aActor
)
{
MOZ_ASSERT
(
aActor
)
;
delete
static_cast
<
mozilla
:
:
media
:
:
MediaSystemResourceManagerParent
*
>
(
aActor
)
;
return
true
;
}
void
ImageBridgeParent
:
:
SendAsyncMessage
(
const
InfallibleTArray
<
AsyncParentMessageData
>
&
aMessage
)
{
mozilla
:
:
Unused
<
<
SendParentAsyncMessages
(
aMessage
)
;
}
class
ProcessIdComparator
{
public
:
bool
Equals
(
const
ImageCompositeNotificationInfo
&
aA
const
ImageCompositeNotificationInfo
&
aB
)
const
{
return
aA
.
mImageBridgeProcessId
=
=
aB
.
mImageBridgeProcessId
;
}
bool
LessThan
(
const
ImageCompositeNotificationInfo
&
aA
const
ImageCompositeNotificationInfo
&
aB
)
const
{
return
aA
.
mImageBridgeProcessId
<
aB
.
mImageBridgeProcessId
;
}
}
;
bool
ImageBridgeParent
:
:
NotifyImageComposites
(
nsTArray
<
ImageCompositeNotificationInfo
>
&
aNotifications
)
{
aNotifications
.
Sort
(
ProcessIdComparator
(
)
)
;
uint32_t
i
=
0
;
bool
ok
=
true
;
while
(
i
<
aNotifications
.
Length
(
)
)
{
AutoTArray
<
ImageCompositeNotification
1
>
notifications
;
notifications
.
AppendElement
(
aNotifications
[
i
]
.
mNotification
)
;
uint32_t
end
=
i
+
1
;
MOZ_ASSERT
(
aNotifications
[
i
]
.
mNotification
.
compositable
(
)
)
;
ProcessId
pid
=
aNotifications
[
i
]
.
mImageBridgeProcessId
;
while
(
end
<
aNotifications
.
Length
(
)
&
&
aNotifications
[
end
]
.
mImageBridgeProcessId
=
=
pid
)
{
notifications
.
AppendElement
(
aNotifications
[
end
]
.
mNotification
)
;
+
+
end
;
}
RefPtr
<
ImageBridgeParent
>
bridge
=
GetInstance
(
pid
)
;
if
(
!
bridge
|
|
bridge
-
>
mClosed
)
{
i
=
end
;
continue
;
}
bridge
-
>
SendPendingAsyncMessages
(
)
;
if
(
!
bridge
-
>
SendDidComposite
(
notifications
)
)
{
ok
=
false
;
}
i
=
end
;
}
return
ok
;
}
void
ImageBridgeParent
:
:
DeferredDestroy
(
)
{
mCompositorThreadHolder
=
nullptr
;
mSelfRef
=
nullptr
;
}
already_AddRefed
<
ImageBridgeParent
>
ImageBridgeParent
:
:
GetInstance
(
ProcessId
aId
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
MonitorAutoLock
lock
(
*
sImageBridgesLock
)
;
ImageBridgeMap
:
:
const_iterator
i
=
sImageBridges
.
find
(
aId
)
;
if
(
i
=
=
sImageBridges
.
end
(
)
)
{
NS_WARNING
(
"
Cannot
find
image
bridge
for
process
!
"
)
;
return
nullptr
;
}
RefPtr
<
ImageBridgeParent
>
bridge
=
i
-
>
second
;
return
bridge
.
forget
(
)
;
}
bool
ImageBridgeParent
:
:
AllocShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
if
(
mClosed
)
{
return
false
;
}
return
PImageBridgeParent
:
:
AllocShmem
(
aSize
aType
aShmem
)
;
}
bool
ImageBridgeParent
:
:
AllocUnsafeShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
if
(
mClosed
)
{
return
false
;
}
return
PImageBridgeParent
:
:
AllocUnsafeShmem
(
aSize
aType
aShmem
)
;
}
void
ImageBridgeParent
:
:
DeallocShmem
(
ipc
:
:
Shmem
&
aShmem
)
{
if
(
mClosed
)
{
return
;
}
PImageBridgeParent
:
:
DeallocShmem
(
aShmem
)
;
}
bool
ImageBridgeParent
:
:
IsSameProcess
(
)
const
{
return
OtherPid
(
)
=
=
base
:
:
GetCurrentProcId
(
)
;
}
void
ImageBridgeParent
:
:
NotifyNotUsed
(
PTextureParent
*
aTexture
uint64_t
aTransactionId
)
{
RefPtr
<
TextureHost
>
texture
=
TextureHost
:
:
AsTextureHost
(
aTexture
)
;
if
(
!
texture
)
{
return
;
}
if
(
!
(
texture
-
>
GetFlags
(
)
&
TextureFlags
:
:
RECYCLE
)
)
{
return
;
}
uint64_t
textureId
=
TextureHost
:
:
GetTextureSerial
(
aTexture
)
;
mPendingAsyncMessage
.
push_back
(
OpNotifyNotUsed
(
textureId
aTransactionId
)
)
;
if
(
!
IsAboutToSendAsyncMessages
(
)
)
{
SendPendingAsyncMessages
(
)
;
}
}
}
}
