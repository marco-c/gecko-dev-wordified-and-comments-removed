#
include
"
ImageBridgeParent
.
h
"
#
include
<
stdint
.
h
>
#
include
"
CompositableHost
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
process
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
Hal
.
h
"
#
include
"
mozilla
/
HalTypes
.
h
"
#
include
"
mozilla
/
ipc
/
MessageChannel
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
ipc
/
Transport
.
h
"
#
include
"
mozilla
/
ipc
/
GeckoChildProcessHost
.
h
"
#
include
"
mozilla
/
media
/
MediaSystemResourceManagerParent
.
h
"
#
include
"
mozilla
/
layers
/
CompositableTransactionParent
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
LayerManagerComposite
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
PCompositableParent
.
h
"
#
include
"
mozilla
/
layers
/
PImageBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
TextureHostOGL
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
unused
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
mozilla
:
:
ipc
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
media
;
std
:
:
map
<
base
:
:
ProcessId
ImageBridgeParent
*
>
ImageBridgeParent
:
:
sImageBridges
;
MessageLoop
*
ImageBridgeParent
:
:
sMainLoop
=
nullptr
;
CompositorThreadHolder
*
GetCompositorThreadHolder
(
)
;
ImageBridgeParent
:
:
ImageBridgeParent
(
MessageLoop
*
aLoop
Transport
*
aTransport
ProcessId
aChildProcessId
)
:
mMessageLoop
(
aLoop
)
mTransport
(
aTransport
)
mSetChildThreadPriority
(
false
)
mClosed
(
false
)
mSubprocess
(
nullptr
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
sMainLoop
=
MessageLoop
:
:
current
(
)
;
SetMessageLoopToPostDestructionTo
(
sMainLoop
)
;
CompositableMap
:
:
Create
(
)
;
sImageBridges
[
aChildProcessId
]
=
this
;
SetOtherProcessId
(
aChildProcessId
)
;
mSelfRef
=
this
;
}
ImageBridgeParent
:
:
~
ImageBridgeParent
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mTransport
)
{
MOZ_ASSERT
(
XRE_GetIOMessageLoop
(
)
)
;
RefPtr
<
DeleteTask
<
Transport
>
>
task
(
new
DeleteTask
<
Transport
>
(
mTransport
)
)
;
XRE_GetIOMessageLoop
(
)
-
>
PostTask
(
task
.
forget
(
)
)
;
}
nsTArray
<
PImageContainerParent
*
>
parents
;
ManagedPImageContainerParent
(
parents
)
;
for
(
PImageContainerParent
*
p
:
parents
)
{
delete
p
;
}
sImageBridges
.
erase
(
OtherPid
(
)
)
;
}
void
ImageBridgeParent
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
mClosed
=
true
;
if
(
mSubprocess
)
{
mSubprocess
-
>
DissociateActor
(
)
;
mSubprocess
=
nullptr
;
}
RefPtr
<
Runnable
>
runnable
=
NS_NewRunnableMethod
(
this
&
ImageBridgeParent
:
:
DeferredDestroy
)
;
MessageLoop
:
:
current
(
)
-
>
PostTask
(
runnable
.
forget
(
)
)
;
}
bool
ImageBridgeParent
:
:
RecvImageBridgeThreadId
(
const
PlatformThreadId
&
aThreadId
)
{
MOZ_ASSERT
(
!
mSetChildThreadPriority
)
;
if
(
mSetChildThreadPriority
)
{
return
false
;
}
mSetChildThreadPriority
=
true
;
#
ifdef
MOZ_WIDGET_GONK
hal
:
:
SetThreadPriority
(
aThreadId
hal
:
:
THREAD_PRIORITY_COMPOSITOR
)
;
#
endif
return
true
;
}
class
MOZ_STACK_CLASS
AutoImageBridgeParentAsyncMessageSender
{
public
:
explicit
AutoImageBridgeParentAsyncMessageSender
(
ImageBridgeParent
*
aImageBridge
InfallibleTArray
<
OpDestroy
>
*
aToDestroy
=
nullptr
)
:
mImageBridge
(
aImageBridge
)
mToDestroy
(
aToDestroy
)
{
}
~
AutoImageBridgeParentAsyncMessageSender
(
)
{
mImageBridge
-
>
SendPendingAsyncMessages
(
)
;
if
(
mToDestroy
)
{
for
(
const
auto
&
op
:
*
mToDestroy
)
{
mImageBridge
-
>
DestroyActor
(
op
)
;
}
}
}
private
:
ImageBridgeParent
*
mImageBridge
;
InfallibleTArray
<
OpDestroy
>
*
mToDestroy
;
}
;
bool
ImageBridgeParent
:
:
RecvUpdate
(
EditArray
&
&
aEdits
OpDestroyArray
&
&
aToDestroy
EditReplyArray
*
aReply
)
{
AutoImageBridgeParentAsyncMessageSender
autoAsyncMessageSender
(
this
&
aToDestroy
)
;
EditReplyVector
replyv
;
for
(
EditArray
:
:
index_type
i
=
0
;
i
<
aEdits
.
Length
(
)
;
+
+
i
)
{
if
(
!
ReceiveCompositableUpdate
(
aEdits
[
i
]
replyv
)
)
{
return
false
;
}
}
aReply
-
>
SetCapacity
(
replyv
.
size
(
)
)
;
if
(
replyv
.
size
(
)
>
0
)
{
aReply
-
>
AppendElements
(
&
replyv
.
front
(
)
replyv
.
size
(
)
)
;
}
if
(
!
IsSameProcess
(
)
)
{
LayerManagerComposite
:
:
PlatformSyncBeforeReplyUpdate
(
)
;
}
return
true
;
}
bool
ImageBridgeParent
:
:
RecvUpdateNoSwap
(
EditArray
&
&
aEdits
OpDestroyArray
&
&
aToDestroy
)
{
InfallibleTArray
<
EditReply
>
noReplies
;
bool
success
=
RecvUpdate
(
Move
(
aEdits
)
Move
(
aToDestroy
)
&
noReplies
)
;
MOZ_ASSERT
(
noReplies
.
Length
(
)
=
=
0
"
RecvUpdateNoSwap
requires
a
sync
Update
to
carry
Edits
"
)
;
return
success
;
}
static
void
ConnectImageBridgeInParentProcess
(
ImageBridgeParent
*
aBridge
Transport
*
aTransport
base
:
:
ProcessId
aOtherPid
)
{
aBridge
-
>
Open
(
aTransport
aOtherPid
XRE_GetIOMessageLoop
(
)
ipc
:
:
ParentSide
)
;
}
PImageBridgeParent
*
ImageBridgeParent
:
:
Create
(
Transport
*
aTransport
ProcessId
aChildProcessId
GeckoChildProcessHost
*
aProcessHost
)
{
MessageLoop
*
loop
=
CompositorBridgeParent
:
:
CompositorLoop
(
)
;
RefPtr
<
ImageBridgeParent
>
bridge
=
new
ImageBridgeParent
(
loop
aTransport
aChildProcessId
)
;
if
(
aProcessHost
)
{
bridge
-
>
mSubprocess
=
aProcessHost
;
aProcessHost
-
>
AssociateActor
(
)
;
}
loop
-
>
PostTask
(
NewRunnableFunction
(
ConnectImageBridgeInParentProcess
bridge
.
get
(
)
aTransport
aChildProcessId
)
)
;
return
bridge
.
get
(
)
;
}
bool
ImageBridgeParent
:
:
RecvWillClose
(
)
{
InfallibleTArray
<
PTextureParent
*
>
textures
;
ManagedPTextureParent
(
textures
)
;
for
(
unsigned
int
i
=
0
;
i
<
textures
.
Length
(
)
;
+
+
i
)
{
RefPtr
<
TextureHost
>
tex
=
TextureHost
:
:
AsTextureHost
(
textures
[
i
]
)
;
tex
-
>
DeallocateDeviceData
(
)
;
}
return
true
;
}
static
uint64_t
GenImageContainerID
(
)
{
static
uint64_t
sNextImageID
=
1
;
+
+
sNextImageID
;
return
sNextImageID
;
}
PCompositableParent
*
ImageBridgeParent
:
:
AllocPCompositableParent
(
const
TextureInfo
&
aInfo
PImageContainerParent
*
aImageContainer
uint64_t
*
aID
)
{
uint64_t
id
=
GenImageContainerID
(
)
;
*
aID
=
id
;
return
CompositableHost
:
:
CreateIPDLActor
(
this
aInfo
id
aImageContainer
)
;
}
bool
ImageBridgeParent
:
:
DeallocPCompositableParent
(
PCompositableParent
*
aActor
)
{
return
CompositableHost
:
:
DestroyIPDLActor
(
aActor
)
;
}
PTextureParent
*
ImageBridgeParent
:
:
AllocPTextureParent
(
const
SurfaceDescriptor
&
aSharedData
const
LayersBackend
&
aLayersBackend
const
TextureFlags
&
aFlags
)
{
return
TextureHost
:
:
CreateIPDLActor
(
this
aSharedData
aLayersBackend
aFlags
)
;
}
bool
ImageBridgeParent
:
:
DeallocPTextureParent
(
PTextureParent
*
actor
)
{
return
TextureHost
:
:
DestroyIPDLActor
(
actor
)
;
}
PMediaSystemResourceManagerParent
*
ImageBridgeParent
:
:
AllocPMediaSystemResourceManagerParent
(
)
{
return
new
mozilla
:
:
media
:
:
MediaSystemResourceManagerParent
(
)
;
}
bool
ImageBridgeParent
:
:
DeallocPMediaSystemResourceManagerParent
(
PMediaSystemResourceManagerParent
*
aActor
)
{
MOZ_ASSERT
(
aActor
)
;
delete
static_cast
<
mozilla
:
:
media
:
:
MediaSystemResourceManagerParent
*
>
(
aActor
)
;
return
true
;
}
PImageContainerParent
*
ImageBridgeParent
:
:
AllocPImageContainerParent
(
)
{
return
new
ImageContainerParent
(
)
;
}
bool
ImageBridgeParent
:
:
DeallocPImageContainerParent
(
PImageContainerParent
*
actor
)
{
delete
actor
;
return
true
;
}
void
ImageBridgeParent
:
:
SendAsyncMessage
(
const
InfallibleTArray
<
AsyncParentMessageData
>
&
aMessage
)
{
mozilla
:
:
Unused
<
<
SendParentAsyncMessages
(
aMessage
)
;
}
bool
ImageBridgeParent
:
:
RecvChildAsyncMessages
(
InfallibleTArray
<
AsyncChildMessageData
>
&
&
aMessages
)
{
return
true
;
}
class
ProcessIdComparator
{
public
:
bool
Equals
(
const
ImageCompositeNotification
&
aA
const
ImageCompositeNotification
&
aB
)
const
{
return
aA
.
imageContainerParent
(
)
-
>
OtherPid
(
)
=
=
aB
.
imageContainerParent
(
)
-
>
OtherPid
(
)
;
}
bool
LessThan
(
const
ImageCompositeNotification
&
aA
const
ImageCompositeNotification
&
aB
)
const
{
return
aA
.
imageContainerParent
(
)
-
>
OtherPid
(
)
<
aB
.
imageContainerParent
(
)
-
>
OtherPid
(
)
;
}
}
;
bool
ImageBridgeParent
:
:
NotifyImageComposites
(
nsTArray
<
ImageCompositeNotification
>
&
aNotifications
)
{
aNotifications
.
Sort
(
ProcessIdComparator
(
)
)
;
uint32_t
i
=
0
;
bool
ok
=
true
;
while
(
i
<
aNotifications
.
Length
(
)
)
{
AutoTArray
<
ImageCompositeNotification
1
>
notifications
;
notifications
.
AppendElement
(
aNotifications
[
i
]
)
;
uint32_t
end
=
i
+
1
;
MOZ_ASSERT
(
aNotifications
[
i
]
.
imageContainerParent
(
)
)
;
ProcessId
pid
=
aNotifications
[
i
]
.
imageContainerParent
(
)
-
>
OtherPid
(
)
;
while
(
end
<
aNotifications
.
Length
(
)
&
&
aNotifications
[
end
]
.
imageContainerParent
(
)
-
>
OtherPid
(
)
=
=
pid
)
{
notifications
.
AppendElement
(
aNotifications
[
end
]
)
;
+
+
end
;
}
if
(
!
GetInstance
(
pid
)
-
>
SendDidComposite
(
notifications
)
)
{
ok
=
false
;
}
i
=
end
;
}
return
ok
;
}
void
ImageBridgeParent
:
:
DeferredDestroy
(
)
{
mCompositorThreadHolder
=
nullptr
;
mSelfRef
=
nullptr
;
}
ImageBridgeParent
*
ImageBridgeParent
:
:
GetInstance
(
ProcessId
aId
)
{
NS_ASSERTION
(
sImageBridges
.
count
(
aId
)
=
=
1
"
ImageBridgeParent
for
the
process
"
)
;
return
sImageBridges
[
aId
]
;
}
IToplevelProtocol
*
ImageBridgeParent
:
:
CloneToplevel
(
const
InfallibleTArray
<
ProtocolFdMapping
>
&
aFds
base
:
:
ProcessHandle
aPeerProcess
mozilla
:
:
ipc
:
:
ProtocolCloneContext
*
aCtx
)
{
for
(
unsigned
int
i
=
0
;
i
<
aFds
.
Length
(
)
;
i
+
+
)
{
if
(
aFds
[
i
]
.
protocolId
(
)
=
=
unsigned
(
GetProtocolId
(
)
)
)
{
Transport
*
transport
=
OpenDescriptor
(
aFds
[
i
]
.
fd
(
)
Transport
:
:
MODE_SERVER
)
;
PImageBridgeParent
*
bridge
=
Create
(
transport
base
:
:
GetProcId
(
aPeerProcess
)
mSubprocess
)
;
bridge
-
>
CloneManagees
(
this
aCtx
)
;
bridge
-
>
IToplevelProtocol
:
:
SetTransport
(
transport
)
;
bridge
-
>
OnChannelConnected
(
base
:
:
GetProcId
(
aPeerProcess
)
)
;
return
bridge
;
}
}
return
nullptr
;
}
void
ImageBridgeParent
:
:
OnChannelConnected
(
int32_t
aPid
)
{
mCompositorThreadHolder
=
GetCompositorThreadHolder
(
)
;
}
bool
ImageBridgeParent
:
:
AllocShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
if
(
mClosed
)
{
return
false
;
}
return
PImageBridgeParent
:
:
AllocShmem
(
aSize
aType
aShmem
)
;
}
bool
ImageBridgeParent
:
:
AllocUnsafeShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
if
(
mClosed
)
{
return
false
;
}
return
PImageBridgeParent
:
:
AllocUnsafeShmem
(
aSize
aType
aShmem
)
;
}
void
ImageBridgeParent
:
:
DeallocShmem
(
ipc
:
:
Shmem
&
aShmem
)
{
if
(
mClosed
)
{
return
;
}
PImageBridgeParent
:
:
DeallocShmem
(
aShmem
)
;
}
bool
ImageBridgeParent
:
:
IsSameProcess
(
)
const
{
return
OtherPid
(
)
=
=
base
:
:
GetCurrentProcId
(
)
;
}
void
ImageBridgeParent
:
:
ReplyRemoveTexture
(
const
OpReplyRemoveTexture
&
aReply
)
{
mPendingAsyncMessage
.
push_back
(
aReply
)
;
}
void
ImageBridgeParent
:
:
ReplyRemoveTexture
(
base
:
:
ProcessId
aChildProcessId
const
OpReplyRemoveTexture
&
aReply
)
{
ImageBridgeParent
*
imageBridge
=
ImageBridgeParent
:
:
GetInstance
(
aChildProcessId
)
;
if
(
!
imageBridge
)
{
return
;
}
imageBridge
-
>
ReplyRemoveTexture
(
aReply
)
;
}
void
ImageBridgeParent
:
:
SendFenceHandleIfPresent
(
PTextureParent
*
aTexture
)
{
RefPtr
<
TextureHost
>
texture
=
TextureHost
:
:
AsTextureHost
(
aTexture
)
;
if
(
!
texture
|
|
!
texture
-
>
NeedsFenceHandle
(
)
)
{
return
;
}
FenceHandle
fence
=
texture
-
>
GetCompositorReleaseFence
(
)
;
if
(
fence
.
IsValid
(
)
)
{
mPendingAsyncMessage
.
push_back
(
OpDeliverFence
(
aTexture
nullptr
fence
)
)
;
}
fence
=
texture
-
>
GetAndResetReleaseFenceHandle
(
)
;
if
(
fence
.
IsValid
(
)
)
{
mPendingAsyncMessage
.
push_back
(
OpDeliverFence
(
aTexture
nullptr
fence
)
)
;
}
}
void
ImageBridgeParent
:
:
AppendDeliverFenceMessage
(
uint64_t
aDestHolderId
uint64_t
aTransactionId
PTextureParent
*
aTexture
)
{
RefPtr
<
TextureHost
>
texture
=
TextureHost
:
:
AsTextureHost
(
aTexture
)
;
if
(
!
texture
|
|
!
texture
-
>
NeedsFenceHandle
(
)
)
{
return
;
}
FenceHandle
fence
=
texture
-
>
GetCompositorReleaseFence
(
)
;
if
(
fence
.
IsValid
(
)
)
{
mPendingAsyncMessage
.
push_back
(
OpDeliverFenceToTracker
(
aDestHolderId
aTransactionId
fence
)
)
;
}
fence
=
texture
-
>
GetAndResetReleaseFenceHandle
(
)
;
if
(
fence
.
IsValid
(
)
)
{
mPendingAsyncMessage
.
push_back
(
OpDeliverFenceToTracker
(
aDestHolderId
aTransactionId
fence
)
)
;
}
}
void
ImageBridgeParent
:
:
AppendDeliverFenceMessage
(
base
:
:
ProcessId
aChildProcessId
uint64_t
aDestHolderId
uint64_t
aTransactionId
PTextureParent
*
aTexture
)
{
ImageBridgeParent
*
imageBridge
=
ImageBridgeParent
:
:
GetInstance
(
aChildProcessId
)
;
if
(
!
imageBridge
)
{
return
;
}
imageBridge
-
>
AppendDeliverFenceMessage
(
aDestHolderId
aTransactionId
aTexture
)
;
}
void
ImageBridgeParent
:
:
SendPendingAsyncMessages
(
base
:
:
ProcessId
aChildProcessId
)
{
ImageBridgeParent
*
imageBridge
=
ImageBridgeParent
:
:
GetInstance
(
aChildProcessId
)
;
if
(
!
imageBridge
)
{
return
;
}
imageBridge
-
>
SendPendingAsyncMessages
(
)
;
}
}
}
