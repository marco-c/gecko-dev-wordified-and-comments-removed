#
include
"
CompositorThread
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
CompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
CompositorManagerParent
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeParent
.
h
"
#
include
"
mozilla
/
media
/
MediaSystemResourceService
.
h
"
namespace
mozilla
{
namespace
gfx
{
void
ReleaseVRManagerParentSingleton
(
)
;
}
namespace
layers
{
static
StaticRefPtr
<
CompositorThreadHolder
>
sCompositorThreadHolder
;
static
bool
sFinishedCompositorShutDown
=
false
;
CompositorThreadHolder
*
GetCompositorThreadHolder
(
)
{
return
sCompositorThreadHolder
;
}
base
:
:
Thread
*
CompositorThread
(
)
{
return
sCompositorThreadHolder
?
sCompositorThreadHolder
-
>
GetCompositorThread
(
)
:
nullptr
;
}
MessageLoop
*
CompositorThreadHolder
:
:
Loop
(
)
{
return
CompositorThread
(
)
?
CompositorThread
(
)
-
>
message_loop
(
)
:
nullptr
;
}
CompositorThreadHolder
*
CompositorThreadHolder
:
:
GetSingleton
(
)
{
return
sCompositorThreadHolder
;
}
CompositorThreadHolder
:
:
CompositorThreadHolder
(
)
:
mCompositorThread
(
CreateCompositorThread
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
CompositorThreadHolder
:
:
~
CompositorThreadHolder
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mCompositorThread
)
{
DestroyCompositorThread
(
mCompositorThread
)
;
}
}
void
CompositorThreadHolder
:
:
DestroyCompositorThread
(
base
:
:
Thread
*
aCompositorThread
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
sCompositorThreadHolder
"
We
shouldn
'
t
be
destroying
the
compositor
thread
yet
.
"
)
;
CompositorBridgeParent
:
:
Shutdown
(
)
;
delete
aCompositorThread
;
sFinishedCompositorShutDown
=
true
;
}
base
:
:
Thread
*
CompositorThreadHolder
:
:
CreateCompositorThread
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
sCompositorThreadHolder
"
The
compositor
thread
has
already
been
started
!
"
)
;
base
:
:
Thread
*
compositorThread
=
new
base
:
:
Thread
(
"
Compositor
"
)
;
base
:
:
Thread
:
:
Options
options
;
options
.
transient_hang_timeout
=
128
;
options
.
permanent_hang_timeout
=
2048
;
#
if
defined
(
_WIN32
)
options
.
message_loop_type
=
MessageLoop
:
:
TYPE_UI
;
#
endif
if
(
!
compositorThread
-
>
StartWithOptions
(
options
)
)
{
delete
compositorThread
;
return
nullptr
;
}
CompositorBridgeParent
:
:
Setup
(
)
;
ImageBridgeParent
:
:
Setup
(
)
;
return
compositorThread
;
}
void
CompositorThreadHolder
:
:
Start
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Should
be
on
the
main
Thread
!
"
)
;
MOZ_ASSERT
(
!
sCompositorThreadHolder
"
The
compositor
thread
has
already
been
started
!
"
)
;
sCompositorThreadHolder
=
new
CompositorThreadHolder
(
)
;
if
(
!
sCompositorThreadHolder
-
>
GetCompositorThread
(
)
)
{
gfxCriticalNote
<
<
"
Compositor
thread
not
started
(
"
<
<
XRE_IsParentProcess
(
)
<
<
"
)
"
;
sCompositorThreadHolder
=
nullptr
;
}
}
void
CompositorThreadHolder
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Should
be
on
the
main
Thread
!
"
)
;
if
(
!
sCompositorThreadHolder
)
{
return
;
}
ImageBridgeParent
:
:
Shutdown
(
)
;
gfx
:
:
ReleaseVRManagerParentSingleton
(
)
;
MediaSystemResourceService
:
:
Shutdown
(
)
;
CompositorManagerParent
:
:
Shutdown
(
)
;
sCompositorThreadHolder
=
nullptr
;
SpinEventLoopUntil
(
[
&
]
(
)
{
return
sFinishedCompositorShutDown
;
}
)
;
CompositorBridgeParent
:
:
FinishShutdown
(
)
;
}
bool
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
{
return
CompositorThread
(
)
&
&
CompositorThread
(
)
-
>
thread_id
(
)
=
=
PlatformThread
:
:
CurrentId
(
)
;
}
}
}
bool
NS_IsInCompositorThread
(
)
{
return
mozilla
:
:
layers
:
:
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
;
}
