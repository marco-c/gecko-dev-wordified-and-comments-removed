#
include
"
CompositorThread
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
CompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
CanvasTranslator
.
h
"
#
include
"
mozilla
/
layers
/
CompositorManagerParent
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeParent
.
h
"
#
include
"
mozilla
/
media
/
MediaSystemResourceService
.
h
"
#
include
"
VRManagerParent
.
h
"
namespace
mozilla
{
namespace
layers
{
static
StaticRefPtr
<
CompositorThreadHolder
>
sCompositorThreadHolder
;
static
bool
sFinishedCompositorShutDown
=
false
;
nsISerialEventTarget
*
CompositorThread
(
)
{
return
sCompositorThreadHolder
?
sCompositorThreadHolder
-
>
GetCompositorThread
(
)
:
nullptr
;
}
CompositorThreadHolder
*
CompositorThreadHolder
:
:
GetSingleton
(
)
{
return
sCompositorThreadHolder
;
}
CompositorThreadHolder
:
:
CompositorThreadHolder
(
)
:
mCompositorThread
(
CreateCompositorThread
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
CompositorThreadHolder
:
:
~
CompositorThreadHolder
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
sFinishedCompositorShutDown
=
true
;
}
already_AddRefed
<
nsIThread
>
CompositorThreadHolder
:
:
CreateCompositorThread
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
sCompositorThreadHolder
"
The
compositor
thread
has
already
been
started
!
"
)
;
nsCOMPtr
<
nsIThread
>
compositorThread
;
nsresult
rv
=
NS_NewNamedThread
(
"
Compositor
"
getter_AddRefs
(
compositorThread
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
CompositorBridgeParent
:
:
Setup
(
)
;
ImageBridgeParent
:
:
Setup
(
)
;
return
compositorThread
.
forget
(
)
;
}
void
CompositorThreadHolder
:
:
Start
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Should
be
on
the
main
Thread
!
"
)
;
MOZ_ASSERT
(
!
sCompositorThreadHolder
"
The
compositor
thread
has
already
been
started
!
"
)
;
sCompositorThreadHolder
=
new
CompositorThreadHolder
(
)
;
if
(
!
sCompositorThreadHolder
-
>
GetCompositorThread
(
)
)
{
gfxCriticalNote
<
<
"
Compositor
thread
not
started
(
"
<
<
XRE_IsParentProcess
(
)
<
<
"
)
"
;
sCompositorThreadHolder
=
nullptr
;
}
}
void
CompositorThreadHolder
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Should
be
on
the
main
Thread
!
"
)
;
if
(
!
sCompositorThreadHolder
)
{
return
;
}
ImageBridgeParent
:
:
Shutdown
(
)
;
gfx
:
:
VRManagerParent
:
:
Shutdown
(
)
;
MediaSystemResourceService
:
:
Shutdown
(
)
;
CompositorManagerParent
:
:
Shutdown
(
)
;
CanvasTranslator
:
:
Shutdown
(
)
;
sCompositorThreadHolder
=
nullptr
;
SpinEventLoopUntil
(
[
&
]
(
)
{
return
sFinishedCompositorShutDown
;
}
)
;
CompositorBridgeParent
:
:
FinishShutdown
(
)
;
}
bool
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
{
if
(
!
CompositorThread
(
)
)
{
return
false
;
}
bool
in
=
false
;
MOZ_ALWAYS_SUCCEEDS
(
CompositorThread
(
)
-
>
IsOnCurrentThread
(
&
in
)
)
;
return
in
;
}
}
}
bool
NS_IsInCompositorThread
(
)
{
return
mozilla
:
:
layers
:
:
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
;
}
