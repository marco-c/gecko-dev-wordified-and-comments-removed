#
ifndef
IPC_GonkNativeHandle_h
#
define
IPC_GonkNativeHandle_h
#
ifdef
MOZ_WIDGET_GONK
#
include
<
cutils
/
native_handle
.
h
>
#
endif
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsISupportsImpl
.
h
"
namespace
mozilla
{
namespace
layers
{
#
ifdef
MOZ_WIDGET_GONK
class
GonkNativeHandle
{
public
:
class
NhObj
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
NhObj
)
friend
class
GonkNativeHandle
;
public
:
NhObj
(
)
:
mHandle
(
nullptr
)
{
}
explicit
NhObj
(
native_handle_t
*
aHandle
)
:
mHandle
(
aHandle
)
{
}
native_handle_t
*
GetAndResetNativeHandle
(
)
{
native_handle_t
*
handle
=
mHandle
;
mHandle
=
nullptr
;
return
handle
;
}
private
:
virtual
~
NhObj
(
)
{
if
(
mHandle
)
{
native_handle_close
(
mHandle
)
;
native_handle_delete
(
mHandle
)
;
}
}
native_handle_t
*
mHandle
;
}
;
GonkNativeHandle
(
)
;
explicit
GonkNativeHandle
(
NhObj
*
aNhObj
)
;
bool
operator
=
=
(
const
GonkNativeHandle
&
aOther
)
const
{
return
mNhObj
.
get
(
)
=
=
aOther
.
mNhObj
.
get
(
)
;
}
bool
IsValid
(
)
const
{
return
mNhObj
&
&
mNhObj
-
>
mHandle
;
}
void
TransferToAnother
(
GonkNativeHandle
&
aHandle
)
;
already_AddRefed
<
NhObj
>
GetAndResetNhObj
(
)
;
already_AddRefed
<
NhObj
>
GetDupNhObj
(
)
;
native_handle_t
*
GetRawNativeHandle
(
)
const
{
if
(
mNhObj
)
{
return
mNhObj
-
>
mHandle
;
}
return
nullptr
;
}
private
:
RefPtr
<
NhObj
>
mNhObj
;
}
;
#
else
struct
GonkNativeHandle
{
bool
operator
=
=
(
const
GonkNativeHandle
&
)
const
{
return
false
;
}
}
;
#
endif
}
}
#
endif
