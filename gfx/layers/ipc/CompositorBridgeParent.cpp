#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
<
stdio
.
h
>
#
include
<
stdint
.
h
>
#
include
<
map
>
#
include
<
utility
>
#
include
"
LayerTransactionParent
.
h
"
#
include
"
RenderTrace
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
process
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
base
/
thread
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
TreeTraversal
.
h
"
#
ifdef
MOZ_WIDGET_GTK
#
include
"
gfxPlatformGtk
.
h
"
#
endif
#
include
"
gfxPrefs
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
TabParent
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
GPUChild
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
VRManager
.
h
"
#
include
"
mozilla
/
ipc
/
Transport
.
h
"
#
include
"
mozilla
/
layers
/
APZCTreeManager
.
h
"
#
include
"
mozilla
/
layers
/
APZCTreeManagerParent
.
h
"
#
include
"
mozilla
/
layers
/
APZThreadUtils
.
h
"
#
include
"
mozilla
/
layers
/
AsyncCompositionManager
.
h
"
#
include
"
mozilla
/
layers
/
BasicCompositor
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
layers
/
CompositorOGL
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
CompositorVsyncScheduler
.
h
"
#
include
"
mozilla
/
layers
/
CrossProcessCompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
FrameUniformityData
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
LayerManagerComposite
.
h
"
#
include
"
mozilla
/
layers
/
LayerTreeOwnerTracker
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
PLayerTransactionParent
.
h
"
#
include
"
mozilla
/
layers
/
RemoteContentController
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderCompositorOGL
.
h
"
#
include
"
mozilla
/
layout
/
RenderFrameParent
.
h
"
#
include
"
mozilla
/
media
/
MediaSystemResourceService
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
ifdef
MOZ_WIDGET_GTK
#
include
"
basic
/
X11BasicCompositor
.
h
"
#
endif
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
ifdef
XP_WIN
#
include
"
mozilla
/
layers
/
CompositorD3D11
.
h
"
#
include
"
mozilla
/
layers
/
CompositorD3D9
.
h
"
#
endif
#
include
"
GeckoProfiler
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolTypes
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Hal
.
h
"
#
include
"
mozilla
/
HalTypes
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
ifdef
MOZ_ENABLE_PROFILER_SPS
#
include
"
ProfilerMarkers
.
h
"
#
endif
#
include
"
mozilla
/
VsyncDispatcher
.
h
"
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
#
include
"
VsyncSource
.
h
"
#
endif
#
include
"
mozilla
/
widget
/
CompositorWidget
.
h
"
#
ifdef
MOZ_WIDGET_SUPPORTS_OOP_COMPOSITING
#
include
"
mozilla
/
widget
/
CompositorWidgetParent
.
h
"
#
endif
#
include
"
LayerScope
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
mozilla
:
:
ipc
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
std
;
using
base
:
:
ProcessId
;
using
base
:
:
Thread
;
ProcessId
CompositorBridgeParentBase
:
:
GetChildProcessId
(
)
{
return
OtherPid
(
)
;
}
void
CompositorBridgeParentBase
:
:
NotifyNotUsed
(
PTextureParent
*
aTexture
uint64_t
aTransactionId
)
{
RefPtr
<
TextureHost
>
texture
=
TextureHost
:
:
AsTextureHost
(
aTexture
)
;
if
(
!
texture
)
{
return
;
}
if
(
!
(
texture
-
>
GetFlags
(
)
&
TextureFlags
:
:
RECYCLE
)
)
{
return
;
}
uint64_t
textureId
=
TextureHost
:
:
GetTextureSerial
(
aTexture
)
;
mPendingAsyncMessage
.
push_back
(
OpNotifyNotUsed
(
textureId
aTransactionId
)
)
;
}
void
CompositorBridgeParentBase
:
:
SendAsyncMessage
(
const
InfallibleTArray
<
AsyncParentMessageData
>
&
aMessage
)
{
Unused
<
<
SendParentAsyncMessages
(
aMessage
)
;
}
bool
CompositorBridgeParentBase
:
:
AllocShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
return
PCompositorBridgeParent
:
:
AllocShmem
(
aSize
aType
aShmem
)
;
}
bool
CompositorBridgeParentBase
:
:
AllocUnsafeShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
return
PCompositorBridgeParent
:
:
AllocUnsafeShmem
(
aSize
aType
aShmem
)
;
}
void
CompositorBridgeParentBase
:
:
DeallocShmem
(
ipc
:
:
Shmem
&
aShmem
)
{
PCompositorBridgeParent
:
:
DeallocShmem
(
aShmem
)
;
}
base
:
:
ProcessId
CompositorBridgeParentBase
:
:
RemotePid
(
)
{
return
OtherPid
(
)
;
}
bool
CompositorBridgeParentBase
:
:
StartSharingMetrics
(
ipc
:
:
SharedMemoryBasic
:
:
Handle
aHandle
CrossProcessMutexHandle
aMutexHandle
uint64_t
aLayersId
uint32_t
aApzcId
)
{
return
PCompositorBridgeParent
:
:
SendSharedCompositorFrameMetrics
(
aHandle
aMutexHandle
aLayersId
aApzcId
)
;
}
bool
CompositorBridgeParentBase
:
:
StopSharingMetrics
(
FrameMetrics
:
:
ViewID
aScrollId
uint32_t
aApzcId
)
{
return
PCompositorBridgeParent
:
:
SendReleaseSharedCompositorFrameMetrics
(
aScrollId
aApzcId
)
;
}
CompositorBridgeParent
:
:
LayerTreeState
:
:
LayerTreeState
(
)
:
mApzcTreeManagerParent
(
nullptr
)
mParent
(
nullptr
)
mLayerManager
(
nullptr
)
mCrossProcessParent
(
nullptr
)
mLayerTree
(
nullptr
)
mUpdatedPluginDataAvailable
(
false
)
mPendingCompositorUpdates
(
0
)
{
}
CompositorBridgeParent
:
:
LayerTreeState
:
:
~
LayerTreeState
(
)
{
if
(
mController
)
{
mController
-
>
Destroy
(
)
;
}
}
typedef
map
<
uint64_t
CompositorBridgeParent
:
:
LayerTreeState
>
LayerTreeMap
;
LayerTreeMap
sIndirectLayerTrees
;
StaticAutoPtr
<
mozilla
:
:
Monitor
>
sIndirectLayerTreesLock
;
static
void
EnsureLayerTreeMapReady
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
sIndirectLayerTreesLock
)
{
sIndirectLayerTreesLock
=
new
Monitor
(
"
IndirectLayerTree
"
)
;
mozilla
:
:
ClearOnShutdown
(
&
sIndirectLayerTreesLock
)
;
}
}
template
<
typename
Lambda
>
inline
void
CompositorBridgeParent
:
:
ForEachIndirectLayerTree
(
const
Lambda
&
aCallback
)
{
sIndirectLayerTreesLock
-
>
AssertCurrentThreadOwns
(
)
;
for
(
auto
it
=
sIndirectLayerTrees
.
begin
(
)
;
it
!
=
sIndirectLayerTrees
.
end
(
)
;
it
+
+
)
{
LayerTreeState
*
state
=
&
it
-
>
second
;
if
(
state
-
>
mParent
=
=
this
)
{
aCallback
(
state
it
-
>
first
)
;
}
}
}
typedef
map
<
uint64_t
CompositorBridgeParent
*
>
CompositorMap
;
static
StaticAutoPtr
<
CompositorMap
>
sCompositorMap
;
void
CompositorBridgeParent
:
:
Setup
(
)
{
EnsureLayerTreeMapReady
(
)
;
MOZ_ASSERT
(
!
sCompositorMap
)
;
sCompositorMap
=
new
CompositorMap
;
gfxPrefs
:
:
SetWebRenderProfilerEnabledChangeCallback
(
[
]
(
const
GfxPrefValue
&
aValue
)
-
>
void
{
CompositorBridgeParent
:
:
SetWebRenderProfilerEnabled
(
aValue
.
get_bool
(
)
)
;
}
)
;
}
void
CompositorBridgeParent
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
sCompositorMap
)
;
MOZ_ASSERT
(
sCompositorMap
-
>
empty
(
)
)
;
sCompositorMap
=
nullptr
;
gfxPrefs
:
:
SetWebRenderProfilerEnabledChangeCallback
(
nullptr
)
;
}
void
CompositorBridgeParent
:
:
FinishShutdown
(
)
{
sIndirectLayerTrees
.
clear
(
)
;
}
static
void
SetThreadPriority
(
)
{
hal
:
:
SetCurrentThreadPriority
(
hal
:
:
THREAD_PRIORITY_COMPOSITOR
)
;
}
#
ifdef
COMPOSITOR_PERFORMANCE_WARNING
static
int32_t
CalculateCompositionFrameRate
(
)
{
const
int32_t
defaultFrameRate
=
60
;
int32_t
compositionFrameRatePref
=
gfxPrefs
:
:
LayersCompositionFrameRate
(
)
;
if
(
compositionFrameRatePref
<
0
)
{
int32_t
layoutFrameRatePref
=
gfxPrefs
:
:
LayoutFrameRate
(
)
;
if
(
layoutFrameRatePref
<
0
)
{
return
defaultFrameRate
;
}
return
layoutFrameRatePref
;
}
return
compositionFrameRatePref
;
}
#
endif
static
inline
MessageLoop
*
CompositorLoop
(
)
{
return
CompositorThreadHolder
:
:
Loop
(
)
;
}
CompositorBridgeParent
:
:
CompositorBridgeParent
(
CSSToLayoutDeviceScale
aScale
const
TimeDuration
&
aVsyncRate
bool
aUseExternalSurfaceSize
const
gfx
:
:
IntSize
&
aSurfaceSize
)
:
mWidget
(
nullptr
)
mScale
(
aScale
)
mVsyncRate
(
aVsyncRate
)
mIsTesting
(
false
)
mPendingTransaction
(
0
)
mPaused
(
false
)
mUseExternalSurfaceSize
(
aUseExternalSurfaceSize
)
mEGLSurfaceSize
(
aSurfaceSize
)
mPauseCompositionMonitor
(
"
PauseCompositionMonitor
"
)
mResumeCompositionMonitor
(
"
ResumeCompositionMonitor
"
)
mResetCompositorMonitor
(
"
ResetCompositorMonitor
"
)
mRootLayerTreeID
(
0
)
mOverrideComposeReadiness
(
false
)
mForceCompositionTask
(
nullptr
)
mCompositorThreadHolder
(
CompositorThreadHolder
:
:
GetSingleton
(
)
)
mCompositorScheduler
(
nullptr
)
mPaintTime
(
TimeDuration
:
:
Forever
(
)
)
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
mLastPluginUpdateLayerTreeId
(
0
)
mDeferPluginWindows
(
false
)
mPluginWindowsHidden
(
false
)
#
endif
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
void
CompositorBridgeParent
:
:
InitSameProcess
(
widget
:
:
CompositorWidget
*
aWidget
const
uint64_t
&
aLayerTreeId
bool
aUseAPZ
)
{
mWidget
=
aWidget
;
mRootLayerTreeID
=
aLayerTreeId
;
if
(
aUseAPZ
)
{
mApzcTreeManager
=
new
APZCTreeManager
(
)
;
}
SetOtherProcessId
(
base
:
:
GetCurrentProcId
(
)
)
;
mSelfRef
=
this
;
Initialize
(
)
;
}
bool
CompositorBridgeParent
:
:
Bind
(
Endpoint
<
PCompositorBridgeParent
>
&
&
aEndpoint
)
{
if
(
!
aEndpoint
.
Bind
(
this
)
)
{
return
false
;
}
mSelfRef
=
this
;
return
true
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvInitialize
(
const
uint64_t
&
aRootLayerTreeId
)
{
mRootLayerTreeID
=
aRootLayerTreeId
;
Initialize
(
)
;
return
IPC_OK
(
)
;
}
void
CompositorBridgeParent
:
:
Initialize
(
)
{
MOZ_ASSERT
(
CompositorThread
(
)
"
The
compositor
thread
must
be
Initialized
before
instanciating
a
CompositorBridgeParent
.
"
)
;
mCompositorID
=
0
;
MOZ_ASSERT
(
CompositorLoop
(
)
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
&
AddCompositor
this
&
mCompositorID
)
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
SetThreadPriority
)
)
;
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
sIndirectLayerTrees
[
mRootLayerTreeID
]
.
mParent
=
this
;
}
LayerScope
:
:
SetPixelScale
(
mScale
.
scale
)
;
if
(
!
gfxPrefs
:
:
WebRenderEnabled
(
)
)
{
mCompositorScheduler
=
new
CompositorVsyncScheduler
(
this
mWidget
)
;
}
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvReset
(
nsTArray
<
LayersBackend
>
&
&
aBackendHints
const
uint64_t
&
aSeqNo
bool
*
aResult
TextureFactoryIdentifier
*
aOutIdentifier
)
{
Maybe
<
TextureFactoryIdentifier
>
newIdentifier
;
ResetCompositorTask
(
aBackendHints
aSeqNo
&
newIdentifier
)
;
if
(
newIdentifier
)
{
*
aResult
=
true
;
*
aOutIdentifier
=
newIdentifier
.
value
(
)
;
}
else
{
*
aResult
=
false
;
}
return
IPC_OK
(
)
;
}
uint64_t
CompositorBridgeParent
:
:
RootLayerTreeId
(
)
{
MOZ_ASSERT
(
mRootLayerTreeID
)
;
return
mRootLayerTreeID
;
}
CompositorBridgeParent
:
:
~
CompositorBridgeParent
(
)
{
InfallibleTArray
<
PTextureParent
*
>
textures
;
ManagedPTextureParent
(
textures
)
;
MOZ_DIAGNOSTIC_ASSERT
(
textures
.
Length
(
)
=
=
0
)
;
for
(
unsigned
int
i
=
0
;
i
<
textures
.
Length
(
)
;
+
+
i
)
{
RefPtr
<
TextureHost
>
tex
=
TextureHost
:
:
AsTextureHost
(
textures
[
i
]
)
;
tex
-
>
DeallocateDeviceData
(
)
;
}
}
void
CompositorBridgeParent
:
:
ForceIsFirstPaint
(
)
{
mCompositionManager
-
>
ForceIsFirstPaint
(
)
;
}
void
CompositorBridgeParent
:
:
StopAndClearResources
(
)
{
if
(
mForceCompositionTask
)
{
mForceCompositionTask
-
>
Cancel
(
)
;
mForceCompositionTask
=
nullptr
;
}
mPaused
=
true
;
if
(
mLayerManager
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
ForEachIndirectLayerTree
(
[
this
]
(
LayerTreeState
*
lts
uint64_t
)
-
>
void
{
mLayerManager
-
>
ClearCachedResources
(
lts
-
>
mRoot
)
;
lts
-
>
mLayerManager
=
nullptr
;
lts
-
>
mParent
=
nullptr
;
}
)
;
mLayerManager
-
>
Destroy
(
)
;
mLayerManager
=
nullptr
;
mCompositionManager
=
nullptr
;
}
if
(
mWRBridge
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
ForEachIndirectLayerTree
(
[
this
]
(
LayerTreeState
*
lts
uint64_t
)
-
>
void
{
if
(
lts
-
>
mWRBridge
)
{
lts
-
>
mWRBridge
-
>
Destroy
(
)
;
lts
-
>
mWRBridge
=
nullptr
;
}
lts
-
>
mParent
=
nullptr
;
}
)
;
mWRBridge
-
>
Destroy
(
)
;
mWRBridge
=
nullptr
;
}
if
(
mCompositor
)
{
mCompositor
-
>
DetachWidget
(
)
;
mCompositor
-
>
Destroy
(
)
;
mCompositor
=
nullptr
;
}
if
(
mCompositorScheduler
)
{
mCompositorScheduler
-
>
Destroy
(
)
;
mCompositorScheduler
=
nullptr
;
}
mWidget
=
nullptr
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvWillClose
(
)
{
StopAndClearResources
(
)
;
return
IPC_OK
(
)
;
}
void
CompositorBridgeParent
:
:
DeferredDestroy
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mCompositorThreadHolder
)
;
mCompositorThreadHolder
=
nullptr
;
mSelfRef
=
nullptr
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvPause
(
)
{
PauseComposition
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvResume
(
)
{
ResumeComposition
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvMakeSnapshot
(
const
SurfaceDescriptor
&
aInSnapshot
const
gfx
:
:
IntRect
&
aRect
)
{
RefPtr
<
DrawTarget
>
target
=
GetDrawTargetForDescriptor
(
aInSnapshot
gfx
:
:
BackendType
:
:
CAIRO
)
;
MOZ_ASSERT
(
target
)
;
if
(
!
target
)
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
ForceComposeToTarget
(
target
&
aRect
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvFlushRendering
(
)
{
if
(
mCompositorScheduler
-
>
NeedsComposite
(
)
)
{
CancelCurrentCompositeTask
(
)
;
ForceComposeToTarget
(
nullptr
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvForcePresent
(
)
{
if
(
mLayerManager
)
{
mLayerManager
-
>
ForcePresent
(
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvNotifyRegionInvalidated
(
const
nsIntRegion
&
aRegion
)
{
if
(
mLayerManager
)
{
mLayerManager
-
>
AddInvalidRegion
(
aRegion
)
;
}
return
IPC_OK
(
)
;
}
void
CompositorBridgeParent
:
:
Invalidate
(
)
{
if
(
mLayerManager
&
&
mLayerManager
-
>
GetRoot
(
)
)
{
mLayerManager
-
>
AddInvalidRegion
(
mLayerManager
-
>
GetRoot
(
)
-
>
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
.
GetBounds
(
)
)
;
}
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvStartFrameTimeRecording
(
const
int32_t
&
aBufferSize
uint32_t
*
aOutStartIndex
)
{
if
(
mLayerManager
)
{
*
aOutStartIndex
=
mLayerManager
-
>
StartFrameTimeRecording
(
aBufferSize
)
;
}
else
{
*
aOutStartIndex
=
0
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvStopFrameTimeRecording
(
const
uint32_t
&
aStartIndex
InfallibleTArray
<
float
>
*
intervals
)
{
if
(
mLayerManager
)
{
mLayerManager
-
>
StopFrameTimeRecording
(
aStartIndex
*
intervals
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvClearApproximatelyVisibleRegions
(
const
uint64_t
&
aLayersId
const
uint32_t
&
aPresShellId
)
{
ClearApproximatelyVisibleRegions
(
aLayersId
Some
(
aPresShellId
)
)
;
return
IPC_OK
(
)
;
}
void
CompositorBridgeParent
:
:
ClearApproximatelyVisibleRegions
(
const
uint64_t
&
aLayersId
const
Maybe
<
uint32_t
>
&
aPresShellId
)
{
if
(
mLayerManager
)
{
mLayerManager
-
>
ClearApproximatelyVisibleRegions
(
aLayersId
aPresShellId
)
;
ScheduleComposition
(
)
;
}
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvNotifyApproximatelyVisibleRegion
(
const
ScrollableLayerGuid
&
aGuid
const
CSSIntRegion
&
aRegion
)
{
if
(
mLayerManager
)
{
mLayerManager
-
>
UpdateApproximatelyVisibleRegion
(
aGuid
aRegion
)
;
ScheduleComposition
(
)
;
}
return
IPC_OK
(
)
;
}
void
CompositorBridgeParent
:
:
ActorDestroy
(
ActorDestroyReason
why
)
{
StopAndClearResources
(
)
;
RemoveCompositor
(
mCompositorID
)
;
mCompositionManager
=
nullptr
;
if
(
mApzcTreeManager
)
{
mApzcTreeManager
-
>
ClearTree
(
)
;
mApzcTreeManager
=
nullptr
;
}
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
sIndirectLayerTrees
.
erase
(
mRootLayerTreeID
)
;
}
mSelfRef
=
this
;
MessageLoop
:
:
current
(
)
-
>
PostTask
(
NewRunnableMethod
(
this
&
CompositorBridgeParent
:
:
DeferredDestroy
)
)
;
}
void
CompositorBridgeParent
:
:
ScheduleRenderOnCompositorThread
(
)
{
MOZ_ASSERT
(
CompositorLoop
(
)
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableMethod
(
this
&
CompositorBridgeParent
:
:
ScheduleComposition
)
)
;
}
void
CompositorBridgeParent
:
:
InvalidateOnCompositorThread
(
)
{
MOZ_ASSERT
(
CompositorLoop
(
)
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableMethod
(
this
&
CompositorBridgeParent
:
:
Invalidate
)
)
;
}
void
CompositorBridgeParent
:
:
PauseComposition
(
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
"
PauseComposition
(
)
can
only
be
called
on
the
compositor
thread
"
)
;
MonitorAutoLock
lock
(
mPauseCompositionMonitor
)
;
if
(
!
mPaused
)
{
mPaused
=
true
;
mCompositor
-
>
Pause
(
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
DidComposite
(
now
now
)
;
}
lock
.
NotifyAll
(
)
;
}
void
CompositorBridgeParent
:
:
ResumeComposition
(
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
"
ResumeComposition
(
)
can
only
be
called
on
the
compositor
thread
"
)
;
MonitorAutoLock
lock
(
mResumeCompositionMonitor
)
;
if
(
!
mCompositor
-
>
Resume
(
)
)
{
#
ifdef
MOZ_WIDGET_ANDROID
__android_log_print
(
ANDROID_LOG_INFO
"
CompositorBridgeParent
"
"
Unable
to
renew
compositor
surface
;
remaining
in
paused
state
"
)
;
#
endif
lock
.
NotifyAll
(
)
;
return
;
}
mPaused
=
false
;
Invalidate
(
)
;
mCompositorScheduler
-
>
ResumeComposition
(
)
;
lock
.
NotifyAll
(
)
;
}
void
CompositorBridgeParent
:
:
ForceComposition
(
)
{
mForceCompositionTask
=
nullptr
;
ScheduleRenderOnCompositorThread
(
)
;
}
void
CompositorBridgeParent
:
:
CancelCurrentCompositeTask
(
)
{
mCompositorScheduler
-
>
CancelCurrentCompositeTask
(
)
;
}
void
CompositorBridgeParent
:
:
SetEGLSurfaceSize
(
int
width
int
height
)
{
NS_ASSERTION
(
mUseExternalSurfaceSize
"
Compositor
created
without
UseExternalSurfaceSize
provided
"
)
;
mEGLSurfaceSize
.
SizeTo
(
width
height
)
;
if
(
mCompositor
)
{
mCompositor
-
>
SetDestinationSurfaceSize
(
gfx
:
:
IntSize
(
mEGLSurfaceSize
.
width
mEGLSurfaceSize
.
height
)
)
;
}
}
void
CompositorBridgeParent
:
:
ResumeCompositionAndResize
(
int
width
int
height
)
{
SetEGLSurfaceSize
(
width
height
)
;
ResumeComposition
(
)
;
}
void
CompositorBridgeParent
:
:
SchedulePauseOnCompositorThread
(
)
{
MonitorAutoLock
lock
(
mPauseCompositionMonitor
)
;
MOZ_ASSERT
(
CompositorLoop
(
)
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableMethod
(
this
&
CompositorBridgeParent
:
:
PauseComposition
)
)
;
lock
.
Wait
(
)
;
}
bool
CompositorBridgeParent
:
:
ScheduleResumeOnCompositorThread
(
)
{
MonitorAutoLock
lock
(
mResumeCompositionMonitor
)
;
MOZ_ASSERT
(
CompositorLoop
(
)
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableMethod
(
this
&
CompositorBridgeParent
:
:
ResumeComposition
)
)
;
lock
.
Wait
(
)
;
return
!
mPaused
;
}
bool
CompositorBridgeParent
:
:
ScheduleResumeOnCompositorThread
(
int
width
int
height
)
{
MonitorAutoLock
lock
(
mResumeCompositionMonitor
)
;
MOZ_ASSERT
(
CompositorLoop
(
)
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableMethod
<
int
int
>
(
this
&
CompositorBridgeParent
:
:
ResumeCompositionAndResize
width
height
)
)
;
lock
.
Wait
(
)
;
return
!
mPaused
;
}
void
CompositorBridgeParent
:
:
ScheduleTask
(
already_AddRefed
<
CancelableRunnable
>
task
int
time
)
{
if
(
time
=
=
0
)
{
MessageLoop
:
:
current
(
)
-
>
PostTask
(
Move
(
task
)
)
;
}
else
{
MessageLoop
:
:
current
(
)
-
>
PostDelayedTask
(
Move
(
task
)
time
)
;
}
}
void
CompositorBridgeParent
:
:
UpdatePaintTime
(
LayerTransactionParent
*
aLayerTree
const
TimeDuration
&
aPaintTime
)
{
if
(
!
mLayerManager
|
|
aPaintTime
.
ToMilliseconds
(
)
<
1
.
0
)
{
return
;
}
mLayerManager
-
>
SetPaintTime
(
aPaintTime
)
;
}
void
CompositorBridgeParent
:
:
NotifyShadowTreeTransaction
(
uint64_t
aId
bool
aIsFirstPaint
bool
aScheduleComposite
uint32_t
aPaintSequenceNumber
bool
aIsRepeatTransaction
bool
aHitTestUpdate
)
{
if
(
!
aIsRepeatTransaction
&
&
mLayerManager
&
&
mLayerManager
-
>
GetRoot
(
)
)
{
bool
pluginsUpdatedFlag
=
true
;
AutoResolveRefLayers
resolve
(
mCompositionManager
this
nullptr
&
pluginsUpdatedFlag
)
;
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
if
(
!
pluginsUpdatedFlag
)
{
mWaitForPluginsUntil
=
TimeStamp
(
)
;
mHaveBlockedForPlugins
=
false
;
}
#
endif
if
(
mApzcTreeManager
&
&
aHitTestUpdate
)
{
mApzcTreeManager
-
>
UpdateHitTestingTree
(
mRootLayerTreeID
mLayerManager
-
>
GetRoot
(
)
aIsFirstPaint
aId
aPaintSequenceNumber
)
;
}
mLayerManager
-
>
NotifyShadowTreeTransaction
(
)
;
}
if
(
aScheduleComposite
)
{
ScheduleComposition
(
)
;
}
}
void
CompositorBridgeParent
:
:
ScheduleComposition
(
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
if
(
mPaused
)
{
return
;
}
mCompositorScheduler
-
>
ScheduleComposition
(
)
;
}
void
CompositorBridgeParent
:
:
SetShadowProperties
(
Layer
*
aLayer
)
{
ForEachNode
<
ForwardIterator
>
(
aLayer
[
]
(
Layer
*
layer
)
{
if
(
Layer
*
maskLayer
=
layer
-
>
GetMaskLayer
(
)
)
{
SetShadowProperties
(
maskLayer
)
;
}
for
(
size_t
i
=
0
;
i
<
layer
-
>
GetAncestorMaskLayerCount
(
)
;
i
+
+
)
{
SetShadowProperties
(
layer
-
>
GetAncestorMaskLayerAt
(
i
)
)
;
}
HostLayer
*
layerCompositor
=
layer
-
>
AsHostLayer
(
)
;
layerCompositor
-
>
SetShadowBaseTransform
(
layer
-
>
GetBaseTransform
(
)
)
;
layerCompositor
-
>
SetShadowTransformSetByAnimation
(
false
)
;
layerCompositor
-
>
SetShadowVisibleRegion
(
layer
-
>
GetVisibleRegion
(
)
)
;
layerCompositor
-
>
SetShadowClipRect
(
layer
-
>
GetClipRect
(
)
)
;
layerCompositor
-
>
SetShadowOpacity
(
layer
-
>
GetOpacity
(
)
)
;
layerCompositor
-
>
SetShadowOpacitySetByAnimation
(
false
)
;
}
)
;
}
void
CompositorBridgeParent
:
:
CompositeToTarget
(
DrawTarget
*
aTarget
const
gfx
:
:
IntRect
*
aRect
)
{
profiler_tracing
(
"
Paint
"
"
Composite
"
TRACING_INTERVAL_START
)
;
PROFILER_LABEL
(
"
CompositorBridgeParent
"
"
Composite
"
js
:
:
ProfileEntry
:
:
Category
:
:
GRAPHICS
)
;
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
"
Composite
can
only
be
called
on
the
compositor
thread
"
)
;
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
#
ifdef
COMPOSITOR_PERFORMANCE_WARNING
TimeDuration
scheduleDelta
=
TimeStamp
:
:
Now
(
)
-
mCompositorScheduler
-
>
GetExpectedComposeStartTime
(
)
;
if
(
scheduleDelta
>
TimeDuration
:
:
FromMilliseconds
(
2
)
|
|
scheduleDelta
<
TimeDuration
:
:
FromMilliseconds
(
-
2
)
)
{
printf_stderr
(
"
Compositor
:
Compose
starting
off
schedule
by
%
4
.
1f
ms
\
n
"
scheduleDelta
.
ToMilliseconds
(
)
)
;
}
#
endif
if
(
!
CanComposite
(
)
)
{
TimeStamp
end
=
TimeStamp
:
:
Now
(
)
;
DidComposite
(
start
end
)
;
return
;
}
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
if
(
!
mWaitForPluginsUntil
.
IsNull
(
)
&
&
mWaitForPluginsUntil
>
start
)
{
mHaveBlockedForPlugins
=
true
;
ScheduleComposition
(
)
;
return
;
}
#
endif
bool
hasRemoteContent
=
false
;
bool
updatePluginsFlag
=
true
;
AutoResolveRefLayers
resolve
(
mCompositionManager
this
&
hasRemoteContent
&
updatePluginsFlag
)
;
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
if
(
!
hasRemoteContent
&
&
gfxVars
:
:
BrowserTabsRemoteAutostart
(
)
&
&
mCachedPluginData
.
Length
(
)
)
{
Unused
<
<
SendHideAllPlugins
(
GetWidget
(
)
-
>
GetWidgetKey
(
)
)
;
mCachedPluginData
.
Clear
(
)
;
}
#
endif
if
(
aTarget
)
{
mLayerManager
-
>
BeginTransactionWithDrawTarget
(
aTarget
*
aRect
)
;
}
else
{
mLayerManager
-
>
BeginTransaction
(
)
;
}
SetShadowProperties
(
mLayerManager
-
>
GetRoot
(
)
)
;
if
(
mForceCompositionTask
&
&
!
mOverrideComposeReadiness
)
{
if
(
mCompositionManager
-
>
ReadyForCompose
(
)
)
{
mForceCompositionTask
-
>
Cancel
(
)
;
mForceCompositionTask
=
nullptr
;
}
else
{
return
;
}
}
mCompositionManager
-
>
ComputeRotation
(
)
;
TimeStamp
time
=
mIsTesting
?
mTestTime
:
mCompositorScheduler
-
>
GetLastComposeTime
(
)
;
bool
requestNextFrame
=
mCompositionManager
-
>
TransformShadowTree
(
time
mVsyncRate
)
;
if
(
requestNextFrame
)
{
ScheduleComposition
(
)
;
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
if
(
!
mPluginWindowsHidden
&
&
mCachedPluginData
.
Length
(
)
)
{
mWaitForPluginsUntil
=
mCompositorScheduler
-
>
GetLastComposeTime
(
)
+
(
mVsyncRate
*
2
)
;
}
#
endif
}
RenderTraceLayers
(
mLayerManager
-
>
GetRoot
(
)
"
0000
"
)
;
#
ifdef
MOZ_DUMP_PAINTING
if
(
gfxPrefs
:
:
DumpHostLayers
(
)
)
{
printf_stderr
(
"
Painting
-
-
-
compositing
layer
tree
:
\
n
"
)
;
mLayerManager
-
>
Dump
(
true
)
;
}
#
endif
mLayerManager
-
>
SetDebugOverlayWantsNextFrame
(
false
)
;
mLayerManager
-
>
EndTransaction
(
time
)
;
if
(
!
aTarget
)
{
TimeStamp
end
=
TimeStamp
:
:
Now
(
)
;
DidComposite
(
start
end
)
;
}
if
(
!
mCompositor
-
>
GetCompositeUntilTime
(
)
.
IsNull
(
)
|
|
mLayerManager
-
>
DebugOverlayWantsNextFrame
(
)
)
{
ScheduleComposition
(
)
;
}
#
ifdef
COMPOSITOR_PERFORMANCE_WARNING
TimeDuration
executionTime
=
TimeStamp
:
:
Now
(
)
-
mCompositorScheduler
-
>
GetLastComposeTime
(
)
;
TimeDuration
frameBudget
=
TimeDuration
:
:
FromMilliseconds
(
15
)
;
int32_t
frameRate
=
CalculateCompositionFrameRate
(
)
;
if
(
frameRate
>
0
)
{
frameBudget
=
TimeDuration
:
:
FromSeconds
(
1
.
0
/
frameRate
)
;
}
if
(
executionTime
>
frameBudget
)
{
printf_stderr
(
"
Compositor
:
Composite
execution
took
%
4
.
1f
ms
\
n
"
executionTime
.
ToMilliseconds
(
)
)
;
}
#
endif
if
(
gfxPrefs
:
:
LayersCompositionFrameRate
(
)
=
=
0
|
|
mLayerManager
-
>
GetCompositor
(
)
-
>
GetDiagnosticTypes
(
)
&
DiagnosticTypes
:
:
FLASH_BORDERS
)
{
ScheduleComposition
(
)
;
}
mCompositor
-
>
SetCompositionTime
(
TimeStamp
(
)
)
;
mozilla
:
:
Telemetry
:
:
AccumulateTimeDelta
(
mozilla
:
:
Telemetry
:
:
COMPOSITE_TIME
start
)
;
profiler_tracing
(
"
Paint
"
"
Composite
"
TRACING_INTERVAL_END
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvRemotePluginsReady
(
)
{
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
mWaitForPluginsUntil
=
TimeStamp
(
)
;
if
(
mHaveBlockedForPlugins
)
{
mHaveBlockedForPlugins
=
false
;
ForceComposeToTarget
(
nullptr
)
;
}
else
{
ScheduleComposition
(
)
;
}
return
IPC_OK
(
)
;
#
else
NS_NOTREACHED
(
"
CompositorBridgeParent
:
:
RecvRemotePluginsReady
calls
"
"
unexpected
on
this
platform
.
"
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
#
endif
}
void
CompositorBridgeParent
:
:
ForceComposeToTarget
(
DrawTarget
*
aTarget
const
gfx
:
:
IntRect
*
aRect
)
{
PROFILER_LABEL
(
"
CompositorBridgeParent
"
"
ForceComposeToTarget
"
js
:
:
ProfileEntry
:
:
Category
:
:
GRAPHICS
)
;
AutoRestore
<
bool
>
override
(
mOverrideComposeReadiness
)
;
mOverrideComposeReadiness
=
true
;
mCompositorScheduler
-
>
ForceComposeToTarget
(
aTarget
aRect
)
;
}
PAPZCTreeManagerParent
*
CompositorBridgeParent
:
:
AllocPAPZCTreeManagerParent
(
const
uint64_t
&
aLayersId
)
{
MOZ_ASSERT
(
aLayersId
=
=
0
)
;
MOZ_ASSERT
(
!
mApzcTreeManager
)
;
mApzcTreeManager
=
new
APZCTreeManager
(
)
;
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
CompositorBridgeParent
:
:
LayerTreeState
&
state
=
sIndirectLayerTrees
[
mRootLayerTreeID
]
;
MOZ_ASSERT
(
state
.
mParent
)
;
MOZ_ASSERT
(
!
state
.
mApzcTreeManagerParent
)
;
state
.
mApzcTreeManagerParent
=
new
APZCTreeManagerParent
(
mRootLayerTreeID
state
.
mParent
-
>
GetAPZCTreeManager
(
)
)
;
return
state
.
mApzcTreeManagerParent
;
}
bool
CompositorBridgeParent
:
:
DeallocPAPZCTreeManagerParent
(
PAPZCTreeManagerParent
*
aActor
)
{
delete
aActor
;
return
true
;
}
PAPZParent
*
CompositorBridgeParent
:
:
AllocPAPZParent
(
const
uint64_t
&
aLayersId
)
{
MOZ_ASSERT
(
aLayersId
=
=
0
)
;
RemoteContentController
*
controller
=
new
RemoteContentController
(
)
;
controller
-
>
AddRef
(
)
;
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
CompositorBridgeParent
:
:
LayerTreeState
&
state
=
sIndirectLayerTrees
[
mRootLayerTreeID
]
;
MOZ_ASSERT
(
!
state
.
mController
)
;
state
.
mController
=
controller
;
return
controller
;
}
bool
CompositorBridgeParent
:
:
DeallocPAPZParent
(
PAPZParent
*
aActor
)
{
RemoteContentController
*
controller
=
static_cast
<
RemoteContentController
*
>
(
aActor
)
;
controller
-
>
Release
(
)
;
return
true
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvAsyncPanZoomEnabled
(
const
uint64_t
&
aLayersId
bool
*
aHasAPZ
)
{
MOZ_ASSERT
(
aLayersId
=
=
0
)
;
*
aHasAPZ
=
AsyncPanZoomEnabled
(
)
;
return
IPC_OK
(
)
;
}
RefPtr
<
APZCTreeManager
>
CompositorBridgeParent
:
:
GetAPZCTreeManager
(
)
{
return
mApzcTreeManager
;
}
bool
CompositorBridgeParent
:
:
CanComposite
(
)
{
return
mLayerManager
&
&
mLayerManager
-
>
GetRoot
(
)
&
&
!
mPaused
;
}
void
CompositorBridgeParent
:
:
ScheduleRotationOnCompositorThread
(
const
TargetConfig
&
aTargetConfig
bool
aIsFirstPaint
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
if
(
!
aIsFirstPaint
&
&
!
mCompositionManager
-
>
IsFirstPaint
(
)
&
&
mCompositionManager
-
>
RequiresReorientation
(
aTargetConfig
.
orientation
(
)
)
)
{
if
(
mForceCompositionTask
!
=
nullptr
)
{
mForceCompositionTask
-
>
Cancel
(
)
;
}
RefPtr
<
CancelableRunnable
>
task
=
NewCancelableRunnableMethod
(
this
&
CompositorBridgeParent
:
:
ForceComposition
)
;
mForceCompositionTask
=
task
;
ScheduleTask
(
task
.
forget
(
)
gfxPrefs
:
:
OrientationSyncMillis
(
)
)
;
}
}
void
CompositorBridgeParent
:
:
ShadowLayersUpdated
(
LayerTransactionParent
*
aLayerTree
const
uint64_t
&
aTransactionId
const
TargetConfig
&
aTargetConfig
const
InfallibleTArray
<
PluginWindowData
>
&
aUnused
bool
aIsFirstPaint
bool
aScheduleComposite
uint32_t
aPaintSequenceNumber
bool
aIsRepeatTransaction
int32_t
aPaintSyncId
bool
aHitTestUpdate
)
{
ScheduleRotationOnCompositorThread
(
aTargetConfig
aIsFirstPaint
)
;
mLayerManager
-
>
UpdateRenderBounds
(
aTargetConfig
.
naturalBounds
(
)
)
;
mLayerManager
-
>
SetRegionToClear
(
aTargetConfig
.
clearRegion
(
)
)
;
if
(
mLayerManager
-
>
GetCompositor
(
)
)
{
mLayerManager
-
>
GetCompositor
(
)
-
>
SetScreenRotation
(
aTargetConfig
.
rotation
(
)
)
;
}
mCompositionManager
-
>
Updated
(
aIsFirstPaint
aTargetConfig
aPaintSyncId
)
;
Layer
*
root
=
aLayerTree
-
>
GetRoot
(
)
;
mLayerManager
-
>
SetRoot
(
root
)
;
if
(
mApzcTreeManager
&
&
!
aIsRepeatTransaction
&
&
aHitTestUpdate
)
{
AutoResolveRefLayers
resolve
(
mCompositionManager
)
;
mApzcTreeManager
-
>
UpdateHitTestingTree
(
mRootLayerTreeID
root
aIsFirstPaint
mRootLayerTreeID
aPaintSequenceNumber
)
;
}
MOZ_ASSERT
(
aTransactionId
=
=
1
|
|
aTransactionId
>
mPendingTransaction
)
;
mPendingTransaction
=
aTransactionId
;
if
(
root
)
{
SetShadowProperties
(
root
)
;
}
if
(
aScheduleComposite
)
{
ScheduleComposition
(
)
;
if
(
mPaused
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
DidComposite
(
now
now
)
;
}
}
mLayerManager
-
>
NotifyShadowTreeTransaction
(
)
;
}
void
CompositorBridgeParent
:
:
ForceComposite
(
LayerTransactionParent
*
aLayerTree
)
{
ScheduleComposition
(
)
;
}
bool
CompositorBridgeParent
:
:
SetTestSampleTime
(
LayerTransactionParent
*
aLayerTree
const
TimeStamp
&
aTime
)
{
if
(
aTime
.
IsNull
(
)
)
{
return
false
;
}
mIsTesting
=
true
;
mTestTime
=
aTime
;
bool
testComposite
=
mCompositionManager
&
&
mCompositorScheduler
-
>
NeedsComposite
(
)
;
if
(
testComposite
)
{
AutoResolveRefLayers
resolve
(
mCompositionManager
)
;
bool
requestNextFrame
=
mCompositionManager
-
>
TransformShadowTree
(
aTime
mVsyncRate
)
;
if
(
!
requestNextFrame
)
{
CancelCurrentCompositeTask
(
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
DidComposite
(
now
now
)
;
}
}
return
true
;
}
void
CompositorBridgeParent
:
:
LeaveTestMode
(
LayerTransactionParent
*
aLayerTree
)
{
mIsTesting
=
false
;
}
void
CompositorBridgeParent
:
:
ApplyAsyncProperties
(
LayerTransactionParent
*
aLayerTree
)
{
if
(
aLayerTree
-
>
GetRoot
(
)
)
{
AutoResolveRefLayers
resolve
(
mCompositionManager
)
;
SetShadowProperties
(
mLayerManager
-
>
GetRoot
(
)
)
;
TimeStamp
time
=
mIsTesting
?
mTestTime
:
mCompositorScheduler
-
>
GetLastComposeTime
(
)
;
bool
requestNextFrame
=
mCompositionManager
-
>
TransformShadowTree
(
time
mVsyncRate
AsyncCompositionManager
:
:
TransformsToSkip
:
:
APZ
)
;
if
(
!
requestNextFrame
)
{
CancelCurrentCompositeTask
(
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
DidComposite
(
now
now
)
;
}
}
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvGetFrameUniformity
(
FrameUniformityData
*
aOutData
)
{
mCompositionManager
-
>
GetFrameUniformity
(
aOutData
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvRequestOverfill
(
)
{
uint32_t
overfillRatio
=
mCompositor
-
>
GetFillRatio
(
)
;
Unused
<
<
SendOverfill
(
overfillRatio
)
;
return
IPC_OK
(
)
;
}
void
CompositorBridgeParent
:
:
FlushApzRepaints
(
const
LayerTransactionParent
*
aLayerTree
)
{
MOZ_ASSERT
(
mApzcTreeManager
)
;
uint64_t
layersId
=
aLayerTree
-
>
GetId
(
)
;
if
(
layersId
=
=
0
)
{
layersId
=
mRootLayerTreeID
;
}
APZThreadUtils
:
:
RunOnControllerThread
(
NS_NewRunnableFunction
(
[
=
]
(
)
{
mApzcTreeManager
-
>
FlushApzRepaints
(
layersId
)
;
}
)
)
;
}
void
CompositorBridgeParent
:
:
GetAPZTestData
(
const
LayerTransactionParent
*
aLayerTree
APZTestData
*
aOutData
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
*
aOutData
=
sIndirectLayerTrees
[
mRootLayerTreeID
]
.
mApzTestData
;
}
void
CompositorBridgeParent
:
:
SetConfirmedTargetAPZC
(
const
LayerTransactionParent
*
aLayerTree
const
uint64_t
&
aInputBlockId
const
nsTArray
<
ScrollableLayerGuid
>
&
aTargets
)
{
if
(
!
mApzcTreeManager
)
{
return
;
}
void
(
APZCTreeManager
:
:
*
setTargetApzcFunc
)
(
uint64_t
const
nsTArray
<
ScrollableLayerGuid
>
&
)
=
&
APZCTreeManager
:
:
SetTargetAPZC
;
RefPtr
<
Runnable
>
task
=
NewRunnableMethod
<
uint64_t
StoreCopyPassByConstLRef
<
nsTArray
<
ScrollableLayerGuid
>
>
>
(
mApzcTreeManager
.
get
(
)
setTargetApzcFunc
aInputBlockId
aTargets
)
;
APZThreadUtils
:
:
RunOnControllerThread
(
task
.
forget
(
)
)
;
}
void
CompositorBridgeParent
:
:
InitializeLayerManager
(
const
nsTArray
<
LayersBackend
>
&
aBackendHints
)
{
NS_ASSERTION
(
!
mLayerManager
"
Already
initialised
mLayerManager
"
)
;
NS_ASSERTION
(
!
mCompositor
"
Already
initialised
mCompositor
"
)
;
mCompositor
=
NewCompositor
(
aBackendHints
)
;
if
(
!
mCompositor
)
{
return
;
}
mLayerManager
=
new
LayerManagerComposite
(
mCompositor
)
;
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
sIndirectLayerTrees
[
mRootLayerTreeID
]
.
mLayerManager
=
mLayerManager
;
}
RefPtr
<
Compositor
>
CompositorBridgeParent
:
:
NewCompositor
(
const
nsTArray
<
LayersBackend
>
&
aBackendHints
)
{
for
(
size_t
i
=
0
;
i
<
aBackendHints
.
Length
(
)
;
+
+
i
)
{
RefPtr
<
Compositor
>
compositor
;
if
(
aBackendHints
[
i
]
=
=
LayersBackend
:
:
LAYERS_OPENGL
)
{
compositor
=
new
CompositorOGL
(
this
mWidget
mEGLSurfaceSize
.
width
mEGLSurfaceSize
.
height
mUseExternalSurfaceSize
)
;
}
else
if
(
aBackendHints
[
i
]
=
=
LayersBackend
:
:
LAYERS_BASIC
)
{
#
ifdef
MOZ_WIDGET_GTK
if
(
gfxVars
:
:
UseXRender
(
)
)
{
compositor
=
new
X11BasicCompositor
(
this
mWidget
)
;
}
else
#
endif
{
compositor
=
new
BasicCompositor
(
this
mWidget
)
;
}
#
ifdef
XP_WIN
}
else
if
(
aBackendHints
[
i
]
=
=
LayersBackend
:
:
LAYERS_D3D11
)
{
compositor
=
new
CompositorD3D11
(
this
mWidget
)
;
}
else
if
(
aBackendHints
[
i
]
=
=
LayersBackend
:
:
LAYERS_D3D9
)
{
compositor
=
new
CompositorD3D9
(
this
mWidget
)
;
#
endif
}
nsCString
failureReason
;
if
(
compositor
&
&
compositor
-
>
Initialize
(
&
failureReason
)
)
{
if
(
failureReason
.
IsEmpty
(
)
)
{
failureReason
=
"
SUCCESS
"
;
}
if
(
aBackendHints
[
i
]
=
=
LayersBackend
:
:
LAYERS_OPENGL
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
OPENGL_COMPOSITING_FAILURE_ID
failureReason
)
;
}
#
ifdef
XP_WIN
else
if
(
aBackendHints
[
i
]
=
=
LayersBackend
:
:
LAYERS_D3D9
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
D3D9_COMPOSITING_FAILURE_ID
failureReason
)
;
}
else
if
(
aBackendHints
[
i
]
=
=
LayersBackend
:
:
LAYERS_D3D11
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
D3D11_COMPOSITING_FAILURE_ID
failureReason
)
;
}
#
endif
compositor
-
>
SetCompositorID
(
mCompositorID
)
;
return
compositor
;
}
if
(
aBackendHints
[
i
]
=
=
LayersBackend
:
:
LAYERS_OPENGL
)
{
gfxCriticalNote
<
<
"
[
OPENGL
]
Failed
to
init
compositor
with
reason
:
"
<
<
failureReason
.
get
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
OPENGL_COMPOSITING_FAILURE_ID
failureReason
)
;
}
#
ifdef
XP_WIN
else
if
(
aBackendHints
[
i
]
=
=
LayersBackend
:
:
LAYERS_D3D9
)
{
gfxCriticalNote
<
<
"
[
D3D9
]
Failed
to
init
compositor
with
reason
:
"
<
<
failureReason
.
get
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
D3D9_COMPOSITING_FAILURE_ID
failureReason
)
;
}
else
if
(
aBackendHints
[
i
]
=
=
LayersBackend
:
:
LAYERS_D3D11
)
{
gfxCriticalNote
<
<
"
[
D3D11
]
Failed
to
init
compositor
with
reason
:
"
<
<
failureReason
.
get
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
D3D11_COMPOSITING_FAILURE_ID
failureReason
)
;
}
#
endif
}
return
nullptr
;
}
PLayerTransactionParent
*
CompositorBridgeParent
:
:
AllocPLayerTransactionParent
(
const
nsTArray
<
LayersBackend
>
&
aBackendHints
const
uint64_t
&
aId
TextureFactoryIdentifier
*
aTextureFactoryIdentifier
bool
*
aSuccess
)
{
MOZ_ASSERT
(
aId
=
=
0
)
;
InitializeLayerManager
(
aBackendHints
)
;
if
(
!
mLayerManager
)
{
NS_WARNING
(
"
Failed
to
initialise
Compositor
"
)
;
*
aSuccess
=
false
;
LayerTransactionParent
*
p
=
new
LayerTransactionParent
(
nullptr
this
0
)
;
p
-
>
AddIPDLReference
(
)
;
return
p
;
}
mCompositionManager
=
new
AsyncCompositionManager
(
mLayerManager
)
;
*
aSuccess
=
true
;
*
aTextureFactoryIdentifier
=
mLayerManager
-
>
GetTextureFactoryIdentifier
(
)
;
LayerTransactionParent
*
p
=
new
LayerTransactionParent
(
mLayerManager
this
0
)
;
p
-
>
AddIPDLReference
(
)
;
return
p
;
}
bool
CompositorBridgeParent
:
:
DeallocPLayerTransactionParent
(
PLayerTransactionParent
*
actor
)
{
static_cast
<
LayerTransactionParent
*
>
(
actor
)
-
>
ReleaseIPDLReference
(
)
;
return
true
;
}
CompositorBridgeParent
*
CompositorBridgeParent
:
:
GetCompositorBridgeParent
(
uint64_t
id
)
{
CompositorMap
:
:
iterator
it
=
sCompositorMap
-
>
find
(
id
)
;
return
it
!
=
sCompositorMap
-
>
end
(
)
?
it
-
>
second
:
nullptr
;
}
void
CompositorBridgeParent
:
:
AddCompositor
(
CompositorBridgeParent
*
compositor
uint64_t
*
outID
)
{
static
uint64_t
sNextID
=
1
;
+
+
sNextID
;
(
*
sCompositorMap
)
[
sNextID
]
=
compositor
;
*
outID
=
sNextID
;
}
CompositorBridgeParent
*
CompositorBridgeParent
:
:
RemoveCompositor
(
uint64_t
id
)
{
CompositorMap
:
:
iterator
it
=
sCompositorMap
-
>
find
(
id
)
;
if
(
it
=
=
sCompositorMap
-
>
end
(
)
)
{
return
nullptr
;
}
CompositorBridgeParent
*
retval
=
it
-
>
second
;
sCompositorMap
-
>
erase
(
it
)
;
return
retval
;
}
void
CompositorBridgeParent
:
:
NotifyVsync
(
const
TimeStamp
&
aTimeStamp
const
uint64_t
&
aLayersId
)
{
MOZ_ASSERT
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_GPU
)
;
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
auto
it
=
sIndirectLayerTrees
.
find
(
aLayersId
)
;
if
(
it
=
=
sIndirectLayerTrees
.
end
(
)
)
return
;
CompositorBridgeParent
*
cbp
=
it
-
>
second
.
mParent
;
if
(
!
cbp
|
|
!
cbp
-
>
mWidget
)
return
;
RefPtr
<
VsyncObserver
>
obs
=
cbp
-
>
mWidget
-
>
GetVsyncObserver
(
)
;
if
(
!
obs
)
return
;
obs
-
>
NotifyVsync
(
aTimeStamp
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvNotifyChildCreated
(
const
uint64_t
&
child
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
NotifyChildCreated
(
child
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvNotifyChildRecreated
(
const
uint64_t
&
aChild
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
if
(
sIndirectLayerTrees
.
find
(
aChild
)
!
=
sIndirectLayerTrees
.
end
(
)
)
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
NotifyChildCreated
(
aChild
)
;
return
IPC_OK
(
)
;
}
void
CompositorBridgeParent
:
:
NotifyChildCreated
(
uint64_t
aChild
)
{
sIndirectLayerTreesLock
-
>
AssertCurrentThreadOwns
(
)
;
sIndirectLayerTrees
[
aChild
]
.
mParent
=
this
;
sIndirectLayerTrees
[
aChild
]
.
mLayerManager
=
mLayerManager
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvAdoptChild
(
const
uint64_t
&
child
)
{
APZCTreeManagerParent
*
parent
;
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
NotifyChildCreated
(
child
)
;
if
(
sIndirectLayerTrees
[
child
]
.
mLayerTree
)
{
sIndirectLayerTrees
[
child
]
.
mLayerTree
-
>
mLayerManager
=
mLayerManager
;
}
if
(
sIndirectLayerTrees
[
child
]
.
mRoot
)
{
sIndirectLayerTrees
[
child
]
.
mRoot
-
>
AsHostLayer
(
)
-
>
SetLayerManager
(
static_cast
<
HostLayerManager
*
>
(
mLayerManager
.
get
(
)
)
)
;
}
parent
=
sIndirectLayerTrees
[
child
]
.
mApzcTreeManagerParent
;
}
if
(
mApzcTreeManager
&
&
parent
)
{
parent
-
>
ChildAdopted
(
mApzcTreeManager
)
;
}
return
IPC_OK
(
)
;
}
PWebRenderBridgeParent
*
CompositorBridgeParent
:
:
AllocPWebRenderBridgeParent
(
const
uint64_t
&
aPipelineId
TextureFactoryIdentifier
*
aTextureFactoryIdentifier
)
{
#
ifndef
MOZ_ENABLE_WEBRENDER
MOZ_RELEASE_ASSERT
(
false
)
;
#
endif
MOZ_ASSERT
(
aPipelineId
=
=
mRootLayerTreeID
)
;
MOZ_ASSERT
(
!
mWRBridge
)
;
MOZ_ASSERT
(
!
mCompositor
)
;
MOZ_ASSERT
(
!
mCompositorScheduler
)
;
RefPtr
<
gl
:
:
GLContext
>
glc
(
gl
:
:
GLContextProvider
:
:
CreateForCompositorWidget
(
mWidget
true
)
)
;
mCompositor
=
new
WebRenderCompositorOGL
(
this
glc
.
get
(
)
)
;
mWRBridge
=
new
WebRenderBridgeParent
(
this
aPipelineId
mWidget
glc
.
get
(
)
nullptr
mCompositor
.
get
(
)
)
;
mCompositorScheduler
=
mWRBridge
-
>
CompositorScheduler
(
)
;
MOZ_ASSERT
(
mCompositorScheduler
)
;
mWRBridge
.
get
(
)
-
>
AddRef
(
)
;
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
MOZ_ASSERT
(
sIndirectLayerTrees
[
aPipelineId
]
.
mWRBridge
=
=
nullptr
)
;
sIndirectLayerTrees
[
aPipelineId
]
.
mWRBridge
=
mWRBridge
;
*
aTextureFactoryIdentifier
=
mCompositor
-
>
GetTextureFactoryIdentifier
(
)
;
return
mWRBridge
;
}
bool
CompositorBridgeParent
:
:
DeallocPWebRenderBridgeParent
(
PWebRenderBridgeParent
*
aActor
)
{
#
ifndef
MOZ_ENABLE_WEBRENDER
MOZ_RELEASE_ASSERT
(
false
)
;
#
endif
WebRenderBridgeParent
*
parent
=
static_cast
<
WebRenderBridgeParent
*
>
(
aActor
)
;
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
auto
it
=
sIndirectLayerTrees
.
find
(
parent
-
>
PipelineId
(
)
)
;
if
(
it
!
=
sIndirectLayerTrees
.
end
(
)
)
{
it
-
>
second
.
mWRBridge
=
nullptr
;
}
}
parent
-
>
Release
(
)
;
return
true
;
}
void
CompositorBridgeParent
:
:
SetWebRenderProfilerEnabled
(
bool
aEnabled
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
for
(
auto
it
=
sIndirectLayerTrees
.
begin
(
)
;
it
!
=
sIndirectLayerTrees
.
end
(
)
;
it
+
+
)
{
LayerTreeState
*
state
=
&
it
-
>
second
;
if
(
state
-
>
mWRBridge
)
{
state
-
>
mWRBridge
-
>
SetWebRenderProfilerEnabled
(
aEnabled
)
;
}
}
}
void
EraseLayerState
(
uint64_t
aId
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
auto
iter
=
sIndirectLayerTrees
.
find
(
aId
)
;
if
(
iter
!
=
sIndirectLayerTrees
.
end
(
)
)
{
CompositorBridgeParent
*
parent
=
iter
-
>
second
.
mParent
;
if
(
parent
)
{
parent
-
>
ClearApproximatelyVisibleRegions
(
aId
Nothing
(
)
)
;
}
sIndirectLayerTrees
.
erase
(
iter
)
;
}
}
void
CompositorBridgeParent
:
:
DeallocateLayerTreeId
(
uint64_t
aId
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
CompositorLoop
(
)
)
{
gfxCriticalError
(
)
<
<
"
Attempting
to
post
to
a
invalid
Compositor
Loop
"
;
return
;
}
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
&
EraseLayerState
aId
)
)
;
}
static
void
UpdateControllerForLayersId
(
uint64_t
aLayersId
GeckoContentController
*
aController
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
sIndirectLayerTrees
[
aLayersId
]
.
mController
=
already_AddRefed
<
GeckoContentController
>
(
aController
)
;
}
ScopedLayerTreeRegistration
:
:
ScopedLayerTreeRegistration
(
APZCTreeManager
*
aApzctm
uint64_t
aLayersId
Layer
*
aRoot
GeckoContentController
*
aController
)
:
mLayersId
(
aLayersId
)
{
EnsureLayerTreeMapReady
(
)
;
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
sIndirectLayerTrees
[
aLayersId
]
.
mRoot
=
aRoot
;
sIndirectLayerTrees
[
aLayersId
]
.
mController
=
aController
;
}
ScopedLayerTreeRegistration
:
:
~
ScopedLayerTreeRegistration
(
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
sIndirectLayerTrees
.
erase
(
mLayersId
)
;
}
void
CompositorBridgeParent
:
:
SetControllerForLayerTree
(
uint64_t
aLayersId
GeckoContentController
*
aController
)
{
aController
-
>
AddRef
(
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
&
UpdateControllerForLayersId
aLayersId
aController
)
)
;
}
already_AddRefed
<
APZCTreeManager
>
CompositorBridgeParent
:
:
GetAPZCTreeManager
(
uint64_t
aLayersId
)
{
EnsureLayerTreeMapReady
(
)
;
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
LayerTreeMap
:
:
iterator
cit
=
sIndirectLayerTrees
.
find
(
aLayersId
)
;
if
(
sIndirectLayerTrees
.
end
(
)
=
=
cit
)
{
return
nullptr
;
}
LayerTreeState
*
lts
=
&
cit
-
>
second
;
RefPtr
<
APZCTreeManager
>
apzctm
=
lts
-
>
mParent
?
lts
-
>
mParent
-
>
mApzcTreeManager
.
get
(
)
:
nullptr
;
return
apzctm
.
forget
(
)
;
}
static
void
InsertVsyncProfilerMarker
(
TimeStamp
aVsyncTimestamp
)
{
#
ifdef
MOZ_ENABLE_PROFILER_SPS
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
VsyncPayload
*
payload
=
new
VsyncPayload
(
aVsyncTimestamp
)
;
PROFILER_MARKER_PAYLOAD
(
"
VsyncTimestamp
"
payload
)
;
#
endif
}
void
CompositorBridgeParent
:
:
PostInsertVsyncProfilerMarker
(
TimeStamp
aVsyncTimestamp
)
{
if
(
profiler_is_active
(
)
&
&
CompositorThreadHolder
:
:
IsActive
(
)
)
{
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
InsertVsyncProfilerMarker
aVsyncTimestamp
)
)
;
}
}
widget
:
:
PCompositorWidgetParent
*
CompositorBridgeParent
:
:
AllocPCompositorWidgetParent
(
const
CompositorWidgetInitData
&
aInitData
)
{
#
if
defined
(
MOZ_WIDGET_SUPPORTS_OOP_COMPOSITING
)
if
(
mWidget
)
{
return
nullptr
;
}
widget
:
:
CompositorWidgetParent
*
widget
=
new
widget
:
:
CompositorWidgetParent
(
aInitData
)
;
widget
-
>
AddRef
(
)
;
mWidget
=
widget
;
return
widget
;
#
else
return
nullptr
;
#
endif
}
bool
CompositorBridgeParent
:
:
DeallocPCompositorWidgetParent
(
PCompositorWidgetParent
*
aActor
)
{
#
if
defined
(
MOZ_WIDGET_SUPPORTS_OOP_COMPOSITING
)
static_cast
<
widget
:
:
CompositorWidgetParent
*
>
(
aActor
)
-
>
Release
(
)
;
return
true
;
#
else
return
false
;
#
endif
}
bool
CompositorBridgeParent
:
:
IsPendingComposite
(
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
if
(
!
mCompositor
)
{
return
false
;
}
return
mCompositor
-
>
IsPendingComposite
(
)
;
}
void
CompositorBridgeParent
:
:
FinishPendingComposite
(
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
if
(
!
mCompositor
)
{
return
;
}
return
mCompositor
-
>
FinishPendingComposite
(
)
;
}
CompositorController
*
CompositorBridgeParent
:
:
LayerTreeState
:
:
GetCompositorController
(
)
const
{
return
mParent
;
}
MetricsSharingController
*
CompositorBridgeParent
:
:
LayerTreeState
:
:
CrossProcessSharingController
(
)
const
{
return
mCrossProcessParent
;
}
MetricsSharingController
*
CompositorBridgeParent
:
:
LayerTreeState
:
:
InProcessSharingController
(
)
const
{
return
mParent
;
}
void
CompositorBridgeParent
:
:
DidComposite
(
TimeStamp
&
aCompositeStart
TimeStamp
&
aCompositeEnd
)
{
NotifyDidComposite
(
mPendingTransaction
aCompositeStart
aCompositeEnd
)
;
mPendingTransaction
=
0
;
}
void
CompositorBridgeParent
:
:
NotifyDidComposite
(
uint64_t
aTransactionId
TimeStamp
&
aCompositeStart
TimeStamp
&
aCompositeEnd
)
{
Unused
<
<
SendDidComposite
(
0
aTransactionId
aCompositeStart
aCompositeEnd
)
;
if
(
mLayerManager
)
{
nsTArray
<
ImageCompositeNotification
>
notifications
;
mLayerManager
-
>
ExtractImageCompositeNotifications
(
&
notifications
)
;
if
(
!
notifications
.
IsEmpty
(
)
)
{
Unused
<
<
ImageBridgeParent
:
:
NotifyImageComposites
(
notifications
)
;
}
}
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
ForEachIndirectLayerTree
(
[
&
]
(
LayerTreeState
*
lts
const
uint64_t
&
aLayersId
)
-
>
void
{
if
(
lts
-
>
mCrossProcessParent
)
{
CrossProcessCompositorBridgeParent
*
cpcp
=
lts
-
>
mCrossProcessParent
;
cpcp
-
>
DidComposite
(
aLayersId
aCompositeStart
aCompositeEnd
)
;
}
}
)
;
}
void
CompositorBridgeParent
:
:
InvalidateRemoteLayers
(
)
{
MOZ_ASSERT
(
CompositorLoop
(
)
=
=
MessageLoop
:
:
current
(
)
)
;
Unused
<
<
PCompositorBridgeParent
:
:
SendInvalidateLayers
(
0
)
;
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
ForEachIndirectLayerTree
(
[
]
(
LayerTreeState
*
lts
const
uint64_t
&
aLayersId
)
-
>
void
{
if
(
lts
-
>
mCrossProcessParent
)
{
CrossProcessCompositorBridgeParent
*
cpcp
=
lts
-
>
mCrossProcessParent
;
Unused
<
<
cpcp
-
>
SendInvalidateLayers
(
aLayersId
)
;
}
}
)
;
}
bool
CompositorBridgeParent
:
:
ResetCompositor
(
const
nsTArray
<
LayersBackend
>
&
aBackendHints
uint64_t
aSeqNo
TextureFactoryIdentifier
*
aOutIdentifier
)
{
Maybe
<
TextureFactoryIdentifier
>
newIdentifier
;
{
MonitorAutoLock
lock
(
mResetCompositorMonitor
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableMethod
<
StoreCopyPassByConstLRef
<
nsTArray
<
LayersBackend
>
>
uint64_t
Maybe
<
TextureFactoryIdentifier
>
*
>
(
this
&
CompositorBridgeParent
:
:
ResetCompositorTask
aBackendHints
aSeqNo
&
newIdentifier
)
)
;
mResetCompositorMonitor
.
Wait
(
)
;
}
if
(
!
newIdentifier
)
{
return
false
;
}
*
aOutIdentifier
=
newIdentifier
.
value
(
)
;
return
true
;
}
void
CompositorBridgeParent
:
:
ResetCompositorTask
(
const
nsTArray
<
LayersBackend
>
&
aBackendHints
uint64_t
aSeqNo
Maybe
<
TextureFactoryIdentifier
>
*
aOutNewIdentifier
)
{
Maybe
<
TextureFactoryIdentifier
>
newIdentifier
;
{
MonitorAutoLock
lock
(
mResetCompositorMonitor
)
;
newIdentifier
=
ResetCompositorImpl
(
aBackendHints
)
;
*
aOutNewIdentifier
=
newIdentifier
;
mResetCompositorMonitor
.
NotifyAll
(
)
;
}
if
(
!
newIdentifier
)
{
return
;
}
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
ForEachIndirectLayerTree
(
[
&
]
(
LayerTreeState
*
lts
uint64_t
layersId
)
-
>
void
{
if
(
CrossProcessCompositorBridgeParent
*
cpcp
=
lts
-
>
mCrossProcessParent
)
{
Unused
<
<
cpcp
-
>
SendCompositorUpdated
(
layersId
newIdentifier
.
value
(
)
aSeqNo
)
;
if
(
LayerTransactionParent
*
ltp
=
lts
-
>
mLayerTree
)
{
ltp
-
>
AddPendingCompositorUpdate
(
)
;
}
lts
-
>
mPendingCompositorUpdates
+
+
;
}
}
)
;
}
Maybe
<
TextureFactoryIdentifier
>
CompositorBridgeParent
:
:
ResetCompositorImpl
(
const
nsTArray
<
LayersBackend
>
&
aBackendHints
)
{
if
(
!
mLayerManager
)
{
return
Nothing
(
)
;
}
RefPtr
<
Compositor
>
compositor
=
NewCompositor
(
aBackendHints
)
;
if
(
!
compositor
)
{
MOZ_RELEASE_ASSERT
(
compositor
"
Failed
to
reset
compositor
.
"
)
;
}
if
(
mCompositor
&
&
mCompositor
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_BASIC
&
&
compositor
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_BASIC
)
{
return
Nothing
(
)
;
}
if
(
mCompositor
)
{
mCompositor
-
>
SetInvalid
(
)
;
}
mCompositor
=
compositor
;
mLayerManager
-
>
ChangeCompositor
(
compositor
)
;
return
Some
(
compositor
-
>
GetTextureFactoryIdentifier
(
)
)
;
}
static
void
OpenCompositor
(
RefPtr
<
CrossProcessCompositorBridgeParent
>
aCompositor
Endpoint
<
PCompositorBridgeParent
>
&
&
aEndpoint
)
{
aCompositor
-
>
Bind
(
Move
(
aEndpoint
)
)
;
}
bool
CompositorBridgeParent
:
:
CreateForContent
(
Endpoint
<
PCompositorBridgeParent
>
&
&
aEndpoint
)
{
gfxPlatform
:
:
InitLayersIPC
(
)
;
RefPtr
<
CrossProcessCompositorBridgeParent
>
cpcp
=
new
CrossProcessCompositorBridgeParent
(
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
OpenCompositor
cpcp
Move
(
aEndpoint
)
)
)
;
return
true
;
}
void
UpdateIndirectTree
(
uint64_t
aId
Layer
*
aRoot
const
TargetConfig
&
aTargetConfig
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
sIndirectLayerTrees
[
aId
]
.
mRoot
=
aRoot
;
sIndirectLayerTrees
[
aId
]
.
mTargetConfig
=
aTargetConfig
;
}
CompositorBridgeParent
:
:
LayerTreeState
*
CompositorBridgeParent
:
:
GetIndirectShadowTree
(
uint64_t
aId
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
LayerTreeMap
:
:
iterator
cit
=
sIndirectLayerTrees
.
find
(
aId
)
;
if
(
sIndirectLayerTrees
.
end
(
)
=
=
cit
)
{
return
nullptr
;
}
return
&
cit
-
>
second
;
}
static
CompositorBridgeParent
:
:
LayerTreeState
*
GetStateForRoot
(
uint64_t
aContentLayersId
const
MonitorAutoLock
&
aProofOfLock
)
{
CompositorBridgeParent
:
:
LayerTreeState
*
state
=
nullptr
;
LayerTreeMap
:
:
iterator
itr
=
sIndirectLayerTrees
.
find
(
aContentLayersId
)
;
if
(
sIndirectLayerTrees
.
end
(
)
!
=
itr
)
{
state
=
&
itr
-
>
second
;
}
if
(
state
)
{
uint64_t
rootLayersId
=
state
-
>
mParent
-
>
RootLayerTreeId
(
)
;
itr
=
sIndirectLayerTrees
.
find
(
rootLayersId
)
;
state
=
(
sIndirectLayerTrees
.
end
(
)
!
=
itr
)
?
&
itr
-
>
second
:
nullptr
;
}
return
state
;
}
APZCTreeManagerParent
*
CompositorBridgeParent
:
:
GetApzcTreeManagerParentForRoot
(
uint64_t
aContentLayersId
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
CompositorBridgeParent
:
:
LayerTreeState
*
state
=
GetStateForRoot
(
aContentLayersId
lock
)
;
return
state
?
state
-
>
mApzcTreeManagerParent
:
nullptr
;
}
GeckoContentController
*
CompositorBridgeParent
:
:
GetGeckoContentControllerForRoot
(
uint64_t
aContentLayersId
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
CompositorBridgeParent
:
:
LayerTreeState
*
state
=
GetStateForRoot
(
aContentLayersId
lock
)
;
return
state
?
state
-
>
mController
.
get
(
)
:
nullptr
;
}
PTextureParent
*
CompositorBridgeParent
:
:
AllocPTextureParent
(
const
SurfaceDescriptor
&
aSharedData
const
LayersBackend
&
aLayersBackend
const
TextureFlags
&
aFlags
const
uint64_t
&
aId
const
uint64_t
&
aSerial
)
{
return
TextureHost
:
:
CreateIPDLActor
(
this
aSharedData
aLayersBackend
aFlags
aSerial
)
;
}
bool
CompositorBridgeParent
:
:
DeallocPTextureParent
(
PTextureParent
*
actor
)
{
return
TextureHost
:
:
DestroyIPDLActor
(
actor
)
;
}
bool
CompositorBridgeParent
:
:
IsSameProcess
(
)
const
{
return
OtherPid
(
)
=
=
base
:
:
GetCurrentProcId
(
)
;
}
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
#
define
PLUGINS_LOG
(
.
.
.
)
bool
CompositorBridgeParent
:
:
UpdatePluginWindowState
(
uint64_t
aId
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
CompositorBridgeParent
:
:
LayerTreeState
&
lts
=
sIndirectLayerTrees
[
aId
]
;
if
(
!
lts
.
mParent
)
{
PLUGINS_LOG
(
"
[
%
"
PRIu64
"
]
layer
tree
compositor
parent
pointer
is
null
"
aId
)
;
return
false
;
}
if
(
!
lts
.
mUpdatedPluginDataAvailable
)
{
PLUGINS_LOG
(
"
[
%
"
PRIu64
"
]
no
plugin
data
"
aId
)
;
return
false
;
}
bool
pluginMetricsChanged
=
false
;
if
(
mLastPluginUpdateLayerTreeId
=
=
aId
)
{
if
(
!
mCachedPluginData
.
Length
(
)
&
&
!
lts
.
mPluginData
.
Length
(
)
)
{
PLUGINS_LOG
(
"
[
%
"
PRIu64
"
]
no
data
no
changes
"
aId
)
;
return
false
;
}
if
(
mCachedPluginData
.
Length
(
)
=
=
lts
.
mPluginData
.
Length
(
)
)
{
for
(
uint32_t
idx
=
0
;
idx
<
lts
.
mPluginData
.
Length
(
)
;
idx
+
+
)
{
if
(
!
(
mCachedPluginData
[
idx
]
=
=
lts
.
mPluginData
[
idx
]
)
)
{
pluginMetricsChanged
=
true
;
break
;
}
}
}
else
{
pluginMetricsChanged
=
true
;
}
}
else
{
pluginMetricsChanged
=
true
;
}
if
(
mDeferPluginWindows
)
{
PLUGINS_LOG
(
"
[
%
"
PRIu64
"
]
suppressing
"
aId
)
;
return
false
;
}
if
(
mPluginWindowsHidden
)
{
PLUGINS_LOG
(
"
[
%
"
PRIu64
"
]
re
-
showing
"
aId
)
;
mPluginWindowsHidden
=
false
;
pluginMetricsChanged
=
true
;
}
if
(
!
lts
.
mPluginData
.
Length
(
)
)
{
if
(
!
mCachedPluginData
.
Length
(
)
)
{
PLUGINS_LOG
(
"
[
%
"
PRIu64
"
]
nothing
to
hide
"
aId
)
;
return
false
;
}
uintptr_t
parentWidget
=
GetWidget
(
)
-
>
GetWidgetKey
(
)
;
mPluginsLayerOffset
=
nsIntPoint
(
0
0
)
;
mPluginsLayerVisibleRegion
.
SetEmpty
(
)
;
Unused
<
<
lts
.
mParent
-
>
SendHideAllPlugins
(
parentWidget
)
;
lts
.
mUpdatedPluginDataAvailable
=
false
;
PLUGINS_LOG
(
"
[
%
"
PRIu64
"
]
hide
all
"
aId
)
;
}
else
{
LayerTransactionParent
*
layerTree
=
lts
.
mLayerTree
;
Layer
*
contentRoot
=
layerTree
-
>
GetRoot
(
)
;
if
(
contentRoot
)
{
nsIntPoint
offset
;
nsIntRegion
visibleRegion
;
if
(
contentRoot
-
>
GetVisibleRegionRelativeToRootLayer
(
visibleRegion
&
offset
)
)
{
if
(
!
pluginMetricsChanged
&
&
mPluginsLayerVisibleRegion
=
=
visibleRegion
&
&
mPluginsLayerOffset
=
=
offset
)
{
PLUGINS_LOG
(
"
[
%
"
PRIu64
"
]
no
change
"
aId
)
;
return
false
;
}
mPluginsLayerOffset
=
offset
;
mPluginsLayerVisibleRegion
=
visibleRegion
;
Unused
<
<
lts
.
mParent
-
>
SendUpdatePluginConfigurations
(
LayoutDeviceIntPoint
:
:
FromUnknownPoint
(
offset
)
LayoutDeviceIntRegion
:
:
FromUnknownRegion
(
visibleRegion
)
lts
.
mPluginData
)
;
lts
.
mUpdatedPluginDataAvailable
=
false
;
PLUGINS_LOG
(
"
[
%
"
PRIu64
"
]
updated
"
aId
)
;
}
else
{
PLUGINS_LOG
(
"
[
%
"
PRIu64
"
]
no
visibility
data
"
aId
)
;
return
false
;
}
}
else
{
PLUGINS_LOG
(
"
[
%
"
PRIu64
"
]
no
content
root
"
aId
)
;
return
false
;
}
}
mLastPluginUpdateLayerTreeId
=
aId
;
mCachedPluginData
=
lts
.
mPluginData
;
return
true
;
}
void
CompositorBridgeParent
:
:
ScheduleShowAllPluginWindows
(
)
{
MOZ_ASSERT
(
CompositorLoop
(
)
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableMethod
(
this
&
CompositorBridgeParent
:
:
ShowAllPluginWindows
)
)
;
}
void
CompositorBridgeParent
:
:
ShowAllPluginWindows
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mDeferPluginWindows
=
false
;
ScheduleComposition
(
)
;
}
void
CompositorBridgeParent
:
:
ScheduleHideAllPluginWindows
(
)
{
MOZ_ASSERT
(
CompositorLoop
(
)
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableMethod
(
this
&
CompositorBridgeParent
:
:
HideAllPluginWindows
)
)
;
}
void
CompositorBridgeParent
:
:
HideAllPluginWindows
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
!
mCachedPluginData
.
Length
(
)
|
|
mDeferPluginWindows
)
{
return
;
}
uintptr_t
parentWidget
=
GetWidget
(
)
-
>
GetWidgetKey
(
)
;
mDeferPluginWindows
=
true
;
mPluginWindowsHidden
=
true
;
#
if
defined
(
XP_WIN
)
mWaitForPluginsUntil
=
TimeStamp
:
:
Now
(
)
+
mVsyncRate
;
Unused
<
<
SendCaptureAllPlugins
(
parentWidget
)
;
#
else
Unused
<
<
SendHideAllPlugins
(
parentWidget
)
;
ScheduleComposition
(
)
;
#
endif
}
#
endif
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvAllPluginsCaptured
(
)
{
#
if
defined
(
XP_WIN
)
mWaitForPluginsUntil
=
TimeStamp
(
)
;
mHaveBlockedForPlugins
=
false
;
ForceComposeToTarget
(
nullptr
)
;
Unused
<
<
SendHideAllPlugins
(
GetWidget
(
)
-
>
GetWidgetKey
(
)
)
;
return
IPC_OK
(
)
;
#
else
MOZ_ASSERT_UNREACHABLE
(
"
CompositorBridgeParent
:
:
RecvAllPluginsCaptured
calls
unexpected
.
"
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
#
endif
}
}
}
