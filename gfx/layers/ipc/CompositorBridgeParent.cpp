#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
<
stdio
.
h
>
#
include
<
stdint
.
h
>
#
include
<
map
>
#
include
<
utility
>
#
include
"
apz
/
src
/
APZCTreeManager
.
h
"
#
include
"
LayerTransactionParent
.
h
"
#
include
"
RenderTrace
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
process
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
base
/
thread
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
TreeTraversal
.
h
"
#
ifdef
MOZ_WIDGET_GTK
#
include
"
gfxPlatformGtk
.
h
"
#
endif
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
StaticPrefs_layers
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
dom
/
BrowserParent
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
VRManager
.
h
"
#
include
"
mozilla
/
ipc
/
Transport
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
gfx
/
GPUParent
.
h
"
#
include
"
mozilla
/
layers
/
AnimationHelper
.
h
"
#
include
"
mozilla
/
layers
/
APZCTreeManagerParent
.
h
"
#
include
"
mozilla
/
layers
/
APZSampler
.
h
"
#
include
"
mozilla
/
layers
/
APZThreadUtils
.
h
"
#
include
"
mozilla
/
layers
/
APZUpdater
.
h
"
#
include
"
mozilla
/
layers
/
AsyncCompositionManager
.
h
"
#
include
"
mozilla
/
layers
/
BasicCompositor
.
h
"
#
include
"
mozilla
/
layers
/
CompositionRecorder
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
layers
/
CompositorManagerParent
.
h
"
#
include
"
mozilla
/
layers
/
CompositorOGL
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
CompositorVsyncScheduler
.
h
"
#
include
"
mozilla
/
layers
/
ContentCompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
FrameUniformityData
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
LayerManagerComposite
.
h
"
#
include
"
mozilla
/
layers
/
LayerManagerMLGPU
.
h
"
#
include
"
mozilla
/
layers
/
LayerTreeOwnerTracker
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
PLayerTransactionParent
.
h
"
#
include
"
mozilla
/
layers
/
RemoteContentController
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
AsyncImagePipelineManager
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
mozilla
/
webgpu
/
WebGPUParent
.
h
"
#
include
"
mozilla
/
media
/
MediaSystemResourceService
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
PerfStats
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
ifdef
MOZ_WIDGET_GTK
#
include
"
basic
/
X11BasicCompositor
.
h
"
#
endif
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
ifdef
XP_WIN
#
include
"
mozilla
/
layers
/
CompositorD3D11
.
h
"
#
include
"
mozilla
/
widget
/
WinCompositorWidget
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
endif
#
include
"
GeckoProfiler
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolTypes
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Hal
.
h
"
#
include
"
mozilla
/
HalTypes
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
ifdef
MOZ_GECKO_PROFILER
#
include
"
ProfilerMarkerPayload
.
h
"
#
endif
#
include
"
mozilla
/
VsyncDispatcher
.
h
"
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
#
include
"
VsyncSource
.
h
"
#
endif
#
include
"
mozilla
/
widget
/
CompositorWidget
.
h
"
#
ifdef
MOZ_WIDGET_SUPPORTS_OOP_COMPOSITING
#
include
"
mozilla
/
widget
/
CompositorWidgetParent
.
h
"
#
endif
#
ifdef
XP_WIN
#
include
"
mozilla
/
gfx
/
DeviceManagerDx
.
h
"
#
endif
#
include
"
LayerScope
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
mozilla
:
:
ipc
;
using
namespace
mozilla
:
:
gfx
;
using
base
:
:
ProcessId
;
using
base
:
:
Thread
;
using
mozilla
:
:
Telemetry
:
:
LABELS_CONTENT_FRAME_TIME_REASON
;
static
void
AssertIsInCompositorThread
(
)
{
MOZ_RELEASE_ASSERT
(
!
CompositorThread
(
)
|
|
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
}
CompositorBridgeParentBase
:
:
CompositorBridgeParentBase
(
CompositorManagerParent
*
aManager
)
:
mCanSend
(
true
)
mCompositorManager
(
aManager
)
{
}
CompositorBridgeParentBase
:
:
~
CompositorBridgeParentBase
(
)
=
default
;
ProcessId
CompositorBridgeParentBase
:
:
GetChildProcessId
(
)
{
return
OtherPid
(
)
;
}
void
CompositorBridgeParentBase
:
:
NotifyNotUsed
(
PTextureParent
*
aTexture
uint64_t
aTransactionId
)
{
RefPtr
<
TextureHost
>
texture
=
TextureHost
:
:
AsTextureHost
(
aTexture
)
;
if
(
!
texture
)
{
return
;
}
if
(
!
(
texture
-
>
GetFlags
(
)
&
TextureFlags
:
:
RECYCLE
)
)
{
return
;
}
uint64_t
textureId
=
TextureHost
:
:
GetTextureSerial
(
aTexture
)
;
mPendingAsyncMessage
.
push_back
(
OpNotifyNotUsed
(
textureId
aTransactionId
)
)
;
}
void
CompositorBridgeParentBase
:
:
SendAsyncMessage
(
const
nsTArray
<
AsyncParentMessageData
>
&
aMessage
)
{
Unused
<
<
SendParentAsyncMessages
(
aMessage
)
;
}
bool
CompositorBridgeParentBase
:
:
AllocShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
return
PCompositorBridgeParent
:
:
AllocShmem
(
aSize
aType
aShmem
)
;
}
bool
CompositorBridgeParentBase
:
:
AllocUnsafeShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
return
PCompositorBridgeParent
:
:
AllocUnsafeShmem
(
aSize
aType
aShmem
)
;
}
bool
CompositorBridgeParentBase
:
:
DeallocShmem
(
ipc
:
:
Shmem
&
aShmem
)
{
return
PCompositorBridgeParent
:
:
DeallocShmem
(
aShmem
)
;
}
static
inline
MessageLoop
*
CompositorLoop
(
)
{
return
CompositorThreadHolder
:
:
Loop
(
)
;
}
base
:
:
ProcessId
CompositorBridgeParentBase
:
:
RemotePid
(
)
{
return
OtherPid
(
)
;
}
bool
CompositorBridgeParentBase
:
:
StartSharingMetrics
(
ipc
:
:
SharedMemoryBasic
:
:
Handle
aHandle
CrossProcessMutexHandle
aMutexHandle
LayersId
aLayersId
uint32_t
aApzcId
)
{
if
(
!
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
{
MOZ_ASSERT
(
CompositorLoop
(
)
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableMethod
<
ipc
:
:
SharedMemoryBasic
:
:
Handle
CrossProcessMutexHandle
LayersId
uint32_t
>
(
"
layers
:
:
CompositorBridgeParent
:
:
StartSharingMetrics
"
this
&
CompositorBridgeParentBase
:
:
StartSharingMetrics
aHandle
aMutexHandle
aLayersId
aApzcId
)
)
;
return
true
;
}
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeParent
:
:
SendSharedCompositorFrameMetrics
(
aHandle
aMutexHandle
aLayersId
aApzcId
)
;
}
bool
CompositorBridgeParentBase
:
:
StopSharingMetrics
(
ScrollableLayerGuid
:
:
ViewID
aScrollId
uint32_t
aApzcId
)
{
if
(
!
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
{
MOZ_ASSERT
(
CompositorLoop
(
)
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableMethod
<
ScrollableLayerGuid
:
:
ViewID
uint32_t
>
(
"
layers
:
:
CompositorBridgeParent
:
:
StopSharingMetrics
"
this
&
CompositorBridgeParentBase
:
:
StopSharingMetrics
aScrollId
aApzcId
)
)
;
return
true
;
}
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeParent
:
:
SendReleaseSharedCompositorFrameMetrics
(
aScrollId
aApzcId
)
;
}
CompositorBridgeParent
:
:
LayerTreeState
:
:
LayerTreeState
(
)
:
mApzcTreeManagerParent
(
nullptr
)
mParent
(
nullptr
)
mLayerManager
(
nullptr
)
mContentCompositorBridgeParent
(
nullptr
)
mLayerTree
(
nullptr
)
mUpdatedPluginDataAvailable
(
false
)
{
}
CompositorBridgeParent
:
:
LayerTreeState
:
:
~
LayerTreeState
(
)
{
if
(
mController
)
{
mController
-
>
Destroy
(
)
;
}
}
typedef
std
:
:
map
<
LayersId
CompositorBridgeParent
:
:
LayerTreeState
>
LayerTreeMap
;
LayerTreeMap
sIndirectLayerTrees
;
StaticAutoPtr
<
mozilla
:
:
Monitor
>
sIndirectLayerTreesLock
;
static
void
EnsureLayerTreeMapReady
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
sIndirectLayerTreesLock
)
{
sIndirectLayerTreesLock
=
new
Monitor
(
"
IndirectLayerTree
"
)
;
mozilla
:
:
ClearOnShutdown
(
&
sIndirectLayerTreesLock
)
;
}
}
template
<
typename
Lambda
>
inline
void
CompositorBridgeParent
:
:
ForEachIndirectLayerTree
(
const
Lambda
&
aCallback
)
{
sIndirectLayerTreesLock
-
>
AssertCurrentThreadOwns
(
)
;
for
(
auto
it
=
sIndirectLayerTrees
.
begin
(
)
;
it
!
=
sIndirectLayerTrees
.
end
(
)
;
it
+
+
)
{
LayerTreeState
*
state
=
&
it
-
>
second
;
if
(
state
-
>
mParent
=
=
this
)
{
aCallback
(
state
it
-
>
first
)
;
}
}
}
template
<
typename
Lambda
>
inline
void
CompositorBridgeParent
:
:
ForEachWebRenderBridgeParent
(
const
Lambda
&
aCallback
)
{
sIndirectLayerTreesLock
-
>
AssertCurrentThreadOwns
(
)
;
for
(
auto
&
it
:
sIndirectLayerTrees
)
{
LayerTreeState
*
state
=
&
it
.
second
;
if
(
state
-
>
mWrBridge
)
{
aCallback
(
state
-
>
mWrBridge
)
;
}
}
}
typedef
std
:
:
map
<
uint64_t
CompositorBridgeParent
*
>
CompositorMap
;
static
StaticAutoPtr
<
CompositorMap
>
sCompositorMap
;
void
CompositorBridgeParent
:
:
Setup
(
)
{
EnsureLayerTreeMapReady
(
)
;
MOZ_ASSERT
(
!
sCompositorMap
)
;
sCompositorMap
=
new
CompositorMap
;
}
void
CompositorBridgeParent
:
:
FinishShutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
sCompositorMap
)
{
MOZ_ASSERT
(
sCompositorMap
-
>
empty
(
)
)
;
sCompositorMap
=
nullptr
;
}
sIndirectLayerTrees
.
clear
(
)
;
}
#
ifdef
COMPOSITOR_PERFORMANCE_WARNING
static
int32_t
CalculateCompositionFrameRate
(
)
{
const
int32_t
defaultFrameRate
=
60
;
int32_t
compositionFrameRatePref
=
StaticPrefs
:
:
layers_offmainthreadcomposition_frame_rate
(
)
;
if
(
compositionFrameRatePref
<
0
)
{
int32_t
layoutFrameRatePref
=
StaticPrefs
:
:
layout_frame_rate
(
)
;
if
(
layoutFrameRatePref
<
0
)
{
return
defaultFrameRate
;
}
return
layoutFrameRatePref
;
}
return
compositionFrameRatePref
;
}
#
endif
CompositorBridgeParent
:
:
CompositorBridgeParent
(
CompositorManagerParent
*
aManager
CSSToLayoutDeviceScale
aScale
const
TimeDuration
&
aVsyncRate
const
CompositorOptions
&
aOptions
bool
aUseExternalSurfaceSize
const
gfx
:
:
IntSize
&
aSurfaceSize
)
:
CompositorBridgeParentBase
(
aManager
)
mWidget
(
nullptr
)
mScale
(
aScale
)
mVsyncRate
(
aVsyncRate
)
mPendingTransaction
{
0
}
mPaused
(
false
)
mHaveCompositionRecorder
(
false
)
mIsForcedFirstPaint
(
false
)
mUseExternalSurfaceSize
(
aUseExternalSurfaceSize
)
mEGLSurfaceSize
(
aSurfaceSize
)
mOptions
(
aOptions
)
mPauseCompositionMonitor
(
"
PauseCompositionMonitor
"
)
mResumeCompositionMonitor
(
"
ResumeCompositionMonitor
"
)
mCompositorBridgeID
(
0
)
mRootLayerTreeID
{
0
}
mOverrideComposeReadiness
(
false
)
mForceCompositionTask
(
nullptr
)
mCompositorScheduler
(
nullptr
)
mAnimationStorage
(
nullptr
)
mPaintTime
(
TimeDuration
:
:
Forever
(
)
)
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
mLastPluginUpdateLayerTreeId
{
0
}
mDeferPluginWindows
(
false
)
mPluginWindowsHidden
(
false
)
#
endif
{
}
void
CompositorBridgeParent
:
:
InitSameProcess
(
widget
:
:
CompositorWidget
*
aWidget
const
LayersId
&
aLayerTreeId
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mWidget
=
aWidget
;
mRootLayerTreeID
=
aLayerTreeId
;
Initialize
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvInitialize
(
const
LayersId
&
aRootLayerTreeId
)
{
MOZ_ASSERT
(
XRE_IsGPUProcess
(
)
)
;
mRootLayerTreeID
=
aRootLayerTreeId
;
#
ifdef
XP_WIN
if
(
XRE_IsGPUProcess
(
)
)
{
mWidget
-
>
AsWindows
(
)
-
>
SetRootLayerTreeID
(
mRootLayerTreeID
)
;
}
#
endif
Initialize
(
)
;
return
IPC_OK
(
)
;
}
void
CompositorBridgeParent
:
:
Initialize
(
)
{
MOZ_ASSERT
(
CompositorThread
(
)
"
The
compositor
thread
must
be
Initialized
before
instanciating
a
"
"
CompositorBridgeParent
.
"
)
;
if
(
mOptions
.
UseAPZ
(
)
)
{
MOZ_ASSERT
(
!
mApzcTreeManager
)
;
MOZ_ASSERT
(
!
mApzSampler
)
;
MOZ_ASSERT
(
!
mApzUpdater
)
;
mApzcTreeManager
=
new
APZCTreeManager
(
mRootLayerTreeID
)
;
mApzSampler
=
new
APZSampler
(
mApzcTreeManager
mOptions
.
UseWebRender
(
)
)
;
mApzUpdater
=
new
APZUpdater
(
mApzcTreeManager
mOptions
.
UseWebRender
(
)
)
;
}
mPaused
=
mOptions
.
InitiallyPaused
(
)
;
mCompositorBridgeID
=
0
;
MOZ_ASSERT
(
CompositorLoop
(
)
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
"
AddCompositorRunnable
"
&
AddCompositor
this
&
mCompositorBridgeID
)
)
;
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
sIndirectLayerTrees
[
mRootLayerTreeID
]
.
mParent
=
this
;
}
LayerScope
:
:
SetPixelScale
(
mScale
.
scale
)
;
if
(
!
mOptions
.
UseWebRender
(
)
)
{
mCompositorScheduler
=
new
CompositorVsyncScheduler
(
this
mWidget
)
;
}
}
LayersId
CompositorBridgeParent
:
:
RootLayerTreeId
(
)
{
MOZ_ASSERT
(
mRootLayerTreeID
.
IsValid
(
)
)
;
return
mRootLayerTreeID
;
}
CompositorBridgeParent
:
:
~
CompositorBridgeParent
(
)
{
nsTArray
<
PTextureParent
*
>
textures
;
ManagedPTextureParent
(
textures
)
;
MOZ_DIAGNOSTIC_ASSERT
(
textures
.
Length
(
)
=
=
0
)
;
for
(
unsigned
int
i
=
0
;
i
<
textures
.
Length
(
)
;
+
+
i
)
{
RefPtr
<
TextureHost
>
tex
=
TextureHost
:
:
AsTextureHost
(
textures
[
i
]
)
;
tex
-
>
DeallocateDeviceData
(
)
;
}
}
void
CompositorBridgeParent
:
:
ForceIsFirstPaint
(
)
{
if
(
mWrBridge
)
{
mIsForcedFirstPaint
=
true
;
}
else
{
mCompositionManager
-
>
ForceIsFirstPaint
(
)
;
}
}
void
CompositorBridgeParent
:
:
StopAndClearResources
(
)
{
if
(
mForceCompositionTask
)
{
mForceCompositionTask
-
>
Cancel
(
)
;
mForceCompositionTask
=
nullptr
;
}
mPaused
=
true
;
MOZ_ASSERT
(
(
mApzSampler
!
=
nullptr
)
=
=
(
mApzcTreeManager
!
=
nullptr
)
)
;
MOZ_ASSERT
(
(
mApzUpdater
!
=
nullptr
)
=
=
(
mApzcTreeManager
!
=
nullptr
)
)
;
if
(
mApzUpdater
)
{
mApzSampler
-
>
Destroy
(
)
;
mApzSampler
=
nullptr
;
mApzUpdater
-
>
ClearTree
(
mRootLayerTreeID
)
;
mApzUpdater
=
nullptr
;
mApzcTreeManager
=
nullptr
;
}
if
(
mLayerManager
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
ForEachIndirectLayerTree
(
[
this
]
(
LayerTreeState
*
lts
LayersId
)
-
>
void
{
mLayerManager
-
>
ClearCachedResources
(
lts
-
>
mRoot
)
;
lts
-
>
mLayerManager
=
nullptr
;
lts
-
>
mParent
=
nullptr
;
}
)
;
mLayerManager
-
>
Destroy
(
)
;
mLayerManager
=
nullptr
;
mCompositionManager
=
nullptr
;
}
if
(
mWrBridge
)
{
std
:
:
vector
<
RefPtr
<
WebRenderBridgeParent
>
>
indirectBridgeParents
;
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
ForEachIndirectLayerTree
(
[
&
]
(
LayerTreeState
*
lts
LayersId
)
-
>
void
{
if
(
lts
-
>
mWrBridge
)
{
indirectBridgeParents
.
emplace_back
(
lts
-
>
mWrBridge
.
forget
(
)
)
;
}
lts
-
>
mParent
=
nullptr
;
}
)
;
}
for
(
const
RefPtr
<
WebRenderBridgeParent
>
&
bridge
:
indirectBridgeParents
)
{
bridge
-
>
Destroy
(
)
;
}
indirectBridgeParents
.
clear
(
)
;
RefPtr
<
wr
:
:
WebRenderAPI
>
api
=
mWrBridge
-
>
GetWebRenderAPI
(
wr
:
:
RenderRoot
:
:
Default
)
;
mWrBridge
-
>
Destroy
(
)
;
mWrBridge
=
nullptr
;
if
(
api
)
{
api
-
>
FlushSceneBuilder
(
)
;
api
=
nullptr
;
}
if
(
mAsyncImageManager
)
{
mAsyncImageManager
-
>
Destroy
(
)
;
mAsyncImageManager
=
nullptr
;
}
}
if
(
mCompositor
)
{
mCompositor
-
>
Destroy
(
)
;
mCompositor
=
nullptr
;
}
if
(
mCompositorScheduler
)
{
mCompositorScheduler
-
>
Destroy
(
)
;
mCompositorScheduler
=
nullptr
;
}
mWidget
=
nullptr
;
mAnimationStorage
=
nullptr
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvWillClose
(
)
{
StopAndClearResources
(
)
;
mCanSend
=
false
;
return
IPC_OK
(
)
;
}
void
CompositorBridgeParent
:
:
DeferredDestroy
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mSelfRef
=
nullptr
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvPause
(
)
{
PauseComposition
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvRequestFxrOutput
(
)
{
#
ifdef
XP_WIN
mWidget
-
>
AsWindows
(
)
-
>
RequestFxrOutput
(
)
;
#
endif
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvResume
(
)
{
ResumeComposition
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvResumeAsync
(
)
{
ResumeComposition
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvMakeSnapshot
(
const
SurfaceDescriptor
&
aInSnapshot
const
gfx
:
:
IntRect
&
aRect
)
{
RefPtr
<
DrawTarget
>
target
=
GetDrawTargetForDescriptor
(
aInSnapshot
gfx
:
:
BackendType
:
:
CAIRO
)
;
MOZ_ASSERT
(
target
)
;
if
(
!
target
)
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
ForceComposeToTarget
(
target
&
aRect
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvWaitOnTransactionProcessed
(
)
{
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvFlushRendering
(
)
{
if
(
mWrBridge
)
{
mWrBridge
-
>
FlushRendering
(
)
;
return
IPC_OK
(
)
;
}
if
(
mCompositorScheduler
-
>
NeedsComposite
(
)
)
{
CancelCurrentCompositeTask
(
)
;
ForceComposeToTarget
(
nullptr
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvFlushRenderingAsync
(
)
{
if
(
mWrBridge
)
{
mWrBridge
-
>
FlushRendering
(
false
)
;
return
IPC_OK
(
)
;
}
return
RecvFlushRendering
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvForcePresent
(
)
{
if
(
mWrBridge
)
{
mWrBridge
-
>
ScheduleForcedGenerateFrame
(
)
;
}
if
(
mLayerManager
)
{
mLayerManager
-
>
ForcePresent
(
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvNotifyRegionInvalidated
(
const
nsIntRegion
&
aRegion
)
{
if
(
mLayerManager
)
{
mLayerManager
-
>
AddInvalidRegion
(
aRegion
)
;
}
return
IPC_OK
(
)
;
}
void
CompositorBridgeParent
:
:
Invalidate
(
)
{
if
(
mLayerManager
)
{
mLayerManager
-
>
InvalidateAll
(
)
;
}
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvStartFrameTimeRecording
(
const
int32_t
&
aBufferSize
uint32_t
*
aOutStartIndex
)
{
if
(
mLayerManager
)
{
*
aOutStartIndex
=
mLayerManager
-
>
StartFrameTimeRecording
(
aBufferSize
)
;
}
else
if
(
mWrBridge
)
{
*
aOutStartIndex
=
mWrBridge
-
>
StartFrameTimeRecording
(
aBufferSize
)
;
}
else
{
*
aOutStartIndex
=
0
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvStopFrameTimeRecording
(
const
uint32_t
&
aStartIndex
nsTArray
<
float
>
*
intervals
)
{
if
(
mLayerManager
)
{
mLayerManager
-
>
StopFrameTimeRecording
(
aStartIndex
*
intervals
)
;
}
else
if
(
mWrBridge
)
{
mWrBridge
-
>
StopFrameTimeRecording
(
aStartIndex
*
intervals
)
;
}
return
IPC_OK
(
)
;
}
void
CompositorBridgeParent
:
:
ActorDestroy
(
ActorDestroyReason
why
)
{
mCanSend
=
false
;
StopAndClearResources
(
)
;
RemoveCompositor
(
mCompositorBridgeID
)
;
mCompositionManager
=
nullptr
;
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
sIndirectLayerTrees
.
erase
(
mRootLayerTreeID
)
;
}
mSelfRef
=
this
;
MessageLoop
:
:
current
(
)
-
>
PostTask
(
NewRunnableMethod
(
"
layers
:
:
CompositorBridgeParent
:
:
DeferredDestroy
"
this
&
CompositorBridgeParent
:
:
DeferredDestroy
)
)
;
}
void
CompositorBridgeParent
:
:
ScheduleRenderOnCompositorThread
(
const
wr
:
:
RenderRootSet
&
aRenderRoots
)
{
MOZ_ASSERT
(
CompositorLoop
(
)
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableMethod
<
wr
:
:
RenderRootSet
>
(
"
layers
:
:
CompositorBridgeParent
:
:
ScheduleComposition
"
this
&
CompositorBridgeParent
:
:
ScheduleComposition
aRenderRoots
)
)
;
}
void
CompositorBridgeParent
:
:
InvalidateOnCompositorThread
(
)
{
MOZ_ASSERT
(
CompositorLoop
(
)
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableMethod
(
"
layers
:
:
CompositorBridgeParent
:
:
Invalidate
"
this
&
CompositorBridgeParent
:
:
Invalidate
)
)
;
}
void
CompositorBridgeParent
:
:
PauseComposition
(
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
"
PauseComposition
(
)
can
only
be
called
on
the
compositor
thread
"
)
;
MonitorAutoLock
lock
(
mPauseCompositionMonitor
)
;
if
(
!
mPaused
)
{
mPaused
=
true
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
mCompositor
)
{
mCompositor
-
>
Pause
(
)
;
DidComposite
(
VsyncId
(
)
now
now
)
;
}
else
if
(
mWrBridge
)
{
mWrBridge
-
>
Pause
(
)
;
NotifyPipelineRendered
(
mWrBridge
-
>
PipelineId
(
)
mWrBridge
-
>
GetCurrentEpoch
(
)
VsyncId
(
)
now
now
now
)
;
}
}
lock
.
NotifyAll
(
)
;
}
void
CompositorBridgeParent
:
:
ResumeComposition
(
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
"
ResumeComposition
(
)
can
only
be
called
on
the
compositor
thread
"
)
;
MonitorAutoLock
lock
(
mResumeCompositionMonitor
)
;
bool
resumed
=
mOptions
.
UseWebRender
(
)
?
mWrBridge
-
>
Resume
(
)
:
mCompositor
-
>
Resume
(
)
;
if
(
!
resumed
)
{
#
ifdef
MOZ_WIDGET_ANDROID
__android_log_print
(
ANDROID_LOG_INFO
"
CompositorBridgeParent
"
"
Unable
to
renew
compositor
surface
;
remaining
in
paused
state
"
)
;
#
endif
lock
.
NotifyAll
(
)
;
return
;
}
mPaused
=
false
;
Invalidate
(
)
;
mCompositorScheduler
-
>
ForceComposeToTarget
(
nullptr
nullptr
)
;
lock
.
NotifyAll
(
)
;
}
void
CompositorBridgeParent
:
:
ForceComposition
(
)
{
mForceCompositionTask
=
nullptr
;
ScheduleRenderOnCompositorThread
(
wr
:
:
RenderRootSet
(
)
)
;
}
void
CompositorBridgeParent
:
:
CancelCurrentCompositeTask
(
)
{
mCompositorScheduler
-
>
CancelCurrentCompositeTask
(
)
;
}
void
CompositorBridgeParent
:
:
SetEGLSurfaceRect
(
int
x
int
y
int
width
int
height
)
{
NS_ASSERTION
(
mUseExternalSurfaceSize
"
Compositor
created
without
UseExternalSurfaceSize
provided
"
)
;
mEGLSurfaceSize
.
SizeTo
(
width
height
)
;
if
(
mCompositor
)
{
mCompositor
-
>
SetDestinationSurfaceSize
(
gfx
:
:
IntSize
(
mEGLSurfaceSize
.
width
mEGLSurfaceSize
.
height
)
)
;
if
(
mCompositor
-
>
AsCompositorOGL
(
)
)
{
mCompositor
-
>
AsCompositorOGL
(
)
-
>
SetSurfaceOrigin
(
ScreenIntPoint
(
x
y
)
)
;
}
}
}
void
CompositorBridgeParent
:
:
ResumeCompositionAndResize
(
int
x
int
y
int
width
int
height
)
{
SetEGLSurfaceRect
(
x
y
width
height
)
;
ResumeComposition
(
)
;
}
void
CompositorBridgeParent
:
:
SchedulePauseOnCompositorThread
(
)
{
MonitorAutoLock
lock
(
mPauseCompositionMonitor
)
;
MOZ_ASSERT
(
CompositorLoop
(
)
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableMethod
(
"
layers
:
:
CompositorBridgeParent
:
:
PauseComposition
"
this
&
CompositorBridgeParent
:
:
PauseComposition
)
)
;
lock
.
Wait
(
)
;
}
bool
CompositorBridgeParent
:
:
ScheduleResumeOnCompositorThread
(
)
{
MonitorAutoLock
lock
(
mResumeCompositionMonitor
)
;
MOZ_ASSERT
(
CompositorLoop
(
)
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableMethod
(
"
layers
:
:
CompositorBridgeParent
:
:
ResumeComposition
"
this
&
CompositorBridgeParent
:
:
ResumeComposition
)
)
;
lock
.
Wait
(
)
;
return
!
mPaused
;
}
bool
CompositorBridgeParent
:
:
ScheduleResumeOnCompositorThread
(
int
x
int
y
int
width
int
height
)
{
MonitorAutoLock
lock
(
mResumeCompositionMonitor
)
;
MOZ_ASSERT
(
CompositorLoop
(
)
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableMethod
<
int
int
int
int
>
(
"
layers
:
:
CompositorBridgeParent
:
:
ResumeCompositionAndResize
"
this
&
CompositorBridgeParent
:
:
ResumeCompositionAndResize
x
y
width
height
)
)
;
lock
.
Wait
(
)
;
return
!
mPaused
;
}
void
CompositorBridgeParent
:
:
ScheduleTask
(
already_AddRefed
<
CancelableRunnable
>
task
int
time
)
{
if
(
time
=
=
0
)
{
MessageLoop
:
:
current
(
)
-
>
PostTask
(
std
:
:
move
(
task
)
)
;
}
else
{
MessageLoop
:
:
current
(
)
-
>
PostDelayedTask
(
std
:
:
move
(
task
)
time
)
;
}
}
void
CompositorBridgeParent
:
:
UpdatePaintTime
(
LayerTransactionParent
*
aLayerTree
const
TimeDuration
&
aPaintTime
)
{
if
(
!
mLayerManager
|
|
aPaintTime
.
ToMilliseconds
(
)
<
1
.
0
)
{
return
;
}
mLayerManager
-
>
SetPaintTime
(
aPaintTime
)
;
}
void
CompositorBridgeParent
:
:
RegisterPayloads
(
LayerTransactionParent
*
aLayerTree
const
nsTArray
<
CompositionPayload
>
&
aPayload
)
{
if
(
!
mLayerManager
)
{
return
;
}
mLayerManager
-
>
RegisterPayloads
(
aPayload
)
;
}
void
CompositorBridgeParent
:
:
NotifyShadowTreeTransaction
(
LayersId
aId
bool
aIsFirstPaint
const
FocusTarget
&
aFocusTarget
bool
aScheduleComposite
uint32_t
aPaintSequenceNumber
bool
aIsRepeatTransaction
bool
aHitTestUpdate
)
{
if
(
!
aIsRepeatTransaction
&
&
mLayerManager
&
&
mLayerManager
-
>
GetRoot
(
)
)
{
bool
pluginsUpdatedFlag
=
true
;
AutoResolveRefLayers
resolve
(
mCompositionManager
this
nullptr
&
pluginsUpdatedFlag
)
;
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
if
(
!
pluginsUpdatedFlag
)
{
mWaitForPluginsUntil
=
TimeStamp
(
)
;
mHaveBlockedForPlugins
=
false
;
}
#
endif
if
(
mApzUpdater
)
{
mApzUpdater
-
>
UpdateFocusState
(
mRootLayerTreeID
WRRootId
:
:
NonWebRender
(
aId
)
aFocusTarget
)
;
if
(
aHitTestUpdate
)
{
mApzUpdater
-
>
UpdateHitTestingTree
(
mLayerManager
-
>
GetRoot
(
)
aIsFirstPaint
aId
aPaintSequenceNumber
)
;
}
}
mLayerManager
-
>
NotifyShadowTreeTransaction
(
)
;
}
if
(
aScheduleComposite
)
{
ScheduleComposition
(
)
;
}
}
void
CompositorBridgeParent
:
:
ScheduleComposition
(
const
wr
:
:
RenderRootSet
&
aRenderRoots
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
if
(
mPaused
)
{
return
;
}
if
(
mWrBridge
)
{
mWrBridge
-
>
ScheduleGenerateFrame
(
aRenderRoots
)
;
}
else
{
mCompositorScheduler
-
>
ScheduleComposition
(
)
;
}
}
void
CompositorBridgeParent
:
:
SetShadowProperties
(
Layer
*
aLayer
)
{
ForEachNode
<
ForwardIterator
>
(
aLayer
[
]
(
Layer
*
layer
)
{
if
(
Layer
*
maskLayer
=
layer
-
>
GetMaskLayer
(
)
)
{
SetShadowProperties
(
maskLayer
)
;
}
for
(
size_t
i
=
0
;
i
<
layer
-
>
GetAncestorMaskLayerCount
(
)
;
i
+
+
)
{
SetShadowProperties
(
layer
-
>
GetAncestorMaskLayerAt
(
i
)
)
;
}
HostLayer
*
layerCompositor
=
layer
-
>
AsHostLayer
(
)
;
const
auto
&
animations
=
layer
-
>
GetPropertyAnimationGroups
(
)
;
if
(
animations
.
IsEmpty
(
)
)
{
layerCompositor
-
>
SetShadowBaseTransform
(
layer
-
>
GetBaseTransform
(
)
)
;
layerCompositor
-
>
SetShadowTransformSetByAnimation
(
false
)
;
layerCompositor
-
>
SetShadowOpacity
(
layer
-
>
GetOpacity
(
)
)
;
layerCompositor
-
>
SetShadowOpacitySetByAnimation
(
false
)
;
}
layerCompositor
-
>
SetShadowVisibleRegion
(
layer
-
>
GetVisibleRegion
(
)
)
;
layerCompositor
-
>
SetShadowClipRect
(
layer
-
>
GetClipRect
(
)
)
;
}
)
;
}
void
CompositorBridgeParent
:
:
CompositeToTarget
(
VsyncId
aId
DrawTarget
*
aTarget
const
gfx
:
:
IntRect
*
aRect
)
{
AUTO_PROFILER_TRACING_MARKER
(
"
Paint
"
"
Composite
"
GRAPHICS
)
;
AUTO_PROFILER_LABEL
(
"
CompositorBridgeParent
:
:
CompositeToTarget
"
GRAPHICS
)
;
PerfStats
:
:
AutoMetricRecording
<
PerfStats
:
:
Metric
:
:
Compositing
>
autoRecording
;
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
"
Composite
can
only
be
called
on
the
compositor
thread
"
)
;
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
if
(
!
CanComposite
(
)
)
{
TimeStamp
end
=
TimeStamp
:
:
Now
(
)
;
DidComposite
(
aId
start
end
)
;
return
;
}
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
if
(
!
mWaitForPluginsUntil
.
IsNull
(
)
&
&
mWaitForPluginsUntil
>
start
)
{
mHaveBlockedForPlugins
=
true
;
ScheduleComposition
(
)
;
return
;
}
#
endif
bool
hasRemoteContent
=
false
;
bool
updatePluginsFlag
=
true
;
AutoResolveRefLayers
resolve
(
mCompositionManager
this
&
hasRemoteContent
&
updatePluginsFlag
)
;
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
if
(
!
hasRemoteContent
&
&
gfxVars
:
:
BrowserTabsRemoteAutostart
(
)
&
&
mCachedPluginData
.
Length
(
)
)
{
Unused
<
<
SendHideAllPlugins
(
GetWidget
(
)
-
>
GetWidgetKey
(
)
)
;
mCachedPluginData
.
Clear
(
)
;
}
#
endif
nsCString
none
;
if
(
aTarget
)
{
mLayerManager
-
>
BeginTransactionWithDrawTarget
(
aTarget
*
aRect
)
;
}
else
{
mLayerManager
-
>
BeginTransaction
(
none
)
;
}
SetShadowProperties
(
mLayerManager
-
>
GetRoot
(
)
)
;
if
(
mForceCompositionTask
&
&
!
mOverrideComposeReadiness
)
{
if
(
mCompositionManager
-
>
ReadyForCompose
(
)
)
{
mForceCompositionTask
-
>
Cancel
(
)
;
mForceCompositionTask
=
nullptr
;
}
else
{
return
;
}
}
mCompositionManager
-
>
ComputeRotation
(
)
;
TimeStamp
time
=
mTestTime
.
valueOr
(
mCompositorScheduler
-
>
GetLastComposeTime
(
)
)
;
bool
requestNextFrame
=
mCompositionManager
-
>
TransformShadowTree
(
time
mVsyncRate
)
;
if
(
requestNextFrame
)
{
ScheduleComposition
(
)
;
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
if
(
!
mPluginWindowsHidden
&
&
mCachedPluginData
.
Length
(
)
)
{
mWaitForPluginsUntil
=
mCompositorScheduler
-
>
GetLastComposeTime
(
)
+
(
mVsyncRate
*
2
)
;
}
#
endif
}
RenderTraceLayers
(
mLayerManager
-
>
GetRoot
(
)
"
0000
"
)
;
if
(
StaticPrefs
:
:
layers_dump_host_layers
(
)
|
|
StaticPrefs
:
:
layers_dump
(
)
)
{
printf_stderr
(
"
Painting
-
-
-
compositing
layer
tree
:
\
n
"
)
;
mLayerManager
-
>
Dump
(
true
)
;
}
mLayerManager
-
>
SetDebugOverlayWantsNextFrame
(
false
)
;
mLayerManager
-
>
EndTransaction
(
time
)
;
if
(
!
aTarget
)
{
TimeStamp
end
=
TimeStamp
:
:
Now
(
)
;
DidComposite
(
aId
start
end
)
;
}
if
(
!
mLayerManager
-
>
GetCompositeUntilTime
(
)
.
IsNull
(
)
|
|
mLayerManager
-
>
DebugOverlayWantsNextFrame
(
)
)
{
ScheduleComposition
(
)
;
}
#
ifdef
COMPOSITOR_PERFORMANCE_WARNING
TimeDuration
executionTime
=
TimeStamp
:
:
Now
(
)
-
mCompositorScheduler
-
>
GetLastComposeTime
(
)
;
TimeDuration
frameBudget
=
TimeDuration
:
:
FromMilliseconds
(
15
)
;
int32_t
frameRate
=
CalculateCompositionFrameRate
(
)
;
if
(
frameRate
>
0
)
{
frameBudget
=
TimeDuration
:
:
FromSeconds
(
1
.
0
/
frameRate
)
;
}
if
(
executionTime
>
frameBudget
)
{
printf_stderr
(
"
Compositor
:
Composite
execution
took
%
4
.
1f
ms
\
n
"
executionTime
.
ToMilliseconds
(
)
)
;
}
#
endif
if
(
StaticPrefs
:
:
layers_offmainthreadcomposition_frame_rate
(
)
=
=
0
|
|
mLayerManager
-
>
AlwaysScheduleComposite
(
)
)
{
ScheduleComposition
(
)
;
}
mLayerManager
-
>
SetCompositionTime
(
TimeStamp
(
)
)
;
mozilla
:
:
Telemetry
:
:
AccumulateTimeDelta
(
mozilla
:
:
Telemetry
:
:
COMPOSITE_TIME
start
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvRemotePluginsReady
(
)
{
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
mWaitForPluginsUntil
=
TimeStamp
(
)
;
if
(
mHaveBlockedForPlugins
)
{
mHaveBlockedForPlugins
=
false
;
ForceComposeToTarget
(
nullptr
)
;
}
else
{
ScheduleComposition
(
)
;
}
return
IPC_OK
(
)
;
#
else
MOZ_ASSERT_UNREACHABLE
(
"
CompositorBridgeParent
:
:
RecvRemotePluginsReady
calls
"
"
unexpected
on
this
platform
.
"
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
#
endif
}
void
CompositorBridgeParent
:
:
ForceComposeToTarget
(
DrawTarget
*
aTarget
const
gfx
:
:
IntRect
*
aRect
)
{
AUTO_PROFILER_LABEL
(
"
CompositorBridgeParent
:
:
ForceComposeToTarget
"
GRAPHICS
)
;
AutoRestore
<
bool
>
override
(
mOverrideComposeReadiness
)
;
mOverrideComposeReadiness
=
true
;
mCompositorScheduler
-
>
ForceComposeToTarget
(
aTarget
aRect
)
;
}
PAPZCTreeManagerParent
*
CompositorBridgeParent
:
:
AllocPAPZCTreeManagerParent
(
const
LayersId
&
aLayersId
)
{
MOZ_ASSERT
(
XRE_IsGPUProcess
(
)
)
;
MOZ_ASSERT
(
mOptions
.
UseAPZ
(
)
)
;
MOZ_ASSERT
(
mApzcTreeManager
)
;
MOZ_ASSERT
(
mApzUpdater
)
;
MOZ_ASSERT
(
!
aLayersId
.
IsValid
(
)
)
;
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
CompositorBridgeParent
:
:
LayerTreeState
&
state
=
sIndirectLayerTrees
[
mRootLayerTreeID
]
;
MOZ_ASSERT
(
state
.
mParent
.
get
(
)
=
=
this
)
;
MOZ_ASSERT
(
!
state
.
mApzcTreeManagerParent
)
;
state
.
mApzcTreeManagerParent
=
new
APZCTreeManagerParent
(
WRRootId
(
mRootLayerTreeID
wr
:
:
RenderRoot
:
:
Default
)
mApzcTreeManager
mApzUpdater
)
;
return
state
.
mApzcTreeManagerParent
;
}
bool
CompositorBridgeParent
:
:
DeallocPAPZCTreeManagerParent
(
PAPZCTreeManagerParent
*
aActor
)
{
delete
aActor
;
return
true
;
}
void
CompositorBridgeParent
:
:
AllocateAPZCTreeManagerParent
(
const
MonitorAutoLock
&
aProofOfLayerTreeStateLock
const
WRRootId
&
aWrRootId
LayerTreeState
&
aState
)
{
MOZ_ASSERT
(
aState
.
mParent
=
=
this
)
;
MOZ_ASSERT
(
mApzcTreeManager
)
;
MOZ_ASSERT
(
mApzUpdater
)
;
MOZ_ASSERT
(
!
aState
.
mApzcTreeManagerParent
)
;
aState
.
mApzcTreeManagerParent
=
new
APZCTreeManagerParent
(
aWrRootId
mApzcTreeManager
mApzUpdater
)
;
}
PAPZParent
*
CompositorBridgeParent
:
:
AllocPAPZParent
(
const
LayersId
&
aLayersId
)
{
MOZ_ASSERT
(
!
aLayersId
.
IsValid
(
)
)
;
RemoteContentController
*
controller
=
new
RemoteContentController
(
)
;
controller
-
>
AddRef
(
)
;
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
CompositorBridgeParent
:
:
LayerTreeState
&
state
=
sIndirectLayerTrees
[
mRootLayerTreeID
]
;
MOZ_ASSERT
(
!
state
.
mController
)
;
state
.
mController
=
controller
;
return
controller
;
}
bool
CompositorBridgeParent
:
:
DeallocPAPZParent
(
PAPZParent
*
aActor
)
{
RemoteContentController
*
controller
=
static_cast
<
RemoteContentController
*
>
(
aActor
)
;
controller
-
>
Release
(
)
;
return
true
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
AndroidDynamicToolbarAnimator
*
CompositorBridgeParent
:
:
GetAndroidDynamicToolbarAnimator
(
)
{
return
mApzcTreeManager
?
mApzcTreeManager
-
>
GetAndroidDynamicToolbarAnimator
(
)
:
nullptr
;
}
#
endif
RefPtr
<
APZSampler
>
CompositorBridgeParent
:
:
GetAPZSampler
(
)
{
return
mApzSampler
;
}
RefPtr
<
APZUpdater
>
CompositorBridgeParent
:
:
GetAPZUpdater
(
)
{
return
mApzUpdater
;
}
CompositorBridgeParent
*
CompositorBridgeParent
:
:
GetCompositorBridgeParentFromLayersId
(
const
LayersId
&
aLayersId
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
return
sIndirectLayerTrees
[
aLayersId
]
.
mParent
;
}
RefPtr
<
CompositorBridgeParent
>
CompositorBridgeParent
:
:
GetCompositorBridgeParentFromWindowId
(
const
wr
:
:
WindowId
&
aWindowId
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
for
(
auto
it
=
sIndirectLayerTrees
.
begin
(
)
;
it
!
=
sIndirectLayerTrees
.
end
(
)
;
it
+
+
)
{
LayerTreeState
*
state
=
&
it
-
>
second
;
if
(
!
state
-
>
mWrBridge
)
{
continue
;
}
if
(
RefPtr
<
wr
:
:
WebRenderAPI
>
api
=
state
-
>
mWrBridge
-
>
GetWebRenderAPI
(
wr
:
:
RenderRoot
:
:
Default
)
)
{
if
(
api
-
>
GetId
(
)
=
=
aWindowId
)
{
return
state
-
>
mParent
;
}
}
}
return
nullptr
;
}
bool
CompositorBridgeParent
:
:
CanComposite
(
)
{
return
mLayerManager
&
&
mLayerManager
-
>
GetRoot
(
)
&
&
!
mPaused
;
}
void
CompositorBridgeParent
:
:
ScheduleRotationOnCompositorThread
(
const
TargetConfig
&
aTargetConfig
bool
aIsFirstPaint
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
if
(
!
aIsFirstPaint
&
&
!
mCompositionManager
-
>
IsFirstPaint
(
)
&
&
mCompositionManager
-
>
RequiresReorientation
(
aTargetConfig
.
orientation
(
)
)
)
{
if
(
mForceCompositionTask
!
=
nullptr
)
{
mForceCompositionTask
-
>
Cancel
(
)
;
}
RefPtr
<
CancelableRunnable
>
task
=
NewCancelableRunnableMethod
(
"
layers
:
:
CompositorBridgeParent
:
:
ForceComposition
"
this
&
CompositorBridgeParent
:
:
ForceComposition
)
;
mForceCompositionTask
=
task
;
ScheduleTask
(
task
.
forget
(
)
StaticPrefs
:
:
layers_orientation_sync_timeout
(
)
)
;
}
}
void
CompositorBridgeParent
:
:
ShadowLayersUpdated
(
LayerTransactionParent
*
aLayerTree
const
TransactionInfo
&
aInfo
bool
aHitTestUpdate
)
{
const
TargetConfig
&
targetConfig
=
aInfo
.
targetConfig
(
)
;
ScheduleRotationOnCompositorThread
(
targetConfig
aInfo
.
isFirstPaint
(
)
)
;
mLayerManager
-
>
UpdateRenderBounds
(
targetConfig
.
naturalBounds
(
)
)
;
mLayerManager
-
>
SetRegionToClear
(
targetConfig
.
clearRegion
(
)
)
;
if
(
mLayerManager
-
>
GetCompositor
(
)
)
{
mLayerManager
-
>
GetCompositor
(
)
-
>
SetScreenRotation
(
targetConfig
.
rotation
(
)
)
;
}
mCompositionManager
-
>
Updated
(
aInfo
.
isFirstPaint
(
)
targetConfig
)
;
Layer
*
root
=
aLayerTree
-
>
GetRoot
(
)
;
mLayerManager
-
>
SetRoot
(
root
)
;
if
(
mApzUpdater
&
&
!
aInfo
.
isRepeatTransaction
(
)
)
{
mApzUpdater
-
>
UpdateFocusState
(
mRootLayerTreeID
WRRootId
:
:
NonWebRender
(
mRootLayerTreeID
)
aInfo
.
focusTarget
(
)
)
;
if
(
aHitTestUpdate
)
{
AutoResolveRefLayers
resolve
(
mCompositionManager
)
;
mApzUpdater
-
>
UpdateHitTestingTree
(
root
aInfo
.
isFirstPaint
(
)
mRootLayerTreeID
aInfo
.
paintSequenceNumber
(
)
)
;
}
}
MOZ_ASSERT
(
aInfo
.
id
(
)
=
=
TransactionId
{
1
}
|
|
aInfo
.
id
(
)
>
mPendingTransaction
)
;
mPendingTransaction
=
aInfo
.
id
(
)
;
mRefreshStartTime
=
aInfo
.
refreshStart
(
)
;
mTxnStartTime
=
aInfo
.
transactionStart
(
)
;
mFwdTime
=
aInfo
.
fwdTime
(
)
;
RegisterPayloads
(
aLayerTree
aInfo
.
payload
(
)
)
;
if
(
root
)
{
SetShadowProperties
(
root
)
;
}
if
(
aInfo
.
scheduleComposite
(
)
)
{
ScheduleComposition
(
)
;
if
(
mPaused
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
DidComposite
(
VsyncId
(
)
now
now
)
;
}
}
mLayerManager
-
>
NotifyShadowTreeTransaction
(
)
;
}
void
CompositorBridgeParent
:
:
ScheduleComposite
(
LayerTransactionParent
*
aLayerTree
)
{
ScheduleComposition
(
)
;
}
bool
CompositorBridgeParent
:
:
SetTestSampleTime
(
const
LayersId
&
aId
const
TimeStamp
&
aTime
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
if
(
aTime
.
IsNull
(
)
)
{
return
false
;
}
mTestTime
=
Some
(
aTime
)
;
if
(
mApzcTreeManager
)
{
mApzcTreeManager
-
>
SetTestSampleTime
(
mTestTime
)
;
}
if
(
mWrBridge
)
{
mWrBridge
-
>
FlushRendering
(
)
;
return
true
;
}
bool
testComposite
=
mCompositionManager
&
&
mCompositorScheduler
-
>
NeedsComposite
(
)
;
if
(
testComposite
)
{
AutoResolveRefLayers
resolve
(
mCompositionManager
)
;
bool
requestNextFrame
=
mCompositionManager
-
>
TransformShadowTree
(
aTime
mVsyncRate
)
;
if
(
!
requestNextFrame
)
{
CancelCurrentCompositeTask
(
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
DidComposite
(
VsyncId
(
)
now
now
)
;
}
}
return
true
;
}
void
CompositorBridgeParent
:
:
LeaveTestMode
(
const
LayersId
&
aId
)
{
mTestTime
=
Nothing
(
)
;
if
(
mApzcTreeManager
)
{
mApzcTreeManager
-
>
SetTestSampleTime
(
mTestTime
)
;
}
}
void
CompositorBridgeParent
:
:
ApplyAsyncProperties
(
LayerTransactionParent
*
aLayerTree
TransformsToSkip
aSkip
)
{
if
(
aLayerTree
-
>
GetRoot
(
)
)
{
AutoResolveRefLayers
resolve
(
mCompositionManager
)
;
SetShadowProperties
(
mLayerManager
-
>
GetRoot
(
)
)
;
TimeStamp
time
=
mTestTime
.
valueOr
(
mCompositorScheduler
-
>
GetLastComposeTime
(
)
)
;
bool
requestNextFrame
=
mCompositionManager
-
>
TransformShadowTree
(
time
mVsyncRate
aSkip
)
;
if
(
!
requestNextFrame
)
{
CancelCurrentCompositeTask
(
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
DidComposite
(
VsyncId
(
)
now
now
)
;
}
}
}
CompositorAnimationStorage
*
CompositorBridgeParent
:
:
GetAnimationStorage
(
)
{
if
(
!
mAnimationStorage
)
{
mAnimationStorage
=
new
CompositorAnimationStorage
(
)
;
}
return
mAnimationStorage
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvGetFrameUniformity
(
FrameUniformityData
*
aOutData
)
{
mCompositionManager
-
>
GetFrameUniformity
(
aOutData
)
;
return
IPC_OK
(
)
;
}
void
CompositorBridgeParent
:
:
SetTestAsyncScrollOffset
(
const
WRRootId
&
aWrRootId
const
ScrollableLayerGuid
:
:
ViewID
&
aScrollId
const
CSSPoint
&
aPoint
)
{
if
(
mApzUpdater
)
{
MOZ_ASSERT
(
aWrRootId
.
IsValid
(
)
)
;
mApzUpdater
-
>
SetTestAsyncScrollOffset
(
aWrRootId
aScrollId
aPoint
)
;
}
}
void
CompositorBridgeParent
:
:
SetTestAsyncZoom
(
const
WRRootId
&
aWrRootId
const
ScrollableLayerGuid
:
:
ViewID
&
aScrollId
const
LayerToParentLayerScale
&
aZoom
)
{
if
(
mApzUpdater
)
{
MOZ_ASSERT
(
aWrRootId
.
IsValid
(
)
)
;
mApzUpdater
-
>
SetTestAsyncZoom
(
aWrRootId
aScrollId
aZoom
)
;
}
}
void
CompositorBridgeParent
:
:
FlushApzRepaints
(
const
WRRootId
&
aWrRootId
)
{
MOZ_ASSERT
(
mApzUpdater
)
;
MOZ_ASSERT
(
aWrRootId
.
IsValid
(
)
)
;
mApzUpdater
-
>
RunOnControllerThread
(
UpdaterQueueSelector
(
aWrRootId
)
NS_NewRunnableFunction
(
"
layers
:
:
CompositorBridgeParent
:
:
FlushApzRepaints
"
[
=
]
(
)
{
APZCTreeManager
:
:
FlushApzRepaints
(
aWrRootId
.
mLayersId
)
;
}
)
)
;
}
void
CompositorBridgeParent
:
:
GetAPZTestData
(
const
WRRootId
&
aWrRootId
APZTestData
*
aOutData
)
{
if
(
mApzUpdater
)
{
MOZ_ASSERT
(
aWrRootId
.
IsValid
(
)
)
;
mApzUpdater
-
>
GetAPZTestData
(
aWrRootId
aOutData
)
;
}
}
void
CompositorBridgeParent
:
:
SetConfirmedTargetAPZC
(
const
LayersId
&
aLayersId
const
uint64_t
&
aInputBlockId
const
nsTArray
<
SLGuidAndRenderRoot
>
&
aTargets
)
{
if
(
!
mApzcTreeManager
|
|
!
mApzUpdater
)
{
return
;
}
void
(
APZCTreeManager
:
:
*
setTargetApzcFunc
)
(
uint64_t
const
nsTArray
<
SLGuidAndRenderRoot
>
&
)
=
&
APZCTreeManager
:
:
SetTargetAPZC
;
RefPtr
<
Runnable
>
task
=
NewRunnableMethod
<
uint64_t
StoreCopyPassByConstLRef
<
nsTArray
<
SLGuidAndRenderRoot
>
>
>
(
"
layers
:
:
CompositorBridgeParent
:
:
SetConfirmedTargetAPZC
"
mApzcTreeManager
.
get
(
)
setTargetApzcFunc
aInputBlockId
aTargets
)
;
UpdaterQueueSelector
selector
(
aLayersId
)
;
for
(
size_t
i
=
0
;
i
<
aTargets
.
Length
(
)
;
i
+
+
)
{
selector
.
mRenderRoots
+
=
aTargets
[
i
]
.
mRenderRoot
;
}
mApzUpdater
-
>
RunOnControllerThread
(
selector
task
.
forget
(
)
)
;
}
void
CompositorBridgeParent
:
:
SetFixedLayerMargins
(
ScreenIntCoord
aTop
ScreenIntCoord
aBottom
)
{
if
(
AsyncCompositionManager
*
manager
=
GetCompositionManager
(
nullptr
)
)
{
manager
-
>
SetFixedLayerMargins
(
aTop
aBottom
)
;
}
if
(
mApzcTreeManager
)
{
mApzcTreeManager
-
>
SetFixedLayerMargins
(
aTop
aBottom
)
;
}
Invalidate
(
)
;
ScheduleComposition
(
)
;
}
void
CompositorBridgeParent
:
:
InitializeLayerManager
(
const
nsTArray
<
LayersBackend
>
&
aBackendHints
)
{
NS_ASSERTION
(
!
mLayerManager
"
Already
initialised
mLayerManager
"
)
;
NS_ASSERTION
(
!
mCompositor
"
Already
initialised
mCompositor
"
)
;
if
(
!
InitializeAdvancedLayers
(
aBackendHints
nullptr
)
)
{
mCompositor
=
NewCompositor
(
aBackendHints
)
;
if
(
!
mCompositor
)
{
return
;
}
#
ifdef
XP_WIN
if
(
mCompositor
-
>
AsBasicCompositor
(
)
&
&
XRE_IsGPUProcess
(
)
)
{
mWidget
-
>
AsWindows
(
)
-
>
DestroyCompositorWindow
(
)
;
}
#
endif
mLayerManager
=
new
LayerManagerComposite
(
mCompositor
)
;
}
mLayerManager
-
>
SetCompositorBridgeID
(
mCompositorBridgeID
)
;
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
sIndirectLayerTrees
[
mRootLayerTreeID
]
.
mLayerManager
=
mLayerManager
;
}
bool
CompositorBridgeParent
:
:
InitializeAdvancedLayers
(
const
nsTArray
<
LayersBackend
>
&
aBackendHints
TextureFactoryIdentifier
*
aOutIdentifier
)
{
#
ifdef
XP_WIN
if
(
!
mOptions
.
UseAdvancedLayers
(
)
)
{
return
false
;
}
if
(
!
aBackendHints
.
Contains
(
LayersBackend
:
:
LAYERS_D3D11
)
)
{
return
false
;
}
RefPtr
<
LayerManagerMLGPU
>
manager
=
new
LayerManagerMLGPU
(
mWidget
)
;
if
(
!
manager
-
>
Initialize
(
)
)
{
return
false
;
}
if
(
aOutIdentifier
)
{
*
aOutIdentifier
=
manager
-
>
GetTextureFactoryIdentifier
(
)
;
}
mLayerManager
=
manager
;
return
true
;
#
else
return
false
;
#
endif
}
RefPtr
<
Compositor
>
CompositorBridgeParent
:
:
NewCompositor
(
const
nsTArray
<
LayersBackend
>
&
aBackendHints
)
{
for
(
size_t
i
=
0
;
i
<
aBackendHints
.
Length
(
)
;
+
+
i
)
{
RefPtr
<
Compositor
>
compositor
;
if
(
aBackendHints
[
i
]
=
=
LayersBackend
:
:
LAYERS_OPENGL
)
{
compositor
=
new
CompositorOGL
(
this
mWidget
mEGLSurfaceSize
.
width
mEGLSurfaceSize
.
height
mUseExternalSurfaceSize
)
;
}
else
if
(
aBackendHints
[
i
]
=
=
LayersBackend
:
:
LAYERS_BASIC
)
{
#
ifdef
MOZ_WIDGET_GTK
if
(
gfxVars
:
:
UseXRender
(
)
)
{
compositor
=
new
X11BasicCompositor
(
this
mWidget
)
;
}
else
#
endif
{
compositor
=
new
BasicCompositor
(
this
mWidget
)
;
}
#
ifdef
XP_WIN
}
else
if
(
aBackendHints
[
i
]
=
=
LayersBackend
:
:
LAYERS_D3D11
)
{
compositor
=
new
CompositorD3D11
(
this
mWidget
)
;
#
endif
}
nsCString
failureReason
;
const
int
max_fb_size
=
32767
;
const
LayoutDeviceIntSize
size
=
mWidget
-
>
GetClientSize
(
)
;
if
(
size
.
width
>
max_fb_size
|
|
size
.
height
>
max_fb_size
)
{
failureReason
=
"
FEATURE_FAILURE_MAX_FRAMEBUFFER_SIZE
"
;
return
nullptr
;
}
MOZ_ASSERT
(
!
gfxVars
:
:
UseWebRender
(
)
|
|
aBackendHints
[
i
]
=
=
LayersBackend
:
:
LAYERS_BASIC
)
;
if
(
compositor
&
&
compositor
-
>
Initialize
(
&
failureReason
)
)
{
if
(
failureReason
.
IsEmpty
(
)
)
{
failureReason
=
"
SUCCESS
"
;
}
if
(
aBackendHints
[
i
]
=
=
LayersBackend
:
:
LAYERS_OPENGL
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
OPENGL_COMPOSITING_FAILURE_ID
failureReason
)
;
}
#
ifdef
XP_WIN
else
if
(
aBackendHints
[
i
]
=
=
LayersBackend
:
:
LAYERS_D3D11
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
D3D11_COMPOSITING_FAILURE_ID
failureReason
)
;
}
#
endif
return
compositor
;
}
if
(
aBackendHints
[
i
]
=
=
LayersBackend
:
:
LAYERS_OPENGL
)
{
gfxCriticalNote
<
<
"
[
OPENGL
]
Failed
to
init
compositor
with
reason
:
"
<
<
failureReason
.
get
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
OPENGL_COMPOSITING_FAILURE_ID
failureReason
)
;
}
#
ifdef
XP_WIN
else
if
(
aBackendHints
[
i
]
=
=
LayersBackend
:
:
LAYERS_D3D11
)
{
gfxCriticalNote
<
<
"
[
D3D11
]
Failed
to
init
compositor
with
reason
:
"
<
<
failureReason
.
get
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
D3D11_COMPOSITING_FAILURE_ID
failureReason
)
;
}
#
endif
}
return
nullptr
;
}
PLayerTransactionParent
*
CompositorBridgeParent
:
:
AllocPLayerTransactionParent
(
const
nsTArray
<
LayersBackend
>
&
aBackendHints
const
LayersId
&
aId
)
{
MOZ_ASSERT
(
!
aId
.
IsValid
(
)
)
;
#
ifdef
XP_WIN
if
(
gfxVars
:
:
UseDoubleBufferingWithCompositor
(
)
&
&
XRE_IsGPUProcess
(
)
&
&
aBackendHints
.
Contains
(
LayersBackend
:
:
LAYERS_D3D11
)
)
{
mWidget
-
>
AsWindows
(
)
-
>
EnsureCompositorWindow
(
)
;
}
#
endif
InitializeLayerManager
(
aBackendHints
)
;
if
(
!
mLayerManager
)
{
NS_WARNING
(
"
Failed
to
initialise
Compositor
"
)
;
LayerTransactionParent
*
p
=
new
LayerTransactionParent
(
nullptr
this
nullptr
mRootLayerTreeID
mVsyncRate
)
;
p
-
>
AddIPDLReference
(
)
;
return
p
;
}
mCompositionManager
=
new
AsyncCompositionManager
(
this
mLayerManager
)
;
LayerTransactionParent
*
p
=
new
LayerTransactionParent
(
mLayerManager
this
GetAnimationStorage
(
)
mRootLayerTreeID
mVsyncRate
)
;
p
-
>
AddIPDLReference
(
)
;
return
p
;
}
bool
CompositorBridgeParent
:
:
DeallocPLayerTransactionParent
(
PLayerTransactionParent
*
actor
)
{
static_cast
<
LayerTransactionParent
*
>
(
actor
)
-
>
ReleaseIPDLReference
(
)
;
return
true
;
}
CompositorBridgeParent
*
CompositorBridgeParent
:
:
GetCompositorBridgeParent
(
uint64_t
id
)
{
AssertIsInCompositorThread
(
)
;
CompositorMap
:
:
iterator
it
=
sCompositorMap
-
>
find
(
id
)
;
return
it
!
=
sCompositorMap
-
>
end
(
)
?
it
-
>
second
:
nullptr
;
}
void
CompositorBridgeParent
:
:
AddCompositor
(
CompositorBridgeParent
*
compositor
uint64_t
*
outID
)
{
AssertIsInCompositorThread
(
)
;
static
uint64_t
sNextID
=
1
;
+
+
sNextID
;
(
*
sCompositorMap
)
[
sNextID
]
=
compositor
;
*
outID
=
sNextID
;
}
CompositorBridgeParent
*
CompositorBridgeParent
:
:
RemoveCompositor
(
uint64_t
id
)
{
AssertIsInCompositorThread
(
)
;
CompositorMap
:
:
iterator
it
=
sCompositorMap
-
>
find
(
id
)
;
if
(
it
=
=
sCompositorMap
-
>
end
(
)
)
{
return
nullptr
;
}
CompositorBridgeParent
*
retval
=
it
-
>
second
;
sCompositorMap
-
>
erase
(
it
)
;
return
retval
;
}
void
CompositorBridgeParent
:
:
NotifyVsync
(
const
VsyncEvent
&
aVsync
const
LayersId
&
aLayersId
)
{
MOZ_ASSERT
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_GPU
)
;
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
auto
it
=
sIndirectLayerTrees
.
find
(
aLayersId
)
;
if
(
it
=
=
sIndirectLayerTrees
.
end
(
)
)
return
;
CompositorBridgeParent
*
cbp
=
it
-
>
second
.
mParent
;
if
(
!
cbp
|
|
!
cbp
-
>
mWidget
)
return
;
RefPtr
<
VsyncObserver
>
obs
=
cbp
-
>
mWidget
-
>
GetVsyncObserver
(
)
;
if
(
!
obs
)
return
;
obs
-
>
NotifyVsync
(
aVsync
)
;
}
void
CompositorBridgeParent
:
:
ScheduleForcedComposition
(
const
LayersId
&
aLayersId
)
{
MOZ_ASSERT
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_GPU
)
;
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
auto
it
=
sIndirectLayerTrees
.
find
(
aLayersId
)
;
if
(
it
=
=
sIndirectLayerTrees
.
end
(
)
)
{
return
;
}
CompositorBridgeParent
*
cbp
=
it
-
>
second
.
mParent
;
if
(
!
cbp
|
|
!
cbp
-
>
mWidget
)
{
return
;
}
if
(
cbp
-
>
mWrBridge
)
{
cbp
-
>
mWrBridge
-
>
ScheduleForcedGenerateFrame
(
)
;
}
else
if
(
cbp
-
>
CanComposite
(
)
)
{
cbp
-
>
mCompositorScheduler
-
>
ScheduleComposition
(
)
;
}
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvNotifyChildCreated
(
const
LayersId
&
child
CompositorOptions
*
aOptions
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
NotifyChildCreated
(
child
)
;
*
aOptions
=
mOptions
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvNotifyChildRecreated
(
const
LayersId
&
aChild
CompositorOptions
*
aOptions
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
if
(
sIndirectLayerTrees
.
find
(
aChild
)
!
=
sIndirectLayerTrees
.
end
(
)
)
{
NS_WARNING
(
"
Invalid
to
register
the
same
layer
tree
twice
"
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
NotifyChildCreated
(
aChild
)
;
*
aOptions
=
mOptions
;
return
IPC_OK
(
)
;
}
void
CompositorBridgeParent
:
:
NotifyChildCreated
(
LayersId
aChild
)
{
sIndirectLayerTreesLock
-
>
AssertCurrentThreadOwns
(
)
;
sIndirectLayerTrees
[
aChild
]
.
mParent
=
this
;
sIndirectLayerTrees
[
aChild
]
.
mLayerManager
=
mLayerManager
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvMapAndNotifyChildCreated
(
const
LayersId
&
aChild
const
base
:
:
ProcessId
&
aOwnerPid
CompositorOptions
*
aOptions
)
{
MOZ_ASSERT
(
XRE_IsGPUProcess
(
)
)
;
LayerTreeOwnerTracker
:
:
Get
(
)
-
>
Map
(
aChild
aOwnerPid
)
;
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
NotifyChildCreated
(
aChild
)
;
*
aOptions
=
mOptions
;
return
IPC_OK
(
)
;
}
enum
class
CompositorOptionsChangeKind
{
eSupported
eBestEffort
eUnsupported
}
;
static
CompositorOptionsChangeKind
ClassifyCompositorOptionsChange
(
const
CompositorOptions
&
aOld
const
CompositorOptions
&
aNew
)
{
if
(
aOld
=
=
aNew
)
{
return
CompositorOptionsChangeKind
:
:
eSupported
;
}
if
(
aOld
.
UseAdvancedLayers
(
)
=
=
aNew
.
UseAdvancedLayers
(
)
&
&
aOld
.
UseWebRender
(
)
=
=
aNew
.
UseWebRender
(
)
&
&
aOld
.
InitiallyPaused
(
)
=
=
aNew
.
InitiallyPaused
(
)
)
{
return
CompositorOptionsChangeKind
:
:
eBestEffort
;
}
return
CompositorOptionsChangeKind
:
:
eUnsupported
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvAdoptChild
(
const
LayersId
&
child
)
{
RefPtr
<
APZUpdater
>
oldApzUpdater
;
APZCTreeManagerParent
*
parent
;
bool
scheduleComposition
=
false
;
bool
apzEnablementChanged
=
false
;
RefPtr
<
ContentCompositorBridgeParent
>
cpcp
;
RefPtr
<
WebRenderBridgeParent
>
childWrBridge
;
RefPtr
<
GeckoContentController
>
oldRootController
=
GetGeckoContentControllerForRoot
(
child
)
;
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
if
(
sIndirectLayerTrees
[
child
]
.
mParent
=
=
this
)
{
return
IPC_OK
(
)
;
}
if
(
sIndirectLayerTrees
[
child
]
.
mParent
)
{
switch
(
ClassifyCompositorOptionsChange
(
sIndirectLayerTrees
[
child
]
.
mParent
-
>
mOptions
mOptions
)
)
{
case
CompositorOptionsChangeKind
:
:
eUnsupported
:
{
MOZ_ASSERT
(
false
"
Moving
tab
between
windows
whose
compositor
options
"
"
differ
in
unsupported
ways
.
Things
may
break
in
"
"
unexpected
ways
"
)
;
break
;
}
case
CompositorOptionsChangeKind
:
:
eBestEffort
:
{
NS_WARNING
(
"
Moving
tab
between
windows
with
different
APZ
enablement
.
"
"
This
is
supported
on
a
best
-
effort
basis
but
some
things
may
"
"
break
.
"
)
;
apzEnablementChanged
=
true
;
break
;
}
case
CompositorOptionsChangeKind
:
:
eSupported
:
{
break
;
}
}
oldApzUpdater
=
sIndirectLayerTrees
[
child
]
.
mParent
-
>
mApzUpdater
;
}
NotifyChildCreated
(
child
)
;
if
(
sIndirectLayerTrees
[
child
]
.
mLayerTree
)
{
sIndirectLayerTrees
[
child
]
.
mLayerTree
-
>
SetLayerManager
(
mLayerManager
GetAnimationStorage
(
)
)
;
scheduleComposition
=
true
;
}
if
(
mWrBridge
)
{
childWrBridge
=
sIndirectLayerTrees
[
child
]
.
mWrBridge
;
cpcp
=
sIndirectLayerTrees
[
child
]
.
mContentCompositorBridgeParent
;
}
parent
=
sIndirectLayerTrees
[
child
]
.
mApzcTreeManagerParent
;
}
if
(
scheduleComposition
)
{
ScheduleComposition
(
)
;
}
if
(
childWrBridge
)
{
MOZ_ASSERT
(
mWrBridge
)
;
nsTArray
<
RefPtr
<
wr
:
:
WebRenderAPI
>
>
apis
;
DebugOnly
<
bool
>
cloneSuccess
=
mWrBridge
-
>
CloneWebRenderAPIs
(
apis
)
;
MOZ_ASSERT
(
cloneSuccess
)
;
wr
:
:
Epoch
newEpoch
=
childWrBridge
-
>
UpdateWebRender
(
mWrBridge
-
>
CompositorScheduler
(
)
std
:
:
move
(
apis
)
mWrBridge
-
>
AsyncImageManager
(
)
GetAnimationStorage
(
)
mWrBridge
-
>
GetTextureFactoryIdentifier
(
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
NotifyPipelineRendered
(
childWrBridge
-
>
PipelineId
(
)
newEpoch
VsyncId
(
)
now
now
now
)
;
}
if
(
oldApzUpdater
)
{
if
(
!
mApzUpdater
&
&
oldRootController
)
{
oldApzUpdater
-
>
MarkAsDetached
(
child
)
;
nsTArray
<
MatrixMessage
>
clear
;
clear
.
AppendElement
(
MatrixMessage
(
Nothing
(
)
ScreenRect
(
)
child
)
)
;
oldRootController
-
>
NotifyLayerTransforms
(
clear
)
;
}
}
if
(
mApzUpdater
)
{
if
(
parent
)
{
MOZ_ASSERT
(
mApzcTreeManager
)
;
parent
-
>
ChildAdopted
(
mApzcTreeManager
mApzUpdater
)
;
}
mApzUpdater
-
>
NotifyLayerTreeAdopted
(
WRRootId
(
child
gfxUtils
:
:
GetContentRenderRoot
(
)
)
oldApzUpdater
)
;
}
if
(
apzEnablementChanged
)
{
Unused
<
<
SendCompositorOptionsChanged
(
child
mOptions
)
;
}
return
IPC_OK
(
)
;
}
PWebRenderBridgeParent
*
CompositorBridgeParent
:
:
AllocPWebRenderBridgeParent
(
const
wr
:
:
PipelineId
&
aPipelineId
const
LayoutDeviceIntSize
&
aSize
)
{
MOZ_ASSERT
(
wr
:
:
AsLayersId
(
aPipelineId
)
=
=
mRootLayerTreeID
)
;
MOZ_ASSERT
(
!
mWrBridge
)
;
MOZ_ASSERT
(
!
mCompositor
)
;
MOZ_ASSERT
(
!
mCompositorScheduler
)
;
MOZ_ASSERT
(
mWidget
)
;
#
ifdef
XP_WIN
if
(
mWidget
&
&
(
DeviceManagerDx
:
:
Get
(
)
-
>
CanUseDComp
(
)
|
|
gfxVars
:
:
UseWebRenderFlipSequentialWin
(
)
)
)
{
mWidget
-
>
AsWindows
(
)
-
>
EnsureCompositorWindow
(
)
;
}
#
endif
RefPtr
<
widget
:
:
CompositorWidget
>
widget
=
mWidget
;
wr
:
:
WrWindowId
windowId
=
wr
:
:
NewWindowId
(
)
;
if
(
mApzUpdater
)
{
mApzUpdater
-
>
SetWebRenderWindowId
(
windowId
)
;
}
if
(
mApzSampler
)
{
mApzSampler
-
>
SetWebRenderWindowId
(
windowId
)
;
}
nsTArray
<
RefPtr
<
wr
:
:
WebRenderAPI
>
>
apis
;
apis
.
AppendElement
(
wr
:
:
WebRenderAPI
:
:
Create
(
this
std
:
:
move
(
widget
)
windowId
aSize
)
)
;
if
(
!
apis
[
0
]
)
{
mWrBridge
=
WebRenderBridgeParent
:
:
CreateDestroyed
(
aPipelineId
)
;
mWrBridge
.
get
(
)
-
>
AddRef
(
)
;
return
mWrBridge
;
}
if
(
StaticPrefs
:
:
gfx_webrender_split_render_roots_AtStartup
(
)
)
{
apis
.
AppendElement
(
apis
[
0
]
-
>
CreateDocument
(
aSize
1
wr
:
:
RenderRoot
:
:
Content
)
)
;
apis
.
AppendElement
(
apis
[
0
]
-
>
CreateDocument
(
aSize
2
wr
:
:
RenderRoot
:
:
Popover
)
)
;
}
nsTArray
<
RefPtr
<
wr
:
:
WebRenderAPI
>
>
clonedApis
;
for
(
auto
&
api
:
apis
)
{
wr
:
:
TransactionBuilder
txn
;
txn
.
SetRootPipeline
(
aPipelineId
)
;
api
-
>
SendTransaction
(
txn
)
;
clonedApis
.
AppendElement
(
api
-
>
Clone
(
)
)
;
}
bool
useCompositorWnd
=
false
;
#
ifdef
XP_WIN
useCompositorWnd
=
!
!
mWidget
-
>
AsWindows
(
)
-
>
GetCompositorHwnd
(
)
;
#
endif
mAsyncImageManager
=
new
AsyncImagePipelineManager
(
std
:
:
move
(
clonedApis
)
useCompositorWnd
)
;
RefPtr
<
AsyncImagePipelineManager
>
asyncMgr
=
mAsyncImageManager
;
RefPtr
<
CompositorAnimationStorage
>
animStorage
=
GetAnimationStorage
(
)
;
mWrBridge
=
new
WebRenderBridgeParent
(
this
aPipelineId
mWidget
nullptr
std
:
:
move
(
apis
)
std
:
:
move
(
asyncMgr
)
std
:
:
move
(
animStorage
)
mVsyncRate
)
;
mWrBridge
.
get
(
)
-
>
AddRef
(
)
;
mCompositorScheduler
=
mWrBridge
-
>
CompositorScheduler
(
)
;
MOZ_ASSERT
(
mCompositorScheduler
)
;
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
MOZ_ASSERT
(
sIndirectLayerTrees
[
mRootLayerTreeID
]
.
mWrBridge
=
=
nullptr
)
;
sIndirectLayerTrees
[
mRootLayerTreeID
]
.
mWrBridge
=
mWrBridge
;
}
return
mWrBridge
;
}
bool
CompositorBridgeParent
:
:
DeallocPWebRenderBridgeParent
(
PWebRenderBridgeParent
*
aActor
)
{
WebRenderBridgeParent
*
parent
=
static_cast
<
WebRenderBridgeParent
*
>
(
aActor
)
;
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
auto
it
=
sIndirectLayerTrees
.
find
(
wr
:
:
AsLayersId
(
parent
-
>
PipelineId
(
)
)
)
;
if
(
it
!
=
sIndirectLayerTrees
.
end
(
)
)
{
it
-
>
second
.
mWrBridge
=
nullptr
;
}
}
parent
-
>
Release
(
)
;
return
true
;
}
webgpu
:
:
PWebGPUParent
*
CompositorBridgeParent
:
:
AllocPWebGPUParent
(
)
{
MOZ_ASSERT
(
!
mWebGPUBridge
)
;
mWebGPUBridge
=
new
webgpu
:
:
WebGPUParent
(
)
;
mWebGPUBridge
.
get
(
)
-
>
AddRef
(
)
;
return
mWebGPUBridge
;
}
bool
CompositorBridgeParent
:
:
DeallocPWebGPUParent
(
webgpu
:
:
PWebGPUParent
*
aActor
)
{
webgpu
:
:
WebGPUParent
*
parent
=
static_cast
<
webgpu
:
:
WebGPUParent
*
>
(
aActor
)
;
MOZ_ASSERT
(
mWebGPUBridge
=
=
parent
)
;
parent
-
>
Release
(
)
;
mWebGPUBridge
=
nullptr
;
return
true
;
}
void
CompositorBridgeParent
:
:
NotifyMemoryPressure
(
)
{
if
(
mWrBridge
)
{
RefPtr
<
wr
:
:
WebRenderAPI
>
api
=
mWrBridge
-
>
GetWebRenderAPI
(
wr
:
:
RenderRoot
:
:
Default
)
;
if
(
api
)
{
api
-
>
NotifyMemoryPressure
(
)
;
}
}
}
void
CompositorBridgeParent
:
:
AccumulateMemoryReport
(
wr
:
:
MemoryReport
*
aReport
)
{
if
(
mWrBridge
)
{
RefPtr
<
wr
:
:
WebRenderAPI
>
api
=
mWrBridge
-
>
GetWebRenderAPI
(
wr
:
:
RenderRoot
:
:
Default
)
;
if
(
api
)
{
api
-
>
AccumulateMemoryReport
(
aReport
)
;
}
}
}
void
CompositorBridgeParent
:
:
InitializeStatics
(
)
{
gfxVars
:
:
SetAllowSacrificingSubpixelAAListener
(
&
UpdateQualitySettings
)
;
gfxVars
:
:
SetWebRenderDebugFlagsListener
(
&
UpdateDebugFlags
)
;
gfxVars
:
:
SetUseWebRenderMultithreadingListener
(
&
UpdateWebRenderMultithreading
)
;
gfxVars
:
:
SetWebRenderBatchingLookbackListener
(
&
UpdateWebRenderBatchingParameters
)
;
}
void
CompositorBridgeParent
:
:
UpdateQualitySettings
(
)
{
if
(
!
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
{
if
(
CompositorLoop
(
)
)
{
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
"
CompositorBridgeParent
:
:
UpdateQualitySettings
"
&
CompositorBridgeParent
:
:
UpdateQualitySettings
)
)
;
}
return
;
}
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
ForEachWebRenderBridgeParent
(
[
&
]
(
WebRenderBridgeParent
*
wrBridge
)
-
>
void
{
wrBridge
-
>
UpdateQualitySettings
(
)
;
}
)
;
}
void
CompositorBridgeParent
:
:
UpdateDebugFlags
(
)
{
if
(
!
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
{
if
(
CompositorLoop
(
)
)
{
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
"
CompositorBridgeParent
:
:
UpdateDebugFlags
"
&
CompositorBridgeParent
:
:
UpdateDebugFlags
)
)
;
}
return
;
}
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
ForEachWebRenderBridgeParent
(
[
&
]
(
WebRenderBridgeParent
*
wrBridge
)
-
>
void
{
wrBridge
-
>
UpdateDebugFlags
(
)
;
}
)
;
}
void
CompositorBridgeParent
:
:
UpdateWebRenderMultithreading
(
)
{
if
(
!
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
{
if
(
CompositorLoop
(
)
)
{
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
"
CompositorBridgeParent
:
:
UpdateWebRenderMultithreading
"
&
CompositorBridgeParent
:
:
UpdateWebRenderMultithreading
)
)
;
}
return
;
}
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
ForEachWebRenderBridgeParent
(
[
&
]
(
WebRenderBridgeParent
*
wrBridge
)
-
>
void
{
wrBridge
-
>
UpdateMultithreading
(
)
;
}
)
;
}
void
CompositorBridgeParent
:
:
UpdateWebRenderBatchingParameters
(
)
{
if
(
!
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
{
if
(
CompositorLoop
(
)
)
{
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
"
CompositorBridgeParent
:
:
UpdateWebRenderBatchingParameters
"
&
CompositorBridgeParent
:
:
UpdateWebRenderBatchingParameters
)
)
;
}
return
;
}
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
ForEachWebRenderBridgeParent
(
[
&
]
(
WebRenderBridgeParent
*
wrBridge
)
-
>
void
{
wrBridge
-
>
UpdateBatchingParameters
(
)
;
}
)
;
}
RefPtr
<
WebRenderBridgeParent
>
CompositorBridgeParent
:
:
GetWebRenderBridgeParent
(
)
const
{
return
mWrBridge
;
}
Maybe
<
TimeStamp
>
CompositorBridgeParent
:
:
GetTestingTimeStamp
(
)
const
{
return
mTestTime
;
}
void
EraseLayerState
(
LayersId
aId
)
{
RefPtr
<
APZUpdater
>
apz
;
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
auto
iter
=
sIndirectLayerTrees
.
find
(
aId
)
;
if
(
iter
!
=
sIndirectLayerTrees
.
end
(
)
)
{
CompositorBridgeParent
*
parent
=
iter
-
>
second
.
mParent
;
if
(
parent
)
{
apz
=
parent
-
>
GetAPZUpdater
(
)
;
}
sIndirectLayerTrees
.
erase
(
iter
)
;
}
}
if
(
apz
)
{
apz
-
>
NotifyLayerTreeRemoved
(
WRRootId
(
aId
gfxUtils
:
:
GetContentRenderRoot
(
)
)
)
;
}
}
void
CompositorBridgeParent
:
:
DeallocateLayerTreeId
(
LayersId
aId
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
CompositorLoop
(
)
)
{
gfxCriticalError
(
)
<
<
"
Attempting
to
post
to
a
invalid
Compositor
Loop
"
;
return
;
}
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
"
EraseLayerStateRunnable
"
&
EraseLayerState
aId
)
)
;
}
static
void
UpdateControllerForLayersId
(
LayersId
aLayersId
GeckoContentController
*
aController
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
sIndirectLayerTrees
[
aLayersId
]
.
mController
=
already_AddRefed
<
GeckoContentController
>
(
aController
)
;
}
ScopedLayerTreeRegistration
:
:
ScopedLayerTreeRegistration
(
APZCTreeManager
*
aApzctm
LayersId
aLayersId
Layer
*
aRoot
GeckoContentController
*
aController
)
:
mLayersId
(
aLayersId
)
{
EnsureLayerTreeMapReady
(
)
;
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
sIndirectLayerTrees
[
aLayersId
]
.
mRoot
=
aRoot
;
sIndirectLayerTrees
[
aLayersId
]
.
mController
=
aController
;
}
ScopedLayerTreeRegistration
:
:
~
ScopedLayerTreeRegistration
(
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
sIndirectLayerTrees
.
erase
(
mLayersId
)
;
}
void
CompositorBridgeParent
:
:
SetControllerForLayerTree
(
LayersId
aLayersId
GeckoContentController
*
aController
)
{
aController
-
>
AddRef
(
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
"
UpdateControllerForLayersIdRunnable
"
&
UpdateControllerForLayersId
aLayersId
aController
)
)
;
}
already_AddRefed
<
IAPZCTreeManager
>
CompositorBridgeParent
:
:
GetAPZCTreeManager
(
LayersId
aLayersId
)
{
EnsureLayerTreeMapReady
(
)
;
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
LayerTreeMap
:
:
iterator
cit
=
sIndirectLayerTrees
.
find
(
aLayersId
)
;
if
(
sIndirectLayerTrees
.
end
(
)
=
=
cit
)
{
return
nullptr
;
}
LayerTreeState
*
lts
=
&
cit
-
>
second
;
RefPtr
<
IAPZCTreeManager
>
apzctm
=
lts
-
>
mParent
?
lts
-
>
mParent
-
>
mApzcTreeManager
.
get
(
)
:
nullptr
;
return
apzctm
.
forget
(
)
;
}
#
if
defined
(
MOZ_GECKO_PROFILER
)
static
void
InsertVsyncProfilerMarker
(
TimeStamp
aVsyncTimestamp
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
if
(
profiler_thread_is_being_profiled
(
)
)
{
PROFILER_ADD_MARKER_WITH_PAYLOAD
(
"
VsyncTimestamp
"
GRAPHICS
VsyncMarkerPayload
(
aVsyncTimestamp
)
)
;
}
}
#
endif
void
CompositorBridgeParent
:
:
PostInsertVsyncProfilerMarker
(
TimeStamp
aVsyncTimestamp
)
{
#
if
defined
(
MOZ_GECKO_PROFILER
)
if
(
profiler_is_active
(
)
&
&
CompositorThreadHolder
:
:
IsActive
(
)
)
{
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
"
InsertVsyncProfilerMarkerRunnable
"
InsertVsyncProfilerMarker
aVsyncTimestamp
)
)
;
}
#
endif
}
widget
:
:
PCompositorWidgetParent
*
CompositorBridgeParent
:
:
AllocPCompositorWidgetParent
(
const
CompositorWidgetInitData
&
aInitData
)
{
#
if
defined
(
MOZ_WIDGET_SUPPORTS_OOP_COMPOSITING
)
if
(
mWidget
)
{
return
nullptr
;
}
widget
:
:
CompositorWidgetParent
*
widget
=
new
widget
:
:
CompositorWidgetParent
(
aInitData
mOptions
)
;
widget
-
>
AddRef
(
)
;
mWidget
=
widget
;
return
widget
;
#
else
return
nullptr
;
#
endif
}
bool
CompositorBridgeParent
:
:
DeallocPCompositorWidgetParent
(
PCompositorWidgetParent
*
aActor
)
{
#
if
defined
(
MOZ_WIDGET_SUPPORTS_OOP_COMPOSITING
)
static_cast
<
widget
:
:
CompositorWidgetParent
*
>
(
aActor
)
-
>
Release
(
)
;
return
true
;
#
else
return
false
;
#
endif
}
bool
CompositorBridgeParent
:
:
IsPendingComposite
(
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
if
(
!
mCompositor
)
{
return
false
;
}
return
mCompositor
-
>
IsPendingComposite
(
)
;
}
void
CompositorBridgeParent
:
:
FinishPendingComposite
(
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
if
(
!
mCompositor
)
{
return
;
}
return
mCompositor
-
>
FinishPendingComposite
(
)
;
}
CompositorController
*
CompositorBridgeParent
:
:
LayerTreeState
:
:
GetCompositorController
(
)
const
{
return
mParent
;
}
MetricsSharingController
*
CompositorBridgeParent
:
:
LayerTreeState
:
:
CrossProcessSharingController
(
)
const
{
return
mContentCompositorBridgeParent
;
}
MetricsSharingController
*
CompositorBridgeParent
:
:
LayerTreeState
:
:
InProcessSharingController
(
)
const
{
return
mParent
;
}
void
CompositorBridgeParent
:
:
DidComposite
(
const
VsyncId
&
aId
TimeStamp
&
aCompositeStart
TimeStamp
&
aCompositeEnd
)
{
if
(
mWrBridge
)
{
MOZ_ASSERT
(
false
)
;
}
else
{
NotifyDidComposite
(
mPendingTransaction
aId
aCompositeStart
aCompositeEnd
)
;
#
if
defined
(
ENABLE_FRAME_LATENCY_LOG
)
if
(
mPendingTransaction
.
IsValid
(
)
)
{
if
(
mRefreshStartTime
)
{
int32_t
latencyMs
=
lround
(
(
aCompositeEnd
-
mRefreshStartTime
)
.
ToMilliseconds
(
)
)
;
printf_stderr
(
"
From
transaction
start
to
end
of
generate
frame
latencyMs
%
d
this
"
"
%
p
\
n
"
latencyMs
this
)
;
}
if
(
mFwdTime
)
{
int32_t
latencyMs
=
lround
(
(
aCompositeEnd
-
mFwdTime
)
.
ToMilliseconds
(
)
)
;
printf_stderr
(
"
From
forwarding
transaction
to
end
of
generate
frame
latencyMs
%
d
"
"
this
%
p
\
n
"
latencyMs
this
)
;
}
}
mRefreshStartTime
=
TimeStamp
(
)
;
mTxnStartTime
=
TimeStamp
(
)
;
mFwdTime
=
TimeStamp
(
)
;
#
endif
mPendingTransaction
=
TransactionId
{
0
}
;
}
}
void
CompositorBridgeParent
:
:
NotifyDidSceneBuild
(
const
nsTArray
<
wr
:
:
RenderRoot
>
&
aRenderRoots
RefPtr
<
const
wr
:
:
WebRenderPipelineInfo
>
aInfo
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
if
(
mPaused
)
{
return
;
}
if
(
mWrBridge
)
{
mWrBridge
-
>
NotifyDidSceneBuild
(
aRenderRoots
aInfo
)
;
}
else
{
mCompositorScheduler
-
>
ScheduleComposition
(
)
;
}
}
void
CompositorBridgeParent
:
:
NotifyPipelineRendered
(
const
wr
:
:
PipelineId
&
aPipelineId
const
wr
:
:
Epoch
&
aEpoch
const
VsyncId
&
aCompositeStartId
TimeStamp
&
aCompositeStart
TimeStamp
&
aRenderStart
TimeStamp
&
aCompositeEnd
wr
:
:
RendererStats
*
aStats
)
{
if
(
!
mWrBridge
|
|
!
mAsyncImageManager
)
{
return
;
}
nsTArray
<
FrameStats
>
stats
;
RefPtr
<
UiCompositorControllerParent
>
uiController
=
UiCompositorControllerParent
:
:
GetFromRootLayerTreeId
(
mRootLayerTreeID
)
;
if
(
mWrBridge
-
>
PipelineId
(
)
=
=
aPipelineId
)
{
mWrBridge
-
>
RemoveEpochDataPriorTo
(
aEpoch
)
;
if
(
!
mPaused
)
{
if
(
mIsForcedFirstPaint
)
{
uiController
-
>
NotifyFirstPaint
(
)
;
mIsForcedFirstPaint
=
false
;
}
std
:
:
pair
<
wr
:
:
PipelineId
wr
:
:
Epoch
>
key
(
aPipelineId
aEpoch
)
;
if
(
nsTArray
<
CompositionPayload
>
*
payloads
=
mWrBridge
-
>
GetPendingScrollPayload
(
key
)
)
{
RecordCompositionPayloadsPresented
(
*
payloads
)
;
mWrBridge
-
>
RemovePendingScrollPayload
(
key
)
;
}
TransactionId
transactionId
=
mWrBridge
-
>
FlushTransactionIdsForEpoch
(
aEpoch
aCompositeStartId
aCompositeStart
aRenderStart
aCompositeEnd
uiController
)
;
Unused
<
<
SendDidComposite
(
LayersId
{
0
}
transactionId
aCompositeStart
aCompositeEnd
)
;
nsTArray
<
ImageCompositeNotificationInfo
>
notifications
;
mWrBridge
-
>
ExtractImageCompositeNotifications
(
&
notifications
)
;
if
(
!
notifications
.
IsEmpty
(
)
)
{
Unused
<
<
ImageBridgeParent
:
:
NotifyImageComposites
(
notifications
)
;
}
}
return
;
}
auto
wrBridge
=
mAsyncImageManager
-
>
GetWrBridge
(
aPipelineId
)
;
if
(
wrBridge
&
&
wrBridge
-
>
GetCompositorBridge
(
)
)
{
MOZ_ASSERT
(
!
wrBridge
-
>
IsRootWebRenderBridgeParent
(
)
)
;
wrBridge
-
>
RemoveEpochDataPriorTo
(
aEpoch
)
;
if
(
!
mPaused
)
{
std
:
:
pair
<
wr
:
:
PipelineId
wr
:
:
Epoch
>
key
(
aPipelineId
aEpoch
)
;
if
(
nsTArray
<
CompositionPayload
>
*
payloads
=
wrBridge
-
>
GetPendingScrollPayload
(
key
)
)
{
RecordCompositionPayloadsPresented
(
*
payloads
)
;
wrBridge
-
>
RemovePendingScrollPayload
(
key
)
;
}
TransactionId
transactionId
=
wrBridge
-
>
FlushTransactionIdsForEpoch
(
aEpoch
aCompositeStartId
aCompositeStart
aRenderStart
aCompositeEnd
uiController
aStats
&
stats
)
;
Unused
<
<
wrBridge
-
>
GetCompositorBridge
(
)
-
>
SendDidComposite
(
wrBridge
-
>
GetLayersId
(
)
transactionId
aCompositeStart
aCompositeEnd
)
;
}
}
if
(
!
stats
.
IsEmpty
(
)
)
{
Unused
<
<
SendNotifyFrameStats
(
stats
)
;
}
}
RefPtr
<
AsyncImagePipelineManager
>
CompositorBridgeParent
:
:
GetAsyncImagePipelineManager
(
)
const
{
return
mAsyncImageManager
;
}
void
CompositorBridgeParent
:
:
NotifyDidComposite
(
TransactionId
aTransactionId
VsyncId
aId
TimeStamp
&
aCompositeStart
TimeStamp
&
aCompositeEnd
)
{
MOZ_ASSERT
(
!
mWrBridge
)
;
Unused
<
<
SendDidComposite
(
LayersId
{
0
}
aTransactionId
aCompositeStart
aCompositeEnd
)
;
if
(
mLayerManager
)
{
nsTArray
<
ImageCompositeNotificationInfo
>
notifications
;
mLayerManager
-
>
ExtractImageCompositeNotifications
(
&
notifications
)
;
if
(
!
notifications
.
IsEmpty
(
)
)
{
Unused
<
<
ImageBridgeParent
:
:
NotifyImageComposites
(
notifications
)
;
}
}
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
ForEachIndirectLayerTree
(
[
&
]
(
LayerTreeState
*
lts
const
LayersId
&
aLayersId
)
-
>
void
{
if
(
lts
-
>
mContentCompositorBridgeParent
&
&
lts
-
>
mParent
=
=
this
)
{
ContentCompositorBridgeParent
*
cpcp
=
lts
-
>
mContentCompositorBridgeParent
;
cpcp
-
>
DidCompositeLocked
(
aLayersId
aId
aCompositeStart
aCompositeEnd
)
;
}
}
)
;
}
void
CompositorBridgeParent
:
:
InvalidateRemoteLayers
(
)
{
MOZ_ASSERT
(
CompositorLoop
(
)
=
=
MessageLoop
:
:
current
(
)
)
;
Unused
<
<
PCompositorBridgeParent
:
:
SendInvalidateLayers
(
LayersId
{
0
}
)
;
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
ForEachIndirectLayerTree
(
[
]
(
LayerTreeState
*
lts
const
LayersId
&
aLayersId
)
-
>
void
{
if
(
lts
-
>
mContentCompositorBridgeParent
)
{
ContentCompositorBridgeParent
*
cpcp
=
lts
-
>
mContentCompositorBridgeParent
;
Unused
<
<
cpcp
-
>
SendInvalidateLayers
(
aLayersId
)
;
}
}
)
;
}
void
UpdateIndirectTree
(
LayersId
aId
Layer
*
aRoot
const
TargetConfig
&
aTargetConfig
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
sIndirectLayerTrees
[
aId
]
.
mRoot
=
aRoot
;
sIndirectLayerTrees
[
aId
]
.
mTargetConfig
=
aTargetConfig
;
}
CompositorBridgeParent
:
:
LayerTreeState
*
CompositorBridgeParent
:
:
GetIndirectShadowTree
(
LayersId
aId
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
LayerTreeMap
:
:
iterator
cit
=
sIndirectLayerTrees
.
find
(
aId
)
;
if
(
sIndirectLayerTrees
.
end
(
)
=
=
cit
)
{
return
nullptr
;
}
return
&
cit
-
>
second
;
}
bool
CompositorBridgeParent
:
:
CallWithIndirectShadowTree
(
LayersId
aId
const
std
:
:
function
<
void
(
CompositorBridgeParent
:
:
LayerTreeState
&
)
>
&
aFunc
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
LayerTreeMap
:
:
iterator
cit
=
sIndirectLayerTrees
.
find
(
aId
)
;
if
(
sIndirectLayerTrees
.
end
(
)
=
=
cit
)
{
return
false
;
}
aFunc
(
cit
-
>
second
)
;
return
true
;
}
static
CompositorBridgeParent
:
:
LayerTreeState
*
GetStateForRoot
(
LayersId
aContentLayersId
const
MonitorAutoLock
&
aProofOfLock
)
{
CompositorBridgeParent
:
:
LayerTreeState
*
state
=
nullptr
;
LayerTreeMap
:
:
iterator
itr
=
sIndirectLayerTrees
.
find
(
aContentLayersId
)
;
if
(
sIndirectLayerTrees
.
end
(
)
!
=
itr
)
{
state
=
&
itr
-
>
second
;
}
if
(
state
&
&
state
-
>
mParent
)
{
LayersId
rootLayersId
=
state
-
>
mParent
-
>
RootLayerTreeId
(
)
;
itr
=
sIndirectLayerTrees
.
find
(
rootLayersId
)
;
state
=
(
sIndirectLayerTrees
.
end
(
)
!
=
itr
)
?
&
itr
-
>
second
:
nullptr
;
}
return
state
;
}
APZCTreeManagerParent
*
CompositorBridgeParent
:
:
GetApzcTreeManagerParentForRoot
(
LayersId
aContentLayersId
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
CompositorBridgeParent
:
:
LayerTreeState
*
state
=
GetStateForRoot
(
aContentLayersId
lock
)
;
return
state
?
state
-
>
mApzcTreeManagerParent
:
nullptr
;
}
GeckoContentController
*
CompositorBridgeParent
:
:
GetGeckoContentControllerForRoot
(
LayersId
aContentLayersId
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
CompositorBridgeParent
:
:
LayerTreeState
*
state
=
GetStateForRoot
(
aContentLayersId
lock
)
;
return
state
?
state
-
>
mController
.
get
(
)
:
nullptr
;
}
PTextureParent
*
CompositorBridgeParent
:
:
AllocPTextureParent
(
const
SurfaceDescriptor
&
aSharedData
const
ReadLockDescriptor
&
aReadLock
const
LayersBackend
&
aLayersBackend
const
TextureFlags
&
aFlags
const
LayersId
&
aId
const
uint64_t
&
aSerial
const
wr
:
:
MaybeExternalImageId
&
aExternalImageId
)
{
return
TextureHost
:
:
CreateIPDLActor
(
this
aSharedData
aReadLock
aLayersBackend
aFlags
aSerial
aExternalImageId
)
;
}
bool
CompositorBridgeParent
:
:
DeallocPTextureParent
(
PTextureParent
*
actor
)
{
return
TextureHost
:
:
DestroyIPDLActor
(
actor
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvInitPCanvasParent
(
Endpoint
<
PCanvasParent
>
&
&
aEndpoint
)
{
MOZ_CRASH
(
"
PCanvasParent
shouldn
'
t
be
created
via
CompositorBridgeParent
.
"
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvReleasePCanvasParent
(
)
{
MOZ_CRASH
(
"
PCanvasParent
shouldn
'
t
be
released
via
CompositorBridgeParent
.
"
)
;
}
bool
CompositorBridgeParent
:
:
IsSameProcess
(
)
const
{
return
OtherPid
(
)
=
=
base
:
:
GetCurrentProcId
(
)
;
}
void
CompositorBridgeParent
:
:
NotifyWebRenderContextPurge
(
)
{
MOZ_ASSERT
(
CompositorLoop
(
)
=
=
MessageLoop
:
:
current
(
)
)
;
RefPtr
<
wr
:
:
WebRenderAPI
>
api
=
mWrBridge
-
>
GetWebRenderAPI
(
wr
:
:
RenderRoot
:
:
Default
)
;
api
-
>
ClearAllCaches
(
)
;
}
void
CompositorBridgeParent
:
:
NotifyWebRenderDisableNativeCompositor
(
)
{
MOZ_ASSERT
(
CompositorLoop
(
)
=
=
MessageLoop
:
:
current
(
)
)
;
if
(
mWrBridge
)
{
mWrBridge
-
>
DisableNativeCompositor
(
)
;
}
}
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
#
define
PLUGINS_LOG
(
.
.
.
)
bool
CompositorBridgeParent
:
:
UpdatePluginWindowState
(
LayersId
aId
)
{
MonitorAutoLock
lock
(
*
sIndirectLayerTreesLock
)
;
CompositorBridgeParent
:
:
LayerTreeState
&
lts
=
sIndirectLayerTrees
[
aId
]
;
if
(
!
lts
.
mParent
)
{
PLUGINS_LOG
(
"
[
%
"
PRIu64
"
]
layer
tree
compositor
parent
pointer
is
null
"
aId
)
;
return
false
;
}
if
(
!
lts
.
mUpdatedPluginDataAvailable
)
{
PLUGINS_LOG
(
"
[
%
"
PRIu64
"
]
no
plugin
data
"
aId
)
;
return
false
;
}
bool
pluginMetricsChanged
=
false
;
if
(
mLastPluginUpdateLayerTreeId
=
=
aId
)
{
if
(
!
mCachedPluginData
.
Length
(
)
&
&
!
lts
.
mPluginData
.
Length
(
)
)
{
PLUGINS_LOG
(
"
[
%
"
PRIu64
"
]
no
data
no
changes
"
aId
)
;
return
false
;
}
if
(
mCachedPluginData
.
Length
(
)
=
=
lts
.
mPluginData
.
Length
(
)
)
{
for
(
uint32_t
idx
=
0
;
idx
<
lts
.
mPluginData
.
Length
(
)
;
idx
+
+
)
{
if
(
!
(
mCachedPluginData
[
idx
]
=
=
lts
.
mPluginData
[
idx
]
)
)
{
pluginMetricsChanged
=
true
;
break
;
}
}
}
else
{
pluginMetricsChanged
=
true
;
}
}
else
{
pluginMetricsChanged
=
true
;
}
if
(
mDeferPluginWindows
)
{
PLUGINS_LOG
(
"
[
%
"
PRIu64
"
]
suppressing
"
aId
)
;
return
false
;
}
if
(
mPluginWindowsHidden
)
{
PLUGINS_LOG
(
"
[
%
"
PRIu64
"
]
re
-
showing
"
aId
)
;
mPluginWindowsHidden
=
false
;
pluginMetricsChanged
=
true
;
}
if
(
!
lts
.
mPluginData
.
Length
(
)
)
{
if
(
!
mCachedPluginData
.
Length
(
)
)
{
PLUGINS_LOG
(
"
[
%
"
PRIu64
"
]
nothing
to
hide
"
aId
)
;
return
false
;
}
uintptr_t
parentWidget
=
GetWidget
(
)
-
>
GetWidgetKey
(
)
;
mPluginsLayerOffset
=
nsIntPoint
(
0
0
)
;
mPluginsLayerVisibleRegion
.
SetEmpty
(
)
;
Unused
<
<
lts
.
mParent
-
>
SendHideAllPlugins
(
parentWidget
)
;
lts
.
mUpdatedPluginDataAvailable
=
false
;
PLUGINS_LOG
(
"
[
%
"
PRIu64
"
]
hide
all
"
aId
)
;
}
else
{
LayerTransactionParent
*
layerTree
=
lts
.
mLayerTree
;
Layer
*
contentRoot
=
layerTree
-
>
GetRoot
(
)
;
if
(
contentRoot
)
{
nsIntPoint
offset
;
nsIntRegion
visibleRegion
;
if
(
contentRoot
-
>
GetVisibleRegionRelativeToRootLayer
(
visibleRegion
&
offset
)
)
{
if
(
!
pluginMetricsChanged
&
&
mPluginsLayerVisibleRegion
=
=
visibleRegion
&
&
mPluginsLayerOffset
=
=
offset
)
{
PLUGINS_LOG
(
"
[
%
"
PRIu64
"
]
no
change
"
aId
)
;
return
false
;
}
mPluginsLayerOffset
=
offset
;
mPluginsLayerVisibleRegion
=
visibleRegion
;
Unused
<
<
lts
.
mParent
-
>
SendUpdatePluginConfigurations
(
LayoutDeviceIntPoint
:
:
FromUnknownPoint
(
offset
)
LayoutDeviceIntRegion
:
:
FromUnknownRegion
(
visibleRegion
)
lts
.
mPluginData
)
;
lts
.
mUpdatedPluginDataAvailable
=
false
;
PLUGINS_LOG
(
"
[
%
"
PRIu64
"
]
updated
"
aId
)
;
}
else
{
PLUGINS_LOG
(
"
[
%
"
PRIu64
"
]
no
visibility
data
"
aId
)
;
return
false
;
}
}
else
{
PLUGINS_LOG
(
"
[
%
"
PRIu64
"
]
no
content
root
"
aId
)
;
return
false
;
}
}
mLastPluginUpdateLayerTreeId
=
aId
;
mCachedPluginData
=
lts
.
mPluginData
;
return
true
;
}
void
CompositorBridgeParent
:
:
ScheduleShowAllPluginWindows
(
)
{
MOZ_ASSERT
(
CompositorLoop
(
)
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableMethod
(
"
layers
:
:
CompositorBridgeParent
:
:
ShowAllPluginWindows
"
this
&
CompositorBridgeParent
:
:
ShowAllPluginWindows
)
)
;
}
void
CompositorBridgeParent
:
:
ShowAllPluginWindows
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mDeferPluginWindows
=
false
;
ScheduleComposition
(
)
;
}
void
CompositorBridgeParent
:
:
ScheduleHideAllPluginWindows
(
)
{
MOZ_ASSERT
(
CompositorLoop
(
)
)
;
CompositorLoop
(
)
-
>
PostTask
(
NewRunnableMethod
(
"
layers
:
:
CompositorBridgeParent
:
:
HideAllPluginWindows
"
this
&
CompositorBridgeParent
:
:
HideAllPluginWindows
)
)
;
}
void
CompositorBridgeParent
:
:
HideAllPluginWindows
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
!
mCachedPluginData
.
Length
(
)
|
|
mDeferPluginWindows
)
{
return
;
}
uintptr_t
parentWidget
=
GetWidget
(
)
-
>
GetWidgetKey
(
)
;
mDeferPluginWindows
=
true
;
mPluginWindowsHidden
=
true
;
#
if
defined
(
XP_WIN
)
mWaitForPluginsUntil
=
TimeStamp
:
:
Now
(
)
+
mVsyncRate
;
Unused
<
<
SendCaptureAllPlugins
(
parentWidget
)
;
#
else
Unused
<
<
SendHideAllPlugins
(
parentWidget
)
;
ScheduleComposition
(
)
;
#
endif
}
#
endif
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvAllPluginsCaptured
(
)
{
#
if
defined
(
XP_WIN
)
mWaitForPluginsUntil
=
TimeStamp
(
)
;
mHaveBlockedForPlugins
=
false
;
ForceComposeToTarget
(
nullptr
)
;
Unused
<
<
SendHideAllPlugins
(
GetWidget
(
)
-
>
GetWidgetKey
(
)
)
;
return
IPC_OK
(
)
;
#
else
MOZ_ASSERT_UNREACHABLE
(
"
CompositorBridgeParent
:
:
RecvAllPluginsCaptured
calls
unexpected
.
"
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
#
endif
}
int32_t
RecordContentFrameTime
(
const
VsyncId
&
aTxnId
const
TimeStamp
&
aVsyncStart
const
TimeStamp
&
aTxnStart
const
VsyncId
&
aCompositeId
const
TimeStamp
&
aCompositeEnd
const
TimeDuration
&
aFullPaintTime
const
TimeDuration
&
aVsyncRate
bool
aContainsSVGGroup
bool
aRecordUploadStats
wr
:
:
RendererStats
*
aStats
)
{
double
latencyMs
=
(
aCompositeEnd
-
aTxnStart
)
.
ToMilliseconds
(
)
;
double
latencyNorm
=
latencyMs
/
aVsyncRate
.
ToMilliseconds
(
)
;
int32_t
fracLatencyNorm
=
lround
(
latencyNorm
*
100
.
0
)
;
#
ifdef
MOZ_GECKO_PROFILER
if
(
profiler_can_accept_markers
(
)
)
{
class
ContentFramePayload
:
public
ProfilerMarkerPayload
{
public
:
ContentFramePayload
(
const
mozilla
:
:
TimeStamp
&
aStartTime
const
mozilla
:
:
TimeStamp
&
aEndTime
)
:
ProfilerMarkerPayload
(
aStartTime
aEndTime
)
{
}
mozilla
:
:
BlocksRingBuffer
:
:
Length
TagAndSerializationBytes
(
)
const
override
{
return
CommonPropsTagAndSerializationBytes
(
)
;
}
void
SerializeTagAndPayload
(
mozilla
:
:
ProfileBufferEntryWriter
&
aEntryWriter
)
const
override
{
static
const
DeserializerTag
tag
=
TagForDeserializer
(
Deserialize
)
;
SerializeTagAndCommonProps
(
tag
aEntryWriter
)
;
}
void
StreamPayload
(
SpliceableJSONWriter
&
aWriter
const
TimeStamp
&
aProcessStartTime
UniqueStacks
&
aUniqueStacks
)
const
override
{
StreamCommonProps
(
"
CONTENT_FRAME_TIME
"
aWriter
aProcessStartTime
aUniqueStacks
)
;
}
private
:
explicit
ContentFramePayload
(
CommonProps
&
&
aCommonProps
)
:
ProfilerMarkerPayload
(
std
:
:
move
(
aCommonProps
)
)
{
}
static
mozilla
:
:
UniquePtr
<
ProfilerMarkerPayload
>
Deserialize
(
mozilla
:
:
ProfileBufferEntryReader
&
aEntryReader
)
{
ProfilerMarkerPayload
:
:
CommonProps
props
=
DeserializeCommonProps
(
aEntryReader
)
;
return
UniquePtr
<
ProfilerMarkerPayload
>
(
new
ContentFramePayload
(
std
:
:
move
(
props
)
)
)
;
}
}
;
AUTO_PROFILER_STATS
(
add_marker_with_ContentFramePayload
)
;
profiler_add_marker_for_thread
(
profiler_current_thread_id
(
)
JS
:
:
ProfilingCategoryPair
:
:
GRAPHICS
"
CONTENT_FRAME_TIME
"
MakeUnique
<
ContentFramePayload
>
(
aTxnStart
aCompositeEnd
)
)
;
}
#
endif
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CONTENT_FRAME_TIME
fracLatencyNorm
)
;
if
(
!
(
aTxnId
=
=
VsyncId
(
)
)
&
&
aVsyncStart
)
{
latencyMs
=
(
aCompositeEnd
-
aVsyncStart
)
.
ToMilliseconds
(
)
;
latencyNorm
=
latencyMs
/
aVsyncRate
.
ToMilliseconds
(
)
;
fracLatencyNorm
=
lround
(
latencyNorm
*
100
.
0
)
;
int32_t
result
=
fracLatencyNorm
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CONTENT_FRAME_TIME_VSYNC
fracLatencyNorm
)
;
if
(
aContainsSVGGroup
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CONTENT_FRAME_TIME_WITH_SVG
fracLatencyNorm
)
;
}
if
(
fracLatencyNorm
<
200
)
{
Telemetry
:
:
AccumulateCategorical
(
LABELS_CONTENT_FRAME_TIME_REASON
:
:
OnTime
)
;
}
else
{
if
(
aCompositeId
=
=
VsyncId
(
)
)
{
Telemetry
:
:
AccumulateCategorical
(
LABELS_CONTENT_FRAME_TIME_REASON
:
:
NoVsyncNoId
)
;
}
else
if
(
aTxnId
>
=
aCompositeId
)
{
Telemetry
:
:
AccumulateCategorical
(
LABELS_CONTENT_FRAME_TIME_REASON
:
:
NoVsync
)
;
}
else
if
(
aCompositeId
-
aTxnId
>
1
)
{
if
(
aFullPaintTime
>
=
TimeDuration
:
:
FromMilliseconds
(
20
)
)
{
Telemetry
:
:
AccumulateCategorical
(
LABELS_CONTENT_FRAME_TIME_REASON
:
:
MissedCompositeLong
)
;
}
else
if
(
aFullPaintTime
>
=
TimeDuration
:
:
FromMilliseconds
(
10
)
)
{
Telemetry
:
:
AccumulateCategorical
(
LABELS_CONTENT_FRAME_TIME_REASON
:
:
MissedCompositeMid
)
;
}
else
if
(
aFullPaintTime
>
=
TimeDuration
:
:
FromMilliseconds
(
5
)
)
{
Telemetry
:
:
AccumulateCategorical
(
LABELS_CONTENT_FRAME_TIME_REASON
:
:
MissedCompositeLow
)
;
}
else
{
Telemetry
:
:
AccumulateCategorical
(
LABELS_CONTENT_FRAME_TIME_REASON
:
:
MissedComposite
)
;
}
}
else
{
Telemetry
:
:
AccumulateCategorical
(
LABELS_CONTENT_FRAME_TIME_REASON
:
:
SlowComposite
)
;
}
}
if
(
aRecordUploadStats
)
{
if
(
aStats
)
{
latencyMs
-
=
(
double
(
aStats
-
>
resource_upload_time
)
/
1000000
.
0
)
;
latencyNorm
=
latencyMs
/
aVsyncRate
.
ToMilliseconds
(
)
;
fracLatencyNorm
=
lround
(
latencyNorm
*
100
.
0
)
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CONTENT_FRAME_TIME_WITHOUT_RESOURCE_UPLOAD
fracLatencyNorm
)
;
if
(
aStats
)
{
latencyMs
-
=
(
double
(
aStats
-
>
gpu_cache_upload_time
)
/
1000000
.
0
)
;
latencyNorm
=
latencyMs
/
aVsyncRate
.
ToMilliseconds
(
)
;
fracLatencyNorm
=
lround
(
latencyNorm
*
100
.
0
)
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CONTENT_FRAME_TIME_WITHOUT_UPLOAD
fracLatencyNorm
)
;
}
return
result
;
}
return
0
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvBeginRecording
(
const
TimeStamp
&
aRecordingStart
BeginRecordingResolver
&
&
aResolve
)
{
if
(
mHaveCompositionRecorder
)
{
aResolve
(
false
)
;
return
IPC_OK
(
)
;
}
if
(
mLayerManager
)
{
mLayerManager
-
>
SetCompositionRecorder
(
MakeUnique
<
CompositionRecorder
>
(
aRecordingStart
)
)
;
}
else
if
(
mWrBridge
)
{
mWrBridge
-
>
SetCompositionRecorder
(
MakeUnique
<
WebRenderCompositionRecorder
>
(
aRecordingStart
mWrBridge
-
>
PipelineId
(
)
)
)
;
}
mHaveCompositionRecorder
=
true
;
aResolve
(
true
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvEndRecordingToDisk
(
EndRecordingToDiskResolver
&
&
aResolve
)
{
if
(
!
mHaveCompositionRecorder
)
{
aResolve
(
false
)
;
return
IPC_OK
(
)
;
}
if
(
mLayerManager
)
{
mLayerManager
-
>
WriteCollectedFrames
(
)
;
aResolve
(
true
)
;
}
else
if
(
mWrBridge
)
{
mWrBridge
-
>
WriteCollectedFrames
(
)
-
>
Then
(
MessageLoop
:
:
current
(
)
-
>
SerialEventTarget
(
)
__func__
[
resolve
{
aResolve
}
]
(
const
bool
success
)
{
resolve
(
success
)
;
}
[
resolve
{
aResolve
}
]
(
)
{
resolve
(
false
)
;
}
)
;
}
else
{
aResolve
(
false
)
;
}
mHaveCompositionRecorder
=
false
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeParent
:
:
RecvEndRecordingToMemory
(
EndRecordingToMemoryResolver
&
&
aResolve
)
{
if
(
!
mHaveCompositionRecorder
)
{
aResolve
(
Nothing
(
)
)
;
return
IPC_OK
(
)
;
}
if
(
mLayerManager
)
{
Maybe
<
CollectedFrames
>
frames
=
mLayerManager
-
>
GetCollectedFrames
(
)
;
if
(
frames
)
{
aResolve
(
WrapCollectedFrames
(
std
:
:
move
(
*
frames
)
)
)
;
}
else
{
aResolve
(
Nothing
(
)
)
;
}
}
else
if
(
mWrBridge
)
{
RefPtr
<
CompositorBridgeParent
>
self
=
this
;
mWrBridge
-
>
GetCollectedFrames
(
)
-
>
Then
(
MessageLoop
:
:
current
(
)
-
>
SerialEventTarget
(
)
__func__
[
self
resolve
{
aResolve
}
]
(
CollectedFrames
&
&
frames
)
{
resolve
(
self
-
>
WrapCollectedFrames
(
std
:
:
move
(
frames
)
)
)
;
}
[
resolve
{
aResolve
}
]
(
)
{
resolve
(
Nothing
(
)
)
;
}
)
;
}
mHaveCompositionRecorder
=
false
;
return
IPC_OK
(
)
;
}
Maybe
<
CollectedFramesParams
>
CompositorBridgeParent
:
:
WrapCollectedFrames
(
CollectedFrames
&
&
aFrames
)
{
CollectedFramesParams
ipcFrames
;
ipcFrames
.
recordingStart
(
)
=
aFrames
.
mRecordingStart
;
size_t
totalLength
=
0
;
for
(
const
CollectedFrame
&
frame
:
aFrames
.
mFrames
)
{
totalLength
+
=
frame
.
mDataUri
.
Length
(
)
;
}
Shmem
shmem
;
if
(
!
AllocShmem
(
totalLength
SharedMemory
:
:
TYPE_BASIC
&
shmem
)
)
{
return
Nothing
(
)
;
}
{
char
*
raw
=
shmem
.
get
<
char
>
(
)
;
for
(
CollectedFrame
&
frame
:
aFrames
.
mFrames
)
{
size_t
length
=
frame
.
mDataUri
.
Length
(
)
;
PodCopy
(
raw
frame
.
mDataUri
.
get
(
)
length
)
;
raw
+
=
length
;
ipcFrames
.
frames
(
)
.
EmplaceBack
(
frame
.
mTimeOffset
length
)
;
}
}
ipcFrames
.
buffer
(
)
=
std
:
:
move
(
shmem
)
;
return
Some
(
std
:
:
move
(
ipcFrames
)
)
;
}
}
}
