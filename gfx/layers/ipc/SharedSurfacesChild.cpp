#
include
"
SharedSurfacesChild
.
h
"
#
include
"
SharedSurfacesParent
.
h
"
#
include
"
CompositorManagerChild
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
layers
/
IpcResourceUpdateQueue
.
h
"
#
include
"
mozilla
/
layers
/
SourceSurfaceSharedData
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
mozilla
:
:
gfx
;
class
SharedSurfacesChild
:
:
ImageKeyData
final
{
public
:
ImageKeyData
(
WebRenderLayerManager
*
aManager
const
wr
:
:
ImageKey
&
aImageKey
)
:
mManager
(
aManager
)
mImageKey
(
aImageKey
)
{
}
ImageKeyData
(
ImageKeyData
&
&
aOther
)
:
mManager
(
std
:
:
move
(
aOther
.
mManager
)
)
mDirtyRect
(
std
:
:
move
(
aOther
.
mDirtyRect
)
)
mImageKey
(
aOther
.
mImageKey
)
{
}
ImageKeyData
&
operator
=
(
ImageKeyData
&
&
aOther
)
{
mManager
=
std
:
:
move
(
aOther
.
mManager
)
;
mDirtyRect
=
std
:
:
move
(
aOther
.
mDirtyRect
)
;
mImageKey
=
aOther
.
mImageKey
;
return
*
this
;
}
void
MergeDirtyRect
(
const
Maybe
<
IntRect
>
&
aDirtyRect
)
{
if
(
mDirtyRect
)
{
if
(
aDirtyRect
)
{
mDirtyRect
-
>
UnionRect
(
mDirtyRect
.
ref
(
)
aDirtyRect
.
ref
(
)
)
;
}
}
else
{
mDirtyRect
=
aDirtyRect
;
}
}
Maybe
<
IntRect
>
TakeDirtyRect
(
)
{
return
std
:
:
move
(
mDirtyRect
)
;
}
ImageKeyData
(
const
ImageKeyData
&
)
=
delete
;
ImageKeyData
&
operator
=
(
const
ImageKeyData
&
)
=
delete
;
RefPtr
<
WebRenderLayerManager
>
mManager
;
Maybe
<
IntRect
>
mDirtyRect
;
wr
:
:
ImageKey
mImageKey
;
}
;
class
SharedSurfacesChild
:
:
SharedUserData
final
{
public
:
explicit
SharedUserData
(
const
wr
:
:
ExternalImageId
&
aId
)
:
mId
(
aId
)
mShared
(
false
)
{
}
~
SharedUserData
(
)
{
if
(
mShared
)
{
mShared
=
false
;
if
(
NS_IsMainThread
(
)
)
{
SharedSurfacesChild
:
:
Unshare
(
mId
mKeys
)
;
}
else
{
class
DestroyRunnable
final
:
public
Runnable
{
public
:
DestroyRunnable
(
const
wr
:
:
ExternalImageId
&
aId
nsTArray
<
ImageKeyData
>
&
&
aKeys
)
:
Runnable
(
"
SharedSurfacesChild
:
:
SharedUserData
:
:
DestroyRunnable
"
)
mId
(
aId
)
mKeys
(
std
:
:
move
(
aKeys
)
)
{
}
NS_IMETHOD
Run
(
)
override
{
SharedSurfacesChild
:
:
Unshare
(
mId
mKeys
)
;
return
NS_OK
;
}
private
:
wr
:
:
ExternalImageId
mId
;
AutoTArray
<
ImageKeyData
1
>
mKeys
;
}
;
nsCOMPtr
<
nsIRunnable
>
task
=
new
DestroyRunnable
(
mId
std
:
:
move
(
mKeys
)
)
;
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
task
.
forget
(
)
)
;
}
}
}
const
wr
:
:
ExternalImageId
&
Id
(
)
const
{
return
mId
;
}
void
SetId
(
const
wr
:
:
ExternalImageId
&
aId
)
{
mId
=
aId
;
mKeys
.
Clear
(
)
;
mShared
=
false
;
}
bool
IsShared
(
)
const
{
return
mShared
;
}
void
MarkShared
(
)
{
MOZ_ASSERT
(
!
mShared
)
;
mShared
=
true
;
}
wr
:
:
ImageKey
UpdateKey
(
WebRenderLayerManager
*
aManager
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
Maybe
<
IntRect
>
&
aDirtyRect
)
{
MOZ_ASSERT
(
aManager
)
;
MOZ_ASSERT
(
!
aManager
-
>
IsDestroyed
(
)
)
;
wr
:
:
ImageKey
key
;
bool
found
=
false
;
auto
i
=
mKeys
.
Length
(
)
;
while
(
i
>
0
)
{
-
-
i
;
ImageKeyData
&
entry
=
mKeys
[
i
]
;
if
(
entry
.
mManager
-
>
IsDestroyed
(
)
)
{
mKeys
.
RemoveElementAt
(
i
)
;
}
else
if
(
entry
.
mManager
=
=
aManager
)
{
WebRenderBridgeChild
*
wrBridge
=
aManager
-
>
WrBridge
(
)
;
MOZ_ASSERT
(
wrBridge
)
;
bool
ownsKey
=
wrBridge
-
>
GetNamespace
(
)
=
=
entry
.
mImageKey
.
mNamespace
;
if
(
!
ownsKey
)
{
entry
.
mImageKey
=
wrBridge
-
>
GetNextImageKey
(
)
;
entry
.
TakeDirtyRect
(
)
;
aResources
.
AddExternalImage
(
mId
entry
.
mImageKey
)
;
}
else
{
entry
.
MergeDirtyRect
(
aDirtyRect
)
;
Maybe
<
IntRect
>
dirtyRect
=
entry
.
TakeDirtyRect
(
)
;
if
(
dirtyRect
)
{
aResources
.
UpdateExternalImage
(
mId
entry
.
mImageKey
ViewAs
<
ImagePixel
>
(
dirtyRect
.
ref
(
)
)
)
;
}
}
key
=
entry
.
mImageKey
;
found
=
true
;
}
else
{
entry
.
MergeDirtyRect
(
aDirtyRect
)
;
}
}
if
(
!
found
)
{
key
=
aManager
-
>
WrBridge
(
)
-
>
GetNextImageKey
(
)
;
ImageKeyData
data
(
aManager
key
)
;
mKeys
.
AppendElement
(
std
:
:
move
(
data
)
)
;
aResources
.
AddExternalImage
(
mId
key
)
;
}
return
key
;
}
private
:
AutoTArray
<
ImageKeyData
1
>
mKeys
;
wr
:
:
ExternalImageId
mId
;
bool
mShared
:
1
;
}
;
void
SharedSurfacesChild
:
:
DestroySharedUserData
(
void
*
aClosure
)
{
MOZ_ASSERT
(
aClosure
)
;
auto
data
=
static_cast
<
SharedUserData
*
>
(
aClosure
)
;
delete
data
;
}
nsresult
SharedSurfacesChild
:
:
ShareInternal
(
SourceSurfaceSharedData
*
aSurface
SharedUserData
*
*
aUserData
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aSurface
)
;
MOZ_ASSERT
(
aUserData
)
;
CompositorManagerChild
*
manager
=
CompositorManagerChild
:
:
GetInstance
(
)
;
if
(
NS_WARN_IF
(
!
manager
|
|
!
manager
-
>
CanSend
(
)
|
|
!
gfxVars
:
:
UseWebRender
(
)
)
)
{
aSurface
-
>
FinishedSharing
(
)
;
return
NS_ERROR_NOT_INITIALIZED
;
}
static
UserDataKey
sSharedKey
;
SharedUserData
*
data
=
static_cast
<
SharedUserData
*
>
(
aSurface
-
>
GetUserData
(
&
sSharedKey
)
)
;
if
(
!
data
)
{
data
=
new
SharedUserData
(
manager
-
>
GetNextExternalImageId
(
)
)
;
aSurface
-
>
AddUserData
(
&
sSharedKey
data
DestroySharedUserData
)
;
}
else
if
(
!
manager
-
>
OwnsExternalImageId
(
data
-
>
Id
(
)
)
)
{
data
-
>
SetId
(
manager
-
>
GetNextExternalImageId
(
)
)
;
}
else
if
(
data
-
>
IsShared
(
)
)
{
*
aUserData
=
data
;
return
NS_OK
;
}
SourceSurfaceSharedData
:
:
HandleLock
lock
(
aSurface
)
;
auto
pid
=
manager
-
>
OtherPid
(
)
;
if
(
pid
=
=
base
:
:
GetCurrentProcId
(
)
)
{
SharedSurfacesParent
:
:
AddSameProcess
(
data
-
>
Id
(
)
aSurface
)
;
data
-
>
MarkShared
(
)
;
*
aUserData
=
data
;
return
NS_OK
;
}
ipc
:
:
SharedMemoryBasic
:
:
Handle
handle
=
ipc
:
:
SharedMemoryBasic
:
:
NULLHandle
(
)
;
nsresult
rv
=
aSurface
-
>
ShareToProcess
(
pid
handle
)
;
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
if
(
NS_WARN_IF
(
!
aSurface
-
>
ReallocHandle
(
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
rv
=
aSurface
-
>
ShareToProcess
(
pid
handle
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_ASSERT
(
rv
!
=
NS_ERROR_NOT_AVAILABLE
)
;
return
rv
;
}
SurfaceFormat
format
=
aSurface
-
>
GetFormat
(
)
;
MOZ_RELEASE_ASSERT
(
format
=
=
SurfaceFormat
:
:
B8G8R8X8
|
|
format
=
=
SurfaceFormat
:
:
B8G8R8A8
"
bad
format
"
)
;
data
-
>
MarkShared
(
)
;
manager
-
>
SendAddSharedSurface
(
data
-
>
Id
(
)
SurfaceDescriptorShared
(
aSurface
-
>
GetSize
(
)
aSurface
-
>
Stride
(
)
format
handle
)
)
;
*
aUserData
=
data
;
return
NS_OK
;
}
void
SharedSurfacesChild
:
:
Share
(
SourceSurfaceSharedData
*
aSurface
)
{
MOZ_ASSERT
(
aSurface
)
;
if
(
!
NS_IsMainThread
(
)
)
{
class
ShareRunnable
final
:
public
Runnable
{
public
:
explicit
ShareRunnable
(
SourceSurfaceSharedData
*
aSurface
)
:
Runnable
(
"
SharedSurfacesChild
:
:
Share
"
)
mSurface
(
aSurface
)
{
}
NS_IMETHOD
Run
(
)
override
{
SharedUserData
*
unused
=
nullptr
;
SharedSurfacesChild
:
:
ShareInternal
(
mSurface
&
unused
)
;
return
NS_OK
;
}
private
:
RefPtr
<
SourceSurfaceSharedData
>
mSurface
;
}
;
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
MakeAndAddRef
<
ShareRunnable
>
(
aSurface
)
)
;
return
;
}
SharedUserData
*
unused
=
nullptr
;
SharedSurfacesChild
:
:
ShareInternal
(
aSurface
&
unused
)
;
}
nsresult
SharedSurfacesChild
:
:
Share
(
SourceSurfaceSharedData
*
aSurface
WebRenderLayerManager
*
aManager
wr
:
:
IpcResourceUpdateQueue
&
aResources
wr
:
:
ImageKey
&
aKey
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aSurface
)
;
MOZ_ASSERT
(
aManager
)
;
Maybe
<
IntRect
>
dirtyRect
=
aSurface
-
>
TakeDirtyRect
(
)
;
SharedUserData
*
data
=
nullptr
;
nsresult
rv
=
SharedSurfacesChild
:
:
ShareInternal
(
aSurface
&
data
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
MOZ_ASSERT
(
data
)
;
aKey
=
data
-
>
UpdateKey
(
aManager
aResources
dirtyRect
)
;
}
return
rv
;
}
nsresult
SharedSurfacesChild
:
:
Share
(
ImageContainer
*
aContainer
WebRenderLayerManager
*
aManager
wr
:
:
IpcResourceUpdateQueue
&
aResources
wr
:
:
ImageKey
&
aKey
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aContainer
)
;
MOZ_ASSERT
(
aManager
)
;
if
(
aContainer
-
>
IsAsync
(
)
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
AutoTArray
<
ImageContainer
:
:
OwningImage
4
>
images
;
aContainer
-
>
GetCurrentImages
(
&
images
)
;
if
(
images
.
IsEmpty
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
gfx
:
:
SourceSurface
>
surface
=
images
[
0
]
.
mImage
-
>
GetAsSourceSurface
(
)
;
if
(
!
surface
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
if
(
surface
-
>
GetType
(
)
!
=
SurfaceType
:
:
DATA_SHARED
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
auto
sharedSurface
=
static_cast
<
SourceSurfaceSharedData
*
>
(
surface
.
get
(
)
)
;
return
Share
(
sharedSurface
aManager
aResources
aKey
)
;
}
nsresult
SharedSurfacesChild
:
:
Share
(
SourceSurface
*
aSurface
wr
:
:
ExternalImageId
&
aId
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aSurface
)
;
if
(
aSurface
-
>
GetType
(
)
!
=
SurfaceType
:
:
DATA_SHARED
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
auto
sharedSurface
=
static_cast
<
SourceSurfaceSharedData
*
>
(
aSurface
)
;
SharedUserData
*
data
=
nullptr
;
nsresult
rv
=
ShareInternal
(
sharedSurface
&
data
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
MOZ_ASSERT
(
data
)
;
aId
=
data
-
>
Id
(
)
;
}
return
rv
;
}
void
SharedSurfacesChild
:
:
Unshare
(
const
wr
:
:
ExternalImageId
&
aId
nsTArray
<
ImageKeyData
>
&
aKeys
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
const
auto
&
entry
:
aKeys
)
{
if
(
entry
.
mManager
-
>
IsDestroyed
(
)
)
{
continue
;
}
entry
.
mManager
-
>
AddImageKeyForDiscard
(
entry
.
mImageKey
)
;
WebRenderBridgeChild
*
wrBridge
=
entry
.
mManager
-
>
WrBridge
(
)
;
if
(
wrBridge
)
{
wrBridge
-
>
DeallocExternalImageId
(
aId
)
;
}
}
CompositorManagerChild
*
manager
=
CompositorManagerChild
:
:
GetInstance
(
)
;
if
(
MOZ_UNLIKELY
(
!
manager
|
|
!
manager
-
>
CanSend
(
)
)
)
{
return
;
}
if
(
manager
-
>
OtherPid
(
)
=
=
base
:
:
GetCurrentProcId
(
)
)
{
if
(
manager
-
>
OwnsExternalImageId
(
aId
)
)
{
SharedSurfacesParent
:
:
RemoveSameProcess
(
aId
)
;
}
}
else
if
(
manager
-
>
OwnsExternalImageId
(
aId
)
)
{
manager
-
>
SendRemoveSharedSurface
(
aId
)
;
}
}
}
}
