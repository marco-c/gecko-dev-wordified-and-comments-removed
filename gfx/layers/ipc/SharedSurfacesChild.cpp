#
include
"
SharedSurfacesChild
.
h
"
#
include
"
SharedSurfacesParent
.
h
"
#
include
"
CompositorManagerChild
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
image
/
RecyclingSourceSurface
.
h
"
#
include
"
mozilla
/
layers
/
SourceSurfaceSharedData
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
mozilla
:
:
gfx
;
UserDataKey
SharedSurfacesChild
:
:
sSharedKey
;
SharedSurfacesChild
:
:
ImageKeyData
:
:
ImageKeyData
(
WebRenderLayerManager
*
aManager
const
wr
:
:
ImageKey
&
aImageKey
)
:
mManager
(
aManager
)
mImageKey
(
aImageKey
)
{
}
SharedSurfacesChild
:
:
ImageKeyData
:
:
ImageKeyData
(
SharedSurfacesChild
:
:
ImageKeyData
&
&
aOther
)
:
mManager
(
std
:
:
move
(
aOther
.
mManager
)
)
mDirtyRect
(
std
:
:
move
(
aOther
.
mDirtyRect
)
)
mImageKey
(
aOther
.
mImageKey
)
{
}
SharedSurfacesChild
:
:
ImageKeyData
&
SharedSurfacesChild
:
:
ImageKeyData
:
:
operator
=
(
SharedSurfacesChild
:
:
ImageKeyData
&
&
aOther
)
{
mManager
=
std
:
:
move
(
aOther
.
mManager
)
;
mDirtyRect
=
std
:
:
move
(
aOther
.
mDirtyRect
)
;
mImageKey
=
aOther
.
mImageKey
;
return
*
this
;
}
SharedSurfacesChild
:
:
ImageKeyData
:
:
~
ImageKeyData
(
)
{
}
void
SharedSurfacesChild
:
:
ImageKeyData
:
:
MergeDirtyRect
(
const
Maybe
<
IntRect
>
&
aDirtyRect
)
{
if
(
mDirtyRect
)
{
if
(
aDirtyRect
)
{
mDirtyRect
-
>
UnionRect
(
mDirtyRect
.
ref
(
)
aDirtyRect
.
ref
(
)
)
;
}
}
else
{
mDirtyRect
=
aDirtyRect
;
}
}
SharedSurfacesChild
:
:
SharedUserData
:
:
~
SharedUserData
(
)
{
if
(
mShared
|
|
!
mKeys
.
IsEmpty
(
)
)
{
if
(
NS_IsMainThread
(
)
)
{
SharedSurfacesChild
:
:
Unshare
(
mId
mShared
mKeys
)
;
}
else
{
class
DestroyRunnable
final
:
public
Runnable
{
public
:
DestroyRunnable
(
const
wr
:
:
ExternalImageId
&
aId
bool
aReleaseId
nsTArray
<
ImageKeyData
>
&
&
aKeys
)
:
Runnable
(
"
SharedSurfacesChild
:
:
SharedUserData
:
:
DestroyRunnable
"
)
mId
(
aId
)
mReleaseId
(
aReleaseId
)
mKeys
(
std
:
:
move
(
aKeys
)
)
{
}
NS_IMETHOD
Run
(
)
override
{
SharedSurfacesChild
:
:
Unshare
(
mId
mReleaseId
mKeys
)
;
return
NS_OK
;
}
private
:
wr
:
:
ExternalImageId
mId
;
bool
mReleaseId
;
AutoTArray
<
ImageKeyData
1
>
mKeys
;
}
;
nsCOMPtr
<
nsIRunnable
>
task
=
new
DestroyRunnable
(
mId
mShared
std
:
:
move
(
mKeys
)
)
;
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
task
.
forget
(
)
)
;
}
}
}
wr
:
:
ImageKey
SharedSurfacesChild
:
:
SharedUserData
:
:
UpdateKey
(
WebRenderLayerManager
*
aManager
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
Maybe
<
IntRect
>
&
aDirtyRect
)
{
MOZ_ASSERT
(
aManager
)
;
MOZ_ASSERT
(
!
aManager
-
>
IsDestroyed
(
)
)
;
wr
:
:
ImageKey
key
;
bool
found
=
false
;
auto
i
=
mKeys
.
Length
(
)
;
while
(
i
>
0
)
{
-
-
i
;
ImageKeyData
&
entry
=
mKeys
[
i
]
;
if
(
entry
.
mManager
-
>
IsDestroyed
(
)
)
{
mKeys
.
RemoveElementAt
(
i
)
;
}
else
if
(
entry
.
mManager
=
=
aManager
)
{
WebRenderBridgeChild
*
wrBridge
=
aManager
-
>
WrBridge
(
)
;
MOZ_ASSERT
(
wrBridge
)
;
bool
ownsKey
=
wrBridge
-
>
GetNamespace
(
)
=
=
entry
.
mImageKey
.
mNamespace
;
if
(
!
ownsKey
)
{
entry
.
mImageKey
=
wrBridge
-
>
GetNextImageKey
(
)
;
entry
.
TakeDirtyRect
(
)
;
aResources
.
AddExternalImage
(
mId
entry
.
mImageKey
)
;
}
else
{
entry
.
MergeDirtyRect
(
aDirtyRect
)
;
Maybe
<
IntRect
>
dirtyRect
=
entry
.
TakeDirtyRect
(
)
;
if
(
dirtyRect
)
{
MOZ_ASSERT
(
mShared
)
;
aResources
.
UpdateExternalImage
(
mId
entry
.
mImageKey
ViewAs
<
ImagePixel
>
(
dirtyRect
.
ref
(
)
)
)
;
}
}
key
=
entry
.
mImageKey
;
found
=
true
;
}
else
{
entry
.
MergeDirtyRect
(
aDirtyRect
)
;
}
}
if
(
!
found
)
{
key
=
aManager
-
>
WrBridge
(
)
-
>
GetNextImageKey
(
)
;
ImageKeyData
data
(
aManager
key
)
;
mKeys
.
AppendElement
(
std
:
:
move
(
data
)
)
;
aResources
.
AddExternalImage
(
mId
key
)
;
}
return
key
;
}
SourceSurfaceSharedData
*
SharedSurfacesChild
:
:
AsSourceSurfaceSharedData
(
SourceSurface
*
aSurface
)
{
MOZ_ASSERT
(
aSurface
)
;
switch
(
aSurface
-
>
GetType
(
)
)
{
case
SurfaceType
:
:
DATA_SHARED
:
return
static_cast
<
SourceSurfaceSharedData
*
>
(
aSurface
)
;
case
SurfaceType
:
:
DATA_RECYCLING_SHARED
:
{
auto
recycleSurface
=
static_cast
<
image
:
:
RecyclingSourceSurface
*
>
(
aSurface
)
;
auto
childSurface
=
recycleSurface
-
>
GetChildSurface
(
)
;
return
static_cast
<
SourceSurfaceSharedData
*
>
(
childSurface
)
;
}
default
:
return
nullptr
;
}
}
void
SharedSurfacesChild
:
:
DestroySharedUserData
(
void
*
aClosure
)
{
MOZ_ASSERT
(
aClosure
)
;
auto
data
=
static_cast
<
SharedUserData
*
>
(
aClosure
)
;
delete
data
;
}
nsresult
SharedSurfacesChild
:
:
ShareInternal
(
SourceSurfaceSharedData
*
aSurface
SharedUserData
*
*
aUserData
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aSurface
)
;
MOZ_ASSERT
(
aUserData
)
;
CompositorManagerChild
*
manager
=
CompositorManagerChild
:
:
GetInstance
(
)
;
if
(
NS_WARN_IF
(
!
manager
|
|
!
manager
-
>
CanSend
(
)
|
|
!
gfxVars
:
:
UseWebRender
(
)
)
)
{
aSurface
-
>
FinishedSharing
(
)
;
return
NS_ERROR_NOT_INITIALIZED
;
}
SharedUserData
*
data
=
static_cast
<
SharedUserData
*
>
(
aSurface
-
>
GetUserData
(
&
sSharedKey
)
)
;
if
(
!
data
)
{
data
=
new
SharedUserData
(
manager
-
>
GetNextExternalImageId
(
)
)
;
aSurface
-
>
AddUserData
(
&
sSharedKey
data
DestroySharedUserData
)
;
}
else
if
(
!
manager
-
>
OwnsExternalImageId
(
data
-
>
Id
(
)
)
)
{
data
-
>
SetId
(
manager
-
>
GetNextExternalImageId
(
)
)
;
}
else
if
(
data
-
>
IsShared
(
)
)
{
*
aUserData
=
data
;
return
NS_OK
;
}
SourceSurfaceSharedData
:
:
HandleLock
lock
(
aSurface
)
;
auto
pid
=
manager
-
>
OtherPid
(
)
;
if
(
pid
=
=
base
:
:
GetCurrentProcId
(
)
)
{
SharedSurfacesParent
:
:
AddSameProcess
(
data
-
>
Id
(
)
aSurface
)
;
data
-
>
MarkShared
(
)
;
*
aUserData
=
data
;
return
NS_OK
;
}
ipc
:
:
SharedMemoryBasic
:
:
Handle
handle
=
ipc
:
:
SharedMemoryBasic
:
:
NULLHandle
(
)
;
nsresult
rv
=
aSurface
-
>
ShareToProcess
(
pid
handle
)
;
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
if
(
NS_WARN_IF
(
!
aSurface
-
>
ReallocHandle
(
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
rv
=
aSurface
-
>
ShareToProcess
(
pid
handle
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_ASSERT
(
rv
!
=
NS_ERROR_NOT_AVAILABLE
)
;
return
rv
;
}
SurfaceFormat
format
=
aSurface
-
>
GetFormat
(
)
;
MOZ_RELEASE_ASSERT
(
format
=
=
SurfaceFormat
:
:
B8G8R8X8
|
|
format
=
=
SurfaceFormat
:
:
B8G8R8A8
"
bad
format
"
)
;
data
-
>
MarkShared
(
)
;
manager
-
>
SendAddSharedSurface
(
data
-
>
Id
(
)
SurfaceDescriptorShared
(
aSurface
-
>
GetSize
(
)
aSurface
-
>
Stride
(
)
format
handle
)
)
;
*
aUserData
=
data
;
return
NS_OK
;
}
void
SharedSurfacesChild
:
:
Share
(
SourceSurfaceSharedData
*
aSurface
)
{
MOZ_ASSERT
(
aSurface
)
;
if
(
!
NS_IsMainThread
(
)
)
{
class
ShareRunnable
final
:
public
Runnable
{
public
:
explicit
ShareRunnable
(
SourceSurfaceSharedData
*
aSurface
)
:
Runnable
(
"
SharedSurfacesChild
:
:
Share
"
)
mSurface
(
aSurface
)
{
}
NS_IMETHOD
Run
(
)
override
{
SharedUserData
*
unused
=
nullptr
;
SharedSurfacesChild
:
:
ShareInternal
(
mSurface
&
unused
)
;
return
NS_OK
;
}
private
:
RefPtr
<
SourceSurfaceSharedData
>
mSurface
;
}
;
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
MakeAndAddRef
<
ShareRunnable
>
(
aSurface
)
)
;
return
;
}
SharedUserData
*
unused
=
nullptr
;
SharedSurfacesChild
:
:
ShareInternal
(
aSurface
&
unused
)
;
}
nsresult
SharedSurfacesChild
:
:
Share
(
SourceSurfaceSharedData
*
aSurface
WebRenderLayerManager
*
aManager
wr
:
:
IpcResourceUpdateQueue
&
aResources
wr
:
:
ImageKey
&
aKey
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aSurface
)
;
MOZ_ASSERT
(
aManager
)
;
Maybe
<
IntRect
>
dirtyRect
=
aSurface
-
>
TakeDirtyRect
(
)
;
SharedUserData
*
data
=
nullptr
;
nsresult
rv
=
SharedSurfacesChild
:
:
ShareInternal
(
aSurface
&
data
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
MOZ_ASSERT
(
data
)
;
aKey
=
data
-
>
UpdateKey
(
aManager
aResources
dirtyRect
)
;
}
return
rv
;
}
nsresult
SharedSurfacesChild
:
:
Share
(
ImageContainer
*
aContainer
WebRenderLayerManager
*
aManager
wr
:
:
IpcResourceUpdateQueue
&
aResources
wr
:
:
ImageKey
&
aKey
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aContainer
)
;
MOZ_ASSERT
(
aManager
)
;
if
(
aContainer
-
>
IsAsync
(
)
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
AutoTArray
<
ImageContainer
:
:
OwningImage
4
>
images
;
aContainer
-
>
GetCurrentImages
(
&
images
)
;
if
(
images
.
IsEmpty
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
gfx
:
:
SourceSurface
>
surface
=
images
[
0
]
.
mImage
-
>
GetAsSourceSurface
(
)
;
if
(
!
surface
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
auto
sharedSurface
=
AsSourceSurfaceSharedData
(
surface
)
;
if
(
!
sharedSurface
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
SharedSurfacesAnimation
*
anim
=
aContainer
-
>
GetSharedSurfacesAnimation
(
)
;
if
(
anim
)
{
return
anim
-
>
UpdateKey
(
surface
sharedSurface
aManager
aResources
aKey
)
;
}
return
Share
(
sharedSurface
aManager
aResources
aKey
)
;
}
nsresult
SharedSurfacesChild
:
:
Share
(
SourceSurface
*
aSurface
wr
:
:
ExternalImageId
&
aId
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aSurface
)
;
auto
sharedSurface
=
AsSourceSurfaceSharedData
(
aSurface
)
;
if
(
!
sharedSurface
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
SharedUserData
*
data
=
nullptr
;
nsresult
rv
=
ShareInternal
(
sharedSurface
&
data
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
MOZ_ASSERT
(
data
)
;
aId
=
data
-
>
Id
(
)
;
}
return
rv
;
}
void
SharedSurfacesChild
:
:
Unshare
(
const
wr
:
:
ExternalImageId
&
aId
bool
aReleaseId
nsTArray
<
ImageKeyData
>
&
aKeys
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
const
auto
&
entry
:
aKeys
)
{
if
(
!
entry
.
mManager
-
>
IsDestroyed
(
)
)
{
entry
.
mManager
-
>
AddImageKeyForDiscard
(
entry
.
mImageKey
)
;
}
}
if
(
!
aReleaseId
)
{
return
;
}
CompositorManagerChild
*
manager
=
CompositorManagerChild
:
:
GetInstance
(
)
;
if
(
MOZ_UNLIKELY
(
!
manager
|
|
!
manager
-
>
CanSend
(
)
)
)
{
return
;
}
if
(
manager
-
>
OtherPid
(
)
=
=
base
:
:
GetCurrentProcId
(
)
)
{
if
(
manager
-
>
OwnsExternalImageId
(
aId
)
)
{
SharedSurfacesParent
:
:
RemoveSameProcess
(
aId
)
;
}
}
else
if
(
manager
-
>
OwnsExternalImageId
(
aId
)
)
{
manager
-
>
SendRemoveSharedSurface
(
aId
)
;
}
}
Maybe
<
wr
:
:
ExternalImageId
>
SharedSurfacesChild
:
:
GetExternalId
(
const
SourceSurfaceSharedData
*
aSurface
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aSurface
)
;
SharedUserData
*
data
=
static_cast
<
SharedUserData
*
>
(
aSurface
-
>
GetUserData
(
&
sSharedKey
)
)
;
if
(
!
data
|
|
!
data
-
>
IsShared
(
)
)
{
return
Nothing
(
)
;
}
return
Some
(
data
-
>
Id
(
)
)
;
}
nsresult
SharedSurfacesChild
:
:
UpdateAnimation
(
ImageContainer
*
aContainer
SourceSurface
*
aSurface
const
IntRect
&
aDirtyRect
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aContainer
)
;
MOZ_ASSERT
(
!
aContainer
-
>
IsAsync
(
)
)
;
MOZ_ASSERT
(
aSurface
)
;
auto
sharedSurface
=
SharedSurfacesChild
:
:
AsSourceSurfaceSharedData
(
aSurface
)
;
if
(
!
sharedSurface
)
{
MOZ_ASSERT
(
!
aContainer
-
>
GetSharedSurfacesAnimation
(
)
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
SharedSurfacesAnimation
*
anim
=
aContainer
-
>
EnsureSharedSurfacesAnimation
(
)
;
MOZ_ASSERT
(
anim
)
;
return
anim
-
>
SetCurrentFrame
(
aSurface
sharedSurface
aDirtyRect
)
;
}
nsresult
SharedSurfacesAnimation
:
:
SetCurrentFrame
(
SourceSurface
*
aParentSurface
SourceSurfaceSharedData
*
aSurface
const
gfx
:
:
IntRect
&
aDirtyRect
)
{
MOZ_ASSERT
(
aSurface
)
;
SharedUserData
*
data
=
nullptr
;
nsresult
rv
=
SharedSurfacesChild
:
:
ShareInternal
(
aSurface
&
data
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
MOZ_ASSERT
(
data
)
;
mId
=
data
-
>
Id
(
)
;
auto
i
=
mKeys
.
Length
(
)
;
while
(
i
>
0
)
{
-
-
i
;
SharedSurfacesChild
:
:
ImageKeyData
&
entry
=
mKeys
[
i
]
;
if
(
entry
.
mManager
-
>
IsDestroyed
(
)
)
{
mKeys
.
RemoveElementAt
(
i
)
;
continue
;
}
entry
.
MergeDirtyRect
(
Some
(
aDirtyRect
)
)
;
Maybe
<
IntRect
>
dirtyRect
=
entry
.
TakeDirtyRect
(
)
;
if
(
dirtyRect
)
{
auto
&
resourceUpdates
=
entry
.
mManager
-
>
AsyncResourceUpdates
(
)
;
resourceUpdates
.
UpdateExternalImage
(
mId
entry
.
mImageKey
ViewAs
<
ImagePixel
>
(
dirtyRect
.
ref
(
)
)
)
;
}
}
return
NS_OK
;
}
nsresult
SharedSurfacesAnimation
:
:
UpdateKey
(
SourceSurface
*
aParentSurface
SourceSurfaceSharedData
*
aSurface
WebRenderLayerManager
*
aManager
wr
:
:
IpcResourceUpdateQueue
&
aResources
wr
:
:
ImageKey
&
aKey
)
{
SharedUserData
*
data
=
nullptr
;
nsresult
rv
=
SharedSurfacesChild
:
:
ShareInternal
(
aSurface
&
data
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
MOZ_ASSERT
(
data
)
;
if
(
mId
.
mHandle
!
=
data
-
>
Id
(
)
.
mHandle
)
{
mKeys
.
Clear
(
)
;
mId
=
data
-
>
Id
(
)
;
}
aKey
=
SharedSurfacesChild
:
:
SharedUserData
:
:
UpdateKey
(
aManager
aResources
Nothing
(
)
)
;
return
NS_OK
;
}
void
SharedSurfacesAnimation
:
:
ReleasePreviousFrame
(
WebRenderLayerManager
*
aManager
const
wr
:
:
ExternalImageId
&
aId
)
{
}
void
SharedSurfacesAnimation
:
:
Invalidate
(
WebRenderLayerManager
*
aManager
)
{
auto
i
=
mKeys
.
Length
(
)
;
while
(
i
>
0
)
{
-
-
i
;
AnimationImageKeyData
&
entry
=
mKeys
[
i
]
;
if
(
entry
.
mManager
=
=
aManager
)
{
mKeys
.
RemoveElementAt
(
i
)
;
}
}
}
}
}
