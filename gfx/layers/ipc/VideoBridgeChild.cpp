#
include
"
VideoBridgeChild
.
h
"
#
include
"
VideoBridgeParent
.
h
"
#
include
"
CompositorThread
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
ipc
/
Endpoint
.
h
"
#
include
"
transport
/
runnable_utils
.
h
"
#
include
"
SynchronousTask
.
h
"
namespace
mozilla
{
namespace
layers
{
StaticRefPtr
<
VideoBridgeChild
>
sVideoBridge
;
void
VideoBridgeChild
:
:
StartupForGPUProcess
(
)
{
ipc
:
:
Endpoint
<
PVideoBridgeParent
>
parentPipe
;
ipc
:
:
Endpoint
<
PVideoBridgeChild
>
childPipe
;
PVideoBridge
:
:
CreateEndpoints
(
base
:
:
GetCurrentProcId
(
)
base
:
:
GetCurrentProcId
(
)
&
parentPipe
&
childPipe
)
;
VideoBridgeChild
:
:
Open
(
std
:
:
move
(
childPipe
)
)
;
VideoBridgeParent
:
:
Open
(
std
:
:
move
(
parentPipe
)
VideoBridgeSource
:
:
GpuProcess
)
;
}
void
VideoBridgeChild
:
:
Open
(
Endpoint
<
PVideoBridgeChild
>
&
&
aEndpoint
)
{
MOZ_ASSERT
(
!
sVideoBridge
|
|
!
sVideoBridge
-
>
CanSend
(
)
)
;
sVideoBridge
=
new
VideoBridgeChild
(
)
;
if
(
!
aEndpoint
.
Bind
(
sVideoBridge
)
)
{
MOZ_CRASH
(
"
Failed
to
bind
VideoBridgeChild
to
endpoint
"
)
;
}
}
void
VideoBridgeChild
:
:
Shutdown
(
)
{
if
(
sVideoBridge
)
{
sVideoBridge
-
>
Close
(
)
;
sVideoBridge
=
nullptr
;
}
}
VideoBridgeChild
:
:
VideoBridgeChild
(
)
:
mThread
(
GetCurrentSerialEventTarget
(
)
)
mCanSend
(
true
)
{
}
VideoBridgeChild
:
:
~
VideoBridgeChild
(
)
=
default
;
VideoBridgeChild
*
VideoBridgeChild
:
:
GetSingleton
(
)
{
return
sVideoBridge
;
}
bool
VideoBridgeChild
:
:
AllocUnsafeShmem
(
size_t
aSize
ipc
:
:
Shmem
*
aShmem
)
{
if
(
!
mThread
-
>
IsOnCurrentThread
(
)
)
{
return
DispatchAllocShmemInternal
(
aSize
aShmem
true
)
;
}
if
(
!
CanSend
(
)
)
{
return
false
;
}
return
PVideoBridgeChild
:
:
AllocUnsafeShmem
(
aSize
aShmem
)
;
}
bool
VideoBridgeChild
:
:
AllocShmem
(
size_t
aSize
ipc
:
:
Shmem
*
aShmem
)
{
MOZ_ASSERT
(
CanSend
(
)
)
;
return
PVideoBridgeChild
:
:
AllocShmem
(
aSize
aShmem
)
;
}
void
VideoBridgeChild
:
:
ProxyAllocShmemNow
(
SynchronousTask
*
aTask
size_t
aSize
ipc
:
:
Shmem
*
aShmem
bool
aUnsafe
bool
*
aSuccess
)
{
AutoCompleteTask
complete
(
aTask
)
;
if
(
!
CanSend
(
)
)
{
return
;
}
bool
ok
=
false
;
if
(
aUnsafe
)
{
ok
=
AllocUnsafeShmem
(
aSize
aShmem
)
;
}
else
{
ok
=
AllocShmem
(
aSize
aShmem
)
;
}
*
aSuccess
=
ok
;
}
bool
VideoBridgeChild
:
:
DispatchAllocShmemInternal
(
size_t
aSize
ipc
:
:
Shmem
*
aShmem
bool
aUnsafe
)
{
SynchronousTask
task
(
"
AllocatorProxy
alloc
"
)
;
bool
success
=
false
;
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
RefPtr
<
VideoBridgeChild
>
(
this
)
&
VideoBridgeChild
:
:
ProxyAllocShmemNow
&
task
aSize
aShmem
aUnsafe
&
success
)
;
GetThread
(
)
-
>
Dispatch
(
runnable
.
forget
(
)
)
;
task
.
Wait
(
)
;
return
success
;
}
void
VideoBridgeChild
:
:
ProxyDeallocShmemNow
(
SynchronousTask
*
aTask
ipc
:
:
Shmem
*
aShmem
bool
*
aResult
)
{
AutoCompleteTask
complete
(
aTask
)
;
if
(
!
CanSend
(
)
)
{
return
;
}
*
aResult
=
DeallocShmem
(
*
aShmem
)
;
}
bool
VideoBridgeChild
:
:
DeallocShmem
(
ipc
:
:
Shmem
&
aShmem
)
{
if
(
GetThread
(
)
-
>
IsOnCurrentThread
(
)
)
{
if
(
!
CanSend
(
)
)
{
return
false
;
}
return
PVideoBridgeChild
:
:
DeallocShmem
(
aShmem
)
;
}
SynchronousTask
task
(
"
AllocatorProxy
Dealloc
"
)
;
bool
result
=
false
;
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
RefPtr
<
VideoBridgeChild
>
(
this
)
&
VideoBridgeChild
:
:
ProxyDeallocShmemNow
&
task
&
aShmem
&
result
)
;
GetThread
(
)
-
>
Dispatch
(
runnable
.
forget
(
)
)
;
task
.
Wait
(
)
;
return
result
;
}
PTextureChild
*
VideoBridgeChild
:
:
AllocPTextureChild
(
const
SurfaceDescriptor
&
ReadLockDescriptor
&
const
LayersBackend
&
const
TextureFlags
&
const
uint64_t
&
aSerial
)
{
MOZ_ASSERT
(
CanSend
(
)
)
;
return
TextureClient
:
:
CreateIPDLActor
(
)
;
}
bool
VideoBridgeChild
:
:
DeallocPTextureChild
(
PTextureChild
*
actor
)
{
return
TextureClient
:
:
DestroyIPDLActor
(
actor
)
;
}
void
VideoBridgeChild
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
mCanSend
=
false
;
}
PTextureChild
*
VideoBridgeChild
:
:
CreateTexture
(
const
SurfaceDescriptor
&
aSharedData
ReadLockDescriptor
&
&
aReadLock
LayersBackend
aLayersBackend
TextureFlags
aFlags
uint64_t
aSerial
wr
:
:
MaybeExternalImageId
&
aExternalImageId
)
{
MOZ_ASSERT
(
CanSend
(
)
)
;
return
SendPTextureConstructor
(
aSharedData
std
:
:
move
(
aReadLock
)
aLayersBackend
aFlags
aSerial
)
;
}
bool
VideoBridgeChild
:
:
IsSameProcess
(
)
const
{
return
OtherPid
(
)
=
=
base
:
:
GetCurrentProcId
(
)
;
}
void
VideoBridgeChild
:
:
HandleFatalError
(
const
char
*
aMsg
)
{
dom
:
:
ContentChild
:
:
FatalErrorIfNotUsingGPUProcess
(
aMsg
OtherPid
(
)
)
;
}
}
}
