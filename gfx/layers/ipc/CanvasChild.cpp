#
include
"
CanvasChild
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
dom
/
WorkerCommon
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRef
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRunnable
.
h
"
#
include
"
mozilla
/
gfx
/
CanvasManagerChild
.
h
"
#
include
"
mozilla
/
gfx
/
DrawTargetRecording
.
h
"
#
include
"
mozilla
/
gfx
/
Tools
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
ipc
/
Endpoint
.
h
"
#
include
"
mozilla
/
ipc
/
ProcessChild
.
h
"
#
include
"
mozilla
/
layers
/
CanvasDrawEventRecorder
.
h
"
#
include
"
mozilla
/
layers
/
ImageDataSerializer
.
h
"
#
include
"
mozilla
/
layers
/
SourceSurfaceSharedData
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
RecordedCanvasEventImpl
.
h
"
namespace
mozilla
{
namespace
layers
{
class
RecorderHelpers
final
:
public
CanvasDrawEventRecorder
:
:
Helpers
{
public
:
NS_DECL_OWNINGTHREAD
explicit
RecorderHelpers
(
CanvasChild
*
aCanvasChild
)
:
mCanvasChild
(
aCanvasChild
)
{
}
~
RecorderHelpers
(
)
override
{
MOZ_ASSERT
(
!
mCanvasChild
)
;
}
void
Destroy
(
)
override
{
NS_ASSERT_OWNINGTHREAD
(
RecorderHelpers
)
;
mCanvasChild
=
nullptr
;
}
bool
InitTranslator
(
TextureType
aTextureType
gfx
:
:
BackendType
aBackendType
Handle
&
&
aReadHandle
nsTArray
<
Handle
>
&
&
aBufferHandles
uint64_t
aBufferSize
CrossProcessSemaphoreHandle
&
&
aReaderSem
CrossProcessSemaphoreHandle
&
&
aWriterSem
bool
aUseIPDLThread
)
override
{
NS_ASSERT_OWNINGTHREAD
(
RecorderHelpers
)
;
if
(
NS_WARN_IF
(
!
mCanvasChild
)
)
{
return
false
;
}
return
mCanvasChild
-
>
SendInitTranslator
(
aTextureType
aBackendType
std
:
:
move
(
aReadHandle
)
std
:
:
move
(
aBufferHandles
)
aBufferSize
std
:
:
move
(
aReaderSem
)
std
:
:
move
(
aWriterSem
)
aUseIPDLThread
)
;
}
bool
AddBuffer
(
Handle
&
&
aBufferHandle
uint64_t
aBufferSize
)
override
{
NS_ASSERT_OWNINGTHREAD
(
RecorderHelpers
)
;
if
(
!
mCanvasChild
)
{
return
false
;
}
return
mCanvasChild
-
>
SendAddBuffer
(
std
:
:
move
(
aBufferHandle
)
aBufferSize
)
;
}
bool
ReaderClosed
(
)
override
{
NS_ASSERT_OWNINGTHREAD
(
RecorderHelpers
)
;
if
(
!
mCanvasChild
)
{
return
false
;
}
return
!
mCanvasChild
-
>
CanSend
(
)
|
|
ipc
:
:
ProcessChild
:
:
ExpectingShutdown
(
)
;
}
bool
RestartReader
(
)
override
{
NS_ASSERT_OWNINGTHREAD
(
RecorderHelpers
)
;
if
(
!
mCanvasChild
)
{
return
false
;
}
return
mCanvasChild
-
>
SendRestartTranslation
(
)
;
}
private
:
CanvasChild
*
MOZ_NON_OWNING_REF
mCanvasChild
;
}
;
CanvasChild
:
:
CanvasChild
(
dom
:
:
ThreadSafeWorkerRef
*
aWorkerRef
)
:
mMutex
(
"
CanvasChild
:
:
mMutex
"
)
mWorkerRef
(
aWorkerRef
)
mIsOnWorker
(
!
!
aWorkerRef
)
{
}
;
CanvasChild
:
:
~
CanvasChild
(
)
=
default
;
static
void
NotifyCanvasDeviceReset
(
)
{
if
(
!
NS_IsMainThread
(
)
)
{
NS_DispatchToMainThread
(
NewRunnableFunction
(
__func__
&
NotifyCanvasDeviceReset
)
)
;
return
;
}
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
nullptr
"
canvas
-
device
-
reset
"
nullptr
)
;
}
}
ipc
:
:
IPCResult
CanvasChild
:
:
RecvNotifyDeviceChanged
(
)
{
NS_ASSERT_OWNINGTHREAD
(
CanvasChild
)
;
NotifyCanvasDeviceReset
(
)
;
mRecorder
-
>
RecordEvent
(
RecordedDeviceChangeAcknowledged
(
)
)
;
return
IPC_OK
(
)
;
}
bool
CanvasChild
:
:
mDeactivated
=
false
;
ipc
:
:
IPCResult
CanvasChild
:
:
RecvDeactivate
(
)
{
NS_ASSERT_OWNINGTHREAD
(
CanvasChild
)
;
RefPtr
<
CanvasChild
>
self
(
this
)
;
mDeactivated
=
true
;
if
(
auto
*
cm
=
gfx
:
:
CanvasManagerChild
:
:
Get
(
)
)
{
cm
-
>
DeactivateCanvas
(
)
;
}
NotifyCanvasDeviceReset
(
)
;
return
IPC_OK
(
)
;
}
ipc
:
:
IPCResult
CanvasChild
:
:
RecvBlockCanvas
(
)
{
if
(
auto
*
cm
=
gfx
:
:
CanvasManagerChild
:
:
Get
(
)
)
{
cm
-
>
BlockCanvas
(
)
;
}
return
IPC_OK
(
)
;
}
RefPtr
<
CanvasDrawEventRecorder
>
CanvasChild
:
:
EnsureRecorder
(
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
TextureType
aTextureType
)
{
NS_ASSERT_OWNINGTHREAD
(
CanvasChild
)
;
if
(
!
mRecorder
)
{
gfx
:
:
BackendType
backendType
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetPreferredCanvasBackend
(
)
;
RefPtr
<
CanvasDrawEventRecorder
>
recorder
;
{
MutexAutoLock
lock
(
mMutex
)
;
recorder
=
MakeAndAddRef
<
CanvasDrawEventRecorder
>
(
mWorkerRef
)
;
}
if
(
!
recorder
-
>
Init
(
aTextureType
backendType
MakeUnique
<
RecorderHelpers
>
(
this
)
)
)
{
recorder
-
>
DetachResources
(
)
;
return
nullptr
;
}
mRecorder
=
recorder
.
forget
(
)
;
}
MOZ_RELEASE_ASSERT
(
mRecorder
-
>
GetTextureType
(
)
=
=
aTextureType
"
We
only
support
one
remote
TextureType
currently
.
"
)
;
MutexAutoLock
lock
(
mMutex
)
;
EnsureDataSurfaceShmem
(
aSize
aFormat
)
;
return
mRecorder
;
}
void
CanvasChild
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
NS_ASSERT_OWNINGTHREAD
(
CanvasChild
)
;
if
(
mRecorder
)
{
mRecorder
-
>
DetachResources
(
)
;
}
MutexAutoLock
lock
(
mMutex
)
;
mWorkerRef
=
nullptr
;
}
void
CanvasChild
:
:
Destroy
(
)
{
NS_ASSERT_OWNINGTHREAD
(
CanvasChild
)
;
if
(
CanSend
(
)
)
{
Send__delete__
(
this
)
;
}
MutexAutoLock
lock
(
mMutex
)
;
mWorkerRef
=
nullptr
;
}
void
CanvasChild
:
:
OnTextureWriteLock
(
)
{
NS_ASSERT_OWNINGTHREAD
(
CanvasChild
)
;
mHasOutstandingWriteLock
=
true
;
mLastWriteLockCheckpoint
=
mRecorder
-
>
CreateCheckpoint
(
)
;
}
void
CanvasChild
:
:
OnTextureForwarded
(
)
{
if
(
mIsOnWorker
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
NS_WARN_IF
(
!
mWorkerRef
)
)
{
return
;
}
if
(
!
mWorkerRef
-
>
Private
(
)
-
>
IsOnCurrentThread
(
)
)
{
class
ForwardedRunnable
final
:
public
dom
:
:
WorkerRunnable
{
public
:
ForwardedRunnable
(
dom
:
:
WorkerPrivate
*
aWorkerPrivate
CanvasChild
*
aCanvasChild
)
:
dom
:
:
WorkerRunnable
(
aWorkerPrivate
)
mCanvasChild
(
aCanvasChild
)
{
}
bool
WorkerRun
(
JSContext
*
dom
:
:
WorkerPrivate
*
)
override
{
mCanvasChild
-
>
OnTextureForwarded
(
)
;
return
true
;
}
private
:
RefPtr
<
CanvasChild
>
mCanvasChild
;
}
;
auto
task
=
MakeRefPtr
<
ForwardedRunnable
>
(
mWorkerRef
-
>
Private
(
)
this
)
;
task
-
>
Dispatch
(
)
;
return
;
}
}
else
if
(
!
NS_IsMainThread
(
)
)
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
CanvasChild
:
:
OnTextureForwarded
"
[
self
=
RefPtr
{
this
}
]
(
)
{
self
-
>
OnTextureForwarded
(
)
;
}
)
)
;
return
;
}
NS_ASSERT_OWNINGTHREAD
(
CanvasChild
)
;
if
(
mHasOutstandingWriteLock
)
{
mRecorder
-
>
RecordEvent
(
RecordedCanvasFlush
(
)
)
;
if
(
!
mRecorder
-
>
WaitForCheckpoint
(
mLastWriteLockCheckpoint
)
)
{
gfxWarning
(
)
<
<
"
Timed
out
waiting
for
last
write
lock
to
be
processed
.
"
;
}
mHasOutstandingWriteLock
=
false
;
}
mRecorder
-
>
TakeExternalSurfaces
(
mLastTransactionExternalSurfaces
)
;
}
bool
CanvasChild
:
:
EnsureBeginTransaction
(
)
{
NS_ASSERT_OWNINGTHREAD
(
CanvasChild
)
;
if
(
!
mIsInTransaction
)
{
RecordEvent
(
RecordedCanvasBeginTransaction
(
)
)
;
mIsInTransaction
=
true
;
}
return
true
;
}
void
CanvasChild
:
:
EndTransaction
(
)
{
NS_ASSERT_OWNINGTHREAD
(
CanvasChild
)
;
if
(
mIsInTransaction
)
{
RecordEvent
(
RecordedCanvasEndTransaction
(
)
)
;
mIsInTransaction
=
false
;
mDormant
=
false
;
}
else
if
(
mRecorder
)
{
if
(
!
mDormant
)
{
mDormant
=
true
;
NS_DelayedDispatchToCurrentThread
(
NewRunnableMethod
(
"
CanvasChild
:
:
DropFreeBuffersWhenDormant
"
this
&
CanvasChild
:
:
DropFreeBuffersWhenDormant
)
StaticPrefs
:
:
gfx_canvas_remote_drop_buffer_milliseconds
(
)
)
;
}
}
+
+
mTransactionsSinceGetDataSurface
;
}
void
CanvasChild
:
:
DropFreeBuffersWhenDormant
(
)
{
NS_ASSERT_OWNINGTHREAD
(
CanvasChild
)
;
if
(
mDormant
&
&
mRecorder
)
{
mRecorder
-
>
DropFreeBuffers
(
)
;
}
}
void
CanvasChild
:
:
ClearCachedResources
(
)
{
NS_ASSERT_OWNINGTHREAD
(
CanvasChild
)
;
if
(
mRecorder
)
{
mRecorder
-
>
DropFreeBuffers
(
)
;
}
}
bool
CanvasChild
:
:
ShouldBeCleanedUp
(
)
const
{
NS_ASSERT_OWNINGTHREAD
(
CanvasChild
)
;
if
(
Deactivated
(
)
)
{
return
true
;
}
return
!
mRecorder
|
|
mRecorder
-
>
hasOneRef
(
)
;
}
already_AddRefed
<
gfx
:
:
DrawTarget
>
CanvasChild
:
:
CreateDrawTarget
(
int64_t
aTextureId
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
)
{
NS_ASSERT_OWNINGTHREAD
(
CanvasChild
)
;
if
(
!
mRecorder
)
{
return
nullptr
;
}
RefPtr
<
gfx
:
:
DrawTarget
>
dummyDt
=
gfx
:
:
Factory
:
:
CreateDrawTarget
(
gfx
:
:
BackendType
:
:
SKIA
gfx
:
:
IntSize
(
1
1
)
aFormat
)
;
RefPtr
<
gfx
:
:
DrawTarget
>
dt
=
MakeAndAddRef
<
gfx
:
:
DrawTargetRecording
>
(
mRecorder
dummyDt
gfx
:
:
IntRect
(
gfx
:
:
IntPoint
(
0
0
)
aSize
)
)
;
mTextureInfo
.
insert
(
{
aTextureId
{
}
}
)
;
return
dt
.
forget
(
)
;
}
bool
CanvasChild
:
:
EnsureDataSurfaceShmem
(
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
)
{
NS_ASSERT_OWNINGTHREAD
(
CanvasChild
)
;
if
(
!
mRecorder
)
{
return
false
;
}
size_t
sizeRequired
=
ImageDataSerializer
:
:
ComputeRGBBufferSize
(
aSize
aFormat
)
;
if
(
!
sizeRequired
)
{
return
false
;
}
sizeRequired
=
ipc
:
:
SharedMemory
:
:
PageAlignedSize
(
sizeRequired
)
;
if
(
!
mDataSurfaceShmemAvailable
|
|
mDataSurfaceShmem
-
>
Size
(
)
<
sizeRequired
)
{
RecordEvent
(
RecordedPauseTranslation
(
)
)
;
auto
dataSurfaceShmem
=
MakeRefPtr
<
ipc
:
:
SharedMemoryBasic
>
(
)
;
if
(
!
dataSurfaceShmem
-
>
Create
(
sizeRequired
)
|
|
!
dataSurfaceShmem
-
>
Map
(
sizeRequired
)
)
{
return
false
;
}
auto
shmemHandle
=
dataSurfaceShmem
-
>
TakeHandle
(
)
;
if
(
!
shmemHandle
)
{
return
false
;
}
if
(
!
SendSetDataSurfaceBuffer
(
std
:
:
move
(
shmemHandle
)
sizeRequired
)
)
{
return
false
;
}
mDataSurfaceShmem
=
dataSurfaceShmem
.
forget
(
)
;
mDataSurfaceShmemAvailable
=
true
;
}
MOZ_ASSERT
(
mDataSurfaceShmemAvailable
)
;
return
true
;
}
void
CanvasChild
:
:
RecordEvent
(
const
gfx
:
:
RecordedEvent
&
aEvent
)
{
NS_ASSERT_OWNINGTHREAD
(
CanvasChild
)
;
if
(
!
mRecorder
)
{
return
;
}
mRecorder
-
>
RecordEvent
(
aEvent
)
;
}
int64_t
CanvasChild
:
:
CreateCheckpoint
(
)
{
NS_ASSERT_OWNINGTHREAD
(
CanvasChild
)
;
return
mRecorder
-
>
CreateCheckpoint
(
)
;
}
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
CanvasChild
:
:
GetDataSurface
(
int64_t
aTextureId
const
gfx
:
:
SourceSurface
*
aSurface
bool
aDetached
)
{
NS_ASSERT_OWNINGTHREAD
(
CanvasChild
)
;
MOZ_ASSERT
(
aSurface
)
;
if
(
!
mIsInTransaction
)
{
mTransactionsSinceGetDataSurface
=
0
;
}
if
(
!
EnsureBeginTransaction
(
)
)
{
return
nullptr
;
}
if
(
!
aDetached
)
{
auto
it
=
mTextureInfo
.
find
(
aTextureId
)
;
if
(
it
!
=
mTextureInfo
.
end
(
)
&
&
it
-
>
second
.
mSnapshotShmem
)
{
const
auto
shmemPtr
=
reinterpret_cast
<
uint8_t
*
>
(
it
-
>
second
.
mSnapshotShmem
-
>
memory
(
)
)
;
MOZ_ASSERT
(
shmemPtr
)
;
mRecorder
-
>
RecordEvent
(
RecordedPrepareShmem
(
aTextureId
)
)
;
auto
checkpoint
=
CreateCheckpoint
(
)
;
mRecorder
-
>
WaitForCheckpoint
(
checkpoint
)
;
gfx
:
:
IntSize
size
=
aSurface
-
>
GetSize
(
)
;
gfx
:
:
SurfaceFormat
format
=
aSurface
-
>
GetFormat
(
)
;
auto
stride
=
ImageDataSerializer
:
:
ComputeRGBStride
(
format
size
.
width
)
;
RefPtr
<
gfx
:
:
DataSourceSurface
>
dataSurface
=
gfx
:
:
Factory
:
:
CreateWrappingDataSourceSurface
(
shmemPtr
stride
size
format
)
;
return
dataSurface
.
forget
(
)
;
}
}
RecordEvent
(
RecordedPrepareDataForSurface
(
aSurface
)
)
;
gfx
:
:
IntSize
ssSize
=
aSurface
-
>
GetSize
(
)
;
gfx
:
:
SurfaceFormat
ssFormat
=
aSurface
-
>
GetFormat
(
)
;
RefPtr
<
ipc
:
:
SharedMemoryBasic
>
shmem
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
EnsureDataSurfaceShmem
(
ssSize
ssFormat
)
)
{
return
nullptr
;
}
shmem
=
mDataSurfaceShmem
;
mDataSurfaceShmemAvailable
=
false
;
}
RecordEvent
(
RecordedGetDataForSurface
(
aSurface
)
)
;
auto
checkpoint
=
CreateCheckpoint
(
)
;
struct
DataShmemHolder
{
RefPtr
<
ipc
:
:
SharedMemoryBasic
>
shmem
;
RefPtr
<
CanvasChild
>
canvasChild
;
}
;
auto
*
data
=
static_cast
<
uint8_t
*
>
(
shmem
-
>
memory
(
)
)
;
auto
*
closure
=
new
DataShmemHolder
{
std
:
:
move
(
shmem
)
this
}
;
auto
stride
=
ImageDataSerializer
:
:
ComputeRGBStride
(
ssFormat
ssSize
.
width
)
;
RefPtr
<
gfx
:
:
DataSourceSurface
>
dataSurface
=
gfx
:
:
Factory
:
:
CreateWrappingDataSourceSurface
(
data
stride
ssSize
ssFormat
[
]
(
void
*
aClosure
)
{
auto
*
shmemHolder
=
static_cast
<
DataShmemHolder
*
>
(
aClosure
)
;
shmemHolder
-
>
canvasChild
-
>
ReturnDataSurfaceShmem
(
shmemHolder
-
>
shmem
.
forget
(
)
)
;
delete
shmemHolder
;
}
closure
)
;
mRecorder
-
>
WaitForCheckpoint
(
checkpoint
)
;
return
dataSurface
.
forget
(
)
;
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
CanvasChild
:
:
WrapSurface
(
const
RefPtr
<
gfx
:
:
SourceSurface
>
&
aSurface
int64_t
aTextureId
)
{
NS_ASSERT_OWNINGTHREAD
(
CanvasChild
)
;
if
(
!
aSurface
)
{
return
nullptr
;
}
auto
wrapper
=
MakeRefPtr
<
SourceSurfaceCanvasRecording
>
(
aTextureId
aSurface
this
mRecorder
)
;
wrapper
-
>
Init
(
)
;
return
wrapper
.
forget
(
)
;
}
void
CanvasChild
:
:
ReturnDataSurfaceShmem
(
already_AddRefed
<
ipc
:
:
SharedMemoryBasic
>
aDataSurfaceShmem
)
{
MutexAutoLock
lock
(
mMutex
)
;
RefPtr
<
ipc
:
:
SharedMemoryBasic
>
data
=
aDataSurfaceShmem
;
if
(
data
=
=
mDataSurfaceShmem
)
{
MOZ_ASSERT
(
!
mDataSurfaceShmemAvailable
)
;
mDataSurfaceShmemAvailable
=
true
;
}
}
void
CanvasChild
:
:
DetachSurface
(
const
RefPtr
<
gfx
:
:
SourceSurface
>
&
aSurface
)
{
if
(
auto
*
surface
=
static_cast
<
SourceSurfaceCanvasRecording
*
>
(
aSurface
.
get
(
)
)
)
{
surface
-
>
DrawTargetWillChange
(
)
;
}
}
ipc
:
:
IPCResult
CanvasChild
:
:
RecvNotifyRequiresRefresh
(
int64_t
aTextureId
)
{
auto
it
=
mTextureInfo
.
find
(
aTextureId
)
;
if
(
it
!
=
mTextureInfo
.
end
(
)
)
{
it
-
>
second
.
mRequiresRefresh
=
true
;
}
return
IPC_OK
(
)
;
}
bool
CanvasChild
:
:
RequiresRefresh
(
int64_t
aTextureId
)
const
{
auto
it
=
mTextureInfo
.
find
(
aTextureId
)
;
if
(
it
!
=
mTextureInfo
.
end
(
)
)
{
return
it
-
>
second
.
mRequiresRefresh
;
}
return
false
;
}
ipc
:
:
IPCResult
CanvasChild
:
:
RecvSnapshotShmem
(
int64_t
aTextureId
Handle
&
&
aShmemHandle
uint32_t
aShmemSize
SnapshotShmemResolver
&
&
aResolve
)
{
auto
it
=
mTextureInfo
.
find
(
aTextureId
)
;
if
(
it
!
=
mTextureInfo
.
end
(
)
)
{
auto
shmem
=
MakeRefPtr
<
ipc
:
:
SharedMemoryBasic
>
(
)
;
if
(
NS_WARN_IF
(
!
shmem
-
>
SetHandle
(
std
:
:
move
(
aShmemHandle
)
ipc
:
:
SharedMemory
:
:
RightsReadOnly
)
)
|
|
NS_WARN_IF
(
!
shmem
-
>
Map
(
aShmemSize
)
)
)
{
shmem
=
nullptr
;
}
else
{
it
-
>
second
.
mSnapshotShmem
=
std
:
:
move
(
shmem
)
;
}
aResolve
(
true
)
;
}
else
{
aResolve
(
false
)
;
}
return
IPC_OK
(
)
;
}
void
CanvasChild
:
:
CleanupTexture
(
int64_t
aTextureId
)
{
mTextureInfo
.
erase
(
aTextureId
)
;
}
bool
CanvasChild
:
:
IsOnOwningThread
(
)
const
{
if
(
!
mIsOnWorker
)
{
return
NS_IsMainThread
(
)
;
}
MutexAutoLock
lock
(
mMutex
)
;
MOZ_RELEASE_ASSERT
(
mWorkerRef
)
;
return
mWorkerRef
-
>
Private
(
)
-
>
IsOnCurrentThread
(
)
;
}
}
}
