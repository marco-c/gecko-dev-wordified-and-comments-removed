#
include
"
SharedPlanarYCbCrImage
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdio
.
h
>
#
include
"
gfx2DGlue
.
h
"
#
include
"
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
ImageClient
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
layers
/
TextureClientRecycleAllocator
.
h
"
#
include
"
mozilla
/
layers
/
BufferTexture
.
h
"
#
include
"
mozilla
/
layers
/
ImageDataSerializer
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeChild
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
mozilla
/
ipc
/
Shmem
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
mozilla
:
:
ipc
;
SharedPlanarYCbCrImage
:
:
SharedPlanarYCbCrImage
(
ImageClient
*
aCompositable
)
:
mCompositable
(
aCompositable
)
{
MOZ_COUNT_CTOR
(
SharedPlanarYCbCrImage
)
;
}
SharedPlanarYCbCrImage
:
:
SharedPlanarYCbCrImage
(
TextureClientRecycleAllocator
*
aRecycleAllocator
)
:
mRecycleAllocator
(
aRecycleAllocator
)
{
MOZ_COUNT_CTOR
(
SharedPlanarYCbCrImage
)
;
}
SharedPlanarYCbCrImage
:
:
~
SharedPlanarYCbCrImage
(
)
{
MOZ_COUNT_DTOR
(
SharedPlanarYCbCrImage
)
;
}
TextureClientRecycleAllocator
*
SharedPlanarYCbCrImage
:
:
RecycleAllocator
(
)
{
static
const
uint32_t
MAX_POOLED_VIDEO_COUNT
=
5
;
if
(
!
mRecycleAllocator
&
&
mCompositable
)
{
if
(
!
mCompositable
-
>
HasTextureClientRecycler
(
)
)
{
mCompositable
-
>
GetTextureClientRecycler
(
)
-
>
SetMaxPoolSize
(
MAX_POOLED_VIDEO_COUNT
)
;
}
mRecycleAllocator
=
mCompositable
-
>
GetTextureClientRecycler
(
)
;
}
return
mRecycleAllocator
;
}
size_t
SharedPlanarYCbCrImage
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
0
;
}
TextureClient
*
SharedPlanarYCbCrImage
:
:
GetTextureClient
(
KnowsCompositor
*
aKnowsCompositor
)
{
return
mTextureClient
.
get
(
)
;
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
SharedPlanarYCbCrImage
:
:
GetAsSourceSurface
(
)
{
if
(
!
IsValid
(
)
)
{
NS_WARNING
(
"
Can
'
t
get
as
surface
"
)
;
return
nullptr
;
}
return
PlanarYCbCrImage
:
:
GetAsSourceSurface
(
)
;
}
nsresult
SharedPlanarYCbCrImage
:
:
CopyData
(
const
PlanarYCbCrData
&
aData
)
{
if
(
!
mTextureClient
)
{
nsresult
r
=
CreateEmptyBuffer
(
aData
aData
.
YDataSize
(
)
aData
.
CbCrDataSize
(
)
)
;
if
(
NS_FAILED
(
r
)
)
{
return
r
;
}
}
TextureClientAutoLock
autoLock
(
mTextureClient
OpenMode
:
:
OPEN_WRITE_ONLY
)
;
if
(
!
autoLock
.
Succeeded
(
)
)
{
MOZ_ASSERT
(
false
"
Failed
to
lock
the
texture
.
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
if
(
!
UpdateYCbCrTextureClient
(
mTextureClient
aData
)
)
{
MOZ_ASSERT
(
false
"
Failed
to
copy
YCbCr
data
into
the
TextureClient
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
mTextureClient
-
>
MarkImmutable
(
)
;
return
NS_OK
;
}
nsresult
SharedPlanarYCbCrImage
:
:
AdoptData
(
const
Data
&
aData
)
{
MOZ_ASSERT
(
false
"
This
shouldn
'
t
be
used
.
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
bool
SharedPlanarYCbCrImage
:
:
IsValid
(
)
const
{
return
mTextureClient
&
&
mTextureClient
-
>
IsValid
(
)
;
}
nsresult
SharedPlanarYCbCrImage
:
:
CreateEmptyBuffer
(
const
PlanarYCbCrData
&
aData
const
gfx
:
:
IntSize
&
aYSize
const
gfx
:
:
IntSize
&
aCbCrSize
)
{
MOZ_ASSERT
(
!
mTextureClient
"
This
image
already
has
allocated
data
"
)
;
TextureFlags
flags
=
mCompositable
?
mCompositable
-
>
GetTextureFlags
(
)
:
TextureFlags
:
:
DEFAULT
;
{
YCbCrTextureClientAllocationHelper
helper
(
aData
aYSize
aCbCrSize
flags
)
;
Result
<
already_AddRefed
<
TextureClient
>
nsresult
>
result
=
RecycleAllocator
(
)
-
>
CreateOrRecycle
(
helper
)
;
if
(
result
.
isErr
(
)
)
{
return
Err
(
result
.
unwrapErr
(
)
)
;
}
mTextureClient
=
result
.
unwrap
(
)
;
}
if
(
!
mTextureClient
)
{
NS_WARNING
(
"
SharedPlanarYCbCrImage
:
:
Allocate
failed
.
"
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
MappedYCbCrTextureData
mapped
;
if
(
!
mTextureClient
-
>
Lock
(
OpenMode
:
:
OPEN_READ
)
|
|
!
mTextureClient
-
>
BorrowMappedYCbCrData
(
mapped
)
)
{
MOZ_CRASH
(
"
GFX
:
Cannot
lock
or
borrow
mapped
YCbCr
"
)
;
}
mData
.
mYChannel
=
mapped
.
y
.
data
;
mData
.
mCbChannel
=
mapped
.
cb
.
data
;
mData
.
mCrChannel
=
mapped
.
cr
.
data
;
mData
.
mPictureRect
=
aData
.
mPictureRect
;
mData
.
mStereoMode
=
aData
.
mStereoMode
;
mData
.
mYUVColorSpace
=
aData
.
mYUVColorSpace
;
mData
.
mColorDepth
=
aData
.
mColorDepth
;
mData
.
mChromaSubsampling
=
aData
.
mChromaSubsampling
;
mData
.
mYSkip
=
0
;
mData
.
mCbSkip
=
0
;
mData
.
mCrSkip
=
0
;
mData
.
mYStride
=
aData
.
mYStride
;
mData
.
mCbCrStride
=
aData
.
mCbCrStride
;
mBufferSize
=
ImageDataSerializer
:
:
ComputeYCbCrBufferSize
(
aYSize
mData
.
mYStride
aCbCrSize
mData
.
mCbCrStride
)
;
mSize
=
mData
.
mPictureRect
.
Size
(
)
;
mOrigin
=
mData
.
mPictureRect
.
TopLeft
(
)
;
mTextureClient
-
>
Unlock
(
)
;
return
mBufferSize
>
0
?
NS_OK
:
NS_ERROR_INVALID_ARG
;
}
void
SharedPlanarYCbCrImage
:
:
SetIsDRM
(
bool
aIsDRM
)
{
Image
:
:
SetIsDRM
(
aIsDRM
)
;
if
(
mTextureClient
)
{
mTextureClient
-
>
AddFlags
(
TextureFlags
:
:
DRM_SOURCE
)
;
}
}
}
}
