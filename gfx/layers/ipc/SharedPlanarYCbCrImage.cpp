#
include
"
SharedPlanarYCbCrImage
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdio
.
h
>
#
include
"
gfx2DGlue
.
h
"
#
include
"
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemory
.
h
"
#
include
"
mozilla
/
layers
/
ImageClient
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
layers
/
TextureClientRecycleAllocator
.
h
"
#
include
"
mozilla
/
layers
/
BufferTexture
.
h
"
#
include
"
mozilla
/
layers
/
ImageDataSerializer
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeChild
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
mozilla
/
ipc
/
Shmem
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
mozilla
:
:
ipc
;
SharedPlanarYCbCrImage
:
:
SharedPlanarYCbCrImage
(
ImageClient
*
aCompositable
)
:
mCompositable
(
aCompositable
)
{
MOZ_COUNT_CTOR
(
SharedPlanarYCbCrImage
)
;
}
SharedPlanarYCbCrImage
:
:
~
SharedPlanarYCbCrImage
(
)
{
MOZ_COUNT_DTOR
(
SharedPlanarYCbCrImage
)
;
}
size_t
SharedPlanarYCbCrImage
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
0
;
}
TextureClient
*
SharedPlanarYCbCrImage
:
:
GetTextureClient
(
KnowsCompositor
*
aForwarder
)
{
return
mTextureClient
.
get
(
)
;
}
uint8_t
*
SharedPlanarYCbCrImage
:
:
GetBuffer
(
)
const
{
MOZ_ASSERT
(
false
)
;
return
nullptr
;
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
SharedPlanarYCbCrImage
:
:
GetAsSourceSurface
(
)
{
if
(
!
IsValid
(
)
)
{
NS_WARNING
(
"
Can
'
t
get
as
surface
"
)
;
return
nullptr
;
}
return
PlanarYCbCrImage
:
:
GetAsSourceSurface
(
)
;
}
bool
SharedPlanarYCbCrImage
:
:
CopyData
(
const
PlanarYCbCrData
&
aData
)
{
PlanarYCbCrData
data
=
aData
;
if
(
!
mTextureClient
&
&
!
Allocate
(
data
)
)
{
return
false
;
}
TextureClientAutoLock
autoLock
(
mTextureClient
OpenMode
:
:
OPEN_WRITE_ONLY
)
;
if
(
!
autoLock
.
Succeeded
(
)
)
{
MOZ_ASSERT
(
false
"
Failed
to
lock
the
texture
.
"
)
;
return
false
;
}
if
(
!
UpdateYCbCrTextureClient
(
mTextureClient
aData
)
)
{
MOZ_ASSERT
(
false
"
Failed
to
copy
YCbCr
data
into
the
TextureClient
"
)
;
return
false
;
}
mTextureClient
-
>
MarkImmutable
(
)
;
return
true
;
}
bool
SharedPlanarYCbCrImage
:
:
AdoptData
(
const
Data
&
aData
)
{
MOZ_ASSERT
(
mTextureClient
"
This
Image
should
have
already
allocated
data
"
)
;
if
(
!
mTextureClient
)
{
return
false
;
}
mData
=
aData
;
mSize
=
aData
.
mPicSize
;
mOrigin
=
gfx
:
:
IntPoint
(
aData
.
mPicX
aData
.
mPicY
)
;
uint8_t
*
base
=
GetBuffer
(
)
;
uint32_t
yOffset
=
aData
.
mYChannel
-
base
;
uint32_t
cbOffset
=
aData
.
mCbChannel
-
base
;
uint32_t
crOffset
=
aData
.
mCrChannel
-
base
;
auto
fwd
=
mCompositable
-
>
GetForwarder
(
)
;
bool
hasIntermediateBuffer
=
ComputeHasIntermediateBuffer
(
gfx
:
:
SurfaceFormat
:
:
YUV
fwd
-
>
GetCompositorBackendType
(
)
)
;
static_cast
<
BufferTextureData
*
>
(
mTextureClient
-
>
GetInternalData
(
)
)
-
>
SetDesciptor
(
YCbCrDescriptor
(
aData
.
mYSize
aData
.
mYStride
aData
.
mCbCrSize
aData
.
mCbCrStride
yOffset
cbOffset
crOffset
aData
.
mStereoMode
aData
.
mYUVColorSpace
aData
.
mBitDepth
hasIntermediateBuffer
)
)
;
return
true
;
}
bool
SharedPlanarYCbCrImage
:
:
IsValid
(
)
const
{
return
mTextureClient
&
&
mTextureClient
-
>
IsValid
(
)
;
}
bool
SharedPlanarYCbCrImage
:
:
Allocate
(
PlanarYCbCrData
&
aData
)
{
MOZ_ASSERT
(
!
mTextureClient
"
This
image
already
has
allocated
data
"
)
;
static
const
uint32_t
MAX_POOLED_VIDEO_COUNT
=
5
;
if
(
!
mCompositable
-
>
HasTextureClientRecycler
(
)
)
{
mCompositable
-
>
GetTextureClientRecycler
(
)
-
>
SetMaxPoolSize
(
MAX_POOLED_VIDEO_COUNT
)
;
}
{
YCbCrTextureClientAllocationHelper
helper
(
aData
mCompositable
-
>
GetTextureFlags
(
)
)
;
mTextureClient
=
mCompositable
-
>
GetTextureClientRecycler
(
)
-
>
CreateOrRecycle
(
helper
)
;
}
if
(
!
mTextureClient
)
{
NS_WARNING
(
"
SharedPlanarYCbCrImage
:
:
Allocate
failed
.
"
)
;
return
false
;
}
MappedYCbCrTextureData
mapped
;
if
(
!
mTextureClient
-
>
Lock
(
OpenMode
:
:
OPEN_READ
)
|
|
!
mTextureClient
-
>
BorrowMappedYCbCrData
(
mapped
)
)
{
MOZ_CRASH
(
"
GFX
:
Cannot
lock
or
borrow
mapped
YCbCr
"
)
;
}
aData
.
mYChannel
=
mapped
.
y
.
data
;
aData
.
mCbChannel
=
mapped
.
cb
.
data
;
aData
.
mCrChannel
=
mapped
.
cr
.
data
;
mData
.
mYChannel
=
aData
.
mYChannel
;
mData
.
mCbChannel
=
aData
.
mCbChannel
;
mData
.
mCrChannel
=
aData
.
mCrChannel
;
mData
.
mYSize
=
aData
.
mYSize
;
mData
.
mCbCrSize
=
aData
.
mCbCrSize
;
mData
.
mPicX
=
aData
.
mPicX
;
mData
.
mPicY
=
aData
.
mPicY
;
mData
.
mPicSize
=
aData
.
mPicSize
;
mData
.
mStereoMode
=
aData
.
mStereoMode
;
mData
.
mYUVColorSpace
=
aData
.
mYUVColorSpace
;
mData
.
mBitDepth
=
aData
.
mBitDepth
;
mData
.
mYSkip
=
0
;
mData
.
mCbSkip
=
0
;
mData
.
mCrSkip
=
0
;
mData
.
mYStride
=
aData
.
mYStride
;
mData
.
mCbCrStride
=
aData
.
mCbCrStride
;
mBufferSize
=
ImageDataSerializer
:
:
ComputeYCbCrBufferSize
(
mData
.
mYSize
mData
.
mYStride
mData
.
mCbCrSize
mData
.
mCbCrStride
)
;
mSize
=
mData
.
mPicSize
;
mOrigin
=
gfx
:
:
IntPoint
(
aData
.
mPicX
aData
.
mPicY
)
;
mTextureClient
-
>
Unlock
(
)
;
return
mBufferSize
>
0
;
}
}
}
