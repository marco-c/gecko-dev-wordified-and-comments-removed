#
include
"
SharedPlanarYCbCrImage
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdio
.
h
>
#
include
"
gfx2DGlue
.
h
"
#
include
"
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemory
.
h
"
#
include
"
mozilla
/
layers
/
ImageClient
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
layers
/
BufferTexture
.
h
"
#
include
"
mozilla
/
layers
/
ImageDataSerializer
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeChild
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
mozilla
/
ipc
/
Shmem
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
mozilla
:
:
ipc
;
SharedPlanarYCbCrImage
:
:
SharedPlanarYCbCrImage
(
ImageClient
*
aCompositable
)
:
mCompositable
(
aCompositable
)
{
MOZ_COUNT_CTOR
(
SharedPlanarYCbCrImage
)
;
}
SharedPlanarYCbCrImage
:
:
~
SharedPlanarYCbCrImage
(
)
{
MOZ_COUNT_DTOR
(
SharedPlanarYCbCrImage
)
;
if
(
mCompositable
-
>
GetAsyncID
(
)
!
=
0
&
&
!
InImageBridgeChildThread
(
)
)
{
if
(
mTextureClient
)
{
ADDREF_MANUALLY
(
mTextureClient
)
;
ImageBridgeChild
:
:
DispatchReleaseTextureClient
(
mTextureClient
)
;
mTextureClient
=
nullptr
;
}
ImageBridgeChild
:
:
DispatchReleaseImageClient
(
mCompositable
.
forget
(
)
.
take
(
)
)
;
}
}
size_t
SharedPlanarYCbCrImage
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
0
;
}
TextureClient
*
SharedPlanarYCbCrImage
:
:
GetTextureClient
(
CompositableClient
*
aClient
)
{
return
mTextureClient
.
get
(
)
;
}
uint8_t
*
SharedPlanarYCbCrImage
:
:
GetBuffer
(
)
{
MOZ_ASSERT
(
false
)
;
return
nullptr
;
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
SharedPlanarYCbCrImage
:
:
GetAsSourceSurface
(
)
{
if
(
!
mTextureClient
)
{
NS_WARNING
(
"
Can
'
t
get
as
surface
"
)
;
return
nullptr
;
}
return
PlanarYCbCrImage
:
:
GetAsSourceSurface
(
)
;
}
bool
SharedPlanarYCbCrImage
:
:
CopyData
(
const
PlanarYCbCrData
&
aData
)
{
PlanarYCbCrData
data
=
aData
;
if
(
!
mTextureClient
&
&
!
Allocate
(
data
)
)
{
return
false
;
}
TextureClientAutoLock
autoLock
(
mTextureClient
OpenMode
:
:
OPEN_WRITE_ONLY
)
;
if
(
!
autoLock
.
Succeeded
(
)
)
{
MOZ_ASSERT
(
false
"
Failed
to
lock
the
texture
.
"
)
;
return
false
;
}
if
(
!
UpdateYCbCrTextureClient
(
mTextureClient
aData
)
)
{
MOZ_ASSERT
(
false
"
Failed
to
copy
YCbCr
data
into
the
TextureClient
"
)
;
return
false
;
}
mTextureClient
-
>
MarkImmutable
(
)
;
return
true
;
}
uint8_t
*
SharedPlanarYCbCrImage
:
:
AllocateAndGetNewBuffer
(
uint32_t
aSize
)
{
MOZ_ASSERT
(
!
mTextureClient
"
This
image
already
has
allocated
data
"
)
;
size_t
size
=
ImageDataSerializer
:
:
ComputeYCbCrBufferSize
(
aSize
)
;
if
(
!
size
)
{
return
nullptr
;
}
mTextureClient
=
TextureClient
:
:
CreateForYCbCrWithBufferSize
(
mCompositable
-
>
GetForwarder
(
)
gfx
:
:
SurfaceFormat
:
:
YUV
size
mCompositable
-
>
GetTextureFlags
(
)
)
;
if
(
!
mTextureClient
)
{
return
nullptr
;
}
mBufferSize
=
size
;
MappedYCbCrTextureData
mapped
;
if
(
mTextureClient
-
>
BorrowMappedYCbCrData
(
mapped
)
)
{
return
mapped
.
y
.
data
;
}
else
{
MOZ_CRASH
(
)
;
}
}
bool
SharedPlanarYCbCrImage
:
:
AdoptData
(
const
Data
&
aData
)
{
MOZ_ASSERT
(
mTextureClient
"
This
Image
should
have
already
allocated
data
"
)
;
if
(
!
mTextureClient
)
{
return
false
;
}
mData
=
aData
;
mSize
=
aData
.
mPicSize
;
uint8_t
*
base
=
GetBuffer
(
)
;
uint32_t
yOffset
=
aData
.
mYChannel
-
base
;
uint32_t
cbOffset
=
aData
.
mCbChannel
-
base
;
uint32_t
crOffset
=
aData
.
mCrChannel
-
base
;
static_cast
<
BufferTextureData
*
>
(
mTextureClient
-
>
GetInternalData
(
)
)
-
>
SetDesciptor
(
YCbCrDescriptor
(
aData
.
mYSize
aData
.
mCbCrSize
yOffset
cbOffset
crOffset
aData
.
mStereoMode
)
)
;
return
true
;
}
bool
SharedPlanarYCbCrImage
:
:
IsValid
(
)
{
return
!
!
mTextureClient
;
}
bool
SharedPlanarYCbCrImage
:
:
Allocate
(
PlanarYCbCrData
&
aData
)
{
MOZ_ASSERT
(
!
mTextureClient
"
This
image
already
has
allocated
data
"
)
;
mTextureClient
=
TextureClient
:
:
CreateForYCbCr
(
mCompositable
-
>
GetForwarder
(
)
aData
.
mYSize
aData
.
mCbCrSize
aData
.
mStereoMode
mCompositable
-
>
GetTextureFlags
(
)
)
;
if
(
!
mTextureClient
)
{
NS_WARNING
(
"
SharedPlanarYCbCrImage
:
:
Allocate
failed
.
"
)
;
return
false
;
}
MappedYCbCrTextureData
mapped
;
if
(
!
mTextureClient
-
>
Lock
(
OpenMode
:
:
OPEN_READ
)
|
|
!
mTextureClient
-
>
BorrowMappedYCbCrData
(
mapped
)
)
{
MOZ_CRASH
(
)
;
}
aData
.
mYChannel
=
mapped
.
y
.
data
;
aData
.
mCbChannel
=
mapped
.
cb
.
data
;
aData
.
mCrChannel
=
mapped
.
cr
.
data
;
mData
.
mYChannel
=
aData
.
mYChannel
;
mData
.
mCbChannel
=
aData
.
mCbChannel
;
mData
.
mCrChannel
=
aData
.
mCrChannel
;
mData
.
mYSize
=
aData
.
mYSize
;
mData
.
mCbCrSize
=
aData
.
mCbCrSize
;
mData
.
mPicX
=
aData
.
mPicX
;
mData
.
mPicY
=
aData
.
mPicY
;
mData
.
mPicSize
=
aData
.
mPicSize
;
mData
.
mStereoMode
=
aData
.
mStereoMode
;
mData
.
mYSkip
=
0
;
mData
.
mCbSkip
=
0
;
mData
.
mCrSkip
=
0
;
mData
.
mYStride
=
mData
.
mYSize
.
width
;
mData
.
mCbCrStride
=
mData
.
mCbCrSize
.
width
;
mBufferSize
=
ImageDataSerializer
:
:
ComputeYCbCrBufferSize
(
mData
.
mYSize
mData
.
mCbCrSize
)
;
mSize
=
mData
.
mPicSize
;
mTextureClient
-
>
Unlock
(
)
;
return
mBufferSize
>
0
;
}
}
}
