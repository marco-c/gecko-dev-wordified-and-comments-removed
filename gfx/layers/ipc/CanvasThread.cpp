#
include
"
CanvasThread
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
prsystem
.
h
"
bool
NS_IsInCanvasThreadOrWorker
(
)
{
return
mozilla
:
:
layers
:
:
CanvasThreadHolder
:
:
IsInCanvasThreadOrWorker
(
)
;
}
namespace
mozilla
{
namespace
layers
{
StaticDataMutex
<
StaticRefPtr
<
CanvasThreadHolder
>
>
CanvasThreadHolder
:
:
sCanvasThreadHolder
(
"
sCanvasThreadHolder
"
)
;
CanvasThreadHolder
:
:
CanvasThreadHolder
(
already_AddRefed
<
nsIThread
>
aCanvasThread
already_AddRefed
<
nsIThreadPool
>
aCanvasWorkers
)
:
mCanvasThread
(
aCanvasThread
)
mCanvasWorkers
(
aCanvasWorkers
)
mCompositorThreadKeepAlive
(
CompositorThreadHolder
:
:
GetSingleton
(
)
)
{
MOZ_ASSERT
(
NS_IsInCompositorThread
(
)
)
;
MOZ_ASSERT
(
mCanvasThread
)
;
MOZ_ASSERT
(
mCanvasWorkers
)
;
}
CanvasThreadHolder
:
:
~
CanvasThreadHolder
(
)
{
MOZ_ASSERT
(
mCompositorThreadKeepAlive
-
>
GetCompositorThread
(
)
-
>
IsOnCurrentThread
(
)
)
;
}
already_AddRefed
<
CanvasThreadHolder
>
CanvasThreadHolder
:
:
EnsureCanvasThread
(
)
{
MOZ_ASSERT
(
NS_IsInCompositorThread
(
)
)
;
auto
lockedCanvasThreadHolder
=
sCanvasThreadHolder
.
Lock
(
)
;
if
(
!
lockedCanvasThreadHolder
.
ref
(
)
)
{
nsCOMPtr
<
nsIThread
>
canvasThread
;
nsresult
rv
=
NS_NewNamedThread
(
"
Canvas
"
getter_AddRefs
(
canvasThread
)
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
uint32_t
threadLimit
=
std
:
:
max
(
2
PR_GetNumberOfProcessors
(
)
/
2
)
;
nsCOMPtr
<
nsIThreadPool
>
canvasWorkers
=
SharedThreadPool
:
:
Get
(
NS_LITERAL_CSTRING
(
"
CanvasWorkers
"
)
threadLimit
)
;
if
(
!
canvasWorkers
)
{
return
nullptr
;
}
lockedCanvasThreadHolder
.
ref
(
)
=
new
CanvasThreadHolder
(
canvasThread
.
forget
(
)
canvasWorkers
.
forget
(
)
)
;
}
return
do_AddRef
(
lockedCanvasThreadHolder
.
ref
(
)
)
;
}
void
CanvasThreadHolder
:
:
StaticRelease
(
already_AddRefed
<
CanvasThreadHolder
>
aCanvasThreadHolder
)
{
RefPtr
<
CanvasThreadHolder
>
threadHolder
=
aCanvasThreadHolder
;
MOZ_ASSERT
(
threadHolder
-
>
mCompositorThreadKeepAlive
-
>
GetCompositorThread
(
)
-
>
IsOnCurrentThread
(
)
)
;
threadHolder
=
nullptr
;
auto
lockedCanvasThreadHolder
=
sCanvasThreadHolder
.
Lock
(
)
;
if
(
lockedCanvasThreadHolder
.
ref
(
)
-
>
mRefCnt
=
=
1
)
{
lockedCanvasThreadHolder
.
ref
(
)
=
nullptr
;
}
}
void
CanvasThreadHolder
:
:
ReleaseOnCompositorThread
(
already_AddRefed
<
CanvasThreadHolder
>
aCanvasThreadHolder
)
{
auto
lockedCanvasThreadHolder
=
sCanvasThreadHolder
.
Lock
(
)
;
lockedCanvasThreadHolder
.
ref
(
)
-
>
mCompositorThreadKeepAlive
-
>
GetCompositorThread
(
)
-
>
Dispatch
(
NewRunnableFunction
(
"
CanvasThreadHolder
:
:
StaticRelease
"
CanvasThreadHolder
:
:
StaticRelease
std
:
:
move
(
aCanvasThreadHolder
)
)
)
;
}
bool
CanvasThreadHolder
:
:
IsInCanvasThread
(
)
{
auto
lockedCanvasThreadHolder
=
sCanvasThreadHolder
.
Lock
(
)
;
return
lockedCanvasThreadHolder
.
ref
(
)
&
&
lockedCanvasThreadHolder
.
ref
(
)
-
>
mCanvasThread
-
>
IsOnCurrentThread
(
)
;
}
bool
CanvasThreadHolder
:
:
IsInCanvasWorker
(
)
{
auto
lockedCanvasThreadHolder
=
sCanvasThreadHolder
.
Lock
(
)
;
return
lockedCanvasThreadHolder
.
ref
(
)
&
&
lockedCanvasThreadHolder
.
ref
(
)
-
>
mCanvasWorkers
-
>
IsOnCurrentThread
(
)
;
}
bool
CanvasThreadHolder
:
:
IsInCanvasThreadOrWorker
(
)
{
auto
lockedCanvasThreadHolder
=
sCanvasThreadHolder
.
Lock
(
)
;
return
lockedCanvasThreadHolder
.
ref
(
)
&
&
(
lockedCanvasThreadHolder
.
ref
(
)
-
>
mCanvasWorkers
-
>
IsOnCurrentThread
(
)
|
|
lockedCanvasThreadHolder
.
ref
(
)
-
>
mCanvasThread
-
>
IsOnCurrentThread
(
)
)
;
}
void
CanvasThreadHolder
:
:
MaybeDispatchToCanvasThread
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
{
auto
lockedCanvasThreadHolder
=
sCanvasThreadHolder
.
Lock
(
)
;
if
(
!
lockedCanvasThreadHolder
.
ref
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
aRunnable
;
return
;
}
lockedCanvasThreadHolder
.
ref
(
)
-
>
mCanvasThread
-
>
Dispatch
(
std
:
:
move
(
aRunnable
)
)
;
}
void
CanvasThreadHolder
:
:
DispatchToCanvasThread
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
{
mCanvasThread
-
>
Dispatch
(
std
:
:
move
(
aRunnable
)
)
;
}
already_AddRefed
<
TaskQueue
>
CanvasThreadHolder
:
:
CreateWorkerTaskQueue
(
)
{
return
MakeAndAddRef
<
TaskQueue
>
(
do_AddRef
(
mCanvasWorkers
)
)
;
}
}
}
