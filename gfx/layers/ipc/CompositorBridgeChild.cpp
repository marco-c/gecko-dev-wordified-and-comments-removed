#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
<
stddef
.
h
>
#
include
"
ClientLayerManager
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
mozilla
/
layers
/
LayerTransactionChild
.
h
"
#
include
"
mozilla
/
layers
/
PLayerTransactionChild
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
layers
/
TextureClientPool
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
FrameLayerBuilder
.
h
"
#
include
"
mozilla
/
dom
/
TabChild
.
h
"
#
include
"
mozilla
/
unused
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
WinUtils
.
h
"
#
endif
#
include
"
mozilla
/
widget
/
CompositorWidget
.
h
"
#
ifdef
MOZ_WIDGET_SUPPORTS_OOP_COMPOSITING
#
include
"
mozilla
/
widget
/
CompositorWidgetChild
.
h
"
#
endif
using
mozilla
:
:
layers
:
:
LayerTransactionChild
;
using
mozilla
:
:
dom
:
:
TabChildBase
;
using
mozilla
:
:
Unused
;
namespace
mozilla
{
namespace
layers
{
static
StaticRefPtr
<
CompositorBridgeChild
>
sCompositorBridge
;
Atomic
<
int32_t
>
CompositableForwarder
:
:
sSerialCounter
(
0
)
;
CompositorBridgeChild
:
:
CompositorBridgeChild
(
ClientLayerManager
*
aLayerManager
)
:
TextureForwarder
(
"
CompositorBridgeChild
"
)
mLayerManager
(
aLayerManager
)
mCanSend
(
false
)
mFwdTransactionId
(
0
)
mMessageLoop
(
MessageLoop
:
:
current
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
SetMessageLoopToPostDestructionTo
(
mMessageLoop
)
;
}
CompositorBridgeChild
:
:
~
CompositorBridgeChild
(
)
{
if
(
mCanSend
)
{
gfxCriticalError
(
)
<
<
"
CompositorBridgeChild
was
not
deinitialized
"
;
}
}
bool
CompositorBridgeChild
:
:
IsSameProcess
(
)
const
{
return
OtherPid
(
)
=
=
base
:
:
GetCurrentProcId
(
)
;
}
static
void
DeferredDestroyCompositor
(
RefPtr
<
CompositorBridgeParent
>
aCompositorBridgeParent
RefPtr
<
CompositorBridgeChild
>
aCompositorBridgeChild
)
{
aCompositorBridgeChild
-
>
Close
(
)
;
if
(
sCompositorBridge
=
=
aCompositorBridgeChild
)
{
sCompositorBridge
=
nullptr
;
}
}
void
CompositorBridgeChild
:
:
Destroy
(
)
{
MOZ_ASSERT
(
!
IsDead
(
)
)
;
mTexturesWaitingRecycled
.
Clear
(
)
;
if
(
!
mCanSend
)
{
return
;
}
for
(
size_t
i
=
0
;
i
<
mTexturePools
.
Length
(
)
;
i
+
+
)
{
mTexturePools
[
i
]
-
>
Destroy
(
)
;
}
RefPtr
<
CompositorBridgeChild
>
selfRef
=
this
;
if
(
mLayerManager
)
{
mLayerManager
-
>
Destroy
(
)
;
mLayerManager
=
nullptr
;
}
AutoTArray
<
PLayerTransactionChild
*
16
>
transactions
;
ManagedPLayerTransactionChild
(
transactions
)
;
for
(
int
i
=
transactions
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
RefPtr
<
LayerTransactionChild
>
layers
=
static_cast
<
LayerTransactionChild
*
>
(
transactions
[
i
]
)
;
layers
-
>
Destroy
(
)
;
}
const
ManagedContainer
<
PTextureChild
>
&
textures
=
ManagedPTextureChild
(
)
;
for
(
auto
iter
=
textures
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
TextureClient
>
texture
=
TextureClient
:
:
AsTextureClient
(
iter
.
Get
(
)
-
>
GetKey
(
)
)
;
if
(
texture
)
{
texture
-
>
Destroy
(
)
;
}
}
SendWillClose
(
)
;
mCanSend
=
false
;
MessageLoop
:
:
current
(
)
-
>
PostTask
(
NewRunnableFunction
(
DeferredDestroyCompositor
mCompositorBridgeParent
selfRef
)
)
;
}
void
CompositorBridgeChild
:
:
ShutDown
(
)
{
if
(
sCompositorBridge
)
{
sCompositorBridge
-
>
Destroy
(
)
;
do
{
NS_ProcessNextEvent
(
nullptr
true
)
;
}
while
(
sCompositorBridge
)
;
}
}
bool
CompositorBridgeChild
:
:
LookupCompositorFrameMetrics
(
const
FrameMetrics
:
:
ViewID
aId
FrameMetrics
&
aFrame
)
{
SharedFrameMetricsData
*
data
=
mFrameMetricsTable
.
Get
(
aId
)
;
if
(
data
)
{
data
-
>
CopyFrameMetrics
(
&
aFrame
)
;
return
true
;
}
return
false
;
}
PCompositorBridgeChild
*
CompositorBridgeChild
:
:
Create
(
Transport
*
aTransport
ProcessId
aOtherPid
)
{
MOZ_ASSERT
(
!
sCompositorBridge
)
;
RefPtr
<
CompositorBridgeChild
>
child
(
new
CompositorBridgeChild
(
nullptr
)
)
;
if
(
!
child
-
>
Open
(
aTransport
aOtherPid
XRE_GetIOMessageLoop
(
)
ipc
:
:
ChildSide
)
)
{
NS_RUNTIMEABORT
(
"
Couldn
'
t
Open
(
)
Compositor
channel
.
"
)
;
return
nullptr
;
}
child
-
>
mCanSend
=
true
;
sCompositorBridge
=
child
;
int32_t
width
;
int32_t
height
;
sCompositorBridge
-
>
SendGetTileSize
(
&
width
&
height
)
;
gfxPlatform
:
:
GetPlatform
(
)
-
>
SetTileSize
(
width
height
)
;
return
sCompositorBridge
;
}
CompositorBridgeParent
*
CompositorBridgeChild
:
:
InitSameProcess
(
widget
:
:
CompositorWidget
*
aWidget
const
uint64_t
&
aLayerTreeId
CSSToLayoutDeviceScale
aScale
bool
aUseAPZ
bool
aUseExternalSurface
const
gfx
:
:
IntSize
&
aSurfaceSize
)
{
mCompositorBridgeParent
=
new
CompositorBridgeParent
(
aScale
aUseExternalSurface
aSurfaceSize
)
;
mCanSend
=
Open
(
mCompositorBridgeParent
-
>
GetIPCChannel
(
)
CompositorThreadHolder
:
:
Loop
(
)
ipc
:
:
ChildSide
)
;
MOZ_RELEASE_ASSERT
(
mCanSend
)
;
mCompositorBridgeParent
-
>
InitSameProcess
(
aWidget
aLayerTreeId
aUseAPZ
)
;
return
mCompositorBridgeParent
;
}
CompositorBridgeChild
*
CompositorBridgeChild
:
:
Get
(
)
{
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
return
sCompositorBridge
;
}
bool
CompositorBridgeChild
:
:
ChildProcessHasCompositorBridge
(
)
{
return
sCompositorBridge
!
=
nullptr
;
}
PLayerTransactionChild
*
CompositorBridgeChild
:
:
AllocPLayerTransactionChild
(
const
nsTArray
<
LayersBackend
>
&
aBackendHints
const
uint64_t
&
aId
TextureFactoryIdentifier
*
bool
*
)
{
MOZ_ASSERT
(
mCanSend
)
;
LayerTransactionChild
*
c
=
new
LayerTransactionChild
(
aId
)
;
c
-
>
AddIPDLReference
(
)
;
return
c
;
}
bool
CompositorBridgeChild
:
:
DeallocPLayerTransactionChild
(
PLayerTransactionChild
*
actor
)
{
uint64_t
childId
=
static_cast
<
LayerTransactionChild
*
>
(
actor
)
-
>
GetId
(
)
;
for
(
auto
iter
=
mFrameMetricsTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsAutoPtr
<
SharedFrameMetricsData
>
&
data
=
iter
.
Data
(
)
;
if
(
data
-
>
GetLayersId
(
)
=
=
childId
)
{
iter
.
Remove
(
)
;
}
}
static_cast
<
LayerTransactionChild
*
>
(
actor
)
-
>
ReleaseIPDLReference
(
)
;
return
true
;
}
bool
CompositorBridgeChild
:
:
RecvInvalidateLayers
(
const
uint64_t
&
aLayersId
)
{
if
(
mLayerManager
)
{
MOZ_ASSERT
(
aLayersId
=
=
0
)
;
FrameLayerBuilder
:
:
InvalidateAllLayers
(
mLayerManager
)
;
}
else
if
(
aLayersId
!
=
0
)
{
if
(
dom
:
:
TabChild
*
child
=
dom
:
:
TabChild
:
:
GetFrom
(
aLayersId
)
)
{
child
-
>
InvalidateLayers
(
)
;
}
}
return
true
;
}
bool
CompositorBridgeChild
:
:
RecvCompositorUpdated
(
const
uint64_t
&
aLayersId
const
TextureFactoryIdentifier
&
aNewIdentifier
)
{
if
(
mLayerManager
)
{
MOZ_ASSERT
(
aLayersId
=
=
0
)
;
}
else
if
(
aLayersId
!
=
0
)
{
if
(
dom
:
:
TabChild
*
child
=
dom
:
:
TabChild
:
:
GetFrom
(
aLayersId
)
)
{
child
-
>
CompositorUpdated
(
aNewIdentifier
)
;
}
SendAcknowledgeCompositorUpdate
(
aLayersId
)
;
}
return
true
;
}
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
static
void
CalculatePluginClip
(
const
LayoutDeviceIntRect
&
aBounds
const
nsTArray
<
LayoutDeviceIntRect
>
&
aPluginClipRects
const
LayoutDeviceIntPoint
&
aContentOffset
const
LayoutDeviceIntRegion
&
aParentLayerVisibleRegion
nsTArray
<
LayoutDeviceIntRect
>
&
aResult
LayoutDeviceIntRect
&
aVisibleBounds
bool
&
aPluginIsVisible
)
{
aPluginIsVisible
=
true
;
LayoutDeviceIntRegion
contentVisibleRegion
;
for
(
uint32_t
idx
=
0
;
idx
<
aPluginClipRects
.
Length
(
)
;
idx
+
+
)
{
LayoutDeviceIntRect
rect
=
aPluginClipRects
[
idx
]
;
rect
.
MoveBy
(
aBounds
.
x
aBounds
.
y
)
;
contentVisibleRegion
.
OrWith
(
rect
)
;
}
LayoutDeviceIntRegion
region
=
aParentLayerVisibleRegion
;
region
.
MoveBy
(
-
aContentOffset
.
x
-
aContentOffset
.
y
)
;
contentVisibleRegion
.
AndWith
(
region
)
;
if
(
contentVisibleRegion
.
IsEmpty
(
)
)
{
aPluginIsVisible
=
false
;
return
;
}
contentVisibleRegion
.
MoveBy
(
-
aBounds
.
x
-
aBounds
.
y
)
;
for
(
auto
iter
=
contentVisibleRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
LayoutDeviceIntRect
&
rect
=
iter
.
Get
(
)
;
aResult
.
AppendElement
(
rect
)
;
aVisibleBounds
.
UnionRect
(
aVisibleBounds
rect
)
;
}
}
#
endif
bool
CompositorBridgeChild
:
:
RecvUpdatePluginConfigurations
(
const
LayoutDeviceIntPoint
&
aContentOffset
const
LayoutDeviceIntRegion
&
aParentLayerVisibleRegion
nsTArray
<
PluginWindowData
>
&
&
aPlugins
)
{
#
if
!
defined
(
XP_WIN
)
&
&
!
defined
(
MOZ_WIDGET_GTK
)
NS_NOTREACHED
(
"
CompositorBridgeChild
:
:
RecvUpdatePluginConfigurations
calls
"
"
unexpected
on
this
platform
.
"
)
;
return
false
;
#
else
DebugOnly
<
nsresult
>
rv
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsTArray
<
uintptr_t
>
visiblePluginIds
;
nsIWidget
*
parent
=
nullptr
;
for
(
uint32_t
pluginsIdx
=
0
;
pluginsIdx
<
aPlugins
.
Length
(
)
;
pluginsIdx
+
+
)
{
nsIWidget
*
widget
=
nsIWidget
:
:
LookupRegisteredPluginWindow
(
aPlugins
[
pluginsIdx
]
.
windowId
(
)
)
;
if
(
!
widget
)
{
NS_WARNING
(
"
Unexpected
plugin
id
not
found
!
"
)
;
continue
;
}
if
(
!
parent
)
{
parent
=
widget
-
>
GetParent
(
)
;
}
bool
isVisible
=
aPlugins
[
pluginsIdx
]
.
visible
(
)
;
if
(
widget
&
&
!
widget
-
>
Destroyed
(
)
)
{
LayoutDeviceIntRect
bounds
;
LayoutDeviceIntRect
visibleBounds
;
if
(
isVisible
)
{
bounds
=
aPlugins
[
pluginsIdx
]
.
bounds
(
)
;
nsTArray
<
LayoutDeviceIntRect
>
rectsOut
;
CalculatePluginClip
(
bounds
aPlugins
[
pluginsIdx
]
.
clip
(
)
aContentOffset
aParentLayerVisibleRegion
rectsOut
visibleBounds
isVisible
)
;
rv
=
widget
-
>
SetWindowClipRegion
(
rectsOut
false
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
widget
call
failure
"
)
;
rv
=
widget
-
>
Resize
(
aContentOffset
.
x
+
bounds
.
x
aContentOffset
.
y
+
bounds
.
y
bounds
.
width
bounds
.
height
true
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
widget
call
failure
"
)
;
}
rv
=
widget
-
>
Enable
(
isVisible
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
widget
call
failure
"
)
;
rv
=
widget
-
>
Show
(
isVisible
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
widget
call
failure
"
)
;
if
(
isVisible
)
{
#
if
defined
(
XP_WIN
)
mozilla
:
:
widget
:
:
WinUtils
:
:
InvalidatePluginAsWorkaround
(
widget
visibleBounds
)
;
#
else
rv
=
widget
-
>
Invalidate
(
visibleBounds
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
widget
call
failure
"
)
;
#
endif
visiblePluginIds
.
AppendElement
(
aPlugins
[
pluginsIdx
]
.
windowId
(
)
)
;
}
}
}
nsIWidget
:
:
UpdateRegisteredPluginWindowVisibility
(
(
uintptr_t
)
parent
visiblePluginIds
)
;
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
SendRemotePluginsReady
(
)
;
#
endif
return
true
;
#
endif
}
bool
CompositorBridgeChild
:
:
RecvHideAllPlugins
(
const
uintptr_t
&
aParentWidget
)
{
#
if
!
defined
(
XP_WIN
)
&
&
!
defined
(
MOZ_WIDGET_GTK
)
NS_NOTREACHED
(
"
CompositorBridgeChild
:
:
RecvHideAllPlugins
calls
"
"
unexpected
on
this
platform
.
"
)
;
return
false
;
#
else
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsTArray
<
uintptr_t
>
list
;
nsIWidget
:
:
UpdateRegisteredPluginWindowVisibility
(
aParentWidget
list
)
;
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
SendRemotePluginsReady
(
)
;
#
endif
return
true
;
#
endif
}
bool
CompositorBridgeChild
:
:
RecvDidComposite
(
const
uint64_t
&
aId
const
uint64_t
&
aTransactionId
const
TimeStamp
&
aCompositeStart
const
TimeStamp
&
aCompositeEnd
)
{
if
(
mLayerManager
)
{
MOZ_ASSERT
(
aId
=
=
0
)
;
RefPtr
<
ClientLayerManager
>
m
=
mLayerManager
;
m
-
>
DidComposite
(
aTransactionId
aCompositeStart
aCompositeEnd
)
;
}
else
if
(
aId
!
=
0
)
{
RefPtr
<
dom
:
:
TabChild
>
child
=
dom
:
:
TabChild
:
:
GetFrom
(
aId
)
;
if
(
child
)
{
child
-
>
DidComposite
(
aTransactionId
aCompositeStart
aCompositeEnd
)
;
}
}
for
(
size_t
i
=
0
;
i
<
mTexturePools
.
Length
(
)
;
i
+
+
)
{
mTexturePools
[
i
]
-
>
ReturnDeferredClients
(
)
;
}
return
true
;
}
bool
CompositorBridgeChild
:
:
RecvOverfill
(
const
uint32_t
&
aOverfill
)
{
for
(
size_t
i
=
0
;
i
<
mOverfillObservers
.
Length
(
)
;
i
+
+
)
{
mOverfillObservers
[
i
]
-
>
RunOverfillCallback
(
aOverfill
)
;
}
mOverfillObservers
.
Clear
(
)
;
return
true
;
}
void
CompositorBridgeChild
:
:
AddOverfillObserver
(
ClientLayerManager
*
aLayerManager
)
{
MOZ_ASSERT
(
aLayerManager
)
;
mOverfillObservers
.
AppendElement
(
aLayerManager
)
;
}
bool
CompositorBridgeChild
:
:
RecvClearCachedResources
(
const
uint64_t
&
aId
)
{
dom
:
:
TabChild
*
child
=
dom
:
:
TabChild
:
:
GetFrom
(
aId
)
;
if
(
child
)
{
child
-
>
ClearCachedResources
(
)
;
}
return
true
;
}
void
CompositorBridgeChild
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
if
(
aWhy
=
=
AbnormalShutdown
)
{
#
ifdef
MOZ_B2G
NS_RUNTIMEABORT
(
"
ActorDestroy
by
IPC
channel
failure
at
CompositorBridgeChild
"
)
;
#
endif
mCanSend
=
false
;
gfxCriticalNote
<
<
"
Receive
IPC
close
with
reason
=
AbnormalShutdown
"
;
}
}
bool
CompositorBridgeChild
:
:
RecvSharedCompositorFrameMetrics
(
const
mozilla
:
:
ipc
:
:
SharedMemoryBasic
:
:
Handle
&
metrics
const
CrossProcessMutexHandle
&
handle
const
uint64_t
&
aLayersId
const
uint32_t
&
aAPZCId
)
{
SharedFrameMetricsData
*
data
=
new
SharedFrameMetricsData
(
metrics
handle
aLayersId
aAPZCId
)
;
mFrameMetricsTable
.
Put
(
data
-
>
GetViewID
(
)
data
)
;
return
true
;
}
bool
CompositorBridgeChild
:
:
RecvReleaseSharedCompositorFrameMetrics
(
const
ViewID
&
aId
const
uint32_t
&
aAPZCId
)
{
SharedFrameMetricsData
*
data
=
mFrameMetricsTable
.
Get
(
aId
)
;
if
(
data
&
&
(
data
-
>
GetAPZCId
(
)
=
=
aAPZCId
)
)
{
mFrameMetricsTable
.
Remove
(
aId
)
;
}
return
true
;
}
CompositorBridgeChild
:
:
SharedFrameMetricsData
:
:
SharedFrameMetricsData
(
const
ipc
:
:
SharedMemoryBasic
:
:
Handle
&
metrics
const
CrossProcessMutexHandle
&
handle
const
uint64_t
&
aLayersId
const
uint32_t
&
aAPZCId
)
:
mMutex
(
nullptr
)
mLayersId
(
aLayersId
)
mAPZCId
(
aAPZCId
)
{
mBuffer
=
new
ipc
:
:
SharedMemoryBasic
;
mBuffer
-
>
SetHandle
(
metrics
)
;
mBuffer
-
>
Map
(
sizeof
(
FrameMetrics
)
)
;
mMutex
=
new
CrossProcessMutex
(
handle
)
;
MOZ_COUNT_CTOR
(
SharedFrameMetricsData
)
;
}
CompositorBridgeChild
:
:
SharedFrameMetricsData
:
:
~
SharedFrameMetricsData
(
)
{
delete
mMutex
;
mBuffer
=
nullptr
;
MOZ_COUNT_DTOR
(
SharedFrameMetricsData
)
;
}
void
CompositorBridgeChild
:
:
SharedFrameMetricsData
:
:
CopyFrameMetrics
(
FrameMetrics
*
aFrame
)
{
FrameMetrics
*
frame
=
static_cast
<
FrameMetrics
*
>
(
mBuffer
-
>
memory
(
)
)
;
MOZ_ASSERT
(
frame
)
;
mMutex
-
>
Lock
(
)
;
*
aFrame
=
*
frame
;
mMutex
-
>
Unlock
(
)
;
}
FrameMetrics
:
:
ViewID
CompositorBridgeChild
:
:
SharedFrameMetricsData
:
:
GetViewID
(
)
{
FrameMetrics
*
frame
=
static_cast
<
FrameMetrics
*
>
(
mBuffer
-
>
memory
(
)
)
;
MOZ_ASSERT
(
frame
)
;
return
frame
-
>
GetScrollId
(
)
;
}
uint64_t
CompositorBridgeChild
:
:
SharedFrameMetricsData
:
:
GetLayersId
(
)
const
{
return
mLayersId
;
}
uint32_t
CompositorBridgeChild
:
:
SharedFrameMetricsData
:
:
GetAPZCId
(
)
{
return
mAPZCId
;
}
bool
CompositorBridgeChild
:
:
RecvRemotePaintIsReady
(
)
{
MOZ_LAYERS_LOG
(
(
"
[
RemoteGfx
]
CompositorBridgeChild
received
RemotePaintIsReady
"
)
)
;
RefPtr
<
nsISupports
>
iTabChildBase
(
do_QueryReferent
(
mWeakTabChild
)
)
;
if
(
!
iTabChildBase
)
{
MOZ_LAYERS_LOG
(
(
"
[
RemoteGfx
]
Note
:
TabChild
was
released
before
RemotePaintIsReady
.
"
"
MozAfterRemotePaint
will
not
be
sent
to
listener
.
"
)
)
;
return
true
;
}
TabChildBase
*
tabChildBase
=
static_cast
<
TabChildBase
*
>
(
iTabChildBase
.
get
(
)
)
;
TabChild
*
tabChild
=
static_cast
<
TabChild
*
>
(
tabChildBase
)
;
MOZ_ASSERT
(
tabChild
)
;
Unused
<
<
tabChild
-
>
SendRemotePaintIsReady
(
)
;
mWeakTabChild
=
nullptr
;
return
true
;
}
void
CompositorBridgeChild
:
:
RequestNotifyAfterRemotePaint
(
TabChild
*
aTabChild
)
{
MOZ_ASSERT
(
aTabChild
"
NULL
TabChild
not
allowed
in
CompositorBridgeChild
:
:
RequestNotifyAfterRemotePaint
"
)
;
mWeakTabChild
=
do_GetWeakReference
(
static_cast
<
dom
:
:
TabChildBase
*
>
(
aTabChild
)
)
;
Unused
<
<
SendRequestNotifyAfterRemotePaint
(
)
;
}
void
CompositorBridgeChild
:
:
CancelNotifyAfterRemotePaint
(
TabChild
*
aTabChild
)
{
RefPtr
<
nsISupports
>
iTabChildBase
(
do_QueryReferent
(
mWeakTabChild
)
)
;
if
(
!
iTabChildBase
)
{
return
;
}
TabChildBase
*
tabChildBase
=
static_cast
<
TabChildBase
*
>
(
iTabChildBase
.
get
(
)
)
;
TabChild
*
tabChild
=
static_cast
<
TabChild
*
>
(
tabChildBase
)
;
if
(
tabChild
=
=
aTabChild
)
{
mWeakTabChild
=
nullptr
;
}
}
bool
CompositorBridgeChild
:
:
SendWillClose
(
)
{
MOZ_ASSERT
(
mCanSend
)
;
if
(
!
mCanSend
)
{
return
true
;
}
return
PCompositorBridgeChild
:
:
SendWillClose
(
)
;
}
bool
CompositorBridgeChild
:
:
SendPause
(
)
{
MOZ_ASSERT
(
mCanSend
)
;
if
(
!
mCanSend
)
{
return
true
;
}
return
PCompositorBridgeChild
:
:
SendPause
(
)
;
}
bool
CompositorBridgeChild
:
:
SendResume
(
)
{
MOZ_ASSERT
(
mCanSend
)
;
if
(
!
mCanSend
)
{
return
true
;
}
return
PCompositorBridgeChild
:
:
SendResume
(
)
;
}
bool
CompositorBridgeChild
:
:
SendNotifyHidden
(
const
uint64_t
&
id
)
{
MOZ_ASSERT
(
mCanSend
)
;
if
(
!
mCanSend
)
{
return
true
;
}
return
PCompositorBridgeChild
:
:
SendNotifyHidden
(
id
)
;
}
bool
CompositorBridgeChild
:
:
SendNotifyVisible
(
const
uint64_t
&
id
)
{
MOZ_ASSERT
(
mCanSend
)
;
if
(
!
mCanSend
)
{
return
true
;
}
return
PCompositorBridgeChild
:
:
SendNotifyVisible
(
id
)
;
}
bool
CompositorBridgeChild
:
:
SendNotifyChildCreated
(
const
uint64_t
&
id
)
{
MOZ_ASSERT
(
mCanSend
)
;
if
(
!
mCanSend
)
{
return
true
;
}
return
PCompositorBridgeChild
:
:
SendNotifyChildCreated
(
id
)
;
}
bool
CompositorBridgeChild
:
:
SendAdoptChild
(
const
uint64_t
&
id
)
{
MOZ_ASSERT
(
mCanSend
)
;
if
(
!
mCanSend
)
{
return
true
;
}
return
PCompositorBridgeChild
:
:
SendAdoptChild
(
id
)
;
}
bool
CompositorBridgeChild
:
:
SendMakeSnapshot
(
const
SurfaceDescriptor
&
inSnapshot
const
gfx
:
:
IntRect
&
dirtyRect
)
{
MOZ_ASSERT
(
mCanSend
)
;
if
(
!
mCanSend
)
{
return
true
;
}
return
PCompositorBridgeChild
:
:
SendMakeSnapshot
(
inSnapshot
dirtyRect
)
;
}
bool
CompositorBridgeChild
:
:
SendFlushRendering
(
)
{
MOZ_ASSERT
(
mCanSend
)
;
if
(
!
mCanSend
)
{
return
true
;
}
return
PCompositorBridgeChild
:
:
SendFlushRendering
(
)
;
}
bool
CompositorBridgeChild
:
:
SendGetTileSize
(
int32_t
*
tileWidth
int32_t
*
tileHeight
)
{
MOZ_ASSERT
(
mCanSend
)
;
if
(
!
mCanSend
)
{
return
true
;
}
return
PCompositorBridgeChild
:
:
SendGetTileSize
(
tileWidth
tileHeight
)
;
}
bool
CompositorBridgeChild
:
:
SendStartFrameTimeRecording
(
const
int32_t
&
bufferSize
uint32_t
*
startIndex
)
{
MOZ_ASSERT
(
mCanSend
)
;
if
(
!
mCanSend
)
{
return
true
;
}
return
PCompositorBridgeChild
:
:
SendStartFrameTimeRecording
(
bufferSize
startIndex
)
;
}
bool
CompositorBridgeChild
:
:
SendStopFrameTimeRecording
(
const
uint32_t
&
startIndex
nsTArray
<
float
>
*
intervals
)
{
MOZ_ASSERT
(
mCanSend
)
;
if
(
!
mCanSend
)
{
return
true
;
}
return
PCompositorBridgeChild
:
:
SendStopFrameTimeRecording
(
startIndex
intervals
)
;
}
bool
CompositorBridgeChild
:
:
SendNotifyRegionInvalidated
(
const
nsIntRegion
&
region
)
{
MOZ_ASSERT
(
mCanSend
)
;
if
(
!
mCanSend
)
{
return
true
;
}
return
PCompositorBridgeChild
:
:
SendNotifyRegionInvalidated
(
region
)
;
}
bool
CompositorBridgeChild
:
:
SendRequestNotifyAfterRemotePaint
(
)
{
MOZ_ASSERT
(
mCanSend
)
;
if
(
!
mCanSend
)
{
return
true
;
}
return
PCompositorBridgeChild
:
:
SendRequestNotifyAfterRemotePaint
(
)
;
}
bool
CompositorBridgeChild
:
:
SendClearVisibleRegions
(
uint64_t
aLayersId
uint32_t
aPresShellId
)
{
MOZ_ASSERT
(
mCanSend
)
;
if
(
!
mCanSend
)
{
return
true
;
}
return
PCompositorBridgeChild
:
:
SendClearVisibleRegions
(
aLayersId
aPresShellId
)
;
}
bool
CompositorBridgeChild
:
:
SendUpdateVisibleRegion
(
VisibilityCounter
aCounter
const
ScrollableLayerGuid
&
aGuid
const
CSSIntRegion
&
aRegion
)
{
MOZ_ASSERT
(
mCanSend
)
;
if
(
!
mCanSend
)
{
return
true
;
}
return
PCompositorBridgeChild
:
:
SendUpdateVisibleRegion
(
aCounter
aGuid
aRegion
)
;
}
PTextureChild
*
CompositorBridgeChild
:
:
AllocPTextureChild
(
const
SurfaceDescriptor
&
const
LayersBackend
&
const
TextureFlags
&
const
uint64_t
&
const
uint64_t
&
aSerial
)
{
return
TextureClient
:
:
CreateIPDLActor
(
)
;
}
bool
CompositorBridgeChild
:
:
DeallocPTextureChild
(
PTextureChild
*
actor
)
{
return
TextureClient
:
:
DestroyIPDLActor
(
actor
)
;
}
bool
CompositorBridgeChild
:
:
RecvParentAsyncMessages
(
InfallibleTArray
<
AsyncParentMessageData
>
&
&
aMessages
)
{
for
(
AsyncParentMessageArray
:
:
index_type
i
=
0
;
i
<
aMessages
.
Length
(
)
;
+
+
i
)
{
const
AsyncParentMessageData
&
message
=
aMessages
[
i
]
;
switch
(
message
.
type
(
)
)
{
case
AsyncParentMessageData
:
:
TOpDeliverFence
:
{
const
OpDeliverFence
&
op
=
message
.
get_OpDeliverFence
(
)
;
FenceHandle
fence
=
op
.
fence
(
)
;
DeliverFence
(
op
.
TextureId
(
)
fence
)
;
break
;
}
case
AsyncParentMessageData
:
:
TOpNotifyNotUsed
:
{
const
OpNotifyNotUsed
&
op
=
message
.
get_OpNotifyNotUsed
(
)
;
NotifyNotUsed
(
op
.
TextureId
(
)
op
.
fwdTransactionId
(
)
)
;
break
;
}
default
:
NS_ERROR
(
"
unknown
AsyncParentMessageData
type
"
)
;
return
false
;
}
}
return
true
;
}
void
CompositorBridgeChild
:
:
HoldUntilCompositableRefReleasedIfNecessary
(
TextureClient
*
aClient
)
{
if
(
!
aClient
)
{
return
;
}
if
(
!
(
aClient
-
>
GetFlags
(
)
&
TextureFlags
:
:
RECYCLE
)
&
&
!
aClient
-
>
NeedsFenceHandle
(
)
)
{
return
;
}
if
(
aClient
-
>
GetFlags
(
)
&
TextureFlags
:
:
RECYCLE
)
{
aClient
-
>
SetLastFwdTransactionId
(
GetFwdTransactionId
(
)
)
;
mTexturesWaitingRecycled
.
Put
(
aClient
-
>
GetSerial
(
)
aClient
)
;
return
;
}
MOZ_ASSERT
(
!
(
aClient
-
>
GetFlags
(
)
&
TextureFlags
:
:
RECYCLE
)
)
;
MOZ_ASSERT
(
aClient
-
>
NeedsFenceHandle
(
)
)
;
ImageBridgeChild
:
:
GetSingleton
(
)
-
>
HoldUntilFenceHandleDelivery
(
aClient
GetFwdTransactionId
(
)
)
;
}
void
CompositorBridgeChild
:
:
NotifyNotUsed
(
uint64_t
aTextureId
uint64_t
aFwdTransactionId
)
{
RefPtr
<
TextureClient
>
client
=
mTexturesWaitingRecycled
.
Get
(
aTextureId
)
;
if
(
!
client
)
{
return
;
}
if
(
aFwdTransactionId
<
client
-
>
GetLastFwdTransactionId
(
)
)
{
return
;
}
mTexturesWaitingRecycled
.
Remove
(
aTextureId
)
;
}
void
CompositorBridgeChild
:
:
DeliverFence
(
uint64_t
aTextureId
FenceHandle
&
aReleaseFenceHandle
)
{
RefPtr
<
TextureClient
>
client
=
mTexturesWaitingRecycled
.
Get
(
aTextureId
)
;
if
(
!
client
)
{
return
;
}
client
-
>
SetReleaseFenceHandle
(
aReleaseFenceHandle
)
;
}
void
CompositorBridgeChild
:
:
CancelWaitForRecycle
(
uint64_t
aTextureId
)
{
RefPtr
<
TextureClient
>
client
=
mTexturesWaitingRecycled
.
Get
(
aTextureId
)
;
if
(
!
client
)
{
return
;
}
mTexturesWaitingRecycled
.
Remove
(
aTextureId
)
;
}
TextureClientPool
*
CompositorBridgeChild
:
:
GetTexturePool
(
LayersBackend
aBackend
SurfaceFormat
aFormat
TextureFlags
aFlags
)
{
for
(
size_t
i
=
0
;
i
<
mTexturePools
.
Length
(
)
;
i
+
+
)
{
if
(
mTexturePools
[
i
]
-
>
GetBackend
(
)
=
=
aBackend
&
&
mTexturePools
[
i
]
-
>
GetFormat
(
)
=
=
aFormat
&
&
mTexturePools
[
i
]
-
>
GetFlags
(
)
=
=
aFlags
)
{
return
mTexturePools
[
i
]
;
}
}
mTexturePools
.
AppendElement
(
new
TextureClientPool
(
aBackend
aFormat
IntSize
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetTileWidth
(
)
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetTileHeight
(
)
)
aFlags
gfxPrefs
:
:
LayersTileMaxPoolSize
(
)
gfxPrefs
:
:
LayersTileShrinkPoolTimeout
(
)
this
)
)
;
return
mTexturePools
.
LastElement
(
)
;
}
void
CompositorBridgeChild
:
:
HandleMemoryPressure
(
)
{
for
(
size_t
i
=
0
;
i
<
mTexturePools
.
Length
(
)
;
i
+
+
)
{
mTexturePools
[
i
]
-
>
ShrinkToMinimumSize
(
)
;
}
}
void
CompositorBridgeChild
:
:
ClearTexturePool
(
)
{
for
(
size_t
i
=
0
;
i
<
mTexturePools
.
Length
(
)
;
i
+
+
)
{
mTexturePools
[
i
]
-
>
Clear
(
)
;
}
}
PTextureChild
*
CompositorBridgeChild
:
:
CreateTexture
(
const
SurfaceDescriptor
&
aSharedData
LayersBackend
aLayersBackend
TextureFlags
aFlags
uint64_t
aSerial
)
{
return
PCompositorBridgeChild
:
:
SendPTextureConstructor
(
aSharedData
aLayersBackend
aFlags
0
aSerial
)
;
}
bool
CompositorBridgeChild
:
:
AllocUnsafeShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
return
PCompositorBridgeChild
:
:
AllocUnsafeShmem
(
aSize
aType
aShmem
)
;
}
bool
CompositorBridgeChild
:
:
AllocShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
return
PCompositorBridgeChild
:
:
AllocShmem
(
aSize
aType
aShmem
)
;
}
void
CompositorBridgeChild
:
:
DeallocShmem
(
ipc
:
:
Shmem
&
aShmem
)
{
PCompositorBridgeChild
:
:
DeallocShmem
(
aShmem
)
;
}
widget
:
:
PCompositorWidgetChild
*
CompositorBridgeChild
:
:
AllocPCompositorWidgetChild
(
const
CompositorWidgetInitData
&
aInitData
)
{
MOZ_CRASH
(
"
Should
not
be
called
"
)
;
return
nullptr
;
}
bool
CompositorBridgeChild
:
:
DeallocPCompositorWidgetChild
(
PCompositorWidgetChild
*
aActor
)
{
#
ifdef
MOZ_WIDGET_SUPPORTS_OOP_COMPOSITING
delete
aActor
;
return
true
;
#
else
return
false
;
#
endif
}
void
CompositorBridgeChild
:
:
ProcessingError
(
Result
aCode
const
char
*
aReason
)
{
MOZ_CRASH
(
"
Processing
error
in
CompositorBridgeChild
"
)
;
}
}
}
