#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
<
stddef
.
h
>
#
include
"
ClientLayerManager
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
mozilla
/
dom
/
TabGroup
.
h
"
#
include
"
mozilla
/
layers
/
CompositorManagerChild
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
APZChild
.
h
"
#
include
"
mozilla
/
layers
/
IAPZCTreeManager
.
h
"
#
include
"
mozilla
/
layers
/
APZCTreeManagerChild
.
h
"
#
include
"
mozilla
/
layers
/
LayerTransactionChild
.
h
"
#
include
"
mozilla
/
layers
/
PaintThread
.
h
"
#
include
"
mozilla
/
layers
/
PLayerTransactionChild
.
h
"
#
include
"
mozilla
/
layers
/
PTextureChild
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
layers
/
TextureClientPool
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
SyncObject
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessManager
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
FrameLayerBuilder
.
h
"
#
include
"
mozilla
/
dom
/
TabChild
.
h
"
#
include
"
mozilla
/
dom
/
TabParent
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
WinUtils
.
h
"
#
endif
#
include
"
mozilla
/
widget
/
CompositorWidget
.
h
"
#
ifdef
MOZ_WIDGET_SUPPORTS_OOP_COMPOSITING
#
include
"
mozilla
/
widget
/
CompositorWidgetChild
.
h
"
#
endif
#
include
"
VsyncSource
.
h
"
using
mozilla
:
:
Unused
;
using
mozilla
:
:
dom
:
:
TabChildBase
;
using
mozilla
:
:
gfx
:
:
GPUProcessManager
;
using
mozilla
:
:
layers
:
:
LayerTransactionChild
;
namespace
mozilla
{
namespace
layers
{
static
int
sShmemCreationCounter
=
0
;
static
void
ResetShmemCounter
(
)
{
sShmemCreationCounter
=
0
;
}
static
void
ShmemAllocated
(
CompositorBridgeChild
*
aProtocol
)
{
sShmemCreationCounter
+
+
;
if
(
sShmemCreationCounter
>
256
)
{
aProtocol
-
>
SendSyncWithCompositor
(
)
;
ResetShmemCounter
(
)
;
MOZ_PERFORMANCE_WARNING
(
"
gfx
"
"
The
number
of
shmem
allocations
is
too
damn
high
!
"
)
;
}
}
static
StaticRefPtr
<
CompositorBridgeChild
>
sCompositorBridge
;
Atomic
<
int32_t
>
KnowsCompositor
:
:
sSerialCounter
(
0
)
;
CompositorBridgeChild
:
:
CompositorBridgeChild
(
CompositorManagerChild
*
aManager
)
:
mCompositorManager
(
aManager
)
mIdNamespace
(
0
)
mResourceId
(
0
)
mCanSend
(
false
)
mActorDestroyed
(
false
)
mFwdTransactionId
(
0
)
mMessageLoop
(
MessageLoop
:
:
current
(
)
)
mProcessToken
(
0
)
mSectionAllocator
(
nullptr
)
mPaintLock
(
"
CompositorBridgeChild
.
mPaintLock
"
)
mTotalAsyncPaints
(
0
)
mOutstandingAsyncPaints
(
0
)
mOutstandingAsyncEndTransaction
(
false
)
mIsDelayingForAsyncPaints
(
false
)
mSlowFlushCount
(
0
)
mTotalFlushCount
(
0
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
CompositorBridgeChild
:
:
~
CompositorBridgeChild
(
)
{
if
(
mCanSend
)
{
gfxCriticalError
(
)
<
<
"
CompositorBridgeChild
was
not
deinitialized
"
;
}
}
bool
CompositorBridgeChild
:
:
IsSameProcess
(
)
const
{
return
OtherPid
(
)
=
=
base
:
:
GetCurrentProcId
(
)
;
}
void
CompositorBridgeChild
:
:
PrepareFinalDestroy
(
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
NewRunnableMethod
(
"
CompositorBridgeChild
:
:
AfterDestroy
"
this
&
CompositorBridgeChild
:
:
AfterDestroy
)
;
NS_DispatchToCurrentThreadQueue
(
runnable
.
forget
(
)
EventQueuePriority
:
:
High
)
;
}
void
CompositorBridgeChild
:
:
AfterDestroy
(
)
{
if
(
!
mActorDestroyed
)
{
Send__delete__
(
this
)
;
mActorDestroyed
=
true
;
}
if
(
sCompositorBridge
=
=
this
)
{
sCompositorBridge
=
nullptr
;
}
}
void
CompositorBridgeChild
:
:
Destroy
(
)
{
mTexturesWaitingRecycled
.
clear
(
)
;
RefPtr
<
CompositorBridgeChild
>
selfRef
=
this
;
for
(
size_t
i
=
0
;
i
<
mTexturePools
.
Length
(
)
;
i
+
+
)
{
mTexturePools
[
i
]
-
>
Destroy
(
)
;
}
if
(
mSectionAllocator
)
{
delete
mSectionAllocator
;
mSectionAllocator
=
nullptr
;
}
if
(
mLayerManager
)
{
mLayerManager
-
>
Destroy
(
)
;
mLayerManager
=
nullptr
;
}
FlushAsyncPaints
(
)
;
if
(
!
mCanSend
)
{
MessageLoop
:
:
current
(
)
-
>
PostTask
(
NewRunnableMethod
(
"
CompositorBridgeChild
:
:
PrepareFinalDestroy
"
selfRef
&
CompositorBridgeChild
:
:
PrepareFinalDestroy
)
)
;
return
;
}
AutoTArray
<
PLayerTransactionChild
*
16
>
transactions
;
ManagedPLayerTransactionChild
(
transactions
)
;
for
(
int
i
=
transactions
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
RefPtr
<
LayerTransactionChild
>
layers
=
static_cast
<
LayerTransactionChild
*
>
(
transactions
[
i
]
)
;
layers
-
>
Destroy
(
)
;
}
AutoTArray
<
PWebRenderBridgeChild
*
16
>
wrBridges
;
ManagedPWebRenderBridgeChild
(
wrBridges
)
;
for
(
int
i
=
wrBridges
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
RefPtr
<
WebRenderBridgeChild
>
wrBridge
=
static_cast
<
WebRenderBridgeChild
*
>
(
wrBridges
[
i
]
)
;
wrBridge
-
>
Destroy
(
false
)
;
}
const
ManagedContainer
<
PTextureChild
>
&
textures
=
ManagedPTextureChild
(
)
;
for
(
auto
iter
=
textures
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
TextureClient
>
texture
=
TextureClient
:
:
AsTextureClient
(
iter
.
Get
(
)
-
>
GetKey
(
)
)
;
if
(
texture
)
{
texture
-
>
Destroy
(
)
;
}
}
SendWillClose
(
)
;
mCanSend
=
false
;
mProcessToken
=
0
;
MessageLoop
:
:
current
(
)
-
>
PostTask
(
NewRunnableMethod
(
"
CompositorBridgeChild
:
:
PrepareFinalDestroy
"
selfRef
&
CompositorBridgeChild
:
:
PrepareFinalDestroy
)
)
;
}
void
CompositorBridgeChild
:
:
ShutDown
(
)
{
if
(
sCompositorBridge
)
{
sCompositorBridge
-
>
Destroy
(
)
;
SpinEventLoopUntil
(
[
&
]
(
)
{
return
!
sCompositorBridge
;
}
)
;
}
}
bool
CompositorBridgeChild
:
:
LookupCompositorFrameMetrics
(
const
ScrollableLayerGuid
:
:
ViewID
aId
FrameMetrics
&
aFrame
)
{
SharedFrameMetricsData
*
data
=
mFrameMetricsTable
.
Get
(
aId
)
;
if
(
data
)
{
data
-
>
CopyFrameMetrics
(
&
aFrame
)
;
return
true
;
}
return
false
;
}
void
CompositorBridgeChild
:
:
InitForContent
(
uint32_t
aNamespace
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aNamespace
)
;
if
(
RefPtr
<
CompositorBridgeChild
>
old
=
sCompositorBridge
.
forget
(
)
)
{
old
-
>
Destroy
(
)
;
}
mCanSend
=
true
;
mIdNamespace
=
aNamespace
;
sCompositorBridge
=
this
;
}
void
CompositorBridgeChild
:
:
InitForWidget
(
uint64_t
aProcessToken
LayerManager
*
aLayerManager
uint32_t
aNamespace
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aProcessToken
)
;
MOZ_ASSERT
(
aLayerManager
)
;
MOZ_ASSERT
(
aNamespace
)
;
mCanSend
=
true
;
mProcessToken
=
aProcessToken
;
mLayerManager
=
aLayerManager
;
mIdNamespace
=
aNamespace
;
}
CompositorBridgeChild
*
CompositorBridgeChild
:
:
Get
(
)
{
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
return
sCompositorBridge
;
}
bool
CompositorBridgeChild
:
:
ChildProcessHasCompositorBridge
(
)
{
return
sCompositorBridge
!
=
nullptr
;
}
bool
CompositorBridgeChild
:
:
CompositorIsInGPUProcess
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
XRE_IsParentProcess
(
)
)
{
return
!
!
GPUProcessManager
:
:
Get
(
)
-
>
GetGPUChild
(
)
;
}
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
CompositorBridgeChild
*
bridge
=
CompositorBridgeChild
:
:
Get
(
)
;
if
(
!
bridge
)
{
return
false
;
}
return
bridge
-
>
OtherPid
(
)
!
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
OtherPid
(
)
;
}
PLayerTransactionChild
*
CompositorBridgeChild
:
:
AllocPLayerTransactionChild
(
const
nsTArray
<
LayersBackend
>
&
aBackendHints
const
LayersId
&
aId
)
{
LayerTransactionChild
*
c
=
new
LayerTransactionChild
(
aId
)
;
c
-
>
AddIPDLReference
(
)
;
TabChild
*
tabChild
=
TabChild
:
:
GetFrom
(
c
-
>
GetId
(
)
)
;
if
(
tabChild
)
{
nsCOMPtr
<
nsIEventTarget
>
target
=
tabChild
-
>
TabGroup
(
)
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
;
SetEventTargetForActor
(
c
target
)
;
MOZ_ASSERT
(
c
-
>
GetActorEventTarget
(
)
)
;
}
return
c
;
}
bool
CompositorBridgeChild
:
:
DeallocPLayerTransactionChild
(
PLayerTransactionChild
*
actor
)
{
LayersId
childId
=
static_cast
<
LayerTransactionChild
*
>
(
actor
)
-
>
GetId
(
)
;
ClearSharedFrameMetricsData
(
childId
)
;
static_cast
<
LayerTransactionChild
*
>
(
actor
)
-
>
ReleaseIPDLReference
(
)
;
return
true
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvInvalidateLayers
(
const
LayersId
&
aLayersId
)
{
if
(
mLayerManager
)
{
MOZ_ASSERT
(
!
aLayersId
.
IsValid
(
)
)
;
FrameLayerBuilder
:
:
InvalidateAllLayers
(
mLayerManager
)
;
}
else
if
(
aLayersId
.
IsValid
(
)
)
{
if
(
dom
:
:
TabChild
*
child
=
dom
:
:
TabChild
:
:
GetFrom
(
aLayersId
)
)
{
child
-
>
InvalidateLayers
(
)
;
}
}
return
IPC_OK
(
)
;
}
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
static
void
CalculatePluginClip
(
const
LayoutDeviceIntRect
&
aBounds
const
nsTArray
<
LayoutDeviceIntRect
>
&
aPluginClipRects
const
LayoutDeviceIntPoint
&
aContentOffset
const
LayoutDeviceIntRegion
&
aParentLayerVisibleRegion
nsTArray
<
LayoutDeviceIntRect
>
&
aResult
LayoutDeviceIntRect
&
aVisibleBounds
bool
&
aPluginIsVisible
)
{
aPluginIsVisible
=
true
;
LayoutDeviceIntRegion
contentVisibleRegion
;
for
(
uint32_t
idx
=
0
;
idx
<
aPluginClipRects
.
Length
(
)
;
idx
+
+
)
{
LayoutDeviceIntRect
rect
=
aPluginClipRects
[
idx
]
;
rect
.
MoveBy
(
aBounds
.
X
(
)
aBounds
.
Y
(
)
)
;
contentVisibleRegion
.
OrWith
(
rect
)
;
}
LayoutDeviceIntRegion
region
=
aParentLayerVisibleRegion
;
region
.
MoveBy
(
-
aContentOffset
.
x
-
aContentOffset
.
y
)
;
contentVisibleRegion
.
AndWith
(
region
)
;
if
(
contentVisibleRegion
.
IsEmpty
(
)
)
{
aPluginIsVisible
=
false
;
return
;
}
contentVisibleRegion
.
MoveBy
(
-
aBounds
.
X
(
)
-
aBounds
.
Y
(
)
)
;
for
(
auto
iter
=
contentVisibleRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
LayoutDeviceIntRect
&
rect
=
iter
.
Get
(
)
;
aResult
.
AppendElement
(
rect
)
;
aVisibleBounds
.
UnionRect
(
aVisibleBounds
rect
)
;
}
}
#
endif
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvUpdatePluginConfigurations
(
const
LayoutDeviceIntPoint
&
aContentOffset
const
LayoutDeviceIntRegion
&
aParentLayerVisibleRegion
nsTArray
<
PluginWindowData
>
&
&
aPlugins
)
{
#
if
!
defined
(
XP_WIN
)
&
&
!
defined
(
MOZ_WIDGET_GTK
)
MOZ_ASSERT_UNREACHABLE
(
"
CompositorBridgeChild
:
:
RecvUpdatePluginConfigurations
"
"
calls
unexpected
on
this
platform
.
"
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
#
else
DebugOnly
<
nsresult
>
rv
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsTArray
<
uintptr_t
>
visiblePluginIds
;
nsIWidget
*
parent
=
nullptr
;
for
(
uint32_t
pluginsIdx
=
0
;
pluginsIdx
<
aPlugins
.
Length
(
)
;
pluginsIdx
+
+
)
{
nsIWidget
*
widget
=
nsIWidget
:
:
LookupRegisteredPluginWindow
(
aPlugins
[
pluginsIdx
]
.
windowId
(
)
)
;
if
(
!
widget
)
{
NS_WARNING
(
"
Unexpected
plugin
id
not
found
!
"
)
;
continue
;
}
if
(
!
parent
)
{
parent
=
widget
-
>
GetParent
(
)
;
}
bool
isVisible
=
aPlugins
[
pluginsIdx
]
.
visible
(
)
;
if
(
widget
&
&
!
widget
-
>
Destroyed
(
)
)
{
LayoutDeviceIntRect
bounds
;
LayoutDeviceIntRect
visibleBounds
;
if
(
isVisible
)
{
bounds
=
aPlugins
[
pluginsIdx
]
.
bounds
(
)
;
nsTArray
<
LayoutDeviceIntRect
>
rectsOut
;
CalculatePluginClip
(
bounds
aPlugins
[
pluginsIdx
]
.
clip
(
)
aContentOffset
aParentLayerVisibleRegion
rectsOut
visibleBounds
isVisible
)
;
rv
=
widget
-
>
SetWindowClipRegion
(
rectsOut
false
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
widget
call
failure
"
)
;
widget
-
>
Resize
(
aContentOffset
.
x
+
bounds
.
X
(
)
aContentOffset
.
y
+
bounds
.
Y
(
)
bounds
.
Width
(
)
bounds
.
Height
(
)
true
)
;
}
widget
-
>
Enable
(
isVisible
)
;
widget
-
>
Show
(
isVisible
)
;
if
(
isVisible
)
{
#
if
defined
(
XP_WIN
)
mozilla
:
:
widget
:
:
WinUtils
:
:
InvalidatePluginAsWorkaround
(
widget
visibleBounds
)
;
#
else
widget
-
>
Invalidate
(
visibleBounds
)
;
#
endif
visiblePluginIds
.
AppendElement
(
aPlugins
[
pluginsIdx
]
.
windowId
(
)
)
;
}
}
}
nsIWidget
:
:
UpdateRegisteredPluginWindowVisibility
(
(
uintptr_t
)
parent
visiblePluginIds
)
;
if
(
!
mCanSend
)
{
return
IPC_OK
(
)
;
}
SendRemotePluginsReady
(
)
;
return
IPC_OK
(
)
;
#
endif
}
#
if
defined
(
XP_WIN
)
static
void
ScheduleSendAllPluginsCaptured
(
CompositorBridgeChild
*
aThis
MessageLoop
*
aLoop
)
{
aLoop
-
>
PostTask
(
NewNonOwningRunnableMethod
(
"
CompositorBridgeChild
:
:
SendAllPluginsCaptured
"
aThis
&
CompositorBridgeChild
:
:
SendAllPluginsCaptured
)
)
;
}
#
endif
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvCaptureAllPlugins
(
const
uintptr_t
&
aParentWidget
)
{
#
if
defined
(
XP_WIN
)
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsIWidget
:
:
CaptureRegisteredPlugins
(
aParentWidget
)
;
ImageBridgeChild
:
:
GetSingleton
(
)
-
>
GetMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
"
ScheduleSendAllPluginsCapturedRunnable
"
&
ScheduleSendAllPluginsCaptured
this
MessageLoop
:
:
current
(
)
)
)
;
return
IPC_OK
(
)
;
#
else
MOZ_ASSERT_UNREACHABLE
(
"
CompositorBridgeChild
:
:
RecvCaptureAllPlugins
calls
unexpected
.
"
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
#
endif
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvHideAllPlugins
(
const
uintptr_t
&
aParentWidget
)
{
#
if
!
defined
(
XP_WIN
)
&
&
!
defined
(
MOZ_WIDGET_GTK
)
MOZ_ASSERT_UNREACHABLE
(
"
CompositorBridgeChild
:
:
RecvHideAllPlugins
calls
"
"
unexpected
on
this
platform
.
"
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
#
else
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsTArray
<
uintptr_t
>
list
;
nsIWidget
:
:
UpdateRegisteredPluginWindowVisibility
(
aParentWidget
list
)
;
if
(
!
mCanSend
)
{
return
IPC_OK
(
)
;
}
SendRemotePluginsReady
(
)
;
return
IPC_OK
(
)
;
#
endif
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvDidComposite
(
const
LayersId
&
aId
const
TransactionId
&
aTransactionId
const
TimeStamp
&
aCompositeStart
const
TimeStamp
&
aCompositeEnd
)
{
AutoTArray
<
RefPtr
<
TextureClientPool
>
2
>
texturePools
=
mTexturePools
;
if
(
mLayerManager
)
{
MOZ_ASSERT
(
!
aId
.
IsValid
(
)
)
;
MOZ_ASSERT
(
mLayerManager
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_CLIENT
|
|
mLayerManager
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_WR
)
;
RefPtr
<
LayerManager
>
m
=
mLayerManager
;
m
-
>
DidComposite
(
aTransactionId
aCompositeStart
aCompositeEnd
)
;
}
else
if
(
aId
.
IsValid
(
)
)
{
RefPtr
<
dom
:
:
TabChild
>
child
=
dom
:
:
TabChild
:
:
GetFrom
(
aId
)
;
if
(
child
)
{
child
-
>
DidComposite
(
aTransactionId
aCompositeStart
aCompositeEnd
)
;
}
}
for
(
size_t
i
=
0
;
i
<
texturePools
.
Length
(
)
;
i
+
+
)
{
texturePools
[
i
]
-
>
ReturnDeferredClients
(
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvNotifyFrameStats
(
nsTArray
<
FrameStats
>
&
&
aFrameStats
)
{
gfxPlatform
:
:
GetPlatform
(
)
-
>
NotifyFrameStats
(
std
:
:
move
(
aFrameStats
)
)
;
return
IPC_OK
(
)
;
}
void
CompositorBridgeChild
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
if
(
aWhy
=
=
AbnormalShutdown
)
{
gfxCriticalNote
<
<
"
Receive
IPC
close
with
reason
=
AbnormalShutdown
"
;
}
{
MonitorAutoLock
lock
(
mPaintLock
)
;
mCanSend
=
false
;
mActorDestroyed
=
true
;
}
if
(
mProcessToken
&
&
XRE_IsParentProcess
(
)
)
{
GPUProcessManager
:
:
Get
(
)
-
>
NotifyRemoteActorDestroyed
(
mProcessToken
)
;
}
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvSharedCompositorFrameMetrics
(
const
mozilla
:
:
ipc
:
:
SharedMemoryBasic
:
:
Handle
&
metrics
const
CrossProcessMutexHandle
&
handle
const
LayersId
&
aLayersId
const
uint32_t
&
aAPZCId
)
{
SharedFrameMetricsData
*
data
=
new
SharedFrameMetricsData
(
metrics
handle
aLayersId
aAPZCId
)
;
mFrameMetricsTable
.
Put
(
data
-
>
GetViewID
(
)
data
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvReleaseSharedCompositorFrameMetrics
(
const
ViewID
&
aId
const
uint32_t
&
aAPZCId
)
{
if
(
auto
entry
=
mFrameMetricsTable
.
Lookup
(
aId
)
)
{
if
(
entry
.
Data
(
)
-
>
GetAPZCId
(
)
=
=
aAPZCId
)
{
entry
.
Remove
(
)
;
}
}
return
IPC_OK
(
)
;
}
CompositorBridgeChild
:
:
SharedFrameMetricsData
:
:
SharedFrameMetricsData
(
const
ipc
:
:
SharedMemoryBasic
:
:
Handle
&
metrics
const
CrossProcessMutexHandle
&
handle
const
LayersId
&
aLayersId
const
uint32_t
&
aAPZCId
)
:
mMutex
(
nullptr
)
mLayersId
(
aLayersId
)
mAPZCId
(
aAPZCId
)
{
mBuffer
=
new
ipc
:
:
SharedMemoryBasic
;
mBuffer
-
>
SetHandle
(
metrics
ipc
:
:
SharedMemory
:
:
RightsReadOnly
)
;
mBuffer
-
>
Map
(
sizeof
(
FrameMetrics
)
)
;
mMutex
=
new
CrossProcessMutex
(
handle
)
;
MOZ_COUNT_CTOR
(
SharedFrameMetricsData
)
;
}
CompositorBridgeChild
:
:
SharedFrameMetricsData
:
:
~
SharedFrameMetricsData
(
)
{
delete
mMutex
;
mBuffer
=
nullptr
;
MOZ_COUNT_DTOR
(
SharedFrameMetricsData
)
;
}
void
CompositorBridgeChild
:
:
SharedFrameMetricsData
:
:
CopyFrameMetrics
(
FrameMetrics
*
aFrame
)
{
const
FrameMetrics
*
frame
=
static_cast
<
const
FrameMetrics
*
>
(
mBuffer
-
>
memory
(
)
)
;
MOZ_ASSERT
(
frame
)
;
mMutex
-
>
Lock
(
)
;
*
aFrame
=
*
frame
;
mMutex
-
>
Unlock
(
)
;
}
ScrollableLayerGuid
:
:
ViewID
CompositorBridgeChild
:
:
SharedFrameMetricsData
:
:
GetViewID
(
)
{
const
FrameMetrics
*
frame
=
static_cast
<
const
FrameMetrics
*
>
(
mBuffer
-
>
memory
(
)
)
;
MOZ_ASSERT
(
frame
)
;
return
frame
-
>
GetScrollId
(
)
;
}
LayersId
CompositorBridgeChild
:
:
SharedFrameMetricsData
:
:
GetLayersId
(
)
const
{
return
mLayersId
;
}
uint32_t
CompositorBridgeChild
:
:
SharedFrameMetricsData
:
:
GetAPZCId
(
)
{
return
mAPZCId
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvRemotePaintIsReady
(
)
{
MOZ_LAYERS_LOG
(
(
"
[
RemoteGfx
]
CompositorBridgeChild
received
RemotePaintIsReady
"
)
)
;
RefPtr
<
nsISupports
>
iTabChildBase
(
do_QueryReferent
(
mWeakTabChild
)
)
;
if
(
!
iTabChildBase
)
{
MOZ_LAYERS_LOG
(
(
"
[
RemoteGfx
]
Note
:
TabChild
was
released
before
RemotePaintIsReady
.
"
"
MozAfterRemotePaint
will
not
be
sent
to
listener
.
"
)
)
;
return
IPC_OK
(
)
;
}
TabChildBase
*
tabChildBase
=
static_cast
<
TabChildBase
*
>
(
iTabChildBase
.
get
(
)
)
;
TabChild
*
tabChild
=
static_cast
<
TabChild
*
>
(
tabChildBase
)
;
MOZ_ASSERT
(
tabChild
)
;
Unused
<
<
tabChild
-
>
SendRemotePaintIsReady
(
)
;
mWeakTabChild
=
nullptr
;
return
IPC_OK
(
)
;
}
void
CompositorBridgeChild
:
:
RequestNotifyAfterRemotePaint
(
TabChild
*
aTabChild
)
{
MOZ_ASSERT
(
aTabChild
"
NULL
TabChild
not
allowed
in
"
"
CompositorBridgeChild
:
:
RequestNotifyAfterRemotePaint
"
)
;
mWeakTabChild
=
do_GetWeakReference
(
static_cast
<
dom
:
:
TabChildBase
*
>
(
aTabChild
)
)
;
if
(
!
mCanSend
)
{
return
;
}
Unused
<
<
SendRequestNotifyAfterRemotePaint
(
)
;
}
void
CompositorBridgeChild
:
:
CancelNotifyAfterRemotePaint
(
TabChild
*
aTabChild
)
{
RefPtr
<
nsISupports
>
iTabChildBase
(
do_QueryReferent
(
mWeakTabChild
)
)
;
if
(
!
iTabChildBase
)
{
return
;
}
TabChildBase
*
tabChildBase
=
static_cast
<
TabChildBase
*
>
(
iTabChildBase
.
get
(
)
)
;
TabChild
*
tabChild
=
static_cast
<
TabChild
*
>
(
tabChildBase
)
;
if
(
tabChild
=
=
aTabChild
)
{
mWeakTabChild
=
nullptr
;
}
}
bool
CompositorBridgeChild
:
:
SendWillClose
(
)
{
MOZ_RELEASE_ASSERT
(
mCanSend
)
;
return
PCompositorBridgeChild
:
:
SendWillClose
(
)
;
}
bool
CompositorBridgeChild
:
:
SendPause
(
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendPause
(
)
;
}
bool
CompositorBridgeChild
:
:
SendResume
(
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendResume
(
)
;
}
bool
CompositorBridgeChild
:
:
SendNotifyChildCreated
(
const
LayersId
&
id
CompositorOptions
*
aOptions
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendNotifyChildCreated
(
id
aOptions
)
;
}
bool
CompositorBridgeChild
:
:
SendAdoptChild
(
const
LayersId
&
id
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendAdoptChild
(
id
)
;
}
bool
CompositorBridgeChild
:
:
SendMakeSnapshot
(
const
SurfaceDescriptor
&
inSnapshot
const
gfx
:
:
IntRect
&
dirtyRect
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendMakeSnapshot
(
inSnapshot
dirtyRect
)
;
}
bool
CompositorBridgeChild
:
:
SendFlushRendering
(
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendFlushRendering
(
)
;
}
bool
CompositorBridgeChild
:
:
SendStartFrameTimeRecording
(
const
int32_t
&
bufferSize
uint32_t
*
startIndex
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendStartFrameTimeRecording
(
bufferSize
startIndex
)
;
}
bool
CompositorBridgeChild
:
:
SendStopFrameTimeRecording
(
const
uint32_t
&
startIndex
nsTArray
<
float
>
*
intervals
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendStopFrameTimeRecording
(
startIndex
intervals
)
;
}
bool
CompositorBridgeChild
:
:
SendNotifyRegionInvalidated
(
const
nsIntRegion
&
region
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendNotifyRegionInvalidated
(
region
)
;
}
bool
CompositorBridgeChild
:
:
SendRequestNotifyAfterRemotePaint
(
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendRequestNotifyAfterRemotePaint
(
)
;
}
bool
CompositorBridgeChild
:
:
SendAllPluginsCaptured
(
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendAllPluginsCaptured
(
)
;
}
PTextureChild
*
CompositorBridgeChild
:
:
AllocPTextureChild
(
const
SurfaceDescriptor
&
const
ReadLockDescriptor
&
const
LayersBackend
&
const
TextureFlags
&
const
LayersId
&
const
uint64_t
&
aSerial
const
wr
:
:
MaybeExternalImageId
&
aExternalImageId
)
{
return
TextureClient
:
:
CreateIPDLActor
(
)
;
}
bool
CompositorBridgeChild
:
:
DeallocPTextureChild
(
PTextureChild
*
actor
)
{
return
TextureClient
:
:
DestroyIPDLActor
(
actor
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvParentAsyncMessages
(
InfallibleTArray
<
AsyncParentMessageData
>
&
&
aMessages
)
{
for
(
AsyncParentMessageArray
:
:
index_type
i
=
0
;
i
<
aMessages
.
Length
(
)
;
+
+
i
)
{
const
AsyncParentMessageData
&
message
=
aMessages
[
i
]
;
switch
(
message
.
type
(
)
)
{
case
AsyncParentMessageData
:
:
TOpNotifyNotUsed
:
{
const
OpNotifyNotUsed
&
op
=
message
.
get_OpNotifyNotUsed
(
)
;
NotifyNotUsed
(
op
.
TextureId
(
)
op
.
fwdTransactionId
(
)
)
;
break
;
}
default
:
NS_ERROR
(
"
unknown
AsyncParentMessageData
type
"
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvObserveLayersUpdate
(
const
LayersId
&
aLayersId
const
LayersObserverEpoch
&
aEpoch
const
bool
&
aActive
)
{
MOZ_ASSERT
(
aLayersId
.
IsValid
(
)
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
RefPtr
<
dom
:
:
TabParent
>
tab
=
dom
:
:
TabParent
:
:
GetTabParentFromLayersId
(
aLayersId
)
)
{
tab
-
>
LayerTreeUpdate
(
aEpoch
aActive
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvNotifyWebRenderError
(
const
WebRenderError
&
aError
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
GPUProcessManager
:
:
Get
(
)
-
>
NotifyWebRenderError
(
aError
)
;
return
IPC_OK
(
)
;
}
void
CompositorBridgeChild
:
:
HoldUntilCompositableRefReleasedIfNecessary
(
TextureClient
*
aClient
)
{
if
(
!
aClient
)
{
return
;
}
if
(
!
(
aClient
-
>
GetFlags
(
)
&
TextureFlags
:
:
RECYCLE
)
)
{
return
;
}
aClient
-
>
SetLastFwdTransactionId
(
GetFwdTransactionId
(
)
)
;
mTexturesWaitingRecycled
.
emplace
(
aClient
-
>
GetSerial
(
)
aClient
)
;
}
void
CompositorBridgeChild
:
:
NotifyNotUsed
(
uint64_t
aTextureId
uint64_t
aFwdTransactionId
)
{
auto
it
=
mTexturesWaitingRecycled
.
find
(
aTextureId
)
;
if
(
it
!
=
mTexturesWaitingRecycled
.
end
(
)
)
{
if
(
aFwdTransactionId
<
it
-
>
second
-
>
GetLastFwdTransactionId
(
)
)
{
return
;
}
mTexturesWaitingRecycled
.
erase
(
it
)
;
}
}
void
CompositorBridgeChild
:
:
CancelWaitForRecycle
(
uint64_t
aTextureId
)
{
mTexturesWaitingRecycled
.
erase
(
aTextureId
)
;
}
TextureClientPool
*
CompositorBridgeChild
:
:
GetTexturePool
(
KnowsCompositor
*
aAllocator
SurfaceFormat
aFormat
TextureFlags
aFlags
)
{
for
(
size_t
i
=
0
;
i
<
mTexturePools
.
Length
(
)
;
i
+
+
)
{
if
(
mTexturePools
[
i
]
-
>
GetBackend
(
)
=
=
aAllocator
-
>
GetCompositorBackendType
(
)
&
&
mTexturePools
[
i
]
-
>
GetMaxTextureSize
(
)
=
=
aAllocator
-
>
GetMaxTextureSize
(
)
&
&
mTexturePools
[
i
]
-
>
GetFormat
(
)
=
=
aFormat
&
&
mTexturePools
[
i
]
-
>
GetFlags
(
)
=
=
aFlags
)
{
return
mTexturePools
[
i
]
;
}
}
mTexturePools
.
AppendElement
(
new
TextureClientPool
(
aAllocator
-
>
GetCompositorBackendType
(
)
aAllocator
-
>
SupportsTextureDirectMapping
(
)
aAllocator
-
>
GetMaxTextureSize
(
)
aFormat
gfx
:
:
gfxVars
:
:
TileSize
(
)
aFlags
gfxPrefs
:
:
LayersTilePoolShrinkTimeout
(
)
gfxPrefs
:
:
LayersTilePoolClearTimeout
(
)
gfxPrefs
:
:
LayersTileInitialPoolSize
(
)
gfxPrefs
:
:
LayersTilePoolUnusedSize
(
)
this
)
)
;
return
mTexturePools
.
LastElement
(
)
;
}
void
CompositorBridgeChild
:
:
HandleMemoryPressure
(
)
{
for
(
size_t
i
=
0
;
i
<
mTexturePools
.
Length
(
)
;
i
+
+
)
{
mTexturePools
[
i
]
-
>
Clear
(
)
;
}
}
void
CompositorBridgeChild
:
:
ClearTexturePool
(
)
{
for
(
size_t
i
=
0
;
i
<
mTexturePools
.
Length
(
)
;
i
+
+
)
{
mTexturePools
[
i
]
-
>
Clear
(
)
;
}
}
FixedSizeSmallShmemSectionAllocator
*
CompositorBridgeChild
:
:
GetTileLockAllocator
(
)
{
if
(
!
IPCOpen
(
)
)
{
return
nullptr
;
}
if
(
!
mSectionAllocator
)
{
mSectionAllocator
=
new
FixedSizeSmallShmemSectionAllocator
(
this
)
;
}
return
mSectionAllocator
;
}
PTextureChild
*
CompositorBridgeChild
:
:
CreateTexture
(
const
SurfaceDescriptor
&
aSharedData
const
ReadLockDescriptor
&
aReadLock
LayersBackend
aLayersBackend
TextureFlags
aFlags
uint64_t
aSerial
wr
:
:
MaybeExternalImageId
&
aExternalImageId
nsIEventTarget
*
aTarget
)
{
PTextureChild
*
textureChild
=
AllocPTextureChild
(
aSharedData
aReadLock
aLayersBackend
aFlags
LayersId
{
0
}
aSerial
aExternalImageId
)
;
if
(
aTarget
)
{
SetEventTargetForActor
(
textureChild
aTarget
)
;
}
return
SendPTextureConstructor
(
textureChild
aSharedData
aReadLock
aLayersBackend
aFlags
LayersId
{
0
}
aSerial
aExternalImageId
)
;
}
bool
CompositorBridgeChild
:
:
AllocUnsafeShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
ShmemAllocated
(
this
)
;
return
PCompositorBridgeChild
:
:
AllocUnsafeShmem
(
aSize
aType
aShmem
)
;
}
bool
CompositorBridgeChild
:
:
AllocShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
ShmemAllocated
(
this
)
;
return
PCompositorBridgeChild
:
:
AllocShmem
(
aSize
aType
aShmem
)
;
}
bool
CompositorBridgeChild
:
:
DeallocShmem
(
ipc
:
:
Shmem
&
aShmem
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
DeallocShmem
(
aShmem
)
;
}
widget
:
:
PCompositorWidgetChild
*
CompositorBridgeChild
:
:
AllocPCompositorWidgetChild
(
const
CompositorWidgetInitData
&
aInitData
)
{
MOZ_CRASH
(
"
Should
not
be
called
"
)
;
return
nullptr
;
}
bool
CompositorBridgeChild
:
:
DeallocPCompositorWidgetChild
(
PCompositorWidgetChild
*
aActor
)
{
#
ifdef
MOZ_WIDGET_SUPPORTS_OOP_COMPOSITING
delete
aActor
;
return
true
;
#
else
return
false
;
#
endif
}
PAPZCTreeManagerChild
*
CompositorBridgeChild
:
:
AllocPAPZCTreeManagerChild
(
const
LayersId
&
aLayersId
)
{
APZCTreeManagerChild
*
child
=
new
APZCTreeManagerChild
(
)
;
child
-
>
AddIPDLReference
(
)
;
if
(
aLayersId
.
IsValid
(
)
)
{
TabChild
*
tabChild
=
TabChild
:
:
GetFrom
(
aLayersId
)
;
if
(
tabChild
)
{
SetEventTargetForActor
(
child
tabChild
-
>
TabGroup
(
)
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
MOZ_ASSERT
(
child
-
>
GetActorEventTarget
(
)
)
;
}
}
return
child
;
}
PAPZChild
*
CompositorBridgeChild
:
:
AllocPAPZChild
(
const
LayersId
&
aLayersId
)
{
MOZ_CRASH
(
"
Should
not
be
called
"
)
;
return
nullptr
;
}
bool
CompositorBridgeChild
:
:
DeallocPAPZChild
(
PAPZChild
*
aActor
)
{
delete
aActor
;
return
true
;
}
bool
CompositorBridgeChild
:
:
DeallocPAPZCTreeManagerChild
(
PAPZCTreeManagerChild
*
aActor
)
{
APZCTreeManagerChild
*
child
=
static_cast
<
APZCTreeManagerChild
*
>
(
aActor
)
;
child
-
>
ReleaseIPDLReference
(
)
;
return
true
;
}
void
CompositorBridgeChild
:
:
WillEndTransaction
(
)
{
ResetShmemCounter
(
)
;
}
PWebRenderBridgeChild
*
CompositorBridgeChild
:
:
AllocPWebRenderBridgeChild
(
const
wr
:
:
PipelineId
&
aPipelineId
const
LayoutDeviceIntSize
&
)
{
WebRenderBridgeChild
*
child
=
new
WebRenderBridgeChild
(
aPipelineId
)
;
child
-
>
AddIPDLReference
(
)
;
return
child
;
}
bool
CompositorBridgeChild
:
:
DeallocPWebRenderBridgeChild
(
PWebRenderBridgeChild
*
aActor
)
{
WebRenderBridgeChild
*
child
=
static_cast
<
WebRenderBridgeChild
*
>
(
aActor
)
;
ClearSharedFrameMetricsData
(
wr
:
:
AsLayersId
(
child
-
>
GetPipeline
(
)
)
)
;
child
-
>
ReleaseIPDLReference
(
)
;
return
true
;
}
void
CompositorBridgeChild
:
:
ClearSharedFrameMetricsData
(
LayersId
aLayersId
)
{
for
(
auto
iter
=
mFrameMetricsTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsAutoPtr
<
SharedFrameMetricsData
>
&
data
=
iter
.
Data
(
)
;
if
(
data
-
>
GetLayersId
(
)
=
=
aLayersId
)
{
iter
.
Remove
(
)
;
}
}
}
uint64_t
CompositorBridgeChild
:
:
GetNextResourceId
(
)
{
+
+
mResourceId
;
MOZ_RELEASE_ASSERT
(
mResourceId
!
=
UINT32_MAX
)
;
uint64_t
id
=
mIdNamespace
;
id
=
(
id
<
<
32
)
|
mResourceId
;
return
id
;
}
wr
:
:
MaybeExternalImageId
CompositorBridgeChild
:
:
GetNextExternalImageId
(
)
{
return
Some
(
wr
:
:
ToExternalImageId
(
GetNextResourceId
(
)
)
)
;
}
wr
:
:
PipelineId
CompositorBridgeChild
:
:
GetNextPipelineId
(
)
{
return
wr
:
:
AsPipelineId
(
GetNextResourceId
(
)
)
;
}
void
CompositorBridgeChild
:
:
FlushAsyncPaints
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Maybe
<
TimeStamp
>
start
;
if
(
XRE_IsContentProcess
(
)
&
&
gfx
:
:
gfxVars
:
:
UseOMTP
(
)
)
{
start
=
Some
(
TimeStamp
:
:
Now
(
)
)
;
}
{
MonitorAutoLock
lock
(
mPaintLock
)
;
while
(
mOutstandingAsyncPaints
>
0
|
|
mOutstandingAsyncEndTransaction
)
{
lock
.
Wait
(
)
;
}
mTextureClientsForAsyncPaint
.
Clear
(
)
;
}
if
(
start
)
{
float
ms
=
(
TimeStamp
:
:
Now
(
)
-
start
.
value
(
)
)
.
ToMilliseconds
(
)
;
if
(
ms
>
=
0
.
2
)
{
mSlowFlushCount
+
+
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GFX_OMTP_PAINT_WAIT_TIME
int32_t
(
ms
)
)
;
}
mTotalFlushCount
+
+
;
double
ratio
=
double
(
mSlowFlushCount
)
/
double
(
mTotalFlushCount
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
GFX_OMTP_PAINT_WAIT_RATIO
uint32_t
(
ratio
*
100
*
100
)
)
;
}
}
void
CompositorBridgeChild
:
:
NotifyBeginAsyncPaint
(
PaintTask
*
aTask
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MonitorAutoLock
lock
(
mPaintLock
)
;
if
(
mTotalAsyncPaints
=
=
0
)
{
mAsyncTransactionBegin
=
TimeStamp
:
:
Now
(
)
;
}
mTotalAsyncPaints
+
=
1
;
MOZ_ASSERT
(
!
mIsDelayingForAsyncPaints
)
;
mOutstandingAsyncPaints
+
+
;
for
(
auto
&
client
:
aTask
-
>
mClients
)
{
client
-
>
AddPaintThreadRef
(
)
;
mTextureClientsForAsyncPaint
.
AppendElement
(
client
)
;
}
;
}
bool
CompositorBridgeChild
:
:
NotifyFinishedAsyncWorkerPaint
(
PaintTask
*
aTask
)
{
MOZ_ASSERT
(
PaintThread
:
:
Get
(
)
-
>
IsOnPaintWorkerThread
(
)
)
;
MonitorAutoLock
lock
(
mPaintLock
)
;
mOutstandingAsyncPaints
-
-
;
for
(
auto
&
client
:
aTask
-
>
mClients
)
{
client
-
>
DropPaintThreadRef
(
)
;
}
;
aTask
-
>
DropTextureClients
(
)
;
return
mOutstandingAsyncEndTransaction
&
&
mOutstandingAsyncPaints
=
=
0
;
}
bool
CompositorBridgeChild
:
:
NotifyBeginAsyncEndLayerTransaction
(
SyncObjectClient
*
aSyncObject
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MonitorAutoLock
lock
(
mPaintLock
)
;
MOZ_ASSERT
(
!
mOutstandingAsyncEndTransaction
)
;
mOutstandingAsyncEndTransaction
=
true
;
mOutstandingAsyncSyncObject
=
aSyncObject
;
return
mOutstandingAsyncPaints
=
=
0
;
}
void
CompositorBridgeChild
:
:
NotifyFinishedAsyncEndLayerTransaction
(
)
{
MOZ_ASSERT
(
PaintThread
:
:
Get
(
)
-
>
IsOnPaintWorkerThread
(
)
)
;
if
(
mOutstandingAsyncSyncObject
)
{
mOutstandingAsyncSyncObject
-
>
Synchronize
(
)
;
mOutstandingAsyncSyncObject
=
nullptr
;
}
MonitorAutoLock
lock
(
mPaintLock
)
;
if
(
mTotalAsyncPaints
>
0
)
{
float
tenthMs
=
(
TimeStamp
:
:
Now
(
)
-
mAsyncTransactionBegin
)
.
ToMilliseconds
(
)
*
10
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GFX_OMTP_PAINT_TASK_COUNT
int32_t
(
mTotalAsyncPaints
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GFX_OMTP_PAINT_TIME
int32_t
(
tenthMs
)
)
;
mTotalAsyncPaints
=
0
;
}
MOZ_RELEASE_ASSERT
(
mOutstandingAsyncPaints
=
=
0
)
;
MOZ_ASSERT
(
mOutstandingAsyncEndTransaction
)
;
mOutstandingAsyncEndTransaction
=
false
;
if
(
mIsDelayingForAsyncPaints
)
{
ResumeIPCAfterAsyncPaint
(
)
;
}
lock
.
Notify
(
)
;
}
void
CompositorBridgeChild
:
:
ResumeIPCAfterAsyncPaint
(
)
{
mPaintLock
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
PaintThread
:
:
Get
(
)
-
>
IsOnPaintWorkerThread
(
)
)
;
MOZ_ASSERT
(
mOutstandingAsyncPaints
=
=
0
)
;
MOZ_ASSERT
(
!
mOutstandingAsyncEndTransaction
)
;
MOZ_ASSERT
(
mIsDelayingForAsyncPaints
)
;
mIsDelayingForAsyncPaints
=
false
;
if
(
!
mCanSend
|
|
mActorDestroyed
)
{
return
;
}
GetIPCChannel
(
)
-
>
StopPostponingSends
(
)
;
}
void
CompositorBridgeChild
:
:
PostponeMessagesIfAsyncPainting
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MonitorAutoLock
lock
(
mPaintLock
)
;
MOZ_ASSERT
(
!
mIsDelayingForAsyncPaints
)
;
if
(
mOutstandingAsyncPaints
>
0
|
|
mOutstandingAsyncEndTransaction
)
{
mIsDelayingForAsyncPaints
=
true
;
GetIPCChannel
(
)
-
>
BeginPostponingSends
(
)
;
}
}
}
}
