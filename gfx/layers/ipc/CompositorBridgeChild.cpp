#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
<
stddef
.
h
>
#
include
"
ClientLayerManager
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
APZChild
.
h
"
#
include
"
mozilla
/
layers
/
IAPZCTreeManager
.
h
"
#
include
"
mozilla
/
layers
/
APZCTreeManagerChild
.
h
"
#
include
"
mozilla
/
layers
/
LayerTransactionChild
.
h
"
#
include
"
mozilla
/
layers
/
PLayerTransactionChild
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
layers
/
TextureClientPool
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderBridgeChild
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessManager
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
FrameLayerBuilder
.
h
"
#
include
"
mozilla
/
dom
/
TabChild
.
h
"
#
include
"
mozilla
/
dom
/
TabParent
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
WinUtils
.
h
"
#
endif
#
include
"
mozilla
/
widget
/
CompositorWidget
.
h
"
#
ifdef
MOZ_WIDGET_SUPPORTS_OOP_COMPOSITING
#
include
"
mozilla
/
widget
/
CompositorWidgetChild
.
h
"
#
endif
#
include
"
VsyncSource
.
h
"
using
mozilla
:
:
layers
:
:
LayerTransactionChild
;
using
mozilla
:
:
dom
:
:
TabChildBase
;
using
mozilla
:
:
Unused
;
using
mozilla
:
:
gfx
:
:
GPUProcessManager
;
namespace
mozilla
{
namespace
layers
{
static
int
sShmemCreationCounter
=
0
;
static
void
ResetShmemCounter
(
)
{
sShmemCreationCounter
=
0
;
}
static
void
ShmemAllocated
(
CompositorBridgeChild
*
aProtocol
)
{
sShmemCreationCounter
+
+
;
if
(
sShmemCreationCounter
>
256
)
{
aProtocol
-
>
SendSyncWithCompositor
(
)
;
ResetShmemCounter
(
)
;
MOZ_PERFORMANCE_WARNING
(
"
gfx
"
"
The
number
of
shmem
allocations
is
too
damn
high
!
"
)
;
}
}
static
StaticRefPtr
<
CompositorBridgeChild
>
sCompositorBridge
;
Atomic
<
int32_t
>
KnowsCompositor
:
:
sSerialCounter
(
0
)
;
CompositorBridgeChild
:
:
CompositorBridgeChild
(
LayerManager
*
aLayerManager
)
:
mLayerManager
(
aLayerManager
)
mCanSend
(
false
)
mFwdTransactionId
(
0
)
mMessageLoop
(
MessageLoop
:
:
current
(
)
)
mSectionAllocator
(
nullptr
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
CompositorBridgeChild
:
:
~
CompositorBridgeChild
(
)
{
if
(
mCanSend
)
{
gfxCriticalError
(
)
<
<
"
CompositorBridgeChild
was
not
deinitialized
"
;
}
}
bool
CompositorBridgeChild
:
:
IsSameProcess
(
)
const
{
return
OtherPid
(
)
=
=
base
:
:
GetCurrentProcId
(
)
;
}
static
void
DeferredDestroyCompositor
(
RefPtr
<
CompositorBridgeParent
>
aCompositorBridgeParent
RefPtr
<
CompositorBridgeChild
>
aCompositorBridgeChild
)
{
aCompositorBridgeChild
-
>
Close
(
)
;
if
(
sCompositorBridge
=
=
aCompositorBridgeChild
)
{
sCompositorBridge
=
nullptr
;
}
}
void
CompositorBridgeChild
:
:
Destroy
(
)
{
mTexturesWaitingRecycled
.
Clear
(
)
;
if
(
!
mCanSend
)
{
return
;
}
for
(
size_t
i
=
0
;
i
<
mTexturePools
.
Length
(
)
;
i
+
+
)
{
mTexturePools
[
i
]
-
>
Destroy
(
)
;
}
if
(
mSectionAllocator
)
{
delete
mSectionAllocator
;
mSectionAllocator
=
nullptr
;
}
RefPtr
<
CompositorBridgeChild
>
selfRef
=
this
;
if
(
mLayerManager
)
{
mLayerManager
-
>
Destroy
(
)
;
mLayerManager
=
nullptr
;
}
AutoTArray
<
PLayerTransactionChild
*
16
>
transactions
;
ManagedPLayerTransactionChild
(
transactions
)
;
for
(
int
i
=
transactions
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
RefPtr
<
LayerTransactionChild
>
layers
=
static_cast
<
LayerTransactionChild
*
>
(
transactions
[
i
]
)
;
layers
-
>
Destroy
(
)
;
}
AutoTArray
<
PWebRenderBridgeChild
*
16
>
wRBridges
;
ManagedPWebRenderBridgeChild
(
wRBridges
)
;
for
(
int
i
=
wRBridges
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
RefPtr
<
WebRenderBridgeChild
>
wRBridge
=
static_cast
<
WebRenderBridgeChild
*
>
(
wRBridges
[
i
]
)
;
wRBridge
-
>
Destroy
(
)
;
}
const
ManagedContainer
<
PTextureChild
>
&
textures
=
ManagedPTextureChild
(
)
;
for
(
auto
iter
=
textures
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
TextureClient
>
texture
=
TextureClient
:
:
AsTextureClient
(
iter
.
Get
(
)
-
>
GetKey
(
)
)
;
if
(
texture
)
{
texture
-
>
Destroy
(
)
;
}
}
SendWillClose
(
)
;
mCanSend
=
false
;
mProcessToken
=
0
;
MessageLoop
:
:
current
(
)
-
>
PostTask
(
NewRunnableFunction
(
DeferredDestroyCompositor
mCompositorBridgeParent
selfRef
)
)
;
}
void
CompositorBridgeChild
:
:
ShutDown
(
)
{
if
(
sCompositorBridge
)
{
sCompositorBridge
-
>
Destroy
(
)
;
do
{
NS_ProcessNextEvent
(
nullptr
true
)
;
}
while
(
sCompositorBridge
)
;
}
}
bool
CompositorBridgeChild
:
:
LookupCompositorFrameMetrics
(
const
FrameMetrics
:
:
ViewID
aId
FrameMetrics
&
aFrame
)
{
SharedFrameMetricsData
*
data
=
mFrameMetricsTable
.
Get
(
aId
)
;
if
(
data
)
{
data
-
>
CopyFrameMetrics
(
&
aFrame
)
;
return
true
;
}
return
false
;
}
bool
CompositorBridgeChild
:
:
InitForContent
(
Endpoint
<
PCompositorBridgeChild
>
&
&
aEndpoint
)
{
MOZ_ASSERT
(
!
sCompositorBridge
)
;
RefPtr
<
CompositorBridgeChild
>
child
(
new
CompositorBridgeChild
(
nullptr
)
)
;
if
(
!
aEndpoint
.
Bind
(
child
)
)
{
NS_RUNTIMEABORT
(
"
Couldn
'
t
Open
(
)
Compositor
channel
.
"
)
;
return
false
;
}
child
-
>
InitIPDL
(
)
;
sCompositorBridge
=
child
;
return
true
;
}
bool
CompositorBridgeChild
:
:
ReinitForContent
(
Endpoint
<
PCompositorBridgeChild
>
&
&
aEndpoint
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
RefPtr
<
CompositorBridgeChild
>
old
=
sCompositorBridge
.
forget
(
)
)
{
old
-
>
Destroy
(
)
;
}
return
InitForContent
(
Move
(
aEndpoint
)
)
;
}
CompositorBridgeParent
*
CompositorBridgeChild
:
:
InitSameProcess
(
widget
:
:
CompositorWidget
*
aWidget
const
uint64_t
&
aLayerTreeId
CSSToLayoutDeviceScale
aScale
const
CompositorOptions
&
aOptions
bool
aUseExternalSurface
const
gfx
:
:
IntSize
&
aSurfaceSize
)
{
TimeDuration
vsyncRate
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetHardwareVsync
(
)
-
>
GetGlobalDisplay
(
)
.
GetVsyncRate
(
)
;
mCompositorBridgeParent
=
new
CompositorBridgeParent
(
aScale
vsyncRate
aOptions
aUseExternalSurface
aSurfaceSize
)
;
bool
ok
=
Open
(
mCompositorBridgeParent
-
>
GetIPCChannel
(
)
CompositorThreadHolder
:
:
Loop
(
)
ipc
:
:
ChildSide
)
;
MOZ_RELEASE_ASSERT
(
ok
)
;
InitIPDL
(
)
;
mCompositorBridgeParent
-
>
InitSameProcess
(
aWidget
aLayerTreeId
)
;
return
mCompositorBridgeParent
;
}
RefPtr
<
CompositorBridgeChild
>
CompositorBridgeChild
:
:
CreateRemote
(
const
uint64_t
&
aProcessToken
LayerManager
*
aLayerManager
Endpoint
<
PCompositorBridgeChild
>
&
&
aEndpoint
)
{
RefPtr
<
CompositorBridgeChild
>
child
=
new
CompositorBridgeChild
(
aLayerManager
)
;
if
(
!
aEndpoint
.
Bind
(
child
)
)
{
return
nullptr
;
}
child
-
>
InitIPDL
(
)
;
child
-
>
mProcessToken
=
aProcessToken
;
return
child
;
}
void
CompositorBridgeChild
:
:
InitIPDL
(
)
{
mCanSend
=
true
;
AddRef
(
)
;
}
void
CompositorBridgeChild
:
:
DeallocPCompositorBridgeChild
(
)
{
Release
(
)
;
}
CompositorBridgeChild
*
CompositorBridgeChild
:
:
Get
(
)
{
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
return
sCompositorBridge
;
}
bool
CompositorBridgeChild
:
:
ChildProcessHasCompositorBridge
(
)
{
return
sCompositorBridge
!
=
nullptr
;
}
bool
CompositorBridgeChild
:
:
CompositorIsInGPUProcess
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
XRE_IsParentProcess
(
)
)
{
return
!
!
GPUProcessManager
:
:
Get
(
)
-
>
GetGPUChild
(
)
;
}
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
CompositorBridgeChild
*
bridge
=
CompositorBridgeChild
:
:
Get
(
)
;
if
(
!
bridge
)
{
return
false
;
}
return
bridge
-
>
OtherPid
(
)
!
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
OtherPid
(
)
;
}
PLayerTransactionChild
*
CompositorBridgeChild
:
:
AllocPLayerTransactionChild
(
const
nsTArray
<
LayersBackend
>
&
aBackendHints
const
uint64_t
&
aId
TextureFactoryIdentifier
*
bool
*
)
{
LayerTransactionChild
*
c
=
new
LayerTransactionChild
(
aId
)
;
c
-
>
AddIPDLReference
(
)
;
return
c
;
}
bool
CompositorBridgeChild
:
:
DeallocPLayerTransactionChild
(
PLayerTransactionChild
*
actor
)
{
uint64_t
childId
=
static_cast
<
LayerTransactionChild
*
>
(
actor
)
-
>
GetId
(
)
;
for
(
auto
iter
=
mFrameMetricsTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsAutoPtr
<
SharedFrameMetricsData
>
&
data
=
iter
.
Data
(
)
;
if
(
data
-
>
GetLayersId
(
)
=
=
childId
)
{
iter
.
Remove
(
)
;
}
}
static_cast
<
LayerTransactionChild
*
>
(
actor
)
-
>
ReleaseIPDLReference
(
)
;
return
true
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvInvalidateLayers
(
const
uint64_t
&
aLayersId
)
{
if
(
mLayerManager
)
{
MOZ_ASSERT
(
aLayersId
=
=
0
)
;
FrameLayerBuilder
:
:
InvalidateAllLayers
(
mLayerManager
)
;
}
else
if
(
aLayersId
!
=
0
)
{
if
(
dom
:
:
TabChild
*
child
=
dom
:
:
TabChild
:
:
GetFrom
(
aLayersId
)
)
{
child
-
>
InvalidateLayers
(
)
;
}
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvCompositorUpdated
(
const
uint64_t
&
aLayersId
const
TextureFactoryIdentifier
&
aNewIdentifier
const
uint64_t
&
aSeqNo
)
{
if
(
mLayerManager
)
{
MOZ_ASSERT
(
aLayersId
=
=
0
)
;
}
else
if
(
aLayersId
!
=
0
)
{
static
uint64_t
sLastSeqNo
=
0
;
if
(
sLastSeqNo
!
=
aSeqNo
)
{
gfxPlatform
:
:
GetPlatform
(
)
-
>
CompositorUpdated
(
)
;
sLastSeqNo
=
aSeqNo
;
}
if
(
dom
:
:
TabChild
*
child
=
dom
:
:
TabChild
:
:
GetFrom
(
aLayersId
)
)
{
child
-
>
CompositorUpdated
(
aNewIdentifier
)
;
}
if
(
!
mCanSend
)
{
return
IPC_OK
(
)
;
}
SendAcknowledgeCompositorUpdate
(
aLayersId
)
;
}
return
IPC_OK
(
)
;
}
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
static
void
CalculatePluginClip
(
const
LayoutDeviceIntRect
&
aBounds
const
nsTArray
<
LayoutDeviceIntRect
>
&
aPluginClipRects
const
LayoutDeviceIntPoint
&
aContentOffset
const
LayoutDeviceIntRegion
&
aParentLayerVisibleRegion
nsTArray
<
LayoutDeviceIntRect
>
&
aResult
LayoutDeviceIntRect
&
aVisibleBounds
bool
&
aPluginIsVisible
)
{
aPluginIsVisible
=
true
;
LayoutDeviceIntRegion
contentVisibleRegion
;
for
(
uint32_t
idx
=
0
;
idx
<
aPluginClipRects
.
Length
(
)
;
idx
+
+
)
{
LayoutDeviceIntRect
rect
=
aPluginClipRects
[
idx
]
;
rect
.
MoveBy
(
aBounds
.
x
aBounds
.
y
)
;
contentVisibleRegion
.
OrWith
(
rect
)
;
}
LayoutDeviceIntRegion
region
=
aParentLayerVisibleRegion
;
region
.
MoveBy
(
-
aContentOffset
.
x
-
aContentOffset
.
y
)
;
contentVisibleRegion
.
AndWith
(
region
)
;
if
(
contentVisibleRegion
.
IsEmpty
(
)
)
{
aPluginIsVisible
=
false
;
return
;
}
contentVisibleRegion
.
MoveBy
(
-
aBounds
.
x
-
aBounds
.
y
)
;
for
(
auto
iter
=
contentVisibleRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
LayoutDeviceIntRect
&
rect
=
iter
.
Get
(
)
;
aResult
.
AppendElement
(
rect
)
;
aVisibleBounds
.
UnionRect
(
aVisibleBounds
rect
)
;
}
}
#
endif
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvUpdatePluginConfigurations
(
const
LayoutDeviceIntPoint
&
aContentOffset
const
LayoutDeviceIntRegion
&
aParentLayerVisibleRegion
nsTArray
<
PluginWindowData
>
&
&
aPlugins
)
{
#
if
!
defined
(
XP_WIN
)
&
&
!
defined
(
MOZ_WIDGET_GTK
)
NS_NOTREACHED
(
"
CompositorBridgeChild
:
:
RecvUpdatePluginConfigurations
calls
"
"
unexpected
on
this
platform
.
"
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
#
else
DebugOnly
<
nsresult
>
rv
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsTArray
<
uintptr_t
>
visiblePluginIds
;
nsIWidget
*
parent
=
nullptr
;
for
(
uint32_t
pluginsIdx
=
0
;
pluginsIdx
<
aPlugins
.
Length
(
)
;
pluginsIdx
+
+
)
{
nsIWidget
*
widget
=
nsIWidget
:
:
LookupRegisteredPluginWindow
(
aPlugins
[
pluginsIdx
]
.
windowId
(
)
)
;
if
(
!
widget
)
{
NS_WARNING
(
"
Unexpected
plugin
id
not
found
!
"
)
;
continue
;
}
if
(
!
parent
)
{
parent
=
widget
-
>
GetParent
(
)
;
}
bool
isVisible
=
aPlugins
[
pluginsIdx
]
.
visible
(
)
;
if
(
widget
&
&
!
widget
-
>
Destroyed
(
)
)
{
LayoutDeviceIntRect
bounds
;
LayoutDeviceIntRect
visibleBounds
;
if
(
isVisible
)
{
bounds
=
aPlugins
[
pluginsIdx
]
.
bounds
(
)
;
nsTArray
<
LayoutDeviceIntRect
>
rectsOut
;
CalculatePluginClip
(
bounds
aPlugins
[
pluginsIdx
]
.
clip
(
)
aContentOffset
aParentLayerVisibleRegion
rectsOut
visibleBounds
isVisible
)
;
rv
=
widget
-
>
SetWindowClipRegion
(
rectsOut
false
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
widget
call
failure
"
)
;
widget
-
>
Resize
(
aContentOffset
.
x
+
bounds
.
x
aContentOffset
.
y
+
bounds
.
y
bounds
.
width
bounds
.
height
true
)
;
}
widget
-
>
Enable
(
isVisible
)
;
widget
-
>
Show
(
isVisible
)
;
if
(
isVisible
)
{
#
if
defined
(
XP_WIN
)
mozilla
:
:
widget
:
:
WinUtils
:
:
InvalidatePluginAsWorkaround
(
widget
visibleBounds
)
;
#
else
widget
-
>
Invalidate
(
visibleBounds
)
;
#
endif
visiblePluginIds
.
AppendElement
(
aPlugins
[
pluginsIdx
]
.
windowId
(
)
)
;
}
}
}
nsIWidget
:
:
UpdateRegisteredPluginWindowVisibility
(
(
uintptr_t
)
parent
visiblePluginIds
)
;
if
(
!
mCanSend
)
{
return
IPC_OK
(
)
;
}
SendRemotePluginsReady
(
)
;
return
IPC_OK
(
)
;
#
endif
}
#
if
defined
(
XP_WIN
)
static
void
ScheduleSendAllPluginsCaptured
(
CompositorBridgeChild
*
aThis
MessageLoop
*
aLoop
)
{
aLoop
-
>
PostTask
(
NewNonOwningRunnableMethod
(
aThis
&
CompositorBridgeChild
:
:
SendAllPluginsCaptured
)
)
;
}
#
endif
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvCaptureAllPlugins
(
const
uintptr_t
&
aParentWidget
)
{
#
if
defined
(
XP_WIN
)
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsIWidget
:
:
CaptureRegisteredPlugins
(
aParentWidget
)
;
ImageBridgeChild
:
:
GetSingleton
(
)
-
>
GetMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
&
ScheduleSendAllPluginsCaptured
this
MessageLoop
:
:
current
(
)
)
)
;
return
IPC_OK
(
)
;
#
else
MOZ_ASSERT_UNREACHABLE
(
"
CompositorBridgeChild
:
:
RecvCaptureAllPlugins
calls
unexpected
.
"
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
#
endif
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvHideAllPlugins
(
const
uintptr_t
&
aParentWidget
)
{
#
if
!
defined
(
XP_WIN
)
&
&
!
defined
(
MOZ_WIDGET_GTK
)
NS_NOTREACHED
(
"
CompositorBridgeChild
:
:
RecvHideAllPlugins
calls
"
"
unexpected
on
this
platform
.
"
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
#
else
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsTArray
<
uintptr_t
>
list
;
nsIWidget
:
:
UpdateRegisteredPluginWindowVisibility
(
aParentWidget
list
)
;
if
(
!
mCanSend
)
{
return
IPC_OK
(
)
;
}
SendRemotePluginsReady
(
)
;
return
IPC_OK
(
)
;
#
endif
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvDidComposite
(
const
uint64_t
&
aId
const
uint64_t
&
aTransactionId
const
TimeStamp
&
aCompositeStart
const
TimeStamp
&
aCompositeEnd
)
{
if
(
mLayerManager
)
{
MOZ_ASSERT
(
aId
=
=
0
)
;
MOZ_ASSERT
(
mLayerManager
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_CLIENT
|
|
mLayerManager
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_WR
)
;
RefPtr
<
LayerManager
>
m
=
mLayerManager
;
m
-
>
DidComposite
(
aTransactionId
aCompositeStart
aCompositeEnd
)
;
}
else
if
(
aId
!
=
0
)
{
RefPtr
<
dom
:
:
TabChild
>
child
=
dom
:
:
TabChild
:
:
GetFrom
(
aId
)
;
if
(
child
)
{
child
-
>
DidComposite
(
aTransactionId
aCompositeStart
aCompositeEnd
)
;
}
}
for
(
size_t
i
=
0
;
i
<
mTexturePools
.
Length
(
)
;
i
+
+
)
{
mTexturePools
[
i
]
-
>
ReturnDeferredClients
(
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvOverfill
(
const
uint32_t
&
aOverfill
)
{
for
(
size_t
i
=
0
;
i
<
mOverfillObservers
.
Length
(
)
;
i
+
+
)
{
mOverfillObservers
[
i
]
-
>
RunOverfillCallback
(
aOverfill
)
;
}
mOverfillObservers
.
Clear
(
)
;
return
IPC_OK
(
)
;
}
void
CompositorBridgeChild
:
:
AddOverfillObserver
(
ClientLayerManager
*
aLayerManager
)
{
MOZ_ASSERT
(
aLayerManager
)
;
mOverfillObservers
.
AppendElement
(
aLayerManager
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvClearCachedResources
(
const
uint64_t
&
aId
)
{
dom
:
:
TabChild
*
child
=
dom
:
:
TabChild
:
:
GetFrom
(
aId
)
;
if
(
child
)
{
child
-
>
ClearCachedResources
(
)
;
}
return
IPC_OK
(
)
;
}
void
CompositorBridgeChild
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
if
(
aWhy
=
=
AbnormalShutdown
)
{
gfxCriticalNote
<
<
"
Receive
IPC
close
with
reason
=
AbnormalShutdown
"
;
}
mCanSend
=
false
;
if
(
mProcessToken
&
&
XRE_IsParentProcess
(
)
)
{
GPUProcessManager
:
:
Get
(
)
-
>
NotifyRemoteActorDestroyed
(
mProcessToken
)
;
}
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvSharedCompositorFrameMetrics
(
const
mozilla
:
:
ipc
:
:
SharedMemoryBasic
:
:
Handle
&
metrics
const
CrossProcessMutexHandle
&
handle
const
uint64_t
&
aLayersId
const
uint32_t
&
aAPZCId
)
{
SharedFrameMetricsData
*
data
=
new
SharedFrameMetricsData
(
metrics
handle
aLayersId
aAPZCId
)
;
mFrameMetricsTable
.
Put
(
data
-
>
GetViewID
(
)
data
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvReleaseSharedCompositorFrameMetrics
(
const
ViewID
&
aId
const
uint32_t
&
aAPZCId
)
{
SharedFrameMetricsData
*
data
=
mFrameMetricsTable
.
Get
(
aId
)
;
if
(
data
&
&
(
data
-
>
GetAPZCId
(
)
=
=
aAPZCId
)
)
{
mFrameMetricsTable
.
Remove
(
aId
)
;
}
return
IPC_OK
(
)
;
}
CompositorBridgeChild
:
:
SharedFrameMetricsData
:
:
SharedFrameMetricsData
(
const
ipc
:
:
SharedMemoryBasic
:
:
Handle
&
metrics
const
CrossProcessMutexHandle
&
handle
const
uint64_t
&
aLayersId
const
uint32_t
&
aAPZCId
)
:
mMutex
(
nullptr
)
mLayersId
(
aLayersId
)
mAPZCId
(
aAPZCId
)
{
mBuffer
=
new
ipc
:
:
SharedMemoryBasic
;
mBuffer
-
>
SetHandle
(
metrics
)
;
mBuffer
-
>
Map
(
sizeof
(
FrameMetrics
)
)
;
mMutex
=
new
CrossProcessMutex
(
handle
)
;
MOZ_COUNT_CTOR
(
SharedFrameMetricsData
)
;
}
CompositorBridgeChild
:
:
SharedFrameMetricsData
:
:
~
SharedFrameMetricsData
(
)
{
delete
mMutex
;
mBuffer
=
nullptr
;
MOZ_COUNT_DTOR
(
SharedFrameMetricsData
)
;
}
void
CompositorBridgeChild
:
:
SharedFrameMetricsData
:
:
CopyFrameMetrics
(
FrameMetrics
*
aFrame
)
{
FrameMetrics
*
frame
=
static_cast
<
FrameMetrics
*
>
(
mBuffer
-
>
memory
(
)
)
;
MOZ_ASSERT
(
frame
)
;
mMutex
-
>
Lock
(
)
;
*
aFrame
=
*
frame
;
mMutex
-
>
Unlock
(
)
;
}
FrameMetrics
:
:
ViewID
CompositorBridgeChild
:
:
SharedFrameMetricsData
:
:
GetViewID
(
)
{
FrameMetrics
*
frame
=
static_cast
<
FrameMetrics
*
>
(
mBuffer
-
>
memory
(
)
)
;
MOZ_ASSERT
(
frame
)
;
return
frame
-
>
GetScrollId
(
)
;
}
uint64_t
CompositorBridgeChild
:
:
SharedFrameMetricsData
:
:
GetLayersId
(
)
const
{
return
mLayersId
;
}
uint32_t
CompositorBridgeChild
:
:
SharedFrameMetricsData
:
:
GetAPZCId
(
)
{
return
mAPZCId
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvRemotePaintIsReady
(
)
{
MOZ_LAYERS_LOG
(
(
"
[
RemoteGfx
]
CompositorBridgeChild
received
RemotePaintIsReady
"
)
)
;
RefPtr
<
nsISupports
>
iTabChildBase
(
do_QueryReferent
(
mWeakTabChild
)
)
;
if
(
!
iTabChildBase
)
{
MOZ_LAYERS_LOG
(
(
"
[
RemoteGfx
]
Note
:
TabChild
was
released
before
RemotePaintIsReady
.
"
"
MozAfterRemotePaint
will
not
be
sent
to
listener
.
"
)
)
;
return
IPC_OK
(
)
;
}
TabChildBase
*
tabChildBase
=
static_cast
<
TabChildBase
*
>
(
iTabChildBase
.
get
(
)
)
;
TabChild
*
tabChild
=
static_cast
<
TabChild
*
>
(
tabChildBase
)
;
MOZ_ASSERT
(
tabChild
)
;
Unused
<
<
tabChild
-
>
SendRemotePaintIsReady
(
)
;
mWeakTabChild
=
nullptr
;
return
IPC_OK
(
)
;
}
void
CompositorBridgeChild
:
:
RequestNotifyAfterRemotePaint
(
TabChild
*
aTabChild
)
{
MOZ_ASSERT
(
aTabChild
"
NULL
TabChild
not
allowed
in
CompositorBridgeChild
:
:
RequestNotifyAfterRemotePaint
"
)
;
mWeakTabChild
=
do_GetWeakReference
(
static_cast
<
dom
:
:
TabChildBase
*
>
(
aTabChild
)
)
;
if
(
!
mCanSend
)
{
return
;
}
Unused
<
<
SendRequestNotifyAfterRemotePaint
(
)
;
}
void
CompositorBridgeChild
:
:
CancelNotifyAfterRemotePaint
(
TabChild
*
aTabChild
)
{
RefPtr
<
nsISupports
>
iTabChildBase
(
do_QueryReferent
(
mWeakTabChild
)
)
;
if
(
!
iTabChildBase
)
{
return
;
}
TabChildBase
*
tabChildBase
=
static_cast
<
TabChildBase
*
>
(
iTabChildBase
.
get
(
)
)
;
TabChild
*
tabChild
=
static_cast
<
TabChild
*
>
(
tabChildBase
)
;
if
(
tabChild
=
=
aTabChild
)
{
mWeakTabChild
=
nullptr
;
}
}
bool
CompositorBridgeChild
:
:
SendWillClose
(
)
{
MOZ_RELEASE_ASSERT
(
mCanSend
)
;
return
PCompositorBridgeChild
:
:
SendWillClose
(
)
;
}
bool
CompositorBridgeChild
:
:
SendPause
(
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendPause
(
)
;
}
bool
CompositorBridgeChild
:
:
SendResume
(
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendResume
(
)
;
}
bool
CompositorBridgeChild
:
:
SendNotifyChildCreated
(
const
uint64_t
&
id
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendNotifyChildCreated
(
id
)
;
}
bool
CompositorBridgeChild
:
:
SendAdoptChild
(
const
uint64_t
&
id
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendAdoptChild
(
id
)
;
}
bool
CompositorBridgeChild
:
:
SendMakeSnapshot
(
const
SurfaceDescriptor
&
inSnapshot
const
gfx
:
:
IntRect
&
dirtyRect
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendMakeSnapshot
(
inSnapshot
dirtyRect
)
;
}
bool
CompositorBridgeChild
:
:
SendFlushRendering
(
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendFlushRendering
(
)
;
}
bool
CompositorBridgeChild
:
:
SendStartFrameTimeRecording
(
const
int32_t
&
bufferSize
uint32_t
*
startIndex
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendStartFrameTimeRecording
(
bufferSize
startIndex
)
;
}
bool
CompositorBridgeChild
:
:
SendStopFrameTimeRecording
(
const
uint32_t
&
startIndex
nsTArray
<
float
>
*
intervals
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendStopFrameTimeRecording
(
startIndex
intervals
)
;
}
bool
CompositorBridgeChild
:
:
SendNotifyRegionInvalidated
(
const
nsIntRegion
&
region
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendNotifyRegionInvalidated
(
region
)
;
}
bool
CompositorBridgeChild
:
:
SendRequestNotifyAfterRemotePaint
(
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendRequestNotifyAfterRemotePaint
(
)
;
}
bool
CompositorBridgeChild
:
:
SendClearApproximatelyVisibleRegions
(
uint64_t
aLayersId
uint32_t
aPresShellId
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendClearApproximatelyVisibleRegions
(
aLayersId
aPresShellId
)
;
}
bool
CompositorBridgeChild
:
:
SendNotifyApproximatelyVisibleRegion
(
const
ScrollableLayerGuid
&
aGuid
const
CSSIntRegion
&
aRegion
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendNotifyApproximatelyVisibleRegion
(
aGuid
aRegion
)
;
}
bool
CompositorBridgeChild
:
:
SendAllPluginsCaptured
(
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
SendAllPluginsCaptured
(
)
;
}
PTextureChild
*
CompositorBridgeChild
:
:
AllocPTextureChild
(
const
SurfaceDescriptor
&
const
LayersBackend
&
const
TextureFlags
&
const
uint64_t
&
const
uint64_t
&
aSerial
)
{
return
TextureClient
:
:
CreateIPDLActor
(
)
;
}
bool
CompositorBridgeChild
:
:
DeallocPTextureChild
(
PTextureChild
*
actor
)
{
return
TextureClient
:
:
DestroyIPDLActor
(
actor
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvParentAsyncMessages
(
InfallibleTArray
<
AsyncParentMessageData
>
&
&
aMessages
)
{
for
(
AsyncParentMessageArray
:
:
index_type
i
=
0
;
i
<
aMessages
.
Length
(
)
;
+
+
i
)
{
const
AsyncParentMessageData
&
message
=
aMessages
[
i
]
;
switch
(
message
.
type
(
)
)
{
case
AsyncParentMessageData
:
:
TOpNotifyNotUsed
:
{
const
OpNotifyNotUsed
&
op
=
message
.
get_OpNotifyNotUsed
(
)
;
NotifyNotUsed
(
op
.
TextureId
(
)
op
.
fwdTransactionId
(
)
)
;
break
;
}
default
:
NS_ERROR
(
"
unknown
AsyncParentMessageData
type
"
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CompositorBridgeChild
:
:
RecvObserveLayerUpdate
(
const
uint64_t
&
aLayersId
const
uint64_t
&
aEpoch
const
bool
&
aActive
)
{
MOZ_ASSERT
(
aLayersId
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
RefPtr
<
dom
:
:
TabParent
>
tab
=
dom
:
:
TabParent
:
:
GetTabParentFromLayersId
(
aLayersId
)
)
{
tab
-
>
LayerTreeUpdate
(
aEpoch
aActive
)
;
}
return
IPC_OK
(
)
;
}
void
CompositorBridgeChild
:
:
HoldUntilCompositableRefReleasedIfNecessary
(
TextureClient
*
aClient
)
{
if
(
!
aClient
)
{
return
;
}
if
(
!
(
aClient
-
>
GetFlags
(
)
&
TextureFlags
:
:
RECYCLE
)
)
{
return
;
}
aClient
-
>
SetLastFwdTransactionId
(
GetFwdTransactionId
(
)
)
;
mTexturesWaitingRecycled
.
Put
(
aClient
-
>
GetSerial
(
)
aClient
)
;
}
void
CompositorBridgeChild
:
:
NotifyNotUsed
(
uint64_t
aTextureId
uint64_t
aFwdTransactionId
)
{
RefPtr
<
TextureClient
>
client
=
mTexturesWaitingRecycled
.
Get
(
aTextureId
)
;
if
(
!
client
)
{
return
;
}
if
(
aFwdTransactionId
<
client
-
>
GetLastFwdTransactionId
(
)
)
{
return
;
}
mTexturesWaitingRecycled
.
Remove
(
aTextureId
)
;
}
void
CompositorBridgeChild
:
:
CancelWaitForRecycle
(
uint64_t
aTextureId
)
{
RefPtr
<
TextureClient
>
client
=
mTexturesWaitingRecycled
.
Get
(
aTextureId
)
;
if
(
!
client
)
{
return
;
}
mTexturesWaitingRecycled
.
Remove
(
aTextureId
)
;
}
TextureClientPool
*
CompositorBridgeChild
:
:
GetTexturePool
(
KnowsCompositor
*
aAllocator
SurfaceFormat
aFormat
TextureFlags
aFlags
)
{
for
(
size_t
i
=
0
;
i
<
mTexturePools
.
Length
(
)
;
i
+
+
)
{
if
(
mTexturePools
[
i
]
-
>
GetBackend
(
)
=
=
aAllocator
-
>
GetCompositorBackendType
(
)
&
&
mTexturePools
[
i
]
-
>
GetMaxTextureSize
(
)
=
=
aAllocator
-
>
GetMaxTextureSize
(
)
&
&
mTexturePools
[
i
]
-
>
GetFormat
(
)
=
=
aFormat
&
&
mTexturePools
[
i
]
-
>
GetFlags
(
)
=
=
aFlags
)
{
return
mTexturePools
[
i
]
;
}
}
mTexturePools
.
AppendElement
(
new
TextureClientPool
(
aAllocator
-
>
GetCompositorBackendType
(
)
aAllocator
-
>
GetMaxTextureSize
(
)
aFormat
gfx
:
:
gfxVars
:
:
TileSize
(
)
aFlags
gfxPrefs
:
:
LayersTilePoolShrinkTimeout
(
)
gfxPrefs
:
:
LayersTilePoolClearTimeout
(
)
gfxPrefs
:
:
LayersTileInitialPoolSize
(
)
gfxPrefs
:
:
LayersTilePoolUnusedSize
(
)
this
)
)
;
return
mTexturePools
.
LastElement
(
)
;
}
void
CompositorBridgeChild
:
:
HandleMemoryPressure
(
)
{
for
(
size_t
i
=
0
;
i
<
mTexturePools
.
Length
(
)
;
i
+
+
)
{
mTexturePools
[
i
]
-
>
Clear
(
)
;
}
}
void
CompositorBridgeChild
:
:
ClearTexturePool
(
)
{
for
(
size_t
i
=
0
;
i
<
mTexturePools
.
Length
(
)
;
i
+
+
)
{
mTexturePools
[
i
]
-
>
Clear
(
)
;
}
}
FixedSizeSmallShmemSectionAllocator
*
CompositorBridgeChild
:
:
GetTileLockAllocator
(
)
{
MOZ_ASSERT
(
IPCOpen
(
)
)
;
if
(
!
IPCOpen
(
)
)
{
return
nullptr
;
}
if
(
!
mSectionAllocator
)
{
mSectionAllocator
=
new
FixedSizeSmallShmemSectionAllocator
(
this
)
;
}
return
mSectionAllocator
;
}
PTextureChild
*
CompositorBridgeChild
:
:
CreateTexture
(
const
SurfaceDescriptor
&
aSharedData
LayersBackend
aLayersBackend
TextureFlags
aFlags
uint64_t
aSerial
)
{
return
PCompositorBridgeChild
:
:
SendPTextureConstructor
(
aSharedData
aLayersBackend
aFlags
0
aSerial
)
;
}
bool
CompositorBridgeChild
:
:
AllocUnsafeShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
ShmemAllocated
(
this
)
;
return
PCompositorBridgeChild
:
:
AllocUnsafeShmem
(
aSize
aType
aShmem
)
;
}
bool
CompositorBridgeChild
:
:
AllocShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
ShmemAllocated
(
this
)
;
return
PCompositorBridgeChild
:
:
AllocShmem
(
aSize
aType
aShmem
)
;
}
bool
CompositorBridgeChild
:
:
DeallocShmem
(
ipc
:
:
Shmem
&
aShmem
)
{
if
(
!
mCanSend
)
{
return
false
;
}
return
PCompositorBridgeChild
:
:
DeallocShmem
(
aShmem
)
;
}
widget
:
:
PCompositorWidgetChild
*
CompositorBridgeChild
:
:
AllocPCompositorWidgetChild
(
const
CompositorWidgetInitData
&
aInitData
)
{
MOZ_CRASH
(
"
Should
not
be
called
"
)
;
return
nullptr
;
}
bool
CompositorBridgeChild
:
:
DeallocPCompositorWidgetChild
(
PCompositorWidgetChild
*
aActor
)
{
#
ifdef
MOZ_WIDGET_SUPPORTS_OOP_COMPOSITING
delete
aActor
;
return
true
;
#
else
return
false
;
#
endif
}
PAPZCTreeManagerChild
*
CompositorBridgeChild
:
:
AllocPAPZCTreeManagerChild
(
const
uint64_t
&
aLayersId
)
{
APZCTreeManagerChild
*
child
=
new
APZCTreeManagerChild
(
)
;
child
-
>
AddRef
(
)
;
return
child
;
}
PAPZChild
*
CompositorBridgeChild
:
:
AllocPAPZChild
(
const
uint64_t
&
aLayersId
)
{
MOZ_CRASH
(
"
Should
not
be
called
"
)
;
return
nullptr
;
}
bool
CompositorBridgeChild
:
:
DeallocPAPZChild
(
PAPZChild
*
aActor
)
{
delete
aActor
;
return
true
;
}
bool
CompositorBridgeChild
:
:
DeallocPAPZCTreeManagerChild
(
PAPZCTreeManagerChild
*
aActor
)
{
APZCTreeManagerChild
*
parent
=
static_cast
<
APZCTreeManagerChild
*
>
(
aActor
)
;
parent
-
>
Release
(
)
;
return
true
;
}
void
CompositorBridgeChild
:
:
ProcessingError
(
Result
aCode
const
char
*
aReason
)
{
if
(
aCode
!
=
MsgDropped
)
{
gfxDevCrash
(
gfx
:
:
LogReason
:
:
ProcessingError
)
<
<
"
Processing
error
in
CompositorBridgeChild
:
"
<
<
int
(
aCode
)
;
}
}
void
CompositorBridgeChild
:
:
WillEndTransaction
(
)
{
ResetShmemCounter
(
)
;
}
void
CompositorBridgeChild
:
:
HandleFatalError
(
const
char
*
aName
const
char
*
aMsg
)
const
{
dom
:
:
ContentChild
:
:
FatalErrorIfNotUsingGPUProcess
(
aName
aMsg
OtherPid
(
)
)
;
}
PWebRenderBridgeChild
*
CompositorBridgeChild
:
:
AllocPWebRenderBridgeChild
(
const
uint64_t
&
aPipelineId
TextureFactoryIdentifier
*
)
{
WebRenderBridgeChild
*
child
=
new
WebRenderBridgeChild
(
aPipelineId
)
;
child
-
>
AddIPDLReference
(
)
;
return
child
;
}
bool
CompositorBridgeChild
:
:
DeallocPWebRenderBridgeChild
(
PWebRenderBridgeChild
*
aActor
)
{
WebRenderBridgeChild
*
child
=
static_cast
<
WebRenderBridgeChild
*
>
(
aActor
)
;
child
-
>
ReleaseIPDLReference
(
)
;
return
true
;
}
}
}
