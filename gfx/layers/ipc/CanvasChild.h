#
ifndef
mozilla_layers_CanvasChild_h
#
define
mozilla_layers_CanvasChild_h
#
include
"
mozilla
/
gfx
/
RecordedEvent
.
h
"
#
include
"
mozilla
/
ipc
/
CrossProcessSemaphore
.
h
"
#
include
"
mozilla
/
layers
/
PCanvasChild
.
h
"
#
include
"
mozilla
/
layers
/
SourceSurfaceSharedData
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
namespace
gfx
{
class
SourceSurface
;
}
namespace
layers
{
class
CanvasDrawEventRecorder
;
class
CanvasChild
final
:
public
PCanvasChild
public
SupportsWeakPtr
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
CanvasChild
)
CanvasChild
(
)
;
static
bool
Deactivated
(
)
{
return
mDeactivated
;
}
static
void
ClearCachedResources
(
)
;
ipc
:
:
IPCResult
RecvNotifyDeviceChanged
(
)
;
ipc
:
:
IPCResult
RecvDeactivate
(
)
;
ipc
:
:
IPCResult
RecvBlockCanvas
(
)
;
ipc
:
:
IPCResult
RecvNotifyRequiresRefresh
(
int64_t
aTextureId
)
;
ipc
:
:
IPCResult
RecvSnapshotShmem
(
int64_t
aTextureId
Shmem
&
&
aShmem
SnapshotShmemResolver
&
&
aResolve
)
;
void
EnsureRecorder
(
TextureType
aTextureType
)
;
void
ResumeTranslation
(
)
;
void
Destroy
(
)
;
void
OnTextureWriteLock
(
)
;
void
OnTextureForwarded
(
)
;
bool
ShouldCacheDataSurface
(
)
const
{
return
mTransactionsSinceGetDataSurface
<
kCacheDataSurfaceThreshold
;
}
bool
EnsureBeginTransaction
(
)
;
void
EndTransaction
(
)
;
bool
ShouldBeCleanedUp
(
)
const
;
already_AddRefed
<
gfx
:
:
DrawTarget
>
CreateDrawTarget
(
int64_t
aTextureId
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
)
;
void
RecordEvent
(
const
gfx
:
:
RecordedEvent
&
aEvent
)
;
already_AddRefed
<
gfx
:
:
SourceSurface
>
WrapSurface
(
const
RefPtr
<
gfx
:
:
SourceSurface
>
&
aSurface
int64_t
aTextureId
)
;
void
DetachSurface
(
const
RefPtr
<
gfx
:
:
SourceSurface
>
&
aSurface
)
;
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
GetDataSurface
(
int64_t
aTextureId
const
gfx
:
:
SourceSurface
*
aSurface
bool
aDetached
)
;
bool
ReadInto
(
int64_t
aTextureId
const
gfx
:
:
SourceSurface
*
aSurface
gfx
:
:
DataSourceSurface
*
aDataSurface
const
gfx
:
:
IntRect
&
aRect
bool
aDetached
)
;
bool
RequiresRefresh
(
int64_t
aTextureId
)
const
;
void
CleanupTexture
(
int64_t
aTextureId
)
;
protected
:
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
final
;
private
:
DISALLOW_COPY_AND_ASSIGN
(
CanvasChild
)
;
~
CanvasChild
(
)
final
;
static
const
uint32_t
kCacheDataSurfaceThreshold
=
10
;
static
bool
mDeactivated
;
static
bool
mInForeground
;
RefPtr
<
CanvasDrawEventRecorder
>
mRecorder
;
TextureType
mTextureType
=
TextureType
:
:
Unknown
;
uint32_t
mLastWriteLockCheckpoint
=
0
;
uint32_t
mTransactionsSinceGetDataSurface
=
kCacheDataSurfaceThreshold
;
std
:
:
vector
<
RefPtr
<
gfx
:
:
SourceSurface
>
>
mLastTransactionExternalSurfaces
;
struct
TextureInfo
{
ipc
:
:
Shmem
mSnapshotShmem
;
bool
mRequiresRefresh
=
false
;
}
;
std
:
:
unordered_map
<
int64_t
TextureInfo
>
mTextureInfo
;
bool
mIsInTransaction
=
false
;
bool
mHasOutstandingWriteLock
=
false
;
}
;
}
}
#
endif
