#
ifndef
mozilla_layers_CanvasChild_h
#
define
mozilla_layers_CanvasChild_h
#
include
"
mozilla
/
gfx
/
RecordedEvent
.
h
"
#
include
"
mozilla
/
ipc
/
CrossProcessSemaphore
.
h
"
#
include
"
mozilla
/
layers
/
PCanvasChild
.
h
"
#
include
"
mozilla
/
layers
/
SourceSurfaceSharedData
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
namespace
mozilla
{
namespace
dom
{
class
ThreadSafeWorkerRef
;
}
namespace
gfx
{
class
SourceSurface
;
}
namespace
layers
{
class
CanvasDrawEventRecorder
;
class
CanvasChild
final
:
public
PCanvasChild
{
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
CanvasChild
)
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
CanvasChild
)
NS_DECL_OWNINGTHREAD
explicit
CanvasChild
(
dom
:
:
ThreadSafeWorkerRef
*
aWorkerRef
)
;
bool
Init
(
)
;
static
bool
Deactivated
(
)
{
return
mDeactivated
;
}
void
ClearCachedResources
(
)
;
ipc
:
:
IPCResult
RecvNotifyDeviceChanged
(
)
;
ipc
:
:
IPCResult
RecvDeactivate
(
)
;
ipc
:
:
IPCResult
RecvBlockCanvas
(
)
;
ipc
:
:
IPCResult
RecvNotifyRequiresRefresh
(
int64_t
aTextureId
)
;
ipc
:
:
IPCResult
RecvSnapshotShmem
(
int64_t
aTextureId
Handle
&
&
aShmemHandle
uint32_t
aShmemSize
SnapshotShmemResolver
&
&
aResolve
)
;
RefPtr
<
CanvasDrawEventRecorder
>
EnsureRecorder
(
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
TextureType
aTextureType
)
;
void
Destroy
(
)
;
void
OnTextureWriteLock
(
)
;
void
OnTextureForwarded
(
)
;
bool
ShouldCacheDataSurface
(
)
const
{
return
mTransactionsSinceGetDataSurface
<
kCacheDataSurfaceThreshold
;
}
bool
EnsureBeginTransaction
(
)
;
void
EndTransaction
(
)
;
bool
ShouldBeCleanedUp
(
)
const
;
already_AddRefed
<
gfx
:
:
DrawTarget
>
CreateDrawTarget
(
int64_t
aTextureId
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
)
;
void
RecordEvent
(
const
gfx
:
:
RecordedEvent
&
aEvent
)
;
int64_t
CreateCheckpoint
(
)
;
already_AddRefed
<
gfx
:
:
SourceSurface
>
WrapSurface
(
const
RefPtr
<
gfx
:
:
SourceSurface
>
&
aSurface
int64_t
aTextureId
)
;
void
DetachSurface
(
const
RefPtr
<
gfx
:
:
SourceSurface
>
&
aSurface
)
;
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
GetDataSurface
(
int64_t
aTextureId
const
gfx
:
:
SourceSurface
*
aSurface
bool
aDetached
)
;
bool
RequiresRefresh
(
int64_t
aTextureId
)
const
;
void
CleanupTexture
(
int64_t
aTextureId
)
;
bool
IsOnOwningThread
(
)
const
;
protected
:
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
final
;
private
:
DISALLOW_COPY_AND_ASSIGN
(
CanvasChild
)
;
~
CanvasChild
(
)
final
;
bool
EnsureDataSurfaceShmem
(
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
)
MOZ_REQUIRES
(
mMutex
)
;
void
ReturnDataSurfaceShmem
(
already_AddRefed
<
ipc
:
:
SharedMemoryBasic
>
aDataSurfaceShmem
)
;
void
DropFreeBuffersWhenDormant
(
)
;
static
const
uint32_t
kCacheDataSurfaceThreshold
=
10
;
static
bool
mDeactivated
;
mutable
Mutex
mMutex
;
RefPtr
<
dom
:
:
ThreadSafeWorkerRef
>
mWorkerRef
MOZ_GUARDED_BY
(
mMutex
)
;
RefPtr
<
CanvasDrawEventRecorder
>
mRecorder
;
RefPtr
<
ipc
:
:
SharedMemoryBasic
>
mDataSurfaceShmem
MOZ_GUARDED_BY
(
mMutex
)
;
bool
mDataSurfaceShmemAvailable
MOZ_GUARDED_BY
(
mMutex
)
=
false
;
int64_t
mLastWriteLockCheckpoint
=
0
;
uint32_t
mTransactionsSinceGetDataSurface
=
kCacheDataSurfaceThreshold
;
std
:
:
vector
<
RefPtr
<
gfx
:
:
SourceSurface
>
>
mLastTransactionExternalSurfaces
;
struct
TextureInfo
{
RefPtr
<
mozilla
:
:
ipc
:
:
SharedMemoryBasic
>
mSnapshotShmem
;
bool
mRequiresRefresh
=
false
;
}
;
std
:
:
unordered_map
<
int64_t
TextureInfo
>
mTextureInfo
;
bool
mIsInTransaction
=
false
;
bool
mHasOutstandingWriteLock
=
false
;
bool
mDormant
=
false
;
bool
mIsOnWorker
=
false
;
}
;
}
}
#
endif
