#
include
"
SharedRGBImage
.
h
"
#
include
"
ImageTypes
.
h
"
#
include
"
Shmem
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
layers
/
BufferTexture
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
layers
/
ImageClient
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeChild
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRect
.
h
"
#
define
MAX_FRAME_SIZE
(
16
*
1024
*
1024
)
namespace
mozilla
{
namespace
layers
{
already_AddRefed
<
Image
>
CreateSharedRGBImage
(
ImageContainer
*
aImageContainer
gfx
:
:
IntSize
aSize
gfxImageFormat
aImageFormat
)
{
NS_ASSERTION
(
aImageFormat
=
=
gfx
:
:
SurfaceFormat
:
:
A8R8G8B8_UINT32
|
|
aImageFormat
=
=
gfx
:
:
SurfaceFormat
:
:
X8R8G8B8_UINT32
|
|
aImageFormat
=
=
gfx
:
:
SurfaceFormat
:
:
R5G6B5_UINT16
"
RGB
formats
supported
only
"
)
;
if
(
!
aImageContainer
)
{
NS_WARNING
(
"
No
ImageContainer
to
allocate
SharedRGBImage
"
)
;
return
nullptr
;
}
RefPtr
<
SharedRGBImage
>
rgbImage
=
aImageContainer
-
>
CreateSharedRGBImage
(
)
;
if
(
!
rgbImage
)
{
NS_WARNING
(
"
Failed
to
create
SharedRGBImage
"
)
;
return
nullptr
;
}
if
(
!
rgbImage
-
>
Allocate
(
aSize
gfx
:
:
ImageFormatToSurfaceFormat
(
aImageFormat
)
)
)
{
NS_WARNING
(
"
Failed
to
allocate
a
shared
image
"
)
;
return
nullptr
;
}
return
rgbImage
.
forget
(
)
;
}
SharedRGBImage
:
:
SharedRGBImage
(
ImageClient
*
aCompositable
)
:
Image
(
nullptr
ImageFormat
:
:
SHARED_RGB
)
mCompositable
(
aCompositable
)
{
MOZ_COUNT_CTOR
(
SharedRGBImage
)
;
}
SharedRGBImage
:
:
~
SharedRGBImage
(
)
{
MOZ_COUNT_DTOR
(
SharedRGBImage
)
;
}
bool
SharedRGBImage
:
:
Allocate
(
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
)
{
mSize
=
aSize
;
mTextureClient
=
mCompositable
-
>
CreateBufferTextureClient
(
aFormat
aSize
gfx
:
:
BackendType
:
:
NONE
TextureFlags
:
:
DEFAULT
)
;
return
!
!
mTextureClient
;
}
uint8_t
*
SharedRGBImage
:
:
GetBuffer
(
)
const
{
MappedTextureData
mapped
;
if
(
mTextureClient
&
&
mTextureClient
-
>
BorrowMappedData
(
mapped
)
)
{
return
mapped
.
data
;
}
return
0
;
}
gfx
:
:
IntSize
SharedRGBImage
:
:
GetSize
(
)
const
{
return
mSize
;
}
TextureClient
*
SharedRGBImage
:
:
GetTextureClient
(
KnowsCompositor
*
aForwarder
)
{
return
mTextureClient
.
get
(
)
;
}
static
void
ReleaseTextureClient
(
void
*
aData
)
{
RELEASE_MANUALLY
(
static_cast
<
TextureClient
*
>
(
aData
)
)
;
}
static
gfx
:
:
UserDataKey
sTextureClientKey
;
already_AddRefed
<
gfx
:
:
SourceSurface
>
SharedRGBImage
:
:
GetAsSourceSurface
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Must
be
main
thread
"
)
;
if
(
mSourceSurface
)
{
RefPtr
<
gfx
:
:
SourceSurface
>
surface
(
mSourceSurface
)
;
return
surface
.
forget
(
)
;
}
RefPtr
<
gfx
:
:
SourceSurface
>
surface
;
{
BufferTextureData
*
decoded_buffer
=
mTextureClient
-
>
GetInternalData
(
)
-
>
AsBufferTextureData
(
)
;
RefPtr
<
gfx
:
:
DrawTarget
>
drawTarget
=
decoded_buffer
-
>
BorrowDrawTarget
(
)
;
if
(
!
drawTarget
)
{
return
nullptr
;
}
surface
=
drawTarget
-
>
Snapshot
(
)
;
if
(
!
surface
)
{
return
nullptr
;
}
if
(
!
surface
-
>
GetUserData
(
&
sTextureClientKey
)
)
{
surface
-
>
AddUserData
(
&
sTextureClientKey
mTextureClient
ReleaseTextureClient
)
;
ADDREF_MANUALLY
(
mTextureClient
)
;
}
}
mSourceSurface
=
surface
;
return
surface
.
forget
(
)
;
}
}
}
