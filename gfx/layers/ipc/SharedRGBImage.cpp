#
include
"
SharedRGBImage
.
h
"
#
include
"
ImageTypes
.
h
"
#
include
"
Shmem
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
layers
/
BufferTexture
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
layers
/
ImageClient
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
layers
/
TextureClientRecycleAllocator
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeChild
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRect
.
h
"
#
define
MAX_FRAME_SIZE
(
16
*
1024
*
1024
)
namespace
mozilla
{
namespace
layers
{
class
TextureClientForRawBufferAccessAllocationHelper
:
public
ITextureClientAllocationHelper
{
public
:
TextureClientForRawBufferAccessAllocationHelper
(
gfx
:
:
SurfaceFormat
aFormat
gfx
:
:
IntSize
aSize
TextureFlags
aTextureFlags
)
:
ITextureClientAllocationHelper
(
aFormat
aSize
BackendSelector
:
:
Content
aTextureFlags
ALLOC_DEFAULT
)
{
}
bool
IsCompatible
(
TextureClient
*
aTextureClient
)
override
{
bool
ret
=
aTextureClient
-
>
GetFormat
(
)
=
=
mFormat
&
&
aTextureClient
-
>
GetSize
(
)
=
=
mSize
;
return
ret
;
}
already_AddRefed
<
TextureClient
>
Allocate
(
KnowsCompositor
*
aAllocator
)
override
{
return
TextureClient
:
:
CreateForRawBufferAccess
(
aAllocator
mFormat
mSize
gfx
:
:
BackendType
:
:
NONE
mTextureFlags
)
;
}
}
;
SharedRGBImage
:
:
SharedRGBImage
(
ImageClient
*
aCompositable
)
:
Image
(
nullptr
ImageFormat
:
:
SHARED_RGB
)
mCompositable
(
aCompositable
)
{
MOZ_COUNT_CTOR
(
SharedRGBImage
)
;
}
SharedRGBImage
:
:
SharedRGBImage
(
TextureClientRecycleAllocator
*
aRecycleAllocator
)
:
Image
(
nullptr
ImageFormat
:
:
SHARED_RGB
)
mRecycleAllocator
(
aRecycleAllocator
)
{
MOZ_COUNT_CTOR
(
SharedRGBImage
)
;
}
SharedRGBImage
:
:
~
SharedRGBImage
(
)
{
MOZ_COUNT_DTOR
(
SharedRGBImage
)
;
NS_ReleaseOnMainThread
(
"
SharedRGBImage
:
:
mSourceSurface
"
mSourceSurface
.
forget
(
)
)
;
}
TextureClientRecycleAllocator
*
SharedRGBImage
:
:
RecycleAllocator
(
)
{
static
const
uint32_t
MAX_POOLED_VIDEO_COUNT
=
5
;
if
(
!
mRecycleAllocator
&
&
mCompositable
)
{
if
(
!
mCompositable
-
>
HasTextureClientRecycler
(
)
)
{
mCompositable
-
>
GetTextureClientRecycler
(
)
-
>
SetMaxPoolSize
(
MAX_POOLED_VIDEO_COUNT
)
;
}
mRecycleAllocator
=
mCompositable
-
>
GetTextureClientRecycler
(
)
;
}
return
mRecycleAllocator
;
}
bool
SharedRGBImage
:
:
Allocate
(
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
)
{
mSize
=
aSize
;
TextureFlags
flags
=
mCompositable
?
mCompositable
-
>
GetTextureFlags
(
)
:
TextureFlags
:
:
DEFAULT
;
{
TextureClientForRawBufferAccessAllocationHelper
helper
(
aFormat
aSize
flags
)
;
mTextureClient
=
RecycleAllocator
(
)
-
>
CreateOrRecycle
(
helper
)
;
}
return
!
!
mTextureClient
;
}
gfx
:
:
IntSize
SharedRGBImage
:
:
GetSize
(
)
const
{
return
mSize
;
}
TextureClient
*
SharedRGBImage
:
:
GetTextureClient
(
KnowsCompositor
*
aKnowsCompositor
)
{
return
mTextureClient
.
get
(
)
;
}
static
void
ReleaseTextureClient
(
void
*
aData
)
{
RELEASE_MANUALLY
(
static_cast
<
TextureClient
*
>
(
aData
)
)
;
}
static
gfx
:
:
UserDataKey
sTextureClientKey
;
already_AddRefed
<
gfx
:
:
SourceSurface
>
SharedRGBImage
:
:
GetAsSourceSurface
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Must
be
main
thread
"
)
;
if
(
mSourceSurface
)
{
RefPtr
<
gfx
:
:
SourceSurface
>
surface
(
mSourceSurface
)
;
return
surface
.
forget
(
)
;
}
RefPtr
<
gfx
:
:
SourceSurface
>
surface
;
{
BufferTextureData
*
decoded_buffer
=
mTextureClient
-
>
GetInternalData
(
)
-
>
AsBufferTextureData
(
)
;
RefPtr
<
gfx
:
:
DrawTarget
>
drawTarget
=
decoded_buffer
-
>
BorrowDrawTarget
(
)
;
if
(
!
drawTarget
)
{
return
nullptr
;
}
surface
=
drawTarget
-
>
Snapshot
(
)
;
if
(
!
surface
)
{
return
nullptr
;
}
if
(
!
surface
-
>
GetUserData
(
&
sTextureClientKey
)
)
{
surface
-
>
AddUserData
(
&
sTextureClientKey
mTextureClient
ReleaseTextureClient
)
;
ADDREF_MANUALLY
(
mTextureClient
)
;
}
}
mSourceSurface
=
surface
;
return
surface
.
forget
(
)
;
}
}
}
