#
include
"
CompositableTransactionParent
.
h
"
#
include
"
CompositableHost
.
h
"
#
include
"
CompositorBridgeParent
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
Layers
.
h
"
#
include
"
RenderTrace
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
ContentHost
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
LayerManagerComposite
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
mozilla
/
layers
/
TextureHostOGL
.
h
"
#
include
"
mozilla
/
layers
/
TiledContentHost
.
h
"
#
include
"
mozilla
/
layers
/
PaintedLayerComposite
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsRegion
.
h
"
namespace
mozilla
{
namespace
layers
{
class
ClientTiledLayerBuffer
;
class
Compositor
;
static
bool
ScheduleComposition
(
CompositableHost
*
aCompositable
)
{
uint64_t
id
=
aCompositable
-
>
GetCompositorID
(
)
;
if
(
!
id
)
{
return
false
;
}
CompositorBridgeParent
*
cp
=
CompositorBridgeParent
:
:
GetCompositorBridgeParent
(
id
)
;
if
(
!
cp
)
{
return
false
;
}
cp
-
>
ScheduleComposition
(
)
;
return
true
;
}
bool
CompositableParentManager
:
:
ReceiveCompositableUpdate
(
const
CompositableOperation
&
aEdit
)
{
RefPtr
<
CompositableHost
>
compositable
=
FindCompositable
(
aEdit
.
compositable
(
)
)
;
if
(
!
compositable
)
{
return
false
;
}
if
(
compositable
-
>
GetCompositor
(
)
&
&
!
compositable
-
>
GetCompositor
(
)
-
>
IsValid
(
)
)
{
return
true
;
}
switch
(
aEdit
.
detail
(
)
.
type
(
)
)
{
case
CompositableOperationDetail
:
:
TOpPaintTextureRegion
:
{
MOZ_LAYERS_LOG
(
(
"
[
ParentSide
]
Paint
PaintedLayer
"
)
)
;
const
OpPaintTextureRegion
&
op
=
aEdit
.
detail
(
)
.
get_OpPaintTextureRegion
(
)
;
Layer
*
layer
=
compositable
-
>
GetLayer
(
)
;
if
(
!
layer
|
|
layer
-
>
GetType
(
)
!
=
Layer
:
:
TYPE_PAINTED
)
{
return
false
;
}
PaintedLayerComposite
*
thebes
=
static_cast
<
PaintedLayerComposite
*
>
(
layer
)
;
const
ThebesBufferData
&
bufferData
=
op
.
bufferData
(
)
;
RenderTraceInvalidateStart
(
thebes
"
FF00FF
"
op
.
updatedRegion
(
)
.
GetBounds
(
)
)
;
if
(
!
compositable
-
>
UpdateThebes
(
bufferData
op
.
updatedRegion
(
)
thebes
-
>
GetValidRegion
(
)
)
)
{
return
false
;
}
RenderTraceInvalidateEnd
(
thebes
"
FF00FF
"
)
;
break
;
}
case
CompositableOperationDetail
:
:
TOpUseTiledLayerBuffer
:
{
MOZ_LAYERS_LOG
(
(
"
[
ParentSide
]
Paint
TiledLayerBuffer
"
)
)
;
const
OpUseTiledLayerBuffer
&
op
=
aEdit
.
detail
(
)
.
get_OpUseTiledLayerBuffer
(
)
;
TiledContentHost
*
tiledHost
=
compositable
-
>
AsTiledContentHost
(
)
;
NS_ASSERTION
(
tiledHost
"
The
compositable
is
not
tiled
"
)
;
const
SurfaceDescriptorTiles
&
tileDesc
=
op
.
tileLayerDescriptor
(
)
;
bool
success
=
tiledHost
-
>
UseTiledLayerBuffer
(
this
tileDesc
)
;
const
InfallibleTArray
<
TileDescriptor
>
&
tileDescriptors
=
tileDesc
.
tiles
(
)
;
for
(
size_t
i
=
0
;
i
<
tileDescriptors
.
Length
(
)
;
i
+
+
)
{
const
TileDescriptor
&
tileDesc
=
tileDescriptors
[
i
]
;
if
(
tileDesc
.
type
(
)
!
=
TileDescriptor
:
:
TTexturedTileDescriptor
)
{
continue
;
}
const
TexturedTileDescriptor
&
texturedDesc
=
tileDesc
.
get_TexturedTileDescriptor
(
)
;
RefPtr
<
TextureHost
>
texture
=
TextureHost
:
:
AsTextureHost
(
texturedDesc
.
textureParent
(
)
)
;
if
(
texture
)
{
texture
-
>
SetLastFwdTransactionId
(
mFwdTransactionId
)
;
MOZ_ASSERT
(
texture
-
>
NumCompositableRefs
(
)
>
0
)
;
}
if
(
texturedDesc
.
textureOnWhite
(
)
.
type
(
)
=
=
MaybeTexture
:
:
TPTextureParent
)
{
texture
=
TextureHost
:
:
AsTextureHost
(
texturedDesc
.
textureOnWhite
(
)
.
get_PTextureParent
(
)
)
;
if
(
texture
)
{
texture
-
>
SetLastFwdTransactionId
(
mFwdTransactionId
)
;
MOZ_ASSERT
(
texture
-
>
NumCompositableRefs
(
)
>
0
)
;
}
}
}
if
(
!
success
)
{
return
false
;
}
break
;
}
case
CompositableOperationDetail
:
:
TOpRemoveTexture
:
{
const
OpRemoveTexture
&
op
=
aEdit
.
detail
(
)
.
get_OpRemoveTexture
(
)
;
RefPtr
<
TextureHost
>
tex
=
TextureHost
:
:
AsTextureHost
(
op
.
textureParent
(
)
)
;
MOZ_ASSERT
(
tex
.
get
(
)
)
;
compositable
-
>
RemoveTextureHost
(
tex
)
;
break
;
}
case
CompositableOperationDetail
:
:
TOpUseTexture
:
{
const
OpUseTexture
&
op
=
aEdit
.
detail
(
)
.
get_OpUseTexture
(
)
;
AutoTArray
<
CompositableHost
:
:
TimedTexture
4
>
textures
;
for
(
auto
&
timedTexture
:
op
.
textures
(
)
)
{
CompositableHost
:
:
TimedTexture
*
t
=
textures
.
AppendElement
(
)
;
t
-
>
mTexture
=
TextureHost
:
:
AsTextureHost
(
timedTexture
.
textureParent
(
)
)
;
MOZ_ASSERT
(
t
-
>
mTexture
)
;
t
-
>
mTimeStamp
=
timedTexture
.
timeStamp
(
)
;
t
-
>
mPictureRect
=
timedTexture
.
picture
(
)
;
t
-
>
mFrameID
=
timedTexture
.
frameID
(
)
;
t
-
>
mProducerID
=
timedTexture
.
producerID
(
)
;
t
-
>
mTexture
-
>
DeserializeReadLock
(
timedTexture
.
sharedLock
(
)
this
)
;
}
if
(
textures
.
Length
(
)
>
0
)
{
compositable
-
>
UseTextureHost
(
textures
)
;
for
(
auto
&
timedTexture
:
op
.
textures
(
)
)
{
RefPtr
<
TextureHost
>
texture
=
TextureHost
:
:
AsTextureHost
(
timedTexture
.
textureParent
(
)
)
;
if
(
texture
)
{
texture
-
>
SetLastFwdTransactionId
(
mFwdTransactionId
)
;
MOZ_ASSERT
(
texture
-
>
NumCompositableRefs
(
)
>
0
)
;
}
}
}
if
(
UsesImageBridge
(
)
&
&
compositable
-
>
GetLayer
(
)
)
{
ScheduleComposition
(
compositable
)
;
}
break
;
}
case
CompositableOperationDetail
:
:
TOpUseComponentAlphaTextures
:
{
const
OpUseComponentAlphaTextures
&
op
=
aEdit
.
detail
(
)
.
get_OpUseComponentAlphaTextures
(
)
;
RefPtr
<
TextureHost
>
texOnBlack
=
TextureHost
:
:
AsTextureHost
(
op
.
textureOnBlackParent
(
)
)
;
RefPtr
<
TextureHost
>
texOnWhite
=
TextureHost
:
:
AsTextureHost
(
op
.
textureOnWhiteParent
(
)
)
;
texOnBlack
-
>
DeserializeReadLock
(
op
.
sharedLockBlack
(
)
this
)
;
texOnWhite
-
>
DeserializeReadLock
(
op
.
sharedLockWhite
(
)
this
)
;
MOZ_ASSERT
(
texOnBlack
&
&
texOnWhite
)
;
compositable
-
>
UseComponentAlphaTextures
(
texOnBlack
texOnWhite
)
;
if
(
texOnBlack
)
{
texOnBlack
-
>
SetLastFwdTransactionId
(
mFwdTransactionId
)
;
MOZ_ASSERT
(
texOnBlack
-
>
NumCompositableRefs
(
)
>
0
)
;
}
if
(
texOnWhite
)
{
texOnWhite
-
>
SetLastFwdTransactionId
(
mFwdTransactionId
)
;
MOZ_ASSERT
(
texOnWhite
-
>
NumCompositableRefs
(
)
>
0
)
;
}
if
(
UsesImageBridge
(
)
)
{
ScheduleComposition
(
compositable
)
;
}
break
;
}
default
:
{
MOZ_ASSERT
(
false
"
bad
type
"
)
;
}
}
return
true
;
}
void
CompositableParentManager
:
:
DestroyActor
(
const
OpDestroy
&
aOp
)
{
switch
(
aOp
.
type
(
)
)
{
case
OpDestroy
:
:
TPTextureParent
:
{
auto
actor
=
aOp
.
get_PTextureParent
(
)
;
TextureHost
:
:
ReceivedDestroy
(
actor
)
;
break
;
}
case
OpDestroy
:
:
TCompositableHandle
:
{
ReleaseCompositable
(
aOp
.
get_CompositableHandle
(
)
)
;
break
;
}
default
:
{
MOZ_ASSERT
(
false
"
unsupported
type
"
)
;
}
}
}
RefPtr
<
CompositableHost
>
CompositableParentManager
:
:
AddCompositable
(
const
CompositableHandle
&
aHandle
const
TextureInfo
&
aInfo
)
{
if
(
mCompositables
.
find
(
aHandle
.
Value
(
)
)
!
=
mCompositables
.
end
(
)
)
{
NS_ERROR
(
"
Client
should
not
allocate
duplicate
handles
"
)
;
return
nullptr
;
}
if
(
!
aHandle
)
{
NS_ERROR
(
"
Client
should
not
allocate
0
as
a
handle
"
)
;
return
nullptr
;
}
RefPtr
<
CompositableHost
>
host
=
CompositableHost
:
:
Create
(
aInfo
)
;
if
(
!
host
)
{
return
nullptr
;
}
mCompositables
[
aHandle
.
Value
(
)
]
=
host
;
return
host
;
}
RefPtr
<
CompositableHost
>
CompositableParentManager
:
:
FindCompositable
(
const
CompositableHandle
&
aHandle
)
{
auto
iter
=
mCompositables
.
find
(
aHandle
.
Value
(
)
)
;
if
(
iter
=
=
mCompositables
.
end
(
)
)
{
return
nullptr
;
}
return
iter
-
>
second
;
}
void
CompositableParentManager
:
:
ReleaseCompositable
(
const
CompositableHandle
&
aHandle
)
{
auto
iter
=
mCompositables
.
find
(
aHandle
.
Value
(
)
)
;
if
(
iter
=
=
mCompositables
.
end
(
)
)
{
return
;
}
RefPtr
<
CompositableHost
>
host
=
iter
-
>
second
;
mCompositables
.
erase
(
iter
)
;
host
-
>
Detach
(
nullptr
CompositableHost
:
:
FORCE_DETACH
)
;
}
}
}
