#
include
"
CompositableTransactionParent
.
h
"
#
include
"
CompositableHost
.
h
"
#
include
"
CompositorBridgeParent
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
Layers
.
h
"
#
include
"
RenderTrace
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
ContentHost
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
SharedBufferManagerParent
.
h
"
#
include
"
mozilla
/
layers
/
LayerManagerComposite
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
mozilla
/
layers
/
TextureHostOGL
.
h
"
#
include
"
mozilla
/
layers
/
TiledContentHost
.
h
"
#
include
"
mozilla
/
layers
/
PaintedLayerComposite
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
unused
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsRegion
.
h
"
namespace
mozilla
{
namespace
layers
{
class
ClientTiledLayerBuffer
;
class
Compositor
;
static
bool
ScheduleComposition
(
CompositableHost
*
aCompositable
)
{
uint64_t
id
=
aCompositable
-
>
GetCompositorID
(
)
;
if
(
!
id
)
{
return
false
;
}
CompositorBridgeParent
*
cp
=
CompositorBridgeParent
:
:
GetCompositor
(
id
)
;
if
(
!
cp
)
{
return
false
;
}
cp
-
>
ScheduleComposition
(
)
;
return
true
;
}
#
if
defined
(
DEBUG
)
|
|
defined
(
MOZ_WIDGET_GONK
)
static
bool
ValidatePictureRect
(
const
mozilla
:
:
gfx
:
:
IntSize
&
aSize
const
nsIntRect
&
aPictureRect
)
{
return
nsIntRect
(
0
0
aSize
.
width
aSize
.
height
)
.
Contains
(
aPictureRect
)
&
&
!
aPictureRect
.
IsEmpty
(
)
;
}
#
endif
bool
CompositableParentManager
:
:
ReceiveCompositableUpdate
(
const
CompositableOperation
&
aEdit
EditReplyVector
&
replyv
)
{
CompositableHost
*
compositable
=
CompositableHost
:
:
FromIPDLActor
(
aEdit
.
compositableParent
(
)
)
;
switch
(
aEdit
.
detail
(
)
.
type
(
)
)
{
case
CompositableOperationDetail
:
:
TOpPaintTextureRegion
:
{
MOZ_LAYERS_LOG
(
(
"
[
ParentSide
]
Paint
PaintedLayer
"
)
)
;
const
OpPaintTextureRegion
&
op
=
aEdit
.
detail
(
)
.
get_OpPaintTextureRegion
(
)
;
Layer
*
layer
=
compositable
-
>
GetLayer
(
)
;
if
(
!
layer
|
|
layer
-
>
GetType
(
)
!
=
Layer
:
:
TYPE_PAINTED
)
{
return
false
;
}
PaintedLayerComposite
*
thebes
=
static_cast
<
PaintedLayerComposite
*
>
(
layer
)
;
const
ThebesBufferData
&
bufferData
=
op
.
bufferData
(
)
;
RenderTraceInvalidateStart
(
thebes
"
FF00FF
"
op
.
updatedRegion
(
)
.
GetBounds
(
)
)
;
nsIntRegion
frontUpdatedRegion
;
if
(
!
compositable
-
>
UpdateThebes
(
bufferData
op
.
updatedRegion
(
)
thebes
-
>
GetValidRegion
(
)
&
frontUpdatedRegion
)
)
{
return
false
;
}
replyv
.
push_back
(
OpContentBufferSwap
(
aEdit
.
compositableParent
(
)
nullptr
frontUpdatedRegion
)
)
;
RenderTraceInvalidateEnd
(
thebes
"
FF00FF
"
)
;
break
;
}
case
CompositableOperationDetail
:
:
TOpUseTiledLayerBuffer
:
{
MOZ_LAYERS_LOG
(
(
"
[
ParentSide
]
Paint
TiledLayerBuffer
"
)
)
;
const
OpUseTiledLayerBuffer
&
op
=
aEdit
.
detail
(
)
.
get_OpUseTiledLayerBuffer
(
)
;
TiledContentHost
*
tiledHost
=
compositable
-
>
AsTiledContentHost
(
)
;
NS_ASSERTION
(
tiledHost
"
The
compositable
is
not
tiled
"
)
;
const
SurfaceDescriptorTiles
&
tileDesc
=
op
.
tileLayerDescriptor
(
)
;
bool
success
=
tiledHost
-
>
UseTiledLayerBuffer
(
this
tileDesc
)
;
if
(
!
success
)
{
return
false
;
}
break
;
}
case
CompositableOperationDetail
:
:
TOpRemoveTexture
:
{
const
OpRemoveTexture
&
op
=
aEdit
.
detail
(
)
.
get_OpRemoveTexture
(
)
;
RefPtr
<
TextureHost
>
tex
=
TextureHost
:
:
AsTextureHost
(
op
.
textureParent
(
)
)
;
MOZ_ASSERT
(
tex
.
get
(
)
)
;
compositable
-
>
RemoveTextureHost
(
tex
)
;
SendFenceHandleIfPresent
(
op
.
textureParent
(
)
)
;
break
;
}
case
CompositableOperationDetail
:
:
TOpRemoveTextureAsync
:
{
const
OpRemoveTextureAsync
&
op
=
aEdit
.
detail
(
)
.
get_OpRemoveTextureAsync
(
)
;
RefPtr
<
TextureHost
>
tex
=
TextureHost
:
:
AsTextureHost
(
op
.
textureParent
(
)
)
;
MOZ_ASSERT
(
tex
.
get
(
)
)
;
compositable
-
>
RemoveTextureHost
(
tex
)
;
if
(
!
UsesImageBridge
(
)
&
&
ImageBridgeParent
:
:
GetInstance
(
GetChildProcessId
(
)
)
)
{
ImageBridgeParent
:
:
AppendDeliverFenceMessage
(
GetChildProcessId
(
)
op
.
holderId
(
)
op
.
transactionId
(
)
op
.
textureParent
(
)
)
;
ImageBridgeParent
:
:
ReplyRemoveTexture
(
GetChildProcessId
(
)
OpReplyRemoveTexture
(
op
.
holderId
(
)
op
.
transactionId
(
)
)
)
;
}
else
{
SendFenceHandleIfPresent
(
op
.
textureParent
(
)
)
;
ReplyRemoveTexture
(
OpReplyRemoveTexture
(
op
.
holderId
(
)
op
.
transactionId
(
)
)
)
;
}
break
;
}
case
CompositableOperationDetail
:
:
TOpUseTexture
:
{
const
OpUseTexture
&
op
=
aEdit
.
detail
(
)
.
get_OpUseTexture
(
)
;
AutoTArray
<
CompositableHost
:
:
TimedTexture
4
>
textures
;
for
(
auto
&
timedTexture
:
op
.
textures
(
)
)
{
CompositableHost
:
:
TimedTexture
*
t
=
textures
.
AppendElement
(
)
;
t
-
>
mTexture
=
TextureHost
:
:
AsTextureHost
(
timedTexture
.
textureParent
(
)
)
;
MOZ_ASSERT
(
t
-
>
mTexture
)
;
t
-
>
mTimeStamp
=
timedTexture
.
timeStamp
(
)
;
t
-
>
mPictureRect
=
timedTexture
.
picture
(
)
;
t
-
>
mFrameID
=
timedTexture
.
frameID
(
)
;
t
-
>
mProducerID
=
timedTexture
.
producerID
(
)
;
t
-
>
mInputFrameID
=
timedTexture
.
inputFrameID
(
)
;
MOZ_ASSERT
(
ValidatePictureRect
(
t
-
>
mTexture
-
>
GetSize
(
)
t
-
>
mPictureRect
)
)
;
MaybeFence
maybeFence
=
timedTexture
.
fence
(
)
;
if
(
maybeFence
.
type
(
)
=
=
MaybeFence
:
:
TFenceHandle
)
{
FenceHandle
fence
=
maybeFence
.
get_FenceHandle
(
)
;
if
(
fence
.
IsValid
(
)
)
{
t
-
>
mTexture
-
>
SetAcquireFenceHandle
(
fence
)
;
}
}
}
compositable
-
>
UseTextureHost
(
textures
)
;
if
(
UsesImageBridge
(
)
&
&
compositable
-
>
GetLayer
(
)
)
{
ScheduleComposition
(
compositable
)
;
}
break
;
}
case
CompositableOperationDetail
:
:
TOpUseComponentAlphaTextures
:
{
const
OpUseComponentAlphaTextures
&
op
=
aEdit
.
detail
(
)
.
get_OpUseComponentAlphaTextures
(
)
;
RefPtr
<
TextureHost
>
texOnBlack
=
TextureHost
:
:
AsTextureHost
(
op
.
textureOnBlackParent
(
)
)
;
RefPtr
<
TextureHost
>
texOnWhite
=
TextureHost
:
:
AsTextureHost
(
op
.
textureOnWhiteParent
(
)
)
;
MOZ_ASSERT
(
texOnBlack
&
&
texOnWhite
)
;
compositable
-
>
UseComponentAlphaTextures
(
texOnBlack
texOnWhite
)
;
if
(
UsesImageBridge
(
)
)
{
ScheduleComposition
(
compositable
)
;
}
break
;
}
#
ifdef
MOZ_WIDGET_GONK
case
CompositableOperationDetail
:
:
TOpUseOverlaySource
:
{
const
OpUseOverlaySource
&
op
=
aEdit
.
detail
(
)
.
get_OpUseOverlaySource
(
)
;
if
(
!
ValidatePictureRect
(
op
.
overlay
(
)
.
size
(
)
op
.
picture
(
)
)
)
{
return
false
;
}
compositable
-
>
UseOverlaySource
(
op
.
overlay
(
)
op
.
picture
(
)
)
;
break
;
}
#
endif
default
:
{
MOZ_ASSERT
(
false
"
bad
type
"
)
;
}
}
return
true
;
}
void
CompositableParentManager
:
:
DestroyActor
(
const
OpDestroy
&
aOp
)
{
switch
(
aOp
.
type
(
)
)
{
case
OpDestroy
:
:
TPTextureParent
:
{
auto
actor
=
aOp
.
get_PTextureParent
(
)
;
TextureHost
:
:
ReceivedDestroy
(
actor
)
;
break
;
}
case
OpDestroy
:
:
TPCompositableParent
:
{
auto
actor
=
aOp
.
get_PCompositableParent
(
)
;
CompositableHost
:
:
ReceivedDestroy
(
actor
)
;
break
;
}
default
:
{
MOZ_ASSERT
(
false
"
unsupported
type
"
)
;
}
}
}
void
CompositableParentManager
:
:
SendPendingAsyncMessages
(
)
{
if
(
mPendingAsyncMessage
.
empty
(
)
)
{
return
;
}
#
if
defined
(
OS_POSIX
)
static
const
uint32_t
kMaxMessageNumber
=
FileDescriptorSet
:
:
MAX_DESCRIPTORS_PER_MESSAGE
;
#
else
static
const
uint32_t
kMaxMessageNumber
=
250
;
#
endif
InfallibleTArray
<
AsyncParentMessageData
>
messages
;
messages
.
SetCapacity
(
mPendingAsyncMessage
.
size
(
)
)
;
for
(
size_t
i
=
0
;
i
<
mPendingAsyncMessage
.
size
(
)
;
i
+
+
)
{
messages
.
AppendElement
(
mPendingAsyncMessage
[
i
]
)
;
if
(
messages
.
Length
(
)
>
=
kMaxMessageNumber
)
{
SendAsyncMessage
(
messages
)
;
messages
.
Clear
(
)
;
}
}
if
(
messages
.
Length
(
)
>
0
)
{
SendAsyncMessage
(
messages
)
;
}
mPendingAsyncMessage
.
clear
(
)
;
}
}
}
