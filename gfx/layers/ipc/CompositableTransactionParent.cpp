#
include
"
CompositableTransactionParent
.
h
"
#
include
"
CompositableHost
.
h
"
#
include
"
CompositorBridgeParent
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
Layers
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
ContentHost
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
mozilla
/
layers
/
TextureHostOGL
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsRegion
.
h
"
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
mozilla
/
layers
/
AndroidHardwareBuffer
.
h
"
#
endif
namespace
mozilla
{
namespace
layers
{
class
ClientTiledLayerBuffer
;
class
Compositor
;
static
bool
ScheduleComposition
(
CompositableHost
*
aCompositable
)
{
uint64_t
id
=
aCompositable
-
>
GetCompositorBridgeID
(
)
;
if
(
!
id
)
{
return
false
;
}
CompositorBridgeParent
*
cp
=
CompositorBridgeParent
:
:
GetCompositorBridgeParent
(
id
)
;
if
(
!
cp
)
{
return
false
;
}
cp
-
>
ScheduleComposition
(
)
;
return
true
;
}
bool
CompositableParentManager
:
:
ReceiveCompositableUpdate
(
const
CompositableOperation
&
aEdit
)
{
RefPtr
<
CompositableHost
>
compositable
=
FindCompositable
(
aEdit
.
compositable
(
)
)
;
if
(
!
compositable
)
{
return
false
;
}
return
ReceiveCompositableUpdate
(
aEdit
.
detail
(
)
WrapNotNull
(
compositable
)
)
;
}
bool
CompositableParentManager
:
:
ReceiveCompositableUpdate
(
const
CompositableOperationDetail
&
aDetail
NotNull
<
CompositableHost
*
>
aCompositable
)
{
if
(
TextureSourceProvider
*
provider
=
aCompositable
-
>
GetTextureSourceProvider
(
)
)
{
if
(
!
provider
-
>
IsValid
(
)
)
{
return
false
;
}
}
switch
(
aDetail
.
type
(
)
)
{
case
CompositableOperationDetail
:
:
TOpPaintTextureRegion
:
{
return
false
;
}
case
CompositableOperationDetail
:
:
TOpUseTiledLayerBuffer
:
{
return
false
;
}
case
CompositableOperationDetail
:
:
TOpRemoveTexture
:
{
const
OpRemoveTexture
&
op
=
aDetail
.
get_OpRemoveTexture
(
)
;
RefPtr
<
TextureHost
>
tex
=
TextureHost
:
:
AsTextureHost
(
op
.
textureParent
(
)
)
;
MOZ_ASSERT
(
tex
.
get
(
)
)
;
aCompositable
-
>
RemoveTextureHost
(
tex
)
;
break
;
}
case
CompositableOperationDetail
:
:
TOpUseTexture
:
{
const
OpUseTexture
&
op
=
aDetail
.
get_OpUseTexture
(
)
;
AutoTArray
<
CompositableHost
:
:
TimedTexture
4
>
textures
;
for
(
auto
&
timedTexture
:
op
.
textures
(
)
)
{
CompositableHost
:
:
TimedTexture
*
t
=
textures
.
AppendElement
(
)
;
t
-
>
mTexture
=
TextureHost
:
:
AsTextureHost
(
timedTexture
.
textureParent
(
)
)
;
MOZ_ASSERT
(
t
-
>
mTexture
)
;
t
-
>
mTimeStamp
=
timedTexture
.
timeStamp
(
)
;
t
-
>
mPictureRect
=
timedTexture
.
picture
(
)
;
t
-
>
mFrameID
=
timedTexture
.
frameID
(
)
;
t
-
>
mProducerID
=
timedTexture
.
producerID
(
)
;
if
(
timedTexture
.
readLocked
(
)
)
{
t
-
>
mTexture
-
>
SetReadLocked
(
)
;
}
}
if
(
textures
.
Length
(
)
>
0
)
{
aCompositable
-
>
UseTextureHost
(
textures
)
;
for
(
auto
&
timedTexture
:
op
.
textures
(
)
)
{
RefPtr
<
TextureHost
>
texture
=
TextureHost
:
:
AsTextureHost
(
timedTexture
.
textureParent
(
)
)
;
if
(
texture
)
{
texture
-
>
SetLastFwdTransactionId
(
mFwdTransactionId
)
;
MOZ_ASSERT
(
texture
-
>
NumCompositableRefs
(
)
>
0
)
;
}
}
}
if
(
UsesImageBridge
(
)
&
&
aCompositable
-
>
GetLayer
(
)
)
{
ScheduleComposition
(
aCompositable
)
;
}
break
;
}
case
CompositableOperationDetail
:
:
TOpUseComponentAlphaTextures
:
{
const
OpUseComponentAlphaTextures
&
op
=
aDetail
.
get_OpUseComponentAlphaTextures
(
)
;
RefPtr
<
TextureHost
>
texOnBlack
=
TextureHost
:
:
AsTextureHost
(
op
.
textureOnBlackParent
(
)
)
;
RefPtr
<
TextureHost
>
texOnWhite
=
TextureHost
:
:
AsTextureHost
(
op
.
textureOnWhiteParent
(
)
)
;
if
(
op
.
readLockedBlack
(
)
)
{
texOnBlack
-
>
SetReadLocked
(
)
;
}
if
(
op
.
readLockedWhite
(
)
)
{
texOnWhite
-
>
SetReadLocked
(
)
;
}
MOZ_ASSERT
(
texOnBlack
&
&
texOnWhite
)
;
aCompositable
-
>
UseComponentAlphaTextures
(
texOnBlack
texOnWhite
)
;
if
(
texOnBlack
)
{
texOnBlack
-
>
SetLastFwdTransactionId
(
mFwdTransactionId
)
;
MOZ_ASSERT
(
texOnBlack
-
>
NumCompositableRefs
(
)
>
0
)
;
}
if
(
texOnWhite
)
{
texOnWhite
-
>
SetLastFwdTransactionId
(
mFwdTransactionId
)
;
MOZ_ASSERT
(
texOnWhite
-
>
NumCompositableRefs
(
)
>
0
)
;
}
if
(
UsesImageBridge
(
)
)
{
ScheduleComposition
(
aCompositable
)
;
}
break
;
}
case
CompositableOperationDetail
:
:
TOpDeliverAcquireFence
:
{
const
OpDeliverAcquireFence
&
op
=
aDetail
.
get_OpDeliverAcquireFence
(
)
;
RefPtr
<
TextureHost
>
tex
=
TextureHost
:
:
AsTextureHost
(
op
.
textureParent
(
)
)
;
MOZ_ASSERT
(
tex
.
get
(
)
)
;
MOZ_ASSERT
(
tex
-
>
AsAndroidHardwareBufferTextureHost
(
)
)
;
auto
fenceFd
=
op
.
fenceFd
(
)
;
tex
-
>
SetAcquireFence
(
std
:
:
move
(
fenceFd
)
)
;
break
;
}
default
:
{
MOZ_ASSERT
(
false
"
bad
type
"
)
;
}
}
return
true
;
}
void
CompositableParentManager
:
:
DestroyActor
(
const
OpDestroy
&
aOp
)
{
switch
(
aOp
.
type
(
)
)
{
case
OpDestroy
:
:
TPTextureParent
:
{
auto
actor
=
aOp
.
get_PTextureParent
(
)
;
TextureHost
:
:
ReceivedDestroy
(
actor
)
;
break
;
}
case
OpDestroy
:
:
TCompositableHandle
:
{
ReleaseCompositable
(
aOp
.
get_CompositableHandle
(
)
)
;
break
;
}
default
:
{
MOZ_ASSERT
(
false
"
unsupported
type
"
)
;
}
}
}
RefPtr
<
CompositableHost
>
CompositableParentManager
:
:
AddCompositable
(
const
CompositableHandle
&
aHandle
const
TextureInfo
&
aInfo
bool
aUseWebRender
)
{
if
(
mCompositables
.
find
(
aHandle
.
Value
(
)
)
!
=
mCompositables
.
end
(
)
)
{
NS_ERROR
(
"
Client
should
not
allocate
duplicate
handles
"
)
;
return
nullptr
;
}
if
(
!
aHandle
)
{
NS_ERROR
(
"
Client
should
not
allocate
0
as
a
handle
"
)
;
return
nullptr
;
}
RefPtr
<
CompositableHost
>
host
=
CompositableHost
:
:
Create
(
aInfo
aUseWebRender
)
;
if
(
!
host
)
{
return
nullptr
;
}
mCompositables
[
aHandle
.
Value
(
)
]
=
host
;
return
host
;
}
RefPtr
<
CompositableHost
>
CompositableParentManager
:
:
FindCompositable
(
const
CompositableHandle
&
aHandle
bool
aAllowDisablingWebRender
)
{
auto
iter
=
mCompositables
.
find
(
aHandle
.
Value
(
)
)
;
if
(
iter
=
=
mCompositables
.
end
(
)
)
{
return
nullptr
;
}
RefPtr
<
CompositableHost
>
host
=
iter
-
>
second
;
if
(
!
aAllowDisablingWebRender
)
{
return
host
;
}
if
(
!
host
-
>
AsWebRenderImageHost
(
)
|
|
!
host
-
>
GetAsyncRef
(
)
)
{
return
host
;
}
RefPtr
<
CompositableHost
>
newHost
=
CompositableHost
:
:
Create
(
host
-
>
GetTextureInfo
(
)
false
)
;
if
(
!
newHost
|
|
!
newHost
-
>
AsImageHost
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
to
be
called
"
)
;
return
host
;
}
newHost
-
>
SetAsyncRef
(
host
-
>
GetAsyncRef
(
)
)
;
mCompositables
[
aHandle
.
Value
(
)
]
=
newHost
;
return
newHost
;
}
void
CompositableParentManager
:
:
ReleaseCompositable
(
const
CompositableHandle
&
aHandle
)
{
auto
iter
=
mCompositables
.
find
(
aHandle
.
Value
(
)
)
;
if
(
iter
=
=
mCompositables
.
end
(
)
)
{
return
;
}
RefPtr
<
CompositableHost
>
host
=
iter
-
>
second
;
mCompositables
.
erase
(
iter
)
;
host
-
>
Detach
(
nullptr
CompositableHost
:
:
FORCE_DETACH
)
;
}
}
}
