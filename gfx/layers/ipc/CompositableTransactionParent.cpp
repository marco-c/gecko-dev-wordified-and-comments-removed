#
include
"
CompositableTransactionParent
.
h
"
#
include
"
CompositableHost
.
h
"
#
include
"
CompositorBridgeParent
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
Layers
.
h
"
#
include
"
RenderTrace
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
ContentHost
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
LayerManagerComposite
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
mozilla
/
layers
/
TextureHostOGL
.
h
"
#
include
"
mozilla
/
layers
/
TiledContentHost
.
h
"
#
include
"
mozilla
/
layers
/
PaintedLayerComposite
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsRegion
.
h
"
namespace
mozilla
{
namespace
layers
{
class
ClientTiledLayerBuffer
;
class
Compositor
;
static
bool
ScheduleComposition
(
CompositableHost
*
aCompositable
)
{
uint64_t
id
=
aCompositable
-
>
GetCompositorBridgeID
(
)
;
if
(
!
id
)
{
return
false
;
}
CompositorBridgeParent
*
cp
=
CompositorBridgeParent
:
:
GetCompositorBridgeParent
(
id
)
;
if
(
!
cp
)
{
return
false
;
}
cp
-
>
ScheduleComposition
(
)
;
return
true
;
}
bool
CompositableParentManager
:
:
ReceiveCompositableUpdate
(
const
CompositableOperation
&
aEdit
)
{
RefPtr
<
CompositableHost
>
compositable
=
FindCompositable
(
aEdit
.
compositable
(
)
)
;
if
(
!
compositable
)
{
return
false
;
}
return
ReceiveCompositableUpdate
(
aEdit
.
detail
(
)
WrapNotNull
(
compositable
)
)
;
}
bool
CompositableParentManager
:
:
ReceiveCompositableUpdate
(
const
CompositableOperationDetail
&
aDetail
NotNull
<
CompositableHost
*
>
aCompositable
)
{
if
(
TextureSourceProvider
*
provider
=
aCompositable
-
>
GetTextureSourceProvider
(
)
)
{
if
(
!
provider
-
>
IsValid
(
)
)
{
return
false
;
}
}
switch
(
aDetail
.
type
(
)
)
{
case
CompositableOperationDetail
:
:
TOpPaintTextureRegion
:
{
MOZ_LAYERS_LOG
(
(
"
[
ParentSide
]
Paint
PaintedLayer
"
)
)
;
const
OpPaintTextureRegion
&
op
=
aDetail
.
get_OpPaintTextureRegion
(
)
;
Layer
*
layer
=
aCompositable
-
>
GetLayer
(
)
;
if
(
!
layer
|
|
layer
-
>
GetType
(
)
!
=
Layer
:
:
TYPE_PAINTED
)
{
return
false
;
}
PaintedLayerComposite
*
thebes
=
static_cast
<
PaintedLayerComposite
*
>
(
layer
)
;
const
ThebesBufferData
&
bufferData
=
op
.
bufferData
(
)
;
RenderTraceInvalidateStart
(
thebes
"
FF00FF
"
op
.
updatedRegion
(
)
.
GetBounds
(
)
)
;
if
(
!
aCompositable
-
>
UpdateThebes
(
bufferData
op
.
updatedRegion
(
)
thebes
-
>
GetValidRegion
(
)
)
)
{
return
false
;
}
RenderTraceInvalidateEnd
(
thebes
"
FF00FF
"
)
;
break
;
}
case
CompositableOperationDetail
:
:
TOpUseTiledLayerBuffer
:
{
MOZ_LAYERS_LOG
(
(
"
[
ParentSide
]
Paint
TiledLayerBuffer
"
)
)
;
const
OpUseTiledLayerBuffer
&
op
=
aDetail
.
get_OpUseTiledLayerBuffer
(
)
;
TiledContentHost
*
tiledHost
=
aCompositable
-
>
AsTiledContentHost
(
)
;
NS_ASSERTION
(
tiledHost
"
The
compositable
is
not
tiled
"
)
;
const
SurfaceDescriptorTiles
&
tileDesc
=
op
.
tileLayerDescriptor
(
)
;
bool
success
=
tiledHost
-
>
UseTiledLayerBuffer
(
this
tileDesc
)
;
const
nsTArray
<
TileDescriptor
>
&
tileDescriptors
=
tileDesc
.
tiles
(
)
;
for
(
size_t
i
=
0
;
i
<
tileDescriptors
.
Length
(
)
;
i
+
+
)
{
const
TileDescriptor
&
tileDesc
=
tileDescriptors
[
i
]
;
if
(
tileDesc
.
type
(
)
!
=
TileDescriptor
:
:
TTexturedTileDescriptor
)
{
continue
;
}
const
TexturedTileDescriptor
&
texturedDesc
=
tileDesc
.
get_TexturedTileDescriptor
(
)
;
RefPtr
<
TextureHost
>
texture
=
TextureHost
:
:
AsTextureHost
(
texturedDesc
.
textureParent
(
)
)
;
if
(
texture
)
{
texture
-
>
SetLastFwdTransactionId
(
mFwdTransactionId
)
;
MOZ_ASSERT
(
texture
-
>
NumCompositableRefs
(
)
>
0
)
;
}
if
(
texturedDesc
.
textureOnWhiteParent
(
)
.
isSome
(
)
)
{
texture
=
TextureHost
:
:
AsTextureHost
(
texturedDesc
.
textureOnWhiteParent
(
)
.
ref
(
)
)
;
if
(
texture
)
{
texture
-
>
SetLastFwdTransactionId
(
mFwdTransactionId
)
;
MOZ_ASSERT
(
texture
-
>
NumCompositableRefs
(
)
>
0
)
;
}
}
}
if
(
!
success
)
{
return
false
;
}
break
;
}
case
CompositableOperationDetail
:
:
TOpRemoveTexture
:
{
const
OpRemoveTexture
&
op
=
aDetail
.
get_OpRemoveTexture
(
)
;
RefPtr
<
TextureHost
>
tex
=
TextureHost
:
:
AsTextureHost
(
op
.
textureParent
(
)
)
;
MOZ_ASSERT
(
tex
.
get
(
)
)
;
aCompositable
-
>
RemoveTextureHost
(
tex
)
;
break
;
}
case
CompositableOperationDetail
:
:
TOpUseTexture
:
{
const
OpUseTexture
&
op
=
aDetail
.
get_OpUseTexture
(
)
;
AutoTArray
<
CompositableHost
:
:
TimedTexture
4
>
textures
;
for
(
auto
&
timedTexture
:
op
.
textures
(
)
)
{
CompositableHost
:
:
TimedTexture
*
t
=
textures
.
AppendElement
(
)
;
t
-
>
mTexture
=
TextureHost
:
:
AsTextureHost
(
timedTexture
.
textureParent
(
)
)
;
MOZ_ASSERT
(
t
-
>
mTexture
)
;
t
-
>
mTimeStamp
=
timedTexture
.
timeStamp
(
)
;
t
-
>
mPictureRect
=
timedTexture
.
picture
(
)
;
t
-
>
mFrameID
=
timedTexture
.
frameID
(
)
;
t
-
>
mProducerID
=
timedTexture
.
producerID
(
)
;
if
(
timedTexture
.
readLocked
(
)
)
{
t
-
>
mTexture
-
>
SetReadLocked
(
)
;
}
}
if
(
textures
.
Length
(
)
>
0
)
{
aCompositable
-
>
UseTextureHost
(
textures
)
;
for
(
auto
&
timedTexture
:
op
.
textures
(
)
)
{
RefPtr
<
TextureHost
>
texture
=
TextureHost
:
:
AsTextureHost
(
timedTexture
.
textureParent
(
)
)
;
if
(
texture
)
{
texture
-
>
SetLastFwdTransactionId
(
mFwdTransactionId
)
;
MOZ_ASSERT
(
texture
-
>
NumCompositableRefs
(
)
>
0
)
;
}
}
}
if
(
UsesImageBridge
(
)
&
&
aCompositable
-
>
GetLayer
(
)
)
{
ScheduleComposition
(
aCompositable
)
;
}
break
;
}
case
CompositableOperationDetail
:
:
TOpUseComponentAlphaTextures
:
{
const
OpUseComponentAlphaTextures
&
op
=
aDetail
.
get_OpUseComponentAlphaTextures
(
)
;
RefPtr
<
TextureHost
>
texOnBlack
=
TextureHost
:
:
AsTextureHost
(
op
.
textureOnBlackParent
(
)
)
;
RefPtr
<
TextureHost
>
texOnWhite
=
TextureHost
:
:
AsTextureHost
(
op
.
textureOnWhiteParent
(
)
)
;
if
(
op
.
readLockedBlack
(
)
)
{
texOnBlack
-
>
SetReadLocked
(
)
;
}
if
(
op
.
readLockedWhite
(
)
)
{
texOnWhite
-
>
SetReadLocked
(
)
;
}
MOZ_ASSERT
(
texOnBlack
&
&
texOnWhite
)
;
aCompositable
-
>
UseComponentAlphaTextures
(
texOnBlack
texOnWhite
)
;
if
(
texOnBlack
)
{
texOnBlack
-
>
SetLastFwdTransactionId
(
mFwdTransactionId
)
;
MOZ_ASSERT
(
texOnBlack
-
>
NumCompositableRefs
(
)
>
0
)
;
}
if
(
texOnWhite
)
{
texOnWhite
-
>
SetLastFwdTransactionId
(
mFwdTransactionId
)
;
MOZ_ASSERT
(
texOnWhite
-
>
NumCompositableRefs
(
)
>
0
)
;
}
if
(
UsesImageBridge
(
)
)
{
ScheduleComposition
(
aCompositable
)
;
}
break
;
}
default
:
{
MOZ_ASSERT
(
false
"
bad
type
"
)
;
}
}
return
true
;
}
void
CompositableParentManager
:
:
DestroyActor
(
const
OpDestroy
&
aOp
)
{
switch
(
aOp
.
type
(
)
)
{
case
OpDestroy
:
:
TPTextureParent
:
{
auto
actor
=
aOp
.
get_PTextureParent
(
)
;
TextureHost
:
:
ReceivedDestroy
(
actor
)
;
break
;
}
case
OpDestroy
:
:
TCompositableHandle
:
{
ReleaseCompositable
(
aOp
.
get_CompositableHandle
(
)
)
;
break
;
}
default
:
{
MOZ_ASSERT
(
false
"
unsupported
type
"
)
;
}
}
}
RefPtr
<
CompositableHost
>
CompositableParentManager
:
:
AddCompositable
(
const
CompositableHandle
&
aHandle
const
TextureInfo
&
aInfo
bool
aUseWebRender
)
{
if
(
mCompositables
.
find
(
aHandle
.
Value
(
)
)
!
=
mCompositables
.
end
(
)
)
{
NS_ERROR
(
"
Client
should
not
allocate
duplicate
handles
"
)
;
return
nullptr
;
}
if
(
!
aHandle
)
{
NS_ERROR
(
"
Client
should
not
allocate
0
as
a
handle
"
)
;
return
nullptr
;
}
RefPtr
<
CompositableHost
>
host
=
CompositableHost
:
:
Create
(
aInfo
aUseWebRender
)
;
if
(
!
host
)
{
return
nullptr
;
}
mCompositables
[
aHandle
.
Value
(
)
]
=
host
;
return
host
;
}
RefPtr
<
CompositableHost
>
CompositableParentManager
:
:
FindCompositable
(
const
CompositableHandle
&
aHandle
bool
aAllowDisablingWebRender
)
{
auto
iter
=
mCompositables
.
find
(
aHandle
.
Value
(
)
)
;
if
(
iter
=
=
mCompositables
.
end
(
)
)
{
return
nullptr
;
}
RefPtr
<
CompositableHost
>
host
=
iter
-
>
second
;
if
(
!
aAllowDisablingWebRender
)
{
return
host
;
}
if
(
!
host
-
>
AsWebRenderImageHost
(
)
|
|
!
host
-
>
GetAsyncRef
(
)
)
{
return
host
;
}
RefPtr
<
CompositableHost
>
newHost
=
CompositableHost
:
:
Create
(
host
-
>
GetTextureInfo
(
)
false
)
;
if
(
!
newHost
|
|
!
newHost
-
>
AsImageHost
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
to
be
called
"
)
;
return
host
;
}
newHost
-
>
SetAsyncRef
(
host
-
>
GetAsyncRef
(
)
)
;
mCompositables
[
aHandle
.
Value
(
)
]
=
newHost
;
return
newHost
;
}
void
CompositableParentManager
:
:
ReleaseCompositable
(
const
CompositableHandle
&
aHandle
)
{
auto
iter
=
mCompositables
.
find
(
aHandle
.
Value
(
)
)
;
if
(
iter
=
=
mCompositables
.
end
(
)
)
{
return
;
}
RefPtr
<
CompositableHost
>
host
=
iter
-
>
second
;
mCompositables
.
erase
(
iter
)
;
host
-
>
Detach
(
nullptr
CompositableHost
:
:
FORCE_DETACH
)
;
}
}
}
