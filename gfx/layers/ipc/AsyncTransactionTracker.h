#
ifndef
mozilla_layers_AsyncTransactionTracker_h
#
define
mozilla_layers_AsyncTransactionTracker_h
#
include
<
map
>
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
layers
/
FenceUtils
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
namespace
mozilla
{
namespace
layers
{
class
TextureClient
;
class
AsyncTransactionTrackersHolder
;
class
AsyncTransactionWaiter
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
AsyncTransactionWaiter
)
AsyncTransactionWaiter
(
)
:
mCompletedMonitor
(
"
AsyncTransactionWaiter
"
)
mWaitCount
(
0
)
{
}
void
IncrementWaitCount
(
)
{
MonitorAutoLock
lock
(
mCompletedMonitor
)
;
+
+
mWaitCount
;
}
void
DecrementWaitCount
(
)
{
MonitorAutoLock
lock
(
mCompletedMonitor
)
;
MOZ_ASSERT
(
mWaitCount
>
0
)
;
-
-
mWaitCount
;
if
(
mWaitCount
=
=
0
)
{
mCompletedMonitor
.
Notify
(
)
;
}
}
void
WaitComplete
(
)
;
uint32_t
GetWaitCount
(
)
{
return
mWaitCount
;
}
private
:
~
AsyncTransactionWaiter
(
)
{
}
Monitor
mCompletedMonitor
;
uint32_t
mWaitCount
;
}
;
class
AsyncTransactionTracker
{
friend
class
AsyncTransactionTrackersHolder
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
AsyncTransactionTracker
)
explicit
AsyncTransactionTracker
(
AsyncTransactionWaiter
*
aWaiter
=
nullptr
)
;
void
NotifyComplete
(
)
;
void
NotifyCancel
(
)
;
uint64_t
GetId
(
)
{
return
mSerial
;
}
virtual
void
Complete
(
)
=
0
;
virtual
void
Cancel
(
)
=
0
;
virtual
void
SetTextureClient
(
TextureClient
*
aTextureClient
)
{
}
virtual
void
SetReleaseFenceHandle
(
FenceHandle
&
aReleaseFenceHandle
)
{
}
protected
:
virtual
~
AsyncTransactionTracker
(
)
;
static
uint64_t
GetNextSerial
(
)
{
return
+
+
sSerialCounter
;
}
uint64_t
mSerial
;
RefPtr
<
AsyncTransactionWaiter
>
mWaiter
;
#
ifdef
DEBUG
bool
mCompleted
;
#
endif
static
Atomic
<
uint64_t
>
sSerialCounter
;
}
;
class
AsyncTransactionTrackersHolder
{
public
:
AsyncTransactionTrackersHolder
(
)
;
virtual
~
AsyncTransactionTrackersHolder
(
)
;
void
HoldUntilComplete
(
AsyncTransactionTracker
*
aTransactionTracker
)
;
void
TransactionCompleteted
(
uint64_t
aTransactionId
)
;
static
void
TransactionCompleteted
(
uint64_t
aHolderId
uint64_t
aTransactionId
)
;
static
void
SetReleaseFenceHandle
(
FenceHandle
&
aReleaseFenceHandle
uint64_t
aHolderId
uint64_t
aTransactionId
)
;
uint64_t
GetId
(
)
{
return
mSerial
;
}
void
DestroyAsyncTransactionTrackersHolder
(
)
;
protected
:
static
uint64_t
GetNextSerial
(
)
{
return
+
+
sSerialCounter
;
}
void
TransactionCompletetedInternal
(
uint64_t
aTransactionId
)
;
void
SetReleaseFenceHandle
(
FenceHandle
&
aReleaseFenceHandle
uint64_t
aTransactionId
)
;
void
ClearAllAsyncTransactionTrackers
(
)
;
const
uint64_t
mSerial
;
bool
mIsTrackersHolderDestroyed
;
std
:
:
map
<
uint64_t
RefPtr
<
AsyncTransactionTracker
>
>
mAsyncTransactionTrackers
;
static
Atomic
<
uint64_t
>
sSerialCounter
;
}
;
}
}
#
endif
