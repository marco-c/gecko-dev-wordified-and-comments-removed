#
ifndef
MOZILLA_LAYERS_TEXTUREFORWARDER
#
define
MOZILLA_LAYERS_TEXTUREFORWARDER
#
include
<
stdint
.
h
>
#
include
"
gfxTypes
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
nsExpirationTracker
.
h
"
namespace
mozilla
{
namespace
layers
{
class
ActiveResource
{
public
:
virtual
void
NotifyInactive
(
)
=
0
;
nsExpirationState
*
GetExpirationState
(
)
{
return
&
mExpirationState
;
}
bool
IsActivityTracked
(
)
{
return
mExpirationState
.
IsTracked
(
)
;
}
private
:
nsExpirationState
mExpirationState
;
}
;
class
ActiveResourceTracker
:
public
nsExpirationTracker
<
ActiveResource
3
>
{
public
:
ActiveResourceTracker
(
uint32_t
aExpirationCycle
const
char
*
aName
)
:
nsExpirationTracker
(
aExpirationCycle
aName
)
{
}
virtual
void
NotifyExpired
(
ActiveResource
*
aResource
)
override
{
RemoveObject
(
aResource
)
;
aResource
-
>
NotifyInactive
(
)
;
}
}
;
class
LayersIPCActor
{
public
:
virtual
bool
IPCOpen
(
)
const
{
return
true
;
}
}
;
class
LayersIPCChannel
:
public
LayersIPCActor
public
ShmemAllocator
{
public
:
NS_IMETHOD_
(
MozExternalRefCountType
)
AddRef
(
void
)
=
0
;
NS_IMETHOD_
(
MozExternalRefCountType
)
Release
(
void
)
=
0
;
virtual
bool
IsSameProcess
(
)
const
=
0
;
virtual
bool
UsesImageBridge
(
)
const
{
return
false
;
}
virtual
base
:
:
ProcessId
GetParentPid
(
)
const
=
0
;
virtual
MessageLoop
*
GetMessageLoop
(
)
const
=
0
;
virtual
FixedSizeSmallShmemSectionAllocator
*
GetTileLockAllocator
(
)
{
return
nullptr
;
}
virtual
void
CancelWaitForRecycle
(
uint64_t
aTextureId
)
=
0
;
protected
:
virtual
~
LayersIPCChannel
(
)
{
}
}
;
class
TextureForwarder
:
public
LayersIPCChannel
{
public
:
virtual
PTextureChild
*
CreateTexture
(
const
SurfaceDescriptor
&
aSharedData
LayersBackend
aLayersBackend
TextureFlags
aFlags
uint64_t
aSerial
)
=
0
;
}
;
class
KnowsCompositor
{
public
:
NS_IMETHOD_
(
MozExternalRefCountType
)
AddRef
(
void
)
=
0
;
NS_IMETHOD_
(
MozExternalRefCountType
)
Release
(
void
)
=
0
;
KnowsCompositor
(
)
:
mSerial
(
+
+
sSerialCounter
)
{
mActiveResourceTracker
=
MakeUnique
<
ActiveResourceTracker
>
(
1000
"
CompositableForwarder
"
)
;
}
void
IdentifyTextureHost
(
const
TextureFactoryIdentifier
&
aIdentifier
)
;
SyncObject
*
GetSyncObject
(
)
{
return
mSyncObject
;
}
int32_t
GetMaxTextureSize
(
)
const
{
return
mTextureFactoryIdentifier
.
mMaxTextureSize
;
}
LayersBackend
GetCompositorBackendType
(
)
const
{
return
mTextureFactoryIdentifier
.
mParentBackend
;
}
bool
SupportsTextureBlitting
(
)
const
{
return
mTextureFactoryIdentifier
.
mSupportsTextureBlitting
;
}
bool
SupportsPartialUploads
(
)
const
{
return
mTextureFactoryIdentifier
.
mSupportsPartialUploads
;
}
const
TextureFactoryIdentifier
&
GetTextureFactoryIdentifier
(
)
const
{
return
mTextureFactoryIdentifier
;
}
int32_t
GetSerial
(
)
{
return
mSerial
;
}
ActiveResourceTracker
&
GetActiveResourceTracker
(
)
{
return
*
mActiveResourceTracker
.
get
(
)
;
}
virtual
TextureForwarder
*
GetTextureForwarder
(
)
=
0
;
virtual
LayersIPCActor
*
GetLayersIPCActor
(
)
=
0
;
protected
:
TextureFactoryIdentifier
mTextureFactoryIdentifier
;
RefPtr
<
SyncObject
>
mSyncObject
;
UniquePtr
<
ActiveResourceTracker
>
mActiveResourceTracker
;
const
int32_t
mSerial
;
static
mozilla
:
:
Atomic
<
int32_t
>
sSerialCounter
;
}
;
}
}
#
endif
