#
include
"
LayerTreeOwnerTracker
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
gfx
/
GPUChild
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessManager
.
h
"
#
include
<
functional
>
#
include
<
utility
>
namespace
mozilla
{
namespace
layers
{
static
StaticAutoPtr
<
LayerTreeOwnerTracker
>
sSingleton
;
LayerTreeOwnerTracker
:
:
LayerTreeOwnerTracker
(
)
:
mLayerIdsLock
(
"
LayerTreeOwnerTrackerLock
"
)
{
}
void
LayerTreeOwnerTracker
:
:
Initialize
(
)
{
MOZ_ASSERT
(
!
sSingleton
)
;
sSingleton
=
new
LayerTreeOwnerTracker
(
)
;
}
void
LayerTreeOwnerTracker
:
:
Shutdown
(
)
{
sSingleton
=
nullptr
;
}
LayerTreeOwnerTracker
*
LayerTreeOwnerTracker
:
:
Get
(
)
{
return
sSingleton
;
}
void
LayerTreeOwnerTracker
:
:
Map
(
LayersId
aLayersId
base
:
:
ProcessId
aProcessId
)
{
MutexAutoLock
lock
(
mLayerIdsLock
)
;
mLayerIds
[
aLayersId
]
=
aProcessId
;
}
void
LayerTreeOwnerTracker
:
:
Unmap
(
LayersId
aLayersId
base
:
:
ProcessId
aProcessId
)
{
MutexAutoLock
lock
(
mLayerIdsLock
)
;
MOZ_ASSERT
(
mLayerIds
[
aLayersId
]
=
=
aProcessId
)
;
mLayerIds
.
erase
(
aLayersId
)
;
}
bool
LayerTreeOwnerTracker
:
:
IsMapped
(
LayersId
aLayersId
base
:
:
ProcessId
aProcessId
)
{
MutexAutoLock
lock
(
mLayerIdsLock
)
;
auto
iter
=
mLayerIds
.
find
(
aLayersId
)
;
return
iter
!
=
mLayerIds
.
end
(
)
&
&
iter
-
>
second
=
=
aProcessId
;
}
void
LayerTreeOwnerTracker
:
:
Iterate
(
const
std
:
:
function
<
void
(
LayersId
aLayersId
base
:
:
ProcessId
aProcessId
)
>
&
aCallback
)
{
MutexAutoLock
lock
(
mLayerIdsLock
)
;
for
(
const
auto
&
iter
:
mLayerIds
)
{
aCallback
(
iter
.
first
iter
.
second
)
;
}
}
}
}
