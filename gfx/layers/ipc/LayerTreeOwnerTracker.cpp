#
include
"
LayerTreeOwnerTracker
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
gfx
/
GPUChild
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessManager
.
h
"
#
include
<
functional
>
namespace
mozilla
{
namespace
layers
{
static
StaticAutoPtr
<
LayerTreeOwnerTracker
>
sSingleton
;
LayerTreeOwnerTracker
:
:
LayerTreeOwnerTracker
(
)
:
mLayerIdsLock
(
"
LayerTreeOwnerTrackerLock
"
)
{
}
void
LayerTreeOwnerTracker
:
:
Initialize
(
)
{
MOZ_ASSERT
(
!
sSingleton
)
;
sSingleton
=
new
LayerTreeOwnerTracker
(
)
;
}
void
LayerTreeOwnerTracker
:
:
Shutdown
(
)
{
sSingleton
=
nullptr
;
}
LayerTreeOwnerTracker
*
LayerTreeOwnerTracker
:
:
Get
(
)
{
return
sSingleton
;
}
void
LayerTreeOwnerTracker
:
:
Map
(
LayersId
aLayersId
base
:
:
ProcessId
aProcessId
)
{
MutexAutoLock
lock
(
mLayerIdsLock
)
;
const
auto
i
=
mLayerIds
.
insert
(
{
aLayersId
aProcessId
}
)
;
MOZ_ASSERT
(
i
.
second
"
Mapping
already
used
layers
ID
!
"
)
;
(
void
)
i
;
}
void
LayerTreeOwnerTracker
:
:
Unmap
(
LayersId
aLayersId
base
:
:
ProcessId
aProcessId
)
{
MutexAutoLock
lock
(
mLayerIdsLock
)
;
auto
i
=
mLayerIds
.
find
(
aLayersId
)
;
if
(
i
=
=
mLayerIds
.
end
(
)
)
{
return
;
}
if
(
NS_WARN_IF
(
i
-
>
second
!
=
aProcessId
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unmapping
layers
ID
for
another
process
!
"
)
;
return
;
}
mLayerIds
.
erase
(
i
)
;
}
bool
LayerTreeOwnerTracker
:
:
IsMapped
(
LayersId
aLayersId
base
:
:
ProcessId
aProcessId
)
{
MutexAutoLock
lock
(
mLayerIdsLock
)
;
auto
iter
=
mLayerIds
.
find
(
aLayersId
)
;
return
iter
!
=
mLayerIds
.
end
(
)
&
&
iter
-
>
second
=
=
aProcessId
;
}
void
LayerTreeOwnerTracker
:
:
Iterate
(
const
std
:
:
function
<
void
(
LayersId
aLayersId
base
:
:
ProcessId
aProcessId
)
>
&
aCallback
)
{
MutexAutoLock
lock
(
mLayerIdsLock
)
;
for
(
const
auto
&
iter
:
mLayerIds
)
{
aCallback
(
iter
.
first
iter
.
second
)
;
}
}
}
}
