#
ifndef
mozilla_layers_ContentCompositorBridgeParent_h
#
define
mozilla_layers_ContentCompositorBridgeParent_h
#
include
"
mozilla
/
layers
/
CanvasTranslator
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
namespace
mozilla
{
namespace
webgpu
{
class
PWebGPUParent
;
}
namespace
layers
{
class
CompositorOptions
;
class
ContentCompositorBridgeParent
final
:
public
CompositorBridgeParentBase
{
friend
class
CompositorBridgeParent
;
public
:
explicit
ContentCompositorBridgeParent
(
CompositorManagerParent
*
aManager
)
:
CompositorBridgeParentBase
(
aManager
)
mNotifyAfterRemotePaint
(
false
)
mDestroyCalled
(
false
)
{
}
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvInitialize
(
const
LayersId
&
aRootLayerTreeId
)
override
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvWillClose
(
)
override
{
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvPause
(
)
override
{
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvRequestFxrOutput
(
)
override
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvResume
(
)
override
{
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvResumeAsync
(
)
override
{
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvNotifyChildCreated
(
const
LayersId
&
child
CompositorOptions
*
aOptions
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvMapAndNotifyChildCreated
(
const
LayersId
&
child
const
base
:
:
ProcessId
&
pid
CompositorOptions
*
aOptions
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvNotifyChildRecreated
(
const
LayersId
&
child
CompositorOptions
*
aOptions
)
override
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvAdoptChild
(
const
LayersId
&
child
)
override
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvMakeSnapshot
(
const
SurfaceDescriptor
&
aInSnapshot
const
gfx
:
:
IntRect
&
aRect
)
override
{
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvFlushRendering
(
)
override
{
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvFlushRenderingAsync
(
)
override
{
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvForcePresent
(
)
override
{
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvWaitOnTransactionProcessed
(
)
override
{
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvNotifyRegionInvalidated
(
const
nsIntRegion
&
aRegion
)
override
{
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvStartFrameTimeRecording
(
const
int32_t
&
aBufferSize
uint32_t
*
aOutStartIndex
)
override
{
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvStopFrameTimeRecording
(
const
uint32_t
&
aStartIndex
nsTArray
<
float
>
*
intervals
)
override
{
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvCheckContentOnlyTDR
(
const
uint32_t
&
sequenceNum
bool
*
isContentOnlyTDR
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvAllPluginsCaptured
(
)
override
{
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvBeginRecording
(
const
TimeStamp
&
aRecordingStart
BeginRecordingResolver
&
&
aResolve
)
override
{
aResolve
(
false
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvEndRecordingToDisk
(
EndRecordingToDiskResolver
&
&
aResolve
)
override
{
aResolve
(
false
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvEndRecordingToMemory
(
EndRecordingToMemoryResolver
&
&
aResolve
)
override
{
aResolve
(
Nothing
(
)
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvGetFrameUniformity
(
FrameUniformityData
*
aOutData
)
override
{
MOZ_ASSERT
(
false
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvRequestNotifyAfterRemotePaint
(
)
override
;
PLayerTransactionParent
*
AllocPLayerTransactionParent
(
const
nsTArray
<
LayersBackend
>
&
aBackendHints
const
LayersId
&
aId
)
override
;
bool
DeallocPLayerTransactionParent
(
PLayerTransactionParent
*
aLayers
)
override
;
void
ShadowLayersUpdated
(
LayerTransactionParent
*
aLayerTree
const
TransactionInfo
&
aInfo
bool
aHitTestUpdate
)
override
;
void
ScheduleComposite
(
LayerTransactionParent
*
aLayerTree
)
override
;
void
NotifyClearCachedResources
(
LayerTransactionParent
*
aLayerTree
)
override
;
bool
SetTestSampleTime
(
const
LayersId
&
aId
const
TimeStamp
&
aTime
)
override
;
void
LeaveTestMode
(
const
LayersId
&
aId
)
override
;
void
ApplyAsyncProperties
(
LayerTransactionParent
*
aLayerTree
TransformsToSkip
aSkip
)
override
;
void
SetTestAsyncScrollOffset
(
const
LayersId
&
aLayersId
const
ScrollableLayerGuid
:
:
ViewID
&
aScrollId
const
CSSPoint
&
aPoint
)
override
;
void
SetTestAsyncZoom
(
const
LayersId
&
aLayersId
const
ScrollableLayerGuid
:
:
ViewID
&
aScrollId
const
LayerToParentLayerScale
&
aZoom
)
override
;
void
FlushApzRepaints
(
const
LayersId
&
aLayersId
)
override
;
void
GetAPZTestData
(
const
LayersId
&
aLayersId
APZTestData
*
aOutData
)
override
;
void
SetConfirmedTargetAPZC
(
const
LayersId
&
aLayersId
const
uint64_t
&
aInputBlockId
const
nsTArray
<
SLGuidAndRenderRoot
>
&
aTargets
)
override
;
AsyncCompositionManager
*
GetCompositionManager
(
LayerTransactionParent
*
aParent
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvRemotePluginsReady
(
)
override
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
already_AddRefed
<
dom
:
:
PWebGLParent
>
AllocPWebGLParent
(
const
webgl
:
:
InitContextDesc
&
webgl
:
:
InitContextResult
*
out
)
override
;
void
DidCompositeLocked
(
LayersId
aId
const
VsyncId
&
aVsyncId
TimeStamp
&
aCompositeStart
TimeStamp
&
aCompositeEnd
)
;
PTextureParent
*
AllocPTextureParent
(
const
SurfaceDescriptor
&
aSharedData
const
ReadLockDescriptor
&
aReadLock
const
LayersBackend
&
aLayersBackend
const
TextureFlags
&
aFlags
const
LayersId
&
aId
const
uint64_t
&
aSerial
const
wr
:
:
MaybeExternalImageId
&
aExternalImageId
)
override
;
bool
DeallocPTextureParent
(
PTextureParent
*
actor
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvInitPCanvasParent
(
Endpoint
<
PCanvasParent
>
&
&
aEndpoint
)
final
;
mozilla
:
:
ipc
:
:
IPCResult
RecvReleasePCanvasParent
(
)
final
;
bool
IsSameProcess
(
)
const
override
;
PCompositorWidgetParent
*
AllocPCompositorWidgetParent
(
const
CompositorWidgetInitData
&
aInitData
)
override
{
return
nullptr
;
}
bool
DeallocPCompositorWidgetParent
(
PCompositorWidgetParent
*
aActor
)
override
{
return
false
;
}
PAPZCTreeManagerParent
*
AllocPAPZCTreeManagerParent
(
const
LayersId
&
aLayersId
)
override
;
bool
DeallocPAPZCTreeManagerParent
(
PAPZCTreeManagerParent
*
aActor
)
override
;
PAPZParent
*
AllocPAPZParent
(
const
LayersId
&
aLayersId
)
override
;
bool
DeallocPAPZParent
(
PAPZParent
*
aActor
)
override
;
void
UpdatePaintTime
(
LayerTransactionParent
*
aLayerTree
const
TimeDuration
&
aPaintTime
)
override
;
void
RegisterPayloads
(
LayerTransactionParent
*
aLayerTree
const
nsTArray
<
CompositionPayload
>
&
aPayload
)
override
;
PWebRenderBridgeParent
*
AllocPWebRenderBridgeParent
(
const
wr
:
:
PipelineId
&
aPipelineId
const
LayoutDeviceIntSize
&
aSize
)
override
;
bool
DeallocPWebRenderBridgeParent
(
PWebRenderBridgeParent
*
aActor
)
override
;
webgpu
:
:
PWebGPUParent
*
AllocPWebGPUParent
(
)
override
;
bool
DeallocPWebGPUParent
(
webgpu
:
:
PWebGPUParent
*
aActor
)
override
;
void
ObserveLayersUpdate
(
LayersId
aLayersId
LayersObserverEpoch
aEpoch
bool
aActive
)
override
;
bool
IsRemote
(
)
const
override
{
return
true
;
}
UniquePtr
<
SurfaceDescriptor
>
LookupSurfaceDescriptorForClientDrawTarget
(
const
uintptr_t
aDrawTarget
)
final
;
mozilla
:
:
ipc
:
:
IPCResult
RecvSupportsAsyncDXGISurface
(
bool
*
value
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvPreferredDXGIAdapter
(
DxgiAdapterDesc
*
desc
)
override
;
private
:
virtual
~
ContentCompositorBridgeParent
(
)
;
void
DeferredDestroy
(
)
;
RefPtr
<
ContentCompositorBridgeParent
>
mSelfRef
;
bool
mNotifyAfterRemotePaint
;
bool
mDestroyCalled
;
RefPtr
<
CanvasTranslator
>
mCanvasTranslator
;
}
;
}
}
#
endif
