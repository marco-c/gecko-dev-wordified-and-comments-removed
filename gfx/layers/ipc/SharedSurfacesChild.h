#
ifndef
MOZILLA_GFX_SHAREDSURFACESCHILD_H
#
define
MOZILLA_GFX_SHAREDSURFACESCHILD_H
#
include
<
stdint
.
h
>
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
gfx
/
UserData
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderTypes
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
ImageTypes
.
h
"
namespace
mozilla
{
namespace
layers
{
class
AnimationImageKeyData
;
}
}
template
<
>
struct
nsTArray_RelocationStrategy
<
mozilla
:
:
layers
:
:
AnimationImageKeyData
>
{
typedef
nsTArray_RelocateUsingMoveConstructor
<
mozilla
:
:
layers
:
:
AnimationImageKeyData
>
Type
;
}
;
namespace
mozilla
{
namespace
gfx
{
class
SourceSurface
;
class
SourceSurfaceSharedData
;
}
namespace
wr
{
class
IpcResourceUpdateQueue
;
}
namespace
layers
{
class
CompositorManagerChild
;
class
RenderRootStateManager
;
class
SharedSurfacesChild
{
public
:
static
void
Share
(
gfx
:
:
SourceSurfaceSharedData
*
aSurface
)
;
static
nsresult
Share
(
gfx
:
:
SourceSurface
*
aSurface
wr
:
:
ExternalImageId
&
aId
)
;
static
nsresult
Share
(
gfx
:
:
SourceSurface
*
aSurface
Maybe
<
SurfaceDescriptor
>
&
aDesc
)
;
static
nsresult
Share
(
gfx
:
:
SourceSurfaceSharedData
*
aSurface
RenderRootStateManager
*
aManager
wr
:
:
IpcResourceUpdateQueue
&
aResources
wr
:
:
ImageKey
&
aKey
)
;
static
nsresult
Share
(
gfx
:
:
SourceSurface
*
aSurface
RenderRootStateManager
*
aManager
wr
:
:
IpcResourceUpdateQueue
&
aResources
wr
:
:
ImageKey
&
aKey
)
;
static
Maybe
<
wr
:
:
ExternalImageId
>
GetExternalId
(
const
gfx
:
:
SourceSurfaceSharedData
*
aSurface
)
;
static
gfx
:
:
SourceSurfaceSharedData
*
AsSourceSurfaceSharedData
(
gfx
:
:
SourceSurface
*
aSurface
)
;
class
ImageKeyData
{
public
:
ImageKeyData
(
RenderRootStateManager
*
aManager
const
wr
:
:
ImageKey
&
aImageKey
)
;
virtual
~
ImageKeyData
(
)
;
ImageKeyData
(
ImageKeyData
&
&
aOther
)
;
ImageKeyData
&
operator
=
(
ImageKeyData
&
&
aOther
)
;
ImageKeyData
(
const
ImageKeyData
&
)
=
delete
;
ImageKeyData
&
operator
=
(
const
ImageKeyData
&
)
=
delete
;
void
MergeDirtyRect
(
const
Maybe
<
gfx
:
:
IntRect
>
&
aDirtyRect
)
;
Maybe
<
gfx
:
:
IntRect
>
TakeDirtyRect
(
)
{
return
std
:
:
move
(
mDirtyRect
)
;
}
RefPtr
<
RenderRootStateManager
>
mManager
;
Maybe
<
gfx
:
:
IntRect
>
mDirtyRect
;
wr
:
:
ImageKey
mImageKey
;
}
;
private
:
SharedSurfacesChild
(
)
=
delete
;
~
SharedSurfacesChild
(
)
=
delete
;
friend
class
SharedSurfacesAnimation
;
class
SharedUserData
final
:
public
Runnable
{
public
:
SharedUserData
(
)
;
virtual
~
SharedUserData
(
)
;
SharedUserData
(
const
SharedUserData
&
aOther
)
=
delete
;
SharedUserData
&
operator
=
(
const
SharedUserData
&
aOther
)
=
delete
;
SharedUserData
(
SharedUserData
&
&
aOther
)
=
delete
;
SharedUserData
&
operator
=
(
SharedUserData
&
&
aOther
)
=
delete
;
static
void
Destroy
(
void
*
aClosure
)
;
NS_IMETHOD
Run
(
)
override
;
const
wr
:
:
ExternalImageId
&
Id
(
)
const
{
return
mId
;
}
void
ClearShared
(
)
{
mKeys
.
Clear
(
)
;
mShared
=
false
;
}
bool
IsShared
(
)
const
{
return
mShared
;
}
void
MarkShared
(
const
wr
:
:
ExternalImageId
&
aId
)
{
MOZ_ASSERT
(
!
mShared
)
;
mId
=
aId
;
mShared
=
true
;
}
wr
:
:
ImageKey
UpdateKey
(
RenderRootStateManager
*
aManager
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
Maybe
<
gfx
:
:
IntRect
>
&
aDirtyRect
)
;
protected
:
AutoTArray
<
ImageKeyData
1
>
mKeys
;
wr
:
:
ExternalImageId
mId
;
bool
mShared
:
1
;
}
;
static
nsresult
ShareInternal
(
gfx
:
:
SourceSurfaceSharedData
*
aSurface
SharedUserData
*
*
aUserData
)
;
static
void
Unshare
(
const
wr
:
:
ExternalImageId
&
aId
bool
aReleaseId
nsTArray
<
ImageKeyData
>
&
aKeys
)
;
static
void
DestroySharedUserData
(
void
*
aClosure
)
;
static
gfx
:
:
UserDataKey
sSharedKey
;
}
;
class
AnimationImageKeyData
final
:
public
SharedSurfacesChild
:
:
ImageKeyData
{
public
:
AnimationImageKeyData
(
RenderRootStateManager
*
aManager
const
wr
:
:
ImageKey
&
aImageKey
)
;
virtual
~
AnimationImageKeyData
(
)
;
AnimationImageKeyData
(
AnimationImageKeyData
&
&
aOther
)
;
AnimationImageKeyData
&
operator
=
(
AnimationImageKeyData
&
&
aOther
)
;
AutoTArray
<
RefPtr
<
gfx
:
:
SourceSurfaceSharedData
>
2
>
mPendingRelease
;
}
;
class
SharedSurfacesAnimation
final
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
SharedSurfacesAnimation
)
SharedSurfacesAnimation
(
)
=
default
;
void
Destroy
(
)
;
nsresult
SetCurrentFrame
(
gfx
:
:
SourceSurfaceSharedData
*
aSurface
const
gfx
:
:
IntRect
&
aDirtyRect
)
;
nsresult
UpdateKey
(
gfx
:
:
SourceSurfaceSharedData
*
aSurface
RenderRootStateManager
*
aManager
wr
:
:
IpcResourceUpdateQueue
&
aResources
wr
:
:
ImageKey
&
aKey
)
;
void
ReleasePreviousFrame
(
RenderRootStateManager
*
aManager
const
wr
:
:
ExternalImageId
&
aId
)
;
void
Invalidate
(
RenderRootStateManager
*
aManager
)
;
private
:
~
SharedSurfacesAnimation
(
)
;
void
HoldSurfaceForRecycling
(
AnimationImageKeyData
&
aEntry
gfx
:
:
SourceSurfaceSharedData
*
aSurface
)
;
AutoTArray
<
AnimationImageKeyData
1
>
mKeys
;
wr
:
:
ExternalImageId
mId
;
}
;
}
}
#
endif
