#
ifndef
MOZILLA_GFX_SHAREDSURFACESCHILD_H
#
define
MOZILLA_GFX_SHAREDSURFACESCHILD_H
#
include
<
stdint
.
h
>
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
gfx
/
UserData
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderTypes
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
ImageTypes
.
h
"
namespace
mozilla
{
namespace
layers
{
class
AnimationImageKeyData
;
}
}
template
<
>
struct
nsTArray_CopyChooser
<
mozilla
:
:
layers
:
:
AnimationImageKeyData
>
{
typedef
nsTArray_CopyWithConstructors
<
mozilla
:
:
layers
:
:
AnimationImageKeyData
>
Type
;
}
;
namespace
mozilla
{
namespace
gfx
{
class
SourceSurfaceSharedData
;
}
namespace
wr
{
class
IpcResourceUpdateQueue
;
}
namespace
layers
{
class
CompositorManagerChild
;
class
ImageContainer
;
class
RenderRootStateManager
;
class
SharedSurfacesChild
final
{
public
:
static
void
Share
(
gfx
:
:
SourceSurfaceSharedData
*
aSurface
)
;
static
nsresult
Share
(
gfx
:
:
SourceSurface
*
aSurface
wr
:
:
ExternalImageId
&
aId
)
;
static
nsresult
Share
(
gfx
:
:
SourceSurfaceSharedData
*
aSurface
RenderRootStateManager
*
aManager
wr
:
:
IpcResourceUpdateQueue
&
aResources
wr
:
:
ImageKey
&
aKey
)
;
static
nsresult
Share
(
gfx
:
:
SourceSurface
*
aSurface
RenderRootStateManager
*
aManager
wr
:
:
IpcResourceUpdateQueue
&
aResources
wr
:
:
ImageKey
&
aKey
)
;
static
nsresult
Share
(
ImageContainer
*
aContainer
RenderRootStateManager
*
aManager
wr
:
:
IpcResourceUpdateQueue
&
aResources
wr
:
:
ImageKey
&
aKey
ContainerProducerID
aProducerId
)
;
static
Maybe
<
wr
:
:
ExternalImageId
>
GetExternalId
(
const
gfx
:
:
SourceSurfaceSharedData
*
aSurface
)
;
static
gfx
:
:
SourceSurfaceSharedData
*
AsSourceSurfaceSharedData
(
gfx
:
:
SourceSurface
*
aSurface
)
;
static
nsresult
UpdateAnimation
(
ImageContainer
*
aContainer
gfx
:
:
SourceSurface
*
aSurface
const
gfx
:
:
IntRect
&
aDirtyRect
)
;
class
ImageKeyData
{
public
:
ImageKeyData
(
RenderRootStateManager
*
aManager
const
wr
:
:
ImageKey
&
aImageKey
)
;
~
ImageKeyData
(
)
;
ImageKeyData
(
ImageKeyData
&
&
aOther
)
;
ImageKeyData
&
operator
=
(
ImageKeyData
&
&
aOther
)
;
ImageKeyData
(
const
ImageKeyData
&
)
=
delete
;
ImageKeyData
&
operator
=
(
const
ImageKeyData
&
)
=
delete
;
void
MergeDirtyRect
(
const
Maybe
<
gfx
:
:
IntRect
>
&
aDirtyRect
)
;
Maybe
<
gfx
:
:
IntRect
>
TakeDirtyRect
(
)
{
return
std
:
:
move
(
mDirtyRect
)
;
}
RefPtr
<
RenderRootStateManager
>
mManager
;
Maybe
<
gfx
:
:
IntRect
>
mDirtyRect
;
wr
:
:
ImageKey
mImageKey
;
}
;
private
:
SharedSurfacesChild
(
)
=
delete
;
~
SharedSurfacesChild
(
)
=
delete
;
friend
class
SharedSurfacesAnimation
;
class
SharedUserData
final
{
public
:
SharedUserData
(
)
:
mShared
(
false
)
{
}
explicit
SharedUserData
(
const
wr
:
:
ExternalImageId
&
aId
)
:
mId
(
aId
)
mShared
(
false
)
{
}
~
SharedUserData
(
)
;
SharedUserData
(
const
SharedUserData
&
aOther
)
=
delete
;
SharedUserData
&
operator
=
(
const
SharedUserData
&
aOther
)
=
delete
;
SharedUserData
(
SharedUserData
&
&
aOther
)
=
delete
;
SharedUserData
&
operator
=
(
SharedUserData
&
&
aOther
)
=
delete
;
const
wr
:
:
ExternalImageId
&
Id
(
)
const
{
return
mId
;
}
void
SetId
(
const
wr
:
:
ExternalImageId
&
aId
)
{
mId
=
aId
;
mKeys
.
Clear
(
)
;
mShared
=
false
;
}
bool
IsShared
(
)
const
{
return
mShared
;
}
void
MarkShared
(
)
{
MOZ_ASSERT
(
!
mShared
)
;
mShared
=
true
;
}
wr
:
:
ImageKey
UpdateKey
(
RenderRootStateManager
*
aManager
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
Maybe
<
gfx
:
:
IntRect
>
&
aDirtyRect
)
;
protected
:
AutoTArray
<
ImageKeyData
1
>
mKeys
;
wr
:
:
ExternalImageId
mId
;
bool
mShared
:
1
;
}
;
static
nsresult
ShareInternal
(
gfx
:
:
SourceSurfaceSharedData
*
aSurface
SharedUserData
*
*
aUserData
)
;
static
void
Unshare
(
const
wr
:
:
ExternalImageId
&
aId
bool
aReleaseId
nsTArray
<
ImageKeyData
>
&
aKeys
)
;
static
void
DestroySharedUserData
(
void
*
aClosure
)
;
static
gfx
:
:
UserDataKey
sSharedKey
;
}
;
class
AnimationImageKeyData
final
:
public
SharedSurfacesChild
:
:
ImageKeyData
{
public
:
AnimationImageKeyData
(
RenderRootStateManager
*
aManager
const
wr
:
:
ImageKey
&
aImageKey
)
;
~
AnimationImageKeyData
(
)
;
AnimationImageKeyData
(
AnimationImageKeyData
&
&
aOther
)
;
AnimationImageKeyData
&
operator
=
(
AnimationImageKeyData
&
&
aOther
)
;
AutoTArray
<
RefPtr
<
gfx
:
:
SourceSurface
>
2
>
mPendingRelease
;
bool
mRecycling
;
}
;
class
SharedSurfacesAnimation
final
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
SharedSurfacesAnimation
)
SharedSurfacesAnimation
(
)
{
}
void
Destroy
(
)
;
nsresult
SetCurrentFrame
(
gfx
:
:
SourceSurface
*
aParentSurface
gfx
:
:
SourceSurfaceSharedData
*
aSurface
const
gfx
:
:
IntRect
&
aDirtyRect
)
;
nsresult
UpdateKey
(
gfx
:
:
SourceSurface
*
aParentSurface
gfx
:
:
SourceSurfaceSharedData
*
aSurface
RenderRootStateManager
*
aManager
wr
:
:
IpcResourceUpdateQueue
&
aResources
wr
:
:
ImageKey
&
aKey
)
;
void
ReleasePreviousFrame
(
RenderRootStateManager
*
aManager
const
wr
:
:
ExternalImageId
&
aId
)
;
void
Invalidate
(
RenderRootStateManager
*
aManager
)
;
private
:
~
SharedSurfacesAnimation
(
)
;
void
HoldSurfaceForRecycling
(
AnimationImageKeyData
&
aEntry
gfx
:
:
SourceSurface
*
aParentSurface
gfx
:
:
SourceSurfaceSharedData
*
aSurface
)
;
AutoTArray
<
AnimationImageKeyData
1
>
mKeys
;
wr
:
:
ExternalImageId
mId
;
}
;
}
}
#
endif
