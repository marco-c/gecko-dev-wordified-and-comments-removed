#
include
"
ImageBridgeChild
.
h
"
#
include
<
vector
>
#
include
"
ImageBridgeParent
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
Layers
.
h
"
#
include
"
ShadowLayers
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
platform_thread
.
h
"
#
include
"
base
/
process
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
base
/
thread
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
ipc
/
MessageChannel
.
h
"
#
include
"
mozilla
/
ipc
/
Transport
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
layers
/
AsyncCanvasRenderer
.
h
"
#
include
"
mozilla
/
media
/
MediaSystemResourceManager
.
h
"
#
include
"
mozilla
/
media
/
MediaSystemResourceManagerChild
.
h
"
#
include
"
mozilla
/
layers
/
CompositableChild
.
h
"
#
include
"
mozilla
/
layers
/
CompositableClient
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
layers
/
ImageClient
.
h
"
#
include
"
mozilla
/
layers
/
ImageContainerChild
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
layers
/
PCompositableChild
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
namespace
mozilla
{
namespace
ipc
{
class
Shmem
;
}
namespace
layers
{
using
base
:
:
Thread
;
using
base
:
:
ProcessId
;
using
namespace
mozilla
:
:
ipc
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
media
;
typedef
std
:
:
vector
<
CompositableOperation
>
OpVector
;
typedef
nsTArray
<
OpDestroy
>
OpDestroyVector
;
namespace
{
class
ImageBridgeThread
:
public
Thread
{
public
:
ImageBridgeThread
(
)
:
Thread
(
"
ImageBridgeChild
"
)
{
}
protected
:
void
Init
(
)
{
#
ifdef
MOZ_ENABLE_PROFILER_SPS
mPseudoStackHack
=
mozilla_get_pseudo_stack
(
)
;
#
endif
}
void
CleanUp
(
)
{
#
ifdef
MOZ_ENABLE_PROFILER_SPS
mPseudoStackHack
=
nullptr
;
#
endif
}
private
:
#
ifdef
MOZ_ENABLE_PROFILER_SPS
MOZ_INIT_OUTSIDE_CTOR
PseudoStack
*
mPseudoStackHack
;
#
endif
}
;
}
struct
CompositableTransaction
{
CompositableTransaction
(
)
:
mSwapRequired
(
false
)
mFinished
(
true
)
{
}
~
CompositableTransaction
(
)
{
End
(
)
;
}
bool
Finished
(
)
const
{
return
mFinished
;
}
void
Begin
(
)
{
MOZ_ASSERT
(
mFinished
)
;
mFinished
=
false
;
}
void
End
(
)
{
mFinished
=
true
;
mSwapRequired
=
false
;
mOperations
.
clear
(
)
;
mDestroyedActors
.
Clear
(
)
;
}
bool
IsEmpty
(
)
const
{
return
mOperations
.
empty
(
)
&
&
mDestroyedActors
.
IsEmpty
(
)
;
}
void
AddNoSwapEdit
(
const
CompositableOperation
&
op
)
{
MOZ_ASSERT
(
!
Finished
(
)
"
forgot
BeginTransaction
?
"
)
;
mOperations
.
push_back
(
op
)
;
}
void
AddEdit
(
const
CompositableOperation
&
op
)
{
AddNoSwapEdit
(
op
)
;
MarkSyncTransaction
(
)
;
}
void
MarkSyncTransaction
(
)
{
mSwapRequired
=
true
;
}
void
FallbackDestroyActors
(
)
{
for
(
auto
&
actor
:
mDestroyedActors
)
{
switch
(
actor
.
type
(
)
)
{
case
OpDestroy
:
:
TPTextureChild
:
{
DebugOnly
<
bool
>
ok
=
TextureClient
:
:
DestroyFallback
(
actor
.
get_PTextureChild
(
)
)
;
MOZ_ASSERT
(
ok
)
;
break
;
}
case
OpDestroy
:
:
TPCompositableChild
:
{
DebugOnly
<
bool
>
ok
=
actor
.
get_PCompositableChild
(
)
-
>
SendDestroySync
(
)
;
MOZ_ASSERT
(
ok
)
;
break
;
}
default
:
MOZ_CRASH
(
"
GFX
:
IBC
Fallback
destroy
actors
"
)
;
}
}
mDestroyedActors
.
Clear
(
)
;
}
OpVector
mOperations
;
OpDestroyVector
mDestroyedActors
;
bool
mSwapRequired
;
bool
mFinished
;
}
;
struct
AutoEndTransaction
{
explicit
AutoEndTransaction
(
CompositableTransaction
*
aTxn
)
:
mTxn
(
aTxn
)
{
}
~
AutoEndTransaction
(
)
{
mTxn
-
>
End
(
)
;
}
CompositableTransaction
*
mTxn
;
}
;
Atomic
<
bool
>
ImageBridgeChild
:
:
sIsShutDown
(
false
)
;
void
ImageBridgeChild
:
:
UseTextures
(
CompositableClient
*
aCompositable
const
nsTArray
<
TimedTextureClient
>
&
aTextures
)
{
MOZ_ASSERT
(
aCompositable
)
;
MOZ_ASSERT
(
aCompositable
-
>
GetIPDLActor
(
)
)
;
MOZ_ASSERT
(
aCompositable
-
>
IsConnected
(
)
)
;
AutoTArray
<
TimedTexture
4
>
textures
;
for
(
auto
&
t
:
aTextures
)
{
MOZ_ASSERT
(
t
.
mTextureClient
)
;
MOZ_ASSERT
(
t
.
mTextureClient
-
>
GetIPDLActor
(
)
)
;
if
(
!
t
.
mTextureClient
-
>
IsSharedWithCompositor
(
)
)
{
return
;
}
ReadLockDescriptor
readLock
;
t
.
mTextureClient
-
>
SerializeReadLock
(
readLock
)
;
FenceHandle
fence
=
t
.
mTextureClient
-
>
GetAcquireFenceHandle
(
)
;
textures
.
AppendElement
(
TimedTexture
(
nullptr
t
.
mTextureClient
-
>
GetIPDLActor
(
)
readLock
fence
.
IsValid
(
)
?
MaybeFence
(
fence
)
:
MaybeFence
(
null_t
(
)
)
t
.
mTimeStamp
t
.
mPictureRect
t
.
mFrameID
t
.
mProducerID
)
)
;
HoldUntilCompositableRefReleasedIfNecessary
(
t
.
mTextureClient
)
;
}
mTxn
-
>
AddNoSwapEdit
(
CompositableOperation
(
nullptr
aCompositable
-
>
GetIPDLActor
(
)
OpUseTexture
(
textures
)
)
)
;
}
void
ImageBridgeChild
:
:
UseComponentAlphaTextures
(
CompositableClient
*
aCompositable
TextureClient
*
aTextureOnBlack
TextureClient
*
aTextureOnWhite
)
{
MOZ_ASSERT
(
aCompositable
)
;
MOZ_ASSERT
(
aTextureOnWhite
)
;
MOZ_ASSERT
(
aTextureOnBlack
)
;
MOZ_ASSERT
(
aCompositable
-
>
IsConnected
(
)
)
;
MOZ_ASSERT
(
aTextureOnWhite
-
>
GetIPDLActor
(
)
)
;
MOZ_ASSERT
(
aTextureOnBlack
-
>
GetIPDLActor
(
)
)
;
MOZ_ASSERT
(
aTextureOnBlack
-
>
GetSize
(
)
=
=
aTextureOnWhite
-
>
GetSize
(
)
)
;
ReadLockDescriptor
readLockW
;
ReadLockDescriptor
readLockB
;
aTextureOnBlack
-
>
SerializeReadLock
(
readLockB
)
;
aTextureOnWhite
-
>
SerializeReadLock
(
readLockW
)
;
HoldUntilCompositableRefReleasedIfNecessary
(
aTextureOnBlack
)
;
HoldUntilCompositableRefReleasedIfNecessary
(
aTextureOnWhite
)
;
mTxn
-
>
AddNoSwapEdit
(
CompositableOperation
(
nullptr
aCompositable
-
>
GetIPDLActor
(
)
OpUseComponentAlphaTextures
(
nullptr
aTextureOnBlack
-
>
GetIPDLActor
(
)
nullptr
aTextureOnWhite
-
>
GetIPDLActor
(
)
readLockB
readLockW
)
)
)
;
}
#
ifdef
MOZ_WIDGET_GONK
void
ImageBridgeChild
:
:
UseOverlaySource
(
CompositableClient
*
aCompositable
const
OverlaySource
&
aOverlay
const
nsIntRect
&
aPictureRect
)
{
MOZ_ASSERT
(
aCompositable
)
;
MOZ_ASSERT
(
aCompositable
-
>
IsConnected
(
)
)
;
CompositableOperation
op
(
nullptr
aCompositable
-
>
GetIPDLActor
(
)
OpUseOverlaySource
(
aOverlay
aPictureRect
)
)
;
mTxn
-
>
AddEdit
(
op
)
;
}
#
endif
void
ImageBridgeChild
:
:
HoldUntilCompositableRefReleasedIfNecessary
(
TextureClient
*
aClient
)
{
if
(
!
aClient
|
|
!
(
aClient
-
>
GetFlags
(
)
&
TextureFlags
:
:
RECYCLE
)
)
{
return
;
}
aClient
-
>
SetLastFwdTransactionId
(
GetFwdTransactionId
(
)
)
;
mTexturesWaitingRecycled
.
Put
(
aClient
-
>
GetSerial
(
)
aClient
)
;
}
void
ImageBridgeChild
:
:
NotifyNotUsed
(
uint64_t
aTextureId
uint64_t
aFwdTransactionId
)
{
RefPtr
<
TextureClient
>
client
=
mTexturesWaitingRecycled
.
Get
(
aTextureId
)
;
if
(
!
client
)
{
return
;
}
if
(
aFwdTransactionId
<
client
-
>
GetLastFwdTransactionId
(
)
)
{
return
;
}
mTexturesWaitingRecycled
.
Remove
(
aTextureId
)
;
}
void
ImageBridgeChild
:
:
DeliverFence
(
uint64_t
aTextureId
FenceHandle
&
aReleaseFenceHandle
)
{
RefPtr
<
TextureClient
>
client
=
mTexturesWaitingRecycled
.
Get
(
aTextureId
)
;
if
(
!
client
)
{
return
;
}
client
-
>
SetReleaseFenceHandle
(
aReleaseFenceHandle
)
;
}
void
ImageBridgeChild
:
:
HoldUntilFenceHandleDelivery
(
TextureClient
*
aClient
uint64_t
aTransactionId
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
;
#
ifdef
MOZ_WIDGET_GONK
if
(
!
aClient
)
{
return
;
}
MutexAutoLock
lock
(
mWaitingFenceHandleMutex
)
;
aClient
-
>
SetLastFwdTransactionId
(
aTransactionId
)
;
aClient
-
>
WaitFenceHandleOnImageBridge
(
mWaitingFenceHandleMutex
)
;
mTexturesWaitingFenceHandle
.
Put
(
aClient
-
>
GetSerial
(
)
aClient
)
;
#
else
NS_RUNTIMEABORT
(
"
not
reached
"
)
;
#
endif
}
void
ImageBridgeChild
:
:
DeliverFenceToNonRecycle
(
uint64_t
aTextureId
FenceHandle
&
aReleaseFenceHandle
)
{
return
;
#
ifdef
MOZ_WIDGET_GONK
MutexAutoLock
lock
(
mWaitingFenceHandleMutex
)
;
TextureClient
*
client
=
mTexturesWaitingFenceHandle
.
Get
(
aTextureId
)
.
get
(
)
;
if
(
!
client
)
{
return
;
}
MOZ_ASSERT
(
aTextureId
=
=
client
-
>
GetSerial
(
)
)
;
client
-
>
SetReleaseFenceHandle
(
aReleaseFenceHandle
)
;
#
else
NS_RUNTIMEABORT
(
"
not
reached
"
)
;
#
endif
}
void
ImageBridgeChild
:
:
NotifyNotUsedToNonRecycle
(
uint64_t
aTextureId
uint64_t
aTransactionId
)
{
return
;
#
ifdef
MOZ_WIDGET_GONK
MutexAutoLock
lock
(
mWaitingFenceHandleMutex
)
;
RefPtr
<
TextureClient
>
client
=
mTexturesWaitingFenceHandle
.
Get
(
aTextureId
)
;
if
(
!
client
)
{
return
;
}
if
(
aTransactionId
<
client
-
>
GetLastFwdTransactionId
(
)
)
{
return
;
}
MOZ_ASSERT
(
aTextureId
=
=
client
-
>
GetSerial
(
)
)
;
client
-
>
ClearWaitFenceHandleOnImageBridge
(
mWaitingFenceHandleMutex
)
;
mTexturesWaitingFenceHandle
.
Remove
(
aTextureId
)
;
RefPtr
<
TextureClientReleaseTask
>
task
=
MakeAndAddRef
<
TextureClientReleaseTask
>
(
client
)
;
RefPtr
<
ClientIPCAllocator
>
allocator
=
client
-
>
GetAllocator
(
)
;
client
=
nullptr
;
allocator
-
>
AsClientAllocator
(
)
-
>
GetMessageLoop
(
)
-
>
PostTask
(
task
.
forget
(
)
)
;
#
else
NS_RUNTIMEABORT
(
"
not
reached
"
)
;
#
endif
}
void
ImageBridgeChild
:
:
CancelWaitFenceHandle
(
TextureClient
*
aClient
)
{
return
;
#
ifdef
MOZ_WIDGET_GONK
MutexAutoLock
lock
(
mWaitingFenceHandleMutex
)
;
aClient
-
>
ClearWaitFenceHandleOnImageBridge
(
mWaitingFenceHandleMutex
)
;
mTexturesWaitingFenceHandle
.
Remove
(
aClient
-
>
GetSerial
(
)
)
;
#
else
NS_RUNTIMEABORT
(
"
not
reached
"
)
;
#
endif
}
void
ImageBridgeChild
:
:
CancelWaitForRecycle
(
uint64_t
aTextureId
)
{
MOZ_ASSERT
(
InImageBridgeChildThread
(
)
)
;
RefPtr
<
TextureClient
>
client
=
mTexturesWaitingRecycled
.
Get
(
aTextureId
)
;
if
(
!
client
)
{
return
;
}
mTexturesWaitingRecycled
.
Remove
(
aTextureId
)
;
}
static
StaticRefPtr
<
ImageBridgeChild
>
sImageBridgeChildSingleton
;
static
Thread
*
sImageBridgeChildThread
=
nullptr
;
void
ImageBridgeChild
:
:
FallbackDestroyActors
(
)
{
if
(
mTxn
&
&
!
mTxn
-
>
mDestroyedActors
.
IsEmpty
(
)
)
{
mTxn
-
>
FallbackDestroyActors
(
)
;
}
}
class
MOZ_STACK_CLASS
SynchronousTask
{
friend
class
AutoCompleteTask
;
public
:
SynchronousTask
(
const
char
*
name
)
:
mMonitor
(
name
)
mAutoEnter
(
mMonitor
)
mDone
(
false
)
{
}
void
Wait
(
)
{
while
(
!
mDone
)
{
mMonitor
.
Wait
(
)
;
}
}
private
:
void
Complete
(
)
{
mDone
=
true
;
mMonitor
.
NotifyAll
(
)
;
}
private
:
ReentrantMonitor
mMonitor
;
ReentrantMonitorAutoEnter
mAutoEnter
;
bool
mDone
;
}
;
class
MOZ_STACK_CLASS
AutoCompleteTask
{
public
:
AutoCompleteTask
(
SynchronousTask
*
aTask
)
:
mTask
(
aTask
)
mAutoEnter
(
aTask
-
>
mMonitor
)
{
}
~
AutoCompleteTask
(
)
{
mTask
-
>
Complete
(
)
;
}
private
:
SynchronousTask
*
mTask
;
ReentrantMonitorAutoEnter
mAutoEnter
;
}
;
static
void
ImageBridgeShutdownStep1
(
SynchronousTask
*
aTask
)
{
AutoCompleteTask
complete
(
aTask
)
;
MOZ_ASSERT
(
InImageBridgeChildThread
(
)
"
Should
be
in
ImageBridgeChild
thread
.
"
)
;
MediaSystemResourceManager
:
:
Shutdown
(
)
;
if
(
sImageBridgeChildSingleton
)
{
InfallibleTArray
<
PCompositableChild
*
>
compositables
;
sImageBridgeChildSingleton
-
>
ManagedPCompositableChild
(
compositables
)
;
for
(
int
i
=
compositables
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
auto
compositable
=
CompositableClient
:
:
FromIPDLActor
(
compositables
[
i
]
)
;
if
(
compositable
)
{
compositable
-
>
Destroy
(
)
;
}
}
InfallibleTArray
<
PTextureChild
*
>
textures
;
sImageBridgeChildSingleton
-
>
ManagedPTextureChild
(
textures
)
;
for
(
int
i
=
textures
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
RefPtr
<
TextureClient
>
client
=
TextureClient
:
:
AsTextureClient
(
textures
[
i
]
)
;
if
(
client
)
{
client
-
>
Destroy
(
)
;
}
}
sImageBridgeChildSingleton
-
>
FallbackDestroyActors
(
)
;
sImageBridgeChildSingleton
-
>
SendWillClose
(
)
;
sImageBridgeChildSingleton
-
>
MarkShutDown
(
)
;
}
}
static
void
ImageBridgeShutdownStep2
(
SynchronousTask
*
aTask
)
{
AutoCompleteTask
complete
(
aTask
)
;
MOZ_ASSERT
(
InImageBridgeChildThread
(
)
"
Should
be
in
ImageBridgeChild
thread
.
"
)
;
sImageBridgeChildSingleton
-
>
Close
(
)
;
}
void
CreateImageClientSync
(
SynchronousTask
*
aTask
RefPtr
<
ImageBridgeChild
>
aChild
RefPtr
<
ImageClient
>
*
result
CompositableType
aType
ImageContainer
*
aImageContainer
ImageContainerChild
*
aContainerChild
)
{
AutoCompleteTask
complete
(
aTask
)
;
*
result
=
aChild
-
>
CreateImageClientNow
(
aType
aImageContainer
aContainerChild
)
;
}
static
void
CreateCanvasClientSync
(
SynchronousTask
*
aTask
CanvasClient
:
:
CanvasClientType
aType
TextureFlags
aFlags
RefPtr
<
CanvasClient
>
*
const
outResult
)
{
AutoCompleteTask
complete
(
aTask
)
;
*
outResult
=
sImageBridgeChildSingleton
-
>
CreateCanvasClientNow
(
aType
aFlags
)
;
}
static
void
ConnectImageBridge
(
ImageBridgeChild
*
child
ImageBridgeParent
*
parent
)
{
MessageLoop
*
parentMsgLoop
=
parent
-
>
GetMessageLoop
(
)
;
ipc
:
:
MessageChannel
*
parentChannel
=
parent
-
>
GetIPCChannel
(
)
;
child
-
>
Open
(
parentChannel
parentMsgLoop
mozilla
:
:
ipc
:
:
ChildSide
)
;
}
ImageBridgeChild
:
:
ImageBridgeChild
(
)
:
mShuttingDown
(
false
)
mFwdTransactionId
(
0
)
#
ifdef
MOZ_WIDGET_GONK
mWaitingFenceHandleMutex
(
"
ImageBridgeChild
:
:
mWaitingFenceHandleMutex
"
)
#
endif
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mTxn
=
new
CompositableTransaction
(
)
;
}
ImageBridgeChild
:
:
~
ImageBridgeChild
(
)
{
delete
mTxn
;
}
void
ImageBridgeChild
:
:
MarkShutDown
(
)
{
MOZ_ASSERT
(
!
mShuttingDown
)
;
mTexturesWaitingRecycled
.
Clear
(
)
;
mTrackersHolder
.
DestroyAsyncTransactionTrackersHolder
(
)
;
mShuttingDown
=
true
;
}
void
ImageBridgeChild
:
:
Connect
(
CompositableClient
*
aCompositable
ImageContainer
*
aImageContainer
)
{
MOZ_ASSERT
(
aCompositable
)
;
MOZ_ASSERT
(
!
mShuttingDown
)
;
MOZ_ASSERT
(
InImageBridgeChildThread
(
)
)
;
uint64_t
id
=
0
;
PImageContainerChild
*
imageContainerChild
=
nullptr
;
if
(
aImageContainer
)
imageContainerChild
=
aImageContainer
-
>
GetPImageContainerChild
(
)
;
PCompositableChild
*
child
=
SendPCompositableConstructor
(
aCompositable
-
>
GetTextureInfo
(
)
imageContainerChild
&
id
)
;
MOZ_ASSERT
(
child
)
;
aCompositable
-
>
InitIPDLActor
(
child
id
)
;
}
PCompositableChild
*
ImageBridgeChild
:
:
AllocPCompositableChild
(
const
TextureInfo
&
aInfo
PImageContainerChild
*
aChild
uint64_t
*
aID
)
{
MOZ_ASSERT
(
!
mShuttingDown
)
;
return
AsyncCompositableChild
:
:
CreateActor
(
)
;
}
bool
ImageBridgeChild
:
:
DeallocPCompositableChild
(
PCompositableChild
*
aActor
)
{
AsyncCompositableChild
:
:
DestroyActor
(
aActor
)
;
return
true
;
}
Thread
*
ImageBridgeChild
:
:
GetThread
(
)
const
{
return
sImageBridgeChildThread
;
}
ImageBridgeChild
*
ImageBridgeChild
:
:
GetSingleton
(
)
{
return
sImageBridgeChildSingleton
;
}
bool
ImageBridgeChild
:
:
IsCreated
(
)
{
return
GetSingleton
(
)
!
=
nullptr
;
}
static
void
ReleaseImageContainerNow
(
RefPtr
<
ImageBridgeChild
>
aBridge
RefPtr
<
ImageContainerChild
>
aChild
)
{
MOZ_ASSERT
(
InImageBridgeChildThread
(
)
)
;
aChild
-
>
SendAsyncDelete
(
)
;
}
void
ImageBridgeChild
:
:
DispatchReleaseImageContainer
(
ImageContainerChild
*
aChild
)
{
if
(
!
aChild
)
{
return
;
}
RefPtr
<
ImageBridgeChild
>
bridge
=
GetSingleton
(
)
;
if
(
!
bridge
)
{
return
;
}
RefPtr
<
ImageContainerChild
>
child
(
aChild
)
;
bridge
-
>
GetMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
&
ReleaseImageContainerNow
bridge
child
)
)
;
}
static
void
ReleaseTextureClientNow
(
TextureClient
*
aClient
)
{
MOZ_ASSERT
(
InImageBridgeChildThread
(
)
)
;
RELEASE_MANUALLY
(
aClient
)
;
}
void
ImageBridgeChild
:
:
DispatchReleaseTextureClient
(
TextureClient
*
aClient
)
{
if
(
!
aClient
)
{
return
;
}
if
(
!
IsCreated
(
)
)
{
MOZ_ASSERT
(
aClient
-
>
GetIPDLActor
(
)
=
=
nullptr
)
;
RELEASE_MANUALLY
(
aClient
)
;
return
;
}
sImageBridgeChildSingleton
-
>
GetMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
&
ReleaseTextureClientNow
aClient
)
)
;
}
static
void
UpdateImageClientNow
(
RefPtr
<
ImageClient
>
aClient
RefPtr
<
ImageContainer
>
&
&
aContainer
)
{
if
(
!
ImageBridgeChild
:
:
IsCreated
(
)
|
|
ImageBridgeChild
:
:
IsShutDown
(
)
)
{
NS_WARNING
(
"
Something
is
holding
on
to
graphics
resources
after
the
shutdown
"
"
of
the
graphics
subsystem
!
"
)
;
return
;
}
MOZ_ASSERT
(
aClient
)
;
MOZ_ASSERT
(
aContainer
)
;
if
(
!
aClient
-
>
IsConnected
(
)
)
{
return
;
}
sImageBridgeChildSingleton
-
>
BeginTransaction
(
)
;
aClient
-
>
UpdateImage
(
aContainer
Layer
:
:
CONTENT_OPAQUE
)
;
sImageBridgeChildSingleton
-
>
EndTransaction
(
)
;
}
void
ImageBridgeChild
:
:
DispatchImageClientUpdate
(
ImageClient
*
aClient
ImageContainer
*
aContainer
)
{
if
(
!
ImageBridgeChild
:
:
IsCreated
(
)
|
|
ImageBridgeChild
:
:
IsShutDown
(
)
)
{
NS_WARNING
(
"
Something
is
holding
on
to
graphics
resources
after
the
shutdown
"
"
of
the
graphics
subsystem
!
"
)
;
return
;
}
if
(
!
aClient
|
|
!
aContainer
|
|
!
IsCreated
(
)
)
{
return
;
}
if
(
InImageBridgeChildThread
(
)
)
{
UpdateImageClientNow
(
aClient
aContainer
)
;
return
;
}
sImageBridgeChildSingleton
-
>
GetMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
&
UpdateImageClientNow
RefPtr
<
ImageClient
>
(
aClient
)
RefPtr
<
ImageContainer
>
(
aContainer
)
)
)
;
}
static
void
UpdateAsyncCanvasRendererSync
(
SynchronousTask
*
aTask
AsyncCanvasRenderer
*
aWrapper
)
{
AutoCompleteTask
complete
(
aTask
)
;
ImageBridgeChild
:
:
UpdateAsyncCanvasRendererNow
(
aWrapper
)
;
}
void
ImageBridgeChild
:
:
UpdateAsyncCanvasRenderer
(
AsyncCanvasRenderer
*
aWrapper
)
{
aWrapper
-
>
GetCanvasClient
(
)
-
>
UpdateAsync
(
aWrapper
)
;
if
(
InImageBridgeChildThread
(
)
)
{
UpdateAsyncCanvasRendererNow
(
aWrapper
)
;
return
;
}
SynchronousTask
task
(
"
UpdateAsyncCanvasRenderer
Lock
"
)
;
sImageBridgeChildSingleton
-
>
GetMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
&
UpdateAsyncCanvasRendererSync
&
task
aWrapper
)
)
;
task
.
Wait
(
)
;
}
void
ImageBridgeChild
:
:
UpdateAsyncCanvasRendererNow
(
AsyncCanvasRenderer
*
aWrapper
)
{
MOZ_ASSERT
(
aWrapper
)
;
sImageBridgeChildSingleton
-
>
BeginTransaction
(
)
;
aWrapper
-
>
GetCanvasClient
(
)
-
>
Updated
(
)
;
sImageBridgeChildSingleton
-
>
EndTransaction
(
)
;
}
static
void
FlushAllImagesSync
(
SynchronousTask
*
aTask
ImageClient
*
aClient
ImageContainer
*
aContainer
RefPtr
<
AsyncTransactionWaiter
>
&
&
aWaiter
)
{
#
ifdef
MOZ_WIDGET_GONK
MOZ_ASSERT
(
aWaiter
)
;
#
else
MOZ_ASSERT
(
!
aWaiter
)
;
#
endif
AutoCompleteTask
complete
(
aTask
)
;
if
(
!
ImageBridgeChild
:
:
IsCreated
(
)
|
|
ImageBridgeChild
:
:
IsShutDown
(
)
)
{
NS_WARNING
(
"
Something
is
holding
on
to
graphics
resources
after
the
shutdown
"
"
of
the
graphics
subsystem
!
"
)
;
#
ifdef
MOZ_WIDGET_GONK
aWaiter
-
>
DecrementWaitCount
(
)
;
#
endif
return
;
}
MOZ_ASSERT
(
aClient
)
;
sImageBridgeChildSingleton
-
>
BeginTransaction
(
)
;
if
(
aContainer
)
{
aContainer
-
>
ClearImagesFromImageBridge
(
)
;
}
aClient
-
>
FlushAllImages
(
aWaiter
)
;
sImageBridgeChildSingleton
-
>
EndTransaction
(
)
;
#
ifdef
MOZ_WIDGET_GONK
aWaiter
-
>
DecrementWaitCount
(
)
;
#
endif
}
void
ImageBridgeChild
:
:
FlushAllImages
(
ImageClient
*
aClient
ImageContainer
*
aContainer
)
{
if
(
!
IsCreated
(
)
|
|
IsShutDown
(
)
)
{
return
;
}
MOZ_ASSERT
(
aClient
)
;
MOZ_ASSERT
(
!
sImageBridgeChildSingleton
-
>
mShuttingDown
)
;
MOZ_ASSERT
(
!
InImageBridgeChildThread
(
)
)
;
if
(
InImageBridgeChildThread
(
)
)
{
NS_ERROR
(
"
ImageBridgeChild
:
:
FlushAllImages
(
)
is
called
on
ImageBridge
thread
.
"
)
;
return
;
}
SynchronousTask
task
(
"
FlushAllImages
Lock
"
)
;
RefPtr
<
AsyncTransactionWaiter
>
waiter
;
#
ifdef
MOZ_WIDGET_GONK
waiter
=
new
AsyncTransactionWaiter
(
)
;
waiter
-
>
IncrementWaitCount
(
)
;
#
endif
sImageBridgeChildSingleton
-
>
GetMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
&
FlushAllImagesSync
&
task
aClient
aContainer
waiter
)
)
;
task
.
Wait
(
)
;
#
ifdef
MOZ_WIDGET_GONK
waiter
-
>
WaitComplete
(
)
;
#
endif
}
void
ImageBridgeChild
:
:
BeginTransaction
(
)
{
MOZ_ASSERT
(
!
mShuttingDown
)
;
MOZ_ASSERT
(
mTxn
-
>
Finished
(
)
"
uncommitted
txn
?
"
)
;
UpdateFwdTransactionId
(
)
;
mTxn
-
>
Begin
(
)
;
}
void
ImageBridgeChild
:
:
EndTransaction
(
)
{
MOZ_ASSERT
(
!
mShuttingDown
)
;
MOZ_ASSERT
(
!
mTxn
-
>
Finished
(
)
"
forgot
BeginTransaction
?
"
)
;
AutoEndTransaction
_
(
mTxn
)
;
if
(
mTxn
-
>
IsEmpty
(
)
)
{
return
;
}
AutoTArray
<
CompositableOperation
10
>
cset
;
cset
.
SetCapacity
(
mTxn
-
>
mOperations
.
size
(
)
)
;
if
(
!
mTxn
-
>
mOperations
.
empty
(
)
)
{
cset
.
AppendElements
(
&
mTxn
-
>
mOperations
.
front
(
)
mTxn
-
>
mOperations
.
size
(
)
)
;
}
if
(
!
IsSameProcess
(
)
)
{
ShadowLayerForwarder
:
:
PlatformSyncBeforeUpdate
(
)
;
}
AutoTArray
<
EditReply
10
>
replies
;
if
(
mTxn
-
>
mSwapRequired
)
{
if
(
!
SendUpdate
(
cset
mTxn
-
>
mDestroyedActors
GetFwdTransactionId
(
)
&
replies
)
)
{
NS_WARNING
(
"
could
not
send
async
texture
transaction
"
)
;
mTxn
-
>
FallbackDestroyActors
(
)
;
return
;
}
}
else
{
if
(
!
SendUpdateNoSwap
(
cset
mTxn
-
>
mDestroyedActors
GetFwdTransactionId
(
)
)
)
{
NS_WARNING
(
"
could
not
send
async
texture
transaction
(
no
swap
)
"
)
;
mTxn
-
>
FallbackDestroyActors
(
)
;
return
;
}
}
for
(
nsTArray
<
EditReply
>
:
:
size_type
i
=
0
;
i
<
replies
.
Length
(
)
;
+
+
i
)
{
NS_RUNTIMEABORT
(
"
not
reached
"
)
;
}
}
void
ImageBridgeChild
:
:
SendImageBridgeThreadId
(
)
{
#
ifdef
MOZ_WIDGET_GONK
SendImageBridgeThreadId
(
gettid
(
)
)
;
#
endif
}
static
void
CallSendImageBridgeThreadId
(
ImageBridgeChild
*
aImageBridgeChild
)
{
MOZ_ASSERT
(
InImageBridgeChildThread
(
)
)
;
aImageBridgeChild
-
>
SendImageBridgeThreadId
(
)
;
}
bool
ImageBridgeChild
:
:
InitForContent
(
Endpoint
<
PImageBridgeChild
>
&
&
aEndpoint
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
gfxPlatform
:
:
GetPlatform
(
)
;
sImageBridgeChildThread
=
new
ImageBridgeThread
(
)
;
if
(
!
sImageBridgeChildThread
-
>
Start
(
)
)
{
return
false
;
}
sImageBridgeChildSingleton
=
new
ImageBridgeChild
(
)
;
MessageLoop
*
loop
=
sImageBridgeChildSingleton
-
>
GetMessageLoop
(
)
;
loop
-
>
PostTask
(
NewRunnableMethod
<
Endpoint
<
PImageBridgeChild
>
&
&
>
(
sImageBridgeChildSingleton
&
ImageBridgeChild
:
:
Bind
Move
(
aEndpoint
)
)
)
;
loop
-
>
PostTask
(
NewRunnableFunction
(
CallSendImageBridgeThreadId
sImageBridgeChildSingleton
.
get
(
)
)
)
;
return
sImageBridgeChildSingleton
;
}
void
ImageBridgeChild
:
:
Bind
(
Endpoint
<
PImageBridgeChild
>
&
&
aEndpoint
)
{
aEndpoint
.
Bind
(
this
)
;
}
void
ImageBridgeChild
:
:
ShutDown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
sIsShutDown
=
true
;
if
(
ImageBridgeChild
:
:
IsCreated
(
)
)
{
MOZ_ASSERT
(
!
sImageBridgeChildSingleton
-
>
mShuttingDown
)
;
{
SynchronousTask
task
(
"
ImageBridge
ShutdownStep1
lock
"
)
;
sImageBridgeChildSingleton
-
>
GetMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
&
ImageBridgeShutdownStep1
&
task
)
)
;
task
.
Wait
(
)
;
}
{
SynchronousTask
task
(
"
ImageBridge
ShutdownStep2
lock
"
)
;
sImageBridgeChildSingleton
-
>
GetMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
&
ImageBridgeShutdownStep2
&
task
)
)
;
task
.
Wait
(
)
;
}
sImageBridgeChildSingleton
=
nullptr
;
delete
sImageBridgeChildThread
;
sImageBridgeChildThread
=
nullptr
;
}
}
void
ImageBridgeChild
:
:
InitSameProcess
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Should
be
on
the
main
Thread
!
"
)
;
MOZ_ASSERT
(
!
sImageBridgeChildSingleton
)
;
MOZ_ASSERT
(
!
sImageBridgeChildThread
)
;
sImageBridgeChildThread
=
new
ImageBridgeThread
(
)
;
if
(
!
sImageBridgeChildThread
-
>
IsRunning
(
)
)
{
sImageBridgeChildThread
-
>
Start
(
)
;
}
sImageBridgeChildSingleton
=
new
ImageBridgeChild
(
)
;
RefPtr
<
ImageBridgeParent
>
parent
=
ImageBridgeParent
:
:
CreateSameProcess
(
)
;
sImageBridgeChildSingleton
-
>
ConnectAsync
(
parent
)
;
sImageBridgeChildSingleton
-
>
GetMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
CallSendImageBridgeThreadId
sImageBridgeChildSingleton
.
get
(
)
)
)
;
}
void
ImageBridgeChild
:
:
InitWithGPUProcess
(
Endpoint
<
PImageBridgeChild
>
&
&
aEndpoint
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
sImageBridgeChildSingleton
)
;
MOZ_ASSERT
(
!
sImageBridgeChildThread
)
;
sImageBridgeChildThread
=
new
ImageBridgeThread
(
)
;
if
(
!
sImageBridgeChildThread
-
>
IsRunning
(
)
)
{
sImageBridgeChildThread
-
>
Start
(
)
;
}
sImageBridgeChildSingleton
=
new
ImageBridgeChild
(
)
;
MessageLoop
*
loop
=
sImageBridgeChildSingleton
-
>
GetMessageLoop
(
)
;
loop
-
>
PostTask
(
NewRunnableMethod
<
Endpoint
<
PImageBridgeChild
>
&
&
>
(
sImageBridgeChildSingleton
&
ImageBridgeChild
:
:
Bind
Move
(
aEndpoint
)
)
)
;
}
bool
InImageBridgeChildThread
(
)
{
return
ImageBridgeChild
:
:
IsCreated
(
)
&
&
sImageBridgeChildThread
-
>
thread_id
(
)
=
=
PlatformThread
:
:
CurrentId
(
)
;
}
MessageLoop
*
ImageBridgeChild
:
:
GetMessageLoop
(
)
const
{
return
sImageBridgeChildThread
?
sImageBridgeChildThread
-
>
message_loop
(
)
:
nullptr
;
}
void
ImageBridgeChild
:
:
ConnectAsync
(
ImageBridgeParent
*
aParent
)
{
GetMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
&
ConnectImageBridge
this
aParent
)
)
;
}
void
ImageBridgeChild
:
:
IdentifyCompositorTextureHost
(
const
TextureFactoryIdentifier
&
aIdentifier
)
{
if
(
sImageBridgeChildSingleton
)
{
sImageBridgeChildSingleton
-
>
IdentifyTextureHost
(
aIdentifier
)
;
}
}
RefPtr
<
ImageClient
>
ImageBridgeChild
:
:
CreateImageClient
(
CompositableType
aType
ImageContainer
*
aImageContainer
ImageContainerChild
*
aContainerChild
)
{
if
(
InImageBridgeChildThread
(
)
)
{
return
CreateImageClientNow
(
aType
aImageContainer
aContainerChild
)
;
}
SynchronousTask
task
(
"
CreateImageClient
Lock
"
)
;
RefPtr
<
ImageClient
>
result
=
nullptr
;
GetMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
&
CreateImageClientSync
&
task
this
&
result
aType
aImageContainer
aContainerChild
)
)
;
task
.
Wait
(
)
;
return
result
;
}
RefPtr
<
ImageClient
>
ImageBridgeChild
:
:
CreateImageClientNow
(
CompositableType
aType
ImageContainer
*
aImageContainer
ImageContainerChild
*
aContainerChild
)
{
MOZ_ASSERT
(
!
mShuttingDown
)
;
MOZ_ASSERT
(
InImageBridgeChildThread
(
)
)
;
if
(
aImageContainer
)
{
SendPImageContainerConstructor
(
aContainerChild
)
;
aContainerChild
-
>
RegisterWithIPDL
(
)
;
}
RefPtr
<
ImageClient
>
client
=
ImageClient
:
:
CreateImageClient
(
aType
this
TextureFlags
:
:
NO_FLAGS
)
;
MOZ_ASSERT
(
client
"
failed
to
create
ImageClient
"
)
;
if
(
client
)
{
client
-
>
Connect
(
aImageContainer
)
;
}
return
client
;
}
already_AddRefed
<
CanvasClient
>
ImageBridgeChild
:
:
CreateCanvasClient
(
CanvasClient
:
:
CanvasClientType
aType
TextureFlags
aFlag
)
{
if
(
InImageBridgeChildThread
(
)
)
{
return
CreateCanvasClientNow
(
aType
aFlag
)
;
}
SynchronousTask
task
(
"
CreateCanvasClient
Lock
"
)
;
RefPtr
<
CanvasClient
>
result
=
nullptr
;
GetMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
&
CreateCanvasClientSync
&
task
aType
aFlag
&
result
)
)
;
task
.
Wait
(
)
;
return
result
.
forget
(
)
;
}
already_AddRefed
<
CanvasClient
>
ImageBridgeChild
:
:
CreateCanvasClientNow
(
CanvasClient
:
:
CanvasClientType
aType
TextureFlags
aFlag
)
{
RefPtr
<
CanvasClient
>
client
=
CanvasClient
:
:
CreateCanvasClient
(
aType
this
aFlag
)
;
MOZ_ASSERT
(
client
"
failed
to
create
CanvasClient
"
)
;
if
(
client
)
{
client
-
>
Connect
(
)
;
}
return
client
.
forget
(
)
;
}
bool
ImageBridgeChild
:
:
AllocUnsafeShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
MOZ_ASSERT
(
!
mShuttingDown
)
;
if
(
InImageBridgeChildThread
(
)
)
{
return
PImageBridgeChild
:
:
AllocUnsafeShmem
(
aSize
aType
aShmem
)
;
}
else
{
return
DispatchAllocShmemInternal
(
aSize
aType
aShmem
true
)
;
}
}
bool
ImageBridgeChild
:
:
AllocShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
MOZ_ASSERT
(
!
mShuttingDown
)
;
if
(
InImageBridgeChildThread
(
)
)
{
return
PImageBridgeChild
:
:
AllocShmem
(
aSize
aType
aShmem
)
;
}
else
{
return
DispatchAllocShmemInternal
(
aSize
aType
aShmem
false
)
;
}
}
struct
AllocShmemParams
{
RefPtr
<
ISurfaceAllocator
>
mAllocator
;
size_t
mSize
;
ipc
:
:
SharedMemory
:
:
SharedMemoryType
mType
;
ipc
:
:
Shmem
*
mShmem
;
bool
mUnsafe
;
bool
mSuccess
;
}
;
static
void
ProxyAllocShmemNow
(
SynchronousTask
*
aTask
AllocShmemParams
*
aParams
)
{
AutoCompleteTask
complete
(
aTask
)
;
MOZ_ASSERT
(
aParams
)
;
auto
shmAllocator
=
aParams
-
>
mAllocator
-
>
AsShmemAllocator
(
)
;
if
(
aParams
-
>
mUnsafe
)
{
aParams
-
>
mSuccess
=
shmAllocator
-
>
AllocUnsafeShmem
(
aParams
-
>
mSize
aParams
-
>
mType
aParams
-
>
mShmem
)
;
}
else
{
aParams
-
>
mSuccess
=
shmAllocator
-
>
AllocShmem
(
aParams
-
>
mSize
aParams
-
>
mType
aParams
-
>
mShmem
)
;
}
}
bool
ImageBridgeChild
:
:
DispatchAllocShmemInternal
(
size_t
aSize
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
bool
aUnsafe
)
{
SynchronousTask
task
(
"
AllocatorProxy
alloc
"
)
;
AllocShmemParams
params
=
{
this
aSize
aType
aShmem
aUnsafe
true
}
;
GetMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
&
ProxyAllocShmemNow
&
task
&
params
)
)
;
task
.
Wait
(
)
;
return
params
.
mSuccess
;
}
static
void
ProxyDeallocShmemNow
(
SynchronousTask
*
aTask
ISurfaceAllocator
*
aAllocator
ipc
:
:
Shmem
*
aShmem
)
{
AutoCompleteTask
complete
(
aTask
)
;
MOZ_ASSERT
(
aShmem
)
;
aAllocator
-
>
AsShmemAllocator
(
)
-
>
DeallocShmem
(
*
aShmem
)
;
}
void
ImageBridgeChild
:
:
DeallocShmem
(
ipc
:
:
Shmem
&
aShmem
)
{
if
(
InImageBridgeChildThread
(
)
)
{
PImageBridgeChild
:
:
DeallocShmem
(
aShmem
)
;
}
else
{
SynchronousTask
task
(
"
AllocatorProxy
Dealloc
"
)
;
GetMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
&
ProxyDeallocShmemNow
&
task
this
&
aShmem
)
)
;
task
.
Wait
(
)
;
}
}
PTextureChild
*
ImageBridgeChild
:
:
AllocPTextureChild
(
const
SurfaceDescriptor
&
const
LayersBackend
&
const
TextureFlags
&
const
uint64_t
&
aSerial
)
{
MOZ_ASSERT
(
!
mShuttingDown
)
;
return
TextureClient
:
:
CreateIPDLActor
(
)
;
}
bool
ImageBridgeChild
:
:
DeallocPTextureChild
(
PTextureChild
*
actor
)
{
return
TextureClient
:
:
DestroyIPDLActor
(
actor
)
;
}
PMediaSystemResourceManagerChild
*
ImageBridgeChild
:
:
AllocPMediaSystemResourceManagerChild
(
)
{
MOZ_ASSERT
(
!
mShuttingDown
)
;
return
new
mozilla
:
:
media
:
:
MediaSystemResourceManagerChild
(
)
;
}
bool
ImageBridgeChild
:
:
DeallocPMediaSystemResourceManagerChild
(
PMediaSystemResourceManagerChild
*
aActor
)
{
MOZ_ASSERT
(
aActor
)
;
delete
static_cast
<
mozilla
:
:
media
:
:
MediaSystemResourceManagerChild
*
>
(
aActor
)
;
return
true
;
}
PImageContainerChild
*
ImageBridgeChild
:
:
AllocPImageContainerChild
(
)
{
NS_RUNTIMEABORT
(
"
not
reached
"
)
;
return
nullptr
;
}
bool
ImageBridgeChild
:
:
DeallocPImageContainerChild
(
PImageContainerChild
*
actor
)
{
static_cast
<
ImageContainerChild
*
>
(
actor
)
-
>
UnregisterFromIPDL
(
)
;
return
true
;
}
bool
ImageBridgeChild
:
:
RecvParentAsyncMessages
(
InfallibleTArray
<
AsyncParentMessageData
>
&
&
aMessages
)
{
for
(
AsyncParentMessageArray
:
:
index_type
i
=
0
;
i
<
aMessages
.
Length
(
)
;
+
+
i
)
{
const
AsyncParentMessageData
&
message
=
aMessages
[
i
]
;
switch
(
message
.
type
(
)
)
{
case
AsyncParentMessageData
:
:
TOpDeliverFence
:
{
const
OpDeliverFence
&
op
=
message
.
get_OpDeliverFence
(
)
;
FenceHandle
fence
=
op
.
fence
(
)
;
DeliverFence
(
op
.
TextureId
(
)
fence
)
;
break
;
}
case
AsyncParentMessageData
:
:
TOpDeliverFenceToNonRecycle
:
{
const
OpDeliverFenceToNonRecycle
&
op
=
message
.
get_OpDeliverFenceToNonRecycle
(
)
;
FenceHandle
fence
=
op
.
fence
(
)
;
DeliverFenceToNonRecycle
(
op
.
TextureId
(
)
fence
)
;
break
;
}
case
AsyncParentMessageData
:
:
TOpNotifyNotUsed
:
{
const
OpNotifyNotUsed
&
op
=
message
.
get_OpNotifyNotUsed
(
)
;
NotifyNotUsed
(
op
.
TextureId
(
)
op
.
fwdTransactionId
(
)
)
;
break
;
}
case
AsyncParentMessageData
:
:
TOpNotifyNotUsedToNonRecycle
:
{
const
OpNotifyNotUsedToNonRecycle
&
op
=
message
.
get_OpNotifyNotUsedToNonRecycle
(
)
;
NotifyNotUsedToNonRecycle
(
op
.
TextureId
(
)
op
.
fwdTransactionId
(
)
)
;
break
;
}
case
AsyncParentMessageData
:
:
TOpReplyRemoveTexture
:
{
const
OpReplyRemoveTexture
&
op
=
message
.
get_OpReplyRemoveTexture
(
)
;
MOZ_ASSERT
(
mTrackersHolder
.
GetId
(
)
=
=
op
.
holderId
(
)
)
;
mTrackersHolder
.
TransactionCompleteted
(
op
.
transactionId
(
)
)
;
break
;
}
default
:
NS_ERROR
(
"
unknown
AsyncParentMessageData
type
"
)
;
return
false
;
}
}
return
true
;
}
bool
ImageBridgeChild
:
:
RecvDidComposite
(
InfallibleTArray
<
ImageCompositeNotification
>
&
&
aNotifications
)
{
for
(
auto
&
n
:
aNotifications
)
{
ImageContainerChild
*
child
=
static_cast
<
ImageContainerChild
*
>
(
n
.
imageContainerChild
(
)
)
;
if
(
child
)
{
child
-
>
NotifyComposite
(
n
)
;
}
}
return
true
;
}
PTextureChild
*
ImageBridgeChild
:
:
CreateTexture
(
const
SurfaceDescriptor
&
aSharedData
LayersBackend
aLayersBackend
TextureFlags
aFlags
uint64_t
aSerial
)
{
MOZ_ASSERT
(
!
mShuttingDown
)
;
return
SendPTextureConstructor
(
aSharedData
aLayersBackend
aFlags
aSerial
)
;
}
static
bool
IBCAddOpDestroy
(
CompositableTransaction
*
aTxn
const
OpDestroy
&
op
bool
synchronously
)
{
if
(
aTxn
-
>
Finished
(
)
)
{
return
false
;
}
aTxn
-
>
mDestroyedActors
.
AppendElement
(
op
)
;
if
(
synchronously
)
{
aTxn
-
>
MarkSyncTransaction
(
)
;
}
return
true
;
}
bool
ImageBridgeChild
:
:
DestroyInTransaction
(
PTextureChild
*
aTexture
bool
synchronously
)
{
return
IBCAddOpDestroy
(
mTxn
OpDestroy
(
aTexture
)
synchronously
)
;
}
bool
ImageBridgeChild
:
:
DestroyInTransaction
(
PCompositableChild
*
aCompositable
bool
synchronously
)
{
return
IBCAddOpDestroy
(
mTxn
OpDestroy
(
aCompositable
)
synchronously
)
;
}
void
ImageBridgeChild
:
:
RemoveTextureFromCompositable
(
CompositableClient
*
aCompositable
TextureClient
*
aTexture
)
{
MOZ_ASSERT
(
!
mShuttingDown
)
;
MOZ_ASSERT
(
aTexture
)
;
MOZ_ASSERT
(
aTexture
-
>
IsSharedWithCompositor
(
)
)
;
MOZ_ASSERT
(
aCompositable
-
>
IsConnected
(
)
)
;
if
(
!
aTexture
|
|
!
aTexture
-
>
IsSharedWithCompositor
(
)
|
|
!
aCompositable
-
>
IsConnected
(
)
)
{
return
;
}
CompositableOperation
op
(
nullptr
aCompositable
-
>
GetIPDLActor
(
)
OpRemoveTexture
(
nullptr
aTexture
-
>
GetIPDLActor
(
)
)
)
;
if
(
aTexture
-
>
GetFlags
(
)
&
TextureFlags
:
:
DEALLOCATE_CLIENT
)
{
mTxn
-
>
AddEdit
(
op
)
;
}
else
{
mTxn
-
>
AddNoSwapEdit
(
op
)
;
}
}
void
ImageBridgeChild
:
:
RemoveTextureFromCompositableAsync
(
AsyncTransactionTracker
*
aAsyncTransactionTracker
CompositableClient
*
aCompositable
TextureClient
*
aTexture
)
{
MOZ_ASSERT
(
!
mShuttingDown
)
;
MOZ_ASSERT
(
aTexture
)
;
MOZ_ASSERT
(
aTexture
-
>
IsSharedWithCompositor
(
)
)
;
MOZ_ASSERT
(
aCompositable
-
>
IsConnected
(
)
)
;
if
(
!
aTexture
|
|
!
aTexture
-
>
IsSharedWithCompositor
(
)
|
|
!
aCompositable
-
>
IsConnected
(
)
)
{
return
;
}
CompositableOperation
op
(
nullptr
aCompositable
-
>
GetIPDLActor
(
)
OpRemoveTextureAsync
(
mTrackersHolder
.
GetId
(
)
aAsyncTransactionTracker
-
>
GetId
(
)
nullptr
aCompositable
-
>
GetIPDLActor
(
)
nullptr
aTexture
-
>
GetIPDLActor
(
)
)
)
;
mTxn
-
>
AddNoSwapEdit
(
op
)
;
mTrackersHolder
.
HoldUntilComplete
(
aAsyncTransactionTracker
)
;
}
bool
ImageBridgeChild
:
:
IsSameProcess
(
)
const
{
return
OtherPid
(
)
=
=
base
:
:
GetCurrentProcId
(
)
;
}
static
void
DestroyCompositableNow
(
RefPtr
<
ImageBridgeChild
>
aImageBridge
RefPtr
<
CompositableChild
>
aCompositable
)
{
aImageBridge
-
>
Destroy
(
aCompositable
)
;
}
void
ImageBridgeChild
:
:
Destroy
(
CompositableChild
*
aCompositable
)
{
if
(
!
InImageBridgeChildThread
(
)
)
{
RefPtr
<
ImageBridgeChild
>
self
=
this
;
RefPtr
<
CompositableChild
>
compositable
=
aCompositable
;
GetMessageLoop
(
)
-
>
PostTask
(
NewRunnableFunction
(
&
DestroyCompositableNow
self
compositable
)
)
;
return
;
}
CompositableForwarder
:
:
Destroy
(
aCompositable
)
;
}
}
}
