#
include
"
ImageBridgeChild
.
h
"
#
include
<
vector
>
#
include
"
ImageBridgeParent
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
Layers
.
h
"
#
include
"
ShadowLayers
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
platform_thread
.
h
"
#
include
"
base
/
process
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
base
/
thread
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
ipc
/
MessageChannel
.
h
"
#
include
"
mozilla
/
ipc
/
Transport
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
layers
/
AsyncCanvasRenderer
.
h
"
#
include
"
mozilla
/
media
/
MediaSystemResourceManager
.
h
"
#
include
"
mozilla
/
media
/
MediaSystemResourceManagerChild
.
h
"
#
include
"
mozilla
/
layers
/
CompositableClient
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
layers
/
ImageClient
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mtransport
/
runnable_utils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
SynchronousTask
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
mozilla
/
gfx
/
DeviceManagerDx
.
h
"
#
endif
namespace
mozilla
{
namespace
ipc
{
class
Shmem
;
}
namespace
layers
{
using
base
:
:
ProcessId
;
using
base
:
:
Thread
;
using
namespace
mozilla
:
:
ipc
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
media
;
typedef
std
:
:
vector
<
CompositableOperation
>
OpVector
;
typedef
nsTArray
<
OpDestroy
>
OpDestroyVector
;
struct
CompositableTransaction
{
CompositableTransaction
(
)
:
mFinished
(
true
)
{
}
~
CompositableTransaction
(
)
{
End
(
)
;
}
bool
Finished
(
)
const
{
return
mFinished
;
}
void
Begin
(
)
{
MOZ_ASSERT
(
mFinished
)
;
mFinished
=
false
;
}
void
End
(
)
{
mFinished
=
true
;
mOperations
.
clear
(
)
;
mDestroyedActors
.
Clear
(
)
;
}
bool
IsEmpty
(
)
const
{
return
mOperations
.
empty
(
)
&
&
mDestroyedActors
.
IsEmpty
(
)
;
}
void
AddNoSwapEdit
(
const
CompositableOperation
&
op
)
{
MOZ_ASSERT
(
!
Finished
(
)
"
forgot
BeginTransaction
?
"
)
;
mOperations
.
push_back
(
op
)
;
}
OpVector
mOperations
;
OpDestroyVector
mDestroyedActors
;
bool
mFinished
;
}
;
struct
AutoEndTransaction
{
explicit
AutoEndTransaction
(
CompositableTransaction
*
aTxn
)
:
mTxn
(
aTxn
)
{
}
~
AutoEndTransaction
(
)
{
mTxn
-
>
End
(
)
;
}
CompositableTransaction
*
mTxn
;
}
;
void
ImageBridgeChild
:
:
UseTextures
(
CompositableClient
*
aCompositable
const
nsTArray
<
TimedTextureClient
>
&
aTextures
)
{
MOZ_ASSERT
(
aCompositable
)
;
MOZ_ASSERT
(
aCompositable
-
>
GetIPCHandle
(
)
)
;
MOZ_ASSERT
(
aCompositable
-
>
IsConnected
(
)
)
;
AutoTArray
<
TimedTexture
4
>
textures
;
for
(
auto
&
t
:
aTextures
)
{
MOZ_ASSERT
(
t
.
mTextureClient
)
;
MOZ_ASSERT
(
t
.
mTextureClient
-
>
GetIPDLActor
(
)
)
;
if
(
!
t
.
mTextureClient
-
>
IsSharedWithCompositor
(
)
)
{
return
;
}
bool
readLocked
=
t
.
mTextureClient
-
>
OnForwardedToHost
(
)
;
textures
.
AppendElement
(
TimedTexture
(
nullptr
t
.
mTextureClient
-
>
GetIPDLActor
(
)
t
.
mTimeStamp
t
.
mPictureRect
t
.
mFrameID
t
.
mProducerID
readLocked
)
)
;
HoldUntilCompositableRefReleasedIfNecessary
(
t
.
mTextureClient
)
;
}
mTxn
-
>
AddNoSwapEdit
(
CompositableOperation
(
aCompositable
-
>
GetIPCHandle
(
)
OpUseTexture
(
textures
)
)
)
;
}
void
ImageBridgeChild
:
:
UseComponentAlphaTextures
(
CompositableClient
*
aCompositable
TextureClient
*
aTextureOnBlack
TextureClient
*
aTextureOnWhite
)
{
MOZ_CRASH
(
"
should
not
be
called
"
)
;
}
void
ImageBridgeChild
:
:
HoldUntilCompositableRefReleasedIfNecessary
(
TextureClient
*
aClient
)
{
if
(
!
aClient
|
|
!
(
aClient
-
>
GetFlags
(
)
&
TextureFlags
:
:
RECYCLE
)
)
{
return
;
}
aClient
-
>
SetLastFwdTransactionId
(
GetFwdTransactionId
(
)
)
;
mTexturesWaitingRecycled
.
emplace
(
aClient
-
>
GetSerial
(
)
aClient
)
;
}
void
ImageBridgeChild
:
:
NotifyNotUsed
(
uint64_t
aTextureId
uint64_t
aFwdTransactionId
)
{
auto
it
=
mTexturesWaitingRecycled
.
find
(
aTextureId
)
;
if
(
it
!
=
mTexturesWaitingRecycled
.
end
(
)
)
{
if
(
aFwdTransactionId
<
it
-
>
second
-
>
GetLastFwdTransactionId
(
)
)
{
return
;
}
mTexturesWaitingRecycled
.
erase
(
it
)
;
}
}
void
ImageBridgeChild
:
:
CancelWaitForRecycle
(
uint64_t
aTextureId
)
{
MOZ_ASSERT
(
InImageBridgeChildThread
(
)
)
;
mTexturesWaitingRecycled
.
erase
(
aTextureId
)
;
}
static
StaticMutex
sImageBridgeSingletonLock
;
static
StaticRefPtr
<
ImageBridgeChild
>
sImageBridgeChildSingleton
;
static
Thread
*
sImageBridgeChildThread
=
nullptr
;
void
ImageBridgeChild
:
:
ShutdownStep1
(
SynchronousTask
*
aTask
)
{
AutoCompleteTask
complete
(
aTask
)
;
MOZ_ASSERT
(
InImageBridgeChildThread
(
)
"
Should
be
in
ImageBridgeChild
thread
.
"
)
;
MediaSystemResourceManager
:
:
Shutdown
(
)
;
InfallibleTArray
<
PTextureChild
*
>
textures
;
ManagedPTextureChild
(
textures
)
;
for
(
int
i
=
textures
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
RefPtr
<
TextureClient
>
client
=
TextureClient
:
:
AsTextureClient
(
textures
[
i
]
)
;
if
(
client
)
{
client
-
>
Destroy
(
)
;
}
}
if
(
mCanSend
)
{
SendWillClose
(
)
;
}
MarkShutDown
(
)
;
}
void
ImageBridgeChild
:
:
ShutdownStep2
(
SynchronousTask
*
aTask
)
{
AutoCompleteTask
complete
(
aTask
)
;
MOZ_ASSERT
(
InImageBridgeChildThread
(
)
"
Should
be
in
ImageBridgeChild
thread
.
"
)
;
if
(
!
mDestroyed
)
{
Close
(
)
;
}
}
void
ImageBridgeChild
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
mCanSend
=
false
;
mDestroyed
=
true
;
{
MutexAutoLock
lock
(
mContainerMapLock
)
;
mImageContainerListeners
.
clear
(
)
;
}
}
void
ImageBridgeChild
:
:
DeallocPImageBridgeChild
(
)
{
this
-
>
Release
(
)
;
}
void
ImageBridgeChild
:
:
CreateImageClientSync
(
SynchronousTask
*
aTask
RefPtr
<
ImageClient
>
*
result
CompositableType
aType
ImageContainer
*
aImageContainer
)
{
AutoCompleteTask
complete
(
aTask
)
;
*
result
=
CreateImageClientNow
(
aType
aImageContainer
)
;
}
void
ImageBridgeChild
:
:
CreateCanvasClientSync
(
SynchronousTask
*
aTask
CanvasClient
:
:
CanvasClientType
aType
TextureFlags
aFlags
RefPtr
<
CanvasClient
>
*
const
outResult
)
{
AutoCompleteTask
complete
(
aTask
)
;
*
outResult
=
CreateCanvasClientNow
(
aType
aFlags
)
;
}
ImageBridgeChild
:
:
ImageBridgeChild
(
uint32_t
aNamespace
)
:
mNamespace
(
aNamespace
)
mCanSend
(
false
)
mDestroyed
(
false
)
mFwdTransactionId
(
0
)
mContainerMapLock
(
"
ImageBridgeChild
.
mContainerMapLock
"
)
{
MOZ_ASSERT
(
mNamespace
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mTxn
=
new
CompositableTransaction
(
)
;
}
ImageBridgeChild
:
:
~
ImageBridgeChild
(
)
{
delete
mTxn
;
}
void
ImageBridgeChild
:
:
MarkShutDown
(
)
{
mTexturesWaitingRecycled
.
clear
(
)
;
mCanSend
=
false
;
}
void
ImageBridgeChild
:
:
Connect
(
CompositableClient
*
aCompositable
ImageContainer
*
aImageContainer
)
{
MOZ_ASSERT
(
aCompositable
)
;
MOZ_ASSERT
(
InImageBridgeChildThread
(
)
)
;
MOZ_ASSERT
(
CanSend
(
)
)
;
static
uint64_t
sNextID
=
1
;
uint64_t
id
=
sNextID
+
+
;
if
(
aImageContainer
)
{
MutexAutoLock
lock
(
mContainerMapLock
)
;
MOZ_ASSERT
(
mImageContainerListeners
.
find
(
id
)
=
=
mImageContainerListeners
.
end
(
)
)
;
mImageContainerListeners
.
emplace
(
id
aImageContainer
-
>
GetImageContainerListener
(
)
)
;
}
CompositableHandle
handle
(
id
)
;
aCompositable
-
>
InitIPDL
(
handle
)
;
SendNewCompositable
(
handle
aCompositable
-
>
GetTextureInfo
(
)
GetCompositorBackendType
(
)
)
;
}
void
ImageBridgeChild
:
:
ForgetImageContainer
(
const
CompositableHandle
&
aHandle
)
{
MutexAutoLock
lock
(
mContainerMapLock
)
;
mImageContainerListeners
.
erase
(
aHandle
.
Value
(
)
)
;
}
Thread
*
ImageBridgeChild
:
:
GetThread
(
)
const
{
return
sImageBridgeChildThread
;
}
RefPtr
<
ImageBridgeChild
>
ImageBridgeChild
:
:
GetSingleton
(
)
{
StaticMutexAutoLock
lock
(
sImageBridgeSingletonLock
)
;
return
sImageBridgeChildSingleton
;
}
void
ImageBridgeChild
:
:
UpdateImageClient
(
RefPtr
<
ImageContainer
>
aContainer
)
{
if
(
!
aContainer
)
{
return
;
}
if
(
!
InImageBridgeChildThread
(
)
)
{
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
RefPtr
<
ImageBridgeChild
>
(
this
)
&
ImageBridgeChild
:
:
UpdateImageClient
aContainer
)
;
GetMessageLoop
(
)
-
>
PostTask
(
runnable
.
forget
(
)
)
;
return
;
}
if
(
!
CanSend
(
)
)
{
return
;
}
RefPtr
<
ImageClient
>
client
=
aContainer
-
>
GetImageClient
(
)
;
if
(
NS_WARN_IF
(
!
client
)
)
{
return
;
}
if
(
!
client
-
>
IsConnected
(
)
)
{
return
;
}
BeginTransaction
(
)
;
client
-
>
UpdateImage
(
aContainer
Layer
:
:
CONTENT_OPAQUE
)
;
EndTransaction
(
)
;
}
void
ImageBridgeChild
:
:
UpdateAsyncCanvasRendererSync
(
SynchronousTask
*
aTask
AsyncCanvasRenderer
*
aWrapper
)
{
AutoCompleteTask
complete
(
aTask
)
;
UpdateAsyncCanvasRendererNow
(
aWrapper
)
;
}
void
ImageBridgeChild
:
:
UpdateAsyncCanvasRenderer
(
AsyncCanvasRenderer
*
aWrapper
)
{
aWrapper
-
>
GetCanvasClient
(
)
-
>
UpdateAsync
(
aWrapper
)
;
if
(
InImageBridgeChildThread
(
)
)
{
UpdateAsyncCanvasRendererNow
(
aWrapper
)
;
return
;
}
SynchronousTask
task
(
"
UpdateAsyncCanvasRenderer
Lock
"
)
;
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
RefPtr
<
ImageBridgeChild
>
(
this
)
&
ImageBridgeChild
:
:
UpdateAsyncCanvasRendererSync
&
task
aWrapper
)
;
GetMessageLoop
(
)
-
>
PostTask
(
runnable
.
forget
(
)
)
;
task
.
Wait
(
)
;
}
void
ImageBridgeChild
:
:
UpdateAsyncCanvasRendererNow
(
AsyncCanvasRenderer
*
aWrapper
)
{
MOZ_ASSERT
(
aWrapper
)
;
if
(
!
CanSend
(
)
)
{
return
;
}
BeginTransaction
(
)
;
aWrapper
-
>
GetCanvasClient
(
)
-
>
Updated
(
)
;
EndTransaction
(
)
;
}
void
ImageBridgeChild
:
:
FlushAllImagesSync
(
SynchronousTask
*
aTask
ImageClient
*
aClient
ImageContainer
*
aContainer
)
{
AutoCompleteTask
complete
(
aTask
)
;
if
(
!
CanSend
(
)
)
{
return
;
}
MOZ_ASSERT
(
aClient
)
;
BeginTransaction
(
)
;
if
(
aContainer
)
{
aContainer
-
>
ClearImagesFromImageBridge
(
)
;
}
aClient
-
>
FlushAllImages
(
)
;
EndTransaction
(
)
;
}
void
ImageBridgeChild
:
:
FlushAllImages
(
ImageClient
*
aClient
ImageContainer
*
aContainer
)
{
MOZ_ASSERT
(
aClient
)
;
MOZ_ASSERT
(
!
InImageBridgeChildThread
(
)
)
;
if
(
InImageBridgeChildThread
(
)
)
{
NS_ERROR
(
"
ImageBridgeChild
:
:
FlushAllImages
(
)
is
called
on
ImageBridge
thread
.
"
)
;
return
;
}
SynchronousTask
task
(
"
FlushAllImages
Lock
"
)
;
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
RefPtr
<
ImageBridgeChild
>
(
this
)
&
ImageBridgeChild
:
:
FlushAllImagesSync
&
task
aClient
aContainer
)
;
GetMessageLoop
(
)
-
>
PostTask
(
runnable
.
forget
(
)
)
;
task
.
Wait
(
)
;
}
void
ImageBridgeChild
:
:
BeginTransaction
(
)
{
MOZ_ASSERT
(
CanSend
(
)
)
;
MOZ_ASSERT
(
mTxn
-
>
Finished
(
)
"
uncommitted
txn
?
"
)
;
UpdateFwdTransactionId
(
)
;
mTxn
-
>
Begin
(
)
;
}
void
ImageBridgeChild
:
:
EndTransaction
(
)
{
MOZ_ASSERT
(
CanSend
(
)
)
;
MOZ_ASSERT
(
!
mTxn
-
>
Finished
(
)
"
forgot
BeginTransaction
?
"
)
;
AutoEndTransaction
_
(
mTxn
)
;
if
(
mTxn
-
>
IsEmpty
(
)
)
{
return
;
}
AutoTArray
<
CompositableOperation
10
>
cset
;
cset
.
SetCapacity
(
mTxn
-
>
mOperations
.
size
(
)
)
;
if
(
!
mTxn
-
>
mOperations
.
empty
(
)
)
{
cset
.
AppendElements
(
&
mTxn
-
>
mOperations
.
front
(
)
mTxn
-
>
mOperations
.
size
(
)
)
;
}
if
(
!
IsSameProcess
(
)
)
{
ShadowLayerForwarder
:
:
PlatformSyncBeforeUpdate
(
)
;
}
if
(
!
SendUpdate
(
cset
mTxn
-
>
mDestroyedActors
GetFwdTransactionId
(
)
)
)
{
NS_WARNING
(
"
could
not
send
async
texture
transaction
"
)
;
return
;
}
}
bool
ImageBridgeChild
:
:
InitForContent
(
Endpoint
<
PImageBridgeChild
>
&
&
aEndpoint
uint32_t
aNamespace
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
gfxPlatform
:
:
GetPlatform
(
)
;
if
(
!
sImageBridgeChildThread
)
{
sImageBridgeChildThread
=
new
Thread
(
"
ImageBridgeChild
"
)
;
bool
success
=
sImageBridgeChildThread
-
>
Start
(
)
;
MOZ_RELEASE_ASSERT
(
success
"
Failed
to
start
ImageBridgeChild
thread
!
"
)
;
}
RefPtr
<
ImageBridgeChild
>
child
=
new
ImageBridgeChild
(
aNamespace
)
;
RefPtr
<
Runnable
>
runnable
=
NewRunnableMethod
<
Endpoint
<
PImageBridgeChild
>
&
&
>
(
"
layers
:
:
ImageBridgeChild
:
:
Bind
"
child
&
ImageBridgeChild
:
:
Bind
std
:
:
move
(
aEndpoint
)
)
;
child
-
>
GetMessageLoop
(
)
-
>
PostTask
(
runnable
.
forget
(
)
)
;
{
StaticMutexAutoLock
lock
(
sImageBridgeSingletonLock
)
;
sImageBridgeChildSingleton
=
child
;
}
return
true
;
}
bool
ImageBridgeChild
:
:
ReinitForContent
(
Endpoint
<
PImageBridgeChild
>
&
&
aEndpoint
uint32_t
aNamespace
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
ShutdownSingleton
(
)
;
return
InitForContent
(
std
:
:
move
(
aEndpoint
)
aNamespace
)
;
}
void
ImageBridgeChild
:
:
Bind
(
Endpoint
<
PImageBridgeChild
>
&
&
aEndpoint
)
{
if
(
!
aEndpoint
.
Bind
(
this
)
)
{
return
;
}
this
-
>
AddRef
(
)
;
mCanSend
=
true
;
}
void
ImageBridgeChild
:
:
BindSameProcess
(
RefPtr
<
ImageBridgeParent
>
aParent
)
{
MessageLoop
*
parentMsgLoop
=
aParent
-
>
GetMessageLoop
(
)
;
ipc
:
:
MessageChannel
*
parentChannel
=
aParent
-
>
GetIPCChannel
(
)
;
Open
(
parentChannel
parentMsgLoop
mozilla
:
:
ipc
:
:
ChildSide
)
;
this
-
>
AddRef
(
)
;
mCanSend
=
true
;
}
void
ImageBridgeChild
:
:
ShutDown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
ShutdownSingleton
(
)
;
delete
sImageBridgeChildThread
;
sImageBridgeChildThread
=
nullptr
;
}
void
ImageBridgeChild
:
:
ShutdownSingleton
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
RefPtr
<
ImageBridgeChild
>
child
=
GetSingleton
(
)
)
{
child
-
>
WillShutdown
(
)
;
StaticMutexAutoLock
lock
(
sImageBridgeSingletonLock
)
;
sImageBridgeChildSingleton
=
nullptr
;
}
}
void
ImageBridgeChild
:
:
WillShutdown
(
)
{
{
SynchronousTask
task
(
"
ImageBridge
ShutdownStep1
lock
"
)
;
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
RefPtr
<
ImageBridgeChild
>
(
this
)
&
ImageBridgeChild
:
:
ShutdownStep1
&
task
)
;
GetMessageLoop
(
)
-
>
PostTask
(
runnable
.
forget
(
)
)
;
task
.
Wait
(
)
;
}
{
SynchronousTask
task
(
"
ImageBridge
ShutdownStep2
lock
"
)
;
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
RefPtr
<
ImageBridgeChild
>
(
this
)
&
ImageBridgeChild
:
:
ShutdownStep2
&
task
)
;
GetMessageLoop
(
)
-
>
PostTask
(
runnable
.
forget
(
)
)
;
task
.
Wait
(
)
;
}
}
void
ImageBridgeChild
:
:
InitSameProcess
(
uint32_t
aNamespace
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Should
be
on
the
main
Thread
!
"
)
;
MOZ_ASSERT
(
!
sImageBridgeChildSingleton
)
;
MOZ_ASSERT
(
!
sImageBridgeChildThread
)
;
sImageBridgeChildThread
=
new
Thread
(
"
ImageBridgeChild
"
)
;
if
(
!
sImageBridgeChildThread
-
>
IsRunning
(
)
)
{
sImageBridgeChildThread
-
>
Start
(
)
;
}
RefPtr
<
ImageBridgeChild
>
child
=
new
ImageBridgeChild
(
aNamespace
)
;
RefPtr
<
ImageBridgeParent
>
parent
=
ImageBridgeParent
:
:
CreateSameProcess
(
)
;
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
child
&
ImageBridgeChild
:
:
BindSameProcess
parent
)
;
child
-
>
GetMessageLoop
(
)
-
>
PostTask
(
runnable
.
forget
(
)
)
;
{
StaticMutexAutoLock
lock
(
sImageBridgeSingletonLock
)
;
sImageBridgeChildSingleton
=
child
;
}
}
void
ImageBridgeChild
:
:
InitWithGPUProcess
(
Endpoint
<
PImageBridgeChild
>
&
&
aEndpoint
uint32_t
aNamespace
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
sImageBridgeChildSingleton
)
;
MOZ_ASSERT
(
!
sImageBridgeChildThread
)
;
sImageBridgeChildThread
=
new
Thread
(
"
ImageBridgeChild
"
)
;
if
(
!
sImageBridgeChildThread
-
>
IsRunning
(
)
)
{
sImageBridgeChildThread
-
>
Start
(
)
;
}
RefPtr
<
ImageBridgeChild
>
child
=
new
ImageBridgeChild
(
aNamespace
)
;
MessageLoop
*
loop
=
child
-
>
GetMessageLoop
(
)
;
loop
-
>
PostTask
(
NewRunnableMethod
<
Endpoint
<
PImageBridgeChild
>
&
&
>
(
"
layers
:
:
ImageBridgeChild
:
:
Bind
"
child
&
ImageBridgeChild
:
:
Bind
std
:
:
move
(
aEndpoint
)
)
)
;
{
StaticMutexAutoLock
lock
(
sImageBridgeSingletonLock
)
;
sImageBridgeChildSingleton
=
child
;
}
}
bool
InImageBridgeChildThread
(
)
{
return
sImageBridgeChildThread
&
&
sImageBridgeChildThread
-
>
thread_id
(
)
=
=
PlatformThread
:
:
CurrentId
(
)
;
}
MessageLoop
*
ImageBridgeChild
:
:
GetMessageLoop
(
)
const
{
return
sImageBridgeChildThread
?
sImageBridgeChildThread
-
>
message_loop
(
)
:
nullptr
;
}
void
ImageBridgeChild
:
:
IdentifyCompositorTextureHost
(
const
TextureFactoryIdentifier
&
aIdentifier
)
{
if
(
RefPtr
<
ImageBridgeChild
>
child
=
GetSingleton
(
)
)
{
child
-
>
UpdateTextureFactoryIdentifier
(
aIdentifier
)
;
}
}
void
ImageBridgeChild
:
:
UpdateTextureFactoryIdentifier
(
const
TextureFactoryIdentifier
&
aIdentifier
)
{
bool
disablingWebRender
=
GetCompositorBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_WR
&
&
aIdentifier
.
mParentBackend
!
=
LayersBackend
:
:
LAYERS_WR
;
bool
initializingWebRender
=
GetCompositorBackendType
(
)
!
=
LayersBackend
:
:
LAYERS_WR
&
&
aIdentifier
.
mParentBackend
=
=
LayersBackend
:
:
LAYERS_WR
;
bool
needsDrop
=
disablingWebRender
|
|
initializingWebRender
;
#
if
defined
(
XP_WIN
)
RefPtr
<
ID3D11Device
>
device
=
gfx
:
:
DeviceManagerDx
:
:
Get
(
)
-
>
GetImageDevice
(
)
;
needsDrop
|
=
!
!
mImageDevice
&
&
mImageDevice
!
=
device
&
&
GetCompositorBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_D3D11
;
mImageDevice
=
device
;
#
endif
IdentifyTextureHost
(
aIdentifier
)
;
if
(
needsDrop
)
{
nsTArray
<
RefPtr
<
ImageContainerListener
>
>
listeners
;
{
MutexAutoLock
lock
(
mContainerMapLock
)
;
for
(
const
auto
&
entry
:
mImageContainerListeners
)
{
listeners
.
AppendElement
(
entry
.
second
)
;
}
}
for
(
auto
container
:
listeners
)
{
container
-
>
DropImageClient
(
)
;
}
}
}
RefPtr
<
ImageClient
>
ImageBridgeChild
:
:
CreateImageClient
(
CompositableType
aType
ImageContainer
*
aImageContainer
)
{
if
(
InImageBridgeChildThread
(
)
)
{
return
CreateImageClientNow
(
aType
aImageContainer
)
;
}
SynchronousTask
task
(
"
CreateImageClient
Lock
"
)
;
RefPtr
<
ImageClient
>
result
=
nullptr
;
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
RefPtr
<
ImageBridgeChild
>
(
this
)
&
ImageBridgeChild
:
:
CreateImageClientSync
&
task
&
result
aType
aImageContainer
)
;
GetMessageLoop
(
)
-
>
PostTask
(
runnable
.
forget
(
)
)
;
task
.
Wait
(
)
;
return
result
;
}
RefPtr
<
ImageClient
>
ImageBridgeChild
:
:
CreateImageClientNow
(
CompositableType
aType
ImageContainer
*
aImageContainer
)
{
MOZ_ASSERT
(
InImageBridgeChildThread
(
)
)
;
if
(
!
CanSend
(
)
)
{
return
nullptr
;
}
RefPtr
<
ImageClient
>
client
=
ImageClient
:
:
CreateImageClient
(
aType
this
TextureFlags
:
:
NO_FLAGS
)
;
MOZ_ASSERT
(
client
"
failed
to
create
ImageClient
"
)
;
if
(
client
)
{
client
-
>
Connect
(
aImageContainer
)
;
}
return
client
;
}
already_AddRefed
<
CanvasClient
>
ImageBridgeChild
:
:
CreateCanvasClient
(
CanvasClient
:
:
CanvasClientType
aType
TextureFlags
aFlag
)
{
if
(
InImageBridgeChildThread
(
)
)
{
return
CreateCanvasClientNow
(
aType
aFlag
)
;
}
SynchronousTask
task
(
"
CreateCanvasClient
Lock
"
)
;
RefPtr
<
CanvasClient
>
result
=
nullptr
;
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
RefPtr
<
ImageBridgeChild
>
(
this
)
&
ImageBridgeChild
:
:
CreateCanvasClientSync
&
task
aType
aFlag
&
result
)
;
GetMessageLoop
(
)
-
>
PostTask
(
runnable
.
forget
(
)
)
;
task
.
Wait
(
)
;
return
result
.
forget
(
)
;
}
already_AddRefed
<
CanvasClient
>
ImageBridgeChild
:
:
CreateCanvasClientNow
(
CanvasClient
:
:
CanvasClientType
aType
TextureFlags
aFlag
)
{
RefPtr
<
CanvasClient
>
client
=
CanvasClient
:
:
CreateCanvasClient
(
aType
this
aFlag
)
;
MOZ_ASSERT
(
client
"
failed
to
create
CanvasClient
"
)
;
if
(
client
)
{
client
-
>
Connect
(
)
;
}
return
client
.
forget
(
)
;
}
bool
ImageBridgeChild
:
:
AllocUnsafeShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
if
(
!
InImageBridgeChildThread
(
)
)
{
return
DispatchAllocShmemInternal
(
aSize
aType
aShmem
true
)
;
}
if
(
!
CanSend
(
)
)
{
return
false
;
}
return
PImageBridgeChild
:
:
AllocUnsafeShmem
(
aSize
aType
aShmem
)
;
}
bool
ImageBridgeChild
:
:
AllocShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
if
(
!
InImageBridgeChildThread
(
)
)
{
return
DispatchAllocShmemInternal
(
aSize
aType
aShmem
false
)
;
}
if
(
!
CanSend
(
)
)
{
return
false
;
}
return
PImageBridgeChild
:
:
AllocShmem
(
aSize
aType
aShmem
)
;
}
struct
AllocShmemParams
{
size_t
mSize
;
ipc
:
:
SharedMemory
:
:
SharedMemoryType
mType
;
ipc
:
:
Shmem
*
mShmem
;
bool
mUnsafe
;
bool
mSuccess
;
}
;
void
ImageBridgeChild
:
:
ProxyAllocShmemNow
(
SynchronousTask
*
aTask
AllocShmemParams
*
aParams
)
{
AutoCompleteTask
complete
(
aTask
)
;
if
(
!
CanSend
(
)
)
{
return
;
}
bool
ok
=
false
;
if
(
aParams
-
>
mUnsafe
)
{
ok
=
AllocUnsafeShmem
(
aParams
-
>
mSize
aParams
-
>
mType
aParams
-
>
mShmem
)
;
}
else
{
ok
=
AllocShmem
(
aParams
-
>
mSize
aParams
-
>
mType
aParams
-
>
mShmem
)
;
}
aParams
-
>
mSuccess
=
ok
;
}
bool
ImageBridgeChild
:
:
DispatchAllocShmemInternal
(
size_t
aSize
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
bool
aUnsafe
)
{
SynchronousTask
task
(
"
AllocatorProxy
alloc
"
)
;
AllocShmemParams
params
=
{
aSize
aType
aShmem
aUnsafe
false
}
;
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
RefPtr
<
ImageBridgeChild
>
(
this
)
&
ImageBridgeChild
:
:
ProxyAllocShmemNow
&
task
&
params
)
;
GetMessageLoop
(
)
-
>
PostTask
(
runnable
.
forget
(
)
)
;
task
.
Wait
(
)
;
return
params
.
mSuccess
;
}
void
ImageBridgeChild
:
:
ProxyDeallocShmemNow
(
SynchronousTask
*
aTask
ipc
:
:
Shmem
*
aShmem
bool
*
aResult
)
{
AutoCompleteTask
complete
(
aTask
)
;
if
(
!
CanSend
(
)
)
{
return
;
}
*
aResult
=
DeallocShmem
(
*
aShmem
)
;
}
bool
ImageBridgeChild
:
:
DeallocShmem
(
ipc
:
:
Shmem
&
aShmem
)
{
if
(
InImageBridgeChildThread
(
)
)
{
if
(
!
CanSend
(
)
)
{
return
false
;
}
return
PImageBridgeChild
:
:
DeallocShmem
(
aShmem
)
;
}
if
(
!
CanPostTask
(
)
)
{
return
false
;
}
SynchronousTask
task
(
"
AllocatorProxy
Dealloc
"
)
;
bool
result
=
false
;
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
RefPtr
<
ImageBridgeChild
>
(
this
)
&
ImageBridgeChild
:
:
ProxyDeallocShmemNow
&
task
&
aShmem
&
result
)
;
GetMessageLoop
(
)
-
>
PostTask
(
runnable
.
forget
(
)
)
;
task
.
Wait
(
)
;
return
result
;
}
PTextureChild
*
ImageBridgeChild
:
:
AllocPTextureChild
(
const
SurfaceDescriptor
&
const
ReadLockDescriptor
&
const
LayersBackend
&
const
TextureFlags
&
const
uint64_t
&
aSerial
const
wr
:
:
MaybeExternalImageId
&
aExternalImageId
)
{
MOZ_ASSERT
(
CanSend
(
)
)
;
return
TextureClient
:
:
CreateIPDLActor
(
)
;
}
bool
ImageBridgeChild
:
:
DeallocPTextureChild
(
PTextureChild
*
actor
)
{
return
TextureClient
:
:
DestroyIPDLActor
(
actor
)
;
}
PMediaSystemResourceManagerChild
*
ImageBridgeChild
:
:
AllocPMediaSystemResourceManagerChild
(
)
{
MOZ_ASSERT
(
CanSend
(
)
)
;
return
new
mozilla
:
:
media
:
:
MediaSystemResourceManagerChild
(
)
;
}
bool
ImageBridgeChild
:
:
DeallocPMediaSystemResourceManagerChild
(
PMediaSystemResourceManagerChild
*
aActor
)
{
MOZ_ASSERT
(
aActor
)
;
delete
static_cast
<
mozilla
:
:
media
:
:
MediaSystemResourceManagerChild
*
>
(
aActor
)
;
return
true
;
}
mozilla
:
:
ipc
:
:
IPCResult
ImageBridgeChild
:
:
RecvParentAsyncMessages
(
InfallibleTArray
<
AsyncParentMessageData
>
&
&
aMessages
)
{
for
(
AsyncParentMessageArray
:
:
index_type
i
=
0
;
i
<
aMessages
.
Length
(
)
;
+
+
i
)
{
const
AsyncParentMessageData
&
message
=
aMessages
[
i
]
;
switch
(
message
.
type
(
)
)
{
case
AsyncParentMessageData
:
:
TOpNotifyNotUsed
:
{
const
OpNotifyNotUsed
&
op
=
message
.
get_OpNotifyNotUsed
(
)
;
NotifyNotUsed
(
op
.
TextureId
(
)
op
.
fwdTransactionId
(
)
)
;
break
;
}
default
:
NS_ERROR
(
"
unknown
AsyncParentMessageData
type
"
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
}
return
IPC_OK
(
)
;
}
RefPtr
<
ImageContainerListener
>
ImageBridgeChild
:
:
FindListener
(
const
CompositableHandle
&
aHandle
)
{
RefPtr
<
ImageContainerListener
>
listener
;
MutexAutoLock
lock
(
mContainerMapLock
)
;
auto
it
=
mImageContainerListeners
.
find
(
aHandle
.
Value
(
)
)
;
if
(
it
!
=
mImageContainerListeners
.
end
(
)
)
{
listener
=
it
-
>
second
;
}
return
listener
;
}
mozilla
:
:
ipc
:
:
IPCResult
ImageBridgeChild
:
:
RecvDidComposite
(
InfallibleTArray
<
ImageCompositeNotification
>
&
&
aNotifications
)
{
for
(
auto
&
n
:
aNotifications
)
{
RefPtr
<
ImageContainerListener
>
listener
=
FindListener
(
n
.
compositable
(
)
)
;
if
(
listener
)
{
listener
-
>
NotifyComposite
(
n
)
;
}
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ImageBridgeChild
:
:
RecvReportFramesDropped
(
const
CompositableHandle
&
aHandle
const
uint32_t
&
aFrames
)
{
RefPtr
<
ImageContainerListener
>
listener
=
FindListener
(
aHandle
)
;
if
(
listener
)
{
listener
-
>
NotifyDropped
(
aFrames
)
;
}
return
IPC_OK
(
)
;
}
PTextureChild
*
ImageBridgeChild
:
:
CreateTexture
(
const
SurfaceDescriptor
&
aSharedData
const
ReadLockDescriptor
&
aReadLock
LayersBackend
aLayersBackend
TextureFlags
aFlags
uint64_t
aSerial
wr
:
:
MaybeExternalImageId
&
aExternalImageId
nsIEventTarget
*
aTarget
)
{
MOZ_ASSERT
(
CanSend
(
)
)
;
return
SendPTextureConstructor
(
aSharedData
aReadLock
aLayersBackend
aFlags
aSerial
aExternalImageId
)
;
}
static
bool
IBCAddOpDestroy
(
CompositableTransaction
*
aTxn
const
OpDestroy
&
op
)
{
if
(
aTxn
-
>
Finished
(
)
)
{
return
false
;
}
aTxn
-
>
mDestroyedActors
.
AppendElement
(
op
)
;
return
true
;
}
bool
ImageBridgeChild
:
:
DestroyInTransaction
(
PTextureChild
*
aTexture
)
{
return
IBCAddOpDestroy
(
mTxn
OpDestroy
(
aTexture
)
)
;
}
bool
ImageBridgeChild
:
:
DestroyInTransaction
(
const
CompositableHandle
&
aHandle
)
{
return
IBCAddOpDestroy
(
mTxn
OpDestroy
(
aHandle
)
)
;
}
void
ImageBridgeChild
:
:
RemoveTextureFromCompositable
(
CompositableClient
*
aCompositable
TextureClient
*
aTexture
)
{
MOZ_ASSERT
(
CanSend
(
)
)
;
MOZ_ASSERT
(
aTexture
)
;
MOZ_ASSERT
(
aTexture
-
>
IsSharedWithCompositor
(
)
)
;
MOZ_ASSERT
(
aCompositable
-
>
IsConnected
(
)
)
;
if
(
!
aTexture
|
|
!
aTexture
-
>
IsSharedWithCompositor
(
)
|
|
!
aCompositable
-
>
IsConnected
(
)
)
{
return
;
}
mTxn
-
>
AddNoSwapEdit
(
CompositableOperation
(
aCompositable
-
>
GetIPCHandle
(
)
OpRemoveTexture
(
nullptr
aTexture
-
>
GetIPDLActor
(
)
)
)
)
;
}
bool
ImageBridgeChild
:
:
IsSameProcess
(
)
const
{
return
OtherPid
(
)
=
=
base
:
:
GetCurrentProcId
(
)
;
}
bool
ImageBridgeChild
:
:
CanPostTask
(
)
const
{
return
!
mDestroyed
;
}
void
ImageBridgeChild
:
:
ReleaseCompositable
(
const
CompositableHandle
&
aHandle
)
{
if
(
!
InImageBridgeChildThread
(
)
)
{
if
(
!
CanPostTask
(
)
)
{
return
;
}
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
RefPtr
<
ImageBridgeChild
>
(
this
)
&
ImageBridgeChild
:
:
ReleaseCompositable
aHandle
)
;
GetMessageLoop
(
)
-
>
PostTask
(
runnable
.
forget
(
)
)
;
return
;
}
if
(
!
CanSend
(
)
)
{
return
;
}
if
(
!
DestroyInTransaction
(
aHandle
)
)
{
SendReleaseCompositable
(
aHandle
)
;
}
{
MutexAutoLock
lock
(
mContainerMapLock
)
;
mImageContainerListeners
.
erase
(
aHandle
.
Value
(
)
)
;
}
}
bool
ImageBridgeChild
:
:
CanSend
(
)
const
{
MOZ_ASSERT
(
InImageBridgeChildThread
(
)
)
;
return
mCanSend
;
}
void
ImageBridgeChild
:
:
HandleFatalError
(
const
char
*
aMsg
)
const
{
dom
:
:
ContentChild
:
:
FatalErrorIfNotUsingGPUProcess
(
aMsg
OtherPid
(
)
)
;
}
wr
:
:
MaybeExternalImageId
ImageBridgeChild
:
:
GetNextExternalImageId
(
)
{
static
uint32_t
sNextID
=
1
;
+
+
sNextID
;
MOZ_RELEASE_ASSERT
(
sNextID
!
=
UINT32_MAX
)
;
uint64_t
imageId
=
mNamespace
;
imageId
=
imageId
<
<
32
|
sNextID
;
return
Some
(
wr
:
:
ToExternalImageId
(
imageId
)
)
;
}
}
}
