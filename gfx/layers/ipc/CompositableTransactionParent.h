#
ifndef
MOZILLA_LAYERS_COMPOSITABLETRANSACTIONPARENT_H
#
define
MOZILLA_LAYERS_COMPOSITABLETRANSACTIONPARENT_H
#
include
<
vector
>
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
CompositableHost
.
h
"
namespace
mozilla
{
namespace
layers
{
class
CompositableParentManager
:
public
HostIPCAllocator
{
public
:
typedef
InfallibleTArray
<
ReadLockInit
>
ReadLockArray
;
CompositableParentManager
(
)
{
}
void
DestroyActor
(
const
OpDestroy
&
aOp
)
;
void
UpdateFwdTransactionId
(
uint64_t
aTransactionId
)
{
MOZ_ASSERT
(
mFwdTransactionId
<
aTransactionId
)
;
mFwdTransactionId
=
aTransactionId
;
}
uint64_t
GetFwdTransactionId
(
)
{
return
mFwdTransactionId
;
}
RefPtr
<
CompositableHost
>
AddCompositable
(
const
CompositableHandle
&
aHandle
const
TextureInfo
&
aInfo
)
;
RefPtr
<
CompositableHost
>
FindCompositable
(
const
CompositableHandle
&
aHandle
)
;
bool
AddReadLocks
(
ReadLockArray
&
&
aReadLocks
)
;
TextureReadLock
*
FindReadLock
(
const
ReadLockHandle
&
aLockHandle
)
;
protected
:
bool
ReceiveCompositableUpdate
(
const
CompositableOperation
&
aEdit
)
;
void
ReleaseCompositable
(
const
CompositableHandle
&
aHandle
)
;
uint64_t
mFwdTransactionId
=
0
;
std
:
:
map
<
uint64_t
RefPtr
<
CompositableHost
>
>
mCompositables
;
std
:
:
map
<
uint64_t
RefPtr
<
TextureReadLock
>
>
mReadLocks
;
}
;
struct
AutoClearReadLocks
{
explicit
AutoClearReadLocks
(
std
:
:
map
<
uint64_t
RefPtr
<
TextureReadLock
>
>
&
aReadLocks
)
:
mReadLocks
(
aReadLocks
)
{
}
~
AutoClearReadLocks
(
)
{
mReadLocks
.
clear
(
)
;
}
std
:
:
map
<
uint64_t
RefPtr
<
TextureReadLock
>
>
&
mReadLocks
;
}
;
}
}
#
endif
