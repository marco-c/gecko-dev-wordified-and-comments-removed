#
include
"
CanvasTranslator
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
GPUParent
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
mozilla
/
ipc
/
Endpoint
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
SyncRunnable
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
RecordedCanvasEventImpl
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
mozilla
/
gfx
/
DeviceManagerDx
.
h
"
#
include
"
mozilla
/
layers
/
TextureD3D11
.
h
"
#
endif
namespace
mozilla
{
namespace
layers
{
static
const
TimeDuration
kReadEventTimeout
=
TimeDuration
:
:
FromMilliseconds
(
5
)
;
class
RingBufferReaderServices
final
:
public
CanvasEventRingBuffer
:
:
ReaderServices
{
public
:
explicit
RingBufferReaderServices
(
RefPtr
<
CanvasTranslator
>
aCanvasTranslator
)
:
mCanvasTranslator
(
std
:
:
move
(
aCanvasTranslator
)
)
{
}
~
RingBufferReaderServices
(
)
final
=
default
;
bool
WriterClosed
(
)
final
{
return
!
mCanvasTranslator
-
>
GetIPCChannel
(
)
-
>
CanSend
(
)
;
}
private
:
RefPtr
<
CanvasTranslator
>
mCanvasTranslator
;
}
;
TextureData
*
CanvasTranslator
:
:
CreateTextureData
(
TextureType
aTextureType
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
)
{
TextureData
*
textureData
=
nullptr
;
switch
(
aTextureType
)
{
#
ifdef
XP_WIN
case
TextureType
:
:
D3D11
:
{
textureData
=
D3D11TextureData
:
:
Create
(
aSize
aFormat
ALLOC_CLEAR_BUFFER
mDevice
)
;
break
;
}
#
endif
default
:
MOZ_CRASH
(
"
Unsupported
TextureType
for
CanvasTranslator
.
"
)
;
}
return
textureData
;
}
typedef
nsTHashtable
<
nsRefPtrHashKey
<
CanvasTranslator
>
>
CanvasTranslatorSet
;
static
CanvasTranslatorSet
&
CanvasTranslators
(
)
{
MOZ_ASSERT
(
CanvasThreadHolder
:
:
IsInCanvasThread
(
)
)
;
static
CanvasTranslatorSet
*
sCanvasTranslator
=
new
CanvasTranslatorSet
(
)
;
return
*
sCanvasTranslator
;
}
static
void
EnsureAllClosed
(
)
{
for
(
auto
iter
=
CanvasTranslators
(
)
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Get
(
)
-
>
GetKey
(
)
-
>
Close
(
)
;
}
}
void
CanvasTranslator
:
:
Shutdown
(
)
{
CanvasThreadHolder
:
:
MaybeDispatchToCanvasThread
(
NewRunnableFunction
(
"
CanvasTranslator
:
:
EnsureAllClosed
"
&
EnsureAllClosed
)
)
;
}
already_AddRefed
<
CanvasTranslator
>
CanvasTranslator
:
:
Create
(
ipc
:
:
Endpoint
<
PCanvasParent
>
&
&
aEndpoint
)
{
MOZ_ASSERT
(
NS_IsInCompositorThread
(
)
)
;
RefPtr
<
CanvasThreadHolder
>
threadHolder
=
CanvasThreadHolder
:
:
EnsureCanvasThread
(
)
;
RefPtr
<
CanvasTranslator
>
canvasTranslator
=
new
CanvasTranslator
(
do_AddRef
(
threadHolder
)
)
;
threadHolder
-
>
DispatchToCanvasThread
(
NewRunnableMethod
<
Endpoint
<
PCanvasParent
>
&
&
>
(
"
CanvasTranslator
:
:
Bind
"
canvasTranslator
&
CanvasTranslator
:
:
Bind
std
:
:
move
(
aEndpoint
)
)
)
;
return
canvasTranslator
.
forget
(
)
;
}
CanvasTranslator
:
:
CanvasTranslator
(
already_AddRefed
<
CanvasThreadHolder
>
aCanvasThreadHolder
)
:
gfx
:
:
InlineTranslator
(
)
mCanvasThreadHolder
(
aCanvasThreadHolder
)
{
Telemetry
:
:
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
GFX_CANVAS_REMOTE_ACTIVATED
1
)
;
}
CanvasTranslator
:
:
~
CanvasTranslator
(
)
{
if
(
mReferenceTextureData
)
{
mReferenceTextureData
-
>
Unlock
(
)
;
}
}
void
CanvasTranslator
:
:
Bind
(
Endpoint
<
PCanvasParent
>
&
&
aEndpoint
)
{
if
(
!
aEndpoint
.
Bind
(
this
)
)
{
return
;
}
CanvasTranslators
(
)
.
PutEntry
(
this
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CanvasTranslator
:
:
RecvInitTranslator
(
const
TextureType
&
aTextureType
const
ipc
:
:
SharedMemoryBasic
:
:
Handle
&
aReadHandle
const
CrossProcessSemaphoreHandle
&
aReaderSem
const
CrossProcessSemaphoreHandle
&
aWriterSem
)
{
mTextureType
=
aTextureType
;
mStream
=
MakeUnique
<
CanvasEventRingBuffer
>
(
)
;
if
(
!
mStream
-
>
InitReader
(
aReadHandle
aReaderSem
aWriterSem
MakeUnique
<
RingBufferReaderServices
>
(
this
)
)
)
{
return
IPC_FAIL
(
this
"
Failed
to
initialize
ring
buffer
reader
.
"
)
;
}
#
if
defined
(
XP_WIN
)
if
(
!
CheckForFreshCanvasDevice
(
__LINE__
)
)
{
gfxCriticalNote
<
<
"
GFX
:
CanvasTranslator
failed
to
get
device
"
;
return
IPC_OK
(
)
;
}
#
endif
mTranslationTaskQueue
=
mCanvasThreadHolder
-
>
CreateWorkerTaskQueue
(
)
;
return
RecvResumeTranslation
(
)
;
}
ipc
:
:
IPCResult
CanvasTranslator
:
:
RecvResumeTranslation
(
)
{
if
(
mDeactivated
)
{
return
IPC_OK
(
)
;
}
MOZ_ALWAYS_SUCCEEDS
(
mTranslationTaskQueue
-
>
Dispatch
(
NewRunnableMethod
(
"
CanvasTranslator
:
:
StartTranslation
"
this
&
CanvasTranslator
:
:
StartTranslation
)
)
)
;
return
IPC_OK
(
)
;
}
void
CanvasTranslator
:
:
StartTranslation
(
)
{
if
(
!
TranslateRecording
(
)
&
&
GetIPCChannel
(
)
-
>
CanSend
(
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
mTranslationTaskQueue
-
>
Dispatch
(
NewRunnableMethod
(
"
CanvasTranslator
:
:
StartTranslation
"
this
&
CanvasTranslator
:
:
StartTranslation
)
)
)
;
}
if
(
!
mStream
-
>
good
(
)
&
&
!
mStream
-
>
WriterFailed
(
)
)
{
Telemetry
:
:
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
GFX_CANVAS_REMOTE_DEACTIVATED_BAD_STREAM
1
)
;
Deactivate
(
)
;
}
}
void
CanvasTranslator
:
:
ActorDestroy
(
ActorDestroyReason
why
)
{
MOZ_ASSERT
(
CanvasThreadHolder
:
:
IsInCanvasThread
(
)
)
;
if
(
!
mTranslationTaskQueue
)
{
return
FinishShutdown
(
)
;
}
mTranslationTaskQueue
-
>
BeginShutdown
(
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
this
&
CanvasTranslator
:
:
FinishShutdown
&
CanvasTranslator
:
:
FinishShutdown
)
;
}
void
CanvasTranslator
:
:
FinishShutdown
(
)
{
MOZ_ASSERT
(
CanvasThreadHolder
:
:
IsInCanvasThread
(
)
)
;
mStream
=
nullptr
;
CanvasTranslatorSet
&
canvasTranslators
=
CanvasTranslators
(
)
;
CanvasThreadHolder
:
:
ReleaseOnCompositorThread
(
mCanvasThreadHolder
.
forget
(
)
)
;
canvasTranslators
.
RemoveEntry
(
this
)
;
}
void
CanvasTranslator
:
:
Deactivate
(
)
{
if
(
mDeactivated
)
{
return
;
}
mDeactivated
=
true
;
mStream
-
>
SetIsBad
(
)
;
mCanvasThreadHolder
-
>
DispatchToCanvasThread
(
NewRunnableMethod
(
"
CanvasTranslator
:
:
SendDeactivate
"
this
&
CanvasTranslator
:
:
SendDeactivate
)
)
;
{
gfx
:
:
AutoSerializeWithMoz2D
serializeWithMoz2D
(
GetBackendType
(
)
)
;
for
(
auto
const
&
entry
:
mTextureDatas
)
{
entry
.
second
-
>
Unlock
(
)
;
}
}
mSurfaceDescriptorsMonitor
.
NotifyAll
(
)
;
}
bool
CanvasTranslator
:
:
TranslateRecording
(
)
{
MOZ_ASSERT
(
CanvasThreadHolder
:
:
IsInCanvasWorker
(
)
)
;
int32_t
eventType
=
mStream
-
>
ReadNextEvent
(
)
;
while
(
mStream
-
>
good
(
)
)
{
bool
success
=
RecordedEvent
:
:
DoWithEventFromStream
(
*
mStream
static_cast
<
RecordedEvent
:
:
EventType
>
(
eventType
)
[
&
]
(
RecordedEvent
*
recordedEvent
)
-
>
bool
{
if
(
!
mStream
-
>
good
(
)
)
{
if
(
!
GetIPCChannel
(
)
-
>
CanSend
(
)
)
{
gfxWarning
(
)
<
<
"
Failed
to
read
event
type
:
"
<
<
recordedEvent
-
>
GetType
(
)
;
}
else
{
gfxCriticalNote
<
<
"
Failed
to
read
event
type
:
"
<
<
recordedEvent
-
>
GetType
(
)
;
}
return
false
;
}
return
recordedEvent
-
>
PlayEvent
(
this
)
;
}
)
;
if
(
!
mStream
-
>
good
(
)
)
{
return
true
;
}
if
(
!
success
&
&
!
HandleExtensionEvent
(
eventType
)
)
{
if
(
mDeviceResetInProgress
)
{
gfxWarning
(
)
<
<
"
Failed
to
play
canvas
event
type
:
"
<
<
eventType
;
}
else
{
gfxCriticalNote
<
<
"
Failed
to
play
canvas
event
type
:
"
<
<
eventType
;
}
if
(
!
mStream
-
>
good
(
)
)
{
return
true
;
}
}
if
(
!
mIsInTransaction
)
{
return
mStream
-
>
StopIfEmpty
(
)
;
}
if
(
!
mStream
-
>
HasDataToRead
(
)
)
{
Flush
(
)
;
if
(
!
mStream
-
>
WaitForDataToRead
(
kReadEventTimeout
0
)
)
{
return
true
;
}
}
eventType
=
mStream
-
>
ReadNextEvent
(
)
;
}
return
true
;
}
#
define
READ_AND_PLAY_CANVAS_EVENT_TYPE
(
_typeenum
_class
)
\
case
_typeenum
:
{
\
auto
e
=
_class
(
*
mStream
)
;
\
if
(
!
mStream
-
>
good
(
)
)
{
\
if
(
!
GetIPCChannel
(
)
-
>
CanSend
(
)
)
{
\
/
*
The
other
side
has
closed
only
warn
about
read
failure
.
*
/
\
gfxWarning
(
)
<
<
"
Failed
to
read
event
type
:
"
<
<
_typeenum
;
\
}
else
{
\
gfxCriticalNote
<
<
"
Failed
to
read
event
type
:
"
<
<
_typeenum
;
\
}
\
return
false
;
\
}
\
return
e
.
PlayCanvasEvent
(
this
)
;
\
}
bool
CanvasTranslator
:
:
HandleExtensionEvent
(
int32_t
aType
)
{
switch
(
aType
)
{
FOR_EACH_CANVAS_EVENT
(
READ_AND_PLAY_CANVAS_EVENT_TYPE
)
default
:
return
false
;
}
}
void
CanvasTranslator
:
:
BeginTransaction
(
)
{
mIsInTransaction
=
true
;
}
void
CanvasTranslator
:
:
Flush
(
)
{
#
if
defined
(
XP_WIN
)
if
(
!
mDevice
)
{
return
;
}
gfx
:
:
AutoSerializeWithMoz2D
serializeWithMoz2D
(
GetBackendType
(
)
)
;
RefPtr
<
ID3D11DeviceContext
>
deviceContext
;
mDevice
-
>
GetImmediateContext
(
getter_AddRefs
(
deviceContext
)
)
;
deviceContext
-
>
Flush
(
)
;
#
endif
}
void
CanvasTranslator
:
:
EndTransaction
(
)
{
Flush
(
)
;
Unused
<
<
CheckForFreshCanvasDevice
(
__LINE__
)
;
mIsInTransaction
=
false
;
}
void
CanvasTranslator
:
:
DeviceChangeAcknowledged
(
)
{
mDeviceResetInProgress
=
false
;
}
bool
CanvasTranslator
:
:
CreateReferenceTexture
(
)
{
if
(
mReferenceTextureData
)
{
mReferenceTextureData
-
>
Unlock
(
)
;
}
mReferenceTextureData
.
reset
(
CreateTextureData
(
mTextureType
gfx
:
:
IntSize
(
1
1
)
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
)
)
;
if
(
!
mReferenceTextureData
)
{
return
false
;
}
mReferenceTextureData
-
>
Lock
(
OpenMode
:
:
OPEN_READ_WRITE
)
;
mBaseDT
=
mReferenceTextureData
-
>
BorrowDrawTarget
(
)
;
if
(
mBaseDT
)
{
mBackendType
=
mBaseDT
-
>
GetBackendType
(
)
;
}
return
true
;
}
bool
CanvasTranslator
:
:
CheckForFreshCanvasDevice
(
int
aLineNumber
)
{
#
if
defined
(
XP_WIN
)
RefPtr
<
ID3D11Device
>
device
=
gfx
:
:
DeviceManagerDx
:
:
Get
(
)
-
>
GetCanvasDevice
(
)
;
if
(
device
&
&
device
!
=
mDevice
)
{
if
(
mDevice
)
{
NotifyDeviceChanged
(
)
;
}
mDevice
=
device
.
forget
(
)
;
return
CreateReferenceTexture
(
)
;
}
if
(
mDevice
)
{
if
(
mDevice
-
>
GetDeviceRemovedReason
(
)
=
=
S_OK
)
{
return
false
;
}
gfxCriticalNote
<
<
"
GFX
:
CanvasTranslator
detected
a
device
reset
at
"
<
<
aLineNumber
;
NotifyDeviceChanged
(
)
;
}
RefPtr
<
Runnable
>
runnable
=
NS_NewRunnableFunction
(
"
CanvasTranslator
NotifyDeviceReset
"
[
]
(
)
{
gfx
:
:
GPUParent
:
:
GetSingleton
(
)
-
>
NotifyDeviceReset
(
)
;
}
)
;
SyncRunnable
:
:
DispatchToThread
(
GetMainThreadEventTarget
(
)
runnable
true
)
;
mDevice
=
gfx
:
:
DeviceManagerDx
:
:
Get
(
)
-
>
GetCanvasDevice
(
)
;
if
(
!
mDevice
)
{
Telemetry
:
:
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
GFX_CANVAS_REMOTE_DEACTIVATED_NO_DEVICE
1
)
;
Deactivate
(
)
;
return
false
;
}
return
CreateReferenceTexture
(
)
;
#
else
return
false
;
#
endif
}
void
CanvasTranslator
:
:
NotifyDeviceChanged
(
)
{
mDeviceResetInProgress
=
true
;
mCanvasThreadHolder
-
>
DispatchToCanvasThread
(
NewRunnableMethod
(
"
CanvasTranslator
:
:
SendNotifyDeviceChanged
"
this
&
CanvasTranslator
:
:
SendNotifyDeviceChanged
)
)
;
}
void
CanvasTranslator
:
:
AddSurfaceDescriptor
(
int64_t
aTextureId
TextureData
*
aTextureData
)
{
UniquePtr
<
SurfaceDescriptor
>
descriptor
=
MakeUnique
<
SurfaceDescriptor
>
(
)
;
if
(
!
aTextureData
-
>
Serialize
(
*
descriptor
)
)
{
MOZ_CRASH
(
"
Failed
to
serialize
"
)
;
}
MonitorAutoLock
lock
(
mSurfaceDescriptorsMonitor
)
;
mSurfaceDescriptors
[
aTextureId
]
=
std
:
:
move
(
descriptor
)
;
mSurfaceDescriptorsMonitor
.
Notify
(
)
;
}
already_AddRefed
<
gfx
:
:
DrawTarget
>
CanvasTranslator
:
:
CreateDrawTarget
(
gfx
:
:
ReferencePtr
aRefPtr
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
)
{
RefPtr
<
gfx
:
:
DrawTarget
>
dt
;
do
{
gfx
:
:
AutoSerializeWithMoz2D
serializeWithMoz2D
(
GetBackendType
(
)
)
;
TextureData
*
textureData
=
CreateTextureData
(
mTextureType
aSize
aFormat
)
;
if
(
textureData
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mNextTextureId
>
=
0
"
No
texture
ID
set
"
)
;
textureData
-
>
Lock
(
OpenMode
:
:
OPEN_READ_WRITE
)
;
mTextureDatas
[
mNextTextureId
]
=
UniquePtr
<
TextureData
>
(
textureData
)
;
AddSurfaceDescriptor
(
mNextTextureId
textureData
)
;
dt
=
textureData
-
>
BorrowDrawTarget
(
)
;
}
}
while
(
!
dt
&
&
CheckForFreshCanvasDevice
(
__LINE__
)
)
;
AddDrawTarget
(
aRefPtr
dt
)
;
mNextTextureId
=
-
1
;
return
dt
.
forget
(
)
;
}
void
CanvasTranslator
:
:
RemoveTexture
(
int64_t
aTextureId
)
{
gfx
:
:
AutoSerializeWithMoz2D
serializeWithMoz2D
(
GetBackendType
(
)
)
;
mTextureDatas
.
erase
(
aTextureId
)
;
MonitorAutoLock
lock
(
mSurfaceDescriptorsMonitor
)
;
mSurfaceDescriptors
.
erase
(
aTextureId
)
;
}
TextureData
*
CanvasTranslator
:
:
LookupTextureData
(
int64_t
aTextureId
)
{
TextureMap
:
:
const_iterator
result
=
mTextureDatas
.
find
(
aTextureId
)
;
if
(
result
=
=
mTextureDatas
.
end
(
)
)
{
return
nullptr
;
}
return
result
-
>
second
.
get
(
)
;
}
UniquePtr
<
SurfaceDescriptor
>
CanvasTranslator
:
:
WaitForSurfaceDescriptor
(
int64_t
aTextureId
)
{
MonitorAutoLock
lock
(
mSurfaceDescriptorsMonitor
)
;
DescriptorMap
:
:
iterator
result
;
while
(
(
result
=
mSurfaceDescriptors
.
find
(
aTextureId
)
)
=
=
mSurfaceDescriptors
.
end
(
)
)
{
if
(
mDeactivated
)
{
return
nullptr
;
}
mSurfaceDescriptorsMonitor
.
Wait
(
)
;
}
UniquePtr
<
SurfaceDescriptor
>
descriptor
=
std
:
:
move
(
result
-
>
second
)
;
mSurfaceDescriptors
.
erase
(
aTextureId
)
;
return
descriptor
;
}
gfx
:
:
DataSourceSurface
*
CanvasTranslator
:
:
LookupDataSurface
(
gfx
:
:
ReferencePtr
aRefPtr
)
{
return
mDataSurfaces
.
GetWeak
(
aRefPtr
)
;
}
void
CanvasTranslator
:
:
AddDataSurface
(
gfx
:
:
ReferencePtr
aRefPtr
RefPtr
<
gfx
:
:
DataSourceSurface
>
&
&
aSurface
)
{
mDataSurfaces
.
Put
(
aRefPtr
std
:
:
move
(
aSurface
)
)
;
}
void
CanvasTranslator
:
:
RemoveDataSurface
(
gfx
:
:
ReferencePtr
aRefPtr
)
{
mDataSurfaces
.
Remove
(
aRefPtr
)
;
}
void
CanvasTranslator
:
:
SetPreparedMap
(
gfx
:
:
ReferencePtr
aSurface
UniquePtr
<
gfx
:
:
DataSourceSurface
:
:
ScopedMap
>
aMap
)
{
mMappedSurface
=
aSurface
;
mPreparedMap
=
std
:
:
move
(
aMap
)
;
}
UniquePtr
<
gfx
:
:
DataSourceSurface
:
:
ScopedMap
>
CanvasTranslator
:
:
GetPreparedMap
(
gfx
:
:
ReferencePtr
aSurface
)
{
if
(
!
mPreparedMap
)
{
return
nullptr
;
}
MOZ_RELEASE_ASSERT
(
mMappedSurface
=
=
aSurface
"
aSurface
must
match
previously
stored
surface
.
"
)
;
mMappedSurface
=
nullptr
;
return
std
:
:
move
(
mPreparedMap
)
;
}
}
}
