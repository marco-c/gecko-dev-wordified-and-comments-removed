#
include
"
CanvasTranslator
.
h
"
#
include
"
gfxGradientCache
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
CanvasManagerParent
.
h
"
#
include
"
mozilla
/
gfx
/
CanvasRenderThread
.
h
"
#
include
"
mozilla
/
gfx
/
DataSourceSurfaceWrapper
.
h
"
#
include
"
mozilla
/
gfx
/
DrawTargetWebgl
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
gfx
/
GPUParent
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessManager
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
mozilla
/
gfx
/
Swizzle
.
h
"
#
include
"
mozilla
/
ipc
/
Endpoint
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemoryHandle
.
h
"
#
include
"
mozilla
/
layers
/
BufferTexture
.
h
"
#
include
"
mozilla
/
layers
/
CanvasTranslator
.
h
"
#
include
"
mozilla
/
layers
/
ImageDataSerializer
.
h
"
#
include
"
mozilla
/
layers
/
SharedSurfacesParent
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
layers
/
VideoBridgeParent
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
SyncRunnable
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
HostWebGLContext
.
h
"
#
include
"
SharedSurface
.
h
"
#
include
"
WebGLParent
.
h
"
#
include
"
RecordedCanvasEventImpl
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
mozilla
/
gfx
/
DeviceManagerDx
.
h
"
#
include
"
mozilla
/
layers
/
TextureD3D11
.
h
"
#
include
"
mozilla
/
layers
/
VideoProcessorD3D11
.
h
"
#
endif
namespace
mozilla
{
namespace
layers
{
UniquePtr
<
TextureData
>
CanvasTranslator
:
:
CreateTextureData
(
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
bool
aClear
)
{
TextureData
*
textureData
=
nullptr
;
TextureAllocationFlags
allocFlags
=
aClear
?
ALLOC_CLEAR_BUFFER
:
ALLOC_DEFAULT
;
switch
(
mTextureType
)
{
#
ifdef
XP_WIN
case
TextureType
:
:
D3D11
:
{
if
(
gfx
:
:
gfxVars
:
:
RemoteCanvasEnabled
(
)
)
{
allocFlags
=
(
TextureAllocationFlags
)
(
allocFlags
|
USE_D3D11_KEYED_MUTEX
)
;
}
textureData
=
D3D11TextureData
:
:
Create
(
aSize
aFormat
allocFlags
mDevice
)
;
break
;
}
#
endif
case
TextureType
:
:
Unknown
:
textureData
=
BufferTextureData
:
:
Create
(
aSize
aFormat
gfx
:
:
BackendType
:
:
SKIA
LayersBackend
:
:
LAYERS_WR
TextureFlags
:
:
DEALLOCATE_CLIENT
|
TextureFlags
:
:
REMOTE_TEXTURE
allocFlags
nullptr
)
;
break
;
default
:
textureData
=
TextureData
:
:
Create
(
mTextureType
aFormat
aSize
allocFlags
mBackendType
)
;
break
;
}
return
WrapUnique
(
textureData
)
;
}
CanvasTranslator
:
:
CanvasTranslator
(
layers
:
:
SharedSurfacesHolder
*
aSharedSurfacesHolder
const
dom
:
:
ContentParentId
&
aContentId
uint32_t
aManagerId
)
:
mTranslationTaskQueue
(
gfx
:
:
CanvasRenderThread
:
:
CreateWorkerTaskQueue
(
)
)
mSharedSurfacesHolder
(
aSharedSurfacesHolder
)
#
if
defined
(
XP_WIN
)
mVideoProcessorD3D11
(
"
CanvasTranslator
:
:
mVideoProcessorD3D11
"
)
#
endif
mMaxSpinCount
(
StaticPrefs
:
:
gfx_canvas_remote_max_spin_count
(
)
)
mContentId
(
aContentId
)
mManagerId
(
aManagerId
)
mCanvasTranslatorEventsLock
(
"
CanvasTranslator
:
:
mCanvasTranslatorEventsLock
"
)
{
mNextEventTimeout
=
TimeDuration
:
:
FromMilliseconds
(
StaticPrefs
:
:
gfx_canvas_remote_event_timeout_ms
(
)
)
;
}
CanvasTranslator
:
:
~
CanvasTranslator
(
)
=
default
;
void
CanvasTranslator
:
:
DispatchToTaskQueue
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
{
if
(
mTranslationTaskQueue
)
{
MOZ_ALWAYS_SUCCEEDS
(
mTranslationTaskQueue
-
>
Dispatch
(
std
:
:
move
(
aRunnable
)
)
)
;
}
else
{
gfx
:
:
CanvasRenderThread
:
:
Dispatch
(
std
:
:
move
(
aRunnable
)
)
;
}
}
bool
CanvasTranslator
:
:
IsInTaskQueue
(
)
const
{
if
(
mTranslationTaskQueue
)
{
return
mTranslationTaskQueue
-
>
IsCurrentThreadIn
(
)
;
}
return
gfx
:
:
CanvasRenderThread
:
:
IsInCanvasRenderThread
(
)
;
}
StaticRefPtr
<
gfx
:
:
SharedContextWebgl
>
CanvasTranslator
:
:
sSharedContext
;
bool
CanvasTranslator
:
:
EnsureSharedContextWebgl
(
)
{
if
(
!
mSharedContext
|
|
mSharedContext
-
>
IsContextLost
(
)
)
{
if
(
mSharedContext
)
{
ForceDrawTargetWebglFallback
(
)
;
if
(
mRemoteTextureOwner
)
{
mRemoteTextureOwner
-
>
ClearRecycledTextures
(
)
;
}
}
if
(
!
sSharedContext
|
|
sSharedContext
-
>
IsContextLost
(
)
)
{
sSharedContext
=
gfx
:
:
SharedContextWebgl
:
:
Create
(
)
;
}
mSharedContext
=
sSharedContext
;
if
(
!
mSharedContext
|
|
mSharedContext
-
>
IsContextLost
(
)
)
{
mSharedContext
=
nullptr
;
BlockCanvas
(
)
;
return
false
;
}
}
return
true
;
}
void
CanvasTranslator
:
:
Shutdown
(
)
{
if
(
sSharedContext
)
{
gfx
:
:
CanvasRenderThread
:
:
Dispatch
(
NS_NewRunnableFunction
(
"
CanvasTranslator
:
:
Shutdown
"
[
]
(
)
{
sSharedContext
=
nullptr
;
}
)
)
;
}
}
mozilla
:
:
ipc
:
:
IPCResult
CanvasTranslator
:
:
RecvInitTranslator
(
TextureType
aTextureType
TextureType
aWebglTextureType
gfx
:
:
BackendType
aBackendType
ipc
:
:
MutableSharedMemoryHandle
&
&
aReadHandle
nsTArray
<
ipc
:
:
ReadOnlySharedMemoryHandle
>
&
&
aBufferHandles
CrossProcessSemaphoreHandle
&
&
aReaderSem
CrossProcessSemaphoreHandle
&
&
aWriterSem
)
{
if
(
mHeaderShmem
)
{
return
IPC_FAIL
(
this
"
RecvInitTranslator
called
twice
.
"
)
;
}
mTextureType
=
aTextureType
;
mWebglTextureType
=
aWebglTextureType
;
mBackendType
=
aBackendType
;
mOtherPid
=
OtherPid
(
)
;
mHeaderShmem
=
aReadHandle
.
Map
(
)
;
if
(
!
mHeaderShmem
)
{
Deactivate
(
)
;
return
IPC_FAIL
(
this
"
Failed
to
map
canvas
header
shared
memory
.
"
)
;
}
mHeader
=
mHeaderShmem
.
DataAs
<
Header
>
(
)
;
mWriterSemaphore
.
reset
(
CrossProcessSemaphore
:
:
Create
(
std
:
:
move
(
aWriterSem
)
)
)
;
mWriterSemaphore
-
>
CloseHandle
(
)
;
mReaderSemaphore
.
reset
(
CrossProcessSemaphore
:
:
Create
(
std
:
:
move
(
aReaderSem
)
)
)
;
mReaderSemaphore
-
>
CloseHandle
(
)
;
if
(
!
CheckForFreshCanvasDevice
(
__LINE__
)
)
{
gfxCriticalNote
<
<
"
GFX
:
CanvasTranslator
failed
to
get
device
"
;
return
IPC_OK
(
)
;
}
if
(
gfx
:
:
gfxVars
:
:
UseAcceleratedCanvas2D
(
)
&
&
!
EnsureSharedContextWebgl
(
)
)
{
gfxCriticalNote
<
<
"
GFX
:
CanvasTranslator
failed
creating
WebGL
shared
context
"
;
}
mDefaultBufferSize
=
aBufferHandles
[
0
]
.
Size
(
)
;
auto
handleIter
=
aBufferHandles
.
begin
(
)
;
mCurrentShmem
.
shmem
=
std
:
:
move
(
*
handleIter
)
.
Map
(
)
;
if
(
!
mCurrentShmem
.
shmem
)
{
Deactivate
(
)
;
return
IPC_FAIL
(
this
"
Failed
to
map
canvas
buffer
shared
memory
.
"
)
;
}
mCurrentMemReader
=
mCurrentShmem
.
CreateMemReader
(
)
;
for
(
handleIter
+
+
;
handleIter
<
aBufferHandles
.
end
(
)
;
handleIter
+
+
)
{
CanvasShmem
newShmem
;
newShmem
.
shmem
=
std
:
:
move
(
*
handleIter
)
.
Map
(
)
;
if
(
!
newShmem
.
shmem
)
{
Deactivate
(
)
;
return
IPC_FAIL
(
this
"
Failed
to
map
canvas
buffer
shared
memory
.
"
)
;
}
mCanvasShmems
.
emplace
(
std
:
:
move
(
newShmem
)
)
;
}
if
(
UsePendingCanvasTranslatorEvents
(
)
)
{
MutexAutoLock
lock
(
mCanvasTranslatorEventsLock
)
;
mPendingCanvasTranslatorEvents
.
push_back
(
CanvasTranslatorEvent
:
:
TranslateRecording
(
)
)
;
PostCanvasTranslatorEvents
(
lock
)
;
}
else
{
DispatchToTaskQueue
(
NewRunnableMethod
(
"
CanvasTranslator
:
:
TranslateRecording
"
this
&
CanvasTranslator
:
:
TranslateRecording
)
)
;
}
return
IPC_OK
(
)
;
}
ipc
:
:
IPCResult
CanvasTranslator
:
:
RecvRestartTranslation
(
)
{
if
(
mDeactivated
)
{
return
IPC_OK
(
)
;
}
if
(
UsePendingCanvasTranslatorEvents
(
)
)
{
MutexAutoLock
lock
(
mCanvasTranslatorEventsLock
)
;
mPendingCanvasTranslatorEvents
.
push_back
(
CanvasTranslatorEvent
:
:
TranslateRecording
(
)
)
;
PostCanvasTranslatorEvents
(
lock
)
;
}
else
{
DispatchToTaskQueue
(
NewRunnableMethod
(
"
CanvasTranslator
:
:
TranslateRecording
"
this
&
CanvasTranslator
:
:
TranslateRecording
)
)
;
}
return
IPC_OK
(
)
;
}
ipc
:
:
IPCResult
CanvasTranslator
:
:
RecvAddBuffer
(
ipc
:
:
ReadOnlySharedMemoryHandle
&
&
aBufferHandle
)
{
if
(
mDeactivated
)
{
return
IPC_OK
(
)
;
}
if
(
UsePendingCanvasTranslatorEvents
(
)
)
{
MutexAutoLock
lock
(
mCanvasTranslatorEventsLock
)
;
mPendingCanvasTranslatorEvents
.
push_back
(
CanvasTranslatorEvent
:
:
AddBuffer
(
std
:
:
move
(
aBufferHandle
)
)
)
;
PostCanvasTranslatorEvents
(
lock
)
;
}
else
{
DispatchToTaskQueue
(
NewRunnableMethod
<
ipc
:
:
ReadOnlySharedMemoryHandle
&
&
>
(
"
CanvasTranslator
:
:
AddBuffer
"
this
&
CanvasTranslator
:
:
AddBuffer
std
:
:
move
(
aBufferHandle
)
)
)
;
}
return
IPC_OK
(
)
;
}
bool
CanvasTranslator
:
:
AddBuffer
(
ipc
:
:
ReadOnlySharedMemoryHandle
&
&
aBufferHandle
)
{
MOZ_ASSERT
(
IsInTaskQueue
(
)
)
;
if
(
mHeader
-
>
readerState
=
=
State
:
:
Failed
)
{
return
false
;
}
if
(
mHeader
-
>
readerState
!
=
State
:
:
Paused
)
{
gfxCriticalNote
<
<
"
CanvasTranslator
:
:
AddBuffer
bad
state
"
<
<
uint32_t
(
State
(
mHeader
-
>
readerState
)
)
;
#
ifndef
FUZZING_SNAPSHOT
MOZ_DIAGNOSTIC_CRASH
(
"
mHeader
-
>
readerState
=
=
State
:
:
Paused
"
)
;
#
endif
Deactivate
(
)
;
return
false
;
}
MOZ_ASSERT
(
mDefaultBufferSize
!
=
0
)
;
CheckAndSignalWriter
(
)
;
if
(
mCurrentShmem
.
IsValid
(
)
&
&
mCurrentShmem
.
Size
(
)
=
=
mDefaultBufferSize
)
{
mCanvasShmems
.
emplace
(
std
:
:
move
(
mCurrentShmem
)
)
;
}
CanvasShmem
newShmem
;
newShmem
.
shmem
=
aBufferHandle
.
Map
(
)
;
if
(
!
newShmem
.
shmem
)
{
return
false
;
}
mCurrentShmem
=
std
:
:
move
(
newShmem
)
;
mCurrentMemReader
=
mCurrentShmem
.
CreateMemReader
(
)
;
return
TranslateRecording
(
)
;
}
ipc
:
:
IPCResult
CanvasTranslator
:
:
RecvSetDataSurfaceBuffer
(
ipc
:
:
MutableSharedMemoryHandle
&
&
aBufferHandle
)
{
if
(
mDeactivated
)
{
return
IPC_OK
(
)
;
}
if
(
UsePendingCanvasTranslatorEvents
(
)
)
{
MutexAutoLock
lock
(
mCanvasTranslatorEventsLock
)
;
mPendingCanvasTranslatorEvents
.
push_back
(
CanvasTranslatorEvent
:
:
SetDataSurfaceBuffer
(
std
:
:
move
(
aBufferHandle
)
)
)
;
PostCanvasTranslatorEvents
(
lock
)
;
}
else
{
DispatchToTaskQueue
(
NewRunnableMethod
<
ipc
:
:
MutableSharedMemoryHandle
&
&
>
(
"
CanvasTranslator
:
:
SetDataSurfaceBuffer
"
this
&
CanvasTranslator
:
:
SetDataSurfaceBuffer
std
:
:
move
(
aBufferHandle
)
)
)
;
}
return
IPC_OK
(
)
;
}
bool
CanvasTranslator
:
:
SetDataSurfaceBuffer
(
ipc
:
:
MutableSharedMemoryHandle
&
&
aBufferHandle
)
{
MOZ_ASSERT
(
IsInTaskQueue
(
)
)
;
if
(
mHeader
-
>
readerState
=
=
State
:
:
Failed
)
{
return
false
;
}
if
(
mHeader
-
>
readerState
!
=
State
:
:
Paused
)
{
gfxCriticalNote
<
<
"
CanvasTranslator
:
:
SetDataSurfaceBuffer
bad
state
"
<
<
uint32_t
(
State
(
mHeader
-
>
readerState
)
)
;
#
ifndef
FUZZING_SNAPSHOT
MOZ_DIAGNOSTIC_CRASH
(
"
mHeader
-
>
readerState
=
=
State
:
:
Paused
"
)
;
#
endif
Deactivate
(
)
;
return
false
;
}
mDataSurfaceShmem
=
aBufferHandle
.
Map
(
)
;
if
(
!
mDataSurfaceShmem
)
{
return
false
;
}
return
TranslateRecording
(
)
;
}
void
CanvasTranslator
:
:
GetDataSurface
(
uint64_t
aSurfaceRef
)
{
MOZ_ASSERT
(
IsInTaskQueue
(
)
)
;
ReferencePtr
surfaceRef
=
reinterpret_cast
<
void
*
>
(
aSurfaceRef
)
;
gfx
:
:
SourceSurface
*
surface
=
LookupSourceSurface
(
surfaceRef
)
;
if
(
!
surface
)
{
return
;
}
UniquePtr
<
gfx
:
:
DataSourceSurface
:
:
ScopedMap
>
map
=
GetPreparedMap
(
surfaceRef
)
;
if
(
!
map
)
{
return
;
}
auto
dstSize
=
surface
-
>
GetSize
(
)
;
auto
srcSize
=
map
-
>
GetSurface
(
)
-
>
GetSize
(
)
;
gfx
:
:
SurfaceFormat
format
=
surface
-
>
GetFormat
(
)
;
int32_t
bpp
=
BytesPerPixel
(
format
)
;
int32_t
dataFormatWidth
=
dstSize
.
width
*
bpp
;
int32_t
srcStride
=
map
-
>
GetStride
(
)
;
if
(
dataFormatWidth
>
srcStride
|
|
srcSize
!
=
dstSize
)
{
return
;
}
int32_t
dstStride
=
ImageDataSerializer
:
:
ComputeRGBStride
(
format
dstSize
.
width
)
;
auto
requiredSize
=
ImageDataSerializer
:
:
ComputeRGBBufferSize
(
dstSize
format
)
;
if
(
requiredSize
<
=
0
|
|
size_t
(
requiredSize
)
>
mDataSurfaceShmem
.
Size
(
)
)
{
return
;
}
uint8_t
*
dst
=
mDataSurfaceShmem
.
DataAs
<
uint8_t
>
(
)
;
const
uint8_t
*
src
=
map
-
>
GetData
(
)
;
const
uint8_t
*
endSrc
=
src
+
(
srcSize
.
height
*
srcStride
)
;
while
(
src
<
endSrc
)
{
memcpy
(
dst
src
dataFormatWidth
)
;
src
+
=
srcStride
;
dst
+
=
dstStride
;
}
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
CanvasTranslator
:
:
WaitForSurface
(
uintptr_t
aId
Maybe
<
layers
:
:
SurfaceDescriptor
>
*
aDesc
)
{
if
(
!
gfx
:
:
gfxVars
:
:
UseAcceleratedCanvas2D
(
)
|
|
!
UsePendingCanvasTranslatorEvents
(
)
|
|
!
IsInTaskQueue
(
)
)
{
return
nullptr
;
}
ReferencePtr
idRef
(
aId
)
;
ExportSurface
*
surf
=
LookupExportSurface
(
idRef
)
;
if
(
!
surf
|
|
!
surf
-
>
mData
)
{
if
(
!
HasPendingEvent
(
)
)
{
return
nullptr
;
}
mFlushCheckpoint
=
mHeader
-
>
eventCount
;
HandleCanvasTranslatorEvents
(
)
;
mFlushCheckpoint
=
0
;
surf
=
LookupExportSurface
(
idRef
)
;
if
(
!
surf
|
|
!
surf
-
>
mData
)
{
return
nullptr
;
}
}
if
(
aDesc
&
&
mWebglTextureType
!
=
TextureType
:
:
Unknown
&
&
mSharedContext
&
&
!
mSharedContext
-
>
IsContextLost
(
)
)
{
surf
-
>
mSharedSurface
=
mSharedContext
-
>
ExportSharedSurface
(
mWebglTextureType
surf
-
>
mData
)
;
if
(
surf
-
>
mSharedSurface
)
{
surf
-
>
mSharedSurface
-
>
BeginRead
(
)
;
*
aDesc
=
surf
-
>
mSharedSurface
-
>
ToSurfaceDescriptor
(
)
;
surf
-
>
mSharedSurface
-
>
EndRead
(
)
;
}
}
return
do_AddRef
(
surf
-
>
mData
)
;
}
void
CanvasTranslator
:
:
RemoveExportSurface
(
gfx
:
:
ReferencePtr
aRefPtr
)
{
auto
it
=
mExportSurfaces
.
find
(
aRefPtr
)
;
if
(
it
!
=
mExportSurfaces
.
end
(
)
)
{
mExportSurfaces
.
erase
(
it
)
;
}
}
void
CanvasTranslator
:
:
RecycleBuffer
(
)
{
mCanvasShmems
.
emplace
(
std
:
:
move
(
mCurrentShmem
)
)
;
NextBuffer
(
)
;
}
void
CanvasTranslator
:
:
NextBuffer
(
)
{
CheckAndSignalWriter
(
)
;
mCurrentShmem
=
std
:
:
move
(
mCanvasShmems
.
front
(
)
)
;
mCanvasShmems
.
pop
(
)
;
mCurrentMemReader
=
mCurrentShmem
.
CreateMemReader
(
)
;
}
void
CanvasTranslator
:
:
ActorDestroy
(
ActorDestroyReason
why
)
{
MOZ_ASSERT
(
gfx
:
:
CanvasRenderThread
:
:
IsInCanvasRenderThread
(
)
)
;
mIPDLClosed
=
true
;
{
MutexAutoLock
lock
(
mCanvasTranslatorEventsLock
)
;
mPendingCanvasTranslatorEvents
.
clear
(
)
;
}
#
if
defined
(
XP_WIN
)
{
auto
lock
=
mVideoProcessorD3D11
.
Lock
(
)
;
auto
&
videoProcessor
=
lock
.
ref
(
)
;
videoProcessor
=
nullptr
;
}
#
endif
DispatchToTaskQueue
(
NewRunnableMethod
(
"
CanvasTranslator
:
:
ClearTextureInfo
"
this
&
CanvasTranslator
:
:
ClearTextureInfo
)
)
;
if
(
mTranslationTaskQueue
)
{
gfx
:
:
CanvasRenderThread
:
:
ShutdownWorkerTaskQueue
(
mTranslationTaskQueue
)
;
return
;
}
}
bool
CanvasTranslator
:
:
CheckDeactivated
(
)
{
if
(
mDeactivated
)
{
return
true
;
}
if
(
NS_WARN_IF
(
!
gfx
:
:
gfxVars
:
:
RemoteCanvasEnabled
(
)
&
&
!
gfx
:
:
gfxVars
:
:
UseAcceleratedCanvas2D
(
)
)
)
{
Deactivate
(
)
;
}
return
mDeactivated
;
}
void
CanvasTranslator
:
:
Deactivate
(
)
{
if
(
mDeactivated
)
{
return
;
}
mDeactivated
=
true
;
if
(
mHeader
)
{
mHeader
-
>
readerState
=
State
:
:
Failed
;
}
gfx
:
:
CanvasRenderThread
:
:
Dispatch
(
NewRunnableMethod
(
"
CanvasTranslator
:
:
SendDeactivate
"
this
&
CanvasTranslator
:
:
SendDeactivate
)
)
;
gfx
:
:
CanvasManagerParent
:
:
DisableRemoteCanvas
(
)
;
}
inline
gfx
:
:
DrawTargetWebgl
*
CanvasTranslator
:
:
TextureInfo
:
:
GetDrawTargetWebgl
(
bool
aCheckForFallback
)
const
{
if
(
(
!
mTextureData
|
|
!
aCheckForFallback
)
&
&
mDrawTarget
&
&
mDrawTarget
-
>
GetBackendType
(
)
=
=
gfx
:
:
BackendType
:
:
WEBGL
)
{
return
static_cast
<
gfx
:
:
DrawTargetWebgl
*
>
(
mDrawTarget
.
get
(
)
)
;
}
return
nullptr
;
}
bool
CanvasTranslator
:
:
TryDrawTargetWebglFallback
(
const
RemoteTextureOwnerId
aTextureOwnerId
gfx
:
:
DrawTargetWebgl
*
aWebgl
)
{
NotifyRequiresRefresh
(
aTextureOwnerId
)
;
const
auto
&
info
=
mTextureInfo
[
aTextureOwnerId
]
;
if
(
RefPtr
<
gfx
:
:
DrawTarget
>
dt
=
CreateFallbackDrawTarget
(
info
.
mRefPtr
aTextureOwnerId
aWebgl
-
>
GetSize
(
)
aWebgl
-
>
GetFormat
(
)
)
)
{
bool
success
=
aWebgl
-
>
CopyToFallback
(
dt
)
;
AddDrawTarget
(
info
.
mRefPtr
dt
)
;
return
success
;
}
return
false
;
}
void
CanvasTranslator
:
:
ForceDrawTargetWebglFallback
(
)
{
RemoteTextureOwnerIdSet
lost
;
for
(
const
auto
&
entry
:
mTextureInfo
)
{
const
auto
&
ownerId
=
entry
.
first
;
const
auto
&
info
=
entry
.
second
;
if
(
gfx
:
:
DrawTargetWebgl
*
webgl
=
info
.
GetDrawTargetWebgl
(
)
)
{
if
(
!
TryDrawTargetWebglFallback
(
entry
.
first
webgl
)
)
{
if
(
mRemoteTextureOwner
&
&
mRemoteTextureOwner
-
>
IsRegistered
(
ownerId
)
)
{
lost
.
insert
(
ownerId
)
;
}
}
}
}
if
(
!
lost
.
empty
(
)
)
{
NotifyDeviceReset
(
lost
)
;
}
}
void
CanvasTranslator
:
:
BlockCanvas
(
)
{
if
(
mDeactivated
|
|
mBlocked
)
{
return
;
}
mBlocked
=
true
;
gfx
:
:
CanvasRenderThread
:
:
Dispatch
(
NewRunnableMethod
(
"
CanvasTranslator
:
:
SendBlockCanvas
"
this
&
CanvasTranslator
:
:
SendBlockCanvas
)
)
;
}
void
CanvasTranslator
:
:
CheckAndSignalWriter
(
)
{
do
{
switch
(
mHeader
-
>
writerState
)
{
case
State
:
:
Processing
:
case
State
:
:
Failed
:
return
;
case
State
:
:
AboutToWait
:
if
(
mIPDLClosed
)
{
return
;
}
continue
;
case
State
:
:
Waiting
:
if
(
mHeader
-
>
processedCount
>
=
mHeader
-
>
writerWaitCount
)
{
mHeader
-
>
writerState
=
State
:
:
Processing
;
mWriterSemaphore
-
>
Signal
(
)
;
}
return
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
waiting
state
.
"
)
;
return
;
}
}
while
(
true
)
;
}
bool
CanvasTranslator
:
:
HasPendingEvent
(
)
{
return
mHeader
-
>
processedCount
<
mHeader
-
>
eventCount
;
}
bool
CanvasTranslator
:
:
ReadPendingEvent
(
EventType
&
aEventType
)
{
ReadElementConstrained
(
mCurrentMemReader
aEventType
EventType
:
:
DRAWTARGETCREATION
LAST_CANVAS_EVENT_TYPE
)
;
if
(
!
mCurrentMemReader
.
good
(
)
)
{
mHeader
-
>
readerState
=
State
:
:
Failed
;
return
false
;
}
return
true
;
}
bool
CanvasTranslator
:
:
ReadNextEvent
(
EventType
&
aEventType
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mHeader
-
>
readerState
=
=
State
:
:
Processing
)
;
uint32_t
spinCount
=
mMaxSpinCount
;
do
{
if
(
HasPendingEvent
(
)
)
{
return
ReadPendingEvent
(
aEventType
)
;
}
}
while
(
-
-
spinCount
!
=
0
)
;
Flush
(
)
;
mHeader
-
>
readerState
=
State
:
:
AboutToWait
;
if
(
HasPendingEvent
(
)
)
{
mHeader
-
>
readerState
=
State
:
:
Processing
;
return
ReadPendingEvent
(
aEventType
)
;
}
if
(
!
mIsInTransaction
)
{
mHeader
-
>
readerState
=
State
:
:
Stopped
;
return
false
;
}
mHeader
-
>
readerState
=
State
:
:
Waiting
;
if
(
mReaderSemaphore
-
>
Wait
(
Some
(
mNextEventTimeout
)
)
)
{
MOZ_RELEASE_ASSERT
(
HasPendingEvent
(
)
)
;
MOZ_RELEASE_ASSERT
(
mHeader
-
>
readerState
=
=
State
:
:
Processing
)
;
return
ReadPendingEvent
(
aEventType
)
;
}
if
(
!
mHeader
-
>
readerState
.
compareExchange
(
State
:
:
Waiting
State
:
:
Stopped
)
)
{
MOZ_RELEASE_ASSERT
(
HasPendingEvent
(
)
)
;
MOZ_RELEASE_ASSERT
(
mHeader
-
>
readerState
=
=
State
:
:
Processing
)
;
MOZ_ALWAYS_TRUE
(
mReaderSemaphore
-
>
Wait
(
)
)
;
return
ReadPendingEvent
(
aEventType
)
;
}
return
false
;
}
bool
CanvasTranslator
:
:
TranslateRecording
(
)
{
MOZ_ASSERT
(
IsInTaskQueue
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT_IF
(
mFlushCheckpoint
HasPendingEvent
(
)
)
;
if
(
mHeader
-
>
readerState
=
=
State
:
:
Failed
)
{
return
false
;
}
if
(
mSharedContext
&
&
EnsureSharedContextWebgl
(
)
)
{
mSharedContext
-
>
EnterTlsScope
(
)
;
}
auto
exitTlsScope
=
MakeScopeExit
(
[
&
]
{
if
(
mSharedContext
)
{
mSharedContext
-
>
ExitTlsScope
(
)
;
}
}
)
;
auto
start
=
TimeStamp
:
:
Now
(
)
;
mHeader
-
>
readerState
=
State
:
:
Processing
;
EventType
eventType
=
EventType
:
:
INVALID
;
while
(
ReadNextEvent
(
eventType
)
)
{
bool
success
=
RecordedEvent
:
:
DoWithEventFromReader
(
mCurrentMemReader
eventType
[
&
]
(
RecordedEvent
*
recordedEvent
)
-
>
bool
{
if
(
!
mCurrentMemReader
.
good
(
)
)
{
if
(
mIPDLClosed
)
{
gfxWarning
(
)
<
<
"
Failed
to
read
event
type
:
"
<
<
recordedEvent
-
>
GetType
(
)
;
}
else
{
gfxCriticalNote
<
<
"
Failed
to
read
event
type
:
"
<
<
recordedEvent
-
>
GetType
(
)
;
}
return
false
;
}
return
recordedEvent
-
>
PlayEvent
(
this
)
;
}
)
;
if
(
!
mCurrentMemReader
.
good
(
)
)
{
mHeader
-
>
readerState
=
State
:
:
Failed
;
return
false
;
}
if
(
!
success
&
&
!
HandleExtensionEvent
(
eventType
)
)
{
if
(
mDeviceResetInProgress
)
{
gfxWarning
(
)
<
<
"
Failed
to
play
canvas
event
type
:
"
<
<
eventType
;
}
else
{
gfxCriticalNote
<
<
"
Failed
to
play
canvas
event
type
:
"
<
<
eventType
;
}
if
(
!
mCurrentMemReader
.
good
(
)
)
{
mHeader
-
>
readerState
=
State
:
:
Failed
;
return
false
;
}
}
mHeader
-
>
processedCount
+
+
;
if
(
mHeader
-
>
readerState
=
=
State
:
:
Paused
|
|
PauseUntilSync
(
)
)
{
Flush
(
)
;
return
false
;
}
if
(
mFlushCheckpoint
)
{
if
(
mHeader
-
>
processedCount
>
=
mFlushCheckpoint
)
{
return
true
;
}
}
else
{
if
(
UsePendingCanvasTranslatorEvents
(
)
)
{
const
auto
maxDurationMs
=
100
;
const
auto
now
=
TimeStamp
:
:
Now
(
)
;
const
auto
waitDurationMs
=
static_cast
<
uint32_t
>
(
(
now
-
start
)
.
ToMilliseconds
(
)
)
;
if
(
waitDurationMs
>
maxDurationMs
)
{
return
true
;
}
}
}
}
return
false
;
}
bool
CanvasTranslator
:
:
UsePendingCanvasTranslatorEvents
(
)
{
return
StaticPrefs
:
:
gfx_canvas_remote_use_canvas_translator_event_AtStartup
(
)
&
&
!
mTranslationTaskQueue
;
}
void
CanvasTranslator
:
:
PostCanvasTranslatorEvents
(
const
MutexAutoLock
&
aProofOfLock
)
{
if
(
mIPDLClosed
)
{
return
;
}
if
(
mCanvasTranslatorEventsRunnable
)
{
return
;
}
RefPtr
<
nsIRunnable
>
runnable
=
NewRunnableMethod
(
"
CanvasTranslator
:
:
HandleCanvasTranslatorEvents
"
this
&
CanvasTranslator
:
:
HandleCanvasTranslatorEvents
)
;
mCanvasTranslatorEventsRunnable
=
runnable
;
DispatchToTaskQueue
(
runnable
.
forget
(
)
)
;
}
void
CanvasTranslator
:
:
HandleCanvasTranslatorEvents
(
)
{
MOZ_ASSERT
(
IsInTaskQueue
(
)
)
;
UniquePtr
<
CanvasTranslatorEvent
>
event
;
{
MutexAutoLock
lock
(
mCanvasTranslatorEventsLock
)
;
MOZ_ASSERT_IF
(
mIPDLClosed
mPendingCanvasTranslatorEvents
.
empty
(
)
)
;
if
(
mPendingCanvasTranslatorEvents
.
empty
(
)
|
|
PauseUntilSync
(
)
)
{
mCanvasTranslatorEventsRunnable
=
nullptr
;
return
;
}
auto
&
front
=
mPendingCanvasTranslatorEvents
.
front
(
)
;
event
=
std
:
:
move
(
front
)
;
mPendingCanvasTranslatorEvents
.
pop_front
(
)
;
}
MOZ_RELEASE_ASSERT
(
event
.
get
(
)
)
;
bool
dispatchTranslate
=
false
;
while
(
!
dispatchTranslate
&
&
event
)
{
switch
(
event
-
>
mTag
)
{
case
CanvasTranslatorEvent
:
:
Tag
:
:
TranslateRecording
:
dispatchTranslate
=
TranslateRecording
(
)
;
break
;
case
CanvasTranslatorEvent
:
:
Tag
:
:
AddBuffer
:
dispatchTranslate
=
AddBuffer
(
event
-
>
TakeBufferHandle
(
)
)
;
break
;
case
CanvasTranslatorEvent
:
:
Tag
:
:
SetDataSurfaceBuffer
:
dispatchTranslate
=
SetDataSurfaceBuffer
(
event
-
>
TakeDataSurfaceBufferHandle
(
)
)
;
break
;
case
CanvasTranslatorEvent
:
:
Tag
:
:
ClearCachedResources
:
ClearCachedResources
(
)
;
break
;
case
CanvasTranslatorEvent
:
:
Tag
:
:
DropFreeBuffersWhenDormant
:
DropFreeBuffersWhenDormant
(
)
;
break
;
}
event
.
reset
(
nullptr
)
;
{
MutexAutoLock
lock
(
mCanvasTranslatorEventsLock
)
;
MOZ_ASSERT_IF
(
mIPDLClosed
mPendingCanvasTranslatorEvents
.
empty
(
)
)
;
if
(
mIPDLClosed
)
{
return
;
}
if
(
PauseUntilSync
(
)
)
{
mCanvasTranslatorEventsRunnable
=
nullptr
;
mPendingCanvasTranslatorEvents
.
push_front
(
CanvasTranslatorEvent
:
:
TranslateRecording
(
)
)
;
return
;
}
if
(
!
mIPDLClosed
&
&
!
dispatchTranslate
&
&
!
mPendingCanvasTranslatorEvents
.
empty
(
)
)
{
auto
&
front
=
mPendingCanvasTranslatorEvents
.
front
(
)
;
event
=
std
:
:
move
(
front
)
;
mPendingCanvasTranslatorEvents
.
pop_front
(
)
;
}
}
}
MOZ_ASSERT
(
!
event
)
;
{
MutexAutoLock
lock
(
mCanvasTranslatorEventsLock
)
;
mCanvasTranslatorEventsRunnable
=
nullptr
;
MOZ_ASSERT_IF
(
mIPDLClosed
mPendingCanvasTranslatorEvents
.
empty
(
)
)
;
if
(
mIPDLClosed
)
{
return
;
}
if
(
dispatchTranslate
)
{
mPendingCanvasTranslatorEvents
.
push_front
(
CanvasTranslatorEvent
:
:
TranslateRecording
(
)
)
;
}
if
(
!
mPendingCanvasTranslatorEvents
.
empty
(
)
)
{
PostCanvasTranslatorEvents
(
lock
)
;
}
}
}
#
define
READ_AND_PLAY_CANVAS_EVENT_TYPE
(
_typeenum
_class
)
\
case
_typeenum
:
{
\
auto
e
=
_class
(
mCurrentMemReader
)
;
\
if
(
!
mCurrentMemReader
.
good
(
)
)
{
\
if
(
mIPDLClosed
)
{
\
/
*
The
other
side
has
closed
only
warn
about
read
failure
.
*
/
\
gfxWarning
(
)
<
<
"
Failed
to
read
event
type
:
"
<
<
_typeenum
;
\
}
else
{
\
gfxCriticalNote
<
<
"
Failed
to
read
event
type
:
"
<
<
_typeenum
;
\
}
\
return
false
;
\
}
\
return
e
.
PlayCanvasEvent
(
this
)
;
\
}
bool
CanvasTranslator
:
:
HandleExtensionEvent
(
int32_t
aType
)
{
switch
(
aType
)
{
FOR_EACH_CANVAS_EVENT
(
READ_AND_PLAY_CANVAS_EVENT_TYPE
)
default
:
return
false
;
}
}
void
CanvasTranslator
:
:
BeginTransaction
(
)
{
PROFILER_MARKER_TEXT
(
"
CanvasTranslator
"
GRAPHICS
{
}
"
CanvasTranslator
:
:
BeginTransaction
"
_ns
)
;
mIsInTransaction
=
true
;
}
void
CanvasTranslator
:
:
Flush
(
)
{
#
if
defined
(
XP_WIN
)
if
(
!
mDevice
)
{
return
;
}
gfx
:
:
AutoSerializeWithMoz2D
serializeWithMoz2D
(
mBackendType
)
;
RefPtr
<
ID3D11DeviceContext
>
deviceContext
;
mDevice
-
>
GetImmediateContext
(
getter_AddRefs
(
deviceContext
)
)
;
deviceContext
-
>
Flush
(
)
;
#
endif
}
void
CanvasTranslator
:
:
EndTransaction
(
)
{
Flush
(
)
;
Unused
<
<
CheckForFreshCanvasDevice
(
__LINE__
)
;
mIsInTransaction
=
false
;
}
void
CanvasTranslator
:
:
DeviceChangeAcknowledged
(
)
{
mDeviceResetInProgress
=
false
;
if
(
mRemoteTextureOwner
)
{
mRemoteTextureOwner
-
>
NotifyContextRestored
(
)
;
}
}
void
CanvasTranslator
:
:
DeviceResetAcknowledged
(
)
{
DeviceChangeAcknowledged
(
)
;
}
bool
CanvasTranslator
:
:
CreateReferenceTexture
(
)
{
if
(
mReferenceTextureData
)
{
mReferenceTextureData
-
>
Unlock
(
)
;
}
mReferenceTextureData
=
CreateTextureData
(
gfx
:
:
IntSize
(
1
1
)
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
true
)
;
if
(
!
mReferenceTextureData
)
{
Deactivate
(
)
;
return
false
;
}
if
(
NS_WARN_IF
(
!
mReferenceTextureData
-
>
Lock
(
OpenMode
:
:
OPEN_READ_WRITE
)
)
)
{
gfxCriticalNote
<
<
"
CanvasTranslator
:
:
CreateReferenceTexture
lock
failed
"
;
mReferenceTextureData
.
reset
(
)
;
Deactivate
(
)
;
return
false
;
}
mBaseDT
=
mReferenceTextureData
-
>
BorrowDrawTarget
(
)
;
if
(
!
mBaseDT
)
{
Deactivate
(
)
;
return
false
;
}
return
true
;
}
bool
CanvasTranslator
:
:
CheckForFreshCanvasDevice
(
int
aLineNumber
)
{
if
(
mBaseDT
&
&
mTextureType
!
=
TextureType
:
:
D3D11
)
{
return
false
;
}
#
if
defined
(
XP_WIN
)
RefPtr
<
ID3D11Device
>
device
=
gfx
:
:
DeviceManagerDx
:
:
Get
(
)
-
>
GetCanvasDevice
(
)
;
if
(
device
&
&
device
!
=
mDevice
)
{
if
(
mDevice
)
{
NotifyDeviceChanged
(
)
;
}
mDevice
=
device
.
forget
(
)
;
return
CreateReferenceTexture
(
)
;
}
gfx
:
:
DeviceResetReason
reason
=
gfx
:
:
DeviceResetReason
:
:
OTHER
;
if
(
mDevice
)
{
const
auto
d3d11Reason
=
mDevice
-
>
GetDeviceRemovedReason
(
)
;
reason
=
DXGIErrorToDeviceResetReason
(
d3d11Reason
)
;
if
(
reason
=
=
gfx
:
:
DeviceResetReason
:
:
OK
)
{
return
false
;
}
gfxCriticalNote
<
<
"
GFX
:
CanvasTranslator
detected
a
device
reset
at
"
<
<
aLineNumber
;
NotifyDeviceChanged
(
)
;
}
RefPtr
<
Runnable
>
runnable
=
NS_NewRunnableFunction
(
"
CanvasTranslator
NotifyDeviceReset
"
[
reason
]
(
)
{
gfx
:
:
GPUProcessManager
:
:
GPUProcessManager
:
:
NotifyDeviceReset
(
reason
gfx
:
:
DeviceResetDetectPlace
:
:
CANVAS_TRANSLATOR
)
;
}
)
;
SyncRunnable
:
:
DispatchToThread
(
GetMainThreadSerialEventTarget
(
)
runnable
true
)
;
mDevice
=
gfx
:
:
DeviceManagerDx
:
:
Get
(
)
-
>
GetCanvasDevice
(
)
;
if
(
!
mDevice
)
{
Deactivate
(
)
;
return
false
;
}
#
endif
return
CreateReferenceTexture
(
)
;
}
void
CanvasTranslator
:
:
NotifyDeviceChanged
(
)
{
if
(
mRemoteTextureOwner
)
{
mRemoteTextureOwner
-
>
NotifyContextLost
(
)
;
mRemoteTextureOwner
-
>
ClearRecycledTextures
(
)
;
}
mDeviceResetInProgress
=
true
;
gfx
:
:
CanvasRenderThread
:
:
Dispatch
(
NewRunnableMethod
(
"
CanvasTranslator
:
:
SendNotifyDeviceChanged
"
this
&
CanvasTranslator
:
:
SendNotifyDeviceChanged
)
)
;
}
void
CanvasTranslator
:
:
NotifyDeviceReset
(
const
RemoteTextureOwnerIdSet
&
aIds
)
{
if
(
aIds
.
empty
(
)
)
{
return
;
}
if
(
mRemoteTextureOwner
)
{
mRemoteTextureOwner
-
>
NotifyContextLost
(
&
aIds
)
;
}
nsTArray
<
RemoteTextureOwnerId
>
idArray
(
aIds
.
size
(
)
)
;
for
(
const
auto
&
id
:
aIds
)
{
idArray
.
AppendElement
(
id
)
;
}
gfx
:
:
CanvasRenderThread
:
:
Dispatch
(
NewRunnableMethod
<
nsTArray
<
RemoteTextureOwnerId
>
&
&
>
(
"
CanvasTranslator
:
:
SendNotifyDeviceReset
"
this
&
CanvasTranslator
:
:
SendNotifyDeviceReset
std
:
:
move
(
idArray
)
)
)
;
}
gfx
:
:
DrawTargetWebgl
*
CanvasTranslator
:
:
GetDrawTargetWebgl
(
const
RemoteTextureOwnerId
aTextureOwnerId
bool
aCheckForFallback
)
const
{
auto
result
=
mTextureInfo
.
find
(
aTextureOwnerId
)
;
if
(
result
!
=
mTextureInfo
.
end
(
)
)
{
return
result
-
>
second
.
GetDrawTargetWebgl
(
aCheckForFallback
)
;
}
return
nullptr
;
}
void
CanvasTranslator
:
:
NotifyRequiresRefresh
(
const
RemoteTextureOwnerId
aTextureOwnerId
bool
aDispatch
)
{
if
(
aDispatch
)
{
auto
&
info
=
mTextureInfo
[
aTextureOwnerId
]
;
if
(
!
info
.
mNotifiedRequiresRefresh
)
{
info
.
mNotifiedRequiresRefresh
=
true
;
DispatchToTaskQueue
(
NewRunnableMethod
<
RemoteTextureOwnerId
bool
>
(
"
CanvasTranslator
:
:
NotifyRequiresRefresh
"
this
&
CanvasTranslator
:
:
NotifyRequiresRefresh
aTextureOwnerId
false
)
)
;
}
return
;
}
if
(
mTextureInfo
.
find
(
aTextureOwnerId
)
!
=
mTextureInfo
.
end
(
)
)
{
Unused
<
<
SendNotifyRequiresRefresh
(
aTextureOwnerId
)
;
}
}
void
CanvasTranslator
:
:
CacheSnapshotShmem
(
const
RemoteTextureOwnerId
aTextureOwnerId
bool
aDispatch
)
{
if
(
aDispatch
)
{
DispatchToTaskQueue
(
NewRunnableMethod
<
RemoteTextureOwnerId
bool
>
(
"
CanvasTranslator
:
:
CacheSnapshotShmem
"
this
&
CanvasTranslator
:
:
CacheSnapshotShmem
aTextureOwnerId
false
)
)
;
return
;
}
if
(
gfx
:
:
DrawTargetWebgl
*
webgl
=
GetDrawTargetWebgl
(
aTextureOwnerId
)
)
{
if
(
auto
shmemHandle
=
webgl
-
>
TakeShmemHandle
(
)
)
{
mTextureInfo
[
aTextureOwnerId
]
.
mLocked
+
+
;
nsCOMPtr
<
nsIThread
>
thread
=
gfx
:
:
CanvasRenderThread
:
:
GetCanvasRenderThread
(
)
;
RefPtr
<
CanvasTranslator
>
translator
=
this
;
SendSnapshotShmem
(
aTextureOwnerId
std
:
:
move
(
shmemHandle
)
)
-
>
Then
(
thread
__func__
[
=
]
(
bool
)
{
translator
-
>
RemoveTexture
(
aTextureOwnerId
)
;
}
[
=
]
(
ipc
:
:
ResponseRejectReason
)
{
translator
-
>
RemoveTexture
(
aTextureOwnerId
)
;
}
)
;
}
}
}
void
CanvasTranslator
:
:
PrepareShmem
(
const
RemoteTextureOwnerId
aTextureOwnerId
)
{
if
(
gfx
:
:
DrawTargetWebgl
*
webgl
=
GetDrawTargetWebgl
(
aTextureOwnerId
false
)
)
{
if
(
const
auto
&
fallback
=
mTextureInfo
[
aTextureOwnerId
]
.
mTextureData
)
{
if
(
RefPtr
<
gfx
:
:
DrawTarget
>
dt
=
fallback
-
>
BorrowDrawTarget
(
)
)
{
if
(
RefPtr
<
gfx
:
:
SourceSurface
>
snapshot
=
dt
-
>
Snapshot
(
)
)
{
webgl
-
>
CopySurface
(
snapshot
snapshot
-
>
GetRect
(
)
gfx
:
:
IntPoint
(
0
0
)
)
;
}
}
}
else
{
webgl
-
>
PrepareShmem
(
)
;
}
}
}
void
CanvasTranslator
:
:
CacheDataSnapshots
(
)
{
if
(
mSharedContext
)
{
for
(
auto
const
&
entry
:
mTextureInfo
)
{
if
(
gfx
:
:
DrawTargetWebgl
*
webgl
=
entry
.
second
.
GetDrawTargetWebgl
(
)
)
{
webgl
-
>
EnsureDataSnapshot
(
)
;
}
}
}
}
void
CanvasTranslator
:
:
ClearCachedResources
(
)
{
mUsedDataSurfaceForSurfaceDescriptor
=
nullptr
;
mUsedWrapperForSurfaceDescriptor
=
nullptr
;
mUsedSurfaceDescriptorForSurfaceDescriptor
=
Nothing
(
)
;
if
(
mSharedContext
)
{
mSharedContext
-
>
OnMemoryPressure
(
)
;
}
CacheDataSnapshots
(
)
;
}
ipc
:
:
IPCResult
CanvasTranslator
:
:
RecvClearCachedResources
(
)
{
if
(
mDeactivated
)
{
return
IPC_OK
(
)
;
}
if
(
UsePendingCanvasTranslatorEvents
(
)
)
{
MutexAutoLock
lock
(
mCanvasTranslatorEventsLock
)
;
mPendingCanvasTranslatorEvents
.
emplace_back
(
CanvasTranslatorEvent
:
:
ClearCachedResources
(
)
)
;
PostCanvasTranslatorEvents
(
lock
)
;
}
else
{
DispatchToTaskQueue
(
NewRunnableMethod
(
"
CanvasTranslator
:
:
ClearCachedResources
"
this
&
CanvasTranslator
:
:
ClearCachedResources
)
)
;
}
return
IPC_OK
(
)
;
}
void
CanvasTranslator
:
:
DropFreeBuffersWhenDormant
(
)
{
CacheDataSnapshots
(
)
;
}
ipc
:
:
IPCResult
CanvasTranslator
:
:
RecvDropFreeBuffersWhenDormant
(
)
{
if
(
mDeactivated
)
{
return
IPC_OK
(
)
;
}
if
(
UsePendingCanvasTranslatorEvents
(
)
)
{
MutexAutoLock
lock
(
mCanvasTranslatorEventsLock
)
;
mPendingCanvasTranslatorEvents
.
emplace_back
(
CanvasTranslatorEvent
:
:
DropFreeBuffersWhenDormant
(
)
)
;
PostCanvasTranslatorEvents
(
lock
)
;
}
else
{
DispatchToTaskQueue
(
NewRunnableMethod
(
"
CanvasTranslator
:
:
DropFreeBuffersWhenDormant
"
this
&
CanvasTranslator
:
:
DropFreeBuffersWhenDormant
)
)
;
}
return
IPC_OK
(
)
;
}
static
const
OpenMode
kInitMode
=
OpenMode
:
:
OPEN_READ_WRITE
;
already_AddRefed
<
gfx
:
:
DrawTarget
>
CanvasTranslator
:
:
CreateFallbackDrawTarget
(
gfx
:
:
ReferencePtr
aRefPtr
const
RemoteTextureOwnerId
aTextureOwnerId
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
)
{
RefPtr
<
gfx
:
:
DrawTarget
>
dt
;
do
{
UniquePtr
<
TextureData
>
textureData
=
CreateOrRecycleTextureData
(
aSize
aFormat
)
;
if
(
NS_WARN_IF
(
!
textureData
)
)
{
continue
;
}
if
(
NS_WARN_IF
(
!
textureData
-
>
Lock
(
kInitMode
)
)
)
{
gfxCriticalNote
<
<
"
CanvasTranslator
:
:
CreateDrawTarget
lock
failed
"
;
continue
;
}
dt
=
textureData
-
>
BorrowDrawTarget
(
)
;
if
(
NS_WARN_IF
(
!
dt
)
)
{
textureData
-
>
Unlock
(
)
;
continue
;
}
dt
-
>
ClearRect
(
gfx
:
:
Rect
(
dt
-
>
GetRect
(
)
)
)
;
TextureInfo
&
info
=
mTextureInfo
[
aTextureOwnerId
]
;
info
.
mRefPtr
=
aRefPtr
;
info
.
mTextureData
=
std
:
:
move
(
textureData
)
;
info
.
mTextureLockMode
=
kInitMode
;
}
while
(
!
dt
&
&
CheckForFreshCanvasDevice
(
__LINE__
)
)
;
return
dt
.
forget
(
)
;
}
already_AddRefed
<
gfx
:
:
DrawTarget
>
CanvasTranslator
:
:
CreateDrawTarget
(
gfx
:
:
ReferencePtr
aRefPtr
const
RemoteTextureOwnerId
aTextureOwnerId
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
)
{
if
(
!
aTextureOwnerId
.
IsValid
(
)
)
{
#
ifndef
FUZZING_SNAPSHOT
MOZ_DIAGNOSTIC_CRASH
(
"
No
texture
owner
set
"
)
;
#
endif
return
nullptr
;
}
RefPtr
<
gfx
:
:
DrawTarget
>
dt
;
if
(
gfx
:
:
gfxVars
:
:
UseAcceleratedCanvas2D
(
)
)
{
if
(
EnsureSharedContextWebgl
(
)
)
{
mSharedContext
-
>
EnterTlsScope
(
)
;
}
if
(
RefPtr
<
gfx
:
:
DrawTargetWebgl
>
webgl
=
gfx
:
:
DrawTargetWebgl
:
:
Create
(
aSize
aFormat
mSharedContext
)
)
{
webgl
-
>
BeginFrame
(
true
)
;
dt
=
webgl
.
forget
(
)
.
downcast
<
gfx
:
:
DrawTarget
>
(
)
;
if
(
dt
)
{
TextureInfo
&
info
=
mTextureInfo
[
aTextureOwnerId
]
;
info
.
mRefPtr
=
aRefPtr
;
info
.
mDrawTarget
=
dt
;
info
.
mTextureLockMode
=
kInitMode
;
CacheSnapshotShmem
(
aTextureOwnerId
)
;
}
}
if
(
!
dt
)
{
NotifyRequiresRefresh
(
aTextureOwnerId
)
;
}
}
if
(
!
dt
)
{
dt
=
CreateFallbackDrawTarget
(
aRefPtr
aTextureOwnerId
aSize
aFormat
)
;
}
AddDrawTarget
(
aRefPtr
dt
)
;
return
dt
.
forget
(
)
;
}
already_AddRefed
<
gfx
:
:
DrawTarget
>
CanvasTranslator
:
:
CreateDrawTarget
(
gfx
:
:
ReferencePtr
aRefPtr
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
)
{
#
ifndef
FUZZING_SNAPSHOT
MOZ_DIAGNOSTIC_CRASH
(
"
Unexpected
CreateDrawTarget
call
!
"
)
;
#
endif
return
nullptr
;
}
void
CanvasTranslator
:
:
NotifyTextureDestruction
(
const
RemoteTextureOwnerId
aTextureOwnerId
)
{
MOZ_ASSERT
(
gfx
:
:
CanvasRenderThread
:
:
IsInCanvasRenderThread
(
)
)
;
if
(
mIPDLClosed
)
{
return
;
}
Unused
<
<
SendNotifyTextureDestruction
(
aTextureOwnerId
)
;
}
void
CanvasTranslator
:
:
RemoveTexture
(
const
RemoteTextureOwnerId
aTextureOwnerId
RemoteTextureTxnType
aTxnType
RemoteTextureTxnId
aTxnId
)
{
auto
result
=
mTextureInfo
.
find
(
aTextureOwnerId
)
;
if
(
result
=
=
mTextureInfo
.
end
(
)
)
{
return
;
}
auto
&
info
=
result
-
>
second
;
if
(
mRemoteTextureOwner
&
&
aTxnType
&
&
aTxnId
)
{
mRemoteTextureOwner
-
>
WaitForTxn
(
aTextureOwnerId
aTxnType
aTxnId
)
;
}
if
(
-
-
info
.
mLocked
>
0
)
{
return
;
}
if
(
info
.
mTextureData
)
{
info
.
mTextureData
-
>
Unlock
(
)
;
}
if
(
mRemoteTextureOwner
)
{
if
(
aTextureOwnerId
.
IsValid
(
)
)
{
mRemoteTextureOwner
-
>
UnregisterTextureOwner
(
aTextureOwnerId
)
;
}
}
gfx
:
:
CanvasRenderThread
:
:
Dispatch
(
NewRunnableMethod
<
RemoteTextureOwnerId
>
(
"
CanvasTranslator
:
:
NotifyTextureDestruction
"
this
&
CanvasTranslator
:
:
NotifyTextureDestruction
aTextureOwnerId
)
)
;
mTextureInfo
.
erase
(
result
)
;
}
bool
CanvasTranslator
:
:
LockTexture
(
const
RemoteTextureOwnerId
aTextureOwnerId
OpenMode
aMode
bool
aInvalidContents
)
{
if
(
aMode
=
=
OpenMode
:
:
OPEN_NONE
)
{
return
false
;
}
auto
result
=
mTextureInfo
.
find
(
aTextureOwnerId
)
;
if
(
result
=
=
mTextureInfo
.
end
(
)
)
{
return
false
;
}
auto
&
info
=
result
-
>
second
;
if
(
info
.
mTextureLockMode
!
=
OpenMode
:
:
OPEN_NONE
)
{
return
(
info
.
mTextureLockMode
&
aMode
)
=
=
aMode
;
}
if
(
gfx
:
:
DrawTargetWebgl
*
webgl
=
info
.
GetDrawTargetWebgl
(
)
)
{
if
(
aMode
&
OpenMode
:
:
OPEN_WRITE
)
{
webgl
-
>
BeginFrame
(
aInvalidContents
)
;
}
}
info
.
mTextureLockMode
=
aMode
;
return
true
;
}
bool
CanvasTranslator
:
:
UnlockTexture
(
const
RemoteTextureOwnerId
aTextureOwnerId
)
{
auto
result
=
mTextureInfo
.
find
(
aTextureOwnerId
)
;
if
(
result
=
=
mTextureInfo
.
end
(
)
)
{
return
false
;
}
auto
&
info
=
result
-
>
second
;
if
(
info
.
mTextureLockMode
=
=
OpenMode
:
:
OPEN_NONE
)
{
return
false
;
}
if
(
gfx
:
:
DrawTargetWebgl
*
webgl
=
info
.
GetDrawTargetWebgl
(
)
)
{
if
(
info
.
mTextureLockMode
&
OpenMode
:
:
OPEN_WRITE
)
{
webgl
-
>
EndFrame
(
)
;
if
(
webgl
-
>
RequiresRefresh
(
)
)
{
NotifyRequiresRefresh
(
aTextureOwnerId
)
;
}
}
}
info
.
mTextureLockMode
=
OpenMode
:
:
OPEN_NONE
;
return
true
;
}
bool
CanvasTranslator
:
:
PresentTexture
(
const
RemoteTextureOwnerId
aTextureOwnerId
RemoteTextureId
aId
)
{
AUTO_PROFILER_MARKER_TEXT
(
"
CanvasTranslator
"
GRAPHICS
{
}
"
CanvasTranslator
:
:
PresentTexture
"
_ns
)
;
auto
result
=
mTextureInfo
.
find
(
aTextureOwnerId
)
;
if
(
result
=
=
mTextureInfo
.
end
(
)
)
{
return
false
;
}
auto
&
info
=
result
-
>
second
;
if
(
gfx
:
:
DrawTargetWebgl
*
webgl
=
info
.
GetDrawTargetWebgl
(
)
)
{
EnsureRemoteTextureOwner
(
aTextureOwnerId
)
;
if
(
webgl
-
>
CopyToSwapChain
(
mWebglTextureType
aId
aTextureOwnerId
mRemoteTextureOwner
)
)
{
return
true
;
}
if
(
mSharedContext
&
&
mSharedContext
-
>
IsContextLost
(
)
)
{
EnsureSharedContextWebgl
(
)
;
}
else
{
webgl
-
>
EnsureDataSnapshot
(
)
;
if
(
!
TryDrawTargetWebglFallback
(
aTextureOwnerId
webgl
)
)
{
RemoteTextureOwnerIdSet
lost
=
{
aTextureOwnerId
}
;
NotifyDeviceReset
(
lost
)
;
}
}
}
if
(
TextureData
*
data
=
info
.
mTextureData
.
get
(
)
)
{
PushRemoteTexture
(
aTextureOwnerId
data
aId
aTextureOwnerId
)
;
}
return
true
;
}
void
CanvasTranslator
:
:
EnsureRemoteTextureOwner
(
RemoteTextureOwnerId
aOwnerId
)
{
if
(
!
mRemoteTextureOwner
)
{
mRemoteTextureOwner
=
new
RemoteTextureOwnerClient
(
mOtherPid
)
;
}
if
(
aOwnerId
.
IsValid
(
)
&
&
!
mRemoteTextureOwner
-
>
IsRegistered
(
aOwnerId
)
)
{
mRemoteTextureOwner
-
>
RegisterTextureOwner
(
aOwnerId
true
)
;
}
}
UniquePtr
<
TextureData
>
CanvasTranslator
:
:
CreateOrRecycleTextureData
(
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
)
{
if
(
mRemoteTextureOwner
)
{
if
(
mTextureType
=
=
TextureType
:
:
Unknown
)
{
return
mRemoteTextureOwner
-
>
CreateOrRecycleBufferTextureData
(
aSize
aFormat
)
;
}
if
(
UniquePtr
<
TextureData
>
data
=
mRemoteTextureOwner
-
>
GetRecycledTextureData
(
aSize
aFormat
mTextureType
)
)
{
return
data
;
}
}
return
CreateTextureData
(
aSize
aFormat
false
)
;
}
bool
CanvasTranslator
:
:
PushRemoteTexture
(
const
RemoteTextureOwnerId
aTextureOwnerId
TextureData
*
aData
RemoteTextureId
aId
RemoteTextureOwnerId
aOwnerId
)
{
EnsureRemoteTextureOwner
(
aOwnerId
)
;
UniquePtr
<
TextureData
>
dstData
;
if
(
!
mDeviceResetInProgress
)
{
TextureData
:
:
Info
info
;
aData
-
>
FillInfo
(
info
)
;
dstData
=
CreateOrRecycleTextureData
(
info
.
size
info
.
format
)
;
}
bool
success
=
false
;
if
(
dstData
)
{
if
(
dstData
-
>
Lock
(
OpenMode
:
:
OPEN_WRITE
)
)
{
if
(
RefPtr
<
gfx
:
:
DrawTarget
>
dstDT
=
dstData
-
>
BorrowDrawTarget
(
)
)
{
if
(
RefPtr
<
gfx
:
:
DrawTarget
>
srcDT
=
aData
-
>
BorrowDrawTarget
(
)
)
{
if
(
RefPtr
<
gfx
:
:
SourceSurface
>
snapshot
=
srcDT
-
>
Snapshot
(
)
)
{
dstDT
-
>
CopySurface
(
snapshot
snapshot
-
>
GetRect
(
)
gfx
:
:
IntPoint
(
0
0
)
)
;
dstDT
-
>
Flush
(
)
;
success
=
true
;
}
}
}
dstData
-
>
Unlock
(
)
;
}
else
{
gfxCriticalNote
<
<
"
CanvasTranslator
:
:
PushRemoteTexture
dst
lock
failed
"
;
}
}
if
(
success
)
{
mRemoteTextureOwner
-
>
PushTexture
(
aId
aOwnerId
std
:
:
move
(
dstData
)
)
;
}
else
{
mRemoteTextureOwner
-
>
PushDummyTexture
(
aId
aOwnerId
)
;
}
return
success
;
}
void
CanvasTranslator
:
:
ClearTextureInfo
(
)
{
MOZ_ASSERT
(
mIPDLClosed
)
;
mUsedDataSurfaceForSurfaceDescriptor
=
nullptr
;
mUsedWrapperForSurfaceDescriptor
=
nullptr
;
mUsedSurfaceDescriptorForSurfaceDescriptor
=
Nothing
(
)
;
for
(
auto
const
&
entry
:
mTextureInfo
)
{
if
(
entry
.
second
.
mTextureData
)
{
entry
.
second
.
mTextureData
-
>
Unlock
(
)
;
}
}
mTextureInfo
.
clear
(
)
;
mDrawTargets
.
Clear
(
)
;
mSharedContext
=
nullptr
;
if
(
sSharedContext
&
&
sSharedContext
-
>
hasOneRef
(
)
)
{
sSharedContext
-
>
ClearCaches
(
)
;
}
mBaseDT
=
nullptr
;
if
(
mReferenceTextureData
)
{
mReferenceTextureData
-
>
Unlock
(
)
;
}
if
(
mRemoteTextureOwner
)
{
mRemoteTextureOwner
-
>
UnregisterAllTextureOwners
(
)
;
mRemoteTextureOwner
=
nullptr
;
}
if
(
mTranslationTaskQueue
)
{
gfx
:
:
CanvasRenderThread
:
:
FinishShutdownWorkerTaskQueue
(
mTranslationTaskQueue
)
;
}
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
CanvasTranslator
:
:
LookupExternalSurface
(
uint64_t
aKey
)
{
return
mSharedSurfacesHolder
-
>
Get
(
wr
:
:
ToExternalImageId
(
aKey
)
)
;
}
static
bool
SDIsSupportedRemoteDecoder
(
const
SurfaceDescriptor
&
sd
)
{
if
(
sd
.
type
(
)
!
=
SurfaceDescriptor
:
:
TSurfaceDescriptorGPUVideo
)
{
return
false
;
}
const
auto
&
sdv
=
sd
.
get_SurfaceDescriptorGPUVideo
(
)
;
const
auto
&
sdvType
=
sdv
.
type
(
)
;
if
(
sdvType
!
=
SurfaceDescriptorGPUVideo
:
:
TSurfaceDescriptorRemoteDecoder
)
{
return
false
;
}
const
auto
&
sdrd
=
sdv
.
get_SurfaceDescriptorRemoteDecoder
(
)
;
const
auto
&
subdesc
=
sdrd
.
subdesc
(
)
;
const
auto
&
subdescType
=
subdesc
.
type
(
)
;
if
(
subdescType
=
=
RemoteDecoderVideoSubDescriptor
:
:
Tnull_t
|
|
subdescType
=
=
RemoteDecoderVideoSubDescriptor
:
:
TSurfaceDescriptorMacIOSurface
|
|
subdescType
=
=
RemoteDecoderVideoSubDescriptor
:
:
TSurfaceDescriptorD3D10
)
{
return
true
;
}
return
false
;
}
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
CanvasTranslator
:
:
MaybeRecycleDataSurfaceForSurfaceDescriptor
(
TextureHost
*
aTextureHost
const
SurfaceDescriptorRemoteDecoder
&
aSurfaceDescriptor
)
{
if
(
!
StaticPrefs
:
:
gfx_canvas_remote_recycle_used_data_surface
(
)
)
{
return
nullptr
;
}
auto
&
usedSurf
=
mUsedDataSurfaceForSurfaceDescriptor
;
auto
&
usedWrapper
=
mUsedWrapperForSurfaceDescriptor
;
auto
&
usedDescriptor
=
mUsedSurfaceDescriptorForSurfaceDescriptor
;
if
(
usedDescriptor
.
isSome
(
)
&
&
usedDescriptor
.
ref
(
)
=
=
aSurfaceDescriptor
)
{
MOZ_ASSERT
(
usedSurf
)
;
MOZ_ASSERT
(
usedWrapper
)
;
MOZ_ASSERT
(
aTextureHost
-
>
GetSize
(
)
=
=
usedSurf
-
>
GetSize
(
)
)
;
return
do_AddRef
(
usedWrapper
)
;
}
usedWrapper
=
nullptr
;
usedDescriptor
=
Some
(
aSurfaceDescriptor
)
;
bool
isYuvVideo
=
false
;
if
(
aTextureHost
-
>
AsMacIOSurfaceTextureHost
(
)
)
{
if
(
aTextureHost
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
NV12
|
|
aTextureHost
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
YUY2
)
{
isYuvVideo
=
true
;
}
}
else
if
(
aTextureHost
-
>
GetFormat
(
)
=
=
gfx
:
:
SurfaceFormat
:
:
YUV420
)
{
isYuvVideo
=
true
;
}
if
(
isYuvVideo
&
&
usedSurf
&
&
usedSurf
-
>
refCount
(
)
=
=
1
&
&
usedSurf
-
>
GetFormat
(
)
=
=
gfx
:
:
SurfaceFormat
:
:
B8G8R8X8
&
&
aTextureHost
-
>
GetSize
(
)
=
=
usedSurf
-
>
GetSize
(
)
)
{
usedSurf
=
aTextureHost
-
>
GetAsSurface
(
usedSurf
)
;
usedWrapper
=
new
gfx
:
:
DataSourceSurfaceWrapper
(
mUsedDataSurfaceForSurfaceDescriptor
)
;
return
do_AddRef
(
usedWrapper
)
;
}
usedSurf
=
aTextureHost
-
>
GetAsSurface
(
nullptr
)
;
usedWrapper
=
new
gfx
:
:
DataSourceSurfaceWrapper
(
mUsedDataSurfaceForSurfaceDescriptor
)
;
return
do_AddRef
(
usedWrapper
)
;
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
CanvasTranslator
:
:
LookupSourceSurfaceFromSurfaceDescriptor
(
const
SurfaceDescriptor
&
aDesc
)
{
if
(
!
SDIsSupportedRemoteDecoder
(
aDesc
)
)
{
return
nullptr
;
}
const
auto
&
sdrd
=
aDesc
.
get_SurfaceDescriptorGPUVideo
(
)
.
get_SurfaceDescriptorRemoteDecoder
(
)
;
const
auto
&
subdesc
=
sdrd
.
subdesc
(
)
;
const
auto
&
subdescType
=
subdesc
.
type
(
)
;
RefPtr
<
VideoBridgeParent
>
parent
=
VideoBridgeParent
:
:
GetSingleton
(
sdrd
.
source
(
)
)
;
if
(
!
parent
)
{
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
to
be
called
"
)
;
gfxCriticalNote
<
<
"
TexUnpackSurface
failed
to
get
VideoBridgeParent
"
;
return
nullptr
;
}
RefPtr
<
TextureHost
>
texture
=
parent
-
>
LookupTexture
(
mContentId
sdrd
.
handle
(
)
)
;
if
(
!
texture
)
{
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
to
be
called
"
)
;
gfxCriticalNote
<
<
"
TexUnpackSurface
failed
to
get
TextureHost
"
;
return
nullptr
;
}
#
if
defined
(
XP_WIN
)
if
(
subdescType
=
=
RemoteDecoderVideoSubDescriptor
:
:
TSurfaceDescriptorD3D10
)
{
auto
*
textureHostD3D11
=
texture
-
>
AsDXGITextureHostD3D11
(
)
;
if
(
!
textureHostD3D11
)
{
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
to
be
called
"
)
;
return
nullptr
;
}
auto
&
usedSurf
=
mUsedDataSurfaceForSurfaceDescriptor
;
auto
&
usedDescriptor
=
mUsedSurfaceDescriptorForSurfaceDescriptor
;
usedSurf
=
textureHostD3D11
-
>
GetAsSurfaceWithDevice
(
mDevice
mVideoProcessorD3D11
)
;
if
(
!
usedSurf
)
{
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
to
be
called
"
)
;
usedDescriptor
=
Nothing
(
)
;
return
nullptr
;
}
usedDescriptor
=
Some
(
sdrd
)
;
return
do_AddRef
(
usedSurf
)
;
}
#
endif
if
(
subdescType
=
=
RemoteDecoderVideoSubDescriptor
:
:
TSurfaceDescriptorMacIOSurface
)
{
MOZ_ASSERT
(
texture
-
>
AsMacIOSurfaceTextureHost
(
)
)
;
RefPtr
<
gfx
:
:
DataSourceSurface
>
surf
=
MaybeRecycleDataSurfaceForSurfaceDescriptor
(
texture
sdrd
)
;
return
surf
.
forget
(
)
;
}
if
(
subdescType
=
=
RemoteDecoderVideoSubDescriptor
:
:
Tnull_t
)
{
RefPtr
<
gfx
:
:
DataSourceSurface
>
surf
=
MaybeRecycleDataSurfaceForSurfaceDescriptor
(
texture
sdrd
)
;
return
surf
.
forget
(
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
to
be
called
"
)
;
return
nullptr
;
}
void
CanvasTranslator
:
:
CheckpointReached
(
)
{
CheckAndSignalWriter
(
)
;
}
void
CanvasTranslator
:
:
PauseTranslation
(
)
{
mHeader
-
>
readerState
=
State
:
:
Paused
;
}
void
CanvasTranslator
:
:
AwaitTranslationSync
(
uint64_t
aSyncId
)
{
if
(
NS_WARN_IF
(
!
UsePendingCanvasTranslatorEvents
(
)
)
|
|
NS_WARN_IF
(
!
IsInTaskQueue
(
)
)
|
|
NS_WARN_IF
(
mAwaitSyncId
>
=
aSyncId
)
)
{
return
;
}
mAwaitSyncId
=
aSyncId
;
}
void
CanvasTranslator
:
:
SyncTranslation
(
uint64_t
aSyncId
)
{
if
(
NS_WARN_IF
(
!
IsInTaskQueue
(
)
)
|
|
NS_WARN_IF
(
aSyncId
<
=
mLastSyncId
)
)
{
return
;
}
bool
wasPaused
=
PauseUntilSync
(
)
;
mLastSyncId
=
aSyncId
;
if
(
wasPaused
&
&
!
PauseUntilSync
(
)
)
{
HandleCanvasTranslatorEvents
(
)
;
}
}
mozilla
:
:
ipc
:
:
IPCResult
CanvasTranslator
:
:
RecvSnapshotExternalCanvas
(
uint64_t
aSyncId
uint32_t
aManagerId
ActorId
aCanvasId
)
{
if
(
NS_WARN_IF
(
!
IsInTaskQueue
(
)
)
)
{
return
IPC_FAIL
(
this
"
RecvSnapshotExternalCanvas
used
outside
of
task
queue
.
"
)
;
}
if
(
NS_WARN_IF
(
aSyncId
<
=
mLastSyncId
)
)
{
return
IPC_FAIL
(
this
"
RecvSnapShotExternalCanvas
received
too
late
.
"
)
;
}
ExternalSnapshot
snapshot
;
if
(
auto
*
actor
=
gfx
:
:
CanvasManagerParent
:
:
GetCanvasActor
(
mContentId
aManagerId
aCanvasId
)
)
{
switch
(
actor
-
>
GetProtocolId
(
)
)
{
case
ProtocolId
:
:
PWebGLMsgStart
:
if
(
auto
*
hostContext
=
static_cast
<
dom
:
:
WebGLParent
*
>
(
actor
)
-
>
GetHostWebGLContext
(
)
)
{
if
(
auto
*
webgl
=
hostContext
-
>
GetWebGLContext
(
)
)
{
if
(
mWebglTextureType
!
=
TextureType
:
:
Unknown
)
{
snapshot
.
mSharedSurface
=
webgl
-
>
GetBackBufferSnapshotSharedSurface
(
mWebglTextureType
true
true
true
)
;
if
(
snapshot
.
mSharedSurface
)
{
snapshot
.
mWebgl
=
webgl
;
snapshot
.
mDescriptor
=
snapshot
.
mSharedSurface
-
>
ToSurfaceDescriptor
(
)
;
}
}
if
(
!
snapshot
.
mDescriptor
)
{
snapshot
.
mData
=
webgl
-
>
GetBackBufferSnapshot
(
true
)
;
}
}
}
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
protocol
"
)
;
break
;
}
}
if
(
!
snapshot
.
mDescriptor
&
&
!
snapshot
.
mData
)
{
SyncTranslation
(
aSyncId
)
;
return
IPC_FAIL
(
this
"
SnapshotExternalCanvas
failed
to
get
surface
.
"
)
;
}
mExternalSnapshots
.
insert
(
{
aSyncId
std
:
:
move
(
snapshot
)
}
)
;
SyncTranslation
(
aSyncId
)
;
return
IPC_OK
(
)
;
}
bool
CanvasTranslator
:
:
ResolveExternalSnapshot
(
uint64_t
aSyncId
ReferencePtr
aRefPtr
const
IntSize
&
aSize
SurfaceFormat
aFormat
DrawTarget
*
aDT
)
{
MOZ_ASSERT
(
IsInTaskQueue
(
)
)
;
uint64_t
prevSyncId
=
mLastSyncId
;
if
(
NS_WARN_IF
(
aSyncId
>
mLastSyncId
)
)
{
SyncTranslation
(
aSyncId
)
;
}
auto
it
=
mExternalSnapshots
.
find
(
aSyncId
)
;
if
(
it
=
=
mExternalSnapshots
.
end
(
)
)
{
if
(
aSyncId
>
prevSyncId
)
{
gfxCriticalNoteOnce
<
<
"
External
canvas
snapshot
resolved
before
creation
.
"
;
}
else
{
gfxCriticalNoteOnce
<
<
"
Exernal
canvas
snapshot
already
resolved
.
"
;
}
return
false
;
}
ExternalSnapshot
snapshot
=
std
:
:
move
(
it
-
>
second
)
;
mExternalSnapshots
.
erase
(
it
)
;
RefPtr
<
gfx
:
:
SourceSurface
>
resolved
;
if
(
snapshot
.
mSharedSurface
)
{
snapshot
.
mSharedSurface
-
>
BeginRead
(
)
;
}
if
(
snapshot
.
mDescriptor
)
{
if
(
aDT
)
{
resolved
=
aDT
-
>
ImportSurfaceDescriptor
(
*
snapshot
.
mDescriptor
aSize
aFormat
)
;
}
if
(
!
resolved
&
&
gfx
:
:
gfxVars
:
:
UseAcceleratedCanvas2D
(
)
&
&
EnsureSharedContextWebgl
(
)
)
{
resolved
=
mSharedContext
-
>
ImportSurfaceDescriptor
(
*
snapshot
.
mDescriptor
aSize
aFormat
)
;
}
}
if
(
snapshot
.
mSharedSurface
)
{
snapshot
.
mSharedSurface
-
>
EndRead
(
)
;
if
(
snapshot
.
mWebgl
)
{
snapshot
.
mWebgl
-
>
RecycleSnapshotSharedSurface
(
snapshot
.
mSharedSurface
)
;
}
}
if
(
!
resolved
)
{
resolved
=
snapshot
.
mData
;
}
if
(
resolved
)
{
AddSourceSurface
(
aRefPtr
resolved
)
;
return
true
;
}
return
false
;
}
already_AddRefed
<
gfx
:
:
GradientStops
>
CanvasTranslator
:
:
GetOrCreateGradientStops
(
gfx
:
:
DrawTarget
*
aDrawTarget
gfx
:
:
GradientStop
*
aRawStops
uint32_t
aNumStops
gfx
:
:
ExtendMode
aExtendMode
)
{
MOZ_ASSERT
(
aDrawTarget
)
;
nsTArray
<
gfx
:
:
GradientStop
>
rawStopArray
(
aRawStops
aNumStops
)
;
return
gfx
:
:
gfxGradientCache
:
:
GetOrCreateGradientStops
(
aDrawTarget
rawStopArray
aExtendMode
)
;
}
gfx
:
:
DataSourceSurface
*
CanvasTranslator
:
:
LookupDataSurface
(
gfx
:
:
ReferencePtr
aRefPtr
)
{
return
mDataSurfaces
.
GetWeak
(
aRefPtr
)
;
}
void
CanvasTranslator
:
:
AddDataSurface
(
gfx
:
:
ReferencePtr
aRefPtr
RefPtr
<
gfx
:
:
DataSourceSurface
>
&
&
aSurface
)
{
mDataSurfaces
.
InsertOrUpdate
(
aRefPtr
std
:
:
move
(
aSurface
)
)
;
}
void
CanvasTranslator
:
:
RemoveDataSurface
(
gfx
:
:
ReferencePtr
aRefPtr
)
{
mDataSurfaces
.
Remove
(
aRefPtr
)
;
}
void
CanvasTranslator
:
:
SetPreparedMap
(
gfx
:
:
ReferencePtr
aSurface
UniquePtr
<
gfx
:
:
DataSourceSurface
:
:
ScopedMap
>
aMap
)
{
mMappedSurface
=
aSurface
;
mPreparedMap
=
std
:
:
move
(
aMap
)
;
}
UniquePtr
<
gfx
:
:
DataSourceSurface
:
:
ScopedMap
>
CanvasTranslator
:
:
GetPreparedMap
(
gfx
:
:
ReferencePtr
aSurface
)
{
if
(
!
mPreparedMap
)
{
return
nullptr
;
}
MOZ_RELEASE_ASSERT
(
mMappedSurface
=
=
aSurface
"
aSurface
must
match
previously
stored
surface
.
"
)
;
mMappedSurface
=
nullptr
;
return
std
:
:
move
(
mPreparedMap
)
;
}
}
}
