#
include
"
VideoBridgeParent
.
h
"
#
include
"
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
mozilla
:
:
ipc
;
using
namespace
mozilla
:
:
gfx
;
static
VideoBridgeParent
*
sVideoBridgeSingleton
;
VideoBridgeParent
:
:
VideoBridgeParent
(
)
:
mClosed
(
false
)
{
mSelfRef
=
this
;
sVideoBridgeSingleton
=
this
;
mCompositorThreadRef
=
CompositorThreadHolder
:
:
GetSingleton
(
)
;
}
VideoBridgeParent
:
:
~
VideoBridgeParent
(
)
{
sVideoBridgeSingleton
=
nullptr
;
}
void
VideoBridgeParent
:
:
Open
(
Endpoint
<
PVideoBridgeParent
>
&
&
aEndpoint
)
{
RefPtr
<
VideoBridgeParent
>
parent
=
new
VideoBridgeParent
(
)
;
if
(
!
aEndpoint
.
Bind
(
parent
)
)
{
MOZ_CRASH
(
"
Failed
to
bind
RemoteDecoderManagerParent
to
endpoint
"
)
;
}
}
VideoBridgeParent
*
VideoBridgeParent
:
:
GetSingleton
(
)
{
return
sVideoBridgeSingleton
;
}
TextureHost
*
VideoBridgeParent
:
:
LookupTexture
(
uint64_t
aSerial
)
{
return
TextureHost
:
:
AsTextureHost
(
mTextureMap
[
aSerial
]
)
;
}
void
VideoBridgeParent
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
mClosed
=
true
;
}
void
VideoBridgeParent
:
:
ActorDealloc
(
)
{
mCompositorThreadRef
=
nullptr
;
mSelfRef
=
nullptr
;
}
PTextureParent
*
VideoBridgeParent
:
:
AllocPTextureParent
(
const
SurfaceDescriptor
&
aSharedData
const
ReadLockDescriptor
&
aReadLock
const
LayersBackend
&
aLayersBackend
const
TextureFlags
&
aFlags
const
uint64_t
&
aSerial
)
{
PTextureParent
*
parent
=
TextureHost
:
:
CreateIPDLActor
(
this
aSharedData
aReadLock
aLayersBackend
aFlags
aSerial
Nothing
(
)
)
;
if
(
!
parent
)
{
return
nullptr
;
}
mTextureMap
[
aSerial
]
=
parent
;
return
parent
;
}
bool
VideoBridgeParent
:
:
DeallocPTextureParent
(
PTextureParent
*
actor
)
{
mTextureMap
.
erase
(
TextureHost
:
:
GetTextureSerial
(
actor
)
)
;
return
TextureHost
:
:
DestroyIPDLActor
(
actor
)
;
}
void
VideoBridgeParent
:
:
SendAsyncMessage
(
const
InfallibleTArray
<
AsyncParentMessageData
>
&
aMessage
)
{
MOZ_ASSERT
(
false
"
AsyncMessages
not
supported
"
)
;
}
bool
VideoBridgeParent
:
:
AllocShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
if
(
mClosed
)
{
return
false
;
}
return
PVideoBridgeParent
:
:
AllocShmem
(
aSize
aType
aShmem
)
;
}
bool
VideoBridgeParent
:
:
AllocUnsafeShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
if
(
mClosed
)
{
return
false
;
}
return
PVideoBridgeParent
:
:
AllocUnsafeShmem
(
aSize
aType
aShmem
)
;
}
void
VideoBridgeParent
:
:
DeallocShmem
(
ipc
:
:
Shmem
&
aShmem
)
{
if
(
mClosed
)
{
return
;
}
PVideoBridgeParent
:
:
DeallocShmem
(
aShmem
)
;
}
bool
VideoBridgeParent
:
:
IsSameProcess
(
)
const
{
return
OtherPid
(
)
=
=
base
:
:
GetCurrentProcId
(
)
;
}
void
VideoBridgeParent
:
:
NotifyNotUsed
(
PTextureParent
*
aTexture
uint64_t
aTransactionId
)
{
}
}
}
