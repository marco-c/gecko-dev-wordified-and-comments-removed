#
ifndef
mozilla_layers_CanvasThread_h
#
define
mozilla_layers_CanvasThread_h
#
include
"
base
/
thread
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsIThreadPool
.
h
"
namespace
mozilla
{
namespace
layers
{
class
CanvasThreadHolder
final
{
NS_INLINE_DECL_REFCOUNTING
(
CanvasThreadHolder
)
public
:
static
already_AddRefed
<
CanvasThreadHolder
>
EnsureCanvasThread
(
)
;
static
void
ReleaseOnCompositorThread
(
already_AddRefed
<
CanvasThreadHolder
>
aCanvasThreadHolder
)
;
static
bool
IsInCanvasThread
(
)
;
static
bool
IsInCanvasWorker
(
)
;
static
bool
IsInCanvasThreadOrWorker
(
)
;
static
void
MaybeDispatchToCanvasThread
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
;
void
DispatchToCanvasThread
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
;
already_AddRefed
<
TaskQueue
>
CreateWorkerTaskQueue
(
)
;
private
:
static
void
StaticRelease
(
already_AddRefed
<
CanvasThreadHolder
>
aCanvasThreadHolder
)
;
static
StaticDataMutex
<
StaticRefPtr
<
CanvasThreadHolder
>
>
sCanvasThreadHolder
;
CanvasThreadHolder
(
UniquePtr
<
base
:
:
Thread
>
aCanvasThread
already_AddRefed
<
nsIThreadPool
>
aCanvasWorkers
)
;
~
CanvasThreadHolder
(
)
;
UniquePtr
<
base
:
:
Thread
>
mCanvasThread
;
RefPtr
<
nsIThreadPool
>
mCanvasWorkers
;
RefPtr
<
CompositorThreadHolder
>
mCompositorThreadKeepAlive
;
}
;
}
}
#
endif
