#
include
"
ISurfaceAllocator
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
mozilla
/
layers
/
TextureForwarder
.
h
"
#
include
"
mozilla
/
layers
/
CompositableForwarder
.
h
"
namespace
mozilla
{
namespace
layers
{
NS_IMPL_ISUPPORTS
(
GfxMemoryImageReporter
nsIMemoryReporter
)
mozilla
:
:
Atomic
<
ptrdiff_t
>
GfxMemoryImageReporter
:
:
sAmount
(
0
)
;
uint32_t
CompositableForwarder
:
:
GetMaxFileDescriptorsPerMessage
(
)
{
#
if
defined
(
OS_POSIX
)
static
const
uint32_t
kMaxFileDescriptors
=
FileDescriptorSet
:
:
MAX_DESCRIPTORS_PER_MESSAGE
;
#
else
static
const
uint32_t
kMaxFileDescriptors
=
250
;
#
endif
return
kMaxFileDescriptors
;
}
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
OptimalShmemType
(
)
{
return
ipc
:
:
SharedMemory
:
:
SharedMemoryType
:
:
TYPE_BASIC
;
}
void
HostIPCAllocator
:
:
SendPendingAsyncMessages
(
)
{
if
(
mPendingAsyncMessage
.
empty
(
)
)
{
return
;
}
#
if
defined
(
OS_POSIX
)
static
const
uint32_t
kMaxMessageNumber
=
FileDescriptorSet
:
:
MAX_DESCRIPTORS_PER_MESSAGE
;
#
else
static
const
uint32_t
kMaxMessageNumber
=
250
;
#
endif
InfallibleTArray
<
AsyncParentMessageData
>
messages
;
messages
.
SetCapacity
(
mPendingAsyncMessage
.
size
(
)
)
;
for
(
size_t
i
=
0
;
i
<
mPendingAsyncMessage
.
size
(
)
;
i
+
+
)
{
messages
.
AppendElement
(
mPendingAsyncMessage
[
i
]
)
;
if
(
messages
.
Length
(
)
>
=
kMaxMessageNumber
)
{
SendAsyncMessage
(
messages
)
;
messages
.
Clear
(
)
;
}
}
if
(
messages
.
Length
(
)
>
0
)
{
SendAsyncMessage
(
messages
)
;
}
mPendingAsyncMessage
.
clear
(
)
;
}
const
uint32_t
sShmemPageSize
=
4096
;
#
ifdef
DEBUG
const
uint32_t
sSupportedBlockSize
=
4
;
#
endif
FixedSizeSmallShmemSectionAllocator
:
:
FixedSizeSmallShmemSectionAllocator
(
LayersIPCChannel
*
aShmProvider
)
:
mShmProvider
(
aShmProvider
)
{
MOZ_ASSERT
(
mShmProvider
)
;
}
FixedSizeSmallShmemSectionAllocator
:
:
~
FixedSizeSmallShmemSectionAllocator
(
)
{
ShrinkShmemSectionHeap
(
)
;
}
bool
FixedSizeSmallShmemSectionAllocator
:
:
IPCOpen
(
)
const
{
return
mShmProvider
-
>
IPCOpen
(
)
;
}
bool
FixedSizeSmallShmemSectionAllocator
:
:
AllocShmemSection
(
uint32_t
aSize
ShmemSection
*
aShmemSection
)
{
MOZ_ASSERT
(
aSize
=
=
sSupportedBlockSize
)
;
MOZ_ASSERT
(
aShmemSection
)
;
if
(
!
IPCOpen
(
)
)
{
gfxCriticalError
(
)
<
<
"
Attempt
to
allocate
a
ShmemSection
after
shutdown
.
"
;
return
false
;
}
uint32_t
allocationSize
=
(
aSize
+
sizeof
(
ShmemSectionHeapAllocation
)
)
;
for
(
size_t
i
=
0
;
i
<
mUsedShmems
.
size
(
)
;
i
+
+
)
{
ShmemSectionHeapHeader
*
header
=
mUsedShmems
[
i
]
.
get
<
ShmemSectionHeapHeader
>
(
)
;
if
(
(
header
-
>
mAllocatedBlocks
+
1
)
*
allocationSize
+
sizeof
(
ShmemSectionHeapHeader
)
<
sShmemPageSize
)
{
aShmemSection
-
>
shmem
(
)
=
mUsedShmems
[
i
]
;
MOZ_ASSERT
(
mUsedShmems
[
i
]
.
IsWritable
(
)
)
;
break
;
}
}
if
(
!
aShmemSection
-
>
shmem
(
)
.
IsWritable
(
)
)
{
ipc
:
:
Shmem
tmp
;
if
(
!
mShmProvider
-
>
AllocUnsafeShmem
(
sShmemPageSize
OptimalShmemType
(
)
&
tmp
)
)
{
return
false
;
}
ShmemSectionHeapHeader
*
header
=
tmp
.
get
<
ShmemSectionHeapHeader
>
(
)
;
header
-
>
mTotalBlocks
=
0
;
header
-
>
mAllocatedBlocks
=
0
;
mUsedShmems
.
push_back
(
tmp
)
;
aShmemSection
-
>
shmem
(
)
=
tmp
;
}
MOZ_ASSERT
(
aShmemSection
-
>
shmem
(
)
.
IsWritable
(
)
)
;
ShmemSectionHeapHeader
*
header
=
aShmemSection
-
>
shmem
(
)
.
get
<
ShmemSectionHeapHeader
>
(
)
;
uint8_t
*
heap
=
aShmemSection
-
>
shmem
(
)
.
get
<
uint8_t
>
(
)
+
sizeof
(
ShmemSectionHeapHeader
)
;
ShmemSectionHeapAllocation
*
allocHeader
=
nullptr
;
if
(
header
-
>
mTotalBlocks
>
header
-
>
mAllocatedBlocks
)
{
for
(
size_t
i
=
0
;
i
<
header
-
>
mTotalBlocks
;
i
+
+
)
{
allocHeader
=
reinterpret_cast
<
ShmemSectionHeapAllocation
*
>
(
heap
)
;
if
(
allocHeader
-
>
mStatus
=
=
STATUS_FREED
)
{
break
;
}
heap
+
=
allocationSize
;
}
MOZ_ASSERT
(
allocHeader
&
&
allocHeader
-
>
mStatus
=
=
STATUS_FREED
)
;
MOZ_ASSERT
(
allocHeader
-
>
mSize
=
=
sSupportedBlockSize
)
;
}
else
{
heap
+
=
header
-
>
mTotalBlocks
*
allocationSize
;
header
-
>
mTotalBlocks
+
+
;
allocHeader
=
reinterpret_cast
<
ShmemSectionHeapAllocation
*
>
(
heap
)
;
allocHeader
-
>
mSize
=
aSize
;
}
MOZ_ASSERT
(
allocHeader
)
;
header
-
>
mAllocatedBlocks
+
+
;
allocHeader
-
>
mStatus
=
STATUS_ALLOCATED
;
aShmemSection
-
>
size
(
)
=
aSize
;
aShmemSection
-
>
offset
(
)
=
(
heap
+
sizeof
(
ShmemSectionHeapAllocation
)
)
-
aShmemSection
-
>
shmem
(
)
.
get
<
uint8_t
>
(
)
;
ShrinkShmemSectionHeap
(
)
;
return
true
;
}
void
FixedSizeSmallShmemSectionAllocator
:
:
FreeShmemSection
(
mozilla
:
:
layers
:
:
ShmemSection
&
aShmemSection
)
{
MOZ_ASSERT
(
aShmemSection
.
size
(
)
=
=
sSupportedBlockSize
)
;
MOZ_ASSERT
(
aShmemSection
.
offset
(
)
<
sShmemPageSize
-
sSupportedBlockSize
)
;
if
(
!
aShmemSection
.
shmem
(
)
.
IsWritable
(
)
)
{
return
;
}
ShmemSectionHeapAllocation
*
allocHeader
=
reinterpret_cast
<
ShmemSectionHeapAllocation
*
>
(
aShmemSection
.
shmem
(
)
.
get
<
char
>
(
)
+
aShmemSection
.
offset
(
)
-
sizeof
(
ShmemSectionHeapAllocation
)
)
;
MOZ_ASSERT
(
allocHeader
-
>
mSize
=
=
aShmemSection
.
size
(
)
)
;
DebugOnly
<
bool
>
success
=
allocHeader
-
>
mStatus
.
compareExchange
(
STATUS_ALLOCATED
STATUS_FREED
)
;
MOZ_ASSERT
(
success
)
;
ShmemSectionHeapHeader
*
header
=
aShmemSection
.
shmem
(
)
.
get
<
ShmemSectionHeapHeader
>
(
)
;
header
-
>
mAllocatedBlocks
-
-
;
}
void
FixedSizeSmallShmemSectionAllocator
:
:
DeallocShmemSection
(
mozilla
:
:
layers
:
:
ShmemSection
&
aShmemSection
)
{
if
(
!
IPCOpen
(
)
)
{
gfxCriticalNote
<
<
"
Attempt
to
dealloc
a
ShmemSections
after
shutdown
.
"
;
return
;
}
FreeShmemSection
(
aShmemSection
)
;
ShrinkShmemSectionHeap
(
)
;
}
void
FixedSizeSmallShmemSectionAllocator
:
:
ShrinkShmemSectionHeap
(
)
{
if
(
!
IPCOpen
(
)
)
{
mUsedShmems
.
clear
(
)
;
return
;
}
size_t
i
=
0
;
while
(
i
<
mUsedShmems
.
size
(
)
)
{
ShmemSectionHeapHeader
*
header
=
mUsedShmems
[
i
]
.
get
<
ShmemSectionHeapHeader
>
(
)
;
if
(
header
-
>
mAllocatedBlocks
=
=
0
)
{
mShmProvider
-
>
DeallocShmem
(
mUsedShmems
[
i
]
)
;
if
(
i
<
mUsedShmems
.
size
(
)
-
1
)
{
mUsedShmems
[
i
]
=
mUsedShmems
[
mUsedShmems
.
size
(
)
-
1
]
;
}
mUsedShmems
.
pop_back
(
)
;
}
else
{
i
+
+
;
}
}
}
}
}
