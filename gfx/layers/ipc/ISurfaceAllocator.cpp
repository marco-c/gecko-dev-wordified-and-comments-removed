#
include
"
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
namespace
mozilla
{
namespace
layers
{
NS_IMPL_ISUPPORTS
(
GfxMemoryImageReporter
nsIMemoryReporter
)
mozilla
:
:
Atomic
<
ptrdiff_t
>
GfxMemoryImageReporter
:
:
sAmount
(
0
)
;
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
OptimalShmemType
(
)
{
return
ipc
:
:
SharedMemory
:
:
SharedMemoryType
:
:
TYPE_BASIC
;
}
void
HostIPCAllocator
:
:
SendFenceHandleIfPresent
(
PTextureParent
*
aTexture
)
{
RefPtr
<
TextureHost
>
texture
=
TextureHost
:
:
AsTextureHost
(
aTexture
)
;
if
(
!
texture
)
{
return
;
}
if
(
!
(
texture
-
>
GetFlags
(
)
&
TextureFlags
:
:
RECYCLE
)
&
&
!
texture
-
>
NeedsFenceHandle
(
)
)
{
return
;
}
uint64_t
textureId
=
TextureHost
:
:
GetTextureSerial
(
aTexture
)
;
FenceHandle
fence
=
texture
-
>
GetCompositorReleaseFence
(
)
;
if
(
fence
.
IsValid
(
)
)
{
mPendingAsyncMessage
.
push_back
(
OpDeliverFence
(
textureId
fence
)
)
;
}
fence
=
texture
-
>
GetAndResetReleaseFenceHandle
(
)
;
if
(
fence
.
IsValid
(
)
)
{
mPendingAsyncMessage
.
push_back
(
OpDeliverFence
(
textureId
fence
)
)
;
}
}
void
HostIPCAllocator
:
:
SendPendingAsyncMessages
(
)
{
if
(
mPendingAsyncMessage
.
empty
(
)
)
{
return
;
}
#
if
defined
(
OS_POSIX
)
static
const
uint32_t
kMaxMessageNumber
=
FileDescriptorSet
:
:
MAX_DESCRIPTORS_PER_MESSAGE
;
#
else
static
const
uint32_t
kMaxMessageNumber
=
250
;
#
endif
InfallibleTArray
<
AsyncParentMessageData
>
messages
;
messages
.
SetCapacity
(
mPendingAsyncMessage
.
size
(
)
)
;
for
(
size_t
i
=
0
;
i
<
mPendingAsyncMessage
.
size
(
)
;
i
+
+
)
{
messages
.
AppendElement
(
mPendingAsyncMessage
[
i
]
)
;
if
(
messages
.
Length
(
)
>
=
kMaxMessageNumber
)
{
SendAsyncMessage
(
messages
)
;
messages
.
Clear
(
)
;
}
}
if
(
messages
.
Length
(
)
>
0
)
{
SendAsyncMessage
(
messages
)
;
}
mPendingAsyncMessage
.
clear
(
)
;
}
void
CompositorBridgeParentIPCAllocator
:
:
NotifyNotUsed
(
PTextureParent
*
aTexture
uint64_t
aTransactionId
)
{
RefPtr
<
TextureHost
>
texture
=
TextureHost
:
:
AsTextureHost
(
aTexture
)
;
if
(
!
texture
)
{
return
;
}
if
(
!
(
texture
-
>
GetFlags
(
)
&
TextureFlags
:
:
RECYCLE
)
&
&
!
texture
-
>
NeedsFenceHandle
(
)
)
{
return
;
}
if
(
texture
-
>
GetFlags
(
)
&
TextureFlags
:
:
RECYCLE
)
{
SendFenceHandleIfPresent
(
aTexture
)
;
uint64_t
textureId
=
TextureHost
:
:
GetTextureSerial
(
aTexture
)
;
mPendingAsyncMessage
.
push_back
(
OpNotifyNotUsed
(
textureId
aTransactionId
)
)
;
return
;
}
MOZ_ASSERT
(
ImageBridgeParent
:
:
GetInstance
(
GetChildProcessId
(
)
)
)
;
if
(
ImageBridgeParent
:
:
GetInstance
(
GetChildProcessId
(
)
)
)
{
ImageBridgeParent
:
:
NotifyNotUsedToNonRecycle
(
GetChildProcessId
(
)
aTexture
aTransactionId
)
;
}
else
{
NS_ERROR
(
"
ImageBridgeParent
should
exist
"
)
;
}
if
(
!
IsAboutToSendAsyncMessages
(
)
)
{
SendPendingAsyncMessages
(
)
;
}
}
}
}
