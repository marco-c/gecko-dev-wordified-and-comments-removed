#
ifndef
MOZILLA_GFX_IMAGEBRIDGECHILD_H
#
define
MOZILLA_GFX_IMAGEBRIDGECHILD_H
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemory
.
h
"
#
include
"
mozilla
/
layers
/
AsyncTransactionTracker
.
h
"
#
include
"
mozilla
/
layers
/
CanvasClient
.
h
"
#
include
"
mozilla
/
layers
/
CompositableForwarder
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
PImageBridgeChild
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
class
MessageLoop
;
namespace
base
{
class
Thread
;
}
namespace
mozilla
{
namespace
ipc
{
class
Shmem
;
}
namespace
layers
{
class
AsyncCanvasRenderer
;
class
AsyncTransactionTracker
;
class
ImageClient
;
class
ImageContainer
;
class
ImageContainerChild
;
class
ImageBridgeParent
;
class
CompositableClient
;
struct
CompositableTransaction
;
class
Image
;
class
TextureClient
;
class
SynchronousTask
;
struct
AllocShmemParams
;
bool
InImageBridgeChildThread
(
)
;
class
ImageBridgeChild
final
:
public
PImageBridgeChild
public
CompositableForwarder
public
TextureForwarder
{
friend
class
ImageContainer
;
typedef
InfallibleTArray
<
AsyncParentMessageData
>
AsyncParentMessageArray
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ImageBridgeChild
override
)
;
TextureForwarder
*
GetTextureForwarder
(
)
override
{
return
this
;
}
LayersIPCActor
*
GetLayersIPCActor
(
)
override
{
return
this
;
}
static
void
InitSameProcess
(
)
;
static
void
InitWithGPUProcess
(
Endpoint
<
PImageBridgeChild
>
&
&
aEndpoint
)
;
static
bool
InitForContent
(
Endpoint
<
PImageBridgeChild
>
&
&
aEndpoint
)
;
static
bool
ReinitForContent
(
Endpoint
<
PImageBridgeChild
>
&
&
aEndpoint
)
;
static
void
ShutDown
(
)
;
static
RefPtr
<
ImageBridgeChild
>
GetSingleton
(
)
;
static
void
IdentifyCompositorTextureHost
(
const
TextureFactoryIdentifier
&
aIdentifier
)
;
void
BeginTransaction
(
)
;
void
EndTransaction
(
)
;
base
:
:
Thread
*
GetThread
(
)
const
;
virtual
MessageLoop
*
GetMessageLoop
(
)
const
override
;
virtual
base
:
:
ProcessId
GetParentPid
(
)
const
override
{
return
OtherPid
(
)
;
}
PCompositableChild
*
AllocPCompositableChild
(
const
TextureInfo
&
aInfo
PImageContainerChild
*
aChild
uint64_t
*
aID
)
override
;
bool
DeallocPCompositableChild
(
PCompositableChild
*
aActor
)
override
;
virtual
PTextureChild
*
AllocPTextureChild
(
const
SurfaceDescriptor
&
aSharedData
const
LayersBackend
&
aLayersBackend
const
TextureFlags
&
aFlags
const
uint64_t
&
aSerial
)
override
;
virtual
bool
DeallocPTextureChild
(
PTextureChild
*
actor
)
override
;
PMediaSystemResourceManagerChild
*
AllocPMediaSystemResourceManagerChild
(
)
override
;
bool
DeallocPMediaSystemResourceManagerChild
(
PMediaSystemResourceManagerChild
*
aActor
)
override
;
virtual
PImageContainerChild
*
AllocPImageContainerChild
(
)
override
;
virtual
bool
DeallocPImageContainerChild
(
PImageContainerChild
*
actor
)
override
;
virtual
bool
RecvParentAsyncMessages
(
InfallibleTArray
<
AsyncParentMessageData
>
&
&
aMessages
)
override
;
virtual
bool
RecvDidComposite
(
InfallibleTArray
<
ImageCompositeNotification
>
&
&
aNotifications
)
override
;
RefPtr
<
ImageClient
>
CreateImageClient
(
CompositableType
aType
ImageContainer
*
aImageContainer
ImageContainerChild
*
aContainerChild
)
;
RefPtr
<
ImageClient
>
CreateImageClientNow
(
CompositableType
aType
ImageContainer
*
aImageContainer
ImageContainerChild
*
aContainerChild
)
;
already_AddRefed
<
CanvasClient
>
CreateCanvasClient
(
CanvasClient
:
:
CanvasClientType
aType
TextureFlags
aFlag
)
;
void
ReleaseImageContainer
(
RefPtr
<
ImageContainerChild
>
aChild
)
;
void
UpdateAsyncCanvasRenderer
(
AsyncCanvasRenderer
*
aClient
)
;
void
UpdateImageClient
(
RefPtr
<
ImageClient
>
aClient
RefPtr
<
ImageContainer
>
aContainer
)
;
static
void
DispatchReleaseTextureClient
(
TextureClient
*
aClient
)
;
void
FlushAllImages
(
ImageClient
*
aClient
ImageContainer
*
aContainer
)
;
private
:
~
ImageBridgeChild
(
)
;
already_AddRefed
<
CanvasClient
>
CreateCanvasClientNow
(
CanvasClient
:
:
CanvasClientType
aType
TextureFlags
aFlags
)
;
void
CreateCanvasClientSync
(
SynchronousTask
*
aTask
CanvasClient
:
:
CanvasClientType
aType
TextureFlags
aFlags
RefPtr
<
CanvasClient
>
*
const
outResult
)
;
void
CreateImageClientSync
(
SynchronousTask
*
aTask
RefPtr
<
ImageClient
>
*
result
CompositableType
aType
ImageContainer
*
aImageContainer
ImageContainerChild
*
aContainerChild
)
;
void
ReleaseTextureClientNow
(
TextureClient
*
aClient
)
;
void
UpdateAsyncCanvasRendererNow
(
AsyncCanvasRenderer
*
aClient
)
;
void
UpdateAsyncCanvasRendererSync
(
SynchronousTask
*
aTask
AsyncCanvasRenderer
*
aWrapper
)
;
void
FlushAllImagesSync
(
SynchronousTask
*
aTask
ImageClient
*
aClient
ImageContainer
*
aContainer
RefPtr
<
AsyncTransactionWaiter
>
aWaiter
)
;
void
ProxyAllocShmemNow
(
SynchronousTask
*
aTask
AllocShmemParams
*
aParams
)
;
void
ProxyDeallocShmemNow
(
SynchronousTask
*
aTask
Shmem
*
aShmem
)
;
public
:
virtual
void
Connect
(
CompositableClient
*
aCompositable
ImageContainer
*
aImageContainer
)
override
;
virtual
bool
UsesImageBridge
(
)
const
override
{
return
true
;
}
virtual
void
UseTextures
(
CompositableClient
*
aCompositable
const
nsTArray
<
TimedTextureClient
>
&
aTextures
)
override
;
virtual
void
UseComponentAlphaTextures
(
CompositableClient
*
aCompositable
TextureClient
*
aClientOnBlack
TextureClient
*
aClientOnWhite
)
override
;
#
ifdef
MOZ_WIDGET_GONK
virtual
void
UseOverlaySource
(
CompositableClient
*
aCompositable
const
OverlaySource
&
aOverlay
const
nsIntRect
&
aPictureRect
)
override
;
#
endif
void
Destroy
(
CompositableChild
*
aCompositable
)
override
;
void
HoldUntilCompositableRefReleasedIfNecessary
(
TextureClient
*
aClient
)
;
void
NotifyNotUsed
(
uint64_t
aTextureId
uint64_t
aFwdTransactionId
)
;
void
DeliverFence
(
uint64_t
aTextureId
FenceHandle
&
aReleaseFenceHandle
)
;
void
HoldUntilFenceHandleDelivery
(
TextureClient
*
aClient
uint64_t
aTransactionId
)
;
void
DeliverFenceToNonRecycle
(
uint64_t
aTextureId
FenceHandle
&
aReleaseFenceHandle
)
;
void
NotifyNotUsedToNonRecycle
(
uint64_t
aTextureId
uint64_t
aTransactionId
)
;
void
CancelWaitFenceHandle
(
TextureClient
*
aClient
)
;
virtual
void
CancelWaitForRecycle
(
uint64_t
aTextureId
)
override
;
virtual
bool
DestroyInTransaction
(
PTextureChild
*
aTexture
bool
synchronously
)
override
;
virtual
bool
DestroyInTransaction
(
PCompositableChild
*
aCompositable
bool
synchronously
)
override
;
virtual
void
RemoveTextureFromCompositable
(
CompositableClient
*
aCompositable
TextureClient
*
aTexture
)
override
;
virtual
void
RemoveTextureFromCompositableAsync
(
AsyncTransactionTracker
*
aAsyncTransactionTracker
CompositableClient
*
aCompositable
TextureClient
*
aTexture
)
override
;
virtual
void
UseTiledLayerBuffer
(
CompositableClient
*
aCompositable
const
SurfaceDescriptorTiles
&
aTileLayerDescriptor
)
override
{
NS_RUNTIMEABORT
(
"
should
not
be
called
"
)
;
}
virtual
void
UpdateTextureRegion
(
CompositableClient
*
aCompositable
const
ThebesBufferData
&
aThebesBufferData
const
nsIntRegion
&
aUpdatedRegion
)
override
{
NS_RUNTIMEABORT
(
"
should
not
be
called
"
)
;
}
virtual
bool
AllocUnsafeShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aShmType
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
override
;
virtual
bool
AllocShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aShmType
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
override
;
virtual
void
DeallocShmem
(
mozilla
:
:
ipc
:
:
Shmem
&
aShmem
)
override
;
virtual
PTextureChild
*
CreateTexture
(
const
SurfaceDescriptor
&
aSharedData
LayersBackend
aLayersBackend
TextureFlags
aFlags
uint64_t
aSerial
)
override
;
virtual
bool
IsSameProcess
(
)
const
override
;
virtual
void
UpdateFwdTransactionId
(
)
override
{
+
+
mFwdTransactionId
;
}
virtual
uint64_t
GetFwdTransactionId
(
)
override
{
return
mFwdTransactionId
;
}
bool
InForwarderThread
(
)
override
{
return
InImageBridgeChildThread
(
)
;
}
protected
:
ImageBridgeChild
(
)
;
bool
DispatchAllocShmemInternal
(
size_t
aSize
SharedMemory
:
:
SharedMemoryType
aType
Shmem
*
aShmem
bool
aUnsafe
)
;
void
Bind
(
Endpoint
<
PImageBridgeChild
>
&
&
aEndpoint
)
;
void
BindSameProcess
(
RefPtr
<
ImageBridgeParent
>
aParent
)
;
void
SendImageBridgeThreadId
(
)
;
void
WillShutdown
(
)
;
void
ShutdownStep1
(
SynchronousTask
*
aTask
)
;
void
ShutdownStep2
(
SynchronousTask
*
aTask
)
;
void
MarkShutDown
(
)
;
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
void
DeallocPImageBridgeChild
(
)
override
;
bool
CanSend
(
)
const
;
static
void
ShutdownSingleton
(
)
;
private
:
CompositableTransaction
*
mTxn
;
bool
mCanSend
;
bool
mCalledClose
;
uint64_t
mFwdTransactionId
;
nsDataHashtable
<
nsUint64HashKey
RefPtr
<
TextureClient
>
>
mTexturesWaitingRecycled
;
AsyncTransactionTrackersHolder
mTrackersHolder
;
#
ifdef
MOZ_WIDGET_GONK
Mutex
mWaitingFenceHandleMutex
;
nsDataHashtable
<
nsUint64HashKey
RefPtr
<
TextureClient
>
>
mTexturesWaitingFenceHandle
;
#
endif
}
;
}
}
#
endif
