#
include
"
mozilla
/
layers
/
CompositorManagerChild
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
CompositorManagerParent
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessManager
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
TabChild
.
h
"
#
include
"
mozilla
/
dom
/
TabGroup
.
h
"
#
include
"
VsyncSource
.
h
"
namespace
mozilla
{
namespace
layers
{
using
gfx
:
:
GPUProcessManager
;
StaticRefPtr
<
CompositorManagerChild
>
CompositorManagerChild
:
:
sInstance
;
bool
CompositorManagerChild
:
:
IsInitialized
(
base
:
:
ProcessId
aGPUPid
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
sInstance
&
&
sInstance
-
>
CanSend
(
)
&
&
sInstance
-
>
OtherPid
(
)
=
=
aGPUPid
;
}
bool
CompositorManagerChild
:
:
InitSameProcess
(
uint32_t
aNamespace
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_WARN_IF
(
IsInitialized
(
base
:
:
GetCurrentProcId
(
)
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Already
initialized
same
process
"
)
;
return
false
;
}
RefPtr
<
CompositorManagerParent
>
parent
=
CompositorManagerParent
:
:
CreateSameProcess
(
)
;
sInstance
=
new
CompositorManagerChild
(
parent
aNamespace
)
;
return
true
;
}
bool
CompositorManagerChild
:
:
Init
(
Endpoint
<
PCompositorManagerChild
>
&
&
aEndpoint
uint32_t
aNamespace
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
sInstance
)
{
MOZ_ASSERT
(
sInstance
-
>
mNamespace
!
=
aNamespace
)
;
}
sInstance
=
new
CompositorManagerChild
(
Move
(
aEndpoint
)
aNamespace
)
;
return
sInstance
-
>
CanSend
(
)
;
}
void
CompositorManagerChild
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
CompositorBridgeChild
:
:
ShutDown
(
)
;
if
(
!
sInstance
)
{
return
;
}
sInstance
-
>
Close
(
)
;
sInstance
=
nullptr
;
}
void
CompositorManagerChild
:
:
OnGPUProcessLost
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
sInstance
)
{
sInstance
-
>
mCanSend
=
false
;
}
}
bool
CompositorManagerChild
:
:
CreateContentCompositorBridge
(
uint32_t
aNamespace
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_WARN_IF
(
!
sInstance
|
|
!
sInstance
-
>
CanSend
(
)
)
)
{
return
false
;
}
CompositorBridgeOptions
options
=
ContentCompositorOptions
(
)
;
PCompositorBridgeChild
*
pbridge
=
sInstance
-
>
SendPCompositorBridgeConstructor
(
options
)
;
if
(
NS_WARN_IF
(
!
pbridge
)
)
{
return
true
;
}
auto
bridge
=
static_cast
<
CompositorBridgeChild
*
>
(
pbridge
)
;
bridge
-
>
InitForContent
(
aNamespace
)
;
return
true
;
}
already_AddRefed
<
CompositorBridgeChild
>
CompositorManagerChild
:
:
CreateWidgetCompositorBridge
(
uint64_t
aProcessToken
LayerManager
*
aLayerManager
uint32_t
aNamespace
CSSToLayoutDeviceScale
aScale
const
CompositorOptions
&
aOptions
bool
aUseExternalSurfaceSize
const
gfx
:
:
IntSize
&
aSurfaceSize
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_WARN_IF
(
!
sInstance
|
|
!
sInstance
-
>
CanSend
(
)
)
)
{
return
nullptr
;
}
TimeDuration
vsyncRate
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetHardwareVsync
(
)
-
>
GetGlobalDisplay
(
)
.
GetVsyncRate
(
)
;
CompositorBridgeOptions
options
=
WidgetCompositorOptions
(
aScale
vsyncRate
aOptions
aUseExternalSurfaceSize
aSurfaceSize
)
;
PCompositorBridgeChild
*
pbridge
=
sInstance
-
>
SendPCompositorBridgeConstructor
(
options
)
;
if
(
NS_WARN_IF
(
!
pbridge
)
)
{
return
nullptr
;
}
RefPtr
<
CompositorBridgeChild
>
bridge
=
static_cast
<
CompositorBridgeChild
*
>
(
pbridge
)
;
bridge
-
>
InitForWidget
(
aProcessToken
aLayerManager
aNamespace
)
;
return
bridge
.
forget
(
)
;
}
already_AddRefed
<
CompositorBridgeChild
>
CompositorManagerChild
:
:
CreateSameProcessWidgetCompositorBridge
(
LayerManager
*
aLayerManager
uint32_t
aNamespace
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_WARN_IF
(
!
sInstance
|
|
!
sInstance
-
>
CanSend
(
)
)
)
{
return
nullptr
;
}
CompositorBridgeOptions
options
=
SameProcessWidgetCompositorOptions
(
)
;
PCompositorBridgeChild
*
pbridge
=
sInstance
-
>
SendPCompositorBridgeConstructor
(
options
)
;
if
(
NS_WARN_IF
(
!
pbridge
)
)
{
return
nullptr
;
}
RefPtr
<
CompositorBridgeChild
>
bridge
=
static_cast
<
CompositorBridgeChild
*
>
(
pbridge
)
;
bridge
-
>
InitForWidget
(
1
aLayerManager
aNamespace
)
;
return
bridge
.
forget
(
)
;
}
CompositorManagerChild
:
:
CompositorManagerChild
(
CompositorManagerParent
*
aParent
uint32_t
aNamespace
)
:
mCanSend
(
false
)
mNamespace
(
aNamespace
)
mResourceId
(
0
)
{
MOZ_ASSERT
(
aParent
)
;
SetOtherProcessId
(
base
:
:
GetCurrentProcId
(
)
)
;
MessageLoop
*
loop
=
CompositorThreadHolder
:
:
Loop
(
)
;
ipc
:
:
MessageChannel
*
channel
=
aParent
-
>
GetIPCChannel
(
)
;
if
(
NS_WARN_IF
(
!
Open
(
channel
loop
ipc
:
:
ChildSide
)
)
)
{
return
;
}
mCanSend
=
true
;
AddRef
(
)
;
SetReplyTimeout
(
)
;
}
CompositorManagerChild
:
:
CompositorManagerChild
(
Endpoint
<
PCompositorManagerChild
>
&
&
aEndpoint
uint32_t
aNamespace
)
:
mCanSend
(
false
)
mNamespace
(
aNamespace
)
mResourceId
(
0
)
{
if
(
NS_WARN_IF
(
!
aEndpoint
.
Bind
(
this
)
)
)
{
return
;
}
mCanSend
=
true
;
AddRef
(
)
;
SetReplyTimeout
(
)
;
}
void
CompositorManagerChild
:
:
DeallocPCompositorManagerChild
(
)
{
MOZ_ASSERT
(
!
mCanSend
)
;
Release
(
)
;
}
void
CompositorManagerChild
:
:
ActorDestroy
(
ActorDestroyReason
aReason
)
{
mCanSend
=
false
;
if
(
sInstance
=
=
this
)
{
sInstance
=
nullptr
;
}
}
PCompositorBridgeChild
*
CompositorManagerChild
:
:
AllocPCompositorBridgeChild
(
const
CompositorBridgeOptions
&
aOptions
)
{
CompositorBridgeChild
*
child
=
new
CompositorBridgeChild
(
this
)
;
child
-
>
AddRef
(
)
;
return
child
;
}
bool
CompositorManagerChild
:
:
DeallocPCompositorBridgeChild
(
PCompositorBridgeChild
*
aActor
)
{
static_cast
<
CompositorBridgeChild
*
>
(
aActor
)
-
>
Release
(
)
;
return
true
;
}
void
CompositorManagerChild
:
:
HandleFatalError
(
const
char
*
aName
const
char
*
aMsg
)
const
{
dom
:
:
ContentChild
:
:
FatalErrorIfNotUsingGPUProcess
(
aName
aMsg
OtherPid
(
)
)
;
}
void
CompositorManagerChild
:
:
ProcessingError
(
Result
aCode
const
char
*
aReason
)
{
if
(
aCode
!
=
MsgDropped
)
{
gfxDevCrash
(
gfx
:
:
LogReason
:
:
ProcessingError
)
<
<
"
Processing
error
in
CompositorBridgeChild
:
"
<
<
int
(
aCode
)
;
}
}
already_AddRefed
<
nsIEventTarget
>
CompositorManagerChild
:
:
GetSpecificMessageEventTarget
(
const
Message
&
aMsg
)
{
if
(
aMsg
.
type
(
)
!
=
PCompositorBridge
:
:
Msg_DidComposite__ID
)
{
return
nullptr
;
}
uint64_t
layersId
;
PickleIterator
iter
(
aMsg
)
;
if
(
!
IPC
:
:
ReadParam
(
&
aMsg
&
iter
&
layersId
)
)
{
return
nullptr
;
}
TabChild
*
tabChild
=
TabChild
:
:
GetFrom
(
layersId
)
;
if
(
!
tabChild
)
{
return
nullptr
;
}
return
do_AddRef
(
tabChild
-
>
TabGroup
(
)
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
}
void
CompositorManagerChild
:
:
SetReplyTimeout
(
)
{
#
ifndef
DEBUG
if
(
XRE_IsParentProcess
(
)
&
&
GPUProcessManager
:
:
Get
(
)
-
>
GetGPUChild
(
)
&
&
!
gfx
:
:
gfxVars
:
:
UseWebRender
(
)
)
{
int32_t
timeout
=
gfxPrefs
:
:
GPUProcessIPCReplyTimeoutMs
(
)
;
SetReplyTimeoutMs
(
timeout
)
;
}
#
endif
}
bool
CompositorManagerChild
:
:
ShouldContinueFromReplyTimeout
(
)
{
if
(
XRE_IsParentProcess
(
)
)
{
gfxCriticalNote
<
<
"
Killing
GPU
process
due
to
IPC
reply
timeout
"
;
MOZ_DIAGNOSTIC_ASSERT
(
GPUProcessManager
:
:
Get
(
)
-
>
GetGPUChild
(
)
)
;
GPUProcessManager
:
:
Get
(
)
-
>
KillProcess
(
)
;
}
return
false
;
}
}
}
