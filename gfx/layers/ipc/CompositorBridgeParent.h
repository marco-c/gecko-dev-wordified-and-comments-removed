#
ifndef
mozilla_layers_CompositorBridgeParent_h
#
define
mozilla_layers_CompositorBridgeParent_h
#
include
<
stdint
.
h
>
#
include
"
Layers
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
IdType
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemory
.
h
"
#
include
"
mozilla
/
layers
/
CompositorController
.
h
"
#
include
"
mozilla
/
layers
/
CompositorOptions
.
h
"
#
include
"
mozilla
/
layers
/
CompositorVsyncSchedulerOwner
.
h
"
#
include
"
mozilla
/
layers
/
GeckoContentController
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
layers
/
MetricsSharingController
.
h
"
#
include
"
mozilla
/
layers
/
PCompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
APZTestData
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderTypes
.
h
"
#
include
"
mozilla
/
webrender
/
RenderThread
.
h
"
#
include
"
mozilla
/
widget
/
CompositorWidget
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
ThreadSafeRefcountingWithMainThreadDestruction
.
h
"
#
include
"
mozilla
/
layers
/
UiCompositorControllerParent
.
h
"
#
include
"
mozilla
/
VsyncDispatcher
.
h
"
class
MessageLoop
;
class
nsIWidget
;
namespace
mozilla
{
class
CancelableRunnable
;
namespace
gfx
{
class
DrawTarget
;
class
GPUProcessManager
;
class
GPUParent
;
}
namespace
ipc
{
class
Shmem
;
#
ifdef
FUZZING
class
ProtocolFuzzerHelper
;
#
endif
}
namespace
layers
{
class
APZCTreeManager
;
class
APZCTreeManagerParent
;
class
APZSampler
;
class
APZUpdater
;
class
AsyncCompositionManager
;
class
AsyncImagePipelineManager
;
class
Compositor
;
class
CompositorAnimationStorage
;
class
CompositorBridgeParent
;
class
CompositorManagerParent
;
class
CompositorVsyncScheduler
;
class
HostLayerManager
;
class
IAPZCTreeManager
;
class
LayerTransactionParent
;
class
PAPZParent
;
class
CrossProcessCompositorBridgeParent
;
class
CompositorThreadHolder
;
class
InProcessCompositorSession
;
class
WebRenderBridgeParent
;
struct
ScopedLayerTreeRegistration
{
ScopedLayerTreeRegistration
(
APZCTreeManager
*
aApzctm
LayersId
aLayersId
Layer
*
aRoot
GeckoContentController
*
aController
)
;
~
ScopedLayerTreeRegistration
(
)
;
private
:
LayersId
mLayersId
;
}
;
class
CompositorBridgeParentBase
:
public
PCompositorBridgeParent
public
HostIPCAllocator
public
ShmemAllocator
public
MetricsSharingController
{
friend
class
PCompositorBridgeParent
;
public
:
explicit
CompositorBridgeParentBase
(
CompositorManagerParent
*
aManager
)
;
virtual
void
ShadowLayersUpdated
(
LayerTransactionParent
*
aLayerTree
const
TransactionInfo
&
aInfo
bool
aHitTestUpdate
)
=
0
;
virtual
AsyncCompositionManager
*
GetCompositionManager
(
LayerTransactionParent
*
aLayerTree
)
{
return
nullptr
;
}
virtual
void
NotifyClearCachedResources
(
LayerTransactionParent
*
aLayerTree
)
{
}
virtual
void
ScheduleComposite
(
LayerTransactionParent
*
aLayerTree
)
{
}
virtual
bool
SetTestSampleTime
(
const
LayersId
&
aId
const
TimeStamp
&
aTime
)
{
return
true
;
}
virtual
void
LeaveTestMode
(
const
LayersId
&
aId
)
{
}
enum
class
TransformsToSkip
:
uint8_t
{
NoneOfThem
=
0
APZ
=
1
}
;
virtual
void
ApplyAsyncProperties
(
LayerTransactionParent
*
aLayerTree
TransformsToSkip
aSkip
)
=
0
;
virtual
void
SetTestAsyncScrollOffset
(
const
LayersId
&
aLayersId
const
ScrollableLayerGuid
:
:
ViewID
&
aScrollId
const
CSSPoint
&
aPoint
)
=
0
;
virtual
void
SetTestAsyncZoom
(
const
LayersId
&
aLayersId
const
ScrollableLayerGuid
:
:
ViewID
&
aScrollId
const
LayerToParentLayerScale
&
aZoom
)
=
0
;
virtual
void
FlushApzRepaints
(
const
LayersId
&
aLayersId
)
=
0
;
virtual
void
GetAPZTestData
(
const
LayersId
&
aLayersId
APZTestData
*
aOutData
)
{
}
virtual
void
SetConfirmedTargetAPZC
(
const
LayersId
&
aLayersId
const
uint64_t
&
aInputBlockId
const
nsTArray
<
ScrollableLayerGuid
>
&
aTargets
)
=
0
;
virtual
void
UpdatePaintTime
(
LayerTransactionParent
*
aLayerTree
const
TimeDuration
&
aPaintTime
)
{
}
virtual
void
RegisterPayload
(
LayerTransactionParent
*
aLayerTree
const
InfallibleTArray
<
CompositionPayload
>
&
aPayload
)
{
}
ShmemAllocator
*
AsShmemAllocator
(
)
override
{
return
this
;
}
CompositorBridgeParentBase
*
AsCompositorBridgeParentBase
(
)
override
{
return
this
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvSyncWithCompositor
(
)
override
{
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
Recv__delete__
(
)
override
{
return
IPC_OK
(
)
;
}
virtual
void
ObserveLayersUpdate
(
LayersId
aLayersId
LayersObserverEpoch
aEpoch
bool
aActive
)
=
0
;
base
:
:
ProcessId
GetChildProcessId
(
)
override
;
void
NotifyNotUsed
(
PTextureParent
*
aTexture
uint64_t
aTransactionId
)
override
;
void
SendAsyncMessage
(
const
InfallibleTArray
<
AsyncParentMessageData
>
&
aMessage
)
override
;
bool
AllocShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
override
;
bool
AllocUnsafeShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
override
;
void
DeallocShmem
(
mozilla
:
:
ipc
:
:
Shmem
&
aShmem
)
override
;
NS_IMETHOD_
(
MozExternalRefCountType
)
AddRef
(
)
override
{
return
HostIPCAllocator
:
:
AddRef
(
)
;
}
NS_IMETHOD_
(
MozExternalRefCountType
)
Release
(
)
override
{
return
HostIPCAllocator
:
:
Release
(
)
;
}
base
:
:
ProcessId
RemotePid
(
)
override
;
bool
StartSharingMetrics
(
mozilla
:
:
ipc
:
:
SharedMemoryBasic
:
:
Handle
aHandle
CrossProcessMutexHandle
aMutexHandle
LayersId
aLayersId
uint32_t
aApzcId
)
override
;
bool
StopSharingMetrics
(
ScrollableLayerGuid
:
:
ViewID
aScrollId
uint32_t
aApzcId
)
override
;
virtual
bool
IsRemote
(
)
const
{
return
false
;
}
virtual
void
ForceComposeToTarget
(
gfx
:
:
DrawTarget
*
aTarget
const
gfx
:
:
IntRect
*
aRect
=
nullptr
)
{
MOZ_CRASH
(
)
;
}
virtual
void
NotifyMemoryPressure
(
)
{
}
virtual
void
AccumulateMemoryReport
(
wr
:
:
MemoryReport
*
)
{
}
protected
:
~
CompositorBridgeParentBase
(
)
override
;
virtual
PAPZParent
*
AllocPAPZParent
(
const
LayersId
&
layersId
)
=
0
;
virtual
bool
DeallocPAPZParent
(
PAPZParent
*
aActor
)
=
0
;
virtual
PAPZCTreeManagerParent
*
AllocPAPZCTreeManagerParent
(
const
LayersId
&
layersId
)
=
0
;
virtual
bool
DeallocPAPZCTreeManagerParent
(
PAPZCTreeManagerParent
*
aActor
)
=
0
;
virtual
PLayerTransactionParent
*
AllocPLayerTransactionParent
(
const
nsTArray
<
LayersBackend
>
&
layersBackendHints
const
LayersId
&
id
)
=
0
;
virtual
bool
DeallocPLayerTransactionParent
(
PLayerTransactionParent
*
aActor
)
=
0
;
virtual
PTextureParent
*
AllocPTextureParent
(
const
SurfaceDescriptor
&
aSharedData
const
ReadLockDescriptor
&
aReadLock
const
LayersBackend
&
aBackend
const
TextureFlags
&
aTextureFlags
const
LayersId
&
id
const
uint64_t
&
aSerial
const
MaybeExternalImageId
&
aExternalImageId
)
=
0
;
virtual
bool
DeallocPTextureParent
(
PTextureParent
*
aActor
)
=
0
;
virtual
PWebRenderBridgeParent
*
AllocPWebRenderBridgeParent
(
const
PipelineId
&
pipelineId
const
LayoutDeviceIntSize
&
aSize
)
=
0
;
virtual
bool
DeallocPWebRenderBridgeParent
(
PWebRenderBridgeParent
*
aActor
)
=
0
;
virtual
PCompositorWidgetParent
*
AllocPCompositorWidgetParent
(
const
CompositorWidgetInitData
&
aInitData
)
=
0
;
virtual
bool
DeallocPCompositorWidgetParent
(
PCompositorWidgetParent
*
aActor
)
=
0
;
bool
mCanSend
;
private
:
RefPtr
<
CompositorManagerParent
>
mCompositorManager
;
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
CompositorBridgeParentBase
:
:
TransformsToSkip
)
class
CompositorBridgeParent
final
:
public
CompositorBridgeParentBase
public
CompositorController
public
CompositorVsyncSchedulerOwner
{
friend
class
CompositorThreadHolder
;
friend
class
InProcessCompositorSession
;
friend
class
gfx
:
:
GPUProcessManager
;
friend
class
gfx
:
:
GPUParent
;
friend
class
PCompositorBridgeParent
;
#
ifdef
FUZZING
friend
class
mozilla
:
:
ipc
:
:
ProtocolFuzzerHelper
;
#
endif
public
:
NS_IMETHOD_
(
MozExternalRefCountType
)
AddRef
(
)
override
{
return
CompositorBridgeParentBase
:
:
AddRef
(
)
;
}
NS_IMETHOD_
(
MozExternalRefCountType
)
Release
(
)
override
{
return
CompositorBridgeParentBase
:
:
Release
(
)
;
}
explicit
CompositorBridgeParent
(
CompositorManagerParent
*
aManager
CSSToLayoutDeviceScale
aScale
const
TimeDuration
&
aVsyncRate
const
CompositorOptions
&
aOptions
bool
aUseExternalSurfaceSize
const
gfx
:
:
IntSize
&
aSurfaceSize
)
;
void
InitSameProcess
(
widget
:
:
CompositorWidget
*
aWidget
const
LayersId
&
aLayerTreeId
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvInitialize
(
const
LayersId
&
aRootLayerTreeId
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvGetFrameUniformity
(
FrameUniformityData
*
aOutData
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvWillClose
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvPause
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvResume
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvNotifyChildCreated
(
const
LayersId
&
child
CompositorOptions
*
aOptions
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvMapAndNotifyChildCreated
(
const
LayersId
&
child
const
base
:
:
ProcessId
&
pid
CompositorOptions
*
aOptions
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvNotifyChildRecreated
(
const
LayersId
&
child
CompositorOptions
*
aOptions
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvAdoptChild
(
const
LayersId
&
child
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvMakeSnapshot
(
const
SurfaceDescriptor
&
aInSnapshot
const
gfx
:
:
IntRect
&
aRect
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvFlushRendering
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvFlushRenderingAsync
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvWaitOnTransactionProcessed
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvForcePresent
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvNotifyRegionInvalidated
(
const
nsIntRegion
&
aRegion
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvStartFrameTimeRecording
(
const
int32_t
&
aBufferSize
uint32_t
*
aOutStartIndex
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvStopFrameTimeRecording
(
const
uint32_t
&
aStartIndex
InfallibleTArray
<
float
>
*
intervals
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvCheckContentOnlyTDR
(
const
uint32_t
&
sequenceNum
bool
*
isContentOnlyTDR
)
override
{
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvRequestNotifyAfterRemotePaint
(
)
override
{
return
IPC_OK
(
)
;
}
;
mozilla
:
:
ipc
:
:
IPCResult
RecvAllPluginsCaptured
(
)
override
;
virtual
void
NotifyMemoryPressure
(
)
override
;
virtual
void
AccumulateMemoryReport
(
wr
:
:
MemoryReport
*
)
override
;
void
ActorDestroy
(
ActorDestroyReason
why
)
override
;
void
ShadowLayersUpdated
(
LayerTransactionParent
*
aLayerTree
const
TransactionInfo
&
aInfo
bool
aHitTestUpdate
)
override
;
void
ScheduleComposite
(
LayerTransactionParent
*
aLayerTree
)
override
;
bool
SetTestSampleTime
(
const
LayersId
&
aId
const
TimeStamp
&
aTime
)
override
;
void
LeaveTestMode
(
const
LayersId
&
aId
)
override
;
void
ApplyAsyncProperties
(
LayerTransactionParent
*
aLayerTree
TransformsToSkip
aSkip
)
override
;
CompositorAnimationStorage
*
GetAnimationStorage
(
)
;
void
SetTestAsyncScrollOffset
(
const
LayersId
&
aLayersId
const
ScrollableLayerGuid
:
:
ViewID
&
aScrollId
const
CSSPoint
&
aPoint
)
override
;
void
SetTestAsyncZoom
(
const
LayersId
&
aLayersId
const
ScrollableLayerGuid
:
:
ViewID
&
aScrollId
const
LayerToParentLayerScale
&
aZoom
)
override
;
void
FlushApzRepaints
(
const
LayersId
&
aLayersId
)
override
;
void
GetAPZTestData
(
const
LayersId
&
aLayersId
APZTestData
*
aOutData
)
override
;
void
SetConfirmedTargetAPZC
(
const
LayersId
&
aLayersId
const
uint64_t
&
aInputBlockId
const
nsTArray
<
ScrollableLayerGuid
>
&
aTargets
)
override
;
AsyncCompositionManager
*
GetCompositionManager
(
LayerTransactionParent
*
aLayerTree
)
override
{
return
mCompositionManager
;
}
PTextureParent
*
AllocPTextureParent
(
const
SurfaceDescriptor
&
aSharedData
const
ReadLockDescriptor
&
aReadLock
const
LayersBackend
&
aLayersBackend
const
TextureFlags
&
aFlags
const
LayersId
&
aId
const
uint64_t
&
aSerial
const
wr
:
:
MaybeExternalImageId
&
aExternalImageId
)
override
;
bool
DeallocPTextureParent
(
PTextureParent
*
actor
)
override
;
bool
IsSameProcess
(
)
const
override
;
void
NotifyWebRenderError
(
wr
:
:
WebRenderError
aError
)
;
void
NotifyWebRenderContextPurge
(
)
;
void
NotifyPipelineRendered
(
const
wr
:
:
PipelineId
&
aPipelineId
const
wr
:
:
Epoch
&
aEpoch
const
VsyncId
&
aCompositeStartId
TimeStamp
&
aCompositeStart
TimeStamp
&
aRenderStart
TimeStamp
&
aCompositeEnd
wr
:
:
RendererStats
*
aStats
=
nullptr
)
;
void
NotifyDidSceneBuild
(
RefPtr
<
wr
:
:
WebRenderPipelineInfo
>
aInfo
)
;
RefPtr
<
AsyncImagePipelineManager
>
GetAsyncImagePipelineManager
(
)
const
;
PCompositorWidgetParent
*
AllocPCompositorWidgetParent
(
const
CompositorWidgetInitData
&
aInitData
)
override
;
bool
DeallocPCompositorWidgetParent
(
PCompositorWidgetParent
*
aActor
)
override
;
void
ObserveLayersUpdate
(
LayersId
aLayersId
LayersObserverEpoch
aEpoch
bool
aActive
)
override
{
}
void
ForceIsFirstPaint
(
)
;
static
void
SetShadowProperties
(
Layer
*
aLayer
)
;
void
NotifyChildCreated
(
LayersId
aChild
)
;
void
AsyncRender
(
)
;
void
ScheduleRenderOnCompositorThread
(
)
override
;
void
SchedulePauseOnCompositorThread
(
)
;
void
InvalidateOnCompositorThread
(
)
;
bool
ScheduleResumeOnCompositorThread
(
)
;
bool
ScheduleResumeOnCompositorThread
(
int
x
int
y
int
width
int
height
)
;
void
ScheduleComposition
(
)
;
void
NotifyShadowTreeTransaction
(
LayersId
aId
bool
aIsFirstPaint
const
FocusTarget
&
aFocusTarget
bool
aScheduleComposite
uint32_t
aPaintSequenceNumber
bool
aIsRepeatTransaction
bool
aHitTestUpdate
)
;
void
UpdatePaintTime
(
LayerTransactionParent
*
aLayerTree
const
TimeDuration
&
aPaintTime
)
override
;
void
RegisterPayload
(
LayerTransactionParent
*
aLayerTree
const
InfallibleTArray
<
CompositionPayload
>
&
aPayload
)
override
;
void
ScheduleRotationOnCompositorThread
(
const
TargetConfig
&
aTargetConfig
bool
aIsFirstPaint
)
;
LayersId
RootLayerTreeId
(
)
;
void
InvalidateRemoteLayers
(
)
;
static
CompositorBridgeParent
*
GetCompositorBridgeParent
(
uint64_t
id
)
;
static
void
NotifyVsync
(
const
VsyncEvent
&
aVsync
const
LayersId
&
aLayersId
)
;
static
void
SetControllerForLayerTree
(
LayersId
aLayersId
GeckoContentController
*
aController
)
;
struct
LayerTreeState
{
LayerTreeState
(
)
;
~
LayerTreeState
(
)
;
RefPtr
<
Layer
>
mRoot
;
RefPtr
<
GeckoContentController
>
mController
;
APZCTreeManagerParent
*
mApzcTreeManagerParent
;
RefPtr
<
CompositorBridgeParent
>
mParent
;
HostLayerManager
*
mLayerManager
;
RefPtr
<
WebRenderBridgeParent
>
mWrBridge
;
CrossProcessCompositorBridgeParent
*
mCrossProcessParent
;
TargetConfig
mTargetConfig
;
LayerTransactionParent
*
mLayerTree
;
nsTArray
<
PluginWindowData
>
mPluginData
;
bool
mUpdatedPluginDataAvailable
;
CompositorController
*
GetCompositorController
(
)
const
;
MetricsSharingController
*
CrossProcessSharingController
(
)
const
;
MetricsSharingController
*
InProcessSharingController
(
)
const
;
RefPtr
<
UiCompositorControllerParent
>
mUiControllerParent
;
}
;
static
LayerTreeState
*
GetIndirectShadowTree
(
LayersId
aId
)
;
static
bool
CallWithIndirectShadowTree
(
LayersId
aId
const
std
:
:
function
<
void
(
LayerTreeState
&
)
>
&
aFunc
)
;
static
APZCTreeManagerParent
*
GetApzcTreeManagerParentForRoot
(
LayersId
aContentLayersId
)
;
static
GeckoContentController
*
GetGeckoContentControllerForRoot
(
LayersId
aContentLayersId
)
;
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
bool
UpdatePluginWindowState
(
LayersId
aId
)
;
void
ScheduleShowAllPluginWindows
(
)
override
;
void
ScheduleHideAllPluginWindows
(
)
override
;
void
ShowAllPluginWindows
(
)
;
void
HideAllPluginWindows
(
)
;
#
else
void
ScheduleShowAllPluginWindows
(
)
override
{
}
void
ScheduleHideAllPluginWindows
(
)
override
{
}
#
endif
mozilla
:
:
ipc
:
:
IPCResult
RecvRemotePluginsReady
(
)
override
;
static
void
PostInsertVsyncProfilerMarker
(
mozilla
:
:
TimeStamp
aVsyncTimestamp
)
;
widget
:
:
CompositorWidget
*
GetWidget
(
)
{
return
mWidget
;
}
virtual
void
ForceComposeToTarget
(
gfx
:
:
DrawTarget
*
aTarget
const
gfx
:
:
IntRect
*
aRect
=
nullptr
)
override
;
PAPZCTreeManagerParent
*
AllocPAPZCTreeManagerParent
(
const
LayersId
&
aLayersId
)
override
;
bool
DeallocPAPZCTreeManagerParent
(
PAPZCTreeManagerParent
*
aActor
)
override
;
void
AllocateAPZCTreeManagerParent
(
const
MonitorAutoLock
&
aProofOfLayerTreeStateLock
const
LayersId
&
aLayersId
LayerTreeState
&
aLayerTreeStateToUpdate
)
;
PAPZParent
*
AllocPAPZParent
(
const
LayersId
&
aLayersId
)
override
;
bool
DeallocPAPZParent
(
PAPZParent
*
aActor
)
override
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
AndroidDynamicToolbarAnimator
*
GetAndroidDynamicToolbarAnimator
(
)
;
#
endif
RefPtr
<
APZSampler
>
GetAPZSampler
(
)
;
RefPtr
<
APZUpdater
>
GetAPZUpdater
(
)
;
CompositorOptions
GetOptions
(
)
const
{
return
mOptions
;
}
TimeDuration
GetVsyncInterval
(
)
const
override
{
return
mVsyncRate
;
}
PWebRenderBridgeParent
*
AllocPWebRenderBridgeParent
(
const
wr
:
:
PipelineId
&
aPipelineId
const
LayoutDeviceIntSize
&
aSize
)
override
;
bool
DeallocPWebRenderBridgeParent
(
PWebRenderBridgeParent
*
aActor
)
override
;
RefPtr
<
WebRenderBridgeParent
>
GetWebRenderBridgeParent
(
)
const
;
Maybe
<
TimeStamp
>
GetTestingTimeStamp
(
)
const
;
static
CompositorBridgeParent
*
GetCompositorBridgeParentFromLayersId
(
const
LayersId
&
aLayersId
)
;
static
RefPtr
<
CompositorBridgeParent
>
GetCompositorBridgeParentFromWindowId
(
const
wr
:
:
WindowId
&
aWindowId
)
;
static
already_AddRefed
<
IAPZCTreeManager
>
GetAPZCTreeManager
(
LayersId
aLayersId
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
gfx
:
:
IntSize
GetEGLSurfaceSize
(
)
{
return
mEGLSurfaceSize
;
}
#
endif
WebRenderBridgeParent
*
GetWrBridge
(
)
{
return
mWrBridge
;
}
private
:
void
Initialize
(
)
;
void
StopAndClearResources
(
)
;
static
void
DeallocateLayerTreeId
(
LayersId
aId
)
;
protected
:
virtual
~
CompositorBridgeParent
(
)
;
void
DeferredDestroy
(
)
;
PLayerTransactionParent
*
AllocPLayerTransactionParent
(
const
nsTArray
<
LayersBackend
>
&
aBackendHints
const
LayersId
&
aId
)
override
;
bool
DeallocPLayerTransactionParent
(
PLayerTransactionParent
*
aLayers
)
override
;
virtual
void
ScheduleTask
(
already_AddRefed
<
CancelableRunnable
>
int
)
;
void
SetEGLSurfaceRect
(
int
x
int
y
int
width
int
height
)
;
void
InitializeLayerManager
(
const
nsTArray
<
LayersBackend
>
&
aBackendHints
)
;
public
:
void
PauseComposition
(
)
;
void
ResumeComposition
(
)
;
void
ResumeCompositionAndResize
(
int
x
int
y
int
width
int
height
)
;
void
Invalidate
(
)
;
protected
:
void
ForceComposition
(
)
;
void
CancelCurrentCompositeTask
(
)
;
bool
IsPendingComposite
(
)
override
;
void
FinishPendingComposite
(
)
override
;
void
CompositeToTarget
(
VsyncId
aId
gfx
:
:
DrawTarget
*
aTarget
const
gfx
:
:
IntRect
*
aRect
=
nullptr
)
override
;
bool
InitializeAdvancedLayers
(
const
nsTArray
<
LayersBackend
>
&
aBackendHints
TextureFactoryIdentifier
*
aOutIdentifier
)
;
RefPtr
<
Compositor
>
NewCompositor
(
const
nsTArray
<
LayersBackend
>
&
aBackendHints
)
;
static
void
AddCompositor
(
CompositorBridgeParent
*
compositor
uint64_t
*
id
)
;
static
CompositorBridgeParent
*
RemoveCompositor
(
uint64_t
id
)
;
static
void
Setup
(
)
;
static
void
FinishShutdown
(
)
;
bool
CanComposite
(
)
;
void
DidComposite
(
const
VsyncId
&
aId
TimeStamp
&
aCompositeStart
TimeStamp
&
aCompositeEnd
)
;
void
NotifyDidComposite
(
TransactionId
aTransactionId
VsyncId
aId
TimeStamp
&
aCompositeStart
TimeStamp
&
aCompositeEnd
)
;
template
<
typename
Lambda
>
inline
void
ForEachIndirectLayerTree
(
const
Lambda
&
aCallback
)
;
RefPtr
<
HostLayerManager
>
mLayerManager
;
RefPtr
<
Compositor
>
mCompositor
;
RefPtr
<
AsyncCompositionManager
>
mCompositionManager
;
RefPtr
<
AsyncImagePipelineManager
>
mAsyncImageManager
;
RefPtr
<
WebRenderBridgeParent
>
mWrBridge
;
widget
:
:
CompositorWidget
*
mWidget
;
Maybe
<
TimeStamp
>
mTestTime
;
CSSToLayoutDeviceScale
mScale
;
TimeDuration
mVsyncRate
;
TransactionId
mPendingTransaction
;
TimeStamp
mRefreshStartTime
;
TimeStamp
mTxnStartTime
;
TimeStamp
mFwdTime
;
bool
mPaused
;
bool
mUseExternalSurfaceSize
;
gfx
:
:
IntSize
mEGLSurfaceSize
;
CompositorOptions
mOptions
;
mozilla
:
:
Monitor
mPauseCompositionMonitor
;
mozilla
:
:
Monitor
mResumeCompositionMonitor
;
uint64_t
mCompositorBridgeID
;
LayersId
mRootLayerTreeID
;
bool
mOverrideComposeReadiness
;
RefPtr
<
CancelableRunnable
>
mForceCompositionTask
;
RefPtr
<
APZCTreeManager
>
mApzcTreeManager
;
RefPtr
<
APZSampler
>
mApzSampler
;
RefPtr
<
APZUpdater
>
mApzUpdater
;
RefPtr
<
CompositorVsyncScheduler
>
mCompositorScheduler
;
RefPtr
<
CompositorBridgeParent
>
mSelfRef
;
RefPtr
<
CompositorAnimationStorage
>
mAnimationStorage
;
TimeDuration
mPaintTime
;
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
LayersId
mLastPluginUpdateLayerTreeId
;
nsIntPoint
mPluginsLayerOffset
;
nsIntRegion
mPluginsLayerVisibleRegion
;
nsTArray
<
PluginWindowData
>
mCachedPluginData
;
TimeStamp
mWaitForPluginsUntil
;
bool
mHaveBlockedForPlugins
=
false
;
bool
mDeferPluginWindows
;
bool
mPluginWindowsHidden
;
#
endif
DISALLOW_EVIL_CONSTRUCTORS
(
CompositorBridgeParent
)
;
}
;
int32_t
RecordContentFrameTime
(
const
VsyncId
&
aTxnId
const
TimeStamp
&
aVsyncStart
const
TimeStamp
&
aTxnStart
const
VsyncId
&
aCompositeId
const
TimeStamp
&
aCompositeEnd
const
TimeDuration
&
aFullPaintTime
const
TimeDuration
&
aVsyncRate
bool
aContainsSVGGroup
bool
aRecordUploadStats
wr
:
:
RendererStats
*
aStats
=
nullptr
)
;
}
}
#
endif
