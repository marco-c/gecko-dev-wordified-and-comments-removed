#
ifndef
GFX_LAYERS_ISURFACEDEALLOCATOR
#
define
GFX_LAYERS_ISURFACEDEALLOCATOR
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
gfxTypes
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
IdType
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemory
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
namespace
mozilla
{
namespace
ipc
{
class
Shmem
;
class
IShmemAllocator
;
}
namespace
gfx
{
class
DataSourceSurface
;
}
namespace
layers
{
class
CompositableForwarder
;
class
CompositorBridgeParentBase
;
class
TextureForwarder
;
class
ShmemSectionAllocator
;
class
LegacySurfaceDescriptorAllocator
;
class
ClientIPCAllocator
;
class
HostIPCAllocator
;
class
LayersIPCChannel
;
enum
BufferCapabilities
{
DEFAULT_BUFFER_CAPS
=
0
MAP_AS_IMAGE_SURFACE
=
1
<
<
0
USING_GL_RENDERING_ONLY
=
1
<
<
1
}
;
class
SurfaceDescriptor
;
class
ISurfaceAllocator
{
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
ISurfaceAllocator
)
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ISurfaceAllocator
)
ISurfaceAllocator
(
)
=
default
;
virtual
mozilla
:
:
ipc
:
:
IShmemAllocator
*
AsShmemAllocator
(
)
{
return
nullptr
;
}
virtual
ShmemSectionAllocator
*
AsShmemSectionAllocator
(
)
{
return
nullptr
;
}
virtual
CompositableForwarder
*
AsCompositableForwarder
(
)
{
return
nullptr
;
}
virtual
TextureForwarder
*
GetTextureForwarder
(
)
{
return
nullptr
;
}
virtual
ClientIPCAllocator
*
AsClientAllocator
(
)
{
return
nullptr
;
}
virtual
HostIPCAllocator
*
AsHostIPCAllocator
(
)
{
return
nullptr
;
}
virtual
LegacySurfaceDescriptorAllocator
*
AsLegacySurfaceDescriptorAllocator
(
)
{
return
nullptr
;
}
virtual
CompositorBridgeParentBase
*
AsCompositorBridgeParentBase
(
)
{
return
nullptr
;
}
virtual
bool
IPCOpen
(
)
const
{
return
true
;
}
virtual
bool
IsSameProcess
(
)
const
=
0
;
virtual
bool
UsesImageBridge
(
)
const
{
return
false
;
}
virtual
bool
UsesWebRenderBridge
(
)
const
{
return
false
;
}
virtual
dom
:
:
ContentParentId
GetContentId
(
)
{
return
dom
:
:
ContentParentId
(
)
;
}
protected
:
void
Finalize
(
)
{
}
virtual
~
ISurfaceAllocator
(
)
=
default
;
}
;
class
ClientIPCAllocator
:
public
ISurfaceAllocator
{
public
:
ClientIPCAllocator
(
)
=
default
;
ClientIPCAllocator
*
AsClientAllocator
(
)
override
{
return
this
;
}
virtual
base
:
:
ProcessId
GetParentPid
(
)
const
=
0
;
virtual
MessageLoop
*
GetMessageLoop
(
)
const
=
0
;
virtual
void
CancelWaitForNotifyNotUsed
(
uint64_t
aTextureId
)
=
0
;
}
;
class
HostIPCAllocator
:
public
ISurfaceAllocator
{
public
:
HostIPCAllocator
(
)
=
default
;
HostIPCAllocator
*
AsHostIPCAllocator
(
)
override
{
return
this
;
}
virtual
base
:
:
ProcessId
GetChildProcessId
(
)
=
0
;
virtual
void
NotifyNotUsed
(
PTextureParent
*
aTexture
uint64_t
aTransactionId
)
=
0
;
virtual
void
SendAsyncMessage
(
const
nsTArray
<
AsyncParentMessageData
>
&
aMessage
)
=
0
;
virtual
void
SendPendingAsyncMessages
(
)
;
virtual
void
SetAboutToSendAsyncMessages
(
)
{
mAboutToSendAsyncMessages
=
true
;
}
bool
IsAboutToSendAsyncMessages
(
)
{
return
mAboutToSendAsyncMessages
;
}
protected
:
std
:
:
vector
<
AsyncParentMessageData
>
mPendingAsyncMessage
;
bool
mAboutToSendAsyncMessages
=
false
;
}
;
class
ShmemSection
{
public
:
static
Maybe
<
ShmemSection
>
FromUntrusted
(
const
UntrustedShmemSection
&
aUntrusted
)
;
bool
Init
(
const
mozilla
:
:
ipc
:
:
Shmem
&
aShm
uint32_t
offset
uint32_t
size
)
;
UntrustedShmemSection
AsUntrusted
(
)
;
uint32_t
size
(
)
const
{
return
mSize
;
}
uint32_t
offset
(
)
const
{
return
mOffset
;
}
const
mozilla
:
:
ipc
:
:
Shmem
&
shmem
(
)
{
return
mShmem
;
}
private
:
mozilla
:
:
ipc
:
:
Shmem
mShmem
;
uint32_t
mOffset
;
uint32_t
mSize
;
}
;
class
ShmemSectionAllocator
{
public
:
virtual
bool
AllocShmemSection
(
uint32_t
aSize
ShmemSection
*
aShmemSection
)
=
0
;
virtual
void
DeallocShmemSection
(
ShmemSection
&
aShmemSection
)
=
0
;
virtual
void
MemoryPressure
(
)
{
}
}
;
class
LegacySurfaceDescriptorAllocator
{
public
:
virtual
bool
AllocSurfaceDescriptor
(
const
gfx
:
:
IntSize
&
aSize
gfxContentType
aContent
SurfaceDescriptor
*
aBuffer
)
=
0
;
virtual
bool
AllocSurfaceDescriptorWithCaps
(
const
gfx
:
:
IntSize
&
aSize
gfxContentType
aContent
uint32_t
aCaps
SurfaceDescriptor
*
aBuffer
)
=
0
;
virtual
void
DestroySurfaceDescriptor
(
SurfaceDescriptor
*
aSurface
)
=
0
;
}
;
bool
IsSurfaceDescriptorValid
(
const
SurfaceDescriptor
&
aSurface
)
;
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
GetSurfaceForDescriptor
(
const
SurfaceDescriptor
&
aDescriptor
)
;
uint8_t
*
GetAddressFromDescriptor
(
const
SurfaceDescriptor
&
aDescriptor
)
;
void
DestroySurfaceDescriptor
(
mozilla
:
:
ipc
:
:
IShmemAllocator
*
aAllocator
SurfaceDescriptor
*
aSurface
)
;
class
GfxMemoryImageReporter
final
:
public
nsIMemoryReporter
{
~
GfxMemoryImageReporter
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
GfxMemoryImageReporter
(
)
{
#
ifdef
DEBUG
static
bool
hasRun
=
false
;
MOZ_ASSERT
(
!
hasRun
)
;
hasRun
=
true
;
#
endif
}
MOZ_DEFINE_MALLOC_SIZE_OF_ON_ALLOC
(
MallocSizeOfOnAlloc
)
MOZ_DEFINE_MALLOC_SIZE_OF_ON_FREE
(
MallocSizeOfOnFree
)
static
void
DidAlloc
(
void
*
aPointer
)
{
sAmount
+
=
MallocSizeOfOnAlloc
(
aPointer
)
;
}
static
void
WillFree
(
void
*
aPointer
)
{
sAmount
-
=
MallocSizeOfOnFree
(
aPointer
)
;
}
NS_IMETHOD
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
override
{
MOZ_COLLECT_REPORT
(
"
explicit
/
gfx
/
heap
-
textures
"
KIND_HEAP
UNITS_BYTES
sAmount
"
Heap
memory
shared
between
threads
by
texture
clients
and
hosts
.
"
)
;
return
NS_OK
;
}
private
:
static
mozilla
:
:
Atomic
<
ptrdiff_t
>
sAmount
;
}
;
class
FixedSizeSmallShmemSectionAllocator
final
:
public
ShmemSectionAllocator
{
public
:
NS_DECL_OWNINGTHREAD
enum
AllocationStatus
{
STATUS_ALLOCATED
STATUS_FREED
}
;
struct
ShmemSectionHeapHeader
{
Atomic
<
uint32_t
>
mTotalBlocks
;
Atomic
<
uint32_t
>
mAllocatedBlocks
;
}
;
struct
ShmemSectionHeapAllocation
{
Atomic
<
uint32_t
>
mStatus
;
uint32_t
mSize
;
}
;
explicit
FixedSizeSmallShmemSectionAllocator
(
LayersIPCChannel
*
aShmProvider
)
;
~
FixedSizeSmallShmemSectionAllocator
(
)
;
bool
AllocShmemSection
(
uint32_t
aSize
ShmemSection
*
aShmemSection
)
override
;
void
DeallocShmemSection
(
ShmemSection
&
aShmemSection
)
override
;
void
MemoryPressure
(
)
override
{
ShrinkShmemSectionHeap
(
)
;
}
static
void
FreeShmemSection
(
ShmemSection
&
aShmemSection
)
;
void
ShrinkShmemSectionHeap
(
)
;
bool
IPCOpen
(
)
const
;
protected
:
std
:
:
vector
<
mozilla
:
:
ipc
:
:
Shmem
>
mUsedShmems
;
LayersIPCChannel
*
mShmProvider
;
}
;
}
}
#
endif
