#
ifndef
GFX_LAYERS_ISURFACEDEALLOCATOR
#
define
GFX_LAYERS_ISURFACEDEALLOCATOR
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
gfxTypes
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemory
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
LayersTypes
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
mozilla
/
layers
/
AtomicRefCountedWithFinalize
.
h
"
#
ifdef
MOZ_WIDGET_GONK
#
define
MOZ_HAVE_SURFACEDESCRIPTORGRALLOC
#
endif
namespace
mozilla
{
namespace
ipc
{
class
Shmem
;
}
namespace
gfx
{
class
DataSourceSurface
;
}
namespace
layers
{
class
CompositableForwarder
;
class
ShadowLayerForwarder
;
class
ShmemAllocator
;
class
ShmemSectionAllocator
;
class
LegacySurfaceDescriptorAllocator
;
class
ClientIPCAllocator
;
class
HostIPCAllocator
;
enum
BufferCapabilities
{
DEFAULT_BUFFER_CAPS
=
0
MAP_AS_IMAGE_SURFACE
=
1
<
<
0
USING_GL_RENDERING_ONLY
=
1
<
<
1
}
;
class
SurfaceDescriptor
;
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
OptimalShmemType
(
)
;
class
ISurfaceAllocator
:
public
AtomicRefCountedWithFinalize
<
ISurfaceAllocator
>
{
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
ISurfaceAllocator
)
virtual
ShmemAllocator
*
AsShmemAllocator
(
)
{
return
nullptr
;
}
virtual
ShmemSectionAllocator
*
AsShmemSectionAllocator
(
)
{
return
nullptr
;
}
virtual
CompositableForwarder
*
AsCompositableForwarder
(
)
{
return
nullptr
;
}
virtual
ShadowLayerForwarder
*
AsLayerForwarder
(
)
{
return
nullptr
;
}
virtual
ClientIPCAllocator
*
AsClientAllocator
(
)
{
return
nullptr
;
}
virtual
HostIPCAllocator
*
AsHostIPCAllocator
(
)
{
return
nullptr
;
}
virtual
LegacySurfaceDescriptorAllocator
*
AsLegacySurfaceDescriptorAllocator
(
)
{
return
nullptr
;
}
virtual
bool
IPCOpen
(
)
const
{
return
true
;
}
virtual
bool
IsSameProcess
(
)
const
=
0
;
virtual
bool
UsesImageBridge
(
)
const
{
return
false
;
}
protected
:
void
Finalize
(
)
{
}
virtual
~
ISurfaceAllocator
(
)
{
}
friend
class
AtomicRefCountedWithFinalize
<
ISurfaceAllocator
>
;
}
;
class
ClientIPCAllocator
:
public
ISurfaceAllocator
{
public
:
virtual
ClientIPCAllocator
*
AsClientAllocator
(
)
override
{
return
this
;
}
virtual
MessageLoop
*
GetMessageLoop
(
)
const
=
0
;
virtual
int32_t
GetMaxTextureSize
(
)
const
{
return
gfxPrefs
:
:
MaxTextureSize
(
)
;
}
}
;
class
HostIPCAllocator
:
public
ISurfaceAllocator
{
public
:
virtual
HostIPCAllocator
*
AsHostIPCAllocator
(
)
override
{
return
this
;
}
virtual
base
:
:
ProcessId
GetChildProcessId
(
)
=
0
;
}
;
class
ShmemAllocator
{
public
:
virtual
bool
AllocShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aShmType
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
=
0
;
virtual
bool
AllocUnsafeShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aShmType
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
=
0
;
virtual
void
DeallocShmem
(
mozilla
:
:
ipc
:
:
Shmem
&
aShmem
)
=
0
;
}
;
class
ShmemSectionAllocator
{
public
:
virtual
bool
AllocShmemSection
(
uint32_t
aSize
ShmemSection
*
aShmemSection
)
=
0
;
virtual
void
DeallocShmemSection
(
ShmemSection
&
aShmemSection
)
=
0
;
virtual
void
MemoryPressure
(
)
{
}
}
;
class
LegacySurfaceDescriptorAllocator
{
public
:
virtual
bool
AllocSurfaceDescriptor
(
const
gfx
:
:
IntSize
&
aSize
gfxContentType
aContent
SurfaceDescriptor
*
aBuffer
)
=
0
;
virtual
bool
AllocSurfaceDescriptorWithCaps
(
const
gfx
:
:
IntSize
&
aSize
gfxContentType
aContent
uint32_t
aCaps
SurfaceDescriptor
*
aBuffer
)
=
0
;
virtual
void
DestroySurfaceDescriptor
(
SurfaceDescriptor
*
aSurface
)
=
0
;
}
;
already_AddRefed
<
gfx
:
:
DrawTarget
>
GetDrawTargetForDescriptor
(
const
SurfaceDescriptor
&
aDescriptor
gfx
:
:
BackendType
aBackend
)
;
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
GetSurfaceForDescriptor
(
const
SurfaceDescriptor
&
aDescriptor
)
;
uint8_t
*
GetAddressFromDescriptor
(
const
SurfaceDescriptor
&
aDescriptor
)
;
class
GfxMemoryImageReporter
final
:
public
nsIMemoryReporter
{
~
GfxMemoryImageReporter
(
)
{
}
public
:
NS_DECL_ISUPPORTS
GfxMemoryImageReporter
(
)
{
#
ifdef
DEBUG
static
bool
hasRun
=
false
;
MOZ_ASSERT
(
!
hasRun
)
;
hasRun
=
true
;
#
endif
}
MOZ_DEFINE_MALLOC_SIZE_OF_ON_ALLOC
(
MallocSizeOfOnAlloc
)
MOZ_DEFINE_MALLOC_SIZE_OF_ON_FREE
(
MallocSizeOfOnFree
)
static
void
DidAlloc
(
void
*
aPointer
)
{
sAmount
+
=
MallocSizeOfOnAlloc
(
aPointer
)
;
}
static
void
WillFree
(
void
*
aPointer
)
{
sAmount
-
=
MallocSizeOfOnFree
(
aPointer
)
;
}
NS_IMETHOD
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
override
{
return
MOZ_COLLECT_REPORT
(
"
explicit
/
gfx
/
heap
-
textures
"
KIND_HEAP
UNITS_BYTES
sAmount
"
Heap
memory
shared
between
threads
by
texture
clients
and
hosts
.
"
)
;
}
private
:
static
mozilla
:
:
Atomic
<
ptrdiff_t
>
sAmount
;
}
;
}
}
#
endif
