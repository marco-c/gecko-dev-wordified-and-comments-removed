#
ifndef
MOZILLA_GFX_SOURCESURFACEVOLATILEDATA_H_
#
define
MOZILLA_GFX_SOURCESURFACEVOLATILEDATA_H_
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
VolatileBuffer
.
h
"
namespace
mozilla
{
namespace
gfx
{
class
SourceSurfaceVolatileData
:
public
DataSourceSurface
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
SourceSurfaceVolatileData
override
)
SourceSurfaceVolatileData
(
)
:
mMutex
(
"
SourceSurfaceVolatileData
"
)
mStride
(
0
)
mFormat
(
SurfaceFormat
:
:
UNKNOWN
)
mWasPurged
(
false
)
{
}
bool
Init
(
const
IntSize
&
aSize
int32_t
aStride
SurfaceFormat
aFormat
)
;
uint8_t
*
GetData
(
)
override
{
return
mVBufPtr
;
}
int32_t
Stride
(
)
override
{
return
mStride
;
}
SurfaceType
GetType
(
)
const
override
{
return
SurfaceType
:
:
DATA
;
}
IntSize
GetSize
(
)
const
override
{
return
mSize
;
}
SurfaceFormat
GetFormat
(
)
const
override
{
return
mFormat
;
}
void
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
SizeOfInfo
&
aInfo
)
const
override
;
bool
OnHeap
(
)
const
override
{
return
mVBuf
-
>
OnHeap
(
)
;
}
bool
Map
(
MapType
MappedSurface
*
aMappedSurface
)
override
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mWasPurged
)
{
return
false
;
}
if
(
mMapCount
=
=
0
)
{
mVBufPtr
=
mVBuf
;
}
if
(
mVBufPtr
.
WasBufferPurged
(
)
)
{
mWasPurged
=
true
;
return
false
;
}
aMappedSurface
-
>
mData
=
mVBufPtr
;
aMappedSurface
-
>
mStride
=
mStride
;
+
+
mMapCount
;
return
true
;
}
void
Unmap
(
)
override
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mMapCount
>
0
)
;
MOZ_ASSERT
(
!
mWasPurged
)
;
if
(
-
-
mMapCount
=
=
0
)
{
mVBufPtr
=
nullptr
;
}
}
private
:
virtual
~
SourceSurfaceVolatileData
(
)
=
default
;
Mutex
mMutex
;
int32_t
mStride
;
IntSize
mSize
;
RefPtr
<
VolatileBuffer
>
mVBuf
;
VolatileBufferPtr
<
uint8_t
>
mVBufPtr
;
SurfaceFormat
mFormat
;
bool
mWasPurged
;
}
;
}
}
#
endif
