#
ifndef
mozilla_layers_AnimationHelper_h
#
define
mozilla_layers_AnimationHelper_h
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
#
include
"
mozilla
/
ComputedTimingFunction
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderTypes
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
TimingParams
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
X11UndefineNone
.
h
"
namespace
mozilla
{
struct
AnimationValue
;
namespace
dom
{
enum
class
CompositeOperation
:
uint8_t
;
enum
class
IterationCompositeOperation
:
uint8_t
;
}
;
namespace
layers
{
class
Animation
;
typedef
nsTArray
<
layers
:
:
Animation
>
AnimationArray
;
struct
PropertyAnimation
{
struct
SegmentData
{
RefPtr
<
RawServoAnimationValue
>
mStartValue
;
RefPtr
<
RawServoAnimationValue
>
mEndValue
;
Maybe
<
mozilla
:
:
ComputedTimingFunction
>
mFunction
;
float
mStartPortion
;
float
mEndPortion
;
dom
:
:
CompositeOperation
mStartComposite
;
dom
:
:
CompositeOperation
mEndComposite
;
}
;
nsTArray
<
SegmentData
>
mSegments
;
TimingParams
mTiming
;
dom
:
:
Nullable
<
double
>
mProgressOnLastCompose
;
uint64_t
mCurrentIterationOnLastCompose
=
0
;
uint32_t
mSegmentIndexOnLastCompose
=
0
;
dom
:
:
Nullable
<
double
>
mPortionInSegmentOnLastCompose
;
TimeStamp
mOriginTime
;
Maybe
<
TimeDuration
>
mStartTime
;
TimeDuration
mHoldTime
;
float
mPlaybackRate
;
dom
:
:
IterationCompositeOperation
mIterationComposite
;
bool
mIsNotPlaying
;
}
;
struct
PropertyAnimationGroup
{
nsCSSPropertyID
mProperty
;
Maybe
<
TransformData
>
mAnimationData
;
nsTArray
<
PropertyAnimation
>
mAnimations
;
RefPtr
<
RawServoAnimationValue
>
mBaseStyle
;
bool
IsEmpty
(
)
const
{
return
mAnimations
.
IsEmpty
(
)
;
}
void
Clear
(
)
{
mAnimations
.
Clear
(
)
;
mBaseStyle
=
nullptr
;
}
}
;
struct
AnimationTransform
{
gfx
:
:
Matrix4x4
mTransformInDevSpace
;
gfx
:
:
Matrix4x4
mFrameTransform
;
TransformData
mData
;
}
;
struct
AnimatedValue
final
{
typedef
Variant
<
AnimationTransform
float
nscolor
>
AnimatedValueType
;
const
AnimatedValueType
&
Value
(
)
const
{
return
mValue
;
}
const
AnimationTransform
&
Transform
(
)
const
{
return
mValue
.
as
<
AnimationTransform
>
(
)
;
}
const
float
&
Opacity
(
)
const
{
return
mValue
.
as
<
float
>
(
)
;
}
const
nscolor
&
Color
(
)
const
{
return
mValue
.
as
<
nscolor
>
(
)
;
}
template
<
typename
T
>
bool
Is
(
)
const
{
return
mValue
.
is
<
T
>
(
)
;
}
AnimatedValue
(
gfx
:
:
Matrix4x4
&
&
aTransformInDevSpace
gfx
:
:
Matrix4x4
&
&
aFrameTransform
const
TransformData
&
aData
)
:
mValue
(
AsVariant
(
AnimationTransform
{
std
:
:
move
(
aTransformInDevSpace
)
std
:
:
move
(
aFrameTransform
)
aData
}
)
)
{
}
explicit
AnimatedValue
(
const
float
&
aValue
)
:
mValue
(
AsVariant
(
aValue
)
)
{
}
explicit
AnimatedValue
(
nscolor
aValue
)
:
mValue
(
AsVariant
(
aValue
)
)
{
}
private
:
AnimatedValueType
mValue
;
}
;
struct
AnimationStorageData
{
nsTArray
<
PropertyAnimationGroup
>
mAnimation
;
RefPtr
<
gfx
:
:
Path
>
mCachedMotionPath
;
AnimationStorageData
(
)
=
default
;
AnimationStorageData
(
AnimationStorageData
&
&
aOther
)
=
default
;
AnimationStorageData
&
operator
=
(
AnimationStorageData
&
&
aOther
)
=
default
;
AnimationStorageData
(
const
AnimationStorageData
&
aOther
)
=
delete
;
AnimationStorageData
&
operator
=
(
const
AnimationStorageData
&
aOther
)
=
delete
;
}
;
class
CompositorAnimationStorage
final
{
typedef
nsClassHashtable
<
nsUint64HashKey
AnimatedValue
>
AnimatedValueTable
;
typedef
nsDataHashtable
<
nsUint64HashKey
AnimationStorageData
>
AnimationsTable
;
typedef
nsDataHashtable
<
nsUint64HashKey
wr
:
:
RenderRoot
>
AnimationsRenderRootsTable
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
CompositorAnimationStorage
)
public
:
void
SetAnimatedValue
(
uint64_t
aId
gfx
:
:
Matrix4x4
&
&
aTransformInDevSpace
gfx
:
:
Matrix4x4
&
&
aFrameTransform
const
TransformData
&
aData
)
;
void
SetAnimatedValue
(
uint64_t
aId
gfx
:
:
Matrix4x4
&
&
aTransformInDevSpace
)
;
void
SetAnimatedValue
(
uint64_t
aId
const
float
&
aOpacity
)
;
void
SetAnimatedValue
(
uint64_t
aId
nscolor
aColor
)
;
AnimatedValue
*
GetAnimatedValue
(
const
uint64_t
&
aId
)
const
;
OMTAValue
GetOMTAValue
(
const
uint64_t
&
aId
)
const
;
AnimatedValueTable
:
:
Iterator
ConstAnimatedValueTableIter
(
)
const
{
return
mAnimatedValues
.
ConstIter
(
)
;
}
uint32_t
AnimatedValueCount
(
)
const
{
return
mAnimatedValues
.
Count
(
)
;
}
void
SetAnimations
(
uint64_t
aId
const
AnimationArray
&
aAnimations
wr
:
:
RenderRoot
aRenderRoot
)
;
AnimationsTable
:
:
Iterator
ConstAnimationsTableIter
(
)
const
{
return
mAnimations
.
ConstIter
(
)
;
}
uint32_t
AnimationsCount
(
)
const
{
return
mAnimations
.
Count
(
)
;
}
wr
:
:
RenderRoot
AnimationRenderRoot
(
const
uint64_t
&
aId
)
const
{
return
mAnimationRenderRoots
.
Get
(
aId
)
;
}
void
Clear
(
)
;
void
ClearById
(
const
uint64_t
&
aId
)
;
private
:
~
CompositorAnimationStorage
(
)
{
}
;
private
:
AnimatedValueTable
mAnimatedValues
;
AnimationsTable
mAnimations
;
AnimationsRenderRootsTable
mAnimationRenderRoots
;
}
;
class
AnimationHelper
{
public
:
enum
class
SampleResult
{
None
Skipped
Sampled
}
;
static
SampleResult
SampleAnimationForEachNode
(
TimeStamp
aPreviousFrameTime
TimeStamp
aCurrentFrameTime
const
AnimatedValue
*
aPreviousValue
nsTArray
<
PropertyAnimationGroup
>
&
aPropertyAnimationGroups
nsTArray
<
RefPtr
<
RawServoAnimationValue
>
>
&
aAnimationValues
)
;
static
AnimationStorageData
ExtractAnimations
(
const
AnimationArray
&
aAnimations
)
;
static
uint64_t
GetNextCompositorAnimationsId
(
)
;
static
bool
SampleAnimations
(
CompositorAnimationStorage
*
aStorage
TimeStamp
aPreviousFrameTime
TimeStamp
aCurrentFrameTime
)
;
static
gfx
:
:
Matrix4x4
ServoAnimationValueToMatrix4x4
(
const
nsTArray
<
RefPtr
<
RawServoAnimationValue
>
>
&
aValue
const
TransformData
&
aTransformData
gfx
:
:
Path
*
aCachedMotionPath
)
;
}
;
}
}
#
endif
