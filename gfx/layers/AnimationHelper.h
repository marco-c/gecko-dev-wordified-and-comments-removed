#
ifndef
mozilla_layers_AnimationHelper_h
#
define
mozilla_layers_AnimationHelper_h
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
#
include
"
mozilla
/
ComputedTimingFunction
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
TimingParams
.
h
"
#
include
"
X11UndefineNone
.
h
"
namespace
mozilla
{
struct
AnimationValue
;
namespace
layers
{
class
Animation
;
typedef
InfallibleTArray
<
layers
:
:
Animation
>
AnimationArray
;
struct
AnimData
{
InfallibleTArray
<
RefPtr
<
RawServoAnimationValue
>
>
mStartValues
;
InfallibleTArray
<
RefPtr
<
RawServoAnimationValue
>
>
mEndValues
;
InfallibleTArray
<
Maybe
<
mozilla
:
:
ComputedTimingFunction
>
>
mFunctions
;
TimingParams
mTiming
;
dom
:
:
Nullable
<
double
>
mProgressOnLastCompose
;
uint64_t
mCurrentIterationOnLastCompose
=
0
;
uint32_t
mSegmentIndexOnLastCompose
=
0
;
dom
:
:
Nullable
<
double
>
mPortionInSegmentOnLastCompose
;
}
;
struct
AnimationTransform
{
gfx
:
:
Matrix4x4
mTransformInDevSpace
;
gfx
:
:
Matrix4x4
mFrameTransform
;
TransformData
mData
;
}
;
struct
AnimatedValue
{
enum
{
TRANSFORM
OPACITY
NONE
}
mType
{
NONE
}
;
union
{
AnimationTransform
mTransform
;
float
mOpacity
;
}
;
AnimatedValue
(
gfx
:
:
Matrix4x4
&
&
aTransformInDevSpace
gfx
:
:
Matrix4x4
&
&
aFrameTransform
const
TransformData
&
aData
)
:
mType
(
AnimatedValue
:
:
TRANSFORM
)
{
mTransform
.
mTransformInDevSpace
=
Move
(
aTransformInDevSpace
)
;
mTransform
.
mFrameTransform
=
Move
(
aFrameTransform
)
;
mTransform
.
mData
=
aData
;
}
explicit
AnimatedValue
(
const
float
&
aValue
)
:
mType
(
AnimatedValue
:
:
OPACITY
)
mOpacity
(
aValue
)
{
}
~
AnimatedValue
(
)
{
}
private
:
AnimatedValue
(
)
=
delete
;
}
;
class
CompositorAnimationStorage
final
{
typedef
nsClassHashtable
<
nsUint64HashKey
AnimatedValue
>
AnimatedValueTable
;
typedef
nsClassHashtable
<
nsUint64HashKey
AnimationArray
>
AnimationsTable
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
CompositorAnimationStorage
)
public
:
void
SetAnimatedValue
(
uint64_t
aId
gfx
:
:
Matrix4x4
&
&
aTransformInDevSpace
gfx
:
:
Matrix4x4
&
&
aFrameTransform
const
TransformData
&
aData
)
;
void
SetAnimatedValue
(
uint64_t
aId
gfx
:
:
Matrix4x4
&
&
aTransformInDevSpace
)
;
void
SetAnimatedValue
(
uint64_t
aId
const
float
&
aOpacity
)
;
AnimatedValue
*
GetAnimatedValue
(
const
uint64_t
&
aId
)
const
;
Maybe
<
float
>
GetAnimationOpacity
(
const
uint64_t
&
aId
)
const
;
Maybe
<
gfx
:
:
Matrix4x4
>
GetAnimationTransform
(
const
uint64_t
&
aId
)
const
;
AnimatedValueTable
:
:
Iterator
ConstAnimatedValueTableIter
(
)
const
{
return
mAnimatedValues
.
ConstIter
(
)
;
}
uint32_t
AnimatedValueCount
(
)
const
{
return
mAnimatedValues
.
Count
(
)
;
}
void
SetAnimations
(
uint64_t
aId
const
AnimationArray
&
aAnimations
)
;
AnimationArray
*
GetAnimations
(
const
uint64_t
&
aId
)
const
;
AnimationsTable
:
:
Iterator
ConstAnimationsTableIter
(
)
const
{
return
mAnimations
.
ConstIter
(
)
;
}
uint32_t
AnimationsCount
(
)
const
{
return
mAnimations
.
Count
(
)
;
}
void
Clear
(
)
;
void
ClearById
(
const
uint64_t
&
aId
)
;
private
:
~
CompositorAnimationStorage
(
)
{
}
;
private
:
AnimatedValueTable
mAnimatedValues
;
AnimationsTable
mAnimations
;
}
;
class
AnimationHelper
{
public
:
enum
class
SampleResult
{
None
Skipped
Sampled
}
;
static
SampleResult
SampleAnimationForEachNode
(
TimeStamp
aPreviousFrameTime
TimeStamp
aCurrentFrameTime
AnimationArray
&
aAnimations
InfallibleTArray
<
AnimData
>
&
aAnimationData
RefPtr
<
RawServoAnimationValue
>
&
aAnimationValue
)
;
static
void
SetAnimations
(
AnimationArray
&
aAnimations
InfallibleTArray
<
AnimData
>
&
aAnimData
RefPtr
<
RawServoAnimationValue
>
&
aBaseAnimationStyle
)
;
static
uint64_t
GetNextCompositorAnimationsId
(
)
;
static
void
SampleAnimations
(
CompositorAnimationStorage
*
aStorage
TimeStamp
aPreviousFrameTime
TimeStamp
aCurrentFrameTime
)
;
}
;
}
}
#
endif
