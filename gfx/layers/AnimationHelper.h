#
ifndef
mozilla_layers_AnimationHelper_h
#
define
mozilla_layers_AnimationHelper_h
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
#
include
"
mozilla
/
ComputedTimingFunction
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
TimingParams
.
h
"
#
include
"
X11UndefineNone
.
h
"
namespace
mozilla
{
struct
AnimationValue
;
namespace
dom
{
enum
class
CompositeOperation
:
uint8_t
;
enum
class
IterationCompositeOperation
:
uint8_t
;
}
;
namespace
layers
{
class
Animation
;
typedef
nsTArray
<
layers
:
:
Animation
>
AnimationArray
;
struct
PropertyAnimation
{
struct
SegmentData
{
RefPtr
<
RawServoAnimationValue
>
mStartValue
;
RefPtr
<
RawServoAnimationValue
>
mEndValue
;
Maybe
<
mozilla
:
:
ComputedTimingFunction
>
mFunction
;
float
mStartPortion
;
float
mEndPortion
;
dom
:
:
CompositeOperation
mStartComposite
;
dom
:
:
CompositeOperation
mEndComposite
;
}
;
nsTArray
<
SegmentData
>
mSegments
;
TimingParams
mTiming
;
dom
:
:
Nullable
<
double
>
mProgressOnLastCompose
;
uint64_t
mCurrentIterationOnLastCompose
=
0
;
uint32_t
mSegmentIndexOnLastCompose
=
0
;
dom
:
:
Nullable
<
double
>
mPortionInSegmentOnLastCompose
;
TimeStamp
mOriginTime
;
MaybeTimeDuration
mStartTime
;
TimeDuration
mHoldTime
;
float
mPlaybackRate
;
dom
:
:
IterationCompositeOperation
mIterationComposite
;
bool
mIsNotPlaying
;
}
;
struct
PropertyAnimationGroup
{
nsCSSPropertyID
mProperty
;
AnimationData
mAnimationData
;
nsTArray
<
PropertyAnimation
>
mAnimations
;
RefPtr
<
RawServoAnimationValue
>
mBaseStyle
;
bool
IsEmpty
(
)
const
{
return
mAnimations
.
IsEmpty
(
)
;
}
void
Clear
(
)
{
mAnimations
.
Clear
(
)
;
mBaseStyle
=
nullptr
;
}
}
;
struct
AnimationTransform
{
gfx
:
:
Matrix4x4
mTransformInDevSpace
;
gfx
:
:
Matrix4x4
mFrameTransform
;
TransformData
mData
;
}
;
struct
AnimatedValue
{
enum
{
TRANSFORM
OPACITY
COLOR
NONE
}
mType
{
NONE
}
;
union
{
AnimationTransform
mTransform
;
float
mOpacity
;
nscolor
mColor
;
}
;
AnimatedValue
(
gfx
:
:
Matrix4x4
&
&
aTransformInDevSpace
gfx
:
:
Matrix4x4
&
&
aFrameTransform
const
TransformData
&
aData
)
:
mType
(
AnimatedValue
:
:
TRANSFORM
)
mOpacity
(
0
.
0
)
{
mTransform
.
mTransformInDevSpace
=
std
:
:
move
(
aTransformInDevSpace
)
;
mTransform
.
mFrameTransform
=
std
:
:
move
(
aFrameTransform
)
;
mTransform
.
mData
=
aData
;
}
explicit
AnimatedValue
(
const
float
&
aValue
)
:
mType
(
AnimatedValue
:
:
OPACITY
)
mOpacity
(
aValue
)
{
}
explicit
AnimatedValue
(
nscolor
aValue
)
:
mType
(
AnimatedValue
:
:
COLOR
)
mColor
(
aValue
)
{
}
~
AnimatedValue
(
)
{
}
private
:
AnimatedValue
(
)
=
delete
;
}
;
class
CompositorAnimationStorage
final
{
typedef
nsClassHashtable
<
nsUint64HashKey
AnimatedValue
>
AnimatedValueTable
;
typedef
nsClassHashtable
<
nsUint64HashKey
nsTArray
<
PropertyAnimationGroup
>
>
AnimationsTable
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
CompositorAnimationStorage
)
public
:
void
SetAnimatedValue
(
uint64_t
aId
gfx
:
:
Matrix4x4
&
&
aTransformInDevSpace
gfx
:
:
Matrix4x4
&
&
aFrameTransform
const
TransformData
&
aData
)
;
void
SetAnimatedValue
(
uint64_t
aId
gfx
:
:
Matrix4x4
&
&
aTransformInDevSpace
)
;
void
SetAnimatedValue
(
uint64_t
aId
const
float
&
aOpacity
)
;
void
SetAnimatedValue
(
uint64_t
aId
nscolor
aColor
)
;
AnimatedValue
*
GetAnimatedValue
(
const
uint64_t
&
aId
)
const
;
OMTAValue
GetOMTAValue
(
const
uint64_t
&
aId
)
const
;
AnimatedValueTable
:
:
Iterator
ConstAnimatedValueTableIter
(
)
const
{
return
mAnimatedValues
.
ConstIter
(
)
;
}
uint32_t
AnimatedValueCount
(
)
const
{
return
mAnimatedValues
.
Count
(
)
;
}
void
SetAnimations
(
uint64_t
aId
const
AnimationArray
&
aAnimations
)
;
nsTArray
<
PropertyAnimationGroup
>
*
GetAnimations
(
const
uint64_t
&
aId
)
const
;
AnimationsTable
:
:
Iterator
ConstAnimationsTableIter
(
)
const
{
return
mAnimations
.
ConstIter
(
)
;
}
uint32_t
AnimationsCount
(
)
const
{
return
mAnimations
.
Count
(
)
;
}
void
Clear
(
)
;
void
ClearById
(
const
uint64_t
&
aId
)
;
private
:
~
CompositorAnimationStorage
(
)
{
}
;
private
:
AnimatedValueTable
mAnimatedValues
;
AnimationsTable
mAnimations
;
}
;
class
AnimationHelper
{
public
:
enum
class
SampleResult
{
None
Skipped
Sampled
}
;
static
SampleResult
SampleAnimationForEachNode
(
TimeStamp
aPreviousFrameTime
TimeStamp
aCurrentFrameTime
nsTArray
<
PropertyAnimationGroup
>
&
aPropertyAnimationGroups
RefPtr
<
RawServoAnimationValue
>
&
aAnimationValue
const
AnimatedValue
*
aPreviousValue
)
;
static
nsTArray
<
PropertyAnimationGroup
>
ExtractAnimations
(
const
AnimationArray
&
aAnimations
)
;
static
uint64_t
GetNextCompositorAnimationsId
(
)
;
static
bool
SampleAnimations
(
CompositorAnimationStorage
*
aStorage
TimeStamp
aPreviousFrameTime
TimeStamp
aCurrentFrameTime
)
;
static
gfx
:
:
Matrix4x4
ServoAnimationValueToMatrix4x4
(
const
RefPtr
<
RawServoAnimationValue
>
&
aValue
const
TransformData
&
aTransformData
)
;
}
;
}
}
#
endif
