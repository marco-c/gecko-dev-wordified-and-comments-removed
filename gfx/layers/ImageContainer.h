#
ifndef
GFX_IMAGECONTAINER_H
#
define
GFX_IMAGECONTAINER_H
#
include
<
stdint
.
h
>
#
include
"
ImageTypes
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
RecursiveMutex
.
h
"
#
include
"
mozilla
/
ThreadSafeWeakPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
nsTHashMap
.
h
"
#
ifdef
XP_WIN
struct
ID3D10Texture2D
;
struct
ID3D10Device
;
struct
ID3D10ShaderResourceView
;
#
endif
typedef
void
*
HANDLE
;
namespace
mozilla
{
namespace
layers
{
class
ImageClient
;
class
ImageCompositeNotification
;
class
ImageContainer
;
class
ImageContainerChild
;
class
SharedPlanarYCbCrImage
;
class
SurfaceDescriptor
;
class
PlanarYCbCrImage
;
class
TextureClient
;
class
TextureClientRecycleAllocator
;
class
KnowsCompositor
;
class
NVImage
;
class
MemoryOrShmem
;
#
ifdef
XP_WIN
class
D3D11YCbCrRecycleAllocator
;
#
endif
#
ifdef
XP_MACOSX
class
MacIOSurfaceRecycleAllocator
;
#
endif
class
SurfaceDescriptorBuffer
;
struct
ImageBackendData
{
virtual
~
ImageBackendData
(
)
=
default
;
protected
:
ImageBackendData
(
)
=
default
;
}
;
class
GLImage
;
class
SharedRGBImage
;
#
ifdef
MOZ_WIDGET_ANDROID
class
SurfaceTextureImage
;
#
elif
defined
(
XP_MACOSX
)
class
MacIOSurfaceImage
;
#
elif
MOZ_WAYLAND
class
DMABUFSurfaceImage
;
#
endif
class
Image
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Image
)
public
:
ImageFormat
GetFormat
(
)
const
{
return
mFormat
;
}
void
*
GetImplData
(
)
const
{
return
mImplData
;
}
virtual
gfx
:
:
IntSize
GetSize
(
)
const
=
0
;
virtual
gfx
:
:
IntPoint
GetOrigin
(
)
const
{
return
gfx
:
:
IntPoint
(
0
0
)
;
}
virtual
gfx
:
:
IntRect
GetPictureRect
(
)
const
{
return
gfx
:
:
IntRect
(
GetOrigin
(
)
.
x
GetOrigin
(
)
.
y
GetSize
(
)
.
width
GetSize
(
)
.
height
)
;
}
ImageBackendData
*
GetBackendData
(
LayersBackend
aBackend
)
{
return
mBackendData
[
aBackend
]
.
get
(
)
;
}
void
SetBackendData
(
LayersBackend
aBackend
ImageBackendData
*
aData
)
{
mBackendData
[
aBackend
]
=
mozilla
:
:
WrapUnique
(
aData
)
;
}
int32_t
GetSerial
(
)
const
{
return
mSerial
;
}
virtual
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetAsSourceSurface
(
)
=
0
;
virtual
bool
IsValid
(
)
const
{
return
true
;
}
virtual
TextureClient
*
GetTextureClient
(
KnowsCompositor
*
aKnowsCompositor
)
{
return
nullptr
;
}
virtual
GLImage
*
AsGLImage
(
)
{
return
nullptr
;
}
#
ifdef
MOZ_WIDGET_ANDROID
virtual
SurfaceTextureImage
*
AsSurfaceTextureImage
(
)
{
return
nullptr
;
}
#
endif
#
ifdef
XP_MACOSX
virtual
MacIOSurfaceImage
*
AsMacIOSurfaceImage
(
)
{
return
nullptr
;
}
#
endif
virtual
PlanarYCbCrImage
*
AsPlanarYCbCrImage
(
)
{
return
nullptr
;
}
#
ifdef
MOZ_WAYLAND
virtual
DMABUFSurfaceImage
*
AsDMABUFSurfaceImage
(
)
{
return
nullptr
;
}
#
endif
virtual
NVImage
*
AsNVImage
(
)
{
return
nullptr
;
}
virtual
Maybe
<
SurfaceDescriptor
>
GetDesc
(
)
;
protected
:
Maybe
<
SurfaceDescriptor
>
GetDescFromTexClient
(
TextureClient
*
tcOverride
=
nullptr
)
;
Image
(
void
*
aImplData
ImageFormat
aFormat
)
:
mImplData
(
aImplData
)
mSerial
(
+
+
sSerialCounter
)
mFormat
(
aFormat
)
{
}
virtual
~
Image
(
)
=
default
;
mozilla
:
:
EnumeratedArray
<
mozilla
:
:
layers
:
:
LayersBackend
mozilla
:
:
layers
:
:
LayersBackend
:
:
LAYERS_LAST
UniquePtr
<
ImageBackendData
>
>
mBackendData
;
void
*
mImplData
;
int32_t
mSerial
;
ImageFormat
mFormat
;
static
mozilla
:
:
Atomic
<
int32_t
>
sSerialCounter
;
}
;
class
BufferRecycleBin
final
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
BufferRecycleBin
)
public
:
BufferRecycleBin
(
)
;
void
RecycleBuffer
(
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
aBuffer
uint32_t
aSize
)
;
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
GetBuffer
(
uint32_t
aSize
)
;
virtual
void
ClearRecycledBuffers
(
)
;
private
:
typedef
mozilla
:
:
Mutex
Mutex
;
~
BufferRecycleBin
(
)
=
default
;
Mutex
mLock
MOZ_UNANNOTATED
;
nsTArray
<
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
>
mRecycledBuffers
;
uint32_t
mRecycledBufferSize
;
}
;
class
ImageFactory
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ImageFactory
)
protected
:
friend
class
ImageContainer
;
ImageFactory
(
)
=
default
;
virtual
~
ImageFactory
(
)
=
default
;
virtual
RefPtr
<
PlanarYCbCrImage
>
CreatePlanarYCbCrImage
(
const
gfx
:
:
IntSize
&
aScaleHint
BufferRecycleBin
*
aRecycleBin
)
;
}
;
class
ImageContainerListener
final
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ImageContainerListener
)
public
:
explicit
ImageContainerListener
(
ImageContainer
*
aImageContainer
)
;
void
NotifyComposite
(
const
ImageCompositeNotification
&
aNotification
)
;
void
NotifyDropped
(
uint32_t
aDropped
)
;
void
ClearImageContainer
(
)
;
void
DropImageClient
(
)
;
private
:
typedef
mozilla
:
:
Mutex
Mutex
;
~
ImageContainerListener
(
)
;
Mutex
mLock
MOZ_UNANNOTATED
;
ImageContainer
*
mImageContainer
;
}
;
class
ImageContainer
final
:
public
SupportsThreadSafeWeakPtr
<
ImageContainer
>
{
friend
class
ImageContainerChild
;
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
ImageContainer
)
enum
Mode
{
SYNCHRONOUS
=
0x0
ASYNCHRONOUS
=
0x01
}
;
static
const
uint64_t
sInvalidAsyncContainerId
=
0
;
explicit
ImageContainer
(
ImageContainer
:
:
Mode
flag
=
SYNCHRONOUS
)
;
explicit
ImageContainer
(
const
CompositableHandle
&
aHandle
)
;
~
ImageContainer
(
)
;
typedef
ContainerFrameID
FrameID
;
typedef
ContainerProducerID
ProducerID
;
RefPtr
<
PlanarYCbCrImage
>
CreatePlanarYCbCrImage
(
)
;
RefPtr
<
SharedRGBImage
>
CreateSharedRGBImage
(
)
;
struct
NonOwningImage
{
explicit
NonOwningImage
(
Image
*
aImage
=
nullptr
TimeStamp
aTimeStamp
=
TimeStamp
(
)
FrameID
aFrameID
=
0
ProducerID
aProducerID
=
0
)
:
mImage
(
aImage
)
mTimeStamp
(
aTimeStamp
)
mFrameID
(
aFrameID
)
mProducerID
(
aProducerID
)
{
}
Image
*
mImage
;
TimeStamp
mTimeStamp
;
FrameID
mFrameID
;
ProducerID
mProducerID
;
}
;
void
SetCurrentImages
(
const
nsTArray
<
NonOwningImage
>
&
aImages
)
;
void
ClearAllImages
(
)
;
void
ClearCachedResources
(
)
;
void
ClearImagesFromImageBridge
(
)
;
void
SetCurrentImageInTransaction
(
Image
*
aImage
)
;
void
SetCurrentImagesInTransaction
(
const
nsTArray
<
NonOwningImage
>
&
aImages
)
;
bool
IsAsync
(
)
const
;
CompositableHandle
GetAsyncContainerHandle
(
)
;
bool
HasCurrentImage
(
)
;
struct
OwningImage
{
OwningImage
(
)
:
mFrameID
(
0
)
mProducerID
(
0
)
mComposited
(
false
)
{
}
RefPtr
<
Image
>
mImage
;
TimeStamp
mTimeStamp
;
FrameID
mFrameID
;
ProducerID
mProducerID
;
bool
mComposited
;
}
;
void
GetCurrentImages
(
nsTArray
<
OwningImage
>
*
aImages
uint32_t
*
aGenerationCounter
=
nullptr
)
;
gfx
:
:
IntSize
GetCurrentSize
(
)
;
void
SetScaleHint
(
const
gfx
:
:
IntSize
&
aScaleHint
)
{
mScaleHint
=
aScaleHint
;
}
const
gfx
:
:
IntSize
&
GetScaleHint
(
)
const
{
return
mScaleHint
;
}
void
SetTransformHint
(
const
gfx
:
:
Matrix
&
aTransformHint
)
{
mTransformHint
=
aTransformHint
;
}
const
gfx
:
:
Matrix
&
GetTransformHint
(
)
const
{
return
mTransformHint
;
}
void
SetRotation
(
VideoInfo
:
:
Rotation
aRotation
)
{
mRotation
=
aRotation
;
}
VideoInfo
:
:
Rotation
GetRotation
(
)
const
{
return
mRotation
;
}
void
SetImageFactory
(
ImageFactory
*
aFactory
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
mImageFactory
=
aFactory
?
aFactory
:
new
ImageFactory
(
)
;
}
ImageFactory
*
GetImageFactory
(
)
const
{
return
mImageFactory
;
}
void
EnsureRecycleAllocatorForRDD
(
KnowsCompositor
*
aKnowsCompositor
)
;
#
ifdef
XP_WIN
D3D11YCbCrRecycleAllocator
*
GetD3D11YCbCrRecycleAllocator
(
KnowsCompositor
*
aKnowsCompositor
)
;
#
endif
#
ifdef
XP_MACOSX
MacIOSurfaceRecycleAllocator
*
GetMacIOSurfaceRecycleAllocator
(
)
;
#
endif
TimeDuration
GetPaintDelay
(
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
mPaintDelay
;
}
uint32_t
GetPaintCount
(
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
mPaintCount
;
}
uint32_t
GetDroppedImageCount
(
)
{
return
mDroppedImageCount
;
}
void
NotifyComposite
(
const
ImageCompositeNotification
&
aNotification
)
;
void
NotifyDropped
(
uint32_t
aDropped
)
;
ImageContainerListener
*
GetImageContainerListener
(
)
{
return
mNotifyCompositeListener
;
}
already_AddRefed
<
ImageClient
>
GetImageClient
(
)
;
static
ProducerID
AllocateProducerID
(
)
;
void
DropImageClient
(
)
;
private
:
typedef
mozilla
:
:
RecursiveMutex
RecursiveMutex
;
void
SetCurrentImageInternal
(
const
nsTArray
<
NonOwningImage
>
&
aImages
)
;
void
EnsureActiveImage
(
)
;
void
EnsureImageClient
(
)
;
RecursiveMutex
mRecursiveMutex
MOZ_UNANNOTATED
;
RefPtr
<
TextureClientRecycleAllocator
>
mRecycleAllocator
;
#
ifdef
XP_WIN
RefPtr
<
D3D11YCbCrRecycleAllocator
>
mD3D11YCbCrRecycleAllocator
;
#
endif
#
ifdef
XP_MACOSX
RefPtr
<
MacIOSurfaceRecycleAllocator
>
mMacIOSurfaceRecycleAllocator
;
#
endif
nsTArray
<
OwningImage
>
mCurrentImages
;
uint32_t
mGenerationCounter
;
uint32_t
mPaintCount
;
TimeDuration
mPaintDelay
;
mozilla
:
:
Atomic
<
uint32_t
>
mDroppedImageCount
;
RefPtr
<
ImageFactory
>
mImageFactory
;
gfx
:
:
IntSize
mScaleHint
;
gfx
:
:
Matrix
mTransformHint
;
VideoInfo
:
:
Rotation
mRotation
=
VideoInfo
:
:
Rotation
:
:
kDegree_0
;
RefPtr
<
BufferRecycleBin
>
mRecycleBin
;
RefPtr
<
ImageClient
>
mImageClient
;
bool
mIsAsync
;
CompositableHandle
mAsyncContainerHandle
;
ProducerID
mCurrentProducerID
;
RefPtr
<
ImageContainerListener
>
mNotifyCompositeListener
;
static
mozilla
:
:
Atomic
<
uint32_t
>
sGenerationCounter
;
}
;
class
AutoLockImage
{
public
:
explicit
AutoLockImage
(
ImageContainer
*
aContainer
)
{
aContainer
-
>
GetCurrentImages
(
&
mImages
)
;
}
bool
HasImage
(
)
const
{
return
!
mImages
.
IsEmpty
(
)
;
}
Image
*
GetImage
(
)
const
{
return
mImages
.
IsEmpty
(
)
?
nullptr
:
mImages
[
0
]
.
mImage
.
get
(
)
;
}
Image
*
GetImage
(
TimeStamp
aTimeStamp
)
const
{
if
(
mImages
.
IsEmpty
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
!
aTimeStamp
.
IsNull
(
)
)
;
uint32_t
chosenIndex
=
0
;
while
(
chosenIndex
+
1
<
mImages
.
Length
(
)
&
&
mImages
[
chosenIndex
+
1
]
.
mTimeStamp
<
=
aTimeStamp
)
{
+
+
chosenIndex
;
}
return
mImages
[
chosenIndex
]
.
mImage
.
get
(
)
;
}
private
:
AutoTArray
<
ImageContainer
:
:
OwningImage
4
>
mImages
;
}
;
struct
PlanarYCbCrData
{
uint8_t
*
mYChannel
=
nullptr
;
int32_t
mYStride
=
0
;
int32_t
mYSkip
=
0
;
uint8_t
*
mCbChannel
=
nullptr
;
uint8_t
*
mCrChannel
=
nullptr
;
int32_t
mCbCrStride
=
0
;
int32_t
mCbSkip
=
0
;
int32_t
mCrSkip
=
0
;
gfx
:
:
IntRect
mPictureRect
=
gfx
:
:
IntRect
(
0
0
0
0
)
;
StereoMode
mStereoMode
=
StereoMode
:
:
MONO
;
gfx
:
:
ColorDepth
mColorDepth
=
gfx
:
:
ColorDepth
:
:
COLOR_8
;
gfx
:
:
YUVColorSpace
mYUVColorSpace
=
gfx
:
:
YUVColorSpace
:
:
Default
;
gfx
:
:
TransferFunction
mTransferFunction
=
gfx
:
:
TransferFunction
:
:
BT709
;
gfx
:
:
ColorRange
mColorRange
=
gfx
:
:
ColorRange
:
:
LIMITED
;
gfx
:
:
ChromaSubsampling
mChromaSubsampling
=
gfx
:
:
ChromaSubsampling
:
:
FULL
;
gfx
:
:
IntSize
YPictureSize
(
)
const
{
return
mPictureRect
.
Size
(
)
;
}
gfx
:
:
IntSize
CbCrPictureSize
(
)
const
{
return
mCbCrStride
>
0
?
gfx
:
:
ChromaSize
(
YPictureSize
(
)
mChromaSubsampling
)
:
gfx
:
:
IntSize
(
0
0
)
;
}
gfx
:
:
IntSize
YDataSize
(
)
const
{
return
gfx
:
:
IntSize
(
mPictureRect
.
XMost
(
)
mPictureRect
.
YMost
(
)
)
;
}
gfx
:
:
IntSize
CbCrDataSize
(
)
const
{
return
mCbCrStride
>
0
?
gfx
:
:
ChromaSize
(
YDataSize
(
)
mChromaSubsampling
)
:
gfx
:
:
IntSize
(
0
0
)
;
}
static
Maybe
<
PlanarYCbCrData
>
From
(
const
SurfaceDescriptorBuffer
&
)
;
}
;
struct
PlanarAlphaData
{
uint8_t
*
mChannel
=
nullptr
;
gfx
:
:
IntSize
mSize
=
gfx
:
:
IntSize
(
0
0
)
;
gfx
:
:
ColorDepth
mDepth
=
gfx
:
:
ColorDepth
:
:
COLOR_8
;
bool
mPremultiplied
=
false
;
}
;
class
PlanarYCbCrImage
:
public
Image
{
public
:
typedef
PlanarYCbCrData
Data
;
enum
{
MAX_DIMENSION
=
16384
}
;
virtual
~
PlanarYCbCrImage
(
)
;
virtual
bool
CopyData
(
const
Data
&
aData
)
=
0
;
virtual
bool
AdoptData
(
const
Data
&
aData
)
;
virtual
bool
CreateEmptyBuffer
(
const
Data
&
aData
const
gfx
:
:
IntSize
&
aYSize
const
gfx
:
:
IntSize
&
aCbCrSize
)
{
return
false
;
}
bool
CreateEmptyBuffer
(
const
Data
&
aData
)
{
return
CreateEmptyBuffer
(
aData
aData
.
YDataSize
(
)
aData
.
CbCrDataSize
(
)
)
;
}
virtual
const
Data
*
GetData
(
)
const
{
return
&
mData
;
}
uint32_t
GetDataSize
(
)
const
{
return
mBufferSize
;
}
bool
IsValid
(
)
const
override
{
return
!
!
mBufferSize
;
}
gfx
:
:
IntSize
GetSize
(
)
const
override
{
return
mSize
;
}
gfx
:
:
IntPoint
GetOrigin
(
)
const
override
{
return
mOrigin
;
}
PlanarYCbCrImage
(
)
;
virtual
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
virtual
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
=
0
;
PlanarYCbCrImage
*
AsPlanarYCbCrImage
(
)
override
{
return
this
;
}
virtual
nsresult
BuildSurfaceDescriptorBuffer
(
SurfaceDescriptorBuffer
&
aSdBuffer
const
std
:
:
function
<
MemoryOrShmem
(
uint32_t
)
>
&
aAllocate
)
;
protected
:
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetAsSourceSurface
(
)
override
;
void
SetOffscreenFormat
(
gfxImageFormat
aFormat
)
{
mOffscreenFormat
=
aFormat
;
}
gfxImageFormat
GetOffscreenFormat
(
)
const
;
Data
mData
;
gfx
:
:
IntPoint
mOrigin
;
gfx
:
:
IntSize
mSize
;
gfxImageFormat
mOffscreenFormat
;
RefPtr
<
gfx
:
:
SourceSurface
>
mSourceSurface
;
uint32_t
mBufferSize
;
}
;
class
RecyclingPlanarYCbCrImage
:
public
PlanarYCbCrImage
{
public
:
explicit
RecyclingPlanarYCbCrImage
(
BufferRecycleBin
*
aRecycleBin
)
:
mRecycleBin
(
aRecycleBin
)
{
}
virtual
~
RecyclingPlanarYCbCrImage
(
)
;
bool
CopyData
(
const
Data
&
aData
)
override
;
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
;
protected
:
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
AllocateBuffer
(
uint32_t
aSize
)
;
RefPtr
<
BufferRecycleBin
>
mRecycleBin
;
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
mBuffer
;
}
;
class
NVImage
final
:
public
Image
{
typedef
PlanarYCbCrData
Data
;
public
:
NVImage
(
)
;
virtual
~
NVImage
(
)
;
gfx
:
:
IntSize
GetSize
(
)
const
override
;
gfx
:
:
IntRect
GetPictureRect
(
)
const
override
;
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetAsSourceSurface
(
)
override
;
bool
IsValid
(
)
const
override
;
NVImage
*
AsNVImage
(
)
override
;
bool
SetData
(
const
Data
&
aData
)
;
const
Data
*
GetData
(
)
const
;
uint32_t
GetBufferSize
(
)
const
;
protected
:
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
AllocateBuffer
(
uint32_t
aSize
)
;
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
mBuffer
;
uint32_t
mBufferSize
;
gfx
:
:
IntSize
mSize
;
Data
mData
;
RefPtr
<
gfx
:
:
SourceSurface
>
mSourceSurface
;
}
;
class
SourceSurfaceImage
final
:
public
Image
{
public
:
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetAsSourceSurface
(
)
override
{
RefPtr
<
gfx
:
:
SourceSurface
>
surface
(
mSourceSurface
)
;
return
surface
.
forget
(
)
;
}
void
SetTextureFlags
(
TextureFlags
aTextureFlags
)
{
mTextureFlags
=
aTextureFlags
;
}
TextureClient
*
GetTextureClient
(
KnowsCompositor
*
aKnowsCompositor
)
override
;
gfx
:
:
IntSize
GetSize
(
)
const
override
{
return
mSize
;
}
SourceSurfaceImage
(
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SourceSurface
*
aSourceSurface
)
;
explicit
SourceSurfaceImage
(
gfx
:
:
SourceSurface
*
aSourceSurface
)
;
virtual
~
SourceSurfaceImage
(
)
;
private
:
gfx
:
:
IntSize
mSize
;
RefPtr
<
gfx
:
:
SourceSurface
>
mSourceSurface
;
nsTHashMap
<
uint32_t
RefPtr
<
TextureClient
>
>
mTextureClients
;
TextureFlags
mTextureFlags
;
}
;
}
}
#
endif
