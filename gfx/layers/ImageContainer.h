#
ifndef
GFX_IMAGECONTAINER_H
#
define
GFX_IMAGECONTAINER_H
#
include
<
stdint
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
"
gfxTypes
.
h
"
#
include
"
ImageTypes
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
layers
/
GonkNativeHandle
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsAutoRef
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
ifndef
XPCOM_GLUE_AVOID_NSPR
class
nsMainThreadSourceSurfaceRef
;
template
<
>
class
nsAutoRefTraits
<
nsMainThreadSourceSurfaceRef
>
{
public
:
typedef
mozilla
:
:
gfx
:
:
SourceSurface
*
RawRef
;
class
SurfaceReleaser
:
public
nsRunnable
{
public
:
explicit
SurfaceReleaser
(
RawRef
aRef
)
:
mRef
(
aRef
)
{
}
NS_IMETHOD
Run
(
)
{
mRef
-
>
Release
(
)
;
return
NS_OK
;
}
RawRef
mRef
;
}
;
static
RawRef
Void
(
)
{
return
nullptr
;
}
static
void
Release
(
RawRef
aRawRef
)
{
if
(
NS_IsMainThread
(
)
)
{
aRawRef
-
>
Release
(
)
;
return
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
SurfaceReleaser
(
aRawRef
)
;
NS_DispatchToMainThread
(
runnable
)
;
}
static
void
AddRef
(
RawRef
aRawRef
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Can
only
add
a
reference
on
the
main
thread
"
)
;
aRawRef
-
>
AddRef
(
)
;
}
}
;
class
nsOwningThreadSourceSurfaceRef
;
template
<
>
class
nsAutoRefTraits
<
nsOwningThreadSourceSurfaceRef
>
{
public
:
typedef
mozilla
:
:
gfx
:
:
SourceSurface
*
RawRef
;
class
SurfaceReleaser
:
public
nsRunnable
{
public
:
explicit
SurfaceReleaser
(
RawRef
aRef
)
:
mRef
(
aRef
)
{
}
NS_IMETHOD
Run
(
)
{
mRef
-
>
Release
(
)
;
return
NS_OK
;
}
RawRef
mRef
;
}
;
static
RawRef
Void
(
)
{
return
nullptr
;
}
void
Release
(
RawRef
aRawRef
)
{
MOZ_ASSERT
(
mOwningThread
)
;
bool
current
;
mOwningThread
-
>
IsOnCurrentThread
(
&
current
)
;
if
(
current
)
{
aRawRef
-
>
Release
(
)
;
return
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
SurfaceReleaser
(
aRawRef
)
;
mOwningThread
-
>
Dispatch
(
runnable
nsIThread
:
:
DISPATCH_NORMAL
)
;
}
void
AddRef
(
RawRef
aRawRef
)
{
MOZ_ASSERT
(
!
mOwningThread
)
;
NS_GetCurrentThread
(
getter_AddRefs
(
mOwningThread
)
)
;
aRawRef
-
>
AddRef
(
)
;
}
private
:
nsCOMPtr
<
nsIThread
>
mOwningThread
;
}
;
#
endif
#
ifdef
XP_WIN
struct
ID3D10Texture2D
;
struct
ID3D10Device
;
struct
ID3D10ShaderResourceView
;
#
endif
typedef
void
*
HANDLE
;
namespace
mozilla
{
namespace
layers
{
class
ImageClient
;
class
ImageCompositeNotification
;
class
ImageContainerChild
;
class
PImageContainerChild
;
class
SharedPlanarYCbCrImage
;
class
PlanarYCbCrImage
;
class
TextureClient
;
class
CompositableClient
;
class
GrallocImage
;
struct
ImageBackendData
{
virtual
~
ImageBackendData
(
)
{
}
protected
:
ImageBackendData
(
)
{
}
}
;
class
EGLImageImage
;
class
SharedRGBImage
;
#
ifdef
MOZ_WIDGET_ANDROID
class
SurfaceTextureImage
;
#
elif
defined
(
XP_MACOSX
)
class
MacIOSurfaceImage
;
#
elif
defined
(
MOZ_WIDGET_GONK
)
class
OverlayImage
;
#
endif
class
Image
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Image
)
public
:
ImageFormat
GetFormat
(
)
{
return
mFormat
;
}
void
*
GetImplData
(
)
{
return
mImplData
;
}
virtual
gfx
:
:
IntSize
GetSize
(
)
=
0
;
virtual
gfx
:
:
IntRect
GetPictureRect
(
)
{
return
gfx
:
:
IntRect
(
0
0
GetSize
(
)
.
width
GetSize
(
)
.
height
)
;
}
ImageBackendData
*
GetBackendData
(
LayersBackend
aBackend
)
{
return
mBackendData
[
aBackend
]
;
}
void
SetBackendData
(
LayersBackend
aBackend
ImageBackendData
*
aData
)
{
mBackendData
[
aBackend
]
=
aData
;
}
int32_t
GetSerial
(
)
{
return
mSerial
;
}
virtual
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetAsSourceSurface
(
)
=
0
;
virtual
GrallocImage
*
AsGrallocImage
(
)
{
return
nullptr
;
}
virtual
bool
IsValid
(
)
{
return
true
;
}
virtual
uint8_t
*
GetBuffer
(
)
{
return
nullptr
;
}
virtual
TextureClient
*
GetTextureClient
(
CompositableClient
*
aClient
)
{
return
nullptr
;
}
virtual
EGLImageImage
*
AsEGLImageImage
(
)
{
return
nullptr
;
}
#
ifdef
MOZ_WIDGET_ANDROID
virtual
SurfaceTextureImage
*
AsSurfaceTextureImage
(
)
{
return
nullptr
;
}
#
endif
#
ifdef
XP_MACOSX
virtual
MacIOSurfaceImage
*
AsMacIOSurfaceImage
(
)
{
return
nullptr
;
}
#
endif
virtual
PlanarYCbCrImage
*
AsPlanarYCbCrImage
(
)
{
return
nullptr
;
}
protected
:
Image
(
void
*
aImplData
ImageFormat
aFormat
)
:
mImplData
(
aImplData
)
mSerial
(
+
+
sSerialCounter
)
mFormat
(
aFormat
)
{
}
virtual
~
Image
(
)
{
}
mozilla
:
:
EnumeratedArray
<
mozilla
:
:
layers
:
:
LayersBackend
mozilla
:
:
layers
:
:
LayersBackend
:
:
LAYERS_LAST
nsAutoPtr
<
ImageBackendData
>
>
mBackendData
;
void
*
mImplData
;
int32_t
mSerial
;
ImageFormat
mFormat
;
static
mozilla
:
:
Atomic
<
int32_t
>
sSerialCounter
;
}
;
class
BufferRecycleBin
final
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
BufferRecycleBin
)
public
:
BufferRecycleBin
(
)
;
void
RecycleBuffer
(
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
aBuffer
uint32_t
aSize
)
;
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
GetBuffer
(
uint32_t
aSize
)
;
private
:
typedef
mozilla
:
:
Mutex
Mutex
;
~
BufferRecycleBin
(
)
{
}
Mutex
mLock
;
nsTArray
<
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
>
mRecycledBuffers
;
uint32_t
mRecycledBufferSize
;
}
;
class
ImageFactory
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ImageFactory
)
protected
:
friend
class
ImageContainer
;
ImageFactory
(
)
{
}
virtual
~
ImageFactory
(
)
{
}
virtual
RefPtr
<
PlanarYCbCrImage
>
CreatePlanarYCbCrImage
(
const
gfx
:
:
IntSize
&
aScaleHint
BufferRecycleBin
*
aRecycleBin
)
;
}
;
class
ImageContainer
final
:
public
SupportsWeakPtr
<
ImageContainer
>
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ImageContainer
)
public
:
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
ImageContainer
)
enum
Mode
{
SYNCHRONOUS
=
0x0
ASYNCHRONOUS
=
0x01
}
;
explicit
ImageContainer
(
ImageContainer
:
:
Mode
flag
=
SYNCHRONOUS
)
;
typedef
uint32_t
FrameID
;
typedef
uint32_t
ProducerID
;
RefPtr
<
PlanarYCbCrImage
>
CreatePlanarYCbCrImage
(
)
;
RefPtr
<
SharedRGBImage
>
CreateSharedRGBImage
(
)
;
#
ifdef
MOZ_WIDGET_GONK
RefPtr
<
OverlayImage
>
CreateOverlayImage
(
)
;
#
endif
struct
NonOwningImage
{
explicit
NonOwningImage
(
Image
*
aImage
=
nullptr
TimeStamp
aTimeStamp
=
TimeStamp
(
)
FrameID
aFrameID
=
0
ProducerID
aProducerID
=
0
)
:
mImage
(
aImage
)
mTimeStamp
(
aTimeStamp
)
mFrameID
(
aFrameID
)
mProducerID
(
aProducerID
)
{
}
Image
*
mImage
;
TimeStamp
mTimeStamp
;
FrameID
mFrameID
;
ProducerID
mProducerID
;
}
;
void
SetCurrentImages
(
const
nsTArray
<
NonOwningImage
>
&
aImages
)
;
void
ClearAllImages
(
)
;
void
ClearImagesFromImageBridge
(
)
;
void
SetCurrentImageInTransaction
(
Image
*
aImage
)
;
bool
IsAsync
(
)
const
;
uint64_t
GetAsyncContainerID
(
)
const
;
bool
HasCurrentImage
(
)
;
struct
OwningImage
{
OwningImage
(
)
:
mFrameID
(
0
)
mProducerID
(
0
)
mComposited
(
false
)
{
}
RefPtr
<
Image
>
mImage
;
TimeStamp
mTimeStamp
;
FrameID
mFrameID
;
ProducerID
mProducerID
;
bool
mComposited
;
}
;
void
GetCurrentImages
(
nsTArray
<
OwningImage
>
*
aImages
uint32_t
*
aGenerationCounter
=
nullptr
)
;
gfx
:
:
IntSize
GetCurrentSize
(
)
;
void
SetScaleHint
(
const
gfx
:
:
IntSize
&
aScaleHint
)
{
mScaleHint
=
aScaleHint
;
}
void
SetImageFactory
(
ImageFactory
*
aFactory
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
mImageFactory
=
aFactory
?
aFactory
:
new
ImageFactory
(
)
;
}
ImageFactory
*
GetImageFactory
(
)
const
{
return
mImageFactory
;
}
TimeDuration
GetPaintDelay
(
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
return
mPaintDelay
;
}
uint32_t
GetPaintCount
(
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
return
mPaintCount
;
}
uint32_t
GetDroppedImageCount
(
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
return
mDroppedImageCount
;
}
PImageContainerChild
*
GetPImageContainerChild
(
)
;
static
void
NotifyComposite
(
const
ImageCompositeNotification
&
aNotification
)
;
static
ProducerID
AllocateProducerID
(
)
;
private
:
typedef
mozilla
:
:
ReentrantMonitor
ReentrantMonitor
;
B2G_ACL_EXPORT
~
ImageContainer
(
)
;
void
SetCurrentImageInternal
(
const
nsTArray
<
NonOwningImage
>
&
aImages
)
;
void
EnsureActiveImage
(
)
;
void
NotifyCompositeInternal
(
const
ImageCompositeNotification
&
aNotification
)
;
ReentrantMonitor
mReentrantMonitor
;
nsTArray
<
OwningImage
>
mCurrentImages
;
uint32_t
mGenerationCounter
;
uint32_t
mPaintCount
;
TimeDuration
mPaintDelay
;
uint32_t
mDroppedImageCount
;
RefPtr
<
ImageFactory
>
mImageFactory
;
gfx
:
:
IntSize
mScaleHint
;
RefPtr
<
BufferRecycleBin
>
mRecycleBin
;
ImageClient
*
mImageClient
;
nsTArray
<
FrameID
>
mFrameIDsNotYetComposited
;
ProducerID
mCurrentProducerID
;
ImageContainerChild
*
mIPDLChild
;
static
mozilla
:
:
Atomic
<
uint32_t
>
sGenerationCounter
;
}
;
class
AutoLockImage
{
public
:
explicit
AutoLockImage
(
ImageContainer
*
aContainer
)
{
aContainer
-
>
GetCurrentImages
(
&
mImages
)
;
}
bool
HasImage
(
)
const
{
return
!
mImages
.
IsEmpty
(
)
;
}
Image
*
GetImage
(
)
const
{
return
mImages
.
IsEmpty
(
)
?
nullptr
:
mImages
[
0
]
.
mImage
.
get
(
)
;
}
private
:
AutoTArray
<
ImageContainer
:
:
OwningImage
4
>
mImages
;
}
;
struct
PlanarYCbCrData
{
uint8_t
*
mYChannel
;
int32_t
mYStride
;
gfx
:
:
IntSize
mYSize
;
int32_t
mYSkip
;
uint8_t
*
mCbChannel
;
uint8_t
*
mCrChannel
;
int32_t
mCbCrStride
;
gfx
:
:
IntSize
mCbCrSize
;
int32_t
mCbSkip
;
int32_t
mCrSkip
;
uint32_t
mPicX
;
uint32_t
mPicY
;
gfx
:
:
IntSize
mPicSize
;
StereoMode
mStereoMode
;
gfx
:
:
IntRect
GetPictureRect
(
)
const
{
return
gfx
:
:
IntRect
(
mPicX
mPicY
mPicSize
.
width
mPicSize
.
height
)
;
}
PlanarYCbCrData
(
)
:
mYChannel
(
nullptr
)
mYStride
(
0
)
mYSize
(
0
0
)
mYSkip
(
0
)
mCbChannel
(
nullptr
)
mCrChannel
(
nullptr
)
mCbCrStride
(
0
)
mCbCrSize
(
0
0
)
mCbSkip
(
0
)
mCrSkip
(
0
)
mPicX
(
0
)
mPicY
(
0
)
mPicSize
(
0
0
)
mStereoMode
(
StereoMode
:
:
MONO
)
{
}
}
;
class
PlanarYCbCrImage
:
public
Image
{
public
:
typedef
PlanarYCbCrData
Data
;
enum
{
MAX_DIMENSION
=
16384
}
;
virtual
~
PlanarYCbCrImage
(
)
{
}
virtual
bool
SetData
(
const
Data
&
aData
)
=
0
;
virtual
bool
SetDataNoCopy
(
const
Data
&
aData
)
;
virtual
uint8_t
*
AllocateAndGetNewBuffer
(
uint32_t
aSize
)
=
0
;
virtual
void
SetDelayedConversion
(
bool
aDelayed
)
{
}
virtual
const
Data
*
GetData
(
)
{
return
&
mData
;
}
virtual
uint32_t
GetDataSize
(
)
{
return
mBufferSize
;
}
virtual
bool
IsValid
(
)
{
return
!
!
mBufferSize
;
}
virtual
gfx
:
:
IntSize
GetSize
(
)
{
return
mSize
;
}
explicit
PlanarYCbCrImage
(
)
;
virtual
SharedPlanarYCbCrImage
*
AsSharedPlanarYCbCrImage
(
)
{
return
nullptr
;
}
virtual
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
virtual
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
=
0
;
PlanarYCbCrImage
*
AsPlanarYCbCrImage
(
)
{
return
this
;
}
protected
:
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetAsSourceSurface
(
)
;
void
SetOffscreenFormat
(
gfxImageFormat
aFormat
)
{
mOffscreenFormat
=
aFormat
;
}
gfxImageFormat
GetOffscreenFormat
(
)
;
Data
mData
;
gfx
:
:
IntSize
mSize
;
gfxImageFormat
mOffscreenFormat
;
nsCountedRef
<
nsMainThreadSourceSurfaceRef
>
mSourceSurface
;
uint32_t
mBufferSize
;
}
;
class
RecyclingPlanarYCbCrImage
:
public
PlanarYCbCrImage
{
public
:
explicit
RecyclingPlanarYCbCrImage
(
BufferRecycleBin
*
aRecycleBin
)
:
mRecycleBin
(
aRecycleBin
)
{
}
virtual
~
RecyclingPlanarYCbCrImage
(
)
override
;
virtual
bool
SetData
(
const
Data
&
aData
)
override
;
virtual
uint8_t
*
AllocateAndGetNewBuffer
(
uint32_t
aSize
)
override
;
virtual
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
;
protected
:
bool
CopyData
(
const
Data
&
aData
)
;
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
AllocateBuffer
(
uint32_t
aSize
)
;
RefPtr
<
BufferRecycleBin
>
mRecycleBin
;
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
mBuffer
;
}
;
class
SourceSurfaceImage
final
:
public
Image
{
public
:
virtual
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetAsSourceSurface
(
)
override
{
RefPtr
<
gfx
:
:
SourceSurface
>
surface
(
mSourceSurface
)
;
return
surface
.
forget
(
)
;
}
virtual
TextureClient
*
GetTextureClient
(
CompositableClient
*
aClient
)
override
;
virtual
gfx
:
:
IntSize
GetSize
(
)
override
{
return
mSize
;
}
SourceSurfaceImage
(
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SourceSurface
*
aSourceSurface
)
;
~
SourceSurfaceImage
(
)
;
private
:
gfx
:
:
IntSize
mSize
;
nsCountedRef
<
nsOwningThreadSourceSurfaceRef
>
mSourceSurface
;
nsDataHashtable
<
nsUint32HashKey
RefPtr
<
TextureClient
>
>
mTextureClients
;
}
;
#
ifdef
MOZ_WIDGET_GONK
class
OverlayImage
:
public
Image
{
public
:
struct
Data
{
int32_t
mOverlayId
;
gfx
:
:
IntSize
mSize
;
}
;
struct
SidebandStreamData
{
GonkNativeHandle
mStream
;
gfx
:
:
IntSize
mSize
;
}
;
OverlayImage
(
)
:
Image
(
nullptr
ImageFormat
:
:
OVERLAY_IMAGE
)
{
mOverlayId
=
INVALID_OVERLAY
;
}
void
SetData
(
const
Data
&
aData
)
{
mOverlayId
=
aData
.
mOverlayId
;
mSize
=
aData
.
mSize
;
mSidebandStream
=
GonkNativeHandle
(
)
;
}
void
SetData
(
const
SidebandStreamData
&
aData
)
{
mSidebandStream
=
aData
.
mStream
;
mSize
=
aData
.
mSize
;
mOverlayId
=
INVALID_OVERLAY
;
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetAsSourceSurface
(
)
{
return
nullptr
;
}
;
int32_t
GetOverlayId
(
)
{
return
mOverlayId
;
}
GonkNativeHandle
&
GetSidebandStream
(
)
{
return
mSidebandStream
;
}
gfx
:
:
IntSize
GetSize
(
)
{
return
mSize
;
}
private
:
int32_t
mOverlayId
;
GonkNativeHandle
mSidebandStream
;
gfx
:
:
IntSize
mSize
;
}
;
#
endif
}
}
#
endif
