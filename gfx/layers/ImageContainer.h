#
ifndef
GFX_IMAGECONTAINER_H
#
define
GFX_IMAGECONTAINER_H
#
include
<
stdint
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
"
gfxTypes
.
h
"
#
include
"
ImageTypes
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
RecursiveMutex
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsAutoRef
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
ifndef
XPCOM_GLUE_AVOID_NSPR
class
nsMainThreadSourceSurfaceRef
;
template
<
>
class
nsAutoRefTraits
<
nsMainThreadSourceSurfaceRef
>
{
public
:
typedef
mozilla
:
:
gfx
:
:
SourceSurface
*
RawRef
;
class
SurfaceReleaser
:
public
mozilla
:
:
Runnable
{
public
:
explicit
SurfaceReleaser
(
RawRef
aRef
)
:
mozilla
:
:
Runnable
(
"
nsAutoRefTraits
<
nsMainThreadSourceSurfaceRef
>
:
:
SurfaceReleaser
"
)
mRef
(
aRef
)
{
}
NS_IMETHOD
Run
(
)
override
{
mRef
-
>
Release
(
)
;
return
NS_OK
;
}
RawRef
mRef
;
}
;
static
RawRef
Void
(
)
{
return
nullptr
;
}
static
void
Release
(
RawRef
aRawRef
)
{
if
(
NS_IsMainThread
(
)
)
{
aRawRef
-
>
Release
(
)
;
return
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
SurfaceReleaser
(
aRawRef
)
;
NS_DispatchToMainThread
(
runnable
)
;
}
static
void
AddRef
(
RawRef
aRawRef
)
{
aRawRef
-
>
AddRef
(
)
;
}
}
;
class
nsOwningThreadSourceSurfaceRef
;
template
<
>
class
nsAutoRefTraits
<
nsOwningThreadSourceSurfaceRef
>
{
public
:
typedef
mozilla
:
:
gfx
:
:
SourceSurface
*
RawRef
;
class
SurfaceReleaser
:
public
mozilla
:
:
Runnable
{
public
:
explicit
SurfaceReleaser
(
RawRef
aRef
)
:
mozilla
:
:
Runnable
(
"
nsAutoRefTraits
<
nsOwningThreadSourceSurfaceRef
>
:
:
"
"
SurfaceReleaser
"
)
mRef
(
aRef
)
{
}
NS_IMETHOD
Run
(
)
override
{
mRef
-
>
Release
(
)
;
return
NS_OK
;
}
RawRef
mRef
;
}
;
static
RawRef
Void
(
)
{
return
nullptr
;
}
void
Release
(
RawRef
aRawRef
)
{
MOZ_ASSERT
(
mOwningEventTarget
)
;
if
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
{
aRawRef
-
>
Release
(
)
;
return
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
SurfaceReleaser
(
aRawRef
)
;
mOwningEventTarget
-
>
Dispatch
(
runnable
nsIThread
:
:
DISPATCH_NORMAL
)
;
}
void
AddRef
(
RawRef
aRawRef
)
{
MOZ_ASSERT
(
!
mOwningEventTarget
)
;
mOwningEventTarget
=
mozilla
:
:
GetCurrentThreadSerialEventTarget
(
)
;
aRawRef
-
>
AddRef
(
)
;
}
private
:
nsCOMPtr
<
nsISerialEventTarget
>
mOwningEventTarget
;
}
;
#
endif
#
ifdef
XP_WIN
struct
ID3D10Texture2D
;
struct
ID3D10Device
;
struct
ID3D10ShaderResourceView
;
#
endif
typedef
void
*
HANDLE
;
namespace
mozilla
{
namespace
layers
{
class
ImageClient
;
class
ImageCompositeNotification
;
class
ImageContainer
;
class
ImageContainerChild
;
class
SharedPlanarYCbCrImage
;
class
SharedSurfacesAnimation
;
class
PlanarYCbCrImage
;
class
TextureClient
;
class
KnowsCompositor
;
class
NVImage
;
#
ifdef
XP_WIN
class
D3D11YCbCrRecycleAllocator
;
#
endif
class
SurfaceDescriptorBuffer
;
struct
ImageBackendData
{
virtual
~
ImageBackendData
(
)
=
default
;
protected
:
ImageBackendData
(
)
{
}
}
;
class
GLImage
;
class
SharedRGBImage
;
#
ifdef
MOZ_WIDGET_ANDROID
class
SurfaceTextureImage
;
#
elif
defined
(
XP_MACOSX
)
class
MacIOSurfaceImage
;
#
endif
class
Image
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Image
)
public
:
ImageFormat
GetFormat
(
)
const
{
return
mFormat
;
}
void
*
GetImplData
(
)
const
{
return
mImplData
;
}
virtual
gfx
:
:
IntSize
GetSize
(
)
const
=
0
;
virtual
gfx
:
:
IntPoint
GetOrigin
(
)
const
{
return
gfx
:
:
IntPoint
(
0
0
)
;
}
virtual
gfx
:
:
IntRect
GetPictureRect
(
)
const
{
return
gfx
:
:
IntRect
(
GetOrigin
(
)
.
x
GetOrigin
(
)
.
y
GetSize
(
)
.
width
GetSize
(
)
.
height
)
;
}
ImageBackendData
*
GetBackendData
(
LayersBackend
aBackend
)
{
return
mBackendData
[
aBackend
]
;
}
void
SetBackendData
(
LayersBackend
aBackend
ImageBackendData
*
aData
)
{
mBackendData
[
aBackend
]
=
aData
;
}
int32_t
GetSerial
(
)
const
{
return
mSerial
;
}
virtual
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetAsSourceSurface
(
)
=
0
;
virtual
bool
IsValid
(
)
const
{
return
true
;
}
virtual
TextureClient
*
GetTextureClient
(
KnowsCompositor
*
aKnowsCompositor
)
{
return
nullptr
;
}
virtual
GLImage
*
AsGLImage
(
)
{
return
nullptr
;
}
#
ifdef
MOZ_WIDGET_ANDROID
virtual
SurfaceTextureImage
*
AsSurfaceTextureImage
(
)
{
return
nullptr
;
}
#
endif
#
ifdef
XP_MACOSX
virtual
MacIOSurfaceImage
*
AsMacIOSurfaceImage
(
)
{
return
nullptr
;
}
#
endif
virtual
PlanarYCbCrImage
*
AsPlanarYCbCrImage
(
)
{
return
nullptr
;
}
virtual
NVImage
*
AsNVImage
(
)
{
return
nullptr
;
}
protected
:
Image
(
void
*
aImplData
ImageFormat
aFormat
)
:
mImplData
(
aImplData
)
mSerial
(
+
+
sSerialCounter
)
mFormat
(
aFormat
)
{
}
virtual
~
Image
(
)
=
default
;
mozilla
:
:
EnumeratedArray
<
mozilla
:
:
layers
:
:
LayersBackend
mozilla
:
:
layers
:
:
LayersBackend
:
:
LAYERS_LAST
nsAutoPtr
<
ImageBackendData
>
>
mBackendData
;
void
*
mImplData
;
int32_t
mSerial
;
ImageFormat
mFormat
;
static
mozilla
:
:
Atomic
<
int32_t
>
sSerialCounter
;
}
;
class
BufferRecycleBin
final
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
BufferRecycleBin
)
public
:
BufferRecycleBin
(
)
;
void
RecycleBuffer
(
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
aBuffer
uint32_t
aSize
)
;
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
GetBuffer
(
uint32_t
aSize
)
;
virtual
void
ClearRecycledBuffers
(
)
;
private
:
typedef
mozilla
:
:
Mutex
Mutex
;
~
BufferRecycleBin
(
)
{
}
Mutex
mLock
;
nsTArray
<
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
>
mRecycledBuffers
;
uint32_t
mRecycledBufferSize
;
}
;
class
ImageFactory
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ImageFactory
)
protected
:
friend
class
ImageContainer
;
ImageFactory
(
)
{
}
virtual
~
ImageFactory
(
)
=
default
;
virtual
RefPtr
<
PlanarYCbCrImage
>
CreatePlanarYCbCrImage
(
const
gfx
:
:
IntSize
&
aScaleHint
BufferRecycleBin
*
aRecycleBin
)
;
}
;
class
ImageContainerListener
final
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ImageContainerListener
)
public
:
explicit
ImageContainerListener
(
ImageContainer
*
aImageContainer
)
;
void
NotifyComposite
(
const
ImageCompositeNotification
&
aNotification
)
;
void
NotifyDropped
(
uint32_t
aDropped
)
;
void
ClearImageContainer
(
)
;
void
DropImageClient
(
)
;
private
:
typedef
mozilla
:
:
Mutex
Mutex
;
~
ImageContainerListener
(
)
;
Mutex
mLock
;
ImageContainer
*
mImageContainer
;
}
;
class
ImageContainer
final
:
public
SupportsWeakPtr
<
ImageContainer
>
{
friend
class
ImageContainerChild
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ImageContainer
)
public
:
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
ImageContainer
)
enum
Mode
{
SYNCHRONOUS
=
0x0
ASYNCHRONOUS
=
0x01
}
;
static
const
uint64_t
sInvalidAsyncContainerId
=
0
;
explicit
ImageContainer
(
ImageContainer
:
:
Mode
flag
=
SYNCHRONOUS
)
;
explicit
ImageContainer
(
const
CompositableHandle
&
aHandle
)
;
typedef
ContainerFrameID
FrameID
;
typedef
ContainerProducerID
ProducerID
;
RefPtr
<
PlanarYCbCrImage
>
CreatePlanarYCbCrImage
(
)
;
RefPtr
<
SharedRGBImage
>
CreateSharedRGBImage
(
)
;
struct
NonOwningImage
{
explicit
NonOwningImage
(
Image
*
aImage
=
nullptr
TimeStamp
aTimeStamp
=
TimeStamp
(
)
FrameID
aFrameID
=
0
ProducerID
aProducerID
=
0
)
:
mImage
(
aImage
)
mTimeStamp
(
aTimeStamp
)
mFrameID
(
aFrameID
)
mProducerID
(
aProducerID
)
{
}
Image
*
mImage
;
TimeStamp
mTimeStamp
;
FrameID
mFrameID
;
ProducerID
mProducerID
;
}
;
void
SetCurrentImages
(
const
nsTArray
<
NonOwningImage
>
&
aImages
)
;
void
ClearAllImages
(
)
;
void
ClearCachedResources
(
)
;
void
ClearImagesFromImageBridge
(
)
;
void
SetCurrentImageInTransaction
(
Image
*
aImage
)
;
void
SetCurrentImagesInTransaction
(
const
nsTArray
<
NonOwningImage
>
&
aImages
)
;
bool
IsAsync
(
)
const
;
CompositableHandle
GetAsyncContainerHandle
(
)
;
bool
HasCurrentImage
(
)
;
struct
OwningImage
{
OwningImage
(
)
:
mFrameID
(
0
)
mProducerID
(
0
)
mComposited
(
false
)
{
}
RefPtr
<
Image
>
mImage
;
TimeStamp
mTimeStamp
;
FrameID
mFrameID
;
ProducerID
mProducerID
;
bool
mComposited
;
}
;
void
GetCurrentImages
(
nsTArray
<
OwningImage
>
*
aImages
uint32_t
*
aGenerationCounter
=
nullptr
)
;
gfx
:
:
IntSize
GetCurrentSize
(
)
;
void
SetScaleHint
(
const
gfx
:
:
IntSize
&
aScaleHint
)
{
mScaleHint
=
aScaleHint
;
}
const
gfx
:
:
IntSize
&
GetScaleHint
(
)
const
{
return
mScaleHint
;
}
void
SetTransformHint
(
const
gfx
:
:
Matrix
&
aTransformHint
)
{
mTransformHint
=
aTransformHint
;
}
const
gfx
:
:
Matrix
&
GetTransformHint
(
)
const
{
return
mTransformHint
;
}
void
SetImageFactory
(
ImageFactory
*
aFactory
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
mImageFactory
=
aFactory
?
aFactory
:
new
ImageFactory
(
)
;
}
ImageFactory
*
GetImageFactory
(
)
const
{
return
mImageFactory
;
}
#
ifdef
XP_WIN
D3D11YCbCrRecycleAllocator
*
GetD3D11YCbCrRecycleAllocator
(
KnowsCompositor
*
aAllocator
)
;
#
endif
TimeDuration
GetPaintDelay
(
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
mPaintDelay
;
}
uint32_t
GetPaintCount
(
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
mPaintCount
;
}
uint32_t
GetDroppedImageCount
(
)
{
return
mDroppedImageCount
;
}
void
NotifyComposite
(
const
ImageCompositeNotification
&
aNotification
)
;
void
NotifyDropped
(
uint32_t
aDropped
)
;
ImageContainerListener
*
GetImageContainerListener
(
)
{
return
mNotifyCompositeListener
;
}
already_AddRefed
<
ImageClient
>
GetImageClient
(
)
;
static
ProducerID
AllocateProducerID
(
)
;
void
DropImageClient
(
)
;
SharedSurfacesAnimation
*
GetSharedSurfacesAnimation
(
)
const
{
return
mSharedAnimation
;
}
SharedSurfacesAnimation
*
EnsureSharedSurfacesAnimation
(
)
;
private
:
typedef
mozilla
:
:
RecursiveMutex
RecursiveMutex
;
~
ImageContainer
(
)
;
void
SetCurrentImageInternal
(
const
nsTArray
<
NonOwningImage
>
&
aImages
)
;
void
EnsureActiveImage
(
)
;
void
EnsureImageClient
(
)
;
RecursiveMutex
mRecursiveMutex
;
#
ifdef
XP_WIN
RefPtr
<
D3D11YCbCrRecycleAllocator
>
mD3D11YCbCrRecycleAllocator
;
#
endif
nsTArray
<
OwningImage
>
mCurrentImages
;
uint32_t
mGenerationCounter
;
uint32_t
mPaintCount
;
TimeDuration
mPaintDelay
;
mozilla
:
:
Atomic
<
uint32_t
>
mDroppedImageCount
;
RefPtr
<
ImageFactory
>
mImageFactory
;
gfx
:
:
IntSize
mScaleHint
;
gfx
:
:
Matrix
mTransformHint
;
RefPtr
<
BufferRecycleBin
>
mRecycleBin
;
RefPtr
<
ImageClient
>
mImageClient
;
RefPtr
<
SharedSurfacesAnimation
>
mSharedAnimation
;
bool
mIsAsync
;
CompositableHandle
mAsyncContainerHandle
;
ProducerID
mCurrentProducerID
;
RefPtr
<
ImageContainerListener
>
mNotifyCompositeListener
;
static
mozilla
:
:
Atomic
<
uint32_t
>
sGenerationCounter
;
}
;
class
AutoLockImage
{
public
:
explicit
AutoLockImage
(
ImageContainer
*
aContainer
)
{
aContainer
-
>
GetCurrentImages
(
&
mImages
)
;
}
bool
HasImage
(
)
const
{
return
!
mImages
.
IsEmpty
(
)
;
}
Image
*
GetImage
(
)
const
{
return
mImages
.
IsEmpty
(
)
?
nullptr
:
mImages
[
0
]
.
mImage
.
get
(
)
;
}
Image
*
GetImage
(
TimeStamp
aTimeStamp
)
const
{
if
(
mImages
.
IsEmpty
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
!
aTimeStamp
.
IsNull
(
)
)
;
uint32_t
chosenIndex
=
0
;
while
(
chosenIndex
+
1
<
mImages
.
Length
(
)
&
&
mImages
[
chosenIndex
+
1
]
.
mTimeStamp
<
=
aTimeStamp
)
{
+
+
chosenIndex
;
}
return
mImages
[
chosenIndex
]
.
mImage
.
get
(
)
;
}
private
:
AutoTArray
<
ImageContainer
:
:
OwningImage
4
>
mImages
;
}
;
struct
PlanarYCbCrData
{
uint8_t
*
mYChannel
=
nullptr
;
int32_t
mYStride
=
0
;
gfx
:
:
IntSize
mYSize
=
gfx
:
:
IntSize
(
0
0
)
;
int32_t
mYSkip
=
0
;
uint8_t
*
mCbChannel
=
nullptr
;
uint8_t
*
mCrChannel
=
nullptr
;
int32_t
mCbCrStride
=
0
;
gfx
:
:
IntSize
mCbCrSize
=
gfx
:
:
IntSize
(
0
0
)
;
int32_t
mCbSkip
=
0
;
int32_t
mCrSkip
=
0
;
uint32_t
mPicX
=
0
;
uint32_t
mPicY
=
0
;
gfx
:
:
IntSize
mPicSize
=
gfx
:
:
IntSize
(
0
0
)
;
StereoMode
mStereoMode
=
StereoMode
:
:
MONO
;
gfx
:
:
ColorDepth
mColorDepth
=
gfx
:
:
ColorDepth
:
:
COLOR_8
;
gfx
:
:
YUVColorSpace
mYUVColorSpace
=
gfx
:
:
YUVColorSpace
:
:
UNKNOWN
;
gfx
:
:
ColorRange
mColorRange
=
gfx
:
:
ColorRange
:
:
LIMITED
;
gfx
:
:
IntRect
GetPictureRect
(
)
const
{
return
gfx
:
:
IntRect
(
mPicX
mPicY
mPicSize
.
width
mPicSize
.
height
)
;
}
}
;
class
PlanarYCbCrImage
:
public
Image
{
public
:
typedef
PlanarYCbCrData
Data
;
enum
{
MAX_DIMENSION
=
16384
}
;
virtual
~
PlanarYCbCrImage
(
)
=
default
;
virtual
bool
CopyData
(
const
Data
&
aData
)
=
0
;
virtual
bool
AdoptData
(
const
Data
&
aData
)
;
virtual
void
SetDelayedConversion
(
bool
aDelayed
)
{
}
virtual
const
Data
*
GetData
(
)
const
{
return
&
mData
;
}
uint32_t
GetDataSize
(
)
const
{
return
mBufferSize
;
}
bool
IsValid
(
)
const
override
{
return
!
!
mBufferSize
;
}
gfx
:
:
IntSize
GetSize
(
)
const
override
{
return
mSize
;
}
gfx
:
:
IntPoint
GetOrigin
(
)
const
override
{
return
mOrigin
;
}
PlanarYCbCrImage
(
)
;
virtual
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
virtual
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
=
0
;
PlanarYCbCrImage
*
AsPlanarYCbCrImage
(
)
override
{
return
this
;
}
virtual
nsresult
BuildSurfaceDescriptorBuffer
(
SurfaceDescriptorBuffer
&
aSdBuffer
)
;
protected
:
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetAsSourceSurface
(
)
override
;
void
SetOffscreenFormat
(
gfxImageFormat
aFormat
)
{
mOffscreenFormat
=
aFormat
;
}
gfxImageFormat
GetOffscreenFormat
(
)
const
;
Data
mData
;
gfx
:
:
IntPoint
mOrigin
;
gfx
:
:
IntSize
mSize
;
gfxImageFormat
mOffscreenFormat
;
nsCountedRef
<
nsMainThreadSourceSurfaceRef
>
mSourceSurface
;
uint32_t
mBufferSize
;
}
;
class
RecyclingPlanarYCbCrImage
:
public
PlanarYCbCrImage
{
public
:
explicit
RecyclingPlanarYCbCrImage
(
BufferRecycleBin
*
aRecycleBin
)
:
mRecycleBin
(
aRecycleBin
)
{
}
virtual
~
RecyclingPlanarYCbCrImage
(
)
;
bool
CopyData
(
const
Data
&
aData
)
override
;
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
;
protected
:
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
AllocateBuffer
(
uint32_t
aSize
)
;
RefPtr
<
BufferRecycleBin
>
mRecycleBin
;
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
mBuffer
;
}
;
class
NVImage
final
:
public
Image
{
typedef
PlanarYCbCrData
Data
;
public
:
NVImage
(
)
;
virtual
~
NVImage
(
)
;
gfx
:
:
IntSize
GetSize
(
)
const
override
;
gfx
:
:
IntRect
GetPictureRect
(
)
const
override
;
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetAsSourceSurface
(
)
override
;
bool
IsValid
(
)
const
override
;
NVImage
*
AsNVImage
(
)
override
;
bool
SetData
(
const
Data
&
aData
)
;
const
Data
*
GetData
(
)
const
;
uint32_t
GetBufferSize
(
)
const
;
protected
:
mozilla
:
:
UniquePtr
<
uint8_t
>
AllocateBuffer
(
uint32_t
aSize
)
;
mozilla
:
:
UniquePtr
<
uint8_t
>
mBuffer
;
uint32_t
mBufferSize
;
gfx
:
:
IntSize
mSize
;
Data
mData
;
nsCountedRef
<
nsMainThreadSourceSurfaceRef
>
mSourceSurface
;
}
;
class
SourceSurfaceImage
final
:
public
Image
{
public
:
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetAsSourceSurface
(
)
override
{
RefPtr
<
gfx
:
:
SourceSurface
>
surface
(
mSourceSurface
)
;
return
surface
.
forget
(
)
;
}
void
SetTextureFlags
(
TextureFlags
aTextureFlags
)
{
mTextureFlags
=
aTextureFlags
;
}
TextureClient
*
GetTextureClient
(
KnowsCompositor
*
aKnowsCompositor
)
override
;
gfx
:
:
IntSize
GetSize
(
)
const
override
{
return
mSize
;
}
SourceSurfaceImage
(
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SourceSurface
*
aSourceSurface
)
;
explicit
SourceSurfaceImage
(
gfx
:
:
SourceSurface
*
aSourceSurface
)
;
virtual
~
SourceSurfaceImage
(
)
;
private
:
gfx
:
:
IntSize
mSize
;
nsCountedRef
<
nsOwningThreadSourceSurfaceRef
>
mSourceSurface
;
nsDataHashtable
<
nsUint32HashKey
RefPtr
<
TextureClient
>
>
mTextureClients
;
TextureFlags
mTextureFlags
;
}
;
}
}
#
endif
