#
ifndef
mozilla_layers_TreeTraversal_h
#
define
mozilla_layers_TreeTraversal_h
#
include
<
queue
>
namespace
mozilla
{
namespace
layers
{
enum
class
TraversalFlag
{
Skip
Continue
Abort
}
;
template
<
typename
Node
typename
PreAction
typename
PostAction
>
static
auto
ForEachNode
(
Node
*
aRoot
const
PreAction
&
aPreAction
const
PostAction
&
aPostAction
)
-
>
typename
EnableIf
<
IsSame
<
decltype
(
aPreAction
(
aRoot
)
)
TraversalFlag
>
:
:
value
&
&
IsSame
<
decltype
(
aPostAction
(
aRoot
)
)
TraversalFlag
>
:
:
value
bool
>
:
:
Type
{
if
(
!
aRoot
)
{
return
false
;
}
TraversalFlag
result
=
aPreAction
(
aRoot
)
;
if
(
result
=
=
TraversalFlag
:
:
Abort
)
{
return
true
;
}
if
(
result
=
=
TraversalFlag
:
:
Continue
)
{
for
(
Node
*
child
=
aRoot
-
>
GetLastChild
(
)
;
child
;
child
=
child
-
>
GetPrevSibling
(
)
)
{
bool
abort
=
ForEachNode
(
child
aPreAction
aPostAction
)
;
if
(
abort
)
{
return
true
;
}
}
result
=
aPostAction
(
aRoot
)
;
if
(
result
=
=
TraversalFlag
:
:
Abort
)
{
return
true
;
}
}
return
false
;
}
template
<
typename
Node
typename
PreAction
typename
PostAction
>
static
auto
ForEachNode
(
Node
*
aRoot
const
PreAction
&
aPreAction
const
PostAction
&
aPostAction
)
-
>
typename
EnableIf
<
IsSame
<
decltype
(
aPreAction
(
aRoot
)
)
void
>
:
:
value
&
&
IsSame
<
decltype
(
aPostAction
(
aRoot
)
)
void
>
:
:
value
void
>
:
:
Type
{
if
(
!
aRoot
)
{
return
;
}
aPreAction
(
aRoot
)
;
for
(
Node
*
child
=
aRoot
-
>
GetLastChild
(
)
;
child
;
child
=
child
-
>
GetPrevSibling
(
)
)
{
ForEachNode
(
child
aPreAction
aPostAction
)
;
}
aPostAction
(
aRoot
)
;
}
template
<
typename
Node
typename
PreAction
>
auto
ForEachNode
(
Node
*
aRoot
const
PreAction
&
aPreAction
)
-
>
typename
EnableIf
<
IsSame
<
decltype
(
aPreAction
(
aRoot
)
)
TraversalFlag
>
:
:
value
bool
>
:
:
Type
{
return
ForEachNode
(
aRoot
aPreAction
[
]
(
Node
*
aNode
)
{
return
TraversalFlag
:
:
Continue
;
}
)
;
}
template
<
typename
Node
typename
PreAction
>
auto
ForEachNode
(
Node
*
aRoot
const
PreAction
&
aPreAction
)
-
>
typename
EnableIf
<
IsSame
<
decltype
(
aPreAction
(
aRoot
)
)
void
>
:
:
value
void
>
:
:
Type
{
ForEachNode
(
aRoot
aPreAction
[
]
(
Node
*
aNode
)
{
}
)
;
}
template
<
typename
Node
typename
PostAction
>
auto
ForEachNodePostOrder
(
Node
*
aRoot
const
PostAction
&
aPostAction
)
-
>
typename
EnableIf
<
IsSame
<
decltype
(
aPostAction
(
aRoot
)
)
TraversalFlag
>
:
:
value
bool
>
:
:
Type
{
return
ForEachNode
(
aRoot
[
]
(
Node
*
aNode
)
{
return
TraversalFlag
:
:
Continue
;
}
aPostAction
)
;
}
template
<
typename
Node
typename
PostAction
>
auto
ForEachNodePostOrder
(
Node
*
aRoot
const
PostAction
&
aPostAction
)
-
>
typename
EnableIf
<
IsSame
<
decltype
(
aPostAction
(
aRoot
)
)
void
>
:
:
value
void
>
:
:
Type
{
ForEachNode
(
aRoot
[
]
(
Node
*
aNode
)
{
}
aPostAction
)
;
}
template
<
typename
Node
typename
Condition
>
Node
*
BreadthFirstSearch
(
Node
*
aRoot
const
Condition
&
aCondition
)
{
if
(
!
aRoot
)
{
return
nullptr
;
}
std
:
:
queue
<
Node
*
>
queue
;
queue
.
push
(
aRoot
)
;
while
(
!
queue
.
empty
(
)
)
{
Node
*
node
=
queue
.
front
(
)
;
queue
.
pop
(
)
;
if
(
aCondition
(
node
)
)
{
return
node
;
}
for
(
Node
*
child
=
node
-
>
GetLastChild
(
)
;
child
;
child
=
child
-
>
GetPrevSibling
(
)
)
{
queue
.
push
(
child
)
;
}
}
return
nullptr
;
}
template
<
typename
Node
typename
Condition
>
Node
*
DepthFirstSearch
(
Node
*
aRoot
const
Condition
&
aCondition
)
{
Node
*
result
=
nullptr
;
ForEachNode
(
aRoot
[
&
aCondition
&
result
]
(
Node
*
aNode
)
{
if
(
aCondition
(
aNode
)
)
{
result
=
aNode
;
return
TraversalFlag
:
:
Abort
;
}
return
TraversalFlag
:
:
Continue
;
}
)
;
return
result
;
}
template
<
typename
Node
typename
Condition
>
Node
*
DepthFirstSearchPostOrder
(
Node
*
aRoot
const
Condition
&
aCondition
)
{
Node
*
result
=
nullptr
;
ForEachNodePostOrder
(
aRoot
[
&
aCondition
&
result
]
(
Node
*
aNode
)
{
if
(
aCondition
(
aNode
)
)
{
result
=
aNode
;
return
TraversalFlag
:
:
Abort
;
}
return
TraversalFlag
:
:
Continue
;
}
)
;
return
result
;
}
}
}
#
endif
