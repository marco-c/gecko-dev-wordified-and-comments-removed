#
ifndef
mozilla_layers_TreeTraversal_h
#
define
mozilla_layers_TreeTraversal_h
#
include
<
queue
>
#
include
<
stack
>
namespace
mozilla
{
namespace
layers
{
enum
class
TraversalFlag
{
Skip
Continue
}
;
template
<
typename
Node
typename
Condition
>
Node
*
BreadthFirstSearch
(
Node
*
aRoot
const
Condition
&
aCondition
)
{
if
(
!
aRoot
)
{
return
nullptr
;
}
std
:
:
queue
<
Node
*
>
queue
;
queue
.
push
(
aRoot
)
;
while
(
!
queue
.
empty
(
)
)
{
Node
*
node
=
queue
.
front
(
)
;
queue
.
pop
(
)
;
if
(
aCondition
(
node
)
)
{
return
node
;
}
for
(
Node
*
child
=
node
-
>
GetLastChild
(
)
;
child
;
child
=
child
-
>
GetPrevSibling
(
)
)
{
queue
.
push
(
child
)
;
}
}
return
nullptr
;
}
template
<
typename
Node
typename
Condition
>
Node
*
DepthFirstSearch
(
Node
*
aRoot
const
Condition
&
aCondition
)
{
if
(
!
aRoot
)
{
return
nullptr
;
}
std
:
:
stack
<
Node
*
>
stack
;
stack
.
push
(
aRoot
)
;
while
(
!
stack
.
empty
(
)
)
{
Node
*
node
=
stack
.
top
(
)
;
stack
.
pop
(
)
;
if
(
aCondition
(
node
)
)
{
return
node
;
}
for
(
Node
*
child
=
node
-
>
GetLastChild
(
)
;
child
;
child
=
child
-
>
GetPrevSibling
(
)
)
{
stack
.
push
(
child
)
;
}
}
return
nullptr
;
}
template
<
typename
Node
typename
Action
>
void
ForEachNode
(
Node
*
aRoot
const
Action
&
aAction
)
{
if
(
!
aRoot
)
{
return
;
}
std
:
:
stack
<
Node
*
>
stack
;
stack
.
push
(
aRoot
)
;
while
(
!
stack
.
empty
(
)
)
{
Node
*
node
=
stack
.
top
(
)
;
stack
.
pop
(
)
;
TraversalFlag
result
=
aAction
(
node
)
;
if
(
result
=
=
TraversalFlag
:
:
Continue
)
{
for
(
Node
*
child
=
node
-
>
GetLastChild
(
)
;
child
;
child
=
child
-
>
GetPrevSibling
(
)
)
{
stack
.
push
(
child
)
;
}
}
}
}
}
}
#
endif
