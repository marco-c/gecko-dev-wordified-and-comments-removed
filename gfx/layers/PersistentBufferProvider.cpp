#
include
"
PersistentBufferProvider
.
h
"
#
include
"
Layers
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
pratom
.
h
"
#
include
"
gfxPlatform
.
h
"
namespace
mozilla
{
using
namespace
gfx
;
namespace
layers
{
PersistentBufferProviderBasic
:
:
PersistentBufferProviderBasic
(
DrawTarget
*
aDt
int64_t
*
aMemoryCounter
)
:
mDrawTarget
(
aDt
)
mMemoryCounter
(
aMemoryCounter
)
{
if
(
mMemoryCounter
)
{
IntSize
size
=
mDrawTarget
-
>
GetSize
(
)
;
*
mMemoryCounter
+
=
size
.
width
*
size
.
height
*
gfx
:
:
BytesPerPixel
(
mDrawTarget
-
>
GetFormat
(
)
)
;
}
MOZ_COUNT_CTOR
(
PersistentBufferProviderBasic
)
;
}
PersistentBufferProviderBasic
:
:
~
PersistentBufferProviderBasic
(
)
{
if
(
mMemoryCounter
)
{
IntSize
size
=
mDrawTarget
-
>
GetSize
(
)
;
*
mMemoryCounter
-
=
size
.
width
*
size
.
height
*
gfx
:
:
BytesPerPixel
(
mDrawTarget
-
>
GetFormat
(
)
)
;
}
MOZ_COUNT_DTOR
(
PersistentBufferProviderBasic
)
;
}
already_AddRefed
<
gfx
:
:
DrawTarget
>
PersistentBufferProviderBasic
:
:
BorrowDrawTarget
(
const
gfx
:
:
IntRect
&
aPersistedRect
)
{
MOZ_ASSERT
(
!
mSnapshot
)
;
RefPtr
<
gfx
:
:
DrawTarget
>
dt
(
mDrawTarget
)
;
return
dt
.
forget
(
)
;
}
bool
PersistentBufferProviderBasic
:
:
ReturnDrawTarget
(
already_AddRefed
<
gfx
:
:
DrawTarget
>
aDT
)
{
RefPtr
<
gfx
:
:
DrawTarget
>
dt
(
aDT
)
;
MOZ_ASSERT
(
mDrawTarget
=
=
dt
)
;
if
(
dt
)
{
dt
-
>
Flush
(
)
;
}
return
true
;
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
PersistentBufferProviderBasic
:
:
BorrowSnapshot
(
)
{
mSnapshot
=
mDrawTarget
-
>
Snapshot
(
)
;
RefPtr
<
SourceSurface
>
snapshot
=
mSnapshot
;
return
snapshot
.
forget
(
)
;
}
void
PersistentBufferProviderBasic
:
:
ReturnSnapshot
(
already_AddRefed
<
gfx
:
:
SourceSurface
>
aSnapshot
)
{
RefPtr
<
SourceSurface
>
snapshot
=
aSnapshot
;
MOZ_ASSERT
(
!
snapshot
|
|
snapshot
=
=
mSnapshot
)
;
mSnapshot
=
nullptr
;
}
already_AddRefed
<
PersistentBufferProviderBasic
>
PersistentBufferProviderBasic
:
:
Create
(
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
gfx
:
:
BackendType
aBackend
int64_t
*
aMemoryCounter
)
{
RefPtr
<
DrawTarget
>
dt
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateDrawTargetForBackend
(
aBackend
aSize
aFormat
)
;
if
(
!
dt
)
{
return
nullptr
;
}
RefPtr
<
PersistentBufferProviderBasic
>
provider
=
new
PersistentBufferProviderBasic
(
dt
aMemoryCounter
)
;
return
provider
.
forget
(
)
;
}
already_AddRefed
<
PersistentBufferProviderShared
>
PersistentBufferProviderShared
:
:
Create
(
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
CompositableForwarder
*
aFwd
int64_t
*
aMemoryCounter
)
{
if
(
!
aFwd
|
|
!
aFwd
-
>
IPCOpen
(
)
)
{
return
nullptr
;
}
RefPtr
<
TextureClient
>
texture
=
TextureClient
:
:
CreateForDrawing
(
aFwd
aFormat
aSize
BackendSelector
:
:
Canvas
TextureFlags
:
:
DEFAULT
TextureAllocationFlags
:
:
ALLOC_DEFAULT
)
;
if
(
!
texture
)
{
return
nullptr
;
}
RefPtr
<
PersistentBufferProviderShared
>
provider
=
new
PersistentBufferProviderShared
(
aSize
aFormat
aFwd
texture
aMemoryCounter
)
;
return
provider
.
forget
(
)
;
}
PersistentBufferProviderShared
:
:
PersistentBufferProviderShared
(
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
CompositableForwarder
*
aFwd
RefPtr
<
TextureClient
>
&
aTexture
int64_t
*
aMemoryCounter
)
:
mSize
(
aSize
)
mFormat
(
aFormat
)
mFwd
(
aFwd
)
mFront
(
Nothing
(
)
)
mMemoryCounter
(
aMemoryCounter
)
{
if
(
mTextures
.
append
(
aTexture
)
)
{
mBack
=
Some
<
uint32_t
>
(
0
)
;
}
OnAllocation
(
)
;
MOZ_COUNT_CTOR
(
PersistentBufferProviderShared
)
;
}
PersistentBufferProviderShared
:
:
~
PersistentBufferProviderShared
(
)
{
MOZ_COUNT_DTOR
(
PersistentBufferProviderShared
)
;
if
(
IsActivityTracked
(
)
)
{
mFwd
-
>
GetActiveResourceTracker
(
)
.
RemoveObject
(
this
)
;
}
Destroy
(
)
;
}
bool
PersistentBufferProviderShared
:
:
SetForwarder
(
CompositableForwarder
*
aFwd
)
{
MOZ_ASSERT
(
aFwd
)
;
if
(
!
aFwd
)
{
return
false
;
}
if
(
mFwd
=
=
aFwd
)
{
return
true
;
}
if
(
IsActivityTracked
(
)
)
{
mFwd
-
>
GetActiveResourceTracker
(
)
.
RemoveObject
(
this
)
;
}
if
(
mFwd
-
>
AsTextureForwarder
(
)
!
=
aFwd
-
>
AsTextureForwarder
(
)
|
|
mFwd
-
>
GetCompositorBackendType
(
)
!
=
aFwd
-
>
GetCompositorBackendType
(
)
)
{
RefPtr
<
TextureClient
>
prevTexture
=
GetTexture
(
mFront
)
;
Destroy
(
)
;
if
(
prevTexture
)
{
RefPtr
<
TextureClient
>
newTexture
=
TextureClient
:
:
CreateForDrawing
(
aFwd
mFormat
mSize
BackendSelector
:
:
Canvas
TextureFlags
:
:
DEFAULT
TextureAllocationFlags
:
:
ALLOC_DEFAULT
)
;
MOZ_ASSERT
(
newTexture
)
;
if
(
!
newTexture
)
{
return
false
;
}
if
(
!
newTexture
-
>
Lock
(
OpenMode
:
:
OPEN_WRITE
)
)
{
return
false
;
}
if
(
!
prevTexture
-
>
Lock
(
OpenMode
:
:
OPEN_READ
)
)
{
newTexture
-
>
Unlock
(
)
;
return
false
;
}
bool
success
=
prevTexture
-
>
CopyToTextureClient
(
newTexture
nullptr
nullptr
)
;
prevTexture
-
>
Unlock
(
)
;
newTexture
-
>
Unlock
(
)
;
if
(
!
success
)
{
return
false
;
}
if
(
!
mTextures
.
append
(
newTexture
)
)
{
return
false
;
}
mFront
=
Some
<
uint32_t
>
(
mTextures
.
length
(
)
-
1
)
;
mBack
=
mFront
;
}
}
mFwd
=
aFwd
;
return
true
;
}
TextureClient
*
PersistentBufferProviderShared
:
:
GetTexture
(
Maybe
<
uint32_t
>
aIndex
)
{
if
(
aIndex
.
isNothing
(
)
|
|
!
CheckIndex
(
aIndex
.
value
(
)
)
)
{
return
nullptr
;
}
return
mTextures
[
aIndex
.
value
(
)
]
;
}
already_AddRefed
<
gfx
:
:
DrawTarget
>
PersistentBufferProviderShared
:
:
BorrowDrawTarget
(
const
gfx
:
:
IntRect
&
aPersistedRect
)
{
if
(
!
mFwd
-
>
IPCOpen
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
!
mSnapshot
)
;
if
(
IsActivityTracked
(
)
)
{
mFwd
-
>
GetActiveResourceTracker
(
)
.
MarkUsed
(
this
)
;
}
else
{
mFwd
-
>
GetActiveResourceTracker
(
)
.
AddObject
(
this
)
;
}
if
(
mDrawTarget
)
{
RefPtr
<
gfx
:
:
DrawTarget
>
dt
(
mDrawTarget
)
;
return
dt
.
forget
(
)
;
}
mFront
=
Nothing
(
)
;
auto
previousBackBuffer
=
mBack
;
TextureClient
*
tex
=
GetTexture
(
mBack
)
;
if
(
tex
&
&
tex
-
>
IsReadLocked
(
)
)
{
tex
=
nullptr
;
}
if
(
!
tex
)
{
for
(
uint32_t
i
=
0
;
i
<
mTextures
.
length
(
)
;
+
+
i
)
{
if
(
!
mTextures
[
i
]
-
>
IsReadLocked
(
)
)
{
mBack
=
Some
(
i
)
;
tex
=
mTextures
[
i
]
;
break
;
}
}
}
if
(
!
tex
)
{
if
(
mTextures
.
length
(
)
>
=
4
)
{
MOZ_ASSERT
(
false
)
;
NotifyInactive
(
)
;
return
nullptr
;
}
RefPtr
<
TextureClient
>
newTexture
=
TextureClient
:
:
CreateForDrawing
(
mFwd
mFormat
mSize
BackendSelector
:
:
Canvas
TextureFlags
:
:
DEFAULT
TextureAllocationFlags
:
:
ALLOC_DEFAULT
)
;
MOZ_ASSERT
(
newTexture
)
;
if
(
newTexture
)
{
OnAllocation
(
)
;
if
(
mTextures
.
append
(
newTexture
)
)
{
tex
=
newTexture
;
mBack
=
Some
<
uint32_t
>
(
mTextures
.
length
(
)
-
1
)
;
}
}
}
if
(
!
tex
|
|
!
tex
-
>
Lock
(
OpenMode
:
:
OPEN_READ_WRITE
)
)
{
return
nullptr
;
}
if
(
mBack
!
=
previousBackBuffer
&
&
!
aPersistedRect
.
IsEmpty
(
)
)
{
TextureClient
*
previous
=
GetTexture
(
previousBackBuffer
)
;
if
(
previous
&
&
previous
-
>
Lock
(
OpenMode
:
:
OPEN_READ
)
)
{
DebugOnly
<
bool
>
success
=
previous
-
>
CopyToTextureClient
(
tex
&
aPersistedRect
nullptr
)
;
MOZ_ASSERT
(
success
)
;
previous
-
>
Unlock
(
)
;
}
}
mDrawTarget
=
tex
-
>
BorrowDrawTarget
(
)
;
RefPtr
<
gfx
:
:
DrawTarget
>
dt
(
mDrawTarget
)
;
return
dt
.
forget
(
)
;
}
bool
PersistentBufferProviderShared
:
:
ReturnDrawTarget
(
already_AddRefed
<
gfx
:
:
DrawTarget
>
aDT
)
{
RefPtr
<
gfx
:
:
DrawTarget
>
dt
(
aDT
)
;
MOZ_ASSERT
(
mDrawTarget
=
=
dt
)
;
MOZ_ASSERT
(
!
mSnapshot
)
;
mDrawTarget
=
nullptr
;
dt
=
nullptr
;
TextureClient
*
back
=
GetTexture
(
mBack
)
;
MOZ_ASSERT
(
back
)
;
if
(
back
)
{
back
-
>
Unlock
(
)
;
mFront
=
mBack
;
}
return
!
!
back
;
}
TextureClient
*
PersistentBufferProviderShared
:
:
GetTextureClient
(
)
{
MOZ_ASSERT
(
!
mDrawTarget
)
;
TextureClient
*
texture
=
GetTexture
(
mFront
)
;
if
(
texture
)
{
texture
-
>
EnableReadLock
(
)
;
}
else
{
gfxCriticalNote
<
<
"
PersistentBufferProviderShared
:
front
buffer
unavailable
"
;
}
return
texture
;
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
PersistentBufferProviderShared
:
:
BorrowSnapshot
(
)
{
MOZ_ASSERT
(
!
mDrawTarget
)
;
auto
front
=
GetTexture
(
mFront
)
;
if
(
!
front
|
|
front
-
>
IsLocked
(
)
)
{
MOZ_ASSERT
(
false
)
;
return
nullptr
;
}
if
(
!
front
-
>
Lock
(
OpenMode
:
:
OPEN_READ
)
)
{
return
nullptr
;
}
RefPtr
<
DrawTarget
>
dt
=
front
-
>
BorrowDrawTarget
(
)
;
if
(
!
dt
)
{
front
-
>
Unlock
(
)
;
return
nullptr
;
}
mSnapshot
=
dt
-
>
Snapshot
(
)
;
RefPtr
<
SourceSurface
>
snapshot
=
mSnapshot
;
return
snapshot
.
forget
(
)
;
}
void
PersistentBufferProviderShared
:
:
ReturnSnapshot
(
already_AddRefed
<
gfx
:
:
SourceSurface
>
aSnapshot
)
{
RefPtr
<
SourceSurface
>
snapshot
=
aSnapshot
;
MOZ_ASSERT
(
!
snapshot
|
|
snapshot
=
=
mSnapshot
)
;
mSnapshot
=
nullptr
;
snapshot
=
nullptr
;
auto
front
=
GetTexture
(
mFront
)
;
if
(
front
)
{
front
-
>
Unlock
(
)
;
}
}
void
PersistentBufferProviderShared
:
:
NotifyInactive
(
)
{
RefPtr
<
TextureClient
>
front
=
GetTexture
(
mFront
)
;
RefPtr
<
TextureClient
>
back
=
GetTexture
(
mBack
)
;
for
(
unsigned
i
=
0
;
i
<
mTextures
.
length
(
)
;
+
+
i
)
{
OnDeallocation
(
)
;
}
mTextures
.
clear
(
)
;
if
(
back
)
{
if
(
mTextures
.
append
(
back
)
)
{
mBack
=
Some
<
uint32_t
>
(
0
)
;
OnAllocation
(
)
;
}
if
(
front
=
=
back
)
{
mFront
=
mBack
;
}
}
if
(
front
&
&
front
!
=
back
)
{
if
(
mTextures
.
append
(
front
)
)
{
mFront
=
Some
<
uint32_t
>
(
mTextures
.
length
(
)
-
1
)
;
OnAllocation
(
)
;
}
}
}
void
PersistentBufferProviderShared
:
:
Destroy
(
)
{
mSnapshot
=
nullptr
;
mDrawTarget
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
mTextures
.
length
(
)
;
+
+
i
)
{
TextureClient
*
texture
=
mTextures
[
i
]
;
if
(
texture
&
&
texture
-
>
IsLocked
(
)
)
{
MOZ_ASSERT
(
false
)
;
texture
-
>
Unlock
(
)
;
}
if
(
texture
)
{
OnDeallocation
(
)
;
}
}
mTextures
.
clear
(
)
;
}
void
PersistentBufferProviderShared
:
:
OnAllocation
(
)
{
if
(
mMemoryCounter
)
{
*
mMemoryCounter
+
=
mSize
.
width
*
mSize
.
height
*
gfx
:
:
BytesPerPixel
(
mFormat
)
;
}
}
void
PersistentBufferProviderShared
:
:
OnDeallocation
(
)
{
if
(
mMemoryCounter
)
{
*
mMemoryCounter
-
=
mSize
.
width
*
mSize
.
height
*
gfx
:
:
BytesPerPixel
(
mFormat
)
;
}
}
}
}
