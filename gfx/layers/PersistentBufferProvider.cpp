#
include
"
PersistentBufferProvider
.
h
"
#
include
"
Layers
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
layers
/
TextureForwarder
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
StaticPrefs_layers
.
h
"
#
include
"
pratom
.
h
"
#
include
"
gfxPlatform
.
h
"
namespace
mozilla
{
using
namespace
gfx
;
namespace
layers
{
PersistentBufferProviderBasic
:
:
PersistentBufferProviderBasic
(
DrawTarget
*
aDt
)
:
mDrawTarget
(
aDt
)
{
MOZ_COUNT_CTOR
(
PersistentBufferProviderBasic
)
;
}
PersistentBufferProviderBasic
:
:
~
PersistentBufferProviderBasic
(
)
{
MOZ_COUNT_DTOR
(
PersistentBufferProviderBasic
)
;
Destroy
(
)
;
}
already_AddRefed
<
gfx
:
:
DrawTarget
>
PersistentBufferProviderBasic
:
:
BorrowDrawTarget
(
const
gfx
:
:
IntRect
&
aPersistedRect
)
{
MOZ_ASSERT
(
!
mSnapshot
)
;
RefPtr
<
gfx
:
:
DrawTarget
>
dt
(
mDrawTarget
)
;
return
dt
.
forget
(
)
;
}
bool
PersistentBufferProviderBasic
:
:
ReturnDrawTarget
(
already_AddRefed
<
gfx
:
:
DrawTarget
>
aDT
)
{
RefPtr
<
gfx
:
:
DrawTarget
>
dt
(
aDT
)
;
MOZ_ASSERT
(
mDrawTarget
=
=
dt
)
;
if
(
dt
)
{
dt
-
>
Flush
(
)
;
}
return
true
;
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
PersistentBufferProviderBasic
:
:
BorrowSnapshot
(
)
{
mSnapshot
=
mDrawTarget
-
>
Snapshot
(
)
;
RefPtr
<
SourceSurface
>
snapshot
=
mSnapshot
;
return
snapshot
.
forget
(
)
;
}
void
PersistentBufferProviderBasic
:
:
ReturnSnapshot
(
already_AddRefed
<
gfx
:
:
SourceSurface
>
aSnapshot
)
{
RefPtr
<
SourceSurface
>
snapshot
=
aSnapshot
;
MOZ_ASSERT
(
!
snapshot
|
|
snapshot
=
=
mSnapshot
)
;
mSnapshot
=
nullptr
;
}
void
PersistentBufferProviderBasic
:
:
Destroy
(
)
{
mSnapshot
=
nullptr
;
mDrawTarget
=
nullptr
;
}
already_AddRefed
<
PersistentBufferProviderBasic
>
PersistentBufferProviderBasic
:
:
Create
(
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
gfx
:
:
BackendType
aBackend
)
{
RefPtr
<
DrawTarget
>
dt
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateDrawTargetForBackend
(
aBackend
aSize
aFormat
)
;
if
(
dt
)
{
dt
-
>
ClearRect
(
Rect
(
0
0
0
0
)
)
;
}
if
(
!
dt
|
|
!
dt
-
>
IsValid
(
)
)
{
return
nullptr
;
}
RefPtr
<
PersistentBufferProviderBasic
>
provider
=
new
PersistentBufferProviderBasic
(
dt
)
;
return
provider
.
forget
(
)
;
}
PersistentBufferProviderAccelerated
:
:
PersistentBufferProviderAccelerated
(
DrawTarget
*
aDt
)
:
PersistentBufferProviderBasic
(
aDt
)
{
MOZ_COUNT_CTOR
(
PersistentBufferProviderAccelerated
)
;
}
PersistentBufferProviderAccelerated
:
:
~
PersistentBufferProviderAccelerated
(
)
{
MOZ_COUNT_DTOR
(
PersistentBufferProviderAccelerated
)
;
}
ClientWebGLContext
*
PersistentBufferProviderAccelerated
:
:
AsWebgl
(
)
{
return
(
ClientWebGLContext
*
)
mDrawTarget
-
>
GetNativeSurface
(
NativeSurfaceType
:
:
WEBGL_CONTEXT
)
;
}
already_AddRefed
<
PersistentBufferProviderShared
>
PersistentBufferProviderShared
:
:
Create
(
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
KnowsCompositor
*
aKnowsCompositor
)
{
if
(
!
aKnowsCompositor
|
|
!
aKnowsCompositor
-
>
GetTextureForwarder
(
)
|
|
!
aKnowsCompositor
-
>
GetTextureForwarder
(
)
-
>
IPCOpen
(
)
)
{
return
nullptr
;
}
if
(
!
StaticPrefs
:
:
layers_shared_buffer_provider_enabled
(
)
)
{
return
nullptr
;
}
#
ifdef
XP_WIN
if
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetPreferredCanvasBackend
(
)
=
=
BackendType
:
:
DIRECT2D1_1
&
&
!
TextureData
:
:
IsRemote
(
aKnowsCompositor
BackendSelector
:
:
Canvas
)
)
{
return
nullptr
;
}
#
endif
RefPtr
<
TextureClient
>
texture
=
TextureClient
:
:
CreateForDrawing
(
aKnowsCompositor
aFormat
aSize
BackendSelector
:
:
Canvas
TextureFlags
:
:
DEFAULT
|
TextureFlags
:
:
NON_BLOCKING_READ_LOCK
TextureAllocationFlags
:
:
ALLOC_DEFAULT
)
;
if
(
!
texture
)
{
return
nullptr
;
}
RefPtr
<
PersistentBufferProviderShared
>
provider
=
new
PersistentBufferProviderShared
(
aSize
aFormat
aKnowsCompositor
texture
)
;
return
provider
.
forget
(
)
;
}
PersistentBufferProviderShared
:
:
PersistentBufferProviderShared
(
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
KnowsCompositor
*
aKnowsCompositor
RefPtr
<
TextureClient
>
&
aTexture
)
:
mSize
(
aSize
)
mFormat
(
aFormat
)
mKnowsCompositor
(
aKnowsCompositor
)
mFront
(
Nothing
(
)
)
{
MOZ_ASSERT
(
aKnowsCompositor
)
;
if
(
aTexture
-
>
HasSynchronization
(
)
)
{
mPermanentBackBuffer
=
aTexture
;
if
(
!
mPermanentBackBuffer
-
>
Lock
(
OpenMode
:
:
OPEN_READ_WRITE
)
)
{
mPermanentBackBuffer
=
nullptr
;
}
}
else
{
if
(
mTextures
.
append
(
aTexture
)
)
{
mBack
=
Some
<
uint32_t
>
(
0
)
;
}
}
if
(
gfxVars
:
:
UseWebRenderTripleBufferingWin
(
)
)
{
+
+
mMaxAllowedTextures
;
}
MOZ_COUNT_CTOR
(
PersistentBufferProviderShared
)
;
}
PersistentBufferProviderShared
:
:
~
PersistentBufferProviderShared
(
)
{
MOZ_COUNT_DTOR
(
PersistentBufferProviderShared
)
;
if
(
IsActivityTracked
(
)
)
{
mKnowsCompositor
-
>
GetActiveResourceTracker
(
)
-
>
RemoveObject
(
this
)
;
}
Destroy
(
)
;
}
bool
PersistentBufferProviderShared
:
:
SetKnowsCompositor
(
KnowsCompositor
*
aKnowsCompositor
)
{
MOZ_ASSERT
(
aKnowsCompositor
)
;
if
(
!
aKnowsCompositor
)
{
return
false
;
}
if
(
mKnowsCompositor
=
=
aKnowsCompositor
)
{
return
true
;
}
if
(
IsActivityTracked
(
)
)
{
mKnowsCompositor
-
>
GetActiveResourceTracker
(
)
-
>
RemoveObject
(
this
)
;
}
if
(
mKnowsCompositor
-
>
GetTextureForwarder
(
)
!
=
aKnowsCompositor
-
>
GetTextureForwarder
(
)
|
|
mKnowsCompositor
-
>
GetCompositorBackendType
(
)
!
=
aKnowsCompositor
-
>
GetCompositorBackendType
(
)
)
{
RefPtr
<
TextureClient
>
prevTexture
=
GetTexture
(
mFront
)
;
Destroy
(
)
;
if
(
prevTexture
)
{
RefPtr
<
TextureClient
>
newTexture
=
TextureClient
:
:
CreateForDrawing
(
aKnowsCompositor
mFormat
mSize
BackendSelector
:
:
Canvas
TextureFlags
:
:
DEFAULT
|
TextureFlags
:
:
NON_BLOCKING_READ_LOCK
TextureAllocationFlags
:
:
ALLOC_DEFAULT
)
;
MOZ_ASSERT
(
newTexture
)
;
if
(
!
newTexture
)
{
return
false
;
}
if
(
newTexture
-
>
HasSynchronization
(
)
)
{
RefPtr
<
TextureClient
>
mPermanentBackBuffer
=
TextureClient
:
:
CreateForDrawing
(
aKnowsCompositor
mFormat
mSize
BackendSelector
:
:
Canvas
TextureFlags
:
:
DEFAULT
|
TextureFlags
:
:
NON_BLOCKING_READ_LOCK
TextureAllocationFlags
:
:
ALLOC_DEFAULT
)
;
if
(
!
mPermanentBackBuffer
)
{
return
false
;
}
if
(
!
mPermanentBackBuffer
-
>
Lock
(
OpenMode
:
:
OPEN_READ_WRITE
)
)
{
mPermanentBackBuffer
=
nullptr
;
return
false
;
}
}
if
(
!
newTexture
-
>
Lock
(
OpenMode
:
:
OPEN_WRITE
)
)
{
return
false
;
}
if
(
!
prevTexture
-
>
Lock
(
OpenMode
:
:
OPEN_READ
)
)
{
newTexture
-
>
Unlock
(
)
;
return
false
;
}
bool
success
=
prevTexture
-
>
CopyToTextureClient
(
newTexture
nullptr
nullptr
)
;
if
(
success
&
&
mPermanentBackBuffer
)
{
success
=
prevTexture
-
>
CopyToTextureClient
(
mPermanentBackBuffer
nullptr
nullptr
)
;
}
prevTexture
-
>
Unlock
(
)
;
newTexture
-
>
Unlock
(
)
;
if
(
!
success
)
{
return
false
;
}
if
(
!
mTextures
.
append
(
newTexture
)
)
{
return
false
;
}
mFront
=
Some
<
uint32_t
>
(
mTextures
.
length
(
)
-
1
)
;
mBack
=
mFront
;
}
}
mKnowsCompositor
=
aKnowsCompositor
;
return
true
;
}
TextureClient
*
PersistentBufferProviderShared
:
:
GetTexture
(
const
Maybe
<
uint32_t
>
&
aIndex
)
{
if
(
aIndex
.
isNothing
(
)
|
|
!
CheckIndex
(
aIndex
.
value
(
)
)
)
{
return
nullptr
;
}
return
mTextures
[
aIndex
.
value
(
)
]
;
}
already_AddRefed
<
gfx
:
:
DrawTarget
>
PersistentBufferProviderShared
:
:
BorrowDrawTarget
(
const
gfx
:
:
IntRect
&
aPersistedRect
)
{
if
(
!
mKnowsCompositor
-
>
GetTextureForwarder
(
)
|
|
!
mKnowsCompositor
-
>
GetTextureForwarder
(
)
-
>
IPCOpen
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
!
mSnapshot
)
;
if
(
IsActivityTracked
(
)
)
{
mKnowsCompositor
-
>
GetActiveResourceTracker
(
)
-
>
MarkUsed
(
this
)
;
}
else
{
mKnowsCompositor
-
>
GetActiveResourceTracker
(
)
-
>
AddObject
(
this
)
;
}
if
(
mDrawTarget
)
{
RefPtr
<
gfx
:
:
DrawTarget
>
dt
(
mDrawTarget
)
;
return
dt
.
forget
(
)
;
}
auto
previousBackBuffer
=
mBack
;
TextureClient
*
tex
=
GetTexture
(
mBack
)
;
if
(
tex
&
&
tex
-
>
IsReadLocked
(
)
)
{
tex
=
nullptr
;
}
if
(
!
tex
)
{
for
(
uint32_t
i
=
0
;
i
<
mTextures
.
length
(
)
;
+
+
i
)
{
if
(
!
mTextures
[
i
]
-
>
IsReadLocked
(
)
)
{
mBack
=
Some
(
i
)
;
tex
=
mTextures
[
i
]
;
break
;
}
}
}
if
(
!
tex
)
{
if
(
mTextures
.
length
(
)
>
=
mMaxAllowedTextures
)
{
mKnowsCompositor
-
>
SyncWithCompositor
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mTextures
.
length
(
)
;
+
+
i
)
{
if
(
!
mTextures
[
i
]
-
>
IsReadLocked
(
)
)
{
gfxCriticalNote
<
<
"
Managed
to
allocate
after
flush
.
"
;
mBack
=
Some
(
i
)
;
tex
=
mTextures
[
i
]
;
break
;
}
}
if
(
!
tex
)
{
gfxCriticalNote
<
<
"
Unexpected
BufferProvider
over
-
production
.
"
;
NotifyInactive
(
)
;
return
nullptr
;
}
}
RefPtr
<
TextureClient
>
newTexture
=
TextureClient
:
:
CreateForDrawing
(
mKnowsCompositor
mFormat
mSize
BackendSelector
:
:
Canvas
TextureFlags
:
:
DEFAULT
|
TextureFlags
:
:
NON_BLOCKING_READ_LOCK
TextureAllocationFlags
:
:
ALLOC_DEFAULT
)
;
MOZ_ASSERT
(
newTexture
)
;
if
(
newTexture
)
{
if
(
mTextures
.
append
(
newTexture
)
)
{
tex
=
newTexture
;
mBack
=
Some
<
uint32_t
>
(
mTextures
.
length
(
)
-
1
)
;
}
}
}
if
(
!
tex
)
{
return
nullptr
;
}
if
(
mPermanentBackBuffer
)
{
if
(
!
tex
-
>
Lock
(
OpenMode
:
:
OPEN_WRITE
)
)
{
return
nullptr
;
}
tex
=
mPermanentBackBuffer
;
}
else
{
Maybe
<
TextureClientAutoLock
>
autoReadLock
;
TextureClient
*
previous
=
nullptr
;
if
(
mBack
!
=
previousBackBuffer
&
&
!
aPersistedRect
.
IsEmpty
(
)
)
{
previous
=
GetTexture
(
previousBackBuffer
)
;
if
(
previous
)
{
autoReadLock
.
emplace
(
previous
OpenMode
:
:
OPEN_READ
)
;
}
}
if
(
!
tex
-
>
Lock
(
OpenMode
:
:
OPEN_READ_WRITE
)
)
{
return
nullptr
;
}
if
(
autoReadLock
.
isSome
(
)
&
&
autoReadLock
-
>
Succeeded
(
)
&
&
previous
)
{
DebugOnly
<
bool
>
success
=
previous
-
>
CopyToTextureClient
(
tex
&
aPersistedRect
nullptr
)
;
MOZ_ASSERT
(
success
)
;
}
}
mDrawTarget
=
tex
-
>
BorrowDrawTarget
(
)
;
if
(
mDrawTarget
)
{
mDrawTarget
-
>
ClearRect
(
Rect
(
0
0
0
0
)
)
;
if
(
!
mDrawTarget
-
>
IsValid
(
)
)
{
mDrawTarget
=
nullptr
;
}
}
RefPtr
<
gfx
:
:
DrawTarget
>
dt
(
mDrawTarget
)
;
return
dt
.
forget
(
)
;
}
bool
PersistentBufferProviderShared
:
:
ReturnDrawTarget
(
already_AddRefed
<
gfx
:
:
DrawTarget
>
aDT
)
{
RefPtr
<
gfx
:
:
DrawTarget
>
dt
(
aDT
)
;
MOZ_ASSERT
(
mDrawTarget
=
=
dt
)
;
MOZ_ASSERT
(
!
mSnapshot
)
;
TextureClient
*
back
=
GetTexture
(
mBack
)
;
MOZ_ASSERT
(
back
)
;
mDrawTarget
=
nullptr
;
dt
=
nullptr
;
if
(
mPermanentBackBuffer
&
&
back
)
{
DebugOnly
<
bool
>
success
=
mPermanentBackBuffer
-
>
CopyToTextureClient
(
back
nullptr
nullptr
)
;
MOZ_ASSERT
(
success
)
;
mPermanentBackBuffer
-
>
EndDraw
(
)
;
}
if
(
back
)
{
back
-
>
Unlock
(
)
;
mFront
=
mBack
;
}
return
!
!
back
;
}
TextureClient
*
PersistentBufferProviderShared
:
:
GetTextureClient
(
)
{
MOZ_ASSERT
(
!
mDrawTarget
)
;
TextureClient
*
texture
=
GetTexture
(
mFront
)
;
if
(
!
texture
)
{
gfxCriticalNote
<
<
"
PersistentBufferProviderShared
:
front
buffer
unavailable
"
;
return
nullptr
;
}
if
(
texture
-
>
IsReadLocked
(
)
)
{
RefPtr
<
DrawTarget
>
dt
=
BorrowDrawTarget
(
IntRect
(
0
0
mSize
.
width
mSize
.
height
)
)
;
if
(
dt
)
{
ReturnDrawTarget
(
dt
.
forget
(
)
)
;
texture
=
GetTexture
(
mFront
)
;
if
(
!
texture
)
{
gfxCriticalNote
<
<
"
PersistentBufferProviderShared
:
front
buffer
unavailable
"
;
return
nullptr
;
}
}
}
else
{
texture
-
>
SetUpdated
(
)
;
}
return
texture
;
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
PersistentBufferProviderShared
:
:
BorrowSnapshot
(
)
{
if
(
mPermanentBackBuffer
)
{
mSnapshot
=
mPermanentBackBuffer
-
>
BorrowSnapshot
(
)
;
return
do_AddRef
(
mSnapshot
)
;
}
if
(
mDrawTarget
)
{
auto
back
=
GetTexture
(
mBack
)
;
MOZ_ASSERT
(
back
&
&
back
-
>
IsLocked
(
)
)
;
mSnapshot
=
back
-
>
BorrowSnapshot
(
)
;
return
do_AddRef
(
mSnapshot
)
;
}
auto
front
=
GetTexture
(
mFront
)
;
if
(
!
front
|
|
front
-
>
IsLocked
(
)
)
{
MOZ_ASSERT
(
false
)
;
return
nullptr
;
}
if
(
!
front
-
>
Lock
(
OpenMode
:
:
OPEN_READ
)
)
{
return
nullptr
;
}
mSnapshot
=
front
-
>
BorrowSnapshot
(
)
;
return
do_AddRef
(
mSnapshot
)
;
}
void
PersistentBufferProviderShared
:
:
ReturnSnapshot
(
already_AddRefed
<
gfx
:
:
SourceSurface
>
aSnapshot
)
{
RefPtr
<
SourceSurface
>
snapshot
=
aSnapshot
;
MOZ_ASSERT
(
!
snapshot
|
|
snapshot
=
=
mSnapshot
)
;
mSnapshot
=
nullptr
;
snapshot
=
nullptr
;
if
(
mDrawTarget
|
|
mPermanentBackBuffer
)
{
return
;
}
auto
front
=
GetTexture
(
mFront
)
;
if
(
front
)
{
front
-
>
Unlock
(
)
;
}
}
void
PersistentBufferProviderShared
:
:
NotifyInactive
(
)
{
ClearCachedResources
(
)
;
}
void
PersistentBufferProviderShared
:
:
ClearCachedResources
(
)
{
RefPtr
<
TextureClient
>
front
=
GetTexture
(
mFront
)
;
RefPtr
<
TextureClient
>
back
=
GetTexture
(
mBack
)
;
mTextures
.
clear
(
)
;
if
(
back
)
{
if
(
mTextures
.
append
(
back
)
)
{
mBack
=
Some
<
uint32_t
>
(
0
)
;
}
if
(
front
=
=
back
)
{
mFront
=
mBack
;
}
}
if
(
front
&
&
front
!
=
back
)
{
if
(
mTextures
.
append
(
front
)
)
{
mFront
=
Some
<
uint32_t
>
(
mTextures
.
length
(
)
-
1
)
;
}
}
}
void
PersistentBufferProviderShared
:
:
Destroy
(
)
{
mSnapshot
=
nullptr
;
mDrawTarget
=
nullptr
;
if
(
mPermanentBackBuffer
)
{
mPermanentBackBuffer
-
>
Unlock
(
)
;
mPermanentBackBuffer
=
nullptr
;
}
for
(
auto
&
mTexture
:
mTextures
)
{
TextureClient
*
texture
=
mTexture
;
if
(
texture
&
&
texture
-
>
IsLocked
(
)
)
{
MOZ_ASSERT
(
false
)
;
texture
-
>
Unlock
(
)
;
}
}
mTextures
.
clear
(
)
;
}
}
}
