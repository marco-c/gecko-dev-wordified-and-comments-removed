#
ifndef
GFX_MACIOSURFACEIMAGE_H
#
define
GFX_MACIOSURFACEIMAGE_H
#
include
"
ImageContainer
.
h
"
#
include
"
mozilla
/
gfx
/
MacIOSurface
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
namespace
mozilla
{
namespace
layers
{
class
MacIOSurfaceImage
:
public
Image
{
public
:
explicit
MacIOSurfaceImage
(
MacIOSurface
*
aSurface
)
:
Image
(
nullptr
ImageFormat
:
:
MAC_IOSURFACE
)
mSurface
(
aSurface
)
{
if
(
aSurface
)
{
mPictureRect
=
gfx
:
:
IntRect
(
gfx
:
:
IntPoint
{
}
gfx
:
:
IntSize
(
aSurface
-
>
GetDevicePixelWidth
(
0
)
aSurface
-
>
GetDevicePixelHeight
(
0
)
)
)
;
}
}
bool
SetData
(
ImageContainer
*
aContainer
const
PlanarYCbCrData
&
aData
)
;
MacIOSurface
*
GetSurface
(
)
{
return
mSurface
;
}
gfx
:
:
IntSize
GetSize
(
)
const
override
{
return
gfx
:
:
IntSize
:
:
Truncate
(
mSurface
-
>
GetDevicePixelWidth
(
)
mSurface
-
>
GetDevicePixelHeight
(
)
)
;
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetAsSourceSurface
(
)
override
;
TextureClient
*
GetTextureClient
(
KnowsCompositor
*
aKnowsCompositor
)
override
;
MacIOSurfaceImage
*
AsMacIOSurfaceImage
(
)
override
{
return
this
;
}
gfx
:
:
IntRect
GetPictureRect
(
)
const
override
{
return
mPictureRect
;
}
gfx
:
:
ColorDepth
GetColorDepth
(
)
const
override
;
private
:
RefPtr
<
MacIOSurface
>
mSurface
;
RefPtr
<
TextureClient
>
mTextureClient
;
gfx
:
:
IntRect
mPictureRect
;
}
;
class
MacIOSurfaceRecycleAllocator
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MacIOSurfaceRecycleAllocator
)
already_AddRefed
<
MacIOSurface
>
Allocate
(
const
gfx
:
:
IntSize
aYSize
const
gfx
:
:
IntSize
&
aCbCrSize
gfx
:
:
YUVColorSpace
aYUVColorSpace
gfx
:
:
TransferFunction
aTransferFunction
gfx
:
:
ColorRange
aColorRange
gfx
:
:
ColorDepth
aColorDepth
)
;
private
:
~
MacIOSurfaceRecycleAllocator
(
)
=
default
;
nsTArray
<
CFTypeRefPtr
<
IOSurfaceRef
>
>
mSurfaces
;
}
;
}
}
#
endif
