#
include
"
BasicCanvasLayer
.
h
"
#
include
"
AsyncCanvasRenderer
.
h
"
#
include
"
basic
/
BasicLayers
.
h
"
#
include
"
basic
/
BasicLayersImpl
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
GLScreenBuffer
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
layers
/
PersistentBufferProvider
.
h
"
#
include
"
client
/
TextureClientSharedSurface
.
h
"
class
gfxContext
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
gl
;
namespace
mozilla
{
namespace
layers
{
already_AddRefed
<
SourceSurface
>
BasicCanvasLayer
:
:
UpdateSurface
(
)
{
if
(
mAsyncRenderer
)
{
return
mAsyncRenderer
-
>
GetSurface
(
)
;
}
if
(
mBufferProvider
)
{
return
nullptr
;
}
if
(
!
mGLContext
)
{
return
nullptr
;
}
SharedSurface
*
frontbuffer
=
nullptr
;
if
(
mGLFrontbuffer
)
{
frontbuffer
=
mGLFrontbuffer
.
get
(
)
;
}
else
{
GLScreenBuffer
*
screen
=
mGLContext
-
>
Screen
(
)
;
const
auto
&
front
=
screen
-
>
Front
(
)
;
if
(
front
)
{
frontbuffer
=
front
-
>
Surf
(
)
;
}
}
if
(
!
frontbuffer
)
{
NS_WARNING
(
"
Null
frame
received
.
"
)
;
return
nullptr
;
}
IntSize
readSize
(
frontbuffer
-
>
mSize
)
;
SurfaceFormat
format
=
(
GetContentFlags
(
)
&
CONTENT_OPAQUE
)
?
SurfaceFormat
:
:
B8G8R8X8
:
SurfaceFormat
:
:
B8G8R8A8
;
bool
needsPremult
=
frontbuffer
-
>
mHasAlpha
&
&
!
mIsAlphaPremultiplied
;
RefPtr
<
DataSourceSurface
>
resultSurf
=
GetTempSurface
(
readSize
format
)
;
if
(
NS_WARN_IF
(
!
resultSurf
)
)
{
return
nullptr
;
}
mGLContext
-
>
Readback
(
frontbuffer
resultSurf
)
;
if
(
needsPremult
)
{
gfxUtils
:
:
PremultiplyDataSurface
(
resultSurf
resultSurf
)
;
}
MOZ_ASSERT
(
resultSurf
)
;
return
resultSurf
.
forget
(
)
;
}
void
BasicCanvasLayer
:
:
Paint
(
DrawTarget
*
aDT
const
Point
&
aDeviceOffset
Layer
*
aMaskLayer
)
{
if
(
IsHidden
(
)
)
return
;
RefPtr
<
SourceSurface
>
surface
;
if
(
IsDirty
(
)
)
{
Painted
(
)
;
FirePreTransactionCallback
(
)
;
surface
=
UpdateSurface
(
)
;
FireDidTransactionCallback
(
)
;
}
AutoReturnSnapshot
autoReturn
(
mBufferProvider
)
;
if
(
mBufferProvider
)
{
MOZ_ASSERT
(
!
surface
)
;
surface
=
mBufferProvider
-
>
BorrowSnapshot
(
)
;
autoReturn
.
mSnapshot
=
&
surface
;
}
if
(
!
surface
)
{
return
;
}
const
bool
needsYFlip
=
(
mOriginPos
=
=
gl
:
:
OriginPos
:
:
BottomLeft
)
;
Matrix
oldTM
;
if
(
needsYFlip
)
{
oldTM
=
aDT
-
>
GetTransform
(
)
;
aDT
-
>
SetTransform
(
Matrix
(
oldTM
)
.
PreTranslate
(
0
.
0f
mBounds
.
height
)
.
PreScale
(
1
.
0f
-
1
.
0f
)
)
;
}
FillRectWithMask
(
aDT
aDeviceOffset
Rect
(
0
0
mBounds
.
width
mBounds
.
height
)
surface
mSamplingFilter
DrawOptions
(
GetEffectiveOpacity
(
)
GetEffectiveOperator
(
this
)
)
aMaskLayer
)
;
if
(
needsYFlip
)
{
aDT
-
>
SetTransform
(
oldTM
)
;
}
}
already_AddRefed
<
CanvasLayer
>
BasicLayerManager
:
:
CreateCanvasLayer
(
)
{
NS_ASSERTION
(
InConstruction
(
)
"
Only
allowed
in
construction
phase
"
)
;
RefPtr
<
CanvasLayer
>
layer
=
new
BasicCanvasLayer
(
this
)
;
return
layer
.
forget
(
)
;
}
}
}
