#
include
<
stdint
.
h
>
#
include
"
BasicLayers
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
ImageTypes
.
h
"
#
include
"
cairo
.
h
"
#
include
"
gfxASurface
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsAutoRef
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
DataSurfaceHelpers
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
YCbCrUtils
.
h
"
namespace
mozilla
{
namespace
layers
{
class
BasicPlanarYCbCrImage
:
public
RecyclingPlanarYCbCrImage
{
public
:
BasicPlanarYCbCrImage
(
const
gfx
:
:
IntSize
&
aScaleHint
gfxImageFormat
aOffscreenFormat
BufferRecycleBin
*
aRecycleBin
)
:
RecyclingPlanarYCbCrImage
(
aRecycleBin
)
mScaleHint
(
aScaleHint
)
mStride
(
0
)
mDelayedConversion
(
false
)
{
SetOffscreenFormat
(
aOffscreenFormat
)
;
}
~
BasicPlanarYCbCrImage
(
)
{
if
(
mDecodedBuffer
)
{
mRecycleBin
-
>
RecycleBuffer
(
std
:
:
move
(
mDecodedBuffer
)
mSize
.
height
*
mStride
)
;
}
}
virtual
bool
CopyData
(
const
Data
&
aData
)
override
;
virtual
void
SetDelayedConversion
(
bool
aDelayed
)
override
{
mDelayedConversion
=
aDelayed
;
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetAsSourceSurface
(
)
override
;
virtual
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
virtual
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
size_t
size
=
RecyclingPlanarYCbCrImage
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
size
+
=
aMallocSizeOf
(
mDecodedBuffer
.
get
(
)
)
;
return
size
;
}
private
:
UniquePtr
<
uint8_t
[
]
>
mDecodedBuffer
;
gfx
:
:
IntSize
mScaleHint
;
int
mStride
;
bool
mDelayedConversion
;
}
;
class
BasicImageFactory
:
public
ImageFactory
{
public
:
BasicImageFactory
(
)
{
}
virtual
RefPtr
<
PlanarYCbCrImage
>
CreatePlanarYCbCrImage
(
const
gfx
:
:
IntSize
&
aScaleHint
BufferRecycleBin
*
aRecycleBin
)
override
{
return
new
BasicPlanarYCbCrImage
(
aScaleHint
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetOffscreenFormat
(
)
aRecycleBin
)
;
}
}
;
bool
BasicPlanarYCbCrImage
:
:
CopyData
(
const
Data
&
aData
)
{
RecyclingPlanarYCbCrImage
:
:
CopyData
(
aData
)
;
if
(
mDelayedConversion
)
{
return
false
;
}
if
(
aData
.
mYSize
.
width
>
PlanarYCbCrImage
:
:
MAX_DIMENSION
|
|
aData
.
mYSize
.
height
>
PlanarYCbCrImage
:
:
MAX_DIMENSION
)
{
NS_ERROR
(
"
Illegal
image
source
width
or
height
"
)
;
return
false
;
}
gfx
:
:
SurfaceFormat
format
=
gfx
:
:
ImageFormatToSurfaceFormat
(
GetOffscreenFormat
(
)
)
;
gfx
:
:
IntSize
size
(
mScaleHint
)
;
gfx
:
:
GetYCbCrToRGBDestFormatAndSize
(
aData
format
size
)
;
if
(
size
.
width
>
PlanarYCbCrImage
:
:
MAX_DIMENSION
|
|
size
.
height
>
PlanarYCbCrImage
:
:
MAX_DIMENSION
)
{
NS_ERROR
(
"
Illegal
image
dest
width
or
height
"
)
;
return
false
;
}
mStride
=
gfx
:
:
StrideForFormatAndWidth
(
format
size
.
width
)
;
mozilla
:
:
CheckedInt32
requiredBytes
=
mozilla
:
:
CheckedInt32
(
size
.
height
)
*
mozilla
:
:
CheckedInt32
(
mStride
)
;
if
(
!
requiredBytes
.
isValid
(
)
)
{
return
false
;
}
mDecodedBuffer
=
AllocateBuffer
(
requiredBytes
.
value
(
)
)
;
if
(
!
mDecodedBuffer
)
{
return
false
;
}
gfx
:
:
ConvertYCbCrToRGB
(
aData
format
size
mDecodedBuffer
.
get
(
)
mStride
)
;
SetOffscreenFormat
(
gfx
:
:
SurfaceFormatToImageFormat
(
format
)
)
;
mSize
=
size
;
return
true
;
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
BasicPlanarYCbCrImage
:
:
GetAsSourceSurface
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Must
be
main
thread
"
)
;
if
(
mSourceSurface
)
{
RefPtr
<
gfx
:
:
SourceSurface
>
surface
(
mSourceSurface
)
;
return
surface
.
forget
(
)
;
}
if
(
!
mDecodedBuffer
)
{
return
PlanarYCbCrImage
:
:
GetAsSourceSurface
(
)
;
}
gfxImageFormat
format
=
GetOffscreenFormat
(
)
;
RefPtr
<
gfx
:
:
SourceSurface
>
surface
;
{
RefPtr
<
gfx
:
:
DrawTarget
>
drawTarget
=
gfxPlatform
:
:
CreateDrawTargetForData
(
mDecodedBuffer
.
get
(
)
mSize
mStride
gfx
:
:
ImageFormatToSurfaceFormat
(
format
)
)
;
if
(
!
drawTarget
)
{
return
nullptr
;
}
surface
=
drawTarget
-
>
Snapshot
(
)
;
}
mRecycleBin
-
>
RecycleBuffer
(
std
:
:
move
(
mDecodedBuffer
)
mSize
.
height
*
mStride
)
;
mSourceSurface
=
surface
;
return
surface
.
forget
(
)
;
}
ImageFactory
*
BasicLayerManager
:
:
GetImageFactory
(
)
{
if
(
!
mFactory
)
{
mFactory
=
new
BasicImageFactory
(
)
;
}
return
mFactory
.
get
(
)
;
}
}
}
