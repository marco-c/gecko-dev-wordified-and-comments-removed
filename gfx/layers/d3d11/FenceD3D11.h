#
ifndef
MOZILLA_GFX_FenceD3D11_H
#
define
MOZILLA_GFX_FenceD3D11_H
#
include
<
unordered_map
>
#
include
"
mozilla
/
gfx
/
FileHandleWrapper
.
h
"
#
include
"
mozilla
/
layers
/
Fence
.
h
"
struct
ID3D11Device
;
struct
ID3D11Fence
;
namespace
mozilla
{
namespace
layers
{
class
FenceD3D11
final
:
public
Fence
{
public
:
static
RefPtr
<
FenceD3D11
>
Create
(
ID3D11Device
*
aDevice
)
;
static
RefPtr
<
FenceD3D11
>
CreateFromHandle
(
RefPtr
<
gfx
:
:
FileHandleWrapper
>
aHandle
const
RefPtr
<
ID3D11Device
>
aDevice
)
;
FenceD3D11
*
AsFenceD3D11
(
)
override
{
return
this
;
}
static
bool
IsSupported
(
ID3D11Device
*
aDevice
)
;
RefPtr
<
FenceD3D11
>
CloneFromHandle
(
)
;
bool
IncrementAndSignal
(
)
;
void
Update
(
uint64_t
aFenceValue
)
;
bool
Wait
(
ID3D11Device
*
aDevice
)
;
uint64_t
GetFenceValue
(
)
const
{
return
mFenceValue
;
}
enum
class
OwnsFence
:
bool
{
No
Yes
}
;
const
OwnsFence
mOwnsFence
;
const
RefPtr
<
ID3D11Device
>
mDevice
;
const
RefPtr
<
ID3D11Fence
>
mSignalFence
;
const
RefPtr
<
gfx
:
:
FileHandleWrapper
>
mHandle
;
protected
:
FenceD3D11
(
const
OwnsFence
aOwnsFence
const
RefPtr
<
ID3D11Device
>
aDevice
const
RefPtr
<
ID3D11Fence
>
aSignalFence
const
RefPtr
<
gfx
:
:
FileHandleWrapper
>
&
aHandle
)
;
virtual
~
FenceD3D11
(
)
;
uint64_t
mFenceValue
=
0
;
std
:
:
unordered_map
<
const
ID3D11Device
*
RefPtr
<
ID3D11Fence
>
>
mWaitFenceMap
;
}
;
}
}
#
endif
