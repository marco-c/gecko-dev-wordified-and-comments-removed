#
include
"
ReadbackManagerD3D11
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
using
namespace
gfx
;
namespace
layers
{
struct
ReadbackTask
{
RefPtr
<
ID3D10Texture2D
>
mReadbackTexture
;
RefPtr
<
TextureReadbackSink
>
mSink
;
}
;
class
ReadbackResultWriterD3D11
final
:
public
nsIRunnable
{
~
ReadbackResultWriterD3D11
(
)
{
}
NS_DECL_THREADSAFE_ISUPPORTS
public
:
explicit
ReadbackResultWriterD3D11
(
UniquePtr
<
ReadbackTask
>
&
&
aTask
)
:
mTask
(
std
:
:
move
(
aTask
)
)
{
}
NS_IMETHOD
Run
(
)
override
{
D3D10_TEXTURE2D_DESC
desc
;
mTask
-
>
mReadbackTexture
-
>
GetDesc
(
&
desc
)
;
D3D10_MAPPED_TEXTURE2D
mappedTex
;
HRESULT
hr
=
mTask
-
>
mReadbackTexture
-
>
Map
(
0
D3D10_MAP_READ
0
&
mappedTex
)
;
if
(
FAILED
(
hr
)
)
{
mTask
-
>
mSink
-
>
ProcessReadback
(
nullptr
)
;
return
NS_OK
;
}
{
RefPtr
<
DataSourceSurface
>
surf
=
Factory
:
:
CreateWrappingDataSourceSurface
(
(
uint8_t
*
)
mappedTex
.
pData
mappedTex
.
RowPitch
IntSize
(
desc
.
Width
desc
.
Height
)
SurfaceFormat
:
:
B8G8R8A8
)
;
mTask
-
>
mSink
-
>
ProcessReadback
(
surf
)
;
MOZ_ASSERT
(
surf
-
>
hasOneRef
(
)
)
;
}
mTask
-
>
mReadbackTexture
-
>
Unmap
(
0
)
;
return
NS_OK
;
}
private
:
UniquePtr
<
ReadbackTask
>
mTask
;
}
;
NS_IMPL_ISUPPORTS
(
ReadbackResultWriterD3D11
nsIRunnable
)
DWORD
WINAPI
ReadbackManagerD3D11
:
:
StartTaskThread
(
void
*
aManager
)
{
static_cast
<
ReadbackManagerD3D11
*
>
(
aManager
)
-
>
ProcessTasks
(
)
;
return
0
;
}
ReadbackManagerD3D11
:
:
ReadbackManagerD3D11
(
)
:
mRefCnt
(
0
)
{
:
:
InitializeCriticalSection
(
&
mTaskMutex
)
;
mShutdownEvent
=
:
:
CreateEventA
(
nullptr
FALSE
FALSE
nullptr
)
;
mTaskSemaphore
=
:
:
CreateSemaphoreA
(
nullptr
0
1000000
nullptr
)
;
mTaskThread
=
:
:
CreateThread
(
nullptr
0
StartTaskThread
this
0
0
)
;
}
ReadbackManagerD3D11
:
:
~
ReadbackManagerD3D11
(
)
{
:
:
SetEvent
(
mShutdownEvent
)
;
DWORD
result
=
:
:
WaitForSingleObject
(
mTaskThread
5000
)
;
if
(
result
!
=
WAIT_TIMEOUT
)
{
:
:
DeleteCriticalSection
(
&
mTaskMutex
)
;
:
:
CloseHandle
(
mShutdownEvent
)
;
:
:
CloseHandle
(
mTaskSemaphore
)
;
:
:
CloseHandle
(
mTaskThread
)
;
}
else
{
MOZ_CRASH
(
"
ReadbackManager
:
Task
thread
did
not
shutdown
in
5
seconds
.
"
)
;
}
}
void
ReadbackManagerD3D11
:
:
PostTask
(
ID3D10Texture2D
*
aTexture
TextureReadbackSink
*
aSink
)
{
auto
task
=
MakeUnique
<
ReadbackTask
>
(
)
;
task
-
>
mReadbackTexture
=
aTexture
;
task
-
>
mSink
=
aSink
;
:
:
EnterCriticalSection
(
&
mTaskMutex
)
;
mPendingReadbackTasks
.
AppendElement
(
std
:
:
move
(
task
)
)
;
:
:
LeaveCriticalSection
(
&
mTaskMutex
)
;
:
:
ReleaseSemaphore
(
mTaskSemaphore
1
nullptr
)
;
}
void
ReadbackManagerD3D11
:
:
ProcessTasks
(
)
{
HANDLE
handles
[
]
=
{
mTaskSemaphore
mShutdownEvent
}
;
while
(
true
)
{
DWORD
result
=
:
:
WaitForMultipleObjects
(
2
handles
FALSE
INFINITE
)
;
if
(
result
!
=
WAIT_OBJECT_0
)
{
return
;
}
:
:
EnterCriticalSection
(
&
mTaskMutex
)
;
if
(
mPendingReadbackTasks
.
Length
(
)
=
=
0
)
{
MOZ_CRASH
(
"
Trying
to
read
from
an
empty
array
bad
bad
bad
"
)
;
}
UniquePtr
<
ReadbackTask
>
nextReadbackTask
=
std
:
:
move
(
mPendingReadbackTasks
[
0
]
)
;
mPendingReadbackTasks
.
RemoveElementAt
(
0
)
;
:
:
LeaveCriticalSection
(
&
mTaskMutex
)
;
D3D10_MAPPED_TEXTURE2D
mappedTex
;
nextReadbackTask
-
>
mReadbackTexture
-
>
Map
(
0
D3D10_MAP_READ
0
&
mappedTex
)
;
nextReadbackTask
-
>
mReadbackTexture
-
>
Unmap
(
0
)
;
nsCOMPtr
<
nsIThread
>
thread
=
do_GetMainThread
(
)
;
thread
-
>
Dispatch
(
new
ReadbackResultWriterD3D11
(
std
:
:
move
(
nextReadbackTask
)
)
nsIEventTarget
:
:
DISPATCH_NORMAL
)
;
}
}
}
}
