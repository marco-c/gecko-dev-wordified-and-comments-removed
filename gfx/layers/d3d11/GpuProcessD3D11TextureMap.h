#
ifndef
MOZILLA_GFX_GpuProcessD3D11TextureMap_H
#
define
MOZILLA_GFX_GpuProcessD3D11TextureMap_H
#
include
<
d3d11
.
h
>
#
include
<
unordered_map
>
#
include
<
unordered_set
>
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
namespace
mozilla
{
namespace
layers
{
class
ZeroCopyUsageInfo
;
class
TextureWrapperD3D11Allocator
;
class
GpuProcessD3D11TextureMap
{
struct
UpdatingTextureHolder
;
public
:
static
void
Init
(
)
;
static
void
Shutdown
(
)
;
static
GpuProcessD3D11TextureMap
*
Get
(
)
{
return
sInstance
;
}
static
GpuProcessTextureId
GetNextTextureId
(
)
;
GpuProcessD3D11TextureMap
(
)
;
~
GpuProcessD3D11TextureMap
(
)
;
void
Register
(
GpuProcessTextureId
aTextureId
ID3D11Texture2D
*
aTexture
uint32_t
aArrayIndex
const
gfx
:
:
IntSize
&
aSize
RefPtr
<
ZeroCopyUsageInfo
>
aUsageInfo
RefPtr
<
gfx
:
:
FileHandleWrapper
>
aSharedHandle
=
nullptr
)
;
void
Register
(
const
MonitorAutoLock
&
aProofOfLock
GpuProcessTextureId
aTextureId
ID3D11Texture2D
*
aTexture
uint32_t
aArrayIndex
const
gfx
:
:
IntSize
&
aSize
RefPtr
<
ZeroCopyUsageInfo
>
aUsageInfo
RefPtr
<
gfx
:
:
FileHandleWrapper
>
aSharedHandle
)
;
void
Unregister
(
GpuProcessTextureId
aTextureId
)
;
RefPtr
<
ID3D11Texture2D
>
GetTexture
(
GpuProcessTextureId
aTextureId
)
;
Maybe
<
HANDLE
>
GetSharedHandle
(
GpuProcessTextureId
aTextureId
)
;
size_t
GetWaitingTextureCount
(
)
const
;
bool
WaitTextureReady
(
const
GpuProcessTextureId
aTextureId
)
;
void
PostUpdateTextureDataTask
(
const
GpuProcessTextureId
aTextureId
TextureHost
*
aTextureHost
TextureHost
*
aWrappedTextureHost
TextureWrapperD3D11Allocator
*
aAllocator
)
;
void
HandleInTextureUpdateThread
(
)
;
private
:
struct
TextureHolder
{
TextureHolder
(
ID3D11Texture2D
*
aTexture
uint32_t
aArrayIndex
const
gfx
:
:
IntSize
&
aSize
RefPtr
<
ZeroCopyUsageInfo
>
aUsageInfo
RefPtr
<
gfx
:
:
FileHandleWrapper
>
aSharedHandle
)
;
TextureHolder
(
)
=
default
;
RefPtr
<
ID3D11Texture2D
>
mTexture
;
uint32_t
mArrayIndex
=
0
;
gfx
:
:
IntSize
mSize
;
RefPtr
<
ZeroCopyUsageInfo
>
mZeroCopyUsageInfo
;
RefPtr
<
gfx
:
:
FileHandleWrapper
>
mSharedHandle
;
RefPtr
<
ID3D11Texture2D
>
mCopiedTexture
;
RefPtr
<
gfx
:
:
FileHandleWrapper
>
mCopiedTextureSharedHandle
;
}
;
struct
UpdatingTextureHolder
{
UpdatingTextureHolder
(
const
GpuProcessTextureId
aTextureId
TextureHost
*
aTextureHost
TextureHost
*
aWrappedTextureHost
TextureWrapperD3D11Allocator
*
aAllocator
)
;
~
UpdatingTextureHolder
(
)
;
const
GpuProcessTextureId
mTextureId
;
RefPtr
<
TextureHost
>
mTextureHost
;
CompositableTextureHostRef
mWrappedTextureHost
;
RefPtr
<
TextureWrapperD3D11Allocator
>
mAllocator
;
}
;
enum
class
UpdatingStatus
{
Waiting
Updating
Error
}
;
RefPtr
<
ID3D11Texture2D
>
UpdateTextureData
(
UpdatingTextureHolder
*
aHolder
)
;
mutable
Monitor
mMonitor
MOZ_UNANNOTATED
;
std
:
:
unordered_map
<
GpuProcessTextureId
TextureHolder
GpuProcessTextureId
:
:
HashFn
>
mD3D11TexturesById
;
std
:
:
deque
<
UniquePtr
<
UpdatingTextureHolder
>
>
mWaitingTextureQueue
;
std
:
:
unordered_set
<
GpuProcessTextureId
GpuProcessTextureId
:
:
HashFn
>
mWaitingTextures
;
static
StaticAutoPtr
<
GpuProcessD3D11TextureMap
>
sInstance
;
}
;
}
}
#
endif
