#
ifndef
MOZILLA_GFX_GpuProcessD3D11TextureMap_H
#
define
MOZILLA_GFX_GpuProcessD3D11TextureMap_H
#
include
<
d3d11
.
h
>
#
include
<
unordered_map
>
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
namespace
mozilla
{
namespace
layers
{
class
IMFSampleUsageInfo
;
class
GpuProcessD3D11TextureMap
{
public
:
static
void
Init
(
)
;
static
void
Shutdown
(
)
;
static
GpuProcessD3D11TextureMap
*
Get
(
)
{
return
sInstance
;
}
static
GpuProcessTextureId
GetNextTextureId
(
)
;
GpuProcessD3D11TextureMap
(
)
;
~
GpuProcessD3D11TextureMap
(
)
;
void
Register
(
GpuProcessTextureId
aTextureId
ID3D11Texture2D
*
aTexture
uint32_t
aArrayIndex
const
gfx
:
:
IntSize
&
aSize
RefPtr
<
IMFSampleUsageInfo
>
aUsageInfo
)
;
void
Unregister
(
GpuProcessTextureId
aTextureId
)
;
RefPtr
<
ID3D11Texture2D
>
GetTexture
(
GpuProcessTextureId
aTextureId
)
;
Maybe
<
HANDLE
>
GetSharedHandleOfCopiedTexture
(
GpuProcessTextureId
aTextureId
)
;
private
:
struct
TextureHolder
{
TextureHolder
(
ID3D11Texture2D
*
aTexture
uint32_t
aArrayIndex
const
gfx
:
:
IntSize
&
aSize
RefPtr
<
IMFSampleUsageInfo
>
aUsageInfo
)
;
TextureHolder
(
)
=
default
;
RefPtr
<
ID3D11Texture2D
>
mTexture
;
uint32_t
mArrayIndex
=
0
;
gfx
:
:
IntSize
mSize
;
RefPtr
<
IMFSampleUsageInfo
>
mIMFSampleUsageInfo
;
RefPtr
<
ID3D11Texture2D
>
mCopiedTexture
;
Maybe
<
HANDLE
>
mCopiedTextureSharedHandle
;
}
;
DataMutex
<
std
:
:
unordered_map
<
GpuProcessTextureId
TextureHolder
GpuProcessTextureId
:
:
HashFn
>
>
mD3D11TexturesById
;
static
StaticAutoPtr
<
GpuProcessD3D11TextureMap
>
sInstance
;
}
;
}
}
#
endif
