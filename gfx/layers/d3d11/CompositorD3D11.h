#
ifndef
MOZILLA_GFX_COMPOSITORD3D11_H
#
define
MOZILLA_GFX_COMPOSITORD3D11_H
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
TextureD3D11
.
h
"
#
include
<
d3d11
.
h
>
#
include
<
dxgi1_2
.
h
>
#
include
"
ShaderDefinitionsD3D11
.
h
"
class
nsWidget
;
namespace
mozilla
{
namespace
layers
{
#
define
LOGD3D11
(
param
)
class
DeviceAttachmentsD3D11
;
class
DiagnosticsD3D11
;
class
CompositorD3D11
:
public
Compositor
{
public
:
CompositorD3D11
(
CompositorBridgeParent
*
aParent
widget
:
:
CompositorWidget
*
aWidget
)
;
virtual
~
CompositorD3D11
(
)
;
CompositorD3D11
*
AsCompositorD3D11
(
)
override
{
return
this
;
}
bool
Initialize
(
nsCString
*
const
out_failureReason
)
override
;
TextureFactoryIdentifier
GetTextureFactoryIdentifier
(
)
override
;
already_AddRefed
<
DataTextureSource
>
CreateDataTextureSource
(
TextureFlags
aFlags
=
TextureFlags
:
:
NO_FLAGS
)
override
;
bool
CanUseCanvasLayerForSize
(
const
gfx
:
:
IntSize
&
aSize
)
override
;
int32_t
GetMaxTextureSize
(
)
const
final
;
void
MakeCurrent
(
MakeCurrentFlags
aFlags
=
0
)
override
{
}
already_AddRefed
<
CompositingRenderTarget
>
CreateRenderTarget
(
const
gfx
:
:
IntRect
&
aRect
SurfaceInitMode
aInit
)
override
;
already_AddRefed
<
CompositingRenderTarget
>
CreateRenderTargetFromSource
(
const
gfx
:
:
IntRect
&
aRect
const
CompositingRenderTarget
*
aSource
const
gfx
:
:
IntPoint
&
aSourcePoint
)
override
;
void
SetRenderTarget
(
CompositingRenderTarget
*
aSurface
)
override
;
already_AddRefed
<
CompositingRenderTarget
>
GetCurrentRenderTarget
(
)
const
override
{
return
do_AddRef
(
mCurrentRT
)
;
}
already_AddRefed
<
CompositingRenderTarget
>
GetWindowRenderTarget
(
)
const
override
;
bool
ReadbackRenderTarget
(
CompositingRenderTarget
*
aSource
AsyncReadbackBuffer
*
aDest
)
override
;
already_AddRefed
<
AsyncReadbackBuffer
>
CreateAsyncReadbackBuffer
(
const
gfx
:
:
IntSize
&
aSize
)
override
;
bool
BlitRenderTarget
(
CompositingRenderTarget
*
aSource
const
gfx
:
:
IntSize
&
aSourceSize
const
gfx
:
:
IntSize
&
aDestSize
)
override
;
void
SetDestinationSurfaceSize
(
const
gfx
:
:
IntSize
&
aSize
)
override
{
}
void
ClearRect
(
const
gfx
:
:
Rect
&
aRect
)
override
;
void
DrawQuad
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
IntRect
&
aClipRect
const
EffectChain
&
aEffectChain
gfx
:
:
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfx
:
:
Rect
&
aVisibleRect
)
override
;
Maybe
<
gfx
:
:
IntRect
>
BeginFrameForWindow
(
const
nsIntRegion
&
aInvalidRegion
const
Maybe
<
gfx
:
:
IntRect
>
&
aClipRect
const
gfx
:
:
IntRect
&
aRenderBounds
const
nsIntRegion
&
aOpaqueRegion
)
override
;
Maybe
<
gfx
:
:
IntRect
>
BeginFrameForTarget
(
const
nsIntRegion
&
aInvalidRegion
const
Maybe
<
gfx
:
:
IntRect
>
&
aClipRect
const
gfx
:
:
IntRect
&
aRenderBounds
const
nsIntRegion
&
aOpaqueRegion
gfx
:
:
DrawTarget
*
aTarget
const
gfx
:
:
IntRect
&
aTargetBounds
)
override
;
void
BeginFrameForNativeLayers
(
)
override
;
Maybe
<
gfx
:
:
IntRect
>
BeginRenderingToNativeLayer
(
const
nsIntRegion
&
aInvalidRegion
const
Maybe
<
gfx
:
:
IntRect
>
&
aClipRect
const
nsIntRegion
&
aOpaqueRegion
NativeLayer
*
aNativeLayer
)
override
;
void
EndRenderingToNativeLayer
(
)
override
;
void
NormalDrawingDone
(
)
override
;
void
EndFrame
(
)
override
;
void
CancelFrame
(
bool
aNeedFlush
=
true
)
override
;
virtual
void
PrepareViewport
(
const
gfx
:
:
IntSize
&
aSize
)
;
virtual
void
PrepareViewport
(
const
gfx
:
:
IntSize
&
aSize
const
gfx
:
:
Matrix4x4
&
aProjection
float
aZNear
float
aZFar
)
;
bool
SupportsPartialTextureUpdate
(
)
override
{
return
true
;
}
bool
SupportsLayerGeometry
(
)
const
override
;
#
ifdef
MOZ_DUMP_PAINTING
const
char
*
Name
(
)
const
override
{
return
"
Direct3D
11
"
;
}
#
endif
LayersBackend
GetBackendType
(
)
const
override
{
return
LayersBackend
:
:
LAYERS_D3D11
;
}
virtual
void
ForcePresent
(
)
;
ID3D11Device
*
GetD3D11Device
(
)
const
override
{
return
mDevice
;
}
ID3D11Device
*
GetDevice
(
)
{
return
mDevice
;
}
ID3D11DeviceContext
*
GetDC
(
)
{
return
mContext
;
}
virtual
void
RequestAllowFrameRecording
(
bool
aWillRecord
)
override
{
mAllowFrameRecording
=
aWillRecord
;
}
void
Readback
(
gfx
:
:
DrawTarget
*
aDrawTarget
)
{
mTarget
=
aDrawTarget
;
mTargetBounds
=
gfx
:
:
IntRect
(
)
;
PaintToTarget
(
)
;
mTarget
=
nullptr
;
}
SyncObjectHost
*
GetSyncObject
(
)
;
private
:
enum
Severity
{
Recoverable
DebugAssert
Critical
}
;
void
HandleError
(
HRESULT
hr
Severity
aSeverity
=
DebugAssert
)
;
bool
Failed
(
HRESULT
hr
const
char
*
aContext
)
;
void
EnsureSize
(
)
;
bool
VerifyBufferSize
(
)
;
bool
UpdateRenderTarget
(
)
;
bool
UpdateConstantBuffers
(
)
;
void
SetSamplerForSamplingFilter
(
gfx
:
:
SamplingFilter
aSamplingFilter
)
;
ID3D11PixelShader
*
GetPSForEffect
(
Effect
*
aEffect
const
bool
aUseBlendShader
const
MaskType
aMaskType
)
;
Maybe
<
gfx
:
:
IntRect
>
BeginFrame
(
const
nsIntRegion
&
aInvalidRegion
const
Maybe
<
gfx
:
:
IntRect
>
&
aClipRect
const
gfx
:
:
IntRect
&
aRenderBounds
const
nsIntRegion
&
aOpaqueRegion
)
;
void
PaintToTarget
(
)
;
RefPtr
<
ID3D11Texture2D
>
CreateTexture
(
const
gfx
:
:
IntRect
&
aRect
const
CompositingRenderTarget
*
aSource
const
gfx
:
:
IntPoint
&
aSourcePoint
)
;
bool
CopyBackdrop
(
const
gfx
:
:
IntRect
&
aRect
RefPtr
<
ID3D11Texture2D
>
*
aOutTexture
RefPtr
<
ID3D11ShaderResourceView
>
*
aOutView
)
;
void
DrawTriangles
(
const
nsTArray
<
gfx
:
:
TexturedTriangle
>
&
aTriangles
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
IntRect
&
aClipRect
const
EffectChain
&
aEffectChain
gfx
:
:
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfx
:
:
Rect
&
aVisibleRect
)
override
;
template
<
typename
Geometry
>
void
DrawGeometry
(
const
Geometry
&
aGeometry
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
IntRect
&
aClipRect
const
EffectChain
&
aEffectChain
gfx
:
:
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfx
:
:
Rect
&
aVisibleRect
)
;
bool
UpdateDynamicVertexBuffer
(
const
nsTArray
<
gfx
:
:
TexturedTriangle
>
&
aTriangles
)
;
void
PrepareDynamicVertexBuffer
(
)
;
void
PrepareStaticVertexBuffer
(
)
;
void
Draw
(
const
nsTArray
<
gfx
:
:
TexturedTriangle
>
&
aGeometry
const
gfx
:
:
Rect
*
aTexCoords
)
;
void
Draw
(
const
gfx
:
:
Rect
&
aGeometry
const
gfx
:
:
Rect
*
aTexCoords
)
;
void
GetFrameStats
(
GPUStats
*
aStats
)
override
;
void
Present
(
)
;
ID3D11VertexShader
*
GetVSForGeometry
(
const
nsTArray
<
gfx
:
:
TexturedTriangle
>
&
aTriangles
const
bool
aUseBlendShader
const
MaskType
aMaskType
)
;
ID3D11VertexShader
*
GetVSForGeometry
(
const
gfx
:
:
Rect
&
aRect
const
bool
aUseBlendShader
const
MaskType
aMaskType
)
;
template
<
typename
VertexType
>
void
SetVertexBuffer
(
ID3D11Buffer
*
aBuffer
)
;
bool
ShouldAllowFrameRecording
(
)
const
;
RefPtr
<
gfx
:
:
DrawTarget
>
mTarget
;
gfx
:
:
IntRect
mTargetBounds
;
RefPtr
<
ID3D11DeviceContext
>
mContext
;
RefPtr
<
ID3D11Device
>
mDevice
;
RefPtr
<
IDXGISwapChain
>
mSwapChain
;
RefPtr
<
CompositingRenderTargetD3D11
>
mDefaultRT
;
RefPtr
<
CompositingRenderTargetD3D11
>
mCurrentRT
;
mutable
RefPtr
<
CompositingRenderTargetD3D11
>
mWindowRTCopy
;
RefPtr
<
ID3D11Query
>
mQuery
;
RefPtr
<
DeviceAttachmentsD3D11
>
mAttachments
;
UniquePtr
<
DiagnosticsD3D11
>
mDiagnostics
;
LayoutDeviceIntSize
mSize
;
LayoutDeviceIntSize
mBufferSize
;
HWND
mHwnd
;
D3D_FEATURE_LEVEL
mFeatureLevel
;
VertexShaderConstants
mVSConstants
;
PixelShaderConstants
mPSConstants
;
bool
mDisableSequenceForNextFrame
;
bool
mAllowPartialPresents
;
bool
mIsDoubleBuffered
;
gfx
:
:
IntRegion
mFrontBufferInvalid
;
gfx
:
:
IntRegion
mBackBufferInvalid
;
gfx
:
:
IntRect
mCurrentClip
;
bool
mVerifyBuffersFailed
;
bool
mUseMutexOnPresent
;
bool
mAllowFrameRecording
;
}
;
namespace
TexSlot
{
static
const
int
RGB
=
0
;
static
const
int
Y
=
1
;
static
const
int
Cb
=
2
;
static
const
int
Cr
=
3
;
static
const
int
RGBWhite
=
4
;
static
const
int
Mask
=
5
;
static
const
int
Backdrop
=
6
;
}
}
}
#
endif
