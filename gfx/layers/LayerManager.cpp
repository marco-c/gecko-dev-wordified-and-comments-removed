#
include
"
mozilla
/
layers
/
LayerManager
.
h
"
#
include
<
stdint
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
algorithm
>
#
include
<
utility
>
#
include
"
FrameMetrics
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
LayerUserData
.
h
"
#
include
"
Layers
.
h
"
#
include
"
TreeTraversal
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
ArrayIterator
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
StaticPrefs_layers
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
Animation
.
h
"
#
include
"
mozilla
/
dom
/
AnimationEffect
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
gfx
/
UserData
.
h
"
#
include
"
mozilla
/
layers
/
LayerMetricsWrapper
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
PersistentBufferProvider
.
h
"
#
include
"
mozilla
/
layers
/
ScrollableLayerGuid
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsTArray
.
h
"
uint8_t
gLayerManagerLayerBuilder
;
#
undef
compress
#
include
"
mozilla
/
Compression
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
Compression
;
LayerManager
:
:
LayerManager
(
)
:
mDestroyed
(
false
)
mSnapEffectiveTransforms
(
true
)
mId
(
0
)
mInTransaction
(
false
)
mContainsSVG
(
false
)
mPaintedPixelCount
(
0
)
{
}
LayerManager
:
:
~
LayerManager
(
)
=
default
;
void
LayerManager
:
:
Destroy
(
)
{
mDestroyed
=
true
;
mUserData
.
Destroy
(
)
;
mRoot
=
nullptr
;
mPartialPrerenderedAnimations
.
Clear
(
)
;
}
mozilla
:
:
LogModule
*
LayerManager
:
:
GetLog
(
)
{
static
LazyLogModule
sLog
(
"
Layers
"
)
;
return
sLog
;
}
ScrollableLayerGuid
:
:
ViewID
LayerManager
:
:
GetRootScrollableLayerId
(
)
{
if
(
!
mRoot
)
{
return
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
;
}
LayerMetricsWrapper
layerMetricsRoot
=
LayerMetricsWrapper
(
mRoot
)
;
LayerMetricsWrapper
rootScrollableLayerMetrics
=
BreadthFirstSearch
<
ForwardIterator
>
(
layerMetricsRoot
[
]
(
LayerMetricsWrapper
aLayerMetrics
)
{
return
aLayerMetrics
.
Metrics
(
)
.
IsScrollable
(
)
;
}
)
;
return
rootScrollableLayerMetrics
.
IsValid
(
)
?
rootScrollableLayerMetrics
.
Metrics
(
)
.
GetScrollId
(
)
:
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
;
}
LayerMetricsWrapper
LayerManager
:
:
GetRootContentLayer
(
)
{
if
(
!
mRoot
)
{
return
LayerMetricsWrapper
(
)
;
}
LayerMetricsWrapper
root
(
mRoot
)
;
return
BreadthFirstSearch
<
ForwardIterator
>
(
root
[
]
(
LayerMetricsWrapper
aLayerMetrics
)
{
return
aLayerMetrics
.
Metrics
(
)
.
IsRootContent
(
)
;
}
)
;
}
already_AddRefed
<
DrawTarget
>
LayerManager
:
:
CreateOptimalDrawTarget
(
const
gfx
:
:
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
return
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateOffscreenContentDrawTarget
(
aSize
aFormat
)
;
}
already_AddRefed
<
DrawTarget
>
LayerManager
:
:
CreateOptimalMaskDrawTarget
(
const
gfx
:
:
IntSize
&
aSize
)
{
return
CreateOptimalDrawTarget
(
aSize
SurfaceFormat
:
:
A8
)
;
}
already_AddRefed
<
DrawTarget
>
LayerManager
:
:
CreateDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
return
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateOffscreenCanvasDrawTarget
(
aSize
aFormat
)
;
}
already_AddRefed
<
PersistentBufferProvider
>
LayerManager
:
:
CreatePersistentBufferProvider
(
const
mozilla
:
:
gfx
:
:
IntSize
&
aSize
mozilla
:
:
gfx
:
:
SurfaceFormat
aFormat
)
{
RefPtr
<
PersistentBufferProviderBasic
>
bufferProvider
=
PersistentBufferProviderBasic
:
:
Create
(
aSize
aFormat
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetPreferredCanvasBackend
(
)
)
;
if
(
!
bufferProvider
)
{
bufferProvider
=
PersistentBufferProviderBasic
:
:
Create
(
aSize
aFormat
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetFallbackCanvasBackend
(
)
)
;
}
return
bufferProvider
.
forget
(
)
;
}
already_AddRefed
<
ImageContainer
>
LayerManager
:
:
CreateImageContainer
(
ImageContainer
:
:
Mode
flag
)
{
RefPtr
<
ImageContainer
>
container
=
new
ImageContainer
(
flag
)
;
return
container
.
forget
(
)
;
}
bool
LayerManager
:
:
LayersComponentAlphaEnabled
(
)
{
#
ifdef
MOZ_GFX_OPTIMIZE_MOBILE
return
false
;
#
else
return
StaticPrefs
:
:
layers_componentalpha_enabled_AtStartup_DoNotUseDirectly
(
)
;
#
endif
}
bool
LayerManager
:
:
AreComponentAlphaLayersEnabled
(
)
{
return
LayerManager
:
:
LayersComponentAlphaEnabled
(
)
;
}
void
LayerManager
:
:
LayerUserDataDestroy
(
void
*
data
)
{
delete
static_cast
<
LayerUserData
*
>
(
data
)
;
}
UniquePtr
<
LayerUserData
>
LayerManager
:
:
RemoveUserData
(
void
*
aKey
)
{
UniquePtr
<
LayerUserData
>
d
(
static_cast
<
LayerUserData
*
>
(
mUserData
.
Remove
(
static_cast
<
gfx
:
:
UserDataKey
*
>
(
aKey
)
)
)
)
;
return
d
;
}
void
LayerManager
:
:
PayloadPresented
(
const
TimeStamp
&
aTimeStamp
)
{
RecordCompositionPayloadsPresented
(
aTimeStamp
mPayload
)
;
}
void
LayerManager
:
:
AddPartialPrerenderedAnimation
(
uint64_t
aCompositorAnimationId
dom
:
:
Animation
*
aAnimation
)
{
mPartialPrerenderedAnimations
.
Put
(
aCompositorAnimationId
RefPtr
{
aAnimation
}
)
;
aAnimation
-
>
SetPartialPrerendered
(
aCompositorAnimationId
)
;
}
void
LayerManager
:
:
RemovePartialPrerenderedAnimation
(
uint64_t
aCompositorAnimationId
dom
:
:
Animation
*
aAnimation
)
{
MOZ_ASSERT
(
aAnimation
)
;
#
ifdef
DEBUG
RefPtr
<
dom
:
:
Animation
>
animation
;
if
(
mPartialPrerenderedAnimations
.
Remove
(
aCompositorAnimationId
getter_AddRefs
(
animation
)
)
&
&
aAnimation
-
>
GetEffect
(
)
&
&
aAnimation
-
>
GetEffect
(
)
-
>
AsKeyframeEffect
(
)
&
&
animation
-
>
GetEffect
(
)
&
&
animation
-
>
GetEffect
(
)
-
>
AsKeyframeEffect
(
)
)
{
MOZ_ASSERT
(
EffectSet
:
:
GetEffectSetForEffect
(
aAnimation
-
>
GetEffect
(
)
-
>
AsKeyframeEffect
(
)
)
=
=
EffectSet
:
:
GetEffectSetForEffect
(
animation
-
>
GetEffect
(
)
-
>
AsKeyframeEffect
(
)
)
)
;
}
#
else
mPartialPrerenderedAnimations
.
Remove
(
aCompositorAnimationId
)
;
#
endif
aAnimation
-
>
ResetPartialPrerendered
(
)
;
}
void
LayerManager
:
:
UpdatePartialPrerenderedAnimations
(
const
nsTArray
<
uint64_t
>
&
aJankedAnimations
)
{
for
(
uint64_t
id
:
aJankedAnimations
)
{
RefPtr
<
dom
:
:
Animation
>
animation
;
if
(
mPartialPrerenderedAnimations
.
Remove
(
id
getter_AddRefs
(
animation
)
)
)
{
animation
-
>
UpdatePartialPrerendered
(
)
;
}
}
}
}
}
