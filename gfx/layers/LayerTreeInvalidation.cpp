#
include
"
LayerTreeInvalidation
.
h
"
#
include
<
stdint
.
h
>
#
include
"
ImageContainer
.
h
"
#
include
"
ImageLayers
.
h
"
#
include
"
Layers
.
h
"
#
include
"
Units
.
h
"
#
include
"
gfxRect
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
gfx
/
BaseSize
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
layers
/
ImageHost
.
h
"
#
include
"
mozilla
/
layers
/
LayerManagerComposite
.
h
"
#
include
"
LayersLogging
.
h
"
#
define
LTI_DEBUG
0
#
if
LTI_DEBUG
#
define
LTI_DEEPER
(
aPrefix
)
nsPrintfCString
(
"
%
s
"
aPrefix
)
.
get
(
)
#
define
LTI_DUMP
(
rgn
label
)
if
(
!
(
rgn
)
.
IsEmpty
(
)
)
printf_stderr
(
"
%
s
%
p
:
"
label
"
portion
is
%
s
\
n
"
aPrefix
mLayer
.
get
(
)
Stringify
(
rgn
)
.
c_str
(
)
)
;
#
define
LTI_LOG
(
.
.
.
)
printf_stderr
(
__VA_ARGS__
)
#
else
#
define
LTI_DEEPER
(
aPrefix
)
nullptr
#
define
LTI_DUMP
(
rgn
label
)
#
define
LTI_LOG
(
.
.
.
)
#
endif
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
namespace
layers
{
struct
LayerPropertiesBase
;
UniquePtr
<
LayerPropertiesBase
>
CloneLayerTreePropertiesInternal
(
Layer
*
aRoot
)
;
static
Matrix4x4
GetTransformIn3DContext
(
Layer
*
aLayer
)
{
Matrix4x4
transform
=
aLayer
-
>
GetLocalTransform
(
)
;
for
(
Layer
*
layer
=
aLayer
-
>
GetParent
(
)
;
layer
&
&
layer
-
>
Extend3DContext
(
)
;
layer
=
layer
-
>
GetParent
(
)
)
{
transform
=
transform
*
layer
-
>
GetLocalTransform
(
)
;
}
return
transform
;
}
static
Matrix4x4
GetTransformForInvalidation
(
Layer
*
aLayer
)
{
return
(
!
aLayer
-
>
Is3DContextLeaf
(
)
&
&
!
aLayer
-
>
Extend3DContext
(
)
?
aLayer
-
>
GetLocalTransform
(
)
:
GetTransformIn3DContext
(
aLayer
)
)
;
}
static
IntRect
TransformRect
(
const
IntRect
&
aRect
const
Matrix4x4
&
aTransform
)
{
if
(
aRect
.
IsEmpty
(
)
)
{
return
IntRect
(
)
;
}
Rect
rect
(
aRect
.
x
aRect
.
y
aRect
.
width
aRect
.
height
)
;
rect
=
aTransform
.
TransformAndClipBounds
(
rect
Rect
:
:
MaxIntRect
(
)
)
;
rect
.
RoundOut
(
)
;
IntRect
intRect
;
if
(
!
gfxUtils
:
:
GfxRectToIntRect
(
ThebesRect
(
rect
)
&
intRect
)
)
{
return
IntRect
(
)
;
}
return
intRect
;
}
static
void
AddTransformedRegion
(
nsIntRegion
&
aDest
const
nsIntRegion
&
aSource
const
Matrix4x4
&
aTransform
)
{
for
(
auto
iter
=
aSource
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
aDest
.
Or
(
aDest
TransformRect
(
iter
.
Get
(
)
aTransform
)
)
;
}
aDest
.
SimplifyOutward
(
20
)
;
}
static
void
AddRegion
(
nsIntRegion
&
aDest
const
nsIntRegion
&
aSource
)
{
aDest
.
Or
(
aDest
aSource
)
;
aDest
.
SimplifyOutward
(
20
)
;
}
static
void
NotifySubdocumentInvalidationRecursive
(
Layer
*
aLayer
NotifySubDocInvalidationFunc
aCallback
)
{
aLayer
-
>
ClearInvalidRect
(
)
;
ContainerLayer
*
container
=
aLayer
-
>
AsContainerLayer
(
)
;
if
(
aLayer
-
>
GetMaskLayer
(
)
)
{
NotifySubdocumentInvalidationRecursive
(
aLayer
-
>
GetMaskLayer
(
)
aCallback
)
;
}
for
(
size_t
i
=
0
;
i
<
aLayer
-
>
GetAncestorMaskLayerCount
(
)
;
i
+
+
)
{
Layer
*
maskLayer
=
aLayer
-
>
GetAncestorMaskLayerAt
(
i
)
;
NotifySubdocumentInvalidationRecursive
(
maskLayer
aCallback
)
;
}
if
(
!
container
)
{
return
;
}
for
(
Layer
*
child
=
container
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
NotifySubdocumentInvalidationRecursive
(
child
aCallback
)
;
}
aCallback
(
container
container
-
>
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
)
;
}
struct
LayerPropertiesBase
:
public
LayerProperties
{
explicit
LayerPropertiesBase
(
Layer
*
aLayer
)
:
mLayer
(
aLayer
)
mMaskLayer
(
nullptr
)
mVisibleRegion
(
mLayer
-
>
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
)
mInvalidRegion
(
aLayer
-
>
GetInvalidRegion
(
)
)
mPostXScale
(
aLayer
-
>
GetPostXScale
(
)
)
mPostYScale
(
aLayer
-
>
GetPostYScale
(
)
)
mOpacity
(
aLayer
-
>
GetLocalOpacity
(
)
)
mUseClipRect
(
!
!
aLayer
-
>
GetEffectiveClipRect
(
)
)
{
MOZ_COUNT_CTOR
(
LayerPropertiesBase
)
;
if
(
aLayer
-
>
GetMaskLayer
(
)
)
{
mMaskLayer
=
CloneLayerTreePropertiesInternal
(
aLayer
-
>
GetMaskLayer
(
)
)
;
}
for
(
size_t
i
=
0
;
i
<
aLayer
-
>
GetAncestorMaskLayerCount
(
)
;
i
+
+
)
{
Layer
*
maskLayer
=
aLayer
-
>
GetAncestorMaskLayerAt
(
i
)
;
mAncestorMaskLayers
.
AppendElement
(
CloneLayerTreePropertiesInternal
(
maskLayer
)
)
;
}
if
(
mUseClipRect
)
{
mClipRect
=
*
aLayer
-
>
GetEffectiveClipRect
(
)
;
}
mTransform
=
GetTransformForInvalidation
(
aLayer
)
;
}
LayerPropertiesBase
(
)
:
mLayer
(
nullptr
)
mMaskLayer
(
nullptr
)
{
MOZ_COUNT_CTOR
(
LayerPropertiesBase
)
;
}
~
LayerPropertiesBase
(
)
{
MOZ_COUNT_DTOR
(
LayerPropertiesBase
)
;
}
virtual
nsIntRegion
ComputeDifferences
(
Layer
*
aRoot
NotifySubDocInvalidationFunc
aCallback
bool
*
aGeometryChanged
)
;
virtual
void
MoveBy
(
const
IntPoint
&
aOffset
)
;
nsIntRegion
ComputeChange
(
const
char
*
aPrefix
NotifySubDocInvalidationFunc
aCallback
bool
&
aGeometryChanged
)
{
bool
transformChanged
=
!
mTransform
.
FuzzyEqual
(
GetTransformForInvalidation
(
mLayer
)
)
|
|
mLayer
-
>
GetPostXScale
(
)
!
=
mPostXScale
|
|
mLayer
-
>
GetPostYScale
(
)
!
=
mPostYScale
;
const
Maybe
<
ParentLayerIntRect
>
&
otherClip
=
mLayer
-
>
GetEffectiveClipRect
(
)
;
nsIntRegion
result
;
bool
ancestorMaskChanged
=
mAncestorMaskLayers
.
Length
(
)
!
=
mLayer
-
>
GetAncestorMaskLayerCount
(
)
;
if
(
!
ancestorMaskChanged
)
{
for
(
size_t
i
=
0
;
i
<
mAncestorMaskLayers
.
Length
(
)
;
i
+
+
)
{
if
(
mLayer
-
>
GetAncestorMaskLayerAt
(
i
)
!
=
mAncestorMaskLayers
[
i
]
-
>
mLayer
)
{
ancestorMaskChanged
=
true
;
break
;
}
}
}
Layer
*
otherMask
=
mLayer
-
>
GetMaskLayer
(
)
;
if
(
(
mMaskLayer
?
mMaskLayer
-
>
mLayer
:
nullptr
)
!
=
otherMask
|
|
ancestorMaskChanged
|
|
(
mUseClipRect
!
=
!
!
otherClip
)
|
|
mLayer
-
>
GetLocalOpacity
(
)
!
=
mOpacity
|
|
transformChanged
)
{
aGeometryChanged
=
true
;
result
=
OldTransformedBounds
(
)
;
LTI_DUMP
(
result
"
oldtransform
"
)
;
LTI_DUMP
(
NewTransformedBounds
(
)
"
newtransform
"
)
;
AddRegion
(
result
NewTransformedBounds
(
)
)
;
}
nsIntRegion
internal
=
ComputeChangeInternal
(
aPrefix
aCallback
aGeometryChanged
)
;
LTI_DUMP
(
internal
"
internal
"
)
;
AddRegion
(
result
internal
)
;
LTI_DUMP
(
mLayer
-
>
GetInvalidRegion
(
)
"
invalid
"
)
;
AddTransformedRegion
(
result
mLayer
-
>
GetInvalidRegion
(
)
mTransform
)
;
if
(
mMaskLayer
&
&
otherMask
)
{
nsIntRegion
mask
=
mMaskLayer
-
>
ComputeChange
(
aPrefix
aCallback
aGeometryChanged
)
;
LTI_DUMP
(
mask
"
mask
"
)
;
AddTransformedRegion
(
result
mask
mTransform
)
;
}
for
(
size_t
i
=
0
;
i
<
std
:
:
min
(
mAncestorMaskLayers
.
Length
(
)
mLayer
-
>
GetAncestorMaskLayerCount
(
)
)
;
i
+
+
)
{
nsIntRegion
mask
=
mAncestorMaskLayers
[
i
]
-
>
ComputeChange
(
aPrefix
aCallback
aGeometryChanged
)
;
LTI_DUMP
(
mask
"
ancestormask
"
)
;
AddTransformedRegion
(
result
mask
mTransform
)
;
}
if
(
mUseClipRect
&
&
otherClip
)
{
if
(
!
mClipRect
.
IsEqualInterior
(
*
otherClip
)
)
{
aGeometryChanged
=
true
;
nsIntRegion
tmp
;
tmp
.
Xor
(
mClipRect
.
ToUnknownRect
(
)
otherClip
-
>
ToUnknownRect
(
)
)
;
LTI_DUMP
(
tmp
"
clip
"
)
;
AddRegion
(
result
tmp
)
;
}
}
mLayer
-
>
ClearInvalidRect
(
)
;
return
result
;
}
virtual
IntRect
NewTransformedBounds
(
)
{
return
TransformRect
(
mLayer
-
>
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
.
GetBounds
(
)
GetTransformForInvalidation
(
mLayer
)
)
;
}
virtual
IntRect
OldTransformedBounds
(
)
{
return
TransformRect
(
mVisibleRegion
.
ToUnknownRegion
(
)
.
GetBounds
(
)
mTransform
)
;
}
virtual
nsIntRegion
ComputeChangeInternal
(
const
char
*
aPrefix
NotifySubDocInvalidationFunc
aCallback
bool
&
aGeometryChanged
)
{
return
IntRect
(
)
;
}
RefPtr
<
Layer
>
mLayer
;
UniquePtr
<
LayerPropertiesBase
>
mMaskLayer
;
nsTArray
<
UniquePtr
<
LayerPropertiesBase
>
>
mAncestorMaskLayers
;
nsIntRegion
mVisibleRegion
;
nsIntRegion
mInvalidRegion
;
Matrix4x4
mTransform
;
float
mPostXScale
;
float
mPostYScale
;
float
mOpacity
;
ParentLayerIntRect
mClipRect
;
bool
mUseClipRect
;
}
;
struct
ContainerLayerProperties
:
public
LayerPropertiesBase
{
explicit
ContainerLayerProperties
(
ContainerLayer
*
aLayer
)
:
LayerPropertiesBase
(
aLayer
)
mPreXScale
(
aLayer
-
>
GetPreXScale
(
)
)
mPreYScale
(
aLayer
-
>
GetPreYScale
(
)
)
{
for
(
Layer
*
child
=
aLayer
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
mChildren
.
AppendElement
(
Move
(
CloneLayerTreePropertiesInternal
(
child
)
)
)
;
}
}
nsIntRegion
ComputeChangeInternal
(
const
char
*
aPrefix
NotifySubDocInvalidationFunc
aCallback
bool
&
aGeometryChanged
)
override
{
ContainerLayer
*
container
=
mLayer
-
>
AsContainerLayer
(
)
;
nsIntRegion
invalidOfLayer
;
nsIntRegion
result
;
bool
childrenChanged
=
false
;
if
(
mPreXScale
!
=
container
-
>
GetPreXScale
(
)
|
|
mPreYScale
!
=
container
-
>
GetPreYScale
(
)
)
{
aGeometryChanged
=
true
;
invalidOfLayer
=
OldTransformedBounds
(
)
;
AddRegion
(
invalidOfLayer
NewTransformedBounds
(
)
)
;
childrenChanged
=
true
;
}
nsDataHashtable
<
nsPtrHashKey
<
Layer
>
uint32_t
>
oldIndexMap
(
mChildren
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mChildren
.
Length
(
)
;
+
+
i
)
{
oldIndexMap
.
Put
(
mChildren
[
i
]
-
>
mLayer
i
)
;
}
uint32_t
i
=
0
;
for
(
Layer
*
child
=
container
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
bool
invalidateChildsCurrentArea
=
false
;
if
(
i
<
mChildren
.
Length
(
)
)
{
uint32_t
childsOldIndex
;
if
(
oldIndexMap
.
Get
(
child
&
childsOldIndex
)
)
{
if
(
childsOldIndex
>
=
i
)
{
for
(
uint32_t
j
=
i
;
j
<
childsOldIndex
;
+
+
j
)
{
AddRegion
(
result
mChildren
[
j
]
-
>
OldTransformedBounds
(
)
)
;
childrenChanged
|
=
true
;
}
nsIntRegion
region
=
mChildren
[
childsOldIndex
]
-
>
ComputeChange
(
LTI_DEEPER
(
aPrefix
)
aCallback
aGeometryChanged
)
;
i
=
childsOldIndex
+
1
;
if
(
!
region
.
IsEmpty
(
)
)
{
LTI_LOG
(
"
%
s
%
p
:
child
%
p
produced
%
s
\
n
"
aPrefix
mLayer
.
get
(
)
mChildren
[
childsOldIndex
]
-
>
mLayer
.
get
(
)
Stringify
(
region
)
.
c_str
(
)
)
;
AddRegion
(
result
region
)
;
childrenChanged
|
=
true
;
}
}
else
{
invalidateChildsCurrentArea
=
true
;
}
}
else
{
invalidateChildsCurrentArea
=
true
;
}
}
else
{
invalidateChildsCurrentArea
=
true
;
}
if
(
invalidateChildsCurrentArea
)
{
aGeometryChanged
=
true
;
LTI_DUMP
(
child
-
>
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
"
invalidateChildsCurrentArea
"
)
;
AddTransformedRegion
(
result
child
-
>
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
GetTransformForInvalidation
(
child
)
)
;
if
(
aCallback
)
{
NotifySubdocumentInvalidationRecursive
(
child
aCallback
)
;
}
else
{
ClearInvalidations
(
child
)
;
}
}
childrenChanged
|
=
invalidateChildsCurrentArea
;
}
while
(
i
<
mChildren
.
Length
(
)
)
{
childrenChanged
|
=
true
;
LTI_DUMP
(
mChildren
[
i
]
-
>
OldTransformedBounds
(
)
"
removed
child
"
)
;
AddRegion
(
result
mChildren
[
i
]
-
>
OldTransformedBounds
(
)
)
;
i
+
+
;
}
if
(
aCallback
)
{
aCallback
(
container
result
)
;
}
if
(
childrenChanged
)
{
container
-
>
SetChildrenChanged
(
true
)
;
}
if
(
!
mLayer
-
>
Extend3DContext
(
)
)
{
result
.
Transform
(
GetTransformForInvalidation
(
mLayer
)
)
;
}
LTI_DUMP
(
invalidOfLayer
"
invalidOfLayer
"
)
;
result
.
OrWith
(
invalidOfLayer
)
;
return
result
;
}
IntRect
NewTransformedBounds
(
)
override
{
if
(
mLayer
-
>
Extend3DContext
(
)
)
{
IntRect
result
;
for
(
UniquePtr
<
LayerPropertiesBase
>
&
child
:
mChildren
)
{
result
=
result
.
Union
(
child
-
>
NewTransformedBounds
(
)
)
;
}
return
result
;
}
return
LayerPropertiesBase
:
:
NewTransformedBounds
(
)
;
}
IntRect
OldTransformedBounds
(
)
override
{
if
(
mLayer
-
>
Extend3DContext
(
)
)
{
IntRect
result
;
for
(
UniquePtr
<
LayerPropertiesBase
>
&
child
:
mChildren
)
{
result
=
result
.
Union
(
child
-
>
OldTransformedBounds
(
)
)
;
}
return
result
;
}
return
LayerPropertiesBase
:
:
OldTransformedBounds
(
)
;
}
AutoTArray
<
UniquePtr
<
LayerPropertiesBase
>
1
>
mChildren
;
float
mPreXScale
;
float
mPreYScale
;
}
;
struct
ColorLayerProperties
:
public
LayerPropertiesBase
{
explicit
ColorLayerProperties
(
ColorLayer
*
aLayer
)
:
LayerPropertiesBase
(
aLayer
)
mColor
(
aLayer
-
>
GetColor
(
)
)
mBounds
(
aLayer
-
>
GetBounds
(
)
)
{
}
virtual
nsIntRegion
ComputeChangeInternal
(
const
char
*
aPrefix
NotifySubDocInvalidationFunc
aCallback
bool
&
aGeometryChanged
)
{
ColorLayer
*
color
=
static_cast
<
ColorLayer
*
>
(
mLayer
.
get
(
)
)
;
if
(
mColor
!
=
color
-
>
GetColor
(
)
)
{
aGeometryChanged
=
true
;
return
NewTransformedBounds
(
)
;
}
nsIntRegion
boundsDiff
;
boundsDiff
.
Xor
(
mBounds
color
-
>
GetBounds
(
)
)
;
LTI_DUMP
(
boundsDiff
"
color
"
)
;
nsIntRegion
result
;
AddTransformedRegion
(
result
boundsDiff
mTransform
)
;
return
result
;
}
Color
mColor
;
IntRect
mBounds
;
}
;
static
ImageHost
*
GetImageHost
(
Layer
*
aLayer
)
{
LayerComposite
*
composite
=
aLayer
-
>
AsLayerComposite
(
)
;
if
(
composite
)
{
return
static_cast
<
ImageHost
*
>
(
composite
-
>
GetCompositableHost
(
)
)
;
}
return
nullptr
;
}
struct
ImageLayerProperties
:
public
LayerPropertiesBase
{
explicit
ImageLayerProperties
(
ImageLayer
*
aImage
)
:
LayerPropertiesBase
(
aImage
)
mContainer
(
aImage
-
>
GetContainer
(
)
)
mImageHost
(
GetImageHost
(
aImage
)
)
mFilter
(
aImage
-
>
GetFilter
(
)
)
mScaleToSize
(
aImage
-
>
GetScaleToSize
(
)
)
mScaleMode
(
aImage
-
>
GetScaleMode
(
)
)
mLastProducerID
(
-
1
)
mLastFrameID
(
-
1
)
{
if
(
mContainer
)
{
mRect
.
SizeTo
(
mContainer
-
>
GetCurrentSize
(
)
)
;
}
if
(
mImageHost
)
{
mRect
.
SizeTo
(
mImageHost
-
>
GetImageSize
(
)
)
;
mLastProducerID
=
mImageHost
-
>
GetLastProducerID
(
)
;
mLastFrameID
=
mImageHost
-
>
GetLastFrameID
(
)
;
}
}
IntRect
NewTransformedBounds
(
)
override
{
IntRect
rect
;
ImageLayer
*
imageLayer
=
static_cast
<
ImageLayer
*
>
(
mLayer
.
get
(
)
)
;
if
(
ImageContainer
*
container
=
imageLayer
-
>
GetContainer
(
)
)
{
rect
.
SizeTo
(
container
-
>
GetCurrentSize
(
)
)
;
}
if
(
ImageHost
*
host
=
GetImageHost
(
imageLayer
)
)
{
rect
.
SizeTo
(
host
-
>
GetImageSize
(
)
)
;
}
return
TransformRect
(
rect
GetTransformForInvalidation
(
mLayer
)
)
;
}
IntRect
OldTransformedBounds
(
)
override
{
return
TransformRect
(
mRect
mTransform
)
;
}
virtual
nsIntRegion
ComputeChangeInternal
(
const
char
*
aPrefix
NotifySubDocInvalidationFunc
aCallback
bool
&
aGeometryChanged
)
override
{
ImageLayer
*
imageLayer
=
static_cast
<
ImageLayer
*
>
(
mLayer
.
get
(
)
)
;
if
(
!
imageLayer
-
>
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
.
IsEqual
(
mVisibleRegion
)
)
{
aGeometryChanged
=
true
;
IntRect
result
=
NewTransformedBounds
(
)
;
result
=
result
.
Union
(
OldTransformedBounds
(
)
)
;
LTI_DUMP
(
result
"
image
"
)
;
return
result
;
}
ImageContainer
*
container
=
imageLayer
-
>
GetContainer
(
)
;
ImageHost
*
host
=
GetImageHost
(
imageLayer
)
;
if
(
mContainer
!
=
container
|
|
mFilter
!
=
imageLayer
-
>
GetFilter
(
)
|
|
mScaleToSize
!
=
imageLayer
-
>
GetScaleToSize
(
)
|
|
mScaleMode
!
=
imageLayer
-
>
GetScaleMode
(
)
|
|
host
!
=
mImageHost
|
|
(
host
&
&
host
-
>
GetProducerID
(
)
!
=
mLastProducerID
)
|
|
(
host
&
&
host
-
>
GetFrameID
(
)
!
=
mLastFrameID
)
)
{
aGeometryChanged
=
true
;
LTI_DUMP
(
NewTransformedBounds
(
)
"
bounds
"
)
;
return
NewTransformedBounds
(
)
;
}
return
IntRect
(
)
;
}
RefPtr
<
ImageContainer
>
mContainer
;
RefPtr
<
ImageHost
>
mImageHost
;
Filter
mFilter
;
gfx
:
:
IntSize
mScaleToSize
;
ScaleMode
mScaleMode
;
IntRect
mRect
;
int32_t
mLastProducerID
;
int32_t
mLastFrameID
;
}
;
struct
CanvasLayerProperties
:
public
LayerPropertiesBase
{
explicit
CanvasLayerProperties
(
CanvasLayer
*
aCanvas
)
:
LayerPropertiesBase
(
aCanvas
)
mImageHost
(
GetImageHost
(
aCanvas
)
)
{
mFrameID
=
mImageHost
?
mImageHost
-
>
GetFrameID
(
)
:
-
1
;
}
virtual
nsIntRegion
ComputeChangeInternal
(
const
char
*
aPrefix
NotifySubDocInvalidationFunc
aCallback
bool
&
aGeometryChanged
)
{
CanvasLayer
*
canvasLayer
=
static_cast
<
CanvasLayer
*
>
(
mLayer
.
get
(
)
)
;
ImageHost
*
host
=
GetImageHost
(
canvasLayer
)
;
if
(
host
&
&
host
-
>
GetFrameID
(
)
!
=
mFrameID
)
{
aGeometryChanged
=
true
;
return
NewTransformedBounds
(
)
;
}
return
IntRect
(
)
;
}
RefPtr
<
ImageHost
>
mImageHost
;
int32_t
mFrameID
;
}
;
UniquePtr
<
LayerPropertiesBase
>
CloneLayerTreePropertiesInternal
(
Layer
*
aRoot
)
{
if
(
!
aRoot
)
{
return
MakeUnique
<
LayerPropertiesBase
>
(
)
;
}
switch
(
aRoot
-
>
GetType
(
)
)
{
case
Layer
:
:
TYPE_CONTAINER
:
case
Layer
:
:
TYPE_REF
:
return
MakeUnique
<
ContainerLayerProperties
>
(
aRoot
-
>
AsContainerLayer
(
)
)
;
case
Layer
:
:
TYPE_COLOR
:
return
MakeUnique
<
ColorLayerProperties
>
(
static_cast
<
ColorLayer
*
>
(
aRoot
)
)
;
case
Layer
:
:
TYPE_IMAGE
:
return
MakeUnique
<
ImageLayerProperties
>
(
static_cast
<
ImageLayer
*
>
(
aRoot
)
)
;
case
Layer
:
:
TYPE_CANVAS
:
return
MakeUnique
<
CanvasLayerProperties
>
(
static_cast
<
CanvasLayer
*
>
(
aRoot
)
)
;
case
Layer
:
:
TYPE_READBACK
:
case
Layer
:
:
TYPE_SHADOW
:
case
Layer
:
:
TYPE_PAINTED
:
return
MakeUnique
<
LayerPropertiesBase
>
(
aRoot
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
root
layer
type
"
)
;
return
MakeUnique
<
LayerPropertiesBase
>
(
aRoot
)
;
}
UniquePtr
<
LayerProperties
>
LayerProperties
:
:
CloneFrom
(
Layer
*
aRoot
)
{
return
CloneLayerTreePropertiesInternal
(
aRoot
)
;
}
void
LayerProperties
:
:
ClearInvalidations
(
Layer
*
aLayer
)
{
aLayer
-
>
ClearInvalidRect
(
)
;
if
(
aLayer
-
>
GetMaskLayer
(
)
)
{
ClearInvalidations
(
aLayer
-
>
GetMaskLayer
(
)
)
;
}
for
(
size_t
i
=
0
;
i
<
aLayer
-
>
GetAncestorMaskLayerCount
(
)
;
i
+
+
)
{
ClearInvalidations
(
aLayer
-
>
GetAncestorMaskLayerAt
(
i
)
)
;
}
ContainerLayer
*
container
=
aLayer
-
>
AsContainerLayer
(
)
;
if
(
!
container
)
{
return
;
}
for
(
Layer
*
child
=
container
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
ClearInvalidations
(
child
)
;
}
}
nsIntRegion
LayerPropertiesBase
:
:
ComputeDifferences
(
Layer
*
aRoot
NotifySubDocInvalidationFunc
aCallback
bool
*
aGeometryChanged
=
nullptr
)
{
NS_ASSERTION
(
aRoot
"
Must
have
a
layer
tree
to
compare
against
!
"
)
;
if
(
mLayer
!
=
aRoot
)
{
if
(
aCallback
)
{
NotifySubdocumentInvalidationRecursive
(
aRoot
aCallback
)
;
}
else
{
ClearInvalidations
(
aRoot
)
;
}
IntRect
result
=
TransformRect
(
aRoot
-
>
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
.
GetBounds
(
)
aRoot
-
>
GetLocalTransform
(
)
)
;
result
=
result
.
Union
(
OldTransformedBounds
(
)
)
;
if
(
aGeometryChanged
!
=
nullptr
)
{
*
aGeometryChanged
=
true
;
}
return
result
;
}
else
{
bool
geometryChanged
=
(
aGeometryChanged
!
=
nullptr
)
?
*
aGeometryChanged
:
false
;
nsIntRegion
invalid
=
ComputeChange
(
"
"
aCallback
geometryChanged
)
;
if
(
aGeometryChanged
!
=
nullptr
)
{
*
aGeometryChanged
=
geometryChanged
;
}
LTI_LOG
(
"
ComputeDifferences
returned
%
s
\
n
"
Stringify
(
invalid
)
.
c_str
(
)
)
;
return
invalid
;
}
}
void
LayerPropertiesBase
:
:
MoveBy
(
const
IntPoint
&
aOffset
)
{
mTransform
.
PostTranslate
(
aOffset
.
x
aOffset
.
y
0
)
;
}
}
}
