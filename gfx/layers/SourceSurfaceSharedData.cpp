#
include
"
SourceSurfaceSharedData
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
SharedSurfacesChild
.
h
"
#
include
"
base
/
process_util
.
h
"
#
ifdef
DEBUG
#
define
SHARED_SURFACE_PROTECT_FINALIZED
#
endif
namespace
mozilla
{
namespace
gfx
{
bool
SourceSurfaceSharedDataWrapper
:
:
Init
(
const
IntSize
&
aSize
int32_t
aStride
SurfaceFormat
aFormat
const
SharedMemoryBasic
:
:
Handle
&
aHandle
base
:
:
ProcessId
aCreatorPid
)
{
MOZ_ASSERT
(
!
mBuf
)
;
mSize
=
aSize
;
mStride
=
aStride
;
mFormat
=
aFormat
;
mCreatorPid
=
aCreatorPid
;
size_t
len
=
GetAlignedDataLength
(
)
;
mBuf
=
MakeAndAddRef
<
SharedMemoryBasic
>
(
)
;
if
(
NS_WARN_IF
(
!
mBuf
-
>
SetHandle
(
aHandle
ipc
:
:
SharedMemory
:
:
RightsReadOnly
)
)
|
|
NS_WARN_IF
(
!
mBuf
-
>
Map
(
len
)
)
)
{
mBuf
=
nullptr
;
return
false
;
}
mBuf
-
>
CloseHandle
(
)
;
return
true
;
}
void
SourceSurfaceSharedDataWrapper
:
:
Init
(
SourceSurfaceSharedData
*
aSurface
)
{
MOZ_ASSERT
(
!
mBuf
)
;
MOZ_ASSERT
(
aSurface
)
;
mSize
=
aSurface
-
>
mSize
;
mStride
=
aSurface
-
>
mStride
;
mFormat
=
aSurface
-
>
mFormat
;
mCreatorPid
=
base
:
:
GetCurrentProcId
(
)
;
mBuf
=
aSurface
-
>
mBuf
;
}
bool
SourceSurfaceSharedData
:
:
Init
(
const
IntSize
&
aSize
int32_t
aStride
SurfaceFormat
aFormat
bool
aShare
)
{
mSize
=
aSize
;
mStride
=
aStride
;
mFormat
=
aFormat
;
size_t
len
=
GetAlignedDataLength
(
)
;
mBuf
=
new
SharedMemoryBasic
(
)
;
if
(
NS_WARN_IF
(
!
mBuf
-
>
Create
(
len
)
)
|
|
NS_WARN_IF
(
!
mBuf
-
>
Map
(
len
)
)
)
{
mBuf
=
nullptr
;
return
false
;
}
if
(
aShare
)
{
layers
:
:
SharedSurfacesChild
:
:
Share
(
this
)
;
}
return
true
;
}
void
SourceSurfaceSharedData
:
:
GuaranteePersistance
(
)
{
}
void
SourceSurfaceSharedData
:
:
AddSizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
size_t
&
aHeapSizeOut
size_t
&
aNonHeapSizeOut
size_t
&
aExtHandlesOut
)
const
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mBuf
)
{
aNonHeapSizeOut
+
=
GetAlignedDataLength
(
)
;
}
if
(
!
mClosed
)
{
+
+
aExtHandlesOut
;
}
}
uint8_t
*
SourceSurfaceSharedData
:
:
GetDataInternal
(
)
const
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
MOZ_UNLIKELY
(
mOldBuf
)
)
{
MOZ_ASSERT
(
mMapCount
>
0
)
;
MOZ_ASSERT
(
mFinalized
)
;
return
static_cast
<
uint8_t
*
>
(
mOldBuf
-
>
memory
(
)
)
;
}
return
static_cast
<
uint8_t
*
>
(
mBuf
-
>
memory
(
)
)
;
}
nsresult
SourceSurfaceSharedData
:
:
ShareToProcess
(
base
:
:
ProcessId
aPid
SharedMemoryBasic
:
:
Handle
&
aHandle
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mHandleCount
>
0
)
;
if
(
mClosed
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
bool
shared
=
mBuf
-
>
ShareToProcess
(
aPid
&
aHandle
)
;
if
(
MOZ_UNLIKELY
(
!
shared
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
void
SourceSurfaceSharedData
:
:
CloseHandleInternal
(
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
mClosed
)
{
MOZ_ASSERT
(
mHandleCount
=
=
0
)
;
MOZ_ASSERT
(
mShared
)
;
return
;
}
if
(
mShared
)
{
mBuf
-
>
CloseHandle
(
)
;
mClosed
=
true
;
}
}
bool
SourceSurfaceSharedData
:
:
ReallocHandle
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mHandleCount
>
0
)
;
MOZ_ASSERT
(
mClosed
)
;
if
(
NS_WARN_IF
(
!
mFinalized
)
)
{
return
false
;
}
size_t
len
=
GetAlignedDataLength
(
)
;
RefPtr
<
SharedMemoryBasic
>
buf
=
new
SharedMemoryBasic
(
)
;
if
(
NS_WARN_IF
(
!
buf
-
>
Create
(
len
)
)
|
|
NS_WARN_IF
(
!
buf
-
>
Map
(
len
)
)
)
{
return
false
;
}
size_t
copyLen
=
GetDataLength
(
)
;
memcpy
(
buf
-
>
memory
(
)
mBuf
-
>
memory
(
)
copyLen
)
;
#
ifdef
SHARED_SURFACE_PROTECT_FINALIZED
buf
-
>
Protect
(
static_cast
<
char
*
>
(
buf
-
>
memory
(
)
)
len
RightsRead
)
;
#
endif
if
(
mMapCount
>
0
&
&
!
mOldBuf
)
{
mOldBuf
=
std
:
:
move
(
mBuf
)
;
}
mBuf
=
std
:
:
move
(
buf
)
;
mClosed
=
false
;
mShared
=
false
;
return
true
;
}
void
SourceSurfaceSharedData
:
:
Finalize
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
!
mFinalized
)
;
#
ifdef
SHARED_SURFACE_PROTECT_FINALIZED
size_t
len
=
GetAlignedDataLength
(
)
;
mBuf
-
>
Protect
(
static_cast
<
char
*
>
(
mBuf
-
>
memory
(
)
)
len
RightsRead
)
;
#
endif
mFinalized
=
true
;
}
}
}
