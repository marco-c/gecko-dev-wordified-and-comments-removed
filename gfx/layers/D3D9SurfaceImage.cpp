#
include
"
D3D9SurfaceImage
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
mozilla
/
layers
/
TextureD3D9
.
h
"
#
include
"
mozilla
/
layers
/
CompositableClient
.
h
"
#
include
"
mozilla
/
layers
/
CompositableForwarder
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeChild
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
namespace
mozilla
{
namespace
layers
{
D3D9SurfaceImage
:
:
D3D9SurfaceImage
(
)
:
Image
(
nullptr
ImageFormat
:
:
D3D9_RGB32_TEXTURE
)
mSize
(
0
0
)
mValid
(
false
)
mIsFirstFrame
(
false
)
{
}
D3D9SurfaceImage
:
:
~
D3D9SurfaceImage
(
)
{
}
HRESULT
D3D9SurfaceImage
:
:
SetData
(
const
Data
&
aData
)
{
NS_ENSURE_TRUE
(
aData
.
mSurface
E_POINTER
)
;
HRESULT
hr
;
nsRefPtr
<
IDirect3DSurface9
>
surface
=
aData
.
mSurface
;
nsRefPtr
<
IDirect3DDevice9
>
device
;
hr
=
surface
-
>
GetDevice
(
getter_AddRefs
(
device
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
E_FAIL
)
;
nsRefPtr
<
IDirect3D9
>
d3d9
;
hr
=
device
-
>
GetDirect3D
(
getter_AddRefs
(
d3d9
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
E_FAIL
)
;
D3DSURFACE_DESC
desc
;
surface
-
>
GetDesc
(
&
desc
)
;
hr
=
d3d9
-
>
CheckDeviceFormatConversion
(
D3DADAPTER_DEFAULT
D3DDEVTYPE_HAL
desc
.
Format
D3DFMT_X8R8G8B8
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
const
gfx
:
:
IntRect
&
region
=
aData
.
mRegion
;
nsRefPtr
<
SharedTextureClientD3D9
>
textureClient
=
aData
.
mAllocator
-
>
CreateOrRecycleClient
(
gfx
:
:
SurfaceFormat
:
:
B8G8R8X8
region
.
Size
(
)
)
;
if
(
!
textureClient
)
{
return
E_FAIL
;
}
nsRefPtr
<
IDirect3DSurface9
>
textureSurface
=
textureClient
-
>
GetD3D9Surface
(
)
;
if
(
!
textureSurface
)
{
return
E_FAIL
;
}
RECT
src
=
{
region
.
x
region
.
y
region
.
x
+
region
.
width
region
.
y
+
region
.
height
}
;
hr
=
device
-
>
StretchRect
(
surface
&
src
textureSurface
nullptr
D3DTEXF_NONE
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
nsRefPtr
<
IDirect3DQuery9
>
query
;
hr
=
device
-
>
CreateQuery
(
D3DQUERYTYPE_EVENT
getter_AddRefs
(
query
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
hr
=
query
-
>
Issue
(
D3DISSUE_END
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
mTextureClient
=
textureClient
;
mSize
=
region
.
Size
(
)
;
mQuery
=
query
;
mIsFirstFrame
=
aData
.
mIsFirstFrame
;
return
S_OK
;
}
bool
D3D9SurfaceImage
:
:
IsValid
(
)
{
EnsureSynchronized
(
)
;
return
mValid
;
}
void
D3D9SurfaceImage
:
:
EnsureSynchronized
(
)
{
nsRefPtr
<
IDirect3DQuery9
>
query
=
mQuery
;
if
(
!
query
)
{
return
;
}
int
iterations
=
0
;
while
(
iterations
<
(
mIsFirstFrame
?
100
:
10
)
)
{
HRESULT
hr
=
query
-
>
GetData
(
nullptr
0
D3DGETDATA_FLUSH
)
;
if
(
hr
=
=
S_FALSE
)
{
Sleep
(
1
)
;
iterations
+
+
;
continue
;
}
if
(
hr
=
=
S_OK
)
{
mValid
=
true
;
}
break
;
}
mQuery
=
nullptr
;
}
const
D3DSURFACE_DESC
&
D3D9SurfaceImage
:
:
GetDesc
(
)
const
{
return
mTextureClient
-
>
GetDesc
(
)
;
}
gfx
:
:
IntSize
D3D9SurfaceImage
:
:
GetSize
(
)
{
return
mSize
;
}
TextureClient
*
D3D9SurfaceImage
:
:
GetTextureClient
(
CompositableClient
*
aClient
)
{
MOZ_ASSERT
(
mTextureClient
)
;
MOZ_ASSERT
(
mTextureClient
-
>
GetAllocator
(
)
=
=
aClient
-
>
GetForwarder
(
)
)
;
EnsureSynchronized
(
)
;
return
mTextureClient
;
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
D3D9SurfaceImage
:
:
GetAsSourceSurface
(
)
{
NS_ENSURE_TRUE
(
mTextureClient
nullptr
)
;
HRESULT
hr
;
nsRefPtr
<
gfx
:
:
DataSourceSurface
>
surface
=
gfx
:
:
Factory
:
:
CreateDataSourceSurface
(
mSize
gfx
:
:
SurfaceFormat
:
:
B8G8R8X8
)
;
if
(
NS_WARN_IF
(
!
surface
)
)
{
return
nullptr
;
}
EnsureSynchronized
(
)
;
nsRefPtr
<
IDirect3DSurface9
>
textureSurface
=
mTextureClient
-
>
GetD3D9Surface
(
)
;
if
(
!
textureSurface
)
{
return
nullptr
;
}
nsRefPtr
<
IDirect3DDevice9
>
device
=
mTextureClient
-
>
GetD3D9Device
(
)
;
if
(
!
device
)
{
return
nullptr
;
}
nsRefPtr
<
IDirect3DSurface9
>
systemMemorySurface
;
hr
=
device
-
>
CreateOffscreenPlainSurface
(
mSize
.
width
mSize
.
height
D3DFMT_X8R8G8B8
D3DPOOL_SYSTEMMEM
getter_AddRefs
(
systemMemorySurface
)
0
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
hr
=
device
-
>
GetRenderTargetData
(
textureSurface
systemMemorySurface
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
D3DLOCKED_RECT
rect
;
hr
=
systemMemorySurface
-
>
LockRect
(
&
rect
nullptr
0
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
gfx
:
:
DataSourceSurface
:
:
MappedSurface
mappedSurface
;
if
(
!
surface
-
>
Map
(
gfx
:
:
DataSourceSurface
:
:
WRITE
&
mappedSurface
)
)
{
systemMemorySurface
-
>
UnlockRect
(
)
;
return
nullptr
;
}
const
unsigned
char
*
src
=
(
const
unsigned
char
*
)
(
rect
.
pBits
)
;
const
unsigned
srcPitch
=
rect
.
Pitch
;
for
(
int
y
=
0
;
y
<
mSize
.
height
;
y
+
+
)
{
memcpy
(
mappedSurface
.
mData
+
mappedSurface
.
mStride
*
y
(
unsigned
char
*
)
(
src
)
+
srcPitch
*
y
mSize
.
width
*
4
)
;
}
systemMemorySurface
-
>
UnlockRect
(
)
;
surface
-
>
Unmap
(
)
;
return
surface
.
forget
(
)
;
}
already_AddRefed
<
TextureClient
>
D3D9RecycleAllocator
:
:
Allocate
(
gfx
:
:
SurfaceFormat
aFormat
gfx
:
:
IntSize
aSize
BackendSelector
aSelector
TextureFlags
aTextureFlags
TextureAllocationFlags
aAllocFlags
)
{
return
SharedTextureClientD3D9
:
:
Create
(
mSurfaceAllocator
aFormat
aTextureFlags
mDevice
aSize
)
;
}
already_AddRefed
<
SharedTextureClientD3D9
>
D3D9RecycleAllocator
:
:
CreateOrRecycleClient
(
gfx
:
:
SurfaceFormat
aFormat
const
gfx
:
:
IntSize
&
aSize
)
{
nsRefPtr
<
TextureClient
>
textureClient
=
CreateOrRecycle
(
aFormat
aSize
BackendSelector
:
:
Content
layers
:
:
TextureFlags
:
:
DEFAULT
)
;
if
(
!
textureClient
)
{
return
nullptr
;
}
nsRefPtr
<
SharedTextureClientD3D9
>
textureD3D9
=
static_cast
<
SharedTextureClientD3D9
*
>
(
textureClient
.
get
(
)
)
;
return
textureD3D9
.
forget
(
)
;
}
}
}
