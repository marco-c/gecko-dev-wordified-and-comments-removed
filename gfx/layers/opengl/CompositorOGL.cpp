#
include
"
CompositorOGL
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
stdlib
.
h
>
#
include
"
GLContextProvider
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
GLUploadHelpers
.
h
"
#
include
"
Layers
.
h
"
#
include
"
LayerScope
.
h
"
#
include
"
gfxCrashReporterUtils
.
h
"
#
include
"
gfxEnv
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
gfxRect
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
gfx
/
BasePoint
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
mozilla
/
gfx
/
Triangle
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
layers
/
LayerManagerComposite
.
h
"
#
include
"
mozilla
/
layers
/
CompositingRenderTargetOGL
.
h
"
#
include
"
mozilla
/
layers
/
Effects
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
mozilla
/
layers
/
TextureHostOGL
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAppRunner
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsMathUtils
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
ScopedGLHelpers
.
h
"
#
include
"
GLReadTexImageHelper
.
h
"
#
include
"
GLBlitTextureImageHelper
.
h
"
#
include
"
HeapCopyOfStackArray
.
h
"
#
if
MOZ_WIDGET_ANDROID
#
include
"
TexturePoolOGL
.
h
"
#
endif
#
include
"
GeckoProfiler
.
h
"
namespace
mozilla
{
using
namespace
std
;
using
namespace
gfx
;
namespace
layers
{
using
namespace
mozilla
:
:
gl
;
static
const
GLuint
kCoordinateAttributeIndex
=
0
;
static
const
GLuint
kTexCoordinateAttributeIndex
=
1
;
static
void
BindMaskForProgram
(
ShaderProgramOGL
*
aProgram
TextureSourceOGL
*
aSourceMask
GLenum
aTexUnit
const
gfx
:
:
Matrix4x4
&
aTransform
)
{
MOZ_ASSERT
(
LOCAL_GL_TEXTURE0
<
=
aTexUnit
&
&
aTexUnit
<
=
LOCAL_GL_TEXTURE31
)
;
aSourceMask
-
>
BindTexture
(
aTexUnit
gfx
:
:
SamplingFilter
:
:
LINEAR
)
;
aProgram
-
>
SetMaskTextureUnit
(
aTexUnit
-
LOCAL_GL_TEXTURE0
)
;
aProgram
-
>
SetMaskLayerTransform
(
aTransform
)
;
}
void
CompositorOGL
:
:
BindBackdrop
(
ShaderProgramOGL
*
aProgram
GLuint
aBackdrop
GLenum
aTexUnit
)
{
MOZ_ASSERT
(
aBackdrop
)
;
mGLContext
-
>
fActiveTexture
(
aTexUnit
)
;
mGLContext
-
>
fBindTexture
(
LOCAL_GL_TEXTURE_2D
aBackdrop
)
;
mGLContext
-
>
fTexParameteri
(
LOCAL_GL_TEXTURE_2D
LOCAL_GL_TEXTURE_MIN_FILTER
LOCAL_GL_LINEAR
)
;
mGLContext
-
>
fTexParameteri
(
LOCAL_GL_TEXTURE_2D
LOCAL_GL_TEXTURE_MAG_FILTER
LOCAL_GL_LINEAR
)
;
aProgram
-
>
SetBackdropTextureUnit
(
aTexUnit
-
LOCAL_GL_TEXTURE0
)
;
}
CompositorOGL
:
:
CompositorOGL
(
CompositorBridgeParent
*
aParent
widget
:
:
CompositorWidget
*
aWidget
int
aSurfaceWidth
int
aSurfaceHeight
bool
aUseExternalSurfaceSize
)
:
Compositor
(
aWidget
aParent
)
mWidgetSize
(
-
1
-
1
)
mSurfaceSize
(
aSurfaceWidth
aSurfaceHeight
)
mHasBGRA
(
0
)
mUseExternalSurfaceSize
(
aUseExternalSurfaceSize
)
mFrameInProgress
(
false
)
mDestroyed
(
false
)
mViewportSize
(
0
0
)
mCurrentProgram
(
nullptr
)
{
MOZ_COUNT_CTOR
(
CompositorOGL
)
;
}
CompositorOGL
:
:
~
CompositorOGL
(
)
{
MOZ_COUNT_DTOR
(
CompositorOGL
)
;
Destroy
(
)
;
}
already_AddRefed
<
mozilla
:
:
gl
:
:
GLContext
>
CompositorOGL
:
:
CreateContext
(
)
{
RefPtr
<
GLContext
>
context
;
nsIWidget
*
widget
=
mWidget
-
>
RealWidget
(
)
;
void
*
widgetOpenGLContext
=
widget
?
widget
-
>
GetNativeData
(
NS_NATIVE_OPENGL_CONTEXT
)
:
nullptr
;
if
(
widgetOpenGLContext
)
{
GLContext
*
alreadyRefed
=
reinterpret_cast
<
GLContext
*
>
(
widgetOpenGLContext
)
;
return
already_AddRefed
<
GLContext
>
(
alreadyRefed
)
;
}
#
ifdef
XP_WIN
if
(
gfxEnv
:
:
LayersPreferEGL
(
)
)
{
printf_stderr
(
"
Trying
GL
layers
.
.
.
\
n
"
)
;
context
=
gl
:
:
GLContextProviderEGL
:
:
CreateForCompositorWidget
(
mWidget
false
)
;
}
#
endif
if
(
!
context
&
&
gfxEnv
:
:
LayersPreferOffscreen
(
)
)
{
SurfaceCaps
caps
=
SurfaceCaps
:
:
ForRGB
(
)
;
caps
.
preserve
=
false
;
caps
.
bpp16
=
gfxVars
:
:
OffscreenFormat
(
)
=
=
SurfaceFormat
:
:
R5G6B5_UINT16
;
nsCString
discardFailureId
;
context
=
GLContextProvider
:
:
CreateOffscreen
(
mSurfaceSize
caps
CreateContextFlags
:
:
REQUIRE_COMPAT_PROFILE
&
discardFailureId
)
;
}
if
(
!
context
)
{
context
=
gl
:
:
GLContextProvider
:
:
CreateForCompositorWidget
(
mWidget
gfxVars
:
:
RequiresAcceleratedGLContextForCompositorOGL
(
)
)
;
}
if
(
!
context
)
{
NS_WARNING
(
"
Failed
to
create
CompositorOGL
context
"
)
;
}
return
context
.
forget
(
)
;
}
void
CompositorOGL
:
:
Destroy
(
)
{
Compositor
:
:
Destroy
(
)
;
if
(
mTexturePool
)
{
mTexturePool
-
>
Clear
(
)
;
mTexturePool
=
nullptr
;
}
if
(
!
mDestroyed
)
{
mDestroyed
=
true
;
CleanupResources
(
)
;
}
}
void
CompositorOGL
:
:
CleanupResources
(
)
{
if
(
!
mGLContext
)
return
;
RefPtr
<
GLContext
>
ctx
=
mGLContext
-
>
GetSharedContext
(
)
;
if
(
!
ctx
)
{
ctx
=
mGLContext
;
}
if
(
!
ctx
-
>
MakeCurrent
(
)
)
{
mQuadVBO
=
0
;
mTriangleVBO
=
0
;
mGLContext
=
nullptr
;
mPrograms
.
clear
(
)
;
return
;
}
for
(
std
:
:
map
<
ShaderConfigOGL
ShaderProgramOGL
*
>
:
:
iterator
iter
=
mPrograms
.
begin
(
)
;
iter
!
=
mPrograms
.
end
(
)
;
iter
+
+
)
{
delete
iter
-
>
second
;
}
mPrograms
.
clear
(
)
;
ctx
-
>
fBindFramebuffer
(
LOCAL_GL_FRAMEBUFFER
0
)
;
if
(
mQuadVBO
)
{
ctx
-
>
fDeleteBuffers
(
1
&
mQuadVBO
)
;
mQuadVBO
=
0
;
}
if
(
mTriangleVBO
)
{
ctx
-
>
fDeleteBuffers
(
1
&
mTriangleVBO
)
;
mTriangleVBO
=
0
;
}
mGLContext
-
>
MakeCurrent
(
)
;
mBlitTextureImageHelper
=
nullptr
;
mContextStateTracker
.
DestroyOGL
(
mGLContext
)
;
mGLContext
-
>
MarkDestroyed
(
)
;
mGLContext
=
nullptr
;
}
bool
CompositorOGL
:
:
Initialize
(
nsCString
*
const
out_failureReason
)
{
ScopedGfxFeatureReporter
reporter
(
"
GL
Layers
"
)
;
MOZ_ASSERT
(
mGLContext
=
=
nullptr
"
Don
'
t
reinitialize
CompositorOGL
"
)
;
mGLContext
=
CreateContext
(
)
;
#
ifdef
MOZ_WIDGET_ANDROID
if
(
!
mGLContext
)
{
*
out_failureReason
=
"
FEATURE_FAILURE_OPENGL_NO_ANDROID_CONTEXT
"
;
MOZ_CRASH
(
"
We
need
a
context
on
Android
"
)
;
}
#
endif
if
(
!
mGLContext
)
{
*
out_failureReason
=
"
FEATURE_FAILURE_OPENGL_CREATE_CONTEXT
"
;
return
false
;
}
MakeCurrent
(
)
;
mHasBGRA
=
mGLContext
-
>
IsExtensionSupported
(
gl
:
:
GLContext
:
:
EXT_texture_format_BGRA8888
)
|
|
mGLContext
-
>
IsExtensionSupported
(
gl
:
:
GLContext
:
:
EXT_bgra
)
;
mGLContext
-
>
fBlendFuncSeparate
(
LOCAL_GL_ONE
LOCAL_GL_ONE_MINUS_SRC_ALPHA
LOCAL_GL_ONE
LOCAL_GL_ONE_MINUS_SRC_ALPHA
)
;
mGLContext
-
>
fEnable
(
LOCAL_GL_BLEND
)
;
RefPtr
<
EffectSolidColor
>
effect
=
new
EffectSolidColor
(
Color
(
0
0
0
0
)
)
;
ShaderConfigOGL
config
=
GetShaderConfigFor
(
effect
)
;
if
(
!
GetShaderProgramFor
(
config
)
)
{
*
out_failureReason
=
"
FEATURE_FAILURE_OPENGL_COMPILE_SHADER
"
;
return
false
;
}
if
(
mGLContext
-
>
WorkAroundDriverBugs
(
)
)
{
GLenum
textureTargets
[
]
=
{
LOCAL_GL_TEXTURE_2D
LOCAL_GL_NONE
}
;
if
(
!
mGLContext
-
>
IsGLES
(
)
)
{
textureTargets
[
1
]
=
LOCAL_GL_TEXTURE_RECTANGLE_ARB
;
}
mFBOTextureTarget
=
LOCAL_GL_NONE
;
GLuint
testFBO
=
0
;
mGLContext
-
>
fGenFramebuffers
(
1
&
testFBO
)
;
GLuint
testTexture
=
0
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
textureTargets
)
;
i
+
+
)
{
GLenum
target
=
textureTargets
[
i
]
;
if
(
!
target
)
continue
;
mGLContext
-
>
fGenTextures
(
1
&
testTexture
)
;
mGLContext
-
>
fBindTexture
(
target
testTexture
)
;
mGLContext
-
>
fTexParameteri
(
target
LOCAL_GL_TEXTURE_MIN_FILTER
LOCAL_GL_NEAREST
)
;
mGLContext
-
>
fTexParameteri
(
target
LOCAL_GL_TEXTURE_MAG_FILTER
LOCAL_GL_NEAREST
)
;
mGLContext
-
>
fTexImage2D
(
target
0
LOCAL_GL_RGBA
5
3
0
LOCAL_GL_RGBA
LOCAL_GL_UNSIGNED_BYTE
nullptr
)
;
mGLContext
-
>
fBindTexture
(
target
0
)
;
mGLContext
-
>
fBindFramebuffer
(
LOCAL_GL_FRAMEBUFFER
testFBO
)
;
mGLContext
-
>
fFramebufferTexture2D
(
LOCAL_GL_FRAMEBUFFER
LOCAL_GL_COLOR_ATTACHMENT0
target
testTexture
0
)
;
if
(
mGLContext
-
>
fCheckFramebufferStatus
(
LOCAL_GL_FRAMEBUFFER
)
=
=
LOCAL_GL_FRAMEBUFFER_COMPLETE
)
{
mFBOTextureTarget
=
target
;
mGLContext
-
>
fDeleteTextures
(
1
&
testTexture
)
;
break
;
}
mGLContext
-
>
fDeleteTextures
(
1
&
testTexture
)
;
}
if
(
testFBO
)
{
mGLContext
-
>
fDeleteFramebuffers
(
1
&
testFBO
)
;
}
if
(
mFBOTextureTarget
=
=
LOCAL_GL_NONE
)
{
*
out_failureReason
=
"
FEATURE_FAILURE_OPENGL_NO_TEXTURE_TARGET
"
;
return
false
;
}
}
else
{
mFBOTextureTarget
=
LOCAL_GL_TEXTURE_2D
;
}
mGLContext
-
>
fBindFramebuffer
(
LOCAL_GL_FRAMEBUFFER
0
)
;
if
(
mFBOTextureTarget
=
=
LOCAL_GL_TEXTURE_RECTANGLE_ARB
)
{
if
(
!
mGLContext
-
>
IsExtensionSupported
(
gl
:
:
GLContext
:
:
ARB_texture_rectangle
)
)
{
*
out_failureReason
=
"
FEATURE_FAILURE_OPENGL_ARB_EXT
"
;
return
false
;
}
}
mGLContext
-
>
fGenBuffers
(
1
&
mTriangleVBO
)
;
mGLContext
-
>
fGenBuffers
(
1
&
mQuadVBO
)
;
GLfloat
vertices
[
]
=
{
0
.
0f
0
.
0f
0
.
0f
0
.
0f
1
.
0f
0
.
0f
0
.
0f
0
.
0f
0
.
0f
1
.
0f
0
.
0f
0
.
0f
1
.
0f
0
.
0f
0
.
0f
0
.
0f
0
.
0f
1
.
0f
0
.
0f
0
.
0f
1
.
0f
1
.
0f
0
.
0f
0
.
0f
0
.
0f
0
.
0f
0
.
0f
1
.
0f
1
.
0f
0
.
0f
0
.
0f
1
.
0f
0
.
0f
1
.
0f
0
.
0f
1
.
0f
1
.
0f
0
.
0f
0
.
0f
1
.
0f
0
.
0f
1
.
0f
0
.
0f
1
.
0f
1
.
0f
1
.
0f
0
.
0f
1
.
0f
0
.
0f
0
.
0f
0
.
0f
2
.
0f
1
.
0f
0
.
0f
0
.
0f
2
.
0f
0
.
0f
1
.
0f
0
.
0f
2
.
0f
1
.
0f
0
.
0f
0
.
0f
2
.
0f
0
.
0f
1
.
0f
0
.
0f
2
.
0f
1
.
0f
1
.
0f
0
.
0f
2
.
0f
0
.
0f
0
.
0f
0
.
0f
3
.
0f
1
.
0f
0
.
0f
0
.
0f
3
.
0f
0
.
0f
1
.
0f
0
.
0f
3
.
0f
1
.
0f
0
.
0f
0
.
0f
3
.
0f
0
.
0f
1
.
0f
0
.
0f
3
.
0f
1
.
0f
1
.
0f
0
.
0f
3
.
0f
}
;
HeapCopyOfStackArray
<
GLfloat
>
verticesOnHeap
(
vertices
)
;
mGLContext
-
>
fBindBuffer
(
LOCAL_GL_ARRAY_BUFFER
mQuadVBO
)
;
mGLContext
-
>
fBufferData
(
LOCAL_GL_ARRAY_BUFFER
verticesOnHeap
.
ByteLength
(
)
verticesOnHeap
.
Data
(
)
LOCAL_GL_STATIC_DRAW
)
;
mGLContext
-
>
fBindBuffer
(
LOCAL_GL_ARRAY_BUFFER
0
)
;
nsCOMPtr
<
nsIConsoleService
>
console
(
do_GetService
(
NS_CONSOLESERVICE_CONTRACTID
)
)
;
if
(
console
)
{
nsString
msg
;
msg
+
=
NS_LITERAL_STRING
(
"
OpenGL
compositor
Initialized
Succesfully
.
\
nVersion
:
"
)
;
msg
+
=
NS_ConvertUTF8toUTF16
(
nsDependentCString
(
(
const
char
*
)
mGLContext
-
>
fGetString
(
LOCAL_GL_VERSION
)
)
)
;
msg
+
=
NS_LITERAL_STRING
(
"
\
nVendor
:
"
)
;
msg
+
=
NS_ConvertUTF8toUTF16
(
nsDependentCString
(
(
const
char
*
)
mGLContext
-
>
fGetString
(
LOCAL_GL_VENDOR
)
)
)
;
msg
+
=
NS_LITERAL_STRING
(
"
\
nRenderer
:
"
)
;
msg
+
=
NS_ConvertUTF8toUTF16
(
nsDependentCString
(
(
const
char
*
)
mGLContext
-
>
fGetString
(
LOCAL_GL_RENDERER
)
)
)
;
msg
+
=
NS_LITERAL_STRING
(
"
\
nFBO
Texture
Target
:
"
)
;
if
(
mFBOTextureTarget
=
=
LOCAL_GL_TEXTURE_2D
)
msg
+
=
NS_LITERAL_STRING
(
"
TEXTURE_2D
"
)
;
else
msg
+
=
NS_LITERAL_STRING
(
"
TEXTURE_RECTANGLE
"
)
;
console
-
>
LogStringMessage
(
msg
.
get
(
)
)
;
}
reporter
.
SetSuccessful
(
)
;
return
true
;
}
static
IntSize
CalculatePOTSize
(
const
IntSize
&
aSize
GLContext
*
gl
)
{
if
(
CanUploadNonPowerOfTwo
(
gl
)
)
return
aSize
;
return
IntSize
(
RoundUpPow2
(
aSize
.
width
)
RoundUpPow2
(
aSize
.
height
)
)
;
}
gfx
:
:
Rect
CompositorOGL
:
:
GetTextureCoordinates
(
gfx
:
:
Rect
textureRect
TextureSource
*
aTexture
)
{
if
(
!
CanUploadNonPowerOfTwo
(
mGLContext
)
)
{
const
IntSize
&
textureSize
=
aTexture
-
>
GetSize
(
)
;
const
IntSize
potSize
=
CalculatePOTSize
(
textureSize
mGLContext
)
;
if
(
potSize
!
=
textureSize
)
{
const
float
xScale
=
(
float
)
textureSize
.
width
/
(
float
)
potSize
.
width
;
const
float
yScale
=
(
float
)
textureSize
.
height
/
(
float
)
potSize
.
height
;
textureRect
.
Scale
(
xScale
yScale
)
;
}
}
return
textureRect
;
}
void
CompositorOGL
:
:
PrepareViewport
(
CompositingRenderTargetOGL
*
aRenderTarget
)
{
MOZ_ASSERT
(
aRenderTarget
)
;
const
gfx
:
:
IntSize
&
size
=
aRenderTarget
-
>
mInitParams
.
mSize
;
const
gfx
:
:
IntSize
&
phySize
=
aRenderTarget
-
>
mInitParams
.
mPhySize
;
mGLContext
-
>
fViewport
(
0
0
phySize
.
width
phySize
.
height
)
;
mViewportSize
=
size
;
if
(
!
aRenderTarget
-
>
HasComplexProjection
(
)
)
{
Matrix
viewMatrix
;
if
(
mGLContext
-
>
IsOffscreen
(
)
&
&
!
gIsGtest
)
{
viewMatrix
.
PreTranslate
(
-
1
.
0
-
1
.
0
)
;
viewMatrix
.
PreScale
(
2
.
0f
/
float
(
size
.
width
)
2
.
0f
/
float
(
size
.
height
)
)
;
}
else
{
viewMatrix
.
PreTranslate
(
-
1
.
0
1
.
0
)
;
viewMatrix
.
PreScale
(
2
.
0f
/
float
(
size
.
width
)
2
.
0f
/
float
(
size
.
height
)
)
;
viewMatrix
.
PreScale
(
1
.
0f
-
1
.
0f
)
;
}
MOZ_ASSERT
(
mCurrentRenderTarget
"
No
destination
"
)
;
if
(
!
mTarget
&
&
mCurrentRenderTarget
-
>
IsWindow
(
)
)
{
viewMatrix
.
PreTranslate
(
mRenderOffset
.
x
mRenderOffset
.
y
)
;
}
Matrix4x4
matrix3d
=
Matrix4x4
:
:
From2D
(
viewMatrix
)
;
matrix3d
.
_33
=
0
.
0f
;
mProjMatrix
=
matrix3d
;
mGLContext
-
>
fDepthRange
(
0
.
0f
1
.
0f
)
;
}
else
{
bool
depthEnable
;
float
zNear
zFar
;
aRenderTarget
-
>
GetProjection
(
mProjMatrix
depthEnable
zNear
zFar
)
;
mGLContext
-
>
fDepthRange
(
zNear
zFar
)
;
}
}
already_AddRefed
<
CompositingRenderTarget
>
CompositorOGL
:
:
CreateRenderTarget
(
const
IntRect
&
aRect
SurfaceInitMode
aInit
)
{
MOZ_ASSERT
(
aRect
.
Width
(
)
!
=
0
&
&
aRect
.
Height
(
)
!
=
0
"
Trying
to
create
a
render
target
of
invalid
size
"
)
;
if
(
aRect
.
Width
(
)
*
aRect
.
Height
(
)
=
=
0
)
{
return
nullptr
;
}
if
(
!
gl
(
)
)
{
return
nullptr
;
}
GLuint
tex
=
0
;
GLuint
fbo
=
0
;
IntRect
rect
=
aRect
;
IntSize
FBOSize
;
CreateFBOWithTexture
(
rect
false
0
&
fbo
&
tex
&
FBOSize
)
;
RefPtr
<
CompositingRenderTargetOGL
>
surface
=
new
CompositingRenderTargetOGL
(
this
aRect
.
TopLeft
(
)
tex
fbo
)
;
surface
-
>
Initialize
(
aRect
.
Size
(
)
FBOSize
mFBOTextureTarget
aInit
)
;
return
surface
.
forget
(
)
;
}
already_AddRefed
<
CompositingRenderTarget
>
CompositorOGL
:
:
CreateRenderTargetFromSource
(
const
IntRect
&
aRect
const
CompositingRenderTarget
*
aSource
const
IntPoint
&
aSourcePoint
)
{
MOZ_ASSERT
(
aRect
.
Width
(
)
!
=
0
&
&
aRect
.
Height
(
)
!
=
0
"
Trying
to
create
a
render
target
of
invalid
size
"
)
;
if
(
aRect
.
Width
(
)
*
aRect
.
Height
(
)
=
=
0
)
{
return
nullptr
;
}
if
(
!
gl
(
)
)
{
return
nullptr
;
}
GLuint
tex
=
0
;
GLuint
fbo
=
0
;
const
CompositingRenderTargetOGL
*
sourceSurface
=
static_cast
<
const
CompositingRenderTargetOGL
*
>
(
aSource
)
;
IntRect
sourceRect
(
aSourcePoint
aRect
.
Size
(
)
)
;
if
(
aSource
)
{
CreateFBOWithTexture
(
sourceRect
true
sourceSurface
-
>
GetFBO
(
)
&
fbo
&
tex
)
;
}
else
{
CreateFBOWithTexture
(
sourceRect
true
0
&
fbo
&
tex
)
;
}
RefPtr
<
CompositingRenderTargetOGL
>
surface
=
new
CompositingRenderTargetOGL
(
this
aRect
.
TopLeft
(
)
tex
fbo
)
;
surface
-
>
Initialize
(
aRect
.
Size
(
)
sourceRect
.
Size
(
)
mFBOTextureTarget
INIT_MODE_NONE
)
;
return
surface
.
forget
(
)
;
}
void
CompositorOGL
:
:
SetRenderTarget
(
CompositingRenderTarget
*
aSurface
)
{
MOZ_ASSERT
(
aSurface
)
;
CompositingRenderTargetOGL
*
surface
=
static_cast
<
CompositingRenderTargetOGL
*
>
(
aSurface
)
;
if
(
mCurrentRenderTarget
!
=
surface
)
{
mCurrentRenderTarget
=
surface
;
if
(
mCurrentRenderTarget
)
{
mContextStateTracker
.
PopOGLSection
(
gl
(
)
"
Frame
"
)
;
}
mContextStateTracker
.
PushOGLSection
(
gl
(
)
"
Frame
"
)
;
surface
-
>
BindRenderTarget
(
)
;
}
PrepareViewport
(
mCurrentRenderTarget
)
;
}
CompositingRenderTarget
*
CompositorOGL
:
:
GetCurrentRenderTarget
(
)
const
{
return
mCurrentRenderTarget
;
}
static
GLenum
GetFrameBufferInternalFormat
(
GLContext
*
gl
GLuint
aFrameBuffer
mozilla
:
:
widget
:
:
CompositorWidget
*
aWidget
)
{
if
(
aFrameBuffer
=
=
0
)
{
return
aWidget
-
>
GetGLFrameBufferFormat
(
)
;
}
return
LOCAL_GL_RGBA
;
}
void
CompositorOGL
:
:
ClearRect
(
const
gfx
:
:
Rect
&
aRect
)
{
GLint
y
=
mViewportSize
.
height
-
(
aRect
.
y
+
aRect
.
Height
(
)
)
;
ScopedGLState
scopedScissorTestState
(
mGLContext
LOCAL_GL_SCISSOR_TEST
true
)
;
ScopedScissorRect
autoScissorRect
(
mGLContext
aRect
.
x
y
aRect
.
Width
(
)
aRect
.
Height
(
)
)
;
mGLContext
-
>
fClearColor
(
0
.
0
0
.
0
0
.
0
0
.
0
)
;
mGLContext
-
>
fClear
(
LOCAL_GL_COLOR_BUFFER_BIT
|
LOCAL_GL_DEPTH_BUFFER_BIT
)
;
}
void
CompositorOGL
:
:
BeginFrame
(
const
nsIntRegion
&
aInvalidRegion
const
IntRect
*
aClipRectIn
const
IntRect
&
aRenderBounds
const
nsIntRegion
&
aOpaqueRegion
IntRect
*
aClipRectOut
IntRect
*
aRenderBoundsOut
)
{
AUTO_PROFILER_LABEL
(
"
CompositorOGL
:
:
BeginFrame
"
GRAPHICS
)
;
MOZ_ASSERT
(
!
mFrameInProgress
"
frame
still
in
progress
(
should
have
called
EndFrame
"
)
;
gfx
:
:
IntRect
rect
;
if
(
mUseExternalSurfaceSize
)
{
rect
=
gfx
:
:
IntRect
(
0
0
mSurfaceSize
.
width
mSurfaceSize
.
height
)
;
}
else
{
rect
=
gfx
:
:
IntRect
(
aRenderBounds
.
x
aRenderBounds
.
y
aRenderBounds
.
Width
(
)
aRenderBounds
.
Height
(
)
)
;
}
if
(
aRenderBoundsOut
)
{
*
aRenderBoundsOut
=
rect
;
}
GLint
width
=
rect
.
Width
(
)
;
GLint
height
=
rect
.
Height
(
)
;
if
(
width
=
=
0
|
|
height
=
=
0
)
return
;
mFrameInProgress
=
true
;
if
(
mWidgetSize
.
width
!
=
width
|
|
mWidgetSize
.
height
!
=
height
)
{
MakeCurrent
(
ForceMakeCurrent
)
;
mWidgetSize
.
width
=
width
;
mWidgetSize
.
height
=
height
;
}
else
{
MakeCurrent
(
)
;
}
mPixelsPerFrame
=
width
*
height
;
mPixelsFilled
=
0
;
#
ifdef
MOZ_WIDGET_ANDROID
TexturePoolOGL
:
:
Fill
(
gl
(
)
)
;
#
endif
mGLContext
-
>
fBlendFuncSeparate
(
LOCAL_GL_ONE
LOCAL_GL_ONE_MINUS_SRC_ALPHA
LOCAL_GL_ONE
LOCAL_GL_ONE_MINUS_SRC_ALPHA
)
;
mGLContext
-
>
fEnable
(
LOCAL_GL_BLEND
)
;
RefPtr
<
CompositingRenderTargetOGL
>
rt
=
CompositingRenderTargetOGL
:
:
RenderTargetForWindow
(
this
IntSize
(
width
height
)
)
;
SetRenderTarget
(
rt
)
;
#
ifdef
DEBUG
mWindowRenderTarget
=
mCurrentRenderTarget
;
#
endif
if
(
aClipRectOut
&
&
!
aClipRectIn
)
{
aClipRectOut
-
>
SetRect
(
0
0
width
height
)
;
}
mGLContext
-
>
fClearColor
(
mClearColor
.
r
mClearColor
.
g
mClearColor
.
b
mClearColor
.
a
)
;
mGLContext
-
>
fClear
(
LOCAL_GL_COLOR_BUFFER_BIT
|
LOCAL_GL_DEPTH_BUFFER_BIT
)
;
}
void
CompositorOGL
:
:
CreateFBOWithTexture
(
const
gfx
:
:
IntRect
&
aRect
bool
aCopyFromSource
GLuint
aSourceFrameBuffer
GLuint
*
aFBO
GLuint
*
aTexture
gfx
:
:
IntSize
*
aAllocSize
)
{
*
aTexture
=
CreateTexture
(
aRect
aCopyFromSource
aSourceFrameBuffer
aAllocSize
)
;
mGLContext
-
>
fGenFramebuffers
(
1
aFBO
)
;
}
GLuint
CompositorOGL
:
:
CreateTexture
(
const
IntRect
&
aRect
bool
aCopyFromSource
GLuint
aSourceFrameBuffer
IntSize
*
aAllocSize
)
{
IntRect
clampedRect
=
aRect
;
int32_t
maxTexSize
=
GetMaxTextureSize
(
)
;
clampedRect
.
SetWidth
(
std
:
:
min
(
clampedRect
.
Width
(
)
maxTexSize
)
)
;
clampedRect
.
SetHeight
(
std
:
:
min
(
clampedRect
.
Height
(
)
maxTexSize
)
)
;
GLuint
tex
;
mGLContext
-
>
fActiveTexture
(
LOCAL_GL_TEXTURE0
)
;
mGLContext
-
>
fGenTextures
(
1
&
tex
)
;
mGLContext
-
>
fBindTexture
(
mFBOTextureTarget
tex
)
;
if
(
aCopyFromSource
)
{
GLuint
curFBO
=
mCurrentRenderTarget
-
>
GetFBO
(
)
;
if
(
curFBO
!
=
aSourceFrameBuffer
)
{
mGLContext
-
>
fBindFramebuffer
(
LOCAL_GL_FRAMEBUFFER
aSourceFrameBuffer
)
;
}
GLenum
format
=
GetFrameBufferInternalFormat
(
gl
(
)
aSourceFrameBuffer
mWidget
)
;
bool
isFormatCompatibleWithRGBA
=
gl
(
)
-
>
IsGLES
(
)
?
(
format
=
=
LOCAL_GL_RGBA
)
:
true
;
if
(
isFormatCompatibleWithRGBA
)
{
mGLContext
-
>
fCopyTexImage2D
(
mFBOTextureTarget
0
LOCAL_GL_RGBA
clampedRect
.
x
FlipY
(
clampedRect
.
y
+
clampedRect
.
Height
(
)
)
clampedRect
.
Width
(
)
clampedRect
.
Height
(
)
0
)
;
}
else
{
size_t
bufferSize
=
clampedRect
.
Width
(
)
*
clampedRect
.
Height
(
)
*
4
;
auto
buf
=
MakeUnique
<
uint8_t
[
]
>
(
bufferSize
)
;
mGLContext
-
>
fReadPixels
(
clampedRect
.
x
clampedRect
.
y
clampedRect
.
Width
(
)
clampedRect
.
Height
(
)
LOCAL_GL_RGBA
LOCAL_GL_UNSIGNED_BYTE
buf
.
get
(
)
)
;
mGLContext
-
>
fTexImage2D
(
mFBOTextureTarget
0
LOCAL_GL_RGBA
clampedRect
.
Width
(
)
clampedRect
.
Height
(
)
0
LOCAL_GL_RGBA
LOCAL_GL_UNSIGNED_BYTE
buf
.
get
(
)
)
;
}
GLenum
error
=
mGLContext
-
>
fGetError
(
)
;
if
(
error
!
=
LOCAL_GL_NO_ERROR
)
{
nsAutoCString
msg
;
msg
.
AppendPrintf
(
"
Texture
initialization
failed
!
-
-
error
0x
%
x
Source
%
d
Source
format
%
d
RGBA
Compat
%
d
"
error
aSourceFrameBuffer
format
isFormatCompatibleWithRGBA
)
;
NS_ERROR
(
msg
.
get
(
)
)
;
}
}
else
{
mGLContext
-
>
fTexImage2D
(
mFBOTextureTarget
0
LOCAL_GL_RGBA
clampedRect
.
Width
(
)
clampedRect
.
Height
(
)
0
LOCAL_GL_RGBA
LOCAL_GL_UNSIGNED_BYTE
nullptr
)
;
}
mGLContext
-
>
fTexParameteri
(
mFBOTextureTarget
LOCAL_GL_TEXTURE_MIN_FILTER
LOCAL_GL_LINEAR
)
;
mGLContext
-
>
fTexParameteri
(
mFBOTextureTarget
LOCAL_GL_TEXTURE_MAG_FILTER
LOCAL_GL_LINEAR
)
;
mGLContext
-
>
fTexParameteri
(
mFBOTextureTarget
LOCAL_GL_TEXTURE_WRAP_S
LOCAL_GL_CLAMP_TO_EDGE
)
;
mGLContext
-
>
fTexParameteri
(
mFBOTextureTarget
LOCAL_GL_TEXTURE_WRAP_T
LOCAL_GL_CLAMP_TO_EDGE
)
;
mGLContext
-
>
fBindTexture
(
mFBOTextureTarget
0
)
;
if
(
aAllocSize
)
{
aAllocSize
-
>
width
=
clampedRect
.
Width
(
)
;
aAllocSize
-
>
height
=
clampedRect
.
Height
(
)
;
}
return
tex
;
}
ShaderConfigOGL
CompositorOGL
:
:
GetShaderConfigFor
(
Effect
*
aEffect
MaskType
aMask
gfx
:
:
CompositionOp
aOp
bool
aColorMatrix
bool
aDEAAEnabled
)
const
{
ShaderConfigOGL
config
;
switch
(
aEffect
-
>
mType
)
{
case
EffectTypes
:
:
SOLID_COLOR
:
config
.
SetRenderColor
(
true
)
;
break
;
case
EffectTypes
:
:
YCBCR
:
{
config
.
SetYCbCr
(
true
)
;
EffectYCbCr
*
effectYCbCr
=
static_cast
<
EffectYCbCr
*
>
(
aEffect
)
;
uint32_t
pixelBits
=
(
8
*
BytesPerPixel
(
SurfaceFormatForAlphaBitDepth
(
effectYCbCr
-
>
mBitDepth
)
)
)
;
uint32_t
paddingBits
=
pixelBits
-
effectYCbCr
-
>
mBitDepth
;
config
.
SetColorMultiplier
(
pow
(
2
paddingBits
)
)
;
break
;
}
case
EffectTypes
:
:
NV12
:
config
.
SetNV12
(
true
)
;
config
.
SetTextureTarget
(
LOCAL_GL_TEXTURE_RECTANGLE_ARB
)
;
break
;
case
EffectTypes
:
:
COMPONENT_ALPHA
:
{
config
.
SetComponentAlpha
(
true
)
;
EffectComponentAlpha
*
effectComponentAlpha
=
static_cast
<
EffectComponentAlpha
*
>
(
aEffect
)
;
gfx
:
:
SurfaceFormat
format
=
effectComponentAlpha
-
>
mOnWhite
-
>
GetFormat
(
)
;
config
.
SetRBSwap
(
format
=
=
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
|
|
format
=
=
gfx
:
:
SurfaceFormat
:
:
B8G8R8X8
)
;
TextureSourceOGL
*
source
=
effectComponentAlpha
-
>
mOnWhite
-
>
AsSourceOGL
(
)
;
config
.
SetTextureTarget
(
source
-
>
GetTextureTarget
(
)
)
;
break
;
}
case
EffectTypes
:
:
RENDER_TARGET
:
config
.
SetTextureTarget
(
mFBOTextureTarget
)
;
break
;
default
:
{
MOZ_ASSERT
(
aEffect
-
>
mType
=
=
EffectTypes
:
:
RGB
)
;
TexturedEffect
*
texturedEffect
=
static_cast
<
TexturedEffect
*
>
(
aEffect
)
;
TextureSourceOGL
*
source
=
texturedEffect
-
>
mTexture
-
>
AsSourceOGL
(
)
;
MOZ_ASSERT_IF
(
source
-
>
GetTextureTarget
(
)
=
=
LOCAL_GL_TEXTURE_EXTERNAL
source
-
>
GetFormat
(
)
=
=
gfx
:
:
SurfaceFormat
:
:
R8G8B8A8
|
|
source
-
>
GetFormat
(
)
=
=
gfx
:
:
SurfaceFormat
:
:
R8G8B8X8
)
;
MOZ_ASSERT_IF
(
source
-
>
GetTextureTarget
(
)
=
=
LOCAL_GL_TEXTURE_RECTANGLE_ARB
source
-
>
GetFormat
(
)
=
=
gfx
:
:
SurfaceFormat
:
:
R8G8B8A8
|
|
source
-
>
GetFormat
(
)
=
=
gfx
:
:
SurfaceFormat
:
:
R8G8B8X8
|
|
source
-
>
GetFormat
(
)
=
=
gfx
:
:
SurfaceFormat
:
:
R5G6B5_UINT16
|
|
source
-
>
GetFormat
(
)
=
=
gfx
:
:
SurfaceFormat
:
:
YUV422
)
;
config
=
ShaderConfigFromTargetAndFormat
(
source
-
>
GetTextureTarget
(
)
source
-
>
GetFormat
(
)
)
;
if
(
!
texturedEffect
-
>
mPremultiplied
)
{
config
.
SetNoPremultipliedAlpha
(
)
;
}
break
;
}
}
config
.
SetColorMatrix
(
aColorMatrix
)
;
config
.
SetMask
(
aMask
=
=
MaskType
:
:
Mask
)
;
config
.
SetDEAA
(
aDEAAEnabled
)
;
config
.
SetCompositionOp
(
aOp
)
;
return
config
;
}
ShaderProgramOGL
*
CompositorOGL
:
:
GetShaderProgramFor
(
const
ShaderConfigOGL
&
aConfig
)
{
std
:
:
map
<
ShaderConfigOGL
ShaderProgramOGL
*
>
:
:
iterator
iter
=
mPrograms
.
find
(
aConfig
)
;
if
(
iter
!
=
mPrograms
.
end
(
)
)
return
iter
-
>
second
;
ProgramProfileOGL
profile
=
ProgramProfileOGL
:
:
GetProfileFor
(
aConfig
)
;
ShaderProgramOGL
*
shader
=
new
ShaderProgramOGL
(
gl
(
)
profile
)
;
if
(
!
shader
-
>
Initialize
(
)
)
{
delete
shader
;
return
nullptr
;
}
mPrograms
[
aConfig
]
=
shader
;
return
shader
;
}
void
CompositorOGL
:
:
ActivateProgram
(
ShaderProgramOGL
*
aProg
)
{
if
(
mCurrentProgram
!
=
aProg
)
{
gl
(
)
-
>
fUseProgram
(
aProg
-
>
GetProgram
(
)
)
;
mCurrentProgram
=
aProg
;
}
}
void
CompositorOGL
:
:
ResetProgram
(
)
{
mCurrentProgram
=
nullptr
;
}
static
bool
SetBlendMode
(
GLContext
*
aGL
gfx
:
:
CompositionOp
aBlendMode
bool
aIsPremultiplied
=
true
)
{
if
(
BlendOpIsMixBlendMode
(
aBlendMode
)
)
{
return
false
;
}
if
(
aBlendMode
=
=
gfx
:
:
CompositionOp
:
:
OP_OVER
&
&
aIsPremultiplied
)
{
return
false
;
}
GLenum
srcBlend
;
GLenum
dstBlend
;
GLenum
srcAlphaBlend
=
LOCAL_GL_ONE
;
GLenum
dstAlphaBlend
=
LOCAL_GL_ONE_MINUS_SRC_ALPHA
;
switch
(
aBlendMode
)
{
case
gfx
:
:
CompositionOp
:
:
OP_OVER
:
MOZ_ASSERT
(
!
aIsPremultiplied
)
;
srcBlend
=
LOCAL_GL_SRC_ALPHA
;
dstBlend
=
LOCAL_GL_ONE_MINUS_SRC_ALPHA
;
break
;
case
gfx
:
:
CompositionOp
:
:
OP_SOURCE
:
srcBlend
=
aIsPremultiplied
?
LOCAL_GL_ONE
:
LOCAL_GL_SRC_ALPHA
;
dstBlend
=
LOCAL_GL_ZERO
;
srcAlphaBlend
=
LOCAL_GL_ONE
;
dstAlphaBlend
=
LOCAL_GL_ZERO
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
blend
mode
!
"
)
;
return
false
;
}
aGL
-
>
fBlendFuncSeparate
(
srcBlend
dstBlend
srcAlphaBlend
dstAlphaBlend
)
;
return
true
;
}
gfx
:
:
Point3D
CompositorOGL
:
:
GetLineCoefficients
(
const
gfx
:
:
Point
&
aPoint1
const
gfx
:
:
Point
&
aPoint2
)
{
gfx
:
:
Point3D
coeffecients
;
coeffecients
.
x
=
aPoint1
.
y
-
aPoint2
.
y
;
coeffecients
.
y
=
aPoint2
.
x
-
aPoint1
.
x
;
coeffecients
.
z
=
aPoint1
.
x
*
aPoint2
.
y
-
aPoint2
.
x
*
aPoint1
.
y
;
coeffecients
*
=
1
.
0f
/
sqrtf
(
coeffecients
.
x
*
coeffecients
.
x
+
coeffecients
.
y
*
coeffecients
.
y
)
;
coeffecients
.
z
+
=
0
.
5f
;
return
coeffecients
;
}
void
CompositorOGL
:
:
DrawQuad
(
const
Rect
&
aRect
const
IntRect
&
aClipRect
const
EffectChain
&
aEffectChain
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfx
:
:
Rect
&
aVisibleRect
)
{
AUTO_PROFILER_LABEL
(
"
CompositorOGL
:
:
DrawQuad
"
GRAPHICS
)
;
DrawGeometry
(
aRect
aRect
aClipRect
aEffectChain
aOpacity
aTransform
aVisibleRect
)
;
}
void
CompositorOGL
:
:
DrawTriangles
(
const
nsTArray
<
gfx
:
:
TexturedTriangle
>
&
aTriangles
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
IntRect
&
aClipRect
const
EffectChain
&
aEffectChain
gfx
:
:
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfx
:
:
Rect
&
aVisibleRect
)
{
AUTO_PROFILER_LABEL
(
"
CompositorOGL
:
:
DrawTriangles
"
GRAPHICS
)
;
DrawGeometry
(
aTriangles
aRect
aClipRect
aEffectChain
aOpacity
aTransform
aVisibleRect
)
;
}
template
<
typename
Geometry
>
void
CompositorOGL
:
:
DrawGeometry
(
const
Geometry
&
aGeometry
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
IntRect
&
aClipRect
const
EffectChain
&
aEffectChain
gfx
:
:
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfx
:
:
Rect
&
aVisibleRect
)
{
MOZ_ASSERT
(
mFrameInProgress
"
frame
not
started
"
)
;
MOZ_ASSERT
(
mCurrentRenderTarget
"
No
destination
"
)
;
MakeCurrent
(
)
;
IntPoint
offset
=
mCurrentRenderTarget
-
>
GetOrigin
(
)
;
IntSize
size
=
mCurrentRenderTarget
-
>
GetSize
(
)
;
Rect
renderBound
(
0
0
size
.
width
size
.
height
)
;
renderBound
.
IntersectRect
(
renderBound
Rect
(
aClipRect
)
)
;
renderBound
.
MoveBy
(
offset
)
;
Rect
destRect
=
aTransform
.
TransformAndClipBounds
(
aRect
renderBound
)
;
mPixelsFilled
+
=
destRect
.
width
*
destRect
.
height
;
destRect
.
Inflate
(
1
1
)
;
destRect
.
MoveBy
(
-
offset
)
;
renderBound
=
Rect
(
0
0
size
.
width
size
.
height
)
;
if
(
!
renderBound
.
Intersects
(
destRect
)
)
{
return
;
}
LayerScope
:
:
DrawBegin
(
)
;
IntRect
clipRect
=
aClipRect
;
if
(
!
mTarget
&
&
mCurrentRenderTarget
-
>
IsWindow
(
)
)
{
clipRect
.
MoveBy
(
mRenderOffset
.
x
mRenderOffset
.
y
)
;
}
ScopedGLState
scopedScissorTestState
(
mGLContext
LOCAL_GL_SCISSOR_TEST
true
)
;
ScopedScissorRect
autoScissorRect
(
mGLContext
clipRect
.
x
FlipY
(
clipRect
.
y
+
clipRect
.
height
)
clipRect
.
width
clipRect
.
height
)
;
MaskType
maskType
;
EffectMask
*
effectMask
;
TextureSourceOGL
*
sourceMask
=
nullptr
;
gfx
:
:
Matrix4x4
maskQuadTransform
;
if
(
aEffectChain
.
mSecondaryEffects
[
EffectTypes
:
:
MASK
]
)
{
effectMask
=
static_cast
<
EffectMask
*
>
(
aEffectChain
.
mSecondaryEffects
[
EffectTypes
:
:
MASK
]
.
get
(
)
)
;
sourceMask
=
effectMask
-
>
mMaskTexture
-
>
AsSourceOGL
(
)
;
IntSize
maskSize
=
CalculatePOTSize
(
effectMask
-
>
mSize
mGLContext
)
;
const
gfx
:
:
Matrix4x4
&
maskTransform
=
effectMask
-
>
mMaskTransform
;
NS_ASSERTION
(
maskTransform
.
Is2D
(
)
"
How
did
we
end
up
with
a
3D
transform
here
?
!
"
)
;
Rect
bounds
=
Rect
(
Point
(
)
Size
(
maskSize
)
)
;
bounds
=
maskTransform
.
As2D
(
)
.
TransformBounds
(
bounds
)
;
maskQuadTransform
.
_11
=
1
.
0f
/
bounds
.
width
;
maskQuadTransform
.
_22
=
1
.
0f
/
bounds
.
height
;
maskQuadTransform
.
_41
=
float
(
-
bounds
.
x
)
/
bounds
.
width
;
maskQuadTransform
.
_42
=
float
(
-
bounds
.
y
)
/
bounds
.
height
;
maskType
=
MaskType
:
:
Mask
;
}
else
{
maskType
=
MaskType
:
:
MaskNone
;
}
Color
color
;
if
(
aEffectChain
.
mPrimaryEffect
-
>
mType
=
=
EffectTypes
:
:
SOLID_COLOR
)
{
EffectSolidColor
*
effectSolidColor
=
static_cast
<
EffectSolidColor
*
>
(
aEffectChain
.
mPrimaryEffect
.
get
(
)
)
;
color
=
effectSolidColor
-
>
mColor
;
Float
opacity
=
aOpacity
*
color
.
a
;
color
.
r
*
=
opacity
;
color
.
g
*
=
opacity
;
color
.
b
*
=
opacity
;
color
.
a
=
opacity
;
aOpacity
=
1
.
f
;
}
bool
createdMixBlendBackdropTexture
=
false
;
GLuint
mixBlendBackdrop
=
0
;
gfx
:
:
CompositionOp
blendMode
=
gfx
:
:
CompositionOp
:
:
OP_OVER
;
if
(
aEffectChain
.
mSecondaryEffects
[
EffectTypes
:
:
BLEND_MODE
]
)
{
EffectBlendMode
*
blendEffect
=
static_cast
<
EffectBlendMode
*
>
(
aEffectChain
.
mSecondaryEffects
[
EffectTypes
:
:
BLEND_MODE
]
.
get
(
)
)
;
blendMode
=
blendEffect
-
>
mBlendMode
;
}
bool
bEnableAA
=
gfxPrefs
:
:
LayersDEAAEnabled
(
)
&
&
!
aTransform
.
Is2DIntegerTranslation
(
)
;
bool
colorMatrix
=
aEffectChain
.
mSecondaryEffects
[
EffectTypes
:
:
COLOR_MATRIX
]
;
ShaderConfigOGL
config
=
GetShaderConfigFor
(
aEffectChain
.
mPrimaryEffect
maskType
blendMode
colorMatrix
bEnableAA
)
;
config
.
SetOpacity
(
aOpacity
!
=
1
.
f
)
;
ApplyPrimitiveConfig
(
config
aGeometry
)
;
ShaderProgramOGL
*
program
=
GetShaderProgramFor
(
config
)
;
ActivateProgram
(
program
)
;
program
-
>
SetProjectionMatrix
(
mProjMatrix
)
;
program
-
>
SetLayerTransform
(
aTransform
)
;
LayerScope
:
:
SetLayerTransform
(
aTransform
)
;
if
(
colorMatrix
)
{
EffectColorMatrix
*
effectColorMatrix
=
static_cast
<
EffectColorMatrix
*
>
(
aEffectChain
.
mSecondaryEffects
[
EffectTypes
:
:
COLOR_MATRIX
]
.
get
(
)
)
;
program
-
>
SetColorMatrix
(
effectColorMatrix
-
>
mColorMatrix
)
;
}
if
(
BlendOpIsMixBlendMode
(
blendMode
)
)
{
gfx
:
:
Matrix4x4
backdropTransform
;
if
(
gl
(
)
-
>
IsExtensionSupported
(
GLContext
:
:
NV_texture_barrier
)
)
{
gl
(
)
-
>
fTextureBarrier
(
)
;
mixBlendBackdrop
=
mCurrentRenderTarget
-
>
GetTextureHandle
(
)
;
}
else
{
gfx
:
:
IntRect
rect
=
ComputeBackdropCopyRect
(
aRect
aClipRect
aTransform
&
backdropTransform
)
;
mixBlendBackdrop
=
CreateTexture
(
rect
true
mCurrentRenderTarget
-
>
GetFBO
(
)
)
;
createdMixBlendBackdropTexture
=
true
;
}
program
-
>
SetBackdropTransform
(
backdropTransform
)
;
}
program
-
>
SetRenderOffset
(
offset
.
x
offset
.
y
)
;
LayerScope
:
:
SetRenderOffset
(
offset
.
x
offset
.
y
)
;
if
(
aOpacity
!
=
1
.
f
)
program
-
>
SetLayerOpacity
(
aOpacity
)
;
if
(
config
.
mFeatures
&
ENABLE_TEXTURE_RECT
)
{
TextureSourceOGL
*
source
=
nullptr
;
if
(
aEffectChain
.
mPrimaryEffect
-
>
mType
=
=
EffectTypes
:
:
COMPONENT_ALPHA
)
{
EffectComponentAlpha
*
effectComponentAlpha
=
static_cast
<
EffectComponentAlpha
*
>
(
aEffectChain
.
mPrimaryEffect
.
get
(
)
)
;
source
=
effectComponentAlpha
-
>
mOnWhite
-
>
AsSourceOGL
(
)
;
}
else
{
TexturedEffect
*
texturedEffect
=
static_cast
<
TexturedEffect
*
>
(
aEffectChain
.
mPrimaryEffect
.
get
(
)
)
;
source
=
texturedEffect
-
>
mTexture
-
>
AsSourceOGL
(
)
;
}
program
-
>
SetTexCoordMultiplier
(
source
-
>
GetSize
(
)
.
width
source
-
>
GetSize
(
)
.
height
)
;
}
if
(
bEnableAA
)
{
Matrix4x4
flatTransform
=
aTransform
;
flatTransform
.
PostTranslate
(
-
offset
.
x
-
offset
.
y
0
.
0f
)
;
flatTransform
*
=
mProjMatrix
;
Rect
viewportClip
=
Rect
(
-
1
.
0f
-
1
.
0f
2
.
0f
2
.
0f
)
;
size_t
edgeCount
=
0
;
Point3D
coefficients
[
4
]
;
Point
points
[
Matrix4x4
:
:
kTransformAndClipRectMaxVerts
]
;
size_t
pointCount
=
flatTransform
.
TransformAndClipRect
(
aVisibleRect
viewportClip
points
)
;
for
(
size_t
i
=
0
;
i
<
pointCount
;
i
+
+
)
{
points
[
i
]
=
Point
(
(
points
[
i
]
.
x
*
0
.
5f
+
0
.
5f
)
*
mViewportSize
.
width
(
points
[
i
]
.
y
*
0
.
5f
+
0
.
5f
)
*
mViewportSize
.
height
)
;
}
if
(
pointCount
>
2
)
{
float
winding
=
0
.
0f
;
size_t
wp
=
0
;
while
(
winding
=
=
0
.
0f
&
&
wp
<
pointCount
)
{
int
wp1
=
(
wp
+
1
)
%
pointCount
;
int
wp2
=
(
wp
+
2
)
%
pointCount
;
winding
=
(
points
[
wp1
]
.
x
-
points
[
wp
]
.
x
)
*
(
points
[
wp1
]
.
y
+
points
[
wp
]
.
y
)
+
(
points
[
wp2
]
.
x
-
points
[
wp1
]
.
x
)
*
(
points
[
wp2
]
.
y
+
points
[
wp1
]
.
y
)
+
(
points
[
wp
]
.
x
-
points
[
wp2
]
.
x
)
*
(
points
[
wp
]
.
y
+
points
[
wp2
]
.
y
)
;
wp
+
+
;
}
bool
frontFacing
=
winding
>
=
0
.
0f
;
for
(
size_t
i
=
0
;
i
<
pointCount
;
i
+
+
)
{
const
Point
&
p1
=
points
[
i
]
;
const
Point
&
p2
=
points
[
(
i
+
1
)
%
pointCount
]
;
if
(
p1
.
x
!
=
p2
.
x
&
&
p1
.
y
!
=
p2
.
y
&
&
edgeCount
<
4
)
{
if
(
frontFacing
)
{
coefficients
[
edgeCount
+
+
]
=
GetLineCoefficients
(
p2
p1
)
;
}
else
{
coefficients
[
edgeCount
+
+
]
=
GetLineCoefficients
(
p1
p2
)
;
}
}
}
}
for
(
size_t
i
=
edgeCount
;
i
<
4
;
i
+
+
)
{
coefficients
[
i
]
=
Point3D
(
0
.
0f
1
.
0f
mViewportSize
.
height
)
;
}
Matrix4x4
transformInverted
=
aTransform
;
transformInverted
.
Invert
(
)
;
program
-
>
SetLayerTransformInverse
(
transformInverted
)
;
program
-
>
SetDEAAEdges
(
coefficients
)
;
program
-
>
SetVisibleCenter
(
aVisibleRect
.
Center
(
)
)
;
program
-
>
SetViewportSize
(
mViewportSize
)
;
}
bool
didSetBlendMode
=
false
;
switch
(
aEffectChain
.
mPrimaryEffect
-
>
mType
)
{
case
EffectTypes
:
:
SOLID_COLOR
:
{
program
-
>
SetRenderColor
(
color
)
;
if
(
maskType
!
=
MaskType
:
:
MaskNone
)
{
BindMaskForProgram
(
program
sourceMask
LOCAL_GL_TEXTURE0
maskQuadTransform
)
;
}
if
(
mixBlendBackdrop
)
{
BindBackdrop
(
program
mixBlendBackdrop
LOCAL_GL_TEXTURE1
)
;
}
didSetBlendMode
=
SetBlendMode
(
gl
(
)
blendMode
)
;
BindAndDrawGeometry
(
program
aGeometry
)
;
}
break
;
case
EffectTypes
:
:
RGB
:
{
TexturedEffect
*
texturedEffect
=
static_cast
<
TexturedEffect
*
>
(
aEffectChain
.
mPrimaryEffect
.
get
(
)
)
;
TextureSource
*
source
=
texturedEffect
-
>
mTexture
;
didSetBlendMode
=
SetBlendMode
(
gl
(
)
blendMode
texturedEffect
-
>
mPremultiplied
)
;
gfx
:
:
SamplingFilter
samplingFilter
=
texturedEffect
-
>
mSamplingFilter
;
source
-
>
AsSourceOGL
(
)
-
>
BindTexture
(
LOCAL_GL_TEXTURE0
samplingFilter
)
;
program
-
>
SetTextureUnit
(
0
)
;
Matrix4x4
textureTransform
=
source
-
>
AsSourceOGL
(
)
-
>
GetTextureTransform
(
)
;
program
-
>
SetTextureTransform
(
textureTransform
)
;
if
(
maskType
!
=
MaskType
:
:
MaskNone
)
{
BindMaskForProgram
(
program
sourceMask
LOCAL_GL_TEXTURE1
maskQuadTransform
)
;
}
if
(
mixBlendBackdrop
)
{
BindBackdrop
(
program
mixBlendBackdrop
LOCAL_GL_TEXTURE2
)
;
}
BindAndDrawGeometryWithTextureRect
(
program
aGeometry
texturedEffect
-
>
mTextureCoords
source
)
;
}
break
;
case
EffectTypes
:
:
YCBCR
:
{
EffectYCbCr
*
effectYCbCr
=
static_cast
<
EffectYCbCr
*
>
(
aEffectChain
.
mPrimaryEffect
.
get
(
)
)
;
TextureSource
*
sourceYCbCr
=
effectYCbCr
-
>
mTexture
;
const
int
Y
=
0
Cb
=
1
Cr
=
2
;
TextureSourceOGL
*
sourceY
=
sourceYCbCr
-
>
GetSubSource
(
Y
)
-
>
AsSourceOGL
(
)
;
TextureSourceOGL
*
sourceCb
=
sourceYCbCr
-
>
GetSubSource
(
Cb
)
-
>
AsSourceOGL
(
)
;
TextureSourceOGL
*
sourceCr
=
sourceYCbCr
-
>
GetSubSource
(
Cr
)
-
>
AsSourceOGL
(
)
;
if
(
!
sourceY
|
|
!
sourceCb
|
|
!
sourceCr
)
{
NS_WARNING
(
"
Invalid
layer
texture
.
"
)
;
return
;
}
sourceY
-
>
BindTexture
(
LOCAL_GL_TEXTURE0
effectYCbCr
-
>
mSamplingFilter
)
;
sourceCb
-
>
BindTexture
(
LOCAL_GL_TEXTURE1
effectYCbCr
-
>
mSamplingFilter
)
;
sourceCr
-
>
BindTexture
(
LOCAL_GL_TEXTURE2
effectYCbCr
-
>
mSamplingFilter
)
;
program
-
>
SetYCbCrTextureUnits
(
Y
Cb
Cr
)
;
program
-
>
SetTextureTransform
(
Matrix4x4
(
)
)
;
program
-
>
SetYUVColorSpace
(
effectYCbCr
-
>
mYUVColorSpace
)
;
if
(
maskType
!
=
MaskType
:
:
MaskNone
)
{
BindMaskForProgram
(
program
sourceMask
LOCAL_GL_TEXTURE3
maskQuadTransform
)
;
}
if
(
mixBlendBackdrop
)
{
BindBackdrop
(
program
mixBlendBackdrop
LOCAL_GL_TEXTURE4
)
;
}
didSetBlendMode
=
SetBlendMode
(
gl
(
)
blendMode
)
;
BindAndDrawGeometryWithTextureRect
(
program
aGeometry
effectYCbCr
-
>
mTextureCoords
sourceYCbCr
-
>
GetSubSource
(
Y
)
)
;
}
break
;
case
EffectTypes
:
:
NV12
:
{
EffectNV12
*
effectNV12
=
static_cast
<
EffectNV12
*
>
(
aEffectChain
.
mPrimaryEffect
.
get
(
)
)
;
TextureSource
*
sourceNV12
=
effectNV12
-
>
mTexture
;
const
int
Y
=
0
CbCr
=
1
;
TextureSourceOGL
*
sourceY
=
sourceNV12
-
>
GetSubSource
(
Y
)
-
>
AsSourceOGL
(
)
;
TextureSourceOGL
*
sourceCbCr
=
sourceNV12
-
>
GetSubSource
(
CbCr
)
-
>
AsSourceOGL
(
)
;
if
(
!
sourceY
|
|
!
sourceCbCr
)
{
NS_WARNING
(
"
Invalid
layer
texture
.
"
)
;
return
;
}
sourceY
-
>
BindTexture
(
LOCAL_GL_TEXTURE0
effectNV12
-
>
mSamplingFilter
)
;
sourceCbCr
-
>
BindTexture
(
LOCAL_GL_TEXTURE1
effectNV12
-
>
mSamplingFilter
)
;
if
(
config
.
mFeatures
&
ENABLE_TEXTURE_RECT
)
{
program
-
>
SetCbCrTexCoordMultiplier
(
sourceCbCr
-
>
GetSize
(
)
.
width
sourceCbCr
-
>
GetSize
(
)
.
height
)
;
}
program
-
>
SetNV12TextureUnits
(
Y
CbCr
)
;
program
-
>
SetTextureTransform
(
Matrix4x4
(
)
)
;
if
(
maskType
!
=
MaskType
:
:
MaskNone
)
{
BindMaskForProgram
(
program
sourceMask
LOCAL_GL_TEXTURE2
maskQuadTransform
)
;
}
if
(
mixBlendBackdrop
)
{
BindBackdrop
(
program
mixBlendBackdrop
LOCAL_GL_TEXTURE3
)
;
}
didSetBlendMode
=
SetBlendMode
(
gl
(
)
blendMode
)
;
BindAndDrawGeometryWithTextureRect
(
program
aGeometry
effectNV12
-
>
mTextureCoords
sourceNV12
-
>
GetSubSource
(
Y
)
)
;
}
break
;
case
EffectTypes
:
:
RENDER_TARGET
:
{
EffectRenderTarget
*
effectRenderTarget
=
static_cast
<
EffectRenderTarget
*
>
(
aEffectChain
.
mPrimaryEffect
.
get
(
)
)
;
RefPtr
<
CompositingRenderTargetOGL
>
surface
=
static_cast
<
CompositingRenderTargetOGL
*
>
(
effectRenderTarget
-
>
mRenderTarget
.
get
(
)
)
;
surface
-
>
BindTexture
(
LOCAL_GL_TEXTURE0
mFBOTextureTarget
)
;
Matrix
transform
;
transform
.
PreTranslate
(
0
.
0
1
.
0
)
;
transform
.
PreScale
(
1
.
0f
-
1
.
0f
)
;
program
-
>
SetTextureTransform
(
Matrix4x4
:
:
From2D
(
transform
)
)
;
program
-
>
SetTextureUnit
(
0
)
;
if
(
maskType
!
=
MaskType
:
:
MaskNone
)
{
BindMaskForProgram
(
program
sourceMask
LOCAL_GL_TEXTURE1
maskQuadTransform
)
;
}
if
(
mixBlendBackdrop
)
{
BindBackdrop
(
program
mixBlendBackdrop
LOCAL_GL_TEXTURE2
)
;
}
if
(
config
.
mFeatures
&
ENABLE_TEXTURE_RECT
)
{
program
-
>
SetTexCoordMultiplier
(
surface
-
>
GetSize
(
)
.
width
surface
-
>
GetSize
(
)
.
height
)
;
}
didSetBlendMode
=
SetBlendMode
(
gl
(
)
blendMode
)
;
BindAndDrawGeometry
(
program
aGeometry
)
;
}
break
;
case
EffectTypes
:
:
COMPONENT_ALPHA
:
{
MOZ_ASSERT
(
gfxPrefs
:
:
ComponentAlphaEnabled
(
)
)
;
MOZ_ASSERT
(
blendMode
=
=
gfx
:
:
CompositionOp
:
:
OP_OVER
"
Can
'
t
support
blend
modes
with
component
alpha
!
"
)
;
EffectComponentAlpha
*
effectComponentAlpha
=
static_cast
<
EffectComponentAlpha
*
>
(
aEffectChain
.
mPrimaryEffect
.
get
(
)
)
;
TextureSourceOGL
*
sourceOnWhite
=
effectComponentAlpha
-
>
mOnWhite
-
>
AsSourceOGL
(
)
;
TextureSourceOGL
*
sourceOnBlack
=
effectComponentAlpha
-
>
mOnBlack
-
>
AsSourceOGL
(
)
;
if
(
!
sourceOnBlack
-
>
IsValid
(
)
|
|
!
sourceOnWhite
-
>
IsValid
(
)
)
{
NS_WARNING
(
"
Invalid
layer
texture
for
component
alpha
"
)
;
return
;
}
sourceOnBlack
-
>
BindTexture
(
LOCAL_GL_TEXTURE0
effectComponentAlpha
-
>
mSamplingFilter
)
;
sourceOnWhite
-
>
BindTexture
(
LOCAL_GL_TEXTURE1
effectComponentAlpha
-
>
mSamplingFilter
)
;
program
-
>
SetBlackTextureUnit
(
0
)
;
program
-
>
SetWhiteTextureUnit
(
1
)
;
program
-
>
SetTextureTransform
(
Matrix4x4
(
)
)
;
if
(
maskType
!
=
MaskType
:
:
MaskNone
)
{
BindMaskForProgram
(
program
sourceMask
LOCAL_GL_TEXTURE2
maskQuadTransform
)
;
}
gl
(
)
-
>
fBlendFuncSeparate
(
LOCAL_GL_ZERO
LOCAL_GL_ONE_MINUS_SRC_COLOR
LOCAL_GL_ONE
LOCAL_GL_ONE
)
;
program
-
>
SetTexturePass2
(
false
)
;
BindAndDrawGeometryWithTextureRect
(
program
aGeometry
effectComponentAlpha
-
>
mTextureCoords
effectComponentAlpha
-
>
mOnBlack
)
;
gl
(
)
-
>
fBlendFuncSeparate
(
LOCAL_GL_ONE
LOCAL_GL_ONE
LOCAL_GL_ONE
LOCAL_GL_ONE
)
;
program
-
>
SetTexturePass2
(
true
)
;
BindAndDrawGeometryWithTextureRect
(
program
aGeometry
effectComponentAlpha
-
>
mTextureCoords
effectComponentAlpha
-
>
mOnBlack
)
;
mGLContext
-
>
fBlendFuncSeparate
(
LOCAL_GL_ONE
LOCAL_GL_ONE_MINUS_SRC_ALPHA
LOCAL_GL_ONE
LOCAL_GL_ONE_MINUS_SRC_ALPHA
)
;
}
break
;
default
:
MOZ_ASSERT
(
false
"
Unhandled
effect
type
"
)
;
break
;
}
if
(
didSetBlendMode
)
{
gl
(
)
-
>
fBlendFuncSeparate
(
LOCAL_GL_ONE
LOCAL_GL_ONE_MINUS_SRC_ALPHA
LOCAL_GL_ONE
LOCAL_GL_ONE_MINUS_SRC_ALPHA
)
;
}
if
(
createdMixBlendBackdropTexture
)
{
gl
(
)
-
>
fDeleteTextures
(
1
&
mixBlendBackdrop
)
;
}
MakeCurrent
(
)
;
LayerScope
:
:
DrawEnd
(
mGLContext
aEffectChain
aRect
.
width
aRect
.
height
)
;
}
void
CompositorOGL
:
:
BindAndDrawGeometry
(
ShaderProgramOGL
*
aProgram
const
gfx
:
:
Rect
&
aRect
)
{
BindAndDrawQuad
(
aProgram
aRect
)
;
}
void
CompositorOGL
:
:
BindAndDrawGeometry
(
ShaderProgramOGL
*
aProgram
const
nsTArray
<
gfx
:
:
TexturedTriangle
>
&
aTriangles
)
{
NS_ASSERTION
(
aProgram
-
>
HasInitialized
(
)
"
Shader
program
not
correctly
initialized
"
)
;
const
nsTArray
<
TexturedVertex
>
vertices
=
TexturedTrianglesToVertexArray
(
aTriangles
)
;
mGLContext
-
>
fBindBuffer
(
LOCAL_GL_ARRAY_BUFFER
mTriangleVBO
)
;
mGLContext
-
>
fBufferData
(
LOCAL_GL_ARRAY_BUFFER
vertices
.
Length
(
)
*
sizeof
(
TexturedVertex
)
vertices
.
Elements
(
)
LOCAL_GL_STREAM_DRAW
)
;
const
GLsizei
stride
=
4
*
sizeof
(
GLfloat
)
;
InitializeVAO
(
kCoordinateAttributeIndex
2
stride
0
)
;
InitializeVAO
(
kTexCoordinateAttributeIndex
2
stride
2
*
sizeof
(
GLfloat
)
)
;
mGLContext
-
>
fDrawArrays
(
LOCAL_GL_TRIANGLES
0
vertices
.
Length
(
)
)
;
mGLContext
-
>
fDisableVertexAttribArray
(
kCoordinateAttributeIndex
)
;
mGLContext
-
>
fDisableVertexAttribArray
(
kTexCoordinateAttributeIndex
)
;
mGLContext
-
>
fBindBuffer
(
LOCAL_GL_ARRAY_BUFFER
0
)
;
}
void
CompositorOGL
:
:
BindAndDrawGeometryWithTextureRect
(
ShaderProgramOGL
*
aProg
const
Rect
&
aRect
const
Rect
&
aTexCoordRect
TextureSource
*
aTexture
)
{
Rect
scaledTexCoordRect
=
GetTextureCoordinates
(
aTexCoordRect
aTexture
)
;
Rect
layerRects
[
4
]
;
Rect
textureRects
[
4
]
;
size_t
rects
=
DecomposeIntoNoRepeatRects
(
aRect
scaledTexCoordRect
&
layerRects
&
textureRects
)
;
BindAndDrawQuads
(
aProg
rects
layerRects
textureRects
)
;
}
void
CompositorOGL
:
:
BindAndDrawGeometryWithTextureRect
(
ShaderProgramOGL
*
aProg
const
nsTArray
<
gfx
:
:
TexturedTriangle
>
&
aTriangles
const
gfx
:
:
Rect
&
aTexCoordRect
TextureSource
*
aTexture
)
{
BindAndDrawGeometry
(
aProg
aTriangles
)
;
}
void
CompositorOGL
:
:
BindAndDrawQuads
(
ShaderProgramOGL
*
aProg
int
aQuads
const
Rect
*
aLayerRects
const
Rect
*
aTextureRects
)
{
NS_ASSERTION
(
aProg
-
>
HasInitialized
(
)
"
Shader
program
not
correctly
initialized
"
)
;
mGLContext
-
>
fBindBuffer
(
LOCAL_GL_ARRAY_BUFFER
mQuadVBO
)
;
InitializeVAO
(
kCoordinateAttributeIndex
4
0
0
)
;
aProg
-
>
SetLayerRects
(
aLayerRects
)
;
if
(
aProg
-
>
GetTextureCount
(
)
>
0
)
{
aProg
-
>
SetTextureRects
(
aTextureRects
)
;
}
mGLContext
-
>
fDrawArrays
(
LOCAL_GL_TRIANGLES
0
6
*
aQuads
)
;
mGLContext
-
>
fDisableVertexAttribArray
(
kCoordinateAttributeIndex
)
;
mGLContext
-
>
fBindBuffer
(
LOCAL_GL_ARRAY_BUFFER
0
)
;
LayerScope
:
:
SetDrawRects
(
aQuads
aLayerRects
aTextureRects
)
;
}
void
CompositorOGL
:
:
InitializeVAO
(
const
GLuint
aAttrib
const
GLint
aComponents
const
GLsizei
aStride
const
size_t
aOffset
)
{
mGLContext
-
>
fVertexAttribPointer
(
aAttrib
aComponents
LOCAL_GL_FLOAT
LOCAL_GL_FALSE
aStride
reinterpret_cast
<
GLvoid
*
>
(
aOffset
)
)
;
mGLContext
-
>
fEnableVertexAttribArray
(
aAttrib
)
;
}
void
CompositorOGL
:
:
EndFrame
(
)
{
AUTO_PROFILER_LABEL
(
"
CompositorOGL
:
:
EndFrame
"
GRAPHICS
)
;
MOZ_ASSERT
(
mCurrentRenderTarget
=
=
mWindowRenderTarget
"
Rendering
target
not
properly
restored
"
)
;
#
ifdef
MOZ_DUMP_PAINTING
if
(
gfxEnv
:
:
DumpCompositorTextures
(
)
)
{
LayoutDeviceIntSize
size
;
if
(
mUseExternalSurfaceSize
)
{
size
=
LayoutDeviceIntSize
(
mSurfaceSize
.
width
mSurfaceSize
.
height
)
;
}
else
{
size
=
mWidget
-
>
GetClientSize
(
)
;
}
RefPtr
<
DrawTarget
>
target
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateOffscreenContentDrawTarget
(
IntSize
(
size
.
width
size
.
height
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
target
)
{
CopyToTarget
(
target
nsIntPoint
(
)
Matrix
(
)
)
;
WriteSnapshotToDumpFile
(
this
target
)
;
}
}
#
endif
mContextStateTracker
.
PopOGLSection
(
gl
(
)
"
Frame
"
)
;
mFrameInProgress
=
false
;
if
(
mTarget
)
{
CopyToTarget
(
mTarget
mTargetBounds
.
TopLeft
(
)
Matrix
(
)
)
;
mGLContext
-
>
fBindBuffer
(
LOCAL_GL_ARRAY_BUFFER
0
)
;
mCurrentRenderTarget
=
nullptr
;
Compositor
:
:
EndFrame
(
)
;
return
;
}
mCurrentRenderTarget
=
nullptr
;
if
(
mTexturePool
)
{
mTexturePool
-
>
EndFrame
(
)
;
}
mGLContext
-
>
SwapBuffers
(
)
;
mGLContext
-
>
fBindBuffer
(
LOCAL_GL_ARRAY_BUFFER
0
)
;
for
(
GLuint
i
=
0
;
i
<
=
4
;
i
+
+
)
{
mGLContext
-
>
fActiveTexture
(
LOCAL_GL_TEXTURE0
+
i
)
;
mGLContext
-
>
fBindTexture
(
LOCAL_GL_TEXTURE_2D
0
)
;
if
(
!
mGLContext
-
>
IsGLES
(
)
)
{
mGLContext
-
>
fBindTexture
(
LOCAL_GL_TEXTURE_RECTANGLE_ARB
0
)
;
}
}
Compositor
:
:
EndFrame
(
)
;
}
void
CompositorOGL
:
:
SetDestinationSurfaceSize
(
const
IntSize
&
aSize
)
{
mSurfaceSize
.
width
=
aSize
.
width
;
mSurfaceSize
.
height
=
aSize
.
height
;
}
void
CompositorOGL
:
:
CopyToTarget
(
DrawTarget
*
aTarget
const
nsIntPoint
&
aTopLeft
const
gfx
:
:
Matrix
&
aTransform
)
{
MOZ_ASSERT
(
aTarget
)
;
IntRect
rect
;
if
(
mUseExternalSurfaceSize
)
{
rect
=
IntRect
(
0
0
mSurfaceSize
.
width
mSurfaceSize
.
height
)
;
}
else
{
rect
=
IntRect
(
0
0
mWidgetSize
.
width
mWidgetSize
.
height
)
;
}
GLint
width
=
rect
.
Width
(
)
;
GLint
height
=
rect
.
Height
(
)
;
if
(
(
int64_t
(
width
)
*
int64_t
(
height
)
*
int64_t
(
4
)
)
>
INT32_MAX
)
{
NS_ERROR
(
"
Widget
size
too
big
-
integer
overflow
!
"
)
;
return
;
}
mGLContext
-
>
fBindFramebuffer
(
LOCAL_GL_FRAMEBUFFER
0
)
;
if
(
!
mGLContext
-
>
IsGLES
(
)
)
{
mGLContext
-
>
fReadBuffer
(
LOCAL_GL_BACK
)
;
}
RefPtr
<
DataSourceSurface
>
source
=
Factory
:
:
CreateDataSourceSurface
(
rect
.
Size
(
)
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
NS_WARN_IF
(
!
source
)
)
{
return
;
}
ReadPixelsIntoDataSurface
(
mGLContext
source
)
;
Matrix
glToCairoTransform
=
aTransform
;
glToCairoTransform
.
Invert
(
)
;
glToCairoTransform
.
PreScale
(
1
.
0
-
1
.
0
)
;
glToCairoTransform
.
PreTranslate
(
0
.
0
-
height
)
;
glToCairoTransform
.
PostTranslate
(
-
aTopLeft
.
x
-
aTopLeft
.
y
)
;
Matrix
oldMatrix
=
aTarget
-
>
GetTransform
(
)
;
aTarget
-
>
SetTransform
(
glToCairoTransform
)
;
Rect
floatRect
=
Rect
(
rect
.
x
rect
.
y
rect
.
Width
(
)
rect
.
Height
(
)
)
;
aTarget
-
>
DrawSurface
(
source
floatRect
floatRect
DrawSurfaceOptions
(
)
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_SOURCE
)
)
;
aTarget
-
>
SetTransform
(
oldMatrix
)
;
aTarget
-
>
Flush
(
)
;
}
void
CompositorOGL
:
:
Pause
(
)
{
#
ifdef
MOZ_WIDGET_ANDROID
if
(
!
gl
(
)
|
|
gl
(
)
-
>
IsDestroyed
(
)
)
return
;
gl
(
)
-
>
ReleaseSurface
(
)
;
#
endif
}
bool
CompositorOGL
:
:
Resume
(
)
{
#
if
defined
(
MOZ_WIDGET_ANDROID
)
|
|
defined
(
MOZ_WIDGET_UIKIT
)
if
(
!
gl
(
)
|
|
gl
(
)
-
>
IsDestroyed
(
)
)
return
false
;
return
gl
(
)
-
>
RenewSurface
(
GetWidget
(
)
)
;
#
endif
return
true
;
}
already_AddRefed
<
DataTextureSource
>
CompositorOGL
:
:
CreateDataTextureSource
(
TextureFlags
aFlags
)
{
return
MakeAndAddRef
<
TextureImageTextureSourceOGL
>
(
this
aFlags
)
;
}
bool
CompositorOGL
:
:
SupportsPartialTextureUpdate
(
)
{
return
CanUploadSubTextures
(
mGLContext
)
;
}
int32_t
CompositorOGL
:
:
GetMaxTextureSize
(
)
const
{
MOZ_ASSERT
(
mGLContext
)
;
GLint
texSize
=
0
;
mGLContext
-
>
fGetIntegerv
(
LOCAL_GL_MAX_TEXTURE_SIZE
&
texSize
)
;
MOZ_ASSERT
(
texSize
!
=
0
)
;
return
texSize
;
}
void
CompositorOGL
:
:
MakeCurrent
(
MakeCurrentFlags
aFlags
)
{
if
(
mDestroyed
)
{
NS_WARNING
(
"
Call
on
destroyed
layer
manager
"
)
;
return
;
}
mGLContext
-
>
MakeCurrent
(
aFlags
&
ForceMakeCurrent
)
;
}
GLBlitTextureImageHelper
*
CompositorOGL
:
:
BlitTextureImageHelper
(
)
{
if
(
!
mBlitTextureImageHelper
)
{
mBlitTextureImageHelper
=
MakeUnique
<
GLBlitTextureImageHelper
>
(
this
)
;
}
return
mBlitTextureImageHelper
.
get
(
)
;
}
GLuint
CompositorOGL
:
:
GetTemporaryTexture
(
GLenum
aTarget
GLenum
aUnit
)
{
if
(
!
mTexturePool
)
{
mTexturePool
=
new
PerUnitTexturePoolOGL
(
gl
(
)
)
;
}
return
mTexturePool
-
>
GetTexture
(
aTarget
aUnit
)
;
}
GLuint
PerUnitTexturePoolOGL
:
:
GetTexture
(
GLenum
aTarget
GLenum
aTextureUnit
)
{
if
(
mTextureTarget
=
=
0
)
{
mTextureTarget
=
aTarget
;
}
MOZ_ASSERT
(
mTextureTarget
=
=
aTarget
)
;
size_t
index
=
aTextureUnit
-
LOCAL_GL_TEXTURE0
;
if
(
mTextures
.
Length
(
)
<
=
index
)
{
size_t
prevLength
=
mTextures
.
Length
(
)
;
mTextures
.
SetLength
(
index
+
1
)
;
for
(
unsigned
int
i
=
prevLength
;
i
<
=
index
;
+
+
i
)
{
mTextures
[
i
]
=
0
;
}
}
if
(
!
mTextures
[
index
]
)
{
if
(
!
mGL
-
>
MakeCurrent
(
)
)
{
return
0
;
}
mGL
-
>
fGenTextures
(
1
&
mTextures
[
index
]
)
;
mGL
-
>
fBindTexture
(
aTarget
mTextures
[
index
]
)
;
mGL
-
>
fTexParameteri
(
aTarget
LOCAL_GL_TEXTURE_WRAP_S
LOCAL_GL_CLAMP_TO_EDGE
)
;
mGL
-
>
fTexParameteri
(
aTarget
LOCAL_GL_TEXTURE_WRAP_T
LOCAL_GL_CLAMP_TO_EDGE
)
;
}
return
mTextures
[
index
]
;
}
void
PerUnitTexturePoolOGL
:
:
DestroyTextures
(
)
{
if
(
mGL
&
&
mGL
-
>
MakeCurrent
(
)
)
{
if
(
mTextures
.
Length
(
)
>
0
)
{
mGL
-
>
fDeleteTextures
(
mTextures
.
Length
(
)
&
mTextures
[
0
]
)
;
}
}
mTextures
.
SetLength
(
0
)
;
}
bool
CompositorOGL
:
:
SupportsLayerGeometry
(
)
const
{
return
gfxPrefs
:
:
OGLLayerGeometry
(
)
;
}
}
}
