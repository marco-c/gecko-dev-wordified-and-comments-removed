#
ifndef
MOZILLA_GFX_COMPOSITOROGL_H
#
define
MOZILLA_GFX_COMPOSITOROGL_H
#
include
<
map
>
#
include
<
unordered_map
>
#
include
<
unordered_set
>
#
include
"
gfx2DGlue
.
h
"
#
include
"
GLContextTypes
.
h
"
#
include
"
GLDefs
.
h
"
#
include
"
OGLShaderConfig
.
h
"
#
include
"
Units
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
BaseSize
.
h
"
#
include
"
mozilla
/
gfx
/
MatrixFwd
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
Triangle
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
ipc
/
FileDescriptor
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nscore
.
h
"
class
nsIWidget
;
namespace
mozilla
{
namespace
layers
{
class
CompositingRenderTarget
;
class
CompositingRenderTargetOGL
;
class
DataTextureSource
;
class
ShaderProgramOGL
;
class
TextureSource
;
class
TextureSourceOGL
;
class
BufferTextureHost
;
struct
Effect
;
struct
EffectChain
;
class
GLBlitTextureImageHelper
;
class
CompositorTexturePoolOGL
{
protected
:
virtual
~
CompositorTexturePoolOGL
(
)
=
default
;
public
:
NS_INLINE_DECL_REFCOUNTING
(
CompositorTexturePoolOGL
)
virtual
void
Clear
(
)
=
0
;
virtual
GLuint
GetTexture
(
GLenum
aTarget
GLenum
aEnum
)
=
0
;
virtual
void
EndFrame
(
)
=
0
;
}
;
class
PerUnitTexturePoolOGL
:
public
CompositorTexturePoolOGL
{
public
:
explicit
PerUnitTexturePoolOGL
(
gl
:
:
GLContext
*
aGL
)
;
virtual
~
PerUnitTexturePoolOGL
(
)
;
void
Clear
(
)
override
{
DestroyTextures
(
)
;
}
GLuint
GetTexture
(
GLenum
aTarget
GLenum
aUnit
)
override
;
void
EndFrame
(
)
override
{
}
protected
:
void
DestroyTextures
(
)
;
GLenum
mTextureTarget
;
nsTArray
<
GLuint
>
mTextures
;
RefPtr
<
gl
:
:
GLContext
>
mGL
;
}
;
class
CompositorOGL
final
:
public
Compositor
{
typedef
mozilla
:
:
gl
:
:
GLContext
GLContext
;
friend
class
CompositingRenderTargetOGL
;
std
:
:
map
<
ShaderConfigOGL
ShaderProgramOGL
*
>
mPrograms
;
public
:
CompositorOGL
(
CompositorBridgeParent
*
aParent
widget
:
:
CompositorWidget
*
aWidget
int
aSurfaceWidth
=
-
1
int
aSurfaceHeight
=
-
1
bool
aUseExternalSurfaceSize
=
false
)
;
protected
:
virtual
~
CompositorOGL
(
)
;
public
:
CompositorOGL
*
AsCompositorOGL
(
)
override
{
return
this
;
}
already_AddRefed
<
DataTextureSource
>
CreateDataTextureSource
(
TextureFlags
aFlags
=
TextureFlags
:
:
NO_FLAGS
)
override
;
already_AddRefed
<
DataTextureSource
>
CreateDataTextureSourceAroundYCbCr
(
TextureHost
*
aTexture
)
override
;
already_AddRefed
<
DataTextureSource
>
CreateDataTextureSourceAround
(
gfx
:
:
DataSourceSurface
*
aSurface
)
override
;
bool
Initialize
(
GLContext
*
aGLContext
nsCString
*
const
out_failureReason
)
;
bool
Initialize
(
nsCString
*
const
out_failureReason
)
override
;
void
Destroy
(
)
override
;
TextureFactoryIdentifier
GetTextureFactoryIdentifier
(
)
override
{
TextureFactoryIdentifier
result
=
TextureFactoryIdentifier
(
LayersBackend
:
:
LAYERS_OPENGL
XRE_GetProcessType
(
)
GetMaxTextureSize
(
)
SupportsTextureDirectMapping
(
)
false
mFBOTextureTarget
=
=
LOCAL_GL_TEXTURE_2D
SupportsPartialTextureUpdate
(
)
)
;
return
result
;
}
already_AddRefed
<
CompositingRenderTargetOGL
>
RenderTargetForNativeLayer
(
NativeLayer
*
aNativeLayer
const
gfx
:
:
IntRegion
&
aInvalidRegion
)
;
already_AddRefed
<
CompositingRenderTarget
>
CreateRenderTarget
(
const
gfx
:
:
IntRect
&
aRect
SurfaceInitMode
aInit
)
override
;
already_AddRefed
<
CompositingRenderTarget
>
CreateRenderTargetFromSource
(
const
gfx
:
:
IntRect
&
aRect
const
CompositingRenderTarget
*
aSource
const
gfx
:
:
IntPoint
&
aSourcePoint
)
override
;
void
SetRenderTarget
(
CompositingRenderTarget
*
aSurface
)
override
;
already_AddRefed
<
CompositingRenderTarget
>
GetCurrentRenderTarget
(
)
const
override
;
already_AddRefed
<
CompositingRenderTarget
>
GetWindowRenderTarget
(
)
const
override
;
bool
ReadbackRenderTarget
(
CompositingRenderTarget
*
aSource
AsyncReadbackBuffer
*
aDest
)
override
;
already_AddRefed
<
AsyncReadbackBuffer
>
CreateAsyncReadbackBuffer
(
const
gfx
:
:
IntSize
&
aSize
)
override
;
bool
BlitRenderTarget
(
CompositingRenderTarget
*
aSource
const
gfx
:
:
IntSize
&
aSourceSize
const
gfx
:
:
IntSize
&
aDestSize
)
override
;
void
DrawQuad
(
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
IntRect
&
aClipRect
const
EffectChain
&
aEffectChain
gfx
:
:
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfx
:
:
Rect
&
aVisibleRect
)
override
;
void
DrawTriangles
(
const
nsTArray
<
gfx
:
:
TexturedTriangle
>
&
aTriangles
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
IntRect
&
aClipRect
const
EffectChain
&
aEffectChain
gfx
:
:
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfx
:
:
Rect
&
aVisibleRect
)
override
;
bool
SupportsLayerGeometry
(
)
const
override
;
void
NormalDrawingDone
(
)
override
;
void
EndFrame
(
)
override
;
void
WaitForGPU
(
)
override
;
RefPtr
<
SurfacePoolHandle
>
GetSurfacePoolHandle
(
)
override
;
bool
SupportsPartialTextureUpdate
(
)
override
;
bool
CanUseCanvasLayerForSize
(
const
gfx
:
:
IntSize
&
aSize
)
override
{
if
(
!
mGLContext
)
return
false
;
int32_t
maxSize
=
GetMaxTextureSize
(
)
;
return
aSize
<
=
gfx
:
:
IntSize
(
maxSize
maxSize
)
;
}
int32_t
GetMaxTextureSize
(
)
const
override
;
void
SetDestinationSurfaceSize
(
const
gfx
:
:
IntSize
&
aSize
)
override
;
void
MakeCurrent
(
MakeCurrentFlags
aFlags
=
0
)
override
;
#
ifdef
MOZ_DUMP_PAINTING
const
char
*
Name
(
)
const
override
{
return
"
OGL
"
;
}
#
endif
LayersBackend
GetBackendType
(
)
const
override
{
return
LayersBackend
:
:
LAYERS_OPENGL
;
}
void
Pause
(
)
override
;
bool
Resume
(
)
override
;
GLContext
*
gl
(
)
const
{
return
mGLContext
;
}
GLContext
*
GetGLContext
(
)
const
override
{
return
mGLContext
;
}
#
ifdef
XP_DARWIN
void
MaybeUnlockBeforeNextComposition
(
TextureHost
*
aTextureHost
)
override
;
void
TryUnlockTextures
(
)
override
;
#
endif
void
ResetProgram
(
)
;
gfx
:
:
SurfaceFormat
GetFBOFormat
(
)
const
{
return
gfx
:
:
SurfaceFormat
:
:
R8G8B8A8
;
}
GLBlitTextureImageHelper
*
BlitTextureImageHelper
(
)
;
GLuint
GetTemporaryTexture
(
GLenum
aTarget
GLenum
aUnit
)
;
const
gfx
:
:
IntSize
GetDestinationSurfaceSize
(
)
const
{
return
gfx
:
:
IntSize
(
mSurfaceSize
.
width
mSurfaceSize
.
height
)
;
}
void
SetSurfaceOrigin
(
const
ScreenIntPoint
&
aOrigin
)
{
mSurfaceOrigin
=
aOrigin
;
}
void
RegisterTextureSource
(
TextureSource
*
aTextureSource
)
;
void
UnregisterTextureSource
(
TextureSource
*
aTextureSource
)
;
ipc
:
:
FileDescriptor
GetReleaseFence
(
)
;
private
:
template
<
typename
Geometry
>
void
DrawGeometry
(
const
Geometry
&
aGeometry
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
IntRect
&
aClipRect
const
EffectChain
&
aEffectChain
gfx
:
:
Float
aOpacity
const
gfx
:
:
Matrix4x4
&
aTransform
const
gfx
:
:
Rect
&
aVisibleRect
)
;
void
PrepareViewport
(
CompositingRenderTargetOGL
*
aRenderTarget
)
;
bool
SupportsTextureDirectMapping
(
)
;
void
InsertFrameDoneSync
(
)
;
bool
NeedToRecreateFullWindowRenderTarget
(
)
const
;
LayoutDeviceIntSize
mWidgetSize
;
RefPtr
<
GLContext
>
mGLContext
;
bool
mOwnsGLContext
=
true
;
RefPtr
<
SurfacePoolHandle
>
mSurfacePoolHandle
;
UniquePtr
<
GLBlitTextureImageHelper
>
mBlitTextureImageHelper
;
gfx
:
:
Matrix4x4
mProjMatrix
;
bool
mCanRenderToDefaultFramebuffer
=
true
;
#
ifdef
XP_DARWIN
nsTArray
<
RefPtr
<
BufferTextureHost
>
>
mMaybeUnlockBeforeNextComposition
;
#
endif
gfx
:
:
IntSize
mSurfaceSize
;
ScreenIntPoint
mSurfaceOrigin
;
already_AddRefed
<
mozilla
:
:
gl
:
:
GLContext
>
CreateContext
(
)
;
GLenum
mFBOTextureTarget
;
RefPtr
<
CompositingRenderTargetOGL
>
mCurrentRenderTarget
;
RefPtr
<
CompositingRenderTarget
>
mNativeLayersReferenceRT
;
RefPtr
<
CompositingRenderTargetOGL
>
mWindowRenderTarget
;
RefPtr
<
CompositingRenderTargetOGL
>
mFullWindowRenderTarget
;
GLuint
mQuadVBO
;
GLuint
mTriangleVBO
;
GLsync
mPreviousFrameDoneSync
;
GLsync
mThisFrameDoneSync
;
bool
mHasBGRA
;
bool
mUseExternalSurfaceSize
;
bool
mFrameInProgress
;
bool
mShouldInvalidateWindow
=
false
;
void
ClearRect
(
const
gfx
:
:
Rect
&
aRect
)
override
;
Maybe
<
gfx
:
:
IntRect
>
BeginFrameForWindow
(
const
nsIntRegion
&
aInvalidRegion
const
Maybe
<
gfx
:
:
IntRect
>
&
aClipRect
const
gfx
:
:
IntRect
&
aRenderBounds
const
nsIntRegion
&
aOpaqueRegion
)
override
;
Maybe
<
gfx
:
:
IntRect
>
BeginFrameForTarget
(
const
nsIntRegion
&
aInvalidRegion
const
Maybe
<
gfx
:
:
IntRect
>
&
aClipRect
const
gfx
:
:
IntRect
&
aRenderBounds
const
nsIntRegion
&
aOpaqueRegion
gfx
:
:
DrawTarget
*
aTarget
const
gfx
:
:
IntRect
&
aTargetBounds
)
override
;
void
BeginFrameForNativeLayers
(
)
override
;
Maybe
<
gfx
:
:
IntRect
>
BeginRenderingToNativeLayer
(
const
nsIntRegion
&
aInvalidRegion
const
Maybe
<
gfx
:
:
IntRect
>
&
aClipRect
const
nsIntRegion
&
aOpaqueRegion
NativeLayer
*
aNativeLayer
)
override
;
void
EndRenderingToNativeLayer
(
)
override
;
Maybe
<
gfx
:
:
IntRect
>
BeginFrame
(
const
nsIntRegion
&
aInvalidRegion
const
Maybe
<
gfx
:
:
IntRect
>
&
aClipRect
const
gfx
:
:
IntRect
&
aRenderBounds
const
nsIntRegion
&
aOpaqueRegion
)
;
ShaderConfigOGL
GetShaderConfigFor
(
Effect
*
aEffect
TextureSourceOGL
*
aSourceMask
=
nullptr
gfx
:
:
CompositionOp
aOp
=
gfx
:
:
CompositionOp
:
:
OP_OVER
bool
aColorMatrix
=
false
bool
aDEAAEnabled
=
false
)
const
;
ShaderProgramOGL
*
GetShaderProgramFor
(
const
ShaderConfigOGL
&
aConfig
)
;
void
ApplyPrimitiveConfig
(
ShaderConfigOGL
&
aConfig
const
gfx
:
:
Rect
&
)
{
aConfig
.
SetDynamicGeometry
(
false
)
;
}
void
ApplyPrimitiveConfig
(
ShaderConfigOGL
&
aConfig
const
nsTArray
<
gfx
:
:
TexturedTriangle
>
&
)
{
aConfig
.
SetDynamicGeometry
(
true
)
;
}
void
CreateFBOWithTexture
(
const
gfx
:
:
IntRect
&
aRect
bool
aCopyFromSource
GLuint
aSourceFrameBuffer
GLuint
*
aFBO
GLuint
*
aTexture
gfx
:
:
IntSize
*
aAllocSize
=
nullptr
)
;
GLuint
CreateTexture
(
const
gfx
:
:
IntRect
&
aRect
bool
aCopyFromSource
GLuint
aSourceFrameBuffer
gfx
:
:
IntSize
*
aAllocSize
=
nullptr
)
;
gfx
:
:
Point3D
GetLineCoefficients
(
const
gfx
:
:
Point
&
aPoint1
const
gfx
:
:
Point
&
aPoint2
)
;
void
ActivateProgram
(
ShaderProgramOGL
*
aProg
)
;
void
CleanupResources
(
)
;
void
BindAndDrawQuads
(
ShaderProgramOGL
*
aProg
int
aQuads
const
gfx
:
:
Rect
*
aLayerRect
const
gfx
:
:
Rect
*
aTextureRect
)
;
void
BindAndDrawQuad
(
ShaderProgramOGL
*
aProg
const
gfx
:
:
Rect
&
aLayerRect
const
gfx
:
:
Rect
&
aTextureRect
=
gfx
:
:
Rect
(
0
.
0f
0
.
0f
1
.
0f
1
.
0f
)
)
{
gfx
:
:
Rect
layerRects
[
4
]
;
gfx
:
:
Rect
textureRects
[
4
]
;
layerRects
[
0
]
=
aLayerRect
;
textureRects
[
0
]
=
aTextureRect
;
BindAndDrawQuads
(
aProg
1
layerRects
textureRects
)
;
}
void
BindAndDrawGeometry
(
ShaderProgramOGL
*
aProgram
const
gfx
:
:
Rect
&
aRect
)
;
void
BindAndDrawGeometry
(
ShaderProgramOGL
*
aProgram
const
nsTArray
<
gfx
:
:
TexturedTriangle
>
&
aTriangles
)
;
void
BindAndDrawGeometryWithTextureRect
(
ShaderProgramOGL
*
aProg
const
gfx
:
:
Rect
&
aRect
const
gfx
:
:
Rect
&
aTexCoordRect
TextureSource
*
aTexture
)
;
void
BindAndDrawGeometryWithTextureRect
(
ShaderProgramOGL
*
aProg
const
nsTArray
<
gfx
:
:
TexturedTriangle
>
&
aTriangles
const
gfx
:
:
Rect
&
aTexCoordRect
TextureSource
*
aTexture
)
;
void
InitializeVAO
(
const
GLuint
aAttribIndex
const
GLint
aComponents
const
GLsizei
aStride
const
size_t
aOffset
)
;
gfx
:
:
Rect
GetTextureCoordinates
(
gfx
:
:
Rect
textureRect
TextureSource
*
aTexture
)
;
void
BindBackdrop
(
ShaderProgramOGL
*
aProgram
GLuint
aBackdrop
GLenum
aTexUnit
)
;
void
CopyToTarget
(
gfx
:
:
DrawTarget
*
aTarget
const
nsIntPoint
&
aTopLeft
const
gfx
:
:
Matrix
&
aWorldMatrix
)
;
GLint
FlipY
(
GLint
y
)
const
{
return
mViewportSize
.
height
-
y
;
}
RefPtr
<
gfx
:
:
DrawTarget
>
mTarget
;
gfx
:
:
IntRect
mTargetBounds
;
RefPtr
<
CompositorTexturePoolOGL
>
mTexturePool
;
RefPtr
<
NativeLayer
>
mCurrentNativeLayer
;
#
ifdef
MOZ_WIDGET_GTK
std
:
:
unordered_set
<
TextureSource
*
>
mRegisteredTextureSources
;
#
endif
ipc
:
:
FileDescriptor
mReleaseFenceFd
;
bool
mDestroyed
;
gfx
:
:
IntSize
mViewportSize
;
gfx
:
:
IntRegion
mCurrentFrameInvalidRegion
;
ShaderProgramOGL
*
mCurrentProgram
;
}
;
}
}
#
endif
