#
ifndef
MOZILLA_GFX_TEXTUREOGL_H
#
define
MOZILLA_GFX_TEXTUREOGL_H
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
CompositableHost
.
h
"
#
include
"
GLContextTypes
.
h
"
#
include
"
GLDefs
.
h
"
#
include
"
GLTextureImage
.
h
"
#
include
"
gfxTypes
.
h
"
#
include
"
mozilla
/
GfxMessageUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
CompositorOGL
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
webrender
/
RenderThread
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRegionFwd
.
h
"
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
AndroidSurfaceTexture
.
h
"
#
include
"
mozilla
/
java
/
GeckoSurfaceTextureWrappers
.
h
"
#
endif
namespace
mozilla
{
namespace
gfx
{
class
DataSourceSurface
;
}
namespace
layers
{
class
Compositor
;
class
CompositorOGL
;
class
AndroidHardwareBuffer
;
class
SurfaceDescriptorAndroidHardwareBuffer
;
class
TextureImageTextureSourceOGL
;
class
GLTextureSource
;
void
ApplySamplingFilterToBoundTexture
(
gl
:
:
GLContext
*
aGL
gfx
:
:
SamplingFilter
aSamplingFilter
GLuint
aTarget
=
LOCAL_GL_TEXTURE_2D
)
;
already_AddRefed
<
TextureHost
>
CreateTextureHostOGL
(
const
SurfaceDescriptor
&
aDesc
ISurfaceAllocator
*
aDeallocator
LayersBackend
aBackend
TextureFlags
aFlags
)
;
class
TextureSourceOGL
{
public
:
TextureSourceOGL
(
)
:
mCachedSamplingFilter
(
gfx
:
:
SamplingFilter
:
:
GOOD
)
mHasCachedSamplingFilter
(
false
)
{
}
virtual
bool
IsValid
(
)
const
=
0
;
virtual
void
BindTexture
(
GLenum
aTextureUnit
gfx
:
:
SamplingFilter
aSamplingFilter
)
=
0
;
virtual
void
MaybeFenceTexture
(
)
{
}
virtual
gfx
:
:
IntSize
GetSize
(
)
const
=
0
;
virtual
GLenum
GetTextureTarget
(
)
const
{
return
LOCAL_GL_TEXTURE_2D
;
}
virtual
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
=
0
;
virtual
GLenum
GetWrapMode
(
)
const
=
0
;
virtual
gfx
:
:
Matrix4x4
GetTextureTransform
(
)
{
return
gfx
:
:
Matrix4x4
(
)
;
}
virtual
TextureImageTextureSourceOGL
*
AsTextureImageTextureSource
(
)
{
return
nullptr
;
}
virtual
GLTextureSource
*
AsGLTextureSource
(
)
{
return
nullptr
;
}
void
SetSamplingFilter
(
gl
:
:
GLContext
*
aGL
gfx
:
:
SamplingFilter
aSamplingFilter
)
{
if
(
mHasCachedSamplingFilter
&
&
mCachedSamplingFilter
=
=
aSamplingFilter
)
{
return
;
}
mHasCachedSamplingFilter
=
true
;
mCachedSamplingFilter
=
aSamplingFilter
;
ApplySamplingFilterToBoundTexture
(
aGL
aSamplingFilter
GetTextureTarget
(
)
)
;
}
void
ClearCachedFilter
(
)
{
mHasCachedSamplingFilter
=
false
;
}
private
:
gfx
:
:
SamplingFilter
mCachedSamplingFilter
;
bool
mHasCachedSamplingFilter
;
}
;
class
TextureImageTextureSourceOGL
final
:
public
DataTextureSource
public
TextureSourceOGL
public
BigImageIterator
{
public
:
explicit
TextureImageTextureSourceOGL
(
CompositorOGL
*
aCompositor
TextureFlags
aFlags
=
TextureFlags
:
:
DEFAULT
)
;
const
char
*
Name
(
)
const
override
{
return
"
TextureImageTextureSourceOGL
"
;
}
bool
Update
(
gfx
:
:
DataSourceSurface
*
aSurface
nsIntRegion
*
aDestRegion
=
nullptr
gfx
:
:
IntPoint
*
aSrcOffset
=
nullptr
)
override
;
void
EnsureBuffer
(
const
gfx
:
:
IntSize
&
aSize
gfxContentType
aContentType
)
;
TextureImageTextureSourceOGL
*
AsTextureImageTextureSource
(
)
override
{
return
this
;
}
void
DeallocateDeviceData
(
)
override
;
TextureSourceOGL
*
AsSourceOGL
(
)
override
{
return
this
;
}
void
BindTexture
(
GLenum
aTextureUnit
gfx
:
:
SamplingFilter
aSamplingFilter
)
override
;
gfx
:
:
IntSize
GetSize
(
)
const
override
;
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
override
;
bool
IsValid
(
)
const
override
{
return
!
!
mTexImage
;
}
void
SetTextureSourceProvider
(
TextureSourceProvider
*
aProvider
)
override
;
GLenum
GetWrapMode
(
)
const
override
{
return
mTexImage
-
>
GetWrapMode
(
)
;
}
BigImageIterator
*
AsBigImageIterator
(
)
override
{
return
this
;
}
void
BeginBigImageIteration
(
)
override
{
mTexImage
-
>
BeginBigImageIteration
(
)
;
mIterating
=
true
;
}
void
EndBigImageIteration
(
)
override
{
mIterating
=
false
;
}
gfx
:
:
IntRect
GetTileRect
(
)
override
;
size_t
GetTileCount
(
)
override
{
return
mTexImage
-
>
GetTileCount
(
)
;
}
bool
NextTile
(
)
override
{
return
mTexImage
-
>
NextTile
(
)
;
}
protected
:
~
TextureImageTextureSourceOGL
(
)
;
RefPtr
<
gl
:
:
TextureImage
>
mTexImage
;
RefPtr
<
gl
:
:
GLContext
>
mGL
;
RefPtr
<
CompositorOGL
>
mCompositor
;
TextureFlags
mFlags
;
bool
mIterating
;
}
;
class
GLTextureSource
:
public
DataTextureSource
public
TextureSourceOGL
{
public
:
GLTextureSource
(
TextureSourceProvider
*
aProvider
GLuint
aTextureHandle
GLenum
aTarget
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
)
;
virtual
~
GLTextureSource
(
)
;
const
char
*
Name
(
)
const
override
{
return
"
GLTextureSource
"
;
}
GLTextureSource
*
AsGLTextureSource
(
)
override
{
return
this
;
}
TextureSourceOGL
*
AsSourceOGL
(
)
override
{
return
this
;
}
void
BindTexture
(
GLenum
activetex
gfx
:
:
SamplingFilter
aSamplingFilter
)
override
;
bool
IsValid
(
)
const
override
;
gfx
:
:
IntSize
GetSize
(
)
const
override
{
return
mSize
;
}
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
override
{
return
mFormat
;
}
GLenum
GetTextureTarget
(
)
const
override
{
return
mTextureTarget
;
}
GLenum
GetWrapMode
(
)
const
override
{
return
LOCAL_GL_CLAMP_TO_EDGE
;
}
void
DeallocateDeviceData
(
)
override
;
void
SetTextureSourceProvider
(
TextureSourceProvider
*
aProvider
)
override
;
void
SetSize
(
gfx
:
:
IntSize
aSize
)
{
mSize
=
aSize
;
}
void
SetFormat
(
gfx
:
:
SurfaceFormat
aFormat
)
{
mFormat
=
aFormat
;
}
GLuint
GetTextureHandle
(
)
const
{
return
mTextureHandle
;
}
gl
:
:
GLContext
*
gl
(
)
const
{
return
mGL
;
}
bool
Update
(
gfx
:
:
DataSourceSurface
*
aSurface
nsIntRegion
*
aDestRegion
=
nullptr
gfx
:
:
IntPoint
*
aSrcOffset
=
nullptr
)
override
{
return
false
;
}
protected
:
void
DeleteTextureHandle
(
)
;
RefPtr
<
gl
:
:
GLContext
>
mGL
;
RefPtr
<
CompositorOGL
>
mCompositor
;
GLuint
mTextureHandle
;
GLenum
mTextureTarget
;
gfx
:
:
IntSize
mSize
;
gfx
:
:
SurfaceFormat
mFormat
;
}
;
class
DirectMapTextureSource
:
public
GLTextureSource
{
public
:
DirectMapTextureSource
(
TextureSourceProvider
*
aProvider
gfx
:
:
DataSourceSurface
*
aSurface
)
;
~
DirectMapTextureSource
(
)
;
bool
Update
(
gfx
:
:
DataSourceSurface
*
aSurface
nsIntRegion
*
aDestRegion
=
nullptr
gfx
:
:
IntPoint
*
aSrcOffset
=
nullptr
)
override
;
bool
IsDirectMap
(
)
override
{
return
true
;
}
bool
Sync
(
bool
aBlocking
)
override
;
void
MaybeFenceTexture
(
)
override
;
private
:
bool
UpdateInternal
(
gfx
:
:
DataSourceSurface
*
aSurface
nsIntRegion
*
aDestRegion
gfx
:
:
IntPoint
*
aSrcOffset
bool
aInit
)
;
GLsync
mSync
;
}
;
class
GLTextureHost
:
public
TextureHost
{
public
:
GLTextureHost
(
TextureFlags
aFlags
GLuint
aTextureHandle
GLenum
aTarget
GLsync
aSync
gfx
:
:
IntSize
aSize
bool
aHasAlpha
)
;
virtual
~
GLTextureHost
(
)
;
void
DeallocateDeviceData
(
)
override
{
}
void
SetTextureSourceProvider
(
TextureSourceProvider
*
aProvider
)
override
;
bool
Lock
(
)
override
;
void
Unlock
(
)
override
{
}
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
override
;
bool
BindTextureSource
(
CompositableTextureSourceRef
&
aTexture
)
override
{
aTexture
=
mTextureSource
;
return
!
!
aTexture
;
}
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
GetAsSurface
(
)
override
{
return
nullptr
;
}
gl
:
:
GLContext
*
gl
(
)
const
;
gfx
:
:
IntSize
GetSize
(
)
const
override
{
return
mSize
;
}
const
char
*
Name
(
)
override
{
return
"
GLTextureHost
"
;
}
protected
:
const
GLuint
mTexture
;
const
GLenum
mTarget
;
GLsync
mSync
;
const
gfx
:
:
IntSize
mSize
;
const
bool
mHasAlpha
;
RefPtr
<
GLTextureSource
>
mTextureSource
;
}
;
#
ifdef
MOZ_WIDGET_ANDROID
class
SurfaceTextureSource
:
public
TextureSource
public
TextureSourceOGL
{
public
:
SurfaceTextureSource
(
TextureSourceProvider
*
aProvider
java
:
:
GeckoSurfaceTexture
:
:
Ref
&
aSurfTex
gfx
:
:
SurfaceFormat
aFormat
GLenum
aTarget
GLenum
aWrapMode
gfx
:
:
IntSize
aSize
bool
aIgnoreTransform
)
;
const
char
*
Name
(
)
const
override
{
return
"
SurfaceTextureSource
"
;
}
TextureSourceOGL
*
AsSourceOGL
(
)
override
{
return
this
;
}
void
BindTexture
(
GLenum
activetex
gfx
:
:
SamplingFilter
aSamplingFilter
)
override
;
bool
IsValid
(
)
const
override
;
gfx
:
:
IntSize
GetSize
(
)
const
override
{
return
mSize
;
}
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
override
{
return
mFormat
;
}
gfx
:
:
Matrix4x4
GetTextureTransform
(
)
override
;
GLenum
GetTextureTarget
(
)
const
override
{
return
mTextureTarget
;
}
GLenum
GetWrapMode
(
)
const
override
{
return
mWrapMode
;
}
void
DeallocateDeviceData
(
)
override
;
void
SetTextureSourceProvider
(
TextureSourceProvider
*
aProvider
)
override
;
gl
:
:
GLContext
*
gl
(
)
const
{
return
mGL
;
}
protected
:
RefPtr
<
gl
:
:
GLContext
>
mGL
;
mozilla
:
:
java
:
:
GeckoSurfaceTexture
:
:
GlobalRef
mSurfTex
;
const
gfx
:
:
SurfaceFormat
mFormat
;
const
GLenum
mTextureTarget
;
const
GLenum
mWrapMode
;
const
gfx
:
:
IntSize
mSize
;
const
bool
mIgnoreTransform
;
}
;
class
SurfaceTextureHost
:
public
TextureHost
{
public
:
SurfaceTextureHost
(
TextureFlags
aFlags
mozilla
:
:
java
:
:
GeckoSurfaceTexture
:
:
Ref
&
aSurfTex
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
bool
aContinuousUpdate
bool
aIgnoreTransform
)
;
virtual
~
SurfaceTextureHost
(
)
;
void
PrepareTextureSource
(
CompositableTextureSourceRef
&
aTexture
)
override
;
void
DeallocateDeviceData
(
)
override
;
void
SetTextureSourceProvider
(
TextureSourceProvider
*
aProvider
)
override
;
bool
Lock
(
)
override
;
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
override
;
void
NotifyNotUsed
(
)
override
;
bool
BindTextureSource
(
CompositableTextureSourceRef
&
aTexture
)
override
{
aTexture
=
mTextureSource
;
return
!
!
aTexture
;
}
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
GetAsSurface
(
)
override
{
return
nullptr
;
}
gl
:
:
GLContext
*
gl
(
)
const
;
gfx
:
:
IntSize
GetSize
(
)
const
override
{
return
mSize
;
}
const
char
*
Name
(
)
override
{
return
"
SurfaceTextureHost
"
;
}
SurfaceTextureHost
*
AsSurfaceTextureHost
(
)
override
{
return
this
;
}
void
CreateRenderTexture
(
const
wr
:
:
ExternalImageId
&
aExternalImageId
)
override
;
uint32_t
NumSubTextures
(
)
override
;
void
PushResourceUpdates
(
wr
:
:
TransactionBuilder
&
aResources
ResourceUpdateOp
aOp
const
Range
<
wr
:
:
ImageKey
>
&
aImageKeys
const
wr
:
:
ExternalImageId
&
aExtID
)
override
;
void
PushDisplayItems
(
wr
:
:
DisplayListBuilder
&
aBuilder
const
wr
:
:
LayoutRect
&
aBounds
const
wr
:
:
LayoutRect
&
aClip
wr
:
:
ImageRendering
aFilter
const
Range
<
wr
:
:
ImageKey
>
&
aImageKeys
const
bool
aPreferCompositorSurface
)
override
;
protected
:
bool
EnsureAttached
(
)
;
mozilla
:
:
java
:
:
GeckoSurfaceTexture
:
:
GlobalRef
mSurfTex
;
const
gfx
:
:
IntSize
mSize
;
const
gfx
:
:
SurfaceFormat
mFormat
;
bool
mContinuousUpdate
;
const
bool
mIgnoreTransform
;
RefPtr
<
CompositorOGL
>
mCompositor
;
RefPtr
<
SurfaceTextureSource
>
mTextureSource
;
}
;
class
AndroidHardwareBufferTextureHost
:
public
TextureHost
{
public
:
static
already_AddRefed
<
AndroidHardwareBufferTextureHost
>
Create
(
TextureFlags
aFlags
const
SurfaceDescriptorAndroidHardwareBuffer
&
aDesc
)
;
AndroidHardwareBufferTextureHost
(
TextureFlags
aFlags
AndroidHardwareBuffer
*
aAndroidHardwareBuffer
)
;
virtual
~
AndroidHardwareBufferTextureHost
(
)
;
void
PrepareTextureSource
(
CompositableTextureSourceRef
&
aTextureSource
)
override
;
bool
BindTextureSource
(
CompositableTextureSourceRef
&
aTexture
)
override
;
void
DeallocateDeviceData
(
)
override
;
void
SetTextureSourceProvider
(
TextureSourceProvider
*
aProvider
)
override
;
bool
Lock
(
)
override
;
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
override
;
gfx
:
:
IntSize
GetSize
(
)
const
override
;
void
NotifyNotUsed
(
)
override
;
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
GetAsSurface
(
)
override
{
return
nullptr
;
}
gl
:
:
GLContext
*
gl
(
)
const
;
const
char
*
Name
(
)
override
{
return
"
AndroidHardwareBufferTextureHost
"
;
}
protected
:
void
DestroyEGLImage
(
)
;
RefPtr
<
AndroidHardwareBuffer
>
mAndroidHardwareBuffer
;
RefPtr
<
GLTextureSource
>
mTextureSource
;
EGLImage
mEGLImage
;
}
;
#
endif
class
EGLImageTextureSource
:
public
TextureSource
public
TextureSourceOGL
{
public
:
EGLImageTextureSource
(
TextureSourceProvider
*
aProvider
EGLImage
aImage
gfx
:
:
SurfaceFormat
aFormat
GLenum
aTarget
GLenum
aWrapMode
gfx
:
:
IntSize
aSize
)
;
const
char
*
Name
(
)
const
override
{
return
"
EGLImageTextureSource
"
;
}
TextureSourceOGL
*
AsSourceOGL
(
)
override
{
return
this
;
}
void
BindTexture
(
GLenum
activetex
gfx
:
:
SamplingFilter
aSamplingFilter
)
override
;
bool
IsValid
(
)
const
override
;
gfx
:
:
IntSize
GetSize
(
)
const
override
{
return
mSize
;
}
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
override
{
return
mFormat
;
}
gfx
:
:
Matrix4x4
GetTextureTransform
(
)
override
;
GLenum
GetTextureTarget
(
)
const
override
{
return
mTextureTarget
;
}
GLenum
GetWrapMode
(
)
const
override
{
return
mWrapMode
;
}
void
DeallocateDeviceData
(
)
override
{
}
void
SetTextureSourceProvider
(
TextureSourceProvider
*
aProvider
)
override
;
gl
:
:
GLContext
*
gl
(
)
const
{
return
mGL
;
}
protected
:
RefPtr
<
gl
:
:
GLContext
>
mGL
;
RefPtr
<
CompositorOGL
>
mCompositor
;
const
EGLImage
mImage
;
const
gfx
:
:
SurfaceFormat
mFormat
;
const
GLenum
mTextureTarget
;
const
GLenum
mWrapMode
;
const
gfx
:
:
IntSize
mSize
;
}
;
class
EGLImageTextureHost
final
:
public
TextureHost
{
public
:
EGLImageTextureHost
(
TextureFlags
aFlags
EGLImage
aImage
EGLSync
aSync
gfx
:
:
IntSize
aSize
bool
hasAlpha
)
;
virtual
~
EGLImageTextureHost
(
)
;
void
DeallocateDeviceData
(
)
override
{
}
void
SetTextureSourceProvider
(
TextureSourceProvider
*
aProvider
)
override
;
bool
Lock
(
)
override
;
void
Unlock
(
)
override
;
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
override
;
bool
BindTextureSource
(
CompositableTextureSourceRef
&
aTexture
)
override
{
aTexture
=
mTextureSource
;
return
!
!
aTexture
;
}
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
GetAsSurface
(
)
override
{
return
nullptr
;
}
gl
:
:
GLContext
*
gl
(
)
const
;
gfx
:
:
IntSize
GetSize
(
)
const
override
{
return
mSize
;
}
const
char
*
Name
(
)
override
{
return
"
EGLImageTextureHost
"
;
}
void
CreateRenderTexture
(
const
wr
:
:
ExternalImageId
&
aExternalImageId
)
override
;
void
PushResourceUpdates
(
wr
:
:
TransactionBuilder
&
aResources
ResourceUpdateOp
aOp
const
Range
<
wr
:
:
ImageKey
>
&
aImageKeys
const
wr
:
:
ExternalImageId
&
aExtID
)
override
;
void
PushDisplayItems
(
wr
:
:
DisplayListBuilder
&
aBuilder
const
wr
:
:
LayoutRect
&
aBounds
const
wr
:
:
LayoutRect
&
aClip
wr
:
:
ImageRendering
aFilter
const
Range
<
wr
:
:
ImageKey
>
&
aImageKeys
const
bool
aPreferCompositorSurface
)
override
;
protected
:
const
EGLImage
mImage
;
const
EGLSync
mSync
;
const
gfx
:
:
IntSize
mSize
;
const
bool
mHasAlpha
;
RefPtr
<
EGLImageTextureSource
>
mTextureSource
;
}
;
}
}
#
endif
