#
include
"
Layers
.
h
"
#
include
<
inttypes
.
h
>
#
include
<
stdio
.
h
>
#
include
<
algorithm
>
#
include
<
list
>
#
include
<
set
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
"
CompositableHost
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
LayerUserData
.
h
"
#
include
"
ReadbackLayer
.
h
"
#
include
"
TreeTraversal
.
h
"
#
include
"
UnitTransforms
.
h
"
#
include
"
apz
/
src
/
AsyncPanZoomController
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxEnv
.
h
"
#
include
"
gfxMatrix
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
ArrayIterator
.
h
"
#
include
"
mozilla
/
BaseProfilerMarkersPrerequisites
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
ScrollPositionUpdate
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TelemetryHistogramEnums
.
h
"
#
include
"
mozilla
/
ToString
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
BasePoint3D
.
h
"
#
include
"
mozilla
/
gfx
/
BaseRect
.
h
"
#
include
"
mozilla
/
gfx
/
BaseSize
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
mozilla
/
gfx
/
MatrixFwd
.
h
"
#
include
"
mozilla
/
gfx
/
Polygon
.
h
"
#
include
"
mozilla
/
layers
/
BSPTree
.
h
"
#
include
"
mozilla
/
layers
/
CompositableClient
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
nsBaseHashtable
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsRegionFwd
.
h
"
#
include
"
nsString
.
h
"
#
undef
compress
#
include
"
mozilla
/
Compression
.
h
"
namespace
mozilla
{
namespace
layers
{
typedef
ScrollableLayerGuid
:
:
ViewID
ViewID
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
Compression
;
#
ifdef
MOZ_DUMP_PAINTING
template
<
typename
T
>
void
WriteSnapshotToDumpFile_internal
(
T
*
aObj
DataSourceSurface
*
aSurf
)
{
nsCString
string
(
aObj
-
>
Name
(
)
)
;
string
.
Append
(
'
-
'
)
;
string
.
AppendInt
(
(
uint64_t
)
aObj
)
;
if
(
gfxUtils
:
:
sDumpPaintFile
!
=
stderr
)
{
fprintf_stderr
(
gfxUtils
:
:
sDumpPaintFile
R
"
(
array
[
"
%
s
"
]
=
"
)
"
string
.
BeginReading
(
)
)
;
}
gfxUtils
:
:
DumpAsDataURI
(
aSurf
gfxUtils
:
:
sDumpPaintFile
)
;
if
(
gfxUtils
:
:
sDumpPaintFile
!
=
stderr
)
{
fprintf_stderr
(
gfxUtils
:
:
sDumpPaintFile
R
"
(
"
;
)
"
)
;
}
}
void
WriteSnapshotToDumpFile
(
LayerManager
*
aManager
DataSourceSurface
*
aSurf
)
{
WriteSnapshotToDumpFile_internal
(
aManager
aSurf
)
;
}
void
WriteSnapshotToDumpFile
(
Compositor
*
aCompositor
DrawTarget
*
aTarget
)
{
RefPtr
<
SourceSurface
>
surf
=
aTarget
-
>
Snapshot
(
)
;
RefPtr
<
DataSourceSurface
>
dSurf
=
surf
-
>
GetDataSurface
(
)
;
WriteSnapshotToDumpFile_internal
(
aCompositor
dSurf
)
;
}
#
endif
void
LayerManager
:
:
Log
(
const
char
*
aPrefix
)
{
if
(
!
IsLogEnabled
(
)
)
return
;
LogSelf
(
aPrefix
)
;
nsAutoCString
pfx
(
aPrefix
)
;
pfx
+
=
"
"
;
if
(
!
GetRoot
(
)
)
{
MOZ_LAYERS_LOG
(
(
"
%
s
(
null
)
"
pfx
.
get
(
)
)
)
;
return
;
}
}
void
LayerManager
:
:
LogSelf
(
const
char
*
aPrefix
)
{
nsAutoCString
str
;
std
:
:
stringstream
ss
;
PrintInfo
(
ss
aPrefix
)
;
MOZ_LAYERS_LOG
(
(
"
%
s
"
ss
.
str
(
)
.
c_str
(
)
)
)
;
}
void
LayerManager
:
:
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
{
aStream
<
<
aPrefix
<
<
nsPrintfCString
(
"
%
sLayerManager
(
0x
%
p
)
"
Name
(
)
this
)
.
get
(
)
;
}
bool
LayerManager
:
:
IsLogEnabled
(
)
{
return
MOZ_LOG_TEST
(
GetLog
(
)
LogLevel
:
:
Debug
)
;
}
bool
LayerManager
:
:
AddPendingScrollUpdateForNextTransaction
(
ScrollableLayerGuid
:
:
ViewID
aScrollId
const
ScrollPositionUpdate
&
aUpdateInfo
)
{
return
true
;
}
Maybe
<
nsTArray
<
ScrollPositionUpdate
>
>
LayerManager
:
:
GetPendingScrollInfoUpdate
(
ScrollableLayerGuid
:
:
ViewID
aScrollId
)
{
auto
p
=
mPendingScrollUpdates
.
Lookup
(
aScrollId
)
;
if
(
!
p
)
{
return
Nothing
(
)
;
}
nsTArray
<
ScrollPositionUpdate
>
copy
;
copy
.
AppendElements
(
p
.
Data
(
)
)
;
return
Some
(
std
:
:
move
(
copy
)
)
;
}
std
:
:
unordered_set
<
ScrollableLayerGuid
:
:
ViewID
>
LayerManager
:
:
ClearPendingScrollInfoUpdate
(
)
{
std
:
:
unordered_set
<
ScrollableLayerGuid
:
:
ViewID
>
scrollIds
(
mPendingScrollUpdates
.
Keys
(
)
.
cbegin
(
)
mPendingScrollUpdates
.
Keys
(
)
.
cend
(
)
)
;
mPendingScrollUpdates
.
Clear
(
)
;
return
scrollIds
;
}
void
SetAntialiasingFlags
(
Layer
*
aLayer
DrawTarget
*
aTarget
)
{
}
IntRect
ToOutsideIntRect
(
const
gfxRect
&
aRect
)
{
return
IntRect
:
:
RoundOut
(
aRect
.
X
(
)
aRect
.
Y
(
)
aRect
.
Width
(
)
aRect
.
Height
(
)
)
;
}
void
RecordCompositionPayloadsPresented
(
const
TimeStamp
&
aCompositionEndTime
const
nsTArray
<
CompositionPayload
>
&
aPayloads
)
{
if
(
aPayloads
.
Length
(
)
)
{
TimeStamp
presented
=
aCompositionEndTime
;
for
(
const
CompositionPayload
&
payload
:
aPayloads
)
{
if
(
profiler_can_accept_markers
(
)
)
{
MOZ_RELEASE_ASSERT
(
payload
.
mType
<
=
kHighestCompositionPayloadType
)
;
nsAutoCString
name
(
kCompositionPayloadTypeNames
[
uint8_t
(
payload
.
mType
)
]
)
;
name
.
AppendLiteral
(
"
Payload
Presented
"
)
;
nsPrintfCString
text
(
"
Latency
:
%
dms
"
int32_t
(
(
presented
-
payload
.
mTimeStamp
)
.
ToMilliseconds
(
)
)
)
;
PROFILER_MARKER_TEXT
(
name
GRAPHICS
MarkerTiming
:
:
Interval
(
payload
.
mTimeStamp
presented
)
text
)
;
}
if
(
payload
.
mType
=
=
CompositionPayloadType
:
:
eKeyPress
)
{
Telemetry
:
:
AccumulateTimeDelta
(
mozilla
:
:
Telemetry
:
:
KEYPRESS_PRESENT_LATENCY
payload
.
mTimeStamp
presented
)
;
}
else
if
(
payload
.
mType
=
=
CompositionPayloadType
:
:
eAPZScroll
)
{
Telemetry
:
:
AccumulateTimeDelta
(
mozilla
:
:
Telemetry
:
:
SCROLL_PRESENT_LATENCY
payload
.
mTimeStamp
presented
)
;
}
else
if
(
payload
.
mType
=
=
CompositionPayloadType
:
:
eMouseUpFollowedByClick
)
{
Telemetry
:
:
AccumulateTimeDelta
(
mozilla
:
:
Telemetry
:
:
MOUSEUP_FOLLOWED_BY_CLICK_PRESENT_LATENCY
payload
.
mTimeStamp
presented
)
;
}
}
}
}
}
}
