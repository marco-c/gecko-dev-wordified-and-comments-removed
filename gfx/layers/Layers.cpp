#
include
"
Layers
.
h
"
#
include
<
inttypes
.
h
>
#
include
<
stdio
.
h
>
#
include
<
algorithm
>
#
include
<
list
>
#
include
<
set
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
"
CompositableHost
.
h
"
#
include
"
LayerUserData
.
h
"
#
include
"
TreeTraversal
.
h
"
#
include
"
UnitTransforms
.
h
"
#
include
"
apz
/
src
/
AsyncPanZoomController
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxEnv
.
h
"
#
include
"
gfxMatrix
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
ArrayIterator
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
mozilla
/
ScrollPositionUpdate
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TelemetryHistogramEnums
.
h
"
#
include
"
mozilla
/
ToString
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
BasePoint3D
.
h
"
#
include
"
mozilla
/
gfx
/
BaseRect
.
h
"
#
include
"
mozilla
/
gfx
/
BaseSize
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
mozilla
/
gfx
/
MatrixFwd
.
h
"
#
include
"
mozilla
/
gfx
/
Polygon
.
h
"
#
include
"
mozilla
/
layers
/
BSPTree
.
h
"
#
include
"
mozilla
/
layers
/
CompositableClient
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
nsBaseHashtable
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsRegionFwd
.
h
"
#
include
"
nsString
.
h
"
#
undef
compress
#
include
"
mozilla
/
Compression
.
h
"
namespace
mozilla
{
namespace
layers
{
typedef
ScrollableLayerGuid
:
:
ViewID
ViewID
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
Compression
;
#
ifdef
MOZ_DUMP_PAINTING
template
<
typename
T
>
void
WriteSnapshotToDumpFile_internal
(
T
*
aObj
DataSourceSurface
*
aSurf
)
{
nsCString
string
(
aObj
-
>
Name
(
)
)
;
string
.
Append
(
'
-
'
)
;
string
.
AppendInt
(
(
uint64_t
)
aObj
)
;
if
(
gfxUtils
:
:
sDumpPaintFile
!
=
stderr
)
{
fprintf_stderr
(
gfxUtils
:
:
sDumpPaintFile
R
"
(
array
[
"
%
s
"
]
=
"
)
"
string
.
BeginReading
(
)
)
;
}
gfxUtils
:
:
DumpAsDataURI
(
aSurf
gfxUtils
:
:
sDumpPaintFile
)
;
if
(
gfxUtils
:
:
sDumpPaintFile
!
=
stderr
)
{
fprintf_stderr
(
gfxUtils
:
:
sDumpPaintFile
R
"
(
"
;
)
"
)
;
}
}
void
WriteSnapshotToDumpFile
(
Compositor
*
aCompositor
DrawTarget
*
aTarget
)
{
RefPtr
<
SourceSurface
>
surf
=
aTarget
-
>
Snapshot
(
)
;
RefPtr
<
DataSourceSurface
>
dSurf
=
surf
-
>
GetDataSurface
(
)
;
WriteSnapshotToDumpFile_internal
(
aCompositor
dSurf
)
;
}
#
endif
IntRect
ToOutsideIntRect
(
const
gfxRect
&
aRect
)
{
return
IntRect
:
:
RoundOut
(
aRect
.
X
(
)
aRect
.
Y
(
)
aRect
.
Width
(
)
aRect
.
Height
(
)
)
;
}
void
RecordCompositionPayloadsPresented
(
const
TimeStamp
&
aCompositionEndTime
const
nsTArray
<
CompositionPayload
>
&
aPayloads
)
{
if
(
aPayloads
.
Length
(
)
)
{
TimeStamp
presented
=
aCompositionEndTime
;
for
(
const
CompositionPayload
&
payload
:
aPayloads
)
{
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
MOZ_RELEASE_ASSERT
(
payload
.
mType
<
=
kHighestCompositionPayloadType
)
;
nsAutoCString
name
(
kCompositionPayloadTypeNames
[
uint8_t
(
payload
.
mType
)
]
)
;
name
.
AppendLiteral
(
"
Payload
Presented
"
)
;
nsPrintfCString
text
(
"
Latency
:
%
dms
"
int32_t
(
(
presented
-
payload
.
mTimeStamp
)
.
ToMilliseconds
(
)
)
)
;
PROFILER_MARKER_TEXT
(
name
GRAPHICS
MarkerTiming
:
:
Interval
(
payload
.
mTimeStamp
presented
)
text
)
;
}
if
(
payload
.
mType
=
=
CompositionPayloadType
:
:
eKeyPress
)
{
Telemetry
:
:
AccumulateTimeDelta
(
mozilla
:
:
Telemetry
:
:
KEYPRESS_PRESENT_LATENCY
payload
.
mTimeStamp
presented
)
;
}
else
if
(
payload
.
mType
=
=
CompositionPayloadType
:
:
eAPZScroll
)
{
Telemetry
:
:
AccumulateTimeDelta
(
mozilla
:
:
Telemetry
:
:
SCROLL_PRESENT_LATENCY
payload
.
mTimeStamp
presented
)
;
}
else
if
(
payload
.
mType
=
=
CompositionPayloadType
:
:
eMouseUpFollowedByClick
)
{
Telemetry
:
:
AccumulateTimeDelta
(
mozilla
:
:
Telemetry
:
:
MOUSEUP_FOLLOWED_BY_CLICK_PRESENT_LATENCY
payload
.
mTimeStamp
presented
)
;
}
}
}
}
}
}
