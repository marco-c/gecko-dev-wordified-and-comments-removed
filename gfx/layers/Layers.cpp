#
include
"
Layers
.
h
"
#
include
<
algorithm
>
#
include
"
apz
/
src
/
AsyncPanZoomController
.
h
"
#
include
"
CompositableHost
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
ImageLayers
.
h
"
#
include
"
LayerSorter
.
h
"
#
include
"
LayersLogging
.
h
"
#
include
"
LayerUserData
.
h
"
#
include
"
ReadbackLayer
.
h
"
#
include
"
UnitTransforms
.
h
"
#
include
"
gfxEnv
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
ToString
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
BaseSize
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
mozilla
/
gfx
/
Polygon
.
h
"
#
include
"
mozilla
/
layers
/
AsyncCanvasRenderer
.
h
"
#
include
"
mozilla
/
layers
/
BSPTree
.
h
"
#
include
"
mozilla
/
layers
/
CompositableClient
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
LayerManagerComposite
.
h
"
#
include
"
mozilla
/
layers
/
LayerMetricsWrapper
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
PersistentBufferProvider
.
h
"
#
include
"
mozilla
/
layers
/
ShadowLayers
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCSSValue
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
protobuf
/
LayerScopePacket
.
pb
.
h
"
#
include
"
mozilla
/
Compression
.
h
"
#
include
"
TreeTraversal
.
h
"
#
include
<
list
>
#
include
<
set
>
uint8_t
gLayerManagerLayerBuilder
;
namespace
mozilla
{
namespace
layers
{
FILE
*
FILEOrDefault
(
FILE
*
aFile
)
{
return
aFile
?
aFile
:
stderr
;
}
typedef
FrameMetrics
:
:
ViewID
ViewID
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
Compression
;
mozilla
:
:
LogModule
*
LayerManager
:
:
GetLog
(
)
{
static
LazyLogModule
sLog
(
"
Layers
"
)
;
return
sLog
;
}
FrameMetrics
:
:
ViewID
LayerManager
:
:
GetRootScrollableLayerId
(
)
{
if
(
!
mRoot
)
{
return
FrameMetrics
:
:
NULL_SCROLL_ID
;
}
LayerMetricsWrapper
layerMetricsRoot
=
LayerMetricsWrapper
(
mRoot
)
;
LayerMetricsWrapper
rootScrollableLayerMetrics
=
BreadthFirstSearch
<
ForwardIterator
>
(
layerMetricsRoot
[
]
(
LayerMetricsWrapper
aLayerMetrics
)
{
return
aLayerMetrics
.
Metrics
(
)
.
IsScrollable
(
)
;
}
)
;
return
rootScrollableLayerMetrics
.
IsValid
(
)
?
rootScrollableLayerMetrics
.
Metrics
(
)
.
GetScrollId
(
)
:
FrameMetrics
:
:
NULL_SCROLL_ID
;
}
LayerMetricsWrapper
LayerManager
:
:
GetRootContentLayer
(
)
{
if
(
!
mRoot
)
{
return
LayerMetricsWrapper
(
)
;
}
LayerMetricsWrapper
root
(
mRoot
)
;
return
BreadthFirstSearch
<
ForwardIterator
>
(
root
[
]
(
LayerMetricsWrapper
aLayerMetrics
)
{
return
aLayerMetrics
.
Metrics
(
)
.
IsRootContent
(
)
;
}
)
;
}
already_AddRefed
<
DrawTarget
>
LayerManager
:
:
CreateOptimalDrawTarget
(
const
gfx
:
:
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
return
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateOffscreenContentDrawTarget
(
aSize
aFormat
)
;
}
already_AddRefed
<
DrawTarget
>
LayerManager
:
:
CreateOptimalMaskDrawTarget
(
const
gfx
:
:
IntSize
&
aSize
)
{
return
CreateOptimalDrawTarget
(
aSize
SurfaceFormat
:
:
A8
)
;
}
already_AddRefed
<
DrawTarget
>
LayerManager
:
:
CreateDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
return
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateOffscreenCanvasDrawTarget
(
aSize
aFormat
)
;
}
already_AddRefed
<
PersistentBufferProvider
>
LayerManager
:
:
CreatePersistentBufferProvider
(
const
mozilla
:
:
gfx
:
:
IntSize
&
aSize
mozilla
:
:
gfx
:
:
SurfaceFormat
aFormat
)
{
RefPtr
<
PersistentBufferProviderBasic
>
bufferProvider
=
PersistentBufferProviderBasic
:
:
Create
(
aSize
aFormat
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetPreferredCanvasBackend
(
)
)
;
if
(
!
bufferProvider
)
{
bufferProvider
=
PersistentBufferProviderBasic
:
:
Create
(
aSize
aFormat
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetFallbackCanvasBackend
(
)
)
;
}
return
bufferProvider
.
forget
(
)
;
}
already_AddRefed
<
ImageContainer
>
LayerManager
:
:
CreateImageContainer
(
ImageContainer
:
:
Mode
flag
)
{
RefPtr
<
ImageContainer
>
container
=
new
ImageContainer
(
flag
)
;
return
container
.
forget
(
)
;
}
bool
LayerManager
:
:
AreComponentAlphaLayersEnabled
(
)
{
return
gfxPrefs
:
:
ComponentAlphaEnabled
(
)
;
}
void
LayerManager
:
:
LayerUserDataDestroy
(
void
*
data
)
{
delete
static_cast
<
LayerUserData
*
>
(
data
)
;
}
UniquePtr
<
LayerUserData
>
LayerManager
:
:
RemoveUserData
(
void
*
aKey
)
{
UniquePtr
<
LayerUserData
>
d
(
static_cast
<
LayerUserData
*
>
(
mUserData
.
Remove
(
static_cast
<
gfx
:
:
UserDataKey
*
>
(
aKey
)
)
)
)
;
return
d
;
}
Layer
:
:
Layer
(
LayerManager
*
aManager
void
*
aImplData
)
:
mManager
(
aManager
)
mParent
(
nullptr
)
mNextSibling
(
nullptr
)
mPrevSibling
(
nullptr
)
mImplData
(
aImplData
)
mAnimationInfo
(
aManager
)
mUseTileSourceRect
(
false
)
#
ifdef
DEBUG
mDebugColorIndex
(
0
)
#
endif
{
}
Layer
:
:
~
Layer
(
)
{
}
void
Layer
:
:
SetCompositorAnimations
(
const
CompositorAnimations
&
aCompositorAnimations
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
SetCompositorAnimations
with
id
=
%
"
PRIu64
this
mAnimationInfo
.
GetCompositorAnimationsId
(
)
)
)
;
mAnimationInfo
.
SetCompositorAnimations
(
aCompositorAnimations
)
;
Mutated
(
)
;
}
void
Layer
:
:
ClearCompositorAnimations
(
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
ClearCompositorAnimations
with
id
=
%
"
PRIu64
this
mAnimationInfo
.
GetCompositorAnimationsId
(
)
)
)
;
mAnimationInfo
.
ClearAnimations
(
)
;
Mutated
(
)
;
}
void
Layer
:
:
StartPendingAnimations
(
const
TimeStamp
&
aReadyTime
)
{
ForEachNode
<
ForwardIterator
>
(
this
[
&
aReadyTime
]
(
Layer
*
layer
)
{
if
(
layer
-
>
mAnimationInfo
.
StartPendingAnimations
(
aReadyTime
)
)
{
layer
-
>
Mutated
(
)
;
}
}
)
;
}
void
Layer
:
:
SetAsyncPanZoomController
(
uint32_t
aIndex
AsyncPanZoomController
*
controller
)
{
MOZ_ASSERT
(
aIndex
<
GetScrollMetadataCount
(
)
)
;
MOZ_ASSERT
(
!
controller
|
|
GetFrameMetrics
(
aIndex
)
.
IsScrollable
(
)
)
;
mApzcs
[
aIndex
]
=
controller
;
}
AsyncPanZoomController
*
Layer
:
:
GetAsyncPanZoomController
(
uint32_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
GetScrollMetadataCount
(
)
)
;
#
ifdef
DEBUG
if
(
mApzcs
[
aIndex
]
)
{
MOZ_ASSERT
(
GetFrameMetrics
(
aIndex
)
.
IsScrollable
(
)
)
;
}
#
endif
return
mApzcs
[
aIndex
]
;
}
void
Layer
:
:
ScrollMetadataChanged
(
)
{
mApzcs
.
SetLength
(
GetScrollMetadataCount
(
)
)
;
}
void
Layer
:
:
ApplyPendingUpdatesToSubtree
(
)
{
ForEachNode
<
ForwardIterator
>
(
this
[
]
(
Layer
*
layer
)
{
layer
-
>
ApplyPendingUpdatesForThisTransaction
(
)
;
}
)
;
Manager
(
)
-
>
ClearPendingScrollInfoUpdate
(
)
;
}
bool
Layer
:
:
IsOpaqueForVisibility
(
)
{
return
GetEffectiveOpacity
(
)
=
=
1
.
0f
&
&
GetEffectiveMixBlendMode
(
)
=
=
CompositionOp
:
:
OP_OVER
;
}
bool
Layer
:
:
CanUseOpaqueSurface
(
)
{
if
(
GetContentFlags
(
)
&
CONTENT_OPAQUE
)
return
true
;
ContainerLayer
*
parent
=
GetParent
(
)
;
return
parent
&
&
parent
-
>
GetFirstChild
(
)
=
=
this
&
&
parent
-
>
CanUseOpaqueSurface
(
)
;
}
const
Maybe
<
ParentLayerIntRect
>
&
Layer
:
:
GetLocalClipRect
(
)
{
if
(
HostLayer
*
shadow
=
AsHostLayer
(
)
)
{
return
shadow
-
>
GetShadowClipRect
(
)
;
}
return
GetClipRect
(
)
;
}
const
LayerIntRegion
&
Layer
:
:
GetLocalVisibleRegion
(
)
{
if
(
HostLayer
*
shadow
=
AsHostLayer
(
)
)
{
return
shadow
-
>
GetShadowVisibleRegion
(
)
;
}
return
GetVisibleRegion
(
)
;
}
Matrix4x4
Layer
:
:
SnapTransformTranslation
(
const
Matrix4x4
&
aTransform
Matrix
*
aResidualTransform
)
{
if
(
aResidualTransform
)
{
*
aResidualTransform
=
Matrix
(
)
;
}
if
(
!
mManager
-
>
IsSnappingEffectiveTransforms
(
)
)
{
return
aTransform
;
}
Matrix
matrix2D
;
if
(
aTransform
.
CanDraw2D
(
&
matrix2D
)
&
&
!
matrix2D
.
HasNonTranslation
(
)
&
&
matrix2D
.
HasNonIntegerTranslation
(
)
)
{
auto
snappedTranslation
=
IntPoint
:
:
Round
(
matrix2D
.
GetTranslation
(
)
)
;
Matrix
snappedMatrix
=
Matrix
:
:
Translation
(
snappedTranslation
.
x
snappedTranslation
.
y
)
;
Matrix4x4
result
=
Matrix4x4
:
:
From2D
(
snappedMatrix
)
;
if
(
aResidualTransform
)
{
*
aResidualTransform
=
Matrix
:
:
Translation
(
matrix2D
.
_31
-
snappedTranslation
.
x
matrix2D
.
_32
-
snappedTranslation
.
y
)
;
}
return
result
;
}
return
SnapTransformTranslation3D
(
aTransform
aResidualTransform
)
;
}
Matrix4x4
Layer
:
:
SnapTransformTranslation3D
(
const
Matrix4x4
&
aTransform
Matrix
*
aResidualTransform
)
{
if
(
aTransform
.
IsSingular
(
)
|
|
aTransform
.
HasPerspectiveComponent
(
)
|
|
aTransform
.
HasNonTranslation
(
)
|
|
!
aTransform
.
HasNonIntegerTranslation
(
)
)
{
return
aTransform
;
}
Point3D
transformedOrigin
=
aTransform
.
TransformPoint
(
Point3D
(
)
)
;
auto
transformedSnapXY
=
IntPoint
:
:
Round
(
transformedOrigin
.
x
transformedOrigin
.
y
)
;
Matrix4x4
inverse
=
aTransform
;
inverse
.
Invert
(
)
;
Float
transformedSnapZ
=
inverse
.
_33
=
=
0
?
0
:
(
-
(
transformedSnapXY
.
x
*
inverse
.
_13
+
transformedSnapXY
.
y
*
inverse
.
_23
+
inverse
.
_43
)
/
inverse
.
_33
)
;
Point3D
transformedSnap
=
Point3D
(
transformedSnapXY
.
x
transformedSnapXY
.
y
transformedSnapZ
)
;
if
(
transformedOrigin
=
=
transformedSnap
)
{
return
aTransform
;
}
Point3D
snap
=
inverse
.
TransformPoint
(
transformedSnap
)
;
if
(
snap
.
z
>
0
.
001
|
|
snap
.
z
<
-
0
.
001
)
{
MOZ_ASSERT
(
inverse
.
_33
=
=
0
.
0
)
;
return
aTransform
;
}
if
(
aResidualTransform
)
{
*
aResidualTransform
=
Matrix
:
:
Translation
(
-
snap
.
x
-
snap
.
y
)
;
}
Point3D
transformedShift
=
transformedSnap
-
transformedOrigin
;
Matrix4x4
result
=
aTransform
;
result
.
PostTranslate
(
transformedShift
.
x
transformedShift
.
y
transformedShift
.
z
)
;
return
result
;
}
Matrix4x4
Layer
:
:
SnapTransform
(
const
Matrix4x4
&
aTransform
const
gfxRect
&
aSnapRect
Matrix
*
aResidualTransform
)
{
if
(
aResidualTransform
)
{
*
aResidualTransform
=
Matrix
(
)
;
}
Matrix
matrix2D
;
Matrix4x4
result
;
if
(
mManager
-
>
IsSnappingEffectiveTransforms
(
)
&
&
aTransform
.
Is2D
(
&
matrix2D
)
&
&
gfxSize
(
1
.
0
1
.
0
)
<
=
aSnapRect
.
Size
(
)
&
&
matrix2D
.
PreservesAxisAlignedRectangles
(
)
)
{
auto
transformedTopLeft
=
IntPoint
:
:
Round
(
matrix2D
.
TransformPoint
(
ToPoint
(
aSnapRect
.
TopLeft
(
)
)
)
)
;
auto
transformedTopRight
=
IntPoint
:
:
Round
(
matrix2D
.
TransformPoint
(
ToPoint
(
aSnapRect
.
TopRight
(
)
)
)
)
;
auto
transformedBottomRight
=
IntPoint
:
:
Round
(
matrix2D
.
TransformPoint
(
ToPoint
(
aSnapRect
.
BottomRight
(
)
)
)
)
;
Matrix
snappedMatrix
=
gfxUtils
:
:
TransformRectToRect
(
aSnapRect
transformedTopLeft
transformedTopRight
transformedBottomRight
)
;
result
=
Matrix4x4
:
:
From2D
(
snappedMatrix
)
;
if
(
aResidualTransform
&
&
!
snappedMatrix
.
IsSingular
(
)
)
{
Matrix
snappedMatrixInverse
=
snappedMatrix
;
snappedMatrixInverse
.
Invert
(
)
;
*
aResidualTransform
=
matrix2D
*
snappedMatrixInverse
;
}
}
else
{
result
=
aTransform
;
}
return
result
;
}
static
bool
AncestorLayerMayChangeTransform
(
Layer
*
aLayer
)
{
for
(
Layer
*
l
=
aLayer
;
l
;
l
=
l
-
>
GetParent
(
)
)
{
if
(
l
-
>
GetContentFlags
(
)
&
Layer
:
:
CONTENT_MAY_CHANGE_TRANSFORM
)
{
return
true
;
}
if
(
l
-
>
GetParent
(
)
&
&
l
-
>
GetParent
(
)
-
>
AsRefLayer
(
)
)
{
return
false
;
}
}
return
false
;
}
bool
Layer
:
:
MayResample
(
)
{
Matrix
transform2d
;
return
!
GetEffectiveTransform
(
)
.
Is2D
(
&
transform2d
)
|
|
ThebesMatrix
(
transform2d
)
.
HasNonIntegerTranslation
(
)
|
|
AncestorLayerMayChangeTransform
(
this
)
;
}
RenderTargetIntRect
Layer
:
:
CalculateScissorRect
(
const
RenderTargetIntRect
&
aCurrentScissorRect
)
{
ContainerLayer
*
container
=
GetParent
(
)
;
ContainerLayer
*
containerChild
=
nullptr
;
NS_ASSERTION
(
GetParent
(
)
"
This
can
'
t
be
called
on
the
root
!
"
)
;
while
(
container
-
>
Extend3DContext
(
)
&
&
!
container
-
>
UseIntermediateSurface
(
)
)
{
containerChild
=
container
;
container
=
container
-
>
GetParent
(
)
;
MOZ_ASSERT
(
container
)
;
}
Layer
*
clipLayer
=
containerChild
&
&
containerChild
-
>
GetLocalClipRect
(
)
?
containerChild
:
this
;
RenderTargetIntRect
currentClip
;
if
(
container
-
>
UseIntermediateSurface
(
)
)
{
currentClip
.
SizeTo
(
container
-
>
GetIntermediateSurfaceRect
(
)
.
Size
(
)
)
;
}
else
{
currentClip
=
aCurrentScissorRect
;
}
if
(
!
clipLayer
-
>
GetLocalClipRect
(
)
)
{
return
currentClip
;
}
if
(
GetLocalVisibleRegion
(
)
.
IsEmpty
(
)
)
{
return
RenderTargetIntRect
(
currentClip
.
TopLeft
(
)
RenderTargetIntSize
(
0
0
)
)
;
}
const
RenderTargetIntRect
clipRect
=
ViewAs
<
RenderTargetPixel
>
(
*
clipLayer
-
>
GetLocalClipRect
(
)
PixelCastJustification
:
:
RenderTargetIsParentLayerForRoot
)
;
if
(
clipRect
.
IsEmpty
(
)
)
{
return
RenderTargetIntRect
(
currentClip
.
TopLeft
(
)
RenderTargetIntSize
(
0
0
)
)
;
}
RenderTargetIntRect
scissor
=
clipRect
;
if
(
!
container
-
>
UseIntermediateSurface
(
)
)
{
gfx
:
:
Matrix
matrix
;
DebugOnly
<
bool
>
is2D
=
container
-
>
GetEffectiveTransform
(
)
.
Is2D
(
&
matrix
)
;
NS_ASSERTION
(
is2D
&
&
matrix
.
PreservesAxisAlignedRectangles
(
)
"
Non
preserves
axis
aligned
transform
with
clipped
child
should
have
forced
intermediate
surface
"
)
;
gfx
:
:
Rect
r
(
scissor
.
X
(
)
scissor
.
Y
(
)
scissor
.
Width
(
)
scissor
.
Height
(
)
)
;
gfxRect
trScissor
=
gfx
:
:
ThebesRect
(
matrix
.
TransformBounds
(
r
)
)
;
trScissor
.
Round
(
)
;
IntRect
tmp
;
if
(
!
gfxUtils
:
:
GfxRectToIntRect
(
trScissor
&
tmp
)
)
{
return
RenderTargetIntRect
(
currentClip
.
TopLeft
(
)
RenderTargetIntSize
(
0
0
)
)
;
}
scissor
=
ViewAs
<
RenderTargetPixel
>
(
tmp
)
;
do
{
container
=
container
-
>
GetParent
(
)
;
}
while
(
container
&
&
!
container
-
>
UseIntermediateSurface
(
)
)
;
}
if
(
container
)
{
scissor
.
MoveBy
(
-
container
-
>
GetIntermediateSurfaceRect
(
)
.
TopLeft
(
)
)
;
}
return
currentClip
.
Intersect
(
scissor
)
;
}
Maybe
<
ParentLayerIntRect
>
Layer
:
:
GetScrolledClipRect
(
)
const
{
const
Maybe
<
LayerClip
>
clip
=
mSimpleAttrs
.
GetScrolledClip
(
)
;
return
clip
?
Some
(
clip
-
>
GetClipRect
(
)
)
:
Nothing
(
)
;
}
const
ScrollMetadata
&
Layer
:
:
GetScrollMetadata
(
uint32_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
GetScrollMetadataCount
(
)
)
;
return
mScrollMetadata
[
aIndex
]
;
}
const
FrameMetrics
&
Layer
:
:
GetFrameMetrics
(
uint32_t
aIndex
)
const
{
return
GetScrollMetadata
(
aIndex
)
.
GetMetrics
(
)
;
}
bool
Layer
:
:
HasScrollableFrameMetrics
(
)
const
{
for
(
uint32_t
i
=
0
;
i
<
GetScrollMetadataCount
(
)
;
i
+
+
)
{
if
(
GetFrameMetrics
(
i
)
.
IsScrollable
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
Layer
:
:
HasRootScrollableFrameMetrics
(
)
const
{
for
(
uint32_t
i
=
0
;
i
<
GetScrollMetadataCount
(
)
;
i
+
+
)
{
if
(
GetFrameMetrics
(
i
)
.
IsScrollable
(
)
&
&
GetFrameMetrics
(
i
)
.
IsRootContent
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
Layer
:
:
IsScrollableWithoutContent
(
)
const
{
return
AsContainerLayer
(
)
&
&
HasScrollableFrameMetrics
(
)
&
&
!
GetFirstChild
(
)
;
}
Matrix4x4
Layer
:
:
GetTransform
(
)
const
{
Matrix4x4
transform
=
mSimpleAttrs
.
GetTransform
(
)
;
transform
.
PostScale
(
GetPostXScale
(
)
GetPostYScale
(
)
1
.
0f
)
;
if
(
const
ContainerLayer
*
c
=
AsContainerLayer
(
)
)
{
transform
.
PreScale
(
c
-
>
GetPreXScale
(
)
c
-
>
GetPreYScale
(
)
1
.
0f
)
;
}
return
transform
;
}
const
CSSTransformMatrix
Layer
:
:
GetTransformTyped
(
)
const
{
return
ViewAs
<
CSSTransformMatrix
>
(
GetTransform
(
)
)
;
}
Matrix4x4
Layer
:
:
GetLocalTransform
(
)
{
if
(
HostLayer
*
shadow
=
AsHostLayer
(
)
)
{
return
shadow
-
>
GetShadowTransform
(
)
;
}
return
GetTransform
(
)
;
}
const
LayerToParentLayerMatrix4x4
Layer
:
:
GetLocalTransformTyped
(
)
{
return
ViewAs
<
LayerToParentLayerMatrix4x4
>
(
GetLocalTransform
(
)
)
;
}
bool
Layer
:
:
IsScrollbarContainer
(
)
const
{
const
ScrollbarData
&
data
=
GetScrollbarData
(
)
;
return
(
data
.
mScrollbarLayerType
=
=
ScrollbarLayerType
:
:
Container
)
?
data
.
mDirection
.
isSome
(
)
:
false
;
}
bool
Layer
:
:
HasTransformAnimation
(
)
const
{
return
mAnimationInfo
.
HasTransformAnimation
(
)
;
}
void
Layer
:
:
ApplyPendingUpdatesForThisTransaction
(
)
{
if
(
mPendingTransform
&
&
*
mPendingTransform
!
=
mSimpleAttrs
.
GetTransform
(
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
PendingUpdatesForThisTransaction
"
this
)
)
;
mSimpleAttrs
.
SetTransform
(
*
mPendingTransform
)
;
MutatedSimple
(
)
;
}
mPendingTransform
=
nullptr
;
if
(
mAnimationInfo
.
ApplyPendingUpdatesForThisTransaction
(
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
PendingUpdatesForThisTransaction
"
this
)
)
;
Mutated
(
)
;
}
for
(
size_t
i
=
0
;
i
<
mScrollMetadata
.
Length
(
)
;
i
+
+
)
{
FrameMetrics
&
fm
=
mScrollMetadata
[
i
]
.
GetMetrics
(
)
;
Maybe
<
ScrollUpdateInfo
>
update
=
Manager
(
)
-
>
GetPendingScrollInfoUpdate
(
fm
.
GetScrollId
(
)
)
;
if
(
update
)
{
fm
.
UpdatePendingScrollInfo
(
update
.
value
(
)
)
;
Mutated
(
)
;
}
}
}
float
Layer
:
:
GetLocalOpacity
(
)
{
float
opacity
=
mSimpleAttrs
.
GetOpacity
(
)
;
if
(
HostLayer
*
shadow
=
AsHostLayer
(
)
)
opacity
=
shadow
-
>
GetShadowOpacity
(
)
;
return
std
:
:
min
(
std
:
:
max
(
opacity
0
.
0f
)
1
.
0f
)
;
}
float
Layer
:
:
GetEffectiveOpacity
(
)
{
float
opacity
=
GetLocalOpacity
(
)
;
for
(
ContainerLayer
*
c
=
GetParent
(
)
;
c
&
&
!
c
-
>
UseIntermediateSurface
(
)
;
c
=
c
-
>
GetParent
(
)
)
{
opacity
*
=
c
-
>
GetLocalOpacity
(
)
;
}
return
opacity
;
}
CompositionOp
Layer
:
:
GetEffectiveMixBlendMode
(
)
{
if
(
mSimpleAttrs
.
GetMixBlendMode
(
)
!
=
CompositionOp
:
:
OP_OVER
)
return
mSimpleAttrs
.
GetMixBlendMode
(
)
;
for
(
ContainerLayer
*
c
=
GetParent
(
)
;
c
&
&
!
c
-
>
UseIntermediateSurface
(
)
;
c
=
c
-
>
GetParent
(
)
)
{
if
(
c
-
>
mSimpleAttrs
.
GetMixBlendMode
(
)
!
=
CompositionOp
:
:
OP_OVER
)
return
c
-
>
mSimpleAttrs
.
GetMixBlendMode
(
)
;
}
return
mSimpleAttrs
.
GetMixBlendMode
(
)
;
}
Matrix4x4
Layer
:
:
ComputeTransformToPreserve3DRoot
(
)
{
Matrix4x4
transform
=
GetLocalTransform
(
)
;
for
(
Layer
*
layer
=
GetParent
(
)
;
layer
&
&
layer
-
>
Extend3DContext
(
)
;
layer
=
layer
-
>
GetParent
(
)
)
{
transform
=
transform
*
layer
-
>
GetLocalTransform
(
)
;
}
return
transform
;
}
void
Layer
:
:
ComputeEffectiveTransformForMaskLayers
(
const
gfx
:
:
Matrix4x4
&
aTransformToSurface
)
{
if
(
GetMaskLayer
(
)
)
{
ComputeEffectiveTransformForMaskLayer
(
GetMaskLayer
(
)
aTransformToSurface
)
;
}
for
(
size_t
i
=
0
;
i
<
GetAncestorMaskLayerCount
(
)
;
i
+
+
)
{
Layer
*
maskLayer
=
GetAncestorMaskLayerAt
(
i
)
;
ComputeEffectiveTransformForMaskLayer
(
maskLayer
aTransformToSurface
)
;
}
}
void
Layer
:
:
ComputeEffectiveTransformForMaskLayer
(
Layer
*
aMaskLayer
const
gfx
:
:
Matrix4x4
&
aTransformToSurface
)
{
aMaskLayer
-
>
mEffectiveTransform
=
aTransformToSurface
;
#
ifdef
DEBUG
bool
maskIs2D
=
aMaskLayer
-
>
GetTransform
(
)
.
CanDraw2D
(
)
;
NS_ASSERTION
(
maskIs2D
"
How
did
we
end
up
with
a
3D
transform
here
?
!
"
)
;
#
endif
aMaskLayer
-
>
mEffectiveTransform
=
aMaskLayer
-
>
GetLocalTransform
(
)
*
aMaskLayer
-
>
mEffectiveTransform
;
}
RenderTargetRect
Layer
:
:
TransformRectToRenderTarget
(
const
LayerIntRect
&
aRect
)
{
LayerRect
rect
(
aRect
)
;
RenderTargetRect
quad
=
RenderTargetRect
:
:
FromUnknownRect
(
GetEffectiveTransform
(
)
.
TransformBounds
(
rect
.
ToUnknownRect
(
)
)
)
;
return
quad
;
}
bool
Layer
:
:
GetVisibleRegionRelativeToRootLayer
(
nsIntRegion
&
aResult
IntPoint
*
aLayerOffset
)
{
MOZ_ASSERT
(
aLayerOffset
"
invalid
offset
pointer
"
)
;
if
(
!
GetParent
(
)
)
{
return
false
;
}
IntPoint
offset
;
aResult
=
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
;
for
(
Layer
*
layer
=
this
;
layer
;
layer
=
layer
-
>
GetParent
(
)
)
{
gfx
:
:
Matrix
matrix
;
if
(
!
layer
-
>
GetLocalTransform
(
)
.
Is2D
(
&
matrix
)
|
|
!
matrix
.
IsTranslation
(
)
)
{
return
false
;
}
auto
currentLayerOffset
=
IntPoint
:
:
Round
(
matrix
.
GetTranslation
(
)
)
;
aResult
.
MoveBy
(
currentLayerOffset
.
x
currentLayerOffset
.
y
)
;
if
(
layer
-
>
GetLocalClipRect
(
)
)
{
aResult
.
AndWith
(
layer
-
>
GetLocalClipRect
(
)
-
>
ToUnknownRect
(
)
)
;
}
Layer
*
sibling
;
for
(
sibling
=
layer
-
>
GetNextSibling
(
)
;
sibling
;
sibling
=
sibling
-
>
GetNextSibling
(
)
)
{
gfx
:
:
Matrix
siblingMatrix
;
if
(
!
sibling
-
>
GetLocalTransform
(
)
.
Is2D
(
&
siblingMatrix
)
|
|
!
siblingMatrix
.
IsTranslation
(
)
)
{
continue
;
}
auto
siblingOffset
=
IntPoint
:
:
Round
(
siblingMatrix
.
GetTranslation
(
)
)
;
nsIntRegion
siblingVisibleRegion
(
sibling
-
>
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
)
;
siblingVisibleRegion
.
MoveBy
(
-
siblingOffset
.
x
-
siblingOffset
.
y
)
;
Maybe
<
ParentLayerIntRect
>
clipRect
=
sibling
-
>
GetLocalClipRect
(
)
;
if
(
clipRect
)
{
siblingVisibleRegion
.
AndWith
(
clipRect
-
>
ToUnknownRect
(
)
)
;
}
aResult
.
SubOut
(
siblingVisibleRegion
)
;
}
offset
+
=
currentLayerOffset
;
}
*
aLayerOffset
=
IntPoint
(
offset
.
x
offset
.
y
)
;
return
true
;
}
InfallibleTArray
<
AnimData
>
&
Layer
:
:
GetAnimationData
(
)
{
return
mAnimationInfo
.
GetAnimationData
(
)
;
}
Maybe
<
ParentLayerIntRect
>
Layer
:
:
GetCombinedClipRect
(
)
const
{
Maybe
<
ParentLayerIntRect
>
clip
=
GetClipRect
(
)
;
clip
=
IntersectMaybeRects
(
clip
GetScrolledClipRect
(
)
)
;
for
(
size_t
i
=
0
;
i
<
mScrollMetadata
.
Length
(
)
;
i
+
+
)
{
clip
=
IntersectMaybeRects
(
clip
mScrollMetadata
[
i
]
.
GetClipRect
(
)
)
;
}
return
clip
;
}
ContainerLayer
:
:
ContainerLayer
(
LayerManager
*
aManager
void
*
aImplData
)
:
Layer
(
aManager
aImplData
)
mFirstChild
(
nullptr
)
mLastChild
(
nullptr
)
mPreXScale
(
1
.
0f
)
mPreYScale
(
1
.
0f
)
mInheritedXScale
(
1
.
0f
)
mInheritedYScale
(
1
.
0f
)
mPresShellResolution
(
1
.
0f
)
mScaleToResolution
(
false
)
mUseIntermediateSurface
(
false
)
mSupportsComponentAlphaChildren
(
false
)
mMayHaveReadbackChild
(
false
)
mChildrenChanged
(
false
)
{
}
ContainerLayer
:
:
~
ContainerLayer
(
)
{
}
bool
ContainerLayer
:
:
InsertAfter
(
Layer
*
aChild
Layer
*
aAfter
)
{
if
(
aChild
-
>
Manager
(
)
!
=
Manager
(
)
)
{
NS_ERROR
(
"
Child
has
wrong
manager
"
)
;
return
false
;
}
if
(
aChild
-
>
GetParent
(
)
)
{
NS_ERROR
(
"
aChild
already
in
the
tree
"
)
;
return
false
;
}
if
(
aChild
-
>
GetNextSibling
(
)
|
|
aChild
-
>
GetPrevSibling
(
)
)
{
NS_ERROR
(
"
aChild
already
has
siblings
?
"
)
;
return
false
;
}
if
(
aAfter
&
&
(
aAfter
-
>
Manager
(
)
!
=
Manager
(
)
|
|
aAfter
-
>
GetParent
(
)
!
=
this
)
)
{
NS_ERROR
(
"
aAfter
is
not
our
child
"
)
;
return
false
;
}
aChild
-
>
SetParent
(
this
)
;
if
(
aAfter
=
=
mLastChild
)
{
mLastChild
=
aChild
;
}
if
(
!
aAfter
)
{
aChild
-
>
SetNextSibling
(
mFirstChild
)
;
if
(
mFirstChild
)
{
mFirstChild
-
>
SetPrevSibling
(
aChild
)
;
}
mFirstChild
=
aChild
;
NS_ADDREF
(
aChild
)
;
DidInsertChild
(
aChild
)
;
return
true
;
}
Layer
*
next
=
aAfter
-
>
GetNextSibling
(
)
;
aChild
-
>
SetNextSibling
(
next
)
;
aChild
-
>
SetPrevSibling
(
aAfter
)
;
if
(
next
)
{
next
-
>
SetPrevSibling
(
aChild
)
;
}
aAfter
-
>
SetNextSibling
(
aChild
)
;
NS_ADDREF
(
aChild
)
;
DidInsertChild
(
aChild
)
;
return
true
;
}
void
ContainerLayer
:
:
RemoveAllChildren
(
)
{
Layer
*
current
=
mFirstChild
;
while
(
current
)
{
Layer
*
next
=
current
-
>
GetNextSibling
(
)
;
if
(
current
-
>
GetType
(
)
=
=
TYPE_READBACK
)
{
static_cast
<
ReadbackLayer
*
>
(
current
)
-
>
NotifyRemoved
(
)
;
}
current
=
next
;
}
current
=
mFirstChild
;
mFirstChild
=
nullptr
;
while
(
current
)
{
MOZ_ASSERT
(
!
current
-
>
GetPrevSibling
(
)
)
;
Layer
*
next
=
current
-
>
GetNextSibling
(
)
;
current
-
>
SetParent
(
nullptr
)
;
current
-
>
SetNextSibling
(
nullptr
)
;
if
(
next
)
{
next
-
>
SetPrevSibling
(
nullptr
)
;
}
NS_RELEASE
(
current
)
;
current
=
next
;
}
}
bool
ContainerLayer
:
:
RemoveChild
(
Layer
*
aChild
)
{
if
(
aChild
-
>
Manager
(
)
!
=
Manager
(
)
)
{
NS_ERROR
(
"
Child
has
wrong
manager
"
)
;
return
false
;
}
if
(
aChild
-
>
GetParent
(
)
!
=
this
)
{
NS_ERROR
(
"
aChild
not
our
child
"
)
;
return
false
;
}
Layer
*
prev
=
aChild
-
>
GetPrevSibling
(
)
;
Layer
*
next
=
aChild
-
>
GetNextSibling
(
)
;
if
(
prev
)
{
prev
-
>
SetNextSibling
(
next
)
;
}
else
{
this
-
>
mFirstChild
=
next
;
}
if
(
next
)
{
next
-
>
SetPrevSibling
(
prev
)
;
}
else
{
this
-
>
mLastChild
=
prev
;
}
aChild
-
>
SetNextSibling
(
nullptr
)
;
aChild
-
>
SetPrevSibling
(
nullptr
)
;
aChild
-
>
SetParent
(
nullptr
)
;
this
-
>
DidRemoveChild
(
aChild
)
;
NS_RELEASE
(
aChild
)
;
return
true
;
}
bool
ContainerLayer
:
:
RepositionChild
(
Layer
*
aChild
Layer
*
aAfter
)
{
if
(
aChild
-
>
Manager
(
)
!
=
Manager
(
)
)
{
NS_ERROR
(
"
Child
has
wrong
manager
"
)
;
return
false
;
}
if
(
aChild
-
>
GetParent
(
)
!
=
this
)
{
NS_ERROR
(
"
aChild
not
our
child
"
)
;
return
false
;
}
if
(
aAfter
&
&
(
aAfter
-
>
Manager
(
)
!
=
Manager
(
)
|
|
aAfter
-
>
GetParent
(
)
!
=
this
)
)
{
NS_ERROR
(
"
aAfter
is
not
our
child
"
)
;
return
false
;
}
if
(
aChild
=
=
aAfter
)
{
NS_ERROR
(
"
aChild
cannot
be
the
same
as
aAfter
"
)
;
return
false
;
}
Layer
*
prev
=
aChild
-
>
GetPrevSibling
(
)
;
Layer
*
next
=
aChild
-
>
GetNextSibling
(
)
;
if
(
prev
=
=
aAfter
)
{
return
true
;
}
if
(
prev
)
{
prev
-
>
SetNextSibling
(
next
)
;
}
else
{
mFirstChild
=
next
;
}
if
(
next
)
{
next
-
>
SetPrevSibling
(
prev
)
;
}
else
{
mLastChild
=
prev
;
}
if
(
!
aAfter
)
{
aChild
-
>
SetPrevSibling
(
nullptr
)
;
aChild
-
>
SetNextSibling
(
mFirstChild
)
;
if
(
mFirstChild
)
{
mFirstChild
-
>
SetPrevSibling
(
aChild
)
;
}
mFirstChild
=
aChild
;
return
true
;
}
Layer
*
afterNext
=
aAfter
-
>
GetNextSibling
(
)
;
if
(
afterNext
)
{
afterNext
-
>
SetPrevSibling
(
aChild
)
;
}
else
{
mLastChild
=
aChild
;
}
aAfter
-
>
SetNextSibling
(
aChild
)
;
aChild
-
>
SetPrevSibling
(
aAfter
)
;
aChild
-
>
SetNextSibling
(
afterNext
)
;
return
true
;
}
void
ContainerLayer
:
:
FillSpecificAttributes
(
SpecificLayerAttributes
&
aAttrs
)
{
aAttrs
=
ContainerLayerAttributes
(
mPreXScale
mPreYScale
mInheritedXScale
mInheritedYScale
mPresShellResolution
mScaleToResolution
)
;
}
bool
ContainerLayer
:
:
Creates3DContextWithExtendingChildren
(
)
{
if
(
Extend3DContext
(
)
)
{
return
false
;
}
for
(
Layer
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
Extend3DContext
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
ContainerLayer
:
:
HasMultipleChildren
(
)
{
uint32_t
count
=
0
;
for
(
Layer
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
const
Maybe
<
ParentLayerIntRect
>
&
clipRect
=
child
-
>
GetLocalClipRect
(
)
;
if
(
clipRect
&
&
clipRect
-
>
IsEmpty
(
)
)
continue
;
if
(
child
-
>
GetLocalVisibleRegion
(
)
.
IsEmpty
(
)
)
continue
;
+
+
count
;
if
(
count
>
1
)
return
true
;
}
return
false
;
}
void
ContainerLayer
:
:
Collect3DContextLeaves
(
nsTArray
<
Layer
*
>
&
aToSort
)
{
ForEachNode
<
ForwardIterator
>
(
(
Layer
*
)
this
[
this
&
aToSort
]
(
Layer
*
layer
)
{
ContainerLayer
*
container
=
layer
-
>
AsContainerLayer
(
)
;
if
(
layer
=
=
this
|
|
(
container
&
&
container
-
>
Extend3DContext
(
)
&
&
!
container
-
>
UseIntermediateSurface
(
)
)
)
{
return
TraversalFlag
:
:
Continue
;
}
aToSort
.
AppendElement
(
layer
)
;
return
TraversalFlag
:
:
Skip
;
}
)
;
}
static
nsTArray
<
LayerPolygon
>
SortLayersWithBSPTree
(
nsTArray
<
Layer
*
>
&
aArray
)
{
std
:
:
list
<
LayerPolygon
>
inputLayers
;
for
(
Layer
*
layer
:
aArray
)
{
if
(
!
layer
-
>
IsVisible
(
)
)
{
continue
;
}
const
gfx
:
:
IntRect
&
bounds
=
layer
-
>
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
.
GetBounds
(
)
;
const
gfx
:
:
Matrix4x4
&
transform
=
layer
-
>
GetEffectiveTransform
(
)
;
if
(
transform
.
IsSingular
(
)
)
{
continue
;
}
gfx
:
:
Polygon
polygon
=
gfx
:
:
Polygon
:
:
FromRect
(
gfx
:
:
Rect
(
bounds
)
)
;
polygon
.
TransformToScreenSpace
(
transform
)
;
if
(
polygon
.
GetPoints
(
)
.
Length
(
)
>
=
3
)
{
inputLayers
.
push_back
(
LayerPolygon
(
layer
std
:
:
move
(
polygon
)
)
)
;
}
}
if
(
inputLayers
.
empty
(
)
)
{
return
nsTArray
<
LayerPolygon
>
(
)
;
}
BSPTree
tree
(
inputLayers
)
;
nsTArray
<
LayerPolygon
>
orderedLayers
(
tree
.
GetDrawOrder
(
)
)
;
for
(
LayerPolygon
&
layerPolygon
:
orderedLayers
)
{
gfx
:
:
Matrix4x4
inverse
=
layerPolygon
.
layer
-
>
GetEffectiveTransform
(
)
.
Inverse
(
)
;
MOZ_ASSERT
(
layerPolygon
.
geometry
)
;
layerPolygon
.
geometry
-
>
TransformToLayerSpace
(
inverse
)
;
}
return
orderedLayers
;
}
static
nsTArray
<
LayerPolygon
>
StripLayerGeometry
(
const
nsTArray
<
LayerPolygon
>
&
aLayers
)
{
nsTArray
<
LayerPolygon
>
layers
;
std
:
:
set
<
Layer
*
>
uniqueLayers
;
for
(
const
LayerPolygon
&
layerPolygon
:
aLayers
)
{
auto
result
=
uniqueLayers
.
insert
(
layerPolygon
.
layer
)
;
if
(
result
.
second
)
{
layers
.
AppendElement
(
LayerPolygon
(
layerPolygon
.
layer
)
)
;
}
}
return
layers
;
}
nsTArray
<
LayerPolygon
>
ContainerLayer
:
:
SortChildrenBy3DZOrder
(
SortMode
aSortMode
)
{
AutoTArray
<
Layer
*
10
>
toSort
;
nsTArray
<
LayerPolygon
>
drawOrder
;
for
(
Layer
*
layer
=
GetFirstChild
(
)
;
layer
;
layer
=
layer
-
>
GetNextSibling
(
)
)
{
ContainerLayer
*
container
=
layer
-
>
AsContainerLayer
(
)
;
if
(
container
&
&
container
-
>
Extend3DContext
(
)
&
&
!
container
-
>
UseIntermediateSurface
(
)
)
{
container
-
>
Collect3DContextLeaves
(
toSort
)
;
if
(
toSort
.
Length
(
)
>
0
)
{
nsTArray
<
LayerPolygon
>
sorted
=
SortLayersWithBSPTree
(
toSort
)
;
drawOrder
.
AppendElements
(
std
:
:
move
(
sorted
)
)
;
toSort
.
ClearAndRetainStorage
(
)
;
}
continue
;
}
drawOrder
.
AppendElement
(
LayerPolygon
(
layer
)
)
;
}
if
(
aSortMode
=
=
SortMode
:
:
WITHOUT_GEOMETRY
)
{
return
StripLayerGeometry
(
drawOrder
)
;
}
return
drawOrder
;
}
bool
ContainerLayer
:
:
AnyAncestorOrThisIs3DContextLeaf
(
)
{
Layer
*
parent
=
this
;
while
(
parent
!
=
nullptr
)
{
if
(
parent
-
>
Is3DContextLeaf
(
)
)
{
return
true
;
}
parent
=
parent
-
>
GetParent
(
)
;
}
return
false
;
}
void
ContainerLayer
:
:
DefaultComputeEffectiveTransforms
(
const
Matrix4x4
&
aTransformToSurface
)
{
Matrix
residual
;
Matrix4x4
idealTransform
=
GetLocalTransform
(
)
*
aTransformToSurface
;
if
(
!
Extend3DContext
(
)
&
&
!
Is3DContextLeaf
(
)
)
{
idealTransform
.
ProjectTo2D
(
)
;
}
bool
useIntermediateSurface
;
if
(
HasMaskLayers
(
)
|
|
GetForceIsolatedGroup
(
)
)
{
useIntermediateSurface
=
true
;
#
ifdef
MOZ_DUMP_PAINTING
}
else
if
(
gfxEnv
:
:
DumpPaintIntermediate
(
)
&
&
!
Extend3DContext
(
)
)
{
useIntermediateSurface
=
true
;
#
endif
}
else
{
float
opacity
=
GetEffectiveOpacity
(
)
;
CompositionOp
blendMode
=
GetEffectiveMixBlendMode
(
)
;
if
(
(
HasMultipleChildren
(
)
|
|
Creates3DContextWithExtendingChildren
(
)
)
&
&
(
(
opacity
!
=
1
.
0f
&
&
!
Extend3DContext
(
)
)
|
|
(
blendMode
!
=
CompositionOp
:
:
OP_OVER
)
)
)
{
useIntermediateSurface
=
true
;
}
else
if
(
(
!
idealTransform
.
Is2D
(
)
|
|
AnyAncestorOrThisIs3DContextLeaf
(
)
)
&
&
Creates3DContextWithExtendingChildren
(
)
)
{
useIntermediateSurface
=
true
;
}
else
if
(
blendMode
!
=
CompositionOp
:
:
OP_OVER
&
&
Manager
(
)
-
>
BlendingRequiresIntermediateSurface
(
)
)
{
useIntermediateSurface
=
true
;
}
else
{
useIntermediateSurface
=
false
;
gfx
:
:
Matrix
contTransform
;
bool
checkClipRect
=
false
;
bool
checkMaskLayers
=
false
;
if
(
!
idealTransform
.
Is2D
(
&
contTransform
)
)
{
checkClipRect
=
true
;
checkMaskLayers
=
true
;
}
else
{
#
ifdef
MOZ_GFX_OPTIMIZE_MOBILE
if
(
!
contTransform
.
PreservesAxisAlignedRectangles
(
)
)
{
#
else
if
(
gfx
:
:
ThebesMatrix
(
contTransform
)
.
HasNonIntegerTranslation
(
)
)
{
#
endif
checkClipRect
=
true
;
}
if
(
contTransform
.
HasNonAxisAlignedTransform
(
)
|
|
contTransform
.
HasNegativeScaling
(
)
)
{
checkMaskLayers
=
true
;
}
}
if
(
checkClipRect
|
|
checkMaskLayers
)
{
for
(
Layer
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
const
Maybe
<
ParentLayerIntRect
>
&
clipRect
=
child
-
>
GetLocalClipRect
(
)
;
if
(
checkClipRect
&
&
(
clipRect
&
&
!
clipRect
-
>
IsEmpty
(
)
&
&
!
child
-
>
GetLocalVisibleRegion
(
)
.
IsEmpty
(
)
)
)
{
useIntermediateSurface
=
true
;
break
;
}
if
(
checkMaskLayers
&
&
child
-
>
HasMaskLayers
(
)
)
{
useIntermediateSurface
=
true
;
break
;
}
}
}
}
}
NS_ASSERTION
(
!
Extend3DContext
(
)
|
|
!
useIntermediateSurface
"
Can
'
t
have
an
intermediate
surface
with
preserve
-
3d
!
"
)
;
if
(
useIntermediateSurface
)
{
mEffectiveTransform
=
SnapTransformTranslation
(
idealTransform
&
residual
)
;
}
else
{
mEffectiveTransform
=
idealTransform
;
}
if
(
!
Extend3DContext
(
)
)
{
idealTransform
.
ProjectTo2D
(
)
;
}
mUseIntermediateSurface
=
useIntermediateSurface
;
if
(
useIntermediateSurface
)
{
ComputeEffectiveTransformsForChildren
(
Matrix4x4
:
:
From2D
(
residual
)
)
;
}
else
{
ComputeEffectiveTransformsForChildren
(
idealTransform
)
;
}
ComputeEffectiveTransformForMaskLayers
(
aTransformToSurface
)
;
}
void
ContainerLayer
:
:
DefaultComputeSupportsComponentAlphaChildren
(
bool
*
aNeedsSurfaceCopy
)
{
if
(
!
(
GetContentFlags
(
)
&
Layer
:
:
CONTENT_COMPONENT_ALPHA_DESCENDANT
)
|
|
!
Manager
(
)
-
>
AreComponentAlphaLayersEnabled
(
)
)
{
mSupportsComponentAlphaChildren
=
false
;
if
(
aNeedsSurfaceCopy
)
{
*
aNeedsSurfaceCopy
=
false
;
}
return
;
}
mSupportsComponentAlphaChildren
=
false
;
bool
needsSurfaceCopy
=
false
;
CompositionOp
blendMode
=
GetEffectiveMixBlendMode
(
)
;
if
(
UseIntermediateSurface
(
)
)
{
if
(
GetLocalVisibleRegion
(
)
.
GetNumRects
(
)
=
=
1
&
&
(
GetContentFlags
(
)
&
Layer
:
:
CONTENT_OPAQUE
)
)
{
mSupportsComponentAlphaChildren
=
true
;
}
else
{
gfx
:
:
Matrix
transform
;
if
(
HasOpaqueAncestorLayer
(
this
)
&
&
GetEffectiveTransform
(
)
.
Is2D
(
&
transform
)
&
&
!
gfx
:
:
ThebesMatrix
(
transform
)
.
HasNonIntegerTranslation
(
)
&
&
blendMode
=
=
gfx
:
:
CompositionOp
:
:
OP_OVER
)
{
mSupportsComponentAlphaChildren
=
true
;
needsSurfaceCopy
=
true
;
}
}
}
else
if
(
blendMode
=
=
gfx
:
:
CompositionOp
:
:
OP_OVER
)
{
mSupportsComponentAlphaChildren
=
(
GetContentFlags
(
)
&
Layer
:
:
CONTENT_OPAQUE
)
|
|
(
GetParent
(
)
&
&
GetParent
(
)
-
>
SupportsComponentAlphaChildren
(
)
)
;
}
if
(
aNeedsSurfaceCopy
)
{
*
aNeedsSurfaceCopy
=
mSupportsComponentAlphaChildren
&
&
needsSurfaceCopy
;
}
}
void
ContainerLayer
:
:
ComputeEffectiveTransformsForChildren
(
const
Matrix4x4
&
aTransformToSurface
)
{
for
(
Layer
*
l
=
mFirstChild
;
l
;
l
=
l
-
>
GetNextSibling
(
)
)
{
l
-
>
ComputeEffectiveTransforms
(
aTransformToSurface
)
;
}
}
bool
ContainerLayer
:
:
HasOpaqueAncestorLayer
(
Layer
*
aLayer
)
{
for
(
Layer
*
l
=
aLayer
-
>
GetParent
(
)
;
l
;
l
=
l
-
>
GetParent
(
)
)
{
if
(
l
-
>
GetContentFlags
(
)
&
Layer
:
:
CONTENT_OPAQUE
)
return
true
;
}
return
false
;
}
void
ContainerLayer
:
:
DidRemoveChild
(
Layer
*
aLayer
)
{
PaintedLayer
*
tl
=
aLayer
-
>
AsPaintedLayer
(
)
;
if
(
tl
&
&
tl
-
>
UsedForReadback
(
)
)
{
for
(
Layer
*
l
=
mFirstChild
;
l
;
l
=
l
-
>
GetNextSibling
(
)
)
{
if
(
l
-
>
GetType
(
)
=
=
TYPE_READBACK
)
{
static_cast
<
ReadbackLayer
*
>
(
l
)
-
>
NotifyPaintedLayerRemoved
(
tl
)
;
}
}
}
if
(
aLayer
-
>
GetType
(
)
=
=
TYPE_READBACK
)
{
static_cast
<
ReadbackLayer
*
>
(
aLayer
)
-
>
NotifyRemoved
(
)
;
}
}
void
ContainerLayer
:
:
DidInsertChild
(
Layer
*
aLayer
)
{
if
(
aLayer
-
>
GetType
(
)
=
=
TYPE_READBACK
)
{
mMayHaveReadbackChild
=
true
;
}
}
void
RefLayer
:
:
FillSpecificAttributes
(
SpecificLayerAttributes
&
aAttrs
)
{
aAttrs
=
RefLayerAttributes
(
GetReferentId
(
)
mEventRegionsOverride
)
;
}
uint32_t
LayerManager
:
:
StartFrameTimeRecording
(
int32_t
aBufferSize
)
{
if
(
mRecording
.
mIsPaused
)
{
mRecording
.
mIsPaused
=
false
;
if
(
!
mRecording
.
mIntervals
.
Length
(
)
)
{
mRecording
.
mIntervals
.
SetLength
(
aBufferSize
)
;
}
mRecording
.
mLastFrameTime
=
TimeStamp
:
:
Now
(
)
;
mRecording
.
mCurrentRunStartIndex
=
mRecording
.
mNextIndex
;
}
mRecording
.
mLatestStartIndex
=
mRecording
.
mNextIndex
;
return
mRecording
.
mNextIndex
;
}
void
LayerManager
:
:
RecordFrame
(
)
{
if
(
!
mRecording
.
mIsPaused
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
uint32_t
i
=
mRecording
.
mNextIndex
%
mRecording
.
mIntervals
.
Length
(
)
;
mRecording
.
mIntervals
[
i
]
=
static_cast
<
float
>
(
(
now
-
mRecording
.
mLastFrameTime
)
.
ToMilliseconds
(
)
)
;
mRecording
.
mNextIndex
+
+
;
mRecording
.
mLastFrameTime
=
now
;
if
(
mRecording
.
mNextIndex
>
(
mRecording
.
mLatestStartIndex
+
mRecording
.
mIntervals
.
Length
(
)
)
)
{
mRecording
.
mIsPaused
=
true
;
}
}
}
void
LayerManager
:
:
StopFrameTimeRecording
(
uint32_t
aStartIndex
nsTArray
<
float
>
&
aFrameIntervals
)
{
uint32_t
bufferSize
=
mRecording
.
mIntervals
.
Length
(
)
;
uint32_t
length
=
mRecording
.
mNextIndex
-
aStartIndex
;
if
(
mRecording
.
mIsPaused
|
|
length
>
bufferSize
|
|
aStartIndex
<
mRecording
.
mCurrentRunStartIndex
)
{
length
=
0
;
}
if
(
!
length
)
{
aFrameIntervals
.
Clear
(
)
;
return
;
}
aFrameIntervals
.
SetLength
(
length
)
;
uint32_t
cyclicPos
=
aStartIndex
%
bufferSize
;
for
(
uint32_t
i
=
0
;
i
<
length
;
i
+
+
cyclicPos
+
+
)
{
if
(
cyclicPos
=
=
bufferSize
)
{
cyclicPos
=
0
;
}
aFrameIntervals
[
i
]
=
mRecording
.
mIntervals
[
cyclicPos
]
;
}
}
static
void
PrintInfo
(
std
:
:
stringstream
&
aStream
HostLayer
*
aLayerComposite
)
;
#
ifdef
MOZ_DUMP_PAINTING
template
<
typename
T
>
void
WriteSnapshotToDumpFile_internal
(
T
*
aObj
DataSourceSurface
*
aSurf
)
{
nsCString
string
(
aObj
-
>
Name
(
)
)
;
string
.
Append
(
'
-
'
)
;
string
.
AppendInt
(
(
uint64_t
)
aObj
)
;
if
(
gfxUtils
:
:
sDumpPaintFile
!
=
stderr
)
{
fprintf_stderr
(
gfxUtils
:
:
sDumpPaintFile
R
"
(
array
[
"
%
s
"
]
=
"
)
"
string
.
BeginReading
(
)
)
;
}
gfxUtils
:
:
DumpAsDataURI
(
aSurf
gfxUtils
:
:
sDumpPaintFile
)
;
if
(
gfxUtils
:
:
sDumpPaintFile
!
=
stderr
)
{
fprintf_stderr
(
gfxUtils
:
:
sDumpPaintFile
R
"
(
"
;
)
"
)
;
}
}
void
WriteSnapshotToDumpFile
(
Layer
*
aLayer
DataSourceSurface
*
aSurf
)
{
WriteSnapshotToDumpFile_internal
(
aLayer
aSurf
)
;
}
void
WriteSnapshotToDumpFile
(
LayerManager
*
aManager
DataSourceSurface
*
aSurf
)
{
WriteSnapshotToDumpFile_internal
(
aManager
aSurf
)
;
}
void
WriteSnapshotToDumpFile
(
Compositor
*
aCompositor
DrawTarget
*
aTarget
)
{
RefPtr
<
SourceSurface
>
surf
=
aTarget
-
>
Snapshot
(
)
;
RefPtr
<
DataSourceSurface
>
dSurf
=
surf
-
>
GetDataSurface
(
)
;
WriteSnapshotToDumpFile_internal
(
aCompositor
dSurf
)
;
}
#
endif
void
Layer
:
:
Dump
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
bool
aDumpHtml
bool
aSorted
const
Maybe
<
gfx
:
:
Polygon
>
&
aGeometry
)
{
#
ifdef
MOZ_DUMP_PAINTING
bool
dumpCompositorTexture
=
gfxEnv
:
:
DumpCompositorTextures
(
)
&
&
AsHostLayer
(
)
&
&
AsHostLayer
(
)
-
>
GetCompositableHost
(
)
;
bool
dumpClientTexture
=
gfxEnv
:
:
DumpPaint
(
)
&
&
AsShadowableLayer
(
)
&
&
AsShadowableLayer
(
)
-
>
GetCompositableClient
(
)
;
nsCString
layerId
(
Name
(
)
)
;
layerId
.
Append
(
'
-
'
)
;
layerId
.
AppendInt
(
(
uint64_t
)
this
)
;
#
endif
if
(
aDumpHtml
)
{
aStream
<
<
nsPrintfCString
(
R
"
(
<
li
>
<
a
id
=
"
%
p
"
)
"
this
)
.
get
(
)
;
#
ifdef
MOZ_DUMP_PAINTING
if
(
dumpCompositorTexture
|
|
dumpClientTexture
)
{
aStream
<
<
nsPrintfCString
(
R
"
lit
(
href
=
"
javascript
:
ViewImage
(
'
%
s
'
)
"
)
lit
"
layerId
.
BeginReading
(
)
)
.
get
(
)
;
}
#
endif
aStream
<
<
"
>
"
;
}
DumpSelf
(
aStream
aPrefix
aGeometry
)
;
#
ifdef
MOZ_DUMP_PAINTING
if
(
dumpCompositorTexture
)
{
AsHostLayer
(
)
-
>
GetCompositableHost
(
)
-
>
Dump
(
aStream
aPrefix
aDumpHtml
)
;
}
else
if
(
dumpClientTexture
)
{
if
(
aDumpHtml
)
{
aStream
<
<
nsPrintfCString
(
R
"
(
<
script
>
array
[
"
%
s
"
]
=
"
)
"
layerId
.
BeginReading
(
)
)
.
get
(
)
;
}
AsShadowableLayer
(
)
-
>
GetCompositableClient
(
)
-
>
Dump
(
aStream
aPrefix
aDumpHtml
TextureDumpMode
:
:
DoNotCompress
)
;
if
(
aDumpHtml
)
{
aStream
<
<
R
"
(
"
;
<
/
script
>
)
"
;
}
}
#
endif
if
(
aDumpHtml
)
{
aStream
<
<
"
<
/
a
>
"
;
#
ifdef
MOZ_DUMP_PAINTING
if
(
dumpClientTexture
)
{
aStream
<
<
nsPrintfCString
(
"
<
br
>
<
img
id
=
\
"
%
s
\
"
>
\
n
"
layerId
.
BeginReading
(
)
)
.
get
(
)
;
}
#
endif
}
if
(
Layer
*
mask
=
GetMaskLayer
(
)
)
{
aStream
<
<
nsPrintfCString
(
"
%
s
Mask
layer
:
\
n
"
aPrefix
)
.
get
(
)
;
nsAutoCString
pfx
(
aPrefix
)
;
pfx
+
=
"
"
;
mask
-
>
Dump
(
aStream
pfx
.
get
(
)
aDumpHtml
)
;
}
for
(
size_t
i
=
0
;
i
<
GetAncestorMaskLayerCount
(
)
;
i
+
+
)
{
aStream
<
<
nsPrintfCString
(
"
%
s
Ancestor
mask
layer
%
d
:
\
n
"
aPrefix
uint32_t
(
i
)
)
.
get
(
)
;
nsAutoCString
pfx
(
aPrefix
)
;
pfx
+
=
"
"
;
GetAncestorMaskLayerAt
(
i
)
-
>
Dump
(
aStream
pfx
.
get
(
)
aDumpHtml
)
;
}
#
ifdef
MOZ_DUMP_PAINTING
for
(
size_t
i
=
0
;
i
<
mExtraDumpInfo
.
Length
(
)
;
i
+
+
)
{
const
nsCString
&
str
=
mExtraDumpInfo
[
i
]
;
aStream
<
<
aPrefix
<
<
"
Info
:
\
n
"
<
<
str
.
get
(
)
;
}
#
endif
if
(
ContainerLayer
*
container
=
AsContainerLayer
(
)
)
{
nsTArray
<
LayerPolygon
>
children
;
if
(
aSorted
)
{
children
=
container
-
>
SortChildrenBy3DZOrder
(
ContainerLayer
:
:
SortMode
:
:
WITH_GEOMETRY
)
;
}
else
{
for
(
Layer
*
l
=
container
-
>
GetFirstChild
(
)
;
l
;
l
=
l
-
>
GetNextSibling
(
)
)
{
children
.
AppendElement
(
LayerPolygon
(
l
)
)
;
}
}
nsAutoCString
pfx
(
aPrefix
)
;
pfx
+
=
"
"
;
if
(
aDumpHtml
)
{
aStream
<
<
"
<
ul
>
"
;
}
for
(
LayerPolygon
&
child
:
children
)
{
child
.
layer
-
>
Dump
(
aStream
pfx
.
get
(
)
aDumpHtml
aSorted
child
.
geometry
)
;
}
if
(
aDumpHtml
)
{
aStream
<
<
"
<
/
ul
>
"
;
}
}
if
(
aDumpHtml
)
{
aStream
<
<
"
<
/
li
>
"
;
}
}
static
void
DumpGeometry
(
std
:
:
stringstream
&
aStream
const
Maybe
<
gfx
:
:
Polygon
>
&
aGeometry
)
{
aStream
<
<
"
[
geometry
=
[
"
;
const
nsTArray
<
gfx
:
:
Point4D
>
&
points
=
aGeometry
-
>
GetPoints
(
)
;
for
(
size_t
i
=
0
;
i
<
points
.
Length
(
)
;
+
+
i
)
{
const
gfx
:
:
IntPoint
point
=
TruncatedToInt
(
points
[
i
]
.
As2DPoint
(
)
)
;
const
char
*
sfx
=
(
i
!
=
points
.
Length
(
)
-
1
)
?
"
"
:
"
"
;
AppendToString
(
aStream
point
"
"
sfx
)
;
}
aStream
<
<
"
]
]
"
;
}
void
Layer
:
:
DumpSelf
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
const
Maybe
<
gfx
:
:
Polygon
>
&
aGeometry
)
{
PrintInfo
(
aStream
aPrefix
)
;
if
(
aGeometry
)
{
DumpGeometry
(
aStream
aGeometry
)
;
}
aStream
<
<
"
\
n
"
;
}
void
Layer
:
:
Dump
(
layerscope
:
:
LayersPacket
*
aPacket
const
void
*
aParent
)
{
DumpPacket
(
aPacket
aParent
)
;
if
(
Layer
*
kid
=
GetFirstChild
(
)
)
{
kid
-
>
Dump
(
aPacket
this
)
;
}
if
(
Layer
*
next
=
GetNextSibling
(
)
)
{
next
-
>
Dump
(
aPacket
aParent
)
;
}
}
void
Layer
:
:
SetDisplayListLog
(
const
char
*
log
)
{
if
(
gfxUtils
:
:
DumpDisplayList
(
)
)
{
mDisplayListLog
=
log
;
}
}
void
Layer
:
:
GetDisplayListLog
(
nsCString
&
log
)
{
log
.
SetLength
(
0
)
;
if
(
gfxUtils
:
:
DumpDisplayList
(
)
)
{
log
.
AppendPrintf
(
"
0x
%
p
\
n
%
s
"
(
void
*
)
this
mDisplayListLog
.
get
(
)
)
;
}
}
void
Layer
:
:
Log
(
const
char
*
aPrefix
)
{
if
(
!
IsLogEnabled
(
)
)
return
;
LogSelf
(
aPrefix
)
;
if
(
Layer
*
kid
=
GetFirstChild
(
)
)
{
nsAutoCString
pfx
(
aPrefix
)
;
pfx
+
=
"
"
;
kid
-
>
Log
(
pfx
.
get
(
)
)
;
}
if
(
Layer
*
next
=
GetNextSibling
(
)
)
next
-
>
Log
(
aPrefix
)
;
}
void
Layer
:
:
LogSelf
(
const
char
*
aPrefix
)
{
if
(
!
IsLogEnabled
(
)
)
return
;
std
:
:
stringstream
ss
;
PrintInfo
(
ss
aPrefix
)
;
MOZ_LAYERS_LOG
(
(
"
%
s
"
ss
.
str
(
)
.
c_str
(
)
)
)
;
if
(
mMaskLayer
)
{
nsAutoCString
pfx
(
aPrefix
)
;
pfx
+
=
R
"
(
\
MaskLayer
)
"
;
mMaskLayer
-
>
LogSelf
(
pfx
.
get
(
)
)
;
}
}
void
Layer
:
:
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
{
aStream
<
<
aPrefix
;
aStream
<
<
nsPrintfCString
(
"
%
s
%
s
(
0x
%
p
)
"
mManager
-
>
Name
(
)
Name
(
)
this
)
.
get
(
)
;
layers
:
:
PrintInfo
(
aStream
AsHostLayer
(
)
)
;
if
(
mClipRect
)
{
AppendToString
(
aStream
*
mClipRect
"
[
clip
=
"
"
]
"
)
;
}
if
(
mSimpleAttrs
.
GetScrolledClip
(
)
)
{
AppendToString
(
aStream
mSimpleAttrs
.
GetScrolledClip
(
)
-
>
GetClipRect
(
)
"
[
scrolled
-
clip
=
"
"
]
"
)
;
if
(
const
Maybe
<
size_t
>
&
ix
=
mSimpleAttrs
.
GetScrolledClip
(
)
-
>
GetMaskLayerIndex
(
)
)
{
AppendToString
(
aStream
ix
.
value
(
)
"
[
scrolled
-
mask
=
"
"
]
"
)
;
}
}
if
(
1
.
0
!
=
mSimpleAttrs
.
GetPostXScale
(
)
|
|
1
.
0
!
=
mSimpleAttrs
.
GetPostYScale
(
)
)
{
aStream
<
<
nsPrintfCString
(
"
[
postScale
=
%
g
%
g
]
"
mSimpleAttrs
.
GetPostXScale
(
)
mSimpleAttrs
.
GetPostYScale
(
)
)
.
get
(
)
;
}
if
(
!
GetBaseTransform
(
)
.
IsIdentity
(
)
)
{
AppendToString
(
aStream
GetBaseTransform
(
)
"
[
transform
=
"
"
]
"
)
;
}
if
(
!
GetEffectiveTransform
(
)
.
IsIdentity
(
)
)
{
AppendToString
(
aStream
GetEffectiveTransform
(
)
"
[
effective
-
transform
=
"
"
]
"
)
;
}
if
(
GetTransformIsPerspective
(
)
)
{
aStream
<
<
"
[
perspective
]
"
;
}
if
(
!
mVisibleRegion
.
IsEmpty
(
)
)
{
AppendToString
(
aStream
mVisibleRegion
.
ToUnknownRegion
(
)
"
[
visible
=
"
"
]
"
)
;
}
else
{
aStream
<
<
"
[
not
visible
]
"
;
}
if
(
!
mEventRegions
.
IsEmpty
(
)
)
{
AppendToString
(
aStream
mEventRegions
"
"
"
"
)
;
}
if
(
1
.
0
!
=
GetOpacity
(
)
)
{
aStream
<
<
nsPrintfCString
(
"
[
opacity
=
%
g
]
"
GetOpacity
(
)
)
.
get
(
)
;
}
if
(
IsOpaque
(
)
)
{
aStream
<
<
"
[
opaqueContent
]
"
;
}
if
(
GetContentFlags
(
)
&
CONTENT_COMPONENT_ALPHA
)
{
aStream
<
<
"
[
componentAlpha
]
"
;
}
if
(
GetContentFlags
(
)
&
CONTENT_BACKFACE_HIDDEN
)
{
aStream
<
<
"
[
backfaceHidden
]
"
;
}
if
(
Extend3DContext
(
)
)
{
aStream
<
<
"
[
extend3DContext
]
"
;
}
if
(
Combines3DTransformWithAncestors
(
)
)
{
aStream
<
<
"
[
combines3DTransformWithAncestors
]
"
;
}
if
(
Is3DContextLeaf
(
)
)
{
aStream
<
<
"
[
is3DContextLeaf
]
"
;
}
if
(
IsScrollbarContainer
(
)
)
{
aStream
<
<
"
[
scrollbar
]
"
;
}
if
(
GetScrollbarData
(
)
.
IsThumb
(
)
)
{
if
(
Maybe
<
ScrollDirection
>
thumbDirection
=
GetScrollbarData
(
)
.
mDirection
)
{
if
(
*
thumbDirection
=
=
ScrollDirection
:
:
eVertical
)
{
aStream
<
<
nsPrintfCString
(
"
[
vscrollbar
=
%
"
PRIu64
"
]
"
GetScrollbarData
(
)
.
mTargetViewId
)
.
get
(
)
;
}
if
(
*
thumbDirection
=
=
ScrollDirection
:
:
eHorizontal
)
{
aStream
<
<
nsPrintfCString
(
"
[
hscrollbar
=
%
"
PRIu64
"
]
"
GetScrollbarData
(
)
.
mTargetViewId
)
.
get
(
)
;
}
}
}
if
(
GetIsFixedPosition
(
)
)
{
LayerPoint
anchor
=
GetFixedPositionAnchor
(
)
;
aStream
<
<
nsPrintfCString
(
"
[
isFixedPosition
scrollId
=
%
"
PRIu64
"
sides
=
0x
%
x
anchor
=
%
s
]
"
GetFixedPositionScrollContainerId
(
)
GetFixedPositionSides
(
)
ToString
(
anchor
)
.
c_str
(
)
)
.
get
(
)
;
}
if
(
GetIsStickyPosition
(
)
)
{
aStream
<
<
nsPrintfCString
(
"
[
isStickyPosition
scrollId
=
%
"
PRIu64
"
outer
=
(
%
.
3f
%
.
3f
)
-
(
%
.
3f
%
.
3f
)
"
"
inner
=
(
%
.
3f
%
.
3f
)
-
(
%
.
3f
%
.
3f
)
]
"
GetStickyScrollContainerId
(
)
GetStickyScrollRangeOuter
(
)
.
X
(
)
GetStickyScrollRangeOuter
(
)
.
Y
(
)
GetStickyScrollRangeOuter
(
)
.
XMost
(
)
GetStickyScrollRangeOuter
(
)
.
YMost
(
)
GetStickyScrollRangeInner
(
)
.
X
(
)
GetStickyScrollRangeInner
(
)
.
Y
(
)
GetStickyScrollRangeInner
(
)
.
XMost
(
)
GetStickyScrollRangeInner
(
)
.
YMost
(
)
)
.
get
(
)
;
}
if
(
mMaskLayer
)
{
aStream
<
<
nsPrintfCString
(
"
[
mMaskLayer
=
%
p
]
"
mMaskLayer
.
get
(
)
)
.
get
(
)
;
}
for
(
uint32_t
i
=
0
;
i
<
mScrollMetadata
.
Length
(
)
;
i
+
+
)
{
if
(
!
mScrollMetadata
[
i
]
.
IsDefault
(
)
)
{
aStream
<
<
nsPrintfCString
(
"
[
metrics
%
d
=
"
i
)
.
get
(
)
;
AppendToString
(
aStream
mScrollMetadata
[
i
]
"
"
"
]
"
)
;
}
}
if
(
!
mAnimationInfo
.
GetAnimations
(
)
.
IsEmpty
(
)
)
{
aStream
<
<
nsPrintfCString
(
"
[
%
d
animations
with
id
=
%
"
PRIu64
"
]
"
(
int
)
mAnimationInfo
.
GetAnimations
(
)
.
Length
(
)
mAnimationInfo
.
GetCompositorAnimationsId
(
)
)
.
get
(
)
;
}
}
static
void
DumpTransform
(
layerscope
:
:
LayersPacket
:
:
Layer
:
:
Matrix
*
aLayerMatrix
const
Matrix4x4
&
aMatrix
)
{
aLayerMatrix
-
>
set_is2d
(
aMatrix
.
Is2D
(
)
)
;
if
(
aMatrix
.
Is2D
(
)
)
{
Matrix
m
=
aMatrix
.
As2D
(
)
;
aLayerMatrix
-
>
set_isid
(
m
.
IsIdentity
(
)
)
;
if
(
!
m
.
IsIdentity
(
)
)
{
aLayerMatrix
-
>
add_m
(
m
.
_11
)
;
aLayerMatrix
-
>
add_m
(
m
.
_12
)
;
aLayerMatrix
-
>
add_m
(
m
.
_21
)
;
aLayerMatrix
-
>
add_m
(
m
.
_22
)
;
aLayerMatrix
-
>
add_m
(
m
.
_31
)
;
aLayerMatrix
-
>
add_m
(
m
.
_32
)
;
}
}
else
{
aLayerMatrix
-
>
add_m
(
aMatrix
.
_11
)
;
aLayerMatrix
-
>
add_m
(
aMatrix
.
_12
)
;
aLayerMatrix
-
>
add_m
(
aMatrix
.
_13
)
;
aLayerMatrix
-
>
add_m
(
aMatrix
.
_14
)
;
aLayerMatrix
-
>
add_m
(
aMatrix
.
_21
)
;
aLayerMatrix
-
>
add_m
(
aMatrix
.
_22
)
;
aLayerMatrix
-
>
add_m
(
aMatrix
.
_23
)
;
aLayerMatrix
-
>
add_m
(
aMatrix
.
_24
)
;
aLayerMatrix
-
>
add_m
(
aMatrix
.
_31
)
;
aLayerMatrix
-
>
add_m
(
aMatrix
.
_32
)
;
aLayerMatrix
-
>
add_m
(
aMatrix
.
_33
)
;
aLayerMatrix
-
>
add_m
(
aMatrix
.
_34
)
;
aLayerMatrix
-
>
add_m
(
aMatrix
.
_41
)
;
aLayerMatrix
-
>
add_m
(
aMatrix
.
_42
)
;
aLayerMatrix
-
>
add_m
(
aMatrix
.
_43
)
;
aLayerMatrix
-
>
add_m
(
aMatrix
.
_44
)
;
}
}
template
<
typename
T
typename
Sub
typename
Point
typename
SizeT
typename
MarginT
>
static
void
DumpRect
(
layerscope
:
:
LayersPacket
:
:
Layer
:
:
Rect
*
aLayerRect
const
BaseRect
<
T
Sub
Point
SizeT
MarginT
>
&
aRect
)
{
aLayerRect
-
>
set_x
(
aRect
.
X
(
)
)
;
aLayerRect
-
>
set_y
(
aRect
.
Y
(
)
)
;
aLayerRect
-
>
set_w
(
aRect
.
Width
(
)
)
;
aLayerRect
-
>
set_h
(
aRect
.
Height
(
)
)
;
}
static
void
DumpRegion
(
layerscope
:
:
LayersPacket
:
:
Layer
:
:
Region
*
aLayerRegion
const
nsIntRegion
&
aRegion
)
{
for
(
auto
iter
=
aRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
DumpRect
(
aLayerRegion
-
>
add_r
(
)
iter
.
Get
(
)
)
;
}
}
void
Layer
:
:
DumpPacket
(
layerscope
:
:
LayersPacket
*
aPacket
const
void
*
aParent
)
{
using
namespace
layerscope
;
LayersPacket
:
:
Layer
*
layer
=
aPacket
-
>
add_layer
(
)
;
layer
-
>
set_type
(
LayersPacket
:
:
Layer
:
:
UnknownLayer
)
;
layer
-
>
set_ptr
(
reinterpret_cast
<
uint64_t
>
(
this
)
)
;
layer
-
>
set_parentptr
(
reinterpret_cast
<
uint64_t
>
(
aParent
)
)
;
if
(
HostLayer
*
lc
=
AsHostLayer
(
)
)
{
LayersPacket
:
:
Layer
:
:
Shadow
*
s
=
layer
-
>
mutable_shadow
(
)
;
if
(
const
Maybe
<
ParentLayerIntRect
>
&
clipRect
=
lc
-
>
GetShadowClipRect
(
)
)
{
DumpRect
(
s
-
>
mutable_clip
(
)
*
clipRect
)
;
}
if
(
!
lc
-
>
GetShadowBaseTransform
(
)
.
IsIdentity
(
)
)
{
DumpTransform
(
s
-
>
mutable_transform
(
)
lc
-
>
GetShadowBaseTransform
(
)
)
;
}
if
(
!
lc
-
>
GetShadowVisibleRegion
(
)
.
IsEmpty
(
)
)
{
DumpRegion
(
s
-
>
mutable_vregion
(
)
lc
-
>
GetShadowVisibleRegion
(
)
.
ToUnknownRegion
(
)
)
;
}
}
if
(
mClipRect
)
{
DumpRect
(
layer
-
>
mutable_clip
(
)
*
mClipRect
)
;
}
if
(
!
GetBaseTransform
(
)
.
IsIdentity
(
)
)
{
DumpTransform
(
layer
-
>
mutable_transform
(
)
GetBaseTransform
(
)
)
;
}
if
(
!
mVisibleRegion
.
ToUnknownRegion
(
)
.
IsEmpty
(
)
)
{
DumpRegion
(
layer
-
>
mutable_vregion
(
)
mVisibleRegion
.
ToUnknownRegion
(
)
)
;
}
if
(
!
mEventRegions
.
IsEmpty
(
)
)
{
const
EventRegions
&
e
=
mEventRegions
;
if
(
!
e
.
mHitRegion
.
IsEmpty
(
)
)
{
DumpRegion
(
layer
-
>
mutable_hitregion
(
)
e
.
mHitRegion
)
;
}
if
(
!
e
.
mDispatchToContentHitRegion
.
IsEmpty
(
)
)
{
DumpRegion
(
layer
-
>
mutable_dispatchregion
(
)
e
.
mDispatchToContentHitRegion
)
;
}
if
(
!
e
.
mNoActionRegion
.
IsEmpty
(
)
)
{
DumpRegion
(
layer
-
>
mutable_noactionregion
(
)
e
.
mNoActionRegion
)
;
}
if
(
!
e
.
mHorizontalPanRegion
.
IsEmpty
(
)
)
{
DumpRegion
(
layer
-
>
mutable_hpanregion
(
)
e
.
mHorizontalPanRegion
)
;
}
if
(
!
e
.
mVerticalPanRegion
.
IsEmpty
(
)
)
{
DumpRegion
(
layer
-
>
mutable_vpanregion
(
)
e
.
mVerticalPanRegion
)
;
}
}
layer
-
>
set_opacity
(
GetOpacity
(
)
)
;
layer
-
>
set_copaque
(
static_cast
<
bool
>
(
GetContentFlags
(
)
&
CONTENT_OPAQUE
)
)
;
layer
-
>
set_calpha
(
static_cast
<
bool
>
(
GetContentFlags
(
)
&
CONTENT_COMPONENT_ALPHA
)
)
;
if
(
GetScrollbarData
(
)
.
mScrollbarLayerType
=
=
layers
:
:
ScrollbarLayerType
:
:
Thumb
)
{
layer
-
>
set_direct
(
*
GetScrollbarData
(
)
.
mDirection
=
=
ScrollDirection
:
:
eVertical
?
LayersPacket
:
:
Layer
:
:
VERTICAL
:
LayersPacket
:
:
Layer
:
:
HORIZONTAL
)
;
layer
-
>
set_barid
(
GetScrollbarData
(
)
.
mTargetViewId
)
;
}
if
(
mMaskLayer
)
{
layer
-
>
set_mask
(
reinterpret_cast
<
uint64_t
>
(
mMaskLayer
.
get
(
)
)
)
;
}
if
(
mDisplayListLog
.
Length
(
)
>
0
)
{
layer
-
>
set_displaylistloglength
(
mDisplayListLog
.
Length
(
)
)
;
auto
compressedData
=
MakeUnique
<
char
[
]
>
(
LZ4
:
:
maxCompressedSize
(
mDisplayListLog
.
Length
(
)
)
)
;
int
compressedSize
=
LZ4
:
:
compress
(
(
char
*
)
mDisplayListLog
.
get
(
)
mDisplayListLog
.
Length
(
)
compressedData
.
get
(
)
)
;
layer
-
>
set_displaylistlog
(
compressedData
.
get
(
)
compressedSize
)
;
}
}
bool
Layer
:
:
IsBackfaceHidden
(
)
{
if
(
GetContentFlags
(
)
&
CONTENT_BACKFACE_HIDDEN
)
{
Layer
*
container
=
AsContainerLayer
(
)
?
this
:
GetParent
(
)
;
if
(
container
)
{
if
(
container
-
>
Extend3DContext
(
)
|
|
container
-
>
Is3DContextLeaf
(
)
)
{
return
container
-
>
GetEffectiveTransform
(
)
.
IsBackfaceVisible
(
)
;
}
return
container
-
>
GetBaseTransform
(
)
.
IsBackfaceVisible
(
)
;
}
}
return
false
;
}
UniquePtr
<
LayerUserData
>
Layer
:
:
RemoveUserData
(
void
*
aKey
)
{
UniquePtr
<
LayerUserData
>
d
(
static_cast
<
LayerUserData
*
>
(
mUserData
.
Remove
(
static_cast
<
gfx
:
:
UserDataKey
*
>
(
aKey
)
)
)
)
;
return
d
;
}
void
Layer
:
:
SetManager
(
LayerManager
*
aManager
HostLayer
*
aSelf
)
{
MOZ_ASSERT
(
aSelf
)
;
MOZ_ASSERT
(
aSelf
-
>
GetLayer
(
)
=
=
this
)
;
mManager
=
aManager
;
}
void
PaintedLayer
:
:
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
{
Layer
:
:
PrintInfo
(
aStream
aPrefix
)
;
nsIntRegion
validRegion
=
GetValidRegion
(
)
;
if
(
!
validRegion
.
IsEmpty
(
)
)
{
AppendToString
(
aStream
validRegion
"
[
valid
=
"
"
]
"
)
;
}
}
void
PaintedLayer
:
:
DumpPacket
(
layerscope
:
:
LayersPacket
*
aPacket
const
void
*
aParent
)
{
Layer
:
:
DumpPacket
(
aPacket
aParent
)
;
using
namespace
layerscope
;
LayersPacket
:
:
Layer
*
layer
=
aPacket
-
>
mutable_layer
(
aPacket
-
>
layer_size
(
)
-
1
)
;
layer
-
>
set_type
(
LayersPacket
:
:
Layer
:
:
PaintedLayer
)
;
nsIntRegion
validRegion
=
GetValidRegion
(
)
;
if
(
!
validRegion
.
IsEmpty
(
)
)
{
DumpRegion
(
layer
-
>
mutable_valid
(
)
validRegion
)
;
}
}
void
ContainerLayer
:
:
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
{
Layer
:
:
PrintInfo
(
aStream
aPrefix
)
;
if
(
UseIntermediateSurface
(
)
)
{
aStream
<
<
"
[
usesTmpSurf
]
"
;
}
if
(
1
.
0
!
=
mPreXScale
|
|
1
.
0
!
=
mPreYScale
)
{
aStream
<
<
nsPrintfCString
(
"
[
preScale
=
%
g
%
g
]
"
mPreXScale
mPreYScale
)
.
get
(
)
;
}
if
(
mScaleToResolution
)
{
aStream
<
<
nsPrintfCString
(
"
[
presShellResolution
=
%
g
]
"
mPresShellResolution
)
.
get
(
)
;
}
}
void
ContainerLayer
:
:
DumpPacket
(
layerscope
:
:
LayersPacket
*
aPacket
const
void
*
aParent
)
{
Layer
:
:
DumpPacket
(
aPacket
aParent
)
;
using
namespace
layerscope
;
LayersPacket
:
:
Layer
*
layer
=
aPacket
-
>
mutable_layer
(
aPacket
-
>
layer_size
(
)
-
1
)
;
layer
-
>
set_type
(
LayersPacket
:
:
Layer
:
:
ContainerLayer
)
;
}
void
ColorLayer
:
:
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
{
Layer
:
:
PrintInfo
(
aStream
aPrefix
)
;
AppendToString
(
aStream
mColor
"
[
color
=
"
"
]
"
)
;
AppendToString
(
aStream
mBounds
"
[
bounds
=
"
"
]
"
)
;
}
void
ColorLayer
:
:
DumpPacket
(
layerscope
:
:
LayersPacket
*
aPacket
const
void
*
aParent
)
{
Layer
:
:
DumpPacket
(
aPacket
aParent
)
;
using
namespace
layerscope
;
LayersPacket
:
:
Layer
*
layer
=
aPacket
-
>
mutable_layer
(
aPacket
-
>
layer_size
(
)
-
1
)
;
layer
-
>
set_type
(
LayersPacket
:
:
Layer
:
:
ColorLayer
)
;
layer
-
>
set_color
(
mColor
.
ToABGR
(
)
)
;
}
CanvasLayer
:
:
CanvasLayer
(
LayerManager
*
aManager
void
*
aImplData
)
:
Layer
(
aManager
aImplData
)
mSamplingFilter
(
SamplingFilter
:
:
GOOD
)
{
}
CanvasLayer
:
:
~
CanvasLayer
(
)
=
default
;
void
CanvasLayer
:
:
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
{
Layer
:
:
PrintInfo
(
aStream
aPrefix
)
;
if
(
mSamplingFilter
!
=
SamplingFilter
:
:
GOOD
)
{
AppendToString
(
aStream
mSamplingFilter
"
[
filter
=
"
"
]
"
)
;
}
}
static
void
DumpFilter
(
layerscope
:
:
LayersPacket
:
:
Layer
*
aLayer
const
SamplingFilter
&
aSamplingFilter
)
{
using
namespace
layerscope
;
switch
(
aSamplingFilter
)
{
case
SamplingFilter
:
:
GOOD
:
aLayer
-
>
set_filter
(
LayersPacket
:
:
Layer
:
:
FILTER_GOOD
)
;
break
;
case
SamplingFilter
:
:
LINEAR
:
aLayer
-
>
set_filter
(
LayersPacket
:
:
Layer
:
:
FILTER_LINEAR
)
;
break
;
case
SamplingFilter
:
:
POINT
:
aLayer
-
>
set_filter
(
LayersPacket
:
:
Layer
:
:
FILTER_POINT
)
;
break
;
default
:
break
;
}
}
void
CanvasLayer
:
:
DumpPacket
(
layerscope
:
:
LayersPacket
*
aPacket
const
void
*
aParent
)
{
Layer
:
:
DumpPacket
(
aPacket
aParent
)
;
using
namespace
layerscope
;
LayersPacket
:
:
Layer
*
layer
=
aPacket
-
>
mutable_layer
(
aPacket
-
>
layer_size
(
)
-
1
)
;
layer
-
>
set_type
(
LayersPacket
:
:
Layer
:
:
CanvasLayer
)
;
DumpFilter
(
layer
mSamplingFilter
)
;
}
CanvasRenderer
*
CanvasLayer
:
:
CreateOrGetCanvasRenderer
(
)
{
if
(
!
mCanvasRenderer
)
{
mCanvasRenderer
.
reset
(
CreateCanvasRendererInternal
(
)
)
;
}
return
mCanvasRenderer
.
get
(
)
;
}
void
ImageLayer
:
:
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
{
Layer
:
:
PrintInfo
(
aStream
aPrefix
)
;
if
(
mSamplingFilter
!
=
SamplingFilter
:
:
GOOD
)
{
AppendToString
(
aStream
mSamplingFilter
"
[
filter
=
"
"
]
"
)
;
}
}
void
ImageLayer
:
:
DumpPacket
(
layerscope
:
:
LayersPacket
*
aPacket
const
void
*
aParent
)
{
Layer
:
:
DumpPacket
(
aPacket
aParent
)
;
using
namespace
layerscope
;
LayersPacket
:
:
Layer
*
layer
=
aPacket
-
>
mutable_layer
(
aPacket
-
>
layer_size
(
)
-
1
)
;
layer
-
>
set_type
(
LayersPacket
:
:
Layer
:
:
ImageLayer
)
;
DumpFilter
(
layer
mSamplingFilter
)
;
}
void
RefLayer
:
:
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
{
ContainerLayer
:
:
PrintInfo
(
aStream
aPrefix
)
;
if
(
mId
.
IsValid
(
)
)
{
AppendToString
(
aStream
uint64_t
(
mId
)
"
[
id
=
"
"
]
"
)
;
}
if
(
mEventRegionsOverride
&
EventRegionsOverride
:
:
ForceDispatchToContent
)
{
aStream
<
<
"
[
force
-
dtc
]
"
;
}
if
(
mEventRegionsOverride
&
EventRegionsOverride
:
:
ForceEmptyHitRegion
)
{
aStream
<
<
"
[
force
-
ehr
]
"
;
}
}
void
RefLayer
:
:
DumpPacket
(
layerscope
:
:
LayersPacket
*
aPacket
const
void
*
aParent
)
{
Layer
:
:
DumpPacket
(
aPacket
aParent
)
;
using
namespace
layerscope
;
LayersPacket
:
:
Layer
*
layer
=
aPacket
-
>
mutable_layer
(
aPacket
-
>
layer_size
(
)
-
1
)
;
layer
-
>
set_type
(
LayersPacket
:
:
Layer
:
:
RefLayer
)
;
layer
-
>
set_refid
(
uint64_t
(
mId
)
)
;
}
void
ReadbackLayer
:
:
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
{
Layer
:
:
PrintInfo
(
aStream
aPrefix
)
;
AppendToString
(
aStream
mSize
"
[
size
=
"
"
]
"
)
;
if
(
mBackgroundLayer
)
{
AppendToString
(
aStream
mBackgroundLayer
"
[
backgroundLayer
=
"
"
]
"
)
;
AppendToString
(
aStream
mBackgroundLayerOffset
"
[
backgroundOffset
=
"
"
]
"
)
;
}
else
if
(
mBackgroundColor
.
a
=
=
1
.
f
)
{
AppendToString
(
aStream
mBackgroundColor
"
[
backgroundColor
=
"
"
]
"
)
;
}
else
{
aStream
<
<
"
[
nobackground
]
"
;
}
}
void
ReadbackLayer
:
:
DumpPacket
(
layerscope
:
:
LayersPacket
*
aPacket
const
void
*
aParent
)
{
Layer
:
:
DumpPacket
(
aPacket
aParent
)
;
using
namespace
layerscope
;
LayersPacket
:
:
Layer
*
layer
=
aPacket
-
>
mutable_layer
(
aPacket
-
>
layer_size
(
)
-
1
)
;
layer
-
>
set_type
(
LayersPacket
:
:
Layer
:
:
ReadbackLayer
)
;
LayersPacket
:
:
Layer
:
:
Size
*
size
=
layer
-
>
mutable_size
(
)
;
size
-
>
set_w
(
mSize
.
width
)
;
size
-
>
set_h
(
mSize
.
height
)
;
}
void
LayerManager
:
:
Dump
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
bool
aDumpHtml
bool
aSorted
)
{
#
ifdef
MOZ_DUMP_PAINTING
if
(
aDumpHtml
)
{
aStream
<
<
"
<
ul
>
<
li
>
"
;
}
#
endif
DumpSelf
(
aStream
aPrefix
aSorted
)
;
nsAutoCString
pfx
(
aPrefix
)
;
pfx
+
=
"
"
;
if
(
!
GetRoot
(
)
)
{
aStream
<
<
nsPrintfCString
(
"
%
s
(
null
)
\
n
"
pfx
.
get
(
)
)
.
get
(
)
;
if
(
aDumpHtml
)
{
aStream
<
<
"
<
/
li
>
<
/
ul
>
"
;
}
return
;
}
if
(
aDumpHtml
)
{
aStream
<
<
"
<
ul
>
"
;
}
GetRoot
(
)
-
>
Dump
(
aStream
pfx
.
get
(
)
aDumpHtml
aSorted
)
;
if
(
aDumpHtml
)
{
aStream
<
<
"
<
/
ul
>
<
/
li
>
<
/
ul
>
"
;
}
aStream
<
<
"
\
n
"
;
}
void
LayerManager
:
:
DumpSelf
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
bool
aSorted
)
{
PrintInfo
(
aStream
aPrefix
)
;
aStream
<
<
"
-
-
-
in
"
<
<
(
aSorted
?
"
3D
-
sorted
rendering
order
"
:
"
content
order
"
)
;
aStream
<
<
"
\
n
"
;
}
void
LayerManager
:
:
Dump
(
bool
aSorted
)
{
std
:
:
stringstream
ss
;
Dump
(
ss
"
"
false
aSorted
)
;
print_stderr
(
ss
)
;
}
void
LayerManager
:
:
Dump
(
layerscope
:
:
LayersPacket
*
aPacket
)
{
DumpPacket
(
aPacket
)
;
if
(
GetRoot
(
)
)
{
GetRoot
(
)
-
>
Dump
(
aPacket
this
)
;
}
}
void
LayerManager
:
:
Log
(
const
char
*
aPrefix
)
{
if
(
!
IsLogEnabled
(
)
)
return
;
LogSelf
(
aPrefix
)
;
nsAutoCString
pfx
(
aPrefix
)
;
pfx
+
=
"
"
;
if
(
!
GetRoot
(
)
)
{
MOZ_LAYERS_LOG
(
(
"
%
s
(
null
)
"
pfx
.
get
(
)
)
)
;
return
;
}
GetRoot
(
)
-
>
Log
(
pfx
.
get
(
)
)
;
}
void
LayerManager
:
:
LogSelf
(
const
char
*
aPrefix
)
{
nsAutoCString
str
;
std
:
:
stringstream
ss
;
PrintInfo
(
ss
aPrefix
)
;
MOZ_LAYERS_LOG
(
(
"
%
s
"
ss
.
str
(
)
.
c_str
(
)
)
)
;
}
void
LayerManager
:
:
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
{
aStream
<
<
aPrefix
<
<
nsPrintfCString
(
"
%
sLayerManager
(
0x
%
p
)
"
Name
(
)
this
)
.
get
(
)
;
}
void
LayerManager
:
:
DumpPacket
(
layerscope
:
:
LayersPacket
*
aPacket
)
{
using
namespace
layerscope
;
LayersPacket
:
:
Layer
*
layer
=
aPacket
-
>
add_layer
(
)
;
layer
-
>
set_type
(
LayersPacket
:
:
Layer
:
:
LayerManager
)
;
layer
-
>
set_ptr
(
reinterpret_cast
<
uint64_t
>
(
this
)
)
;
layer
-
>
set_parentptr
(
0
)
;
}
bool
LayerManager
:
:
IsLogEnabled
(
)
{
return
MOZ_LOG_TEST
(
GetLog
(
)
LogLevel
:
:
Debug
)
;
}
bool
LayerManager
:
:
SetPendingScrollUpdateForNextTransaction
(
FrameMetrics
:
:
ViewID
aScrollId
const
ScrollUpdateInfo
&
aUpdateInfo
)
{
Layer
*
withPendingTransform
=
DepthFirstSearch
<
ForwardIterator
>
(
GetRoot
(
)
[
]
(
Layer
*
aLayer
)
{
return
aLayer
-
>
HasPendingTransform
(
)
;
}
)
;
if
(
withPendingTransform
)
{
return
false
;
}
mPendingScrollUpdates
[
aScrollId
]
=
aUpdateInfo
;
return
true
;
}
Maybe
<
ScrollUpdateInfo
>
LayerManager
:
:
GetPendingScrollInfoUpdate
(
FrameMetrics
:
:
ViewID
aScrollId
)
{
auto
it
=
mPendingScrollUpdates
.
find
(
aScrollId
)
;
if
(
it
!
=
mPendingScrollUpdates
.
end
(
)
)
{
return
Some
(
it
-
>
second
)
;
}
return
Nothing
(
)
;
}
void
LayerManager
:
:
ClearPendingScrollInfoUpdate
(
)
{
mPendingScrollUpdates
.
clear
(
)
;
}
void
PrintInfo
(
std
:
:
stringstream
&
aStream
HostLayer
*
aLayerComposite
)
{
if
(
!
aLayerComposite
)
{
return
;
}
if
(
const
Maybe
<
ParentLayerIntRect
>
&
clipRect
=
aLayerComposite
-
>
GetShadowClipRect
(
)
)
{
AppendToString
(
aStream
*
clipRect
"
[
shadow
-
clip
=
"
"
]
"
)
;
}
if
(
!
aLayerComposite
-
>
GetShadowBaseTransform
(
)
.
IsIdentity
(
)
)
{
AppendToString
(
aStream
aLayerComposite
-
>
GetShadowBaseTransform
(
)
"
[
shadow
-
transform
=
"
"
]
"
)
;
}
if
(
!
aLayerComposite
-
>
GetShadowVisibleRegion
(
)
.
IsEmpty
(
)
)
{
AppendToString
(
aStream
aLayerComposite
-
>
GetShadowVisibleRegion
(
)
.
ToUnknownRegion
(
)
"
[
shadow
-
visible
=
"
"
]
"
)
;
}
}
void
SetAntialiasingFlags
(
Layer
*
aLayer
DrawTarget
*
aTarget
)
{
bool
permitSubpixelAA
=
!
(
aLayer
-
>
GetContentFlags
(
)
&
Layer
:
:
CONTENT_DISABLE_SUBPIXEL_AA
)
;
if
(
aTarget
-
>
IsCurrentGroupOpaque
(
)
)
{
aTarget
-
>
SetPermitSubpixelAA
(
permitSubpixelAA
)
;
return
;
}
const
IntRect
&
bounds
=
aLayer
-
>
GetVisibleRegion
(
)
.
ToUnknownRegion
(
)
.
GetBounds
(
)
;
gfx
:
:
Rect
transformedBounds
=
aTarget
-
>
GetTransform
(
)
.
TransformBounds
(
gfx
:
:
Rect
(
Float
(
bounds
.
X
(
)
)
Float
(
bounds
.
Y
(
)
)
Float
(
bounds
.
Width
(
)
)
Float
(
bounds
.
Height
(
)
)
)
)
;
transformedBounds
.
RoundOut
(
)
;
IntRect
intTransformedBounds
;
transformedBounds
.
ToIntRect
(
&
intTransformedBounds
)
;
permitSubpixelAA
&
=
!
(
aLayer
-
>
GetContentFlags
(
)
&
Layer
:
:
CONTENT_COMPONENT_ALPHA
)
|
|
aTarget
-
>
GetOpaqueRect
(
)
.
Contains
(
intTransformedBounds
)
;
aTarget
-
>
SetPermitSubpixelAA
(
permitSubpixelAA
)
;
}
IntRect
ToOutsideIntRect
(
const
gfxRect
&
aRect
)
{
return
IntRect
:
:
RoundOut
(
aRect
.
X
(
)
aRect
.
Y
(
)
aRect
.
Width
(
)
aRect
.
Height
(
)
)
;
}
}
}
