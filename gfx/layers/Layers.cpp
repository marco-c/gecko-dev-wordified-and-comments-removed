#
include
"
Layers
.
h
"
#
include
<
inttypes
.
h
>
#
include
<
stdio
.
h
>
#
include
<
algorithm
>
#
include
<
list
>
#
include
<
set
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
"
CompositableHost
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
LayerUserData
.
h
"
#
include
"
ReadbackLayer
.
h
"
#
include
"
TreeTraversal
.
h
"
#
include
"
UnitTransforms
.
h
"
#
include
"
apz
/
src
/
AsyncPanZoomController
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxEnv
.
h
"
#
include
"
gfxMatrix
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
ArrayIterator
.
h
"
#
include
"
mozilla
/
BaseProfilerMarkersPrerequisites
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
ScrollPositionUpdate
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TelemetryHistogramEnums
.
h
"
#
include
"
mozilla
/
ToString
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
BasePoint3D
.
h
"
#
include
"
mozilla
/
gfx
/
BaseRect
.
h
"
#
include
"
mozilla
/
gfx
/
BaseSize
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
mozilla
/
gfx
/
MatrixFwd
.
h
"
#
include
"
mozilla
/
gfx
/
Polygon
.
h
"
#
include
"
mozilla
/
layers
/
BSPTree
.
h
"
#
include
"
mozilla
/
layers
/
CompositableClient
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
nsBaseHashtable
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsRegionFwd
.
h
"
#
include
"
nsString
.
h
"
#
undef
compress
#
include
"
mozilla
/
Compression
.
h
"
namespace
mozilla
{
namespace
layers
{
typedef
ScrollableLayerGuid
:
:
ViewID
ViewID
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
Compression
;
Layer
:
:
Layer
(
LayerManager
*
aManager
void
*
aImplData
)
:
mManager
(
aManager
)
mParent
(
nullptr
)
mNextSibling
(
nullptr
)
mPrevSibling
(
nullptr
)
mImplData
(
aImplData
)
mUseTileSourceRect
(
false
)
#
ifdef
DEBUG
mDebugColorIndex
(
0
)
#
endif
{
}
Layer
:
:
~
Layer
(
)
=
default
;
void
Layer
:
:
SetEventRegions
(
const
EventRegions
&
aRegions
)
{
if
(
mEventRegions
!
=
aRegions
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
eventregions
were
%
s
now
%
s
"
this
ToString
(
mEventRegions
)
.
c_str
(
)
ToString
(
aRegions
)
.
c_str
(
)
)
)
;
mEventRegions
=
aRegions
;
Mutated
(
)
;
}
}
void
Layer
:
:
SetCompositorAnimations
(
const
LayersId
&
aLayersId
const
CompositorAnimations
&
aCompositorAnimations
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
SetCompositorAnimations
with
id
=
%
"
PRIu64
this
mAnimationInfo
.
GetCompositorAnimationsId
(
)
)
)
;
mAnimationInfo
.
SetCompositorAnimations
(
aLayersId
aCompositorAnimations
)
;
Mutated
(
)
;
}
void
Layer
:
:
ClearCompositorAnimations
(
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
ClearCompositorAnimations
with
id
=
%
"
PRIu64
this
mAnimationInfo
.
GetCompositorAnimationsId
(
)
)
)
;
mAnimationInfo
.
ClearAnimations
(
)
;
Mutated
(
)
;
}
void
Layer
:
:
StartPendingAnimations
(
const
TimeStamp
&
aReadyTime
)
{
ForEachNode
<
ForwardIterator
>
(
this
[
&
aReadyTime
]
(
Layer
*
layer
)
{
if
(
layer
-
>
mAnimationInfo
.
StartPendingAnimations
(
aReadyTime
)
)
{
layer
-
>
Mutated
(
)
;
}
}
)
;
}
void
Layer
:
:
SetAsyncPanZoomController
(
uint32_t
aIndex
AsyncPanZoomController
*
controller
)
{
MOZ_ASSERT
(
aIndex
<
GetScrollMetadataCount
(
)
)
;
MOZ_ASSERT
(
!
controller
|
|
GetFrameMetrics
(
aIndex
)
.
IsScrollable
(
)
)
;
mApzcs
[
aIndex
]
=
controller
;
}
AsyncPanZoomController
*
Layer
:
:
GetAsyncPanZoomController
(
uint32_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
GetScrollMetadataCount
(
)
)
;
#
ifdef
DEBUG
if
(
mApzcs
[
aIndex
]
)
{
MOZ_ASSERT
(
GetFrameMetrics
(
aIndex
)
.
IsScrollable
(
)
)
;
}
#
endif
return
mApzcs
[
aIndex
]
;
}
void
Layer
:
:
ScrollMetadataChanged
(
)
{
mApzcs
.
SetLength
(
GetScrollMetadataCount
(
)
)
;
}
std
:
:
unordered_set
<
ScrollableLayerGuid
:
:
ViewID
>
Layer
:
:
ApplyPendingUpdatesToSubtree
(
)
{
ForEachNode
<
ForwardIterator
>
(
this
[
]
(
Layer
*
layer
)
{
layer
-
>
ApplyPendingUpdatesForThisTransaction
(
)
;
}
)
;
return
Manager
(
)
-
>
ClearPendingScrollInfoUpdate
(
)
;
}
bool
Layer
:
:
IsOpaqueForVisibility
(
)
{
return
GetEffectiveOpacity
(
)
=
=
1
.
0f
&
&
GetEffectiveMixBlendMode
(
)
=
=
CompositionOp
:
:
OP_OVER
;
}
bool
Layer
:
:
CanUseOpaqueSurface
(
)
{
return
false
;
}
const
Maybe
<
ParentLayerIntRect
>
&
Layer
:
:
GetLocalClipRect
(
)
{
return
GetClipRect
(
)
;
}
const
LayerIntRegion
&
Layer
:
:
GetLocalVisibleRegion
(
)
{
return
GetVisibleRegion
(
)
;
}
Matrix4x4
Layer
:
:
SnapTransformTranslation
(
const
Matrix4x4
&
aTransform
Matrix
*
aResidualTransform
)
{
if
(
aResidualTransform
)
{
*
aResidualTransform
=
Matrix
(
)
;
}
if
(
!
mManager
-
>
IsSnappingEffectiveTransforms
(
)
)
{
return
aTransform
;
}
return
gfxUtils
:
:
SnapTransformTranslation
(
aTransform
aResidualTransform
)
;
}
Matrix4x4
Layer
:
:
SnapTransformTranslation3D
(
const
Matrix4x4
&
aTransform
Matrix
*
aResidualTransform
)
{
return
gfxUtils
:
:
SnapTransformTranslation3D
(
aTransform
aResidualTransform
)
;
}
Matrix4x4
Layer
:
:
SnapTransform
(
const
Matrix4x4
&
aTransform
const
gfxRect
&
aSnapRect
Matrix
*
aResidualTransform
)
{
if
(
aResidualTransform
)
{
*
aResidualTransform
=
Matrix
(
)
;
}
if
(
!
mManager
-
>
IsSnappingEffectiveTransforms
(
)
)
{
return
aTransform
;
}
return
gfxUtils
:
:
SnapTransform
(
aTransform
aSnapRect
aResidualTransform
)
;
}
RenderTargetIntRect
Layer
:
:
CalculateScissorRect
(
const
RenderTargetIntRect
&
aCurrentScissorRect
)
{
return
RenderTargetIntRect
(
)
;
}
const
ScrollMetadata
&
Layer
:
:
GetScrollMetadata
(
uint32_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
GetScrollMetadataCount
(
)
)
;
return
mScrollMetadata
[
aIndex
]
;
}
const
FrameMetrics
&
Layer
:
:
GetFrameMetrics
(
uint32_t
aIndex
)
const
{
return
GetScrollMetadata
(
aIndex
)
.
GetMetrics
(
)
;
}
bool
Layer
:
:
HasScrollableFrameMetrics
(
)
const
{
for
(
uint32_t
i
=
0
;
i
<
GetScrollMetadataCount
(
)
;
i
+
+
)
{
if
(
GetFrameMetrics
(
i
)
.
IsScrollable
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
Layer
:
:
IsScrollableWithoutContent
(
)
const
{
return
AsContainerLayer
(
)
&
&
HasScrollableFrameMetrics
(
)
&
&
!
GetFirstChild
(
)
;
}
Matrix4x4
Layer
:
:
GetTransform
(
)
const
{
Matrix4x4
transform
=
mSimpleAttrs
.
GetTransform
(
)
;
transform
.
PostScale
(
GetPostXScale
(
)
GetPostYScale
(
)
1
.
0f
)
;
return
transform
;
}
const
CSSTransformMatrix
Layer
:
:
GetTransformTyped
(
)
const
{
return
ViewAs
<
CSSTransformMatrix
>
(
GetTransform
(
)
)
;
}
Matrix4x4
Layer
:
:
GetLocalTransform
(
)
{
return
GetTransform
(
)
;
}
const
LayerToParentLayerMatrix4x4
Layer
:
:
GetLocalTransformTyped
(
)
{
return
ViewAs
<
LayerToParentLayerMatrix4x4
>
(
GetLocalTransform
(
)
)
;
}
bool
Layer
:
:
IsScrollbarContainer
(
)
const
{
const
ScrollbarData
&
data
=
GetScrollbarData
(
)
;
return
(
data
.
mScrollbarLayerType
=
=
ScrollbarLayerType
:
:
Container
)
?
data
.
mDirection
.
isSome
(
)
:
false
;
}
bool
Layer
:
:
HasTransformAnimation
(
)
const
{
return
mAnimationInfo
.
HasTransformAnimation
(
)
;
}
void
Layer
:
:
ApplyPendingUpdatesForThisTransaction
(
)
{
if
(
mPendingTransform
&
&
*
mPendingTransform
!
=
mSimpleAttrs
.
GetTransform
(
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
PendingUpdatesForThisTransaction
"
this
)
)
;
mSimpleAttrs
.
SetTransform
(
*
mPendingTransform
)
;
MutatedSimple
(
)
;
}
mPendingTransform
=
nullptr
;
if
(
mAnimationInfo
.
ApplyPendingUpdatesForThisTransaction
(
)
)
{
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
this
(
"
Layer
:
:
Mutated
(
%
p
)
PendingUpdatesForThisTransaction
"
this
)
)
;
Mutated
(
)
;
}
for
(
size_t
i
=
0
;
i
<
mScrollMetadata
.
Length
(
)
;
i
+
+
)
{
FrameMetrics
&
fm
=
mScrollMetadata
[
i
]
.
GetMetrics
(
)
;
ScrollableLayerGuid
:
:
ViewID
scrollId
=
fm
.
GetScrollId
(
)
;
Maybe
<
nsTArray
<
ScrollPositionUpdate
>
>
update
=
Manager
(
)
-
>
GetPendingScrollInfoUpdate
(
scrollId
)
;
if
(
update
)
{
nsTArray
<
ScrollPositionUpdate
>
infos
=
update
.
extract
(
)
;
mScrollMetadata
[
i
]
.
UpdatePendingScrollInfo
(
std
:
:
move
(
infos
)
)
;
Mutated
(
)
;
}
}
}
float
Layer
:
:
GetLocalOpacity
(
)
{
float
opacity
=
mSimpleAttrs
.
GetOpacity
(
)
;
return
std
:
:
min
(
std
:
:
max
(
opacity
0
.
0f
)
1
.
0f
)
;
}
float
Layer
:
:
GetEffectiveOpacity
(
)
{
float
opacity
=
GetLocalOpacity
(
)
;
return
opacity
;
}
CompositionOp
Layer
:
:
GetEffectiveMixBlendMode
(
)
{
return
mSimpleAttrs
.
GetMixBlendMode
(
)
;
}
Matrix4x4
Layer
:
:
ComputeTransformToPreserve3DRoot
(
)
{
Matrix4x4
transform
=
GetLocalTransform
(
)
;
for
(
Layer
*
layer
=
GetParent
(
)
;
layer
&
&
layer
-
>
Extend3DContext
(
)
;
layer
=
layer
-
>
GetParent
(
)
)
{
transform
=
transform
*
layer
-
>
GetLocalTransform
(
)
;
}
return
transform
;
}
void
Layer
:
:
ComputeEffectiveTransformForMaskLayers
(
const
gfx
:
:
Matrix4x4
&
aTransformToSurface
)
{
if
(
GetMaskLayer
(
)
)
{
ComputeEffectiveTransformForMaskLayer
(
GetMaskLayer
(
)
aTransformToSurface
)
;
}
}
void
Layer
:
:
ComputeEffectiveTransformForMaskLayer
(
Layer
*
aMaskLayer
const
gfx
:
:
Matrix4x4
&
aTransformToSurface
)
{
#
ifdef
DEBUG
bool
maskIs2D
=
aMaskLayer
-
>
GetTransform
(
)
.
CanDraw2D
(
)
;
NS_ASSERTION
(
maskIs2D
"
How
did
we
end
up
with
a
3D
transform
here
?
!
"
)
;
#
endif
aMaskLayer
-
>
mEffectiveTransform
=
aMaskLayer
-
>
SnapTransformTranslation
(
aMaskLayer
-
>
GetLocalTransform
(
)
*
aTransformToSurface
nullptr
)
;
}
RenderTargetRect
Layer
:
:
TransformRectToRenderTarget
(
const
LayerIntRect
&
aRect
)
{
LayerRect
rect
(
aRect
)
;
RenderTargetRect
quad
=
RenderTargetRect
:
:
FromUnknownRect
(
GetEffectiveTransform
(
)
.
TransformBounds
(
rect
.
ToUnknownRect
(
)
)
)
;
return
quad
;
}
bool
Layer
:
:
GetVisibleRegionRelativeToRootLayer
(
nsIntRegion
&
aResult
IntPoint
*
aLayerOffset
)
{
MOZ_ASSERT
(
aLayerOffset
"
invalid
offset
pointer
"
)
;
if
(
!
GetParent
(
)
)
{
return
false
;
}
IntPoint
offset
;
aResult
=
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
;
for
(
Layer
*
layer
=
this
;
layer
;
layer
=
layer
-
>
GetParent
(
)
)
{
gfx
:
:
Matrix
matrix
;
if
(
!
layer
-
>
GetLocalTransform
(
)
.
Is2D
(
&
matrix
)
|
|
!
matrix
.
IsTranslation
(
)
)
{
return
false
;
}
auto
currentLayerOffset
=
IntPoint
:
:
Round
(
matrix
.
GetTranslation
(
)
)
;
aResult
.
MoveBy
(
currentLayerOffset
.
x
currentLayerOffset
.
y
)
;
if
(
layer
-
>
GetLocalClipRect
(
)
)
{
aResult
.
AndWith
(
layer
-
>
GetLocalClipRect
(
)
-
>
ToUnknownRect
(
)
)
;
}
Layer
*
sibling
;
for
(
sibling
=
layer
-
>
GetNextSibling
(
)
;
sibling
;
sibling
=
sibling
-
>
GetNextSibling
(
)
)
{
gfx
:
:
Matrix
siblingMatrix
;
if
(
!
sibling
-
>
GetLocalTransform
(
)
.
Is2D
(
&
siblingMatrix
)
|
|
!
siblingMatrix
.
IsTranslation
(
)
)
{
continue
;
}
auto
siblingOffset
=
IntPoint
:
:
Round
(
siblingMatrix
.
GetTranslation
(
)
)
;
nsIntRegion
siblingVisibleRegion
(
sibling
-
>
GetLocalVisibleRegion
(
)
.
ToUnknownRegion
(
)
)
;
siblingVisibleRegion
.
MoveBy
(
-
siblingOffset
.
x
-
siblingOffset
.
y
)
;
Maybe
<
ParentLayerIntRect
>
clipRect
=
sibling
-
>
GetLocalClipRect
(
)
;
if
(
clipRect
)
{
siblingVisibleRegion
.
AndWith
(
clipRect
-
>
ToUnknownRect
(
)
)
;
}
aResult
.
SubOut
(
siblingVisibleRegion
)
;
}
offset
+
=
currentLayerOffset
;
}
*
aLayerOffset
=
IntPoint
(
offset
.
x
offset
.
y
)
;
return
true
;
}
#
ifdef
MOZ_DUMP_PAINTING
template
<
typename
T
>
void
WriteSnapshotToDumpFile_internal
(
T
*
aObj
DataSourceSurface
*
aSurf
)
{
nsCString
string
(
aObj
-
>
Name
(
)
)
;
string
.
Append
(
'
-
'
)
;
string
.
AppendInt
(
(
uint64_t
)
aObj
)
;
if
(
gfxUtils
:
:
sDumpPaintFile
!
=
stderr
)
{
fprintf_stderr
(
gfxUtils
:
:
sDumpPaintFile
R
"
(
array
[
"
%
s
"
]
=
"
)
"
string
.
BeginReading
(
)
)
;
}
gfxUtils
:
:
DumpAsDataURI
(
aSurf
gfxUtils
:
:
sDumpPaintFile
)
;
if
(
gfxUtils
:
:
sDumpPaintFile
!
=
stderr
)
{
fprintf_stderr
(
gfxUtils
:
:
sDumpPaintFile
R
"
(
"
;
)
"
)
;
}
}
void
WriteSnapshotToDumpFile
(
Layer
*
aLayer
DataSourceSurface
*
aSurf
)
{
WriteSnapshotToDumpFile_internal
(
aLayer
aSurf
)
;
}
void
WriteSnapshotToDumpFile
(
LayerManager
*
aManager
DataSourceSurface
*
aSurf
)
{
WriteSnapshotToDumpFile_internal
(
aManager
aSurf
)
;
}
void
WriteSnapshotToDumpFile
(
Compositor
*
aCompositor
DrawTarget
*
aTarget
)
{
RefPtr
<
SourceSurface
>
surf
=
aTarget
-
>
Snapshot
(
)
;
RefPtr
<
DataSourceSurface
>
dSurf
=
surf
-
>
GetDataSurface
(
)
;
WriteSnapshotToDumpFile_internal
(
aCompositor
dSurf
)
;
}
#
endif
void
Layer
:
:
SetDisplayListLog
(
const
char
*
log
)
{
if
(
gfxUtils
:
:
DumpDisplayList
(
)
)
{
mDisplayListLog
=
log
;
}
}
void
Layer
:
:
GetDisplayListLog
(
nsCString
&
log
)
{
log
.
SetLength
(
0
)
;
if
(
gfxUtils
:
:
DumpDisplayList
(
)
)
{
log
.
AppendPrintf
(
"
0x
%
p
\
n
%
s
"
(
void
*
)
this
mDisplayListLog
.
get
(
)
)
;
}
}
void
Layer
:
:
Log
(
const
char
*
aPrefix
)
{
if
(
!
IsLogEnabled
(
)
)
return
;
LogSelf
(
aPrefix
)
;
if
(
Layer
*
kid
=
GetFirstChild
(
)
)
{
nsAutoCString
pfx
(
aPrefix
)
;
pfx
+
=
"
"
;
kid
-
>
Log
(
pfx
.
get
(
)
)
;
}
if
(
Layer
*
next
=
GetNextSibling
(
)
)
next
-
>
Log
(
aPrefix
)
;
}
void
Layer
:
:
LogSelf
(
const
char
*
aPrefix
)
{
if
(
!
IsLogEnabled
(
)
)
return
;
std
:
:
stringstream
ss
;
PrintInfo
(
ss
aPrefix
)
;
MOZ_LAYERS_LOG
(
(
"
%
s
"
ss
.
str
(
)
.
c_str
(
)
)
)
;
if
(
mMaskLayer
)
{
nsAutoCString
pfx
(
aPrefix
)
;
pfx
+
=
R
"
(
\
MaskLayer
)
"
;
mMaskLayer
-
>
LogSelf
(
pfx
.
get
(
)
)
;
}
}
void
Layer
:
:
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
{
aStream
<
<
aPrefix
;
aStream
<
<
nsPrintfCString
(
"
%
s
%
s
(
0x
%
p
)
"
mManager
-
>
Name
(
)
Name
(
)
this
)
.
get
(
)
;
if
(
mClipRect
)
{
aStream
<
<
"
[
clip
=
"
<
<
*
mClipRect
<
<
"
]
"
;
}
if
(
1
.
0
!
=
mSimpleAttrs
.
GetPostXScale
(
)
|
|
1
.
0
!
=
mSimpleAttrs
.
GetPostYScale
(
)
)
{
aStream
<
<
nsPrintfCString
(
"
[
postScale
=
%
g
%
g
]
"
mSimpleAttrs
.
GetPostXScale
(
)
mSimpleAttrs
.
GetPostYScale
(
)
)
.
get
(
)
;
}
if
(
!
GetBaseTransform
(
)
.
IsIdentity
(
)
)
{
aStream
<
<
"
[
transform
=
"
<
<
GetBaseTransform
(
)
<
<
"
]
"
;
}
if
(
!
GetEffectiveTransform
(
)
.
IsIdentity
(
)
)
{
aStream
<
<
"
[
effective
-
transform
=
"
<
<
GetEffectiveTransform
(
)
<
<
"
]
"
;
}
if
(
GetTransformIsPerspective
(
)
)
{
aStream
<
<
"
[
perspective
]
"
;
}
if
(
!
mVisibleRegion
.
IsEmpty
(
)
)
{
aStream
<
<
"
[
visible
=
"
<
<
mVisibleRegion
<
<
"
]
"
;
}
else
{
aStream
<
<
"
[
not
visible
]
"
;
}
if
(
!
mEventRegions
.
IsEmpty
(
)
)
{
aStream
<
<
"
"
<
<
mEventRegions
;
}
if
(
1
.
0
!
=
GetOpacity
(
)
)
{
aStream
<
<
nsPrintfCString
(
"
[
opacity
=
%
g
]
"
GetOpacity
(
)
)
.
get
(
)
;
}
if
(
IsOpaque
(
)
)
{
aStream
<
<
"
[
opaqueContent
]
"
;
}
if
(
GetContentFlags
(
)
&
CONTENT_COMPONENT_ALPHA
)
{
aStream
<
<
"
[
componentAlpha
]
"
;
}
if
(
GetContentFlags
(
)
&
CONTENT_BACKFACE_HIDDEN
)
{
aStream
<
<
"
[
backfaceHidden
]
"
;
}
if
(
Extend3DContext
(
)
)
{
aStream
<
<
"
[
extend3DContext
]
"
;
}
if
(
Combines3DTransformWithAncestors
(
)
)
{
aStream
<
<
"
[
combines3DTransformWithAncestors
]
"
;
}
if
(
Is3DContextLeaf
(
)
)
{
aStream
<
<
"
[
is3DContextLeaf
]
"
;
}
if
(
Maybe
<
FrameMetrics
:
:
ViewID
>
viewId
=
GetAsyncZoomContainerId
(
)
)
{
aStream
<
<
nsPrintfCString
(
"
[
asyncZoomContainer
scrollId
=
%
"
PRIu64
"
]
"
*
viewId
)
.
get
(
)
;
}
if
(
IsScrollbarContainer
(
)
)
{
aStream
<
<
"
[
scrollbar
]
"
;
}
if
(
GetScrollbarData
(
)
.
IsThumb
(
)
)
{
if
(
Maybe
<
ScrollDirection
>
thumbDirection
=
GetScrollbarData
(
)
.
mDirection
)
{
if
(
*
thumbDirection
=
=
ScrollDirection
:
:
eVertical
)
{
aStream
<
<
nsPrintfCString
(
"
[
vscrollbar
=
%
"
PRIu64
"
]
"
GetScrollbarData
(
)
.
mTargetViewId
)
.
get
(
)
;
}
if
(
*
thumbDirection
=
=
ScrollDirection
:
:
eHorizontal
)
{
aStream
<
<
nsPrintfCString
(
"
[
hscrollbar
=
%
"
PRIu64
"
]
"
GetScrollbarData
(
)
.
mTargetViewId
)
.
get
(
)
;
}
}
}
if
(
GetIsFixedPosition
(
)
)
{
LayerPoint
anchor
=
GetFixedPositionAnchor
(
)
;
aStream
<
<
nsPrintfCString
(
"
[
isFixedPosition
scrollId
=
%
"
PRIu64
"
sides
=
0x
%
x
anchor
=
%
s
]
"
GetFixedPositionScrollContainerId
(
)
static_cast
<
unsigned
int
>
(
GetFixedPositionSides
(
)
)
ToString
(
anchor
)
.
c_str
(
)
)
.
get
(
)
;
}
if
(
GetIsStickyPosition
(
)
)
{
aStream
<
<
nsPrintfCString
(
"
[
isStickyPosition
scrollId
=
%
"
PRIu64
"
outer
=
(
%
.
3f
%
.
3f
)
-
(
%
.
3f
%
.
3f
)
"
"
inner
=
(
%
.
3f
%
.
3f
)
-
(
%
.
3f
%
.
3f
)
]
"
GetStickyScrollContainerId
(
)
GetStickyScrollRangeOuter
(
)
.
X
(
)
GetStickyScrollRangeOuter
(
)
.
Y
(
)
GetStickyScrollRangeOuter
(
)
.
XMost
(
)
GetStickyScrollRangeOuter
(
)
.
YMost
(
)
GetStickyScrollRangeInner
(
)
.
X
(
)
GetStickyScrollRangeInner
(
)
.
Y
(
)
GetStickyScrollRangeInner
(
)
.
XMost
(
)
GetStickyScrollRangeInner
(
)
.
YMost
(
)
)
.
get
(
)
;
}
if
(
mMaskLayer
)
{
aStream
<
<
nsPrintfCString
(
"
[
mMaskLayer
=
%
p
]
"
mMaskLayer
.
get
(
)
)
.
get
(
)
;
}
for
(
uint32_t
i
=
0
;
i
<
mScrollMetadata
.
Length
(
)
;
i
+
+
)
{
if
(
!
mScrollMetadata
[
i
]
.
IsDefault
(
)
)
{
aStream
<
<
"
[
metrics
"
<
<
i
<
<
"
=
"
<
<
mScrollMetadata
[
i
]
<
<
"
]
"
;
}
}
if
(
!
mAnimationInfo
.
GetAnimations
(
)
.
IsEmpty
(
)
)
{
aStream
<
<
nsPrintfCString
(
"
[
%
d
animations
with
id
=
%
"
PRIu64
"
]
"
(
int
)
mAnimationInfo
.
GetAnimations
(
)
.
Length
(
)
mAnimationInfo
.
GetCompositorAnimationsId
(
)
)
.
get
(
)
;
}
}
bool
Layer
:
:
IsBackfaceHidden
(
)
{
return
false
;
}
UniquePtr
<
LayerUserData
>
Layer
:
:
RemoveUserData
(
void
*
aKey
)
{
UniquePtr
<
LayerUserData
>
d
(
static_cast
<
LayerUserData
*
>
(
mUserData
.
Remove
(
static_cast
<
gfx
:
:
UserDataKey
*
>
(
aKey
)
)
)
)
;
return
d
;
}
void
LayerManager
:
:
Log
(
const
char
*
aPrefix
)
{
if
(
!
IsLogEnabled
(
)
)
return
;
LogSelf
(
aPrefix
)
;
nsAutoCString
pfx
(
aPrefix
)
;
pfx
+
=
"
"
;
if
(
!
GetRoot
(
)
)
{
MOZ_LAYERS_LOG
(
(
"
%
s
(
null
)
"
pfx
.
get
(
)
)
)
;
return
;
}
GetRoot
(
)
-
>
Log
(
pfx
.
get
(
)
)
;
}
void
LayerManager
:
:
LogSelf
(
const
char
*
aPrefix
)
{
nsAutoCString
str
;
std
:
:
stringstream
ss
;
PrintInfo
(
ss
aPrefix
)
;
MOZ_LAYERS_LOG
(
(
"
%
s
"
ss
.
str
(
)
.
c_str
(
)
)
)
;
}
void
LayerManager
:
:
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
{
aStream
<
<
aPrefix
<
<
nsPrintfCString
(
"
%
sLayerManager
(
0x
%
p
)
"
Name
(
)
this
)
.
get
(
)
;
}
bool
LayerManager
:
:
IsLogEnabled
(
)
{
return
MOZ_LOG_TEST
(
GetLog
(
)
LogLevel
:
:
Debug
)
;
}
bool
LayerManager
:
:
AddPendingScrollUpdateForNextTransaction
(
ScrollableLayerGuid
:
:
ViewID
aScrollId
const
ScrollPositionUpdate
&
aUpdateInfo
)
{
Layer
*
withPendingTransform
=
DepthFirstSearch
<
ForwardIterator
>
(
GetRoot
(
)
[
]
(
Layer
*
aLayer
)
{
return
aLayer
-
>
HasPendingTransform
(
)
;
}
)
;
if
(
withPendingTransform
)
{
return
false
;
}
mPendingScrollUpdates
.
LookupOrInsert
(
aScrollId
)
.
AppendElement
(
aUpdateInfo
)
;
return
true
;
}
Maybe
<
nsTArray
<
ScrollPositionUpdate
>
>
LayerManager
:
:
GetPendingScrollInfoUpdate
(
ScrollableLayerGuid
:
:
ViewID
aScrollId
)
{
auto
p
=
mPendingScrollUpdates
.
Lookup
(
aScrollId
)
;
if
(
!
p
)
{
return
Nothing
(
)
;
}
nsTArray
<
ScrollPositionUpdate
>
copy
;
copy
.
AppendElements
(
p
.
Data
(
)
)
;
return
Some
(
std
:
:
move
(
copy
)
)
;
}
std
:
:
unordered_set
<
ScrollableLayerGuid
:
:
ViewID
>
LayerManager
:
:
ClearPendingScrollInfoUpdate
(
)
{
std
:
:
unordered_set
<
ScrollableLayerGuid
:
:
ViewID
>
scrollIds
(
mPendingScrollUpdates
.
Keys
(
)
.
cbegin
(
)
mPendingScrollUpdates
.
Keys
(
)
.
cend
(
)
)
;
mPendingScrollUpdates
.
Clear
(
)
;
return
scrollIds
;
}
void
SetAntialiasingFlags
(
Layer
*
aLayer
DrawTarget
*
aTarget
)
{
bool
permitSubpixelAA
=
!
(
aLayer
-
>
GetContentFlags
(
)
&
Layer
:
:
CONTENT_DISABLE_SUBPIXEL_AA
)
;
if
(
aTarget
-
>
IsCurrentGroupOpaque
(
)
)
{
aTarget
-
>
SetPermitSubpixelAA
(
permitSubpixelAA
)
;
return
;
}
const
IntRect
&
bounds
=
aLayer
-
>
GetVisibleRegion
(
)
.
GetBounds
(
)
.
ToUnknownRect
(
)
;
gfx
:
:
Rect
transformedBounds
=
aTarget
-
>
GetTransform
(
)
.
TransformBounds
(
gfx
:
:
Rect
(
Float
(
bounds
.
X
(
)
)
Float
(
bounds
.
Y
(
)
)
Float
(
bounds
.
Width
(
)
)
Float
(
bounds
.
Height
(
)
)
)
)
;
transformedBounds
.
RoundOut
(
)
;
IntRect
intTransformedBounds
;
transformedBounds
.
ToIntRect
(
&
intTransformedBounds
)
;
permitSubpixelAA
&
=
!
(
aLayer
-
>
GetContentFlags
(
)
&
Layer
:
:
CONTENT_COMPONENT_ALPHA
)
|
|
aTarget
-
>
GetOpaqueRect
(
)
.
Contains
(
intTransformedBounds
)
;
aTarget
-
>
SetPermitSubpixelAA
(
permitSubpixelAA
)
;
}
IntRect
ToOutsideIntRect
(
const
gfxRect
&
aRect
)
{
return
IntRect
:
:
RoundOut
(
aRect
.
X
(
)
aRect
.
Y
(
)
aRect
.
Width
(
)
aRect
.
Height
(
)
)
;
}
void
RecordCompositionPayloadsPresented
(
const
TimeStamp
&
aCompositionEndTime
const
nsTArray
<
CompositionPayload
>
&
aPayloads
)
{
if
(
aPayloads
.
Length
(
)
)
{
TimeStamp
presented
=
aCompositionEndTime
;
for
(
const
CompositionPayload
&
payload
:
aPayloads
)
{
if
(
profiler_can_accept_markers
(
)
)
{
MOZ_RELEASE_ASSERT
(
payload
.
mType
<
=
kHighestCompositionPayloadType
)
;
nsAutoCString
name
(
kCompositionPayloadTypeNames
[
uint8_t
(
payload
.
mType
)
]
)
;
name
.
AppendLiteral
(
"
Payload
Presented
"
)
;
nsPrintfCString
text
(
"
Latency
:
%
dms
"
int32_t
(
(
presented
-
payload
.
mTimeStamp
)
.
ToMilliseconds
(
)
)
)
;
PROFILER_MARKER_TEXT
(
name
GRAPHICS
MarkerTiming
:
:
Interval
(
payload
.
mTimeStamp
presented
)
text
)
;
}
if
(
payload
.
mType
=
=
CompositionPayloadType
:
:
eKeyPress
)
{
Telemetry
:
:
AccumulateTimeDelta
(
mozilla
:
:
Telemetry
:
:
KEYPRESS_PRESENT_LATENCY
payload
.
mTimeStamp
presented
)
;
}
else
if
(
payload
.
mType
=
=
CompositionPayloadType
:
:
eAPZScroll
)
{
Telemetry
:
:
AccumulateTimeDelta
(
mozilla
:
:
Telemetry
:
:
SCROLL_PRESENT_LATENCY
payload
.
mTimeStamp
presented
)
;
}
else
if
(
payload
.
mType
=
=
CompositionPayloadType
:
:
eMouseUpFollowedByClick
)
{
Telemetry
:
:
AccumulateTimeDelta
(
mozilla
:
:
Telemetry
:
:
MOUSEUP_FOLLOWED_BY_CLICK_PRESENT_LATENCY
payload
.
mTimeStamp
presented
)
;
}
}
}
}
}
}
