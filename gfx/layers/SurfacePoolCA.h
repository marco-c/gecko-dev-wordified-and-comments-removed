#
ifndef
mozilla_layers_SurfacePoolCA_h
#
define
mozilla_layers_SurfacePoolCA_h
#
include
<
IOSurface
/
IOSurfaceRef
.
h
>
#
include
<
deque
>
#
include
<
unordered_map
>
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
layers
/
SurfacePool
.
h
"
#
include
"
CFTypeRefPtr
.
h
"
#
include
"
MozFramebuffer
.
h
"
#
include
"
nsISupportsImpl
.
h
"
namespace
mozilla
{
namespace
gl
{
class
MozFramebuffer
;
}
namespace
layers
{
class
SurfacePoolHandleCA
;
struct
SurfacePoolCAWrapperForGL
;
class
SurfacePoolCA
final
:
public
SurfacePool
{
public
:
RefPtr
<
SurfacePoolHandle
>
GetHandleForGL
(
gl
:
:
GLContext
*
aGL
)
override
;
void
DestroyGLResourcesForContext
(
gl
:
:
GLContext
*
aGL
)
override
;
private
:
friend
struct
SurfacePoolCAWrapperForGL
;
friend
class
SurfacePoolHandleCA
;
friend
RefPtr
<
SurfacePool
>
SurfacePool
:
:
Create
(
size_t
aPoolSizeLimit
)
;
explicit
SurfacePoolCA
(
size_t
aPoolSizeLimit
)
;
~
SurfacePoolCA
(
)
override
;
CFTypeRefPtr
<
IOSurfaceRef
>
ObtainSurfaceFromPool
(
const
gfx
:
:
IntSize
&
aSize
gl
:
:
GLContext
*
aGL
)
;
void
ReturnSurfaceToPool
(
CFTypeRefPtr
<
IOSurfaceRef
>
aSurface
)
;
uint64_t
CollectPendingSurfaces
(
uint64_t
aCheckGenerationsUpTo
)
;
void
EnforcePoolSizeLimit
(
)
;
Maybe
<
GLuint
>
GetFramebufferForSurface
(
CFTypeRefPtr
<
IOSurfaceRef
>
aSurface
gl
:
:
GLContext
*
aGL
bool
aNeedsDepthBuffer
)
;
void
OnWrapperDestroyed
(
gl
:
:
GLContext
*
aGL
SurfacePoolCAWrapperForGL
*
aWrapper
)
;
struct
LockedPool
{
explicit
LockedPool
(
size_t
aPoolSizeLimit
)
;
LockedPool
(
LockedPool
&
&
)
=
default
;
~
LockedPool
(
)
;
RefPtr
<
SurfacePoolCAWrapperForGL
>
GetWrapperForGL
(
SurfacePoolCA
*
aPool
gl
:
:
GLContext
*
aGL
)
;
void
DestroyGLResourcesForContext
(
gl
:
:
GLContext
*
aGL
)
;
CFTypeRefPtr
<
IOSurfaceRef
>
ObtainSurfaceFromPool
(
const
gfx
:
:
IntSize
&
aSize
gl
:
:
GLContext
*
aGL
)
;
void
ReturnSurfaceToPool
(
CFTypeRefPtr
<
IOSurfaceRef
>
aSurface
)
;
uint64_t
CollectPendingSurfaces
(
uint64_t
aCheckGenerationsUpTo
)
;
void
EnforcePoolSizeLimit
(
)
;
Maybe
<
GLuint
>
GetFramebufferForSurface
(
CFTypeRefPtr
<
IOSurfaceRef
>
aSurface
gl
:
:
GLContext
*
aGL
bool
aNeedsDepthBuffer
)
;
void
OnWrapperDestroyed
(
gl
:
:
GLContext
*
aGL
SurfacePoolCAWrapperForGL
*
aWrapper
)
;
uint64_t
EstimateTotalMemory
(
)
;
uint64_t
mCollectionGeneration
=
0
;
protected
:
struct
GLResourcesForSurface
{
RefPtr
<
gl
:
:
GLContext
>
mGLContext
;
UniquePtr
<
gl
:
:
MozFramebuffer
>
mFramebuffer
;
}
;
struct
SurfacePoolEntry
{
gfx
:
:
IntSize
mSize
;
CFTypeRefPtr
<
IOSurfaceRef
>
mIOSurface
;
Maybe
<
GLResourcesForSurface
>
mGLResources
;
}
;
struct
PendingSurfaceEntry
{
SurfacePoolEntry
mEntry
;
uint64_t
mPreviousCheckGeneration
;
uint64_t
mCheckCount
;
}
;
template
<
typename
F
>
void
MutateEntryStorage
(
const
char
*
aMutationType
const
gfx
:
:
IntSize
&
aSize
F
aFn
)
;
template
<
typename
F
>
void
ForEachEntry
(
F
aFn
)
;
bool
CanRecycleSurfaceForRequest
(
const
SurfacePoolEntry
&
aEntry
const
gfx
:
:
IntSize
&
aSize
gl
:
:
GLContext
*
aGL
)
;
RefPtr
<
gl
:
:
DepthAndStencilBuffer
>
GetDepthBufferForSharing
(
gl
:
:
GLContext
*
aGL
const
gfx
:
:
IntSize
&
aSize
)
;
UniquePtr
<
gl
:
:
MozFramebuffer
>
CreateFramebufferForTexture
(
gl
:
:
GLContext
*
aGL
const
gfx
:
:
IntSize
&
aSize
GLuint
aTexture
bool
aNeedsDepthBuffer
)
;
std
:
:
unordered_map
<
CFTypeRefPtr
<
IOSurfaceRef
>
SurfacePoolEntry
>
mInUseEntries
;
nsTArray
<
PendingSurfaceEntry
>
mPendingEntries
;
nsTArray
<
SurfacePoolEntry
>
mAvailableEntries
;
std
:
:
unordered_map
<
gl
:
:
GLContext
*
SurfacePoolCAWrapperForGL
*
>
mWrappers
;
size_t
mPoolSizeLimit
=
0
;
struct
DepthBufferEntry
{
RefPtr
<
gl
:
:
GLContext
>
mGLContext
;
gfx
:
:
IntSize
mSize
;
WeakPtr
<
gl
:
:
DepthAndStencilBuffer
>
mBuffer
;
}
;
nsTArray
<
DepthBufferEntry
>
mDepthBuffers
;
}
;
DataMutex
<
LockedPool
>
mPool
;
}
;
struct
SurfacePoolCAWrapperForGL
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
SurfacePoolCAWrapperForGL
)
;
const
RefPtr
<
SurfacePoolCA
>
mPool
;
const
RefPtr
<
gl
:
:
GLContext
>
mGL
;
SurfacePoolCAWrapperForGL
(
SurfacePoolCA
*
aPool
gl
:
:
GLContext
*
aGL
)
:
mPool
(
aPool
)
mGL
(
aGL
)
{
}
protected
:
~
SurfacePoolCAWrapperForGL
(
)
{
mPool
-
>
OnWrapperDestroyed
(
mGL
this
)
;
}
}
;
class
SurfacePoolHandleCA
final
:
public
SurfacePoolHandle
{
public
:
SurfacePoolHandleCA
*
AsSurfacePoolHandleCA
(
)
override
{
return
this
;
}
const
auto
&
gl
(
)
{
return
mPoolWrapper
-
>
mGL
;
}
CFTypeRefPtr
<
IOSurfaceRef
>
ObtainSurfaceFromPool
(
const
gfx
:
:
IntSize
&
aSize
)
;
void
ReturnSurfaceToPool
(
CFTypeRefPtr
<
IOSurfaceRef
>
aSurface
)
;
Maybe
<
GLuint
>
GetFramebufferForSurface
(
CFTypeRefPtr
<
IOSurfaceRef
>
aSurface
bool
aNeedsDepthBuffer
)
;
RefPtr
<
SurfacePool
>
Pool
(
)
override
{
return
mPoolWrapper
-
>
mPool
;
}
void
OnBeginFrame
(
)
override
;
void
OnEndFrame
(
)
override
;
private
:
friend
class
SurfacePoolCA
;
SurfacePoolHandleCA
(
RefPtr
<
SurfacePoolCAWrapperForGL
>
&
&
aPoolWrapper
uint64_t
aCurrentCollectionGeneration
)
;
~
SurfacePoolHandleCA
(
)
override
;
const
RefPtr
<
SurfacePoolCAWrapperForGL
>
mPoolWrapper
;
DataMutex
<
uint64_t
>
mPreviousFrameCollectionGeneration
;
}
;
}
}
#
endif
