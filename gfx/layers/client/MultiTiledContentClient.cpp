#
include
"
mozilla
/
layers
/
MultiTiledContentClient
.
h
"
#
include
"
ClientTiledPaintedLayer
.
h
"
#
include
"
mozilla
/
layers
/
LayerMetricsWrapper
.
h
"
namespace
mozilla
{
using
namespace
gfx
;
namespace
layers
{
MultiTiledContentClient
:
:
MultiTiledContentClient
(
ClientTiledPaintedLayer
&
aPaintedLayer
ClientLayerManager
*
aManager
)
:
TiledContentClient
(
aManager
"
Multi
"
)
mTiledBuffer
(
aPaintedLayer
*
this
aManager
&
mSharedFrameMetricsHelper
)
mLowPrecisionTiledBuffer
(
aPaintedLayer
*
this
aManager
&
mSharedFrameMetricsHelper
)
{
MOZ_COUNT_CTOR
(
MultiTiledContentClient
)
;
mLowPrecisionTiledBuffer
.
SetResolution
(
gfxPrefs
:
:
LowPrecisionResolution
(
)
)
;
mHasLowPrecision
=
gfxPrefs
:
:
UseLowPrecisionBuffer
(
)
;
}
void
MultiTiledContentClient
:
:
ClearCachedResources
(
)
{
CompositableClient
:
:
ClearCachedResources
(
)
;
mTiledBuffer
.
DiscardBuffers
(
)
;
mLowPrecisionTiledBuffer
.
DiscardBuffers
(
)
;
}
void
MultiTiledContentClient
:
:
UpdatedBuffer
(
TiledBufferType
aType
)
{
ClientMultiTiledLayerBuffer
*
buffer
=
aType
=
=
LOW_PRECISION_TILED_BUFFER
?
&
mLowPrecisionTiledBuffer
:
&
mTiledBuffer
;
MOZ_ASSERT
(
aType
!
=
LOW_PRECISION_TILED_BUFFER
|
|
mHasLowPrecision
)
;
mForwarder
-
>
UseTiledLayerBuffer
(
this
buffer
-
>
GetSurfaceDescriptorTiles
(
)
)
;
}
ClientMultiTiledLayerBuffer
:
:
ClientMultiTiledLayerBuffer
(
ClientTiledPaintedLayer
&
aPaintedLayer
CompositableClient
&
aCompositableClient
ClientLayerManager
*
aManager
SharedFrameMetricsHelper
*
aHelper
)
:
ClientTiledLayerBuffer
(
aPaintedLayer
aCompositableClient
)
mManager
(
aManager
)
mCallback
(
nullptr
)
mCallbackData
(
nullptr
)
mSharedFrameMetricsHelper
(
aHelper
)
{
}
void
ClientMultiTiledLayerBuffer
:
:
DiscardBuffers
(
)
{
for
(
TileClient
&
tile
:
mRetainedTiles
)
{
tile
.
DiscardBuffers
(
)
;
}
}
SurfaceDescriptorTiles
ClientMultiTiledLayerBuffer
:
:
GetSurfaceDescriptorTiles
(
)
{
InfallibleTArray
<
TileDescriptor
>
tiles
;
for
(
TileClient
&
tile
:
mRetainedTiles
)
{
TileDescriptor
tileDesc
=
tile
.
GetTileDescriptor
(
)
;
tiles
.
AppendElement
(
tileDesc
)
;
tile
.
mUpdateRect
=
IntRect
(
)
;
}
return
SurfaceDescriptorTiles
(
mValidRegion
tiles
mTileOrigin
mTileSize
mTiles
.
mFirst
.
x
mTiles
.
mFirst
.
y
mTiles
.
mSize
.
width
mTiles
.
mSize
.
height
mResolution
mFrameResolution
.
xScale
mFrameResolution
.
yScale
mWasLastPaintProgressive
)
;
}
void
ClientMultiTiledLayerBuffer
:
:
PaintThebes
(
const
nsIntRegion
&
aNewValidRegion
const
nsIntRegion
&
aPaintRegion
const
nsIntRegion
&
aDirtyRegion
LayerManager
:
:
DrawPaintedLayerCallback
aCallback
void
*
aCallbackData
TilePaintFlags
aFlags
)
{
TILING_LOG
(
"
TILING
%
p
:
PaintThebes
painting
region
%
s
\
n
"
&
mPaintedLayer
Stringify
(
aPaintRegion
)
.
c_str
(
)
)
;
TILING_LOG
(
"
TILING
%
p
:
PaintThebes
new
valid
region
%
s
\
n
"
&
mPaintedLayer
Stringify
(
aNewValidRegion
)
.
c_str
(
)
)
;
mCallback
=
aCallback
;
mCallbackData
=
aCallbackData
;
mWasLastPaintProgressive
=
!
!
(
aFlags
&
TilePaintFlags
:
:
Progressive
)
;
#
ifdef
GFX_TILEDLAYER_PREF_WARNINGS
long
start
=
PR_IntervalNow
(
)
;
#
endif
#
ifdef
GFX_TILEDLAYER_PREF_WARNINGS
if
(
PR_IntervalNow
(
)
-
start
>
30
)
{
const
IntRect
bounds
=
aPaintRegion
.
GetBounds
(
)
;
printf_stderr
(
"
Time
to
draw
%
i
:
%
i
%
i
%
i
%
i
\
n
"
PR_IntervalNow
(
)
-
start
bounds
.
x
bounds
.
y
bounds
.
width
bounds
.
height
)
;
if
(
aPaintRegion
.
IsComplex
(
)
)
{
printf_stderr
(
"
Complex
region
\
n
"
)
;
for
(
auto
iter
=
aPaintRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
IntRect
&
rect
=
iter
.
Get
(
)
;
printf_stderr
(
"
rect
%
i
%
i
%
i
%
i
\
n
"
rect
.
x
rect
.
y
rect
.
width
rect
.
height
)
;
}
}
}
start
=
PR_IntervalNow
(
)
;
#
endif
AUTO_PROFILER_LABEL
(
"
ClientMultiTiledLayerBuffer
:
:
PaintThebes
"
GRAPHICS
)
;
mNewValidRegion
=
aNewValidRegion
;
Update
(
aNewValidRegion
aPaintRegion
aDirtyRegion
aFlags
)
;
#
ifdef
GFX_TILEDLAYER_PREF_WARNINGS
if
(
PR_IntervalNow
(
)
-
start
>
10
)
{
const
IntRect
bounds
=
aPaintRegion
.
GetBounds
(
)
;
printf_stderr
(
"
Time
to
tile
%
i
:
%
i
%
i
%
i
%
i
\
n
"
PR_IntervalNow
(
)
-
start
bounds
.
x
bounds
.
y
bounds
.
width
bounds
.
height
)
;
}
#
endif
mLastPaintContentType
=
GetContentType
(
&
mLastPaintSurfaceMode
)
;
mCallback
=
nullptr
;
mCallbackData
=
nullptr
;
}
void
PadDrawTargetOutFromRegion
(
RefPtr
<
DrawTarget
>
drawTarget
nsIntRegion
&
region
)
{
struct
LockedBits
{
uint8_t
*
data
;
IntSize
size
;
int32_t
stride
;
SurfaceFormat
format
;
static
int
clamp
(
int
x
int
min
int
max
)
{
if
(
x
<
min
)
x
=
min
;
if
(
x
>
max
)
x
=
max
;
return
x
;
}
static
void
ensure_memcpy
(
uint8_t
*
dst
uint8_t
*
src
size_t
n
uint8_t
*
bitmap
int
stride
int
height
)
{
if
(
src
+
n
>
bitmap
+
stride
*
height
)
{
MOZ_CRASH
(
"
GFX
:
long
src
memcpy
"
)
;
}
if
(
src
<
bitmap
)
{
MOZ_CRASH
(
"
GFX
:
short
src
memcpy
"
)
;
}
if
(
dst
+
n
>
bitmap
+
stride
*
height
)
{
MOZ_CRASH
(
"
GFX
:
long
dst
mempcy
"
)
;
}
if
(
dst
<
bitmap
)
{
MOZ_CRASH
(
"
GFX
:
short
dst
mempcy
"
)
;
}
}
static
void
visitor
(
void
*
closure
VisitSide
side
int
x1
int
y1
int
x2
int
y2
)
{
LockedBits
*
lb
=
static_cast
<
LockedBits
*
>
(
closure
)
;
uint8_t
*
bitmap
=
lb
-
>
data
;
const
int
bpp
=
gfx
:
:
BytesPerPixel
(
lb
-
>
format
)
;
const
int
stride
=
lb
-
>
stride
;
const
int
width
=
lb
-
>
size
.
width
;
const
int
height
=
lb
-
>
size
.
height
;
if
(
side
=
=
VisitSide
:
:
TOP
)
{
if
(
y1
>
0
)
{
x1
=
clamp
(
x1
0
width
-
1
)
;
x2
=
clamp
(
x2
0
width
-
1
)
;
ensure_memcpy
(
&
bitmap
[
x1
*
bpp
+
(
y1
-
1
)
*
stride
]
&
bitmap
[
x1
*
bpp
+
y1
*
stride
]
(
x2
-
x1
)
*
bpp
bitmap
stride
height
)
;
memcpy
(
&
bitmap
[
x1
*
bpp
+
(
y1
-
1
)
*
stride
]
&
bitmap
[
x1
*
bpp
+
y1
*
stride
]
(
x2
-
x1
)
*
bpp
)
;
}
}
else
if
(
side
=
=
VisitSide
:
:
BOTTOM
)
{
if
(
y1
<
height
)
{
x1
=
clamp
(
x1
0
width
-
1
)
;
x2
=
clamp
(
x2
0
width
-
1
)
;
ensure_memcpy
(
&
bitmap
[
x1
*
bpp
+
y1
*
stride
]
&
bitmap
[
x1
*
bpp
+
(
y1
-
1
)
*
stride
]
(
x2
-
x1
)
*
bpp
bitmap
stride
height
)
;
memcpy
(
&
bitmap
[
x1
*
bpp
+
y1
*
stride
]
&
bitmap
[
x1
*
bpp
+
(
y1
-
1
)
*
stride
]
(
x2
-
x1
)
*
bpp
)
;
}
}
else
if
(
side
=
=
VisitSide
:
:
LEFT
)
{
if
(
x1
>
0
)
{
while
(
y1
!
=
y2
)
{
memcpy
(
&
bitmap
[
(
x1
-
1
)
*
bpp
+
y1
*
stride
]
&
bitmap
[
x1
*
bpp
+
y1
*
stride
]
bpp
)
;
y1
+
+
;
}
}
}
else
if
(
side
=
=
VisitSide
:
:
RIGHT
)
{
if
(
x1
<
width
)
{
while
(
y1
!
=
y2
)
{
memcpy
(
&
bitmap
[
x1
*
bpp
+
y1
*
stride
]
&
bitmap
[
(
x1
-
1
)
*
bpp
+
y1
*
stride
]
bpp
)
;
y1
+
+
;
}
}
}
}
}
lb
;
if
(
drawTarget
-
>
LockBits
(
&
lb
.
data
&
lb
.
size
&
lb
.
stride
&
lb
.
format
)
)
{
region
.
VisitEdges
(
lb
.
visitor
&
lb
)
;
drawTarget
-
>
ReleaseBits
(
lb
.
data
)
;
}
}
void
ClientMultiTiledLayerBuffer
:
:
Update
(
const
nsIntRegion
&
newValidRegion
const
nsIntRegion
&
aPaintRegion
const
nsIntRegion
&
aDirtyRegion
TilePaintFlags
aFlags
)
{
const
IntSize
scaledTileSize
=
GetScaledTileSize
(
)
;
const
gfx
:
:
IntRect
newBounds
=
newValidRegion
.
GetBounds
(
)
;
const
TilesPlacement
oldTiles
=
mTiles
;
const
TilesPlacement
newTiles
(
floor_div
(
newBounds
.
X
(
)
scaledTileSize
.
width
)
floor_div
(
newBounds
.
Y
(
)
scaledTileSize
.
height
)
floor_div
(
GetTileStart
(
newBounds
.
X
(
)
scaledTileSize
.
width
)
+
newBounds
.
Width
(
)
scaledTileSize
.
width
)
+
1
floor_div
(
GetTileStart
(
newBounds
.
Y
(
)
scaledTileSize
.
height
)
+
newBounds
.
Height
(
)
scaledTileSize
.
height
)
+
1
)
;
const
size_t
oldTileCount
=
mRetainedTiles
.
Length
(
)
;
const
size_t
newTileCount
=
newTiles
.
mSize
.
width
*
newTiles
.
mSize
.
height
;
nsTArray
<
TileClient
>
oldRetainedTiles
;
mRetainedTiles
.
SwapElements
(
oldRetainedTiles
)
;
mRetainedTiles
.
SetLength
(
newTileCount
)
;
for
(
size_t
oldIndex
=
0
;
oldIndex
<
oldTileCount
;
oldIndex
+
+
)
{
const
TileCoordIntPoint
tilePosition
=
oldTiles
.
TilePosition
(
oldIndex
)
;
const
size_t
newIndex
=
newTiles
.
TileIndex
(
tilePosition
)
;
if
(
newTiles
.
HasTile
(
tilePosition
)
)
{
mRetainedTiles
[
newIndex
]
=
oldRetainedTiles
[
oldIndex
]
;
}
else
{
oldRetainedTiles
[
oldIndex
]
.
DiscardBuffers
(
)
;
}
}
oldRetainedTiles
.
Clear
(
)
;
nsIntRegion
paintRegion
=
aPaintRegion
;
nsIntRegion
dirtyRegion
=
aDirtyRegion
;
if
(
!
paintRegion
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
mPaintStates
.
size
(
)
=
=
0
)
;
for
(
size_t
i
=
0
;
i
<
newTileCount
;
+
+
i
)
{
const
TileCoordIntPoint
tilePosition
=
newTiles
.
TilePosition
(
i
)
;
IntPoint
tileOffset
=
GetTileOffset
(
tilePosition
)
;
nsIntRegion
tileDrawRegion
=
IntRect
(
tileOffset
scaledTileSize
)
;
tileDrawRegion
.
AndWith
(
paintRegion
)
;
if
(
tileDrawRegion
.
IsEmpty
(
)
)
{
continue
;
}
TileClient
&
tile
=
mRetainedTiles
[
i
]
;
if
(
!
ValidateTile
(
tile
GetTileOffset
(
tilePosition
)
tileDrawRegion
aFlags
)
)
{
gfxCriticalError
(
)
<
<
"
ValidateTile
failed
"
;
}
paintRegion
.
OrWith
(
tileDrawRegion
)
;
dirtyRegion
.
OrWith
(
tileDrawRegion
)
;
}
if
(
!
mPaintTiles
.
empty
(
)
)
{
gfx
:
:
TileSet
tileset
;
for
(
size_t
i
=
0
;
i
<
mPaintTiles
.
size
(
)
;
+
+
i
)
{
mPaintTiles
[
i
]
.
mTileOrigin
-
=
mTilingOrigin
;
}
tileset
.
mTiles
=
&
mPaintTiles
[
0
]
;
tileset
.
mTileCount
=
mPaintTiles
.
size
(
)
;
RefPtr
<
DrawTarget
>
drawTarget
=
gfx
:
:
Factory
:
:
CreateTiledDrawTarget
(
tileset
)
;
if
(
!
drawTarget
|
|
!
drawTarget
-
>
IsValid
(
)
)
{
gfxDevCrash
(
LogReason
:
:
InvalidContext
)
<
<
"
Invalid
tiled
draw
target
"
;
return
;
}
drawTarget
-
>
SetTransform
(
Matrix
(
)
)
;
RefPtr
<
gfxContext
>
ctx
=
gfxContext
:
:
CreateOrNull
(
drawTarget
)
;
MOZ_ASSERT
(
ctx
)
;
ctx
-
>
SetMatrix
(
ctx
-
>
CurrentMatrix
(
)
.
PreScale
(
mResolution
mResolution
)
.
PreTranslate
(
-
mTilingOrigin
)
)
;
mCallback
(
&
mPaintedLayer
ctx
paintRegion
dirtyRegion
DrawRegionClip
:
:
DRAW
nsIntRegion
(
)
mCallbackData
)
;
ctx
=
nullptr
;
if
(
aFlags
&
TilePaintFlags
:
:
Async
)
{
for
(
const
auto
&
state
:
mPaintStates
)
{
PaintThread
:
:
Get
(
)
-
>
PaintTiledContents
(
state
)
;
}
mManager
-
>
SetQueuedAsyncPaints
(
)
;
MOZ_ASSERT
(
mPaintStates
.
size
(
)
>
0
)
;
mPaintStates
.
clear
(
)
;
}
else
{
MOZ_ASSERT
(
mPaintStates
.
size
(
)
=
=
0
)
;
}
mPaintTiles
.
clear
(
)
;
mTilingOrigin
=
IntPoint
(
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
;
}
bool
edgePaddingEnabled
=
gfxPrefs
:
:
TileEdgePaddingEnabled
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mRetainedTiles
.
Length
(
)
;
+
+
i
)
{
TileClient
&
tile
=
mRetainedTiles
[
i
]
;
if
(
edgePaddingEnabled
&
&
mResolution
=
=
1
&
&
tile
.
mFrontBuffer
&
&
tile
.
mFrontBuffer
-
>
IsLocked
(
)
)
{
const
TileCoordIntPoint
tilePosition
=
newTiles
.
TilePosition
(
i
)
;
IntPoint
tileOffset
=
GetTileOffset
(
tilePosition
)
;
IntRect
tileRect
=
IntRect
(
tileOffset
.
x
tileOffset
.
y
GetTileSize
(
)
.
width
GetTileSize
(
)
.
height
)
;
nsIntRegion
tileDrawRegion
=
IntRect
(
tileOffset
scaledTileSize
)
;
tileDrawRegion
.
AndWith
(
paintRegion
)
;
nsIntRegion
tileValidRegion
=
mValidRegion
;
tileValidRegion
.
OrWith
(
tileDrawRegion
)
;
if
(
!
tileValidRegion
.
Contains
(
tileRect
)
)
{
tileValidRegion
=
tileValidRegion
.
Intersect
(
tileRect
)
;
tileValidRegion
.
MoveBy
(
-
IntPoint
(
tileOffset
.
x
tileOffset
.
y
)
)
;
RefPtr
<
DrawTarget
>
drawTarget
=
tile
.
mFrontBuffer
-
>
BorrowDrawTarget
(
)
;
PadDrawTargetOutFromRegion
(
drawTarget
tileValidRegion
)
;
}
}
UnlockTile
(
tile
)
;
}
}
mTiles
=
newTiles
;
mValidRegion
=
newValidRegion
;
}
bool
ClientMultiTiledLayerBuffer
:
:
ValidateTile
(
TileClient
&
aTile
const
nsIntPoint
&
aTileOrigin
nsIntRegion
&
aDirtyRegion
TilePaintFlags
aFlags
)
{
AUTO_PROFILER_LABEL
(
"
ClientMultiTiledLayerBuffer
:
:
ValidateTile
"
GRAPHICS
)
;
#
ifdef
GFX_TILEDLAYER_PREF_WARNINGS
if
(
aDirtyRegion
.
IsComplex
(
)
)
{
printf_stderr
(
"
Complex
region
\
n
"
)
;
}
#
endif
SurfaceMode
mode
;
gfxContentType
content
=
GetContentType
(
&
mode
)
;
if
(
!
aTile
.
mAllocator
)
{
aTile
.
SetTextureAllocator
(
mManager
-
>
GetCompositorBridgeChild
(
)
-
>
GetTexturePool
(
mManager
-
>
AsShadowForwarder
(
)
gfxPlatform
:
:
GetPlatform
(
)
-
>
Optimal2DFormatForContent
(
content
)
TextureFlags
:
:
DISALLOW_BIGIMAGE
|
TextureFlags
:
:
IMMEDIATE_UPLOAD
|
TextureFlags
:
:
NON_BLOCKING_READ_LOCK
)
)
;
MOZ_ASSERT
(
aTile
.
mAllocator
)
;
}
nsIntRegion
tileDirtyRegion
=
aDirtyRegion
.
MovedBy
(
-
aTileOrigin
)
;
tileDirtyRegion
.
ScaleRoundOut
(
mResolution
mResolution
)
;
nsIntRegion
tileVisibleRegion
=
mNewValidRegion
.
MovedBy
(
-
aTileOrigin
)
;
tileVisibleRegion
.
ScaleRoundOut
(
mResolution
mResolution
)
;
std
:
:
vector
<
CapturedTiledPaintState
:
:
Copy
>
asyncPaintCopies
;
std
:
:
vector
<
RefPtr
<
TextureClient
>
>
asyncPaintClients
;
nsIntRegion
extraPainted
;
RefPtr
<
TextureClient
>
backBufferOnWhite
;
RefPtr
<
TextureClient
>
backBuffer
=
aTile
.
GetBackBuffer
(
mCompositableClient
tileDirtyRegion
tileVisibleRegion
content
mode
extraPainted
aFlags
&
backBufferOnWhite
&
asyncPaintCopies
&
asyncPaintClients
)
;
aTile
.
mInvalidFront
.
OrWith
(
tileDirtyRegion
)
;
nsIntRegion
tileInvalidRegion
=
aTile
.
mInvalidBack
;
tileInvalidRegion
.
AndWith
(
tileVisibleRegion
)
;
nsIntRegion
invalidRegion
=
tileInvalidRegion
;
invalidRegion
.
MoveBy
(
aTileOrigin
)
;
invalidRegion
.
ScaleInverseRoundOut
(
mResolution
mResolution
)
;
tileDirtyRegion
.
OrWith
(
tileInvalidRegion
)
;
aDirtyRegion
.
OrWith
(
invalidRegion
)
;
aTile
.
mUpdateRect
=
tileDirtyRegion
.
GetBounds
(
)
.
Union
(
extraPainted
.
GetBounds
(
)
)
;
extraPainted
.
MoveBy
(
aTileOrigin
)
;
extraPainted
.
And
(
extraPainted
mNewValidRegion
)
;
if
(
!
backBuffer
)
{
return
false
;
}
RefPtr
<
DrawTarget
>
dt
=
backBuffer
-
>
BorrowDrawTarget
(
)
;
RefPtr
<
DrawTarget
>
dtOnWhite
;
if
(
backBufferOnWhite
)
{
dtOnWhite
=
backBufferOnWhite
-
>
BorrowDrawTarget
(
)
;
}
if
(
!
dt
|
|
(
backBufferOnWhite
&
&
!
dtOnWhite
)
)
{
aTile
.
DiscardBuffers
(
)
;
return
false
;
}
RefPtr
<
DrawTarget
>
drawTarget
;
if
(
dtOnWhite
)
{
drawTarget
=
Factory
:
:
CreateDualDrawTarget
(
dt
dtOnWhite
)
;
}
else
{
drawTarget
=
dt
;
}
auto
clear
=
CapturedTiledPaintState
:
:
Clear
{
dt
dtOnWhite
tileDirtyRegion
}
;
gfx
:
:
Tile
paintTile
;
paintTile
.
mTileOrigin
=
gfx
:
:
IntPoint
(
aTileOrigin
.
x
aTileOrigin
.
y
)
;
if
(
aFlags
&
TilePaintFlags
:
:
Async
)
{
RefPtr
<
CapturedTiledPaintState
>
asyncPaint
=
new
CapturedTiledPaintState
(
)
;
RefPtr
<
DrawTargetCapture
>
captureDT
=
Factory
:
:
CreateCaptureDrawTarget
(
drawTarget
-
>
GetBackendType
(
)
drawTarget
-
>
GetSize
(
)
drawTarget
-
>
GetFormat
(
)
)
;
paintTile
.
mDrawTarget
=
captureDT
;
asyncPaint
-
>
mTarget
=
drawTarget
;
asyncPaint
-
>
mCapture
=
captureDT
;
asyncPaint
-
>
mCopies
=
std
:
:
move
(
asyncPaintCopies
)
;
asyncPaint
-
>
mClears
.
push_back
(
clear
)
;
asyncPaint
-
>
mClients
=
std
:
:
move
(
asyncPaintClients
)
;
asyncPaint
-
>
mClients
.
push_back
(
backBuffer
)
;
if
(
backBufferOnWhite
)
{
asyncPaint
-
>
mClients
.
push_back
(
backBufferOnWhite
)
;
}
mPaintStates
.
push_back
(
asyncPaint
)
;
}
else
{
paintTile
.
mDrawTarget
=
drawTarget
;
clear
.
ClearBuffer
(
)
;
}
mPaintTiles
.
push_back
(
paintTile
)
;
mTilingOrigin
.
x
=
std
:
:
min
(
mTilingOrigin
.
x
paintTile
.
mTileOrigin
.
x
)
;
mTilingOrigin
.
y
=
std
:
:
min
(
mTilingOrigin
.
y
paintTile
.
mTileOrigin
.
y
)
;
aTile
.
mInvalidBack
.
SubOut
(
tileDirtyRegion
)
;
aTile
.
Flip
(
)
;
return
true
;
}
static
Maybe
<
LayerRect
>
GetCompositorSideCompositionBounds
(
const
LayerMetricsWrapper
&
aScrollAncestor
const
LayerToParentLayerMatrix4x4
&
aTransformToCompBounds
const
AsyncTransform
&
aAPZTransform
const
LayerRect
&
aClip
)
{
LayerToParentLayerMatrix4x4
transform
=
aTransformToCompBounds
*
AsyncTransformComponentMatrix
(
aAPZTransform
)
;
return
UntransformBy
(
transform
.
Inverse
(
)
aScrollAncestor
.
Metrics
(
)
.
GetCompositionBounds
(
)
aClip
)
;
}
bool
ClientMultiTiledLayerBuffer
:
:
ComputeProgressiveUpdateRegion
(
const
nsIntRegion
&
aInvalidRegion
const
nsIntRegion
&
aOldValidRegion
nsIntRegion
&
aRegionToPaint
BasicTiledLayerPaintData
*
aPaintData
bool
aIsRepeated
)
{
aRegionToPaint
=
aInvalidRegion
;
if
(
aPaintData
-
>
mCompositionBounds
.
IsEmpty
(
)
)
{
aPaintData
-
>
mPaintFinished
=
true
;
return
false
;
}
bool
drawingLowPrecision
=
IsLowPrecision
(
)
;
nsIntRegion
staleRegion
;
staleRegion
.
And
(
aInvalidRegion
aOldValidRegion
)
;
TILING_LOG
(
"
TILING
%
p
:
Progressive
update
stale
region
%
s
\
n
"
&
mPaintedLayer
Stringify
(
staleRegion
)
.
c_str
(
)
)
;
LayerMetricsWrapper
scrollAncestor
;
mPaintedLayer
.
GetAncestorLayers
(
&
scrollAncestor
nullptr
nullptr
)
;
AsyncTransform
viewTransform
;
MOZ_ASSERT
(
mSharedFrameMetricsHelper
)
;
bool
abortPaint
=
mSharedFrameMetricsHelper
-
>
UpdateFromCompositorFrameMetrics
(
scrollAncestor
!
staleRegion
.
Contains
(
aInvalidRegion
)
drawingLowPrecision
viewTransform
)
;
TILING_LOG
(
"
TILING
%
p
:
Progressive
update
view
transform
%
s
zoom
%
f
abort
%
d
\
n
"
&
mPaintedLayer
ToString
(
viewTransform
.
mTranslation
)
.
c_str
(
)
viewTransform
.
mScale
.
scale
abortPaint
)
;
if
(
abortPaint
)
{
if
(
!
aPaintData
-
>
mFirstPaint
|
|
drawingLowPrecision
)
{
AUTO_PROFILER_LABEL
(
"
ClientMultiTiledLayerBuffer
:
:
ComputeProgressiveUpdateRegion
"
GRAPHICS
)
;
aRegionToPaint
.
SetEmpty
(
)
;
return
aIsRepeated
;
}
}
Maybe
<
LayerRect
>
transformedCompositionBounds
=
GetCompositorSideCompositionBounds
(
scrollAncestor
aPaintData
-
>
mTransformToCompBounds
viewTransform
LayerRect
(
mPaintedLayer
.
GetVisibleRegion
(
)
.
GetBounds
(
)
)
)
;
if
(
!
transformedCompositionBounds
)
{
aPaintData
-
>
mPaintFinished
=
true
;
return
false
;
}
TILING_LOG
(
"
TILING
%
p
:
Progressive
update
transformed
compositor
bounds
%
s
\
n
"
&
mPaintedLayer
Stringify
(
*
transformedCompositionBounds
)
.
c_str
(
)
)
;
IntRect
coherentUpdateRect
(
RoundedOut
(
#
ifdef
MOZ_WIDGET_ANDROID
transformedCompositionBounds
-
>
Intersect
(
aPaintData
-
>
mCompositionBounds
)
#
else
*
transformedCompositionBounds
#
endif
)
.
ToUnknownRect
(
)
)
;
TILING_LOG
(
"
TILING
%
p
:
Progressive
update
final
coherency
rect
%
s
\
n
"
&
mPaintedLayer
Stringify
(
coherentUpdateRect
)
.
c_str
(
)
)
;
aRegionToPaint
.
And
(
aInvalidRegion
coherentUpdateRect
)
;
aRegionToPaint
.
Or
(
aRegionToPaint
staleRegion
)
;
bool
drawingStale
=
!
aRegionToPaint
.
IsEmpty
(
)
;
if
(
!
drawingStale
)
{
aRegionToPaint
=
aInvalidRegion
;
}
bool
paintingVisible
=
false
;
if
(
aRegionToPaint
.
Intersects
(
coherentUpdateRect
)
)
{
aRegionToPaint
.
And
(
aRegionToPaint
coherentUpdateRect
)
;
paintingVisible
=
true
;
}
TILING_LOG
(
"
TILING
%
p
:
Progressive
update
final
paint
region
%
s
\
n
"
&
mPaintedLayer
Stringify
(
aRegionToPaint
)
.
c_str
(
)
)
;
bool
paintInSingleTransaction
=
paintingVisible
&
&
(
drawingStale
|
|
aPaintData
-
>
mFirstPaint
)
;
TILING_LOG
(
"
TILING
%
p
:
paintingVisible
%
d
drawingStale
%
d
firstPaint
%
d
singleTransaction
%
d
\
n
"
&
mPaintedLayer
paintingVisible
drawingStale
aPaintData
-
>
mFirstPaint
paintInSingleTransaction
)
;
NS_ASSERTION
(
!
aRegionToPaint
.
IsEmpty
(
)
"
Unexpectedly
empty
paint
region
!
"
)
;
IntRect
paintBounds
=
aRegionToPaint
.
GetBounds
(
)
;
int
startX
incX
startY
incY
;
gfx
:
:
IntSize
scaledTileSize
=
GetScaledTileSize
(
)
;
if
(
aPaintData
-
>
mScrollOffset
.
x
>
=
aPaintData
-
>
mLastScrollOffset
.
x
)
{
startX
=
RoundDownToTileEdge
(
paintBounds
.
X
(
)
scaledTileSize
.
width
)
;
incX
=
scaledTileSize
.
width
;
}
else
{
startX
=
RoundDownToTileEdge
(
paintBounds
.
XMost
(
)
-
1
scaledTileSize
.
width
)
;
incX
=
-
scaledTileSize
.
width
;
}
if
(
aPaintData
-
>
mScrollOffset
.
y
>
=
aPaintData
-
>
mLastScrollOffset
.
y
)
{
startY
=
RoundDownToTileEdge
(
paintBounds
.
Y
(
)
scaledTileSize
.
height
)
;
incY
=
scaledTileSize
.
height
;
}
else
{
startY
=
RoundDownToTileEdge
(
paintBounds
.
YMost
(
)
-
1
scaledTileSize
.
height
)
;
incY
=
-
scaledTileSize
.
height
;
}
IntRect
tileBounds
(
startX
startY
scaledTileSize
.
width
scaledTileSize
.
height
)
;
int32_t
scrollDiffX
=
aPaintData
-
>
mScrollOffset
.
x
-
aPaintData
-
>
mLastScrollOffset
.
x
;
int32_t
scrollDiffY
=
aPaintData
-
>
mScrollOffset
.
y
-
aPaintData
-
>
mLastScrollOffset
.
y
;
while
(
true
)
{
aRegionToPaint
.
And
(
aInvalidRegion
tileBounds
)
;
if
(
!
aRegionToPaint
.
IsEmpty
(
)
)
{
if
(
mResolution
!
=
1
)
{
aRegionToPaint
=
tileBounds
;
}
break
;
}
if
(
Abs
(
scrollDiffY
)
>
=
Abs
(
scrollDiffX
)
)
{
tileBounds
.
MoveByX
(
incX
)
;
}
else
{
tileBounds
.
MoveByY
(
incY
)
;
}
}
if
(
!
aRegionToPaint
.
Contains
(
aInvalidRegion
)
)
{
return
(
!
drawingLowPrecision
&
&
paintInSingleTransaction
)
;
}
aPaintData
-
>
mPaintFinished
=
true
;
return
false
;
}
bool
ClientMultiTiledLayerBuffer
:
:
ProgressiveUpdate
(
const
nsIntRegion
&
aValidRegion
const
nsIntRegion
&
aInvalidRegion
const
nsIntRegion
&
aOldValidRegion
nsIntRegion
&
aOutDrawnRegion
BasicTiledLayerPaintData
*
aPaintData
LayerManager
:
:
DrawPaintedLayerCallback
aCallback
void
*
aCallbackData
)
{
TILING_LOG
(
"
TILING
%
p
:
Progressive
update
valid
region
%
s
\
n
"
&
mPaintedLayer
Stringify
(
aValidRegion
)
.
c_str
(
)
)
;
TILING_LOG
(
"
TILING
%
p
:
Progressive
update
invalid
region
%
s
\
n
"
&
mPaintedLayer
Stringify
(
aInvalidRegion
)
.
c_str
(
)
)
;
TILING_LOG
(
"
TILING
%
p
:
Progressive
update
old
valid
region
%
s
\
n
"
&
mPaintedLayer
Stringify
(
aOldValidRegion
)
.
c_str
(
)
)
;
bool
repeat
=
false
;
bool
isBufferChanged
=
false
;
nsIntRegion
remainingInvalidRegion
=
aInvalidRegion
;
nsIntRegion
updatedValidRegion
=
aValidRegion
;
do
{
nsIntRegion
regionToPaint
;
repeat
=
ComputeProgressiveUpdateRegion
(
remainingInvalidRegion
aOldValidRegion
regionToPaint
aPaintData
repeat
)
;
TILING_LOG
(
"
TILING
%
p
:
Progressive
update
computed
paint
region
%
s
repeat
%
d
\
n
"
&
mPaintedLayer
Stringify
(
regionToPaint
)
.
c_str
(
)
repeat
)
;
if
(
regionToPaint
.
IsEmpty
(
)
)
{
break
;
}
isBufferChanged
=
true
;
aOutDrawnRegion
.
OrWith
(
regionToPaint
)
;
updatedValidRegion
.
OrWith
(
regionToPaint
)
;
nsIntRegion
validOrStale
;
validOrStale
.
Or
(
updatedValidRegion
aOldValidRegion
)
;
PaintThebes
(
validOrStale
regionToPaint
remainingInvalidRegion
aCallback
aCallbackData
TilePaintFlags
:
:
Progressive
)
;
remainingInvalidRegion
.
SubOut
(
regionToPaint
)
;
}
while
(
repeat
)
;
TILING_LOG
(
"
TILING
%
p
:
Progressive
update
final
valid
region
%
s
buffer
changed
%
d
\
n
"
&
mPaintedLayer
Stringify
(
updatedValidRegion
)
.
c_str
(
)
isBufferChanged
)
;
TILING_LOG
(
"
TILING
%
p
:
Progressive
update
final
invalid
region
%
s
\
n
"
&
mPaintedLayer
Stringify
(
remainingInvalidRegion
)
.
c_str
(
)
)
;
return
isBufferChanged
;
}
}
}
