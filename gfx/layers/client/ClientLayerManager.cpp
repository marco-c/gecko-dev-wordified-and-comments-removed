#
include
"
ClientLayerManager
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
gfxEnv
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Hal
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
TabGroup
.
h
"
#
include
"
mozilla
/
hal_sandbox
/
PHal
.
h
"
#
include
"
mozilla
/
layers
/
CompositableClient
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
FrameUniformityData
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
LayerTransactionChild
.
h
"
#
include
"
mozilla
/
layers
/
PersistentBufferProvider
.
h
"
#
include
"
mozilla
/
layers
/
SyncObject
.
h
"
#
include
"
mozilla
/
PerfStats
.
h
"
#
include
"
ClientReadbackLayer
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsIWidgetListener
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
TiledLayerBuffer
.
h
"
#
include
"
FrameLayerBuilder
.
h
"
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
AndroidBridge
.
h
"
#
include
"
LayerMetricsWrapper
.
h
"
#
endif
#
ifdef
XP_WIN
#
include
"
mozilla
/
gfx
/
DeviceManagerDx
.
h
"
#
include
"
gfxDWriteFonts
.
h
"
#
endif
namespace
mozilla
{
namespace
layers
{
using
namespace
mozilla
:
:
gfx
;
ClientLayerManager
:
:
ClientLayerManager
(
nsIWidget
*
aWidget
)
:
mPhase
(
PHASE_NONE
)
mWidget
(
aWidget
)
mPaintedLayerCallback
(
nullptr
)
mPaintedLayerCallbackData
(
nullptr
)
mLatestTransactionId
{
0
}
mLastPaintTime
(
TimeDuration
:
:
Forever
(
)
)
mTargetRotation
(
ROTATION_0
)
mRepeatTransaction
(
false
)
mIsRepeatTransaction
(
false
)
mTransactionIncomplete
(
false
)
mCompositorMightResample
(
false
)
mNeedsComposite
(
false
)
mQueuedAsyncPaints
(
false
)
mNotifyingWidgetListener
(
false
)
mPaintSequenceNumber
(
0
)
mForwarder
(
new
ShadowLayerForwarder
(
this
)
)
{
MOZ_COUNT_CTOR
(
ClientLayerManager
)
;
mMemoryPressureObserver
=
MemoryPressureObserver
:
:
Create
(
this
)
;
}
ClientLayerManager
:
:
~
ClientLayerManager
(
)
{
mMemoryPressureObserver
-
>
Unregister
(
)
;
ClearCachedResources
(
)
;
mForwarder
-
>
StopReceiveAsyncParentMessge
(
)
;
mRoot
=
nullptr
;
MOZ_COUNT_DTOR
(
ClientLayerManager
)
;
}
void
ClientLayerManager
:
:
Destroy
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mNotifyingWidgetListener
"
Try
to
avoid
destroying
widgets
and
layer
managers
"
"
during
DidCompositeWindow
if
you
can
"
)
;
ClearCachedResources
(
)
;
LayerManager
:
:
Destroy
(
)
;
if
(
mTransactionIdAllocator
)
{
RefPtr
<
TransactionIdAllocator
>
allocator
=
mTransactionIdAllocator
;
TransactionId
id
=
mLatestTransactionId
;
RefPtr
<
Runnable
>
task
=
NS_NewRunnableFunction
(
"
TransactionIdAllocator
:
:
NotifyTransactionCompleted
"
[
allocator
id
]
(
)
-
>
void
{
allocator
-
>
NotifyTransactionCompleted
(
id
)
;
}
)
;
NS_DispatchToMainThread
(
task
.
forget
(
)
)
;
}
mWidget
=
nullptr
;
}
TabGroup
*
ClientLayerManager
:
:
GetTabGroup
(
)
{
if
(
mWidget
)
{
if
(
BrowserChild
*
browserChild
=
mWidget
-
>
GetOwningBrowserChild
(
)
)
{
return
browserChild
-
>
TabGroup
(
)
;
}
}
return
nullptr
;
}
int32_t
ClientLayerManager
:
:
GetMaxTextureSize
(
)
const
{
return
mForwarder
-
>
GetMaxTextureSize
(
)
;
}
void
ClientLayerManager
:
:
SetDefaultTargetConfiguration
(
BufferMode
aDoubleBuffering
ScreenRotation
aRotation
)
{
mTargetRotation
=
aRotation
;
}
void
ClientLayerManager
:
:
SetRoot
(
Layer
*
aLayer
)
{
if
(
mRoot
!
=
aLayer
)
{
if
(
mRoot
)
{
Hold
(
mRoot
)
;
}
mForwarder
-
>
SetRoot
(
Hold
(
aLayer
)
)
;
NS_ASSERTION
(
aLayer
"
Root
can
'
t
be
null
"
)
;
NS_ASSERTION
(
aLayer
-
>
Manager
(
)
=
=
this
"
Wrong
manager
"
)
;
NS_ASSERTION
(
InConstruction
(
)
"
Only
allowed
in
construction
phase
"
)
;
mRoot
=
aLayer
;
}
}
void
ClientLayerManager
:
:
Mutated
(
Layer
*
aLayer
)
{
LayerManager
:
:
Mutated
(
aLayer
)
;
NS_ASSERTION
(
InConstruction
(
)
|
|
InDrawing
(
)
"
wrong
phase
"
)
;
mForwarder
-
>
Mutated
(
Hold
(
aLayer
)
)
;
}
void
ClientLayerManager
:
:
MutatedSimple
(
Layer
*
aLayer
)
{
LayerManager
:
:
MutatedSimple
(
aLayer
)
;
NS_ASSERTION
(
InConstruction
(
)
|
|
InDrawing
(
)
"
wrong
phase
"
)
;
mForwarder
-
>
MutatedSimple
(
Hold
(
aLayer
)
)
;
}
already_AddRefed
<
ReadbackLayer
>
ClientLayerManager
:
:
CreateReadbackLayer
(
)
{
RefPtr
<
ReadbackLayer
>
layer
=
new
ClientReadbackLayer
(
this
)
;
return
layer
.
forget
(
)
;
}
bool
ClientLayerManager
:
:
BeginTransactionWithTarget
(
gfxContext
*
aTarget
const
nsCString
&
aURL
)
{
#
ifdef
MOZ_DUMP_PAINTING
if
(
gfxEnv
:
:
DumpPaint
(
)
)
{
FlushAsyncPaints
(
)
;
}
#
endif
MOZ_ASSERT
(
mForwarder
"
ClientLayerManager
:
:
BeginTransaction
without
forwarder
"
)
;
if
(
!
mForwarder
-
>
IPCOpen
(
)
)
{
gfxCriticalNote
<
<
"
ClientLayerManager
:
:
BeginTransaction
with
IPC
channel
"
"
down
.
GPU
process
may
have
died
.
"
;
return
false
;
}
mInTransaction
=
true
;
mTransactionStart
=
TimeStamp
:
:
Now
(
)
;
mURL
=
aURL
;
#
ifdef
MOZ_LAYERS_HAVE_LOG
MOZ_LAYERS_LOG
(
(
"
[
-
-
-
-
-
BeginTransaction
"
)
)
;
Log
(
)
;
#
endif
NS_ASSERTION
(
!
InTransaction
(
)
"
Nested
transactions
not
allowed
"
)
;
mPhase
=
PHASE_CONSTRUCTION
;
MOZ_ASSERT
(
mKeepAlive
.
IsEmpty
(
)
"
uncommitted
txn
?
"
)
;
hal
:
:
ScreenOrientation
orientation
;
if
(
dom
:
:
BrowserChild
*
window
=
mWidget
-
>
GetOwningBrowserChild
(
)
)
{
orientation
=
window
-
>
GetOrientation
(
)
;
}
else
{
hal
:
:
ScreenConfiguration
currentConfig
;
hal
:
:
GetCurrentScreenConfiguration
(
&
currentConfig
)
;
orientation
=
currentConfig
.
orientation
(
)
;
}
LayoutDeviceIntRect
targetBounds
=
mWidget
-
>
GetNaturalBounds
(
)
;
targetBounds
.
MoveTo
(
0
0
)
;
mForwarder
-
>
BeginTransaction
(
targetBounds
.
ToUnknownRect
(
)
mTargetRotation
orientation
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
|
|
defined
(
MOZ_WIDGET_UIKIT
)
if
(
mWidget
&
&
mWidget
-
>
GetOwningBrowserChild
(
)
)
{
mCompositorMightResample
=
AsyncPanZoomEnabled
(
)
;
}
#
endif
if
(
aTarget
&
&
XRE_IsParentProcess
(
)
)
{
mShadowTarget
=
aTarget
;
}
else
{
NS_ASSERTION
(
!
aTarget
"
Content
-
process
ClientLayerManager
:
:
BeginTransactionWithTarget
not
"
"
supported
"
)
;
}
if
(
!
mIsRepeatTransaction
)
{
+
+
mPaintSequenceNumber
;
if
(
StaticPrefs
:
:
apz_test_logging_enabled
(
)
)
{
mApzTestData
.
StartNewPaint
(
mPaintSequenceNumber
)
;
}
}
return
true
;
}
bool
ClientLayerManager
:
:
BeginTransaction
(
const
nsCString
&
aURL
)
{
return
BeginTransactionWithTarget
(
nullptr
aURL
)
;
}
bool
ClientLayerManager
:
:
EndTransactionInternal
(
DrawPaintedLayerCallback
aCallback
void
*
aCallbackData
EndTransactionFlags
)
{
if
(
mForwarder
)
{
mForwarder
-
>
UpdateTextureLocks
(
)
;
}
{
PaintTelemetry
:
:
AutoRecord
record
(
PaintTelemetry
:
:
Metric
:
:
FlushRasterization
)
;
FlushAsyncPaints
(
)
;
}
PaintTelemetry
:
:
AutoRecord
record
(
PaintTelemetry
:
:
Metric
:
:
Rasterization
)
;
AUTO_PROFILER_TRACING
(
"
Paint
"
"
Rasterize
"
GRAPHICS
)
;
PerfStats
:
:
AutoMetricRecording
<
PerfStats
:
:
Metric
:
:
Rasterizing
>
autoRecording
;
Maybe
<
TimeStamp
>
startTime
;
if
(
StaticPrefs
:
:
LayersDrawFPS
(
)
)
{
startTime
=
Some
(
TimeStamp
:
:
Now
(
)
)
;
}
AUTO_PROFILER_LABEL
(
"
ClientLayerManager
:
:
EndTransactionInternal
"
GRAPHICS
)
;
#
ifdef
MOZ_LAYERS_HAVE_LOG
MOZ_LAYERS_LOG
(
(
"
-
-
-
-
-
(
beginning
paint
)
"
)
)
;
Log
(
)
;
#
endif
NS_ASSERTION
(
InConstruction
(
)
"
Should
be
in
construction
phase
"
)
;
mPhase
=
PHASE_DRAWING
;
ClientLayer
*
root
=
ClientLayer
:
:
ToClientLayer
(
GetRoot
(
)
)
;
mTransactionIncomplete
=
false
;
mQueuedAsyncPaints
=
false
;
auto
scrollIdsUpdated
=
GetRoot
(
)
-
>
ApplyPendingUpdatesToSubtree
(
)
;
mPaintedLayerCallback
=
aCallback
;
mPaintedLayerCallbackData
=
aCallbackData
;
GetRoot
(
)
-
>
ComputeEffectiveTransforms
(
Matrix4x4
(
)
)
;
if
(
!
gfxPlatform
:
:
GetPlatform
(
)
-
>
DidRenderingDeviceReset
(
)
)
{
if
(
StaticPrefs
:
:
AlwaysPaint
(
)
&
&
XRE_IsContentProcess
(
)
)
{
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
root
-
>
RenderLayer
(
)
;
mLastPaintTime
=
TimeStamp
:
:
Now
(
)
-
start
;
}
else
{
root
-
>
RenderLayer
(
)
;
}
}
else
{
gfxCriticalNote
<
<
"
LayerManager
:
:
EndTransaction
skip
RenderLayer
(
)
.
"
;
}
if
(
!
mTransactionIncomplete
)
{
for
(
ScrollableLayerGuid
:
:
ViewID
scrollId
:
scrollIdsUpdated
)
{
nsLayoutUtils
:
:
NotifyPaintSkipTransaction
(
scrollId
)
;
}
}
if
(
!
mRepeatTransaction
&
&
!
GetRoot
(
)
-
>
GetInvalidRegion
(
)
.
IsEmpty
(
)
)
{
GetRoot
(
)
-
>
Mutated
(
)
;
}
if
(
!
mIsRepeatTransaction
)
{
mAnimationReadyTime
=
TimeStamp
:
:
Now
(
)
;
GetRoot
(
)
-
>
StartPendingAnimations
(
mAnimationReadyTime
)
;
}
mPaintedLayerCallback
=
nullptr
;
mPaintedLayerCallbackData
=
nullptr
;
mPhase
=
mTransactionIncomplete
?
PHASE_CONSTRUCTION
:
PHASE_NONE
;
NS_ASSERTION
(
!
aCallback
|
|
!
mTransactionIncomplete
"
If
callback
is
not
null
transaction
must
be
complete
"
)
;
if
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
DidRenderingDeviceReset
(
)
)
{
FrameLayerBuilder
:
:
InvalidateAllLayers
(
this
)
;
}
if
(
startTime
)
{
PaintTiming
&
pt
=
mForwarder
-
>
GetPaintTiming
(
)
;
pt
.
rasterMs
(
)
=
(
TimeStamp
:
:
Now
(
)
-
startTime
.
value
(
)
)
.
ToMilliseconds
(
)
;
}
return
!
mTransactionIncomplete
;
}
void
ClientLayerManager
:
:
StorePluginWidgetConfigurations
(
const
nsTArray
<
nsIWidget
:
:
Configuration
>
&
aConfigurations
)
{
if
(
mForwarder
)
{
mForwarder
-
>
StorePluginWidgetConfigurations
(
aConfigurations
)
;
}
}
void
ClientLayerManager
:
:
EndTransaction
(
DrawPaintedLayerCallback
aCallback
void
*
aCallbackData
EndTransactionFlags
aFlags
)
{
if
(
!
mForwarder
-
>
IPCOpen
(
)
)
{
mInTransaction
=
false
;
return
;
}
if
(
mWidget
)
{
mWidget
-
>
PrepareWindowEffects
(
)
;
}
EndTransactionInternal
(
aCallback
aCallbackData
aFlags
)
;
if
(
XRE_IsContentProcess
(
)
)
{
RegisterPayload
(
{
CompositionPayloadType
:
:
eContentPaint
TimeStamp
:
:
Now
(
)
}
)
;
}
ForwardTransaction
(
!
(
aFlags
&
END_NO_REMOTE_COMPOSITE
)
)
;
if
(
mRepeatTransaction
)
{
mRepeatTransaction
=
false
;
mIsRepeatTransaction
=
true
;
TimeStamp
transactionStart
=
mTransactionStart
;
if
(
BeginTransaction
(
mURL
)
)
{
mTransactionStart
=
transactionStart
;
ClientLayerManager
:
:
EndTransaction
(
aCallback
aCallbackData
aFlags
)
;
}
mIsRepeatTransaction
=
false
;
}
else
{
MakeSnapshotIfRequired
(
)
;
}
mInTransaction
=
false
;
mTransactionStart
=
TimeStamp
(
)
;
}
bool
ClientLayerManager
:
:
EndEmptyTransaction
(
EndTransactionFlags
aFlags
)
{
mInTransaction
=
false
;
if
(
!
mRoot
|
|
!
mForwarder
-
>
IPCOpen
(
)
)
{
return
false
;
}
if
(
!
EndTransactionInternal
(
nullptr
nullptr
aFlags
)
)
{
if
(
PaintThread
:
:
Get
(
)
&
&
mQueuedAsyncPaints
)
{
PaintThread
:
:
Get
(
)
-
>
QueueEndLayerTransaction
(
nullptr
)
;
}
return
false
;
}
if
(
mWidget
)
{
mWidget
-
>
PrepareWindowEffects
(
)
;
}
ForwardTransaction
(
!
(
aFlags
&
END_NO_REMOTE_COMPOSITE
)
)
;
MakeSnapshotIfRequired
(
)
;
return
true
;
}
CompositorBridgeChild
*
ClientLayerManager
:
:
GetRemoteRenderer
(
)
{
if
(
!
mWidget
)
{
return
nullptr
;
}
return
mWidget
-
>
GetRemoteRenderer
(
)
;
}
CompositorBridgeChild
*
ClientLayerManager
:
:
GetCompositorBridgeChild
(
)
{
if
(
!
XRE_IsParentProcess
(
)
&
&
!
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
return
CompositorBridgeChild
:
:
Get
(
)
;
}
return
GetRemoteRenderer
(
)
;
}
void
ClientLayerManager
:
:
FlushAsyncPaints
(
)
{
AUTO_PROFILER_LABEL_CATEGORY_PAIR
(
GRAPHICS_FlushingAsyncPaints
)
;
CompositorBridgeChild
*
cbc
=
GetCompositorBridgeChild
(
)
;
if
(
cbc
)
{
cbc
-
>
FlushAsyncPaints
(
)
;
}
}
void
ClientLayerManager
:
:
ScheduleComposite
(
)
{
mForwarder
-
>
ScheduleComposite
(
)
;
}
void
ClientLayerManager
:
:
DidComposite
(
TransactionId
aTransactionId
const
TimeStamp
&
aCompositeStart
const
TimeStamp
&
aCompositeEnd
)
{
if
(
!
mWidget
)
{
MOZ_ASSERT
(
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
;
return
;
}
RefPtr
<
ClientLayerManager
>
selfRef
=
this
;
if
(
aTransactionId
.
IsValid
(
)
)
{
nsIWidgetListener
*
listener
=
mWidget
-
>
GetWidgetListener
(
)
;
if
(
listener
)
{
mNotifyingWidgetListener
=
true
;
listener
-
>
DidCompositeWindow
(
aTransactionId
aCompositeStart
aCompositeEnd
)
;
mNotifyingWidgetListener
=
false
;
}
if
(
mWidget
)
{
listener
=
mWidget
-
>
GetAttachedWidgetListener
(
)
;
if
(
listener
)
{
listener
-
>
DidCompositeWindow
(
aTransactionId
aCompositeStart
aCompositeEnd
)
;
}
}
if
(
mTransactionIdAllocator
)
{
mTransactionIdAllocator
-
>
NotifyTransactionCompleted
(
aTransactionId
)
;
}
}
for
(
size_t
i
=
0
;
i
<
mDidCompositeObservers
.
Length
(
)
;
i
+
+
)
{
mDidCompositeObservers
[
i
]
-
>
DidComposite
(
)
;
}
}
void
ClientLayerManager
:
:
GetCompositorSideAPZTestData
(
APZTestData
*
aData
)
const
{
if
(
mForwarder
-
>
HasShadowManager
(
)
)
{
if
(
!
mForwarder
-
>
GetShadowManager
(
)
-
>
SendGetAPZTestData
(
aData
)
)
{
NS_WARNING
(
"
Call
to
PLayerTransactionChild
:
:
SendGetAPZTestData
(
)
failed
"
)
;
}
}
}
void
ClientLayerManager
:
:
SetTransactionIdAllocator
(
TransactionIdAllocator
*
aAllocator
)
{
if
(
mTransactionIdAllocator
&
&
(
aAllocator
!
=
mTransactionIdAllocator
)
)
{
mTransactionIdAllocator
-
>
ClearPendingTransactions
(
)
;
if
(
aAllocator
)
{
aAllocator
-
>
ResetInitialTransactionId
(
mTransactionIdAllocator
-
>
LastTransactionId
(
)
)
;
}
}
mTransactionIdAllocator
=
aAllocator
;
}
float
ClientLayerManager
:
:
RequestProperty
(
const
nsAString
&
aProperty
)
{
if
(
mForwarder
-
>
HasShadowManager
(
)
)
{
float
value
;
if
(
!
mForwarder
-
>
GetShadowManager
(
)
-
>
SendRequestProperty
(
nsString
(
aProperty
)
&
value
)
)
{
NS_WARNING
(
"
Call
to
PLayerTransactionChild
:
:
SendGetAPZTestData
(
)
failed
"
)
;
}
return
value
;
}
return
-
1
;
}
void
ClientLayerManager
:
:
StartNewRepaintRequest
(
SequenceNumber
aSequenceNumber
)
{
if
(
StaticPrefs
:
:
apz_test_logging_enabled
(
)
)
{
mApzTestData
.
StartNewRepaintRequest
(
aSequenceNumber
)
;
}
}
void
ClientLayerManager
:
:
GetFrameUniformity
(
FrameUniformityData
*
aOutData
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Frame
Uniformity
only
supported
in
parent
process
"
)
;
if
(
HasShadowManager
(
)
)
{
CompositorBridgeChild
*
child
=
GetRemoteRenderer
(
)
;
child
-
>
SendGetFrameUniformity
(
aOutData
)
;
return
;
}
return
LayerManager
:
:
GetFrameUniformity
(
aOutData
)
;
}
void
ClientLayerManager
:
:
MakeSnapshotIfRequired
(
)
{
if
(
!
mShadowTarget
)
{
return
;
}
if
(
mWidget
)
{
if
(
CompositorBridgeChild
*
remoteRenderer
=
GetRemoteRenderer
(
)
)
{
LayoutDeviceIntRect
outerBounds
=
mWidget
-
>
GetBounds
(
)
;
IntRect
bounds
=
ToOutsideIntRect
(
mShadowTarget
-
>
GetClipExtents
(
)
)
;
if
(
mTargetRotation
)
{
bounds
=
RotateRect
(
bounds
outerBounds
.
ToUnknownRect
(
)
mTargetRotation
)
;
}
SurfaceDescriptor
inSnapshot
;
if
(
!
bounds
.
IsEmpty
(
)
&
&
mForwarder
-
>
AllocSurfaceDescriptor
(
bounds
.
Size
(
)
gfxContentType
:
:
COLOR_ALPHA
&
inSnapshot
)
)
{
SurfaceDescriptor
outSnapshot
=
inSnapshot
;
if
(
remoteRenderer
-
>
SendMakeSnapshot
(
inSnapshot
bounds
)
)
{
RefPtr
<
DataSourceSurface
>
surf
=
GetSurfaceForDescriptor
(
outSnapshot
)
;
DrawTarget
*
dt
=
mShadowTarget
-
>
GetDrawTarget
(
)
;
Rect
dstRect
(
bounds
.
X
(
)
bounds
.
Y
(
)
bounds
.
Width
(
)
bounds
.
Height
(
)
)
;
Rect
srcRect
(
0
0
bounds
.
Width
(
)
bounds
.
Height
(
)
)
;
gfx
:
:
Matrix
rotate
=
ComputeTransformForUnRotation
(
outerBounds
.
ToUnknownRect
(
)
mTargetRotation
)
;
gfx
:
:
Matrix
oldMatrix
=
dt
-
>
GetTransform
(
)
;
dt
-
>
SetTransform
(
rotate
*
oldMatrix
)
;
dt
-
>
DrawSurface
(
surf
dstRect
srcRect
DrawSurfaceOptions
(
)
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_OVER
)
)
;
dt
-
>
SetTransform
(
oldMatrix
)
;
}
mForwarder
-
>
DestroySurfaceDescriptor
(
&
outSnapshot
)
;
}
}
}
mShadowTarget
=
nullptr
;
}
void
ClientLayerManager
:
:
FlushRendering
(
)
{
if
(
mWidget
)
{
if
(
CompositorBridgeChild
*
remoteRenderer
=
mWidget
-
>
GetRemoteRenderer
(
)
)
{
if
(
mWidget
-
>
SynchronouslyRepaintOnResize
(
)
|
|
StaticPrefs
:
:
LayersForceSynchronousResize
(
)
)
{
remoteRenderer
-
>
SendFlushRendering
(
)
;
}
else
{
remoteRenderer
-
>
SendFlushRenderingAsync
(
)
;
}
}
}
}
void
ClientLayerManager
:
:
WaitOnTransactionProcessed
(
)
{
CompositorBridgeChild
*
remoteRenderer
=
GetCompositorBridgeChild
(
)
;
if
(
remoteRenderer
)
{
remoteRenderer
-
>
SendWaitOnTransactionProcessed
(
)
;
}
}
void
ClientLayerManager
:
:
UpdateTextureFactoryIdentifier
(
const
TextureFactoryIdentifier
&
aNewIdentifier
)
{
mForwarder
-
>
IdentifyTextureHost
(
aNewIdentifier
)
;
}
void
ClientLayerManager
:
:
SendInvalidRegion
(
const
nsIntRegion
&
aRegion
)
{
if
(
mWidget
)
{
if
(
CompositorBridgeChild
*
remoteRenderer
=
mWidget
-
>
GetRemoteRenderer
(
)
)
{
remoteRenderer
-
>
SendNotifyRegionInvalidated
(
aRegion
)
;
}
}
}
uint32_t
ClientLayerManager
:
:
StartFrameTimeRecording
(
int32_t
aBufferSize
)
{
CompositorBridgeChild
*
renderer
=
GetRemoteRenderer
(
)
;
if
(
renderer
)
{
uint32_t
startIndex
;
renderer
-
>
SendStartFrameTimeRecording
(
aBufferSize
&
startIndex
)
;
return
startIndex
;
}
return
-
1
;
}
void
ClientLayerManager
:
:
StopFrameTimeRecording
(
uint32_t
aStartIndex
nsTArray
<
float
>
&
aFrameIntervals
)
{
CompositorBridgeChild
*
renderer
=
GetRemoteRenderer
(
)
;
if
(
renderer
)
{
renderer
-
>
SendStopFrameTimeRecording
(
aStartIndex
&
aFrameIntervals
)
;
}
}
void
ClientLayerManager
:
:
ForwardTransaction
(
bool
aScheduleComposite
)
{
AUTO_PROFILER_TRACING
(
"
Paint
"
"
ForwardTransaction
"
GRAPHICS
)
;
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
GetCompositorBridgeChild
(
)
-
>
EndCanvasTransaction
(
)
;
RefPtr
<
SyncObjectClient
>
syncObject
=
nullptr
;
if
(
!
gfxPlatform
:
:
GetPlatform
(
)
-
>
DidRenderingDeviceReset
(
)
)
{
if
(
mForwarder
-
>
GetSyncObject
(
)
&
&
mForwarder
-
>
GetSyncObject
(
)
-
>
IsSyncObjectValid
(
)
)
{
syncObject
=
mForwarder
-
>
GetSyncObject
(
)
;
}
}
if
(
mQueuedAsyncPaints
)
{
MOZ_ASSERT
(
PaintThread
:
:
Get
(
)
)
;
PaintThread
:
:
Get
(
)
-
>
QueueEndLayerTransaction
(
syncObject
)
;
}
else
if
(
syncObject
)
{
syncObject
-
>
Synchronize
(
)
;
}
mPhase
=
PHASE_FORWARD
;
mLatestTransactionId
=
mTransactionIdAllocator
-
>
GetTransactionId
(
!
mIsRepeatTransaction
)
;
TimeStamp
refreshStart
=
mTransactionIdAllocator
-
>
GetTransactionStart
(
)
;
if
(
!
refreshStart
)
{
refreshStart
=
mTransactionStart
;
}
if
(
StaticPrefs
:
:
AlwaysPaint
(
)
&
&
XRE_IsContentProcess
(
)
)
{
mForwarder
-
>
SendPaintTime
(
mLatestTransactionId
mLastPaintTime
)
;
}
bool
sent
=
false
;
bool
ok
=
mForwarder
-
>
EndTransaction
(
mRegionToClear
mLatestTransactionId
aScheduleComposite
mPaintSequenceNumber
mIsRepeatTransaction
mTransactionIdAllocator
-
>
GetVsyncId
(
)
mTransactionIdAllocator
-
>
GetVsyncStart
(
)
refreshStart
mTransactionStart
mContainsSVG
mURL
&
sent
mPayload
)
;
if
(
ok
)
{
if
(
sent
)
{
mPayload
.
Clear
(
)
;
mNeedsComposite
=
false
;
}
}
else
if
(
HasShadowManager
(
)
)
{
NS_WARNING
(
"
failed
to
forward
Layers
transaction
"
)
;
}
if
(
!
sent
)
{
mTransactionIdAllocator
-
>
RevokeTransactionId
(
mLatestTransactionId
)
;
mLatestTransactionId
=
mLatestTransactionId
.
Prev
(
)
;
}
mPhase
=
PHASE_NONE
;
mKeepAlive
.
Clear
(
)
;
BrowserChild
*
window
=
mWidget
?
mWidget
-
>
GetOwningBrowserChild
(
)
:
nullptr
;
if
(
window
)
{
TimeStamp
end
=
TimeStamp
:
:
Now
(
)
;
window
-
>
DidRequestComposite
(
start
end
)
;
}
}
ShadowableLayer
*
ClientLayerManager
:
:
Hold
(
Layer
*
aLayer
)
{
MOZ_ASSERT
(
HasShadowManager
(
)
"
top
-
level
tree
no
shadow
tree
to
remote
to
"
)
;
ShadowableLayer
*
shadowable
=
ClientLayer
:
:
ToClientLayer
(
aLayer
)
;
MOZ_ASSERT
(
shadowable
"
trying
to
remote
an
unshadowable
layer
"
)
;
mKeepAlive
.
AppendElement
(
aLayer
)
;
return
shadowable
;
}
bool
ClientLayerManager
:
:
IsCompositingCheap
(
)
{
return
mForwarder
-
>
mShadowManager
&
&
LayerManager
:
:
IsCompositingCheap
(
mForwarder
-
>
GetCompositorBackendType
(
)
)
;
}
bool
ClientLayerManager
:
:
AreComponentAlphaLayersEnabled
(
)
{
return
GetCompositorBackendType
(
)
!
=
LayersBackend
:
:
LAYERS_BASIC
&
&
AsShadowForwarder
(
)
-
>
SupportsComponentAlpha
(
)
&
&
LayerManager
:
:
AreComponentAlphaLayersEnabled
(
)
;
}
void
ClientLayerManager
:
:
SetIsFirstPaint
(
)
{
mForwarder
-
>
SetIsFirstPaint
(
)
;
}
void
ClientLayerManager
:
:
SetFocusTarget
(
const
FocusTarget
&
aFocusTarget
)
{
mForwarder
-
>
SetFocusTarget
(
aFocusTarget
)
;
}
void
ClientLayerManager
:
:
ClearCachedResources
(
Layer
*
aSubtree
)
{
if
(
mDestroyed
)
{
return
;
}
MOZ_ASSERT
(
!
HasShadowManager
(
)
|
|
!
aSubtree
)
;
mForwarder
-
>
ClearCachedResources
(
)
;
if
(
aSubtree
)
{
ClearLayer
(
aSubtree
)
;
}
else
if
(
mRoot
)
{
ClearLayer
(
mRoot
)
;
}
}
void
ClientLayerManager
:
:
OnMemoryPressure
(
MemoryPressureReason
aWhy
)
{
if
(
mRoot
)
{
HandleMemoryPressureLayer
(
mRoot
)
;
}
if
(
GetCompositorBridgeChild
(
)
)
{
GetCompositorBridgeChild
(
)
-
>
HandleMemoryPressure
(
)
;
}
}
void
ClientLayerManager
:
:
ClearLayer
(
Layer
*
aLayer
)
{
aLayer
-
>
ClearCachedResources
(
)
;
for
(
Layer
*
child
=
aLayer
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
ClearLayer
(
child
)
;
}
}
void
ClientLayerManager
:
:
HandleMemoryPressureLayer
(
Layer
*
aLayer
)
{
ClientLayer
:
:
ToClientLayer
(
aLayer
)
-
>
HandleMemoryPressure
(
)
;
for
(
Layer
*
child
=
aLayer
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
HandleMemoryPressureLayer
(
child
)
;
}
}
void
ClientLayerManager
:
:
GetBackendName
(
nsAString
&
aName
)
{
switch
(
mForwarder
-
>
GetCompositorBackendType
(
)
)
{
case
LayersBackend
:
:
LAYERS_NONE
:
aName
.
AssignLiteral
(
"
None
"
)
;
return
;
case
LayersBackend
:
:
LAYERS_BASIC
:
aName
.
AssignLiteral
(
"
Basic
"
)
;
return
;
case
LayersBackend
:
:
LAYERS_OPENGL
:
aName
.
AssignLiteral
(
"
OpenGL
"
)
;
return
;
case
LayersBackend
:
:
LAYERS_D3D11
:
{
#
ifdef
XP_WIN
if
(
DeviceManagerDx
:
:
Get
(
)
-
>
IsWARP
(
)
)
{
aName
.
AssignLiteral
(
"
Direct3D
11
WARP
"
)
;
}
else
{
aName
.
AssignLiteral
(
"
Direct3D
11
"
)
;
}
#
endif
return
;
}
default
:
MOZ_CRASH
(
"
Invalid
backend
"
)
;
}
}
bool
ClientLayerManager
:
:
AsyncPanZoomEnabled
(
)
const
{
return
mWidget
&
&
mWidget
-
>
AsyncPanZoomEnabled
(
)
;
}
void
ClientLayerManager
:
:
SetLayersObserverEpoch
(
LayersObserverEpoch
aEpoch
)
{
mForwarder
-
>
SetLayersObserverEpoch
(
aEpoch
)
;
}
void
ClientLayerManager
:
:
AddDidCompositeObserver
(
DidCompositeObserver
*
aObserver
)
{
if
(
!
mDidCompositeObservers
.
Contains
(
aObserver
)
)
{
mDidCompositeObservers
.
AppendElement
(
aObserver
)
;
}
}
void
ClientLayerManager
:
:
RemoveDidCompositeObserver
(
DidCompositeObserver
*
aObserver
)
{
mDidCompositeObservers
.
RemoveElement
(
aObserver
)
;
}
already_AddRefed
<
PersistentBufferProvider
>
ClientLayerManager
:
:
CreatePersistentBufferProvider
(
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
)
{
if
(
IsCompositingCheap
(
)
)
{
RefPtr
<
PersistentBufferProvider
>
provider
=
PersistentBufferProviderShared
:
:
Create
(
aSize
aFormat
AsShadowForwarder
(
)
)
;
if
(
provider
)
{
return
provider
.
forget
(
)
;
}
}
return
LayerManager
:
:
CreatePersistentBufferProvider
(
aSize
aFormat
)
;
}
ClientLayer
:
:
~
ClientLayer
(
)
{
MOZ_COUNT_DTOR
(
ClientLayer
)
;
}
}
}
