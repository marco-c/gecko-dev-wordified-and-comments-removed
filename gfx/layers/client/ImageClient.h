#
ifndef
MOZILLA_GFX_IMAGECLIENT_H
#
define
MOZILLA_GFX_IMAGECLIENT_H
#
include
<
stdint
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
CompositableClient
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsRect
.
h
"
namespace
mozilla
{
namespace
layers
{
class
ClientLayer
;
class
CompositableForwarder
;
class
Image
;
class
ImageContainer
;
class
ShadowableLayer
;
class
ImageClientSingle
;
class
ImageClient
:
public
CompositableClient
{
public
:
static
already_AddRefed
<
ImageClient
>
CreateImageClient
(
CompositableType
aImageHostType
CompositableForwarder
*
aFwd
TextureFlags
aFlags
)
;
virtual
~
ImageClient
(
)
=
default
;
virtual
bool
UpdateImage
(
ImageContainer
*
aContainer
uint32_t
aContentFlags
const
Maybe
<
wr
:
:
RenderRoot
>
&
aRenderRoot
)
=
0
;
void
SetLayer
(
ClientLayer
*
aLayer
)
{
mLayer
=
aLayer
;
}
ClientLayer
*
GetLayer
(
)
const
{
return
mLayer
;
}
virtual
void
FlushAllImages
(
)
{
}
virtual
void
RemoveTexture
(
TextureClient
*
aTexture
const
Maybe
<
wr
:
:
RenderRoot
>
&
aRenderRoot
)
override
;
virtual
ImageClientSingle
*
AsImageClientSingle
(
)
{
return
nullptr
;
}
static
already_AddRefed
<
TextureClient
>
CreateTextureClientForImage
(
Image
*
aImage
KnowsCompositor
*
aForwarder
)
;
uint32_t
GetLastUpdateGenerationCounter
(
)
{
return
mLastUpdateGenerationCounter
;
}
virtual
RefPtr
<
TextureClient
>
GetForwardedTexture
(
)
{
return
nullptr
;
}
protected
:
ImageClient
(
CompositableForwarder
*
aFwd
TextureFlags
aFlags
CompositableType
aType
)
;
ClientLayer
*
mLayer
;
CompositableType
mType
;
uint32_t
mLastUpdateGenerationCounter
;
}
;
class
ImageClientSingle
:
public
ImageClient
{
public
:
ImageClientSingle
(
CompositableForwarder
*
aFwd
TextureFlags
aFlags
CompositableType
aType
)
;
bool
UpdateImage
(
ImageContainer
*
aContainer
uint32_t
aContentFlag
const
Maybe
<
wr
:
:
RenderRoot
>
&
aRenderRoot
)
override
;
void
OnDetach
(
)
override
;
bool
AddTextureClient
(
TextureClient
*
aTexture
)
override
;
TextureInfo
GetTextureInfo
(
)
const
override
;
void
FlushAllImages
(
)
override
;
ImageClientSingle
*
AsImageClientSingle
(
)
override
{
return
this
;
}
RefPtr
<
TextureClient
>
GetForwardedTexture
(
)
override
;
bool
IsEmpty
(
)
{
return
mBuffers
.
IsEmpty
(
)
;
}
protected
:
struct
Buffer
{
RefPtr
<
TextureClient
>
mTextureClient
;
int32_t
mImageSerial
;
}
;
nsTArray
<
Buffer
>
mBuffers
;
}
;
class
ImageClientBridge
:
public
ImageClient
{
public
:
ImageClientBridge
(
CompositableForwarder
*
aFwd
TextureFlags
aFlags
)
;
bool
UpdateImage
(
ImageContainer
*
aContainer
uint32_t
aContentFlags
const
Maybe
<
wr
:
:
RenderRoot
>
&
aRenderRoot
)
override
;
bool
Connect
(
ImageContainer
*
aImageContainer
)
override
{
return
false
;
}
TextureInfo
GetTextureInfo
(
)
const
override
{
return
TextureInfo
(
mType
)
;
}
protected
:
CompositableHandle
mAsyncContainerHandle
;
}
;
}
}
#
endif
