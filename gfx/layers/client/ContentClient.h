#
ifndef
MOZILLA_GFX_CONTENTCLIENT_H
#
define
MOZILLA_GFX_CONTENTCLIENT_H
#
include
<
stdint
.
h
>
#
include
"
RotatedBuffer
.
h
"
#
include
"
gfxTypes
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
layers
/
CompositableClient
.
h
"
#
include
"
mozilla
/
layers
/
CompositableForwarder
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
layers
/
PaintThread
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
ReadbackProcessor
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
namespace
gfx
{
class
DrawTarget
;
}
namespace
layers
{
class
PaintedLayer
;
class
ContentClient
:
public
CompositableClient
{
public
:
typedef
gfxContentType
ContentType
;
static
already_AddRefed
<
ContentClient
>
CreateContentClient
(
CompositableForwarder
*
aFwd
)
;
enum
BufferSizePolicy
{
SizedToVisibleBounds
ContainsVisibleBounds
}
;
ContentClient
(
CompositableForwarder
*
aForwarder
BufferSizePolicy
aBufferSizePolicy
)
:
CompositableClient
(
aForwarder
)
mBufferSizePolicy
(
aBufferSizePolicy
)
{
}
virtual
void
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
;
virtual
void
Clear
(
)
;
struct
PaintState
{
PaintState
(
)
:
mRegionToDraw
(
)
mRegionToInvalidate
(
)
mMode
(
SurfaceMode
:
:
SURFACE_NONE
)
mClip
(
DrawRegionClip
:
:
NONE
)
mContentType
(
gfxContentType
:
:
SENTINEL
)
mAsyncPaint
(
false
)
mAsyncTask
(
nullptr
)
{
}
nsIntRegion
mRegionToDraw
;
nsIntRegion
mRegionToInvalidate
;
SurfaceMode
mMode
;
DrawRegionClip
mClip
;
gfxContentType
mContentType
;
bool
mAsyncPaint
;
UniquePtr
<
PaintTask
>
mAsyncTask
;
}
;
enum
{
PAINT_WILL_RESAMPLE
=
0x01
PAINT_NO_ROTATION
=
0x02
PAINT_CAN_DRAW_ROTATED
=
0x04
PAINT_ASYNC
=
0x08
}
;
virtual
PaintState
BeginPaint
(
PaintedLayer
*
aLayer
uint32_t
aFlags
)
;
virtual
void
EndPaint
(
PaintState
&
aPaintState
nsTArray
<
ReadbackProcessor
:
:
Update
>
*
aReadbackUpdates
=
nullptr
)
;
virtual
gfx
:
:
DrawTarget
*
BorrowDrawTargetForPainting
(
PaintState
&
aPaintState
RotatedBuffer
:
:
DrawIterator
*
aIter
=
nullptr
)
;
void
ReturnDrawTarget
(
gfx
:
:
DrawTarget
*
&
aReturned
)
;
enum
{
BUFFER_COMPONENT_ALPHA
=
0x02
}
;
protected
:
struct
BufferDecision
{
nsIntRegion
mNeededRegion
;
nsIntRegion
mValidRegion
;
gfx
:
:
IntRect
mBufferRect
;
SurfaceMode
mBufferMode
;
gfxContentType
mBufferContentType
;
bool
mCanReuseBuffer
;
bool
mCanKeepBufferContents
;
}
;
BufferDecision
CalculateBufferForPaint
(
PaintedLayer
*
aLayer
uint32_t
aFlags
)
;
static
bool
ValidBufferSize
(
BufferSizePolicy
aPolicy
const
gfx
:
:
IntSize
&
aBufferSize
const
gfx
:
:
IntSize
&
aVisibleBoundsSize
)
;
virtual
void
FinalizeFrame
(
PaintState
&
aPaintState
)
{
}
virtual
RefPtr
<
RotatedBuffer
>
GetFrontBuffer
(
)
const
{
return
mBuffer
;
}
virtual
RefPtr
<
RotatedBuffer
>
CreateBuffer
(
gfxContentType
aType
const
gfx
:
:
IntRect
&
aRect
uint32_t
aFlags
)
=
0
;
RefPtr
<
RotatedBuffer
>
mBuffer
;
BufferSizePolicy
mBufferSizePolicy
;
}
;
class
ContentClientBasic
final
:
public
ContentClient
{
public
:
explicit
ContentClientBasic
(
gfx
:
:
BackendType
aBackend
)
;
void
DrawTo
(
PaintedLayer
*
aLayer
gfx
:
:
DrawTarget
*
aTarget
float
aOpacity
gfx
:
:
CompositionOp
aOp
gfx
:
:
SourceSurface
*
aMask
const
gfx
:
:
Matrix
*
aMaskTransform
)
;
TextureInfo
GetTextureInfo
(
)
const
override
{
MOZ_CRASH
(
"
GFX
:
Should
not
be
called
on
non
-
remote
ContentClient
"
)
;
}
protected
:
RefPtr
<
RotatedBuffer
>
CreateBuffer
(
gfxContentType
aType
const
gfx
:
:
IntRect
&
aRect
uint32_t
aFlags
)
override
;
private
:
gfx
:
:
BackendType
mBackend
;
}
;
class
ContentClientRemoteBuffer
:
public
ContentClient
{
public
:
explicit
ContentClientRemoteBuffer
(
CompositableForwarder
*
aForwarder
)
:
ContentClient
(
aForwarder
ContainsVisibleBounds
)
mIsNewBuffer
(
false
)
{
}
void
Dump
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
=
"
"
bool
aDumpHtml
=
false
TextureDumpMode
aCompress
=
TextureDumpMode
:
:
Compress
)
override
;
void
EndPaint
(
PaintState
&
aPaintState
nsTArray
<
ReadbackProcessor
:
:
Update
>
*
aReadbackUpdates
=
nullptr
)
override
;
void
Updated
(
const
nsIntRegion
&
aRegionToDraw
const
nsIntRegion
&
aVisibleRegion
)
;
TextureFlags
ExtraTextureFlags
(
)
const
{
return
TextureFlags
:
:
IMMEDIATE_UPLOAD
;
}
protected
:
virtual
void
SwapBuffers
(
const
nsIntRegion
&
aFrontUpdatedRegion
)
{
}
virtual
nsIntRegion
GetUpdatedRegion
(
const
nsIntRegion
&
aRegionToDraw
const
nsIntRegion
&
aVisibleRegion
)
;
RefPtr
<
RotatedBuffer
>
CreateBuffer
(
gfxContentType
aType
const
gfx
:
:
IntRect
&
aRect
uint32_t
aFlags
)
override
;
RefPtr
<
RotatedBuffer
>
CreateBufferInternal
(
const
gfx
:
:
IntRect
&
aRect
gfx
:
:
SurfaceFormat
aFormat
TextureFlags
aFlags
)
;
RemoteRotatedBuffer
*
GetRemoteBuffer
(
)
const
{
return
static_cast
<
RemoteRotatedBuffer
*
>
(
mBuffer
.
get
(
)
)
;
}
bool
mIsNewBuffer
;
}
;
class
ContentClientDoubleBuffered
:
public
ContentClientRemoteBuffer
{
public
:
explicit
ContentClientDoubleBuffered
(
CompositableForwarder
*
aFwd
)
:
ContentClientRemoteBuffer
(
aFwd
)
mFrontAndBackBufferDiffer
(
false
)
{
}
void
Dump
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
=
"
"
bool
aDumpHtml
=
false
TextureDumpMode
aCompress
=
TextureDumpMode
:
:
Compress
)
override
;
void
Clear
(
)
override
;
void
SwapBuffers
(
const
nsIntRegion
&
aFrontUpdatedRegion
)
override
;
PaintState
BeginPaint
(
PaintedLayer
*
aLayer
uint32_t
aFlags
)
override
;
void
FinalizeFrame
(
PaintState
&
aPaintState
)
override
;
RefPtr
<
RotatedBuffer
>
GetFrontBuffer
(
)
const
override
{
return
mFrontBuffer
;
}
TextureInfo
GetTextureInfo
(
)
const
override
{
return
TextureInfo
(
CompositableType
:
:
CONTENT_DOUBLE
mTextureFlags
)
;
}
private
:
void
EnsureBackBufferIfFrontBuffer
(
)
;
RefPtr
<
RemoteRotatedBuffer
>
mFrontBuffer
;
nsIntRegion
mFrontUpdatedRegion
;
bool
mFrontAndBackBufferDiffer
;
}
;
class
ContentClientSingleBuffered
:
public
ContentClientRemoteBuffer
{
public
:
explicit
ContentClientSingleBuffered
(
CompositableForwarder
*
aFwd
)
:
ContentClientRemoteBuffer
(
aFwd
)
{
}
TextureInfo
GetTextureInfo
(
)
const
override
{
return
TextureInfo
(
CompositableType
:
:
CONTENT_SINGLE
mTextureFlags
|
ExtraTextureFlags
(
)
)
;
}
}
;
}
}
#
endif
