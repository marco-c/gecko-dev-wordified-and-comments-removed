#
ifndef
MOZILLA_GFX_CONTENTCLIENT_H
#
define
MOZILLA_GFX_CONTENTCLIENT_H
#
include
<
stdint
.
h
>
#
include
"
gfxTypes
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
layers
/
CompositableClient
.
h
"
#
include
"
mozilla
/
layers
/
CompositableForwarder
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
ReadbackProcessor
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
namespace
gfx
{
class
DrawTarget
;
}
namespace
layers
{
class
ContentClient
:
public
CompositableClient
{
public
:
typedef
gfxContentType
ContentType
;
static
already_AddRefed
<
ContentClient
>
CreateContentClient
(
CompositableForwarder
*
aFwd
)
;
enum
BufferSizePolicy
{
SizedToVisibleBounds
ContainsVisibleBounds
}
;
ContentClient
(
CompositableForwarder
*
aForwarder
BufferSizePolicy
aBufferSizePolicy
)
:
CompositableClient
(
aForwarder
)
mBufferSizePolicy
(
aBufferSizePolicy
)
{
}
virtual
void
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
;
virtual
void
Clear
(
)
;
struct
PaintState
{
PaintState
(
)
:
mRegionToDraw
(
)
mRegionToInvalidate
(
)
mMode
(
SurfaceMode
:
:
SURFACE_NONE
)
mClip
(
DrawRegionClip
:
:
NONE
)
mContentType
(
gfxContentType
:
:
SENTINEL
)
{
}
nsIntRegion
mRegionToDraw
;
nsIntRegion
mRegionToInvalidate
;
SurfaceMode
mMode
;
DrawRegionClip
mClip
;
gfxContentType
mContentType
;
}
;
enum
{
PAINT_WILL_RESAMPLE
=
0x01
PAINT_NO_ROTATION
=
0x02
PAINT_CAN_DRAW_ROTATED
=
0x04
PAINT_ASYNC
=
0x08
}
;
virtual
PaintState
BeginPaint
(
PaintedLayer
*
aLayer
uint32_t
aFlags
)
;
virtual
void
EndPaint
(
PaintState
&
aPaintState
nsTArray
<
ReadbackProcessor
:
:
Update
>
*
aReadbackUpdates
=
nullptr
)
;
void
ReturnDrawTarget
(
gfx
:
:
DrawTarget
*
&
aReturned
)
;
enum
{
BUFFER_COMPONENT_ALPHA
=
0x02
}
;
protected
:
struct
BufferDecision
{
nsIntRegion
mNeededRegion
;
nsIntRegion
mValidRegion
;
gfx
:
:
IntRect
mBufferRect
;
SurfaceMode
mBufferMode
;
gfxContentType
mBufferContentType
;
bool
mCanReuseBuffer
;
bool
mCanKeepBufferContents
;
}
;
BufferDecision
CalculateBufferForPaint
(
PaintedLayer
*
aLayer
uint32_t
aFlags
)
;
static
bool
ValidBufferSize
(
BufferSizePolicy
aPolicy
const
gfx
:
:
IntSize
&
aBufferSize
const
gfx
:
:
IntSize
&
aVisibleBoundsSize
)
;
virtual
void
FinalizeFrame
(
PaintState
&
aPaintState
)
{
}
BufferSizePolicy
mBufferSizePolicy
;
}
;
class
ContentClientRemoteBuffer
:
public
ContentClient
{
public
:
explicit
ContentClientRemoteBuffer
(
CompositableForwarder
*
aForwarder
)
:
ContentClient
(
aForwarder
ContainsVisibleBounds
)
mIsNewBuffer
(
false
)
{
}
void
Dump
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
=
"
"
bool
aDumpHtml
=
false
TextureDumpMode
aCompress
=
TextureDumpMode
:
:
Compress
)
override
;
void
EndPaint
(
PaintState
&
aPaintState
nsTArray
<
ReadbackProcessor
:
:
Update
>
*
aReadbackUpdates
=
nullptr
)
override
;
void
Updated
(
const
nsIntRegion
&
aRegionToDraw
const
nsIntRegion
&
aVisibleRegion
)
;
TextureFlags
ExtraTextureFlags
(
)
const
{
return
TextureFlags
:
:
IMMEDIATE_UPLOAD
;
}
protected
:
virtual
void
SwapBuffers
(
const
nsIntRegion
&
aFrontUpdatedRegion
)
{
}
virtual
nsIntRegion
GetUpdatedRegion
(
const
nsIntRegion
&
aRegionToDraw
const
nsIntRegion
&
aVisibleRegion
)
;
bool
mIsNewBuffer
;
}
;
class
ContentClientDoubleBuffered
:
public
ContentClientRemoteBuffer
{
public
:
explicit
ContentClientDoubleBuffered
(
CompositableForwarder
*
aFwd
)
:
ContentClientRemoteBuffer
(
aFwd
)
mFrontAndBackBufferDiffer
(
false
)
{
}
void
Dump
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
=
"
"
bool
aDumpHtml
=
false
TextureDumpMode
aCompress
=
TextureDumpMode
:
:
Compress
)
override
;
void
Clear
(
)
override
;
void
SwapBuffers
(
const
nsIntRegion
&
aFrontUpdatedRegion
)
override
;
PaintState
BeginPaint
(
PaintedLayer
*
aLayer
uint32_t
aFlags
)
override
;
void
FinalizeFrame
(
PaintState
&
aPaintState
)
override
;
TextureInfo
GetTextureInfo
(
)
const
override
{
return
TextureInfo
(
CompositableType
:
:
CONTENT_DOUBLE
mTextureFlags
)
;
}
private
:
void
EnsureBackBufferIfFrontBuffer
(
)
;
nsIntRegion
mFrontUpdatedRegion
;
bool
mFrontAndBackBufferDiffer
;
}
;
class
ContentClientSingleBuffered
:
public
ContentClientRemoteBuffer
{
public
:
explicit
ContentClientSingleBuffered
(
CompositableForwarder
*
aFwd
)
:
ContentClientRemoteBuffer
(
aFwd
)
{
}
TextureInfo
GetTextureInfo
(
)
const
override
{
return
TextureInfo
(
CompositableType
:
:
CONTENT_SINGLE
mTextureFlags
|
ExtraTextureFlags
(
)
)
;
}
}
;
}
}
#
endif
