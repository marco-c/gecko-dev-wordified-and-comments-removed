#
include
"
ImageClient
.
h
"
#
include
<
stdint
.
h
>
#
include
"
ClientLayerManager
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
ImageTypes
.
h
"
#
include
"
GLImages
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
BaseSize
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
CompositableClient
.
h
"
#
include
"
mozilla
/
layers
/
CompositableForwarder
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
ShadowLayers
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
layers
/
TextureClientOGL
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRect
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
mozilla
:
:
gfx
;
already_AddRefed
<
ImageClient
>
ImageClient
:
:
CreateImageClient
(
CompositableType
aCompositableHostType
CompositableForwarder
*
aForwarder
TextureFlags
aFlags
)
{
RefPtr
<
ImageClient
>
result
=
nullptr
;
switch
(
aCompositableHostType
)
{
case
CompositableType
:
:
IMAGE
:
result
=
new
ImageClientSingle
(
aForwarder
aFlags
CompositableType
:
:
IMAGE
)
;
break
;
case
CompositableType
:
:
IMAGE_BRIDGE
:
result
=
new
ImageClientBridge
(
aForwarder
aFlags
)
;
break
;
case
CompositableType
:
:
UNKNOWN
:
result
=
nullptr
;
break
;
default
:
MOZ_CRASH
(
"
GFX
:
unhandled
program
type
image
"
)
;
}
NS_ASSERTION
(
result
"
Failed
to
create
ImageClient
"
)
;
return
result
.
forget
(
)
;
}
void
ImageClient
:
:
RemoveTexture
(
TextureClient
*
aTexture
)
{
GetForwarder
(
)
-
>
RemoveTextureFromCompositable
(
this
aTexture
)
;
}
ImageClientSingle
:
:
ImageClientSingle
(
CompositableForwarder
*
aFwd
TextureFlags
aFlags
CompositableType
aType
)
:
ImageClient
(
aFwd
aFlags
aType
)
{
}
TextureInfo
ImageClientSingle
:
:
GetTextureInfo
(
)
const
{
return
TextureInfo
(
CompositableType
:
:
IMAGE
)
;
}
void
ImageClientSingle
:
:
FlushAllImages
(
)
{
for
(
auto
&
b
:
mBuffers
)
{
RemoveTexture
(
b
.
mTextureClient
)
;
}
mBuffers
.
Clear
(
)
;
}
already_AddRefed
<
TextureClient
>
ImageClient
:
:
CreateTextureClientForImage
(
Image
*
aImage
KnowsCompositor
*
aForwarder
)
{
RefPtr
<
TextureClient
>
texture
;
if
(
aImage
-
>
GetFormat
(
)
=
=
ImageFormat
:
:
PLANAR_YCBCR
)
{
PlanarYCbCrImage
*
ycbcr
=
static_cast
<
PlanarYCbCrImage
*
>
(
aImage
)
;
const
PlanarYCbCrData
*
data
=
ycbcr
-
>
GetData
(
)
;
if
(
!
data
)
{
return
nullptr
;
}
texture
=
TextureClient
:
:
CreateForYCbCr
(
aForwarder
data
-
>
mYSize
data
-
>
mYStride
data
-
>
mCbCrSize
data
-
>
mCbCrStride
data
-
>
mStereoMode
data
-
>
mYUVColorSpace
data
-
>
mBitDepth
TextureFlags
:
:
DEFAULT
)
;
if
(
!
texture
)
{
return
nullptr
;
}
TextureClientAutoLock
autoLock
(
texture
OpenMode
:
:
OPEN_WRITE_ONLY
)
;
if
(
!
autoLock
.
Succeeded
(
)
)
{
return
nullptr
;
}
bool
status
=
UpdateYCbCrTextureClient
(
texture
*
data
)
;
MOZ_ASSERT
(
status
)
;
if
(
!
status
)
{
return
nullptr
;
}
#
ifdef
MOZ_WIDGET_ANDROID
}
else
if
(
aImage
-
>
GetFormat
(
)
=
=
ImageFormat
:
:
SURFACE_TEXTURE
)
{
gfx
:
:
IntSize
size
=
aImage
-
>
GetSize
(
)
;
SurfaceTextureImage
*
typedImage
=
aImage
-
>
AsSurfaceTextureImage
(
)
;
texture
=
AndroidSurfaceTextureData
:
:
CreateTextureClient
(
typedImage
-
>
GetHandle
(
)
size
typedImage
-
>
GetContinuous
(
)
typedImage
-
>
GetOriginPos
(
)
aForwarder
-
>
GetTextureForwarder
(
)
TextureFlags
:
:
DEFAULT
)
;
#
endif
}
else
{
RefPtr
<
gfx
:
:
SourceSurface
>
surface
=
aImage
-
>
GetAsSourceSurface
(
)
;
MOZ_ASSERT
(
surface
)
;
texture
=
TextureClient
:
:
CreateForDrawing
(
aForwarder
surface
-
>
GetFormat
(
)
aImage
-
>
GetSize
(
)
BackendSelector
:
:
Content
TextureFlags
:
:
DEFAULT
)
;
if
(
!
texture
)
{
return
nullptr
;
}
MOZ_ASSERT
(
texture
-
>
CanExposeDrawTarget
(
)
)
;
if
(
!
texture
-
>
Lock
(
OpenMode
:
:
OPEN_WRITE_ONLY
)
)
{
return
nullptr
;
}
{
DrawTarget
*
dt
=
texture
-
>
BorrowDrawTarget
(
)
;
if
(
!
dt
)
{
gfxWarning
(
)
<
<
"
ImageClientSingle
:
:
UpdateImage
failed
in
BorrowDrawTarget
"
;
return
nullptr
;
}
MOZ_ASSERT
(
surface
.
get
(
)
)
;
dt
-
>
CopySurface
(
surface
IntRect
(
IntPoint
(
)
surface
-
>
GetSize
(
)
)
IntPoint
(
)
)
;
}
texture
-
>
Unlock
(
)
;
}
return
texture
.
forget
(
)
;
}
bool
ImageClientSingle
:
:
UpdateImage
(
ImageContainer
*
aContainer
uint32_t
aContentFlags
)
{
AutoTArray
<
ImageContainer
:
:
OwningImage
4
>
images
;
uint32_t
generationCounter
;
aContainer
-
>
GetCurrentImages
(
&
images
&
generationCounter
)
;
if
(
mLastUpdateGenerationCounter
=
=
generationCounter
)
{
return
true
;
}
mLastUpdateGenerationCounter
=
generationCounter
;
for
(
int32_t
i
=
images
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
!
images
[
i
]
.
mImage
-
>
IsValid
(
)
)
{
images
.
RemoveElementAt
(
i
)
;
}
}
if
(
images
.
IsEmpty
(
)
)
{
for
(
auto
&
b
:
mBuffers
)
{
RemoveTexture
(
b
.
mTextureClient
)
;
}
mBuffers
.
Clear
(
)
;
return
true
;
}
nsTArray
<
Buffer
>
newBuffers
;
AutoTArray
<
CompositableForwarder
:
:
TimedTextureClient
4
>
textures
;
for
(
auto
&
img
:
images
)
{
Image
*
image
=
img
.
mImage
;
RefPtr
<
TextureClient
>
texture
=
image
-
>
GetTextureClient
(
GetForwarder
(
)
)
;
const
bool
hasTextureClient
=
!
!
texture
;
for
(
int32_t
i
=
mBuffers
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
mBuffers
[
i
]
.
mImageSerial
=
=
image
-
>
GetSerial
(
)
)
{
if
(
hasTextureClient
)
{
MOZ_ASSERT
(
image
-
>
GetTextureClient
(
GetForwarder
(
)
)
=
=
mBuffers
[
i
]
.
mTextureClient
)
;
}
else
{
texture
=
mBuffers
[
i
]
.
mTextureClient
;
}
mBuffers
.
RemoveElementAt
(
i
)
;
}
}
if
(
!
texture
)
{
texture
=
CreateTextureClientForImage
(
image
GetForwarder
(
)
)
;
}
if
(
!
texture
)
{
return
false
;
}
if
(
!
texture
-
>
GetAllocator
(
)
-
>
IPCOpen
(
)
)
{
continue
;
}
if
(
!
AddTextureClient
(
texture
)
)
{
return
false
;
}
CompositableForwarder
:
:
TimedTextureClient
*
t
=
textures
.
AppendElement
(
)
;
t
-
>
mTextureClient
=
texture
;
t
-
>
mTimeStamp
=
img
.
mTimeStamp
;
t
-
>
mPictureRect
=
image
-
>
GetPictureRect
(
)
;
t
-
>
mFrameID
=
img
.
mFrameID
;
t
-
>
mProducerID
=
img
.
mProducerID
;
Buffer
*
newBuf
=
newBuffers
.
AppendElement
(
)
;
newBuf
-
>
mImageSerial
=
image
-
>
GetSerial
(
)
;
newBuf
-
>
mTextureClient
=
texture
;
texture
-
>
SyncWithObject
(
GetForwarder
(
)
-
>
GetSyncObject
(
)
)
;
}
GetForwarder
(
)
-
>
UseTextures
(
this
textures
)
;
for
(
auto
&
b
:
mBuffers
)
{
RemoveTexture
(
b
.
mTextureClient
)
;
}
mBuffers
.
SwapElements
(
newBuffers
)
;
return
true
;
}
RefPtr
<
TextureClient
>
ImageClientSingle
:
:
GetForwardedTexture
(
)
{
if
(
mBuffers
.
Length
(
)
=
=
0
)
{
return
nullptr
;
}
return
mBuffers
[
0
]
.
mTextureClient
;
}
bool
ImageClientSingle
:
:
AddTextureClient
(
TextureClient
*
aTexture
)
{
MOZ_ASSERT
(
(
mTextureFlags
&
aTexture
-
>
GetFlags
(
)
)
=
=
mTextureFlags
)
;
return
CompositableClient
:
:
AddTextureClient
(
aTexture
)
;
}
void
ImageClientSingle
:
:
OnDetach
(
)
{
mBuffers
.
Clear
(
)
;
}
ImageClient
:
:
ImageClient
(
CompositableForwarder
*
aFwd
TextureFlags
aFlags
CompositableType
aType
)
:
CompositableClient
(
aFwd
aFlags
)
mLayer
(
nullptr
)
mType
(
aType
)
mLastUpdateGenerationCounter
(
0
)
{
}
ImageClientBridge
:
:
ImageClientBridge
(
CompositableForwarder
*
aFwd
TextureFlags
aFlags
)
:
ImageClient
(
aFwd
aFlags
CompositableType
:
:
IMAGE_BRIDGE
)
{
}
bool
ImageClientBridge
:
:
UpdateImage
(
ImageContainer
*
aContainer
uint32_t
aContentFlags
)
{
if
(
!
GetForwarder
(
)
|
|
!
mLayer
)
{
return
false
;
}
if
(
mAsyncContainerHandle
=
=
aContainer
-
>
GetAsyncContainerHandle
(
)
)
{
return
true
;
}
mAsyncContainerHandle
=
aContainer
-
>
GetAsyncContainerHandle
(
)
;
if
(
!
mAsyncContainerHandle
)
{
return
true
;
}
static_cast
<
ShadowLayerForwarder
*
>
(
GetForwarder
(
)
)
-
>
AttachAsyncCompositable
(
mAsyncContainerHandle
mLayer
)
;
return
true
;
}
}
}
