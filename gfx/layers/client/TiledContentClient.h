#
ifndef
MOZILLA_GFX_TILEDCONTENTCLIENT_H
#
define
MOZILLA_GFX_TILEDCONTENTCLIENT_H
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
algorithm
>
#
include
<
limits
>
#
include
"
Layers
.
h
"
#
include
"
TiledLayerBuffer
.
h
"
#
include
"
Units
.
h
"
#
include
"
gfxTypes
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ipc
/
Shmem
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemory
.
h
"
#
include
"
mozilla
/
layers
/
AsyncCompositionManager
.
h
"
#
include
"
mozilla
/
layers
/
CompositableClient
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
layers
/
TextureClientPool
.
h
"
#
include
"
ClientLayerManager
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsExpirationTracker
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
gfxReusableSurfaceWrapper
.
h
"
#
include
"
pratom
.
h
"
namespace
mozilla
{
namespace
layers
{
class
ClientTiledPaintedLayer
;
class
ClientLayerManager
;
class
gfxSharedReadLock
{
protected
:
virtual
~
gfxSharedReadLock
(
)
{
}
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
gfxSharedReadLock
)
virtual
int32_t
ReadLock
(
)
=
0
;
virtual
int32_t
ReadUnlock
(
)
=
0
;
virtual
int32_t
GetReadCount
(
)
=
0
;
virtual
bool
IsValid
(
)
const
=
0
;
enum
gfxSharedReadLockType
{
TYPE_MEMORY
TYPE_SHMEM
}
;
virtual
gfxSharedReadLockType
GetType
(
)
=
0
;
protected
:
NS_DECL_OWNINGTHREAD
}
;
class
gfxMemorySharedReadLock
:
public
gfxSharedReadLock
{
public
:
gfxMemorySharedReadLock
(
)
;
protected
:
~
gfxMemorySharedReadLock
(
)
;
public
:
virtual
int32_t
ReadLock
(
)
override
;
virtual
int32_t
ReadUnlock
(
)
override
;
virtual
int32_t
GetReadCount
(
)
override
;
virtual
gfxSharedReadLockType
GetType
(
)
override
{
return
TYPE_MEMORY
;
}
virtual
bool
IsValid
(
)
const
override
{
return
true
;
}
;
private
:
int32_t
mReadCount
;
}
;
class
gfxShmSharedReadLock
:
public
gfxSharedReadLock
{
private
:
struct
ShmReadLockInfo
{
int32_t
readCount
;
}
;
public
:
explicit
gfxShmSharedReadLock
(
ISurfaceAllocator
*
aAllocator
)
;
protected
:
~
gfxShmSharedReadLock
(
)
;
public
:
virtual
int32_t
ReadLock
(
)
override
;
virtual
int32_t
ReadUnlock
(
)
override
;
virtual
int32_t
GetReadCount
(
)
override
;
virtual
bool
IsValid
(
)
const
override
{
return
mAllocSuccess
;
}
;
virtual
gfxSharedReadLockType
GetType
(
)
override
{
return
TYPE_SHMEM
;
}
mozilla
:
:
layers
:
:
ShmemSection
&
GetShmemSection
(
)
{
return
mShmemSection
;
}
static
already_AddRefed
<
gfxShmSharedReadLock
>
Open
(
mozilla
:
:
layers
:
:
ISurfaceAllocator
*
aAllocator
const
mozilla
:
:
layers
:
:
ShmemSection
&
aShmemSection
)
{
MOZ_RELEASE_ASSERT
(
aShmemSection
.
shmem
(
)
.
IsReadable
(
)
)
;
RefPtr
<
gfxShmSharedReadLock
>
readLock
=
new
gfxShmSharedReadLock
(
aAllocator
aShmemSection
)
;
return
readLock
.
forget
(
)
;
}
private
:
gfxShmSharedReadLock
(
ISurfaceAllocator
*
aAllocator
const
mozilla
:
:
layers
:
:
ShmemSection
&
aShmemSection
)
:
mAllocator
(
aAllocator
)
mShmemSection
(
aShmemSection
)
mAllocSuccess
(
true
)
{
MOZ_COUNT_CTOR
(
gfxShmSharedReadLock
)
;
}
ShmReadLockInfo
*
GetShmReadLockInfoPtr
(
)
{
return
reinterpret_cast
<
ShmReadLockInfo
*
>
(
mShmemSection
.
shmem
(
)
.
get
<
char
>
(
)
+
mShmemSection
.
offset
(
)
)
;
}
RefPtr
<
ISurfaceAllocator
>
mAllocator
;
mozilla
:
:
layers
:
:
ShmemSection
mShmemSection
;
bool
mAllocSuccess
;
}
;
struct
TileClient
{
TileClient
(
)
;
~
TileClient
(
)
;
TileClient
(
const
TileClient
&
o
)
;
TileClient
&
operator
=
(
const
TileClient
&
o
)
;
bool
operator
=
=
(
const
TileClient
&
o
)
const
{
return
mFrontBuffer
=
=
o
.
mFrontBuffer
;
}
bool
operator
!
=
(
const
TileClient
&
o
)
const
{
return
mFrontBuffer
!
=
o
.
mFrontBuffer
;
}
void
SetLayerManager
(
ClientLayerManager
*
aManager
)
{
mManager
=
aManager
;
}
void
SetTextureAllocator
(
TextureClientAllocator
*
aAllocator
)
{
mAllocator
=
aAllocator
;
}
void
SetCompositableClient
(
CompositableClient
*
aCompositableClient
)
{
mCompositableClient
=
aCompositableClient
;
}
bool
IsPlaceholderTile
(
)
const
{
return
mBackBuffer
=
=
nullptr
&
&
mFrontBuffer
=
=
nullptr
;
}
void
ReadUnlock
(
)
{
MOZ_ASSERT
(
mFrontLock
"
ReadLock
with
no
gfxSharedReadLock
"
)
;
if
(
mFrontLock
)
{
mFrontLock
-
>
ReadUnlock
(
)
;
}
}
void
ReadLock
(
)
{
MOZ_ASSERT
(
mFrontLock
"
ReadLock
with
no
gfxSharedReadLock
"
)
;
if
(
mFrontLock
)
{
mFrontLock
-
>
ReadLock
(
)
;
}
}
void
DiscardBuffers
(
)
{
DiscardFrontBuffer
(
)
;
DiscardBackBuffer
(
)
;
}
nsExpirationState
*
GetExpirationState
(
)
{
return
&
mExpirationState
;
}
TileDescriptor
GetTileDescriptor
(
)
;
void
Dump
(
std
:
:
stringstream
&
aStream
)
;
void
Flip
(
)
;
void
DumpTexture
(
std
:
:
stringstream
&
aStream
TextureDumpMode
aCompress
)
{
CompositableClient
:
:
DumpTextureClient
(
aStream
mFrontBuffer
aCompress
)
;
}
TextureClient
*
GetBackBuffer
(
const
nsIntRegion
&
aDirtyRegion
gfxContentType
aContent
SurfaceMode
aMode
nsIntRegion
&
aAddPaintedRegion
RefPtr
<
TextureClient
>
*
aTextureClientOnWhite
)
;
void
DiscardFrontBuffer
(
)
;
void
DiscardBackBuffer
(
)
;
class
PrivateProtector
{
public
:
void
Set
(
TileClient
*
container
RefPtr
<
TextureClient
>
)
;
void
Set
(
TileClient
*
container
TextureClient
*
)
;
operator
TextureClient
*
(
)
const
{
return
mBuffer
;
}
RefPtr
<
TextureClient
>
operator
-
>
(
)
{
return
mBuffer
;
}
private
:
PrivateProtector
&
operator
=
(
const
PrivateProtector
&
)
;
RefPtr
<
TextureClient
>
mBuffer
;
}
mBackBuffer
;
RefPtr
<
TextureClient
>
mBackBufferOnWhite
;
RefPtr
<
TextureClient
>
mFrontBuffer
;
RefPtr
<
TextureClient
>
mFrontBufferOnWhite
;
RefPtr
<
gfxSharedReadLock
>
mBackLock
;
RefPtr
<
gfxSharedReadLock
>
mFrontLock
;
RefPtr
<
ClientLayerManager
>
mManager
;
RefPtr
<
TextureClientAllocator
>
mAllocator
;
gfx
:
:
IntRect
mUpdateRect
;
CompositableClient
*
mCompositableClient
;
#
ifdef
GFX_TILEDLAYER_DEBUG_OVERLAY
TimeStamp
mLastUpdate
;
#
endif
nsIntRegion
mInvalidFront
;
nsIntRegion
mInvalidBack
;
nsExpirationState
mExpirationState
;
private
:
void
ValidateBackBufferFromFront
(
const
nsIntRegion
&
aDirtyRegion
nsIntRegion
&
aAddPaintedRegion
)
;
}
;
struct
BasicTiledLayerPaintData
{
ParentLayerPoint
mScrollOffset
;
ParentLayerPoint
mLastScrollOffset
;
LayerToParentLayerMatrix4x4
mTransformToCompBounds
;
Maybe
<
LayerIntRect
>
mCriticalDisplayPort
;
CSSToParentLayerScale2D
mResolution
;
LayerRect
mCompositionBounds
;
uint16_t
mLowPrecisionPaintCount
;
bool
mFirstPaint
:
1
;
bool
mPaintFinished
:
1
;
void
ResetPaintData
(
)
;
}
;
class
SharedFrameMetricsHelper
{
public
:
SharedFrameMetricsHelper
(
)
;
~
SharedFrameMetricsHelper
(
)
;
bool
UpdateFromCompositorFrameMetrics
(
const
LayerMetricsWrapper
&
aLayer
bool
aHasPendingNewThebesContent
bool
aLowPrecision
AsyncTransform
&
aViewTransform
)
;
bool
AboutToCheckerboard
(
const
FrameMetrics
&
aContentMetrics
const
FrameMetrics
&
aCompositorMetrics
)
;
private
:
bool
mLastProgressiveUpdateWasLowPrecision
;
bool
mProgressiveUpdateWasInDanger
;
}
;
class
ClientTiledLayerBuffer
{
public
:
ClientTiledLayerBuffer
(
ClientTiledPaintedLayer
*
aPaintedLayer
CompositableClient
*
aCompositableClient
)
:
mPaintedLayer
(
aPaintedLayer
)
mCompositableClient
(
aCompositableClient
)
mLastPaintContentType
(
gfxContentType
:
:
COLOR
)
mLastPaintSurfaceMode
(
SurfaceMode
:
:
SURFACE_OPAQUE
)
{
}
virtual
void
PaintThebes
(
const
nsIntRegion
&
aNewValidRegion
const
nsIntRegion
&
aPaintRegion
const
nsIntRegion
&
aDirtyRegion
LayerManager
:
:
DrawPaintedLayerCallback
aCallback
void
*
aCallbackData
)
=
0
;
virtual
bool
SupportsProgressiveUpdate
(
)
=
0
;
virtual
bool
ProgressiveUpdate
(
nsIntRegion
&
aValidRegion
nsIntRegion
&
aInvalidRegion
const
nsIntRegion
&
aOldValidRegion
BasicTiledLayerPaintData
*
aPaintData
LayerManager
:
:
DrawPaintedLayerCallback
aCallback
void
*
aCallbackData
)
=
0
;
virtual
void
ResetPaintedAndValidState
(
)
=
0
;
virtual
const
nsIntRegion
&
GetValidRegion
(
)
=
0
;
virtual
bool
IsLowPrecision
(
)
const
=
0
;
virtual
void
Dump
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
bool
aDumpHtml
TextureDumpMode
aCompress
)
{
}
const
CSSToParentLayerScale2D
&
GetFrameResolution
(
)
{
return
mFrameResolution
;
}
void
SetFrameResolution
(
const
CSSToParentLayerScale2D
&
aResolution
)
{
mFrameResolution
=
aResolution
;
}
bool
HasFormatChanged
(
)
const
;
protected
:
void
UnlockTile
(
TileClient
&
aTile
)
;
gfxContentType
GetContentType
(
SurfaceMode
*
aMode
=
nullptr
)
const
;
ClientTiledPaintedLayer
*
mPaintedLayer
;
CompositableClient
*
mCompositableClient
;
gfxContentType
mLastPaintContentType
;
SurfaceMode
mLastPaintSurfaceMode
;
CSSToParentLayerScale2D
mFrameResolution
;
}
;
class
ClientMultiTiledLayerBuffer
:
public
TiledLayerBuffer
<
ClientMultiTiledLayerBuffer
TileClient
>
public
ClientTiledLayerBuffer
{
friend
class
TiledLayerBuffer
<
ClientMultiTiledLayerBuffer
TileClient
>
;
public
:
ClientMultiTiledLayerBuffer
(
ClientTiledPaintedLayer
*
aPaintedLayer
CompositableClient
*
aCompositableClient
ClientLayerManager
*
aManager
SharedFrameMetricsHelper
*
aHelper
)
;
ClientMultiTiledLayerBuffer
(
)
:
ClientTiledLayerBuffer
(
nullptr
nullptr
)
mManager
(
nullptr
)
mCallback
(
nullptr
)
mCallbackData
(
nullptr
)
mSharedFrameMetricsHelper
(
nullptr
)
mTilingOrigin
(
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
{
}
void
PaintThebes
(
const
nsIntRegion
&
aNewValidRegion
const
nsIntRegion
&
aPaintRegion
const
nsIntRegion
&
aDirtyRegion
LayerManager
:
:
DrawPaintedLayerCallback
aCallback
void
*
aCallbackData
)
override
;
virtual
bool
SupportsProgressiveUpdate
(
)
override
{
return
true
;
}
bool
ProgressiveUpdate
(
nsIntRegion
&
aValidRegion
nsIntRegion
&
aInvalidRegion
const
nsIntRegion
&
aOldValidRegion
BasicTiledLayerPaintData
*
aPaintData
LayerManager
:
:
DrawPaintedLayerCallback
aCallback
void
*
aCallbackData
)
override
;
void
ResetPaintedAndValidState
(
)
override
{
mPaintedRegion
.
SetEmpty
(
)
;
mValidRegion
.
SetEmpty
(
)
;
mTiles
.
mSize
.
width
=
0
;
mTiles
.
mSize
.
height
=
0
;
DiscardBuffers
(
)
;
mRetainedTiles
.
Clear
(
)
;
}
const
nsIntRegion
&
GetValidRegion
(
)
override
{
return
TiledLayerBuffer
:
:
GetValidRegion
(
)
;
}
bool
IsLowPrecision
(
)
const
override
{
return
TiledLayerBuffer
:
:
IsLowPrecision
(
)
;
}
void
Dump
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
bool
aDumpHtml
TextureDumpMode
aCompress
)
override
{
TiledLayerBuffer
:
:
Dump
(
aStream
aPrefix
aDumpHtml
aCompress
)
;
}
void
ReadLock
(
)
;
void
Release
(
)
;
void
DiscardBuffers
(
)
;
SurfaceDescriptorTiles
GetSurfaceDescriptorTiles
(
)
;
void
SetResolution
(
float
aResolution
)
{
if
(
mResolution
=
=
aResolution
)
{
return
;
}
Update
(
nsIntRegion
(
)
nsIntRegion
(
)
nsIntRegion
(
)
)
;
mResolution
=
aResolution
;
}
protected
:
bool
ValidateTile
(
TileClient
&
aTile
const
nsIntPoint
&
aTileRect
const
nsIntRegion
&
dirtyRect
)
;
void
Update
(
const
nsIntRegion
&
aNewValidRegion
const
nsIntRegion
&
aPaintRegion
const
nsIntRegion
&
aDirtyRegion
)
;
TileClient
GetPlaceholderTile
(
)
const
{
return
TileClient
(
)
;
}
private
:
ClientLayerManager
*
mManager
;
LayerManager
:
:
DrawPaintedLayerCallback
mCallback
;
void
*
mCallbackData
;
nsIntRegion
mNewValidRegion
;
RefPtr
<
gfx
:
:
DrawTarget
>
mSinglePaintDrawTarget
;
nsIntPoint
mSinglePaintBufferOffset
;
SharedFrameMetricsHelper
*
mSharedFrameMetricsHelper
;
std
:
:
vector
<
gfx
:
:
Tile
>
mMoz2DTiles
;
gfx
:
:
IntPoint
mTilingOrigin
;
bool
ComputeProgressiveUpdateRegion
(
const
nsIntRegion
&
aInvalidRegion
const
nsIntRegion
&
aOldValidRegion
nsIntRegion
&
aRegionToPaint
BasicTiledLayerPaintData
*
aPaintData
bool
aIsRepeated
)
;
}
;
class
TiledContentClient
:
public
CompositableClient
{
public
:
TiledContentClient
(
ClientLayerManager
*
aManager
const
char
*
aName
=
"
"
)
:
CompositableClient
(
aManager
-
>
AsShadowForwarder
(
)
)
mName
(
aName
)
{
}
protected
:
~
TiledContentClient
(
)
{
}
public
:
virtual
void
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
;
virtual
void
Dump
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
=
"
"
bool
aDumpHtml
=
false
TextureDumpMode
aCompress
=
TextureDumpMode
:
:
Compress
)
override
;
virtual
TextureInfo
GetTextureInfo
(
)
const
override
{
return
TextureInfo
(
CompositableType
:
:
CONTENT_TILED
)
;
}
virtual
ClientTiledLayerBuffer
*
GetTiledBuffer
(
)
=
0
;
virtual
ClientTiledLayerBuffer
*
GetLowPrecisionTiledBuffer
(
)
=
0
;
enum
TiledBufferType
{
TILED_BUFFER
LOW_PRECISION_TILED_BUFFER
}
;
virtual
void
UpdatedBuffer
(
TiledBufferType
aType
)
=
0
;
private
:
const
char
*
mName
;
}
;
class
MultiTiledContentClient
:
public
TiledContentClient
{
public
:
MultiTiledContentClient
(
ClientTiledPaintedLayer
*
aPaintedLayer
ClientLayerManager
*
aManager
)
;
protected
:
~
MultiTiledContentClient
(
)
{
MOZ_COUNT_DTOR
(
MultiTiledContentClient
)
;
mTiledBuffer
.
DiscardBuffers
(
)
;
mLowPrecisionTiledBuffer
.
DiscardBuffers
(
)
;
}
public
:
void
ClearCachedResources
(
)
override
;
void
UpdatedBuffer
(
TiledBufferType
aType
)
override
;
ClientTiledLayerBuffer
*
GetTiledBuffer
(
)
override
{
return
&
mTiledBuffer
;
}
ClientTiledLayerBuffer
*
GetLowPrecisionTiledBuffer
(
)
override
{
if
(
mHasLowPrecision
)
{
return
&
mLowPrecisionTiledBuffer
;
}
return
nullptr
;
}
private
:
SharedFrameMetricsHelper
mSharedFrameMetricsHelper
;
ClientMultiTiledLayerBuffer
mTiledBuffer
;
ClientMultiTiledLayerBuffer
mLowPrecisionTiledBuffer
;
bool
mHasLowPrecision
;
}
;
}
}
#
endif
