#
ifndef
MOZILLA_GFX_BUFFERCLIENT_H
#
define
MOZILLA_GFX_BUFFERCLIENT_H
#
include
<
stdint
.
h
>
#
include
<
map
>
#
include
<
vector
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderTypes
.
h
"
#
include
"
nsISupportsImpl
.
h
"
namespace
mozilla
{
namespace
layers
{
class
CompositableClient
;
class
ImageBridgeChild
;
class
ImageContainer
;
class
CompositableForwarder
;
class
CompositableChild
;
class
TextureClientRecycleAllocator
;
class
ContentClientRemoteBuffer
;
class
CompositableClient
{
protected
:
virtual
~
CompositableClient
(
)
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
CompositableClient
)
explicit
CompositableClient
(
CompositableForwarder
*
aForwarder
TextureFlags
aFlags
=
TextureFlags
:
:
NO_FLAGS
)
;
virtual
void
Dump
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
=
"
"
bool
aDumpHtml
=
false
TextureDumpMode
aCompress
=
TextureDumpMode
:
:
Compress
)
{
}
;
virtual
TextureInfo
GetTextureInfo
(
)
const
=
0
;
LayersBackend
GetCompositorBackendType
(
)
const
;
already_AddRefed
<
TextureClient
>
CreateBufferTextureClient
(
gfx
:
:
SurfaceFormat
aFormat
gfx
:
:
IntSize
aSize
gfx
:
:
BackendType
aMoz2dBackend
=
gfx
:
:
BackendType
:
:
NONE
TextureFlags
aFlags
=
TextureFlags
:
:
DEFAULT
)
;
already_AddRefed
<
TextureClient
>
CreateTextureClientForDrawing
(
gfx
:
:
SurfaceFormat
aFormat
gfx
:
:
IntSize
aSize
BackendSelector
aSelector
TextureFlags
aTextureFlags
TextureAllocationFlags
aAllocFlags
=
ALLOC_DEFAULT
)
;
virtual
bool
Connect
(
ImageContainer
*
aImageContainer
=
nullptr
)
;
void
Destroy
(
)
;
bool
IsConnected
(
)
const
;
CompositableForwarder
*
GetForwarder
(
)
const
{
return
mForwarder
;
}
CompositableHandle
GetAsyncHandle
(
)
const
;
CompositableHandle
GetIPCHandle
(
)
const
{
return
mHandle
;
}
virtual
bool
AddTextureClient
(
TextureClient
*
aClient
)
;
virtual
void
OnDetach
(
)
{
}
virtual
void
ClearCachedResources
(
)
;
virtual
void
HandleMemoryPressure
(
)
;
virtual
void
RemoveTexture
(
TextureClient
*
aTexture
)
;
void
InitIPDL
(
const
CompositableHandle
&
aHandle
)
;
TextureFlags
GetTextureFlags
(
)
const
{
return
mTextureFlags
;
}
TextureClientRecycleAllocator
*
GetTextureClientRecycler
(
)
;
bool
HasTextureClientRecycler
(
)
{
auto
lock
=
mTextureClientRecycler
.
Lock
(
)
;
return
!
!
(
*
lock
)
;
}
static
void
DumpTextureClient
(
std
:
:
stringstream
&
aStream
TextureClient
*
aTexture
TextureDumpMode
aCompress
)
;
protected
:
RefPtr
<
CompositableForwarder
>
mForwarder
;
Atomic
<
TextureFlags
>
mTextureFlags
;
DataMutex
<
RefPtr
<
TextureClientRecycleAllocator
>
>
mTextureClientRecycler
;
CompositableHandle
mHandle
;
bool
mIsAsync
;
friend
class
CompositableChild
;
}
;
struct
AutoRemoveTexture
{
explicit
AutoRemoveTexture
(
CompositableClient
*
aCompositable
TextureClient
*
aTexture
=
nullptr
)
:
mTexture
(
aTexture
)
mCompositable
(
aCompositable
)
{
}
~
AutoRemoveTexture
(
)
;
RefPtr
<
TextureClient
>
mTexture
;
private
:
CompositableClient
*
mCompositable
;
}
;
}
}
#
endif
