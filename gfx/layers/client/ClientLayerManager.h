#
ifndef
GFX_CLIENTLAYERMANAGER_H
#
define
GFX_CLIENTLAYERMANAGER_H
#
include
<
stdint
.
h
>
#
include
"
Layers
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
WidgetUtils
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
FocusTarget
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
PaintThread
.
h
"
#
include
"
mozilla
/
layers
/
ShadowLayers
.
h
"
#
include
"
mozilla
/
layers
/
APZTestData
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nscore
.
h
"
#
include
"
mozilla
/
layers
/
TransactionIdAllocator
.
h
"
#
include
"
nsIWidget
.
h
"
class
nsDisplayListBuilder
;
namespace
mozilla
{
namespace
dom
{
class
TabGroup
;
}
namespace
layers
{
using
dom
:
:
TabGroup
;
class
ClientPaintedLayer
;
class
CompositorBridgeChild
;
class
ImageLayer
;
class
FrameUniformityData
;
class
ClientLayerManager
final
:
public
LayerManager
{
typedef
nsTArray
<
RefPtr
<
Layer
>
>
LayerRefArray
;
public
:
explicit
ClientLayerManager
(
nsIWidget
*
aWidget
)
;
virtual
void
Destroy
(
)
override
;
protected
:
virtual
~
ClientLayerManager
(
)
;
public
:
virtual
ShadowLayerForwarder
*
AsShadowForwarder
(
)
override
{
return
mForwarder
;
}
virtual
KnowsCompositor
*
AsKnowsCompositor
(
)
override
{
return
mForwarder
;
}
virtual
ClientLayerManager
*
AsClientLayerManager
(
)
override
{
return
this
;
}
TabGroup
*
GetTabGroup
(
)
;
virtual
int32_t
GetMaxTextureSize
(
)
const
override
;
virtual
void
SetDefaultTargetConfiguration
(
BufferMode
aDoubleBuffering
ScreenRotation
aRotation
)
;
virtual
bool
BeginTransactionWithTarget
(
gfxContext
*
aTarget
)
override
;
virtual
bool
BeginTransaction
(
)
override
;
virtual
bool
EndEmptyTransaction
(
EndTransactionFlags
aFlags
=
END_DEFAULT
)
override
;
virtual
void
EndTransaction
(
DrawPaintedLayerCallback
aCallback
void
*
aCallbackData
EndTransactionFlags
aFlags
=
END_DEFAULT
)
override
;
virtual
LayersBackend
GetBackendType
(
)
override
{
return
LayersBackend
:
:
LAYERS_CLIENT
;
}
virtual
LayersBackend
GetCompositorBackendType
(
)
override
{
return
AsShadowForwarder
(
)
-
>
GetCompositorBackendType
(
)
;
}
virtual
void
GetBackendName
(
nsAString
&
name
)
override
;
virtual
const
char
*
Name
(
)
const
override
{
return
"
Client
"
;
}
virtual
void
SetRoot
(
Layer
*
aLayer
)
override
;
virtual
void
Mutated
(
Layer
*
aLayer
)
override
;
virtual
void
MutatedSimple
(
Layer
*
aLayer
)
override
;
virtual
already_AddRefed
<
PaintedLayer
>
CreatePaintedLayer
(
)
override
;
virtual
already_AddRefed
<
PaintedLayer
>
CreatePaintedLayerWithHint
(
PaintedLayerCreationHint
aHint
)
override
;
virtual
already_AddRefed
<
ContainerLayer
>
CreateContainerLayer
(
)
override
;
virtual
already_AddRefed
<
ImageLayer
>
CreateImageLayer
(
)
override
;
virtual
already_AddRefed
<
CanvasLayer
>
CreateCanvasLayer
(
)
override
;
virtual
already_AddRefed
<
ReadbackLayer
>
CreateReadbackLayer
(
)
override
;
virtual
already_AddRefed
<
ColorLayer
>
CreateColorLayer
(
)
override
;
virtual
already_AddRefed
<
RefLayer
>
CreateRefLayer
(
)
override
;
virtual
void
UpdateTextureFactoryIdentifier
(
const
TextureFactoryIdentifier
&
aNewIdentifier
)
override
;
virtual
TextureFactoryIdentifier
GetTextureFactoryIdentifier
(
)
override
{
return
AsShadowForwarder
(
)
-
>
GetTextureFactoryIdentifier
(
)
;
}
virtual
void
FlushRendering
(
)
override
;
virtual
void
WaitOnTransactionProcessed
(
)
override
;
virtual
void
SendInvalidRegion
(
const
nsIntRegion
&
aRegion
)
override
;
virtual
uint32_t
StartFrameTimeRecording
(
int32_t
aBufferSize
)
override
;
virtual
void
StopFrameTimeRecording
(
uint32_t
aStartIndex
nsTArray
<
float
>
&
aFrameIntervals
)
override
;
virtual
bool
NeedsWidgetInvalidation
(
)
override
{
return
false
;
}
ShadowableLayer
*
Hold
(
Layer
*
aLayer
)
;
bool
HasShadowManager
(
)
const
{
return
mForwarder
-
>
HasShadowManager
(
)
;
}
virtual
bool
IsCompositingCheap
(
)
override
;
virtual
bool
HasShadowManagerInternal
(
)
const
override
{
return
HasShadowManager
(
)
;
}
virtual
void
SetIsFirstPaint
(
)
override
;
virtual
void
SetFocusTarget
(
const
FocusTarget
&
aFocusTarget
)
override
;
void
StorePluginWidgetConfigurations
(
const
nsTArray
<
nsIWidget
:
:
Configuration
>
&
aConfigurations
)
override
;
virtual
void
ClearCachedResources
(
Layer
*
aSubtree
=
nullptr
)
override
;
void
HandleMemoryPressure
(
)
;
void
SetRepeatTransaction
(
)
{
mRepeatTransaction
=
true
;
}
bool
GetRepeatTransaction
(
)
{
return
mRepeatTransaction
;
}
bool
IsRepeatTransaction
(
)
{
return
mIsRepeatTransaction
;
}
void
SetTransactionIncomplete
(
)
{
mTransactionIncomplete
=
true
;
}
void
SetQueuedAsyncPaints
(
)
{
mQueuedAsyncPaints
=
true
;
}
bool
HasShadowTarget
(
)
{
return
!
!
mShadowTarget
;
}
void
SetShadowTarget
(
gfxContext
*
aTarget
)
{
mShadowTarget
=
aTarget
;
}
bool
CompositorMightResample
(
)
{
return
mCompositorMightResample
;
}
DrawPaintedLayerCallback
GetPaintedLayerCallback
(
)
const
{
return
mPaintedLayerCallback
;
}
void
*
GetPaintedLayerCallbackData
(
)
const
{
return
mPaintedLayerCallbackData
;
}
CompositorBridgeChild
*
GetRemoteRenderer
(
)
;
virtual
CompositorBridgeChild
*
GetCompositorBridgeChild
(
)
override
;
bool
InConstruction
(
)
{
return
mPhase
=
=
PHASE_CONSTRUCTION
;
}
#
ifdef
DEBUG
bool
InDrawing
(
)
{
return
mPhase
=
=
PHASE_DRAWING
;
}
bool
InForward
(
)
{
return
mPhase
=
=
PHASE_FORWARD
;
}
#
endif
bool
InTransaction
(
)
{
return
mPhase
!
=
PHASE_NONE
;
}
virtual
void
SetNeedsComposite
(
bool
aNeedsComposite
)
override
{
mNeedsComposite
=
aNeedsComposite
;
}
virtual
bool
NeedsComposite
(
)
const
override
{
return
mNeedsComposite
;
}
virtual
void
ScheduleComposite
(
)
override
;
virtual
void
GetFrameUniformity
(
FrameUniformityData
*
aFrameUniformityData
)
override
;
virtual
void
DidComposite
(
TransactionId
aTransactionId
const
mozilla
:
:
TimeStamp
&
aCompositeStart
const
mozilla
:
:
TimeStamp
&
aCompositeEnd
)
override
;
virtual
bool
AreComponentAlphaLayersEnabled
(
)
override
;
void
LogTestDataForCurrentPaint
(
FrameMetrics
:
:
ViewID
aScrollId
const
std
:
:
string
&
aKey
const
std
:
:
string
&
aValue
)
{
MOZ_ASSERT
(
gfxPrefs
:
:
APZTestLoggingEnabled
(
)
"
don
'
t
call
me
"
)
;
mApzTestData
.
LogTestDataForPaint
(
mPaintSequenceNumber
aScrollId
aKey
aValue
)
;
}
void
StartNewRepaintRequest
(
SequenceNumber
aSequenceNumber
)
;
void
LogTestDataForRepaintRequest
(
SequenceNumber
aSequenceNumber
FrameMetrics
:
:
ViewID
aScrollId
const
std
:
:
string
&
aKey
const
std
:
:
string
&
aValue
)
{
MOZ_ASSERT
(
gfxPrefs
:
:
APZTestLoggingEnabled
(
)
"
don
'
t
call
me
"
)
;
mApzTestData
.
LogTestDataForRepaintRequest
(
aSequenceNumber
aScrollId
aKey
aValue
)
;
}
const
APZTestData
&
GetAPZTestData
(
)
const
{
return
mApzTestData
;
}
void
GetCompositorSideAPZTestData
(
APZTestData
*
aData
)
const
;
virtual
void
SetTransactionIdAllocator
(
TransactionIdAllocator
*
aAllocator
)
override
;
virtual
TransactionId
GetLastTransactionId
(
)
override
{
return
mLatestTransactionId
;
}
float
RequestProperty
(
const
nsAString
&
aProperty
)
override
;
bool
AsyncPanZoomEnabled
(
)
const
override
;
virtual
void
SetLayersObserverEpoch
(
LayersObserverEpoch
aEpoch
)
override
;
virtual
void
AddDidCompositeObserver
(
DidCompositeObserver
*
aObserver
)
override
;
virtual
void
RemoveDidCompositeObserver
(
DidCompositeObserver
*
aObserver
)
override
;
virtual
already_AddRefed
<
PersistentBufferProvider
>
CreatePersistentBufferProvider
(
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
)
override
;
static
PaintTiming
*
MaybeGetPaintTiming
(
LayerManager
*
aManager
)
{
if
(
!
aManager
)
{
return
nullptr
;
}
if
(
ClientLayerManager
*
lm
=
aManager
-
>
AsClientLayerManager
(
)
)
{
return
&
lm
-
>
AsShadowForwarder
(
)
-
>
GetPaintTiming
(
)
;
}
return
nullptr
;
}
protected
:
enum
TransactionPhase
{
PHASE_NONE
PHASE_CONSTRUCTION
PHASE_DRAWING
PHASE_FORWARD
}
;
TransactionPhase
mPhase
;
private
:
class
MemoryPressureObserver
final
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
explicit
MemoryPressureObserver
(
ClientLayerManager
*
aClientLayerManager
)
:
mClientLayerManager
(
aClientLayerManager
)
{
RegisterMemoryPressureEvent
(
)
;
}
void
Destroy
(
)
;
private
:
virtual
~
MemoryPressureObserver
(
)
{
}
void
RegisterMemoryPressureEvent
(
)
;
void
UnregisterMemoryPressureEvent
(
)
;
ClientLayerManager
*
mClientLayerManager
;
}
;
void
ForwardTransaction
(
bool
aScheduleComposite
)
;
void
MakeSnapshotIfRequired
(
)
;
void
ClearLayer
(
Layer
*
aLayer
)
;
void
HandleMemoryPressureLayer
(
Layer
*
aLayer
)
;
bool
EndTransactionInternal
(
DrawPaintedLayerCallback
aCallback
void
*
aCallbackData
EndTransactionFlags
)
;
void
FlushAsyncPaints
(
)
;
LayerRefArray
mKeepAlive
;
nsIWidget
*
mWidget
;
DrawPaintedLayerCallback
mPaintedLayerCallback
;
void
*
mPaintedLayerCallbackData
;
RefPtr
<
gfxContext
>
mShadowTarget
;
RefPtr
<
TransactionIdAllocator
>
mTransactionIdAllocator
;
TransactionId
mLatestTransactionId
;
TimeDuration
mLastPaintTime
;
ScreenRotation
mTargetRotation
;
bool
mRepeatTransaction
;
bool
mIsRepeatTransaction
;
bool
mTransactionIncomplete
;
bool
mCompositorMightResample
;
bool
mNeedsComposite
;
bool
mQueuedAsyncPaints
;
uint32_t
mPaintSequenceNumber
;
APZTestData
mApzTestData
;
RefPtr
<
ShadowLayerForwarder
>
mForwarder
;
mozilla
:
:
TimeStamp
mTransactionStart
;
nsTArray
<
DidCompositeObserver
*
>
mDidCompositeObservers
;
RefPtr
<
MemoryPressureObserver
>
mMemoryPressureObserver
;
}
;
class
ClientLayer
:
public
ShadowableLayer
{
public
:
ClientLayer
(
)
{
MOZ_COUNT_CTOR
(
ClientLayer
)
;
}
~
ClientLayer
(
)
;
virtual
void
HandleMemoryPressure
(
)
{
}
virtual
void
RenderLayer
(
)
=
0
;
virtual
void
RenderLayerWithReadback
(
ReadbackProcessor
*
aReadback
)
{
RenderLayer
(
)
;
}
virtual
ClientPaintedLayer
*
AsThebes
(
)
{
return
nullptr
;
}
static
inline
ClientLayer
*
ToClientLayer
(
Layer
*
aLayer
)
{
return
static_cast
<
ClientLayer
*
>
(
aLayer
-
>
ImplData
(
)
)
;
}
template
<
typename
LayerType
>
static
inline
void
RenderMaskLayers
(
LayerType
*
aLayer
)
{
if
(
aLayer
-
>
GetMaskLayer
(
)
)
{
ToClientLayer
(
aLayer
-
>
GetMaskLayer
(
)
)
-
>
RenderLayer
(
)
;
}
for
(
size_t
i
=
0
;
i
<
aLayer
-
>
GetAncestorMaskLayerCount
(
)
;
i
+
+
)
{
ToClientLayer
(
aLayer
-
>
GetAncestorMaskLayerAt
(
i
)
)
-
>
RenderLayer
(
)
;
}
}
}
;
template
<
typename
CreatedMethod
>
void
CreateShadowFor
(
ClientLayer
*
aLayer
ClientLayerManager
*
aMgr
CreatedMethod
aMethod
)
{
LayerHandle
shadow
=
aMgr
-
>
AsShadowForwarder
(
)
-
>
ConstructShadowFor
(
aLayer
)
;
if
(
!
shadow
)
{
return
;
}
aLayer
-
>
SetShadow
(
aMgr
-
>
AsShadowForwarder
(
)
shadow
)
;
(
aMgr
-
>
AsShadowForwarder
(
)
-
>
*
aMethod
)
(
aLayer
)
;
aMgr
-
>
Hold
(
aLayer
-
>
AsLayer
(
)
)
;
}
#
define
CREATE_SHADOW
(
_type
)
\
CreateShadowFor
(
layer
this
\
&
ShadowLayerForwarder
:
:
Created
#
#
_type
#
#
Layer
)
}
}
#
endif
