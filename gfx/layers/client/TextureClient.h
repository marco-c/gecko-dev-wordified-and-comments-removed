#
ifndef
MOZILLA_GFX_TEXTURECLIENT_H
#
define
MOZILLA_GFX_TEXTURECLIENT_H
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
GLTextureImage
.
h
"
#
include
"
ImageTypes
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
FenceUtils
.
h
"
#
include
"
mozilla
/
ipc
/
Shmem
.
h
"
#
include
"
mozilla
/
layers
/
AtomicRefCountedWithFinalize
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
gfx
/
CriticalSection
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
GfxTexturesReporter
.
h
"
#
include
"
pratom
.
h
"
#
include
"
nsThreadUtils
.
h
"
class
gfxImageSurface
;
namespace
mozilla
{
#
ifdef
DEBUG
#
define
GFX_DEBUG_TRACK_CLIENTS_IN_POOL
1
#
endif
namespace
gl
{
class
SharedSurface_Gralloc
;
}
namespace
layers
{
class
AsyncTransactionWaiter
;
class
BufferTextureData
;
class
CompositableForwarder
;
class
KnowsCompositor
;
class
GrallocTextureData
;
class
LayersIPCChannel
;
class
CompositableClient
;
struct
PlanarYCbCrData
;
class
Image
;
class
PTextureChild
;
class
TextureChild
;
class
TextureData
;
struct
RawTextureBuffer
;
class
RawYCbCrTextureBuffer
;
class
TextureClient
;
class
ITextureClientRecycleAllocator
;
#
ifdef
GFX_DEBUG_TRACK_CLIENTS_IN_POOL
class
TextureClientPool
;
#
endif
class
TextureForwarder
;
class
KeepAlive
;
enum
TextureAllocationFlags
{
ALLOC_DEFAULT
=
0
ALLOC_CLEAR_BUFFER
=
1
<
<
1
ALLOC_CLEAR_BUFFER_WHITE
=
1
<
<
2
ALLOC_CLEAR_BUFFER_BLACK
=
1
<
<
3
ALLOC_DISALLOW_BUFFERTEXTURECLIENT
=
1
<
<
4
ALLOC_FOR_OUT_OF_BAND_CONTENT
=
1
<
<
5
ALLOC_MANUAL_SYNCHRONIZATION
=
1
<
<
6
}
;
#
ifdef
XP_WIN
typedef
void
*
SyncHandle
;
#
else
typedef
uintptr_t
SyncHandle
;
#
endif
class
SyncObject
:
public
RefCounted
<
SyncObject
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
SyncObject
)
virtual
~
SyncObject
(
)
{
}
static
already_AddRefed
<
SyncObject
>
CreateSyncObject
(
SyncHandle
aHandle
)
;
enum
class
SyncType
{
D3D11
}
;
virtual
SyncType
GetSyncType
(
)
=
0
;
virtual
void
FinalizeFrame
(
)
=
0
;
protected
:
SyncObject
(
)
{
}
}
;
class
TextureReadbackSink
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
TextureReadbackSink
)
public
:
virtual
void
ProcessReadback
(
gfx
:
:
DataSourceSurface
*
aSourceSurface
)
=
0
;
protected
:
virtual
~
TextureReadbackSink
(
)
{
}
}
;
enum
class
BackendSelector
{
Content
Canvas
}
;
struct
MappedTextureData
{
uint8_t
*
data
;
gfx
:
:
IntSize
size
;
int32_t
stride
;
gfx
:
:
SurfaceFormat
format
;
}
;
struct
MappedYCbCrChannelData
{
uint8_t
*
data
;
gfx
:
:
IntSize
size
;
int32_t
stride
;
int32_t
skip
;
bool
CopyInto
(
MappedYCbCrChannelData
&
aDst
)
;
}
;
struct
MappedYCbCrTextureData
{
MappedYCbCrChannelData
y
;
MappedYCbCrChannelData
cb
;
MappedYCbCrChannelData
cr
;
uint8_t
*
metadata
;
StereoMode
stereoMode
;
bool
CopyInto
(
MappedYCbCrTextureData
&
aDst
)
{
return
y
.
CopyInto
(
aDst
.
y
)
&
&
cb
.
CopyInto
(
aDst
.
cb
)
&
&
cr
.
CopyInto
(
aDst
.
cr
)
;
}
}
;
class
ReadLockDescriptor
;
class
TextureReadLock
{
protected
:
virtual
~
TextureReadLock
(
)
{
}
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
TextureReadLock
)
virtual
int32_t
ReadLock
(
)
=
0
;
virtual
int32_t
ReadUnlock
(
)
=
0
;
virtual
int32_t
GetReadCount
(
)
=
0
;
virtual
bool
IsValid
(
)
const
=
0
;
static
already_AddRefed
<
TextureReadLock
>
Create
(
LayersIPCChannel
*
aAllocator
)
;
static
already_AddRefed
<
TextureReadLock
>
Deserialize
(
const
ReadLockDescriptor
&
aDescriptor
ISurfaceAllocator
*
aAllocator
)
;
virtual
bool
Serialize
(
ReadLockDescriptor
&
aOutput
)
=
0
;
enum
LockType
{
TYPE_MEMORY
TYPE_SHMEM
}
;
virtual
LockType
GetType
(
)
=
0
;
protected
:
NS_DECL_OWNINGTHREAD
}
;
#
ifdef
XP_WIN
class
D3D11TextureData
;
#
endif
class
TextureData
{
public
:
struct
Info
{
gfx
:
:
IntSize
size
;
gfx
:
:
SurfaceFormat
format
;
bool
hasIntermediateBuffer
;
bool
hasSynchronization
;
bool
supportsMoz2D
;
bool
canExposeMappedData
;
Info
(
)
:
format
(
gfx
:
:
SurfaceFormat
:
:
UNKNOWN
)
hasIntermediateBuffer
(
false
)
hasSynchronization
(
false
)
supportsMoz2D
(
false
)
canExposeMappedData
(
false
)
{
}
}
;
TextureData
(
)
{
MOZ_COUNT_CTOR
(
TextureData
)
;
}
virtual
~
TextureData
(
)
{
MOZ_COUNT_DTOR
(
TextureData
)
;
}
virtual
void
FillInfo
(
TextureData
:
:
Info
&
aInfo
)
const
=
0
;
virtual
bool
Lock
(
OpenMode
aMode
FenceHandle
*
aFence
)
=
0
;
virtual
void
Unlock
(
)
=
0
;
virtual
already_AddRefed
<
gfx
:
:
DrawTarget
>
BorrowDrawTarget
(
)
{
return
nullptr
;
}
virtual
bool
BorrowMappedData
(
MappedTextureData
&
)
{
return
false
;
}
virtual
bool
BorrowMappedYCbCrData
(
MappedYCbCrTextureData
&
)
{
return
false
;
}
virtual
void
Deallocate
(
LayersIPCChannel
*
aAllocator
)
=
0
;
virtual
void
Forget
(
LayersIPCChannel
*
aAllocator
)
{
}
virtual
bool
Serialize
(
SurfaceDescriptor
&
aDescriptor
)
=
0
;
virtual
TextureData
*
CreateSimilar
(
LayersIPCChannel
*
aAllocator
LayersBackend
aLayersBackend
TextureFlags
aFlags
=
TextureFlags
:
:
DEFAULT
TextureAllocationFlags
aAllocFlags
=
ALLOC_DEFAULT
)
const
{
return
nullptr
;
}
virtual
bool
UpdateFromSurface
(
gfx
:
:
SourceSurface
*
aSurface
)
{
return
false
;
}
;
virtual
bool
ReadBack
(
TextureReadbackSink
*
aReadbackSink
)
{
return
false
;
}
virtual
void
WaitForFence
(
FenceHandle
*
aFence
)
{
}
;
virtual
void
SyncWithObject
(
SyncObject
*
aFence
)
{
}
;
virtual
TextureFlags
GetTextureFlags
(
)
const
{
return
TextureFlags
:
:
NO_FLAGS
;
}
#
ifdef
XP_WIN
virtual
D3D11TextureData
*
AsD3D11TextureData
(
)
{
return
nullptr
;
}
#
endif
virtual
GrallocTextureData
*
AsGrallocTextureData
(
)
{
return
nullptr
;
}
virtual
BufferTextureData
*
AsBufferTextureData
(
)
{
return
nullptr
;
}
}
;
class
TextureClient
:
public
AtomicRefCountedWithFinalize
<
TextureClient
>
{
public
:
explicit
TextureClient
(
TextureData
*
aData
TextureFlags
aFlags
LayersIPCChannel
*
aAllocator
)
;
virtual
~
TextureClient
(
)
;
static
already_AddRefed
<
TextureClient
>
CreateWithData
(
TextureData
*
aData
TextureFlags
aFlags
LayersIPCChannel
*
aAllocator
)
;
static
already_AddRefed
<
TextureClient
>
CreateForDrawing
(
KnowsCompositor
*
aAllocator
gfx
:
:
SurfaceFormat
aFormat
gfx
:
:
IntSize
aSize
BackendSelector
aSelector
TextureFlags
aTextureFlags
TextureAllocationFlags
flags
=
ALLOC_DEFAULT
)
;
static
already_AddRefed
<
TextureClient
>
CreateFromSurface
(
KnowsCompositor
*
aAllocator
gfx
:
:
SourceSurface
*
aSurface
BackendSelector
aSelector
TextureFlags
aTextureFlags
TextureAllocationFlags
aAllocFlags
)
;
static
already_AddRefed
<
TextureClient
>
CreateForYCbCr
(
KnowsCompositor
*
aAllocator
gfx
:
:
IntSize
aYSize
gfx
:
:
IntSize
aCbCrSize
StereoMode
aStereoMode
TextureFlags
aTextureFlags
)
;
static
already_AddRefed
<
TextureClient
>
CreateForRawBufferAccess
(
KnowsCompositor
*
aAllocator
gfx
:
:
SurfaceFormat
aFormat
gfx
:
:
IntSize
aSize
gfx
:
:
BackendType
aMoz2dBackend
TextureFlags
aTextureFlags
TextureAllocationFlags
flags
=
ALLOC_DEFAULT
)
;
static
already_AddRefed
<
TextureClient
>
CreateForYCbCrWithBufferSize
(
KnowsCompositor
*
aAllocator
size_t
aSize
TextureFlags
aTextureFlags
)
;
already_AddRefed
<
TextureClient
>
CreateSimilar
(
LayersBackend
aLayersBackend
=
LayersBackend
:
:
LAYERS_NONE
TextureFlags
aFlags
=
TextureFlags
:
:
DEFAULT
TextureAllocationFlags
aAllocFlags
=
ALLOC_DEFAULT
)
const
;
bool
Lock
(
OpenMode
aMode
)
;
void
Unlock
(
)
;
bool
IsLocked
(
)
const
{
return
mIsLocked
;
}
gfx
:
:
IntSize
GetSize
(
)
const
{
return
mInfo
.
size
;
}
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
{
return
mInfo
.
format
;
}
bool
HasSynchronization
(
)
const
{
return
mInfo
.
hasSynchronization
;
}
bool
HasIntermediateBuffer
(
)
const
{
return
mInfo
.
hasIntermediateBuffer
;
}
bool
CanExposeDrawTarget
(
)
const
{
return
mInfo
.
supportsMoz2D
;
}
bool
CanExposeMappedData
(
)
const
{
return
mInfo
.
canExposeMappedData
;
}
gfx
:
:
DrawTarget
*
BorrowDrawTarget
(
)
;
bool
BorrowMappedData
(
MappedTextureData
&
)
;
bool
BorrowMappedYCbCrData
(
MappedYCbCrTextureData
&
)
;
void
UpdateFromSurface
(
gfx
:
:
SourceSurface
*
aSurface
)
;
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
GetAsSurface
(
)
;
virtual
void
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
;
bool
CopyToTextureClient
(
TextureClient
*
aTarget
const
gfx
:
:
IntRect
*
aRect
const
gfx
:
:
IntPoint
*
aPoint
)
;
static
PTextureChild
*
CreateIPDLActor
(
)
;
static
bool
DestroyIPDLActor
(
PTextureChild
*
actor
)
;
static
already_AddRefed
<
TextureClient
>
AsTextureClient
(
PTextureChild
*
actor
)
;
TextureFlags
GetFlags
(
)
const
{
return
mFlags
;
}
bool
HasFlags
(
TextureFlags
aFlags
)
const
{
return
(
mFlags
&
aFlags
)
=
=
aFlags
;
}
void
AddFlags
(
TextureFlags
aFlags
)
;
void
RemoveFlags
(
TextureFlags
aFlags
)
;
void
RecycleTexture
(
TextureFlags
aFlags
)
;
bool
IsImmutable
(
)
const
{
return
!
!
(
mFlags
&
TextureFlags
:
:
IMMUTABLE
)
;
}
void
MarkImmutable
(
)
{
AddFlags
(
TextureFlags
:
:
IMMUTABLE
)
;
}
bool
IsSharedWithCompositor
(
)
const
;
bool
IsValid
(
)
const
{
return
!
!
mData
;
}
void
SetAddedToCompositableClient
(
)
;
bool
IsAddedToCompositableClient
(
)
const
{
return
mAddedToCompositableClient
;
}
bool
InitIPDLActor
(
CompositableForwarder
*
aForwarder
)
;
bool
InitIPDLActor
(
KnowsCompositor
*
aForwarder
)
;
PTextureChild
*
GetIPDLActor
(
)
;
void
Destroy
(
bool
sync
=
false
)
;
virtual
void
SetReleaseFenceHandle
(
const
FenceHandle
&
aReleaseFenceHandle
)
{
mReleaseFenceHandle
.
Merge
(
aReleaseFenceHandle
)
;
}
virtual
FenceHandle
GetAndResetReleaseFenceHandle
(
)
{
FenceHandle
fence
;
mReleaseFenceHandle
.
TransferToAnotherFenceHandle
(
fence
)
;
return
fence
;
}
virtual
void
SetAcquireFenceHandle
(
const
FenceHandle
&
aAcquireFenceHandle
)
{
mAcquireFenceHandle
=
aAcquireFenceHandle
;
}
virtual
const
FenceHandle
&
GetAcquireFenceHandle
(
)
const
{
return
mAcquireFenceHandle
;
}
virtual
void
WaitForBufferOwnership
(
bool
aWaitReleaseFence
=
true
)
;
void
SetWaste
(
int
aWasteArea
)
{
mWasteTracker
.
Update
(
aWasteArea
BytesPerPixel
(
GetFormat
(
)
)
)
;
}
virtual
void
SetReadbackSink
(
TextureReadbackSink
*
aReadbackSink
)
{
mReadbackSink
=
aReadbackSink
;
}
void
SyncWithObject
(
SyncObject
*
aFence
)
{
mData
-
>
SyncWithObject
(
aFence
)
;
}
LayersIPCChannel
*
GetAllocator
(
)
{
return
mAllocator
;
}
ITextureClientRecycleAllocator
*
GetRecycleAllocator
(
)
{
return
mRecycleAllocator
;
}
void
SetRecycleAllocator
(
ITextureClientRecycleAllocator
*
aAllocator
)
;
TextureData
*
GetInternalData
(
)
{
return
mData
;
}
const
TextureData
*
GetInternalData
(
)
const
{
return
mData
;
}
uint64_t
GetSerial
(
)
const
{
return
mSerial
;
}
bool
NeedsFenceHandle
(
)
{
#
if
defined
(
MOZ_WIDGET_GONK
)
&
&
ANDROID_VERSION
>
=
17
if
(
!
mData
)
{
return
false
;
}
return
!
!
mData
-
>
AsGrallocTextureData
(
)
;
#
else
return
false
;
#
endif
}
void
WaitFenceHandleOnImageBridge
(
Mutex
&
aMutex
)
;
void
ClearWaitFenceHandleOnImageBridge
(
Mutex
&
aMutex
)
;
void
CancelWaitFenceHandleOnImageBridge
(
)
;
void
CancelWaitForRecycle
(
)
;
void
SetLastFwdTransactionId
(
uint64_t
aTransactionId
)
{
MOZ_ASSERT
(
mFwdTransactionId
<
=
aTransactionId
)
;
mFwdTransactionId
=
aTransactionId
;
}
uint64_t
GetLastFwdTransactionId
(
)
{
return
mFwdTransactionId
;
}
void
EnableReadLock
(
)
;
TextureReadLock
*
GetReadLock
(
)
{
return
mReadLock
;
}
bool
IsReadLocked
(
)
const
;
void
SerializeReadLock
(
ReadLockDescriptor
&
aDescriptor
)
;
private
:
static
void
TextureClientRecycleCallback
(
TextureClient
*
aClient
void
*
aClosure
)
;
friend
class
TextureClientPool
;
static
already_AddRefed
<
TextureClient
>
CreateForDrawing
(
TextureForwarder
*
aAllocator
gfx
:
:
SurfaceFormat
aFormat
gfx
:
:
IntSize
aSize
LayersBackend
aLayersBackend
int32_t
aMaxTextureSize
BackendSelector
aSelector
TextureFlags
aTextureFlags
TextureAllocationFlags
aAllocFlags
=
ALLOC_DEFAULT
)
;
static
already_AddRefed
<
TextureClient
>
CreateForRawBufferAccess
(
LayersIPCChannel
*
aAllocator
gfx
:
:
SurfaceFormat
aFormat
gfx
:
:
IntSize
aSize
gfx
:
:
BackendType
aMoz2dBackend
LayersBackend
aLayersBackend
TextureFlags
aTextureFlags
TextureAllocationFlags
flags
=
ALLOC_DEFAULT
)
;
void
Finalize
(
)
{
}
friend
class
AtomicRefCountedWithFinalize
<
TextureClient
>
;
friend
class
gl
:
:
SharedSurface_Gralloc
;
protected
:
bool
ToSurfaceDescriptor
(
SurfaceDescriptor
&
aDescriptor
)
;
void
LockActor
(
)
const
;
void
UnlockActor
(
)
const
;
TextureData
:
:
Info
mInfo
;
RefPtr
<
LayersIPCChannel
>
mAllocator
;
RefPtr
<
TextureChild
>
mActor
;
RefPtr
<
ITextureClientRecycleAllocator
>
mRecycleAllocator
;
RefPtr
<
TextureReadLock
>
mReadLock
;
TextureData
*
mData
;
RefPtr
<
gfx
:
:
DrawTarget
>
mBorrowedDrawTarget
;
TextureFlags
mFlags
;
FenceHandle
mReleaseFenceHandle
;
FenceHandle
mAcquireFenceHandle
;
RefPtr
<
AsyncTransactionWaiter
>
mFenceHandleWaiter
;
gl
:
:
GfxTextureWasteTracker
mWasteTracker
;
OpenMode
mOpenMode
;
#
ifdef
DEBUG
uint32_t
mExpectedDtRefs
;
#
endif
bool
mIsLocked
;
bool
mUpdated
;
bool
mAddedToCompositableClient
;
bool
mWorkaroundAnnoyingSharedSurfaceLifetimeIssues
;
bool
mWorkaroundAnnoyingSharedSurfaceOwnershipIssues
;
RefPtr
<
TextureReadbackSink
>
mReadbackSink
;
uint64_t
mFwdTransactionId
;
const
uint64_t
mSerial
;
static
mozilla
:
:
Atomic
<
uint64_t
>
sSerialCounter
;
friend
class
TextureChild
;
friend
class
RemoveTextureFromCompositableTracker
;
friend
void
TestTextureClientSurface
(
TextureClient
*
gfxImageSurface
*
)
;
friend
void
TestTextureClientYCbCr
(
TextureClient
*
PlanarYCbCrData
&
)
;
#
ifdef
GFX_DEBUG_TRACK_CLIENTS_IN_POOL
public
:
TextureClientPool
*
mPoolTracker
;
#
endif
}
;
class
TextureClientReleaseTask
:
public
Runnable
{
public
:
explicit
TextureClientReleaseTask
(
TextureClient
*
aClient
)
:
mTextureClient
(
aClient
)
{
}
NS_IMETHOD
Run
(
)
override
{
mTextureClient
=
nullptr
;
return
NS_OK
;
}
private
:
RefPtr
<
TextureClient
>
mTextureClient
;
}
;
class
MOZ_RAII
TextureClientAutoLock
{
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
;
public
:
TextureClientAutoLock
(
TextureClient
*
aTexture
OpenMode
aMode
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mTexture
(
aTexture
)
mSucceeded
(
false
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
mSucceeded
=
mTexture
-
>
Lock
(
aMode
)
;
#
ifdef
DEBUG
mChecked
=
false
;
#
endif
}
~
TextureClientAutoLock
(
)
{
MOZ_ASSERT
(
mChecked
)
;
if
(
mSucceeded
)
{
mTexture
-
>
Unlock
(
)
;
}
}
bool
Succeeded
(
)
{
#
ifdef
DEBUG
mChecked
=
true
;
#
endif
return
mSucceeded
;
}
private
:
TextureClient
*
mTexture
;
#
ifdef
DEBUG
bool
mChecked
;
#
endif
bool
mSucceeded
;
}
;
class
KeepAlive
{
public
:
virtual
~
KeepAlive
(
)
{
}
}
;
template
<
typename
T
>
class
TKeepAlive
:
public
KeepAlive
{
public
:
explicit
TKeepAlive
(
T
*
aData
)
:
mData
(
aData
)
{
}
protected
:
RefPtr
<
T
>
mData
;
}
;
bool
UpdateYCbCrTextureClient
(
TextureClient
*
aTexture
const
PlanarYCbCrData
&
aData
)
;
}
}
#
endif
