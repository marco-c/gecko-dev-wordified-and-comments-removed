#
ifndef
MOZILLA_GFX_TEXTURECLIENT_H
#
define
MOZILLA_GFX_TEXTURECLIENT_H
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
GLTextureImage
.
h
"
#
include
"
ImageTypes
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
FenceUtils
.
h
"
#
include
"
mozilla
/
ipc
/
Shmem
.
h
"
#
include
"
mozilla
/
layers
/
AtomicRefCountedWithFinalize
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
GfxTexturesReporter
.
h
"
class
gfxImageSurface
;
namespace
mozilla
{
#
ifdef
DEBUG
#
define
GFX_DEBUG_TRACK_CLIENTS_IN_POOL
1
#
endif
namespace
gl
{
class
SharedSurface_Gralloc
;
}
namespace
layers
{
class
AsyncTransactionWaiter
;
class
CompositableForwarder
;
class
ISurfaceAllocator
;
class
CompositableClient
;
struct
PlanarYCbCrData
;
class
Image
;
class
PTextureChild
;
class
TextureChild
;
class
TextureData
;
struct
RawTextureBuffer
;
class
RawYCbCrTextureBuffer
;
class
TextureClient
;
class
ITextureClientRecycleAllocator
;
#
ifdef
GFX_DEBUG_TRACK_CLIENTS_IN_POOL
class
TextureClientPool
;
#
endif
class
KeepAlive
;
enum
TextureAllocationFlags
{
ALLOC_DEFAULT
=
0
ALLOC_CLEAR_BUFFER
=
1
<
<
1
ALLOC_CLEAR_BUFFER_WHITE
=
1
<
<
2
ALLOC_CLEAR_BUFFER_BLACK
=
1
<
<
3
ALLOC_DISALLOW_BUFFERTEXTURECLIENT
=
1
<
<
4
ALLOC_FOR_OUT_OF_BAND_CONTENT
=
1
<
<
5
}
;
#
ifdef
XP_WIN
typedef
void
*
SyncHandle
;
#
else
typedef
uintptr_t
SyncHandle
;
#
endif
class
SyncObject
:
public
RefCounted
<
SyncObject
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
SyncObject
)
virtual
~
SyncObject
(
)
{
}
static
already_AddRefed
<
SyncObject
>
CreateSyncObject
(
SyncHandle
aHandle
)
;
enum
class
SyncType
{
D3D11
}
;
virtual
SyncType
GetSyncType
(
)
=
0
;
virtual
void
FinalizeFrame
(
)
=
0
;
protected
:
SyncObject
(
)
{
}
}
;
class
TextureReadbackSink
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
TextureReadbackSink
)
public
:
virtual
void
ProcessReadback
(
gfx
:
:
DataSourceSurface
*
aSourceSurface
)
=
0
;
protected
:
virtual
~
TextureReadbackSink
(
)
{
}
}
;
enum
class
BackendSelector
{
Content
Canvas
}
;
struct
MappedTextureData
{
uint8_t
*
data
;
gfx
:
:
IntSize
size
;
int32_t
stride
;
gfx
:
:
SurfaceFormat
format
;
}
;
struct
MappedYCbCrChannelData
{
uint8_t
*
data
;
gfx
:
:
IntSize
size
;
int32_t
stride
;
int32_t
skip
;
bool
CopyInto
(
MappedYCbCrChannelData
&
aDst
)
;
}
;
struct
MappedYCbCrTextureData
{
MappedYCbCrChannelData
y
;
MappedYCbCrChannelData
cb
;
MappedYCbCrChannelData
cr
;
uint8_t
*
metadata
;
StereoMode
stereoMode
;
bool
CopyInto
(
MappedYCbCrTextureData
&
aDst
)
{
return
y
.
CopyInto
(
aDst
.
y
)
&
&
cb
.
CopyInto
(
aDst
.
cb
)
&
&
cr
.
CopyInto
(
aDst
.
cr
)
;
}
}
;
#
ifdef
XP_WIN
class
D3D11TextureData
;
#
endif
class
TextureData
{
public
:
TextureData
(
)
{
MOZ_COUNT_CTOR
(
TextureData
)
;
}
virtual
~
TextureData
(
)
{
MOZ_COUNT_DTOR
(
TextureData
)
;
}
virtual
gfx
:
:
IntSize
GetSize
(
)
const
=
0
;
virtual
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
=
0
;
virtual
bool
Lock
(
OpenMode
aMode
FenceHandle
*
aFence
)
=
0
;
virtual
void
Unlock
(
)
=
0
;
virtual
bool
SupportsMoz2D
(
)
const
{
return
false
;
}
virtual
bool
CanExposeMappedData
(
)
const
{
return
false
;
}
virtual
bool
HasInternalBuffer
(
)
const
=
0
;
virtual
bool
HasSynchronization
(
)
const
{
return
false
;
}
virtual
already_AddRefed
<
gfx
:
:
DrawTarget
>
BorrowDrawTarget
(
)
{
return
nullptr
;
}
virtual
bool
BorrowMappedData
(
MappedTextureData
&
)
{
return
false
;
}
virtual
bool
BorrowMappedYCbCrData
(
MappedYCbCrTextureData
&
)
{
return
false
;
}
virtual
void
Deallocate
(
ISurfaceAllocator
*
aAllocator
)
=
0
;
virtual
void
Forget
(
ISurfaceAllocator
*
aAllocator
)
{
}
virtual
bool
Serialize
(
SurfaceDescriptor
&
aDescriptor
)
=
0
;
virtual
TextureData
*
CreateSimilar
(
ISurfaceAllocator
*
aAllocator
TextureFlags
aFlags
=
TextureFlags
:
:
DEFAULT
TextureAllocationFlags
aAllocFlags
=
ALLOC_DEFAULT
)
const
{
return
nullptr
;
}
virtual
bool
UpdateFromSurface
(
gfx
:
:
SourceSurface
*
aSurface
)
{
return
false
;
}
;
virtual
bool
ReadBack
(
TextureReadbackSink
*
aReadbackSink
)
{
return
false
;
}
virtual
void
WaitForFence
(
FenceHandle
*
aFence
)
{
}
;
virtual
void
SyncWithObject
(
SyncObject
*
aFence
)
{
}
;
virtual
TextureFlags
GetTextureFlags
(
)
const
{
return
TextureFlags
:
:
NO_FLAGS
;
}
#
ifdef
XP_WIN
virtual
D3D11TextureData
*
AsD3D11TextureData
(
)
{
return
nullptr
;
}
#
endif
}
;
class
TextureClient
:
public
AtomicRefCountedWithFinalize
<
TextureClient
>
{
public
:
explicit
TextureClient
(
TextureData
*
aData
TextureFlags
aFlags
ISurfaceAllocator
*
aAllocator
)
;
virtual
~
TextureClient
(
)
;
static
already_AddRefed
<
TextureClient
>
CreateWithData
(
TextureData
*
aData
TextureFlags
aFlags
ISurfaceAllocator
*
aAllocator
)
;
static
already_AddRefed
<
TextureClient
>
CreateForDrawing
(
CompositableForwarder
*
aAllocator
gfx
:
:
SurfaceFormat
aFormat
gfx
:
:
IntSize
aSize
BackendSelector
aSelector
TextureFlags
aTextureFlags
TextureAllocationFlags
flags
=
ALLOC_DEFAULT
)
;
static
already_AddRefed
<
TextureClient
>
CreateForYCbCr
(
ISurfaceAllocator
*
aAllocator
gfx
:
:
IntSize
aYSize
gfx
:
:
IntSize
aCbCrSize
StereoMode
aStereoMode
TextureFlags
aTextureFlags
)
;
static
already_AddRefed
<
TextureClient
>
CreateForRawBufferAccess
(
ISurfaceAllocator
*
aAllocator
gfx
:
:
SurfaceFormat
aFormat
gfx
:
:
IntSize
aSize
gfx
:
:
BackendType
aMoz2dBackend
TextureFlags
aTextureFlags
TextureAllocationFlags
flags
=
ALLOC_DEFAULT
)
;
static
already_AddRefed
<
TextureClient
>
CreateForYCbCrWithBufferSize
(
ISurfaceAllocator
*
aAllocator
gfx
:
:
SurfaceFormat
aFormat
size_t
aSize
TextureFlags
aTextureFlags
)
;
already_AddRefed
<
TextureClient
>
CreateSimilar
(
TextureFlags
aFlags
=
TextureFlags
:
:
DEFAULT
TextureAllocationFlags
aAllocFlags
=
ALLOC_DEFAULT
)
const
;
bool
Lock
(
OpenMode
aMode
)
;
void
Unlock
(
)
;
bool
IsLocked
(
)
const
{
return
mIsLocked
;
}
bool
CanExposeDrawTarget
(
)
const
{
return
mData
-
>
SupportsMoz2D
(
)
;
}
bool
CanExposeMappedData
(
)
const
{
return
mData
-
>
CanExposeMappedData
(
)
;
}
gfx
:
:
DrawTarget
*
BorrowDrawTarget
(
)
;
bool
BorrowMappedData
(
MappedTextureData
&
)
;
bool
BorrowMappedYCbCrData
(
MappedYCbCrTextureData
&
)
;
void
UpdateFromSurface
(
gfx
:
:
SourceSurface
*
aSurface
)
;
virtual
gfx
:
:
SurfaceFormat
GetFormat
(
)
const
;
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
GetAsSurface
(
)
{
Lock
(
OpenMode
:
:
OPEN_READ
)
;
RefPtr
<
gfx
:
:
DataSourceSurface
>
data
;
RefPtr
<
gfx
:
:
DrawTarget
>
dt
=
BorrowDrawTarget
(
)
;
if
(
dt
)
{
RefPtr
<
gfx
:
:
SourceSurface
>
surf
=
dt
-
>
Snapshot
(
)
;
if
(
surf
)
{
data
=
surf
-
>
GetDataSurface
(
)
;
}
}
Unlock
(
)
;
return
data
.
forget
(
)
;
}
virtual
void
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
;
bool
CopyToTextureClient
(
TextureClient
*
aTarget
const
gfx
:
:
IntRect
*
aRect
const
gfx
:
:
IntPoint
*
aPoint
)
;
bool
HasSynchronization
(
)
const
{
return
false
;
}
bool
HasInternalBuffer
(
)
const
;
static
PTextureChild
*
CreateIPDLActor
(
)
;
static
bool
DestroyIPDLActor
(
PTextureChild
*
actor
)
;
static
bool
DestroyFallback
(
PTextureChild
*
actor
)
;
static
TextureClient
*
AsTextureClient
(
PTextureChild
*
actor
)
;
gfx
:
:
IntSize
GetSize
(
)
const
;
TextureFlags
GetFlags
(
)
const
{
return
mFlags
;
}
bool
HasFlags
(
TextureFlags
aFlags
)
const
{
return
(
mFlags
&
aFlags
)
=
=
aFlags
;
}
void
AddFlags
(
TextureFlags
aFlags
)
;
void
RemoveFlags
(
TextureFlags
aFlags
)
;
void
RecycleTexture
(
TextureFlags
aFlags
)
;
void
WaitForCompositorRecycle
(
)
;
bool
IsImmutable
(
)
const
{
return
!
!
(
mFlags
&
TextureFlags
:
:
IMMUTABLE
)
;
}
void
MarkImmutable
(
)
{
AddFlags
(
TextureFlags
:
:
IMMUTABLE
)
;
}
bool
IsSharedWithCompositor
(
)
const
;
bool
IsValid
(
)
const
{
return
!
!
mData
;
}
void
SetAddedToCompositableClient
(
)
;
bool
IsAddedToCompositableClient
(
)
const
{
return
mAddedToCompositableClient
;
}
bool
InitIPDLActor
(
CompositableForwarder
*
aForwarder
)
;
PTextureChild
*
GetIPDLActor
(
)
;
void
Destroy
(
bool
sync
=
false
)
;
virtual
void
SetReleaseFenceHandle
(
const
FenceHandle
&
aReleaseFenceHandle
)
{
mReleaseFenceHandle
.
Merge
(
aReleaseFenceHandle
)
;
}
virtual
FenceHandle
GetAndResetReleaseFenceHandle
(
)
{
FenceHandle
fence
;
mReleaseFenceHandle
.
TransferToAnotherFenceHandle
(
fence
)
;
return
fence
;
}
virtual
void
SetAcquireFenceHandle
(
const
FenceHandle
&
aAcquireFenceHandle
)
{
mAcquireFenceHandle
=
aAcquireFenceHandle
;
}
virtual
const
FenceHandle
&
GetAcquireFenceHandle
(
)
const
{
return
mAcquireFenceHandle
;
}
virtual
void
SetRemoveFromCompositableWaiter
(
AsyncTransactionWaiter
*
aWaiter
)
;
virtual
void
WaitForBufferOwnership
(
bool
aWaitReleaseFence
=
true
)
;
void
SetWaste
(
int
aWasteArea
)
{
mWasteTracker
.
Update
(
aWasteArea
BytesPerPixel
(
GetFormat
(
)
)
)
;
}
virtual
void
SetReadbackSink
(
TextureReadbackSink
*
aReadbackSink
)
{
mReadbackSink
=
aReadbackSink
;
}
void
SyncWithObject
(
SyncObject
*
aFence
)
{
mData
-
>
SyncWithObject
(
aFence
)
;
}
ISurfaceAllocator
*
GetAllocator
(
)
{
return
mAllocator
;
}
ITextureClientRecycleAllocator
*
GetRecycleAllocator
(
)
{
return
mRecycleAllocator
;
}
void
SetRecycleAllocator
(
ITextureClientRecycleAllocator
*
aAllocator
)
;
TextureData
*
GetInternalData
(
)
{
return
mData
;
}
const
TextureData
*
GetInternalData
(
)
const
{
return
mData
;
}
private
:
static
void
TextureClientRecycleCallback
(
TextureClient
*
aClient
void
*
aClosure
)
;
B2G_ACL_EXPORT
void
Finalize
(
)
{
}
friend
class
AtomicRefCountedWithFinalize
<
TextureClient
>
;
friend
class
gl
:
:
SharedSurface_Gralloc
;
protected
:
bool
ToSurfaceDescriptor
(
SurfaceDescriptor
&
aDescriptor
)
;
RefPtr
<
ISurfaceAllocator
>
mAllocator
;
RefPtr
<
TextureChild
>
mActor
;
RefPtr
<
ITextureClientRecycleAllocator
>
mRecycleAllocator
;
RefPtr
<
AsyncTransactionWaiter
>
mRemoveFromCompositableWaiter
;
TextureData
*
mData
;
RefPtr
<
gfx
:
:
DrawTarget
>
mBorrowedDrawTarget
;
TextureFlags
mFlags
;
FenceHandle
mReleaseFenceHandle
;
FenceHandle
mAcquireFenceHandle
;
gl
:
:
GfxTextureWasteTracker
mWasteTracker
;
OpenMode
mOpenMode
;
DebugOnly
<
uint32_t
>
mExpectedDtRefs
;
bool
mIsLocked
;
bool
mAddedToCompositableClient
;
bool
mWorkaroundAnnoyingSharedSurfaceLifetimeIssues
;
bool
mWorkaroundAnnoyingSharedSurfaceOwnershipIssues
;
RefPtr
<
TextureReadbackSink
>
mReadbackSink
;
friend
class
TextureChild
;
friend
class
RemoveTextureFromCompositableTracker
;
friend
void
TestTextureClientSurface
(
TextureClient
*
gfxImageSurface
*
)
;
friend
void
TestTextureClientYCbCr
(
TextureClient
*
PlanarYCbCrData
&
)
;
#
ifdef
GFX_DEBUG_TRACK_CLIENTS_IN_POOL
public
:
TextureClientPool
*
mPoolTracker
;
#
endif
}
;
class
TextureClientReleaseTask
:
public
Task
{
public
:
explicit
TextureClientReleaseTask
(
TextureClient
*
aClient
)
:
mTextureClient
(
aClient
)
{
}
virtual
void
Run
(
)
override
{
mTextureClient
=
nullptr
;
}
private
:
RefPtr
<
TextureClient
>
mTextureClient
;
}
;
class
MOZ_RAII
TextureClientAutoLock
{
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
;
public
:
TextureClientAutoLock
(
TextureClient
*
aTexture
OpenMode
aMode
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mTexture
(
aTexture
)
mSucceeded
(
false
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
mSucceeded
=
mTexture
-
>
Lock
(
aMode
)
;
mChecked
=
false
;
}
~
TextureClientAutoLock
(
)
{
MOZ_ASSERT
(
mChecked
)
;
if
(
mSucceeded
)
{
mTexture
-
>
Unlock
(
)
;
}
}
bool
Succeeded
(
)
{
mChecked
=
true
;
return
mSucceeded
;
}
private
:
TextureClient
*
mTexture
;
DebugOnly
<
bool
>
mChecked
;
bool
mSucceeded
;
}
;
class
KeepAlive
{
public
:
virtual
~
KeepAlive
(
)
{
}
}
;
template
<
typename
T
>
class
TKeepAlive
:
public
KeepAlive
{
public
:
explicit
TKeepAlive
(
T
*
aData
)
:
mData
(
aData
)
{
}
protected
:
RefPtr
<
T
>
mData
;
}
;
bool
UpdateYCbCrTextureClient
(
TextureClient
*
aTexture
const
PlanarYCbCrData
&
aData
)
;
}
}
#
endif
