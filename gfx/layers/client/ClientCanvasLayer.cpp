#
include
"
ClientCanvasLayer
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
GLScreenBuffer
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
SharedSurfaceEGL
.
h
"
#
include
"
SharedSurfaceGL
.
h
"
#
include
"
ClientLayerManager
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
layers
/
AsyncCanvasRenderer
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
gfxPrefs
.
h
"
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
gl
;
namespace
mozilla
{
namespace
layers
{
ClientCanvasLayer
:
:
~
ClientCanvasLayer
(
)
{
MOZ_COUNT_DTOR
(
ClientCanvasLayer
)
;
if
(
mCanvasClient
)
{
mCanvasClient
-
>
OnDetach
(
)
;
mCanvasClient
=
nullptr
;
}
}
void
ClientCanvasLayer
:
:
Initialize
(
const
Data
&
aData
)
{
CopyableCanvasLayer
:
:
Initialize
(
aData
)
;
mCanvasClient
=
nullptr
;
if
(
!
mGLContext
)
return
;
GLScreenBuffer
*
screen
=
mGLContext
-
>
Screen
(
)
;
SurfaceCaps
caps
;
if
(
mGLFrontbuffer
)
{
caps
=
mGLFrontbuffer
-
>
mHasAlpha
?
SurfaceCaps
:
:
ForRGBA
(
)
:
SurfaceCaps
:
:
ForRGB
(
)
;
}
else
{
MOZ_ASSERT
(
screen
)
;
caps
=
screen
-
>
mCaps
;
}
MOZ_ASSERT
(
caps
.
alpha
=
=
aData
.
mHasAlpha
)
;
auto
forwarder
=
ClientManager
(
)
-
>
AsShadowForwarder
(
)
;
mFlags
=
TextureFlags
:
:
ORIGIN_BOTTOM_LEFT
;
if
(
!
aData
.
mIsGLAlphaPremult
)
{
mFlags
|
=
TextureFlags
:
:
NON_PREMULTIPLIED
;
}
UniquePtr
<
SurfaceFactory
>
factory
=
GLScreenBuffer
:
:
CreateFactory
(
mGLContext
caps
forwarder
mFlags
)
;
if
(
mGLFrontbuffer
|
|
aData
.
mIsMirror
)
{
mFactory
=
Move
(
factory
)
;
if
(
!
mFactory
)
{
mFactory
=
MakeUnique
<
SurfaceFactory_Basic
>
(
mGLContext
caps
mFlags
)
;
}
}
else
{
if
(
factory
)
screen
-
>
Morph
(
Move
(
factory
)
)
;
}
}
void
ClientCanvasLayer
:
:
RenderLayer
(
)
{
PROFILER_LABEL
(
"
ClientCanvasLayer
"
"
RenderLayer
"
js
:
:
ProfileEntry
:
:
Category
:
:
GRAPHICS
)
;
RenderMaskLayers
(
this
)
;
if
(
!
mCanvasClient
)
{
TextureFlags
flags
=
TextureFlags
:
:
DEFAULT
;
if
(
mOriginPos
=
=
gl
:
:
OriginPos
:
:
BottomLeft
)
{
flags
|
=
TextureFlags
:
:
ORIGIN_BOTTOM_LEFT
;
}
if
(
!
mIsAlphaPremultiplied
)
{
flags
|
=
TextureFlags
:
:
NON_PREMULTIPLIED
;
}
mCanvasClient
=
CanvasClient
:
:
CreateCanvasClient
(
GetCanvasClientType
(
)
ClientManager
(
)
-
>
AsShadowForwarder
(
)
flags
)
;
if
(
!
mCanvasClient
)
{
return
;
}
if
(
HasShadow
(
)
)
{
if
(
mAsyncRenderer
)
{
static_cast
<
CanvasClientBridge
*
>
(
mCanvasClient
.
get
(
)
)
-
>
SetLayer
(
this
)
;
}
else
{
mCanvasClient
-
>
Connect
(
)
;
ClientManager
(
)
-
>
AsShadowForwarder
(
)
-
>
Attach
(
mCanvasClient
this
)
;
}
}
}
if
(
mCanvasClient
&
&
mAsyncRenderer
)
{
mCanvasClient
-
>
UpdateAsync
(
mAsyncRenderer
)
;
}
if
(
!
IsDirty
(
)
)
{
return
;
}
Painted
(
)
;
FirePreTransactionCallback
(
)
;
if
(
mBufferProvider
&
&
mBufferProvider
-
>
GetTextureClient
(
)
)
{
if
(
!
mBufferProvider
-
>
SetForwarder
(
ClientManager
(
)
-
>
AsShadowForwarder
(
)
)
)
{
gfxCriticalNote
<
<
"
BufferProvider
:
:
SetForwarder
failed
"
;
return
;
}
mCanvasClient
-
>
UpdateFromTexture
(
mBufferProvider
-
>
GetTextureClient
(
)
)
;
}
else
{
mCanvasClient
-
>
Update
(
gfx
:
:
IntSize
(
mBounds
.
width
mBounds
.
height
)
this
)
;
}
FireDidTransactionCallback
(
)
;
ClientManager
(
)
-
>
Hold
(
this
)
;
mCanvasClient
-
>
Updated
(
)
;
}
bool
ClientCanvasLayer
:
:
UpdateTarget
(
DrawTarget
*
aDestTarget
)
{
MOZ_ASSERT
(
aDestTarget
)
;
if
(
!
aDestTarget
)
{
return
false
;
}
RefPtr
<
SourceSurface
>
surface
;
if
(
!
mGLContext
)
{
AutoReturnSnapshot
autoReturn
;
if
(
mAsyncRenderer
)
{
surface
=
mAsyncRenderer
-
>
GetSurface
(
)
;
}
else
if
(
mBufferProvider
)
{
surface
=
mBufferProvider
-
>
BorrowSnapshot
(
)
;
autoReturn
.
mSnapshot
=
&
surface
;
autoReturn
.
mBufferProvider
=
mBufferProvider
;
}
MOZ_ASSERT
(
surface
)
;
if
(
!
surface
)
{
return
false
;
}
aDestTarget
-
>
CopySurface
(
surface
IntRect
(
0
0
mBounds
.
width
mBounds
.
height
)
IntPoint
(
0
0
)
)
;
return
true
;
}
SharedSurface
*
frontbuffer
=
nullptr
;
if
(
mGLFrontbuffer
)
{
frontbuffer
=
mGLFrontbuffer
.
get
(
)
;
}
else
{
GLScreenBuffer
*
screen
=
mGLContext
-
>
Screen
(
)
;
const
auto
&
front
=
screen
-
>
Front
(
)
;
if
(
front
)
{
frontbuffer
=
front
-
>
Surf
(
)
;
}
}
if
(
!
frontbuffer
)
{
NS_WARNING
(
"
Null
frame
received
.
"
)
;
return
false
;
}
IntSize
readSize
(
frontbuffer
-
>
mSize
)
;
SurfaceFormat
format
=
(
GetContentFlags
(
)
&
CONTENT_OPAQUE
)
?
SurfaceFormat
:
:
B8G8R8X8
:
SurfaceFormat
:
:
B8G8R8A8
;
bool
needsPremult
=
frontbuffer
-
>
mHasAlpha
&
&
!
mIsAlphaPremultiplied
;
uint8_t
*
destData
;
IntSize
destSize
;
int32_t
destStride
;
SurfaceFormat
destFormat
;
if
(
aDestTarget
-
>
LockBits
(
&
destData
&
destSize
&
destStride
&
destFormat
)
)
{
if
(
destSize
=
=
readSize
&
&
destFormat
=
=
format
)
{
RefPtr
<
DataSourceSurface
>
data
=
Factory
:
:
CreateWrappingDataSourceSurface
(
destData
destStride
destSize
destFormat
)
;
mGLContext
-
>
Readback
(
frontbuffer
data
)
;
if
(
needsPremult
)
{
gfxUtils
:
:
PremultiplyDataSurface
(
data
data
)
;
}
aDestTarget
-
>
ReleaseBits
(
destData
)
;
return
true
;
}
aDestTarget
-
>
ReleaseBits
(
destData
)
;
}
RefPtr
<
DataSourceSurface
>
resultSurf
=
GetTempSurface
(
readSize
format
)
;
if
(
NS_WARN_IF
(
!
resultSurf
)
)
{
return
false
;
}
mGLContext
-
>
Readback
(
frontbuffer
resultSurf
)
;
if
(
needsPremult
)
{
gfxUtils
:
:
PremultiplyDataSurface
(
resultSurf
resultSurf
)
;
}
aDestTarget
-
>
CopySurface
(
resultSurf
IntRect
(
0
0
readSize
.
width
readSize
.
height
)
IntPoint
(
0
0
)
)
;
return
true
;
}
CanvasClient
:
:
CanvasClientType
ClientCanvasLayer
:
:
GetCanvasClientType
(
)
{
if
(
mAsyncRenderer
)
{
return
CanvasClient
:
:
CanvasClientAsync
;
}
if
(
mGLContext
)
{
return
CanvasClient
:
:
CanvasClientTypeShSurf
;
}
return
CanvasClient
:
:
CanvasClientSurface
;
}
already_AddRefed
<
CanvasLayer
>
ClientLayerManager
:
:
CreateCanvasLayer
(
)
{
NS_ASSERTION
(
InConstruction
(
)
"
Only
allowed
in
construction
phase
"
)
;
RefPtr
<
ClientCanvasLayer
>
layer
=
new
ClientCanvasLayer
(
this
)
;
CREATE_SHADOW
(
Canvas
)
;
return
layer
.
forget
(
)
;
}
}
}
