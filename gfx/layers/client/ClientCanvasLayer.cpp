#
include
"
ClientCanvasLayer
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
GLScreenBuffer
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
SharedSurfaceEGL
.
h
"
#
include
"
SharedSurfaceGL
.
h
"
#
include
"
ClientLayerManager
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
layers
/
AsyncCanvasRenderer
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
gfxPrefs
.
h
"
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
gl
;
namespace
mozilla
{
namespace
layers
{
ClientCanvasLayer
:
:
~
ClientCanvasLayer
(
)
{
MOZ_COUNT_DTOR
(
ClientCanvasLayer
)
;
if
(
mCanvasClient
)
{
mCanvasClient
-
>
OnDetach
(
)
;
mCanvasClient
=
nullptr
;
}
}
void
ClientCanvasLayer
:
:
Initialize
(
const
Data
&
aData
)
{
CopyableCanvasLayer
:
:
Initialize
(
aData
)
;
mCanvasClient
=
nullptr
;
if
(
!
mGLContext
)
return
;
GLScreenBuffer
*
screen
=
mGLContext
-
>
Screen
(
)
;
SurfaceCaps
caps
;
if
(
mGLFrontbuffer
)
{
caps
=
mGLFrontbuffer
-
>
mHasAlpha
?
SurfaceCaps
:
:
ForRGBA
(
)
:
SurfaceCaps
:
:
ForRGB
(
)
;
}
else
{
MOZ_ASSERT
(
screen
)
;
caps
=
screen
-
>
mCaps
;
}
MOZ_ASSERT
(
caps
.
alpha
=
=
aData
.
mHasAlpha
)
;
auto
forwarder
=
ClientManager
(
)
-
>
AsShadowForwarder
(
)
;
mFlags
=
TextureFlags
:
:
ORIGIN_BOTTOM_LEFT
;
if
(
!
aData
.
mIsGLAlphaPremult
)
{
mFlags
|
=
TextureFlags
:
:
NON_PREMULTIPLIED
;
}
UniquePtr
<
SurfaceFactory
>
factory
=
GLScreenBuffer
:
:
CreateFactory
(
mGLContext
caps
forwarder
mFlags
)
;
if
(
mGLFrontbuffer
)
{
mFactory
=
Move
(
factory
)
;
if
(
!
mFactory
)
{
mFactory
=
MakeUnique
<
SurfaceFactory_Basic
>
(
mGLContext
caps
mFlags
)
;
}
}
else
{
if
(
factory
)
screen
-
>
Morph
(
Move
(
factory
)
)
;
}
}
void
ClientCanvasLayer
:
:
RenderLayer
(
)
{
PROFILER_LABEL
(
"
ClientCanvasLayer
"
"
RenderLayer
"
js
:
:
ProfileEntry
:
:
Category
:
:
GRAPHICS
)
;
RenderMaskLayers
(
this
)
;
if
(
!
mCanvasClient
)
{
TextureFlags
flags
=
TextureFlags
:
:
IMMEDIATE_UPLOAD
;
if
(
mOriginPos
=
=
gl
:
:
OriginPos
:
:
BottomLeft
)
{
flags
|
=
TextureFlags
:
:
ORIGIN_BOTTOM_LEFT
;
}
if
(
!
mGLContext
)
{
flags
|
=
TextureFlags
:
:
IMMEDIATE_UPLOAD
;
}
if
(
!
mIsAlphaPremultiplied
)
{
flags
|
=
TextureFlags
:
:
NON_PREMULTIPLIED
;
}
mCanvasClient
=
CanvasClient
:
:
CreateCanvasClient
(
GetCanvasClientType
(
)
ClientManager
(
)
-
>
AsShadowForwarder
(
)
flags
)
;
if
(
!
mCanvasClient
)
{
return
;
}
if
(
HasShadow
(
)
)
{
if
(
mAsyncRenderer
)
{
static_cast
<
CanvasClientBridge
*
>
(
mCanvasClient
.
get
(
)
)
-
>
SetLayer
(
this
)
;
}
else
{
mCanvasClient
-
>
Connect
(
)
;
ClientManager
(
)
-
>
AsShadowForwarder
(
)
-
>
Attach
(
mCanvasClient
this
)
;
}
}
}
if
(
mCanvasClient
&
&
mAsyncRenderer
)
{
mCanvasClient
-
>
UpdateAsync
(
mAsyncRenderer
)
;
}
if
(
!
IsDirty
(
)
)
{
return
;
}
Painted
(
)
;
FirePreTransactionCallback
(
)
;
mCanvasClient
-
>
Update
(
gfx
:
:
IntSize
(
mBounds
.
width
mBounds
.
height
)
this
)
;
FireDidTransactionCallback
(
)
;
ClientManager
(
)
-
>
Hold
(
this
)
;
mCanvasClient
-
>
Updated
(
)
;
}
CanvasClient
:
:
CanvasClientType
ClientCanvasLayer
:
:
GetCanvasClientType
(
)
{
if
(
mAsyncRenderer
)
{
return
CanvasClient
:
:
CanvasClientAsync
;
}
if
(
mGLContext
)
{
return
CanvasClient
:
:
CanvasClientTypeShSurf
;
}
return
CanvasClient
:
:
CanvasClientSurface
;
}
already_AddRefed
<
CanvasLayer
>
ClientLayerManager
:
:
CreateCanvasLayer
(
)
{
NS_ASSERTION
(
InConstruction
(
)
"
Only
allowed
in
construction
phase
"
)
;
nsRefPtr
<
ClientCanvasLayer
>
layer
=
new
ClientCanvasLayer
(
this
)
;
CREATE_SHADOW
(
Canvas
)
;
return
layer
.
forget
(
)
;
}
}
}
