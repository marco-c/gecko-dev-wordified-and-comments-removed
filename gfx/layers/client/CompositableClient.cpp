#
include
"
mozilla
/
layers
/
CompositableClient
.
h
"
#
include
<
stdint
.
h
>
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
layers
/
CompositableForwarder
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
layers
/
TextureClientOGL
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
layers
/
TextureClientRecycleAllocator
.
h
"
#
ifdef
XP_WIN
#
include
"
gfxWindowsPlatform
.
h
"
#
include
"
mozilla
/
layers
/
TextureD3D11
.
h
"
#
endif
#
include
"
gfxUtils
.
h
"
#
include
"
IPDLActor
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
mozilla
:
:
gfx
;
void
CompositableClient
:
:
InitIPDL
(
const
CompositableHandle
&
aHandle
)
{
MOZ_ASSERT
(
aHandle
)
;
mForwarder
-
>
AssertInForwarderThread
(
)
;
mHandle
=
aHandle
;
mIsAsync
=
!
NS_IsMainThread
(
)
;
}
CompositableClient
:
:
CompositableClient
(
CompositableForwarder
*
aForwarder
TextureFlags
aTextureFlags
)
:
mForwarder
(
aForwarder
)
mTextureFlags
(
aTextureFlags
)
mIsAsync
(
false
)
{
}
CompositableClient
:
:
~
CompositableClient
(
)
{
Destroy
(
)
;
}
LayersBackend
CompositableClient
:
:
GetCompositorBackendType
(
)
const
{
return
mForwarder
-
>
GetCompositorBackendType
(
)
;
}
bool
CompositableClient
:
:
Connect
(
ImageContainer
*
aImageContainer
)
{
MOZ_ASSERT
(
!
mHandle
)
;
if
(
!
GetForwarder
(
)
|
|
mHandle
)
{
return
false
;
}
GetForwarder
(
)
-
>
AssertInForwarderThread
(
)
;
GetForwarder
(
)
-
>
Connect
(
this
aImageContainer
)
;
return
true
;
}
bool
CompositableClient
:
:
IsConnected
(
)
const
{
mForwarder
-
>
AssertInForwarderThread
(
)
;
return
!
!
mHandle
;
}
void
CompositableClient
:
:
Destroy
(
)
{
if
(
mTextureClientRecycler
)
{
mTextureClientRecycler
-
>
Destroy
(
)
;
}
if
(
mHandle
)
{
mForwarder
-
>
ReleaseCompositable
(
mHandle
)
;
mHandle
=
CompositableHandle
(
)
;
}
}
CompositableHandle
CompositableClient
:
:
GetAsyncHandle
(
)
const
{
if
(
mIsAsync
)
{
return
mHandle
;
}
return
CompositableHandle
(
)
;
}
already_AddRefed
<
TextureClient
>
CompositableClient
:
:
CreateBufferTextureClient
(
gfx
:
:
SurfaceFormat
aFormat
gfx
:
:
IntSize
aSize
gfx
:
:
BackendType
aMoz2DBackend
TextureFlags
aTextureFlags
)
{
return
TextureClient
:
:
CreateForRawBufferAccess
(
GetForwarder
(
)
aFormat
aSize
aMoz2DBackend
aTextureFlags
|
mTextureFlags
)
;
}
already_AddRefed
<
TextureClient
>
CompositableClient
:
:
CreateTextureClientForDrawing
(
gfx
:
:
SurfaceFormat
aFormat
gfx
:
:
IntSize
aSize
BackendSelector
aSelector
TextureFlags
aTextureFlags
TextureAllocationFlags
aAllocFlags
)
{
return
TextureClient
:
:
CreateForDrawing
(
GetForwarder
(
)
aFormat
aSize
aSelector
aTextureFlags
|
mTextureFlags
aAllocFlags
)
;
}
already_AddRefed
<
TextureClient
>
CompositableClient
:
:
CreateTextureClientFromSurface
(
gfx
:
:
SourceSurface
*
aSurface
BackendSelector
aSelector
TextureFlags
aTextureFlags
TextureAllocationFlags
aAllocFlags
)
{
return
TextureClient
:
:
CreateFromSurface
(
GetForwarder
(
)
aSurface
aSelector
aTextureFlags
|
mTextureFlags
aAllocFlags
)
;
}
bool
CompositableClient
:
:
AddTextureClient
(
TextureClient
*
aClient
)
{
if
(
!
aClient
)
{
return
false
;
}
aClient
-
>
SetAddedToCompositableClient
(
)
;
return
aClient
-
>
InitIPDLActor
(
mForwarder
)
;
}
void
CompositableClient
:
:
ClearCachedResources
(
)
{
if
(
mTextureClientRecycler
)
{
mTextureClientRecycler
-
>
ShrinkToMinimumSize
(
)
;
}
}
void
CompositableClient
:
:
HandleMemoryPressure
(
)
{
if
(
mTextureClientRecycler
)
{
mTextureClientRecycler
-
>
ShrinkToMinimumSize
(
)
;
}
}
void
CompositableClient
:
:
RemoveTexture
(
TextureClient
*
aTexture
const
Maybe
<
wr
:
:
RenderRoot
>
&
aRenderRoot
)
{
mForwarder
-
>
RemoveTextureFromCompositable
(
this
aTexture
aRenderRoot
)
;
}
TextureClientRecycleAllocator
*
CompositableClient
:
:
GetTextureClientRecycler
(
)
{
if
(
mTextureClientRecycler
)
{
return
mTextureClientRecycler
;
}
if
(
!
mForwarder
|
|
!
mForwarder
-
>
GetTextureForwarder
(
)
)
{
return
nullptr
;
}
if
(
!
mForwarder
-
>
GetTextureForwarder
(
)
-
>
UsesImageBridge
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mTextureClientRecycler
=
new
layers
:
:
TextureClientRecycleAllocator
(
mForwarder
)
;
return
mTextureClientRecycler
;
}
if
(
InImageBridgeChildThread
(
)
)
{
mTextureClientRecycler
=
new
layers
:
:
TextureClientRecycleAllocator
(
mForwarder
)
;
return
mTextureClientRecycler
;
}
ReentrantMonitor
barrier
(
"
CompositableClient
:
:
GetTextureClientRecycler
"
)
;
ReentrantMonitorAutoEnter
mainThreadAutoMon
(
barrier
)
;
bool
done
=
false
;
RefPtr
<
Runnable
>
runnable
=
NS_NewRunnableFunction
(
"
layers
:
:
CompositableClient
:
:
GetTextureClientRecycler
"
[
&
]
(
)
{
if
(
!
mTextureClientRecycler
)
{
mTextureClientRecycler
=
new
layers
:
:
TextureClientRecycleAllocator
(
mForwarder
)
;
}
ReentrantMonitorAutoEnter
childThreadAutoMon
(
barrier
)
;
done
=
true
;
barrier
.
NotifyAll
(
)
;
}
)
;
ImageBridgeChild
:
:
GetSingleton
(
)
-
>
GetMessageLoop
(
)
-
>
PostTask
(
runnable
.
forget
(
)
)
;
while
(
!
done
)
{
barrier
.
Wait
(
)
;
}
return
mTextureClientRecycler
;
}
void
CompositableClient
:
:
DumpTextureClient
(
std
:
:
stringstream
&
aStream
TextureClient
*
aTexture
TextureDumpMode
aCompress
)
{
if
(
!
aTexture
)
{
return
;
}
RefPtr
<
gfx
:
:
DataSourceSurface
>
dSurf
=
aTexture
-
>
GetAsSurface
(
)
;
if
(
!
dSurf
)
{
return
;
}
if
(
aCompress
=
=
TextureDumpMode
:
:
Compress
)
{
aStream
<
<
gfxUtils
:
:
GetAsLZ4Base64Str
(
dSurf
)
.
get
(
)
;
}
else
{
aStream
<
<
gfxUtils
:
:
GetAsDataURI
(
dSurf
)
.
get
(
)
;
}
}
AutoRemoveTexture
:
:
~
AutoRemoveTexture
(
)
{
if
(
mCompositable
&
&
mTexture
&
&
mCompositable
-
>
IsConnected
(
)
)
{
mCompositable
-
>
RemoveTexture
(
mTexture
Some
(
mRenderRoot
)
)
;
}
}
}
}
