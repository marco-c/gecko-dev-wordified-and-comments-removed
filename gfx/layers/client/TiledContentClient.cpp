#
include
"
mozilla
/
layers
/
TiledContentClient
.
h
"
#
include
<
math
.
h
>
#
include
<
algorithm
>
#
include
"
ClientTiledPaintedLayer
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
ClientLayerManager
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
gfxRect
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
Tools
.
h
"
#
include
"
mozilla
/
layers
/
CompositableForwarder
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
LayerMetricsWrapper
.
h
"
#
include
"
mozilla
/
layers
/
ShadowLayers
.
h
"
#
include
"
mozilla
/
layers
/
PaintThread
.
h
"
#
include
"
TextureClientPool
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsExpirationTracker
.
h
"
#
include
"
nsMathUtils
.
h
"
#
include
"
LayersLogging
.
h
"
#
include
"
UnitTransforms
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
define
MINIMUM_TILE_COPY_AREA
(
1
.
f
/
16
.
f
)
#
ifdef
GFX_TILEDLAYER_DEBUG_OVERLAY
#
include
"
cairo
.
h
"
#
include
<
sstream
>
using
mozilla
:
:
layers
:
:
Layer
;
static
void
DrawDebugOverlay
(
mozilla
:
:
gfx
:
:
DrawTarget
*
dt
int
x
int
y
int
width
int
height
)
{
gfxContext
c
(
dt
)
;
c
.
NewPath
(
)
;
c
.
SetDeviceColor
(
Color
(
0
.
f
0
.
f
0
.
f
)
)
;
c
.
Rectangle
(
gfxRect
(
0
0
width
height
)
)
;
c
.
Stroke
(
)
;
std
:
:
stringstream
ss
;
ss
<
<
x
<
<
"
"
<
<
y
;
cairo_t
*
cr
=
gfxFont
:
:
RefCairo
(
dt
)
;
cairo_set_font_size
(
cr
25
)
;
cairo_text_extents_t
extents
;
cairo_text_extents
(
cr
ss
.
str
(
)
.
c_str
(
)
&
extents
)
;
int
textWidth
=
extents
.
width
+
6
;
c
.
NewPath
(
)
;
c
.
SetDeviceColor
(
Color
(
0
.
f
0
.
f
0
.
f
)
)
;
c
.
Rectangle
(
gfxRect
(
gfxPoint
(
2
2
)
gfxSize
(
textWidth
30
)
)
)
;
c
.
Fill
(
)
;
c
.
NewPath
(
)
;
c
.
SetDeviceColor
(
Color
(
1
.
0
0
.
0
0
.
0
)
)
;
c
.
Rectangle
(
gfxRect
(
gfxPoint
(
2
2
)
gfxSize
(
textWidth
30
)
)
)
;
c
.
Stroke
(
)
;
c
.
NewPath
(
)
;
cairo_move_to
(
cr
4
28
)
;
cairo_show_text
(
cr
ss
.
str
(
)
.
c_str
(
)
)
;
}
#
endif
namespace
mozilla
{
using
namespace
gfx
;
namespace
layers
{
MultiTiledContentClient
:
:
MultiTiledContentClient
(
ClientTiledPaintedLayer
&
aPaintedLayer
ClientLayerManager
*
aManager
)
:
TiledContentClient
(
aManager
"
Multi
"
)
mTiledBuffer
(
aPaintedLayer
*
this
aManager
&
mSharedFrameMetricsHelper
)
mLowPrecisionTiledBuffer
(
aPaintedLayer
*
this
aManager
&
mSharedFrameMetricsHelper
)
{
MOZ_COUNT_CTOR
(
MultiTiledContentClient
)
;
mLowPrecisionTiledBuffer
.
SetResolution
(
gfxPrefs
:
:
LowPrecisionResolution
(
)
)
;
mHasLowPrecision
=
gfxPrefs
:
:
UseLowPrecisionBuffer
(
)
;
}
void
MultiTiledContentClient
:
:
ClearCachedResources
(
)
{
CompositableClient
:
:
ClearCachedResources
(
)
;
mTiledBuffer
.
DiscardBuffers
(
)
;
mLowPrecisionTiledBuffer
.
DiscardBuffers
(
)
;
}
void
MultiTiledContentClient
:
:
UpdatedBuffer
(
TiledBufferType
aType
)
{
ClientMultiTiledLayerBuffer
*
buffer
=
aType
=
=
LOW_PRECISION_TILED_BUFFER
?
&
mLowPrecisionTiledBuffer
:
&
mTiledBuffer
;
MOZ_ASSERT
(
aType
!
=
LOW_PRECISION_TILED_BUFFER
|
|
mHasLowPrecision
)
;
mForwarder
-
>
UseTiledLayerBuffer
(
this
buffer
-
>
GetSurfaceDescriptorTiles
(
)
)
;
buffer
-
>
ClearPaintedRegion
(
)
;
}
SharedFrameMetricsHelper
:
:
SharedFrameMetricsHelper
(
)
:
mLastProgressiveUpdateWasLowPrecision
(
false
)
mProgressiveUpdateWasInDanger
(
false
)
{
MOZ_COUNT_CTOR
(
SharedFrameMetricsHelper
)
;
}
SharedFrameMetricsHelper
:
:
~
SharedFrameMetricsHelper
(
)
{
MOZ_COUNT_DTOR
(
SharedFrameMetricsHelper
)
;
}
static
inline
bool
FuzzyEquals
(
float
a
float
b
)
{
return
(
fabsf
(
a
-
b
)
<
1e
-
6
)
;
}
static
AsyncTransform
ComputeViewTransform
(
const
FrameMetrics
&
aContentMetrics
const
FrameMetrics
&
aCompositorMetrics
)
{
ParentLayerPoint
translation
=
(
aCompositorMetrics
.
GetScrollOffset
(
)
-
aContentMetrics
.
GetScrollOffset
(
)
)
*
aCompositorMetrics
.
GetZoom
(
)
;
return
AsyncTransform
(
aCompositorMetrics
.
GetAsyncZoom
(
)
-
translation
)
;
}
bool
SharedFrameMetricsHelper
:
:
UpdateFromCompositorFrameMetrics
(
const
LayerMetricsWrapper
&
aLayer
bool
aHasPendingNewThebesContent
bool
aLowPrecision
AsyncTransform
&
aViewTransform
)
{
MOZ_ASSERT
(
aLayer
)
;
CompositorBridgeChild
*
compositor
=
nullptr
;
if
(
aLayer
.
Manager
(
)
&
&
aLayer
.
Manager
(
)
-
>
AsClientLayerManager
(
)
)
{
compositor
=
aLayer
.
Manager
(
)
-
>
AsClientLayerManager
(
)
-
>
GetCompositorBridgeChild
(
)
;
}
if
(
!
compositor
)
{
return
false
;
}
const
FrameMetrics
&
contentMetrics
=
aLayer
.
Metrics
(
)
;
FrameMetrics
compositorMetrics
;
if
(
!
compositor
-
>
LookupCompositorFrameMetrics
(
contentMetrics
.
GetScrollId
(
)
compositorMetrics
)
)
{
return
false
;
}
aViewTransform
=
ComputeViewTransform
(
contentMetrics
compositorMetrics
)
;
if
(
aLowPrecision
&
&
!
mLastProgressiveUpdateWasLowPrecision
)
{
if
(
!
mProgressiveUpdateWasInDanger
)
{
TILING_LOG
(
"
TILING
:
Aborting
low
-
precision
rendering
because
not
at
risk
of
checkerboarding
\
n
"
)
;
return
true
;
}
mProgressiveUpdateWasInDanger
=
false
;
}
mLastProgressiveUpdateWasLowPrecision
=
aLowPrecision
;
if
(
!
FuzzyEquals
(
compositorMetrics
.
GetZoom
(
)
.
xScale
contentMetrics
.
GetZoom
(
)
.
xScale
)
|
|
!
FuzzyEquals
(
compositorMetrics
.
GetZoom
(
)
.
yScale
contentMetrics
.
GetZoom
(
)
.
yScale
)
)
{
TILING_LOG
(
"
TILING
:
Aborting
because
resolution
changed
from
%
s
to
%
s
\
n
"
ToString
(
contentMetrics
.
GetZoom
(
)
)
.
c_str
(
)
ToString
(
compositorMetrics
.
GetZoom
(
)
)
.
c_str
(
)
)
;
return
true
;
}
if
(
fabsf
(
contentMetrics
.
GetScrollOffset
(
)
.
x
-
compositorMetrics
.
GetScrollOffset
(
)
.
x
)
<
=
2
&
&
fabsf
(
contentMetrics
.
GetScrollOffset
(
)
.
y
-
compositorMetrics
.
GetScrollOffset
(
)
.
y
)
<
=
2
&
&
fabsf
(
contentMetrics
.
GetDisplayPort
(
)
.
x
-
compositorMetrics
.
GetDisplayPort
(
)
.
x
)
<
=
2
&
&
fabsf
(
contentMetrics
.
GetDisplayPort
(
)
.
y
-
compositorMetrics
.
GetDisplayPort
(
)
.
y
)
<
=
2
&
&
fabsf
(
contentMetrics
.
GetDisplayPort
(
)
.
Width
(
)
-
compositorMetrics
.
GetDisplayPort
(
)
.
Width
(
)
)
<
=
2
&
&
fabsf
(
contentMetrics
.
GetDisplayPort
(
)
.
Height
(
)
-
compositorMetrics
.
GetDisplayPort
(
)
.
Height
(
)
)
<
=
2
)
{
return
false
;
}
if
(
!
aLowPrecision
&
&
!
mProgressiveUpdateWasInDanger
)
{
bool
scrollUpdatePending
=
contentMetrics
.
GetScrollOffsetUpdated
(
)
&
&
contentMetrics
.
GetScrollGeneration
(
)
!
=
compositorMetrics
.
GetScrollGeneration
(
)
;
if
(
!
scrollUpdatePending
&
&
AboutToCheckerboard
(
contentMetrics
compositorMetrics
)
)
{
mProgressiveUpdateWasInDanger
=
true
;
return
true
;
}
}
if
(
aLowPrecision
&
&
!
aHasPendingNewThebesContent
)
{
TILING_LOG
(
"
TILING
:
Aborting
low
-
precision
because
of
new
pending
content
\
n
"
)
;
return
true
;
}
return
false
;
}
bool
SharedFrameMetricsHelper
:
:
AboutToCheckerboard
(
const
FrameMetrics
&
aContentMetrics
const
FrameMetrics
&
aCompositorMetrics
)
{
CSSRect
painted
=
(
aContentMetrics
.
GetCriticalDisplayPort
(
)
.
IsEmpty
(
)
?
aContentMetrics
.
GetDisplayPort
(
)
:
aContentMetrics
.
GetCriticalDisplayPort
(
)
)
+
aContentMetrics
.
GetScrollOffset
(
)
;
painted
.
Inflate
(
CSSMargin
:
:
FromAppUnits
(
nsMargin
(
1
1
1
1
)
)
)
;
CSSRect
showing
=
CSSRect
(
aCompositorMetrics
.
GetScrollOffset
(
)
aCompositorMetrics
.
CalculateBoundedCompositedSizeInCssPixels
(
)
)
;
showing
.
Inflate
(
LayerSize
(
gfxPrefs
:
:
APZDangerZoneX
(
)
gfxPrefs
:
:
APZDangerZoneY
(
)
)
/
aCompositorMetrics
.
LayersPixelsPerCSSPixel
(
)
)
;
painted
=
painted
.
Intersect
(
aContentMetrics
.
GetScrollableRect
(
)
)
;
showing
=
showing
.
Intersect
(
aContentMetrics
.
GetScrollableRect
(
)
)
;
if
(
!
painted
.
Contains
(
showing
)
)
{
TILING_LOG
(
"
TILING
:
About
to
checkerboard
;
content
%
s
\
n
"
Stringify
(
aContentMetrics
)
.
c_str
(
)
)
;
TILING_LOG
(
"
TILING
:
About
to
checkerboard
;
painted
%
s
\
n
"
Stringify
(
painted
)
.
c_str
(
)
)
;
TILING_LOG
(
"
TILING
:
About
to
checkerboard
;
compositor
%
s
\
n
"
Stringify
(
aCompositorMetrics
)
.
c_str
(
)
)
;
TILING_LOG
(
"
TILING
:
About
to
checkerboard
;
showing
%
s
\
n
"
Stringify
(
showing
)
.
c_str
(
)
)
;
return
true
;
}
return
false
;
}
ClientMultiTiledLayerBuffer
:
:
ClientMultiTiledLayerBuffer
(
ClientTiledPaintedLayer
&
aPaintedLayer
CompositableClient
&
aCompositableClient
ClientLayerManager
*
aManager
SharedFrameMetricsHelper
*
aHelper
)
:
ClientTiledLayerBuffer
(
aPaintedLayer
aCompositableClient
)
mManager
(
aManager
)
mCallback
(
nullptr
)
mCallbackData
(
nullptr
)
mSharedFrameMetricsHelper
(
aHelper
)
{
}
bool
ClientTiledLayerBuffer
:
:
HasFormatChanged
(
)
const
{
SurfaceMode
mode
;
gfxContentType
content
=
GetContentType
(
&
mode
)
;
return
content
!
=
mLastPaintContentType
|
|
mode
!
=
mLastPaintSurfaceMode
;
}
gfxContentType
ClientTiledLayerBuffer
:
:
GetContentType
(
SurfaceMode
*
aMode
)
const
{
gfxContentType
content
=
mPaintedLayer
.
CanUseOpaqueSurface
(
)
?
gfxContentType
:
:
COLOR
:
gfxContentType
:
:
COLOR_ALPHA
;
SurfaceMode
mode
=
mPaintedLayer
.
GetSurfaceMode
(
)
;
if
(
mode
=
=
SurfaceMode
:
:
SURFACE_COMPONENT_ALPHA
)
{
#
if
defined
(
MOZ_GFX_OPTIMIZE_MOBILE
)
mode
=
SurfaceMode
:
:
SURFACE_SINGLE_CHANNEL_ALPHA
;
#
else
if
(
!
mPaintedLayer
.
GetParent
(
)
|
|
!
mPaintedLayer
.
GetParent
(
)
-
>
SupportsComponentAlphaChildren
(
)
)
{
mode
=
SurfaceMode
:
:
SURFACE_SINGLE_CHANNEL_ALPHA
;
}
else
{
content
=
gfxContentType
:
:
COLOR
;
}
#
endif
}
else
if
(
mode
=
=
SurfaceMode
:
:
SURFACE_OPAQUE
)
{
#
if
defined
(
MOZ_GFX_OPTIMIZE_MOBILE
)
if
(
IsLowPrecision
(
)
)
{
mode
=
SurfaceMode
:
:
SURFACE_SINGLE_CHANNEL_ALPHA
;
content
=
gfxContentType
:
:
COLOR_ALPHA
;
}
#
else
if
(
mPaintedLayer
.
MayResample
(
)
)
{
mode
=
SurfaceMode
:
:
SURFACE_SINGLE_CHANNEL_ALPHA
;
content
=
gfxContentType
:
:
COLOR_ALPHA
;
}
#
endif
}
if
(
aMode
)
{
*
aMode
=
mode
;
}
return
content
;
}
class
TileExpiry
final
:
public
nsExpirationTracker
<
TileClient
3
>
{
public
:
TileExpiry
(
)
:
nsExpirationTracker
<
TileClient
3
>
(
1000
"
TileExpiry
"
)
{
}
static
void
AddTile
(
TileClient
*
aTile
)
{
if
(
!
sTileExpiry
)
{
sTileExpiry
=
MakeUnique
<
TileExpiry
>
(
)
;
}
sTileExpiry
-
>
AddObject
(
aTile
)
;
}
static
void
RemoveTile
(
TileClient
*
aTile
)
{
MOZ_ASSERT
(
sTileExpiry
)
;
sTileExpiry
-
>
RemoveObject
(
aTile
)
;
}
static
void
Shutdown
(
)
{
sTileExpiry
=
nullptr
;
}
private
:
virtual
void
NotifyExpired
(
TileClient
*
aTile
)
override
{
aTile
-
>
DiscardBackBuffer
(
)
;
}
static
UniquePtr
<
TileExpiry
>
sTileExpiry
;
}
;
UniquePtr
<
TileExpiry
>
TileExpiry
:
:
sTileExpiry
;
void
ShutdownTileCache
(
)
{
TileExpiry
:
:
Shutdown
(
)
;
}
void
TileClient
:
:
PrivateProtector
:
:
Set
(
TileClient
*
const
aContainer
RefPtr
<
TextureClient
>
aNewValue
)
{
if
(
mBuffer
)
{
TileExpiry
:
:
RemoveTile
(
aContainer
)
;
}
mBuffer
=
aNewValue
;
if
(
mBuffer
)
{
TileExpiry
:
:
AddTile
(
aContainer
)
;
}
}
void
TileClient
:
:
PrivateProtector
:
:
Set
(
TileClient
*
const
aContainer
TextureClient
*
aNewValue
)
{
Set
(
aContainer
RefPtr
<
TextureClient
>
(
aNewValue
)
)
;
}
TileClient
:
:
TileClient
(
)
:
mWasPlaceholder
(
false
)
{
}
TileClient
:
:
~
TileClient
(
)
{
if
(
mExpirationState
.
IsTracked
(
)
)
{
MOZ_ASSERT
(
mBackBuffer
)
;
TileExpiry
:
:
RemoveTile
(
this
)
;
}
}
TileClient
:
:
TileClient
(
const
TileClient
&
o
)
{
mBackBuffer
.
Set
(
this
o
.
mBackBuffer
)
;
mBackBufferOnWhite
=
o
.
mBackBufferOnWhite
;
mFrontBuffer
=
o
.
mFrontBuffer
;
mFrontBufferOnWhite
=
o
.
mFrontBufferOnWhite
;
mWasPlaceholder
=
o
.
mWasPlaceholder
;
mUpdateRect
=
o
.
mUpdateRect
;
#
ifdef
GFX_TILEDLAYER_DEBUG_OVERLAY
mLastUpdate
=
o
.
mLastUpdate
;
#
endif
mAllocator
=
o
.
mAllocator
;
mInvalidFront
=
o
.
mInvalidFront
;
mInvalidBack
=
o
.
mInvalidBack
;
}
TileClient
&
TileClient
:
:
operator
=
(
const
TileClient
&
o
)
{
if
(
this
=
=
&
o
)
return
*
this
;
mBackBuffer
.
Set
(
this
o
.
mBackBuffer
)
;
mBackBufferOnWhite
=
o
.
mBackBufferOnWhite
;
mFrontBuffer
=
o
.
mFrontBuffer
;
mFrontBufferOnWhite
=
o
.
mFrontBufferOnWhite
;
mWasPlaceholder
=
o
.
mWasPlaceholder
;
mUpdateRect
=
o
.
mUpdateRect
;
#
ifdef
GFX_TILEDLAYER_DEBUG_OVERLAY
mLastUpdate
=
o
.
mLastUpdate
;
#
endif
mAllocator
=
o
.
mAllocator
;
mInvalidFront
=
o
.
mInvalidFront
;
mInvalidBack
=
o
.
mInvalidBack
;
return
*
this
;
}
void
TileClient
:
:
Dump
(
std
:
:
stringstream
&
aStream
)
{
aStream
<
<
"
TileClient
(
bb
=
"
<
<
(
TextureClient
*
)
mBackBuffer
<
<
"
fb
=
"
<
<
mFrontBuffer
.
get
(
)
;
if
(
mBackBufferOnWhite
)
{
aStream
<
<
"
bbow
=
"
<
<
mBackBufferOnWhite
.
get
(
)
;
}
if
(
mFrontBufferOnWhite
)
{
aStream
<
<
"
fbow
=
"
<
<
mFrontBufferOnWhite
.
get
(
)
;
}
aStream
<
<
"
)
"
;
}
void
TileClient
:
:
Flip
(
)
{
RefPtr
<
TextureClient
>
frontBuffer
=
mFrontBuffer
;
RefPtr
<
TextureClient
>
frontBufferOnWhite
=
mFrontBufferOnWhite
;
mFrontBuffer
=
mBackBuffer
;
mFrontBufferOnWhite
=
mBackBufferOnWhite
;
mBackBuffer
.
Set
(
this
frontBuffer
)
;
mBackBufferOnWhite
=
frontBufferOnWhite
;
nsIntRegion
invalidFront
=
mInvalidFront
;
mInvalidFront
=
mInvalidBack
;
mInvalidBack
=
invalidFront
;
}
static
bool
CopyFrontToBack
(
TextureClient
*
aFront
TextureClient
*
aBack
const
gfx
:
:
IntRect
&
aRectToCopy
TilePaintFlags
aFlags
)
{
bool
asyncPaint
=
!
!
(
aFlags
&
TilePaintFlags
:
:
Async
)
;
OpenMode
lockMode
=
asyncPaint
?
OpenMode
:
:
OPEN_READ_ASYNC_WRITE
:
OpenMode
:
:
OPEN_READ_WRITE
;
TextureClientAutoLock
frontLock
(
aFront
OpenMode
:
:
OPEN_READ
)
;
if
(
!
frontLock
.
Succeeded
(
)
)
{
return
false
;
}
if
(
!
aBack
-
>
Lock
(
lockMode
)
)
{
gfxCriticalError
(
)
<
<
"
[
Tiling
:
Client
]
Failed
to
lock
the
tile
'
s
back
buffer
"
;
return
false
;
}
gfx
:
:
IntPoint
rectToCopyTopLeft
=
aRectToCopy
.
TopLeft
(
)
;
aFront
-
>
CopyToTextureClient
(
aBack
&
aRectToCopy
&
rectToCopyTopLeft
)
;
return
true
;
}
void
TileClient
:
:
ValidateBackBufferFromFront
(
const
nsIntRegion
&
aDirtyRegion
nsIntRegion
&
aAddPaintedRegion
TilePaintFlags
aFlags
)
{
if
(
mBackBuffer
&
&
mFrontBuffer
)
{
gfx
:
:
IntSize
tileSize
=
mFrontBuffer
-
>
GetSize
(
)
;
const
IntRect
tileRect
=
IntRect
(
0
0
tileSize
.
width
tileSize
.
height
)
;
if
(
aDirtyRegion
.
Contains
(
tileRect
)
)
{
DiscardFrontBuffer
(
)
;
}
else
{
nsIntRegion
regionToCopy
=
mInvalidBack
;
regionToCopy
.
Sub
(
regionToCopy
aDirtyRegion
)
;
aAddPaintedRegion
=
regionToCopy
;
if
(
regionToCopy
.
IsEmpty
(
)
)
{
return
;
}
const
IntRect
rectToCopy
=
regionToCopy
.
GetBounds
(
)
;
gfx
:
:
IntRect
gfxRectToCopy
(
rectToCopy
.
x
rectToCopy
.
y
rectToCopy
.
Width
(
)
rectToCopy
.
Height
(
)
)
;
if
(
CopyFrontToBack
(
mFrontBuffer
mBackBuffer
gfxRectToCopy
aFlags
)
)
{
if
(
mBackBufferOnWhite
)
{
MOZ_ASSERT
(
mFrontBufferOnWhite
)
;
if
(
CopyFrontToBack
(
mFrontBufferOnWhite
mBackBufferOnWhite
gfxRectToCopy
aFlags
)
)
{
mInvalidBack
.
SetEmpty
(
)
;
}
}
}
}
}
}
void
TileClient
:
:
DiscardFrontBuffer
(
)
{
if
(
mFrontBuffer
)
{
MOZ_ASSERT
(
mFrontBuffer
-
>
GetReadLock
(
)
)
;
MOZ_ASSERT
(
mAllocator
)
;
if
(
mAllocator
)
{
mAllocator
-
>
ReturnTextureClientDeferred
(
mFrontBuffer
)
;
if
(
mFrontBufferOnWhite
)
{
mAllocator
-
>
ReturnTextureClientDeferred
(
mFrontBufferOnWhite
)
;
}
}
if
(
mFrontBuffer
-
>
IsLocked
(
)
)
{
mFrontBuffer
-
>
Unlock
(
)
;
}
if
(
mFrontBufferOnWhite
&
&
mFrontBufferOnWhite
-
>
IsLocked
(
)
)
{
mFrontBufferOnWhite
-
>
Unlock
(
)
;
}
mFrontBuffer
=
nullptr
;
mFrontBufferOnWhite
=
nullptr
;
}
}
static
void
DiscardTexture
(
TextureClient
*
aTexture
TextureClientAllocator
*
aAllocator
)
{
MOZ_ASSERT
(
aAllocator
)
;
if
(
aTexture
&
&
aAllocator
)
{
MOZ_ASSERT
(
aTexture
-
>
GetReadLock
(
)
)
;
if
(
!
aTexture
-
>
HasSynchronization
(
)
&
&
aTexture
-
>
IsReadLocked
(
)
)
{
aAllocator
-
>
ReportClientLost
(
)
;
}
else
{
aAllocator
-
>
ReturnTextureClientDeferred
(
aTexture
)
;
}
if
(
aTexture
-
>
IsLocked
(
)
)
{
aTexture
-
>
Unlock
(
)
;
}
}
}
void
TileClient
:
:
DiscardBackBuffer
(
)
{
if
(
mBackBuffer
)
{
DiscardTexture
(
mBackBuffer
mAllocator
)
;
mBackBuffer
.
Set
(
this
nullptr
)
;
DiscardTexture
(
mBackBufferOnWhite
mAllocator
)
;
mBackBufferOnWhite
=
nullptr
;
}
}
static
already_AddRefed
<
TextureClient
>
CreateBackBufferTexture
(
TextureClient
*
aCurrentTexture
CompositableClient
&
aCompositable
TextureClientAllocator
*
aAllocator
)
{
if
(
aCurrentTexture
)
{
aAllocator
-
>
ReportClientLost
(
)
;
}
RefPtr
<
TextureClient
>
texture
=
aAllocator
-
>
GetTextureClient
(
)
;
if
(
!
texture
)
{
gfxCriticalError
(
)
<
<
"
[
Tiling
:
Client
]
Failed
to
allocate
a
TextureClient
"
;
return
nullptr
;
}
texture
-
>
EnableReadLock
(
)
;
if
(
!
aCompositable
.
AddTextureClient
(
texture
)
)
{
gfxCriticalError
(
)
<
<
"
[
Tiling
:
Client
]
Failed
to
connect
a
TextureClient
"
;
return
nullptr
;
}
return
texture
.
forget
(
)
;
}
TextureClient
*
TileClient
:
:
GetBackBuffer
(
CompositableClient
&
aCompositable
const
nsIntRegion
&
aDirtyRegion
gfxContentType
aContent
SurfaceMode
aMode
nsIntRegion
&
aAddPaintedRegion
TilePaintFlags
aFlags
RefPtr
<
TextureClient
>
*
aBackBufferOnWhite
)
{
if
(
!
mAllocator
)
{
gfxCriticalError
(
)
<
<
"
[
TileClient
]
Missing
TextureClientAllocator
.
"
;
return
nullptr
;
}
if
(
aMode
!
=
SurfaceMode
:
:
SURFACE_COMPONENT_ALPHA
)
{
if
(
mBackBufferOnWhite
)
{
mAllocator
-
>
ReportClientLost
(
)
;
mBackBufferOnWhite
=
nullptr
;
}
if
(
mFrontBufferOnWhite
)
{
mAllocator
-
>
ReportClientLost
(
)
;
mFrontBufferOnWhite
=
nullptr
;
}
}
if
(
mFrontBuffer
&
&
mFrontBuffer
-
>
HasIntermediateBuffer
(
)
&
&
!
mFrontBuffer
-
>
IsReadLocked
(
)
&
&
(
aMode
!
=
SurfaceMode
:
:
SURFACE_COMPONENT_ALPHA
|
|
(
mFrontBufferOnWhite
&
&
!
mFrontBufferOnWhite
-
>
IsReadLocked
(
)
)
)
)
{
DiscardBackBuffer
(
)
;
Flip
(
)
;
}
else
{
if
(
!
mBackBuffer
|
|
mBackBuffer
-
>
IsReadLocked
(
)
)
{
mBackBuffer
.
Set
(
this
CreateBackBufferTexture
(
mBackBuffer
aCompositable
mAllocator
)
)
;
if
(
!
mBackBuffer
)
{
DiscardBackBuffer
(
)
;
DiscardFrontBuffer
(
)
;
return
nullptr
;
}
mInvalidBack
=
IntRect
(
IntPoint
(
)
mBackBuffer
-
>
GetSize
(
)
)
;
}
if
(
aMode
=
=
SurfaceMode
:
:
SURFACE_COMPONENT_ALPHA
&
&
(
!
mBackBufferOnWhite
|
|
mBackBufferOnWhite
-
>
IsReadLocked
(
)
)
)
{
mBackBufferOnWhite
=
CreateBackBufferTexture
(
mBackBufferOnWhite
aCompositable
mAllocator
)
;
if
(
!
mBackBufferOnWhite
)
{
DiscardBackBuffer
(
)
;
DiscardFrontBuffer
(
)
;
return
nullptr
;
}
mInvalidBack
=
IntRect
(
IntPoint
(
)
mBackBufferOnWhite
-
>
GetSize
(
)
)
;
}
ValidateBackBufferFromFront
(
aDirtyRegion
aAddPaintedRegion
aFlags
)
;
}
OpenMode
lockMode
=
aFlags
&
TilePaintFlags
:
:
Async
?
OpenMode
:
:
OPEN_READ_ASYNC_WRITE
:
OpenMode
:
:
OPEN_READ_WRITE
;
if
(
!
mBackBuffer
-
>
IsLocked
(
)
)
{
if
(
!
mBackBuffer
-
>
Lock
(
lockMode
)
)
{
gfxCriticalError
(
)
<
<
"
[
Tiling
:
Client
]
Failed
to
lock
a
tile
(
B
)
"
;
DiscardBackBuffer
(
)
;
DiscardFrontBuffer
(
)
;
return
nullptr
;
}
}
if
(
mBackBufferOnWhite
&
&
!
mBackBufferOnWhite
-
>
IsLocked
(
)
)
{
if
(
!
mBackBufferOnWhite
-
>
Lock
(
lockMode
)
)
{
gfxCriticalError
(
)
<
<
"
[
Tiling
:
Client
]
Failed
to
lock
a
tile
(
W
)
"
;
DiscardBackBuffer
(
)
;
DiscardFrontBuffer
(
)
;
return
nullptr
;
}
}
*
aBackBufferOnWhite
=
mBackBufferOnWhite
;
return
mBackBuffer
;
}
TileDescriptor
TileClient
:
:
GetTileDescriptor
(
)
{
if
(
IsPlaceholderTile
(
)
)
{
mWasPlaceholder
=
true
;
return
PlaceholderTileDescriptor
(
)
;
}
bool
wasPlaceholder
=
mWasPlaceholder
;
mWasPlaceholder
=
false
;
ReadLockDescriptor
lock
;
mFrontBuffer
-
>
SerializeReadLock
(
lock
)
;
ReadLockDescriptor
lockOnWhite
=
null_t
(
)
;
if
(
mFrontBufferOnWhite
)
{
mFrontBufferOnWhite
-
>
SerializeReadLock
(
lockOnWhite
)
;
}
return
TexturedTileDescriptor
(
nullptr
mFrontBuffer
-
>
GetIPDLActor
(
)
mFrontBufferOnWhite
?
MaybeTexture
(
mFrontBufferOnWhite
-
>
GetIPDLActor
(
)
)
:
MaybeTexture
(
null_t
(
)
)
mUpdateRect
lock
lockOnWhite
wasPlaceholder
)
;
}
void
ClientMultiTiledLayerBuffer
:
:
DiscardBuffers
(
)
{
for
(
TileClient
&
tile
:
mRetainedTiles
)
{
tile
.
DiscardBuffers
(
)
;
}
}
SurfaceDescriptorTiles
ClientMultiTiledLayerBuffer
:
:
GetSurfaceDescriptorTiles
(
)
{
InfallibleTArray
<
TileDescriptor
>
tiles
;
for
(
TileClient
&
tile
:
mRetainedTiles
)
{
TileDescriptor
tileDesc
=
tile
.
GetTileDescriptor
(
)
;
tiles
.
AppendElement
(
tileDesc
)
;
tile
.
mUpdateRect
=
IntRect
(
)
;
}
return
SurfaceDescriptorTiles
(
mValidRegion
tiles
mTileOrigin
mTileSize
mTiles
.
mFirst
.
x
mTiles
.
mFirst
.
y
mTiles
.
mSize
.
width
mTiles
.
mSize
.
height
mResolution
mFrameResolution
.
xScale
mFrameResolution
.
yScale
mWasLastPaintProgressive
)
;
}
void
ClientMultiTiledLayerBuffer
:
:
PaintThebes
(
const
nsIntRegion
&
aNewValidRegion
const
nsIntRegion
&
aPaintRegion
const
nsIntRegion
&
aDirtyRegion
LayerManager
:
:
DrawPaintedLayerCallback
aCallback
void
*
aCallbackData
TilePaintFlags
aFlags
)
{
TILING_LOG
(
"
TILING
%
p
:
PaintThebes
painting
region
%
s
\
n
"
&
mPaintedLayer
Stringify
(
aPaintRegion
)
.
c_str
(
)
)
;
TILING_LOG
(
"
TILING
%
p
:
PaintThebes
new
valid
region
%
s
\
n
"
&
mPaintedLayer
Stringify
(
aNewValidRegion
)
.
c_str
(
)
)
;
mCallback
=
aCallback
;
mCallbackData
=
aCallbackData
;
mWasLastPaintProgressive
=
!
!
(
aFlags
&
TilePaintFlags
:
:
Progressive
)
;
#
ifdef
GFX_TILEDLAYER_PREF_WARNINGS
long
start
=
PR_IntervalNow
(
)
;
#
endif
#
ifdef
GFX_TILEDLAYER_PREF_WARNINGS
if
(
PR_IntervalNow
(
)
-
start
>
30
)
{
const
IntRect
bounds
=
aPaintRegion
.
GetBounds
(
)
;
printf_stderr
(
"
Time
to
draw
%
i
:
%
i
%
i
%
i
%
i
\
n
"
PR_IntervalNow
(
)
-
start
bounds
.
x
bounds
.
y
bounds
.
width
bounds
.
height
)
;
if
(
aPaintRegion
.
IsComplex
(
)
)
{
printf_stderr
(
"
Complex
region
\
n
"
)
;
for
(
auto
iter
=
aPaintRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
IntRect
&
rect
=
iter
.
Get
(
)
;
printf_stderr
(
"
rect
%
i
%
i
%
i
%
i
\
n
"
rect
.
x
rect
.
y
rect
.
width
rect
.
height
)
;
}
}
}
start
=
PR_IntervalNow
(
)
;
#
endif
AUTO_PROFILER_LABEL
(
"
ClientMultiTiledLayerBuffer
:
:
PaintThebes
"
GRAPHICS
)
;
mNewValidRegion
=
aNewValidRegion
;
Update
(
aNewValidRegion
aPaintRegion
aDirtyRegion
aFlags
)
;
#
ifdef
GFX_TILEDLAYER_PREF_WARNINGS
if
(
PR_IntervalNow
(
)
-
start
>
10
)
{
const
IntRect
bounds
=
aPaintRegion
.
GetBounds
(
)
;
printf_stderr
(
"
Time
to
tile
%
i
:
%
i
%
i
%
i
%
i
\
n
"
PR_IntervalNow
(
)
-
start
bounds
.
x
bounds
.
y
bounds
.
width
bounds
.
height
)
;
}
#
endif
mLastPaintContentType
=
GetContentType
(
&
mLastPaintSurfaceMode
)
;
mCallback
=
nullptr
;
mCallbackData
=
nullptr
;
}
void
PadDrawTargetOutFromRegion
(
RefPtr
<
DrawTarget
>
drawTarget
nsIntRegion
&
region
)
{
struct
LockedBits
{
uint8_t
*
data
;
IntSize
size
;
int32_t
stride
;
SurfaceFormat
format
;
static
int
clamp
(
int
x
int
min
int
max
)
{
if
(
x
<
min
)
x
=
min
;
if
(
x
>
max
)
x
=
max
;
return
x
;
}
static
void
ensure_memcpy
(
uint8_t
*
dst
uint8_t
*
src
size_t
n
uint8_t
*
bitmap
int
stride
int
height
)
{
if
(
src
+
n
>
bitmap
+
stride
*
height
)
{
MOZ_CRASH
(
"
GFX
:
long
src
memcpy
"
)
;
}
if
(
src
<
bitmap
)
{
MOZ_CRASH
(
"
GFX
:
short
src
memcpy
"
)
;
}
if
(
dst
+
n
>
bitmap
+
stride
*
height
)
{
MOZ_CRASH
(
"
GFX
:
long
dst
mempcy
"
)
;
}
if
(
dst
<
bitmap
)
{
MOZ_CRASH
(
"
GFX
:
short
dst
mempcy
"
)
;
}
}
static
void
visitor
(
void
*
closure
VisitSide
side
int
x1
int
y1
int
x2
int
y2
)
{
LockedBits
*
lb
=
static_cast
<
LockedBits
*
>
(
closure
)
;
uint8_t
*
bitmap
=
lb
-
>
data
;
const
int
bpp
=
gfx
:
:
BytesPerPixel
(
lb
-
>
format
)
;
const
int
stride
=
lb
-
>
stride
;
const
int
width
=
lb
-
>
size
.
width
;
const
int
height
=
lb
-
>
size
.
height
;
if
(
side
=
=
VisitSide
:
:
TOP
)
{
if
(
y1
>
0
)
{
x1
=
clamp
(
x1
0
width
-
1
)
;
x2
=
clamp
(
x2
0
width
-
1
)
;
ensure_memcpy
(
&
bitmap
[
x1
*
bpp
+
(
y1
-
1
)
*
stride
]
&
bitmap
[
x1
*
bpp
+
y1
*
stride
]
(
x2
-
x1
)
*
bpp
bitmap
stride
height
)
;
memcpy
(
&
bitmap
[
x1
*
bpp
+
(
y1
-
1
)
*
stride
]
&
bitmap
[
x1
*
bpp
+
y1
*
stride
]
(
x2
-
x1
)
*
bpp
)
;
}
}
else
if
(
side
=
=
VisitSide
:
:
BOTTOM
)
{
if
(
y1
<
height
)
{
x1
=
clamp
(
x1
0
width
-
1
)
;
x2
=
clamp
(
x2
0
width
-
1
)
;
ensure_memcpy
(
&
bitmap
[
x1
*
bpp
+
y1
*
stride
]
&
bitmap
[
x1
*
bpp
+
(
y1
-
1
)
*
stride
]
(
x2
-
x1
)
*
bpp
bitmap
stride
height
)
;
memcpy
(
&
bitmap
[
x1
*
bpp
+
y1
*
stride
]
&
bitmap
[
x1
*
bpp
+
(
y1
-
1
)
*
stride
]
(
x2
-
x1
)
*
bpp
)
;
}
}
else
if
(
side
=
=
VisitSide
:
:
LEFT
)
{
if
(
x1
>
0
)
{
while
(
y1
!
=
y2
)
{
memcpy
(
&
bitmap
[
(
x1
-
1
)
*
bpp
+
y1
*
stride
]
&
bitmap
[
x1
*
bpp
+
y1
*
stride
]
bpp
)
;
y1
+
+
;
}
}
}
else
if
(
side
=
=
VisitSide
:
:
RIGHT
)
{
if
(
x1
<
width
)
{
while
(
y1
!
=
y2
)
{
memcpy
(
&
bitmap
[
x1
*
bpp
+
y1
*
stride
]
&
bitmap
[
(
x1
-
1
)
*
bpp
+
y1
*
stride
]
bpp
)
;
y1
+
+
;
}
}
}
}
}
lb
;
if
(
drawTarget
-
>
LockBits
(
&
lb
.
data
&
lb
.
size
&
lb
.
stride
&
lb
.
format
)
)
{
region
.
VisitEdges
(
lb
.
visitor
&
lb
)
;
drawTarget
-
>
ReleaseBits
(
lb
.
data
)
;
}
}
void
ClientTiledLayerBuffer
:
:
UnlockTile
(
TileClient
&
aTile
)
{
if
(
aTile
.
mFrontBuffer
&
&
aTile
.
mFrontBuffer
-
>
IsLocked
(
)
)
{
aTile
.
mFrontBuffer
-
>
Unlock
(
)
;
aTile
.
mFrontBuffer
-
>
SyncWithObject
(
mCompositableClient
.
GetForwarder
(
)
-
>
GetSyncObject
(
)
)
;
}
if
(
aTile
.
mFrontBufferOnWhite
&
&
aTile
.
mFrontBufferOnWhite
-
>
IsLocked
(
)
)
{
aTile
.
mFrontBufferOnWhite
-
>
Unlock
(
)
;
aTile
.
mFrontBufferOnWhite
-
>
SyncWithObject
(
mCompositableClient
.
GetForwarder
(
)
-
>
GetSyncObject
(
)
)
;
}
if
(
aTile
.
mBackBuffer
&
&
aTile
.
mBackBuffer
-
>
IsLocked
(
)
)
{
aTile
.
mBackBuffer
-
>
Unlock
(
)
;
}
if
(
aTile
.
mBackBufferOnWhite
&
&
aTile
.
mBackBufferOnWhite
-
>
IsLocked
(
)
)
{
aTile
.
mBackBufferOnWhite
-
>
Unlock
(
)
;
}
}
void
ClientMultiTiledLayerBuffer
:
:
Update
(
const
nsIntRegion
&
newValidRegion
const
nsIntRegion
&
aPaintRegion
const
nsIntRegion
&
aDirtyRegion
TilePaintFlags
aFlags
)
{
const
IntSize
scaledTileSize
=
GetScaledTileSize
(
)
;
const
gfx
:
:
IntRect
newBounds
=
newValidRegion
.
GetBounds
(
)
;
const
TilesPlacement
oldTiles
=
mTiles
;
const
TilesPlacement
newTiles
(
floor_div
(
newBounds
.
x
scaledTileSize
.
width
)
floor_div
(
newBounds
.
y
scaledTileSize
.
height
)
floor_div
(
GetTileStart
(
newBounds
.
x
scaledTileSize
.
width
)
+
newBounds
.
Width
(
)
scaledTileSize
.
width
)
+
1
floor_div
(
GetTileStart
(
newBounds
.
y
scaledTileSize
.
height
)
+
newBounds
.
Height
(
)
scaledTileSize
.
height
)
+
1
)
;
const
size_t
oldTileCount
=
mRetainedTiles
.
Length
(
)
;
const
size_t
newTileCount
=
newTiles
.
mSize
.
width
*
newTiles
.
mSize
.
height
;
nsTArray
<
TileClient
>
oldRetainedTiles
;
mRetainedTiles
.
SwapElements
(
oldRetainedTiles
)
;
mRetainedTiles
.
SetLength
(
newTileCount
)
;
for
(
size_t
oldIndex
=
0
;
oldIndex
<
oldTileCount
;
oldIndex
+
+
)
{
const
TileIntPoint
tilePosition
=
oldTiles
.
TilePosition
(
oldIndex
)
;
const
size_t
newIndex
=
newTiles
.
TileIndex
(
tilePosition
)
;
if
(
newTiles
.
HasTile
(
tilePosition
)
)
{
mRetainedTiles
[
newIndex
]
=
oldRetainedTiles
[
oldIndex
]
;
}
else
{
oldRetainedTiles
[
oldIndex
]
.
DiscardBuffers
(
)
;
}
}
oldRetainedTiles
.
Clear
(
)
;
nsIntRegion
paintRegion
=
aPaintRegion
;
nsIntRegion
dirtyRegion
=
aDirtyRegion
;
if
(
!
paintRegion
.
IsEmpty
(
)
)
{
for
(
size_t
i
=
0
;
i
<
newTileCount
;
+
+
i
)
{
const
TileIntPoint
tilePosition
=
newTiles
.
TilePosition
(
i
)
;
IntPoint
tileOffset
=
GetTileOffset
(
tilePosition
)
;
nsIntRegion
tileDrawRegion
=
IntRect
(
tileOffset
scaledTileSize
)
;
tileDrawRegion
.
AndWith
(
paintRegion
)
;
if
(
tileDrawRegion
.
IsEmpty
(
)
)
{
continue
;
}
TileClient
&
tile
=
mRetainedTiles
[
i
]
;
if
(
!
ValidateTile
(
tile
GetTileOffset
(
tilePosition
)
tileDrawRegion
aFlags
)
)
{
gfxCriticalError
(
)
<
<
"
ValidateTile
failed
"
;
}
paintRegion
.
OrWith
(
tileDrawRegion
)
;
dirtyRegion
.
OrWith
(
tileDrawRegion
)
;
}
if
(
!
mPaintTiles
.
empty
(
)
)
{
gfx
:
:
TileSet
tileset
;
for
(
size_t
i
=
0
;
i
<
mPaintTiles
.
size
(
)
;
+
+
i
)
{
mPaintTiles
[
i
]
.
mTileOrigin
-
=
mTilingOrigin
;
}
tileset
.
mTiles
=
&
mPaintTiles
[
0
]
;
tileset
.
mTileCount
=
mPaintTiles
.
size
(
)
;
RefPtr
<
DrawTarget
>
drawTarget
=
gfx
:
:
Factory
:
:
CreateTiledDrawTarget
(
tileset
)
;
if
(
!
drawTarget
|
|
!
drawTarget
-
>
IsValid
(
)
)
{
gfxDevCrash
(
LogReason
:
:
InvalidContext
)
<
<
"
Invalid
tiled
draw
target
"
;
return
;
}
drawTarget
-
>
SetTransform
(
Matrix
(
)
)
;
if
(
aFlags
&
TilePaintFlags
:
:
Async
)
{
RefPtr
<
DrawTargetCapture
>
captureDT
=
Factory
:
:
CreateCaptureDrawTarget
(
drawTarget
-
>
GetBackendType
(
)
drawTarget
-
>
GetSize
(
)
drawTarget
-
>
GetFormat
(
)
)
;
RefPtr
<
gfxContext
>
ctx
=
gfxContext
:
:
CreateOrNull
(
captureDT
)
;
MOZ_ASSERT
(
ctx
)
;
ctx
-
>
SetMatrix
(
ctx
-
>
CurrentMatrix
(
)
.
PreScale
(
mResolution
mResolution
)
.
PreTranslate
(
-
mTilingOrigin
)
)
;
mCallback
(
&
mPaintedLayer
ctx
paintRegion
dirtyRegion
DrawRegionClip
:
:
DRAW
nsIntRegion
(
)
mCallbackData
)
;
ctx
=
nullptr
;
RefPtr
<
CapturedTiledPaintState
>
capturedState
=
new
CapturedTiledPaintState
(
drawTarget
captureDT
)
;
capturedState
-
>
mClients
=
std
:
:
move
(
mPaintTilesTextureClients
)
;
PaintThread
:
:
Get
(
)
-
>
PaintTiledContents
(
capturedState
)
;
mManager
-
>
SetQueuedAsyncPaints
(
)
;
}
else
{
RefPtr
<
gfxContext
>
ctx
=
gfxContext
:
:
CreateOrNull
(
drawTarget
)
;
MOZ_ASSERT
(
ctx
)
;
ctx
-
>
SetMatrix
(
ctx
-
>
CurrentMatrix
(
)
.
PreScale
(
mResolution
mResolution
)
.
PreTranslate
(
-
mTilingOrigin
)
)
;
mCallback
(
&
mPaintedLayer
ctx
paintRegion
dirtyRegion
DrawRegionClip
:
:
DRAW
nsIntRegion
(
)
mCallbackData
)
;
}
mPaintTiles
.
clear
(
)
;
mPaintTilesTextureClients
.
clear
(
)
;
mTilingOrigin
=
IntPoint
(
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
;
}
bool
edgePaddingEnabled
=
gfxPrefs
:
:
TileEdgePaddingEnabled
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mRetainedTiles
.
Length
(
)
;
+
+
i
)
{
TileClient
&
tile
=
mRetainedTiles
[
i
]
;
if
(
edgePaddingEnabled
&
&
mResolution
=
=
1
&
&
tile
.
mFrontBuffer
&
&
tile
.
mFrontBuffer
-
>
IsLocked
(
)
)
{
const
TileIntPoint
tilePosition
=
newTiles
.
TilePosition
(
i
)
;
IntPoint
tileOffset
=
GetTileOffset
(
tilePosition
)
;
IntRect
tileRect
=
IntRect
(
tileOffset
.
x
tileOffset
.
y
GetTileSize
(
)
.
width
GetTileSize
(
)
.
height
)
;
nsIntRegion
tileDrawRegion
=
IntRect
(
tileOffset
scaledTileSize
)
;
tileDrawRegion
.
AndWith
(
paintRegion
)
;
nsIntRegion
tileValidRegion
=
mValidRegion
;
tileValidRegion
.
OrWith
(
tileDrawRegion
)
;
if
(
!
tileValidRegion
.
Contains
(
tileRect
)
)
{
tileValidRegion
=
tileValidRegion
.
Intersect
(
tileRect
)
;
tileValidRegion
.
MoveBy
(
-
IntPoint
(
tileOffset
.
x
tileOffset
.
y
)
)
;
RefPtr
<
DrawTarget
>
drawTarget
=
tile
.
mFrontBuffer
-
>
BorrowDrawTarget
(
)
;
PadDrawTargetOutFromRegion
(
drawTarget
tileValidRegion
)
;
}
}
UnlockTile
(
tile
)
;
}
}
mTiles
=
newTiles
;
mValidRegion
=
newValidRegion
;
mPaintedRegion
.
OrWith
(
paintRegion
)
;
}
bool
ClientMultiTiledLayerBuffer
:
:
ValidateTile
(
TileClient
&
aTile
const
nsIntPoint
&
aTileOrigin
nsIntRegion
&
aDirtyRegion
TilePaintFlags
aFlags
)
{
AUTO_PROFILER_LABEL
(
"
ClientMultiTiledLayerBuffer
:
:
ValidateTile
"
GRAPHICS
)
;
#
ifdef
GFX_TILEDLAYER_PREF_WARNINGS
if
(
aDirtyRegion
.
IsComplex
(
)
)
{
printf_stderr
(
"
Complex
region
\
n
"
)
;
}
#
endif
SurfaceMode
mode
;
gfxContentType
content
=
GetContentType
(
&
mode
)
;
if
(
!
aTile
.
mAllocator
)
{
aTile
.
SetTextureAllocator
(
mManager
-
>
GetCompositorBridgeChild
(
)
-
>
GetTexturePool
(
mManager
-
>
AsShadowForwarder
(
)
gfxPlatform
:
:
GetPlatform
(
)
-
>
Optimal2DFormatForContent
(
content
)
TextureFlags
:
:
DISALLOW_BIGIMAGE
|
TextureFlags
:
:
IMMEDIATE_UPLOAD
)
)
;
MOZ_ASSERT
(
aTile
.
mAllocator
)
;
}
nsIntRegion
offsetScaledDirtyRegion
=
aDirtyRegion
.
MovedBy
(
-
aTileOrigin
)
;
offsetScaledDirtyRegion
.
ScaleRoundOut
(
mResolution
mResolution
)
;
nsIntRegion
extraPainted
;
RefPtr
<
TextureClient
>
backBufferOnWhite
;
RefPtr
<
TextureClient
>
backBuffer
=
aTile
.
GetBackBuffer
(
mCompositableClient
offsetScaledDirtyRegion
content
mode
extraPainted
aFlags
&
backBufferOnWhite
)
;
aTile
.
mInvalidFront
.
OrWith
(
offsetScaledDirtyRegion
)
;
nsIntRegion
invalidBack
=
aTile
.
mInvalidBack
;
invalidBack
.
MoveBy
(
aTileOrigin
)
;
invalidBack
.
ScaleInverseRoundOut
(
mResolution
mResolution
)
;
invalidBack
.
AndWith
(
mNewValidRegion
)
;
aDirtyRegion
.
OrWith
(
invalidBack
)
;
offsetScaledDirtyRegion
.
OrWith
(
aTile
.
mInvalidBack
)
;
aTile
.
mUpdateRect
=
offsetScaledDirtyRegion
.
GetBounds
(
)
.
Union
(
extraPainted
.
GetBounds
(
)
)
;
extraPainted
.
MoveBy
(
aTileOrigin
)
;
extraPainted
.
And
(
extraPainted
mNewValidRegion
)
;
mPaintedRegion
.
Or
(
mPaintedRegion
extraPainted
)
;
if
(
!
backBuffer
)
{
return
false
;
}
gfx
:
:
Tile
paintTile
;
RefPtr
<
DrawTarget
>
dt
=
backBuffer
-
>
BorrowDrawTarget
(
)
;
RefPtr
<
DrawTarget
>
dtOnWhite
;
if
(
backBufferOnWhite
)
{
dtOnWhite
=
backBufferOnWhite
-
>
BorrowDrawTarget
(
)
;
paintTile
.
mDrawTarget
=
Factory
:
:
CreateDualDrawTarget
(
dt
dtOnWhite
)
;
}
else
{
paintTile
.
mDrawTarget
=
dt
;
}
paintTile
.
mTileOrigin
=
gfx
:
:
IntPoint
(
aTileOrigin
.
x
aTileOrigin
.
y
)
;
if
(
!
dt
|
|
(
backBufferOnWhite
&
&
!
dtOnWhite
)
)
{
aTile
.
DiscardBuffers
(
)
;
return
false
;
}
mPaintTiles
.
push_back
(
paintTile
)
;
mTilingOrigin
.
x
=
std
:
:
min
(
mTilingOrigin
.
x
paintTile
.
mTileOrigin
.
x
)
;
mTilingOrigin
.
y
=
std
:
:
min
(
mTilingOrigin
.
y
paintTile
.
mTileOrigin
.
y
)
;
if
(
aFlags
&
TilePaintFlags
:
:
Async
)
{
mPaintTilesTextureClients
.
push_back
(
backBuffer
)
;
if
(
backBufferOnWhite
)
{
mPaintTilesTextureClients
.
push_back
(
backBufferOnWhite
)
;
}
}
for
(
auto
iter
=
offsetScaledDirtyRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
gfx
:
:
Rect
drawRect
(
iter
.
Get
(
)
.
x
iter
.
Get
(
)
.
y
iter
.
Get
(
)
.
width
iter
.
Get
(
)
.
height
)
;
if
(
mode
=
=
SurfaceMode
:
:
SURFACE_COMPONENT_ALPHA
)
{
dt
-
>
FillRect
(
drawRect
ColorPattern
(
Color
(
0
.
0
0
.
0
0
.
0
1
.
0
)
)
)
;
dtOnWhite
-
>
FillRect
(
drawRect
ColorPattern
(
Color
(
1
.
0
1
.
0
1
.
0
1
.
0
)
)
)
;
}
else
if
(
content
=
=
gfxContentType
:
:
COLOR_ALPHA
)
{
dt
-
>
ClearRect
(
drawRect
)
;
}
}
aTile
.
mInvalidBack
.
SubOut
(
offsetScaledDirtyRegion
)
;
aTile
.
Flip
(
)
;
return
true
;
}
static
Maybe
<
LayerRect
>
GetCompositorSideCompositionBounds
(
const
LayerMetricsWrapper
&
aScrollAncestor
const
LayerToParentLayerMatrix4x4
&
aTransformToCompBounds
const
AsyncTransform
&
aAPZTransform
const
LayerRect
&
aClip
)
{
LayerToParentLayerMatrix4x4
transform
=
aTransformToCompBounds
*
AsyncTransformComponentMatrix
(
aAPZTransform
)
;
return
UntransformBy
(
transform
.
Inverse
(
)
aScrollAncestor
.
Metrics
(
)
.
GetCompositionBounds
(
)
aClip
)
;
}
bool
ClientMultiTiledLayerBuffer
:
:
ComputeProgressiveUpdateRegion
(
const
nsIntRegion
&
aInvalidRegion
const
nsIntRegion
&
aOldValidRegion
nsIntRegion
&
aRegionToPaint
BasicTiledLayerPaintData
*
aPaintData
bool
aIsRepeated
)
{
aRegionToPaint
=
aInvalidRegion
;
if
(
aPaintData
-
>
mCompositionBounds
.
IsEmpty
(
)
)
{
aPaintData
-
>
mPaintFinished
=
true
;
return
false
;
}
bool
drawingLowPrecision
=
IsLowPrecision
(
)
;
nsIntRegion
staleRegion
;
staleRegion
.
And
(
aInvalidRegion
aOldValidRegion
)
;
TILING_LOG
(
"
TILING
%
p
:
Progressive
update
stale
region
%
s
\
n
"
&
mPaintedLayer
Stringify
(
staleRegion
)
.
c_str
(
)
)
;
LayerMetricsWrapper
scrollAncestor
;
mPaintedLayer
.
GetAncestorLayers
(
&
scrollAncestor
nullptr
nullptr
)
;
AsyncTransform
viewTransform
;
MOZ_ASSERT
(
mSharedFrameMetricsHelper
)
;
bool
abortPaint
=
mSharedFrameMetricsHelper
-
>
UpdateFromCompositorFrameMetrics
(
scrollAncestor
!
staleRegion
.
Contains
(
aInvalidRegion
)
drawingLowPrecision
viewTransform
)
;
TILING_LOG
(
"
TILING
%
p
:
Progressive
update
view
transform
%
s
zoom
%
f
abort
%
d
\
n
"
&
mPaintedLayer
ToString
(
viewTransform
.
mTranslation
)
.
c_str
(
)
viewTransform
.
mScale
.
scale
abortPaint
)
;
if
(
abortPaint
)
{
if
(
!
aPaintData
-
>
mFirstPaint
|
|
drawingLowPrecision
)
{
AUTO_PROFILER_LABEL
(
"
ClientMultiTiledLayerBuffer
:
:
ComputeProgressiveUpdateRegion
"
GRAPHICS
)
;
aRegionToPaint
.
SetEmpty
(
)
;
return
aIsRepeated
;
}
}
Maybe
<
LayerRect
>
transformedCompositionBounds
=
GetCompositorSideCompositionBounds
(
scrollAncestor
aPaintData
-
>
mTransformToCompBounds
viewTransform
LayerRect
(
mPaintedLayer
.
GetVisibleRegion
(
)
.
GetBounds
(
)
)
)
;
if
(
!
transformedCompositionBounds
)
{
aPaintData
-
>
mPaintFinished
=
true
;
return
false
;
}
TILING_LOG
(
"
TILING
%
p
:
Progressive
update
transformed
compositor
bounds
%
s
\
n
"
&
mPaintedLayer
Stringify
(
*
transformedCompositionBounds
)
.
c_str
(
)
)
;
IntRect
coherentUpdateRect
(
RoundedOut
(
#
ifdef
MOZ_WIDGET_ANDROID
transformedCompositionBounds
-
>
Intersect
(
aPaintData
-
>
mCompositionBounds
)
#
else
*
transformedCompositionBounds
#
endif
)
.
ToUnknownRect
(
)
)
;
TILING_LOG
(
"
TILING
%
p
:
Progressive
update
final
coherency
rect
%
s
\
n
"
&
mPaintedLayer
Stringify
(
coherentUpdateRect
)
.
c_str
(
)
)
;
aRegionToPaint
.
And
(
aInvalidRegion
coherentUpdateRect
)
;
aRegionToPaint
.
Or
(
aRegionToPaint
staleRegion
)
;
bool
drawingStale
=
!
aRegionToPaint
.
IsEmpty
(
)
;
if
(
!
drawingStale
)
{
aRegionToPaint
=
aInvalidRegion
;
}
bool
paintingVisible
=
false
;
if
(
aRegionToPaint
.
Intersects
(
coherentUpdateRect
)
)
{
aRegionToPaint
.
And
(
aRegionToPaint
coherentUpdateRect
)
;
paintingVisible
=
true
;
}
TILING_LOG
(
"
TILING
%
p
:
Progressive
update
final
paint
region
%
s
\
n
"
&
mPaintedLayer
Stringify
(
aRegionToPaint
)
.
c_str
(
)
)
;
bool
paintInSingleTransaction
=
paintingVisible
&
&
(
drawingStale
|
|
aPaintData
-
>
mFirstPaint
)
;
TILING_LOG
(
"
TILING
%
p
:
paintingVisible
%
d
drawingStale
%
d
firstPaint
%
d
singleTransaction
%
d
\
n
"
&
mPaintedLayer
paintingVisible
drawingStale
aPaintData
-
>
mFirstPaint
paintInSingleTransaction
)
;
NS_ASSERTION
(
!
aRegionToPaint
.
IsEmpty
(
)
"
Unexpectedly
empty
paint
region
!
"
)
;
IntRect
paintBounds
=
aRegionToPaint
.
GetBounds
(
)
;
int
startX
incX
startY
incY
;
gfx
:
:
IntSize
scaledTileSize
=
GetScaledTileSize
(
)
;
if
(
aPaintData
-
>
mScrollOffset
.
x
>
=
aPaintData
-
>
mLastScrollOffset
.
x
)
{
startX
=
RoundDownToTileEdge
(
paintBounds
.
x
scaledTileSize
.
width
)
;
incX
=
scaledTileSize
.
width
;
}
else
{
startX
=
RoundDownToTileEdge
(
paintBounds
.
XMost
(
)
-
1
scaledTileSize
.
width
)
;
incX
=
-
scaledTileSize
.
width
;
}
if
(
aPaintData
-
>
mScrollOffset
.
y
>
=
aPaintData
-
>
mLastScrollOffset
.
y
)
{
startY
=
RoundDownToTileEdge
(
paintBounds
.
y
scaledTileSize
.
height
)
;
incY
=
scaledTileSize
.
height
;
}
else
{
startY
=
RoundDownToTileEdge
(
paintBounds
.
YMost
(
)
-
1
scaledTileSize
.
height
)
;
incY
=
-
scaledTileSize
.
height
;
}
IntRect
tileBounds
(
startX
startY
scaledTileSize
.
width
scaledTileSize
.
height
)
;
int32_t
scrollDiffX
=
aPaintData
-
>
mScrollOffset
.
x
-
aPaintData
-
>
mLastScrollOffset
.
x
;
int32_t
scrollDiffY
=
aPaintData
-
>
mScrollOffset
.
y
-
aPaintData
-
>
mLastScrollOffset
.
y
;
while
(
true
)
{
aRegionToPaint
.
And
(
aInvalidRegion
tileBounds
)
;
if
(
!
aRegionToPaint
.
IsEmpty
(
)
)
{
if
(
mResolution
!
=
1
)
{
aRegionToPaint
=
tileBounds
;
}
break
;
}
if
(
Abs
(
scrollDiffY
)
>
=
Abs
(
scrollDiffX
)
)
{
tileBounds
.
x
+
=
incX
;
}
else
{
tileBounds
.
y
+
=
incY
;
}
}
if
(
!
aRegionToPaint
.
Contains
(
aInvalidRegion
)
)
{
return
(
!
drawingLowPrecision
&
&
paintInSingleTransaction
)
;
}
aPaintData
-
>
mPaintFinished
=
true
;
return
false
;
}
bool
ClientMultiTiledLayerBuffer
:
:
ProgressiveUpdate
(
const
nsIntRegion
&
aValidRegion
const
nsIntRegion
&
aInvalidRegion
const
nsIntRegion
&
aOldValidRegion
nsIntRegion
&
aOutDrawnRegion
BasicTiledLayerPaintData
*
aPaintData
LayerManager
:
:
DrawPaintedLayerCallback
aCallback
void
*
aCallbackData
)
{
TILING_LOG
(
"
TILING
%
p
:
Progressive
update
valid
region
%
s
\
n
"
&
mPaintedLayer
Stringify
(
aValidRegion
)
.
c_str
(
)
)
;
TILING_LOG
(
"
TILING
%
p
:
Progressive
update
invalid
region
%
s
\
n
"
&
mPaintedLayer
Stringify
(
aInvalidRegion
)
.
c_str
(
)
)
;
TILING_LOG
(
"
TILING
%
p
:
Progressive
update
old
valid
region
%
s
\
n
"
&
mPaintedLayer
Stringify
(
aOldValidRegion
)
.
c_str
(
)
)
;
bool
repeat
=
false
;
bool
isBufferChanged
=
false
;
nsIntRegion
remainingInvalidRegion
=
aInvalidRegion
;
nsIntRegion
updatedValidRegion
=
aValidRegion
;
do
{
nsIntRegion
regionToPaint
;
repeat
=
ComputeProgressiveUpdateRegion
(
remainingInvalidRegion
aOldValidRegion
regionToPaint
aPaintData
repeat
)
;
TILING_LOG
(
"
TILING
%
p
:
Progressive
update
computed
paint
region
%
s
repeat
%
d
\
n
"
&
mPaintedLayer
Stringify
(
regionToPaint
)
.
c_str
(
)
repeat
)
;
if
(
regionToPaint
.
IsEmpty
(
)
)
{
break
;
}
isBufferChanged
=
true
;
aOutDrawnRegion
.
OrWith
(
regionToPaint
)
;
updatedValidRegion
.
OrWith
(
regionToPaint
)
;
nsIntRegion
validOrStale
;
validOrStale
.
Or
(
updatedValidRegion
aOldValidRegion
)
;
PaintThebes
(
validOrStale
regionToPaint
remainingInvalidRegion
aCallback
aCallbackData
TilePaintFlags
:
:
Progressive
)
;
remainingInvalidRegion
.
SubOut
(
regionToPaint
)
;
}
while
(
repeat
)
;
TILING_LOG
(
"
TILING
%
p
:
Progressive
update
final
valid
region
%
s
buffer
changed
%
d
\
n
"
&
mPaintedLayer
Stringify
(
updatedValidRegion
)
.
c_str
(
)
isBufferChanged
)
;
TILING_LOG
(
"
TILING
%
p
:
Progressive
update
final
invalid
region
%
s
\
n
"
&
mPaintedLayer
Stringify
(
remainingInvalidRegion
)
.
c_str
(
)
)
;
return
isBufferChanged
;
}
void
TiledContentClient
:
:
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
{
aStream
<
<
aPrefix
;
aStream
<
<
nsPrintfCString
(
"
%
sTiledContentClient
(
0x
%
p
)
"
mName
this
)
.
get
(
)
;
}
void
TiledContentClient
:
:
Dump
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
bool
aDumpHtml
TextureDumpMode
aCompress
)
{
GetTiledBuffer
(
)
-
>
Dump
(
aStream
aPrefix
aDumpHtml
aCompress
)
;
}
void
BasicTiledLayerPaintData
:
:
ResetPaintData
(
)
{
mLowPrecisionPaintCount
=
0
;
mPaintFinished
=
false
;
mHasTransformAnimation
=
false
;
mCompositionBounds
.
SetEmpty
(
)
;
mCriticalDisplayPort
=
Nothing
(
)
;
}
}
}
