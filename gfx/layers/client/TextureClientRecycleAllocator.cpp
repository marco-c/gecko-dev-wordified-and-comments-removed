#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
TextureClientRecycleAllocator
.
h
"
namespace
mozilla
{
namespace
layers
{
class
TextureClientHolder
{
~
TextureClientHolder
(
)
{
}
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
TextureClientHolder
)
explicit
TextureClientHolder
(
TextureClient
*
aClient
)
:
mTextureClient
(
aClient
)
{
}
TextureClient
*
GetTextureClient
(
)
{
return
mTextureClient
;
}
void
ClearTextureClient
(
)
{
mTextureClient
=
nullptr
;
}
protected
:
RefPtr
<
TextureClient
>
mTextureClient
;
}
;
TextureClientRecycleAllocator
:
:
TextureClientRecycleAllocator
(
CompositableForwarder
*
aAllocator
)
:
mSurfaceAllocator
(
aAllocator
)
mMaxPooledSize
(
kMaxPooledSized
)
mLock
(
"
TextureClientRecycleAllocatorImp
.
mLock
"
)
{
}
TextureClientRecycleAllocator
:
:
~
TextureClientRecycleAllocator
(
)
{
MutexAutoLock
lock
(
mLock
)
;
while
(
!
mPooledClients
.
empty
(
)
)
{
mPooledClients
.
pop
(
)
;
}
MOZ_ASSERT
(
mInUseClients
.
empty
(
)
)
;
}
void
TextureClientRecycleAllocator
:
:
SetMaxPoolSize
(
uint32_t
aMax
)
{
mMaxPooledSize
=
aMax
;
}
class
TextureClientRecycleTask
:
public
Task
{
public
:
explicit
TextureClientRecycleTask
(
TextureClient
*
aClient
TextureFlags
aFlags
)
:
mTextureClient
(
aClient
)
mFlags
(
aFlags
)
{
}
virtual
void
Run
(
)
override
{
mTextureClient
-
>
RecycleTexture
(
mFlags
)
;
}
private
:
RefPtr
<
TextureClient
>
mTextureClient
;
TextureFlags
mFlags
;
}
;
already_AddRefed
<
TextureClient
>
TextureClientRecycleAllocator
:
:
CreateOrRecycle
(
gfx
:
:
SurfaceFormat
aFormat
gfx
:
:
IntSize
aSize
BackendSelector
aSelector
TextureFlags
aTextureFlags
TextureAllocationFlags
aAllocFlags
)
{
MOZ_ASSERT
(
aAllocFlags
=
=
TextureAllocationFlags
:
:
ALLOC_DEFAULT
|
|
aAllocFlags
=
=
TextureAllocationFlags
:
:
ALLOC_DISALLOW_BUFFERTEXTURECLIENT
)
;
MOZ_ASSERT
(
!
(
aTextureFlags
&
TextureFlags
:
:
RECYCLE
)
)
;
aTextureFlags
=
aTextureFlags
|
TextureFlags
:
:
RECYCLE
;
RefPtr
<
TextureClientHolder
>
textureHolder
;
{
MutexAutoLock
lock
(
mLock
)
;
if
(
!
mPooledClients
.
empty
(
)
)
{
textureHolder
=
mPooledClients
.
top
(
)
;
mPooledClients
.
pop
(
)
;
Task
*
task
=
nullptr
;
if
(
textureHolder
-
>
GetTextureClient
(
)
-
>
GetFormat
(
)
!
=
aFormat
|
|
textureHolder
-
>
GetTextureClient
(
)
-
>
GetSize
(
)
!
=
aSize
)
{
task
=
new
TextureClientReleaseTask
(
textureHolder
-
>
GetTextureClient
(
)
)
;
textureHolder
-
>
ClearTextureClient
(
)
;
textureHolder
=
nullptr
;
}
else
{
task
=
new
TextureClientRecycleTask
(
textureHolder
-
>
GetTextureClient
(
)
aTextureFlags
)
;
}
mSurfaceAllocator
-
>
GetMessageLoop
(
)
-
>
PostTask
(
FROM_HERE
task
)
;
}
}
if
(
!
textureHolder
)
{
RefPtr
<
TextureClient
>
texture
=
Allocate
(
aFormat
aSize
aSelector
aTextureFlags
aAllocFlags
)
;
if
(
!
texture
)
{
return
nullptr
;
}
textureHolder
=
new
TextureClientHolder
(
texture
)
;
}
{
MutexAutoLock
lock
(
mLock
)
;
MOZ_ASSERT
(
mInUseClients
.
find
(
textureHolder
-
>
GetTextureClient
(
)
)
=
=
mInUseClients
.
end
(
)
)
;
mInUseClients
[
textureHolder
-
>
GetTextureClient
(
)
]
=
textureHolder
;
}
RefPtr
<
TextureClient
>
client
(
textureHolder
-
>
GetTextureClient
(
)
)
;
client
-
>
SetRecycleAllocator
(
this
)
;
return
client
.
forget
(
)
;
}
already_AddRefed
<
TextureClient
>
TextureClientRecycleAllocator
:
:
Allocate
(
gfx
:
:
SurfaceFormat
aFormat
gfx
:
:
IntSize
aSize
BackendSelector
aSelector
TextureFlags
aTextureFlags
TextureAllocationFlags
aAllocFlags
)
{
return
TextureClient
:
:
CreateForDrawing
(
mSurfaceAllocator
aFormat
aSize
aSelector
aTextureFlags
aAllocFlags
)
;
}
void
TextureClientRecycleAllocator
:
:
RecycleTextureClient
(
TextureClient
*
aClient
)
{
RefPtr
<
TextureClientRecycleAllocator
>
kungFuDeathGrip
(
this
)
;
aClient
-
>
SetRecycleAllocator
(
nullptr
)
;
RefPtr
<
TextureClientHolder
>
textureHolder
;
{
MutexAutoLock
lock
(
mLock
)
;
if
(
mInUseClients
.
find
(
aClient
)
!
=
mInUseClients
.
end
(
)
)
{
textureHolder
=
mInUseClients
[
aClient
]
;
if
(
mPooledClients
.
size
(
)
<
mMaxPooledSize
)
{
mPooledClients
.
push
(
textureHolder
)
;
}
mInUseClients
.
erase
(
aClient
)
;
}
}
}
}
}
