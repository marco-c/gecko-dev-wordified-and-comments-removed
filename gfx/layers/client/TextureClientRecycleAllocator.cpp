#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
layers
/
CompositableForwarder
.
h
"
#
include
"
TextureClientRecycleAllocator
.
h
"
namespace
mozilla
{
namespace
layers
{
class
TextureClientHolder
{
~
TextureClientHolder
(
)
{
}
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
TextureClientHolder
)
explicit
TextureClientHolder
(
TextureClient
*
aClient
)
:
mTextureClient
(
aClient
)
{
}
TextureClient
*
GetTextureClient
(
)
{
return
mTextureClient
;
}
void
ClearTextureClient
(
)
{
mTextureClient
=
nullptr
;
}
protected
:
RefPtr
<
TextureClient
>
mTextureClient
;
}
;
class
DefaultTextureClientAllocationHelper
:
public
ITextureClientAllocationHelper
{
public
:
DefaultTextureClientAllocationHelper
(
TextureClientRecycleAllocator
*
aAllocator
gfx
:
:
SurfaceFormat
aFormat
gfx
:
:
IntSize
aSize
BackendSelector
aSelector
TextureFlags
aTextureFlags
TextureAllocationFlags
aAllocationFlags
)
:
ITextureClientAllocationHelper
(
aFormat
aSize
aSelector
aTextureFlags
aAllocationFlags
)
mAllocator
(
aAllocator
)
{
}
bool
IsCompatible
(
TextureClient
*
aTextureClient
)
override
{
if
(
aTextureClient
-
>
GetFormat
(
)
!
=
mFormat
|
|
aTextureClient
-
>
GetSize
(
)
!
=
mSize
)
{
return
false
;
}
return
true
;
}
already_AddRefed
<
TextureClient
>
Allocate
(
CompositableForwarder
*
aAllocator
)
override
{
return
mAllocator
-
>
Allocate
(
mFormat
mSize
mSelector
mTextureFlags
mAllocationFlags
)
;
}
protected
:
TextureClientRecycleAllocator
*
mAllocator
;
}
;
TextureClientRecycleAllocator
:
:
TextureClientRecycleAllocator
(
CompositableForwarder
*
aAllocator
)
:
mSurfaceAllocator
(
aAllocator
)
mMaxPooledSize
(
kMaxPooledSized
)
mLock
(
"
TextureClientRecycleAllocatorImp
.
mLock
"
)
{
}
TextureClientRecycleAllocator
:
:
~
TextureClientRecycleAllocator
(
)
{
MutexAutoLock
lock
(
mLock
)
;
while
(
!
mPooledClients
.
empty
(
)
)
{
mPooledClients
.
pop
(
)
;
}
MOZ_ASSERT
(
mInUseClients
.
empty
(
)
)
;
}
void
TextureClientRecycleAllocator
:
:
SetMaxPoolSize
(
uint32_t
aMax
)
{
mMaxPooledSize
=
aMax
;
}
class
TextureClientRecycleTask
:
public
Runnable
{
public
:
explicit
TextureClientRecycleTask
(
TextureClient
*
aClient
TextureFlags
aFlags
)
:
mTextureClient
(
aClient
)
mFlags
(
aFlags
)
{
}
NS_IMETHOD
Run
(
)
override
{
mTextureClient
-
>
RecycleTexture
(
mFlags
)
;
return
NS_OK
;
}
private
:
RefPtr
<
TextureClient
>
mTextureClient
;
TextureFlags
mFlags
;
}
;
already_AddRefed
<
TextureClient
>
TextureClientRecycleAllocator
:
:
CreateOrRecycle
(
gfx
:
:
SurfaceFormat
aFormat
gfx
:
:
IntSize
aSize
BackendSelector
aSelector
TextureFlags
aTextureFlags
TextureAllocationFlags
aAllocFlags
)
{
MOZ_ASSERT
(
!
(
aTextureFlags
&
TextureFlags
:
:
RECYCLE
)
)
;
DefaultTextureClientAllocationHelper
helper
(
this
aFormat
aSize
aSelector
aTextureFlags
aAllocFlags
)
;
return
CreateOrRecycle
(
helper
)
;
}
already_AddRefed
<
TextureClient
>
TextureClientRecycleAllocator
:
:
CreateOrRecycle
(
ITextureClientAllocationHelper
&
aHelper
)
{
MOZ_ASSERT
(
aHelper
.
mAllocationFlags
=
=
TextureAllocationFlags
:
:
ALLOC_DEFAULT
|
|
aHelper
.
mAllocationFlags
=
=
TextureAllocationFlags
:
:
ALLOC_DISALLOW_BUFFERTEXTURECLIENT
|
|
aHelper
.
mAllocationFlags
=
=
TextureAllocationFlags
:
:
ALLOC_FOR_OUT_OF_BAND_CONTENT
|
|
aHelper
.
mAllocationFlags
=
=
TextureAllocationFlags
:
:
ALLOC_MANUAL_SYNCHRONIZATION
)
;
MOZ_ASSERT
(
aHelper
.
mTextureFlags
&
TextureFlags
:
:
RECYCLE
)
;
RefPtr
<
TextureClientHolder
>
textureHolder
;
{
MutexAutoLock
lock
(
mLock
)
;
if
(
!
mPooledClients
.
empty
(
)
)
{
textureHolder
=
mPooledClients
.
top
(
)
;
mPooledClients
.
pop
(
)
;
RefPtr
<
Runnable
>
task
;
if
(
!
aHelper
.
IsCompatible
(
textureHolder
-
>
GetTextureClient
(
)
)
)
{
task
=
new
TextureClientReleaseTask
(
textureHolder
-
>
GetTextureClient
(
)
)
;
textureHolder
-
>
ClearTextureClient
(
)
;
textureHolder
=
nullptr
;
}
else
{
task
=
new
TextureClientRecycleTask
(
textureHolder
-
>
GetTextureClient
(
)
aHelper
.
mTextureFlags
)
;
}
mSurfaceAllocator
-
>
GetMessageLoop
(
)
-
>
PostTask
(
task
.
forget
(
)
)
;
}
}
if
(
!
textureHolder
)
{
RefPtr
<
TextureClient
>
texture
=
aHelper
.
Allocate
(
mSurfaceAllocator
)
;
if
(
!
texture
)
{
return
nullptr
;
}
textureHolder
=
new
TextureClientHolder
(
texture
)
;
}
{
MutexAutoLock
lock
(
mLock
)
;
MOZ_ASSERT
(
mInUseClients
.
find
(
textureHolder
-
>
GetTextureClient
(
)
)
=
=
mInUseClients
.
end
(
)
)
;
mInUseClients
[
textureHolder
-
>
GetTextureClient
(
)
]
=
textureHolder
;
}
RefPtr
<
TextureClient
>
client
(
textureHolder
-
>
GetTextureClient
(
)
)
;
client
-
>
SetRecycleAllocator
(
this
)
;
return
client
.
forget
(
)
;
}
already_AddRefed
<
TextureClient
>
TextureClientRecycleAllocator
:
:
Allocate
(
gfx
:
:
SurfaceFormat
aFormat
gfx
:
:
IntSize
aSize
BackendSelector
aSelector
TextureFlags
aTextureFlags
TextureAllocationFlags
aAllocFlags
)
{
return
TextureClient
:
:
CreateForDrawing
(
mSurfaceAllocator
aFormat
aSize
aSelector
aTextureFlags
aAllocFlags
)
;
}
void
TextureClientRecycleAllocator
:
:
ShrinkToMinimumSize
(
)
{
MutexAutoLock
lock
(
mLock
)
;
while
(
!
mPooledClients
.
empty
(
)
)
{
mPooledClients
.
pop
(
)
;
}
}
void
TextureClientRecycleAllocator
:
:
RecycleTextureClient
(
TextureClient
*
aClient
)
{
RefPtr
<
TextureClientRecycleAllocator
>
kungFuDeathGrip
(
this
)
;
aClient
-
>
SetRecycleAllocator
(
nullptr
)
;
RefPtr
<
TextureClientHolder
>
textureHolder
;
{
MutexAutoLock
lock
(
mLock
)
;
if
(
mInUseClients
.
find
(
aClient
)
!
=
mInUseClients
.
end
(
)
)
{
textureHolder
=
mInUseClients
[
aClient
]
;
if
(
mPooledClients
.
size
(
)
<
mMaxPooledSize
)
{
mPooledClients
.
push
(
textureHolder
)
;
}
mInUseClients
.
erase
(
aClient
)
;
}
}
}
}
}
