#
include
"
mozilla
/
layers
/
ContentClient
.
h
"
#
include
"
BasicLayers
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxEnv
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
gfxPoint
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
ipc
/
ShadowLayers
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
BasePoint
.
h
"
#
include
"
mozilla
/
gfx
/
BaseSize
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
LayerManagerComposite
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
PaintThread
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
ifdef
XP_WIN
#
include
"
gfxWindowsPlatform
.
h
"
#
endif
#
ifdef
MOZ_WIDGET_GTK
#
include
"
gfxPlatformGtk
.
h
"
#
endif
#
include
"
ReadbackLayer
.
h
"
#
include
<
utility
>
#
include
<
vector
>
using
namespace
std
;
namespace
mozilla
{
using
namespace
gfx
;
namespace
layers
{
static
TextureFlags
TextureFlagsForContentClientFlags
(
uint32_t
aBufferFlags
)
{
TextureFlags
result
=
TextureFlags
:
:
NO_FLAGS
;
if
(
aBufferFlags
&
ContentClient
:
:
BUFFER_COMPONENT_ALPHA
)
{
result
|
=
TextureFlags
:
:
COMPONENT_ALPHA
;
}
return
result
;
}
static
IntRect
ComputeBufferRect
(
const
IntRect
&
aRequestedRect
)
{
IntRect
rect
(
aRequestedRect
)
;
rect
.
SetWidth
(
std
:
:
max
(
aRequestedRect
.
Width
(
)
8
)
)
;
return
rect
;
}
already_AddRefed
<
ContentClient
>
ContentClient
:
:
CreateContentClient
(
CompositableForwarder
*
aForwarder
)
{
LayersBackend
backend
=
aForwarder
-
>
GetCompositorBackendType
(
)
;
if
(
backend
!
=
LayersBackend
:
:
LAYERS_OPENGL
&
&
backend
!
=
LayersBackend
:
:
LAYERS_D3D11
&
&
backend
!
=
LayersBackend
:
:
LAYERS_WR
&
&
backend
!
=
LayersBackend
:
:
LAYERS_BASIC
)
{
return
nullptr
;
}
bool
useDoubleBuffering
=
false
;
#
ifdef
XP_WIN
if
(
backend
=
=
LayersBackend
:
:
LAYERS_D3D11
)
{
useDoubleBuffering
=
gfxWindowsPlatform
:
:
GetPlatform
(
)
-
>
IsDirect2DBackend
(
)
;
}
else
#
endif
#
ifdef
MOZ_WIDGET_GTK
if
(
!
gfxPlatformGtk
:
:
GetPlatform
(
)
-
>
UseImageOffscreenSurfaces
(
)
|
|
!
gfxVars
:
:
UseXRender
(
)
)
#
endif
{
useDoubleBuffering
=
backend
=
=
LayersBackend
:
:
LAYERS_BASIC
;
}
if
(
useDoubleBuffering
|
|
gfxEnv
:
:
ForceDoubleBuffering
(
)
)
{
return
MakeAndAddRef
<
ContentClientDoubleBuffered
>
(
aForwarder
)
;
}
return
MakeAndAddRef
<
ContentClientSingleBuffered
>
(
aForwarder
)
;
}
void
ContentClient
:
:
Clear
(
)
{
mBuffer
=
nullptr
;
}
ContentClient
:
:
PaintState
ContentClient
:
:
BeginPaint
(
PaintedLayer
*
aLayer
uint32_t
aFlags
)
{
PaintState
result
;
BufferDecision
dest
=
CalculateBufferForPaint
(
aLayer
aFlags
)
;
result
.
mContentType
=
dest
.
mBufferContentType
;
if
(
!
dest
.
mCanKeepBufferContents
)
{
MOZ_ASSERT
(
!
dest
.
mCanReuseBuffer
)
;
MOZ_ASSERT
(
dest
.
mValidRegion
.
IsEmpty
(
)
)
;
result
.
mRegionToInvalidate
=
aLayer
-
>
GetValidRegion
(
)
;
#
if
defined
(
MOZ_DUMP_PAINTING
)
if
(
nsLayoutUtils
:
:
InvalidationDebuggingIsEnabled
(
)
)
{
if
(
result
.
mContentType
!
=
mBuffer
-
>
GetContentType
(
)
)
{
printf_stderr
(
"
Invalidating
entire
rotated
buffer
(
layer
%
p
)
:
content
type
changed
\
n
"
aLayer
)
;
}
else
if
(
(
dest
.
mBufferMode
=
=
SurfaceMode
:
:
SURFACE_COMPONENT_ALPHA
)
!
=
mBuffer
-
>
HaveBufferOnWhite
(
)
)
{
printf_stderr
(
"
Invalidating
entire
rotated
buffer
(
layer
%
p
)
:
component
alpha
changed
\
n
"
aLayer
)
;
}
}
#
endif
Clear
(
)
;
}
result
.
mRegionToDraw
.
Sub
(
dest
.
mNeededRegion
dest
.
mValidRegion
)
;
if
(
result
.
mRegionToDraw
.
IsEmpty
(
)
)
return
result
;
bool
canHaveRotation
=
gfxPlatform
:
:
BufferRotationEnabled
(
)
&
&
!
(
aFlags
&
(
PAINT_WILL_RESAMPLE
|
PAINT_NO_ROTATION
)
)
&
&
!
(
aLayer
-
>
Manager
(
)
-
>
AsWebRenderLayerManager
(
)
)
;
bool
canDrawRotated
=
aFlags
&
PAINT_CAN_DRAW_ROTATED
;
bool
asyncPaint
=
(
aFlags
&
PAINT_ASYNC
)
;
IntRect
drawBounds
=
result
.
mRegionToDraw
.
GetBounds
(
)
;
OpenMode
lockMode
=
asyncPaint
?
OpenMode
:
:
OPEN_READ_WRITE_ASYNC
:
OpenMode
:
:
OPEN_READ_WRITE
;
if
(
asyncPaint
)
{
result
.
mBufferState
=
new
CapturedBufferState
(
)
;
}
if
(
mBuffer
)
{
if
(
mBuffer
-
>
Lock
(
lockMode
)
)
{
Maybe
<
CapturedBufferState
:
:
Copy
>
bufferFinalize
=
FinalizeFrame
(
result
.
mRegionToDraw
)
;
if
(
asyncPaint
)
{
result
.
mBufferState
-
>
mBufferFinalize
=
std
:
:
move
(
bufferFinalize
)
;
}
else
if
(
bufferFinalize
)
{
bufferFinalize
-
>
CopyBuffer
(
)
;
}
}
else
{
result
.
mRegionToDraw
=
dest
.
mNeededRegion
;
dest
.
mCanReuseBuffer
=
false
;
Clear
(
)
;
}
}
if
(
dest
.
mCanReuseBuffer
)
{
MOZ_ASSERT
(
mBuffer
)
;
bool
canReuseBuffer
=
false
;
auto
newParameters
=
mBuffer
-
>
AdjustedParameters
(
dest
.
mBufferRect
)
;
Maybe
<
CapturedBufferState
:
:
Unrotate
>
bufferUnrotate
=
Nothing
(
)
;
if
(
(
!
canHaveRotation
&
&
newParameters
.
IsRotated
(
)
)
|
|
(
!
canDrawRotated
&
&
newParameters
.
RectWrapsBuffer
(
drawBounds
)
)
)
{
bufferUnrotate
=
Some
(
CapturedBufferState
:
:
Unrotate
{
newParameters
mBuffer
-
>
ShallowCopy
(
)
}
)
;
}
if
(
asyncPaint
)
{
if
(
!
bufferUnrotate
|
|
mBuffer
-
>
BufferRotation
(
)
=
=
IntPoint
(
0
0
)
)
{
result
.
mBufferState
-
>
mBufferUnrotate
=
std
:
:
move
(
bufferUnrotate
)
;
if
(
result
.
mBufferState
-
>
mBufferUnrotate
)
{
newParameters
.
SetUnrotated
(
)
;
}
mBuffer
-
>
SetParameters
(
newParameters
)
;
canReuseBuffer
=
true
;
}
}
else
{
if
(
!
bufferUnrotate
|
|
bufferUnrotate
-
>
UnrotateBuffer
(
)
)
{
if
(
bufferUnrotate
)
{
newParameters
.
SetUnrotated
(
)
;
}
mBuffer
-
>
SetParameters
(
newParameters
)
;
canReuseBuffer
=
true
;
}
}
if
(
!
canReuseBuffer
)
{
dest
.
mBufferRect
=
ComputeBufferRect
(
dest
.
mNeededRegion
.
GetBounds
(
)
)
;
dest
.
mCanReuseBuffer
=
false
;
}
}
MOZ_ASSERT
(
dest
.
mBufferRect
.
Contains
(
result
.
mRegionToDraw
.
GetBounds
(
)
)
)
;
NS_ASSERTION
(
!
(
aFlags
&
PAINT_WILL_RESAMPLE
)
|
|
dest
.
mBufferRect
=
=
dest
.
mNeededRegion
.
GetBounds
(
)
"
If
we
'
re
resampling
we
need
to
validate
the
entire
buffer
"
)
;
if
(
!
dest
.
mCanReuseBuffer
)
{
uint32_t
bufferFlags
=
0
;
if
(
dest
.
mBufferMode
=
=
SurfaceMode
:
:
SURFACE_COMPONENT_ALPHA
)
{
bufferFlags
|
=
BUFFER_COMPONENT_ALPHA
;
}
RefPtr
<
RotatedBuffer
>
newBuffer
=
CreateBuffer
(
result
.
mContentType
dest
.
mBufferRect
bufferFlags
)
;
if
(
!
newBuffer
)
{
if
(
Factory
:
:
ReasonableSurfaceSize
(
IntSize
(
dest
.
mBufferRect
.
Width
(
)
dest
.
mBufferRect
.
Height
(
)
)
)
)
{
gfxCriticalNote
<
<
"
Failed
buffer
for
"
<
<
dest
.
mBufferRect
.
X
(
)
<
<
"
"
<
<
dest
.
mBufferRect
.
Y
(
)
<
<
"
"
<
<
dest
.
mBufferRect
.
Width
(
)
<
<
"
"
<
<
dest
.
mBufferRect
.
Height
(
)
;
}
Clear
(
)
;
return
result
;
}
if
(
!
newBuffer
-
>
Lock
(
lockMode
)
)
{
gfxCriticalNote
<
<
"
Failed
to
lock
new
back
buffer
.
"
;
Clear
(
)
;
return
result
;
}
if
(
mBuffer
)
{
if
(
mBuffer
-
>
IsLocked
(
)
)
{
mBuffer
-
>
Unlock
(
)
;
}
nsIntRegion
updateRegion
=
newBuffer
-
>
BufferRect
(
)
;
updateRegion
.
Sub
(
updateRegion
result
.
mRegionToDraw
)
;
if
(
!
updateRegion
.
IsEmpty
(
)
)
{
auto
bufferInitialize
=
CapturedBufferState
:
:
Copy
{
mBuffer
-
>
ShallowCopy
(
)
newBuffer
-
>
ShallowCopy
(
)
updateRegion
.
GetBounds
(
)
}
;
if
(
asyncPaint
)
{
result
.
mBufferState
-
>
mBufferInitialize
=
Some
(
std
:
:
move
(
bufferInitialize
)
)
;
}
else
{
if
(
!
bufferInitialize
.
CopyBuffer
(
)
)
{
gfxCriticalNote
<
<
"
Failed
to
copy
front
buffer
to
back
buffer
.
"
;
return
result
;
}
}
}
}
Clear
(
)
;
mBuffer
=
newBuffer
;
}
NS_ASSERTION
(
canHaveRotation
|
|
mBuffer
-
>
BufferRotation
(
)
=
=
IntPoint
(
0
0
)
"
Rotation
disabled
but
we
have
nonzero
rotation
?
"
)
;
nsIntRegion
invalidate
;
invalidate
.
Sub
(
aLayer
-
>
GetValidRegion
(
)
dest
.
mBufferRect
)
;
result
.
mRegionToInvalidate
.
Or
(
result
.
mRegionToInvalidate
invalidate
)
;
result
.
mClip
=
DrawRegionClip
:
:
DRAW
;
result
.
mMode
=
dest
.
mBufferMode
;
return
result
;
}
DrawTarget
*
ContentClient
:
:
BorrowDrawTargetForPainting
(
ContentClient
:
:
PaintState
&
aPaintState
RotatedBuffer
:
:
DrawIterator
*
aIter
)
{
RefPtr
<
CapturedPaintState
>
capturedState
=
ContentClient
:
:
BorrowDrawTargetForRecording
(
aPaintState
aIter
true
)
;
if
(
!
capturedState
)
{
return
nullptr
;
}
if
(
!
ContentClient
:
:
PrepareDrawTargetForPainting
(
capturedState
)
)
{
return
nullptr
;
}
return
capturedState
-
>
mTargetDual
;
}
nsIntRegion
ExpandDrawRegion
(
ContentClient
:
:
PaintState
&
aPaintState
RotatedBuffer
:
:
DrawIterator
*
aIter
BackendType
aBackendType
)
{
nsIntRegion
*
drawPtr
=
&
aPaintState
.
mRegionToDraw
;
if
(
aIter
)
{
aIter
-
>
mDrawRegion
.
And
(
aIter
-
>
mDrawRegion
aPaintState
.
mRegionToDraw
)
;
drawPtr
=
&
aIter
-
>
mDrawRegion
;
}
if
(
aBackendType
=
=
BackendType
:
:
DIRECT2D
|
|
aBackendType
=
=
BackendType
:
:
DIRECT2D1_1
)
{
drawPtr
-
>
SimplifyOutwardByArea
(
100
*
100
)
;
}
return
*
drawPtr
;
}
RefPtr
<
CapturedPaintState
>
ContentClient
:
:
BorrowDrawTargetForRecording
(
ContentClient
:
:
PaintState
&
aPaintState
RotatedBuffer
:
:
DrawIterator
*
aIter
bool
aSetTransform
)
{
if
(
aPaintState
.
mMode
=
=
SurfaceMode
:
:
SURFACE_NONE
|
|
!
mBuffer
)
{
return
nullptr
;
}
Matrix
transform
;
DrawTarget
*
result
=
mBuffer
-
>
BorrowDrawTargetForQuadrantUpdate
(
aPaintState
.
mRegionToDraw
.
GetBounds
(
)
RotatedBuffer
:
:
BUFFER_BOTH
aIter
aSetTransform
&
transform
)
;
if
(
!
result
)
{
return
nullptr
;
}
nsIntRegion
regionToDraw
=
ExpandDrawRegion
(
aPaintState
aIter
result
-
>
GetBackendType
(
)
)
;
RefPtr
<
CapturedPaintState
>
state
=
new
CapturedPaintState
(
regionToDraw
result
mBuffer
-
>
GetDTBuffer
(
)
mBuffer
-
>
GetDTBufferOnWhite
(
)
transform
aPaintState
.
mMode
aPaintState
.
mContentType
)
;
return
state
;
}
void
ContentClient
:
:
ReturnDrawTarget
(
gfx
:
:
DrawTarget
*
&
aReturned
)
{
mBuffer
-
>
ReturnDrawTarget
(
aReturned
)
;
}
bool
ContentClient
:
:
PrepareDrawTargetForPainting
(
CapturedPaintState
*
aState
)
{
MOZ_ASSERT
(
aState
)
;
RefPtr
<
DrawTarget
>
target
=
aState
-
>
mTarget
;
RefPtr
<
DrawTarget
>
whiteTarget
=
aState
-
>
mTargetOnWhite
;
if
(
aState
-
>
mSurfaceMode
=
=
SurfaceMode
:
:
SURFACE_COMPONENT_ALPHA
)
{
if
(
!
target
|
|
!
target
-
>
IsValid
(
)
|
|
!
whiteTarget
|
|
!
whiteTarget
-
>
IsValid
(
)
)
{
return
false
;
}
for
(
auto
iter
=
aState
-
>
mRegionToDraw
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
IntRect
&
rect
=
iter
.
Get
(
)
;
target
-
>
FillRect
(
Rect
(
rect
.
X
(
)
rect
.
Y
(
)
rect
.
Width
(
)
rect
.
Height
(
)
)
ColorPattern
(
Color
(
0
.
0
0
.
0
0
.
0
1
.
0
)
)
)
;
whiteTarget
-
>
FillRect
(
Rect
(
rect
.
X
(
)
rect
.
Y
(
)
rect
.
Width
(
)
rect
.
Height
(
)
)
ColorPattern
(
Color
(
1
.
0
1
.
0
1
.
0
1
.
0
)
)
)
;
}
}
else
if
(
aState
-
>
mContentType
=
=
gfxContentType
:
:
COLOR_ALPHA
&
&
target
-
>
IsValid
(
)
)
{
for
(
auto
iter
=
aState
-
>
mRegionToDraw
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
IntRect
&
rect
=
iter
.
Get
(
)
;
target
-
>
ClearRect
(
Rect
(
rect
.
X
(
)
rect
.
Y
(
)
rect
.
Width
(
)
rect
.
Height
(
)
)
)
;
}
}
return
true
;
}
ContentClient
:
:
BufferDecision
ContentClient
:
:
CalculateBufferForPaint
(
PaintedLayer
*
aLayer
uint32_t
aFlags
)
{
gfxContentType
layerContentType
=
aLayer
-
>
CanUseOpaqueSurface
(
)
?
gfxContentType
:
:
COLOR
:
gfxContentType
:
:
COLOR_ALPHA
;
SurfaceMode
mode
;
gfxContentType
contentType
;
IntRect
destBufferRect
;
nsIntRegion
neededRegion
;
nsIntRegion
validRegion
=
aLayer
-
>
GetValidRegion
(
)
;
bool
canReuseBuffer
=
!
!
mBuffer
;
bool
canKeepBufferContents
=
true
;
while
(
true
)
{
mode
=
aLayer
-
>
GetSurfaceMode
(
)
;
neededRegion
=
aLayer
-
>
GetVisibleRegion
(
)
.
ToUnknownRegion
(
)
;
canReuseBuffer
=
canReuseBuffer
&
&
ValidBufferSize
(
mBufferSizePolicy
mBuffer
-
>
BufferRect
(
)
.
Size
(
)
neededRegion
.
GetBounds
(
)
.
Size
(
)
)
;
contentType
=
layerContentType
;
if
(
canReuseBuffer
)
{
if
(
mBuffer
-
>
BufferRect
(
)
.
Contains
(
neededRegion
.
GetBounds
(
)
)
)
{
destBufferRect
=
mBuffer
-
>
BufferRect
(
)
;
}
else
if
(
neededRegion
.
GetBounds
(
)
.
Size
(
)
<
=
mBuffer
-
>
BufferRect
(
)
.
Size
(
)
)
{
destBufferRect
=
IntRect
(
neededRegion
.
GetBounds
(
)
.
TopLeft
(
)
mBuffer
-
>
BufferRect
(
)
.
Size
(
)
)
;
}
else
{
destBufferRect
=
neededRegion
.
GetBounds
(
)
;
}
}
else
{
destBufferRect
=
ComputeBufferRect
(
neededRegion
.
GetBounds
(
)
)
;
}
if
(
mode
=
=
SurfaceMode
:
:
SURFACE_COMPONENT_ALPHA
)
{
#
if
defined
(
MOZ_GFX_OPTIMIZE_MOBILE
)
mode
=
SurfaceMode
:
:
SURFACE_SINGLE_CHANNEL_ALPHA
;
#
else
if
(
!
aLayer
-
>
GetParent
(
)
|
|
!
aLayer
-
>
GetParent
(
)
-
>
SupportsComponentAlphaChildren
(
)
|
|
!
aLayer
-
>
AsShadowableLayer
(
)
|
|
!
aLayer
-
>
AsShadowableLayer
(
)
-
>
HasShadow
(
)
)
{
mode
=
SurfaceMode
:
:
SURFACE_SINGLE_CHANNEL_ALPHA
;
}
else
{
contentType
=
gfxContentType
:
:
COLOR
;
}
#
endif
}
if
(
(
aFlags
&
PAINT_WILL_RESAMPLE
)
&
&
(
!
neededRegion
.
GetBounds
(
)
.
IsEqualInterior
(
destBufferRect
)
|
|
neededRegion
.
GetNumRects
(
)
>
1
)
)
{
if
(
mode
=
=
SurfaceMode
:
:
SURFACE_OPAQUE
)
{
contentType
=
gfxContentType
:
:
COLOR_ALPHA
;
mode
=
SurfaceMode
:
:
SURFACE_SINGLE_CHANNEL_ALPHA
;
}
neededRegion
=
destBufferRect
;
}
bool
needsComponentAlpha
=
(
mode
=
=
SurfaceMode
:
:
SURFACE_COMPONENT_ALPHA
)
;
bool
backBufferChangedSurface
=
mBuffer
&
&
(
contentType
!
=
mBuffer
-
>
GetContentType
(
)
|
|
needsComponentAlpha
!
=
mBuffer
-
>
HaveBufferOnWhite
(
)
)
;
if
(
canKeepBufferContents
&
&
backBufferChangedSurface
)
{
canReuseBuffer
=
false
;
canKeepBufferContents
=
false
;
validRegion
.
SetEmpty
(
)
;
continue
;
}
break
;
}
NS_ASSERTION
(
destBufferRect
.
Contains
(
neededRegion
.
GetBounds
(
)
)
"
Destination
rect
doesn
'
t
contain
what
we
need
to
paint
"
)
;
BufferDecision
dest
;
dest
.
mNeededRegion
=
std
:
:
move
(
neededRegion
)
;
dest
.
mValidRegion
=
std
:
:
move
(
validRegion
)
;
dest
.
mBufferRect
=
destBufferRect
;
dest
.
mBufferMode
=
mode
;
dest
.
mBufferContentType
=
contentType
;
dest
.
mCanReuseBuffer
=
canReuseBuffer
;
dest
.
mCanKeepBufferContents
=
canKeepBufferContents
;
return
dest
;
}
bool
ContentClient
:
:
ValidBufferSize
(
BufferSizePolicy
aPolicy
const
gfx
:
:
IntSize
&
aBufferSize
const
gfx
:
:
IntSize
&
aVisibleBoundsSize
)
{
return
(
aVisibleBoundsSize
=
=
aBufferSize
|
|
(
SizedToVisibleBounds
!
=
aPolicy
&
&
aVisibleBoundsSize
<
aBufferSize
)
)
;
}
void
ContentClient
:
:
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
{
aStream
<
<
aPrefix
;
aStream
<
<
nsPrintfCString
(
"
ContentClient
(
0x
%
p
)
"
this
)
.
get
(
)
;
}
ContentClientBasic
:
:
ContentClientBasic
(
gfx
:
:
BackendType
aBackend
)
:
ContentClient
(
nullptr
ContainsVisibleBounds
)
mBackend
(
aBackend
)
{
}
void
ContentClientBasic
:
:
DrawTo
(
PaintedLayer
*
aLayer
gfx
:
:
DrawTarget
*
aTarget
float
aOpacity
gfx
:
:
CompositionOp
aOp
gfx
:
:
SourceSurface
*
aMask
const
gfx
:
:
Matrix
*
aMaskTransform
)
{
if
(
!
mBuffer
)
{
return
;
}
mBuffer
-
>
DrawTo
(
aLayer
aTarget
aOpacity
aOp
aMask
aMaskTransform
)
;
}
RefPtr
<
RotatedBuffer
>
ContentClientBasic
:
:
CreateBuffer
(
gfxContentType
aType
const
IntRect
&
aRect
uint32_t
aFlags
)
{
MOZ_ASSERT
(
!
(
aFlags
&
BUFFER_COMPONENT_ALPHA
)
)
;
if
(
aFlags
&
BUFFER_COMPONENT_ALPHA
)
{
gfxDevCrash
(
LogReason
:
:
AlphaWithBasicClient
)
<
<
"
Asking
basic
content
client
for
component
alpha
"
;
}
IntSize
size
(
aRect
.
Width
(
)
aRect
.
Height
(
)
)
;
RefPtr
<
gfx
:
:
DrawTarget
>
drawTarget
;
#
ifdef
XP_WIN
if
(
mBackend
=
=
BackendType
:
:
CAIRO
&
&
(
aType
=
=
gfxContentType
:
:
COLOR
|
|
aType
=
=
gfxContentType
:
:
COLOR_ALPHA
)
)
{
RefPtr
<
gfxASurface
>
surf
=
new
gfxWindowsSurface
(
size
aType
=
=
gfxContentType
:
:
COLOR
?
gfxImageFormat
:
:
X8R8G8B8_UINT32
:
gfxImageFormat
:
:
A8R8G8B8_UINT32
)
;
drawTarget
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateDrawTargetForSurface
(
surf
size
)
;
}
#
endif
if
(
!
drawTarget
)
{
drawTarget
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateDrawTargetForBackend
(
mBackend
size
gfxPlatform
:
:
GetPlatform
(
)
-
>
Optimal2DFormatForContent
(
aType
)
)
;
}
if
(
!
drawTarget
)
{
return
nullptr
;
}
return
new
DrawTargetRotatedBuffer
(
drawTarget
nullptr
aRect
IntPoint
(
0
0
)
)
;
}
RefPtr
<
CapturedPaintState
>
ContentClientBasic
:
:
BorrowDrawTargetForRecording
(
ContentClient
:
:
PaintState
&
aPaintState
RotatedBuffer
:
:
DrawIterator
*
aIter
bool
aSetTransform
)
{
return
nullptr
;
}
RefPtr
<
CapturedPaintState
>
ContentClientRemoteBuffer
:
:
BorrowDrawTargetForRecording
(
ContentClient
:
:
PaintState
&
aPaintState
RotatedBuffer
:
:
DrawIterator
*
aIter
bool
aSetTransform
)
{
RefPtr
<
CapturedPaintState
>
cps
=
ContentClient
:
:
BorrowDrawTargetForRecording
(
aPaintState
aIter
aSetTransform
)
;
if
(
!
cps
)
{
return
nullptr
;
}
RemoteRotatedBuffer
*
remoteBuffer
=
GetRemoteBuffer
(
)
;
cps
-
>
mTextureClient
=
remoteBuffer
-
>
GetClient
(
)
;
cps
-
>
mTextureClientOnWhite
=
remoteBuffer
-
>
GetClientOnWhite
(
)
;
return
cps
.
forget
(
)
;
}
class
RemoteBufferReadbackProcessor
:
public
TextureReadbackSink
{
public
:
RemoteBufferReadbackProcessor
(
nsTArray
<
ReadbackProcessor
:
:
Update
>
*
aReadbackUpdates
const
IntRect
&
aBufferRect
const
nsIntPoint
&
aBufferRotation
)
:
mReadbackUpdates
(
*
aReadbackUpdates
)
mBufferRect
(
aBufferRect
)
mBufferRotation
(
aBufferRotation
)
{
for
(
uint32_t
i
=
0
;
i
<
mReadbackUpdates
.
Length
(
)
;
+
+
i
)
{
mLayerRefs
.
push_back
(
mReadbackUpdates
[
i
]
.
mLayer
)
;
}
}
virtual
void
ProcessReadback
(
gfx
:
:
DataSourceSurface
*
aSourceSurface
)
override
{
SourceRotatedBuffer
rotBuffer
(
aSourceSurface
nullptr
mBufferRect
mBufferRotation
)
;
for
(
uint32_t
i
=
0
;
i
<
mReadbackUpdates
.
Length
(
)
;
+
+
i
)
{
ReadbackProcessor
:
:
Update
&
update
=
mReadbackUpdates
[
i
]
;
nsIntPoint
offset
=
update
.
mLayer
-
>
GetBackgroundLayerOffset
(
)
;
ReadbackSink
*
sink
=
update
.
mLayer
-
>
GetSink
(
)
;
if
(
!
sink
)
{
continue
;
}
if
(
!
aSourceSurface
)
{
sink
-
>
SetUnknown
(
update
.
mSequenceCounter
)
;
continue
;
}
RefPtr
<
DrawTarget
>
dt
=
sink
-
>
BeginUpdate
(
update
.
mUpdateRect
+
offset
update
.
mSequenceCounter
)
;
if
(
!
dt
)
{
continue
;
}
dt
-
>
SetTransform
(
Matrix
:
:
Translation
(
offset
.
x
offset
.
y
)
)
;
rotBuffer
.
DrawBufferWithRotation
(
dt
RotatedBuffer
:
:
BUFFER_BLACK
)
;
update
.
mLayer
-
>
GetSink
(
)
-
>
EndUpdate
(
update
.
mUpdateRect
+
offset
)
;
}
}
private
:
nsTArray
<
ReadbackProcessor
:
:
Update
>
mReadbackUpdates
;
vector
<
RefPtr
<
Layer
>
>
mLayerRefs
;
IntRect
mBufferRect
;
nsIntPoint
mBufferRotation
;
}
;
void
ContentClientRemoteBuffer
:
:
EndPaint
(
nsTArray
<
ReadbackProcessor
:
:
Update
>
*
aReadbackUpdates
)
{
MOZ_ASSERT
(
!
mBuffer
|
|
!
mBuffer
-
>
HaveBufferOnWhite
(
)
|
|
!
aReadbackUpdates
|
|
aReadbackUpdates
-
>
Length
(
)
=
=
0
)
;
RemoteRotatedBuffer
*
remoteBuffer
=
GetRemoteBuffer
(
)
;
if
(
remoteBuffer
&
&
remoteBuffer
-
>
IsLocked
(
)
)
{
if
(
aReadbackUpdates
&
&
aReadbackUpdates
-
>
Length
(
)
>
0
)
{
RefPtr
<
TextureReadbackSink
>
readbackSink
=
new
RemoteBufferReadbackProcessor
(
aReadbackUpdates
remoteBuffer
-
>
BufferRect
(
)
remoteBuffer
-
>
BufferRotation
(
)
)
;
remoteBuffer
-
>
GetClient
(
)
-
>
SetReadbackSink
(
readbackSink
)
;
}
remoteBuffer
-
>
Unlock
(
)
;
remoteBuffer
-
>
SyncWithObject
(
mForwarder
-
>
GetSyncObject
(
)
)
;
}
ContentClient
:
:
EndPaint
(
aReadbackUpdates
)
;
}
RefPtr
<
RotatedBuffer
>
ContentClientRemoteBuffer
:
:
CreateBuffer
(
gfxContentType
aType
const
IntRect
&
aRect
uint32_t
aFlags
)
{
MOZ_ASSERT
(
!
mIsNewBuffer
"
Bad
!
Did
we
create
a
buffer
twice
without
painting
?
"
)
;
gfx
:
:
SurfaceFormat
format
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
Optimal2DFormatForContent
(
aType
)
;
TextureFlags
textureFlags
=
TextureFlagsForContentClientFlags
(
aFlags
)
;
if
(
aFlags
&
BUFFER_COMPONENT_ALPHA
)
{
textureFlags
|
=
TextureFlags
:
:
COMPONENT_ALPHA
;
}
RefPtr
<
RotatedBuffer
>
buffer
=
CreateBufferInternal
(
aRect
format
textureFlags
)
;
if
(
!
buffer
)
{
return
nullptr
;
}
mIsNewBuffer
=
true
;
mTextureFlags
=
textureFlags
;
return
buffer
;
}
RefPtr
<
RotatedBuffer
>
ContentClientRemoteBuffer
:
:
CreateBufferInternal
(
const
gfx
:
:
IntRect
&
aRect
gfx
:
:
SurfaceFormat
aFormat
TextureFlags
aFlags
)
{
TextureAllocationFlags
textureAllocFlags
=
(
aFlags
&
TextureFlags
:
:
COMPONENT_ALPHA
)
?
TextureAllocationFlags
:
:
ALLOC_CLEAR_BUFFER_BLACK
:
TextureAllocationFlags
:
:
ALLOC_CLEAR_BUFFER
;
RefPtr
<
TextureClient
>
textureClient
=
CreateTextureClientForDrawing
(
aFormat
aRect
.
Size
(
)
BackendSelector
:
:
Content
aFlags
|
ExtraTextureFlags
(
)
|
TextureFlags
:
:
BLOCKING_READ_LOCK
textureAllocFlags
)
;
if
(
!
textureClient
|
|
!
AddTextureClient
(
textureClient
)
)
{
return
nullptr
;
}
RefPtr
<
TextureClient
>
textureClientOnWhite
;
if
(
aFlags
&
TextureFlags
:
:
COMPONENT_ALPHA
)
{
TextureAllocationFlags
allocFlags
=
ALLOC_CLEAR_BUFFER_WHITE
;
if
(
mForwarder
-
>
SupportsTextureDirectMapping
(
)
)
{
allocFlags
=
TextureAllocationFlags
(
allocFlags
|
ALLOC_ALLOW_DIRECT_MAPPING
)
;
}
textureClientOnWhite
=
textureClient
-
>
CreateSimilar
(
mForwarder
-
>
GetCompositorBackendType
(
)
aFlags
|
ExtraTextureFlags
(
)
allocFlags
)
;
if
(
!
textureClientOnWhite
|
|
!
AddTextureClient
(
textureClientOnWhite
)
)
{
return
nullptr
;
}
}
return
new
RemoteRotatedBuffer
(
textureClient
textureClientOnWhite
aRect
IntPoint
(
0
0
)
)
;
}
nsIntRegion
ContentClientRemoteBuffer
:
:
GetUpdatedRegion
(
const
nsIntRegion
&
aRegionToDraw
const
nsIntRegion
&
aVisibleRegion
)
{
nsIntRegion
updatedRegion
;
if
(
mIsNewBuffer
|
|
mBuffer
-
>
DidSelfCopy
(
)
)
{
updatedRegion
=
aVisibleRegion
.
GetBounds
(
)
;
mIsNewBuffer
=
false
;
}
else
{
updatedRegion
=
aRegionToDraw
;
}
MOZ_ASSERT
(
mBuffer
"
should
have
a
back
buffer
by
now
"
)
;
NS_ASSERTION
(
mBuffer
-
>
BufferRect
(
)
.
Contains
(
aRegionToDraw
.
GetBounds
(
)
)
"
Update
outside
of
buffer
rect
!
"
)
;
return
updatedRegion
;
}
void
ContentClientRemoteBuffer
:
:
Updated
(
const
nsIntRegion
&
aRegionToDraw
const
nsIntRegion
&
aVisibleRegion
)
{
nsIntRegion
updatedRegion
=
GetUpdatedRegion
(
aRegionToDraw
aVisibleRegion
)
;
RemoteRotatedBuffer
*
remoteBuffer
=
GetRemoteBuffer
(
)
;
MOZ_ASSERT
(
remoteBuffer
&
&
remoteBuffer
-
>
GetClient
(
)
)
;
if
(
remoteBuffer
-
>
HaveBufferOnWhite
(
)
)
{
mForwarder
-
>
UseComponentAlphaTextures
(
this
remoteBuffer
-
>
GetClient
(
)
remoteBuffer
-
>
GetClientOnWhite
(
)
)
;
}
else
{
AutoTArray
<
CompositableForwarder
:
:
TimedTextureClient
1
>
textures
;
CompositableForwarder
:
:
TimedTextureClient
*
t
=
textures
.
AppendElement
(
)
;
t
-
>
mTextureClient
=
remoteBuffer
-
>
GetClient
(
)
;
IntSize
size
=
remoteBuffer
-
>
GetClient
(
)
-
>
GetSize
(
)
;
t
-
>
mPictureRect
=
nsIntRect
(
0
0
size
.
width
size
.
height
)
;
GetForwarder
(
)
-
>
UseTextures
(
this
textures
)
;
}
mForwarder
-
>
UpdateTextureRegion
(
this
ThebesBufferData
(
remoteBuffer
-
>
BufferRect
(
)
remoteBuffer
-
>
BufferRotation
(
)
)
updatedRegion
)
;
SwapBuffers
(
updatedRegion
)
;
}
void
ContentClientRemoteBuffer
:
:
Dump
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
bool
aDumpHtml
TextureDumpMode
aCompress
)
{
RemoteRotatedBuffer
*
remoteBuffer
=
GetRemoteBuffer
(
)
;
if
(
!
aDumpHtml
)
{
aStream
<
<
"
\
n
"
<
<
aPrefix
<
<
"
Surface
:
"
;
}
CompositableClient
:
:
DumpTextureClient
(
aStream
remoteBuffer
?
remoteBuffer
-
>
GetClient
(
)
:
nullptr
aCompress
)
;
}
void
ContentClientDoubleBuffered
:
:
Dump
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
bool
aDumpHtml
TextureDumpMode
aCompress
)
{
if
(
!
aDumpHtml
)
{
aStream
<
<
"
\
n
"
<
<
aPrefix
<
<
"
Surface
:
"
;
}
CompositableClient
:
:
DumpTextureClient
(
aStream
mFrontBuffer
?
mFrontBuffer
-
>
GetClient
(
)
:
nullptr
aCompress
)
;
}
void
ContentClientDoubleBuffered
:
:
Clear
(
)
{
ContentClient
:
:
Clear
(
)
;
mFrontBuffer
=
nullptr
;
}
void
ContentClientDoubleBuffered
:
:
SwapBuffers
(
const
nsIntRegion
&
aFrontUpdatedRegion
)
{
mFrontUpdatedRegion
=
aFrontUpdatedRegion
;
RefPtr
<
RemoteRotatedBuffer
>
frontBuffer
=
mFrontBuffer
;
RefPtr
<
RemoteRotatedBuffer
>
backBuffer
=
GetRemoteBuffer
(
)
;
std
:
:
swap
(
frontBuffer
backBuffer
)
;
mFrontBuffer
=
frontBuffer
;
mBuffer
=
backBuffer
;
mFrontAndBackBufferDiffer
=
true
;
}
ContentClient
:
:
PaintState
ContentClientDoubleBuffered
:
:
BeginPaint
(
PaintedLayer
*
aLayer
uint32_t
aFlags
)
{
EnsureBackBufferIfFrontBuffer
(
)
;
mIsNewBuffer
=
false
;
if
(
!
mFrontBuffer
|
|
!
mBuffer
)
{
mFrontAndBackBufferDiffer
=
false
;
}
if
(
mFrontAndBackBufferDiffer
)
{
if
(
mFrontBuffer
-
>
DidSelfCopy
(
)
)
{
gfx
:
:
IntRect
backBufferRect
=
mBuffer
-
>
BufferRect
(
)
;
backBufferRect
.
MoveTo
(
mFrontBuffer
-
>
BufferRect
(
)
.
TopLeft
(
)
)
;
mBuffer
-
>
SetBufferRect
(
backBufferRect
)
;
mBuffer
-
>
SetBufferRotation
(
IntPoint
(
0
0
)
)
;
}
else
{
mBuffer
-
>
SetBufferRect
(
mFrontBuffer
-
>
BufferRect
(
)
)
;
mBuffer
-
>
SetBufferRotation
(
mFrontBuffer
-
>
BufferRotation
(
)
)
;
}
}
return
ContentClient
:
:
BeginPaint
(
aLayer
aFlags
)
;
}
Maybe
<
CapturedBufferState
:
:
Copy
>
ContentClientDoubleBuffered
:
:
FinalizeFrame
(
const
nsIntRegion
&
aRegionToDraw
)
{
if
(
!
mFrontAndBackBufferDiffer
)
{
MOZ_ASSERT
(
!
mFrontBuffer
|
|
!
mFrontBuffer
-
>
DidSelfCopy
(
)
"
If
the
front
buffer
did
a
self
copy
then
our
front
and
back
buffer
must
be
different
.
"
)
;
return
Nothing
(
)
;
}
MOZ_ASSERT
(
mFrontBuffer
&
&
mBuffer
)
;
if
(
!
mFrontBuffer
|
|
!
mBuffer
)
{
return
Nothing
(
)
;
}
MOZ_LAYERS_LOG
(
(
"
BasicShadowableThebes
(
%
p
)
:
reading
back
<
x
=
%
d
y
=
%
d
w
=
%
d
h
=
%
d
>
"
this
mFrontUpdatedRegion
.
GetBounds
(
)
.
X
(
)
mFrontUpdatedRegion
.
GetBounds
(
)
.
Y
(
)
mFrontUpdatedRegion
.
GetBounds
(
)
.
Width
(
)
mFrontUpdatedRegion
.
GetBounds
(
)
.
Height
(
)
)
)
;
mFrontAndBackBufferDiffer
=
false
;
nsIntRegion
updateRegion
=
mFrontUpdatedRegion
;
if
(
mFrontBuffer
-
>
DidSelfCopy
(
)
)
{
mFrontBuffer
-
>
ClearDidSelfCopy
(
)
;
updateRegion
=
mBuffer
-
>
BufferRect
(
)
;
}
updateRegion
.
Sub
(
updateRegion
aRegionToDraw
)
;
if
(
updateRegion
.
IsEmpty
(
)
)
{
return
Nothing
(
)
;
}
return
Some
(
CapturedBufferState
:
:
Copy
{
mFrontBuffer
-
>
ShallowCopy
(
)
mBuffer
-
>
ShallowCopy
(
)
updateRegion
.
GetBounds
(
)
}
)
;
}
void
ContentClientDoubleBuffered
:
:
EnsureBackBufferIfFrontBuffer
(
)
{
if
(
!
mBuffer
&
&
mFrontBuffer
)
{
mBuffer
=
CreateBufferInternal
(
mFrontBuffer
-
>
BufferRect
(
)
mFrontBuffer
-
>
GetFormat
(
)
mTextureFlags
)
;
MOZ_ASSERT
(
mBuffer
)
;
}
}
}
}
