#
include
"
mozilla
/
layers
/
ContentClient
.
h
"
#
include
"
BasicLayers
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxEnv
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
gfxPoint
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
ipc
/
ShadowLayers
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
BasePoint
.
h
"
#
include
"
mozilla
/
gfx
/
BaseSize
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
LayerManagerComposite
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
ifdef
XP_WIN
#
include
"
gfxWindowsPlatform
.
h
"
#
endif
#
ifdef
MOZ_WIDGET_GTK
#
include
"
gfxPlatformGtk
.
h
"
#
endif
#
include
"
ReadbackLayer
.
h
"
#
include
<
vector
>
using
namespace
std
;
namespace
mozilla
{
using
namespace
gfx
;
namespace
layers
{
static
TextureFlags
TextureFlagsForRotatedContentBufferFlags
(
uint32_t
aBufferFlags
)
{
TextureFlags
result
=
TextureFlags
:
:
NO_FLAGS
;
if
(
aBufferFlags
&
RotatedContentBuffer
:
:
BUFFER_COMPONENT_ALPHA
)
{
result
|
=
TextureFlags
:
:
COMPONENT_ALPHA
;
}
return
result
;
}
already_AddRefed
<
ContentClient
>
ContentClient
:
:
CreateContentClient
(
CompositableForwarder
*
aForwarder
)
{
LayersBackend
backend
=
aForwarder
-
>
GetCompositorBackendType
(
)
;
if
(
backend
!
=
LayersBackend
:
:
LAYERS_OPENGL
&
&
backend
!
=
LayersBackend
:
:
LAYERS_D3D11
&
&
backend
!
=
LayersBackend
:
:
LAYERS_WR
&
&
backend
!
=
LayersBackend
:
:
LAYERS_BASIC
)
{
return
nullptr
;
}
bool
useDoubleBuffering
=
false
;
#
ifdef
XP_WIN
if
(
backend
=
=
LayersBackend
:
:
LAYERS_D3D11
)
{
useDoubleBuffering
=
gfxWindowsPlatform
:
:
GetPlatform
(
)
-
>
IsDirect2DBackend
(
)
;
}
else
#
endif
#
ifdef
MOZ_WIDGET_GTK
if
(
!
gfxPlatformGtk
:
:
GetPlatform
(
)
-
>
UseImageOffscreenSurfaces
(
)
|
|
!
gfxVars
:
:
UseXRender
(
)
)
#
endif
{
useDoubleBuffering
=
backend
=
=
LayersBackend
:
:
LAYERS_BASIC
;
}
if
(
useDoubleBuffering
|
|
gfxEnv
:
:
ForceDoubleBuffering
(
)
)
{
return
MakeAndAddRef
<
ContentClientDoubleBuffered
>
(
aForwarder
)
;
}
return
MakeAndAddRef
<
ContentClientSingleBuffered
>
(
aForwarder
)
;
}
void
ContentClient
:
:
BeginAsyncPaint
(
)
{
mInAsyncPaint
=
true
;
}
void
ContentClient
:
:
EndPaint
(
nsTArray
<
ReadbackProcessor
:
:
Update
>
*
aReadbackUpdates
)
{
mInAsyncPaint
=
false
;
}
void
ContentClient
:
:
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
{
aStream
<
<
aPrefix
;
aStream
<
<
nsPrintfCString
(
"
ContentClient
(
0x
%
p
)
"
this
)
.
get
(
)
;
if
(
profiler_feature_active
(
ProfilerFeature
:
:
DisplayListDump
)
)
{
nsAutoCString
pfx
(
aPrefix
)
;
pfx
+
=
"
"
;
Dump
(
aStream
pfx
.
get
(
)
false
)
;
}
}
ContentClientBasic
:
:
ContentClientBasic
(
gfx
:
:
BackendType
aBackend
)
:
ContentClient
(
nullptr
)
RotatedContentBuffer
(
ContainsVisibleBounds
)
mBackend
(
aBackend
)
{
}
void
ContentClientBasic
:
:
CreateBuffer
(
ContentType
aType
const
IntRect
&
aRect
uint32_t
aFlags
RefPtr
<
gfx
:
:
DrawTarget
>
*
aBlackDT
RefPtr
<
gfx
:
:
DrawTarget
>
*
aWhiteDT
)
{
MOZ_ASSERT
(
!
(
aFlags
&
BUFFER_COMPONENT_ALPHA
)
)
;
if
(
aFlags
&
BUFFER_COMPONENT_ALPHA
)
{
gfxDevCrash
(
LogReason
:
:
AlphaWithBasicClient
)
<
<
"
Asking
basic
content
client
for
component
alpha
"
;
}
IntSize
size
(
aRect
.
Width
(
)
aRect
.
Height
(
)
)
;
#
ifdef
XP_WIN
if
(
mBackend
=
=
BackendType
:
:
CAIRO
&
&
(
aType
=
=
gfxContentType
:
:
COLOR
|
|
aType
=
=
gfxContentType
:
:
COLOR_ALPHA
)
)
{
RefPtr
<
gfxASurface
>
surf
=
new
gfxWindowsSurface
(
size
aType
=
=
gfxContentType
:
:
COLOR
?
gfxImageFormat
:
:
X8R8G8B8_UINT32
:
gfxImageFormat
:
:
A8R8G8B8_UINT32
)
;
*
aBlackDT
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateDrawTargetForSurface
(
surf
size
)
;
if
(
*
aBlackDT
)
{
return
;
}
}
#
endif
*
aBlackDT
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateDrawTargetForBackend
(
mBackend
size
gfxPlatform
:
:
GetPlatform
(
)
-
>
Optimal2DFormatForContent
(
aType
)
)
;
}
RefPtr
<
CapturedPaintState
>
ContentClientBasic
:
:
BorrowDrawTargetForRecording
(
PaintState
&
aPaintState
RotatedContentBuffer
:
:
DrawIterator
*
aIter
)
{
return
nullptr
;
}
void
ContentClientRemoteBuffer
:
:
DestroyBuffers
(
)
{
if
(
!
mTextureClient
)
{
return
;
}
mOldTextures
.
AppendElement
(
mTextureClient
)
;
mTextureClient
=
nullptr
;
if
(
mTextureClientOnWhite
)
{
mOldTextures
.
AppendElement
(
mTextureClientOnWhite
)
;
mTextureClientOnWhite
=
nullptr
;
}
DestroyFrontBuffer
(
)
;
}
RefPtr
<
CapturedPaintState
>
ContentClientRemoteBuffer
:
:
BorrowDrawTargetForRecording
(
PaintState
&
aPaintState
RotatedContentBuffer
:
:
DrawIterator
*
aIter
)
{
RefPtr
<
CapturedPaintState
>
cps
=
RotatedContentBuffer
:
:
BorrowDrawTargetForRecording
(
aPaintState
aIter
)
;
if
(
!
cps
)
{
return
nullptr
;
}
cps
-
>
mTextureClient
=
mTextureClient
;
cps
-
>
mTextureClientOnWhite
=
mTextureClientOnWhite
;
return
cps
.
forget
(
)
;
}
class
RemoteBufferReadbackProcessor
:
public
TextureReadbackSink
{
public
:
RemoteBufferReadbackProcessor
(
nsTArray
<
ReadbackProcessor
:
:
Update
>
*
aReadbackUpdates
const
IntRect
&
aBufferRect
const
nsIntPoint
&
aBufferRotation
)
:
mReadbackUpdates
(
*
aReadbackUpdates
)
mBufferRect
(
aBufferRect
)
mBufferRotation
(
aBufferRotation
)
{
for
(
uint32_t
i
=
0
;
i
<
mReadbackUpdates
.
Length
(
)
;
+
+
i
)
{
mLayerRefs
.
push_back
(
mReadbackUpdates
[
i
]
.
mLayer
)
;
}
}
virtual
void
ProcessReadback
(
gfx
:
:
DataSourceSurface
*
aSourceSurface
)
{
SourceRotatedBuffer
rotBuffer
(
aSourceSurface
nullptr
mBufferRect
mBufferRotation
)
;
for
(
uint32_t
i
=
0
;
i
<
mReadbackUpdates
.
Length
(
)
;
+
+
i
)
{
ReadbackProcessor
:
:
Update
&
update
=
mReadbackUpdates
[
i
]
;
nsIntPoint
offset
=
update
.
mLayer
-
>
GetBackgroundLayerOffset
(
)
;
ReadbackSink
*
sink
=
update
.
mLayer
-
>
GetSink
(
)
;
if
(
!
sink
)
{
continue
;
}
if
(
!
aSourceSurface
)
{
sink
-
>
SetUnknown
(
update
.
mSequenceCounter
)
;
continue
;
}
RefPtr
<
DrawTarget
>
dt
=
sink
-
>
BeginUpdate
(
update
.
mUpdateRect
+
offset
update
.
mSequenceCounter
)
;
if
(
!
dt
)
{
continue
;
}
dt
-
>
SetTransform
(
Matrix
:
:
Translation
(
offset
.
x
offset
.
y
)
)
;
rotBuffer
.
DrawBufferWithRotation
(
dt
RotatedBuffer
:
:
BUFFER_BLACK
)
;
update
.
mLayer
-
>
GetSink
(
)
-
>
EndUpdate
(
update
.
mUpdateRect
+
offset
)
;
}
}
private
:
nsTArray
<
ReadbackProcessor
:
:
Update
>
mReadbackUpdates
;
vector
<
RefPtr
<
Layer
>
>
mLayerRefs
;
IntRect
mBufferRect
;
nsIntPoint
mBufferRotation
;
}
;
void
ContentClientRemoteBuffer
:
:
BeginPaint
(
)
{
EnsureBackBufferIfFrontBuffer
(
)
;
if
(
mTextureClient
)
{
SetBufferProvider
(
mTextureClient
)
;
}
if
(
mTextureClientOnWhite
)
{
SetBufferProviderOnWhite
(
mTextureClientOnWhite
)
;
}
}
void
ContentClientRemoteBuffer
:
:
BeginAsyncPaint
(
)
{
BeginPaint
(
)
;
mInAsyncPaint
=
true
;
}
void
ContentClientRemoteBuffer
:
:
EndPaint
(
nsTArray
<
ReadbackProcessor
:
:
Update
>
*
aReadbackUpdates
)
{
MOZ_ASSERT
(
!
mTextureClientOnWhite
|
|
!
aReadbackUpdates
|
|
aReadbackUpdates
-
>
Length
(
)
=
=
0
)
;
SetBufferProvider
(
nullptr
)
;
SetBufferProviderOnWhite
(
nullptr
)
;
for
(
unsigned
i
=
0
;
i
<
mOldTextures
.
Length
(
)
;
+
+
i
)
{
if
(
mOldTextures
[
i
]
-
>
IsLocked
(
)
)
{
mOldTextures
[
i
]
-
>
Unlock
(
)
;
}
}
mOldTextures
.
Clear
(
)
;
if
(
mTextureClient
&
&
mTextureClient
-
>
IsLocked
(
)
)
{
if
(
aReadbackUpdates
&
&
aReadbackUpdates
-
>
Length
(
)
>
0
)
{
RefPtr
<
TextureReadbackSink
>
readbackSink
=
new
RemoteBufferReadbackProcessor
(
aReadbackUpdates
mBufferRect
mBufferRotation
)
;
mTextureClient
-
>
SetReadbackSink
(
readbackSink
)
;
}
mTextureClient
-
>
Unlock
(
)
;
mTextureClient
-
>
SyncWithObject
(
mForwarder
-
>
GetSyncObject
(
)
)
;
}
if
(
mTextureClientOnWhite
&
&
mTextureClientOnWhite
-
>
IsLocked
(
)
)
{
mTextureClientOnWhite
-
>
Unlock
(
)
;
mTextureClientOnWhite
-
>
SyncWithObject
(
mForwarder
-
>
GetSyncObject
(
)
)
;
}
ContentClientRemote
:
:
EndPaint
(
aReadbackUpdates
)
;
}
void
ContentClientRemoteBuffer
:
:
BuildTextureClients
(
SurfaceFormat
aFormat
const
IntRect
&
aRect
uint32_t
aFlags
)
{
MOZ_ASSERT
(
!
mIsNewBuffer
"
Bad
!
Did
we
create
a
buffer
twice
without
painting
?
"
)
;
mIsNewBuffer
=
true
;
DestroyBuffers
(
)
;
mSurfaceFormat
=
aFormat
;
mSize
=
IntSize
(
aRect
.
Width
(
)
aRect
.
Height
(
)
)
;
mTextureFlags
=
TextureFlagsForRotatedContentBufferFlags
(
aFlags
)
;
if
(
aFlags
&
BUFFER_COMPONENT_ALPHA
)
{
mTextureFlags
|
=
TextureFlags
:
:
COMPONENT_ALPHA
;
}
CreateBackBuffer
(
mBufferRect
)
;
}
void
ContentClientRemoteBuffer
:
:
CreateBackBuffer
(
const
IntRect
&
aBufferRect
)
{
TextureAllocationFlags
textureAllocFlags
=
(
mTextureFlags
&
TextureFlags
:
:
COMPONENT_ALPHA
)
?
TextureAllocationFlags
:
:
ALLOC_CLEAR_BUFFER_BLACK
:
TextureAllocationFlags
:
:
ALLOC_CLEAR_BUFFER
;
mTextureClient
=
CreateTextureClientForDrawing
(
mSurfaceFormat
mSize
BackendSelector
:
:
Content
mTextureFlags
|
ExtraTextureFlags
(
)
textureAllocFlags
)
;
if
(
!
mTextureClient
|
|
!
AddTextureClient
(
mTextureClient
)
)
{
AbortTextureClientCreation
(
)
;
return
;
}
mTextureClient
-
>
EnableBlockingReadLock
(
)
;
if
(
mTextureFlags
&
TextureFlags
:
:
COMPONENT_ALPHA
)
{
mTextureClientOnWhite
=
mTextureClient
-
>
CreateSimilar
(
mForwarder
-
>
GetCompositorBackendType
(
)
mTextureFlags
|
ExtraTextureFlags
(
)
TextureAllocationFlags
:
:
ALLOC_CLEAR_BUFFER_WHITE
)
;
if
(
!
mTextureClientOnWhite
|
|
!
AddTextureClient
(
mTextureClientOnWhite
)
)
{
AbortTextureClientCreation
(
)
;
return
;
}
}
}
void
ContentClientRemoteBuffer
:
:
CreateBuffer
(
ContentType
aType
const
IntRect
&
aRect
uint32_t
aFlags
RefPtr
<
gfx
:
:
DrawTarget
>
*
aBlackDT
RefPtr
<
gfx
:
:
DrawTarget
>
*
aWhiteDT
)
{
BuildTextureClients
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
Optimal2DFormatForContent
(
aType
)
aRect
aFlags
)
;
if
(
!
mTextureClient
)
{
return
;
}
OpenMode
mode
=
OpenMode
:
:
OPEN_READ_WRITE
;
if
(
mInAsyncPaint
)
{
mode
|
=
OpenMode
:
:
OPEN_ASYNC_WRITE
;
}
DebugOnly
<
bool
>
locked
=
mTextureClient
-
>
Lock
(
mode
)
;
MOZ_ASSERT
(
locked
"
Could
not
lock
the
TextureClient
"
)
;
*
aBlackDT
=
mTextureClient
-
>
BorrowDrawTarget
(
)
;
if
(
aFlags
&
BUFFER_COMPONENT_ALPHA
)
{
locked
=
mTextureClientOnWhite
-
>
Lock
(
mode
)
;
MOZ_ASSERT
(
locked
"
Could
not
lock
the
second
TextureClient
for
component
alpha
"
)
;
*
aWhiteDT
=
mTextureClientOnWhite
-
>
BorrowDrawTarget
(
)
;
}
}
nsIntRegion
ContentClientRemoteBuffer
:
:
GetUpdatedRegion
(
const
nsIntRegion
&
aRegionToDraw
const
nsIntRegion
&
aVisibleRegion
bool
aDidSelfCopy
)
{
nsIntRegion
updatedRegion
;
if
(
mIsNewBuffer
|
|
aDidSelfCopy
)
{
updatedRegion
=
aVisibleRegion
.
GetBounds
(
)
;
mIsNewBuffer
=
false
;
}
else
{
updatedRegion
=
aRegionToDraw
;
}
NS_ASSERTION
(
BufferRect
(
)
.
Contains
(
aRegionToDraw
.
GetBounds
(
)
)
"
Update
outside
of
buffer
rect
!
"
)
;
MOZ_ASSERT
(
mTextureClient
"
should
have
a
back
buffer
by
now
"
)
;
return
updatedRegion
;
}
void
ContentClientRemoteBuffer
:
:
Updated
(
const
nsIntRegion
&
aRegionToDraw
const
nsIntRegion
&
aVisibleRegion
bool
aDidSelfCopy
)
{
nsIntRegion
updatedRegion
=
GetUpdatedRegion
(
aRegionToDraw
aVisibleRegion
aDidSelfCopy
)
;
MOZ_ASSERT
(
mTextureClient
)
;
if
(
mTextureClientOnWhite
)
{
mForwarder
-
>
UseComponentAlphaTextures
(
this
mTextureClient
mTextureClientOnWhite
)
;
}
else
{
AutoTArray
<
CompositableForwarder
:
:
TimedTextureClient
1
>
textures
;
CompositableForwarder
:
:
TimedTextureClient
*
t
=
textures
.
AppendElement
(
)
;
t
-
>
mTextureClient
=
mTextureClient
;
IntSize
size
=
mTextureClient
-
>
GetSize
(
)
;
t
-
>
mPictureRect
=
nsIntRect
(
0
0
size
.
width
size
.
height
)
;
GetForwarder
(
)
-
>
UseTextures
(
this
textures
)
;
}
mForwarder
-
>
UpdateTextureRegion
(
this
ThebesBufferData
(
BufferRect
(
)
BufferRotation
(
)
)
updatedRegion
)
;
SwapBuffers
(
updatedRegion
)
;
}
void
ContentClientRemoteBuffer
:
:
SwapBuffers
(
const
nsIntRegion
&
aFrontUpdatedRegion
)
{
mFrontAndBackBufferDiffer
=
true
;
}
bool
ContentClientRemoteBuffer
:
:
LockBuffers
(
)
{
OpenMode
mode
=
OpenMode
:
:
OPEN_READ_WRITE
;
if
(
mInAsyncPaint
)
{
mode
|
=
OpenMode
:
:
OPEN_ASYNC_WRITE
;
}
if
(
mTextureClient
)
{
bool
locked
=
mTextureClient
-
>
Lock
(
mode
)
;
if
(
!
locked
)
{
return
false
;
}
}
if
(
mTextureClientOnWhite
)
{
bool
locked
=
mTextureClientOnWhite
-
>
Lock
(
mode
)
;
if
(
!
locked
)
{
UnlockBuffers
(
)
;
return
false
;
}
}
return
true
;
}
void
ContentClientRemoteBuffer
:
:
UnlockBuffers
(
)
{
if
(
mTextureClient
&
&
mTextureClient
-
>
IsLocked
(
)
)
{
mTextureClient
-
>
Unlock
(
)
;
}
if
(
mTextureClientOnWhite
&
&
mTextureClientOnWhite
-
>
IsLocked
(
)
)
{
mTextureClientOnWhite
-
>
Unlock
(
)
;
}
}
void
ContentClientRemoteBuffer
:
:
Dump
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
bool
aDumpHtml
TextureDumpMode
aCompress
)
{
if
(
!
aDumpHtml
)
{
aStream
<
<
"
\
n
"
<
<
aPrefix
<
<
"
Surface
:
"
;
}
CompositableClient
:
:
DumpTextureClient
(
aStream
mTextureClient
aCompress
)
;
}
void
ContentClientDoubleBuffered
:
:
Dump
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
bool
aDumpHtml
TextureDumpMode
aCompress
)
{
if
(
!
aDumpHtml
)
{
aStream
<
<
"
\
n
"
<
<
aPrefix
<
<
"
Surface
:
"
;
}
CompositableClient
:
:
DumpTextureClient
(
aStream
mFrontClient
aCompress
)
;
}
void
ContentClientDoubleBuffered
:
:
DestroyFrontBuffer
(
)
{
if
(
mFrontClient
)
{
mOldTextures
.
AppendElement
(
mFrontClient
)
;
mFrontClient
=
nullptr
;
}
if
(
mFrontClientOnWhite
)
{
mOldTextures
.
AppendElement
(
mFrontClientOnWhite
)
;
mFrontClientOnWhite
=
nullptr
;
}
}
void
ContentClientDoubleBuffered
:
:
Updated
(
const
nsIntRegion
&
aRegionToDraw
const
nsIntRegion
&
aVisibleRegion
bool
aDidSelfCopy
)
{
ContentClientRemoteBuffer
:
:
Updated
(
aRegionToDraw
aVisibleRegion
aDidSelfCopy
)
;
}
void
ContentClientDoubleBuffered
:
:
SwapBuffers
(
const
nsIntRegion
&
aFrontUpdatedRegion
)
{
mFrontUpdatedRegion
=
aFrontUpdatedRegion
;
RefPtr
<
TextureClient
>
oldBack
=
mTextureClient
;
mTextureClient
=
mFrontClient
;
mFrontClient
=
oldBack
;
oldBack
=
mTextureClientOnWhite
;
mTextureClientOnWhite
=
mFrontClientOnWhite
;
mFrontClientOnWhite
=
oldBack
;
IntRect
oldBufferRect
=
mBufferRect
;
mBufferRect
=
mFrontBufferRect
;
mFrontBufferRect
=
oldBufferRect
;
nsIntPoint
oldBufferRotation
=
mBufferRotation
;
mBufferRotation
=
mFrontBufferRotation
;
mFrontBufferRotation
=
oldBufferRotation
;
MOZ_ASSERT
(
mFrontClient
)
;
ContentClientRemoteBuffer
:
:
SwapBuffers
(
aFrontUpdatedRegion
)
;
}
void
ContentClientDoubleBuffered
:
:
BeginPaint
(
)
{
ContentClientRemoteBuffer
:
:
BeginPaint
(
)
;
mIsNewBuffer
=
false
;
if
(
!
mFrontAndBackBufferDiffer
)
{
return
;
}
if
(
mDidSelfCopy
)
{
mBufferRect
.
MoveTo
(
mFrontBufferRect
.
TopLeft
(
)
)
;
mBufferRotation
=
nsIntPoint
(
)
;
return
;
}
mBufferRect
=
mFrontBufferRect
;
mBufferRotation
=
mFrontBufferRotation
;
}
void
ContentClientDoubleBuffered
:
:
BeginAsyncPaint
(
)
{
BeginPaint
(
)
;
mInAsyncPaint
=
true
;
}
void
ContentClientDoubleBuffered
:
:
FinalizeFrame
(
const
nsIntRegion
&
aRegionToDraw
)
{
if
(
!
mFrontAndBackBufferDiffer
)
{
MOZ_ASSERT
(
!
mDidSelfCopy
"
If
we
have
to
copy
the
world
then
our
buffers
are
different
right
?
"
)
;
return
;
}
MOZ_ASSERT
(
mFrontClient
)
;
if
(
!
mFrontClient
)
{
return
;
}
MOZ_LAYERS_LOG
(
(
"
BasicShadowableThebes
(
%
p
)
:
reading
back
<
x
=
%
d
y
=
%
d
w
=
%
d
h
=
%
d
>
"
this
mFrontUpdatedRegion
.
GetBounds
(
)
.
x
mFrontUpdatedRegion
.
GetBounds
(
)
.
y
mFrontUpdatedRegion
.
GetBounds
(
)
.
Width
(
)
mFrontUpdatedRegion
.
GetBounds
(
)
.
Height
(
)
)
)
;
mFrontAndBackBufferDiffer
=
false
;
nsIntRegion
updateRegion
=
mFrontUpdatedRegion
;
if
(
mDidSelfCopy
)
{
mDidSelfCopy
=
false
;
updateRegion
=
mBufferRect
;
}
updateRegion
.
Sub
(
updateRegion
aRegionToDraw
)
;
if
(
updateRegion
.
IsEmpty
(
)
)
{
return
;
}
TextureClientAutoLock
frontLock
(
mFrontClient
OpenMode
:
:
OPEN_READ_ONLY
)
;
if
(
!
frontLock
.
Succeeded
(
)
)
{
return
;
}
Maybe
<
TextureClientAutoLock
>
frontOnWhiteLock
;
if
(
mFrontClientOnWhite
)
{
frontOnWhiteLock
.
emplace
(
mFrontClientOnWhite
OpenMode
:
:
OPEN_READ_ONLY
)
;
if
(
!
frontOnWhiteLock
-
>
Succeeded
(
)
)
{
return
;
}
}
gfx
:
:
DrawTarget
*
dt
=
mFrontClient
-
>
BorrowDrawTarget
(
)
;
gfx
:
:
DrawTarget
*
dtw
=
mFrontClientOnWhite
?
mFrontClientOnWhite
-
>
BorrowDrawTarget
(
)
:
nullptr
;
if
(
dt
&
&
dt
-
>
IsValid
(
)
)
{
RefPtr
<
SourceSurface
>
surf
=
dt
-
>
Snapshot
(
)
;
RefPtr
<
SourceSurface
>
surfOnWhite
=
dtw
?
dtw
-
>
Snapshot
(
)
:
nullptr
;
SourceRotatedBuffer
frontBuffer
(
surf
surfOnWhite
mFrontBufferRect
mFrontBufferRotation
)
;
UpdateDestinationFrom
(
frontBuffer
updateRegion
)
;
}
else
{
gfxCriticalNote
<
<
"
Invalid
draw
target
(
s
)
"
<
<
hexa
(
dt
)
<
<
"
and
"
<
<
hexa
(
dtw
)
;
}
}
void
ContentClientDoubleBuffered
:
:
EnsureBackBufferIfFrontBuffer
(
)
{
if
(
!
mTextureClient
&
&
mFrontClient
)
{
CreateBackBuffer
(
mFrontBufferRect
)
;
mBufferRect
=
mFrontBufferRect
;
mBufferRotation
=
mFrontBufferRotation
;
}
}
void
ContentClientDoubleBuffered
:
:
UpdateDestinationFrom
(
const
RotatedBuffer
&
aSource
const
nsIntRegion
&
aUpdateRegion
)
{
DrawIterator
iter
;
while
(
DrawTarget
*
destDT
=
BorrowDrawTargetForQuadrantUpdate
(
aUpdateRegion
.
GetBounds
(
)
BUFFER_BLACK
&
iter
)
)
{
bool
isClippingCheap
=
IsClippingCheap
(
destDT
iter
.
mDrawRegion
)
;
if
(
isClippingCheap
)
{
gfxUtils
:
:
ClipToRegion
(
destDT
iter
.
mDrawRegion
)
;
}
aSource
.
DrawBufferWithRotation
(
destDT
BUFFER_BLACK
1
.
0
CompositionOp
:
:
OP_SOURCE
)
;
if
(
isClippingCheap
)
{
destDT
-
>
PopClip
(
)
;
}
destDT
-
>
Flush
(
)
;
ReturnDrawTargetToBuffer
(
destDT
)
;
}
if
(
aSource
.
HaveBufferOnWhite
(
)
)
{
MOZ_ASSERT
(
HaveBufferOnWhite
(
)
)
;
DrawIterator
whiteIter
;
while
(
DrawTarget
*
destDT
=
BorrowDrawTargetForQuadrantUpdate
(
aUpdateRegion
.
GetBounds
(
)
BUFFER_WHITE
&
whiteIter
)
)
{
bool
isClippingCheap
=
IsClippingCheap
(
destDT
whiteIter
.
mDrawRegion
)
;
if
(
isClippingCheap
)
{
gfxUtils
:
:
ClipToRegion
(
destDT
whiteIter
.
mDrawRegion
)
;
}
aSource
.
DrawBufferWithRotation
(
destDT
BUFFER_WHITE
1
.
0
CompositionOp
:
:
OP_SOURCE
)
;
if
(
isClippingCheap
)
{
destDT
-
>
PopClip
(
)
;
}
destDT
-
>
Flush
(
)
;
ReturnDrawTargetToBuffer
(
destDT
)
;
}
}
}
}
}
