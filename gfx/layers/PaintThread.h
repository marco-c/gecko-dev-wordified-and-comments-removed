#
ifndef
MOZILLA_LAYERS_PAINTTHREAD_H
#
define
MOZILLA_LAYERS_PAINTTHREAD_H
#
include
"
base
/
platform_thread
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
RotatedBuffer
.
h
"
#
include
"
nsThreadUtils
.
h
"
class
nsIThreadPool
;
namespace
mozilla
{
namespace
gfx
{
class
DrawTarget
;
class
DrawTargetCapture
;
}
;
namespace
layers
{
class
PaintTask
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
PaintTask
)
public
:
PaintTask
(
)
{
}
void
DropTextureClients
(
)
;
RefPtr
<
gfx
:
:
DrawTarget
>
mTarget
;
RefPtr
<
gfx
:
:
DrawTargetCapture
>
mCapture
;
AutoTArray
<
RefPtr
<
TextureClient
>
4
>
mClients
;
protected
:
virtual
~
PaintTask
(
)
{
}
}
;
class
CompositorBridgeChild
;
class
PaintThread
final
{
friend
void
DestroyPaintThread
(
UniquePtr
<
PaintThread
>
&
&
aPaintThread
)
;
public
:
static
void
Start
(
)
;
static
void
Shutdown
(
)
;
static
PaintThread
*
Get
(
)
;
static
bool
IsOnPaintThread
(
)
;
bool
IsOnPaintWorkerThread
(
)
;
void
UpdateRenderMode
(
)
;
void
QueuePaintTask
(
PaintTask
*
aTask
)
;
void
Dispatch
(
RefPtr
<
Runnable
>
&
aRunnable
)
;
void
EndLayerTransaction
(
SyncObjectClient
*
aSyncObject
)
;
void
Release
(
)
;
void
AddRef
(
)
;
static
int32_t
CalculatePaintWorkerCount
(
)
;
private
:
PaintThread
(
)
;
bool
Init
(
)
;
void
ShutdownOnPaintThread
(
)
;
void
InitOnPaintThread
(
)
;
void
InitPaintWorkers
(
)
;
void
AsyncPaintTask
(
CompositorBridgeChild
*
aBridge
PaintTask
*
aTask
)
;
void
AsyncEndLayerTransaction
(
CompositorBridgeChild
*
aBridge
)
;
static
StaticAutoPtr
<
PaintThread
>
sSingleton
;
static
StaticRefPtr
<
nsIThread
>
sThread
;
static
PlatformThreadId
sThreadId
;
RefPtr
<
nsIThreadPool
>
mPaintWorkers
;
}
;
}
}
#
endif
