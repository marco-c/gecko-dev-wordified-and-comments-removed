#
include
"
mozilla
/
layers
/
NativeLayerCA
.
h
"
#
import
<
AppKit
/
NSAnimationContext
.
h
>
#
import
<
AppKit
/
NSColor
.
h
>
#
import
<
OpenGL
/
gl
.
h
>
#
import
<
QuartzCore
/
QuartzCore
.
h
>
#
include
<
utility
>
#
include
<
algorithm
>
#
include
"
gfxUtils
.
h
"
#
include
"
GLBlitHelper
.
h
"
#
include
"
GLContextCGL
.
h
"
#
include
"
GLContextProvider
.
h
"
#
include
"
MozFramebuffer
.
h
"
#
include
"
mozilla
/
layers
/
SurfacePoolCA
.
h
"
#
include
"
ScopedGLHelpers
.
h
"
interface
CALayer
(
PrivateSetContentsOpaque
)
-
(
void
)
setContentsOpaque
:
(
BOOL
)
opaque
;
end
namespace
mozilla
{
namespace
layers
{
using
gfx
:
:
IntPoint
;
using
gfx
:
:
IntSize
;
using
gfx
:
:
IntRect
;
using
gfx
:
:
IntRegion
;
using
gfx
:
:
SurfaceFormat
;
using
gl
:
:
GLContext
;
using
gl
:
:
GLContextCGL
;
struct
MOZ_STACK_CLASS
AutoCATransaction
final
{
AutoCATransaction
(
)
{
[
NSAnimationContext
beginGrouping
]
;
[
CATransaction
setDisableActions
:
YES
]
;
}
~
AutoCATransaction
(
)
{
[
NSAnimationContext
endGrouping
]
;
}
}
;
already_AddRefed
<
NativeLayerRootCA
>
NativeLayerRootCA
:
:
CreateForCALayer
(
CALayer
*
aLayer
)
{
RefPtr
<
NativeLayerRootCA
>
layerRoot
=
new
NativeLayerRootCA
(
aLayer
)
;
return
layerRoot
.
forget
(
)
;
}
static
CALayer
*
MakeOffscreenRootCALayer
(
)
{
AutoCATransaction
transaction
;
CALayer
*
layer
=
[
CALayer
layer
]
;
layer
.
position
=
NSZeroPoint
;
layer
.
bounds
=
NSZeroRect
;
layer
.
anchorPoint
=
NSZeroPoint
;
layer
.
contentsGravity
=
kCAGravityTopLeft
;
layer
.
masksToBounds
=
YES
;
layer
.
geometryFlipped
=
YES
;
return
layer
;
}
NativeLayerRootCA
:
:
NativeLayerRootCA
(
CALayer
*
aLayer
)
:
mMutex
(
"
NativeLayerRootCA
"
)
mOnscreenRepresentation
(
aLayer
)
mOffscreenRepresentation
(
MakeOffscreenRootCALayer
(
)
)
{
}
NativeLayerRootCA
:
:
~
NativeLayerRootCA
(
)
{
MOZ_RELEASE_ASSERT
(
mSublayers
.
IsEmpty
(
)
"
Please
clear
all
layers
before
destroying
the
layer
root
.
"
)
;
}
already_AddRefed
<
NativeLayer
>
NativeLayerRootCA
:
:
CreateLayer
(
const
IntSize
&
aSize
bool
aIsOpaque
SurfacePoolHandle
*
aSurfacePoolHandle
)
{
RefPtr
<
NativeLayer
>
layer
=
new
NativeLayerCA
(
aSize
aIsOpaque
aSurfacePoolHandle
-
>
AsSurfacePoolHandleCA
(
)
)
;
return
layer
.
forget
(
)
;
}
void
NativeLayerRootCA
:
:
AppendLayer
(
NativeLayer
*
aLayer
)
{
MutexAutoLock
lock
(
mMutex
)
;
RefPtr
<
NativeLayerCA
>
layerCA
=
aLayer
-
>
AsNativeLayerCA
(
)
;
MOZ_RELEASE_ASSERT
(
layerCA
)
;
mSublayers
.
AppendElement
(
layerCA
)
;
layerCA
-
>
SetBackingScale
(
mBackingScale
)
;
ForAllRepresentations
(
[
&
]
(
Representation
&
r
)
{
r
.
mMutated
=
true
;
}
)
;
}
void
NativeLayerRootCA
:
:
RemoveLayer
(
NativeLayer
*
aLayer
)
{
MutexAutoLock
lock
(
mMutex
)
;
RefPtr
<
NativeLayerCA
>
layerCA
=
aLayer
-
>
AsNativeLayerCA
(
)
;
MOZ_RELEASE_ASSERT
(
layerCA
)
;
mSublayers
.
RemoveElement
(
layerCA
)
;
ForAllRepresentations
(
[
&
]
(
Representation
&
r
)
{
r
.
mMutated
=
true
;
}
)
;
}
void
NativeLayerRootCA
:
:
SetLayers
(
const
nsTArray
<
RefPtr
<
NativeLayer
>
>
&
aLayers
)
{
MutexAutoLock
lock
(
mMutex
)
;
nsTArray
<
RefPtr
<
NativeLayerCA
>
>
layersCA
(
aLayers
.
Length
(
)
)
;
for
(
auto
&
layer
:
aLayers
)
{
RefPtr
<
NativeLayerCA
>
layerCA
=
layer
-
>
AsNativeLayerCA
(
)
;
MOZ_RELEASE_ASSERT
(
layerCA
)
;
layerCA
-
>
SetBackingScale
(
mBackingScale
)
;
layersCA
.
AppendElement
(
std
:
:
move
(
layerCA
)
)
;
}
if
(
layersCA
!
=
mSublayers
)
{
mSublayers
=
std
:
:
move
(
layersCA
)
;
ForAllRepresentations
(
[
&
]
(
Representation
&
r
)
{
r
.
mMutated
=
true
;
}
)
;
}
}
void
NativeLayerRootCA
:
:
SetBackingScale
(
float
aBackingScale
)
{
MutexAutoLock
lock
(
mMutex
)
;
mBackingScale
=
aBackingScale
;
for
(
auto
layer
:
mSublayers
)
{
layer
-
>
SetBackingScale
(
aBackingScale
)
;
}
}
float
NativeLayerRootCA
:
:
BackingScale
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mBackingScale
;
}
void
NativeLayerRootCA
:
:
SuspendOffMainThreadCommits
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
mOffMainThreadCommitsSuspended
=
true
;
}
bool
NativeLayerRootCA
:
:
UnsuspendOffMainThreadCommits
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
mOffMainThreadCommitsSuspended
=
false
;
return
mCommitPending
;
}
bool
NativeLayerRootCA
:
:
AreOffMainThreadCommitsSuspended
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mOffMainThreadCommitsSuspended
;
}
bool
NativeLayerRootCA
:
:
CommitToScreen
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
NS_IsMainThread
(
)
&
&
mOffMainThreadCommitsSuspended
)
{
mCommitPending
=
true
;
return
false
;
}
mOnscreenRepresentation
.
Commit
(
WhichRepresentation
:
:
ONSCREEN
mSublayers
)
;
mCommitPending
=
false
;
return
true
;
}
UniquePtr
<
NativeLayerRootSnapshotter
>
NativeLayerRootCA
:
:
CreateSnapshotter
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_RELEASE_ASSERT
(
!
mWeakSnapshotter
"
No
NativeLayerRootSnapshotter
for
this
NativeLayerRoot
should
exist
when
this
is
called
"
)
;
auto
cr
=
NativeLayerRootSnapshotterCA
:
:
Create
(
this
mOffscreenRepresentation
.
mRootCALayer
)
;
if
(
cr
)
{
mWeakSnapshotter
=
cr
.
get
(
)
;
}
return
cr
;
}
void
NativeLayerRootCA
:
:
OnNativeLayerRootSnapshotterDestroyed
(
NativeLayerRootSnapshotterCA
*
aNativeLayerRootSnapshotter
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_RELEASE_ASSERT
(
mWeakSnapshotter
=
=
aNativeLayerRootSnapshotter
)
;
mWeakSnapshotter
=
nullptr
;
}
void
NativeLayerRootCA
:
:
CommitOffscreen
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
mOffscreenRepresentation
.
Commit
(
WhichRepresentation
:
:
OFFSCREEN
mSublayers
)
;
}
template
<
typename
F
>
void
NativeLayerRootCA
:
:
ForAllRepresentations
(
F
aFn
)
{
aFn
(
mOnscreenRepresentation
)
;
aFn
(
mOffscreenRepresentation
)
;
}
NativeLayerRootCA
:
:
Representation
:
:
Representation
(
CALayer
*
aRootCALayer
)
:
mRootCALayer
(
[
aRootCALayer
retain
]
)
{
}
NativeLayerRootCA
:
:
Representation
:
:
~
Representation
(
)
{
if
(
mMutated
)
{
AutoCATransaction
transaction
;
mRootCALayer
.
sublayers
=
[
]
;
}
[
mRootCALayer
release
]
;
}
void
NativeLayerRootCA
:
:
Representation
:
:
Commit
(
WhichRepresentation
aRepresentation
const
nsTArray
<
RefPtr
<
NativeLayerCA
>
>
&
aSublayers
)
{
AutoCATransaction
transaction
;
for
(
auto
layer
:
aSublayers
)
{
layer
-
>
ApplyChanges
(
aRepresentation
)
;
}
if
(
mMutated
)
{
NSMutableArray
<
CALayer
*
>
*
sublayers
=
[
NSMutableArray
arrayWithCapacity
:
aSublayers
.
Length
(
)
]
;
for
(
auto
layer
:
aSublayers
)
{
[
sublayers
addObject
:
layer
-
>
UnderlyingCALayer
(
aRepresentation
)
]
;
}
mRootCALayer
.
sublayers
=
sublayers
;
mMutated
=
false
;
}
}
UniquePtr
<
NativeLayerRootSnapshotterCA
>
NativeLayerRootSnapshotterCA
:
:
Create
(
NativeLayerRootCA
*
aLayerRoot
CALayer
*
aRootCALayer
)
{
if
(
NS_IsMainThread
(
)
)
{
return
nullptr
;
}
nsCString
failureUnused
;
RefPtr
<
gl
:
:
GLContext
>
gl
=
gl
:
:
GLContextProvider
:
:
CreateHeadless
(
{
gl
:
:
CreateContextFlags
:
:
ALLOW_OFFLINE_RENDERER
|
gl
:
:
CreateContextFlags
:
:
REQUIRE_COMPAT_PROFILE
}
&
failureUnused
)
;
if
(
!
gl
)
{
return
nullptr
;
}
return
UniquePtr
<
NativeLayerRootSnapshotterCA
>
(
new
NativeLayerRootSnapshotterCA
(
aLayerRoot
std
:
:
move
(
gl
)
aRootCALayer
)
)
;
}
NativeLayerRootSnapshotterCA
:
:
NativeLayerRootSnapshotterCA
(
NativeLayerRootCA
*
aLayerRoot
RefPtr
<
GLContext
>
&
&
aGL
CALayer
*
aRootCALayer
)
:
mLayerRoot
(
aLayerRoot
)
mGL
(
aGL
)
{
AutoCATransaction
transaction
;
mRenderer
=
[
[
CARenderer
rendererWithCGLContext
:
gl
:
:
GLContextCGL
:
:
Cast
(
mGL
)
-
>
GetCGLContext
(
)
options
:
nil
]
retain
]
;
mRenderer
.
layer
=
aRootCALayer
;
}
NativeLayerRootSnapshotterCA
:
:
~
NativeLayerRootSnapshotterCA
(
)
{
mLayerRoot
-
>
OnNativeLayerRootSnapshotterDestroyed
(
this
)
;
[
mRenderer
release
]
;
}
bool
NativeLayerRootSnapshotterCA
:
:
ReadbackPixels
(
const
IntSize
&
aReadbackSize
SurfaceFormat
aReadbackFormat
const
Range
<
uint8_t
>
&
aReadbackBuffer
)
{
if
(
aReadbackFormat
!
=
SurfaceFormat
:
:
B8G8R8A8
)
{
return
false
;
}
CGRect
bounds
=
CGRectMake
(
0
0
aReadbackSize
.
width
aReadbackSize
.
height
)
;
{
AutoCATransaction
transaction
;
mRenderer
.
layer
.
bounds
=
bounds
;
float
scale
=
mLayerRoot
-
>
BackingScale
(
)
;
mRenderer
.
layer
.
sublayerTransform
=
CATransform3DMakeScale
(
scale
scale
1
)
;
mRenderer
.
bounds
=
bounds
;
}
mLayerRoot
-
>
CommitOffscreen
(
)
;
mGL
-
>
MakeCurrent
(
)
;
bool
needToRedrawEverything
=
false
;
if
(
!
mFB
|
|
mFB
-
>
mSize
!
=
aReadbackSize
)
{
mFB
=
gl
:
:
MozFramebuffer
:
:
Create
(
mGL
aReadbackSize
0
false
)
;
if
(
!
mFB
)
{
return
false
;
}
needToRedrawEverything
=
true
;
}
const
gl
:
:
ScopedBindFramebuffer
bindFB
(
mGL
mFB
-
>
mFB
)
;
mGL
-
>
fViewport
(
0
.
0
0
.
0
aReadbackSize
.
width
aReadbackSize
.
height
)
;
glMatrixMode
(
GL_PROJECTION
)
;
glLoadIdentity
(
)
;
glOrtho
(
0
.
0
aReadbackSize
.
width
0
.
0
aReadbackSize
.
height
-
1
1
)
;
float
mediaTime
=
CACurrentMediaTime
(
)
;
[
mRenderer
beginFrameAtTime
:
mediaTime
timeStamp
:
nullptr
]
;
if
(
needToRedrawEverything
)
{
[
mRenderer
addUpdateRect
:
bounds
]
;
}
if
(
!
CGRectIsEmpty
(
[
mRenderer
updateBounds
]
)
)
{
CGRect
updateBounds
=
[
mRenderer
updateBounds
]
;
gl
:
:
ScopedGLState
scopedScissorTestState
(
mGL
LOCAL_GL_SCISSOR_TEST
true
)
;
gl
:
:
ScopedScissorRect
scissor
(
mGL
updateBounds
.
origin
.
x
updateBounds
.
origin
.
y
updateBounds
.
size
.
width
updateBounds
.
size
.
height
)
;
mGL
-
>
fClearColor
(
0
.
0
0
.
0
0
.
0
0
.
0
)
;
mGL
-
>
fClear
(
LOCAL_GL_COLOR_BUFFER_BIT
)
;
[
mRenderer
addUpdateRect
:
updateBounds
]
;
}
[
mRenderer
render
]
;
[
mRenderer
endFrame
]
;
gl
:
:
ScopedPackState
safePackState
(
mGL
)
;
mGL
-
>
fReadPixels
(
0
.
0f
0
.
0f
aReadbackSize
.
width
aReadbackSize
.
height
LOCAL_GL_BGRA
LOCAL_GL_UNSIGNED_BYTE
&
aReadbackBuffer
[
0
]
)
;
return
true
;
}
NativeLayerCA
:
:
NativeLayerCA
(
const
IntSize
&
aSize
bool
aIsOpaque
SurfacePoolHandleCA
*
aSurfacePoolHandle
)
:
mMutex
(
"
NativeLayerCA
"
)
mSurfacePoolHandle
(
aSurfacePoolHandle
)
mSize
(
aSize
)
mIsOpaque
(
aIsOpaque
)
{
MOZ_RELEASE_ASSERT
(
mSurfacePoolHandle
"
Need
a
non
-
null
surface
pool
handle
.
"
)
;
}
NativeLayerCA
:
:
~
NativeLayerCA
(
)
{
if
(
mInProgressLockedIOSurface
)
{
mInProgressLockedIOSurface
-
>
Unlock
(
false
)
;
mInProgressLockedIOSurface
=
nullptr
;
}
if
(
mInProgressSurface
)
{
IOSurfaceDecrementUseCount
(
mInProgressSurface
-
>
mSurface
.
get
(
)
)
;
mSurfacePoolHandle
-
>
ReturnSurfaceToPool
(
mInProgressSurface
-
>
mSurface
)
;
}
if
(
mFrontSurface
)
{
mSurfacePoolHandle
-
>
ReturnSurfaceToPool
(
mFrontSurface
-
>
mSurface
)
;
}
for
(
const
auto
&
surf
:
mSurfaces
)
{
mSurfacePoolHandle
-
>
ReturnSurfaceToPool
(
surf
.
mEntry
.
mSurface
)
;
}
}
void
NativeLayerCA
:
:
SetSurfaceIsFlipped
(
bool
aIsFlipped
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
aIsFlipped
!
=
mSurfaceIsFlipped
)
{
mSurfaceIsFlipped
=
aIsFlipped
;
ForAllRepresentations
(
[
&
]
(
Representation
&
r
)
{
r
.
mMutatedSurfaceIsFlipped
=
true
;
}
)
;
}
}
bool
NativeLayerCA
:
:
SurfaceIsFlipped
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mSurfaceIsFlipped
;
}
IntSize
NativeLayerCA
:
:
GetSize
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mSize
;
}
void
NativeLayerCA
:
:
SetPosition
(
const
IntPoint
&
aPosition
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
aPosition
!
=
mPosition
)
{
mPosition
=
aPosition
;
ForAllRepresentations
(
[
&
]
(
Representation
&
r
)
{
r
.
mMutatedPosition
=
true
;
}
)
;
}
}
IntPoint
NativeLayerCA
:
:
GetPosition
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mPosition
;
}
IntRect
NativeLayerCA
:
:
GetRect
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
IntRect
(
mPosition
mSize
)
;
}
void
NativeLayerCA
:
:
SetBackingScale
(
float
aBackingScale
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
aBackingScale
!
=
mBackingScale
)
{
mBackingScale
=
aBackingScale
;
ForAllRepresentations
(
[
&
]
(
Representation
&
r
)
{
r
.
mMutatedBackingScale
=
true
;
}
)
;
}
}
bool
NativeLayerCA
:
:
IsOpaque
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mIsOpaque
;
}
void
NativeLayerCA
:
:
SetClipRect
(
const
Maybe
<
gfx
:
:
IntRect
>
&
aClipRect
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
aClipRect
!
=
mClipRect
)
{
mClipRect
=
aClipRect
;
ForAllRepresentations
(
[
&
]
(
Representation
&
r
)
{
r
.
mMutatedClipRect
=
true
;
}
)
;
}
}
Maybe
<
gfx
:
:
IntRect
>
NativeLayerCA
:
:
ClipRect
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mClipRect
;
}
gfx
:
:
IntRect
NativeLayerCA
:
:
CurrentSurfaceDisplayRect
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mDisplayRect
;
}
NativeLayerCA
:
:
Representation
:
:
~
Representation
(
)
{
[
mContentCALayer
release
]
;
[
mOpaquenessTintLayer
release
]
;
[
mWrappingCALayer
release
]
;
}
void
NativeLayerCA
:
:
InvalidateRegionThroughoutSwapchain
(
const
MutexAutoLock
&
const
IntRegion
&
aRegion
)
{
IntRegion
r
=
aRegion
;
if
(
mInProgressSurface
)
{
mInProgressSurface
-
>
mInvalidRegion
.
OrWith
(
r
)
;
}
if
(
mFrontSurface
)
{
mFrontSurface
-
>
mInvalidRegion
.
OrWith
(
r
)
;
}
for
(
auto
&
surf
:
mSurfaces
)
{
surf
.
mEntry
.
mInvalidRegion
.
OrWith
(
r
)
;
}
}
bool
NativeLayerCA
:
:
NextSurface
(
const
MutexAutoLock
&
aLock
)
{
if
(
mSize
.
IsEmpty
(
)
)
{
NSLog
(
"
NextSurface
returning
false
because
of
invalid
mSize
(
%
d
%
d
)
.
"
mSize
.
width
mSize
.
height
)
;
return
false
;
}
MOZ_RELEASE_ASSERT
(
!
mInProgressSurface
"
ERROR
:
Do
not
call
NextSurface
twice
in
sequence
.
Call
NotifySurfaceReady
before
the
"
"
next
call
to
NextSurface
.
"
)
;
Maybe
<
SurfaceWithInvalidRegion
>
surf
=
GetUnusedSurfaceAndCleanUp
(
aLock
)
;
if
(
!
surf
)
{
CFTypeRefPtr
<
IOSurfaceRef
>
newSurf
=
mSurfacePoolHandle
-
>
ObtainSurfaceFromPool
(
mSize
)
;
if
(
!
newSurf
)
{
NSLog
(
"
NextSurface
returning
false
because
IOSurfaceCreate
failed
to
create
the
surface
.
"
)
;
return
false
;
}
surf
=
Some
(
SurfaceWithInvalidRegion
{
newSurf
IntRect
(
{
}
mSize
)
}
)
;
}
MOZ_RELEASE_ASSERT
(
surf
)
;
mInProgressSurface
=
std
:
:
move
(
surf
)
;
IOSurfaceIncrementUseCount
(
mInProgressSurface
-
>
mSurface
.
get
(
)
)
;
return
true
;
}
template
<
typename
F
>
void
NativeLayerCA
:
:
HandlePartialUpdate
(
const
MutexAutoLock
&
aLock
const
IntRect
&
aDisplayRect
const
IntRegion
&
aUpdateRegion
F
&
&
aCopyFn
)
{
MOZ_RELEASE_ASSERT
(
IntRect
(
{
}
mSize
)
.
Contains
(
aUpdateRegion
.
GetBounds
(
)
)
"
The
update
region
should
be
within
the
surface
bounds
.
"
)
;
MOZ_RELEASE_ASSERT
(
IntRect
(
{
}
mSize
)
.
Contains
(
aDisplayRect
)
"
The
display
rect
should
be
within
the
surface
bounds
.
"
)
;
MOZ_RELEASE_ASSERT
(
!
mInProgressUpdateRegion
)
;
MOZ_RELEASE_ASSERT
(
!
mInProgressDisplayRect
)
;
mInProgressUpdateRegion
=
Some
(
aUpdateRegion
)
;
mInProgressDisplayRect
=
Some
(
aDisplayRect
)
;
InvalidateRegionThroughoutSwapchain
(
aLock
aUpdateRegion
)
;
if
(
mFrontSurface
)
{
gfx
:
:
IntRegion
copyRegion
;
copyRegion
.
Sub
(
mInProgressSurface
-
>
mInvalidRegion
aUpdateRegion
)
;
copyRegion
.
SubOut
(
mFrontSurface
-
>
mInvalidRegion
)
;
if
(
!
copyRegion
.
IsEmpty
(
)
)
{
aCopyFn
(
mFrontSurface
-
>
mSurface
copyRegion
)
;
mInProgressSurface
-
>
mInvalidRegion
.
SubOut
(
copyRegion
)
;
}
}
}
RefPtr
<
gfx
:
:
DrawTarget
>
NativeLayerCA
:
:
NextSurfaceAsDrawTarget
(
const
IntRect
&
aDisplayRect
const
IntRegion
&
aUpdateRegion
gfx
:
:
BackendType
aBackendType
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
NextSurface
(
lock
)
)
{
return
nullptr
;
}
mInProgressLockedIOSurface
=
new
MacIOSurface
(
mInProgressSurface
-
>
mSurface
)
;
mInProgressLockedIOSurface
-
>
Lock
(
false
)
;
RefPtr
<
gfx
:
:
DrawTarget
>
dt
=
mInProgressLockedIOSurface
-
>
GetAsDrawTargetLocked
(
aBackendType
)
;
HandlePartialUpdate
(
lock
aDisplayRect
aUpdateRegion
[
&
]
(
CFTypeRefPtr
<
IOSurfaceRef
>
validSource
const
gfx
:
:
IntRegion
&
copyRegion
)
{
RefPtr
<
MacIOSurface
>
source
=
new
MacIOSurface
(
validSource
)
;
source
-
>
Lock
(
true
)
;
{
RefPtr
<
gfx
:
:
DrawTarget
>
sourceDT
=
source
-
>
GetAsDrawTargetLocked
(
aBackendType
)
;
RefPtr
<
gfx
:
:
SourceSurface
>
sourceSurface
=
sourceDT
-
>
Snapshot
(
)
;
for
(
auto
iter
=
copyRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
gfx
:
:
IntRect
&
r
=
iter
.
Get
(
)
;
dt
-
>
CopySurface
(
sourceSurface
r
r
.
TopLeft
(
)
)
;
}
}
source
-
>
Unlock
(
true
)
;
}
)
;
return
dt
;
}
Maybe
<
GLuint
>
NativeLayerCA
:
:
NextSurfaceAsFramebuffer
(
const
IntRect
&
aDisplayRect
const
IntRegion
&
aUpdateRegion
bool
aNeedsDepth
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
NextSurface
(
lock
)
)
{
return
Nothing
(
)
;
}
Maybe
<
GLuint
>
fbo
=
mSurfacePoolHandle
-
>
GetFramebufferForSurface
(
mInProgressSurface
-
>
mSurface
aNeedsDepth
)
;
if
(
!
fbo
)
{
return
Nothing
(
)
;
}
HandlePartialUpdate
(
lock
aDisplayRect
aUpdateRegion
[
&
]
(
CFTypeRefPtr
<
IOSurfaceRef
>
validSource
const
gfx
:
:
IntRegion
&
copyRegion
)
{
MOZ_RELEASE_ASSERT
(
mSurfacePoolHandle
-
>
gl
(
)
)
;
mSurfacePoolHandle
-
>
gl
(
)
-
>
MakeCurrent
(
)
;
Maybe
<
GLuint
>
sourceFBO
=
mSurfacePoolHandle
-
>
GetFramebufferForSurface
(
validSource
false
)
;
if
(
!
sourceFBO
)
{
return
;
}
for
(
auto
iter
=
copyRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
gfx
:
:
IntRect
r
=
iter
.
Get
(
)
;
if
(
mSurfaceIsFlipped
)
{
r
.
y
=
mSize
.
height
-
r
.
YMost
(
)
;
}
mSurfacePoolHandle
-
>
gl
(
)
-
>
BlitHelper
(
)
-
>
BlitFramebufferToFramebuffer
(
*
sourceFBO
*
fbo
r
r
LOCAL_GL_NEAREST
)
;
}
}
)
;
return
fbo
;
}
void
NativeLayerCA
:
:
NotifySurfaceReady
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_RELEASE_ASSERT
(
mInProgressSurface
"
NotifySurfaceReady
called
without
preceding
call
to
NextSurface
"
)
;
if
(
mInProgressLockedIOSurface
)
{
mInProgressLockedIOSurface
-
>
Unlock
(
false
)
;
mInProgressLockedIOSurface
=
nullptr
;
}
if
(
mFrontSurface
)
{
mSurfaces
.
push_back
(
{
*
mFrontSurface
0
}
)
;
mFrontSurface
=
Nothing
(
)
;
}
MOZ_RELEASE_ASSERT
(
mInProgressUpdateRegion
)
;
IOSurfaceDecrementUseCount
(
mInProgressSurface
-
>
mSurface
.
get
(
)
)
;
mFrontSurface
=
std
:
:
move
(
mInProgressSurface
)
;
mFrontSurface
-
>
mInvalidRegion
.
SubOut
(
mInProgressUpdateRegion
.
extract
(
)
)
;
ForAllRepresentations
(
[
&
]
(
Representation
&
r
)
{
r
.
mMutatedFrontSurface
=
true
;
}
)
;
MOZ_RELEASE_ASSERT
(
mInProgressDisplayRect
)
;
if
(
!
mDisplayRect
.
IsEqualInterior
(
*
mInProgressDisplayRect
)
)
{
mDisplayRect
=
*
mInProgressDisplayRect
;
ForAllRepresentations
(
[
&
]
(
Representation
&
r
)
{
r
.
mMutatedDisplayRect
=
true
;
}
)
;
}
mInProgressDisplayRect
=
Nothing
(
)
;
MOZ_RELEASE_ASSERT
(
mFrontSurface
-
>
mInvalidRegion
.
Intersect
(
mDisplayRect
)
.
IsEmpty
(
)
"
Parts
of
the
display
rect
are
invalid
!
This
shouldn
'
t
happen
.
"
)
;
}
void
NativeLayerCA
:
:
DiscardBackbuffers
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
for
(
const
auto
&
surf
:
mSurfaces
)
{
mSurfacePoolHandle
-
>
ReturnSurfaceToPool
(
surf
.
mEntry
.
mSurface
)
;
}
mSurfaces
.
clear
(
)
;
}
NativeLayerCA
:
:
Representation
&
NativeLayerCA
:
:
GetRepresentation
(
WhichRepresentation
aRepresentation
)
{
switch
(
aRepresentation
)
{
case
WhichRepresentation
:
:
ONSCREEN
:
return
mOnscreenRepresentation
;
case
WhichRepresentation
:
:
OFFSCREEN
:
return
mOffscreenRepresentation
;
}
}
template
<
typename
F
>
void
NativeLayerCA
:
:
ForAllRepresentations
(
F
aFn
)
{
aFn
(
mOnscreenRepresentation
)
;
aFn
(
mOffscreenRepresentation
)
;
}
void
NativeLayerCA
:
:
ApplyChanges
(
WhichRepresentation
aRepresentation
)
{
MutexAutoLock
lock
(
mMutex
)
;
GetRepresentation
(
aRepresentation
)
.
ApplyChanges
(
mSize
mIsOpaque
mPosition
mDisplayRect
mClipRect
mBackingScale
mSurfaceIsFlipped
mFrontSurface
?
mFrontSurface
-
>
mSurface
:
nullptr
)
;
}
CALayer
*
NativeLayerCA
:
:
UnderlyingCALayer
(
WhichRepresentation
aRepresentation
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
GetRepresentation
(
aRepresentation
)
.
UnderlyingCALayer
(
)
;
}
void
NativeLayerCA
:
:
Representation
:
:
ApplyChanges
(
const
IntSize
&
aSize
bool
aIsOpaque
const
IntPoint
&
aPosition
const
IntRect
&
aDisplayRect
const
Maybe
<
IntRect
>
&
aClipRect
float
aBackingScale
bool
aSurfaceIsFlipped
CFTypeRefPtr
<
IOSurfaceRef
>
aFrontSurface
)
{
if
(
!
mWrappingCALayer
)
{
mWrappingCALayer
=
[
[
CALayer
layer
]
retain
]
;
mWrappingCALayer
.
position
=
NSZeroPoint
;
mWrappingCALayer
.
bounds
=
NSZeroRect
;
mWrappingCALayer
.
anchorPoint
=
NSZeroPoint
;
mWrappingCALayer
.
contentsGravity
=
kCAGravityTopLeft
;
mContentCALayer
=
[
[
CALayer
layer
]
retain
]
;
mContentCALayer
.
position
=
NSZeroPoint
;
mContentCALayer
.
anchorPoint
=
NSZeroPoint
;
mContentCALayer
.
contentsGravity
=
kCAGravityTopLeft
;
mContentCALayer
.
contentsScale
=
1
;
mContentCALayer
.
bounds
=
CGRectMake
(
0
0
aSize
.
width
aSize
.
height
)
;
mContentCALayer
.
opaque
=
aIsOpaque
;
if
(
[
mContentCALayer
respondsToSelector
:
selector
(
setContentsOpaque
:
)
]
)
{
[
mContentCALayer
setContentsOpaque
:
aIsOpaque
]
;
}
[
mWrappingCALayer
addSublayer
:
mContentCALayer
]
;
}
bool
shouldTintOpaqueness
=
StaticPrefs
:
:
gfx_core_animation_tint_opaque
(
)
;
if
(
shouldTintOpaqueness
&
&
!
mOpaquenessTintLayer
)
{
mOpaquenessTintLayer
=
[
[
CALayer
layer
]
retain
]
;
mOpaquenessTintLayer
.
position
=
mContentCALayer
.
position
;
mOpaquenessTintLayer
.
bounds
=
mContentCALayer
.
bounds
;
mOpaquenessTintLayer
.
anchorPoint
=
NSZeroPoint
;
mOpaquenessTintLayer
.
contentsGravity
=
kCAGravityTopLeft
;
if
(
aIsOpaque
)
{
mOpaquenessTintLayer
.
backgroundColor
=
[
[
[
NSColor
greenColor
]
colorWithAlphaComponent
:
0
.
5
]
CGColor
]
;
}
else
{
mOpaquenessTintLayer
.
backgroundColor
=
[
[
[
NSColor
redColor
]
colorWithAlphaComponent
:
0
.
5
]
CGColor
]
;
}
[
mWrappingCALayer
addSublayer
:
mOpaquenessTintLayer
]
;
}
else
if
(
!
shouldTintOpaqueness
&
&
mOpaquenessTintLayer
)
{
[
mOpaquenessTintLayer
removeFromSuperlayer
]
;
[
mOpaquenessTintLayer
release
]
;
mOpaquenessTintLayer
=
nullptr
;
}
if
(
mMutatedBackingScale
)
{
mContentCALayer
.
bounds
=
CGRectMake
(
0
0
aSize
.
width
/
aBackingScale
aSize
.
height
/
aBackingScale
)
;
if
(
mOpaquenessTintLayer
)
{
mOpaquenessTintLayer
.
bounds
=
mContentCALayer
.
bounds
;
}
mContentCALayer
.
contentsScale
=
aBackingScale
;
}
if
(
mMutatedBackingScale
|
|
mMutatedPosition
|
|
mMutatedDisplayRect
|
|
mMutatedClipRect
)
{
auto
clipFromDisplayRect
=
aDisplayRect
.
IsEqualInterior
(
IntRect
(
{
}
aSize
)
)
?
Nothing
(
)
:
Some
(
aDisplayRect
+
aPosition
)
;
auto
effectiveClip
=
IntersectMaybeRects
(
aClipRect
clipFromDisplayRect
)
;
auto
globalClipOrigin
=
effectiveClip
?
effectiveClip
-
>
TopLeft
(
)
:
aPosition
;
auto
globalLayerOrigin
=
aPosition
;
auto
clipToLayerOffset
=
globalLayerOrigin
-
globalClipOrigin
;
mWrappingCALayer
.
position
=
CGPointMake
(
globalClipOrigin
.
x
/
aBackingScale
globalClipOrigin
.
y
/
aBackingScale
)
;
if
(
effectiveClip
)
{
mWrappingCALayer
.
masksToBounds
=
YES
;
mWrappingCALayer
.
bounds
=
CGRectMake
(
0
0
effectiveClip
-
>
Width
(
)
/
aBackingScale
effectiveClip
-
>
Height
(
)
/
aBackingScale
)
;
}
else
{
mWrappingCALayer
.
masksToBounds
=
NO
;
}
mContentCALayer
.
position
=
CGPointMake
(
clipToLayerOffset
.
x
/
aBackingScale
clipToLayerOffset
.
y
/
aBackingScale
)
;
if
(
mOpaquenessTintLayer
)
{
mOpaquenessTintLayer
.
position
=
mContentCALayer
.
position
;
}
}
if
(
mMutatedBackingScale
|
|
mMutatedSurfaceIsFlipped
)
{
if
(
aSurfaceIsFlipped
)
{
CGFloat
height
=
aSize
.
height
/
aBackingScale
;
mContentCALayer
.
affineTransform
=
CGAffineTransformMake
(
1
.
0
0
.
0
0
.
0
-
1
.
0
0
.
0
height
)
;
}
else
{
mContentCALayer
.
affineTransform
=
CGAffineTransformIdentity
;
}
}
if
(
mMutatedFrontSurface
)
{
mContentCALayer
.
contents
=
(
id
)
aFrontSurface
.
get
(
)
;
}
mMutatedPosition
=
false
;
mMutatedBackingScale
=
false
;
mMutatedSurfaceIsFlipped
=
false
;
mMutatedDisplayRect
=
false
;
mMutatedClipRect
=
false
;
mMutatedFrontSurface
=
false
;
}
Maybe
<
NativeLayerCA
:
:
SurfaceWithInvalidRegion
>
NativeLayerCA
:
:
GetUnusedSurfaceAndCleanUp
(
const
MutexAutoLock
&
)
{
std
:
:
vector
<
SurfaceWithInvalidRegionAndCheckCount
>
usedSurfaces
;
Maybe
<
SurfaceWithInvalidRegion
>
unusedSurface
;
for
(
auto
&
surf
:
mSurfaces
)
{
if
(
IOSurfaceIsInUse
(
surf
.
mEntry
.
mSurface
.
get
(
)
)
)
{
surf
.
mCheckCount
+
+
;
if
(
surf
.
mCheckCount
<
10
)
{
usedSurfaces
.
push_back
(
std
:
:
move
(
surf
)
)
;
}
else
{
mSurfacePoolHandle
-
>
ReturnSurfaceToPool
(
std
:
:
move
(
surf
.
mEntry
.
mSurface
)
)
;
}
}
else
{
if
(
unusedSurface
)
{
mSurfacePoolHandle
-
>
ReturnSurfaceToPool
(
std
:
:
move
(
unusedSurface
-
>
mSurface
)
)
;
}
unusedSurface
=
Some
(
std
:
:
move
(
surf
.
mEntry
)
)
;
}
}
mSurfaces
=
std
:
:
move
(
usedSurfaces
)
;
return
unusedSurface
;
}
}
}
