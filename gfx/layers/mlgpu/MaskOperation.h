#
ifndef
mozilla_gfx_layers_mlgpu_MaskOperation_h
#
define
mozilla_gfx_layers_mlgpu_MaskOperation_h
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
SharedBufferMLGPU
.
h
"
#
include
<
vector
>
namespace
mozilla
{
namespace
layers
{
class
FrameBuilder
;
class
Layer
;
class
MLGDevice
;
class
MLGRenderTarget
;
class
MLGTexture
;
class
TextureSource
;
class
MaskOperation
{
NS_INLINE_DECL_REFCOUNTING
(
MaskOperation
)
public
:
MaskOperation
(
FrameBuilder
*
aBuilder
MLGTexture
*
aSource
)
;
virtual
gfx
:
:
Rect
ComputeMaskRect
(
Layer
*
aLayer
)
const
;
MLGTexture
*
GetTexture
(
)
const
{
return
mTexture
;
}
bool
IsEmpty
(
)
const
{
return
!
mTexture
;
}
protected
:
explicit
MaskOperation
(
FrameBuilder
*
aBuilder
)
;
virtual
~
MaskOperation
(
)
;
protected
:
RefPtr
<
MLGTexture
>
mTexture
;
}
;
struct
MaskTexture
{
MaskTexture
(
)
:
mSource
(
nullptr
)
{
}
MaskTexture
(
const
gfx
:
:
Rect
&
aRect
TextureSource
*
aSource
)
:
mRect
(
aRect
)
mSource
(
aSource
)
{
}
bool
operator
<
(
const
MaskTexture
&
aOther
)
const
;
gfx
:
:
Rect
mRect
;
RefPtr
<
TextureSource
>
mSource
;
}
;
typedef
std
:
:
vector
<
MaskTexture
>
MaskTextureList
;
class
MaskCombineOperation
final
:
public
MaskOperation
{
public
:
explicit
MaskCombineOperation
(
FrameBuilder
*
aBuilder
)
;
~
MaskCombineOperation
(
)
override
;
void
Init
(
const
MaskTextureList
&
aTextures
)
;
void
PrepareForRendering
(
)
;
void
Render
(
)
;
gfx
:
:
Rect
ComputeMaskRect
(
Layer
*
aLayer
)
const
override
{
return
mArea
;
}
private
:
FrameBuilder
*
mBuilder
;
gfx
:
:
Rect
mArea
;
MaskTextureList
mTextures
;
RefPtr
<
MLGRenderTarget
>
mTarget
;
std
:
:
vector
<
VertexBufferSection
>
mInputBuffers
;
}
;
RefPtr
<
TextureSource
>
GetMaskLayerTexture
(
Layer
*
aLayer
)
;
void
AppendToMaskTextureList
(
MaskTextureList
&
aList
Layer
*
aLayer
)
;
}
}
#
endif
