#
include
"
FrameBuilder
.
h
"
#
include
"
ContainerLayerMLGPU
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
LayerMLGPU
.
h
"
#
include
"
LayerManagerMLGPU
.
h
"
#
include
"
MaskOperation
.
h
"
#
include
"
MLGDevice
.
h
"
#
include
"
RenderPassMLGPU
.
h
"
#
include
"
RenderViewMLGPU
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
mozilla
/
gfx
/
Polygon
.
h
"
#
include
"
mozilla
/
layers
/
BSPTree
.
h
"
#
include
"
mozilla
/
layers
/
LayersHelpers
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
mlg
;
FrameBuilder
:
:
FrameBuilder
(
LayerManagerMLGPU
*
aManager
MLGSwapChain
*
aSwapChain
)
:
mManager
(
aManager
)
mDevice
(
aManager
-
>
GetDevice
(
)
)
mSwapChain
(
aSwapChain
)
{
mRoot
=
mManager
-
>
GetRoot
(
)
-
>
AsHostLayer
(
)
-
>
AsLayerMLGPU
(
)
;
}
FrameBuilder
:
:
~
FrameBuilder
(
)
{
}
bool
FrameBuilder
:
:
Build
(
)
{
AUTO_PROFILER_LABEL
(
"
FrameBuilder
:
:
Build
"
GRAPHICS
)
;
RefPtr
<
MLGRenderTarget
>
target
=
mSwapChain
-
>
AcquireBackBuffer
(
)
;
if
(
!
target
)
{
return
false
;
}
LayerMLGPU
:
:
BeginFrame
(
)
;
const
nsIntRegion
&
region
=
mSwapChain
-
>
GetBackBufferInvalidRegion
(
)
;
mWidgetRenderView
=
new
RenderViewMLGPU
(
this
target
region
)
;
if
(
ContainerLayerMLGPU
*
root
=
mRoot
-
>
AsLayerMLGPU
(
)
-
>
AsContainerLayerMLGPU
(
)
)
{
root
-
>
ComputeIntermediateSurfaceBounds
(
)
;
}
{
Maybe
<
gfx
:
:
Polygon
>
geometry
;
RenderTargetIntRect
clip
(
0
0
target
-
>
GetSize
(
)
.
width
target
-
>
GetSize
(
)
.
height
)
;
AssignLayer
(
mRoot
-
>
GetLayer
(
)
mWidgetRenderView
clip
std
:
:
move
(
geometry
)
)
;
}
{
MaskInformation
defaultMaskInfo
(
1
.
0f
false
)
;
if
(
!
mDevice
-
>
GetSharedPSBuffer
(
)
-
>
Allocate
(
&
mDefaultMaskInfo
defaultMaskInfo
)
)
{
return
false
;
}
}
mWidgetRenderView
-
>
FinishBuilding
(
)
;
mWidgetRenderView
-
>
Prepare
(
)
;
for
(
const
auto
&
pair
:
mCombinedTextureMasks
)
{
pair
.
second
-
>
PrepareForRendering
(
)
;
}
FinishCurrentLayerBuffer
(
)
;
FinishCurrentMaskRectBuffer
(
)
;
return
true
;
}
void
FrameBuilder
:
:
Render
(
)
{
AUTO_PROFILER_LABEL
(
"
FrameBuilder
:
:
Render
"
GRAPHICS
)
;
for
(
const
auto
&
pair
:
mCombinedTextureMasks
)
{
pair
.
second
-
>
Render
(
)
;
}
mWidgetRenderView
-
>
Render
(
)
;
}
void
FrameBuilder
:
:
AssignLayer
(
Layer
*
aLayer
RenderViewMLGPU
*
aView
const
RenderTargetIntRect
&
aClipRect
Maybe
<
gfx
:
:
Polygon
>
&
&
aGeometry
)
{
LayerMLGPU
*
layer
=
aLayer
-
>
AsHostLayer
(
)
-
>
AsLayerMLGPU
(
)
;
if
(
ContainerLayer
*
container
=
aLayer
-
>
AsContainerLayer
(
)
)
{
if
(
!
ProcessContainerLayer
(
container
aView
aClipRect
aGeometry
)
)
{
return
;
}
}
else
{
if
(
!
layer
-
>
PrepareToRender
(
this
aClipRect
)
)
{
return
;
}
}
if
(
aGeometry
)
{
TransformLayerGeometry
(
aLayer
aGeometry
)
;
}
layer
-
>
AssignToView
(
this
aView
std
:
:
move
(
aGeometry
)
)
;
}
bool
FrameBuilder
:
:
ProcessContainerLayer
(
ContainerLayer
*
aContainer
RenderViewMLGPU
*
aView
const
RenderTargetIntRect
&
aClipRect
Maybe
<
gfx
:
:
Polygon
>
&
aGeometry
)
{
LayerMLGPU
*
layer
=
aContainer
-
>
AsHostLayer
(
)
-
>
AsLayerMLGPU
(
)
;
if
(
!
layer
)
{
gfxDevCrash
(
gfx
:
:
LogReason
:
:
InvalidLayerType
)
<
<
"
Layer
type
is
invalid
:
"
<
<
aContainer
-
>
Name
(
)
;
return
false
;
}
bool
isFirstVisit
=
!
layer
-
>
IsPrepared
(
)
;
if
(
isFirstVisit
&
&
!
layer
-
>
PrepareToRender
(
this
aClipRect
)
)
{
return
false
;
}
if
(
!
aContainer
-
>
UseIntermediateSurface
(
)
)
{
layer
-
>
ClearCachedResources
(
)
;
ProcessChildList
(
aContainer
aView
aClipRect
aGeometry
)
;
return
false
;
}
ContainerLayerMLGPU
*
viewContainer
=
layer
-
>
AsContainerLayerMLGPU
(
)
;
if
(
!
viewContainer
)
{
gfxDevCrash
(
gfx
:
:
LogReason
:
:
InvalidLayerType
)
<
<
"
Container
layer
type
is
invalid
:
"
<
<
aContainer
-
>
Name
(
)
;
return
false
;
}
if
(
isFirstVisit
&
&
!
viewContainer
-
>
GetInvalidRect
(
)
.
IsEmpty
(
)
)
{
RefPtr
<
RenderViewMLGPU
>
view
=
new
RenderViewMLGPU
(
this
viewContainer
aView
)
;
ProcessChildList
(
aContainer
view
aClipRect
Nothing
(
)
)
;
view
-
>
FinishBuilding
(
)
;
}
return
true
;
}
void
FrameBuilder
:
:
ProcessChildList
(
ContainerLayer
*
aContainer
RenderViewMLGPU
*
aView
const
RenderTargetIntRect
&
aParentClipRect
const
Maybe
<
gfx
:
:
Polygon
>
&
aParentGeometry
)
{
nsTArray
<
LayerPolygon
>
polygons
=
aContainer
-
>
SortChildrenBy3DZOrder
(
ContainerLayer
:
:
SortMode
:
:
WITH_GEOMETRY
)
;
for
(
auto
iter
=
polygons
.
rbegin
(
)
;
iter
!
=
polygons
.
rend
(
)
;
iter
+
+
)
{
LayerPolygon
&
entry
=
*
iter
;
Layer
*
child
=
entry
.
layer
;
if
(
child
-
>
IsBackfaceHidden
(
)
|
|
!
child
-
>
IsVisible
(
)
)
{
continue
;
}
RenderTargetIntRect
clip
=
child
-
>
CalculateScissorRect
(
aParentClipRect
)
;
if
(
clip
.
IsEmpty
(
)
)
{
continue
;
}
Maybe
<
gfx
:
:
Polygon
>
geometry
;
if
(
aParentGeometry
&
&
entry
.
geometry
)
{
geometry
=
Some
(
aParentGeometry
-
>
ClipPolygon
(
*
entry
.
geometry
)
)
;
}
else
if
(
aParentGeometry
)
{
geometry
=
aParentGeometry
;
}
else
if
(
entry
.
geometry
)
{
geometry
=
std
:
:
move
(
entry
.
geometry
)
;
}
AssignLayer
(
child
aView
clip
std
:
:
move
(
geometry
)
)
;
}
}
bool
FrameBuilder
:
:
AddLayerToConstantBuffer
(
ItemInfo
&
aItem
)
{
LayerMLGPU
*
layer
=
aItem
.
layer
;
if
(
aItem
.
geometry
)
{
if
(
mLayerBufferMap
.
Get
(
layer
&
aItem
.
layerIndex
)
)
{
return
true
;
}
}
LayerConstants
*
info
=
AllocateLayerInfo
(
aItem
)
;
if
(
!
info
)
{
return
false
;
}
Layer
*
baseLayer
=
layer
-
>
GetLayer
(
)
;
const
gfx
:
:
Matrix4x4
&
transform
=
baseLayer
-
>
GetEffectiveTransform
(
)
;
memcpy
(
&
info
-
>
transform
&
transform
.
_11
64
)
;
info
-
>
clipRect
=
gfx
:
:
Rect
(
layer
-
>
GetComputedClipRect
(
)
.
ToUnknownRect
(
)
)
;
info
-
>
maskIndex
=
0
;
if
(
MaskOperation
*
op
=
layer
-
>
GetMask
(
)
)
{
gfx
:
:
Rect
rect
=
op
-
>
ComputeMaskRect
(
baseLayer
)
;
AddMaskRect
(
rect
&
info
-
>
maskIndex
)
;
}
if
(
aItem
.
geometry
)
{
mLayerBufferMap
.
Put
(
layer
aItem
.
layerIndex
)
;
}
return
true
;
}
MaskOperation
*
FrameBuilder
:
:
AddMaskOperation
(
LayerMLGPU
*
aLayer
)
{
Layer
*
layer
=
aLayer
-
>
GetLayer
(
)
;
MOZ_ASSERT
(
layer
-
>
HasMaskLayers
(
)
)
;
if
(
(
layer
-
>
GetMaskLayer
(
)
&
&
layer
-
>
GetAncestorMaskLayerCount
(
)
)
|
|
layer
-
>
GetAncestorMaskLayerCount
(
)
>
1
)
{
MaskTextureList
textures
;
if
(
Layer
*
maskLayer
=
layer
-
>
GetMaskLayer
(
)
)
{
AppendToMaskTextureList
(
textures
maskLayer
)
;
}
for
(
size_t
i
=
0
;
i
<
layer
-
>
GetAncestorMaskLayerCount
(
)
;
i
+
+
)
{
AppendToMaskTextureList
(
textures
layer
-
>
GetAncestorMaskLayerAt
(
i
)
)
;
}
auto
iter
=
mCombinedTextureMasks
.
find
(
textures
)
;
if
(
iter
!
=
mCombinedTextureMasks
.
end
(
)
)
{
return
iter
-
>
second
;
}
RefPtr
<
MaskCombineOperation
>
op
=
new
MaskCombineOperation
(
this
)
;
op
-
>
Init
(
textures
)
;
mCombinedTextureMasks
[
textures
]
=
op
;
return
op
;
}
Layer
*
maskLayer
=
layer
-
>
GetMaskLayer
(
)
?
layer
-
>
GetMaskLayer
(
)
:
layer
-
>
GetAncestorMaskLayerAt
(
0
)
;
RefPtr
<
TextureSource
>
texture
=
GetMaskLayerTexture
(
maskLayer
)
;
if
(
!
texture
)
{
return
nullptr
;
}
RefPtr
<
MaskOperation
>
op
;
mSingleTextureMasks
.
Get
(
texture
getter_AddRefs
(
op
)
)
;
if
(
op
)
{
return
op
;
}
RefPtr
<
MLGTexture
>
wrapped
=
mDevice
-
>
CreateTexture
(
texture
)
;
op
=
new
MaskOperation
(
this
wrapped
)
;
mSingleTextureMasks
.
Put
(
texture
op
)
;
return
op
;
}
void
FrameBuilder
:
:
RetainTemporaryLayer
(
LayerMLGPU
*
aLayer
)
{
MOZ_ASSERT
(
!
aLayer
-
>
GetLayer
(
)
-
>
GetParent
(
)
)
;
mTemporaryLayers
.
push_back
(
aLayer
-
>
GetLayer
(
)
)
;
}
MLGRenderTarget
*
FrameBuilder
:
:
GetWidgetRT
(
)
{
return
mWidgetRenderView
-
>
GetRenderTarget
(
)
;
}
LayerConstants
*
FrameBuilder
:
:
AllocateLayerInfo
(
ItemInfo
&
aItem
)
{
if
(
(
(
mCurrentLayerBuffer
.
Length
(
)
+
1
)
*
sizeof
(
LayerConstants
)
)
>
mDevice
-
>
GetMaxConstantBufferBindSize
(
)
)
{
FinishCurrentLayerBuffer
(
)
;
mLayerBufferMap
.
Clear
(
)
;
mCurrentLayerBuffer
.
ClearAndRetainStorage
(
)
;
}
LayerConstants
*
info
=
mCurrentLayerBuffer
.
AppendElement
(
mozilla
:
:
fallible
)
;
if
(
!
info
)
{
return
nullptr
;
}
aItem
.
layerIndex
=
mCurrentLayerBuffer
.
Length
(
)
-
1
;
return
info
;
}
void
FrameBuilder
:
:
FinishCurrentLayerBuffer
(
)
{
if
(
mCurrentLayerBuffer
.
IsEmpty
(
)
)
{
return
;
}
ConstantBufferSection
section
;
mDevice
-
>
GetSharedVSBuffer
(
)
-
>
Allocate
(
&
section
mCurrentLayerBuffer
.
Elements
(
)
mCurrentLayerBuffer
.
Length
(
)
)
;
mLayerBuffers
.
AppendElement
(
section
)
;
}
size_t
FrameBuilder
:
:
CurrentLayerBufferIndex
(
)
const
{
return
mLayerBuffers
.
Length
(
)
;
}
ConstantBufferSection
FrameBuilder
:
:
GetLayerBufferByIndex
(
size_t
aIndex
)
const
{
if
(
aIndex
>
=
mLayerBuffers
.
Length
(
)
)
{
return
ConstantBufferSection
(
)
;
}
return
mLayerBuffers
[
aIndex
]
;
}
bool
FrameBuilder
:
:
AddMaskRect
(
const
gfx
:
:
Rect
&
aRect
uint32_t
*
aOutIndex
)
{
if
(
(
(
mCurrentMaskRectList
.
Length
(
)
+
1
)
*
sizeof
(
gfx
:
:
Rect
)
)
>
mDevice
-
>
GetMaxConstantBufferBindSize
(
)
)
{
FinishCurrentMaskRectBuffer
(
)
;
mCurrentMaskRectList
.
ClearAndRetainStorage
(
)
;
}
mCurrentMaskRectList
.
AppendElement
(
aRect
)
;
*
aOutIndex
=
mCurrentMaskRectList
.
Length
(
)
;
return
true
;
}
void
FrameBuilder
:
:
FinishCurrentMaskRectBuffer
(
)
{
if
(
mCurrentMaskRectList
.
IsEmpty
(
)
)
{
return
;
}
ConstantBufferSection
section
;
mDevice
-
>
GetSharedVSBuffer
(
)
-
>
Allocate
(
&
section
mCurrentMaskRectList
.
Elements
(
)
mCurrentMaskRectList
.
Length
(
)
)
;
mMaskRectBuffers
.
AppendElement
(
section
)
;
}
size_t
FrameBuilder
:
:
CurrentMaskRectBufferIndex
(
)
const
{
return
mMaskRectBuffers
.
Length
(
)
;
}
ConstantBufferSection
FrameBuilder
:
:
GetMaskRectBufferByIndex
(
size_t
aIndex
)
const
{
if
(
aIndex
>
=
mMaskRectBuffers
.
Length
(
)
)
{
return
ConstantBufferSection
(
)
;
}
return
mMaskRectBuffers
[
aIndex
]
;
}
}
}
