#
include
"
BufferCache
.
h
"
#
include
"
MLGDevice
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
namespace
mozilla
{
namespace
layers
{
BufferCache
:
:
BufferCache
(
MLGDevice
*
aDevice
)
:
mDevice
(
aDevice
)
{
}
BufferCache
:
:
~
BufferCache
(
)
{
}
RefPtr
<
MLGBuffer
>
BufferCache
:
:
GetOrCreateBuffer
(
size_t
aBytes
)
{
RefPtr
<
MLGBuffer
>
buffer
=
mExpired
.
Take
(
aBytes
)
;
if
(
!
buffer
)
{
size_t
roundedUp
=
std
:
:
max
(
std
:
:
min
(
RoundUpPow2
(
aBytes
)
size_t
(
1024
)
)
aBytes
)
;
buffer
=
mDevice
-
>
CreateBuffer
(
MLGBufferType
:
:
Constant
roundedUp
MLGUsage
:
:
Dynamic
nullptr
)
;
if
(
!
buffer
)
{
return
nullptr
;
}
}
MOZ_ASSERT
(
buffer
-
>
GetSize
(
)
>
=
aBytes
)
;
mCurrent
.
Put
(
buffer
)
;
return
buffer
;
}
void
BufferCache
:
:
EndFrame
(
)
{
BufferPool
empty
;
mExpired
=
Move
(
mPrevious
)
;
mPrevious
=
Move
(
mCurrent
)
;
mCurrent
=
Move
(
empty
)
;
}
RefPtr
<
MLGBuffer
>
BufferPool
:
:
Take
(
size_t
aBytes
)
{
MOZ_ASSERT
(
aBytes
>
=
16
)
;
SizeClass
sc
=
GetSizeClassFromHighBit
(
CeilingLog2
(
aBytes
)
)
;
if
(
sc
=
=
SizeClass
:
:
Huge
)
{
return
TakeHugeBuffer
(
aBytes
)
;
}
if
(
mClasses
[
sc
]
.
IsEmpty
(
)
)
{
return
nullptr
;
}
RefPtr
<
MLGBuffer
>
buffer
=
mClasses
[
sc
]
.
LastElement
(
)
;
mClasses
[
sc
]
.
RemoveElementAt
(
mClasses
[
sc
]
.
Length
(
)
-
1
)
;
return
buffer
.
forget
(
)
;
}
void
BufferPool
:
:
Put
(
MLGBuffer
*
aBuffer
)
{
MOZ_ASSERT
(
aBuffer
-
>
GetSize
(
)
>
=
16
)
;
SizeClass
sc
=
GetSizeClassFromHighBit
(
FloorLog2
(
aBuffer
-
>
GetSize
(
)
)
)
;
if
(
sc
=
=
SizeClass
:
:
Huge
)
{
mHugeBuffers
.
push_back
(
aBuffer
)
;
}
else
{
mClasses
[
sc
]
.
AppendElement
(
aBuffer
)
;
}
}
RefPtr
<
MLGBuffer
>
BufferPool
:
:
TakeHugeBuffer
(
size_t
aBytes
)
{
static
const
size_t
kMaxSearches
=
3
;
size_t
numSearches
=
std
:
:
min
(
kMaxSearches
mHugeBuffers
.
size
(
)
)
;
for
(
size_t
i
=
0
;
i
<
numSearches
;
i
+
+
)
{
RefPtr
<
MLGBuffer
>
buffer
=
mHugeBuffers
.
front
(
)
;
mHugeBuffers
.
pop_front
(
)
;
if
(
buffer
-
>
GetSize
(
)
>
=
aBytes
&
&
buffer
-
>
GetSize
(
)
<
=
aBytes
*
2
)
{
return
buffer
.
forget
(
)
;
}
mHugeBuffers
.
push_back
(
buffer
)
;
}
return
nullptr
;
}
BufferPool
:
:
SizeClass
BufferPool
:
:
GetSizeClassFromHighBit
(
size_t
aBit
)
{
static
const
size_t
kBitForFirstClass
=
4
;
static
const
size_t
kBitForLastClass
=
kBitForFirstClass
+
size_t
(
SizeClass
:
:
Huge
)
;
if
(
aBit
<
kBitForFirstClass
|
|
aBit
>
=
kBitForLastClass
)
{
return
SizeClass
:
:
Huge
;
}
return
SizeClass
(
aBit
-
kBitForFirstClass
)
;
}
}
}
