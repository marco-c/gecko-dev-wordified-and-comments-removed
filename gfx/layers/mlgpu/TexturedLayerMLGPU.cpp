#
include
"
TexturedLayerMLGPU
.
h
"
#
include
"
LayerManagerMLGPU
.
h
"
#
include
"
RenderViewMLGPU
.
h
"
#
include
"
FrameBuilder
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
ImageHost
.
h
"
#
include
"
UnitTransforms
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
gfx
;
TexturedLayerMLGPU
:
:
TexturedLayerMLGPU
(
LayerManagerMLGPU
*
aManager
)
:
LayerMLGPU
(
aManager
)
{
}
TexturedLayerMLGPU
:
:
~
TexturedLayerMLGPU
(
)
{
}
bool
TexturedLayerMLGPU
:
:
SetCompositableHost
(
CompositableHost
*
aHost
)
{
switch
(
aHost
-
>
GetType
(
)
)
{
case
CompositableType
:
:
IMAGE
:
mHost
=
aHost
-
>
AsImageHost
(
)
;
return
true
;
default
:
return
false
;
}
}
CompositableHost
*
TexturedLayerMLGPU
:
:
GetCompositableHost
(
)
{
if
(
mHost
&
&
mHost
-
>
IsAttached
(
)
)
{
return
mHost
.
get
(
)
;
}
return
nullptr
;
}
RefPtr
<
TextureSource
>
TexturedLayerMLGPU
:
:
BindAndGetTexture
(
)
{
if
(
!
mHost
)
{
return
nullptr
;
}
LayerManagerMLGPU
*
lm
=
GetLayerManager
(
)
-
>
AsLayerManagerMLGPU
(
)
;
ImageHost
:
:
RenderInfo
info
;
if
(
!
mHost
-
>
PrepareToRender
(
lm
-
>
GetTextureSourceProvider
(
)
&
info
)
)
{
return
nullptr
;
}
RefPtr
<
TextureSource
>
source
=
mHost
-
>
AcquireTextureSource
(
info
)
;
if
(
!
source
)
{
return
nullptr
;
}
mTexture
=
source
;
return
source
;
}
bool
TexturedLayerMLGPU
:
:
OnPrepareToRender
(
FrameBuilder
*
aBuilder
)
{
if
(
!
mHost
)
{
return
false
;
}
LayerManagerMLGPU
*
lm
=
GetLayerManager
(
)
-
>
AsLayerManagerMLGPU
(
)
;
ImageHost
:
:
RenderInfo
info
;
if
(
!
mHost
-
>
PrepareToRender
(
lm
-
>
GetTextureSourceProvider
(
)
&
info
)
)
{
return
false
;
}
RefPtr
<
TextureSource
>
source
=
mHost
-
>
AcquireTextureSource
(
info
)
;
if
(
!
source
)
{
return
false
;
}
if
(
source
-
>
AsBigImageIterator
(
)
)
{
mBigImageTexture
=
source
;
mTexture
=
nullptr
;
}
else
{
mTexture
=
source
;
}
mPictureRect
=
IntRect
(
0
0
info
.
img
-
>
mPictureRect
.
Width
(
)
info
.
img
-
>
mPictureRect
.
Height
(
)
)
;
mHost
-
>
FinishRendering
(
info
)
;
return
true
;
}
void
TexturedLayerMLGPU
:
:
AssignToView
(
FrameBuilder
*
aBuilder
RenderViewMLGPU
*
aView
Maybe
<
Polygon
>
&
&
aGeometry
)
{
if
(
mBigImageTexture
)
{
BigImageIterator
*
iter
=
mBigImageTexture
-
>
AsBigImageIterator
(
)
;
iter
-
>
BeginBigImageIteration
(
)
;
AssignBigImage
(
aBuilder
aView
iter
aGeometry
)
;
iter
-
>
EndBigImageIteration
(
)
;
}
else
{
LayerMLGPU
:
:
AssignToView
(
aBuilder
aView
std
:
:
move
(
aGeometry
)
)
;
}
}
void
TexturedLayerMLGPU
:
:
AssignBigImage
(
FrameBuilder
*
aBuilder
RenderViewMLGPU
*
aView
BigImageIterator
*
aIter
const
Maybe
<
Polygon
>
&
aGeometry
)
{
const
Matrix4x4
&
transform
=
GetLayer
(
)
-
>
GetEffectiveTransformForBuffer
(
)
;
do
{
IntRect
tileRect
=
aIter
-
>
GetTileRect
(
)
;
IntRect
rect
=
tileRect
.
Intersect
(
mPictureRect
)
;
if
(
rect
.
IsEmpty
(
)
)
{
continue
;
}
{
Rect
screenRect
=
transform
.
TransformBounds
(
Rect
(
rect
)
)
;
screenRect
.
MoveBy
(
-
aView
-
>
GetTargetOffset
(
)
)
;
screenRect
=
screenRect
.
Intersect
(
Rect
(
mComputedClipRect
.
ToUnknownRect
(
)
)
)
;
if
(
screenRect
.
IsEmpty
(
)
)
{
continue
;
}
}
RefPtr
<
TextureSource
>
tile
=
mBigImageTexture
-
>
ExtractCurrentTile
(
)
;
if
(
!
tile
)
{
continue
;
}
RefPtr
<
TempImageLayerMLGPU
>
item
=
new
TempImageLayerMLGPU
(
aBuilder
-
>
GetManager
(
)
)
;
item
-
>
Init
(
this
tile
rect
)
;
Maybe
<
Polygon
>
geometry
=
aGeometry
;
item
-
>
AddBoundsToView
(
aBuilder
aView
std
:
:
move
(
geometry
)
)
;
aBuilder
-
>
RetainTemporaryLayer
(
item
)
;
}
while
(
aIter
-
>
NextTile
(
)
)
;
}
TempImageLayerMLGPU
:
:
TempImageLayerMLGPU
(
LayerManagerMLGPU
*
aManager
)
:
ImageLayer
(
aManager
static_cast
<
HostLayer
*
>
(
this
)
)
TexturedLayerMLGPU
(
aManager
)
{
}
TempImageLayerMLGPU
:
:
~
TempImageLayerMLGPU
(
)
{
}
void
TempImageLayerMLGPU
:
:
Init
(
TexturedLayerMLGPU
*
aSource
const
RefPtr
<
TextureSource
>
&
aTexture
const
gfx
:
:
IntRect
&
aPictureRect
)
{
mEffectiveTransform
=
aSource
-
>
GetLayer
(
)
-
>
GetEffectiveTransform
(
)
;
mEffectiveTransformForBuffer
=
aSource
-
>
GetLayer
(
)
-
>
GetEffectiveTransformForBuffer
(
)
;
mComputedClipRect
=
aSource
-
>
GetComputedClipRect
(
)
;
mMask
=
aSource
-
>
GetMask
(
)
;
mComputedOpacity
=
aSource
-
>
GetComputedOpacity
(
)
;
mHost
=
aSource
-
>
GetImageHost
(
)
;
mTexture
=
aTexture
;
mPictureRect
=
aPictureRect
;
mFilter
=
aSource
-
>
GetSamplingFilter
(
)
;
mShadowVisibleRegion
=
aSource
-
>
GetShadowVisibleRegion
(
)
;
mIsOpaque
=
aSource
-
>
IsContentOpaque
(
)
;
MarkPrepared
(
)
;
}
}
}
