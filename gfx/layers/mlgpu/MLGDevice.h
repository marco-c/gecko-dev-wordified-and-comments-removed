#
ifndef
mozilla_gfx_layers_mlgpu_MLGDevice_h
#
define
mozilla_gfx_layers_mlgpu_MLGDevice_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
"
mozilla
/
WidgetUtils
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
ImageTypes
.
h
"
#
include
"
MLGDeviceTypes
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsPrintfCString
.
h
"
namespace
mozilla
{
namespace
widget
{
class
CompositorWidget
;
}
namespace
gfx
{
class
DrawTarget
;
}
namespace
layers
{
struct
GPUStats
;
class
BufferCache
;
class
ConstantBufferSection
;
class
DataTextureSource
;
class
MLGBufferD3D11
;
class
MLGDeviceD3D11
;
class
MLGRenderTargetD3D11
;
class
MLGResourceD3D11
;
class
MLGTexture
;
class
MLGTextureD3D11
;
class
SharedVertexBuffer
;
class
SharedConstantBuffer
;
class
TextureSource
;
class
VertexBufferSection
;
struct
ClearRegionHelper
;
class
MLGRenderTarget
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MLGRenderTarget
)
virtual
gfx
:
:
IntSize
GetSize
(
)
const
=
0
;
virtual
MLGRenderTargetD3D11
*
AsD3D11
(
)
{
return
nullptr
;
}
virtual
MLGTexture
*
GetTexture
(
)
=
0
;
bool
HasDepthBuffer
(
)
const
{
return
(
mFlags
&
MLGRenderTargetFlags
:
:
ZBuffer
)
=
=
MLGRenderTargetFlags
:
:
ZBuffer
;
}
int32_t
GetLastDepthStart
(
)
const
{
return
mLastDepthStart
;
}
void
SetLastDepthStart
(
int32_t
aDepthStart
)
{
mLastDepthStart
=
aDepthStart
;
}
protected
:
explicit
MLGRenderTarget
(
MLGRenderTargetFlags
aFlags
)
;
virtual
~
MLGRenderTarget
(
)
{
}
protected
:
MLGRenderTargetFlags
mFlags
;
int32_t
mLastDepthStart
;
}
;
class
MLGSwapChain
{
protected
:
virtual
~
MLGSwapChain
(
)
{
}
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MLGSwapChain
)
virtual
RefPtr
<
MLGRenderTarget
>
AcquireBackBuffer
(
)
=
0
;
virtual
bool
ResizeBuffers
(
const
gfx
:
:
IntSize
&
aSize
)
=
0
;
virtual
gfx
:
:
IntSize
GetSize
(
)
const
=
0
;
virtual
void
Present
(
)
=
0
;
virtual
void
ForcePresent
(
)
=
0
;
virtual
void
CopyBackbuffer
(
gfx
:
:
DrawTarget
*
aTarget
const
gfx
:
:
IntRect
&
aBounds
)
=
0
;
virtual
void
Destroy
(
)
=
0
;
bool
ApplyNewInvalidRegion
(
nsIntRegion
&
&
aRegion
const
Maybe
<
gfx
:
:
IntRect
>
&
aExtraRect
)
;
const
nsIntRegion
&
GetBackBufferInvalidRegion
(
)
const
{
return
mBackBufferInvalid
;
}
protected
:
MLGSwapChain
(
)
;
protected
:
gfx
:
:
IntSize
mLastPresentSize
;
nsIntRegion
mBackBufferInvalid
;
nsIntRegion
mFrontBufferInvalid
;
bool
mIsDoubleBuffered
;
}
;
class
MLGResource
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MLGResource
)
public
:
enum
class
Type
{
Buffer
Texture
}
;
virtual
Type
GetType
(
)
const
=
0
;
virtual
MLGResourceD3D11
*
AsResourceD3D11
(
)
{
return
nullptr
;
}
protected
:
virtual
~
MLGResource
(
)
{
}
}
;
class
MLGBuffer
:
public
MLGResource
{
public
:
Type
GetType
(
)
const
override
{
return
Type
:
:
Buffer
;
}
virtual
MLGBufferD3D11
*
AsD3D11
(
)
{
return
nullptr
;
}
virtual
size_t
GetSize
(
)
const
=
0
;
protected
:
~
MLGBuffer
(
)
override
{
}
}
;
class
MLGTexture
:
public
MLGResource
{
public
:
Type
GetType
(
)
const
override
{
return
Type
:
:
Texture
;
}
virtual
MLGTextureD3D11
*
AsD3D11
(
)
{
return
nullptr
;
}
const
gfx
:
:
IntSize
&
GetSize
(
)
const
{
return
mSize
;
}
protected
:
gfx
:
:
IntSize
mSize
;
}
;
enum
class
VertexShaderID
{
TexturedQuad
TexturedVertex
ColoredQuad
ColoredVertex
BlendVertex
Clear
MaskCombiner
DiagnosticText
MaxShaders
}
;
enum
class
PixelShaderID
{
ColoredQuad
ColoredVertex
TexturedQuadRGB
TexturedQuadRGBA
TexturedVertexRGB
TexturedVertexRGBA
TexturedQuadIMC4
TexturedQuadNV12
TexturedVertexIMC4
TexturedVertexNV12
ComponentAlphaQuad
ComponentAlphaVertex
BlendMultiply
BlendScreen
BlendOverlay
BlendDarken
BlendLighten
BlendColorDodge
BlendColorBurn
BlendHardLight
BlendSoftLight
BlendDifference
BlendExclusion
BlendHue
BlendSaturation
BlendColor
BlendLuminosity
Clear
MaskCombiner
DiagnosticText
MaxShaders
}
;
class
MLGDevice
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MLGDevice
)
MLGDevice
(
)
;
virtual
bool
Initialize
(
)
;
virtual
TextureFactoryIdentifier
GetTextureFactoryIdentifier
(
)
const
=
0
;
virtual
int32_t
GetMaxTextureSize
(
)
const
=
0
;
virtual
LayersBackend
GetLayersBackend
(
)
const
=
0
;
virtual
RefPtr
<
MLGSwapChain
>
CreateSwapChainForWidget
(
widget
:
:
CompositorWidget
*
aWidget
)
=
0
;
virtual
void
StartDiagnostics
(
uint32_t
aInvalidPixels
)
=
0
;
virtual
void
EndDiagnostics
(
)
=
0
;
virtual
void
GetDiagnostics
(
GPUStats
*
aStats
)
=
0
;
virtual
RefPtr
<
DataTextureSource
>
CreateDataTextureSource
(
TextureFlags
aFlags
)
=
0
;
virtual
bool
Map
(
MLGResource
*
aResource
MLGMapType
aType
MLGMappedResource
*
aMap
)
=
0
;
virtual
void
Unmap
(
MLGResource
*
aResource
)
=
0
;
virtual
void
UpdatePartialResource
(
MLGResource
*
aResource
const
gfx
:
:
IntRect
*
aRect
void
*
aData
uint32_t
aStride
)
=
0
;
virtual
void
CopyTexture
(
MLGTexture
*
aDest
const
gfx
:
:
IntPoint
&
aTarget
MLGTexture
*
aSource
const
gfx
:
:
IntRect
&
aRect
)
=
0
;
virtual
void
BeginFrame
(
)
;
virtual
void
EndFrame
(
)
;
virtual
void
SetRenderTarget
(
MLGRenderTarget
*
aRT
)
=
0
;
virtual
MLGRenderTarget
*
GetRenderTarget
(
)
=
0
;
virtual
void
SetViewport
(
const
gfx
:
:
IntRect
&
aRT
)
=
0
;
virtual
void
SetScissorRect
(
const
Maybe
<
gfx
:
:
IntRect
>
&
aScissorRect
)
=
0
;
virtual
void
SetVertexShader
(
VertexShaderID
aVertexShader
)
=
0
;
virtual
void
SetPixelShader
(
PixelShaderID
aPixelShader
)
=
0
;
virtual
void
SetSamplerMode
(
uint32_t
aIndex
SamplerMode
aSamplerMode
)
=
0
;
virtual
void
SetBlendState
(
MLGBlendState
aBlendState
)
=
0
;
virtual
void
SetVertexBuffer
(
uint32_t
aSlot
MLGBuffer
*
aBuffer
uint32_t
aStride
uint32_t
aOffset
=
0
)
=
0
;
virtual
void
SetVSConstantBuffer
(
uint32_t
aSlot
MLGBuffer
*
aBuffer
)
=
0
;
virtual
void
SetPSConstantBuffer
(
uint32_t
aSlot
MLGBuffer
*
aBuffer
)
=
0
;
virtual
void
SetPSTextures
(
uint32_t
aSlot
uint32_t
aNumTextures
TextureSource
*
const
*
aTextures
)
=
0
;
virtual
void
SetPSTexture
(
uint32_t
aSlot
MLGTexture
*
aTexture
)
=
0
;
virtual
void
SetDepthTestMode
(
MLGDepthTestMode
aMode
)
=
0
;
virtual
void
SetVSConstantBuffer
(
uint32_t
aSlot
MLGBuffer
*
aBuffer
uint32_t
aFirstConstant
uint32_t
aNumConstants
)
=
0
;
virtual
void
SetPSConstantBuffer
(
uint32_t
aSlot
MLGBuffer
*
aBuffer
uint32_t
aFirstConstant
uint32_t
aNumConstants
)
=
0
;
void
SetTopology
(
MLGPrimitiveTopology
aTopology
)
;
virtual
void
SetPSTexturesNV12
(
uint32_t
aSlot
TextureSource
*
aTexture
)
=
0
;
void
SetPSTexturesYUV
(
uint32_t
aSlot
TextureSource
*
aTexture
)
;
virtual
RefPtr
<
MLGBuffer
>
CreateBuffer
(
MLGBufferType
aType
uint32_t
aSize
MLGUsage
aUsage
const
void
*
aInitialData
=
nullptr
)
=
0
;
virtual
RefPtr
<
MLGTexture
>
CreateTexture
(
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
MLGUsage
aUsage
MLGTextureFlags
aFlags
)
=
0
;
virtual
RefPtr
<
MLGTexture
>
CreateTexture
(
TextureSource
*
aSource
)
=
0
;
virtual
RefPtr
<
MLGRenderTarget
>
CreateRenderTarget
(
const
gfx
:
:
IntSize
&
aSize
MLGRenderTargetFlags
aFlags
=
MLGRenderTargetFlags
:
:
Default
)
=
0
;
virtual
void
Clear
(
MLGRenderTarget
*
aRT
const
gfx
:
:
Color
&
aColor
)
=
0
;
virtual
void
ClearDepthBuffer
(
MLGRenderTarget
*
aRT
)
=
0
;
virtual
void
ClearView
(
MLGRenderTarget
*
aRT
const
gfx
:
:
Color
&
aColor
const
gfx
:
:
IntRect
*
aRects
size_t
aNumRects
)
=
0
;
virtual
void
Draw
(
uint32_t
aVertexCount
uint32_t
aOffset
)
=
0
;
virtual
void
DrawInstanced
(
uint32_t
aVertexCountPerInstance
uint32_t
aInstanceCount
uint32_t
aVertexOffset
uint32_t
aInstanceOffset
)
=
0
;
virtual
void
Flush
(
)
=
0
;
virtual
void
UnlockAllTextures
(
)
=
0
;
virtual
MLGDeviceD3D11
*
AsD3D11
(
)
{
return
nullptr
;
}
void
SetVertexBuffer
(
uint32_t
aSlot
const
VertexBufferSection
*
aSection
)
;
void
SetPSConstantBuffer
(
uint32_t
aSlot
const
ConstantBufferSection
*
aSection
)
;
void
SetVSConstantBuffer
(
uint32_t
aSlot
const
ConstantBufferSection
*
aSection
)
;
void
SetPSTexture
(
uint32_t
aSlot
TextureSource
*
aSource
)
;
void
SetSamplerMode
(
uint32_t
aIndex
gfx
:
:
SamplingFilter
aFilter
)
;
RefPtr
<
MLGBuffer
>
GetBufferForColorSpace
(
YUVColorSpace
aColorSpace
)
;
SharedVertexBuffer
*
GetSharedVertexBuffer
(
)
{
return
mSharedVertexBuffer
.
get
(
)
;
}
SharedConstantBuffer
*
GetSharedVSBuffer
(
)
{
return
mSharedVSBuffer
.
get
(
)
;
}
SharedConstantBuffer
*
GetSharedPSBuffer
(
)
{
return
mSharedPSBuffer
.
get
(
)
;
}
BufferCache
*
GetConstantBufferCache
(
)
{
return
mConstantBufferCache
.
get
(
)
;
}
void
FinishSharedBufferUse
(
)
;
virtual
bool
IsValid
(
)
const
{
return
mInitialized
&
&
mIsValid
;
}
const
nsCString
&
GetFailureId
(
)
const
{
return
mFailureId
;
}
const
nsCString
&
GetFailureMessage
(
)
const
{
return
mFailureMessage
;
}
void
PrepareClearRegion
(
ClearRegionHelper
*
aOut
nsTArray
<
gfx
:
:
IntRect
>
&
&
aRects
const
Maybe
<
int32_t
>
&
aSortIndex
)
;
void
DrawClearRegion
(
const
ClearRegionHelper
&
aHelper
)
;
virtual
bool
Synchronize
(
)
;
bool
CanUseClearView
(
)
const
{
return
mCanUseClearView
;
}
bool
CanUseConstantBufferOffsetBinding
(
)
const
{
return
mCanUseConstantBufferOffsetBinding
;
}
size_t
GetMaxConstantBufferBindSize
(
)
const
{
return
mMaxConstantBufferBindSize
;
}
void
UnsetPSTexture
(
uint32_t
aSlot
)
{
TextureSource
*
nullTexture
=
nullptr
;
SetPSTexture
(
aSlot
nullTexture
)
;
}
void
WriteAsPNG
(
MLGTexture
*
aTexture
const
char
*
aPath
)
;
RefPtr
<
MLGTexture
>
CopyAndCreateReadbackTexture
(
MLGTexture
*
aTexture
)
;
protected
:
virtual
~
MLGDevice
(
)
;
virtual
void
SetPrimitiveTopology
(
MLGPrimitiveTopology
aTopology
)
=
0
;
virtual
bool
VerifyConstantBufferOffsetting
(
)
{
return
true
;
}
bool
Fail
(
const
nsCString
&
aFailureId
const
nsCString
*
aMessage
)
;
#
if
defined
(
__GNUC__
)
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wformat
-
security
"
#
endif
template
<
typename
.
.
.
T
>
bool
Fail
(
const
char
*
aFailureId
)
{
nsCString
failureId
(
aFailureId
)
;
return
Fail
(
failureId
nullptr
)
;
}
template
<
typename
.
.
.
T
>
bool
Fail
(
const
char
*
aFailureId
const
char
*
aMessage
const
T
&
.
.
.
args
)
{
nsCString
failureId
(
aFailureId
)
;
nsPrintfCString
message
(
aMessage
args
.
.
.
)
;
return
Fail
(
failureId
&
message
)
;
}
#
if
defined
(
__GNUC__
)
#
pragma
GCC
diagnostic
pop
#
endif
void
UnmapSharedBuffers
(
)
;
private
:
MLGPrimitiveTopology
mTopology
;
UniquePtr
<
SharedVertexBuffer
>
mSharedVertexBuffer
;
UniquePtr
<
SharedConstantBuffer
>
mSharedVSBuffer
;
UniquePtr
<
SharedConstantBuffer
>
mSharedPSBuffer
;
UniquePtr
<
BufferCache
>
mConstantBufferCache
;
nsCString
mFailureId
;
nsCString
mFailureMessage
;
bool
mInitialized
;
typedef
EnumeratedArray
<
YUVColorSpace
YUVColorSpace
:
:
UNKNOWN
RefPtr
<
MLGBuffer
>
>
ColorSpaceArray
;
ColorSpaceArray
mColorSpaceBuffers
;
protected
:
bool
mIsValid
;
bool
mCanUseClearView
;
bool
mCanUseConstantBufferOffsetBinding
;
size_t
mMaxConstantBufferBindSize
;
RefPtr
<
MLGRenderTarget
>
mCurrentRT
;
}
;
}
}
#
endif
