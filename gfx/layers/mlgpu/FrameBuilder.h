#
ifndef
mozilla_gfx_layers_mlgpu_FrameBuilder_h
#
define
mozilla_gfx_layers_mlgpu_FrameBuilder_h
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
MaskOperation
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
ShaderDefinitionsMLGPU
.
h
"
#
include
"
SharedBufferMLGPU
.
h
"
#
include
"
Units
.
h
"
#
include
<
map
>
#
include
<
vector
>
namespace
mozilla
{
namespace
layers
{
class
ContainerLayer
;
class
ContainerLayerMLGPU
;
class
Layer
;
class
LayerMLGPU
;
class
LayerManagerMLGPU
;
class
MLGDevice
;
class
MLGRenderTarget
;
class
MLGSwapChain
;
class
RenderViewMLGPU
;
struct
ItemInfo
;
class
FrameBuilder
final
{
public
:
FrameBuilder
(
LayerManagerMLGPU
*
aManager
MLGSwapChain
*
aSwapChain
)
;
~
FrameBuilder
(
)
;
bool
Build
(
)
;
void
Render
(
)
;
bool
AddLayerToConstantBuffer
(
ItemInfo
&
aItem
)
;
LayerManagerMLGPU
*
GetManager
(
)
const
{
return
mManager
;
}
MLGDevice
*
GetDevice
(
)
const
{
return
mDevice
;
}
const
ConstantBufferSection
&
GetDefaultMaskInfo
(
)
const
{
return
mDefaultMaskInfo
;
}
MaskOperation
*
AddMaskOperation
(
LayerMLGPU
*
aLayer
)
;
size_t
CurrentLayerBufferIndex
(
)
const
;
size_t
CurrentMaskRectBufferIndex
(
)
const
;
ConstantBufferSection
GetLayerBufferByIndex
(
size_t
aIndex
)
const
;
ConstantBufferSection
GetMaskRectBufferByIndex
(
size_t
aIndex
)
const
;
void
RetainTemporaryLayer
(
LayerMLGPU
*
aLayer
)
;
private
:
void
AssignLayer
(
Layer
*
aLayer
RenderViewMLGPU
*
aView
const
RenderTargetIntRect
&
aClipRect
Maybe
<
gfx
:
:
Polygon
>
&
&
aGeometry
)
;
void
ProcessChildList
(
ContainerLayer
*
aContainer
RenderViewMLGPU
*
aView
const
RenderTargetIntRect
&
aParentClipRect
const
Maybe
<
gfx
:
:
Polygon
>
&
aParentGeometry
)
;
mlg
:
:
LayerConstants
*
AllocateLayerInfo
(
ItemInfo
&
aItem
)
;
bool
AddMaskRect
(
const
gfx
:
:
Rect
&
aRect
uint32_t
*
aOutIndex
)
;
void
FinishCurrentLayerBuffer
(
)
;
void
FinishCurrentMaskRectBuffer
(
)
;
bool
ProcessContainerLayer
(
ContainerLayer
*
aLayer
RenderViewMLGPU
*
aView
const
RenderTargetIntRect
&
aClipRect
Maybe
<
gfx
:
:
Polygon
>
&
aGeometry
)
;
private
:
RefPtr
<
LayerManagerMLGPU
>
mManager
;
RefPtr
<
MLGDevice
>
mDevice
;
RefPtr
<
MLGSwapChain
>
mSwapChain
;
RefPtr
<
RenderViewMLGPU
>
mWidgetRenderView
;
LayerMLGPU
*
mRoot
;
nsTArray
<
ConstantBufferSection
>
mLayerBuffers
;
nsTArray
<
mlg
:
:
LayerConstants
>
mCurrentLayerBuffer
;
nsDataHashtable
<
nsPtrHashKey
<
LayerMLGPU
>
uint32_t
>
mLayerBufferMap
;
nsTArray
<
ConstantBufferSection
>
mMaskRectBuffers
;
nsTArray
<
gfx
:
:
Rect
>
mCurrentMaskRectList
;
ConstantBufferSection
mDefaultMaskInfo
;
nsRefPtrHashtable
<
nsRefPtrHashKey
<
TextureSource
>
MaskOperation
>
mSingleTextureMasks
;
std
:
:
map
<
MaskTextureList
RefPtr
<
MaskCombineOperation
>
>
mCombinedTextureMasks
;
std
:
:
vector
<
RefPtr
<
Layer
>
>
mTemporaryLayers
;
}
;
}
}
#
endif
