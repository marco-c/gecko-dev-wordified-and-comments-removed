#
ifndef
mozilla_gfx_layers_mlgpu_TexturedLayerMLGPU_h
#
define
mozilla_gfx_layers_mlgpu_TexturedLayerMLGPU_h
#
include
"
LayerMLGPU
.
h
"
#
include
"
ImageLayers
.
h
"
#
include
"
mozilla
/
layers
/
ImageHost
.
h
"
namespace
mozilla
{
namespace
layers
{
class
TexturedLayerMLGPU
:
public
LayerMLGPU
{
public
:
TexturedLayerMLGPU
*
AsTexturedLayerMLGPU
(
)
override
{
return
this
;
}
virtual
gfx
:
:
SamplingFilter
GetSamplingFilter
(
)
=
0
;
bool
SetCompositableHost
(
CompositableHost
*
aHost
)
override
;
CompositableHost
*
GetCompositableHost
(
)
override
;
void
AssignToView
(
FrameBuilder
*
aBuilder
RenderViewMLGPU
*
aView
Maybe
<
gfx
:
:
Polygon
>
&
&
aGeometry
)
override
;
TextureSource
*
GetTexture
(
)
const
{
return
mTexture
;
}
ImageHost
*
GetImageHost
(
)
const
{
return
mHost
;
}
virtual
Maybe
<
gfx
:
:
Size
>
GetPictureScale
(
)
const
{
return
Nothing
(
)
;
}
RefPtr
<
TextureSource
>
BindAndGetTexture
(
)
;
protected
:
explicit
TexturedLayerMLGPU
(
LayerManagerMLGPU
*
aManager
)
;
virtual
~
TexturedLayerMLGPU
(
)
;
void
AssignBigImage
(
FrameBuilder
*
aBuilder
RenderViewMLGPU
*
aView
BigImageIterator
*
aIter
const
Maybe
<
gfx
:
:
Polygon
>
&
aGeometry
)
;
bool
OnPrepareToRender
(
FrameBuilder
*
aBuilder
)
override
;
protected
:
RefPtr
<
ImageHost
>
mHost
;
RefPtr
<
TextureSource
>
mTexture
;
RefPtr
<
TextureSource
>
mBigImageTexture
;
gfx
:
:
IntRect
mPictureRect
;
}
;
class
TempImageLayerMLGPU
final
:
public
ImageLayer
public
TexturedLayerMLGPU
{
public
:
explicit
TempImageLayerMLGPU
(
LayerManagerMLGPU
*
aManager
)
;
HostLayer
*
AsHostLayer
(
)
override
{
return
this
;
}
gfx
:
:
SamplingFilter
GetSamplingFilter
(
)
override
{
return
mFilter
;
}
bool
IsContentOpaque
(
)
override
{
return
mIsOpaque
;
}
void
Init
(
TexturedLayerMLGPU
*
aSource
const
RefPtr
<
TextureSource
>
&
aTexture
const
gfx
:
:
IntRect
&
aPictureRect
)
;
Layer
*
GetLayer
(
)
override
{
return
this
;
}
protected
:
virtual
~
TempImageLayerMLGPU
(
)
;
private
:
gfx
:
:
SamplingFilter
mFilter
;
bool
mIsOpaque
;
}
;
}
}
#
endif
