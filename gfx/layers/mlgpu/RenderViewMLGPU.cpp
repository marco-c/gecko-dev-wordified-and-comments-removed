#
include
"
RenderViewMLGPU
.
h
"
#
include
"
ContainerLayerMLGPU
.
h
"
#
include
"
FrameBuilder
.
h
"
#
include
"
mozilla
/
StaticPrefs_layers
.
h
"
#
include
"
LayersHelpers
.
h
"
#
include
"
LayersLogging
.
h
"
#
include
"
MLGDevice
.
h
"
#
include
"
RenderPassMLGPU
.
h
"
#
include
"
ShaderDefinitionsMLGPU
.
h
"
#
include
"
Units
.
h
"
#
include
"
UnitTransforms
.
h
"
#
include
"
UtilityMLGPU
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
gfx
;
RenderViewMLGPU
:
:
RenderViewMLGPU
(
FrameBuilder
*
aBuilder
MLGRenderTarget
*
aTarget
const
nsIntRegion
&
aInvalidRegion
)
:
RenderViewMLGPU
(
aBuilder
nullptr
)
{
mTarget
=
aTarget
;
mInvalidBounds
=
aInvalidRegion
.
GetBounds
(
)
;
mPostClearRegion
=
aBuilder
-
>
GetManager
(
)
-
>
GetRegionToClear
(
)
;
mPostClearRegion
.
AndWith
(
mInvalidBounds
)
;
mOccludedRegion
.
OrWith
(
ViewAs
<
LayerPixel
>
(
mPostClearRegion
PixelCastJustification
:
:
RenderTargetIsParentLayerForRoot
)
)
;
AL_LOG
(
"
RenderView
%
p
root
with
invalid
area
%
s
clear
area
%
s
\
n
"
this
Stringify
(
mInvalidBounds
)
.
c_str
(
)
Stringify
(
mPostClearRegion
)
.
c_str
(
)
)
;
}
RenderViewMLGPU
:
:
RenderViewMLGPU
(
FrameBuilder
*
aBuilder
ContainerLayerMLGPU
*
aContainer
RenderViewMLGPU
*
aParent
)
:
RenderViewMLGPU
(
aBuilder
aParent
)
{
mContainer
=
aContainer
;
mTargetOffset
=
aContainer
-
>
GetTargetOffset
(
)
;
mInvalidBounds
=
aContainer
-
>
GetInvalidRect
(
)
;
MOZ_ASSERT
(
!
mInvalidBounds
.
IsEmpty
(
)
)
;
AL_LOG
(
"
RenderView
%
p
starting
with
container
%
p
and
invalid
area
%
s
\
n
"
this
aContainer
-
>
GetLayer
(
)
Stringify
(
mInvalidBounds
)
.
c_str
(
)
)
;
mContainer
-
>
SetRenderView
(
this
)
;
}
RenderViewMLGPU
:
:
RenderViewMLGPU
(
FrameBuilder
*
aBuilder
RenderViewMLGPU
*
aParent
)
:
mBuilder
(
aBuilder
)
mDevice
(
aBuilder
-
>
GetDevice
(
)
)
mParent
(
aParent
)
mContainer
(
nullptr
)
mFinishedBuilding
(
false
)
mCurrentLayerBufferIndex
(
kInvalidResourceIndex
)
mCurrentMaskRectBufferIndex
(
kInvalidResourceIndex
)
mCurrentDepthMode
(
MLGDepthTestMode
:
:
Disabled
)
mNextSortIndex
(
1
)
mUseDepthBuffer
(
StaticPrefs
:
:
layers_mlgpu_enable_depth_buffer_AtStartup
(
)
)
mDepthBufferNeedsClear
(
false
)
{
if
(
aParent
)
{
aParent
-
>
AddChild
(
this
)
;
}
}
RenderViewMLGPU
:
:
~
RenderViewMLGPU
(
)
{
for
(
const
auto
&
child
:
mChildren
)
{
child
-
>
mParent
=
nullptr
;
}
}
IntSize
RenderViewMLGPU
:
:
GetSize
(
)
const
{
MOZ_ASSERT
(
mFinishedBuilding
)
;
return
mTarget
-
>
GetSize
(
)
;
}
MLGRenderTarget
*
RenderViewMLGPU
:
:
GetRenderTarget
(
)
const
{
MOZ_ASSERT
(
mFinishedBuilding
)
;
return
mTarget
;
}
void
RenderViewMLGPU
:
:
AddChild
(
RenderViewMLGPU
*
aParent
)
{
mChildren
.
push_back
(
aParent
)
;
}
void
RenderViewMLGPU
:
:
Render
(
)
{
for
(
const
auto
&
child
:
mChildren
)
{
child
-
>
Render
(
)
;
}
if
(
mContainer
&
&
mContainer
-
>
NeedsSurfaceCopy
(
)
)
{
return
;
}
ExecuteRendering
(
)
;
}
void
RenderViewMLGPU
:
:
RenderAfterBackdropCopy
(
)
{
MOZ_ASSERT
(
mContainer
&
&
mContainer
-
>
NeedsSurfaceCopy
(
)
)
;
mInvalidBounds
=
mContainer
-
>
GetRenderRegion
(
)
.
GetBounds
(
)
.
ToUnknownRect
(
)
-
GetTargetOffset
(
)
;
ExecuteRendering
(
)
;
}
void
RenderViewMLGPU
:
:
FinishBuilding
(
)
{
MOZ_ASSERT
(
!
mFinishedBuilding
)
;
mFinishedBuilding
=
true
;
if
(
mContainer
)
{
MOZ_ASSERT
(
!
mTarget
)
;
MLGRenderTargetFlags
flags
=
MLGRenderTargetFlags
:
:
Default
;
if
(
mUseDepthBuffer
)
{
flags
|
=
MLGRenderTargetFlags
:
:
ZBuffer
;
}
mTarget
=
mContainer
-
>
UpdateRenderTarget
(
mDevice
flags
)
;
}
}
void
RenderViewMLGPU
:
:
AddItem
(
LayerMLGPU
*
aItem
const
IntRect
&
aRect
Maybe
<
Polygon
>
&
&
aGeometry
)
{
AL_LOG
(
"
RenderView
%
p
analyzing
layer
%
p
\
n
"
this
aItem
-
>
GetLayer
(
)
)
;
if
(
aItem
-
>
GetComputedOpacity
(
)
=
=
0
.
0f
)
{
AL_LOG
(
"
RenderView
%
p
culling
item
%
p
with
no
opacity
\
n
"
this
aItem
-
>
GetLayer
(
)
)
;
return
;
}
ItemInfo
info
(
mBuilder
this
aItem
mNextSortIndex
+
+
aRect
std
:
:
move
(
aGeometry
)
)
;
if
(
!
UpdateVisibleRegion
(
info
)
|
|
!
mBuilder
-
>
AddLayerToConstantBuffer
(
info
)
)
{
AL_LOG
(
"
RenderView
%
p
culled
item
%
p
!
\
n
"
this
aItem
-
>
GetLayer
(
)
)
;
return
;
}
MOZ_ASSERT
(
info
.
type
!
=
RenderPassType
:
:
Unknown
)
;
if
(
info
.
renderOrder
=
=
RenderOrder
:
:
FrontToBack
)
{
AddItemFrontToBack
(
aItem
info
)
;
}
else
{
AddItemBackToFront
(
aItem
info
)
;
}
}
bool
RenderViewMLGPU
:
:
UpdateVisibleRegion
(
ItemInfo
&
aItem
)
{
if
(
mUseDepthBuffer
|
|
!
aItem
.
translation
|
|
!
StaticPrefs
:
:
layers_mlgpu_enable_cpu_occlusion_AtStartup
(
)
)
{
LayerIntRegion
region
=
aItem
.
layer
-
>
GetShadowVisibleRegion
(
)
;
aItem
.
layer
-
>
SetRenderRegion
(
std
:
:
move
(
region
)
)
;
AL_LOG
(
"
RenderView
%
p
simple
occlusion
test
bounds
=
%
s
translation
?
=
%
d
\
n
"
this
Stringify
(
aItem
.
bounds
)
.
c_str
(
)
aItem
.
translation
?
1
:
0
)
;
return
mInvalidBounds
.
Intersects
(
aItem
.
bounds
)
;
}
MOZ_ASSERT
(
aItem
.
rectilinear
)
;
AL_LOG
(
"
RenderView
%
p
starting
visibility
tests
:
\
n
"
this
)
;
AL_LOG
(
"
occluded
=
%
s
\
n
"
Stringify
(
mOccludedRegion
)
.
c_str
(
)
)
;
LayerIntPoint
translation
=
LayerIntPoint
:
:
FromUnknownPoint
(
aItem
.
translation
.
value
(
)
-
mTargetOffset
)
;
AL_LOG
(
"
translation
=
%
s
\
n
"
Stringify
(
translation
)
.
c_str
(
)
)
;
IntRect
clip
=
aItem
.
layer
-
>
GetComputedClipRect
(
)
.
ToUnknownRect
(
)
;
AL_LOG
(
"
clip
=
%
s
\
n
"
Stringify
(
translation
)
.
c_str
(
)
)
;
LayerIntRegion
region
=
aItem
.
layer
-
>
GetShadowVisibleRegion
(
)
;
region
.
MoveBy
(
translation
)
;
AL_LOG
(
"
effective
-
visible
=
%
s
\
n
"
Stringify
(
region
)
.
c_str
(
)
)
;
region
.
SubOut
(
mOccludedRegion
)
;
region
.
AndWith
(
LayerIntRect
:
:
FromUnknownRect
(
mInvalidBounds
)
)
;
region
.
AndWith
(
LayerIntRect
:
:
FromUnknownRect
(
clip
)
)
;
if
(
region
.
IsEmpty
(
)
)
{
return
false
;
}
region
.
MoveBy
(
-
translation
)
;
AL_LOG
(
"
new
-
local
-
visible
=
%
s
\
n
"
Stringify
(
region
)
.
c_str
(
)
)
;
aItem
.
layer
-
>
SetRenderRegion
(
std
:
:
move
(
region
)
)
;
if
(
aItem
.
opaque
)
{
mOccludedRegion
.
MoveBy
(
-
translation
)
;
mOccludedRegion
.
OrWith
(
aItem
.
layer
-
>
GetRenderRegion
(
)
)
;
mOccludedRegion
.
MoveBy
(
translation
)
;
AL_LOG
(
"
new
-
occluded
=
%
s
\
n
"
Stringify
(
mOccludedRegion
)
.
c_str
(
)
)
;
if
(
mOccludedRegion
.
GetNumRects
(
)
>
=
32
)
{
mOccludedRegion
.
SetEmpty
(
)
;
AL_LOG
(
"
clear
-
occluded
too
many
rects
\
n
"
)
;
}
}
return
true
;
}
void
RenderViewMLGPU
:
:
AddItemFrontToBack
(
LayerMLGPU
*
aLayer
ItemInfo
&
aItem
)
{
static
const
size_t
kMaxSearch
=
3
;
size_t
iterations
=
0
;
for
(
auto
iter
=
mFrontToBack
.
rbegin
(
)
;
iter
!
=
mFrontToBack
.
rend
(
)
;
iter
+
+
)
{
RenderPassMLGPU
*
pass
=
(
*
iter
)
;
if
(
pass
-
>
IsCompatible
(
aItem
)
&
&
pass
-
>
AcceptItem
(
aItem
)
)
{
AL_LOG
(
"
RenderView
%
p
added
layer
%
p
to
pass
%
p
(
%
d
)
\
n
"
this
aLayer
-
>
GetLayer
(
)
pass
int
(
pass
-
>
GetType
(
)
)
)
;
return
;
}
if
(
+
+
iterations
>
kMaxSearch
)
{
break
;
}
}
RefPtr
<
RenderPassMLGPU
>
pass
=
RenderPassMLGPU
:
:
CreatePass
(
mBuilder
aItem
)
;
if
(
!
pass
|
|
!
pass
-
>
AcceptItem
(
aItem
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Could
not
build
a
pass
for
item
!
"
)
;
return
;
}
AL_LOG
(
"
RenderView
%
p
added
layer
%
p
to
new
pass
%
p
(
%
d
)
\
n
"
this
aLayer
-
>
GetLayer
(
)
pass
.
get
(
)
int
(
pass
-
>
GetType
(
)
)
)
;
mFrontToBack
.
push_back
(
pass
)
;
}
void
RenderViewMLGPU
:
:
AddItemBackToFront
(
LayerMLGPU
*
aLayer
ItemInfo
&
aItem
)
{
static
const
size_t
kMaxSearch
=
10
;
size_t
iterations
=
0
;
for
(
auto
iter
=
mBackToFront
.
begin
(
)
;
iter
!
=
mBackToFront
.
end
(
)
;
iter
+
+
)
{
RenderPassMLGPU
*
pass
=
(
*
iter
)
;
if
(
pass
-
>
IsCompatible
(
aItem
)
&
&
pass
-
>
AcceptItem
(
aItem
)
)
{
AL_LOG
(
"
RenderView
%
p
added
layer
%
p
to
pass
%
p
(
%
d
)
\
n
"
this
aLayer
-
>
GetLayer
(
)
pass
int
(
pass
-
>
GetType
(
)
)
)
;
return
;
}
if
(
pass
-
>
Intersects
(
aItem
)
)
{
break
;
}
if
(
+
+
iterations
>
kMaxSearch
)
{
break
;
}
}
RefPtr
<
RenderPassMLGPU
>
pass
=
RenderPassMLGPU
:
:
CreatePass
(
mBuilder
aItem
)
;
if
(
!
pass
|
|
!
pass
-
>
AcceptItem
(
aItem
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Could
not
build
a
pass
for
item
!
"
)
;
return
;
}
AL_LOG
(
"
RenderView
%
p
added
layer
%
p
to
new
pass
%
p
(
%
d
)
\
n
"
this
aLayer
-
>
GetLayer
(
)
pass
.
get
(
)
int
(
pass
-
>
GetType
(
)
)
)
;
mBackToFront
.
push_front
(
pass
)
;
}
void
RenderViewMLGPU
:
:
Prepare
(
)
{
if
(
!
mTarget
)
{
return
;
}
for
(
RefPtr
<
RenderPassMLGPU
>
&
pass
:
mFrontToBack
)
{
pass
-
>
PrepareForRendering
(
)
;
}
PrepareClears
(
)
;
{
WorldConstants
vsConstants
;
Matrix4x4
projection
=
Matrix4x4
:
:
Translation
(
-
1
.
0
1
.
0
0
.
0
)
;
projection
.
PreScale
(
2
.
0
/
float
(
mTarget
-
>
GetSize
(
)
.
width
)
2
.
0
/
float
(
mTarget
-
>
GetSize
(
)
.
height
)
1
.
0f
)
;
projection
.
PreScale
(
1
.
0f
-
1
.
0f
1
.
0f
)
;
memcpy
(
vsConstants
.
projection
&
projection
.
_11
64
)
;
vsConstants
.
targetOffset
=
Point
(
mTargetOffset
)
;
vsConstants
.
sortIndexOffset
=
PrepareDepthBuffer
(
)
;
vsConstants
.
debugFrameNumber
=
mBuilder
-
>
GetManager
(
)
-
>
GetDebugFrameNumber
(
)
;
SharedConstantBuffer
*
shared
=
mDevice
-
>
GetSharedVSBuffer
(
)
;
if
(
!
shared
-
>
Allocate
(
&
mWorldConstants
vsConstants
)
)
{
return
;
}
}
for
(
RefPtr
<
RenderPassMLGPU
>
&
pass
:
mBackToFront
)
{
pass
-
>
PrepareForRendering
(
)
;
}
for
(
const
auto
&
iter
:
mChildren
)
{
iter
-
>
Prepare
(
)
;
}
}
void
RenderViewMLGPU
:
:
ExecuteRendering
(
)
{
if
(
!
mTarget
)
{
return
;
}
if
(
!
mWorldConstants
.
IsValid
(
)
)
{
gfxWarning
(
)
<
<
"
Failed
to
allocate
constant
buffer
for
world
transform
"
;
return
;
}
SetDeviceState
(
)
;
if
(
mUseDepthBuffer
)
{
if
(
mDepthBufferNeedsClear
)
{
mDevice
-
>
ClearDepthBuffer
(
mTarget
)
;
}
SetDepthTestMode
(
MLGDepthTestMode
:
:
Write
)
;
}
for
(
auto
iter
=
mFrontToBack
.
begin
(
)
;
iter
!
=
mFrontToBack
.
end
(
)
;
iter
+
+
)
{
ExecutePass
(
*
iter
)
;
}
if
(
mUseDepthBuffer
)
{
SetDepthTestMode
(
MLGDepthTestMode
:
:
ReadOnly
)
;
}
mDevice
-
>
DrawClearRegion
(
mPreClear
)
;
for
(
auto
iter
=
mBackToFront
.
begin
(
)
;
iter
!
=
mBackToFront
.
end
(
)
;
iter
+
+
)
{
ExecutePass
(
*
iter
)
;
}
if
(
!
mPostClearRegion
.
IsEmpty
(
)
)
{
mDevice
-
>
DrawClearRegion
(
mPostClear
)
;
}
if
(
mContainer
)
{
mContainer
-
>
ClearInvalidRect
(
)
;
}
}
void
RenderViewMLGPU
:
:
ExecutePass
(
RenderPassMLGPU
*
aPass
)
{
if
(
!
aPass
-
>
IsPrepared
(
)
)
{
return
;
}
if
(
aPass
-
>
GetLayerBufferIndex
(
)
!
=
mCurrentLayerBufferIndex
)
{
mCurrentLayerBufferIndex
=
aPass
-
>
GetLayerBufferIndex
(
)
;
ConstantBufferSection
section
=
mBuilder
-
>
GetLayerBufferByIndex
(
mCurrentLayerBufferIndex
)
;
mDevice
-
>
SetVSConstantBuffer
(
kLayerBufferSlot
&
section
)
;
}
if
(
aPass
-
>
GetMaskRectBufferIndex
(
)
&
&
aPass
-
>
GetMaskRectBufferIndex
(
)
.
value
(
)
!
=
mCurrentMaskRectBufferIndex
)
{
mCurrentMaskRectBufferIndex
=
aPass
-
>
GetMaskRectBufferIndex
(
)
.
value
(
)
;
ConstantBufferSection
section
=
mBuilder
-
>
GetMaskRectBufferByIndex
(
mCurrentMaskRectBufferIndex
)
;
mDevice
-
>
SetVSConstantBuffer
(
kMaskBufferSlot
&
section
)
;
}
aPass
-
>
ExecuteRendering
(
)
;
}
void
RenderViewMLGPU
:
:
SetDeviceState
(
)
{
mDevice
-
>
UnsetPSTexture
(
0
)
;
mDevice
-
>
SetRenderTarget
(
mTarget
)
;
mDevice
-
>
SetViewport
(
IntRect
(
IntPoint
(
0
0
)
mTarget
-
>
GetSize
(
)
)
)
;
mDevice
-
>
SetScissorRect
(
Some
(
mInvalidBounds
)
)
;
mDevice
-
>
SetVSConstantBuffer
(
kWorldConstantBufferSlot
&
mWorldConstants
)
;
}
void
RenderViewMLGPU
:
:
SetDepthTestMode
(
MLGDepthTestMode
aMode
)
{
mDevice
-
>
SetDepthTestMode
(
aMode
)
;
mCurrentDepthMode
=
aMode
;
}
void
RenderViewMLGPU
:
:
RestoreDeviceState
(
)
{
SetDeviceState
(
)
;
mDevice
-
>
SetDepthTestMode
(
mCurrentDepthMode
)
;
mCurrentLayerBufferIndex
=
kInvalidResourceIndex
;
mCurrentMaskRectBufferIndex
=
kInvalidResourceIndex
;
}
int32_t
RenderViewMLGPU
:
:
PrepareDepthBuffer
(
)
{
if
(
!
mUseDepthBuffer
)
{
return
0
;
}
int32_t
highestIndex
=
mTarget
-
>
GetLastDepthStart
(
)
;
if
(
highestIndex
<
mNextSortIndex
)
{
mDepthBufferNeedsClear
=
true
;
highestIndex
=
kDepthLimit
;
}
int32_t
sortOffset
=
highestIndex
-
mNextSortIndex
-
1
;
MOZ_ASSERT
(
sortOffset
>
=
0
)
;
mTarget
-
>
SetLastDepthStart
(
sortOffset
)
;
return
sortOffset
;
}
void
RenderViewMLGPU
:
:
PrepareClears
(
)
{
if
(
mContainer
&
&
mContainer
-
>
NeedsSurfaceCopy
(
)
)
{
return
;
}
LayerIntRegion
region
=
LayerIntRect
:
:
FromUnknownRect
(
mInvalidBounds
)
;
if
(
!
mUseDepthBuffer
)
{
region
.
SubOut
(
mOccludedRegion
)
;
region
.
SimplifyOutward
(
kMaxClearViewRects
)
;
}
Maybe
<
int32_t
>
sortIndex
;
if
(
mUseDepthBuffer
)
{
sortIndex
=
Some
(
mNextSortIndex
+
+
)
;
}
nsTArray
<
IntRect
>
rects
=
ToRectArray
(
region
)
;
mDevice
-
>
PrepareClearRegion
(
&
mPreClear
std
:
:
move
(
rects
)
sortIndex
)
;
if
(
!
mPostClearRegion
.
IsEmpty
(
)
)
{
nsTArray
<
IntRect
>
rects
=
ToRectArray
(
mPostClearRegion
)
;
mDevice
-
>
PrepareClearRegion
(
&
mPostClear
std
:
:
move
(
rects
)
Nothing
(
)
)
;
}
}
}
}
