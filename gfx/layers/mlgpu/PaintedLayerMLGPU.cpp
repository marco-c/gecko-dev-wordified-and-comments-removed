#
include
"
PaintedLayerMLGPU
.
h
"
#
include
"
LayerManagerMLGPU
.
h
"
#
include
"
mozilla
/
layers
/
LayersHelpers
.
h
"
#
include
"
mozilla
/
layers
/
TiledContentHost
.
h
"
#
include
"
UnitTransforms
.
h
"
namespace
mozilla
{
using
namespace
gfx
;
namespace
layers
{
PaintedLayerMLGPU
:
:
PaintedLayerMLGPU
(
LayerManagerMLGPU
*
aManager
)
:
PaintedLayer
(
aManager
static_cast
<
HostLayer
*
>
(
this
)
)
LayerMLGPU
(
aManager
)
{
MOZ_COUNT_CTOR
(
PaintedLayerMLGPU
)
;
}
PaintedLayerMLGPU
:
:
~
PaintedLayerMLGPU
(
)
{
MOZ_COUNT_DTOR
(
PaintedLayerMLGPU
)
;
CleanupResources
(
)
;
}
bool
PaintedLayerMLGPU
:
:
OnPrepareToRender
(
FrameBuilder
*
aBuilder
)
{
mTexture
=
nullptr
;
mTextureOnWhite
=
nullptr
;
return
!
!
mHost
;
}
void
PaintedLayerMLGPU
:
:
SetRenderRegion
(
LayerIntRegion
&
&
aRegion
)
{
mRenderRegion
=
Move
(
aRegion
)
;
LayerIntRect
bounds
(
mRenderRegion
.
GetBounds
(
)
.
TopLeft
(
)
ViewAs
<
LayerPixel
>
(
mTexture
-
>
GetSize
(
)
)
)
;
mRenderRegion
.
AndWith
(
bounds
)
;
}
const
LayerIntRegion
&
PaintedLayerMLGPU
:
:
GetDrawRects
(
)
{
#
ifndef
MOZ_IGNORE_PAINT_WILL_RESAMPLE
if
(
MayResample
(
)
)
{
mDrawRects
=
mRenderRegion
.
GetBounds
(
)
;
return
mDrawRects
;
}
#
endif
return
mRenderRegion
;
}
bool
PaintedLayerMLGPU
:
:
SetCompositableHost
(
CompositableHost
*
aHost
)
{
switch
(
aHost
-
>
GetType
(
)
)
{
case
CompositableType
:
:
CONTENT_TILED
:
case
CompositableType
:
:
CONTENT_SINGLE
:
case
CompositableType
:
:
CONTENT_DOUBLE
:
mHost
=
aHost
-
>
AsContentHost
(
)
;
if
(
!
mHost
)
{
gfxWarning
(
)
<
<
"
ContentHostBase
is
not
a
ContentHostTexture
"
;
}
return
true
;
default
:
return
false
;
}
}
CompositableHost
*
PaintedLayerMLGPU
:
:
GetCompositableHost
(
)
{
return
mHost
;
}
gfx
:
:
Point
PaintedLayerMLGPU
:
:
GetDestOrigin
(
)
const
{
return
mDestOrigin
;
}
void
PaintedLayerMLGPU
:
:
AssignToView
(
FrameBuilder
*
aBuilder
RenderViewMLGPU
*
aView
Maybe
<
Polygon
>
&
&
aGeometry
)
{
if
(
TiledContentHost
*
tiles
=
mHost
-
>
AsTiledContentHost
(
)
)
{
MOZ_ASSERT
(
tiles
-
>
GetLowResBuffer
(
)
.
GetTileCount
(
)
=
=
0
)
;
AssignHighResTilesToView
(
aBuilder
aView
tiles
aGeometry
)
;
return
;
}
if
(
!
mTexture
)
{
ContentHostTexture
*
single
=
mHost
-
>
AsContentHostTexture
(
)
;
if
(
!
single
)
{
return
;
}
mTexture
=
single
-
>
AcquireTextureSource
(
)
;
if
(
!
mTexture
)
{
return
;
}
mTextureOnWhite
=
single
-
>
AcquireTextureSourceOnWhite
(
)
;
mDestOrigin
=
single
-
>
GetOriginOffset
(
)
;
}
LayerMLGPU
:
:
AssignToView
(
aBuilder
aView
Move
(
aGeometry
)
)
;
}
void
PaintedLayerMLGPU
:
:
AssignHighResTilesToView
(
FrameBuilder
*
aBuilder
RenderViewMLGPU
*
aView
TiledContentHost
*
aTileHost
const
Maybe
<
Polygon
>
&
aGeometry
)
{
TiledLayerBufferComposite
&
tiles
=
aTileHost
-
>
GetHighResBuffer
(
)
;
LayerIntRegion
compositeRegion
=
ViewAs
<
LayerPixel
>
(
tiles
.
GetValidRegion
(
)
)
;
compositeRegion
.
AndWith
(
GetShadowVisibleRegion
(
)
)
;
if
(
compositeRegion
.
IsEmpty
(
)
)
{
return
;
}
AssignTileBufferToView
(
aBuilder
aView
tiles
compositeRegion
aGeometry
)
;
}
void
PaintedLayerMLGPU
:
:
AssignTileBufferToView
(
FrameBuilder
*
aBuilder
RenderViewMLGPU
*
aView
TiledLayerBufferComposite
&
aTiles
const
LayerIntRegion
&
aCompositeRegion
const
Maybe
<
Polygon
>
&
aGeometry
)
{
float
resolution
=
aTiles
.
GetResolution
(
)
;
float
baseOpacity
=
mComputedOpacity
;
LayerIntRegion
visible
=
GetShadowVisibleRegion
(
)
;
for
(
size_t
i
=
0
;
i
<
aTiles
.
GetTileCount
(
)
;
i
+
+
)
{
TileHost
&
tile
=
aTiles
.
GetTile
(
i
)
;
if
(
tile
.
IsPlaceholderTile
(
)
)
{
continue
;
}
TileCoordIntPoint
pos
=
aTiles
.
GetPlacement
(
)
.
TilePosition
(
i
)
;
MOZ_ASSERT
(
pos
.
x
=
=
tile
.
mTilePosition
.
x
&
&
pos
.
y
=
=
tile
.
mTilePosition
.
y
)
;
IntPoint
offset
=
aTiles
.
GetTileOffset
(
pos
)
;
LayerIntRect
tileRect
(
ViewAs
<
LayerPixel
>
(
offset
)
ViewAs
<
LayerPixel
>
(
aTiles
.
GetScaledTileSize
(
)
)
)
;
LayerIntRegion
tileDrawRegion
=
tileRect
;
tileDrawRegion
.
AndWith
(
aCompositeRegion
)
;
if
(
tileDrawRegion
.
IsEmpty
(
)
)
{
continue
;
}
tileDrawRegion
.
ScaleRoundOut
(
resolution
resolution
)
;
mTexture
=
tile
.
AcquireTextureSource
(
)
;
if
(
!
mTexture
)
{
continue
;
}
mTextureOnWhite
=
tile
.
AcquireTextureSourceOnWhite
(
)
;
SetShadowVisibleRegion
(
tileDrawRegion
)
;
mComputedOpacity
=
tile
.
GetFadeInOpacity
(
baseOpacity
)
;
mDestOrigin
=
offset
;
Maybe
<
Polygon
>
geometry
=
aGeometry
;
LayerMLGPU
:
:
AssignToView
(
aBuilder
aView
Move
(
geometry
)
)
;
}
mComputedOpacity
=
baseOpacity
;
SetShadowVisibleRegion
(
Move
(
visible
)
)
;
}
void
PaintedLayerMLGPU
:
:
CleanupResources
(
)
{
if
(
mHost
)
{
mHost
-
>
Detach
(
this
)
;
}
mTexture
=
nullptr
;
mTextureOnWhite
=
nullptr
;
mHost
=
nullptr
;
}
void
PaintedLayerMLGPU
:
:
PrintInfo
(
std
:
:
stringstream
&
aStream
const
char
*
aPrefix
)
{
PaintedLayer
:
:
PrintInfo
(
aStream
aPrefix
)
;
if
(
mHost
&
&
mHost
-
>
IsAttached
(
)
)
{
aStream
<
<
"
\
n
"
;
nsAutoCString
pfx
(
aPrefix
)
;
pfx
+
=
"
"
;
mHost
-
>
PrintInfo
(
aStream
pfx
.
get
(
)
)
;
}
}
void
PaintedLayerMLGPU
:
:
Disconnect
(
)
{
CleanupResources
(
)
;
}
bool
PaintedLayerMLGPU
:
:
IsContentOpaque
(
)
{
return
!
!
(
GetContentFlags
(
)
&
CONTENT_OPAQUE
)
;
}
void
PaintedLayerMLGPU
:
:
CleanupCachedResources
(
)
{
CleanupResources
(
)
;
}
}
}
