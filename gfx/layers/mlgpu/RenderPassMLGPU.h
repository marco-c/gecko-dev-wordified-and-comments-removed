#
ifndef
MOZILLA_GFX_RENDERPASSMLGPU_H
#
define
MOZILLA_GFX_RENDERPASSMLGPU_H
#
include
"
LayerMLGPU
.
h
"
#
include
"
LayerManagerMLGPU
.
h
"
#
include
"
ShaderDefinitionsMLGPU
.
h
"
#
include
"
SharedBufferMLGPU
.
h
"
#
include
"
StagingBuffer
.
h
"
namespace
mozilla
{
namespace
layers
{
using
namespace
mlg
;
class
RenderViewMLGPU
;
enum
class
RenderPassType
{
ClearView
SolidColor
SingleTexture
RenderView
Video
ComponentAlpha
Unknown
}
;
enum
class
RenderOrder
{
BackToFront
FrontToBack
}
;
static
const
uint32_t
kInvalidResourceIndex
=
uint32_t
(
-
1
)
;
struct
ItemInfo
final
{
ItemInfo
(
FrameBuilder
*
aBuilder
RenderViewMLGPU
*
aView
LayerMLGPU
*
aLayer
int32_t
aSortOrder
const
gfx
:
:
IntRect
&
aBounds
Maybe
<
gfx
:
:
Polygon
>
&
&
aGeometry
)
;
bool
HasRectTransformAndClip
(
)
const
{
return
rectilinear
&
&
!
layer
-
>
GetMask
(
)
;
}
RenderViewMLGPU
*
view
;
LayerMLGPU
*
layer
;
RenderPassType
type
;
uint32_t
layerIndex
;
int32_t
sortOrder
;
gfx
:
:
IntRect
bounds
;
RenderOrder
renderOrder
;
Maybe
<
gfx
:
:
Polygon
>
geometry
;
Maybe
<
gfx
:
:
IntPoint
>
translation
;
bool
opaque
;
bool
rectilinear
;
}
;
class
RenderPassMLGPU
{
NS_INLINE_DECL_REFCOUNTING
(
RenderPassMLGPU
)
public
:
static
RenderPassType
GetPreferredPassType
(
FrameBuilder
*
aBuilder
const
ItemInfo
&
aInfo
)
;
static
RefPtr
<
RenderPassMLGPU
>
CreatePass
(
FrameBuilder
*
aBuilder
const
ItemInfo
&
aInfo
)
;
virtual
bool
IsCompatible
(
const
ItemInfo
&
aItem
)
;
virtual
RenderPassType
GetType
(
)
const
=
0
;
bool
AcceptItem
(
ItemInfo
&
aInfo
)
;
virtual
void
PrepareForRendering
(
)
;
virtual
void
ExecuteRendering
(
)
=
0
;
virtual
Maybe
<
MLGBlendState
>
GetBlendState
(
)
const
{
return
Nothing
(
)
;
}
size_t
GetLayerBufferIndex
(
)
const
{
return
mLayerBufferIndex
;
}
Maybe
<
uint32_t
>
GetMaskRectBufferIndex
(
)
const
{
return
mMaskRectBufferIndex
=
=
kInvalidResourceIndex
?
Nothing
(
)
:
Some
(
mMaskRectBufferIndex
)
;
}
bool
Intersects
(
const
ItemInfo
&
aItem
)
;
bool
IsPrepared
(
)
const
{
return
mPrepared
;
}
protected
:
RenderPassMLGPU
(
FrameBuilder
*
aBuilder
const
ItemInfo
&
aItem
)
;
virtual
~
RenderPassMLGPU
(
)
;
virtual
bool
AddToPass
(
LayerMLGPU
*
aItem
ItemInfo
&
aInfo
)
=
0
;
protected
:
enum
class
GeometryMode
{
Unknown
UnitQuad
Polygon
}
;
protected
:
FrameBuilder
*
mBuilder
;
RefPtr
<
MLGDevice
>
mDevice
;
size_t
mLayerBufferIndex
;
size_t
mMaskRectBufferIndex
;
gfx
:
:
IntRegion
mAffectedRegion
;
bool
mPrepared
;
}
;
class
ShaderRenderPass
:
public
RenderPassMLGPU
{
public
:
ShaderRenderPass
(
FrameBuilder
*
aBuilder
const
ItemInfo
&
aItem
)
;
VertexStagingBuffer
*
GetInstances
(
)
{
return
&
mInstances
;
}
bool
IsCompatible
(
const
ItemInfo
&
aItem
)
override
;
void
PrepareForRendering
(
)
override
;
void
ExecuteRendering
(
)
override
;
Maybe
<
MLGBlendState
>
GetBlendState
(
)
const
override
{
return
Some
(
MLGBlendState
:
:
Over
)
;
}
protected
:
virtual
float
GetOpacity
(
)
const
=
0
;
virtual
void
SetupPipeline
(
)
=
0
;
protected
:
void
SetGeometry
(
const
ItemInfo
&
aItem
GeometryMode
aMode
)
;
void
SetDefaultGeometry
(
const
ItemInfo
&
aItem
)
{
SetGeometry
(
aItem
GeometryMode
:
:
Unknown
)
;
}
virtual
bool
OnPrepareBuffers
(
)
{
return
true
;
}
bool
SetupPSBuffer0
(
float
aOpacity
)
;
bool
HasMask
(
)
const
{
return
!
!
mMask
;
}
MaskOperation
*
GetMask
(
)
const
{
return
mMask
;
}
protected
:
GeometryMode
mGeometry
;
RefPtr
<
MaskOperation
>
mMask
;
bool
mHasRectTransformAndClip
;
VertexStagingBuffer
mInstances
;
VertexBufferSection
mInstanceBuffer
;
ConstantBufferSection
mPSBuffer0
;
}
;
template
<
typename
Traits
>
class
BatchRenderPass
:
public
ShaderRenderPass
{
public
:
BatchRenderPass
(
FrameBuilder
*
aBuilder
const
ItemInfo
&
aItem
)
:
ShaderRenderPass
(
aBuilder
aItem
)
{
}
protected
:
class
Txn
final
{
public
:
explicit
Txn
(
BatchRenderPass
*
aPass
)
:
mPass
(
aPass
)
mPrevInstancePos
(
aPass
-
>
mInstances
.
GetPosition
(
)
)
{
}
bool
Add
(
const
Traits
&
aTraits
)
{
if
(
!
AddImpl
(
aTraits
)
)
{
return
Fail
(
)
;
}
return
true
;
}
bool
AddImpl
(
const
Traits
&
aTraits
)
;
bool
Fail
(
)
{
MOZ_ASSERT
(
!
mStatus
.
isSome
(
)
|
|
!
mStatus
.
value
(
)
)
;
mStatus
=
Some
(
false
)
;
return
false
;
}
bool
Commit
(
)
{
MOZ_ASSERT
(
!
mStatus
.
isSome
(
)
|
|
!
mStatus
.
value
(
)
)
;
if
(
mStatus
.
isSome
(
)
)
{
return
false
;
}
mStatus
=
Some
(
true
)
;
return
true
;
}
~
Txn
(
)
{
if
(
!
mStatus
.
isSome
(
)
|
|
!
mStatus
.
value
(
)
)
{
mPass
-
>
mInstances
.
RestorePosition
(
mPrevInstancePos
)
;
}
}
private
:
BatchRenderPass
*
mPass
;
VertexStagingBuffer
:
:
Position
mPrevVertexPos
;
VertexStagingBuffer
:
:
Position
mPrevItemPos
;
ConstantStagingBuffer
:
:
Position
mPrevInstancePos
;
Maybe
<
bool
>
mStatus
;
}
;
}
;
class
TexturedRenderPass
:
public
BatchRenderPass
<
TexturedTraits
>
{
public
:
explicit
TexturedRenderPass
(
FrameBuilder
*
aBuilder
const
ItemInfo
&
aItem
)
;
protected
:
struct
Info
final
{
Info
(
const
ItemInfo
&
aItem
PaintedLayerMLGPU
*
aLayer
)
;
Info
(
const
ItemInfo
&
aItem
TexturedLayerMLGPU
*
aLayer
)
;
Info
(
const
ItemInfo
&
aItem
ContainerLayerMLGPU
*
aLayer
)
;
const
ItemInfo
&
item
;
gfx
:
:
IntSize
textureSize
;
gfx
:
:
Point
destOrigin
;
Maybe
<
gfx
:
:
Size
>
scale
;
bool
decomposeIntoNoRepeatRects
;
}
;
template
<
typename
RegionType
>
bool
AddItems
(
Txn
&
aTxn
const
Info
&
aInfo
const
RegionType
&
aDrawRegion
)
{
for
(
auto
iter
=
aDrawRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
gfx
:
:
Rect
drawRect
=
gfx
:
:
Rect
(
iter
.
Get
(
)
.
ToUnknownRect
(
)
)
;
if
(
!
AddItem
(
aTxn
aInfo
drawRect
)
)
{
return
false
;
}
}
return
true
;
}
private
:
bool
AddItem
(
Txn
&
aTxn
const
Info
&
aInfo
const
gfx
:
:
Rect
&
aDrawRect
)
;
bool
AddClippedItem
(
Txn
&
aTxn
const
Info
&
aInfo
const
gfx
:
:
Rect
&
aDrawRect
)
;
protected
:
TextureFlags
mTextureFlags
;
}
;
class
ClearViewPass
final
:
public
RenderPassMLGPU
{
public
:
ClearViewPass
(
FrameBuilder
*
aBuilder
const
ItemInfo
&
aItem
)
;
bool
IsCompatible
(
const
ItemInfo
&
aItem
)
override
;
void
ExecuteRendering
(
)
override
;
RenderPassType
GetType
(
)
const
override
{
return
RenderPassType
:
:
ClearView
;
}
private
:
bool
AddToPass
(
LayerMLGPU
*
aItem
ItemInfo
&
aInfo
)
override
;
private
:
RenderViewMLGPU
*
mView
;
gfx
:
:
DeviceColor
mColor
;
nsTArray
<
gfx
:
:
IntRect
>
mRects
;
}
;
class
SolidColorPass
final
:
public
BatchRenderPass
<
ColorTraits
>
{
public
:
explicit
SolidColorPass
(
FrameBuilder
*
aBuilder
const
ItemInfo
&
aItem
)
;
RenderPassType
GetType
(
)
const
override
{
return
RenderPassType
:
:
SolidColor
;
}
private
:
bool
AddToPass
(
LayerMLGPU
*
aItem
ItemInfo
&
aInfo
)
override
;
void
SetupPipeline
(
)
override
;
float
GetOpacity
(
)
const
override
;
}
;
class
SingleTexturePass
final
:
public
TexturedRenderPass
{
public
:
explicit
SingleTexturePass
(
FrameBuilder
*
aBuilder
const
ItemInfo
&
aItem
)
;
RenderPassType
GetType
(
)
const
override
{
return
RenderPassType
:
:
SingleTexture
;
}
private
:
bool
AddToPass
(
LayerMLGPU
*
aItem
ItemInfo
&
aInfo
)
override
;
void
SetupPipeline
(
)
override
;
float
GetOpacity
(
)
const
override
{
return
mOpacity
;
}
Maybe
<
MLGBlendState
>
GetBlendState
(
)
const
override
;
private
:
RefPtr
<
TextureSource
>
mTexture
;
SamplerMode
mSamplerMode
;
float
mOpacity
;
}
;
class
ComponentAlphaPass
final
:
public
TexturedRenderPass
{
public
:
explicit
ComponentAlphaPass
(
FrameBuilder
*
aBuilder
const
ItemInfo
&
aItem
)
;
RenderPassType
GetType
(
)
const
override
{
return
RenderPassType
:
:
ComponentAlpha
;
}
private
:
bool
AddToPass
(
LayerMLGPU
*
aItem
ItemInfo
&
aInfo
)
override
;
void
SetupPipeline
(
)
override
;
float
GetOpacity
(
)
const
override
;
Maybe
<
MLGBlendState
>
GetBlendState
(
)
const
override
{
return
Some
(
MLGBlendState
:
:
ComponentAlpha
)
;
}
private
:
float
mOpacity
;
SamplerMode
mSamplerMode
;
RefPtr
<
TextureSource
>
mTextureOnBlack
;
RefPtr
<
TextureSource
>
mTextureOnWhite
;
}
;
class
VideoRenderPass
final
:
public
TexturedRenderPass
{
public
:
explicit
VideoRenderPass
(
FrameBuilder
*
aBuilder
const
ItemInfo
&
aItem
)
;
RenderPassType
GetType
(
)
const
override
{
return
RenderPassType
:
:
Video
;
}
private
:
bool
AddToPass
(
LayerMLGPU
*
aItem
ItemInfo
&
aInfo
)
override
;
void
SetupPipeline
(
)
override
;
float
GetOpacity
(
)
const
override
{
return
mOpacity
;
}
private
:
RefPtr
<
TextureHost
>
mHost
;
RefPtr
<
TextureSource
>
mTexture
;
SamplerMode
mSamplerMode
;
float
mOpacity
;
}
;
class
RenderViewPass
final
:
public
TexturedRenderPass
{
public
:
RenderViewPass
(
FrameBuilder
*
aBuilder
const
ItemInfo
&
aItem
)
;
RenderPassType
GetType
(
)
const
override
{
return
RenderPassType
:
:
RenderView
;
}
private
:
bool
AddToPass
(
LayerMLGPU
*
aItem
ItemInfo
&
aInfo
)
override
;
void
SetupPipeline
(
)
override
;
bool
OnPrepareBuffers
(
)
override
;
void
ExecuteRendering
(
)
override
;
float
GetOpacity
(
)
const
override
;
bool
PrepareBlendState
(
)
;
void
RenderWithBackdropCopy
(
)
;
private
:
ConstantBufferSection
mBlendConstants
;
ContainerLayerMLGPU
*
mAssignedLayer
;
RefPtr
<
MLGRenderTarget
>
mSource
;
RenderViewMLGPU
*
mParentView
;
gfx
:
:
IntRect
mBackdropCopyRect
;
Maybe
<
gfx
:
:
CompositionOp
>
mBlendMode
;
}
;
}
}
#
endif
