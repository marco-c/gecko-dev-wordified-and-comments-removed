#
ifndef
mozilla_gfx_layers_mlgpu_LayerMLGPU_h
#
define
mozilla_gfx_layers_mlgpu_LayerMLGPU_h
#
include
"
Layers
.
h
"
#
include
"
mozilla
/
layers
/
LayerManagerComposite
.
h
"
namespace
mozilla
{
namespace
layers
{
class
CanvasLayerMLGPU
;
class
ColorLayerMLGPU
;
class
ContainerLayerMLGPU
;
class
FrameBuilder
;
class
ImageHost
;
class
ImageLayerMLGPU
;
class
LayerManagerMLGPU
;
class
MaskOperation
;
class
MLGRenderTarget
;
class
PaintedLayerMLGPU
;
class
RefLayerMLGPU
;
class
RenderViewMLGPU
;
class
TexturedLayerMLGPU
;
class
TextureSource
;
class
LayerMLGPU
:
public
HostLayer
{
public
:
LayerMLGPU
*
AsLayerMLGPU
(
)
override
{
return
this
;
}
virtual
PaintedLayerMLGPU
*
AsPaintedLayerMLGPU
(
)
{
return
nullptr
;
}
virtual
ImageLayerMLGPU
*
AsImageLayerMLGPU
(
)
{
return
nullptr
;
}
virtual
CanvasLayerMLGPU
*
AsCanvasLayerMLGPU
(
)
{
return
nullptr
;
}
virtual
ContainerLayerMLGPU
*
AsContainerLayerMLGPU
(
)
{
return
nullptr
;
}
virtual
RefLayerMLGPU
*
AsRefLayerMLGPU
(
)
{
return
nullptr
;
}
virtual
ColorLayerMLGPU
*
AsColorLayerMLGPU
(
)
{
return
nullptr
;
}
virtual
TexturedLayerMLGPU
*
AsTexturedLayerMLGPU
(
)
{
return
nullptr
;
}
static
void
BeginFrame
(
)
;
bool
PrepareToRender
(
FrameBuilder
*
aBuilder
const
RenderTargetIntRect
&
aClipRect
)
;
Layer
:
:
LayerType
GetType
(
)
{
return
GetLayer
(
)
-
>
GetType
(
)
;
}
const
RenderTargetIntRect
&
GetComputedClipRect
(
)
const
{
return
mComputedClipRect
;
}
MaskOperation
*
GetMask
(
)
const
{
return
mMask
;
}
float
GetComputedOpacity
(
)
const
{
return
mComputedOpacity
;
}
gfx
:
:
IntRect
GetClippedBoundingBox
(
RenderViewMLGPU
*
aView
const
Maybe
<
gfx
:
:
Polygon
>
&
aGeometry
)
;
bool
IsPrepared
(
)
const
{
return
mFrameKey
=
=
sFrameKey
&
&
mPrepared
;
}
virtual
bool
IsContentOpaque
(
)
;
const
LayerIntRegion
&
GetRenderRegion
(
)
const
{
return
mRenderRegion
;
}
virtual
void
SetRenderRegion
(
LayerIntRegion
&
&
aRegion
)
;
virtual
void
AssignToView
(
FrameBuilder
*
aBuilder
RenderViewMLGPU
*
aView
Maybe
<
gfx
:
:
Polygon
>
&
&
aGeometry
)
;
virtual
bool
OnPrepareToRender
(
FrameBuilder
*
aBuilder
)
{
return
true
;
}
virtual
void
ClearCachedResources
(
)
{
}
virtual
CompositableHost
*
GetCompositableHost
(
)
override
{
return
nullptr
;
}
protected
:
LayerMLGPU
(
LayerManagerMLGPU
*
aManager
)
;
LayerManagerMLGPU
*
GetManager
(
)
;
void
AddBoundsToView
(
FrameBuilder
*
aBuilder
RenderViewMLGPU
*
aView
Maybe
<
gfx
:
:
Polygon
>
&
&
aGeometry
)
;
void
MarkPrepared
(
)
;
void
SetLayerManager
(
HostLayerManager
*
aManager
)
override
;
virtual
void
OnLayerManagerChange
(
LayerManagerMLGPU
*
aManager
)
{
}
private
:
static
uint64_t
sFrameKey
;
protected
:
RenderTargetIntRect
mComputedClipRect
;
RefPtr
<
MaskOperation
>
mMask
;
uint64_t
mFrameKey
;
float
mComputedOpacity
;
bool
mPrepared
;
LayerIntRegion
mRenderRegion
;
}
;
class
RefLayerMLGPU
final
:
public
RefLayer
public
LayerMLGPU
{
public
:
explicit
RefLayerMLGPU
(
LayerManagerMLGPU
*
aManager
)
;
~
RefLayerMLGPU
(
)
override
;
HostLayer
*
AsHostLayer
(
)
override
{
return
this
;
}
RefLayerMLGPU
*
AsRefLayerMLGPU
(
)
override
{
return
this
;
}
Layer
*
GetLayer
(
)
override
{
return
this
;
}
void
ComputeEffectiveTransforms
(
const
gfx
:
:
Matrix4x4
&
aTransformToSurface
)
override
{
DefaultComputeEffectiveTransforms
(
aTransformToSurface
)
;
}
const
LayerIntRegion
&
GetShadowVisibleRegion
(
)
override
;
MOZ_LAYER_DECL_NAME
(
"
RefLayerMLGPU
"
TYPE_REF
)
}
;
class
ColorLayerMLGPU
final
:
public
ColorLayer
public
LayerMLGPU
{
public
:
explicit
ColorLayerMLGPU
(
LayerManagerMLGPU
*
aManager
)
;
~
ColorLayerMLGPU
(
)
override
;
bool
IsContentOpaque
(
)
override
{
return
mColor
.
a
>
=
1
.
0f
;
}
HostLayer
*
AsHostLayer
(
)
override
{
return
this
;
}
ColorLayerMLGPU
*
AsColorLayerMLGPU
(
)
override
{
return
this
;
}
Layer
*
GetLayer
(
)
override
{
return
this
;
}
MOZ_LAYER_DECL_NAME
(
"
ColorLayerMLGPU
"
TYPE_COLOR
)
}
;
}
}
#
endif
