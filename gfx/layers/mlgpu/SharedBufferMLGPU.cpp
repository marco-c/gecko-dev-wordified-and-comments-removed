#
include
"
SharedBufferMLGPU
.
h
"
#
include
"
BufferCache
.
h
"
#
include
"
MLGDevice
.
h
"
using
namespace
std
;
namespace
mozilla
{
namespace
layers
{
SharedBufferMLGPU
:
:
SharedBufferMLGPU
(
MLGDevice
*
aDevice
MLGBufferType
aType
size_t
aDefaultSize
)
:
mDevice
(
aDevice
)
mType
(
aType
)
mDefaultSize
(
aDefaultSize
)
mCanUseOffsetAllocation
(
true
)
mCurrentPosition
(
0
)
mMaxSize
(
0
)
mMapped
(
false
)
mBytesUsedThisFrame
(
0
)
mNumSmallFrames
(
0
)
{
MOZ_COUNT_CTOR
(
SharedBufferMLGPU
)
;
}
SharedBufferMLGPU
:
:
~
SharedBufferMLGPU
(
)
{
MOZ_COUNT_DTOR
(
SharedBufferMLGPU
)
;
Unmap
(
)
;
}
bool
SharedBufferMLGPU
:
:
Init
(
)
{
if
(
!
mCanUseOffsetAllocation
)
{
return
true
;
}
if
(
!
GrowBuffer
(
mDefaultSize
)
)
{
return
false
;
}
return
true
;
}
void
SharedBufferMLGPU
:
:
Reset
(
)
{
Unmap
(
)
;
mBytesUsedThisFrame
=
0
;
if
(
mBuffer
&
&
(
mBuffer
-
>
GetSize
(
)
>
mDefaultSize
*
4
)
&
&
mNumSmallFrames
>
=
10
)
{
mBuffer
=
nullptr
;
}
}
bool
SharedBufferMLGPU
:
:
EnsureMappedBuffer
(
size_t
aBytes
)
{
if
(
!
mBuffer
|
|
(
mMaxSize
-
mCurrentPosition
<
aBytes
)
)
{
if
(
!
GrowBuffer
(
aBytes
)
)
{
return
false
;
}
}
if
(
!
mMapped
&
&
!
Map
(
)
)
{
return
false
;
}
return
true
;
}
static
const
size_t
kMaxCachedBufferSize
=
128
*
1024
;
bool
SharedBufferMLGPU
:
:
GrowBuffer
(
size_t
aBytes
)
{
MOZ_ASSERT
(
mCanUseOffsetAllocation
)
;
Unmap
(
)
;
size_t
maybeSize
=
mDefaultSize
;
if
(
mBuffer
)
{
maybeSize
=
std
:
:
min
(
kMaxCachedBufferSize
mBuffer
-
>
GetSize
(
)
*
2
)
;
}
size_t
bytes
=
std
:
:
max
(
aBytes
maybeSize
)
;
mBuffer
=
mDevice
-
>
CreateBuffer
(
mType
bytes
MLGUsage
:
:
Dynamic
)
;
if
(
!
mBuffer
)
{
return
false
;
}
mCurrentPosition
=
0
;
mMaxSize
=
mBuffer
-
>
GetSize
(
)
;
return
true
;
}
void
SharedBufferMLGPU
:
:
PrepareForUsage
(
)
{
Unmap
(
)
;
if
(
mBytesUsedThisFrame
<
=
mDefaultSize
)
{
mNumSmallFrames
+
+
;
}
else
{
mNumSmallFrames
=
0
;
}
}
bool
SharedBufferMLGPU
:
:
Map
(
)
{
MOZ_ASSERT
(
mBuffer
)
;
MOZ_ASSERT
(
!
mMapped
)
;
if
(
!
mDevice
-
>
Map
(
mBuffer
MLGMapType
:
:
WRITE_DISCARD
&
mMap
)
)
{
mBuffer
=
nullptr
;
return
false
;
}
mCurrentPosition
=
0
;
mMapped
=
true
;
return
true
;
}
void
SharedBufferMLGPU
:
:
Unmap
(
)
{
if
(
!
mMapped
)
{
return
;
}
mBytesUsedThisFrame
+
=
mCurrentPosition
;
mDevice
-
>
Unmap
(
mBuffer
)
;
mMap
=
MLGMappedResource
(
)
;
mMapped
=
false
;
}
SharedVertexBuffer
:
:
SharedVertexBuffer
(
MLGDevice
*
aDevice
size_t
aDefaultSize
)
:
SharedBufferMLGPU
(
aDevice
MLGBufferType
:
:
Vertex
aDefaultSize
)
{
}
SharedConstantBuffer
:
:
SharedConstantBuffer
(
MLGDevice
*
aDevice
size_t
aDefaultSize
)
:
SharedBufferMLGPU
(
aDevice
MLGBufferType
:
:
Constant
aDefaultSize
)
{
mMaxConstantBufferBindSize
=
aDevice
-
>
GetMaxConstantBufferBindSize
(
)
;
mCanUseOffsetAllocation
=
aDevice
-
>
CanUseConstantBufferOffsetBinding
(
)
;
}
uint8_t
*
SharedConstantBuffer
:
:
AllocateNewBuffer
(
size_t
aBytes
ptrdiff_t
*
aOutOffset
RefPtr
<
MLGBuffer
>
*
aOutBuffer
)
{
RefPtr
<
MLGBuffer
>
buffer
;
if
(
BufferCache
*
cache
=
mDevice
-
>
GetConstantBufferCache
(
)
)
{
buffer
=
cache
-
>
GetOrCreateBuffer
(
aBytes
)
;
}
else
{
buffer
=
mDevice
-
>
CreateBuffer
(
MLGBufferType
:
:
Constant
aBytes
MLGUsage
:
:
Dynamic
)
;
}
if
(
!
buffer
)
{
return
nullptr
;
}
MLGMappedResource
map
;
if
(
!
mDevice
-
>
Map
(
buffer
MLGMapType
:
:
WRITE_DISCARD
&
map
)
)
{
return
nullptr
;
}
*
aOutOffset
=
-
1
;
*
aOutBuffer
=
buffer
;
return
reinterpret_cast
<
uint8_t
*
>
(
map
.
mData
)
;
}
void
AutoBufferUploadBase
:
:
UnmapBuffer
(
)
{
mDevice
-
>
Unmap
(
mBuffer
)
;
}
}
}
