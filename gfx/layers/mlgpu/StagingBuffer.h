#
ifndef
mozilla_gfx_layers_mlgpu_StagingBuffer_h
#
define
mozilla_gfx_layers_mlgpu_StagingBuffer_h
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
UtilityMLGPU
.
h
"
#
include
<
algorithm
>
#
include
<
utility
>
#
include
<
limits
.
h
>
namespace
mozilla
{
namespace
layers
{
class
MLGDevice
;
template
<
size_t
Alignment
=
0
>
class
StagingBuffer
{
public
:
StagingBuffer
(
)
:
StagingBuffer
(
0
)
{
}
void
SetReversed
(
)
{
MOZ_ASSERT
(
IsEmpty
(
)
)
;
mReversed
=
true
;
}
template
<
typename
T
>
bool
AddItem
(
const
T
&
aItem
)
{
if
(
mReversed
)
{
return
PrependItem
(
aItem
)
;
}
return
AppendItem
(
aItem
)
;
}
template
<
typename
T1
typename
T2
>
bool
AddItem
(
const
T1
&
aItem1
const
T2
&
aItem2
)
{
if
(
mReversed
)
{
return
PrependItem
(
aItem1
aItem2
)
;
}
return
AppendItem
(
aItem1
aItem2
)
;
}
template
<
typename
T
>
bool
AppendItem
(
const
T
&
aItem
)
{
MOZ_ASSERT
(
!
mReversed
)
;
size_t
alignedBytes
=
AlignUp
<
Alignment
>
:
:
calc
(
sizeof
(
aItem
)
)
;
if
(
!
mUniformSize
)
{
mUniformSize
=
alignedBytes
;
}
if
(
!
EnsureForwardRoomFor
(
alignedBytes
)
)
{
return
false
;
}
if
(
mUniformSize
!
=
alignedBytes
)
{
MOZ_ASSERT_UNREACHABLE
(
"
item
of
incorrect
size
added
!
"
)
;
return
false
;
}
*
reinterpret_cast
<
T
*
>
(
mPos
)
=
aItem
;
mPos
+
=
alignedBytes
;
MOZ_ASSERT
(
mPos
<
=
mEnd
)
;
mNumItems
+
+
;
return
true
;
}
template
<
typename
T1
typename
T2
>
bool
AppendItem
(
const
T1
&
aFirst
const
T2
&
aSecond
)
{
struct
Combined
{
T1
first
;
T2
second
;
}
value
=
{
aFirst
aSecond
}
;
static_assert
(
sizeof
(
value
)
=
=
sizeof
(
aFirst
)
+
sizeof
(
aSecond
)
"
Items
must
be
packed
within
struct
"
)
;
return
AppendItem
(
value
)
;
}
template
<
typename
T
>
bool
PrependItem
(
const
T
&
aItem
)
{
MOZ_ASSERT
(
mReversed
)
;
size_t
alignedBytes
=
AlignUp
<
Alignment
>
:
:
calc
(
sizeof
(
aItem
)
)
;
if
(
!
mUniformSize
)
{
mUniformSize
=
alignedBytes
;
}
if
(
!
EnsureBackwardRoomFor
(
alignedBytes
)
)
{
return
false
;
}
if
(
mUniformSize
!
=
alignedBytes
)
{
MOZ_ASSERT_UNREACHABLE
(
"
item
of
incorrect
size
added
!
"
)
;
return
false
;
}
mPos
-
=
alignedBytes
;
*
reinterpret_cast
<
T
*
>
(
mPos
)
=
aItem
;
MOZ_ASSERT
(
mPos
>
=
mBuffer
.
get
(
)
)
;
mNumItems
+
+
;
return
true
;
}
template
<
typename
T1
typename
T2
>
bool
PrependItem
(
const
T1
&
aFirst
const
T2
&
aSecond
)
{
struct
Combined
{
T1
first
;
T2
second
;
}
value
=
{
aFirst
aSecond
}
;
static_assert
(
sizeof
(
value
)
=
=
sizeof
(
aFirst
)
+
sizeof
(
aSecond
)
"
Items
must
be
packed
within
struct
"
)
;
return
PrependItem
(
value
)
;
}
size_t
NumBytes
(
)
const
{
return
mReversed
?
mEnd
-
mPos
:
mPos
-
mBuffer
.
get
(
)
;
}
uint8_t
*
GetBufferStart
(
)
const
{
return
mReversed
?
mPos
:
mBuffer
.
get
(
)
;
}
size_t
SizeOfItem
(
)
const
{
return
mUniformSize
;
}
size_t
NumItems
(
)
const
{
return
mNumItems
;
}
void
Reset
(
)
{
mPos
=
mReversed
?
mEnd
:
mBuffer
.
get
(
)
;
mUniformSize
=
0
;
mNumItems
=
0
;
}
typedef
std
:
:
pair
<
size_t
size_t
>
Position
;
Position
GetPosition
(
)
const
{
return
std
:
:
make_pair
(
NumBytes
(
)
mNumItems
)
;
}
void
RestorePosition
(
const
Position
&
aPosition
)
{
mPos
=
mBuffer
.
get
(
)
+
aPosition
.
first
;
mNumItems
=
aPosition
.
second
;
if
(
mNumItems
=
=
0
)
{
mUniformSize
=
0
;
}
MOZ_ASSERT
(
mPos
>
=
mBuffer
.
get
(
)
&
&
mPos
<
=
mEnd
)
;
MOZ_ASSERT
(
mNumItems
*
mUniformSize
=
=
NumBytes
(
)
)
;
}
bool
IsEmpty
(
)
const
{
return
mNumItems
=
=
0
;
}
protected
:
explicit
StagingBuffer
(
size_t
aMaxSize
)
:
mPos
(
nullptr
)
mEnd
(
nullptr
)
mUniformSize
(
0
)
mNumItems
(
0
)
mMaxSize
(
aMaxSize
)
mReversed
(
false
)
{
}
static
const
size_t
kDefaultSize
=
8
;
bool
EnsureForwardRoomFor
(
size_t
aAlignedBytes
)
{
if
(
size_t
(
mEnd
-
mPos
)
<
aAlignedBytes
)
{
return
GrowBuffer
(
aAlignedBytes
)
;
}
return
true
;
}
bool
EnsureBackwardRoomFor
(
size_t
aAlignedBytes
)
{
if
(
size_t
(
mPos
-
mBuffer
.
get
(
)
)
<
aAlignedBytes
)
{
return
GrowBuffer
(
aAlignedBytes
)
;
}
return
true
;
}
bool
GrowBuffer
(
size_t
aAlignedBytes
)
{
MOZ_ASSERT_IF
(
mMaxSize
aAlignedBytes
<
mMaxSize
)
;
MOZ_ASSERT_IF
(
mMaxSize
kDefaultSize
*
Alignment
<
mMaxSize
)
;
if
(
!
mBuffer
)
{
size_t
newSize
=
std
:
:
max
(
kDefaultSize
*
Alignment
aAlignedBytes
)
;
MOZ_ASSERT_IF
(
mMaxSize
newSize
<
mMaxSize
)
;
mBuffer
=
MakeUnique
<
uint8_t
[
]
>
(
newSize
)
;
mEnd
=
mBuffer
.
get
(
)
+
newSize
;
mPos
=
mReversed
?
mEnd
:
mBuffer
.
get
(
)
;
return
true
;
}
size_t
oldSize
=
mEnd
-
mBuffer
.
get
(
)
;
size_t
trySize
=
std
:
:
max
(
oldSize
+
aAlignedBytes
oldSize
+
oldSize
/
2
)
;
size_t
newSize
=
mMaxSize
?
std
:
:
min
(
trySize
mMaxSize
)
:
trySize
;
if
(
newSize
<
oldSize
|
|
newSize
-
oldSize
<
aAlignedBytes
)
{
return
false
;
}
UniquePtr
<
uint8_t
[
]
>
newBuffer
=
MakeUnique
<
uint8_t
[
]
>
(
newSize
)
;
if
(
!
newBuffer
)
{
return
false
;
}
if
(
mReversed
)
{
size_t
usedBytes
=
mEnd
-
mPos
;
size_t
newPos
=
newSize
-
usedBytes
;
MOZ_RELEASE_ASSERT
(
newPos
+
usedBytes
<
=
newSize
)
;
memcpy
(
newBuffer
.
get
(
)
+
newPos
mPos
usedBytes
)
;
mPos
=
newBuffer
.
get
(
)
+
newPos
;
}
else
{
size_t
usedBytes
=
mPos
-
mBuffer
.
get
(
)
;
MOZ_RELEASE_ASSERT
(
usedBytes
<
=
newSize
)
;
memcpy
(
newBuffer
.
get
(
)
mBuffer
.
get
(
)
usedBytes
)
;
mPos
=
newBuffer
.
get
(
)
+
usedBytes
;
}
mEnd
=
newBuffer
.
get
(
)
+
newSize
;
mBuffer
=
std
:
:
move
(
newBuffer
)
;
MOZ_RELEASE_ASSERT
(
mPos
>
=
mBuffer
.
get
(
)
&
&
mPos
<
=
mEnd
)
;
return
true
;
}
protected
:
UniquePtr
<
uint8_t
[
]
>
mBuffer
;
uint8_t
*
mPos
;
uint8_t
*
mEnd
;
size_t
mUniformSize
;
size_t
mNumItems
;
size_t
mMaxSize
;
bool
mReversed
;
}
;
class
ConstantStagingBuffer
:
public
StagingBuffer
<
16
>
{
public
:
explicit
ConstantStagingBuffer
(
MLGDevice
*
aDevice
)
;
}
;
}
}
#
endif
