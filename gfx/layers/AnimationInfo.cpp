#
include
"
AnimationInfo
.
h
"
#
include
"
mozilla
/
LayerAnimationInfo
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
layers
/
AnimationHelper
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
dom
/
Animation
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
PuppetWidget
.
h
"
namespace
mozilla
{
namespace
layers
{
AnimationInfo
:
:
AnimationInfo
(
)
:
mCompositorAnimationsId
(
0
)
mMutated
(
false
)
{
}
AnimationInfo
:
:
~
AnimationInfo
(
)
{
}
void
AnimationInfo
:
:
EnsureAnimationsId
(
)
{
if
(
!
mCompositorAnimationsId
)
{
mCompositorAnimationsId
=
AnimationHelper
:
:
GetNextCompositorAnimationsId
(
)
;
}
}
Animation
*
AnimationInfo
:
:
AddAnimation
(
)
{
MOZ_ASSERT
(
!
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
EnsureAnimationsId
(
)
;
MOZ_ASSERT
(
!
mPendingAnimations
"
should
have
called
ClearAnimations
first
"
)
;
Animation
*
anim
=
mAnimations
.
AppendElement
(
)
;
mMutated
=
true
;
return
anim
;
}
Animation
*
AnimationInfo
:
:
AddAnimationForNextTransaction
(
)
{
MOZ_ASSERT
(
!
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
MOZ_ASSERT
(
mPendingAnimations
"
should
have
called
ClearAnimationsForNextTransaction
first
"
)
;
Animation
*
anim
=
mPendingAnimations
-
>
AppendElement
(
)
;
return
anim
;
}
void
AnimationInfo
:
:
ClearAnimations
(
)
{
mPendingAnimations
=
nullptr
;
if
(
mAnimations
.
IsEmpty
(
)
&
&
mPropertyAnimationGroups
.
IsEmpty
(
)
)
{
return
;
}
mAnimations
.
Clear
(
)
;
mPropertyAnimationGroups
.
Clear
(
)
;
if
(
mTransformLikeMetaData
)
{
mTransformLikeMetaData
-
>
Clear
(
)
;
}
mTransformLikeMetaData
.
reset
(
)
;
mCachedMotionPath
=
nullptr
;
mMutated
=
true
;
}
void
AnimationInfo
:
:
ClearAnimationsForNextTransaction
(
)
{
if
(
!
mPendingAnimations
)
{
mPendingAnimations
=
MakeUnique
<
AnimationArray
>
(
)
;
}
mPendingAnimations
-
>
Clear
(
)
;
}
void
AnimationInfo
:
:
SetCompositorAnimations
(
const
CompositorAnimations
&
aCompositorAnimations
)
{
mCompositorAnimationsId
=
aCompositorAnimations
.
id
(
)
;
AnimationStorageData
data
=
AnimationHelper
:
:
ExtractAnimations
(
aCompositorAnimations
.
animations
(
)
)
;
mPropertyAnimationGroups
.
SwapElements
(
data
.
mAnimation
)
;
if
(
data
.
mTransformLikeMetaData
.
HasData
(
)
)
{
mTransformLikeMetaData
=
MakeUnique
<
CompositorAnimationData
>
(
std
:
:
move
(
data
.
mTransformLikeMetaData
)
)
;
}
mCachedMotionPath
.
swap
(
data
.
mCachedMotionPath
)
;
}
bool
AnimationInfo
:
:
StartPendingAnimations
(
const
TimeStamp
&
aReadyTime
)
{
bool
updated
=
false
;
for
(
size_t
animIdx
=
0
animEnd
=
mAnimations
.
Length
(
)
;
animIdx
<
animEnd
;
animIdx
+
+
)
{
Animation
&
anim
=
mAnimations
[
animIdx
]
;
if
(
!
std
:
:
isnan
(
anim
.
previousPlaybackRate
(
)
)
&
&
anim
.
startTime
(
)
.
isSome
(
)
&
&
!
anim
.
originTime
(
)
.
IsNull
(
)
&
&
!
anim
.
isNotPlaying
(
)
)
{
TimeDuration
readyTime
=
aReadyTime
-
anim
.
originTime
(
)
;
anim
.
holdTime
(
)
=
dom
:
:
Animation
:
:
CurrentTimeFromTimelineTime
(
readyTime
anim
.
startTime
(
)
.
ref
(
)
anim
.
previousPlaybackRate
(
)
)
;
anim
.
startTime
(
)
=
Nothing
(
)
;
}
if
(
anim
.
startTime
(
)
.
isNothing
(
)
&
&
!
anim
.
originTime
(
)
.
IsNull
(
)
&
&
!
anim
.
isNotPlaying
(
)
)
{
TimeDuration
readyTime
=
aReadyTime
-
anim
.
originTime
(
)
;
anim
.
startTime
(
)
=
Some
(
dom
:
:
Animation
:
:
StartTimeFromTimelineTime
(
readyTime
anim
.
holdTime
(
)
anim
.
playbackRate
(
)
)
)
;
updated
=
true
;
}
}
return
updated
;
}
void
AnimationInfo
:
:
TransferMutatedFlagToLayer
(
Layer
*
aLayer
)
{
if
(
mMutated
)
{
aLayer
-
>
Mutated
(
)
;
mMutated
=
false
;
}
}
bool
AnimationInfo
:
:
ApplyPendingUpdatesForThisTransaction
(
)
{
if
(
mPendingAnimations
)
{
mPendingAnimations
-
>
SwapElements
(
mAnimations
)
;
mPendingAnimations
=
nullptr
;
return
true
;
}
return
false
;
}
bool
AnimationInfo
:
:
HasTransformAnimation
(
)
const
{
const
nsCSSPropertyIDSet
&
transformSet
=
LayerAnimationInfo
:
:
GetCSSPropertiesFor
(
DisplayItemType
:
:
TYPE_TRANSFORM
)
;
for
(
uint32_t
i
=
0
;
i
<
mAnimations
.
Length
(
)
;
i
+
+
)
{
if
(
transformSet
.
HasProperty
(
mAnimations
[
i
]
.
property
(
)
)
)
{
return
true
;
}
}
return
false
;
}
Maybe
<
uint64_t
>
AnimationInfo
:
:
GetGenerationFromFrame
(
nsIFrame
*
aFrame
DisplayItemType
aDisplayItemKey
)
{
MOZ_ASSERT
(
aFrame
-
>
IsPrimaryFrame
(
)
|
|
nsLayoutUtils
:
:
IsFirstContinuationOrIBSplitSibling
(
aFrame
)
)
;
layers
:
:
Layer
*
layer
=
FrameLayerBuilder
:
:
GetDedicatedLayer
(
aFrame
aDisplayItemKey
)
;
if
(
layer
)
{
return
layer
-
>
GetAnimationInfo
(
)
.
GetAnimationGeneration
(
)
;
}
if
(
nsLayoutUtils
:
:
IsFirstContinuationOrIBSplitSibling
(
aFrame
)
)
{
aFrame
=
nsLayoutUtils
:
:
LastContinuationOrIBSplitSibling
(
aFrame
)
;
}
RefPtr
<
WebRenderAnimationData
>
animationData
=
GetWebRenderUserData
<
WebRenderAnimationData
>
(
aFrame
(
uint32_t
)
aDisplayItemKey
)
;
if
(
animationData
)
{
return
animationData
-
>
GetAnimationInfo
(
)
.
GetAnimationGeneration
(
)
;
}
return
Nothing
(
)
;
}
void
AnimationInfo
:
:
EnumerateGenerationOnFrame
(
const
nsIFrame
*
aFrame
const
nsIContent
*
aContent
const
CompositorAnimatableDisplayItemTypes
&
aDisplayItemTypes
const
AnimationGenerationCallback
&
aCallback
)
{
if
(
XRE_IsContentProcess
(
)
)
{
if
(
nsIWidget
*
widget
=
nsContentUtils
:
:
WidgetForContent
(
aContent
)
)
{
if
(
widget
-
>
GetOwningBrowserChild
(
)
&
&
!
static_cast
<
widget
:
:
PuppetWidget
*
>
(
widget
)
-
>
HasLayerManager
(
)
)
{
for
(
auto
displayItem
:
LayerAnimationInfo
:
:
sDisplayItemTypes
)
{
aCallback
(
Nothing
(
)
displayItem
)
;
}
return
;
}
}
}
RefPtr
<
LayerManager
>
layerManager
=
nsContentUtils
:
:
LayerManagerForContent
(
aContent
)
;
if
(
layerManager
&
&
layerManager
-
>
GetBackendType
(
)
=
=
layers
:
:
LayersBackend
:
:
LAYERS_WR
)
{
if
(
nsLayoutUtils
:
:
IsFirstContinuationOrIBSplitSibling
(
aFrame
)
)
{
aFrame
=
nsLayoutUtils
:
:
LastContinuationOrIBSplitSibling
(
aFrame
)
;
}
for
(
auto
displayItem
:
LayerAnimationInfo
:
:
sDisplayItemTypes
)
{
const
nsIFrame
*
frameToQuery
=
displayItem
=
=
DisplayItemType
:
:
TYPE_TRANSFORM
?
nsLayoutUtils
:
:
GetPrimaryFrameFromStyleFrame
(
aFrame
)
:
aFrame
;
RefPtr
<
WebRenderAnimationData
>
animationData
=
GetWebRenderUserData
<
WebRenderAnimationData
>
(
frameToQuery
(
uint32_t
)
displayItem
)
;
Maybe
<
uint64_t
>
generation
;
if
(
animationData
)
{
generation
=
animationData
-
>
GetAnimationInfo
(
)
.
GetAnimationGeneration
(
)
;
}
aCallback
(
generation
displayItem
)
;
}
return
;
}
FrameLayerBuilder
:
:
EnumerateGenerationForDedicatedLayers
(
aFrame
aCallback
)
;
}
}
}
