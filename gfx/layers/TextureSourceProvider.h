#
ifndef
mozilla_gfx_layers_TextureSourceProvider_h
#
define
mozilla_gfx_layers_TextureSourceProvider_h
#
include
"
nsISupportsImpl
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
layers
/
CompositorTypes
.
h
"
#
include
"
nsTArray
.
h
"
struct
ID3D11Device
;
namespace
mozilla
{
namespace
gfx
{
class
DataSourceSurface
;
}
namespace
gl
{
class
GLContext
;
}
namespace
layers
{
class
TextureHost
;
class
DataTextureSource
;
class
Compositor
;
class
TextureSourceProvider
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
TextureSourceProvider
)
virtual
already_AddRefed
<
DataTextureSource
>
CreateDataTextureSource
(
TextureFlags
aFlags
=
TextureFlags
:
:
NO_FLAGS
)
=
0
;
virtual
already_AddRefed
<
DataTextureSource
>
CreateDataTextureSourceAround
(
gfx
:
:
DataSourceSurface
*
aSurface
)
{
return
nullptr
;
}
virtual
already_AddRefed
<
DataTextureSource
>
CreateDataTextureSourceAroundYCbCr
(
TextureHost
*
aTexture
)
{
return
nullptr
;
}
virtual
TimeStamp
GetLastCompositionEndTime
(
)
const
=
0
;
virtual
bool
SupportsEffect
(
EffectTypes
aEffect
)
{
return
true
;
}
void
UnlockAfterComposition
(
TextureHost
*
aTexture
)
;
virtual
bool
NotifyNotUsedAfterComposition
(
TextureHost
*
aTextureHost
)
;
virtual
void
Destroy
(
)
;
void
FlushPendingNotifyNotUsed
(
)
;
virtual
Compositor
*
AsCompositor
(
)
{
return
nullptr
;
}
#
ifdef
XP_WIN
virtual
ID3D11Device
*
GetD3D11Device
(
)
const
{
return
nullptr
;
}
#
endif
virtual
gl
:
:
GLContext
*
GetGLContext
(
)
const
{
return
nullptr
;
}
virtual
int32_t
GetMaxTextureSize
(
)
const
=
0
;
virtual
bool
IsValid
(
)
const
=
0
;
protected
:
void
ReadUnlockTextures
(
)
;
protected
:
virtual
~
TextureSourceProvider
(
)
;
private
:
nsTArray
<
RefPtr
<
TextureHost
>
>
mUnlockAfterComposition
;
nsTArray
<
RefPtr
<
TextureHost
>
>
mNotifyNotUsedAfterComposition
;
}
;
}
}
#
endif
