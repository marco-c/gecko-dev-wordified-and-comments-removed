#
ifndef
MOZILLA_GFX_SOURCESURFACESHAREDDATA_H_
#
define
MOZILLA_GFX_SOURCESURFACESHAREDDATA_H_
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemoryBasic
.
h
"
namespace
mozilla
{
namespace
gfx
{
class
SourceSurfaceSharedData
;
class
SourceSurfaceSharedDataWrapper
final
:
public
DataSourceSurface
{
typedef
mozilla
:
:
ipc
:
:
SharedMemoryBasic
SharedMemoryBasic
;
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
SourceSurfaceSharedDataWrapper
override
)
SourceSurfaceSharedDataWrapper
(
)
:
mStride
(
0
)
mConsumers
(
0
)
mFormat
(
SurfaceFormat
:
:
UNKNOWN
)
mCreatorPid
(
0
)
mCreatorRef
(
true
)
{
}
bool
Init
(
const
IntSize
&
aSize
int32_t
aStride
SurfaceFormat
aFormat
const
SharedMemoryBasic
:
:
Handle
&
aHandle
base
:
:
ProcessId
aCreatorPid
)
;
void
Init
(
SourceSurfaceSharedData
*
aSurface
)
;
base
:
:
ProcessId
GetCreatorPid
(
)
const
{
return
mCreatorPid
;
}
int32_t
Stride
(
)
override
{
return
mStride
;
}
SurfaceType
GetType
(
)
const
override
{
return
SurfaceType
:
:
DATA
;
}
IntSize
GetSize
(
)
const
override
{
return
mSize
;
}
SurfaceFormat
GetFormat
(
)
const
override
{
return
mFormat
;
}
uint8_t
*
GetData
(
)
override
{
return
static_cast
<
uint8_t
*
>
(
mBuf
-
>
memory
(
)
)
;
}
bool
OnHeap
(
)
const
override
{
return
false
;
}
bool
AddConsumer
(
)
{
return
+
+
mConsumers
=
=
1
;
}
bool
RemoveConsumer
(
bool
aForCreator
)
{
MOZ_ASSERT
(
mConsumers
>
0
)
;
if
(
aForCreator
)
{
if
(
!
mCreatorRef
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Already
released
creator
reference
!
"
)
;
return
false
;
}
mCreatorRef
=
false
;
}
return
-
-
mConsumers
=
=
0
;
}
uint32_t
GetConsumers
(
)
const
{
MOZ_ASSERT
(
mConsumers
>
0
)
;
return
mConsumers
;
}
bool
HasCreatorRef
(
)
const
{
return
mCreatorRef
;
}
private
:
size_t
GetDataLength
(
)
const
{
return
static_cast
<
size_t
>
(
mStride
)
*
mSize
.
height
;
}
size_t
GetAlignedDataLength
(
)
const
{
return
mozilla
:
:
ipc
:
:
SharedMemory
:
:
PageAlignedSize
(
GetDataLength
(
)
)
;
}
int32_t
mStride
;
uint32_t
mConsumers
;
IntSize
mSize
;
RefPtr
<
SharedMemoryBasic
>
mBuf
;
SurfaceFormat
mFormat
;
base
:
:
ProcessId
mCreatorPid
;
bool
mCreatorRef
;
}
;
class
SourceSurfaceSharedData
final
:
public
DataSourceSurface
{
typedef
mozilla
:
:
ipc
:
:
SharedMemoryBasic
SharedMemoryBasic
;
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
SourceSurfaceSharedData
override
)
SourceSurfaceSharedData
(
)
:
mMutex
(
"
SourceSurfaceSharedData
"
)
mStride
(
0
)
mHandleCount
(
0
)
mFormat
(
SurfaceFormat
:
:
UNKNOWN
)
mClosed
(
false
)
mFinalized
(
false
)
mShared
(
false
)
{
}
bool
Init
(
const
IntSize
&
aSize
int32_t
aStride
SurfaceFormat
aFormat
bool
aShare
=
true
)
;
uint8_t
*
GetData
(
)
override
{
MutexAutoLock
lock
(
mMutex
)
;
return
GetDataInternal
(
)
;
}
int32_t
Stride
(
)
override
{
return
mStride
;
}
SurfaceType
GetType
(
)
const
override
{
return
SurfaceType
:
:
DATA_SHARED
;
}
IntSize
GetSize
(
)
const
override
{
return
mSize
;
}
SurfaceFormat
GetFormat
(
)
const
override
{
return
mFormat
;
}
void
GuaranteePersistance
(
)
override
;
void
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
SizeOfInfo
&
aInfo
)
const
override
;
bool
OnHeap
(
)
const
override
{
return
false
;
}
bool
Map
(
MapType
MappedSurface
*
aMappedSurface
)
override
{
MutexAutoLock
lock
(
mMutex
)
;
+
+
mMapCount
;
aMappedSurface
-
>
mData
=
GetDataInternal
(
)
;
aMappedSurface
-
>
mStride
=
mStride
;
return
true
;
}
void
Unmap
(
)
override
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mMapCount
>
0
)
;
if
(
-
-
mMapCount
=
=
0
)
{
mOldBuf
=
nullptr
;
}
}
nsresult
ShareToProcess
(
base
:
:
ProcessId
aPid
SharedMemoryBasic
:
:
Handle
&
aHandle
)
;
void
FinishedSharing
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
mShared
=
true
;
CloseHandleInternal
(
)
;
}
bool
CanShare
(
)
const
{
MutexAutoLock
lock
(
mMutex
)
;
return
!
mClosed
;
}
bool
ReallocHandle
(
)
;
void
Finalize
(
)
;
bool
IsFinalized
(
)
const
{
MutexAutoLock
lock
(
mMutex
)
;
return
mFinalized
;
}
Maybe
<
IntRect
>
TakeDirtyRect
(
)
override
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mDirtyRect
)
{
Maybe
<
IntRect
>
ret
=
std
:
:
move
(
mDirtyRect
)
;
return
ret
;
}
return
Nothing
(
)
;
}
void
Invalidate
(
const
IntRect
&
aDirtyRect
)
override
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
aDirtyRect
.
IsEmpty
(
)
)
{
if
(
mDirtyRect
)
{
mDirtyRect
-
>
UnionRect
(
mDirtyRect
.
ref
(
)
aDirtyRect
)
;
}
else
{
mDirtyRect
=
Some
(
aDirtyRect
)
;
}
}
else
{
mDirtyRect
=
Some
(
IntRect
(
IntPoint
(
0
0
)
mSize
)
)
;
}
MOZ_ASSERT_IF
(
mDirtyRect
!
mDirtyRect
-
>
IsEmpty
(
)
)
;
}
class
MOZ_STACK_CLASS
HandleLock
final
{
public
:
explicit
HandleLock
(
SourceSurfaceSharedData
*
aSurface
)
:
mSurface
(
aSurface
)
{
mSurface
-
>
LockHandle
(
)
;
}
~
HandleLock
(
)
{
mSurface
-
>
UnlockHandle
(
)
;
}
private
:
RefPtr
<
SourceSurfaceSharedData
>
mSurface
;
}
;
private
:
friend
class
SourceSurfaceSharedDataWrapper
;
virtual
~
SourceSurfaceSharedData
(
)
=
default
;
void
LockHandle
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
+
+
mHandleCount
;
}
void
UnlockHandle
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mHandleCount
>
0
)
;
-
-
mHandleCount
;
mShared
=
true
;
CloseHandleInternal
(
)
;
}
uint8_t
*
GetDataInternal
(
)
const
;
size_t
GetDataLength
(
)
const
{
return
static_cast
<
size_t
>
(
mStride
)
*
mSize
.
height
;
}
size_t
GetAlignedDataLength
(
)
const
{
return
mozilla
:
:
ipc
:
:
SharedMemory
:
:
PageAlignedSize
(
GetDataLength
(
)
)
;
}
void
CloseHandleInternal
(
)
;
mutable
Mutex
mMutex
;
int32_t
mStride
;
int32_t
mHandleCount
;
Maybe
<
IntRect
>
mDirtyRect
;
IntSize
mSize
;
RefPtr
<
SharedMemoryBasic
>
mBuf
;
RefPtr
<
SharedMemoryBasic
>
mOldBuf
;
SurfaceFormat
mFormat
;
bool
mClosed
:
1
;
bool
mFinalized
:
1
;
bool
mShared
:
1
;
}
;
}
}
#
endif
