#
ifndef
MOZILLA_GFX_SOURCESURFACESHAREDDATA_H_
#
define
MOZILLA_GFX_SOURCESURFACESHAREDDATA_H_
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemoryBasic
.
h
"
namespace
mozilla
{
namespace
gfx
{
class
SourceSurfaceSharedData
final
:
public
DataSourceSurface
{
typedef
mozilla
:
:
ipc
:
:
SharedMemoryBasic
SharedMemoryBasic
;
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
SourceSurfaceSharedData
override
)
SourceSurfaceSharedData
(
)
:
mMutex
(
"
SourceSurfaceSharedData
"
)
mStride
(
0
)
mMapCount
(
0
)
mFormat
(
SurfaceFormat
:
:
UNKNOWN
)
mClosed
(
false
)
mFinalized
(
false
)
mShared
(
false
)
{
}
bool
Init
(
const
IntSize
&
aSize
int32_t
aStride
SurfaceFormat
aFormat
)
;
uint8_t
*
GetData
(
)
override
{
MutexAutoLock
lock
(
mMutex
)
;
return
GetDataInternal
(
)
;
}
int32_t
Stride
(
)
override
{
return
mStride
;
}
SurfaceType
GetType
(
)
const
override
{
return
SurfaceType
:
:
DATA_SHARED
;
}
IntSize
GetSize
(
)
const
override
{
return
mSize
;
}
SurfaceFormat
GetFormat
(
)
const
override
{
return
mFormat
;
}
void
GuaranteePersistance
(
)
override
;
void
AddSizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
size_t
&
aHeapSizeOut
size_t
&
aNonHeapSizeOut
)
const
override
;
bool
OnHeap
(
)
const
override
{
return
false
;
}
bool
Map
(
MapType
MappedSurface
*
aMappedSurface
)
override
{
MutexAutoLock
lock
(
mMutex
)
;
+
+
mMapCount
;
aMappedSurface
-
>
mData
=
GetDataInternal
(
)
;
aMappedSurface
-
>
mStride
=
mStride
;
return
true
;
}
void
Unmap
(
)
override
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mMapCount
>
0
)
;
if
(
-
-
mMapCount
=
=
0
)
{
mOldBuf
=
nullptr
;
}
}
nsresult
ShareToProcess
(
base
:
:
ProcessId
aPid
SharedMemoryBasic
:
:
Handle
&
aHandle
)
;
void
FinishedSharing
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
mShared
=
true
;
CloseHandleInternal
(
)
;
}
bool
CanShare
(
)
const
{
MutexAutoLock
lock
(
mMutex
)
;
return
!
mClosed
;
}
bool
ReallocHandle
(
)
;
void
Finalize
(
)
;
private
:
~
SourceSurfaceSharedData
(
)
override
{
MOZ_ASSERT
(
mMapCount
=
=
0
)
;
}
uint8_t
*
GetDataInternal
(
)
const
;
size_t
GetDataLength
(
)
const
{
return
static_cast
<
size_t
>
(
mStride
)
*
mSize
.
height
;
}
size_t
GetAlignedDataLength
(
)
const
{
return
mozilla
:
:
ipc
:
:
SharedMemory
:
:
PageAlignedSize
(
GetDataLength
(
)
)
;
}
void
CloseHandleInternal
(
)
;
mutable
Mutex
mMutex
;
int32_t
mStride
;
int32_t
mMapCount
;
IntSize
mSize
;
RefPtr
<
SharedMemoryBasic
>
mBuf
;
RefPtr
<
SharedMemoryBasic
>
mOldBuf
;
SurfaceFormat
mFormat
;
bool
mClosed
:
1
;
bool
mFinalized
:
1
;
bool
mShared
:
1
;
}
;
}
}
#
endif
