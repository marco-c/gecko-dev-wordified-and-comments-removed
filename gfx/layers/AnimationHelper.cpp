#
include
"
AnimationHelper
.
h
"
#
include
"
base
/
process_util
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxLineSegment
.
h
"
#
include
"
gfxPoint
.
h
"
#
include
"
gfxQuad
.
h
"
#
include
"
gfxRect
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
ServoStyleConsts
.
h
"
#
include
"
mozilla
/
dom
/
AnimationEffectBinding
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffectBinding
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffect
.
h
"
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
#
include
"
mozilla
/
layers
/
APZSampler
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
LayerAnimationInfo
.
h
"
#
include
"
mozilla
/
MotionPathUtils
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsDisplayList
.
h
"
namespace
mozilla
{
namespace
layers
{
static
dom
:
:
Nullable
<
TimeDuration
>
CalculateElapsedTimeForScrollTimeline
(
const
Maybe
<
APZSampler
:
:
ScrollOffsetAndRange
>
aScrollMeta
const
ScrollTimelineOptions
&
aOptions
const
StickyTimeDuration
&
aEndTime
const
TimeDuration
&
aStartTime
float
aPlaybackRate
)
{
if
(
!
aScrollMeta
)
{
return
nullptr
;
}
const
bool
isHorizontal
=
aOptions
.
axis
(
)
=
=
layers
:
:
ScrollDirection
:
:
eHorizontal
;
double
range
=
isHorizontal
?
aScrollMeta
-
>
mRange
.
width
:
aScrollMeta
-
>
mRange
.
height
;
MOZ_ASSERT
(
range
>
0
"
We
don
'
t
expect
to
get
a
zero
or
negative
range
on
the
compositor
"
)
;
double
position
=
std
:
:
abs
(
isHorizontal
?
aScrollMeta
-
>
mOffset
.
x
:
aScrollMeta
-
>
mOffset
.
y
)
;
double
progress
=
position
/
range
;
progress
=
std
:
:
min
(
progress
1
.
0
)
;
auto
timelineTime
=
TimeDuration
(
aEndTime
.
MultDouble
(
progress
)
)
;
return
dom
:
:
Animation
:
:
CurrentTimeFromTimelineTime
(
timelineTime
aStartTime
aPlaybackRate
)
;
}
static
dom
:
:
Nullable
<
TimeDuration
>
CalculateElapsedTime
(
const
APZSampler
*
aAPZSampler
const
LayersId
&
aLayersId
const
MutexAutoLock
&
aProofOfMapLock
const
PropertyAnimation
&
aAnimation
const
TimeStamp
aPreviousFrameTime
const
TimeStamp
aCurrentFrameTime
const
AnimatedValue
*
aPreviousValue
)
{
if
(
aAnimation
.
mScrollTimelineOptions
)
{
MOZ_ASSERT
(
aAPZSampler
"
We
don
'
t
send
scroll
animations
to
the
compositor
if
APZ
is
disabled
"
)
;
return
CalculateElapsedTimeForScrollTimeline
(
aAPZSampler
-
>
GetCurrentScrollOffsetAndRange
(
aLayersId
aAnimation
.
mScrollTimelineOptions
.
value
(
)
.
source
(
)
aProofOfMapLock
)
aAnimation
.
mScrollTimelineOptions
.
value
(
)
aAnimation
.
mTiming
.
EndTime
(
)
aAnimation
.
mStartTime
.
refOr
(
aAnimation
.
mHoldTime
)
aAnimation
.
mPlaybackRate
)
;
}
MOZ_ASSERT
(
(
!
aAnimation
.
mOriginTime
.
IsNull
(
)
&
&
aAnimation
.
mStartTime
.
isSome
(
)
)
|
|
aAnimation
.
mIsNotPlaying
"
If
we
are
playing
we
should
have
an
origin
time
and
a
start
time
"
)
;
bool
hasFutureReadyTime
=
false
;
if
(
!
aPreviousValue
&
&
!
aAnimation
.
mIsNotPlaying
&
&
!
aPreviousFrameTime
.
IsNull
(
)
)
{
const
TimeStamp
readyTime
=
aAnimation
.
mOriginTime
+
(
aAnimation
.
mStartTime
.
ref
(
)
+
aAnimation
.
mHoldTime
.
MultDouble
(
1
.
0
/
aAnimation
.
mPlaybackRate
)
)
;
hasFutureReadyTime
=
!
readyTime
.
IsNull
(
)
&
&
readyTime
>
aPreviousFrameTime
;
}
const
TimeStamp
&
timeStamp
=
aPreviousFrameTime
.
IsNull
(
)
|
|
hasFutureReadyTime
?
aCurrentFrameTime
:
aPreviousFrameTime
;
TimeDuration
elapsedDuration
=
aAnimation
.
mIsNotPlaying
|
|
aAnimation
.
mStartTime
.
isNothing
(
)
?
aAnimation
.
mHoldTime
:
(
timeStamp
-
aAnimation
.
mOriginTime
-
aAnimation
.
mStartTime
.
ref
(
)
)
.
MultDouble
(
aAnimation
.
mPlaybackRate
)
;
return
elapsedDuration
;
}
enum
class
CanSkipCompose
{
IfPossible
No
}
;
static
AnimationHelper
:
:
SampleResult
SampleAnimationForProperty
(
const
APZSampler
*
aAPZSampler
const
LayersId
&
aLayersId
const
MutexAutoLock
&
aProofOfMapLock
TimeStamp
aPreviousFrameTime
TimeStamp
aCurrentFrameTime
const
AnimatedValue
*
aPreviousValue
CanSkipCompose
aCanSkipCompose
nsTArray
<
PropertyAnimation
>
&
aPropertyAnimations
RefPtr
<
StyleAnimationValue
>
&
aAnimationValue
)
{
MOZ_ASSERT
(
!
aPropertyAnimations
.
IsEmpty
(
)
"
Should
have
animations
"
)
;
auto
reason
=
AnimationHelper
:
:
SampleResult
:
:
Reason
:
:
None
;
bool
hasInEffectAnimations
=
false
;
#
ifdef
DEBUG
bool
shouldBeSkipped
=
false
;
#
endif
for
(
PropertyAnimation
&
animation
:
aPropertyAnimations
)
{
dom
:
:
Nullable
<
TimeDuration
>
elapsedDuration
=
CalculateElapsedTime
(
aAPZSampler
aLayersId
aProofOfMapLock
animation
aPreviousFrameTime
aCurrentFrameTime
aPreviousValue
)
;
const
auto
progressTimelinePosition
=
animation
.
mScrollTimelineOptions
?
dom
:
:
Animation
:
:
AtProgressTimelineBoundary
(
TimeDuration
:
:
FromMilliseconds
(
PROGRESS_TIMELINE_DURATION_MILLISEC
)
elapsedDuration
animation
.
mStartTime
.
refOr
(
TimeDuration
(
)
)
animation
.
mPlaybackRate
)
:
dom
:
:
Animation
:
:
ProgressTimelinePosition
:
:
NotBoundary
;
ComputedTiming
computedTiming
=
dom
:
:
AnimationEffect
:
:
GetComputedTimingAt
(
elapsedDuration
animation
.
mTiming
animation
.
mPlaybackRate
progressTimelinePosition
)
;
if
(
computedTiming
.
mProgress
.
IsNull
(
)
)
{
if
(
animation
.
mScrollTimelineOptions
&
&
!
animation
.
mProgressOnLastCompose
.
IsNull
(
)
&
&
(
computedTiming
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
Before
|
|
computedTiming
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
After
)
)
{
animation
.
ResetLastCompositionValues
(
)
;
reason
=
AnimationHelper
:
:
SampleResult
:
:
Reason
:
:
ScrollToDelayPhase
;
}
continue
;
}
dom
:
:
IterationCompositeOperation
iterCompositeOperation
=
animation
.
mIterationComposite
;
if
(
aCanSkipCompose
=
=
CanSkipCompose
:
:
IfPossible
&
&
!
dom
:
:
KeyframeEffect
:
:
HasComputedTimingChanged
(
computedTiming
iterCompositeOperation
animation
.
mProgressOnLastCompose
animation
.
mCurrentIterationOnLastCompose
)
)
{
#
ifdef
DEBUG
shouldBeSkipped
=
true
;
#
else
return
AnimationHelper
:
:
SampleResult
:
:
Skipped
(
)
;
#
endif
}
uint32_t
segmentIndex
=
0
;
size_t
segmentSize
=
animation
.
mSegments
.
Length
(
)
;
PropertyAnimation
:
:
SegmentData
*
segment
=
animation
.
mSegments
.
Elements
(
)
;
while
(
segment
-
>
mEndPortion
<
computedTiming
.
mProgress
.
Value
(
)
&
&
segmentIndex
<
segmentSize
-
1
)
{
+
+
segment
;
+
+
segmentIndex
;
}
double
positionInSegment
=
(
computedTiming
.
mProgress
.
Value
(
)
-
segment
-
>
mStartPortion
)
/
(
segment
-
>
mEndPortion
-
segment
-
>
mStartPortion
)
;
double
portion
=
StyleComputedTimingFunction
:
:
GetPortion
(
segment
-
>
mFunction
positionInSegment
computedTiming
.
mBeforeFlag
)
;
if
(
aCanSkipCompose
=
=
CanSkipCompose
:
:
IfPossible
&
&
animation
.
mSegmentIndexOnLastCompose
=
=
segmentIndex
&
&
!
animation
.
mPortionInSegmentOnLastCompose
.
IsNull
(
)
&
&
animation
.
mPortionInSegmentOnLastCompose
.
Value
(
)
=
=
portion
)
{
#
ifdef
DEBUG
shouldBeSkipped
=
true
;
#
else
return
AnimationHelper
:
:
SampleResult
:
:
Skipped
(
)
;
#
endif
}
AnimationPropertySegment
animSegment
;
animSegment
.
mFromKey
=
0
.
0
;
animSegment
.
mToKey
=
1
.
0
;
animSegment
.
mFromValue
=
AnimationValue
(
segment
-
>
mStartValue
)
;
animSegment
.
mToValue
=
AnimationValue
(
segment
-
>
mEndValue
)
;
animSegment
.
mFromComposite
=
segment
-
>
mStartComposite
;
animSegment
.
mToComposite
=
segment
-
>
mEndComposite
;
aAnimationValue
=
Servo_ComposeAnimationSegment
(
&
animSegment
aAnimationValue
animation
.
mSegments
.
LastElement
(
)
.
mEndValue
iterCompositeOperation
portion
computedTiming
.
mCurrentIteration
)
.
Consume
(
)
;
#
ifdef
DEBUG
if
(
shouldBeSkipped
)
{
return
AnimationHelper
:
:
SampleResult
:
:
Skipped
(
)
;
}
#
endif
hasInEffectAnimations
=
true
;
animation
.
mProgressOnLastCompose
=
computedTiming
.
mProgress
;
animation
.
mCurrentIterationOnLastCompose
=
computedTiming
.
mCurrentIteration
;
animation
.
mSegmentIndexOnLastCompose
=
segmentIndex
;
animation
.
mPortionInSegmentOnLastCompose
.
SetValue
(
portion
)
;
}
auto
rv
=
hasInEffectAnimations
?
AnimationHelper
:
:
SampleResult
:
:
Sampled
(
)
:
AnimationHelper
:
:
SampleResult
(
)
;
rv
.
mReason
=
reason
;
return
rv
;
}
AnimationHelper
:
:
SampleResult
AnimationHelper
:
:
SampleAnimationForEachNode
(
const
APZSampler
*
aAPZSampler
const
LayersId
&
aLayersId
const
MutexAutoLock
&
aProofOfMapLock
TimeStamp
aPreviousFrameTime
TimeStamp
aCurrentFrameTime
const
AnimatedValue
*
aPreviousValue
nsTArray
<
PropertyAnimationGroup
>
&
aPropertyAnimationGroups
nsTArray
<
RefPtr
<
StyleAnimationValue
>
>
&
aAnimationValues
)
{
MOZ_ASSERT
(
!
aPropertyAnimationGroups
.
IsEmpty
(
)
"
Should
be
called
with
animation
data
"
)
;
MOZ_ASSERT
(
aAnimationValues
.
IsEmpty
(
)
"
Should
be
called
with
empty
aAnimationValues
"
)
;
nsTArray
<
RefPtr
<
StyleAnimationValue
>
>
baseStyleOfDelayAnimations
;
nsTArray
<
RefPtr
<
StyleAnimationValue
>
>
nonAnimatingValues
;
for
(
PropertyAnimationGroup
&
group
:
aPropertyAnimationGroups
)
{
RefPtr
<
StyleAnimationValue
>
currValue
=
group
.
mBaseStyle
;
CanSkipCompose
canSkipCompose
=
aPreviousValue
&
&
aPropertyAnimationGroups
.
Length
(
)
=
=
1
&
&
group
.
mAnimations
.
Length
(
)
=
=
1
?
CanSkipCompose
:
:
IfPossible
:
CanSkipCompose
:
:
No
;
MOZ_ASSERT
(
!
group
.
mAnimations
.
IsEmpty
(
)
|
|
nsCSSPropertyIDSet
:
:
TransformLikeProperties
(
)
.
HasProperty
(
group
.
mProperty
)
"
Only
transform
-
like
properties
can
have
empty
PropertyAnimation
list
"
)
;
if
(
group
.
mAnimations
.
IsEmpty
(
)
)
{
nonAnimatingValues
.
AppendElement
(
std
:
:
move
(
currValue
)
)
;
continue
;
}
SampleResult
result
=
SampleAnimationForProperty
(
aAPZSampler
aLayersId
aProofOfMapLock
aPreviousFrameTime
aCurrentFrameTime
aPreviousValue
canSkipCompose
group
.
mAnimations
currValue
)
;
if
(
result
.
IsSkipped
(
)
)
{
#
ifdef
DEBUG
aAnimationValues
.
AppendElement
(
std
:
:
move
(
currValue
)
)
;
#
endif
return
result
;
}
if
(
!
result
.
IsSampled
(
)
)
{
if
(
result
.
mReason
=
=
SampleResult
:
:
Reason
:
:
ScrollToDelayPhase
)
{
MOZ_ASSERT
(
currValue
&
&
currValue
=
=
group
.
mBaseStyle
)
;
baseStyleOfDelayAnimations
.
AppendElement
(
std
:
:
move
(
currValue
)
)
;
}
continue
;
}
MOZ_ASSERT
(
currValue
)
;
aAnimationValues
.
AppendElement
(
std
:
:
move
(
currValue
)
)
;
}
SampleResult
rv
=
aAnimationValues
.
IsEmpty
(
)
?
SampleResult
(
)
:
SampleResult
:
:
Sampled
(
)
;
if
(
rv
.
IsNone
(
)
&
&
!
baseStyleOfDelayAnimations
.
IsEmpty
(
)
)
{
aAnimationValues
.
AppendElements
(
std
:
:
move
(
baseStyleOfDelayAnimations
)
)
;
rv
.
mReason
=
SampleResult
:
:
Reason
:
:
ScrollToDelayPhase
;
}
if
(
!
aAnimationValues
.
IsEmpty
(
)
)
{
aAnimationValues
.
AppendElements
(
std
:
:
move
(
nonAnimatingValues
)
)
;
}
return
rv
;
}
static
dom
:
:
FillMode
GetAdjustedFillMode
(
const
Animation
&
aAnimation
)
{
auto
fillMode
=
static_cast
<
dom
:
:
FillMode
>
(
aAnimation
.
fillMode
(
)
)
;
float
playbackRate
=
aAnimation
.
playbackRate
(
)
;
switch
(
fillMode
)
{
case
dom
:
:
FillMode
:
:
None
:
if
(
playbackRate
>
0
)
{
fillMode
=
dom
:
:
FillMode
:
:
Forwards
;
}
else
if
(
playbackRate
<
0
)
{
fillMode
=
dom
:
:
FillMode
:
:
Backwards
;
}
break
;
case
dom
:
:
FillMode
:
:
Backwards
:
if
(
playbackRate
>
0
)
{
fillMode
=
dom
:
:
FillMode
:
:
Both
;
}
break
;
case
dom
:
:
FillMode
:
:
Forwards
:
if
(
playbackRate
<
0
)
{
fillMode
=
dom
:
:
FillMode
:
:
Both
;
}
break
;
default
:
break
;
}
return
fillMode
;
}
#
ifdef
DEBUG
static
bool
HasTransformLikeAnimations
(
const
AnimationArray
&
aAnimations
)
{
nsCSSPropertyIDSet
transformSet
=
nsCSSPropertyIDSet
:
:
TransformLikeProperties
(
)
;
for
(
const
Animation
&
animation
:
aAnimations
)
{
if
(
animation
.
isNotAnimating
(
)
)
{
continue
;
}
if
(
transformSet
.
HasProperty
(
animation
.
property
(
)
)
)
{
return
true
;
}
}
return
false
;
}
#
endif
AnimationStorageData
AnimationHelper
:
:
ExtractAnimations
(
const
LayersId
&
aLayersId
const
AnimationArray
&
aAnimations
)
{
AnimationStorageData
storageData
;
storageData
.
mLayersId
=
aLayersId
;
nsCSSPropertyID
prevID
=
eCSSProperty_UNKNOWN
;
PropertyAnimationGroup
*
currData
=
nullptr
;
DebugOnly
<
const
layers
:
:
Animatable
*
>
currBaseStyle
=
nullptr
;
for
(
const
Animation
&
animation
:
aAnimations
)
{
if
(
prevID
!
=
animation
.
property
(
)
)
{
currData
=
storageData
.
mAnimation
.
AppendElement
(
)
;
currData
-
>
mProperty
=
animation
.
property
(
)
;
if
(
animation
.
transformData
(
)
)
{
MOZ_ASSERT
(
!
storageData
.
mTransformData
"
Only
one
entry
has
TransformData
"
)
;
storageData
.
mTransformData
=
animation
.
transformData
(
)
;
}
prevID
=
animation
.
property
(
)
;
currBaseStyle
=
nullptr
;
}
MOZ_ASSERT
(
currData
)
;
if
(
animation
.
baseStyle
(
)
.
type
(
)
!
=
Animatable
:
:
Tnull_t
)
{
MOZ_ASSERT
(
!
currBaseStyle
|
|
*
currBaseStyle
=
=
animation
.
baseStyle
(
)
"
Should
be
the
same
base
style
"
)
;
currData
-
>
mBaseStyle
=
AnimationValue
:
:
FromAnimatable
(
animation
.
property
(
)
animation
.
baseStyle
(
)
)
;
currBaseStyle
=
&
animation
.
baseStyle
(
)
;
}
if
(
animation
.
isNotAnimating
(
)
)
{
MOZ_ASSERT
(
nsCSSPropertyIDSet
:
:
TransformLikeProperties
(
)
.
HasProperty
(
animation
.
property
(
)
)
"
Only
transform
-
like
properties
could
set
this
true
"
)
;
if
(
animation
.
property
(
)
=
=
eCSSProperty_offset_path
)
{
MOZ_ASSERT
(
currData
-
>
mBaseStyle
"
Fixed
offset
-
path
should
have
base
style
"
)
;
MOZ_ASSERT
(
HasTransformLikeAnimations
(
aAnimations
)
)
;
AnimationValue
value
{
currData
-
>
mBaseStyle
}
;
const
StyleOffsetPath
&
offsetPath
=
value
.
GetOffsetPathProperty
(
)
;
if
(
offsetPath
.
IsPath
(
)
)
{
MOZ_ASSERT
(
!
storageData
.
mCachedMotionPath
"
Only
one
offset
-
path
:
path
(
)
is
set
"
)
;
RefPtr
<
gfx
:
:
PathBuilder
>
builder
=
MotionPathUtils
:
:
GetCompositorPathBuilder
(
)
;
storageData
.
mCachedMotionPath
=
MotionPathUtils
:
:
BuildPath
(
offsetPath
.
AsPath
(
)
builder
)
;
}
}
continue
;
}
PropertyAnimation
*
propertyAnimation
=
currData
-
>
mAnimations
.
AppendElement
(
)
;
propertyAnimation
-
>
mOriginTime
=
animation
.
originTime
(
)
;
propertyAnimation
-
>
mStartTime
=
animation
.
startTime
(
)
;
propertyAnimation
-
>
mHoldTime
=
animation
.
holdTime
(
)
;
propertyAnimation
-
>
mPlaybackRate
=
animation
.
playbackRate
(
)
;
propertyAnimation
-
>
mIterationComposite
=
static_cast
<
dom
:
:
IterationCompositeOperation
>
(
animation
.
iterationComposite
(
)
)
;
propertyAnimation
-
>
mIsNotPlaying
=
animation
.
isNotPlaying
(
)
;
propertyAnimation
-
>
mTiming
=
TimingParams
{
animation
.
duration
(
)
animation
.
delay
(
)
animation
.
endDelay
(
)
animation
.
iterations
(
)
animation
.
iterationStart
(
)
static_cast
<
dom
:
:
PlaybackDirection
>
(
animation
.
direction
(
)
)
GetAdjustedFillMode
(
animation
)
animation
.
easingFunction
(
)
}
;
propertyAnimation
-
>
mScrollTimelineOptions
=
animation
.
scrollTimelineOptions
(
)
;
nsTArray
<
PropertyAnimation
:
:
SegmentData
>
&
segmentData
=
propertyAnimation
-
>
mSegments
;
for
(
const
AnimationSegment
&
segment
:
animation
.
segments
(
)
)
{
segmentData
.
AppendElement
(
PropertyAnimation
:
:
SegmentData
{
AnimationValue
:
:
FromAnimatable
(
animation
.
property
(
)
segment
.
startState
(
)
)
AnimationValue
:
:
FromAnimatable
(
animation
.
property
(
)
segment
.
endState
(
)
)
segment
.
sampleFn
(
)
segment
.
startPortion
(
)
segment
.
endPortion
(
)
static_cast
<
dom
:
:
CompositeOperation
>
(
segment
.
startComposite
(
)
)
static_cast
<
dom
:
:
CompositeOperation
>
(
segment
.
endComposite
(
)
)
}
)
;
}
}
#
ifdef
DEBUG
if
(
!
storageData
.
mAnimation
.
IsEmpty
(
)
)
{
nsCSSPropertyIDSet
seenProperties
;
for
(
const
auto
&
group
:
storageData
.
mAnimation
)
{
nsCSSPropertyID
id
=
group
.
mProperty
;
MOZ_ASSERT
(
!
seenProperties
.
HasProperty
(
id
)
"
Should
be
a
new
property
"
)
;
seenProperties
.
AddProperty
(
id
)
;
}
MOZ_ASSERT
(
seenProperties
.
IsSubsetOf
(
LayerAnimationInfo
:
:
GetCSSPropertiesFor
(
DisplayItemType
:
:
TYPE_TRANSFORM
)
)
|
|
seenProperties
.
IsSubsetOf
(
LayerAnimationInfo
:
:
GetCSSPropertiesFor
(
DisplayItemType
:
:
TYPE_OPACITY
)
)
|
|
seenProperties
.
IsSubsetOf
(
LayerAnimationInfo
:
:
GetCSSPropertiesFor
(
DisplayItemType
:
:
TYPE_BACKGROUND_COLOR
)
)
"
The
property
set
of
output
should
be
the
subset
of
transform
-
like
"
"
properties
opacity
or
background_color
.
"
)
;
if
(
seenProperties
.
IsSubsetOf
(
LayerAnimationInfo
:
:
GetCSSPropertiesFor
(
DisplayItemType
:
:
TYPE_TRANSFORM
)
)
)
{
MOZ_ASSERT
(
storageData
.
mTransformData
"
Should
have
TransformData
"
)
;
}
if
(
seenProperties
.
HasProperty
(
eCSSProperty_offset_path
)
)
{
MOZ_ASSERT
(
storageData
.
mTransformData
"
Should
have
TransformData
"
)
;
MOZ_ASSERT
(
storageData
.
mTransformData
-
>
motionPathData
(
)
"
Should
have
MotionPathData
"
)
;
}
}
#
endif
return
storageData
;
}
uint64_t
AnimationHelper
:
:
GetNextCompositorAnimationsId
(
)
{
static
uint32_t
sNextId
=
0
;
+
+
sNextId
;
uint32_t
procId
=
static_cast
<
uint32_t
>
(
base
:
:
GetCurrentProcId
(
)
)
;
uint64_t
nextId
=
procId
;
nextId
=
nextId
<
<
32
|
sNextId
;
return
nextId
;
}
gfx
:
:
Matrix4x4
AnimationHelper
:
:
ServoAnimationValueToMatrix4x4
(
const
nsTArray
<
RefPtr
<
StyleAnimationValue
>
>
&
aValues
const
TransformData
&
aTransformData
gfx
:
:
Path
*
aCachedMotionPath
)
{
using
nsStyleTransformMatrix
:
:
TransformReferenceBox
;
auto
noneTranslate
=
StyleTranslate
:
:
None
(
)
;
auto
noneRotate
=
StyleRotate
:
:
None
(
)
;
auto
noneScale
=
StyleScale
:
:
None
(
)
;
const
StyleTransform
noneTransform
;
const
StyleTranslate
*
translate
=
nullptr
;
const
StyleRotate
*
rotate
=
nullptr
;
const
StyleScale
*
scale
=
nullptr
;
const
StyleTransform
*
transform
=
nullptr
;
const
StyleOffsetPath
*
path
=
nullptr
;
const
StyleLengthPercentage
*
distance
=
nullptr
;
const
StyleOffsetRotate
*
offsetRotate
=
nullptr
;
const
StylePositionOrAuto
*
anchor
=
nullptr
;
for
(
const
auto
&
value
:
aValues
)
{
MOZ_ASSERT
(
value
)
;
nsCSSPropertyID
id
=
Servo_AnimationValue_GetPropertyId
(
value
)
;
switch
(
id
)
{
case
eCSSProperty_transform
:
MOZ_ASSERT
(
!
transform
)
;
transform
=
Servo_AnimationValue_GetTransform
(
value
)
;
break
;
case
eCSSProperty_translate
:
MOZ_ASSERT
(
!
translate
)
;
translate
=
Servo_AnimationValue_GetTranslate
(
value
)
;
break
;
case
eCSSProperty_rotate
:
MOZ_ASSERT
(
!
rotate
)
;
rotate
=
Servo_AnimationValue_GetRotate
(
value
)
;
break
;
case
eCSSProperty_scale
:
MOZ_ASSERT
(
!
scale
)
;
scale
=
Servo_AnimationValue_GetScale
(
value
)
;
break
;
case
eCSSProperty_offset_path
:
MOZ_ASSERT
(
!
path
)
;
path
=
Servo_AnimationValue_GetOffsetPath
(
value
)
;
break
;
case
eCSSProperty_offset_distance
:
MOZ_ASSERT
(
!
distance
)
;
distance
=
Servo_AnimationValue_GetOffsetDistance
(
value
)
;
break
;
case
eCSSProperty_offset_rotate
:
MOZ_ASSERT
(
!
offsetRotate
)
;
offsetRotate
=
Servo_AnimationValue_GetOffsetRotate
(
value
)
;
break
;
case
eCSSProperty_offset_anchor
:
MOZ_ASSERT
(
!
anchor
)
;
anchor
=
Servo_AnimationValue_GetOffsetAnchor
(
value
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
transform
-
like
property
"
)
;
}
}
TransformReferenceBox
refBox
(
nullptr
aTransformData
.
bounds
(
)
)
;
Maybe
<
ResolvedMotionPathData
>
motion
=
MotionPathUtils
:
:
ResolveMotionPath
(
path
distance
offsetRotate
anchor
aTransformData
.
motionPathData
(
)
refBox
aCachedMotionPath
)
;
gfx
:
:
Point3D
transformOrigin
=
aTransformData
.
transformOrigin
(
)
;
nsDisplayTransform
:
:
FrameTransformProperties
props
(
translate
?
*
translate
:
noneTranslate
rotate
?
*
rotate
:
noneRotate
scale
?
*
scale
:
noneScale
transform
?
*
transform
:
noneTransform
motion
transformOrigin
)
;
return
nsDisplayTransform
:
:
GetResultingTransformMatrix
(
props
refBox
aTransformData
.
appUnitsPerDevPixel
(
)
)
;
}
static
uint8_t
CollectOverflowedSideLines
(
const
gfxQuad
&
aPrerenderedQuad
SideBits
aOverflowSides
gfxLineSegment
sideLines
[
4
]
)
{
uint8_t
count
=
0
;
if
(
aOverflowSides
&
SideBits
:
:
eTop
)
{
sideLines
[
count
]
=
gfxLineSegment
(
aPrerenderedQuad
.
mPoints
[
0
]
aPrerenderedQuad
.
mPoints
[
1
]
)
;
count
+
+
;
}
if
(
aOverflowSides
&
SideBits
:
:
eRight
)
{
sideLines
[
count
]
=
gfxLineSegment
(
aPrerenderedQuad
.
mPoints
[
1
]
aPrerenderedQuad
.
mPoints
[
2
]
)
;
count
+
+
;
}
if
(
aOverflowSides
&
SideBits
:
:
eBottom
)
{
sideLines
[
count
]
=
gfxLineSegment
(
aPrerenderedQuad
.
mPoints
[
2
]
aPrerenderedQuad
.
mPoints
[
3
]
)
;
count
+
+
;
}
if
(
aOverflowSides
&
SideBits
:
:
eLeft
)
{
sideLines
[
count
]
=
gfxLineSegment
(
aPrerenderedQuad
.
mPoints
[
3
]
aPrerenderedQuad
.
mPoints
[
0
]
)
;
count
+
+
;
}
return
count
;
}
enum
RegionBits
:
uint8_t
{
Inside
=
0
Left
=
(
1
<
<
0
)
Right
=
(
1
<
<
1
)
Bottom
=
(
1
<
<
2
)
Top
=
(
1
<
<
3
)
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
RegionBits
)
;
static
RegionBits
GetRegionBitsForPoint
(
double
aX
double
aY
const
gfxRect
&
aClip
)
{
RegionBits
result
=
RegionBits
:
:
Inside
;
if
(
aX
<
aClip
.
X
(
)
)
{
result
|
=
RegionBits
:
:
Left
;
}
else
if
(
aX
>
aClip
.
XMost
(
)
)
{
result
|
=
RegionBits
:
:
Right
;
}
if
(
aY
<
aClip
.
Y
(
)
)
{
result
|
=
RegionBits
:
:
Bottom
;
}
else
if
(
aY
>
aClip
.
YMost
(
)
)
{
result
|
=
RegionBits
:
:
Top
;
}
return
result
;
}
;
static
bool
LineSegmentIntersectsClip
(
double
aX0
double
aY0
double
aX1
double
aY1
const
gfxRect
&
aClip
)
{
RegionBits
b0
=
GetRegionBitsForPoint
(
aX0
aY0
aClip
)
;
RegionBits
b1
=
GetRegionBitsForPoint
(
aX1
aY1
aClip
)
;
while
(
true
)
{
if
(
!
(
b0
|
b1
)
)
{
return
true
;
}
if
(
b0
&
b1
)
{
return
false
;
}
double
x
y
;
RegionBits
outsidePointBits
=
b1
>
b0
?
b1
:
b0
;
if
(
outsidePointBits
&
RegionBits
:
:
Top
)
{
x
=
aX0
+
(
aX1
-
aX0
)
*
(
aClip
.
YMost
(
)
-
aY0
)
/
(
aY1
-
aY0
)
;
y
=
aClip
.
YMost
(
)
;
}
else
if
(
outsidePointBits
&
RegionBits
:
:
Bottom
)
{
x
=
aX0
+
(
aX1
-
aX0
)
*
(
aClip
.
Y
(
)
-
aY0
)
/
(
aY1
-
aY0
)
;
y
=
aClip
.
Y
(
)
;
}
else
if
(
outsidePointBits
&
RegionBits
:
:
Right
)
{
y
=
aY0
+
(
aY1
-
aY0
)
*
(
aClip
.
XMost
(
)
-
aX0
)
/
(
aX1
-
aX0
)
;
x
=
aClip
.
XMost
(
)
;
}
else
if
(
outsidePointBits
&
RegionBits
:
:
Left
)
{
y
=
aY0
+
(
aY1
-
aY0
)
*
(
aClip
.
X
(
)
-
aX0
)
/
(
aX1
-
aX0
)
;
x
=
aClip
.
X
(
)
;
}
if
(
outsidePointBits
=
=
b0
)
{
aX0
=
x
;
aY0
=
y
;
b0
=
GetRegionBitsForPoint
(
aX0
aY0
aClip
)
;
}
else
{
aX1
=
x
;
aY1
=
y
;
b1
=
GetRegionBitsForPoint
(
aX1
aY1
aClip
)
;
}
}
MOZ_ASSERT_UNREACHABLE
(
)
;
return
false
;
}
bool
AnimationHelper
:
:
ShouldBeJank
(
const
LayoutDeviceRect
&
aPrerenderedRect
SideBits
aOverflowSides
const
gfx
:
:
Matrix4x4
&
aTransform
const
ParentLayerRect
&
aClipRect
)
{
if
(
aClipRect
.
IsEmpty
(
)
)
{
return
false
;
}
gfxQuad
prerenderedQuad
=
gfxUtils
:
:
TransformToQuad
(
ThebesRect
(
aPrerenderedRect
.
ToUnknownRect
(
)
)
aTransform
)
;
gfxLineSegment
sideLines
[
4
]
;
uint8_t
overflowSideCount
=
CollectOverflowedSideLines
(
prerenderedQuad
aOverflowSides
sideLines
)
;
gfxRect
clipRect
=
ThebesRect
(
aClipRect
.
ToUnknownRect
(
)
)
;
for
(
uint8_t
j
=
0
;
j
<
overflowSideCount
;
j
+
+
)
{
if
(
LineSegmentIntersectsClip
(
sideLines
[
j
]
.
mStart
.
x
sideLines
[
j
]
.
mStart
.
y
sideLines
[
j
]
.
mEnd
.
x
sideLines
[
j
]
.
mEnd
.
y
clipRect
)
)
{
return
true
;
}
}
return
GetRegionBitsForPoint
(
prerenderedQuad
.
mPoints
[
0
]
.
x
prerenderedQuad
.
mPoints
[
0
]
.
y
clipRect
)
&
GetRegionBitsForPoint
(
prerenderedQuad
.
mPoints
[
1
]
.
x
prerenderedQuad
.
mPoints
[
1
]
.
y
clipRect
)
&
GetRegionBitsForPoint
(
prerenderedQuad
.
mPoints
[
2
]
.
x
prerenderedQuad
.
mPoints
[
2
]
.
y
clipRect
)
&
GetRegionBitsForPoint
(
prerenderedQuad
.
mPoints
[
3
]
.
x
prerenderedQuad
.
mPoints
[
3
]
.
y
clipRect
)
;
}
}
}
