#
include
"
MacIOSurfaceHelpers
.
h
"
#
include
"
MacIOSurfaceImage
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
layers
/
CompositableClient
.
h
"
#
include
"
mozilla
/
layers
/
CompositableForwarder
.
h
"
#
include
"
mozilla
/
layers
/
MacIOSurfaceTextureClientOGL
.
h
"
#
include
"
mozilla
/
StaticPrefs_layers
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
YCbCrUtils
.
h
"
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
gfx
;
TextureClient
*
MacIOSurfaceImage
:
:
GetTextureClient
(
KnowsCompositor
*
aKnowsCompositor
)
{
if
(
!
mTextureClient
)
{
BackendType
backend
=
BackendType
:
:
NONE
;
mTextureClient
=
TextureClient
:
:
CreateWithData
(
MacIOSurfaceTextureData
:
:
Create
(
mSurface
backend
)
TextureFlags
:
:
DEFAULT
aKnowsCompositor
-
>
GetTextureForwarder
(
)
)
;
}
return
mTextureClient
;
}
already_AddRefed
<
SourceSurface
>
MacIOSurfaceImage
:
:
GetAsSourceSurface
(
)
{
return
CreateSourceSurfaceFromMacIOSurface
(
mSurface
)
;
}
bool
MacIOSurfaceImage
:
:
SetData
(
ImageContainer
*
aContainer
const
PlanarYCbCrData
&
aData
)
{
MOZ_ASSERT
(
!
mSurface
)
;
if
(
aData
.
mYSkip
!
=
0
|
|
aData
.
mCbSkip
!
=
0
|
|
aData
.
mCrSkip
!
=
0
|
|
!
(
aData
.
mYUVColorSpace
=
=
YUVColorSpace
:
:
BT601
|
|
aData
.
mYUVColorSpace
=
=
YUVColorSpace
:
:
BT709
)
|
|
!
(
aData
.
mColorRange
=
=
ColorRange
:
:
FULL
|
|
aData
.
mColorRange
=
=
ColorRange
:
:
LIMITED
)
|
|
aData
.
mColorDepth
!
=
ColorDepth
:
:
COLOR_8
)
{
return
false
;
}
if
(
aData
.
mCbCrSize
.
width
*
2
!
=
aData
.
mYSize
.
width
)
{
return
false
;
}
if
(
aData
.
mCbCrSize
.
height
!
=
aData
.
mYSize
.
height
&
&
aData
.
mCbCrSize
.
height
*
2
!
=
aData
.
mYSize
.
height
)
{
return
false
;
}
RefPtr
<
MacIOSurfaceRecycleAllocator
>
allocator
=
aContainer
-
>
GetMacIOSurfaceRecycleAllocator
(
)
;
RefPtr
<
MacIOSurface
>
surf
=
allocator
-
>
Allocate
(
aData
.
mYSize
aData
.
mCbCrSize
aData
.
mYUVColorSpace
aData
.
mColorRange
)
;
surf
-
>
Lock
(
false
)
;
size_t
heightScale
=
aData
.
mYSize
.
height
/
aData
.
mCbCrSize
.
height
;
MOZ_ASSERT
(
surf
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
YUV422
)
;
MOZ_ASSERT
(
aData
.
mYSize
.
height
>
0
)
;
uint8_t
*
dst
=
(
uint8_t
*
)
surf
-
>
GetBaseAddressOfPlane
(
0
)
;
size_t
stride
=
surf
-
>
GetBytesPerRow
(
0
)
;
for
(
size_t
i
=
0
;
i
<
(
size_t
)
aData
.
mYSize
.
height
;
i
+
+
)
{
uint8_t
*
rowYSrc
=
aData
.
mYChannel
+
aData
.
mYStride
*
i
;
uint8_t
*
rowCbSrc
=
aData
.
mCbChannel
+
aData
.
mCbCrStride
*
(
i
/
heightScale
)
;
uint8_t
*
rowCrSrc
=
aData
.
mCrChannel
+
aData
.
mCbCrStride
*
(
i
/
heightScale
)
;
uint8_t
*
rowDst
=
dst
+
stride
*
i
;
for
(
size_t
j
=
0
;
j
<
(
size_t
)
aData
.
mCbCrSize
.
width
;
j
+
+
)
{
*
rowDst
=
*
rowYSrc
;
rowDst
+
+
;
rowYSrc
+
+
;
*
rowDst
=
*
rowCbSrc
;
rowDst
+
+
;
rowCbSrc
+
+
;
*
rowDst
=
*
rowYSrc
;
rowDst
+
+
;
rowYSrc
+
+
;
*
rowDst
=
*
rowCrSrc
;
rowDst
+
+
;
rowCrSrc
+
+
;
}
}
surf
-
>
Unlock
(
false
)
;
mSurface
=
surf
;
mPictureRect
=
aData
.
GetPictureRect
(
)
;
return
true
;
}
already_AddRefed
<
MacIOSurface
>
MacIOSurfaceRecycleAllocator
:
:
Allocate
(
const
gfx
:
:
IntSize
aYSize
const
gfx
:
:
IntSize
&
aCbCrSize
gfx
:
:
YUVColorSpace
aYUVColorSpace
gfx
:
:
ColorRange
aColorRange
)
{
nsTArray
<
CFTypeRefPtr
<
IOSurfaceRef
>
>
surfaces
=
std
:
:
move
(
mSurfaces
)
;
RefPtr
<
MacIOSurface
>
result
;
for
(
auto
&
surf
:
surfaces
)
{
if
(
:
:
IOSurfaceGetWidthOfPlane
(
surf
.
get
(
)
0
)
!
=
(
size_t
)
aYSize
.
width
|
|
:
:
IOSurfaceGetHeightOfPlane
(
surf
.
get
(
)
0
)
!
=
(
size_t
)
aYSize
.
height
)
{
continue
;
}
if
(
!
result
&
&
!
:
:
IOSurfaceIsInUse
(
surf
.
get
(
)
)
)
{
result
=
new
MacIOSurface
(
surf
1
.
0
false
aYUVColorSpace
)
;
}
mSurfaces
.
AppendElement
(
surf
)
;
}
if
(
!
result
)
{
result
=
MacIOSurface
:
:
CreateYUV422Surface
(
aYSize
aYUVColorSpace
aColorRange
)
;
if
(
mSurfaces
.
Length
(
)
<
StaticPrefs
:
:
layers_iosurfaceimage_recycle_limit
(
)
)
{
mSurfaces
.
AppendElement
(
result
-
>
GetIOSurfaceRef
(
)
)
;
}
}
return
result
.
forget
(
)
;
}
