#
ifndef
GFX_LAYERSTYPES_H
#
define
GFX_LAYERSTYPES_H
#
include
<
stdint
.
h
>
#
include
"
Units
.
h
"
#
include
"
mozilla
/
DefineEnum
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
"
nsRegion
.
h
"
#
include
<
stdio
.
h
>
#
include
"
mozilla
/
Logging
.
h
"
#
ifndef
MOZ_LAYERS_HAVE_LOG
#
define
MOZ_LAYERS_HAVE_LOG
#
endif
#
define
MOZ_LAYERS_LOG
(
_args
)
\
MOZ_LOG
(
LayerManager
:
:
GetLog
(
)
LogLevel
:
:
Debug
_args
)
#
define
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
layer
_args
)
\
do
{
\
if
(
layer
-
>
AsShadowableLayer
(
)
)
{
\
MOZ_LOG
(
LayerManager
:
:
GetLog
(
)
LogLevel
:
:
Debug
_args
)
;
\
}
\
}
while
(
0
)
#
define
INVALID_OVERLAY
-
1
namespace
IPC
{
template
<
typename
T
>
struct
ParamTraits
;
}
namespace
mozilla
{
enum
class
StyleBorderStyle
:
uint8_t
;
namespace
layers
{
class
TextureHost
;
#
undef
NONE
#
undef
OPAQUE
struct
LayersId
{
uint64_t
mId
=
0
;
bool
IsValid
(
)
const
{
return
mId
!
=
0
;
}
explicit
operator
uint64_t
(
)
const
{
return
mId
;
}
bool
operator
<
(
const
LayersId
&
aOther
)
const
{
return
mId
<
aOther
.
mId
;
}
bool
operator
=
=
(
const
LayersId
&
aOther
)
const
{
return
mId
=
=
aOther
.
mId
;
}
bool
operator
!
=
(
const
LayersId
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
struct
HashFn
{
std
:
:
size_t
operator
(
)
(
const
LayersId
&
aKey
)
const
{
return
std
:
:
hash
<
uint64_t
>
{
}
(
aKey
.
mId
)
;
}
}
;
}
;
template
<
typename
T
>
struct
BaseTransactionId
{
uint64_t
mId
=
0
;
bool
IsValid
(
)
const
{
return
mId
!
=
0
;
}
[
[
nodiscard
]
]
BaseTransactionId
<
T
>
Next
(
)
const
{
return
BaseTransactionId
<
T
>
{
mId
+
1
}
;
}
[
[
nodiscard
]
]
BaseTransactionId
<
T
>
Prev
(
)
const
{
return
BaseTransactionId
<
T
>
{
mId
-
1
}
;
}
int64_t
operator
-
(
const
BaseTransactionId
<
T
>
&
aOther
)
const
{
return
mId
-
aOther
.
mId
;
}
explicit
operator
uint64_t
(
)
const
{
return
mId
;
}
bool
operator
<
(
const
BaseTransactionId
<
T
>
&
aOther
)
const
{
return
mId
<
aOther
.
mId
;
}
bool
operator
<
=
(
const
BaseTransactionId
<
T
>
&
aOther
)
const
{
return
mId
<
=
aOther
.
mId
;
}
bool
operator
>
(
const
BaseTransactionId
<
T
>
&
aOther
)
const
{
return
mId
>
aOther
.
mId
;
}
bool
operator
>
=
(
const
BaseTransactionId
<
T
>
&
aOther
)
const
{
return
mId
>
=
aOther
.
mId
;
}
bool
operator
=
=
(
const
BaseTransactionId
<
T
>
&
aOther
)
const
{
return
mId
=
=
aOther
.
mId
;
}
}
;
class
TransactionIdType
{
}
;
typedef
BaseTransactionId
<
TransactionIdType
>
TransactionId
;
struct
LayersObserverEpoch
{
uint64_t
mId
;
[
[
nodiscard
]
]
LayersObserverEpoch
Next
(
)
const
{
return
LayersObserverEpoch
{
mId
+
1
}
;
}
bool
operator
<
=
(
const
LayersObserverEpoch
&
aOther
)
const
{
return
mId
<
=
aOther
.
mId
;
}
bool
operator
>
=
(
const
LayersObserverEpoch
&
aOther
)
const
{
return
mId
>
=
aOther
.
mId
;
}
bool
operator
=
=
(
const
LayersObserverEpoch
&
aOther
)
const
{
return
mId
=
=
aOther
.
mId
;
}
bool
operator
!
=
(
const
LayersObserverEpoch
&
aOther
)
const
{
return
mId
!
=
aOther
.
mId
;
}
}
;
enum
class
LayersBackend
:
int8_t
{
LAYERS_NONE
=
0
LAYERS_BASIC
LAYERS_OPENGL
LAYERS_D3D11
LAYERS_CLIENT
LAYERS_WR
LAYERS_LAST
}
;
const
char
*
GetLayersBackendName
(
LayersBackend
aBackend
)
;
enum
class
TextureType
:
int8_t
{
Unknown
=
0
D3D11
DIB
X11
MacIOSurface
AndroidNativeWindow
WaylandDMABUF
Last
}
;
enum
class
BufferMode
:
int8_t
{
BUFFER_NONE
BUFFERED
}
;
enum
class
DrawRegionClip
:
int8_t
{
DRAW
NONE
}
;
enum
class
SurfaceMode
:
int8_t
{
SURFACE_NONE
=
0
SURFACE_OPAQUE
SURFACE_SINGLE_CHANNEL_ALPHA
SURFACE_COMPONENT_ALPHA
}
;
MOZ_DEFINE_ENUM_CLASS_WITH_BASE
(
ScaleMode
int8_t
(
SCALE_NONE
STRETCH
)
)
;
struct
EventRegions
{
nsIntRegion
mHitRegion
;
nsIntRegion
mDispatchToContentHitRegion
;
nsIntRegion
mNoActionRegion
;
nsIntRegion
mHorizontalPanRegion
;
nsIntRegion
mVerticalPanRegion
;
bool
mDTCRequiresTargetConfirmation
;
EventRegions
(
)
:
mDTCRequiresTargetConfirmation
(
false
)
{
}
explicit
EventRegions
(
nsIntRegion
aHitRegion
)
:
mHitRegion
(
aHitRegion
)
mDTCRequiresTargetConfirmation
(
false
)
{
}
EventRegions
(
const
nsIntRegion
&
aHitRegion
const
nsIntRegion
&
aMaybeHitRegion
const
nsIntRegion
&
aDispatchToContentRegion
const
nsIntRegion
&
aNoActionRegion
const
nsIntRegion
&
aHorizontalPanRegion
const
nsIntRegion
&
aVerticalPanRegion
bool
aDTCRequiresTargetConfirmation
)
;
bool
operator
=
=
(
const
EventRegions
&
aRegions
)
const
{
return
mHitRegion
=
=
aRegions
.
mHitRegion
&
&
mDispatchToContentHitRegion
=
=
aRegions
.
mDispatchToContentHitRegion
&
&
mNoActionRegion
=
=
aRegions
.
mNoActionRegion
&
&
mHorizontalPanRegion
=
=
aRegions
.
mHorizontalPanRegion
&
&
mVerticalPanRegion
=
=
aRegions
.
mVerticalPanRegion
&
&
mDTCRequiresTargetConfirmation
=
=
aRegions
.
mDTCRequiresTargetConfirmation
;
}
bool
operator
!
=
(
const
EventRegions
&
aRegions
)
const
{
return
!
(
*
this
=
=
aRegions
)
;
}
void
ApplyTranslationAndScale
(
float
aXTrans
float
aYTrans
float
aXScale
float
aYScale
)
{
mHitRegion
.
ScaleRoundOut
(
aXScale
aYScale
)
;
mDispatchToContentHitRegion
.
ScaleRoundOut
(
aXScale
aYScale
)
;
mNoActionRegion
.
ScaleRoundOut
(
aXScale
aYScale
)
;
mHorizontalPanRegion
.
ScaleRoundOut
(
aXScale
aYScale
)
;
mVerticalPanRegion
.
ScaleRoundOut
(
aXScale
aYScale
)
;
mHitRegion
.
MoveBy
(
aXTrans
aYTrans
)
;
mDispatchToContentHitRegion
.
MoveBy
(
aXTrans
aYTrans
)
;
mNoActionRegion
.
MoveBy
(
aXTrans
aYTrans
)
;
mHorizontalPanRegion
.
MoveBy
(
aXTrans
aYTrans
)
;
mVerticalPanRegion
.
MoveBy
(
aXTrans
aYTrans
)
;
}
void
Transform
(
const
gfx
:
:
Matrix4x4
&
aTransform
)
{
mHitRegion
.
Transform
(
aTransform
)
;
mDispatchToContentHitRegion
.
Transform
(
aTransform
)
;
mNoActionRegion
.
Transform
(
aTransform
)
;
mHorizontalPanRegion
.
Transform
(
aTransform
)
;
mVerticalPanRegion
.
Transform
(
aTransform
)
;
}
void
OrWith
(
const
EventRegions
&
aOther
)
{
mHitRegion
.
OrWith
(
aOther
.
mHitRegion
)
;
mDispatchToContentHitRegion
.
OrWith
(
aOther
.
mDispatchToContentHitRegion
)
;
bool
alreadyHadRegions
=
!
mNoActionRegion
.
IsEmpty
(
)
|
|
!
mHorizontalPanRegion
.
IsEmpty
(
)
|
|
!
mVerticalPanRegion
.
IsEmpty
(
)
;
mNoActionRegion
.
OrWith
(
aOther
.
mNoActionRegion
)
;
mHorizontalPanRegion
.
OrWith
(
aOther
.
mHorizontalPanRegion
)
;
mVerticalPanRegion
.
OrWith
(
aOther
.
mVerticalPanRegion
)
;
if
(
alreadyHadRegions
)
{
nsIntRegion
combinedActionRegions
;
combinedActionRegions
.
Or
(
mHorizontalPanRegion
mVerticalPanRegion
)
;
combinedActionRegions
.
OrWith
(
mNoActionRegion
)
;
mDispatchToContentHitRegion
.
OrWith
(
combinedActionRegions
)
;
}
mDTCRequiresTargetConfirmation
|
=
aOther
.
mDTCRequiresTargetConfirmation
;
}
bool
IsEmpty
(
)
const
{
return
mHitRegion
.
IsEmpty
(
)
&
&
mDispatchToContentHitRegion
.
IsEmpty
(
)
&
&
mNoActionRegion
.
IsEmpty
(
)
&
&
mHorizontalPanRegion
.
IsEmpty
(
)
&
&
mVerticalPanRegion
.
IsEmpty
(
)
;
}
void
SetEmpty
(
)
{
mHitRegion
.
SetEmpty
(
)
;
mDispatchToContentHitRegion
.
SetEmpty
(
)
;
mNoActionRegion
.
SetEmpty
(
)
;
mHorizontalPanRegion
.
SetEmpty
(
)
;
mVerticalPanRegion
.
SetEmpty
(
)
;
}
nsCString
ToString
(
)
const
{
nsCString
result
=
mHitRegion
.
ToString
(
)
;
result
.
AppendLiteral
(
"
;
dispatchToContent
=
"
)
;
result
.
Append
(
mDispatchToContentHitRegion
.
ToString
(
)
)
;
return
result
;
}
}
;
enum
EventRegionsOverride
{
NoOverride
=
0
ForceDispatchToContent
=
(
1
<
<
0
)
ForceEmptyHitRegion
=
(
1
<
<
1
)
ALL_BITS
=
(
1
<
<
2
)
-
1
}
;
MOZ_ALWAYS_INLINE
EventRegionsOverride
operator
|
(
EventRegionsOverride
a
EventRegionsOverride
b
)
{
return
(
EventRegionsOverride
)
(
(
int
)
a
|
(
int
)
b
)
;
}
MOZ_ALWAYS_INLINE
EventRegionsOverride
&
operator
|
=
(
EventRegionsOverride
&
a
EventRegionsOverride
b
)
{
a
=
a
|
b
;
return
a
;
}
enum
TextureDumpMode
{
Compress
DoNotCompress
}
;
typedef
uint32_t
TouchBehaviorFlags
;
typedef
gfx
:
:
Matrix4x4Typed
<
LayerPixel
CSSTransformedLayerPixel
>
CSSTransformMatrix
;
typedef
gfx
:
:
Matrix4x4Typed
<
ParentLayerPixel
ParentLayerPixel
>
AsyncTransformComponentMatrix
;
typedef
gfx
:
:
Matrix4x4Typed
<
CSSTransformedLayerPixel
ParentLayerPixel
>
AsyncTransformMatrix
;
typedef
Array
<
gfx
:
:
DeviceColor
4
>
BorderColors
;
typedef
Array
<
LayerSize
4
>
BorderCorners
;
typedef
Array
<
LayerCoord
4
>
BorderWidths
;
typedef
Array
<
StyleBorderStyle
4
>
BorderStyles
;
typedef
Maybe
<
LayerRect
>
MaybeLayerRect
;
class
LayerHandle
final
{
friend
struct
IPC
:
:
ParamTraits
<
mozilla
:
:
layers
:
:
LayerHandle
>
;
public
:
LayerHandle
(
)
:
mHandle
(
0
)
{
}
LayerHandle
(
const
LayerHandle
&
aOther
)
=
default
;
explicit
LayerHandle
(
uint64_t
aHandle
)
:
mHandle
(
aHandle
)
{
}
bool
IsValid
(
)
const
{
return
mHandle
!
=
0
;
}
explicit
operator
bool
(
)
const
{
return
IsValid
(
)
;
}
bool
operator
=
=
(
const
LayerHandle
&
aOther
)
const
{
return
mHandle
=
=
aOther
.
mHandle
;
}
uint64_t
Value
(
)
const
{
return
mHandle
;
}
private
:
uint64_t
mHandle
;
}
;
class
CompositableHandle
final
{
friend
struct
IPC
:
:
ParamTraits
<
mozilla
:
:
layers
:
:
CompositableHandle
>
;
public
:
CompositableHandle
(
)
:
mHandle
(
0
)
{
}
CompositableHandle
(
const
CompositableHandle
&
aOther
)
=
default
;
explicit
CompositableHandle
(
uint64_t
aHandle
)
:
mHandle
(
aHandle
)
{
}
bool
IsValid
(
)
const
{
return
mHandle
!
=
0
;
}
explicit
operator
bool
(
)
const
{
return
IsValid
(
)
;
}
bool
operator
=
=
(
const
CompositableHandle
&
aOther
)
const
{
return
mHandle
=
=
aOther
.
mHandle
;
}
uint64_t
Value
(
)
const
{
return
mHandle
;
}
private
:
uint64_t
mHandle
;
}
;
MOZ_DEFINE_ENUM_CLASS_WITH_BASE
(
ScrollDirection
uint32_t
(
eVertical
eHorizontal
)
)
;
MOZ_DEFINE_ENUM_CLASS_WITH_BASE
(
CompositionPayloadType
uint8_t
(
eKeyPress
eAPZScroll
eAPZPinchZoom
eContentPaint
)
)
;
struct
CompositionPayload
{
bool
operator
=
=
(
const
CompositionPayload
&
aOther
)
const
{
return
mType
=
=
aOther
.
mType
&
&
mTimeStamp
=
=
aOther
.
mTimeStamp
;
}
CompositionPayloadType
mType
;
TimeStamp
mTimeStamp
;
}
;
}
}
#
endif
