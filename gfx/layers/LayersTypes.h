#
ifndef
GFX_LAYERSTYPES_H
#
define
GFX_LAYERSTYPES_H
#
include
<
stdint
.
h
>
#
include
"
Units
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
"
nsRegion
.
h
"
#
include
<
stdio
.
h
>
#
include
"
mozilla
/
Logging
.
h
"
#
ifndef
MOZ_LAYERS_HAVE_LOG
#
define
MOZ_LAYERS_HAVE_LOG
#
endif
#
define
MOZ_LAYERS_LOG
(
_args
)
\
MOZ_LOG
(
LayerManager
:
:
GetLog
(
)
LogLevel
:
:
Debug
_args
)
#
define
MOZ_LAYERS_LOG_IF_SHADOWABLE
(
layer
_args
)
\
do
{
if
(
layer
-
>
AsShadowableLayer
(
)
)
{
MOZ_LOG
(
LayerManager
:
:
GetLog
(
)
LogLevel
:
:
Debug
_args
)
;
}
}
while
(
0
)
#
define
INVALID_OVERLAY
-
1
namespace
IPC
{
template
<
typename
T
>
struct
ParamTraits
;
}
namespace
android
{
class
MOZ_EXPORT
GraphicBuffer
;
}
namespace
mozilla
{
namespace
layers
{
class
TextureHost
;
#
undef
NONE
#
undef
OPAQUE
enum
class
LayersBackend
:
int8_t
{
LAYERS_NONE
=
0
LAYERS_BASIC
LAYERS_OPENGL
LAYERS_D3D11
LAYERS_CLIENT
LAYERS_WR
LAYERS_LAST
}
;
enum
class
BufferMode
:
int8_t
{
BUFFER_NONE
BUFFERED
}
;
enum
class
DrawRegionClip
:
int8_t
{
DRAW
NONE
}
;
enum
class
SurfaceMode
:
int8_t
{
SURFACE_NONE
=
0
SURFACE_OPAQUE
SURFACE_SINGLE_CHANNEL_ALPHA
SURFACE_COMPONENT_ALPHA
}
;
enum
class
ScaleMode
:
int8_t
{
SCALE_NONE
STRETCH
SENTINEL
}
;
struct
EventRegions
{
nsIntRegion
mHitRegion
;
nsIntRegion
mDispatchToContentHitRegion
;
nsIntRegion
mNoActionRegion
;
nsIntRegion
mHorizontalPanRegion
;
nsIntRegion
mVerticalPanRegion
;
EventRegions
(
)
{
}
explicit
EventRegions
(
nsIntRegion
aHitRegion
)
:
mHitRegion
(
aHitRegion
)
{
}
bool
operator
=
=
(
const
EventRegions
&
aRegions
)
const
{
return
mHitRegion
=
=
aRegions
.
mHitRegion
&
&
mDispatchToContentHitRegion
=
=
aRegions
.
mDispatchToContentHitRegion
&
&
mNoActionRegion
=
=
aRegions
.
mNoActionRegion
&
&
mHorizontalPanRegion
=
=
aRegions
.
mHorizontalPanRegion
&
&
mVerticalPanRegion
=
=
aRegions
.
mVerticalPanRegion
;
}
bool
operator
!
=
(
const
EventRegions
&
aRegions
)
const
{
return
!
(
*
this
=
=
aRegions
)
;
}
void
ApplyTranslationAndScale
(
float
aXTrans
float
aYTrans
float
aXScale
float
aYScale
)
{
mHitRegion
.
ScaleRoundOut
(
aXScale
aYScale
)
;
mDispatchToContentHitRegion
.
ScaleRoundOut
(
aXScale
aYScale
)
;
mNoActionRegion
.
ScaleRoundOut
(
aXScale
aYScale
)
;
mHorizontalPanRegion
.
ScaleRoundOut
(
aXScale
aYScale
)
;
mVerticalPanRegion
.
ScaleRoundOut
(
aXScale
aYScale
)
;
mHitRegion
.
MoveBy
(
aXTrans
aYTrans
)
;
mDispatchToContentHitRegion
.
MoveBy
(
aXTrans
aYTrans
)
;
mNoActionRegion
.
MoveBy
(
aXTrans
aYTrans
)
;
mHorizontalPanRegion
.
MoveBy
(
aXTrans
aYTrans
)
;
mVerticalPanRegion
.
MoveBy
(
aXTrans
aYTrans
)
;
}
void
Transform
(
const
gfx
:
:
Matrix4x4
&
aTransform
)
{
mHitRegion
.
Transform
(
aTransform
)
;
mDispatchToContentHitRegion
.
Transform
(
aTransform
)
;
mNoActionRegion
.
Transform
(
aTransform
)
;
mHorizontalPanRegion
.
Transform
(
aTransform
)
;
mVerticalPanRegion
.
Transform
(
aTransform
)
;
}
bool
IsEmpty
(
)
const
{
return
mHitRegion
.
IsEmpty
(
)
&
&
mDispatchToContentHitRegion
.
IsEmpty
(
)
&
&
mNoActionRegion
.
IsEmpty
(
)
&
&
mHorizontalPanRegion
.
IsEmpty
(
)
&
&
mVerticalPanRegion
.
IsEmpty
(
)
;
}
nsCString
ToString
(
)
const
{
nsCString
result
=
mHitRegion
.
ToString
(
)
;
result
.
AppendLiteral
(
"
;
dispatchToContent
=
"
)
;
result
.
Append
(
mDispatchToContentHitRegion
.
ToString
(
)
)
;
return
result
;
}
}
;
enum
EventRegionsOverride
{
NoOverride
=
0
ForceDispatchToContent
=
(
1
<
<
0
)
ForceEmptyHitRegion
=
(
1
<
<
1
)
ALL_BITS
=
(
1
<
<
2
)
-
1
}
;
MOZ_ALWAYS_INLINE
EventRegionsOverride
operator
|
(
EventRegionsOverride
a
EventRegionsOverride
b
)
{
return
(
EventRegionsOverride
)
(
(
int
)
a
|
(
int
)
b
)
;
}
MOZ_ALWAYS_INLINE
EventRegionsOverride
&
operator
|
=
(
EventRegionsOverride
&
a
EventRegionsOverride
b
)
{
a
=
a
|
b
;
return
a
;
}
enum
TextureDumpMode
{
Compress
DoNotCompress
}
;
typedef
gfx
:
:
Matrix4x4Typed
<
LayerPixel
CSSTransformedLayerPixel
>
CSSTransformMatrix
;
typedef
gfx
:
:
Matrix4x4Typed
<
ParentLayerPixel
ParentLayerPixel
>
AsyncTransformComponentMatrix
;
typedef
gfx
:
:
Matrix4x4Typed
<
CSSTransformedLayerPixel
ParentLayerPixel
>
AsyncTransformMatrix
;
typedef
Array
<
gfx
:
:
Color
4
>
BorderColors
;
typedef
Array
<
LayerSize
4
>
BorderCorners
;
typedef
Array
<
LayerCoord
4
>
BorderWidths
;
typedef
Array
<
uint8_t
4
>
BorderStyles
;
class
LayerHandle
{
friend
struct
IPC
:
:
ParamTraits
<
mozilla
:
:
layers
:
:
LayerHandle
>
;
public
:
LayerHandle
(
)
:
mHandle
(
0
)
{
}
LayerHandle
(
const
LayerHandle
&
aOther
)
:
mHandle
(
aOther
.
mHandle
)
{
}
explicit
LayerHandle
(
uint64_t
aHandle
)
:
mHandle
(
aHandle
)
{
}
bool
IsValid
(
)
const
{
return
mHandle
!
=
0
;
}
explicit
operator
bool
(
)
const
{
return
IsValid
(
)
;
}
bool
operator
=
=
(
const
LayerHandle
&
aOther
)
const
{
return
mHandle
=
=
aOther
.
mHandle
;
}
uint64_t
Value
(
)
const
{
return
mHandle
;
}
private
:
uint64_t
mHandle
;
}
;
class
CompositableHandle
{
friend
struct
IPC
:
:
ParamTraits
<
mozilla
:
:
layers
:
:
CompositableHandle
>
;
public
:
CompositableHandle
(
)
:
mHandle
(
0
)
{
}
CompositableHandle
(
const
CompositableHandle
&
aOther
)
:
mHandle
(
aOther
.
mHandle
)
{
}
explicit
CompositableHandle
(
uint64_t
aHandle
)
:
mHandle
(
aHandle
)
{
}
bool
IsValid
(
)
const
{
return
mHandle
!
=
0
;
}
explicit
operator
bool
(
)
const
{
return
IsValid
(
)
;
}
bool
operator
=
=
(
const
CompositableHandle
&
aOther
)
const
{
return
mHandle
=
=
aOther
.
mHandle
;
}
uint64_t
Value
(
)
const
{
return
mHandle
;
}
private
:
uint64_t
mHandle
;
}
;
class
ReadLockHandle
{
friend
struct
IPC
:
:
ParamTraits
<
mozilla
:
:
layers
:
:
ReadLockHandle
>
;
public
:
ReadLockHandle
(
)
:
mHandle
(
0
)
{
}
ReadLockHandle
(
const
ReadLockHandle
&
aOther
)
:
mHandle
(
aOther
.
mHandle
)
{
}
explicit
ReadLockHandle
(
uint64_t
aHandle
)
:
mHandle
(
aHandle
)
{
}
bool
IsValid
(
)
const
{
return
mHandle
!
=
0
;
}
explicit
operator
bool
(
)
const
{
return
IsValid
(
)
;
}
bool
operator
=
=
(
const
ReadLockHandle
&
aOther
)
const
{
return
mHandle
=
=
aOther
.
mHandle
;
}
uint64_t
Value
(
)
const
{
return
mHandle
;
}
private
:
uint64_t
mHandle
;
}
;
enum
class
ScrollDirection
:
uint32_t
{
NONE
VERTICAL
HORIZONTAL
SENTINEL
}
;
}
}
#
endif
