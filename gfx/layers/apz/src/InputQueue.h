#
ifndef
mozilla_layers_InputQueue_h
#
define
mozilla_layers_InputQueue_h
#
include
"
APZUtils
.
h
"
#
include
"
DragTracker
.
h
"
#
include
"
InputData
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
layers
/
TouchCounter
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsTArray
.
h
"
#
include
<
unordered_map
>
namespace
mozilla
{
class
InputData
;
class
MultiTouchInput
;
class
ScrollWheelInput
;
namespace
layers
{
class
AsyncPanZoomController
;
class
InputBlockState
;
class
CancelableBlockState
;
class
TouchBlockState
;
class
WheelBlockState
;
class
DragBlockState
;
class
PanGestureBlockState
;
class
PinchGestureBlockState
;
class
KeyboardBlockState
;
class
AsyncDragMetrics
;
class
QueuedInput
;
struct
APZEventResult
;
struct
APZHandledResult
;
enum
class
BrowserGestureResponse
:
bool
;
using
InputBlockCallback
=
std
:
:
function
<
void
(
uint64_t
aInputBlockId
APZHandledResult
aHandledResult
)
>
;
struct
InputBlockCallbackInfo
{
nsEventStatus
mEagerStatus
;
InputBlockCallback
mCallback
;
}
;
class
InputQueue
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
InputQueue
)
public
:
InputQueue
(
)
;
APZEventResult
ReceiveInputEvent
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTarget
TargetConfirmationFlags
aFlags
InputData
&
aEvent
const
Maybe
<
nsTArray
<
TouchBehaviorFlags
>
>
&
aTouchBehaviors
=
Nothing
(
)
)
;
void
ContentReceivedInputBlock
(
uint64_t
aInputBlockId
bool
aPreventDefault
)
;
void
SetConfirmedTargetApzc
(
uint64_t
aInputBlockId
const
RefPtr
<
AsyncPanZoomController
>
&
aTargetApzc
)
;
void
ConfirmDragBlock
(
uint64_t
aInputBlockId
const
RefPtr
<
AsyncPanZoomController
>
&
aTargetApzc
const
AsyncDragMetrics
&
aDragMetrics
)
;
void
SetAllowedTouchBehavior
(
uint64_t
aInputBlockId
const
nsTArray
<
TouchBehaviorFlags
>
&
aBehaviors
)
;
uint64_t
InjectNewTouchBlock
(
AsyncPanZoomController
*
aTarget
)
;
InputBlockState
*
GetCurrentBlock
(
)
const
;
TouchBlockState
*
GetCurrentTouchBlock
(
)
const
;
WheelBlockState
*
GetCurrentWheelBlock
(
)
const
;
DragBlockState
*
GetCurrentDragBlock
(
)
const
;
PanGestureBlockState
*
GetCurrentPanGestureBlock
(
)
const
;
PinchGestureBlockState
*
GetCurrentPinchGestureBlock
(
)
const
;
KeyboardBlockState
*
GetCurrentKeyboardBlock
(
)
const
;
bool
HasReadyTouchBlock
(
)
const
;
WheelBlockState
*
GetActiveWheelTransaction
(
)
const
;
void
Clear
(
)
;
bool
AllowScrollHandoff
(
)
const
;
bool
IsDragOnScrollbar
(
bool
aOnScrollbar
)
;
InputBlockState
*
GetBlockForId
(
uint64_t
aInputBlockId
)
;
void
AddInputBlockCallback
(
uint64_t
aInputBlockId
InputBlockCallbackInfo
&
&
aCallback
)
;
void
SetBrowserGestureResponse
(
uint64_t
aInputBlockId
BrowserGestureResponse
aResponse
)
;
private
:
~
InputQueue
(
)
;
class
AutoRunImmediateTimeout
final
{
public
:
explicit
AutoRunImmediateTimeout
(
InputQueue
*
aQueue
)
;
~
AutoRunImmediateTimeout
(
)
;
private
:
InputQueue
*
mQueue
;
}
;
TouchBlockState
*
StartNewTouchBlock
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTarget
TargetConfirmationFlags
aFlags
)
;
TouchBlockState
*
StartNewTouchBlockForLongTap
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTarget
)
;
void
CancelAnimationsForNewBlock
(
InputBlockState
*
aBlock
CancelAnimationFlags
aExtraFlags
=
Default
)
;
bool
MaybeRequestContentResponse
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTarget
CancelableBlockState
*
aBlock
)
;
APZEventResult
ReceiveTouchInput
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTarget
TargetConfirmationFlags
aFlags
const
MultiTouchInput
&
aEvent
const
Maybe
<
nsTArray
<
TouchBehaviorFlags
>
>
&
aTouchBehaviors
)
;
APZEventResult
ReceiveMouseInput
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTarget
TargetConfirmationFlags
aFlags
MouseInput
&
aEvent
)
;
APZEventResult
ReceiveScrollWheelInput
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTarget
TargetConfirmationFlags
aFlags
const
ScrollWheelInput
&
aEvent
)
;
APZEventResult
ReceivePanGestureInput
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTarget
TargetConfirmationFlags
aFlags
const
PanGestureInput
&
aEvent
)
;
APZEventResult
ReceivePinchGestureInput
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTarget
TargetConfirmationFlags
aFlags
const
PinchGestureInput
&
aEvent
)
;
APZEventResult
ReceiveKeyboardInput
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTarget
TargetConfirmationFlags
aFlags
const
KeyboardInput
&
aEvent
)
;
InputBlockState
*
FindBlockForId
(
uint64_t
aInputBlockId
InputData
*
*
aOutFirstInput
)
;
void
ScheduleMainThreadTimeout
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTarget
CancelableBlockState
*
aBlock
)
;
void
MainThreadTimeout
(
uint64_t
aInputBlockId
)
;
void
MaybeLongTapTimeout
(
uint64_t
aInputBlockId
)
;
void
ProcessQueue
(
)
;
bool
CanDiscardBlock
(
InputBlockState
*
aBlock
)
;
void
UpdateActiveApzc
(
const
RefPtr
<
AsyncPanZoomController
>
&
aNewActive
)
;
private
:
nsTArray
<
UniquePtr
<
QueuedInput
>
>
mQueuedInputs
;
RefPtr
<
TouchBlockState
>
mActiveTouchBlock
;
RefPtr
<
WheelBlockState
>
mActiveWheelBlock
;
RefPtr
<
DragBlockState
>
mActiveDragBlock
;
RefPtr
<
PanGestureBlockState
>
mActivePanGestureBlock
;
RefPtr
<
PinchGestureBlockState
>
mActivePinchGestureBlock
;
RefPtr
<
KeyboardBlockState
>
mActiveKeyboardBlock
;
RefPtr
<
TouchBlockState
>
mPrevActiveTouchBlock
;
RefPtr
<
AsyncPanZoomController
>
mLastActiveApzc
;
TouchCounter
mTouchCounter
;
DragTracker
mDragTracker
;
RefPtr
<
Runnable
>
mImmediateTimeout
;
using
InputBlockCallbackMap
=
std
:
:
unordered_map
<
uint64_t
InputBlockCallbackInfo
>
;
InputBlockCallbackMap
mInputBlockCallbacks
;
}
;
}
}
#
endif
