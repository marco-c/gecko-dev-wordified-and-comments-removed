#
ifndef
mozilla_dom_TaskThrottler_h
#
define
mozilla_dom_TaskThrottler_h
#
include
<
stdint
.
h
>
#
include
"
base
/
task
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
RollingMean
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
class
nsITimer
;
namespace
tracked_objects
{
class
Location
;
}
namespace
mozilla
{
namespace
layers
{
class
TaskThrottler
{
public
:
TaskThrottler
(
const
TimeStamp
&
aTimeStamp
const
TimeDuration
&
aMaxWait
)
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
TaskThrottler
)
void
PostTask
(
const
tracked_objects
:
:
Location
&
aLocation
UniquePtr
<
CancelableTask
>
aTask
const
TimeStamp
&
aTimeStamp
)
;
void
TaskComplete
(
const
TimeStamp
&
aTimeStamp
)
;
TimeDuration
AverageDuration
(
)
;
void
CancelPendingTask
(
)
;
TimeDuration
TimeSinceLastRequest
(
const
TimeStamp
&
aTimeStamp
)
;
void
ClearHistory
(
)
;
void
SetMaxDurations
(
uint32_t
aMaxDurations
)
;
private
:
mutable
Monitor
mMonitor
;
bool
mOutstanding
;
UniquePtr
<
CancelableTask
>
mQueuedTask
;
TimeStamp
mStartTime
;
TimeDuration
mMaxWait
;
RollingMean
<
TimeDuration
TimeDuration
>
mMean
;
nsCOMPtr
<
nsITimer
>
mTimer
;
~
TaskThrottler
(
)
;
void
RunQueuedTask
(
const
TimeStamp
&
aTimeStamp
const
MonitorAutoLock
&
aProofOfLock
)
;
void
CancelPendingTask
(
const
MonitorAutoLock
&
aProofOfLock
)
;
TimeDuration
TimeSinceLastRequest
(
const
TimeStamp
&
aTimeStamp
const
MonitorAutoLock
&
aProofOfLock
)
;
}
;
}
}
#
endif
