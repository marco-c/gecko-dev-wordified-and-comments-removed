#
include
"
HitTestingTreeNode
.
h
"
#
include
"
AsyncPanZoomController
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
LayersLogging
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
layers
/
APZUtils
.
h
"
#
include
"
mozilla
/
layers
/
AsyncCompositionManager
.
h
"
#
include
"
mozilla
/
layers
/
AsyncDragMetrics
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
UnitTransforms
.
h
"
namespace
mozilla
{
namespace
layers
{
using
gfx
:
:
CompositorHitTestFlags
;
using
gfx
:
:
CompositorHitTestInfo
;
using
gfx
:
:
CompositorHitTestInvisibleToHit
;
using
gfx
:
:
CompositorHitTestTouchActionMask
;
HitTestingTreeNode
:
:
HitTestingTreeNode
(
AsyncPanZoomController
*
aApzc
bool
aIsPrimaryHolder
LayersId
aLayersId
)
:
mApzc
(
aApzc
)
mIsPrimaryApzcHolder
(
aIsPrimaryHolder
)
mLockCount
(
0
)
mLayersId
(
aLayersId
)
mFixedPosTarget
(
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
)
mIsBackfaceHidden
(
false
)
mIsAsyncZoomContainer
(
false
)
mOverride
(
EventRegionsOverride
:
:
NoOverride
)
{
if
(
mIsPrimaryApzcHolder
)
{
MOZ_ASSERT
(
mApzc
)
;
}
MOZ_ASSERT
(
!
mApzc
|
|
mApzc
-
>
GetLayersId
(
)
=
=
mLayersId
)
;
}
void
HitTestingTreeNode
:
:
RecycleWith
(
const
RecursiveMutexAutoLock
&
aProofOfTreeLock
AsyncPanZoomController
*
aApzc
LayersId
aLayersId
)
{
MOZ_ASSERT
(
IsRecyclable
(
aProofOfTreeLock
)
)
;
Destroy
(
)
;
mApzc
=
aApzc
;
mLayersId
=
aLayersId
;
MOZ_ASSERT
(
!
mApzc
|
|
mApzc
-
>
GetLayersId
(
)
=
=
mLayersId
)
;
}
HitTestingTreeNode
:
:
~
HitTestingTreeNode
(
)
=
default
;
void
HitTestingTreeNode
:
:
Destroy
(
)
{
mPrevSibling
=
nullptr
;
mLastChild
=
nullptr
;
mParent
=
nullptr
;
if
(
mApzc
)
{
if
(
mIsPrimaryApzcHolder
)
{
mApzc
-
>
Destroy
(
)
;
}
mApzc
=
nullptr
;
}
}
bool
HitTestingTreeNode
:
:
IsRecyclable
(
const
RecursiveMutexAutoLock
&
aProofOfTreeLock
)
{
return
!
(
IsPrimaryHolder
(
)
|
|
(
mLockCount
>
0
)
)
;
}
void
HitTestingTreeNode
:
:
SetLastChild
(
HitTestingTreeNode
*
aChild
)
{
mLastChild
=
aChild
;
if
(
aChild
)
{
aChild
-
>
mParent
=
this
;
if
(
aChild
-
>
GetApzc
(
)
)
{
AsyncPanZoomController
*
parent
=
GetNearestContainingApzc
(
)
;
MOZ_ASSERT
(
aChild
-
>
GetApzc
(
)
!
=
parent
)
;
aChild
-
>
SetApzcParent
(
parent
)
;
}
}
}
void
HitTestingTreeNode
:
:
SetScrollbarData
(
const
Maybe
<
uint64_t
>
&
aScrollbarAnimationId
const
ScrollbarData
&
aScrollbarData
)
{
mScrollbarAnimationId
=
aScrollbarAnimationId
;
mScrollbarData
=
aScrollbarData
;
}
bool
HitTestingTreeNode
:
:
MatchesScrollDragMetrics
(
const
AsyncDragMetrics
&
aDragMetrics
)
const
{
return
IsScrollThumbNode
(
)
&
&
mScrollbarData
.
mDirection
=
=
aDragMetrics
.
mDirection
&
&
mScrollbarData
.
mTargetViewId
=
=
aDragMetrics
.
mViewId
;
}
bool
HitTestingTreeNode
:
:
IsScrollThumbNode
(
)
const
{
return
mScrollbarData
.
mScrollbarLayerType
=
=
layers
:
:
ScrollbarLayerType
:
:
Thumb
;
}
bool
HitTestingTreeNode
:
:
IsScrollbarNode
(
)
const
{
return
mScrollbarData
.
mScrollbarLayerType
!
=
layers
:
:
ScrollbarLayerType
:
:
None
;
}
ScrollDirection
HitTestingTreeNode
:
:
GetScrollbarDirection
(
)
const
{
MOZ_ASSERT
(
IsScrollbarNode
(
)
)
;
MOZ_ASSERT
(
mScrollbarData
.
mDirection
.
isSome
(
)
)
;
return
*
mScrollbarData
.
mDirection
;
}
ScrollableLayerGuid
:
:
ViewID
HitTestingTreeNode
:
:
GetScrollTargetId
(
)
const
{
return
mScrollbarData
.
mTargetViewId
;
}
Maybe
<
uint64_t
>
HitTestingTreeNode
:
:
GetScrollbarAnimationId
(
)
const
{
return
mScrollbarAnimationId
;
}
const
ScrollbarData
&
HitTestingTreeNode
:
:
GetScrollbarData
(
)
const
{
return
mScrollbarData
;
}
void
HitTestingTreeNode
:
:
SetFixedPosData
(
ScrollableLayerGuid
:
:
ViewID
aFixedPosTarget
)
{
mFixedPosTarget
=
aFixedPosTarget
;
}
ScrollableLayerGuid
:
:
ViewID
HitTestingTreeNode
:
:
GetFixedPosTarget
(
)
const
{
return
mFixedPosTarget
;
}
void
HitTestingTreeNode
:
:
SetPrevSibling
(
HitTestingTreeNode
*
aSibling
)
{
mPrevSibling
=
aSibling
;
if
(
aSibling
)
{
aSibling
-
>
mParent
=
mParent
;
if
(
aSibling
-
>
GetApzc
(
)
)
{
AsyncPanZoomController
*
parent
=
mParent
?
mParent
-
>
GetNearestContainingApzc
(
)
:
nullptr
;
aSibling
-
>
SetApzcParent
(
parent
)
;
}
}
}
void
HitTestingTreeNode
:
:
MakeRoot
(
)
{
mParent
=
nullptr
;
if
(
GetApzc
(
)
)
{
SetApzcParent
(
nullptr
)
;
}
}
HitTestingTreeNode
*
HitTestingTreeNode
:
:
GetFirstChild
(
)
const
{
HitTestingTreeNode
*
child
=
GetLastChild
(
)
;
while
(
child
&
&
child
-
>
GetPrevSibling
(
)
)
{
child
=
child
-
>
GetPrevSibling
(
)
;
}
return
child
;
}
HitTestingTreeNode
*
HitTestingTreeNode
:
:
GetLastChild
(
)
const
{
return
mLastChild
;
}
HitTestingTreeNode
*
HitTestingTreeNode
:
:
GetPrevSibling
(
)
const
{
return
mPrevSibling
;
}
HitTestingTreeNode
*
HitTestingTreeNode
:
:
GetParent
(
)
const
{
return
mParent
;
}
bool
HitTestingTreeNode
:
:
IsAncestorOf
(
const
HitTestingTreeNode
*
aOther
)
const
{
for
(
const
HitTestingTreeNode
*
cur
=
aOther
;
cur
;
cur
=
cur
-
>
GetParent
(
)
)
{
if
(
cur
=
=
this
)
{
return
true
;
}
}
return
false
;
}
AsyncPanZoomController
*
HitTestingTreeNode
:
:
GetApzc
(
)
const
{
return
mApzc
;
}
AsyncPanZoomController
*
HitTestingTreeNode
:
:
GetNearestContainingApzc
(
)
const
{
for
(
const
HitTestingTreeNode
*
n
=
this
;
n
;
n
=
n
-
>
GetParent
(
)
)
{
if
(
n
-
>
GetApzc
(
)
)
{
return
n
-
>
GetApzc
(
)
;
}
}
return
nullptr
;
}
bool
HitTestingTreeNode
:
:
IsPrimaryHolder
(
)
const
{
return
mIsPrimaryApzcHolder
;
}
LayersId
HitTestingTreeNode
:
:
GetLayersId
(
)
const
{
return
mLayersId
;
}
void
HitTestingTreeNode
:
:
SetHitTestData
(
const
EventRegions
&
aRegions
const
LayerIntRegion
&
aVisibleRegion
const
CSSTransformMatrix
&
aTransform
const
Maybe
<
ParentLayerIntRegion
>
&
aClipRegion
const
EventRegionsOverride
&
aOverride
bool
aIsBackfaceHidden
bool
aIsAsyncZoomContainer
)
{
mEventRegions
=
aRegions
;
mVisibleRegion
=
aVisibleRegion
;
mTransform
=
aTransform
;
mClipRegion
=
aClipRegion
;
mOverride
=
aOverride
;
mIsBackfaceHidden
=
aIsBackfaceHidden
;
mIsAsyncZoomContainer
=
aIsAsyncZoomContainer
;
}
bool
HitTestingTreeNode
:
:
IsOutsideClip
(
const
ParentLayerPoint
&
aPoint
)
const
{
return
(
mClipRegion
.
isSome
(
)
&
&
!
mClipRegion
-
>
Contains
(
aPoint
.
x
aPoint
.
y
)
)
;
}
Maybe
<
LayerPoint
>
HitTestingTreeNode
:
:
Untransform
(
const
ParentLayerPoint
&
aPoint
const
LayerToParentLayerMatrix4x4
&
aTransform
)
const
{
Maybe
<
ParentLayerToLayerMatrix4x4
>
inverse
=
aTransform
.
MaybeInverse
(
)
;
if
(
inverse
)
{
return
UntransformBy
(
inverse
.
ref
(
)
aPoint
)
;
}
return
Nothing
(
)
;
}
CompositorHitTestInfo
HitTestingTreeNode
:
:
HitTest
(
const
LayerPoint
&
aPoint
)
const
{
CompositorHitTestInfo
result
=
CompositorHitTestInvisibleToHit
;
if
(
mOverride
&
EventRegionsOverride
:
:
ForceEmptyHitRegion
)
{
return
result
;
}
auto
point
=
LayerIntPoint
:
:
Round
(
aPoint
)
;
if
(
mIsBackfaceHidden
)
{
return
result
;
}
if
(
!
mEventRegions
.
mHitRegion
.
Contains
(
point
.
x
point
.
y
)
)
{
return
result
;
}
result
=
CompositorHitTestFlags
:
:
eVisibleToHitTest
;
if
(
(
mOverride
&
EventRegionsOverride
:
:
ForceDispatchToContent
)
|
|
mEventRegions
.
mDispatchToContentHitRegion
.
Contains
(
point
.
x
point
.
y
)
)
{
result
+
=
CompositorHitTestFlags
:
:
eDispatchToContent
;
if
(
mEventRegions
.
mDTCRequiresTargetConfirmation
)
{
result
+
=
CompositorHitTestFlags
:
:
eRequiresTargetConfirmation
;
}
}
else
if
(
gfxPrefs
:
:
TouchActionEnabled
(
)
)
{
if
(
mEventRegions
.
mNoActionRegion
.
Contains
(
point
.
x
point
.
y
)
)
{
result
+
=
CompositorHitTestTouchActionMask
;
}
else
{
bool
panX
=
mEventRegions
.
mHorizontalPanRegion
.
Contains
(
point
.
x
point
.
y
)
;
bool
panY
=
mEventRegions
.
mVerticalPanRegion
.
Contains
(
point
.
x
point
.
y
)
;
if
(
panX
&
&
panY
)
{
result
+
=
CompositorHitTestFlags
:
:
eTouchActionDoubleTapZoomDisabled
;
result
+
=
CompositorHitTestFlags
:
:
eTouchActionPinchZoomDisabled
;
}
else
if
(
panX
)
{
result
+
=
CompositorHitTestFlags
:
:
eTouchActionPanYDisabled
;
result
+
=
CompositorHitTestFlags
:
:
eTouchActionPinchZoomDisabled
;
result
+
=
CompositorHitTestFlags
:
:
eTouchActionDoubleTapZoomDisabled
;
}
else
if
(
panY
)
{
result
+
=
CompositorHitTestFlags
:
:
eTouchActionPanXDisabled
;
result
+
=
CompositorHitTestFlags
:
:
eTouchActionPinchZoomDisabled
;
result
+
=
CompositorHitTestFlags
:
:
eTouchActionDoubleTapZoomDisabled
;
}
}
}
return
result
;
}
EventRegionsOverride
HitTestingTreeNode
:
:
GetEventRegionsOverride
(
)
const
{
return
mOverride
;
}
const
CSSTransformMatrix
&
HitTestingTreeNode
:
:
GetTransform
(
)
const
{
return
mTransform
;
}
const
LayerIntRegion
&
HitTestingTreeNode
:
:
GetVisibleRegion
(
)
const
{
return
mVisibleRegion
;
}
bool
HitTestingTreeNode
:
:
IsAsyncZoomContainer
(
)
const
{
return
mIsAsyncZoomContainer
;
}
void
HitTestingTreeNode
:
:
Dump
(
const
char
*
aPrefix
)
const
{
if
(
mPrevSibling
)
{
mPrevSibling
-
>
Dump
(
aPrefix
)
;
}
printf_stderr
(
"
%
sHitTestingTreeNode
(
%
p
)
APZC
(
%
p
)
g
=
(
%
s
)
%
s
%
s
%
sr
=
(
%
s
)
t
=
(
%
s
)
"
"
c
=
(
%
s
)
%
s
%
s
\
n
"
aPrefix
this
mApzc
.
get
(
)
mApzc
?
Stringify
(
mApzc
-
>
GetGuid
(
)
)
.
c_str
(
)
:
nsPrintfCString
(
"
l
=
0x
%
"
PRIx64
uint64_t
(
mLayersId
)
)
.
get
(
)
(
mOverride
&
EventRegionsOverride
:
:
ForceDispatchToContent
)
?
"
fdtc
"
:
"
"
(
mOverride
&
EventRegionsOverride
:
:
ForceEmptyHitRegion
)
?
"
fehr
"
:
"
"
(
mFixedPosTarget
!
=
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
)
?
nsPrintfCString
(
"
fixed
=
%
"
PRIu64
"
"
mFixedPosTarget
)
.
get
(
)
:
"
"
Stringify
(
mEventRegions
)
.
c_str
(
)
Stringify
(
mTransform
)
.
c_str
(
)
mClipRegion
?
Stringify
(
mClipRegion
.
ref
(
)
)
.
c_str
(
)
:
"
none
"
mScrollbarData
.
mDirection
.
isSome
(
)
?
"
scrollbar
"
:
"
"
IsScrollThumbNode
(
)
?
"
scrollthumb
"
:
"
"
)
;
if
(
mLastChild
)
{
mLastChild
-
>
Dump
(
nsPrintfCString
(
"
%
s
"
aPrefix
)
.
get
(
)
)
;
}
}
void
HitTestingTreeNode
:
:
SetApzcParent
(
AsyncPanZoomController
*
aParent
)
{
MOZ_ASSERT
(
GetApzc
(
)
!
=
nullptr
)
;
if
(
IsPrimaryHolder
(
)
)
{
GetApzc
(
)
-
>
SetParent
(
aParent
)
;
}
else
{
MOZ_ASSERT
(
GetApzc
(
)
-
>
GetParent
(
)
=
=
aParent
)
;
}
}
void
HitTestingTreeNode
:
:
Lock
(
const
RecursiveMutexAutoLock
&
aProofOfTreeLock
)
{
mLockCount
+
+
;
}
void
HitTestingTreeNode
:
:
Unlock
(
const
RecursiveMutexAutoLock
&
aProofOfTreeLock
)
{
MOZ_ASSERT
(
mLockCount
>
0
)
;
mLockCount
-
-
;
}
HitTestingTreeNodeAutoLock
:
:
HitTestingTreeNodeAutoLock
(
)
:
mTreeMutex
(
nullptr
)
{
}
HitTestingTreeNodeAutoLock
:
:
~
HitTestingTreeNodeAutoLock
(
)
{
Clear
(
)
;
}
void
HitTestingTreeNodeAutoLock
:
:
Initialize
(
const
RecursiveMutexAutoLock
&
aProofOfTreeLock
already_AddRefed
<
HitTestingTreeNode
>
aNode
RecursiveMutex
&
aTreeMutex
)
{
MOZ_ASSERT
(
!
mNode
)
;
mNode
=
aNode
;
mTreeMutex
=
&
aTreeMutex
;
mNode
-
>
Lock
(
aProofOfTreeLock
)
;
}
void
HitTestingTreeNodeAutoLock
:
:
Clear
(
)
{
if
(
!
mNode
)
{
return
;
}
MOZ_ASSERT
(
mTreeMutex
)
;
{
RecursiveMutexAutoLock
lock
(
*
mTreeMutex
)
;
mNode
-
>
Unlock
(
lock
)
;
}
mNode
=
nullptr
;
mTreeMutex
=
nullptr
;
}
}
}
