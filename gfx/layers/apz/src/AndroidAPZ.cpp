#
include
"
AndroidAPZ
.
h
"
#
include
"
AndroidFlingPhysics
.
h
"
#
include
"
AsyncPanZoomController
.
h
"
#
include
"
GeneratedJNIWrappers
.
h
"
#
include
"
GenericFlingAnimation
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
OverscrollHandoffState
.
h
"
#
include
"
ViewConfiguration
.
h
"
#
define
ANDROID_APZ_LOG
(
.
.
.
)
static
float
sMaxFlingSpeed
=
0
.
0f
;
namespace
mozilla
{
namespace
layers
{
AndroidSpecificState
:
:
AndroidSpecificState
(
)
{
using
namespace
mozilla
:
:
java
;
sdk
:
:
ViewConfiguration
:
:
LocalRef
config
;
if
(
sdk
:
:
ViewConfiguration
:
:
Get
(
GeckoAppShell
:
:
GetApplicationContext
(
)
&
config
)
=
=
NS_OK
)
{
int32_t
speed
=
0
;
if
(
config
-
>
GetScaledMaximumFlingVelocity
(
&
speed
)
=
=
NS_OK
)
{
sMaxFlingSpeed
=
(
float
)
speed
*
0
.
001f
;
}
else
{
ANDROID_APZ_LOG
(
"
%
p
Failed
to
query
ViewConfiguration
for
scaled
maximum
fling
velocity
\
n
"
this
)
;
}
}
else
{
ANDROID_APZ_LOG
(
"
%
p
Failed
to
get
ViewConfiguration
\
n
"
this
)
;
}
StackScroller
:
:
LocalRef
scroller
;
if
(
StackScroller
:
:
New
(
GeckoAppShell
:
:
GetApplicationContext
(
)
&
scroller
)
!
=
NS_OK
)
{
ANDROID_APZ_LOG
(
"
%
p
Failed
to
create
Android
StackScroller
\
n
"
this
)
;
return
;
}
mOverScroller
=
scroller
;
}
AsyncPanZoomAnimation
*
AndroidSpecificState
:
:
CreateFlingAnimation
(
AsyncPanZoomController
&
aApzc
const
FlingHandoffState
&
aHandoffState
float
aPLPPI
)
{
if
(
gfxPrefs
:
:
APZUseChromeFlingPhysics
(
)
)
{
return
new
GenericFlingAnimation
<
AndroidFlingPhysics
>
(
aApzc
aHandoffState
.
mChain
aHandoffState
.
mIsHandoff
aHandoffState
.
mScrolledApzc
aPLPPI
)
;
}
else
{
return
new
StackScrollerFlingAnimation
(
aApzc
this
aHandoffState
.
mChain
aHandoffState
.
mIsHandoff
aHandoffState
.
mScrolledApzc
)
;
}
}
void
AndroidSpecificState
:
:
InitializeGlobalState
(
)
{
AndroidFlingPhysics
:
:
InitializeGlobalState
(
)
;
}
const
float
BOUNDS_EPSILON
=
1
.
0f
;
static
int32_t
ClampStart
(
float
aOrigin
float
aMin
float
aMax
)
{
if
(
aOrigin
<
=
aMin
)
{
return
(
int32_t
)
floor
(
aMin
)
;
}
else
if
(
aOrigin
>
=
aMax
)
{
return
(
int32_t
)
ceil
(
aMax
)
;
}
return
(
int32_t
)
aOrigin
;
}
StackScrollerFlingAnimation
:
:
StackScrollerFlingAnimation
(
AsyncPanZoomController
&
aApzc
PlatformSpecificStateBase
*
aPlatformSpecificState
const
RefPtr
<
const
OverscrollHandoffChain
>
&
aOverscrollHandoffChain
bool
aFlingIsHandoff
const
RefPtr
<
const
AsyncPanZoomController
>
&
aScrolledApzc
)
:
mApzc
(
aApzc
)
mOverscrollHandoffChain
(
aOverscrollHandoffChain
)
mScrolledApzc
(
aScrolledApzc
)
mSentBounceX
(
false
)
mSentBounceY
(
false
)
mFlingDuration
(
0
)
{
MOZ_ASSERT
(
mOverscrollHandoffChain
)
;
AndroidSpecificState
*
state
=
aPlatformSpecificState
-
>
AsAndroidSpecificState
(
)
;
MOZ_ASSERT
(
state
)
;
mOverScroller
=
state
-
>
mOverScroller
;
MOZ_ASSERT
(
mOverScroller
)
;
if
(
!
mOverscrollHandoffChain
-
>
CanScrollInDirection
(
&
mApzc
ScrollDirection
:
:
eHorizontal
)
)
{
RecursiveMutexAutoLock
lock
(
mApzc
.
mRecursiveMutex
)
;
mApzc
.
mX
.
SetVelocity
(
0
)
;
}
if
(
!
mOverscrollHandoffChain
-
>
CanScrollInDirection
(
&
mApzc
ScrollDirection
:
:
eVertical
)
)
{
RecursiveMutexAutoLock
lock
(
mApzc
.
mRecursiveMutex
)
;
mApzc
.
mY
.
SetVelocity
(
0
)
;
}
ParentLayerPoint
velocity
=
mApzc
.
GetVelocityVector
(
)
;
float
scrollRangeStartX
=
mApzc
.
mX
.
GetPageStart
(
)
.
value
;
float
scrollRangeEndX
=
mApzc
.
mX
.
GetScrollRangeEnd
(
)
.
value
;
float
scrollRangeStartY
=
mApzc
.
mY
.
GetPageStart
(
)
.
value
;
float
scrollRangeEndY
=
mApzc
.
mY
.
GetScrollRangeEnd
(
)
.
value
;
mStartOffset
.
x
=
mPreviousOffset
.
x
=
mApzc
.
mX
.
GetOrigin
(
)
.
value
;
mStartOffset
.
y
=
mPreviousOffset
.
y
=
mApzc
.
mY
.
GetOrigin
(
)
.
value
;
float
length
=
velocity
.
Length
(
)
;
if
(
length
>
0
.
0f
)
{
mFlingDirection
=
velocity
/
length
;
if
(
(
sMaxFlingSpeed
>
0
.
0f
)
&
&
(
length
>
sMaxFlingSpeed
)
)
{
velocity
=
mFlingDirection
*
sMaxFlingSpeed
;
}
}
mPreviousVelocity
=
velocity
;
int32_t
originX
=
ClampStart
(
mStartOffset
.
x
scrollRangeStartX
scrollRangeEndX
)
;
int32_t
originY
=
ClampStart
(
mStartOffset
.
y
scrollRangeStartY
scrollRangeEndY
)
;
if
(
!
state
-
>
mLastFling
.
IsNull
(
)
)
{
TimeDuration
flingDuration
=
TimeStamp
:
:
Now
(
)
-
state
-
>
mLastFling
;
if
(
flingDuration
.
ToMilliseconds
(
)
<
gfxPrefs
:
:
APZFlingAccelInterval
(
)
&
&
velocity
.
Length
(
)
>
=
gfxPrefs
:
:
APZFlingAccelMinVelocity
(
)
)
{
bool
unused
=
false
;
mOverScroller
-
>
ComputeScrollOffset
(
flingDuration
.
ToMilliseconds
(
)
&
unused
)
;
}
else
{
mOverScroller
-
>
ForceFinished
(
true
)
;
}
}
mOverScroller
-
>
Fling
(
originX
originY
(
int32_t
)
(
velocity
.
x
*
1000
.
0f
)
(
int32_t
)
(
velocity
.
y
*
1000
.
0f
)
(
int32_t
)
floor
(
scrollRangeStartX
)
(
int32_t
)
ceil
(
scrollRangeEndX
)
(
int32_t
)
floor
(
scrollRangeStartY
)
(
int32_t
)
ceil
(
scrollRangeEndY
)
0
0
0
)
;
state
-
>
mLastFling
=
TimeStamp
:
:
Now
(
)
;
}
bool
StackScrollerFlingAnimation
:
:
DoSample
(
FrameMetrics
&
aFrameMetrics
const
TimeDuration
&
aDelta
)
{
bool
shouldContinueFling
=
true
;
mFlingDuration
+
=
aDelta
.
ToMilliseconds
(
)
;
mOverScroller
-
>
ComputeScrollOffset
(
mFlingDuration
&
shouldContinueFling
)
;
int32_t
currentX
=
0
;
int32_t
currentY
=
0
;
mOverScroller
-
>
GetCurrX
(
&
currentX
)
;
mOverScroller
-
>
GetCurrY
(
&
currentY
)
;
ParentLayerPoint
offset
(
(
float
)
currentX
(
float
)
currentY
)
;
ParentLayerPoint
preCheckedOffset
(
offset
)
;
bool
hitBoundX
=
CheckBounds
(
mApzc
.
mX
offset
.
x
mFlingDirection
.
x
&
(
offset
.
x
)
)
;
bool
hitBoundY
=
CheckBounds
(
mApzc
.
mY
offset
.
y
mFlingDirection
.
y
&
(
offset
.
y
)
)
;
ParentLayerPoint
velocity
=
mPreviousVelocity
;
if
(
offset
!
=
mPreviousOffset
)
{
if
(
aDelta
.
ToMilliseconds
(
)
>
0
)
{
mOverScroller
-
>
GetCurrSpeedX
(
&
velocity
.
x
)
;
mOverScroller
-
>
GetCurrSpeedY
(
&
velocity
.
y
)
;
velocity
.
x
/
=
1000
;
velocity
.
y
/
=
1000
;
mPreviousVelocity
=
velocity
;
}
}
else
if
(
(
fabsf
(
offset
.
x
-
preCheckedOffset
.
x
)
>
BOUNDS_EPSILON
)
|
|
(
fabsf
(
offset
.
y
-
preCheckedOffset
.
y
)
>
BOUNDS_EPSILON
)
)
{
shouldContinueFling
=
false
;
}
else
if
(
hitBoundX
&
&
hitBoundY
)
{
shouldContinueFling
=
false
;
}
float
speed
=
velocity
.
Length
(
)
;
if
(
!
shouldContinueFling
|
|
(
speed
<
gfxPrefs
:
:
APZFlingStoppedThreshold
(
)
)
)
{
if
(
shouldContinueFling
)
{
mOverScroller
-
>
AbortAnimation
(
)
;
}
if
(
!
mSentBounceX
&
&
!
mSentBounceY
&
&
(
speed
>
0
.
0f
)
)
{
DeferHandleFlingOverscroll
(
velocity
)
;
}
return
false
;
}
mPreviousOffset
=
offset
;
mApzc
.
SetVelocityVector
(
velocity
)
;
mApzc
.
SetScrollOffset
(
offset
/
aFrameMetrics
.
GetZoom
(
)
)
;
if
(
hitBoundX
|
|
hitBoundY
)
{
ParentLayerPoint
bounceVelocity
=
velocity
;
if
(
!
mSentBounceX
&
&
hitBoundX
&
&
fabsf
(
offset
.
x
-
mStartOffset
.
x
)
>
BOUNDS_EPSILON
)
{
mSentBounceX
=
true
;
}
else
{
bounceVelocity
.
x
=
0
.
0f
;
}
if
(
!
mSentBounceY
&
&
hitBoundY
&
&
fabsf
(
offset
.
y
-
mStartOffset
.
y
)
>
BOUNDS_EPSILON
)
{
mSentBounceY
=
true
;
}
else
{
bounceVelocity
.
y
=
0
.
0f
;
}
if
(
!
IsZero
(
bounceVelocity
)
)
{
DeferHandleFlingOverscroll
(
bounceVelocity
)
;
}
}
return
true
;
}
void
StackScrollerFlingAnimation
:
:
DeferHandleFlingOverscroll
(
ParentLayerPoint
&
aVelocity
)
{
mDeferredTasks
.
AppendElement
(
NewRunnableMethod
<
ParentLayerPoint
RefPtr
<
const
OverscrollHandoffChain
>
RefPtr
<
const
AsyncPanZoomController
>
>
(
"
layers
:
:
AsyncPanZoomController
:
:
HandleFlingOverscroll
"
&
mApzc
&
AsyncPanZoomController
:
:
HandleFlingOverscroll
aVelocity
mOverscrollHandoffChain
mScrolledApzc
)
)
;
}
bool
StackScrollerFlingAnimation
:
:
CheckBounds
(
Axis
&
aAxis
float
aValue
float
aDirection
float
*
aClamped
)
{
if
(
(
aDirection
<
0
.
0f
)
&
&
(
aValue
<
=
aAxis
.
GetPageStart
(
)
.
value
)
)
{
if
(
aClamped
)
{
*
aClamped
=
aAxis
.
GetPageStart
(
)
.
value
;
}
return
true
;
}
else
if
(
(
aDirection
>
0
.
0f
)
&
&
(
aValue
>
=
aAxis
.
GetScrollRangeEnd
(
)
.
value
)
)
{
if
(
aClamped
)
{
*
aClamped
=
aAxis
.
GetScrollRangeEnd
(
)
.
value
;
}
return
true
;
}
return
false
;
}
}
}
