#
include
"
TaskThrottler
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
define
TASK_LOG
(
.
.
.
)
namespace
mozilla
{
namespace
layers
{
TaskThrottler
:
:
TaskThrottler
(
const
TimeStamp
&
aTimeStamp
const
TimeDuration
&
aMaxWait
)
:
mMonitor
(
"
TaskThrottler
"
)
mOutstanding
(
false
)
mQueuedTask
(
nullptr
)
mStartTime
(
aTimeStamp
)
mMaxWait
(
aMaxWait
)
mMean
(
1
)
mTimeoutTask
(
nullptr
)
{
}
TaskThrottler
:
:
~
TaskThrottler
(
)
{
}
void
TaskThrottler
:
:
PostTask
(
const
tracked_objects
:
:
Location
&
aLocation
UniquePtr
<
CancelableTask
>
aTask
const
TimeStamp
&
aTimeStamp
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
TASK_LOG
(
"
%
p
got
a
task
posted
;
mOutstanding
=
%
d
\
n
"
this
mOutstanding
)
;
aTask
-
>
SetBirthPlace
(
aLocation
)
;
if
(
mOutstanding
)
{
CancelPendingTask
(
lock
)
;
if
(
TimeSinceLastRequest
(
aTimeStamp
lock
)
<
mMaxWait
)
{
mQueuedTask
=
Move
(
aTask
)
;
TASK_LOG
(
"
%
p
queued
task
%
p
\
n
"
this
mQueuedTask
.
get
(
)
)
;
TimeDuration
timeout
=
mMaxWait
-
TimeSinceLastRequest
(
aTimeStamp
lock
)
;
mTimeoutTask
=
NewRunnableMethod
(
this
&
TaskThrottler
:
:
OnTimeout
)
;
MessageLoop
:
:
current
(
)
-
>
PostDelayedTask
(
FROM_HERE
mTimeoutTask
timeout
.
ToMilliseconds
(
)
)
;
return
;
}
}
mStartTime
=
aTimeStamp
;
aTask
-
>
Run
(
)
;
mOutstanding
=
true
;
}
void
TaskThrottler
:
:
OnTimeout
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
mQueuedTask
)
{
RunQueuedTask
(
TimeStamp
:
:
Now
(
)
lock
)
;
}
mTimeoutTask
=
nullptr
;
}
void
TaskThrottler
:
:
TaskComplete
(
const
TimeStamp
&
aTimeStamp
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
!
mOutstanding
)
{
return
;
}
mMean
.
insert
(
aTimeStamp
-
mStartTime
)
;
if
(
mQueuedTask
)
{
RunQueuedTask
(
aTimeStamp
lock
)
;
CancelTimeoutTask
(
lock
)
;
}
else
{
mOutstanding
=
false
;
}
}
TimeDuration
TaskThrottler
:
:
AverageDuration
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
return
mMean
.
empty
(
)
?
TimeDuration
(
)
:
mMean
.
mean
(
)
;
}
void
TaskThrottler
:
:
RunQueuedTask
(
const
TimeStamp
&
aTimeStamp
const
MonitorAutoLock
&
aProofOfLock
)
{
TASK_LOG
(
"
%
p
running
task
%
p
\
n
"
this
mQueuedTask
.
get
(
)
)
;
mStartTime
=
aTimeStamp
;
mQueuedTask
-
>
Run
(
)
;
mQueuedTask
=
nullptr
;
}
void
TaskThrottler
:
:
CancelPendingTask
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
CancelPendingTask
(
lock
)
;
}
void
TaskThrottler
:
:
CancelPendingTask
(
const
MonitorAutoLock
&
aProofOfLock
)
{
if
(
mQueuedTask
)
{
TASK_LOG
(
"
%
p
cancelling
task
%
p
\
n
"
this
mQueuedTask
.
get
(
)
)
;
mQueuedTask
-
>
Cancel
(
)
;
mQueuedTask
=
nullptr
;
CancelTimeoutTask
(
aProofOfLock
)
;
}
}
void
TaskThrottler
:
:
CancelTimeoutTask
(
const
MonitorAutoLock
&
aProofOfLock
)
{
if
(
mTimeoutTask
)
{
mTimeoutTask
-
>
Cancel
(
)
;
mTimeoutTask
=
nullptr
;
}
}
TimeDuration
TaskThrottler
:
:
TimeSinceLastRequest
(
const
TimeStamp
&
aTimeStamp
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
return
TimeSinceLastRequest
(
aTimeStamp
lock
)
;
}
TimeDuration
TaskThrottler
:
:
TimeSinceLastRequest
(
const
TimeStamp
&
aTimeStamp
const
MonitorAutoLock
&
aProofOfLock
)
{
return
aTimeStamp
-
mStartTime
;
}
void
TaskThrottler
:
:
ClearHistory
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
mMean
.
clear
(
)
;
}
void
TaskThrottler
:
:
SetMaxDurations
(
uint32_t
aMaxDurations
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
aMaxDurations
!
=
mMean
.
maxValues
(
)
)
{
mMean
=
RollingMean
<
TimeDuration
TimeDuration
>
(
aMaxDurations
)
;
}
}
}
}
