#
ifndef
mozilla_layers_APZCTreeManager_h
#
define
mozilla_layers_APZCTreeManager_h
#
include
<
unordered_map
>
#
include
"
FocusState
.
h
"
#
include
"
HitTestingTreeNode
.
h
"
#
include
"
IAPZHitTester
.
h
"
#
include
"
gfxPoint
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
gfx
/
CompositorHitTestInfo
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
mozilla
/
layers
/
APZInputBridge
.
h
"
#
include
"
mozilla
/
layers
/
APZTestData
.
h
"
#
include
"
mozilla
/
layers
/
APZUtils
.
h
"
#
include
"
mozilla
/
layers
/
IAPZCTreeManager
.
h
"
#
include
"
mozilla
/
layers
/
LayerAttributes
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
KeyboardMap
.
h
"
#
include
"
mozilla
/
layers
/
TouchCounter
.
h
"
#
include
"
mozilla
/
layers
/
ZoomConstraints
.
h
"
#
include
"
mozilla
/
webrender
/
webrender_ffi
.
h
"
#
include
"
mozilla
/
RecursiveMutex
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
class
MultiTouchInput
;
namespace
wr
{
class
TransactionWrapper
;
class
WebRenderAPI
;
}
namespace
layers
{
class
Layer
;
class
AsyncPanZoomController
;
class
APZCTreeManagerParent
;
class
APZSampler
;
class
APZUpdater
;
class
CompositorBridgeParent
;
class
OverscrollHandoffChain
;
struct
OverscrollHandoffState
;
class
FocusTarget
;
struct
FlingHandoffState
;
class
InputQueue
;
class
GeckoContentController
;
class
HitTestingTreeNode
;
class
SampleTime
;
class
WebRenderScrollDataWrapper
;
struct
AncestorTransform
;
struct
ScrollThumbData
;
struct
ZoomTarget
;
class
APZCTreeManager
:
public
IAPZCTreeManager
public
APZInputBridge
{
typedef
mozilla
:
:
layers
:
:
AllowedTouchBehavior
AllowedTouchBehavior
;
typedef
mozilla
:
:
layers
:
:
AsyncDragMetrics
AsyncDragMetrics
;
using
HitTestResult
=
IAPZHitTester
:
:
HitTestResult
;
struct
TreeBuildingState
;
public
:
explicit
APZCTreeManager
(
LayersId
aRootLayersId
UniquePtr
<
IAPZHitTester
>
aHitTester
=
nullptr
)
;
static
mozilla
:
:
LazyLogModule
sLog
;
void
SetSampler
(
APZSampler
*
aSampler
)
;
void
SetUpdater
(
APZUpdater
*
aUpdater
)
;
void
NotifyLayerTreeAdopted
(
LayersId
aLayersId
const
RefPtr
<
APZCTreeManager
>
&
aOldTreeManager
)
;
void
NotifyLayerTreeRemoved
(
LayersId
aLayersId
)
;
void
UpdateFocusState
(
LayersId
aRootLayerTreeId
LayersId
aOriginatingLayersId
const
FocusTarget
&
aFocusTarget
)
;
void
UpdateHitTestingTree
(
const
WebRenderScrollDataWrapper
&
aRoot
bool
aIsFirstPaint
LayersId
aOriginatingLayersId
uint32_t
aPaintSequenceNumber
)
;
void
SampleForWebRender
(
const
Maybe
<
VsyncId
>
&
aVsyncId
wr
:
:
TransactionWrapper
&
aTxn
const
SampleTime
&
aSampleTime
)
;
APZEventResult
ReceiveInputEvent
(
InputData
&
aEvent
InputBlockCallback
&
&
aCallback
=
InputBlockCallback
(
)
)
override
;
void
SetKeyboardMap
(
const
KeyboardMap
&
aKeyboardMap
)
override
;
void
ZoomToRect
(
const
ScrollableLayerGuid
&
aGuid
const
ZoomTarget
&
aZoomTarget
const
uint32_t
aFlags
=
DEFAULT_BEHAVIOR
)
override
;
void
ContentReceivedInputBlock
(
uint64_t
aInputBlockId
bool
aPreventDefault
)
override
;
void
SetTargetAPZC
(
uint64_t
aInputBlockId
const
nsTArray
<
ScrollableLayerGuid
>
&
aTargets
)
override
;
void
UpdateZoomConstraints
(
const
ScrollableLayerGuid
&
aGuid
const
Maybe
<
ZoomConstraints
>
&
aConstraints
)
override
;
void
ClearTree
(
)
;
void
SetDPI
(
float
aDpiValue
)
override
;
float
GetDPI
(
)
const
;
void
FindScrollThumbNode
(
const
AsyncDragMetrics
&
aDragMetrics
LayersId
aLayersId
HitTestingTreeNodeAutoLock
&
aOutThumbNode
)
;
void
SetAllowedTouchBehavior
(
uint64_t
aInputBlockId
const
nsTArray
<
TouchBehaviorFlags
>
&
aValues
)
override
;
bool
DispatchScroll
(
AsyncPanZoomController
*
aPrev
ParentLayerPoint
&
aStartPoint
ParentLayerPoint
&
aEndPoint
OverscrollHandoffState
&
aOverscrollHandoffState
)
;
ParentLayerPoint
DispatchFling
(
AsyncPanZoomController
*
aApzc
const
FlingHandoffState
&
aHandoffState
)
;
void
StartScrollbarDrag
(
const
ScrollableLayerGuid
&
aGuid
const
AsyncDragMetrics
&
aDragMetrics
)
override
;
bool
StartAutoscroll
(
const
ScrollableLayerGuid
&
aGuid
const
ScreenPoint
&
aAnchorLocation
)
override
;
void
StopAutoscroll
(
const
ScrollableLayerGuid
&
aGuid
)
override
;
RefPtr
<
const
OverscrollHandoffChain
>
BuildOverscrollHandoffChain
(
const
RefPtr
<
AsyncPanZoomController
>
&
aInitialTarget
)
;
void
SetLongTapEnabled
(
bool
aTapGestureEnabled
)
override
;
APZInputBridge
*
InputBridge
(
)
override
{
return
this
;
}
void
AddInputBlockCallback
(
uint64_t
aInputBlockId
InputBlockCallback
&
&
aCallback
)
;
void
ProcessUnhandledEvent
(
LayoutDeviceIntPoint
*
aRefPoint
ScrollableLayerGuid
*
aOutTargetGuid
uint64_t
*
aOutFocusSequenceNumber
LayersId
*
aOutLayersId
)
override
;
void
UpdateWheelTransaction
(
LayoutDeviceIntPoint
aRefPoint
EventMessage
aEventMessage
const
Maybe
<
ScrollableLayerGuid
>
&
aTargetGuid
)
override
;
bool
GetAPZTestData
(
LayersId
aLayersId
APZTestData
*
aOutData
)
;
void
SendSubtreeTransformsToChromeMainThread
(
const
AsyncPanZoomController
*
aAncestor
)
;
void
SetFixedLayerMargins
(
ScreenIntCoord
aTop
ScreenIntCoord
aBottom
)
;
static
LayerToParentLayerMatrix4x4
ComputeTransformForScrollThumb
(
const
LayerToParentLayerMatrix4x4
&
aCurrentTransform
const
gfx
:
:
Matrix4x4
&
aScrollableContentTransform
AsyncPanZoomController
*
aApzc
const
FrameMetrics
&
aMetrics
const
ScrollbarData
&
aScrollbarData
bool
aScrollbarIsDescendant
)
;
static
void
FlushApzRepaints
(
LayersId
aLayersId
)
;
void
MarkAsDetached
(
LayersId
aLayersId
)
;
void
AssertOnSamplerThread
(
)
;
void
AssertOnUpdaterThread
(
)
;
already_AddRefed
<
wr
:
:
WebRenderAPI
>
GetWebRenderAPI
(
)
const
;
protected
:
virtual
~
APZCTreeManager
(
)
;
APZSampler
*
GetSampler
(
)
const
;
APZUpdater
*
GetUpdater
(
)
const
;
private
:
friend
class
APZUpdater
;
void
LockTree
(
)
MOZ_CAPABILITY_ACQUIRE
(
mTreeLock
)
;
void
UnlockTree
(
)
MOZ_CAPABILITY_RELEASE
(
mTreeLock
)
;
virtual
AsyncPanZoomController
*
NewAPZCInstance
(
LayersId
aLayersId
GeckoContentController
*
aController
)
;
public
:
virtual
SampleTime
GetFrameTime
(
)
;
void
SetTestSampleTime
(
const
Maybe
<
TimeStamp
>
&
aTime
)
;
private
:
mutable
DataMutex
<
Maybe
<
TimeStamp
>
>
mTestSampleTime
;
CopyableTArray
<
MatrixMessage
>
mLastMessages
;
public
:
RefPtr
<
HitTestingTreeNode
>
GetRootNode
(
)
const
;
HitTestResult
GetTargetAPZC
(
const
ScreenPoint
&
aPoint
)
;
already_AddRefed
<
AsyncPanZoomController
>
GetTargetAPZC
(
const
LayersId
&
aLayersId
const
ScrollableLayerGuid
:
:
ViewID
&
aScrollId
)
const
;
already_AddRefed
<
AsyncPanZoomController
>
GetTargetAPZC
(
const
LayersId
&
aLayersId
const
ScrollableLayerGuid
:
:
ViewID
&
aScrollId
const
MutexAutoLock
&
aProofOfMapLock
)
const
;
ScreenToParentLayerMatrix4x4
GetScreenToApzcTransform
(
const
AsyncPanZoomController
*
aApzc
)
const
;
ParentLayerToScreenMatrix4x4
GetApzcToGeckoTransformForHit
(
HitTestResult
&
aHitResult
)
const
;
ParentLayerToScreenMatrix4x4
GetApzcToGeckoTransform
(
const
AsyncPanZoomController
*
aApzc
const
AsyncTransformComponents
&
aComponents
)
const
;
ScreenPoint
GetCurrentMousePosition
(
)
const
;
void
SetCurrentMousePosition
(
const
ScreenPoint
&
aNewPos
)
;
Maybe
<
ScreenIntPoint
>
ConvertToGecko
(
const
ScreenIntPoint
&
aPoint
AsyncPanZoomController
*
aApzc
)
;
already_AddRefed
<
AsyncPanZoomController
>
FindZoomableApzc
(
AsyncPanZoomController
*
aStart
)
const
;
ScreenMargin
GetCompositorFixedLayerMargins
(
)
const
;
void
AdjustEventPointForDynamicToolbar
(
ScreenIntPoint
&
aEventPoint
const
HitTestResult
&
aHit
)
;
APZScrollGeneration
NewAPZScrollGeneration
(
)
{
MutexAutoLock
lock
(
mScrollGenerationLock
)
;
return
mScrollGenerationCounter
.
NewAPZGeneration
(
)
;
}
template
<
typename
Callback
>
void
CallWithMapLock
(
Callback
&
aCallback
)
{
MutexAutoLock
lock
(
mMapLock
)
;
aCallback
(
lock
)
;
}
private
:
using
GuidComparator
=
ScrollableLayerGuid
:
:
Comparator
;
using
ScrollNode
=
WebRenderScrollDataWrapper
;
void
AttachNodeToTree
(
HitTestingTreeNode
*
aNode
HitTestingTreeNode
*
aParent
HitTestingTreeNode
*
aNextSibling
)
MOZ_REQUIRES
(
mTreeLock
)
;
already_AddRefed
<
AsyncPanZoomController
>
GetTargetAPZC
(
const
ScrollableLayerGuid
&
aGuid
)
;
already_AddRefed
<
HitTestingTreeNode
>
GetTargetNode
(
const
ScrollableLayerGuid
&
aGuid
GuidComparator
aComparator
)
const
;
HitTestingTreeNode
*
FindTargetNode
(
HitTestingTreeNode
*
aNode
const
ScrollableLayerGuid
&
aGuid
GuidComparator
aComparator
)
;
AsyncPanZoomController
*
GetTargetApzcForNode
(
const
HitTestingTreeNode
*
aNode
)
;
AsyncPanZoomController
*
FindHandoffParent
(
const
AsyncPanZoomController
*
aApzc
)
;
HitTestingTreeNode
*
FindRootNodeForLayersId
(
LayersId
aLayersId
)
const
;
AsyncPanZoomController
*
FindRootContentApzcForLayersId
(
LayersId
aLayersId
)
const
;
already_AddRefed
<
AsyncPanZoomController
>
GetZoomableTarget
(
AsyncPanZoomController
*
aApzc1
AsyncPanZoomController
*
aApzc2
)
const
;
already_AddRefed
<
AsyncPanZoomController
>
CommonAncestor
(
AsyncPanZoomController
*
aApzc1
AsyncPanZoomController
*
aApzc2
)
const
;
struct
FixedPositionInfo
;
struct
StickyPositionInfo
;
bool
IsFixedToRootContent
(
const
HitTestingTreeNode
*
aNode
)
const
;
bool
IsFixedToRootContent
(
const
FixedPositionInfo
&
aFixedInfo
const
MutexAutoLock
&
aProofOfMapLock
)
const
;
SideBits
SidesStuckToRootContent
(
const
HitTestingTreeNode
*
aNode
)
const
;
SideBits
SidesStuckToRootContent
(
const
StickyPositionInfo
&
aStickyInfo
const
MutexAutoLock
&
aProofOfMapLock
)
const
;
HitTestResult
GetTouchInputBlockAPZC
(
const
MultiTouchInput
&
aEvent
nsTArray
<
TouchBehaviorFlags
>
*
aOutTouchBehaviors
)
;
struct
InputHandlingState
{
InputData
&
mEvent
;
APZEventResult
mResult
;
HitTestResult
mHit
;
APZEventResult
Finish
(
APZCTreeManager
&
aTreeManager
InputBlockCallback
&
&
aCallback
)
;
}
;
void
ProcessTouchInput
(
InputHandlingState
&
aState
MultiTouchInput
&
aInput
)
;
void
SetupScrollbarDrag
(
MouseInput
&
aMouseInput
const
HitTestingTreeNodeAutoLock
&
aScrollThumbNode
AsyncPanZoomController
*
aApzc
)
;
APZEventResult
ProcessTouchInputForScrollbarDrag
(
MultiTouchInput
&
aInput
const
HitTestingTreeNodeAutoLock
&
aScrollThumbNode
const
gfx
:
:
CompositorHitTestInfo
&
aHitInfo
)
;
void
FlushRepaintsToClearScreenToGeckoTransform
(
)
;
void
SynthesizePinchGestureFromMouseWheel
(
const
ScrollWheelInput
&
aWheelInput
const
RefPtr
<
AsyncPanZoomController
>
&
aTarget
)
;
already_AddRefed
<
HitTestingTreeNode
>
RecycleOrCreateNode
(
const
RecursiveMutexAutoLock
&
aProofOfTreeLock
TreeBuildingState
&
aState
AsyncPanZoomController
*
aApzc
LayersId
aLayersId
)
;
HitTestingTreeNode
*
PrepareNodeForLayer
(
const
RecursiveMutexAutoLock
&
aProofOfTreeLock
const
ScrollNode
&
aLayer
const
FrameMetrics
&
aMetrics
LayersId
aLayersId
const
Maybe
<
ZoomConstraints
>
&
aZoomConstraints
const
AncestorTransform
&
aAncestorTransform
HitTestingTreeNode
*
aParent
HitTestingTreeNode
*
aNextSibling
TreeBuildingState
&
aState
)
;
void
PrintLayerInfo
(
const
ScrollNode
&
aLayer
)
;
void
NotifyScrollbarDragInitiated
(
uint64_t
aDragBlockId
const
ScrollableLayerGuid
&
aGuid
ScrollDirection
aDirection
)
const
;
void
NotifyScrollbarDragRejected
(
const
ScrollableLayerGuid
&
aGuid
)
const
;
void
NotifyAutoscrollRejected
(
const
ScrollableLayerGuid
&
aGuid
)
const
;
LayerToParentLayerMatrix4x4
ComputeTransformForNode
(
const
HitTestingTreeNode
*
aNode
)
const
MOZ_REQUIRES
(
mTreeLock
)
;
static
already_AddRefed
<
GeckoContentController
>
GetContentController
(
LayersId
aLayersId
)
;
bool
AdvanceAnimationsInternal
(
const
MutexAutoLock
&
aProofOfMapLock
const
SampleTime
&
aSampleTime
)
;
using
ClippedCompositionBoundsMap
=
std
:
:
unordered_map
<
ScrollableLayerGuid
ParentLayerRect
ScrollableLayerGuid
:
:
HashIgnoringPresShellFn
ScrollableLayerGuid
:
:
EqualIgnoringPresShellFn
>
;
ParentLayerRect
ComputeClippedCompositionBounds
(
const
MutexAutoLock
&
aProofOfMapLock
ClippedCompositionBoundsMap
&
aDestMap
ScrollableLayerGuid
aGuid
)
;
ScreenMargin
GetCompositorFixedLayerMargins
(
const
MutexAutoLock
&
aProofOfMapLock
)
const
;
protected
:
RefPtr
<
InputQueue
>
mInputQueue
;
private
:
LayersId
mRootLayersId
;
APZSampler
*
MOZ_NON_OWNING_REF
mSampler
;
APZUpdater
*
MOZ_NON_OWNING_REF
mUpdater
;
mutable
mozilla
:
:
RecursiveMutex
mTreeLock
;
RefPtr
<
HitTestingTreeNode
>
mRootNode
MOZ_GUARDED_BY
(
mTreeLock
)
;
std
:
:
unordered_set
<
LayersId
LayersId
:
:
HashFn
>
mDetachedLayersIds
MOZ_GUARDED_BY
(
mTreeLock
)
;
Maybe
<
LayersId
>
mAsyncZoomContainerSubtree
;
mutable
mozilla
:
:
Mutex
mMapLock
;
struct
ApzcMapData
{
RefPtr
<
AsyncPanZoomController
>
apzc
;
Maybe
<
ScrollableLayerGuid
>
parent
;
}
;
std
:
:
unordered_map
<
ScrollableLayerGuid
ApzcMapData
ScrollableLayerGuid
:
:
HashIgnoringPresShellFn
ScrollableLayerGuid
:
:
EqualIgnoringPresShellFn
>
mApzcMap
;
struct
ScrollThumbInfo
{
uint64_t
mThumbAnimationId
;
CSSTransformMatrix
mThumbTransform
;
ScrollbarData
mThumbData
;
ScrollableLayerGuid
mTargetGuid
;
CSSTransformMatrix
mTargetTransform
;
bool
mTargetIsAncestor
;
ScrollThumbInfo
(
const
uint64_t
&
aThumbAnimationId
const
CSSTransformMatrix
&
aThumbTransform
const
ScrollbarData
&
aThumbData
const
ScrollableLayerGuid
&
aTargetGuid
const
CSSTransformMatrix
&
aTargetTransform
bool
aTargetIsAncestor
)
:
mThumbAnimationId
(
aThumbAnimationId
)
mThumbTransform
(
aThumbTransform
)
mThumbData
(
aThumbData
)
mTargetGuid
(
aTargetGuid
)
mTargetTransform
(
aTargetTransform
)
mTargetIsAncestor
(
aTargetIsAncestor
)
{
MOZ_ASSERT
(
mTargetGuid
.
mScrollId
=
=
mThumbData
.
mTargetViewId
)
;
}
}
;
std
:
:
vector
<
ScrollThumbInfo
>
mScrollThumbInfo
;
struct
RootScrollbarInfo
{
uint64_t
mScrollbarAnimationId
;
ScrollDirection
mScrollDirection
;
RootScrollbarInfo
(
const
uint64_t
&
aScrollbarAnimationId
const
ScrollDirection
aScrollDirection
)
:
mScrollbarAnimationId
(
aScrollbarAnimationId
)
mScrollDirection
(
aScrollDirection
)
{
}
}
;
std
:
:
vector
<
RootScrollbarInfo
>
mRootScrollbarInfo
;
struct
FixedPositionInfo
{
Maybe
<
uint64_t
>
mFixedPositionAnimationId
;
SideBits
mFixedPosSides
;
ScrollableLayerGuid
:
:
ViewID
mFixedPosTarget
;
LayersId
mLayersId
;
explicit
FixedPositionInfo
(
const
HitTestingTreeNode
*
aNode
)
;
}
;
std
:
:
vector
<
FixedPositionInfo
>
mFixedPositionInfo
;
struct
StickyPositionInfo
{
Maybe
<
uint64_t
>
mStickyPositionAnimationId
;
SideBits
mFixedPosSides
;
ScrollableLayerGuid
:
:
ViewID
mStickyPosTarget
;
LayersId
mLayersId
;
LayerRectAbsolute
mStickyScrollRangeInner
;
LayerRectAbsolute
mStickyScrollRangeOuter
;
explicit
StickyPositionInfo
(
const
HitTestingTreeNode
*
aNode
)
;
}
;
std
:
:
vector
<
StickyPositionInfo
>
mStickyPositionInfo
;
std
:
:
unordered_map
<
ScrollableLayerGuid
ZoomConstraints
ScrollableLayerGuid
:
:
HashIgnoringPresShellFn
ScrollableLayerGuid
:
:
EqualIgnoringPresShellFn
>
mZoomConstraints
;
KeyboardMap
mKeyboardMap
;
FocusState
mFocusState
;
HitTestResult
mTouchBlockHitResult
;
int32_t
mRetainedTouchIdentifier
;
bool
mInScrollbarTouchDrag
;
TouchCounter
mTouchCounter
;
HitTestResult
mTapGestureHitResult
;
mutable
DataMutex
<
ScreenPoint
>
mCurrentMousePosition
;
ScreenMargin
mCompositorFixedLayerMargins
;
ScreenMargin
mGeckoFixedLayerMargins
;
gfx
:
:
TreeLog
<
gfx
:
:
LOG_CRITICAL
>
mApzcTreeLog
;
class
CheckerboardFlushObserver
;
friend
class
CheckerboardFlushObserver
;
RefPtr
<
CheckerboardFlushObserver
>
mFlushObserver
;
std
:
:
unordered_map
<
LayersId
UniquePtr
<
APZTestData
>
LayersId
:
:
HashFn
>
mTestData
;
mutable
mozilla
:
:
Mutex
mTestDataLock
;
float
mDPI
;
friend
class
IAPZHitTester
;
UniquePtr
<
IAPZHitTester
>
mHitTester
;
ScrollGenerationCounter
mScrollGenerationCounter
;
mozilla
:
:
Mutex
mScrollGenerationLock
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
private
:
GeckoViewMetrics
mLastRootMetrics
;
#
endif
}
;
}
}
#
endif
