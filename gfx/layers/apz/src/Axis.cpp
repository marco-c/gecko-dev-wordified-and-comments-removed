#
include
"
Axis
.
h
"
#
include
<
math
.
h
>
#
include
<
algorithm
>
#
include
"
AsyncPanZoomController
.
h
"
#
include
"
mozilla
/
layers
/
APZCTreeManager
.
h
"
#
include
"
mozilla
/
layers
/
APZThreadUtils
.
h
"
#
include
"
FrameMetrics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ComputedTimingFunction
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
nsMathUtils
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nscore
.
h
"
#
include
"
gfxPrefs
.
h
"
#
define
AXIS_LOG
(
.
.
.
)
namespace
mozilla
{
namespace
layers
{
const
uint32_t
MIN_VELOCITY_SAMPLE_TIME_MS
=
5
;
bool
FuzzyEqualsCoordinate
(
float
aValue1
float
aValue2
)
{
return
FuzzyEqualsAdditive
(
aValue1
aValue2
COORDINATE_EPSILON
)
|
|
FuzzyEqualsMultiplicative
(
aValue1
aValue2
)
;
}
extern
StaticAutoPtr
<
ComputedTimingFunction
>
gVelocityCurveFunction
;
Axis
:
:
Axis
(
AsyncPanZoomController
*
aAsyncPanZoomController
)
:
mPos
(
0
)
mVelocitySampleTimeMs
(
0
)
mVelocitySamplePos
(
0
)
mVelocity
(
0
.
0f
)
mAxisLocked
(
false
)
mAsyncPanZoomController
(
aAsyncPanZoomController
)
mOverscroll
(
0
)
mMSDModel
(
0
.
0
0
.
0
0
.
0
400
.
0
1
.
2
)
{
}
float
Axis
:
:
ToLocalVelocity
(
float
aVelocityInchesPerMs
)
const
{
ScreenPoint
velocity
=
MakePoint
(
aVelocityInchesPerMs
*
APZCTreeManager
:
:
GetDPI
(
)
)
;
ScreenPoint
panStart
=
mAsyncPanZoomController
-
>
ToScreenCoordinates
(
mAsyncPanZoomController
-
>
PanStart
(
)
ParentLayerPoint
(
)
)
;
ParentLayerPoint
localVelocity
=
mAsyncPanZoomController
-
>
ToParentLayerCoordinates
(
velocity
panStart
)
;
return
localVelocity
.
Length
(
)
;
}
void
Axis
:
:
UpdateWithTouchAtDevicePoint
(
ParentLayerCoord
aPos
ParentLayerCoord
aAdditionalDelta
uint32_t
aTimestampMs
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
if
(
aTimestampMs
<
=
mVelocitySampleTimeMs
+
MIN_VELOCITY_SAMPLE_TIME_MS
)
{
AXIS_LOG
(
"
%
p
|
%
s
skipping
velocity
computation
for
small
time
delta
%
dms
\
n
"
mAsyncPanZoomController
Name
(
)
(
aTimestampMs
-
mVelocitySampleTimeMs
)
)
;
mPos
=
aPos
;
return
;
}
float
newVelocity
=
mAxisLocked
?
0
.
0f
:
(
float
)
(
mVelocitySamplePos
-
aPos
+
aAdditionalDelta
)
/
(
float
)
(
aTimestampMs
-
mVelocitySampleTimeMs
)
;
newVelocity
=
ApplyFlingCurveToVelocity
(
newVelocity
)
;
AXIS_LOG
(
"
%
p
|
%
s
updating
velocity
to
%
f
with
touch
\
n
"
mAsyncPanZoomController
Name
(
)
newVelocity
)
;
mVelocity
=
newVelocity
;
mPos
=
aPos
;
mVelocitySampleTimeMs
=
aTimestampMs
;
mVelocitySamplePos
=
aPos
;
AddVelocityToQueue
(
aTimestampMs
mVelocity
)
;
}
float
Axis
:
:
ApplyFlingCurveToVelocity
(
float
aVelocity
)
const
{
float
newVelocity
=
aVelocity
;
if
(
gfxPrefs
:
:
APZMaxVelocity
(
)
>
0
.
0f
)
{
bool
velocityIsNegative
=
(
newVelocity
<
0
)
;
newVelocity
=
fabs
(
newVelocity
)
;
float
maxVelocity
=
ToLocalVelocity
(
gfxPrefs
:
:
APZMaxVelocity
(
)
)
;
newVelocity
=
std
:
:
min
(
newVelocity
maxVelocity
)
;
if
(
gfxPrefs
:
:
APZCurveThreshold
(
)
>
0
.
0f
&
&
gfxPrefs
:
:
APZCurveThreshold
(
)
<
gfxPrefs
:
:
APZMaxVelocity
(
)
)
{
float
curveThreshold
=
ToLocalVelocity
(
gfxPrefs
:
:
APZCurveThreshold
(
)
)
;
if
(
newVelocity
>
curveThreshold
)
{
float
scale
=
maxVelocity
-
curveThreshold
;
float
funcInput
=
(
newVelocity
-
curveThreshold
)
/
scale
;
float
funcOutput
=
gVelocityCurveFunction
-
>
GetValue
(
funcInput
ComputedTimingFunction
:
:
BeforeFlag
:
:
Unset
)
;
float
curvedVelocity
=
(
funcOutput
*
scale
)
+
curveThreshold
;
AXIS_LOG
(
"
%
p
|
%
s
curving
up
velocity
from
%
f
to
%
f
\
n
"
mAsyncPanZoomController
Name
(
)
newVelocity
curvedVelocity
)
;
newVelocity
=
curvedVelocity
;
}
}
if
(
velocityIsNegative
)
{
newVelocity
=
-
newVelocity
;
}
}
return
newVelocity
;
}
void
Axis
:
:
AddVelocityToQueue
(
uint32_t
aTimestampMs
float
aVelocity
)
{
mVelocityQueue
.
AppendElement
(
std
:
:
make_pair
(
aTimestampMs
aVelocity
)
)
;
if
(
mVelocityQueue
.
Length
(
)
>
gfxPrefs
:
:
APZMaxVelocityQueueSize
(
)
)
{
mVelocityQueue
.
RemoveElementAt
(
0
)
;
}
}
void
Axis
:
:
HandleTouchVelocity
(
uint32_t
aTimestampMs
float
aSpeed
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
mVelocity
=
ApplyFlingCurveToVelocity
(
aSpeed
)
;
mVelocitySampleTimeMs
=
aTimestampMs
;
AddVelocityToQueue
(
aTimestampMs
mVelocity
)
;
}
void
Axis
:
:
StartTouch
(
ParentLayerCoord
aPos
uint32_t
aTimestampMs
)
{
mStartPos
=
aPos
;
mPos
=
aPos
;
mVelocitySampleTimeMs
=
aTimestampMs
;
mVelocitySamplePos
=
aPos
;
mAxisLocked
=
false
;
}
bool
Axis
:
:
AdjustDisplacement
(
ParentLayerCoord
aDisplacement
float
&
aDisplacementOut
float
&
aOverscrollAmountOut
bool
aForceOverscroll
)
{
if
(
mAxisLocked
)
{
aOverscrollAmountOut
=
0
;
aDisplacementOut
=
0
;
return
false
;
}
if
(
aForceOverscroll
)
{
aOverscrollAmountOut
=
aDisplacement
;
aDisplacementOut
=
0
;
return
false
;
}
EndOverscrollAnimation
(
)
;
ParentLayerCoord
displacement
=
aDisplacement
;
ParentLayerCoord
consumedOverscroll
=
0
;
if
(
mOverscroll
>
0
&
&
aDisplacement
<
0
)
{
consumedOverscroll
=
std
:
:
min
(
mOverscroll
-
aDisplacement
)
;
}
else
if
(
mOverscroll
<
0
&
&
aDisplacement
>
0
)
{
consumedOverscroll
=
0
.
f
-
std
:
:
min
(
-
mOverscroll
aDisplacement
)
;
}
mOverscroll
-
=
consumedOverscroll
;
displacement
+
=
consumedOverscroll
;
aOverscrollAmountOut
=
DisplacementWillOverscrollAmount
(
displacement
)
;
if
(
aOverscrollAmountOut
!
=
0
.
0f
)
{
AXIS_LOG
(
"
%
p
|
%
s
has
overscrolled
clearing
velocity
\
n
"
mAsyncPanZoomController
Name
(
)
)
;
mVelocity
=
0
.
0f
;
displacement
-
=
aOverscrollAmountOut
;
}
aDisplacementOut
=
displacement
;
return
fabsf
(
consumedOverscroll
)
>
EPSILON
;
}
ParentLayerCoord
Axis
:
:
ApplyResistance
(
ParentLayerCoord
aRequestedOverscroll
)
const
{
float
resistanceFactor
=
(
1
-
fabsf
(
GetOverscroll
(
)
)
/
GetCompositionLength
(
)
)
/
16
;
float
result
=
resistanceFactor
<
0
?
ParentLayerCoord
(
0
)
:
aRequestedOverscroll
*
resistanceFactor
;
result
=
clamped
(
result
-
8
.
0f
8
.
0f
)
;
return
result
;
}
void
Axis
:
:
OverscrollBy
(
ParentLayerCoord
aOverscroll
)
{
MOZ_ASSERT
(
CanScroll
(
)
)
;
if
(
FuzzyEqualsAdditive
(
aOverscroll
.
value
0
.
0f
COORDINATE_EPSILON
)
)
{
return
;
}
EndOverscrollAnimation
(
)
;
aOverscroll
=
ApplyResistance
(
aOverscroll
)
;
if
(
aOverscroll
>
0
)
{
#
ifdef
DEBUG
if
(
!
FuzzyEqualsCoordinate
(
GetCompositionEnd
(
)
.
value
GetPageEnd
(
)
.
value
)
)
{
nsPrintfCString
message
(
"
composition
end
(
%
f
)
is
not
equal
(
within
error
)
to
page
end
(
%
f
)
\
n
"
GetCompositionEnd
(
)
.
value
GetPageEnd
(
)
.
value
)
;
NS_ASSERTION
(
false
message
.
get
(
)
)
;
MOZ_CRASH
(
"
GFX
:
Overscroll
issue
>
0
"
)
;
}
#
endif
MOZ_ASSERT
(
mOverscroll
>
=
0
)
;
}
else
if
(
aOverscroll
<
0
)
{
#
ifdef
DEBUG
if
(
!
FuzzyEqualsCoordinate
(
GetOrigin
(
)
.
value
GetPageStart
(
)
.
value
)
)
{
nsPrintfCString
message
(
"
composition
origin
(
%
f
)
is
not
equal
(
within
error
)
to
page
origin
(
%
f
)
\
n
"
GetOrigin
(
)
.
value
GetPageStart
(
)
.
value
)
;
NS_ASSERTION
(
false
message
.
get
(
)
)
;
MOZ_CRASH
(
"
GFX
:
Overscroll
issue
<
0
"
)
;
}
#
endif
MOZ_ASSERT
(
mOverscroll
<
=
0
)
;
}
mOverscroll
+
=
aOverscroll
;
}
ParentLayerCoord
Axis
:
:
GetOverscroll
(
)
const
{
return
mOverscroll
;
}
void
Axis
:
:
StartOverscrollAnimation
(
float
aVelocity
)
{
aVelocity
=
clamped
(
aVelocity
/
2
.
0f
-
20
.
0f
20
.
0f
)
;
SetVelocity
(
aVelocity
)
;
mMSDModel
.
SetPosition
(
mOverscroll
)
;
mMSDModel
.
SetVelocity
(
mVelocity
*
1000
.
0
)
;
}
void
Axis
:
:
EndOverscrollAnimation
(
)
{
mMSDModel
.
SetPosition
(
0
.
0
)
;
mMSDModel
.
SetVelocity
(
0
.
0
)
;
}
bool
Axis
:
:
SampleOverscrollAnimation
(
const
TimeDuration
&
aDelta
)
{
mMSDModel
.
Simulate
(
aDelta
)
;
mOverscroll
=
mMSDModel
.
GetPosition
(
)
;
if
(
mMSDModel
.
IsFinished
(
1
.
0
)
)
{
AXIS_LOG
(
"
%
p
|
%
s
oscillation
dropped
below
threshold
going
to
rest
\
n
"
mAsyncPanZoomController
Name
(
)
)
;
ClearOverscroll
(
)
;
mVelocity
=
0
;
return
false
;
}
return
true
;
}
bool
Axis
:
:
IsOverscrolled
(
)
const
{
return
mOverscroll
!
=
0
.
f
;
}
void
Axis
:
:
ClearOverscroll
(
)
{
EndOverscrollAnimation
(
)
;
mOverscroll
=
0
;
}
ParentLayerCoord
Axis
:
:
PanStart
(
)
const
{
return
mStartPos
;
}
ParentLayerCoord
Axis
:
:
PanDistance
(
)
const
{
return
fabs
(
mPos
-
mStartPos
)
;
}
ParentLayerCoord
Axis
:
:
PanDistance
(
ParentLayerCoord
aPos
)
const
{
return
fabs
(
aPos
-
mStartPos
)
;
}
void
Axis
:
:
EndTouch
(
uint32_t
aTimestampMs
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
mAxisLocked
=
false
;
mVelocity
=
0
;
int
count
=
0
;
while
(
!
mVelocityQueue
.
IsEmpty
(
)
)
{
uint32_t
timeDelta
=
(
aTimestampMs
-
mVelocityQueue
[
0
]
.
first
)
;
if
(
timeDelta
<
gfxPrefs
:
:
APZVelocityRelevanceTime
(
)
)
{
count
+
+
;
mVelocity
+
=
mVelocityQueue
[
0
]
.
second
;
}
mVelocityQueue
.
RemoveElementAt
(
0
)
;
}
if
(
count
>
1
)
{
mVelocity
/
=
count
;
}
AXIS_LOG
(
"
%
p
|
%
s
ending
touch
computed
velocity
%
f
\
n
"
mAsyncPanZoomController
Name
(
)
mVelocity
)
;
}
void
Axis
:
:
CancelGesture
(
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
AXIS_LOG
(
"
%
p
|
%
s
cancelling
touch
clearing
velocity
queue
\
n
"
mAsyncPanZoomController
Name
(
)
)
;
mVelocity
=
0
.
0f
;
while
(
!
mVelocityQueue
.
IsEmpty
(
)
)
{
mVelocityQueue
.
RemoveElementAt
(
0
)
;
}
}
bool
Axis
:
:
CanScroll
(
)
const
{
return
GetPageLength
(
)
-
GetCompositionLength
(
)
>
COORDINATE_EPSILON
;
}
bool
Axis
:
:
CanScroll
(
ParentLayerCoord
aDelta
)
const
{
if
(
!
CanScroll
(
)
|
|
mAxisLocked
)
{
return
false
;
}
return
fabs
(
DisplacementWillOverscrollAmount
(
aDelta
)
-
aDelta
)
>
COORDINATE_EPSILON
;
}
CSSCoord
Axis
:
:
ClampOriginToScrollableRect
(
CSSCoord
aOrigin
)
const
{
CSSToParentLayerScale
zoom
=
GetScaleForAxis
(
GetFrameMetrics
(
)
.
GetZoom
(
)
)
;
ParentLayerCoord
origin
=
aOrigin
*
zoom
;
ParentLayerCoord
result
;
if
(
origin
<
GetPageStart
(
)
)
{
result
=
GetPageStart
(
)
;
}
else
if
(
origin
+
GetCompositionLength
(
)
>
GetPageEnd
(
)
)
{
result
=
GetPageEnd
(
)
-
GetCompositionLength
(
)
;
}
else
{
return
aOrigin
;
}
return
result
/
zoom
;
}
bool
Axis
:
:
CanScrollNow
(
)
const
{
return
!
mAxisLocked
&
&
CanScroll
(
)
;
}
bool
Axis
:
:
FlingApplyFrictionOrCancel
(
const
TimeDuration
&
aDelta
float
aFriction
float
aThreshold
)
{
if
(
fabsf
(
mVelocity
)
<
=
aThreshold
)
{
mVelocity
=
0
.
0f
;
return
false
;
}
else
{
mVelocity
*
=
pow
(
1
.
0f
-
aFriction
float
(
aDelta
.
ToMilliseconds
(
)
)
)
;
}
AXIS_LOG
(
"
%
p
|
%
s
reduced
velocity
to
%
f
due
to
friction
\
n
"
mAsyncPanZoomController
Name
(
)
mVelocity
)
;
return
true
;
}
ParentLayerCoord
Axis
:
:
DisplacementWillOverscrollAmount
(
ParentLayerCoord
aDisplacement
)
const
{
ParentLayerCoord
newOrigin
=
GetOrigin
(
)
+
aDisplacement
;
ParentLayerCoord
newCompositionEnd
=
GetCompositionEnd
(
)
+
aDisplacement
;
bool
minus
=
newOrigin
<
GetPageStart
(
)
;
bool
plus
=
newCompositionEnd
>
GetPageEnd
(
)
;
if
(
minus
&
&
plus
)
{
return
0
;
}
if
(
minus
)
{
return
newOrigin
-
GetPageStart
(
)
;
}
if
(
plus
)
{
return
newCompositionEnd
-
GetPageEnd
(
)
;
}
return
0
;
}
CSSCoord
Axis
:
:
ScaleWillOverscrollAmount
(
float
aScale
CSSCoord
aFocus
)
const
{
CSSToParentLayerScale
zoom
=
GetFrameMetrics
(
)
.
GetZoom
(
)
.
ToScaleFactor
(
)
;
ParentLayerCoord
focus
=
aFocus
*
zoom
;
ParentLayerCoord
originAfterScale
=
(
GetOrigin
(
)
+
focus
)
-
(
focus
/
aScale
)
;
bool
both
=
ScaleWillOverscrollBothSides
(
aScale
)
;
bool
minus
=
GetPageStart
(
)
-
originAfterScale
>
COORDINATE_EPSILON
;
bool
plus
=
(
originAfterScale
+
(
GetCompositionLength
(
)
/
aScale
)
)
-
GetPageEnd
(
)
>
COORDINATE_EPSILON
;
if
(
(
minus
&
&
plus
)
|
|
both
)
{
MOZ_ASSERT
(
false
"
In
an
OVERSCROLL_BOTH
condition
in
ScaleWillOverscrollAmount
"
)
;
return
0
;
}
if
(
minus
)
{
return
(
originAfterScale
-
GetPageStart
(
)
)
/
zoom
;
}
if
(
plus
)
{
return
(
originAfterScale
+
(
GetCompositionLength
(
)
/
aScale
)
-
GetPageEnd
(
)
)
/
zoom
;
}
return
0
;
}
bool
Axis
:
:
IsAxisLocked
(
)
const
{
return
mAxisLocked
;
}
float
Axis
:
:
GetVelocity
(
)
const
{
return
mAxisLocked
?
0
:
mVelocity
;
}
void
Axis
:
:
SetVelocity
(
float
aVelocity
)
{
AXIS_LOG
(
"
%
p
|
%
s
direct
-
setting
velocity
to
%
f
\
n
"
mAsyncPanZoomController
Name
(
)
aVelocity
)
;
mVelocity
=
aVelocity
;
}
ParentLayerCoord
Axis
:
:
GetCompositionEnd
(
)
const
{
return
GetOrigin
(
)
+
GetCompositionLength
(
)
;
}
ParentLayerCoord
Axis
:
:
GetPageEnd
(
)
const
{
return
GetPageStart
(
)
+
GetPageLength
(
)
;
}
ParentLayerCoord
Axis
:
:
GetScrollRangeEnd
(
)
const
{
return
GetPageEnd
(
)
-
GetCompositionLength
(
)
;
}
ParentLayerCoord
Axis
:
:
GetOrigin
(
)
const
{
ParentLayerPoint
origin
=
GetFrameMetrics
(
)
.
GetScrollOffset
(
)
*
GetFrameMetrics
(
)
.
GetZoom
(
)
;
return
GetPointOffset
(
origin
)
;
}
ParentLayerCoord
Axis
:
:
GetCompositionLength
(
)
const
{
return
GetRectLength
(
GetFrameMetrics
(
)
.
GetCompositionBounds
(
)
)
;
}
ParentLayerCoord
Axis
:
:
GetPageStart
(
)
const
{
ParentLayerRect
pageRect
=
GetFrameMetrics
(
)
.
GetExpandedScrollableRect
(
)
*
GetFrameMetrics
(
)
.
GetZoom
(
)
;
return
GetRectOffset
(
pageRect
)
;
}
ParentLayerCoord
Axis
:
:
GetPageLength
(
)
const
{
ParentLayerRect
pageRect
=
GetFrameMetrics
(
)
.
GetExpandedScrollableRect
(
)
*
GetFrameMetrics
(
)
.
GetZoom
(
)
;
return
GetRectLength
(
pageRect
)
;
}
bool
Axis
:
:
ScaleWillOverscrollBothSides
(
float
aScale
)
const
{
const
FrameMetrics
&
metrics
=
GetFrameMetrics
(
)
;
ParentLayerRect
screenCompositionBounds
=
metrics
.
GetCompositionBounds
(
)
/
ParentLayerToParentLayerScale
(
aScale
)
;
return
GetRectLength
(
screenCompositionBounds
)
-
GetPageLength
(
)
>
COORDINATE_EPSILON
;
}
const
FrameMetrics
&
Axis
:
:
GetFrameMetrics
(
)
const
{
return
mAsyncPanZoomController
-
>
GetFrameMetrics
(
)
;
}
AxisX
:
:
AxisX
(
AsyncPanZoomController
*
aAsyncPanZoomController
)
:
Axis
(
aAsyncPanZoomController
)
{
}
ParentLayerCoord
AxisX
:
:
GetPointOffset
(
const
ParentLayerPoint
&
aPoint
)
const
{
return
aPoint
.
x
;
}
ParentLayerCoord
AxisX
:
:
GetRectLength
(
const
ParentLayerRect
&
aRect
)
const
{
return
aRect
.
width
;
}
ParentLayerCoord
AxisX
:
:
GetRectOffset
(
const
ParentLayerRect
&
aRect
)
const
{
return
aRect
.
x
;
}
CSSToParentLayerScale
AxisX
:
:
GetScaleForAxis
(
const
CSSToParentLayerScale2D
&
aScale
)
const
{
return
CSSToParentLayerScale
(
aScale
.
xScale
)
;
}
ScreenPoint
AxisX
:
:
MakePoint
(
ScreenCoord
aCoord
)
const
{
return
ScreenPoint
(
aCoord
0
)
;
}
const
char
*
AxisX
:
:
Name
(
)
const
{
return
"
X
"
;
}
AxisY
:
:
AxisY
(
AsyncPanZoomController
*
aAsyncPanZoomController
)
:
Axis
(
aAsyncPanZoomController
)
{
}
ParentLayerCoord
AxisY
:
:
GetPointOffset
(
const
ParentLayerPoint
&
aPoint
)
const
{
return
aPoint
.
y
;
}
ParentLayerCoord
AxisY
:
:
GetRectLength
(
const
ParentLayerRect
&
aRect
)
const
{
return
aRect
.
height
;
}
ParentLayerCoord
AxisY
:
:
GetRectOffset
(
const
ParentLayerRect
&
aRect
)
const
{
return
aRect
.
y
;
}
CSSToParentLayerScale
AxisY
:
:
GetScaleForAxis
(
const
CSSToParentLayerScale2D
&
aScale
)
const
{
return
CSSToParentLayerScale
(
aScale
.
yScale
)
;
}
ScreenPoint
AxisY
:
:
MakePoint
(
ScreenCoord
aCoord
)
const
{
return
ScreenPoint
(
0
aCoord
)
;
}
const
char
*
AxisY
:
:
Name
(
)
const
{
return
"
Y
"
;
}
}
}
