#
include
"
SimpleVelocityTracker
.
h
"
#
include
"
mozilla
/
ComputedTimingFunction
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
define
SVT_LOG
(
.
.
.
)
namespace
mozilla
{
namespace
layers
{
const
uint32_t
MIN_VELOCITY_SAMPLE_TIME_MS
=
5
;
extern
StaticAutoPtr
<
ComputedTimingFunction
>
gVelocityCurveFunction
;
SimpleVelocityTracker
:
:
SimpleVelocityTracker
(
Axis
*
aAxis
)
:
mAxis
(
aAxis
)
mVelocitySampleTimeMs
(
0
)
mVelocitySamplePos
(
0
)
{
}
void
SimpleVelocityTracker
:
:
StartTracking
(
ParentLayerCoord
aPos
uint32_t
aTimestampMs
)
{
Clear
(
)
;
mVelocitySampleTimeMs
=
aTimestampMs
;
mVelocitySamplePos
=
aPos
;
}
Maybe
<
float
>
SimpleVelocityTracker
:
:
AddPosition
(
ParentLayerCoord
aPos
uint32_t
aTimestampMs
)
{
if
(
aTimestampMs
<
=
mVelocitySampleTimeMs
+
MIN_VELOCITY_SAMPLE_TIME_MS
)
{
SVT_LOG
(
"
%
p
|
%
s
skipping
velocity
computation
for
small
time
delta
%
dms
\
n
"
mAxis
-
>
mAsyncPanZoomController
mAxis
-
>
Name
(
)
(
aTimestampMs
-
mVelocitySampleTimeMs
)
)
;
return
Nothing
(
)
;
}
float
newVelocity
=
(
float
)
(
mVelocitySamplePos
-
aPos
)
/
(
float
)
(
aTimestampMs
-
mVelocitySampleTimeMs
)
;
newVelocity
=
ApplyFlingCurveToVelocity
(
newVelocity
)
;
SVT_LOG
(
"
%
p
|
%
s
updating
velocity
to
%
f
with
touch
\
n
"
mAxis
-
>
mAsyncPanZoomController
mAxis
-
>
Name
(
)
newVelocity
)
;
mVelocitySampleTimeMs
=
aTimestampMs
;
mVelocitySamplePos
=
aPos
;
AddVelocityToQueue
(
aTimestampMs
newVelocity
)
;
return
Some
(
newVelocity
)
;
}
float
SimpleVelocityTracker
:
:
HandleDynamicToolbarMovement
(
uint32_t
aStartTimestampMs
uint32_t
aEndTimestampMs
ParentLayerCoord
aDelta
)
{
float
timeDelta
=
aEndTimestampMs
-
aStartTimestampMs
;
MOZ_ASSERT
(
timeDelta
!
=
0
)
;
float
velocity
=
-
aDelta
/
timeDelta
;
velocity
=
ApplyFlingCurveToVelocity
(
velocity
)
;
mVelocitySampleTimeMs
=
aEndTimestampMs
;
AddVelocityToQueue
(
aEndTimestampMs
velocity
)
;
return
velocity
;
}
Maybe
<
float
>
SimpleVelocityTracker
:
:
ComputeVelocity
(
uint32_t
aTimestampMs
)
{
float
velocity
=
0
;
int
count
=
0
;
for
(
const
auto
&
e
:
mVelocityQueue
)
{
uint32_t
timeDelta
=
(
aTimestampMs
-
e
.
first
)
;
if
(
timeDelta
<
StaticPrefs
:
:
apz_velocity_relevance_time_ms
(
)
)
{
count
+
+
;
velocity
+
=
e
.
second
;
}
}
mVelocityQueue
.
Clear
(
)
;
if
(
count
>
1
)
{
velocity
/
=
count
;
}
return
Some
(
velocity
)
;
}
void
SimpleVelocityTracker
:
:
Clear
(
)
{
mVelocityQueue
.
Clear
(
)
;
}
void
SimpleVelocityTracker
:
:
AddVelocityToQueue
(
uint32_t
aTimestampMs
float
aVelocity
)
{
mVelocityQueue
.
AppendElement
(
std
:
:
make_pair
(
aTimestampMs
aVelocity
)
)
;
if
(
mVelocityQueue
.
Length
(
)
>
StaticPrefs
:
:
apz_max_velocity_queue_size
(
)
)
{
mVelocityQueue
.
RemoveElementAt
(
0
)
;
}
}
float
SimpleVelocityTracker
:
:
ApplyFlingCurveToVelocity
(
float
aVelocity
)
const
{
float
newVelocity
=
aVelocity
;
if
(
StaticPrefs
:
:
apz_max_velocity_inches_per_ms
(
)
>
0
.
0f
)
{
bool
velocityIsNegative
=
(
newVelocity
<
0
)
;
newVelocity
=
fabs
(
newVelocity
)
;
float
maxVelocity
=
mAxis
-
>
ToLocalVelocity
(
StaticPrefs
:
:
apz_max_velocity_inches_per_ms
(
)
)
;
newVelocity
=
std
:
:
min
(
newVelocity
maxVelocity
)
;
if
(
StaticPrefs
:
:
apz_fling_curve_threshold_inches_per_ms
(
)
>
0
.
0f
&
&
StaticPrefs
:
:
apz_fling_curve_threshold_inches_per_ms
(
)
<
StaticPrefs
:
:
apz_max_velocity_inches_per_ms
(
)
)
{
float
curveThreshold
=
mAxis
-
>
ToLocalVelocity
(
StaticPrefs
:
:
apz_fling_curve_threshold_inches_per_ms
(
)
)
;
if
(
newVelocity
>
curveThreshold
)
{
float
scale
=
maxVelocity
-
curveThreshold
;
float
funcInput
=
(
newVelocity
-
curveThreshold
)
/
scale
;
float
funcOutput
=
gVelocityCurveFunction
-
>
GetValue
(
funcInput
ComputedTimingFunction
:
:
BeforeFlag
:
:
Unset
)
;
float
curvedVelocity
=
(
funcOutput
*
scale
)
+
curveThreshold
;
SVT_LOG
(
"
%
p
|
%
s
curving
up
velocity
from
%
f
to
%
f
\
n
"
mAxis
-
>
mAsyncPanZoomController
mAxis
-
>
Name
(
)
newVelocity
curvedVelocity
)
;
newVelocity
=
curvedVelocity
;
}
}
if
(
velocityIsNegative
)
{
newVelocity
=
-
newVelocity
;
}
}
return
newVelocity
;
}
}
}
