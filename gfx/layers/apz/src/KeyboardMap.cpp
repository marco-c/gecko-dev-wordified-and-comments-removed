#
include
"
mozilla
/
layers
/
KeyboardMap
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
namespace
mozilla
{
namespace
layers
{
KeyboardShortcut
:
:
KeyboardShortcut
(
)
:
mKeyCode
(
0
)
mCharCode
(
0
)
mModifiers
(
0
)
mModifiersMask
(
0
)
mEventType
(
KeyboardInput
:
:
KeyboardEventType
:
:
KEY_OTHER
)
mDispatchToContent
(
false
)
{
}
KeyboardShortcut
:
:
KeyboardShortcut
(
KeyboardInput
:
:
KeyboardEventType
aEventType
uint32_t
aKeyCode
uint32_t
aCharCode
Modifiers
aModifiers
Modifiers
aModifiersMask
const
KeyboardScrollAction
&
aAction
)
:
mAction
(
aAction
)
mKeyCode
(
aKeyCode
)
mCharCode
(
aCharCode
)
mModifiers
(
aModifiers
)
mModifiersMask
(
aModifiersMask
)
mEventType
(
aEventType
)
mDispatchToContent
(
false
)
{
}
KeyboardShortcut
:
:
KeyboardShortcut
(
KeyboardInput
:
:
KeyboardEventType
aEventType
uint32_t
aKeyCode
uint32_t
aCharCode
Modifiers
aModifiers
Modifiers
aModifiersMask
)
:
mKeyCode
(
aKeyCode
)
mCharCode
(
aCharCode
)
mModifiers
(
aModifiers
)
mModifiersMask
(
aModifiersMask
)
mEventType
(
aEventType
)
mDispatchToContent
(
true
)
{
}
void
KeyboardShortcut
:
:
AppendHardcodedShortcuts
(
nsTArray
<
KeyboardShortcut
>
&
aShortcuts
)
{
KeyboardShortcut
tab1
;
tab1
.
mDispatchToContent
=
true
;
tab1
.
mKeyCode
=
NS_VK_TAB
;
tab1
.
mCharCode
=
0
;
tab1
.
mModifiers
=
0
;
tab1
.
mModifiersMask
=
0
;
tab1
.
mEventType
=
KeyboardInput
:
:
KEY_PRESS
;
aShortcuts
.
AppendElement
(
tab1
)
;
KeyboardShortcut
tab2
;
tab2
.
mDispatchToContent
=
true
;
tab2
.
mKeyCode
=
NS_VK_F6
;
tab2
.
mCharCode
=
0
;
tab2
.
mModifiers
=
0
;
tab2
.
mModifiersMask
=
0
;
tab2
.
mEventType
=
KeyboardInput
:
:
KEY_PRESS
;
aShortcuts
.
AppendElement
(
tab2
)
;
}
bool
KeyboardShortcut
:
:
Matches
(
const
KeyboardInput
&
aInput
const
IgnoreModifierState
&
aIgnore
uint32_t
aOverrideCharCode
)
const
{
return
mEventType
=
=
aInput
.
mType
&
&
MatchesKey
(
aInput
aOverrideCharCode
)
&
&
MatchesModifiers
(
aInput
aIgnore
)
;
}
bool
KeyboardShortcut
:
:
MatchesKey
(
const
KeyboardInput
&
aInput
uint32_t
aOverrideCharCode
)
const
{
if
(
!
mCharCode
)
{
return
mKeyCode
=
=
aInput
.
mKeyCode
;
}
uint32_t
charCode
;
if
(
aOverrideCharCode
)
{
charCode
=
aOverrideCharCode
;
}
else
{
charCode
=
aInput
.
mCharCode
;
}
if
(
IS_IN_BMP
(
charCode
)
)
{
charCode
=
ToLowerCase
(
static_cast
<
char16_t
>
(
charCode
)
)
;
}
return
mCharCode
=
=
charCode
;
}
bool
KeyboardShortcut
:
:
MatchesModifiers
(
const
KeyboardInput
&
aInput
const
IgnoreModifierState
&
aIgnore
)
const
{
Modifiers
modifiersMask
=
mModifiersMask
;
if
(
aIgnore
.
mOS
)
{
modifiersMask
&
=
~
MODIFIER_OS
;
}
if
(
aIgnore
.
mShift
)
{
modifiersMask
&
=
~
MODIFIER_SHIFT
;
}
return
(
aInput
.
modifiers
&
modifiersMask
)
=
=
mModifiers
;
}
KeyboardMap
:
:
KeyboardMap
(
nsTArray
<
KeyboardShortcut
>
&
&
aShortcuts
)
:
mShortcuts
(
aShortcuts
)
{
}
KeyboardMap
:
:
KeyboardMap
(
)
=
default
;
Maybe
<
KeyboardShortcut
>
KeyboardMap
:
:
FindMatch
(
const
KeyboardInput
&
aEvent
)
const
{
if
(
aEvent
.
mShortcutCandidates
.
IsEmpty
(
)
)
{
return
FindMatchInternal
(
aEvent
IgnoreModifierState
(
)
)
;
}
for
(
auto
&
key
:
aEvent
.
mShortcutCandidates
)
{
IgnoreModifierState
ignoreModifierState
;
ignoreModifierState
.
mShift
=
key
.
mIgnoreShift
;
auto
match
=
FindMatchInternal
(
aEvent
ignoreModifierState
key
.
mCharCode
)
;
if
(
match
)
{
return
match
;
}
}
return
Nothing
(
)
;
}
Maybe
<
KeyboardShortcut
>
KeyboardMap
:
:
FindMatchInternal
(
const
KeyboardInput
&
aEvent
const
IgnoreModifierState
&
aIgnore
uint32_t
aOverrideCharCode
)
const
{
for
(
auto
&
shortcut
:
mShortcuts
)
{
if
(
shortcut
.
Matches
(
aEvent
aIgnore
aOverrideCharCode
)
)
{
return
Some
(
shortcut
)
;
}
}
#
ifdef
XP_WIN
if
(
!
aIgnore
.
mOS
&
&
(
aEvent
.
modifiers
&
MODIFIER_OS
)
)
{
IgnoreModifierState
ignoreModifierState
(
aIgnore
)
;
ignoreModifierState
.
mOS
=
true
;
return
FindMatchInternal
(
aEvent
ignoreModifierState
aOverrideCharCode
)
;
}
#
endif
return
Nothing
(
)
;
}
}
}
