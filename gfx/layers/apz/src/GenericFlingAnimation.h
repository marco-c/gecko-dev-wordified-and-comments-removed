#
ifndef
mozilla_layers_GenericFlingAnimation_h_
#
define
mozilla_layers_GenericFlingAnimation_h_
#
include
"
APZUtils
.
h
"
#
include
"
AsyncPanZoomAnimation
.
h
"
#
include
"
AsyncPanZoomController
.
h
"
#
include
"
FrameMetrics
.
h
"
#
include
"
Layers
.
h
"
#
include
"
Units
.
h
"
#
include
"
OverscrollHandoffState
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
define
FLING_LOG
(
.
.
.
)
namespace
mozilla
{
namespace
layers
{
class
GenericFlingAnimation
:
public
AsyncPanZoomAnimation
{
public
:
GenericFlingAnimation
(
AsyncPanZoomController
&
aApzc
PlatformSpecificStateBase
*
aPlatformSpecificState
const
RefPtr
<
const
OverscrollHandoffChain
>
&
aOverscrollHandoffChain
bool
aFlingIsHandedOff
const
RefPtr
<
const
AsyncPanZoomController
>
&
aScrolledApzc
)
:
mApzc
(
aApzc
)
mOverscrollHandoffChain
(
aOverscrollHandoffChain
)
mScrolledApzc
(
aScrolledApzc
)
{
MOZ_ASSERT
(
mOverscrollHandoffChain
)
;
TimeStamp
now
=
aApzc
.
GetFrameTime
(
)
;
if
(
!
mOverscrollHandoffChain
-
>
CanScrollInDirection
(
&
mApzc
ScrollDirection
:
:
HORIZONTAL
)
)
{
ReentrantMonitorAutoEnter
lock
(
mApzc
.
mMonitor
)
;
mApzc
.
mX
.
SetVelocity
(
0
)
;
}
if
(
!
mOverscrollHandoffChain
-
>
CanScrollInDirection
(
&
mApzc
ScrollDirection
:
:
VERTICAL
)
)
{
ReentrantMonitorAutoEnter
lock
(
mApzc
.
mMonitor
)
;
mApzc
.
mY
.
SetVelocity
(
0
)
;
}
ParentLayerPoint
velocity
=
mApzc
.
GetVelocityVector
(
)
;
bool
applyAcceleration
=
!
aFlingIsHandedOff
;
if
(
applyAcceleration
&
&
!
mApzc
.
mLastFlingTime
.
IsNull
(
)
&
&
(
now
-
mApzc
.
mLastFlingTime
)
.
ToMilliseconds
(
)
<
gfxPrefs
:
:
APZFlingAccelInterval
(
)
&
&
velocity
.
Length
(
)
>
=
gfxPrefs
:
:
APZFlingAccelMinVelocity
(
)
)
{
if
(
SameDirection
(
velocity
.
x
mApzc
.
mLastFlingVelocity
.
x
)
)
{
velocity
.
x
=
Accelerate
(
velocity
.
x
mApzc
.
mLastFlingVelocity
.
x
)
;
FLING_LOG
(
"
%
p
Applying
fling
x
-
acceleration
from
%
f
to
%
f
(
delta
%
f
)
\
n
"
&
mApzc
mApzc
.
mX
.
GetVelocity
(
)
velocity
.
x
mApzc
.
mLastFlingVelocity
.
x
)
;
mApzc
.
mX
.
SetVelocity
(
velocity
.
x
)
;
}
if
(
SameDirection
(
velocity
.
y
mApzc
.
mLastFlingVelocity
.
y
)
)
{
velocity
.
y
=
Accelerate
(
velocity
.
y
mApzc
.
mLastFlingVelocity
.
y
)
;
FLING_LOG
(
"
%
p
Applying
fling
y
-
acceleration
from
%
f
to
%
f
(
delta
%
f
)
\
n
"
&
mApzc
mApzc
.
mY
.
GetVelocity
(
)
velocity
.
y
mApzc
.
mLastFlingVelocity
.
y
)
;
mApzc
.
mY
.
SetVelocity
(
velocity
.
y
)
;
}
}
mApzc
.
mLastFlingTime
=
now
;
mApzc
.
mLastFlingVelocity
=
velocity
;
}
virtual
bool
DoSample
(
FrameMetrics
&
aFrameMetrics
const
TimeDuration
&
aDelta
)
override
{
float
friction
=
gfxPrefs
:
:
APZFlingFriction
(
)
;
float
threshold
=
gfxPrefs
:
:
APZFlingStoppedThreshold
(
)
;
bool
shouldContinueFlingX
=
mApzc
.
mX
.
FlingApplyFrictionOrCancel
(
aDelta
friction
threshold
)
shouldContinueFlingY
=
mApzc
.
mY
.
FlingApplyFrictionOrCancel
(
aDelta
friction
threshold
)
;
if
(
!
shouldContinueFlingX
&
&
!
shouldContinueFlingY
)
{
FLING_LOG
(
"
%
p
ending
fling
animation
.
overscrolled
=
%
d
\
n
"
&
mApzc
mApzc
.
IsOverscrolled
(
)
)
;
mDeferredTasks
.
AppendElement
(
NewRunnableMethod
<
AsyncPanZoomController
*
>
(
"
layers
:
:
OverscrollHandoffChain
:
:
SnapBackOverscrolledApzc
"
mOverscrollHandoffChain
.
get
(
)
&
OverscrollHandoffChain
:
:
SnapBackOverscrolledApzc
&
mApzc
)
)
;
return
false
;
}
ParentLayerPoint
velocity
=
mApzc
.
GetVelocityVector
(
)
;
ParentLayerPoint
offset
=
velocity
*
aDelta
.
ToMilliseconds
(
)
;
ParentLayerPoint
overscroll
;
ParentLayerPoint
adjustedOffset
;
mApzc
.
mX
.
AdjustDisplacement
(
offset
.
x
adjustedOffset
.
x
overscroll
.
x
)
;
mApzc
.
mY
.
AdjustDisplacement
(
offset
.
y
adjustedOffset
.
y
overscroll
.
y
)
;
aFrameMetrics
.
ScrollBy
(
adjustedOffset
/
aFrameMetrics
.
GetZoom
(
)
)
;
if
(
!
IsZero
(
overscroll
)
)
{
if
(
FuzzyEqualsAdditive
(
overscroll
.
x
0
.
0f
COORDINATE_EPSILON
)
)
{
velocity
.
x
=
0
;
}
else
if
(
FuzzyEqualsAdditive
(
overscroll
.
y
0
.
0f
COORDINATE_EPSILON
)
)
{
velocity
.
y
=
0
;
}
FLING_LOG
(
"
%
p
fling
went
into
overscroll
handing
off
with
velocity
%
s
\
n
"
&
mApzc
Stringify
(
velocity
)
.
c_str
(
)
)
;
mDeferredTasks
.
AppendElement
(
NewRunnableMethod
<
ParentLayerPoint
RefPtr
<
const
OverscrollHandoffChain
>
RefPtr
<
const
AsyncPanZoomController
>
>
(
"
layers
:
:
AsyncPanZoomController
:
:
HandleFlingOverscroll
"
&
mApzc
&
AsyncPanZoomController
:
:
HandleFlingOverscroll
velocity
mOverscrollHandoffChain
mScrolledApzc
)
)
;
return
!
IsZero
(
mApzc
.
GetVelocityVector
(
)
)
;
}
return
true
;
}
private
:
static
bool
SameDirection
(
float
aVelocity1
float
aVelocity2
)
{
return
(
aVelocity1
=
=
0
.
0f
)
|
|
(
aVelocity2
=
=
0
.
0f
)
|
|
(
IsNegative
(
aVelocity1
)
=
=
IsNegative
(
aVelocity2
)
)
;
}
static
float
Accelerate
(
float
aBase
float
aSupplemental
)
{
return
(
aBase
*
gfxPrefs
:
:
APZFlingAccelBaseMultiplier
(
)
)
+
(
aSupplemental
*
gfxPrefs
:
:
APZFlingAccelSupplementalMultiplier
(
)
)
;
}
AsyncPanZoomController
&
mApzc
;
RefPtr
<
const
OverscrollHandoffChain
>
mOverscrollHandoffChain
;
RefPtr
<
const
AsyncPanZoomController
>
mScrolledApzc
;
}
;
}
}
#
endif
