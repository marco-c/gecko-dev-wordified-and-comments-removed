#
ifndef
mozilla_layers_GenericFlingAnimation_h_
#
define
mozilla_layers_GenericFlingAnimation_h_
#
include
"
APZUtils
.
h
"
#
include
"
AsyncPanZoomAnimation
.
h
"
#
include
"
AsyncPanZoomController
.
h
"
#
include
"
FrameMetrics
.
h
"
#
include
"
Layers
.
h
"
#
include
"
LayersLogging
.
h
"
#
include
"
Units
.
h
"
#
include
"
OverscrollHandoffState
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsThreadUtils
.
h
"
static
mozilla
:
:
LazyLogModule
sApzFlgLog
(
"
apz
.
fling
"
)
;
#
define
FLING_LOG
(
.
.
.
)
MOZ_LOG
(
sApzFlgLog
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
namespace
mozilla
{
namespace
layers
{
template
<
typename
FlingPhysics
>
class
GenericFlingAnimation
:
public
AsyncPanZoomAnimation
public
FlingPhysics
{
public
:
GenericFlingAnimation
(
AsyncPanZoomController
&
aApzc
const
RefPtr
<
const
OverscrollHandoffChain
>
&
aOverscrollHandoffChain
bool
aFlingIsHandedOff
const
RefPtr
<
const
AsyncPanZoomController
>
&
aScrolledApzc
float
aPLPPI
)
:
mApzc
(
aApzc
)
mOverscrollHandoffChain
(
aOverscrollHandoffChain
)
mScrolledApzc
(
aScrolledApzc
)
{
MOZ_ASSERT
(
mOverscrollHandoffChain
)
;
SampleTime
now
=
aApzc
.
GetFrameTime
(
)
;
if
(
!
mOverscrollHandoffChain
-
>
CanScrollInDirection
(
&
mApzc
ScrollDirection
:
:
eHorizontal
)
)
{
RecursiveMutexAutoLock
lock
(
mApzc
.
mRecursiveMutex
)
;
mApzc
.
mX
.
SetVelocity
(
0
)
;
}
if
(
!
mOverscrollHandoffChain
-
>
CanScrollInDirection
(
&
mApzc
ScrollDirection
:
:
eVertical
)
)
{
RecursiveMutexAutoLock
lock
(
mApzc
.
mRecursiveMutex
)
;
mApzc
.
mY
.
SetVelocity
(
0
)
;
}
ParentLayerPoint
velocity
=
mApzc
.
GetVelocityVector
(
)
;
bool
applyAcceleration
=
!
aFlingIsHandedOff
;
if
(
applyAcceleration
&
&
!
mApzc
.
mLastFlingTime
.
IsNull
(
)
&
&
(
now
-
mApzc
.
mLastFlingTime
)
.
ToMilliseconds
(
)
<
StaticPrefs
:
:
apz_fling_accel_interval_ms
(
)
&
&
velocity
.
Length
(
)
>
=
StaticPrefs
:
:
apz_fling_accel_min_velocity
(
)
)
{
if
(
velocity
.
x
!
=
0
&
&
SameDirection
(
velocity
.
x
mApzc
.
mLastFlingVelocity
.
x
)
)
{
velocity
.
x
=
Accelerate
(
velocity
.
x
mApzc
.
mLastFlingVelocity
.
x
)
;
FLING_LOG
(
"
%
p
Applying
fling
x
-
acceleration
from
%
f
to
%
f
(
delta
%
f
)
\
n
"
&
mApzc
mApzc
.
mX
.
GetVelocity
(
)
velocity
.
x
mApzc
.
mLastFlingVelocity
.
x
)
;
mApzc
.
mX
.
SetVelocity
(
velocity
.
x
)
;
}
if
(
velocity
.
y
!
=
0
&
&
SameDirection
(
velocity
.
y
mApzc
.
mLastFlingVelocity
.
y
)
)
{
velocity
.
y
=
Accelerate
(
velocity
.
y
mApzc
.
mLastFlingVelocity
.
y
)
;
FLING_LOG
(
"
%
p
Applying
fling
y
-
acceleration
from
%
f
to
%
f
(
delta
%
f
)
\
n
"
&
mApzc
mApzc
.
mY
.
GetVelocity
(
)
velocity
.
y
mApzc
.
mLastFlingVelocity
.
y
)
;
mApzc
.
mY
.
SetVelocity
(
velocity
.
y
)
;
}
}
mApzc
.
mLastFlingTime
=
now
;
mApzc
.
mLastFlingVelocity
=
velocity
;
FlingPhysics
:
:
Init
(
mApzc
.
GetVelocityVector
(
)
aPLPPI
)
;
}
virtual
bool
DoSample
(
FrameMetrics
&
aFrameMetrics
const
TimeDuration
&
aDelta
)
override
{
ParentLayerPoint
velocity
;
ParentLayerPoint
offset
;
FlingPhysics
:
:
Sample
(
aDelta
&
velocity
&
offset
)
;
mApzc
.
SetVelocityVector
(
velocity
)
;
if
(
IsZero
(
velocity
)
)
{
FLING_LOG
(
"
%
p
ending
fling
animation
.
overscrolled
=
%
d
\
n
"
&
mApzc
mApzc
.
IsOverscrolled
(
)
)
;
mDeferredTasks
.
AppendElement
(
NewRunnableMethod
<
AsyncPanZoomController
*
>
(
"
layers
:
:
OverscrollHandoffChain
:
:
SnapBackOverscrolledApzc
"
mOverscrollHandoffChain
.
get
(
)
&
OverscrollHandoffChain
:
:
SnapBackOverscrolledApzc
&
mApzc
)
)
;
return
false
;
}
ParentLayerPoint
overscroll
;
ParentLayerPoint
adjustedOffset
;
mApzc
.
mX
.
AdjustDisplacement
(
offset
.
x
adjustedOffset
.
x
overscroll
.
x
)
;
mApzc
.
mY
.
AdjustDisplacement
(
offset
.
y
adjustedOffset
.
y
overscroll
.
y
)
;
mApzc
.
ScrollBy
(
adjustedOffset
/
aFrameMetrics
.
GetZoom
(
)
)
;
if
(
!
IsZero
(
overscroll
)
)
{
if
(
FuzzyEqualsAdditive
(
overscroll
.
x
0
.
0f
COORDINATE_EPSILON
)
)
{
velocity
.
x
=
0
;
}
else
if
(
FuzzyEqualsAdditive
(
overscroll
.
y
0
.
0f
COORDINATE_EPSILON
)
)
{
velocity
.
y
=
0
;
}
FLING_LOG
(
"
%
p
fling
went
into
overscroll
handing
off
with
velocity
%
s
\
n
"
&
mApzc
Stringify
(
velocity
)
.
c_str
(
)
)
;
mDeferredTasks
.
AppendElement
(
NewRunnableMethod
<
ParentLayerPoint
RefPtr
<
const
OverscrollHandoffChain
>
RefPtr
<
const
AsyncPanZoomController
>
>
(
"
layers
:
:
AsyncPanZoomController
:
:
HandleFlingOverscroll
"
&
mApzc
&
AsyncPanZoomController
:
:
HandleFlingOverscroll
velocity
mOverscrollHandoffChain
mScrolledApzc
)
)
;
return
!
IsZero
(
mApzc
.
GetVelocityVector
(
)
)
;
}
return
true
;
}
virtual
bool
HandleScrollOffsetUpdate
(
const
Maybe
<
CSSPoint
>
&
aRelativeDelta
)
override
{
return
true
;
}
private
:
static
bool
SameDirection
(
float
aVelocity1
float
aVelocity2
)
{
return
(
aVelocity1
=
=
0
.
0f
)
|
|
(
aVelocity2
=
=
0
.
0f
)
|
|
(
IsNegative
(
aVelocity1
)
=
=
IsNegative
(
aVelocity2
)
)
;
}
static
float
Accelerate
(
float
aBase
float
aSupplemental
)
{
return
(
aBase
*
StaticPrefs
:
:
apz_fling_accel_base_mult
(
)
)
+
(
aSupplemental
*
StaticPrefs
:
:
apz_fling_accel_supplemental_mult
(
)
)
;
}
AsyncPanZoomController
&
mApzc
;
RefPtr
<
const
OverscrollHandoffChain
>
mOverscrollHandoffChain
;
RefPtr
<
const
AsyncPanZoomController
>
mScrolledApzc
;
}
;
}
}
#
endif
