#
include
"
AsyncPanZoomController
.
h
"
#
include
<
math
.
h
>
#
include
<
stdint
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
algorithm
>
#
include
"
APZCTreeManager
.
h
"
#
include
"
AsyncPanZoomAnimation
.
h
"
#
include
"
AutoscrollAnimation
.
h
"
#
include
"
Axis
.
h
"
#
include
"
CheckerboardEvent
.
h
"
#
include
"
Compositor
.
h
"
#
include
"
FrameMetrics
.
h
"
#
include
"
GenericFlingAnimation
.
h
"
#
include
"
GestureEventListener
.
h
"
#
include
"
HitTestingTreeNode
.
h
"
#
include
"
InputData
.
h
"
#
include
"
InputBlockState
.
h
"
#
include
"
InputQueue
.
h
"
#
include
"
Overscroll
.
h
"
#
include
"
OverscrollHandoffState
.
h
"
#
include
"
Units
.
h
"
#
include
"
UnitTransforms
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
gfxTypes
.
h
"
#
include
"
LayersLogging
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
ComputedTimingFunction
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
RecursiveMutex
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
dom
/
CheckerboardReportService
.
h
"
#
include
"
mozilla
/
dom
/
Touch
.
h
"
#
include
"
mozilla
/
gfx
/
BasePoint
.
h
"
#
include
"
mozilla
/
gfx
/
BaseRect
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
ScaleFactor
.
h
"
#
include
"
mozilla
/
layers
/
APZThreadUtils
.
h
"
#
include
"
mozilla
/
layers
/
AsyncCompositionManager
.
h
"
#
include
"
mozilla
/
layers
/
AxisPhysicsModel
.
h
"
#
include
"
mozilla
/
layers
/
AxisPhysicsMSDModel
.
h
"
#
include
"
mozilla
/
layers
/
CompositorController
.
h
"
#
include
"
mozilla
/
layers
/
DirectionUtils
.
h
"
#
include
"
mozilla
/
layers
/
LayerTransactionParent
.
h
"
#
include
"
mozilla
/
layers
/
MetricsSharingController
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsIDOMWindowUtils
.
h
"
#
include
"
nsMathUtils
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsTimingFunction
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsViewportInfo
.
h
"
#
include
"
prsystem
.
h
"
#
include
"
SharedMemoryBasic
.
h
"
#
include
"
ScrollSnap
.
h
"
#
include
"
ScrollAnimationPhysics
.
h
"
#
include
"
WheelScrollAnimation
.
h
"
#
include
"
KeyboardScrollAnimation
.
h
"
#
if
defined
(
MOZ_WIDGET_ANDROID
)
#
include
"
AndroidAPZ
.
h
"
#
include
"
mozilla
/
layers
/
AndroidDynamicToolbarAnimator
.
h
"
#
endif
#
define
ENABLE_APZC_LOGGING
0
#
if
ENABLE_APZC_LOGGING
#
define
APZC_LOG
(
.
.
.
)
printf_stderr
(
"
APZC
:
"
__VA_ARGS__
)
#
define
APZC_LOG_FM
(
fm
prefix
.
.
.
)
\
{
std
:
:
stringstream
ss
;
\
ss
<
<
nsPrintfCString
(
prefix
__VA_ARGS__
)
.
get
(
)
;
\
AppendToString
(
ss
fm
"
:
"
"
"
true
)
;
\
APZC_LOG
(
"
%
s
\
n
"
ss
.
str
(
)
.
c_str
(
)
)
;
\
}
#
else
#
define
APZC_LOG
(
.
.
.
)
#
define
APZC_LOG_FM
(
fm
prefix
.
.
.
)
#
endif
namespace
mozilla
{
namespace
layers
{
typedef
mozilla
:
:
layers
:
:
AllowedTouchBehavior
AllowedTouchBehavior
;
typedef
GeckoContentController
:
:
APZStateChange
APZStateChange
;
typedef
GeckoContentController
:
:
TapType
TapType
;
typedef
mozilla
:
:
gfx
:
:
Point
Point
;
typedef
mozilla
:
:
gfx
:
:
Matrix4x4
Matrix4x4
;
using
mozilla
:
:
gfx
:
:
PointTyped
;
#
ifdef
MOZ_WIDGET_ANDROID
typedef
WidgetOverscrollEffect
OverscrollEffect
;
typedef
AndroidSpecificState
PlatformSpecificState
;
typedef
AndroidFlingAnimation
FlingAnimation
;
#
else
typedef
GenericOverscrollEffect
OverscrollEffect
;
typedef
PlatformSpecificStateBase
PlatformSpecificState
;
typedef
GenericFlingAnimation
FlingAnimation
;
#
endif
StaticAutoPtr
<
ComputedTimingFunction
>
gZoomAnimationFunction
;
StaticAutoPtr
<
ComputedTimingFunction
>
gVelocityCurveFunction
;
static
const
double
kDefaultEstimatedPaintDurationMs
=
50
;
static
bool
gIsHighMemSystem
=
false
;
static
bool
IsHighMemSystem
(
)
{
return
gIsHighMemSystem
;
}
static
bool
IsCloseToHorizontal
(
float
aAngle
float
aThreshold
)
{
return
(
aAngle
<
aThreshold
|
|
aAngle
>
(
M_PI
-
aThreshold
)
)
;
}
static
bool
IsCloseToVertical
(
float
aAngle
float
aThreshold
)
{
return
(
fabs
(
aAngle
-
(
M_PI
/
2
)
)
<
aThreshold
)
;
}
static
uint32_t
sAsyncPanZoomControllerCount
=
0
;
TimeStamp
AsyncPanZoomController
:
:
GetFrameTime
(
)
const
{
APZCTreeManager
*
treeManagerLocal
=
GetApzcTreeManager
(
)
;
return
treeManagerLocal
?
treeManagerLocal
-
>
GetFrameTime
(
)
:
TimeStamp
:
:
Now
(
)
;
}
class
MOZ_STACK_CLASS
StateChangeNotificationBlocker
{
public
:
explicit
StateChangeNotificationBlocker
(
AsyncPanZoomController
*
aApzc
)
:
mApzc
(
aApzc
)
{
RecursiveMutexAutoLock
lock
(
mApzc
-
>
mRecursiveMutex
)
;
mInitialState
=
mApzc
-
>
mState
;
mApzc
-
>
mNotificationBlockers
+
+
;
}
~
StateChangeNotificationBlocker
(
)
{
AsyncPanZoomController
:
:
PanZoomState
newState
;
{
RecursiveMutexAutoLock
lock
(
mApzc
-
>
mRecursiveMutex
)
;
mApzc
-
>
mNotificationBlockers
-
-
;
newState
=
mApzc
-
>
mState
;
}
mApzc
-
>
DispatchStateChangeNotification
(
mInitialState
newState
)
;
}
private
:
AsyncPanZoomController
*
mApzc
;
AsyncPanZoomController
:
:
PanZoomState
mInitialState
;
}
;
class
ZoomAnimation
:
public
AsyncPanZoomAnimation
{
public
:
ZoomAnimation
(
const
CSSPoint
&
aStartOffset
const
CSSToParentLayerScale2D
&
aStartZoom
const
CSSPoint
&
aEndOffset
const
CSSToParentLayerScale2D
&
aEndZoom
)
:
mTotalDuration
(
TimeDuration
:
:
FromMilliseconds
(
gfxPrefs
:
:
APZZoomAnimationDuration
(
)
)
)
mStartOffset
(
aStartOffset
)
mStartZoom
(
aStartZoom
)
mEndOffset
(
aEndOffset
)
mEndZoom
(
aEndZoom
)
{
}
virtual
bool
DoSample
(
FrameMetrics
&
aFrameMetrics
const
TimeDuration
&
aDelta
)
override
{
mDuration
+
=
aDelta
;
double
animPosition
=
mDuration
/
mTotalDuration
;
if
(
animPosition
>
=
1
.
0
)
{
aFrameMetrics
.
SetZoom
(
mEndZoom
)
;
aFrameMetrics
.
SetScrollOffset
(
mEndOffset
)
;
return
false
;
}
float
sampledPosition
=
gZoomAnimationFunction
-
>
GetValue
(
animPosition
ComputedTimingFunction
:
:
BeforeFlag
:
:
Unset
)
;
aFrameMetrics
.
SetZoom
(
CSSToParentLayerScale2D
(
1
/
(
sampledPosition
/
mEndZoom
.
xScale
+
(
1
-
sampledPosition
)
/
mStartZoom
.
xScale
)
1
/
(
sampledPosition
/
mEndZoom
.
yScale
+
(
1
-
sampledPosition
)
/
mStartZoom
.
yScale
)
)
)
;
aFrameMetrics
.
SetScrollOffset
(
CSSPoint
:
:
FromUnknownPoint
(
gfx
:
:
Point
(
mEndOffset
.
x
*
sampledPosition
+
mStartOffset
.
x
*
(
1
-
sampledPosition
)
mEndOffset
.
y
*
sampledPosition
+
mStartOffset
.
y
*
(
1
-
sampledPosition
)
)
)
)
;
return
true
;
}
virtual
bool
WantsRepaints
(
)
override
{
return
false
;
}
private
:
TimeDuration
mDuration
;
const
TimeDuration
mTotalDuration
;
CSSPoint
mStartOffset
;
CSSToParentLayerScale2D
mStartZoom
;
CSSPoint
mEndOffset
;
CSSToParentLayerScale2D
mEndZoom
;
}
;
class
SmoothScrollAnimation
:
public
AsyncPanZoomAnimation
{
public
:
SmoothScrollAnimation
(
AsyncPanZoomController
&
aApzc
const
nsPoint
&
aInitialPosition
const
nsPoint
&
aInitialVelocity
const
nsPoint
&
aDestination
double
aSpringConstant
double
aDampingRatio
)
:
mApzc
(
aApzc
)
mXAxisModel
(
aInitialPosition
.
x
aDestination
.
x
aInitialVelocity
.
x
aSpringConstant
aDampingRatio
)
mYAxisModel
(
aInitialPosition
.
y
aDestination
.
y
aInitialVelocity
.
y
aSpringConstant
aDampingRatio
)
{
}
bool
DoSample
(
FrameMetrics
&
aFrameMetrics
const
TimeDuration
&
aDelta
)
override
{
nsPoint
oneParentLayerPixel
=
CSSPoint
:
:
ToAppUnits
(
ParentLayerPoint
(
1
1
)
/
aFrameMetrics
.
GetZoom
(
)
)
;
if
(
mXAxisModel
.
IsFinished
(
oneParentLayerPixel
.
x
)
&
&
mYAxisModel
.
IsFinished
(
oneParentLayerPixel
.
y
)
)
{
aFrameMetrics
.
ClampAndSetScrollOffset
(
CSSPoint
:
:
FromAppUnits
(
nsPoint
(
mXAxisModel
.
GetDestination
(
)
mYAxisModel
.
GetDestination
(
)
)
)
)
;
return
false
;
}
mXAxisModel
.
Simulate
(
aDelta
)
;
mYAxisModel
.
Simulate
(
aDelta
)
;
CSSPoint
position
=
CSSPoint
:
:
FromAppUnits
(
nsPoint
(
mXAxisModel
.
GetPosition
(
)
mYAxisModel
.
GetPosition
(
)
)
)
;
CSSPoint
css_velocity
=
CSSPoint
:
:
FromAppUnits
(
nsPoint
(
mXAxisModel
.
GetVelocity
(
)
mYAxisModel
.
GetVelocity
(
)
)
)
;
ParentLayerPoint
velocity
=
ParentLayerPoint
(
css_velocity
.
x
css_velocity
.
y
)
/
1000
.
0f
;
if
(
mXAxisModel
.
IsFinished
(
oneParentLayerPixel
.
x
)
)
{
mApzc
.
mX
.
SetVelocity
(
0
)
;
}
else
{
mApzc
.
mX
.
SetVelocity
(
velocity
.
x
)
;
}
if
(
mYAxisModel
.
IsFinished
(
oneParentLayerPixel
.
y
)
)
{
mApzc
.
mY
.
SetVelocity
(
0
)
;
}
else
{
mApzc
.
mY
.
SetVelocity
(
velocity
.
y
)
;
}
CSSToParentLayerScale2D
zoom
=
aFrameMetrics
.
GetZoom
(
)
;
ParentLayerPoint
displacement
=
(
position
-
aFrameMetrics
.
GetScrollOffset
(
)
)
*
zoom
;
ParentLayerPoint
overscroll
;
ParentLayerPoint
adjustedOffset
;
mApzc
.
mX
.
AdjustDisplacement
(
displacement
.
x
adjustedOffset
.
x
overscroll
.
x
)
;
mApzc
.
mY
.
AdjustDisplacement
(
displacement
.
y
adjustedOffset
.
y
overscroll
.
y
)
;
aFrameMetrics
.
ScrollBy
(
adjustedOffset
/
zoom
)
;
if
(
!
IsZero
(
overscroll
)
)
{
if
(
FuzzyEqualsAdditive
(
overscroll
.
x
0
.
0f
COORDINATE_EPSILON
)
)
{
velocity
.
x
=
0
;
}
else
if
(
FuzzyEqualsAdditive
(
overscroll
.
y
0
.
0f
COORDINATE_EPSILON
)
)
{
velocity
.
y
=
0
;
}
mDeferredTasks
.
AppendElement
(
NewRunnableMethod
<
ParentLayerPoint
>
(
"
layers
:
:
AsyncPanZoomController
:
:
HandleSmoothScrollOverscroll
"
&
mApzc
&
AsyncPanZoomController
:
:
HandleSmoothScrollOverscroll
velocity
)
)
;
return
false
;
}
return
true
;
}
void
SetDestination
(
const
nsPoint
&
aNewDestination
)
{
mXAxisModel
.
SetDestination
(
static_cast
<
int32_t
>
(
aNewDestination
.
x
)
)
;
mYAxisModel
.
SetDestination
(
static_cast
<
int32_t
>
(
aNewDestination
.
y
)
)
;
}
CSSPoint
GetDestination
(
)
const
{
return
CSSPoint
:
:
FromAppUnits
(
nsPoint
(
mXAxisModel
.
GetDestination
(
)
mYAxisModel
.
GetDestination
(
)
)
)
;
}
SmoothScrollAnimation
*
AsSmoothScrollAnimation
(
)
override
{
return
this
;
}
private
:
AsyncPanZoomController
&
mApzc
;
AxisPhysicsMSDModel
mXAxisModel
mYAxisModel
;
}
;
void
AsyncPanZoomController
:
:
InitializeGlobalState
(
)
{
static
bool
sInitialized
=
false
;
if
(
sInitialized
)
return
;
sInitialized
=
true
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
gZoomAnimationFunction
=
new
ComputedTimingFunction
(
nsTimingFunction
(
NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE
)
)
;
ClearOnShutdown
(
&
gZoomAnimationFunction
)
;
gVelocityCurveFunction
=
new
ComputedTimingFunction
(
nsTimingFunction
(
gfxPrefs
:
:
APZCurveFunctionX1
(
)
gfxPrefs
:
:
APZCurveFunctionY1
(
)
gfxPrefs
:
:
APZCurveFunctionX2
(
)
gfxPrefs
:
:
APZCurveFunctionY2
(
)
)
)
;
ClearOnShutdown
(
&
gVelocityCurveFunction
)
;
uint64_t
sysmem
=
PR_GetPhysicalMemorySize
(
)
;
uint64_t
threshold
=
1LL
<
<
32
;
gIsHighMemSystem
=
sysmem
>
=
threshold
;
}
AsyncPanZoomController
:
:
AsyncPanZoomController
(
LayersId
aLayersId
APZCTreeManager
*
aTreeManager
const
RefPtr
<
InputQueue
>
&
aInputQueue
GeckoContentController
*
aGeckoContentController
GestureBehavior
aGestures
)
:
mLayersId
(
aLayersId
)
mGeckoContentController
(
aGeckoContentController
)
mRefPtrMonitor
(
"
RefPtrMonitor
"
)
mTreeManager
(
aTreeManager
)
mFrameMetrics
(
mScrollMetadata
.
GetMetrics
(
)
)
mRecursiveMutex
(
"
AsyncPanZoomController
"
)
mLastContentPaintMetrics
(
mLastContentPaintMetadata
.
GetMetrics
(
)
)
mX
(
this
)
mY
(
this
)
mPanDirRestricted
(
false
)
mPinchLocked
(
false
)
mZoomConstraints
(
false
false
mFrameMetrics
.
GetDevPixelsPerCSSPixel
(
)
*
kViewportMinScale
/
ParentLayerToScreenScale
(
1
)
mFrameMetrics
.
GetDevPixelsPerCSSPixel
(
)
*
kViewportMaxScale
/
ParentLayerToScreenScale
(
1
)
)
mLastSampleTime
(
GetFrameTime
(
)
)
mLastCheckerboardReport
(
GetFrameTime
(
)
)
mOverscrollEffect
(
MakeUnique
<
OverscrollEffect
>
(
*
this
)
)
mState
(
NOTHING
)
mNotificationBlockers
(
0
)
mInputQueue
(
aInputQueue
)
mPinchPaintTimerSet
(
false
)
mAPZCId
(
sAsyncPanZoomControllerCount
+
+
)
mSharedLock
(
nullptr
)
mAsyncTransformAppliedToContent
(
false
)
mTestHasAsyncKeyScrolled
(
false
)
mCheckerboardEventLock
(
"
APZCBELock
"
)
{
if
(
aGestures
=
=
USE_GESTURE_DETECTOR
)
{
mGestureEventListener
=
new
GestureEventListener
(
this
)
;
}
}
AsyncPanZoomController
:
:
~
AsyncPanZoomController
(
)
{
MOZ_ASSERT
(
IsDestroyed
(
)
)
;
}
PlatformSpecificStateBase
*
AsyncPanZoomController
:
:
GetPlatformSpecificState
(
)
{
if
(
!
mPlatformSpecificState
)
{
mPlatformSpecificState
=
MakeUnique
<
PlatformSpecificState
>
(
)
;
}
return
mPlatformSpecificState
.
get
(
)
;
}
already_AddRefed
<
GeckoContentController
>
AsyncPanZoomController
:
:
GetGeckoContentController
(
)
const
{
MonitorAutoLock
lock
(
mRefPtrMonitor
)
;
RefPtr
<
GeckoContentController
>
controller
=
mGeckoContentController
;
return
controller
.
forget
(
)
;
}
already_AddRefed
<
GestureEventListener
>
AsyncPanZoomController
:
:
GetGestureEventListener
(
)
const
{
MonitorAutoLock
lock
(
mRefPtrMonitor
)
;
RefPtr
<
GestureEventListener
>
listener
=
mGestureEventListener
;
return
listener
.
forget
(
)
;
}
const
RefPtr
<
InputQueue
>
&
AsyncPanZoomController
:
:
GetInputQueue
(
)
const
{
return
mInputQueue
;
}
void
AsyncPanZoomController
:
:
Destroy
(
)
{
AssertOnSamplerThread
(
)
;
CancelAnimation
(
CancelAnimationFlags
:
:
ScrollSnap
)
;
{
MonitorAutoLock
lock
(
mRefPtrMonitor
)
;
mGeckoContentController
=
nullptr
;
mGestureEventListener
=
nullptr
;
}
mParent
=
nullptr
;
mTreeManager
=
nullptr
;
if
(
mMetricsSharingController
&
&
mSharedFrameMetricsBuffer
)
{
Unused
<
<
mMetricsSharingController
-
>
StopSharingMetrics
(
mFrameMetrics
.
GetScrollId
(
)
mAPZCId
)
;
}
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
mSharedFrameMetricsBuffer
=
nullptr
;
delete
mSharedLock
;
mSharedLock
=
nullptr
;
}
}
bool
AsyncPanZoomController
:
:
IsDestroyed
(
)
const
{
return
mTreeManager
=
=
nullptr
;
}
float
AsyncPanZoomController
:
:
GetDPI
(
)
const
{
if
(
APZCTreeManager
*
localPtr
=
mTreeManager
)
{
return
localPtr
-
>
GetDPI
(
)
;
}
return
0
.
0
;
}
ScreenCoord
AsyncPanZoomController
:
:
GetTouchStartTolerance
(
)
const
{
return
(
gfxPrefs
:
:
APZTouchStartTolerance
(
)
*
GetDPI
(
)
)
;
}
ScreenCoord
AsyncPanZoomController
:
:
GetTouchMoveTolerance
(
)
const
{
return
(
gfxPrefs
:
:
APZTouchMoveTolerance
(
)
*
GetDPI
(
)
)
;
}
ScreenCoord
AsyncPanZoomController
:
:
GetSecondTapTolerance
(
)
const
{
return
(
gfxPrefs
:
:
APZSecondTapTolerance
(
)
*
GetDPI
(
)
)
;
}
AsyncPanZoomController
:
:
AxisLockMode
AsyncPanZoomController
:
:
GetAxisLockMode
(
)
{
return
static_cast
<
AxisLockMode
>
(
gfxPrefs
:
:
APZAxisLockMode
(
)
)
;
}
AsyncPanZoomController
:
:
PinchLockMode
AsyncPanZoomController
:
:
GetPinchLockMode
(
)
{
return
static_cast
<
PinchLockMode
>
(
gfxPrefs
:
:
APZPinchLockMode
(
)
)
;
}
bool
AsyncPanZoomController
:
:
ArePointerEventsConsumable
(
TouchBlockState
*
aBlock
uint32_t
aTouchPoints
)
{
if
(
aTouchPoints
=
=
0
)
{
return
false
;
}
bool
pannable
=
aBlock
-
>
GetOverscrollHandoffChain
(
)
-
>
CanBePanned
(
this
)
;
bool
zoomable
=
mZoomConstraints
.
mAllowZoom
;
pannable
&
=
(
aBlock
-
>
TouchActionAllowsPanningX
(
)
|
|
aBlock
-
>
TouchActionAllowsPanningY
(
)
)
;
zoomable
&
=
(
aBlock
-
>
TouchActionAllowsPinchZoom
(
)
)
;
bool
consumable
=
(
aTouchPoints
=
=
1
?
pannable
:
zoomable
)
;
if
(
!
consumable
)
{
return
false
;
}
return
true
;
}
nsEventStatus
AsyncPanZoomController
:
:
HandleDragEvent
(
const
MouseInput
&
aEvent
const
AsyncDragMetrics
&
aDragMetrics
CSSCoord
aInitialThumbPos
)
{
if
(
!
gfxPrefs
:
:
APZDragEnabled
(
)
)
{
return
nsEventStatus_eIgnore
;
}
if
(
!
GetApzcTreeManager
(
)
)
{
return
nsEventStatus_eConsumeNoDefault
;
}
if
(
aEvent
.
mType
=
=
MouseInput
:
:
MouseType
:
:
MOUSE_DOWN
)
{
SetState
(
SCROLLBAR_DRAG
)
;
}
if
(
aEvent
.
mType
=
=
MouseInput
:
:
MouseType
:
:
MOUSE_UP
)
{
SetState
(
NOTHING
)
;
ScrollSnap
(
)
;
}
if
(
aEvent
.
mType
!
=
MouseInput
:
:
MouseType
:
:
MOUSE_MOVE
)
{
return
nsEventStatus_eConsumeNoDefault
;
}
RefPtr
<
HitTestingTreeNode
>
node
=
GetApzcTreeManager
(
)
-
>
FindScrollThumbNode
(
aDragMetrics
)
;
if
(
!
node
)
{
return
nsEventStatus_eConsumeNoDefault
;
}
const
ScrollThumbData
&
thumbData
=
node
-
>
GetScrollThumbData
(
)
;
MOZ_ASSERT
(
thumbData
.
mDirection
.
isSome
(
)
)
;
ScrollDirection
direction
=
*
thumbData
.
mDirection
;
bool
isMouseAwayFromThumb
=
false
;
if
(
int
snapMultiplier
=
gfxPrefs
:
:
SliderSnapMultiplier
(
)
)
{
ParentLayerRect
thumbRect
=
(
node
-
>
GetTransform
(
)
*
AsyncTransformMatrix
(
)
)
.
TransformBounds
(
LayerRect
(
node
-
>
GetVisibleRegion
(
)
.
GetBounds
(
)
)
)
;
ScrollDirection
otherDirection
=
GetPerpendicularDirection
(
direction
)
;
ParentLayerCoord
distance
=
GetAxisStart
(
otherDirection
thumbRect
.
DistanceTo
(
aEvent
.
mLocalOrigin
)
)
;
ParentLayerCoord
thumbWidth
=
GetAxisLength
(
otherDirection
thumbRect
)
;
if
(
thumbWidth
>
0
&
&
thumbWidth
*
snapMultiplier
<
distance
)
{
isMouseAwayFromThumb
=
true
;
}
}
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
CSSCoord
thumbPosition
;
if
(
isMouseAwayFromThumb
)
{
thumbPosition
=
aInitialThumbPos
;
}
else
{
thumbPosition
=
ConvertScrollbarPoint
(
aEvent
.
mLocalOrigin
thumbData
)
-
aDragMetrics
.
mScrollbarDragOffset
;
}
CSSCoord
maxThumbPos
=
thumbData
.
mScrollTrackLength
;
maxThumbPos
-
=
thumbData
.
mThumbLength
;
float
scrollPercent
=
thumbPosition
/
maxThumbPos
;
CSSCoord
minScrollPosition
=
GetAxisStart
(
direction
mFrameMetrics
.
GetScrollableRect
(
)
.
TopLeft
(
)
)
;
CSSCoord
maxScrollPosition
=
GetAxisStart
(
direction
mFrameMetrics
.
GetScrollableRect
(
)
.
BottomRight
(
)
)
-
GetAxisLength
(
direction
mFrameMetrics
.
CalculateCompositedRectInCssPixels
(
)
)
;
CSSCoord
scrollPosition
=
minScrollPosition
+
(
scrollPercent
*
(
maxScrollPosition
-
minScrollPosition
)
)
;
scrollPosition
=
std
:
:
max
(
scrollPosition
minScrollPosition
)
;
scrollPosition
=
std
:
:
min
(
scrollPosition
maxScrollPosition
)
;
CSSPoint
scrollOffset
=
mFrameMetrics
.
GetScrollOffset
(
)
;
if
(
direction
=
=
ScrollDirection
:
:
eHorizontal
)
{
scrollOffset
.
x
=
scrollPosition
;
}
else
{
scrollOffset
.
y
=
scrollPosition
;
}
mFrameMetrics
.
SetScrollOffset
(
scrollOffset
)
;
ScheduleCompositeAndMaybeRepaint
(
)
;
UpdateSharedCompositorFrameMetrics
(
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
HandleInputEvent
(
const
InputData
&
aEvent
const
ScreenToParentLayerMatrix4x4
&
aTransformToApzc
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
nsEventStatus
rv
=
nsEventStatus_eIgnore
;
switch
(
aEvent
.
mInputType
)
{
case
MULTITOUCH_INPUT
:
{
MultiTouchInput
multiTouchInput
=
aEvent
.
AsMultiTouchInput
(
)
;
if
(
!
multiTouchInput
.
TransformToLocal
(
aTransformToApzc
)
)
{
return
rv
;
}
RefPtr
<
GestureEventListener
>
listener
=
GetGestureEventListener
(
)
;
if
(
listener
)
{
rv
=
listener
-
>
HandleInputEvent
(
multiTouchInput
)
;
if
(
rv
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
rv
;
}
}
switch
(
multiTouchInput
.
mType
)
{
case
MultiTouchInput
:
:
MULTITOUCH_START
:
rv
=
OnTouchStart
(
multiTouchInput
)
;
break
;
case
MultiTouchInput
:
:
MULTITOUCH_MOVE
:
rv
=
OnTouchMove
(
multiTouchInput
)
;
break
;
case
MultiTouchInput
:
:
MULTITOUCH_END
:
rv
=
OnTouchEnd
(
multiTouchInput
)
;
break
;
case
MultiTouchInput
:
:
MULTITOUCH_CANCEL
:
rv
=
OnTouchCancel
(
multiTouchInput
)
;
break
;
}
break
;
}
case
PANGESTURE_INPUT
:
{
PanGestureInput
panGestureInput
=
aEvent
.
AsPanGestureInput
(
)
;
if
(
!
panGestureInput
.
TransformToLocal
(
aTransformToApzc
)
)
{
return
rv
;
}
switch
(
panGestureInput
.
mType
)
{
case
PanGestureInput
:
:
PANGESTURE_MAYSTART
:
rv
=
OnPanMayBegin
(
panGestureInput
)
;
break
;
case
PanGestureInput
:
:
PANGESTURE_CANCELLED
:
rv
=
OnPanCancelled
(
panGestureInput
)
;
break
;
case
PanGestureInput
:
:
PANGESTURE_START
:
rv
=
OnPanBegin
(
panGestureInput
)
;
break
;
case
PanGestureInput
:
:
PANGESTURE_PAN
:
rv
=
OnPan
(
panGestureInput
true
)
;
break
;
case
PanGestureInput
:
:
PANGESTURE_END
:
rv
=
OnPanEnd
(
panGestureInput
)
;
break
;
case
PanGestureInput
:
:
PANGESTURE_MOMENTUMSTART
:
rv
=
OnPanMomentumStart
(
panGestureInput
)
;
break
;
case
PanGestureInput
:
:
PANGESTURE_MOMENTUMPAN
:
rv
=
OnPan
(
panGestureInput
false
)
;
break
;
case
PanGestureInput
:
:
PANGESTURE_MOMENTUMEND
:
rv
=
OnPanMomentumEnd
(
panGestureInput
)
;
break
;
}
break
;
}
case
MOUSE_INPUT
:
{
MouseInput
mouseInput
=
aEvent
.
AsMouseInput
(
)
;
if
(
!
mouseInput
.
TransformToLocal
(
aTransformToApzc
)
)
{
return
rv
;
}
break
;
}
case
SCROLLWHEEL_INPUT
:
{
ScrollWheelInput
scrollInput
=
aEvent
.
AsScrollWheelInput
(
)
;
if
(
!
scrollInput
.
TransformToLocal
(
aTransformToApzc
)
)
{
return
rv
;
}
rv
=
OnScrollWheel
(
scrollInput
)
;
break
;
}
case
PINCHGESTURE_INPUT
:
{
PinchGestureInput
pinchInput
=
aEvent
.
AsPinchGestureInput
(
)
;
if
(
!
pinchInput
.
TransformToLocal
(
aTransformToApzc
)
)
{
return
rv
;
}
rv
=
HandleGestureEvent
(
pinchInput
)
;
break
;
}
case
TAPGESTURE_INPUT
:
{
TapGestureInput
tapInput
=
aEvent
.
AsTapGestureInput
(
)
;
if
(
!
tapInput
.
TransformToLocal
(
aTransformToApzc
)
)
{
return
rv
;
}
rv
=
HandleGestureEvent
(
tapInput
)
;
break
;
}
case
KEYBOARD_INPUT
:
{
const
KeyboardInput
&
keyInput
=
aEvent
.
AsKeyboardInput
(
)
;
rv
=
OnKeyboard
(
keyInput
)
;
break
;
}
}
return
rv
;
}
nsEventStatus
AsyncPanZoomController
:
:
HandleGestureEvent
(
const
InputData
&
aEvent
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
nsEventStatus
rv
=
nsEventStatus_eIgnore
;
switch
(
aEvent
.
mInputType
)
{
case
PINCHGESTURE_INPUT
:
{
const
PinchGestureInput
&
pinchGestureInput
=
aEvent
.
AsPinchGestureInput
(
)
;
switch
(
pinchGestureInput
.
mType
)
{
case
PinchGestureInput
:
:
PINCHGESTURE_START
:
rv
=
OnScaleBegin
(
pinchGestureInput
)
;
break
;
case
PinchGestureInput
:
:
PINCHGESTURE_SCALE
:
rv
=
OnScale
(
pinchGestureInput
)
;
break
;
case
PinchGestureInput
:
:
PINCHGESTURE_END
:
rv
=
OnScaleEnd
(
pinchGestureInput
)
;
break
;
}
break
;
}
case
TAPGESTURE_INPUT
:
{
const
TapGestureInput
&
tapGestureInput
=
aEvent
.
AsTapGestureInput
(
)
;
switch
(
tapGestureInput
.
mType
)
{
case
TapGestureInput
:
:
TAPGESTURE_LONG
:
rv
=
OnLongPress
(
tapGestureInput
)
;
break
;
case
TapGestureInput
:
:
TAPGESTURE_LONG_UP
:
rv
=
OnLongPressUp
(
tapGestureInput
)
;
break
;
case
TapGestureInput
:
:
TAPGESTURE_UP
:
rv
=
OnSingleTapUp
(
tapGestureInput
)
;
break
;
case
TapGestureInput
:
:
TAPGESTURE_CONFIRMED
:
rv
=
OnSingleTapConfirmed
(
tapGestureInput
)
;
break
;
case
TapGestureInput
:
:
TAPGESTURE_DOUBLE
:
rv
=
OnDoubleTap
(
tapGestureInput
)
;
break
;
case
TapGestureInput
:
:
TAPGESTURE_SECOND
:
rv
=
OnSecondTap
(
tapGestureInput
)
;
break
;
case
TapGestureInput
:
:
TAPGESTURE_CANCEL
:
rv
=
OnCancelTap
(
tapGestureInput
)
;
break
;
}
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unhandled
input
event
"
)
;
break
;
}
return
rv
;
}
void
AsyncPanZoomController
:
:
HandleTouchVelocity
(
uint32_t
aTimesampMs
float
aSpeedY
)
{
mY
.
HandleTouchVelocity
(
aTimesampMs
aSpeedY
)
;
}
void
AsyncPanZoomController
:
:
StartAutoscroll
(
const
ScreenPoint
&
aPoint
)
{
CancelAnimation
(
)
;
SetState
(
AUTOSCROLL
)
;
StartAnimation
(
new
AutoscrollAnimation
(
*
this
aPoint
)
)
;
}
void
AsyncPanZoomController
:
:
StopAutoscroll
(
)
{
if
(
mState
=
=
AUTOSCROLL
)
{
CancelAnimation
(
TriggeredExternally
)
;
}
}
nsEventStatus
AsyncPanZoomController
:
:
OnTouchStart
(
const
MultiTouchInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
touch
-
start
in
state
%
d
\
n
"
this
mState
)
;
mPanDirRestricted
=
false
;
ParentLayerPoint
point
=
GetFirstTouchPoint
(
aEvent
)
;
switch
(
mState
)
{
case
FLING
:
case
ANIMATING_ZOOM
:
case
SMOOTH_SCROLL
:
case
OVERSCROLL_ANIMATION
:
case
WHEEL_SCROLL
:
case
KEYBOARD_SCROLL
:
case
PAN_MOMENTUM
:
case
AUTOSCROLL
:
MOZ_ASSERT
(
GetCurrentTouchBlock
(
)
)
;
GetCurrentTouchBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
-
>
CancelAnimations
(
ExcludeOverscroll
)
;
MOZ_FALLTHROUGH
;
case
SCROLLBAR_DRAG
:
case
NOTHING
:
{
mX
.
StartTouch
(
point
.
x
aEvent
.
mTime
)
;
mY
.
StartTouch
(
point
.
y
aEvent
.
mTime
)
;
if
(
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
)
{
MOZ_ASSERT
(
GetCurrentTouchBlock
(
)
)
;
controller
-
>
NotifyAPZStateChange
(
GetGuid
(
)
APZStateChange
:
:
eStartTouch
GetCurrentTouchBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
-
>
CanBePanned
(
this
)
)
;
}
SetState
(
TOUCHING
)
;
break
;
}
case
TOUCHING
:
case
PANNING
:
case
PANNING_LOCKED_X
:
case
PANNING_LOCKED_Y
:
case
PINCHING
:
NS_WARNING
(
"
Received
impossible
touch
in
OnTouchStart
"
)
;
break
;
}
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnTouchMove
(
const
MultiTouchInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
touch
-
move
in
state
%
d
\
n
"
this
mState
)
;
switch
(
mState
)
{
case
FLING
:
case
SMOOTH_SCROLL
:
case
NOTHING
:
case
ANIMATING_ZOOM
:
return
nsEventStatus_eIgnore
;
case
TOUCHING
:
{
ScreenCoord
panThreshold
=
GetTouchStartTolerance
(
)
;
UpdateWithTouchAtDevicePoint
(
aEvent
)
;
if
(
PanDistance
(
)
<
panThreshold
)
{
return
nsEventStatus_eIgnore
;
}
ParentLayerPoint
touchPoint
=
GetFirstTouchPoint
(
aEvent
)
;
MOZ_ASSERT
(
GetCurrentTouchBlock
(
)
)
;
if
(
gfxPrefs
:
:
TouchActionEnabled
(
)
&
&
GetCurrentTouchBlock
(
)
-
>
TouchActionAllowsPanningXY
(
)
)
{
StartPanning
(
touchPoint
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
return
StartPanning
(
touchPoint
)
;
}
case
PANNING
:
case
PANNING_LOCKED_X
:
case
PANNING_LOCKED_Y
:
case
PAN_MOMENTUM
:
TrackTouch
(
aEvent
)
;
return
nsEventStatus_eConsumeNoDefault
;
case
PINCHING
:
NS_WARNING
(
"
Gesture
listener
should
have
handled
pinching
in
OnTouchMove
.
"
)
;
return
nsEventStatus_eIgnore
;
case
WHEEL_SCROLL
:
case
KEYBOARD_SCROLL
:
case
OVERSCROLL_ANIMATION
:
case
AUTOSCROLL
:
case
SCROLLBAR_DRAG
:
NS_WARNING
(
"
Received
impossible
touch
in
OnTouchMove
"
)
;
break
;
}
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnTouchEnd
(
const
MultiTouchInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
touch
-
end
in
state
%
d
\
n
"
this
mState
)
;
OnTouchEndOrCancel
(
)
;
if
(
mState
!
=
NOTHING
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
}
switch
(
mState
)
{
case
FLING
:
NS_WARNING
(
"
Received
impossible
touch
end
in
OnTouchEnd
.
"
)
;
MOZ_FALLTHROUGH
;
case
ANIMATING_ZOOM
:
case
SMOOTH_SCROLL
:
case
NOTHING
:
return
nsEventStatus_eIgnore
;
case
TOUCHING
:
mX
.
SetVelocity
(
0
)
;
mY
.
SetVelocity
(
0
)
;
MOZ_ASSERT
(
GetCurrentTouchBlock
(
)
)
;
APZC_LOG
(
"
%
p
still
has
%
u
touch
points
active
\
n
"
this
GetCurrentTouchBlock
(
)
-
>
GetActiveTouchCount
(
)
)
;
if
(
GetCurrentTouchBlock
(
)
-
>
GetActiveTouchCount
(
)
=
=
0
)
{
GetCurrentTouchBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
-
>
SnapBackOverscrolledApzc
(
this
)
;
if
(
mState
!
=
OVERSCROLL_ANIMATION
)
{
SetState
(
NOTHING
)
;
}
}
return
nsEventStatus_eIgnore
;
case
PANNING
:
case
PANNING_LOCKED_X
:
case
PANNING_LOCKED_Y
:
case
PAN_MOMENTUM
:
{
MOZ_ASSERT
(
GetCurrentTouchBlock
(
)
)
;
mX
.
EndTouch
(
aEvent
.
mTime
)
;
mY
.
EndTouch
(
aEvent
.
mTime
)
;
return
HandleEndOfPan
(
)
;
}
case
PINCHING
:
SetState
(
NOTHING
)
;
NS_WARNING
(
"
Gesture
listener
should
have
handled
pinching
in
OnTouchEnd
.
"
)
;
return
nsEventStatus_eIgnore
;
case
WHEEL_SCROLL
:
case
KEYBOARD_SCROLL
:
case
OVERSCROLL_ANIMATION
:
case
AUTOSCROLL
:
case
SCROLLBAR_DRAG
:
NS_WARNING
(
"
Received
impossible
touch
in
OnTouchEnd
"
)
;
break
;
}
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnTouchCancel
(
const
MultiTouchInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
touch
-
cancel
in
state
%
d
\
n
"
this
mState
)
;
OnTouchEndOrCancel
(
)
;
CancelAnimationAndGestureState
(
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnScaleBegin
(
const
PinchGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
scale
-
begin
in
state
%
d
\
n
"
this
mState
)
;
mPinchLocked
=
false
;
mPinchPaintTimerSet
=
false
;
if
(
HasReadyTouchBlock
(
)
&
&
!
GetCurrentTouchBlock
(
)
-
>
TouchActionAllowsPinchZoom
(
)
)
{
return
nsEventStatus_eIgnore
;
}
if
(
!
mZoomConstraints
.
mAllowZoom
)
{
mX
.
StartTouch
(
aEvent
.
mLocalFocusPoint
.
x
aEvent
.
mTime
)
;
mY
.
StartTouch
(
aEvent
.
mLocalFocusPoint
.
y
aEvent
.
mTime
)
;
}
if
(
!
gfxPrefs
:
:
APZAllowZooming
(
)
)
{
if
(
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
)
{
controller
-
>
NotifyPinchGesture
(
aEvent
.
mType
GetGuid
(
)
0
aEvent
.
modifiers
)
;
}
}
SetState
(
PINCHING
)
;
mX
.
SetVelocity
(
0
)
;
mY
.
SetVelocity
(
0
)
;
mLastZoomFocus
=
aEvent
.
mLocalFocusPoint
-
mFrameMetrics
.
GetCompositionBounds
(
)
.
TopLeft
(
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnScale
(
const
PinchGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
scale
in
state
%
d
\
n
"
this
mState
)
;
if
(
HasReadyTouchBlock
(
)
&
&
!
GetCurrentTouchBlock
(
)
-
>
TouchActionAllowsPinchZoom
(
)
)
{
return
nsEventStatus_eIgnore
;
}
if
(
mState
!
=
PINCHING
)
{
return
nsEventStatus_eConsumeNoDefault
;
}
ParentLayerCoord
spanDistance
=
fabsf
(
aEvent
.
mPreviousSpan
-
aEvent
.
mCurrentSpan
)
;
ParentLayerPoint
focusPoint
focusChange
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
focusPoint
=
aEvent
.
mLocalFocusPoint
-
mFrameMetrics
.
GetCompositionBounds
(
)
.
TopLeft
(
)
;
focusChange
=
mLastZoomFocus
-
focusPoint
;
mLastZoomFocus
=
focusPoint
;
}
HandlePinchLocking
(
ToScreenCoordinates
(
ParentLayerPoint
(
0
spanDistance
)
focusPoint
)
.
Length
(
)
ToScreenCoordinates
(
focusChange
focusPoint
)
)
;
bool
allowZoom
=
mZoomConstraints
.
mAllowZoom
&
&
!
mPinchLocked
;
if
(
!
allowZoom
)
{
mX
.
UpdateWithTouchAtDevicePoint
(
aEvent
.
mLocalFocusPoint
.
x
0
aEvent
.
mTime
)
;
mY
.
UpdateWithTouchAtDevicePoint
(
aEvent
.
mLocalFocusPoint
.
y
0
aEvent
.
mTime
)
;
}
if
(
!
gfxPrefs
:
:
APZAllowZooming
(
)
)
{
if
(
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
)
{
controller
-
>
NotifyPinchGesture
(
aEvent
.
mType
GetGuid
(
)
ViewAs
<
LayoutDevicePixel
>
(
aEvent
.
mCurrentSpan
-
aEvent
.
mPreviousSpan
PixelCastJustification
:
:
LayoutDeviceIsParentLayerForRCDRSF
)
aEvent
.
modifiers
)
;
}
}
MOZ_ASSERT
(
mFrameMetrics
.
IsRootContent
(
)
)
;
MOZ_ASSERT
(
mFrameMetrics
.
GetZoom
(
)
.
AreScalesSame
(
)
)
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
CSSToParentLayerScale
userZoom
=
mFrameMetrics
.
GetZoom
(
)
.
ToScaleFactor
(
)
;
CSSPoint
cssFocusPoint
=
focusPoint
/
mFrameMetrics
.
GetZoom
(
)
;
focusChange
.
x
-
=
mX
.
DisplacementWillOverscrollAmount
(
focusChange
.
x
)
;
focusChange
.
y
-
=
mY
.
DisplacementWillOverscrollAmount
(
focusChange
.
y
)
;
ScrollBy
(
focusChange
/
userZoom
)
;
float
prevSpan
=
aEvent
.
mPreviousSpan
;
if
(
fabsf
(
prevSpan
)
<
=
EPSILON
|
|
fabsf
(
aEvent
.
mCurrentSpan
)
<
=
EPSILON
)
{
ScheduleCompositeAndMaybeRepaint
(
)
;
UpdateSharedCompositorFrameMetrics
(
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
float
spanRatio
=
aEvent
.
mCurrentSpan
/
aEvent
.
mPreviousSpan
;
CSSPoint
neededDisplacement
;
CSSToParentLayerScale
realMinZoom
=
mZoomConstraints
.
mMinZoom
;
CSSToParentLayerScale
realMaxZoom
=
mZoomConstraints
.
mMaxZoom
;
realMinZoom
.
scale
=
std
:
:
max
(
realMinZoom
.
scale
mFrameMetrics
.
GetCompositionBounds
(
)
.
Width
(
)
/
mFrameMetrics
.
GetScrollableRect
(
)
.
Width
(
)
)
;
realMinZoom
.
scale
=
std
:
:
max
(
realMinZoom
.
scale
mFrameMetrics
.
GetCompositionBounds
(
)
.
Height
(
)
/
mFrameMetrics
.
GetScrollableRect
(
)
.
Height
(
)
)
;
if
(
realMaxZoom
<
realMinZoom
)
{
realMaxZoom
=
realMinZoom
;
}
bool
doScale
=
allowZoom
&
&
(
(
spanRatio
>
1
.
0
&
&
userZoom
<
realMaxZoom
)
|
|
(
spanRatio
<
1
.
0
&
&
userZoom
>
realMinZoom
)
)
;
if
(
doScale
)
{
spanRatio
=
clamped
(
spanRatio
realMinZoom
.
scale
/
userZoom
.
scale
realMaxZoom
.
scale
/
userZoom
.
scale
)
;
neededDisplacement
.
x
=
-
mX
.
ScaleWillOverscrollAmount
(
spanRatio
cssFocusPoint
.
x
)
;
neededDisplacement
.
y
=
-
mY
.
ScaleWillOverscrollAmount
(
spanRatio
cssFocusPoint
.
y
)
;
ScaleWithFocus
(
spanRatio
cssFocusPoint
)
;
if
(
neededDisplacement
!
=
CSSPoint
(
)
)
{
ScrollBy
(
neededDisplacement
)
;
}
if
(
!
mPinchPaintTimerSet
)
{
const
int
delay
=
gfxPrefs
:
:
APZScaleRepaintDelay
(
)
;
if
(
delay
>
=
0
)
{
if
(
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
)
{
mPinchPaintTimerSet
=
true
;
controller
-
>
PostDelayedTask
(
NewRunnableMethod
(
"
layers
:
:
AsyncPanZoomController
:
:
"
"
DoDelayedRequestContentRepaint
"
this
&
AsyncPanZoomController
:
:
DoDelayedRequestContentRepaint
)
delay
)
;
}
}
}
UpdateSharedCompositorFrameMetrics
(
)
;
}
else
{
RequestContentRepaint
(
)
;
}
ScheduleComposite
(
)
;
}
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnScaleEnd
(
const
PinchGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
scale
-
end
in
state
%
d
\
n
"
this
mState
)
;
mPinchPaintTimerSet
=
false
;
if
(
HasReadyTouchBlock
(
)
&
&
!
GetCurrentTouchBlock
(
)
-
>
TouchActionAllowsPinchZoom
(
)
)
{
return
nsEventStatus_eIgnore
;
}
if
(
!
gfxPrefs
:
:
APZAllowZooming
(
)
)
{
if
(
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
)
{
controller
-
>
NotifyPinchGesture
(
aEvent
.
mType
GetGuid
(
)
0
aEvent
.
modifiers
)
;
}
}
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
ScheduleComposite
(
)
;
RequestContentRepaint
(
)
;
UpdateSharedCompositorFrameMetrics
(
)
;
}
if
(
aEvent
.
mLocalFocusPoint
.
x
!
=
-
1
&
&
aEvent
.
mLocalFocusPoint
.
y
!
=
-
1
)
{
if
(
mZoomConstraints
.
mAllowZoom
)
{
mPanDirRestricted
=
false
;
mX
.
StartTouch
(
aEvent
.
mLocalFocusPoint
.
x
aEvent
.
mTime
)
;
mY
.
StartTouch
(
aEvent
.
mLocalFocusPoint
.
y
aEvent
.
mTime
)
;
SetState
(
TOUCHING
)
;
}
else
{
StartPanning
(
aEvent
.
mLocalFocusPoint
)
;
}
}
else
{
StateChangeNotificationBlocker
blocker
(
this
)
;
SetState
(
NOTHING
)
;
if
(
mZoomConstraints
.
mAllowZoom
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
HasReadyTouchBlock
(
)
)
{
GetCurrentTouchBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
-
>
ClearOverscroll
(
)
;
}
else
{
ClearOverscroll
(
)
;
}
ScrollSnap
(
)
;
}
else
{
mX
.
EndTouch
(
aEvent
.
mTime
)
;
mY
.
EndTouch
(
aEvent
.
mTime
)
;
if
(
mState
=
=
PINCHING
)
{
if
(
HasReadyTouchBlock
(
)
)
{
return
HandleEndOfPan
(
)
;
}
}
}
}
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
HandleEndOfPan
(
)
{
MOZ_ASSERT
(
GetCurrentTouchBlock
(
)
)
;
GetCurrentTouchBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
-
>
FlushRepaints
(
)
;
ParentLayerPoint
flingVelocity
=
GetVelocityVector
(
)
;
mX
.
SetVelocity
(
0
)
;
mY
.
SetVelocity
(
0
)
;
StateChangeNotificationBlocker
blocker
(
this
)
;
SetState
(
NOTHING
)
;
APZC_LOG
(
"
%
p
starting
a
fling
animation
if
%
f
>
=
%
f
\
n
"
this
flingVelocity
.
Length
(
)
.
value
gfxPrefs
:
:
APZFlingMinVelocityThreshold
(
)
)
;
if
(
flingVelocity
.
Length
(
)
<
gfxPrefs
:
:
APZFlingMinVelocityThreshold
(
)
)
{
GetCurrentTouchBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
-
>
SnapBackOverscrolledApzc
(
this
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
if
(
APZCTreeManager
*
treeManagerLocal
=
GetApzcTreeManager
(
)
)
{
const
FlingHandoffState
handoffState
{
flingVelocity
GetCurrentTouchBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
false
GetCurrentTouchBlock
(
)
-
>
GetScrolledApzc
(
)
}
;
treeManagerLocal
-
>
DispatchFling
(
this
handoffState
)
;
}
return
nsEventStatus_eConsumeNoDefault
;
}
bool
AsyncPanZoomController
:
:
ConvertToGecko
(
const
ScreenIntPoint
&
aPoint
LayoutDevicePoint
*
aOut
)
{
if
(
APZCTreeManager
*
treeManagerLocal
=
GetApzcTreeManager
(
)
)
{
ScreenToScreenMatrix4x4
transformScreenToGecko
=
treeManagerLocal
-
>
GetScreenToApzcTransform
(
this
)
*
treeManagerLocal
-
>
GetApzcToGeckoTransform
(
this
)
;
Maybe
<
ScreenIntPoint
>
layoutPoint
=
UntransformBy
(
transformScreenToGecko
aPoint
)
;
if
(
!
layoutPoint
)
{
return
false
;
}
*
aOut
=
LayoutDevicePoint
(
ViewAs
<
LayoutDevicePixel
>
(
*
layoutPoint
PixelCastJustification
:
:
LayoutDeviceIsScreenForUntransformedEvent
)
)
;
return
true
;
}
return
false
;
}
CSSCoord
AsyncPanZoomController
:
:
ConvertScrollbarPoint
(
const
ParentLayerPoint
&
aScrollbarPoint
const
ScrollThumbData
&
aThumbData
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
CSSPoint
scrollbarPoint
=
aScrollbarPoint
/
mFrameMetrics
.
GetZoom
(
)
;
scrollbarPoint
=
scrollbarPoint
*
mFrameMetrics
.
GetPresShellResolution
(
)
;
CSSRect
cssCompositionBound
=
mFrameMetrics
.
CalculateCompositedRectInCssPixels
(
)
;
return
GetAxisStart
(
*
aThumbData
.
mDirection
scrollbarPoint
)
-
GetAxisStart
(
*
aThumbData
.
mDirection
cssCompositionBound
)
-
aThumbData
.
mScrollTrackStart
;
}
static
bool
AllowsScrollingMoreThanOnePage
(
double
aMultiplier
)
{
const
int32_t
kMinAllowPageScroll
=
EventStateManager
:
:
MIN_MULTIPLIER_VALUE_ALLOWING_OVER_ONE_PAGE_SCROLL
;
return
Abs
(
aMultiplier
)
>
=
kMinAllowPageScroll
;
}
ParentLayerPoint
AsyncPanZoomController
:
:
GetScrollWheelDelta
(
const
ScrollWheelInput
&
aEvent
)
const
{
ParentLayerSize
scrollAmount
;
ParentLayerSize
pageScrollSize
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
LayoutDeviceIntSize
scrollAmountLD
=
mScrollMetadata
.
GetLineScrollAmount
(
)
;
LayoutDeviceIntSize
pageScrollSizeLD
=
mScrollMetadata
.
GetPageScrollAmount
(
)
;
scrollAmount
=
scrollAmountLD
/
mFrameMetrics
.
GetDevPixelsPerCSSPixel
(
)
*
mFrameMetrics
.
GetZoom
(
)
;
pageScrollSize
=
pageScrollSizeLD
/
mFrameMetrics
.
GetDevPixelsPerCSSPixel
(
)
*
mFrameMetrics
.
GetZoom
(
)
;
}
ParentLayerPoint
delta
;
switch
(
aEvent
.
mDeltaType
)
{
case
ScrollWheelInput
:
:
SCROLLDELTA_LINE
:
{
delta
.
x
=
aEvent
.
mDeltaX
*
scrollAmount
.
width
;
delta
.
y
=
aEvent
.
mDeltaY
*
scrollAmount
.
height
;
break
;
}
case
ScrollWheelInput
:
:
SCROLLDELTA_PAGE
:
{
delta
.
x
=
aEvent
.
mDeltaX
*
pageScrollSize
.
width
;
delta
.
y
=
aEvent
.
mDeltaY
*
pageScrollSize
.
height
;
break
;
}
case
ScrollWheelInput
:
:
SCROLLDELTA_PIXEL
:
{
delta
=
ToParentLayerCoordinates
(
ScreenPoint
(
aEvent
.
mDeltaX
aEvent
.
mDeltaY
)
aEvent
.
mOrigin
)
;
break
;
}
}
delta
.
x
*
=
aEvent
.
mUserDeltaMultiplierX
;
delta
.
y
*
=
aEvent
.
mUserDeltaMultiplierY
;
if
(
gfxPrefs
:
:
MouseWheelHasRootScrollDeltaOverride
(
)
&
&
!
aEvent
.
IsCustomizedByUserPrefs
(
)
&
&
aEvent
.
mDeltaType
=
=
ScrollWheelInput
:
:
SCROLLDELTA_LINE
&
&
aEvent
.
mAllowToOverrideSystemScrollSpeed
)
{
delta
.
x
=
WidgetWheelEvent
:
:
ComputeOverriddenDelta
(
delta
.
x
false
)
;
delta
.
y
=
WidgetWheelEvent
:
:
ComputeOverriddenDelta
(
delta
.
y
true
)
;
}
if
(
aEvent
.
mDeltaType
=
=
ScrollWheelInput
:
:
SCROLLDELTA_LINE
&
&
aEvent
.
mScrollSeriesNumber
>
0
)
{
int32_t
start
=
gfxPrefs
:
:
MouseWheelAccelerationStart
(
)
;
if
(
start
>
=
0
&
&
aEvent
.
mScrollSeriesNumber
>
=
uint32_t
(
start
)
)
{
int32_t
factor
=
gfxPrefs
:
:
MouseWheelAccelerationFactor
(
)
;
if
(
factor
>
0
)
{
delta
.
x
=
ComputeAcceleratedWheelDelta
(
delta
.
x
aEvent
.
mScrollSeriesNumber
factor
)
;
delta
.
y
=
ComputeAcceleratedWheelDelta
(
delta
.
y
aEvent
.
mScrollSeriesNumber
factor
)
;
}
}
}
if
(
!
AllowsScrollingMoreThanOnePage
(
aEvent
.
mUserDeltaMultiplierX
)
&
&
Abs
(
delta
.
x
)
>
pageScrollSize
.
width
)
{
delta
.
x
=
(
delta
.
x
>
=
0
)
?
pageScrollSize
.
width
:
-
pageScrollSize
.
width
;
}
if
(
!
AllowsScrollingMoreThanOnePage
(
aEvent
.
mUserDeltaMultiplierY
)
&
&
Abs
(
delta
.
y
)
>
pageScrollSize
.
height
)
{
delta
.
y
=
(
delta
.
y
>
=
0
)
?
pageScrollSize
.
height
:
-
pageScrollSize
.
height
;
}
return
delta
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnKeyboard
(
const
KeyboardInput
&
aEvent
)
{
mTestHasAsyncKeyScrolled
=
true
;
CSSPoint
destination
=
GetKeyboardDestination
(
aEvent
.
mAction
)
;
bool
scrollSnapped
=
MaybeAdjustDestinationForScrollSnapping
(
aEvent
destination
)
;
if
(
!
gfxPrefs
:
:
SmoothScrollEnabled
(
)
)
{
CancelAnimation
(
)
;
ParentLayerPoint
startPoint
=
destination
*
mFrameMetrics
.
GetZoom
(
)
;
ParentLayerPoint
endPoint
=
mFrameMetrics
.
GetScrollOffset
(
)
*
mFrameMetrics
.
GetZoom
(
)
;
ParentLayerPoint
delta
=
endPoint
-
startPoint
;
ScreenPoint
distance
=
ToScreenCoordinates
(
ParentLayerPoint
(
fabs
(
delta
.
x
)
fabs
(
delta
.
y
)
)
startPoint
)
;
OverscrollHandoffState
handoffState
(
*
mInputQueue
-
>
GetCurrentKeyboardBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
distance
ScrollSource
:
:
Keyboard
)
;
CallDispatchScroll
(
startPoint
endPoint
handoffState
)
;
SetState
(
NOTHING
)
;
return
nsEventStatus_eConsumeDoDefault
;
}
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
scrollSnapped
)
{
APZC_LOG
(
"
%
p
keyboard
scrolling
to
snap
point
%
s
\
n
"
this
Stringify
(
destination
)
.
c_str
(
)
)
;
SmoothScrollTo
(
destination
)
;
return
nsEventStatus_eConsumeDoDefault
;
}
if
(
mState
!
=
KEYBOARD_SCROLL
)
{
CancelAnimation
(
)
;
SetState
(
KEYBOARD_SCROLL
)
;
nsPoint
initialPosition
=
CSSPoint
:
:
ToAppUnits
(
mFrameMetrics
.
GetScrollOffset
(
)
)
;
StartAnimation
(
new
KeyboardScrollAnimation
(
*
this
initialPosition
aEvent
.
mAction
.
mType
)
)
;
}
nsPoint
velocity
=
CSSPoint
:
:
ToAppUnits
(
ParentLayerPoint
(
mX
.
GetVelocity
(
)
*
1000
.
0f
mY
.
GetVelocity
(
)
*
1000
.
0f
)
/
mFrameMetrics
.
GetZoom
(
)
)
;
KeyboardScrollAnimation
*
animation
=
mAnimation
-
>
AsKeyboardScrollAnimation
(
)
;
MOZ_ASSERT
(
animation
)
;
animation
-
>
UpdateDestination
(
aEvent
.
mTimeStamp
CSSPixel
:
:
ToAppUnits
(
destination
)
nsSize
(
velocity
.
x
velocity
.
y
)
)
;
return
nsEventStatus_eConsumeDoDefault
;
}
CSSPoint
AsyncPanZoomController
:
:
GetKeyboardDestination
(
const
KeyboardScrollAction
&
aAction
)
const
{
CSSSize
lineScrollSize
;
CSSSize
pageScrollSize
;
CSSPoint
scrollOffset
;
CSSRect
scrollRect
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
lineScrollSize
=
mScrollMetadata
.
GetLineScrollAmount
(
)
/
mFrameMetrics
.
GetDevPixelsPerCSSPixel
(
)
;
pageScrollSize
=
mScrollMetadata
.
GetPageScrollAmount
(
)
/
mFrameMetrics
.
GetDevPixelsPerCSSPixel
(
)
;
if
(
mState
=
=
WHEEL_SCROLL
)
{
scrollOffset
=
mAnimation
-
>
AsWheelScrollAnimation
(
)
-
>
GetDestination
(
)
;
}
else
if
(
mState
=
=
SMOOTH_SCROLL
)
{
scrollOffset
=
mAnimation
-
>
AsSmoothScrollAnimation
(
)
-
>
GetDestination
(
)
;
}
else
if
(
mState
=
=
KEYBOARD_SCROLL
)
{
scrollOffset
=
mAnimation
-
>
AsKeyboardScrollAnimation
(
)
-
>
GetDestination
(
)
;
}
else
{
scrollOffset
=
mFrameMetrics
.
GetScrollOffset
(
)
;
}
scrollRect
=
mFrameMetrics
.
GetScrollableRect
(
)
;
}
CSSPoint
scrollDestination
=
scrollOffset
;
switch
(
aAction
.
mType
)
{
case
KeyboardScrollAction
:
:
eScrollCharacter
:
{
int32_t
scrollDistance
=
gfxPrefs
:
:
ToolkitHorizontalScrollDistance
(
)
;
if
(
aAction
.
mForward
)
{
scrollDestination
.
x
+
=
scrollDistance
*
lineScrollSize
.
width
;
}
else
{
scrollDestination
.
x
-
=
scrollDistance
*
lineScrollSize
.
width
;
}
break
;
}
case
KeyboardScrollAction
:
:
eScrollLine
:
{
int32_t
scrollDistance
=
gfxPrefs
:
:
ToolkitVerticalScrollDistance
(
)
;
if
(
aAction
.
mForward
)
{
scrollDestination
.
y
+
=
scrollDistance
*
lineScrollSize
.
height
;
}
else
{
scrollDestination
.
y
-
=
scrollDistance
*
lineScrollSize
.
height
;
}
break
;
}
case
KeyboardScrollAction
:
:
eScrollPage
:
{
if
(
aAction
.
mForward
)
{
scrollDestination
.
y
+
=
pageScrollSize
.
height
;
}
else
{
scrollDestination
.
y
-
=
pageScrollSize
.
height
;
}
break
;
}
case
KeyboardScrollAction
:
:
eScrollComplete
:
{
if
(
aAction
.
mForward
)
{
scrollDestination
.
y
=
scrollRect
.
YMost
(
)
;
}
else
{
scrollDestination
.
y
=
scrollRect
.
Y
(
)
;
}
break
;
}
}
return
scrollDestination
;
}
ParentLayerPoint
AsyncPanZoomController
:
:
GetDeltaForEvent
(
const
InputData
&
aEvent
)
const
{
ParentLayerPoint
delta
;
if
(
aEvent
.
mInputType
=
=
SCROLLWHEEL_INPUT
)
{
delta
=
GetScrollWheelDelta
(
aEvent
.
AsScrollWheelInput
(
)
)
;
}
else
if
(
aEvent
.
mInputType
=
=
PANGESTURE_INPUT
)
{
const
PanGestureInput
&
panInput
=
aEvent
.
AsPanGestureInput
(
)
;
delta
=
ToParentLayerCoordinates
(
panInput
.
UserMultipliedPanDisplacement
(
)
panInput
.
mPanStartPoint
)
;
}
return
delta
;
}
bool
AsyncPanZoomController
:
:
CanScroll
(
const
InputData
&
aEvent
)
const
{
ParentLayerPoint
delta
=
GetDeltaForEvent
(
aEvent
)
;
if
(
!
delta
.
x
&
&
!
delta
.
y
)
{
return
false
;
}
if
(
SCROLLWHEEL_INPUT
=
=
aEvent
.
mInputType
)
{
return
CanScrollWithWheel
(
delta
)
;
}
return
CanScroll
(
delta
)
;
}
ScrollDirections
AsyncPanZoomController
:
:
GetAllowedHandoffDirections
(
)
const
{
ScrollDirections
result
;
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
mX
.
OverscrollBehaviorAllowsHandoff
(
)
)
{
result
+
=
ScrollDirection
:
:
eHorizontal
;
}
if
(
mY
.
OverscrollBehaviorAllowsHandoff
(
)
)
{
result
+
=
ScrollDirection
:
:
eVertical
;
}
return
result
;
}
bool
AsyncPanZoomController
:
:
CanScroll
(
const
ParentLayerPoint
&
aDelta
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
mX
.
CanScroll
(
aDelta
.
x
)
|
|
mY
.
CanScroll
(
aDelta
.
y
)
;
}
bool
AsyncPanZoomController
:
:
CanScrollWithWheel
(
const
ParentLayerPoint
&
aDelta
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
Maybe
<
ScrollDirection
>
disregardedDirection
=
mScrollMetadata
.
GetDisregardedDirection
(
)
;
if
(
mX
.
CanScroll
(
aDelta
.
x
)
&
&
disregardedDirection
!
=
Some
(
ScrollDirection
:
:
eHorizontal
)
)
{
return
true
;
}
if
(
mY
.
CanScroll
(
aDelta
.
y
)
&
&
disregardedDirection
!
=
Some
(
ScrollDirection
:
:
eVertical
)
)
{
return
true
;
}
return
false
;
}
bool
AsyncPanZoomController
:
:
CanScroll
(
ScrollDirection
aDirection
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
switch
(
aDirection
)
{
case
ScrollDirection
:
:
eHorizontal
:
return
mX
.
CanScroll
(
)
;
case
ScrollDirection
:
:
eVertical
:
return
mY
.
CanScroll
(
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
value
"
)
;
return
false
;
}
bool
AsyncPanZoomController
:
:
AllowScrollHandoffInCurrentBlock
(
)
const
{
bool
result
=
mInputQueue
-
>
AllowScrollHandoff
(
)
;
if
(
!
gfxPrefs
:
:
APZAllowImmediateHandoff
(
)
)
{
if
(
InputBlockState
*
currentBlock
=
GetCurrentInputBlock
(
)
)
{
if
(
currentBlock
-
>
GetScrolledApzc
(
)
=
=
this
)
{
result
=
false
;
}
}
}
return
result
;
}
void
AsyncPanZoomController
:
:
DoDelayedRequestContentRepaint
(
)
{
if
(
!
IsDestroyed
(
)
&
&
mPinchPaintTimerSet
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
RequestContentRepaint
(
)
;
}
mPinchPaintTimerSet
=
false
;
}
static
void
AdjustDeltaForAllowedScrollDirections
(
ParentLayerPoint
&
aDelta
const
ScrollDirections
&
aAllowedScrollDirections
)
{
if
(
!
aAllowedScrollDirections
.
contains
(
ScrollDirection
:
:
eHorizontal
)
)
{
aDelta
.
x
=
0
;
}
if
(
!
aAllowedScrollDirections
.
contains
(
ScrollDirection
:
:
eVertical
)
)
{
aDelta
.
y
=
0
;
}
}
nsEventStatus
AsyncPanZoomController
:
:
OnScrollWheel
(
const
ScrollWheelInput
&
aEvent
)
{
ParentLayerPoint
delta
=
GetScrollWheelDelta
(
aEvent
)
;
APZC_LOG
(
"
%
p
got
a
scroll
-
wheel
with
delta
%
s
\
n
"
this
Stringify
(
delta
)
.
c_str
(
)
)
;
if
(
(
delta
.
x
|
|
delta
.
y
)
&
&
!
CanScrollWithWheel
(
delta
)
)
{
if
(
mInputQueue
-
>
GetActiveWheelTransaction
(
)
&
&
gfxPrefs
:
:
MouseScrollTestingEnabled
(
)
)
{
if
(
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
)
{
controller
-
>
NotifyMozMouseScrollEvent
(
mFrameMetrics
.
GetScrollId
(
)
NS_LITERAL_STRING
(
"
MozMouseScrollFailed
"
)
)
;
}
}
return
nsEventStatus_eConsumeNoDefault
;
}
MOZ_ASSERT
(
mInputQueue
-
>
GetCurrentWheelBlock
(
)
)
;
AdjustDeltaForAllowedScrollDirections
(
delta
mInputQueue
-
>
GetCurrentWheelBlock
(
)
-
>
GetAllowedScrollDirections
(
)
)
;
if
(
delta
.
x
=
=
0
&
&
delta
.
y
=
=
0
)
{
return
nsEventStatus_eIgnore
;
}
switch
(
aEvent
.
mScrollMode
)
{
case
ScrollWheelInput
:
:
SCROLLMODE_INSTANT
:
{
CSSPoint
startPosition
=
mFrameMetrics
.
GetScrollOffset
(
)
;
MaybeAdjustDeltaForScrollSnapping
(
aEvent
delta
startPosition
)
;
ScreenPoint
distance
=
ToScreenCoordinates
(
ParentLayerPoint
(
fabs
(
delta
.
x
)
fabs
(
delta
.
y
)
)
aEvent
.
mLocalOrigin
)
;
CancelAnimation
(
)
;
OverscrollHandoffState
handoffState
(
*
mInputQueue
-
>
GetCurrentWheelBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
distance
ScrollSource
:
:
Wheel
)
;
ParentLayerPoint
startPoint
=
aEvent
.
mLocalOrigin
;
ParentLayerPoint
endPoint
=
aEvent
.
mLocalOrigin
-
delta
;
CallDispatchScroll
(
startPoint
endPoint
handoffState
)
;
SetState
(
NOTHING
)
;
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
RequestContentRepaint
(
)
;
break
;
}
case
ScrollWheelInput
:
:
SCROLLMODE_SMOOTH
:
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
CSSPoint
startPosition
=
mFrameMetrics
.
GetScrollOffset
(
)
;
if
(
mState
=
=
WHEEL_SCROLL
)
{
startPosition
=
mAnimation
-
>
AsWheelScrollAnimation
(
)
-
>
GetDestination
(
)
;
}
else
if
(
mState
=
=
SMOOTH_SCROLL
)
{
startPosition
=
mAnimation
-
>
AsSmoothScrollAnimation
(
)
-
>
GetDestination
(
)
;
}
else
if
(
mState
=
=
KEYBOARD_SCROLL
)
{
startPosition
=
mAnimation
-
>
AsKeyboardScrollAnimation
(
)
-
>
GetDestination
(
)
;
}
if
(
MaybeAdjustDeltaForScrollSnapping
(
aEvent
delta
startPosition
)
)
{
APZC_LOG
(
"
%
p
wheel
scrolling
to
snap
point
%
s
\
n
"
this
Stringify
(
startPosition
)
.
c_str
(
)
)
;
SmoothScrollTo
(
startPosition
)
;
break
;
}
if
(
mState
!
=
WHEEL_SCROLL
)
{
CancelAnimation
(
)
;
SetState
(
WHEEL_SCROLL
)
;
nsPoint
initialPosition
=
CSSPoint
:
:
ToAppUnits
(
mFrameMetrics
.
GetScrollOffset
(
)
)
;
StartAnimation
(
new
WheelScrollAnimation
(
*
this
initialPosition
aEvent
.
mDeltaType
)
)
;
}
nsPoint
deltaInAppUnits
=
CSSPoint
:
:
ToAppUnits
(
delta
/
mFrameMetrics
.
GetZoom
(
)
)
;
nsPoint
velocity
=
CSSPoint
:
:
ToAppUnits
(
ParentLayerPoint
(
mX
.
GetVelocity
(
)
*
1000
.
0f
mY
.
GetVelocity
(
)
*
1000
.
0f
)
/
mFrameMetrics
.
GetZoom
(
)
)
;
WheelScrollAnimation
*
animation
=
mAnimation
-
>
AsWheelScrollAnimation
(
)
;
animation
-
>
UpdateDelta
(
aEvent
.
mTimeStamp
deltaInAppUnits
nsSize
(
velocity
.
x
velocity
.
y
)
)
;
break
;
}
}
return
nsEventStatus_eConsumeNoDefault
;
}
void
AsyncPanZoomController
:
:
NotifyMozMouseScrollEvent
(
const
nsString
&
aString
)
const
{
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
;
if
(
!
controller
)
{
return
;
}
controller
-
>
NotifyMozMouseScrollEvent
(
mFrameMetrics
.
GetScrollId
(
)
aString
)
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnPanMayBegin
(
const
PanGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
pan
-
maybegin
in
state
%
d
\
n
"
this
mState
)
;
mX
.
StartTouch
(
aEvent
.
mLocalPanStartPoint
.
x
aEvent
.
mTime
)
;
mY
.
StartTouch
(
aEvent
.
mLocalPanStartPoint
.
y
aEvent
.
mTime
)
;
MOZ_ASSERT
(
GetCurrentPanGestureBlock
(
)
)
;
GetCurrentPanGestureBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
-
>
CancelAnimations
(
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnPanCancelled
(
const
PanGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
pan
-
cancelled
in
state
%
d
\
n
"
this
mState
)
;
mX
.
CancelGesture
(
)
;
mY
.
CancelGesture
(
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnPanBegin
(
const
PanGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
pan
-
begin
in
state
%
d
\
n
"
this
mState
)
;
if
(
mState
=
=
SMOOTH_SCROLL
)
{
CancelAnimation
(
)
;
}
mX
.
StartTouch
(
aEvent
.
mLocalPanStartPoint
.
x
aEvent
.
mTime
)
;
mY
.
StartTouch
(
aEvent
.
mLocalPanStartPoint
.
y
aEvent
.
mTime
)
;
if
(
GetAxisLockMode
(
)
=
=
FREE
)
{
SetState
(
PANNING
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
float
dx
=
aEvent
.
mPanDisplacement
.
x
dy
=
aEvent
.
mPanDisplacement
.
y
;
if
(
dx
|
|
dy
)
{
double
angle
=
atan2
(
dy
dx
)
;
angle
=
fabs
(
angle
)
;
HandlePanning
(
angle
)
;
}
else
{
SetState
(
PANNING
)
;
}
OnPan
(
aEvent
true
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnPan
(
const
PanGestureInput
&
aEvent
bool
aFingersOnTouchpad
)
{
APZC_LOG
(
"
%
p
got
a
pan
-
pan
in
state
%
d
\
n
"
this
mState
)
;
if
(
mState
=
=
SMOOTH_SCROLL
)
{
if
(
!
aFingersOnTouchpad
)
{
return
nsEventStatus_eConsumeNoDefault
;
}
CancelAnimation
(
)
;
}
if
(
mState
=
=
NOTHING
)
{
if
(
!
aFingersOnTouchpad
)
{
return
nsEventStatus_eConsumeNoDefault
;
}
return
OnPanBegin
(
aEvent
)
;
}
ScreenPoint
physicalPanDisplacement
=
aEvent
.
mPanDisplacement
;
ParentLayerPoint
logicalPanDisplacement
=
aEvent
.
UserMultipliedLocalPanDisplacement
(
)
;
MOZ_ASSERT
(
GetCurrentPanGestureBlock
(
)
)
;
AdjustDeltaForAllowedScrollDirections
(
logicalPanDisplacement
GetCurrentPanGestureBlock
(
)
-
>
GetAllowedScrollDirections
(
)
)
;
mX
.
UpdateWithTouchAtDevicePoint
(
aEvent
.
mLocalPanStartPoint
.
x
logicalPanDisplacement
.
x
aEvent
.
mTime
)
;
mY
.
UpdateWithTouchAtDevicePoint
(
aEvent
.
mLocalPanStartPoint
.
y
logicalPanDisplacement
.
y
aEvent
.
mTime
)
;
HandlePanningUpdate
(
physicalPanDisplacement
)
;
ScreenPoint
panDistance
(
fabs
(
physicalPanDisplacement
.
x
)
fabs
(
physicalPanDisplacement
.
y
)
)
;
OverscrollHandoffState
handoffState
(
*
GetCurrentPanGestureBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
panDistance
ScrollSource
:
:
Wheel
)
;
ParentLayerPoint
startPoint
=
aEvent
.
mLocalPanStartPoint
;
ParentLayerPoint
endPoint
=
aEvent
.
mLocalPanStartPoint
-
logicalPanDisplacement
;
CallDispatchScroll
(
startPoint
endPoint
handoffState
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnPanEnd
(
const
PanGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
pan
-
end
in
state
%
d
\
n
"
this
mState
)
;
OnPan
(
aEvent
true
)
;
mX
.
EndTouch
(
aEvent
.
mTime
)
;
mY
.
EndTouch
(
aEvent
.
mTime
)
;
MOZ_ASSERT
(
GetCurrentPanGestureBlock
(
)
)
;
RefPtr
<
const
OverscrollHandoffChain
>
overscrollHandoffChain
=
GetCurrentPanGestureBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
;
if
(
!
overscrollHandoffChain
-
>
CanScrollInDirection
(
this
ScrollDirection
:
:
eHorizontal
)
)
{
mX
.
SetVelocity
(
0
)
;
}
if
(
!
overscrollHandoffChain
-
>
CanScrollInDirection
(
this
ScrollDirection
:
:
eVertical
)
)
{
mY
.
SetVelocity
(
0
)
;
}
SetState
(
NOTHING
)
;
RequestContentRepaint
(
)
;
if
(
!
aEvent
.
mFollowedByMomentum
)
{
ScrollSnap
(
)
;
}
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnPanMomentumStart
(
const
PanGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
pan
-
momentumstart
in
state
%
d
\
n
"
this
mState
)
;
if
(
mState
=
=
SMOOTH_SCROLL
)
{
CancelAnimation
(
)
;
}
SetState
(
PAN_MOMENTUM
)
;
ScrollSnapToDestination
(
)
;
OnPan
(
aEvent
false
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnPanMomentumEnd
(
const
PanGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
pan
-
momentumend
in
state
%
d
\
n
"
this
mState
)
;
OnPan
(
aEvent
false
)
;
mX
.
CancelGesture
(
)
;
mY
.
CancelGesture
(
)
;
SetState
(
NOTHING
)
;
RequestContentRepaint
(
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnLongPress
(
const
TapGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
long
-
press
in
state
%
d
\
n
"
this
mState
)
;
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
;
if
(
controller
)
{
LayoutDevicePoint
geckoScreenPoint
;
if
(
ConvertToGecko
(
aEvent
.
mPoint
&
geckoScreenPoint
)
)
{
TouchBlockState
*
touch
=
GetCurrentTouchBlock
(
)
;
if
(
!
touch
)
{
APZC_LOG
(
"
%
p
dropping
long
-
press
because
some
non
-
touch
block
interrupted
it
\
n
"
this
)
;
return
nsEventStatus_eIgnore
;
}
if
(
touch
-
>
IsDuringFastFling
(
)
)
{
APZC_LOG
(
"
%
p
dropping
long
-
press
because
of
fast
fling
\
n
"
this
)
;
return
nsEventStatus_eIgnore
;
}
uint64_t
blockId
=
GetInputQueue
(
)
-
>
InjectNewTouchBlock
(
this
)
;
controller
-
>
HandleTap
(
TapType
:
:
eLongTap
geckoScreenPoint
aEvent
.
modifiers
GetGuid
(
)
blockId
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
}
return
nsEventStatus_eIgnore
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnLongPressUp
(
const
TapGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
long
-
tap
-
up
in
state
%
d
\
n
"
this
mState
)
;
return
GenerateSingleTap
(
TapType
:
:
eLongTapUp
aEvent
.
mPoint
aEvent
.
modifiers
)
;
}
nsEventStatus
AsyncPanZoomController
:
:
GenerateSingleTap
(
TapType
aType
const
ScreenIntPoint
&
aPoint
mozilla
:
:
Modifiers
aModifiers
)
{
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
;
if
(
controller
)
{
LayoutDevicePoint
geckoScreenPoint
;
if
(
ConvertToGecko
(
aPoint
&
geckoScreenPoint
)
)
{
TouchBlockState
*
touch
=
GetCurrentTouchBlock
(
)
;
if
(
touch
)
{
if
(
touch
-
>
IsDuringFastFling
(
)
)
{
APZC_LOG
(
"
%
p
dropping
single
-
tap
because
it
was
during
a
fast
-
fling
\
n
"
this
)
;
return
nsEventStatus_eIgnore
;
}
touch
-
>
SetSingleTapOccurred
(
)
;
}
RefPtr
<
Runnable
>
runnable
=
NewRunnableMethod
<
TapType
LayoutDevicePoint
mozilla
:
:
Modifiers
ScrollableLayerGuid
uint64_t
>
(
"
layers
:
:
GeckoContentController
:
:
HandleTap
"
controller
&
GeckoContentController
:
:
HandleTap
aType
geckoScreenPoint
aModifiers
GetGuid
(
)
touch
?
touch
-
>
GetBlockId
(
)
:
0
)
;
controller
-
>
PostDelayedTask
(
runnable
.
forget
(
)
0
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
}
return
nsEventStatus_eIgnore
;
}
void
AsyncPanZoomController
:
:
OnTouchEndOrCancel
(
)
{
if
(
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
)
{
MOZ_ASSERT
(
GetCurrentTouchBlock
(
)
)
;
controller
-
>
NotifyAPZStateChange
(
GetGuid
(
)
APZStateChange
:
:
eEndTouch
GetCurrentTouchBlock
(
)
-
>
SingleTapOccurred
(
)
)
;
}
}
nsEventStatus
AsyncPanZoomController
:
:
OnSingleTapUp
(
const
TapGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
single
-
tap
-
up
in
state
%
d
\
n
"
this
mState
)
;
MOZ_ASSERT
(
GetCurrentTouchBlock
(
)
)
;
if
(
!
(
mZoomConstraints
.
mAllowDoubleTapZoom
&
&
GetCurrentTouchBlock
(
)
-
>
TouchActionAllowsDoubleTapZoom
(
)
)
)
{
return
GenerateSingleTap
(
TapType
:
:
eSingleTap
aEvent
.
mPoint
aEvent
.
modifiers
)
;
}
return
nsEventStatus_eIgnore
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnSingleTapConfirmed
(
const
TapGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
single
-
tap
-
confirmed
in
state
%
d
\
n
"
this
mState
)
;
return
GenerateSingleTap
(
TapType
:
:
eSingleTap
aEvent
.
mPoint
aEvent
.
modifiers
)
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnDoubleTap
(
const
TapGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
double
-
tap
in
state
%
d
\
n
"
this
mState
)
;
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
;
if
(
controller
)
{
MOZ_ASSERT
(
GetCurrentTouchBlock
(
)
)
;
if
(
mZoomConstraints
.
mAllowDoubleTapZoom
&
&
GetCurrentTouchBlock
(
)
-
>
TouchActionAllowsDoubleTapZoom
(
)
)
{
LayoutDevicePoint
geckoScreenPoint
;
if
(
ConvertToGecko
(
aEvent
.
mPoint
&
geckoScreenPoint
)
)
{
controller
-
>
HandleTap
(
TapType
:
:
eDoubleTap
geckoScreenPoint
aEvent
.
modifiers
GetGuid
(
)
GetCurrentTouchBlock
(
)
-
>
GetBlockId
(
)
)
;
}
}
return
nsEventStatus_eConsumeNoDefault
;
}
return
nsEventStatus_eIgnore
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnSecondTap
(
const
TapGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
second
-
tap
in
state
%
d
\
n
"
this
mState
)
;
return
GenerateSingleTap
(
TapType
:
:
eSecondTap
aEvent
.
mPoint
aEvent
.
modifiers
)
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnCancelTap
(
const
TapGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
cancel
-
tap
in
state
%
d
\
n
"
this
mState
)
;
return
nsEventStatus_eIgnore
;
}
ScreenToParentLayerMatrix4x4
AsyncPanZoomController
:
:
GetTransformToThis
(
)
const
{
if
(
APZCTreeManager
*
treeManagerLocal
=
GetApzcTreeManager
(
)
)
{
return
treeManagerLocal
-
>
GetScreenToApzcTransform
(
this
)
;
}
return
ScreenToParentLayerMatrix4x4
(
)
;
}
ScreenPoint
AsyncPanZoomController
:
:
ToScreenCoordinates
(
const
ParentLayerPoint
&
aVector
const
ParentLayerPoint
&
aAnchor
)
const
{
return
TransformVector
(
GetTransformToThis
(
)
.
Inverse
(
)
aVector
aAnchor
)
;
}
ParentLayerPoint
AsyncPanZoomController
:
:
ToParentLayerCoordinates
(
const
ScreenPoint
&
aVector
const
ScreenPoint
&
aAnchor
)
const
{
return
TransformVector
(
GetTransformToThis
(
)
aVector
aAnchor
)
;
}
bool
AsyncPanZoomController
:
:
Contains
(
const
ScreenIntPoint
&
aPoint
)
const
{
ScreenToParentLayerMatrix4x4
transformToThis
=
GetTransformToThis
(
)
;
Maybe
<
ParentLayerIntPoint
>
point
=
UntransformBy
(
transformToThis
aPoint
)
;
if
(
!
point
)
{
return
false
;
}
ParentLayerIntRect
cb
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
GetFrameMetrics
(
)
.
GetCompositionBounds
(
)
.
ToIntRect
(
&
cb
)
;
}
return
cb
.
Contains
(
*
point
)
;
}
ScreenCoord
AsyncPanZoomController
:
:
PanDistance
(
)
const
{
ParentLayerPoint
panVector
;
ParentLayerPoint
panStart
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
panVector
=
ParentLayerPoint
(
mX
.
PanDistance
(
)
mY
.
PanDistance
(
)
)
;
panStart
=
PanStart
(
)
;
}
return
ToScreenCoordinates
(
panVector
panStart
)
.
Length
(
)
;
}
ParentLayerPoint
AsyncPanZoomController
:
:
PanStart
(
)
const
{
return
ParentLayerPoint
(
mX
.
PanStart
(
)
mY
.
PanStart
(
)
)
;
}
const
ParentLayerPoint
AsyncPanZoomController
:
:
GetVelocityVector
(
)
const
{
return
ParentLayerPoint
(
mX
.
GetVelocity
(
)
mY
.
GetVelocity
(
)
)
;
}
void
AsyncPanZoomController
:
:
SetVelocityVector
(
const
ParentLayerPoint
&
aVelocityVector
)
{
mX
.
SetVelocity
(
aVelocityVector
.
x
)
;
mY
.
SetVelocity
(
aVelocityVector
.
y
)
;
}
void
AsyncPanZoomController
:
:
HandlePanningWithTouchAction
(
double
aAngle
)
{
MOZ_ASSERT
(
GetCurrentTouchBlock
(
)
)
;
RefPtr
<
const
OverscrollHandoffChain
>
overscrollHandoffChain
=
GetCurrentInputBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
;
bool
canScrollHorizontal
=
!
mX
.
IsAxisLocked
(
)
&
&
overscrollHandoffChain
-
>
CanScrollInDirection
(
this
ScrollDirection
:
:
eHorizontal
)
;
bool
canScrollVertical
=
!
mY
.
IsAxisLocked
(
)
&
&
overscrollHandoffChain
-
>
CanScrollInDirection
(
this
ScrollDirection
:
:
eVertical
)
;
if
(
GetCurrentTouchBlock
(
)
-
>
TouchActionAllowsPanningXY
(
)
)
{
if
(
canScrollHorizontal
&
&
canScrollVertical
)
{
if
(
IsCloseToHorizontal
(
aAngle
gfxPrefs
:
:
APZAxisLockAngle
(
)
)
)
{
mY
.
SetAxisLocked
(
true
)
;
SetState
(
PANNING_LOCKED_X
)
;
}
else
if
(
IsCloseToVertical
(
aAngle
gfxPrefs
:
:
APZAxisLockAngle
(
)
)
)
{
mX
.
SetAxisLocked
(
true
)
;
SetState
(
PANNING_LOCKED_Y
)
;
}
else
{
SetState
(
PANNING
)
;
}
}
else
if
(
canScrollHorizontal
|
|
canScrollVertical
)
{
SetState
(
PANNING
)
;
}
else
{
SetState
(
NOTHING
)
;
}
}
else
if
(
GetCurrentTouchBlock
(
)
-
>
TouchActionAllowsPanningX
(
)
)
{
if
(
IsCloseToHorizontal
(
aAngle
gfxPrefs
:
:
APZAllowedDirectPanAngle
(
)
)
)
{
mY
.
SetAxisLocked
(
true
)
;
SetState
(
PANNING_LOCKED_X
)
;
mPanDirRestricted
=
true
;
}
else
{
SetState
(
NOTHING
)
;
}
}
else
if
(
GetCurrentTouchBlock
(
)
-
>
TouchActionAllowsPanningY
(
)
)
{
if
(
IsCloseToVertical
(
aAngle
gfxPrefs
:
:
APZAllowedDirectPanAngle
(
)
)
)
{
mX
.
SetAxisLocked
(
true
)
;
SetState
(
PANNING_LOCKED_Y
)
;
mPanDirRestricted
=
true
;
}
else
{
SetState
(
NOTHING
)
;
}
}
else
{
SetState
(
NOTHING
)
;
}
if
(
!
IsInPanningState
(
)
)
{
mX
.
SetVelocity
(
0
)
;
mY
.
SetVelocity
(
0
)
;
}
}
void
AsyncPanZoomController
:
:
HandlePanning
(
double
aAngle
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
MOZ_ASSERT
(
GetCurrentInputBlock
(
)
)
;
RefPtr
<
const
OverscrollHandoffChain
>
overscrollHandoffChain
=
GetCurrentInputBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
;
bool
canScrollHorizontal
=
!
mX
.
IsAxisLocked
(
)
&
&
overscrollHandoffChain
-
>
CanScrollInDirection
(
this
ScrollDirection
:
:
eHorizontal
)
;
bool
canScrollVertical
=
!
mY
.
IsAxisLocked
(
)
&
&
overscrollHandoffChain
-
>
CanScrollInDirection
(
this
ScrollDirection
:
:
eVertical
)
;
if
(
!
canScrollHorizontal
|
|
!
canScrollVertical
)
{
SetState
(
PANNING
)
;
}
else
if
(
IsCloseToHorizontal
(
aAngle
gfxPrefs
:
:
APZAxisLockAngle
(
)
)
)
{
mY
.
SetAxisLocked
(
true
)
;
if
(
canScrollHorizontal
)
{
SetState
(
PANNING_LOCKED_X
)
;
}
}
else
if
(
IsCloseToVertical
(
aAngle
gfxPrefs
:
:
APZAxisLockAngle
(
)
)
)
{
mX
.
SetAxisLocked
(
true
)
;
if
(
canScrollVertical
)
{
SetState
(
PANNING_LOCKED_Y
)
;
}
}
else
{
SetState
(
PANNING
)
;
}
}
void
AsyncPanZoomController
:
:
HandlePanningUpdate
(
const
ScreenPoint
&
aPanDistance
)
{
if
(
GetAxisLockMode
(
)
=
=
STICKY
&
&
!
mPanDirRestricted
)
{
double
angle
=
atan2
(
aPanDistance
.
y
aPanDistance
.
x
)
;
angle
=
fabs
(
angle
)
;
float
breakThreshold
=
gfxPrefs
:
:
APZAxisBreakoutThreshold
(
)
*
GetDPI
(
)
;
if
(
fabs
(
aPanDistance
.
x
)
>
breakThreshold
|
|
fabs
(
aPanDistance
.
y
)
>
breakThreshold
)
{
if
(
mState
=
=
PANNING_LOCKED_X
)
{
if
(
!
IsCloseToHorizontal
(
angle
gfxPrefs
:
:
APZAxisBreakoutAngle
(
)
)
)
{
mY
.
SetAxisLocked
(
false
)
;
SetState
(
PANNING
)
;
}
}
else
if
(
mState
=
=
PANNING_LOCKED_Y
)
{
if
(
!
IsCloseToVertical
(
angle
gfxPrefs
:
:
APZAxisBreakoutAngle
(
)
)
)
{
mX
.
SetAxisLocked
(
false
)
;
SetState
(
PANNING
)
;
}
}
}
}
}
void
AsyncPanZoomController
:
:
HandlePinchLocking
(
ScreenCoord
spanDistance
ScreenPoint
focusChange
)
{
if
(
mPinchLocked
)
{
if
(
GetPinchLockMode
(
)
=
=
PINCH_STICKY
)
{
ScreenCoord
spanBreakoutThreshold
=
gfxPrefs
:
:
APZPinchLockSpanBreakoutThreshold
(
)
*
GetDPI
(
)
;
mPinchLocked
=
!
(
spanDistance
>
spanBreakoutThreshold
)
;
}
}
else
{
if
(
GetPinchLockMode
(
)
!
=
PINCH_FREE
)
{
ScreenCoord
spanLockThreshold
=
gfxPrefs
:
:
APZPinchLockSpanLockThreshold
(
)
*
GetDPI
(
)
;
ScreenCoord
scrollLockThreshold
=
gfxPrefs
:
:
APZPinchLockScrollLockThreshold
(
)
*
GetDPI
(
)
;
if
(
spanDistance
<
spanLockThreshold
&
&
focusChange
.
Length
(
)
>
scrollLockThreshold
)
{
mPinchLocked
=
true
;
}
}
}
}
nsEventStatus
AsyncPanZoomController
:
:
StartPanning
(
const
ParentLayerPoint
&
aStartPoint
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
float
dx
=
mX
.
PanDistance
(
aStartPoint
.
x
)
;
float
dy
=
mY
.
PanDistance
(
aStartPoint
.
y
)
;
double
angle
=
atan2
(
dy
dx
)
;
angle
=
fabs
(
angle
)
;
if
(
gfxPrefs
:
:
TouchActionEnabled
(
)
)
{
HandlePanningWithTouchAction
(
angle
)
;
}
else
{
if
(
GetAxisLockMode
(
)
=
=
FREE
)
{
SetState
(
PANNING
)
;
}
else
{
HandlePanning
(
angle
)
;
}
}
if
(
IsInPanningState
(
)
)
{
if
(
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
)
{
controller
-
>
NotifyAPZStateChange
(
GetGuid
(
)
APZStateChange
:
:
eStartPanning
)
;
}
return
nsEventStatus_eConsumeNoDefault
;
}
return
nsEventStatus_eIgnore
;
}
void
AsyncPanZoomController
:
:
UpdateWithTouchAtDevicePoint
(
const
MultiTouchInput
&
aEvent
)
{
ParentLayerPoint
point
=
GetFirstTouchPoint
(
aEvent
)
;
mX
.
UpdateWithTouchAtDevicePoint
(
point
.
x
0
aEvent
.
mTime
)
;
mY
.
UpdateWithTouchAtDevicePoint
(
point
.
y
0
aEvent
.
mTime
)
;
}
bool
AsyncPanZoomController
:
:
AttemptScroll
(
ParentLayerPoint
&
aStartPoint
ParentLayerPoint
&
aEndPoint
OverscrollHandoffState
&
aOverscrollHandoffState
)
{
ParentLayerPoint
displacement
=
aStartPoint
-
aEndPoint
;
ParentLayerPoint
overscroll
;
bool
scrollThisApzc
=
false
;
if
(
InputBlockState
*
block
=
GetCurrentInputBlock
(
)
)
{
scrollThisApzc
=
!
block
-
>
GetScrolledApzc
(
)
|
|
block
-
>
IsDownchainOfScrolledApzc
(
this
)
;
}
if
(
scrollThisApzc
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
bool
forcesVerticalOverscroll
=
ScrollSource
:
:
Wheel
=
=
aOverscrollHandoffState
.
mScrollSource
&
&
mScrollMetadata
.
GetDisregardedDirection
(
)
=
=
Some
(
ScrollDirection
:
:
eVertical
)
;
bool
forcesHorizontalOverscroll
=
ScrollSource
:
:
Wheel
=
=
aOverscrollHandoffState
.
mScrollSource
&
&
mScrollMetadata
.
GetDisregardedDirection
(
)
=
=
Some
(
ScrollDirection
:
:
eHorizontal
)
;
ParentLayerPoint
adjustedDisplacement
;
bool
yChanged
=
mY
.
AdjustDisplacement
(
displacement
.
y
adjustedDisplacement
.
y
overscroll
.
y
forcesVerticalOverscroll
)
;
bool
xChanged
=
mX
.
AdjustDisplacement
(
displacement
.
x
adjustedDisplacement
.
x
overscroll
.
x
forcesHorizontalOverscroll
)
;
if
(
xChanged
|
|
yChanged
)
{
ScheduleComposite
(
)
;
}
if
(
!
IsZero
(
adjustedDisplacement
)
)
{
ScrollBy
(
adjustedDisplacement
/
mFrameMetrics
.
GetZoom
(
)
)
;
if
(
InputBlockState
*
block
=
GetCurrentInputBlock
(
)
)
{
#
if
defined
(
MOZ_WIDGET_ANDROID
)
if
(
block
-
>
AsTouchBlock
(
)
&
&
(
block
-
>
GetScrolledApzc
(
)
!
=
this
)
&
&
IsRootContent
(
)
)
{
if
(
APZCTreeManager
*
manager
=
GetApzcTreeManager
(
)
)
{
AndroidDynamicToolbarAnimator
*
animator
=
manager
-
>
GetAndroidDynamicToolbarAnimator
(
)
;
MOZ_ASSERT
(
animator
)
;
animator
-
>
SetScrollingRootContent
(
)
;
}
}
#
endif
block
-
>
SetScrolledApzc
(
this
)
;
}
ScheduleCompositeAndMaybeRepaint
(
)
;
UpdateSharedCompositorFrameMetrics
(
)
;
}
aStartPoint
=
aEndPoint
+
overscroll
;
}
else
{
overscroll
=
displacement
;
}
if
(
IsZero
(
overscroll
)
)
{
return
true
;
}
if
(
AllowScrollHandoffInCurrentBlock
(
)
)
{
+
+
aOverscrollHandoffState
.
mChainIndex
;
CallDispatchScroll
(
aStartPoint
aEndPoint
aOverscrollHandoffState
)
;
overscroll
=
aStartPoint
-
aEndPoint
;
if
(
IsZero
(
overscroll
)
)
{
return
true
;
}
}
APZC_LOG
(
"
%
p
taking
overscroll
during
panning
\
n
"
this
)
;
OverscrollForPanning
(
overscroll
aOverscrollHandoffState
.
mPanDistance
)
;
aStartPoint
=
aEndPoint
+
overscroll
;
return
IsZero
(
overscroll
)
;
}
void
AsyncPanZoomController
:
:
OverscrollForPanning
(
ParentLayerPoint
&
aOverscroll
const
ScreenPoint
&
aPanDistance
)
{
if
(
!
IsOverscrolled
(
)
)
{
if
(
aPanDistance
.
x
<
gfxPrefs
:
:
APZMinPanDistanceRatio
(
)
*
aPanDistance
.
y
)
{
aOverscroll
.
x
=
0
;
}
if
(
aPanDistance
.
y
<
gfxPrefs
:
:
APZMinPanDistanceRatio
(
)
*
aPanDistance
.
x
)
{
aOverscroll
.
y
=
0
;
}
}
OverscrollBy
(
aOverscroll
)
;
}
void
AsyncPanZoomController
:
:
OverscrollBy
(
ParentLayerPoint
&
aOverscroll
)
{
if
(
!
gfxPrefs
:
:
APZOverscrollEnabled
(
)
)
{
return
;
}
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
bool
xCanScroll
=
mX
.
CanScroll
(
)
;
bool
yCanScroll
=
mY
.
CanScroll
(
)
;
bool
xConsumed
=
FuzzyEqualsAdditive
(
aOverscroll
.
x
0
.
0f
COORDINATE_EPSILON
)
;
bool
yConsumed
=
FuzzyEqualsAdditive
(
aOverscroll
.
y
0
.
0f
COORDINATE_EPSILON
)
;
bool
shouldOverscrollX
=
xCanScroll
&
&
!
xConsumed
&
&
mX
.
OverscrollBehaviorAllowsOverscrollEffect
(
)
;
bool
shouldOverscrollY
=
yCanScroll
&
&
!
yConsumed
&
&
mY
.
OverscrollBehaviorAllowsOverscrollEffect
(
)
;
mOverscrollEffect
-
>
ConsumeOverscroll
(
aOverscroll
shouldOverscrollX
shouldOverscrollY
)
;
}
RefPtr
<
const
OverscrollHandoffChain
>
AsyncPanZoomController
:
:
BuildOverscrollHandoffChain
(
)
{
if
(
APZCTreeManager
*
treeManagerLocal
=
GetApzcTreeManager
(
)
)
{
return
treeManagerLocal
-
>
BuildOverscrollHandoffChain
(
this
)
;
}
OverscrollHandoffChain
*
result
=
new
OverscrollHandoffChain
;
result
-
>
Add
(
this
)
;
return
result
;
}
ParentLayerPoint
AsyncPanZoomController
:
:
AttemptFling
(
const
FlingHandoffState
&
aHandoffState
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
!
IsPannable
(
)
)
{
return
aHandoffState
.
mVelocity
;
}
APZC_LOG
(
"
%
p
accepting
fling
with
velocity
%
s
\
n
"
this
Stringify
(
aHandoffState
.
mVelocity
)
.
c_str
(
)
)
;
ParentLayerPoint
residualVelocity
=
aHandoffState
.
mVelocity
;
if
(
mX
.
CanScroll
(
)
)
{
mX
.
SetVelocity
(
mX
.
GetVelocity
(
)
+
aHandoffState
.
mVelocity
.
x
)
;
residualVelocity
.
x
=
0
;
}
if
(
mY
.
CanScroll
(
)
)
{
mY
.
SetVelocity
(
mY
.
GetVelocity
(
)
+
aHandoffState
.
mVelocity
.
y
)
;
residualVelocity
.
y
=
0
;
}
ScrollSnapToDestination
(
)
;
if
(
mState
!
=
SMOOTH_SCROLL
)
{
SetState
(
FLING
)
;
FlingAnimation
*
fling
=
new
FlingAnimation
(
*
this
GetPlatformSpecificState
(
)
aHandoffState
.
mChain
aHandoffState
.
mIsHandoff
aHandoffState
.
mScrolledApzc
)
;
StartAnimation
(
fling
)
;
}
return
residualVelocity
;
}
ParentLayerPoint
AsyncPanZoomController
:
:
AdjustHandoffVelocityForOverscrollBehavior
(
ParentLayerPoint
&
aHandoffVelocity
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
ParentLayerPoint
residualVelocity
;
if
(
!
mX
.
OverscrollBehaviorAllowsHandoff
(
)
)
{
residualVelocity
.
x
=
aHandoffVelocity
.
x
;
aHandoffVelocity
.
x
=
0
;
}
if
(
!
mY
.
OverscrollBehaviorAllowsHandoff
(
)
)
{
residualVelocity
.
y
=
aHandoffVelocity
.
y
;
aHandoffVelocity
.
y
=
0
;
}
return
residualVelocity
;
}
bool
AsyncPanZoomController
:
:
OverscrollBehaviorAllowsSwipe
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
mX
.
OverscrollBehaviorAllowsHandoff
(
)
;
}
void
AsyncPanZoomController
:
:
HandleFlingOverscroll
(
const
ParentLayerPoint
&
aVelocity
const
RefPtr
<
const
OverscrollHandoffChain
>
&
aOverscrollHandoffChain
const
RefPtr
<
const
AsyncPanZoomController
>
&
aScrolledApzc
)
{
APZCTreeManager
*
treeManagerLocal
=
GetApzcTreeManager
(
)
;
if
(
treeManagerLocal
)
{
const
FlingHandoffState
handoffState
{
aVelocity
aOverscrollHandoffChain
true
aScrolledApzc
}
;
ParentLayerPoint
residualVelocity
=
treeManagerLocal
-
>
DispatchFling
(
this
handoffState
)
;
if
(
!
IsZero
(
residualVelocity
)
&
&
IsPannable
(
)
&
&
gfxPrefs
:
:
APZOverscrollEnabled
(
)
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
!
mX
.
OverscrollBehaviorAllowsOverscrollEffect
(
)
)
{
residualVelocity
.
x
=
0
;
}
if
(
!
mY
.
OverscrollBehaviorAllowsOverscrollEffect
(
)
)
{
residualVelocity
.
y
=
0
;
}
if
(
!
IsZero
(
residualVelocity
)
)
{
mOverscrollEffect
-
>
HandleFlingOverscroll
(
residualVelocity
)
;
}
}
}
}
void
AsyncPanZoomController
:
:
HandleSmoothScrollOverscroll
(
const
ParentLayerPoint
&
aVelocity
)
{
HandleFlingOverscroll
(
aVelocity
BuildOverscrollHandoffChain
(
)
nullptr
)
;
}
void
AsyncPanZoomController
:
:
SmoothScrollTo
(
const
CSSPoint
&
aDestination
)
{
if
(
mState
=
=
SMOOTH_SCROLL
&
&
mAnimation
)
{
APZC_LOG
(
"
%
p
updating
destination
on
existing
animation
\
n
"
this
)
;
RefPtr
<
SmoothScrollAnimation
>
animation
(
static_cast
<
SmoothScrollAnimation
*
>
(
mAnimation
.
get
(
)
)
)
;
animation
-
>
SetDestination
(
CSSPoint
:
:
ToAppUnits
(
aDestination
)
)
;
}
else
{
CancelAnimation
(
)
;
SetState
(
SMOOTH_SCROLL
)
;
nsPoint
initialPosition
=
CSSPoint
:
:
ToAppUnits
(
mFrameMetrics
.
GetScrollOffset
(
)
)
;
nsPoint
initialVelocity
=
CSSPoint
:
:
ToAppUnits
(
ParentLayerPoint
(
mX
.
GetVelocity
(
)
*
1000
.
0f
mY
.
GetVelocity
(
)
*
1000
.
0f
)
/
mFrameMetrics
.
GetZoom
(
)
)
;
nsPoint
destination
=
CSSPoint
:
:
ToAppUnits
(
aDestination
)
;
StartAnimation
(
new
SmoothScrollAnimation
(
*
this
initialPosition
initialVelocity
destination
gfxPrefs
:
:
ScrollBehaviorSpringConstant
(
)
gfxPrefs
:
:
ScrollBehaviorDampingRatio
(
)
)
)
;
}
}
void
AsyncPanZoomController
:
:
StartOverscrollAnimation
(
const
ParentLayerPoint
&
aVelocity
)
{
SetState
(
OVERSCROLL_ANIMATION
)
;
StartAnimation
(
new
OverscrollAnimation
(
*
this
aVelocity
)
)
;
}
void
AsyncPanZoomController
:
:
CallDispatchScroll
(
ParentLayerPoint
&
aStartPoint
ParentLayerPoint
&
aEndPoint
OverscrollHandoffState
&
aOverscrollHandoffState
)
{
APZCTreeManager
*
treeManagerLocal
=
GetApzcTreeManager
(
)
;
if
(
!
treeManagerLocal
)
{
return
;
}
ParentLayerPoint
endPoint
=
aEndPoint
;
if
(
aOverscrollHandoffState
.
mChainIndex
>
0
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
!
mX
.
OverscrollBehaviorAllowsHandoff
(
)
)
{
endPoint
.
x
=
aStartPoint
.
x
;
}
if
(
!
mY
.
OverscrollBehaviorAllowsHandoff
(
)
)
{
endPoint
.
y
=
aStartPoint
.
y
;
}
if
(
aStartPoint
=
=
endPoint
)
{
return
;
}
}
treeManagerLocal
-
>
DispatchScroll
(
this
aStartPoint
endPoint
aOverscrollHandoffState
)
;
}
void
AsyncPanZoomController
:
:
TrackTouch
(
const
MultiTouchInput
&
aEvent
)
{
ParentLayerPoint
prevTouchPoint
(
mX
.
GetPos
(
)
mY
.
GetPos
(
)
)
;
ParentLayerPoint
touchPoint
=
GetFirstTouchPoint
(
aEvent
)
;
ScreenPoint
panDistance
=
ToScreenCoordinates
(
ParentLayerPoint
(
mX
.
PanDistance
(
touchPoint
.
x
)
mY
.
PanDistance
(
touchPoint
.
y
)
)
PanStart
(
)
)
;
HandlePanningUpdate
(
panDistance
)
;
UpdateWithTouchAtDevicePoint
(
aEvent
)
;
if
(
prevTouchPoint
!
=
touchPoint
)
{
MOZ_ASSERT
(
GetCurrentTouchBlock
(
)
)
;
OverscrollHandoffState
handoffState
(
*
GetCurrentTouchBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
panDistance
ScrollSource
:
:
Touch
)
;
CallDispatchScroll
(
prevTouchPoint
touchPoint
handoffState
)
;
}
}
ParentLayerPoint
AsyncPanZoomController
:
:
GetFirstTouchPoint
(
const
MultiTouchInput
&
aEvent
)
{
return
(
(
SingleTouchData
&
)
aEvent
.
mTouches
[
0
]
)
.
mLocalScreenPoint
;
}
void
AsyncPanZoomController
:
:
StartAnimation
(
AsyncPanZoomAnimation
*
aAnimation
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
mAnimation
=
aAnimation
;
mLastSampleTime
=
GetFrameTime
(
)
;
ScheduleComposite
(
)
;
}
void
AsyncPanZoomController
:
:
CancelAnimation
(
CancelAnimationFlags
aFlags
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
APZC_LOG
(
"
%
p
running
CancelAnimation
(
0x
%
x
)
in
state
%
d
\
n
"
this
aFlags
mState
)
;
if
(
(
aFlags
&
ExcludeWheel
)
&
&
mState
=
=
WHEEL_SCROLL
)
{
return
;
}
if
(
mAnimation
)
{
mAnimation
-
>
Cancel
(
aFlags
)
;
}
SetState
(
NOTHING
)
;
mAnimation
=
nullptr
;
bool
repaint
=
!
IsZero
(
GetVelocityVector
(
)
)
;
mX
.
SetVelocity
(
0
)
;
mY
.
SetVelocity
(
0
)
;
mX
.
SetAxisLocked
(
false
)
;
mY
.
SetAxisLocked
(
false
)
;
if
(
!
(
aFlags
&
ExcludeOverscroll
)
&
&
IsOverscrolled
(
)
)
{
ClearOverscroll
(
)
;
repaint
=
true
;
}
if
(
aFlags
&
CancelAnimationFlags
:
:
ScrollSnap
)
{
ScrollSnap
(
)
;
}
if
(
repaint
)
{
RequestContentRepaint
(
)
;
ScheduleComposite
(
)
;
UpdateSharedCompositorFrameMetrics
(
)
;
}
}
void
AsyncPanZoomController
:
:
ClearOverscroll
(
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
mX
.
ClearOverscroll
(
)
;
mY
.
ClearOverscroll
(
)
;
}
void
AsyncPanZoomController
:
:
SetCompositorController
(
CompositorController
*
aCompositorController
)
{
mCompositorController
=
aCompositorController
;
}
void
AsyncPanZoomController
:
:
SetMetricsSharingController
(
MetricsSharingController
*
aMetricsSharingController
)
{
mMetricsSharingController
=
aMetricsSharingController
;
}
void
AsyncPanZoomController
:
:
AdjustScrollForSurfaceShift
(
const
ScreenPoint
&
aShift
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
CSSPoint
adjustment
=
ViewAs
<
ParentLayerPixel
>
(
aShift
PixelCastJustification
:
:
ScreenIsParentLayerForRoot
)
/
mFrameMetrics
.
GetZoom
(
)
;
APZC_LOG
(
"
%
p
adjusting
scroll
position
by
%
s
for
surface
shift
\
n
"
this
Stringify
(
adjustment
)
.
c_str
(
)
)
;
CSSRect
scrollRange
=
mFrameMetrics
.
CalculateScrollRange
(
)
;
mFrameMetrics
.
SetScrollOffset
(
scrollRange
.
ClampPoint
(
mFrameMetrics
.
GetScrollOffset
(
)
+
adjustment
)
)
;
mCompositedScrollOffset
=
scrollRange
.
ClampPoint
(
mCompositedScrollOffset
+
adjustment
)
;
RequestContentRepaint
(
)
;
UpdateSharedCompositorFrameMetrics
(
)
;
}
void
AsyncPanZoomController
:
:
ScrollBy
(
const
CSSPoint
&
aOffset
)
{
mFrameMetrics
.
ScrollBy
(
aOffset
)
;
}
void
AsyncPanZoomController
:
:
ScrollByAndClamp
(
const
CSSPoint
&
aOffset
)
{
mFrameMetrics
.
ClampAndSetScrollOffset
(
mFrameMetrics
.
GetScrollOffset
(
)
+
aOffset
)
;
}
void
AsyncPanZoomController
:
:
ScaleWithFocus
(
float
aScale
const
CSSPoint
&
aFocus
)
{
mFrameMetrics
.
ZoomBy
(
aScale
)
;
mFrameMetrics
.
SetScrollOffset
(
(
mFrameMetrics
.
GetScrollOffset
(
)
+
aFocus
)
-
(
aFocus
/
aScale
)
)
;
}
static
CSSSize
CalculateDisplayPortSize
(
const
CSSSize
&
aCompositionSize
const
CSSPoint
&
aVelocity
)
{
bool
xIsStationarySpeed
=
fabsf
(
aVelocity
.
x
)
<
gfxPrefs
:
:
APZMinSkateSpeed
(
)
;
bool
yIsStationarySpeed
=
fabsf
(
aVelocity
.
y
)
<
gfxPrefs
:
:
APZMinSkateSpeed
(
)
;
float
xMultiplier
=
xIsStationarySpeed
?
gfxPrefs
:
:
APZXStationarySizeMultiplier
(
)
:
gfxPrefs
:
:
APZXSkateSizeMultiplier
(
)
;
float
yMultiplier
=
yIsStationarySpeed
?
gfxPrefs
:
:
APZYStationarySizeMultiplier
(
)
:
gfxPrefs
:
:
APZYSkateSizeMultiplier
(
)
;
if
(
IsHighMemSystem
(
)
&
&
!
xIsStationarySpeed
)
{
xMultiplier
+
=
gfxPrefs
:
:
APZXSkateHighMemAdjust
(
)
;
}
if
(
IsHighMemSystem
(
)
&
&
!
yIsStationarySpeed
)
{
yMultiplier
+
=
gfxPrefs
:
:
APZYSkateHighMemAdjust
(
)
;
}
return
aCompositionSize
*
CSSSize
(
xMultiplier
yMultiplier
)
;
}
static
CSSSize
ExpandDisplayPortToDangerZone
(
const
CSSSize
&
aDisplayPortSize
const
FrameMetrics
&
aFrameMetrics
)
{
CSSSize
dangerZone
(
0
.
0f
0
.
0f
)
;
if
(
aFrameMetrics
.
LayersPixelsPerCSSPixel
(
)
.
xScale
!
=
0
&
&
aFrameMetrics
.
LayersPixelsPerCSSPixel
(
)
.
yScale
!
=
0
)
{
dangerZone
=
LayerSize
(
gfxPrefs
:
:
APZDangerZoneX
(
)
gfxPrefs
:
:
APZDangerZoneY
(
)
)
/
aFrameMetrics
.
LayersPixelsPerCSSPixel
(
)
;
}
const
CSSSize
compositionSize
=
aFrameMetrics
.
CalculateBoundedCompositedSizeInCssPixels
(
)
;
const
float
xSize
=
std
:
:
max
(
aDisplayPortSize
.
width
compositionSize
.
width
+
(
2
*
dangerZone
.
width
)
)
;
const
float
ySize
=
std
:
:
max
(
aDisplayPortSize
.
height
compositionSize
.
height
+
(
2
*
dangerZone
.
height
)
)
;
return
CSSSize
(
xSize
ySize
)
;
}
static
void
RedistributeDisplayPortExcess
(
CSSSize
&
aDisplayPortSize
const
CSSRect
&
aScrollableRect
)
{
if
(
aDisplayPortSize
.
height
>
aScrollableRect
.
Height
(
)
)
{
aDisplayPortSize
.
width
*
=
(
aDisplayPortSize
.
height
/
aScrollableRect
.
Height
(
)
)
;
aDisplayPortSize
.
height
=
aScrollableRect
.
Height
(
)
;
}
else
if
(
aDisplayPortSize
.
width
>
aScrollableRect
.
Width
(
)
)
{
aDisplayPortSize
.
height
*
=
(
aDisplayPortSize
.
width
/
aScrollableRect
.
Width
(
)
)
;
aDisplayPortSize
.
width
=
aScrollableRect
.
Width
(
)
;
}
}
const
ScreenMargin
AsyncPanZoomController
:
:
CalculatePendingDisplayPort
(
const
FrameMetrics
&
aFrameMetrics
const
ParentLayerPoint
&
aVelocity
)
{
if
(
aFrameMetrics
.
IsScrollInfoLayer
(
)
)
{
return
ScreenMargin
(
)
;
}
CSSSize
compositionSize
=
aFrameMetrics
.
CalculateBoundedCompositedSizeInCssPixels
(
)
;
CSSPoint
velocity
;
if
(
aFrameMetrics
.
GetZoom
(
)
!
=
CSSToParentLayerScale2D
(
0
0
)
)
{
velocity
=
aVelocity
/
aFrameMetrics
.
GetZoom
(
)
;
}
CSSRect
scrollableRect
=
aFrameMetrics
.
GetExpandedScrollableRect
(
)
;
CSSSize
displayPortSize
=
CalculateDisplayPortSize
(
compositionSize
velocity
)
;
displayPortSize
=
ExpandDisplayPortToDangerZone
(
displayPortSize
aFrameMetrics
)
;
if
(
gfxPrefs
:
:
APZEnlargeDisplayPortWhenClipped
(
)
)
{
RedistributeDisplayPortExcess
(
displayPortSize
scrollableRect
)
;
}
CSSRect
displayPort
(
(
compositionSize
.
width
-
displayPortSize
.
width
)
/
2
.
0f
(
compositionSize
.
height
-
displayPortSize
.
height
)
/
2
.
0f
displayPortSize
.
width
displayPortSize
.
height
)
;
float
paintFactor
=
kDefaultEstimatedPaintDurationMs
;
displayPort
.
MoveBy
(
velocity
*
paintFactor
*
gfxPrefs
:
:
APZVelocityBias
(
)
)
;
APZC_LOG_FM
(
aFrameMetrics
"
Calculated
displayport
as
(
%
f
%
f
%
f
%
f
)
from
velocity
%
s
paint
time
%
f
metrics
"
displayPort
.
x
displayPort
.
y
displayPort
.
Width
(
)
displayPort
.
Height
(
)
ToString
(
aVelocity
)
.
c_str
(
)
paintFactor
)
;
CSSMargin
cssMargins
;
cssMargins
.
left
=
-
displayPort
.
X
(
)
;
cssMargins
.
top
=
-
displayPort
.
Y
(
)
;
cssMargins
.
right
=
displayPort
.
Width
(
)
-
compositionSize
.
width
-
cssMargins
.
left
;
cssMargins
.
bottom
=
displayPort
.
Height
(
)
-
compositionSize
.
height
-
cssMargins
.
top
;
return
cssMargins
*
aFrameMetrics
.
DisplayportPixelsPerCSSPixel
(
)
;
}
void
AsyncPanZoomController
:
:
ScheduleComposite
(
)
{
if
(
mCompositorController
)
{
mCompositorController
-
>
ScheduleRenderOnCompositorThread
(
)
;
}
}
void
AsyncPanZoomController
:
:
ScheduleCompositeAndMaybeRepaint
(
)
{
ScheduleComposite
(
)
;
RequestContentRepaint
(
)
;
}
void
AsyncPanZoomController
:
:
FlushRepaintForOverscrollHandoff
(
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
RequestContentRepaint
(
)
;
UpdateSharedCompositorFrameMetrics
(
)
;
}
void
AsyncPanZoomController
:
:
FlushRepaintForNewInputBlock
(
)
{
APZC_LOG
(
"
%
p
flushing
repaint
for
new
input
block
\
n
"
this
)
;
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
RequestContentRepaint
(
)
;
UpdateSharedCompositorFrameMetrics
(
)
;
}
bool
AsyncPanZoomController
:
:
SnapBackIfOverscrolled
(
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
IsOverscrolled
(
)
&
&
mState
!
=
OVERSCROLL_ANIMATION
)
{
APZC_LOG
(
"
%
p
is
overscrolled
starting
snap
-
back
\
n
"
this
)
;
StartOverscrollAnimation
(
ParentLayerPoint
(
0
0
)
)
;
return
true
;
}
if
(
mState
!
=
FLING
)
{
ScrollSnap
(
)
;
}
return
false
;
}
bool
AsyncPanZoomController
:
:
IsFlingingFast
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
mState
=
=
FLING
&
&
GetVelocityVector
(
)
.
Length
(
)
>
gfxPrefs
:
:
APZFlingStopOnTapThreshold
(
)
)
{
APZC_LOG
(
"
%
p
is
moving
fast
\
n
"
this
)
;
return
true
;
}
return
false
;
}
bool
AsyncPanZoomController
:
:
IsPannable
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
mX
.
CanScroll
(
)
|
|
mY
.
CanScroll
(
)
;
}
bool
AsyncPanZoomController
:
:
IsScrollInfoLayer
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
mFrameMetrics
.
IsScrollInfoLayer
(
)
;
}
int32_t
AsyncPanZoomController
:
:
GetLastTouchIdentifier
(
)
const
{
RefPtr
<
GestureEventListener
>
listener
=
GetGestureEventListener
(
)
;
return
listener
?
listener
-
>
GetLastTouchIdentifier
(
)
:
-
1
;
}
void
AsyncPanZoomController
:
:
RequestContentRepaint
(
bool
aUserAction
)
{
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
;
if
(
!
controller
)
{
return
;
}
if
(
!
controller
-
>
IsRepaintThread
(
)
)
{
auto
func
=
static_cast
<
void
(
AsyncPanZoomController
:
:
*
)
(
bool
)
>
(
&
AsyncPanZoomController
:
:
RequestContentRepaint
)
;
controller
-
>
DispatchToRepaintThread
(
NewRunnableMethod
<
bool
>
(
"
layers
:
:
AsyncPanZoomController
:
:
RequestContentRepaint
"
this
func
aUserAction
)
)
;
return
;
}
MOZ_ASSERT
(
controller
-
>
IsRepaintThread
(
)
)
;
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
ParentLayerPoint
velocity
=
GetVelocityVector
(
)
;
mFrameMetrics
.
SetDisplayPortMargins
(
CalculatePendingDisplayPort
(
mFrameMetrics
velocity
)
)
;
mFrameMetrics
.
SetUseDisplayPortMargins
(
true
)
;
mFrameMetrics
.
SetPaintRequestTime
(
TimeStamp
:
:
Now
(
)
)
;
mFrameMetrics
.
SetRepaintDrivenByUserAction
(
aUserAction
)
;
RequestContentRepaint
(
mFrameMetrics
velocity
)
;
}
CSSRect
GetDisplayPortRect
(
const
FrameMetrics
&
aFrameMetrics
)
{
CSSRect
baseRect
(
aFrameMetrics
.
GetScrollOffset
(
)
aFrameMetrics
.
CalculateBoundedCompositedSizeInCssPixels
(
)
)
;
baseRect
.
Inflate
(
aFrameMetrics
.
GetDisplayPortMargins
(
)
/
aFrameMetrics
.
DisplayportPixelsPerCSSPixel
(
)
)
;
return
baseRect
;
}
void
AsyncPanZoomController
:
:
RequestContentRepaint
(
const
FrameMetrics
&
aFrameMetrics
const
ParentLayerPoint
&
aVelocity
)
{
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
;
if
(
!
controller
)
{
return
;
}
MOZ_ASSERT
(
controller
-
>
IsRepaintThread
(
)
)
;
ScreenMargin
marginDelta
=
(
mLastPaintRequestMetrics
.
GetDisplayPortMargins
(
)
-
aFrameMetrics
.
GetDisplayPortMargins
(
)
)
;
if
(
fabsf
(
marginDelta
.
left
)
<
EPSILON
&
&
fabsf
(
marginDelta
.
top
)
<
EPSILON
&
&
fabsf
(
marginDelta
.
right
)
<
EPSILON
&
&
fabsf
(
marginDelta
.
bottom
)
<
EPSILON
&
&
fabsf
(
mLastPaintRequestMetrics
.
GetScrollOffset
(
)
.
x
-
aFrameMetrics
.
GetScrollOffset
(
)
.
x
)
<
EPSILON
&
&
fabsf
(
mLastPaintRequestMetrics
.
GetScrollOffset
(
)
.
y
-
aFrameMetrics
.
GetScrollOffset
(
)
.
y
)
<
EPSILON
&
&
aFrameMetrics
.
GetPresShellResolution
(
)
=
=
mLastPaintRequestMetrics
.
GetPresShellResolution
(
)
&
&
aFrameMetrics
.
GetZoom
(
)
=
=
mLastPaintRequestMetrics
.
GetZoom
(
)
&
&
fabsf
(
aFrameMetrics
.
GetViewport
(
)
.
Width
(
)
-
mLastPaintRequestMetrics
.
GetViewport
(
)
.
Width
(
)
)
<
EPSILON
&
&
fabsf
(
aFrameMetrics
.
GetViewport
(
)
.
Height
(
)
-
mLastPaintRequestMetrics
.
GetViewport
(
)
.
Height
(
)
)
<
EPSILON
&
&
aFrameMetrics
.
GetScrollGeneration
(
)
=
=
mLastPaintRequestMetrics
.
GetScrollGeneration
(
)
&
&
aFrameMetrics
.
GetScrollUpdateType
(
)
=
=
mLastPaintRequestMetrics
.
GetScrollUpdateType
(
)
)
{
return
;
}
APZC_LOG_FM
(
aFrameMetrics
"
%
p
requesting
content
repaint
"
this
)
;
{
MutexAutoLock
lock
(
mCheckerboardEventLock
)
;
if
(
mCheckerboardEvent
&
&
mCheckerboardEvent
-
>
IsRecordingTrace
(
)
)
{
std
:
:
stringstream
info
;
info
<
<
"
velocity
"
<
<
aVelocity
;
std
:
:
string
str
=
info
.
str
(
)
;
mCheckerboardEvent
-
>
UpdateRendertraceProperty
(
CheckerboardEvent
:
:
RequestedDisplayPort
GetDisplayPortRect
(
aFrameMetrics
)
str
)
;
}
}
MOZ_ASSERT
(
aFrameMetrics
.
GetScrollUpdateType
(
)
=
=
FrameMetrics
:
:
eNone
|
|
aFrameMetrics
.
GetScrollUpdateType
(
)
=
=
FrameMetrics
:
:
eUserAction
)
;
controller
-
>
RequestContentRepaint
(
aFrameMetrics
)
;
mExpectedGeckoMetrics
=
aFrameMetrics
;
mLastPaintRequestMetrics
=
aFrameMetrics
;
}
bool
AsyncPanZoomController
:
:
UpdateAnimation
(
const
TimeStamp
&
aSampleTime
nsTArray
<
RefPtr
<
Runnable
>
>
*
aOutDeferredTasks
)
{
AssertOnSamplerThread
(
)
;
if
(
mLastSampleTime
=
=
aSampleTime
)
{
return
false
;
}
bool
needComposite
=
SampleCompositedAsyncTransform
(
)
;
TimeDuration
sampleTimeDelta
=
aSampleTime
-
mLastSampleTime
;
mLastSampleTime
=
aSampleTime
;
if
(
mAnimation
)
{
bool
continueAnimation
=
mAnimation
-
>
Sample
(
mFrameMetrics
sampleTimeDelta
)
;
bool
wantsRepaints
=
mAnimation
-
>
WantsRepaints
(
)
;
*
aOutDeferredTasks
=
mAnimation
-
>
TakeDeferredTasks
(
)
;
if
(
!
continueAnimation
)
{
mAnimation
=
nullptr
;
SetState
(
NOTHING
)
;
}
if
(
!
continueAnimation
|
|
wantsRepaints
)
{
RequestContentRepaint
(
)
;
}
UpdateSharedCompositorFrameMetrics
(
)
;
needComposite
=
true
;
}
return
needComposite
;
}
AsyncTransformComponentMatrix
AsyncPanZoomController
:
:
GetOverscrollTransform
(
AsyncTransformConsumer
aMode
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
aMode
=
=
eForCompositing
&
&
mScrollMetadata
.
IsApzForceDisabled
(
)
)
{
return
AsyncTransformComponentMatrix
(
)
;
}
if
(
!
IsOverscrolled
(
)
)
{
return
AsyncTransformComponentMatrix
(
)
;
}
ParentLayerPoint
overscrollOffset
(
-
mX
.
GetOverscroll
(
)
-
mY
.
GetOverscroll
(
)
)
;
return
AsyncTransformComponentMatrix
(
)
.
PostTranslate
(
overscrollOffset
.
x
overscrollOffset
.
y
0
)
;
}
bool
AsyncPanZoomController
:
:
AdvanceAnimations
(
const
TimeStamp
&
aSampleTime
)
{
AssertOnSamplerThread
(
)
;
StateChangeNotificationBlocker
blocker
(
this
)
;
mAsyncTransformAppliedToContent
=
false
;
bool
requestAnimationFrame
=
false
;
nsTArray
<
RefPtr
<
Runnable
>
>
deferredTasks
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
requestAnimationFrame
=
UpdateAnimation
(
aSampleTime
&
deferredTasks
)
;
{
MutexAutoLock
lock
(
mCheckerboardEventLock
)
;
if
(
mCheckerboardEvent
)
{
mCheckerboardEvent
-
>
UpdateRendertraceProperty
(
CheckerboardEvent
:
:
UserVisible
CSSRect
(
mFrameMetrics
.
GetScrollOffset
(
)
mFrameMetrics
.
CalculateCompositedSizeInCssPixels
(
)
)
)
;
}
}
}
for
(
uint32_t
i
=
0
;
i
<
deferredTasks
.
Length
(
)
;
+
+
i
)
{
deferredTasks
[
i
]
-
>
Run
(
)
;
deferredTasks
[
i
]
=
nullptr
;
}
requestAnimationFrame
|
=
(
mAnimation
!
=
nullptr
)
;
return
requestAnimationFrame
;
}
ParentLayerPoint
AsyncPanZoomController
:
:
GetCurrentAsyncScrollOffset
(
AsyncTransformConsumer
aMode
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
aMode
=
=
eForCompositing
&
&
mScrollMetadata
.
IsApzForceDisabled
(
)
)
{
return
mLastContentPaintMetrics
.
GetScrollOffset
(
)
*
mLastContentPaintMetrics
.
GetZoom
(
)
;
}
return
(
GetEffectiveScrollOffset
(
aMode
)
+
mTestAsyncScrollOffset
)
*
GetEffectiveZoom
(
aMode
)
*
mTestAsyncZoom
.
scale
;
}
CSSPoint
AsyncPanZoomController
:
:
GetCurrentAsyncScrollOffsetInCssPixels
(
AsyncTransformConsumer
aMode
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
aMode
=
=
eForCompositing
&
&
mScrollMetadata
.
IsApzForceDisabled
(
)
)
{
return
mLastContentPaintMetrics
.
GetScrollOffset
(
)
;
}
return
GetEffectiveScrollOffset
(
aMode
)
+
mTestAsyncScrollOffset
;
}
AsyncTransform
AsyncPanZoomController
:
:
GetCurrentAsyncTransform
(
AsyncTransformConsumer
aMode
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
aMode
=
=
eForCompositing
&
&
mScrollMetadata
.
IsApzForceDisabled
(
)
)
{
return
AsyncTransform
(
)
;
}
CSSPoint
lastPaintScrollOffset
;
if
(
mLastContentPaintMetrics
.
IsScrollable
(
)
)
{
lastPaintScrollOffset
=
mLastContentPaintMetrics
.
GetScrollOffset
(
)
;
}
CSSPoint
currentScrollOffset
=
GetEffectiveScrollOffset
(
aMode
)
+
mTestAsyncScrollOffset
;
if
(
!
gfxPrefs
:
:
APZAllowCheckerboarding
(
)
&
&
!
mLastContentPaintMetrics
.
GetDisplayPort
(
)
.
IsEmpty
(
)
)
{
CSSSize
compositedSize
=
mLastContentPaintMetrics
.
CalculateCompositedSizeInCssPixels
(
)
;
CSSPoint
maxScrollOffset
=
lastPaintScrollOffset
+
CSSPoint
(
mLastContentPaintMetrics
.
GetDisplayPort
(
)
.
XMost
(
)
-
compositedSize
.
width
mLastContentPaintMetrics
.
GetDisplayPort
(
)
.
YMost
(
)
-
compositedSize
.
height
)
;
CSSPoint
minScrollOffset
=
lastPaintScrollOffset
+
mLastContentPaintMetrics
.
GetDisplayPort
(
)
.
TopLeft
(
)
;
if
(
minScrollOffset
.
x
<
maxScrollOffset
.
x
)
{
currentScrollOffset
.
x
=
clamped
(
currentScrollOffset
.
x
minScrollOffset
.
x
maxScrollOffset
.
x
)
;
}
if
(
minScrollOffset
.
y
<
maxScrollOffset
.
y
)
{
currentScrollOffset
.
y
=
clamped
(
currentScrollOffset
.
y
minScrollOffset
.
y
maxScrollOffset
.
y
)
;
}
}
CSSToParentLayerScale2D
effectiveZoom
=
GetEffectiveZoom
(
aMode
)
;
ParentLayerPoint
translation
=
(
currentScrollOffset
-
lastPaintScrollOffset
)
*
effectiveZoom
*
mTestAsyncZoom
.
scale
;
LayerToParentLayerScale
compositedAsyncZoom
=
(
effectiveZoom
/
mFrameMetrics
.
LayersPixelsPerCSSPixel
(
)
)
.
ToScaleFactor
(
)
;
return
AsyncTransform
(
LayerToParentLayerScale
(
compositedAsyncZoom
.
scale
*
mTestAsyncZoom
.
scale
)
-
translation
)
;
}
CSSPoint
AsyncPanZoomController
:
:
GetEffectiveScrollOffset
(
AsyncTransformConsumer
aMode
)
const
{
if
(
gfxPrefs
:
:
APZFrameDelayEnabled
(
)
&
&
aMode
=
=
eForCompositing
)
{
return
mCompositedScrollOffset
;
}
return
mFrameMetrics
.
GetScrollOffset
(
)
;
}
CSSToParentLayerScale2D
AsyncPanZoomController
:
:
GetEffectiveZoom
(
AsyncTransformConsumer
aMode
)
const
{
if
(
gfxPrefs
:
:
APZFrameDelayEnabled
(
)
&
&
aMode
=
=
eForCompositing
)
{
return
mCompositedZoom
;
}
return
mFrameMetrics
.
GetZoom
(
)
;
}
bool
AsyncPanZoomController
:
:
SampleCompositedAsyncTransform
(
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
mCompositedScrollOffset
!
=
mFrameMetrics
.
GetScrollOffset
(
)
|
|
mCompositedZoom
!
=
mFrameMetrics
.
GetZoom
(
)
)
{
mCompositedScrollOffset
=
mFrameMetrics
.
GetScrollOffset
(
)
;
mCompositedZoom
=
mFrameMetrics
.
GetZoom
(
)
;
return
true
;
}
return
false
;
}
AsyncTransformComponentMatrix
AsyncPanZoomController
:
:
GetCurrentAsyncTransformWithOverscroll
(
AsyncTransformConsumer
aMode
)
const
{
return
AsyncTransformComponentMatrix
(
GetCurrentAsyncTransform
(
aMode
)
)
*
GetOverscrollTransform
(
aMode
)
;
}
Matrix4x4
AsyncPanZoomController
:
:
GetTransformToLastDispatchedPaint
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
LayerPoint
scrollChange
=
(
mLastContentPaintMetrics
.
GetScrollOffset
(
)
-
mExpectedGeckoMetrics
.
GetScrollOffset
(
)
)
*
mLastContentPaintMetrics
.
GetDevPixelsPerCSSPixel
(
)
*
mLastContentPaintMetrics
.
GetCumulativeResolution
(
)
;
LayoutDeviceToParentLayerScale2D
lastContentZoom
=
mLastContentPaintMetrics
.
GetZoom
(
)
/
mLastContentPaintMetrics
.
GetDevPixelsPerCSSPixel
(
)
;
LayoutDeviceToParentLayerScale2D
lastDispatchedZoom
=
mExpectedGeckoMetrics
.
GetZoom
(
)
/
mExpectedGeckoMetrics
.
GetDevPixelsPerCSSPixel
(
)
;
gfxSize
zoomChange
=
lastContentZoom
/
lastDispatchedZoom
;
return
Matrix4x4
:
:
Translation
(
scrollChange
.
x
scrollChange
.
y
0
)
.
PostScale
(
zoomChange
.
width
zoomChange
.
height
1
)
;
}
uint32_t
AsyncPanZoomController
:
:
GetCheckerboardMagnitude
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
CSSPoint
currentScrollOffset
=
mFrameMetrics
.
GetScrollOffset
(
)
+
mTestAsyncScrollOffset
;
CSSRect
painted
=
mLastContentPaintMetrics
.
GetDisplayPort
(
)
+
mLastContentPaintMetrics
.
GetScrollOffset
(
)
;
CSSRect
visible
=
CSSRect
(
currentScrollOffset
mFrameMetrics
.
CalculateCompositedSizeInCssPixels
(
)
)
;
CSSIntRegion
checkerboard
;
checkerboard
.
Sub
(
RoundedIn
(
visible
)
RoundedOut
(
painted
)
)
;
return
checkerboard
.
Area
(
)
;
}
void
AsyncPanZoomController
:
:
ReportCheckerboard
(
const
TimeStamp
&
aSampleTime
)
{
if
(
mLastCheckerboardReport
=
=
aSampleTime
)
{
return
;
}
mLastCheckerboardReport
=
aSampleTime
;
bool
recordTrace
=
gfxPrefs
:
:
APZRecordCheckerboarding
(
)
;
bool
forTelemetry
=
Telemetry
:
:
CanRecordExtended
(
)
;
uint32_t
magnitude
=
GetCheckerboardMagnitude
(
)
;
MutexAutoLock
lock
(
mCheckerboardEventLock
)
;
if
(
!
mCheckerboardEvent
&
&
(
recordTrace
|
|
forTelemetry
)
)
{
mCheckerboardEvent
=
MakeUnique
<
CheckerboardEvent
>
(
recordTrace
)
;
}
mPotentialCheckerboardTracker
.
InTransform
(
IsTransformingState
(
mState
)
)
;
if
(
magnitude
)
{
mPotentialCheckerboardTracker
.
CheckerboardSeen
(
)
;
}
UpdateCheckerboardEvent
(
lock
magnitude
)
;
}
void
AsyncPanZoomController
:
:
UpdateCheckerboardEvent
(
const
MutexAutoLock
&
aProofOfLock
uint32_t
aMagnitude
)
{
if
(
mCheckerboardEvent
&
&
mCheckerboardEvent
-
>
RecordFrameInfo
(
aMagnitude
)
)
{
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
CHECKERBOARD_SEVERITY
mCheckerboardEvent
-
>
GetSeverity
(
)
)
;
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
CHECKERBOARD_PEAK
mCheckerboardEvent
-
>
GetPeak
(
)
)
;
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
CHECKERBOARD_DURATION
(
uint32_t
)
mCheckerboardEvent
-
>
GetDuration
(
)
.
ToMilliseconds
(
)
)
;
mPotentialCheckerboardTracker
.
CheckerboardDone
(
)
;
if
(
gfxPrefs
:
:
APZRecordCheckerboarding
(
)
)
{
uint32_t
severity
=
mCheckerboardEvent
-
>
GetSeverity
(
)
;
std
:
:
string
log
=
mCheckerboardEvent
-
>
GetLog
(
)
;
CheckerboardEventStorage
:
:
Report
(
severity
log
)
;
}
mCheckerboardEvent
=
nullptr
;
}
}
void
AsyncPanZoomController
:
:
FlushActiveCheckerboardReport
(
)
{
MutexAutoLock
lock
(
mCheckerboardEventLock
)
;
UpdateCheckerboardEvent
(
lock
0
)
;
}
bool
AsyncPanZoomController
:
:
IsCurrentlyCheckerboarding
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
!
gfxPrefs
:
:
APZAllowCheckerboarding
(
)
|
|
mScrollMetadata
.
IsApzForceDisabled
(
)
)
{
return
false
;
}
CSSPoint
currentScrollOffset
=
mFrameMetrics
.
GetScrollOffset
(
)
+
mTestAsyncScrollOffset
;
CSSRect
painted
=
mLastContentPaintMetrics
.
GetDisplayPort
(
)
+
mLastContentPaintMetrics
.
GetScrollOffset
(
)
;
painted
.
Inflate
(
CSSMargin
:
:
FromAppUnits
(
nsMargin
(
1
1
1
1
)
)
)
;
CSSRect
visible
=
CSSRect
(
currentScrollOffset
mFrameMetrics
.
CalculateCompositedSizeInCssPixels
(
)
)
;
if
(
painted
.
Contains
(
visible
)
)
{
return
false
;
}
APZC_LOG_FM
(
mFrameMetrics
"
%
p
is
currently
checkerboarding
(
painted
%
s
visble
%
s
)
"
this
Stringify
(
painted
)
.
c_str
(
)
Stringify
(
visible
)
.
c_str
(
)
)
;
return
true
;
}
void
AsyncPanZoomController
:
:
NotifyLayersUpdated
(
const
ScrollMetadata
&
aScrollMetadata
bool
aIsFirstPaint
bool
aThisLayerTreeUpdated
)
{
AssertOnSamplerThread
(
)
;
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
bool
isDefault
=
mScrollMetadata
.
IsDefault
(
)
;
const
FrameMetrics
&
aLayerMetrics
=
aScrollMetadata
.
GetMetrics
(
)
;
if
(
(
aScrollMetadata
=
=
mLastContentPaintMetadata
)
&
&
!
isDefault
)
{
APZC_LOG
(
"
%
p
NotifyLayersUpdated
short
-
circuit
\
n
"
this
)
;
return
;
}
CSSPoint
lastScrollOffset
=
mLastContentPaintMetadata
.
GetMetrics
(
)
.
GetScrollOffset
(
)
;
bool
userScrolled
=
!
FuzzyEqualsAdditive
(
mFrameMetrics
.
GetScrollOffset
(
)
.
x
lastScrollOffset
.
x
)
|
|
!
FuzzyEqualsAdditive
(
mFrameMetrics
.
GetScrollOffset
(
)
.
y
lastScrollOffset
.
y
)
;
if
(
aLayerMetrics
.
GetScrollUpdateType
(
)
!
=
FrameMetrics
:
:
ScrollOffsetUpdateType
:
:
ePending
)
{
mLastContentPaintMetadata
=
aScrollMetadata
;
}
mScrollMetadata
.
SetScrollParentId
(
aScrollMetadata
.
GetScrollParentId
(
)
)
;
APZC_LOG_FM
(
aLayerMetrics
"
%
p
got
a
NotifyLayersUpdated
with
aIsFirstPaint
=
%
d
aThisLayerTreeUpdated
=
%
d
"
this
aIsFirstPaint
aThisLayerTreeUpdated
)
;
{
MutexAutoLock
lock
(
mCheckerboardEventLock
)
;
if
(
mCheckerboardEvent
&
&
mCheckerboardEvent
-
>
IsRecordingTrace
(
)
)
{
std
:
:
string
str
;
if
(
aThisLayerTreeUpdated
)
{
if
(
!
aLayerMetrics
.
GetPaintRequestTime
(
)
.
IsNull
(
)
)
{
TimeDuration
paintTime
=
TimeStamp
:
:
Now
(
)
-
aLayerMetrics
.
GetPaintRequestTime
(
)
;
std
:
:
stringstream
info
;
info
<
<
"
painttime
"
<
<
paintTime
.
ToMilliseconds
(
)
;
str
=
info
.
str
(
)
;
}
else
{
str
=
"
(
this
layertree
updated
)
"
;
}
}
mCheckerboardEvent
-
>
UpdateRendertraceProperty
(
CheckerboardEvent
:
:
Page
aLayerMetrics
.
GetScrollableRect
(
)
)
;
mCheckerboardEvent
-
>
UpdateRendertraceProperty
(
CheckerboardEvent
:
:
PaintedDisplayPort
aLayerMetrics
.
GetDisplayPort
(
)
+
aLayerMetrics
.
GetScrollOffset
(
)
str
)
;
if
(
!
aLayerMetrics
.
GetCriticalDisplayPort
(
)
.
IsEmpty
(
)
)
{
mCheckerboardEvent
-
>
UpdateRendertraceProperty
(
CheckerboardEvent
:
:
PaintedCriticalDisplayPort
aLayerMetrics
.
GetCriticalDisplayPort
(
)
+
aLayerMetrics
.
GetScrollOffset
(
)
)
;
}
}
}
bool
needContentRepaint
=
false
;
bool
viewportUpdated
=
false
;
if
(
FuzzyEqualsAdditive
(
aLayerMetrics
.
GetCompositionBounds
(
)
.
Width
(
)
mFrameMetrics
.
GetCompositionBounds
(
)
.
Width
(
)
)
&
&
FuzzyEqualsAdditive
(
aLayerMetrics
.
GetCompositionBounds
(
)
.
Height
(
)
mFrameMetrics
.
GetCompositionBounds
(
)
.
Height
(
)
)
)
{
if
(
mFrameMetrics
.
GetViewport
(
)
.
Width
(
)
!
=
aLayerMetrics
.
GetViewport
(
)
.
Width
(
)
|
|
mFrameMetrics
.
GetViewport
(
)
.
Height
(
)
!
=
aLayerMetrics
.
GetViewport
(
)
.
Height
(
)
)
{
needContentRepaint
=
true
;
viewportUpdated
=
true
;
}
mFrameMetrics
.
SetViewport
(
aLayerMetrics
.
GetViewport
(
)
)
;
}
bool
scrollOffsetUpdated
=
aLayerMetrics
.
GetScrollOffsetUpdated
(
)
&
&
(
aLayerMetrics
.
GetScrollGeneration
(
)
!
=
mFrameMetrics
.
GetScrollGeneration
(
)
)
;
if
(
scrollOffsetUpdated
&
&
userScrolled
&
&
aLayerMetrics
.
GetScrollUpdateType
(
)
=
=
FrameMetrics
:
:
ScrollOffsetUpdateType
:
:
eRestore
)
{
APZC_LOG
(
"
%
p
dropping
scroll
update
of
type
eRestore
because
of
user
scroll
\
n
"
this
)
;
scrollOffsetUpdated
=
false
;
}
bool
smoothScrollRequested
=
aLayerMetrics
.
GetDoSmoothScroll
(
)
&
&
(
aLayerMetrics
.
GetScrollGeneration
(
)
!
=
mFrameMetrics
.
GetScrollGeneration
(
)
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
if
(
aLayerMetrics
.
IsRootContent
(
)
)
{
if
(
APZCTreeManager
*
manager
=
GetApzcTreeManager
(
)
)
{
AndroidDynamicToolbarAnimator
*
animator
=
manager
-
>
GetAndroidDynamicToolbarAnimator
(
)
;
MOZ_ASSERT
(
animator
)
;
animator
-
>
MaybeUpdateCompositionSizeAndRootFrameMetrics
(
aLayerMetrics
)
;
}
}
#
endif
if
(
(
aIsFirstPaint
&
&
aThisLayerTreeUpdated
)
|
|
isDefault
)
{
CancelAnimation
(
)
;
mScrollMetadata
=
aScrollMetadata
;
mExpectedGeckoMetrics
=
aLayerMetrics
;
ShareCompositorFrameMetrics
(
)
;
mCompositedScrollOffset
=
mFrameMetrics
.
GetScrollOffset
(
)
;
mCompositedZoom
=
mFrameMetrics
.
GetZoom
(
)
;
if
(
mFrameMetrics
.
GetDisplayPortMargins
(
)
!
=
ScreenMargin
(
)
)
{
APZC_LOG
(
"
%
p
detected
non
-
empty
margins
which
probably
need
updating
\
n
"
this
)
;
needContentRepaint
=
true
;
}
}
else
{
if
(
FuzzyEqualsAdditive
(
mFrameMetrics
.
GetCompositionBounds
(
)
.
Width
(
)
aLayerMetrics
.
GetCompositionBounds
(
)
.
Width
(
)
)
&
&
mFrameMetrics
.
GetDevPixelsPerCSSPixel
(
)
=
=
aLayerMetrics
.
GetDevPixelsPerCSSPixel
(
)
&
&
!
viewportUpdated
)
{
gfxSize
totalResolutionChange
=
aLayerMetrics
.
GetCumulativeResolution
(
)
/
mFrameMetrics
.
GetCumulativeResolution
(
)
;
float
presShellResolutionChange
=
aLayerMetrics
.
GetPresShellResolution
(
)
/
mFrameMetrics
.
GetPresShellResolution
(
)
;
if
(
presShellResolutionChange
!
=
1
.
0f
)
{
needContentRepaint
=
true
;
}
mFrameMetrics
.
ZoomBy
(
totalResolutionChange
/
presShellResolutionChange
)
;
mCompositedZoom
.
xScale
*
=
(
totalResolutionChange
/
presShellResolutionChange
)
.
width
;
mCompositedZoom
.
yScale
*
=
(
totalResolutionChange
/
presShellResolutionChange
)
.
height
;
}
else
{
mFrameMetrics
.
SetZoom
(
aLayerMetrics
.
GetZoom
(
)
)
;
mCompositedZoom
=
aLayerMetrics
.
GetZoom
(
)
;
mFrameMetrics
.
SetDevPixelsPerCSSPixel
(
aLayerMetrics
.
GetDevPixelsPerCSSPixel
(
)
)
;
}
bool
scrollableRectChanged
=
false
;
if
(
!
mFrameMetrics
.
GetScrollableRect
(
)
.
IsEqualEdges
(
aLayerMetrics
.
GetScrollableRect
(
)
)
)
{
mFrameMetrics
.
SetScrollableRect
(
aLayerMetrics
.
GetScrollableRect
(
)
)
;
needContentRepaint
=
true
;
scrollableRectChanged
=
true
;
}
mFrameMetrics
.
SetCompositionBounds
(
aLayerMetrics
.
GetCompositionBounds
(
)
)
;
mFrameMetrics
.
SetRootCompositionSize
(
aLayerMetrics
.
GetRootCompositionSize
(
)
)
;
mFrameMetrics
.
SetPresShellResolution
(
aLayerMetrics
.
GetPresShellResolution
(
)
)
;
mFrameMetrics
.
SetCumulativeResolution
(
aLayerMetrics
.
GetCumulativeResolution
(
)
)
;
mScrollMetadata
.
SetHasScrollgrab
(
aScrollMetadata
.
GetHasScrollgrab
(
)
)
;
mScrollMetadata
.
SetLineScrollAmount
(
aScrollMetadata
.
GetLineScrollAmount
(
)
)
;
mScrollMetadata
.
SetPageScrollAmount
(
aScrollMetadata
.
GetPageScrollAmount
(
)
)
;
mScrollMetadata
.
SetSnapInfo
(
ScrollSnapInfo
(
aScrollMetadata
.
GetSnapInfo
(
)
)
)
;
mScrollMetadata
.
SetScrollClip
(
Nothing
(
)
)
;
mScrollMetadata
.
SetIsLayersIdRoot
(
aScrollMetadata
.
IsLayersIdRoot
(
)
)
;
mScrollMetadata
.
SetUsesContainerScrolling
(
aScrollMetadata
.
UsesContainerScrolling
(
)
)
;
mFrameMetrics
.
SetIsScrollInfoLayer
(
aLayerMetrics
.
IsScrollInfoLayer
(
)
)
;
mScrollMetadata
.
SetForceDisableApz
(
aScrollMetadata
.
IsApzForceDisabled
(
)
)
;
mScrollMetadata
.
SetDisregardedDirection
(
aScrollMetadata
.
GetDisregardedDirection
(
)
)
;
mScrollMetadata
.
SetOverscrollBehavior
(
aScrollMetadata
.
GetOverscrollBehavior
(
)
)
;
if
(
scrollOffsetUpdated
)
{
APZC_LOG
(
"
%
p
updating
scroll
offset
from
%
s
to
%
s
\
n
"
this
ToString
(
mFrameMetrics
.
GetScrollOffset
(
)
)
.
c_str
(
)
ToString
(
aLayerMetrics
.
GetScrollOffset
(
)
)
.
c_str
(
)
)
;
mFrameMetrics
.
CopyScrollInfoFrom
(
aLayerMetrics
)
;
mCompositedScrollOffset
=
mFrameMetrics
.
GetScrollOffset
(
)
;
mExpectedGeckoMetrics
=
aLayerMetrics
;
CancelAnimation
(
)
;
needContentRepaint
=
true
;
}
else
if
(
scrollableRectChanged
)
{
mFrameMetrics
.
ClampAndSetScrollOffset
(
mFrameMetrics
.
GetScrollOffset
(
)
)
;
}
}
if
(
smoothScrollRequested
)
{
APZC_LOG
(
"
%
p
smooth
scrolling
from
%
s
to
%
s
in
state
%
d
\
n
"
this
Stringify
(
mFrameMetrics
.
GetScrollOffset
(
)
)
.
c_str
(
)
Stringify
(
aLayerMetrics
.
GetSmoothScrollOffset
(
)
)
.
c_str
(
)
mState
)
;
mFrameMetrics
.
CopySmoothScrollInfoFrom
(
aLayerMetrics
)
;
needContentRepaint
=
true
;
mExpectedGeckoMetrics
=
aLayerMetrics
;
SmoothScrollTo
(
mFrameMetrics
.
GetSmoothScrollOffset
(
)
)
;
}
if
(
needContentRepaint
)
{
RequestContentRepaint
(
false
)
;
}
UpdateSharedCompositorFrameMetrics
(
)
;
}
const
FrameMetrics
&
AsyncPanZoomController
:
:
GetFrameMetrics
(
)
const
{
mRecursiveMutex
.
AssertCurrentThreadIn
(
)
;
return
mFrameMetrics
;
}
const
ScrollMetadata
&
AsyncPanZoomController
:
:
GetScrollMetadata
(
)
const
{
mRecursiveMutex
.
AssertCurrentThreadIn
(
)
;
return
mScrollMetadata
;
}
void
AsyncPanZoomController
:
:
AssertOnSamplerThread
(
)
const
{
if
(
APZCTreeManager
*
treeManagerLocal
=
GetApzcTreeManager
(
)
)
{
treeManagerLocal
-
>
AssertOnSamplerThread
(
)
;
}
}
APZCTreeManager
*
AsyncPanZoomController
:
:
GetApzcTreeManager
(
)
const
{
mRecursiveMutex
.
AssertNotCurrentThreadIn
(
)
;
return
mTreeManager
;
}
void
AsyncPanZoomController
:
:
ZoomToRect
(
CSSRect
aRect
const
uint32_t
aFlags
)
{
if
(
!
aRect
.
IsFinite
(
)
)
{
NS_WARNING
(
"
ZoomToRect
got
called
with
a
non
-
finite
rect
;
ignoring
.
.
.
"
)
;
return
;
}
else
if
(
aRect
.
IsEmpty
(
)
&
&
(
aFlags
&
DISABLE_ZOOM_OUT
)
)
{
NS_WARNING
(
"
ZoomToRect
got
called
with
an
empty
rect
and
zoom
out
disabled
;
ignoring
.
.
.
"
)
;
return
;
}
MOZ_ASSERT
(
mFrameMetrics
.
IsRootContent
(
)
)
;
MOZ_ASSERT
(
mFrameMetrics
.
GetZoom
(
)
.
AreScalesSame
(
)
)
;
SetState
(
ANIMATING_ZOOM
)
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
ParentLayerRect
compositionBounds
=
mFrameMetrics
.
GetCompositionBounds
(
)
;
CSSRect
cssPageRect
=
mFrameMetrics
.
GetScrollableRect
(
)
;
CSSPoint
scrollOffset
=
mFrameMetrics
.
GetScrollOffset
(
)
;
CSSToParentLayerScale
currentZoom
=
mFrameMetrics
.
GetZoom
(
)
.
ToScaleFactor
(
)
;
CSSToParentLayerScale
targetZoom
;
CSSToParentLayerScale
localMinZoom
(
std
:
:
max
(
mZoomConstraints
.
mMinZoom
.
scale
std
:
:
max
(
compositionBounds
.
Width
(
)
/
cssPageRect
.
Width
(
)
compositionBounds
.
Height
(
)
/
cssPageRect
.
Height
(
)
)
)
)
;
CSSToParentLayerScale
localMaxZoom
=
mZoomConstraints
.
mMaxZoom
;
if
(
!
aRect
.
IsEmpty
(
)
)
{
aRect
=
aRect
.
Intersect
(
cssPageRect
)
;
targetZoom
=
CSSToParentLayerScale
(
std
:
:
min
(
compositionBounds
.
Width
(
)
/
aRect
.
Width
(
)
compositionBounds
.
Height
(
)
/
aRect
.
Height
(
)
)
)
;
}
bool
zoomOut
;
if
(
aFlags
&
DISABLE_ZOOM_OUT
)
{
zoomOut
=
false
;
}
else
{
zoomOut
=
aRect
.
IsEmpty
(
)
|
|
(
currentZoom
=
=
localMaxZoom
&
&
targetZoom
>
=
localMaxZoom
)
|
|
(
currentZoom
=
=
localMinZoom
&
&
targetZoom
<
=
localMinZoom
)
;
}
if
(
zoomOut
)
{
CSSSize
compositedSize
=
mFrameMetrics
.
CalculateCompositedSizeInCssPixels
(
)
;
float
y
=
scrollOffset
.
y
;
float
newHeight
=
cssPageRect
.
Width
(
)
*
(
compositedSize
.
height
/
compositedSize
.
width
)
;
float
dh
=
compositedSize
.
height
-
newHeight
;
aRect
=
CSSRect
(
0
.
0f
y
+
dh
/
2
cssPageRect
.
Width
(
)
newHeight
)
;
aRect
=
aRect
.
Intersect
(
cssPageRect
)
;
targetZoom
=
CSSToParentLayerScale
(
std
:
:
min
(
compositionBounds
.
Width
(
)
/
aRect
.
Width
(
)
compositionBounds
.
Height
(
)
/
aRect
.
Height
(
)
)
)
;
}
targetZoom
.
scale
=
clamped
(
targetZoom
.
scale
localMinZoom
.
scale
localMaxZoom
.
scale
)
;
FrameMetrics
endZoomToMetrics
=
mFrameMetrics
;
if
(
aFlags
&
PAN_INTO_VIEW_ONLY
)
{
targetZoom
=
currentZoom
;
}
else
if
(
aFlags
&
ONLY_ZOOM_TO_DEFAULT_SCALE
)
{
CSSToParentLayerScale
zoomAtDefaultScale
=
mFrameMetrics
.
GetDevPixelsPerCSSPixel
(
)
*
LayoutDeviceToParentLayerScale
(
1
.
0
)
;
if
(
targetZoom
.
scale
>
zoomAtDefaultScale
.
scale
)
{
if
(
currentZoom
.
scale
<
zoomAtDefaultScale
.
scale
)
{
targetZoom
=
zoomAtDefaultScale
;
}
else
{
targetZoom
=
currentZoom
;
}
}
}
endZoomToMetrics
.
SetZoom
(
CSSToParentLayerScale2D
(
targetZoom
)
)
;
CSSSize
sizeAfterZoom
=
endZoomToMetrics
.
CalculateCompositedSizeInCssPixels
(
)
;
if
(
!
zoomOut
&
&
(
sizeAfterZoom
.
height
>
aRect
.
Height
(
)
)
)
{
aRect
.
MoveByY
(
-
(
sizeAfterZoom
.
height
-
aRect
.
Height
(
)
)
*
0
.
5f
)
;
if
(
aRect
.
Y
(
)
<
0
.
0f
)
{
aRect
.
MoveToY
(
0
.
0f
)
;
}
}
if
(
aRect
.
Y
(
)
+
sizeAfterZoom
.
height
>
cssPageRect
.
Height
(
)
)
{
aRect
.
MoveToY
(
std
:
:
max
(
0
.
f
cssPageRect
.
Height
(
)
-
sizeAfterZoom
.
height
)
)
;
}
if
(
aRect
.
X
(
)
+
sizeAfterZoom
.
width
>
cssPageRect
.
Width
(
)
)
{
aRect
.
MoveToX
(
std
:
:
max
(
0
.
f
cssPageRect
.
Width
(
)
-
sizeAfterZoom
.
width
)
)
;
}
endZoomToMetrics
.
SetScrollOffset
(
aRect
.
TopLeft
(
)
)
;
StartAnimation
(
new
ZoomAnimation
(
mFrameMetrics
.
GetScrollOffset
(
)
mFrameMetrics
.
GetZoom
(
)
endZoomToMetrics
.
GetScrollOffset
(
)
endZoomToMetrics
.
GetZoom
(
)
)
)
;
ParentLayerPoint
velocity
(
0
0
)
;
endZoomToMetrics
.
SetDisplayPortMargins
(
CalculatePendingDisplayPort
(
endZoomToMetrics
velocity
)
)
;
endZoomToMetrics
.
SetUseDisplayPortMargins
(
true
)
;
endZoomToMetrics
.
SetPaintRequestTime
(
TimeStamp
:
:
Now
(
)
)
;
endZoomToMetrics
.
SetRepaintDrivenByUserAction
(
true
)
;
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
;
if
(
!
controller
)
{
return
;
}
if
(
controller
-
>
IsRepaintThread
(
)
)
{
RequestContentRepaint
(
endZoomToMetrics
velocity
)
;
}
else
{
auto
func
=
static_cast
<
void
(
AsyncPanZoomController
:
:
*
)
(
const
FrameMetrics
&
const
ParentLayerPoint
&
)
>
(
&
AsyncPanZoomController
:
:
RequestContentRepaint
)
;
controller
-
>
DispatchToRepaintThread
(
NewRunnableMethod
<
FrameMetrics
ParentLayerPoint
>
(
"
layers
:
:
AsyncPanZoomController
:
:
ZoomToRect
"
this
func
endZoomToMetrics
velocity
)
)
;
}
}
}
InputBlockState
*
AsyncPanZoomController
:
:
GetCurrentInputBlock
(
)
const
{
return
GetInputQueue
(
)
-
>
GetCurrentBlock
(
)
;
}
TouchBlockState
*
AsyncPanZoomController
:
:
GetCurrentTouchBlock
(
)
const
{
return
GetInputQueue
(
)
-
>
GetCurrentTouchBlock
(
)
;
}
PanGestureBlockState
*
AsyncPanZoomController
:
:
GetCurrentPanGestureBlock
(
)
const
{
return
GetInputQueue
(
)
-
>
GetCurrentPanGestureBlock
(
)
;
}
void
AsyncPanZoomController
:
:
ResetTouchInputState
(
)
{
MultiTouchInput
cancel
(
MultiTouchInput
:
:
MULTITOUCH_CANCEL
0
TimeStamp
:
:
Now
(
)
0
)
;
RefPtr
<
GestureEventListener
>
listener
=
GetGestureEventListener
(
)
;
if
(
listener
)
{
listener
-
>
HandleInputEvent
(
cancel
)
;
}
CancelAnimationAndGestureState
(
)
;
if
(
TouchBlockState
*
block
=
GetCurrentTouchBlock
(
)
)
{
block
-
>
GetOverscrollHandoffChain
(
)
-
>
ClearOverscroll
(
)
;
}
}
void
AsyncPanZoomController
:
:
CancelAnimationAndGestureState
(
)
{
mX
.
CancelGesture
(
)
;
mY
.
CancelGesture
(
)
;
CancelAnimation
(
CancelAnimationFlags
:
:
ScrollSnap
)
;
}
bool
AsyncPanZoomController
:
:
HasReadyTouchBlock
(
)
const
{
return
GetInputQueue
(
)
-
>
HasReadyTouchBlock
(
)
;
}
void
AsyncPanZoomController
:
:
SetState
(
PanZoomState
aNewState
)
{
PanZoomState
oldState
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
APZC_LOG
(
"
%
p
changing
from
state
%
d
to
%
d
\
n
"
this
mState
aNewState
)
;
oldState
=
mState
;
mState
=
aNewState
;
}
DispatchStateChangeNotification
(
oldState
aNewState
)
;
}
void
AsyncPanZoomController
:
:
DispatchStateChangeNotification
(
PanZoomState
aOldState
PanZoomState
aNewState
)
{
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
mNotificationBlockers
>
0
)
{
return
;
}
}
if
(
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
)
{
if
(
!
IsTransformingState
(
aOldState
)
&
&
IsTransformingState
(
aNewState
)
)
{
controller
-
>
NotifyAPZStateChange
(
GetGuid
(
)
APZStateChange
:
:
eTransformBegin
)
;
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
if
(
gfxPrefs
:
:
HidePluginsForScroll
(
)
&
&
mCompositorController
)
{
mCompositorController
-
>
ScheduleHideAllPluginWindows
(
)
;
}
#
endif
}
else
if
(
IsTransformingState
(
aOldState
)
&
&
!
IsTransformingState
(
aNewState
)
)
{
#
if
defined
(
MOZ_WIDGET_ANDROID
)
if
(
APZCTreeManager
*
manager
=
GetApzcTreeManager
(
)
)
{
AndroidDynamicToolbarAnimator
*
animator
=
manager
-
>
GetAndroidDynamicToolbarAnimator
(
)
;
MOZ_ASSERT
(
animator
)
;
animator
-
>
UpdateRootFrameMetrics
(
mFrameMetrics
)
;
}
#
endif
controller
-
>
NotifyAPZStateChange
(
GetGuid
(
)
APZStateChange
:
:
eTransformEnd
)
;
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
if
(
gfxPrefs
:
:
HidePluginsForScroll
(
)
&
&
mCompositorController
)
{
mCompositorController
-
>
ScheduleShowAllPluginWindows
(
)
;
}
#
endif
}
}
}
bool
AsyncPanZoomController
:
:
IsTransformingState
(
PanZoomState
aState
)
{
return
!
(
aState
=
=
NOTHING
|
|
aState
=
=
TOUCHING
)
;
}
bool
AsyncPanZoomController
:
:
IsInPanningState
(
)
const
{
return
(
mState
=
=
PANNING
|
|
mState
=
=
PANNING_LOCKED_X
|
|
mState
=
=
PANNING_LOCKED_Y
)
;
}
void
AsyncPanZoomController
:
:
UpdateZoomConstraints
(
const
ZoomConstraints
&
aConstraints
)
{
APZC_LOG
(
"
%
p
updating
zoom
constraints
to
%
d
%
d
%
f
%
f
\
n
"
this
aConstraints
.
mAllowZoom
aConstraints
.
mAllowDoubleTapZoom
aConstraints
.
mMinZoom
.
scale
aConstraints
.
mMaxZoom
.
scale
)
;
if
(
IsNaN
(
aConstraints
.
mMinZoom
.
scale
)
|
|
IsNaN
(
aConstraints
.
mMaxZoom
.
scale
)
)
{
NS_WARNING
(
"
APZC
received
zoom
constraints
with
NaN
values
;
dropping
.
.
.
"
)
;
return
;
}
CSSToParentLayerScale
min
=
mFrameMetrics
.
GetDevPixelsPerCSSPixel
(
)
*
kViewportMinScale
/
ParentLayerToScreenScale
(
1
)
;
CSSToParentLayerScale
max
=
mFrameMetrics
.
GetDevPixelsPerCSSPixel
(
)
*
kViewportMaxScale
/
ParentLayerToScreenScale
(
1
)
;
mZoomConstraints
.
mAllowZoom
=
aConstraints
.
mAllowZoom
;
mZoomConstraints
.
mAllowDoubleTapZoom
=
aConstraints
.
mAllowDoubleTapZoom
;
mZoomConstraints
.
mMinZoom
=
(
min
>
aConstraints
.
mMinZoom
?
min
:
aConstraints
.
mMinZoom
)
;
mZoomConstraints
.
mMaxZoom
=
(
max
>
aConstraints
.
mMaxZoom
?
aConstraints
.
mMaxZoom
:
max
)
;
if
(
mZoomConstraints
.
mMaxZoom
<
mZoomConstraints
.
mMinZoom
)
{
mZoomConstraints
.
mMaxZoom
=
mZoomConstraints
.
mMinZoom
;
}
}
ZoomConstraints
AsyncPanZoomController
:
:
GetZoomConstraints
(
)
const
{
return
mZoomConstraints
;
}
void
AsyncPanZoomController
:
:
PostDelayedTask
(
already_AddRefed
<
Runnable
>
aTask
int
aDelayMs
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
RefPtr
<
Runnable
>
task
=
aTask
;
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
;
if
(
controller
)
{
controller
-
>
PostDelayedTask
(
task
.
forget
(
)
aDelayMs
)
;
}
}
bool
AsyncPanZoomController
:
:
Matches
(
const
ScrollableLayerGuid
&
aGuid
)
{
return
aGuid
=
=
GetGuid
(
)
;
}
bool
AsyncPanZoomController
:
:
HasTreeManager
(
const
APZCTreeManager
*
aTreeManager
)
const
{
return
GetApzcTreeManager
(
)
=
=
aTreeManager
;
}
void
AsyncPanZoomController
:
:
GetGuid
(
ScrollableLayerGuid
*
aGuidOut
)
const
{
if
(
aGuidOut
)
{
*
aGuidOut
=
GetGuid
(
)
;
}
}
ScrollableLayerGuid
AsyncPanZoomController
:
:
GetGuid
(
)
const
{
return
ScrollableLayerGuid
(
mLayersId
mFrameMetrics
)
;
}
void
AsyncPanZoomController
:
:
UpdateSharedCompositorFrameMetrics
(
)
{
mRecursiveMutex
.
AssertCurrentThreadIn
(
)
;
FrameMetrics
*
frame
=
mSharedFrameMetricsBuffer
?
static_cast
<
FrameMetrics
*
>
(
mSharedFrameMetricsBuffer
-
>
memory
(
)
)
:
nullptr
;
if
(
frame
&
&
mSharedLock
&
&
gfxPrefs
:
:
ProgressivePaint
(
)
)
{
mSharedLock
-
>
Lock
(
)
;
*
frame
=
mFrameMetrics
;
mSharedLock
-
>
Unlock
(
)
;
}
}
void
AsyncPanZoomController
:
:
ShareCompositorFrameMetrics
(
)
{
AssertOnSamplerThread
(
)
;
if
(
!
mSharedFrameMetricsBuffer
&
&
mMetricsSharingController
&
&
gfxPrefs
:
:
ProgressivePaint
(
)
)
{
mSharedFrameMetricsBuffer
=
new
ipc
:
:
SharedMemoryBasic
;
FrameMetrics
*
frame
=
nullptr
;
mSharedFrameMetricsBuffer
-
>
Create
(
sizeof
(
FrameMetrics
)
)
;
mSharedFrameMetricsBuffer
-
>
Map
(
sizeof
(
FrameMetrics
)
)
;
frame
=
static_cast
<
FrameMetrics
*
>
(
mSharedFrameMetricsBuffer
-
>
memory
(
)
)
;
if
(
frame
)
{
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
*
frame
=
mFrameMetrics
;
}
base
:
:
ProcessId
otherPid
=
mMetricsSharingController
-
>
RemotePid
(
)
;
ipc
:
:
SharedMemoryBasic
:
:
Handle
mem
=
ipc
:
:
SharedMemoryBasic
:
:
NULLHandle
(
)
;
mSharedFrameMetricsBuffer
-
>
ShareToProcess
(
otherPid
&
mem
)
;
mSharedLock
=
new
CrossProcessMutex
(
"
AsyncPanZoomControlLock
"
)
;
CrossProcessMutexHandle
handle
=
mSharedLock
-
>
ShareToProcess
(
otherPid
)
;
if
(
!
mMetricsSharingController
-
>
StartSharingMetrics
(
mem
handle
mLayersId
mAPZCId
)
)
{
APZC_LOG
(
"
%
p
failed
to
share
FrameMetrics
with
content
process
.
"
this
)
;
}
}
}
}
void
AsyncPanZoomController
:
:
SetTestAsyncScrollOffset
(
const
CSSPoint
&
aPoint
)
{
mTestAsyncScrollOffset
=
aPoint
;
ScheduleComposite
(
)
;
}
void
AsyncPanZoomController
:
:
SetTestAsyncZoom
(
const
LayerToParentLayerScale
&
aZoom
)
{
mTestAsyncZoom
=
aZoom
;
ScheduleComposite
(
)
;
}
Maybe
<
CSSPoint
>
AsyncPanZoomController
:
:
FindSnapPointNear
(
const
CSSPoint
&
aDestination
nsIScrollableFrame
:
:
ScrollUnit
aUnit
)
{
mRecursiveMutex
.
AssertCurrentThreadIn
(
)
;
APZC_LOG
(
"
%
p
scroll
snapping
near
%
s
\
n
"
this
Stringify
(
aDestination
)
.
c_str
(
)
)
;
CSSRect
scrollRange
=
mFrameMetrics
.
CalculateScrollRange
(
)
;
if
(
Maybe
<
nsPoint
>
snapPoint
=
ScrollSnapUtils
:
:
GetSnapPointForDestination
(
mScrollMetadata
.
GetSnapInfo
(
)
aUnit
CSSSize
:
:
ToAppUnits
(
mFrameMetrics
.
CalculateCompositedSizeInCssPixels
(
)
)
CSSRect
:
:
ToAppUnits
(
scrollRange
)
CSSPoint
:
:
ToAppUnits
(
mFrameMetrics
.
GetScrollOffset
(
)
)
CSSPoint
:
:
ToAppUnits
(
aDestination
)
)
)
{
CSSPoint
cssSnapPoint
=
CSSPoint
:
:
FromAppUnits
(
snapPoint
.
ref
(
)
)
;
return
Some
(
scrollRange
.
ClampPoint
(
cssSnapPoint
)
)
;
}
return
Nothing
(
)
;
}
void
AsyncPanZoomController
:
:
ScrollSnapNear
(
const
CSSPoint
&
aDestination
)
{
if
(
Maybe
<
CSSPoint
>
snapPoint
=
FindSnapPointNear
(
aDestination
nsIScrollableFrame
:
:
DEVICE_PIXELS
)
)
{
if
(
*
snapPoint
!
=
mFrameMetrics
.
GetScrollOffset
(
)
)
{
APZC_LOG
(
"
%
p
smooth
scrolling
to
snap
point
%
s
\
n
"
this
Stringify
(
*
snapPoint
)
.
c_str
(
)
)
;
SmoothScrollTo
(
*
snapPoint
)
;
}
}
}
void
AsyncPanZoomController
:
:
ScrollSnap
(
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
ScrollSnapNear
(
mFrameMetrics
.
GetScrollOffset
(
)
)
;
}
void
AsyncPanZoomController
:
:
ScrollSnapToDestination
(
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
float
friction
=
gfxPrefs
:
:
APZFlingFriction
(
)
;
ParentLayerPoint
velocity
(
mX
.
GetVelocity
(
)
mY
.
GetVelocity
(
)
)
;
ParentLayerPoint
predictedDelta
;
if
(
velocity
.
x
!
=
0
.
0f
)
{
predictedDelta
.
x
=
-
velocity
.
x
/
log
(
1
.
0
-
friction
)
;
}
if
(
velocity
.
y
!
=
0
.
0f
)
{
predictedDelta
.
y
=
-
velocity
.
y
/
log
(
1
.
0
-
friction
)
;
}
CSSPoint
predictedDestination
=
mFrameMetrics
.
GetScrollOffset
(
)
+
predictedDelta
/
mFrameMetrics
.
GetZoom
(
)
;
bool
flingWillOverscroll
=
IsOverscrolled
(
)
&
&
(
(
velocity
.
x
*
mX
.
GetOverscroll
(
)
>
=
0
)
|
|
(
velocity
.
y
*
mY
.
GetOverscroll
(
)
>
=
0
)
)
;
if
(
!
flingWillOverscroll
)
{
APZC_LOG
(
"
%
p
fling
snapping
.
friction
:
%
f
velocity
:
%
f
%
f
"
"
predictedDelta
:
%
f
%
f
position
:
%
f
%
f
"
"
predictedDestination
:
%
f
%
f
\
n
"
this
friction
velocity
.
x
velocity
.
y
(
float
)
predictedDelta
.
x
(
float
)
predictedDelta
.
y
(
float
)
mFrameMetrics
.
GetScrollOffset
(
)
.
x
(
float
)
mFrameMetrics
.
GetScrollOffset
(
)
.
y
(
float
)
predictedDestination
.
x
(
float
)
predictedDestination
.
y
)
;
ScrollSnapNear
(
predictedDestination
)
;
}
}
bool
AsyncPanZoomController
:
:
MaybeAdjustDeltaForScrollSnapping
(
const
ScrollWheelInput
&
aEvent
ParentLayerPoint
&
aDelta
CSSPoint
&
aStartPosition
)
{
if
(
aEvent
.
mDeltaType
=
=
ScrollWheelInput
:
:
SCROLLDELTA_PIXEL
)
{
return
false
;
}
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
CSSToParentLayerScale2D
zoom
=
mFrameMetrics
.
GetZoom
(
)
;
CSSPoint
destination
=
mFrameMetrics
.
CalculateScrollRange
(
)
.
ClampPoint
(
aStartPosition
+
(
aDelta
/
zoom
)
)
;
nsIScrollableFrame
:
:
ScrollUnit
unit
=
ScrollWheelInput
:
:
ScrollUnitForDeltaType
(
aEvent
.
mDeltaType
)
;
if
(
Maybe
<
CSSPoint
>
snapPoint
=
FindSnapPointNear
(
destination
unit
)
)
{
aDelta
=
(
*
snapPoint
-
aStartPosition
)
*
zoom
;
aStartPosition
=
*
snapPoint
;
return
true
;
}
return
false
;
}
bool
AsyncPanZoomController
:
:
MaybeAdjustDestinationForScrollSnapping
(
const
KeyboardInput
&
aEvent
CSSPoint
&
aDestination
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
nsIScrollableFrame
:
:
ScrollUnit
unit
=
KeyboardScrollAction
:
:
GetScrollUnit
(
aEvent
.
mAction
.
mType
)
;
if
(
Maybe
<
CSSPoint
>
snapPoint
=
FindSnapPointNear
(
aDestination
unit
)
)
{
aDestination
=
*
snapPoint
;
return
true
;
}
return
false
;
}
}
}
