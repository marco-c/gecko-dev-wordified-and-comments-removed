#
include
"
AsyncPanZoomController
.
h
"
#
include
<
math
.
h
>
#
include
<
stdint
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
algorithm
>
#
include
"
APZCTreeManager
.
h
"
#
include
"
AsyncPanZoomAnimation
.
h
"
#
include
"
AutoDirWheelDeltaAdjuster
.
h
"
#
include
"
AutoscrollAnimation
.
h
"
#
include
"
Axis
.
h
"
#
include
"
CheckerboardEvent
.
h
"
#
include
"
Compositor
.
h
"
#
include
"
DesktopFlingPhysics
.
h
"
#
include
"
FrameMetrics
.
h
"
#
include
"
GenericFlingAnimation
.
h
"
#
include
"
GestureEventListener
.
h
"
#
include
"
HitTestingTreeNode
.
h
"
#
include
"
InputData
.
h
"
#
include
"
InputBlockState
.
h
"
#
include
"
InputQueue
.
h
"
#
include
"
Overscroll
.
h
"
#
include
"
OverscrollHandoffState
.
h
"
#
include
"
SimpleVelocityTracker
.
h
"
#
include
"
Units
.
h
"
#
include
"
UnitTransforms
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
gfxTypes
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
ComputedTimingFunction
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
RecursiveMutex
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ScrollTypes
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
include
"
mozilla
/
StaticPrefs_general
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
StaticPrefs_mousewheel
.
h
"
#
include
"
mozilla
/
StaticPrefs_layers
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
StaticPrefs_slider
.
h
"
#
include
"
mozilla
/
StaticPrefs_test
.
h
"
#
include
"
mozilla
/
StaticPrefs_toolkit
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
dom
/
CheckerboardReportService
.
h
"
#
include
"
mozilla
/
dom
/
Touch
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
gfx
/
BasePoint
.
h
"
#
include
"
mozilla
/
gfx
/
BaseRect
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
ScaleFactor
.
h
"
#
include
"
mozilla
/
layers
/
APZThreadUtils
.
h
"
#
include
"
mozilla
/
layers
/
APZUtils
.
h
"
#
include
"
mozilla
/
layers
/
CompositorController
.
h
"
#
include
"
mozilla
/
layers
/
DirectionUtils
.
h
"
#
include
"
mozilla
/
layers
/
LayerTransactionParent
.
h
"
#
include
"
mozilla
/
layers
/
MetricsSharingController
.
h
"
#
include
"
mozilla
/
layers
/
ScrollInputMethods
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsMathUtils
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsTimingFunction
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsViewportInfo
.
h
"
#
include
"
prsystem
.
h
"
#
include
"
SharedMemoryBasic
.
h
"
#
include
"
ScrollSnap
.
h
"
#
include
"
ScrollAnimationPhysics
.
h
"
#
include
"
SmoothMsdScrollAnimation
.
h
"
#
include
"
SmoothScrollAnimation
.
h
"
#
include
"
WheelScrollAnimation
.
h
"
#
if
defined
(
MOZ_WIDGET_ANDROID
)
#
include
"
AndroidAPZ
.
h
"
#
endif
static
mozilla
:
:
LazyLogModule
sApzCtlLog
(
"
apz
.
controller
"
)
;
#
define
APZC_LOG
(
.
.
.
)
MOZ_LOG
(
sApzCtlLog
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
#
define
APZC_LOGV
(
.
.
.
)
MOZ_LOG
(
sApzCtlLog
LogLevel
:
:
Verbose
(
__VA_ARGS__
)
)
#
define
APZC_LOG_FM_COMMON
(
fm
prefix
level
.
.
.
)
\
if
(
MOZ_LOG_TEST
(
sApzCtlLog
level
)
)
{
\
std
:
:
stringstream
ss
;
\
ss
<
<
nsPrintfCString
(
prefix
__VA_ARGS__
)
.
get
(
)
<
<
"
:
"
<
<
fm
;
\
MOZ_LOG
(
sApzCtlLog
level
(
"
%
s
\
n
"
ss
.
str
(
)
.
c_str
(
)
)
)
;
\
}
#
define
APZC_LOG_FM
(
fm
prefix
.
.
.
)
\
APZC_LOG_FM_COMMON
(
fm
prefix
LogLevel
:
:
Debug
__VA_ARGS__
)
#
define
APZC_LOGV_FM
(
fm
prefix
.
.
.
)
\
APZC_LOG_FM_COMMON
(
fm
prefix
LogLevel
:
:
Verbose
__VA_ARGS__
)
namespace
mozilla
{
namespace
layers
{
typedef
mozilla
:
:
layers
:
:
AllowedTouchBehavior
AllowedTouchBehavior
;
typedef
GeckoContentController
:
:
APZStateChange
APZStateChange
;
typedef
GeckoContentController
:
:
TapType
TapType
;
typedef
mozilla
:
:
gfx
:
:
Point
Point
;
typedef
mozilla
:
:
gfx
:
:
Matrix4x4
Matrix4x4
;
#
ifdef
MOZ_WIDGET_ANDROID
typedef
WidgetOverscrollEffect
OverscrollEffect
;
typedef
AndroidSpecificState
PlatformSpecificState
;
#
else
typedef
GenericOverscrollEffect
OverscrollEffect
;
typedef
PlatformSpecificStateBase
PlatformSpecificState
;
#
endif
StaticAutoPtr
<
ComputedTimingFunction
>
gZoomAnimationFunction
;
StaticAutoPtr
<
ComputedTimingFunction
>
gVelocityCurveFunction
;
static
const
double
kDefaultEstimatedPaintDurationMs
=
50
;
static
bool
gIsHighMemSystem
=
false
;
static
bool
IsHighMemSystem
(
)
{
return
gIsHighMemSystem
;
}
static
uint32_t
sAsyncPanZoomControllerCount
=
0
;
AsyncPanZoomAnimation
*
PlatformSpecificStateBase
:
:
CreateFlingAnimation
(
AsyncPanZoomController
&
aApzc
const
FlingHandoffState
&
aHandoffState
float
aPLPPI
)
{
return
new
GenericFlingAnimation
<
DesktopFlingPhysics
>
(
aApzc
aHandoffState
aPLPPI
)
;
}
UniquePtr
<
VelocityTracker
>
PlatformSpecificStateBase
:
:
CreateVelocityTracker
(
Axis
*
aAxis
)
{
return
MakeUnique
<
SimpleVelocityTracker
>
(
aAxis
)
;
}
SampleTime
AsyncPanZoomController
:
:
GetFrameTime
(
)
const
{
APZCTreeManager
*
treeManagerLocal
=
GetApzcTreeManager
(
)
;
return
treeManagerLocal
?
treeManagerLocal
-
>
GetFrameTime
(
)
:
SampleTime
:
:
FromNow
(
)
;
}
class
MOZ_STACK_CLASS
StateChangeNotificationBlocker
final
{
public
:
explicit
StateChangeNotificationBlocker
(
AsyncPanZoomController
*
aApzc
)
:
mApzc
(
aApzc
)
{
RecursiveMutexAutoLock
lock
(
mApzc
-
>
mRecursiveMutex
)
;
mInitialState
=
mApzc
-
>
mState
;
mApzc
-
>
mNotificationBlockers
+
+
;
}
~
StateChangeNotificationBlocker
(
)
{
AsyncPanZoomController
:
:
PanZoomState
newState
;
{
RecursiveMutexAutoLock
lock
(
mApzc
-
>
mRecursiveMutex
)
;
mApzc
-
>
mNotificationBlockers
-
-
;
newState
=
mApzc
-
>
mState
;
}
mApzc
-
>
DispatchStateChangeNotification
(
mInitialState
newState
)
;
}
private
:
AsyncPanZoomController
*
mApzc
;
AsyncPanZoomController
:
:
PanZoomState
mInitialState
;
}
;
class
MOZ_RAII
AutoApplyAsyncTestAttributes
final
{
public
:
explicit
AutoApplyAsyncTestAttributes
(
const
AsyncPanZoomController
*
const
RecursiveMutexAutoLock
&
aProofOfLock
)
;
~
AutoApplyAsyncTestAttributes
(
)
;
private
:
AsyncPanZoomController
*
mApzc
;
FrameMetrics
mPrevFrameMetrics
;
ParentLayerPoint
mPrevOverscroll
;
const
RecursiveMutexAutoLock
&
mProofOfLock
;
}
;
AutoApplyAsyncTestAttributes
:
:
AutoApplyAsyncTestAttributes
(
const
AsyncPanZoomController
*
aApzc
const
RecursiveMutexAutoLock
&
aProofOfLock
)
:
mApzc
(
const_cast
<
AsyncPanZoomController
*
>
(
aApzc
)
)
mPrevFrameMetrics
(
aApzc
-
>
Metrics
(
)
)
mPrevOverscroll
(
aApzc
-
>
GetOverscrollAmountInternal
(
)
)
mProofOfLock
(
aProofOfLock
)
{
mApzc
-
>
ApplyAsyncTestAttributes
(
aProofOfLock
)
;
}
AutoApplyAsyncTestAttributes
:
:
~
AutoApplyAsyncTestAttributes
(
)
{
mApzc
-
>
UnapplyAsyncTestAttributes
(
mProofOfLock
mPrevFrameMetrics
mPrevOverscroll
)
;
}
class
ZoomAnimation
:
public
AsyncPanZoomAnimation
{
public
:
ZoomAnimation
(
AsyncPanZoomController
&
aApzc
const
CSSPoint
&
aStartOffset
const
CSSToParentLayerScale2D
&
aStartZoom
const
CSSPoint
&
aEndOffset
const
CSSToParentLayerScale2D
&
aEndZoom
)
:
mApzc
(
aApzc
)
mTotalDuration
(
TimeDuration
:
:
FromMilliseconds
(
StaticPrefs
:
:
apz_zoom_animation_duration_ms
(
)
)
)
mStartOffset
(
aStartOffset
)
mStartZoom
(
aStartZoom
)
mEndOffset
(
aEndOffset
)
mEndZoom
(
aEndZoom
)
{
}
virtual
bool
DoSample
(
FrameMetrics
&
aFrameMetrics
const
TimeDuration
&
aDelta
)
override
{
mDuration
+
=
aDelta
;
double
animPosition
=
mDuration
/
mTotalDuration
;
if
(
animPosition
>
=
1
.
0
)
{
aFrameMetrics
.
SetZoom
(
mEndZoom
)
;
mApzc
.
SetVisualScrollOffset
(
mEndOffset
)
;
return
false
;
}
float
sampledPosition
=
gZoomAnimationFunction
-
>
GetValue
(
animPosition
ComputedTimingFunction
:
:
BeforeFlag
:
:
Unset
)
;
if
(
mStartZoom
=
=
CSSToParentLayerScale2D
(
0
0
)
|
|
mEndZoom
=
=
CSSToParentLayerScale2D
(
0
0
)
)
{
return
false
;
}
aFrameMetrics
.
SetZoom
(
CSSToParentLayerScale2D
(
1
/
(
sampledPosition
/
mEndZoom
.
xScale
+
(
1
-
sampledPosition
)
/
mStartZoom
.
xScale
)
1
/
(
sampledPosition
/
mEndZoom
.
yScale
+
(
1
-
sampledPosition
)
/
mStartZoom
.
yScale
)
)
)
;
mApzc
.
SetVisualScrollOffset
(
CSSPoint
:
:
FromUnknownPoint
(
gfx
:
:
Point
(
mEndOffset
.
x
*
sampledPosition
+
mStartOffset
.
x
*
(
1
-
sampledPosition
)
mEndOffset
.
y
*
sampledPosition
+
mStartOffset
.
y
*
(
1
-
sampledPosition
)
)
)
)
;
return
true
;
}
virtual
bool
WantsRepaints
(
)
override
{
return
true
;
}
private
:
AsyncPanZoomController
&
mApzc
;
TimeDuration
mDuration
;
const
TimeDuration
mTotalDuration
;
CSSPoint
mStartOffset
;
CSSToParentLayerScale2D
mStartZoom
;
CSSPoint
mEndOffset
;
CSSToParentLayerScale2D
mEndZoom
;
}
;
void
AsyncPanZoomController
:
:
InitializeGlobalState
(
)
{
static
bool
sInitialized
=
false
;
if
(
sInitialized
)
return
;
sInitialized
=
true
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
gZoomAnimationFunction
=
new
ComputedTimingFunction
(
nsTimingFunction
(
StyleTimingKeyword
:
:
Ease
)
)
;
ClearOnShutdown
(
&
gZoomAnimationFunction
)
;
gVelocityCurveFunction
=
new
ComputedTimingFunction
(
nsTimingFunction
(
StaticPrefs
:
:
apz_fling_curve_function_x1_AtStartup
(
)
StaticPrefs
:
:
apz_fling_curve_function_y1_AtStartup
(
)
StaticPrefs
:
:
apz_fling_curve_function_x2_AtStartup
(
)
StaticPrefs
:
:
apz_fling_curve_function_y2_AtStartup
(
)
)
)
;
ClearOnShutdown
(
&
gVelocityCurveFunction
)
;
uint64_t
sysmem
=
PR_GetPhysicalMemorySize
(
)
;
uint64_t
threshold
=
1LL
<
<
32
;
gIsHighMemSystem
=
sysmem
>
=
threshold
;
PlatformSpecificState
:
:
InitializeGlobalState
(
)
;
}
AsyncPanZoomController
:
:
AsyncPanZoomController
(
LayersId
aLayersId
APZCTreeManager
*
aTreeManager
const
RefPtr
<
InputQueue
>
&
aInputQueue
GeckoContentController
*
aGeckoContentController
GestureBehavior
aGestures
)
:
mLayersId
(
aLayersId
)
mGeckoContentController
(
aGeckoContentController
)
mRefPtrMonitor
(
"
RefPtrMonitor
"
)
mTreeManager
(
aTreeManager
)
mRecursiveMutex
(
"
AsyncPanZoomController
"
)
mLastContentPaintMetrics
(
mLastContentPaintMetadata
.
GetMetrics
(
)
)
mX
(
this
)
mY
(
this
)
mPanDirRestricted
(
false
)
mPinchLocked
(
false
)
mPinchEventBuffer
(
TimeDuration
:
:
FromMilliseconds
(
StaticPrefs
:
:
apz_pinch_lock_buffer_max_age_AtStartup
(
)
)
)
mZoomConstraints
(
false
false
mScrollMetadata
.
GetMetrics
(
)
.
GetDevPixelsPerCSSPixel
(
)
*
kViewportMinScale
/
ParentLayerToScreenScale
(
1
)
mScrollMetadata
.
GetMetrics
(
)
.
GetDevPixelsPerCSSPixel
(
)
*
kViewportMaxScale
/
ParentLayerToScreenScale
(
1
)
)
mLastSampleTime
(
GetFrameTime
(
)
)
mLastCheckerboardReport
(
GetFrameTime
(
)
)
mOverscrollEffect
(
MakeUnique
<
OverscrollEffect
>
(
*
this
)
)
mState
(
NOTHING
)
mNotificationBlockers
(
0
)
mInputQueue
(
aInputQueue
)
mPinchPaintTimerSet
(
false
)
mAPZCId
(
sAsyncPanZoomControllerCount
+
+
)
mSharedLock
(
nullptr
)
mTestAttributeAppliers
(
0
)
mAsyncTransformAppliedToContent
(
false
)
mTestHasAsyncKeyScrolled
(
false
)
mCheckerboardEventLock
(
"
APZCBELock
"
)
{
if
(
aGestures
=
=
USE_GESTURE_DETECTOR
)
{
mGestureEventListener
=
new
GestureEventListener
(
this
)
;
}
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
mSampledState
.
emplace_back
(
)
;
}
AsyncPanZoomController
:
:
~
AsyncPanZoomController
(
)
{
MOZ_ASSERT
(
IsDestroyed
(
)
)
;
}
PlatformSpecificStateBase
*
AsyncPanZoomController
:
:
GetPlatformSpecificState
(
)
{
if
(
!
mPlatformSpecificState
)
{
mPlatformSpecificState
=
MakeUnique
<
PlatformSpecificState
>
(
)
;
}
return
mPlatformSpecificState
.
get
(
)
;
}
already_AddRefed
<
GeckoContentController
>
AsyncPanZoomController
:
:
GetGeckoContentController
(
)
const
{
MonitorAutoLock
lock
(
mRefPtrMonitor
)
;
RefPtr
<
GeckoContentController
>
controller
=
mGeckoContentController
;
return
controller
.
forget
(
)
;
}
already_AddRefed
<
GestureEventListener
>
AsyncPanZoomController
:
:
GetGestureEventListener
(
)
const
{
MonitorAutoLock
lock
(
mRefPtrMonitor
)
;
RefPtr
<
GestureEventListener
>
listener
=
mGestureEventListener
;
return
listener
.
forget
(
)
;
}
const
RefPtr
<
InputQueue
>
&
AsyncPanZoomController
:
:
GetInputQueue
(
)
const
{
return
mInputQueue
;
}
void
AsyncPanZoomController
:
:
Destroy
(
)
{
AssertOnUpdaterThread
(
)
;
CancelAnimation
(
CancelAnimationFlags
:
:
ScrollSnap
)
;
{
MonitorAutoLock
lock
(
mRefPtrMonitor
)
;
mGeckoContentController
=
nullptr
;
mGestureEventListener
=
nullptr
;
}
mParent
=
nullptr
;
mTreeManager
=
nullptr
;
if
(
mMetricsSharingController
&
&
mSharedFrameMetricsBuffer
)
{
Unused
<
<
mMetricsSharingController
-
>
StopSharingMetrics
(
GetScrollId
(
)
mAPZCId
)
;
}
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
mSharedFrameMetricsBuffer
=
nullptr
;
delete
mSharedLock
;
mSharedLock
=
nullptr
;
}
}
bool
AsyncPanZoomController
:
:
IsDestroyed
(
)
const
{
return
mTreeManager
=
=
nullptr
;
}
float
AsyncPanZoomController
:
:
GetDPI
(
)
const
{
if
(
APZCTreeManager
*
localPtr
=
mTreeManager
)
{
return
localPtr
-
>
GetDPI
(
)
;
}
return
0
.
0
;
}
ScreenCoord
AsyncPanZoomController
:
:
GetTouchStartTolerance
(
)
const
{
return
(
StaticPrefs
:
:
apz_touch_start_tolerance
(
)
*
GetDPI
(
)
)
;
}
ScreenCoord
AsyncPanZoomController
:
:
GetTouchMoveTolerance
(
)
const
{
return
(
StaticPrefs
:
:
apz_touch_move_tolerance
(
)
*
GetDPI
(
)
)
;
}
ScreenCoord
AsyncPanZoomController
:
:
GetSecondTapTolerance
(
)
const
{
return
(
StaticPrefs
:
:
apz_second_tap_tolerance
(
)
*
GetDPI
(
)
)
;
}
AsyncPanZoomController
:
:
AxisLockMode
AsyncPanZoomController
:
:
GetAxisLockMode
(
)
{
return
static_cast
<
AxisLockMode
>
(
StaticPrefs
:
:
apz_axis_lock_mode
(
)
)
;
}
AsyncPanZoomController
:
:
PinchLockMode
AsyncPanZoomController
:
:
GetPinchLockMode
(
)
{
return
static_cast
<
PinchLockMode
>
(
StaticPrefs
:
:
apz_pinch_lock_mode
(
)
)
;
}
bool
AsyncPanZoomController
:
:
ArePointerEventsConsumable
(
TouchBlockState
*
aBlock
const
MultiTouchInput
&
aInput
)
{
uint32_t
touchPoints
=
aInput
.
mTouches
.
Length
(
)
;
if
(
touchPoints
=
=
0
)
{
return
false
;
}
bool
pannableX
=
aBlock
-
>
TouchActionAllowsPanningX
(
)
&
&
aBlock
-
>
GetOverscrollHandoffChain
(
)
-
>
CanScrollInDirection
(
this
ScrollDirection
:
:
eHorizontal
)
;
bool
pannableY
=
(
aBlock
-
>
TouchActionAllowsPanningY
(
)
&
&
(
aBlock
-
>
GetOverscrollHandoffChain
(
)
-
>
CanScrollInDirection
(
this
ScrollDirection
:
:
eVertical
)
|
|
(
IsRootContent
(
)
&
&
CanVerticalScrollWithDynamicToolbar
(
)
)
)
)
;
bool
pannable
;
Maybe
<
ScrollDirection
>
panDirection
=
aBlock
-
>
GetBestGuessPanDirection
(
aInput
)
;
if
(
panDirection
=
=
Some
(
ScrollDirection
:
:
eVertical
)
)
{
pannable
=
pannableY
;
}
else
if
(
panDirection
=
=
Some
(
ScrollDirection
:
:
eHorizontal
)
)
{
pannable
=
pannableX
;
}
else
{
pannable
=
pannableX
|
|
pannableY
;
}
if
(
touchPoints
=
=
1
)
{
return
pannable
;
}
bool
zoomable
=
ZoomConstraintsAllowZoom
(
)
;
zoomable
&
=
(
aBlock
-
>
TouchActionAllowsPinchZoom
(
)
)
;
return
pannable
|
|
zoomable
;
}
nsEventStatus
AsyncPanZoomController
:
:
HandleDragEvent
(
const
MouseInput
&
aEvent
const
AsyncDragMetrics
&
aDragMetrics
CSSCoord
aInitialThumbPos
)
{
bool
isRDMTouchSimulationActive
=
false
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
isRDMTouchSimulationActive
=
mScrollMetadata
.
GetIsRDMTouchSimulationActive
(
)
;
}
if
(
!
StaticPrefs
:
:
apz_drag_enabled
(
)
|
|
isRDMTouchSimulationActive
)
{
return
nsEventStatus_eIgnore
;
}
if
(
!
GetApzcTreeManager
(
)
)
{
return
nsEventStatus_eConsumeNoDefault
;
}
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
aEvent
.
mType
=
=
MouseInput
:
:
MouseType
:
:
MOUSE_UP
)
{
if
(
mState
=
=
SCROLLBAR_DRAG
)
{
APZC_LOG
(
"
%
p
ending
drag
\
n
"
this
)
;
SetState
(
NOTHING
)
;
}
SnapBackIfOverscrolled
(
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
}
HitTestingTreeNodeAutoLock
node
;
GetApzcTreeManager
(
)
-
>
FindScrollThumbNode
(
aDragMetrics
mLayersId
node
)
;
if
(
!
node
)
{
APZC_LOG
(
"
%
p
unable
to
find
scrollthumb
node
with
viewid
%
"
PRIu64
"
\
n
"
this
aDragMetrics
.
mViewId
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
if
(
aEvent
.
mType
=
=
MouseInput
:
:
MouseType
:
:
MOUSE_DOWN
)
{
APZC_LOG
(
"
%
p
starting
scrollbar
drag
\
n
"
this
)
;
SetState
(
SCROLLBAR_DRAG
)
;
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
SCROLL_INPUT_METHODS
(
uint32_t
)
ScrollInputMethod
:
:
ApzScrollbarDrag
)
;
}
if
(
aEvent
.
mType
!
=
MouseInput
:
:
MouseType
:
:
MOUSE_MOVE
)
{
APZC_LOG
(
"
%
p
discarding
event
of
type
%
d
\
n
"
this
aEvent
.
mType
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
const
ScrollbarData
&
scrollbarData
=
node
-
>
GetScrollbarData
(
)
;
MOZ_ASSERT
(
scrollbarData
.
mScrollbarLayerType
=
=
layers
:
:
ScrollbarLayerType
:
:
Thumb
)
;
MOZ_ASSERT
(
scrollbarData
.
mDirection
.
isSome
(
)
)
;
ScrollDirection
direction
=
*
scrollbarData
.
mDirection
;
bool
isMouseAwayFromThumb
=
false
;
if
(
int
snapMultiplier
=
StaticPrefs
:
:
slider_snapMultiplier_AtStartup
(
)
)
{
ParentLayerRect
thumbRect
=
(
node
-
>
GetTransform
(
)
*
AsyncTransformMatrix
(
)
)
.
TransformBounds
(
LayerRect
(
node
-
>
GetVisibleRegion
(
)
.
GetBounds
(
)
)
)
;
ScrollDirection
otherDirection
=
GetPerpendicularDirection
(
direction
)
;
ParentLayerCoord
distance
=
GetAxisStart
(
otherDirection
thumbRect
.
DistanceTo
(
aEvent
.
mLocalOrigin
)
)
;
ParentLayerCoord
thumbWidth
=
GetAxisLength
(
otherDirection
thumbRect
)
;
if
(
thumbWidth
>
0
&
&
thumbWidth
*
snapMultiplier
<
distance
)
{
isMouseAwayFromThumb
=
true
;
APZC_LOG
(
"
%
p
determined
mouse
is
away
from
thumb
will
snap
\
n
"
this
)
;
}
}
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
CSSCoord
thumbPosition
;
if
(
isMouseAwayFromThumb
)
{
thumbPosition
=
aInitialThumbPos
;
}
else
{
thumbPosition
=
ConvertScrollbarPoint
(
aEvent
.
mLocalOrigin
scrollbarData
)
-
aDragMetrics
.
mScrollbarDragOffset
;
}
CSSCoord
maxThumbPos
=
scrollbarData
.
mScrollTrackLength
;
maxThumbPos
-
=
scrollbarData
.
mThumbLength
;
float
scrollPercent
=
maxThumbPos
.
value
=
=
0
.
0f
?
0
.
0f
:
(
float
)
(
thumbPosition
/
maxThumbPos
)
;
APZC_LOG
(
"
%
p
scrollbar
dragged
to
%
f
percent
\
n
"
this
scrollPercent
)
;
CSSCoord
minScrollPosition
=
GetAxisStart
(
direction
Metrics
(
)
.
GetScrollableRect
(
)
.
TopLeft
(
)
)
;
CSSCoord
maxScrollPosition
=
GetAxisStart
(
direction
Metrics
(
)
.
GetScrollableRect
(
)
.
BottomRight
(
)
)
-
GetAxisLength
(
direction
Metrics
(
)
.
CalculateCompositedSizeInCssPixels
(
)
)
;
CSSCoord
scrollPosition
=
minScrollPosition
+
(
scrollPercent
*
(
maxScrollPosition
-
minScrollPosition
)
)
;
scrollPosition
=
std
:
:
max
(
scrollPosition
minScrollPosition
)
;
scrollPosition
=
std
:
:
min
(
scrollPosition
maxScrollPosition
)
;
CSSPoint
scrollOffset
=
Metrics
(
)
.
GetVisualScrollOffset
(
)
;
if
(
direction
=
=
ScrollDirection
:
:
eHorizontal
)
{
scrollOffset
.
x
=
scrollPosition
;
}
else
{
scrollOffset
.
y
=
scrollPosition
;
}
APZC_LOG
(
"
%
p
set
scroll
offset
to
%
s
from
scrollbar
drag
\
n
"
this
ToString
(
scrollOffset
)
.
c_str
(
)
)
;
SetVisualScrollOffset
(
scrollOffset
)
;
ScheduleCompositeAndMaybeRepaint
(
)
;
UpdateSharedCompositorFrameMetrics
(
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
HandleInputEvent
(
const
InputData
&
aEvent
const
ScreenToParentLayerMatrix4x4
&
aTransformToApzc
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
nsEventStatus
rv
=
nsEventStatus_eIgnore
;
switch
(
aEvent
.
mInputType
)
{
case
MULTITOUCH_INPUT
:
{
MultiTouchInput
multiTouchInput
=
aEvent
.
AsMultiTouchInput
(
)
;
RefPtr
<
GestureEventListener
>
listener
=
GetGestureEventListener
(
)
;
if
(
listener
)
{
rv
=
listener
-
>
HandleInputEvent
(
multiTouchInput
)
;
if
(
rv
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
rv
;
}
}
if
(
!
multiTouchInput
.
TransformToLocal
(
aTransformToApzc
)
)
{
return
rv
;
}
switch
(
multiTouchInput
.
mType
)
{
case
MultiTouchInput
:
:
MULTITOUCH_START
:
rv
=
OnTouchStart
(
multiTouchInput
)
;
break
;
case
MultiTouchInput
:
:
MULTITOUCH_MOVE
:
rv
=
OnTouchMove
(
multiTouchInput
)
;
break
;
case
MultiTouchInput
:
:
MULTITOUCH_END
:
rv
=
OnTouchEnd
(
multiTouchInput
)
;
break
;
case
MultiTouchInput
:
:
MULTITOUCH_CANCEL
:
rv
=
OnTouchCancel
(
multiTouchInput
)
;
break
;
}
break
;
}
case
PANGESTURE_INPUT
:
{
PanGestureInput
panGestureInput
=
aEvent
.
AsPanGestureInput
(
)
;
if
(
!
panGestureInput
.
TransformToLocal
(
aTransformToApzc
)
)
{
return
rv
;
}
switch
(
panGestureInput
.
mType
)
{
case
PanGestureInput
:
:
PANGESTURE_MAYSTART
:
rv
=
OnPanMayBegin
(
panGestureInput
)
;
break
;
case
PanGestureInput
:
:
PANGESTURE_CANCELLED
:
rv
=
OnPanCancelled
(
panGestureInput
)
;
break
;
case
PanGestureInput
:
:
PANGESTURE_START
:
rv
=
OnPanBegin
(
panGestureInput
)
;
break
;
case
PanGestureInput
:
:
PANGESTURE_PAN
:
rv
=
OnPan
(
panGestureInput
FingersOnTouchpad
:
:
Yes
)
;
break
;
case
PanGestureInput
:
:
PANGESTURE_END
:
rv
=
OnPanEnd
(
panGestureInput
)
;
break
;
case
PanGestureInput
:
:
PANGESTURE_MOMENTUMSTART
:
rv
=
OnPanMomentumStart
(
panGestureInput
)
;
break
;
case
PanGestureInput
:
:
PANGESTURE_MOMENTUMPAN
:
rv
=
OnPan
(
panGestureInput
FingersOnTouchpad
:
:
No
)
;
break
;
case
PanGestureInput
:
:
PANGESTURE_MOMENTUMEND
:
rv
=
OnPanMomentumEnd
(
panGestureInput
)
;
break
;
case
PanGestureInput
:
:
PANGESTURE_INTERRUPTED
:
rv
=
OnPanInterrupted
(
panGestureInput
)
;
break
;
}
break
;
}
case
MOUSE_INPUT
:
{
MouseInput
mouseInput
=
aEvent
.
AsMouseInput
(
)
;
if
(
!
mouseInput
.
TransformToLocal
(
aTransformToApzc
)
)
{
return
rv
;
}
break
;
}
case
SCROLLWHEEL_INPUT
:
{
ScrollWheelInput
scrollInput
=
aEvent
.
AsScrollWheelInput
(
)
;
if
(
!
scrollInput
.
TransformToLocal
(
aTransformToApzc
)
)
{
return
rv
;
}
rv
=
OnScrollWheel
(
scrollInput
)
;
break
;
}
case
PINCHGESTURE_INPUT
:
{
MOZ_ASSERT
(
IsRootContent
(
)
)
;
PinchGestureInput
pinchInput
=
aEvent
.
AsPinchGestureInput
(
)
;
if
(
!
pinchInput
.
TransformToLocal
(
aTransformToApzc
)
)
{
return
rv
;
}
rv
=
HandleGestureEvent
(
pinchInput
)
;
break
;
}
case
TAPGESTURE_INPUT
:
{
TapGestureInput
tapInput
=
aEvent
.
AsTapGestureInput
(
)
;
if
(
!
tapInput
.
TransformToLocal
(
aTransformToApzc
)
)
{
return
rv
;
}
rv
=
HandleGestureEvent
(
tapInput
)
;
break
;
}
case
KEYBOARD_INPUT
:
{
const
KeyboardInput
&
keyInput
=
aEvent
.
AsKeyboardInput
(
)
;
rv
=
OnKeyboard
(
keyInput
)
;
break
;
}
}
return
rv
;
}
nsEventStatus
AsyncPanZoomController
:
:
HandleGestureEvent
(
const
InputData
&
aEvent
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
nsEventStatus
rv
=
nsEventStatus_eIgnore
;
switch
(
aEvent
.
mInputType
)
{
case
PINCHGESTURE_INPUT
:
{
if
(
!
IsRootContent
(
)
)
{
if
(
APZCTreeManager
*
treeManagerLocal
=
GetApzcTreeManager
(
)
)
{
if
(
RefPtr
<
AsyncPanZoomController
>
root
=
treeManagerLocal
-
>
FindZoomableApzc
(
this
)
)
{
rv
=
root
-
>
HandleGestureEvent
(
aEvent
)
;
}
}
break
;
}
PinchGestureInput
pinchGestureInput
=
aEvent
.
AsPinchGestureInput
(
)
;
pinchGestureInput
.
TransformToLocal
(
GetTransformToThis
(
)
)
;
switch
(
pinchGestureInput
.
mType
)
{
case
PinchGestureInput
:
:
PINCHGESTURE_START
:
rv
=
OnScaleBegin
(
pinchGestureInput
)
;
break
;
case
PinchGestureInput
:
:
PINCHGESTURE_SCALE
:
rv
=
OnScale
(
pinchGestureInput
)
;
break
;
case
PinchGestureInput
:
:
PINCHGESTURE_FINGERLIFTED
:
case
PinchGestureInput
:
:
PINCHGESTURE_END
:
rv
=
OnScaleEnd
(
pinchGestureInput
)
;
break
;
}
break
;
}
case
TAPGESTURE_INPUT
:
{
TapGestureInput
tapGestureInput
=
aEvent
.
AsTapGestureInput
(
)
;
tapGestureInput
.
TransformToLocal
(
GetTransformToThis
(
)
)
;
switch
(
tapGestureInput
.
mType
)
{
case
TapGestureInput
:
:
TAPGESTURE_LONG
:
rv
=
OnLongPress
(
tapGestureInput
)
;
break
;
case
TapGestureInput
:
:
TAPGESTURE_LONG_UP
:
rv
=
OnLongPressUp
(
tapGestureInput
)
;
break
;
case
TapGestureInput
:
:
TAPGESTURE_UP
:
rv
=
OnSingleTapUp
(
tapGestureInput
)
;
break
;
case
TapGestureInput
:
:
TAPGESTURE_CONFIRMED
:
rv
=
OnSingleTapConfirmed
(
tapGestureInput
)
;
break
;
case
TapGestureInput
:
:
TAPGESTURE_DOUBLE
:
rv
=
OnDoubleTap
(
tapGestureInput
)
;
break
;
case
TapGestureInput
:
:
TAPGESTURE_SECOND
:
rv
=
OnSecondTap
(
tapGestureInput
)
;
break
;
case
TapGestureInput
:
:
TAPGESTURE_CANCEL
:
rv
=
OnCancelTap
(
tapGestureInput
)
;
break
;
}
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unhandled
input
event
"
)
;
break
;
}
return
rv
;
}
void
AsyncPanZoomController
:
:
StartAutoscroll
(
const
ScreenPoint
&
aPoint
)
{
CancelAnimation
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SCROLL_INPUT_METHODS
(
uint32_t
)
ScrollInputMethod
:
:
ApzAutoscrolling
)
;
SetState
(
AUTOSCROLL
)
;
StartAnimation
(
new
AutoscrollAnimation
(
*
this
aPoint
)
)
;
}
void
AsyncPanZoomController
:
:
StopAutoscroll
(
)
{
if
(
mState
=
=
AUTOSCROLL
)
{
CancelAnimation
(
TriggeredExternally
)
;
}
}
nsEventStatus
AsyncPanZoomController
:
:
OnTouchStart
(
const
MultiTouchInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
touch
-
start
in
state
%
d
\
n
"
this
mState
)
;
mPanDirRestricted
=
false
;
switch
(
mState
)
{
case
FLING
:
case
ANIMATING_ZOOM
:
case
SMOOTH_SCROLL
:
case
SMOOTHMSD_SCROLL
:
case
OVERSCROLL_ANIMATION
:
case
WHEEL_SCROLL
:
case
KEYBOARD_SCROLL
:
case
PAN_MOMENTUM
:
case
AUTOSCROLL
:
MOZ_ASSERT
(
GetCurrentTouchBlock
(
)
)
;
GetCurrentTouchBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
-
>
CancelAnimations
(
ExcludeOverscroll
)
;
[
[
fallthrough
]
]
;
case
SCROLLBAR_DRAG
:
case
NOTHING
:
{
ParentLayerPoint
point
=
GetFirstTouchPoint
(
aEvent
)
;
mStartTouch
=
GetFirstExternalTouchPoint
(
aEvent
)
;
StartTouch
(
point
aEvent
.
mTimeStamp
)
;
if
(
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
)
{
MOZ_ASSERT
(
GetCurrentTouchBlock
(
)
)
;
controller
-
>
NotifyAPZStateChange
(
GetGuid
(
)
APZStateChange
:
:
eStartTouch
GetCurrentTouchBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
-
>
CanBePanned
(
this
)
)
;
}
mTouchStartTime
=
aEvent
.
mTimeStamp
;
SetState
(
TOUCHING
)
;
break
;
}
case
TOUCHING
:
case
PANNING
:
case
PANNING_LOCKED_X
:
case
PANNING_LOCKED_Y
:
case
PINCHING
:
NS_WARNING
(
"
Received
impossible
touch
in
OnTouchStart
"
)
;
break
;
}
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnTouchMove
(
const
MultiTouchInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
touch
-
move
in
state
%
d
\
n
"
this
mState
)
;
switch
(
mState
)
{
case
FLING
:
case
SMOOTHMSD_SCROLL
:
case
NOTHING
:
case
ANIMATING_ZOOM
:
return
nsEventStatus_eIgnore
;
case
TOUCHING
:
{
ScreenCoord
panThreshold
=
GetTouchStartTolerance
(
)
;
ExternalPoint
extPoint
=
GetFirstExternalTouchPoint
(
aEvent
)
;
if
(
panThreshold
>
0
.
0f
)
{
UpdateWithTouchAtDevicePoint
(
aEvent
)
;
if
(
PanVector
(
extPoint
)
.
Length
(
)
<
panThreshold
)
{
return
nsEventStatus_eIgnore
;
}
}
MOZ_ASSERT
(
GetCurrentTouchBlock
(
)
)
;
if
(
StaticPrefs
:
:
layout_css_touch_action_enabled
(
)
&
&
GetCurrentTouchBlock
(
)
-
>
TouchActionAllowsPanningXY
(
)
)
{
StartPanning
(
extPoint
aEvent
.
mTimeStamp
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
return
StartPanning
(
extPoint
aEvent
.
mTimeStamp
)
;
}
case
PANNING
:
case
PANNING_LOCKED_X
:
case
PANNING_LOCKED_Y
:
case
PAN_MOMENTUM
:
TrackTouch
(
aEvent
)
;
return
nsEventStatus_eConsumeNoDefault
;
case
PINCHING
:
NS_WARNING
(
"
Gesture
listener
should
have
handled
pinching
in
OnTouchMove
.
"
)
;
return
nsEventStatus_eIgnore
;
case
SMOOTH_SCROLL
:
case
WHEEL_SCROLL
:
case
KEYBOARD_SCROLL
:
case
OVERSCROLL_ANIMATION
:
case
AUTOSCROLL
:
case
SCROLLBAR_DRAG
:
NS_WARNING
(
"
Received
impossible
touch
in
OnTouchMove
"
)
;
break
;
}
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnTouchEnd
(
const
MultiTouchInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
touch
-
end
in
state
%
d
\
n
"
this
mState
)
;
OnTouchEndOrCancel
(
)
;
if
(
mState
!
=
NOTHING
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
}
switch
(
mState
)
{
case
FLING
:
NS_WARNING
(
"
Received
impossible
touch
end
in
OnTouchEnd
.
"
)
;
[
[
fallthrough
]
]
;
case
ANIMATING_ZOOM
:
case
SMOOTHMSD_SCROLL
:
case
NOTHING
:
return
nsEventStatus_eIgnore
;
case
TOUCHING
:
SetVelocityVector
(
ParentLayerPoint
(
0
0
)
)
;
MOZ_ASSERT
(
GetCurrentTouchBlock
(
)
)
;
APZC_LOG
(
"
%
p
still
has
%
u
touch
points
active
\
n
"
this
GetCurrentTouchBlock
(
)
-
>
GetActiveTouchCount
(
)
)
;
if
(
GetCurrentTouchBlock
(
)
-
>
GetActiveTouchCount
(
)
=
=
0
)
{
GetCurrentTouchBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
-
>
SnapBackOverscrolledApzc
(
this
)
;
mFlingAccelerator
.
Reset
(
)
;
if
(
mState
!
=
OVERSCROLL_ANIMATION
)
{
SetState
(
NOTHING
)
;
}
}
return
nsEventStatus_eIgnore
;
case
PANNING
:
case
PANNING_LOCKED_X
:
case
PANNING_LOCKED_Y
:
case
PAN_MOMENTUM
:
{
MOZ_ASSERT
(
GetCurrentTouchBlock
(
)
)
;
EndTouch
(
aEvent
.
mTimeStamp
)
;
return
HandleEndOfPan
(
)
;
}
case
PINCHING
:
SetState
(
NOTHING
)
;
NS_WARNING
(
"
Gesture
listener
should
have
handled
pinching
in
OnTouchEnd
.
"
)
;
return
nsEventStatus_eIgnore
;
case
SMOOTH_SCROLL
:
case
WHEEL_SCROLL
:
case
KEYBOARD_SCROLL
:
case
OVERSCROLL_ANIMATION
:
case
AUTOSCROLL
:
case
SCROLLBAR_DRAG
:
NS_WARNING
(
"
Received
impossible
touch
in
OnTouchEnd
"
)
;
break
;
}
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnTouchCancel
(
const
MultiTouchInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
touch
-
cancel
in
state
%
d
\
n
"
this
mState
)
;
OnTouchEndOrCancel
(
)
;
CancelAnimationAndGestureState
(
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnScaleBegin
(
const
PinchGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
scale
-
begin
in
state
%
d
\
n
"
this
mState
)
;
mPinchLocked
=
false
;
mPinchPaintTimerSet
=
false
;
if
(
HasReadyTouchBlock
(
)
&
&
!
GetCurrentTouchBlock
(
)
-
>
TouchActionAllowsPinchZoom
(
)
)
{
return
nsEventStatus_eIgnore
;
}
if
(
!
ZoomConstraintsAllowZoom
(
)
)
{
StartTouch
(
aEvent
.
mLocalFocusPoint
aEvent
.
mTimeStamp
)
;
}
if
(
!
StaticPrefs
:
:
apz_allow_zooming
(
)
)
{
if
(
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
)
{
APZC_LOG
(
"
%
p
notifying
controller
of
pinch
gesture
start
\
n
"
this
)
;
controller
-
>
NotifyPinchGesture
(
aEvent
.
mType
GetGuid
(
)
ViewAs
<
LayoutDevicePixel
>
(
aEvent
.
mFocusPoint
PixelCastJustification
:
:
LayoutDeviceIsScreenForUntransformedEvent
)
0
aEvent
.
modifiers
)
;
}
}
SetState
(
PINCHING
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
APZ_ZOOM_PINCHSOURCE
(
int
)
aEvent
.
mSource
)
;
SetVelocityVector
(
ParentLayerPoint
(
0
0
)
)
;
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
mLastZoomFocus
=
aEvent
.
mLocalFocusPoint
-
Metrics
(
)
.
GetCompositionBounds
(
)
.
TopLeft
(
)
;
mPinchEventBuffer
.
push
(
aEvent
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnScale
(
const
PinchGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
scale
in
state
%
d
\
n
"
this
mState
)
;
if
(
HasReadyTouchBlock
(
)
&
&
!
GetCurrentTouchBlock
(
)
-
>
TouchActionAllowsPinchZoom
(
)
)
{
return
nsEventStatus_eIgnore
;
}
if
(
mState
!
=
PINCHING
)
{
return
nsEventStatus_eConsumeNoDefault
;
}
mPinchEventBuffer
.
push
(
aEvent
)
;
HandlePinchLocking
(
aEvent
)
;
bool
allowZoom
=
ZoomConstraintsAllowZoom
(
)
&
&
!
mPinchLocked
;
if
(
!
allowZoom
)
{
mX
.
UpdateWithTouchAtDevicePoint
(
aEvent
.
mLocalFocusPoint
.
x
aEvent
.
mTimeStamp
)
;
mY
.
UpdateWithTouchAtDevicePoint
(
aEvent
.
mLocalFocusPoint
.
y
aEvent
.
mTimeStamp
)
;
}
if
(
!
StaticPrefs
:
:
apz_allow_zooming
(
)
)
{
if
(
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
)
{
APZC_LOG
(
"
%
p
notifying
controller
of
pinch
gesture
\
n
"
this
)
;
controller
-
>
NotifyPinchGesture
(
aEvent
.
mType
GetGuid
(
)
ViewAs
<
LayoutDevicePixel
>
(
aEvent
.
mFocusPoint
PixelCastJustification
:
:
LayoutDeviceIsScreenForUntransformedEvent
)
ViewAs
<
LayoutDevicePixel
>
(
aEvent
.
mCurrentSpan
-
aEvent
.
mPreviousSpan
PixelCastJustification
:
:
LayoutDeviceIsScreenForUntransformedEvent
)
aEvent
.
modifiers
)
;
}
}
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
MOZ_ASSERT
(
Metrics
(
)
.
IsRootContent
(
)
)
;
MOZ_ASSERT
(
Metrics
(
)
.
GetZoom
(
)
.
AreScalesSame
(
)
)
;
CSSToParentLayerScale
userZoom
=
Metrics
(
)
.
GetZoom
(
)
.
ToScaleFactor
(
)
;
ParentLayerPoint
focusPoint
=
aEvent
.
mLocalFocusPoint
-
Metrics
(
)
.
GetCompositionBounds
(
)
.
TopLeft
(
)
;
CSSPoint
cssFocusPoint
;
if
(
Metrics
(
)
.
GetZoom
(
)
!
=
CSSToParentLayerScale2D
(
0
0
)
)
{
cssFocusPoint
=
focusPoint
/
Metrics
(
)
.
GetZoom
(
)
;
}
ParentLayerPoint
focusChange
=
mLastZoomFocus
-
focusPoint
;
mLastZoomFocus
=
focusPoint
;
focusChange
.
x
-
=
mX
.
DisplacementWillOverscrollAmount
(
focusChange
.
x
)
;
focusChange
.
y
-
=
mY
.
DisplacementWillOverscrollAmount
(
focusChange
.
y
)
;
if
(
userZoom
!
=
CSSToParentLayerScale
(
0
)
)
{
ScrollBy
(
focusChange
/
userZoom
)
;
}
float
prevSpan
=
aEvent
.
mPreviousSpan
;
if
(
fabsf
(
prevSpan
)
<
=
EPSILON
|
|
fabsf
(
aEvent
.
mCurrentSpan
)
<
=
EPSILON
)
{
ScheduleCompositeAndMaybeRepaint
(
)
;
UpdateSharedCompositorFrameMetrics
(
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
float
spanRatio
=
aEvent
.
mCurrentSpan
/
aEvent
.
mPreviousSpan
;
CSSPoint
neededDisplacement
;
CSSToParentLayerScale
realMinZoom
=
mZoomConstraints
.
mMinZoom
;
CSSToParentLayerScale
realMaxZoom
=
mZoomConstraints
.
mMaxZoom
;
realMinZoom
.
scale
=
std
:
:
max
(
realMinZoom
.
scale
Metrics
(
)
.
GetCompositionBounds
(
)
.
Width
(
)
/
Metrics
(
)
.
GetScrollableRect
(
)
.
Width
(
)
)
;
realMinZoom
.
scale
=
std
:
:
max
(
realMinZoom
.
scale
Metrics
(
)
.
GetCompositionBounds
(
)
.
Height
(
)
/
Metrics
(
)
.
GetScrollableRect
(
)
.
Height
(
)
)
;
if
(
realMaxZoom
<
realMinZoom
)
{
realMaxZoom
=
realMinZoom
;
}
bool
doScale
=
allowZoom
&
&
(
(
spanRatio
>
1
.
0
&
&
userZoom
<
realMaxZoom
)
|
|
(
spanRatio
<
1
.
0
&
&
userZoom
>
realMinZoom
)
)
;
if
(
doScale
)
{
spanRatio
=
clamped
(
spanRatio
realMinZoom
.
scale
/
userZoom
.
scale
realMaxZoom
.
scale
/
userZoom
.
scale
)
;
neededDisplacement
.
x
=
-
mX
.
ScaleWillOverscrollAmount
(
spanRatio
cssFocusPoint
.
x
)
;
neededDisplacement
.
y
=
-
mY
.
ScaleWillOverscrollAmount
(
spanRatio
cssFocusPoint
.
y
)
;
ScaleWithFocus
(
spanRatio
cssFocusPoint
)
;
if
(
neededDisplacement
!
=
CSSPoint
(
)
)
{
ScrollBy
(
neededDisplacement
)
;
}
if
(
!
mPinchPaintTimerSet
)
{
const
int
delay
=
StaticPrefs
:
:
apz_scale_repaint_delay_ms
(
)
;
if
(
delay
>
=
0
)
{
if
(
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
)
{
mPinchPaintTimerSet
=
true
;
controller
-
>
PostDelayedTask
(
NewRunnableMethod
(
"
layers
:
:
AsyncPanZoomController
:
:
"
"
DoDelayedRequestContentRepaint
"
this
&
AsyncPanZoomController
:
:
DoDelayedRequestContentRepaint
)
delay
)
;
}
}
}
else
if
(
apz
:
:
AboutToCheckerboard
(
mLastContentPaintMetrics
Metrics
(
)
)
)
{
DoDelayedRequestContentRepaint
(
)
;
}
UpdateSharedCompositorFrameMetrics
(
)
;
}
else
{
RequestContentRepaint
(
)
;
}
ScheduleComposite
(
)
;
}
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnScaleEnd
(
const
PinchGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
scale
-
end
in
state
%
d
\
n
"
this
mState
)
;
mPinchPaintTimerSet
=
false
;
if
(
HasReadyTouchBlock
(
)
&
&
!
GetCurrentTouchBlock
(
)
-
>
TouchActionAllowsPinchZoom
(
)
)
{
return
nsEventStatus_eIgnore
;
}
if
(
!
StaticPrefs
:
:
apz_allow_zooming
(
)
)
{
if
(
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
)
{
controller
-
>
NotifyPinchGesture
(
aEvent
.
mType
GetGuid
(
)
ViewAs
<
LayoutDevicePixel
>
(
aEvent
.
mFocusPoint
PixelCastJustification
:
:
LayoutDeviceIsScreenForUntransformedEvent
)
0
aEvent
.
modifiers
)
;
}
}
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
ScheduleComposite
(
)
;
RequestContentRepaint
(
)
;
UpdateSharedCompositorFrameMetrics
(
)
;
}
mPinchEventBuffer
.
clear
(
)
;
if
(
aEvent
.
mType
=
=
PinchGestureInput
:
:
PINCHGESTURE_FINGERLIFTED
)
{
if
(
ZoomConstraintsAllowZoom
(
)
)
{
mPanDirRestricted
=
false
;
StartTouch
(
aEvent
.
mLocalFocusPoint
aEvent
.
mTimeStamp
)
;
SetState
(
TOUCHING
)
;
}
else
{
StartPanning
(
ToExternalPoint
(
aEvent
.
mScreenOffset
aEvent
.
mFocusPoint
)
aEvent
.
mTimeStamp
)
;
}
}
else
{
bool
stateWasPinching
=
(
mState
=
=
PINCHING
)
;
StateChangeNotificationBlocker
blocker
(
this
)
;
SetState
(
NOTHING
)
;
if
(
ZoomConstraintsAllowZoom
(
)
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
HasReadyTouchBlock
(
)
)
{
GetCurrentTouchBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
-
>
ClearOverscroll
(
)
;
}
else
{
ClearOverscroll
(
)
;
}
ScrollSnap
(
)
;
}
else
{
EndTouch
(
aEvent
.
mTimeStamp
)
;
if
(
stateWasPinching
)
{
if
(
HasReadyTouchBlock
(
)
)
{
return
HandleEndOfPan
(
)
;
}
}
}
}
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
HandleEndOfPan
(
)
{
MOZ_ASSERT
(
GetCurrentTouchBlock
(
)
|
|
GetCurrentPanGestureBlock
(
)
)
;
GetCurrentInputBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
-
>
FlushRepaints
(
)
;
ParentLayerPoint
flingVelocity
=
GetVelocityVector
(
)
;
SetVelocityVector
(
ParentLayerPoint
(
0
0
)
)
;
StateChangeNotificationBlocker
blocker
(
this
)
;
SetState
(
NOTHING
)
;
APZC_LOG
(
"
%
p
starting
a
fling
animation
if
%
f
>
%
f
\
n
"
this
flingVelocity
.
Length
(
)
.
value
StaticPrefs
:
:
apz_fling_min_velocity_threshold
(
)
)
;
if
(
flingVelocity
.
Length
(
)
<
=
StaticPrefs
:
:
apz_fling_min_velocity_threshold
(
)
)
{
GetCurrentInputBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
-
>
SnapBackOverscrolledApzc
(
this
)
;
mFlingAccelerator
.
Reset
(
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
if
(
APZCTreeManager
*
treeManagerLocal
=
GetApzcTreeManager
(
)
)
{
const
FlingHandoffState
handoffState
{
flingVelocity
GetCurrentInputBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
Some
(
mTouchStartRestingTimeBeforePan
)
mMinimumVelocityDuringPan
.
valueOr
(
0
)
false
GetCurrentInputBlock
(
)
-
>
GetScrolledApzc
(
)
}
;
treeManagerLocal
-
>
DispatchFling
(
this
handoffState
)
;
}
return
nsEventStatus_eConsumeNoDefault
;
}
Maybe
<
LayoutDevicePoint
>
AsyncPanZoomController
:
:
ConvertToGecko
(
const
ScreenIntPoint
&
aPoint
)
{
if
(
APZCTreeManager
*
treeManagerLocal
=
GetApzcTreeManager
(
)
)
{
if
(
Maybe
<
ScreenIntPoint
>
layoutPoint
=
treeManagerLocal
-
>
ConvertToGecko
(
aPoint
this
)
)
{
return
Some
(
LayoutDevicePoint
(
ViewAs
<
LayoutDevicePixel
>
(
*
layoutPoint
PixelCastJustification
:
:
LayoutDeviceIsScreenForUntransformedEvent
)
)
)
;
}
}
return
Nothing
(
)
;
}
CSSCoord
AsyncPanZoomController
:
:
ConvertScrollbarPoint
(
const
ParentLayerPoint
&
aScrollbarPoint
const
ScrollbarData
&
aThumbData
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
CSSPoint
scrollbarPoint
;
if
(
Metrics
(
)
.
GetZoom
(
)
!
=
CSSToParentLayerScale2D
(
0
0
)
)
{
scrollbarPoint
=
aScrollbarPoint
/
Metrics
(
)
.
GetZoom
(
)
;
}
scrollbarPoint
=
scrollbarPoint
*
Metrics
(
)
.
GetPresShellResolution
(
)
;
CSSRect
cssCompositionBound
=
Metrics
(
)
.
CalculateCompositionBoundsInCssPixelsOfSurroundingContent
(
)
;
return
GetAxisStart
(
*
aThumbData
.
mDirection
scrollbarPoint
)
-
GetAxisStart
(
*
aThumbData
.
mDirection
cssCompositionBound
)
-
aThumbData
.
mScrollTrackStart
;
}
static
bool
AllowsScrollingMoreThanOnePage
(
double
aMultiplier
)
{
const
int32_t
kMinAllowPageScroll
=
EventStateManager
:
:
MIN_MULTIPLIER_VALUE_ALLOWING_OVER_ONE_PAGE_SCROLL
;
return
Abs
(
aMultiplier
)
>
=
kMinAllowPageScroll
;
}
ParentLayerPoint
AsyncPanZoomController
:
:
GetScrollWheelDelta
(
const
ScrollWheelInput
&
aEvent
)
const
{
return
GetScrollWheelDelta
(
aEvent
aEvent
.
mDeltaX
aEvent
.
mDeltaY
aEvent
.
mUserDeltaMultiplierX
aEvent
.
mUserDeltaMultiplierY
)
;
}
ParentLayerPoint
AsyncPanZoomController
:
:
GetScrollWheelDelta
(
const
ScrollWheelInput
&
aEvent
double
aDeltaX
double
aDeltaY
double
aMultiplierX
double
aMultiplierY
)
const
{
ParentLayerSize
scrollAmount
;
ParentLayerSize
pageScrollSize
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
LayoutDeviceIntSize
scrollAmountLD
=
mScrollMetadata
.
GetLineScrollAmount
(
)
;
LayoutDeviceIntSize
pageScrollSizeLD
=
mScrollMetadata
.
GetPageScrollAmount
(
)
;
scrollAmount
=
scrollAmountLD
/
Metrics
(
)
.
GetDevPixelsPerCSSPixel
(
)
*
Metrics
(
)
.
GetZoom
(
)
;
pageScrollSize
=
pageScrollSizeLD
/
Metrics
(
)
.
GetDevPixelsPerCSSPixel
(
)
*
Metrics
(
)
.
GetZoom
(
)
;
}
ParentLayerPoint
delta
;
switch
(
aEvent
.
mDeltaType
)
{
case
ScrollWheelInput
:
:
SCROLLDELTA_LINE
:
{
delta
.
x
=
aDeltaX
*
scrollAmount
.
width
;
delta
.
y
=
aDeltaY
*
scrollAmount
.
height
;
break
;
}
case
ScrollWheelInput
:
:
SCROLLDELTA_PAGE
:
{
delta
.
x
=
aDeltaX
*
pageScrollSize
.
width
;
delta
.
y
=
aDeltaY
*
pageScrollSize
.
height
;
break
;
}
case
ScrollWheelInput
:
:
SCROLLDELTA_PIXEL
:
{
delta
=
ToParentLayerCoordinates
(
ScreenPoint
(
aDeltaX
aDeltaY
)
aEvent
.
mOrigin
)
;
break
;
}
}
delta
.
x
*
=
aMultiplierX
;
delta
.
y
*
=
aMultiplierY
;
if
(
StaticPrefs
:
:
mousewheel_system_scroll_override_enabled
(
)
&
&
!
aEvent
.
IsCustomizedByUserPrefs
(
)
&
&
aEvent
.
mDeltaType
=
=
ScrollWheelInput
:
:
SCROLLDELTA_LINE
&
&
aEvent
.
mAllowToOverrideSystemScrollSpeed
)
{
delta
.
x
=
WidgetWheelEvent
:
:
ComputeOverriddenDelta
(
delta
.
x
false
)
;
delta
.
y
=
WidgetWheelEvent
:
:
ComputeOverriddenDelta
(
delta
.
y
true
)
;
}
if
(
aEvent
.
mDeltaType
=
=
ScrollWheelInput
:
:
SCROLLDELTA_LINE
&
&
aEvent
.
mScrollSeriesNumber
>
0
)
{
int32_t
start
=
StaticPrefs
:
:
mousewheel_acceleration_start
(
)
;
if
(
start
>
=
0
&
&
aEvent
.
mScrollSeriesNumber
>
=
uint32_t
(
start
)
)
{
int32_t
factor
=
StaticPrefs
:
:
mousewheel_acceleration_factor
(
)
;
if
(
factor
>
0
)
{
delta
.
x
=
ComputeAcceleratedWheelDelta
(
delta
.
x
aEvent
.
mScrollSeriesNumber
factor
)
;
delta
.
y
=
ComputeAcceleratedWheelDelta
(
delta
.
y
aEvent
.
mScrollSeriesNumber
factor
)
;
}
}
}
if
(
!
AllowsScrollingMoreThanOnePage
(
aMultiplierX
)
&
&
Abs
(
delta
.
x
)
>
pageScrollSize
.
width
)
{
delta
.
x
=
(
delta
.
x
>
=
0
)
?
pageScrollSize
.
width
:
-
pageScrollSize
.
width
;
}
if
(
!
AllowsScrollingMoreThanOnePage
(
aMultiplierY
)
&
&
Abs
(
delta
.
y
)
>
pageScrollSize
.
height
)
{
delta
.
y
=
(
delta
.
y
>
=
0
)
?
pageScrollSize
.
height
:
-
pageScrollSize
.
height
;
}
return
delta
;
}
static
void
ReportKeyboardScrollAction
(
const
KeyboardScrollAction
&
aAction
)
{
ScrollInputMethod
scrollMethod
;
switch
(
aAction
.
mType
)
{
case
KeyboardScrollAction
:
:
eScrollLine
:
{
scrollMethod
=
ScrollInputMethod
:
:
ApzScrollLine
;
break
;
}
case
KeyboardScrollAction
:
:
eScrollCharacter
:
{
scrollMethod
=
ScrollInputMethod
:
:
ApzScrollCharacter
;
break
;
}
case
KeyboardScrollAction
:
:
eScrollPage
:
{
scrollMethod
=
ScrollInputMethod
:
:
ApzScrollPage
;
break
;
}
case
KeyboardScrollAction
:
:
eScrollComplete
:
{
scrollMethod
=
ScrollInputMethod
:
:
ApzCompleteScroll
;
break
;
}
}
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
SCROLL_INPUT_METHODS
(
uint32_t
)
scrollMethod
)
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnKeyboard
(
const
KeyboardInput
&
aEvent
)
{
ReportKeyboardScrollAction
(
aEvent
.
mAction
)
;
mTestHasAsyncKeyScrolled
=
true
;
CSSPoint
destination
=
GetKeyboardDestination
(
aEvent
.
mAction
)
;
bool
scrollSnapped
=
MaybeAdjustDestinationForScrollSnapping
(
aEvent
destination
)
;
RecordScrollPayload
(
aEvent
.
mTimeStamp
)
;
if
(
!
StaticPrefs
:
:
general_smoothScroll
(
)
)
{
CancelAnimation
(
)
;
ParentLayerPoint
startPoint
endPoint
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
startPoint
=
destination
*
Metrics
(
)
.
GetZoom
(
)
;
endPoint
=
Metrics
(
)
.
GetVisualScrollOffset
(
)
*
Metrics
(
)
.
GetZoom
(
)
;
}
ParentLayerPoint
delta
=
endPoint
-
startPoint
;
ScreenPoint
distance
=
ToScreenCoordinates
(
ParentLayerPoint
(
fabs
(
delta
.
x
)
fabs
(
delta
.
y
)
)
startPoint
)
;
OverscrollHandoffState
handoffState
(
*
mInputQueue
-
>
GetCurrentKeyboardBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
distance
ScrollSource
:
:
Keyboard
)
;
CallDispatchScroll
(
startPoint
endPoint
handoffState
)
;
SetState
(
NOTHING
)
;
return
nsEventStatus_eConsumeDoDefault
;
}
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
scrollSnapped
)
{
APZC_LOG
(
"
%
p
keyboard
scrolling
to
snap
point
%
s
\
n
"
this
ToString
(
destination
)
.
c_str
(
)
)
;
SmoothMsdScrollTo
(
destination
)
;
return
nsEventStatus_eConsumeDoDefault
;
}
if
(
mState
!
=
KEYBOARD_SCROLL
)
{
CancelAnimation
(
)
;
SetState
(
KEYBOARD_SCROLL
)
;
nsPoint
initialPosition
=
CSSPoint
:
:
ToAppUnits
(
Metrics
(
)
.
GetVisualScrollOffset
(
)
)
;
StartAnimation
(
new
SmoothScrollAnimation
(
*
this
initialPosition
SmoothScrollAnimation
:
:
GetScrollOriginForAction
(
aEvent
.
mAction
.
mType
)
)
)
;
}
nsPoint
velocity
;
if
(
Metrics
(
)
.
GetZoom
(
)
!
=
CSSToParentLayerScale2D
(
0
0
)
)
{
velocity
=
CSSPoint
:
:
ToAppUnits
(
ParentLayerPoint
(
mX
.
GetVelocity
(
)
*
1000
.
0f
mY
.
GetVelocity
(
)
*
1000
.
0f
)
/
Metrics
(
)
.
GetZoom
(
)
)
;
}
SmoothScrollAnimation
*
animation
=
mAnimation
-
>
AsSmoothScrollAnimation
(
)
;
MOZ_ASSERT
(
animation
)
;
animation
-
>
UpdateDestination
(
aEvent
.
mTimeStamp
CSSPixel
:
:
ToAppUnits
(
destination
)
nsSize
(
velocity
.
x
velocity
.
y
)
)
;
return
nsEventStatus_eConsumeDoDefault
;
}
CSSPoint
AsyncPanZoomController
:
:
GetKeyboardDestination
(
const
KeyboardScrollAction
&
aAction
)
const
{
CSSSize
lineScrollSize
;
CSSSize
pageScrollSize
;
CSSPoint
scrollOffset
;
CSSRect
scrollRect
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
lineScrollSize
=
mScrollMetadata
.
GetLineScrollAmount
(
)
/
Metrics
(
)
.
GetDevPixelsPerCSSPixel
(
)
;
pageScrollSize
=
mScrollMetadata
.
GetPageScrollAmount
(
)
/
Metrics
(
)
.
GetDevPixelsPerCSSPixel
(
)
;
scrollOffset
=
GetCurrentAnimationDestination
(
lock
)
.
valueOr
(
Metrics
(
)
.
GetVisualScrollOffset
(
)
)
;
scrollRect
=
Metrics
(
)
.
GetScrollableRect
(
)
;
}
CSSPoint
scrollDestination
=
scrollOffset
;
switch
(
aAction
.
mType
)
{
case
KeyboardScrollAction
:
:
eScrollCharacter
:
{
int32_t
scrollDistance
=
StaticPrefs
:
:
toolkit_scrollbox_horizontalScrollDistance
(
)
;
if
(
aAction
.
mForward
)
{
scrollDestination
.
x
+
=
scrollDistance
*
lineScrollSize
.
width
;
}
else
{
scrollDestination
.
x
-
=
scrollDistance
*
lineScrollSize
.
width
;
}
break
;
}
case
KeyboardScrollAction
:
:
eScrollLine
:
{
int32_t
scrollDistance
=
StaticPrefs
:
:
toolkit_scrollbox_verticalScrollDistance
(
)
;
if
(
aAction
.
mForward
)
{
scrollDestination
.
y
+
=
scrollDistance
*
lineScrollSize
.
height
;
}
else
{
scrollDestination
.
y
-
=
scrollDistance
*
lineScrollSize
.
height
;
}
break
;
}
case
KeyboardScrollAction
:
:
eScrollPage
:
{
if
(
aAction
.
mForward
)
{
scrollDestination
.
y
+
=
pageScrollSize
.
height
;
}
else
{
scrollDestination
.
y
-
=
pageScrollSize
.
height
;
}
break
;
}
case
KeyboardScrollAction
:
:
eScrollComplete
:
{
if
(
aAction
.
mForward
)
{
scrollDestination
.
y
=
scrollRect
.
YMost
(
)
;
}
else
{
scrollDestination
.
y
=
scrollRect
.
Y
(
)
;
}
break
;
}
}
return
scrollDestination
;
}
ParentLayerPoint
AsyncPanZoomController
:
:
GetDeltaForEvent
(
const
InputData
&
aEvent
)
const
{
ParentLayerPoint
delta
;
if
(
aEvent
.
mInputType
=
=
SCROLLWHEEL_INPUT
)
{
delta
=
GetScrollWheelDelta
(
aEvent
.
AsScrollWheelInput
(
)
)
;
}
else
if
(
aEvent
.
mInputType
=
=
PANGESTURE_INPUT
)
{
const
PanGestureInput
&
panInput
=
aEvent
.
AsPanGestureInput
(
)
;
delta
=
ToParentLayerCoordinates
(
panInput
.
UserMultipliedPanDisplacement
(
)
panInput
.
mPanStartPoint
)
;
}
return
delta
;
}
bool
AsyncPanZoomController
:
:
CanScroll
(
const
InputData
&
aEvent
)
const
{
ParentLayerPoint
delta
=
GetDeltaForEvent
(
aEvent
)
;
if
(
!
delta
.
x
&
&
!
delta
.
y
)
{
return
false
;
}
if
(
SCROLLWHEEL_INPUT
=
=
aEvent
.
mInputType
)
{
const
ScrollWheelInput
&
scrollWheelInput
=
aEvent
.
AsScrollWheelInput
(
)
;
if
(
scrollWheelInput
.
IsAutoDir
(
)
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
auto
deltaX
=
scrollWheelInput
.
mDeltaX
;
auto
deltaY
=
scrollWheelInput
.
mDeltaY
;
bool
isRTL
=
IsContentOfHonouredTargetRightToLeft
(
scrollWheelInput
.
HonoursRoot
(
)
)
;
APZAutoDirWheelDeltaAdjuster
adjuster
(
deltaX
deltaY
mX
mY
isRTL
)
;
if
(
adjuster
.
ShouldBeAdjusted
(
)
)
{
return
true
;
}
}
return
CanScrollWithWheel
(
delta
)
;
}
return
CanScroll
(
delta
)
;
}
ScrollDirections
AsyncPanZoomController
:
:
GetAllowedHandoffDirections
(
)
const
{
ScrollDirections
result
;
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
mX
.
OverscrollBehaviorAllowsHandoff
(
)
)
{
result
+
=
ScrollDirection
:
:
eHorizontal
;
}
if
(
mY
.
OverscrollBehaviorAllowsHandoff
(
)
)
{
result
+
=
ScrollDirection
:
:
eVertical
;
}
return
result
;
}
bool
AsyncPanZoomController
:
:
CanScroll
(
const
ParentLayerPoint
&
aDelta
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
mX
.
CanScroll
(
aDelta
.
x
)
|
|
mY
.
CanScroll
(
aDelta
.
y
)
;
}
bool
AsyncPanZoomController
:
:
CanScrollWithWheel
(
const
ParentLayerPoint
&
aDelta
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
Maybe
<
ScrollDirection
>
disregardedDirection
=
mScrollMetadata
.
GetDisregardedDirection
(
)
;
if
(
mX
.
CanScroll
(
aDelta
.
x
)
&
&
disregardedDirection
!
=
Some
(
ScrollDirection
:
:
eHorizontal
)
)
{
return
true
;
}
if
(
mY
.
CanScroll
(
aDelta
.
y
)
&
&
disregardedDirection
!
=
Some
(
ScrollDirection
:
:
eVertical
)
)
{
return
true
;
}
return
false
;
}
bool
AsyncPanZoomController
:
:
CanScroll
(
ScrollDirection
aDirection
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
switch
(
aDirection
)
{
case
ScrollDirection
:
:
eHorizontal
:
return
mX
.
CanScroll
(
)
;
case
ScrollDirection
:
:
eVertical
:
return
mY
.
CanScroll
(
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
value
"
)
;
return
false
;
}
bool
AsyncPanZoomController
:
:
CanVerticalScrollWithDynamicToolbar
(
)
const
{
MOZ_ASSERT
(
IsRootContent
(
)
)
;
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
mY
.
CanVerticalScrollWithDynamicToolbar
(
)
;
}
bool
AsyncPanZoomController
:
:
CanScrollDownwards
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
mY
.
CanScrollTo
(
eSideBottom
)
;
}
SideBits
AsyncPanZoomController
:
:
ScrollableDirections
(
)
const
{
SideBits
result
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
result
=
mX
.
ScrollableDirections
(
)
|
mY
.
ScrollableDirections
(
)
;
}
if
(
IsRootContent
(
)
)
{
if
(
APZCTreeManager
*
treeManagerLocal
=
GetApzcTreeManager
(
)
)
{
ScreenMargin
fixedLayerMargins
=
treeManagerLocal
-
>
GetCompositorFixedLayerMargins
(
)
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
result
|
=
mY
.
ScrollableDirectionsWithDynamicToolbar
(
fixedLayerMargins
)
;
}
}
}
return
result
;
}
bool
AsyncPanZoomController
:
:
IsContentOfHonouredTargetRightToLeft
(
bool
aHonoursRoot
)
const
{
if
(
aHonoursRoot
)
{
return
mScrollMetadata
.
IsAutoDirRootContentRTL
(
)
;
}
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
Metrics
(
)
.
IsHorizontalContentRightToLeft
(
)
;
}
bool
AsyncPanZoomController
:
:
AllowScrollHandoffInCurrentBlock
(
)
const
{
bool
result
=
mInputQueue
-
>
AllowScrollHandoff
(
)
;
if
(
!
StaticPrefs
:
:
apz_allow_immediate_handoff
(
)
)
{
if
(
InputBlockState
*
currentBlock
=
GetCurrentInputBlock
(
)
)
{
if
(
currentBlock
-
>
GetScrolledApzc
(
)
=
=
this
)
{
result
=
false
;
APZC_LOG
(
"
%
p
dropping
handoff
;
AllowImmediateHandoff
=
false
\
n
"
this
)
;
}
}
}
return
result
;
}
void
AsyncPanZoomController
:
:
DoDelayedRequestContentRepaint
(
)
{
if
(
!
IsDestroyed
(
)
&
&
mPinchPaintTimerSet
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
RequestContentRepaint
(
)
;
}
mPinchPaintTimerSet
=
false
;
}
static
ScrollInputMethod
ScrollInputMethodForWheelDeltaType
(
ScrollWheelInput
:
:
ScrollDeltaType
aDeltaType
)
{
switch
(
aDeltaType
)
{
case
ScrollWheelInput
:
:
SCROLLDELTA_LINE
:
{
return
ScrollInputMethod
:
:
ApzWheelLine
;
}
case
ScrollWheelInput
:
:
SCROLLDELTA_PAGE
:
{
return
ScrollInputMethod
:
:
ApzWheelPage
;
}
case
ScrollWheelInput
:
:
SCROLLDELTA_PIXEL
:
{
return
ScrollInputMethod
:
:
ApzWheelPixel
;
}
}
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
value
"
)
;
return
ScrollInputMethod
:
:
ApzWheelLine
;
}
static
void
AdjustDeltaForAllowedScrollDirections
(
ParentLayerPoint
&
aDelta
const
ScrollDirections
&
aAllowedScrollDirections
)
{
if
(
!
aAllowedScrollDirections
.
contains
(
ScrollDirection
:
:
eHorizontal
)
)
{
aDelta
.
x
=
0
;
}
if
(
!
aAllowedScrollDirections
.
contains
(
ScrollDirection
:
:
eVertical
)
)
{
aDelta
.
y
=
0
;
}
}
nsEventStatus
AsyncPanZoomController
:
:
OnScrollWheel
(
const
ScrollWheelInput
&
aEvent
)
{
bool
adjustedByAutoDir
=
false
;
auto
deltaX
=
aEvent
.
mDeltaX
;
auto
deltaY
=
aEvent
.
mDeltaY
;
ParentLayerPoint
delta
;
if
(
aEvent
.
IsAutoDir
(
)
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
bool
isRTL
=
IsContentOfHonouredTargetRightToLeft
(
aEvent
.
HonoursRoot
(
)
)
;
APZAutoDirWheelDeltaAdjuster
adjuster
(
deltaX
deltaY
mX
mY
isRTL
)
;
if
(
adjuster
.
ShouldBeAdjusted
(
)
)
{
adjuster
.
Adjust
(
)
;
adjustedByAutoDir
=
true
;
}
}
if
(
adjustedByAutoDir
)
{
delta
=
GetScrollWheelDelta
(
aEvent
deltaX
deltaY
aEvent
.
mUserDeltaMultiplierY
aEvent
.
mUserDeltaMultiplierX
)
;
}
else
{
delta
=
GetScrollWheelDelta
(
aEvent
)
;
}
APZC_LOG
(
"
%
p
got
a
scroll
-
wheel
with
delta
in
parent
-
layer
pixels
:
%
s
\
n
"
this
ToString
(
delta
)
.
c_str
(
)
)
;
if
(
adjustedByAutoDir
)
{
MOZ_ASSERT
(
delta
.
x
|
|
delta
.
y
"
Adjusted
auto
-
dir
delta
values
can
never
be
all
-
zero
.
"
)
;
APZC_LOG
(
"
%
p
got
a
scroll
-
wheel
with
adjusted
auto
-
dir
delta
values
\
n
"
this
)
;
}
else
if
(
(
delta
.
x
|
|
delta
.
y
)
&
&
!
CanScrollWithWheel
(
delta
)
)
{
if
(
mInputQueue
-
>
GetActiveWheelTransaction
(
)
&
&
StaticPrefs
:
:
test_mousescroll
(
)
)
{
if
(
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
)
{
controller
-
>
NotifyMozMouseScrollEvent
(
GetScrollId
(
)
u
"
MozMouseScrollFailed
"
_ns
)
;
}
}
return
nsEventStatus_eConsumeNoDefault
;
}
MOZ_ASSERT
(
mInputQueue
-
>
GetCurrentWheelBlock
(
)
)
;
AdjustDeltaForAllowedScrollDirections
(
delta
mInputQueue
-
>
GetCurrentWheelBlock
(
)
-
>
GetAllowedScrollDirections
(
)
)
;
if
(
delta
.
x
=
=
0
&
&
delta
.
y
=
=
0
)
{
return
nsEventStatus_eIgnore
;
}
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
SCROLL_INPUT_METHODS
(
uint32_t
)
ScrollInputMethodForWheelDeltaType
(
aEvent
.
mDeltaType
)
)
;
switch
(
aEvent
.
mScrollMode
)
{
case
ScrollWheelInput
:
:
SCROLLMODE_INSTANT
:
{
CSSPoint
startPosition
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
startPosition
=
Metrics
(
)
.
GetVisualScrollOffset
(
)
;
}
MaybeAdjustDeltaForScrollSnappingOnWheelInput
(
aEvent
delta
startPosition
)
;
ScreenPoint
distance
=
ToScreenCoordinates
(
ParentLayerPoint
(
fabs
(
delta
.
x
)
fabs
(
delta
.
y
)
)
aEvent
.
mLocalOrigin
)
;
CancelAnimation
(
)
;
OverscrollHandoffState
handoffState
(
*
mInputQueue
-
>
GetCurrentWheelBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
distance
ScrollSource
:
:
Wheel
)
;
ParentLayerPoint
startPoint
=
aEvent
.
mLocalOrigin
;
ParentLayerPoint
endPoint
=
aEvent
.
mLocalOrigin
-
delta
;
RecordScrollPayload
(
aEvent
.
mTimeStamp
)
;
CallDispatchScroll
(
startPoint
endPoint
handoffState
)
;
SetState
(
NOTHING
)
;
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
RequestContentRepaint
(
)
;
break
;
}
case
ScrollWheelInput
:
:
SCROLLMODE_SMOOTH
:
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
RecordScrollPayload
(
aEvent
.
mTimeStamp
)
;
CSSPoint
startPosition
=
GetCurrentAnimationDestination
(
lock
)
.
valueOr
(
Metrics
(
)
.
GetVisualScrollOffset
(
)
)
;
if
(
MaybeAdjustDeltaForScrollSnappingOnWheelInput
(
aEvent
delta
startPosition
)
)
{
APZC_LOG
(
"
%
p
wheel
scrolling
to
snap
point
%
s
\
n
"
this
ToString
(
startPosition
)
.
c_str
(
)
)
;
SmoothMsdScrollTo
(
startPosition
)
;
break
;
}
if
(
mState
!
=
WHEEL_SCROLL
)
{
CancelAnimation
(
)
;
SetState
(
WHEEL_SCROLL
)
;
nsPoint
initialPosition
=
CSSPoint
:
:
ToAppUnits
(
Metrics
(
)
.
GetVisualScrollOffset
(
)
)
;
StartAnimation
(
new
WheelScrollAnimation
(
*
this
initialPosition
aEvent
.
mDeltaType
)
)
;
}
nsPoint
deltaInAppUnits
;
nsPoint
velocity
;
if
(
Metrics
(
)
.
GetZoom
(
)
!
=
CSSToParentLayerScale2D
(
0
0
)
)
{
deltaInAppUnits
=
CSSPoint
:
:
ToAppUnits
(
delta
/
Metrics
(
)
.
GetZoom
(
)
)
;
velocity
=
CSSPoint
:
:
ToAppUnits
(
ParentLayerPoint
(
mX
.
GetVelocity
(
)
*
1000
.
0f
mY
.
GetVelocity
(
)
*
1000
.
0f
)
/
Metrics
(
)
.
GetZoom
(
)
)
;
}
WheelScrollAnimation
*
animation
=
mAnimation
-
>
AsWheelScrollAnimation
(
)
;
animation
-
>
UpdateDelta
(
aEvent
.
mTimeStamp
deltaInAppUnits
nsSize
(
velocity
.
x
velocity
.
y
)
)
;
break
;
}
}
return
nsEventStatus_eConsumeNoDefault
;
}
void
AsyncPanZoomController
:
:
NotifyMozMouseScrollEvent
(
const
nsString
&
aString
)
const
{
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
;
if
(
!
controller
)
{
return
;
}
controller
-
>
NotifyMozMouseScrollEvent
(
GetScrollId
(
)
aString
)
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnPanMayBegin
(
const
PanGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
pan
-
maybegin
in
state
%
d
\
n
"
this
mState
)
;
StartTouch
(
aEvent
.
mLocalPanStartPoint
aEvent
.
mTimeStamp
)
;
MOZ_ASSERT
(
GetCurrentPanGestureBlock
(
)
)
;
GetCurrentPanGestureBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
-
>
CancelAnimations
(
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnPanCancelled
(
const
PanGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
pan
-
cancelled
in
state
%
d
\
n
"
this
mState
)
;
mX
.
CancelGesture
(
)
;
mY
.
CancelGesture
(
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnPanBegin
(
const
PanGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
pan
-
begin
in
state
%
d
\
n
"
this
mState
)
;
if
(
mState
=
=
SMOOTHMSD_SCROLL
)
{
CancelAnimation
(
)
;
}
StartTouch
(
aEvent
.
mLocalPanStartPoint
aEvent
.
mTimeStamp
)
;
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
SCROLL_INPUT_METHODS
(
uint32_t
)
ScrollInputMethod
:
:
ApzPanGesture
)
;
if
(
GetAxisLockMode
(
)
=
=
FREE
)
{
SetState
(
PANNING
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
float
dx
=
aEvent
.
mPanDisplacement
.
x
dy
=
aEvent
.
mPanDisplacement
.
y
;
if
(
dx
|
|
dy
)
{
double
angle
=
atan2
(
dy
dx
)
;
angle
=
fabs
(
angle
)
;
HandlePanning
(
angle
)
;
}
else
{
SetState
(
PANNING
)
;
}
OnPan
(
aEvent
FingersOnTouchpad
:
:
Yes
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
std
:
:
tuple
<
ParentLayerPoint
ScreenPoint
>
AsyncPanZoomController
:
:
GetDisplacementsForPanGesture
(
const
PanGestureInput
&
aEvent
)
{
ScreenPoint
physicalPanDisplacement
=
aEvent
.
mPanDisplacement
;
ParentLayerPoint
logicalPanDisplacement
=
aEvent
.
UserMultipliedLocalPanDisplacement
(
)
;
if
(
aEvent
.
mDeltaType
=
=
PanGestureInput
:
:
PANDELTA_PAGE
)
{
CSSSize
pageScrollSize
;
CSSToParentLayerScale2D
zoom
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
pageScrollSize
=
mScrollMetadata
.
GetPageScrollAmount
(
)
/
Metrics
(
)
.
GetDevPixelsPerCSSPixel
(
)
;
zoom
=
Metrics
(
)
.
GetZoom
(
)
;
}
auto
scrollUnitWidth
=
std
:
:
min
(
std
:
:
pow
(
pageScrollSize
.
width
2
.
0
/
3
.
0
)
pageScrollSize
.
width
/
2
.
0
)
*
zoom
.
xScale
;
auto
scrollUnitHeight
=
std
:
:
min
(
std
:
:
pow
(
pageScrollSize
.
height
2
.
0
/
3
.
0
)
pageScrollSize
.
height
/
2
.
0
)
*
zoom
.
yScale
;
ParentLayerPoint
physicalPanDisplacementPL
(
physicalPanDisplacement
.
x
*
scrollUnitWidth
physicalPanDisplacement
.
y
*
scrollUnitHeight
)
;
physicalPanDisplacement
=
ToScreenCoordinates
(
physicalPanDisplacementPL
aEvent
.
mLocalPanStartPoint
)
;
logicalPanDisplacement
.
x
*
=
scrollUnitWidth
;
logicalPanDisplacement
.
y
*
=
scrollUnitHeight
;
if
(
mX
.
GetVelocity
(
)
!
=
0
)
{
float
absVelocity
=
std
:
:
abs
(
mX
.
GetVelocity
(
)
)
;
logicalPanDisplacement
.
x
*
=
std
:
:
pow
(
absVelocity
StaticPrefs
:
:
apz_touch_acceleration_factor_x
(
)
)
/
absVelocity
;
}
if
(
mY
.
GetVelocity
(
)
!
=
0
)
{
float
absVelocity
=
std
:
:
abs
(
mY
.
GetVelocity
(
)
)
;
logicalPanDisplacement
.
y
*
=
std
:
:
pow
(
absVelocity
StaticPrefs
:
:
apz_touch_acceleration_factor_y
(
)
)
/
absVelocity
;
}
}
MOZ_ASSERT
(
GetCurrentPanGestureBlock
(
)
)
;
AdjustDeltaForAllowedScrollDirections
(
logicalPanDisplacement
GetCurrentPanGestureBlock
(
)
-
>
GetAllowedScrollDirections
(
)
)
;
return
{
logicalPanDisplacement
physicalPanDisplacement
}
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnPan
(
const
PanGestureInput
&
aEvent
FingersOnTouchpad
aFingersOnTouchpad
)
{
APZC_LOG
(
"
%
p
got
a
pan
-
pan
in
state
%
d
\
n
"
this
mState
)
;
if
(
mState
=
=
SMOOTHMSD_SCROLL
)
{
if
(
aFingersOnTouchpad
=
=
FingersOnTouchpad
:
:
No
)
{
return
nsEventStatus_eConsumeNoDefault
;
}
CancelAnimation
(
)
;
}
if
(
mState
=
=
NOTHING
)
{
if
(
aFingersOnTouchpad
=
=
FingersOnTouchpad
:
:
No
)
{
return
nsEventStatus_eConsumeNoDefault
;
}
return
OnPanBegin
(
aEvent
)
;
}
auto
[
logicalPanDisplacement
physicalPanDisplacement
]
=
GetDisplacementsForPanGesture
(
aEvent
)
;
MOZ_ASSERT_IF
(
mState
=
=
OVERSCROLL_ANIMATION
mAnimation
)
;
if
(
mState
=
=
OVERSCROLL_ANIMATION
&
&
mAnimation
&
&
aFingersOnTouchpad
=
=
FingersOnTouchpad
:
:
No
)
{
MOZ_ASSERT
(
mAnimation
-
>
AsOverscrollAnimation
(
)
)
;
if
(
RefPtr
<
OverscrollAnimation
>
overscrollAnimation
=
mAnimation
-
>
AsOverscrollAnimation
(
)
)
{
overscrollAnimation
-
>
HandlePanMomentum
(
logicalPanDisplacement
)
;
if
(
overscrollAnimation
-
>
IsManagingXAxis
(
)
)
{
logicalPanDisplacement
.
x
=
0
;
physicalPanDisplacement
.
x
=
0
;
}
if
(
overscrollAnimation
-
>
IsManagingYAxis
(
)
)
{
logicalPanDisplacement
.
y
=
0
;
physicalPanDisplacement
.
y
=
0
;
}
}
}
HandlePanningUpdate
(
physicalPanDisplacement
)
;
MOZ_ASSERT
(
GetCurrentPanGestureBlock
(
)
)
;
ScreenPoint
panDistance
(
fabs
(
physicalPanDisplacement
.
x
)
fabs
(
physicalPanDisplacement
.
y
)
)
;
OverscrollHandoffState
handoffState
(
*
GetCurrentPanGestureBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
panDistance
ScrollSource
:
:
Touchpad
)
;
ParentLayerPoint
startPoint
=
aEvent
.
mLocalPanStartPoint
;
ParentLayerPoint
endPoint
=
aEvent
.
mLocalPanStartPoint
-
logicalPanDisplacement
;
if
(
logicalPanDisplacement
!
=
ParentLayerPoint
(
)
)
{
RecordScrollPayload
(
aEvent
.
mTimeStamp
)
;
}
const
ParentLayerPoint
velocity
=
GetVelocityVector
(
)
;
bool
consumed
=
CallDispatchScroll
(
startPoint
endPoint
handoffState
)
;
const
ParentLayerPoint
visualDisplacement
=
ToParentLayerCoordinates
(
handoffState
.
mTotalMovement
aEvent
.
mPanStartPoint
)
;
if
(
visualDisplacement
.
x
!
=
0
)
{
mX
.
UpdateWithTouchAtDevicePoint
(
mX
.
GetPos
(
)
-
visualDisplacement
.
x
aEvent
.
mTimeStamp
)
;
}
if
(
visualDisplacement
.
y
!
=
0
)
{
mY
.
UpdateWithTouchAtDevicePoint
(
mY
.
GetPos
(
)
-
visualDisplacement
.
y
aEvent
.
mTimeStamp
)
;
}
if
(
aFingersOnTouchpad
=
=
FingersOnTouchpad
:
:
No
)
{
if
(
IsOverscrolled
(
)
&
&
mState
!
=
OVERSCROLL_ANIMATION
)
{
StartOverscrollAnimation
(
velocity
GetOverscrollSideBits
(
)
)
;
}
else
if
(
!
consumed
)
{
SetState
(
NOTHING
)
;
}
}
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnPanEnd
(
const
PanGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
pan
-
end
in
state
%
d
\
n
"
this
mState
)
;
if
(
aEvent
.
mPanDisplacement
!
=
ScreenPoint
{
}
)
{
OnPan
(
aEvent
FingersOnTouchpad
:
:
Yes
)
;
}
EndTouch
(
aEvent
.
mTimeStamp
)
;
if
(
aEvent
.
mSimulateMomentum
)
{
return
HandleEndOfPan
(
)
;
}
if
(
IsOverscrolled
(
)
&
&
mState
!
=
OVERSCROLL_ANIMATION
)
{
StartOverscrollAnimation
(
GetVelocityVector
(
)
GetOverscrollSideBits
(
)
)
;
}
else
{
SetState
(
NOTHING
)
;
}
MOZ_ASSERT
(
GetCurrentPanGestureBlock
(
)
)
;
RefPtr
<
const
OverscrollHandoffChain
>
overscrollHandoffChain
=
GetCurrentPanGestureBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
!
overscrollHandoffChain
-
>
CanScrollInDirection
(
this
ScrollDirection
:
:
eHorizontal
)
)
{
mX
.
SetVelocity
(
0
)
;
}
if
(
!
overscrollHandoffChain
-
>
CanScrollInDirection
(
this
ScrollDirection
:
:
eVertical
)
)
{
mY
.
SetVelocity
(
0
)
;
}
}
RequestContentRepaint
(
)
;
if
(
!
aEvent
.
mFollowedByMomentum
)
{
ScrollSnap
(
)
;
}
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnPanMomentumStart
(
const
PanGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
pan
-
momentumstart
in
state
%
d
\
n
"
this
mState
)
;
if
(
mState
=
=
SMOOTHMSD_SCROLL
)
{
CancelAnimation
(
)
;
}
if
(
mState
=
=
OVERSCROLL_ANIMATION
)
{
return
nsEventStatus_eConsumeNoDefault
;
}
SetState
(
PAN_MOMENTUM
)
;
ScrollSnapToDestination
(
)
;
OnPan
(
aEvent
FingersOnTouchpad
:
:
No
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnPanMomentumEnd
(
const
PanGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
pan
-
momentumend
in
state
%
d
\
n
"
this
mState
)
;
if
(
mState
=
=
OVERSCROLL_ANIMATION
)
{
return
nsEventStatus_eConsumeNoDefault
;
}
OnPan
(
aEvent
FingersOnTouchpad
:
:
No
)
;
mX
.
CancelGesture
(
)
;
mY
.
CancelGesture
(
)
;
SetState
(
NOTHING
)
;
RequestContentRepaint
(
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnPanInterrupted
(
const
PanGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
pan
-
interrupted
in
state
%
d
\
n
"
this
mState
)
;
CancelAnimation
(
)
;
return
nsEventStatus_eIgnore
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnLongPress
(
const
TapGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
long
-
press
in
state
%
d
\
n
"
this
mState
)
;
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
;
if
(
controller
)
{
if
(
Maybe
<
LayoutDevicePoint
>
geckoScreenPoint
=
ConvertToGecko
(
aEvent
.
mPoint
)
)
{
TouchBlockState
*
touch
=
GetCurrentTouchBlock
(
)
;
if
(
!
touch
)
{
APZC_LOG
(
"
%
p
dropping
long
-
press
because
some
non
-
touch
block
interrupted
"
"
it
\
n
"
this
)
;
return
nsEventStatus_eIgnore
;
}
if
(
touch
-
>
IsDuringFastFling
(
)
)
{
APZC_LOG
(
"
%
p
dropping
long
-
press
because
of
fast
fling
\
n
"
this
)
;
return
nsEventStatus_eIgnore
;
}
uint64_t
blockId
=
GetInputQueue
(
)
-
>
InjectNewTouchBlock
(
this
)
;
controller
-
>
HandleTap
(
TapType
:
:
eLongTap
*
geckoScreenPoint
aEvent
.
modifiers
GetGuid
(
)
blockId
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
}
return
nsEventStatus_eIgnore
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnLongPressUp
(
const
TapGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
long
-
tap
-
up
in
state
%
d
\
n
"
this
mState
)
;
return
GenerateSingleTap
(
TapType
:
:
eLongTapUp
aEvent
.
mPoint
aEvent
.
modifiers
)
;
}
nsEventStatus
AsyncPanZoomController
:
:
GenerateSingleTap
(
TapType
aType
const
ScreenIntPoint
&
aPoint
mozilla
:
:
Modifiers
aModifiers
)
{
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
;
if
(
controller
)
{
if
(
Maybe
<
LayoutDevicePoint
>
geckoScreenPoint
=
ConvertToGecko
(
aPoint
)
)
{
TouchBlockState
*
touch
=
GetCurrentTouchBlock
(
)
;
if
(
touch
)
{
if
(
touch
-
>
IsDuringFastFling
(
)
)
{
APZC_LOG
(
"
%
p
dropping
single
-
tap
because
it
was
during
a
fast
-
fling
\
n
"
this
)
;
return
nsEventStatus_eIgnore
;
}
touch
-
>
SetSingleTapOccurred
(
)
;
}
APZC_LOG
(
"
posting
runnable
for
HandleTap
from
GenerateSingleTap
"
)
;
RefPtr
<
Runnable
>
runnable
=
NewRunnableMethod
<
TapType
LayoutDevicePoint
mozilla
:
:
Modifiers
ScrollableLayerGuid
uint64_t
>
(
"
layers
:
:
GeckoContentController
:
:
HandleTap
"
controller
&
GeckoContentController
:
:
HandleTap
aType
*
geckoScreenPoint
aModifiers
GetGuid
(
)
touch
?
touch
-
>
GetBlockId
(
)
:
0
)
;
controller
-
>
PostDelayedTask
(
runnable
.
forget
(
)
0
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
}
return
nsEventStatus_eIgnore
;
}
void
AsyncPanZoomController
:
:
OnTouchEndOrCancel
(
)
{
if
(
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
)
{
MOZ_ASSERT
(
GetCurrentTouchBlock
(
)
)
;
controller
-
>
NotifyAPZStateChange
(
GetGuid
(
)
APZStateChange
:
:
eEndTouch
GetCurrentTouchBlock
(
)
-
>
SingleTapOccurred
(
)
)
;
}
}
nsEventStatus
AsyncPanZoomController
:
:
OnSingleTapUp
(
const
TapGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
single
-
tap
-
up
in
state
%
d
\
n
"
this
mState
)
;
MOZ_ASSERT
(
GetCurrentTouchBlock
(
)
)
;
if
(
!
(
ZoomConstraintsAllowDoubleTapZoom
(
)
&
&
GetCurrentTouchBlock
(
)
-
>
TouchActionAllowsDoubleTapZoom
(
)
)
)
{
return
GenerateSingleTap
(
TapType
:
:
eSingleTap
aEvent
.
mPoint
aEvent
.
modifiers
)
;
}
return
nsEventStatus_eIgnore
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnSingleTapConfirmed
(
const
TapGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
single
-
tap
-
confirmed
in
state
%
d
\
n
"
this
mState
)
;
return
GenerateSingleTap
(
TapType
:
:
eSingleTap
aEvent
.
mPoint
aEvent
.
modifiers
)
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnDoubleTap
(
const
TapGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
double
-
tap
in
state
%
d
\
n
"
this
mState
)
;
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
;
if
(
controller
)
{
if
(
ZoomConstraintsAllowDoubleTapZoom
(
)
&
&
(
!
GetCurrentTouchBlock
(
)
|
|
GetCurrentTouchBlock
(
)
-
>
TouchActionAllowsDoubleTapZoom
(
)
)
)
{
if
(
Maybe
<
LayoutDevicePoint
>
geckoScreenPoint
=
ConvertToGecko
(
aEvent
.
mPoint
)
)
{
controller
-
>
HandleTap
(
TapType
:
:
eDoubleTap
*
geckoScreenPoint
aEvent
.
modifiers
GetGuid
(
)
GetCurrentTouchBlock
(
)
?
GetCurrentTouchBlock
(
)
-
>
GetBlockId
(
)
:
0
)
;
}
}
return
nsEventStatus_eConsumeNoDefault
;
}
return
nsEventStatus_eIgnore
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnSecondTap
(
const
TapGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
second
-
tap
in
state
%
d
\
n
"
this
mState
)
;
return
GenerateSingleTap
(
TapType
:
:
eSecondTap
aEvent
.
mPoint
aEvent
.
modifiers
)
;
}
nsEventStatus
AsyncPanZoomController
:
:
OnCancelTap
(
const
TapGestureInput
&
aEvent
)
{
APZC_LOG
(
"
%
p
got
a
cancel
-
tap
in
state
%
d
\
n
"
this
mState
)
;
return
nsEventStatus_eIgnore
;
}
ScreenToParentLayerMatrix4x4
AsyncPanZoomController
:
:
GetTransformToThis
(
)
const
{
if
(
APZCTreeManager
*
treeManagerLocal
=
GetApzcTreeManager
(
)
)
{
return
treeManagerLocal
-
>
GetScreenToApzcTransform
(
this
)
;
}
return
ScreenToParentLayerMatrix4x4
(
)
;
}
ScreenPoint
AsyncPanZoomController
:
:
ToScreenCoordinates
(
const
ParentLayerPoint
&
aVector
const
ParentLayerPoint
&
aAnchor
)
const
{
return
TransformVector
(
GetTransformToThis
(
)
.
Inverse
(
)
aVector
aAnchor
)
;
}
ParentLayerPoint
AsyncPanZoomController
:
:
ToParentLayerCoordinates
(
const
ScreenPoint
&
aVector
const
ScreenPoint
&
aAnchor
)
const
{
return
TransformVector
(
GetTransformToThis
(
)
aVector
aAnchor
)
;
}
ParentLayerPoint
AsyncPanZoomController
:
:
ToParentLayerCoordinates
(
const
ScreenPoint
&
aVector
const
ExternalPoint
&
aAnchor
)
const
{
return
ToParentLayerCoordinates
(
aVector
ViewAs
<
ScreenPixel
>
(
aAnchor
PixelCastJustification
:
:
ExternalIsScreen
)
)
;
}
ExternalPoint
AsyncPanZoomController
:
:
ToExternalPoint
(
const
ExternalPoint
&
aScreenOffset
const
ScreenPoint
&
aScreenPoint
)
{
return
aScreenOffset
+
ViewAs
<
ExternalPixel
>
(
aScreenPoint
PixelCastJustification
:
:
ExternalIsScreen
)
;
}
ScreenPoint
AsyncPanZoomController
:
:
PanVector
(
const
ExternalPoint
&
aPos
)
const
{
return
ScreenPoint
(
fabs
(
aPos
.
x
-
mStartTouch
.
x
)
fabs
(
aPos
.
y
-
mStartTouch
.
y
)
)
;
}
bool
AsyncPanZoomController
:
:
Contains
(
const
ScreenIntPoint
&
aPoint
)
const
{
ScreenToParentLayerMatrix4x4
transformToThis
=
GetTransformToThis
(
)
;
Maybe
<
ParentLayerIntPoint
>
point
=
UntransformBy
(
transformToThis
aPoint
)
;
if
(
!
point
)
{
return
false
;
}
ParentLayerIntRect
cb
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
GetFrameMetrics
(
)
.
GetCompositionBounds
(
)
.
ToIntRect
(
&
cb
)
;
}
return
cb
.
Contains
(
*
point
)
;
}
bool
AsyncPanZoomController
:
:
IsInOverscrollGutter
(
const
ScreenPoint
&
aHitTestPoint
)
const
{
if
(
!
IsOverscrolled
(
)
)
{
return
false
;
}
Maybe
<
ParentLayerPoint
>
apzcPoint
=
UntransformBy
(
GetTransformToThis
(
)
aHitTestPoint
)
;
if
(
!
apzcPoint
)
return
false
;
return
IsInOverscrollGutter
(
*
apzcPoint
)
;
}
bool
AsyncPanZoomController
:
:
IsInOverscrollGutter
(
const
ParentLayerPoint
&
aHitTestPoint
)
const
{
ParentLayerRect
compositionBounds
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
compositionBounds
=
GetFrameMetrics
(
)
.
GetCompositionBounds
(
)
;
}
if
(
!
compositionBounds
.
Contains
(
aHitTestPoint
)
)
{
return
false
;
}
auto
overscrollTransform
=
GetOverscrollTransform
(
eForHitTesting
)
;
ParentLayerPoint
overscrollUntransformed
=
overscrollTransform
.
Inverse
(
)
.
TransformPoint
(
aHitTestPoint
)
;
if
(
compositionBounds
.
Contains
(
overscrollUntransformed
)
)
{
return
false
;
}
return
true
;
}
bool
AsyncPanZoomController
:
:
IsOverscrolled
(
)
const
{
if
(
StaticPrefs
:
:
apz_overscroll_test_async_scroll_offset_enabled
(
)
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
AutoApplyAsyncTestAttributes
testAttributeApplier
(
this
lock
)
;
return
mX
.
IsOverscrolled
(
)
|
|
mY
.
IsOverscrolled
(
)
;
}
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
mX
.
IsOverscrolled
(
)
|
|
mY
.
IsOverscrolled
(
)
;
}
bool
AsyncPanZoomController
:
:
IsInInvalidOverscroll
(
)
const
{
return
mX
.
IsInInvalidOverscroll
(
)
|
|
mY
.
IsInInvalidOverscroll
(
)
;
}
ParentLayerPoint
AsyncPanZoomController
:
:
PanStart
(
)
const
{
return
ParentLayerPoint
(
mX
.
PanStart
(
)
mY
.
PanStart
(
)
)
;
}
const
ParentLayerPoint
AsyncPanZoomController
:
:
GetVelocityVector
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
ParentLayerPoint
(
mX
.
GetVelocity
(
)
mY
.
GetVelocity
(
)
)
;
}
void
AsyncPanZoomController
:
:
SetVelocityVector
(
const
ParentLayerPoint
&
aVelocityVector
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
mX
.
SetVelocity
(
aVelocityVector
.
x
)
;
mY
.
SetVelocity
(
aVelocityVector
.
y
)
;
}
void
AsyncPanZoomController
:
:
HandlePanningWithTouchAction
(
double
aAngle
)
{
MOZ_ASSERT
(
GetCurrentTouchBlock
(
)
)
;
RefPtr
<
const
OverscrollHandoffChain
>
overscrollHandoffChain
=
GetCurrentInputBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
;
bool
canScrollHorizontal
=
!
mX
.
IsAxisLocked
(
)
&
&
overscrollHandoffChain
-
>
CanScrollInDirection
(
this
ScrollDirection
:
:
eHorizontal
)
;
bool
canScrollVertical
=
!
mY
.
IsAxisLocked
(
)
&
&
overscrollHandoffChain
-
>
CanScrollInDirection
(
this
ScrollDirection
:
:
eVertical
)
;
if
(
GetCurrentTouchBlock
(
)
-
>
TouchActionAllowsPanningXY
(
)
)
{
if
(
canScrollHorizontal
&
&
canScrollVertical
)
{
if
(
apz
:
:
IsCloseToHorizontal
(
aAngle
StaticPrefs
:
:
apz_axis_lock_lock_angle
(
)
)
)
{
mY
.
SetAxisLocked
(
true
)
;
SetState
(
PANNING_LOCKED_X
)
;
}
else
if
(
apz
:
:
IsCloseToVertical
(
aAngle
StaticPrefs
:
:
apz_axis_lock_lock_angle
(
)
)
)
{
mX
.
SetAxisLocked
(
true
)
;
SetState
(
PANNING_LOCKED_Y
)
;
}
else
{
SetState
(
PANNING
)
;
}
}
else
if
(
canScrollHorizontal
|
|
canScrollVertical
)
{
SetState
(
PANNING
)
;
}
else
{
SetState
(
NOTHING
)
;
}
}
else
if
(
GetCurrentTouchBlock
(
)
-
>
TouchActionAllowsPanningX
(
)
)
{
if
(
apz
:
:
IsCloseToHorizontal
(
aAngle
StaticPrefs
:
:
apz_axis_lock_direct_pan_angle
(
)
)
)
{
mY
.
SetAxisLocked
(
true
)
;
SetState
(
PANNING_LOCKED_X
)
;
mPanDirRestricted
=
true
;
}
else
{
SetState
(
NOTHING
)
;
}
}
else
if
(
GetCurrentTouchBlock
(
)
-
>
TouchActionAllowsPanningY
(
)
)
{
if
(
apz
:
:
IsCloseToVertical
(
aAngle
StaticPrefs
:
:
apz_axis_lock_direct_pan_angle
(
)
)
)
{
mX
.
SetAxisLocked
(
true
)
;
SetState
(
PANNING_LOCKED_Y
)
;
mPanDirRestricted
=
true
;
}
else
{
SetState
(
NOTHING
)
;
}
}
else
{
SetState
(
NOTHING
)
;
}
if
(
!
IsInPanningState
(
)
)
{
mX
.
SetVelocity
(
0
)
;
mY
.
SetVelocity
(
0
)
;
}
}
void
AsyncPanZoomController
:
:
HandlePanning
(
double
aAngle
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
MOZ_ASSERT
(
GetCurrentInputBlock
(
)
)
;
RefPtr
<
const
OverscrollHandoffChain
>
overscrollHandoffChain
=
GetCurrentInputBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
;
bool
canScrollHorizontal
=
!
mX
.
IsAxisLocked
(
)
&
&
overscrollHandoffChain
-
>
CanScrollInDirection
(
this
ScrollDirection
:
:
eHorizontal
)
;
bool
canScrollVertical
=
!
mY
.
IsAxisLocked
(
)
&
&
overscrollHandoffChain
-
>
CanScrollInDirection
(
this
ScrollDirection
:
:
eVertical
)
;
if
(
!
canScrollHorizontal
|
|
!
canScrollVertical
)
{
SetState
(
PANNING
)
;
}
else
if
(
apz
:
:
IsCloseToHorizontal
(
aAngle
StaticPrefs
:
:
apz_axis_lock_lock_angle
(
)
)
)
{
mY
.
SetAxisLocked
(
true
)
;
if
(
canScrollHorizontal
)
{
SetState
(
PANNING_LOCKED_X
)
;
}
}
else
if
(
apz
:
:
IsCloseToVertical
(
aAngle
StaticPrefs
:
:
apz_axis_lock_lock_angle
(
)
)
)
{
mX
.
SetAxisLocked
(
true
)
;
if
(
canScrollVertical
)
{
SetState
(
PANNING_LOCKED_Y
)
;
}
}
else
{
SetState
(
PANNING
)
;
}
}
void
AsyncPanZoomController
:
:
HandlePanningUpdate
(
const
ScreenPoint
&
aPanDistance
)
{
if
(
GetAxisLockMode
(
)
=
=
STICKY
&
&
!
mPanDirRestricted
)
{
ParentLayerPoint
vector
=
ToParentLayerCoordinates
(
aPanDistance
mStartTouch
)
;
double
angle
=
atan2
(
vector
.
y
vector
.
x
)
;
angle
=
fabs
(
angle
)
;
float
breakThreshold
=
StaticPrefs
:
:
apz_axis_lock_breakout_threshold
(
)
*
GetDPI
(
)
;
if
(
fabs
(
aPanDistance
.
x
)
>
breakThreshold
|
|
fabs
(
aPanDistance
.
y
)
>
breakThreshold
)
{
if
(
mState
=
=
PANNING_LOCKED_X
)
{
if
(
!
apz
:
:
IsCloseToHorizontal
(
angle
StaticPrefs
:
:
apz_axis_lock_breakout_angle
(
)
)
)
{
mY
.
SetAxisLocked
(
false
)
;
SetState
(
PANNING
)
;
}
}
else
if
(
mState
=
=
PANNING_LOCKED_Y
)
{
if
(
!
apz
:
:
IsCloseToVertical
(
angle
StaticPrefs
:
:
apz_axis_lock_breakout_angle
(
)
)
)
{
mX
.
SetAxisLocked
(
false
)
;
SetState
(
PANNING
)
;
}
}
}
}
}
void
AsyncPanZoomController
:
:
HandlePinchLocking
(
const
PinchGestureInput
&
aEvent
)
{
ParentLayerCoord
bufferedSpanDistance
;
ParentLayerPoint
focusPoint
bufferedFocusChange
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
focusPoint
=
mPinchEventBuffer
.
back
(
)
.
mLocalFocusPoint
-
Metrics
(
)
.
GetCompositionBounds
(
)
.
TopLeft
(
)
;
ParentLayerPoint
bufferedLastZoomFocus
=
(
mPinchEventBuffer
.
size
(
)
>
1
)
?
mPinchEventBuffer
.
front
(
)
.
mLocalFocusPoint
-
Metrics
(
)
.
GetCompositionBounds
(
)
.
TopLeft
(
)
:
mLastZoomFocus
;
bufferedFocusChange
=
bufferedLastZoomFocus
-
focusPoint
;
bufferedSpanDistance
=
fabsf
(
mPinchEventBuffer
.
front
(
)
.
mPreviousSpan
-
mPinchEventBuffer
.
back
(
)
.
mCurrentSpan
)
;
}
ScreenCoord
spanDistance
=
ToScreenCoordinates
(
ParentLayerPoint
(
0
bufferedSpanDistance
)
focusPoint
)
.
Length
(
)
;
ScreenPoint
focusChange
=
ToScreenCoordinates
(
bufferedFocusChange
focusPoint
)
;
if
(
mPinchLocked
)
{
if
(
GetPinchLockMode
(
)
=
=
PINCH_STICKY
)
{
ScreenCoord
spanBreakoutThreshold
=
StaticPrefs
:
:
apz_pinch_lock_span_breakout_threshold
(
)
*
GetDPI
(
)
;
mPinchLocked
=
!
(
spanDistance
>
spanBreakoutThreshold
)
;
}
}
else
{
if
(
GetPinchLockMode
(
)
!
=
PINCH_FREE
)
{
ScreenCoord
spanLockThreshold
=
StaticPrefs
:
:
apz_pinch_lock_span_lock_threshold
(
)
*
GetDPI
(
)
;
ScreenCoord
scrollLockThreshold
=
StaticPrefs
:
:
apz_pinch_lock_scroll_lock_threshold
(
)
*
GetDPI
(
)
;
if
(
spanDistance
<
spanLockThreshold
&
&
focusChange
.
Length
(
)
>
scrollLockThreshold
)
{
mPinchLocked
=
true
;
StartTouch
(
aEvent
.
mLocalFocusPoint
aEvent
.
mTimeStamp
)
;
}
}
}
}
nsEventStatus
AsyncPanZoomController
:
:
StartPanning
(
const
ExternalPoint
&
aStartPoint
const
TimeStamp
&
aEventTime
)
{
ParentLayerPoint
vector
=
ToParentLayerCoordinates
(
PanVector
(
aStartPoint
)
mStartTouch
)
;
double
angle
=
atan2
(
vector
.
y
vector
.
x
)
;
angle
=
fabs
(
angle
)
;
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
StaticPrefs
:
:
layout_css_touch_action_enabled
(
)
)
{
HandlePanningWithTouchAction
(
angle
)
;
}
else
{
if
(
GetAxisLockMode
(
)
=
=
FREE
)
{
SetState
(
PANNING
)
;
}
else
{
HandlePanning
(
angle
)
;
}
}
if
(
IsInPanningState
(
)
)
{
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
SCROLL_INPUT_METHODS
(
uint32_t
)
ScrollInputMethod
:
:
ApzTouch
)
;
mTouchStartRestingTimeBeforePan
=
aEventTime
-
mTouchStartTime
;
mMinimumVelocityDuringPan
=
Nothing
(
)
;
if
(
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
)
{
controller
-
>
NotifyAPZStateChange
(
GetGuid
(
)
APZStateChange
:
:
eStartPanning
)
;
}
return
nsEventStatus_eConsumeNoDefault
;
}
return
nsEventStatus_eIgnore
;
}
void
AsyncPanZoomController
:
:
UpdateWithTouchAtDevicePoint
(
const
MultiTouchInput
&
aEvent
)
{
const
SingleTouchData
&
touchData
=
aEvent
.
mTouches
[
0
]
;
for
(
const
auto
&
historicalData
:
touchData
.
mHistoricalData
)
{
ParentLayerPoint
historicalPoint
=
historicalData
.
mLocalScreenPoint
;
mX
.
UpdateWithTouchAtDevicePoint
(
historicalPoint
.
x
historicalData
.
mTimeStamp
)
;
mY
.
UpdateWithTouchAtDevicePoint
(
historicalPoint
.
y
historicalData
.
mTimeStamp
)
;
}
ParentLayerPoint
point
=
touchData
.
mLocalScreenPoint
;
mX
.
UpdateWithTouchAtDevicePoint
(
point
.
x
aEvent
.
mTimeStamp
)
;
mY
.
UpdateWithTouchAtDevicePoint
(
point
.
y
aEvent
.
mTimeStamp
)
;
}
Maybe
<
CompositionPayload
>
AsyncPanZoomController
:
:
NotifyScrollSampling
(
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
mSampledState
.
front
(
)
.
TakeScrollPayload
(
)
;
}
bool
AsyncPanZoomController
:
:
AttemptScroll
(
ParentLayerPoint
&
aStartPoint
ParentLayerPoint
&
aEndPoint
OverscrollHandoffState
&
aOverscrollHandoffState
)
{
ParentLayerPoint
displacement
=
aStartPoint
-
aEndPoint
;
ParentLayerPoint
overscroll
;
bool
scrollThisApzc
=
false
;
if
(
InputBlockState
*
block
=
GetCurrentInputBlock
(
)
)
{
scrollThisApzc
=
!
block
-
>
GetScrolledApzc
(
)
|
|
block
-
>
IsDownchainOfScrolledApzc
(
this
)
;
}
ParentLayerPoint
adjustedDisplacement
;
if
(
scrollThisApzc
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
bool
respectDisregardedDirections
=
ScrollSourceRespectsDisregardedDirections
(
aOverscrollHandoffState
.
mScrollSource
)
;
bool
forcesVerticalOverscroll
=
respectDisregardedDirections
&
&
mScrollMetadata
.
GetDisregardedDirection
(
)
=
=
Some
(
ScrollDirection
:
:
eVertical
)
;
bool
forcesHorizontalOverscroll
=
respectDisregardedDirections
&
&
mScrollMetadata
.
GetDisregardedDirection
(
)
=
=
Some
(
ScrollDirection
:
:
eHorizontal
)
;
bool
yChanged
=
mY
.
AdjustDisplacement
(
displacement
.
y
adjustedDisplacement
.
y
overscroll
.
y
forcesVerticalOverscroll
)
;
bool
xChanged
=
mX
.
AdjustDisplacement
(
displacement
.
x
adjustedDisplacement
.
x
overscroll
.
x
forcesHorizontalOverscroll
)
;
if
(
xChanged
|
|
yChanged
)
{
ScheduleComposite
(
)
;
}
if
(
!
IsZero
(
adjustedDisplacement
)
&
&
Metrics
(
)
.
GetZoom
(
)
!
=
CSSToParentLayerScale2D
(
0
0
)
)
{
ScrollBy
(
adjustedDisplacement
/
Metrics
(
)
.
GetZoom
(
)
)
;
if
(
InputBlockState
*
block
=
GetCurrentInputBlock
(
)
)
{
bool
displacementIsUserVisible
=
true
;
{
RecursiveMutexAutoUnlock
unlock
(
mRecursiveMutex
)
;
ScreenIntPoint
screenDisplacement
=
RoundedToInt
(
ToScreenCoordinates
(
adjustedDisplacement
aStartPoint
)
)
;
if
(
screenDisplacement
=
=
ScreenIntPoint
(
)
)
{
displacementIsUserVisible
=
false
;
}
}
if
(
displacementIsUserVisible
)
{
block
-
>
SetScrolledApzc
(
this
)
;
}
}
ScheduleCompositeAndMaybeRepaint
(
)
;
UpdateSharedCompositorFrameMetrics
(
)
;
}
aStartPoint
=
aEndPoint
+
overscroll
;
}
else
{
overscroll
=
displacement
;
}
if
(
!
IsZero
(
adjustedDisplacement
)
)
{
aOverscrollHandoffState
.
mTotalMovement
+
=
ToScreenCoordinates
(
adjustedDisplacement
aEndPoint
)
;
}
if
(
IsZero
(
overscroll
)
)
{
return
true
;
}
if
(
AllowScrollHandoffInCurrentBlock
(
)
)
{
+
+
aOverscrollHandoffState
.
mChainIndex
;
bool
consumed
=
CallDispatchScroll
(
aStartPoint
aEndPoint
aOverscrollHandoffState
)
;
if
(
consumed
)
{
return
true
;
}
overscroll
=
aStartPoint
-
aEndPoint
;
MOZ_ASSERT
(
!
IsZero
(
overscroll
)
)
;
}
if
(
ScrollSourceAllowsOverscroll
(
aOverscrollHandoffState
.
mScrollSource
)
)
{
APZC_LOG
(
"
%
p
taking
overscroll
during
panning
\
n
"
this
)
;
ParentLayerPoint
prevVisualOverscroll
=
GetOverscrollAmount
(
)
;
OverscrollForPanning
(
overscroll
aOverscrollHandoffState
.
mPanDistance
)
;
ParentLayerPoint
visualOverscrollChange
=
GetOverscrollAmount
(
)
-
prevVisualOverscroll
;
if
(
!
IsZero
(
visualOverscrollChange
)
)
{
aOverscrollHandoffState
.
mTotalMovement
+
=
ToScreenCoordinates
(
visualOverscrollChange
aEndPoint
)
;
}
}
aStartPoint
=
aEndPoint
+
overscroll
;
return
IsZero
(
overscroll
)
;
}
void
AsyncPanZoomController
:
:
OverscrollForPanning
(
ParentLayerPoint
&
aOverscroll
const
ScreenPoint
&
aPanDistance
)
{
if
(
!
IsOverscrolled
(
)
)
{
if
(
aPanDistance
.
x
<
StaticPrefs
:
:
apz_overscroll_min_pan_distance_ratio
(
)
*
aPanDistance
.
y
)
{
aOverscroll
.
x
=
0
;
}
if
(
aPanDistance
.
y
<
StaticPrefs
:
:
apz_overscroll_min_pan_distance_ratio
(
)
*
aPanDistance
.
x
)
{
aOverscroll
.
y
=
0
;
}
}
OverscrollBy
(
aOverscroll
)
;
}
ScrollDirections
AsyncPanZoomController
:
:
GetOverscrollableDirections
(
)
const
{
ScrollDirections
result
;
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
mScrollMetadata
.
GetDisregardedDirection
(
)
)
{
return
result
;
}
if
(
mX
.
CanScroll
(
)
&
&
mX
.
OverscrollBehaviorAllowsOverscrollEffect
(
)
)
{
result
+
=
ScrollDirection
:
:
eHorizontal
;
}
if
(
mY
.
CanScroll
(
)
&
&
mY
.
OverscrollBehaviorAllowsOverscrollEffect
(
)
)
{
result
+
=
ScrollDirection
:
:
eVertical
;
}
return
result
;
}
void
AsyncPanZoomController
:
:
OverscrollBy
(
ParentLayerPoint
&
aOverscroll
)
{
if
(
!
StaticPrefs
:
:
apz_overscroll_enabled
(
)
)
{
return
;
}
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
ScrollDirections
overscrollableDirections
=
GetOverscrollableDirections
(
)
;
if
(
FuzzyEqualsAdditive
(
aOverscroll
.
x
0
.
0f
COORDINATE_EPSILON
)
)
{
overscrollableDirections
-
=
ScrollDirection
:
:
eHorizontal
;
}
if
(
FuzzyEqualsAdditive
(
aOverscroll
.
y
0
.
0f
COORDINATE_EPSILON
)
)
{
overscrollableDirections
-
=
ScrollDirection
:
:
eVertical
;
}
mOverscrollEffect
-
>
ConsumeOverscroll
(
aOverscroll
overscrollableDirections
)
;
}
RefPtr
<
const
OverscrollHandoffChain
>
AsyncPanZoomController
:
:
BuildOverscrollHandoffChain
(
)
{
if
(
APZCTreeManager
*
treeManagerLocal
=
GetApzcTreeManager
(
)
)
{
return
treeManagerLocal
-
>
BuildOverscrollHandoffChain
(
this
)
;
}
OverscrollHandoffChain
*
result
=
new
OverscrollHandoffChain
;
result
-
>
Add
(
this
)
;
return
result
;
}
ParentLayerPoint
AsyncPanZoomController
:
:
AttemptFling
(
const
FlingHandoffState
&
aHandoffState
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
float
PLPPI
=
ComputePLPPI
(
PanStart
(
)
aHandoffState
.
mVelocity
)
;
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
!
IsPannable
(
)
)
{
return
aHandoffState
.
mVelocity
;
}
APZC_LOG
(
"
%
p
accepting
fling
with
velocity
%
s
\
n
"
this
ToString
(
aHandoffState
.
mVelocity
)
.
c_str
(
)
)
;
ParentLayerPoint
residualVelocity
=
aHandoffState
.
mVelocity
;
if
(
mX
.
CanScroll
(
)
)
{
mX
.
SetVelocity
(
mX
.
GetVelocity
(
)
+
aHandoffState
.
mVelocity
.
x
)
;
residualVelocity
.
x
=
0
;
}
if
(
mY
.
CanScroll
(
)
)
{
mY
.
SetVelocity
(
mY
.
GetVelocity
(
)
+
aHandoffState
.
mVelocity
.
y
)
;
residualVelocity
.
y
=
0
;
}
ParentLayerPoint
velocity
=
GetVelocityVector
(
)
;
if
(
!
velocity
.
IsFinite
(
)
|
|
velocity
.
Length
(
)
<
=
StaticPrefs
:
:
apz_fling_min_velocity_threshold
(
)
)
{
aHandoffState
.
mChain
-
>
SnapBackOverscrolledApzc
(
this
)
;
return
residualVelocity
;
}
ScrollSnapToDestination
(
)
;
if
(
mState
!
=
SMOOTHMSD_SCROLL
)
{
SetState
(
FLING
)
;
AsyncPanZoomAnimation
*
fling
=
GetPlatformSpecificState
(
)
-
>
CreateFlingAnimation
(
*
this
aHandoffState
PLPPI
)
;
StartAnimation
(
fling
)
;
}
return
residualVelocity
;
}
float
AsyncPanZoomController
:
:
ComputePLPPI
(
ParentLayerPoint
aPoint
ParentLayerPoint
aDirection
)
const
{
if
(
aDirection
=
=
ParentLayerPoint
(
)
)
{
return
GetDPI
(
)
;
}
aDirection
=
aDirection
/
aDirection
.
Length
(
)
;
float
screenPerParent
=
ToScreenCoordinates
(
aDirection
aPoint
)
.
Length
(
)
;
return
GetDPI
(
)
/
screenPerParent
;
}
Maybe
<
CSSPoint
>
AsyncPanZoomController
:
:
GetCurrentAnimationDestination
(
const
RecursiveMutexAutoLock
&
aProofOfLock
)
const
{
if
(
mState
=
=
WHEEL_SCROLL
)
{
return
Some
(
mAnimation
-
>
AsWheelScrollAnimation
(
)
-
>
GetDestination
(
)
)
;
}
if
(
mState
=
=
SMOOTH_SCROLL
)
{
return
Some
(
mAnimation
-
>
AsSmoothScrollAnimation
(
)
-
>
GetDestination
(
)
)
;
}
if
(
mState
=
=
SMOOTHMSD_SCROLL
)
{
return
Some
(
mAnimation
-
>
AsSmoothMsdScrollAnimation
(
)
-
>
GetDestination
(
)
)
;
}
if
(
mState
=
=
KEYBOARD_SCROLL
)
{
return
Some
(
mAnimation
-
>
AsSmoothScrollAnimation
(
)
-
>
GetDestination
(
)
)
;
}
return
Nothing
(
)
;
}
ParentLayerPoint
AsyncPanZoomController
:
:
AdjustHandoffVelocityForOverscrollBehavior
(
ParentLayerPoint
&
aHandoffVelocity
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
ParentLayerPoint
residualVelocity
;
if
(
!
mX
.
OverscrollBehaviorAllowsHandoff
(
)
)
{
residualVelocity
.
x
=
aHandoffVelocity
.
x
;
aHandoffVelocity
.
x
=
0
;
}
if
(
!
mY
.
OverscrollBehaviorAllowsHandoff
(
)
)
{
residualVelocity
.
y
=
aHandoffVelocity
.
y
;
aHandoffVelocity
.
y
=
0
;
}
return
residualVelocity
;
}
bool
AsyncPanZoomController
:
:
OverscrollBehaviorAllowsSwipe
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
mX
.
OverscrollBehaviorAllowsHandoff
(
)
;
}
void
AsyncPanZoomController
:
:
HandleFlingOverscroll
(
const
ParentLayerPoint
&
aVelocity
SideBits
aOverscrollSideBits
const
RefPtr
<
const
OverscrollHandoffChain
>
&
aOverscrollHandoffChain
const
RefPtr
<
const
AsyncPanZoomController
>
&
aScrolledApzc
)
{
APZCTreeManager
*
treeManagerLocal
=
GetApzcTreeManager
(
)
;
if
(
treeManagerLocal
)
{
const
FlingHandoffState
handoffState
{
aVelocity
aOverscrollHandoffChain
Nothing
(
)
0
true
aScrolledApzc
}
;
ParentLayerPoint
residualVelocity
=
treeManagerLocal
-
>
DispatchFling
(
this
handoffState
)
;
FLING_LOG
(
"
APZC
%
p
left
with
residual
velocity
%
s
\
n
"
this
ToString
(
residualVelocity
)
.
c_str
(
)
)
;
if
(
!
IsZero
(
residualVelocity
)
&
&
IsPannable
(
)
&
&
StaticPrefs
:
:
apz_overscroll_enabled
(
)
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
!
mX
.
OverscrollBehaviorAllowsOverscrollEffect
(
)
)
{
residualVelocity
.
x
=
0
;
}
if
(
!
mY
.
OverscrollBehaviorAllowsOverscrollEffect
(
)
)
{
residualVelocity
.
y
=
0
;
}
if
(
!
IsZero
(
residualVelocity
)
)
{
mOverscrollEffect
-
>
HandleFlingOverscroll
(
residualVelocity
aOverscrollSideBits
)
;
}
}
}
}
void
AsyncPanZoomController
:
:
HandleSmoothScrollOverscroll
(
const
ParentLayerPoint
&
aVelocity
SideBits
aOverscrollSideBits
)
{
HandleFlingOverscroll
(
aVelocity
aOverscrollSideBits
BuildOverscrollHandoffChain
(
)
nullptr
)
;
}
void
AsyncPanZoomController
:
:
SmoothScrollTo
(
const
CSSPoint
&
aDestination
const
ScrollOrigin
&
aOrigin
)
{
nsPoint
destination
=
CSSPoint
:
:
ToAppUnits
(
aDestination
)
;
nsSize
velocity
;
if
(
Metrics
(
)
.
GetZoom
(
)
!
=
CSSToParentLayerScale2D
(
0
0
)
)
{
velocity
=
CSSSize
:
:
ToAppUnits
(
ParentLayerSize
(
mX
.
GetVelocity
(
)
*
1000
.
0f
mY
.
GetVelocity
(
)
*
1000
.
0f
)
/
Metrics
(
)
.
GetZoom
(
)
)
;
}
if
(
mState
=
=
SMOOTH_SCROLL
&
&
mAnimation
)
{
RefPtr
<
SmoothScrollAnimation
>
animation
(
mAnimation
-
>
AsSmoothScrollAnimation
(
)
)
;
if
(
animation
-
>
GetScrollOrigin
(
)
=
=
aOrigin
)
{
APZC_LOG
(
"
%
p
updating
destination
on
existing
animation
\
n
"
this
)
;
animation
-
>
UpdateDestination
(
GetFrameTime
(
)
.
Time
(
)
destination
velocity
)
;
return
;
}
}
CancelAnimation
(
)
;
SetState
(
SMOOTH_SCROLL
)
;
nsPoint
initialPosition
=
CSSPoint
:
:
ToAppUnits
(
Metrics
(
)
.
GetVisualScrollOffset
(
)
)
;
RefPtr
<
SmoothScrollAnimation
>
animation
=
new
SmoothScrollAnimation
(
*
this
initialPosition
aOrigin
)
;
animation
-
>
UpdateDestination
(
GetFrameTime
(
)
.
Time
(
)
destination
velocity
)
;
StartAnimation
(
animation
.
get
(
)
)
;
}
void
AsyncPanZoomController
:
:
SmoothMsdScrollTo
(
const
CSSPoint
&
aDestination
)
{
if
(
mState
=
=
SMOOTHMSD_SCROLL
&
&
mAnimation
)
{
APZC_LOG
(
"
%
p
updating
destination
on
existing
animation
\
n
"
this
)
;
RefPtr
<
SmoothMsdScrollAnimation
>
animation
(
static_cast
<
SmoothMsdScrollAnimation
*
>
(
mAnimation
.
get
(
)
)
)
;
animation
-
>
SetDestination
(
aDestination
)
;
}
else
{
CancelAnimation
(
)
;
SetState
(
SMOOTHMSD_SCROLL
)
;
CSSPoint
initialVelocity
;
if
(
Metrics
(
)
.
GetZoom
(
)
!
=
CSSToParentLayerScale2D
(
0
0
)
)
{
initialVelocity
=
ParentLayerPoint
(
mX
.
GetVelocity
(
)
*
1000
.
0f
mY
.
GetVelocity
(
)
*
1000
.
0f
)
/
Metrics
(
)
.
GetZoom
(
)
;
}
StartAnimation
(
new
SmoothMsdScrollAnimation
(
*
this
Metrics
(
)
.
GetVisualScrollOffset
(
)
initialVelocity
aDestination
StaticPrefs
:
:
layout_css_scroll_behavior_spring_constant
(
)
StaticPrefs
:
:
layout_css_scroll_behavior_damping_ratio
(
)
)
)
;
}
}
void
AsyncPanZoomController
:
:
StartOverscrollAnimation
(
const
ParentLayerPoint
&
aVelocity
SideBits
aOverscrollSideBits
)
{
SetState
(
OVERSCROLL_ANIMATION
)
;
ParentLayerPoint
velocity
=
aVelocity
;
AdjustDeltaForAllowedScrollDirections
(
velocity
GetOverscrollableDirections
(
)
)
;
StartAnimation
(
new
OverscrollAnimation
(
*
this
velocity
aOverscrollSideBits
)
)
;
}
bool
AsyncPanZoomController
:
:
CallDispatchScroll
(
ParentLayerPoint
&
aStartPoint
ParentLayerPoint
&
aEndPoint
OverscrollHandoffState
&
aOverscrollHandoffState
)
{
APZCTreeManager
*
treeManagerLocal
=
GetApzcTreeManager
(
)
;
if
(
!
treeManagerLocal
)
{
return
false
;
}
ParentLayerPoint
endPoint
=
aEndPoint
;
if
(
aOverscrollHandoffState
.
mChainIndex
>
0
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
!
mX
.
OverscrollBehaviorAllowsHandoff
(
)
)
{
endPoint
.
x
=
aStartPoint
.
x
;
}
if
(
!
mY
.
OverscrollBehaviorAllowsHandoff
(
)
)
{
endPoint
.
y
=
aStartPoint
.
y
;
}
if
(
aStartPoint
=
=
endPoint
)
{
return
false
;
}
}
return
treeManagerLocal
-
>
DispatchScroll
(
this
aStartPoint
endPoint
aOverscrollHandoffState
)
;
}
void
AsyncPanZoomController
:
:
RecordScrollPayload
(
const
TimeStamp
&
aTimeStamp
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
!
mScrollPayload
)
{
mScrollPayload
=
Some
(
CompositionPayload
{
CompositionPayloadType
:
:
eAPZScroll
aTimeStamp
}
)
;
}
}
void
AsyncPanZoomController
:
:
StartTouch
(
const
ParentLayerPoint
&
aPoint
TimeStamp
aTimestamp
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
mX
.
StartTouch
(
aPoint
.
x
aTimestamp
)
;
mY
.
StartTouch
(
aPoint
.
y
aTimestamp
)
;
}
void
AsyncPanZoomController
:
:
EndTouch
(
TimeStamp
aTimestamp
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
mX
.
EndTouch
(
aTimestamp
)
;
mY
.
EndTouch
(
aTimestamp
)
;
}
void
AsyncPanZoomController
:
:
TrackTouch
(
const
MultiTouchInput
&
aEvent
)
{
ExternalPoint
extPoint
=
GetFirstExternalTouchPoint
(
aEvent
)
;
ScreenPoint
panVector
=
PanVector
(
extPoint
)
;
HandlePanningUpdate
(
panVector
)
;
ParentLayerPoint
prevTouchPoint
(
mX
.
GetPos
(
)
mY
.
GetPos
(
)
)
;
ParentLayerPoint
touchPoint
=
GetFirstTouchPoint
(
aEvent
)
;
UpdateWithTouchAtDevicePoint
(
aEvent
)
;
auto
velocity
=
GetVelocityVector
(
)
.
Length
(
)
;
if
(
mMinimumVelocityDuringPan
)
{
mMinimumVelocityDuringPan
=
Some
(
std
:
:
min
(
*
mMinimumVelocityDuringPan
velocity
)
)
;
}
else
{
mMinimumVelocityDuringPan
=
Some
(
velocity
)
;
}
if
(
prevTouchPoint
!
=
touchPoint
)
{
MOZ_ASSERT
(
GetCurrentTouchBlock
(
)
)
;
OverscrollHandoffState
handoffState
(
*
GetCurrentTouchBlock
(
)
-
>
GetOverscrollHandoffChain
(
)
panVector
ScrollSource
:
:
Touchscreen
)
;
RecordScrollPayload
(
aEvent
.
mTimeStamp
)
;
CallDispatchScroll
(
prevTouchPoint
touchPoint
handoffState
)
;
}
}
ParentLayerPoint
AsyncPanZoomController
:
:
GetFirstTouchPoint
(
const
MultiTouchInput
&
aEvent
)
{
return
(
(
SingleTouchData
&
)
aEvent
.
mTouches
[
0
]
)
.
mLocalScreenPoint
;
}
ExternalPoint
AsyncPanZoomController
:
:
GetFirstExternalTouchPoint
(
const
MultiTouchInput
&
aEvent
)
{
return
ToExternalPoint
(
aEvent
.
mScreenOffset
(
(
SingleTouchData
&
)
aEvent
.
mTouches
[
0
]
)
.
mScreenPoint
)
;
}
ParentLayerPoint
AsyncPanZoomController
:
:
GetOverscrollAmount
(
)
const
{
if
(
StaticPrefs
:
:
apz_overscroll_test_async_scroll_offset_enabled
(
)
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
AutoApplyAsyncTestAttributes
testAttributeApplier
(
this
lock
)
;
return
GetOverscrollAmountInternal
(
)
;
}
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
GetOverscrollAmountInternal
(
)
;
}
ParentLayerPoint
AsyncPanZoomController
:
:
GetOverscrollAmountInternal
(
)
const
{
return
{
mX
.
GetOverscroll
(
)
mY
.
GetOverscroll
(
)
}
;
}
SideBits
AsyncPanZoomController
:
:
GetOverscrollSideBits
(
)
const
{
return
apz
:
:
GetOverscrollSideBits
(
{
mX
.
GetOverscroll
(
)
mY
.
GetOverscroll
(
)
}
)
;
}
void
AsyncPanZoomController
:
:
RestoreOverscrollAmount
(
const
ParentLayerPoint
&
aOverscroll
)
{
mX
.
RestoreOverscroll
(
aOverscroll
.
x
)
;
mY
.
RestoreOverscroll
(
aOverscroll
.
y
)
;
}
void
AsyncPanZoomController
:
:
StartAnimation
(
AsyncPanZoomAnimation
*
aAnimation
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
mAnimation
=
aAnimation
;
mLastSampleTime
=
GetFrameTime
(
)
;
ScheduleComposite
(
)
;
}
void
AsyncPanZoomController
:
:
CancelAnimation
(
CancelAnimationFlags
aFlags
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
APZC_LOG
(
"
%
p
running
CancelAnimation
(
0x
%
x
)
in
state
%
d
\
n
"
this
aFlags
mState
)
;
if
(
(
aFlags
&
ExcludeWheel
)
&
&
mState
=
=
WHEEL_SCROLL
)
{
return
;
}
if
(
mAnimation
)
{
mAnimation
-
>
Cancel
(
aFlags
)
;
}
SetState
(
NOTHING
)
;
mAnimation
=
nullptr
;
bool
repaint
=
!
IsZero
(
GetVelocityVector
(
)
)
;
mX
.
SetVelocity
(
0
)
;
mY
.
SetVelocity
(
0
)
;
mX
.
SetAxisLocked
(
false
)
;
mY
.
SetAxisLocked
(
false
)
;
if
(
!
(
aFlags
&
ExcludeOverscroll
)
&
&
IsOverscrolled
(
)
)
{
ClearOverscroll
(
)
;
repaint
=
true
;
}
if
(
aFlags
&
CancelAnimationFlags
:
:
ScrollSnap
)
{
ScrollSnap
(
)
;
}
if
(
repaint
)
{
RequestContentRepaint
(
)
;
ScheduleComposite
(
)
;
UpdateSharedCompositorFrameMetrics
(
)
;
}
}
void
AsyncPanZoomController
:
:
ClearOverscroll
(
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
mX
.
ClearOverscroll
(
)
;
mY
.
ClearOverscroll
(
)
;
}
void
AsyncPanZoomController
:
:
SetCompositorController
(
CompositorController
*
aCompositorController
)
{
mCompositorController
=
aCompositorController
;
}
void
AsyncPanZoomController
:
:
SetMetricsSharingController
(
MetricsSharingController
*
aMetricsSharingController
)
{
mMetricsSharingController
=
aMetricsSharingController
;
}
void
AsyncPanZoomController
:
:
SetVisualScrollOffset
(
const
CSSPoint
&
aOffset
)
{
Metrics
(
)
.
SetVisualScrollOffset
(
aOffset
)
;
Metrics
(
)
.
RecalculateLayoutViewportOffset
(
)
;
}
void
AsyncPanZoomController
:
:
ClampAndSetVisualScrollOffset
(
const
CSSPoint
&
aOffset
)
{
Metrics
(
)
.
ClampAndSetVisualScrollOffset
(
aOffset
)
;
Metrics
(
)
.
RecalculateLayoutViewportOffset
(
)
;
}
void
AsyncPanZoomController
:
:
ScrollBy
(
const
CSSPoint
&
aOffset
)
{
SetVisualScrollOffset
(
Metrics
(
)
.
GetVisualScrollOffset
(
)
+
aOffset
)
;
}
void
AsyncPanZoomController
:
:
ScrollByAndClamp
(
const
CSSPoint
&
aOffset
)
{
ClampAndSetVisualScrollOffset
(
Metrics
(
)
.
GetVisualScrollOffset
(
)
+
aOffset
)
;
}
void
AsyncPanZoomController
:
:
ScaleWithFocus
(
float
aScale
const
CSSPoint
&
aFocus
)
{
Metrics
(
)
.
ZoomBy
(
aScale
)
;
SetVisualScrollOffset
(
(
Metrics
(
)
.
GetVisualScrollOffset
(
)
+
aFocus
)
-
(
aFocus
/
aScale
)
)
;
}
gfx
:
:
IntSize
AsyncPanZoomController
:
:
GetDisplayportAlignmentMultiplier
(
const
ScreenSize
&
aBaseSize
)
{
MOZ_ASSERT
(
gfx
:
:
gfxVars
:
:
UseWebRender
(
)
)
;
gfx
:
:
IntSize
multiplier
(
1
1
)
;
float
baseWidth
=
aBaseSize
.
width
;
while
(
baseWidth
>
500
)
{
baseWidth
/
=
2
;
multiplier
.
width
*
=
2
;
if
(
multiplier
.
width
>
=
8
)
{
break
;
}
}
float
baseHeight
=
aBaseSize
.
height
;
while
(
baseHeight
>
500
)
{
baseHeight
/
=
2
;
multiplier
.
height
*
=
2
;
if
(
multiplier
.
height
>
=
8
)
{
break
;
}
}
return
multiplier
;
}
static
CSSSize
CalculateDisplayPortSize
(
const
CSSSize
&
aCompositionSize
const
CSSPoint
&
aVelocity
AsyncPanZoomController
:
:
ZoomInProgress
aZoomInProgress
const
CSSToScreenScale2D
&
aDpPerCSS
)
{
bool
xIsStationarySpeed
=
fabsf
(
aVelocity
.
x
)
<
StaticPrefs
:
:
apz_min_skate_speed
(
)
;
bool
yIsStationarySpeed
=
fabsf
(
aVelocity
.
y
)
<
StaticPrefs
:
:
apz_min_skate_speed
(
)
;
float
xMultiplier
=
xIsStationarySpeed
?
StaticPrefs
:
:
apz_x_stationary_size_multiplier
(
)
:
StaticPrefs
:
:
apz_x_skate_size_multiplier
(
)
;
float
yMultiplier
=
yIsStationarySpeed
?
StaticPrefs
:
:
apz_y_stationary_size_multiplier
(
)
:
StaticPrefs
:
:
apz_y_skate_size_multiplier
(
)
;
if
(
IsHighMemSystem
(
)
&
&
!
xIsStationarySpeed
)
{
xMultiplier
+
=
StaticPrefs
:
:
apz_x_skate_highmem_adjust
(
)
;
}
if
(
IsHighMemSystem
(
)
&
&
!
yIsStationarySpeed
)
{
yMultiplier
+
=
StaticPrefs
:
:
apz_y_skate_highmem_adjust
(
)
;
}
if
(
aZoomInProgress
=
=
AsyncPanZoomController
:
:
ZoomInProgress
:
:
Yes
)
{
float
areaMultiplier
=
xMultiplier
*
yMultiplier
;
xMultiplier
=
sqrt
(
areaMultiplier
)
;
yMultiplier
=
xMultiplier
;
}
if
(
gfx
:
:
gfxVars
:
:
UseWebRender
(
)
)
{
gfx
:
:
IntSize
alignmentMultipler
=
AsyncPanZoomController
:
:
GetDisplayportAlignmentMultiplier
(
aCompositionSize
*
aDpPerCSS
)
;
if
(
xMultiplier
>
1
)
{
xMultiplier
=
(
(
xMultiplier
-
1
)
/
alignmentMultipler
.
width
)
+
1
;
}
if
(
yMultiplier
>
1
)
{
yMultiplier
=
(
(
yMultiplier
-
1
)
/
alignmentMultipler
.
height
)
+
1
;
}
}
return
aCompositionSize
*
CSSSize
(
xMultiplier
yMultiplier
)
;
}
static
CSSSize
ExpandDisplayPortToDangerZone
(
const
CSSSize
&
aDisplayPortSize
const
FrameMetrics
&
aFrameMetrics
)
{
CSSSize
dangerZone
(
0
.
0f
0
.
0f
)
;
if
(
aFrameMetrics
.
LayersPixelsPerCSSPixel
(
)
.
xScale
!
=
0
&
&
aFrameMetrics
.
LayersPixelsPerCSSPixel
(
)
.
yScale
!
=
0
)
{
dangerZone
=
LayerSize
(
StaticPrefs
:
:
apz_danger_zone_x
(
)
StaticPrefs
:
:
apz_danger_zone_y
(
)
)
/
aFrameMetrics
.
LayersPixelsPerCSSPixel
(
)
;
}
const
CSSSize
compositionSize
=
aFrameMetrics
.
CalculateBoundedCompositedSizeInCssPixels
(
)
;
const
float
xSize
=
std
:
:
max
(
aDisplayPortSize
.
width
compositionSize
.
width
+
(
2
*
dangerZone
.
width
)
)
;
const
float
ySize
=
std
:
:
max
(
aDisplayPortSize
.
height
compositionSize
.
height
+
(
2
*
dangerZone
.
height
)
)
;
return
CSSSize
(
xSize
ySize
)
;
}
static
void
RedistributeDisplayPortExcess
(
CSSSize
&
aDisplayPortSize
const
CSSRect
&
aScrollableRect
)
{
if
(
aDisplayPortSize
.
height
>
aScrollableRect
.
Height
(
)
)
{
aDisplayPortSize
.
width
*
=
(
aDisplayPortSize
.
height
/
aScrollableRect
.
Height
(
)
)
;
aDisplayPortSize
.
height
=
aScrollableRect
.
Height
(
)
;
}
else
if
(
aDisplayPortSize
.
width
>
aScrollableRect
.
Width
(
)
)
{
aDisplayPortSize
.
height
*
=
(
aDisplayPortSize
.
width
/
aScrollableRect
.
Width
(
)
)
;
aDisplayPortSize
.
width
=
aScrollableRect
.
Width
(
)
;
}
}
const
ScreenMargin
AsyncPanZoomController
:
:
CalculatePendingDisplayPort
(
const
FrameMetrics
&
aFrameMetrics
const
ParentLayerPoint
&
aVelocity
ZoomInProgress
aZoomInProgress
)
{
if
(
aFrameMetrics
.
IsScrollInfoLayer
(
)
)
{
return
ScreenMargin
(
)
;
}
CSSSize
compositionSize
=
aFrameMetrics
.
CalculateBoundedCompositedSizeInCssPixels
(
)
;
CSSPoint
velocity
;
if
(
aFrameMetrics
.
GetZoom
(
)
!
=
CSSToParentLayerScale2D
(
0
0
)
)
{
velocity
=
aVelocity
/
aFrameMetrics
.
GetZoom
(
)
;
}
CSSRect
scrollableRect
=
aFrameMetrics
.
GetExpandedScrollableRect
(
)
;
CSSSize
displayPortSize
=
CalculateDisplayPortSize
(
compositionSize
velocity
aZoomInProgress
aFrameMetrics
.
DisplayportPixelsPerCSSPixel
(
)
)
;
displayPortSize
=
ExpandDisplayPortToDangerZone
(
displayPortSize
aFrameMetrics
)
;
if
(
StaticPrefs
:
:
apz_enlarge_displayport_when_clipped
(
)
)
{
RedistributeDisplayPortExcess
(
displayPortSize
scrollableRect
)
;
}
CSSRect
displayPort
(
(
compositionSize
.
width
-
displayPortSize
.
width
)
/
2
.
0f
(
compositionSize
.
height
-
displayPortSize
.
height
)
/
2
.
0f
displayPortSize
.
width
displayPortSize
.
height
)
;
float
paintFactor
=
kDefaultEstimatedPaintDurationMs
;
displayPort
.
MoveBy
(
velocity
*
paintFactor
*
StaticPrefs
:
:
apz_velocity_bias
(
)
)
;
APZC_LOGV_FM
(
aFrameMetrics
"
Calculated
displayport
as
%
s
from
velocity
%
s
zooming
%
d
paint
"
"
time
%
f
metrics
"
ToString
(
displayPort
)
.
c_str
(
)
ToString
(
aVelocity
)
.
c_str
(
)
(
int
)
aZoomInProgress
paintFactor
)
;
CSSMargin
cssMargins
;
cssMargins
.
left
=
-
displayPort
.
X
(
)
;
cssMargins
.
top
=
-
displayPort
.
Y
(
)
;
cssMargins
.
right
=
displayPort
.
Width
(
)
-
compositionSize
.
width
-
cssMargins
.
left
;
cssMargins
.
bottom
=
displayPort
.
Height
(
)
-
compositionSize
.
height
-
cssMargins
.
top
;
return
cssMargins
*
aFrameMetrics
.
DisplayportPixelsPerCSSPixel
(
)
;
}
void
AsyncPanZoomController
:
:
ScheduleComposite
(
)
{
if
(
mCompositorController
)
{
mCompositorController
-
>
ScheduleRenderOnCompositorThread
(
)
;
}
}
void
AsyncPanZoomController
:
:
ScheduleCompositeAndMaybeRepaint
(
)
{
ScheduleComposite
(
)
;
RequestContentRepaint
(
)
;
}
void
AsyncPanZoomController
:
:
FlushRepaintForOverscrollHandoff
(
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
RequestContentRepaint
(
)
;
UpdateSharedCompositorFrameMetrics
(
)
;
}
void
AsyncPanZoomController
:
:
FlushRepaintForNewInputBlock
(
)
{
APZC_LOG
(
"
%
p
flushing
repaint
for
new
input
block
\
n
"
this
)
;
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
RequestContentRepaint
(
)
;
UpdateSharedCompositorFrameMetrics
(
)
;
}
bool
AsyncPanZoomController
:
:
SnapBackIfOverscrolled
(
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
IsOverscrolled
(
)
&
&
mState
!
=
OVERSCROLL_ANIMATION
)
{
APZC_LOG
(
"
%
p
is
overscrolled
starting
snap
-
back
\
n
"
this
)
;
StartOverscrollAnimation
(
ParentLayerPoint
(
0
0
)
GetOverscrollSideBits
(
)
)
;
return
true
;
}
if
(
mState
!
=
FLING
)
{
ScrollSnap
(
)
;
}
return
false
;
}
bool
AsyncPanZoomController
:
:
IsFlingingFast
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
mState
=
=
FLING
&
&
GetVelocityVector
(
)
.
Length
(
)
>
StaticPrefs
:
:
apz_fling_stop_on_tap_threshold
(
)
)
{
APZC_LOG
(
"
%
p
is
moving
fast
\
n
"
this
)
;
return
true
;
}
return
false
;
}
bool
AsyncPanZoomController
:
:
IsPannable
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
mX
.
CanScroll
(
)
|
|
mY
.
CanScroll
(
)
;
}
bool
AsyncPanZoomController
:
:
IsScrollInfoLayer
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
Metrics
(
)
.
IsScrollInfoLayer
(
)
;
}
int32_t
AsyncPanZoomController
:
:
GetLastTouchIdentifier
(
)
const
{
RefPtr
<
GestureEventListener
>
listener
=
GetGestureEventListener
(
)
;
return
listener
?
listener
-
>
GetLastTouchIdentifier
(
)
:
-
1
;
}
void
AsyncPanZoomController
:
:
RequestContentRepaint
(
RepaintUpdateType
aUpdateType
)
{
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
;
if
(
!
controller
)
{
return
;
}
if
(
!
controller
-
>
IsRepaintThread
(
)
)
{
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
mExpectedGeckoMetrics
.
UpdateFrom
(
Metrics
(
)
)
;
}
auto
func
=
static_cast
<
void
(
AsyncPanZoomController
:
:
*
)
(
RepaintUpdateType
)
>
(
&
AsyncPanZoomController
:
:
RequestContentRepaint
)
;
controller
-
>
DispatchToRepaintThread
(
NewRunnableMethod
<
RepaintUpdateType
>
(
"
layers
:
:
AsyncPanZoomController
:
:
RequestContentRepaint
"
this
func
aUpdateType
)
)
;
return
;
}
MOZ_ASSERT
(
controller
-
>
IsRepaintThread
(
)
)
;
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
ParentLayerPoint
velocity
=
GetVelocityVector
(
)
;
ScreenMargin
displayportMargins
=
CalculatePendingDisplayPort
(
Metrics
(
)
velocity
(
mState
=
=
PINCHING
|
|
mState
=
=
ANIMATING_ZOOM
)
?
ZoomInProgress
:
:
Yes
:
ZoomInProgress
:
:
No
)
;
Metrics
(
)
.
SetPaintRequestTime
(
TimeStamp
:
:
Now
(
)
)
;
RequestContentRepaint
(
Metrics
(
)
velocity
displayportMargins
aUpdateType
)
;
}
static
CSSRect
GetDisplayPortRect
(
const
FrameMetrics
&
aFrameMetrics
const
ScreenMargin
&
aDisplayportMargins
)
{
CSSRect
baseRect
(
aFrameMetrics
.
GetVisualScrollOffset
(
)
aFrameMetrics
.
CalculateBoundedCompositedSizeInCssPixels
(
)
)
;
baseRect
.
Inflate
(
aDisplayportMargins
/
aFrameMetrics
.
DisplayportPixelsPerCSSPixel
(
)
)
;
return
baseRect
;
}
void
AsyncPanZoomController
:
:
RequestContentRepaint
(
const
FrameMetrics
&
aFrameMetrics
const
ParentLayerPoint
&
aVelocity
const
ScreenMargin
&
aDisplayportMargins
RepaintUpdateType
aUpdateType
)
{
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
;
if
(
!
controller
)
{
return
;
}
MOZ_ASSERT
(
controller
-
>
IsRepaintThread
(
)
)
;
const
bool
isAnimationInProgress
=
!
!
mAnimation
;
RepaintRequest
request
(
aFrameMetrics
aDisplayportMargins
aUpdateType
isAnimationInProgress
)
;
if
(
request
.
GetDisplayPortMargins
(
)
.
WithinEpsilonOf
(
mLastPaintRequestMetrics
.
GetDisplayPortMargins
(
)
EPSILON
)
&
&
request
.
GetVisualScrollOffset
(
)
.
WithinEpsilonOf
(
mLastPaintRequestMetrics
.
GetVisualScrollOffset
(
)
EPSILON
)
&
&
request
.
GetPresShellResolution
(
)
=
=
mLastPaintRequestMetrics
.
GetPresShellResolution
(
)
&
&
request
.
GetZoom
(
)
=
=
mLastPaintRequestMetrics
.
GetZoom
(
)
&
&
request
.
GetLayoutViewport
(
)
.
WithinEpsilonOf
(
mLastPaintRequestMetrics
.
GetLayoutViewport
(
)
EPSILON
)
&
&
request
.
GetScrollGeneration
(
)
=
=
mLastPaintRequestMetrics
.
GetScrollGeneration
(
)
&
&
request
.
GetScrollUpdateType
(
)
=
=
mLastPaintRequestMetrics
.
GetScrollUpdateType
(
)
&
&
request
.
IsAnimationInProgress
(
)
=
=
mLastPaintRequestMetrics
.
IsAnimationInProgress
(
)
)
{
return
;
}
APZC_LOGV
(
"
%
p
requesting
content
repaint
%
s
"
this
ToString
(
request
)
.
c_str
(
)
)
;
{
MutexAutoLock
lock
(
mCheckerboardEventLock
)
;
if
(
mCheckerboardEvent
&
&
mCheckerboardEvent
-
>
IsRecordingTrace
(
)
)
{
std
:
:
stringstream
info
;
info
<
<
"
velocity
"
<
<
aVelocity
;
std
:
:
string
str
=
info
.
str
(
)
;
mCheckerboardEvent
-
>
UpdateRendertraceProperty
(
CheckerboardEvent
:
:
RequestedDisplayPort
GetDisplayPortRect
(
aFrameMetrics
aDisplayportMargins
)
str
)
;
}
}
controller
-
>
RequestContentRepaint
(
request
)
;
mExpectedGeckoMetrics
.
UpdateFrom
(
aFrameMetrics
)
;
mLastPaintRequestMetrics
=
request
;
controller
-
>
DispatchToRepaintThread
(
NewRunnableMethod
<
AsyncPanZoomController
*
>
(
"
layers
:
:
APZCTreeManager
:
:
SendSubtreeTransformsToChromeMainThread
"
GetApzcTreeManager
(
)
&
APZCTreeManager
:
:
SendSubtreeTransformsToChromeMainThread
this
)
)
;
}
bool
AsyncPanZoomController
:
:
UpdateAnimation
(
const
RecursiveMutexAutoLock
&
aProofOfLock
const
SampleTime
&
aSampleTime
nsTArray
<
RefPtr
<
Runnable
>
>
*
aOutDeferredTasks
)
{
AssertOnSamplerThread
(
)
;
if
(
mLastSampleTime
=
=
aSampleTime
)
{
return
!
!
mAnimation
;
}
AdvanceToNextSample
(
)
;
bool
needComposite
=
SampleCompositedAsyncTransform
(
aProofOfLock
)
;
TimeDuration
sampleTimeDelta
=
aSampleTime
-
mLastSampleTime
;
mLastSampleTime
=
aSampleTime
;
if
(
mAnimation
)
{
bool
continueAnimation
=
mAnimation
-
>
Sample
(
Metrics
(
)
sampleTimeDelta
)
;
bool
wantsRepaints
=
mAnimation
-
>
WantsRepaints
(
)
;
*
aOutDeferredTasks
=
mAnimation
-
>
TakeDeferredTasks
(
)
;
if
(
!
continueAnimation
)
{
SetState
(
NOTHING
)
;
mAnimation
=
nullptr
;
}
if
(
!
continueAnimation
|
|
wantsRepaints
)
{
RequestContentRepaint
(
)
;
}
UpdateSharedCompositorFrameMetrics
(
)
;
needComposite
=
true
;
}
return
needComposite
;
}
AsyncTransformComponentMatrix
AsyncPanZoomController
:
:
GetOverscrollTransform
(
AsyncTransformConsumer
aMode
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
AutoApplyAsyncTestAttributes
testAttributeApplier
(
this
lock
)
;
if
(
aMode
=
=
eForCompositing
&
&
mScrollMetadata
.
IsApzForceDisabled
(
)
)
{
return
AsyncTransformComponentMatrix
(
)
;
}
if
(
!
IsOverscrolled
(
)
)
{
return
AsyncTransformComponentMatrix
(
)
;
}
ParentLayerPoint
overscrollOffset
(
-
mX
.
GetOverscroll
(
)
-
mY
.
GetOverscroll
(
)
)
;
return
AsyncTransformComponentMatrix
(
)
.
PostTranslate
(
overscrollOffset
.
x
overscrollOffset
.
y
0
)
;
}
bool
AsyncPanZoomController
:
:
AdvanceAnimations
(
const
SampleTime
&
aSampleTime
)
{
AssertOnSamplerThread
(
)
;
StateChangeNotificationBlocker
blocker
(
this
)
;
mAsyncTransformAppliedToContent
=
false
;
bool
requestAnimationFrame
=
false
;
nsTArray
<
RefPtr
<
Runnable
>
>
deferredTasks
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
{
CSSRect
visibleRect
=
GetVisibleRect
(
lock
)
;
MutexAutoLock
lock2
(
mCheckerboardEventLock
)
;
if
(
mCheckerboardEvent
)
{
mCheckerboardEvent
-
>
UpdateRendertraceProperty
(
CheckerboardEvent
:
:
UserVisible
visibleRect
)
;
}
}
requestAnimationFrame
=
UpdateAnimation
(
lock
aSampleTime
&
deferredTasks
)
;
}
for
(
uint32_t
i
=
0
;
i
<
deferredTasks
.
Length
(
)
;
+
+
i
)
{
APZThreadUtils
:
:
RunOnControllerThread
(
std
:
:
move
(
deferredTasks
[
i
]
)
)
;
}
return
requestAnimationFrame
;
}
CSSRect
AsyncPanZoomController
:
:
GetCurrentAsyncLayoutViewport
(
AsyncTransformConsumer
aMode
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
AutoApplyAsyncTestAttributes
testAttributeApplier
(
this
lock
)
;
MOZ_ASSERT
(
Metrics
(
)
.
IsRootContent
(
)
"
Only
the
root
content
APZC
has
a
layout
viewport
"
)
;
return
GetEffectiveLayoutViewport
(
aMode
lock
)
;
}
ParentLayerPoint
AsyncPanZoomController
:
:
GetCurrentAsyncScrollOffset
(
AsyncTransformConsumer
aMode
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
AutoApplyAsyncTestAttributes
testAttributeApplier
(
this
lock
)
;
return
GetEffectiveScrollOffset
(
aMode
lock
)
*
GetEffectiveZoom
(
aMode
lock
)
;
}
CSSPoint
AsyncPanZoomController
:
:
GetCurrentAsyncScrollOffsetInCssPixels
(
AsyncTransformConsumer
aMode
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
AutoApplyAsyncTestAttributes
testAttributeApplier
(
this
lock
)
;
return
GetEffectiveScrollOffset
(
aMode
lock
)
;
}
AsyncTransform
AsyncPanZoomController
:
:
GetCurrentAsyncTransform
(
AsyncTransformConsumer
aMode
AsyncTransformComponents
aComponents
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
AutoApplyAsyncTestAttributes
testAttributeApplier
(
this
lock
)
;
CSSToParentLayerScale2D
effectiveZoom
;
if
(
aComponents
.
contains
(
AsyncTransformComponent
:
:
eVisual
)
)
{
effectiveZoom
=
GetEffectiveZoom
(
aMode
lock
)
;
}
else
{
effectiveZoom
=
Metrics
(
)
.
LayersPixelsPerCSSPixel
(
)
*
LayerToParentLayerScale
(
1
.
0f
)
;
}
LayerToParentLayerScale
compositedAsyncZoom
=
(
effectiveZoom
/
Metrics
(
)
.
LayersPixelsPerCSSPixel
(
)
)
.
ToScaleFactor
(
)
;
ParentLayerPoint
translation
;
if
(
aComponents
.
contains
(
AsyncTransformComponent
:
:
eVisual
)
)
{
CSSPoint
currentVisualOffset
=
GetEffectiveScrollOffset
(
aMode
lock
)
-
GetEffectiveLayoutViewport
(
aMode
lock
)
.
TopLeft
(
)
;
translation
+
=
currentVisualOffset
*
effectiveZoom
;
}
if
(
aComponents
.
contains
(
AsyncTransformComponent
:
:
eLayout
)
)
{
CSSPoint
lastPaintLayoutOffset
;
if
(
mLastContentPaintMetrics
.
IsScrollable
(
)
)
{
lastPaintLayoutOffset
=
mLastContentPaintMetrics
.
GetLayoutScrollOffset
(
)
;
}
CSSPoint
currentLayoutOffset
=
GetEffectiveLayoutViewport
(
aMode
lock
)
.
TopLeft
(
)
;
translation
+
=
(
currentLayoutOffset
-
lastPaintLayoutOffset
)
*
effectiveZoom
;
}
return
AsyncTransform
(
compositedAsyncZoom
-
translation
)
;
}
AsyncTransformComponentMatrix
AsyncPanZoomController
:
:
GetCurrentAsyncTransformWithOverscroll
(
AsyncTransformConsumer
aMode
AsyncTransformComponents
aComponents
)
const
{
AsyncTransformComponentMatrix
asyncTransform
=
GetCurrentAsyncTransform
(
aMode
aComponents
)
;
if
(
aComponents
.
contains
(
AsyncTransformComponent
:
:
eVisual
)
)
{
return
asyncTransform
*
GetOverscrollTransform
(
aMode
)
;
}
return
asyncTransform
;
}
LayoutDeviceToParentLayerScale
AsyncPanZoomController
:
:
GetCurrentPinchZoomScale
(
AsyncTransformConsumer
aMode
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
AutoApplyAsyncTestAttributes
testAttributeApplier
(
this
lock
)
;
CSSToParentLayerScale2D
scale
=
GetEffectiveZoom
(
aMode
lock
)
;
return
scale
.
ToScaleFactor
(
)
/
Metrics
(
)
.
GetDevPixelsPerCSSPixel
(
)
;
}
bool
AsyncPanZoomController
:
:
SuppressAsyncScrollOffset
(
)
const
{
return
mScrollMetadata
.
IsApzForceDisabled
(
)
|
|
(
Metrics
(
)
.
IsMinimalDisplayPort
(
)
&
&
StaticPrefs
:
:
apz_prefer_jank_minimal_displayports
(
)
)
;
}
CSSRect
AsyncPanZoomController
:
:
GetEffectiveLayoutViewport
(
AsyncTransformConsumer
aMode
const
RecursiveMutexAutoLock
&
aProofOfLock
)
const
{
if
(
aMode
=
=
eForCompositing
&
&
SuppressAsyncScrollOffset
(
)
)
{
return
mLastContentPaintMetrics
.
GetLayoutViewport
(
)
;
}
if
(
aMode
=
=
eForCompositing
)
{
return
mSampledState
.
front
(
)
.
GetLayoutViewport
(
)
;
}
return
Metrics
(
)
.
GetLayoutViewport
(
)
;
}
CSSPoint
AsyncPanZoomController
:
:
GetEffectiveScrollOffset
(
AsyncTransformConsumer
aMode
const
RecursiveMutexAutoLock
&
aProofOfLock
)
const
{
if
(
aMode
=
=
eForCompositing
&
&
SuppressAsyncScrollOffset
(
)
)
{
return
mLastContentPaintMetrics
.
GetVisualScrollOffset
(
)
;
}
if
(
aMode
=
=
eForCompositing
)
{
return
mSampledState
.
front
(
)
.
GetVisualScrollOffset
(
)
;
}
return
Metrics
(
)
.
GetVisualScrollOffset
(
)
;
}
CSSToParentLayerScale2D
AsyncPanZoomController
:
:
GetEffectiveZoom
(
AsyncTransformConsumer
aMode
const
RecursiveMutexAutoLock
&
aProofOfLock
)
const
{
if
(
aMode
=
=
eForCompositing
&
&
SuppressAsyncScrollOffset
(
)
)
{
return
mLastContentPaintMetrics
.
GetZoom
(
)
;
}
if
(
aMode
=
=
eForCompositing
)
{
return
mSampledState
.
front
(
)
.
GetZoom
(
)
;
}
return
Metrics
(
)
.
GetZoom
(
)
;
}
void
AsyncPanZoomController
:
:
AdvanceToNextSample
(
)
{
AssertOnSamplerThread
(
)
;
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
mSampledState
.
size
(
)
>
1
)
{
mSampledState
.
pop_front
(
)
;
}
}
bool
AsyncPanZoomController
:
:
SampleCompositedAsyncTransform
(
const
RecursiveMutexAutoLock
&
aProofOfLock
)
{
MOZ_ASSERT
(
mSampledState
.
size
(
)
<
=
2
)
;
bool
sampleChanged
=
(
mSampledState
.
back
(
)
!
=
SampledAPZCState
(
Metrics
(
)
)
)
;
mSampledState
.
emplace_back
(
Metrics
(
)
std
:
:
move
(
mScrollPayload
)
)
;
return
sampleChanged
;
}
void
AsyncPanZoomController
:
:
ResampleCompositedAsyncTransform
(
const
RecursiveMutexAutoLock
&
aProofOfLock
)
{
mSampledState
.
front
(
)
=
SampledAPZCState
(
Metrics
(
)
)
;
}
void
AsyncPanZoomController
:
:
ApplyAsyncTestAttributes
(
const
RecursiveMutexAutoLock
&
aProofOfLock
)
{
if
(
mTestAttributeAppliers
=
=
0
)
{
if
(
mTestAsyncScrollOffset
!
=
CSSPoint
(
)
|
|
mTestAsyncZoom
!
=
LayerToParentLayerScale
(
)
)
{
Metrics
(
)
.
ZoomBy
(
mTestAsyncZoom
.
scale
)
;
CSSPoint
asyncScrollPosition
=
Metrics
(
)
.
GetVisualScrollOffset
(
)
;
CSSPoint
requestedPoint
=
asyncScrollPosition
+
this
-
>
mTestAsyncScrollOffset
;
CSSPoint
clampedPoint
=
Metrics
(
)
.
CalculateScrollRange
(
)
.
ClampPoint
(
requestedPoint
)
;
CSSPoint
difference
=
mTestAsyncScrollOffset
-
clampedPoint
;
ScrollByAndClamp
(
mTestAsyncScrollOffset
)
;
if
(
StaticPrefs
:
:
apz_overscroll_test_async_scroll_offset_enabled
(
)
)
{
ParentLayerPoint
overscroll
=
difference
*
Metrics
(
)
.
GetZoom
(
)
;
OverscrollBy
(
overscroll
)
;
}
ResampleCompositedAsyncTransform
(
aProofOfLock
)
;
}
}
+
+
mTestAttributeAppliers
;
}
void
AsyncPanZoomController
:
:
UnapplyAsyncTestAttributes
(
const
RecursiveMutexAutoLock
&
aProofOfLock
const
FrameMetrics
&
aPrevFrameMetrics
const
ParentLayerPoint
&
aPrevOverscroll
)
{
MOZ_ASSERT
(
mTestAttributeAppliers
>
=
1
)
;
-
-
mTestAttributeAppliers
;
if
(
mTestAttributeAppliers
=
=
0
)
{
if
(
mTestAsyncScrollOffset
!
=
CSSPoint
(
)
|
|
mTestAsyncZoom
!
=
LayerToParentLayerScale
(
)
)
{
Metrics
(
)
=
aPrevFrameMetrics
;
RestoreOverscrollAmount
(
aPrevOverscroll
)
;
ResampleCompositedAsyncTransform
(
aProofOfLock
)
;
}
}
}
Matrix4x4
AsyncPanZoomController
:
:
GetTransformToLastDispatchedPaint
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
LayerPoint
scrollChange
=
(
mLastContentPaintMetrics
.
GetLayoutScrollOffset
(
)
-
mExpectedGeckoMetrics
.
GetVisualScrollOffset
(
)
)
*
mLastContentPaintMetrics
.
GetDevPixelsPerCSSPixel
(
)
*
mLastContentPaintMetrics
.
GetCumulativeResolution
(
)
;
LayoutDeviceToParentLayerScale2D
lastContentZoom
=
mLastContentPaintMetrics
.
GetZoom
(
)
/
mLastContentPaintMetrics
.
GetDevPixelsPerCSSPixel
(
)
;
LayoutDeviceToParentLayerScale2D
lastDispatchedZoom
=
mExpectedGeckoMetrics
.
GetZoom
(
)
/
mExpectedGeckoMetrics
.
GetDevPixelsPerCSSPixel
(
)
;
gfxSize
zoomChange
(
1
.
0
1
.
0
)
;
if
(
lastDispatchedZoom
!
=
LayoutDeviceToParentLayerScale2D
(
0
0
)
)
{
zoomChange
=
lastContentZoom
/
lastDispatchedZoom
;
}
return
Matrix4x4
:
:
Translation
(
scrollChange
.
x
scrollChange
.
y
0
)
.
PostScale
(
zoomChange
.
width
zoomChange
.
height
1
)
;
}
CSSRect
AsyncPanZoomController
:
:
GetVisibleRect
(
const
RecursiveMutexAutoLock
&
aProofOfLock
)
const
{
AutoApplyAsyncTestAttributes
testAttributeApplier
(
this
aProofOfLock
)
;
CSSPoint
currentScrollOffset
=
GetEffectiveScrollOffset
(
AsyncPanZoomController
:
:
eForCompositing
aProofOfLock
)
;
CSSRect
visible
=
CSSRect
(
currentScrollOffset
Metrics
(
)
.
CalculateCompositedSizeInCssPixels
(
)
)
;
return
visible
;
}
uint32_t
AsyncPanZoomController
:
:
GetCheckerboardMagnitude
(
const
ParentLayerRect
&
aClippedCompositionBounds
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
CSSRect
painted
=
mLastContentPaintMetrics
.
GetDisplayPort
(
)
+
mLastContentPaintMetrics
.
GetLayoutScrollOffset
(
)
;
painted
.
Inflate
(
CSSMargin
:
:
FromAppUnits
(
nsMargin
(
1
1
1
1
)
)
)
;
CSSRect
visible
=
GetVisibleRect
(
lock
)
;
if
(
visible
.
IsEmpty
(
)
|
|
painted
.
Contains
(
visible
)
)
{
return
0
;
}
ParentLayerRect
visiblePartOfCompBoundsRelativeToItself
=
aClippedCompositionBounds
-
Metrics
(
)
.
GetCompositionBounds
(
)
.
TopLeft
(
)
;
CSSRect
visiblePartOfCompBoundsRelativeToItselfInCssSpace
;
if
(
Metrics
(
)
.
GetZoom
(
)
!
=
CSSToParentLayerScale2D
(
0
0
)
)
{
visiblePartOfCompBoundsRelativeToItselfInCssSpace
=
(
visiblePartOfCompBoundsRelativeToItself
/
Metrics
(
)
.
GetZoom
(
)
)
;
}
CSSRect
visiblePartOfCompBoundsInCssSpace
=
visiblePartOfCompBoundsRelativeToItselfInCssSpace
+
visible
.
TopLeft
(
)
;
visible
=
visible
.
Intersect
(
visiblePartOfCompBoundsInCssSpace
)
;
CSSIntRegion
checkerboard
;
checkerboard
.
Sub
(
RoundedIn
(
visible
)
RoundedOut
(
painted
)
)
;
uint32_t
area
=
checkerboard
.
Area
(
)
;
if
(
area
)
{
APZC_LOG_FM
(
Metrics
(
)
"
%
p
is
currently
checkerboarding
(
painted
%
s
visible
%
s
)
"
this
ToString
(
painted
)
.
c_str
(
)
ToString
(
visible
)
.
c_str
(
)
)
;
}
return
area
;
}
void
AsyncPanZoomController
:
:
ReportCheckerboard
(
const
SampleTime
&
aSampleTime
const
ParentLayerRect
&
aClippedCompositionBounds
)
{
if
(
mLastCheckerboardReport
=
=
aSampleTime
)
{
return
;
}
mLastCheckerboardReport
=
aSampleTime
;
bool
recordTrace
=
StaticPrefs
:
:
apz_record_checkerboarding
(
)
;
bool
forTelemetry
=
Telemetry
:
:
CanRecordExtended
(
)
;
uint32_t
magnitude
=
GetCheckerboardMagnitude
(
aClippedCompositionBounds
)
;
bool
inTransformingState
=
IsInTransformingState
(
)
;
MutexAutoLock
lock
(
mCheckerboardEventLock
)
;
if
(
!
mCheckerboardEvent
&
&
(
recordTrace
|
|
forTelemetry
)
)
{
mCheckerboardEvent
=
MakeUnique
<
CheckerboardEvent
>
(
recordTrace
)
;
}
mPotentialCheckerboardTracker
.
InTransform
(
inTransformingState
)
;
if
(
magnitude
)
{
mPotentialCheckerboardTracker
.
CheckerboardSeen
(
)
;
}
UpdateCheckerboardEvent
(
lock
magnitude
)
;
}
void
AsyncPanZoomController
:
:
UpdateCheckerboardEvent
(
const
MutexAutoLock
&
aProofOfLock
uint32_t
aMagnitude
)
{
if
(
mCheckerboardEvent
&
&
mCheckerboardEvent
-
>
RecordFrameInfo
(
aMagnitude
)
)
{
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
CHECKERBOARD_SEVERITY
mCheckerboardEvent
-
>
GetSeverity
(
)
)
;
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
CHECKERBOARD_PEAK
mCheckerboardEvent
-
>
GetPeak
(
)
)
;
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
CHECKERBOARD_DURATION
(
uint32_t
)
mCheckerboardEvent
-
>
GetDuration
(
)
.
ToMilliseconds
(
)
)
;
mPotentialCheckerboardTracker
.
CheckerboardDone
(
)
;
if
(
StaticPrefs
:
:
apz_record_checkerboarding
(
)
)
{
uint32_t
severity
=
mCheckerboardEvent
-
>
GetSeverity
(
)
;
std
:
:
string
log
=
mCheckerboardEvent
-
>
GetLog
(
)
;
CheckerboardEventStorage
:
:
Report
(
severity
log
)
;
}
mCheckerboardEvent
=
nullptr
;
}
}
void
AsyncPanZoomController
:
:
FlushActiveCheckerboardReport
(
)
{
MutexAutoLock
lock
(
mCheckerboardEventLock
)
;
UpdateCheckerboardEvent
(
lock
0
)
;
}
void
AsyncPanZoomController
:
:
NotifyLayersUpdated
(
const
ScrollMetadata
&
aScrollMetadata
bool
aIsFirstPaint
bool
aThisLayerTreeUpdated
)
{
AssertOnUpdaterThread
(
)
;
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
bool
isDefault
=
mScrollMetadata
.
IsDefault
(
)
;
const
FrameMetrics
&
aLayerMetrics
=
aScrollMetadata
.
GetMetrics
(
)
;
if
(
(
aScrollMetadata
=
=
mLastContentPaintMetadata
)
&
&
!
isDefault
)
{
APZC_LOGV
(
"
%
p
NotifyLayersUpdated
short
-
circuit
\
n
"
this
)
;
return
;
}
CSSPoint
lastScrollOffset
=
mLastContentPaintMetrics
.
GetLayoutScrollOffset
(
)
;
bool
userScrolled
=
!
FuzzyEqualsAdditive
(
Metrics
(
)
.
GetVisualScrollOffset
(
)
.
x
lastScrollOffset
.
x
)
|
|
!
FuzzyEqualsAdditive
(
Metrics
(
)
.
GetVisualScrollOffset
(
)
.
y
lastScrollOffset
.
y
)
;
if
(
aScrollMetadata
.
DidContentGetPainted
(
)
)
{
mLastContentPaintMetadata
=
aScrollMetadata
;
}
mScrollMetadata
.
SetScrollParentId
(
aScrollMetadata
.
GetScrollParentId
(
)
)
;
APZC_LOGV_FM
(
aLayerMetrics
"
%
p
got
a
NotifyLayersUpdated
with
aIsFirstPaint
=
%
d
"
"
aThisLayerTreeUpdated
=
%
d
"
this
aIsFirstPaint
aThisLayerTreeUpdated
)
;
{
MutexAutoLock
lock
(
mCheckerboardEventLock
)
;
if
(
mCheckerboardEvent
&
&
mCheckerboardEvent
-
>
IsRecordingTrace
(
)
)
{
std
:
:
string
str
;
if
(
aThisLayerTreeUpdated
)
{
if
(
!
aLayerMetrics
.
GetPaintRequestTime
(
)
.
IsNull
(
)
)
{
TimeDuration
paintTime
=
TimeStamp
:
:
Now
(
)
-
aLayerMetrics
.
GetPaintRequestTime
(
)
;
std
:
:
stringstream
info
;
info
<
<
"
painttime
"
<
<
paintTime
.
ToMilliseconds
(
)
;
str
=
info
.
str
(
)
;
}
else
{
str
=
"
(
this
layertree
updated
)
"
;
}
}
mCheckerboardEvent
-
>
UpdateRendertraceProperty
(
CheckerboardEvent
:
:
Page
aLayerMetrics
.
GetScrollableRect
(
)
)
;
mCheckerboardEvent
-
>
UpdateRendertraceProperty
(
CheckerboardEvent
:
:
PaintedDisplayPort
aLayerMetrics
.
GetDisplayPort
(
)
+
aLayerMetrics
.
GetLayoutScrollOffset
(
)
str
)
;
if
(
!
aLayerMetrics
.
GetCriticalDisplayPort
(
)
.
IsEmpty
(
)
)
{
mCheckerboardEvent
-
>
UpdateRendertraceProperty
(
CheckerboardEvent
:
:
PaintedCriticalDisplayPort
aLayerMetrics
.
GetCriticalDisplayPort
(
)
+
aLayerMetrics
.
GetLayoutScrollOffset
(
)
)
;
}
}
}
bool
ignoreVisualUpdate
=
false
;
bool
needContentRepaint
=
false
;
RepaintUpdateType
contentRepaintType
=
RepaintUpdateType
:
:
eNone
;
bool
viewportSizeUpdated
=
false
;
bool
needToReclampScroll
=
false
;
if
(
(
aIsFirstPaint
&
&
aThisLayerTreeUpdated
)
|
|
isDefault
)
{
CancelAnimation
(
)
;
ScrollGeneration
oldScrollGeneration
=
Metrics
(
)
.
GetScrollGeneration
(
)
;
mScrollMetadata
=
aScrollMetadata
;
if
(
!
aScrollMetadata
.
GetScrollUpdates
(
)
.
IsEmpty
(
)
)
{
Metrics
(
)
.
SetScrollGeneration
(
oldScrollGeneration
)
;
}
mExpectedGeckoMetrics
.
UpdateFrom
(
aLayerMetrics
)
;
ShareCompositorFrameMetrics
(
)
;
for
(
auto
&
sampledState
:
mSampledState
)
{
sampledState
.
UpdateScrollProperties
(
Metrics
(
)
)
;
sampledState
.
UpdateZoomProperties
(
Metrics
(
)
)
;
}
if
(
aLayerMetrics
.
HasNonZeroDisplayPortMargins
(
)
)
{
APZC_LOG
(
"
%
p
detected
non
-
empty
margins
which
probably
need
updating
\
n
"
this
)
;
needContentRepaint
=
true
;
}
}
else
{
if
(
Metrics
(
)
.
GetLayoutViewport
(
)
.
Size
(
)
!
=
aLayerMetrics
.
GetLayoutViewport
(
)
.
Size
(
)
)
{
CSSRect
layoutViewport
=
Metrics
(
)
.
GetLayoutViewport
(
)
;
layoutViewport
.
SizeTo
(
aLayerMetrics
.
GetLayoutViewport
(
)
.
Size
(
)
)
;
Metrics
(
)
.
SetLayoutViewport
(
layoutViewport
)
;
needContentRepaint
=
true
;
viewportSizeUpdated
=
true
;
}
if
(
FuzzyEqualsAdditive
(
Metrics
(
)
.
GetCompositionBoundsWidthIgnoringScrollbars
(
)
.
value
aLayerMetrics
.
GetCompositionBoundsWidthIgnoringScrollbars
(
)
.
value
)
&
&
Metrics
(
)
.
GetDevPixelsPerCSSPixel
(
)
=
=
aLayerMetrics
.
GetDevPixelsPerCSSPixel
(
)
&
&
!
viewportSizeUpdated
&
&
!
aScrollMetadata
.
IsResolutionUpdated
(
)
)
{
gfxSize
totalResolutionChange
(
1
.
0
1
.
0
)
;
if
(
Metrics
(
)
.
GetCumulativeResolution
(
)
!
=
LayoutDeviceToLayerScale2D
(
0
0
)
)
{
totalResolutionChange
=
aLayerMetrics
.
GetCumulativeResolution
(
)
/
Metrics
(
)
.
GetCumulativeResolution
(
)
;
}
float
presShellResolutionChange
=
aLayerMetrics
.
GetPresShellResolution
(
)
/
Metrics
(
)
.
GetPresShellResolution
(
)
;
if
(
presShellResolutionChange
!
=
1
.
0f
)
{
needContentRepaint
=
true
;
}
Metrics
(
)
.
ZoomBy
(
totalResolutionChange
/
presShellResolutionChange
)
;
for
(
auto
&
sampledState
:
mSampledState
)
{
sampledState
.
ZoomBy
(
totalResolutionChange
/
presShellResolutionChange
)
;
}
}
else
{
Metrics
(
)
.
SetZoom
(
aLayerMetrics
.
GetZoom
(
)
)
;
for
(
auto
&
sampledState
:
mSampledState
)
{
sampledState
.
UpdateZoomProperties
(
aLayerMetrics
)
;
}
Metrics
(
)
.
SetDevPixelsPerCSSPixel
(
aLayerMetrics
.
GetDevPixelsPerCSSPixel
(
)
)
;
}
if
(
!
Metrics
(
)
.
GetScrollableRect
(
)
.
IsEqualEdges
(
aLayerMetrics
.
GetScrollableRect
(
)
)
)
{
Metrics
(
)
.
SetScrollableRect
(
aLayerMetrics
.
GetScrollableRect
(
)
)
;
needContentRepaint
=
true
;
needToReclampScroll
=
true
;
}
if
(
!
Metrics
(
)
.
GetCompositionBounds
(
)
.
IsEqualEdges
(
aLayerMetrics
.
GetCompositionBounds
(
)
)
)
{
Metrics
(
)
.
SetCompositionBounds
(
aLayerMetrics
.
GetCompositionBounds
(
)
)
;
needToReclampScroll
=
true
;
}
Metrics
(
)
.
SetCompositionBoundsWidthIgnoringScrollbars
(
aLayerMetrics
.
GetCompositionBoundsWidthIgnoringScrollbars
(
)
)
;
if
(
Metrics
(
)
.
IsRootContent
(
)
&
&
Metrics
(
)
.
GetCompositionSizeWithoutDynamicToolbar
(
)
!
=
aLayerMetrics
.
GetCompositionSizeWithoutDynamicToolbar
(
)
)
{
Metrics
(
)
.
SetCompositionSizeWithoutDynamicToolbar
(
aLayerMetrics
.
GetCompositionSizeWithoutDynamicToolbar
(
)
)
;
needToReclampScroll
=
true
;
}
Metrics
(
)
.
SetBoundingCompositionSize
(
aLayerMetrics
.
GetBoundingCompositionSize
(
)
)
;
Metrics
(
)
.
SetPresShellResolution
(
aLayerMetrics
.
GetPresShellResolution
(
)
)
;
Metrics
(
)
.
SetCumulativeResolution
(
aLayerMetrics
.
GetCumulativeResolution
(
)
)
;
mScrollMetadata
.
SetHasScrollgrab
(
aScrollMetadata
.
GetHasScrollgrab
(
)
)
;
mScrollMetadata
.
SetLineScrollAmount
(
aScrollMetadata
.
GetLineScrollAmount
(
)
)
;
mScrollMetadata
.
SetPageScrollAmount
(
aScrollMetadata
.
GetPageScrollAmount
(
)
)
;
mScrollMetadata
.
SetSnapInfo
(
ScrollSnapInfo
(
aScrollMetadata
.
GetSnapInfo
(
)
)
)
;
mScrollMetadata
.
SetScrollClip
(
Nothing
(
)
)
;
mScrollMetadata
.
SetIsLayersIdRoot
(
aScrollMetadata
.
IsLayersIdRoot
(
)
)
;
mScrollMetadata
.
SetIsAutoDirRootContentRTL
(
aScrollMetadata
.
IsAutoDirRootContentRTL
(
)
)
;
Metrics
(
)
.
SetIsScrollInfoLayer
(
aLayerMetrics
.
IsScrollInfoLayer
(
)
)
;
Metrics
(
)
.
SetHasNonZeroDisplayPortMargins
(
aLayerMetrics
.
HasNonZeroDisplayPortMargins
(
)
)
;
Metrics
(
)
.
SetMinimalDisplayPort
(
aLayerMetrics
.
IsMinimalDisplayPort
(
)
)
;
mScrollMetadata
.
SetForceDisableApz
(
aScrollMetadata
.
IsApzForceDisabled
(
)
)
;
mScrollMetadata
.
SetIsRDMTouchSimulationActive
(
aScrollMetadata
.
GetIsRDMTouchSimulationActive
(
)
)
;
mScrollMetadata
.
SetPrefersReducedMotion
(
aScrollMetadata
.
PrefersReducedMotion
(
)
)
;
mScrollMetadata
.
SetDisregardedDirection
(
aScrollMetadata
.
GetDisregardedDirection
(
)
)
;
mScrollMetadata
.
SetOverscrollBehavior
(
aScrollMetadata
.
GetOverscrollBehavior
(
)
)
;
}
bool
scrollOffsetUpdated
=
false
;
bool
smoothScrollRequested
=
false
;
for
(
const
auto
&
scrollUpdate
:
aScrollMetadata
.
GetScrollUpdates
(
)
)
{
APZC_LOG
(
"
%
p
processing
scroll
update
%
s
\
n
"
this
ToString
(
scrollUpdate
)
.
c_str
(
)
)
;
if
(
!
(
Metrics
(
)
.
GetScrollGeneration
(
)
<
scrollUpdate
.
GetGeneration
(
)
)
)
{
APZC_LOG
(
"
%
p
scrollupdate
generation
stale
dropping
\
n
"
this
)
;
continue
;
}
Metrics
(
)
.
SetScrollGeneration
(
scrollUpdate
.
GetGeneration
(
)
)
;
MOZ_ASSERT
(
scrollUpdate
.
GetOrigin
(
)
!
=
ScrollOrigin
:
:
Apz
)
;
if
(
userScrolled
&
&
!
nsLayoutUtils
:
:
CanScrollOriginClobberApz
(
scrollUpdate
.
GetOrigin
(
)
)
)
{
APZC_LOG
(
"
%
p
scrollupdate
cannot
clobber
APZ
userScrolled
\
n
"
this
)
;
continue
;
}
if
(
scrollUpdate
.
GetMode
(
)
=
=
ScrollMode
:
:
Smooth
|
|
scrollUpdate
.
GetMode
(
)
=
=
ScrollMode
:
:
SmoothMsd
)
{
smoothScrollRequested
=
true
;
ignoreVisualUpdate
=
true
;
CSSPoint
base
=
GetCurrentAnimationDestination
(
lock
)
.
valueOr
(
Metrics
(
)
.
GetVisualScrollOffset
(
)
)
;
CSSPoint
destination
;
if
(
scrollUpdate
.
GetType
(
)
=
=
ScrollUpdateType
:
:
Relative
)
{
CSSPoint
delta
=
scrollUpdate
.
GetDestination
(
)
-
scrollUpdate
.
GetSource
(
)
;
APZC_LOG
(
"
%
p
relative
smooth
scrolling
from
%
s
by
%
s
\
n
"
this
ToString
(
base
)
.
c_str
(
)
ToString
(
delta
)
.
c_str
(
)
)
;
destination
=
Metrics
(
)
.
CalculateScrollRange
(
)
.
ClampPoint
(
base
+
delta
)
;
}
else
if
(
scrollUpdate
.
GetType
(
)
=
=
ScrollUpdateType
:
:
PureRelative
)
{
CSSPoint
delta
=
scrollUpdate
.
GetDelta
(
)
;
APZC_LOG
(
"
%
p
pure
-
relative
smooth
scrolling
from
%
s
by
%
s
\
n
"
this
ToString
(
base
)
.
c_str
(
)
ToString
(
delta
)
.
c_str
(
)
)
;
destination
=
Metrics
(
)
.
CalculateScrollRange
(
)
.
ClampPoint
(
base
+
delta
)
;
}
else
{
APZC_LOG
(
"
%
p
smooth
scrolling
to
%
s
\
n
"
this
ToString
(
scrollUpdate
.
GetDestination
(
)
)
.
c_str
(
)
)
;
destination
=
scrollUpdate
.
GetDestination
(
)
;
}
if
(
scrollUpdate
.
GetMode
(
)
=
=
ScrollMode
:
:
SmoothMsd
)
{
SmoothMsdScrollTo
(
destination
)
;
}
else
{
MOZ_ASSERT
(
scrollUpdate
.
GetMode
(
)
=
=
ScrollMode
:
:
Smooth
)
;
SmoothScrollTo
(
destination
scrollUpdate
.
GetOrigin
(
)
)
;
}
continue
;
}
MOZ_ASSERT
(
scrollUpdate
.
GetMode
(
)
=
=
ScrollMode
:
:
Instant
|
|
scrollUpdate
.
GetMode
(
)
=
=
ScrollMode
:
:
Normal
)
;
if
(
nsLayoutUtils
:
:
CanScrollOriginClobberApz
(
scrollUpdate
.
GetOrigin
(
)
)
&
&
aLayerMetrics
.
GetVisualScrollUpdateType
(
)
!
=
FrameMetrics
:
:
eMainThread
)
{
ignoreVisualUpdate
=
true
;
}
Maybe
<
CSSPoint
>
relativeDelta
;
if
(
scrollUpdate
.
GetType
(
)
=
=
ScrollUpdateType
:
:
Relative
)
{
APZC_LOG
(
"
%
p
relative
updating
scroll
offset
from
%
s
by
%
s
\
n
"
this
ToString
(
Metrics
(
)
.
GetVisualScrollOffset
(
)
)
.
c_str
(
)
ToString
(
scrollUpdate
.
GetDestination
(
)
-
scrollUpdate
.
GetSource
(
)
)
.
c_str
(
)
)
;
scrollOffsetUpdated
=
true
;
if
(
Metrics
(
)
.
HasPendingScroll
(
aLayerMetrics
)
)
{
needContentRepaint
=
true
;
contentRepaintType
=
RepaintUpdateType
:
:
eUserAction
;
}
relativeDelta
=
Some
(
Metrics
(
)
.
ApplyRelativeScrollUpdateFrom
(
scrollUpdate
)
)
;
Metrics
(
)
.
RecalculateLayoutViewportOffset
(
)
;
}
else
if
(
scrollUpdate
.
GetType
(
)
=
=
ScrollUpdateType
:
:
PureRelative
)
{
APZC_LOG
(
"
%
p
pure
-
relative
updating
scroll
offset
from
%
s
by
%
s
\
n
"
this
ToString
(
Metrics
(
)
.
GetVisualScrollOffset
(
)
)
.
c_str
(
)
ToString
(
scrollUpdate
.
GetDelta
(
)
)
.
c_str
(
)
)
;
scrollOffsetUpdated
=
true
;
needContentRepaint
=
true
;
contentRepaintType
=
RepaintUpdateType
:
:
eVisualUpdate
;
ignoreVisualUpdate
=
true
;
relativeDelta
=
Some
(
Metrics
(
)
.
ApplyPureRelativeScrollUpdateFrom
(
scrollUpdate
)
)
;
Metrics
(
)
.
RecalculateLayoutViewportOffset
(
)
;
}
else
{
APZC_LOG
(
"
%
p
updating
scroll
offset
from
%
s
to
%
s
\
n
"
this
ToString
(
Metrics
(
)
.
GetVisualScrollOffset
(
)
)
.
c_str
(
)
ToString
(
scrollUpdate
.
GetDestination
(
)
)
.
c_str
(
)
)
;
bool
offsetChanged
=
Metrics
(
)
.
ApplyScrollUpdateFrom
(
scrollUpdate
)
;
Metrics
(
)
.
RecalculateLayoutViewportOffset
(
)
;
if
(
offsetChanged
|
|
scrollUpdate
.
GetMode
(
)
!
=
ScrollMode
:
:
Instant
|
|
scrollUpdate
.
GetType
(
)
!
=
ScrollUpdateType
:
:
Absolute
|
|
scrollUpdate
.
GetOrigin
(
)
!
=
ScrollOrigin
:
:
None
)
{
scrollOffsetUpdated
=
true
;
}
}
if
(
ShouldCancelAnimationForScrollUpdate
(
relativeDelta
)
)
{
CancelAnimation
(
)
;
}
}
if
(
scrollOffsetUpdated
)
{
for
(
auto
&
sampledState
:
mSampledState
)
{
sampledState
.
UpdateScrollProperties
(
Metrics
(
)
)
;
}
mExpectedGeckoMetrics
.
UpdateFrom
(
aLayerMetrics
)
;
needContentRepaint
=
true
;
ScheduleComposite
(
)
;
}
else
if
(
needToReclampScroll
)
{
ClampAndSetVisualScrollOffset
(
Metrics
(
)
.
GetVisualScrollOffset
(
)
)
;
for
(
auto
&
sampledState
:
mSampledState
)
{
sampledState
.
ClampVisualScrollOffset
(
Metrics
(
)
)
;
}
}
if
(
needToReclampScroll
)
{
if
(
IsInInvalidOverscroll
(
)
)
{
if
(
mState
=
=
OVERSCROLL_ANIMATION
)
{
CancelAnimation
(
)
;
}
else
if
(
IsOverscrolled
(
)
)
{
ClearOverscroll
(
)
;
}
}
}
if
(
smoothScrollRequested
&
&
!
scrollOffsetUpdated
)
{
mExpectedGeckoMetrics
.
UpdateFrom
(
aLayerMetrics
)
;
needContentRepaint
=
true
;
}
bool
visualScrollOffsetUpdated
=
!
ignoreVisualUpdate
&
&
(
isDefault
|
|
aLayerMetrics
.
GetVisualScrollUpdateType
(
)
!
=
FrameMetrics
:
:
eNone
)
;
if
(
visualScrollOffsetUpdated
)
{
APZC_LOG
(
"
%
p
updating
visual
scroll
offset
from
%
s
to
%
s
(
updateType
%
d
)
\
n
"
this
ToString
(
Metrics
(
)
.
GetVisualScrollOffset
(
)
)
.
c_str
(
)
ToString
(
aLayerMetrics
.
GetVisualDestination
(
)
)
.
c_str
(
)
(
int
)
aLayerMetrics
.
GetVisualScrollUpdateType
(
)
)
;
bool
offsetChanged
=
Metrics
(
)
.
ClampAndSetVisualScrollOffset
(
aLayerMetrics
.
GetVisualDestination
(
)
)
;
if
(
aLayerMetrics
.
GetVisualScrollUpdateType
(
)
=
=
FrameMetrics
:
:
eNone
&
&
!
offsetChanged
)
{
visualScrollOffsetUpdated
=
false
;
}
}
if
(
visualScrollOffsetUpdated
)
{
Metrics
(
)
.
RecalculateLayoutViewportOffset
(
)
;
for
(
auto
&
sampledState
:
mSampledState
)
{
sampledState
.
UpdateScrollProperties
(
Metrics
(
)
)
;
}
mExpectedGeckoMetrics
.
UpdateFrom
(
aLayerMetrics
)
;
if
(
ShouldCancelAnimationForScrollUpdate
(
Nothing
(
)
)
)
{
CancelAnimation
(
)
;
}
needContentRepaint
=
true
;
if
(
aLayerMetrics
.
GetVisualScrollUpdateType
(
)
=
=
FrameMetrics
:
:
eMainThread
)
{
contentRepaintType
=
RepaintUpdateType
:
:
eVisualUpdate
;
}
ScheduleComposite
(
)
;
}
if
(
viewportSizeUpdated
)
{
Metrics
(
)
.
RecalculateLayoutViewportOffset
(
)
;
}
if
(
needContentRepaint
)
{
RequestContentRepaint
(
contentRepaintType
)
;
}
UpdateSharedCompositorFrameMetrics
(
)
;
}
FrameMetrics
&
AsyncPanZoomController
:
:
Metrics
(
)
{
mRecursiveMutex
.
AssertCurrentThreadIn
(
)
;
return
mScrollMetadata
.
GetMetrics
(
)
;
}
const
FrameMetrics
&
AsyncPanZoomController
:
:
Metrics
(
)
const
{
mRecursiveMutex
.
AssertCurrentThreadIn
(
)
;
return
mScrollMetadata
.
GetMetrics
(
)
;
}
GeckoViewMetrics
AsyncPanZoomController
:
:
GetGeckoViewMetrics
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
GeckoViewMetrics
{
GetEffectiveScrollOffset
(
eForCompositing
lock
)
GetEffectiveZoom
(
eForCompositing
lock
)
}
;
}
bool
AsyncPanZoomController
:
:
UpdateRootFrameMetricsIfChanged
(
GeckoViewMetrics
&
aMetrics
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
!
Metrics
(
)
.
IsRootContent
(
)
)
{
return
false
;
}
GeckoViewMetrics
newMetrics
=
GetGeckoViewMetrics
(
)
;
bool
hasChanged
=
RoundedToInt
(
aMetrics
.
mVisualScrollOffset
)
!
=
RoundedToInt
(
newMetrics
.
mVisualScrollOffset
)
|
|
aMetrics
.
mZoom
!
=
newMetrics
.
mZoom
;
if
(
hasChanged
)
{
aMetrics
=
newMetrics
;
}
return
hasChanged
;
}
const
FrameMetrics
&
AsyncPanZoomController
:
:
GetFrameMetrics
(
)
const
{
return
Metrics
(
)
;
}
const
ScrollMetadata
&
AsyncPanZoomController
:
:
GetScrollMetadata
(
)
const
{
mRecursiveMutex
.
AssertCurrentThreadIn
(
)
;
return
mScrollMetadata
;
}
void
AsyncPanZoomController
:
:
AssertOnSamplerThread
(
)
const
{
if
(
APZCTreeManager
*
treeManagerLocal
=
GetApzcTreeManager
(
)
)
{
treeManagerLocal
-
>
AssertOnSamplerThread
(
)
;
}
}
void
AsyncPanZoomController
:
:
AssertOnUpdaterThread
(
)
const
{
if
(
APZCTreeManager
*
treeManagerLocal
=
GetApzcTreeManager
(
)
)
{
treeManagerLocal
-
>
AssertOnUpdaterThread
(
)
;
}
}
APZCTreeManager
*
AsyncPanZoomController
:
:
GetApzcTreeManager
(
)
const
{
mRecursiveMutex
.
AssertNotCurrentThreadIn
(
)
;
return
mTreeManager
;
}
void
AsyncPanZoomController
:
:
ZoomToRect
(
const
ZoomTarget
&
aZoomTarget
const
uint32_t
aFlags
)
{
CSSRect
rect
=
aZoomTarget
.
targetRect
;
if
(
!
rect
.
IsFinite
(
)
)
{
NS_WARNING
(
"
ZoomToRect
got
called
with
a
non
-
finite
rect
;
ignoring
.
.
.
"
)
;
return
;
}
if
(
rect
.
IsEmpty
(
)
&
&
(
aFlags
&
DISABLE_ZOOM_OUT
)
)
{
NS_WARNING
(
"
ZoomToRect
got
called
with
an
empty
rect
and
zoom
out
disabled
;
"
"
ignoring
.
.
.
"
)
;
return
;
}
SetState
(
ANIMATING_ZOOM
)
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
MOZ_ASSERT
(
Metrics
(
)
.
IsRootContent
(
)
)
;
MOZ_ASSERT
(
Metrics
(
)
.
GetZoom
(
)
.
AreScalesSame
(
)
)
;
ParentLayerRect
compositionBounds
=
Metrics
(
)
.
GetCompositionBounds
(
)
;
CSSRect
cssPageRect
=
Metrics
(
)
.
GetScrollableRect
(
)
;
CSSPoint
scrollOffset
=
Metrics
(
)
.
GetVisualScrollOffset
(
)
;
CSSToParentLayerScale
currentZoom
=
Metrics
(
)
.
GetZoom
(
)
.
ToScaleFactor
(
)
;
CSSToParentLayerScale
targetZoom
;
CSSToParentLayerScale
localMinZoom
(
std
:
:
max
(
mZoomConstraints
.
mMinZoom
.
scale
std
:
:
max
(
compositionBounds
.
Width
(
)
/
cssPageRect
.
Width
(
)
compositionBounds
.
Height
(
)
/
cssPageRect
.
Height
(
)
)
)
)
;
CSSToParentLayerScale
localMaxZoom
=
std
:
:
max
(
localMinZoom
mZoomConstraints
.
mMaxZoom
)
;
if
(
!
rect
.
IsEmpty
(
)
)
{
rect
=
rect
.
Intersect
(
cssPageRect
)
;
targetZoom
=
CSSToParentLayerScale
(
std
:
:
min
(
compositionBounds
.
Width
(
)
/
rect
.
Width
(
)
compositionBounds
.
Height
(
)
/
rect
.
Height
(
)
)
)
;
if
(
aFlags
&
DISABLE_ZOOM_OUT
)
{
targetZoom
=
std
:
:
max
(
targetZoom
currentZoom
)
;
}
}
bool
zoomOut
;
if
(
aFlags
&
DISABLE_ZOOM_OUT
)
{
zoomOut
=
false
;
}
else
{
zoomOut
=
rect
.
IsEmpty
(
)
|
|
(
currentZoom
=
=
localMaxZoom
&
&
targetZoom
>
=
localMaxZoom
)
|
|
(
currentZoom
=
=
localMinZoom
&
&
targetZoom
<
=
localMinZoom
)
;
}
FrameMetrics
endZoomToMetrics
=
Metrics
(
)
;
if
(
zoomOut
)
{
targetZoom
=
localMinZoom
;
endZoomToMetrics
.
SetZoom
(
CSSToParentLayerScale2D
(
targetZoom
)
)
;
CSSSize
sizeAfterZoom
=
endZoomToMetrics
.
CalculateCompositedSizeInCssPixels
(
)
;
CSSSize
sizeBeforeZoom
=
Metrics
(
)
.
CalculateCompositedSizeInCssPixels
(
)
;
rect
=
CSSRect
(
scrollOffset
.
x
+
(
sizeBeforeZoom
.
width
-
sizeAfterZoom
.
width
)
/
2
scrollOffset
.
y
+
(
sizeBeforeZoom
.
height
-
sizeAfterZoom
.
height
)
/
2
sizeAfterZoom
.
Width
(
)
sizeAfterZoom
.
Height
(
)
)
;
rect
=
rect
.
Intersect
(
cssPageRect
)
;
}
targetZoom
.
scale
=
clamped
(
targetZoom
.
scale
localMinZoom
.
scale
localMaxZoom
.
scale
)
;
if
(
aFlags
&
PAN_INTO_VIEW_ONLY
)
{
targetZoom
=
currentZoom
;
}
else
if
(
aFlags
&
ONLY_ZOOM_TO_DEFAULT_SCALE
)
{
CSSToParentLayerScale
zoomAtDefaultScale
=
Metrics
(
)
.
GetDevPixelsPerCSSPixel
(
)
*
LayoutDeviceToParentLayerScale
(
1
.
0
)
;
if
(
targetZoom
.
scale
>
zoomAtDefaultScale
.
scale
)
{
if
(
currentZoom
.
scale
<
zoomAtDefaultScale
.
scale
)
{
targetZoom
=
zoomAtDefaultScale
;
}
else
{
targetZoom
=
currentZoom
;
}
}
}
endZoomToMetrics
.
SetZoom
(
CSSToParentLayerScale2D
(
targetZoom
)
)
;
CSSSize
sizeAfterZoom
=
endZoomToMetrics
.
CalculateCompositedSizeInCssPixels
(
)
;
if
(
!
zoomOut
&
&
aZoomTarget
.
elementBoundingRect
.
isSome
(
)
)
{
MOZ_ASSERT
(
aZoomTarget
.
elementBoundingRect
-
>
Contains
(
rect
)
)
;
CSSRect
elementBoundingRect
=
aZoomTarget
.
elementBoundingRect
-
>
Intersect
(
cssPageRect
)
;
if
(
elementBoundingRect
.
width
<
=
sizeAfterZoom
.
width
&
&
elementBoundingRect
.
height
<
=
sizeAfterZoom
.
height
)
{
rect
=
elementBoundingRect
;
}
}
if
(
!
zoomOut
&
&
(
sizeAfterZoom
.
height
>
rect
.
Height
(
)
)
)
{
rect
.
MoveByY
(
-
(
sizeAfterZoom
.
height
-
rect
.
Height
(
)
)
*
0
.
5f
)
;
if
(
rect
.
Y
(
)
<
0
.
0f
)
{
rect
.
MoveToY
(
0
.
0f
)
;
}
}
if
(
!
zoomOut
&
&
(
sizeAfterZoom
.
width
>
rect
.
Width
(
)
)
)
{
rect
.
MoveByX
(
-
(
sizeAfterZoom
.
width
-
rect
.
Width
(
)
)
*
0
.
5f
)
;
if
(
rect
.
X
(
)
<
0
.
0f
)
{
rect
.
MoveToX
(
0
.
0f
)
;
}
}
if
(
rect
.
Y
(
)
+
sizeAfterZoom
.
height
>
cssPageRect
.
YMost
(
)
)
{
rect
.
MoveToY
(
std
:
:
max
(
cssPageRect
.
Y
(
)
cssPageRect
.
YMost
(
)
-
sizeAfterZoom
.
height
)
)
;
}
if
(
rect
.
Y
(
)
<
cssPageRect
.
Y
(
)
)
{
rect
.
MoveToY
(
cssPageRect
.
Y
(
)
)
;
}
if
(
rect
.
X
(
)
+
sizeAfterZoom
.
width
>
cssPageRect
.
XMost
(
)
)
{
rect
.
MoveToX
(
std
:
:
max
(
cssPageRect
.
X
(
)
cssPageRect
.
XMost
(
)
-
sizeAfterZoom
.
width
)
)
;
}
if
(
rect
.
X
(
)
<
cssPageRect
.
X
(
)
)
{
rect
.
MoveToY
(
cssPageRect
.
X
(
)
)
;
}
endZoomToMetrics
.
SetVisualScrollOffset
(
rect
.
TopLeft
(
)
)
;
endZoomToMetrics
.
RecalculateLayoutViewportOffset
(
)
;
StartAnimation
(
new
ZoomAnimation
(
*
this
Metrics
(
)
.
GetVisualScrollOffset
(
)
Metrics
(
)
.
GetZoom
(
)
endZoomToMetrics
.
GetVisualScrollOffset
(
)
endZoomToMetrics
.
GetZoom
(
)
)
)
;
RequestContentRepaint
(
RepaintUpdateType
:
:
eUserAction
)
;
}
}
InputBlockState
*
AsyncPanZoomController
:
:
GetCurrentInputBlock
(
)
const
{
return
GetInputQueue
(
)
-
>
GetCurrentBlock
(
)
;
}
TouchBlockState
*
AsyncPanZoomController
:
:
GetCurrentTouchBlock
(
)
const
{
return
GetInputQueue
(
)
-
>
GetCurrentTouchBlock
(
)
;
}
PanGestureBlockState
*
AsyncPanZoomController
:
:
GetCurrentPanGestureBlock
(
)
const
{
return
GetInputQueue
(
)
-
>
GetCurrentPanGestureBlock
(
)
;
}
PinchGestureBlockState
*
AsyncPanZoomController
:
:
GetCurrentPinchGestureBlock
(
)
const
{
return
GetInputQueue
(
)
-
>
GetCurrentPinchGestureBlock
(
)
;
}
void
AsyncPanZoomController
:
:
ResetTouchInputState
(
)
{
MultiTouchInput
cancel
(
MultiTouchInput
:
:
MULTITOUCH_CANCEL
0
TimeStamp
:
:
Now
(
)
0
)
;
RefPtr
<
GestureEventListener
>
listener
=
GetGestureEventListener
(
)
;
if
(
listener
)
{
listener
-
>
HandleInputEvent
(
cancel
)
;
}
CancelAnimationAndGestureState
(
)
;
if
(
TouchBlockState
*
block
=
GetCurrentTouchBlock
(
)
)
{
block
-
>
GetOverscrollHandoffChain
(
)
-
>
ClearOverscroll
(
)
;
}
}
void
AsyncPanZoomController
:
:
ResetPanGestureInputState
(
)
{
CancelAnimationAndGestureState
(
)
;
if
(
PanGestureBlockState
*
block
=
GetCurrentPanGestureBlock
(
)
)
{
block
-
>
GetOverscrollHandoffChain
(
)
-
>
ClearOverscroll
(
)
;
}
}
void
AsyncPanZoomController
:
:
CancelAnimationAndGestureState
(
)
{
mX
.
CancelGesture
(
)
;
mY
.
CancelGesture
(
)
;
CancelAnimation
(
CancelAnimationFlags
:
:
ScrollSnap
)
;
}
bool
AsyncPanZoomController
:
:
HasReadyTouchBlock
(
)
const
{
return
GetInputQueue
(
)
-
>
HasReadyTouchBlock
(
)
;
}
bool
AsyncPanZoomController
:
:
CanHandleScrollOffsetUpdate
(
PanZoomState
aState
)
{
return
aState
=
=
PAN_MOMENTUM
|
|
aState
=
=
TOUCHING
|
|
IsPanningState
(
aState
)
;
}
bool
AsyncPanZoomController
:
:
ShouldCancelAnimationForScrollUpdate
(
const
Maybe
<
CSSPoint
>
&
aRelativeDelta
)
{
if
(
aRelativeDelta
=
=
Some
(
CSSPoint
(
)
)
)
{
return
false
;
}
if
(
mAnimation
)
{
return
!
mAnimation
-
>
HandleScrollOffsetUpdate
(
aRelativeDelta
)
;
}
return
!
CanHandleScrollOffsetUpdate
(
mState
)
;
}
void
AsyncPanZoomController
:
:
SetState
(
PanZoomState
aNewState
)
{
PanZoomState
oldState
;
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
APZC_LOG
(
"
%
p
changing
from
state
%
d
to
%
d
\
n
"
this
mState
aNewState
)
;
oldState
=
mState
;
mState
=
aNewState
;
}
DispatchStateChangeNotification
(
oldState
aNewState
)
;
}
void
AsyncPanZoomController
:
:
DispatchStateChangeNotification
(
PanZoomState
aOldState
PanZoomState
aNewState
)
{
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
mNotificationBlockers
>
0
)
{
return
;
}
}
if
(
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
)
{
if
(
!
IsTransformingState
(
aOldState
)
&
&
IsTransformingState
(
aNewState
)
)
{
controller
-
>
NotifyAPZStateChange
(
GetGuid
(
)
APZStateChange
:
:
eTransformBegin
)
;
}
else
if
(
IsTransformingState
(
aOldState
)
&
&
!
IsTransformingState
(
aNewState
)
)
{
controller
-
>
NotifyAPZStateChange
(
GetGuid
(
)
APZStateChange
:
:
eTransformEnd
)
;
}
}
}
bool
AsyncPanZoomController
:
:
IsInTransformingState
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
IsTransformingState
(
mState
)
;
}
bool
AsyncPanZoomController
:
:
IsTransformingState
(
PanZoomState
aState
)
{
return
!
(
aState
=
=
NOTHING
|
|
aState
=
=
TOUCHING
)
;
}
bool
AsyncPanZoomController
:
:
IsPanningState
(
PanZoomState
aState
)
{
return
(
aState
=
=
PANNING
|
|
aState
=
=
PANNING_LOCKED_X
|
|
aState
=
=
PANNING_LOCKED_Y
)
;
}
bool
AsyncPanZoomController
:
:
IsInPanningState
(
)
const
{
return
IsPanningState
(
mState
)
;
}
void
AsyncPanZoomController
:
:
UpdateZoomConstraints
(
const
ZoomConstraints
&
aConstraints
)
{
APZC_LOG
(
"
%
p
updating
zoom
constraints
to
%
d
%
d
%
f
%
f
\
n
"
this
aConstraints
.
mAllowZoom
aConstraints
.
mAllowDoubleTapZoom
aConstraints
.
mMinZoom
.
scale
aConstraints
.
mMaxZoom
.
scale
)
;
if
(
IsNaN
(
aConstraints
.
mMinZoom
.
scale
)
|
|
IsNaN
(
aConstraints
.
mMaxZoom
.
scale
)
)
{
NS_WARNING
(
"
APZC
received
zoom
constraints
with
NaN
values
;
dropping
.
.
.
"
)
;
return
;
}
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
CSSToParentLayerScale
min
=
Metrics
(
)
.
GetDevPixelsPerCSSPixel
(
)
*
kViewportMinScale
/
ParentLayerToScreenScale
(
1
)
;
CSSToParentLayerScale
max
=
Metrics
(
)
.
GetDevPixelsPerCSSPixel
(
)
*
kViewportMaxScale
/
ParentLayerToScreenScale
(
1
)
;
mZoomConstraints
.
mAllowZoom
=
aConstraints
.
mAllowZoom
;
mZoomConstraints
.
mAllowDoubleTapZoom
=
aConstraints
.
mAllowDoubleTapZoom
;
mZoomConstraints
.
mMinZoom
=
(
min
>
aConstraints
.
mMinZoom
?
min
:
aConstraints
.
mMinZoom
)
;
mZoomConstraints
.
mMaxZoom
=
(
max
>
aConstraints
.
mMaxZoom
?
aConstraints
.
mMaxZoom
:
max
)
;
if
(
mZoomConstraints
.
mMaxZoom
<
mZoomConstraints
.
mMinZoom
)
{
mZoomConstraints
.
mMaxZoom
=
mZoomConstraints
.
mMinZoom
;
}
}
bool
AsyncPanZoomController
:
:
ZoomConstraintsAllowZoom
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
mZoomConstraints
.
mAllowZoom
;
}
bool
AsyncPanZoomController
:
:
ZoomConstraintsAllowDoubleTapZoom
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
mZoomConstraints
.
mAllowDoubleTapZoom
;
}
void
AsyncPanZoomController
:
:
PostDelayedTask
(
already_AddRefed
<
Runnable
>
aTask
int
aDelayMs
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
RefPtr
<
Runnable
>
task
=
aTask
;
RefPtr
<
GeckoContentController
>
controller
=
GetGeckoContentController
(
)
;
if
(
controller
)
{
controller
-
>
PostDelayedTask
(
task
.
forget
(
)
aDelayMs
)
;
}
}
bool
AsyncPanZoomController
:
:
Matches
(
const
ScrollableLayerGuid
&
aGuid
)
{
return
aGuid
=
=
GetGuid
(
)
;
}
bool
AsyncPanZoomController
:
:
HasTreeManager
(
const
APZCTreeManager
*
aTreeManager
)
const
{
return
GetApzcTreeManager
(
)
=
=
aTreeManager
;
}
void
AsyncPanZoomController
:
:
GetGuid
(
ScrollableLayerGuid
*
aGuidOut
)
const
{
if
(
aGuidOut
)
{
*
aGuidOut
=
GetGuid
(
)
;
}
}
ScrollableLayerGuid
AsyncPanZoomController
:
:
GetGuid
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
ScrollableLayerGuid
(
mLayersId
Metrics
(
)
.
GetPresShellId
(
)
Metrics
(
)
.
GetScrollId
(
)
)
;
}
void
AsyncPanZoomController
:
:
UpdateSharedCompositorFrameMetrics
(
)
{
mRecursiveMutex
.
AssertCurrentThreadIn
(
)
;
FrameMetrics
*
frame
=
mSharedFrameMetricsBuffer
?
static_cast
<
FrameMetrics
*
>
(
mSharedFrameMetricsBuffer
-
>
memory
(
)
)
:
nullptr
;
if
(
frame
&
&
mSharedLock
&
&
apz
:
:
ShouldUseProgressivePaint
(
)
)
{
mSharedLock
-
>
Lock
(
)
;
*
frame
=
Metrics
(
)
;
mSharedLock
-
>
Unlock
(
)
;
}
}
void
AsyncPanZoomController
:
:
ShareCompositorFrameMetrics
(
)
{
AssertOnUpdaterThread
(
)
;
if
(
!
mSharedFrameMetricsBuffer
&
&
mMetricsSharingController
&
&
apz
:
:
ShouldUseProgressivePaint
(
)
)
{
mSharedFrameMetricsBuffer
=
new
ipc
:
:
SharedMemoryBasic
;
FrameMetrics
*
frame
=
nullptr
;
mSharedFrameMetricsBuffer
-
>
Create
(
sizeof
(
FrameMetrics
)
)
;
mSharedFrameMetricsBuffer
-
>
Map
(
sizeof
(
FrameMetrics
)
)
;
frame
=
static_cast
<
FrameMetrics
*
>
(
mSharedFrameMetricsBuffer
-
>
memory
(
)
)
;
if
(
frame
)
{
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
*
frame
=
Metrics
(
)
;
}
base
:
:
ProcessId
otherPid
=
mMetricsSharingController
-
>
RemotePid
(
)
;
ipc
:
:
SharedMemoryBasic
:
:
Handle
mem
=
ipc
:
:
SharedMemoryBasic
:
:
NULLHandle
(
)
;
mSharedFrameMetricsBuffer
-
>
ShareToProcess
(
otherPid
&
mem
)
;
mSharedLock
=
new
CrossProcessMutex
(
"
AsyncPanZoomControlLock
"
)
;
CrossProcessMutexHandle
handle
=
mSharedLock
-
>
ShareToProcess
(
otherPid
)
;
if
(
!
mMetricsSharingController
-
>
StartSharingMetrics
(
mem
handle
mLayersId
mAPZCId
)
)
{
APZC_LOG
(
"
%
p
failed
to
share
FrameMetrics
with
content
process
.
"
this
)
;
}
}
}
}
void
AsyncPanZoomController
:
:
SetTestAsyncScrollOffset
(
const
CSSPoint
&
aPoint
)
{
mTestAsyncScrollOffset
=
aPoint
;
ScheduleComposite
(
)
;
}
void
AsyncPanZoomController
:
:
SetTestAsyncZoom
(
const
LayerToParentLayerScale
&
aZoom
)
{
mTestAsyncZoom
=
aZoom
;
ScheduleComposite
(
)
;
}
Maybe
<
CSSPoint
>
AsyncPanZoomController
:
:
FindSnapPointNear
(
const
CSSPoint
&
aDestination
ScrollUnit
aUnit
)
{
mRecursiveMutex
.
AssertCurrentThreadIn
(
)
;
APZC_LOG
(
"
%
p
scroll
snapping
near
%
s
\
n
"
this
ToString
(
aDestination
)
.
c_str
(
)
)
;
CSSRect
scrollRange
=
Metrics
(
)
.
CalculateScrollRange
(
)
;
if
(
Maybe
<
nsPoint
>
snapPoint
=
ScrollSnapUtils
:
:
GetSnapPointForDestination
(
mScrollMetadata
.
GetSnapInfo
(
)
aUnit
CSSRect
:
:
ToAppUnits
(
scrollRange
)
CSSPoint
:
:
ToAppUnits
(
Metrics
(
)
.
GetVisualScrollOffset
(
)
)
CSSPoint
:
:
ToAppUnits
(
aDestination
)
)
)
{
CSSPoint
cssSnapPoint
=
CSSPoint
:
:
FromAppUnits
(
snapPoint
.
ref
(
)
)
;
return
Some
(
scrollRange
.
ClampPoint
(
cssSnapPoint
)
)
;
}
return
Nothing
(
)
;
}
void
AsyncPanZoomController
:
:
ScrollSnapNear
(
const
CSSPoint
&
aDestination
)
{
if
(
Maybe
<
CSSPoint
>
snapPoint
=
FindSnapPointNear
(
aDestination
ScrollUnit
:
:
DEVICE_PIXELS
)
)
{
if
(
*
snapPoint
!
=
Metrics
(
)
.
GetVisualScrollOffset
(
)
)
{
APZC_LOG
(
"
%
p
smooth
scrolling
to
snap
point
%
s
\
n
"
this
ToString
(
*
snapPoint
)
.
c_str
(
)
)
;
SmoothMsdScrollTo
(
*
snapPoint
)
;
}
}
}
void
AsyncPanZoomController
:
:
ScrollSnap
(
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
ScrollSnapNear
(
Metrics
(
)
.
GetVisualScrollOffset
(
)
)
;
}
void
AsyncPanZoomController
:
:
ScrollSnapToDestination
(
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
float
friction
=
StaticPrefs
:
:
apz_fling_friction
(
)
;
ParentLayerPoint
velocity
(
mX
.
GetVelocity
(
)
mY
.
GetVelocity
(
)
)
;
ParentLayerPoint
predictedDelta
;
if
(
velocity
.
x
!
=
0
.
0f
&
&
friction
!
=
0
.
0f
)
{
predictedDelta
.
x
=
-
velocity
.
x
/
log
(
1
.
0
-
friction
)
;
}
if
(
velocity
.
y
!
=
0
.
0f
&
&
friction
!
=
0
.
0f
)
{
predictedDelta
.
y
=
-
velocity
.
y
/
log
(
1
.
0
-
friction
)
;
}
bool
flingWillOverscroll
=
IsOverscrolled
(
)
&
&
(
(
velocity
.
x
*
mX
.
GetOverscroll
(
)
>
=
0
)
|
|
(
velocity
.
y
*
mY
.
GetOverscroll
(
)
>
=
0
)
)
;
if
(
flingWillOverscroll
)
{
return
;
}
CSSPoint
startPosition
=
Metrics
(
)
.
GetVisualScrollOffset
(
)
;
if
(
MaybeAdjustDeltaForScrollSnapping
(
ScrollUnit
:
:
LINES
predictedDelta
startPosition
)
)
{
APZC_LOG
(
"
%
p
fling
snapping
.
friction
:
%
f
velocity
:
%
f
%
f
"
"
predictedDelta
:
%
f
%
f
position
:
%
f
%
f
"
"
snapDestination
:
%
f
%
f
\
n
"
this
friction
velocity
.
x
velocity
.
y
(
float
)
predictedDelta
.
x
(
float
)
predictedDelta
.
y
(
float
)
Metrics
(
)
.
GetVisualScrollOffset
(
)
.
x
(
float
)
Metrics
(
)
.
GetVisualScrollOffset
(
)
.
y
(
float
)
startPosition
.
x
(
float
)
startPosition
.
y
)
;
SmoothMsdScrollTo
(
startPosition
)
;
}
}
bool
AsyncPanZoomController
:
:
MaybeAdjustDeltaForScrollSnapping
(
ScrollUnit
aUnit
ParentLayerPoint
&
aDelta
CSSPoint
&
aStartPosition
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
CSSToParentLayerScale2D
zoom
=
Metrics
(
)
.
GetZoom
(
)
;
if
(
zoom
=
=
CSSToParentLayerScale2D
(
0
0
)
)
{
return
false
;
}
CSSPoint
destination
=
Metrics
(
)
.
CalculateScrollRange
(
)
.
ClampPoint
(
aStartPosition
+
(
aDelta
/
zoom
)
)
;
if
(
Maybe
<
CSSPoint
>
snapPoint
=
FindSnapPointNear
(
destination
aUnit
)
)
{
aDelta
=
(
*
snapPoint
-
aStartPosition
)
*
zoom
;
aStartPosition
=
*
snapPoint
;
return
true
;
}
return
false
;
}
bool
AsyncPanZoomController
:
:
MaybeAdjustDeltaForScrollSnappingOnWheelInput
(
const
ScrollWheelInput
&
aEvent
ParentLayerPoint
&
aDelta
CSSPoint
&
aStartPosition
)
{
if
(
aEvent
.
mDeltaType
=
=
ScrollWheelInput
:
:
SCROLLDELTA_PIXEL
)
{
return
false
;
}
return
MaybeAdjustDeltaForScrollSnapping
(
ScrollWheelInput
:
:
ScrollUnitForDeltaType
(
aEvent
.
mDeltaType
)
aDelta
aStartPosition
)
;
}
bool
AsyncPanZoomController
:
:
MaybeAdjustDestinationForScrollSnapping
(
const
KeyboardInput
&
aEvent
CSSPoint
&
aDestination
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
ScrollUnit
unit
=
KeyboardScrollAction
:
:
GetScrollUnit
(
aEvent
.
mAction
.
mType
)
;
if
(
Maybe
<
CSSPoint
>
snapPoint
=
FindSnapPointNear
(
aDestination
unit
)
)
{
aDestination
=
*
snapPoint
;
return
true
;
}
return
false
;
}
void
AsyncPanZoomController
:
:
SetZoomAnimationId
(
const
Maybe
<
uint64_t
>
&
aZoomAnimationId
)
{
mZoomAnimationId
=
aZoomAnimationId
;
}
Maybe
<
uint64_t
>
AsyncPanZoomController
:
:
GetZoomAnimationId
(
)
const
{
return
mZoomAnimationId
;
}
}
}
