#
include
"
FlingAccelerator
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
include
"
GenericFlingAnimation
.
h
"
namespace
mozilla
{
namespace
layers
{
void
FlingAccelerator
:
:
Reset
(
)
{
mPreviousFlingStartTime
=
SampleTime
{
}
;
mPreviousFlingStartingVelocity
=
ParentLayerPoint
{
}
;
mPreviousFlingCancelVelocity
=
ParentLayerPoint
{
}
;
}
static
bool
SameDirection
(
float
aVelocity1
float
aVelocity2
)
{
return
(
aVelocity1
=
=
0
.
0f
)
|
|
(
aVelocity2
=
=
0
.
0f
)
|
|
(
IsNegative
(
aVelocity1
)
=
=
IsNegative
(
aVelocity2
)
)
;
}
static
float
Accelerate
(
float
aBase
float
aSupplemental
)
{
return
(
aBase
*
StaticPrefs
:
:
apz_fling_accel_base_mult
(
)
)
+
(
aSupplemental
*
StaticPrefs
:
:
apz_fling_accel_supplemental_mult
(
)
)
;
}
ParentLayerPoint
FlingAccelerator
:
:
GetFlingStartingVelocity
(
const
SampleTime
&
aNow
const
ParentLayerPoint
&
aVelocity
const
FlingHandoffState
&
aHandoffState
)
{
ParentLayerPoint
velocity
=
aVelocity
;
if
(
ShouldAccelerate
(
aNow
aVelocity
aHandoffState
)
)
{
if
(
velocity
.
x
!
=
0
&
&
SameDirection
(
velocity
.
x
mPreviousFlingStartingVelocity
.
x
)
)
{
velocity
.
x
=
Accelerate
(
velocity
.
x
mPreviousFlingStartingVelocity
.
x
)
;
FLING_LOG
(
"
%
p
Applying
fling
x
-
acceleration
from
%
f
to
%
f
(
delta
%
f
)
\
n
"
this
aVelocity
.
x
velocity
.
x
mPreviousFlingStartingVelocity
.
x
)
;
}
if
(
velocity
.
y
!
=
0
&
&
SameDirection
(
velocity
.
y
mPreviousFlingStartingVelocity
.
y
)
)
{
velocity
.
y
=
Accelerate
(
velocity
.
y
mPreviousFlingStartingVelocity
.
y
)
;
FLING_LOG
(
"
%
p
Applying
fling
y
-
acceleration
from
%
f
to
%
f
(
delta
%
f
)
\
n
"
this
aVelocity
.
y
velocity
.
y
mPreviousFlingStartingVelocity
.
y
)
;
}
}
Reset
(
)
;
mPreviousFlingStartTime
=
aNow
;
mPreviousFlingStartingVelocity
=
velocity
;
return
velocity
;
}
bool
FlingAccelerator
:
:
ShouldAccelerate
(
const
SampleTime
&
aNow
const
ParentLayerPoint
&
aVelocity
const
FlingHandoffState
&
aHandoffState
)
const
{
if
(
!
IsTracking
(
)
|
|
mPreviousFlingStartTime
.
IsNull
(
)
)
{
FLING_LOG
(
"
%
p
Fling
accelerator
was
reset
not
accelerating
.
\
n
"
this
)
;
return
false
;
}
if
(
!
aHandoffState
.
mTouchStartRestingTime
)
{
FLING_LOG
(
"
%
p
Don
'
t
have
a
touch
start
resting
time
not
accelerating
.
\
n
"
this
)
;
return
false
;
}
double
msSincePreviousFling
=
(
aNow
-
mPreviousFlingStartTime
)
.
ToMilliseconds
(
)
;
double
msBetweenTouchStartAndPanStart
=
aHandoffState
.
mTouchStartRestingTime
-
>
ToMilliseconds
(
)
;
FLING_LOG
(
"
%
p
ShouldAccelerate
with
pan
velocity
%
f
pixels
/
ms
previous
fling
"
"
cancel
velocity
%
f
pixels
/
ms
time
elapsed
since
starting
previous
"
"
fling
%
fms
time
between
touch
start
and
pan
start
%
fms
.
\
n
"
this
float
(
aVelocity
.
Length
(
)
)
float
(
mPreviousFlingCancelVelocity
.
Length
(
)
)
float
(
msSincePreviousFling
)
float
(
msBetweenTouchStartAndPanStart
)
)
;
if
(
aVelocity
.
Length
(
)
<
StaticPrefs
:
:
apz_fling_accel_min_velocity
(
)
)
{
FLING_LOG
(
"
%
p
Fling
velocity
too
low
(
%
f
)
not
accelerating
.
\
n
"
this
float
(
aVelocity
.
Length
(
)
)
)
;
return
false
;
}
if
(
mPreviousFlingCancelVelocity
.
Length
(
)
<
StaticPrefs
:
:
apz_fling_accel_min_velocity
(
)
)
{
FLING_LOG
(
"
%
p
The
previous
fling
animation
had
slowed
down
too
much
when
it
was
"
"
interrupted
(
%
f
)
not
accelerating
.
\
n
"
this
float
(
mPreviousFlingCancelVelocity
.
Length
(
)
)
)
;
return
false
;
}
if
(
msSincePreviousFling
>
=
StaticPrefs
:
:
apz_fling_accel_interval_ms
(
)
)
{
FLING_LOG
(
"
%
p
Too
much
time
(
%
fms
)
elapsed
since
previous
fling
not
"
"
accelerating
.
\
n
"
this
msSincePreviousFling
)
;
return
false
;
}
if
(
msBetweenTouchStartAndPanStart
>
=
StaticPrefs
:
:
apz_fling_accel_max_pause_interval_ms
(
)
)
{
FLING_LOG
(
"
%
p
Too
much
time
(
%
fms
)
elapsed
between
touch
start
and
pan
start
"
"
not
accelerating
.
\
n
"
this
msBetweenTouchStartAndPanStart
)
;
return
false
;
}
return
true
;
}
}
}
