#
include
"
AndroidVelocityTracker
.
h
"
#
include
"
gfxPrefs
.
h
"
namespace
mozilla
{
namespace
layers
{
static
const
int
kAssumePointerMoveStoppedTimeMs
=
40
;
static
const
uint8_t
kDegree
=
2
;
static
const
uint8_t
kPolyDegree
=
kDegree
+
1
;
static
const
uint8_t
kHistorySize
=
20
;
AndroidVelocityTracker
:
:
AndroidVelocityTracker
(
)
:
mLastEventTime
(
0
)
mAdditionalDelta
(
0
)
{
}
void
AndroidVelocityTracker
:
:
StartTracking
(
ParentLayerCoord
aPos
uint32_t
aTimestampMs
)
{
Clear
(
)
;
mLastEventTime
=
aTimestampMs
;
}
Maybe
<
float
>
AndroidVelocityTracker
:
:
AddPosition
(
ParentLayerCoord
aPos
uint32_t
aTimestampMs
bool
aIsAxisLocked
)
{
if
(
(
aTimestampMs
-
mLastEventTime
)
>
=
kAssumePointerMoveStoppedTimeMs
)
{
Clear
(
)
;
}
mLastEventTime
=
aTimestampMs
;
if
(
aIsAxisLocked
&
&
!
mHistory
.
IsEmpty
(
)
)
{
aPos
=
mHistory
[
mHistory
.
Length
(
)
-
1
]
.
second
-
mAdditionalDelta
;
}
mHistory
.
AppendElement
(
std
:
:
make_pair
(
aTimestampMs
aPos
+
mAdditionalDelta
)
)
;
if
(
mHistory
.
Length
(
)
>
kHistorySize
)
{
mHistory
.
RemoveElementAt
(
0
)
;
}
if
(
mHistory
.
Length
(
)
<
2
)
{
return
Nothing
(
)
;
}
auto
start
=
mHistory
[
mHistory
.
Length
(
)
-
2
]
;
auto
end
=
mHistory
[
mHistory
.
Length
(
)
-
1
]
;
return
Some
(
(
end
.
second
-
start
.
second
)
/
(
end
.
first
-
start
.
first
)
)
;
}
float
AndroidVelocityTracker
:
:
HandleDynamicToolbarMovement
(
uint32_t
aStartTimestampMs
uint32_t
aEndTimestampMs
ParentLayerCoord
aDelta
)
{
mAdditionalDelta
+
=
aDelta
;
float
timeDelta
=
aEndTimestampMs
-
aStartTimestampMs
;
MOZ_ASSERT
(
timeDelta
!
=
0
)
;
return
aDelta
/
timeDelta
;
}
static
float
VectorDot
(
const
float
*
a
const
float
*
b
uint32_t
m
)
{
float
r
=
0
;
while
(
m
-
-
)
{
r
+
=
*
(
a
+
+
)
*
*
(
b
+
+
)
;
}
return
r
;
}
static
float
VectorNorm
(
const
float
*
a
uint32_t
m
)
{
float
r
=
0
;
while
(
m
-
-
)
{
float
t
=
*
(
a
+
+
)
;
r
+
=
t
*
t
;
}
return
sqrtf
(
r
)
;
}
static
bool
SolveLeastSquares
(
const
float
*
x
const
float
*
y
const
float
*
w
uint32_t
m
uint32_t
n
float
*
out_b
)
{
#
if
defined
(
COMPILER_MSVC
)
const
uint32_t
M_ARRAY_LENGTH
=
VelocityTracker
:
:
kHistorySize
;
const
uint32_t
N_ARRAY_LENGTH
=
VelocityTracker
:
:
kPolyDegree
;
DCHECK_LE
(
m
M_ARRAY_LENGTH
)
;
DCHECK_LE
(
n
N_ARRAY_LENGTH
)
;
#
else
const
uint32_t
M_ARRAY_LENGTH
=
m
;
const
uint32_t
N_ARRAY_LENGTH
=
n
;
#
endif
float
a
[
N_ARRAY_LENGTH
]
[
M_ARRAY_LENGTH
]
;
for
(
uint32_t
h
=
0
;
h
<
m
;
h
+
+
)
{
a
[
0
]
[
h
]
=
w
[
h
]
;
for
(
uint32_t
i
=
1
;
i
<
n
;
i
+
+
)
{
a
[
i
]
[
h
]
=
a
[
i
-
1
]
[
h
]
*
x
[
h
]
;
}
}
float
q
[
N_ARRAY_LENGTH
]
[
M_ARRAY_LENGTH
]
;
float
r
[
N_ARRAY_LENGTH
]
[
N_ARRAY_LENGTH
]
;
for
(
uint32_t
j
=
0
;
j
<
n
;
j
+
+
)
{
for
(
uint32_t
h
=
0
;
h
<
m
;
h
+
+
)
{
q
[
j
]
[
h
]
=
a
[
j
]
[
h
]
;
}
for
(
uint32_t
i
=
0
;
i
<
j
;
i
+
+
)
{
float
dot
=
VectorDot
(
&
q
[
j
]
[
0
]
&
q
[
i
]
[
0
]
m
)
;
for
(
uint32_t
h
=
0
;
h
<
m
;
h
+
+
)
{
q
[
j
]
[
h
]
-
=
dot
*
q
[
i
]
[
h
]
;
}
}
float
norm
=
VectorNorm
(
&
q
[
j
]
[
0
]
m
)
;
if
(
norm
<
0
.
000001f
)
{
return
false
;
}
float
invNorm
=
1
.
0f
/
norm
;
for
(
uint32_t
h
=
0
;
h
<
m
;
h
+
+
)
{
q
[
j
]
[
h
]
*
=
invNorm
;
}
for
(
uint32_t
i
=
0
;
i
<
n
;
i
+
+
)
{
r
[
j
]
[
i
]
=
i
<
j
?
0
:
VectorDot
(
&
q
[
j
]
[
0
]
&
a
[
i
]
[
0
]
m
)
;
}
}
float
wy
[
M_ARRAY_LENGTH
]
;
for
(
uint32_t
h
=
0
;
h
<
m
;
h
+
+
)
{
wy
[
h
]
=
y
[
h
]
*
w
[
h
]
;
}
for
(
uint32_t
i
=
n
;
i
-
-
!
=
0
;
)
{
out_b
[
i
]
=
VectorDot
(
&
q
[
i
]
[
0
]
wy
m
)
;
for
(
uint32_t
j
=
n
-
1
;
j
>
i
;
j
-
-
)
{
out_b
[
i
]
-
=
r
[
i
]
[
j
]
*
out_b
[
j
]
;
}
out_b
[
i
]
/
=
r
[
i
]
[
i
]
;
}
return
true
;
}
Maybe
<
float
>
AndroidVelocityTracker
:
:
ComputeVelocity
(
uint32_t
aTimestampMs
)
{
if
(
mHistory
.
IsEmpty
(
)
)
{
return
Nothing
{
}
;
}
float
xcoeff
[
kPolyDegree
+
1
]
;
for
(
size_t
i
=
0
;
i
<
=
kPolyDegree
;
i
+
+
)
{
xcoeff
[
i
]
=
0
;
}
float
pos
[
kHistorySize
]
;
float
w
[
kHistorySize
]
;
float
time
[
kHistorySize
]
;
uint32_t
m
=
0
;
int
index
=
mHistory
.
Length
(
)
-
1
;
const
uint32_t
horizon
=
gfxPrefs
:
:
APZVelocityRelevanceTime
(
)
;
const
auto
&
newest_movement
=
mHistory
[
index
]
;
do
{
const
auto
&
movement
=
mHistory
[
index
]
;
uint32_t
age
=
newest_movement
.
first
-
movement
.
first
;
if
(
age
>
horizon
)
break
;
ParentLayerCoord
position
=
movement
.
second
;
pos
[
m
]
=
position
;
w
[
m
]
=
1
.
0f
;
time
[
m
]
=
-
static_cast
<
float
>
(
age
)
/
1000
.
0f
;
index
-
-
;
m
+
+
;
}
while
(
index
>
=
0
)
;
if
(
m
=
=
0
)
{
return
Nothing
{
}
;
}
uint32_t
degree
=
kDegree
;
if
(
degree
>
m
-
1
)
{
degree
=
m
-
1
;
}
if
(
degree
>
=
1
)
{
uint32_t
n
=
degree
+
1
;
if
(
SolveLeastSquares
(
time
pos
w
m
n
xcoeff
)
)
{
float
velocity
=
xcoeff
[
1
]
;
return
Some
(
-
velocity
/
1000
.
0f
)
;
}
}
return
Nothing
{
}
;
}
void
AndroidVelocityTracker
:
:
Clear
(
)
{
mAdditionalDelta
=
0
;
mHistory
.
Clear
(
)
;
}
}
}
