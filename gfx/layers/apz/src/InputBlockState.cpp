#
include
"
InputBlockState
.
h
"
#
include
"
APZUtils
.
h
"
#
include
"
AsyncPanZoomController
.
h
"
#
include
"
ScrollAnimationPhysics
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
layers
/
IAPZCTreeManager
.
h
"
#
include
"
OverscrollHandoffState
.
h
"
#
include
"
QueuedInput
.
h
"
#
define
TBS_LOG
(
.
.
.
)
namespace
mozilla
{
namespace
layers
{
static
uint64_t
sBlockCounter
=
InputBlockState
:
:
NO_BLOCK_ID
+
1
;
InputBlockState
:
:
InputBlockState
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTargetApzc
TargetConfirmationFlags
aFlags
)
:
mTargetApzc
(
aTargetApzc
)
mTargetConfirmed
(
aFlags
.
mTargetConfirmed
?
TargetConfirmationState
:
:
eConfirmed
:
TargetConfirmationState
:
:
eUnconfirmed
)
mRequiresTargetConfirmation
(
aFlags
.
mRequiresTargetConfirmation
)
mBlockId
(
sBlockCounter
+
+
)
mTransformToApzc
(
aTargetApzc
-
>
GetTransformToThis
(
)
)
{
MOZ_ASSERT
(
mTargetApzc
)
;
mOverscrollHandoffChain
=
mTargetApzc
-
>
BuildOverscrollHandoffChain
(
)
;
}
bool
InputBlockState
:
:
SetConfirmedTargetApzc
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTargetApzc
TargetConfirmationState
aState
InputData
*
aFirstInput
bool
aForScrollbarDrag
)
{
MOZ_ASSERT
(
aState
=
=
TargetConfirmationState
:
:
eConfirmed
|
|
aState
=
=
TargetConfirmationState
:
:
eTimedOut
)
;
if
(
mTargetConfirmed
=
=
TargetConfirmationState
:
:
eTimedOut
&
&
aState
=
=
TargetConfirmationState
:
:
eConfirmed
)
{
mTargetConfirmed
=
TargetConfirmationState
:
:
eTimedOutAndMainThreadResponded
;
}
if
(
AsDragBlock
(
)
&
&
aForScrollbarDrag
&
&
mTargetConfirmed
=
=
TargetConfirmationState
:
:
eConfirmed
&
&
aState
=
=
TargetConfirmationState
:
:
eConfirmed
&
&
mTargetApzc
&
&
aTargetApzc
&
&
mTargetApzc
-
>
GetGuid
(
)
!
=
aTargetApzc
-
>
GetGuid
(
)
)
{
MOZ_ASSERT
(
false
"
APZ
and
main
thread
confirmed
scrollbar
drag
block
with
"
"
different
targets
"
)
;
UpdateTargetApzc
(
aTargetApzc
)
;
return
true
;
}
if
(
mTargetConfirmed
!
=
TargetConfirmationState
:
:
eUnconfirmed
)
{
return
false
;
}
mTargetConfirmed
=
aState
;
TBS_LOG
(
"
%
p
got
confirmed
target
APZC
%
p
\
n
"
this
mTargetApzc
.
get
(
)
)
;
if
(
mTargetApzc
=
=
aTargetApzc
)
{
return
true
;
}
TBS_LOG
(
"
%
p
replacing
unconfirmed
target
%
p
with
real
target
%
p
\
n
"
this
mTargetApzc
.
get
(
)
aTargetApzc
.
get
(
)
)
;
UpdateTargetApzc
(
aTargetApzc
)
;
return
true
;
}
void
InputBlockState
:
:
UpdateTargetApzc
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTargetApzc
)
{
mTargetApzc
=
aTargetApzc
;
mTransformToApzc
=
aTargetApzc
?
aTargetApzc
-
>
GetTransformToThis
(
)
:
ScreenToParentLayerMatrix4x4
(
)
;
mOverscrollHandoffChain
=
(
mTargetApzc
?
mTargetApzc
-
>
BuildOverscrollHandoffChain
(
)
:
nullptr
)
;
}
const
RefPtr
<
AsyncPanZoomController
>
&
InputBlockState
:
:
GetTargetApzc
(
)
const
{
return
mTargetApzc
;
}
const
RefPtr
<
const
OverscrollHandoffChain
>
&
InputBlockState
:
:
GetOverscrollHandoffChain
(
)
const
{
return
mOverscrollHandoffChain
;
}
uint64_t
InputBlockState
:
:
GetBlockId
(
)
const
{
return
mBlockId
;
}
bool
InputBlockState
:
:
IsTargetConfirmed
(
)
const
{
return
mTargetConfirmed
!
=
TargetConfirmationState
:
:
eUnconfirmed
;
}
bool
InputBlockState
:
:
HasReceivedRealConfirmedTarget
(
)
const
{
return
mTargetConfirmed
=
=
TargetConfirmationState
:
:
eConfirmed
|
|
mTargetConfirmed
=
=
TargetConfirmationState
:
:
eTimedOutAndMainThreadResponded
;
}
bool
InputBlockState
:
:
ShouldDropEvents
(
)
const
{
return
mRequiresTargetConfirmation
&
&
(
mTargetConfirmed
!
=
TargetConfirmationState
:
:
eConfirmed
)
;
}
bool
InputBlockState
:
:
IsDownchainOf
(
AsyncPanZoomController
*
aA
AsyncPanZoomController
*
aB
)
const
{
if
(
aA
=
=
aB
)
{
return
true
;
}
bool
seenA
=
false
;
for
(
size_t
i
=
0
;
i
<
mOverscrollHandoffChain
-
>
Length
(
)
;
+
+
i
)
{
AsyncPanZoomController
*
apzc
=
mOverscrollHandoffChain
-
>
GetApzcAtIndex
(
i
)
;
if
(
apzc
=
=
aB
)
{
return
seenA
;
}
if
(
apzc
=
=
aA
)
{
seenA
=
true
;
}
}
return
false
;
}
void
InputBlockState
:
:
SetScrolledApzc
(
AsyncPanZoomController
*
aApzc
)
{
MOZ_ASSERT
(
!
mScrolledApzc
|
|
(
StaticPrefs
:
:
apz_allow_immediate_handoff
(
)
?
IsDownchainOf
(
mScrolledApzc
aApzc
)
:
mScrolledApzc
=
=
aApzc
)
)
;
mScrolledApzc
=
aApzc
;
}
AsyncPanZoomController
*
InputBlockState
:
:
GetScrolledApzc
(
)
const
{
return
mScrolledApzc
;
}
bool
InputBlockState
:
:
IsDownchainOfScrolledApzc
(
AsyncPanZoomController
*
aApzc
)
const
{
MOZ_ASSERT
(
aApzc
&
&
mScrolledApzc
)
;
return
IsDownchainOf
(
mScrolledApzc
aApzc
)
;
}
void
InputBlockState
:
:
DispatchEvent
(
const
InputData
&
aEvent
)
const
{
GetTargetApzc
(
)
-
>
HandleInputEvent
(
aEvent
mTransformToApzc
)
;
}
CancelableBlockState
:
:
CancelableBlockState
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTargetApzc
TargetConfirmationFlags
aFlags
)
:
InputBlockState
(
aTargetApzc
aFlags
)
mPreventDefault
(
false
)
mContentResponded
(
false
)
mContentResponseTimerExpired
(
false
)
{
}
bool
CancelableBlockState
:
:
SetContentResponse
(
bool
aPreventDefault
)
{
if
(
mContentResponded
)
{
return
false
;
}
TBS_LOG
(
"
%
p
got
content
response
%
d
with
timer
expired
%
d
\
n
"
this
aPreventDefault
mContentResponseTimerExpired
)
;
mPreventDefault
=
aPreventDefault
;
mContentResponded
=
true
;
return
true
;
}
void
CancelableBlockState
:
:
StartContentResponseTimer
(
)
{
MOZ_ASSERT
(
mContentResponseTimer
.
IsNull
(
)
)
;
mContentResponseTimer
=
TimeStamp
:
:
Now
(
)
;
}
bool
CancelableBlockState
:
:
TimeoutContentResponse
(
)
{
if
(
mContentResponseTimerExpired
)
{
return
false
;
}
TBS_LOG
(
"
%
p
got
content
timer
expired
with
response
received
%
d
\
n
"
this
mContentResponded
)
;
if
(
!
mContentResponded
)
{
mPreventDefault
=
false
;
}
mContentResponseTimerExpired
=
true
;
return
true
;
}
bool
CancelableBlockState
:
:
IsContentResponseTimerExpired
(
)
const
{
return
mContentResponseTimerExpired
;
}
bool
CancelableBlockState
:
:
IsDefaultPrevented
(
)
const
{
MOZ_ASSERT
(
mContentResponded
|
|
mContentResponseTimerExpired
)
;
return
mPreventDefault
;
}
bool
CancelableBlockState
:
:
HasReceivedAllContentNotifications
(
)
const
{
return
HasReceivedRealConfirmedTarget
(
)
&
&
mContentResponded
;
}
bool
CancelableBlockState
:
:
IsReadyForHandling
(
)
const
{
if
(
!
IsTargetConfirmed
(
)
)
{
return
false
;
}
return
mContentResponded
|
|
mContentResponseTimerExpired
;
}
bool
CancelableBlockState
:
:
ShouldDropEvents
(
)
const
{
return
InputBlockState
:
:
ShouldDropEvents
(
)
|
|
IsDefaultPrevented
(
)
;
}
void
CancelableBlockState
:
:
RecordContentResponseTime
(
)
{
if
(
!
mContentResponseTimer
)
{
return
;
}
if
(
!
HasReceivedAllContentNotifications
(
)
)
{
return
;
}
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
CONTENT_RESPONSE_DURATION
(
uint32_t
)
(
TimeStamp
:
:
Now
(
)
-
mContentResponseTimer
)
.
ToMilliseconds
(
)
)
;
mContentResponseTimer
=
TimeStamp
(
)
;
}
DragBlockState
:
:
DragBlockState
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTargetApzc
TargetConfirmationFlags
aFlags
const
MouseInput
&
aInitialEvent
)
:
CancelableBlockState
(
aTargetApzc
aFlags
)
mReceivedMouseUp
(
false
)
{
}
bool
DragBlockState
:
:
HasReceivedMouseUp
(
)
{
return
mReceivedMouseUp
;
}
void
DragBlockState
:
:
MarkMouseUpReceived
(
)
{
mReceivedMouseUp
=
true
;
}
void
DragBlockState
:
:
SetInitialThumbPos
(
CSSCoord
aThumbPos
)
{
mInitialThumbPos
=
aThumbPos
;
}
void
DragBlockState
:
:
SetDragMetrics
(
const
AsyncDragMetrics
&
aDragMetrics
)
{
mDragMetrics
=
aDragMetrics
;
}
void
DragBlockState
:
:
DispatchEvent
(
const
InputData
&
aEvent
)
const
{
MouseInput
mouseInput
=
aEvent
.
AsMouseInput
(
)
;
if
(
!
mouseInput
.
TransformToLocal
(
mTransformToApzc
)
)
{
return
;
}
GetTargetApzc
(
)
-
>
HandleDragEvent
(
mouseInput
mDragMetrics
mInitialThumbPos
)
;
}
bool
DragBlockState
:
:
MustStayActive
(
)
{
return
!
mReceivedMouseUp
;
}
const
char
*
DragBlockState
:
:
Type
(
)
{
return
"
drag
"
;
}
static
uint64_t
sLastWheelBlockId
=
InputBlockState
:
:
NO_BLOCK_ID
;
WheelBlockState
:
:
WheelBlockState
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTargetApzc
TargetConfirmationFlags
aFlags
const
ScrollWheelInput
&
aInitialEvent
)
:
CancelableBlockState
(
aTargetApzc
aFlags
)
mScrollSeriesCounter
(
0
)
mTransactionEnded
(
false
)
{
sLastWheelBlockId
=
GetBlockId
(
)
;
if
(
aFlags
.
mTargetConfirmed
)
{
RefPtr
<
AsyncPanZoomController
>
apzc
=
mOverscrollHandoffChain
-
>
FindFirstScrollable
(
aInitialEvent
&
mAllowedScrollDirections
)
;
if
(
!
apzc
)
{
EndTransaction
(
)
;
return
;
}
if
(
apzc
!
=
GetTargetApzc
(
)
)
{
UpdateTargetApzc
(
apzc
)
;
}
}
}
bool
WheelBlockState
:
:
SetContentResponse
(
bool
aPreventDefault
)
{
if
(
aPreventDefault
)
{
EndTransaction
(
)
;
}
return
CancelableBlockState
:
:
SetContentResponse
(
aPreventDefault
)
;
}
bool
WheelBlockState
:
:
SetConfirmedTargetApzc
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTargetApzc
TargetConfirmationState
aState
InputData
*
aFirstInput
bool
aForScrollbarDrag
)
{
RefPtr
<
AsyncPanZoomController
>
apzc
=
aTargetApzc
;
if
(
apzc
&
&
aFirstInput
)
{
apzc
=
apzc
-
>
BuildOverscrollHandoffChain
(
)
-
>
FindFirstScrollable
(
*
aFirstInput
&
mAllowedScrollDirections
)
;
}
InputBlockState
:
:
SetConfirmedTargetApzc
(
apzc
aState
aFirstInput
aForScrollbarDrag
)
;
return
true
;
}
void
WheelBlockState
:
:
Update
(
ScrollWheelInput
&
aEvent
)
{
if
(
!
InTransaction
(
)
)
{
return
;
}
if
(
!
mLastEventTime
.
IsNull
(
)
&
&
(
aEvent
.
mTimeStamp
-
mLastEventTime
)
.
ToMilliseconds
(
)
>
kScrollSeriesTimeoutMs
)
{
mScrollSeriesCounter
=
0
;
}
aEvent
.
mScrollSeriesNumber
=
+
+
mScrollSeriesCounter
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetApzc
(
)
;
if
(
IsTargetConfirmed
(
)
&
&
!
apzc
-
>
CanScroll
(
aEvent
)
)
{
return
;
}
mLastEventTime
=
aEvent
.
mTimeStamp
;
mLastMouseMove
=
TimeStamp
(
)
;
}
bool
WheelBlockState
:
:
MustStayActive
(
)
{
return
!
mTransactionEnded
;
}
const
char
*
WheelBlockState
:
:
Type
(
)
{
return
"
scroll
wheel
"
;
}
bool
WheelBlockState
:
:
ShouldAcceptNewEvent
(
)
const
{
if
(
!
InTransaction
(
)
)
{
return
false
;
}
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetApzc
(
)
;
if
(
apzc
-
>
IsDestroyed
(
)
)
{
return
false
;
}
return
true
;
}
bool
WheelBlockState
:
:
MaybeTimeout
(
const
ScrollWheelInput
&
aEvent
)
{
MOZ_ASSERT
(
InTransaction
(
)
)
;
if
(
MaybeTimeout
(
aEvent
.
mTimeStamp
)
)
{
return
true
;
}
if
(
!
mLastMouseMove
.
IsNull
(
)
)
{
TimeDuration
duration
=
TimeStamp
:
:
Now
(
)
-
mLastMouseMove
;
if
(
duration
.
ToMilliseconds
(
)
>
=
StaticPrefs
:
:
mousewheel_transaction_ignoremovedelay
(
)
)
{
TBS_LOG
(
"
%
p
wheel
transaction
timed
out
after
mouse
move
\
n
"
this
)
;
EndTransaction
(
)
;
return
true
;
}
}
return
false
;
}
bool
WheelBlockState
:
:
MaybeTimeout
(
const
TimeStamp
&
aTimeStamp
)
{
MOZ_ASSERT
(
InTransaction
(
)
)
;
TimeDuration
duration
=
aTimeStamp
-
mLastEventTime
;
if
(
duration
.
ToMilliseconds
(
)
<
StaticPrefs
:
:
mousewheel_transaction_timeout
(
)
)
{
return
false
;
}
TBS_LOG
(
"
%
p
wheel
transaction
timed
out
\
n
"
this
)
;
if
(
StaticPrefs
:
:
MouseScrollTestingEnabled
(
)
)
{
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetApzc
(
)
;
apzc
-
>
NotifyMozMouseScrollEvent
(
NS_LITERAL_STRING
(
"
MozMouseScrollTransactionTimeout
"
)
)
;
}
EndTransaction
(
)
;
return
true
;
}
void
WheelBlockState
:
:
OnMouseMove
(
const
ScreenIntPoint
&
aPoint
)
{
MOZ_ASSERT
(
InTransaction
(
)
)
;
if
(
!
GetTargetApzc
(
)
-
>
Contains
(
aPoint
)
)
{
EndTransaction
(
)
;
return
;
}
if
(
mLastMouseMove
.
IsNull
(
)
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
TimeDuration
duration
=
now
-
mLastEventTime
;
if
(
duration
.
ToMilliseconds
(
)
>
=
StaticPrefs
:
:
mousewheel_transaction_ignoremovedelay
(
)
)
{
mLastMouseMove
=
now
;
}
}
}
void
WheelBlockState
:
:
UpdateTargetApzc
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTargetApzc
)
{
InputBlockState
:
:
UpdateTargetApzc
(
aTargetApzc
)
;
if
(
!
GetTargetApzc
(
)
)
{
EndTransaction
(
)
;
}
}
bool
WheelBlockState
:
:
InTransaction
(
)
const
{
if
(
GetBlockId
(
)
!
=
sLastWheelBlockId
)
{
return
false
;
}
if
(
mTransactionEnded
)
{
return
false
;
}
MOZ_ASSERT
(
GetTargetApzc
(
)
)
;
return
true
;
}
bool
WheelBlockState
:
:
AllowScrollHandoff
(
)
const
{
return
!
IsTargetConfirmed
(
)
|
|
!
InTransaction
(
)
;
}
void
WheelBlockState
:
:
EndTransaction
(
)
{
TBS_LOG
(
"
%
p
ending
wheel
transaction
\
n
"
this
)
;
mTransactionEnded
=
true
;
}
PanGestureBlockState
:
:
PanGestureBlockState
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTargetApzc
TargetConfirmationFlags
aFlags
const
PanGestureInput
&
aInitialEvent
)
:
CancelableBlockState
(
aTargetApzc
aFlags
)
mInterrupted
(
false
)
mWaitingForContentResponse
(
false
)
{
if
(
aFlags
.
mTargetConfirmed
)
{
RefPtr
<
AsyncPanZoomController
>
apzc
=
mOverscrollHandoffChain
-
>
FindFirstScrollable
(
aInitialEvent
&
mAllowedScrollDirections
)
;
if
(
apzc
&
&
apzc
!
=
GetTargetApzc
(
)
)
{
UpdateTargetApzc
(
apzc
)
;
}
}
}
bool
PanGestureBlockState
:
:
SetConfirmedTargetApzc
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTargetApzc
TargetConfirmationState
aState
InputData
*
aFirstInput
bool
aForScrollbarDrag
)
{
RefPtr
<
AsyncPanZoomController
>
apzc
=
aTargetApzc
;
if
(
apzc
&
&
aFirstInput
)
{
RefPtr
<
AsyncPanZoomController
>
scrollableApzc
=
apzc
-
>
BuildOverscrollHandoffChain
(
)
-
>
FindFirstScrollable
(
*
aFirstInput
&
mAllowedScrollDirections
)
;
if
(
scrollableApzc
)
{
apzc
=
scrollableApzc
;
}
}
InputBlockState
:
:
SetConfirmedTargetApzc
(
apzc
aState
aFirstInput
aForScrollbarDrag
)
;
return
true
;
}
bool
PanGestureBlockState
:
:
MustStayActive
(
)
{
return
!
mInterrupted
;
}
const
char
*
PanGestureBlockState
:
:
Type
(
)
{
return
"
pan
gesture
"
;
}
bool
PanGestureBlockState
:
:
SetContentResponse
(
bool
aPreventDefault
)
{
if
(
aPreventDefault
)
{
TBS_LOG
(
"
%
p
setting
interrupted
flag
\
n
"
this
)
;
mInterrupted
=
true
;
}
bool
stateChanged
=
CancelableBlockState
:
:
SetContentResponse
(
aPreventDefault
)
;
if
(
mWaitingForContentResponse
)
{
mWaitingForContentResponse
=
false
;
stateChanged
=
true
;
}
return
stateChanged
;
}
bool
PanGestureBlockState
:
:
HasReceivedAllContentNotifications
(
)
const
{
return
CancelableBlockState
:
:
HasReceivedAllContentNotifications
(
)
&
&
!
mWaitingForContentResponse
;
}
bool
PanGestureBlockState
:
:
IsReadyForHandling
(
)
const
{
if
(
!
CancelableBlockState
:
:
IsReadyForHandling
(
)
)
{
return
false
;
}
return
!
mWaitingForContentResponse
|
|
IsContentResponseTimerExpired
(
)
;
}
bool
PanGestureBlockState
:
:
AllowScrollHandoff
(
)
const
{
return
false
;
}
void
PanGestureBlockState
:
:
SetNeedsToWaitForContentResponse
(
bool
aWaitForContentResponse
)
{
mWaitingForContentResponse
=
aWaitForContentResponse
;
}
TouchBlockState
:
:
TouchBlockState
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTargetApzc
TargetConfirmationFlags
aFlags
TouchCounter
&
aCounter
)
:
CancelableBlockState
(
aTargetApzc
aFlags
)
mAllowedTouchBehaviorSet
(
false
)
mDuringFastFling
(
false
)
mSingleTapOccurred
(
false
)
mInSlop
(
false
)
mTouchCounter
(
aCounter
)
{
TBS_LOG
(
"
Creating
%
p
\
n
"
this
)
;
if
(
!
StaticPrefs
:
:
layout_css_touch_action_enabled
(
)
)
{
mAllowedTouchBehaviorSet
=
true
;
}
}
bool
TouchBlockState
:
:
SetAllowedTouchBehaviors
(
const
nsTArray
<
TouchBehaviorFlags
>
&
aBehaviors
)
{
if
(
mAllowedTouchBehaviorSet
)
{
return
false
;
}
TBS_LOG
(
"
%
p
got
allowed
touch
behaviours
for
%
zu
points
\
n
"
this
aBehaviors
.
Length
(
)
)
;
mAllowedTouchBehaviors
.
AppendElements
(
aBehaviors
)
;
mAllowedTouchBehaviorSet
=
true
;
return
true
;
}
bool
TouchBlockState
:
:
GetAllowedTouchBehaviors
(
nsTArray
<
TouchBehaviorFlags
>
&
aOutBehaviors
)
const
{
if
(
!
mAllowedTouchBehaviorSet
)
{
return
false
;
}
aOutBehaviors
.
AppendElements
(
mAllowedTouchBehaviors
)
;
return
true
;
}
bool
TouchBlockState
:
:
HasAllowedTouchBehaviors
(
)
const
{
return
mAllowedTouchBehaviorSet
;
}
void
TouchBlockState
:
:
CopyPropertiesFrom
(
const
TouchBlockState
&
aOther
)
{
TBS_LOG
(
"
%
p
copying
properties
from
%
p
\
n
"
this
&
aOther
)
;
if
(
StaticPrefs
:
:
layout_css_touch_action_enabled
(
)
)
{
MOZ_ASSERT
(
aOther
.
mAllowedTouchBehaviorSet
|
|
aOther
.
IsContentResponseTimerExpired
(
)
)
;
SetAllowedTouchBehaviors
(
aOther
.
mAllowedTouchBehaviors
)
;
}
mTransformToApzc
=
aOther
.
mTransformToApzc
;
}
bool
TouchBlockState
:
:
HasReceivedAllContentNotifications
(
)
const
{
return
CancelableBlockState
:
:
HasReceivedAllContentNotifications
(
)
&
&
(
!
StaticPrefs
:
:
layout_css_touch_action_enabled
(
)
|
|
mAllowedTouchBehaviorSet
)
;
}
bool
TouchBlockState
:
:
IsReadyForHandling
(
)
const
{
if
(
!
CancelableBlockState
:
:
IsReadyForHandling
(
)
)
{
return
false
;
}
if
(
!
StaticPrefs
:
:
layout_css_touch_action_enabled
(
)
)
{
return
true
;
}
return
mAllowedTouchBehaviorSet
|
|
IsContentResponseTimerExpired
(
)
;
}
void
TouchBlockState
:
:
SetDuringFastFling
(
)
{
TBS_LOG
(
"
%
p
setting
fast
-
motion
flag
\
n
"
this
)
;
mDuringFastFling
=
true
;
}
bool
TouchBlockState
:
:
IsDuringFastFling
(
)
const
{
return
mDuringFastFling
;
}
void
TouchBlockState
:
:
SetSingleTapOccurred
(
)
{
TBS_LOG
(
"
%
p
setting
single
-
tap
-
occurred
flag
\
n
"
this
)
;
mSingleTapOccurred
=
true
;
}
bool
TouchBlockState
:
:
SingleTapOccurred
(
)
const
{
return
mSingleTapOccurred
;
}
bool
TouchBlockState
:
:
MustStayActive
(
)
{
return
true
;
}
const
char
*
TouchBlockState
:
:
Type
(
)
{
return
"
touch
"
;
}
void
TouchBlockState
:
:
DispatchEvent
(
const
InputData
&
aEvent
)
const
{
MOZ_ASSERT
(
aEvent
.
mInputType
=
=
MULTITOUCH_INPUT
)
;
mTouchCounter
.
Update
(
aEvent
.
AsMultiTouchInput
(
)
)
;
CancelableBlockState
:
:
DispatchEvent
(
aEvent
)
;
}
bool
TouchBlockState
:
:
TouchActionAllowsPinchZoom
(
)
const
{
if
(
!
StaticPrefs
:
:
layout_css_touch_action_enabled
(
)
)
{
return
true
;
}
for
(
size_t
i
=
0
;
i
<
mAllowedTouchBehaviors
.
Length
(
)
;
i
+
+
)
{
if
(
!
(
mAllowedTouchBehaviors
[
i
]
&
AllowedTouchBehavior
:
:
PINCH_ZOOM
)
)
{
return
false
;
}
}
return
true
;
}
bool
TouchBlockState
:
:
TouchActionAllowsDoubleTapZoom
(
)
const
{
if
(
!
StaticPrefs
:
:
layout_css_touch_action_enabled
(
)
)
{
return
true
;
}
for
(
size_t
i
=
0
;
i
<
mAllowedTouchBehaviors
.
Length
(
)
;
i
+
+
)
{
if
(
!
(
mAllowedTouchBehaviors
[
i
]
&
AllowedTouchBehavior
:
:
DOUBLE_TAP_ZOOM
)
)
{
return
false
;
}
}
return
true
;
}
bool
TouchBlockState
:
:
TouchActionAllowsPanningX
(
)
const
{
if
(
!
StaticPrefs
:
:
layout_css_touch_action_enabled
(
)
)
{
return
true
;
}
if
(
mAllowedTouchBehaviors
.
IsEmpty
(
)
)
{
return
true
;
}
TouchBehaviorFlags
flags
=
mAllowedTouchBehaviors
[
0
]
;
return
(
flags
&
AllowedTouchBehavior
:
:
HORIZONTAL_PAN
)
;
}
bool
TouchBlockState
:
:
TouchActionAllowsPanningY
(
)
const
{
if
(
!
StaticPrefs
:
:
layout_css_touch_action_enabled
(
)
)
{
return
true
;
}
if
(
mAllowedTouchBehaviors
.
IsEmpty
(
)
)
{
return
true
;
}
TouchBehaviorFlags
flags
=
mAllowedTouchBehaviors
[
0
]
;
return
(
flags
&
AllowedTouchBehavior
:
:
VERTICAL_PAN
)
;
}
bool
TouchBlockState
:
:
TouchActionAllowsPanningXY
(
)
const
{
if
(
!
StaticPrefs
:
:
layout_css_touch_action_enabled
(
)
)
{
return
true
;
}
if
(
mAllowedTouchBehaviors
.
IsEmpty
(
)
)
{
return
true
;
}
TouchBehaviorFlags
flags
=
mAllowedTouchBehaviors
[
0
]
;
return
(
flags
&
AllowedTouchBehavior
:
:
HORIZONTAL_PAN
)
&
&
(
flags
&
AllowedTouchBehavior
:
:
VERTICAL_PAN
)
;
}
bool
TouchBlockState
:
:
UpdateSlopState
(
const
MultiTouchInput
&
aInput
bool
aApzcCanConsumeEvents
)
{
if
(
aInput
.
mType
=
=
MultiTouchInput
:
:
MULTITOUCH_START
)
{
mInSlop
=
(
aInput
.
mTouches
.
Length
(
)
=
=
1
)
;
if
(
mInSlop
)
{
mSlopOrigin
=
aInput
.
mTouches
[
0
]
.
mScreenPoint
;
TBS_LOG
(
"
%
p
entering
slop
with
origin
%
s
\
n
"
this
Stringify
(
mSlopOrigin
)
.
c_str
(
)
)
;
}
return
false
;
}
if
(
mInSlop
)
{
ScreenCoord
threshold
=
0
;
if
(
const
RefPtr
<
AsyncPanZoomController
>
&
apzc
=
GetTargetApzc
(
)
)
{
threshold
=
aApzcCanConsumeEvents
?
apzc
-
>
GetTouchStartTolerance
(
)
:
apzc
-
>
GetTouchMoveTolerance
(
)
;
}
bool
stayInSlop
=
(
aInput
.
mType
=
=
MultiTouchInput
:
:
MULTITOUCH_MOVE
)
&
&
(
aInput
.
mTouches
.
Length
(
)
=
=
1
)
&
&
(
(
aInput
.
mTouches
[
0
]
.
mScreenPoint
-
mSlopOrigin
)
.
Length
(
)
<
threshold
)
;
if
(
!
stayInSlop
)
{
TBS_LOG
(
"
%
p
exiting
slop
\
n
"
this
)
;
mInSlop
=
false
;
}
}
return
mInSlop
;
}
Maybe
<
ScrollDirection
>
TouchBlockState
:
:
GetBestGuessPanDirection
(
const
MultiTouchInput
&
aInput
)
{
if
(
aInput
.
mType
!
=
MultiTouchInput
:
:
MULTITOUCH_MOVE
|
|
aInput
.
mTouches
.
Length
(
)
!
=
1
)
{
return
Nothing
(
)
;
}
ScreenPoint
vector
=
aInput
.
mTouches
[
0
]
.
mScreenPoint
-
mSlopOrigin
;
double
angle
=
atan2
(
vector
.
y
vector
.
x
)
;
angle
=
fabs
(
angle
)
;
double
angleThreshold
=
TouchActionAllowsPanningXY
(
)
?
StaticPrefs
:
:
apz_axis_lock_lock_angle
(
)
:
StaticPrefs
:
:
apz_axis_lock_direct_pan_angle
(
)
;
if
(
apz
:
:
IsCloseToHorizontal
(
angle
angleThreshold
)
)
{
return
Some
(
ScrollDirection
:
:
eHorizontal
)
;
}
if
(
apz
:
:
IsCloseToVertical
(
angle
angleThreshold
)
)
{
return
Some
(
ScrollDirection
:
:
eVertical
)
;
}
return
Nothing
(
)
;
}
uint32_t
TouchBlockState
:
:
GetActiveTouchCount
(
)
const
{
return
mTouchCounter
.
GetActiveTouchCount
(
)
;
}
KeyboardBlockState
:
:
KeyboardBlockState
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTargetApzc
)
:
InputBlockState
(
aTargetApzc
TargetConfirmationFlags
{
true
}
)
{
}
}
}
