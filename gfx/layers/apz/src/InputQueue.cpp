#
include
"
InputQueue
.
h
"
#
include
"
AsyncPanZoomController
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
InputBlockState
.
h
"
#
include
"
LayersLogging
.
h
"
#
include
"
mozilla
/
layers
/
APZThreadUtils
.
h
"
#
include
"
OverscrollHandoffState
.
h
"
#
include
"
QueuedInput
.
h
"
#
define
INPQ_LOG
(
.
.
.
)
namespace
mozilla
{
namespace
layers
{
InputQueue
:
:
InputQueue
(
)
{
}
InputQueue
:
:
~
InputQueue
(
)
{
mInputBlockQueue
.
Clear
(
)
;
mQueuedInputs
.
Clear
(
)
;
}
nsEventStatus
InputQueue
:
:
ReceiveInputEvent
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTarget
bool
aTargetConfirmed
const
InputData
&
aEvent
uint64_t
*
aOutInputBlockId
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
switch
(
aEvent
.
mInputType
)
{
case
MULTITOUCH_INPUT
:
{
const
MultiTouchInput
&
event
=
aEvent
.
AsMultiTouchInput
(
)
;
return
ReceiveTouchInput
(
aTarget
aTargetConfirmed
event
aOutInputBlockId
)
;
}
case
SCROLLWHEEL_INPUT
:
{
const
ScrollWheelInput
&
event
=
aEvent
.
AsScrollWheelInput
(
)
;
return
ReceiveScrollWheelInput
(
aTarget
aTargetConfirmed
event
aOutInputBlockId
)
;
}
case
PANGESTURE_INPUT
:
{
const
PanGestureInput
&
event
=
aEvent
.
AsPanGestureInput
(
)
;
return
ReceivePanGestureInput
(
aTarget
aTargetConfirmed
event
aOutInputBlockId
)
;
}
case
MOUSE_INPUT
:
{
const
MouseInput
&
event
=
aEvent
.
AsMouseInput
(
)
;
return
ReceiveMouseInput
(
aTarget
aTargetConfirmed
event
aOutInputBlockId
)
;
}
default
:
return
aTarget
-
>
HandleInputEvent
(
aEvent
aTarget
-
>
GetTransformToThis
(
)
)
;
}
}
bool
InputQueue
:
:
MaybeHandleCurrentBlock
(
CancelableBlockState
*
block
const
InputData
&
aEvent
)
{
if
(
block
=
=
CurrentBlock
(
)
&
&
block
-
>
IsReadyForHandling
(
)
)
{
const
RefPtr
<
AsyncPanZoomController
>
&
target
=
block
-
>
GetTargetApzc
(
)
;
INPQ_LOG
(
"
current
block
is
ready
with
target
%
p
preventdefault
%
d
\
n
"
target
.
get
(
)
block
-
>
IsDefaultPrevented
(
)
)
;
if
(
!
target
|
|
block
-
>
IsDefaultPrevented
(
)
)
{
return
true
;
}
UpdateActiveApzc
(
block
-
>
GetTargetApzc
(
)
)
;
block
-
>
DispatchImmediate
(
aEvent
)
;
return
true
;
}
return
false
;
}
nsEventStatus
InputQueue
:
:
ReceiveTouchInput
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTarget
bool
aTargetConfirmed
const
MultiTouchInput
&
aEvent
uint64_t
*
aOutInputBlockId
)
{
TouchBlockState
*
block
=
nullptr
;
if
(
aEvent
.
mType
=
=
MultiTouchInput
:
:
MULTITOUCH_START
)
{
nsTArray
<
TouchBehaviorFlags
>
currentBehaviors
;
bool
haveBehaviors
=
false
;
if
(
!
gfxPrefs
:
:
TouchActionEnabled
(
)
)
{
haveBehaviors
=
true
;
}
else
if
(
mActiveTouchBlock
)
{
haveBehaviors
=
mActiveTouchBlock
-
>
GetAllowedTouchBehaviors
(
currentBehaviors
)
;
haveBehaviors
|
=
mActiveTouchBlock
-
>
IsContentResponseTimerExpired
(
)
;
}
block
=
StartNewTouchBlock
(
aTarget
aTargetConfirmed
false
)
;
INPQ_LOG
(
"
started
new
touch
block
%
p
id
%
"
PRIu64
"
for
target
%
p
\
n
"
block
block
-
>
GetBlockId
(
)
aTarget
.
get
(
)
)
;
if
(
block
=
=
CurrentBlock
(
)
&
&
aEvent
.
mTouches
.
Length
(
)
=
=
1
&
&
block
-
>
GetOverscrollHandoffChain
(
)
-
>
HasFastFlungApzc
(
)
&
&
haveBehaviors
)
{
block
-
>
SetDuringFastFling
(
)
;
block
-
>
SetConfirmedTargetApzc
(
aTarget
InputBlockState
:
:
TargetConfirmationState
:
:
eConfirmed
)
;
if
(
gfxPrefs
:
:
TouchActionEnabled
(
)
)
{
block
-
>
SetAllowedTouchBehaviors
(
currentBehaviors
)
;
}
INPQ_LOG
(
"
block
%
p
tagged
as
fast
-
motion
\
n
"
block
)
;
}
CancelAnimationsForNewBlock
(
block
)
;
MaybeRequestContentResponse
(
aTarget
block
)
;
}
else
{
block
=
mActiveTouchBlock
.
get
(
)
;
if
(
!
block
)
{
NS_WARNING
(
"
Received
a
non
-
start
touch
event
while
no
touch
blocks
active
!
"
)
;
return
nsEventStatus_eIgnore
;
}
INPQ_LOG
(
"
received
new
event
in
block
%
p
\
n
"
block
)
;
}
if
(
aOutInputBlockId
)
{
*
aOutInputBlockId
=
block
-
>
GetBlockId
(
)
;
}
RefPtr
<
AsyncPanZoomController
>
target
=
block
-
>
GetTargetApzc
(
)
;
nsEventStatus
result
=
nsEventStatus_eIgnore
;
if
(
block
-
>
IsDuringFastFling
(
)
)
{
INPQ_LOG
(
"
dropping
event
due
to
block
%
p
being
in
fast
motion
\
n
"
block
)
;
result
=
nsEventStatus_eConsumeNoDefault
;
}
else
if
(
target
&
&
target
-
>
ArePointerEventsConsumable
(
block
aEvent
.
AsMultiTouchInput
(
)
.
mTouches
.
Length
(
)
)
)
{
if
(
block
-
>
UpdateSlopState
(
aEvent
.
AsMultiTouchInput
(
)
true
)
)
{
INPQ_LOG
(
"
dropping
event
due
to
block
%
p
being
in
slop
\
n
"
block
)
;
result
=
nsEventStatus_eConsumeNoDefault
;
}
else
{
result
=
nsEventStatus_eConsumeDoDefault
;
}
}
else
if
(
block
-
>
UpdateSlopState
(
aEvent
.
AsMultiTouchInput
(
)
false
)
)
{
INPQ_LOG
(
"
dropping
event
due
to
block
%
p
being
in
mini
-
slop
\
n
"
block
)
;
result
=
nsEventStatus_eConsumeNoDefault
;
}
if
(
!
MaybeHandleCurrentBlock
(
block
aEvent
)
)
{
block
-
>
AddEvent
(
aEvent
.
AsMultiTouchInput
(
)
)
;
mQueuedInputs
.
AppendElement
(
MakeUnique
<
QueuedInput
>
(
aEvent
.
AsMultiTouchInput
(
)
*
block
)
)
;
}
return
result
;
}
nsEventStatus
InputQueue
:
:
ReceiveMouseInput
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTarget
bool
aTargetConfirmed
const
MouseInput
&
aEvent
uint64_t
*
aOutInputBlockId
)
{
bool
newBlock
=
DragTracker
:
:
StartsDrag
(
aEvent
)
;
DragBlockState
*
block
=
newBlock
?
nullptr
:
mActiveDragBlock
.
get
(
)
;
if
(
block
&
&
block
-
>
HasReceivedMouseUp
(
)
)
{
block
=
nullptr
;
}
if
(
!
block
&
&
mDragTracker
.
InDrag
(
)
)
{
INPQ_LOG
(
"
got
a
drag
event
outside
a
drag
block
need
to
create
a
block
to
hold
it
\
n
"
)
;
newBlock
=
true
;
}
mDragTracker
.
Update
(
aEvent
)
;
if
(
!
newBlock
&
&
!
block
)
{
return
nsEventStatus_eIgnore
;
}
if
(
!
block
)
{
MOZ_ASSERT
(
newBlock
)
;
block
=
new
DragBlockState
(
aTarget
aTargetConfirmed
aEvent
)
;
INPQ_LOG
(
"
started
new
drag
block
%
p
id
%
"
PRIu64
"
for
%
sconfirmed
target
%
p
\
n
"
block
block
-
>
GetBlockId
(
)
aTargetConfirmed
?
"
"
:
"
un
"
aTarget
.
get
(
)
)
;
SweepDepletedBlocks
(
)
;
mInputBlockQueue
.
AppendElement
(
block
)
;
mActiveDragBlock
=
block
;
CancelAnimationsForNewBlock
(
block
)
;
MaybeRequestContentResponse
(
aTarget
block
)
;
}
if
(
aOutInputBlockId
)
{
*
aOutInputBlockId
=
block
-
>
GetBlockId
(
)
;
}
if
(
!
MaybeHandleCurrentBlock
(
block
aEvent
)
)
{
block
-
>
AddEvent
(
aEvent
.
AsMouseInput
(
)
)
;
mQueuedInputs
.
AppendElement
(
MakeUnique
<
QueuedInput
>
(
aEvent
.
AsMouseInput
(
)
*
block
)
)
;
}
if
(
DragTracker
:
:
EndsDrag
(
aEvent
)
)
{
block
-
>
MarkMouseUpReceived
(
)
;
}
return
nsEventStatus_eConsumeDoDefault
;
}
nsEventStatus
InputQueue
:
:
ReceiveScrollWheelInput
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTarget
bool
aTargetConfirmed
const
ScrollWheelInput
&
aEvent
uint64_t
*
aOutInputBlockId
)
{
WheelBlockState
*
block
=
mActiveWheelBlock
.
get
(
)
;
if
(
block
&
&
(
!
block
-
>
ShouldAcceptNewEvent
(
)
|
|
block
-
>
MaybeTimeout
(
aEvent
)
)
)
{
block
=
nullptr
;
}
MOZ_ASSERT
(
!
block
|
|
block
-
>
InTransaction
(
)
)
;
if
(
!
block
)
{
block
=
new
WheelBlockState
(
aTarget
aTargetConfirmed
aEvent
)
;
INPQ_LOG
(
"
started
new
scroll
wheel
block
%
p
id
%
"
PRIu64
"
for
target
%
p
\
n
"
block
block
-
>
GetBlockId
(
)
aTarget
.
get
(
)
)
;
SweepDepletedBlocks
(
)
;
mInputBlockQueue
.
AppendElement
(
block
)
;
mActiveWheelBlock
=
block
;
CancelAnimationsForNewBlock
(
block
)
;
MaybeRequestContentResponse
(
aTarget
block
)
;
}
else
{
INPQ_LOG
(
"
received
new
event
in
block
%
p
\
n
"
block
)
;
}
if
(
aOutInputBlockId
)
{
*
aOutInputBlockId
=
block
-
>
GetBlockId
(
)
;
}
ScrollWheelInput
event
(
aEvent
)
;
block
-
>
Update
(
event
)
;
if
(
!
MaybeHandleCurrentBlock
(
block
event
)
)
{
block
-
>
AddEvent
(
event
)
;
mQueuedInputs
.
AppendElement
(
MakeUnique
<
QueuedInput
>
(
event
*
block
)
)
;
}
return
nsEventStatus_eConsumeDoDefault
;
}
static
bool
CanScrollTargetHorizontally
(
const
PanGestureInput
&
aInitialEvent
PanGestureBlockState
*
aBlock
)
{
PanGestureInput
horizontalComponent
=
aInitialEvent
;
horizontalComponent
.
mPanDisplacement
.
y
=
0
;
RefPtr
<
AsyncPanZoomController
>
horizontallyScrollableAPZC
=
aBlock
-
>
GetOverscrollHandoffChain
(
)
-
>
FindFirstScrollable
(
horizontalComponent
)
;
return
horizontallyScrollableAPZC
&
&
horizontallyScrollableAPZC
=
=
aBlock
-
>
GetTargetApzc
(
)
;
}
nsEventStatus
InputQueue
:
:
ReceivePanGestureInput
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTarget
bool
aTargetConfirmed
const
PanGestureInput
&
aEvent
uint64_t
*
aOutInputBlockId
)
{
if
(
aEvent
.
mType
=
=
PanGestureInput
:
:
PANGESTURE_MAYSTART
|
|
aEvent
.
mType
=
=
PanGestureInput
:
:
PANGESTURE_CANCELLED
)
{
return
nsEventStatus_eConsumeDoDefault
;
}
PanGestureBlockState
*
block
=
nullptr
;
if
(
aEvent
.
mType
!
=
PanGestureInput
:
:
PANGESTURE_START
)
{
block
=
mActivePanGestureBlock
.
get
(
)
;
}
PanGestureInput
event
=
aEvent
;
nsEventStatus
result
=
nsEventStatus_eConsumeDoDefault
;
if
(
!
block
|
|
block
-
>
WasInterrupted
(
)
)
{
if
(
event
.
mType
!
=
PanGestureInput
:
:
PANGESTURE_START
)
{
INPQ_LOG
(
"
transmogrifying
pan
input
%
d
to
PANGESTURE_START
for
new
block
\
n
"
event
.
mType
)
;
event
.
mType
=
PanGestureInput
:
:
PANGESTURE_START
;
}
block
=
new
PanGestureBlockState
(
aTarget
aTargetConfirmed
event
)
;
INPQ_LOG
(
"
started
new
pan
gesture
block
%
p
id
%
"
PRIu64
"
for
target
%
p
\
n
"
block
block
-
>
GetBlockId
(
)
aTarget
.
get
(
)
)
;
if
(
aTargetConfirmed
&
&
event
.
mRequiresContentResponseIfCannotScrollHorizontallyInStartDirection
&
&
!
CanScrollTargetHorizontally
(
event
block
)
)
{
block
-
>
SetNeedsToWaitForContentResponse
(
true
)
;
result
=
nsEventStatus_eIgnore
;
}
SweepDepletedBlocks
(
)
;
mInputBlockQueue
.
AppendElement
(
block
)
;
mActivePanGestureBlock
=
block
;
CancelAnimationsForNewBlock
(
block
)
;
MaybeRequestContentResponse
(
aTarget
block
)
;
}
else
{
INPQ_LOG
(
"
received
new
event
in
block
%
p
\
n
"
block
)
;
}
if
(
aOutInputBlockId
)
{
*
aOutInputBlockId
=
block
-
>
GetBlockId
(
)
;
}
if
(
!
MaybeHandleCurrentBlock
(
block
event
)
)
{
block
-
>
AddEvent
(
event
.
AsPanGestureInput
(
)
)
;
mQueuedInputs
.
AppendElement
(
MakeUnique
<
QueuedInput
>
(
event
.
AsPanGestureInput
(
)
*
block
)
)
;
}
return
result
;
}
void
InputQueue
:
:
CancelAnimationsForNewBlock
(
CancelableBlockState
*
aBlock
)
{
if
(
aBlock
=
=
CurrentBlock
(
)
)
{
aBlock
-
>
GetOverscrollHandoffChain
(
)
-
>
CancelAnimations
(
ExcludeOverscroll
|
ScrollSnap
)
;
}
}
void
InputQueue
:
:
MaybeRequestContentResponse
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTarget
CancelableBlockState
*
aBlock
)
{
bool
waitForMainThread
=
false
;
if
(
aBlock
-
>
IsTargetConfirmed
(
)
)
{
INPQ_LOG
(
"
not
waiting
for
content
response
on
block
%
p
\
n
"
aBlock
)
;
aBlock
-
>
SetContentResponse
(
false
)
;
}
else
{
waitForMainThread
=
true
;
}
if
(
aBlock
-
>
AsTouchBlock
(
)
&
&
gfxPrefs
:
:
TouchActionEnabled
(
)
)
{
INPQ_LOG
(
"
waiting
for
main
thread
touch
-
action
info
on
block
%
p
\
n
"
aBlock
)
;
waitForMainThread
=
true
;
}
if
(
waitForMainThread
)
{
ScheduleMainThreadTimeout
(
aTarget
aBlock
)
;
}
}
uint64_t
InputQueue
:
:
InjectNewTouchBlock
(
AsyncPanZoomController
*
aTarget
)
{
TouchBlockState
*
block
=
StartNewTouchBlock
(
aTarget
true
true
)
;
INPQ_LOG
(
"
injecting
new
touch
block
%
p
with
id
%
"
PRIu64
"
and
target
%
p
\
n
"
block
block
-
>
GetBlockId
(
)
aTarget
)
;
ScheduleMainThreadTimeout
(
aTarget
block
)
;
return
block
-
>
GetBlockId
(
)
;
}
void
InputQueue
:
:
SweepDepletedBlocks
(
)
{
while
(
!
mInputBlockQueue
.
IsEmpty
(
)
)
{
CancelableBlockState
*
block
=
mInputBlockQueue
[
0
]
.
get
(
)
;
if
(
!
block
-
>
IsReadyForHandling
(
)
|
|
block
-
>
HasEvents
(
)
)
{
break
;
}
INPQ_LOG
(
"
discarding
depleted
%
s
block
%
p
\
n
"
block
-
>
Type
(
)
block
)
;
ClearActiveBlock
(
block
)
;
mInputBlockQueue
.
RemoveElementAt
(
0
)
;
}
}
TouchBlockState
*
InputQueue
:
:
StartNewTouchBlock
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTarget
bool
aTargetConfirmed
bool
aCopyPropertiesFromCurrent
)
{
TouchBlockState
*
newBlock
=
new
TouchBlockState
(
aTarget
aTargetConfirmed
mTouchCounter
)
;
if
(
aCopyPropertiesFromCurrent
)
{
newBlock
-
>
CopyPropertiesFrom
(
*
CurrentTouchBlock
(
)
)
;
}
SweepDepletedBlocks
(
)
;
mInputBlockQueue
.
AppendElement
(
newBlock
)
;
mActiveTouchBlock
=
newBlock
;
return
newBlock
;
}
CancelableBlockState
*
InputQueue
:
:
CurrentBlock
(
)
const
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
MOZ_ASSERT
(
!
mInputBlockQueue
.
IsEmpty
(
)
)
;
return
mInputBlockQueue
[
0
]
.
get
(
)
;
}
TouchBlockState
*
InputQueue
:
:
CurrentTouchBlock
(
)
const
{
TouchBlockState
*
block
=
CurrentBlock
(
)
-
>
AsTouchBlock
(
)
;
MOZ_ASSERT
(
block
)
;
return
block
;
}
WheelBlockState
*
InputQueue
:
:
CurrentWheelBlock
(
)
const
{
WheelBlockState
*
block
=
CurrentBlock
(
)
-
>
AsWheelBlock
(
)
;
MOZ_ASSERT
(
block
)
;
return
block
;
}
DragBlockState
*
InputQueue
:
:
CurrentDragBlock
(
)
const
{
DragBlockState
*
block
=
CurrentBlock
(
)
-
>
AsDragBlock
(
)
;
MOZ_ASSERT
(
block
)
;
return
block
;
}
PanGestureBlockState
*
InputQueue
:
:
CurrentPanGestureBlock
(
)
const
{
PanGestureBlockState
*
block
=
CurrentBlock
(
)
-
>
AsPanGestureBlock
(
)
;
MOZ_ASSERT
(
block
)
;
return
block
;
}
WheelBlockState
*
InputQueue
:
:
GetCurrentWheelTransaction
(
)
const
{
WheelBlockState
*
block
=
mActiveWheelBlock
.
get
(
)
;
if
(
!
block
|
|
!
block
-
>
InTransaction
(
)
)
{
return
nullptr
;
}
return
block
;
}
bool
InputQueue
:
:
HasReadyTouchBlock
(
)
const
{
return
!
mInputBlockQueue
.
IsEmpty
(
)
&
&
mInputBlockQueue
[
0
]
-
>
AsTouchBlock
(
)
&
&
mInputBlockQueue
[
0
]
-
>
IsReadyForHandling
(
)
;
}
bool
InputQueue
:
:
AllowScrollHandoff
(
)
const
{
MOZ_ASSERT
(
CurrentBlock
(
)
)
;
if
(
CurrentBlock
(
)
-
>
AsWheelBlock
(
)
)
{
return
CurrentBlock
(
)
-
>
AsWheelBlock
(
)
-
>
AllowScrollHandoff
(
)
;
}
if
(
CurrentBlock
(
)
-
>
AsPanGestureBlock
(
)
)
{
return
CurrentBlock
(
)
-
>
AsPanGestureBlock
(
)
-
>
AllowScrollHandoff
(
)
;
}
return
true
;
}
bool
InputQueue
:
:
IsDragOnScrollbar
(
bool
aHitScrollbar
)
{
if
(
!
mDragTracker
.
InDrag
(
)
)
{
return
false
;
}
return
mDragTracker
.
IsOnScrollbar
(
aHitScrollbar
)
;
}
void
InputQueue
:
:
ScheduleMainThreadTimeout
(
const
RefPtr
<
AsyncPanZoomController
>
&
aTarget
CancelableBlockState
*
aBlock
)
{
INPQ_LOG
(
"
scheduling
main
thread
timeout
for
target
%
p
\
n
"
aTarget
.
get
(
)
)
;
aBlock
-
>
StartContentResponseTimer
(
)
;
aTarget
-
>
PostDelayedTask
(
NewRunnableMethod
<
uint64_t
>
(
this
&
InputQueue
:
:
MainThreadTimeout
aBlock
-
>
GetBlockId
(
)
)
gfxPrefs
:
:
APZContentResponseTimeout
(
)
)
;
}
void
InputQueue
:
:
MainThreadTimeout
(
const
uint64_t
&
aInputBlockId
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
INPQ_LOG
(
"
got
a
main
thread
timeout
;
block
=
%
"
PRIu64
"
\
n
"
aInputBlockId
)
;
bool
success
=
false
;
for
(
size_t
i
=
0
;
i
<
mInputBlockQueue
.
Length
(
)
;
i
+
+
)
{
if
(
mInputBlockQueue
[
i
]
-
>
GetBlockId
(
)
=
=
aInputBlockId
)
{
success
=
mInputBlockQueue
[
i
]
-
>
TimeoutContentResponse
(
)
;
success
|
=
mInputBlockQueue
[
i
]
-
>
SetConfirmedTargetApzc
(
mInputBlockQueue
[
i
]
-
>
GetTargetApzc
(
)
InputBlockState
:
:
TargetConfirmationState
:
:
eTimedOut
)
;
break
;
}
}
if
(
success
)
{
ProcessInputBlocks
(
)
;
}
}
void
InputQueue
:
:
ContentReceivedInputBlock
(
uint64_t
aInputBlockId
bool
aPreventDefault
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
INPQ_LOG
(
"
got
a
content
response
;
block
=
%
"
PRIu64
"
\
n
"
aInputBlockId
)
;
bool
success
=
false
;
for
(
size_t
i
=
0
;
i
<
mInputBlockQueue
.
Length
(
)
;
i
+
+
)
{
CancelableBlockState
*
block
=
mInputBlockQueue
[
i
]
.
get
(
)
;
if
(
block
-
>
GetBlockId
(
)
=
=
aInputBlockId
)
{
success
=
block
-
>
SetContentResponse
(
aPreventDefault
)
;
block
-
>
RecordContentResponseTime
(
)
;
break
;
}
}
if
(
success
)
{
ProcessInputBlocks
(
)
;
}
}
void
InputQueue
:
:
SetConfirmedTargetApzc
(
uint64_t
aInputBlockId
const
RefPtr
<
AsyncPanZoomController
>
&
aTargetApzc
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
INPQ_LOG
(
"
got
a
target
apzc
;
block
=
%
"
PRIu64
"
guid
=
%
s
\
n
"
aInputBlockId
aTargetApzc
?
Stringify
(
aTargetApzc
-
>
GetGuid
(
)
)
.
c_str
(
)
:
"
"
)
;
bool
success
=
false
;
for
(
size_t
i
=
0
;
i
<
mInputBlockQueue
.
Length
(
)
;
i
+
+
)
{
CancelableBlockState
*
block
=
mInputBlockQueue
[
i
]
.
get
(
)
;
if
(
block
-
>
GetBlockId
(
)
=
=
aInputBlockId
)
{
success
=
block
-
>
SetConfirmedTargetApzc
(
aTargetApzc
InputBlockState
:
:
TargetConfirmationState
:
:
eConfirmed
)
;
block
-
>
RecordContentResponseTime
(
)
;
break
;
}
}
if
(
success
)
{
ProcessInputBlocks
(
)
;
}
}
void
InputQueue
:
:
ConfirmDragBlock
(
uint64_t
aInputBlockId
const
RefPtr
<
AsyncPanZoomController
>
&
aTargetApzc
const
AsyncDragMetrics
&
aDragMetrics
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
INPQ_LOG
(
"
got
a
target
apzc
;
block
=
%
"
PRIu64
"
guid
=
%
s
\
n
"
aInputBlockId
aTargetApzc
?
Stringify
(
aTargetApzc
-
>
GetGuid
(
)
)
.
c_str
(
)
:
"
"
)
;
bool
success
=
false
;
for
(
size_t
i
=
0
;
i
<
mInputBlockQueue
.
Length
(
)
;
i
+
+
)
{
DragBlockState
*
block
=
mInputBlockQueue
[
i
]
-
>
AsDragBlock
(
)
;
if
(
block
&
&
block
-
>
GetBlockId
(
)
=
=
aInputBlockId
)
{
block
-
>
SetDragMetrics
(
aDragMetrics
)
;
success
=
block
-
>
SetConfirmedTargetApzc
(
aTargetApzc
InputBlockState
:
:
TargetConfirmationState
:
:
eConfirmed
)
;
block
-
>
RecordContentResponseTime
(
)
;
break
;
}
}
if
(
success
)
{
ProcessInputBlocks
(
)
;
}
}
void
InputQueue
:
:
SetAllowedTouchBehavior
(
uint64_t
aInputBlockId
const
nsTArray
<
TouchBehaviorFlags
>
&
aBehaviors
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
INPQ_LOG
(
"
got
allowed
touch
behaviours
;
block
=
%
"
PRIu64
"
\
n
"
aInputBlockId
)
;
bool
success
=
false
;
for
(
size_t
i
=
0
;
i
<
mInputBlockQueue
.
Length
(
)
;
i
+
+
)
{
if
(
mInputBlockQueue
[
i
]
-
>
GetBlockId
(
)
=
=
aInputBlockId
)
{
TouchBlockState
*
block
=
mInputBlockQueue
[
i
]
-
>
AsTouchBlock
(
)
;
if
(
block
)
{
success
=
block
-
>
SetAllowedTouchBehaviors
(
aBehaviors
)
;
block
-
>
RecordContentResponseTime
(
)
;
}
else
{
NS_WARNING
(
"
input
block
is
not
a
touch
block
"
)
;
}
break
;
}
}
if
(
success
)
{
ProcessInputBlocks
(
)
;
}
}
void
InputQueue
:
:
ProcessInputBlocks
(
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
do
{
CancelableBlockState
*
curBlock
=
CurrentBlock
(
)
;
if
(
!
curBlock
-
>
IsReadyForHandling
(
)
)
{
break
;
}
INPQ_LOG
(
"
processing
input
block
%
p
;
preventDefault
%
d
target
%
p
\
n
"
curBlock
curBlock
-
>
IsDefaultPrevented
(
)
curBlock
-
>
GetTargetApzc
(
)
.
get
(
)
)
;
RefPtr
<
AsyncPanZoomController
>
target
=
curBlock
-
>
GetTargetApzc
(
)
;
if
(
!
target
)
{
curBlock
-
>
DropEvents
(
&
mQueuedInputs
)
;
}
else
if
(
curBlock
-
>
IsDefaultPrevented
(
)
)
{
curBlock
-
>
DropEvents
(
&
mQueuedInputs
)
;
if
(
curBlock
-
>
AsTouchBlock
(
)
)
{
target
-
>
ResetTouchInputState
(
)
;
}
}
else
{
UpdateActiveApzc
(
curBlock
-
>
GetTargetApzc
(
)
)
;
curBlock
-
>
HandleEvents
(
&
mQueuedInputs
)
;
}
MOZ_ASSERT
(
!
curBlock
-
>
HasEvents
(
)
)
;
if
(
mInputBlockQueue
.
Length
(
)
=
=
1
&
&
curBlock
-
>
MustStayActive
(
)
)
{
break
;
}
INPQ_LOG
(
"
discarding
processed
%
s
block
%
p
\
n
"
curBlock
-
>
Type
(
)
curBlock
)
;
ClearActiveBlock
(
curBlock
)
;
mInputBlockQueue
.
RemoveElementAt
(
0
)
;
}
while
(
!
mInputBlockQueue
.
IsEmpty
(
)
)
;
}
void
InputQueue
:
:
ClearActiveBlock
(
CancelableBlockState
*
aBlock
)
{
if
(
mActiveTouchBlock
.
get
(
)
=
=
aBlock
)
{
mActiveTouchBlock
=
nullptr
;
}
else
if
(
mActiveWheelBlock
.
get
(
)
=
=
aBlock
)
{
mActiveWheelBlock
=
nullptr
;
}
else
if
(
mActiveDragBlock
.
get
(
)
=
=
aBlock
)
{
mActiveDragBlock
=
nullptr
;
}
else
if
(
mActivePanGestureBlock
.
get
(
)
=
=
aBlock
)
{
mActivePanGestureBlock
=
nullptr
;
}
}
void
InputQueue
:
:
UpdateActiveApzc
(
const
RefPtr
<
AsyncPanZoomController
>
&
aNewActive
)
{
if
(
mLastActiveApzc
&
&
mLastActiveApzc
!
=
aNewActive
&
&
mTouchCounter
.
GetActiveTouchCount
(
)
>
0
)
{
mLastActiveApzc
-
>
ResetTouchInputState
(
)
;
}
mLastActiveApzc
=
aNewActive
;
}
void
InputQueue
:
:
Clear
(
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
mInputBlockQueue
.
Clear
(
)
;
mQueuedInputs
.
Clear
(
)
;
mActiveTouchBlock
=
nullptr
;
mActiveWheelBlock
=
nullptr
;
mActiveDragBlock
=
nullptr
;
mActivePanGestureBlock
=
nullptr
;
mLastActiveApzc
=
nullptr
;
}
}
}
