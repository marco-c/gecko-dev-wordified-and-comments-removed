#
include
"
mozilla
/
layers
/
APZUpdater
.
h
"
#
include
"
APZCTreeManager
.
h
"
#
include
"
AsyncPanZoomController
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
layers
/
APZThreadUtils
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
SynchronousTask
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderScrollDataWrapper
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
namespace
mozilla
{
namespace
layers
{
StaticMutex
APZUpdater
:
:
sWindowIdLock
;
StaticAutoPtr
<
std
:
:
unordered_map
<
uint64_t
APZUpdater
*
>
>
APZUpdater
:
:
sWindowIdMap
;
APZUpdater
:
:
APZUpdater
(
const
RefPtr
<
APZCTreeManager
>
&
aApz
bool
aIsUsingWebRender
)
:
mApz
(
aApz
)
mDestroyed
(
false
)
mIsUsingWebRender
(
aIsUsingWebRender
)
mThreadIdLock
(
"
APZUpdater
:
:
ThreadIdLock
"
)
mQueueLock
(
"
APZUpdater
:
:
QueueLock
"
)
{
MOZ_ASSERT
(
aApz
)
;
mApz
-
>
SetUpdater
(
this
)
;
}
APZUpdater
:
:
~
APZUpdater
(
)
{
mApz
-
>
SetUpdater
(
nullptr
)
;
StaticMutexAutoLock
lock
(
sWindowIdLock
)
;
if
(
mWindowId
)
{
MOZ_ASSERT
(
sWindowIdMap
)
;
MOZ_ASSERT
(
sWindowIdMap
-
>
find
(
wr
:
:
AsUint64
(
*
mWindowId
)
)
=
=
sWindowIdMap
-
>
end
(
)
)
;
}
}
bool
APZUpdater
:
:
HasTreeManager
(
const
RefPtr
<
APZCTreeManager
>
&
aApz
)
{
return
aApz
.
get
(
)
=
=
mApz
.
get
(
)
;
}
void
APZUpdater
:
:
SetWebRenderWindowId
(
const
wr
:
:
WindowId
&
aWindowId
)
{
StaticMutexAutoLock
lock
(
sWindowIdLock
)
;
MOZ_ASSERT
(
!
mWindowId
)
;
mWindowId
=
Some
(
aWindowId
)
;
if
(
!
sWindowIdMap
)
{
sWindowIdMap
=
new
std
:
:
unordered_map
<
uint64_t
APZUpdater
*
>
(
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
APZUpdater
:
:
ClearOnShutdown
"
[
]
{
ClearOnShutdown
(
&
sWindowIdMap
)
;
}
)
)
;
}
(
*
sWindowIdMap
)
[
wr
:
:
AsUint64
(
aWindowId
)
]
=
this
;
}
void
APZUpdater
:
:
SetUpdaterThread
(
const
wr
:
:
WrWindowId
&
aWindowId
)
{
if
(
RefPtr
<
APZUpdater
>
updater
=
GetUpdater
(
aWindowId
)
)
{
MutexAutoLock
lock
(
updater
-
>
mThreadIdLock
)
;
updater
-
>
mUpdaterThreadId
=
Some
(
PlatformThread
:
:
CurrentId
(
)
)
;
}
}
void
APZUpdater
:
:
PrepareForSceneSwap
(
const
wr
:
:
WrWindowId
&
aWindowId
)
{
if
(
RefPtr
<
APZUpdater
>
updater
=
GetUpdater
(
aWindowId
)
)
{
updater
-
>
mApz
-
>
LockTree
(
)
;
}
}
void
APZUpdater
:
:
CompleteSceneSwap
(
const
wr
:
:
WrWindowId
&
aWindowId
const
wr
:
:
WrPipelineInfo
&
aInfo
)
{
RefPtr
<
APZUpdater
>
updater
=
GetUpdater
(
aWindowId
)
;
if
(
!
updater
)
{
return
;
}
for
(
const
auto
&
removedPipeline
:
aInfo
.
removed_pipelines
)
{
WRRootId
layersId
=
WRRootId
(
removedPipeline
.
pipeline_id
removedPipeline
.
document_id
)
;
updater
-
>
mEpochData
.
erase
(
layersId
)
;
}
for
(
auto
&
i
:
updater
-
>
mEpochData
)
{
i
.
second
.
mBuilt
=
Nothing
(
)
;
}
for
(
const
auto
&
epoch
:
aInfo
.
epochs
)
{
WRRootId
layersId
=
WRRootId
(
epoch
.
pipeline_id
epoch
.
document_id
)
;
updater
-
>
mEpochData
[
layersId
]
.
mBuilt
=
Some
(
epoch
.
epoch
)
;
}
updater
-
>
ProcessQueue
(
)
;
updater
-
>
mApz
-
>
UnlockTree
(
)
;
}
void
APZUpdater
:
:
ProcessPendingTasks
(
const
wr
:
:
WrWindowId
&
aWindowId
)
{
if
(
RefPtr
<
APZUpdater
>
updater
=
GetUpdater
(
aWindowId
)
)
{
updater
-
>
ProcessQueue
(
)
;
}
}
void
APZUpdater
:
:
ClearTree
(
LayersId
aRootLayersId
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
RefPtr
<
APZUpdater
>
self
=
this
;
RunOnUpdaterThread
(
UpdaterQueueSelector
(
aRootLayersId
wr
:
:
RenderRoot
:
:
Default
)
NS_NewRunnableFunction
(
"
APZUpdater
:
:
ClearTree
"
[
=
]
(
)
{
self
-
>
mApz
-
>
ClearTree
(
)
;
self
-
>
mDestroyed
=
true
;
StaticMutexAutoLock
lock
(
sWindowIdLock
)
;
if
(
self
-
>
mWindowId
)
{
MOZ_ASSERT
(
sWindowIdMap
)
;
sWindowIdMap
-
>
erase
(
wr
:
:
AsUint64
(
*
(
self
-
>
mWindowId
)
)
)
;
}
}
)
)
;
}
void
APZUpdater
:
:
UpdateFocusState
(
LayersId
aRootLayerTreeId
WRRootId
aOriginatingWrRootId
const
FocusTarget
&
aFocusTarget
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
UpdaterQueueSelector
selector
(
aOriginatingWrRootId
.
mLayersId
)
;
if
(
aFocusTarget
.
mData
.
is
<
FocusTarget
:
:
ScrollTargets
>
(
)
)
{
const
FocusTarget
:
:
ScrollTargets
&
targets
=
aFocusTarget
.
mData
.
as
<
FocusTarget
:
:
ScrollTargets
>
(
)
;
if
(
targets
.
mHorizontalRenderRoot
)
{
selector
.
mRenderRoots
+
=
*
targets
.
mHorizontalRenderRoot
;
}
if
(
targets
.
mVerticalRenderRoot
)
{
selector
.
mRenderRoots
+
=
*
targets
.
mVerticalRenderRoot
;
}
}
else
{
selector
.
mRenderRoots
+
=
aOriginatingWrRootId
.
mRenderRoot
;
}
RunOnUpdaterThread
(
selector
NewRunnableMethod
<
LayersId
LayersId
FocusTarget
>
(
"
APZUpdater
:
:
UpdateFocusState
"
mApz
&
APZCTreeManager
:
:
UpdateFocusState
aRootLayerTreeId
aOriginatingWrRootId
.
mLayersId
aFocusTarget
)
)
;
}
void
APZUpdater
:
:
UpdateHitTestingTree
(
Layer
*
aRoot
bool
aIsFirstPaint
LayersId
aOriginatingLayersId
uint32_t
aPaintSequenceNumber
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
AssertOnUpdaterThread
(
)
;
mApz
-
>
UpdateHitTestingTree
(
aRoot
aIsFirstPaint
aOriginatingLayersId
aPaintSequenceNumber
)
;
}
void
APZUpdater
:
:
UpdateScrollDataAndTreeState
(
WRRootId
aRootLayerTreeId
WRRootId
aOriginatingWrRootId
const
wr
:
:
Epoch
&
aEpoch
WebRenderScrollData
&
&
aScrollData
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
RefPtr
<
APZUpdater
>
self
=
this
;
RunOnUpdaterThread
(
UpdaterQueueSelector
(
aOriginatingWrRootId
)
NS_NewRunnableFunction
(
"
APZUpdater
:
:
UpdateEpochRequirement
"
[
=
]
(
)
{
if
(
aRootLayerTreeId
=
=
aOriginatingWrRootId
)
{
self
-
>
mEpochData
[
aOriginatingWrRootId
]
.
mIsRoot
=
true
;
}
self
-
>
mEpochData
[
aOriginatingWrRootId
]
.
mRequired
=
aEpoch
;
}
)
)
;
RunOnUpdaterThread
(
UpdaterQueueSelector
(
aOriginatingWrRootId
)
NS_NewRunnableFunction
(
"
APZUpdater
:
:
UpdateHitTestingTree
"
[
=
aScrollData
=
std
:
:
move
(
aScrollData
)
]
(
)
mutable
{
auto
isFirstPaint
=
aScrollData
.
IsFirstPaint
(
)
;
auto
paintSequenceNumber
=
aScrollData
.
GetPaintSequenceNumber
(
)
;
self
-
>
mScrollData
[
aOriginatingWrRootId
]
=
std
:
:
move
(
aScrollData
)
;
auto
root
=
self
-
>
mScrollData
.
find
(
aRootLayerTreeId
)
;
if
(
root
=
=
self
-
>
mScrollData
.
end
(
)
)
{
return
;
}
self
-
>
mApz
-
>
UpdateHitTestingTree
(
WebRenderScrollDataWrapper
(
*
self
&
(
root
-
>
second
)
)
isFirstPaint
aOriginatingWrRootId
.
mLayersId
paintSequenceNumber
)
;
}
)
)
;
}
void
APZUpdater
:
:
UpdateScrollOffsets
(
WRRootId
aRootLayerTreeId
WRRootId
aOriginatingWrRootId
ScrollUpdatesMap
&
&
aUpdates
uint32_t
aPaintSequenceNumber
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
RefPtr
<
APZUpdater
>
self
=
this
;
RunOnUpdaterThread
(
UpdaterQueueSelector
(
aOriginatingWrRootId
)
NS_NewRunnableFunction
(
"
APZUpdater
:
:
UpdateScrollOffsets
"
[
=
updates
=
std
:
:
move
(
aUpdates
)
]
(
)
mutable
{
self
-
>
mScrollData
[
aOriginatingWrRootId
]
.
ApplyUpdates
(
updates
aPaintSequenceNumber
)
;
auto
root
=
self
-
>
mScrollData
.
find
(
aRootLayerTreeId
)
;
if
(
root
=
=
self
-
>
mScrollData
.
end
(
)
)
{
return
;
}
self
-
>
mApz
-
>
UpdateHitTestingTree
(
WebRenderScrollDataWrapper
(
*
self
&
(
root
-
>
second
)
)
false
aOriginatingWrRootId
.
mLayersId
aPaintSequenceNumber
)
;
}
)
)
;
}
void
APZUpdater
:
:
NotifyLayerTreeAdopted
(
WRRootId
aWrRootId
const
RefPtr
<
APZUpdater
>
&
aOldUpdater
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
RunOnUpdaterThread
(
UpdaterQueueSelector
(
aWrRootId
)
NewRunnableMethod
<
LayersId
RefPtr
<
APZCTreeManager
>
>
(
"
APZUpdater
:
:
NotifyLayerTreeAdopted
"
mApz
&
APZCTreeManager
:
:
NotifyLayerTreeAdopted
aWrRootId
.
mLayersId
aOldUpdater
?
aOldUpdater
-
>
mApz
:
nullptr
)
)
;
}
void
APZUpdater
:
:
NotifyLayerTreeRemoved
(
WRRootId
aWrRootId
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
RefPtr
<
APZUpdater
>
self
=
this
;
RunOnUpdaterThread
(
UpdaterQueueSelector
(
aWrRootId
)
NS_NewRunnableFunction
(
"
APZUpdater
:
:
NotifyLayerTreeRemoved
"
[
=
]
(
)
{
self
-
>
mEpochData
.
erase
(
aWrRootId
)
;
self
-
>
mScrollData
.
erase
(
aWrRootId
)
;
self
-
>
mApz
-
>
NotifyLayerTreeRemoved
(
aWrRootId
.
mLayersId
)
;
}
)
)
;
}
bool
APZUpdater
:
:
GetAPZTestData
(
WRRootId
aWrRootId
APZTestData
*
aOutData
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
RefPtr
<
APZCTreeManager
>
apz
=
mApz
;
bool
ret
=
false
;
SynchronousTask
waiter
(
"
APZUpdater
:
:
GetAPZTestData
"
)
;
RunOnUpdaterThread
(
UpdaterQueueSelector
(
aWrRootId
)
NS_NewRunnableFunction
(
"
APZUpdater
:
:
GetAPZTestData
"
[
&
]
(
)
{
AutoCompleteTask
notifier
(
&
waiter
)
;
ret
=
apz
-
>
GetAPZTestData
(
aWrRootId
.
mLayersId
aOutData
)
;
}
)
)
;
waiter
.
Wait
(
)
;
return
ret
;
}
void
APZUpdater
:
:
SetTestAsyncScrollOffset
(
WRRootId
aWrRootId
const
ScrollableLayerGuid
:
:
ViewID
&
aScrollId
const
CSSPoint
&
aOffset
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
RefPtr
<
APZCTreeManager
>
apz
=
mApz
;
RunOnUpdaterThread
(
UpdaterQueueSelector
(
aWrRootId
)
NS_NewRunnableFunction
(
"
APZUpdater
:
:
SetTestAsyncScrollOffset
"
[
=
]
(
)
{
RefPtr
<
AsyncPanZoomController
>
apzc
=
apz
-
>
GetTargetAPZC
(
aWrRootId
.
mLayersId
aScrollId
)
;
if
(
apzc
)
{
apzc
-
>
SetTestAsyncScrollOffset
(
aOffset
)
;
}
else
{
NS_WARNING
(
"
Unable
to
find
APZC
in
SetTestAsyncScrollOffset
"
)
;
}
}
)
)
;
}
void
APZUpdater
:
:
SetTestAsyncZoom
(
WRRootId
aWrRootId
const
ScrollableLayerGuid
:
:
ViewID
&
aScrollId
const
LayerToParentLayerScale
&
aZoom
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
RefPtr
<
APZCTreeManager
>
apz
=
mApz
;
RunOnUpdaterThread
(
UpdaterQueueSelector
(
aWrRootId
)
NS_NewRunnableFunction
(
"
APZUpdater
:
:
SetTestAsyncZoom
"
[
=
]
(
)
{
RefPtr
<
AsyncPanZoomController
>
apzc
=
apz
-
>
GetTargetAPZC
(
aWrRootId
.
mLayersId
aScrollId
)
;
if
(
apzc
)
{
apzc
-
>
SetTestAsyncZoom
(
aZoom
)
;
}
else
{
NS_WARNING
(
"
Unable
to
find
APZC
in
SetTestAsyncZoom
"
)
;
}
}
)
)
;
}
const
WebRenderScrollData
*
APZUpdater
:
:
GetScrollData
(
WRRootId
aWrRootId
)
const
{
AssertOnUpdaterThread
(
)
;
auto
it
=
mScrollData
.
find
(
aWrRootId
)
;
return
(
it
=
=
mScrollData
.
end
(
)
?
nullptr
:
&
(
it
-
>
second
)
)
;
}
void
APZUpdater
:
:
AssertOnUpdaterThread
(
)
const
{
if
(
APZThreadUtils
:
:
GetThreadAssertionsEnabled
(
)
)
{
MOZ_ASSERT
(
IsUpdaterThread
(
)
)
;
}
}
void
APZUpdater
:
:
RunOnUpdaterThread
(
UpdaterQueueSelector
aSelector
already_AddRefed
<
Runnable
>
aTask
)
{
RefPtr
<
Runnable
>
task
=
aTask
;
if
(
IsUpdaterThread
(
)
)
{
task
-
>
Run
(
)
;
return
;
}
if
(
UsingWebRenderUpdaterThread
(
)
)
{
bool
sendWakeMessage
=
true
;
{
MutexAutoLock
lock
(
mQueueLock
)
;
wr
:
:
RenderRootSet
alreadyWoken
;
for
(
const
auto
&
queuedTask
:
mUpdaterQueue
)
{
if
(
queuedTask
.
mSelector
.
mLayersId
=
=
aSelector
.
mLayersId
)
{
alreadyWoken
+
=
(
queuedTask
.
mSelector
.
mRenderRoots
&
aSelector
.
mRenderRoots
)
;
break
;
}
}
if
(
alreadyWoken
=
=
aSelector
.
mRenderRoots
)
{
sendWakeMessage
=
false
;
}
mUpdaterQueue
.
push_back
(
QueuedTask
{
aSelector
task
}
)
;
}
if
(
sendWakeMessage
)
{
RefPtr
<
wr
:
:
WebRenderAPI
>
api
=
mApz
-
>
GetWebRenderAPI
(
wr
:
:
RenderRoot
:
:
Default
)
;
if
(
api
)
{
api
-
>
WakeSceneBuilder
(
)
;
}
else
{
NS_WARNING
(
"
Possibly
dropping
task
posted
to
updater
thread
"
)
;
}
}
return
;
}
if
(
MessageLoop
*
loop
=
CompositorThreadHolder
:
:
Loop
(
)
)
{
loop
-
>
PostTask
(
task
.
forget
(
)
)
;
}
else
{
NS_WARNING
(
"
Dropping
task
posted
to
updater
thread
"
)
;
}
}
bool
APZUpdater
:
:
IsUpdaterThread
(
)
const
{
if
(
UsingWebRenderUpdaterThread
(
)
)
{
MutexAutoLock
lock
(
mThreadIdLock
)
;
return
mUpdaterThreadId
&
&
PlatformThread
:
:
CurrentId
(
)
=
=
*
mUpdaterThreadId
;
}
return
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
;
}
void
APZUpdater
:
:
RunOnControllerThread
(
UpdaterQueueSelector
aSelector
already_AddRefed
<
Runnable
>
aTask
)
{
MOZ_ASSERT
(
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
RefPtr
<
Runnable
>
task
=
aTask
;
RunOnUpdaterThread
(
aSelector
NewRunnableFunction
(
"
APZUpdater
:
:
RunOnControllerThread
"
&
APZThreadUtils
:
:
RunOnControllerThread
std
:
:
move
(
task
)
)
)
;
}
bool
APZUpdater
:
:
UsingWebRenderUpdaterThread
(
)
const
{
return
mIsUsingWebRender
;
}
already_AddRefed
<
APZUpdater
>
APZUpdater
:
:
GetUpdater
(
const
wr
:
:
WrWindowId
&
aWindowId
)
{
RefPtr
<
APZUpdater
>
updater
;
StaticMutexAutoLock
lock
(
sWindowIdLock
)
;
if
(
sWindowIdMap
)
{
auto
it
=
sWindowIdMap
-
>
find
(
wr
:
:
AsUint64
(
aWindowId
)
)
;
if
(
it
!
=
sWindowIdMap
-
>
end
(
)
)
{
updater
=
it
-
>
second
;
}
}
return
updater
.
forget
(
)
;
}
void
APZUpdater
:
:
ProcessQueue
(
)
{
MOZ_ASSERT
(
!
mDestroyed
)
;
{
MutexAutoLock
lock
(
mQueueLock
)
;
if
(
mUpdaterQueue
.
empty
(
)
)
{
return
;
}
}
std
:
:
deque
<
QueuedTask
>
blockedTasks
;
while
(
true
)
{
QueuedTask
task
;
{
MutexAutoLock
lock
(
mQueueLock
)
;
if
(
mUpdaterQueue
.
empty
(
)
)
{
std
:
:
swap
(
mUpdaterQueue
blockedTasks
)
;
break
;
}
task
=
mUpdaterQueue
.
front
(
)
;
mUpdaterQueue
.
pop_front
(
)
;
}
bool
blocked
=
false
;
for
(
wr
:
:
RenderRoot
root
:
task
.
mSelector
.
mRenderRoots
)
{
WRRootId
selector
=
WRRootId
(
task
.
mSelector
.
mLayersId
root
)
;
auto
it
=
mEpochData
.
find
(
selector
)
;
if
(
it
!
=
mEpochData
.
end
(
)
&
&
it
-
>
second
.
IsBlocked
(
)
)
{
blocked
=
true
;
break
;
}
}
if
(
blocked
)
{
blockedTasks
.
push_back
(
task
)
;
}
else
{
task
.
mRunnable
-
>
Run
(
)
;
}
}
if
(
mDestroyed
)
{
MutexAutoLock
lock
(
mQueueLock
)
;
if
(
!
mUpdaterQueue
.
empty
(
)
)
{
mUpdaterQueue
.
clear
(
)
;
}
}
}
void
APZUpdater
:
:
MarkAsDetached
(
LayersId
aLayersId
)
{
mApz
-
>
MarkAsDetached
(
aLayersId
)
;
}
APZUpdater
:
:
EpochState
:
:
EpochState
(
)
:
mRequired
{
0
}
mIsRoot
(
false
)
{
}
bool
APZUpdater
:
:
EpochState
:
:
IsBlocked
(
)
const
{
if
(
mIsRoot
&
&
!
mBuilt
)
{
return
true
;
}
return
mBuilt
&
&
(
*
mBuilt
<
mRequired
)
;
}
}
}
void
apz_register_updater
(
mozilla
:
:
wr
:
:
WrWindowId
aWindowId
)
{
mozilla
:
:
layers
:
:
APZUpdater
:
:
SetUpdaterThread
(
aWindowId
)
;
}
void
apz_pre_scene_swap
(
mozilla
:
:
wr
:
:
WrWindowId
aWindowId
)
{
mozilla
:
:
layers
:
:
APZUpdater
:
:
PrepareForSceneSwap
(
aWindowId
)
;
}
void
apz_post_scene_swap
(
mozilla
:
:
wr
:
:
WrWindowId
aWindowId
const
mozilla
:
:
wr
:
:
WrPipelineInfo
*
aInfo
)
{
mozilla
:
:
layers
:
:
APZUpdater
:
:
CompleteSceneSwap
(
aWindowId
*
aInfo
)
;
}
void
apz_run_updater
(
mozilla
:
:
wr
:
:
WrWindowId
aWindowId
)
{
mozilla
:
:
layers
:
:
APZUpdater
:
:
ProcessPendingTasks
(
aWindowId
)
;
}
void
apz_deregister_updater
(
mozilla
:
:
wr
:
:
WrWindowId
aWindowId
)
{
mozilla
:
:
layers
:
:
APZUpdater
:
:
ProcessPendingTasks
(
aWindowId
)
;
}
