#
include
<
stack
>
#
include
<
unordered_set
>
#
include
"
APZCTreeManager
.
h
"
#
include
"
AsyncPanZoomController
.
h
"
#
include
"
Compositor
.
h
"
#
include
"
DragTracker
.
h
"
#
include
"
GenericFlingAnimation
.
h
"
#
include
"
HitTestingTreeNode
.
h
"
#
include
"
InputBlockState
.
h
"
#
include
"
InputData
.
h
"
#
include
"
Layers
.
h
"
#
include
"
mozilla
/
dom
/
MouseEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
BrowserParent
.
h
"
#
include
"
mozilla
/
dom
/
Touch
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
gfx
/
GPUParent
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
mozilla
/
jni
/
Utils
.
h
"
#
endif
#
include
"
mozilla
/
layers
/
APZSampler
.
h
"
#
include
"
mozilla
/
layers
/
APZThreadUtils
.
h
"
#
include
"
mozilla
/
layers
/
APZUpdater
.
h
"
#
include
"
mozilla
/
layers
/
AsyncCompositionManager
.
h
"
#
include
"
mozilla
/
layers
/
AsyncDragMetrics
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
LayerMetricsWrapper
.
h
"
#
include
"
mozilla
/
layers
/
MatrixMessage
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderScrollDataWrapper
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_accessibility
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
TouchEvents
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
OverscrollHandoffState
.
h
"
#
include
"
TreeTraversal
.
h
"
#
include
"
LayersLogging
.
h
"
#
include
"
Units
.
h
"
#
include
"
GestureEventListener
.
h
"
#
include
"
UnitTransforms
.
h
"
#
define
ENABLE_APZCTM_LOGGING
0
#
if
ENABLE_APZCTM_LOGGING
#
define
APZCTM_LOG
(
.
.
.
)
printf_stderr
(
"
APZCTM
:
"
__VA_ARGS__
)
#
else
#
define
APZCTM_LOG
(
.
.
.
)
#
endif
#
define
APZ_KEY_LOG
(
.
.
.
)
namespace
mozilla
{
namespace
layers
{
using
mozilla
:
:
gfx
:
:
CompositorHitTestInfo
;
typedef
mozilla
:
:
gfx
:
:
Point
Point
;
typedef
mozilla
:
:
gfx
:
:
Point4D
Point4D
;
typedef
mozilla
:
:
gfx
:
:
Matrix4x4
Matrix4x4
;
typedef
CompositorBridgeParent
:
:
LayerTreeState
LayerTreeState
;
struct
APZCTreeManager
:
:
TreeBuildingState
{
TreeBuildingState
(
LayersId
aRootLayersId
bool
aIsFirstPaint
WRRootId
aOriginatingWrRootId
APZTestData
*
aTestData
uint32_t
aPaintSequence
)
:
mIsFirstPaint
(
aIsFirstPaint
)
mOriginatingWrRootId
(
aOriginatingWrRootId
)
mPaintLogger
(
aTestData
aPaintSequence
)
{
CompositorBridgeParent
:
:
CallWithIndirectShadowTree
(
aRootLayersId
[
this
]
(
LayerTreeState
&
aState
)
-
>
void
{
mCompositorController
=
aState
.
GetCompositorController
(
)
;
mInProcessSharingController
=
aState
.
InProcessSharingController
(
)
;
}
)
;
}
typedef
std
:
:
unordered_map
<
AsyncPanZoomController
*
gfx
:
:
Matrix4x4
>
DeferredTransformMap
;
RefPtr
<
CompositorController
>
mCompositorController
;
RefPtr
<
MetricsSharingController
>
mInProcessSharingController
;
const
bool
mIsFirstPaint
;
const
WRRootId
mOriginatingWrRootId
;
const
APZPaintLogHelper
mPaintLogger
;
nsTArray
<
RefPtr
<
HitTestingTreeNode
>
>
mNodesToDestroy
;
std
:
:
unordered_map
<
ScrollableLayerGuid
RefPtr
<
AsyncPanZoomController
>
ScrollableLayerGuid
:
:
HashIgnoringPresShellFn
ScrollableLayerGuid
:
:
EqualIgnoringPresShellFn
>
mApzcMap
;
std
:
:
vector
<
HitTestingTreeNode
*
>
mScrollThumbs
;
std
:
:
unordered_map
<
ScrollableLayerGuid
HitTestingTreeNode
*
ScrollableLayerGuid
:
:
HashIgnoringPresShellFn
ScrollableLayerGuid
:
:
EqualIgnoringPresShellFn
>
mScrollTargets
;
std
:
:
stack
<
bool
>
mParentHasPerspective
;
DeferredTransformMap
mPerspectiveTransformsDeferredToChildren
;
Maybe
<
uint64_t
>
mZoomAnimationId
;
}
;
class
APZCTreeManager
:
:
CheckerboardFlushObserver
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
explicit
CheckerboardFlushObserver
(
APZCTreeManager
*
aTreeManager
)
:
mTreeManager
(
aTreeManager
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
obsSvc
)
;
if
(
obsSvc
)
{
obsSvc
-
>
AddObserver
(
this
"
APZ
:
FlushActiveCheckerboard
"
false
)
;
}
}
void
Unregister
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsSvc
)
{
obsSvc
-
>
RemoveObserver
(
this
"
APZ
:
FlushActiveCheckerboard
"
)
;
}
mTreeManager
=
nullptr
;
}
protected
:
virtual
~
CheckerboardFlushObserver
(
)
=
default
;
private
:
RefPtr
<
APZCTreeManager
>
mTreeManager
;
}
;
NS_IMPL_ISUPPORTS
(
APZCTreeManager
:
:
CheckerboardFlushObserver
nsIObserver
)
NS_IMETHODIMP
APZCTreeManager
:
:
CheckerboardFlushObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mTreeManager
.
get
(
)
)
;
RecursiveMutexAutoLock
lock
(
mTreeManager
-
>
mTreeLock
)
;
if
(
mTreeManager
-
>
mRootNode
)
{
ForEachNode
<
ReverseIterator
>
(
mTreeManager
-
>
mRootNode
.
get
(
)
[
]
(
HitTestingTreeNode
*
aNode
)
{
if
(
aNode
-
>
IsPrimaryHolder
(
)
)
{
MOZ_ASSERT
(
aNode
-
>
GetApzc
(
)
)
;
aNode
-
>
GetApzc
(
)
-
>
FlushActiveCheckerboardReport
(
)
;
}
}
)
;
}
if
(
XRE_IsGPUProcess
(
)
)
{
if
(
gfx
:
:
GPUParent
*
gpu
=
gfx
:
:
GPUParent
:
:
GetSingleton
(
)
)
{
nsCString
topic
(
"
APZ
:
FlushActiveCheckerboard
:
Done
"
)
;
Unused
<
<
gpu
-
>
SendNotifyUiObservers
(
topic
)
;
}
}
else
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsSvc
)
{
obsSvc
-
>
NotifyObservers
(
nullptr
"
APZ
:
FlushActiveCheckerboard
:
Done
"
nullptr
)
;
}
}
return
NS_OK
;
}
class
MOZ_RAII
AutoFocusSequenceNumberSetter
{
public
:
AutoFocusSequenceNumberSetter
(
FocusState
&
aFocusState
InputData
&
aEvent
)
:
mFocusState
(
aFocusState
)
mEvent
(
aEvent
)
mMayChangeFocus
(
true
)
{
}
void
MarkAsNonFocusChanging
(
)
{
mMayChangeFocus
=
false
;
}
~
AutoFocusSequenceNumberSetter
(
)
{
if
(
mMayChangeFocus
)
{
mFocusState
.
ReceiveFocusChangingEvent
(
)
;
APZ_KEY_LOG
(
"
Marking
input
with
type
=
%
d
as
focus
changing
with
seq
=
%
"
PRIu64
"
\
n
"
static_cast
<
int
>
(
mEvent
.
mInputType
)
mFocusState
.
LastAPZProcessedEvent
(
)
)
;
}
else
{
APZ_KEY_LOG
(
"
Marking
input
with
type
=
%
d
as
non
focus
changing
with
seq
=
%
"
PRIu64
"
\
n
"
static_cast
<
int
>
(
mEvent
.
mInputType
)
mFocusState
.
LastAPZProcessedEvent
(
)
)
;
}
mEvent
.
mFocusSequenceNumber
=
mFocusState
.
LastAPZProcessedEvent
(
)
;
}
private
:
FocusState
&
mFocusState
;
InputData
&
mEvent
;
bool
mMayChangeFocus
;
}
;
APZCTreeManager
:
:
APZCTreeManager
(
LayersId
aRootLayersId
)
:
mInputQueue
(
new
InputQueue
(
)
)
mRootLayersId
(
aRootLayersId
)
mSampler
(
nullptr
)
mUpdater
(
nullptr
)
mTreeLock
(
"
APZCTreeLock
"
)
mUsingAsyncZoomContainer
(
false
)
mMapLock
(
"
APZCMapLock
"
)
mRetainedTouchIdentifier
(
-
1
)
mInScrollbarTouchDrag
(
false
)
mApzcTreeLog
(
"
apzctree
"
)
mTestDataLock
(
"
APZTestDataLock
"
)
mDPI
(
160
.
0
)
{
RefPtr
<
APZCTreeManager
>
self
(
this
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
layers
:
:
APZCTreeManager
:
:
APZCTreeManager
"
[
self
]
{
self
-
>
mFlushObserver
=
new
CheckerboardFlushObserver
(
self
)
;
}
)
)
;
AsyncPanZoomController
:
:
InitializeGlobalState
(
)
;
mApzcTreeLog
.
ConditionOnPrefFunction
(
StaticPrefs
:
:
apz_printtree
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
if
(
jni
:
:
IsFennec
(
)
)
{
mToolbarAnimator
=
new
AndroidDynamicToolbarAnimator
(
this
)
;
}
#
endif
}
APZCTreeManager
:
:
~
APZCTreeManager
(
)
=
default
;
void
APZCTreeManager
:
:
SetSampler
(
APZSampler
*
aSampler
)
{
MOZ_ASSERT
(
(
mSampler
=
=
nullptr
)
!
=
(
aSampler
=
=
nullptr
)
)
;
mSampler
=
aSampler
;
}
void
APZCTreeManager
:
:
SetUpdater
(
APZUpdater
*
aUpdater
)
{
MOZ_ASSERT
(
(
mUpdater
=
=
nullptr
)
!
=
(
aUpdater
=
=
nullptr
)
)
;
mUpdater
=
aUpdater
;
}
void
APZCTreeManager
:
:
NotifyLayerTreeAdopted
(
LayersId
aLayersId
const
RefPtr
<
APZCTreeManager
>
&
aOldApzcTreeManager
)
{
AssertOnUpdaterThread
(
)
;
if
(
aOldApzcTreeManager
)
{
aOldApzcTreeManager
-
>
mFocusState
.
RemoveFocusTarget
(
aLayersId
)
;
}
UniquePtr
<
APZTestData
>
adoptedData
;
if
(
aOldApzcTreeManager
)
{
MutexAutoLock
lock
(
aOldApzcTreeManager
-
>
mTestDataLock
)
;
auto
it
=
aOldApzcTreeManager
-
>
mTestData
.
find
(
aLayersId
)
;
if
(
it
!
=
aOldApzcTreeManager
-
>
mTestData
.
end
(
)
)
{
adoptedData
=
std
:
:
move
(
it
-
>
second
)
;
aOldApzcTreeManager
-
>
mTestData
.
erase
(
it
)
;
}
}
if
(
adoptedData
)
{
MutexAutoLock
lock
(
mTestDataLock
)
;
mTestData
[
aLayersId
]
=
std
:
:
move
(
adoptedData
)
;
}
}
void
APZCTreeManager
:
:
NotifyLayerTreeRemoved
(
LayersId
aLayersId
)
{
AssertOnUpdaterThread
(
)
;
mFocusState
.
RemoveFocusTarget
(
aLayersId
)
;
{
MutexAutoLock
lock
(
mTestDataLock
)
;
mTestData
.
erase
(
aLayersId
)
;
}
}
AsyncPanZoomController
*
APZCTreeManager
:
:
NewAPZCInstance
(
LayersId
aLayersId
GeckoContentController
*
aController
wr
:
:
RenderRoot
aRenderRoot
)
{
return
new
AsyncPanZoomController
(
aLayersId
this
mInputQueue
aController
aRenderRoot
AsyncPanZoomController
:
:
USE_GESTURE_DETECTOR
)
;
}
void
APZCTreeManager
:
:
SetTestSampleTime
(
const
Maybe
<
TimeStamp
>
&
aTime
)
{
mTestSampleTime
=
aTime
;
}
TimeStamp
APZCTreeManager
:
:
GetFrameTime
(
)
{
if
(
mTestSampleTime
)
{
return
*
mTestSampleTime
;
}
return
TimeStamp
:
:
Now
(
)
;
}
void
APZCTreeManager
:
:
SetAllowedTouchBehavior
(
uint64_t
aInputBlockId
const
nsTArray
<
TouchBehaviorFlags
>
&
aValues
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
mInputQueue
-
>
SetAllowedTouchBehavior
(
aInputBlockId
aValues
)
;
}
template
<
class
ScrollNode
>
void
APZCTreeManager
:
:
UpdateHitTestingTreeImpl
(
const
ScrollNode
&
aRoot
bool
aIsFirstPaint
WRRootId
aOriginatingWrRootId
uint32_t
aPaintSequenceNumber
)
{
RecursiveMutexAutoLock
lock
(
mTreeLock
)
;
APZTestData
*
testData
=
nullptr
;
if
(
StaticPrefs
:
:
apz_test_logging_enabled
(
)
)
{
MutexAutoLock
lock
(
mTestDataLock
)
;
UniquePtr
<
APZTestData
>
ptr
=
MakeUnique
<
APZTestData
>
(
)
;
auto
result
=
mTestData
.
insert
(
std
:
:
make_pair
(
aOriginatingWrRootId
.
mLayersId
std
:
:
move
(
ptr
)
)
)
;
testData
=
result
.
first
-
>
second
.
get
(
)
;
testData
-
>
StartNewPaint
(
aPaintSequenceNumber
)
;
}
TreeBuildingState
state
(
mRootLayersId
aIsFirstPaint
aOriginatingWrRootId
testData
aPaintSequenceNumber
)
;
ForEachNode
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
&
state
]
(
HitTestingTreeNode
*
aNode
)
{
state
.
mNodesToDestroy
.
AppendElement
(
aNode
)
;
}
)
;
mRootNode
=
nullptr
;
mUsingAsyncZoomContainer
=
false
;
int
asyncZoomContainerNestingDepth
=
0
;
bool
haveMultipleAsyncZoomContainers
=
false
;
bool
haveRootContentOutsideAsyncZoomContainer
=
false
;
if
(
aRoot
)
{
std
:
:
unordered_set
<
LayersId
LayersId
:
:
HashFn
>
seenLayersIds
;
std
:
:
stack
<
gfx
:
:
TreeAutoIndent
<
LOG_DEFAULT
>
>
indents
;
std
:
:
stack
<
AncestorTransform
>
ancestorTransforms
;
HitTestingTreeNode
*
parent
=
nullptr
;
HitTestingTreeNode
*
next
=
nullptr
;
LayersId
layersId
=
mRootLayersId
;
seenLayersIds
.
insert
(
mRootLayersId
)
;
std
:
:
stack
<
wr
:
:
RenderRoot
>
renderRoots
;
renderRoots
.
push
(
wr
:
:
RenderRoot
:
:
Default
)
;
ancestorTransforms
.
push
(
AncestorTransform
(
)
)
;
state
.
mParentHasPerspective
.
push
(
false
)
;
mApzcTreeLog
<
<
"
[
start
]
\
n
"
;
mTreeLock
.
AssertCurrentThreadIn
(
)
;
ForEachNode
<
ReverseIterator
>
(
aRoot
[
&
]
(
ScrollNode
aLayerMetrics
)
{
mApzcTreeLog
<
<
aLayerMetrics
.
Name
(
)
<
<
'
\
t
'
;
if
(
aLayerMetrics
.
IsAsyncZoomContainer
(
)
)
{
if
(
mUsingAsyncZoomContainer
)
{
haveMultipleAsyncZoomContainers
=
true
;
}
mUsingAsyncZoomContainer
=
true
;
+
+
asyncZoomContainerNestingDepth
;
}
if
(
aLayerMetrics
.
Metrics
(
)
.
IsRootContent
(
)
&
&
asyncZoomContainerNestingDepth
=
=
0
)
{
haveRootContentOutsideAsyncZoomContainer
=
true
;
}
HitTestingTreeNode
*
node
=
PrepareNodeForLayer
(
lock
aLayerMetrics
aLayerMetrics
.
Metrics
(
)
layersId
ancestorTransforms
.
top
(
)
parent
next
state
renderRoots
.
top
(
)
)
;
MOZ_ASSERT
(
node
)
;
AsyncPanZoomController
*
apzc
=
node
-
>
GetApzc
(
)
;
aLayerMetrics
.
SetApzc
(
apzc
)
;
if
(
node
-
>
IsScrollThumbNode
(
)
&
&
node
-
>
GetScrollbarAnimationId
(
)
)
{
state
.
mScrollThumbs
.
push_back
(
node
)
;
}
if
(
apzc
&
&
node
-
>
IsPrimaryHolder
(
)
)
{
state
.
mScrollTargets
[
apzc
-
>
GetGuid
(
)
]
=
node
;
}
mApzcTreeLog
<
<
'
\
n
'
;
AncestorTransform
currentTransform
{
aLayerMetrics
.
GetTransform
(
)
aLayerMetrics
.
TransformIsPerspective
(
)
}
;
if
(
!
apzc
)
{
currentTransform
=
currentTransform
*
ancestorTransforms
.
top
(
)
;
}
ancestorTransforms
.
push
(
currentTransform
)
;
MOZ_ASSERT
(
!
node
-
>
GetFirstChild
(
)
)
;
parent
=
node
;
next
=
nullptr
;
if
(
Maybe
<
LayersId
>
newLayersId
=
aLayerMetrics
.
GetReferentId
(
)
)
{
layersId
=
*
newLayersId
;
seenLayersIds
.
insert
(
layersId
)
;
}
if
(
Maybe
<
wr
:
:
RenderRoot
>
newRenderRoot
=
aLayerMetrics
.
GetReferentRenderRoot
(
)
)
{
renderRoots
.
push
(
*
newRenderRoot
)
;
}
indents
.
push
(
gfx
:
:
TreeAutoIndent
<
LOG_DEFAULT
>
(
mApzcTreeLog
)
)
;
state
.
mParentHasPerspective
.
push
(
aLayerMetrics
.
TransformIsPerspective
(
)
)
;
}
[
&
]
(
ScrollNode
aLayerMetrics
)
{
if
(
aLayerMetrics
.
IsAsyncZoomContainer
(
)
)
{
-
-
asyncZoomContainerNestingDepth
;
}
next
=
parent
;
parent
=
parent
-
>
GetParent
(
)
;
layersId
=
next
-
>
GetLayersId
(
)
;
ancestorTransforms
.
pop
(
)
;
indents
.
pop
(
)
;
state
.
mParentHasPerspective
.
pop
(
)
;
if
(
aLayerMetrics
.
GetReferentRenderRoot
(
)
)
{
renderRoots
.
pop
(
)
;
}
}
)
;
mApzcTreeLog
<
<
"
[
end
]
\
n
"
;
MOZ_ASSERT
(
!
mUsingAsyncZoomContainer
|
|
!
haveRootContentOutsideAsyncZoomContainer
"
If
there
is
an
async
zoom
container
all
scroll
nodes
with
root
"
"
content
scroll
metadata
should
be
inside
it
"
)
;
if
(
!
state
.
mPerspectiveTransformsDeferredToChildren
.
empty
(
)
)
{
ForEachNode
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
&
state
]
(
HitTestingTreeNode
*
aNode
)
{
AsyncPanZoomController
*
apzc
=
aNode
-
>
GetApzc
(
)
;
if
(
!
apzc
)
{
return
;
}
if
(
!
aNode
-
>
IsPrimaryHolder
(
)
)
{
return
;
}
AsyncPanZoomController
*
parent
=
apzc
-
>
GetParent
(
)
;
if
(
!
parent
)
{
return
;
}
auto
it
=
state
.
mPerspectiveTransformsDeferredToChildren
.
find
(
parent
)
;
if
(
it
!
=
state
.
mPerspectiveTransformsDeferredToChildren
.
end
(
)
)
{
apzc
-
>
SetAncestorTransform
(
AncestorTransform
{
it
-
>
second
*
apzc
-
>
GetAncestorTransform
(
)
false
}
)
;
}
}
)
;
}
for
(
auto
iter
=
mDetachedLayersIds
.
begin
(
)
;
iter
!
=
mDetachedLayersIds
.
end
(
)
;
)
{
if
(
seenLayersIds
.
find
(
*
iter
)
=
=
seenLayersIds
.
end
(
)
)
{
iter
=
mDetachedLayersIds
.
erase
(
iter
)
;
}
else
{
+
+
iter
;
}
}
}
MOZ_ASSERT
(
!
(
mRootNode
&
&
mRootNode
-
>
GetPrevSibling
(
)
)
)
;
{
MutexAutoLock
lock
(
mMapLock
)
;
mApzcMap
=
std
:
:
move
(
state
.
mApzcMap
)
;
mScrollThumbInfo
.
clear
(
)
;
for
(
HitTestingTreeNode
*
thumb
:
state
.
mScrollThumbs
)
{
MOZ_ASSERT
(
thumb
-
>
IsScrollThumbNode
(
)
)
;
ScrollableLayerGuid
targetGuid
(
thumb
-
>
GetLayersId
(
)
0
thumb
-
>
GetScrollTargetId
(
)
)
;
auto
it
=
state
.
mScrollTargets
.
find
(
targetGuid
)
;
if
(
it
=
=
state
.
mScrollTargets
.
end
(
)
)
{
continue
;
}
HitTestingTreeNode
*
target
=
it
-
>
second
;
mScrollThumbInfo
.
emplace_back
(
*
(
thumb
-
>
GetScrollbarAnimationId
(
)
)
thumb
-
>
GetTransform
(
)
thumb
-
>
GetScrollbarData
(
)
targetGuid
target
-
>
GetTransform
(
)
target
-
>
IsAncestorOf
(
thumb
)
)
;
}
}
for
(
size_t
i
=
0
;
i
<
state
.
mNodesToDestroy
.
Length
(
)
;
i
+
+
)
{
APZCTM_LOG
(
"
Destroying
node
at
%
p
with
APZC
%
p
\
n
"
state
.
mNodesToDestroy
[
i
]
.
get
(
)
state
.
mNodesToDestroy
[
i
]
-
>
GetApzc
(
)
)
;
state
.
mNodesToDestroy
[
i
]
-
>
Destroy
(
)
;
}
#
if
ENABLE_APZCTM_LOGGING
printf_stderr
(
"
APZCTreeManager
(
%
p
)
\
n
"
this
)
;
if
(
mRootNode
)
{
mRootNode
-
>
Dump
(
"
"
)
;
}
#
endif
SendSubtreeTransformsToChromeMainThread
(
nullptr
)
;
}
void
APZCTreeManager
:
:
UpdateFocusState
(
LayersId
aRootLayerTreeId
LayersId
aOriginatingLayersId
const
FocusTarget
&
aFocusTarget
)
{
AssertOnUpdaterThread
(
)
;
if
(
!
StaticPrefs
:
:
apz_keyboard_enabled_AtStartup
(
)
)
{
return
;
}
mFocusState
.
Update
(
aRootLayerTreeId
aOriginatingLayersId
aFocusTarget
)
;
}
void
APZCTreeManager
:
:
UpdateHitTestingTree
(
Layer
*
aRoot
bool
aIsFirstPaint
LayersId
aOriginatingLayersId
uint32_t
aPaintSequenceNumber
)
{
AssertOnUpdaterThread
(
)
;
LayerMetricsWrapper
root
(
aRoot
)
;
UpdateHitTestingTreeImpl
(
root
aIsFirstPaint
WRRootId
:
:
NonWebRender
(
aOriginatingLayersId
)
aPaintSequenceNumber
)
;
}
void
APZCTreeManager
:
:
UpdateHitTestingTree
(
const
WebRenderScrollDataWrapper
&
aScrollWrapper
bool
aIsFirstPaint
WRRootId
aOriginatingWrRootId
uint32_t
aPaintSequenceNumber
)
{
AssertOnUpdaterThread
(
)
;
UpdateHitTestingTreeImpl
(
aScrollWrapper
aIsFirstPaint
aOriginatingWrRootId
aPaintSequenceNumber
)
;
}
void
APZCTreeManager
:
:
SampleForWebRender
(
wr
:
:
TransactionWrapper
&
aTxn
const
TimeStamp
&
aSampleTime
wr
:
:
RenderRoot
aRenderRoot
)
{
AssertOnSamplerThread
(
)
;
MutexAutoLock
lock
(
mMapLock
)
;
nsTArray
<
wr
:
:
WrTransformProperty
>
transforms
;
for
(
const
auto
&
mapping
:
mApzcMap
)
{
AsyncPanZoomController
*
apzc
=
mapping
.
second
;
if
(
apzc
-
>
GetRenderRoot
(
)
!
=
aRenderRoot
)
{
continue
;
}
ParentLayerPoint
layerTranslation
=
apzc
-
>
GetCurrentAsyncTransform
(
AsyncPanZoomController
:
:
eForCompositing
)
.
mTranslation
;
LayoutDeviceToParentLayerScale
zoom
;
if
(
Maybe
<
uint64_t
>
zoomAnimationId
=
apzc
-
>
GetZoomAnimationId
(
)
)
{
MOZ_ASSERT
(
apzc
-
>
IsRootContent
(
)
)
;
zoom
=
apzc
-
>
GetCurrentPinchZoomScale
(
AsyncPanZoomController
:
:
eForCompositing
)
;
transforms
.
AppendElement
(
wr
:
:
ToWrTransformProperty
(
*
zoomAnimationId
Matrix4x4
:
:
Scaling
(
zoom
.
scale
zoom
.
scale
1
.
0f
)
)
)
;
aTxn
.
UpdateIsTransformPinchZooming
(
*
zoomAnimationId
apzc
-
>
IsPinchZooming
(
)
)
;
}
LayoutDevicePoint
asyncScrollDelta
=
-
layerTranslation
/
zoom
;
aTxn
.
UpdateScrollPosition
(
wr
:
:
AsPipelineId
(
apzc
-
>
GetGuid
(
)
.
mLayersId
)
apzc
-
>
GetGuid
(
)
.
mScrollId
wr
:
:
ToRoundedLayoutPoint
(
asyncScrollDelta
)
)
;
apzc
-
>
ReportCheckerboard
(
aSampleTime
)
;
}
for
(
const
ScrollThumbInfo
&
info
:
mScrollThumbInfo
)
{
auto
it
=
mApzcMap
.
find
(
info
.
mTargetGuid
)
;
if
(
it
=
=
mApzcMap
.
end
(
)
)
{
continue
;
}
AsyncPanZoomController
*
scrollTargetApzc
=
it
-
>
second
;
MOZ_ASSERT
(
scrollTargetApzc
)
;
if
(
scrollTargetApzc
-
>
GetRenderRoot
(
)
!
=
aRenderRoot
)
{
continue
;
}
LayerToParentLayerMatrix4x4
transform
=
scrollTargetApzc
-
>
CallWithLastContentPaintMetrics
(
[
&
]
(
const
FrameMetrics
&
aMetrics
)
{
return
ComputeTransformForScrollThumb
(
info
.
mThumbTransform
*
AsyncTransformMatrix
(
)
info
.
mTargetTransform
.
ToUnknownMatrix
(
)
scrollTargetApzc
aMetrics
info
.
mThumbData
info
.
mTargetIsAncestor
nullptr
)
;
}
)
;
transforms
.
AppendElement
(
wr
:
:
ToWrTransformProperty
(
info
.
mThumbAnimationId
transform
)
)
;
}
aTxn
.
AppendTransformProperties
(
transforms
)
;
bool
activeAnimations
=
false
;
for
(
const
auto
&
mapping
:
mApzcMap
)
{
AsyncPanZoomController
*
apzc
=
mapping
.
second
;
if
(
apzc
-
>
GetRenderRoot
(
)
!
=
aRenderRoot
)
{
continue
;
}
activeAnimations
|
=
apzc
-
>
AdvanceAnimations
(
aSampleTime
)
;
}
if
(
activeAnimations
)
{
RefPtr
<
CompositorController
>
controller
;
CompositorBridgeParent
:
:
CallWithIndirectShadowTree
(
mRootLayersId
[
&
]
(
LayerTreeState
&
aState
)
-
>
void
{
controller
=
aState
.
GetCompositorController
(
)
;
}
)
;
if
(
controller
)
{
controller
-
>
ScheduleRenderOnCompositorThread
(
wr
:
:
RenderRootSet
(
aRenderRoot
)
)
;
}
}
}
template
<
class
ScrollNode
>
Maybe
<
ParentLayerIntRegion
>
APZCTreeManager
:
:
ComputeClipRegion
(
const
ScrollNode
&
aLayer
)
{
Maybe
<
ParentLayerIntRegion
>
clipRegion
;
if
(
aLayer
.
GetClipRect
(
)
)
{
clipRegion
.
emplace
(
*
aLayer
.
GetClipRect
(
)
)
;
}
else
if
(
aLayer
.
Metrics
(
)
.
IsRootContent
(
)
&
&
mUsingAsyncZoomContainer
)
{
}
else
{
clipRegion
.
emplace
(
RoundedToInt
(
aLayer
.
Metrics
(
)
.
GetCompositionBounds
(
)
)
)
;
}
return
clipRegion
;
}
template
<
class
ScrollNode
>
void
APZCTreeManager
:
:
PrintAPZCInfo
(
const
ScrollNode
&
aLayer
const
AsyncPanZoomController
*
apzc
)
{
const
FrameMetrics
&
metrics
=
aLayer
.
Metrics
(
)
;
mApzcTreeLog
<
<
"
APZC
"
<
<
apzc
-
>
GetGuid
(
)
<
<
"
\
tcb
=
"
<
<
metrics
.
GetCompositionBounds
(
)
<
<
"
\
tsr
=
"
<
<
metrics
.
GetScrollableRect
(
)
<
<
(
metrics
.
IsScrollInfoLayer
(
)
?
"
\
tscrollinfo
"
:
"
"
)
<
<
(
apzc
-
>
HasScrollgrab
(
)
?
"
\
tscrollgrab
"
:
"
"
)
<
<
"
\
t
"
<
<
aLayer
.
Metadata
(
)
.
GetContentDescription
(
)
.
get
(
)
;
}
void
APZCTreeManager
:
:
AttachNodeToTree
(
HitTestingTreeNode
*
aNode
HitTestingTreeNode
*
aParent
HitTestingTreeNode
*
aNextSibling
)
{
if
(
aNextSibling
)
{
aNextSibling
-
>
SetPrevSibling
(
aNode
)
;
}
else
if
(
aParent
)
{
aParent
-
>
SetLastChild
(
aNode
)
;
}
else
{
MOZ_ASSERT
(
!
mRootNode
)
;
mRootNode
=
aNode
;
aNode
-
>
MakeRoot
(
)
;
}
}
template
<
class
ScrollNode
>
static
EventRegions
GetEventRegions
(
const
ScrollNode
&
aLayer
)
{
if
(
aLayer
.
Metrics
(
)
.
IsScrollInfoLayer
(
)
)
{
ParentLayerIntRect
compositionBounds
(
RoundedToInt
(
aLayer
.
Metrics
(
)
.
GetCompositionBounds
(
)
)
)
;
nsIntRegion
hitRegion
(
compositionBounds
.
ToUnknownRect
(
)
)
;
EventRegions
eventRegions
(
hitRegion
)
;
eventRegions
.
mDispatchToContentHitRegion
=
eventRegions
.
mHitRegion
;
return
eventRegions
;
}
return
aLayer
.
GetEventRegions
(
)
;
}
already_AddRefed
<
HitTestingTreeNode
>
APZCTreeManager
:
:
RecycleOrCreateNode
(
const
RecursiveMutexAutoLock
&
aProofOfTreeLock
TreeBuildingState
&
aState
AsyncPanZoomController
*
aApzc
LayersId
aLayersId
)
{
for
(
int32_t
i
=
aState
.
mNodesToDestroy
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
RefPtr
<
HitTestingTreeNode
>
node
=
aState
.
mNodesToDestroy
[
i
]
;
if
(
node
-
>
IsRecyclable
(
aProofOfTreeLock
)
)
{
aState
.
mNodesToDestroy
.
RemoveElementAt
(
i
)
;
node
-
>
RecycleWith
(
aProofOfTreeLock
aApzc
aLayersId
)
;
return
node
.
forget
(
)
;
}
}
RefPtr
<
HitTestingTreeNode
>
node
=
new
HitTestingTreeNode
(
aApzc
false
aLayersId
)
;
return
node
.
forget
(
)
;
}
template
<
class
ScrollNode
>
static
EventRegionsOverride
GetEventRegionsOverride
(
HitTestingTreeNode
*
aParent
const
ScrollNode
&
aLayer
)
{
EventRegionsOverride
result
=
aLayer
.
GetEventRegionsOverride
(
)
;
if
(
result
!
=
EventRegionsOverride
:
:
NoOverride
)
{
MOZ_ASSERT
(
aLayer
.
GetReferentId
(
)
)
;
}
if
(
aParent
)
{
result
|
=
aParent
-
>
GetEventRegionsOverride
(
)
;
}
return
result
;
}
void
APZCTreeManager
:
:
StartScrollbarDrag
(
const
SLGuidAndRenderRoot
&
aGuid
const
AsyncDragMetrics
&
aDragMetrics
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
aGuid
.
mScrollableLayerGuid
)
;
if
(
!
apzc
)
{
NotifyScrollbarDragRejected
(
aGuid
.
mScrollableLayerGuid
)
;
return
;
}
uint64_t
inputBlockId
=
aDragMetrics
.
mDragStartSequenceNumber
;
mInputQueue
-
>
ConfirmDragBlock
(
inputBlockId
apzc
aDragMetrics
)
;
}
bool
APZCTreeManager
:
:
StartAutoscroll
(
const
SLGuidAndRenderRoot
&
aGuid
const
ScreenPoint
&
aAnchorLocation
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
aGuid
.
mScrollableLayerGuid
)
;
if
(
!
apzc
)
{
if
(
XRE_IsGPUProcess
(
)
)
{
NotifyAutoscrollRejected
(
aGuid
.
mScrollableLayerGuid
)
;
}
return
false
;
}
apzc
-
>
StartAutoscroll
(
aAnchorLocation
)
;
return
true
;
}
void
APZCTreeManager
:
:
StopAutoscroll
(
const
SLGuidAndRenderRoot
&
aGuid
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
if
(
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
aGuid
.
mScrollableLayerGuid
)
)
{
apzc
-
>
StopAutoscroll
(
)
;
}
}
void
APZCTreeManager
:
:
NotifyScrollbarDragInitiated
(
uint64_t
aDragBlockId
const
ScrollableLayerGuid
&
aGuid
ScrollDirection
aDirection
)
const
{
RefPtr
<
GeckoContentController
>
controller
=
GetContentController
(
aGuid
.
mLayersId
)
;
if
(
controller
)
{
controller
-
>
NotifyAsyncScrollbarDragInitiated
(
aDragBlockId
aGuid
.
mScrollId
aDirection
)
;
}
}
void
APZCTreeManager
:
:
NotifyScrollbarDragRejected
(
const
ScrollableLayerGuid
&
aGuid
)
const
{
RefPtr
<
GeckoContentController
>
controller
=
GetContentController
(
aGuid
.
mLayersId
)
;
if
(
controller
)
{
controller
-
>
NotifyAsyncScrollbarDragRejected
(
aGuid
.
mScrollId
)
;
}
}
void
APZCTreeManager
:
:
NotifyAutoscrollRejected
(
const
ScrollableLayerGuid
&
aGuid
)
const
{
RefPtr
<
GeckoContentController
>
controller
=
GetContentController
(
aGuid
.
mLayersId
)
;
MOZ_ASSERT
(
controller
)
;
controller
-
>
NotifyAsyncAutoscrollRejected
(
aGuid
.
mScrollId
)
;
}
template
<
class
ScrollNode
>
HitTestingTreeNode
*
APZCTreeManager
:
:
PrepareNodeForLayer
(
const
RecursiveMutexAutoLock
&
aProofOfTreeLock
const
ScrollNode
&
aLayer
const
FrameMetrics
&
aMetrics
LayersId
aLayersId
const
AncestorTransform
&
aAncestorTransform
HitTestingTreeNode
*
aParent
HitTestingTreeNode
*
aNextSibling
TreeBuildingState
&
aState
wr
:
:
RenderRoot
aRenderRoot
)
{
bool
needsApzc
=
true
;
if
(
!
aMetrics
.
IsScrollable
(
)
)
{
needsApzc
=
false
;
}
RefPtr
<
GeckoContentController
>
geckoContentController
;
RefPtr
<
MetricsSharingController
>
crossProcessSharingController
;
CompositorBridgeParent
:
:
CallWithIndirectShadowTree
(
aLayersId
[
&
]
(
LayerTreeState
&
lts
)
-
>
void
{
geckoContentController
=
lts
.
mController
;
crossProcessSharingController
=
lts
.
CrossProcessSharingController
(
)
;
}
)
;
if
(
!
geckoContentController
)
{
needsApzc
=
false
;
}
bool
parentHasPerspective
=
aState
.
mParentHasPerspective
.
top
(
)
;
if
(
Maybe
<
uint64_t
>
zoomAnimationId
=
aLayer
.
GetZoomAnimationId
(
)
)
{
aState
.
mZoomAnimationId
=
zoomAnimationId
;
}
RefPtr
<
HitTestingTreeNode
>
node
=
nullptr
;
if
(
!
needsApzc
)
{
node
=
RecycleOrCreateNode
(
aProofOfTreeLock
aState
nullptr
aLayersId
)
;
AttachNodeToTree
(
node
aParent
aNextSibling
)
;
node
-
>
SetHitTestData
(
GetEventRegions
(
aLayer
)
aLayer
.
GetVisibleRegion
(
)
aLayer
.
GetRemoteDocumentRect
(
)
aLayer
.
GetTransformTyped
(
)
(
!
parentHasPerspective
&
&
aLayer
.
GetClipRect
(
)
)
?
Some
(
ParentLayerIntRegion
(
*
aLayer
.
GetClipRect
(
)
)
)
:
Nothing
(
)
GetEventRegionsOverride
(
aParent
aLayer
)
aLayer
.
IsBackfaceHidden
(
)
!
!
aLayer
.
IsAsyncZoomContainer
(
)
)
;
node
-
>
SetScrollbarData
(
aLayer
.
GetScrollbarAnimationId
(
)
aLayer
.
GetScrollbarData
(
)
)
;
node
-
>
SetFixedPosData
(
aLayer
.
GetFixedPositionScrollContainerId
(
)
)
;
return
node
;
}
AsyncPanZoomController
*
apzc
=
nullptr
;
ScrollableLayerGuid
guid
(
aLayersId
aMetrics
.
GetPresShellId
(
)
aMetrics
.
GetScrollId
(
)
)
;
auto
insertResult
=
aState
.
mApzcMap
.
insert
(
std
:
:
make_pair
(
guid
static_cast
<
AsyncPanZoomController
*
>
(
nullptr
)
)
)
;
if
(
!
insertResult
.
second
)
{
apzc
=
insertResult
.
first
-
>
second
;
PrintAPZCInfo
(
aLayer
apzc
)
;
}
APZCTM_LOG
(
"
Found
APZC
%
p
for
layer
%
p
with
identifiers
%
"
PRIx64
"
%
"
PRId64
"
\
n
"
apzc
aLayer
.
GetLayer
(
)
uint64_t
(
guid
.
mLayersId
)
guid
.
mScrollId
)
;
if
(
apzc
=
=
nullptr
)
{
apzc
=
aLayer
.
GetApzc
(
)
;
if
(
apzc
&
&
(
!
apzc
-
>
Matches
(
guid
)
|
|
!
apzc
-
>
HasTreeManager
(
this
)
)
)
{
apzc
=
nullptr
;
}
for
(
size_t
i
=
0
;
i
<
aState
.
mNodesToDestroy
.
Length
(
)
;
i
+
+
)
{
RefPtr
<
HitTestingTreeNode
>
n
=
aState
.
mNodesToDestroy
[
i
]
;
if
(
n
-
>
IsPrimaryHolder
(
)
&
&
n
-
>
GetApzc
(
)
&
&
n
-
>
GetApzc
(
)
-
>
Matches
(
guid
)
)
{
node
=
n
;
if
(
apzc
!
=
nullptr
)
{
MOZ_ASSERT
(
apzc
=
=
node
-
>
GetApzc
(
)
)
;
}
apzc
=
node
-
>
GetApzc
(
)
;
break
;
}
}
bool
newApzc
=
(
apzc
=
=
nullptr
|
|
apzc
-
>
IsDestroyed
(
)
)
;
if
(
newApzc
)
{
apzc
=
NewAPZCInstance
(
aLayersId
geckoContentController
aRenderRoot
)
;
apzc
-
>
SetCompositorController
(
aState
.
mCompositorController
.
get
(
)
)
;
if
(
crossProcessSharingController
)
{
apzc
-
>
SetMetricsSharingController
(
crossProcessSharingController
)
;
}
else
{
apzc
-
>
SetMetricsSharingController
(
aState
.
mInProcessSharingController
.
get
(
)
)
;
}
MOZ_ASSERT
(
node
=
=
nullptr
)
;
node
=
new
HitTestingTreeNode
(
apzc
true
aLayersId
)
;
}
else
{
aState
.
mNodesToDestroy
.
RemoveElement
(
node
)
;
node
-
>
SetPrevSibling
(
nullptr
)
;
node
-
>
SetLastChild
(
nullptr
)
;
}
if
(
aMetrics
.
IsRootContent
(
)
)
{
apzc
-
>
SetZoomAnimationId
(
aState
.
mZoomAnimationId
)
;
aState
.
mZoomAnimationId
=
Nothing
(
)
;
}
APZCTM_LOG
(
"
Using
APZC
%
p
for
layer
%
p
with
identifiers
%
"
PRIx64
"
%
"
PRId64
"
\
n
"
apzc
aLayer
.
GetLayer
(
)
uint64_t
(
aLayersId
)
aMetrics
.
GetScrollId
(
)
)
;
apzc
-
>
NotifyLayersUpdated
(
aLayer
.
Metadata
(
)
aState
.
mIsFirstPaint
WRRootId
(
aLayersId
aRenderRoot
)
=
=
aState
.
mOriginatingWrRootId
)
;
MOZ_ASSERT
(
node
-
>
IsPrimaryHolder
(
)
&
&
node
-
>
GetApzc
(
)
&
&
node
-
>
GetApzc
(
)
-
>
Matches
(
guid
)
)
;
Maybe
<
ParentLayerIntRegion
>
clipRegion
=
parentHasPerspective
?
Nothing
(
)
:
ComputeClipRegion
(
aLayer
)
;
node
-
>
SetHitTestData
(
GetEventRegions
(
aLayer
)
aLayer
.
GetVisibleRegion
(
)
aLayer
.
GetRemoteDocumentRect
(
)
aLayer
.
GetTransformTyped
(
)
clipRegion
GetEventRegionsOverride
(
aParent
aLayer
)
aLayer
.
IsBackfaceHidden
(
)
!
!
aLayer
.
IsAsyncZoomContainer
(
)
)
;
apzc
-
>
SetAncestorTransform
(
aAncestorTransform
)
;
PrintAPZCInfo
(
aLayer
apzc
)
;
AttachNodeToTree
(
node
aParent
aNextSibling
)
;
if
(
aLayersId
=
=
aState
.
mOriginatingWrRootId
.
mLayersId
)
{
if
(
apzc
-
>
HasNoParentWithSameLayersId
(
)
)
{
aState
.
mPaintLogger
.
LogTestData
(
aMetrics
.
GetScrollId
(
)
"
hasNoParentWithSameLayersId
"
true
)
;
}
else
{
MOZ_ASSERT
(
apzc
-
>
GetParent
(
)
)
;
aState
.
mPaintLogger
.
LogTestData
(
aMetrics
.
GetScrollId
(
)
"
parentScrollId
"
apzc
-
>
GetParent
(
)
-
>
GetGuid
(
)
.
mScrollId
)
;
}
if
(
aMetrics
.
IsRootContent
(
)
)
{
aState
.
mPaintLogger
.
LogTestData
(
aMetrics
.
GetScrollId
(
)
"
isRootContent
"
true
)
;
}
aState
.
mPaintLogger
.
LogTestData
(
aMetrics
.
GetScrollId
(
)
"
asyncScrollOffset
"
apzc
-
>
GetCurrentAsyncScrollOffset
(
AsyncPanZoomController
:
:
eForHitTesting
)
)
;
aState
.
mPaintLogger
.
LogTestData
(
aMetrics
.
GetScrollId
(
)
"
hasAsyncKeyScrolled
"
apzc
-
>
TestHasAsyncKeyScrolled
(
)
)
;
}
if
(
newApzc
)
{
auto
it
=
mZoomConstraints
.
find
(
guid
)
;
if
(
it
!
=
mZoomConstraints
.
end
(
)
)
{
apzc
-
>
UpdateZoomConstraints
(
it
-
>
second
)
;
}
else
if
(
!
apzc
-
>
HasNoParentWithSameLayersId
(
)
)
{
apzc
-
>
UpdateZoomConstraints
(
apzc
-
>
GetParent
(
)
-
>
GetZoomConstraints
(
)
)
;
}
}
insertResult
.
first
-
>
second
=
apzc
;
}
else
{
node
=
RecycleOrCreateNode
(
aProofOfTreeLock
aState
apzc
aLayersId
)
;
AttachNodeToTree
(
node
aParent
aNextSibling
)
;
if
(
!
aAncestorTransform
.
CombinedTransform
(
)
.
FuzzyEqualsMultiplicative
(
apzc
-
>
GetAncestorTransform
(
)
)
)
{
typedef
TreeBuildingState
:
:
DeferredTransformMap
:
:
value_type
PairType
;
if
(
!
aAncestorTransform
.
ContainsPerspectiveTransform
(
)
&
&
!
apzc
-
>
AncestorTransformContainsPerspective
(
)
)
{
MOZ_ASSERT
(
false
"
Two
layers
that
scroll
together
have
different
ancestor
"
"
transforms
"
)
;
}
else
if
(
!
aAncestorTransform
.
ContainsPerspectiveTransform
(
)
)
{
aState
.
mPerspectiveTransformsDeferredToChildren
.
insert
(
PairType
{
apzc
apzc
-
>
GetAncestorTransformPerspective
(
)
}
)
;
apzc
-
>
SetAncestorTransform
(
aAncestorTransform
)
;
}
else
{
aState
.
mPerspectiveTransformsDeferredToChildren
.
insert
(
PairType
{
apzc
aAncestorTransform
.
GetPerspectiveTransform
(
)
}
)
;
}
}
Maybe
<
ParentLayerIntRegion
>
clipRegion
=
parentHasPerspective
?
Nothing
(
)
:
ComputeClipRegion
(
aLayer
)
;
node
-
>
SetHitTestData
(
GetEventRegions
(
aLayer
)
aLayer
.
GetVisibleRegion
(
)
aLayer
.
GetRemoteDocumentRect
(
)
aLayer
.
GetTransformTyped
(
)
clipRegion
GetEventRegionsOverride
(
aParent
aLayer
)
aLayer
.
IsBackfaceHidden
(
)
!
!
aLayer
.
IsAsyncZoomContainer
(
)
)
;
}
node
-
>
SetScrollbarData
(
aLayer
.
GetScrollbarAnimationId
(
)
aLayer
.
GetScrollbarData
(
)
)
;
node
-
>
SetFixedPosData
(
aLayer
.
GetFixedPositionScrollContainerId
(
)
)
;
return
node
;
}
template
<
typename
PanGestureOrScrollWheelInput
>
static
bool
WillHandleInput
(
const
PanGestureOrScrollWheelInput
&
aPanInput
)
{
if
(
!
XRE_IsParentProcess
(
)
|
|
!
NS_IsMainThread
(
)
)
{
return
true
;
}
WidgetWheelEvent
wheelEvent
=
aPanInput
.
ToWidgetWheelEvent
(
nullptr
)
;
return
APZInputBridge
:
:
ActionForWheelEvent
(
&
wheelEvent
)
.
isSome
(
)
;
}
void
APZCTreeManager
:
:
FlushApzRepaints
(
LayersId
aLayersId
)
{
APZCTM_LOG
(
"
Flushing
repaints
for
layers
id
0x
%
"
PRIx64
"
\
n
"
uint64_t
(
aLayersId
)
)
;
RefPtr
<
GeckoContentController
>
controller
=
GetContentController
(
aLayersId
)
;
#
ifndef
MOZ_WIDGET_ANDROID
MOZ_ASSERT
(
controller
)
;
#
endif
if
(
controller
)
{
controller
-
>
DispatchToRepaintThread
(
NewRunnableMethod
(
"
layers
:
:
GeckoContentController
:
:
NotifyFlushComplete
"
controller
&
GeckoContentController
:
:
NotifyFlushComplete
)
)
;
}
}
void
APZCTreeManager
:
:
MarkAsDetached
(
LayersId
aLayersId
)
{
RecursiveMutexAutoLock
lock
(
mTreeLock
)
;
mDetachedLayersIds
.
insert
(
aLayersId
)
;
}
nsEventStatus
APZCTreeManager
:
:
ReceiveInputEvent
(
InputData
&
aEvent
ScrollableLayerGuid
*
aOutTargetGuid
uint64_t
*
aOutInputBlockId
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
if
(
dom
:
:
BrowserParent
:
:
AreRecordReplayTabsActive
(
)
)
{
return
nsEventStatus_eIgnore
;
}
AutoFocusSequenceNumberSetter
focusSetter
(
mFocusState
aEvent
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
if
(
mToolbarAnimator
)
{
ScreenPoint
scrollOffset
;
{
RecursiveMutexAutoLock
lock
(
mTreeLock
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
FindRootContentOrRootApzc
(
)
;
if
(
apzc
)
{
scrollOffset
=
ViewAs
<
ScreenPixel
>
(
apzc
-
>
GetCurrentAsyncScrollOffset
(
AsyncPanZoomController
:
:
eForHitTesting
)
PixelCastJustification
:
:
ScreenIsParentLayerForRoot
)
;
}
}
RefPtr
<
APZCTreeManager
>
self
=
this
;
nsEventStatus
isConsumed
=
mToolbarAnimator
-
>
ReceiveInputEvent
(
self
aEvent
scrollOffset
)
;
if
(
isConsumed
=
=
nsEventStatus_eConsumeNoDefault
)
{
APZCTM_LOG
(
"
Dynamic
toolbar
consumed
event
"
)
;
return
isConsumed
;
}
}
#
endif
if
(
aOutInputBlockId
)
{
*
aOutInputBlockId
=
InputBlockState
:
:
NO_BLOCK_ID
;
}
nsEventStatus
result
=
nsEventStatus_eIgnore
;
CompositorHitTestInfo
hitResult
=
CompositorHitTestInvisibleToHit
;
switch
(
aEvent
.
mInputType
)
{
case
MULTITOUCH_INPUT
:
{
MultiTouchInput
&
touchInput
=
aEvent
.
AsMultiTouchInput
(
)
;
result
=
ProcessTouchInput
(
touchInput
aOutTargetGuid
aOutInputBlockId
)
;
break
;
}
case
MOUSE_INPUT
:
{
MouseInput
&
mouseInput
=
aEvent
.
AsMouseInput
(
)
;
mouseInput
.
mHandledByAPZ
=
true
;
mCurrentMousePosition
=
mouseInput
.
mOrigin
;
bool
startsDrag
=
DragTracker
:
:
StartsDrag
(
mouseInput
)
;
if
(
startsDrag
)
{
FlushRepaintsToClearScreenToGeckoTransform
(
)
;
}
HitTestingTreeNodeAutoLock
hitScrollbarNode
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
mouseInput
.
mOrigin
&
hitResult
&
aEvent
.
mLayersId
&
hitScrollbarNode
)
;
bool
hitScrollbar
=
(
bool
)
hitScrollbarNode
;
{
RecursiveMutexAutoLock
lock
(
mTreeLock
)
;
if
(
!
apzc
&
&
mRootNode
)
{
apzc
=
mRootNode
-
>
GetApzc
(
)
;
}
}
if
(
apzc
)
{
if
(
StaticPrefs
:
:
apz_test_logging_enabled
(
)
&
&
mouseInput
.
mType
=
=
MouseInput
:
:
MOUSE_HITTEST
)
{
ScrollableLayerGuid
guid
=
apzc
-
>
GetGuid
(
)
;
MutexAutoLock
lock
(
mTestDataLock
)
;
auto
it
=
mTestData
.
find
(
guid
.
mLayersId
)
;
MOZ_ASSERT
(
it
!
=
mTestData
.
end
(
)
)
;
it
-
>
second
-
>
RecordHitResult
(
mouseInput
.
mOrigin
hitResult
guid
.
mLayersId
guid
.
mScrollId
)
;
}
TargetConfirmationFlags
confFlags
{
hitResult
}
;
bool
apzDragEnabled
=
StaticPrefs
:
:
apz_drag_enabled
(
)
;
if
(
apzDragEnabled
&
&
hitScrollbar
)
{
confFlags
.
mTargetConfirmed
=
false
;
}
result
=
mInputQueue
-
>
ReceiveInputEvent
(
apzc
confFlags
mouseInput
aOutInputBlockId
)
;
if
(
apzDragEnabled
&
&
startsDrag
&
&
hitScrollbarNode
&
&
hitScrollbarNode
-
>
IsScrollThumbNode
(
)
&
&
hitScrollbarNode
-
>
GetScrollbarData
(
)
.
mThumbIsAsyncDraggable
)
{
SetupScrollbarDrag
(
mouseInput
hitScrollbarNode
apzc
.
get
(
)
)
;
}
if
(
result
=
=
nsEventStatus_eConsumeDoDefault
)
{
hitScrollbar
=
mInputQueue
-
>
IsDragOnScrollbar
(
hitScrollbar
)
;
}
apzc
-
>
GetGuid
(
aOutTargetGuid
)
;
if
(
!
hitScrollbar
)
{
ScreenToParentLayerMatrix4x4
transformToApzc
=
GetScreenToApzcTransform
(
apzc
)
;
ParentLayerToScreenMatrix4x4
transformToGecko
=
GetApzcToGeckoTransform
(
apzc
)
;
ScreenToScreenMatrix4x4
outTransform
=
transformToApzc
*
transformToGecko
;
Maybe
<
ScreenPoint
>
untransformedRefPoint
=
UntransformBy
(
outTransform
mouseInput
.
mOrigin
)
;
if
(
untransformedRefPoint
)
{
mouseInput
.
mOrigin
=
*
untransformedRefPoint
;
}
}
else
{
aOutTargetGuid
-
>
mScrollId
=
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
;
}
}
break
;
}
case
SCROLLWHEEL_INPUT
:
{
FlushRepaintsToClearScreenToGeckoTransform
(
)
;
ScrollWheelInput
&
wheelInput
=
aEvent
.
AsScrollWheelInput
(
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
wheelInput
.
mOrigin
&
hitResult
&
aEvent
.
mLayersId
)
;
wheelInput
.
mHandledByAPZ
=
WillHandleInput
(
wheelInput
)
;
if
(
!
wheelInput
.
mHandledByAPZ
)
{
return
result
;
}
if
(
apzc
)
{
MOZ_ASSERT
(
hitResult
!
=
CompositorHitTestInvisibleToHit
)
;
if
(
wheelInput
.
mAPZAction
=
=
APZWheelAction
:
:
PinchZoom
)
{
{
RecursiveMutexAutoLock
lock
(
mTreeLock
)
;
apzc
=
FindRootContentApzcForLayersId
(
apzc
-
>
GetLayersId
(
)
)
;
}
if
(
apzc
)
{
SynthesizePinchGestureFromMouseWheel
(
wheelInput
apzc
)
;
}
return
nsEventStatus_eConsumeNoDefault
;
}
MOZ_ASSERT
(
wheelInput
.
mAPZAction
=
=
APZWheelAction
:
:
Scroll
)
;
ScreenToScreenMatrix4x4
transformToGecko
=
GetScreenToApzcTransform
(
apzc
)
*
GetApzcToGeckoTransform
(
apzc
)
;
Maybe
<
ScreenPoint
>
untransformedOrigin
=
UntransformBy
(
transformToGecko
wheelInput
.
mOrigin
)
;
if
(
!
untransformedOrigin
)
{
return
result
;
}
result
=
mInputQueue
-
>
ReceiveInputEvent
(
apzc
TargetConfirmationFlags
{
hitResult
}
wheelInput
aOutInputBlockId
)
;
apzc
-
>
GetGuid
(
aOutTargetGuid
)
;
wheelInput
.
mOrigin
=
*
untransformedOrigin
;
}
break
;
}
case
PANGESTURE_INPUT
:
{
FlushRepaintsToClearScreenToGeckoTransform
(
)
;
PanGestureInput
&
panInput
=
aEvent
.
AsPanGestureInput
(
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
panInput
.
mPanStartPoint
&
hitResult
&
aEvent
.
mLayersId
)
;
panInput
.
mHandledByAPZ
=
WillHandleInput
(
panInput
)
;
if
(
!
panInput
.
mHandledByAPZ
)
{
return
result
;
}
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
WidgetWheelEvent
wheelEvent
=
panInput
.
ToWidgetWheelEvent
(
nullptr
)
;
EventStateManager
:
:
GetUserPrefsForWheelEvent
(
&
wheelEvent
&
panInput
.
mUserDeltaMultiplierX
&
panInput
.
mUserDeltaMultiplierY
)
;
if
(
apzc
)
{
MOZ_ASSERT
(
hitResult
!
=
CompositorHitTestInvisibleToHit
)
;
ScreenToScreenMatrix4x4
transformToGecko
=
GetScreenToApzcTransform
(
apzc
)
*
GetApzcToGeckoTransform
(
apzc
)
;
Maybe
<
ScreenPoint
>
untransformedStartPoint
=
UntransformBy
(
transformToGecko
panInput
.
mPanStartPoint
)
;
Maybe
<
ScreenPoint
>
untransformedDisplacement
=
UntransformVector
(
transformToGecko
panInput
.
mPanDisplacement
panInput
.
mPanStartPoint
)
;
if
(
!
untransformedStartPoint
|
|
!
untransformedDisplacement
)
{
return
result
;
}
result
=
mInputQueue
-
>
ReceiveInputEvent
(
apzc
TargetConfirmationFlags
{
hitResult
}
panInput
aOutInputBlockId
)
;
apzc
-
>
GetGuid
(
aOutTargetGuid
)
;
panInput
.
mPanStartPoint
=
*
untransformedStartPoint
;
panInput
.
mPanDisplacement
=
*
untransformedDisplacement
;
panInput
.
mOverscrollBehaviorAllowsSwipe
=
apzc
-
>
OverscrollBehaviorAllowsSwipe
(
)
;
}
break
;
}
case
PINCHGESTURE_INPUT
:
{
PinchGestureInput
&
pinchInput
=
aEvent
.
AsPinchGestureInput
(
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
pinchInput
.
mFocusPoint
&
hitResult
&
aEvent
.
mLayersId
)
;
if
(
apzc
)
{
MOZ_ASSERT
(
hitResult
!
=
CompositorHitTestInvisibleToHit
)
;
ScreenToScreenMatrix4x4
outTransform
=
GetScreenToApzcTransform
(
apzc
)
*
GetApzcToGeckoTransform
(
apzc
)
;
Maybe
<
ScreenPoint
>
untransformedFocusPoint
=
UntransformBy
(
outTransform
pinchInput
.
mFocusPoint
)
;
if
(
!
untransformedFocusPoint
)
{
return
result
;
}
result
=
mInputQueue
-
>
ReceiveInputEvent
(
apzc
TargetConfirmationFlags
{
hitResult
}
pinchInput
aOutInputBlockId
)
;
apzc
-
>
GetGuid
(
aOutTargetGuid
)
;
pinchInput
.
mFocusPoint
=
*
untransformedFocusPoint
;
}
break
;
}
case
TAPGESTURE_INPUT
:
{
TapGestureInput
&
tapInput
=
aEvent
.
AsTapGestureInput
(
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
tapInput
.
mPoint
&
hitResult
&
aEvent
.
mLayersId
)
;
if
(
apzc
)
{
MOZ_ASSERT
(
hitResult
!
=
CompositorHitTestInvisibleToHit
)
;
ScreenToScreenMatrix4x4
outTransform
=
GetScreenToApzcTransform
(
apzc
)
*
GetApzcToGeckoTransform
(
apzc
)
;
Maybe
<
ScreenIntPoint
>
untransformedPoint
=
UntransformBy
(
outTransform
tapInput
.
mPoint
)
;
if
(
!
untransformedPoint
)
{
return
result
;
}
result
=
mInputQueue
-
>
ReceiveInputEvent
(
apzc
TargetConfirmationFlags
{
hitResult
}
tapInput
aOutInputBlockId
)
;
apzc
-
>
GetGuid
(
aOutTargetGuid
)
;
tapInput
.
mPoint
=
*
untransformedPoint
;
}
break
;
}
case
KEYBOARD_INPUT
:
{
if
(
!
StaticPrefs
:
:
apz_keyboard_enabled_AtStartup
(
)
|
|
StaticPrefs
:
:
accessibility_browsewithcaret
(
)
)
{
APZ_KEY_LOG
(
"
Skipping
key
input
from
invalid
prefs
\
n
"
)
;
return
result
;
}
KeyboardInput
&
keyInput
=
aEvent
.
AsKeyboardInput
(
)
;
Maybe
<
KeyboardShortcut
>
shortcut
=
mKeyboardMap
.
FindMatch
(
keyInput
)
;
if
(
!
shortcut
)
{
APZ_KEY_LOG
(
"
Skipping
key
input
with
no
shortcut
\
n
"
)
;
if
(
mFocusState
.
CanIgnoreKeyboardShortcutMisses
(
)
)
{
focusSetter
.
MarkAsNonFocusChanging
(
)
;
}
return
result
;
}
if
(
shortcut
-
>
mDispatchToContent
)
{
APZ_KEY_LOG
(
"
Skipping
key
input
with
dispatch
-
to
-
content
shortcut
\
n
"
)
;
return
result
;
}
const
KeyboardScrollAction
&
action
=
shortcut
-
>
mAction
;
Maybe
<
ScrollableLayerGuid
>
targetGuid
;
switch
(
action
.
mType
)
{
case
KeyboardScrollAction
:
:
eScrollCharacter
:
{
targetGuid
=
mFocusState
.
GetHorizontalTarget
(
)
;
break
;
}
case
KeyboardScrollAction
:
:
eScrollLine
:
case
KeyboardScrollAction
:
:
eScrollPage
:
case
KeyboardScrollAction
:
:
eScrollComplete
:
{
targetGuid
=
mFocusState
.
GetVerticalTarget
(
)
;
break
;
}
}
if
(
!
targetGuid
)
{
APZ_KEY_LOG
(
"
Skipping
key
input
with
no
current
focus
target
\
n
"
)
;
return
result
;
}
RefPtr
<
AsyncPanZoomController
>
targetApzc
=
GetTargetAPZC
(
targetGuid
-
>
mLayersId
targetGuid
-
>
mScrollId
)
;
if
(
!
targetApzc
)
{
APZ_KEY_LOG
(
"
Skipping
key
input
with
focus
target
but
no
APZC
\
n
"
)
;
return
result
;
}
keyInput
.
mAction
=
action
;
APZ_KEY_LOG
(
"
Dispatching
key
input
with
apzc
=
%
p
\
n
"
targetApzc
.
get
(
)
)
;
result
=
mInputQueue
-
>
ReceiveInputEvent
(
targetApzc
TargetConfirmationFlags
{
true
}
keyInput
aOutInputBlockId
)
;
MOZ_ASSERT
(
result
=
=
nsEventStatus_eConsumeDoDefault
|
|
result
=
=
nsEventStatus_eConsumeNoDefault
)
;
keyInput
.
mHandledByAPZ
=
true
;
focusSetter
.
MarkAsNonFocusChanging
(
)
;
break
;
}
}
return
result
;
}
static
TouchBehaviorFlags
ConvertToTouchBehavior
(
const
CompositorHitTestInfo
&
info
)
{
TouchBehaviorFlags
result
=
AllowedTouchBehavior
:
:
UNKNOWN
;
if
(
info
=
=
CompositorHitTestInvisibleToHit
)
{
result
=
AllowedTouchBehavior
:
:
NONE
;
}
else
if
(
info
.
contains
(
CompositorHitTestFlags
:
:
eIrregularArea
)
)
{
result
=
AllowedTouchBehavior
:
:
UNKNOWN
;
}
else
{
result
=
AllowedTouchBehavior
:
:
VERTICAL_PAN
|
AllowedTouchBehavior
:
:
HORIZONTAL_PAN
|
AllowedTouchBehavior
:
:
PINCH_ZOOM
|
AllowedTouchBehavior
:
:
DOUBLE_TAP_ZOOM
;
if
(
info
.
contains
(
CompositorHitTestFlags
:
:
eTouchActionPanXDisabled
)
)
{
result
&
=
~
AllowedTouchBehavior
:
:
HORIZONTAL_PAN
;
}
if
(
info
.
contains
(
CompositorHitTestFlags
:
:
eTouchActionPanYDisabled
)
)
{
result
&
=
~
AllowedTouchBehavior
:
:
VERTICAL_PAN
;
}
if
(
info
.
contains
(
CompositorHitTestFlags
:
:
eTouchActionPinchZoomDisabled
)
)
{
result
&
=
~
AllowedTouchBehavior
:
:
PINCH_ZOOM
;
}
if
(
info
.
contains
(
CompositorHitTestFlags
:
:
eTouchActionDoubleTapZoomDisabled
)
)
{
result
&
=
~
AllowedTouchBehavior
:
:
DOUBLE_TAP_ZOOM
;
}
}
return
result
;
}
already_AddRefed
<
AsyncPanZoomController
>
APZCTreeManager
:
:
GetTouchInputBlockAPZC
(
const
MultiTouchInput
&
aEvent
nsTArray
<
TouchBehaviorFlags
>
*
aOutTouchBehaviors
CompositorHitTestInfo
*
aOutHitResult
LayersId
*
aOutLayersId
HitTestingTreeNodeAutoLock
*
aOutHitScrollbarNode
)
{
RefPtr
<
AsyncPanZoomController
>
apzc
;
if
(
aEvent
.
mTouches
.
Length
(
)
=
=
0
)
{
return
apzc
.
forget
(
)
;
}
FlushRepaintsToClearScreenToGeckoTransform
(
)
;
CompositorHitTestInfo
hitResult
;
apzc
=
GetTargetAPZC
(
aEvent
.
mTouches
[
0
]
.
mScreenPoint
&
hitResult
aEvent
.
mTouches
.
Length
(
)
=
=
1
?
aOutLayersId
:
nullptr
aOutHitScrollbarNode
)
;
if
(
aOutTouchBehaviors
)
{
aOutTouchBehaviors
-
>
AppendElement
(
ConvertToTouchBehavior
(
hitResult
)
)
;
}
for
(
size_t
i
=
1
;
i
<
aEvent
.
mTouches
.
Length
(
)
;
i
+
+
)
{
RefPtr
<
AsyncPanZoomController
>
apzc2
=
GetTargetAPZC
(
aEvent
.
mTouches
[
i
]
.
mScreenPoint
&
hitResult
nullptr
)
;
if
(
aOutTouchBehaviors
)
{
aOutTouchBehaviors
-
>
AppendElement
(
ConvertToTouchBehavior
(
hitResult
)
)
;
}
apzc
=
GetZoomableTarget
(
apzc
apzc2
)
;
APZCTM_LOG
(
"
Using
APZC
%
p
as
the
root
APZC
for
multi
-
touch
\
n
"
apzc
.
get
(
)
)
;
aOutHitScrollbarNode
-
>
Clear
(
)
;
}
if
(
aOutHitResult
)
{
*
aOutHitResult
=
hitResult
;
}
return
apzc
.
forget
(
)
;
}
nsEventStatus
APZCTreeManager
:
:
ProcessTouchInput
(
MultiTouchInput
&
aInput
ScrollableLayerGuid
*
aOutTargetGuid
uint64_t
*
aOutInputBlockId
)
{
aInput
.
mHandledByAPZ
=
true
;
nsTArray
<
TouchBehaviorFlags
>
touchBehaviors
;
HitTestingTreeNodeAutoLock
hitScrollbarNode
;
if
(
aInput
.
mType
=
=
MultiTouchInput
:
:
MULTITOUCH_START
)
{
if
(
mApzcForInputBlock
&
&
mApzcForInputBlock
-
>
IsInPanningState
(
)
&
&
BuildOverscrollHandoffChain
(
mApzcForInputBlock
)
-
>
HasOverscrolledApzc
(
)
)
{
if
(
mRetainedTouchIdentifier
=
=
-
1
)
{
mRetainedTouchIdentifier
=
mApzcForInputBlock
-
>
GetLastTouchIdentifier
(
)
;
}
return
nsEventStatus_eConsumeNoDefault
;
}
mHitResultForInputBlock
=
CompositorHitTestInvisibleToHit
;
mApzcForInputBlock
=
GetTouchInputBlockAPZC
(
aInput
&
touchBehaviors
&
mHitResultForInputBlock
&
aInput
.
mLayersId
&
hitScrollbarNode
)
;
mInScrollbarTouchDrag
=
StaticPrefs
:
:
apz_drag_enabled
(
)
&
&
StaticPrefs
:
:
apz_drag_touch_enabled
(
)
&
&
hitScrollbarNode
&
&
hitScrollbarNode
-
>
IsScrollThumbNode
(
)
&
&
hitScrollbarNode
-
>
GetScrollbarData
(
)
.
mThumbIsAsyncDraggable
;
MOZ_ASSERT
(
touchBehaviors
.
Length
(
)
=
=
aInput
.
mTouches
.
Length
(
)
)
;
for
(
size_t
i
=
0
;
i
<
touchBehaviors
.
Length
(
)
;
i
+
+
)
{
APZCTM_LOG
(
"
Touch
point
has
allowed
behaviours
0x
%
02x
\
n
"
touchBehaviors
[
i
]
)
;
if
(
touchBehaviors
[
i
]
=
=
AllowedTouchBehavior
:
:
UNKNOWN
)
{
touchBehaviors
.
Clear
(
)
;
break
;
}
}
}
else
if
(
mApzcForInputBlock
)
{
APZCTM_LOG
(
"
Re
-
using
APZC
%
p
as
continuation
of
event
block
\
n
"
mApzcForInputBlock
.
get
(
)
)
;
}
nsEventStatus
result
=
nsEventStatus_eIgnore
;
if
(
mInScrollbarTouchDrag
)
{
result
=
ProcessTouchInputForScrollbarDrag
(
aInput
hitScrollbarNode
aOutTargetGuid
aOutInputBlockId
)
;
}
else
{
if
(
aInput
.
mType
=
=
MultiTouchInput
:
:
MULTITOUCH_CANCEL
)
{
mRetainedTouchIdentifier
=
-
1
;
}
if
(
mRetainedTouchIdentifier
!
=
-
1
)
{
for
(
size_t
j
=
0
;
j
<
aInput
.
mTouches
.
Length
(
)
;
+
+
j
)
{
if
(
aInput
.
mTouches
[
j
]
.
mIdentifier
!
=
mRetainedTouchIdentifier
)
{
aInput
.
mTouches
.
RemoveElementAt
(
j
)
;
if
(
!
touchBehaviors
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
touchBehaviors
.
Length
(
)
>
j
)
;
touchBehaviors
.
RemoveElementAt
(
j
)
;
}
-
-
j
;
}
}
if
(
aInput
.
mTouches
.
IsEmpty
(
)
)
{
return
nsEventStatus_eConsumeNoDefault
;
}
}
if
(
mApzcForInputBlock
)
{
MOZ_ASSERT
(
mHitResultForInputBlock
!
=
CompositorHitTestInvisibleToHit
)
;
mApzcForInputBlock
-
>
GetGuid
(
aOutTargetGuid
)
;
uint64_t
inputBlockId
=
0
;
result
=
mInputQueue
-
>
ReceiveInputEvent
(
mApzcForInputBlock
TargetConfirmationFlags
{
mHitResultForInputBlock
}
aInput
&
inputBlockId
touchBehaviors
.
IsEmpty
(
)
?
Nothing
(
)
:
Some
(
touchBehaviors
)
)
;
if
(
aOutInputBlockId
)
{
*
aOutInputBlockId
=
inputBlockId
;
}
ScreenToParentLayerMatrix4x4
transformToApzc
=
GetScreenToApzcTransform
(
mApzcForInputBlock
)
;
ParentLayerToScreenMatrix4x4
transformToGecko
=
GetApzcToGeckoTransform
(
mApzcForInputBlock
)
;
ScreenToScreenMatrix4x4
outTransform
=
transformToApzc
*
transformToGecko
;
for
(
size_t
i
=
0
;
i
<
aInput
.
mTouches
.
Length
(
)
;
i
+
+
)
{
SingleTouchData
&
touchData
=
aInput
.
mTouches
[
i
]
;
Maybe
<
ScreenIntPoint
>
untransformedScreenPoint
=
UntransformBy
(
outTransform
touchData
.
mScreenPoint
)
;
if
(
!
untransformedScreenPoint
)
{
return
nsEventStatus_eIgnore
;
}
touchData
.
mScreenPoint
=
*
untransformedScreenPoint
;
}
}
}
mTouchCounter
.
Update
(
aInput
)
;
if
(
mTouchCounter
.
GetActiveTouchCount
(
)
=
=
0
)
{
mApzcForInputBlock
=
nullptr
;
mHitResultForInputBlock
=
CompositorHitTestInvisibleToHit
;
mRetainedTouchIdentifier
=
-
1
;
mInScrollbarTouchDrag
=
false
;
}
return
result
;
}
static
MouseInput
:
:
MouseType
MultiTouchTypeToMouseType
(
MultiTouchInput
:
:
MultiTouchType
aType
)
{
switch
(
aType
)
{
case
MultiTouchInput
:
:
MULTITOUCH_START
:
return
MouseInput
:
:
MOUSE_DOWN
;
case
MultiTouchInput
:
:
MULTITOUCH_MOVE
:
return
MouseInput
:
:
MOUSE_MOVE
;
case
MultiTouchInput
:
:
MULTITOUCH_END
:
case
MultiTouchInput
:
:
MULTITOUCH_CANCEL
:
return
MouseInput
:
:
MOUSE_UP
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
multi
-
touch
type
"
)
;
return
MouseInput
:
:
MOUSE_NONE
;
}
nsEventStatus
APZCTreeManager
:
:
ProcessTouchInputForScrollbarDrag
(
MultiTouchInput
&
aTouchInput
const
HitTestingTreeNodeAutoLock
&
aScrollThumbNode
ScrollableLayerGuid
*
aOutTargetGuid
uint64_t
*
aOutInputBlockId
)
{
MOZ_ASSERT
(
mRetainedTouchIdentifier
=
=
-
1
)
;
MOZ_ASSERT
(
mApzcForInputBlock
)
;
MOZ_ASSERT
(
aTouchInput
.
mTouches
.
Length
(
)
=
=
1
)
;
MouseInput
mouseInput
{
MultiTouchTypeToMouseType
(
aTouchInput
.
mType
)
MouseInput
:
:
LEFT_BUTTON
dom
:
:
MouseEvent_Binding
:
:
MOZ_SOURCE_TOUCH
MouseButtonsFlag
:
:
eLeftFlag
aTouchInput
.
mTouches
[
0
]
.
mScreenPoint
aTouchInput
.
mTime
aTouchInput
.
mTimeStamp
aTouchInput
.
modifiers
}
;
mouseInput
.
mHandledByAPZ
=
true
;
TargetConfirmationFlags
targetConfirmed
{
false
}
;
nsEventStatus
result
=
mInputQueue
-
>
ReceiveInputEvent
(
mApzcForInputBlock
targetConfirmed
mouseInput
aOutInputBlockId
)
;
if
(
aScrollThumbNode
)
{
SetupScrollbarDrag
(
mouseInput
aScrollThumbNode
mApzcForInputBlock
.
get
(
)
)
;
}
mApzcForInputBlock
-
>
GetGuid
(
aOutTargetGuid
)
;
aOutTargetGuid
-
>
mScrollId
=
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
;
return
result
;
}
void
APZCTreeManager
:
:
SetupScrollbarDrag
(
MouseInput
&
aMouseInput
const
HitTestingTreeNodeAutoLock
&
aScrollThumbNode
AsyncPanZoomController
*
aApzc
)
{
DragBlockState
*
dragBlock
=
mInputQueue
-
>
GetCurrentDragBlock
(
)
;
if
(
!
dragBlock
)
{
return
;
}
const
ScrollbarData
&
thumbData
=
aScrollThumbNode
-
>
GetScrollbarData
(
)
;
MOZ_ASSERT
(
thumbData
.
mDirection
.
isSome
(
)
)
;
dragBlock
-
>
SetInitialThumbPos
(
thumbData
.
mThumbStart
)
;
if
(
StaticPrefs
:
:
apz_drag_initial_enabled
(
)
&
&
aScrollThumbNode
-
>
GetScrollTargetId
(
)
=
=
aApzc
-
>
GetGuid
(
)
.
mScrollId
&
&
!
aApzc
-
>
IsScrollInfoLayer
(
)
)
{
uint64_t
dragBlockId
=
dragBlock
-
>
GetBlockId
(
)
;
aMouseInput
.
TransformToLocal
(
aApzc
-
>
GetTransformToThis
(
)
)
;
CSSCoord
dragStart
=
aApzc
-
>
ConvertScrollbarPoint
(
aMouseInput
.
mLocalOrigin
thumbData
)
;
LayerToParentLayerMatrix4x4
thumbTransform
;
{
RecursiveMutexAutoLock
lock
(
mTreeLock
)
;
thumbTransform
=
ComputeTransformForNode
(
aScrollThumbNode
.
Get
(
lock
)
)
;
}
CSSCoord
thumbStart
=
thumbData
.
mThumbStart
+
(
(
*
thumbData
.
mDirection
=
=
ScrollDirection
:
:
eHorizontal
)
?
thumbTransform
.
_41
:
thumbTransform
.
_42
)
;
dragStart
-
=
thumbStart
;
dragBlock
-
>
SetContentResponse
(
false
)
;
NotifyScrollbarDragInitiated
(
dragBlockId
aApzc
-
>
GetGuid
(
)
*
thumbData
.
mDirection
)
;
mInputQueue
-
>
ConfirmDragBlock
(
dragBlockId
aApzc
AsyncDragMetrics
(
aApzc
-
>
GetGuid
(
)
.
mScrollId
aApzc
-
>
GetGuid
(
)
.
mPresShellId
dragBlockId
dragStart
*
thumbData
.
mDirection
)
)
;
}
}
void
APZCTreeManager
:
:
SynthesizePinchGestureFromMouseWheel
(
const
ScrollWheelInput
&
aWheelInput
const
RefPtr
<
AsyncPanZoomController
>
&
aTarget
)
{
MOZ_ASSERT
(
aTarget
)
;
ScreenPoint
focusPoint
=
aWheelInput
.
mOrigin
;
ScreenCoord
oldSpan
=
100
;
ScreenCoord
newSpan
=
oldSpan
+
aWheelInput
.
mDeltaY
;
TargetConfirmationFlags
confFlags
{
true
}
;
PinchGestureInput
pinchStart
{
PinchGestureInput
:
:
PINCHGESTURE_START
aWheelInput
.
mTime
aWheelInput
.
mTimeStamp
ExternalPoint
(
0
0
)
focusPoint
oldSpan
oldSpan
aWheelInput
.
modifiers
}
;
PinchGestureInput
pinchScale1
{
PinchGestureInput
:
:
PINCHGESTURE_SCALE
aWheelInput
.
mTime
aWheelInput
.
mTimeStamp
ExternalPoint
(
0
0
)
focusPoint
oldSpan
oldSpan
aWheelInput
.
modifiers
}
;
PinchGestureInput
pinchScale2
{
PinchGestureInput
:
:
PINCHGESTURE_SCALE
aWheelInput
.
mTime
aWheelInput
.
mTimeStamp
ExternalPoint
(
0
0
)
focusPoint
oldSpan
newSpan
aWheelInput
.
modifiers
}
;
PinchGestureInput
pinchEnd
{
PinchGestureInput
:
:
PINCHGESTURE_END
aWheelInput
.
mTime
aWheelInput
.
mTimeStamp
ExternalPoint
(
0
0
)
PinchGestureInput
:
:
BothFingersLifted
<
ScreenPixel
>
(
)
newSpan
newSpan
aWheelInput
.
modifiers
}
;
mInputQueue
-
>
ReceiveInputEvent
(
aTarget
confFlags
pinchStart
nullptr
)
;
mInputQueue
-
>
ReceiveInputEvent
(
aTarget
confFlags
pinchScale1
nullptr
)
;
mInputQueue
-
>
ReceiveInputEvent
(
aTarget
confFlags
pinchScale2
nullptr
)
;
mInputQueue
-
>
ReceiveInputEvent
(
aTarget
confFlags
pinchEnd
nullptr
)
;
}
void
APZCTreeManager
:
:
UpdateWheelTransaction
(
LayoutDeviceIntPoint
aRefPoint
EventMessage
aEventMessage
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
WheelBlockState
*
txn
=
mInputQueue
-
>
GetActiveWheelTransaction
(
)
;
if
(
!
txn
)
{
return
;
}
if
(
txn
-
>
MaybeTimeout
(
TimeStamp
:
:
Now
(
)
)
)
{
return
;
}
switch
(
aEventMessage
)
{
case
eMouseMove
:
case
eDragOver
:
{
ScreenIntPoint
point
=
ViewAs
<
ScreenPixel
>
(
aRefPoint
PixelCastJustification
:
:
LayoutDeviceIsScreenForUntransformedEvent
)
;
txn
-
>
OnMouseMove
(
point
)
;
return
;
}
case
eKeyPress
:
case
eKeyUp
:
case
eKeyDown
:
case
eMouseUp
:
case
eMouseDown
:
case
eMouseDoubleClick
:
case
eMouseAuxClick
:
case
eMouseClick
:
case
eContextMenu
:
case
eDrop
:
txn
-
>
EndTransaction
(
)
;
return
;
default
:
break
;
}
}
void
APZCTreeManager
:
:
ProcessUnhandledEvent
(
LayoutDeviceIntPoint
*
aRefPoint
ScrollableLayerGuid
*
aOutTargetGuid
uint64_t
*
aOutFocusSequenceNumber
LayersId
*
aOutLayersId
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
CompositorHitTestInfo
hitResult
=
CompositorHitTestInvisibleToHit
;
PixelCastJustification
LDIsScreen
=
PixelCastJustification
:
:
LayoutDeviceIsScreenForUntransformedEvent
;
ScreenIntPoint
refPointAsScreen
=
ViewAs
<
ScreenPixel
>
(
*
aRefPoint
LDIsScreen
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
refPointAsScreen
&
hitResult
aOutLayersId
)
;
if
(
apzc
)
{
MOZ_ASSERT
(
hitResult
!
=
CompositorHitTestInvisibleToHit
)
;
apzc
-
>
GetGuid
(
aOutTargetGuid
)
;
ScreenToParentLayerMatrix4x4
transformToApzc
=
GetScreenToApzcTransform
(
apzc
)
;
ParentLayerToScreenMatrix4x4
transformToGecko
=
GetApzcToGeckoTransform
(
apzc
)
;
ScreenToScreenMatrix4x4
outTransform
=
transformToApzc
*
transformToGecko
;
Maybe
<
ScreenIntPoint
>
untransformedRefPoint
=
UntransformBy
(
outTransform
refPointAsScreen
)
;
if
(
untransformedRefPoint
)
{
*
aRefPoint
=
ViewAs
<
LayoutDevicePixel
>
(
*
untransformedRefPoint
LDIsScreen
)
;
}
}
mFocusState
.
ReceiveFocusChangingEvent
(
)
;
*
aOutFocusSequenceNumber
=
mFocusState
.
LastAPZProcessedEvent
(
)
;
}
void
APZCTreeManager
:
:
ProcessDynamicToolbarMovement
(
uint32_t
aStartTimestampMs
uint32_t
aEndTimestampMs
ScreenCoord
aDeltaY
)
{
if
(
mApzcForInputBlock
)
{
mApzcForInputBlock
-
>
HandleDynamicToolbarMovement
(
aStartTimestampMs
aEndTimestampMs
ViewAs
<
ParentLayerPixel
>
(
aDeltaY
PixelCastJustification
:
:
ScreenIsParentLayerForRoot
)
)
;
}
}
void
APZCTreeManager
:
:
SetKeyboardMap
(
const
KeyboardMap
&
aKeyboardMap
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
mKeyboardMap
=
aKeyboardMap
;
}
void
APZCTreeManager
:
:
ZoomToRect
(
const
SLGuidAndRenderRoot
&
aGuid
const
CSSRect
&
aRect
const
uint32_t
aFlags
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
aGuid
.
mScrollableLayerGuid
)
;
if
(
apzc
)
{
apzc
-
>
ZoomToRect
(
aRect
aFlags
)
;
}
}
void
APZCTreeManager
:
:
ContentReceivedInputBlock
(
uint64_t
aInputBlockId
bool
aPreventDefault
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
mInputQueue
-
>
ContentReceivedInputBlock
(
aInputBlockId
aPreventDefault
)
;
}
void
APZCTreeManager
:
:
SetTargetAPZC
(
uint64_t
aInputBlockId
const
nsTArray
<
SLGuidAndRenderRoot
>
&
aTargets
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
RefPtr
<
AsyncPanZoomController
>
target
=
nullptr
;
if
(
aTargets
.
Length
(
)
>
0
)
{
target
=
GetTargetAPZC
(
aTargets
[
0
]
.
mScrollableLayerGuid
)
;
}
for
(
size_t
i
=
1
;
i
<
aTargets
.
Length
(
)
;
i
+
+
)
{
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
aTargets
[
i
]
.
mScrollableLayerGuid
)
;
target
=
GetZoomableTarget
(
target
apzc
)
;
}
mInputQueue
-
>
SetConfirmedTargetApzc
(
aInputBlockId
target
)
;
}
void
APZCTreeManager
:
:
UpdateZoomConstraints
(
const
SLGuidAndRenderRoot
&
aGuid
const
Maybe
<
ZoomConstraints
>
&
aConstraints
)
{
if
(
!
GetUpdater
(
)
-
>
IsUpdaterThread
(
)
)
{
GetUpdater
(
)
-
>
RunOnUpdaterThread
(
UpdaterQueueSelector
(
aGuid
.
GetWRRootId
(
)
)
NewRunnableMethod
<
SLGuidAndRenderRoot
Maybe
<
ZoomConstraints
>
>
(
"
APZCTreeManager
:
:
UpdateZoomConstraints
"
this
&
APZCTreeManager
:
:
UpdateZoomConstraints
aGuid
aConstraints
)
)
;
return
;
}
AssertOnUpdaterThread
(
)
;
ScrollableLayerGuid
guid
=
aGuid
.
mScrollableLayerGuid
;
RecursiveMutexAutoLock
lock
(
mTreeLock
)
;
RefPtr
<
HitTestingTreeNode
>
node
=
GetTargetNode
(
guid
nullptr
)
;
MOZ_ASSERT
(
!
node
|
|
node
-
>
GetApzc
(
)
)
;
if
(
aConstraints
)
{
APZCTM_LOG
(
"
Recording
constraints
%
s
for
guid
%
s
\
n
"
Stringify
(
aConstraints
.
value
(
)
)
.
c_str
(
)
Stringify
(
guid
)
.
c_str
(
)
)
;
mZoomConstraints
[
guid
]
=
aConstraints
.
ref
(
)
;
}
else
{
APZCTM_LOG
(
"
Removing
constraints
for
guid
%
s
\
n
"
Stringify
(
guid
)
.
c_str
(
)
)
;
mZoomConstraints
.
erase
(
guid
)
;
}
if
(
node
&
&
aConstraints
)
{
ForEachNode
<
ReverseIterator
>
(
node
.
get
(
)
[
&
aConstraints
&
node
this
]
(
HitTestingTreeNode
*
aNode
)
{
if
(
aNode
!
=
node
)
{
if
(
AsyncPanZoomController
*
childApzc
=
aNode
-
>
GetApzc
(
)
)
{
if
(
childApzc
-
>
HasNoParentWithSameLayersId
(
)
|
|
this
-
>
mZoomConstraints
.
find
(
childApzc
-
>
GetGuid
(
)
)
!
=
this
-
>
mZoomConstraints
.
end
(
)
)
{
return
TraversalFlag
:
:
Skip
;
}
}
}
if
(
aNode
-
>
IsPrimaryHolder
(
)
)
{
MOZ_ASSERT
(
aNode
-
>
GetApzc
(
)
)
;
aNode
-
>
GetApzc
(
)
-
>
UpdateZoomConstraints
(
aConstraints
.
ref
(
)
)
;
}
return
TraversalFlag
:
:
Continue
;
}
)
;
}
}
void
APZCTreeManager
:
:
FlushRepaintsToClearScreenToGeckoTransform
(
)
{
RecursiveMutexAutoLock
lock
(
mTreeLock
)
;
ForEachNode
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
]
(
HitTestingTreeNode
*
aNode
)
{
if
(
aNode
-
>
IsPrimaryHolder
(
)
)
{
MOZ_ASSERT
(
aNode
-
>
GetApzc
(
)
)
;
aNode
-
>
GetApzc
(
)
-
>
FlushRepaintForNewInputBlock
(
)
;
}
}
)
;
}
void
APZCTreeManager
:
:
AdjustScrollForSurfaceShift
(
const
ScreenPoint
&
aShift
)
{
RecursiveMutexAutoLock
lock
(
mTreeLock
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
FindRootContentOrRootApzc
(
)
;
if
(
apzc
)
{
apzc
-
>
AdjustScrollForSurfaceShift
(
aShift
)
;
}
}
void
APZCTreeManager
:
:
ClearTree
(
)
{
AssertOnUpdaterThread
(
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
if
(
mToolbarAnimator
)
{
mToolbarAnimator
-
>
ClearTreeManager
(
)
;
}
#
endif
APZThreadUtils
:
:
RunOnControllerThread
(
NewRunnableMethod
(
"
layers
:
:
InputQueue
:
:
Clear
"
mInputQueue
&
InputQueue
:
:
Clear
)
)
;
RecursiveMutexAutoLock
lock
(
mTreeLock
)
;
nsTArray
<
RefPtr
<
HitTestingTreeNode
>
>
nodesToDestroy
;
ForEachNode
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
&
nodesToDestroy
]
(
HitTestingTreeNode
*
aNode
)
{
nodesToDestroy
.
AppendElement
(
aNode
)
;
}
)
;
for
(
size_t
i
=
0
;
i
<
nodesToDestroy
.
Length
(
)
;
i
+
+
)
{
nodesToDestroy
[
i
]
-
>
Destroy
(
)
;
}
mRootNode
=
nullptr
;
RefPtr
<
APZCTreeManager
>
self
(
this
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
layers
:
:
APZCTreeManager
:
:
ClearTree
"
[
self
]
{
self
-
>
mFlushObserver
-
>
Unregister
(
)
;
self
-
>
mFlushObserver
=
nullptr
;
}
)
)
;
}
RefPtr
<
HitTestingTreeNode
>
APZCTreeManager
:
:
GetRootNode
(
)
const
{
RecursiveMutexAutoLock
lock
(
mTreeLock
)
;
return
mRootNode
;
}
static
bool
TransformDisplacement
(
APZCTreeManager
*
aTreeManager
AsyncPanZoomController
*
aSource
AsyncPanZoomController
*
aTarget
ParentLayerPoint
&
aStartPoint
ParentLayerPoint
&
aEndPoint
)
{
if
(
aSource
=
=
aTarget
)
{
return
true
;
}
ParentLayerToScreenMatrix4x4
untransformToApzc
=
aTreeManager
-
>
GetScreenToApzcTransform
(
aSource
)
.
Inverse
(
)
;
ScreenPoint
screenStart
=
TransformBy
(
untransformToApzc
aStartPoint
)
;
ScreenPoint
screenEnd
=
TransformBy
(
untransformToApzc
aEndPoint
)
;
ScreenToParentLayerMatrix4x4
transformToApzc
=
aTreeManager
-
>
GetScreenToApzcTransform
(
aTarget
)
;
Maybe
<
ParentLayerPoint
>
startPoint
=
UntransformBy
(
transformToApzc
screenStart
)
;
Maybe
<
ParentLayerPoint
>
endPoint
=
UntransformBy
(
transformToApzc
screenEnd
)
;
if
(
!
startPoint
|
|
!
endPoint
)
{
return
false
;
}
aEndPoint
=
*
endPoint
;
aStartPoint
=
*
startPoint
;
return
true
;
}
void
APZCTreeManager
:
:
DispatchScroll
(
AsyncPanZoomController
*
aPrev
ParentLayerPoint
&
aStartPoint
ParentLayerPoint
&
aEndPoint
OverscrollHandoffState
&
aOverscrollHandoffState
)
{
const
OverscrollHandoffChain
&
overscrollHandoffChain
=
aOverscrollHandoffState
.
mChain
;
uint32_t
overscrollHandoffChainIndex
=
aOverscrollHandoffState
.
mChainIndex
;
RefPtr
<
AsyncPanZoomController
>
next
;
if
(
overscrollHandoffChainIndex
>
=
overscrollHandoffChain
.
Length
(
)
)
{
return
;
}
next
=
overscrollHandoffChain
.
GetApzcAtIndex
(
overscrollHandoffChainIndex
)
;
if
(
next
=
=
nullptr
|
|
next
-
>
IsDestroyed
(
)
)
{
return
;
}
if
(
!
TransformDisplacement
(
this
aPrev
next
aStartPoint
aEndPoint
)
)
{
return
;
}
if
(
!
next
-
>
AttemptScroll
(
aStartPoint
aEndPoint
aOverscrollHandoffState
)
)
{
if
(
!
TransformDisplacement
(
this
next
aPrev
aStartPoint
aEndPoint
)
)
{
NS_WARNING
(
"
Failed
to
untransform
scroll
points
during
dispatch
"
)
;
}
}
}
ParentLayerPoint
APZCTreeManager
:
:
DispatchFling
(
AsyncPanZoomController
*
aPrev
const
FlingHandoffState
&
aHandoffState
)
{
if
(
aHandoffState
.
mIsHandoff
&
&
!
StaticPrefs
:
:
apz_allow_immediate_handoff
(
)
&
&
aHandoffState
.
mScrolledApzc
=
=
aPrev
)
{
FLING_LOG
(
"
APZCTM
dropping
handoff
due
to
disallowed
immediate
handoff
\
n
"
)
;
return
aHandoffState
.
mVelocity
;
}
const
OverscrollHandoffChain
*
chain
=
aHandoffState
.
mChain
;
RefPtr
<
AsyncPanZoomController
>
current
;
uint32_t
overscrollHandoffChainLength
=
chain
-
>
Length
(
)
;
uint32_t
startIndex
;
ParentLayerPoint
startPoint
;
ParentLayerPoint
endPoint
;
if
(
aHandoffState
.
mIsHandoff
)
{
startIndex
=
chain
-
>
IndexOf
(
aPrev
)
+
1
;
if
(
startIndex
>
=
overscrollHandoffChainLength
)
{
return
aHandoffState
.
mVelocity
;
}
}
else
{
startIndex
=
0
;
}
ParentLayerPoint
finalResidualVelocity
=
aHandoffState
.
mVelocity
;
ParentLayerPoint
currentVelocity
=
aHandoffState
.
mVelocity
;
for
(
;
startIndex
<
overscrollHandoffChainLength
;
startIndex
+
+
)
{
current
=
chain
-
>
GetApzcAtIndex
(
startIndex
)
;
if
(
current
=
=
nullptr
|
|
current
-
>
IsDestroyed
(
)
)
{
break
;
}
endPoint
=
startPoint
+
currentVelocity
;
RefPtr
<
AsyncPanZoomController
>
prevApzc
=
(
startIndex
>
0
)
?
chain
-
>
GetApzcAtIndex
(
startIndex
-
1
)
:
nullptr
;
if
(
prevApzc
)
{
if
(
!
TransformDisplacement
(
this
prevApzc
current
startPoint
endPoint
)
)
{
break
;
}
}
ParentLayerPoint
availableVelocity
=
(
endPoint
-
startPoint
)
;
ParentLayerPoint
residualVelocity
;
FlingHandoffState
transformedHandoffState
=
aHandoffState
;
transformedHandoffState
.
mVelocity
=
availableVelocity
;
if
(
prevApzc
)
{
residualVelocity
+
=
prevApzc
-
>
AdjustHandoffVelocityForOverscrollBehavior
(
transformedHandoffState
.
mVelocity
)
;
}
residualVelocity
+
=
current
-
>
AttemptFling
(
transformedHandoffState
)
;
if
(
IsZero
(
residualVelocity
)
)
{
return
ParentLayerPoint
(
)
;
}
if
(
!
FuzzyEqualsAdditive
(
availableVelocity
.
x
residualVelocity
.
x
COORDINATE_EPSILON
)
)
{
finalResidualVelocity
.
x
*
=
(
residualVelocity
.
x
/
availableVelocity
.
x
)
;
}
if
(
!
FuzzyEqualsAdditive
(
availableVelocity
.
y
residualVelocity
.
y
COORDINATE_EPSILON
)
)
{
finalResidualVelocity
.
y
*
=
(
residualVelocity
.
y
/
availableVelocity
.
y
)
;
}
currentVelocity
=
residualVelocity
;
}
return
finalResidualVelocity
;
}
bool
APZCTreeManager
:
:
HitTestAPZC
(
const
ScreenIntPoint
&
aPoint
)
{
RefPtr
<
AsyncPanZoomController
>
target
=
GetTargetAPZC
(
aPoint
nullptr
nullptr
)
;
return
target
!
=
nullptr
;
}
already_AddRefed
<
AsyncPanZoomController
>
APZCTreeManager
:
:
GetTargetAPZC
(
const
ScrollableLayerGuid
&
aGuid
)
{
RecursiveMutexAutoLock
lock
(
mTreeLock
)
;
RefPtr
<
HitTestingTreeNode
>
node
=
GetTargetNode
(
aGuid
nullptr
)
;
MOZ_ASSERT
(
!
node
|
|
node
-
>
GetApzc
(
)
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
node
?
node
-
>
GetApzc
(
)
:
nullptr
;
return
apzc
.
forget
(
)
;
}
static
bool
GuidComparatorIgnoringPresShell
(
const
ScrollableLayerGuid
&
aOne
const
ScrollableLayerGuid
&
aTwo
)
{
return
aOne
.
mLayersId
=
=
aTwo
.
mLayersId
&
&
aOne
.
mScrollId
=
=
aTwo
.
mScrollId
;
}
already_AddRefed
<
AsyncPanZoomController
>
APZCTreeManager
:
:
GetTargetAPZC
(
const
LayersId
&
aLayersId
const
ScrollableLayerGuid
:
:
ViewID
&
aScrollId
)
{
MutexAutoLock
lock
(
mMapLock
)
;
ScrollableLayerGuid
guid
(
aLayersId
0
aScrollId
)
;
auto
it
=
mApzcMap
.
find
(
guid
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
(
it
!
=
mApzcMap
.
end
(
)
?
it
-
>
second
:
nullptr
)
;
return
apzc
.
forget
(
)
;
}
already_AddRefed
<
HitTestingTreeNode
>
APZCTreeManager
:
:
GetTargetNode
(
const
ScrollableLayerGuid
&
aGuid
GuidComparator
aComparator
)
const
{
mTreeLock
.
AssertCurrentThreadIn
(
)
;
RefPtr
<
HitTestingTreeNode
>
target
=
DepthFirstSearchPostOrder
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
&
aGuid
&
aComparator
]
(
HitTestingTreeNode
*
node
)
{
bool
matches
=
false
;
if
(
node
-
>
GetApzc
(
)
)
{
if
(
aComparator
)
{
matches
=
aComparator
(
aGuid
node
-
>
GetApzc
(
)
-
>
GetGuid
(
)
)
;
}
else
{
matches
=
node
-
>
GetApzc
(
)
-
>
Matches
(
aGuid
)
;
}
}
return
matches
;
}
)
;
return
target
.
forget
(
)
;
}
already_AddRefed
<
AsyncPanZoomController
>
APZCTreeManager
:
:
GetTargetAPZC
(
const
ScreenPoint
&
aPoint
CompositorHitTestInfo
*
aOutHitResult
LayersId
*
aOutLayersId
HitTestingTreeNodeAutoLock
*
aOutScrollbarNode
)
{
RecursiveMutexAutoLock
lock
(
mTreeLock
)
;
CompositorHitTestInfo
hitResult
;
HitTestingTreeNode
*
scrollbarNode
=
nullptr
;
RefPtr
<
AsyncPanZoomController
>
target
;
if
(
gfx
:
:
gfxVars
:
:
UseWebRender
(
)
)
{
target
=
GetAPZCAtPointWR
(
aPoint
&
hitResult
aOutLayersId
&
scrollbarNode
)
;
}
else
{
target
=
GetAPZCAtPoint
(
mRootNode
aPoint
&
hitResult
aOutLayersId
&
scrollbarNode
)
;
}
if
(
aOutHitResult
)
{
*
aOutHitResult
=
hitResult
;
}
if
(
aOutScrollbarNode
&
&
scrollbarNode
)
{
RefPtr
<
HitTestingTreeNode
>
scrollbarRef
=
scrollbarNode
;
aOutScrollbarNode
-
>
Initialize
(
lock
scrollbarRef
.
forget
(
)
mTreeLock
)
;
}
return
target
.
forget
(
)
;
}
already_AddRefed
<
AsyncPanZoomController
>
APZCTreeManager
:
:
GetAPZCAtPointWR
(
const
ScreenPoint
&
aHitTestPoint
CompositorHitTestInfo
*
aOutHitResult
LayersId
*
aOutLayersId
HitTestingTreeNode
*
*
aOutScrollbarNode
)
{
MOZ_ASSERT
(
aOutHitResult
)
;
MOZ_ASSERT
(
aOutScrollbarNode
)
;
RefPtr
<
AsyncPanZoomController
>
result
;
RefPtr
<
wr
:
:
WebRenderAPI
>
wr
=
GetWebRenderAPIAtPoint
(
aHitTestPoint
)
;
if
(
!
wr
)
{
result
=
FindRootApzcForLayersId
(
mRootLayersId
)
;
*
aOutHitResult
=
CompositorHitTestFlags
:
:
eVisibleToHitTest
;
return
result
.
forget
(
)
;
}
wr
:
:
WrPipelineId
pipelineId
;
ScrollableLayerGuid
:
:
ViewID
scrollId
;
gfx
:
:
CompositorHitTestInfo
hitInfo
;
bool
hitSomething
=
wr
-
>
HitTest
(
wr
:
:
ToWorldPoint
(
aHitTestPoint
)
pipelineId
scrollId
hitInfo
)
;
if
(
!
hitSomething
)
{
return
result
.
forget
(
)
;
}
LayersId
layersId
=
wr
:
:
AsLayersId
(
pipelineId
)
;
if
(
aOutLayersId
)
{
*
aOutLayersId
=
layersId
;
}
ScrollableLayerGuid
guid
{
layersId
0
scrollId
}
;
if
(
RefPtr
<
HitTestingTreeNode
>
node
=
GetTargetNode
(
guid
&
GuidComparatorIgnoringPresShell
)
)
{
MOZ_ASSERT
(
node
-
>
GetApzc
(
)
)
;
result
=
node
-
>
GetApzc
(
)
;
EventRegionsOverride
flags
=
node
-
>
GetEventRegionsOverride
(
)
;
if
(
flags
&
EventRegionsOverride
:
:
ForceDispatchToContent
)
{
hitInfo
+
=
CompositorHitTestFlags
:
:
eApzAwareListeners
;
}
}
APZCTM_LOG
(
"
Successfully
matched
APZC
%
p
(
hit
result
0x
%
x
)
\
n
"
result
.
get
(
)
hitInfo
.
serialize
(
)
)
;
if
(
!
result
)
{
MOZ_ASSERT
(
scrollId
=
=
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
)
;
result
=
FindRootApzcForLayersId
(
layersId
)
;
MOZ_ASSERT
(
result
)
;
}
const
bool
isScrollbar
=
hitInfo
.
contains
(
gfx
:
:
CompositorHitTestFlags
:
:
eScrollbar
)
;
const
bool
isScrollbarThumb
=
hitInfo
.
contains
(
gfx
:
:
CompositorHitTestFlags
:
:
eScrollbarThumb
)
;
const
ScrollDirection
direction
=
hitInfo
.
contains
(
gfx
:
:
CompositorHitTestFlags
:
:
eScrollbarVertical
)
?
ScrollDirection
:
:
eVertical
:
ScrollDirection
:
:
eHorizontal
;
if
(
isScrollbar
|
|
isScrollbarThumb
)
{
*
aOutScrollbarNode
=
BreadthFirstSearch
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
&
]
(
HitTestingTreeNode
*
aNode
)
{
return
(
aNode
-
>
GetLayersId
(
)
=
=
layersId
)
&
&
(
aNode
-
>
IsScrollbarNode
(
)
=
=
isScrollbar
)
&
&
(
aNode
-
>
IsScrollThumbNode
(
)
=
=
isScrollbarThumb
)
&
&
(
aNode
-
>
GetScrollbarDirection
(
)
=
=
direction
)
&
&
(
aNode
-
>
GetScrollTargetId
(
)
=
=
scrollId
)
;
}
)
;
}
*
aOutHitResult
=
hitInfo
;
return
result
.
forget
(
)
;
}
RefPtr
<
const
OverscrollHandoffChain
>
APZCTreeManager
:
:
BuildOverscrollHandoffChain
(
const
RefPtr
<
AsyncPanZoomController
>
&
aInitialTarget
)
{
RecursiveMutexAutoLock
lock
(
mTreeLock
)
;
OverscrollHandoffChain
*
result
=
new
OverscrollHandoffChain
;
AsyncPanZoomController
*
apzc
=
aInitialTarget
;
while
(
apzc
!
=
nullptr
)
{
result
-
>
Add
(
apzc
)
;
if
(
apzc
-
>
GetScrollHandoffParentId
(
)
=
=
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
)
{
if
(
!
apzc
-
>
IsRootForLayersId
(
)
)
{
NS_WARNING
(
"
Found
a
non
-
root
APZ
with
no
handoff
parent
"
)
;
}
apzc
=
apzc
-
>
GetParent
(
)
;
continue
;
}
MOZ_ASSERT
(
apzc
-
>
GetScrollHandoffParentId
(
)
!
=
apzc
-
>
GetGuid
(
)
.
mScrollId
)
;
RefPtr
<
AsyncPanZoomController
>
scrollParent
=
GetTargetAPZC
(
apzc
-
>
GetGuid
(
)
.
mLayersId
apzc
-
>
GetScrollHandoffParentId
(
)
)
;
apzc
=
scrollParent
.
get
(
)
;
}
result
-
>
SortByScrollPriority
(
)
;
for
(
uint32_t
i
=
0
;
i
<
result
-
>
Length
(
)
;
+
+
i
)
{
APZCTM_LOG
(
"
OverscrollHandoffChain
[
%
d
]
=
%
p
\
n
"
i
result
-
>
GetApzcAtIndex
(
i
)
.
get
(
)
)
;
}
return
result
;
}
void
APZCTreeManager
:
:
SetLongTapEnabled
(
bool
aLongTapEnabled
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
GestureEventListener
:
:
SetLongTapEnabled
(
aLongTapEnabled
)
;
}
void
APZCTreeManager
:
:
FindScrollThumbNode
(
const
AsyncDragMetrics
&
aDragMetrics
HitTestingTreeNodeAutoLock
&
aOutThumbNode
)
{
if
(
!
aDragMetrics
.
mDirection
)
{
return
;
}
RecursiveMutexAutoLock
lock
(
mTreeLock
)
;
RefPtr
<
HitTestingTreeNode
>
result
=
DepthFirstSearch
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
&
aDragMetrics
]
(
HitTestingTreeNode
*
aNode
)
{
return
aNode
-
>
MatchesScrollDragMetrics
(
aDragMetrics
)
;
}
)
;
if
(
result
)
{
aOutThumbNode
.
Initialize
(
lock
result
.
forget
(
)
mTreeLock
)
;
}
}
AsyncPanZoomController
*
APZCTreeManager
:
:
GetTargetApzcForNode
(
HitTestingTreeNode
*
aNode
)
{
for
(
const
HitTestingTreeNode
*
n
=
aNode
;
n
&
&
n
-
>
GetLayersId
(
)
=
=
aNode
-
>
GetLayersId
(
)
;
n
=
n
-
>
GetParent
(
)
)
{
if
(
n
-
>
GetApzc
(
)
)
{
APZCTM_LOG
(
"
Found
target
%
p
using
ancestor
lookup
\
n
"
n
-
>
GetApzc
(
)
)
;
return
n
-
>
GetApzc
(
)
;
}
if
(
n
-
>
GetFixedPosTarget
(
)
!
=
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
)
{
RefPtr
<
AsyncPanZoomController
>
fpTarget
=
GetTargetAPZC
(
n
-
>
GetLayersId
(
)
n
-
>
GetFixedPosTarget
(
)
)
;
APZCTM_LOG
(
"
Found
target
APZC
%
p
using
fixed
-
pos
lookup
on
%
"
PRIu64
"
\
n
"
fpTarget
.
get
(
)
n
-
>
GetFixedPosTarget
(
)
)
;
return
fpTarget
.
get
(
)
;
}
}
return
nullptr
;
}
AsyncPanZoomController
*
APZCTreeManager
:
:
GetAPZCAtPoint
(
HitTestingTreeNode
*
aNode
const
ScreenPoint
&
aHitTestPoint
CompositorHitTestInfo
*
aOutHitResult
LayersId
*
aOutLayersId
HitTestingTreeNode
*
*
aOutScrollbarNode
)
{
mTreeLock
.
AssertCurrentThreadIn
(
)
;
HitTestingTreeNode
*
resultNode
;
HitTestingTreeNode
*
root
=
aNode
;
std
:
:
stack
<
LayerPoint
>
hitTestPoints
;
ParentLayerPoint
point
=
ViewAs
<
ParentLayerPixel
>
(
aHitTestPoint
PixelCastJustification
:
:
ScreenIsParentLayerForRoot
)
;
hitTestPoints
.
push
(
ViewAs
<
LayerPixel
>
(
point
PixelCastJustification
:
:
MovingDownToChildren
)
)
;
ForEachNode
<
ReverseIterator
>
(
root
[
&
hitTestPoints
this
]
(
HitTestingTreeNode
*
aNode
)
{
ParentLayerPoint
hitTestPointForParent
=
ViewAs
<
ParentLayerPixel
>
(
hitTestPoints
.
top
(
)
PixelCastJustification
:
:
MovingDownToChildren
)
;
if
(
aNode
-
>
IsOutsideClip
(
hitTestPointForParent
)
)
{
APZCTM_LOG
(
"
Point
%
f
%
f
outside
clip
for
node
%
p
\
n
"
hitTestPoints
.
top
(
)
.
x
hitTestPoints
.
top
(
)
.
y
aNode
)
;
return
TraversalFlag
:
:
Skip
;
}
Maybe
<
LayerPoint
>
hitTestPoint
=
aNode
-
>
Untransform
(
hitTestPointForParent
ComputeTransformForNode
(
aNode
)
)
;
APZCTM_LOG
(
"
Transformed
ParentLayer
point
%
s
to
layer
%
s
\
n
"
Stringify
(
hitTestPointForParent
)
.
c_str
(
)
hitTestPoint
?
Stringify
(
hitTestPoint
.
ref
(
)
)
.
c_str
(
)
:
"
nil
"
)
;
if
(
!
hitTestPoint
)
{
return
TraversalFlag
:
:
Skip
;
}
hitTestPoints
.
push
(
hitTestPoint
.
ref
(
)
)
;
return
TraversalFlag
:
:
Continue
;
}
[
&
resultNode
&
hitTestPoints
&
aOutHitResult
]
(
HitTestingTreeNode
*
aNode
)
{
CompositorHitTestInfo
hitResult
=
aNode
-
>
HitTest
(
hitTestPoints
.
top
(
)
)
;
hitTestPoints
.
pop
(
)
;
APZCTM_LOG
(
"
Testing
Layer
point
%
s
against
node
%
p
\
n
"
Stringify
(
hitTestPoints
.
top
(
)
)
.
c_str
(
)
aNode
)
;
if
(
hitResult
!
=
CompositorHitTestInvisibleToHit
)
{
resultNode
=
aNode
;
*
aOutHitResult
=
hitResult
;
return
TraversalFlag
:
:
Abort
;
}
return
TraversalFlag
:
:
Continue
;
}
)
;
if
(
*
aOutHitResult
!
=
CompositorHitTestInvisibleToHit
)
{
MOZ_ASSERT
(
resultNode
)
;
for
(
HitTestingTreeNode
*
n
=
resultNode
;
n
;
n
=
n
-
>
GetParent
(
)
)
{
if
(
n
-
>
IsScrollbarNode
(
)
)
{
*
aOutScrollbarNode
=
n
;
*
aOutHitResult
+
=
CompositorHitTestFlags
:
:
eScrollbar
;
if
(
n
-
>
IsScrollThumbNode
(
)
)
{
*
aOutHitResult
+
=
CompositorHitTestFlags
:
:
eScrollbarThumb
;
}
if
(
n
-
>
GetScrollbarDirection
(
)
=
=
ScrollDirection
:
:
eVertical
)
{
*
aOutHitResult
+
=
CompositorHitTestFlags
:
:
eScrollbarVertical
;
}
RefPtr
<
AsyncPanZoomController
>
scrollTarget
=
GetTargetAPZC
(
n
-
>
GetLayersId
(
)
n
-
>
GetScrollTargetId
(
)
)
;
if
(
scrollTarget
)
{
if
(
aOutLayersId
)
{
*
aOutLayersId
=
n
-
>
GetLayersId
(
)
;
}
return
scrollTarget
.
get
(
)
;
}
}
}
AsyncPanZoomController
*
result
=
GetTargetApzcForNode
(
resultNode
)
;
if
(
!
result
)
{
result
=
FindRootApzcForLayersId
(
resultNode
-
>
GetLayersId
(
)
)
;
MOZ_ASSERT
(
result
)
;
APZCTM_LOG
(
"
Found
target
%
p
using
root
lookup
\
n
"
result
)
;
}
APZCTM_LOG
(
"
Successfully
matched
APZC
%
p
via
node
%
p
(
hit
result
0x
%
x
)
\
n
"
result
resultNode
aOutHitResult
-
>
serialize
(
)
)
;
if
(
aOutLayersId
)
{
*
aOutLayersId
=
resultNode
-
>
GetLayersId
(
)
;
}
return
result
;
}
return
nullptr
;
}
AsyncPanZoomController
*
APZCTreeManager
:
:
FindRootApzcForLayersId
(
LayersId
aLayersId
)
const
{
mTreeLock
.
AssertCurrentThreadIn
(
)
;
HitTestingTreeNode
*
resultNode
=
BreadthFirstSearch
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
aLayersId
]
(
HitTestingTreeNode
*
aNode
)
{
AsyncPanZoomController
*
apzc
=
aNode
-
>
GetApzc
(
)
;
return
apzc
&
&
apzc
-
>
GetLayersId
(
)
=
=
aLayersId
&
&
apzc
-
>
IsRootForLayersId
(
)
;
}
)
;
return
resultNode
?
resultNode
-
>
GetApzc
(
)
:
nullptr
;
}
already_AddRefed
<
AsyncPanZoomController
>
APZCTreeManager
:
:
FindZoomableApzc
(
AsyncPanZoomController
*
aStart
)
const
{
return
GetZoomableTarget
(
aStart
aStart
)
;
}
AsyncPanZoomController
*
APZCTreeManager
:
:
FindRootContentApzcForLayersId
(
LayersId
aLayersId
)
const
{
mTreeLock
.
AssertCurrentThreadIn
(
)
;
HitTestingTreeNode
*
resultNode
=
BreadthFirstSearch
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
aLayersId
]
(
HitTestingTreeNode
*
aNode
)
{
AsyncPanZoomController
*
apzc
=
aNode
-
>
GetApzc
(
)
;
return
apzc
&
&
apzc
-
>
GetLayersId
(
)
=
=
aLayersId
&
&
apzc
-
>
IsRootContent
(
)
;
}
)
;
return
resultNode
?
resultNode
-
>
GetApzc
(
)
:
nullptr
;
}
AsyncPanZoomController
*
APZCTreeManager
:
:
FindRootContentOrRootApzc
(
)
const
{
mTreeLock
.
AssertCurrentThreadIn
(
)
;
HitTestingTreeNode
*
resultNode
=
BreadthFirstSearch
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
]
(
HitTestingTreeNode
*
aNode
)
{
AsyncPanZoomController
*
apzc
=
aNode
-
>
GetApzc
(
)
;
return
apzc
&
&
apzc
-
>
IsRootContent
(
)
;
}
)
;
if
(
resultNode
)
{
return
resultNode
-
>
GetApzc
(
)
;
}
resultNode
=
BreadthFirstSearch
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
]
(
HitTestingTreeNode
*
aNode
)
{
AsyncPanZoomController
*
apzc
=
aNode
-
>
GetApzc
(
)
;
return
(
apzc
!
=
nullptr
)
;
}
)
;
return
resultNode
?
resultNode
-
>
GetApzc
(
)
:
nullptr
;
}
ScreenToParentLayerMatrix4x4
APZCTreeManager
:
:
GetScreenToApzcTransform
(
const
AsyncPanZoomController
*
aApzc
)
const
{
Matrix4x4
result
;
RecursiveMutexAutoLock
lock
(
mTreeLock
)
;
Matrix4x4
ancestorUntransform
=
aApzc
-
>
GetAncestorTransform
(
)
.
Inverse
(
)
;
result
=
ancestorUntransform
;
for
(
AsyncPanZoomController
*
parent
=
aApzc
-
>
GetParent
(
)
;
parent
;
parent
=
parent
-
>
GetParent
(
)
)
{
ancestorUntransform
=
parent
-
>
GetAncestorTransform
(
)
.
Inverse
(
)
;
Matrix4x4
asyncUntransform
=
parent
-
>
GetCurrentAsyncTransformWithOverscroll
(
AsyncPanZoomController
:
:
eForHitTesting
)
.
Inverse
(
)
.
ToUnknownMatrix
(
)
;
Matrix4x4
untransformSinceLastApzc
=
ancestorUntransform
*
asyncUntransform
;
result
=
untransformSinceLastApzc
*
result
;
}
return
ViewAs
<
ScreenToParentLayerMatrix4x4
>
(
result
)
;
}
ParentLayerToScreenMatrix4x4
APZCTreeManager
:
:
GetApzcToGeckoTransform
(
const
AsyncPanZoomController
*
aApzc
)
const
{
Matrix4x4
result
;
RecursiveMutexAutoLock
lock
(
mTreeLock
)
;
Matrix4x4
asyncUntransform
=
aApzc
-
>
GetCurrentAsyncTransformWithOverscroll
(
AsyncPanZoomController
:
:
eForHitTesting
)
.
Inverse
(
)
.
ToUnknownMatrix
(
)
;
result
=
asyncUntransform
*
aApzc
-
>
GetTransformToLastDispatchedPaint
(
)
*
aApzc
-
>
GetAncestorTransform
(
)
;
for
(
AsyncPanZoomController
*
parent
=
aApzc
-
>
GetParent
(
)
;
parent
;
parent
=
parent
-
>
GetParent
(
)
)
{
result
=
result
*
parent
-
>
GetTransformToLastDispatchedPaint
(
)
*
parent
-
>
GetAncestorTransform
(
)
;
}
return
ViewAs
<
ParentLayerToScreenMatrix4x4
>
(
result
)
;
}
ScreenPoint
APZCTreeManager
:
:
GetCurrentMousePosition
(
)
const
{
return
mCurrentMousePosition
;
}
already_AddRefed
<
AsyncPanZoomController
>
APZCTreeManager
:
:
GetZoomableTarget
(
AsyncPanZoomController
*
aApzc1
AsyncPanZoomController
*
aApzc2
)
const
{
RecursiveMutexAutoLock
lock
(
mTreeLock
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
;
if
(
aApzc1
&
&
aApzc2
&
&
aApzc1
-
>
GetLayersId
(
)
=
=
aApzc2
-
>
GetLayersId
(
)
)
{
apzc
=
FindRootContentApzcForLayersId
(
aApzc1
-
>
GetLayersId
(
)
)
;
}
else
{
apzc
=
CommonAncestor
(
aApzc1
aApzc2
)
;
if
(
apzc
)
{
apzc
=
FindRootContentApzcForLayersId
(
apzc
-
>
GetLayersId
(
)
)
;
}
}
return
apzc
.
forget
(
)
;
}
already_AddRefed
<
AsyncPanZoomController
>
APZCTreeManager
:
:
CommonAncestor
(
AsyncPanZoomController
*
aApzc1
AsyncPanZoomController
*
aApzc2
)
const
{
mTreeLock
.
AssertCurrentThreadIn
(
)
;
RefPtr
<
AsyncPanZoomController
>
ancestor
;
int
depth1
=
0
depth2
=
0
;
for
(
AsyncPanZoomController
*
parent
=
aApzc1
;
parent
;
parent
=
parent
-
>
GetParent
(
)
)
{
depth1
+
+
;
}
for
(
AsyncPanZoomController
*
parent
=
aApzc2
;
parent
;
parent
=
parent
-
>
GetParent
(
)
)
{
depth2
+
+
;
}
int
minDepth
=
depth1
<
depth2
?
depth1
:
depth2
;
while
(
depth1
>
minDepth
)
{
depth1
-
-
;
aApzc1
=
aApzc1
-
>
GetParent
(
)
;
}
while
(
depth2
>
minDepth
)
{
depth2
-
-
;
aApzc2
=
aApzc2
-
>
GetParent
(
)
;
}
while
(
true
)
{
if
(
aApzc1
=
=
aApzc2
)
{
ancestor
=
aApzc1
;
break
;
}
if
(
depth1
<
=
0
)
{
break
;
}
aApzc1
=
aApzc1
-
>
GetParent
(
)
;
aApzc2
=
aApzc2
-
>
GetParent
(
)
;
}
return
ancestor
.
forget
(
)
;
}
LayerToParentLayerMatrix4x4
APZCTreeManager
:
:
ComputeTransformForNode
(
const
HitTestingTreeNode
*
aNode
)
const
{
mTreeLock
.
AssertCurrentThreadIn
(
)
;
if
(
AsyncPanZoomController
*
apzc
=
aNode
-
>
GetApzc
(
)
)
{
bool
visualTransformIsInheritedFromAncestor
=
apzc
-
>
IsRootContent
(
)
&
&
mUsingAsyncZoomContainer
&
&
!
aNode
-
>
IsAsyncZoomContainer
(
)
;
AsyncTransformComponents
components
=
visualTransformIsInheritedFromAncestor
?
AsyncTransformComponents
{
AsyncTransformComponent
:
:
eLayout
}
:
LayoutAndVisual
;
return
aNode
-
>
GetTransform
(
)
*
CompleteAsyncTransform
(
apzc
-
>
GetCurrentAsyncTransformWithOverscroll
(
AsyncPanZoomController
:
:
eForHitTesting
components
)
)
;
}
else
if
(
aNode
-
>
IsAsyncZoomContainer
(
)
)
{
if
(
AsyncPanZoomController
*
rootContent
=
FindRootContentApzcForLayersId
(
aNode
-
>
GetLayersId
(
)
)
)
{
return
aNode
-
>
GetTransform
(
)
*
CompleteAsyncTransform
(
rootContent
-
>
GetCurrentAsyncTransformWithOverscroll
(
AsyncPanZoomController
:
:
eForHitTesting
{
AsyncTransformComponent
:
:
eVisual
}
)
)
;
}
}
else
if
(
aNode
-
>
IsScrollThumbNode
(
)
)
{
ScrollableLayerGuid
guid
{
aNode
-
>
GetLayersId
(
)
0
aNode
-
>
GetScrollTargetId
(
)
}
;
if
(
RefPtr
<
HitTestingTreeNode
>
scrollTargetNode
=
GetTargetNode
(
guid
&
GuidComparatorIgnoringPresShell
)
)
{
AsyncPanZoomController
*
scrollTargetApzc
=
scrollTargetNode
-
>
GetApzc
(
)
;
MOZ_ASSERT
(
scrollTargetApzc
)
;
return
scrollTargetApzc
-
>
CallWithLastContentPaintMetrics
(
[
&
]
(
const
FrameMetrics
&
aMetrics
)
{
return
ComputeTransformForScrollThumb
(
aNode
-
>
GetTransform
(
)
*
AsyncTransformMatrix
(
)
scrollTargetNode
-
>
GetTransform
(
)
.
ToUnknownMatrix
(
)
scrollTargetApzc
aMetrics
aNode
-
>
GetScrollbarData
(
)
scrollTargetNode
-
>
IsAncestorOf
(
aNode
)
nullptr
)
;
}
)
;
}
}
return
aNode
-
>
GetTransform
(
)
*
AsyncTransformMatrix
(
)
;
}
already_AddRefed
<
wr
:
:
WebRenderAPI
>
APZCTreeManager
:
:
GetWebRenderAPI
(
wr
:
:
RenderRoot
aRenderRoot
)
const
{
RefPtr
<
wr
:
:
WebRenderAPI
>
api
;
CompositorBridgeParent
:
:
CallWithIndirectShadowTree
(
mRootLayersId
[
&
]
(
LayerTreeState
&
aState
)
-
>
void
{
if
(
aState
.
mWrBridge
)
{
api
=
aState
.
mWrBridge
-
>
GetWebRenderAPI
(
aRenderRoot
)
;
}
}
)
;
return
api
.
forget
(
)
;
}
already_AddRefed
<
wr
:
:
WebRenderAPI
>
APZCTreeManager
:
:
GetWebRenderAPIAtPoint
(
const
ScreenPoint
&
aPoint
)
const
{
RefPtr
<
wr
:
:
WebRenderAPI
>
api
;
CompositorBridgeParent
:
:
CallWithIndirectShadowTree
(
mRootLayersId
[
&
]
(
LayerTreeState
&
aState
)
-
>
void
{
if
(
aState
.
mWrBridge
)
{
api
=
aState
.
mWrBridge
-
>
GetWebRenderAPIAtPoint
(
aPoint
)
;
}
}
)
;
return
api
.
forget
(
)
;
}
already_AddRefed
<
GeckoContentController
>
APZCTreeManager
:
:
GetContentController
(
LayersId
aLayersId
)
{
RefPtr
<
GeckoContentController
>
controller
;
CompositorBridgeParent
:
:
CallWithIndirectShadowTree
(
aLayersId
[
&
]
(
LayerTreeState
&
aState
)
-
>
void
{
controller
=
aState
.
mController
;
}
)
;
return
controller
.
forget
(
)
;
}
bool
APZCTreeManager
:
:
GetAPZTestData
(
LayersId
aLayersId
APZTestData
*
aOutData
)
{
AssertOnUpdaterThread
(
)
;
MutexAutoLock
lock
(
mTestDataLock
)
;
auto
it
=
mTestData
.
find
(
aLayersId
)
;
if
(
it
=
=
mTestData
.
end
(
)
)
{
return
false
;
}
*
aOutData
=
*
(
it
-
>
second
)
;
return
true
;
}
void
APZCTreeManager
:
:
SendSubtreeTransformsToChromeMainThread
(
const
AsyncPanZoomController
*
aAncestor
)
{
RefPtr
<
GeckoContentController
>
controller
=
GetContentController
(
mRootLayersId
)
;
if
(
!
controller
)
{
return
;
}
nsTArray
<
MatrixMessage
>
messages
;
bool
underAncestor
=
(
aAncestor
=
=
nullptr
)
;
{
RecursiveMutexAutoLock
lock
(
mTreeLock
)
;
ForEachNode
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
&
]
(
HitTestingTreeNode
*
aNode
)
{
bool
atAncestor
=
(
aAncestor
&
&
aNode
-
>
GetApzc
(
)
=
=
aAncestor
)
;
MOZ_ASSERT
(
!
(
underAncestor
&
&
atAncestor
)
)
;
underAncestor
|
=
atAncestor
;
if
(
!
underAncestor
)
{
return
;
}
LayersId
layersId
=
aNode
-
>
GetLayersId
(
)
;
HitTestingTreeNode
*
parent
=
aNode
-
>
GetParent
(
)
;
if
(
!
parent
)
{
messages
.
AppendElement
(
MatrixMessage
(
Some
(
LayerToScreenMatrix4x4
(
)
)
ScreenRect
(
)
layersId
)
)
;
}
else
if
(
layersId
!
=
parent
-
>
GetLayersId
(
)
)
{
if
(
mDetachedLayersIds
.
find
(
layersId
)
!
=
mDetachedLayersIds
.
end
(
)
)
{
messages
.
AppendElement
(
MatrixMessage
(
Nothing
(
)
ScreenRect
(
)
layersId
)
)
;
}
else
{
messages
.
AppendElement
(
MatrixMessage
(
Some
(
parent
-
>
GetTransformToGecko
(
)
)
parent
-
>
GetRemoteDocumentScreenRect
(
)
layersId
)
)
;
}
}
}
[
&
]
(
HitTestingTreeNode
*
aNode
)
{
bool
atAncestor
=
(
aAncestor
&
&
aNode
-
>
GetApzc
(
)
=
=
aAncestor
)
;
if
(
atAncestor
)
{
MOZ_ASSERT
(
underAncestor
)
;
underAncestor
=
false
;
}
}
)
;
}
controller
-
>
NotifyLayerTransforms
(
messages
)
;
}
LayerToParentLayerMatrix4x4
APZCTreeManager
:
:
ComputeTransformForScrollThumb
(
const
LayerToParentLayerMatrix4x4
&
aCurrentTransform
const
Matrix4x4
&
aScrollableContentTransform
AsyncPanZoomController
*
aApzc
const
FrameMetrics
&
aMetrics
const
ScrollbarData
&
aScrollbarData
bool
aScrollbarIsDescendant
AsyncTransformComponentMatrix
*
aOutClipTransform
)
{
if
(
aMetrics
.
IsScrollInfoLayer
(
)
)
{
return
LayerToParentLayerMatrix4x4
{
}
;
}
MOZ_RELEASE_ASSERT
(
aApzc
)
;
AsyncTransformComponentMatrix
asyncTransform
=
aApzc
-
>
GetCurrentAsyncTransform
(
AsyncPanZoomController
:
:
eForCompositing
)
;
bool
scrollbarSubjectToResolution
=
aMetrics
.
IsRootContent
(
)
&
&
StaticPrefs
:
:
layout_scroll_root_frame_containers
(
)
;
AsyncTransformComponentMatrix
scrollbarTransform
;
if
(
*
aScrollbarData
.
mDirection
=
=
ScrollDirection
:
:
eVertical
)
{
const
ParentLayerCoord
asyncScrollY
=
asyncTransform
.
_42
;
const
float
asyncZoomY
=
asyncTransform
.
_22
;
const
float
yScale
=
1
.
f
/
asyncZoomY
;
const
CSSToParentLayerScale
effectiveZoom
(
aMetrics
.
GetZoom
(
)
.
yScale
*
asyncZoomY
)
;
const
float
ratio
=
aScrollbarData
.
mThumbRatio
/
(
aMetrics
.
GetPresShellResolution
(
)
*
asyncZoomY
)
;
ParentLayerCoord
yTranslation
=
-
asyncScrollY
*
ratio
;
const
CSSCoord
thumbOrigin
=
(
aMetrics
.
GetScrollOffset
(
)
.
y
*
ratio
)
;
const
CSSCoord
thumbOriginScaled
=
thumbOrigin
*
yScale
;
const
CSSCoord
thumbOriginDelta
=
thumbOriginScaled
-
thumbOrigin
;
const
ParentLayerCoord
thumbOriginDeltaPL
=
thumbOriginDelta
*
effectiveZoom
;
yTranslation
-
=
thumbOriginDeltaPL
;
if
(
scrollbarSubjectToResolution
)
{
yTranslation
*
=
aMetrics
.
GetPresShellResolution
(
)
;
}
scrollbarTransform
.
PostScale
(
1
.
f
yScale
1
.
f
)
;
scrollbarTransform
.
PostTranslate
(
0
yTranslation
0
)
;
}
if
(
*
aScrollbarData
.
mDirection
=
=
ScrollDirection
:
:
eHorizontal
)
{
const
ParentLayerCoord
asyncScrollX
=
asyncTransform
.
_41
;
const
float
asyncZoomX
=
asyncTransform
.
_11
;
const
float
xScale
=
1
.
f
/
asyncZoomX
;
const
CSSToParentLayerScale
effectiveZoom
(
aMetrics
.
GetZoom
(
)
.
xScale
*
asyncZoomX
)
;
const
float
ratio
=
aScrollbarData
.
mThumbRatio
/
(
aMetrics
.
GetPresShellResolution
(
)
*
asyncZoomX
)
;
ParentLayerCoord
xTranslation
=
-
asyncScrollX
*
ratio
;
const
CSSCoord
thumbOrigin
=
(
aMetrics
.
GetScrollOffset
(
)
.
x
*
ratio
)
;
const
CSSCoord
thumbOriginScaled
=
thumbOrigin
*
xScale
;
const
CSSCoord
thumbOriginDelta
=
thumbOriginScaled
-
thumbOrigin
;
const
ParentLayerCoord
thumbOriginDeltaPL
=
thumbOriginDelta
*
effectiveZoom
;
xTranslation
-
=
thumbOriginDeltaPL
;
if
(
scrollbarSubjectToResolution
)
{
xTranslation
*
=
aMetrics
.
GetPresShellResolution
(
)
;
}
scrollbarTransform
.
PostScale
(
xScale
1
.
f
1
.
f
)
;
scrollbarTransform
.
PostTranslate
(
xTranslation
0
0
)
;
}
LayerToParentLayerMatrix4x4
transform
=
aCurrentTransform
*
scrollbarTransform
;
AsyncTransformComponentMatrix
compensation
;
if
(
scrollbarSubjectToResolution
)
{
compensation
=
AsyncTransformComponentMatrix
:
:
Scaling
(
aMetrics
.
GetPresShellResolution
(
)
aMetrics
.
GetPresShellResolution
(
)
1
.
0f
)
.
Inverse
(
)
;
}
if
(
aScrollbarIsDescendant
)
{
AsyncTransformComponentMatrix
overscroll
=
aApzc
-
>
GetOverscrollTransform
(
AsyncPanZoomController
:
:
eForCompositing
)
;
Matrix4x4
asyncUntransform
=
(
asyncTransform
*
overscroll
)
.
Inverse
(
)
.
ToUnknownMatrix
(
)
;
const
Matrix4x4
&
contentTransform
=
aScrollableContentTransform
;
Matrix4x4
contentUntransform
=
contentTransform
.
Inverse
(
)
;
compensation
*
=
ViewAs
<
AsyncTransformComponentMatrix
>
(
contentTransform
*
asyncUntransform
*
contentUntransform
)
;
if
(
aOutClipTransform
)
{
*
aOutClipTransform
=
compensation
;
}
}
transform
=
transform
*
compensation
;
return
transform
;
}
APZSampler
*
APZCTreeManager
:
:
GetSampler
(
)
const
{
MOZ_ASSERT
(
mSampler
)
;
return
mSampler
;
}
void
APZCTreeManager
:
:
AssertOnSamplerThread
(
)
{
GetSampler
(
)
-
>
AssertOnSamplerThread
(
)
;
}
APZUpdater
*
APZCTreeManager
:
:
GetUpdater
(
)
const
{
MOZ_ASSERT
(
mUpdater
)
;
return
mUpdater
;
}
void
APZCTreeManager
:
:
AssertOnUpdaterThread
(
)
{
GetUpdater
(
)
-
>
AssertOnUpdaterThread
(
)
;
}
void
APZCTreeManager
:
:
LockTree
(
)
{
AssertOnUpdaterThread
(
)
;
mTreeLock
.
Lock
(
)
;
}
void
APZCTreeManager
:
:
UnlockTree
(
)
{
AssertOnUpdaterThread
(
)
;
mTreeLock
.
Unlock
(
)
;
}
void
APZCTreeManager
:
:
SetDPI
(
float
aDpiValue
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
mDPI
=
aDpiValue
;
}
float
APZCTreeManager
:
:
GetDPI
(
)
const
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
return
mDPI
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
AndroidDynamicToolbarAnimator
*
APZCTreeManager
:
:
GetAndroidDynamicToolbarAnimator
(
)
{
return
mToolbarAnimator
;
}
#
endif
}
}
