#
include
<
stack
>
#
include
<
unordered_set
>
#
include
"
APZCTreeManager
.
h
"
#
include
"
AsyncPanZoomController
.
h
"
#
include
"
Compositor
.
h
"
#
include
"
DragTracker
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
HitTestingTreeNode
.
h
"
#
include
"
InputBlockState
.
h
"
#
include
"
InputData
.
h
"
#
include
"
Layers
.
h
"
#
include
"
mozilla
/
dom
/
Touch
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
gfx
/
GPUParent
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
layers
/
APZThreadUtils
.
h
"
#
include
"
mozilla
/
layers
/
AsyncCompositionManager
.
h
"
#
include
"
mozilla
/
layers
/
AsyncDragMetrics
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
FocusState
.
h
"
#
include
"
mozilla
/
layers
/
LayerMetricsWrapper
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderScrollDataWrapper
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
TouchEvents
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
OverscrollHandoffState
.
h
"
#
include
"
TreeTraversal
.
h
"
#
include
"
LayersLogging
.
h
"
#
include
"
Units
.
h
"
#
include
"
GestureEventListener
.
h
"
#
include
"
UnitTransforms
.
h
"
#
define
ENABLE_APZCTM_LOGGING
0
#
if
ENABLE_APZCTM_LOGGING
#
define
APZCTM_LOG
(
.
.
.
)
printf_stderr
(
"
APZCTM
:
"
__VA_ARGS__
)
#
else
#
define
APZCTM_LOG
(
.
.
.
)
#
endif
#
define
APZ_KEY_LOG
(
.
.
.
)
namespace
mozilla
{
namespace
layers
{
using
mozilla
:
:
gfx
:
:
CompositorHitTestInfo
;
typedef
mozilla
:
:
gfx
:
:
Point
Point
;
typedef
mozilla
:
:
gfx
:
:
Point4D
Point4D
;
typedef
mozilla
:
:
gfx
:
:
Matrix4x4
Matrix4x4
;
typedef
CompositorBridgeParent
:
:
LayerTreeState
LayerTreeState
;
float
APZCTreeManager
:
:
sDPI
=
160
.
0
;
struct
APZCTreeManager
:
:
TreeBuildingState
{
TreeBuildingState
(
const
LayerTreeState
*
const
aLayerTreeState
bool
aIsFirstPaint
uint64_t
aOriginatingLayersId
APZTestData
*
aTestData
uint32_t
aPaintSequence
)
:
mLayerTreeState
(
aLayerTreeState
)
mIsFirstPaint
(
aIsFirstPaint
)
mOriginatingLayersId
(
aOriginatingLayersId
)
mPaintLogger
(
aTestData
aPaintSequence
)
{
}
const
LayerTreeState
*
const
mLayerTreeState
;
const
bool
mIsFirstPaint
;
const
uint64_t
mOriginatingLayersId
;
const
APZPaintLogHelper
mPaintLogger
;
nsTArray
<
RefPtr
<
HitTestingTreeNode
>
>
mNodesToDestroy
;
std
:
:
unordered_set
<
uint64_t
>
mLayersIdsToDestroy
;
std
:
:
unordered_map
<
ScrollableLayerGuid
AsyncPanZoomController
*
ScrollableLayerGuidHash
>
mApzcMap
;
std
:
:
stack
<
bool
>
mParentHasPerspective
;
}
;
class
APZCTreeManager
:
:
CheckerboardFlushObserver
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
explicit
CheckerboardFlushObserver
(
APZCTreeManager
*
aTreeManager
)
:
mTreeManager
(
aTreeManager
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
obsSvc
)
;
if
(
obsSvc
)
{
obsSvc
-
>
AddObserver
(
this
"
APZ
:
FlushActiveCheckerboard
"
false
)
;
}
}
void
Unregister
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsSvc
)
{
obsSvc
-
>
RemoveObserver
(
this
"
APZ
:
FlushActiveCheckerboard
"
)
;
}
mTreeManager
=
nullptr
;
}
protected
:
virtual
~
CheckerboardFlushObserver
(
)
{
}
private
:
RefPtr
<
APZCTreeManager
>
mTreeManager
;
}
;
NS_IMPL_ISUPPORTS
(
APZCTreeManager
:
:
CheckerboardFlushObserver
nsIObserver
)
NS_IMETHODIMP
APZCTreeManager
:
:
CheckerboardFlushObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mTreeManager
.
get
(
)
)
;
MutexAutoLock
lock
(
mTreeManager
-
>
mTreeLock
)
;
if
(
mTreeManager
-
>
mRootNode
)
{
ForEachNode
<
ReverseIterator
>
(
mTreeManager
-
>
mRootNode
.
get
(
)
[
]
(
HitTestingTreeNode
*
aNode
)
{
if
(
aNode
-
>
IsPrimaryHolder
(
)
)
{
MOZ_ASSERT
(
aNode
-
>
GetApzc
(
)
)
;
aNode
-
>
GetApzc
(
)
-
>
FlushActiveCheckerboardReport
(
)
;
}
}
)
;
}
if
(
XRE_IsGPUProcess
(
)
)
{
if
(
gfx
:
:
GPUParent
*
gpu
=
gfx
:
:
GPUParent
:
:
GetSingleton
(
)
)
{
nsCString
topic
(
"
APZ
:
FlushActiveCheckerboard
:
Done
"
)
;
Unused
<
<
gpu
-
>
SendNotifyUiObservers
(
topic
)
;
}
}
else
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsSvc
)
{
obsSvc
-
>
NotifyObservers
(
nullptr
"
APZ
:
FlushActiveCheckerboard
:
Done
"
nullptr
)
;
}
}
return
NS_OK
;
}
class
MOZ_RAII
AutoFocusSequenceNumberSetter
{
public
:
AutoFocusSequenceNumberSetter
(
FocusState
&
aFocusState
InputData
&
aEvent
)
:
mFocusState
(
aFocusState
)
mEvent
(
aEvent
)
mMayChangeFocus
(
true
)
{
}
void
MarkAsNonFocusChanging
(
)
{
mMayChangeFocus
=
false
;
}
~
AutoFocusSequenceNumberSetter
(
)
{
if
(
mMayChangeFocus
)
{
mFocusState
.
ReceiveFocusChangingEvent
(
)
;
APZ_KEY_LOG
(
"
Marking
input
with
type
=
%
d
as
focus
changing
with
seq
=
%
"
PRIu64
"
\
n
"
static_cast
<
int
>
(
mEvent
.
mInputType
)
mFocusState
.
LastAPZProcessedEvent
(
)
)
;
}
else
{
APZ_KEY_LOG
(
"
Marking
input
with
type
=
%
d
as
non
focus
changing
with
seq
=
%
"
PRIu64
"
\
n
"
static_cast
<
int
>
(
mEvent
.
mInputType
)
mFocusState
.
LastAPZProcessedEvent
(
)
)
;
}
mEvent
.
mFocusSequenceNumber
=
mFocusState
.
LastAPZProcessedEvent
(
)
;
}
private
:
FocusState
&
mFocusState
;
InputData
&
mEvent
;
bool
mMayChangeFocus
;
}
;
const
ScreenMargin
APZCTreeManager
:
:
CalculatePendingDisplayPort
(
const
FrameMetrics
&
aFrameMetrics
const
ParentLayerPoint
&
aVelocity
)
{
return
AsyncPanZoomController
:
:
CalculatePendingDisplayPort
(
aFrameMetrics
aVelocity
)
;
}
APZCTreeManager
:
:
APZCTreeManager
(
uint64_t
aRootLayersId
)
:
mInputQueue
(
new
InputQueue
(
)
)
mRootLayersId
(
aRootLayersId
)
mTreeLock
(
"
APZCTreeLock
"
)
mHitResultForInputBlock
(
CompositorHitTestInfo
:
:
eInvisibleToHitTest
)
mRetainedTouchIdentifier
(
-
1
)
mInScrollbarTouchDrag
(
false
)
mApzcTreeLog
(
"
apzctree
"
)
{
RefPtr
<
APZCTreeManager
>
self
(
this
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
layers
:
:
APZCTreeManager
:
:
APZCTreeManager
"
[
self
]
{
self
-
>
mFlushObserver
=
new
CheckerboardFlushObserver
(
self
)
;
}
)
)
;
AsyncPanZoomController
:
:
InitializeGlobalState
(
)
;
mApzcTreeLog
.
ConditionOnPrefFunction
(
gfxPrefs
:
:
APZPrintTree
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
mToolbarAnimator
=
new
AndroidDynamicToolbarAnimator
(
)
;
#
endif
}
APZCTreeManager
:
:
~
APZCTreeManager
(
)
{
}
void
APZCTreeManager
:
:
InitializeGlobalState
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AsyncPanZoomController
:
:
InitializeGlobalState
(
)
;
}
AsyncPanZoomController
*
APZCTreeManager
:
:
NewAPZCInstance
(
uint64_t
aLayersId
GeckoContentController
*
aController
)
{
return
new
AsyncPanZoomController
(
aLayersId
this
mInputQueue
aController
AsyncPanZoomController
:
:
USE_GESTURE_DETECTOR
)
;
}
TimeStamp
APZCTreeManager
:
:
GetFrameTime
(
)
{
return
TimeStamp
:
:
Now
(
)
;
}
void
APZCTreeManager
:
:
SetAllowedTouchBehavior
(
uint64_t
aInputBlockId
const
nsTArray
<
TouchBehaviorFlags
>
&
aValues
)
{
mInputQueue
-
>
SetAllowedTouchBehavior
(
aInputBlockId
aValues
)
;
}
template
<
class
ScrollNode
>
void
APZCTreeManager
:
:
UpdateHitTestingTreeImpl
(
uint64_t
aRootLayerTreeId
const
ScrollNode
&
aRoot
bool
aIsFirstPaint
uint64_t
aOriginatingLayersId
uint32_t
aPaintSequenceNumber
)
{
APZThreadUtils
:
:
AssertOnCompositorThread
(
)
;
MutexAutoLock
lock
(
mTreeLock
)
;
APZTestData
*
testData
=
nullptr
;
if
(
gfxPrefs
:
:
APZTestLoggingEnabled
(
)
)
{
if
(
LayerTreeState
*
state
=
CompositorBridgeParent
:
:
GetIndirectShadowTree
(
aOriginatingLayersId
)
)
{
testData
=
&
state
-
>
mApzTestData
;
testData
-
>
StartNewPaint
(
aPaintSequenceNumber
)
;
}
}
const
LayerTreeState
*
treeState
=
CompositorBridgeParent
:
:
GetIndirectShadowTree
(
aRootLayerTreeId
)
;
MOZ_ASSERT
(
treeState
)
;
TreeBuildingState
state
(
treeState
aIsFirstPaint
aOriginatingLayersId
testData
aPaintSequenceNumber
)
;
ForEachNode
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
&
state
]
(
HitTestingTreeNode
*
aNode
)
{
state
.
mNodesToDestroy
.
AppendElement
(
aNode
)
;
}
)
;
state
.
mLayersIdsToDestroy
=
mFocusState
.
GetFocusTargetLayerIds
(
)
;
mRootNode
=
nullptr
;
if
(
aRoot
)
{
std
:
:
stack
<
gfx
:
:
TreeAutoIndent
>
indents
;
std
:
:
stack
<
AncestorTransform
>
ancestorTransforms
;
HitTestingTreeNode
*
parent
=
nullptr
;
HitTestingTreeNode
*
next
=
nullptr
;
uint64_t
layersId
=
aRootLayerTreeId
;
ancestorTransforms
.
push
(
AncestorTransform
(
)
)
;
state
.
mParentHasPerspective
.
push
(
false
)
;
state
.
mLayersIdsToDestroy
.
erase
(
aRootLayerTreeId
)
;
mApzcTreeLog
<
<
"
[
start
]
\
n
"
;
mTreeLock
.
AssertCurrentThreadOwns
(
)
;
ForEachNode
<
ReverseIterator
>
(
aRoot
[
&
]
(
ScrollNode
aLayerMetrics
)
{
mApzcTreeLog
<
<
aLayerMetrics
.
Name
(
)
<
<
'
\
t
'
;
HitTestingTreeNode
*
node
=
PrepareNodeForLayer
(
aLayerMetrics
aLayerMetrics
.
Metrics
(
)
layersId
ancestorTransforms
.
top
(
)
parent
next
state
)
;
MOZ_ASSERT
(
node
)
;
AsyncPanZoomController
*
apzc
=
node
-
>
GetApzc
(
)
;
aLayerMetrics
.
SetApzc
(
apzc
)
;
mApzcTreeLog
<
<
'
\
n
'
;
AncestorTransform
currentTransform
{
aLayerMetrics
.
GetTransform
(
)
aLayerMetrics
.
TransformIsPerspective
(
)
}
;
if
(
!
apzc
)
{
currentTransform
=
currentTransform
*
ancestorTransforms
.
top
(
)
;
}
ancestorTransforms
.
push
(
currentTransform
)
;
MOZ_ASSERT
(
!
node
-
>
GetFirstChild
(
)
)
;
parent
=
node
;
next
=
nullptr
;
if
(
Maybe
<
uint64_t
>
newLayersId
=
aLayerMetrics
.
GetReferentId
(
)
)
{
layersId
=
*
newLayersId
;
state
.
mLayersIdsToDestroy
.
erase
(
layersId
)
;
}
indents
.
push
(
gfx
:
:
TreeAutoIndent
(
mApzcTreeLog
)
)
;
state
.
mParentHasPerspective
.
push
(
aLayerMetrics
.
TransformIsPerspective
(
)
)
;
}
[
&
]
(
ScrollNode
aLayerMetrics
)
{
next
=
parent
;
parent
=
parent
-
>
GetParent
(
)
;
layersId
=
next
-
>
GetLayersId
(
)
;
ancestorTransforms
.
pop
(
)
;
indents
.
pop
(
)
;
state
.
mParentHasPerspective
.
pop
(
)
;
}
)
;
mApzcTreeLog
<
<
"
[
end
]
\
n
"
;
}
MOZ_ASSERT
(
!
(
mRootNode
&
&
mRootNode
-
>
GetPrevSibling
(
)
)
)
;
for
(
size_t
i
=
0
;
i
<
state
.
mNodesToDestroy
.
Length
(
)
;
i
+
+
)
{
APZCTM_LOG
(
"
Destroying
node
at
%
p
with
APZC
%
p
\
n
"
state
.
mNodesToDestroy
[
i
]
.
get
(
)
state
.
mNodesToDestroy
[
i
]
-
>
GetApzc
(
)
)
;
state
.
mNodesToDestroy
[
i
]
-
>
Destroy
(
)
;
}
for
(
auto
layersId
:
state
.
mLayersIdsToDestroy
)
{
mFocusState
.
RemoveFocusTarget
(
layersId
)
;
}
#
if
ENABLE_APZCTM_LOGGING
printf_stderr
(
"
APZCTreeManager
(
%
p
)
\
n
"
this
)
;
mRootNode
-
>
Dump
(
"
"
)
;
#
endif
}
void
APZCTreeManager
:
:
UpdateFocusState
(
uint64_t
aRootLayerTreeId
uint64_t
aOriginatingLayersId
const
FocusTarget
&
aFocusTarget
)
{
if
(
!
gfxPrefs
:
:
APZKeyboardEnabled
(
)
)
{
return
;
}
mFocusState
.
Update
(
aRootLayerTreeId
aOriginatingLayersId
aFocusTarget
)
;
}
void
APZCTreeManager
:
:
UpdateHitTestingTree
(
uint64_t
aRootLayerTreeId
Layer
*
aRoot
bool
aIsFirstPaint
uint64_t
aOriginatingLayersId
uint32_t
aPaintSequenceNumber
)
{
LayerMetricsWrapper
root
(
aRoot
)
;
UpdateHitTestingTreeImpl
(
aRootLayerTreeId
root
aIsFirstPaint
aOriginatingLayersId
aPaintSequenceNumber
)
;
}
void
APZCTreeManager
:
:
UpdateHitTestingTree
(
uint64_t
aRootLayerTreeId
const
WebRenderScrollData
&
aScrollData
bool
aIsFirstPaint
uint64_t
aOriginatingLayersId
uint32_t
aPaintSequenceNumber
)
{
WebRenderScrollDataWrapper
wrapper
(
&
aScrollData
)
;
UpdateHitTestingTreeImpl
(
aRootLayerTreeId
wrapper
aIsFirstPaint
aOriginatingLayersId
aPaintSequenceNumber
)
;
}
bool
APZCTreeManager
:
:
PushStateToWR
(
wr
:
:
TransactionBuilder
&
aTxn
const
TimeStamp
&
aSampleTime
nsTArray
<
wr
:
:
WrTransformProperty
>
&
aTransformArray
)
{
APZThreadUtils
:
:
AssertOnCompositorThread
(
)
;
MutexAutoLock
lock
(
mTreeLock
)
;
std
:
:
unordered_map
<
ScrollableLayerGuid
HitTestingTreeNode
*
ScrollableLayerGuidHash
>
httnMap
;
bool
activeAnimations
=
false
;
uint64_t
lastLayersId
=
-
1
;
wr
:
:
WrPipelineId
lastPipelineId
;
ForEachNode
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
&
]
(
HitTestingTreeNode
*
aNode
)
{
if
(
!
aNode
-
>
IsPrimaryHolder
(
)
)
{
return
;
}
AsyncPanZoomController
*
apzc
=
aNode
-
>
GetApzc
(
)
;
MOZ_ASSERT
(
apzc
)
;
if
(
aNode
-
>
GetLayersId
(
)
!
=
lastLayersId
)
{
const
LayerTreeState
*
state
=
CompositorBridgeParent
:
:
GetIndirectShadowTree
(
aNode
-
>
GetLayersId
(
)
)
;
if
(
!
(
state
&
&
state
-
>
mWrBridge
)
)
{
return
;
}
lastPipelineId
=
state
-
>
mWrBridge
-
>
PipelineId
(
)
;
lastLayersId
=
aNode
-
>
GetLayersId
(
)
;
}
ScrollableLayerGuid
guid
(
lastLayersId
0
apzc
-
>
GetGuid
(
)
.
mScrollId
)
;
httnMap
.
emplace
(
guid
aNode
)
;
ParentLayerPoint
layerTranslation
=
apzc
-
>
GetCurrentAsyncTransform
(
AsyncPanZoomController
:
:
eForCompositing
)
.
mTranslation
;
ParentLayerPoint
asyncScrollDelta
=
-
layerTranslation
;
aTxn
.
UpdateScrollPosition
(
lastPipelineId
apzc
-
>
GetGuid
(
)
.
mScrollId
wr
:
:
ToLayoutPoint
(
LayoutDevicePoint
:
:
FromUnknownPoint
(
asyncScrollDelta
.
ToUnknownPoint
(
)
)
)
)
;
apzc
-
>
ReportCheckerboard
(
aSampleTime
)
;
activeAnimations
|
=
apzc
-
>
AdvanceAnimations
(
aSampleTime
)
;
}
)
;
ForEachNode
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
&
]
(
HitTestingTreeNode
*
aNode
)
{
if
(
!
aNode
-
>
IsScrollThumbNode
(
)
)
{
return
;
}
ScrollableLayerGuid
guid
(
aNode
-
>
GetLayersId
(
)
0
aNode
-
>
GetScrollTargetId
(
)
)
;
auto
it
=
httnMap
.
find
(
guid
)
;
if
(
it
=
=
httnMap
.
end
(
)
)
{
return
;
}
HitTestingTreeNode
*
scrollTargetNode
=
it
-
>
second
;
AsyncPanZoomController
*
scrollTargetApzc
=
scrollTargetNode
-
>
GetApzc
(
)
;
MOZ_ASSERT
(
scrollTargetApzc
)
;
LayerToParentLayerMatrix4x4
transform
=
scrollTargetApzc
-
>
CallWithLastContentPaintMetrics
(
[
&
]
(
const
FrameMetrics
&
aMetrics
)
{
return
AsyncCompositionManager
:
:
ComputeTransformForScrollThumb
(
aNode
-
>
GetTransform
(
)
*
AsyncTransformMatrix
(
)
scrollTargetNode
-
>
GetTransform
(
)
.
ToUnknownMatrix
(
)
scrollTargetApzc
aMetrics
aNode
-
>
GetScrollThumbData
(
)
scrollTargetNode
-
>
IsAncestorOf
(
aNode
)
nullptr
)
;
}
)
;
aTransformArray
.
AppendElement
(
wr
:
:
ToWrTransformProperty
(
aNode
-
>
GetScrollbarAnimationId
(
)
transform
)
)
;
}
)
;
return
activeAnimations
;
}
template
<
class
ScrollNode
>
static
ParentLayerIntRegion
ComputeClipRegion
(
GeckoContentController
*
aController
const
ScrollNode
&
aLayer
)
{
ParentLayerIntRegion
clipRegion
;
if
(
aLayer
.
GetClipRect
(
)
)
{
clipRegion
=
*
aLayer
.
GetClipRect
(
)
;
}
else
{
clipRegion
=
RoundedToInt
(
aLayer
.
Metrics
(
)
.
GetCompositionBounds
(
)
)
;
}
return
clipRegion
;
}
template
<
class
ScrollNode
>
void
APZCTreeManager
:
:
PrintAPZCInfo
(
const
ScrollNode
&
aLayer
const
AsyncPanZoomController
*
apzc
)
{
const
FrameMetrics
&
metrics
=
aLayer
.
Metrics
(
)
;
mApzcTreeLog
<
<
"
APZC
"
<
<
apzc
-
>
GetGuid
(
)
<
<
"
\
tcb
=
"
<
<
metrics
.
GetCompositionBounds
(
)
<
<
"
\
tsr
=
"
<
<
metrics
.
GetScrollableRect
(
)
<
<
(
metrics
.
IsScrollInfoLayer
(
)
?
"
\
tscrollinfo
"
:
"
"
)
<
<
(
apzc
-
>
HasScrollgrab
(
)
?
"
\
tscrollgrab
"
:
"
"
)
<
<
"
\
t
"
<
<
aLayer
.
Metadata
(
)
.
GetContentDescription
(
)
.
get
(
)
;
}
void
APZCTreeManager
:
:
AttachNodeToTree
(
HitTestingTreeNode
*
aNode
HitTestingTreeNode
*
aParent
HitTestingTreeNode
*
aNextSibling
)
{
if
(
aNextSibling
)
{
aNextSibling
-
>
SetPrevSibling
(
aNode
)
;
}
else
if
(
aParent
)
{
aParent
-
>
SetLastChild
(
aNode
)
;
}
else
{
MOZ_ASSERT
(
!
mRootNode
)
;
mRootNode
=
aNode
;
aNode
-
>
MakeRoot
(
)
;
}
}
template
<
class
ScrollNode
>
static
EventRegions
GetEventRegions
(
const
ScrollNode
&
aLayer
)
{
if
(
aLayer
.
Metrics
(
)
.
IsScrollInfoLayer
(
)
)
{
ParentLayerIntRect
compositionBounds
(
RoundedToInt
(
aLayer
.
Metrics
(
)
.
GetCompositionBounds
(
)
)
)
;
nsIntRegion
hitRegion
(
compositionBounds
.
ToUnknownRect
(
)
)
;
EventRegions
eventRegions
(
hitRegion
)
;
eventRegions
.
mDispatchToContentHitRegion
=
eventRegions
.
mHitRegion
;
return
eventRegions
;
}
return
aLayer
.
GetEventRegions
(
)
;
}
already_AddRefed
<
HitTestingTreeNode
>
APZCTreeManager
:
:
RecycleOrCreateNode
(
TreeBuildingState
&
aState
AsyncPanZoomController
*
aApzc
uint64_t
aLayersId
)
{
for
(
size_t
i
=
0
;
i
<
aState
.
mNodesToDestroy
.
Length
(
)
;
i
+
+
)
{
RefPtr
<
HitTestingTreeNode
>
node
=
aState
.
mNodesToDestroy
[
i
]
;
if
(
!
node
-
>
IsPrimaryHolder
(
)
)
{
aState
.
mNodesToDestroy
.
RemoveElement
(
node
)
;
node
-
>
RecycleWith
(
aApzc
aLayersId
)
;
return
node
.
forget
(
)
;
}
}
RefPtr
<
HitTestingTreeNode
>
node
=
new
HitTestingTreeNode
(
aApzc
false
aLayersId
)
;
return
node
.
forget
(
)
;
}
template
<
class
ScrollNode
>
static
EventRegionsOverride
GetEventRegionsOverride
(
HitTestingTreeNode
*
aParent
const
ScrollNode
&
aLayer
)
{
EventRegionsOverride
result
=
aLayer
.
GetEventRegionsOverride
(
)
;
if
(
result
!
=
EventRegionsOverride
:
:
NoOverride
)
{
MOZ_ASSERT
(
aLayer
.
GetReferentId
(
)
)
;
}
if
(
aParent
)
{
result
|
=
aParent
-
>
GetEventRegionsOverride
(
)
;
}
return
result
;
}
void
APZCTreeManager
:
:
StartScrollbarDrag
(
const
ScrollableLayerGuid
&
aGuid
const
AsyncDragMetrics
&
aDragMetrics
)
{
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
aGuid
)
;
if
(
!
apzc
)
{
NotifyScrollbarDragRejected
(
aGuid
)
;
return
;
}
uint64_t
inputBlockId
=
aDragMetrics
.
mDragStartSequenceNumber
;
mInputQueue
-
>
ConfirmDragBlock
(
inputBlockId
apzc
aDragMetrics
)
;
}
bool
APZCTreeManager
:
:
StartAutoscroll
(
const
ScrollableLayerGuid
&
aGuid
const
ScreenPoint
&
aAnchorLocation
)
{
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
aGuid
)
;
if
(
!
apzc
)
{
if
(
XRE_IsGPUProcess
(
)
)
{
NotifyAutoscrollRejected
(
aGuid
)
;
}
return
false
;
}
apzc
-
>
StartAutoscroll
(
aAnchorLocation
)
;
return
true
;
}
void
APZCTreeManager
:
:
StopAutoscroll
(
const
ScrollableLayerGuid
&
aGuid
)
{
if
(
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
aGuid
)
)
{
apzc
-
>
StopAutoscroll
(
)
;
}
}
void
APZCTreeManager
:
:
NotifyScrollbarDragRejected
(
const
ScrollableLayerGuid
&
aGuid
)
const
{
RefPtr
<
GeckoContentController
>
controller
=
GetContentController
(
aGuid
.
mLayersId
)
;
MOZ_ASSERT
(
controller
)
;
controller
-
>
NotifyAsyncScrollbarDragRejected
(
aGuid
.
mScrollId
)
;
}
void
APZCTreeManager
:
:
NotifyAutoscrollRejected
(
const
ScrollableLayerGuid
&
aGuid
)
const
{
RefPtr
<
GeckoContentController
>
controller
=
GetContentController
(
aGuid
.
mLayersId
)
;
MOZ_ASSERT
(
controller
)
;
controller
-
>
NotifyAsyncAutoscrollRejected
(
aGuid
.
mScrollId
)
;
}
template
<
class
ScrollNode
>
HitTestingTreeNode
*
APZCTreeManager
:
:
PrepareNodeForLayer
(
const
ScrollNode
&
aLayer
const
FrameMetrics
&
aMetrics
uint64_t
aLayersId
const
AncestorTransform
&
aAncestorTransform
HitTestingTreeNode
*
aParent
HitTestingTreeNode
*
aNextSibling
TreeBuildingState
&
aState
)
{
mTreeLock
.
AssertCurrentThreadOwns
(
)
;
bool
needsApzc
=
true
;
if
(
!
aMetrics
.
IsScrollable
(
)
)
{
needsApzc
=
false
;
}
const
LayerTreeState
*
state
=
CompositorBridgeParent
:
:
GetIndirectShadowTree
(
aLayersId
)
;
if
(
!
(
state
&
&
state
-
>
mController
.
get
(
)
)
)
{
needsApzc
=
false
;
}
bool
parentHasPerspective
=
aState
.
mParentHasPerspective
.
top
(
)
;
RefPtr
<
HitTestingTreeNode
>
node
=
nullptr
;
if
(
!
needsApzc
)
{
node
=
RecycleOrCreateNode
(
aState
nullptr
aLayersId
)
;
AttachNodeToTree
(
node
aParent
aNextSibling
)
;
node
-
>
SetHitTestData
(
GetEventRegions
(
aLayer
)
aLayer
.
GetVisibleRegion
(
)
aLayer
.
GetTransformTyped
(
)
(
!
parentHasPerspective
&
&
aLayer
.
GetClipRect
(
)
)
?
Some
(
ParentLayerIntRegion
(
*
aLayer
.
GetClipRect
(
)
)
)
:
Nothing
(
)
GetEventRegionsOverride
(
aParent
aLayer
)
)
;
node
-
>
SetScrollbarData
(
aLayer
.
GetScrollbarTargetContainerId
(
)
aLayer
.
GetScrollbarAnimationId
(
)
aLayer
.
GetScrollThumbData
(
)
aLayer
.
GetScrollbarContainerDirection
(
)
)
;
node
-
>
SetFixedPosData
(
aLayer
.
GetFixedPositionScrollContainerId
(
)
)
;
return
node
;
}
AsyncPanZoomController
*
apzc
=
nullptr
;
ScrollableLayerGuid
guid
(
aLayersId
aMetrics
)
;
auto
insertResult
=
aState
.
mApzcMap
.
insert
(
std
:
:
make_pair
(
guid
static_cast
<
AsyncPanZoomController
*
>
(
nullptr
)
)
)
;
if
(
!
insertResult
.
second
)
{
apzc
=
insertResult
.
first
-
>
second
;
PrintAPZCInfo
(
aLayer
apzc
)
;
}
APZCTM_LOG
(
"
Found
APZC
%
p
for
layer
%
p
with
identifiers
%
"
PRId64
"
%
"
PRId64
"
\
n
"
apzc
aLayer
.
GetLayer
(
)
guid
.
mLayersId
guid
.
mScrollId
)
;
if
(
apzc
=
=
nullptr
)
{
apzc
=
aLayer
.
GetApzc
(
)
;
if
(
apzc
&
&
(
!
apzc
-
>
Matches
(
guid
)
|
|
!
apzc
-
>
HasTreeManager
(
this
)
)
)
{
apzc
=
nullptr
;
}
for
(
size_t
i
=
0
;
i
<
aState
.
mNodesToDestroy
.
Length
(
)
;
i
+
+
)
{
RefPtr
<
HitTestingTreeNode
>
n
=
aState
.
mNodesToDestroy
[
i
]
;
if
(
n
-
>
IsPrimaryHolder
(
)
&
&
n
-
>
GetApzc
(
)
&
&
n
-
>
GetApzc
(
)
-
>
Matches
(
guid
)
)
{
node
=
n
;
if
(
apzc
!
=
nullptr
)
{
MOZ_ASSERT
(
apzc
=
=
node
-
>
GetApzc
(
)
)
;
}
apzc
=
node
-
>
GetApzc
(
)
;
break
;
}
}
bool
newApzc
=
(
apzc
=
=
nullptr
|
|
apzc
-
>
IsDestroyed
(
)
)
;
if
(
newApzc
)
{
MOZ_ASSERT
(
aState
.
mLayerTreeState
)
;
apzc
=
NewAPZCInstance
(
aLayersId
state
-
>
mController
)
;
apzc
-
>
SetCompositorController
(
aState
.
mLayerTreeState
-
>
GetCompositorController
(
)
)
;
if
(
state
-
>
mCrossProcessParent
)
{
apzc
-
>
SetMetricsSharingController
(
state
-
>
CrossProcessSharingController
(
)
)
;
}
else
{
apzc
-
>
SetMetricsSharingController
(
aState
.
mLayerTreeState
-
>
InProcessSharingController
(
)
)
;
}
MOZ_ASSERT
(
node
=
=
nullptr
)
;
node
=
new
HitTestingTreeNode
(
apzc
true
aLayersId
)
;
}
else
{
aState
.
mNodesToDestroy
.
RemoveElement
(
node
)
;
node
-
>
SetPrevSibling
(
nullptr
)
;
node
-
>
SetLastChild
(
nullptr
)
;
}
APZCTM_LOG
(
"
Using
APZC
%
p
for
layer
%
p
with
identifiers
%
"
PRId64
"
%
"
PRId64
"
\
n
"
apzc
aLayer
.
GetLayer
(
)
aLayersId
aMetrics
.
GetScrollId
(
)
)
;
apzc
-
>
NotifyLayersUpdated
(
aLayer
.
Metadata
(
)
aState
.
mIsFirstPaint
aLayersId
=
=
aState
.
mOriginatingLayersId
)
;
MOZ_ASSERT
(
node
-
>
IsPrimaryHolder
(
)
&
&
node
-
>
GetApzc
(
)
&
&
node
-
>
GetApzc
(
)
-
>
Matches
(
guid
)
)
;
Maybe
<
ParentLayerIntRegion
>
clipRegion
=
parentHasPerspective
?
Nothing
(
)
:
Some
(
ComputeClipRegion
(
state
-
>
mController
aLayer
)
)
;
node
-
>
SetHitTestData
(
GetEventRegions
(
aLayer
)
aLayer
.
GetVisibleRegion
(
)
aLayer
.
GetTransformTyped
(
)
clipRegion
GetEventRegionsOverride
(
aParent
aLayer
)
)
;
apzc
-
>
SetAncestorTransform
(
aAncestorTransform
)
;
PrintAPZCInfo
(
aLayer
apzc
)
;
AttachNodeToTree
(
node
aParent
aNextSibling
)
;
if
(
aLayersId
=
=
aState
.
mOriginatingLayersId
)
{
if
(
apzc
-
>
HasNoParentWithSameLayersId
(
)
)
{
aState
.
mPaintLogger
.
LogTestData
(
aMetrics
.
GetScrollId
(
)
"
hasNoParentWithSameLayersId
"
true
)
;
}
else
{
MOZ_ASSERT
(
apzc
-
>
GetParent
(
)
)
;
aState
.
mPaintLogger
.
LogTestData
(
aMetrics
.
GetScrollId
(
)
"
parentScrollId
"
apzc
-
>
GetParent
(
)
-
>
GetGuid
(
)
.
mScrollId
)
;
}
if
(
aMetrics
.
IsRootContent
(
)
)
{
aState
.
mPaintLogger
.
LogTestData
(
aMetrics
.
GetScrollId
(
)
"
isRootContent
"
true
)
;
}
aState
.
mPaintLogger
.
LogTestData
(
aMetrics
.
GetScrollId
(
)
"
asyncScrollOffset
"
apzc
-
>
GetCurrentAsyncScrollOffset
(
AsyncPanZoomController
:
:
eForHitTesting
)
)
;
aState
.
mPaintLogger
.
LogTestData
(
aMetrics
.
GetScrollId
(
)
"
hasAsyncKeyScrolled
"
apzc
-
>
TestHasAsyncKeyScrolled
(
)
)
;
}
if
(
newApzc
)
{
auto
it
=
mZoomConstraints
.
find
(
guid
)
;
if
(
it
!
=
mZoomConstraints
.
end
(
)
)
{
apzc
-
>
UpdateZoomConstraints
(
it
-
>
second
)
;
}
else
if
(
!
apzc
-
>
HasNoParentWithSameLayersId
(
)
)
{
apzc
-
>
UpdateZoomConstraints
(
apzc
-
>
GetParent
(
)
-
>
GetZoomConstraints
(
)
)
;
}
}
insertResult
.
first
-
>
second
=
apzc
;
}
else
{
node
=
RecycleOrCreateNode
(
aState
apzc
aLayersId
)
;
AttachNodeToTree
(
node
aParent
aNextSibling
)
;
if
(
!
aAncestorTransform
.
mTransform
.
FuzzyEqualsMultiplicative
(
apzc
-
>
GetAncestorTransform
(
)
)
)
{
if
(
!
aAncestorTransform
.
mContainsPerspectiveTransform
&
&
!
apzc
-
>
AncestorTransformContainsPerspective
(
)
)
{
MOZ_ASSERT
(
false
"
Two
layers
that
scroll
together
have
different
ancestor
transforms
"
)
;
}
else
if
(
!
aAncestorTransform
.
mContainsPerspectiveTransform
)
{
apzc
-
>
SetAncestorTransform
(
aAncestorTransform
)
;
}
}
Maybe
<
ParentLayerIntRegion
>
clipRegion
=
parentHasPerspective
?
Nothing
(
)
:
Some
(
ComputeClipRegion
(
state
-
>
mController
aLayer
)
)
;
node
-
>
SetHitTestData
(
GetEventRegions
(
aLayer
)
aLayer
.
GetVisibleRegion
(
)
aLayer
.
GetTransformTyped
(
)
clipRegion
GetEventRegionsOverride
(
aParent
aLayer
)
)
;
}
node
-
>
SetScrollbarData
(
aLayer
.
GetScrollbarTargetContainerId
(
)
aLayer
.
GetScrollbarAnimationId
(
)
aLayer
.
GetScrollThumbData
(
)
aLayer
.
GetScrollbarContainerDirection
(
)
)
;
node
-
>
SetFixedPosData
(
aLayer
.
GetFixedPositionScrollContainerId
(
)
)
;
return
node
;
}
template
<
typename
PanGestureOrScrollWheelInput
>
static
bool
WillHandleInput
(
const
PanGestureOrScrollWheelInput
&
aPanInput
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
true
;
}
WidgetWheelEvent
wheelEvent
=
aPanInput
.
ToWidgetWheelEvent
(
nullptr
)
;
return
IAPZCTreeManager
:
:
WillHandleWheelEvent
(
&
wheelEvent
)
;
}
void
APZCTreeManager
:
:
FlushApzRepaints
(
uint64_t
aLayersId
)
{
APZCTM_LOG
(
"
Flushing
repaints
for
layers
id
0x
%
"
PRIx64
"
\
n
"
aLayersId
)
;
RefPtr
<
GeckoContentController
>
controller
=
GetContentController
(
aLayersId
)
;
MOZ_ASSERT
(
controller
)
;
controller
-
>
DispatchToRepaintThread
(
NewRunnableMethod
(
"
layers
:
:
GeckoContentController
:
:
NotifyFlushComplete
"
controller
&
GeckoContentController
:
:
NotifyFlushComplete
)
)
;
}
nsEventStatus
APZCTreeManager
:
:
ReceiveInputEvent
(
InputData
&
aEvent
ScrollableLayerGuid
*
aOutTargetGuid
uint64_t
*
aOutInputBlockId
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
AutoFocusSequenceNumberSetter
focusSetter
(
mFocusState
aEvent
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
MOZ_ASSERT
(
mToolbarAnimator
)
;
ScreenPoint
scrollOffset
;
{
MutexAutoLock
lock
(
mTreeLock
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
FindRootContentOrRootApzc
(
)
;
if
(
apzc
)
{
scrollOffset
=
ViewAs
<
ScreenPixel
>
(
apzc
-
>
GetCurrentAsyncScrollOffset
(
AsyncPanZoomController
:
:
eForHitTesting
)
PixelCastJustification
:
:
ScreenIsParentLayerForRoot
)
;
}
}
nsEventStatus
isConsumed
=
mToolbarAnimator
-
>
ReceiveInputEvent
(
aEvent
scrollOffset
)
;
if
(
isConsumed
=
=
nsEventStatus_eConsumeNoDefault
)
{
APZCTM_LOG
(
"
Dynamic
toolbar
consumed
event
"
)
;
return
isConsumed
;
}
#
endif
if
(
aOutInputBlockId
)
{
*
aOutInputBlockId
=
InputBlockState
:
:
NO_BLOCK_ID
;
}
nsEventStatus
result
=
nsEventStatus_eIgnore
;
CompositorHitTestInfo
hitResult
=
CompositorHitTestInfo
:
:
eInvisibleToHitTest
;
switch
(
aEvent
.
mInputType
)
{
case
MULTITOUCH_INPUT
:
{
MultiTouchInput
&
touchInput
=
aEvent
.
AsMultiTouchInput
(
)
;
result
=
ProcessTouchInput
(
touchInput
aOutTargetGuid
aOutInputBlockId
)
;
break
;
}
case
MOUSE_INPUT
:
{
MouseInput
&
mouseInput
=
aEvent
.
AsMouseInput
(
)
;
mouseInput
.
mHandledByAPZ
=
true
;
mCurrentMousePosition
=
mouseInput
.
mOrigin
;
bool
startsDrag
=
DragTracker
:
:
StartsDrag
(
mouseInput
)
;
if
(
startsDrag
)
{
FlushRepaintsToClearScreenToGeckoTransform
(
)
;
}
RefPtr
<
HitTestingTreeNode
>
hitScrollbarNode
=
nullptr
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
mouseInput
.
mOrigin
&
hitResult
&
hitScrollbarNode
)
;
bool
hitScrollbar
=
hitScrollbarNode
;
{
MutexAutoLock
lock
(
mTreeLock
)
;
if
(
!
apzc
&
&
mRootNode
)
{
apzc
=
mRootNode
-
>
GetApzc
(
)
;
}
}
if
(
apzc
)
{
if
(
gfxPrefs
:
:
APZTestLoggingEnabled
(
)
&
&
mouseInput
.
mType
=
=
MouseInput
:
:
MOUSE_HITTEST
)
{
ScrollableLayerGuid
guid
=
apzc
-
>
GetGuid
(
)
;
CompositorBridgeParent
:
:
CallWithIndirectShadowTree
(
guid
.
mLayersId
[
&
]
(
LayerTreeState
&
aState
)
-
>
void
{
aState
.
mApzTestData
.
RecordHitResult
(
mouseInput
.
mOrigin
hitResult
guid
.
mScrollId
)
;
}
)
;
}
bool
targetConfirmed
=
(
hitResult
!
=
CompositorHitTestInfo
:
:
eInvisibleToHitTest
)
&
&
!
(
hitResult
&
CompositorHitTestInfo
:
:
eDispatchToContent
)
;
bool
apzDragEnabled
=
gfxPrefs
:
:
APZDragEnabled
(
)
;
if
(
apzDragEnabled
&
&
hitScrollbar
)
{
targetConfirmed
=
false
;
}
result
=
mInputQueue
-
>
ReceiveInputEvent
(
apzc
targetConfirmed
mouseInput
aOutInputBlockId
)
;
if
(
apzDragEnabled
&
&
startsDrag
&
&
hitScrollbarNode
&
&
hitScrollbarNode
-
>
IsScrollThumbNode
(
)
&
&
hitScrollbarNode
-
>
GetScrollThumbData
(
)
.
mIsAsyncDraggable
)
{
SetupScrollbarDrag
(
mouseInput
hitScrollbarNode
.
get
(
)
apzc
.
get
(
)
)
;
}
if
(
result
=
=
nsEventStatus_eConsumeDoDefault
)
{
hitScrollbar
=
mInputQueue
-
>
IsDragOnScrollbar
(
hitScrollbar
)
;
}
apzc
-
>
GetGuid
(
aOutTargetGuid
)
;
if
(
!
hitScrollbar
)
{
ScreenToParentLayerMatrix4x4
transformToApzc
=
GetScreenToApzcTransform
(
apzc
)
;
ParentLayerToScreenMatrix4x4
transformToGecko
=
GetApzcToGeckoTransform
(
apzc
)
;
ScreenToScreenMatrix4x4
outTransform
=
transformToApzc
*
transformToGecko
;
Maybe
<
ScreenPoint
>
untransformedRefPoint
=
UntransformBy
(
outTransform
mouseInput
.
mOrigin
)
;
if
(
untransformedRefPoint
)
{
mouseInput
.
mOrigin
=
*
untransformedRefPoint
;
}
}
else
{
aOutTargetGuid
-
>
mScrollId
=
FrameMetrics
:
:
NULL_SCROLL_ID
;
}
}
break
;
}
case
SCROLLWHEEL_INPUT
:
{
FlushRepaintsToClearScreenToGeckoTransform
(
)
;
ScrollWheelInput
&
wheelInput
=
aEvent
.
AsScrollWheelInput
(
)
;
wheelInput
.
mHandledByAPZ
=
WillHandleInput
(
wheelInput
)
;
if
(
!
wheelInput
.
mHandledByAPZ
)
{
return
result
;
}
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
wheelInput
.
mOrigin
&
hitResult
)
;
if
(
apzc
)
{
MOZ_ASSERT
(
hitResult
!
=
CompositorHitTestInfo
:
:
eInvisibleToHitTest
)
;
ScreenToScreenMatrix4x4
transformToGecko
=
GetScreenToApzcTransform
(
apzc
)
*
GetApzcToGeckoTransform
(
apzc
)
;
Maybe
<
ScreenPoint
>
untransformedOrigin
=
UntransformBy
(
transformToGecko
wheelInput
.
mOrigin
)
;
if
(
!
untransformedOrigin
)
{
return
result
;
}
result
=
mInputQueue
-
>
ReceiveInputEvent
(
apzc
!
(
hitResult
&
CompositorHitTestInfo
:
:
eDispatchToContent
)
wheelInput
aOutInputBlockId
)
;
apzc
-
>
GetGuid
(
aOutTargetGuid
)
;
wheelInput
.
mOrigin
=
*
untransformedOrigin
;
}
break
;
}
case
PANGESTURE_INPUT
:
{
FlushRepaintsToClearScreenToGeckoTransform
(
)
;
PanGestureInput
&
panInput
=
aEvent
.
AsPanGestureInput
(
)
;
panInput
.
mHandledByAPZ
=
WillHandleInput
(
panInput
)
;
if
(
!
panInput
.
mHandledByAPZ
)
{
return
result
;
}
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
WidgetWheelEvent
wheelEvent
=
panInput
.
ToWidgetWheelEvent
(
nullptr
)
;
EventStateManager
:
:
GetUserPrefsForWheelEvent
(
&
wheelEvent
&
panInput
.
mUserDeltaMultiplierX
&
panInput
.
mUserDeltaMultiplierY
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
panInput
.
mPanStartPoint
&
hitResult
)
;
if
(
apzc
)
{
MOZ_ASSERT
(
hitResult
!
=
CompositorHitTestInfo
:
:
eInvisibleToHitTest
)
;
ScreenToScreenMatrix4x4
transformToGecko
=
GetScreenToApzcTransform
(
apzc
)
*
GetApzcToGeckoTransform
(
apzc
)
;
Maybe
<
ScreenPoint
>
untransformedStartPoint
=
UntransformBy
(
transformToGecko
panInput
.
mPanStartPoint
)
;
Maybe
<
ScreenPoint
>
untransformedDisplacement
=
UntransformVector
(
transformToGecko
panInput
.
mPanDisplacement
panInput
.
mPanStartPoint
)
;
if
(
!
untransformedStartPoint
|
|
!
untransformedDisplacement
)
{
return
result
;
}
result
=
mInputQueue
-
>
ReceiveInputEvent
(
apzc
!
(
hitResult
&
CompositorHitTestInfo
:
:
eDispatchToContent
)
panInput
aOutInputBlockId
)
;
apzc
-
>
GetGuid
(
aOutTargetGuid
)
;
panInput
.
mPanStartPoint
=
*
untransformedStartPoint
;
panInput
.
mPanDisplacement
=
*
untransformedDisplacement
;
panInput
.
mOverscrollBehaviorAllowsSwipe
=
apzc
-
>
OverscrollBehaviorAllowsSwipe
(
)
;
}
break
;
}
case
PINCHGESTURE_INPUT
:
{
PinchGestureInput
&
pinchInput
=
aEvent
.
AsPinchGestureInput
(
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
pinchInput
.
mFocusPoint
&
hitResult
)
;
if
(
apzc
)
{
MOZ_ASSERT
(
hitResult
!
=
CompositorHitTestInfo
:
:
eInvisibleToHitTest
)
;
ScreenToScreenMatrix4x4
outTransform
=
GetScreenToApzcTransform
(
apzc
)
*
GetApzcToGeckoTransform
(
apzc
)
;
Maybe
<
ScreenPoint
>
untransformedFocusPoint
=
UntransformBy
(
outTransform
pinchInput
.
mFocusPoint
)
;
if
(
!
untransformedFocusPoint
)
{
return
result
;
}
result
=
mInputQueue
-
>
ReceiveInputEvent
(
apzc
!
(
hitResult
&
CompositorHitTestInfo
:
:
eDispatchToContent
)
pinchInput
aOutInputBlockId
)
;
apzc
-
>
GetGuid
(
aOutTargetGuid
)
;
pinchInput
.
mFocusPoint
=
*
untransformedFocusPoint
;
}
break
;
}
case
TAPGESTURE_INPUT
:
{
TapGestureInput
&
tapInput
=
aEvent
.
AsTapGestureInput
(
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
tapInput
.
mPoint
&
hitResult
)
;
if
(
apzc
)
{
MOZ_ASSERT
(
hitResult
!
=
CompositorHitTestInfo
:
:
eInvisibleToHitTest
)
;
ScreenToScreenMatrix4x4
outTransform
=
GetScreenToApzcTransform
(
apzc
)
*
GetApzcToGeckoTransform
(
apzc
)
;
Maybe
<
ScreenIntPoint
>
untransformedPoint
=
UntransformBy
(
outTransform
tapInput
.
mPoint
)
;
if
(
!
untransformedPoint
)
{
return
result
;
}
result
=
mInputQueue
-
>
ReceiveInputEvent
(
apzc
!
(
hitResult
&
CompositorHitTestInfo
:
:
eDispatchToContent
)
tapInput
aOutInputBlockId
)
;
apzc
-
>
GetGuid
(
aOutTargetGuid
)
;
tapInput
.
mPoint
=
*
untransformedPoint
;
}
break
;
}
case
KEYBOARD_INPUT
:
{
if
(
!
gfxPrefs
:
:
APZKeyboardEnabled
(
)
|
|
gfxPrefs
:
:
AccessibilityBrowseWithCaret
(
)
)
{
APZ_KEY_LOG
(
"
Skipping
key
input
from
invalid
prefs
\
n
"
)
;
return
result
;
}
KeyboardInput
&
keyInput
=
aEvent
.
AsKeyboardInput
(
)
;
Maybe
<
KeyboardShortcut
>
shortcut
=
mKeyboardMap
.
FindMatch
(
keyInput
)
;
if
(
!
shortcut
)
{
APZ_KEY_LOG
(
"
Skipping
key
input
with
no
shortcut
\
n
"
)
;
if
(
mFocusState
.
CanIgnoreKeyboardShortcutMisses
(
)
)
{
focusSetter
.
MarkAsNonFocusChanging
(
)
;
}
return
result
;
}
if
(
shortcut
-
>
mDispatchToContent
)
{
APZ_KEY_LOG
(
"
Skipping
key
input
with
dispatch
-
to
-
content
shortcut
\
n
"
)
;
return
result
;
}
const
KeyboardScrollAction
&
action
=
shortcut
-
>
mAction
;
Maybe
<
ScrollableLayerGuid
>
targetGuid
;
switch
(
action
.
mType
)
{
case
KeyboardScrollAction
:
:
eScrollCharacter
:
{
targetGuid
=
mFocusState
.
GetHorizontalTarget
(
)
;
break
;
}
case
KeyboardScrollAction
:
:
eScrollLine
:
case
KeyboardScrollAction
:
:
eScrollPage
:
case
KeyboardScrollAction
:
:
eScrollComplete
:
{
targetGuid
=
mFocusState
.
GetVerticalTarget
(
)
;
break
;
}
}
if
(
!
targetGuid
)
{
APZ_KEY_LOG
(
"
Skipping
key
input
with
no
current
focus
target
\
n
"
)
;
return
result
;
}
RefPtr
<
AsyncPanZoomController
>
targetApzc
=
GetTargetAPZC
(
targetGuid
-
>
mLayersId
targetGuid
-
>
mScrollId
)
;
if
(
!
targetApzc
)
{
APZ_KEY_LOG
(
"
Skipping
key
input
with
focus
target
but
no
APZC
\
n
"
)
;
return
result
;
}
keyInput
.
mAction
=
action
;
APZ_KEY_LOG
(
"
Dispatching
key
input
with
apzc
=
%
p
\
n
"
targetApzc
.
get
(
)
)
;
result
=
mInputQueue
-
>
ReceiveInputEvent
(
targetApzc
true
keyInput
aOutInputBlockId
)
;
MOZ_ASSERT
(
result
=
=
nsEventStatus_eConsumeDoDefault
|
|
result
=
=
nsEventStatus_eConsumeNoDefault
)
;
keyInput
.
mHandledByAPZ
=
true
;
focusSetter
.
MarkAsNonFocusChanging
(
)
;
break
;
}
}
return
result
;
}
static
TouchBehaviorFlags
ConvertToTouchBehavior
(
CompositorHitTestInfo
info
)
{
TouchBehaviorFlags
result
=
AllowedTouchBehavior
:
:
UNKNOWN
;
if
(
info
=
=
CompositorHitTestInfo
:
:
eInvisibleToHitTest
)
{
result
=
AllowedTouchBehavior
:
:
NONE
;
}
else
if
(
info
&
CompositorHitTestInfo
:
:
eDispatchToContent
)
{
result
=
AllowedTouchBehavior
:
:
UNKNOWN
;
}
else
{
result
=
AllowedTouchBehavior
:
:
VERTICAL_PAN
|
AllowedTouchBehavior
:
:
HORIZONTAL_PAN
|
AllowedTouchBehavior
:
:
PINCH_ZOOM
|
AllowedTouchBehavior
:
:
DOUBLE_TAP_ZOOM
;
if
(
info
&
CompositorHitTestInfo
:
:
eTouchActionPanXDisabled
)
{
result
&
=
~
AllowedTouchBehavior
:
:
HORIZONTAL_PAN
;
}
if
(
info
&
CompositorHitTestInfo
:
:
eTouchActionPanYDisabled
)
{
result
&
=
~
AllowedTouchBehavior
:
:
VERTICAL_PAN
;
}
if
(
info
&
CompositorHitTestInfo
:
:
eTouchActionPinchZoomDisabled
)
{
result
&
=
~
AllowedTouchBehavior
:
:
PINCH_ZOOM
;
}
if
(
info
&
CompositorHitTestInfo
:
:
eTouchActionDoubleTapZoomDisabled
)
{
result
&
=
~
AllowedTouchBehavior
:
:
DOUBLE_TAP_ZOOM
;
}
}
return
result
;
}
already_AddRefed
<
AsyncPanZoomController
>
APZCTreeManager
:
:
GetTouchInputBlockAPZC
(
const
MultiTouchInput
&
aEvent
nsTArray
<
TouchBehaviorFlags
>
*
aOutTouchBehaviors
CompositorHitTestInfo
*
aOutHitResult
RefPtr
<
HitTestingTreeNode
>
*
aOutHitScrollbarNode
)
{
RefPtr
<
AsyncPanZoomController
>
apzc
;
if
(
aEvent
.
mTouches
.
Length
(
)
=
=
0
)
{
return
apzc
.
forget
(
)
;
}
FlushRepaintsToClearScreenToGeckoTransform
(
)
;
CompositorHitTestInfo
hitResult
;
apzc
=
GetTargetAPZC
(
aEvent
.
mTouches
[
0
]
.
mScreenPoint
&
hitResult
aOutHitScrollbarNode
)
;
if
(
aOutTouchBehaviors
)
{
aOutTouchBehaviors
-
>
AppendElement
(
ConvertToTouchBehavior
(
hitResult
)
)
;
}
for
(
size_t
i
=
1
;
i
<
aEvent
.
mTouches
.
Length
(
)
;
i
+
+
)
{
RefPtr
<
AsyncPanZoomController
>
apzc2
=
GetTargetAPZC
(
aEvent
.
mTouches
[
i
]
.
mScreenPoint
&
hitResult
)
;
if
(
aOutTouchBehaviors
)
{
aOutTouchBehaviors
-
>
AppendElement
(
ConvertToTouchBehavior
(
hitResult
)
)
;
}
apzc
=
GetMultitouchTarget
(
apzc
apzc2
)
;
APZCTM_LOG
(
"
Using
APZC
%
p
as
the
root
APZC
for
multi
-
touch
\
n
"
apzc
.
get
(
)
)
;
*
aOutHitScrollbarNode
=
nullptr
;
}
if
(
aOutHitResult
)
{
*
aOutHitResult
=
hitResult
;
}
return
apzc
.
forget
(
)
;
}
nsEventStatus
APZCTreeManager
:
:
ProcessTouchInput
(
MultiTouchInput
&
aInput
ScrollableLayerGuid
*
aOutTargetGuid
uint64_t
*
aOutInputBlockId
)
{
aInput
.
mHandledByAPZ
=
true
;
nsTArray
<
TouchBehaviorFlags
>
touchBehaviors
;
RefPtr
<
HitTestingTreeNode
>
hitScrollbarNode
=
nullptr
;
if
(
aInput
.
mType
=
=
MultiTouchInput
:
:
MULTITOUCH_START
)
{
if
(
mApzcForInputBlock
&
&
mApzcForInputBlock
-
>
IsInPanningState
(
)
&
&
BuildOverscrollHandoffChain
(
mApzcForInputBlock
)
-
>
HasOverscrolledApzc
(
)
)
{
if
(
mRetainedTouchIdentifier
=
=
-
1
)
{
mRetainedTouchIdentifier
=
mApzcForInputBlock
-
>
GetLastTouchIdentifier
(
)
;
}
return
nsEventStatus_eConsumeNoDefault
;
}
mHitResultForInputBlock
=
CompositorHitTestInfo
:
:
eInvisibleToHitTest
;
mApzcForInputBlock
=
GetTouchInputBlockAPZC
(
aInput
&
touchBehaviors
&
mHitResultForInputBlock
&
hitScrollbarNode
)
;
mInScrollbarTouchDrag
=
gfxPrefs
:
:
APZDragEnabled
(
)
&
&
gfxPrefs
:
:
APZTouchDragEnabled
(
)
&
&
hitScrollbarNode
&
&
hitScrollbarNode
-
>
IsScrollThumbNode
(
)
&
&
hitScrollbarNode
-
>
GetScrollThumbData
(
)
.
mIsAsyncDraggable
;
MOZ_ASSERT
(
touchBehaviors
.
Length
(
)
=
=
aInput
.
mTouches
.
Length
(
)
)
;
for
(
size_t
i
=
0
;
i
<
touchBehaviors
.
Length
(
)
;
i
+
+
)
{
APZCTM_LOG
(
"
Touch
point
has
allowed
behaviours
0x
%
02x
\
n
"
touchBehaviors
[
i
]
)
;
if
(
touchBehaviors
[
i
]
=
=
AllowedTouchBehavior
:
:
UNKNOWN
)
{
touchBehaviors
.
Clear
(
)
;
break
;
}
}
}
else
if
(
mApzcForInputBlock
)
{
APZCTM_LOG
(
"
Re
-
using
APZC
%
p
as
continuation
of
event
block
\
n
"
mApzcForInputBlock
.
get
(
)
)
;
}
nsEventStatus
result
=
nsEventStatus_eIgnore
;
if
(
mInScrollbarTouchDrag
)
{
result
=
ProcessTouchInputForScrollbarDrag
(
aInput
hitScrollbarNode
.
get
(
)
aOutTargetGuid
aOutInputBlockId
)
;
}
else
{
if
(
aInput
.
mType
=
=
MultiTouchInput
:
:
MULTITOUCH_CANCEL
)
{
mRetainedTouchIdentifier
=
-
1
;
}
if
(
mRetainedTouchIdentifier
!
=
-
1
)
{
for
(
size_t
j
=
0
;
j
<
aInput
.
mTouches
.
Length
(
)
;
+
+
j
)
{
if
(
aInput
.
mTouches
[
j
]
.
mIdentifier
!
=
mRetainedTouchIdentifier
)
{
aInput
.
mTouches
.
RemoveElementAt
(
j
)
;
if
(
!
touchBehaviors
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
touchBehaviors
.
Length
(
)
>
j
)
;
touchBehaviors
.
RemoveElementAt
(
j
)
;
}
-
-
j
;
}
}
if
(
aInput
.
mTouches
.
IsEmpty
(
)
)
{
return
nsEventStatus_eConsumeNoDefault
;
}
}
if
(
mApzcForInputBlock
)
{
MOZ_ASSERT
(
mHitResultForInputBlock
!
=
CompositorHitTestInfo
:
:
eInvisibleToHitTest
)
;
mApzcForInputBlock
-
>
GetGuid
(
aOutTargetGuid
)
;
uint64_t
inputBlockId
=
0
;
result
=
mInputQueue
-
>
ReceiveInputEvent
(
mApzcForInputBlock
!
(
mHitResultForInputBlock
&
CompositorHitTestInfo
:
:
eDispatchToContent
)
aInput
&
inputBlockId
)
;
if
(
aOutInputBlockId
)
{
*
aOutInputBlockId
=
inputBlockId
;
}
if
(
!
touchBehaviors
.
IsEmpty
(
)
)
{
mInputQueue
-
>
SetAllowedTouchBehavior
(
inputBlockId
touchBehaviors
)
;
}
ScreenToParentLayerMatrix4x4
transformToApzc
=
GetScreenToApzcTransform
(
mApzcForInputBlock
)
;
ParentLayerToScreenMatrix4x4
transformToGecko
=
GetApzcToGeckoTransform
(
mApzcForInputBlock
)
;
ScreenToScreenMatrix4x4
outTransform
=
transformToApzc
*
transformToGecko
;
for
(
size_t
i
=
0
;
i
<
aInput
.
mTouches
.
Length
(
)
;
i
+
+
)
{
SingleTouchData
&
touchData
=
aInput
.
mTouches
[
i
]
;
Maybe
<
ScreenIntPoint
>
untransformedScreenPoint
=
UntransformBy
(
outTransform
touchData
.
mScreenPoint
)
;
if
(
!
untransformedScreenPoint
)
{
return
nsEventStatus_eIgnore
;
}
touchData
.
mScreenPoint
=
*
untransformedScreenPoint
;
}
}
}
mTouchCounter
.
Update
(
aInput
)
;
if
(
mTouchCounter
.
GetActiveTouchCount
(
)
=
=
0
)
{
mApzcForInputBlock
=
nullptr
;
mHitResultForInputBlock
=
CompositorHitTestInfo
:
:
eInvisibleToHitTest
;
mRetainedTouchIdentifier
=
-
1
;
mInScrollbarTouchDrag
=
false
;
}
return
result
;
}
MouseInput
:
:
MouseType
MultiTouchTypeToMouseType
(
MultiTouchInput
:
:
MultiTouchType
aType
)
{
switch
(
aType
)
{
case
MultiTouchInput
:
:
MULTITOUCH_START
:
return
MouseInput
:
:
MOUSE_DOWN
;
case
MultiTouchInput
:
:
MULTITOUCH_MOVE
:
return
MouseInput
:
:
MOUSE_MOVE
;
case
MultiTouchInput
:
:
MULTITOUCH_END
:
case
MultiTouchInput
:
:
MULTITOUCH_CANCEL
:
return
MouseInput
:
:
MOUSE_UP
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
multi
-
touch
type
"
)
;
return
MouseInput
:
:
MOUSE_NONE
;
}
nsEventStatus
APZCTreeManager
:
:
ProcessTouchInputForScrollbarDrag
(
MultiTouchInput
&
aTouchInput
const
HitTestingTreeNode
*
aScrollThumbNode
ScrollableLayerGuid
*
aOutTargetGuid
uint64_t
*
aOutInputBlockId
)
{
MOZ_ASSERT
(
mRetainedTouchIdentifier
=
=
-
1
)
;
MOZ_ASSERT
(
mApzcForInputBlock
)
;
MOZ_ASSERT
(
aTouchInput
.
mTouches
.
Length
(
)
=
=
1
)
;
MouseInput
mouseInput
{
MultiTouchTypeToMouseType
(
aTouchInput
.
mType
)
MouseInput
:
:
LEFT_BUTTON
nsIDOMMouseEvent
:
:
MOZ_SOURCE_TOUCH
WidgetMouseEvent
:
:
eLeftButtonFlag
aTouchInput
.
mTouches
[
0
]
.
mScreenPoint
aTouchInput
.
mTime
aTouchInput
.
mTimeStamp
aTouchInput
.
modifiers
}
;
mouseInput
.
mHandledByAPZ
=
true
;
bool
targetConfirmed
=
false
;
nsEventStatus
result
=
mInputQueue
-
>
ReceiveInputEvent
(
mApzcForInputBlock
targetConfirmed
mouseInput
aOutInputBlockId
)
;
if
(
aScrollThumbNode
)
{
SetupScrollbarDrag
(
mouseInput
aScrollThumbNode
mApzcForInputBlock
.
get
(
)
)
;
}
mApzcForInputBlock
-
>
GetGuid
(
aOutTargetGuid
)
;
aOutTargetGuid
-
>
mScrollId
=
FrameMetrics
:
:
NULL_SCROLL_ID
;
return
result
;
}
void
APZCTreeManager
:
:
SetupScrollbarDrag
(
MouseInput
&
aMouseInput
const
HitTestingTreeNode
*
aScrollThumbNode
AsyncPanZoomController
*
aApzc
)
{
DragBlockState
*
dragBlock
=
mInputQueue
-
>
GetCurrentDragBlock
(
)
;
if
(
!
dragBlock
)
{
return
;
}
const
ScrollThumbData
&
thumbData
=
aScrollThumbNode
-
>
GetScrollThumbData
(
)
;
MOZ_ASSERT
(
thumbData
.
mDirection
.
isSome
(
)
)
;
dragBlock
-
>
SetInitialThumbPos
(
thumbData
.
mThumbStart
)
;
if
(
gfxPrefs
:
:
APZDragInitiationEnabled
(
)
&
&
aScrollThumbNode
-
>
GetScrollTargetId
(
)
=
=
aApzc
-
>
GetGuid
(
)
.
mScrollId
&
&
!
aApzc
-
>
IsScrollInfoLayer
(
)
)
{
uint64_t
dragBlockId
=
dragBlock
-
>
GetBlockId
(
)
;
aMouseInput
.
TransformToLocal
(
aApzc
-
>
GetTransformToThis
(
)
)
;
CSSCoord
dragStart
=
aApzc
-
>
ConvertScrollbarPoint
(
aMouseInput
.
mLocalOrigin
thumbData
)
;
LayerToParentLayerMatrix4x4
thumbTransform
;
{
MutexAutoLock
lock
(
mTreeLock
)
;
thumbTransform
=
ComputeTransformForNode
(
aScrollThumbNode
)
;
}
CSSCoord
thumbStart
=
thumbData
.
mThumbStart
+
(
(
*
thumbData
.
mDirection
=
=
ScrollDirection
:
:
eHorizontal
)
?
thumbTransform
.
_41
:
thumbTransform
.
_42
)
;
dragStart
-
=
thumbStart
;
dragBlock
-
>
SetContentResponse
(
false
)
;
mInputQueue
-
>
ConfirmDragBlock
(
dragBlockId
aApzc
AsyncDragMetrics
(
aApzc
-
>
GetGuid
(
)
.
mScrollId
aApzc
-
>
GetGuid
(
)
.
mPresShellId
dragBlockId
dragStart
*
thumbData
.
mDirection
)
)
;
}
}
void
APZCTreeManager
:
:
UpdateWheelTransaction
(
LayoutDeviceIntPoint
aRefPoint
EventMessage
aEventMessage
)
{
WheelBlockState
*
txn
=
mInputQueue
-
>
GetActiveWheelTransaction
(
)
;
if
(
!
txn
)
{
return
;
}
if
(
txn
-
>
MaybeTimeout
(
TimeStamp
:
:
Now
(
)
)
)
{
return
;
}
switch
(
aEventMessage
)
{
case
eMouseMove
:
case
eDragOver
:
{
ScreenIntPoint
point
=
ViewAs
<
ScreenPixel
>
(
aRefPoint
PixelCastJustification
:
:
LayoutDeviceIsScreenForUntransformedEvent
)
;
txn
-
>
OnMouseMove
(
point
)
;
return
;
}
case
eKeyPress
:
case
eKeyUp
:
case
eKeyDown
:
case
eMouseUp
:
case
eMouseDown
:
case
eMouseDoubleClick
:
case
eMouseAuxClick
:
case
eMouseClick
:
case
eContextMenu
:
case
eDrop
:
txn
-
>
EndTransaction
(
)
;
return
;
default
:
break
;
}
}
void
APZCTreeManager
:
:
ProcessUnhandledEvent
(
LayoutDeviceIntPoint
*
aRefPoint
ScrollableLayerGuid
*
aOutTargetGuid
uint64_t
*
aOutFocusSequenceNumber
)
{
CompositorHitTestInfo
hitResult
=
CompositorHitTestInfo
:
:
eInvisibleToHitTest
;
PixelCastJustification
LDIsScreen
=
PixelCastJustification
:
:
LayoutDeviceIsScreenForUntransformedEvent
;
ScreenIntPoint
refPointAsScreen
=
ViewAs
<
ScreenPixel
>
(
*
aRefPoint
LDIsScreen
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
refPointAsScreen
&
hitResult
)
;
if
(
apzc
)
{
MOZ_ASSERT
(
hitResult
!
=
CompositorHitTestInfo
:
:
eInvisibleToHitTest
)
;
apzc
-
>
GetGuid
(
aOutTargetGuid
)
;
ScreenToParentLayerMatrix4x4
transformToApzc
=
GetScreenToApzcTransform
(
apzc
)
;
ParentLayerToScreenMatrix4x4
transformToGecko
=
GetApzcToGeckoTransform
(
apzc
)
;
ScreenToScreenMatrix4x4
outTransform
=
transformToApzc
*
transformToGecko
;
Maybe
<
ScreenIntPoint
>
untransformedRefPoint
=
UntransformBy
(
outTransform
refPointAsScreen
)
;
if
(
untransformedRefPoint
)
{
*
aRefPoint
=
ViewAs
<
LayoutDevicePixel
>
(
*
untransformedRefPoint
LDIsScreen
)
;
}
}
mFocusState
.
ReceiveFocusChangingEvent
(
)
;
*
aOutFocusSequenceNumber
=
mFocusState
.
LastAPZProcessedEvent
(
)
;
}
void
APZCTreeManager
:
:
ProcessTouchVelocity
(
uint32_t
aTimestampMs
float
aSpeedY
)
{
if
(
mApzcForInputBlock
)
{
mApzcForInputBlock
-
>
HandleTouchVelocity
(
aTimestampMs
aSpeedY
)
;
}
}
void
APZCTreeManager
:
:
SetKeyboardMap
(
const
KeyboardMap
&
aKeyboardMap
)
{
mKeyboardMap
=
aKeyboardMap
;
}
void
APZCTreeManager
:
:
ZoomToRect
(
const
ScrollableLayerGuid
&
aGuid
const
CSSRect
&
aRect
const
uint32_t
aFlags
)
{
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
aGuid
)
;
if
(
apzc
)
{
apzc
-
>
ZoomToRect
(
aRect
aFlags
)
;
}
}
void
APZCTreeManager
:
:
ContentReceivedInputBlock
(
uint64_t
aInputBlockId
bool
aPreventDefault
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
mInputQueue
-
>
ContentReceivedInputBlock
(
aInputBlockId
aPreventDefault
)
;
}
void
APZCTreeManager
:
:
SetTargetAPZC
(
uint64_t
aInputBlockId
const
nsTArray
<
ScrollableLayerGuid
>
&
aTargets
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
RefPtr
<
AsyncPanZoomController
>
target
=
nullptr
;
if
(
aTargets
.
Length
(
)
>
0
)
{
target
=
GetTargetAPZC
(
aTargets
[
0
]
)
;
}
for
(
size_t
i
=
1
;
i
<
aTargets
.
Length
(
)
;
i
+
+
)
{
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
aTargets
[
i
]
)
;
target
=
GetMultitouchTarget
(
target
apzc
)
;
}
mInputQueue
-
>
SetConfirmedTargetApzc
(
aInputBlockId
target
)
;
}
void
APZCTreeManager
:
:
SetTargetAPZC
(
uint64_t
aInputBlockId
const
ScrollableLayerGuid
&
aTarget
)
{
APZThreadUtils
:
:
AssertOnControllerThread
(
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
aTarget
)
;
mInputQueue
-
>
SetConfirmedTargetApzc
(
aInputBlockId
apzc
)
;
}
void
APZCTreeManager
:
:
UpdateZoomConstraints
(
const
ScrollableLayerGuid
&
aGuid
const
Maybe
<
ZoomConstraints
>
&
aConstraints
)
{
MutexAutoLock
lock
(
mTreeLock
)
;
RefPtr
<
HitTestingTreeNode
>
node
=
GetTargetNode
(
aGuid
nullptr
)
;
MOZ_ASSERT
(
!
node
|
|
node
-
>
GetApzc
(
)
)
;
if
(
aConstraints
)
{
APZCTM_LOG
(
"
Recording
constraints
%
s
for
guid
%
s
\
n
"
Stringify
(
aConstraints
.
value
(
)
)
.
c_str
(
)
Stringify
(
aGuid
)
.
c_str
(
)
)
;
mZoomConstraints
[
aGuid
]
=
aConstraints
.
ref
(
)
;
}
else
{
APZCTM_LOG
(
"
Removing
constraints
for
guid
%
s
\
n
"
Stringify
(
aGuid
)
.
c_str
(
)
)
;
mZoomConstraints
.
erase
(
aGuid
)
;
}
if
(
node
&
&
aConstraints
)
{
ForEachNode
<
ReverseIterator
>
(
node
.
get
(
)
[
&
aConstraints
&
node
this
]
(
HitTestingTreeNode
*
aNode
)
{
if
(
aNode
!
=
node
)
{
if
(
AsyncPanZoomController
*
childApzc
=
aNode
-
>
GetApzc
(
)
)
{
if
(
childApzc
-
>
HasNoParentWithSameLayersId
(
)
|
|
this
-
>
mZoomConstraints
.
find
(
childApzc
-
>
GetGuid
(
)
)
!
=
this
-
>
mZoomConstraints
.
end
(
)
)
{
return
TraversalFlag
:
:
Skip
;
}
}
}
if
(
aNode
-
>
IsPrimaryHolder
(
)
)
{
MOZ_ASSERT
(
aNode
-
>
GetApzc
(
)
)
;
aNode
-
>
GetApzc
(
)
-
>
UpdateZoomConstraints
(
aConstraints
.
ref
(
)
)
;
}
return
TraversalFlag
:
:
Continue
;
}
)
;
}
}
void
APZCTreeManager
:
:
FlushRepaintsToClearScreenToGeckoTransform
(
)
{
MutexAutoLock
lock
(
mTreeLock
)
;
mTreeLock
.
AssertCurrentThreadOwns
(
)
;
ForEachNode
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
]
(
HitTestingTreeNode
*
aNode
)
{
if
(
aNode
-
>
IsPrimaryHolder
(
)
)
{
MOZ_ASSERT
(
aNode
-
>
GetApzc
(
)
)
;
aNode
-
>
GetApzc
(
)
-
>
FlushRepaintForNewInputBlock
(
)
;
}
}
)
;
}
void
APZCTreeManager
:
:
CancelAnimation
(
const
ScrollableLayerGuid
&
aGuid
)
{
RefPtr
<
AsyncPanZoomController
>
apzc
=
GetTargetAPZC
(
aGuid
)
;
if
(
apzc
)
{
apzc
-
>
CancelAnimation
(
)
;
}
}
void
APZCTreeManager
:
:
AdjustScrollForSurfaceShift
(
const
ScreenPoint
&
aShift
)
{
MutexAutoLock
lock
(
mTreeLock
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
FindRootContentOrRootApzc
(
)
;
if
(
apzc
)
{
apzc
-
>
AdjustScrollForSurfaceShift
(
aShift
)
;
}
}
void
APZCTreeManager
:
:
ClearTree
(
)
{
APZThreadUtils
:
:
RunOnControllerThread
(
NewRunnableMethod
(
"
layers
:
:
InputQueue
:
:
Clear
"
mInputQueue
&
InputQueue
:
:
Clear
)
)
;
MutexAutoLock
lock
(
mTreeLock
)
;
nsTArray
<
RefPtr
<
HitTestingTreeNode
>
>
nodesToDestroy
;
ForEachNode
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
&
nodesToDestroy
]
(
HitTestingTreeNode
*
aNode
)
{
nodesToDestroy
.
AppendElement
(
aNode
)
;
}
)
;
for
(
size_t
i
=
0
;
i
<
nodesToDestroy
.
Length
(
)
;
i
+
+
)
{
nodesToDestroy
[
i
]
-
>
Destroy
(
)
;
}
mRootNode
=
nullptr
;
RefPtr
<
APZCTreeManager
>
self
(
this
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
layers
:
:
APZCTreeManager
:
:
ClearTree
"
[
self
]
{
self
-
>
mFlushObserver
-
>
Unregister
(
)
;
self
-
>
mFlushObserver
=
nullptr
;
}
)
)
;
}
RefPtr
<
HitTestingTreeNode
>
APZCTreeManager
:
:
GetRootNode
(
)
const
{
MutexAutoLock
lock
(
mTreeLock
)
;
return
mRootNode
;
}
static
bool
TransformDisplacement
(
APZCTreeManager
*
aTreeManager
AsyncPanZoomController
*
aSource
AsyncPanZoomController
*
aTarget
ParentLayerPoint
&
aStartPoint
ParentLayerPoint
&
aEndPoint
)
{
if
(
aSource
=
=
aTarget
)
{
return
true
;
}
ParentLayerToScreenMatrix4x4
untransformToApzc
=
aTreeManager
-
>
GetScreenToApzcTransform
(
aSource
)
.
Inverse
(
)
;
ScreenPoint
screenStart
=
TransformBy
(
untransformToApzc
aStartPoint
)
;
ScreenPoint
screenEnd
=
TransformBy
(
untransformToApzc
aEndPoint
)
;
ScreenToParentLayerMatrix4x4
transformToApzc
=
aTreeManager
-
>
GetScreenToApzcTransform
(
aTarget
)
;
Maybe
<
ParentLayerPoint
>
startPoint
=
UntransformBy
(
transformToApzc
screenStart
)
;
Maybe
<
ParentLayerPoint
>
endPoint
=
UntransformBy
(
transformToApzc
screenEnd
)
;
if
(
!
startPoint
|
|
!
endPoint
)
{
return
false
;
}
aEndPoint
=
*
endPoint
;
aStartPoint
=
*
startPoint
;
return
true
;
}
void
APZCTreeManager
:
:
DispatchScroll
(
AsyncPanZoomController
*
aPrev
ParentLayerPoint
&
aStartPoint
ParentLayerPoint
&
aEndPoint
OverscrollHandoffState
&
aOverscrollHandoffState
)
{
const
OverscrollHandoffChain
&
overscrollHandoffChain
=
aOverscrollHandoffState
.
mChain
;
uint32_t
overscrollHandoffChainIndex
=
aOverscrollHandoffState
.
mChainIndex
;
RefPtr
<
AsyncPanZoomController
>
next
;
if
(
overscrollHandoffChainIndex
>
=
overscrollHandoffChain
.
Length
(
)
)
{
return
;
}
next
=
overscrollHandoffChain
.
GetApzcAtIndex
(
overscrollHandoffChainIndex
)
;
if
(
next
=
=
nullptr
|
|
next
-
>
IsDestroyed
(
)
)
{
return
;
}
if
(
!
TransformDisplacement
(
this
aPrev
next
aStartPoint
aEndPoint
)
)
{
return
;
}
if
(
!
next
-
>
AttemptScroll
(
aStartPoint
aEndPoint
aOverscrollHandoffState
)
)
{
if
(
!
TransformDisplacement
(
this
next
aPrev
aStartPoint
aEndPoint
)
)
{
NS_WARNING
(
"
Failed
to
untransform
scroll
points
during
dispatch
"
)
;
}
}
}
ParentLayerPoint
APZCTreeManager
:
:
DispatchFling
(
AsyncPanZoomController
*
aPrev
const
FlingHandoffState
&
aHandoffState
)
{
if
(
aHandoffState
.
mIsHandoff
&
&
!
gfxPrefs
:
:
APZAllowImmediateHandoff
(
)
&
&
aHandoffState
.
mScrolledApzc
=
=
aPrev
)
{
return
aHandoffState
.
mVelocity
;
}
const
OverscrollHandoffChain
*
chain
=
aHandoffState
.
mChain
;
RefPtr
<
AsyncPanZoomController
>
current
;
uint32_t
overscrollHandoffChainLength
=
chain
-
>
Length
(
)
;
uint32_t
startIndex
;
ParentLayerPoint
startPoint
;
ParentLayerPoint
endPoint
;
if
(
aHandoffState
.
mIsHandoff
)
{
startIndex
=
chain
-
>
IndexOf
(
aPrev
)
+
1
;
if
(
startIndex
>
=
overscrollHandoffChainLength
)
{
return
aHandoffState
.
mVelocity
;
}
}
else
{
startIndex
=
0
;
}
ParentLayerPoint
finalResidualVelocity
=
aHandoffState
.
mVelocity
;
ParentLayerPoint
currentVelocity
=
aHandoffState
.
mVelocity
;
for
(
;
startIndex
<
overscrollHandoffChainLength
;
startIndex
+
+
)
{
current
=
chain
-
>
GetApzcAtIndex
(
startIndex
)
;
if
(
current
=
=
nullptr
|
|
current
-
>
IsDestroyed
(
)
)
{
break
;
}
endPoint
=
startPoint
+
currentVelocity
;
RefPtr
<
AsyncPanZoomController
>
prevApzc
=
(
startIndex
>
0
)
?
chain
-
>
GetApzcAtIndex
(
startIndex
-
1
)
:
nullptr
;
if
(
prevApzc
)
{
if
(
!
TransformDisplacement
(
this
prevApzc
current
startPoint
endPoint
)
)
{
break
;
}
}
ParentLayerPoint
availableVelocity
=
(
endPoint
-
startPoint
)
;
ParentLayerPoint
residualVelocity
;
FlingHandoffState
transformedHandoffState
=
aHandoffState
;
transformedHandoffState
.
mVelocity
=
availableVelocity
;
if
(
prevApzc
)
{
residualVelocity
+
=
prevApzc
-
>
AdjustHandoffVelocityForOverscrollBehavior
(
transformedHandoffState
.
mVelocity
)
;
}
residualVelocity
+
=
current
-
>
AttemptFling
(
transformedHandoffState
)
;
if
(
IsZero
(
residualVelocity
)
)
{
return
ParentLayerPoint
(
)
;
}
if
(
!
FuzzyEqualsAdditive
(
availableVelocity
.
x
residualVelocity
.
x
COORDINATE_EPSILON
)
)
{
finalResidualVelocity
.
x
*
=
(
residualVelocity
.
x
/
availableVelocity
.
x
)
;
}
if
(
!
FuzzyEqualsAdditive
(
availableVelocity
.
y
residualVelocity
.
y
COORDINATE_EPSILON
)
)
{
finalResidualVelocity
.
y
*
=
(
residualVelocity
.
y
/
availableVelocity
.
y
)
;
}
currentVelocity
=
residualVelocity
;
}
return
finalResidualVelocity
;
}
bool
APZCTreeManager
:
:
HitTestAPZC
(
const
ScreenIntPoint
&
aPoint
)
{
RefPtr
<
AsyncPanZoomController
>
target
=
GetTargetAPZC
(
aPoint
nullptr
)
;
return
target
!
=
nullptr
;
}
already_AddRefed
<
AsyncPanZoomController
>
APZCTreeManager
:
:
GetTargetAPZC
(
const
ScrollableLayerGuid
&
aGuid
)
{
MutexAutoLock
lock
(
mTreeLock
)
;
RefPtr
<
HitTestingTreeNode
>
node
=
GetTargetNode
(
aGuid
nullptr
)
;
MOZ_ASSERT
(
!
node
|
|
node
-
>
GetApzc
(
)
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
node
?
node
-
>
GetApzc
(
)
:
nullptr
;
return
apzc
.
forget
(
)
;
}
static
bool
GuidComparatorIgnoringPresShell
(
const
ScrollableLayerGuid
&
aOne
const
ScrollableLayerGuid
&
aTwo
)
{
return
aOne
.
mLayersId
=
=
aTwo
.
mLayersId
&
&
aOne
.
mScrollId
=
=
aTwo
.
mScrollId
;
}
already_AddRefed
<
AsyncPanZoomController
>
APZCTreeManager
:
:
GetTargetAPZC
(
const
uint64_t
&
aLayersId
const
FrameMetrics
:
:
ViewID
&
aScrollId
)
{
MutexAutoLock
lock
(
mTreeLock
)
;
ScrollableLayerGuid
guid
(
aLayersId
0
aScrollId
)
;
RefPtr
<
HitTestingTreeNode
>
node
=
GetTargetNode
(
guid
&
GuidComparatorIgnoringPresShell
)
;
MOZ_ASSERT
(
!
node
|
|
node
-
>
GetApzc
(
)
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
=
node
?
node
-
>
GetApzc
(
)
:
nullptr
;
return
apzc
.
forget
(
)
;
}
already_AddRefed
<
HitTestingTreeNode
>
APZCTreeManager
:
:
GetTargetNode
(
const
ScrollableLayerGuid
&
aGuid
GuidComparator
aComparator
)
const
{
mTreeLock
.
AssertCurrentThreadOwns
(
)
;
RefPtr
<
HitTestingTreeNode
>
target
=
DepthFirstSearchPostOrder
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
&
aGuid
&
aComparator
]
(
HitTestingTreeNode
*
node
)
{
bool
matches
=
false
;
if
(
node
-
>
GetApzc
(
)
)
{
if
(
aComparator
)
{
matches
=
aComparator
(
aGuid
node
-
>
GetApzc
(
)
-
>
GetGuid
(
)
)
;
}
else
{
matches
=
node
-
>
GetApzc
(
)
-
>
Matches
(
aGuid
)
;
}
}
return
matches
;
}
)
;
return
target
.
forget
(
)
;
}
already_AddRefed
<
AsyncPanZoomController
>
APZCTreeManager
:
:
GetTargetAPZC
(
const
ScreenPoint
&
aPoint
CompositorHitTestInfo
*
aOutHitResult
RefPtr
<
HitTestingTreeNode
>
*
aOutScrollbarNode
)
{
MutexAutoLock
lock
(
mTreeLock
)
;
CompositorHitTestInfo
hitResult
=
CompositorHitTestInfo
:
:
eInvisibleToHitTest
;
HitTestingTreeNode
*
scrollbarNode
=
nullptr
;
RefPtr
<
AsyncPanZoomController
>
target
;
if
(
gfx
:
:
gfxVars
:
:
UseWebRender
(
)
&
&
gfxPrefs
:
:
WebRenderHitTest
(
)
)
{
target
=
GetAPZCAtPointWR
(
aPoint
&
hitResult
&
scrollbarNode
)
;
}
else
{
target
=
GetAPZCAtPoint
(
mRootNode
aPoint
&
hitResult
&
scrollbarNode
)
;
}
if
(
aOutHitResult
)
{
*
aOutHitResult
=
hitResult
;
}
if
(
aOutScrollbarNode
)
{
*
aOutScrollbarNode
=
scrollbarNode
;
}
return
target
.
forget
(
)
;
}
already_AddRefed
<
AsyncPanZoomController
>
APZCTreeManager
:
:
GetAPZCAtPointWR
(
const
ScreenPoint
&
aHitTestPoint
CompositorHitTestInfo
*
aOutHitResult
HitTestingTreeNode
*
*
aOutScrollbarNode
)
{
MOZ_ASSERT
(
aOutHitResult
)
;
MOZ_ASSERT
(
aOutScrollbarNode
)
;
RefPtr
<
AsyncPanZoomController
>
result
;
RefPtr
<
wr
:
:
WebRenderAPI
>
wr
=
GetWebRenderAPI
(
)
;
if
(
!
wr
)
{
result
=
FindRootApzcForLayersId
(
mRootLayersId
)
;
*
aOutHitResult
=
CompositorHitTestInfo
:
:
eVisibleToHitTest
;
return
result
.
forget
(
)
;
}
wr
:
:
WrPipelineId
pipelineId
;
FrameMetrics
:
:
ViewID
scrollId
;
gfx
:
:
CompositorHitTestInfo
hitInfo
;
bool
hitSomething
=
wr
-
>
HitTest
(
wr
:
:
ToWorldPoint
(
aHitTestPoint
)
pipelineId
scrollId
hitInfo
)
;
if
(
!
hitSomething
)
{
return
result
.
forget
(
)
;
}
uint64_t
layersId
=
wr
:
:
AsUint64
(
pipelineId
)
;
RefPtr
<
HitTestingTreeNode
>
node
=
GetTargetNode
(
ScrollableLayerGuid
(
layersId
0
scrollId
)
&
GuidComparatorIgnoringPresShell
)
;
MOZ_ASSERT
(
!
node
|
|
node
-
>
GetApzc
(
)
)
;
result
=
node
?
node
-
>
GetApzc
(
)
:
nullptr
;
if
(
!
result
)
{
MOZ_ASSERT
(
scrollId
=
=
FrameMetrics
:
:
NULL_SCROLL_ID
)
;
result
=
FindRootApzcForLayersId
(
layersId
)
;
MOZ_ASSERT
(
result
)
;
}
bool
isScrollbar
=
bool
(
hitInfo
&
gfx
:
:
CompositorHitTestInfo
:
:
eScrollbar
)
;
bool
isScrollbarThumb
=
bool
(
hitInfo
&
gfx
:
:
CompositorHitTestInfo
:
:
eScrollbarThumb
)
;
ScrollDirection
direction
=
(
hitInfo
&
gfx
:
:
CompositorHitTestInfo
:
:
eScrollbarVertical
)
?
ScrollDirection
:
:
eVertical
:
ScrollDirection
:
:
eHorizontal
;
if
(
isScrollbar
|
|
isScrollbarThumb
)
{
*
aOutScrollbarNode
=
BreadthFirstSearch
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
&
]
(
HitTestingTreeNode
*
aNode
)
{
return
(
aNode
-
>
GetLayersId
(
)
=
=
layersId
)
&
&
(
aNode
-
>
IsScrollbarNode
(
)
=
=
isScrollbar
)
&
&
(
aNode
-
>
IsScrollThumbNode
(
)
=
=
isScrollbarThumb
)
&
&
(
aNode
-
>
GetScrollbarDirection
(
)
=
=
direction
)
&
&
(
aNode
-
>
GetScrollTargetId
(
)
=
=
scrollId
)
;
}
)
;
}
*
aOutHitResult
=
hitInfo
;
return
result
.
forget
(
)
;
}
RefPtr
<
const
OverscrollHandoffChain
>
APZCTreeManager
:
:
BuildOverscrollHandoffChain
(
const
RefPtr
<
AsyncPanZoomController
>
&
aInitialTarget
)
{
MutexAutoLock
lock
(
mTreeLock
)
;
OverscrollHandoffChain
*
result
=
new
OverscrollHandoffChain
;
AsyncPanZoomController
*
apzc
=
aInitialTarget
;
while
(
apzc
!
=
nullptr
)
{
result
-
>
Add
(
apzc
)
;
if
(
apzc
-
>
GetScrollHandoffParentId
(
)
=
=
FrameMetrics
:
:
NULL_SCROLL_ID
)
{
if
(
!
apzc
-
>
IsRootForLayersId
(
)
)
{
NS_WARNING
(
"
Found
a
non
-
root
APZ
with
no
handoff
parent
"
)
;
}
apzc
=
apzc
-
>
GetParent
(
)
;
continue
;
}
MOZ_ASSERT
(
apzc
-
>
GetScrollHandoffParentId
(
)
!
=
apzc
-
>
GetGuid
(
)
.
mScrollId
)
;
AsyncPanZoomController
*
scrollParent
=
nullptr
;
AsyncPanZoomController
*
parent
=
apzc
;
while
(
!
parent
-
>
HasNoParentWithSameLayersId
(
)
)
{
parent
=
parent
-
>
GetParent
(
)
;
if
(
parent
-
>
GetGuid
(
)
.
mScrollId
=
=
apzc
-
>
GetScrollHandoffParentId
(
)
)
{
scrollParent
=
parent
;
break
;
}
}
if
(
!
scrollParent
)
{
ScrollableLayerGuid
guid
(
parent
-
>
GetGuid
(
)
.
mLayersId
0
apzc
-
>
GetScrollHandoffParentId
(
)
)
;
RefPtr
<
HitTestingTreeNode
>
node
=
GetTargetNode
(
guid
&
GuidComparatorIgnoringPresShell
)
;
MOZ_ASSERT
(
!
node
|
|
node
-
>
GetApzc
(
)
)
;
scrollParent
=
node
?
node
-
>
GetApzc
(
)
:
nullptr
;
}
apzc
=
scrollParent
;
}
result
-
>
SortByScrollPriority
(
)
;
for
(
uint32_t
i
=
0
;
i
<
result
-
>
Length
(
)
;
+
+
i
)
{
APZCTM_LOG
(
"
OverscrollHandoffChain
[
%
d
]
=
%
p
\
n
"
i
result
-
>
GetApzcAtIndex
(
i
)
.
get
(
)
)
;
}
return
result
;
}
void
APZCTreeManager
:
:
SetLongTapEnabled
(
bool
aLongTapEnabled
)
{
APZThreadUtils
:
:
RunOnControllerThread
(
NewRunnableFunction
(
"
SetLongTapEnabledRunnable
"
GestureEventListener
:
:
SetLongTapEnabled
aLongTapEnabled
)
)
;
}
RefPtr
<
HitTestingTreeNode
>
APZCTreeManager
:
:
FindScrollThumbNode
(
const
AsyncDragMetrics
&
aDragMetrics
)
{
MutexAutoLock
lock
(
mTreeLock
)
;
return
DepthFirstSearch
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
&
aDragMetrics
]
(
HitTestingTreeNode
*
aNode
)
{
return
aNode
-
>
MatchesScrollDragMetrics
(
aDragMetrics
)
;
}
)
;
}
AsyncPanZoomController
*
APZCTreeManager
:
:
GetTargetApzcForNode
(
HitTestingTreeNode
*
aNode
)
{
for
(
const
HitTestingTreeNode
*
n
=
aNode
;
n
&
&
n
-
>
GetLayersId
(
)
=
=
aNode
-
>
GetLayersId
(
)
;
n
=
n
-
>
GetParent
(
)
)
{
if
(
n
-
>
GetApzc
(
)
)
{
APZCTM_LOG
(
"
Found
target
%
p
using
ancestor
lookup
\
n
"
n
-
>
GetApzc
(
)
)
;
return
n
-
>
GetApzc
(
)
;
}
if
(
n
-
>
GetFixedPosTarget
(
)
!
=
FrameMetrics
:
:
NULL_SCROLL_ID
)
{
ScrollableLayerGuid
guid
(
n
-
>
GetLayersId
(
)
0
n
-
>
GetFixedPosTarget
(
)
)
;
RefPtr
<
HitTestingTreeNode
>
fpNode
=
GetTargetNode
(
guid
&
GuidComparatorIgnoringPresShell
)
;
APZCTM_LOG
(
"
Found
target
node
%
p
using
fixed
-
pos
lookup
on
%
"
PRIu64
"
\
n
"
fpNode
.
get
(
)
n
-
>
GetFixedPosTarget
(
)
)
;
return
fpNode
?
fpNode
-
>
GetApzc
(
)
:
nullptr
;
}
}
return
nullptr
;
}
AsyncPanZoomController
*
APZCTreeManager
:
:
GetAPZCAtPoint
(
HitTestingTreeNode
*
aNode
const
ScreenPoint
&
aHitTestPoint
CompositorHitTestInfo
*
aOutHitResult
HitTestingTreeNode
*
*
aOutScrollbarNode
)
{
mTreeLock
.
AssertCurrentThreadOwns
(
)
;
HitTestingTreeNode
*
resultNode
;
HitTestingTreeNode
*
root
=
aNode
;
std
:
:
stack
<
LayerPoint
>
hitTestPoints
;
ParentLayerPoint
point
=
ViewAs
<
ParentLayerPixel
>
(
aHitTestPoint
PixelCastJustification
:
:
ScreenIsParentLayerForRoot
)
;
hitTestPoints
.
push
(
ViewAs
<
LayerPixel
>
(
point
PixelCastJustification
:
:
MovingDownToChildren
)
)
;
ForEachNode
<
ReverseIterator
>
(
root
[
&
hitTestPoints
this
]
(
HitTestingTreeNode
*
aNode
)
{
ParentLayerPoint
hitTestPointForParent
=
ViewAs
<
ParentLayerPixel
>
(
hitTestPoints
.
top
(
)
PixelCastJustification
:
:
MovingDownToChildren
)
;
if
(
aNode
-
>
IsOutsideClip
(
hitTestPointForParent
)
)
{
APZCTM_LOG
(
"
Point
%
f
%
f
outside
clip
for
node
%
p
\
n
"
hitTestPoints
.
top
(
)
.
x
hitTestPoints
.
top
(
)
.
y
aNode
)
;
return
TraversalFlag
:
:
Skip
;
}
Maybe
<
LayerPoint
>
hitTestPoint
=
aNode
-
>
Untransform
(
hitTestPointForParent
ComputeTransformForNode
(
aNode
)
)
;
APZCTM_LOG
(
"
Transformed
ParentLayer
point
%
s
to
layer
%
s
\
n
"
Stringify
(
hitTestPointForParent
)
.
c_str
(
)
hitTestPoint
?
Stringify
(
hitTestPoint
.
ref
(
)
)
.
c_str
(
)
:
"
nil
"
)
;
if
(
!
hitTestPoint
)
{
return
TraversalFlag
:
:
Skip
;
}
hitTestPoints
.
push
(
hitTestPoint
.
ref
(
)
)
;
return
TraversalFlag
:
:
Continue
;
}
[
&
resultNode
&
hitTestPoints
&
aOutHitResult
]
(
HitTestingTreeNode
*
aNode
)
{
CompositorHitTestInfo
hitResult
=
aNode
-
>
HitTest
(
hitTestPoints
.
top
(
)
)
;
hitTestPoints
.
pop
(
)
;
APZCTM_LOG
(
"
Testing
Layer
point
%
s
against
node
%
p
\
n
"
Stringify
(
hitTestPoints
.
top
(
)
)
.
c_str
(
)
aNode
)
;
if
(
hitResult
!
=
CompositorHitTestInfo
:
:
eInvisibleToHitTest
)
{
resultNode
=
aNode
;
*
aOutHitResult
=
hitResult
;
return
TraversalFlag
:
:
Abort
;
}
return
TraversalFlag
:
:
Continue
;
}
)
;
if
(
*
aOutHitResult
!
=
CompositorHitTestInfo
:
:
eInvisibleToHitTest
)
{
MOZ_ASSERT
(
resultNode
)
;
for
(
HitTestingTreeNode
*
n
=
resultNode
;
n
;
n
=
n
-
>
GetParent
(
)
)
{
if
(
n
-
>
IsScrollbarNode
(
)
)
{
*
aOutScrollbarNode
=
n
;
*
aOutHitResult
|
=
CompositorHitTestInfo
:
:
eScrollbar
;
if
(
n
-
>
IsScrollThumbNode
(
)
)
{
*
aOutHitResult
|
=
CompositorHitTestInfo
:
:
eScrollbarThumb
;
}
if
(
n
-
>
GetScrollbarDirection
(
)
=
=
ScrollDirection
:
:
eVertical
)
{
*
aOutHitResult
|
=
CompositorHitTestInfo
:
:
eScrollbarVertical
;
}
ScrollableLayerGuid
guid
(
n
-
>
GetLayersId
(
)
0
n
-
>
GetScrollTargetId
(
)
)
;
if
(
RefPtr
<
HitTestingTreeNode
>
scrollTarget
=
GetTargetNode
(
guid
&
GuidComparatorIgnoringPresShell
)
)
{
MOZ_ASSERT
(
scrollTarget
-
>
GetApzc
(
)
)
;
return
scrollTarget
-
>
GetApzc
(
)
;
}
}
}
AsyncPanZoomController
*
result
=
GetTargetApzcForNode
(
resultNode
)
;
if
(
!
result
)
{
result
=
FindRootApzcForLayersId
(
resultNode
-
>
GetLayersId
(
)
)
;
MOZ_ASSERT
(
result
)
;
APZCTM_LOG
(
"
Found
target
%
p
using
root
lookup
\
n
"
result
)
;
}
APZCTM_LOG
(
"
Successfully
matched
APZC
%
p
via
node
%
p
(
hit
result
0x
%
x
)
\
n
"
result
resultNode
(
int
)
*
aOutHitResult
)
;
return
result
;
}
return
nullptr
;
}
AsyncPanZoomController
*
APZCTreeManager
:
:
FindRootApzcForLayersId
(
uint64_t
aLayersId
)
const
{
mTreeLock
.
AssertCurrentThreadOwns
(
)
;
HitTestingTreeNode
*
resultNode
=
BreadthFirstSearch
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
aLayersId
]
(
HitTestingTreeNode
*
aNode
)
{
AsyncPanZoomController
*
apzc
=
aNode
-
>
GetApzc
(
)
;
return
apzc
&
&
apzc
-
>
GetLayersId
(
)
=
=
aLayersId
&
&
apzc
-
>
IsRootForLayersId
(
)
;
}
)
;
return
resultNode
?
resultNode
-
>
GetApzc
(
)
:
nullptr
;
}
AsyncPanZoomController
*
APZCTreeManager
:
:
FindRootContentApzcForLayersId
(
uint64_t
aLayersId
)
const
{
mTreeLock
.
AssertCurrentThreadOwns
(
)
;
HitTestingTreeNode
*
resultNode
=
BreadthFirstSearch
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
aLayersId
]
(
HitTestingTreeNode
*
aNode
)
{
AsyncPanZoomController
*
apzc
=
aNode
-
>
GetApzc
(
)
;
return
apzc
&
&
apzc
-
>
GetLayersId
(
)
=
=
aLayersId
&
&
apzc
-
>
IsRootContent
(
)
;
}
)
;
return
resultNode
?
resultNode
-
>
GetApzc
(
)
:
nullptr
;
}
AsyncPanZoomController
*
APZCTreeManager
:
:
FindRootContentOrRootApzc
(
)
const
{
mTreeLock
.
AssertCurrentThreadOwns
(
)
;
HitTestingTreeNode
*
resultNode
=
BreadthFirstSearch
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
]
(
HitTestingTreeNode
*
aNode
)
{
AsyncPanZoomController
*
apzc
=
aNode
-
>
GetApzc
(
)
;
return
apzc
&
&
apzc
-
>
IsRootContent
(
)
;
}
)
;
if
(
resultNode
)
{
return
resultNode
-
>
GetApzc
(
)
;
}
resultNode
=
BreadthFirstSearch
<
ReverseIterator
>
(
mRootNode
.
get
(
)
[
]
(
HitTestingTreeNode
*
aNode
)
{
AsyncPanZoomController
*
apzc
=
aNode
-
>
GetApzc
(
)
;
return
(
apzc
!
=
nullptr
)
;
}
)
;
return
resultNode
?
resultNode
-
>
GetApzc
(
)
:
nullptr
;
}
ScreenToParentLayerMatrix4x4
APZCTreeManager
:
:
GetScreenToApzcTransform
(
const
AsyncPanZoomController
*
aApzc
)
const
{
Matrix4x4
result
;
MutexAutoLock
lock
(
mTreeLock
)
;
Matrix4x4
ancestorUntransform
=
aApzc
-
>
GetAncestorTransform
(
)
.
Inverse
(
)
;
result
=
ancestorUntransform
;
for
(
AsyncPanZoomController
*
parent
=
aApzc
-
>
GetParent
(
)
;
parent
;
parent
=
parent
-
>
GetParent
(
)
)
{
ancestorUntransform
=
parent
-
>
GetAncestorTransform
(
)
.
Inverse
(
)
;
Matrix4x4
asyncUntransform
=
parent
-
>
GetCurrentAsyncTransformWithOverscroll
(
AsyncPanZoomController
:
:
eForHitTesting
)
.
Inverse
(
)
.
ToUnknownMatrix
(
)
;
Matrix4x4
untransformSinceLastApzc
=
ancestorUntransform
*
asyncUntransform
;
result
=
untransformSinceLastApzc
*
result
;
}
return
ViewAs
<
ScreenToParentLayerMatrix4x4
>
(
result
)
;
}
ParentLayerToScreenMatrix4x4
APZCTreeManager
:
:
GetApzcToGeckoTransform
(
const
AsyncPanZoomController
*
aApzc
)
const
{
Matrix4x4
result
;
MutexAutoLock
lock
(
mTreeLock
)
;
Matrix4x4
asyncUntransform
=
aApzc
-
>
GetCurrentAsyncTransformWithOverscroll
(
AsyncPanZoomController
:
:
eForHitTesting
)
.
Inverse
(
)
.
ToUnknownMatrix
(
)
;
result
=
asyncUntransform
*
aApzc
-
>
GetTransformToLastDispatchedPaint
(
)
*
aApzc
-
>
GetAncestorTransform
(
)
;
for
(
AsyncPanZoomController
*
parent
=
aApzc
-
>
GetParent
(
)
;
parent
;
parent
=
parent
-
>
GetParent
(
)
)
{
result
=
result
*
parent
-
>
GetTransformToLastDispatchedPaint
(
)
*
parent
-
>
GetAncestorTransform
(
)
;
}
return
ViewAs
<
ParentLayerToScreenMatrix4x4
>
(
result
)
;
}
ScreenPoint
APZCTreeManager
:
:
GetCurrentMousePosition
(
)
const
{
return
mCurrentMousePosition
;
}
already_AddRefed
<
AsyncPanZoomController
>
APZCTreeManager
:
:
GetMultitouchTarget
(
AsyncPanZoomController
*
aApzc1
AsyncPanZoomController
*
aApzc2
)
const
{
MutexAutoLock
lock
(
mTreeLock
)
;
RefPtr
<
AsyncPanZoomController
>
apzc
;
if
(
aApzc1
&
&
aApzc2
&
&
aApzc1
-
>
GetLayersId
(
)
=
=
aApzc2
-
>
GetLayersId
(
)
)
{
apzc
=
FindRootContentApzcForLayersId
(
aApzc1
-
>
GetLayersId
(
)
)
;
}
else
{
apzc
=
CommonAncestor
(
aApzc1
aApzc2
)
;
if
(
apzc
)
{
apzc
=
FindRootContentApzcForLayersId
(
apzc
-
>
GetLayersId
(
)
)
;
}
}
return
apzc
.
forget
(
)
;
}
already_AddRefed
<
AsyncPanZoomController
>
APZCTreeManager
:
:
CommonAncestor
(
AsyncPanZoomController
*
aApzc1
AsyncPanZoomController
*
aApzc2
)
const
{
mTreeLock
.
AssertCurrentThreadOwns
(
)
;
RefPtr
<
AsyncPanZoomController
>
ancestor
;
int
depth1
=
0
depth2
=
0
;
for
(
AsyncPanZoomController
*
parent
=
aApzc1
;
parent
;
parent
=
parent
-
>
GetParent
(
)
)
{
depth1
+
+
;
}
for
(
AsyncPanZoomController
*
parent
=
aApzc2
;
parent
;
parent
=
parent
-
>
GetParent
(
)
)
{
depth2
+
+
;
}
int
minDepth
=
depth1
<
depth2
?
depth1
:
depth2
;
while
(
depth1
>
minDepth
)
{
depth1
-
-
;
aApzc1
=
aApzc1
-
>
GetParent
(
)
;
}
while
(
depth2
>
minDepth
)
{
depth2
-
-
;
aApzc2
=
aApzc2
-
>
GetParent
(
)
;
}
while
(
true
)
{
if
(
aApzc1
=
=
aApzc2
)
{
ancestor
=
aApzc1
;
break
;
}
if
(
depth1
<
=
0
)
{
break
;
}
aApzc1
=
aApzc1
-
>
GetParent
(
)
;
aApzc2
=
aApzc2
-
>
GetParent
(
)
;
}
return
ancestor
.
forget
(
)
;
}
LayerToParentLayerMatrix4x4
APZCTreeManager
:
:
ComputeTransformForNode
(
const
HitTestingTreeNode
*
aNode
)
const
{
mTreeLock
.
AssertCurrentThreadOwns
(
)
;
if
(
AsyncPanZoomController
*
apzc
=
aNode
-
>
GetApzc
(
)
)
{
return
aNode
-
>
GetTransform
(
)
*
CompleteAsyncTransform
(
apzc
-
>
GetCurrentAsyncTransformWithOverscroll
(
AsyncPanZoomController
:
:
eForHitTesting
)
)
;
}
else
if
(
aNode
-
>
IsScrollThumbNode
(
)
)
{
ScrollableLayerGuid
guid
{
aNode
-
>
GetLayersId
(
)
0
aNode
-
>
GetScrollTargetId
(
)
}
;
if
(
RefPtr
<
HitTestingTreeNode
>
scrollTargetNode
=
GetTargetNode
(
guid
&
GuidComparatorIgnoringPresShell
)
)
{
AsyncPanZoomController
*
scrollTargetApzc
=
scrollTargetNode
-
>
GetApzc
(
)
;
MOZ_ASSERT
(
scrollTargetApzc
)
;
return
scrollTargetApzc
-
>
CallWithLastContentPaintMetrics
(
[
&
]
(
const
FrameMetrics
&
aMetrics
)
{
return
AsyncCompositionManager
:
:
ComputeTransformForScrollThumb
(
aNode
-
>
GetTransform
(
)
*
AsyncTransformMatrix
(
)
scrollTargetNode
-
>
GetTransform
(
)
.
ToUnknownMatrix
(
)
scrollTargetApzc
aMetrics
aNode
-
>
GetScrollThumbData
(
)
scrollTargetNode
-
>
IsAncestorOf
(
aNode
)
nullptr
)
;
}
)
;
}
}
return
aNode
-
>
GetTransform
(
)
*
AsyncTransformMatrix
(
)
;
}
already_AddRefed
<
wr
:
:
WebRenderAPI
>
APZCTreeManager
:
:
GetWebRenderAPI
(
)
const
{
RefPtr
<
wr
:
:
WebRenderAPI
>
api
;
CompositorBridgeParent
:
:
CallWithIndirectShadowTree
(
mRootLayersId
[
&
]
(
LayerTreeState
&
aState
)
-
>
void
{
if
(
aState
.
mWrBridge
)
{
api
=
aState
.
mWrBridge
-
>
GetWebRenderAPI
(
)
;
}
}
)
;
return
api
.
forget
(
)
;
}
already_AddRefed
<
GeckoContentController
>
APZCTreeManager
:
:
GetContentController
(
uint64_t
aLayersId
)
const
{
RefPtr
<
GeckoContentController
>
controller
;
CompositorBridgeParent
:
:
CallWithIndirectShadowTree
(
aLayersId
[
&
]
(
LayerTreeState
&
aState
)
-
>
void
{
controller
=
aState
.
mController
;
}
)
;
return
controller
.
forget
(
)
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
void
APZCTreeManager
:
:
InitializeDynamicToolbarAnimator
(
const
int64_t
&
aRootLayerTreeId
)
{
MOZ_ASSERT
(
mToolbarAnimator
)
;
mToolbarAnimator
-
>
Initialize
(
aRootLayerTreeId
)
;
}
AndroidDynamicToolbarAnimator
*
APZCTreeManager
:
:
GetAndroidDynamicToolbarAnimator
(
)
{
return
mToolbarAnimator
;
}
#
endif
}
}
