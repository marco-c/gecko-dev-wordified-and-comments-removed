#
ifndef
mozilla_layers_APZUpdater_h
#
define
mozilla_layers_APZUpdater_h
#
include
<
deque
>
#
include
<
unordered_map
>
#
include
"
base
/
platform_thread
.
h
"
#
include
"
LayersTypes
.
h
"
#
include
"
APZTypes
.
h
"
#
include
"
mozilla
/
layers
/
APZTestData
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderScrollData
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderTypes
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
Units
.
h
"
namespace
mozilla
{
namespace
layers
{
class
APZCTreeManager
;
class
FocusTarget
;
class
Layer
;
class
WebRenderScrollData
;
class
APZUpdater
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
APZUpdater
)
public
:
APZUpdater
(
const
RefPtr
<
APZCTreeManager
>
&
aApz
bool
aIsUsingWebRender
)
;
bool
HasTreeManager
(
const
RefPtr
<
APZCTreeManager
>
&
aApz
)
;
void
SetWebRenderWindowId
(
const
wr
:
:
WindowId
&
aWindowId
)
;
static
void
SetUpdaterThread
(
const
wr
:
:
WrWindowId
&
aWindowId
)
;
static
void
PrepareForSceneSwap
(
const
wr
:
:
WrWindowId
&
aWindowId
)
;
static
void
CompleteSceneSwap
(
const
wr
:
:
WrWindowId
&
aWindowId
const
wr
:
:
WrPipelineInfo
&
aInfo
)
;
static
void
ProcessPendingTasks
(
const
wr
:
:
WrWindowId
&
aWindowId
)
;
void
ClearTree
(
LayersId
aRootLayersId
)
;
void
UpdateFocusState
(
LayersId
aRootLayerTreeId
WRRootId
aOriginatingWrRootId
const
FocusTarget
&
aFocusTarget
)
;
void
UpdateHitTestingTree
(
Layer
*
aRoot
bool
aIsFirstPaint
LayersId
aOriginatingLayersId
uint32_t
aPaintSequenceNumber
)
;
void
UpdateScrollDataAndTreeState
(
WRRootId
aRootLayerTreeId
WRRootId
aOriginatingWrRootId
const
wr
:
:
Epoch
&
aEpoch
WebRenderScrollData
&
&
aScrollData
)
;
void
UpdateScrollOffsets
(
WRRootId
aRootLayerTreeId
WRRootId
aOriginatingWrRootId
ScrollUpdatesMap
&
&
aUpdates
uint32_t
aPaintSequenceNumber
)
;
void
NotifyLayerTreeAdopted
(
WRRootId
aWrRootId
const
RefPtr
<
APZUpdater
>
&
aOldUpdater
)
;
void
NotifyLayerTreeRemoved
(
WRRootId
aWrRootId
)
;
bool
GetAPZTestData
(
WRRootId
aWrRootId
APZTestData
*
aOutData
)
;
void
SetTestAsyncScrollOffset
(
WRRootId
aWrRootId
const
ScrollableLayerGuid
:
:
ViewID
&
aScrollId
const
CSSPoint
&
aOffset
)
;
void
SetTestAsyncZoom
(
WRRootId
aWrRootId
const
ScrollableLayerGuid
:
:
ViewID
&
aScrollId
const
LayerToParentLayerScale
&
aZoom
)
;
const
WebRenderScrollData
*
GetScrollData
(
WRRootId
aWrRootId
)
const
;
void
AssertOnUpdaterThread
(
)
const
;
void
RunOnUpdaterThread
(
UpdaterQueueSelector
aSelector
already_AddRefed
<
Runnable
>
aTask
)
;
bool
IsUpdaterThread
(
)
const
;
void
RunOnControllerThread
(
UpdaterQueueSelector
aSelector
already_AddRefed
<
Runnable
>
aTask
)
;
protected
:
virtual
~
APZUpdater
(
)
;
bool
UsingWebRenderUpdaterThread
(
)
const
;
static
already_AddRefed
<
APZUpdater
>
GetUpdater
(
const
wr
:
:
WrWindowId
&
aWindowId
)
;
void
ProcessQueue
(
)
;
private
:
RefPtr
<
APZCTreeManager
>
mApz
;
bool
mDestroyed
;
bool
mIsUsingWebRender
;
std
:
:
unordered_map
<
WRRootId
WebRenderScrollData
WRRootId
:
:
HashFn
>
mScrollData
;
struct
EpochState
{
wr
:
:
Epoch
mRequired
;
Maybe
<
wr
:
:
Epoch
>
mBuilt
;
bool
mIsRoot
;
EpochState
(
)
;
bool
IsBlocked
(
)
const
;
}
;
std
:
:
unordered_map
<
WRRootId
EpochState
WRRootId
:
:
HashFn
>
mEpochData
;
static
StaticMutex
sWindowIdLock
;
static
StaticAutoPtr
<
std
:
:
unordered_map
<
uint64_t
APZUpdater
*
>
>
sWindowIdMap
;
Maybe
<
wr
:
:
WrWindowId
>
mWindowId
;
mutable
Mutex
mThreadIdLock
;
Maybe
<
PlatformThreadId
>
mUpdaterThreadId
;
struct
QueuedTask
{
UpdaterQueueSelector
mSelector
;
RefPtr
<
Runnable
>
mRunnable
;
}
;
Mutex
mQueueLock
;
std
:
:
deque
<
QueuedTask
>
mUpdaterQueue
;
}
;
}
}
#
endif
