#
include
"
APZEventState
.
h
"
#
include
<
utility
>
#
include
"
APZCCallbackHelper
.
h
"
#
include
"
ActiveElementManager
.
h
"
#
include
"
LayersLogging
.
h
"
#
include
"
TouchManager
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
PositionedEventTargeting
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_ui
.
h
"
#
include
"
mozilla
/
ToString
.
h
"
#
include
"
mozilla
/
TouchEvents
.
h
"
#
include
"
mozilla
/
ViewportUtils
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
MouseEventBinding
.
h
"
#
include
"
mozilla
/
layers
/
APZCCallbackHelper
.
h
"
#
include
"
mozilla
/
layers
/
IAPZCTreeManager
.
h
"
#
include
"
mozilla
/
widget
/
nsAutoRollup
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsIDOMWindowUtils
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsIScrollbarMediator
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsQueryFrame
.
h
"
static
mozilla
:
:
LazyLogModule
sApzEvtLog
(
"
apz
.
eventstate
"
)
;
#
define
APZES_LOG
(
.
.
.
)
MOZ_LOG
(
sApzEvtLog
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
namespace
{
int32_t
WidgetModifiersToDOMModifiers
(
mozilla
:
:
Modifiers
aModifiers
)
{
int32_t
result
=
0
;
if
(
aModifiers
&
mozilla
:
:
MODIFIER_SHIFT
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_SHIFT
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_CONTROL
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_CONTROL
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_ALT
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_ALT
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_META
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_META
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_ALTGRAPH
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_ALTGRAPH
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_CAPSLOCK
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_CAPSLOCK
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_FN
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_FN
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_FNLOCK
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_FNLOCK
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_NUMLOCK
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_NUMLOCK
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_SCROLLLOCK
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_SCROLLLOCK
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_SYMBOL
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_SYMBOL
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_SYMBOLLOCK
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_SYMBOLLOCK
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_OS
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_OS
;
}
return
result
;
}
}
namespace
mozilla
{
namespace
layers
{
APZEventState
:
:
APZEventState
(
nsIWidget
*
aWidget
ContentReceivedInputBlockCallback
&
&
aCallback
)
:
mWidget
(
nullptr
)
mActiveElementManager
(
new
ActiveElementManager
(
)
)
mContentReceivedInputBlockCallback
(
std
:
:
move
(
aCallback
)
)
mPendingTouchPreventedResponse
(
false
)
mPendingTouchPreventedBlockId
(
0
)
mEndTouchIsClick
(
false
)
mFirstTouchCancelled
(
false
)
mTouchEndCancelled
(
false
)
mLastTouchIdentifier
(
0
)
{
nsresult
rv
;
mWidget
=
do_GetWeakReference
(
aWidget
&
rv
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
APZEventState
constructed
with
a
widget
that
"
"
does
not
support
weak
references
.
APZ
will
NOT
work
!
"
)
;
}
APZEventState
:
:
~
APZEventState
(
)
=
default
;
class
DelayedFireSingleTapEvent
final
:
public
nsITimerCallback
public
nsINamed
{
public
:
NS_DECL_ISUPPORTS
DelayedFireSingleTapEvent
(
nsWeakPtr
aWidget
LayoutDevicePoint
&
aPoint
Modifiers
aModifiers
int32_t
aClickCount
nsITimer
*
aTimer
RefPtr
<
nsIContent
>
&
aTouchRollup
)
:
mWidget
(
aWidget
)
mPoint
(
aPoint
)
mModifiers
(
aModifiers
)
mClickCount
(
aClickCount
)
mTimer
(
aTimer
)
mTouchRollup
(
aTouchRollup
)
{
}
NS_IMETHOD
Notify
(
nsITimer
*
)
override
{
if
(
nsCOMPtr
<
nsIWidget
>
widget
=
do_QueryReferent
(
mWidget
)
)
{
widget
:
:
nsAutoRollup
rollup
(
mTouchRollup
.
get
(
)
)
;
APZCCallbackHelper
:
:
FireSingleTapEvent
(
mPoint
mModifiers
mClickCount
widget
)
;
}
mTimer
=
nullptr
;
return
NS_OK
;
}
NS_IMETHOD
GetName
(
nsACString
&
aName
)
override
{
aName
.
AssignLiteral
(
"
DelayedFireSingleTapEvent
"
)
;
return
NS_OK
;
}
void
ClearTimer
(
)
{
mTimer
=
nullptr
;
}
private
:
~
DelayedFireSingleTapEvent
(
)
=
default
;
nsWeakPtr
mWidget
;
LayoutDevicePoint
mPoint
;
Modifiers
mModifiers
;
int32_t
mClickCount
;
nsCOMPtr
<
nsITimer
>
mTimer
;
RefPtr
<
nsIContent
>
mTouchRollup
;
}
;
NS_IMPL_ISUPPORTS
(
DelayedFireSingleTapEvent
nsITimerCallback
nsINamed
)
void
APZEventState
:
:
ProcessSingleTap
(
const
CSSPoint
&
aPoint
const
CSSToLayoutDeviceScale
&
aScale
Modifiers
aModifiers
int32_t
aClickCount
)
{
APZES_LOG
(
"
Handling
single
tap
at
%
s
with
%
d
\
n
"
ToString
(
aPoint
)
.
c_str
(
)
mTouchEndCancelled
)
;
RefPtr
<
nsIContent
>
touchRollup
=
GetTouchRollup
(
)
;
mTouchRollup
=
nullptr
;
nsCOMPtr
<
nsIWidget
>
widget
=
GetWidget
(
)
;
if
(
!
widget
)
{
return
;
}
if
(
mTouchEndCancelled
)
{
return
;
}
LayoutDevicePoint
ldPoint
=
aPoint
*
aScale
;
APZES_LOG
(
"
Scheduling
timer
for
click
event
\
n
"
)
;
nsCOMPtr
<
nsITimer
>
timer
=
NS_NewTimer
(
)
;
RefPtr
<
DelayedFireSingleTapEvent
>
callback
=
new
DelayedFireSingleTapEvent
(
mWidget
ldPoint
aModifiers
aClickCount
timer
touchRollup
)
;
nsresult
rv
=
timer
-
>
InitWithCallback
(
callback
StaticPrefs
:
:
ui_touch_activation_duration_ms
(
)
nsITimer
:
:
TYPE_ONE_SHOT
)
;
if
(
NS_FAILED
(
rv
)
)
{
callback
-
>
ClearTimer
(
)
;
}
}
bool
APZEventState
:
:
FireContextmenuEvents
(
PresShell
*
aPresShell
const
CSSPoint
&
aPoint
const
CSSToLayoutDeviceScale
&
aScale
Modifiers
aModifiers
const
nsCOMPtr
<
nsIWidget
>
&
aWidget
)
{
EventRetargetSuppression
suppression
;
APZCCallbackHelper
:
:
DispatchSynthesizedMouseEvent
(
eMouseMove
0
aPoint
*
aScale
aModifiers
0
aWidget
)
;
CSSPoint
point
=
CSSPoint
:
:
FromAppUnits
(
ViewportUtils
:
:
VisualToLayout
(
CSSPoint
:
:
ToAppUnits
(
aPoint
)
aPresShell
)
)
;
bool
eventHandled
=
APZCCallbackHelper
:
:
DispatchMouseEvent
(
aPresShell
u
"
contextmenu
"
_ns
point
2
1
WidgetModifiersToDOMModifiers
(
aModifiers
)
dom
:
:
MouseEvent_Binding
:
:
MOZ_SOURCE_TOUCH
0
)
;
APZES_LOG
(
"
Contextmenu
event
handled
:
%
d
\
n
"
eventHandled
)
;
if
(
eventHandled
)
{
mActiveElementManager
-
>
ClearActivation
(
)
;
#
ifndef
XP_WIN
}
else
{
nsEventStatus
status
=
APZCCallbackHelper
:
:
DispatchSynthesizedMouseEvent
(
eMouseLongTap
0
aPoint
*
aScale
aModifiers
1
aWidget
)
;
eventHandled
=
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
;
APZES_LOG
(
"
eMouseLongTap
event
handled
:
%
d
\
n
"
eventHandled
)
;
#
endif
}
return
eventHandled
;
}
void
APZEventState
:
:
ProcessLongTap
(
PresShell
*
aPresShell
const
CSSPoint
&
aPoint
const
CSSToLayoutDeviceScale
&
aScale
Modifiers
aModifiers
uint64_t
aInputBlockId
)
{
APZES_LOG
(
"
Handling
long
tap
at
%
s
\
n
"
ToString
(
aPoint
)
.
c_str
(
)
)
;
nsCOMPtr
<
nsIWidget
>
widget
=
GetWidget
(
)
;
if
(
!
widget
)
{
return
;
}
SendPendingTouchPreventedResponse
(
false
)
;
#
ifdef
XP_WIN
nsEventStatus
status
=
APZCCallbackHelper
:
:
DispatchSynthesizedMouseEvent
(
eMouseLongTap
0
aPoint
*
aScale
aModifiers
1
widget
)
;
bool
eventHandled
=
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
;
#
else
bool
eventHandled
=
FireContextmenuEvents
(
aPresShell
aPoint
aScale
aModifiers
widget
)
;
#
endif
mContentReceivedInputBlockCallback
(
aInputBlockId
eventHandled
)
;
if
(
eventHandled
)
{
WidgetTouchEvent
cancelTouchEvent
(
true
eTouchCancel
widget
.
get
(
)
)
;
cancelTouchEvent
.
mModifiers
=
aModifiers
;
auto
ldPoint
=
LayoutDeviceIntPoint
:
:
Round
(
aPoint
*
aScale
)
;
cancelTouchEvent
.
mTouches
.
AppendElement
(
new
mozilla
:
:
dom
:
:
Touch
(
mLastTouchIdentifier
ldPoint
LayoutDeviceIntPoint
(
)
0
0
)
)
;
APZCCallbackHelper
:
:
DispatchWidgetEvent
(
cancelTouchEvent
)
;
}
}
void
APZEventState
:
:
ProcessLongTapUp
(
PresShell
*
aPresShell
const
CSSPoint
&
aPoint
const
CSSToLayoutDeviceScale
&
aScale
Modifiers
aModifiers
)
{
#
ifdef
XP_WIN
nsCOMPtr
<
nsIWidget
>
widget
=
GetWidget
(
)
;
if
(
widget
)
{
FireContextmenuEvents
(
aPresShell
aPoint
aScale
aModifiers
widget
)
;
}
#
endif
}
void
APZEventState
:
:
ProcessTouchEvent
(
const
WidgetTouchEvent
&
aEvent
const
ScrollableLayerGuid
&
aGuid
uint64_t
aInputBlockId
nsEventStatus
aApzResponse
nsEventStatus
aContentResponse
nsTArray
<
TouchBehaviorFlags
>
&
&
aAllowedTouchBehaviors
)
{
if
(
aEvent
.
mMessage
=
=
eTouchStart
&
&
aEvent
.
mTouches
.
Length
(
)
>
0
)
{
mActiveElementManager
-
>
SetTargetElement
(
aEvent
.
mTouches
[
0
]
-
>
GetTarget
(
)
)
;
mLastTouchIdentifier
=
aEvent
.
mTouches
[
0
]
-
>
Identifier
(
)
;
}
if
(
aEvent
.
mMessage
=
=
eTouchStart
)
{
mTouchBlockAllowedBehaviors
=
std
:
:
move
(
aAllowedTouchBehaviors
)
;
}
bool
isTouchPrevented
=
aContentResponse
=
=
nsEventStatus_eConsumeNoDefault
;
bool
sentContentResponse
=
false
;
APZES_LOG
(
"
Handling
event
type
%
d
\
n
"
aEvent
.
mMessage
)
;
switch
(
aEvent
.
mMessage
)
{
case
eTouchStart
:
{
mTouchEndCancelled
=
false
;
mTouchRollup
=
do_GetWeakReference
(
widget
:
:
nsAutoRollup
:
:
GetLastRollup
(
)
)
;
sentContentResponse
=
SendPendingTouchPreventedResponse
(
false
)
;
MOZ_ASSERT
(
aEvent
.
mFlags
.
mHandledByAPZ
)
;
if
(
mTouchCounter
.
GetActiveTouchCount
(
)
=
=
0
)
{
mFirstTouchCancelled
=
isTouchPrevented
;
}
else
{
if
(
mFirstTouchCancelled
&
&
!
isTouchPrevented
)
{
APZES_LOG
(
"
Propagating
prevent
-
default
from
first
-
touch
for
block
%
"
PRIu64
"
\
n
"
aInputBlockId
)
;
}
isTouchPrevented
|
=
mFirstTouchCancelled
;
}
if
(
isTouchPrevented
)
{
mContentReceivedInputBlockCallback
(
aInputBlockId
isTouchPrevented
)
;
sentContentResponse
=
true
;
}
else
{
APZES_LOG
(
"
Event
not
prevented
;
pending
response
for
%
"
PRIu64
"
%
s
\
n
"
aInputBlockId
ToString
(
aGuid
)
.
c_str
(
)
)
;
mPendingTouchPreventedResponse
=
true
;
mPendingTouchPreventedGuid
=
aGuid
;
mPendingTouchPreventedBlockId
=
aInputBlockId
;
}
break
;
}
case
eTouchEnd
:
if
(
isTouchPrevented
)
{
mTouchEndCancelled
=
true
;
mEndTouchIsClick
=
false
;
}
[
[
fallthrough
]
]
;
case
eTouchCancel
:
mActiveElementManager
-
>
HandleTouchEndEvent
(
mEndTouchIsClick
)
;
[
[
fallthrough
]
]
;
case
eTouchMove
:
{
if
(
mPendingTouchPreventedResponse
)
{
MOZ_ASSERT
(
aGuid
=
=
mPendingTouchPreventedGuid
)
;
}
sentContentResponse
=
SendPendingTouchPreventedResponse
(
isTouchPrevented
)
;
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
touch
event
type
"
)
;
break
;
}
mTouchCounter
.
Update
(
aEvent
)
;
if
(
mTouchCounter
.
GetActiveTouchCount
(
)
=
=
0
)
{
mFirstTouchCancelled
=
false
;
}
if
(
sentContentResponse
&
&
!
isTouchPrevented
&
&
aApzResponse
=
=
nsEventStatus_eConsumeDoDefault
&
&
StaticPrefs
:
:
dom_w3c_pointer_events_enabled
(
)
&
&
MainThreadAgreesEventsAreConsumableByAPZ
(
)
)
{
WidgetTouchEvent
cancelEvent
(
aEvent
)
;
cancelEvent
.
mMessage
=
eTouchPointerCancel
;
cancelEvent
.
mFlags
.
mCancelable
=
false
;
for
(
uint32_t
i
=
0
;
i
<
cancelEvent
.
mTouches
.
Length
(
)
;
+
+
i
)
{
if
(
mozilla
:
:
dom
:
:
Touch
*
touch
=
cancelEvent
.
mTouches
[
i
]
)
{
touch
-
>
convertToPointer
=
true
;
}
}
nsEventStatus
status
;
cancelEvent
.
mWidget
-
>
DispatchEvent
(
&
cancelEvent
status
)
;
}
}
bool
APZEventState
:
:
MainThreadAgreesEventsAreConsumableByAPZ
(
)
const
{
switch
(
mTouchBlockAllowedBehaviors
.
Length
(
)
)
{
case
0
:
return
true
;
case
1
:
{
TouchBehaviorFlags
flags
=
mTouchBlockAllowedBehaviors
[
0
]
;
return
(
flags
&
AllowedTouchBehavior
:
:
HORIZONTAL_PAN
)
|
|
(
flags
&
AllowedTouchBehavior
:
:
VERTICAL_PAN
)
;
}
case
2
:
{
for
(
const
auto
&
allowed
:
mTouchBlockAllowedBehaviors
)
{
if
(
!
(
allowed
&
AllowedTouchBehavior
:
:
PINCH_ZOOM
)
)
{
return
false
;
}
}
return
true
;
}
default
:
return
false
;
}
}
void
APZEventState
:
:
ProcessWheelEvent
(
const
WidgetWheelEvent
&
aEvent
uint64_t
aInputBlockId
)
{
bool
defaultPrevented
=
aEvent
.
DefaultPrevented
(
)
|
|
aEvent
.
TriggersSwipe
(
)
;
mContentReceivedInputBlockCallback
(
aInputBlockId
defaultPrevented
)
;
}
void
APZEventState
:
:
ProcessMouseEvent
(
const
WidgetMouseEvent
&
aEvent
uint64_t
aInputBlockId
)
{
bool
defaultPrevented
=
false
;
mContentReceivedInputBlockCallback
(
aInputBlockId
defaultPrevented
)
;
}
void
APZEventState
:
:
ProcessAPZStateChange
(
ViewID
aViewId
APZStateChange
aChange
int
aArg
)
{
switch
(
aChange
)
{
case
APZStateChange
:
:
eTransformBegin
:
{
nsIScrollableFrame
*
sf
=
nsLayoutUtils
:
:
FindScrollableFrameFor
(
aViewId
)
;
if
(
sf
)
{
sf
-
>
SetTransformingByAPZ
(
true
)
;
}
nsIScrollbarMediator
*
scrollbarMediator
=
do_QueryFrame
(
sf
)
;
if
(
scrollbarMediator
)
{
scrollbarMediator
-
>
ScrollbarActivityStarted
(
)
;
}
nsIContent
*
content
=
nsLayoutUtils
:
:
FindContentFor
(
aViewId
)
;
dom
:
:
Document
*
doc
=
content
?
content
-
>
GetComposedDoc
(
)
:
nullptr
;
nsCOMPtr
<
nsIDocShell
>
docshell
(
doc
?
doc
-
>
GetDocShell
(
)
:
nullptr
)
;
if
(
docshell
&
&
sf
)
{
nsDocShell
*
nsdocshell
=
static_cast
<
nsDocShell
*
>
(
docshell
.
get
(
)
)
;
nsdocshell
-
>
NotifyAsyncPanZoomStarted
(
)
;
}
break
;
}
case
APZStateChange
:
:
eTransformEnd
:
{
nsIScrollableFrame
*
sf
=
nsLayoutUtils
:
:
FindScrollableFrameFor
(
aViewId
)
;
if
(
sf
)
{
sf
-
>
SetTransformingByAPZ
(
false
)
;
}
nsIScrollbarMediator
*
scrollbarMediator
=
do_QueryFrame
(
sf
)
;
if
(
scrollbarMediator
)
{
scrollbarMediator
-
>
ScrollbarActivityStopped
(
)
;
}
nsIContent
*
content
=
nsLayoutUtils
:
:
FindContentFor
(
aViewId
)
;
dom
:
:
Document
*
doc
=
content
?
content
-
>
GetComposedDoc
(
)
:
nullptr
;
nsCOMPtr
<
nsIDocShell
>
docshell
(
doc
?
doc
-
>
GetDocShell
(
)
:
nullptr
)
;
if
(
docshell
&
&
sf
)
{
nsDocShell
*
nsdocshell
=
static_cast
<
nsDocShell
*
>
(
docshell
.
get
(
)
)
;
nsdocshell
-
>
NotifyAsyncPanZoomStopped
(
)
;
}
break
;
}
case
APZStateChange
:
:
eStartTouch
:
{
mActiveElementManager
-
>
HandleTouchStart
(
aArg
)
;
break
;
}
case
APZStateChange
:
:
eStartPanning
:
{
mActiveElementManager
-
>
ClearActivation
(
)
;
break
;
}
case
APZStateChange
:
:
eEndTouch
:
{
mEndTouchIsClick
=
aArg
;
mActiveElementManager
-
>
HandleTouchEnd
(
)
;
break
;
}
}
}
bool
APZEventState
:
:
SendPendingTouchPreventedResponse
(
bool
aPreventDefault
)
{
if
(
mPendingTouchPreventedResponse
)
{
APZES_LOG
(
"
Sending
response
%
d
for
pending
guid
:
%
s
\
n
"
aPreventDefault
ToString
(
mPendingTouchPreventedGuid
)
.
c_str
(
)
)
;
mContentReceivedInputBlockCallback
(
mPendingTouchPreventedBlockId
aPreventDefault
)
;
mPendingTouchPreventedResponse
=
false
;
return
true
;
}
return
false
;
}
already_AddRefed
<
nsIWidget
>
APZEventState
:
:
GetWidget
(
)
const
{
nsCOMPtr
<
nsIWidget
>
result
=
do_QueryReferent
(
mWidget
)
;
return
result
.
forget
(
)
;
}
already_AddRefed
<
nsIContent
>
APZEventState
:
:
GetTouchRollup
(
)
const
{
nsCOMPtr
<
nsIContent
>
result
=
do_QueryReferent
(
mTouchRollup
)
;
return
result
.
forget
(
)
;
}
}
}
