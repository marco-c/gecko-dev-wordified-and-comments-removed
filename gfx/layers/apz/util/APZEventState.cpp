#
include
"
APZEventState
.
h
"
#
include
<
utility
>
#
include
"
APZCCallbackHelper
.
h
"
#
include
"
ActiveElementManager
.
h
"
#
include
"
TouchManager
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
PositionedEventTargeting
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ScrollContainerFrame
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_ui
.
h
"
#
include
"
mozilla
/
ToString
.
h
"
#
include
"
mozilla
/
TouchEvents
.
h
"
#
include
"
mozilla
/
ViewportUtils
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
MouseEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
PointerEventHandler
.
h
"
#
include
"
mozilla
/
layers
/
APZCCallbackHelper
.
h
"
#
include
"
mozilla
/
layers
/
APZUtils
.
h
"
#
include
"
mozilla
/
layers
/
IAPZCTreeManager
.
h
"
#
include
"
mozilla
/
widget
/
nsAutoRollup
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsIDOMWindowUtils
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsIScrollbarMediator
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsQueryFrame
.
h
"
static
mozilla
:
:
LazyLogModule
sApzEvtLog
(
"
apz
.
eventstate
"
)
;
#
define
APZES_LOG
(
.
.
.
)
MOZ_LOG
(
sApzEvtLog
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
namespace
{
int32_t
WidgetModifiersToDOMModifiers
(
mozilla
:
:
Modifiers
aModifiers
)
{
int32_t
result
=
0
;
if
(
aModifiers
&
mozilla
:
:
MODIFIER_SHIFT
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_SHIFT
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_CONTROL
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_CONTROL
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_ALT
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_ALT
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_META
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_META
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_ALTGRAPH
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_ALTGRAPH
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_CAPSLOCK
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_CAPSLOCK
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_FN
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_FN
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_FNLOCK
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_FNLOCK
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_NUMLOCK
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_NUMLOCK
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_SCROLLLOCK
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_SCROLLLOCK
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_SYMBOL
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_SYMBOL
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_SYMBOLLOCK
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_SYMBOLLOCK
;
}
return
result
;
}
}
namespace
mozilla
{
namespace
layers
{
APZEventState
:
:
APZEventState
(
nsIWidget
*
aWidget
ContentReceivedInputBlockCallback
&
&
aCallback
)
:
mWidget
(
nullptr
)
mActiveElementManager
(
new
ActiveElementManager
(
)
)
mContentReceivedInputBlockCallback
(
std
:
:
move
(
aCallback
)
)
mPendingTouchPreventedBlockId
(
0
)
mEndTouchState
(
apz
:
:
SingleTapState
:
:
NotClick
)
mLastTouchIdentifier
(
0
)
{
nsresult
rv
;
mWidget
=
do_GetWeakReference
(
aWidget
&
rv
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
APZEventState
constructed
with
a
widget
that
"
"
does
not
support
weak
references
.
APZ
will
NOT
work
!
"
)
;
}
APZEventState
:
:
~
APZEventState
(
)
=
default
;
void
APZEventState
:
:
ProcessSingleTap
(
const
CSSPoint
&
aPoint
const
CSSToLayoutDeviceScale
&
aScale
Modifiers
aModifiers
int32_t
aClickCount
uint64_t
aInputBlockId
)
{
APZES_LOG
(
"
Handling
single
tap
at
%
s
with
%
d
\
n
"
ToString
(
aPoint
)
.
c_str
(
)
mTouchEndCancelled
)
;
RefPtr
<
nsIContent
>
touchRollup
=
GetTouchRollup
(
)
;
mTouchRollup
=
nullptr
;
nsCOMPtr
<
nsIWidget
>
widget
=
GetWidget
(
)
;
if
(
!
widget
)
{
return
;
}
if
(
mTouchEndCancelled
)
{
return
;
}
nsCOMPtr
<
nsIWidget
>
localWidget
=
do_QueryReferent
(
mWidget
)
;
if
(
localWidget
)
{
widget
:
:
nsAutoRollup
rollup
(
touchRollup
)
;
APZCCallbackHelper
:
:
FireSingleTapEvent
(
aPoint
*
aScale
aModifiers
aClickCount
mPrecedingPointerDownState
localWidget
)
;
}
mActiveElementManager
-
>
ProcessSingleTap
(
)
;
}
PreventDefaultResult
APZEventState
:
:
FireContextmenuEvents
(
PresShell
*
aPresShell
const
CSSPoint
&
aPoint
const
CSSToLayoutDeviceScale
&
aScale
Modifiers
aModifiers
const
nsCOMPtr
<
nsIWidget
>
&
aWidget
)
{
EventRetargetSuppression
suppression
;
APZCCallbackHelper
:
:
DispatchSynthesizedMouseEvent
(
eMouseMove
aPoint
*
aScale
aModifiers
0
mPrecedingPointerDownState
aWidget
)
;
CSSPoint
point
=
CSSPoint
:
:
FromAppUnits
(
ViewportUtils
:
:
VisualToLayout
(
CSSPoint
:
:
ToAppUnits
(
aPoint
)
aPresShell
)
)
;
PreventDefaultResult
preventDefaultResult
=
APZCCallbackHelper
:
:
DispatchMouseEvent
(
aPresShell
u
"
contextmenu
"
_ns
point
MouseButton
:
:
ePrimary
1
WidgetModifiersToDOMModifiers
(
aModifiers
)
dom
:
:
MouseEvent_Binding
:
:
MOZ_SOURCE_TOUCH
0
)
;
APZES_LOG
(
"
Contextmenu
event
%
s
\
n
"
ToString
(
preventDefaultResult
)
.
c_str
(
)
)
;
if
(
preventDefaultResult
!
=
PreventDefaultResult
:
:
No
)
{
mActiveElementManager
-
>
ClearActivation
(
)
;
#
ifndef
XP_WIN
}
else
{
nsEventStatus
status
=
APZCCallbackHelper
:
:
DispatchSynthesizedMouseEvent
(
eMouseLongTap
aPoint
*
aScale
aModifiers
1
mPrecedingPointerDownState
aWidget
)
;
APZES_LOG
(
"
eMouseLongTap
event
%
s
\
n
"
ToString
(
status
)
.
c_str
(
)
)
;
#
endif
}
return
preventDefaultResult
;
}
void
APZEventState
:
:
ProcessLongTap
(
PresShell
*
aPresShell
const
CSSPoint
&
aPoint
const
CSSToLayoutDeviceScale
&
aScale
Modifiers
aModifiers
uint64_t
aInputBlockId
)
{
APZES_LOG
(
"
Handling
long
tap
at
%
s
block
id
%
"
PRIu64
"
\
n
"
ToString
(
aPoint
)
.
c_str
(
)
aInputBlockId
)
;
nsCOMPtr
<
nsIWidget
>
widget
=
GetWidget
(
)
;
if
(
!
widget
)
{
return
;
}
if
(
mPendingTouchPreventedResponse
)
{
APZES_LOG
(
"
Sending
response
%
d
for
pending
guid
:
%
s
block
id
:
%
"
PRIu64
"
due
to
long
tap
\
n
"
false
ToString
(
mPendingTouchPreventedGuid
)
.
c_str
(
)
mPendingTouchPreventedBlockId
)
;
mContentReceivedInputBlockCallback
(
mPendingTouchPreventedBlockId
false
)
;
}
#
ifdef
XP_WIN
APZCCallbackHelper
:
:
DispatchSynthesizedMouseEvent
(
eMouseLongTap
aPoint
*
aScale
aModifiers
1
mPrecedingPointerDownState
widget
)
;
#
else
PreventDefaultResult
preventDefaultResult
=
FireContextmenuEvents
(
aPresShell
aPoint
aScale
aModifiers
widget
)
;
#
endif
const
bool
contextmenuOpen
=
#
ifdef
XP_WIN
false
;
#
elif
defined
(
MOZ_WIDGET_ANDROID
)
preventDefaultResult
=
=
PreventDefaultResult
:
:
ByChrome
;
#
else
preventDefaultResult
=
=
PreventDefaultResult
:
:
No
;
#
endif
mContentReceivedInputBlockCallback
(
aInputBlockId
contextmenuOpen
)
;
if
(
contextmenuOpen
)
{
WidgetTouchEvent
cancelTouchEvent
(
true
eTouchCancel
widget
.
get
(
)
)
;
cancelTouchEvent
.
mModifiers
=
aModifiers
;
auto
ldPoint
=
LayoutDeviceIntPoint
:
:
Round
(
aPoint
*
aScale
)
;
cancelTouchEvent
.
mTouches
.
AppendElement
(
new
mozilla
:
:
dom
:
:
Touch
(
mLastTouchIdentifier
ldPoint
LayoutDeviceIntPoint
(
)
0
0
)
)
;
APZCCallbackHelper
:
:
DispatchWidgetEvent
(
cancelTouchEvent
)
;
}
}
void
APZEventState
:
:
ProcessLongTapUp
(
PresShell
*
aPresShell
const
CSSPoint
&
aPoint
const
CSSToLayoutDeviceScale
&
aScale
Modifiers
aModifiers
)
{
#
ifdef
XP_WIN
nsCOMPtr
<
nsIWidget
>
widget
=
GetWidget
(
)
;
if
(
widget
)
{
FireContextmenuEvents
(
aPresShell
aPoint
aScale
aModifiers
widget
)
;
}
#
endif
}
void
APZEventState
:
:
ProcessTouchEvent
(
const
WidgetTouchEvent
&
aEvent
const
ScrollableLayerGuid
&
aGuid
uint64_t
aInputBlockId
nsEventStatus
aApzResponse
nsEventStatus
aContentResponse
nsTArray
<
TouchBehaviorFlags
>
&
&
aAllowedTouchBehaviors
)
{
if
(
aEvent
.
mMessage
=
=
eTouchStart
&
&
aEvent
.
mTouches
.
Length
(
)
>
0
)
{
mActiveElementManager
-
>
SetTargetElement
(
aEvent
.
mTouches
[
0
]
-
>
GetOriginalTarget
(
)
)
;
mLastTouchIdentifier
=
aEvent
.
mTouches
[
0
]
-
>
Identifier
(
)
;
}
if
(
aEvent
.
mMessage
=
=
eTouchStart
)
{
mTouchBlockAllowedBehaviors
=
std
:
:
move
(
aAllowedTouchBehaviors
)
;
}
bool
isTouchPrevented
=
aContentResponse
=
=
nsEventStatus_eConsumeNoDefault
;
bool
mayNeedPointerCancelEvent
=
false
;
APZES_LOG
(
"
Handling
event
type
%
d
isPrevented
=
%
d
\
n
"
aEvent
.
mMessage
isTouchPrevented
)
;
switch
(
aEvent
.
mMessage
)
{
case
eTouchStart
:
{
mTouchEndCancelled
=
false
;
mReceivedNonTouchStart
=
false
;
mTouchRollup
=
do_GetWeakReference
(
widget
:
:
nsAutoRollup
:
:
GetLastRollup
(
)
)
;
SendPendingTouchPreventedResponse
(
false
)
;
MOZ_ASSERT
(
aEvent
.
mFlags
.
mHandledByAPZ
)
;
if
(
mTouchCounter
.
GetActiveTouchCount
(
)
=
=
0
)
{
mFirstTouchCancelled
=
isTouchPrevented
;
const
PointerInfo
*
pointerInfo
=
!
aEvent
.
mTouches
.
IsEmpty
(
)
?
PointerEventHandler
:
:
GetPointerInfo
(
aEvent
.
mTouches
[
0
]
-
>
Identifier
(
)
)
:
nullptr
;
mPrecedingPointerDownState
=
pointerInfo
&
&
pointerInfo
-
>
mPreventMouseEventByContent
?
PrecedingPointerDown
:
:
ConsumedByContent
:
PrecedingPointerDown
:
:
NotConsumed
;
}
else
{
if
(
mFirstTouchCancelled
&
&
!
isTouchPrevented
)
{
APZES_LOG
(
"
Propagating
prevent
-
default
from
first
-
touch
for
block
%
"
PRIu64
"
\
n
"
aInputBlockId
)
;
}
isTouchPrevented
|
=
mFirstTouchCancelled
;
}
mTouchStartPrevented
=
isTouchPrevented
;
if
(
isTouchPrevented
)
{
mContentReceivedInputBlockCallback
(
aInputBlockId
isTouchPrevented
)
;
}
else
{
APZES_LOG
(
"
Event
not
prevented
;
pending
response
for
%
"
PRIu64
"
%
s
\
n
"
aInputBlockId
ToString
(
aGuid
)
.
c_str
(
)
)
;
mPendingTouchPreventedResponse
=
true
;
mPendingTouchPreventedGuid
=
aGuid
;
mPendingTouchPreventedBlockId
=
aInputBlockId
;
}
break
;
}
case
eTouchEnd
:
if
(
isTouchPrevented
)
{
mTouchEndCancelled
=
true
;
mEndTouchState
=
apz
:
:
SingleTapState
:
:
NotClick
;
}
[
[
fallthrough
]
]
;
case
eTouchCancel
:
if
(
mActiveElementManager
-
>
HandleTouchEndEvent
(
mEndTouchState
)
)
{
mEndTouchState
=
apz
:
:
SingleTapState
:
:
NotClick
;
}
[
[
fallthrough
]
]
;
case
eTouchMove
:
{
if
(
!
mReceivedNonTouchStart
)
{
mayNeedPointerCancelEvent
=
!
isTouchPrevented
&
&
!
mTouchStartPrevented
;
mReceivedNonTouchStart
=
true
;
}
if
(
mPendingTouchPreventedResponse
)
{
MOZ_ASSERT
(
aGuid
=
=
mPendingTouchPreventedGuid
)
;
if
(
aEvent
.
mMessage
=
=
eTouchCancel
)
{
isTouchPrevented
=
true
;
}
mContentReceivedInputBlockCallback
(
aInputBlockId
isTouchPrevented
)
;
mPendingTouchPreventedResponse
=
false
;
}
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
touch
event
type
"
)
;
break
;
}
mTouchCounter
.
Update
(
aEvent
)
;
if
(
mTouchCounter
.
GetActiveTouchCount
(
)
=
=
0
)
{
mFirstTouchCancelled
=
false
;
}
APZES_LOG
(
"
Pointercancel
if
%
d
%
d
%
d
%
d
\
n
"
mayNeedPointerCancelEvent
!
isTouchPrevented
aApzResponse
=
=
nsEventStatus_eConsumeDoDefault
MainThreadAgreesEventsAreConsumableByAPZ
(
)
)
;
if
(
mayNeedPointerCancelEvent
&
&
aApzResponse
=
=
nsEventStatus_eConsumeDoDefault
&
&
MainThreadAgreesEventsAreConsumableByAPZ
(
)
)
{
WidgetTouchEvent
cancelEvent
(
aEvent
)
;
cancelEvent
.
mMessage
=
eTouchPointerCancel
;
cancelEvent
.
mFlags
.
mCancelable
=
false
;
for
(
uint32_t
i
=
0
;
i
<
cancelEvent
.
mTouches
.
Length
(
)
;
+
+
i
)
{
if
(
mozilla
:
:
dom
:
:
Touch
*
touch
=
cancelEvent
.
mTouches
[
i
]
)
{
touch
-
>
convertToPointer
=
true
;
}
}
nsEventStatus
status
;
cancelEvent
.
mWidget
-
>
DispatchEvent
(
&
cancelEvent
status
)
;
}
}
bool
APZEventState
:
:
MainThreadAgreesEventsAreConsumableByAPZ
(
)
const
{
switch
(
mTouchBlockAllowedBehaviors
.
Length
(
)
)
{
case
0
:
return
true
;
case
1
:
{
TouchBehaviorFlags
flags
=
mTouchBlockAllowedBehaviors
[
0
]
;
return
(
flags
&
AllowedTouchBehavior
:
:
HORIZONTAL_PAN
)
|
|
(
flags
&
AllowedTouchBehavior
:
:
VERTICAL_PAN
)
;
}
case
2
:
{
for
(
const
auto
&
allowed
:
mTouchBlockAllowedBehaviors
)
{
if
(
!
(
allowed
&
AllowedTouchBehavior
:
:
PINCH_ZOOM
)
)
{
return
false
;
}
}
return
true
;
}
default
:
return
false
;
}
}
void
APZEventState
:
:
ProcessWheelEvent
(
const
WidgetWheelEvent
&
aEvent
uint64_t
aInputBlockId
)
{
bool
defaultPrevented
=
aEvent
.
DefaultPrevented
(
)
|
|
aEvent
.
TriggersSwipe
(
)
;
mContentReceivedInputBlockCallback
(
aInputBlockId
defaultPrevented
)
;
}
void
APZEventState
:
:
ProcessMouseEvent
(
const
WidgetMouseEvent
&
aEvent
uint64_t
aInputBlockId
)
{
bool
defaultPrevented
=
false
;
mContentReceivedInputBlockCallback
(
aInputBlockId
defaultPrevented
)
;
}
void
APZEventState
:
:
ProcessAPZStateChange
(
ViewID
aViewId
APZStateChange
aChange
int
aArg
Maybe
<
uint64_t
>
aInputBlockId
)
{
switch
(
aChange
)
{
case
APZStateChange
:
:
eTransformBegin
:
{
ScrollContainerFrame
*
sf
=
nsLayoutUtils
:
:
FindScrollContainerFrameFor
(
aViewId
)
;
if
(
sf
)
{
sf
-
>
SetTransformingByAPZ
(
true
)
;
sf
-
>
ScrollbarActivityStarted
(
)
;
}
nsIContent
*
content
=
nsLayoutUtils
:
:
FindContentFor
(
aViewId
)
;
dom
:
:
Document
*
doc
=
content
?
content
-
>
GetComposedDoc
(
)
:
nullptr
;
nsCOMPtr
<
nsIDocShell
>
docshell
(
doc
?
doc
-
>
GetDocShell
(
)
:
nullptr
)
;
if
(
docshell
&
&
sf
)
{
nsDocShell
*
nsdocshell
=
static_cast
<
nsDocShell
*
>
(
docshell
.
get
(
)
)
;
nsdocshell
-
>
NotifyAsyncPanZoomStarted
(
)
;
}
break
;
}
case
APZStateChange
:
:
eTransformEnd
:
{
ScrollContainerFrame
*
sf
=
nsLayoutUtils
:
:
FindScrollContainerFrameFor
(
aViewId
)
;
if
(
sf
)
{
sf
-
>
SetTransformingByAPZ
(
false
)
;
sf
-
>
ScrollbarActivityStopped
(
)
;
}
nsIContent
*
content
=
nsLayoutUtils
:
:
FindContentFor
(
aViewId
)
;
dom
:
:
Document
*
doc
=
content
?
content
-
>
GetComposedDoc
(
)
:
nullptr
;
nsCOMPtr
<
nsIDocShell
>
docshell
(
doc
?
doc
-
>
GetDocShell
(
)
:
nullptr
)
;
if
(
docshell
&
&
sf
)
{
nsDocShell
*
nsdocshell
=
static_cast
<
nsDocShell
*
>
(
docshell
.
get
(
)
)
;
nsdocshell
-
>
NotifyAsyncPanZoomStopped
(
)
;
}
break
;
}
case
APZStateChange
:
:
eStartTouch
:
{
bool
canBePanOrZoom
=
aArg
;
mActiveElementManager
-
>
HandleTouchStart
(
canBePanOrZoom
)
;
APZES_LOG
(
"
%
s
:
can
-
be
-
pan
-
or
-
zoom
=
%
d
"
__FUNCTION__
aArg
)
;
if
(
!
canBePanOrZoom
)
{
MOZ_ASSERT
(
aInputBlockId
.
isSome
(
)
)
;
}
break
;
}
case
APZStateChange
:
:
eStartPanning
:
{
mActiveElementManager
-
>
ClearActivation
(
)
;
break
;
}
case
APZStateChange
:
:
eEndTouch
:
{
mEndTouchState
=
static_cast
<
apz
:
:
SingleTapState
>
(
aArg
)
;
if
(
mActiveElementManager
-
>
HandleTouchEnd
(
mEndTouchState
)
)
{
mEndTouchState
=
apz
:
:
SingleTapState
:
:
NotClick
;
}
break
;
}
}
}
void
APZEventState
:
:
Destroy
(
)
{
mActiveElementManager
-
>
Destroy
(
)
;
}
void
APZEventState
:
:
SendPendingTouchPreventedResponse
(
bool
aPreventDefault
)
{
if
(
mPendingTouchPreventedResponse
)
{
APZES_LOG
(
"
Sending
response
%
d
for
pending
guid
:
%
s
block
id
:
%
"
PRIu64
"
\
n
"
aPreventDefault
ToString
(
mPendingTouchPreventedGuid
)
.
c_str
(
)
mPendingTouchPreventedBlockId
)
;
mContentReceivedInputBlockCallback
(
mPendingTouchPreventedBlockId
aPreventDefault
)
;
mPendingTouchPreventedResponse
=
false
;
}
}
already_AddRefed
<
nsIWidget
>
APZEventState
:
:
GetWidget
(
)
const
{
nsCOMPtr
<
nsIWidget
>
result
=
do_QueryReferent
(
mWidget
)
;
return
result
.
forget
(
)
;
}
already_AddRefed
<
nsIContent
>
APZEventState
:
:
GetTouchRollup
(
)
const
{
nsCOMPtr
<
nsIContent
>
result
=
do_QueryReferent
(
mTouchRollup
)
;
return
result
.
forget
(
)
;
}
}
}
