#
include
"
APZEventState
.
h
"
#
include
"
ActiveElementManager
.
h
"
#
include
"
APZCCallbackHelper
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
LayersLogging
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
dom
/
TabChild
.
h
"
#
include
"
mozilla
/
dom
/
TabGroup
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TouchEvents
.
h
"
#
include
"
mozilla
/
layers
/
APZCCallbackHelper
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsIDOMMouseEvent
.
h
"
#
include
"
nsIDOMWindowUtils
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsIScrollbarMediator
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsQueryFrame
.
h
"
#
include
"
TouchManager
.
h
"
#
include
"
nsIDOMMouseEvent
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsIScrollbarMediator
.
h
"
#
include
"
mozilla
/
TouchEvents
.
h
"
#
include
"
mozilla
/
widget
/
nsAutoRollup
.
h
"
#
define
APZES_LOG
(
.
.
.
)
namespace
{
int32_t
WidgetModifiersToDOMModifiers
(
mozilla
:
:
Modifiers
aModifiers
)
{
int32_t
result
=
0
;
if
(
aModifiers
&
mozilla
:
:
MODIFIER_SHIFT
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_SHIFT
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_CONTROL
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_CONTROL
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_ALT
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_ALT
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_META
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_META
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_ALTGRAPH
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_ALTGRAPH
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_CAPSLOCK
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_CAPSLOCK
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_FN
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_FN
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_FNLOCK
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_FNLOCK
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_NUMLOCK
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_NUMLOCK
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_SCROLLLOCK
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_SCROLLLOCK
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_SYMBOL
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_SYMBOL
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_SYMBOLLOCK
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_SYMBOLLOCK
;
}
if
(
aModifiers
&
mozilla
:
:
MODIFIER_OS
)
{
result
|
=
nsIDOMWindowUtils
:
:
MODIFIER_OS
;
}
return
result
;
}
}
namespace
mozilla
{
namespace
layers
{
static
int32_t
sActiveDurationMs
=
10
;
static
bool
sActiveDurationMsSet
=
false
;
APZEventState
:
:
APZEventState
(
nsIWidget
*
aWidget
ContentReceivedInputBlockCallback
&
&
aCallback
)
:
mWidget
(
nullptr
)
mActiveElementManager
(
new
ActiveElementManager
(
)
)
mContentReceivedInputBlockCallback
(
Move
(
aCallback
)
)
mPendingTouchPreventedResponse
(
false
)
mPendingTouchPreventedBlockId
(
0
)
mEndTouchIsClick
(
false
)
mTouchEndCancelled
(
false
)
mLastTouchIdentifier
(
0
)
{
nsresult
rv
;
mWidget
=
do_GetWeakReference
(
aWidget
&
rv
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
APZEventState
constructed
with
a
widget
that
"
"
does
not
support
weak
references
.
APZ
will
NOT
work
!
"
)
;
if
(
!
sActiveDurationMsSet
)
{
Preferences
:
:
AddIntVarCache
(
&
sActiveDurationMs
"
ui
.
touch_activation
.
duration_ms
"
sActiveDurationMs
)
;
sActiveDurationMsSet
=
true
;
}
}
APZEventState
:
:
~
APZEventState
(
)
{
}
class
DelayedFireSingleTapEvent
final
:
public
nsITimerCallback
public
nsINamed
{
public
:
NS_DECL_ISUPPORTS
DelayedFireSingleTapEvent
(
nsWeakPtr
aWidget
LayoutDevicePoint
&
aPoint
Modifiers
aModifiers
int32_t
aClickCount
nsITimer
*
aTimer
RefPtr
<
nsIContent
>
&
aTouchRollup
)
:
mWidget
(
aWidget
)
mPoint
(
aPoint
)
mModifiers
(
aModifiers
)
mClickCount
(
aClickCount
)
mTimer
(
aTimer
)
mTouchRollup
(
aTouchRollup
)
{
}
NS_IMETHOD
Notify
(
nsITimer
*
)
override
{
if
(
nsCOMPtr
<
nsIWidget
>
widget
=
do_QueryReferent
(
mWidget
)
)
{
widget
:
:
nsAutoRollup
rollup
(
mTouchRollup
.
get
(
)
)
;
APZCCallbackHelper
:
:
FireSingleTapEvent
(
mPoint
mModifiers
mClickCount
widget
)
;
}
mTimer
=
nullptr
;
return
NS_OK
;
}
NS_IMETHOD
GetName
(
nsACString
&
aName
)
override
{
aName
.
AssignLiteral
(
"
DelayedFireSingleTapEvent
"
)
;
return
NS_OK
;
}
void
ClearTimer
(
)
{
mTimer
=
nullptr
;
}
private
:
~
DelayedFireSingleTapEvent
(
)
{
}
nsWeakPtr
mWidget
;
LayoutDevicePoint
mPoint
;
Modifiers
mModifiers
;
int32_t
mClickCount
;
nsCOMPtr
<
nsITimer
>
mTimer
;
RefPtr
<
nsIContent
>
mTouchRollup
;
}
;
NS_IMPL_ISUPPORTS
(
DelayedFireSingleTapEvent
nsITimerCallback
nsINamed
)
void
APZEventState
:
:
ProcessSingleTap
(
const
CSSPoint
&
aPoint
const
CSSToLayoutDeviceScale
&
aScale
Modifiers
aModifiers
const
ScrollableLayerGuid
&
aGuid
int32_t
aClickCount
)
{
APZES_LOG
(
"
Handling
single
tap
at
%
s
on
%
s
with
%
d
\
n
"
Stringify
(
aPoint
)
.
c_str
(
)
Stringify
(
aGuid
)
.
c_str
(
)
mTouchEndCancelled
)
;
RefPtr
<
nsIContent
>
touchRollup
=
GetTouchRollup
(
)
;
mTouchRollup
=
nullptr
;
nsCOMPtr
<
nsIWidget
>
widget
=
GetWidget
(
)
;
if
(
!
widget
)
{
return
;
}
if
(
mTouchEndCancelled
)
{
return
;
}
LayoutDevicePoint
ldPoint
=
aPoint
*
aScale
;
APZES_LOG
(
"
Scheduling
timer
for
click
event
\
n
"
)
;
nsCOMPtr
<
nsITimer
>
timer
=
do_CreateInstance
(
NS_TIMER_CONTRACTID
)
;
dom
:
:
TabChild
*
tabChild
=
widget
-
>
GetOwningTabChild
(
)
;
if
(
tabChild
&
&
XRE_IsContentProcess
(
)
)
{
timer
-
>
SetTarget
(
tabChild
-
>
TabGroup
(
)
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
}
RefPtr
<
DelayedFireSingleTapEvent
>
callback
=
new
DelayedFireSingleTapEvent
(
mWidget
ldPoint
aModifiers
aClickCount
timer
touchRollup
)
;
nsresult
rv
=
timer
-
>
InitWithCallback
(
callback
sActiveDurationMs
nsITimer
:
:
TYPE_ONE_SHOT
)
;
if
(
NS_FAILED
(
rv
)
)
{
callback
-
>
ClearTimer
(
)
;
}
}
bool
APZEventState
:
:
FireContextmenuEvents
(
const
nsCOMPtr
<
nsIPresShell
>
&
aPresShell
const
CSSPoint
&
aPoint
const
CSSToLayoutDeviceScale
&
aScale
Modifiers
aModifiers
const
nsCOMPtr
<
nsIWidget
>
&
aWidget
)
{
bool
eventHandled
=
APZCCallbackHelper
:
:
DispatchMouseEvent
(
aPresShell
NS_LITERAL_STRING
(
"
contextmenu
"
)
aPoint
2
1
WidgetModifiersToDOMModifiers
(
aModifiers
)
true
nsIDOMMouseEvent
:
:
MOZ_SOURCE_TOUCH
0
)
;
APZES_LOG
(
"
Contextmenu
event
handled
:
%
d
\
n
"
eventHandled
)
;
if
(
eventHandled
)
{
mActiveElementManager
-
>
ClearActivation
(
)
;
#
ifndef
XP_WIN
}
else
{
nsEventStatus
status
=
APZCCallbackHelper
:
:
DispatchSynthesizedMouseEvent
(
eMouseLongTap
0
aPoint
*
aScale
aModifiers
1
aWidget
)
;
eventHandled
=
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
;
APZES_LOG
(
"
eMouseLongTap
event
handled
:
%
d
\
n
"
eventHandled
)
;
#
endif
}
return
eventHandled
;
}
void
APZEventState
:
:
ProcessLongTap
(
const
nsCOMPtr
<
nsIPresShell
>
&
aPresShell
const
CSSPoint
&
aPoint
const
CSSToLayoutDeviceScale
&
aScale
Modifiers
aModifiers
const
ScrollableLayerGuid
&
aGuid
uint64_t
aInputBlockId
)
{
APZES_LOG
(
"
Handling
long
tap
at
%
s
\
n
"
Stringify
(
aPoint
)
.
c_str
(
)
)
;
nsCOMPtr
<
nsIWidget
>
widget
=
GetWidget
(
)
;
if
(
!
widget
)
{
return
;
}
SendPendingTouchPreventedResponse
(
false
)
;
#
ifdef
XP_WIN
nsEventStatus
status
=
APZCCallbackHelper
:
:
DispatchSynthesizedMouseEvent
(
eMouseLongTap
0
aPoint
*
aScale
aModifiers
1
widget
)
;
bool
eventHandled
=
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
;
#
else
bool
eventHandled
=
FireContextmenuEvents
(
aPresShell
aPoint
aScale
aModifiers
widget
)
;
#
endif
mContentReceivedInputBlockCallback
(
aGuid
aInputBlockId
eventHandled
)
;
if
(
eventHandled
)
{
WidgetTouchEvent
cancelTouchEvent
(
true
eTouchCancel
widget
.
get
(
)
)
;
cancelTouchEvent
.
mModifiers
=
aModifiers
;
auto
ldPoint
=
LayoutDeviceIntPoint
:
:
Round
(
aPoint
*
aScale
)
;
cancelTouchEvent
.
mTouches
.
AppendElement
(
new
mozilla
:
:
dom
:
:
Touch
(
mLastTouchIdentifier
ldPoint
LayoutDeviceIntPoint
(
)
0
0
)
)
;
APZCCallbackHelper
:
:
DispatchWidgetEvent
(
cancelTouchEvent
)
;
}
}
void
APZEventState
:
:
ProcessLongTapUp
(
const
nsCOMPtr
<
nsIPresShell
>
&
aPresShell
const
CSSPoint
&
aPoint
const
CSSToLayoutDeviceScale
&
aScale
Modifiers
aModifiers
)
{
#
ifdef
XP_WIN
nsCOMPtr
<
nsIWidget
>
widget
=
GetWidget
(
)
;
if
(
widget
)
{
FireContextmenuEvents
(
aPresShell
aPoint
aScale
aModifiers
widget
)
;
}
#
endif
}
void
APZEventState
:
:
ProcessTouchEvent
(
const
WidgetTouchEvent
&
aEvent
const
ScrollableLayerGuid
&
aGuid
uint64_t
aInputBlockId
nsEventStatus
aApzResponse
nsEventStatus
aContentResponse
)
{
if
(
aEvent
.
mMessage
=
=
eTouchStart
&
&
aEvent
.
mTouches
.
Length
(
)
>
0
)
{
mActiveElementManager
-
>
SetTargetElement
(
aEvent
.
mTouches
[
0
]
-
>
GetTarget
(
)
)
;
mLastTouchIdentifier
=
aEvent
.
mTouches
[
0
]
-
>
Identifier
(
)
;
}
bool
isTouchPrevented
=
aContentResponse
=
=
nsEventStatus_eConsumeNoDefault
;
bool
sentContentResponse
=
false
;
APZES_LOG
(
"
Handling
event
type
%
d
\
n
"
aEvent
.
mMessage
)
;
switch
(
aEvent
.
mMessage
)
{
case
eTouchStart
:
{
mTouchEndCancelled
=
false
;
mTouchRollup
=
do_GetWeakReference
(
widget
:
:
nsAutoRollup
:
:
GetLastRollup
(
)
)
;
sentContentResponse
=
SendPendingTouchPreventedResponse
(
false
)
;
MOZ_ASSERT
(
aEvent
.
mFlags
.
mHandledByAPZ
)
;
if
(
isTouchPrevented
)
{
mContentReceivedInputBlockCallback
(
aGuid
aInputBlockId
isTouchPrevented
)
;
sentContentResponse
=
true
;
}
else
{
APZES_LOG
(
"
Event
not
prevented
;
pending
response
for
%
"
PRIu64
"
%
s
\
n
"
aInputBlockId
Stringify
(
aGuid
)
.
c_str
(
)
)
;
mPendingTouchPreventedResponse
=
true
;
mPendingTouchPreventedGuid
=
aGuid
;
mPendingTouchPreventedBlockId
=
aInputBlockId
;
}
break
;
}
case
eTouchEnd
:
if
(
isTouchPrevented
)
{
mTouchEndCancelled
=
true
;
mEndTouchIsClick
=
false
;
}
MOZ_FALLTHROUGH
;
case
eTouchCancel
:
mActiveElementManager
-
>
HandleTouchEndEvent
(
mEndTouchIsClick
)
;
MOZ_FALLTHROUGH
;
case
eTouchMove
:
{
if
(
mPendingTouchPreventedResponse
)
{
MOZ_ASSERT
(
aGuid
=
=
mPendingTouchPreventedGuid
)
;
}
sentContentResponse
=
SendPendingTouchPreventedResponse
(
isTouchPrevented
)
;
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
touch
event
type
"
)
;
break
;
}
if
(
sentContentResponse
&
&
aApzResponse
=
=
nsEventStatus_eConsumeDoDefault
&
&
gfxPrefs
:
:
PointerEventsEnabled
(
)
)
{
WidgetTouchEvent
cancelEvent
(
aEvent
)
;
cancelEvent
.
mMessage
=
eTouchPointerCancel
;
cancelEvent
.
mFlags
.
mCancelable
=
false
;
for
(
uint32_t
i
=
0
;
i
<
cancelEvent
.
mTouches
.
Length
(
)
;
+
+
i
)
{
if
(
mozilla
:
:
dom
:
:
Touch
*
touch
=
cancelEvent
.
mTouches
[
i
]
)
{
touch
-
>
convertToPointer
=
true
;
}
}
nsEventStatus
status
;
cancelEvent
.
mWidget
-
>
DispatchEvent
(
&
cancelEvent
status
)
;
}
}
void
APZEventState
:
:
ProcessWheelEvent
(
const
WidgetWheelEvent
&
aEvent
const
ScrollableLayerGuid
&
aGuid
uint64_t
aInputBlockId
)
{
bool
defaultPrevented
=
aEvent
.
DefaultPrevented
(
)
|
|
aEvent
.
TriggersSwipe
(
)
;
mContentReceivedInputBlockCallback
(
aGuid
aInputBlockId
defaultPrevented
)
;
}
void
APZEventState
:
:
ProcessMouseEvent
(
const
WidgetMouseEvent
&
aEvent
const
ScrollableLayerGuid
&
aGuid
uint64_t
aInputBlockId
)
{
bool
defaultPrevented
=
false
;
mContentReceivedInputBlockCallback
(
aGuid
aInputBlockId
defaultPrevented
)
;
}
void
APZEventState
:
:
ProcessAPZStateChange
(
ViewID
aViewId
APZStateChange
aChange
int
aArg
)
{
switch
(
aChange
)
{
case
APZStateChange
:
:
eTransformBegin
:
{
nsIScrollableFrame
*
sf
=
nsLayoutUtils
:
:
FindScrollableFrameFor
(
aViewId
)
;
if
(
sf
)
{
sf
-
>
SetTransformingByAPZ
(
true
)
;
}
nsIScrollbarMediator
*
scrollbarMediator
=
do_QueryFrame
(
sf
)
;
if
(
scrollbarMediator
)
{
scrollbarMediator
-
>
ScrollbarActivityStarted
(
)
;
}
nsIContent
*
content
=
nsLayoutUtils
:
:
FindContentFor
(
aViewId
)
;
nsIDocument
*
doc
=
content
?
content
-
>
GetComposedDoc
(
)
:
nullptr
;
nsCOMPtr
<
nsIDocShell
>
docshell
(
doc
?
doc
-
>
GetDocShell
(
)
:
nullptr
)
;
if
(
docshell
&
&
sf
)
{
nsDocShell
*
nsdocshell
=
static_cast
<
nsDocShell
*
>
(
docshell
.
get
(
)
)
;
nsdocshell
-
>
NotifyAsyncPanZoomStarted
(
)
;
}
break
;
}
case
APZStateChange
:
:
eTransformEnd
:
{
nsIScrollableFrame
*
sf
=
nsLayoutUtils
:
:
FindScrollableFrameFor
(
aViewId
)
;
if
(
sf
)
{
sf
-
>
SetTransformingByAPZ
(
false
)
;
}
nsIScrollbarMediator
*
scrollbarMediator
=
do_QueryFrame
(
sf
)
;
if
(
scrollbarMediator
)
{
scrollbarMediator
-
>
ScrollbarActivityStopped
(
)
;
}
nsIContent
*
content
=
nsLayoutUtils
:
:
FindContentFor
(
aViewId
)
;
nsIDocument
*
doc
=
content
?
content
-
>
GetComposedDoc
(
)
:
nullptr
;
nsCOMPtr
<
nsIDocShell
>
docshell
(
doc
?
doc
-
>
GetDocShell
(
)
:
nullptr
)
;
if
(
docshell
&
&
sf
)
{
nsDocShell
*
nsdocshell
=
static_cast
<
nsDocShell
*
>
(
docshell
.
get
(
)
)
;
nsdocshell
-
>
NotifyAsyncPanZoomStopped
(
)
;
}
break
;
}
case
APZStateChange
:
:
eStartTouch
:
{
mActiveElementManager
-
>
HandleTouchStart
(
aArg
)
;
break
;
}
case
APZStateChange
:
:
eStartPanning
:
{
mActiveElementManager
-
>
ClearActivation
(
)
;
break
;
}
case
APZStateChange
:
:
eEndTouch
:
{
mEndTouchIsClick
=
aArg
;
mActiveElementManager
-
>
HandleTouchEnd
(
)
;
break
;
}
}
}
void
APZEventState
:
:
ProcessClusterHit
(
)
{
#
ifndef
MOZ_WIDGET_ANDROID
MOZ_ASSERT
(
false
)
;
#
endif
mActiveElementManager
-
>
ClearActivation
(
)
;
}
bool
APZEventState
:
:
SendPendingTouchPreventedResponse
(
bool
aPreventDefault
)
{
if
(
mPendingTouchPreventedResponse
)
{
APZES_LOG
(
"
Sending
response
%
d
for
pending
guid
:
%
s
\
n
"
aPreventDefault
Stringify
(
mPendingTouchPreventedGuid
)
.
c_str
(
)
)
;
mContentReceivedInputBlockCallback
(
mPendingTouchPreventedGuid
mPendingTouchPreventedBlockId
aPreventDefault
)
;
mPendingTouchPreventedResponse
=
false
;
return
true
;
}
return
false
;
}
already_AddRefed
<
nsIWidget
>
APZEventState
:
:
GetWidget
(
)
const
{
nsCOMPtr
<
nsIWidget
>
result
=
do_QueryReferent
(
mWidget
)
;
return
result
.
forget
(
)
;
}
already_AddRefed
<
nsIContent
>
APZEventState
:
:
GetTouchRollup
(
)
const
{
nsCOMPtr
<
nsIContent
>
result
=
do_QueryReferent
(
mTouchRollup
)
;
return
result
.
forget
(
)
;
}
}
}
