#
include
"
ActiveElementManager
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
StaticPrefs_ui
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsITimer
.
h
"
static
mozilla
:
:
LazyLogModule
sApzAemLog
(
"
apz
.
activeelement
"
)
;
#
define
AEM_LOG
(
.
.
.
)
MOZ_LOG
(
sApzAemLog
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
namespace
mozilla
{
namespace
layers
{
class
DelayedClearElementActivation
final
:
public
nsITimerCallback
public
nsINamed
{
private
:
explicit
DelayedClearElementActivation
(
nsCOMPtr
<
dom
:
:
Element
>
&
aTarget
const
nsCOMPtr
<
nsITimer
>
&
aTimer
)
:
mTarget
(
aTarget
)
mTimer
(
aTimer
)
mProcessedSingleTap
(
false
)
{
}
public
:
NS_DECL_ISUPPORTS
static
RefPtr
<
DelayedClearElementActivation
>
Create
(
nsCOMPtr
<
dom
:
:
Element
>
&
aTarget
)
;
NS_IMETHOD
Notify
(
nsITimer
*
)
override
;
NS_IMETHOD
GetName
(
nsACString
&
aName
)
override
;
void
MarkSingleTapProcessed
(
)
;
bool
ProcessedSingleTap
(
)
const
{
return
mProcessedSingleTap
;
}
void
StartTimer
(
)
;
void
ClearGlobalActiveContent
(
)
;
void
ClearTimer
(
)
{
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
}
private
:
~
DelayedClearElementActivation
(
)
=
default
;
nsCOMPtr
<
dom
:
:
Element
>
mTarget
;
nsCOMPtr
<
nsITimer
>
mTimer
;
bool
mProcessedSingleTap
;
}
;
static
nsPresContext
*
GetPresContextFor
(
nsIContent
*
aContent
)
{
if
(
!
aContent
)
{
return
nullptr
;
}
PresShell
*
presShell
=
aContent
-
>
OwnerDoc
(
)
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
nullptr
;
}
return
presShell
-
>
GetPresContext
(
)
;
}
RefPtr
<
DelayedClearElementActivation
>
DelayedClearElementActivation
:
:
Create
(
nsCOMPtr
<
dom
:
:
Element
>
&
aTarget
)
{
nsCOMPtr
<
nsITimer
>
timer
=
NS_NewTimer
(
)
;
if
(
!
timer
)
{
return
nullptr
;
}
RefPtr
<
DelayedClearElementActivation
>
event
=
new
DelayedClearElementActivation
(
aTarget
timer
)
;
return
event
;
}
NS_IMETHODIMP
DelayedClearElementActivation
:
:
Notify
(
nsITimer
*
)
{
AEM_LOG
(
"
DelayedClearElementActivation
notification
ready
=
%
d
"
mProcessedSingleTap
)
;
if
(
mProcessedSingleTap
)
{
AEM_LOG
(
"
DelayedClearElementActivation
clearing
active
content
\
n
"
)
;
ClearGlobalActiveContent
(
)
;
}
mTimer
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
DelayedClearElementActivation
:
:
GetName
(
nsACString
&
aName
)
{
aName
.
AssignLiteral
(
"
DelayedClearElementActivation
"
)
;
return
NS_OK
;
}
void
DelayedClearElementActivation
:
:
StartTimer
(
)
{
MOZ_ASSERT
(
mTimer
)
;
if
(
!
mTimer
)
{
return
;
}
nsresult
rv
=
mTimer
-
>
InitWithCallback
(
this
StaticPrefs
:
:
ui_touch_activation_duration_ms
(
)
nsITimer
:
:
TYPE_ONE_SHOT
)
;
if
(
NS_FAILED
(
rv
)
)
{
ClearTimer
(
)
;
}
}
void
DelayedClearElementActivation
:
:
MarkSingleTapProcessed
(
)
{
mProcessedSingleTap
=
true
;
if
(
!
mTimer
)
{
AEM_LOG
(
"
Clear
activation
immediate
!
"
)
;
ClearGlobalActiveContent
(
)
;
}
}
void
DelayedClearElementActivation
:
:
ClearGlobalActiveContent
(
)
{
if
(
nsPresContext
*
pc
=
GetPresContextFor
(
mTarget
)
)
{
EventStateManager
:
:
ClearGlobalActiveContent
(
pc
-
>
EventStateManager
(
)
)
;
}
mTarget
=
nullptr
;
}
NS_IMPL_ISUPPORTS
(
DelayedClearElementActivation
nsITimerCallback
nsINamed
)
ActiveElementManager
:
:
ActiveElementManager
(
)
:
mCanBePan
(
false
)
mCanBePanSet
(
false
)
mSetActiveTask
(
nullptr
)
{
}
ActiveElementManager
:
:
~
ActiveElementManager
(
)
=
default
;
void
ActiveElementManager
:
:
SetTargetElement
(
dom
:
:
EventTarget
*
aTarget
)
{
if
(
mTarget
)
{
AEM_LOG
(
"
Multiple
fingers
on
-
screen
clearing
target
element
\
n
"
)
;
CancelTask
(
)
;
ResetActive
(
)
;
ResetTouchBlockState
(
)
;
return
;
}
mTarget
=
dom
:
:
Element
:
:
FromEventTargetOrNull
(
aTarget
)
;
AEM_LOG
(
"
Setting
target
element
to
%
p
\
n
"
mTarget
.
get
(
)
)
;
TriggerElementActivation
(
)
;
}
void
ActiveElementManager
:
:
HandleTouchStart
(
bool
aCanBePan
)
{
AEM_LOG
(
"
Touch
start
aCanBePan
:
%
d
\
n
"
aCanBePan
)
;
if
(
mCanBePanSet
)
{
AEM_LOG
(
"
Multiple
fingers
on
-
screen
clearing
touch
block
state
\
n
"
)
;
CancelTask
(
)
;
ResetActive
(
)
;
ResetTouchBlockState
(
)
;
return
;
}
mCanBePan
=
aCanBePan
;
mCanBePanSet
=
true
;
TriggerElementActivation
(
)
;
}
void
ActiveElementManager
:
:
TriggerElementActivation
(
)
{
if
(
!
(
mTarget
&
&
mCanBePanSet
)
)
{
return
;
}
RefPtr
<
DelayedClearElementActivation
>
delayedEvent
=
DelayedClearElementActivation
:
:
Create
(
mTarget
)
;
if
(
mDelayedClearElementActivation
)
{
mDelayedClearElementActivation
-
>
ClearTimer
(
)
;
mDelayedClearElementActivation
-
>
ClearGlobalActiveContent
(
)
;
}
mDelayedClearElementActivation
=
delayedEvent
;
if
(
!
mCanBePan
)
{
SetActive
(
mTarget
)
;
if
(
mDelayedClearElementActivation
)
{
mDelayedClearElementActivation
-
>
StartTimer
(
)
;
}
}
else
{
CancelTask
(
)
;
MOZ_ASSERT
(
mSetActiveTask
=
=
nullptr
)
;
RefPtr
<
CancelableRunnable
>
task
=
NewCancelableRunnableMethod
<
nsCOMPtr
<
dom
:
:
Element
>
>
(
"
layers
:
:
ActiveElementManager
:
:
SetActiveTask
"
this
&
ActiveElementManager
:
:
SetActiveTask
mTarget
)
;
mSetActiveTask
=
task
;
NS_GetCurrentThread
(
)
-
>
DelayedDispatch
(
task
.
forget
(
)
StaticPrefs
:
:
ui_touch_activation_delay_ms
(
)
)
;
AEM_LOG
(
"
Scheduling
mSetActiveTask
%
p
\
n
"
mSetActiveTask
.
get
(
)
)
;
}
}
void
ActiveElementManager
:
:
ClearActivation
(
)
{
AEM_LOG
(
"
Clearing
element
activation
\
n
"
)
;
CancelTask
(
)
;
ResetActive
(
)
;
}
void
ActiveElementManager
:
:
HandleTouchEndEvent
(
bool
aWasClick
)
{
AEM_LOG
(
"
Touch
end
event
aWasClick
:
%
d
\
n
"
aWasClick
)
;
CancelTask
(
)
;
mTouchEndState
+
=
TouchEndState
:
:
GotTouchEndEvent
;
MaybeChangeActiveState
(
aWasClick
)
;
}
void
ActiveElementManager
:
:
HandleTouchEnd
(
bool
aWasClick
)
{
AEM_LOG
(
"
Touch
end
clearing
pan
state
\
n
"
)
;
mCanBePanSet
=
false
;
mTouchEndState
+
=
TouchEndState
:
:
GotTouchEndNotification
;
MaybeChangeActiveState
(
aWasClick
)
;
}
void
ActiveElementManager
:
:
MaybeChangeActiveState
(
bool
aWasClick
)
{
if
(
mTouchEndState
!
=
TouchEndStates
(
TouchEndState
:
:
GotTouchEndEvent
TouchEndState
:
:
GotTouchEndNotification
)
)
{
return
;
}
if
(
aWasClick
)
{
if
(
!
(
mTarget
&
&
mTarget
-
>
IsXULElement
(
nsGkAtoms
:
:
thumb
)
)
)
{
SetActive
(
mTarget
)
;
}
}
else
{
ResetActive
(
)
;
}
ResetTouchBlockState
(
)
;
}
void
ActiveElementManager
:
:
ProcessSingleTap
(
)
{
if
(
!
mDelayedClearElementActivation
)
{
return
;
}
mDelayedClearElementActivation
-
>
MarkSingleTapProcessed
(
)
;
if
(
mCanBePan
)
{
mDelayedClearElementActivation
-
>
StartTimer
(
)
;
}
mDelayedClearElementActivation
=
nullptr
;
}
void
ActiveElementManager
:
:
Destroy
(
)
{
if
(
mDelayedClearElementActivation
)
{
mDelayedClearElementActivation
-
>
ClearTimer
(
)
;
mDelayedClearElementActivation
=
nullptr
;
}
}
void
ActiveElementManager
:
:
SetActive
(
dom
:
:
Element
*
aTarget
)
{
AEM_LOG
(
"
Setting
active
%
p
\
n
"
aTarget
)
;
if
(
nsPresContext
*
pc
=
GetPresContextFor
(
aTarget
)
)
{
pc
-
>
EventStateManager
(
)
-
>
SetContentState
(
aTarget
dom
:
:
ElementState
:
:
ACTIVE
)
;
}
}
void
ActiveElementManager
:
:
ResetActive
(
)
{
AEM_LOG
(
"
Resetting
active
from
%
p
\
n
"
mTarget
.
get
(
)
)
;
if
(
mTarget
)
{
dom
:
:
Element
*
root
=
mTarget
-
>
OwnerDoc
(
)
-
>
GetDocumentElement
(
)
;
if
(
root
)
{
AEM_LOG
(
"
Found
root
%
p
making
active
\
n
"
root
)
;
SetActive
(
root
)
;
}
}
}
void
ActiveElementManager
:
:
ResetTouchBlockState
(
)
{
mTarget
=
nullptr
;
mCanBePanSet
=
false
;
mTouchEndState
.
clear
(
)
;
}
void
ActiveElementManager
:
:
SetActiveTask
(
const
nsCOMPtr
<
dom
:
:
Element
>
&
aTarget
)
{
AEM_LOG
(
"
mSetActiveTask
%
p
running
\
n
"
mSetActiveTask
.
get
(
)
)
;
mSetActiveTask
=
nullptr
;
SetActive
(
aTarget
)
;
}
void
ActiveElementManager
:
:
CancelTask
(
)
{
AEM_LOG
(
"
Cancelling
task
%
p
\
n
"
mSetActiveTask
.
get
(
)
)
;
if
(
mSetActiveTask
)
{
mSetActiveTask
-
>
Cancel
(
)
;
mSetActiveTask
=
nullptr
;
}
}
}
}
