#
include
"
ActiveElementManager
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
StyleSetHandle
.
h
"
#
include
"
mozilla
/
StyleSetHandleInlines
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsIDocument
.
h
"
#
ifdef
MOZ_OLD_STYLE
#
include
"
nsStyleSet
.
h
"
#
endif
#
define
AEM_LOG
(
.
.
.
)
namespace
mozilla
{
namespace
layers
{
static
int32_t
sActivationDelayMs
=
100
;
static
bool
sActivationDelayMsSet
=
false
;
ActiveElementManager
:
:
ActiveElementManager
(
)
:
mCanBePan
(
false
)
mCanBePanSet
(
false
)
mSetActiveTask
(
nullptr
)
{
if
(
!
sActivationDelayMsSet
)
{
Preferences
:
:
AddIntVarCache
(
&
sActivationDelayMs
"
ui
.
touch_activation
.
delay_ms
"
sActivationDelayMs
)
;
sActivationDelayMsSet
=
true
;
}
}
ActiveElementManager
:
:
~
ActiveElementManager
(
)
{
}
void
ActiveElementManager
:
:
SetTargetElement
(
dom
:
:
EventTarget
*
aTarget
)
{
if
(
mTarget
)
{
AEM_LOG
(
"
Multiple
fingers
on
-
screen
clearing
target
element
\
n
"
)
;
CancelTask
(
)
;
ResetActive
(
)
;
ResetTouchBlockState
(
)
;
return
;
}
mTarget
=
do_QueryInterface
(
aTarget
)
;
AEM_LOG
(
"
Setting
target
element
to
%
p
\
n
"
mTarget
.
get
(
)
)
;
TriggerElementActivation
(
)
;
}
void
ActiveElementManager
:
:
HandleTouchStart
(
bool
aCanBePan
)
{
AEM_LOG
(
"
Touch
start
aCanBePan
:
%
d
\
n
"
aCanBePan
)
;
if
(
mCanBePanSet
)
{
AEM_LOG
(
"
Multiple
fingers
on
-
screen
clearing
touch
block
state
\
n
"
)
;
CancelTask
(
)
;
ResetActive
(
)
;
ResetTouchBlockState
(
)
;
return
;
}
mCanBePan
=
aCanBePan
;
mCanBePanSet
=
true
;
TriggerElementActivation
(
)
;
}
void
ActiveElementManager
:
:
TriggerElementActivation
(
)
{
if
(
!
(
mTarget
&
&
mCanBePanSet
)
)
{
return
;
}
if
(
!
mCanBePan
)
{
SetActive
(
mTarget
)
;
}
else
{
CancelTask
(
)
;
MOZ_ASSERT
(
mSetActiveTask
=
=
nullptr
)
;
RefPtr
<
CancelableRunnable
>
task
=
NewCancelableRunnableMethod
<
nsCOMPtr
<
dom
:
:
Element
>
>
(
"
layers
:
:
ActiveElementManager
:
:
SetActiveTask
"
this
&
ActiveElementManager
:
:
SetActiveTask
mTarget
)
;
mSetActiveTask
=
task
;
MessageLoop
:
:
current
(
)
-
>
PostDelayedTask
(
task
.
forget
(
)
sActivationDelayMs
)
;
AEM_LOG
(
"
Scheduling
mSetActiveTask
%
p
\
n
"
mSetActiveTask
)
;
}
}
void
ActiveElementManager
:
:
ClearActivation
(
)
{
AEM_LOG
(
"
Clearing
element
activation
\
n
"
)
;
CancelTask
(
)
;
ResetActive
(
)
;
}
void
ActiveElementManager
:
:
HandleTouchEndEvent
(
bool
aWasClick
)
{
AEM_LOG
(
"
Touch
end
event
aWasClick
:
%
d
\
n
"
aWasClick
)
;
CancelTask
(
)
;
if
(
aWasClick
)
{
if
(
!
(
mTarget
&
&
mTarget
-
>
IsXULElement
(
nsGkAtoms
:
:
thumb
)
)
)
{
SetActive
(
mTarget
)
;
}
}
else
{
ResetActive
(
)
;
}
ResetTouchBlockState
(
)
;
}
void
ActiveElementManager
:
:
HandleTouchEnd
(
)
{
AEM_LOG
(
"
Touch
end
clearing
pan
state
\
n
"
)
;
mCanBePanSet
=
false
;
}
static
nsPresContext
*
GetPresContextFor
(
nsIContent
*
aContent
)
{
if
(
!
aContent
)
{
return
nullptr
;
}
nsIPresShell
*
shell
=
aContent
-
>
OwnerDoc
(
)
-
>
GetShell
(
)
;
if
(
!
shell
)
{
return
nullptr
;
}
return
shell
-
>
GetPresContext
(
)
;
}
void
ActiveElementManager
:
:
SetActive
(
dom
:
:
Element
*
aTarget
)
{
AEM_LOG
(
"
Setting
active
%
p
\
n
"
aTarget
)
;
if
(
nsPresContext
*
pc
=
GetPresContextFor
(
aTarget
)
)
{
pc
-
>
EventStateManager
(
)
-
>
SetContentState
(
aTarget
NS_EVENT_STATE_ACTIVE
)
;
}
}
void
ActiveElementManager
:
:
ResetActive
(
)
{
AEM_LOG
(
"
Resetting
active
from
%
p
\
n
"
mTarget
.
get
(
)
)
;
if
(
mTarget
)
{
dom
:
:
Element
*
root
=
mTarget
-
>
OwnerDoc
(
)
-
>
GetDocumentElement
(
)
;
if
(
root
)
{
AEM_LOG
(
"
Found
root
%
p
making
active
\
n
"
root
)
;
SetActive
(
root
)
;
}
}
}
void
ActiveElementManager
:
:
ResetTouchBlockState
(
)
{
mTarget
=
nullptr
;
mCanBePanSet
=
false
;
}
void
ActiveElementManager
:
:
SetActiveTask
(
const
nsCOMPtr
<
dom
:
:
Element
>
&
aTarget
)
{
AEM_LOG
(
"
mSetActiveTask
%
p
running
\
n
"
mSetActiveTask
)
;
mSetActiveTask
=
nullptr
;
SetActive
(
aTarget
)
;
}
void
ActiveElementManager
:
:
CancelTask
(
)
{
AEM_LOG
(
"
Cancelling
task
%
p
\
n
"
mSetActiveTask
)
;
if
(
mSetActiveTask
)
{
mSetActiveTask
-
>
Cancel
(
)
;
mSetActiveTask
=
nullptr
;
}
}
}
}
