#
ifndef
mozilla_layers_RepaintRequestRunnable_h
#
define
mozilla_layers_RepaintRequestRunnable_h
#
include
<
deque
>
#
include
<
unordered_set
>
#
include
"
mozilla
/
layers
/
GeckoContentController
.
h
"
#
include
"
mozilla
/
layers
/
RepaintRequest
.
h
"
#
include
"
mozilla
/
layers
/
ScrollableLayerGuid
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
namespace
layers
{
class
GeckoContentController
;
class
APZTaskRunnable
final
:
public
Runnable
{
public
:
explicit
APZTaskRunnable
(
GeckoContentController
*
aController
)
:
Runnable
(
"
RepaintRequestRunnable
"
)
mController
(
aController
)
mRegisteredPresShellId
(
0
)
mNeedsFlushCompleteNotification
(
false
)
{
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_DECL_NSIRUNNABLE
void
QueueRequest
(
const
RepaintRequest
&
aRequest
)
;
void
QueueFlushCompleteNotification
(
)
;
void
Revoke
(
)
{
mController
=
nullptr
;
mRegisteredPresShellId
=
0
;
}
private
:
void
EnsureRegisterAsEarlyRunner
(
)
;
bool
IsRegisteredWithCurrentPresShell
(
)
const
;
bool
IsTestControllingRefreshesEnabled
(
)
const
;
GeckoContentController
*
mController
;
struct
RepaintRequestKey
{
ScrollableLayerGuid
:
:
ViewID
mScrollId
;
RepaintRequest
:
:
ScrollOffsetUpdateType
mScrollUpdateType
;
bool
operator
=
=
(
const
RepaintRequestKey
&
aOther
)
const
{
return
mScrollId
=
=
aOther
.
mScrollId
&
&
mScrollUpdateType
=
=
aOther
.
mScrollUpdateType
;
}
struct
HashFn
{
std
:
:
size_t
operator
(
)
(
const
RepaintRequestKey
&
aKey
)
const
{
return
HashGeneric
(
aKey
.
mScrollId
aKey
.
mScrollUpdateType
)
;
}
}
;
}
;
using
RepaintRequests
=
std
:
:
unordered_set
<
RepaintRequestKey
RepaintRequestKey
:
:
HashFn
>
;
RepaintRequests
mPendingRepaintRequestMap
;
std
:
:
deque
<
RepaintRequest
>
mPendingRepaintRequestQueue
;
uint32_t
mRegisteredPresShellId
;
bool
mNeedsFlushCompleteNotification
;
}
;
}
}
#
endif
