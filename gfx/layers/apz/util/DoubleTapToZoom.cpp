#
include
"
DoubleTapToZoom
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIDOMHTMLLIElement
.
h
"
#
include
"
nsIDOMHTMLQuoteElement
.
h
"
#
include
"
nsIDOMWindow
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsStyleConsts
.
h
"
namespace
mozilla
{
namespace
layers
{
static
already_AddRefed
<
dom
:
:
Element
>
ElementFromPoint
(
const
nsCOMPtr
<
nsIPresShell
>
&
aShell
const
CSSPoint
&
aPoint
)
{
if
(
nsIFrame
*
rootFrame
=
aShell
-
>
GetRootFrame
(
)
)
{
if
(
nsIFrame
*
frame
=
nsLayoutUtils
:
:
GetFrameForPoint
(
rootFrame
CSSPoint
:
:
ToAppUnits
(
aPoint
)
nsLayoutUtils
:
:
IGNORE_PAINT_SUPPRESSION
|
nsLayoutUtils
:
:
IGNORE_ROOT_SCROLL_FRAME
)
)
{
while
(
frame
&
&
(
!
frame
-
>
GetContent
(
)
|
|
frame
-
>
GetContent
(
)
-
>
IsInAnonymousSubtree
(
)
)
)
{
frame
=
nsLayoutUtils
:
:
GetParentOrPlaceholderFor
(
frame
)
;
}
nsIContent
*
content
=
frame
-
>
GetContent
(
)
;
if
(
content
&
&
!
content
-
>
IsElement
(
)
)
{
content
=
content
-
>
GetParent
(
)
;
}
if
(
content
)
{
nsCOMPtr
<
dom
:
:
Element
>
result
=
content
-
>
AsElement
(
)
;
return
result
.
forget
(
)
;
}
}
}
return
nullptr
;
}
static
bool
ShouldZoomToElement
(
const
nsCOMPtr
<
dom
:
:
Element
>
&
aElement
)
{
if
(
nsIFrame
*
frame
=
aElement
-
>
GetPrimaryFrame
(
)
)
{
if
(
frame
-
>
GetDisplay
(
)
=
=
NS_STYLE_DISPLAY_INLINE
)
{
return
false
;
}
}
if
(
aElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
li
nsGkAtoms
:
:
q
)
)
{
return
false
;
}
return
true
;
}
static
bool
IsRectZoomedIn
(
const
CSSRect
&
aRect
const
CSSRect
&
aCompositedArea
)
{
CSSRect
overlap
=
aCompositedArea
.
Intersect
(
aRect
)
;
float
overlapArea
=
overlap
.
width
*
overlap
.
height
;
float
availHeight
=
std
:
:
min
(
aRect
.
width
*
aCompositedArea
.
height
/
aCompositedArea
.
width
aRect
.
height
)
;
float
showing
=
overlapArea
/
(
aRect
.
width
*
availHeight
)
;
float
ratioW
=
aRect
.
width
/
aCompositedArea
.
width
;
float
ratioH
=
aRect
.
height
/
aCompositedArea
.
height
;
return
showing
>
0
.
9
&
&
(
ratioW
>
0
.
9
|
|
ratioH
>
0
.
9
)
;
}
CSSRect
CalculateRectToZoomTo
(
const
nsCOMPtr
<
nsIDocument
>
&
aRootContentDocument
const
CSSPoint
&
aPoint
)
{
aRootContentDocument
-
>
FlushPendingNotifications
(
Flush_Layout
)
;
const
CSSRect
zoomOut
;
nsCOMPtr
<
nsIPresShell
>
shell
=
aRootContentDocument
-
>
GetShell
(
)
;
if
(
!
shell
)
{
return
zoomOut
;
}
nsIScrollableFrame
*
rootScrollFrame
=
shell
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
!
rootScrollFrame
)
{
return
zoomOut
;
}
nsCOMPtr
<
dom
:
:
Element
>
element
=
ElementFromPoint
(
shell
aPoint
)
;
if
(
!
element
)
{
return
zoomOut
;
}
while
(
element
&
&
!
ShouldZoomToElement
(
element
)
)
{
element
=
element
-
>
GetParentElement
(
)
;
}
if
(
!
element
)
{
return
zoomOut
;
}
FrameMetrics
metrics
=
nsLayoutUtils
:
:
CalculateBasicFrameMetrics
(
rootScrollFrame
)
;
CSSRect
compositedArea
(
metrics
.
GetScrollOffset
(
)
metrics
.
CalculateCompositedSizeInCssPixels
(
)
)
;
const
CSSCoord
margin
=
15
;
CSSRect
rect
=
nsLayoutUtils
:
:
GetBoundingContentRect
(
element
rootScrollFrame
)
;
if
(
!
rect
.
IsEmpty
(
)
&
&
compositedArea
.
width
>
0
.
0f
)
{
const
float
widthRatio
=
rect
.
width
/
compositedArea
.
width
;
float
targetHeight
=
compositedArea
.
height
*
widthRatio
;
if
(
widthRatio
<
0
.
9
&
&
targetHeight
<
rect
.
height
)
{
const
CSSPoint
scrollPoint
=
CSSPoint
:
:
FromAppUnits
(
rootScrollFrame
-
>
GetScrollPosition
(
)
)
;
float
newY
=
aPoint
.
y
+
scrollPoint
.
y
-
(
targetHeight
*
0
.
5f
)
;
if
(
(
newY
+
targetHeight
)
>
(
rect
.
y
+
rect
.
height
)
)
{
rect
.
y
+
=
rect
.
height
-
targetHeight
;
}
else
if
(
newY
>
rect
.
y
)
{
rect
.
y
=
newY
;
}
rect
.
height
=
targetHeight
;
}
}
rect
=
CSSRect
(
std
:
:
max
(
metrics
.
GetScrollableRect
(
)
.
x
rect
.
x
-
margin
)
rect
.
y
rect
.
width
+
2
*
margin
rect
.
height
)
;
rect
.
width
=
std
:
:
min
(
rect
.
width
metrics
.
GetScrollableRect
(
)
.
XMost
(
)
-
rect
.
x
)
;
if
(
IsRectZoomedIn
(
rect
compositedArea
)
)
{
return
zoomOut
;
}
CSSRect
rounded
(
rect
)
;
rounded
.
Round
(
)
;
CSSCoord
cssTapY
=
metrics
.
GetScrollOffset
(
)
.
y
+
aPoint
.
y
;
if
(
(
rect
.
height
>
rounded
.
height
)
&
&
(
cssTapY
>
rounded
.
y
+
(
rounded
.
height
*
1
.
2
)
)
)
{
rounded
.
y
=
cssTapY
-
(
rounded
.
height
/
2
)
;
}
return
rounded
;
}
}
}
