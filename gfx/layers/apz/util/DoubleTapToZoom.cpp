#
include
"
DoubleTapToZoom
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsTableCellFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
mozilla
/
ViewportUtils
.
h
"
namespace
mozilla
{
namespace
layers
{
namespace
{
using
FrameForPointOption
=
nsLayoutUtils
:
:
FrameForPointOption
;
static
bool
IsGeneratedContent
(
nsIContent
*
aContent
)
{
return
aContent
-
>
IsGeneratedContentContainerForBefore
(
)
|
|
aContent
-
>
IsGeneratedContentContainerForAfter
(
)
;
}
static
already_AddRefed
<
dom
:
:
Element
>
ElementFromPoint
(
const
RefPtr
<
PresShell
>
&
aPresShell
const
CSSPoint
&
aPoint
)
{
nsIFrame
*
rootFrame
=
aPresShell
-
>
GetRootFrame
(
)
;
if
(
!
rootFrame
)
{
return
nullptr
;
}
nsIFrame
*
frame
=
nsLayoutUtils
:
:
GetFrameForPoint
(
RelativeTo
{
rootFrame
ViewportType
:
:
Visual
}
CSSPoint
:
:
ToAppUnits
(
aPoint
)
{
{
FrameForPointOption
:
:
IgnorePaintSuppression
}
}
)
;
while
(
frame
&
&
(
!
frame
-
>
GetContent
(
)
|
|
(
frame
-
>
GetContent
(
)
-
>
IsInNativeAnonymousSubtree
(
)
&
&
!
IsGeneratedContent
(
frame
-
>
GetContent
(
)
)
)
)
)
{
frame
=
nsLayoutUtils
:
:
GetParentOrPlaceholderFor
(
frame
)
;
}
if
(
!
frame
)
{
return
nullptr
;
}
nsIContent
*
content
=
frame
-
>
GetContent
(
)
;
if
(
!
content
)
{
return
nullptr
;
}
if
(
dom
:
:
Element
*
element
=
content
-
>
GetAsElementOrParentElement
(
)
)
{
return
do_AddRef
(
element
)
;
}
return
nullptr
;
}
static
dom
:
:
Element
*
GetNearbyTableCell
(
const
nsCOMPtr
<
dom
:
:
Element
>
&
aElement
)
{
nsTableCellFrame
*
tableCell
=
do_QueryFrame
(
aElement
-
>
GetPrimaryFrame
(
)
)
;
if
(
tableCell
)
{
return
aElement
.
get
(
)
;
}
if
(
dom
:
:
Element
*
parent
=
aElement
-
>
GetFlattenedTreeParentElement
(
)
)
{
nsTableCellFrame
*
tableCell
=
do_QueryFrame
(
parent
-
>
GetPrimaryFrame
(
)
)
;
if
(
tableCell
)
{
return
parent
;
}
if
(
dom
:
:
Element
*
grandParent
=
parent
-
>
GetFlattenedTreeParentElement
(
)
)
{
tableCell
=
do_QueryFrame
(
grandParent
-
>
GetPrimaryFrame
(
)
)
;
if
(
tableCell
)
{
return
grandParent
;
}
}
}
return
nullptr
;
}
static
bool
ShouldZoomToElement
(
const
nsCOMPtr
<
dom
:
:
Element
>
&
aElement
const
RefPtr
<
dom
:
:
Document
>
&
aRootContentDocument
nsIScrollableFrame
*
aRootScrollFrame
const
FrameMetrics
&
aMetrics
)
{
if
(
nsIFrame
*
frame
=
aElement
-
>
GetPrimaryFrame
(
)
)
{
if
(
frame
-
>
StyleDisplay
(
)
-
>
IsInlineFlow
(
)
&
&
!
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eReplaced
)
)
{
return
false
;
}
}
if
(
aElement
-
>
OwnerDoc
(
)
=
=
aRootContentDocument
&
&
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
html
)
)
{
return
false
;
}
if
(
aElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
li
nsGkAtoms
:
:
q
)
)
{
return
false
;
}
if
(
dom
:
:
Element
*
tableCell
=
GetNearbyTableCell
(
aElement
)
)
{
CSSRect
rect
=
nsLayoutUtils
:
:
GetBoundingContentRect
(
tableCell
aRootScrollFrame
)
;
if
(
rect
.
width
<
0
.
3
*
aMetrics
.
GetScrollableRect
(
)
.
width
)
{
return
false
;
}
}
return
true
;
}
static
bool
RectHasAlmostSameZoomLevel
(
const
CSSRect
&
aRect
const
CSSRect
&
aCompositedArea
)
{
float
overlapArea
=
std
:
:
min
(
aRect
.
width
aCompositedArea
.
width
)
*
std
:
:
min
(
aRect
.
height
aCompositedArea
.
height
)
;
float
availHeight
=
std
:
:
min
(
aRect
.
Width
(
)
*
aCompositedArea
.
Height
(
)
/
aCompositedArea
.
Width
(
)
aRect
.
Height
(
)
)
;
float
showing
=
overlapArea
/
(
aRect
.
Width
(
)
*
availHeight
)
;
float
ratioW
=
aRect
.
Width
(
)
/
aCompositedArea
.
Width
(
)
;
float
ratioH
=
aRect
.
Height
(
)
/
aCompositedArea
.
Height
(
)
;
return
showing
>
0
.
9
&
&
(
ratioW
>
0
.
9
|
|
ratioH
>
0
.
9
)
;
}
}
static
CSSRect
AddHMargin
(
const
CSSRect
&
aRect
const
CSSCoord
&
aMargin
const
FrameMetrics
&
aMetrics
)
{
CSSRect
rect
=
CSSRect
(
std
:
:
max
(
aMetrics
.
GetScrollableRect
(
)
.
X
(
)
aRect
.
X
(
)
-
aMargin
)
aRect
.
Y
(
)
aRect
.
Width
(
)
+
2
*
aMargin
aRect
.
Height
(
)
)
;
rect
.
SetWidth
(
std
:
:
min
(
rect
.
Width
(
)
aMetrics
.
GetScrollableRect
(
)
.
XMost
(
)
-
rect
.
X
(
)
)
)
;
return
rect
;
}
static
CSSRect
AddVMargin
(
const
CSSRect
&
aRect
const
CSSCoord
&
aMargin
const
FrameMetrics
&
aMetrics
)
{
CSSRect
rect
=
CSSRect
(
aRect
.
X
(
)
std
:
:
max
(
aMetrics
.
GetScrollableRect
(
)
.
Y
(
)
aRect
.
Y
(
)
-
aMargin
)
aRect
.
Width
(
)
aRect
.
Height
(
)
+
2
*
aMargin
)
;
rect
.
SetHeight
(
std
:
:
min
(
rect
.
Height
(
)
aMetrics
.
GetScrollableRect
(
)
.
YMost
(
)
-
rect
.
Y
(
)
)
)
;
return
rect
;
}
static
bool
IsReplacedElement
(
const
nsCOMPtr
<
dom
:
:
Element
>
&
aElement
)
{
if
(
nsIFrame
*
frame
=
aElement
-
>
GetPrimaryFrame
(
)
)
{
if
(
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eReplaced
)
)
{
return
true
;
}
}
return
false
;
}
ZoomTarget
CalculateRectToZoomTo
(
const
RefPtr
<
dom
:
:
Document
>
&
aRootContentDocument
const
CSSPoint
&
aPoint
)
{
aRootContentDocument
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
const
CSSRect
zoomOut
;
RefPtr
<
PresShell
>
presShell
=
aRootContentDocument
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
ZoomTarget
{
zoomOut
CantZoomOutBehavior
:
:
ZoomIn
}
;
}
nsIScrollableFrame
*
rootScrollFrame
=
presShell
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
!
rootScrollFrame
)
{
return
ZoomTarget
{
zoomOut
CantZoomOutBehavior
:
:
ZoomIn
}
;
}
CSSPoint
documentRelativePoint
=
CSSPoint
:
:
FromAppUnits
(
ViewportUtils
:
:
VisualToLayout
(
CSSPoint
:
:
ToAppUnits
(
aPoint
)
presShell
)
)
+
CSSPoint
:
:
FromAppUnits
(
rootScrollFrame
-
>
GetScrollPosition
(
)
)
;
nsCOMPtr
<
dom
:
:
Element
>
element
=
ElementFromPoint
(
presShell
aPoint
)
;
if
(
!
element
)
{
return
ZoomTarget
{
zoomOut
CantZoomOutBehavior
:
:
ZoomIn
Nothing
(
)
Some
(
documentRelativePoint
)
}
;
}
FrameMetrics
metrics
=
nsLayoutUtils
:
:
CalculateBasicFrameMetrics
(
rootScrollFrame
)
;
while
(
element
&
&
!
ShouldZoomToElement
(
element
aRootContentDocument
rootScrollFrame
metrics
)
)
{
element
=
element
-
>
GetFlattenedTreeParentElement
(
)
;
}
if
(
!
element
)
{
return
ZoomTarget
{
zoomOut
CantZoomOutBehavior
:
:
ZoomIn
Nothing
(
)
Some
(
documentRelativePoint
)
}
;
}
CSSPoint
visualScrollOffset
=
metrics
.
GetVisualScrollOffset
(
)
;
CSSRect
compositedArea
(
visualScrollOffset
metrics
.
CalculateCompositedSizeInCssPixels
(
)
)
;
Maybe
<
CSSRect
>
nearestScrollClip
;
CSSRect
rect
=
nsLayoutUtils
:
:
GetBoundingContentRect
(
element
rootScrollFrame
&
nearestScrollClip
)
;
if
(
!
rect
.
Contains
(
documentRelativePoint
)
)
{
if
(
nsIFrame
*
scrolledFrame
=
rootScrollFrame
-
>
GetScrolledFrame
(
)
)
{
if
(
nsIFrame
*
f
=
element
-
>
GetPrimaryFrame
(
)
)
{
nsRect
overflowRect
=
f
-
>
ScrollableOverflowRect
(
)
;
nsLayoutUtils
:
:
TransformResult
res
=
nsLayoutUtils
:
:
TransformRect
(
f
scrolledFrame
overflowRect
)
;
MOZ_ASSERT
(
res
=
=
nsLayoutUtils
:
:
TRANSFORM_SUCCEEDED
|
|
res
=
=
nsLayoutUtils
:
:
NONINVERTIBLE_TRANSFORM
)
;
if
(
res
=
=
nsLayoutUtils
:
:
TRANSFORM_SUCCEEDED
)
{
CSSRect
overflowRectCSS
=
CSSRect
:
:
FromAppUnits
(
overflowRect
)
;
if
(
nearestScrollClip
.
isSome
(
)
)
{
overflowRectCSS
=
nearestScrollClip
-
>
Intersect
(
overflowRectCSS
)
;
}
if
(
overflowRectCSS
.
Contains
(
documentRelativePoint
)
)
{
rect
=
overflowRectCSS
;
}
}
}
}
}
CSSRect
elementBoundingRect
=
rect
;
bool
heightConstrained
=
false
;
if
(
!
rect
.
IsEmpty
(
)
&
&
compositedArea
.
Width
(
)
>
0
.
0f
&
&
compositedArea
.
Height
(
)
>
0
.
0f
)
{
const
float
widthRatio
=
rect
.
Width
(
)
/
compositedArea
.
Width
(
)
;
float
targetHeight
=
compositedArea
.
Height
(
)
*
widthRatio
;
if
(
IsReplacedElement
(
element
)
&
&
targetHeight
<
rect
.
Height
(
)
&
&
rect
.
Height
(
)
<
1
.
1
*
rect
.
Width
(
)
&
&
compositedArea
.
Width
(
)
>
=
compositedArea
.
Height
(
)
)
{
heightConstrained
=
true
;
float
targetWidth
=
rect
.
Height
(
)
*
compositedArea
.
Width
(
)
/
compositedArea
.
Height
(
)
;
MOZ_ASSERT
(
targetWidth
>
rect
.
Width
(
)
)
;
if
(
targetWidth
>
rect
.
Width
(
)
)
{
rect
.
x
-
=
(
targetWidth
-
rect
.
Width
(
)
)
/
2
;
rect
.
SetWidth
(
targetWidth
)
;
elementBoundingRect
=
rect
;
}
}
else
if
(
targetHeight
<
rect
.
Height
(
)
)
{
float
newY
=
documentRelativePoint
.
y
-
(
targetHeight
*
0
.
5f
)
;
if
(
(
newY
+
targetHeight
)
>
rect
.
YMost
(
)
)
{
rect
.
MoveByY
(
rect
.
Height
(
)
-
targetHeight
)
;
}
else
if
(
newY
>
rect
.
Y
(
)
)
{
rect
.
MoveToY
(
newY
)
;
}
rect
.
SetHeight
(
targetHeight
)
;
}
}
const
CSSCoord
margin
=
15
;
rect
=
AddHMargin
(
rect
margin
metrics
)
;
if
(
heightConstrained
)
{
rect
=
AddVMargin
(
rect
margin
metrics
)
;
}
if
(
RectHasAlmostSameZoomLevel
(
rect
compositedArea
)
)
{
return
ZoomTarget
{
zoomOut
CantZoomOutBehavior
:
:
ZoomIn
Nothing
(
)
Some
(
documentRelativePoint
)
}
;
}
elementBoundingRect
=
AddHMargin
(
elementBoundingRect
margin
metrics
)
;
elementBoundingRect
=
AddVMargin
(
elementBoundingRect
margin
metrics
)
;
rect
.
Round
(
)
;
elementBoundingRect
.
Round
(
)
;
return
ZoomTarget
{
rect
CantZoomOutBehavior
:
:
ZoomIn
Some
(
elementBoundingRect
)
Some
(
documentRelativePoint
)
}
;
}
}
}
