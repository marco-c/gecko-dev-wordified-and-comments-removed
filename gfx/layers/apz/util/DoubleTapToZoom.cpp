#
include
"
DoubleTapToZoom
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIDOMWindow
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsStyleConsts
.
h
"
namespace
mozilla
{
namespace
layers
{
namespace
{
using
FrameForPointOption
=
nsLayoutUtils
:
:
FrameForPointOption
;
static
already_AddRefed
<
dom
:
:
Element
>
ElementFromPoint
(
const
nsCOMPtr
<
nsIPresShell
>
&
aShell
const
CSSPoint
&
aPoint
)
{
nsIFrame
*
rootFrame
=
aShell
-
>
GetRootFrame
(
)
;
if
(
!
rootFrame
)
{
return
nullptr
;
}
nsIFrame
*
frame
=
nsLayoutUtils
:
:
GetFrameForPoint
(
rootFrame
CSSPoint
:
:
ToAppUnits
(
aPoint
)
{
FrameForPointOption
:
:
IgnorePaintSuppression
FrameForPointOption
:
:
IgnoreRootScrollFrame
}
)
;
while
(
frame
&
&
(
!
frame
-
>
GetContent
(
)
|
|
frame
-
>
GetContent
(
)
-
>
IsInAnonymousSubtree
(
)
)
)
{
frame
=
nsLayoutUtils
:
:
GetParentOrPlaceholderFor
(
frame
)
;
}
if
(
!
frame
)
{
return
nullptr
;
}
nsIContent
*
content
=
frame
-
>
GetContent
(
)
;
if
(
content
&
&
!
content
-
>
IsElement
(
)
)
{
content
=
content
-
>
GetParent
(
)
;
}
if
(
content
&
&
content
-
>
IsElement
(
)
)
{
nsCOMPtr
<
dom
:
:
Element
>
result
=
content
-
>
AsElement
(
)
;
return
result
.
forget
(
)
;
}
return
nullptr
;
}
static
bool
ShouldZoomToElement
(
const
nsCOMPtr
<
dom
:
:
Element
>
&
aElement
)
{
if
(
nsIFrame
*
frame
=
aElement
-
>
GetPrimaryFrame
(
)
)
{
if
(
frame
-
>
GetDisplay
(
)
=
=
StyleDisplay
:
:
Inline
)
{
return
false
;
}
}
if
(
aElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
li
nsGkAtoms
:
:
q
)
)
{
return
false
;
}
return
true
;
}
static
bool
IsRectZoomedIn
(
const
CSSRect
&
aRect
const
CSSRect
&
aCompositedArea
)
{
CSSRect
overlap
=
aCompositedArea
.
Intersect
(
aRect
)
;
float
overlapArea
=
overlap
.
Width
(
)
*
overlap
.
Height
(
)
;
float
availHeight
=
std
:
:
min
(
aRect
.
Width
(
)
*
aCompositedArea
.
Height
(
)
/
aCompositedArea
.
Width
(
)
aRect
.
Height
(
)
)
;
float
showing
=
overlapArea
/
(
aRect
.
Width
(
)
*
availHeight
)
;
float
ratioW
=
aRect
.
Width
(
)
/
aCompositedArea
.
Width
(
)
;
float
ratioH
=
aRect
.
Height
(
)
/
aCompositedArea
.
Height
(
)
;
return
showing
>
0
.
9
&
&
(
ratioW
>
0
.
9
|
|
ratioH
>
0
.
9
)
;
}
}
CSSRect
CalculateRectToZoomTo
(
const
RefPtr
<
dom
:
:
Document
>
&
aRootContentDocument
const
CSSPoint
&
aPoint
)
{
aRootContentDocument
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
const
CSSRect
zoomOut
;
nsCOMPtr
<
nsIPresShell
>
shell
=
aRootContentDocument
-
>
GetShell
(
)
;
if
(
!
shell
)
{
return
zoomOut
;
}
nsIScrollableFrame
*
rootScrollFrame
=
shell
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
!
rootScrollFrame
)
{
return
zoomOut
;
}
nsCOMPtr
<
dom
:
:
Element
>
element
=
ElementFromPoint
(
shell
aPoint
)
;
if
(
!
element
)
{
return
zoomOut
;
}
while
(
element
&
&
!
ShouldZoomToElement
(
element
)
)
{
element
=
element
-
>
GetParentElement
(
)
;
}
if
(
!
element
)
{
return
zoomOut
;
}
FrameMetrics
metrics
=
nsLayoutUtils
:
:
CalculateBasicFrameMetrics
(
rootScrollFrame
)
;
CSSRect
compositedArea
(
CSSPoint
:
:
FromAppUnits
(
shell
-
>
GetVisualViewportOffset
(
)
)
metrics
.
CalculateCompositedSizeInCssPixels
(
)
)
;
const
CSSCoord
margin
=
15
;
CSSRect
rect
=
nsLayoutUtils
:
:
GetBoundingContentRect
(
element
rootScrollFrame
)
;
if
(
!
rect
.
IsEmpty
(
)
&
&
compositedArea
.
Width
(
)
>
0
.
0f
)
{
const
float
widthRatio
=
rect
.
Width
(
)
/
compositedArea
.
Width
(
)
;
float
targetHeight
=
compositedArea
.
Height
(
)
*
widthRatio
;
if
(
widthRatio
<
0
.
9
&
&
targetHeight
<
rect
.
Height
(
)
)
{
const
CSSPoint
scrollPoint
=
CSSPoint
:
:
FromAppUnits
(
rootScrollFrame
-
>
GetScrollPosition
(
)
)
;
float
newY
=
aPoint
.
y
+
scrollPoint
.
y
-
(
targetHeight
*
0
.
5f
)
;
if
(
(
newY
+
targetHeight
)
>
rect
.
YMost
(
)
)
{
rect
.
MoveByY
(
rect
.
Height
(
)
-
targetHeight
)
;
}
else
if
(
newY
>
rect
.
Y
(
)
)
{
rect
.
MoveToY
(
newY
)
;
}
rect
.
SetHeight
(
targetHeight
)
;
}
}
rect
=
CSSRect
(
std
:
:
max
(
metrics
.
GetScrollableRect
(
)
.
X
(
)
rect
.
X
(
)
-
margin
)
rect
.
Y
(
)
rect
.
Width
(
)
+
2
*
margin
rect
.
Height
(
)
)
;
rect
.
SetWidth
(
std
:
:
min
(
rect
.
Width
(
)
metrics
.
GetScrollableRect
(
)
.
XMost
(
)
-
rect
.
X
(
)
)
)
;
if
(
IsRectZoomedIn
(
rect
compositedArea
)
)
{
return
zoomOut
;
}
CSSRect
rounded
(
rect
)
;
rounded
.
Round
(
)
;
CSSCoord
cssTapY
=
metrics
.
GetScrollOffset
(
)
.
y
+
aPoint
.
y
;
if
(
(
rect
.
Height
(
)
>
rounded
.
Height
(
)
)
&
&
(
cssTapY
>
rounded
.
Y
(
)
+
(
rounded
.
Height
(
)
*
1
.
2
)
)
)
{
rounded
.
MoveToY
(
cssTapY
-
(
rounded
.
Height
(
)
/
2
)
)
;
}
return
rounded
;
}
}
}
