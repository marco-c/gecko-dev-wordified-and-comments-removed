#
include
"
CheckerboardReportService
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
CheckerboardReportServiceBinding
.
h
"
#
include
"
mozilla
/
gfx
/
GPUParent
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessManager
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
namespace
mozilla
{
namespace
layers
{
StaticRefPtr
<
CheckerboardEventStorage
>
CheckerboardEventStorage
:
:
sInstance
;
already_AddRefed
<
CheckerboardEventStorage
>
CheckerboardEventStorage
:
:
GetInstance
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
sInstance
)
{
sInstance
=
new
CheckerboardEventStorage
(
)
;
ClearOnShutdown
(
&
sInstance
)
;
}
RefPtr
<
CheckerboardEventStorage
>
instance
=
sInstance
.
get
(
)
;
return
instance
.
forget
(
)
;
}
void
CheckerboardEventStorage
:
:
Report
(
uint32_t
aSeverity
const
std
:
:
string
&
aLog
)
{
if
(
!
NS_IsMainThread
(
)
)
{
RefPtr
<
Runnable
>
task
=
NS_NewRunnableFunction
(
"
layers
:
:
CheckerboardEventStorage
:
:
Report
"
[
aSeverity
aLog
]
(
)
-
>
void
{
CheckerboardEventStorage
:
:
Report
(
aSeverity
aLog
)
;
}
)
;
NS_DispatchToMainThread
(
task
.
forget
(
)
)
;
return
;
}
if
(
XRE_IsGPUProcess
(
)
)
{
if
(
gfx
:
:
GPUParent
*
gpu
=
gfx
:
:
GPUParent
:
:
GetSingleton
(
)
)
{
nsCString
log
(
aLog
.
c_str
(
)
)
;
Unused
<
<
gpu
-
>
SendReportCheckerboard
(
aSeverity
log
)
;
}
return
;
}
RefPtr
<
CheckerboardEventStorage
>
storage
=
GetInstance
(
)
;
storage
-
>
ReportCheckerboard
(
aSeverity
aLog
)
;
}
void
CheckerboardEventStorage
:
:
ReportCheckerboard
(
uint32_t
aSeverity
const
std
:
:
string
&
aLog
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aSeverity
=
=
0
)
{
return
;
}
CheckerboardReport
severe
(
aSeverity
JS_Now
(
)
aLog
)
;
CheckerboardReport
recent
;
for
(
int
i
=
0
;
i
<
SEVERITY_MAX_INDEX
;
i
+
+
)
{
if
(
mCheckerboardReports
[
i
]
.
mSeverity
>
=
severe
.
mSeverity
)
{
continue
;
}
recent
=
mCheckerboardReports
[
SEVERITY_MAX_INDEX
-
1
]
;
for
(
int
j
=
SEVERITY_MAX_INDEX
-
1
;
j
>
i
;
j
-
-
)
{
mCheckerboardReports
[
j
]
=
mCheckerboardReports
[
j
-
1
]
;
}
mCheckerboardReports
[
i
]
=
severe
;
severe
.
mSeverity
=
0
;
break
;
}
if
(
severe
.
mSeverity
)
{
MOZ_ASSERT
(
recent
.
mSeverity
=
=
0
"
recent
should
be
empty
here
"
)
;
recent
=
severe
;
}
if
(
recent
.
mSeverity
=
=
0
)
{
return
;
}
for
(
int
i
=
SEVERITY_MAX_INDEX
;
i
<
RECENT_MAX_INDEX
;
i
+
+
)
{
if
(
mCheckerboardReports
[
i
]
.
mTimestamp
>
=
recent
.
mTimestamp
)
{
continue
;
}
for
(
int
j
=
RECENT_MAX_INDEX
-
1
;
j
>
i
;
j
-
-
)
{
mCheckerboardReports
[
j
]
=
mCheckerboardReports
[
j
-
1
]
;
}
mCheckerboardReports
[
i
]
=
recent
;
break
;
}
}
void
CheckerboardEventStorage
:
:
GetReports
(
nsTArray
<
dom
:
:
CheckerboardReport
>
&
aOutReports
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
int
i
=
0
;
i
<
RECENT_MAX_INDEX
;
i
+
+
)
{
CheckerboardReport
&
r
=
mCheckerboardReports
[
i
]
;
if
(
r
.
mSeverity
=
=
0
)
{
continue
;
}
dom
:
:
CheckerboardReport
report
;
report
.
mSeverity
.
Construct
(
)
=
r
.
mSeverity
;
report
.
mTimestamp
.
Construct
(
)
=
r
.
mTimestamp
/
1000
;
report
.
mLog
.
Construct
(
)
=
NS_ConvertUTF8toUTF16
(
r
.
mLog
.
c_str
(
)
r
.
mLog
.
size
(
)
)
;
report
.
mReason
.
Construct
(
)
=
(
i
<
SEVERITY_MAX_INDEX
)
?
dom
:
:
CheckerboardReason
:
:
Severe
:
dom
:
:
CheckerboardReason
:
:
Recent
;
aOutReports
.
AppendElement
(
report
)
;
}
}
}
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
CheckerboardReportService
mParent
)
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
CheckerboardReportService
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
CheckerboardReportService
Release
)
bool
CheckerboardReportService
:
:
IsEnabled
(
JSContext
*
aCtx
JSObject
*
aGlobal
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
false
;
}
return
nsContentUtils
:
:
IsSystemCaller
(
aCtx
)
|
|
nsContentUtils
:
:
IsSpecificAboutPage
(
aGlobal
"
about
:
checkerboard
"
)
;
}
already_AddRefed
<
CheckerboardReportService
>
CheckerboardReportService
:
:
Constructor
(
const
dom
:
:
GlobalObject
&
aGlobal
ErrorResult
&
aRv
)
{
RefPtr
<
CheckerboardReportService
>
ces
=
new
CheckerboardReportService
(
aGlobal
.
GetAsSupports
(
)
)
;
return
ces
.
forget
(
)
;
}
CheckerboardReportService
:
:
CheckerboardReportService
(
nsISupports
*
aParent
)
:
mParent
(
aParent
)
{
}
JSObject
*
CheckerboardReportService
:
:
WrapObject
(
JSContext
*
aCtx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
CheckerboardReportService_Binding
:
:
Wrap
(
aCtx
this
aGivenProto
)
;
}
nsISupports
*
CheckerboardReportService
:
:
GetParentObject
(
)
{
return
mParent
;
}
void
CheckerboardReportService
:
:
GetReports
(
nsTArray
<
dom
:
:
CheckerboardReport
>
&
aOutReports
)
{
RefPtr
<
mozilla
:
:
layers
:
:
CheckerboardEventStorage
>
instance
=
mozilla
:
:
layers
:
:
CheckerboardEventStorage
:
:
GetInstance
(
)
;
MOZ_ASSERT
(
instance
)
;
instance
-
>
GetReports
(
aOutReports
)
;
}
bool
CheckerboardReportService
:
:
IsRecordingEnabled
(
)
const
{
return
StaticPrefs
:
:
apz_record_checkerboarding
(
)
;
}
void
CheckerboardReportService
:
:
SetRecordingEnabled
(
bool
aEnabled
)
{
Preferences
:
:
SetBool
(
"
apz
.
record_checkerboarding
"
aEnabled
)
;
}
void
CheckerboardReportService
:
:
FlushActiveReports
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
gfx
:
:
GPUProcessManager
*
gpu
=
gfx
:
:
GPUProcessManager
:
:
Get
(
)
;
if
(
gpu
&
&
gpu
-
>
NotifyGpuObservers
(
"
APZ
:
FlushActiveCheckerboard
"
)
)
{
return
;
}
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
obsSvc
)
;
if
(
obsSvc
)
{
obsSvc
-
>
NotifyObservers
(
nullptr
"
APZ
:
FlushActiveCheckerboard
"
nullptr
)
;
}
}
}
}
