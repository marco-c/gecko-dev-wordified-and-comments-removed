"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
paint_listener
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
new
URL
(
"
apz_test_utils
.
js
"
gTestPath
)
.
href
this
)
;
Services
.
scriptloader
.
loadSubScript
(
new
URL
(
"
apz_test_native_event_utils
.
js
"
gTestPath
)
.
href
this
)
;
Services
.
scriptloader
.
loadSubScript
(
new
URL
(
"
helper_browser_test_utils
.
js
"
gTestPath
)
.
href
this
)
;
add_task
(
(
)
=
>
{
registerCleanupFunction
(
(
)
=
>
{
delete
window
.
waitForAllPaintsFlushed
;
delete
window
.
waitForAllPaints
;
delete
window
.
promiseAllPaintsDone
;
}
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
apz
.
popups
.
enabled
"
true
]
[
"
apz
.
popups_without_remote
.
enabled
"
true
]
]
}
)
;
}
)
;
async
function
twoRafsInContent
(
browser
)
{
await
SpecialPowers
.
spawn
(
browser
[
]
async
function
(
)
{
await
new
Promise
(
r
=
>
content
.
requestAnimationFrame
(
(
)
=
>
content
.
requestAnimationFrame
(
r
)
)
)
;
}
)
;
}
async
function
runTest
(
aTestFile
)
{
const
nullPrincipal
=
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
}
)
;
const
tab
=
gBrowser
.
addTab
(
"
about
:
blank
"
{
forceNotRemote
:
true
triggeringPrincipal
:
nullPrincipal
}
)
;
gBrowser
.
selectedTab
=
tab
;
const
browser
=
tab
.
linkedBrowser
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
browser
.
isConnected
)
;
await
promiseApzFlushedRepaints
(
)
;
await
waitUntilApzStable
(
)
;
let
loaded
=
BrowserTestUtils
.
browserLoaded
(
browser
)
;
const
url_of_test_file
=
getRootDirectory
(
gTestPath
)
+
aTestFile
;
BrowserTestUtils
.
startLoadingURIString
(
browser
url_of_test_file
)
;
await
loaded
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
(
)
=
>
{
Assert
.
ok
(
SpecialPowers
.
isMainProcess
(
)
)
;
Assert
.
ok
(
SpecialPowers
.
wrap
(
content
)
.
docShell
.
isTopLevelContentDocShell
)
;
}
)
;
await
promiseApzFlushedRepaints
(
)
;
await
waitUntilApzStable
(
)
;
let
contentWin
=
browser
.
contentWindow
;
const
adiv
=
contentWin
.
document
.
createElement
(
"
div
"
)
;
adiv
.
style
.
transform
=
"
translateX
(
1px
)
"
;
contentWin
.
document
.
body
.
appendChild
(
adiv
)
;
const
popupset
=
contentWin
.
document
.
createXULElement
(
"
popupset
"
)
;
adiv
.
appendChild
(
popupset
)
;
const
popup
=
contentWin
.
document
.
createXULElement
(
"
menupopup
"
)
;
popup
.
style
.
position
=
"
fixed
"
;
popup
.
style
.
background
=
"
blue
"
;
popup
.
setAttribute
(
"
noautohide
"
true
)
;
const
scroller
=
contentWin
.
document
.
createElement
(
"
div
"
)
;
scroller
.
style
=
"
width
:
100px
;
height
:
100px
;
overflow
:
auto
;
background
-
color
:
white
;
"
;
popup
.
appendChild
(
scroller
)
;
const
spacer
=
contentWin
.
document
.
createElement
(
"
div
"
)
;
spacer
.
style
=
"
width
:
200px
;
height
:
200px
;
background
-
color
:
green
;
"
;
scroller
.
appendChild
(
spacer
)
;
popupset
.
appendChild
(
popup
)
;
const
popupshownPromise
=
new
Promise
(
resolve
=
>
{
popup
.
addEventListener
(
"
popupshown
"
resolve
(
)
)
;
}
)
;
popup
.
openPopupAtScreen
(
contentWin
.
mozInnerScreenX
contentWin
.
mozInnerScreenY
true
)
;
await
popupshownPromise
;
await
ensureApzReadyForPopup
(
popup
contentWin
)
;
await
promiseApzFlushedRepaints
(
popup
)
;
AccessibilityUtils
.
setEnv
(
{
mustHaveAccessibleRule
:
false
}
)
;
const
popupRect
=
popup
.
getBoundingClientRect
(
)
;
ok
(
popupRect
.
width
>
10
"
non
-
zero
popup
width
"
)
;
ok
(
popupRect
.
height
>
10
"
non
-
zero
popup
height
"
)
;
await
synthesizeNativeMouseEventWithAPZ
(
{
type
:
"
click
"
target
:
popup
offsetX
:
10
offsetY
:
10
}
)
;
await
twoRafsInContent
(
browser
)
;
AccessibilityUtils
.
resetEnv
(
)
;
const
popuphiddenPromise
=
new
Promise
(
resolve
=
>
{
popup
.
addEventListener
(
"
popuphidden
"
resolve
(
)
)
;
}
)
;
popup
.
hidePopup
(
)
;
await
popuphiddenPromise
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
add_task
(
async
(
)
=
>
{
await
runTest
(
"
helper_popup_menu_in_parent_process_content
.
html
"
)
;
}
)
;
