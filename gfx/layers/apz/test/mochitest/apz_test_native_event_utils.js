function
getResolution
(
)
{
let
resolution
=
-
1
;
resolution
=
SpecialPowers
.
getDOMWindowUtils
(
window
.
top
)
.
getResolution
(
)
;
return
resolution
;
}
function
getPlatform
(
)
{
if
(
navigator
.
platform
.
indexOf
(
"
Win
"
)
=
=
0
)
{
return
"
windows
"
;
}
if
(
navigator
.
platform
.
indexOf
(
"
Mac
"
)
=
=
0
)
{
return
"
mac
"
;
}
if
(
navigator
.
appVersion
.
includes
(
"
Android
"
)
)
{
return
"
android
"
;
}
if
(
navigator
.
platform
.
indexOf
(
"
Linux
"
)
=
=
0
)
{
return
"
linux
"
;
}
return
"
unknown
"
;
}
function
nativeVerticalWheelEventMsg
(
)
{
switch
(
getPlatform
(
)
)
{
case
"
windows
"
:
return
0x020a
;
case
"
mac
"
:
return
0
;
case
"
linux
"
:
return
4
;
}
throw
new
Error
(
"
Native
wheel
events
not
supported
on
platform
"
+
getPlatform
(
)
)
;
}
function
nativeHorizontalWheelEventMsg
(
)
{
switch
(
getPlatform
(
)
)
{
case
"
windows
"
:
return
0x020e
;
case
"
mac
"
:
return
0
;
case
"
linux
"
:
return
4
;
}
throw
new
Error
(
"
Native
wheel
events
not
supported
on
platform
"
+
getPlatform
(
)
)
;
}
function
windowForTarget
(
aTarget
)
{
if
(
aTarget
instanceof
Window
)
{
return
aTarget
;
}
return
aTarget
.
ownerDocument
.
defaultView
;
}
function
elementForTarget
(
aTarget
)
{
if
(
aTarget
instanceof
Window
)
{
return
aTarget
.
document
.
documentElement
;
}
return
aTarget
;
}
function
utilsForTarget
(
aTarget
)
{
return
SpecialPowers
.
getDOMWindowUtils
(
windowForTarget
(
aTarget
)
)
;
}
function
nativeScrollUnits
(
aTarget
aDimen
)
{
switch
(
getPlatform
(
)
)
{
case
"
linux
"
:
{
var
targetWindow
=
windowForTarget
(
aTarget
)
;
var
targetElement
=
elementForTarget
(
aTarget
)
;
var
lineHeight
=
targetWindow
.
getComputedStyle
(
targetElement
)
[
"
font
-
size
"
]
;
return
aDimen
/
(
parseInt
(
lineHeight
)
*
3
)
;
}
}
return
aDimen
;
}
function
nativeMouseDownEventMsg
(
)
{
switch
(
getPlatform
(
)
)
{
case
"
windows
"
:
return
2
;
case
"
mac
"
:
return
1
;
case
"
linux
"
:
return
4
;
case
"
android
"
:
return
5
;
}
throw
new
Error
(
"
Native
mouse
-
down
events
not
supported
on
platform
"
+
getPlatform
(
)
)
;
}
function
nativeMouseMoveEventMsg
(
)
{
switch
(
getPlatform
(
)
)
{
case
"
windows
"
:
return
1
;
case
"
mac
"
:
return
5
;
case
"
linux
"
:
return
3
;
case
"
android
"
:
return
7
;
}
throw
new
Error
(
"
Native
mouse
-
move
events
not
supported
on
platform
"
+
getPlatform
(
)
)
;
}
function
nativeMouseUpEventMsg
(
)
{
switch
(
getPlatform
(
)
)
{
case
"
windows
"
:
return
4
;
case
"
mac
"
:
return
2
;
case
"
linux
"
:
return
7
;
case
"
android
"
:
return
6
;
}
throw
new
Error
(
"
Native
mouse
-
up
events
not
supported
on
platform
"
+
getPlatform
(
)
)
;
}
function
getBoundingClientRectRelativeToVisualViewport
(
aElement
)
{
let
utils
=
SpecialPowers
.
getDOMWindowUtils
(
window
)
;
var
rect
=
aElement
.
getBoundingClientRect
(
)
;
var
offsetX
=
{
}
offsetY
=
{
}
;
utils
.
getVisualViewportOffsetRelativeToLayoutViewport
(
offsetX
offsetY
)
;
rect
.
x
-
=
offsetX
.
value
;
rect
.
y
-
=
offsetY
.
value
;
return
rect
;
}
function
getTargetOrigin
(
aTarget
)
{
let
origin
=
{
left
:
0
top
:
0
}
;
if
(
aTarget
instanceof
Window
)
{
return
origin
;
}
let
rect
=
aTarget
.
getBoundingClientRect
(
)
;
origin
.
left
+
=
rect
.
left
;
origin
.
top
+
=
rect
.
top
;
while
(
aTarget
.
ownerDocument
.
defaultView
.
frameElement
)
{
let
iframe
=
aTarget
.
ownerDocument
.
defaultView
.
frameElement
;
let
style
=
iframe
.
ownerDocument
.
defaultView
.
getComputedStyle
(
iframe
)
;
let
borderLeft
=
parseFloat
(
style
.
borderLeftWidth
)
|
|
0
;
let
borderTop
=
parseFloat
(
style
.
borderTopWidth
)
|
|
0
;
let
paddingLeft
=
parseFloat
(
style
.
paddingLeft
)
|
|
0
;
let
paddingTop
=
parseFloat
(
style
.
paddingTop
)
|
|
0
;
rect
=
iframe
.
getBoundingClientRect
(
)
;
origin
.
left
+
=
rect
.
left
+
borderLeft
+
paddingLeft
;
origin
.
top
+
=
rect
.
top
+
borderTop
+
paddingTop
;
aTarget
=
iframe
;
}
var
offsetX
=
{
}
offsetY
=
{
}
;
let
rootUtils
=
SpecialPowers
.
getDOMWindowUtils
(
window
.
top
)
;
rootUtils
.
getVisualViewportOffsetRelativeToLayoutViewport
(
offsetX
offsetY
)
;
origin
.
left
-
=
offsetX
.
value
;
origin
.
top
-
=
offsetY
.
value
;
return
origin
;
}
function
coordinatesRelativeToScreen
(
aX
aY
aTarget
)
{
var
utils
=
SpecialPowers
.
getDOMWindowUtils
(
window
)
;
var
deviceScale
=
utils
.
screenPixelsPerCSSPixel
;
var
deviceScaleNoOverride
=
utils
.
screenPixelsPerCSSPixelNoOverride
;
var
resolution
=
getResolution
(
)
;
var
origin
=
getTargetOrigin
(
aTarget
)
;
return
{
x
:
window
.
top
.
mozInnerScreenX
*
deviceScaleNoOverride
+
(
origin
.
left
+
aX
)
*
resolution
*
deviceScale
y
:
window
.
top
.
mozInnerScreenY
*
deviceScaleNoOverride
+
(
origin
.
top
+
aY
)
*
resolution
*
deviceScale
}
;
}
function
rectRelativeToScreen
(
aElement
)
{
var
targetWindow
=
aElement
.
ownerDocument
.
defaultView
;
var
scale
=
targetWindow
.
devicePixelRatio
;
var
rect
=
aElement
.
getBoundingClientRect
(
)
;
return
{
x
:
(
targetWindow
.
mozInnerScreenX
+
rect
.
left
)
*
scale
y
:
(
targetWindow
.
mozInnerScreenY
+
rect
.
top
)
*
scale
w
:
rect
.
width
*
scale
h
:
rect
.
height
*
scale
}
;
}
function
synthesizeNativeWheel
(
aTarget
aX
aY
aDeltaX
aDeltaY
aObserver
)
{
var
pt
=
coordinatesRelativeToScreen
(
aX
aY
aTarget
)
;
if
(
aDeltaX
&
&
aDeltaY
)
{
throw
new
Error
(
"
Simultaneous
wheeling
of
horizontal
and
vertical
is
not
supported
on
all
platforms
.
"
)
;
}
aDeltaX
=
nativeScrollUnits
(
aTarget
aDeltaX
)
;
aDeltaY
=
nativeScrollUnits
(
aTarget
aDeltaY
)
;
var
msg
=
aDeltaX
?
nativeHorizontalWheelEventMsg
(
)
:
nativeVerticalWheelEventMsg
(
)
;
var
utils
=
utilsForTarget
(
aTarget
)
;
var
element
=
elementForTarget
(
aTarget
)
;
utils
.
sendNativeMouseScrollEvent
(
pt
.
x
pt
.
y
msg
aDeltaX
aDeltaY
0
0
0
element
aObserver
)
;
return
true
;
}
function
synthesizeNativeWheelAndWaitForObserver
(
aElement
aX
aY
aDeltaX
aDeltaY
aCallback
)
{
var
observer
=
{
observe
(
aSubject
aTopic
aData
)
{
if
(
aCallback
&
&
aTopic
=
=
"
mousescrollevent
"
)
{
setTimeout
(
aCallback
0
)
;
}
}
}
;
return
synthesizeNativeWheel
(
aElement
aX
aY
aDeltaX
aDeltaY
observer
)
;
}
function
synthesizeNativeWheelAndWaitForWheelEvent
(
aTarget
aX
aY
aDeltaX
aDeltaY
aCallback
)
{
var
targetWindow
=
windowForTarget
(
aTarget
)
;
targetWindow
.
addEventListener
(
"
wheel
"
function
(
e
)
{
if
(
aCallback
)
{
setTimeout
(
aCallback
0
)
;
}
}
{
once
:
true
}
)
;
return
synthesizeNativeWheel
(
aTarget
aX
aY
aDeltaX
aDeltaY
)
;
}
function
synthesizeNativeWheelAndWaitForScrollEvent
(
aTarget
aX
aY
aDeltaX
aDeltaY
aCallback
)
{
var
targetWindow
=
windowForTarget
(
aTarget
)
;
targetWindow
.
addEventListener
(
"
scroll
"
function
(
)
{
setTimeout
(
aCallback
0
)
;
}
{
capture
:
true
once
:
true
}
)
;
return
synthesizeNativeWheel
(
aTarget
aX
aY
aDeltaX
aDeltaY
)
;
}
function
synthesizeNativeMouseMove
(
aTarget
aX
aY
)
{
var
pt
=
coordinatesRelativeToScreen
(
aX
aY
aTarget
)
;
var
utils
=
utilsForTarget
(
aTarget
)
;
var
element
=
elementForTarget
(
aTarget
)
;
utils
.
sendNativeMouseEvent
(
pt
.
x
pt
.
y
nativeMouseMoveEventMsg
(
)
0
element
)
;
return
true
;
}
function
synthesizeNativeMouseMoveAndWaitForMoveEvent
(
aTarget
aX
aY
aCallback
)
{
var
targetWindow
=
windowForTarget
(
aTarget
)
;
targetWindow
.
addEventListener
(
"
mousemove
"
function
(
e
)
{
setTimeout
(
aCallback
0
)
;
}
{
once
:
true
}
)
;
return
synthesizeNativeMouseMove
(
aTarget
aX
aY
)
;
}
function
synthesizeNativeTouch
(
aTarget
aX
aY
aType
aObserver
=
null
aTouchId
=
0
)
{
var
pt
=
coordinatesRelativeToScreen
(
aX
aY
aTarget
)
;
var
utils
=
utilsForTarget
(
aTarget
)
;
utils
.
sendNativeTouchPoint
(
aTouchId
aType
pt
.
x
pt
.
y
1
90
aObserver
)
;
return
true
;
}
function
*
synthesizeNativeTouchSequences
(
aTarget
aPositions
aObserver
=
null
aTouchIds
=
[
0
]
)
{
var
lastNonNullValue
=
-
1
;
var
yields
=
0
;
for
(
let
i
=
0
;
i
<
aPositions
.
length
;
i
+
+
)
{
if
(
aPositions
[
i
]
=
=
null
)
{
yields
+
+
;
continue
;
}
if
(
aPositions
[
i
]
.
length
!
=
aTouchIds
.
length
)
{
throw
new
Error
(
aPositions
[
{
i
}
]
did
not
have
the
expected
number
of
positions
;
+
expected
{
aTouchIds
.
length
}
touch
points
but
found
{
aPositions
[
i
]
.
length
}
)
;
}
for
(
let
j
=
0
;
j
<
aTouchIds
.
length
;
j
+
+
)
{
if
(
aPositions
[
i
]
[
j
]
!
=
null
)
{
lastNonNullValue
=
(
i
-
yields
)
*
aTouchIds
.
length
+
j
;
}
}
}
if
(
lastNonNullValue
<
0
)
{
throw
new
Error
(
"
All
values
in
positions
array
were
null
!
"
)
;
}
var
allNullRow
=
new
Array
(
aTouchIds
.
length
)
;
allNullRow
.
fill
(
null
)
;
aPositions
.
push
(
allNullRow
)
;
var
lastSynthesizeCall
=
lastNonNullValue
+
aTouchIds
.
length
;
var
currentPositions
=
new
Array
(
aTouchIds
.
length
)
;
currentPositions
.
fill
(
null
)
;
yields
=
0
;
for
(
let
i
=
0
;
i
<
aPositions
.
length
;
i
+
+
)
{
if
(
aPositions
[
i
]
=
=
null
)
{
yields
+
+
;
yield
i
;
continue
;
}
for
(
let
j
=
0
;
j
<
aTouchIds
.
length
;
j
+
+
)
{
if
(
aPositions
[
i
]
[
j
]
=
=
null
)
{
if
(
currentPositions
[
j
]
=
=
null
)
{
}
else
{
var
thisIndex
=
(
i
-
yields
)
*
aTouchIds
.
length
+
j
;
var
observer
=
lastSynthesizeCall
=
=
thisIndex
?
aObserver
:
null
;
synthesizeNativeTouch
(
aTarget
currentPositions
[
j
]
.
x
currentPositions
[
j
]
.
y
SpecialPowers
.
DOMWindowUtils
.
TOUCH_REMOVE
observer
aTouchIds
[
j
]
)
;
currentPositions
[
j
]
=
null
;
}
}
else
{
synthesizeNativeTouch
(
aTarget
aPositions
[
i
]
[
j
]
.
x
aPositions
[
i
]
[
j
]
.
y
SpecialPowers
.
DOMWindowUtils
.
TOUCH_CONTACT
null
aTouchIds
[
j
]
)
;
currentPositions
[
j
]
=
aPositions
[
i
]
[
j
]
;
}
}
}
return
true
;
}
function
synthesizeNativeTouchDrag
(
aTarget
aX
aY
aDeltaX
aDeltaY
aObserver
=
null
aTouchId
=
0
)
{
var
steps
=
Math
.
max
(
Math
.
abs
(
aDeltaX
)
Math
.
abs
(
aDeltaY
)
)
;
var
positions
=
[
[
{
x
:
aX
y
:
aY
}
]
]
;
for
(
var
i
=
1
;
i
<
steps
;
i
+
+
)
{
var
dx
=
i
*
(
aDeltaX
/
steps
)
;
var
dy
=
i
*
(
aDeltaY
/
steps
)
;
var
pos
=
{
x
:
aX
+
dx
y
:
aY
+
dy
}
;
positions
.
push
(
[
pos
]
)
;
}
positions
.
push
(
[
{
x
:
aX
+
aDeltaX
y
:
aY
+
aDeltaY
}
]
)
;
var
continuation
=
synthesizeNativeTouchSequences
(
aTarget
positions
aObserver
[
aTouchId
]
)
;
var
yielded
=
continuation
.
next
(
)
;
while
(
!
yielded
.
done
)
{
yielded
=
continuation
.
next
(
)
;
}
return
yielded
.
value
;
}
function
synthesizeNativeTap
(
aElement
aX
aY
aObserver
=
null
)
{
var
pt
=
coordinatesRelativeToScreen
(
aX
aY
aElement
)
;
var
utils
=
SpecialPowers
.
getDOMWindowUtils
(
aElement
.
ownerDocument
.
defaultView
)
;
utils
.
sendNativeTouchTap
(
pt
.
x
pt
.
y
false
aObserver
)
;
return
true
;
}
function
synthesizeNativeMouseEvent
(
aTarget
aX
aY
aType
aObserver
=
null
)
{
var
pt
=
coordinatesRelativeToScreen
(
aX
aY
aTarget
)
;
var
utils
=
utilsForTarget
(
aTarget
)
;
var
element
=
elementForTarget
(
aTarget
)
;
utils
.
sendNativeMouseEvent
(
pt
.
x
pt
.
y
aType
0
element
aObserver
)
;
return
true
;
}
function
synthesizeNativeClick
(
aElement
aX
aY
aObserver
=
null
)
{
var
pt
=
coordinatesRelativeToScreen
(
aX
aY
aElement
)
;
var
utils
=
SpecialPowers
.
getDOMWindowUtils
(
aElement
.
ownerDocument
.
defaultView
)
;
utils
.
sendNativeMouseEvent
(
pt
.
x
pt
.
y
nativeMouseDownEventMsg
(
)
0
aElement
function
(
)
{
utils
.
sendNativeMouseEvent
(
pt
.
x
pt
.
y
nativeMouseUpEventMsg
(
)
0
aElement
aObserver
)
;
}
)
;
return
true
;
}
function
promiseNativeClick
(
aElement
aX
aY
)
{
return
new
Promise
(
resolve
=
>
{
synthesizeNativeClick
(
aElement
aX
aY
resolve
)
;
}
)
;
}
function
synthesizeNativeClickAndWaitForClickEvent
(
aElement
aX
aY
aCallback
)
{
var
targetWindow
=
windowForTarget
(
aElement
)
;
targetWindow
.
addEventListener
(
"
click
"
function
(
e
)
{
setTimeout
(
aCallback
0
)
;
}
{
capture
:
true
once
:
true
}
)
;
return
synthesizeNativeClick
(
aElement
aX
aY
)
;
}
function
moveMouseAndScrollWheelOver
(
target
dx
dy
testDriver
waitForScroll
=
true
)
{
return
synthesizeNativeMouseMoveAndWaitForMoveEvent
(
target
dx
dy
function
(
)
{
if
(
waitForScroll
)
{
synthesizeNativeWheelAndWaitForScrollEvent
(
target
dx
dy
0
-
10
testDriver
)
;
}
else
{
synthesizeNativeWheelAndWaitForWheelEvent
(
target
dx
dy
0
-
10
testDriver
)
;
}
}
)
;
}
function
promiseMoveMouseAndScrollWheelOver
(
target
dx
dy
waitForScroll
=
true
)
{
return
new
Promise
(
resolve
=
>
{
moveMouseAndScrollWheelOver
(
target
dx
dy
resolve
waitForScroll
)
;
}
)
;
}
function
*
dragVerticalScrollbar
(
target
testDriver
distance
=
20
increment
=
5
)
{
var
targetElement
=
elementForTarget
(
target
)
;
var
w
=
{
}
h
=
{
}
;
utilsForTarget
(
target
)
.
getScrollbarSizes
(
targetElement
w
h
)
;
var
verticalScrollbarWidth
=
w
.
value
;
if
(
verticalScrollbarWidth
=
=
0
)
{
return
false
;
}
var
upArrowHeight
=
verticalScrollbarWidth
;
var
mouseX
=
targetElement
.
clientWidth
+
verticalScrollbarWidth
/
2
;
var
mouseY
=
upArrowHeight
+
5
;
dump
(
"
Starting
drag
at
"
+
mouseX
+
"
"
+
mouseY
+
"
from
top
-
left
of
#
"
+
targetElement
.
id
+
"
\
n
"
)
;
yield
synthesizeNativeMouseEvent
(
target
mouseX
mouseY
nativeMouseMoveEventMsg
(
)
testDriver
)
;
yield
synthesizeNativeMouseEvent
(
target
mouseX
mouseY
nativeMouseDownEventMsg
(
)
testDriver
)
;
for
(
var
y
=
increment
;
y
<
distance
;
y
+
=
increment
)
{
yield
synthesizeNativeMouseEvent
(
target
mouseX
mouseY
+
y
nativeMouseMoveEventMsg
(
)
testDriver
)
;
}
yield
synthesizeNativeMouseEvent
(
target
mouseX
mouseY
+
distance
nativeMouseMoveEventMsg
(
)
testDriver
)
;
return
function
*
(
)
{
dump
(
"
Finishing
drag
of
#
"
+
targetElement
.
id
+
"
\
n
"
)
;
yield
synthesizeNativeMouseEvent
(
target
mouseX
mouseY
+
distance
nativeMouseUpEventMsg
(
)
testDriver
)
;
}
;
}
function
*
pinchZoomInTouchSequence
(
focusX
focusY
)
{
var
zoom_in
=
[
[
{
x
:
focusX
-
25
y
:
focusY
-
50
}
{
x
:
focusX
+
25
y
:
focusY
+
50
}
]
[
{
x
:
focusX
-
30
y
:
focusY
-
80
}
{
x
:
focusX
+
30
y
:
focusY
+
80
}
]
[
{
x
:
focusX
-
35
y
:
focusY
-
110
}
{
x
:
focusX
+
40
y
:
focusY
+
110
}
]
[
{
x
:
focusX
-
40
y
:
focusY
-
140
}
{
x
:
focusX
+
45
y
:
focusY
+
140
}
]
[
{
x
:
focusX
-
45
y
:
focusY
-
170
}
{
x
:
focusX
+
50
y
:
focusY
+
170
}
]
[
{
x
:
focusX
-
50
y
:
focusY
-
200
}
{
x
:
focusX
+
55
y
:
focusY
+
200
}
]
]
;
var
touchIds
=
[
0
1
]
;
yield
*
synthesizeNativeTouchSequences
(
document
.
body
zoom_in
null
touchIds
)
;
}
function
*
pinchZoomOutTouchSequenceAtCenter
(
)
{
const
deltaX
=
window
.
visualViewport
.
width
/
16
;
const
deltaY
=
window
.
visualViewport
.
height
/
16
;
const
centerX
=
window
.
visualViewport
.
pageLeft
+
window
.
visualViewport
.
width
/
2
;
const
centerY
=
window
.
visualViewport
.
pageTop
+
window
.
visualViewport
.
height
/
2
;
var
zoom_out
=
[
[
{
x
:
centerX
-
(
deltaX
*
6
)
y
:
centerY
-
(
deltaY
*
6
)
}
{
x
:
centerX
+
(
deltaX
*
6
)
y
:
centerY
+
(
deltaY
*
6
)
}
]
[
{
x
:
centerX
-
(
deltaX
*
5
)
y
:
centerY
-
(
deltaY
*
5
)
}
{
x
:
centerX
+
(
deltaX
*
5
)
y
:
centerY
+
(
deltaY
*
5
)
}
]
[
{
x
:
centerX
-
(
deltaX
*
4
)
y
:
centerY
-
(
deltaY
*
4
)
}
{
x
:
centerX
+
(
deltaX
*
4
)
y
:
centerY
+
(
deltaY
*
4
)
}
]
[
{
x
:
centerX
-
(
deltaX
*
3
)
y
:
centerY
-
(
deltaY
*
3
)
}
{
x
:
centerX
+
(
deltaX
*
3
)
y
:
centerY
+
(
deltaY
*
3
)
}
]
[
{
x
:
centerX
-
(
deltaX
*
2
)
y
:
centerY
-
(
deltaY
*
2
)
}
{
x
:
centerX
+
(
deltaX
*
2
)
y
:
centerY
+
(
deltaY
*
2
)
}
]
[
{
x
:
centerX
-
(
deltaX
*
1
)
y
:
centerY
-
(
deltaY
*
1
)
}
{
x
:
centerX
+
(
deltaX
*
1
)
y
:
centerY
+
(
deltaY
*
1
)
}
]
]
;
var
touchIds
=
[
0
1
]
;
yield
*
synthesizeNativeTouchSequences
(
document
.
body
zoom_out
null
touchIds
)
;
}
function
promiseTopic
(
aTopic
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
SpecialPowers
.
Services
.
obs
.
addObserver
(
function
observer
(
subject
topic
data
)
{
try
{
SpecialPowers
.
Services
.
obs
.
removeObserver
(
observer
topic
)
;
resolve
(
[
subject
data
]
)
;
}
catch
(
ex
)
{
SpecialPowers
.
Services
.
obs
.
removeObserver
(
observer
topic
)
;
reject
(
ex
)
;
}
}
aTopic
)
;
}
)
;
}
async
function
pinchZoomInWithTouch
(
focusX
focusY
)
{
let
transformEndPromise
=
promiseTopic
(
"
APZ
:
TransformEnd
"
)
;
let
generator
=
pinchZoomInTouchSequence
(
focusX
focusY
)
;
while
(
true
)
{
let
yieldResult
=
generator
.
next
(
)
;
if
(
yieldResult
.
done
)
{
break
;
}
}
await
transformEndPromise
;
}
async
function
pinchZoomOutWithTouchAtCenter
(
)
{
let
transformEndPromise
=
promiseTopic
(
"
APZ
:
TransformEnd
"
)
;
let
generator
=
pinchZoomOutTouchSequenceAtCenter
(
)
;
while
(
true
)
{
let
yieldResult
=
generator
.
next
(
)
;
if
(
yieldResult
.
done
)
{
break
;
}
}
await
transformEndPromise
;
}
