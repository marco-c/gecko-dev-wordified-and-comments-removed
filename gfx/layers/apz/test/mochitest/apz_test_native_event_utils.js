function
getResolution
(
)
{
let
resolution
=
-
1
;
resolution
=
SpecialPowers
.
getDOMWindowUtils
(
window
.
top
)
.
getResolution
(
)
;
return
resolution
;
}
function
getPlatform
(
)
{
if
(
navigator
.
platform
.
indexOf
(
"
Win
"
)
=
=
0
)
{
return
"
windows
"
;
}
if
(
navigator
.
platform
.
indexOf
(
"
Mac
"
)
=
=
0
)
{
return
"
mac
"
;
}
if
(
navigator
.
appVersion
.
includes
(
"
Android
"
)
)
{
return
"
android
"
;
}
if
(
navigator
.
platform
.
indexOf
(
"
Linux
"
)
=
=
0
)
{
return
"
linux
"
;
}
return
"
unknown
"
;
}
function
nativeVerticalWheelEventMsg
(
)
{
switch
(
getPlatform
(
)
)
{
case
"
windows
"
:
return
0x020a
;
case
"
mac
"
:
var
useWheelCodepath
=
SpecialPowers
.
getBoolPref
(
"
apz
.
test
.
mac
.
synth_wheel_input
"
false
)
;
return
useWheelCodepath
?
0
:
1
;
case
"
linux
"
:
return
4
;
}
throw
new
Error
(
"
Native
wheel
events
not
supported
on
platform
"
+
getPlatform
(
)
)
;
}
function
nativeHorizontalWheelEventMsg
(
)
{
switch
(
getPlatform
(
)
)
{
case
"
windows
"
:
return
0x020e
;
case
"
mac
"
:
return
0
;
case
"
linux
"
:
return
4
;
}
throw
new
Error
(
"
Native
wheel
events
not
supported
on
platform
"
+
getPlatform
(
)
)
;
}
function
windowForTarget
(
aTarget
)
{
if
(
aTarget
instanceof
Window
)
{
return
aTarget
;
}
return
aTarget
.
ownerDocument
.
defaultView
;
}
function
elementForTarget
(
aTarget
)
{
if
(
aTarget
instanceof
Window
)
{
return
aTarget
.
document
.
documentElement
;
}
return
aTarget
;
}
function
utilsForTarget
(
aTarget
)
{
return
SpecialPowers
.
getDOMWindowUtils
(
windowForTarget
(
aTarget
)
)
;
}
function
nativeScrollUnits
(
aTarget
aDimen
)
{
switch
(
getPlatform
(
)
)
{
case
"
linux
"
:
{
var
targetWindow
=
windowForTarget
(
aTarget
)
;
var
targetElement
=
elementForTarget
(
aTarget
)
;
var
lineHeight
=
targetWindow
.
getComputedStyle
(
targetElement
)
[
"
font
-
size
"
]
;
return
aDimen
/
(
parseInt
(
lineHeight
)
*
3
)
;
}
}
return
aDimen
;
}
function
parseNativeModifiers
(
aModifiers
aWindow
=
window
)
{
let
modifiers
=
0
;
if
(
aModifiers
.
capsLockKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_CAPS_LOCK
;
}
if
(
aModifiers
.
numLockKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_NUM_LOCK
;
}
if
(
aModifiers
.
shiftKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_SHIFT_LEFT
;
}
if
(
aModifiers
.
shiftRightKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_SHIFT_RIGHT
;
}
if
(
aModifiers
.
ctrlKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_CONTROL_LEFT
;
}
if
(
aModifiers
.
ctrlRightKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_CONTROL_RIGHT
;
}
if
(
aModifiers
.
altKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_ALT_LEFT
;
}
if
(
aModifiers
.
altRightKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_ALT_RIGHT
;
}
if
(
aModifiers
.
metaKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_COMMAND_LEFT
;
}
if
(
aModifiers
.
metaRightKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_COMMAND_RIGHT
;
}
if
(
aModifiers
.
helpKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_HELP
;
}
if
(
aModifiers
.
fnKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_FUNCTION
;
}
if
(
aModifiers
.
numericKeyPadKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_NUMERIC_KEY_PAD
;
}
if
(
aModifiers
.
accelKey
)
{
modifiers
|
=
_EU_isMac
(
aWindow
)
?
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_COMMAND_LEFT
:
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_CONTROL_LEFT
;
}
if
(
aModifiers
.
accelRightKey
)
{
modifiers
|
=
_EU_isMac
(
aWindow
)
?
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_COMMAND_RIGHT
:
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_CONTROL_RIGHT
;
}
if
(
aModifiers
.
altGrKey
)
{
modifiers
|
=
_EU_isMac
(
aWindow
)
?
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_ALT_LEFT
:
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_ALT_GRAPH
;
}
return
modifiers
;
}
function
getBoundingClientRectRelativeToVisualViewport
(
aElement
)
{
let
utils
=
SpecialPowers
.
getDOMWindowUtils
(
window
)
;
var
rect
=
aElement
.
getBoundingClientRect
(
)
;
var
offsetX
=
{
}
offsetY
=
{
}
;
utils
.
getVisualViewportOffsetRelativeToLayoutViewport
(
offsetX
offsetY
)
;
rect
.
x
-
=
offsetX
.
value
;
rect
.
y
-
=
offsetY
.
value
;
return
rect
;
}
function
getTargetOrigin
(
aTarget
)
{
const
rect
=
getTargetRect
(
aTarget
)
;
return
{
left
:
rect
.
left
top
:
rect
.
top
}
;
}
function
getTargetRect
(
aTarget
)
{
let
rect
=
{
left
:
0
top
:
0
width
:
0
height
:
0
}
;
if
(
aTarget
instanceof
Window
)
{
return
rect
;
}
const
boundingClientRect
=
aTarget
.
getBoundingClientRect
(
)
;
rect
.
left
=
boundingClientRect
.
left
;
rect
.
top
=
boundingClientRect
.
top
;
rect
.
width
=
boundingClientRect
.
width
;
rect
.
height
=
boundingClientRect
.
height
;
while
(
aTarget
.
ownerDocument
.
defaultView
.
frameElement
)
{
const
iframe
=
aTarget
.
ownerDocument
.
defaultView
.
frameElement
;
const
style
=
iframe
.
ownerDocument
.
defaultView
.
getComputedStyle
(
iframe
)
;
const
borderLeft
=
parseFloat
(
style
.
borderLeftWidth
)
|
|
0
;
const
borderTop
=
parseFloat
(
style
.
borderTopWidth
)
|
|
0
;
const
borderRight
=
parseFloat
(
style
.
borderRightWidth
)
|
|
0
;
const
borderBottom
=
parseFloat
(
style
.
borderBottomWidth
)
|
|
0
;
const
paddingLeft
=
parseFloat
(
style
.
paddingLeft
)
|
|
0
;
const
paddingTop
=
parseFloat
(
style
.
paddingTop
)
|
|
0
;
const
paddingRight
=
parseFloat
(
style
.
paddingRight
)
|
|
0
;
const
paddingBottom
=
parseFloat
(
style
.
paddingBottom
)
|
|
0
;
const
iframeRect
=
iframe
.
getBoundingClientRect
(
)
;
rect
.
left
+
=
iframeRect
.
left
+
borderLeft
+
paddingLeft
;
rect
.
top
+
=
iframeRect
.
top
+
borderTop
+
paddingTop
;
if
(
rect
.
left
+
rect
.
width
>
iframeRect
.
right
-
borderRight
-
paddingRight
)
{
rect
.
width
=
Math
.
max
(
iframeRect
.
right
-
borderRight
-
paddingRight
-
rect
.
left
0
)
;
}
if
(
rect
.
top
+
rect
.
height
>
iframeRect
.
bottom
-
borderBottom
-
paddingBottom
)
{
rect
.
height
=
Math
.
max
(
iframeRect
.
bottom
-
borderBottom
-
paddingBottom
-
rect
.
top
0
)
;
}
aTarget
=
iframe
;
}
var
offsetX
=
{
}
offsetY
=
{
}
;
let
rootUtils
=
SpecialPowers
.
getDOMWindowUtils
(
window
.
top
)
;
rootUtils
.
getVisualViewportOffsetRelativeToLayoutViewport
(
offsetX
offsetY
)
;
rect
.
left
-
=
offsetX
.
value
;
rect
.
top
-
=
offsetY
.
value
;
return
rect
;
}
function
coordinatesRelativeToScreen
(
aParams
)
{
const
{
target
offsetX
offsetY
atCenter
}
=
aParams
;
const
utils
=
SpecialPowers
.
getDOMWindowUtils
(
window
)
;
const
deviceScale
=
utils
.
screenPixelsPerCSSPixel
;
const
deviceScaleNoOverride
=
utils
.
screenPixelsPerCSSPixelNoOverride
;
const
resolution
=
getResolution
(
)
;
const
rect
=
getTargetRect
(
target
)
;
return
{
x
:
window
.
top
.
mozInnerScreenX
*
deviceScaleNoOverride
+
(
rect
.
left
+
(
atCenter
?
rect
.
width
/
2
:
offsetX
)
)
*
resolution
*
deviceScale
y
:
window
.
top
.
mozInnerScreenY
*
deviceScaleNoOverride
+
(
rect
.
top
+
(
atCenter
?
rect
.
height
/
2
:
offsetY
)
)
*
resolution
*
deviceScale
}
;
}
function
rectRelativeToScreen
(
aElement
)
{
var
targetWindow
=
aElement
.
ownerDocument
.
defaultView
;
var
scale
=
targetWindow
.
devicePixelRatio
;
var
rect
=
aElement
.
getBoundingClientRect
(
)
;
return
{
x
:
(
targetWindow
.
mozInnerScreenX
+
rect
.
left
)
*
scale
y
:
(
targetWindow
.
mozInnerScreenY
+
rect
.
top
)
*
scale
w
:
rect
.
width
*
scale
h
:
rect
.
height
*
scale
}
;
}
function
synthesizeNativeWheel
(
aTarget
aX
aY
aDeltaX
aDeltaY
aObserver
)
{
var
pt
=
coordinatesRelativeToScreen
(
{
offsetX
:
aX
offsetY
:
aY
target
:
aTarget
}
)
;
if
(
aDeltaX
&
&
aDeltaY
)
{
throw
new
Error
(
"
Simultaneous
wheeling
of
horizontal
and
vertical
is
not
supported
on
all
platforms
.
"
)
;
}
aDeltaX
=
nativeScrollUnits
(
aTarget
aDeltaX
)
;
aDeltaY
=
nativeScrollUnits
(
aTarget
aDeltaY
)
;
var
msg
=
aDeltaX
?
nativeHorizontalWheelEventMsg
(
)
:
nativeVerticalWheelEventMsg
(
)
;
var
utils
=
utilsForTarget
(
aTarget
)
;
var
element
=
elementForTarget
(
aTarget
)
;
utils
.
sendNativeMouseScrollEvent
(
pt
.
x
pt
.
y
msg
aDeltaX
aDeltaY
0
0
0
element
aObserver
)
;
return
true
;
}
function
synthesizeNativeWheelAndWaitForObserver
(
aElement
aX
aY
aDeltaX
aDeltaY
aCallback
)
{
var
observer
=
{
observe
(
aSubject
aTopic
aData
)
{
if
(
aCallback
&
&
aTopic
=
=
"
mousescrollevent
"
)
{
setTimeout
(
aCallback
0
)
;
}
}
}
;
return
synthesizeNativeWheel
(
aElement
aX
aY
aDeltaX
aDeltaY
observer
)
;
}
function
synthesizeNativeWheelAndWaitForWheelEvent
(
aTarget
aX
aY
aDeltaX
aDeltaY
aCallback
)
{
let
p
=
promiseNativeWheelAndWaitForWheelEvent
(
aTarget
aX
aY
aDeltaX
aDeltaY
)
;
if
(
aCallback
)
{
p
.
then
(
aCallback
)
;
}
return
true
;
}
function
promiseNativeWheelAndWaitForWheelEvent
(
aTarget
aX
aY
aDeltaX
aDeltaY
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
var
targetWindow
=
windowForTarget
(
aTarget
)
;
targetWindow
.
addEventListener
(
"
wheel
"
function
(
e
)
{
setTimeout
(
resolve
0
)
;
}
{
once
:
true
}
)
;
try
{
synthesizeNativeWheel
(
aTarget
aX
aY
aDeltaX
aDeltaY
)
;
}
catch
(
e
)
{
reject
(
)
;
}
}
)
;
}
function
synthesizeNativeWheelAndWaitForScrollEvent
(
aTarget
aX
aY
aDeltaX
aDeltaY
aCallback
)
{
promiseNativeWheelAndWaitForScrollEvent
(
aTarget
aX
aY
aDeltaX
aDeltaY
)
.
then
(
aCallback
)
;
return
true
;
}
function
promiseNativeWheelAndWaitForScrollEvent
(
aTarget
aX
aY
aDeltaX
aDeltaY
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
var
targetWindow
=
windowForTarget
(
aTarget
)
;
targetWindow
.
addEventListener
(
"
scroll
"
function
(
)
{
setTimeout
(
resolve
0
)
;
}
{
capture
:
true
once
:
true
}
)
;
try
{
synthesizeNativeWheel
(
aTarget
aX
aY
aDeltaX
aDeltaY
)
;
}
catch
(
e
)
{
reject
(
)
;
}
}
)
;
}
function
synthesizeNativeTouch
(
aTarget
aX
aY
aType
aObserver
=
null
aTouchId
=
0
)
{
var
pt
=
coordinatesRelativeToScreen
(
{
offsetX
:
aX
offsetY
:
aY
target
:
aTarget
}
)
;
var
utils
=
utilsForTarget
(
aTarget
)
;
utils
.
sendNativeTouchPoint
(
aTouchId
aType
pt
.
x
pt
.
y
1
90
aObserver
)
;
return
true
;
}
function
synthesizeNativeTouchSequences
(
aTarget
aPositions
aObserver
=
null
aTouchIds
=
[
0
]
)
{
var
lastNonNullValue
=
-
1
;
for
(
let
i
=
0
;
i
<
aPositions
.
length
;
i
+
+
)
{
if
(
aPositions
[
i
]
=
=
null
)
{
throw
new
Error
(
aPositions
[
{
i
}
]
was
unexpectedly
null
)
;
}
if
(
aPositions
[
i
]
.
length
!
=
aTouchIds
.
length
)
{
throw
new
Error
(
aPositions
[
{
i
}
]
did
not
have
the
expected
number
of
positions
;
+
expected
{
aTouchIds
.
length
}
touch
points
but
found
{
aPositions
[
i
]
.
length
}
)
;
}
for
(
let
j
=
0
;
j
<
aTouchIds
.
length
;
j
+
+
)
{
if
(
aPositions
[
i
]
[
j
]
!
=
null
)
{
lastNonNullValue
=
i
*
aTouchIds
.
length
+
j
;
aPositions
[
i
]
[
j
]
=
coordinatesRelativeToScreen
(
{
offsetX
:
aPositions
[
i
]
[
j
]
.
x
offsetY
:
aPositions
[
i
]
[
j
]
.
y
target
:
aTarget
}
)
;
}
}
}
if
(
lastNonNullValue
<
0
)
{
throw
new
Error
(
"
All
values
in
positions
array
were
null
!
"
)
;
}
var
allNullRow
=
new
Array
(
aTouchIds
.
length
)
;
allNullRow
.
fill
(
null
)
;
aPositions
.
push
(
allNullRow
)
;
var
lastSynthesizeCall
=
lastNonNullValue
+
aTouchIds
.
length
;
var
currentPositions
=
new
Array
(
aTouchIds
.
length
)
;
currentPositions
.
fill
(
null
)
;
var
utils
=
utilsForTarget
(
aTarget
)
;
for
(
let
i
=
0
;
i
<
aPositions
.
length
;
i
+
+
)
{
for
(
let
j
=
0
;
j
<
aTouchIds
.
length
;
j
+
+
)
{
if
(
aPositions
[
i
]
[
j
]
=
=
null
)
{
if
(
currentPositions
[
j
]
=
=
null
)
{
}
else
{
var
thisIndex
=
i
*
aTouchIds
.
length
+
j
;
var
observer
=
lastSynthesizeCall
=
=
thisIndex
?
aObserver
:
null
;
utils
.
sendNativeTouchPoint
(
aTouchIds
[
j
]
SpecialPowers
.
DOMWindowUtils
.
TOUCH_REMOVE
currentPositions
[
j
]
.
x
currentPositions
[
j
]
.
y
1
90
observer
)
;
currentPositions
[
j
]
=
null
;
}
}
else
{
utils
.
sendNativeTouchPoint
(
aTouchIds
[
j
]
SpecialPowers
.
DOMWindowUtils
.
TOUCH_CONTACT
aPositions
[
i
]
[
j
]
.
x
aPositions
[
i
]
[
j
]
.
y
1
90
null
)
;
currentPositions
[
j
]
=
aPositions
[
i
]
[
j
]
;
}
}
}
return
true
;
}
function
synthesizeNativeTouchDrag
(
aTarget
aX
aY
aDeltaX
aDeltaY
aObserver
=
null
aTouchId
=
0
)
{
var
steps
=
Math
.
max
(
Math
.
abs
(
aDeltaX
)
Math
.
abs
(
aDeltaY
)
)
;
var
positions
=
[
[
{
x
:
aX
y
:
aY
}
]
]
;
for
(
var
i
=
1
;
i
<
steps
;
i
+
+
)
{
var
dx
=
i
*
(
aDeltaX
/
steps
)
;
var
dy
=
i
*
(
aDeltaY
/
steps
)
;
var
pos
=
{
x
:
aX
+
dx
y
:
aY
+
dy
}
;
positions
.
push
(
[
pos
]
)
;
}
positions
.
push
(
[
{
x
:
aX
+
aDeltaX
y
:
aY
+
aDeltaY
}
]
)
;
return
synthesizeNativeTouchSequences
(
aTarget
positions
aObserver
[
aTouchId
]
)
;
}
function
promiseNativeTouchDrag
(
aTarget
aX
aY
aDeltaX
aDeltaY
aTouchId
=
0
)
{
return
new
Promise
(
resolve
=
>
{
synthesizeNativeTouchDrag
(
aTarget
aX
aY
aDeltaX
aDeltaY
resolve
aTouchId
)
;
}
)
;
}
function
synthesizeNativeTap
(
aElement
aX
aY
aObserver
=
null
)
{
var
pt
=
coordinatesRelativeToScreen
(
{
offsetX
:
aX
offsetY
:
aY
target
:
aElement
}
)
;
var
utils
=
SpecialPowers
.
getDOMWindowUtils
(
aElement
.
ownerDocument
.
defaultView
)
;
utils
.
sendNativeTouchTap
(
pt
.
x
pt
.
y
false
aObserver
)
;
return
true
;
}
function
synthesizeNativeMouseEventWithAPZ
(
aParams
aObserver
=
null
)
{
if
(
aParams
.
win
!
=
=
undefined
)
{
throw
Error
(
"
Are
you
trying
to
use
EventUtils
'
API
?
win
won
'
t
be
used
with
synthesizeNativeMouseClickWithAPZ
.
"
)
;
}
const
{
type
target
offsetX
offsetY
atCenter
screenX
screenY
modifiers
=
{
}
}
=
aParams
;
if
(
atCenter
)
{
if
(
offsetX
!
=
undefined
|
|
offsetY
!
=
undefined
)
{
throw
Error
(
atCenter
is
specified
but
offsetX
(
{
offsetX
}
)
and
/
or
offsetY
(
{
offsetY
}
)
are
also
specified
)
;
}
if
(
screenX
!
=
undefined
|
|
screenY
!
=
undefined
)
{
throw
Error
(
atCenter
is
specified
but
screenX
(
{
screenX
}
)
and
/
or
screenY
(
{
screenY
}
)
are
also
specified
)
;
}
}
else
if
(
offsetX
!
=
undefined
&
&
offsetY
!
=
undefined
)
{
if
(
screenX
!
=
undefined
|
|
screenY
!
=
undefined
)
{
throw
Error
(
offsetX
/
Y
are
specified
but
screenX
(
{
screenX
}
)
and
/
or
screenY
(
{
screenY
}
)
are
also
specified
)
;
}
}
else
if
(
screenX
!
=
undefined
&
&
screenY
!
=
undefined
)
{
if
(
offsetX
!
=
undefined
|
|
offsetY
!
=
undefined
)
{
throw
Error
(
screenX
/
Y
are
specified
but
offsetX
(
{
offsetX
}
)
and
/
or
offsetY
(
{
offsetY
}
)
are
also
specified
)
;
}
}
const
pt
=
(
(
)
=
>
{
if
(
screenX
!
=
undefined
)
{
return
{
x
:
screenX
y
:
screenY
}
;
}
return
coordinatesRelativeToScreen
(
{
offsetX
offsetY
atCenter
target
}
)
;
}
)
(
)
;
const
utils
=
utilsForTarget
(
target
)
;
const
element
=
elementForTarget
(
target
)
;
const
modifierFlags
=
parseNativeModifiers
(
modifiers
)
;
if
(
type
=
=
=
"
click
"
)
{
utils
.
sendNativeMouseEvent
(
pt
.
x
pt
.
y
utils
.
NATIVE_MOUSE_MESSAGE_BUTTON_DOWN
0
modifierFlags
element
function
(
)
{
utils
.
sendNativeMouseEvent
(
pt
.
x
pt
.
y
utils
.
NATIVE_MOUSE_MESSAGE_BUTTON_UP
0
modifierFlags
element
aObserver
)
;
}
)
;
return
;
}
utils
.
sendNativeMouseEvent
(
pt
.
x
pt
.
y
(
(
)
=
>
{
switch
(
type
)
{
case
"
mousedown
"
:
return
utils
.
NATIVE_MOUSE_MESSAGE_BUTTON_DOWN
;
case
"
mouseup
"
:
return
utils
.
NATIVE_MOUSE_MESSAGE_BUTTON_UP
;
case
"
mousemove
"
:
return
utils
.
NATIVE_MOUSE_MESSAGE_MOVE
;
default
:
throw
Error
(
Invalid
type
is
specified
:
{
type
}
)
;
}
}
)
(
)
0
modifierFlags
element
aObserver
)
;
}
function
promiseNativeMouseEventWithAPZ
(
aParams
)
{
return
new
Promise
(
resolve
=
>
synthesizeNativeMouseEventWithAPZ
(
aParams
resolve
)
)
;
}
function
synthesizeNativeMouseEventWithAPZAndWaitForEvent
(
aParams
aCallback
=
null
)
{
const
targetWindow
=
windowForTarget
(
aParams
.
target
)
;
const
eventType
=
aParams
.
eventTypeToWait
|
|
aParams
.
type
;
targetWindow
.
addEventListener
(
eventType
function
(
e
)
{
setTimeout
(
aCallback
0
)
;
}
{
capture
:
true
once
:
true
}
)
;
return
synthesizeNativeMouseEventWithAPZ
(
aParams
)
;
}
function
promiseNativeMouseEventWithAPZAndWaitForEvent
(
aParams
)
{
return
new
Promise
(
resolve
=
>
{
synthesizeNativeMouseEventWithAPZAndWaitForEvent
(
aParams
resolve
)
;
}
)
;
}
function
moveMouseAndScrollWheelOver
(
target
dx
dy
testDriver
waitForScroll
=
true
scrollDelta
=
10
)
{
promiseMoveMouseAndScrollWheelOver
(
target
dx
dy
waitForScroll
scrollDelta
)
.
then
(
testDriver
)
;
return
true
;
}
function
promiseMoveMouseAndScrollWheelOver
(
target
dx
dy
waitForScroll
=
true
scrollDelta
=
10
)
{
let
p
=
promiseNativeMouseEventWithAPZAndWaitForEvent
(
{
type
:
"
mousemove
"
target
offsetX
:
dx
offsetY
:
dy
}
)
;
if
(
waitForScroll
)
{
p
=
p
.
then
(
(
)
=
>
promiseNativeWheelAndWaitForScrollEvent
(
target
dx
dy
0
-
scrollDelta
)
)
;
}
else
{
p
=
p
.
then
(
(
)
=
>
promiseNativeWheelAndWaitForWheelEvent
(
target
dx
dy
0
-
scrollDelta
)
)
;
}
return
p
;
}
async
function
promiseVerticalScrollbarDrag
(
target
distance
=
20
increment
=
5
scaleFactor
=
1
)
{
var
targetElement
=
elementForTarget
(
target
)
;
var
w
=
{
}
h
=
{
}
;
utilsForTarget
(
target
)
.
getScrollbarSizes
(
targetElement
w
h
)
;
var
verticalScrollbarWidth
=
w
.
value
;
if
(
verticalScrollbarWidth
=
=
0
)
{
return
null
;
}
var
upArrowHeight
=
verticalScrollbarWidth
;
var
mouseX
=
targetElement
.
clientWidth
+
verticalScrollbarWidth
/
2
;
var
mouseY
=
upArrowHeight
+
5
;
mouseX
*
=
scaleFactor
;
mouseY
*
=
scaleFactor
;
dump
(
"
Starting
drag
at
"
+
mouseX
+
"
"
+
mouseY
+
"
from
top
-
left
of
#
"
+
targetElement
.
id
+
"
\
n
"
)
;
await
promiseNativeMouseEventWithAPZ
(
{
target
offsetX
:
mouseX
offsetY
:
mouseY
type
:
"
mousemove
"
}
)
;
await
promiseNativeMouseEventWithAPZ
(
{
target
offsetX
:
mouseX
offsetY
:
mouseY
type
:
"
mousedown
"
}
)
;
for
(
var
y
=
increment
;
y
<
distance
;
y
+
=
increment
)
{
await
promiseNativeMouseEventWithAPZ
(
{
target
offsetX
:
mouseX
offsetY
:
mouseY
+
y
type
:
"
mousemove
"
}
)
;
}
await
promiseNativeMouseEventWithAPZ
(
{
target
offsetX
:
mouseX
offsetY
:
mouseY
+
distance
type
:
"
mousemove
"
}
)
;
return
async
function
(
)
{
dump
(
"
Finishing
drag
of
#
"
+
targetElement
.
id
+
"
\
n
"
)
;
await
promiseNativeMouseEventWithAPZ
(
{
target
offsetX
:
mouseX
offsetY
:
mouseY
+
distance
type
:
"
mouseup
"
}
)
;
}
;
}
async
function
promiseNativeMouseDrag
(
target
mouseX
mouseY
distanceX
=
20
distanceY
=
20
steps
=
20
)
{
var
targetElement
=
elementForTarget
(
target
)
;
dump
(
"
Starting
drag
at
"
+
mouseX
+
"
"
+
mouseY
+
"
from
top
-
left
of
#
"
+
targetElement
.
id
+
"
\
n
"
)
;
await
promiseNativeMouseEventWithAPZ
(
{
target
offsetX
:
mouseX
offsetY
:
mouseY
type
:
"
mousemove
"
}
)
;
await
promiseNativeMouseEventWithAPZ
(
{
target
offsetX
:
mouseX
offsetY
:
mouseY
type
:
"
mousedown
"
}
)
;
for
(
var
s
=
1
;
s
<
=
steps
;
s
+
+
)
{
let
dx
=
distanceX
*
(
s
/
steps
)
;
let
dy
=
distanceY
*
(
s
/
steps
)
;
dump
(
Dragging
to
{
mouseX
+
dx
}
{
mouseY
+
dy
}
from
target
\
n
)
;
await
promiseNativeMouseEventWithAPZ
(
{
target
offsetX
:
mouseX
+
dx
offsetY
:
mouseY
+
dy
type
:
"
mousemove
"
}
)
;
}
return
function
(
)
{
return
promiseNativeMouseEventWithAPZ
(
{
target
offsetX
:
mouseX
+
distanceX
offsetY
:
mouseY
+
distanceY
type
:
"
mouseup
"
}
)
;
}
;
}
function
pinchZoomInTouchSequence
(
focusX
focusY
)
{
var
zoom_in
=
[
[
{
x
:
focusX
-
25
y
:
focusY
-
50
}
{
x
:
focusX
+
25
y
:
focusY
+
50
}
]
[
{
x
:
focusX
-
30
y
:
focusY
-
80
}
{
x
:
focusX
+
30
y
:
focusY
+
80
}
]
[
{
x
:
focusX
-
35
y
:
focusY
-
110
}
{
x
:
focusX
+
40
y
:
focusY
+
110
}
]
[
{
x
:
focusX
-
40
y
:
focusY
-
140
}
{
x
:
focusX
+
45
y
:
focusY
+
140
}
]
[
{
x
:
focusX
-
45
y
:
focusY
-
170
}
{
x
:
focusX
+
50
y
:
focusY
+
170
}
]
[
{
x
:
focusX
-
50
y
:
focusY
-
200
}
{
x
:
focusX
+
55
y
:
focusY
+
200
}
]
]
;
var
touchIds
=
[
0
1
]
;
return
synthesizeNativeTouchSequences
(
document
.
body
zoom_in
null
touchIds
)
;
}
function
promiseTopic
(
aTopic
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
SpecialPowers
.
Services
.
obs
.
addObserver
(
function
observer
(
subject
topic
data
)
{
try
{
SpecialPowers
.
Services
.
obs
.
removeObserver
(
observer
topic
)
;
resolve
(
[
subject
data
]
)
;
}
catch
(
ex
)
{
SpecialPowers
.
Services
.
obs
.
removeObserver
(
observer
topic
)
;
reject
(
ex
)
;
}
}
aTopic
)
;
}
)
;
}
function
promiseTransformEnd
(
)
{
return
promiseTopic
(
"
APZ
:
TransformEnd
"
)
;
}
function
promiseTouchEnd
(
element
count
=
1
)
{
return
new
Promise
(
resolve
=
>
{
var
eventCount
=
0
;
var
counterFunction
=
function
(
e
)
{
eventCount
+
+
;
if
(
eventCount
=
=
count
)
{
element
.
removeEventListener
(
"
touchend
"
counterFunction
{
passive
:
true
}
)
;
resolve
(
)
;
}
}
;
element
.
addEventListener
(
"
touchend
"
counterFunction
{
passive
:
true
}
)
;
}
)
;
}
async
function
pinchZoomInWithTouch
(
focusX
focusY
)
{
let
transformEndPromise
=
promiseTopic
(
"
APZ
:
TransformEnd
"
)
;
pinchZoomInTouchSequence
(
focusX
focusY
)
;
await
transformEndPromise
;
}
async
function
pinchZoomInWithTouchpad
(
focusX
focusY
)
{
let
transformEndPromise
=
promiseTopic
(
"
APZ
:
TransformEnd
"
)
;
var
scales
=
[
1
.
0
1
.
019531
1
.
035156
1
.
054688
1
.
070312
1
.
089844
1
.
109375
1
.
128906
1
.
144531
1
.
160156
1
.
175781
1
.
191406
1
.
207031
1
.
222656
1
.
234375
1
.
246094
1
.
261719
1
.
273438
1
.
285156
1
.
296875
1
.
3125
1
.
328125
1
.
347656
1
.
363281
1
.
382812
1
.
402344
1
.
421875
1
.
0
]
;
var
modifierFlags
=
0
;
var
pt
=
coordinatesRelativeToScreen
(
{
offsetX
:
focusX
offsetY
:
focusY
target
:
document
.
body
}
)
;
var
utils
=
utilsForTarget
(
document
.
body
)
;
for
(
let
i
=
0
;
i
<
scales
.
length
;
i
+
+
)
{
var
phase
;
if
(
i
=
=
=
0
)
{
phase
=
SpecialPowers
.
DOMWindowUtils
.
PHASE_BEGIN
;
}
else
if
(
i
=
=
=
scales
.
length
-
1
)
{
phase
=
SpecialPowers
.
DOMWindowUtils
.
PHASE_END
;
}
else
{
phase
=
SpecialPowers
.
DOMWindowUtils
.
PHASE_UPDATE
;
}
utils
.
sendNativeTouchpadPinch
(
phase
scales
[
i
]
pt
.
x
pt
.
y
modifierFlags
)
;
}
await
transformEndPromise
;
}
async
function
synthesizeNativeTouchAndWaitForTransformEnd
(
touchSequence
touchIds
)
{
let
transformEndPromise
=
promiseTopic
(
"
APZ
:
TransformEnd
"
)
;
synthesizeNativeTouchSequences
(
document
.
body
touchSequence
null
touchIds
)
;
await
transformEndPromise
;
}
function
pinchZoomOutTouchSequenceAtCenter
(
)
{
const
deltaX
=
window
.
visualViewport
.
width
/
16
;
const
deltaY
=
window
.
visualViewport
.
height
/
16
;
const
centerX
=
window
.
visualViewport
.
pageLeft
+
window
.
visualViewport
.
width
/
2
;
const
centerY
=
window
.
visualViewport
.
pageTop
+
window
.
visualViewport
.
height
/
2
;
var
zoom_out
=
[
[
{
x
:
centerX
-
(
deltaX
*
6
)
y
:
centerY
-
(
deltaY
*
6
)
}
{
x
:
centerX
+
(
deltaX
*
6
)
y
:
centerY
+
(
deltaY
*
6
)
}
]
[
{
x
:
centerX
-
(
deltaX
*
5
)
y
:
centerY
-
(
deltaY
*
5
)
}
{
x
:
centerX
+
(
deltaX
*
5
)
y
:
centerY
+
(
deltaY
*
5
)
}
]
[
{
x
:
centerX
-
(
deltaX
*
4
)
y
:
centerY
-
(
deltaY
*
4
)
}
{
x
:
centerX
+
(
deltaX
*
4
)
y
:
centerY
+
(
deltaY
*
4
)
}
]
[
{
x
:
centerX
-
(
deltaX
*
3
)
y
:
centerY
-
(
deltaY
*
3
)
}
{
x
:
centerX
+
(
deltaX
*
3
)
y
:
centerY
+
(
deltaY
*
3
)
}
]
[
{
x
:
centerX
-
(
deltaX
*
2
)
y
:
centerY
-
(
deltaY
*
2
)
}
{
x
:
centerX
+
(
deltaX
*
2
)
y
:
centerY
+
(
deltaY
*
2
)
}
]
[
{
x
:
centerX
-
(
deltaX
*
1
)
y
:
centerY
-
(
deltaY
*
1
)
}
{
x
:
centerX
+
(
deltaX
*
1
)
y
:
centerY
+
(
deltaY
*
1
)
}
]
]
;
return
zoom_out
;
}
async
function
pinchZoomOutWithTouchAtCenter
(
)
{
var
zoom_out
=
pinchZoomOutTouchSequenceAtCenter
(
)
;
var
touchIds
=
[
0
1
]
;
await
synthesizeNativeTouchAndWaitForTransformEnd
(
zoom_out
touchIds
)
;
}
