async
function
getResolution
(
)
{
let
resolution
=
-
1
;
resolution
=
await
SpecialPowers
.
spawn
(
window
.
top
[
]
(
)
=
>
{
return
SpecialPowers
.
getDOMWindowUtils
(
content
.
window
)
.
getResolution
(
)
;
}
)
;
return
resolution
;
}
function
getPlatform
(
)
{
if
(
navigator
.
platform
.
indexOf
(
"
Win
"
)
=
=
0
)
{
return
"
windows
"
;
}
if
(
navigator
.
platform
.
indexOf
(
"
Mac
"
)
=
=
0
)
{
return
"
mac
"
;
}
if
(
navigator
.
appVersion
.
includes
(
"
Android
"
)
)
{
return
"
android
"
;
}
if
(
navigator
.
platform
.
indexOf
(
"
Linux
"
)
=
=
0
)
{
return
"
linux
"
;
}
return
"
unknown
"
;
}
function
nativeVerticalWheelEventMsg
(
)
{
switch
(
getPlatform
(
)
)
{
case
"
windows
"
:
return
0x020a
;
case
"
mac
"
:
var
useWheelCodepath
=
SpecialPowers
.
getBoolPref
(
"
apz
.
test
.
mac
.
synth_wheel_input
"
false
)
;
return
useWheelCodepath
?
0
:
1
;
case
"
linux
"
:
return
4
;
}
throw
new
Error
(
"
Native
wheel
events
not
supported
on
platform
"
+
getPlatform
(
)
)
;
}
function
nativeHorizontalWheelEventMsg
(
)
{
switch
(
getPlatform
(
)
)
{
case
"
windows
"
:
return
0x020e
;
case
"
mac
"
:
return
0
;
case
"
linux
"
:
return
4
;
}
throw
new
Error
(
"
Native
wheel
events
not
supported
on
platform
"
+
getPlatform
(
)
)
;
}
function
nativeArrowDownKey
(
)
{
switch
(
getPlatform
(
)
)
{
case
"
windows
"
:
return
WIN_VK_DOWN
;
case
"
mac
"
:
return
MAC_VK_DownArrow
;
}
throw
new
Error
(
"
Native
key
events
not
supported
on
platform
"
+
getPlatform
(
)
)
;
}
function
nativeArrowUpKey
(
)
{
switch
(
getPlatform
(
)
)
{
case
"
windows
"
:
return
WIN_VK_UP
;
case
"
mac
"
:
return
MAC_VK_UpArrow
;
}
throw
new
Error
(
"
Native
key
events
not
supported
on
platform
"
+
getPlatform
(
)
)
;
}
function
windowForTarget
(
aTarget
)
{
if
(
aTarget
.
Window
&
&
aTarget
instanceof
aTarget
.
Window
)
{
return
aTarget
;
}
return
aTarget
.
ownerDocument
.
defaultView
;
}
function
elementForTarget
(
aTarget
)
{
if
(
aTarget
.
Window
&
&
aTarget
instanceof
aTarget
.
Window
)
{
return
aTarget
.
document
.
documentElement
;
}
return
aTarget
;
}
function
utilsForTarget
(
aTarget
)
{
return
SpecialPowers
.
getDOMWindowUtils
(
windowForTarget
(
aTarget
)
)
;
}
function
nativeScrollUnits
(
aTarget
aDimen
)
{
switch
(
getPlatform
(
)
)
{
case
"
linux
"
:
{
var
targetWindow
=
windowForTarget
(
aTarget
)
;
var
targetElement
=
elementForTarget
(
aTarget
)
;
var
lineHeight
=
targetWindow
.
getComputedStyle
(
targetElement
)
[
"
font
-
size
"
]
;
return
aDimen
/
(
parseInt
(
lineHeight
)
*
3
)
;
}
}
return
aDimen
;
}
function
parseNativeModifiers
(
aModifiers
aWindow
=
window
)
{
let
modifiers
=
0
;
if
(
aModifiers
.
capsLockKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_CAPS_LOCK
;
}
if
(
aModifiers
.
numLockKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_NUM_LOCK
;
}
if
(
aModifiers
.
shiftKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_SHIFT_LEFT
;
}
if
(
aModifiers
.
shiftRightKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_SHIFT_RIGHT
;
}
if
(
aModifiers
.
ctrlKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_CONTROL_LEFT
;
}
if
(
aModifiers
.
ctrlRightKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_CONTROL_RIGHT
;
}
if
(
aModifiers
.
altKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_ALT_LEFT
;
}
if
(
aModifiers
.
altRightKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_ALT_RIGHT
;
}
if
(
aModifiers
.
metaKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_COMMAND_LEFT
;
}
if
(
aModifiers
.
metaRightKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_COMMAND_RIGHT
;
}
if
(
aModifiers
.
helpKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_HELP
;
}
if
(
aModifiers
.
fnKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_FUNCTION
;
}
if
(
aModifiers
.
numericKeyPadKey
)
{
modifiers
|
=
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_NUMERIC_KEY_PAD
;
}
if
(
aModifiers
.
accelKey
)
{
modifiers
|
=
_EU_isMac
(
aWindow
)
?
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_COMMAND_LEFT
:
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_CONTROL_LEFT
;
}
if
(
aModifiers
.
accelRightKey
)
{
modifiers
|
=
_EU_isMac
(
aWindow
)
?
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_COMMAND_RIGHT
:
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_CONTROL_RIGHT
;
}
if
(
aModifiers
.
altGrKey
)
{
modifiers
|
=
_EU_isMac
(
aWindow
)
?
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_ALT_LEFT
:
SpecialPowers
.
Ci
.
nsIDOMWindowUtils
.
NATIVE_MODIFIER_ALT_GRAPH
;
}
return
modifiers
;
}
function
getBoundingClientRectRelativeToVisualViewport
(
aElement
)
{
let
utils
=
SpecialPowers
.
getDOMWindowUtils
(
window
)
;
var
rect
=
aElement
.
getBoundingClientRect
(
)
;
var
offsetX
=
{
}
offsetY
=
{
}
;
utils
.
getVisualViewportOffsetRelativeToLayoutViewport
(
offsetX
offsetY
)
;
rect
.
x
-
=
offsetX
.
value
;
rect
.
y
-
=
offsetY
.
value
;
return
rect
;
}
function
_getTargetRect
(
aTarget
)
{
let
rect
=
{
left
:
0
top
:
0
width
:
0
height
:
0
}
;
if
(
aTarget
instanceof
Window
)
{
return
rect
;
}
if
(
aTarget
.
Window
&
&
aTarget
instanceof
aTarget
.
Window
)
{
return
rect
;
}
const
boundingClientRect
=
aTarget
.
getBoundingClientRect
(
)
;
rect
.
left
=
boundingClientRect
.
left
;
rect
.
top
=
boundingClientRect
.
top
;
rect
.
width
=
boundingClientRect
.
width
;
rect
.
height
=
boundingClientRect
.
height
;
while
(
aTarget
.
ownerDocument
.
defaultView
.
frameElement
)
{
const
iframe
=
aTarget
.
ownerDocument
.
defaultView
.
frameElement
;
const
style
=
iframe
.
ownerDocument
.
defaultView
.
getComputedStyle
(
iframe
)
;
const
borderLeft
=
parseFloat
(
style
.
borderLeftWidth
)
|
|
0
;
const
borderTop
=
parseFloat
(
style
.
borderTopWidth
)
|
|
0
;
const
borderRight
=
parseFloat
(
style
.
borderRightWidth
)
|
|
0
;
const
borderBottom
=
parseFloat
(
style
.
borderBottomWidth
)
|
|
0
;
const
paddingLeft
=
parseFloat
(
style
.
paddingLeft
)
|
|
0
;
const
paddingTop
=
parseFloat
(
style
.
paddingTop
)
|
|
0
;
const
paddingRight
=
parseFloat
(
style
.
paddingRight
)
|
|
0
;
const
paddingBottom
=
parseFloat
(
style
.
paddingBottom
)
|
|
0
;
const
iframeRect
=
iframe
.
getBoundingClientRect
(
)
;
rect
.
left
+
=
iframeRect
.
left
+
borderLeft
+
paddingLeft
;
rect
.
top
+
=
iframeRect
.
top
+
borderTop
+
paddingTop
;
if
(
rect
.
left
+
rect
.
width
>
iframeRect
.
right
-
borderRight
-
paddingRight
)
{
rect
.
width
=
Math
.
max
(
iframeRect
.
right
-
borderRight
-
paddingRight
-
rect
.
left
0
)
;
}
if
(
rect
.
top
+
rect
.
height
>
iframeRect
.
bottom
-
borderBottom
-
paddingBottom
)
{
rect
.
height
=
Math
.
max
(
iframeRect
.
bottom
-
borderBottom
-
paddingBottom
-
rect
.
top
0
)
;
}
aTarget
=
iframe
;
}
return
rect
;
}
function
getInProcessRootWindow
(
aWindow
)
{
let
window
=
aWindow
;
while
(
window
.
frameElement
)
{
window
=
window
.
frameElement
.
ownerDocument
.
defaultView
;
}
return
window
;
}
async
function
coordinatesRelativeToScreen
(
aParams
)
{
const
{
target
offsetX
offsetY
atCenter
}
=
aParams
;
if
(
target
instanceof
Window
&
&
window
.
parent
=
=
window
)
{
const
resolution
=
await
getResolution
(
)
;
const
deviceScale
=
window
.
devicePixelRatio
;
return
{
x
:
window
.
mozInnerScreenX
*
deviceScale
+
(
atCenter
?
0
:
offsetX
)
*
resolution
*
deviceScale
y
:
window
.
mozInnerScreenY
*
deviceScale
+
(
atCenter
?
0
:
offsetY
)
*
resolution
*
deviceScale
}
;
}
const
rect
=
_getTargetRect
(
target
)
;
const
utils
=
SpecialPowers
.
getDOMWindowUtils
(
getInProcessRootWindow
(
window
)
)
;
const
positionInScreenCoords
=
utils
.
toScreenRect
(
rect
.
left
+
(
atCenter
?
rect
.
width
/
2
:
offsetX
)
rect
.
top
+
(
atCenter
?
rect
.
height
/
2
:
offsetY
)
0
0
)
;
return
{
x
:
positionInScreenCoords
.
x
y
:
positionInScreenCoords
.
y
}
;
}
function
rectRelativeToScreen
(
aElement
)
{
var
targetWindow
=
aElement
.
ownerDocument
.
defaultView
;
var
scale
=
targetWindow
.
devicePixelRatio
;
var
rect
=
aElement
.
getBoundingClientRect
(
)
;
return
{
x
:
(
targetWindow
.
mozInnerScreenX
+
rect
.
left
)
*
scale
y
:
(
targetWindow
.
mozInnerScreenY
+
rect
.
top
)
*
scale
width
:
rect
.
width
*
scale
height
:
rect
.
height
*
scale
}
;
}
async
function
synthesizeNativeWheel
(
aTarget
aX
aY
aDeltaX
aDeltaY
aObserver
)
{
var
pt
=
await
coordinatesRelativeToScreen
(
{
offsetX
:
aX
offsetY
:
aY
target
:
aTarget
}
)
;
if
(
aDeltaX
&
&
aDeltaY
)
{
throw
new
Error
(
"
Simultaneous
wheeling
of
horizontal
and
vertical
is
not
supported
on
all
platforms
.
"
)
;
}
aDeltaX
=
nativeScrollUnits
(
aTarget
aDeltaX
)
;
aDeltaY
=
nativeScrollUnits
(
aTarget
aDeltaY
)
;
var
msg
=
aDeltaX
?
nativeHorizontalWheelEventMsg
(
)
:
nativeVerticalWheelEventMsg
(
)
;
var
utils
=
utilsForTarget
(
aTarget
)
;
var
element
=
elementForTarget
(
aTarget
)
;
utils
.
sendNativeMouseScrollEvent
(
pt
.
x
pt
.
y
msg
aDeltaX
aDeltaY
0
0
SpecialPowers
.
getBoolPref
(
"
apz
.
test
.
mac
.
synth_wheel_input
"
false
)
?
SpecialPowers
.
DOMWindowUtils
.
MOUSESCROLL_SCROLL_LINES
:
0
element
aObserver
)
;
return
true
;
}
async
function
synthesizeNativePanGestureEvent
(
aTarget
aX
aY
aDeltaX
aDeltaY
aPhase
aObserver
)
{
if
(
getPlatform
(
)
!
=
"
mac
"
)
{
throw
new
Error
(
synthesizeNativePanGestureEvent
doesn
'
t
work
on
{
getPlatform
(
)
}
)
;
}
var
pt
=
await
coordinatesRelativeToScreen
(
{
offsetX
:
aX
offsetY
:
aY
target
:
aTarget
}
)
;
if
(
aDeltaX
&
&
aDeltaY
)
{
throw
new
Error
(
"
Simultaneous
panning
of
horizontal
and
vertical
is
not
supported
.
"
)
;
}
aDeltaX
=
nativeScrollUnits
(
aTarget
aDeltaX
)
;
aDeltaY
=
nativeScrollUnits
(
aTarget
aDeltaY
)
;
var
element
=
elementForTarget
(
aTarget
)
;
var
utils
=
utilsForTarget
(
aTarget
)
;
utils
.
sendNativeMouseScrollEvent
(
pt
.
x
pt
.
y
aPhase
aDeltaX
aDeltaY
0
0
0
element
aObserver
)
;
return
true
;
}
async
function
promiseNativeTouchpadPanEventAndWaitForObserver
(
aTarget
aX
aY
aDeltaX
aDeltaY
aPhase
)
{
if
(
getPlatform
(
)
!
=
"
windows
"
&
&
getPlatform
(
)
!
=
"
linux
"
)
{
throw
new
Error
(
promiseNativeTouchpadPanEventAndWaitForObserver
doesn
'
t
work
on
{
getPlatform
(
)
}
)
;
}
let
pt
=
await
coordinatesRelativeToScreen
(
{
offsetX
:
aX
offsetY
:
aY
target
:
aTarget
}
)
;
const
utils
=
utilsForTarget
(
aTarget
)
;
return
new
Promise
(
resolve
=
>
{
var
observer
=
{
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
touchpadpanevent
"
)
{
resolve
(
)
;
}
}
}
;
utils
.
sendNativeTouchpadPan
(
aPhase
pt
.
x
pt
.
y
aDeltaX
aDeltaY
0
observer
)
;
}
)
;
}
async
function
synthesizeSimpleGestureEvent
(
aElement
aType
aX
aY
aDirection
aDelta
aModifiers
aClickCount
)
{
let
pt
=
await
coordinatesRelativeToScreen
(
{
offsetX
:
aX
offsetY
:
aY
target
:
aElement
}
)
;
let
utils
=
utilsForTarget
(
aElement
)
;
utils
.
sendSimpleGestureEvent
(
aType
pt
.
x
pt
.
y
aDirection
aDelta
aModifiers
aClickCount
)
;
}
function
promiseNativePanGestureEventAndWaitForObserver
(
aElement
aX
aY
aDeltaX
aDeltaY
aPhase
)
{
return
new
Promise
(
resolve
=
>
{
var
observer
=
{
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
mousescrollevent
"
)
{
resolve
(
)
;
}
}
}
;
synthesizeNativePanGestureEvent
(
aElement
aX
aY
aDeltaX
aDeltaY
aPhase
observer
)
;
}
)
;
}
function
promiseNativeWheelAndWaitForObserver
(
aElement
aX
aY
aDeltaX
aDeltaY
)
{
return
new
Promise
(
resolve
=
>
{
var
observer
=
{
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
mousescrollevent
"
)
{
resolve
(
)
;
}
}
}
;
synthesizeNativeWheel
(
aElement
aX
aY
aDeltaX
aDeltaY
observer
)
;
}
)
;
}
function
promiseNativeWheelAndWaitForWheelEvent
(
aTarget
aX
aY
aDeltaX
aDeltaY
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
var
targetWindow
=
windowForTarget
(
aTarget
)
;
targetWindow
.
addEventListener
(
"
wheel
"
function
(
e
)
{
setTimeout
(
resolve
0
)
;
}
{
once
:
true
}
)
;
try
{
synthesizeNativeWheel
(
aTarget
aX
aY
aDeltaX
aDeltaY
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
)
;
}
function
promiseNativeWheelAndWaitForScrollEvent
(
aTarget
aX
aY
aDeltaX
aDeltaY
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
var
targetWindow
=
windowForTarget
(
aTarget
)
;
targetWindow
.
addEventListener
(
"
scroll
"
function
(
)
{
setTimeout
(
resolve
0
)
;
}
{
capture
:
true
once
:
true
}
)
;
try
{
synthesizeNativeWheel
(
aTarget
aX
aY
aDeltaX
aDeltaY
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
)
;
}
async
function
synthesizeTouchpadPinch
(
scales
focusX
focusY
options
)
{
var
scalesAndFoci
=
[
]
;
for
(
let
i
=
0
;
i
<
scales
.
length
;
i
+
+
)
{
scalesAndFoci
.
push
(
[
scales
[
i
]
focusX
focusY
]
)
;
}
await
synthesizeTouchpadGesture
(
scalesAndFoci
options
)
;
}
async
function
synthesizeTouchpadGesture
(
scalesAndFoci
options
)
{
let
waitForTransformEnd
=
options
.
waitForTransformEnd
!
=
=
undefined
?
options
.
waitForTransformEnd
:
true
;
let
waitForFrames
=
options
.
waitForFrames
!
=
=
undefined
?
options
.
waitForFrames
:
false
;
let
transformEndPromise
=
promiseTransformEnd
(
)
;
var
modifierFlags
=
0
;
var
utils
=
utilsForTarget
(
document
.
body
)
;
for
(
let
i
=
0
;
i
<
scalesAndFoci
.
length
;
i
+
+
)
{
var
pt
=
await
coordinatesRelativeToScreen
(
{
offsetX
:
scalesAndFoci
[
i
]
[
1
]
offsetY
:
scalesAndFoci
[
i
]
[
2
]
target
:
document
.
body
}
)
;
var
phase
;
if
(
i
=
=
=
0
)
{
phase
=
SpecialPowers
.
DOMWindowUtils
.
PHASE_BEGIN
;
}
else
if
(
i
=
=
=
scalesAndFoci
.
length
-
1
)
{
phase
=
SpecialPowers
.
DOMWindowUtils
.
PHASE_END
;
}
else
{
phase
=
SpecialPowers
.
DOMWindowUtils
.
PHASE_UPDATE
;
}
utils
.
sendNativeTouchpadPinch
(
phase
scalesAndFoci
[
i
]
[
0
]
pt
.
x
pt
.
y
modifierFlags
)
;
if
(
waitForFrames
)
{
await
promiseFrame
(
)
;
}
}
if
(
waitForTransformEnd
)
{
await
transformEndPromise
;
}
}
async
function
synthesizeTouchpadPan
(
focusX
focusY
deltaXs
deltaYs
options
)
{
let
waitForTransformEnd
=
options
.
waitForTransformEnd
!
=
=
undefined
?
options
.
waitForTransformEnd
:
true
;
let
waitForFrames
=
options
.
waitForFrames
!
=
=
undefined
?
options
.
waitForFrames
:
false
;
let
transformEndPromise
=
promiseTransformEnd
(
)
;
var
modifierFlags
=
0
;
var
pt
=
await
coordinatesRelativeToScreen
(
{
offsetX
:
focusX
offsetY
:
focusY
target
:
document
.
body
}
)
;
var
utils
=
utilsForTarget
(
document
.
body
)
;
for
(
let
i
=
0
;
i
<
deltaXs
.
length
;
i
+
+
)
{
var
phase
;
if
(
i
=
=
=
0
)
{
phase
=
SpecialPowers
.
DOMWindowUtils
.
PHASE_BEGIN
;
}
else
if
(
i
=
=
=
deltaXs
.
length
-
1
)
{
phase
=
SpecialPowers
.
DOMWindowUtils
.
PHASE_END
;
}
else
{
phase
=
SpecialPowers
.
DOMWindowUtils
.
PHASE_UPDATE
;
}
utils
.
sendNativeTouchpadPan
(
phase
pt
.
x
pt
.
y
deltaXs
[
i
]
deltaYs
[
i
]
modifierFlags
)
;
if
(
waitForFrames
)
{
await
promiseFrame
(
)
;
}
}
if
(
waitForTransformEnd
)
{
await
transformEndPromise
;
}
}
async
function
synthesizeNativeTouch
(
aTarget
aX
aY
aType
aObserver
=
null
aTouchId
=
0
)
{
var
pt
=
await
coordinatesRelativeToScreen
(
{
offsetX
:
aX
offsetY
:
aY
target
:
aTarget
}
)
;
var
utils
=
utilsForTarget
(
aTarget
)
;
utils
.
sendNativeTouchPoint
(
aTouchId
aType
pt
.
x
pt
.
y
1
90
aObserver
)
;
return
true
;
}
function
sendBasicNativePointerInput
(
utils
aId
aPointerType
aState
aX
aY
aObserver
{
pressure
=
1
twist
=
0
tiltX
=
0
tiltY
=
0
button
=
0
}
=
{
}
)
{
switch
(
aPointerType
)
{
case
"
touch
"
:
utils
.
sendNativeTouchPoint
(
aId
aState
aX
aY
pressure
90
aObserver
)
;
break
;
case
"
pen
"
:
utils
.
sendNativePenInput
(
aId
aState
aX
aY
pressure
twist
tiltX
tiltY
button
aObserver
)
;
break
;
default
:
throw
new
Error
(
Not
supported
:
{
aPointerType
}
)
;
}
}
async
function
promiseNativePointerInput
(
aTarget
aPointerType
aState
aX
aY
options
)
{
const
pt
=
await
coordinatesRelativeToScreen
(
{
offsetX
:
aX
offsetY
:
aY
target
:
aTarget
}
)
;
const
utils
=
utilsForTarget
(
aTarget
)
;
return
new
Promise
(
resolve
=
>
{
sendBasicNativePointerInput
(
utils
options
?
.
pointerId
?
?
0
aPointerType
aState
pt
.
x
pt
.
y
resolve
options
)
;
}
)
;
}
async
function
synthesizeNativePointerSequences
(
aTarget
aPointerType
aPositions
aObserver
=
null
aPointerIds
=
[
0
]
options
)
{
var
lastNonNullValue
=
-
1
;
for
(
let
i
=
0
;
i
<
aPositions
.
length
;
i
+
+
)
{
if
(
aPositions
[
i
]
=
=
null
)
{
throw
new
Error
(
aPositions
[
{
i
}
]
was
unexpectedly
null
)
;
}
if
(
aPositions
[
i
]
.
length
!
=
aPointerIds
.
length
)
{
throw
new
Error
(
aPositions
[
{
i
}
]
did
not
have
the
expected
number
of
positions
;
+
expected
{
aPointerIds
.
length
}
pointers
but
found
{
aPositions
[
i
]
.
length
}
)
;
}
for
(
let
j
=
0
;
j
<
aPointerIds
.
length
;
j
+
+
)
{
if
(
aPositions
[
i
]
[
j
]
!
=
null
)
{
lastNonNullValue
=
i
*
aPointerIds
.
length
+
j
;
aPositions
[
i
]
[
j
]
=
await
coordinatesRelativeToScreen
(
{
offsetX
:
aPositions
[
i
]
[
j
]
.
x
offsetY
:
aPositions
[
i
]
[
j
]
.
y
target
:
aTarget
}
)
;
}
}
}
if
(
lastNonNullValue
<
0
)
{
throw
new
Error
(
"
All
values
in
positions
array
were
null
!
"
)
;
}
var
allNullRow
=
new
Array
(
aPointerIds
.
length
)
;
allNullRow
.
fill
(
null
)
;
aPositions
.
push
(
allNullRow
)
;
var
lastSynthesizeCall
=
lastNonNullValue
+
aPointerIds
.
length
;
var
currentPositions
=
new
Array
(
aPointerIds
.
length
)
;
currentPositions
.
fill
(
null
)
;
var
utils
=
utilsForTarget
(
aTarget
)
;
for
(
let
i
=
0
;
i
<
aPositions
.
length
;
i
+
+
)
{
for
(
let
j
=
0
;
j
<
aPointerIds
.
length
;
j
+
+
)
{
if
(
aPositions
[
i
]
[
j
]
=
=
null
)
{
if
(
currentPositions
[
j
]
=
=
null
)
{
}
else
{
var
thisIndex
=
i
*
aPointerIds
.
length
+
j
;
var
observer
=
lastSynthesizeCall
=
=
thisIndex
?
aObserver
:
null
;
sendBasicNativePointerInput
(
utils
aPointerIds
[
j
]
aPointerType
SpecialPowers
.
DOMWindowUtils
.
TOUCH_REMOVE
currentPositions
[
j
]
.
x
currentPositions
[
j
]
.
y
observer
options
)
;
currentPositions
[
j
]
=
null
;
}
}
else
{
sendBasicNativePointerInput
(
utils
aPointerIds
[
j
]
aPointerType
SpecialPowers
.
DOMWindowUtils
.
TOUCH_CONTACT
aPositions
[
i
]
[
j
]
.
x
aPositions
[
i
]
[
j
]
.
y
null
options
)
;
currentPositions
[
j
]
=
aPositions
[
i
]
[
j
]
;
}
}
}
return
true
;
}
async
function
synthesizeNativeTouchSequences
(
aTarget
aPositions
aObserver
=
null
aTouchIds
=
[
0
]
)
{
await
synthesizeNativePointerSequences
(
aTarget
"
touch
"
aPositions
aObserver
aTouchIds
)
;
}
async
function
synthesizeNativePointerDrag
(
aTarget
aPointerType
aX
aY
aDeltaX
aDeltaY
aObserver
=
null
aPointerId
=
0
options
)
{
var
steps
=
Math
.
max
(
Math
.
abs
(
aDeltaX
)
Math
.
abs
(
aDeltaY
)
)
;
var
positions
=
[
[
{
x
:
aX
y
:
aY
}
]
]
;
for
(
var
i
=
1
;
i
<
steps
;
i
+
+
)
{
var
dx
=
i
*
(
aDeltaX
/
steps
)
;
var
dy
=
i
*
(
aDeltaY
/
steps
)
;
var
pos
=
{
x
:
aX
+
dx
y
:
aY
+
dy
}
;
positions
.
push
(
[
pos
]
)
;
}
positions
.
push
(
[
{
x
:
aX
+
aDeltaX
y
:
aY
+
aDeltaY
}
]
)
;
return
synthesizeNativePointerSequences
(
aTarget
aPointerType
positions
aObserver
[
aPointerId
]
options
)
;
}
async
function
synthesizeNativeTouchDrag
(
aTarget
aX
aY
aDeltaX
aDeltaY
aObserver
=
null
aTouchId
=
0
)
{
return
synthesizeNativePointerDrag
(
aTarget
"
touch
"
aX
aY
aDeltaX
aDeltaY
aObserver
aTouchId
)
;
}
function
promiseNativePointerDrag
(
aTarget
aPointerType
aX
aY
aDeltaX
aDeltaY
aPointerId
=
0
options
)
{
return
new
Promise
(
resolve
=
>
{
synthesizeNativePointerDrag
(
aTarget
aPointerType
aX
aY
aDeltaX
aDeltaY
resolve
aPointerId
options
)
;
}
)
;
}
function
promiseNativeTouchDrag
(
aTarget
aX
aY
aDeltaX
aDeltaY
aTouchId
=
0
)
{
return
new
Promise
(
resolve
=
>
{
synthesizeNativeTouchDrag
(
aTarget
aX
aY
aDeltaX
aDeltaY
resolve
aTouchId
)
;
}
)
;
}
function
promiseNativePointerTap
(
aTarget
aPointerType
aX
aY
options
)
{
return
promiseNativePointerDrag
(
aTarget
aPointerType
aX
aY
0
0
options
?
.
pointerId
?
?
0
options
)
;
}
async
function
synthesizeNativeTap
(
aTarget
aX
aY
aObserver
=
null
)
{
var
pt
=
await
coordinatesRelativeToScreen
(
{
offsetX
:
aX
offsetY
:
aY
target
:
aTarget
}
)
;
let
utils
=
utilsForTarget
(
aTarget
)
;
utils
.
sendNativeTouchTap
(
pt
.
x
pt
.
y
false
aObserver
)
;
return
true
;
}
async
function
synthesizeNativeTouchpadDoubleTap
(
aTarget
aX
aY
)
{
ok
(
getPlatform
(
)
=
=
"
mac
"
"
only
implemented
on
mac
.
implement
sendNativeTouchpadDoubleTap
for
this
platform
"
+
"
see
bug
1696802
for
how
it
was
done
on
macOS
"
)
;
let
pt
=
await
coordinatesRelativeToScreen
(
{
offsetX
:
aX
offsetY
:
aY
target
:
aTarget
}
)
;
let
utils
=
utilsForTarget
(
aTarget
)
;
utils
.
sendNativeTouchpadDoubleTap
(
pt
.
x
pt
.
y
0
)
;
return
true
;
}
async
function
synthesizeNativeMouseEventWithAPZ
(
aParams
aObserver
=
null
)
{
if
(
aParams
.
win
!
=
=
undefined
)
{
throw
Error
(
"
Are
you
trying
to
use
EventUtils
'
API
?
win
won
'
t
be
used
with
synthesizeNativeMouseClickWithAPZ
.
"
)
;
}
if
(
aParams
.
scale
!
=
=
undefined
)
{
throw
Error
(
"
Are
you
trying
to
use
EventUtils
'
API
?
scale
won
'
t
be
used
with
synthesizeNativeMouseClickWithAPZ
.
"
)
;
}
if
(
aParams
.
elementOnWidget
!
=
=
undefined
)
{
throw
Error
(
"
Are
you
trying
to
use
EventUtils
'
API
?
elementOnWidget
won
'
t
be
used
with
synthesizeNativeMouseClickWithAPZ
.
"
)
;
}
const
{
type
target
offsetX
offsetY
atCenter
screenX
screenY
button
=
0
modifiers
=
{
}
}
=
aParams
;
if
(
atCenter
)
{
if
(
offsetX
!
=
undefined
|
|
offsetY
!
=
undefined
)
{
throw
Error
(
atCenter
is
specified
but
offsetX
(
{
offsetX
}
)
and
/
or
offsetY
(
{
offsetY
}
)
are
also
specified
)
;
}
if
(
screenX
!
=
undefined
|
|
screenY
!
=
undefined
)
{
throw
Error
(
atCenter
is
specified
but
screenX
(
{
screenX
}
)
and
/
or
screenY
(
{
screenY
}
)
are
also
specified
)
;
}
}
else
if
(
offsetX
!
=
undefined
&
&
offsetY
!
=
undefined
)
{
if
(
screenX
!
=
undefined
|
|
screenY
!
=
undefined
)
{
throw
Error
(
offsetX
/
Y
are
specified
but
screenX
(
{
screenX
}
)
and
/
or
screenY
(
{
screenY
}
)
are
also
specified
)
;
}
}
else
if
(
screenX
!
=
undefined
&
&
screenY
!
=
undefined
)
{
if
(
offsetX
!
=
undefined
|
|
offsetY
!
=
undefined
)
{
throw
Error
(
screenX
/
Y
are
specified
but
offsetX
(
{
offsetX
}
)
and
/
or
offsetY
(
{
offsetY
}
)
are
also
specified
)
;
}
}
const
pt
=
await
(
async
(
)
=
>
{
if
(
screenX
!
=
undefined
)
{
return
{
x
:
screenX
y
:
screenY
}
;
}
return
coordinatesRelativeToScreen
(
{
offsetX
offsetY
atCenter
target
}
)
;
}
)
(
)
;
const
utils
=
utilsForTarget
(
target
)
;
const
element
=
elementForTarget
(
target
)
;
const
modifierFlags
=
parseNativeModifiers
(
modifiers
)
;
if
(
type
=
=
=
"
click
"
)
{
utils
.
sendNativeMouseEvent
(
pt
.
x
pt
.
y
utils
.
NATIVE_MOUSE_MESSAGE_BUTTON_DOWN
button
modifierFlags
element
function
(
)
{
utils
.
sendNativeMouseEvent
(
pt
.
x
pt
.
y
utils
.
NATIVE_MOUSE_MESSAGE_BUTTON_UP
button
modifierFlags
element
aObserver
)
;
}
)
;
return
;
}
utils
.
sendNativeMouseEvent
(
pt
.
x
pt
.
y
(
(
)
=
>
{
switch
(
type
)
{
case
"
mousedown
"
:
return
utils
.
NATIVE_MOUSE_MESSAGE_BUTTON_DOWN
;
case
"
mouseup
"
:
return
utils
.
NATIVE_MOUSE_MESSAGE_BUTTON_UP
;
case
"
mousemove
"
:
return
utils
.
NATIVE_MOUSE_MESSAGE_MOVE
;
default
:
throw
Error
(
Invalid
type
is
specified
:
{
type
}
)
;
}
}
)
(
)
button
modifierFlags
element
aObserver
)
;
}
function
promiseNativeMouseEventWithAPZ
(
aParams
)
{
return
new
Promise
(
resolve
=
>
synthesizeNativeMouseEventWithAPZ
(
aParams
resolve
)
)
;
}
function
promiseNativeMouseEventWithAPZAndWaitForEvent
(
aParams
)
{
return
new
Promise
(
resolve
=
>
{
const
targetWindow
=
windowForTarget
(
aParams
.
target
)
;
const
eventType
=
aParams
.
eventTypeToWait
|
|
aParams
.
type
;
targetWindow
.
addEventListener
(
eventType
resolve
{
once
:
true
}
)
;
synthesizeNativeMouseEventWithAPZ
(
aParams
)
;
}
)
;
}
function
promiseMoveMouseAndScrollWheelOver
(
target
dx
dy
waitForScroll
=
true
scrollDelta
=
10
)
{
let
p
=
promiseNativeMouseEventWithAPZAndWaitForEvent
(
{
type
:
"
mousemove
"
target
offsetX
:
dx
offsetY
:
dy
}
)
;
if
(
waitForScroll
)
{
p
=
p
.
then
(
(
)
=
>
promiseNativeWheelAndWaitForScrollEvent
(
target
dx
dy
0
-
scrollDelta
)
)
;
}
else
{
p
=
p
.
then
(
(
)
=
>
promiseNativeWheelAndWaitForWheelEvent
(
target
dx
dy
0
-
scrollDelta
)
)
;
}
return
p
;
}
async
function
promiseVerticalScrollbarDrag
(
target
distance
=
20
increment
=
5
scaleFactor
=
1
)
{
var
targetElement
=
elementForTarget
(
target
)
;
var
w
=
{
}
h
=
{
}
;
utilsForTarget
(
target
)
.
getScrollbarSizes
(
targetElement
w
h
)
;
var
verticalScrollbarWidth
=
w
.
value
;
if
(
verticalScrollbarWidth
=
=
0
)
{
return
null
;
}
var
upArrowHeight
=
verticalScrollbarWidth
;
var
mouseX
=
targetElement
.
clientWidth
+
verticalScrollbarWidth
/
2
;
var
mouseY
=
upArrowHeight
+
5
;
mouseX
*
=
scaleFactor
;
mouseY
*
=
scaleFactor
;
dump
(
"
Starting
drag
at
"
+
mouseX
+
"
"
+
mouseY
+
"
from
top
-
left
of
#
"
+
targetElement
.
id
+
"
\
n
"
)
;
await
promiseNativeMouseEventWithAPZ
(
{
target
offsetX
:
mouseX
offsetY
:
mouseY
type
:
"
mousemove
"
}
)
;
await
promiseNativeMouseEventWithAPZ
(
{
target
offsetX
:
mouseX
offsetY
:
mouseY
type
:
"
mousedown
"
}
)
;
for
(
var
y
=
increment
;
y
<
distance
;
y
+
=
increment
)
{
await
promiseNativeMouseEventWithAPZ
(
{
target
offsetX
:
mouseX
offsetY
:
mouseY
+
y
type
:
"
mousemove
"
}
)
;
}
await
promiseNativeMouseEventWithAPZ
(
{
target
offsetX
:
mouseX
offsetY
:
mouseY
+
distance
type
:
"
mousemove
"
}
)
;
return
async
function
(
)
{
dump
(
"
Finishing
drag
of
#
"
+
targetElement
.
id
+
"
\
n
"
)
;
await
promiseNativeMouseEventWithAPZ
(
{
target
offsetX
:
mouseX
offsetY
:
mouseY
+
distance
type
:
"
mouseup
"
}
)
;
}
;
}
async
function
promiseNativeMouseDrag
(
target
mouseX
mouseY
distanceX
=
20
distanceY
=
20
steps
=
20
)
{
var
targetElement
=
elementForTarget
(
target
)
;
dump
(
"
Starting
drag
at
"
+
mouseX
+
"
"
+
mouseY
+
"
from
top
-
left
of
#
"
+
targetElement
.
id
+
"
\
n
"
)
;
await
promiseNativeMouseEventWithAPZ
(
{
target
offsetX
:
mouseX
offsetY
:
mouseY
type
:
"
mousemove
"
}
)
;
await
promiseNativeMouseEventWithAPZ
(
{
target
offsetX
:
mouseX
offsetY
:
mouseY
type
:
"
mousedown
"
}
)
;
for
(
var
s
=
1
;
s
<
=
steps
;
s
+
+
)
{
let
dx
=
distanceX
*
(
s
/
steps
)
;
let
dy
=
distanceY
*
(
s
/
steps
)
;
dump
(
Dragging
to
{
mouseX
+
dx
}
{
mouseY
+
dy
}
from
target
\
n
)
;
await
promiseNativeMouseEventWithAPZ
(
{
target
offsetX
:
mouseX
+
dx
offsetY
:
mouseY
+
dy
type
:
"
mousemove
"
}
)
;
}
return
function
(
)
{
return
promiseNativeMouseEventWithAPZ
(
{
target
offsetX
:
mouseX
+
distanceX
offsetY
:
mouseY
+
distanceY
type
:
"
mouseup
"
}
)
;
}
;
}
async
function
pinchZoomInTouchSequence
(
focusX
focusY
)
{
var
zoom_in
=
[
[
{
x
:
focusX
-
25
y
:
focusY
-
50
}
{
x
:
focusX
+
25
y
:
focusY
+
50
}
]
[
{
x
:
focusX
-
30
y
:
focusY
-
80
}
{
x
:
focusX
+
30
y
:
focusY
+
80
}
]
[
{
x
:
focusX
-
35
y
:
focusY
-
110
}
{
x
:
focusX
+
40
y
:
focusY
+
110
}
]
[
{
x
:
focusX
-
40
y
:
focusY
-
140
}
{
x
:
focusX
+
45
y
:
focusY
+
140
}
]
[
{
x
:
focusX
-
45
y
:
focusY
-
170
}
{
x
:
focusX
+
50
y
:
focusY
+
170
}
]
[
{
x
:
focusX
-
50
y
:
focusY
-
200
}
{
x
:
focusX
+
55
y
:
focusY
+
200
}
]
]
;
var
touchIds
=
[
0
1
]
;
return
synthesizeNativeTouchSequences
(
document
.
body
zoom_in
null
touchIds
)
;
}
function
promiseTopic
(
aTopic
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
SpecialPowers
.
Services
.
obs
.
addObserver
(
function
observer
(
subject
topic
data
)
{
try
{
SpecialPowers
.
Services
.
obs
.
removeObserver
(
observer
topic
)
;
resolve
(
[
subject
data
]
)
;
}
catch
(
ex
)
{
SpecialPowers
.
Services
.
obs
.
removeObserver
(
observer
topic
)
;
reject
(
ex
)
;
}
}
aTopic
)
;
}
)
;
}
function
promiseTransformEnd
(
)
{
return
promiseTopic
(
"
APZ
:
TransformEnd
"
)
;
}
function
promiseTouchEnd
(
element
count
=
1
)
{
return
new
Promise
(
resolve
=
>
{
var
eventCount
=
0
;
var
counterFunction
=
function
(
e
)
{
eventCount
+
+
;
if
(
eventCount
=
=
count
)
{
element
.
removeEventListener
(
"
touchend
"
counterFunction
{
passive
:
true
}
)
;
resolve
(
)
;
}
}
;
element
.
addEventListener
(
"
touchend
"
counterFunction
{
passive
:
true
}
)
;
}
)
;
}
async
function
pinchZoomInWithTouch
(
focusX
focusY
)
{
let
transformEndPromise
=
promiseTopic
(
"
APZ
:
TransformEnd
"
)
;
await
pinchZoomInTouchSequence
(
focusX
focusY
)
;
await
transformEndPromise
;
}
async
function
pinchZoomInWithTouchpad
(
focusX
focusY
options
=
{
}
)
{
var
zoomIn
=
[
1
.
0
1
.
019531
1
.
035156
1
.
037156
1
.
039156
1
.
054688
1
.
056688
1
.
070312
1
.
072312
1
.
089844
1
.
091844
1
.
109375
1
.
128906
1
.
144531
1
.
160156
1
.
175781
1
.
191406
1
.
207031
1
.
222656
1
.
234375
1
.
246094
1
.
261719
1
.
273438
1
.
285156
1
.
296875
1
.
3125
1
.
328125
1
.
347656
1
.
363281
1
.
382812
1
.
402344
1
.
421875
1
.
0
]
;
await
synthesizeTouchpadPinch
(
zoomIn
focusX
focusY
options
)
;
}
async
function
pinchZoomInAndPanWithTouchpad
(
options
=
{
}
)
{
var
x
=
584
;
var
y
=
347
;
var
scalesAndFoci
=
[
]
;
for
(
var
scale
=
1
.
0
;
scale
<
=
2
.
0
;
scale
+
=
0
.
2
)
{
scalesAndFoci
.
push
(
[
scale
x
y
]
)
;
}
for
(
var
i
=
1
;
i
<
=
20
;
i
+
+
)
{
x
-
=
4
;
y
-
=
5
;
scalesAndFoci
.
push
(
[
scale
+
0
.
01
*
i
x
y
]
)
;
}
await
synthesizeTouchpadGesture
(
scalesAndFoci
options
)
;
}
async
function
pinchZoomOutWithTouchpad
(
focusX
focusY
options
=
{
}
)
{
var
zoomOut
=
[
1
.
0
1
.
375
1
.
359375
1
.
339844
1
.
316406
1
.
296875
1
.
277344
1
.
257812
1
.
238281
1
.
21875
1
.
199219
1
.
175781
1
.
15625
1
.
132812
1
.
101562
1
.
078125
1
.
054688
1
.
03125
1
.
011719
0
.
992188
0
.
972656
0
.
953125
0
.
933594
1
.
0
]
;
await
synthesizeTouchpadPinch
(
zoomOut
focusX
focusY
options
)
;
}
async
function
pinchZoomInOutWithTouchpad
(
focusX
focusY
options
=
{
}
)
{
var
zoomInOut
=
[
1
.
0
1
.
082031
1
.
089844
1
.
097656
1
.
101562
1
.
109375
1
.
121094
1
.
128906
1
.
128906
1
.
125
1
.
097656
1
.
074219
1
.
054688
1
.
035156
1
.
015625
1
.
0
1
.
0
]
;
await
synthesizeTouchpadPinch
(
zoomInOut
focusX
focusY
options
)
;
}
async
function
synthesizeNativeTouchAndWaitForTransformEnd
(
touchSequence
touchIds
)
{
let
transformEndPromise
=
promiseTopic
(
"
APZ
:
TransformEnd
"
)
;
await
synthesizeNativeTouchSequences
(
document
.
body
touchSequence
null
touchIds
)
;
await
transformEndPromise
;
}
function
pinchZoomOutTouchSequenceAtCenter
(
)
{
const
deltaX
=
window
.
visualViewport
.
width
/
16
;
const
deltaY
=
window
.
visualViewport
.
height
/
16
;
const
centerX
=
window
.
visualViewport
.
pageLeft
+
window
.
visualViewport
.
width
/
2
;
const
centerY
=
window
.
visualViewport
.
pageTop
+
window
.
visualViewport
.
height
/
2
;
var
zoom_out
=
[
[
{
x
:
centerX
-
(
deltaX
*
6
)
y
:
centerY
-
(
deltaY
*
6
)
}
{
x
:
centerX
+
(
deltaX
*
6
)
y
:
centerY
+
(
deltaY
*
6
)
}
]
[
{
x
:
centerX
-
(
deltaX
*
5
)
y
:
centerY
-
(
deltaY
*
5
)
}
{
x
:
centerX
+
(
deltaX
*
5
)
y
:
centerY
+
(
deltaY
*
5
)
}
]
[
{
x
:
centerX
-
(
deltaX
*
4
)
y
:
centerY
-
(
deltaY
*
4
)
}
{
x
:
centerX
+
(
deltaX
*
4
)
y
:
centerY
+
(
deltaY
*
4
)
}
]
[
{
x
:
centerX
-
(
deltaX
*
3
)
y
:
centerY
-
(
deltaY
*
3
)
}
{
x
:
centerX
+
(
deltaX
*
3
)
y
:
centerY
+
(
deltaY
*
3
)
}
]
[
{
x
:
centerX
-
(
deltaX
*
2
)
y
:
centerY
-
(
deltaY
*
2
)
}
{
x
:
centerX
+
(
deltaX
*
2
)
y
:
centerY
+
(
deltaY
*
2
)
}
]
[
{
x
:
centerX
-
(
deltaX
*
1
)
y
:
centerY
-
(
deltaY
*
1
)
}
{
x
:
centerX
+
(
deltaX
*
1
)
y
:
centerY
+
(
deltaY
*
1
)
}
]
]
;
return
zoom_out
;
}
async
function
pinchZoomOutWithTouchAtCenter
(
)
{
var
zoom_out
=
pinchZoomOutTouchSequenceAtCenter
(
)
;
var
touchIds
=
[
0
1
]
;
await
synthesizeNativeTouchAndWaitForTransformEnd
(
zoom_out
touchIds
)
;
}
async
function
synthesizeDoubleTap
(
element
x
y
useTouchpad
)
{
if
(
useTouchpad
)
{
await
synthesizeNativeTouchpadDoubleTap
(
element
x
y
)
;
}
else
{
await
synthesizeNativeTap
(
element
x
y
)
;
await
synthesizeNativeTap
(
element
x
y
)
;
}
}
async
function
doubleTapOn
(
element
x
y
useTouchpad
)
{
let
transformEndPromise
=
promiseTransformEnd
(
)
;
await
synthesizeDoubleTap
(
element
x
y
useTouchpad
)
;
await
transformEndPromise
;
await
promiseApzFlushedRepaints
(
)
;
}
