add_task
(
async
function
setup_pref
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
layout
.
throttled_frame_rate
"
60
]
[
"
dom
.
animations
-
api
.
getAnimations
.
enabled
"
true
]
[
"
dom
.
animations
-
api
.
timelines
.
enabled
"
true
]
[
"
test
.
events
.
async
.
enabled
"
true
]
[
"
apz
.
test
.
logging_enabled
"
true
]
]
}
)
;
}
)
;
add_task
(
async
function
test_main
(
)
{
function
httpURL
(
filename
)
{
let
chromeURL
=
getRootDirectory
(
gTestPath
)
+
filename
;
return
chromeURL
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
mochi
.
test
:
8888
/
"
)
;
}
var
utils
=
SpecialPowers
.
getDOMWindowUtils
(
window
)
;
var
isWebRender
=
utils
.
layerManagerType
.
startsWith
(
"
WebRender
"
)
;
var
subtests
=
[
{
file
:
"
helper_fission_basic
.
html
"
}
{
file
:
"
helper_fission_transforms
.
html
"
}
{
file
:
"
helper_fission_scroll_oopif
.
html
"
}
{
file
:
"
helper_fission_event_region_override
.
html
"
setup
(
win
)
{
win
.
document
.
addEventListener
(
"
wheel
"
e
=
>
e
.
preventDefault
(
)
{
once
:
true
passive
:
false
}
)
;
}
}
{
file
:
"
helper_fission_animation_styling_in_oopif
.
html
"
}
{
file
:
"
helper_fission_force_empty_hit_region
.
html
"
}
{
file
:
"
helper_fission_touch
.
html
"
}
{
file
:
"
helper_fission_tap
.
html
"
prefs
:
[
[
"
apz
.
max_tap_time
"
10000
]
]
}
{
file
:
"
helper_fission_inactivescroller_under_oopif
.
html
"
}
{
file
:
"
helper_fission_tap_on_zoomed
.
html
"
prefs
:
[
[
"
apz
.
max_tap_time
"
10000
]
]
}
{
file
:
"
helper_fission_tap_in_nested_iframe_on_zoomed
.
html
"
prefs
:
[
[
"
apz
.
max_tap_time
"
10000
]
]
}
{
file
:
"
helper_fission_scroll_handoff
.
html
"
}
{
file
:
"
helper_fission_large_subframe
.
html
"
}
]
;
if
(
isWebRender
)
{
subtests
=
subtests
.
concat
(
[
{
file
:
"
helper_fission_inactivescroller_positionedcontent
.
html
"
}
]
)
;
}
else
{
subtests
=
subtests
.
concat
(
[
{
file
:
"
helper_fission_animation_styling_in_transformed_oopif
.
html
"
}
]
)
;
}
requestLongerTimeout
(
subtests
.
length
)
;
let
fissionWindow
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
{
fission
:
true
}
)
;
const
{
FissionTestHelperParent
}
=
ChromeUtils
.
import
(
getRootDirectory
(
gTestPath
)
+
"
FissionTestHelperParent
.
jsm
"
)
;
FissionTestHelperParent
.
SimpleTest
=
SimpleTest
;
ChromeUtils
.
registerWindowActor
(
"
FissionTestHelper
"
{
parent
:
{
moduleURI
:
getRootDirectory
(
gTestPath
)
+
"
FissionTestHelperParent
.
jsm
"
}
child
:
{
moduleURI
:
getRootDirectory
(
gTestPath
)
+
"
FissionTestHelperChild
.
jsm
"
events
:
{
"
FissionTestHelper
:
Init
"
:
{
capture
:
true
wantUntrusted
:
true
}
}
}
allFrames
:
true
}
)
;
try
{
var
onlyOneSubtest
=
SpecialPowers
.
getCharPref
(
"
apz
.
subtest
"
"
"
)
;
for
(
var
subtest
of
subtests
)
{
if
(
onlyOneSubtest
&
&
onlyOneSubtest
!
=
subtest
.
file
)
{
SimpleTest
.
ok
(
true
"
Skipping
"
+
subtest
.
file
+
"
because
only
"
+
onlyOneSubtest
+
"
is
being
run
"
)
;
continue
;
}
let
url
=
httpURL
(
subtest
.
file
)
;
dump
(
Starting
test
{
url
}
\
n
)
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
:
fissionWindow
.
gBrowser
url
}
async
browser
=
>
{
let
tabActor
=
browser
.
browsingContext
.
currentWindowGlobal
.
getActor
(
"
FissionTestHelper
"
)
;
let
donePromise
=
tabActor
.
getTestCompletePromise
(
)
;
if
(
subtest
.
setup
)
{
subtest
.
setup
(
fissionWindow
)
;
}
tabActor
.
startTest
(
)
;
await
donePromise
;
}
)
;
dump
(
Finished
test
{
url
}
\
n
)
;
}
}
finally
{
delete
FissionTestHelperParent
.
SimpleTest
;
ChromeUtils
.
unregisterWindowActor
(
"
FissionTestHelper
"
)
;
await
BrowserTestUtils
.
closeWindow
(
fissionWindow
)
;
}
}
)
;
