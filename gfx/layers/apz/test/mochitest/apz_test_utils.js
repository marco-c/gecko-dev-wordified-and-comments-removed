function
convertEntries
(
entries
)
{
var
result
=
{
}
;
for
(
var
i
=
0
;
i
<
entries
.
length
;
+
+
i
)
{
result
[
entries
[
i
]
.
key
]
=
entries
[
i
]
.
value
;
}
return
result
;
}
function
getPropertyAsRect
(
scrollFrames
scrollId
prop
)
{
SimpleTest
.
ok
(
scrollId
in
scrollFrames
'
expected
scroll
frame
data
for
scroll
id
'
+
scrollId
)
;
var
scrollFrameData
=
scrollFrames
[
scrollId
]
;
SimpleTest
.
ok
(
'
displayport
'
in
scrollFrameData
'
expected
a
'
+
prop
+
'
for
scroll
id
'
+
scrollId
)
;
var
value
=
scrollFrameData
[
prop
]
;
var
pieces
=
value
.
replace
(
/
[
(
)
\
s
]
+
/
g
'
'
)
.
split
(
'
'
)
;
SimpleTest
.
is
(
pieces
.
length
4
"
expected
string
of
form
(
x
y
w
h
)
"
)
;
return
{
x
:
parseInt
(
pieces
[
0
]
)
y
:
parseInt
(
pieces
[
1
]
)
w
:
parseInt
(
pieces
[
2
]
)
h
:
parseInt
(
pieces
[
3
]
)
}
;
}
function
convertScrollFrameData
(
scrollFrames
)
{
var
result
=
{
}
;
for
(
var
i
=
0
;
i
<
scrollFrames
.
length
;
+
+
i
)
{
result
[
scrollFrames
[
i
]
.
scrollId
]
=
convertEntries
(
scrollFrames
[
i
]
.
entries
)
;
}
return
result
;
}
function
convertBuckets
(
buckets
)
{
var
result
=
{
}
;
for
(
var
i
=
0
;
i
<
buckets
.
length
;
+
+
i
)
{
result
[
buckets
[
i
]
.
sequenceNumber
]
=
convertScrollFrameData
(
buckets
[
i
]
.
scrollFrames
)
;
}
return
result
;
}
function
convertTestData
(
testData
)
{
var
result
=
{
}
;
result
.
paints
=
convertBuckets
(
testData
.
paints
)
;
result
.
repaintRequests
=
convertBuckets
(
testData
.
repaintRequests
)
;
return
result
;
}
function
buildApzcTree
(
paint
)
{
var
root
=
{
scrollId
:
-
1
children
:
[
]
}
;
for
(
var
scrollId
in
paint
)
{
paint
[
scrollId
]
.
children
=
[
]
;
paint
[
scrollId
]
.
scrollId
=
scrollId
;
}
for
(
var
scrollId
in
paint
)
{
var
parentNode
=
null
;
if
(
"
hasNoParentWithSameLayersId
"
in
paint
[
scrollId
]
)
{
parentNode
=
root
;
}
else
if
(
"
parentScrollId
"
in
paint
[
scrollId
]
)
{
parentNode
=
paint
[
paint
[
scrollId
]
.
parentScrollId
]
;
}
parentNode
.
children
.
push
(
paint
[
scrollId
]
)
;
}
return
root
;
}
function
findRcdNode
(
apzcTree
)
{
if
(
!
!
apzcTree
.
isRootContent
)
{
return
apzcTree
;
}
for
(
var
i
=
0
;
i
<
apzcTree
.
children
.
length
;
i
+
+
)
{
var
rcd
=
findRcdNode
(
apzcTree
.
children
[
i
]
)
;
if
(
rcd
!
=
null
)
{
return
rcd
;
}
}
return
null
;
}
function
isLayerized
(
elementId
)
{
var
contentTestData
=
SpecialPowers
.
getDOMWindowUtils
(
window
)
.
getContentAPZTestData
(
)
;
ok
(
contentTestData
.
paints
.
length
>
0
"
expected
at
least
one
paint
"
)
;
var
seqno
=
contentTestData
.
paints
[
contentTestData
.
paints
.
length
-
1
]
.
sequenceNumber
;
contentTestData
=
convertTestData
(
contentTestData
)
;
var
paint
=
contentTestData
.
paints
[
seqno
]
;
for
(
var
scrollId
in
paint
)
{
if
(
"
contentDescription
"
in
paint
[
scrollId
]
)
{
if
(
paint
[
scrollId
]
[
"
contentDescription
"
]
.
includes
(
elementId
)
)
{
return
true
;
}
}
}
return
false
;
}
function
flushApzRepaints
(
aCallback
aWindow
=
window
)
{
if
(
!
aCallback
)
{
throw
"
A
callback
must
be
provided
!
"
;
}
var
repaintDone
=
function
(
)
{
SpecialPowers
.
Services
.
obs
.
removeObserver
(
repaintDone
"
apz
-
repaints
-
flushed
"
)
;
setTimeout
(
aCallback
0
)
;
}
;
SpecialPowers
.
Services
.
obs
.
addObserver
(
repaintDone
"
apz
-
repaints
-
flushed
"
)
;
if
(
SpecialPowers
.
getDOMWindowUtils
(
aWindow
)
.
flushApzRepaints
(
)
)
{
dump
(
"
Flushed
APZ
repaints
waiting
for
callback
.
.
.
\
n
"
)
;
}
else
{
dump
(
"
Flushing
APZ
repaints
was
a
no
-
op
triggering
callback
directly
.
.
.
\
n
"
)
;
repaintDone
(
)
;
}
}
function
waitForApzFlushedRepaints
(
aCallback
)
{
waitForAllPaints
(
function
(
)
{
flushApzRepaints
(
function
(
)
{
waitForAllPaints
(
aCallback
)
;
}
)
;
}
)
;
}
function
runSubtestsSeriallyInFreshWindows
(
aSubtests
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
var
testIndex
=
-
1
;
var
w
=
null
;
function
advanceSubtestExecution
(
)
{
var
test
=
aSubtests
[
testIndex
]
;
if
(
w
)
{
if
(
typeof
test
.
dp_suppression
!
=
'
undefined
'
)
{
SpecialPowers
.
getDOMWindowUtils
(
window
)
.
respectDisplayPortSuppression
(
!
test
.
dp_suppression
)
;
}
if
(
test
.
prefs
)
{
SpecialPowers
.
popPrefEnv
(
function
(
)
{
w
.
close
(
)
;
w
=
null
;
advanceSubtestExecution
(
)
;
}
)
;
return
;
}
w
.
close
(
)
;
}
testIndex
+
+
;
if
(
testIndex
>
=
aSubtests
.
length
)
{
resolve
(
)
;
return
;
}
test
=
aSubtests
[
testIndex
]
;
if
(
typeof
test
.
dp_suppression
!
=
'
undefined
'
)
{
SpecialPowers
.
getDOMWindowUtils
(
window
)
.
respectDisplayPortSuppression
(
test
.
dp_suppression
)
;
}
function
spawnTest
(
aFile
)
{
w
=
window
.
open
(
'
'
"
_blank
"
)
;
w
.
subtestDone
=
advanceSubtestExecution
;
w
.
SimpleTest
=
SimpleTest
;
w
.
is
=
function
(
a
b
msg
)
{
return
is
(
a
b
aFile
+
"
|
"
+
msg
)
;
}
;
w
.
ok
=
function
(
cond
name
diag
)
{
return
ok
(
cond
aFile
+
"
|
"
+
name
diag
)
;
}
;
if
(
test
.
onload
)
{
w
.
addEventListener
(
'
load
'
function
(
e
)
{
test
.
onload
(
w
)
;
}
{
once
:
true
}
)
;
}
w
.
location
=
location
.
href
.
substring
(
0
location
.
href
.
lastIndexOf
(
'
/
'
)
+
1
)
+
aFile
;
return
w
;
}
if
(
test
.
prefs
)
{
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
test
.
prefs
}
function
(
)
{
w
=
spawnTest
(
test
.
file
)
;
}
)
;
}
else
{
w
=
spawnTest
(
test
.
file
)
;
}
}
advanceSubtestExecution
(
)
;
}
)
;
}
function
pushPrefs
(
prefs
)
{
return
SpecialPowers
.
pushPrefEnv
(
{
'
set
'
:
prefs
}
)
;
}
function
waitUntilApzStable
(
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
SimpleTest
.
waitForFocus
(
function
(
)
{
waitForAllPaints
(
function
(
)
{
flushApzRepaints
(
resolve
)
;
}
)
;
}
window
)
;
}
)
;
}
function
isApzEnabled
(
)
{
var
enabled
=
SpecialPowers
.
getDOMWindowUtils
(
window
)
.
asyncPanZoomEnabled
;
if
(
!
enabled
)
{
SimpleTest
.
ok
(
true
"
APZ
is
not
enabled
;
this
test
will
be
skipped
"
)
;
}
return
enabled
;
}
function
isKeyApzEnabled
(
)
{
return
isApzEnabled
(
)
&
&
SpecialPowers
.
getBoolPref
(
"
apz
.
keyboard
.
enabled
"
)
;
}
function
runContinuation
(
testFunction
)
{
return
function
(
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
var
testContinuation
=
null
;
function
driveTest
(
)
{
if
(
!
testContinuation
)
{
testContinuation
=
testFunction
(
driveTest
)
;
}
var
ret
=
testContinuation
.
next
(
)
;
if
(
ret
.
done
)
{
resolve
(
)
;
}
}
driveTest
(
)
;
}
)
;
}
;
}
function
getSnapshot
(
rect
)
{
function
parentProcessSnapshot
(
)
{
addMessageListener
(
'
snapshot
'
function
(
rect
)
{
ChromeUtils
.
import
(
'
resource
:
/
/
gre
/
modules
/
Services
.
jsm
'
)
;
var
topWin
=
Services
.
wm
.
getMostRecentWindow
(
'
navigator
:
browser
'
)
;
rect
=
JSON
.
parse
(
rect
)
;
rect
.
x
-
=
topWin
.
mozInnerScreenX
;
rect
.
y
-
=
topWin
.
mozInnerScreenY
;
var
canvas
=
topWin
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
canvas
.
width
=
rect
.
w
;
canvas
.
height
=
rect
.
h
;
var
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
drawWindow
(
topWin
rect
.
x
rect
.
y
rect
.
w
rect
.
h
'
rgb
(
255
255
255
)
'
ctx
.
DRAWWINDOW_DRAW_VIEW
|
ctx
.
DRAWWINDOW_USE_WIDGET_LAYERS
|
ctx
.
DRAWWINDOW_DRAW_CARET
)
;
return
canvas
.
toDataURL
(
)
;
}
)
;
}
if
(
typeof
getSnapshot
.
chromeHelper
=
=
'
undefined
'
)
{
getSnapshot
.
chromeHelper
=
SpecialPowers
.
loadChromeScript
(
parentProcessSnapshot
)
;
SimpleTest
.
registerCleanupFunction
(
function
(
)
{
getSnapshot
.
chromeHelper
.
destroy
(
)
}
)
;
}
return
getSnapshot
.
chromeHelper
.
sendSyncMessage
(
'
snapshot
'
JSON
.
stringify
(
rect
)
)
.
toString
(
)
;
}
function
getQueryArgs
(
)
{
var
args
=
{
}
;
if
(
location
.
search
.
length
>
0
)
{
var
params
=
location
.
search
.
substr
(
1
)
.
split
(
'
&
'
)
;
for
(
var
p
of
params
)
{
var
[
k
v
]
=
p
.
split
(
'
=
'
)
;
args
[
k
]
=
JSON
.
parse
(
v
)
;
}
}
return
args
;
}
function
injectScript
(
aScript
aWindow
=
window
)
{
return
function
(
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
var
e
=
aWindow
.
document
.
createElement
(
'
script
'
)
;
e
.
type
=
'
text
/
javascript
'
;
e
.
onload
=
function
(
)
{
resolve
(
)
;
}
;
e
.
onerror
=
function
(
)
{
dump
(
'
Script
[
'
+
aScript
+
'
]
errored
out
\
n
'
)
;
reject
(
)
;
}
;
e
.
src
=
aScript
;
aWindow
.
document
.
getElementsByTagName
(
'
head
'
)
[
0
]
.
appendChild
(
e
)
;
}
)
;
}
;
}
