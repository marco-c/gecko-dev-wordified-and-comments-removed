function
convertEntries
(
entries
)
{
var
result
=
{
}
;
for
(
var
i
=
0
;
i
<
entries
.
length
;
+
+
i
)
{
result
[
entries
[
i
]
.
key
]
=
entries
[
i
]
.
value
;
}
return
result
;
}
function
getPropertyAsRect
(
scrollFrames
scrollId
prop
)
{
SimpleTest
.
ok
(
scrollId
in
scrollFrames
'
expected
scroll
frame
data
for
scroll
id
'
+
scrollId
)
;
var
scrollFrameData
=
scrollFrames
[
scrollId
]
;
SimpleTest
.
ok
(
'
displayport
'
in
scrollFrameData
'
expected
a
'
+
prop
+
'
for
scroll
id
'
+
scrollId
)
;
var
value
=
scrollFrameData
[
prop
]
;
var
pieces
=
value
.
replace
(
/
[
(
)
\
s
]
+
/
g
'
'
)
.
split
(
'
'
)
;
SimpleTest
.
is
(
pieces
.
length
4
"
expected
string
of
form
(
x
y
w
h
)
"
)
;
return
{
x
:
parseInt
(
pieces
[
0
]
)
y
:
parseInt
(
pieces
[
1
]
)
w
:
parseInt
(
pieces
[
2
]
)
h
:
parseInt
(
pieces
[
3
]
)
}
;
}
function
convertScrollFrameData
(
scrollFrames
)
{
var
result
=
{
}
;
for
(
var
i
=
0
;
i
<
scrollFrames
.
length
;
+
+
i
)
{
result
[
scrollFrames
[
i
]
.
scrollId
]
=
convertEntries
(
scrollFrames
[
i
]
.
entries
)
;
}
return
result
;
}
function
convertBuckets
(
buckets
)
{
var
result
=
{
}
;
for
(
var
i
=
0
;
i
<
buckets
.
length
;
+
+
i
)
{
result
[
buckets
[
i
]
.
sequenceNumber
]
=
convertScrollFrameData
(
buckets
[
i
]
.
scrollFrames
)
;
}
return
result
;
}
function
convertTestData
(
testData
)
{
var
result
=
{
}
;
result
.
paints
=
convertBuckets
(
testData
.
paints
)
;
result
.
repaintRequests
=
convertBuckets
(
testData
.
repaintRequests
)
;
return
result
;
}
function
buildApzcTree
(
paint
)
{
var
root
=
{
scrollId
:
-
1
children
:
[
]
}
;
for
(
var
scrollId
in
paint
)
{
paint
[
scrollId
]
.
children
=
[
]
;
paint
[
scrollId
]
.
scrollId
=
scrollId
;
}
for
(
var
scrollId
in
paint
)
{
var
parentNode
=
null
;
if
(
"
hasNoParentWithSameLayersId
"
in
paint
[
scrollId
]
)
{
parentNode
=
root
;
}
else
if
(
"
parentScrollId
"
in
paint
[
scrollId
]
)
{
parentNode
=
paint
[
paint
[
scrollId
]
.
parentScrollId
]
;
}
parentNode
.
children
.
push
(
paint
[
scrollId
]
)
;
}
return
root
;
}
function
findRcdNode
(
apzcTree
)
{
if
(
!
!
apzcTree
.
isRootContent
)
{
return
apzcTree
;
}
for
(
var
i
=
0
;
i
<
apzcTree
.
children
.
length
;
i
+
+
)
{
var
rcd
=
findRcdNode
(
apzcTree
.
children
[
i
]
)
;
if
(
rcd
!
=
null
)
{
return
rcd
;
}
}
return
null
;
}
function
isLayerized
(
elementId
)
{
var
contentTestData
=
SpecialPowers
.
getDOMWindowUtils
(
window
)
.
getContentAPZTestData
(
)
;
ok
(
contentTestData
.
paints
.
length
>
0
"
expected
at
least
one
paint
"
)
;
var
seqno
=
contentTestData
.
paints
[
contentTestData
.
paints
.
length
-
1
]
.
sequenceNumber
;
contentTestData
=
convertTestData
(
contentTestData
)
;
var
paint
=
contentTestData
.
paints
[
seqno
]
;
for
(
var
scrollId
in
paint
)
{
if
(
"
contentDescription
"
in
paint
[
scrollId
]
)
{
if
(
paint
[
scrollId
]
[
"
contentDescription
"
]
.
includes
(
elementId
)
)
{
return
true
;
}
}
}
return
false
;
}
function
promiseApzRepaintsFlushed
(
aWindow
=
window
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
var
repaintDone
=
function
(
)
{
SpecialPowers
.
Services
.
obs
.
removeObserver
(
repaintDone
"
apz
-
repaints
-
flushed
"
)
;
setTimeout
(
resolve
0
)
;
}
;
SpecialPowers
.
Services
.
obs
.
addObserver
(
repaintDone
"
apz
-
repaints
-
flushed
"
)
;
if
(
SpecialPowers
.
getDOMWindowUtils
(
aWindow
)
.
flushApzRepaints
(
)
)
{
dump
(
"
Flushed
APZ
repaints
waiting
for
callback
.
.
.
\
n
"
)
;
}
else
{
dump
(
"
Flushing
APZ
repaints
was
a
no
-
op
triggering
callback
directly
.
.
.
\
n
"
)
;
repaintDone
(
)
;
}
}
)
;
}
function
flushApzRepaints
(
aCallback
aWindow
=
window
)
{
if
(
!
aCallback
)
{
throw
"
A
callback
must
be
provided
!
"
;
}
promiseApzRepaintsFlushed
(
aWindow
)
.
then
(
aCallback
)
;
}
function
waitForApzFlushedRepaints
(
aCallback
)
{
promiseAllPaintsDone
(
)
.
then
(
(
)
=
>
promiseApzRepaintsFlushed
(
)
)
.
then
(
promiseAllPaintsDone
)
.
then
(
aCallback
)
;
}
function
runSubtestsSeriallyInFreshWindows
(
aSubtests
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
var
testIndex
=
-
1
;
var
w
=
null
;
var
onlyOneSubtest
=
SpecialPowers
.
getCharPref
(
"
apz
.
subtest
"
"
"
)
;
function
advanceSubtestExecution
(
)
{
var
test
=
aSubtests
[
testIndex
]
;
if
(
w
)
{
if
(
w
.
ApzCleanup
)
{
w
.
ApzCleanup
.
execute
(
)
;
}
if
(
typeof
test
.
dp_suppression
!
=
'
undefined
'
)
{
SpecialPowers
.
getDOMWindowUtils
(
window
)
.
respectDisplayPortSuppression
(
!
test
.
dp_suppression
)
;
}
if
(
test
.
prefs
)
{
SpecialPowers
.
popPrefEnv
(
function
(
)
{
w
.
close
(
)
;
w
=
null
;
advanceSubtestExecution
(
)
;
}
)
;
return
;
}
w
.
close
(
)
;
}
testIndex
+
+
;
if
(
testIndex
>
=
aSubtests
.
length
)
{
resolve
(
)
;
return
;
}
test
=
aSubtests
[
testIndex
]
;
if
(
onlyOneSubtest
&
&
onlyOneSubtest
!
=
test
.
file
)
{
SimpleTest
.
ok
(
true
"
Skipping
"
+
test
.
file
+
"
because
only
"
+
onlyOneSubtest
+
"
is
being
run
"
)
;
setTimeout
(
function
(
)
{
advanceSubtestExecution
(
)
;
}
0
)
;
return
;
}
if
(
typeof
test
.
dp_suppression
!
=
'
undefined
'
)
{
SpecialPowers
.
getDOMWindowUtils
(
window
)
.
respectDisplayPortSuppression
(
test
.
dp_suppression
)
;
}
function
spawnTest
(
aFile
)
{
w
=
window
.
open
(
'
'
"
_blank
"
)
;
w
.
subtestDone
=
advanceSubtestExecution
;
w
.
isApzSubtest
=
true
;
w
.
SimpleTest
=
SimpleTest
;
w
.
is
=
function
(
a
b
msg
)
{
return
is
(
a
b
aFile
+
"
|
"
+
msg
)
;
}
;
w
.
ok
=
function
(
cond
name
diag
)
{
return
ok
(
cond
aFile
+
"
|
"
+
name
diag
)
;
}
;
if
(
test
.
onload
)
{
w
.
addEventListener
(
'
load
'
function
(
e
)
{
test
.
onload
(
w
)
;
}
{
once
:
true
}
)
;
}
var
subtestUrl
=
location
.
href
.
substring
(
0
location
.
href
.
lastIndexOf
(
'
/
'
)
+
1
)
+
aFile
;
function
urlResolves
(
url
)
{
var
request
=
new
XMLHttpRequest
(
)
;
request
.
open
(
'
GET
'
url
false
)
;
request
.
send
(
)
;
return
request
.
status
!
=
=
404
;
}
if
(
!
urlResolves
(
subtestUrl
)
)
{
SimpleTest
.
ok
(
false
"
Subtest
URL
"
+
subtestUrl
+
"
does
not
resolve
.
"
+
"
Be
sure
it
'
s
present
in
the
support
-
files
section
of
mochitest
.
ini
.
"
)
;
reject
(
)
;
return
;
}
w
.
location
=
subtestUrl
;
return
w
;
}
if
(
test
.
prefs
)
{
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
test
.
prefs
}
function
(
)
{
w
=
spawnTest
(
test
.
file
)
;
}
)
;
}
else
{
w
=
spawnTest
(
test
.
file
)
;
}
}
advanceSubtestExecution
(
)
;
}
)
.
catch
(
function
(
e
)
{
SimpleTest
.
ok
(
false
"
Error
occurred
while
running
subtests
:
"
+
e
)
;
}
)
;
}
function
pushPrefs
(
prefs
)
{
return
SpecialPowers
.
pushPrefEnv
(
{
'
set
'
:
prefs
}
)
;
}
async
function
waitUntilApzStable
(
)
{
if
(
!
SpecialPowers
.
isMainProcess
(
)
)
{
function
parentProcessFlush
(
)
{
addMessageListener
(
"
apz
-
flush
"
function
(
)
{
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
topWin
=
Services
.
wm
.
getMostRecentWindow
(
'
navigator
:
browser
'
)
;
if
(
!
topWin
)
{
topWin
=
Services
.
wm
.
getMostRecentWindow
(
'
navigator
:
geckoview
'
)
;
}
var
topUtils
=
topWin
.
windowUtils
;
var
repaintDone
=
function
(
)
{
Services
.
obs
.
removeObserver
(
repaintDone
"
apz
-
repaints
-
flushed
"
)
;
sendAsyncMessage
(
"
apz
-
flush
-
done
"
null
)
;
}
;
var
flushRepaint
=
function
(
)
{
if
(
topUtils
.
isMozAfterPaintPending
)
{
topWin
.
addEventListener
(
"
MozAfterPaint
"
flushRepaint
{
once
:
true
}
)
;
return
;
}
Services
.
obs
.
addObserver
(
repaintDone
"
apz
-
repaints
-
flushed
"
)
;
if
(
topUtils
.
flushApzRepaints
(
)
)
{
dump
(
"
Parent
process
:
flushed
APZ
repaints
waiting
for
callback
.
.
.
\
n
"
)
;
}
else
{
dump
(
"
Parent
process
:
flushing
APZ
repaints
was
a
no
-
op
triggering
callback
directly
.
.
.
\
n
"
)
;
repaintDone
(
)
;
}
}
flushRepaint
(
)
;
}
)
;
}
if
(
typeof
waitUntilApzStable
.
chromeHelper
=
=
"
undefined
"
)
{
waitUntilApzStable
.
chromeHelper
=
SpecialPowers
.
loadChromeScript
(
parentProcessFlush
)
;
ApzCleanup
.
register
(
(
)
=
>
{
waitUntilApzStable
.
chromeHelper
.
destroy
(
)
;
}
)
;
}
waitUntilApzStable
.
chromeHelper
.
sendAsyncMessage
(
"
apz
-
flush
"
null
)
;
await
waitUntilApzStable
.
chromeHelper
.
promiseOneMessage
(
"
apz
-
flush
-
done
"
)
;
}
await
SimpleTest
.
promiseFocus
(
window
)
;
await
promiseAllPaintsDone
(
)
;
await
promiseApzRepaintsFlushed
(
)
;
}
async
function
forceLayerTreeToCompositor
(
)
{
var
utils
=
SpecialPowers
.
getDOMWindowUtils
(
window
)
;
if
(
!
utils
.
isMozAfterPaintPending
)
{
dump
(
"
Forcing
a
paint
since
none
was
pending
already
.
.
.
\
n
"
)
;
var
testMode
=
utils
.
isTestControllingRefreshes
;
utils
.
advanceTimeAndRefresh
(
0
)
;
if
(
!
testMode
)
{
utils
.
restoreNormalRefresh
(
)
;
}
}
await
promiseAllPaintsDone
(
null
true
)
;
await
promiseApzRepaintsFlushed
(
)
;
}
function
isApzEnabled
(
)
{
var
enabled
=
SpecialPowers
.
getDOMWindowUtils
(
window
)
.
asyncPanZoomEnabled
;
if
(
!
enabled
)
{
SimpleTest
.
ok
(
true
"
APZ
is
not
enabled
;
this
test
will
be
skipped
"
)
;
}
return
enabled
;
}
function
isKeyApzEnabled
(
)
{
return
isApzEnabled
(
)
&
&
SpecialPowers
.
getBoolPref
(
"
apz
.
keyboard
.
enabled
"
)
;
}
function
runContinuation
(
testFunction
)
{
return
function
(
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
var
testContinuation
=
null
;
function
driveTest
(
)
{
if
(
!
testContinuation
)
{
testContinuation
=
testFunction
(
driveTest
)
;
}
var
ret
=
testContinuation
.
next
(
)
;
if
(
ret
.
done
)
{
resolve
(
)
;
}
}
driveTest
(
)
;
}
)
;
}
;
}
function
getSnapshot
(
rect
)
{
function
parentProcessSnapshot
(
)
{
addMessageListener
(
'
snapshot
'
function
(
rect
)
{
ChromeUtils
.
import
(
'
resource
:
/
/
gre
/
modules
/
Services
.
jsm
'
)
;
var
topWin
=
Services
.
wm
.
getMostRecentWindow
(
'
navigator
:
browser
'
)
;
if
(
!
topWin
)
{
topWin
=
Services
.
wm
.
getMostRecentWindow
(
'
navigator
:
geckoview
'
)
;
}
rect
=
JSON
.
parse
(
rect
)
;
rect
.
x
-
=
topWin
.
mozInnerScreenX
;
rect
.
y
-
=
topWin
.
mozInnerScreenY
;
var
canvas
=
topWin
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
canvas
.
width
=
rect
.
w
;
canvas
.
height
=
rect
.
h
;
var
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
drawWindow
(
topWin
rect
.
x
rect
.
y
rect
.
w
rect
.
h
'
rgb
(
255
255
255
)
'
ctx
.
DRAWWINDOW_DRAW_VIEW
|
ctx
.
DRAWWINDOW_USE_WIDGET_LAYERS
|
ctx
.
DRAWWINDOW_DRAW_CARET
)
;
return
canvas
.
toDataURL
(
)
;
}
)
;
}
if
(
typeof
getSnapshot
.
chromeHelper
=
=
'
undefined
'
)
{
getSnapshot
.
chromeHelper
=
SpecialPowers
.
loadChromeScript
(
parentProcessSnapshot
)
;
ApzCleanup
.
register
(
function
(
)
{
getSnapshot
.
chromeHelper
.
destroy
(
)
}
)
;
}
return
getSnapshot
.
chromeHelper
.
sendSyncMessage
(
'
snapshot
'
JSON
.
stringify
(
rect
)
)
.
toString
(
)
;
}
function
getQueryArgs
(
)
{
var
args
=
{
}
;
if
(
location
.
search
.
length
>
0
)
{
var
params
=
location
.
search
.
substr
(
1
)
.
split
(
'
&
'
)
;
for
(
var
p
of
params
)
{
var
[
k
v
]
=
p
.
split
(
'
=
'
)
;
args
[
k
]
=
JSON
.
parse
(
v
)
;
}
}
return
args
;
}
function
injectScript
(
aScript
aWindow
=
window
)
{
return
function
(
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
var
e
=
aWindow
.
document
.
createElement
(
'
script
'
)
;
e
.
type
=
'
text
/
javascript
'
;
e
.
onload
=
function
(
)
{
resolve
(
)
;
}
;
e
.
onerror
=
function
(
)
{
dump
(
'
Script
[
'
+
aScript
+
'
]
errored
out
\
n
'
)
;
reject
(
)
;
}
;
e
.
src
=
aScript
;
aWindow
.
document
.
getElementsByTagName
(
'
head
'
)
[
0
]
.
appendChild
(
e
)
;
}
)
;
}
;
}
function
getHitTestConfig
(
)
{
if
(
!
(
"
hitTestConfig
"
in
window
)
)
{
var
utils
=
SpecialPowers
.
getDOMWindowUtils
(
window
)
;
var
isWebRender
=
(
utils
.
layerManagerType
=
=
'
WebRender
'
)
;
var
isWindows
=
(
getPlatform
(
)
=
=
'
windows
'
)
;
window
.
hitTestConfig
=
{
utils
isWebRender
isWindows
}
;
}
return
window
.
hitTestConfig
;
}
function
centerOf
(
element
)
{
if
(
typeof
element
=
=
=
"
string
"
)
{
element
=
document
.
getElementById
(
element
)
;
}
var
bounds
=
element
.
getBoundingClientRect
(
)
;
return
{
x
:
bounds
.
x
+
(
bounds
.
width
/
2
)
y
:
bounds
.
y
+
(
bounds
.
height
/
2
)
}
;
}
function
hitTest
(
point
)
{
var
utils
=
getHitTestConfig
(
)
.
utils
;
dump
(
"
Hit
-
testing
point
(
"
+
point
.
x
+
"
"
+
point
.
y
+
"
)
\
n
"
)
;
utils
.
sendMouseEvent
(
"
MozMouseHittest
"
point
.
x
point
.
y
0
0
0
true
0
0
true
true
)
;
var
data
=
utils
.
getCompositorAPZTestData
(
)
;
ok
(
data
.
hitResults
.
length
>
=
1
"
Expected
at
least
one
hit
result
in
the
APZTestData
"
)
;
var
result
=
data
.
hitResults
[
data
.
hitResults
.
length
-
1
]
;
return
{
hitInfo
:
result
.
hitResult
scrollId
:
result
.
scrollId
}
;
}
function
hitInfoToString
(
hitInfo
)
{
var
strs
=
[
]
;
for
(
var
flag
in
APZHitResultFlags
)
{
if
(
(
hitInfo
&
APZHitResultFlags
[
flag
]
)
!
=
0
)
{
strs
.
push
(
flag
)
;
}
}
if
(
strs
.
length
=
=
0
)
{
return
"
INVISIBLE
"
;
}
strs
.
sort
(
function
(
a
b
)
{
return
APZHitResultFlags
[
a
]
-
APZHitResultFlags
[
b
]
;
}
)
;
return
strs
.
join
(
"
|
"
)
;
}
function
checkHitResult
(
hitResult
expectedHitInfo
expectedScrollId
desc
)
{
is
(
hitInfoToString
(
hitResult
.
hitInfo
)
hitInfoToString
(
expectedHitInfo
)
desc
+
"
hit
info
"
)
;
is
(
hitResult
.
scrollId
expectedScrollId
desc
+
"
scrollid
"
)
;
}
var
ScrollbarTrackLocation
=
{
START
:
1
END
:
2
}
;
var
LayerState
=
{
ACTIVE
:
1
INACTIVE
:
2
}
;
function
hitTestScrollbar
(
params
)
{
var
config
=
getHitTestConfig
(
)
;
var
elem
=
params
.
element
;
var
boundingClientRect
=
elem
.
getBoundingClientRect
(
)
;
var
verticalScrollbarWidth
=
boundingClientRect
.
width
-
elem
.
clientWidth
;
var
horizontalScrollbarHeight
=
boundingClientRect
.
height
-
elem
.
clientHeight
;
var
scrollbarArrowButtonHeight
=
config
.
isWindows
?
verticalScrollbarWidth
:
0
;
var
scrollbarArrowButtonWidth
=
config
.
isWindows
?
horizontalScrollbarHeight
:
0
;
var
expectedHitInfo
=
APZHitResultFlags
.
VISIBLE
|
APZHitResultFlags
.
SCROLLBAR
;
if
(
params
.
expectThumb
)
{
expectedHitInfo
|
=
APZHitResultFlags
.
DISPATCH_TO_CONTENT
;
if
(
params
.
layerState
=
=
LayerState
.
ACTIVE
)
{
expectedHitInfo
|
=
APZHitResultFlags
.
SCROLLBAR_THUMB
;
}
}
var
scrollframeMsg
=
(
params
.
layerState
=
=
LayerState
.
ACTIVE
)
?
"
active
scrollframe
"
:
"
inactive
scrollframe
"
;
if
(
params
.
directions
.
vertical
&
&
verticalScrollbarWidth
>
0
)
{
var
verticalScrollbarPoint
=
{
x
:
boundingClientRect
.
right
-
(
verticalScrollbarWidth
/
2
)
y
:
(
params
.
trackLocation
=
=
ScrollbarTrackLocation
.
START
)
?
(
boundingClientRect
.
y
+
scrollbarArrowButtonHeight
+
5
)
:
(
boundingClientRect
.
bottom
-
horizontalScrollbarHeight
-
scrollbarArrowButtonHeight
-
5
)
}
;
checkHitResult
(
hitTest
(
verticalScrollbarPoint
)
expectedHitInfo
|
APZHitResultFlags
.
SCROLLBAR_VERTICAL
params
.
expectedScrollId
scrollframeMsg
+
"
-
vertical
scrollbar
"
)
;
}
if
(
params
.
directions
.
horizontal
&
&
horizontalScrollbarHeight
>
0
)
{
var
horizontalScrollbarPoint
=
{
x
:
(
params
.
trackLocation
=
=
ScrollbarTrackLocation
.
START
)
?
(
boundingClientRect
.
x
+
scrollbarArrowButtonWidth
+
5
)
:
(
boundingClientRect
.
right
-
verticalScrollbarWidth
-
scrollbarArrowButtonWidth
-
5
)
y
:
boundingClientRect
.
bottom
-
(
horizontalScrollbarHeight
/
2
)
}
;
checkHitResult
(
hitTest
(
horizontalScrollbarPoint
)
expectedHitInfo
params
.
expectedScrollId
scrollframeMsg
+
"
-
horizontal
scrollbar
"
)
;
}
}
function
getPrefs
(
ident
)
{
switch
(
ident
)
{
case
"
TOUCH_EVENTS
:
PAN
"
:
return
[
[
"
apz
.
touch_start_tolerance
"
"
0
.
0
"
]
[
"
ui
.
click_hold_context_menus
.
delay
"
10000
]
[
"
apz
.
fling_min_velocity_threshold
"
"
10000
"
]
[
"
apz
.
displayport_expiry_ms
"
0
]
]
;
default
:
return
[
]
;
}
}
var
ApzCleanup
=
{
_cleanups
:
[
]
register
:
function
(
func
)
{
if
(
this
.
_cleanups
.
length
=
=
0
)
{
if
(
!
window
.
isApzSubtest
)
{
SimpleTest
.
registerCleanupFunction
(
this
.
execute
.
bind
(
this
)
)
;
}
}
this
.
_cleanups
.
push
(
func
)
;
}
execute
:
function
(
)
{
while
(
this
.
_cleanups
.
length
>
0
)
{
var
func
=
this
.
_cleanups
.
pop
(
)
;
try
{
func
(
)
;
}
catch
(
ex
)
{
SimpleTest
.
ok
(
false
"
Subtest
cleanup
function
[
"
+
func
.
toString
(
)
+
"
]
threw
exception
[
"
+
ex
+
"
]
on
page
[
"
+
location
.
href
+
"
]
"
)
;
}
}
}
}
;
