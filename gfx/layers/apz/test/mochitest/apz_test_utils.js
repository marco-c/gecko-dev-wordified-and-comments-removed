function
convertEntries
(
entries
)
{
var
result
=
{
}
;
for
(
var
i
=
0
;
i
<
entries
.
length
;
+
+
i
)
{
result
[
entries
[
i
]
.
key
]
=
entries
[
i
]
.
value
;
}
return
result
;
}
function
parsePoint
(
str
)
{
var
pieces
=
str
.
replace
(
/
[
(
)
\
s
]
+
/
g
"
"
)
.
split
(
"
"
)
;
SimpleTest
.
is
(
pieces
.
length
2
"
expected
string
of
form
(
x
y
)
"
)
;
for
(
var
i
=
0
;
i
<
2
;
i
+
+
)
{
var
eq
=
pieces
[
i
]
.
indexOf
(
"
=
"
)
;
if
(
eq
>
=
0
)
{
pieces
[
i
]
=
pieces
[
i
]
.
substring
(
eq
+
1
)
;
}
}
return
{
x
:
parseInt
(
pieces
[
0
]
)
y
:
parseInt
(
pieces
[
1
]
)
}
;
}
function
getVisualViewportRect
(
vv
)
{
return
{
x
:
vv
.
pageLeft
y
:
vv
.
pageTop
width
:
vv
.
width
height
:
vv
.
height
}
;
}
function
parseRect
(
str
)
{
var
pieces
=
str
.
replace
(
/
[
(
)
\
s
]
+
/
g
"
"
)
.
split
(
"
"
)
;
SimpleTest
.
is
(
pieces
.
length
4
"
expected
string
of
form
(
x
y
w
h
)
"
)
;
for
(
var
i
=
0
;
i
<
4
;
i
+
+
)
{
var
eq
=
pieces
[
i
]
.
indexOf
(
"
=
"
)
;
if
(
eq
>
=
0
)
{
pieces
[
i
]
=
pieces
[
i
]
.
substring
(
eq
+
1
)
;
}
}
return
{
x
:
parseInt
(
pieces
[
0
]
)
y
:
parseInt
(
pieces
[
1
]
)
width
:
parseInt
(
pieces
[
2
]
)
height
:
parseInt
(
pieces
[
3
]
)
}
;
}
function
rectContains
(
haystack
needle
)
{
return
(
haystack
.
x
<
=
needle
.
x
&
&
haystack
.
y
<
=
needle
.
y
&
&
haystack
.
x
+
haystack
.
width
>
=
needle
.
x
+
needle
.
width
&
&
haystack
.
y
+
haystack
.
height
>
=
needle
.
y
+
needle
.
height
)
;
}
function
rectToString
(
rect
)
{
return
(
"
(
"
+
rect
.
x
+
"
"
+
rect
.
y
+
"
"
+
rect
.
width
+
"
"
+
rect
.
height
+
"
)
"
)
;
}
function
assertRectContainment
(
haystackRect
haystackDesc
needleRect
needleDesc
)
{
SimpleTest
.
ok
(
rectContains
(
haystackRect
needleRect
)
haystackDesc
+
"
"
+
rectToString
(
haystackRect
)
+
"
should
contain
"
+
needleDesc
+
"
"
+
rectToString
(
needleRect
)
)
;
}
function
getPropertyAsRect
(
scrollFrames
scrollId
prop
)
{
SimpleTest
.
ok
(
scrollId
in
scrollFrames
"
expected
scroll
frame
data
for
scroll
id
"
+
scrollId
)
;
var
scrollFrameData
=
scrollFrames
[
scrollId
]
;
SimpleTest
.
ok
(
"
displayport
"
in
scrollFrameData
"
expected
a
"
+
prop
+
"
for
scroll
id
"
+
scrollId
)
;
var
value
=
scrollFrameData
[
prop
]
;
return
parseRect
(
value
)
;
}
function
convertScrollFrameData
(
scrollFrames
)
{
var
result
=
{
}
;
for
(
var
i
=
0
;
i
<
scrollFrames
.
length
;
+
+
i
)
{
result
[
scrollFrames
[
i
]
.
scrollId
]
=
convertEntries
(
scrollFrames
[
i
]
.
entries
)
;
}
return
result
;
}
function
convertBuckets
(
buckets
)
{
var
result
=
{
}
;
for
(
var
i
=
0
;
i
<
buckets
.
length
;
+
+
i
)
{
result
[
buckets
[
i
]
.
sequenceNumber
]
=
convertScrollFrameData
(
buckets
[
i
]
.
scrollFrames
)
;
}
return
result
;
}
function
convertTestData
(
testData
)
{
var
result
=
{
}
;
result
.
paints
=
convertBuckets
(
testData
.
paints
)
;
result
.
repaintRequests
=
convertBuckets
(
testData
.
repaintRequests
)
;
return
result
;
}
function
getLastNonemptyBucket
(
buckets
)
{
for
(
var
i
=
buckets
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
buckets
[
i
]
.
scrollFrames
.
length
)
{
return
buckets
[
i
]
;
}
}
return
null
;
}
function
parseTransform
(
transform
)
{
return
/
matrix
\
(
(
.
*
)
(
.
*
)
(
.
*
)
(
.
*
)
(
.
*
)
(
.
*
)
\
)
/
.
exec
(
transform
)
.
slice
(
1
)
.
map
(
parseFloat
)
;
}
function
isTransformClose
(
a
b
name
)
{
is
(
a
.
length
b
.
length
expected
transforms
{
a
}
and
{
b
}
to
be
the
same
length
)
;
for
(
let
i
=
0
;
i
<
a
.
length
;
i
+
+
)
{
ok
(
Math
.
abs
(
a
[
i
]
-
b
[
i
]
)
<
0
.
01
name
)
;
}
}
function
buildApzcTree
(
paint
)
{
var
root
=
{
scrollId
:
-
1
children
:
[
]
}
;
for
(
let
scrollId
in
paint
)
{
paint
[
scrollId
]
.
children
=
[
]
;
paint
[
scrollId
]
.
scrollId
=
scrollId
;
}
for
(
let
scrollId
in
paint
)
{
var
parentNode
=
null
;
if
(
"
hasNoParentWithSameLayersId
"
in
paint
[
scrollId
]
)
{
parentNode
=
root
;
}
else
if
(
"
parentScrollId
"
in
paint
[
scrollId
]
)
{
parentNode
=
paint
[
paint
[
scrollId
]
.
parentScrollId
]
;
}
parentNode
.
children
.
push
(
paint
[
scrollId
]
)
;
}
return
root
;
}
function
findRcdNode
(
apzcTree
)
{
if
(
apzcTree
.
isRootContent
)
{
return
apzcTree
;
}
for
(
var
i
=
0
;
i
<
apzcTree
.
children
.
length
;
i
+
+
)
{
var
rcd
=
findRcdNode
(
apzcTree
.
children
[
i
]
)
;
if
(
rcd
!
=
null
)
{
return
rcd
;
}
}
return
null
;
}
function
isLayerized
(
elementId
)
{
var
contentTestData
=
SpecialPowers
.
getDOMWindowUtils
(
window
)
.
getContentAPZTestData
(
)
;
var
nonEmptyBucket
=
getLastNonemptyBucket
(
contentTestData
.
paints
)
;
ok
(
nonEmptyBucket
!
=
null
"
expected
at
least
one
nonempty
paint
"
)
;
var
seqno
=
nonEmptyBucket
.
sequenceNumber
;
contentTestData
=
convertTestData
(
contentTestData
)
;
var
paint
=
contentTestData
.
paints
[
seqno
]
;
for
(
var
scrollId
in
paint
)
{
if
(
"
contentDescription
"
in
paint
[
scrollId
]
)
{
if
(
paint
[
scrollId
]
.
contentDescription
.
includes
(
elementId
)
)
{
return
true
;
}
}
}
return
false
;
}
function
getLastContentDisplayportFor
(
elementId
expectPainted
=
true
)
{
var
contentTestData
=
SpecialPowers
.
getDOMWindowUtils
(
window
)
.
getContentAPZTestData
(
)
;
if
(
contentTestData
=
=
undefined
)
{
ok
(
!
expectPainted
"
expected
to
have
apz
test
data
(
1
)
"
)
;
return
null
;
}
var
nonEmptyBucket
=
getLastNonemptyBucket
(
contentTestData
.
paints
)
;
if
(
nonEmptyBucket
=
=
null
)
{
ok
(
!
expectPainted
"
expected
to
have
apz
test
data
(
2
)
"
)
;
return
null
;
}
var
seqno
=
nonEmptyBucket
.
sequenceNumber
;
contentTestData
=
convertTestData
(
contentTestData
)
;
var
paint
=
contentTestData
.
paints
[
seqno
]
;
for
(
var
scrollId
in
paint
)
{
if
(
"
contentDescription
"
in
paint
[
scrollId
]
)
{
if
(
paint
[
scrollId
]
.
contentDescription
.
includes
(
elementId
)
)
{
if
(
"
displayport
"
in
paint
[
scrollId
]
)
{
return
parseRect
(
paint
[
scrollId
]
.
displayport
)
;
}
}
}
}
return
null
;
}
function
getLastApzcTree
(
)
{
let
data
=
SpecialPowers
.
getDOMWindowUtils
(
window
)
.
getCompositorAPZTestData
(
)
;
if
(
data
=
=
undefined
)
{
ok
(
false
"
expected
to
have
compositor
apz
test
data
"
)
;
return
null
;
}
if
(
!
data
.
paints
.
length
)
{
ok
(
false
"
expected
to
have
at
least
one
compositor
paint
bucket
"
)
;
return
null
;
}
var
seqno
=
data
.
paints
[
data
.
paints
.
length
-
1
]
.
sequenceNumber
;
data
=
convertTestData
(
data
)
;
return
buildApzcTree
(
data
.
paints
[
seqno
]
)
;
}
function
promiseFrame
(
aWindow
=
window
)
{
return
new
Promise
(
resolve
=
>
{
aWindow
.
requestAnimationFrame
(
resolve
)
;
}
)
;
}
function
promiseAfterPaint
(
)
{
return
new
Promise
(
resolve
=
>
{
window
.
addEventListener
(
"
MozAfterPaint
"
resolve
{
once
:
true
}
)
;
}
)
;
}
function
promiseOnlyApzControllerFlushedWithoutSetTimeout
(
aWindow
=
window
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
var
repaintDone
=
function
(
)
{
dump
(
"
PromiseApzRepaintsFlushed
:
APZ
flush
done
\
n
"
)
;
SpecialPowers
.
Services
.
obs
.
removeObserver
(
repaintDone
"
apz
-
repaints
-
flushed
"
)
;
resolve
(
)
;
}
;
SpecialPowers
.
Services
.
obs
.
addObserver
(
repaintDone
"
apz
-
repaints
-
flushed
"
)
;
if
(
SpecialPowers
.
getDOMWindowUtils
(
aWindow
)
.
flushApzRepaints
(
)
)
{
dump
(
"
PromiseApzRepaintsFlushed
:
Flushed
APZ
repaints
waiting
for
callback
.
.
.
\
n
"
)
;
}
else
{
dump
(
"
PromiseApzRepaintsFlushed
:
Flushing
APZ
repaints
was
a
no
-
op
triggering
callback
directly
.
.
.
\
n
"
)
;
repaintDone
(
)
;
}
}
)
;
}
function
promiseOnlyApzControllerFlushed
(
aWindow
=
window
)
{
return
new
Promise
(
resolve
=
>
{
promiseOnlyApzControllerFlushedWithoutSetTimeout
(
aWindow
)
.
then
(
(
)
=
>
{
setTimeout
(
resolve
0
)
;
}
)
;
}
)
;
}
async
function
promiseApzFlushedRepaints
(
)
{
await
promiseAllPaintsDone
(
)
;
await
promiseOnlyApzControllerFlushed
(
)
;
await
promiseAllPaintsDone
(
)
;
}
function
runSubtestsSeriallyInFreshWindows
(
aSubtests
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
var
testIndex
=
-
1
;
var
w
=
null
;
var
onlyOneSubtest
=
SpecialPowers
.
getCharPref
(
"
apz
.
subtest
"
"
"
)
;
function
advanceSubtestExecutionWithFailure
(
msg
)
{
SimpleTest
.
ok
(
false
msg
)
;
advanceSubtestExecution
(
)
;
}
async
function
advanceSubtestExecution
(
)
{
var
test
=
aSubtests
[
testIndex
]
;
if
(
w
)
{
if
(
w
.
ApzCleanup
)
{
w
.
ApzCleanup
.
execute
(
)
;
}
if
(
typeof
test
.
dp_suppression
!
=
"
undefined
"
)
{
SpecialPowers
.
getDOMWindowUtils
(
window
)
.
respectDisplayPortSuppression
(
!
test
.
dp_suppression
)
;
}
if
(
test
.
prefs
)
{
SpecialPowers
.
popPrefEnv
(
function
(
)
{
w
.
close
(
)
;
w
=
null
;
advanceSubtestExecution
(
)
;
}
)
;
return
;
}
w
.
close
(
)
;
}
testIndex
+
+
;
if
(
testIndex
>
=
aSubtests
.
length
)
{
resolve
(
)
;
return
;
}
await
SimpleTest
.
promiseFocus
(
window
)
;
test
=
aSubtests
[
testIndex
]
;
let
recognizedProps
=
[
"
file
"
"
prefs
"
"
dp_suppression
"
"
onload
"
]
;
for
(
let
prop
in
test
)
{
if
(
!
recognizedProps
.
includes
(
prop
)
)
{
SimpleTest
.
ok
(
false
"
Subtest
"
+
test
.
file
+
"
has
unrecognized
property
'
"
+
prop
+
"
'
"
)
;
setTimeout
(
function
(
)
{
advanceSubtestExecution
(
)
;
}
0
)
;
return
;
}
}
if
(
onlyOneSubtest
&
&
onlyOneSubtest
!
=
test
.
file
)
{
SimpleTest
.
ok
(
true
"
Skipping
"
+
test
.
file
+
"
because
only
"
+
onlyOneSubtest
+
"
is
being
run
"
)
;
setTimeout
(
function
(
)
{
advanceSubtestExecution
(
)
;
}
0
)
;
return
;
}
SimpleTest
.
ok
(
true
"
Starting
subtest
"
+
test
.
file
)
;
if
(
typeof
test
.
dp_suppression
!
=
"
undefined
"
)
{
SpecialPowers
.
getDOMWindowUtils
(
window
)
.
respectDisplayPortSuppression
(
test
.
dp_suppression
)
;
}
function
spawnTest
(
aFile
)
{
w
=
window
.
open
(
"
"
"
_blank
"
)
;
w
.
subtestDone
=
advanceSubtestExecution
;
w
.
subtestFailed
=
advanceSubtestExecutionWithFailure
;
w
.
isApzSubtest
=
true
;
w
.
SimpleTest
=
SimpleTest
;
w
.
dump
=
function
(
msg
)
{
return
dump
(
aFile
+
"
|
"
+
msg
)
;
}
;
w
.
info
=
function
(
msg
)
{
return
info
(
aFile
+
"
|
"
+
msg
)
;
}
;
w
.
is
=
function
(
a
b
msg
)
{
return
is
(
a
b
aFile
+
"
|
"
+
msg
)
;
}
;
w
.
isnot
=
function
(
a
b
msg
)
{
return
isnot
(
a
b
aFile
+
"
|
"
+
msg
)
;
}
;
w
.
isfuzzy
=
function
(
a
b
eps
msg
)
{
return
isfuzzy
(
a
b
eps
aFile
+
"
|
"
+
msg
)
;
}
;
w
.
ok
=
function
(
cond
msg
)
{
arguments
[
1
]
=
aFile
+
"
|
"
+
msg
;
return
SimpleTest
.
ok
.
apply
(
SimpleTest
arguments
)
;
}
;
w
.
todo_is
=
function
(
a
b
msg
)
{
return
todo_is
(
a
b
aFile
+
"
|
"
+
msg
)
;
}
;
w
.
todo
=
function
(
cond
msg
)
{
return
todo
(
cond
aFile
+
"
|
"
+
msg
)
;
}
;
if
(
test
.
onload
)
{
w
.
addEventListener
(
"
load
"
function
(
e
)
{
test
.
onload
(
w
)
;
}
{
once
:
true
}
)
;
}
var
subtestUrl
=
location
.
href
.
substring
(
0
location
.
href
.
lastIndexOf
(
"
/
"
)
+
1
)
+
aFile
;
function
urlResolves
(
url
)
{
var
request
=
new
XMLHttpRequest
(
)
;
request
.
open
(
"
GET
"
url
false
)
;
request
.
send
(
)
;
return
request
.
status
!
=
=
404
;
}
if
(
!
urlResolves
(
subtestUrl
)
)
{
SimpleTest
.
ok
(
false
"
Subtest
URL
"
+
subtestUrl
+
"
does
not
resolve
.
"
+
"
Be
sure
it
'
s
present
in
the
support
-
files
section
of
mochitest
.
ini
.
"
)
;
reject
(
)
;
return
undefined
;
}
w
.
location
=
subtestUrl
;
return
w
;
}
if
(
test
.
prefs
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
test
.
prefs
}
)
;
}
w
=
spawnTest
(
test
.
file
)
;
}
advanceSubtestExecution
(
)
;
}
)
.
catch
(
function
(
e
)
{
SimpleTest
.
ok
(
false
"
Error
occurred
while
running
subtests
:
"
+
e
)
;
}
)
;
}
function
pushPrefs
(
prefs
)
{
return
SpecialPowers
.
pushPrefEnv
(
{
set
:
prefs
}
)
;
}
async
function
waitUntilApzStable
(
)
{
if
(
!
SpecialPowers
.
isMainProcess
(
)
)
{
function
parentProcessFlush
(
)
{
function
apzFlush
(
)
{
var
topWin
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
if
(
!
topWin
)
{
topWin
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
geckoview
"
)
;
}
var
topUtils
=
topWin
.
windowUtils
;
var
repaintDone
=
function
(
)
{
dump
(
"
WaitUntilApzStable
:
APZ
flush
done
in
parent
proc
\
n
"
)
;
Services
.
obs
.
removeObserver
(
repaintDone
"
apz
-
repaints
-
flushed
"
)
;
sendAsyncMessage
(
"
apz
-
flush
-
done
"
null
)
;
}
;
var
flushRepaint
=
function
(
)
{
if
(
topUtils
.
isMozAfterPaintPending
)
{
topWin
.
addEventListener
(
"
MozAfterPaint
"
flushRepaint
{
once
:
true
}
)
;
return
;
}
Services
.
obs
.
addObserver
(
repaintDone
"
apz
-
repaints
-
flushed
"
)
;
if
(
topUtils
.
flushApzRepaints
(
)
)
{
dump
(
"
WaitUntilApzStable
:
flushed
APZ
repaints
in
parent
proc
waiting
for
callback
.
.
.
\
n
"
)
;
}
else
{
dump
(
"
WaitUntilApzStable
:
flushing
APZ
repaints
in
parent
proc
was
a
no
-
op
triggering
callback
directly
.
.
.
\
n
"
)
;
repaintDone
(
)
;
}
}
;
flushRepaint
(
)
;
}
function
cleanup
(
)
{
removeMessageListener
(
"
apz
-
flush
"
apzFlush
)
;
removeMessageListener
(
"
cleanup
"
cleanup
)
;
}
addMessageListener
(
"
apz
-
flush
"
apzFlush
)
;
addMessageListener
(
"
cleanup
"
cleanup
)
;
}
if
(
typeof
waitUntilApzStable
.
chromeHelper
=
=
"
undefined
"
)
{
waitUntilApzStable
.
chromeHelper
=
SpecialPowers
.
loadChromeScript
(
parentProcessFlush
)
;
ApzCleanup
.
register
(
(
)
=
>
{
waitUntilApzStable
.
chromeHelper
.
sendAsyncMessage
(
"
cleanup
"
null
)
;
waitUntilApzStable
.
chromeHelper
.
destroy
(
)
;
delete
waitUntilApzStable
.
chromeHelper
;
}
)
;
}
waitUntilApzStable
.
chromeHelper
.
sendAsyncMessage
(
"
apz
-
flush
"
null
)
;
await
waitUntilApzStable
.
chromeHelper
.
promiseOneMessage
(
"
apz
-
flush
-
done
"
)
;
dump
(
"
WaitUntilApzStable
:
got
apz
-
flush
-
done
in
child
proc
\
n
"
)
;
}
await
SimpleTest
.
promiseFocus
(
window
)
;
dump
(
"
WaitUntilApzStable
:
done
promiseFocus
\
n
"
)
;
await
promiseAllPaintsDone
(
)
;
dump
(
"
WaitUntilApzStable
:
done
promiseAllPaintsDone
\
n
"
)
;
await
promiseOnlyApzControllerFlushed
(
)
;
dump
(
"
WaitUntilApzStable
:
all
done
\
n
"
)
;
}
async
function
forceLayerTreeToCompositor
(
)
{
document
.
body
.
style
.
boxSizing
=
"
border
-
box
"
;
var
utils
=
SpecialPowers
.
getDOMWindowUtils
(
window
)
;
if
(
!
utils
.
isMozAfterPaintPending
)
{
dump
(
"
Forcing
a
paint
since
none
was
pending
already
.
.
.
\
n
"
)
;
var
testMode
=
utils
.
isTestControllingRefreshes
;
utils
.
advanceTimeAndRefresh
(
0
)
;
if
(
!
testMode
)
{
utils
.
restoreNormalRefresh
(
)
;
}
}
await
promiseAllPaintsDone
(
null
true
)
;
await
promiseOnlyApzControllerFlushed
(
)
;
}
function
isApzEnabled
(
)
{
var
enabled
=
SpecialPowers
.
getDOMWindowUtils
(
window
)
.
asyncPanZoomEnabled
;
if
(
!
enabled
)
{
SimpleTest
.
ok
(
true
"
APZ
is
not
enabled
;
this
test
will
be
skipped
"
)
;
}
return
enabled
;
}
function
isKeyApzEnabled
(
)
{
return
isApzEnabled
(
)
&
&
SpecialPowers
.
getBoolPref
(
"
apz
.
keyboard
.
enabled
"
)
;
}
function
getSnapshot
(
rect
)
{
function
parentProcessSnapshot
(
)
{
addMessageListener
(
"
snapshot
"
function
(
parentRect
)
{
var
topWin
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
if
(
!
topWin
)
{
topWin
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
geckoview
"
)
;
}
parentRect
=
JSON
.
parse
(
parentRect
)
;
parentRect
.
x
-
=
topWin
.
mozInnerScreenX
;
parentRect
.
y
-
=
topWin
.
mozInnerScreenY
;
var
canvas
=
topWin
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
canvas
.
width
=
parentRect
.
width
;
canvas
.
height
=
parentRect
.
height
;
var
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
drawWindow
(
topWin
parentRect
.
x
parentRect
.
y
parentRect
.
width
parentRect
.
height
"
rgb
(
255
255
255
)
"
ctx
.
DRAWWINDOW_DRAW_VIEW
|
ctx
.
DRAWWINDOW_USE_WIDGET_LAYERS
|
ctx
.
DRAWWINDOW_DRAW_CARET
)
;
return
canvas
.
toDataURL
(
)
;
}
)
;
}
if
(
typeof
getSnapshot
.
chromeHelper
=
=
"
undefined
"
)
{
getSnapshot
.
chromeHelper
=
SpecialPowers
.
loadChromeScript
(
parentProcessSnapshot
)
;
ApzCleanup
.
register
(
function
(
)
{
getSnapshot
.
chromeHelper
.
destroy
(
)
;
}
)
;
}
return
getSnapshot
.
chromeHelper
.
sendQuery
(
"
snapshot
"
JSON
.
stringify
(
rect
)
)
;
}
function
getQueryArgs
(
)
{
var
args
=
{
}
;
if
(
location
.
search
.
length
)
{
var
params
=
location
.
search
.
substr
(
1
)
.
split
(
"
&
"
)
;
for
(
var
p
of
params
)
{
var
[
k
v
]
=
p
.
split
(
"
=
"
)
;
args
[
k
]
=
JSON
.
parse
(
v
)
;
}
}
return
args
;
}
async
function
injectScript
(
aScript
aWindow
=
window
)
{
var
e
=
aWindow
.
document
.
createElement
(
"
script
"
)
;
e
.
type
=
"
text
/
javascript
"
;
let
loadPromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
e
.
onload
=
function
(
)
{
resolve
(
)
;
}
;
e
.
onerror
=
function
(
)
{
dump
(
"
Script
[
"
+
aScript
+
"
]
errored
out
\
n
"
)
;
reject
(
)
;
}
;
}
)
;
e
.
src
=
aScript
;
aWindow
.
document
.
getElementsByTagName
(
"
head
"
)
[
0
]
.
appendChild
(
e
)
;
await
loadPromise
;
}
function
getHitTestConfig
(
)
{
if
(
!
(
"
hitTestConfig
"
in
window
)
)
{
var
utils
=
SpecialPowers
.
getDOMWindowUtils
(
window
)
;
var
isWindows
=
getPlatform
(
)
=
=
"
windows
"
;
let
activateAllScrollFrames
=
SpecialPowers
.
getBoolPref
(
"
apz
.
wr
.
activate_all_scroll_frames
"
)
|
|
(
SpecialPowers
.
getBoolPref
(
"
apz
.
wr
.
activate_all_scroll_frames_when_fission
"
)
&
&
SpecialPowers
.
Services
.
appinfo
.
fissionAutostart
)
;
window
.
hitTestConfig
=
{
utils
isWindows
activateAllScrollFrames
}
;
}
return
window
.
hitTestConfig
;
}
function
centerOf
(
element
)
{
if
(
typeof
element
=
=
=
"
string
"
)
{
element
=
document
.
getElementById
(
element
)
;
}
var
bounds
=
element
.
getBoundingClientRect
(
)
;
return
{
x
:
bounds
.
x
+
bounds
.
width
/
2
y
:
bounds
.
y
+
bounds
.
height
/
2
}
;
}
function
hitTest
(
point
)
{
var
utils
=
getHitTestConfig
(
)
.
utils
;
dump
(
"
Hit
-
testing
point
(
"
+
point
.
x
+
"
"
+
point
.
y
+
"
)
\
n
"
)
;
utils
.
sendMouseEvent
(
"
MozMouseHittest
"
point
.
x
point
.
y
0
0
0
true
0
0
true
true
)
;
var
data
=
utils
.
getCompositorAPZTestData
(
)
;
ok
(
data
.
hitResults
.
length
>
=
1
"
Expected
at
least
one
hit
result
in
the
APZTestData
"
)
;
var
result
=
data
.
hitResults
[
data
.
hitResults
.
length
-
1
]
;
return
{
hitInfo
:
result
.
hitResult
scrollId
:
result
.
scrollId
layersId
:
result
.
layersId
}
;
}
function
hitInfoToString
(
hitInfo
)
{
var
strs
=
[
]
;
for
(
var
flag
in
APZHitResultFlags
)
{
if
(
(
hitInfo
&
APZHitResultFlags
[
flag
]
)
!
=
0
)
{
strs
.
push
(
flag
)
;
}
}
if
(
!
strs
.
length
)
{
return
"
INVISIBLE
"
;
}
strs
.
sort
(
function
(
a
b
)
{
return
APZHitResultFlags
[
a
]
-
APZHitResultFlags
[
b
]
;
}
)
;
return
strs
.
join
(
"
|
"
)
;
}
function
checkHitResult
(
hitResult
expectedHitInfo
expectedScrollId
expectedLayersId
desc
)
{
is
(
hitInfoToString
(
hitResult
.
hitInfo
)
hitInfoToString
(
expectedHitInfo
)
desc
+
"
hit
info
"
)
;
is
(
hitResult
.
scrollId
expectedScrollId
desc
+
"
scrollid
"
)
;
is
(
hitResult
.
layersId
expectedLayersId
desc
+
"
layersid
"
)
;
}
var
ScrollbarTrackLocation
=
{
START
:
1
END
:
2
}
;
var
LayerState
=
{
ACTIVE
:
1
INACTIVE
:
2
}
;
function
hitTestScrollbar
(
params
)
{
var
config
=
getHitTestConfig
(
)
;
var
elem
=
params
.
element
;
var
boundingClientRect
=
elem
.
getBoundingClientRect
(
)
;
var
verticalScrollbarWidth
=
boundingClientRect
.
width
-
elem
.
clientWidth
;
var
horizontalScrollbarHeight
=
boundingClientRect
.
height
-
elem
.
clientHeight
;
var
scrollbarArrowButtonHeight
=
config
.
isWindows
?
verticalScrollbarWidth
:
0
;
var
scrollbarArrowButtonWidth
=
config
.
isWindows
?
horizontalScrollbarHeight
:
0
;
var
expectedHitInfo
=
APZHitResultFlags
.
VISIBLE
|
APZHitResultFlags
.
SCROLLBAR
;
if
(
params
.
expectThumb
)
{
expectedHitInfo
|
=
APZHitResultFlags
.
APZ_AWARE_LISTENERS
;
var
expectActive
=
config
.
activateAllScrollFrames
|
|
params
.
layerState
=
=
LayerState
.
ACTIVE
;
if
(
!
expectActive
)
{
expectedHitInfo
|
=
APZHitResultFlags
.
INACTIVE_SCROLLFRAME
;
}
if
(
expectActive
)
{
expectedHitInfo
|
=
APZHitResultFlags
.
SCROLLBAR_THUMB
;
}
}
var
expectedScrollId
=
params
.
expectedScrollId
;
if
(
config
.
activateAllScrollFrames
)
{
expectedScrollId
=
config
.
utils
.
getViewId
(
params
.
element
)
;
if
(
params
.
layerState
=
=
LayerState
.
ACTIVE
)
{
is
(
expectedScrollId
params
.
expectedScrollId
"
Expected
scrollId
for
active
scrollframe
should
match
"
)
;
}
}
var
scrollframeMsg
=
params
.
layerState
=
=
LayerState
.
ACTIVE
?
"
active
scrollframe
"
:
"
inactive
scrollframe
"
;
if
(
params
.
directions
.
vertical
&
&
verticalScrollbarWidth
>
0
)
{
var
verticalScrollbarPoint
=
{
x
:
boundingClientRect
.
right
-
verticalScrollbarWidth
/
2
y
:
params
.
trackLocation
=
=
ScrollbarTrackLocation
.
START
?
boundingClientRect
.
y
+
scrollbarArrowButtonHeight
+
5
:
boundingClientRect
.
bottom
-
horizontalScrollbarHeight
-
scrollbarArrowButtonHeight
-
5
}
;
checkHitResult
(
hitTest
(
verticalScrollbarPoint
)
expectedHitInfo
|
APZHitResultFlags
.
SCROLLBAR_VERTICAL
expectedScrollId
params
.
expectedLayersId
scrollframeMsg
+
"
-
vertical
scrollbar
"
)
;
}
if
(
params
.
directions
.
horizontal
&
&
horizontalScrollbarHeight
>
0
)
{
var
horizontalScrollbarPoint
=
{
x
:
params
.
trackLocation
=
=
ScrollbarTrackLocation
.
START
?
boundingClientRect
.
x
+
scrollbarArrowButtonWidth
+
5
:
boundingClientRect
.
right
-
verticalScrollbarWidth
-
scrollbarArrowButtonWidth
-
5
y
:
boundingClientRect
.
bottom
-
horizontalScrollbarHeight
/
2
}
;
checkHitResult
(
hitTest
(
horizontalScrollbarPoint
)
expectedHitInfo
expectedScrollId
params
.
expectedLayersId
scrollframeMsg
+
"
-
horizontal
scrollbar
"
)
;
}
}
function
getPrefs
(
ident
)
{
switch
(
ident
)
{
case
"
TOUCH_EVENTS
:
PAN
"
:
return
[
[
"
apz
.
touch_start_tolerance
"
"
0
.
0
"
]
[
"
ui
.
click_hold_context_menus
.
delay
"
10000
]
[
"
apz
.
fling_min_velocity_threshold
"
"
10000
"
]
[
"
apz
.
displayport_expiry_ms
"
0
]
[
"
android
.
touch_resampling
.
enabled
"
false
]
]
;
case
"
TOUCH_ACTION
"
:
return
[
.
.
.
getPrefs
(
"
TOUCH_EVENTS
:
PAN
"
)
[
"
apz
.
test
.
fails_with_native_injection
"
getPlatform
(
)
=
=
"
windows
"
]
]
;
default
:
return
[
]
;
}
}
var
ApzCleanup
=
{
_cleanups
:
[
]
register
(
func
)
{
if
(
!
this
.
_cleanups
.
length
)
{
if
(
!
window
.
isApzSubtest
)
{
SimpleTest
.
registerCleanupFunction
(
this
.
execute
.
bind
(
this
)
)
;
}
}
this
.
_cleanups
.
push
(
func
)
;
}
execute
(
)
{
while
(
this
.
_cleanups
.
length
)
{
var
func
=
this
.
_cleanups
.
pop
(
)
;
try
{
func
(
)
;
}
catch
(
ex
)
{
SimpleTest
.
ok
(
false
"
Subtest
cleanup
function
[
"
+
func
.
toString
(
)
+
"
]
threw
exception
[
"
+
ex
+
"
]
on
page
[
"
+
location
.
href
+
"
]
"
)
;
}
}
}
}
;
function
promiseOneEvent
(
eventTarget
eventType
filter
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
eventTarget
.
addEventListener
(
eventType
function
listener
(
e
)
{
let
success
=
false
;
if
(
filter
=
=
null
)
{
success
=
true
;
}
else
if
(
typeof
filter
=
=
"
function
"
)
{
try
{
success
=
filter
(
e
)
;
}
catch
(
ex
)
{
dump
(
ERROR
:
Filter
passed
to
promiseOneEvent
threw
exception
:
{
ex
}
\
n
)
;
reject
(
)
;
return
;
}
}
else
{
dump
(
"
ERROR
:
Filter
passed
to
promiseOneEvent
was
neither
null
nor
a
function
\
n
"
)
;
reject
(
)
;
return
;
}
if
(
success
)
{
eventTarget
.
removeEventListener
(
eventType
listener
)
;
resolve
(
e
)
;
}
}
)
;
}
)
;
}
function
visualViewportAsZoomedRect
(
)
{
let
vv
=
window
.
visualViewport
;
return
{
x
:
vv
.
pageLeft
y
:
vv
.
pageTop
w
:
vv
.
width
h
:
vv
.
height
z
:
vv
.
scale
}
;
}
function
assertNotCheckerboarded
(
utils
scrollerId
msgPrefix
)
{
utils
.
advanceTimeAndRefresh
(
0
)
;
var
data
=
utils
.
getCompositorAPZTestData
(
)
;
var
found
=
false
;
for
(
apzcData
of
data
.
additionalData
)
{
if
(
apzcData
.
key
=
=
scrollerId
)
{
var
checkerboarding
=
apzcData
.
value
.
split
(
"
"
)
.
includes
(
"
checkerboarding
"
)
;
ok
(
!
checkerboarding
{
msgPrefix
}
:
scroller
is
not
checkerboarding
)
;
found
=
true
;
}
}
ok
(
found
{
msgPrefix
}
:
Found
the
scroller
in
the
APZ
data
)
;
utils
.
restoreNormalRefresh
(
)
;
}
async
function
waitToClearOutAnyPotentialScrolls
(
aWindow
)
{
await
promiseFrame
(
aWindow
)
;
await
promiseFrame
(
aWindow
)
;
await
promiseOnlyApzControllerFlushed
(
aWindow
)
;
await
promiseFrame
(
aWindow
)
;
await
promiseFrame
(
aWindow
)
;
}
function
waitForScrollEvent
(
target
)
{
return
new
Promise
(
resolve
=
>
{
target
.
addEventListener
(
"
scroll
"
resolve
{
once
:
true
}
)
;
}
)
;
}
async
function
promiseApzFlushedRepaintsInPopup
(
popup
)
{
await
SpecialPowers
.
spawn
(
popup
[
]
async
(
)
=
>
{
const
utils
=
SpecialPowers
.
getDOMWindowUtils
(
content
.
window
)
;
async
function
promiseAllPaintsDone
(
)
{
return
new
Promise
(
resolve
=
>
{
function
waitForPaints
(
)
{
if
(
utils
.
isMozAfterPaintPending
)
{
dump
(
"
Waits
for
a
MozAfterPaint
event
\
n
"
)
;
content
.
window
.
addEventListener
(
"
MozAfterPaint
"
(
)
=
>
{
dump
(
"
Got
a
MozAfterPaint
event
\
n
"
)
;
waitForPaints
(
)
;
}
{
once
:
true
}
)
;
}
else
{
dump
(
"
No
more
pending
MozAfterPaint
\
n
"
)
;
content
.
window
.
setTimeout
(
resolve
0
)
;
}
}
waitForPaints
(
)
;
}
)
;
}
await
promiseAllPaintsDone
(
)
;
await
new
Promise
(
resolve
=
>
{
var
repaintDone
=
function
(
)
{
dump
(
"
APZ
flush
done
\
n
"
)
;
SpecialPowers
.
Services
.
obs
.
removeObserver
(
repaintDone
"
apz
-
repaints
-
flushed
"
)
;
content
.
window
.
setTimeout
(
resolve
0
)
;
}
;
SpecialPowers
.
Services
.
obs
.
addObserver
(
repaintDone
"
apz
-
repaints
-
flushed
"
)
;
if
(
utils
.
flushApzRepaints
(
)
)
{
dump
(
"
Flushed
APZ
repaints
waiting
for
callback
.
.
.
\
n
"
)
;
}
else
{
dump
(
"
Flushing
APZ
repaints
was
a
no
-
op
triggering
callback
directly
.
.
.
\
n
"
)
;
repaintDone
(
)
;
}
}
)
;
await
promiseAllPaintsDone
(
)
;
}
)
;
}
async
function
cancelScrollAnimation
(
aElement
aWindow
=
window
)
{
const
originalStyle
=
aElement
.
style
.
display
;
aElement
.
style
.
display
=
"
none
"
;
await
aWindow
.
promiseApzFlushedRepaints
(
)
;
aElement
.
style
.
display
=
originalStyle
;
await
aWindow
.
promiseApzFlushedRepaints
(
)
;
}
function
collectSampledScrollOffsets
(
aElement
)
{
let
data
=
SpecialPowers
.
DOMWindowUtils
.
getCompositorAPZTestData
(
)
;
let
sampledResults
=
data
.
sampledResults
;
const
layersId
=
SpecialPowers
.
DOMWindowUtils
.
getLayersId
(
)
;
const
scrollId
=
SpecialPowers
.
DOMWindowUtils
.
getViewId
(
aElement
)
;
return
sampledResults
.
filter
(
result
=
>
SpecialPowers
.
wrap
(
result
)
.
layersId
=
=
layersId
&
&
SpecialPowers
.
wrap
(
result
)
.
scrollId
=
=
scrollId
)
;
}
