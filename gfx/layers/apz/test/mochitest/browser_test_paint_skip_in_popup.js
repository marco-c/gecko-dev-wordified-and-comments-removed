"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
paint_listener
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
new
URL
(
"
apz_test_utils
.
js
"
gTestPath
)
.
href
this
)
;
Services
.
scriptloader
.
loadSubScript
(
new
URL
(
"
helper_browser_test_utils
.
js
"
gTestPath
)
.
href
this
)
;
add_task
(
(
)
=
>
{
registerCleanupFunction
(
(
)
=
>
{
delete
window
.
waitForAllPaintsFlushed
;
delete
window
.
waitForAllPaints
;
delete
window
.
promiseAllPaintsDone
;
}
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
apz
.
popups
.
enabled
"
true
]
[
"
apz
.
popups_without_remote
.
enabled
"
true
]
[
"
apz
.
test
.
logging_enabled
"
true
]
[
"
layout
.
scroll
.
disable
-
pixel
-
alignment
"
true
]
]
}
)
;
}
)
;
add_task
(
async
(
)
=
>
{
function
httpURL
(
filename
)
{
let
chromeURL
=
getRootDirectory
(
gTestPath
)
+
filename
;
return
chromeURL
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
mochi
.
test
:
8888
/
"
)
;
}
const
url
=
httpURL
(
"
helper_paint_skip_in_popup
.
html
"
)
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
url
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
(
)
=
>
{
await
content
.
wrappedJSObject
.
promiseApzFlushedRepaints
(
)
;
await
content
.
wrappedJSObject
.
waitUntilApzStable
(
)
;
}
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
(
)
=
>
{
const
select
=
content
.
document
.
querySelector
(
"
select
"
)
;
const
focusPromise
=
new
Promise
(
resolve
=
>
{
select
.
addEventListener
(
"
focus
"
resolve
{
once
:
true
}
)
;
}
)
;
select
.
focus
(
)
;
await
focusPromise
;
}
)
;
const
selectPopup
=
await
openSelectPopup
(
)
;
const
arrowscrollbox
=
selectPopup
.
shadowRoot
.
querySelector
(
"
arrowscrollbox
"
)
;
ok
(
arrowscrollbox
"
There
'
s
<
arrowscrollbox
>
inside
the
popup
"
)
;
const
scrollbox
=
arrowscrollbox
.
shadowRoot
.
querySelector
(
"
scrollbox
"
)
;
ok
(
scrollbox
"
There
'
s
<
scrollbox
>
inside
the
popup
"
)
;
scrollbox
.
scrollTo
(
0
100000
)
;
const
scrollMax
=
scrollbox
.
scrollTop
;
ok
(
scrollMax
"
The
max
scroll
offset
should
not
be
zero
"
)
;
scrollbox
.
scrollTo
(
0
0
)
;
await
promiseApzFlushedRepaints
(
selectPopup
)
;
scrollbox
.
scrollBy
(
0
scrollMax
-
10
)
;
await
promiseApzFlushedRepaints
(
selectPopup
)
;
scrollbox
.
scrollBy
(
0
10
)
;
await
promiseApzFlushedRepaints
(
selectPopup
)
;
await
promiseApzFlushedRepaints
(
selectPopup
)
;
is
(
scrollbox
.
scrollTop
scrollMax
The
scroll
offset
:
{
scrollbox
.
scrollTop
}
on
the
main
-
thread
should
be
{
scrollMax
}
)
;
const
sampledData
=
collectSampledScrollOffsets
(
scrollbox
selectPopup
)
;
ok
(
sampledData
.
length
"
There
should
be
at
least
one
collected
offsets
"
)
;
ok
(
sampledData
.
some
(
data
=
>
Math
.
round
(
SpecialPowers
.
wrap
(
data
)
.
scrollOffsetY
)
=
=
scrollMax
)
There
should
be
{
scrollMax
}
in
[
{
sampledData
.
map
(
data
=
>
SpecialPowers
.
wrap
(
data
)
.
scrollOffsetY
)
}
]
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
