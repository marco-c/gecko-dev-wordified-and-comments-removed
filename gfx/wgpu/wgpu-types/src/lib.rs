#
!
[
allow
(
broken_intra_doc_links
)
]
#
[
cfg
(
feature
=
"
serde
"
)
]
use
serde
:
:
{
Deserialize
Serialize
}
;
use
std
:
:
{
num
:
:
NonZeroU32
ops
:
:
Range
}
;
pub
type
BufferAddress
=
u64
;
pub
type
BufferSize
=
std
:
:
num
:
:
NonZeroU64
;
pub
type
ShaderLocation
=
u32
;
pub
type
DynamicOffset
=
u32
;
pub
const
COPY_BYTES_PER_ROW_ALIGNMENT
:
u32
=
256
;
pub
const
BIND_BUFFER_ALIGNMENT
:
BufferAddress
=
256
;
pub
const
COPY_BUFFER_ALIGNMENT
:
BufferAddress
=
4
;
pub
const
VERTEX_STRIDE_ALIGNMENT
:
BufferAddress
=
4
;
pub
const
PUSH_CONSTANT_ALIGNMENT
:
u32
=
4
;
#
[
repr
(
u8
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
Backend
{
Empty
=
0
Vulkan
=
1
Metal
=
2
Dx12
=
3
Dx11
=
4
Gl
=
5
BrowserWebGpu
=
6
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
PowerPreference
{
LowPower
=
0
HighPerformance
=
1
}
impl
Default
for
PowerPreference
{
fn
default
(
)
-
>
Self
{
Self
:
:
LowPower
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Represents
the
backends
that
wgpu
will
use
.
#
[
repr
(
transparent
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
BackendBit
:
u32
{
/
/
/
Supported
on
Windows
Linux
/
Android
and
macOS
/
iOS
via
Vulkan
Portability
(
with
the
Vulkan
feature
enabled
)
const
VULKAN
=
1
<
<
Backend
:
:
Vulkan
as
u32
;
/
/
/
Currently
unsupported
const
GL
=
1
<
<
Backend
:
:
Gl
as
u32
;
/
/
/
Supported
on
macOS
/
iOS
const
METAL
=
1
<
<
Backend
:
:
Metal
as
u32
;
/
/
/
Supported
on
Windows
10
const
DX12
=
1
<
<
Backend
:
:
Dx12
as
u32
;
/
/
/
Supported
on
Windows
7
+
const
DX11
=
1
<
<
Backend
:
:
Dx11
as
u32
;
/
/
/
Supported
when
targeting
the
web
through
webassembly
const
BROWSER_WEBGPU
=
1
<
<
Backend
:
:
BrowserWebGpu
as
u32
;
/
/
/
All
the
apis
that
wgpu
offers
first
tier
of
support
for
.
/
/
/
/
/
/
Vulkan
+
Metal
+
DX12
+
Browser
WebGPU
const
PRIMARY
=
Self
:
:
VULKAN
.
bits
|
Self
:
:
METAL
.
bits
|
Self
:
:
DX12
.
bits
|
Self
:
:
BROWSER_WEBGPU
.
bits
;
/
/
/
All
the
apis
that
wgpu
offers
second
tier
of
support
for
.
These
may
/
/
/
be
unsupported
/
still
experimental
.
/
/
/
/
/
/
OpenGL
+
DX11
const
SECONDARY
=
Self
:
:
GL
.
bits
|
Self
:
:
DX11
.
bits
;
}
}
impl
From
<
Backend
>
for
BackendBit
{
fn
from
(
backend
:
Backend
)
-
>
Self
{
Self
:
:
from_bits
(
1
<
<
backend
as
u32
)
.
unwrap
(
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RequestAdapterOptions
<
S
>
{
pub
power_preference
:
PowerPreference
pub
compatible_surface
:
Option
<
S
>
}
impl
<
S
>
Default
for
RequestAdapterOptions
<
S
>
{
fn
default
(
)
-
>
Self
{
Self
{
power_preference
:
PowerPreference
:
:
default
(
)
compatible_surface
:
None
}
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Features
that
are
not
guaranteed
to
be
supported
.
/
/
/
/
/
/
These
are
either
part
of
the
webgpu
standard
or
are
extension
features
supported
by
/
/
/
wgpu
when
targeting
native
.
/
/
/
/
/
/
If
you
want
to
use
a
feature
you
need
to
first
verify
that
the
adapter
supports
/
/
/
the
feature
.
If
the
adapter
does
not
support
the
feature
requesting
a
device
with
it
enabled
/
/
/
will
panic
.
#
[
repr
(
transparent
)
]
#
[
derive
(
Default
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
Features
:
u64
{
/
/
/
By
default
polygon
depth
is
clipped
to
0
-
1
range
.
Anything
outside
of
that
range
/
/
/
is
rejected
and
respective
fragments
are
not
touched
.
/
/
/
/
/
/
With
this
extension
we
can
force
clamping
of
the
polygon
depth
to
0
-
1
.
That
allows
/
/
/
shadow
map
occluders
to
be
rendered
into
a
tighter
depth
range
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
desktops
/
/
/
-
some
mobile
chips
/
/
/
/
/
/
This
is
a
web
and
native
feature
.
const
DEPTH_CLAMPING
=
0x0000_0000_0000_0001
;
/
/
/
Enables
BCn
family
of
compressed
textures
.
All
BCn
textures
use
4x4
pixel
blocks
/
/
/
with
8
or
16
bytes
per
block
.
/
/
/
/
/
/
Compressed
textures
sacrifice
some
quality
in
exchange
for
signifigantly
reduced
/
/
/
bandwidth
usage
.
/
/
/
/
/
/
Supported
Platforms
:
/
/
/
-
desktops
/
/
/
/
/
/
This
is
a
web
and
native
feature
.
const
TEXTURE_COMPRESSION_BC
=
0x0000_0000_0000_0002
;
/
/
/
Webgpu
only
allows
the
MAP_READ
and
MAP_WRITE
buffer
usage
to
be
matched
with
/
/
/
COPY_DST
and
COPY_SRC
respectively
.
This
removes
this
requirement
.
/
/
/
/
/
/
This
is
only
beneficial
on
systems
that
share
memory
between
CPU
and
GPU
.
If
enabled
/
/
/
on
a
system
that
doesn
'
t
this
can
severely
hinder
performance
.
Only
use
if
you
understand
/
/
/
the
consequences
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
All
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
MAPPABLE_PRIMARY_BUFFERS
=
0x0000_0000_0001_0000
;
/
/
/
Allows
the
user
to
create
uniform
arrays
of
sampled
textures
in
shaders
:
/
/
/
/
/
/
eg
.
uniform
texture2D
textures
[
10
]
.
/
/
/
/
/
/
This
capability
allows
them
to
exist
and
to
be
indexed
by
compile
time
constant
/
/
/
values
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Metal
(
with
MSL
2
.
0
+
on
macOS
10
.
13
+
)
/
/
/
-
Vulkan
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
SAMPLED_TEXTURE_BINDING_ARRAY
=
0x0000_0000_0002_0000
;
/
/
/
Allows
shaders
to
index
sampled
texture
arrays
with
dynamically
uniform
values
:
/
/
/
/
/
/
eg
.
texture_array
[
uniform_value
]
/
/
/
/
/
/
This
capability
means
the
hardware
will
also
support
SAMPLED_TEXTURE_BINDING_ARRAY
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Metal
(
with
MSL
2
.
0
+
on
macOS
10
.
13
+
)
/
/
/
-
Vulkan
'
s
shaderSampledImageArrayDynamicIndexing
feature
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
SAMPLED_TEXTURE_ARRAY_DYNAMIC_INDEXING
=
0x0000_0000_0004_0000
;
/
/
/
Allows
shaders
to
index
sampled
texture
arrays
with
dynamically
non
-
uniform
values
:
/
/
/
/
/
/
eg
.
texture_array
[
vertex_data
]
/
/
/
/
/
/
In
order
to
use
this
capability
the
corresponding
GLSL
extension
must
be
enabled
like
so
:
/
/
/
/
/
/
#
extension
GL_EXT_nonuniform_qualifier
:
require
/
/
/
/
/
/
and
then
used
either
as
nonuniformEXT
qualifier
in
variable
declaration
:
/
/
/
/
/
/
eg
.
layout
(
location
=
0
)
nonuniformEXT
flat
in
int
vertex_data
;
/
/
/
/
/
/
or
as
nonuniformEXT
constructor
:
/
/
/
/
/
/
eg
.
texture_array
[
nonuniformEXT
(
vertex_data
)
]
/
/
/
/
/
/
HLSL
does
not
need
any
extension
.
/
/
/
/
/
/
This
capability
means
the
hardware
will
also
support
SAMPLED_TEXTURE_ARRAY_DYNAMIC_INDEXING
/
/
/
and
SAMPLED_TEXTURE_BINDING_ARRAY
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Metal
(
with
MSL
2
.
0
+
on
macOS
10
.
13
+
)
/
/
/
-
Vulkan
1
.
2
+
(
or
VK_EXT_descriptor_indexing
)
'
s
shaderSampledImageArrayNonUniformIndexing
feature
)
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
SAMPLED_TEXTURE_ARRAY_NON_UNIFORM_INDEXING
=
0x0000_0000_0008_0000
;
/
/
/
Allows
the
user
to
create
unsized
uniform
arrays
of
bindings
:
/
/
/
/
/
/
eg
.
uniform
texture2D
textures
[
]
.
/
/
/
/
/
/
If
this
capability
is
supported
SAMPLED_TEXTURE_ARRAY_NON_UNIFORM_INDEXING
is
very
likely
/
/
/
to
also
be
supported
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Vulkan
1
.
2
+
(
or
VK_EXT_descriptor_indexing
)
'
s
runtimeDescriptorArray
feature
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
UNSIZED_BINDING_ARRAY
=
0x0000_0000_0010_0000
;
/
/
/
Allows
the
user
to
call
[
RenderPass
:
:
multi_draw_indirect
]
and
[
RenderPass
:
:
multi_draw_indexed_indirect
]
.
/
/
/
/
/
/
Allows
multiple
indirect
calls
to
be
dispatched
from
a
single
buffer
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Metal
/
/
/
-
Vulkan
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
MULTI_DRAW_INDIRECT
=
0x0000_0000_0020_0000
;
/
/
/
Allows
the
user
to
call
[
RenderPass
:
:
multi_draw_indirect_count
]
and
[
RenderPass
:
:
multi_draw_indexed_indirect_count
]
.
/
/
/
/
/
/
This
allows
the
use
of
a
buffer
containing
the
actual
number
of
draw
calls
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Vulkan
1
.
2
+
(
or
VK_KHR_draw_indirect_count
)
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
MULTI_DRAW_INDIRECT_COUNT
=
0x0000_0000_0040_0000
;
/
/
/
Allows
the
use
of
push
constants
:
small
fast
bits
of
memory
that
can
be
updated
/
/
/
inside
a
[
RenderPass
]
.
/
/
/
/
/
/
Allows
the
user
to
call
[
RenderPass
:
:
set_push_constants
]
provide
a
non
-
empty
array
/
/
/
to
[
PipelineLayoutDescriptor
]
and
provide
a
non
-
zero
limit
to
[
Limits
:
:
max_push_constant_size
]
.
/
/
/
/
/
/
A
block
of
push
constants
can
be
declared
with
layout
(
push_constant
)
uniform
Name
{
.
.
}
in
shaders
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Vulkan
/
/
/
-
Metal
/
/
/
-
DX11
(
emulated
with
uniforms
)
/
/
/
-
OpenGL
(
emulated
with
uniforms
)
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
PUSH_CONSTANTS
=
0x0000_0000_0080_0000
;
/
/
/
Allows
the
use
of
[
AddressMode
:
:
ClampToBorder
]
.
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Vulkan
/
/
/
-
Metal
(
macOS
10
.
12
+
only
)
/
/
/
-
DX11
/
/
/
-
OpenGL
/
/
/
/
/
/
This
is
a
web
and
native
feature
.
const
ADDRESS_MODE_CLAMP_TO_BORDER
=
0x0000_0000_0100_0000
;
/
/
/
Allows
the
user
to
set
a
non
-
fill
polygon
mode
in
[
RasterizationStateDescriptor
:
:
polygon_mode
]
/
/
/
/
/
/
This
allows
drawing
polygons
/
triangles
as
lines
(
wireframe
)
or
points
instead
of
filled
/
/
/
/
/
/
Supported
platforms
:
/
/
/
-
DX12
/
/
/
-
Vulkan
/
/
/
/
/
/
This
is
a
native
only
feature
.
const
NON_FILL_POLYGON_MODE
=
0x0000_0000_0200_0000
;
/
/
/
Features
which
are
part
of
the
upstream
WebGPU
standard
.
const
ALL_WEBGPU
=
0x0000_0000_0000_FFFF
;
/
/
/
Features
that
are
only
available
when
targeting
native
(
not
web
)
.
const
ALL_NATIVE
=
0xFFFF_FFFF_FFFF_0000
;
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
Limits
{
pub
max_bind_groups
:
u32
pub
max_dynamic_uniform_buffers_per_pipeline_layout
:
u32
pub
max_dynamic_storage_buffers_per_pipeline_layout
:
u32
pub
max_sampled_textures_per_shader_stage
:
u32
pub
max_samplers_per_shader_stage
:
u32
pub
max_storage_buffers_per_shader_stage
:
u32
pub
max_storage_textures_per_shader_stage
:
u32
pub
max_uniform_buffers_per_shader_stage
:
u32
pub
max_uniform_buffer_binding_size
:
u32
pub
max_push_constant_size
:
u32
}
impl
Default
for
Limits
{
fn
default
(
)
-
>
Self
{
Self
{
max_bind_groups
:
4
max_dynamic_uniform_buffers_per_pipeline_layout
:
8
max_dynamic_storage_buffers_per_pipeline_layout
:
4
max_sampled_textures_per_shader_stage
:
16
max_samplers_per_shader_stage
:
16
max_storage_buffers_per_shader_stage
:
4
max_storage_textures_per_shader_stage
:
4
max_uniform_buffers_per_shader_stage
:
12
max_uniform_buffer_binding_size
:
16384
max_push_constant_size
:
0
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
Default
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
DeviceDescriptor
{
pub
features
:
Features
pub
limits
:
Limits
pub
shader_validation
:
bool
}
bitflags
:
:
bitflags
!
{
/
/
/
Describes
the
shader
stages
that
a
binding
will
be
visible
from
.
/
/
/
/
/
/
These
can
be
combined
so
something
that
is
visible
from
both
vertex
and
fragment
shaders
can
be
defined
as
:
/
/
/
/
/
/
ShaderStage
:
:
VERTEX
|
ShaderStage
:
:
FRAGMENT
#
[
repr
(
transparent
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Deserialize
Serialize
)
)
]
pub
struct
ShaderStage
:
u32
{
/
/
/
Binding
is
not
visible
from
any
shader
stage
.
const
NONE
=
0
;
/
/
/
Binding
is
visible
from
the
vertex
shader
of
a
render
pipeline
.
const
VERTEX
=
1
;
/
/
/
Binding
is
visible
from
the
fragment
shader
of
a
render
pipeline
.
const
FRAGMENT
=
2
;
/
/
/
Binding
is
visible
from
the
compute
shader
of
a
compute
pipeline
.
const
COMPUTE
=
4
;
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TextureViewDimension
{
D1
D2
D2Array
Cube
CubeArray
D3
}
impl
TextureViewDimension
{
pub
fn
compatible_texture_dimension
(
self
)
-
>
TextureDimension
{
match
self
{
Self
:
:
D1
=
>
TextureDimension
:
:
D1
Self
:
:
D2
|
Self
:
:
D2Array
|
Self
:
:
Cube
|
Self
:
:
CubeArray
=
>
TextureDimension
:
:
D2
Self
:
:
D3
=
>
TextureDimension
:
:
D3
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
BlendFactor
{
Zero
=
0
One
=
1
SrcColor
=
2
OneMinusSrcColor
=
3
SrcAlpha
=
4
OneMinusSrcAlpha
=
5
DstColor
=
6
OneMinusDstColor
=
7
DstAlpha
=
8
OneMinusDstAlpha
=
9
SrcAlphaSaturated
=
10
BlendColor
=
11
OneMinusBlendColor
=
12
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
BlendOperation
{
Add
=
0
Subtract
=
1
ReverseSubtract
=
2
Min
=
3
Max
=
4
}
impl
Default
for
BlendOperation
{
fn
default
(
)
-
>
Self
{
Self
:
:
Add
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
BlendDescriptor
{
pub
src_factor
:
BlendFactor
pub
dst_factor
:
BlendFactor
pub
operation
:
BlendOperation
}
impl
BlendDescriptor
{
pub
const
REPLACE
:
Self
=
BlendDescriptor
{
src_factor
:
BlendFactor
:
:
One
dst_factor
:
BlendFactor
:
:
Zero
operation
:
BlendOperation
:
:
Add
}
;
pub
fn
uses_color
(
&
self
)
-
>
bool
{
match
(
self
.
src_factor
self
.
dst_factor
)
{
(
BlendFactor
:
:
BlendColor
_
)
|
(
BlendFactor
:
:
OneMinusBlendColor
_
)
|
(
_
BlendFactor
:
:
BlendColor
)
|
(
_
BlendFactor
:
:
OneMinusBlendColor
)
=
>
true
(
_
_
)
=
>
false
}
}
}
impl
Default
for
BlendDescriptor
{
fn
default
(
)
-
>
Self
{
Self
:
:
REPLACE
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
ColorStateDescriptor
{
pub
format
:
TextureFormat
pub
alpha_blend
:
BlendDescriptor
pub
color_blend
:
BlendDescriptor
pub
write_mask
:
ColorWrite
}
impl
From
<
TextureFormat
>
for
ColorStateDescriptor
{
fn
from
(
format
:
TextureFormat
)
-
>
Self
{
Self
{
format
alpha_blend
:
BlendDescriptor
:
:
REPLACE
color_blend
:
BlendDescriptor
:
:
REPLACE
write_mask
:
ColorWrite
:
:
ALL
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
PrimitiveTopology
{
PointList
=
0
LineList
=
1
LineStrip
=
2
TriangleList
=
3
TriangleStrip
=
4
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
FrontFace
{
Ccw
=
0
Cw
=
1
}
impl
Default
for
FrontFace
{
fn
default
(
)
-
>
Self
{
Self
:
:
Ccw
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
CullMode
{
None
=
0
Front
=
1
Back
=
2
}
impl
Default
for
CullMode
{
fn
default
(
)
-
>
Self
{
Self
:
:
None
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
PolygonMode
{
Fill
=
0
Line
=
1
Point
=
2
}
impl
Default
for
PolygonMode
{
fn
default
(
)
-
>
Self
{
Self
:
:
Fill
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
Default
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RasterizationStateDescriptor
{
pub
front_face
:
FrontFace
pub
cull_mode
:
CullMode
pub
polygon_mode
:
PolygonMode
pub
clamp_depth
:
bool
pub
depth_bias
:
i32
pub
depth_bias_slope_scale
:
f32
pub
depth_bias_clamp
:
f32
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Deserialize
Serialize
)
)
]
pub
enum
TextureFormat
{
R8Unorm
=
0
R8Snorm
=
1
R8Uint
=
2
R8Sint
=
3
R16Uint
=
4
R16Sint
=
5
R16Float
=
6
Rg8Unorm
=
7
Rg8Snorm
=
8
Rg8Uint
=
9
Rg8Sint
=
10
R32Uint
=
11
R32Sint
=
12
R32Float
=
13
Rg16Uint
=
14
Rg16Sint
=
15
Rg16Float
=
16
Rgba8Unorm
=
17
Rgba8UnormSrgb
=
18
Rgba8Snorm
=
19
Rgba8Uint
=
20
Rgba8Sint
=
21
Bgra8Unorm
=
22
Bgra8UnormSrgb
=
23
Rgb10a2Unorm
=
24
Rg11b10Float
=
25
Rg32Uint
=
26
Rg32Sint
=
27
Rg32Float
=
28
Rgba16Uint
=
29
Rgba16Sint
=
30
Rgba16Float
=
31
Rgba32Uint
=
32
Rgba32Sint
=
33
Rgba32Float
=
34
Depth32Float
=
35
Depth24Plus
=
36
Depth24PlusStencil8
=
37
Bc1RgbaUnorm
=
38
Bc1RgbaUnormSrgb
=
39
Bc2RgbaUnorm
=
40
Bc2RgbaUnormSrgb
=
41
Bc3RgbaUnorm
=
42
Bc3RgbaUnormSrgb
=
43
Bc4RUnorm
=
44
Bc4RSnorm
=
45
Bc5RgUnorm
=
46
Bc5RgSnorm
=
47
Bc6hRgbUfloat
=
48
Bc6hRgbSfloat
=
49
Bc7RgbaUnorm
=
50
Bc7RgbaUnormSrgb
=
51
}
bitflags
:
:
bitflags
!
{
/
/
/
Color
write
mask
.
Disabled
color
channels
will
not
be
written
to
.
#
[
repr
(
transparent
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
ColorWrite
:
u32
{
/
/
/
Enable
red
channel
writes
const
RED
=
1
;
/
/
/
Enable
green
channel
writes
const
GREEN
=
2
;
/
/
/
Enable
blue
channel
writes
const
BLUE
=
4
;
/
/
/
Enable
alpha
channel
writes
const
ALPHA
=
8
;
/
/
/
Enable
red
green
and
blue
channel
writes
const
COLOR
=
7
;
/
/
/
Enable
writes
to
all
channels
.
const
ALL
=
15
;
}
}
impl
Default
for
ColorWrite
{
fn
default
(
)
-
>
Self
{
Self
:
:
ALL
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
Default
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
StencilStateDescriptor
{
pub
front
:
StencilStateFaceDescriptor
pub
back
:
StencilStateFaceDescriptor
pub
read_mask
:
u32
pub
write_mask
:
u32
}
impl
StencilStateDescriptor
{
pub
fn
is_enabled
(
&
self
)
-
>
bool
{
(
self
.
front
!
=
StencilStateFaceDescriptor
:
:
IGNORE
|
|
self
.
back
!
=
StencilStateFaceDescriptor
:
:
IGNORE
)
&
&
(
self
.
read_mask
!
=
0
|
|
self
.
write_mask
!
=
0
)
}
pub
fn
is_read_only
(
&
self
)
-
>
bool
{
self
.
write_mask
=
=
0
}
pub
fn
needs_ref_value
(
&
self
)
-
>
bool
{
self
.
front
.
compare
.
needs_ref_value
(
)
|
|
self
.
back
.
compare
.
needs_ref_value
(
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
DepthStencilStateDescriptor
{
pub
format
:
TextureFormat
pub
depth_write_enabled
:
bool
pub
depth_compare
:
CompareFunction
pub
stencil
:
StencilStateDescriptor
}
impl
DepthStencilStateDescriptor
{
pub
fn
is_depth_enabled
(
&
self
)
-
>
bool
{
self
.
depth_compare
!
=
CompareFunction
:
:
Always
|
|
self
.
depth_write_enabled
}
pub
fn
is_read_only
(
&
self
)
-
>
bool
{
!
self
.
depth_write_enabled
&
&
self
.
stencil
.
is_read_only
(
)
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
IndexFormat
{
Uint16
=
0
Uint32
=
1
}
impl
Default
for
IndexFormat
{
fn
default
(
)
-
>
Self
{
Self
:
:
Uint32
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
StencilOperation
{
Keep
=
0
Zero
=
1
Replace
=
2
Invert
=
3
IncrementClamp
=
4
DecrementClamp
=
5
IncrementWrap
=
6
DecrementWrap
=
7
}
impl
Default
for
StencilOperation
{
fn
default
(
)
-
>
Self
{
Self
:
:
Keep
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
StencilStateFaceDescriptor
{
pub
compare
:
CompareFunction
pub
fail_op
:
StencilOperation
pub
depth_fail_op
:
StencilOperation
pub
pass_op
:
StencilOperation
}
impl
StencilStateFaceDescriptor
{
pub
const
IGNORE
:
Self
=
StencilStateFaceDescriptor
{
compare
:
CompareFunction
:
:
Always
fail_op
:
StencilOperation
:
:
Keep
depth_fail_op
:
StencilOperation
:
:
Keep
pass_op
:
StencilOperation
:
:
Keep
}
;
}
impl
Default
for
StencilStateFaceDescriptor
{
fn
default
(
)
-
>
Self
{
Self
:
:
IGNORE
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
CompareFunction
{
Never
=
1
Less
=
2
Equal
=
3
LessEqual
=
4
Greater
=
5
NotEqual
=
6
GreaterEqual
=
7
Always
=
8
}
impl
CompareFunction
{
pub
fn
needs_ref_value
(
self
)
-
>
bool
{
match
self
{
Self
:
:
Never
|
Self
:
:
Always
=
>
false
_
=
>
true
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
InputStepMode
{
Vertex
=
0
Instance
=
1
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
VertexAttributeDescriptor
{
pub
offset
:
BufferAddress
pub
format
:
VertexFormat
pub
shader_location
:
ShaderLocation
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
VertexFormat
{
Uchar2
=
0
Uchar4
=
1
Char2
=
2
Char4
=
3
Uchar2Norm
=
4
Uchar4Norm
=
5
Char2Norm
=
6
Char4Norm
=
7
Ushort2
=
8
Ushort4
=
9
Short2
=
10
Short4
=
11
Ushort2Norm
=
12
Ushort4Norm
=
13
Short2Norm
=
14
Short4Norm
=
15
Half2
=
16
Half4
=
17
Float
=
18
Float2
=
19
Float3
=
20
Float4
=
21
Uint
=
22
Uint2
=
23
Uint3
=
24
Uint4
=
25
Int
=
26
Int2
=
27
Int3
=
28
Int4
=
29
}
impl
VertexFormat
{
pub
fn
size
(
&
self
)
-
>
u64
{
match
self
{
Self
:
:
Uchar2
|
Self
:
:
Char2
|
Self
:
:
Uchar2Norm
|
Self
:
:
Char2Norm
=
>
2
Self
:
:
Uchar4
|
Self
:
:
Char4
|
Self
:
:
Uchar4Norm
|
Self
:
:
Char4Norm
|
Self
:
:
Ushort2
|
Self
:
:
Short2
|
Self
:
:
Ushort2Norm
|
Self
:
:
Short2Norm
|
Self
:
:
Half2
|
Self
:
:
Float
|
Self
:
:
Uint
|
Self
:
:
Int
=
>
4
Self
:
:
Ushort4
|
Self
:
:
Short4
|
Self
:
:
Ushort4Norm
|
Self
:
:
Short4Norm
|
Self
:
:
Half4
|
Self
:
:
Float2
|
Self
:
:
Uint2
|
Self
:
:
Int2
=
>
8
Self
:
:
Float3
|
Self
:
:
Uint3
|
Self
:
:
Int3
=
>
12
Self
:
:
Float4
|
Self
:
:
Uint4
|
Self
:
:
Int4
=
>
16
}
}
}
bitflags
:
:
bitflags
!
{
/
/
/
Different
ways
that
you
can
use
a
buffer
.
/
/
/
/
/
/
The
usages
determine
what
kind
of
memory
the
buffer
is
allocated
from
and
what
/
/
/
actions
the
buffer
can
partake
in
.
#
[
repr
(
transparent
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
BufferUsage
:
u32
{
/
/
/
Allow
a
buffer
to
be
mapped
for
reading
using
[
Buffer
:
:
map_async
]
+
[
Buffer
:
:
get_mapped_range
]
.
/
/
/
This
does
not
include
creating
a
buffer
with
[
BufferDescriptor
:
:
mapped_at_creation
]
set
.
/
/
/
/
/
/
If
[
Features
:
:
MAPPABLE_PRIMARY_BUFFERS
]
isn
'
t
enabled
the
only
other
usage
a
buffer
/
/
/
may
have
is
COPY_DST
.
const
MAP_READ
=
1
;
/
/
/
Allow
a
buffer
to
be
mapped
for
writing
using
[
Buffer
:
:
map_async
]
+
[
Buffer
:
:
get_mapped_range_mut
]
.
/
/
/
This
does
not
include
creating
a
buffer
with
mapped_at_creation
set
.
/
/
/
/
/
/
If
[
Features
:
:
MAPPABLE_PRIMARY_BUFFERS
]
feature
isn
'
t
enabled
the
only
other
usage
a
buffer
/
/
/
may
have
is
COPY_SRC
.
const
MAP_WRITE
=
2
;
/
/
/
Allow
a
buffer
to
be
the
source
buffer
for
a
[
CommandEncoder
:
:
copy_buffer_to_buffer
]
or
[
CommandEncoder
:
:
copy_buffer_to_texture
]
/
/
/
operation
.
const
COPY_SRC
=
4
;
/
/
/
Allow
a
buffer
to
be
the
destination
buffer
for
a
[
CommandEncoder
:
:
copy_buffer_to_buffer
]
[
CommandEncoder
:
:
copy_texture_to_buffer
]
/
/
/
or
[
Queue
:
:
write_buffer
]
operation
.
const
COPY_DST
=
8
;
/
/
/
Allow
a
buffer
to
be
the
index
buffer
in
a
draw
operation
.
const
INDEX
=
16
;
/
/
/
Allow
a
buffer
to
be
the
vertex
buffer
in
a
draw
operation
.
const
VERTEX
=
32
;
/
/
/
Allow
a
buffer
to
be
a
[
BindingType
:
:
UniformBuffer
]
inside
a
bind
group
.
const
UNIFORM
=
64
;
/
/
/
Allow
a
buffer
to
be
a
[
BindingType
:
:
StorageBuffer
]
inside
a
bind
group
.
const
STORAGE
=
128
;
/
/
/
Allow
a
buffer
to
be
the
indirect
buffer
in
an
indirect
draw
call
.
const
INDIRECT
=
256
;
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
BufferDescriptor
<
L
>
{
pub
label
:
L
pub
size
:
BufferAddress
pub
usage
:
BufferUsage
pub
mapped_at_creation
:
bool
}
impl
<
L
>
BufferDescriptor
<
L
>
{
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
BufferDescriptor
<
K
>
{
BufferDescriptor
{
label
:
fun
(
&
self
.
label
)
size
:
self
.
size
usage
:
self
.
usage
mapped_at_creation
:
self
.
mapped_at_creation
}
}
}
#
[
repr
(
C
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
pub
struct
CommandEncoderDescriptor
<
L
>
{
pub
label
:
L
}
impl
<
L
>
CommandEncoderDescriptor
<
L
>
{
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
CommandEncoderDescriptor
<
K
>
{
CommandEncoderDescriptor
{
label
:
fun
(
&
self
.
label
)
}
}
}
impl
<
T
>
Default
for
CommandEncoderDescriptor
<
Option
<
T
>
>
{
fn
default
(
)
-
>
Self
{
Self
{
label
:
None
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
PresentMode
{
Immediate
=
0
Mailbox
=
1
Fifo
=
2
}
bitflags
:
:
bitflags
!
{
/
/
/
Different
ways
that
you
can
use
a
texture
.
/
/
/
/
/
/
The
usages
determine
what
kind
of
memory
the
texture
is
allocated
from
and
what
/
/
/
actions
the
texture
can
partake
in
.
#
[
repr
(
transparent
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
TextureUsage
:
u32
{
/
/
/
Allows
a
texture
to
be
the
source
in
a
[
CommandEncoder
:
:
copy_texture_to_buffer
]
or
/
/
/
[
CommandEncoder
:
:
copy_texture_to_texture
]
operation
.
const
COPY_SRC
=
1
;
/
/
/
Allows
a
texture
to
be
the
destination
in
a
[
CommandEncoder
:
:
copy_texture_to_buffer
]
/
/
/
[
CommandEncoder
:
:
copy_texture_to_texture
]
or
[
Queue
:
:
write_texture
]
operation
.
const
COPY_DST
=
2
;
/
/
/
Allows
a
texture
to
be
a
[
BindingType
:
:
SampledTexture
]
in
a
bind
group
.
const
SAMPLED
=
4
;
/
/
/
Allows
a
texture
to
be
a
[
BindingType
:
:
StorageTexture
]
in
a
bind
group
.
const
STORAGE
=
8
;
/
/
/
Allows
a
texture
to
be
a
output
attachment
of
a
renderpass
.
const
OUTPUT_ATTACHMENT
=
16
;
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
SwapChainDescriptor
{
pub
usage
:
TextureUsage
pub
format
:
TextureFormat
pub
width
:
u32
pub
height
:
u32
pub
present_mode
:
PresentMode
}
#
[
repr
(
C
)
]
#
[
derive
(
Debug
)
]
pub
enum
SwapChainStatus
{
Good
Suboptimal
Timeout
Outdated
Lost
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
Default
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
serde
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
Color
{
pub
r
:
f64
pub
g
:
f64
pub
b
:
f64
pub
a
:
f64
}
impl
Color
{
pub
const
TRANSPARENT
:
Self
=
Self
{
r
:
0
.
0
g
:
0
.
0
b
:
0
.
0
a
:
0
.
0
}
;
pub
const
BLACK
:
Self
=
Self
{
r
:
0
.
0
g
:
0
.
0
b
:
0
.
0
a
:
1
.
0
}
;
pub
const
WHITE
:
Self
=
Self
{
r
:
1
.
0
g
:
1
.
0
b
:
1
.
0
a
:
1
.
0
}
;
pub
const
RED
:
Self
=
Self
{
r
:
1
.
0
g
:
0
.
0
b
:
0
.
0
a
:
1
.
0
}
;
pub
const
GREEN
:
Self
=
Self
{
r
:
0
.
0
g
:
1
.
0
b
:
0
.
0
a
:
1
.
0
}
;
pub
const
BLUE
:
Self
=
Self
{
r
:
0
.
0
g
:
0
.
0
b
:
1
.
0
a
:
1
.
0
}
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TextureDimension
{
D1
D2
D3
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
Origin3d
{
pub
x
:
u32
pub
y
:
u32
pub
z
:
u32
}
impl
Origin3d
{
pub
const
ZERO
:
Self
=
Self
{
x
:
0
y
:
0
z
:
0
}
;
}
impl
Default
for
Origin3d
{
fn
default
(
)
-
>
Self
{
Self
:
:
ZERO
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
Extent3d
{
pub
width
:
u32
pub
height
:
u32
pub
depth
:
u32
}
impl
Default
for
Extent3d
{
fn
default
(
)
-
>
Self
{
Self
{
width
:
1
height
:
1
depth
:
1
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
TextureDescriptor
<
L
>
{
pub
label
:
L
pub
size
:
Extent3d
pub
mip_level_count
:
u32
pub
sample_count
:
u32
pub
dimension
:
TextureDimension
pub
format
:
TextureFormat
pub
usage
:
TextureUsage
}
impl
<
L
>
TextureDescriptor
<
L
>
{
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
TextureDescriptor
<
K
>
{
TextureDescriptor
{
label
:
fun
(
&
self
.
label
)
size
:
self
.
size
mip_level_count
:
self
.
mip_level_count
sample_count
:
self
.
sample_count
dimension
:
self
.
dimension
format
:
self
.
format
usage
:
self
.
usage
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TextureAspect
{
All
StencilOnly
DepthOnly
}
impl
Default
for
TextureAspect
{
fn
default
(
)
-
>
Self
{
Self
:
:
All
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
AddressMode
{
ClampToEdge
=
0
Repeat
=
1
MirrorRepeat
=
2
ClampToBorder
=
3
}
impl
Default
for
AddressMode
{
fn
default
(
)
-
>
Self
{
Self
:
:
ClampToEdge
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
FilterMode
{
Nearest
=
0
Linear
=
1
}
impl
Default
for
FilterMode
{
fn
default
(
)
-
>
Self
{
Self
:
:
Nearest
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
PushConstantRange
{
pub
stages
:
ShaderStage
pub
range
:
Range
<
u32
>
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
Default
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
CommandBufferDescriptor
<
L
>
{
pub
label
:
L
}
impl
<
L
>
CommandBufferDescriptor
<
L
>
{
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
CommandBufferDescriptor
<
K
>
{
CommandBufferDescriptor
{
label
:
fun
(
&
self
.
label
)
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderBundleDescriptor
<
L
>
{
pub
label
:
L
}
impl
<
L
>
RenderBundleDescriptor
<
L
>
{
pub
fn
map_label
<
K
>
(
&
self
fun
:
impl
FnOnce
(
&
L
)
-
>
K
)
-
>
RenderBundleDescriptor
<
K
>
{
RenderBundleDescriptor
{
label
:
fun
(
&
self
.
label
)
}
}
}
impl
<
T
>
Default
for
RenderBundleDescriptor
<
Option
<
T
>
>
{
fn
default
(
)
-
>
Self
{
Self
{
label
:
None
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TextureComponentType
{
Float
Sint
Uint
DepthComparison
}
impl
From
<
TextureFormat
>
for
TextureComponentType
{
fn
from
(
format
:
TextureFormat
)
-
>
Self
{
match
format
{
TextureFormat
:
:
R8Uint
|
TextureFormat
:
:
R16Uint
|
TextureFormat
:
:
Rg8Uint
|
TextureFormat
:
:
R32Uint
|
TextureFormat
:
:
Rg16Uint
|
TextureFormat
:
:
Rgba8Uint
|
TextureFormat
:
:
Rg32Uint
|
TextureFormat
:
:
Rgba16Uint
|
TextureFormat
:
:
Rgba32Uint
=
>
Self
:
:
Uint
TextureFormat
:
:
R8Sint
|
TextureFormat
:
:
R16Sint
|
TextureFormat
:
:
Rg8Sint
|
TextureFormat
:
:
R32Sint
|
TextureFormat
:
:
Rg16Sint
|
TextureFormat
:
:
Rgba8Sint
|
TextureFormat
:
:
Rg32Sint
|
TextureFormat
:
:
Rgba16Sint
|
TextureFormat
:
:
Rgba32Sint
=
>
Self
:
:
Sint
TextureFormat
:
:
R8Unorm
|
TextureFormat
:
:
R8Snorm
|
TextureFormat
:
:
R16Float
|
TextureFormat
:
:
R32Float
|
TextureFormat
:
:
Rg8Unorm
|
TextureFormat
:
:
Rg8Snorm
|
TextureFormat
:
:
Rg16Float
|
TextureFormat
:
:
Rg11b10Float
|
TextureFormat
:
:
Rg32Float
|
TextureFormat
:
:
Rgba8Snorm
|
TextureFormat
:
:
Rgba16Float
|
TextureFormat
:
:
Rgba32Float
|
TextureFormat
:
:
Rgba8Unorm
|
TextureFormat
:
:
Rgba8UnormSrgb
|
TextureFormat
:
:
Bgra8Unorm
|
TextureFormat
:
:
Bgra8UnormSrgb
|
TextureFormat
:
:
Rgb10a2Unorm
|
TextureFormat
:
:
Depth32Float
|
TextureFormat
:
:
Depth24Plus
|
TextureFormat
:
:
Depth24PlusStencil8
|
TextureFormat
:
:
Bc1RgbaUnorm
|
TextureFormat
:
:
Bc1RgbaUnormSrgb
|
TextureFormat
:
:
Bc2RgbaUnorm
|
TextureFormat
:
:
Bc2RgbaUnormSrgb
|
TextureFormat
:
:
Bc3RgbaUnorm
|
TextureFormat
:
:
Bc3RgbaUnormSrgb
|
TextureFormat
:
:
Bc4RUnorm
|
TextureFormat
:
:
Bc4RSnorm
|
TextureFormat
:
:
Bc5RgUnorm
|
TextureFormat
:
:
Bc5RgSnorm
|
TextureFormat
:
:
Bc6hRgbSfloat
|
TextureFormat
:
:
Bc6hRgbUfloat
|
TextureFormat
:
:
Bc7RgbaUnorm
|
TextureFormat
:
:
Bc7RgbaUnormSrgb
=
>
Self
:
:
Float
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
Default
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
TextureDataLayout
{
pub
offset
:
BufferAddress
pub
bytes_per_row
:
u32
pub
rows_per_image
:
u32
}
#
[
derive
(
Clone
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
BindingType
{
UniformBuffer
{
dynamic
:
bool
min_binding_size
:
Option
<
BufferSize
>
}
StorageBuffer
{
dynamic
:
bool
min_binding_size
:
Option
<
BufferSize
>
readonly
:
bool
}
Sampler
{
comparison
:
bool
}
SampledTexture
{
dimension
:
TextureViewDimension
component_type
:
TextureComponentType
multisampled
:
bool
}
StorageTexture
{
dimension
:
TextureViewDimension
format
:
TextureFormat
readonly
:
bool
}
}
impl
BindingType
{
pub
fn
has_dynamic_offset
(
&
self
)
-
>
bool
{
match
*
self
{
Self
:
:
UniformBuffer
{
dynamic
.
.
}
|
Self
:
:
StorageBuffer
{
dynamic
.
.
}
=
>
dynamic
_
=
>
false
}
}
}
#
[
derive
(
Clone
Debug
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
BindGroupLayoutEntry
{
pub
binding
:
u32
pub
visibility
:
ShaderStage
pub
ty
:
BindingType
pub
count
:
Option
<
NonZeroU32
>
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
BufferCopyView
<
B
>
{
pub
buffer
:
B
pub
layout
:
TextureDataLayout
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
struct
TextureCopyView
<
T
>
{
pub
texture
:
T
pub
mip_level
:
u32
#
[
cfg_attr
(
any
(
feature
=
"
replay
"
feature
=
"
trace
"
)
serde
(
default
)
)
]
pub
origin
:
Origin3d
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
trace
"
derive
(
serde
:
:
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
serde
:
:
Deserialize
)
)
]
pub
enum
SamplerBorderColor
{
TransparentBlack
OpaqueBlack
OpaqueWhite
}
