use
crate
:
:
{
iccread
:
:
LAB_SIGNATURE
iccread
:
:
RGB_SIGNATURE
iccread
:
:
XYZ_SIGNATURE
iccread
:
:
{
curveType
lutType
lutmABType
Profile
CMYK_SIGNATURE
}
matrix
:
:
Matrix
s15Fixed16Number_to_float
transform_util
:
:
clamp_float
transform_util
:
:
{
build_colorant_matrix
build_input_gamma_table
build_output_lut
lut_interp_linear
lut_interp_linear_float
}
}
;
trait
ModularTransform
{
fn
transform
(
&
self
src
:
&
[
f32
]
dst
:
&
mut
[
f32
]
)
;
}
#
[
inline
]
fn
lerp
(
a
:
f32
b
:
f32
t
:
f32
)
-
>
f32
{
a
*
(
1
.
0
-
t
)
+
b
*
t
}
fn
build_lut_matrix
(
lut
:
&
lutType
)
-
>
Matrix
{
Matrix
{
m
:
[
[
s15Fixed16Number_to_float
(
lut
.
e00
)
s15Fixed16Number_to_float
(
lut
.
e01
)
s15Fixed16Number_to_float
(
lut
.
e02
)
]
[
s15Fixed16Number_to_float
(
lut
.
e10
)
s15Fixed16Number_to_float
(
lut
.
e11
)
s15Fixed16Number_to_float
(
lut
.
e12
)
]
[
s15Fixed16Number_to_float
(
lut
.
e20
)
s15Fixed16Number_to_float
(
lut
.
e21
)
s15Fixed16Number_to_float
(
lut
.
e22
)
]
]
}
}
fn
build_mAB_matrix
(
lut
:
&
lutmABType
)
-
>
Matrix
{
Matrix
{
m
:
[
[
s15Fixed16Number_to_float
(
lut
.
e00
)
s15Fixed16Number_to_float
(
lut
.
e01
)
s15Fixed16Number_to_float
(
lut
.
e02
)
]
[
s15Fixed16Number_to_float
(
lut
.
e10
)
s15Fixed16Number_to_float
(
lut
.
e11
)
s15Fixed16Number_to_float
(
lut
.
e12
)
]
[
s15Fixed16Number_to_float
(
lut
.
e20
)
s15Fixed16Number_to_float
(
lut
.
e21
)
s15Fixed16Number_to_float
(
lut
.
e22
)
]
]
}
}
fn
f
(
t
:
f32
)
-
>
f32
{
if
t
<
=
24
.
/
116
.
*
(
24
.
/
116
.
)
*
(
24
.
/
116
.
)
{
(
841
.
/
108
.
*
t
)
+
16
.
/
116
.
}
else
{
t
.
powf
(
1
.
/
3
.
)
}
}
fn
f_1
(
t
:
f32
)
-
>
f32
{
if
t
<
=
24
.
0
/
116
.
0
{
(
108
.
0
/
841
.
0
)
*
(
t
-
16
.
0
/
116
.
0
)
}
else
{
t
*
t
*
t
}
}
const
WHITE_POINT_X
:
f32
=
0
.
9642
;
const
WHITE_POINT_Y
:
f32
=
1
.
0
;
const
WHITE_POINT_Z
:
f32
=
0
.
8249
;
#
[
allow
(
clippy
:
:
upper_case_acronyms
)
]
struct
LABtoXYZ
;
impl
ModularTransform
for
LABtoXYZ
{
fn
transform
(
&
self
src
:
&
[
f32
]
dest
:
&
mut
[
f32
]
)
{
for
(
dest
src
)
in
dest
.
chunks_exact_mut
(
3
)
.
zip
(
src
.
chunks_exact
(
3
)
)
{
let
device_L
=
src
[
0
]
*
100
.
0
;
let
device_a
=
src
[
1
]
*
255
.
0
-
128
.
0
;
let
device_b
=
src
[
2
]
*
255
.
0
-
128
.
0
;
let
y
=
(
device_L
+
16
.
0
)
/
116
.
0
;
let
X
=
f_1
(
y
+
0
.
002
*
device_a
)
*
WHITE_POINT_X
;
let
Y
=
f_1
(
y
)
*
WHITE_POINT_Y
;
let
Z
=
f_1
(
y
-
0
.
005
*
device_b
)
*
WHITE_POINT_Z
;
dest
[
0
]
=
(
X
as
f64
/
(
1
.
0f64
+
32767
.
0f64
/
32768
.
0f64
)
)
as
f32
;
dest
[
1
]
=
(
Y
as
f64
/
(
1
.
0f64
+
32767
.
0f64
/
32768
.
0f64
)
)
as
f32
;
dest
[
2
]
=
(
Z
as
f64
/
(
1
.
0f64
+
32767
.
0f64
/
32768
.
0f64
)
)
as
f32
;
}
}
}
#
[
allow
(
clippy
:
:
upper_case_acronyms
)
]
struct
XYZtoLAB
;
impl
ModularTransform
for
XYZtoLAB
{
fn
transform
(
&
self
src
:
&
[
f32
]
dest
:
&
mut
[
f32
]
)
{
for
(
dest
src
)
in
dest
.
chunks_exact_mut
(
3
)
.
zip
(
src
.
chunks_exact
(
3
)
)
{
let
device_x
=
(
src
[
0
]
as
f64
*
(
1
.
0f64
+
32767
.
0f64
/
32768
.
0f64
)
/
WHITE_POINT_X
as
f64
)
as
f32
;
let
device_y
=
(
src
[
1
]
as
f64
*
(
1
.
0f64
+
32767
.
0f64
/
32768
.
0f64
)
/
WHITE_POINT_Y
as
f64
)
as
f32
;
let
device_z
=
(
src
[
2
]
as
f64
*
(
1
.
0f64
+
32767
.
0f64
/
32768
.
0f64
)
/
WHITE_POINT_Z
as
f64
)
as
f32
;
let
fx
=
f
(
device_x
)
;
let
fy
=
f
(
device_y
)
;
let
fz
=
f
(
device_z
)
;
let
L
=
116
.
0
*
fy
-
16
.
0
;
let
a
=
500
.
0
*
(
fx
-
fy
)
;
let
b
=
200
.
0
*
(
fy
-
fz
)
;
dest
[
0
]
=
L
/
100
.
0
;
dest
[
1
]
=
(
a
+
128
.
0
)
/
255
.
0
;
dest
[
2
]
=
(
b
+
128
.
0
)
/
255
.
0
;
}
}
}
struct
ClutOnly
{
clut
:
Box
<
[
f32
]
>
grid_size
:
u16
}
impl
ModularTransform
for
ClutOnly
{
fn
transform
(
&
self
src
:
&
[
f32
]
dest
:
&
mut
[
f32
]
)
{
let
xy_len
=
1
;
let
x_len
=
self
.
grid_size
as
i32
;
let
len
=
x_len
*
x_len
;
let
r_table
=
&
self
.
clut
[
0
.
.
]
;
let
g_table
=
&
self
.
clut
[
1
.
.
]
;
let
b_table
=
&
self
.
clut
[
2
.
.
]
;
let
CLU
=
|
table
:
&
[
f32
]
x
y
z
|
table
[
(
(
x
*
len
+
y
*
x_len
+
z
*
xy_len
)
*
3
)
as
usize
]
;
for
(
dest
src
)
in
dest
.
chunks_exact_mut
(
3
)
.
zip
(
src
.
chunks_exact
(
3
)
)
{
debug_assert
!
(
self
.
grid_size
as
i32
>
=
1
)
;
let
linear_r
=
src
[
0
]
;
let
linear_g
=
src
[
1
]
;
let
linear_b
=
src
[
2
]
;
let
x
=
(
linear_r
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
)
.
floor
(
)
as
i32
;
let
y
=
(
linear_g
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
)
.
floor
(
)
as
i32
;
let
z
=
(
linear_b
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
)
.
floor
(
)
as
i32
;
let
x_n
=
(
linear_r
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
)
.
ceil
(
)
as
i32
;
let
y_n
=
(
linear_g
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
)
.
ceil
(
)
as
i32
;
let
z_n
=
(
linear_b
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
)
.
ceil
(
)
as
i32
;
let
x_d
=
linear_r
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
-
x
as
f32
;
let
y_d
=
linear_g
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
-
y
as
f32
;
let
z_d
=
linear_b
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
-
z
as
f32
;
let
r_x1
=
lerp
(
CLU
(
r_table
x
y
z
)
CLU
(
r_table
x_n
y
z
)
x_d
)
;
let
r_x2
=
lerp
(
CLU
(
r_table
x
y_n
z
)
CLU
(
r_table
x_n
y_n
z
)
x_d
)
;
let
r_y1
=
lerp
(
r_x1
r_x2
y_d
)
;
let
r_x3
=
lerp
(
CLU
(
r_table
x
y
z_n
)
CLU
(
r_table
x_n
y
z_n
)
x_d
)
;
let
r_x4
=
lerp
(
CLU
(
r_table
x
y_n
z_n
)
CLU
(
r_table
x_n
y_n
z_n
)
x_d
)
;
let
r_y2
=
lerp
(
r_x3
r_x4
y_d
)
;
let
clut_r
=
lerp
(
r_y1
r_y2
z_d
)
;
let
g_x1
=
lerp
(
CLU
(
g_table
x
y
z
)
CLU
(
g_table
x_n
y
z
)
x_d
)
;
let
g_x2
=
lerp
(
CLU
(
g_table
x
y_n
z
)
CLU
(
g_table
x_n
y_n
z
)
x_d
)
;
let
g_y1
=
lerp
(
g_x1
g_x2
y_d
)
;
let
g_x3
=
lerp
(
CLU
(
g_table
x
y
z_n
)
CLU
(
g_table
x_n
y
z_n
)
x_d
)
;
let
g_x4
=
lerp
(
CLU
(
g_table
x
y_n
z_n
)
CLU
(
g_table
x_n
y_n
z_n
)
x_d
)
;
let
g_y2
=
lerp
(
g_x3
g_x4
y_d
)
;
let
clut_g
=
lerp
(
g_y1
g_y2
z_d
)
;
let
b_x1
=
lerp
(
CLU
(
b_table
x
y
z
)
CLU
(
b_table
x_n
y
z
)
x_d
)
;
let
b_x2
=
lerp
(
CLU
(
b_table
x
y_n
z
)
CLU
(
b_table
x_n
y_n
z
)
x_d
)
;
let
b_y1
=
lerp
(
b_x1
b_x2
y_d
)
;
let
b_x3
=
lerp
(
CLU
(
b_table
x
y
z_n
)
CLU
(
b_table
x_n
y
z_n
)
x_d
)
;
let
b_x4
=
lerp
(
CLU
(
b_table
x
y_n
z_n
)
CLU
(
b_table
x_n
y_n
z_n
)
x_d
)
;
let
b_y2
=
lerp
(
b_x3
b_x4
y_d
)
;
let
clut_b
=
lerp
(
b_y1
b_y2
z_d
)
;
dest
[
0
]
=
clamp_float
(
clut_r
)
;
dest
[
1
]
=
clamp_float
(
clut_g
)
;
dest
[
2
]
=
clamp_float
(
clut_b
)
;
}
}
}
#
[
derive
(
Default
)
]
struct
Clut3x3
{
input_clut_table
:
[
Option
<
Vec
<
f32
>
>
;
3
]
clut
:
Option
<
Vec
<
f32
>
>
grid_size
:
u16
output_clut_table
:
[
Option
<
Vec
<
f32
>
>
;
3
]
}
impl
ModularTransform
for
Clut3x3
{
fn
transform
(
&
self
src
:
&
[
f32
]
dest
:
&
mut
[
f32
]
)
{
let
xy_len
=
1
;
let
x_len
=
self
.
grid_size
as
i32
;
let
len
=
x_len
*
x_len
;
let
r_table
=
&
self
.
clut
.
as_ref
(
)
.
unwrap
(
)
[
0
.
.
]
;
let
g_table
=
&
self
.
clut
.
as_ref
(
)
.
unwrap
(
)
[
1
.
.
]
;
let
b_table
=
&
self
.
clut
.
as_ref
(
)
.
unwrap
(
)
[
2
.
.
]
;
let
CLU
=
|
table
:
&
[
f32
]
x
y
z
|
table
[
(
(
x
*
len
+
y
*
x_len
+
z
*
xy_len
)
*
3
)
as
usize
]
;
let
input_clut_table_r
=
self
.
input_clut_table
[
0
]
.
as_ref
(
)
.
unwrap
(
)
;
let
input_clut_table_g
=
self
.
input_clut_table
[
1
]
.
as_ref
(
)
.
unwrap
(
)
;
let
input_clut_table_b
=
self
.
input_clut_table
[
2
]
.
as_ref
(
)
.
unwrap
(
)
;
for
(
dest
src
)
in
dest
.
chunks_exact_mut
(
3
)
.
zip
(
src
.
chunks_exact
(
3
)
)
{
debug_assert
!
(
self
.
grid_size
as
i32
>
=
1
)
;
let
device_r
=
src
[
0
]
;
let
device_g
=
src
[
1
]
;
let
device_b
=
src
[
2
]
;
let
linear_r
=
lut_interp_linear_float
(
device_r
&
input_clut_table_r
)
;
let
linear_g
=
lut_interp_linear_float
(
device_g
&
input_clut_table_g
)
;
let
linear_b
=
lut_interp_linear_float
(
device_b
&
input_clut_table_b
)
;
let
x
=
(
linear_r
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
)
.
floor
(
)
as
i32
;
let
y
=
(
linear_g
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
)
.
floor
(
)
as
i32
;
let
z
=
(
linear_b
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
)
.
floor
(
)
as
i32
;
let
x_n
=
(
linear_r
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
)
.
ceil
(
)
as
i32
;
let
y_n
=
(
linear_g
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
)
.
ceil
(
)
as
i32
;
let
z_n
=
(
linear_b
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
)
.
ceil
(
)
as
i32
;
let
x_d
=
linear_r
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
-
x
as
f32
;
let
y_d
=
linear_g
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
-
y
as
f32
;
let
z_d
=
linear_b
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
-
z
as
f32
;
let
r_x1
=
lerp
(
CLU
(
r_table
x
y
z
)
CLU
(
r_table
x_n
y
z
)
x_d
)
;
let
r_x2
=
lerp
(
CLU
(
r_table
x
y_n
z
)
CLU
(
r_table
x_n
y_n
z
)
x_d
)
;
let
r_y1
=
lerp
(
r_x1
r_x2
y_d
)
;
let
r_x3
=
lerp
(
CLU
(
r_table
x
y
z_n
)
CLU
(
r_table
x_n
y
z_n
)
x_d
)
;
let
r_x4
=
lerp
(
CLU
(
r_table
x
y_n
z_n
)
CLU
(
r_table
x_n
y_n
z_n
)
x_d
)
;
let
r_y2
=
lerp
(
r_x3
r_x4
y_d
)
;
let
clut_r
=
lerp
(
r_y1
r_y2
z_d
)
;
let
g_x1
=
lerp
(
CLU
(
g_table
x
y
z
)
CLU
(
g_table
x_n
y
z
)
x_d
)
;
let
g_x2
=
lerp
(
CLU
(
g_table
x
y_n
z
)
CLU
(
g_table
x_n
y_n
z
)
x_d
)
;
let
g_y1
=
lerp
(
g_x1
g_x2
y_d
)
;
let
g_x3
=
lerp
(
CLU
(
g_table
x
y
z_n
)
CLU
(
g_table
x_n
y
z_n
)
x_d
)
;
let
g_x4
=
lerp
(
CLU
(
g_table
x
y_n
z_n
)
CLU
(
g_table
x_n
y_n
z_n
)
x_d
)
;
let
g_y2
=
lerp
(
g_x3
g_x4
y_d
)
;
let
clut_g
=
lerp
(
g_y1
g_y2
z_d
)
;
let
b_x1
=
lerp
(
CLU
(
b_table
x
y
z
)
CLU
(
b_table
x_n
y
z
)
x_d
)
;
let
b_x2
=
lerp
(
CLU
(
b_table
x
y_n
z
)
CLU
(
b_table
x_n
y_n
z
)
x_d
)
;
let
b_y1
=
lerp
(
b_x1
b_x2
y_d
)
;
let
b_x3
=
lerp
(
CLU
(
b_table
x
y
z_n
)
CLU
(
b_table
x_n
y
z_n
)
x_d
)
;
let
b_x4
=
lerp
(
CLU
(
b_table
x
y_n
z_n
)
CLU
(
b_table
x_n
y_n
z_n
)
x_d
)
;
let
b_y2
=
lerp
(
b_x3
b_x4
y_d
)
;
let
clut_b
=
lerp
(
b_y1
b_y2
z_d
)
;
let
pcs_r
=
lut_interp_linear_float
(
clut_r
&
self
.
output_clut_table
[
0
]
.
as_ref
(
)
.
unwrap
(
)
)
;
let
pcs_g
=
lut_interp_linear_float
(
clut_g
&
self
.
output_clut_table
[
1
]
.
as_ref
(
)
.
unwrap
(
)
)
;
let
pcs_b
=
lut_interp_linear_float
(
clut_b
&
self
.
output_clut_table
[
2
]
.
as_ref
(
)
.
unwrap
(
)
)
;
dest
[
0
]
=
clamp_float
(
pcs_r
)
;
dest
[
1
]
=
clamp_float
(
pcs_g
)
;
dest
[
2
]
=
clamp_float
(
pcs_b
)
;
}
}
}
#
[
derive
(
Default
)
]
struct
Clut4x3
{
input_clut_table
:
[
Option
<
Vec
<
f32
>
>
;
4
]
clut
:
Option
<
Vec
<
f32
>
>
grid_size
:
u16
output_clut_table
:
[
Option
<
Vec
<
f32
>
>
;
3
]
}
impl
ModularTransform
for
Clut4x3
{
fn
transform
(
&
self
src
:
&
[
f32
]
dest
:
&
mut
[
f32
]
)
{
let
z_stride
=
self
.
grid_size
as
i32
;
let
y_stride
=
z_stride
*
z_stride
;
let
x_stride
=
z_stride
*
z_stride
*
z_stride
;
let
r_tbl
=
&
self
.
clut
.
as_ref
(
)
.
unwrap
(
)
[
0
.
.
]
;
let
g_tbl
=
&
self
.
clut
.
as_ref
(
)
.
unwrap
(
)
[
1
.
.
]
;
let
b_tbl
=
&
self
.
clut
.
as_ref
(
)
.
unwrap
(
)
[
2
.
.
]
;
let
CLU
=
|
table
:
&
[
f32
]
x
y
z
w
|
{
table
[
(
(
x
*
x_stride
+
y
*
y_stride
+
z
*
z_stride
+
w
)
*
3
)
as
usize
]
}
;
let
input_clut_table_0
=
self
.
input_clut_table
[
0
]
.
as_ref
(
)
.
unwrap
(
)
;
let
input_clut_table_1
=
self
.
input_clut_table
[
1
]
.
as_ref
(
)
.
unwrap
(
)
;
let
input_clut_table_2
=
self
.
input_clut_table
[
2
]
.
as_ref
(
)
.
unwrap
(
)
;
let
input_clut_table_3
=
self
.
input_clut_table
[
3
]
.
as_ref
(
)
.
unwrap
(
)
;
for
(
dest
src
)
in
dest
.
chunks_exact_mut
(
3
)
.
zip
(
src
.
chunks_exact
(
4
)
)
{
debug_assert
!
(
self
.
grid_size
as
i32
>
=
1
)
;
let
linear_x
=
lut_interp_linear_float
(
src
[
0
]
&
input_clut_table_0
)
;
let
linear_y
=
lut_interp_linear_float
(
src
[
1
]
&
input_clut_table_1
)
;
let
linear_z
=
lut_interp_linear_float
(
src
[
2
]
&
input_clut_table_2
)
;
let
linear_w
=
lut_interp_linear_float
(
src
[
3
]
&
input_clut_table_3
)
;
let
x
=
(
linear_x
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
)
.
floor
(
)
as
i32
;
let
y
=
(
linear_y
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
)
.
floor
(
)
as
i32
;
let
z
=
(
linear_z
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
)
.
floor
(
)
as
i32
;
let
w
=
(
linear_w
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
)
.
floor
(
)
as
i32
;
let
x_n
=
(
linear_x
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
)
.
ceil
(
)
as
i32
;
let
y_n
=
(
linear_y
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
)
.
ceil
(
)
as
i32
;
let
z_n
=
(
linear_z
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
)
.
ceil
(
)
as
i32
;
let
w_n
=
(
linear_w
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
)
.
ceil
(
)
as
i32
;
let
x_d
=
linear_x
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
-
x
as
f32
;
let
y_d
=
linear_y
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
-
y
as
f32
;
let
z_d
=
linear_z
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
-
z
as
f32
;
let
w_d
=
linear_w
*
(
self
.
grid_size
as
i32
-
1
)
as
f32
-
w
as
f32
;
let
quadlinear
=
|
tbl
|
{
let
CLU
=
|
x
y
z
w
|
CLU
(
tbl
x
y
z
w
)
;
let
r_x1
=
lerp
(
CLU
(
x
y
z
w
)
CLU
(
x_n
y
z
w
)
x_d
)
;
let
r_x2
=
lerp
(
CLU
(
x
y_n
z
w
)
CLU
(
x_n
y_n
z
w
)
x_d
)
;
let
r_y1
=
lerp
(
r_x1
r_x2
y_d
)
;
let
r_x3
=
lerp
(
CLU
(
x
y
z_n
w
)
CLU
(
x_n
y
z_n
w
)
x_d
)
;
let
r_x4
=
lerp
(
CLU
(
x
y_n
z_n
w
)
CLU
(
x_n
y_n
z_n
w
)
x_d
)
;
let
r_y2
=
lerp
(
r_x3
r_x4
y_d
)
;
let
r_z1
=
lerp
(
r_y1
r_y2
z_d
)
;
let
r_x1
=
lerp
(
CLU
(
x
y
z
w_n
)
CLU
(
x_n
y
z
w_n
)
x_d
)
;
let
r_x2
=
lerp
(
CLU
(
x
y_n
z
w_n
)
CLU
(
x_n
y_n
z
w_n
)
x_d
)
;
let
r_y1
=
lerp
(
r_x1
r_x2
y_d
)
;
let
r_x3
=
lerp
(
CLU
(
x
y
z_n
w_n
)
CLU
(
x_n
y
z_n
w_n
)
x_d
)
;
let
r_x4
=
lerp
(
CLU
(
x
y_n
z_n
w_n
)
CLU
(
x_n
y_n
z_n
w_n
)
x_d
)
;
let
r_y2
=
lerp
(
r_x3
r_x4
y_d
)
;
let
r_z2
=
lerp
(
r_y1
r_y2
z_d
)
;
lerp
(
r_z1
r_z2
w_d
)
}
;
let
clut_r
=
quadlinear
(
r_tbl
)
;
let
clut_g
=
quadlinear
(
g_tbl
)
;
let
clut_b
=
quadlinear
(
b_tbl
)
;
let
pcs_r
=
lut_interp_linear_float
(
clut_r
&
self
.
output_clut_table
[
0
]
.
as_ref
(
)
.
unwrap
(
)
)
;
let
pcs_g
=
lut_interp_linear_float
(
clut_g
&
self
.
output_clut_table
[
1
]
.
as_ref
(
)
.
unwrap
(
)
)
;
let
pcs_b
=
lut_interp_linear_float
(
clut_b
&
self
.
output_clut_table
[
2
]
.
as_ref
(
)
.
unwrap
(
)
)
;
dest
[
0
]
=
clamp_float
(
pcs_r
)
;
dest
[
1
]
=
clamp_float
(
pcs_g
)
;
dest
[
2
]
=
clamp_float
(
pcs_b
)
;
}
}
}
struct
GammaTable
{
input_clut_table
:
[
[
f32
;
256
]
;
3
]
}
impl
GammaTable
{
pub
fn
from_curves
(
curve
:
[
&
curveType
;
3
]
)
-
>
Box
<
Self
>
{
Box
:
:
new
(
Self
{
input_clut_table
:
[
build_input_gamma_table
(
curve
[
0
]
)
build_input_gamma_table
(
curve
[
1
]
)
build_input_gamma_table
(
curve
[
2
]
)
]
}
)
}
}
impl
ModularTransform
for
GammaTable
{
fn
transform
(
&
self
src
:
&
[
f32
]
dest
:
&
mut
[
f32
]
)
{
let
mut
out_r
:
f32
;
let
mut
out_g
:
f32
;
let
mut
out_b
:
f32
;
let
input_clut_table_r
=
&
self
.
input_clut_table
[
0
]
;
let
input_clut_table_g
=
&
self
.
input_clut_table
[
1
]
;
let
input_clut_table_b
=
&
self
.
input_clut_table
[
2
]
;
for
(
dest
src
)
in
dest
.
chunks_exact_mut
(
3
)
.
zip
(
src
.
chunks_exact
(
3
)
)
{
let
in_r
=
src
[
0
]
;
let
in_g
=
src
[
1
]
;
let
in_b
=
src
[
2
]
;
out_r
=
lut_interp_linear_float
(
in_r
&
input_clut_table_r
[
.
.
]
)
;
out_g
=
lut_interp_linear_float
(
in_g
&
input_clut_table_g
[
.
.
]
)
;
out_b
=
lut_interp_linear_float
(
in_b
&
input_clut_table_b
[
.
.
]
)
;
dest
[
0
]
=
clamp_float
(
out_r
)
;
dest
[
1
]
=
clamp_float
(
out_g
)
;
dest
[
2
]
=
clamp_float
(
out_b
)
;
}
}
}
#
[
derive
(
Default
)
]
struct
GammaLut
{
output_gamma_lut_r
:
Option
<
Vec
<
u16
>
>
output_gamma_lut_g
:
Option
<
Vec
<
u16
>
>
output_gamma_lut_b
:
Option
<
Vec
<
u16
>
>
}
impl
ModularTransform
for
GammaLut
{
fn
transform
(
&
self
src
:
&
[
f32
]
dest
:
&
mut
[
f32
]
)
{
let
mut
out_r
:
f32
;
let
mut
out_g
:
f32
;
let
mut
out_b
:
f32
;
for
(
dest
src
)
in
dest
.
chunks_exact_mut
(
3
)
.
zip
(
src
.
chunks_exact
(
3
)
)
{
let
in_r
=
src
[
0
]
;
let
in_g
=
src
[
1
]
;
let
in_b
=
src
[
2
]
;
out_r
=
lut_interp_linear
(
in_r
as
f64
&
self
.
output_gamma_lut_r
.
as_ref
(
)
.
unwrap
(
)
)
;
out_g
=
lut_interp_linear
(
in_g
as
f64
&
self
.
output_gamma_lut_g
.
as_ref
(
)
.
unwrap
(
)
)
;
out_b
=
lut_interp_linear
(
in_b
as
f64
&
self
.
output_gamma_lut_b
.
as_ref
(
)
.
unwrap
(
)
)
;
dest
[
0
]
=
clamp_float
(
out_r
)
;
dest
[
1
]
=
clamp_float
(
out_g
)
;
dest
[
2
]
=
clamp_float
(
out_b
)
;
}
}
}
#
[
derive
(
Default
)
]
struct
MatrixTranslate
{
matrix
:
Matrix
tx
:
f32
ty
:
f32
tz
:
f32
}
impl
ModularTransform
for
MatrixTranslate
{
fn
transform
(
&
self
src
:
&
[
f32
]
dest
:
&
mut
[
f32
]
)
{
let
mut
mat
:
Matrix
=
Matrix
{
m
:
[
[
0
.
;
3
]
;
3
]
}
;
mat
.
m
[
0
]
[
0
]
=
self
.
matrix
.
m
[
0
]
[
0
]
;
mat
.
m
[
1
]
[
0
]
=
self
.
matrix
.
m
[
0
]
[
1
]
;
mat
.
m
[
2
]
[
0
]
=
self
.
matrix
.
m
[
0
]
[
2
]
;
mat
.
m
[
0
]
[
1
]
=
self
.
matrix
.
m
[
1
]
[
0
]
;
mat
.
m
[
1
]
[
1
]
=
self
.
matrix
.
m
[
1
]
[
1
]
;
mat
.
m
[
2
]
[
1
]
=
self
.
matrix
.
m
[
1
]
[
2
]
;
mat
.
m
[
0
]
[
2
]
=
self
.
matrix
.
m
[
2
]
[
0
]
;
mat
.
m
[
1
]
[
2
]
=
self
.
matrix
.
m
[
2
]
[
1
]
;
mat
.
m
[
2
]
[
2
]
=
self
.
matrix
.
m
[
2
]
[
2
]
;
for
(
dest
src
)
in
dest
.
chunks_exact_mut
(
3
)
.
zip
(
src
.
chunks_exact
(
3
)
)
{
let
in_r
=
src
[
0
]
;
let
in_g
=
src
[
1
]
;
let
in_b
=
src
[
2
]
;
let
out_r
=
mat
.
m
[
0
]
[
0
]
*
in_r
+
mat
.
m
[
1
]
[
0
]
*
in_g
+
mat
.
m
[
2
]
[
0
]
*
in_b
+
self
.
tx
;
let
out_g
=
mat
.
m
[
0
]
[
1
]
*
in_r
+
mat
.
m
[
1
]
[
1
]
*
in_g
+
mat
.
m
[
2
]
[
1
]
*
in_b
+
self
.
ty
;
let
out_b
=
mat
.
m
[
0
]
[
2
]
*
in_r
+
mat
.
m
[
1
]
[
2
]
*
in_g
+
mat
.
m
[
2
]
[
2
]
*
in_b
+
self
.
tz
;
dest
[
0
]
=
clamp_float
(
out_r
)
;
dest
[
1
]
=
clamp_float
(
out_g
)
;
dest
[
2
]
=
clamp_float
(
out_b
)
;
}
}
}
struct
MatrixTransform
{
matrix
:
Matrix
}
impl
ModularTransform
for
MatrixTransform
{
fn
transform
(
&
self
src
:
&
[
f32
]
dest
:
&
mut
[
f32
]
)
{
let
mat
=
Matrix
{
m
:
[
[
self
.
matrix
.
m
[
0
]
[
0
]
self
.
matrix
.
m
[
1
]
[
0
]
self
.
matrix
.
m
[
2
]
[
0
]
]
[
self
.
matrix
.
m
[
0
]
[
1
]
self
.
matrix
.
m
[
1
]
[
1
]
self
.
matrix
.
m
[
2
]
[
1
]
]
[
self
.
matrix
.
m
[
0
]
[
2
]
self
.
matrix
.
m
[
1
]
[
2
]
self
.
matrix
.
m
[
2
]
[
2
]
]
]
}
;
for
(
dest
src
)
in
dest
.
chunks_exact_mut
(
3
)
.
zip
(
src
.
chunks_exact
(
3
)
)
{
let
in_r
=
src
[
0
]
;
let
in_g
=
src
[
1
]
;
let
in_b
=
src
[
2
]
;
let
out_r
=
mat
.
m
[
0
]
[
0
]
*
in_r
+
mat
.
m
[
1
]
[
0
]
*
in_g
+
mat
.
m
[
2
]
[
0
]
*
in_b
;
let
out_g
=
mat
.
m
[
0
]
[
1
]
*
in_r
+
mat
.
m
[
1
]
[
1
]
*
in_g
+
mat
.
m
[
2
]
[
1
]
*
in_b
;
let
out_b
=
mat
.
m
[
0
]
[
2
]
*
in_r
+
mat
.
m
[
1
]
[
2
]
*
in_g
+
mat
.
m
[
2
]
[
2
]
*
in_b
;
dest
[
0
]
=
clamp_float
(
out_r
)
;
dest
[
1
]
=
clamp_float
(
out_g
)
;
dest
[
2
]
=
clamp_float
(
out_b
)
;
}
}
}
fn
modular_transform_create_mAB
(
lut
:
&
lutmABType
)
-
>
Option
<
Vec
<
Box
<
dyn
ModularTransform
>
>
>
{
let
mut
transforms
:
Vec
<
Box
<
dyn
ModularTransform
>
>
=
Vec
:
:
new
(
)
;
if
lut
.
a_curves
[
0
]
.
is_some
(
)
{
let
clut_table
=
lut
.
clut_table
.
as_deref
(
)
?
;
if
lut
.
num_grid_points
[
0
]
!
=
lut
.
num_grid_points
[
1
]
|
|
lut
.
num_grid_points
[
1
]
!
=
lut
.
num_grid_points
[
2
]
{
return
None
;
}
transforms
.
push
(
GammaTable
:
:
from_curves
(
[
lut
.
a_curves
[
0
]
.
as_deref
(
)
?
lut
.
a_curves
[
1
]
.
as_deref
(
)
?
lut
.
a_curves
[
2
]
.
as_deref
(
)
?
]
)
)
;
let
clut_length
=
(
lut
.
num_grid_points
[
0
]
as
usize
)
.
pow
(
3
)
*
3
;
assert_eq
!
(
clut_length
clut_table
.
len
(
)
)
;
transforms
.
push
(
Box
:
:
new
(
ClutOnly
{
clut
:
clut_table
.
into
(
)
grid_size
:
lut
.
num_grid_points
[
0
]
as
u16
}
)
)
;
}
if
lut
.
m_curves
[
0
]
.
is_some
(
)
{
transforms
.
push
(
GammaTable
:
:
from_curves
(
[
lut
.
m_curves
[
0
]
.
as_deref
(
)
?
lut
.
m_curves
[
1
]
.
as_deref
(
)
?
lut
.
m_curves
[
2
]
.
as_deref
(
)
?
]
)
)
;
let
mut
transform
=
Box
:
:
new
(
MatrixTranslate
:
:
default
(
)
)
;
transform
.
matrix
=
build_mAB_matrix
(
lut
)
;
transform
.
tx
=
s15Fixed16Number_to_float
(
lut
.
e03
)
;
transform
.
ty
=
s15Fixed16Number_to_float
(
lut
.
e13
)
;
transform
.
tz
=
s15Fixed16Number_to_float
(
lut
.
e23
)
;
transforms
.
push
(
transform
)
;
}
if
lut
.
b_curves
[
0
]
.
is_some
(
)
{
transforms
.
push
(
GammaTable
:
:
from_curves
(
[
lut
.
b_curves
[
0
]
.
as_deref
(
)
?
lut
.
b_curves
[
1
]
.
as_deref
(
)
?
lut
.
b_curves
[
2
]
.
as_deref
(
)
?
]
)
)
;
}
else
{
return
None
;
}
if
lut
.
reversed
{
transforms
.
reverse
(
)
;
}
Some
(
transforms
)
}
fn
modular_transform_create_lut
(
lut
:
&
lutType
)
-
>
Option
<
Vec
<
Box
<
dyn
ModularTransform
>
>
>
{
let
mut
transforms
:
Vec
<
Box
<
dyn
ModularTransform
>
>
=
Vec
:
:
new
(
)
;
let
clut_length
:
usize
;
transforms
.
push
(
Box
:
:
new
(
MatrixTransform
{
matrix
:
build_lut_matrix
(
lut
)
}
)
)
;
let
mut
transform
=
Box
:
:
new
(
Clut3x3
:
:
default
(
)
)
;
transform
.
input_clut_table
[
0
]
=
Some
(
lut
.
input_table
[
0
.
.
lut
.
num_input_table_entries
as
usize
]
.
to_vec
(
)
)
;
transform
.
input_clut_table
[
1
]
=
Some
(
lut
.
input_table
[
lut
.
num_input_table_entries
as
usize
.
.
lut
.
num_input_table_entries
as
usize
*
2
]
.
to_vec
(
)
)
;
transform
.
input_clut_table
[
2
]
=
Some
(
lut
.
input_table
[
lut
.
num_input_table_entries
as
usize
*
2
.
.
lut
.
num_input_table_entries
as
usize
*
3
]
.
to_vec
(
)
)
;
clut_length
=
(
lut
.
num_clut_grid_points
as
usize
)
.
pow
(
3
)
*
3
;
assert_eq
!
(
clut_length
lut
.
clut_table
.
len
(
)
)
;
transform
.
clut
=
Some
(
lut
.
clut_table
.
clone
(
)
)
;
transform
.
grid_size
=
lut
.
num_clut_grid_points
as
u16
;
transform
.
output_clut_table
[
0
]
=
Some
(
lut
.
output_table
[
0
.
.
lut
.
num_output_table_entries
as
usize
]
.
to_vec
(
)
)
;
transform
.
output_clut_table
[
1
]
=
Some
(
lut
.
output_table
[
lut
.
num_output_table_entries
as
usize
.
.
lut
.
num_output_table_entries
as
usize
*
2
]
.
to_vec
(
)
)
;
transform
.
output_clut_table
[
2
]
=
Some
(
lut
.
output_table
[
lut
.
num_output_table_entries
as
usize
*
2
.
.
lut
.
num_output_table_entries
as
usize
*
3
]
.
to_vec
(
)
)
;
transforms
.
push
(
transform
)
;
return
Some
(
transforms
)
;
}
fn
modular_transform_create_lut4x3
(
lut
:
&
lutType
)
-
>
Vec
<
Box
<
dyn
ModularTransform
>
>
{
let
mut
transforms
:
Vec
<
Box
<
dyn
ModularTransform
>
>
=
Vec
:
:
new
(
)
;
let
clut_length
:
usize
;
let
mut
transform
=
Box
:
:
new
(
Clut4x3
:
:
default
(
)
)
;
transform
.
input_clut_table
[
0
]
=
Some
(
lut
.
input_table
[
0
.
.
lut
.
num_input_table_entries
as
usize
]
.
to_vec
(
)
)
;
transform
.
input_clut_table
[
1
]
=
Some
(
lut
.
input_table
[
lut
.
num_input_table_entries
as
usize
.
.
lut
.
num_input_table_entries
as
usize
*
2
]
.
to_vec
(
)
)
;
transform
.
input_clut_table
[
2
]
=
Some
(
lut
.
input_table
[
lut
.
num_input_table_entries
as
usize
*
2
.
.
lut
.
num_input_table_entries
as
usize
*
3
]
.
to_vec
(
)
)
;
transform
.
input_clut_table
[
3
]
=
Some
(
lut
.
input_table
[
lut
.
num_input_table_entries
as
usize
*
3
.
.
lut
.
num_input_table_entries
as
usize
*
4
]
.
to_vec
(
)
)
;
clut_length
=
(
lut
.
num_clut_grid_points
as
usize
)
.
pow
(
lut
.
num_input_channels
as
u32
)
*
lut
.
num_output_channels
as
usize
;
assert_eq
!
(
clut_length
lut
.
clut_table
.
len
(
)
)
;
transform
.
clut
=
Some
(
lut
.
clut_table
.
clone
(
)
)
;
transform
.
grid_size
=
lut
.
num_clut_grid_points
as
u16
;
transform
.
output_clut_table
[
0
]
=
Some
(
lut
.
output_table
[
0
.
.
lut
.
num_output_table_entries
as
usize
]
.
to_vec
(
)
)
;
transform
.
output_clut_table
[
1
]
=
Some
(
lut
.
output_table
[
lut
.
num_output_table_entries
as
usize
.
.
lut
.
num_output_table_entries
as
usize
*
2
]
.
to_vec
(
)
)
;
transform
.
output_clut_table
[
2
]
=
Some
(
lut
.
output_table
[
lut
.
num_output_table_entries
as
usize
*
2
.
.
lut
.
num_output_table_entries
as
usize
*
3
]
.
to_vec
(
)
)
;
transforms
.
push
(
transform
)
;
transforms
}
fn
modular_transform_create_input
(
input
:
&
Profile
)
-
>
Option
<
Vec
<
Box
<
dyn
ModularTransform
>
>
>
{
let
mut
transforms
=
Vec
:
:
new
(
)
;
if
let
Some
(
A2B0
)
=
&
input
.
A2B0
{
let
lut_transform
;
if
A2B0
.
num_input_channels
=
=
4
{
lut_transform
=
Some
(
modular_transform_create_lut4x3
(
&
A2B0
)
)
;
}
else
{
lut_transform
=
modular_transform_create_lut
(
&
A2B0
)
;
}
if
let
Some
(
lut_transform
)
=
lut_transform
{
transforms
.
extend
(
lut_transform
)
;
}
else
{
return
None
;
}
}
else
if
input
.
mAB
.
is_some
(
)
&
&
(
*
input
.
mAB
.
as_deref
(
)
.
unwrap
(
)
)
.
num_in_channels
=
=
3
&
&
(
*
input
.
mAB
.
as_deref
(
)
.
unwrap
(
)
)
.
num_out_channels
=
=
3
{
let
mAB_transform
=
modular_transform_create_mAB
(
input
.
mAB
.
as_deref
(
)
.
unwrap
(
)
)
;
if
let
Some
(
mAB_transform
)
=
mAB_transform
{
transforms
.
extend
(
mAB_transform
)
;
}
else
{
return
None
;
}
}
else
{
transforms
.
push
(
GammaTable
:
:
from_curves
(
[
input
.
redTRC
.
as_deref
(
)
?
input
.
greenTRC
.
as_deref
(
)
?
input
.
blueTRC
.
as_deref
(
)
?
]
)
)
;
transforms
.
push
(
Box
:
:
new
(
MatrixTransform
{
matrix
:
Matrix
{
m
:
[
[
1
.
/
1
.
999_969_5
0
.
0
0
.
0
]
[
0
.
0
1
.
/
1
.
999_969_5
0
.
0
]
[
0
.
0
0
.
0
1
.
/
1
.
999_969_5
]
]
}
}
)
)
;
transforms
.
push
(
Box
:
:
new
(
MatrixTransform
{
matrix
:
build_colorant_matrix
(
input
)
}
)
)
;
}
Some
(
transforms
)
}
fn
modular_transform_create_output
(
out
:
&
Profile
)
-
>
Option
<
Vec
<
Box
<
dyn
ModularTransform
>
>
>
{
let
mut
transforms
=
Vec
:
:
new
(
)
;
if
let
Some
(
B2A0
)
=
&
out
.
B2A0
{
if
B2A0
.
num_input_channels
!
=
3
|
|
B2A0
.
num_output_channels
!
=
3
{
return
None
;
}
let
lut_transform
=
modular_transform_create_lut
(
B2A0
)
;
if
let
Some
(
lut_transform
)
=
lut_transform
{
transforms
.
extend
(
lut_transform
)
;
}
else
{
return
None
;
}
}
else
if
out
.
mBA
.
is_some
(
)
&
&
(
*
out
.
mBA
.
as_deref
(
)
.
unwrap
(
)
)
.
num_in_channels
=
=
3
&
&
(
*
out
.
mBA
.
as_deref
(
)
.
unwrap
(
)
)
.
num_out_channels
=
=
3
{
let
lut_transform
=
modular_transform_create_mAB
(
out
.
mBA
.
as_deref
(
)
.
unwrap
(
)
)
;
if
let
Some
(
lut_transform
)
=
lut_transform
{
transforms
.
extend
(
lut_transform
)
}
else
{
return
None
;
}
}
else
if
let
(
Some
(
redTRC
)
Some
(
greenTRC
)
Some
(
blueTRC
)
)
=
(
&
out
.
redTRC
&
out
.
greenTRC
&
out
.
blueTRC
)
{
transforms
.
push
(
Box
:
:
new
(
MatrixTransform
{
matrix
:
build_colorant_matrix
(
out
)
.
invert
(
)
?
}
)
)
;
transforms
.
push
(
Box
:
:
new
(
MatrixTransform
{
matrix
:
Matrix
{
m
:
[
[
1
.
999_969_5
0
.
0
0
.
0
]
[
0
.
0
1
.
999_969_5
0
.
0
]
[
0
.
0
0
.
0
1
.
999_969_5
]
]
}
}
)
)
;
let
mut
transform
=
Box
:
:
new
(
GammaLut
:
:
default
(
)
)
;
transform
.
output_gamma_lut_r
=
Some
(
build_output_lut
(
redTRC
)
?
)
;
transform
.
output_gamma_lut_g
=
Some
(
build_output_lut
(
greenTRC
)
?
)
;
transform
.
output_gamma_lut_b
=
Some
(
build_output_lut
(
blueTRC
)
?
)
;
transforms
.
push
(
transform
)
;
}
else
{
debug_assert
!
(
false
"
Unsupported
output
profile
workflow
.
"
)
;
return
None
;
}
Some
(
transforms
)
}
fn
modular_transform_create
(
input
:
&
Profile
output
:
&
Profile
)
-
>
Option
<
Vec
<
Box
<
dyn
ModularTransform
>
>
>
{
let
mut
transforms
=
Vec
:
:
new
(
)
;
if
input
.
color_space
=
=
RGB_SIGNATURE
|
|
input
.
color_space
=
=
CMYK_SIGNATURE
{
let
rgb_to_pcs
=
modular_transform_create_input
(
input
)
;
if
let
Some
(
rgb_to_pcs
)
=
rgb_to_pcs
{
transforms
.
extend
(
rgb_to_pcs
)
;
}
else
{
return
None
;
}
}
else
{
debug_assert
!
(
false
"
input
color
space
not
supported
"
)
;
return
None
;
}
if
input
.
pcs
=
=
LAB_SIGNATURE
&
&
output
.
pcs
=
=
XYZ_SIGNATURE
{
transforms
.
push
(
Box
:
:
new
(
LABtoXYZ
{
}
)
)
;
}
if
input
.
pcs
=
=
XYZ_SIGNATURE
&
&
output
.
pcs
=
=
LAB_SIGNATURE
{
transforms
.
push
(
Box
:
:
new
(
XYZtoLAB
{
}
)
)
;
}
if
output
.
color_space
=
=
RGB_SIGNATURE
{
let
pcs_to_rgb
=
modular_transform_create_output
(
output
)
;
if
let
Some
(
pcs_to_rgb
)
=
pcs_to_rgb
{
transforms
.
extend
(
pcs_to_rgb
)
;
}
else
{
return
None
;
}
}
else
if
output
.
color_space
=
=
CMYK_SIGNATURE
{
let
pcs_to_cmyk
=
modular_transform_create_output
(
output
)
?
;
transforms
.
extend
(
pcs_to_cmyk
)
;
}
else
{
debug_assert
!
(
false
"
output
color
space
not
supported
"
)
;
}
Some
(
transforms
)
}
fn
modular_transform_data
(
transforms
:
Vec
<
Box
<
dyn
ModularTransform
>
>
mut
src
:
Vec
<
f32
>
mut
dest
:
Vec
<
f32
>
_len
:
usize
)
-
>
Vec
<
f32
>
{
for
transform
in
transforms
{
transform
.
transform
(
&
src
&
mut
dest
)
;
std
:
:
mem
:
:
swap
(
&
mut
src
&
mut
dest
)
;
}
src
}
pub
fn
chain_transform
(
input
:
&
Profile
output
:
&
Profile
src
:
Vec
<
f32
>
dest
:
Vec
<
f32
>
lutSize
:
usize
)
-
>
Option
<
Vec
<
f32
>
>
{
let
transform_list
=
modular_transform_create
(
input
output
)
;
if
let
Some
(
transform_list
)
=
transform_list
{
let
lut
=
modular_transform_data
(
transform_list
src
dest
lutSize
/
3
)
;
return
Some
(
lut
)
;
}
None
}
