#
include
<
altivec
.
h
>
#
include
"
qcmsint
.
h
"
#
define
FLOATSCALE
(
float
)
(
PRECACHE_OUTPUT_SIZE
)
#
define
CLAMPMAXVAL
(
(
(
float
)
(
PRECACHE_OUTPUT_SIZE
-
1
)
)
/
PRECACHE_OUTPUT_SIZE
)
static
const
ALIGN
float
floatScaleX4
=
FLOATSCALE
;
static
const
ALIGN
float
clampMaxValueX4
=
CLAMPMAXVAL
;
inline
vector
float
load_aligned_float
(
float
*
dataPtr
)
{
vector
float
data
=
vec_lde
(
0
dataPtr
)
;
vector
unsigned
char
moveToStart
=
vec_lvsl
(
0
dataPtr
)
;
return
vec_perm
(
data
data
moveToStart
)
;
}
template
<
size_t
kRIndex
size_t
kGIndex
size_t
kBIndex
size_t
kAIndex
=
NO_A_INDEX
>
static
void
qcms_transform_data_template_lut_altivec
(
const
qcms_transform
*
transform
const
unsigned
char
*
src
unsigned
char
*
dest
size_t
length
)
{
unsigned
int
i
;
const
float
(
*
mat
)
[
4
]
=
transform
-
>
matrix
;
char
input_back
[
32
]
;
float
const
*
input
=
(
float
*
)
(
(
(
uintptr_t
)
&
input_back
[
16
]
)
&
~
0xf
)
;
uint32_t
const
*
output
=
(
uint32_t
*
)
input
;
const
float
*
igtbl_r
=
transform
-
>
input_gamma_table_r
;
const
float
*
igtbl_g
=
transform
-
>
input_gamma_table_g
;
const
float
*
igtbl_b
=
transform
-
>
input_gamma_table_b
;
const
uint8_t
*
otdata_r
=
&
transform
-
>
output_table_r
-
>
data
[
0
]
;
const
uint8_t
*
otdata_g
=
&
transform
-
>
output_table_g
-
>
data
[
0
]
;
const
uint8_t
*
otdata_b
=
&
transform
-
>
output_table_b
-
>
data
[
0
]
;
const
vector
float
mat0
=
vec_ldl
(
0
(
vector
float
*
)
mat
[
0
]
)
;
const
vector
float
mat1
=
vec_ldl
(
0
(
vector
float
*
)
mat
[
1
]
)
;
const
vector
float
mat2
=
vec_ldl
(
0
(
vector
float
*
)
mat
[
2
]
)
;
const
vector
float
max
=
vec_splat
(
vec_lde
(
0
(
float
*
)
&
clampMaxValueX4
)
0
)
;
const
vector
float
min
=
(
vector
float
)
vec_splat_u32
(
0
)
;
const
vector
float
scale
=
vec_splat
(
vec_lde
(
0
(
float
*
)
&
floatScaleX4
)
0
)
;
const
unsigned
int
components
=
A_INDEX_COMPONENTS
(
kAIndex
)
;
vector
float
vec_r
vec_g
vec_b
result
;
unsigned
char
alpha
;
if
(
!
length
)
return
;
length
-
-
;
vec_r
=
load_aligned_float
(
(
float
*
)
&
igtbl_r
[
src
[
kRIndex
]
]
)
;
vec_g
=
load_aligned_float
(
(
float
*
)
&
igtbl_r
[
src
[
kGIndex
]
]
)
;
vec_b
=
load_aligned_float
(
(
float
*
)
&
igtbl_r
[
src
[
kBIndex
]
]
)
;
if
(
kAIndex
!
=
NO_A_INDEX
)
{
alpha
=
src
[
kAIndex
]
;
}
src
+
=
components
;
for
(
i
=
0
;
i
<
length
;
i
+
+
)
{
vec_r
=
vec_splat
(
vec_r
0
)
;
vec_g
=
vec_splat
(
vec_g
0
)
;
vec_b
=
vec_splat
(
vec_b
0
)
;
vec_r
=
vec_madd
(
vec_r
mat0
min
)
;
vec_g
=
vec_madd
(
vec_g
mat1
min
)
;
vec_b
=
vec_madd
(
vec_b
mat2
min
)
;
if
(
kAIndex
!
=
NO_A_INDEX
)
{
dest
[
kAIndex
]
=
alpha
;
alpha
=
src
[
kAIndex
]
;
}
vec_r
=
vec_add
(
vec_r
vec_add
(
vec_g
vec_b
)
)
;
vec_r
=
vec_max
(
min
vec_r
)
;
vec_r
=
vec_min
(
max
vec_r
)
;
result
=
vec_madd
(
vec_r
scale
min
)
;
vec_st
(
vec_ctu
(
vec_round
(
result
)
0
)
0
(
vector
unsigned
int
*
)
output
)
;
vec_r
=
load_aligned_float
(
(
float
*
)
&
igtbl_r
[
src
[
kRIndex
]
]
)
;
vec_g
=
load_aligned_float
(
(
float
*
)
&
igtbl_r
[
src
[
kGIndex
]
]
)
;
vec_b
=
load_aligned_float
(
(
float
*
)
&
igtbl_r
[
src
[
kBIndex
]
]
)
;
src
+
=
components
;
dest
[
kRIndex
]
=
otdata_r
[
output
[
0
]
]
;
dest
[
kGIndex
]
=
otdata_g
[
output
[
1
]
]
;
dest
[
kBIndex
]
=
otdata_b
[
output
[
2
]
]
;
dest
+
=
components
;
}
vec_r
=
vec_splat
(
vec_r
0
)
;
vec_g
=
vec_splat
(
vec_g
0
)
;
vec_b
=
vec_splat
(
vec_b
0
)
;
vec_r
=
vec_madd
(
vec_r
mat0
min
)
;
vec_g
=
vec_madd
(
vec_g
mat1
min
)
;
vec_b
=
vec_madd
(
vec_b
mat2
min
)
;
if
(
kAIndex
!
=
NO_A_INDEX
)
{
dest
[
kAIndex
]
=
alpha
;
}
vec_r
=
vec_add
(
vec_r
vec_add
(
vec_g
vec_b
)
)
;
vec_r
=
vec_max
(
min
vec_r
)
;
vec_r
=
vec_min
(
max
vec_r
)
;
result
=
vec_madd
(
vec_r
scale
min
)
;
vec_st
(
vec_ctu
(
vec_round
(
result
)
0
)
0
(
vector
unsigned
int
*
)
output
)
;
dest
[
kRIndex
]
=
otdata_r
[
output
[
0
]
]
;
dest
[
kGIndex
]
=
otdata_g
[
output
[
1
]
]
;
dest
[
kBIndex
]
=
otdata_b
[
output
[
2
]
]
;
}
void
qcms_transform_data_rgb_out_lut_altivec
(
const
qcms_transform
*
transform
const
unsigned
char
*
src
unsigned
char
*
dest
size_t
length
)
{
qcms_transform_data_template_lut_altivec
<
RGBA_R_INDEX
RGBA_G_INDEX
RGBA_B_INDEX
>
(
transform
src
dest
length
)
;
}
void
qcms_transform_data_rgba_out_lut_altivec
(
const
qcms_transform
*
transform
const
unsigned
char
*
src
unsigned
char
*
dest
size_t
length
)
{
qcms_transform_data_template_lut_altivec
<
RGBA_R_INDEX
RGBA_G_INDEX
RGBA_B_INDEX
RGBA_A_INDEX
>
(
transform
src
dest
length
)
;
}
