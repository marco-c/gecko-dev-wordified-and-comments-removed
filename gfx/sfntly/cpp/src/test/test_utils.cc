#
include
"
test
/
test_utils
.
h
"
#
include
<
stdio
.
h
>
#
include
<
unicode
/
ucnv
.
h
>
#
include
<
unicode
/
uchar
.
h
>
#
include
"
gtest
/
gtest
.
h
"
#
include
"
sfntly
/
font
.
h
"
#
include
"
sfntly
/
data
/
memory_byte_array
.
h
"
#
include
"
sfntly
/
data
/
growable_memory_byte_array
.
h
"
#
include
"
sfntly
/
port
/
file_input_stream
.
h
"
namespace
sfntly
{
TestUtils
:
:
TestUtils
(
)
{
}
int32_t
TestUtils
:
:
EncodeOneChar
(
UConverter
*
encoder
int16_t
uchar
)
{
char
*
target
=
new
char
[
ucnv_getMaxCharSize
(
encoder
)
*
2
]
;
char
*
target_end
;
UChar
*
source
=
new
UChar
[
2
]
;
UChar
*
source_end
;
source
[
0
]
=
(
UChar
)
uchar
;
source
[
1
]
=
0
;
UErrorCode
status
=
U_ZERO_ERROR
;
source_end
=
source
;
target_end
=
target
;
ucnv_fromUnicode
(
encoder
&
target_end
target
+
4
(
const
UChar
*
*
)
&
source_end
source
+
sizeof
(
UChar
)
NULL
TRUE
&
status
)
;
if
(
!
U_SUCCESS
(
status
)
)
{
fprintf
(
stderr
"
Error
occured
in
conversion
of
%
d
:
%
s
\
n
"
uchar
u_errorName
(
status
)
)
;
delete
[
]
source
;
delete
[
]
target
;
return
0
;
}
int32_t
enc_char
=
0
;
for
(
int32_t
position
=
0
;
position
<
target_end
-
target
;
+
+
position
)
{
enc_char
<
<
=
8
;
enc_char
|
=
(
target
[
position
]
&
0xff
)
;
}
delete
[
]
source
;
delete
[
]
target
;
return
enc_char
;
}
UConverter
*
TestUtils
:
:
GetEncoder
(
const
char
*
charset_name
)
{
if
(
charset_name
=
=
NULL
|
|
strcmp
(
charset_name
"
"
)
=
=
0
)
return
NULL
;
UErrorCode
status
=
U_ZERO_ERROR
;
UConverter
*
conv
=
ucnv_open
(
charset_name
&
status
)
;
return
conv
;
}
const
char
*
TestUtils
:
:
Extension
(
const
char
*
file_path
)
{
if
(
!
file_path
)
return
NULL
;
return
strrchr
(
file_path
EXTENSION_SEPARATOR
)
;
}
}
