#
include
"
test
/
platform_thread
.
h
"
namespace
sfntly
{
#
if
defined
(
WIN32
)
DWORD
__stdcall
ThreadFunc
(
void
*
params
)
{
PlatformThread
:
:
Delegate
*
delegate
=
static_cast
<
PlatformThread
:
:
Delegate
*
>
(
params
)
;
delegate
-
>
ThreadMain
(
)
;
return
0
;
}
bool
PlatformThread
:
:
Create
(
Delegate
*
delegate
PlatformThreadHandle
*
thread_handle
)
{
assert
(
thread_handle
)
;
*
thread_handle
=
CreateThread
(
NULL
0
ThreadFunc
delegate
0
NULL
)
;
if
(
!
(
*
thread_handle
)
)
{
return
false
;
}
return
true
;
}
void
PlatformThread
:
:
Join
(
PlatformThreadHandle
thread_handle
)
{
assert
(
thread_handle
)
;
DWORD
result
=
WaitForSingleObject
(
thread_handle
INFINITE
)
;
assert
(
result
=
=
WAIT_OBJECT_0
)
;
CloseHandle
(
thread_handle
)
;
}
void
PlatformThread
:
:
Sleep
(
int32_t
duration_ms
)
{
:
:
Sleep
(
duration_ms
)
;
}
#
else
void
*
ThreadFunc
(
void
*
params
)
{
PlatformThread
:
:
Delegate
*
delegate
=
static_cast
<
PlatformThread
:
:
Delegate
*
>
(
params
)
;
delegate
-
>
ThreadMain
(
)
;
return
NULL
;
}
bool
PlatformThread
:
:
Create
(
Delegate
*
delegate
PlatformThreadHandle
*
thread_handle
)
{
assert
(
thread_handle
)
;
bool
success
=
false
;
pthread_attr_t
attributes
;
pthread_attr_init
(
&
attributes
)
;
success
=
!
pthread_create
(
thread_handle
&
attributes
ThreadFunc
delegate
)
;
pthread_attr_destroy
(
&
attributes
)
;
return
success
;
}
void
PlatformThread
:
:
Join
(
PlatformThreadHandle
thread_handle
)
{
assert
(
thread_handle
)
;
pthread_join
(
thread_handle
NULL
)
;
}
void
PlatformThread
:
:
Sleep
(
int32_t
duration_ms
)
{
struct
timespec
sleep_time
remaining
;
sleep_time
.
tv_sec
=
duration_ms
/
1000
;
duration_ms
-
=
sleep_time
.
tv_sec
*
1000
;
sleep_time
.
tv_nsec
=
duration_ms
*
1000
*
1000
;
while
(
nanosleep
(
&
sleep_time
&
remaining
)
=
=
-
1
&
&
errno
=
=
EINTR
)
sleep_time
=
remaining
;
}
#
endif
}
