#
include
"
sfntly
/
data
/
growable_memory_byte_array
.
h
"
#
include
<
limits
.
h
>
#
include
<
string
.
h
>
#
include
<
algorithm
>
namespace
sfntly
{
GrowableMemoryByteArray
:
:
GrowableMemoryByteArray
(
)
:
ByteArray
(
0
INT_MAX
true
)
{
}
GrowableMemoryByteArray
:
:
~
GrowableMemoryByteArray
(
)
{
}
int32_t
GrowableMemoryByteArray
:
:
CopyTo
(
OutputStream
*
os
int32_t
offset
int32_t
length
)
{
assert
(
os
)
;
os
-
>
Write
(
&
b_
offset
length
)
;
return
length
;
}
void
GrowableMemoryByteArray
:
:
InternalPut
(
int32_t
index
byte_t
b
)
{
if
(
(
size_t
)
index
>
=
b_
.
size
(
)
)
{
b_
.
resize
(
(
size_t
)
(
index
+
1
)
)
;
}
b_
[
index
]
=
b
;
}
int32_t
GrowableMemoryByteArray
:
:
InternalPut
(
int32_t
index
byte_t
*
b
int32_t
offset
int32_t
length
)
{
if
(
(
size_t
)
index
+
length
>
=
b_
.
size
(
)
)
{
b_
.
resize
(
(
size_t
)
(
index
+
length
+
1
)
)
;
}
std
:
:
copy
(
b
+
offset
b
+
offset
+
length
b_
.
begin
(
)
+
index
)
;
return
length
;
}
byte_t
GrowableMemoryByteArray
:
:
InternalGet
(
int32_t
index
)
{
return
b_
[
index
]
;
}
int32_t
GrowableMemoryByteArray
:
:
InternalGet
(
int32_t
index
byte_t
*
b
int32_t
offset
int32_t
length
)
{
memcpy
(
b
+
offset
&
(
b_
[
0
]
)
+
index
length
)
;
return
length
;
}
void
GrowableMemoryByteArray
:
:
Close
(
)
{
b_
.
clear
(
)
;
}
byte_t
*
GrowableMemoryByteArray
:
:
Begin
(
)
{
return
&
(
b_
[
0
]
)
;
}
}
