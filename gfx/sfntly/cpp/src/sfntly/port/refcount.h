#
ifndef
SFNTLY_CPP_SRC_SFNTLY_PORT_REFCOUNT_H_
#
define
SFNTLY_CPP_SRC_SFNTLY_PORT_REFCOUNT_H_
#
if
!
defined
(
NDEBUG
)
#
define
ENABLE_OBJECT_COUNTER
#
endif
#
if
defined
(
REF_COUNT_DEBUGGING
)
#
include
<
stdio
.
h
>
#
include
<
typeinfo
>
#
endif
#
include
"
sfntly
/
port
/
atomic
.
h
"
#
include
"
sfntly
/
port
/
type
.
h
"
#
define
CALLER_ATTACH
#
if
defined
(
REF_COUNT_DEBUGGING
)
#
define
DEBUG_OUTPUT
(
a
)
\
fprintf
(
stderr
"
%
s
%
s
:
oc
=
%
d
oid
=
%
d
rc
=
%
d
\
n
"
a
\
typeid
(
this
)
.
name
(
)
object_counter_
object_id_
ref_count_
)
#
else
#
define
DEBUG_OUTPUT
(
a
)
#
endif
#
if
defined
(
_MSC_VER
)
#
pragma
warning
(
disable
:
4250
)
#
endif
namespace
sfntly
{
template
<
typename
T
>
class
Ptr
;
class
RefCount
{
public
:
virtual
~
RefCount
(
)
{
}
private
:
template
<
typename
T
>
friend
class
Ptr
;
virtual
size_t
AddRef
(
)
const
=
0
;
virtual
size_t
Release
(
)
const
=
0
;
}
;
template
<
typename
TDerived
>
class
RefCounted
:
virtual
public
RefCount
{
public
:
RefCounted
(
)
:
ref_count_
(
0
)
{
#
if
defined
(
ENABLE_OBJECT_COUNTER
)
object_id_
=
AtomicIncrement
(
&
next_id_
)
;
AtomicIncrement
(
&
object_counter_
)
;
DEBUG_OUTPUT
(
"
C
"
)
;
#
endif
}
RefCounted
(
const
RefCounted
<
TDerived
>
&
)
:
ref_count_
(
0
)
{
}
virtual
~
RefCounted
(
)
{
#
if
defined
(
ENABLE_OBJECT_COUNTER
)
AtomicDecrement
(
&
object_counter_
)
;
DEBUG_OUTPUT
(
"
D
"
)
;
#
endif
}
RefCounted
<
TDerived
>
&
operator
=
(
const
RefCounted
<
TDerived
>
&
)
{
return
*
this
;
}
private
:
virtual
size_t
AddRef
(
)
const
{
size_t
new_count
=
AtomicIncrement
(
&
ref_count_
)
;
DEBUG_OUTPUT
(
"
A
"
)
;
return
new_count
;
}
virtual
size_t
Release
(
)
const
{
size_t
new_ref_count
=
AtomicDecrement
(
&
ref_count_
)
;
DEBUG_OUTPUT
(
"
R
"
)
;
if
(
new_ref_count
=
=
0
)
{
delete
(
TDerived
*
)
(
this
)
;
}
return
new_ref_count
;
}
mutable
size_t
ref_count_
;
#
if
defined
(
ENABLE_OBJECT_COUNTER
)
static
size_t
object_counter_
;
static
size_t
next_id_
;
mutable
size_t
object_id_
;
#
endif
}
;
#
if
defined
(
ENABLE_OBJECT_COUNTER
)
template
<
typename
TDerived
>
size_t
RefCounted
<
TDerived
>
:
:
object_counter_
=
0
;
template
<
typename
TDerived
>
size_t
RefCounted
<
TDerived
>
:
:
next_id_
=
0
;
#
endif
template
<
typename
T
>
class
Ptr
{
public
:
Ptr
(
)
:
p_
(
NULL
)
{
}
Ptr
(
T
*
pT
)
:
p_
(
NULL
)
{
*
this
=
pT
;
}
Ptr
(
const
Ptr
<
T
>
&
p
)
:
p_
(
NULL
)
{
*
this
=
p
;
}
~
Ptr
(
)
{
Release
(
)
;
}
T
*
operator
=
(
T
*
pT
)
{
if
(
p_
=
=
pT
)
{
return
p_
;
}
if
(
pT
)
{
RefCount
*
p
=
static_cast
<
RefCount
*
>
(
pT
)
;
if
(
p
=
=
NULL
)
{
return
NULL
;
}
p
-
>
AddRef
(
)
;
}
Release
(
)
;
p_
=
pT
;
return
p_
;
}
T
*
operator
=
(
const
Ptr
<
T
>
&
p
)
{
if
(
p_
=
=
p
.
p_
)
{
return
p_
;
}
return
operator
=
(
p
.
p_
)
;
}
operator
T
*
&
(
)
{
return
p_
;
}
T
&
operator
*
(
)
const
{
return
*
p_
;
}
T
*
operator
-
>
(
)
const
{
return
p_
;
}
bool
operator
!
(
)
const
{
return
(
p_
=
=
NULL
)
;
}
bool
operator
<
(
const
Ptr
<
T
>
&
p
)
const
{
return
(
p_
<
p
.
p_
)
;
}
bool
operator
!
=
(
T
*
pT
)
const
{
return
!
operator
=
=
(
pT
)
;
}
bool
operator
=
=
(
T
*
pT
)
const
{
return
(
p_
=
=
pT
)
;
}
size_t
Release
(
)
const
{
size_t
ref_count
=
0
;
if
(
p_
)
{
RefCount
*
p
=
static_cast
<
RefCount
*
>
(
p_
)
;
if
(
p
)
{
ref_count
=
p
-
>
Release
(
)
;
}
p_
=
NULL
;
}
return
ref_count
;
}
void
Attach
(
T
*
pT
)
{
if
(
p_
!
=
pT
)
{
Release
(
)
;
p_
=
pT
;
}
}
T
*
Detach
(
)
{
T
*
pT
=
p_
;
p_
=
NULL
;
return
pT
;
}
mutable
T
*
p_
;
}
;
}
#
endif
