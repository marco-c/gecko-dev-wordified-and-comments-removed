#
ifndef
SFNTLY_CPP_SRC_SFNTLY_PORT_TYPE_H_
#
define
SFNTLY_CPP_SRC_SFNTLY_PORT_TYPE_H_
#
include
<
assert
.
h
>
#
if
defined
(
_MSC_VER
)
&
&
(
_MSC_VER
<
1600
)
typedef
unsigned
char
uint8_t
;
typedef
signed
char
int8_t
;
typedef
unsigned
__int16
uint16_t
;
typedef
signed
__int16
int16_t
;
typedef
unsigned
__int32
uint32_t
;
typedef
signed
__int32
int32_t
;
typedef
unsigned
__int64
uint64_t
;
typedef
signed
__int64
int64_t
;
#
define
U_HAVE_INT8_T
1
#
define
U_HAVE_UINT8_T
1
#
define
U_HAVE_INT16_T
1
#
define
U_HAVE_UINT16_T
1
#
define
U_HAVE_INT32_T
1
#
define
U_HAVE_UINT32_T
1
#
define
U_HAVE_INT64_T
1
#
define
U_HAVE_UINT64_T
1
#
else
#
include
<
stdint
.
h
>
#
endif
#
include
<
stddef
.
h
>
#
include
<
vector
>
#
include
<
set
>
namespace
sfntly
{
typedef
uint8_t
byte_t
;
typedef
uint16_t
word_t
;
typedef
uint32_t
dword_t
;
typedef
uint64_t
qword_t
;
typedef
std
:
:
vector
<
byte_t
>
ByteVector
;
typedef
std
:
:
vector
<
int32_t
>
IntegerList
;
typedef
std
:
:
set
<
int32_t
>
IntegerSet
;
#
define
NO_COPY_AND_ASSIGN
(
TypeName
)
\
TypeName
(
const
TypeName
&
)
;
\
void
operator
=
(
const
TypeName
&
)
}
template
<
typename
To
typename
From
>
inline
To
implicit_cast
(
From
const
&
f
)
{
return
f
;
}
template
<
typename
To
typename
From
>
inline
To
down_cast
(
From
*
f
)
{
#
if
defined
(
_MSC_VER
)
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4127
)
/
/
disable
"
conditional
expression
is
constant
"
#
endif
if
(
false
)
{
implicit_cast
<
From
*
To
>
(
0
)
;
}
#
if
defined
(
_MSC_VER
)
#
pragma
warning
(
pop
)
#
endif
#
if
defined
(
SFNTLY_TYPE_VERIFICATION
)
assert
(
f
=
=
NULL
|
|
dynamic_cast
<
To
>
(
f
)
!
=
NULL
)
;
#
endif
return
static_cast
<
To
>
(
f
)
;
}
#
if
!
defined
(
WIN32
)
#
define
UNREFERENCED_PARAMETER
(
p
)
do
{
(
void
)
p
;
}
while
(
0
)
#
endif
#
endif
