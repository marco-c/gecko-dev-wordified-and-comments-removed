#
ifndef
SFNTLY_CPP_SRC_SFNTLY_TABLE_CORE_CMAP_TABLE_H_
#
define
SFNTLY_CPP_SRC_SFNTLY_TABLE_CORE_CMAP_TABLE_H_
#
include
"
sfntly
/
port
/
type
.
h
"
#
include
<
vector
>
#
include
<
map
>
#
include
"
sfntly
/
port
/
refcount
.
h
"
#
include
"
sfntly
/
table
/
subtable
.
h
"
#
include
"
sfntly
/
table
/
subtable_container_table
.
h
"
namespace
sfntly
{
struct
CMapFormat
{
enum
{
kFormat0
=
0
kFormat2
=
2
kFormat4
=
4
kFormat6
=
6
kFormat8
=
8
kFormat10
=
10
kFormat12
=
12
kFormat13
=
13
kFormat14
=
14
}
;
}
;
class
CMapTable
:
public
SubTableContainerTable
public
RefCounted
<
CMapTable
>
{
public
:
struct
CMapId
{
int32_t
platform_id
;
int32_t
encoding_id
;
bool
operator
=
=
(
const
CMapId
&
obj
)
const
{
return
platform_id
=
=
obj
.
platform_id
&
&
encoding_id
=
=
obj
.
encoding_id
;
}
}
;
static
CMapId
WINDOWS_BMP
;
static
CMapId
WINDOWS_UCS4
;
static
CMapId
MAC_ROMAN
;
class
CMapIdComparator
{
public
:
bool
operator
(
)
(
const
CMapId
&
lhs
const
CMapId
&
rhs
)
const
;
}
;
class
CMapFilter
{
public
:
virtual
bool
accept
(
const
CMapId
&
cmap_id
)
const
=
0
;
virtual
~
CMapFilter
(
)
{
}
}
;
class
CMapIdFilter
:
public
CMapFilter
{
public
:
explicit
CMapIdFilter
(
const
CMapId
wanted_id
)
;
CMapIdFilter
(
const
CMapId
wanted_id
const
CMapIdComparator
*
comparator
)
;
~
CMapIdFilter
(
)
{
}
virtual
bool
accept
(
const
CMapId
&
cmap_id
)
const
;
private
:
CMapIdFilter
&
operator
=
(
const
CMapIdFilter
&
that
)
;
const
CMapId
wanted_id_
;
const
CMapIdComparator
*
comparator_
;
}
;
class
Builder
;
class
CMap
:
public
SubTable
{
public
:
class
Builder
:
public
SubTable
:
:
Builder
{
public
:
virtual
~
Builder
(
)
;
CALLER_ATTACH
static
Builder
*
GetBuilder
(
ReadableFontData
*
data
int32_t
offset
const
CMapId
&
cmap_id
)
;
CALLER_ATTACH
static
Builder
*
GetBuilder
(
int32_t
format
const
CMapId
&
cmap_id
)
;
virtual
CMapId
cmap_id
(
)
{
return
cmap_id_
;
}
virtual
int32_t
platform_id
(
)
{
return
cmap_id_
.
platform_id
;
}
virtual
int32_t
encoding_id
(
)
{
return
cmap_id_
.
encoding_id
;
}
virtual
int32_t
format
(
)
{
return
format_
;
}
virtual
int32_t
language
(
)
{
return
language_
;
}
virtual
void
set_language
(
int32_t
language
)
{
language_
=
language
;
}
protected
:
Builder
(
ReadableFontData
*
data
int32_t
format
const
CMapId
&
cmap_id
)
;
Builder
(
WritableFontData
*
data
int32_t
format
const
CMapId
&
cmap_id
)
;
virtual
int32_t
SubSerialize
(
WritableFontData
*
new_data
)
;
virtual
bool
SubReadyToSerialize
(
)
;
virtual
int32_t
SubDataSizeToSerialize
(
)
;
virtual
void
SubDataSet
(
)
;
private
:
int32_t
format_
;
CMapId
cmap_id_
;
int32_t
language_
;
friend
class
CMapTable
:
:
Builder
;
}
;
class
CharacterIterator
{
public
:
virtual
~
CharacterIterator
(
)
{
}
virtual
bool
HasNext
(
)
=
0
;
virtual
int32_t
Next
(
)
=
0
;
protected
:
CharacterIterator
(
)
{
}
}
;
CMap
(
ReadableFontData
*
data
int32_t
format
const
CMapId
&
cmap_id
)
;
virtual
~
CMap
(
)
;
virtual
CMap
:
:
CharacterIterator
*
Iterator
(
)
=
0
;
virtual
int32_t
format
(
)
{
return
format_
;
}
virtual
CMapId
cmap_id
(
)
{
return
cmap_id_
;
}
virtual
int32_t
platform_id
(
)
{
return
cmap_id_
.
platform_id
;
}
virtual
int32_t
encoding_id
(
)
{
return
cmap_id_
.
encoding_id
;
}
virtual
int32_t
Language
(
)
=
0
;
virtual
int32_t
GlyphId
(
int32_t
character
)
=
0
;
private
:
int32_t
format_
;
CMapId
cmap_id_
;
}
;
typedef
Ptr
<
CMap
>
CMapPtr
;
typedef
Ptr
<
CMap
:
:
Builder
>
CMapBuilderPtr
;
typedef
std
:
:
map
<
CMapId
CMapBuilderPtr
CMapIdComparator
>
CMapBuilderMap
;
class
CMapFormat0
:
public
CMap
public
RefCounted
<
CMapFormat0
>
{
public
:
class
Builder
:
public
CMap
:
:
Builder
public
RefCounted
<
Builder
>
{
public
:
CALLER_ATTACH
static
Builder
*
NewInstance
(
ReadableFontData
*
data
int32_t
offset
const
CMapId
&
cmap_id
)
;
CALLER_ATTACH
static
Builder
*
NewInstance
(
WritableFontData
*
data
int32_t
offset
const
CMapId
&
cmap_id
)
;
CALLER_ATTACH
static
Builder
*
NewInstance
(
const
CMapId
&
cmap_id
)
;
virtual
~
Builder
(
)
;
protected
:
virtual
CALLER_ATTACH
FontDataTable
*
SubBuildTable
(
ReadableFontData
*
data
)
;
private
:
Builder
(
ReadableFontData
*
data
int32_t
offset
const
CMapId
&
cmap_id
)
;
Builder
(
WritableFontData
*
data
int32_t
offset
const
CMapId
&
cmap_id
)
;
Builder
(
const
CMapId
&
cmap_id
)
;
}
;
class
CharacterIterator
:
public
CMap
:
:
CharacterIterator
{
public
:
virtual
~
CharacterIterator
(
)
;
virtual
bool
HasNext
(
)
;
virtual
int32_t
Next
(
)
;
private
:
CharacterIterator
(
int32_t
start
int32_t
end
)
;
friend
class
CMapFormat0
;
int32_t
character_
max_character_
;
}
;
virtual
~
CMapFormat0
(
)
;
virtual
int32_t
Language
(
)
;
virtual
int32_t
GlyphId
(
int32_t
character
)
;
CMap
:
:
CharacterIterator
*
Iterator
(
)
;
private
:
CMapFormat0
(
ReadableFontData
*
data
const
CMapId
&
cmap_id
)
;
}
;
class
CMapFormat2
:
public
CMap
public
RefCounted
<
CMapFormat2
>
{
public
:
class
Builder
:
public
CMap
:
:
Builder
public
RefCounted
<
Builder
>
{
public
:
Builder
(
ReadableFontData
*
data
int32_t
offset
const
CMapId
&
cmap_id
)
;
Builder
(
WritableFontData
*
data
int32_t
offset
const
CMapId
&
cmap_id
)
;
virtual
~
Builder
(
)
;
protected
:
virtual
CALLER_ATTACH
FontDataTable
*
SubBuildTable
(
ReadableFontData
*
data
)
;
}
;
class
CharacterIterator
:
public
CMap
:
:
CharacterIterator
{
public
:
virtual
~
CharacterIterator
(
)
;
virtual
bool
hasNext
(
)
;
virtual
int32_t
next
(
)
;
private
:
CharacterIterator
(
)
;
}
;
virtual
int32_t
Language
(
)
;
virtual
int32_t
GlyphId
(
int32_t
character
)
;
virtual
int32_t
BytesConsumed
(
int32_t
character
)
;
virtual
~
CMapFormat2
(
)
;
private
:
CMapFormat2
(
ReadableFontData
*
data
const
CMapId
&
cmap_id
)
;
int32_t
SubHeaderOffset
(
int32_t
sub_header_index
)
;
int32_t
FirstCode
(
int32_t
sub_header_index
)
;
int32_t
EntryCount
(
int32_t
sub_header_index
)
;
int32_t
IdRangeOffset
(
int32_t
sub_header_index
)
;
int32_t
IdDelta
(
int32_t
sub_header_index
)
;
CMap
:
:
CharacterIterator
*
Iterator
(
)
;
}
;
class
CMapFormat4
:
public
CMap
public
RefCounted
<
CMapFormat4
>
{
public
:
class
Builder
:
public
CMap
:
:
Builder
public
RefCounted
<
Builder
>
{
public
:
class
Segment
:
public
RefCounted
<
Segment
>
{
public
:
Segment
(
)
;
explicit
Segment
(
Segment
*
other
)
;
Segment
(
int32_t
start_count
int32_t
end_count
int32_t
id_delta
int32_t
id_range_offset
)
;
~
Segment
(
)
;
int32_t
start_count
(
)
;
void
set_start_count
(
int32_t
start_count
)
;
int32_t
end_count
(
)
;
void
set_end_count
(
int32_t
end_count
)
;
int32_t
id_delta
(
)
;
void
set_id_delta
(
int32_t
id_delta
)
;
int32_t
id_range_offset
(
)
;
void
set_id_range_offset
(
int32_t
id_range_offset
)
;
static
CALLER_ATTACH
std
:
:
vector
<
Ptr
<
Segment
>
>
*
DeepCopy
(
std
:
:
vector
<
Ptr
<
Segment
>
>
*
original
)
;
private
:
int32_t
start_count_
;
int32_t
end_count_
;
int32_t
id_delta_
;
int32_t
id_range_offset_
;
}
;
typedef
std
:
:
vector
<
Ptr
<
Segment
>
>
SegmentList
;
static
CALLER_ATTACH
Builder
*
NewInstance
(
WritableFontData
*
data
int32_t
offset
const
CMapId
&
cmap_id
)
;
static
CALLER_ATTACH
Builder
*
NewInstance
(
ReadableFontData
*
data
int32_t
offset
const
CMapId
&
cmap_id
)
;
static
CALLER_ATTACH
Builder
*
NewInstance
(
const
CMapId
&
cmap_id
)
;
virtual
~
Builder
(
)
;
SegmentList
*
segments
(
)
;
void
set_segments
(
SegmentList
*
segments
)
;
IntegerList
*
glyph_id_array
(
)
;
void
set_glyph_id_array
(
IntegerList
*
glyph_id_array
)
;
protected
:
Builder
(
WritableFontData
*
data
int32_t
offset
const
CMapId
&
cmap_id
)
;
Builder
(
ReadableFontData
*
data
int32_t
offset
const
CMapId
&
cmap_id
)
;
Builder
(
SegmentList
*
segments
IntegerList
*
glyph_id_array
const
CMapId
&
cmap_id
)
;
explicit
Builder
(
const
CMapId
&
cmap_id
)
;
virtual
CALLER_ATTACH
FontDataTable
*
SubBuildTable
(
ReadableFontData
*
data
)
;
virtual
void
SubDataSet
(
)
;
virtual
int32_t
SubDataSizeToSerialize
(
)
;
virtual
bool
SubReadyToSerialize
(
)
;
virtual
int32_t
SubSerialize
(
WritableFontData
*
new_data
)
;
private
:
void
Initialize
(
ReadableFontData
*
data
)
;
SegmentList
segments_
;
IntegerList
glyph_id_array_
;
}
;
CMap
:
:
CharacterIterator
*
Iterator
(
)
;
class
CharacterIterator
:
public
CMap
:
:
CharacterIterator
{
public
:
bool
HasNext
(
)
;
int32_t
Next
(
)
;
virtual
~
CharacterIterator
(
)
{
}
private
:
explicit
CharacterIterator
(
CMapFormat4
*
parent
)
;
friend
CMap
:
:
CharacterIterator
*
CMapFormat4
:
:
Iterator
(
)
;
CMapFormat4
*
parent_
;
int32_t
segment_index_
;
int32_t
first_char_in_segment_
;
int32_t
last_char_in_segment_
;
int32_t
next_char_
;
bool
next_char_set_
;
}
;
virtual
int32_t
GlyphId
(
int32_t
character
)
;
int32_t
RetrieveGlyphId
(
int32_t
segment
int32_t
start_count
int32_t
character
)
;
virtual
int32_t
Language
(
)
;
int32_t
seg_count
(
)
;
int32_t
Length
(
)
;
int32_t
StartCode
(
int32_t
segment
)
;
int32_t
EndCode
(
int32_t
segment
)
;
int32_t
IdDelta
(
int32_t
segment
)
;
int32_t
IdRangeOffset
(
int32_t
segment
)
;
int32_t
IdRangeOffsetLocation
(
int32_t
segment
)
;
virtual
~
CMapFormat4
(
)
;
protected
:
CMapFormat4
(
ReadableFontData
*
data
const
CMapId
&
cmap_id
)
;
private
:
static
int32_t
Language
(
ReadableFontData
*
data
)
;
static
int32_t
Length
(
ReadableFontData
*
data
)
;
static
int32_t
SegCount
(
ReadableFontData
*
data
)
;
static
int32_t
StartCode
(
ReadableFontData
*
data
int32_t
seg_count
int32_t
index
)
;
static
int32_t
StartCodeOffset
(
int32_t
seg_count
)
;
static
int32_t
EndCode
(
ReadableFontData
*
data
int32_t
seg_count
int32_t
index
)
;
static
int32_t
IdDelta
(
ReadableFontData
*
data
int32_t
seg_count
int32_t
index
)
;
static
int32_t
IdDeltaOffset
(
int32_t
seg_count
)
;
static
int32_t
IdRangeOffset
(
ReadableFontData
*
data
int32_t
seg_count
int32_t
index
)
;
static
int32_t
IdRangeOffsetOffset
(
int32_t
seg_count
)
;
static
int32_t
GlyphIdArrayOffset
(
int32_t
seg_count
)
;
bool
IsValidIndex
(
int32_t
segment
)
;
int32_t
GlyphIdArray
(
int32_t
index
)
;
int32_t
seg_count_
;
int32_t
start_code_offset_
;
int32_t
id_delta_offset_
;
int32_t
glyph_id_array_offset_
;
}
;
class
Builder
:
public
SubTableContainerTable
:
:
Builder
public
RefCounted
<
Builder
>
{
public
:
Builder
(
Header
*
header
WritableFontData
*
data
)
;
Builder
(
Header
*
header
ReadableFontData
*
data
)
;
virtual
~
Builder
(
)
;
virtual
int32_t
SubSerialize
(
WritableFontData
*
new_data
)
;
virtual
bool
SubReadyToSerialize
(
)
;
virtual
int32_t
SubDataSizeToSerialize
(
)
;
virtual
void
SubDataSet
(
)
;
virtual
CALLER_ATTACH
FontDataTable
*
SubBuildTable
(
ReadableFontData
*
data
)
;
static
CALLER_ATTACH
Builder
*
CreateBuilder
(
Header
*
header
WritableFontData
*
data
)
;
CMap
:
:
Builder
*
NewCMapBuilder
(
const
CMapId
&
cmap_id
ReadableFontData
*
data
)
;
CMap
:
:
Builder
*
NewCMapBuilder
(
int32_t
format
const
CMapId
&
cmap_id
)
;
CMap
:
:
Builder
*
CMapBuilder
(
const
CMapId
&
cmap_id
)
;
int32_t
NumCMaps
(
)
;
void
SetVersion
(
int32_t
version
)
;
CMapBuilderMap
*
GetCMapBuilders
(
)
;
protected
:
static
CALLER_ATTACH
CMap
:
:
Builder
*
CMapBuilder
(
ReadableFontData
*
data
int32_t
index
)
;
private
:
void
Initialize
(
ReadableFontData
*
data
)
;
static
int32_t
NumCMaps
(
ReadableFontData
*
data
)
;
int32_t
version_
;
CMapBuilderMap
cmap_builders_
;
}
;
typedef
Ptr
<
Builder
>
CMapTableBuilderPtr
;
class
CMapIterator
{
public
:
CMapIterator
(
CMapTable
*
table
const
CMapFilter
*
filter
)
;
bool
HasNext
(
)
;
CMap
*
Next
(
)
;
private
:
int32_t
table_index_
;
const
CMapFilter
*
filter_
;
CMapTable
*
table_
;
}
;
static
CMapId
NewCMapId
(
int32_t
platform_id
int32_t
encoding_id
)
;
static
CMapId
NewCMapId
(
const
CMapId
&
obj
)
;
CALLER_ATTACH
CMap
*
GetCMap
(
const
int32_t
index
)
;
CALLER_ATTACH
CMap
*
GetCMap
(
const
int32_t
platform_id
const
int32_t
encoding_id
)
;
CALLER_ATTACH
CMap
*
GetCMap
(
const
CMapId
GetCMap_id
)
;
virtual
int32_t
Version
(
)
;
virtual
int32_t
NumCMaps
(
)
;
virtual
CMapId
GetCMapId
(
int32_t
index
)
;
virtual
int32_t
PlatformId
(
int32_t
index
)
;
virtual
int32_t
EncodingId
(
int32_t
index
)
;
virtual
int32_t
Offset
(
int32_t
index
)
;
virtual
~
CMapTable
(
)
;
static
const
int32_t
NOTDEF
;
private
:
struct
Offset
{
enum
{
kVersion
=
0
kNumTables
=
2
kEncodingRecordStart
=
4
kEncodingRecordPlatformId
=
0
kEncodingRecordEncodingId
=
2
kEncodingRecordOffset
=
4
kEncodingRecordSize
=
8
kFormat
=
0
kFormat0Format
=
0
kFormat0Length
=
2
kFormat0Language
=
4
kFormat0GlyphIdArray
=
6
kFormat2Format
=
0
kFormat2Length
=
2
kFormat2Language
=
4
kFormat2SubHeaderKeys
=
6
kFormat2SubHeaders
=
518
kFormat2SubHeader_firstCode
=
0
kFormat2SubHeader_entryCount
=
2
kFormat2SubHeader_idDelta
=
4
kFormat2SubHeader_idRangeOffset
=
6
kFormat2SubHeader_structLength
=
8
kFormat4Format
=
0
kFormat4Length
=
2
kFormat4Language
=
4
kFormat4SegCountX2
=
6
kFormat4SearchRange
=
8
kFormat4EntrySelector
=
10
kFormat4RangeShift
=
12
kFormat4EndCount
=
14
kFormat4FixedSize
=
16
kFormat6Format
=
0
kFormat6Length
=
2
kFormat6Language
=
4
kFormat6FirstCode
=
6
kFormat6EntryCount
=
8
kFormat6GlyphIdArray
=
10
kFormat8Format
=
0
kFormat8Length
=
4
kFormat8Language
=
8
kFormat8Is32
=
12
kFormat8nGroups204
=
8204
kFormat8Groups208
=
8208
kFormat8Group_startCharCode
=
0
kFormat8Group_endCharCode
=
4
kFormat8Group_startGlyphId
=
8
kFormat8Group_structLength
=
12
kFormat10Format
=
0
kFormat10Length
=
4
kFormat10Language
=
8
kFormat10StartCharCode
=
12
kFormat10NumChars
=
16
kFormat10Glyphs0
=
20
kFormat12Format
=
0
kFormat12Length
=
4
kFormat12Language
=
8
kFormat12nGroups
=
12
kFormat12Groups
=
16
kFormat12Groups_structLength
=
12
kFormat12_startCharCode
=
0
kFormat12_endCharCode
=
4
kFormat12_startGlyphId
=
8
kFormat13Format
=
0
kFormat13Length
=
4
kFormat13Language
=
8
kFormat13nGroups
=
12
kFormat13Groups
=
16
kFormat13Groups_structLength
=
12
kFormat13_startCharCode
=
0
kFormat13_endCharCode
=
4
kFormat13_glyphId
=
8
kFormat14Format
=
0
kFormat14Length
=
2
kLast
=
-
1
}
;
}
;
CMapTable
(
Header
*
header
ReadableFontData
*
data
)
;
static
int32_t
OffsetForEncodingRecord
(
int32_t
index
)
;
}
;
typedef
std
:
:
vector
<
CMapTable
:
:
CMapId
>
CMapIdList
;
typedef
Ptr
<
CMapTable
>
CMapTablePtr
;
typedef
std
:
:
vector
<
Ptr
<
CMapTable
:
:
CMapFormat4
:
:
Builder
:
:
Segment
>
>
SegmentList
;
}
#
endif
