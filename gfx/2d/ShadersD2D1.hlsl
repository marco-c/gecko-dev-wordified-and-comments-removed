Texture2D
InputTexture
:
register
(
t0
)
;
SamplerState
InputSampler
:
register
(
s0
)
;
Texture2D
GradientTexture
:
register
(
t1
)
;
SamplerState
GradientSampler
:
register
(
s1
)
;
cbuffer
radialGradientConstants
:
register
(
b0
)
{
float3
diff
:
packoffset
(
c0
.
x
)
;
float2
center1
:
packoffset
(
c1
.
x
)
;
float
A
:
packoffset
(
c1
.
z
)
;
float
radius1
:
packoffset
(
c1
.
w
)
;
float
sq_radius1
:
packoffset
(
c2
.
x
)
;
float
repeat_correct
:
packoffset
(
c2
.
y
)
;
float
allow_odd
:
packoffset
(
c2
.
z
)
;
float3x2
transform
:
packoffset
(
c3
.
x
)
;
}
cbuffer
conicGradientConstants
:
register
(
b0
)
{
float2
center
:
packoffset
(
c0
.
x
)
;
float
angle
:
packoffset
(
c0
.
z
)
;
float
start_offset
:
packoffset
(
c0
.
w
)
;
float
end_offset
:
packoffset
(
c1
.
x
)
;
float
repeat_correct_conic
:
packoffset
(
c1
.
y
)
;
float
allow_odd_conic
:
packoffset
(
c1
.
z
)
;
float3x2
transform_conic
:
packoffset
(
c2
.
x
)
;
}
static
const
float
M_PI
=
3
.
14159265f
;
float4
SampleConicGradientPS
(
float4
clipSpaceOutput
:
SV_POSITION
float4
sceneSpaceOutput
:
SCENE_POSITION
float4
texelSpaceInput0
:
TEXCOORD0
)
:
SV_Target
{
float2
p
=
float2
(
sceneSpaceOutput
.
x
*
transform_conic
.
_11
+
sceneSpaceOutput
.
y
*
transform_conic
.
_21
+
transform_conic
.
_31
sceneSpaceOutput
.
x
*
transform_conic
.
_12
+
sceneSpaceOutput
.
y
*
transform_conic
.
_22
+
transform_conic
.
_32
)
;
float2
dir
=
float2
(
-
(
center
.
y
-
p
.
y
)
(
center
.
x
-
p
.
x
)
)
;
float
vstart
=
start_offset
;
float
vend
=
end_offset
;
float
n
=
1
/
(
vend
-
vstart
)
;
float
current_angle
=
atan2
(
dir
.
y
dir
.
x
)
-
angle
;
float
lambda
=
fmod
(
n
*
current_angle
/
M_PI
/
2
+
vend
-
vstart
+
.
5
1
)
;
float
offset
=
lambda
;
float4
output
=
GradientTexture
.
Sample
(
GradientSampler
float2
(
offset
0
.
5
)
)
;
output
.
rgb
*
=
output
.
a
;
output
*
=
InputTexture
.
Sample
(
InputSampler
texelSpaceInput0
.
xy
)
;
return
output
;
}
;
float4
SampleRadialGradientPS
(
float4
clipSpaceOutput
:
SV_POSITION
float4
sceneSpaceOutput
:
SCENE_POSITION
float4
texelSpaceInput0
:
TEXCOORD0
)
:
SV_Target
{
float2
p
=
float2
(
sceneSpaceOutput
.
x
*
transform
.
_11
+
sceneSpaceOutput
.
y
*
transform
.
_21
+
transform
.
_31
sceneSpaceOutput
.
x
*
transform
.
_12
+
sceneSpaceOutput
.
y
*
transform
.
_22
+
transform
.
_32
)
;
float3
dp
=
float3
(
p
-
center1
radius1
)
;
float
B
=
dot
(
dp
diff
)
;
float
C
=
pow
(
dp
.
x
2
)
+
pow
(
dp
.
y
2
)
-
sq_radius1
;
float
det
=
pow
(
B
2
)
-
A
*
C
;
float
sqrt_det
=
sqrt
(
abs
(
det
)
)
;
float2
t
=
(
B
+
float2
(
sqrt_det
-
sqrt_det
)
)
/
A
;
float2
isValid
=
step
(
float2
(
-
radius1
-
radius1
)
t
*
diff
.
z
)
;
float
upper_t
=
lerp
(
t
.
y
t
.
x
isValid
.
x
)
;
float
oddeven
=
abs
(
fmod
(
floor
(
upper_t
)
2
)
)
*
allow_odd
;
float
upper_t_repeated
=
(
(
upper_t
-
floor
(
upper_t
)
)
*
(
1
.
0f
-
oddeven
)
)
+
(
(
ceil
(
upper_t
)
-
upper_t
)
*
oddeven
)
;
float4
output
=
GradientTexture
.
Sample
(
GradientSampler
float2
(
upper_t
*
(
1
.
0f
-
repeat_correct
)
+
upper_t_repeated
*
repeat_correct
0
.
5
)
)
;
output
.
rgb
*
=
output
.
a
;
output
*
=
InputTexture
.
Sample
(
InputSampler
texelSpaceInput0
.
xy
)
;
return
output
*
abs
(
step
(
max
(
isValid
.
x
isValid
.
y
)
0
)
-
1
.
0f
)
*
step
(
0
det
)
;
}
;
float4
SampleRadialGradientA0PS
(
float4
clipSpaceOutput
:
SV_POSITION
float4
sceneSpaceOutput
:
SCENE_POSITION
float4
texelSpaceInput0
:
TEXCOORD0
)
:
SV_Target
{
float2
p
=
float2
(
sceneSpaceOutput
.
x
*
transform
.
_11
+
sceneSpaceOutput
.
y
*
transform
.
_21
+
transform
.
_31
sceneSpaceOutput
.
x
*
transform
.
_12
+
sceneSpaceOutput
.
y
*
transform
.
_22
+
transform
.
_32
)
;
float3
dp
=
float3
(
p
-
center1
radius1
)
;
float
B
=
dot
(
dp
diff
)
;
float
C
=
pow
(
dp
.
x
2
)
+
pow
(
dp
.
y
2
)
-
pow
(
radius1
2
)
;
float
t
=
0
.
5
*
C
/
B
;
float
oddeven
=
abs
(
fmod
(
floor
(
t
)
2
)
)
*
allow_odd
;
float
t_repeated
=
(
(
t
-
floor
(
t
)
)
*
(
1
.
0f
-
oddeven
)
)
+
(
(
ceil
(
t
)
-
t
)
*
oddeven
)
;
float4
output
=
GradientTexture
.
Sample
(
GradientSampler
float2
(
t
*
(
1
.
0f
-
repeat_correct
)
+
t_repeated
*
repeat_correct
0
.
5
)
)
;
output
.
rgb
*
=
output
.
a
;
output
*
=
InputTexture
.
Sample
(
InputSampler
texelSpaceInput0
.
xy
)
;
return
output
*
abs
(
step
(
t
*
diff
.
z
-
radius1
)
-
1
.
0f
)
;
}
;
