#
ifndef
MOZILLA_GFX_ITERABLEARENA_H_
#
define
MOZILLA_GFX_ITERABLEARENA_H_
#
include
<
utility
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
<
string
.
h
>
#
include
<
vector
>
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
namespace
mozilla
{
namespace
gfx
{
class
IterableArena
{
protected
:
struct
Header
{
size_t
mBlocSize
;
}
;
public
:
enum
ArenaType
{
FIXED_SIZE
GROWABLE
}
;
IterableArena
(
ArenaType
aType
size_t
aStorageSize
)
:
mSize
(
aStorageSize
)
mCursor
(
0
)
mIsGrowable
(
aType
=
=
GROWABLE
)
{
if
(
mSize
=
=
0
)
{
mSize
=
128
;
}
mStorage
=
(
uint8_t
*
)
malloc
(
mSize
)
;
if
(
mStorage
=
=
nullptr
)
{
gfxCriticalError
(
)
<
<
"
Not
enough
Memory
allocate
a
memory
pool
of
size
"
<
<
aStorageSize
;
MOZ_CRASH
(
"
GFX
:
Out
of
memory
IterableArena
"
)
;
}
}
~
IterableArena
(
)
{
free
(
mStorage
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
ptrdiff_t
Alloc
(
Args
&
&
.
.
.
aArgs
)
{
void
*
storage
=
nullptr
;
auto
offset
=
AllocRaw
(
sizeof
(
T
)
&
storage
)
;
if
(
offset
<
0
)
{
return
offset
;
}
new
(
storage
)
T
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
return
offset
;
}
ptrdiff_t
AllocRaw
(
size_t
aSize
void
*
*
aOutPtr
=
nullptr
)
{
const
size_t
blocSize
=
AlignedSize
(
sizeof
(
Header
)
+
aSize
)
;
if
(
AlignedSize
(
mCursor
+
blocSize
)
>
mSize
)
{
if
(
!
mIsGrowable
)
{
return
-
1
;
}
size_t
newSize
=
mSize
*
2
;
while
(
AlignedSize
(
mCursor
+
blocSize
)
>
newSize
)
{
newSize
*
=
2
;
}
uint8_t
*
newStorage
=
(
uint8_t
*
)
realloc
(
mStorage
newSize
)
;
if
(
!
newStorage
)
{
gfxCriticalError
(
)
<
<
"
Not
enough
Memory
to
grow
the
memory
pool
size
:
"
<
<
newSize
;
return
-
1
;
}
mStorage
=
newStorage
;
mSize
=
newSize
;
}
ptrdiff_t
offset
=
mCursor
;
GetHeader
(
offset
)
-
>
mBlocSize
=
blocSize
;
mCursor
+
=
blocSize
;
if
(
aOutPtr
)
{
*
aOutPtr
=
GetStorage
(
offset
)
;
}
return
offset
;
}
void
*
GetStorage
(
ptrdiff_t
offset
=
0
)
{
MOZ_ASSERT
(
offset
>
=
0
)
;
MOZ_ASSERT
(
offset
<
mCursor
)
;
return
offset
>
=
0
?
mStorage
+
offset
+
sizeof
(
Header
)
:
nullptr
;
}
void
Clear
(
)
{
mCursor
=
0
;
}
template
<
typename
Func
>
void
ForEach
(
Func
cb
)
{
Iterator
it
;
while
(
void
*
ptr
=
it
.
Next
(
this
)
)
{
cb
(
ptr
)
;
}
}
class
Iterator
{
public
:
Iterator
(
)
:
mCursor
(
0
)
{
}
void
*
Next
(
IterableArena
*
aArena
)
{
if
(
mCursor
>
=
aArena
-
>
mCursor
)
{
return
nullptr
;
}
void
*
result
=
aArena
-
>
GetStorage
(
mCursor
)
;
const
size_t
blocSize
=
aArena
-
>
GetHeader
(
mCursor
)
-
>
mBlocSize
;
MOZ_ASSERT
(
blocSize
!
=
0
)
;
mCursor
+
=
blocSize
;
return
result
;
}
private
:
ptrdiff_t
mCursor
;
}
;
protected
:
Header
*
GetHeader
(
ptrdiff_t
offset
)
{
return
(
Header
*
)
(
mStorage
+
offset
)
;
}
size_t
AlignedSize
(
size_t
aSize
)
const
{
const
size_t
alignment
=
sizeof
(
uintptr_t
)
;
return
aSize
+
(
alignment
-
(
aSize
%
alignment
)
)
%
alignment
;
}
uint8_t
*
mStorage
;
uint32_t
mSize
;
ptrdiff_t
mCursor
;
bool
mIsGrowable
;
friend
class
Iterator
;
}
;
}
}
#
endif
