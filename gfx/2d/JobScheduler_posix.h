#
ifndef
WIN32
#
ifndef
MOZILLA_GFX_TASKSCHEDULER_POSIX_H_
#
define
MOZILLA_GFX_TASKSCHEDULER_POSIX_H_
#
include
<
string
>
#
include
<
vector
>
#
include
<
list
>
#
include
<
pthread
.
h
>
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
namespace
mozilla
{
namespace
gfx
{
class
Job
;
class
PosixCondVar
;
class
Mutex
{
public
:
Mutex
(
)
{
DebugOnly
<
int
>
err
=
pthread_mutex_init
(
&
mMutex
nullptr
)
;
MOZ_ASSERT
(
!
err
)
;
}
~
Mutex
(
)
{
DebugOnly
<
int
>
err
=
pthread_mutex_destroy
(
&
mMutex
)
;
MOZ_ASSERT
(
!
err
)
;
}
void
Lock
(
)
{
DebugOnly
<
int
>
err
=
pthread_mutex_lock
(
&
mMutex
)
;
MOZ_ASSERT
(
!
err
)
;
}
void
Unlock
(
)
{
DebugOnly
<
int
>
err
=
pthread_mutex_unlock
(
&
mMutex
)
;
MOZ_ASSERT
(
!
err
)
;
}
protected
:
pthread_mutex_t
mMutex
;
friend
class
PosixCondVar
;
}
;
class
PosixCondVar
{
public
:
PosixCondVar
(
)
{
DebugOnly
<
int
>
err
=
pthread_cond_init
(
&
mCond
nullptr
)
;
MOZ_ASSERT
(
!
err
)
;
}
~
PosixCondVar
(
)
{
DebugOnly
<
int
>
err
=
pthread_cond_destroy
(
&
mCond
)
;
MOZ_ASSERT
(
!
err
)
;
}
void
Wait
(
Mutex
*
aMutex
)
{
DebugOnly
<
int
>
err
=
pthread_cond_wait
(
&
mCond
&
aMutex
-
>
mMutex
)
;
MOZ_ASSERT
(
!
err
)
;
}
void
Broadcast
(
)
{
DebugOnly
<
int
>
err
=
pthread_cond_broadcast
(
&
mCond
)
;
MOZ_ASSERT
(
!
err
)
;
}
protected
:
pthread_cond_t
mCond
;
}
;
class
MultiThreadedJobQueue
{
public
:
enum
AccessType
{
BLOCKING
NON_BLOCKING
}
;
MultiThreadedJobQueue
(
)
;
~
MultiThreadedJobQueue
(
)
;
bool
WaitForJob
(
Job
*
&
aOutJob
)
;
bool
PopJob
(
Job
*
&
aOutJob
AccessType
aAccess
)
;
void
SubmitJob
(
Job
*
aJob
)
;
void
ShutDown
(
)
;
size_t
NumJobs
(
)
;
bool
IsEmpty
(
)
;
void
RegisterThread
(
)
;
void
UnregisterThread
(
)
;
protected
:
std
:
:
list
<
Job
*
>
mJobs
;
Mutex
mMutex
;
PosixCondVar
mAvailableCondvar
;
PosixCondVar
mShutdownCondvar
;
int32_t
mThreadsCount
;
bool
mShuttingDown
;
friend
class
WorkerThread
;
}
;
class
WorkerThread
{
public
:
explicit
WorkerThread
(
MultiThreadedJobQueue
*
aJobQueue
)
;
~
WorkerThread
(
)
;
void
Run
(
)
;
MultiThreadedJobQueue
*
GetJobQueue
(
)
{
return
mQueue
;
}
protected
:
void
SetName
(
const
char
*
name
)
;
MultiThreadedJobQueue
*
mQueue
;
pthread_t
mThread
;
}
;
class
EventObject
:
public
external
:
:
AtomicRefCounted
<
EventObject
>
{
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
EventObject
)
EventObject
(
)
;
~
EventObject
(
)
;
void
Wait
(
)
;
bool
Peak
(
)
;
void
Set
(
)
;
protected
:
Mutex
mMutex
;
PosixCondVar
mCond
;
bool
mIsSet
;
}
;
}
}
#
include
"
JobScheduler
.
h
"
#
endif
#
endif
