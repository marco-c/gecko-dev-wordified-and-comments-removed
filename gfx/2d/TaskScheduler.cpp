#
include
"
TaskScheduler
.
h
"
namespace
mozilla
{
namespace
gfx
{
TaskScheduler
*
TaskScheduler
:
:
sSingleton
=
nullptr
;
bool
TaskScheduler
:
:
Init
(
uint32_t
aNumThreads
uint32_t
aNumQueues
)
{
MOZ_ASSERT
(
!
sSingleton
)
;
MOZ_ASSERT
(
aNumThreads
>
=
aNumQueues
)
;
sSingleton
=
new
TaskScheduler
(
)
;
sSingleton
-
>
mNextQueue
=
0
;
for
(
uint32_t
i
=
0
;
i
<
aNumQueues
;
+
+
i
)
{
sSingleton
-
>
mDrawingQueues
.
push_back
(
new
MultiThreadedTaskQueue
(
)
)
;
}
for
(
uint32_t
i
=
0
;
i
<
aNumThreads
;
+
+
i
)
{
sSingleton
-
>
mWorkerThreads
.
push_back
(
WorkerThread
:
:
Create
(
sSingleton
-
>
mDrawingQueues
[
i
%
aNumQueues
]
)
)
;
}
return
true
;
}
void
TaskScheduler
:
:
ShutDown
(
)
{
MOZ_ASSERT
(
IsEnabled
(
)
)
;
if
(
!
IsEnabled
(
)
)
{
return
;
}
for
(
auto
queue
:
sSingleton
-
>
mDrawingQueues
)
{
queue
-
>
ShutDown
(
)
;
delete
queue
;
}
for
(
WorkerThread
*
thread
:
sSingleton
-
>
mWorkerThreads
)
{
delete
thread
;
}
sSingleton
-
>
mWorkerThreads
.
clear
(
)
;
delete
sSingleton
;
sSingleton
=
nullptr
;
}
TaskStatus
TaskScheduler
:
:
ProcessTask
(
Task
*
aTask
)
{
MOZ_ASSERT
(
aTask
)
;
auto
status
=
aTask
-
>
Run
(
)
;
if
(
status
=
=
TaskStatus
:
:
Error
|
|
status
=
=
TaskStatus
:
:
Complete
)
{
delete
aTask
;
}
return
status
;
}
void
TaskScheduler
:
:
SubmitTask
(
Task
*
aTask
)
{
MOZ_ASSERT
(
aTask
)
;
RefPtr
<
SyncObject
>
start
=
aTask
-
>
GetStartSync
(
)
;
if
(
start
&
&
start
-
>
Register
(
aTask
)
)
{
return
;
}
aTask
-
>
GetTaskQueue
(
)
-
>
SubmitTask
(
aTask
)
;
}
Task
:
:
Task
(
MultiThreadedTaskQueue
*
aQueue
SyncObject
*
aStart
SyncObject
*
aCompletion
)
:
mQueue
(
aQueue
)
mStartSync
(
aStart
)
mCompletionSync
(
aCompletion
)
{
if
(
mStartSync
)
{
mStartSync
-
>
AddSubsequent
(
this
)
;
}
if
(
mCompletionSync
)
{
mCompletionSync
-
>
AddPrerequisite
(
this
)
;
}
}
Task
:
:
~
Task
(
)
{
if
(
mCompletionSync
)
{
mCompletionSync
-
>
Signal
(
)
;
mCompletionSync
=
nullptr
;
}
}
TaskStatus
SetEventTask
:
:
Run
(
)
{
mEvent
-
>
Set
(
)
;
return
TaskStatus
:
:
Complete
;
}
SetEventTask
:
:
SetEventTask
(
MultiThreadedTaskQueue
*
aQueue
SyncObject
*
aStart
SyncObject
*
aCompletion
)
:
Task
(
aQueue
aStart
aCompletion
)
{
mEvent
=
new
EventObject
(
)
;
}
SetEventTask
:
:
~
SetEventTask
(
)
{
}
SyncObject
:
:
SyncObject
(
)
:
mSignals
(
0
)
mHasSubmittedSubsequent
(
false
)
{
}
SyncObject
:
:
~
SyncObject
(
)
{
MOZ_ASSERT
(
mWaitingTasks
.
size
(
)
=
=
0
)
;
}
bool
SyncObject
:
:
Register
(
Task
*
aTask
)
{
MOZ_ASSERT
(
aTask
)
;
mHasSubmittedSubsequent
=
true
;
int32_t
signals
=
mSignals
;
if
(
signals
>
0
)
{
AddWaitingTask
(
aTask
)
;
int32_t
signals2
=
mSignals
;
if
(
signals2
=
=
0
)
{
SubmitWaitingTasks
(
)
;
}
return
true
;
}
return
false
;
}
void
SyncObject
:
:
Signal
(
)
{
bool
hasSubmittedSubsequent
=
mHasSubmittedSubsequent
;
int32_t
signals
=
-
-
mSignals
;
MOZ_ASSERT
(
signals
>
=
0
)
;
if
(
hasSubmittedSubsequent
&
&
signals
=
=
0
)
{
SubmitWaitingTasks
(
)
;
}
}
void
SyncObject
:
:
AddWaitingTask
(
Task
*
aTask
)
{
CriticalSectionAutoEnter
lock
(
&
mWaitingTasksSection
)
;
mWaitingTasks
.
push_back
(
aTask
)
;
}
void
SyncObject
:
:
SubmitWaitingTasks
(
)
{
std
:
:
vector
<
Task
*
>
tasksToSubmit
;
{
RefPtr
<
SyncObject
>
kungFuDeathGrip
(
this
)
;
CriticalSectionAutoEnter
lock
(
&
mWaitingTasksSection
)
;
tasksToSubmit
=
Move
(
mWaitingTasks
)
;
mWaitingTasks
.
clear
(
)
;
}
for
(
Task
*
task
:
tasksToSubmit
)
{
task
-
>
GetTaskQueue
(
)
-
>
SubmitTask
(
task
)
;
}
}
bool
SyncObject
:
:
IsSignaled
(
)
{
return
mSignals
=
=
0
;
}
void
SyncObject
:
:
AddPrerequisite
(
Task
*
aTask
)
{
#
ifdef
DEBUG
mPrerequisites
.
push_back
(
aTask
)
;
#
endif
MOZ_ASSERT
(
!
mHasSubmittedSubsequent
)
;
mSignals
+
+
;
}
void
SyncObject
:
:
AddSubsequent
(
Task
*
aTask
)
{
#
ifdef
DEBUG
mSubsequents
.
push_back
(
aTask
)
;
#
endif
}
WorkerThread
:
:
WorkerThread
(
MultiThreadedTaskQueue
*
aTaskQueue
)
:
mQueue
(
aTaskQueue
)
{
aTaskQueue
-
>
RegisterThread
(
)
;
}
void
WorkerThread
:
:
Run
(
)
{
for
(
;
;
)
{
Task
*
commands
=
nullptr
;
if
(
!
mQueue
-
>
WaitForTask
(
commands
)
)
{
mQueue
-
>
UnregisterThread
(
)
;
return
;
}
TaskStatus
status
=
TaskScheduler
:
:
ProcessTask
(
commands
)
;
if
(
status
=
=
TaskStatus
:
:
Error
)
{
MOZ_CRASH
(
)
;
}
}
}
}
}
