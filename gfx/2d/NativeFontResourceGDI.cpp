#
include
"
NativeFontResourceGDI
.
h
"
#
include
"
Logging
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
ScaledFontWin
.
h
"
#
include
"
SFNTData
.
h
"
namespace
mozilla
{
namespace
gfx
{
already_AddRefed
<
NativeFontResourceGDI
>
NativeFontResourceGDI
:
:
Create
(
uint8_t
*
aFontData
uint32_t
aDataLength
bool
aNeedsCairo
)
{
UniquePtr
<
SFNTData
>
sfntData
=
SFNTData
:
:
Create
(
aFontData
aDataLength
)
;
if
(
!
sfntData
)
{
gfxWarning
(
)
<
<
"
Failed
to
create
SFNTData
for
ScaledFontWin
.
"
;
return
nullptr
;
}
Vector
<
mozilla
:
:
u16string
>
fontNames
;
if
(
!
sfntData
-
>
GetU16FullNames
(
fontNames
)
)
{
gfxWarning
(
)
<
<
"
Failed
to
get
font
names
from
font
.
"
;
return
nullptr
;
}
for
(
size_t
i
=
0
;
i
<
fontNames
.
length
(
)
;
+
+
i
)
{
if
(
fontNames
[
i
]
.
size
(
)
>
LF_FACESIZE
-
1
)
{
fontNames
[
i
]
.
resize
(
LF_FACESIZE
-
1
)
;
}
fontNames
[
i
]
.
append
(
1
'
\
0
'
)
;
}
DWORD
numberOfFontsAdded
;
HANDLE
fontResourceHandle
=
:
:
AddFontMemResourceEx
(
aFontData
aDataLength
0
&
numberOfFontsAdded
)
;
if
(
!
fontResourceHandle
)
{
gfxWarning
(
)
<
<
"
Failed
to
add
memory
font
resource
.
"
;
return
nullptr
;
}
if
(
numberOfFontsAdded
!
=
fontNames
.
length
(
)
)
{
gfxWarning
(
)
<
<
"
Number
of
fonts
added
doesn
'
t
match
number
of
names
extracted
.
"
;
}
RefPtr
<
NativeFontResourceGDI
>
fontResouce
=
new
NativeFontResourceGDI
(
fontResourceHandle
Move
(
fontNames
)
aNeedsCairo
)
;
return
fontResouce
.
forget
(
)
;
}
NativeFontResourceGDI
:
:
~
NativeFontResourceGDI
(
)
{
:
:
RemoveFontMemResourceEx
(
mFontResourceHandle
)
;
}
already_AddRefed
<
ScaledFont
>
NativeFontResourceGDI
:
:
CreateScaledFont
(
uint32_t
aIndex
Float
aGlyphSize
const
uint8_t
*
aInstanceData
uint32_t
aInstanceDataLength
)
{
if
(
aIndex
>
=
mFontNames
.
length
(
)
)
{
gfxWarning
(
)
<
<
"
Font
index
is
too
high
for
font
resource
.
"
;
return
nullptr
;
}
if
(
mFontNames
[
aIndex
]
.
empty
(
)
)
{
gfxWarning
(
)
<
<
"
Font
name
for
index
is
empty
.
"
;
return
nullptr
;
}
LOGFONT
logFont
;
logFont
.
lfHeight
=
0
;
logFont
.
lfWidth
=
0
;
logFont
.
lfEscapement
=
0
;
logFont
.
lfOrientation
=
0
;
logFont
.
lfWeight
=
FW_DONTCARE
;
logFont
.
lfItalic
=
FALSE
;
logFont
.
lfUnderline
=
FALSE
;
logFont
.
lfStrikeOut
=
FALSE
;
logFont
.
lfCharSet
=
DEFAULT_CHARSET
;
logFont
.
lfOutPrecision
=
OUT_DEFAULT_PRECIS
;
logFont
.
lfClipPrecision
=
CLIP_DEFAULT_PRECIS
;
logFont
.
lfQuality
=
DEFAULT_QUALITY
;
logFont
.
lfPitchAndFamily
=
DEFAULT_PITCH
|
FF_DONTCARE
;
mFontNames
[
aIndex
]
.
copy
(
reinterpret_cast
<
char16_t
*
>
(
logFont
.
lfFaceName
)
mFontNames
[
aIndex
]
.
length
(
)
)
;
RefPtr
<
ScaledFontBase
>
scaledFont
=
new
ScaledFontWin
(
&
logFont
aGlyphSize
)
;
if
(
mNeedsCairo
&
&
!
scaledFont
-
>
PopulateCairoScaledFont
(
)
)
{
gfxWarning
(
)
<
<
"
Unable
to
create
cairo
scaled
font
DWrite
font
.
"
;
return
nullptr
;
}
return
scaledFont
.
forget
(
)
;
}
}
}
