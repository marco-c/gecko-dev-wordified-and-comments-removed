#
include
"
SkConvolver
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
<
arm_neon
.
h
>
namespace
skia
{
static
MOZ_ALWAYS_INLINE
void
AccumRemainder
(
const
unsigned
char
*
pixelsLeft
const
SkConvolutionFilter1D
:
:
ConvolutionFixed
*
filterValues
int32x4_t
&
accum
int
r
)
{
int
remainder
[
4
]
=
{
0
}
;
for
(
int
i
=
0
;
i
<
r
;
i
+
+
)
{
SkConvolutionFilter1D
:
:
ConvolutionFixed
coeff
=
filterValues
[
i
]
;
remainder
[
0
]
+
=
coeff
*
pixelsLeft
[
i
*
4
+
0
]
;
remainder
[
1
]
+
=
coeff
*
pixelsLeft
[
i
*
4
+
1
]
;
remainder
[
2
]
+
=
coeff
*
pixelsLeft
[
i
*
4
+
2
]
;
remainder
[
3
]
+
=
coeff
*
pixelsLeft
[
i
*
4
+
3
]
;
}
int32x4_t
t
=
{
remainder
[
0
]
remainder
[
1
]
remainder
[
2
]
remainder
[
3
]
}
;
accum
+
=
t
;
}
void
convolve_horizontally_neon
(
const
unsigned
char
*
srcData
const
SkConvolutionFilter1D
&
filter
unsigned
char
*
outRow
bool
)
{
int
numValues
=
filter
.
numValues
(
)
;
for
(
int
outX
=
0
;
outX
<
numValues
;
outX
+
+
)
{
uint8x8_t
coeff_mask0
=
vcreate_u8
(
0x0100010001000100
)
;
uint8x8_t
coeff_mask1
=
vcreate_u8
(
0x0302030203020302
)
;
uint8x8_t
coeff_mask2
=
vcreate_u8
(
0x0504050405040504
)
;
uint8x8_t
coeff_mask3
=
vcreate_u8
(
0x0706070607060706
)
;
int
filterOffset
filterLength
;
const
SkConvolutionFilter1D
:
:
ConvolutionFixed
*
filterValues
=
filter
.
FilterForValue
(
outX
&
filterOffset
&
filterLength
)
;
const
unsigned
char
*
rowToFilter
=
&
srcData
[
filterOffset
*
4
]
;
int32x4_t
accum
=
vdupq_n_s32
(
0
)
;
for
(
int
filterX
=
0
;
filterX
<
filterLength
>
>
2
;
filterX
+
+
)
{
int16x4_t
coeffs
coeff0
coeff1
coeff2
coeff3
;
coeffs
=
vld1_s16
(
filterValues
)
;
coeff0
=
vreinterpret_s16_u8
(
vtbl1_u8
(
vreinterpret_u8_s16
(
coeffs
)
coeff_mask0
)
)
;
coeff1
=
vreinterpret_s16_u8
(
vtbl1_u8
(
vreinterpret_u8_s16
(
coeffs
)
coeff_mask1
)
)
;
coeff2
=
vreinterpret_s16_u8
(
vtbl1_u8
(
vreinterpret_u8_s16
(
coeffs
)
coeff_mask2
)
)
;
coeff3
=
vreinterpret_s16_u8
(
vtbl1_u8
(
vreinterpret_u8_s16
(
coeffs
)
coeff_mask3
)
)
;
uint8x16_t
pixels
=
vld1q_u8
(
rowToFilter
)
;
int16x8_t
p01_16
=
vreinterpretq_s16_u16
(
vmovl_u8
(
vget_low_u8
(
pixels
)
)
)
;
int16x8_t
p23_16
=
vreinterpretq_s16_u16
(
vmovl_u8
(
vget_high_u8
(
pixels
)
)
)
;
int16x4_t
p0_src
=
vget_low_s16
(
p01_16
)
;
int16x4_t
p1_src
=
vget_high_s16
(
p01_16
)
;
int16x4_t
p2_src
=
vget_low_s16
(
p23_16
)
;
int16x4_t
p3_src
=
vget_high_s16
(
p23_16
)
;
int32x4_t
p0
=
vmull_s16
(
p0_src
coeff0
)
;
int32x4_t
p1
=
vmull_s16
(
p1_src
coeff1
)
;
int32x4_t
p2
=
vmull_s16
(
p2_src
coeff2
)
;
int32x4_t
p3
=
vmull_s16
(
p3_src
coeff3
)
;
accum
+
=
p0
;
accum
+
=
p1
;
accum
+
=
p2
;
accum
+
=
p3
;
rowToFilter
+
=
16
;
filterValues
+
=
4
;
}
int
r
=
filterLength
&
3
;
if
(
r
)
{
int
remainder_offset
=
(
filterOffset
+
filterLength
-
r
)
*
4
;
AccumRemainder
(
srcData
+
remainder_offset
filterValues
accum
r
)
;
}
accum
=
vshrq_n_s32
(
accum
SkConvolutionFilter1D
:
:
kShiftBits
)
;
int16x4_t
accum16
=
vqmovn_s32
(
accum
)
;
uint8x8_t
accum8
=
vqmovun_s16
(
vcombine_s16
(
accum16
accum16
)
)
;
vst1_lane_u32
(
reinterpret_cast
<
uint32_t
*
>
(
outRow
)
vreinterpret_u32_u8
(
accum8
)
0
)
;
outRow
+
=
4
;
}
}
template
<
bool
hasAlpha
>
static
void
ConvolveVertically
(
const
SkConvolutionFilter1D
:
:
ConvolutionFixed
*
filterValues
int
filterLength
unsigned
char
*
const
*
sourceDataRows
int
pixelWidth
unsigned
char
*
outRow
)
{
int
width
=
pixelWidth
&
~
3
;
for
(
int
outX
=
0
;
outX
<
width
;
outX
+
=
4
)
{
int32x4_t
accum0
=
vdupq_n_s32
(
0
)
;
int32x4_t
accum1
=
vdupq_n_s32
(
0
)
;
int32x4_t
accum2
=
vdupq_n_s32
(
0
)
;
int32x4_t
accum3
=
vdupq_n_s32
(
0
)
;
for
(
int
filterY
=
0
;
filterY
<
filterLength
;
filterY
+
+
)
{
int16x4_t
coeff16
=
vdup_n_s16
(
filterValues
[
filterY
]
)
;
uint8x16_t
src8
=
vld1q_u8
(
&
sourceDataRows
[
filterY
]
[
outX
<
<
2
]
)
;
int16x8_t
src16_01
=
vreinterpretq_s16_u16
(
vmovl_u8
(
vget_low_u8
(
src8
)
)
)
;
int16x8_t
src16_23
=
vreinterpretq_s16_u16
(
vmovl_u8
(
vget_high_u8
(
src8
)
)
)
;
int16x4_t
src16_0
=
vget_low_s16
(
src16_01
)
;
int16x4_t
src16_1
=
vget_high_s16
(
src16_01
)
;
int16x4_t
src16_2
=
vget_low_s16
(
src16_23
)
;
int16x4_t
src16_3
=
vget_high_s16
(
src16_23
)
;
accum0
+
=
vmull_s16
(
src16_0
coeff16
)
;
accum1
+
=
vmull_s16
(
src16_1
coeff16
)
;
accum2
+
=
vmull_s16
(
src16_2
coeff16
)
;
accum3
+
=
vmull_s16
(
src16_3
coeff16
)
;
}
accum0
=
vshrq_n_s32
(
accum0
SkConvolutionFilter1D
:
:
kShiftBits
)
;
accum1
=
vshrq_n_s32
(
accum1
SkConvolutionFilter1D
:
:
kShiftBits
)
;
accum2
=
vshrq_n_s32
(
accum2
SkConvolutionFilter1D
:
:
kShiftBits
)
;
accum3
=
vshrq_n_s32
(
accum3
SkConvolutionFilter1D
:
:
kShiftBits
)
;
int16x8_t
accum16_0
=
vcombine_s16
(
vqmovn_s32
(
accum0
)
vqmovn_s32
(
accum1
)
)
;
int16x8_t
accum16_1
=
vcombine_s16
(
vqmovn_s32
(
accum2
)
vqmovn_s32
(
accum3
)
)
;
uint8x16_t
accum8
=
vcombine_u8
(
vqmovun_s16
(
accum16_0
)
vqmovun_s16
(
accum16_1
)
)
;
if
(
hasAlpha
)
{
uint8x16_t
a
=
vreinterpretq_u8_u32
(
vshrq_n_u32
(
vreinterpretq_u32_u8
(
accum8
)
8
)
)
;
uint8x16_t
b
=
vmaxq_u8
(
a
accum8
)
;
a
=
vreinterpretq_u8_u32
(
vshrq_n_u32
(
vreinterpretq_u32_u8
(
accum8
)
16
)
)
;
b
=
vmaxq_u8
(
a
b
)
;
b
=
vreinterpretq_u8_u32
(
vshlq_n_u32
(
vreinterpretq_u32_u8
(
b
)
24
)
)
;
accum8
=
vmaxq_u8
(
b
accum8
)
;
}
else
{
accum8
=
vreinterpretq_u8_u32
(
vreinterpretq_u32_u8
(
accum8
)
|
vdupq_n_u32
(
0xFF000000
)
)
;
}
vst1q_u8
(
outRow
accum8
)
;
outRow
+
=
16
;
}
int
r
=
pixelWidth
&
3
;
if
(
r
)
{
int32x4_t
accum0
=
vdupq_n_s32
(
0
)
;
int32x4_t
accum1
=
vdupq_n_s32
(
0
)
;
int32x4_t
accum2
=
vdupq_n_s32
(
0
)
;
for
(
int
filterY
=
0
;
filterY
<
filterLength
;
+
+
filterY
)
{
int16x4_t
coeff16
=
vdup_n_s16
(
filterValues
[
filterY
]
)
;
uint8x16_t
src8
=
vld1q_u8
(
&
sourceDataRows
[
filterY
]
[
width
<
<
2
]
)
;
int16x8_t
src16_01
=
vreinterpretq_s16_u16
(
vmovl_u8
(
vget_low_u8
(
src8
)
)
)
;
int16x8_t
src16_23
=
vreinterpretq_s16_u16
(
vmovl_u8
(
vget_high_u8
(
src8
)
)
)
;
int16x4_t
src16_0
=
vget_low_s16
(
src16_01
)
;
int16x4_t
src16_1
=
vget_high_s16
(
src16_01
)
;
int16x4_t
src16_2
=
vget_low_s16
(
src16_23
)
;
accum0
+
=
vmull_s16
(
src16_0
coeff16
)
;
accum1
+
=
vmull_s16
(
src16_1
coeff16
)
;
accum2
+
=
vmull_s16
(
src16_2
coeff16
)
;
}
accum0
=
vshrq_n_s32
(
accum0
SkConvolutionFilter1D
:
:
kShiftBits
)
;
accum1
=
vshrq_n_s32
(
accum1
SkConvolutionFilter1D
:
:
kShiftBits
)
;
accum2
=
vshrq_n_s32
(
accum2
SkConvolutionFilter1D
:
:
kShiftBits
)
;
int16x8_t
accum16_0
=
vcombine_s16
(
vqmovn_s32
(
accum0
)
vqmovn_s32
(
accum1
)
)
;
int16x8_t
accum16_1
=
vcombine_s16
(
vqmovn_s32
(
accum2
)
vqmovn_s32
(
accum2
)
)
;
uint8x16_t
accum8
=
vcombine_u8
(
vqmovun_s16
(
accum16_0
)
vqmovun_s16
(
accum16_1
)
)
;
if
(
hasAlpha
)
{
uint8x16_t
a
=
vreinterpretq_u8_u32
(
vshrq_n_u32
(
vreinterpretq_u32_u8
(
accum8
)
8
)
)
;
uint8x16_t
b
=
vmaxq_u8
(
a
accum8
)
;
a
=
vreinterpretq_u8_u32
(
vshrq_n_u32
(
vreinterpretq_u32_u8
(
accum8
)
16
)
)
;
b
=
vmaxq_u8
(
a
b
)
;
b
=
vreinterpretq_u8_u32
(
vshlq_n_u32
(
vreinterpretq_u32_u8
(
b
)
24
)
)
;
accum8
=
vmaxq_u8
(
b
accum8
)
;
}
else
{
accum8
=
vreinterpretq_u8_u32
(
vreinterpretq_u32_u8
(
accum8
)
|
vdupq_n_u32
(
0xFF000000
)
)
;
}
switch
(
r
)
{
case
1
:
vst1q_lane_u32
(
reinterpret_cast
<
uint32_t
*
>
(
outRow
)
vreinterpretq_u32_u8
(
accum8
)
0
)
;
break
;
case
2
:
vst1_u32
(
reinterpret_cast
<
uint32_t
*
>
(
outRow
)
vreinterpret_u32_u8
(
vget_low_u8
(
accum8
)
)
)
;
break
;
case
3
:
vst1_u32
(
reinterpret_cast
<
uint32_t
*
>
(
outRow
)
vreinterpret_u32_u8
(
vget_low_u8
(
accum8
)
)
)
;
vst1q_lane_u32
(
reinterpret_cast
<
uint32_t
*
>
(
outRow
+
8
)
vreinterpretq_u32_u8
(
accum8
)
2
)
;
break
;
}
}
}
void
convolve_vertically_neon
(
const
SkConvolutionFilter1D
:
:
ConvolutionFixed
*
filterValues
int
filterLength
unsigned
char
*
const
*
sourceDataRows
int
pixelWidth
unsigned
char
*
outRow
bool
hasAlpha
)
{
if
(
hasAlpha
)
{
ConvolveVertically
<
true
>
(
filterValues
filterLength
sourceDataRows
pixelWidth
outRow
)
;
}
else
{
ConvolveVertically
<
false
>
(
filterValues
filterLength
sourceDataRows
pixelWidth
outRow
)
;
}
}
}
