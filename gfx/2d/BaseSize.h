#
ifndef
MOZILLA_GFX_BASESIZE_H_
#
define
MOZILLA_GFX_BASESIZE_H_
#
include
<
algorithm
>
#
include
<
ostream
>
#
include
"
mozilla
/
Attributes
.
h
"
namespace
mozilla
:
:
gfx
{
template
<
class
T
class
Sub
class
Coord
=
T
>
struct
BaseSize
{
union
{
struct
{
T
width
height
;
}
;
T
components
[
2
]
;
}
;
constexpr
BaseSize
(
)
:
width
(
0
)
height
(
0
)
{
}
constexpr
BaseSize
(
Coord
aWidth
Coord
aHeight
)
:
width
(
aWidth
)
height
(
aHeight
)
{
}
void
SizeTo
(
T
aWidth
T
aHeight
)
{
width
=
aWidth
;
height
=
aHeight
;
}
bool
IsEmpty
(
)
const
{
return
width
<
=
0
|
|
height
<
=
0
;
}
bool
IsSquare
(
)
const
{
return
width
=
=
height
;
}
MOZ_ALWAYS_INLINE
T
Width
(
)
const
{
return
width
;
}
MOZ_ALWAYS_INLINE
T
Height
(
)
const
{
return
height
;
}
bool
operator
=
=
(
const
Sub
&
aSize
)
const
{
return
width
=
=
aSize
.
width
&
&
height
=
=
aSize
.
height
;
}
bool
operator
!
=
(
const
Sub
&
aSize
)
const
{
return
width
!
=
aSize
.
width
|
|
height
!
=
aSize
.
height
;
}
bool
operator
<
=
(
const
Sub
&
aSize
)
const
{
return
width
<
=
aSize
.
width
&
&
height
<
=
aSize
.
height
;
}
bool
operator
<
(
const
Sub
&
aSize
)
const
{
return
*
this
<
=
aSize
&
&
*
this
!
=
aSize
;
}
Sub
operator
+
(
const
Sub
&
aSize
)
const
{
return
Sub
(
width
+
aSize
.
width
height
+
aSize
.
height
)
;
}
Sub
operator
-
(
const
Sub
&
aSize
)
const
{
return
Sub
(
width
-
aSize
.
width
height
-
aSize
.
height
)
;
}
Sub
&
operator
+
=
(
const
Sub
&
aSize
)
{
width
+
=
aSize
.
width
;
height
+
=
aSize
.
height
;
return
*
static_cast
<
Sub
*
>
(
this
)
;
}
Sub
&
operator
-
=
(
const
Sub
&
aSize
)
{
width
-
=
aSize
.
width
;
height
-
=
aSize
.
height
;
return
*
static_cast
<
Sub
*
>
(
this
)
;
}
Sub
operator
*
(
T
aScale
)
const
{
return
Sub
(
width
*
aScale
height
*
aScale
)
;
}
Sub
operator
/
(
T
aScale
)
const
{
return
Sub
(
width
/
aScale
height
/
aScale
)
;
}
friend
Sub
operator
*
(
T
aScale
const
Sub
&
aSize
)
{
return
Sub
(
aScale
*
aSize
.
width
aScale
*
aSize
.
height
)
;
}
void
Scale
(
T
aXScale
T
aYScale
)
{
width
*
=
aXScale
;
height
*
=
aYScale
;
}
Sub
operator
*
(
const
Sub
&
aSize
)
const
{
return
Sub
(
width
*
aSize
.
width
height
*
aSize
.
height
)
;
}
Sub
operator
/
(
const
Sub
&
aSize
)
const
{
return
Sub
(
width
/
aSize
.
width
height
/
aSize
.
height
)
;
}
friend
Sub
Min
(
const
Sub
&
aA
const
Sub
&
aB
)
{
return
Sub
(
std
:
:
min
(
aA
.
width
aB
.
width
)
std
:
:
min
(
aA
.
height
aB
.
height
)
)
;
}
friend
Sub
Max
(
const
Sub
&
aA
const
Sub
&
aB
)
{
return
Sub
(
std
:
:
max
(
aA
.
width
aB
.
width
)
std
:
:
max
(
aA
.
height
aB
.
height
)
)
;
}
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
BaseSize
<
T
Sub
Coord
>
&
aSize
)
{
return
aStream
<
<
'
(
'
<
<
aSize
.
width
<
<
"
x
"
<
<
aSize
.
height
<
<
'
)
'
;
}
}
;
}
#
endif
