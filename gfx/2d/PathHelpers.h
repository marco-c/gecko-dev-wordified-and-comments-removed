#
ifndef
MOZILLA_GFX_PATHHELPERS_H_
#
define
MOZILLA_GFX_PATHHELPERS_H_
#
include
"
2D
.
h
"
#
include
"
mozilla
/
Constants
.
h
"
#
include
"
UserData
.
h
"
namespace
mozilla
{
namespace
gfx
{
const
Float
kKappaFactor
=
0
.
55191497064665766025f
;
inline
Float
ComputeKappaFactor
(
Float
aAngle
)
{
return
(
4
.
0f
/
3
.
0f
)
*
tanf
(
aAngle
/
4
.
0f
)
;
}
template
<
typename
T
>
inline
void
PartialArcToBezier
(
T
*
aSink
const
Size
&
aRadius
const
Point
&
aStartPoint
const
Point
&
aEndPoint
const
Point
&
aStartOffset
const
Point
&
aEndOffset
Float
aKappaFactor
=
kKappaFactor
)
{
Float
kappaX
=
aKappaFactor
*
aRadius
.
width
;
Float
kappaY
=
aKappaFactor
*
aRadius
.
height
;
Point
cp1
=
aStartPoint
+
Point
(
-
aStartOffset
.
y
*
kappaX
aStartOffset
.
x
*
kappaY
)
;
Point
cp2
=
aEndPoint
+
Point
(
aEndOffset
.
y
*
kappaX
-
aEndOffset
.
x
*
kappaY
)
;
aSink
-
>
BezierTo
(
cp1
cp2
aEndPoint
)
;
}
template
<
typename
T
>
inline
void
AcuteArcToBezier
(
T
*
aSink
const
Point
&
aOrigin
const
Size
&
aRadius
const
Point
&
aStartPoint
const
Point
&
aEndPoint
Float
aKappaFactor
=
kKappaFactor
)
{
aSink
-
>
LineTo
(
aStartPoint
)
;
if
(
!
aRadius
.
IsEmpty
(
)
)
{
Point
startOffset
=
aStartPoint
-
aOrigin
;
startOffset
.
x
/
=
aRadius
.
width
;
startOffset
.
y
/
=
aRadius
.
height
;
Point
endOffset
=
aEndPoint
-
aOrigin
;
endOffset
.
x
/
=
aRadius
.
width
;
endOffset
.
y
/
=
aRadius
.
height
;
PartialArcToBezier
(
aSink
aRadius
aStartPoint
aEndPoint
startOffset
endOffset
aKappaFactor
)
;
}
else
if
(
aEndPoint
!
=
aStartPoint
)
{
aSink
-
>
LineTo
(
aEndPoint
)
;
}
}
template
<
typename
T
>
inline
void
AcuteArcToBezier
(
T
*
aSink
const
Point
&
aOrigin
const
Size
&
aRadius
const
Point
&
aStartPoint
const
Point
&
aEndPoint
Float
aStartAngle
Float
aEndAngle
)
{
AcuteArcToBezier
(
aSink
aOrigin
aRadius
aStartPoint
aEndPoint
ComputeKappaFactor
(
aEndAngle
-
aStartAngle
)
)
;
}
template
<
typename
T
>
void
ArcToBezier
(
T
*
aSink
const
Point
&
aOrigin
const
Size
&
aRadius
float
aStartAngle
float
aEndAngle
bool
aAntiClockwise
)
{
Float
sweepDirection
=
aAntiClockwise
?
-
1
.
0f
:
1
.
0f
;
Float
arcSweepLeft
=
(
aEndAngle
-
aStartAngle
)
*
sweepDirection
;
if
(
arcSweepLeft
<
0
)
{
arcSweepLeft
=
Float
(
2
.
0f
*
M_PI
)
+
fmodf
(
arcSweepLeft
Float
(
2
.
0f
*
M_PI
)
)
;
aStartAngle
=
aEndAngle
-
arcSweepLeft
*
sweepDirection
;
}
else
if
(
arcSweepLeft
>
Float
(
2
.
0f
*
M_PI
)
)
{
arcSweepLeft
=
Float
(
2
.
0f
*
M_PI
)
;
}
Float
currentStartAngle
=
aStartAngle
;
Point
currentStartOffset
(
cosf
(
aStartAngle
)
sinf
(
aStartAngle
)
)
;
Point
currentStartPoint
(
aOrigin
.
x
+
currentStartOffset
.
x
*
aRadius
.
width
aOrigin
.
y
+
currentStartOffset
.
y
*
aRadius
.
height
)
;
aSink
-
>
LineTo
(
currentStartPoint
)
;
while
(
arcSweepLeft
>
0
)
{
Float
currentEndAngle
=
currentStartAngle
+
std
:
:
min
(
arcSweepLeft
Float
(
M_PI
/
2
.
0f
)
)
*
sweepDirection
;
Point
currentEndOffset
(
cosf
(
currentEndAngle
)
sinf
(
currentEndAngle
)
)
;
Point
currentEndPoint
(
aOrigin
.
x
+
currentEndOffset
.
x
*
aRadius
.
width
aOrigin
.
y
+
currentEndOffset
.
y
*
aRadius
.
height
)
;
PartialArcToBezier
(
aSink
aRadius
currentStartPoint
currentEndPoint
currentStartOffset
currentEndOffset
ComputeKappaFactor
(
currentEndAngle
-
currentStartAngle
)
)
;
arcSweepLeft
-
=
Float
(
M_PI
/
2
.
0f
)
;
currentStartAngle
=
currentEndAngle
;
currentStartOffset
=
currentEndOffset
;
currentStartPoint
=
currentEndPoint
;
}
}
template
<
typename
T
>
void
EllipseToBezier
(
T
*
aSink
const
Point
&
aOrigin
const
Size
&
aRadius
)
{
Point
currentStartOffset
(
1
0
)
;
Point
currentStartPoint
(
aOrigin
.
x
+
aRadius
.
width
aOrigin
.
y
)
;
aSink
-
>
LineTo
(
currentStartPoint
)
;
for
(
int
i
=
0
;
i
<
4
;
i
+
+
)
{
Point
currentEndOffset
(
-
currentStartOffset
.
y
currentStartOffset
.
x
)
;
Point
currentEndPoint
(
aOrigin
.
x
+
currentEndOffset
.
x
*
aRadius
.
width
aOrigin
.
y
+
currentEndOffset
.
y
*
aRadius
.
height
)
;
PartialArcToBezier
(
aSink
aRadius
currentStartPoint
currentEndPoint
currentStartOffset
currentEndOffset
)
;
currentStartOffset
=
currentEndOffset
;
currentStartPoint
=
currentEndPoint
;
}
}
GFX2D_API
void
AppendRectToPath
(
PathBuilder
*
aPathBuilder
const
Rect
&
aRect
bool
aDrawClockwise
=
true
)
;
inline
already_AddRefed
<
Path
>
MakePathForRect
(
const
DrawTarget
&
aDrawTarget
const
Rect
&
aRect
bool
aDrawClockwise
=
true
)
{
RefPtr
<
PathBuilder
>
builder
=
aDrawTarget
.
CreatePathBuilder
(
)
;
AppendRectToPath
(
builder
aRect
aDrawClockwise
)
;
return
builder
-
>
Finish
(
)
;
}
struct
RectCornerRadii
{
Size
radii
[
RectCorner
:
:
Count
]
;
RectCornerRadii
(
)
{
}
explicit
RectCornerRadii
(
Float
radius
)
{
for
(
int
i
=
0
;
i
<
RectCorner
:
:
Count
;
i
+
+
)
{
radii
[
i
]
.
SizeTo
(
radius
radius
)
;
}
}
explicit
RectCornerRadii
(
Float
radiusX
Float
radiusY
)
{
for
(
int
i
=
0
;
i
<
RectCorner
:
:
Count
;
i
+
+
)
{
radii
[
i
]
.
SizeTo
(
radiusX
radiusY
)
;
}
}
RectCornerRadii
(
Float
tl
Float
tr
Float
br
Float
bl
)
{
radii
[
RectCorner
:
:
TopLeft
]
.
SizeTo
(
tl
tl
)
;
radii
[
RectCorner
:
:
TopRight
]
.
SizeTo
(
tr
tr
)
;
radii
[
RectCorner
:
:
BottomRight
]
.
SizeTo
(
br
br
)
;
radii
[
RectCorner
:
:
BottomLeft
]
.
SizeTo
(
bl
bl
)
;
}
RectCornerRadii
(
const
Size
&
tl
const
Size
&
tr
const
Size
&
br
const
Size
&
bl
)
{
radii
[
RectCorner
:
:
TopLeft
]
=
tl
;
radii
[
RectCorner
:
:
TopRight
]
=
tr
;
radii
[
RectCorner
:
:
BottomRight
]
=
br
;
radii
[
RectCorner
:
:
BottomLeft
]
=
bl
;
}
const
Size
&
operator
[
]
(
size_t
aCorner
)
const
{
return
radii
[
aCorner
]
;
}
Size
&
operator
[
]
(
size_t
aCorner
)
{
return
radii
[
aCorner
]
;
}
bool
operator
=
=
(
const
RectCornerRadii
&
aOther
)
const
{
for
(
size_t
i
=
0
;
i
<
RectCorner
:
:
Count
;
i
+
+
)
{
if
(
radii
[
i
]
!
=
aOther
.
radii
[
i
]
)
return
false
;
}
return
true
;
}
void
Scale
(
Float
aXScale
Float
aYScale
)
{
for
(
int
i
=
0
;
i
<
RectCorner
:
:
Count
;
i
+
+
)
{
radii
[
i
]
.
Scale
(
aXScale
aYScale
)
;
}
}
const
Size
TopLeft
(
)
const
{
return
radii
[
RectCorner
:
:
TopLeft
]
;
}
Size
&
TopLeft
(
)
{
return
radii
[
RectCorner
:
:
TopLeft
]
;
}
const
Size
TopRight
(
)
const
{
return
radii
[
RectCorner
:
:
TopRight
]
;
}
Size
&
TopRight
(
)
{
return
radii
[
RectCorner
:
:
TopRight
]
;
}
const
Size
BottomRight
(
)
const
{
return
radii
[
RectCorner
:
:
BottomRight
]
;
}
Size
&
BottomRight
(
)
{
return
radii
[
RectCorner
:
:
BottomRight
]
;
}
const
Size
BottomLeft
(
)
const
{
return
radii
[
RectCorner
:
:
BottomLeft
]
;
}
Size
&
BottomLeft
(
)
{
return
radii
[
RectCorner
:
:
BottomLeft
]
;
}
}
;
GFX2D_API
void
AppendRoundedRectToPath
(
PathBuilder
*
aPathBuilder
const
Rect
&
aRect
const
RectCornerRadii
&
aRadii
bool
aDrawClockwise
=
true
)
;
inline
already_AddRefed
<
Path
>
MakePathForRoundedRect
(
const
DrawTarget
&
aDrawTarget
const
Rect
&
aRect
const
RectCornerRadii
&
aRadii
bool
aDrawClockwise
=
true
)
{
RefPtr
<
PathBuilder
>
builder
=
aDrawTarget
.
CreatePathBuilder
(
)
;
AppendRoundedRectToPath
(
builder
aRect
aRadii
aDrawClockwise
)
;
return
builder
-
>
Finish
(
)
;
}
GFX2D_API
void
AppendEllipseToPath
(
PathBuilder
*
aPathBuilder
const
Point
&
aCenter
const
Size
&
aDimensions
)
;
inline
already_AddRefed
<
Path
>
MakePathForEllipse
(
const
DrawTarget
&
aDrawTarget
const
Point
&
aCenter
const
Size
&
aDimensions
)
{
RefPtr
<
PathBuilder
>
builder
=
aDrawTarget
.
CreatePathBuilder
(
)
;
AppendEllipseToPath
(
builder
aCenter
aDimensions
)
;
return
builder
-
>
Finish
(
)
;
}
GFX2D_API
bool
SnapLineToDevicePixelsForStroking
(
Point
&
aP1
Point
&
aP2
const
DrawTarget
&
aDrawTarget
Float
aLineWidth
)
;
GFX2D_API
void
StrokeSnappedEdgesOfRect
(
const
Rect
&
aRect
DrawTarget
&
aDrawTarget
const
ColorPattern
&
aColor
const
StrokeOptions
&
aStrokeOptions
)
;
GFX2D_API
Margin
MaxStrokeExtents
(
const
StrokeOptions
&
aStrokeOptions
const
Matrix
&
aTransform
)
;
extern
UserDataKey
sDisablePixelSnapping
;
inline
bool
UserToDevicePixelSnapped
(
Rect
&
aRect
const
DrawTarget
&
aDrawTarget
bool
aAllowScaleOr90DegreeRotate
=
false
bool
aAllowEmptySnaps
=
true
)
{
if
(
aDrawTarget
.
GetUserData
(
&
sDisablePixelSnapping
)
)
{
return
false
;
}
Matrix
mat
=
aDrawTarget
.
GetTransform
(
)
;
const
Float
epsilon
=
0
.
0000001f
;
#
define
WITHIN_E
(
a
b
)
(
fabs
(
(
a
)
-
(
b
)
)
<
epsilon
)
if
(
!
aAllowScaleOr90DegreeRotate
&
&
(
!
WITHIN_E
(
mat
.
_11
1
.
f
)
|
|
!
WITHIN_E
(
mat
.
_22
1
.
f
)
|
|
!
WITHIN_E
(
mat
.
_12
0
.
f
)
|
|
!
WITHIN_E
(
mat
.
_21
0
.
f
)
)
)
{
return
false
;
}
#
undef
WITHIN_E
Point
p1
=
mat
*
aRect
.
TopLeft
(
)
;
Point
p2
=
mat
*
aRect
.
TopRight
(
)
;
Point
p3
=
mat
*
aRect
.
BottomRight
(
)
;
if
(
p2
=
=
Point
(
p1
.
x
p3
.
y
)
|
|
p2
=
=
Point
(
p3
.
x
p1
.
y
)
)
{
Point
p1r
=
p1
;
Point
p3r
=
p3
;
p1r
.
Round
(
)
;
p3r
.
Round
(
)
;
if
(
aAllowEmptySnaps
|
|
p1r
.
x
!
=
p3r
.
x
)
{
p1
.
x
=
p1r
.
x
;
p3
.
x
=
p3r
.
x
;
}
if
(
aAllowEmptySnaps
|
|
p1r
.
y
!
=
p3r
.
y
)
{
p1
.
y
=
p1r
.
y
;
p3
.
y
=
p3r
.
y
;
}
aRect
.
MoveTo
(
Point
(
std
:
:
min
(
p1
.
x
p3
.
x
)
std
:
:
min
(
p1
.
y
p3
.
y
)
)
)
;
aRect
.
SizeTo
(
Size
(
std
:
:
max
(
p1
.
x
p3
.
x
)
-
aRect
.
X
(
)
std
:
:
max
(
p1
.
y
p3
.
y
)
-
aRect
.
Y
(
)
)
)
;
return
true
;
}
return
false
;
}
inline
bool
MaybeSnapToDevicePixels
(
Rect
&
aRect
const
DrawTarget
&
aDrawTarget
bool
aAllowScaleOr90DegreeRotate
=
false
bool
aAllowEmptySnaps
=
true
)
{
if
(
UserToDevicePixelSnapped
(
aRect
aDrawTarget
aAllowScaleOr90DegreeRotate
aAllowEmptySnaps
)
)
{
Matrix
mat
=
aDrawTarget
.
GetTransform
(
)
;
mat
.
Invert
(
)
;
aRect
=
mat
.
TransformBounds
(
aRect
)
;
return
true
;
}
return
false
;
}
}
}
#
endif
