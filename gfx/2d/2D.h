#
ifndef
_MOZILLA_GFX_2D_H
#
define
_MOZILLA_GFX_2D_H
#
include
"
Types
.
h
"
#
include
"
Point
.
h
"
#
include
"
Rect
.
h
"
#
include
"
Matrix
.
h
"
#
include
"
Quaternion
.
h
"
#
include
"
UserData
.
h
"
#
include
<
vector
>
#
include
"
mozilla
/
GenericRefCounted
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
ifdef
MOZ_ENABLE_FREETYPE
#
include
<
string
>
#
endif
#
include
"
gfxPrefs
.
h
"
struct
_cairo_surface
;
typedef
_cairo_surface
cairo_surface_t
;
struct
_cairo_scaled_font
;
typedef
_cairo_scaled_font
cairo_scaled_font_t
;
struct
_FcPattern
;
typedef
_FcPattern
FcPattern
;
struct
ID3D11Texture2D
;
struct
ID3D11Device
;
struct
ID2D1Device
;
struct
IDWriteRenderingParams
;
struct
IDWriteFontFace
;
class
GrContext
;
class
SkCanvas
;
struct
gfxFontStyle
;
struct
CGContext
;
typedef
struct
CGContext
*
CGContextRef
;
namespace
mozilla
{
namespace
gfx
{
class
SourceSurface
;
class
DataSourceSurface
;
class
DrawTarget
;
class
DrawEventRecorder
;
class
FilterNode
;
class
LogForwarder
;
struct
NativeSurface
{
NativeSurfaceType
mType
;
SurfaceFormat
mFormat
;
gfx
:
:
IntSize
mSize
;
void
*
mSurface
;
}
;
struct
NativeFont
{
NativeFontType
mType
;
void
*
mFont
;
}
;
struct
DrawOptions
{
explicit
DrawOptions
(
Float
aAlpha
=
1
.
0f
CompositionOp
aCompositionOp
=
CompositionOp
:
:
OP_OVER
AntialiasMode
aAntialiasMode
=
AntialiasMode
:
:
DEFAULT
)
:
mAlpha
(
aAlpha
)
mCompositionOp
(
aCompositionOp
)
mAntialiasMode
(
aAntialiasMode
)
{
}
Float
mAlpha
;
CompositionOp
mCompositionOp
;
AntialiasMode
mAntialiasMode
;
}
;
struct
StrokeOptions
{
explicit
StrokeOptions
(
Float
aLineWidth
=
1
.
0f
JoinStyle
aLineJoin
=
JoinStyle
:
:
MITER_OR_BEVEL
CapStyle
aLineCap
=
CapStyle
:
:
BUTT
Float
aMiterLimit
=
10
.
0f
size_t
aDashLength
=
0
const
Float
*
aDashPattern
=
0
Float
aDashOffset
=
0
.
f
)
:
mLineWidth
(
aLineWidth
)
mMiterLimit
(
aMiterLimit
)
mDashPattern
(
aDashLength
>
0
?
aDashPattern
:
0
)
mDashLength
(
aDashLength
)
mDashOffset
(
aDashOffset
)
mLineJoin
(
aLineJoin
)
mLineCap
(
aLineCap
)
{
MOZ_ASSERT
(
aDashLength
=
=
0
|
|
aDashPattern
)
;
}
Float
mLineWidth
;
Float
mMiterLimit
;
const
Float
*
mDashPattern
;
size_t
mDashLength
;
Float
mDashOffset
;
JoinStyle
mLineJoin
;
CapStyle
mLineCap
;
}
;
struct
DrawSurfaceOptions
{
explicit
DrawSurfaceOptions
(
SamplingFilter
aSamplingFilter
=
SamplingFilter
:
:
LINEAR
SamplingBounds
aSamplingBounds
=
SamplingBounds
:
:
UNBOUNDED
)
:
mSamplingFilter
(
aSamplingFilter
)
mSamplingBounds
(
aSamplingBounds
)
{
}
SamplingFilter
mSamplingFilter
;
SamplingBounds
mSamplingBounds
;
}
;
class
GradientStops
:
public
RefCounted
<
GradientStops
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
GradientStops
)
virtual
~
GradientStops
(
)
{
}
virtual
BackendType
GetBackendType
(
)
const
=
0
;
virtual
bool
IsValid
(
)
const
{
return
true
;
}
protected
:
GradientStops
(
)
{
}
}
;
class
Pattern
{
public
:
virtual
~
Pattern
(
)
{
}
virtual
PatternType
GetType
(
)
const
=
0
;
protected
:
Pattern
(
)
{
}
}
;
class
ColorPattern
:
public
Pattern
{
public
:
explicit
ColorPattern
(
const
Color
&
aColor
)
:
mColor
(
aColor
)
{
}
virtual
PatternType
GetType
(
)
const
override
{
return
PatternType
:
:
COLOR
;
}
Color
mColor
;
}
;
class
LinearGradientPattern
:
public
Pattern
{
public
:
LinearGradientPattern
(
const
Point
&
aBegin
const
Point
&
aEnd
GradientStops
*
aStops
const
Matrix
&
aMatrix
=
Matrix
(
)
)
:
mBegin
(
aBegin
)
mEnd
(
aEnd
)
mStops
(
aStops
)
mMatrix
(
aMatrix
)
{
}
virtual
PatternType
GetType
(
)
const
override
{
return
PatternType
:
:
LINEAR_GRADIENT
;
}
Point
mBegin
;
Point
mEnd
;
RefPtr
<
GradientStops
>
mStops
;
Matrix
mMatrix
;
}
;
class
RadialGradientPattern
:
public
Pattern
{
public
:
RadialGradientPattern
(
const
Point
&
aCenter1
const
Point
&
aCenter2
Float
aRadius1
Float
aRadius2
GradientStops
*
aStops
const
Matrix
&
aMatrix
=
Matrix
(
)
)
:
mCenter1
(
aCenter1
)
mCenter2
(
aCenter2
)
mRadius1
(
aRadius1
)
mRadius2
(
aRadius2
)
mStops
(
aStops
)
mMatrix
(
aMatrix
)
{
}
virtual
PatternType
GetType
(
)
const
override
{
return
PatternType
:
:
RADIAL_GRADIENT
;
}
Point
mCenter1
;
Point
mCenter2
;
Float
mRadius1
;
Float
mRadius2
;
RefPtr
<
GradientStops
>
mStops
;
Matrix
mMatrix
;
}
;
class
SurfacePattern
:
public
Pattern
{
public
:
SurfacePattern
(
SourceSurface
*
aSourceSurface
ExtendMode
aExtendMode
const
Matrix
&
aMatrix
=
Matrix
(
)
SamplingFilter
aSamplingFilter
=
SamplingFilter
:
:
GOOD
const
IntRect
&
aSamplingRect
=
IntRect
(
)
)
:
mSurface
(
aSourceSurface
)
mExtendMode
(
aExtendMode
)
mSamplingFilter
(
aSamplingFilter
)
mMatrix
(
aMatrix
)
mSamplingRect
(
aSamplingRect
)
{
}
virtual
PatternType
GetType
(
)
const
override
{
return
PatternType
:
:
SURFACE
;
}
RefPtr
<
SourceSurface
>
mSurface
;
ExtendMode
mExtendMode
;
SamplingFilter
mSamplingFilter
;
Matrix
mMatrix
;
IntRect
mSamplingRect
;
}
;
class
StoredPattern
;
class
DrawTargetCaptureImpl
;
class
SourceSurface
:
public
external
:
:
AtomicRefCounted
<
SourceSurface
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
SourceSurface
)
virtual
~
SourceSurface
(
)
{
}
virtual
SurfaceType
GetType
(
)
const
=
0
;
virtual
IntSize
GetSize
(
)
const
=
0
;
virtual
SurfaceFormat
GetFormat
(
)
const
=
0
;
virtual
bool
IsValid
(
)
const
{
return
true
;
}
virtual
already_AddRefed
<
DataSourceSurface
>
GetDataSurface
(
)
=
0
;
virtual
void
*
GetNativeSurface
(
NativeSurfaceType
aType
)
{
return
nullptr
;
}
void
AddUserData
(
UserDataKey
*
key
void
*
userData
void
(
*
destroy
)
(
void
*
)
)
{
mUserData
.
Add
(
key
userData
destroy
)
;
}
void
*
GetUserData
(
UserDataKey
*
key
)
{
return
mUserData
.
Get
(
key
)
;
}
protected
:
friend
class
DrawTargetCaptureImpl
;
friend
class
StoredPattern
;
virtual
void
GuaranteePersistance
(
)
{
}
UserData
mUserData
;
}
;
class
DataSourceSurface
:
public
SourceSurface
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
DataSourceSurface
override
)
DataSourceSurface
(
)
:
mIsMapped
(
false
)
{
}
#
ifdef
DEBUG
virtual
~
DataSourceSurface
(
)
{
MOZ_ASSERT
(
!
mIsMapped
"
Someone
forgot
to
call
Unmap
(
)
"
)
;
}
#
endif
struct
MappedSurface
{
uint8_t
*
mData
;
int32_t
mStride
;
}
;
enum
MapType
{
READ
WRITE
READ_WRITE
}
;
class
ScopedMap
{
public
:
explicit
ScopedMap
(
DataSourceSurface
*
aSurface
MapType
aType
)
:
mSurface
(
aSurface
)
mIsMapped
(
aSurface
-
>
Map
(
aType
&
mMap
)
)
{
}
virtual
~
ScopedMap
(
)
{
if
(
mIsMapped
)
{
mSurface
-
>
Unmap
(
)
;
}
}
uint8_t
*
GetData
(
)
const
{
MOZ_ASSERT
(
mIsMapped
)
;
return
mMap
.
mData
;
}
int32_t
GetStride
(
)
const
{
MOZ_ASSERT
(
mIsMapped
)
;
return
mMap
.
mStride
;
}
const
MappedSurface
*
GetMappedSurface
(
)
const
{
MOZ_ASSERT
(
mIsMapped
)
;
return
&
mMap
;
}
bool
IsMapped
(
)
const
{
return
mIsMapped
;
}
private
:
RefPtr
<
DataSourceSurface
>
mSurface
;
MappedSurface
mMap
;
bool
mIsMapped
;
}
;
virtual
SurfaceType
GetType
(
)
const
override
{
return
SurfaceType
:
:
DATA
;
}
virtual
uint8_t
*
GetData
(
)
=
0
;
virtual
int32_t
Stride
(
)
=
0
;
virtual
bool
Map
(
MapType
MappedSurface
*
aMappedSurface
)
{
aMappedSurface
-
>
mData
=
GetData
(
)
;
aMappedSurface
-
>
mStride
=
Stride
(
)
;
mIsMapped
=
!
!
aMappedSurface
-
>
mData
;
return
mIsMapped
;
}
virtual
void
Unmap
(
)
{
MOZ_ASSERT
(
mIsMapped
)
;
mIsMapped
=
false
;
}
virtual
already_AddRefed
<
DataSourceSurface
>
GetDataSurface
(
)
override
;
protected
:
bool
mIsMapped
;
}
;
class
PathSink
:
public
RefCounted
<
PathSink
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
PathSink
)
virtual
~
PathSink
(
)
{
}
virtual
void
MoveTo
(
const
Point
&
aPoint
)
=
0
;
virtual
void
LineTo
(
const
Point
&
aPoint
)
=
0
;
virtual
void
BezierTo
(
const
Point
&
aCP1
const
Point
&
aCP2
const
Point
&
aCP3
)
=
0
;
virtual
void
QuadraticBezierTo
(
const
Point
&
aCP1
const
Point
&
aCP2
)
=
0
;
virtual
void
Close
(
)
=
0
;
virtual
void
Arc
(
const
Point
&
aOrigin
float
aRadius
float
aStartAngle
float
aEndAngle
bool
aAntiClockwise
=
false
)
=
0
;
virtual
Point
CurrentPoint
(
)
const
=
0
;
}
;
class
PathBuilder
;
class
FlattenedPath
;
class
Path
:
public
RefCounted
<
Path
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
Path
)
virtual
~
Path
(
)
;
virtual
BackendType
GetBackendType
(
)
const
=
0
;
inline
already_AddRefed
<
PathBuilder
>
CopyToBuilder
(
)
const
{
return
CopyToBuilder
(
GetFillRule
(
)
)
;
}
inline
already_AddRefed
<
PathBuilder
>
TransformedCopyToBuilder
(
const
Matrix
&
aTransform
)
const
{
return
TransformedCopyToBuilder
(
aTransform
GetFillRule
(
)
)
;
}
virtual
already_AddRefed
<
PathBuilder
>
CopyToBuilder
(
FillRule
aFillRule
)
const
=
0
;
virtual
already_AddRefed
<
PathBuilder
>
TransformedCopyToBuilder
(
const
Matrix
&
aTransform
FillRule
aFillRule
)
const
=
0
;
virtual
bool
ContainsPoint
(
const
Point
&
aPoint
const
Matrix
&
aTransform
)
const
=
0
;
virtual
bool
StrokeContainsPoint
(
const
StrokeOptions
&
aStrokeOptions
const
Point
&
aPoint
const
Matrix
&
aTransform
)
const
=
0
;
virtual
Rect
GetBounds
(
const
Matrix
&
aTransform
=
Matrix
(
)
)
const
=
0
;
virtual
Rect
GetStrokedBounds
(
const
StrokeOptions
&
aStrokeOptions
const
Matrix
&
aTransform
=
Matrix
(
)
)
const
=
0
;
virtual
void
StreamToSink
(
PathSink
*
aSink
)
const
=
0
;
virtual
FillRule
GetFillRule
(
)
const
=
0
;
virtual
Float
ComputeLength
(
)
;
virtual
Point
ComputePointAtLength
(
Float
aLength
Point
*
aTangent
=
nullptr
)
;
protected
:
Path
(
)
;
void
EnsureFlattenedPath
(
)
;
RefPtr
<
FlattenedPath
>
mFlattenedPath
;
}
;
class
PathBuilder
:
public
PathSink
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
PathBuilder
)
virtual
already_AddRefed
<
Path
>
Finish
(
)
=
0
;
virtual
BackendType
GetBackendType
(
)
const
=
0
;
}
;
struct
Glyph
{
uint32_t
mIndex
;
Point
mPosition
;
}
;
static
inline
bool
operator
=
=
(
const
Glyph
&
aOne
const
Glyph
&
aOther
)
{
return
aOne
.
mIndex
=
=
aOther
.
mIndex
&
&
aOne
.
mPosition
=
=
aOther
.
mPosition
;
}
struct
GlyphBuffer
{
const
Glyph
*
mGlyphs
;
uint32_t
mNumGlyphs
;
}
;
struct
GlyphMetrics
{
Float
mXBearing
;
Float
mXAdvance
;
Float
mYBearing
;
Float
mYAdvance
;
Float
mWidth
;
Float
mHeight
;
}
;
class
ScaledFont
:
public
external
:
:
AtomicRefCounted
<
ScaledFont
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
ScaledFont
)
virtual
~
ScaledFont
(
)
{
}
typedef
void
(
*
FontFileDataOutput
)
(
const
uint8_t
*
aData
uint32_t
aLength
uint32_t
aIndex
Float
aGlyphSize
void
*
aBaton
)
;
typedef
void
(
*
FontDescriptorOutput
)
(
const
uint8_t
*
aData
uint32_t
aLength
Float
aFontSize
void
*
aBaton
)
;
virtual
FontType
GetType
(
)
const
=
0
;
virtual
AntialiasMode
GetDefaultAAMode
(
)
{
if
(
gfxPrefs
:
:
DisableAllTextAA
(
)
)
{
return
AntialiasMode
:
:
NONE
;
}
return
AntialiasMode
:
:
DEFAULT
;
}
virtual
already_AddRefed
<
Path
>
GetPathForGlyphs
(
const
GlyphBuffer
&
aBuffer
const
DrawTarget
*
aTarget
)
=
0
;
virtual
void
CopyGlyphsToBuilder
(
const
GlyphBuffer
&
aBuffer
PathBuilder
*
aBuilder
const
Matrix
*
aTransformHint
=
nullptr
)
=
0
;
virtual
void
GetGlyphDesignMetrics
(
const
uint16_t
*
aGlyphIndices
uint32_t
aNumGlyphs
GlyphMetrics
*
aGlyphMetrics
)
=
0
;
virtual
bool
GetFontFileData
(
FontFileDataOutput
void
*
)
{
return
false
;
}
virtual
bool
GetFontDescriptor
(
FontDescriptorOutput
void
*
)
{
return
false
;
}
void
AddUserData
(
UserDataKey
*
key
void
*
userData
void
(
*
destroy
)
(
void
*
)
)
{
mUserData
.
Add
(
key
userData
destroy
)
;
}
void
*
GetUserData
(
UserDataKey
*
key
)
{
return
mUserData
.
Get
(
key
)
;
}
protected
:
ScaledFont
(
)
{
}
UserData
mUserData
;
}
;
class
NativeFontResource
:
public
RefCounted
<
NativeFontResource
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
NativeFontResource
)
virtual
already_AddRefed
<
ScaledFont
>
CreateScaledFont
(
uint32_t
aIndex
uint32_t
aGlyphSize
)
=
0
;
virtual
~
NativeFontResource
(
)
{
}
;
}
;
class
GlyphRenderingOptions
:
public
RefCounted
<
GlyphRenderingOptions
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
GlyphRenderingOptions
)
virtual
~
GlyphRenderingOptions
(
)
{
}
virtual
FontType
GetType
(
)
const
=
0
;
protected
:
GlyphRenderingOptions
(
)
{
}
}
;
class
DrawTargetCapture
;
class
DrawTarget
:
public
RefCounted
<
DrawTarget
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
DrawTarget
)
DrawTarget
(
)
:
mTransformDirty
(
false
)
mPermitSubpixelAA
(
false
)
{
}
virtual
~
DrawTarget
(
)
{
}
virtual
bool
IsValid
(
)
const
{
return
true
;
}
;
virtual
DrawTargetType
GetType
(
)
const
=
0
;
virtual
BackendType
GetBackendType
(
)
const
=
0
;
virtual
bool
IsRecording
(
)
const
{
return
false
;
}
virtual
bool
IsCaptureDT
(
)
const
{
return
false
;
}
virtual
already_AddRefed
<
SourceSurface
>
Snapshot
(
)
=
0
;
virtual
IntSize
GetSize
(
)
=
0
;
virtual
bool
LockBits
(
uint8_t
*
*
aData
IntSize
*
aSize
int32_t
*
aStride
SurfaceFormat
*
aFormat
IntPoint
*
aOrigin
=
nullptr
)
{
return
false
;
}
virtual
void
ReleaseBits
(
uint8_t
*
aData
)
{
}
virtual
void
Flush
(
)
=
0
;
virtual
void
DrawCapturedDT
(
DrawTargetCapture
*
aCaptureDT
const
Matrix
&
aTransform
)
;
virtual
void
DrawSurface
(
SourceSurface
*
aSurface
const
Rect
&
aDest
const
Rect
&
aSource
const
DrawSurfaceOptions
&
aSurfOptions
=
DrawSurfaceOptions
(
)
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
=
0
;
virtual
void
DrawFilter
(
FilterNode
*
aNode
const
Rect
&
aSourceRect
const
Point
&
aDestPoint
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
=
0
;
virtual
void
DrawSurfaceWithShadow
(
SourceSurface
*
aSurface
const
Point
&
aDest
const
Color
&
aColor
const
Point
&
aOffset
Float
aSigma
CompositionOp
aOperator
)
=
0
;
virtual
void
ClearRect
(
const
Rect
&
aRect
)
=
0
;
virtual
void
CopySurface
(
SourceSurface
*
aSurface
const
IntRect
&
aSourceRect
const
IntPoint
&
aDestination
)
=
0
;
virtual
void
CopyRect
(
const
IntRect
&
aSourceRect
const
IntPoint
&
aDestination
)
{
RefPtr
<
SourceSurface
>
source
=
Snapshot
(
)
;
CopySurface
(
source
aSourceRect
aDestination
)
;
}
virtual
void
FillRect
(
const
Rect
&
aRect
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
=
0
;
virtual
void
StrokeRect
(
const
Rect
&
aRect
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
=
StrokeOptions
(
)
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
=
0
;
virtual
void
StrokeLine
(
const
Point
&
aStart
const
Point
&
aEnd
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
=
StrokeOptions
(
)
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
=
0
;
virtual
void
Stroke
(
const
Path
*
aPath
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
=
StrokeOptions
(
)
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
=
0
;
virtual
void
Fill
(
const
Path
*
aPath
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
=
0
;
virtual
void
FillGlyphs
(
ScaledFont
*
aFont
const
GlyphBuffer
&
aBuffer
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
const
GlyphRenderingOptions
*
aRenderingOptions
=
nullptr
)
=
0
;
virtual
void
Mask
(
const
Pattern
&
aSource
const
Pattern
&
aMask
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
=
0
;
virtual
void
MaskSurface
(
const
Pattern
&
aSource
SourceSurface
*
aMask
Point
aOffset
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
=
0
;
virtual
bool
Draw3DTransformedSurface
(
SourceSurface
*
aSurface
const
Matrix4x4
&
aMatrix
)
;
virtual
void
PushClip
(
const
Path
*
aPath
)
=
0
;
virtual
void
PushClipRect
(
const
Rect
&
aRect
)
=
0
;
virtual
void
PushDeviceSpaceClipRects
(
const
IntRect
*
aRects
uint32_t
aCount
)
;
virtual
void
PopClip
(
)
=
0
;
virtual
void
PushLayer
(
bool
aOpaque
Float
aOpacity
SourceSurface
*
aMask
const
Matrix
&
aMaskTransform
const
IntRect
&
aBounds
=
IntRect
(
)
bool
aCopyBackground
=
false
)
{
MOZ_CRASH
(
"
GFX
:
PushLayer
"
)
;
}
virtual
void
PopLayer
(
)
{
MOZ_CRASH
(
"
GFX
:
PopLayer
"
)
;
}
virtual
already_AddRefed
<
SourceSurface
>
CreateSourceSurfaceFromData
(
unsigned
char
*
aData
const
IntSize
&
aSize
int32_t
aStride
SurfaceFormat
aFormat
)
const
=
0
;
virtual
already_AddRefed
<
SourceSurface
>
OptimizeSourceSurface
(
SourceSurface
*
aSurface
)
const
=
0
;
virtual
already_AddRefed
<
SourceSurface
>
OptimizeSourceSurfaceForUnknownAlpha
(
SourceSurface
*
aSurface
)
const
{
return
OptimizeSourceSurface
(
aSurface
)
;
}
virtual
already_AddRefed
<
SourceSurface
>
CreateSourceSurfaceFromNativeSurface
(
const
NativeSurface
&
aSurface
)
const
=
0
;
virtual
already_AddRefed
<
DrawTarget
>
CreateSimilarDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
const
=
0
;
virtual
already_AddRefed
<
DrawTargetCapture
>
CreateCaptureDT
(
const
IntSize
&
aSize
)
;
virtual
already_AddRefed
<
DrawTarget
>
CreateShadowDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
float
aSigma
)
const
{
return
CreateSimilarDrawTarget
(
aSize
aFormat
)
;
}
virtual
already_AddRefed
<
PathBuilder
>
CreatePathBuilder
(
FillRule
aFillRule
=
FillRule
:
:
FILL_WINDING
)
const
=
0
;
virtual
already_AddRefed
<
GradientStops
>
CreateGradientStops
(
GradientStop
*
aStops
uint32_t
aNumStops
ExtendMode
aExtendMode
=
ExtendMode
:
:
CLAMP
)
const
=
0
;
virtual
already_AddRefed
<
FilterNode
>
CreateFilter
(
FilterType
aType
)
=
0
;
Matrix
GetTransform
(
)
const
{
return
mTransform
;
}
virtual
void
GetGlyphRasterizationMetrics
(
ScaledFont
*
aScaledFont
const
uint16_t
*
aGlyphIndices
uint32_t
aNumGlyphs
GlyphMetrics
*
aGlyphMetrics
)
{
aScaledFont
-
>
GetGlyphDesignMetrics
(
aGlyphIndices
aNumGlyphs
aGlyphMetrics
)
;
}
virtual
void
SetTransform
(
const
Matrix
&
aTransform
)
{
mTransform
=
aTransform
;
mTransformDirty
=
true
;
}
inline
void
ConcatTransform
(
const
Matrix
&
aTransform
)
{
SetTransform
(
aTransform
*
Matrix
(
GetTransform
(
)
)
)
;
}
SurfaceFormat
GetFormat
(
)
const
{
return
mFormat
;
}
virtual
void
*
GetNativeSurface
(
NativeSurfaceType
aType
)
{
return
nullptr
;
}
virtual
bool
IsDualDrawTarget
(
)
const
{
return
false
;
}
virtual
bool
IsTiledDrawTarget
(
)
const
{
return
false
;
}
virtual
bool
SupportsRegionClipping
(
)
const
{
return
true
;
}
void
AddUserData
(
UserDataKey
*
key
void
*
userData
void
(
*
destroy
)
(
void
*
)
)
{
mUserData
.
Add
(
key
userData
destroy
)
;
}
void
*
GetUserData
(
UserDataKey
*
key
)
const
{
return
mUserData
.
Get
(
key
)
;
}
void
*
RemoveUserData
(
UserDataKey
*
key
)
{
return
mUserData
.
Remove
(
key
)
;
}
void
SetOpaqueRect
(
const
IntRect
&
aRect
)
{
mOpaqueRect
=
aRect
;
}
const
IntRect
&
GetOpaqueRect
(
)
const
{
return
mOpaqueRect
;
}
virtual
bool
IsCurrentGroupOpaque
(
)
{
return
GetFormat
(
)
=
=
SurfaceFormat
:
:
B8G8R8X8
;
}
virtual
void
SetPermitSubpixelAA
(
bool
aPermitSubpixelAA
)
{
mPermitSubpixelAA
=
aPermitSubpixelAA
;
}
bool
GetPermitSubpixelAA
(
)
{
return
mPermitSubpixelAA
;
}
virtual
void
DetachAllSnapshots
(
)
=
0
;
#
ifdef
USE_SKIA_GPU
virtual
bool
InitWithGrContext
(
GrContext
*
aGrContext
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
MOZ_CRASH
(
"
GFX
:
InitWithGrContext
"
)
;
}
#
endif
protected
:
UserData
mUserData
;
Matrix
mTransform
;
IntRect
mOpaqueRect
;
bool
mTransformDirty
:
1
;
bool
mPermitSubpixelAA
:
1
;
SurfaceFormat
mFormat
;
}
;
class
DrawTargetCapture
:
public
DrawTarget
{
public
:
virtual
bool
IsCaptureDT
(
)
const
{
return
true
;
}
virtual
bool
ContainsOnlyColoredGlyphs
(
RefPtr
<
ScaledFont
>
&
aScaledFont
Color
&
aColor
std
:
:
vector
<
Glyph
>
&
aGlyphs
)
=
0
;
}
;
class
DrawEventRecorder
:
public
RefCounted
<
DrawEventRecorder
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
DrawEventRecorder
)
virtual
~
DrawEventRecorder
(
)
{
}
}
;
struct
Tile
{
RefPtr
<
DrawTarget
>
mDrawTarget
;
IntPoint
mTileOrigin
;
}
;
struct
TileSet
{
Tile
*
mTiles
;
size_t
mTileCount
;
}
;
struct
Config
{
LogForwarder
*
mLogForwarder
;
int32_t
mMaxTextureSize
;
int32_t
mMaxAllocSize
;
Config
(
)
:
mLogForwarder
(
nullptr
)
mMaxTextureSize
(
8192
)
mMaxAllocSize
(
52000000
)
{
}
}
;
class
GFX2D_API
Factory
{
public
:
static
void
Init
(
const
Config
&
aConfig
)
;
static
void
ShutDown
(
)
;
static
bool
HasSSE2
(
)
;
static
bool
CheckSurfaceSize
(
const
IntSize
&
sz
int32_t
limit
=
0
int32_t
allocLimit
=
0
)
;
static
bool
CheckBufferSize
(
int32_t
bufSize
)
;
static
bool
ReasonableSurfaceSize
(
const
IntSize
&
aSize
)
;
static
bool
AllowedSurfaceSize
(
const
IntSize
&
aSize
)
;
static
already_AddRefed
<
DrawTarget
>
CreateDrawTargetForCairoSurface
(
cairo_surface_t
*
aSurface
const
IntSize
&
aSize
SurfaceFormat
*
aFormat
=
nullptr
)
;
static
already_AddRefed
<
SourceSurface
>
CreateSourceSurfaceForCairoSurface
(
cairo_surface_t
*
aSurface
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
;
static
already_AddRefed
<
DrawTarget
>
CreateDrawTarget
(
BackendType
aBackend
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
;
static
already_AddRefed
<
DrawTarget
>
CreateRecordingDrawTarget
(
DrawEventRecorder
*
aRecorder
DrawTarget
*
aDT
)
;
static
already_AddRefed
<
DrawTarget
>
CreateDrawTargetForData
(
BackendType
aBackend
unsigned
char
*
aData
const
IntSize
&
aSize
int32_t
aStride
SurfaceFormat
aFormat
bool
aUninitialized
=
false
)
;
static
already_AddRefed
<
ScaledFont
>
CreateScaledFontForNativeFont
(
const
NativeFont
&
aNativeFont
Float
aSize
)
;
#
ifdef
MOZ_WIDGET_GTK
static
already_AddRefed
<
ScaledFont
>
CreateScaledFontForFontconfigFont
(
cairo_scaled_font_t
*
aScaledFont
FcPattern
*
aPattern
Float
aSize
)
;
#
endif
static
already_AddRefed
<
NativeFontResource
>
CreateNativeFontResource
(
uint8_t
*
aData
uint32_t
aSize
FontType
aType
)
;
static
already_AddRefed
<
ScaledFont
>
CreateScaledFontWithCairo
(
const
NativeFont
&
aNativeFont
Float
aSize
cairo_scaled_font_t
*
aScaledFont
)
;
static
already_AddRefed
<
DataSourceSurface
>
CreateDataSourceSurface
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
bool
aZero
=
false
)
;
static
already_AddRefed
<
DataSourceSurface
>
CreateDataSourceSurfaceWithStride
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
int32_t
aStride
bool
aZero
=
false
)
;
typedef
void
(
*
SourceSurfaceDeallocator
)
(
void
*
aClosure
)
;
static
already_AddRefed
<
DataSourceSurface
>
CreateWrappingDataSourceSurface
(
uint8_t
*
aData
int32_t
aStride
const
IntSize
&
aSize
SurfaceFormat
aFormat
SourceSurfaceDeallocator
aDeallocator
=
nullptr
void
*
aClosure
=
nullptr
)
;
static
void
CopyDataSourceSurface
(
DataSourceSurface
*
aSource
DataSourceSurface
*
aDest
)
;
static
already_AddRefed
<
DrawEventRecorder
>
CreateEventRecorderForFile
(
const
char
*
aFilename
)
;
static
void
SetGlobalEventRecorder
(
DrawEventRecorder
*
aRecorder
)
;
static
uint32_t
GetMaxSurfaceSize
(
BackendType
aType
)
;
static
LogForwarder
*
GetLogForwarder
(
)
{
return
sConfig
?
sConfig
-
>
mLogForwarder
:
nullptr
;
}
private
:
static
Config
*
sConfig
;
public
:
#
ifdef
USE_SKIA_GPU
static
already_AddRefed
<
DrawTarget
>
CreateDrawTargetSkiaWithGrContext
(
GrContext
*
aGrContext
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
;
#
endif
static
void
PurgeAllCaches
(
)
;
static
already_AddRefed
<
DrawTarget
>
CreateDualDrawTarget
(
DrawTarget
*
targetA
DrawTarget
*
targetB
)
;
static
already_AddRefed
<
DrawTarget
>
CreateTiledDrawTarget
(
const
TileSet
&
aTileSet
)
;
static
bool
DoesBackendSupportDataDrawtarget
(
BackendType
aType
)
;
#
ifdef
USE_SKIA
static
already_AddRefed
<
DrawTarget
>
CreateDrawTargetWithSkCanvas
(
SkCanvas
*
aCanvas
)
;
#
endif
#
ifdef
XP_DARWIN
static
already_AddRefed
<
GlyphRenderingOptions
>
CreateCGGlyphRenderingOptions
(
const
Color
&
aFontSmoothingBackgroundColor
)
;
#
endif
#
ifdef
WIN32
static
already_AddRefed
<
DrawTarget
>
CreateDrawTargetForD3D11Texture
(
ID3D11Texture2D
*
aTexture
SurfaceFormat
aFormat
)
;
static
bool
SetDirect3D11Device
(
ID3D11Device
*
aDevice
)
;
static
ID3D11Device
*
GetDirect3D11Device
(
)
;
static
ID2D1Device
*
GetD2D1Device
(
)
;
static
bool
SupportsD2D1
(
)
;
static
already_AddRefed
<
GlyphRenderingOptions
>
CreateDWriteGlyphRenderingOptions
(
IDWriteRenderingParams
*
aParams
)
;
static
uint64_t
GetD2DVRAMUsageDrawTarget
(
)
;
static
uint64_t
GetD2DVRAMUsageSourceSurface
(
)
;
static
void
D2DCleanup
(
)
;
static
already_AddRefed
<
ScaledFont
>
CreateScaledFontForDWriteFont
(
IDWriteFontFace
*
aFontFace
const
gfxFontStyle
*
aStyle
Float
aSize
bool
aUseEmbeddedBitmap
bool
aForceGDIMode
)
;
private
:
static
ID2D1Device
*
mD2D1Device
;
static
ID3D11Device
*
mD3D11Device
;
#
endif
static
DrawEventRecorder
*
mRecorder
;
}
;
}
}
#
endif
