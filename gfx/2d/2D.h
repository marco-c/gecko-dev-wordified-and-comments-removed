#
ifndef
_MOZILLA_GFX_2D_H
#
define
_MOZILLA_GFX_2D_H
#
include
"
Types
.
h
"
#
include
"
Point
.
h
"
#
include
"
Rect
.
h
"
#
include
"
Matrix
.
h
"
#
include
"
Quaternion
.
h
"
#
include
"
UserData
.
h
"
#
include
"
FontVariation
.
h
"
#
include
<
vector
>
#
include
"
mozilla
/
GenericRefCounted
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Path
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
ThreadSafeWeakPtr
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
nsRegionFwd
.
h
"
#
if
defined
(
MOZ_WIDGET_ANDROID
)
|
|
defined
(
MOZ_WIDGET_GTK
)
#
ifndef
MOZ_ENABLE_FREETYPE
#
define
MOZ_ENABLE_FREETYPE
#
endif
#
endif
struct
_cairo_surface
;
typedef
_cairo_surface
cairo_surface_t
;
struct
_cairo_scaled_font
;
typedef
_cairo_scaled_font
cairo_scaled_font_t
;
struct
FT_LibraryRec_
;
typedef
FT_LibraryRec_
*
FT_Library
;
struct
FT_FaceRec_
;
typedef
FT_FaceRec_
*
FT_Face
;
typedef
int
FT_Error
;
struct
_FcPattern
;
typedef
_FcPattern
FcPattern
;
struct
ID3D11Texture2D
;
struct
ID3D11Device
;
struct
ID2D1Device
;
struct
ID2D1DeviceContext
;
struct
ID2D1Multithread
;
struct
IDWriteFactory
;
struct
IDWriteRenderingParams
;
struct
IDWriteFontFace
;
struct
IDWriteFontCollection
;
class
SkCanvas
;
struct
gfxFontStyle
;
struct
CGContext
;
typedef
struct
CGContext
*
CGContextRef
;
struct
CGFont
;
typedef
CGFont
*
CGFontRef
;
namespace
mozilla
{
class
Mutex
;
namespace
layers
{
class
TextureData
;
}
namespace
wr
{
struct
FontInstanceOptions
;
struct
FontInstancePlatformOptions
;
}
namespace
gfx
{
class
UnscaledFont
;
class
ScaledFont
;
}
namespace
gfx
{
class
AlphaBoxBlur
;
class
ScaledFont
;
class
SourceSurface
;
class
DataSourceSurface
;
class
DrawTarget
;
class
DrawEventRecorder
;
class
FilterNode
;
class
LogForwarder
;
struct
NativeSurface
{
NativeSurfaceType
mType
;
SurfaceFormat
mFormat
;
gfx
:
:
IntSize
mSize
;
void
*
mSurface
;
}
;
struct
DrawOptions
{
explicit
DrawOptions
(
Float
aAlpha
=
1
.
0f
CompositionOp
aCompositionOp
=
CompositionOp
:
:
OP_OVER
AntialiasMode
aAntialiasMode
=
AntialiasMode
:
:
DEFAULT
)
:
mAlpha
(
aAlpha
)
mCompositionOp
(
aCompositionOp
)
mAntialiasMode
(
aAntialiasMode
)
{
}
Float
mAlpha
;
CompositionOp
mCompositionOp
;
AntialiasMode
mAntialiasMode
;
}
;
struct
StoredStrokeOptions
;
struct
StrokeOptions
{
explicit
StrokeOptions
(
Float
aLineWidth
=
1
.
0f
JoinStyle
aLineJoin
=
JoinStyle
:
:
MITER_OR_BEVEL
CapStyle
aLineCap
=
CapStyle
:
:
BUTT
Float
aMiterLimit
=
10
.
0f
size_t
aDashLength
=
0
const
Float
*
aDashPattern
=
0
Float
aDashOffset
=
0
.
f
)
:
mLineWidth
(
aLineWidth
)
mMiterLimit
(
aMiterLimit
)
mDashPattern
(
aDashLength
>
0
?
aDashPattern
:
0
)
mDashLength
(
aDashLength
)
mDashOffset
(
aDashOffset
)
mLineJoin
(
aLineJoin
)
mLineCap
(
aLineCap
)
{
MOZ_ASSERT
(
aDashLength
=
=
0
|
|
aDashPattern
)
;
}
Float
mLineWidth
;
Float
mMiterLimit
;
const
Float
*
mDashPattern
;
size_t
mDashLength
;
Float
mDashOffset
;
JoinStyle
mLineJoin
;
CapStyle
mLineCap
;
StoredStrokeOptions
*
Clone
(
)
const
;
bool
operator
=
=
(
const
StrokeOptions
&
aOther
)
const
{
return
mLineWidth
=
=
aOther
.
mLineWidth
&
&
mMiterLimit
=
=
aOther
.
mMiterLimit
&
&
mDashLength
=
=
aOther
.
mDashLength
&
&
(
!
mDashLength
|
|
(
mDashPattern
&
&
aOther
.
mDashPattern
&
&
!
memcmp
(
mDashPattern
aOther
.
mDashPattern
mDashLength
*
sizeof
(
Float
)
)
)
)
&
&
mDashOffset
=
=
aOther
.
mDashOffset
&
&
mLineJoin
=
=
aOther
.
mLineJoin
&
&
mLineCap
=
=
aOther
.
mLineCap
;
}
}
;
struct
StoredStrokeOptions
:
public
StrokeOptions
{
explicit
StoredStrokeOptions
(
const
StrokeOptions
&
aOptions
)
:
StrokeOptions
(
aOptions
)
{
if
(
mDashLength
)
{
Float
*
pattern
=
new
Float
[
mDashLength
]
;
memcpy
(
pattern
mDashPattern
mDashLength
*
sizeof
(
Float
)
)
;
mDashPattern
=
pattern
;
}
}
~
StoredStrokeOptions
(
)
{
if
(
mDashPattern
)
{
delete
[
]
mDashPattern
;
}
}
}
;
inline
StoredStrokeOptions
*
StrokeOptions
:
:
Clone
(
)
const
{
return
new
StoredStrokeOptions
(
*
this
)
;
}
struct
DrawSurfaceOptions
{
explicit
DrawSurfaceOptions
(
SamplingFilter
aSamplingFilter
=
SamplingFilter
:
:
LINEAR
SamplingBounds
aSamplingBounds
=
SamplingBounds
:
:
UNBOUNDED
)
:
mSamplingFilter
(
aSamplingFilter
)
mSamplingBounds
(
aSamplingBounds
)
{
}
SamplingFilter
mSamplingFilter
;
SamplingBounds
mSamplingBounds
;
}
;
struct
ShadowOptions
{
explicit
ShadowOptions
(
const
DeviceColor
&
aColor
=
DeviceColor
(
0
.
0f
0
.
0f
0
.
0f
)
const
Point
&
aOffset
=
Point
(
)
Float
aSigma
=
0
.
0f
)
:
mColor
(
aColor
)
mOffset
(
aOffset
)
mSigma
(
aSigma
)
{
}
DeviceColor
mColor
;
Point
mOffset
;
Float
mSigma
;
int32_t
BlurRadius
(
)
const
;
}
;
class
GradientStops
:
public
SupportsThreadSafeWeakPtr
<
GradientStops
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
GradientStops
)
virtual
~
GradientStops
(
)
=
default
;
virtual
BackendType
GetBackendType
(
)
const
=
0
;
virtual
bool
IsValid
(
)
const
{
return
true
;
}
protected
:
GradientStops
(
)
=
default
;
}
;
class
Pattern
{
public
:
virtual
~
Pattern
(
)
=
default
;
virtual
PatternType
GetType
(
)
const
=
0
;
virtual
Pattern
*
CloneWeak
(
)
const
{
return
nullptr
;
}
virtual
bool
IsWeak
(
)
const
{
return
false
;
}
virtual
bool
IsValid
(
)
const
{
return
true
;
}
virtual
bool
operator
=
=
(
const
Pattern
&
aOther
)
const
=
0
;
bool
operator
!
=
(
const
Pattern
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
protected
:
Pattern
(
)
=
default
;
template
<
typename
T
>
static
inline
bool
IsRefValid
(
const
RefPtr
<
T
>
&
aPtr
)
{
return
true
;
}
template
<
typename
T
>
static
inline
bool
IsRefValid
(
const
ThreadSafeWeakPtr
<
T
>
&
aPtr
)
{
return
!
aPtr
.
IsDead
(
)
;
}
}
;
class
ColorPattern
:
public
Pattern
{
public
:
explicit
ColorPattern
(
const
DeviceColor
&
aColor
)
:
mColor
(
aColor
)
{
}
PatternType
GetType
(
)
const
override
{
return
PatternType
:
:
COLOR
;
}
Pattern
*
CloneWeak
(
)
const
override
{
return
new
ColorPattern
(
mColor
)
;
}
bool
operator
=
=
(
const
Pattern
&
aOther
)
const
override
{
if
(
aOther
.
GetType
(
)
!
=
PatternType
:
:
COLOR
)
{
return
false
;
}
const
ColorPattern
&
other
=
static_cast
<
const
ColorPattern
&
>
(
aOther
)
;
return
mColor
=
=
other
.
mColor
;
}
DeviceColor
mColor
;
}
;
template
<
template
<
typename
>
typename
REF
=
RefPtr
>
class
LinearGradientPatternT
:
public
Pattern
{
typedef
LinearGradientPatternT
<
ThreadSafeWeakPtr
>
Weak
;
public
:
LinearGradientPatternT
(
const
Point
&
aBegin
const
Point
&
aEnd
RefPtr
<
GradientStops
>
aStops
const
Matrix
&
aMatrix
=
Matrix
(
)
)
:
mBegin
(
aBegin
)
mEnd
(
aEnd
)
mStops
(
std
:
:
move
(
aStops
)
)
mMatrix
(
aMatrix
)
{
}
PatternType
GetType
(
)
const
override
{
return
PatternType
:
:
LINEAR_GRADIENT
;
}
Pattern
*
CloneWeak
(
)
const
override
{
return
new
Weak
(
mBegin
mEnd
do_AddRef
(
mStops
)
mMatrix
)
;
}
bool
IsWeak
(
)
const
override
{
return
std
:
:
is_same
<
decltype
(
*
this
)
Weak
>
:
:
value
;
}
bool
IsValid
(
)
const
override
{
return
IsRefValid
(
mStops
)
;
}
template
<
template
<
typename
>
typename
T
>
bool
operator
=
=
(
const
LinearGradientPatternT
<
T
>
&
aOther
)
const
{
return
mBegin
=
=
aOther
.
mBegin
&
&
mEnd
=
=
aOther
.
mEnd
&
&
mStops
=
=
aOther
.
mStops
&
&
mMatrix
.
ExactlyEquals
(
aOther
.
mMatrix
)
;
}
bool
operator
=
=
(
const
Pattern
&
aOther
)
const
override
{
if
(
aOther
.
GetType
(
)
!
=
PatternType
:
:
LINEAR_GRADIENT
)
{
return
false
;
}
return
aOther
.
IsWeak
(
)
?
*
this
=
=
static_cast
<
const
Weak
&
>
(
aOther
)
:
*
this
=
=
static_cast
<
const
LinearGradientPatternT
<
>
&
>
(
aOther
)
;
}
Point
mBegin
;
Point
mEnd
;
REF
<
GradientStops
>
mStops
;
Matrix
mMatrix
;
}
;
typedef
LinearGradientPatternT
<
>
LinearGradientPattern
;
template
<
template
<
typename
>
typename
REF
=
RefPtr
>
class
RadialGradientPatternT
:
public
Pattern
{
typedef
RadialGradientPatternT
<
ThreadSafeWeakPtr
>
Weak
;
public
:
RadialGradientPatternT
(
const
Point
&
aCenter1
const
Point
&
aCenter2
Float
aRadius1
Float
aRadius2
RefPtr
<
GradientStops
>
aStops
const
Matrix
&
aMatrix
=
Matrix
(
)
)
:
mCenter1
(
aCenter1
)
mCenter2
(
aCenter2
)
mRadius1
(
aRadius1
)
mRadius2
(
aRadius2
)
mStops
(
std
:
:
move
(
aStops
)
)
mMatrix
(
aMatrix
)
{
}
PatternType
GetType
(
)
const
override
{
return
PatternType
:
:
RADIAL_GRADIENT
;
}
Pattern
*
CloneWeak
(
)
const
override
{
return
new
Weak
(
mCenter1
mCenter2
mRadius1
mRadius2
do_AddRef
(
mStops
)
mMatrix
)
;
}
bool
IsWeak
(
)
const
override
{
return
std
:
:
is_same
<
decltype
(
*
this
)
Weak
>
:
:
value
;
}
bool
IsValid
(
)
const
override
{
return
IsRefValid
(
mStops
)
;
}
template
<
template
<
typename
>
typename
T
>
bool
operator
=
=
(
const
RadialGradientPatternT
<
T
>
&
aOther
)
const
{
return
mCenter1
=
=
aOther
.
mCenter1
&
&
mCenter2
=
=
aOther
.
mCenter2
&
&
mRadius1
=
=
aOther
.
mRadius1
&
&
mRadius2
=
=
aOther
.
mRadius2
&
&
mStops
=
=
aOther
.
mStops
&
&
mMatrix
.
ExactlyEquals
(
aOther
.
mMatrix
)
;
}
bool
operator
=
=
(
const
Pattern
&
aOther
)
const
override
{
if
(
aOther
.
GetType
(
)
!
=
PatternType
:
:
RADIAL_GRADIENT
)
{
return
false
;
}
return
aOther
.
IsWeak
(
)
?
*
this
=
=
static_cast
<
const
Weak
&
>
(
aOther
)
:
*
this
=
=
static_cast
<
const
RadialGradientPatternT
<
>
&
>
(
aOther
)
;
}
Point
mCenter1
;
Point
mCenter2
;
Float
mRadius1
;
Float
mRadius2
;
REF
<
GradientStops
>
mStops
;
Matrix
mMatrix
;
}
;
typedef
RadialGradientPatternT
<
>
RadialGradientPattern
;
template
<
template
<
typename
>
typename
REF
=
RefPtr
>
class
ConicGradientPatternT
:
public
Pattern
{
typedef
ConicGradientPatternT
<
ThreadSafeWeakPtr
>
Weak
;
public
:
ConicGradientPatternT
(
const
Point
&
aCenter
Float
aAngle
Float
aStartOffset
Float
aEndOffset
RefPtr
<
GradientStops
>
aStops
const
Matrix
&
aMatrix
=
Matrix
(
)
)
:
mCenter
(
aCenter
)
mAngle
(
aAngle
)
mStartOffset
(
aStartOffset
)
mEndOffset
(
aEndOffset
)
mStops
(
std
:
:
move
(
aStops
)
)
mMatrix
(
aMatrix
)
{
}
PatternType
GetType
(
)
const
override
{
return
PatternType
:
:
CONIC_GRADIENT
;
}
Pattern
*
CloneWeak
(
)
const
override
{
return
new
Weak
(
mCenter
mAngle
mStartOffset
mEndOffset
do_AddRef
(
mStops
)
mMatrix
)
;
}
bool
IsWeak
(
)
const
override
{
return
std
:
:
is_same
<
decltype
(
*
this
)
Weak
>
:
:
value
;
}
bool
IsValid
(
)
const
override
{
return
IsRefValid
(
mStops
)
;
}
template
<
template
<
typename
>
typename
T
>
bool
operator
=
=
(
const
ConicGradientPatternT
<
T
>
&
aOther
)
const
{
return
mCenter
=
=
aOther
.
mCenter
&
&
mAngle
=
=
aOther
.
mAngle
&
&
mStartOffset
=
=
aOther
.
mStartOffset
&
&
mEndOffset
=
=
aOther
.
mEndOffset
&
&
mStops
=
=
aOther
.
mStops
&
&
mMatrix
.
ExactlyEquals
(
aOther
.
mMatrix
)
;
}
bool
operator
=
=
(
const
Pattern
&
aOther
)
const
override
{
if
(
aOther
.
GetType
(
)
!
=
PatternType
:
:
CONIC_GRADIENT
)
{
return
false
;
}
return
aOther
.
IsWeak
(
)
?
*
this
=
=
static_cast
<
const
Weak
&
>
(
aOther
)
:
*
this
=
=
static_cast
<
const
ConicGradientPatternT
<
>
&
>
(
aOther
)
;
}
Point
mCenter
;
Float
mAngle
;
Float
mStartOffset
;
Float
mEndOffset
;
REF
<
GradientStops
>
mStops
;
Matrix
mMatrix
;
}
;
typedef
ConicGradientPatternT
<
>
ConicGradientPattern
;
template
<
template
<
typename
>
typename
REF
=
RefPtr
>
class
SurfacePatternT
:
public
Pattern
{
typedef
SurfacePatternT
<
ThreadSafeWeakPtr
>
Weak
;
public
:
SurfacePatternT
(
RefPtr
<
SourceSurface
>
aSourceSurface
ExtendMode
aExtendMode
const
Matrix
&
aMatrix
=
Matrix
(
)
SamplingFilter
aSamplingFilter
=
SamplingFilter
:
:
GOOD
const
IntRect
&
aSamplingRect
=
IntRect
(
)
)
:
mSurface
(
std
:
:
move
(
aSourceSurface
)
)
mExtendMode
(
aExtendMode
)
mSamplingFilter
(
aSamplingFilter
)
mMatrix
(
aMatrix
)
mSamplingRect
(
aSamplingRect
)
{
}
PatternType
GetType
(
)
const
override
{
return
PatternType
:
:
SURFACE
;
}
Pattern
*
CloneWeak
(
)
const
override
{
return
new
Weak
(
do_AddRef
(
mSurface
)
mExtendMode
mMatrix
mSamplingFilter
mSamplingRect
)
;
}
bool
IsWeak
(
)
const
override
{
return
std
:
:
is_same
<
decltype
(
*
this
)
Weak
>
:
:
value
;
}
bool
IsValid
(
)
const
override
{
return
IsRefValid
(
mSurface
)
;
}
template
<
template
<
typename
>
typename
T
>
bool
operator
=
=
(
const
SurfacePatternT
<
T
>
&
aOther
)
const
{
return
mSurface
=
=
aOther
.
mSurface
&
&
mExtendMode
=
=
aOther
.
mExtendMode
&
&
mSamplingFilter
=
=
aOther
.
mSamplingFilter
&
&
mMatrix
.
ExactlyEquals
(
aOther
.
mMatrix
)
&
&
mSamplingRect
.
IsEqualEdges
(
aOther
.
mSamplingRect
)
;
}
bool
operator
=
=
(
const
Pattern
&
aOther
)
const
override
{
if
(
aOther
.
GetType
(
)
!
=
PatternType
:
:
SURFACE
)
{
return
false
;
}
return
aOther
.
IsWeak
(
)
?
*
this
=
=
static_cast
<
const
Weak
&
>
(
aOther
)
:
*
this
=
=
static_cast
<
const
SurfacePatternT
<
>
&
>
(
aOther
)
;
}
REF
<
SourceSurface
>
mSurface
;
ExtendMode
mExtendMode
;
SamplingFilter
mSamplingFilter
;
Matrix
mMatrix
;
IntRect
mSamplingRect
;
}
;
typedef
SurfacePatternT
<
>
SurfacePattern
;
class
StoredPattern
;
static
const
int32_t
kReasonableSurfaceSize
=
8192
;
class
SourceSurface
:
public
SupportsThreadSafeWeakPtr
<
SourceSurface
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
SourceSurface
)
virtual
~
SourceSurface
(
)
=
default
;
virtual
SurfaceType
GetType
(
)
const
=
0
;
virtual
IntSize
GetSize
(
)
const
=
0
;
virtual
IntRect
GetRect
(
)
const
{
return
IntRect
(
IntPoint
(
0
0
)
GetSize
(
)
)
;
}
virtual
SurfaceFormat
GetFormat
(
)
const
=
0
;
struct
SizeOfInfo
{
SizeOfInfo
(
)
:
mHeapBytes
(
0
)
mNonHeapBytes
(
0
)
mUnknownBytes
(
0
)
mExternalHandles
(
0
)
mExternalId
(
0
)
mTypes
(
0
)
{
}
void
Accumulate
(
const
SizeOfInfo
&
aOther
)
{
mHeapBytes
+
=
aOther
.
mHeapBytes
;
mNonHeapBytes
+
=
aOther
.
mNonHeapBytes
;
mUnknownBytes
+
=
aOther
.
mUnknownBytes
;
mExternalHandles
+
=
aOther
.
mExternalHandles
;
if
(
aOther
.
mExternalId
)
{
mExternalId
=
aOther
.
mExternalId
;
}
mTypes
|
=
aOther
.
mTypes
;
}
void
AddType
(
SurfaceType
aType
)
{
mTypes
|
=
1
<
<
uint32_t
(
aType
)
;
}
size_t
mHeapBytes
;
size_t
mNonHeapBytes
;
size_t
mUnknownBytes
;
size_t
mExternalHandles
;
uint64_t
mExternalId
;
uint32_t
mTypes
;
}
;
virtual
void
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
SizeOfInfo
&
aInfo
)
const
{
auto
size
=
GetSize
(
)
;
auto
format
=
GetFormat
(
)
;
aInfo
.
AddType
(
GetType
(
)
)
;
aInfo
.
mUnknownBytes
=
size
.
width
*
size
.
height
*
BytesPerPixel
(
format
)
;
}
virtual
bool
IsValid
(
)
const
{
return
true
;
}
virtual
bool
Equals
(
SourceSurface
*
aOther
bool
aSymmetric
=
true
)
{
return
this
=
=
aOther
|
|
(
aSymmetric
&
&
aOther
&
&
aOther
-
>
Equals
(
this
false
)
)
;
}
bool
IsDataSourceSurface
(
)
const
{
switch
(
GetType
(
)
)
{
case
SurfaceType
:
:
DATA
:
case
SurfaceType
:
:
DATA_SHARED
:
case
SurfaceType
:
:
DATA_RECYCLING_SHARED
:
case
SurfaceType
:
:
DATA_ALIGNED
:
case
SurfaceType
:
:
DATA_SHARED_WRAPPER
:
case
SurfaceType
:
:
DATA_MAPPED
:
case
SurfaceType
:
:
SKIA
:
case
SurfaceType
:
:
WEBGL
:
return
true
;
default
:
return
false
;
}
}
virtual
already_AddRefed
<
DataSourceSurface
>
GetDataSurface
(
)
=
0
;
virtual
already_AddRefed
<
SourceSurface
>
GetUnderlyingSurface
(
)
{
RefPtr
<
SourceSurface
>
surface
=
this
;
return
surface
.
forget
(
)
;
}
virtual
void
*
GetNativeSurface
(
NativeSurfaceType
aType
)
{
return
nullptr
;
}
void
AddUserData
(
UserDataKey
*
key
void
*
userData
void
(
*
destroy
)
(
void
*
)
)
{
mUserData
.
Add
(
key
userData
destroy
)
;
}
void
*
GetUserData
(
UserDataKey
*
key
)
const
{
return
mUserData
.
Get
(
key
)
;
}
void
RemoveUserData
(
UserDataKey
*
key
)
{
mUserData
.
RemoveAndDestroy
(
key
)
;
}
protected
:
friend
class
StoredPattern
;
UserData
mUserData
;
}
;
class
DataSourceSurface
:
public
SourceSurface
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
DataSourceSurface
override
)
DataSourceSurface
(
)
:
mMapCount
(
0
)
{
}
#
ifdef
DEBUG
virtual
~
DataSourceSurface
(
)
{
MOZ_ASSERT
(
mMapCount
=
=
0
)
;
}
#
endif
struct
MappedSurface
{
uint8_t
*
mData
=
nullptr
;
int32_t
mStride
=
0
;
}
;
enum
MapType
{
READ
WRITE
READ_WRITE
}
;
class
ScopedMap
final
{
public
:
ScopedMap
(
DataSourceSurface
*
aSurface
MapType
aType
)
:
mSurface
(
aSurface
)
mIsMapped
(
aSurface
-
>
Map
(
aType
&
mMap
)
)
{
}
ScopedMap
(
ScopedMap
&
&
aOther
)
:
mSurface
(
std
:
:
move
(
aOther
.
mSurface
)
)
mMap
(
aOther
.
mMap
)
mIsMapped
(
aOther
.
mIsMapped
)
{
aOther
.
mMap
.
mData
=
nullptr
;
aOther
.
mIsMapped
=
false
;
}
ScopedMap
&
operator
=
(
ScopedMap
&
&
aOther
)
{
if
(
mIsMapped
)
{
mSurface
-
>
Unmap
(
)
;
}
mSurface
=
std
:
:
move
(
aOther
.
mSurface
)
;
mMap
=
aOther
.
mMap
;
mIsMapped
=
aOther
.
mIsMapped
;
aOther
.
mMap
.
mData
=
nullptr
;
aOther
.
mIsMapped
=
false
;
return
*
this
;
}
~
ScopedMap
(
)
{
if
(
mIsMapped
)
{
mSurface
-
>
Unmap
(
)
;
}
}
uint8_t
*
GetData
(
)
const
{
MOZ_ASSERT
(
mIsMapped
)
;
return
mMap
.
mData
;
}
int32_t
GetStride
(
)
const
{
MOZ_ASSERT
(
mIsMapped
)
;
return
mMap
.
mStride
;
}
const
MappedSurface
*
GetMappedSurface
(
)
const
{
MOZ_ASSERT
(
mIsMapped
)
;
return
&
mMap
;
}
const
DataSourceSurface
*
GetSurface
(
)
const
{
MOZ_ASSERT
(
mIsMapped
)
;
return
mSurface
;
}
bool
IsMapped
(
)
const
{
return
mIsMapped
;
}
private
:
ScopedMap
(
const
ScopedMap
&
aOther
)
=
delete
;
ScopedMap
&
operator
=
(
const
ScopedMap
&
aOther
)
=
delete
;
RefPtr
<
DataSourceSurface
>
mSurface
;
MappedSurface
mMap
;
bool
mIsMapped
;
}
;
SurfaceType
GetType
(
)
const
override
{
return
SurfaceType
:
:
DATA
;
}
virtual
uint8_t
*
GetData
(
)
=
0
;
virtual
int32_t
Stride
(
)
=
0
;
virtual
bool
Map
(
MapType
MappedSurface
*
aMappedSurface
)
{
aMappedSurface
-
>
mData
=
GetData
(
)
;
aMappedSurface
-
>
mStride
=
Stride
(
)
;
bool
success
=
!
!
aMappedSurface
-
>
mData
;
if
(
success
)
{
mMapCount
+
+
;
}
return
success
;
}
virtual
void
Unmap
(
)
{
mMapCount
-
-
;
MOZ_ASSERT
(
mMapCount
>
=
0
)
;
}
already_AddRefed
<
DataSourceSurface
>
GetDataSurface
(
)
override
;
virtual
bool
OnHeap
(
)
const
{
return
true
;
}
virtual
Maybe
<
IntRect
>
TakeDirtyRect
(
)
{
return
Nothing
(
)
;
}
virtual
void
Invalidate
(
const
IntRect
&
aDirtyRect
)
{
}
protected
:
Atomic
<
int32_t
>
mMapCount
;
}
;
class
PathSink
:
public
RefCounted
<
PathSink
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
PathSink
)
virtual
~
PathSink
(
)
=
default
;
virtual
void
MoveTo
(
const
Point
&
aPoint
)
=
0
;
virtual
void
LineTo
(
const
Point
&
aPoint
)
=
0
;
virtual
void
BezierTo
(
const
Point
&
aCP1
const
Point
&
aCP2
const
Point
&
aCP3
)
=
0
;
virtual
void
QuadraticBezierTo
(
const
Point
&
aCP1
const
Point
&
aCP2
)
=
0
;
virtual
void
Close
(
)
=
0
;
virtual
void
Arc
(
const
Point
&
aOrigin
float
aRadius
float
aStartAngle
float
aEndAngle
bool
aAntiClockwise
=
false
)
=
0
;
virtual
Point
CurrentPoint
(
)
const
{
return
mCurrentPoint
;
}
virtual
Point
BeginPoint
(
)
const
{
return
mBeginPoint
;
}
virtual
void
SetCurrentPoint
(
const
Point
&
aPoint
)
{
mCurrentPoint
=
aPoint
;
}
virtual
void
SetBeginPoint
(
const
Point
&
aPoint
)
{
mBeginPoint
=
aPoint
;
}
protected
:
Point
mCurrentPoint
;
Point
mBeginPoint
;
}
;
class
PathBuilder
;
class
FlattenedPath
;
class
Path
:
public
external
:
:
AtomicRefCounted
<
Path
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
Path
)
virtual
~
Path
(
)
;
virtual
BackendType
GetBackendType
(
)
const
=
0
;
inline
already_AddRefed
<
PathBuilder
>
CopyToBuilder
(
)
const
{
return
CopyToBuilder
(
GetFillRule
(
)
)
;
}
inline
already_AddRefed
<
PathBuilder
>
TransformedCopyToBuilder
(
const
Matrix
&
aTransform
)
const
{
return
TransformedCopyToBuilder
(
aTransform
GetFillRule
(
)
)
;
}
virtual
already_AddRefed
<
PathBuilder
>
CopyToBuilder
(
FillRule
aFillRule
)
const
=
0
;
virtual
already_AddRefed
<
PathBuilder
>
TransformedCopyToBuilder
(
const
Matrix
&
aTransform
FillRule
aFillRule
)
const
=
0
;
virtual
bool
ContainsPoint
(
const
Point
&
aPoint
const
Matrix
&
aTransform
)
const
=
0
;
virtual
bool
StrokeContainsPoint
(
const
StrokeOptions
&
aStrokeOptions
const
Point
&
aPoint
const
Matrix
&
aTransform
)
const
=
0
;
virtual
Rect
GetBounds
(
const
Matrix
&
aTransform
=
Matrix
(
)
)
const
=
0
;
virtual
Rect
GetStrokedBounds
(
const
StrokeOptions
&
aStrokeOptions
const
Matrix
&
aTransform
=
Matrix
(
)
)
const
=
0
;
virtual
Rect
GetFastBounds
(
const
Matrix
&
aTransform
=
Matrix
(
)
const
StrokeOptions
*
aStrokeOptions
=
nullptr
)
const
;
virtual
void
StreamToSink
(
PathSink
*
aSink
)
const
=
0
;
virtual
FillRule
GetFillRule
(
)
const
=
0
;
virtual
Float
ComputeLength
(
)
;
virtual
Point
ComputePointAtLength
(
Float
aLength
Point
*
aTangent
=
nullptr
)
;
protected
:
Path
(
)
;
void
EnsureFlattenedPath
(
)
;
RefPtr
<
FlattenedPath
>
mFlattenedPath
;
}
;
class
PathBuilder
:
public
PathSink
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
PathBuilder
override
)
virtual
already_AddRefed
<
Path
>
Finish
(
)
=
0
;
virtual
BackendType
GetBackendType
(
)
const
=
0
;
}
;
struct
Glyph
{
uint32_t
mIndex
;
Point
mPosition
;
}
;
static
inline
bool
operator
=
=
(
const
Glyph
&
aOne
const
Glyph
&
aOther
)
{
return
aOne
.
mIndex
=
=
aOther
.
mIndex
&
&
aOne
.
mPosition
=
=
aOther
.
mPosition
;
}
struct
GlyphBuffer
{
const
Glyph
*
mGlyphs
;
uint32_t
mNumGlyphs
;
}
;
#
ifdef
MOZ_ENABLE_FREETYPE
class
SharedFTFace
;
class
SharedFTFaceData
{
public
:
virtual
already_AddRefed
<
SharedFTFace
>
CloneFace
(
int
aFaceIndex
=
0
)
{
return
nullptr
;
}
virtual
void
BindData
(
)
=
0
;
virtual
void
ReleaseData
(
)
=
0
;
}
;
template
<
class
T
>
class
SharedFTFaceRefCountedData
:
public
SharedFTFaceData
{
public
:
void
BindData
(
)
{
static_cast
<
T
*
>
(
this
)
-
>
AddRef
(
)
;
}
void
ReleaseData
(
)
{
static_cast
<
T
*
>
(
this
)
-
>
Release
(
)
;
}
}
;
class
SharedFTFace
:
public
external
:
:
AtomicRefCounted
<
SharedFTFace
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
SharedFTFace
)
explicit
SharedFTFace
(
FT_Face
aFace
SharedFTFaceData
*
aData
=
nullptr
)
;
virtual
~
SharedFTFace
(
)
;
FT_Face
GetFace
(
)
const
{
return
mFace
;
}
SharedFTFaceData
*
GetData
(
)
const
{
return
mData
;
}
bool
Lock
(
const
void
*
aOwner
=
nullptr
)
CAPABILITY_ACQUIRE
(
mLock
)
{
mLock
.
Lock
(
)
;
return
!
aOwner
|
|
mLastLockOwner
.
exchange
(
aOwner
)
=
=
aOwner
;
}
void
Unlock
(
)
CAPABILITY_RELEASE
(
mLock
)
{
mLock
.
Unlock
(
)
;
}
void
ForgetLockOwner
(
const
void
*
aOwner
)
{
if
(
aOwner
)
{
mLastLockOwner
.
compareExchange
(
aOwner
nullptr
)
;
}
}
private
:
FT_Face
mFace
;
SharedFTFaceData
*
mData
;
Mutex
mLock
;
Atomic
<
const
void
*
>
mLastLockOwner
;
}
;
#
endif
class
UnscaledFont
:
public
SupportsThreadSafeWeakPtr
<
UnscaledFont
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
UnscaledFont
)
virtual
~
UnscaledFont
(
)
;
virtual
FontType
GetType
(
)
const
=
0
;
static
uint32_t
DeletionCounter
(
)
{
return
sDeletionCounter
;
}
typedef
void
(
*
FontFileDataOutput
)
(
const
uint8_t
*
aData
uint32_t
aLength
uint32_t
aIndex
void
*
aBaton
)
;
typedef
void
(
*
FontInstanceDataOutput
)
(
const
uint8_t
*
aData
uint32_t
aLength
void
*
aBaton
)
;
typedef
void
(
*
FontDescriptorOutput
)
(
const
uint8_t
*
aData
uint32_t
aLength
uint32_t
aIndex
void
*
aBaton
)
;
virtual
bool
GetFontFileData
(
FontFileDataOutput
void
*
)
{
return
false
;
}
virtual
bool
GetFontInstanceData
(
FontInstanceDataOutput
void
*
)
{
return
false
;
}
virtual
bool
GetFontDescriptor
(
FontDescriptorOutput
void
*
)
{
return
false
;
}
virtual
already_AddRefed
<
ScaledFont
>
CreateScaledFont
(
Float
aGlyphSize
const
uint8_t
*
aInstanceData
uint32_t
aInstanceDataLength
const
FontVariation
*
aVariations
uint32_t
aNumVariations
)
{
return
nullptr
;
}
virtual
already_AddRefed
<
ScaledFont
>
CreateScaledFontFromWRFont
(
Float
aGlyphSize
const
wr
:
:
FontInstanceOptions
*
aOptions
const
wr
:
:
FontInstancePlatformOptions
*
aPlatformOptions
const
FontVariation
*
aVariations
uint32_t
aNumVariations
)
{
return
CreateScaledFont
(
aGlyphSize
nullptr
0
aVariations
aNumVariations
)
;
}
protected
:
UnscaledFont
(
)
=
default
;
private
:
static
Atomic
<
uint32_t
>
sDeletionCounter
;
}
;
class
ScaledFont
:
public
SupportsThreadSafeWeakPtr
<
ScaledFont
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
ScaledFont
)
virtual
~
ScaledFont
(
)
;
virtual
FontType
GetType
(
)
const
=
0
;
virtual
Float
GetSize
(
)
const
=
0
;
virtual
AntialiasMode
GetDefaultAAMode
(
)
{
return
AntialiasMode
:
:
DEFAULT
;
}
static
uint32_t
DeletionCounter
(
)
{
return
sDeletionCounter
;
}
virtual
already_AddRefed
<
Path
>
GetPathForGlyphs
(
const
GlyphBuffer
&
aBuffer
const
DrawTarget
*
aTarget
)
=
0
;
virtual
void
CopyGlyphsToBuilder
(
const
GlyphBuffer
&
aBuffer
PathBuilder
*
aBuilder
const
Matrix
*
aTransformHint
=
nullptr
)
=
0
;
typedef
void
(
*
FontInstanceDataOutput
)
(
const
uint8_t
*
aData
uint32_t
aLength
const
FontVariation
*
aVariations
uint32_t
aNumVariations
void
*
aBaton
)
;
virtual
bool
GetFontInstanceData
(
FontInstanceDataOutput
void
*
)
{
return
false
;
}
virtual
bool
GetWRFontInstanceOptions
(
Maybe
<
wr
:
:
FontInstanceOptions
>
*
aOutOptions
Maybe
<
wr
:
:
FontInstancePlatformOptions
>
*
aOutPlatformOptions
std
:
:
vector
<
FontVariation
>
*
aOutVariations
)
{
return
false
;
}
virtual
bool
CanSerialize
(
)
{
return
false
;
}
virtual
bool
HasVariationSettings
(
)
{
return
false
;
}
virtual
bool
MayUseBitmaps
(
)
{
return
false
;
}
virtual
bool
UseSubpixelPosition
(
)
const
{
return
false
;
}
void
AddUserData
(
UserDataKey
*
key
void
*
userData
void
(
*
destroy
)
(
void
*
)
)
{
mUserData
.
Add
(
key
userData
destroy
)
;
}
void
*
GetUserData
(
UserDataKey
*
key
)
{
return
mUserData
.
Get
(
key
)
;
}
void
RemoveUserData
(
UserDataKey
*
key
)
{
mUserData
.
RemoveAndDestroy
(
key
)
;
}
const
RefPtr
<
UnscaledFont
>
&
GetUnscaledFont
(
)
const
{
return
mUnscaledFont
;
}
virtual
cairo_scaled_font_t
*
GetCairoScaledFont
(
)
{
return
nullptr
;
}
Float
GetSyntheticObliqueAngle
(
)
const
{
return
mSyntheticObliqueAngle
;
}
void
SetSyntheticObliqueAngle
(
Float
aAngle
)
{
mSyntheticObliqueAngle
=
aAngle
;
}
protected
:
explicit
ScaledFont
(
const
RefPtr
<
UnscaledFont
>
&
aUnscaledFont
)
:
mUnscaledFont
(
aUnscaledFont
)
mSyntheticObliqueAngle
(
0
.
0f
)
{
}
UserData
mUserData
;
RefPtr
<
UnscaledFont
>
mUnscaledFont
;
Float
mSyntheticObliqueAngle
;
private
:
static
Atomic
<
uint32_t
>
sDeletionCounter
;
}
;
class
NativeFontResource
:
public
external
:
:
AtomicRefCounted
<
NativeFontResource
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
NativeFontResource
)
virtual
already_AddRefed
<
UnscaledFont
>
CreateUnscaledFont
(
uint32_t
aIndex
const
uint8_t
*
aInstanceData
uint32_t
aInstanceDataLength
)
=
0
;
NativeFontResource
(
size_t
aDataLength
)
;
virtual
~
NativeFontResource
(
)
;
static
void
RegisterMemoryReporter
(
)
;
private
:
size_t
mDataLength
;
}
;
class
DrawTarget
:
public
external
:
:
AtomicRefCounted
<
DrawTarget
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
DrawTarget
)
DrawTarget
(
)
:
mTransformDirty
(
false
)
mPermitSubpixelAA
(
false
)
mFormat
(
SurfaceFormat
:
:
UNKNOWN
)
{
}
virtual
~
DrawTarget
(
)
=
default
;
virtual
bool
IsValid
(
)
const
{
return
true
;
}
;
virtual
DrawTargetType
GetType
(
)
const
=
0
;
virtual
BackendType
GetBackendType
(
)
const
=
0
;
virtual
bool
IsRecording
(
)
const
{
return
false
;
}
virtual
void
Link
(
const
char
*
aDestination
const
Rect
&
aRect
)
{
}
virtual
void
Destination
(
const
char
*
aDestination
const
Point
&
aPoint
)
{
}
virtual
already_AddRefed
<
SourceSurface
>
Snapshot
(
)
=
0
;
virtual
already_AddRefed
<
SourceSurface
>
GetBackingSurface
(
)
{
return
Snapshot
(
)
;
}
virtual
already_AddRefed
<
SourceSurface
>
IntoLuminanceSource
(
LuminanceType
aLuminanceType
float
aOpacity
)
;
virtual
IntSize
GetSize
(
)
const
=
0
;
virtual
IntRect
GetRect
(
)
const
{
return
IntRect
(
IntPoint
(
0
0
)
GetSize
(
)
)
;
}
virtual
bool
LockBits
(
uint8_t
*
*
aData
IntSize
*
aSize
int32_t
*
aStride
SurfaceFormat
*
aFormat
IntPoint
*
aOrigin
=
nullptr
)
{
return
false
;
}
virtual
void
ReleaseBits
(
uint8_t
*
aData
)
{
}
virtual
void
Flush
(
)
=
0
;
virtual
void
DrawSurface
(
SourceSurface
*
aSurface
const
Rect
&
aDest
const
Rect
&
aSource
const
DrawSurfaceOptions
&
aSurfOptions
=
DrawSurfaceOptions
(
)
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
=
0
;
virtual
void
DrawDependentSurface
(
uint64_t
aId
const
Rect
&
aDest
)
{
MOZ_CRASH
(
"
GFX
:
DrawDependentSurface
"
)
;
}
virtual
void
DrawFilter
(
FilterNode
*
aNode
const
Rect
&
aSourceRect
const
Point
&
aDestPoint
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
=
0
;
virtual
void
DrawSurfaceWithShadow
(
SourceSurface
*
aSurface
const
Point
&
aDest
const
ShadowOptions
&
aShadow
CompositionOp
aOperator
)
=
0
;
virtual
void
DrawShadow
(
const
Path
*
aPath
const
Pattern
&
aPattern
const
ShadowOptions
&
aShadow
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
const
StrokeOptions
*
aStrokeOptions
=
nullptr
)
;
virtual
void
ClearRect
(
const
Rect
&
aRect
)
=
0
;
virtual
void
CopySurface
(
SourceSurface
*
aSurface
const
IntRect
&
aSourceRect
const
IntPoint
&
aDestination
)
=
0
;
virtual
void
CopyRect
(
const
IntRect
&
aSourceRect
const
IntPoint
&
aDestination
)
{
RefPtr
<
SourceSurface
>
source
=
Snapshot
(
)
;
CopySurface
(
source
aSourceRect
aDestination
)
;
}
virtual
void
FillRect
(
const
Rect
&
aRect
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
=
0
;
virtual
void
FillRoundedRect
(
const
RoundedRect
&
aRect
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
;
virtual
void
StrokeRect
(
const
Rect
&
aRect
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
=
StrokeOptions
(
)
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
=
0
;
virtual
void
StrokeLine
(
const
Point
&
aStart
const
Point
&
aEnd
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
=
StrokeOptions
(
)
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
=
0
;
virtual
void
Stroke
(
const
Path
*
aPath
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
=
StrokeOptions
(
)
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
=
0
;
virtual
void
Fill
(
const
Path
*
aPath
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
=
0
;
virtual
void
FillGlyphs
(
ScaledFont
*
aFont
const
GlyphBuffer
&
aBuffer
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
=
0
;
virtual
void
StrokeGlyphs
(
ScaledFont
*
aFont
const
GlyphBuffer
&
aBuffer
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
=
StrokeOptions
(
)
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
;
virtual
void
Mask
(
const
Pattern
&
aSource
const
Pattern
&
aMask
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
=
0
;
virtual
void
MaskSurface
(
const
Pattern
&
aSource
SourceSurface
*
aMask
Point
aOffset
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
=
0
;
virtual
bool
Draw3DTransformedSurface
(
SourceSurface
*
aSurface
const
Matrix4x4
&
aMatrix
)
;
virtual
void
PushClip
(
const
Path
*
aPath
)
=
0
;
virtual
void
PushClipRect
(
const
Rect
&
aRect
)
=
0
;
virtual
void
PushDeviceSpaceClipRects
(
const
IntRect
*
aRects
uint32_t
aCount
)
;
virtual
void
PopClip
(
)
=
0
;
virtual
void
PushLayer
(
bool
aOpaque
Float
aOpacity
SourceSurface
*
aMask
const
Matrix
&
aMaskTransform
const
IntRect
&
aBounds
=
IntRect
(
)
bool
aCopyBackground
=
false
)
{
MOZ_CRASH
(
"
GFX
:
PushLayer
"
)
;
}
virtual
void
PushLayerWithBlend
(
bool
aOpaque
Float
aOpacity
SourceSurface
*
aMask
const
Matrix
&
aMaskTransform
const
IntRect
&
aBounds
=
IntRect
(
)
bool
aCopyBackground
=
false
CompositionOp
=
CompositionOp
:
:
OP_OVER
)
{
MOZ_CRASH
(
"
GFX
:
PushLayerWithBlend
"
)
;
}
virtual
void
PopLayer
(
)
{
MOZ_CRASH
(
"
GFX
:
PopLayer
"
)
;
}
virtual
void
Blur
(
const
AlphaBoxBlur
&
aBlur
)
;
virtual
void
PadEdges
(
const
IntRegion
&
aRegion
)
;
virtual
bool
Unrotate
(
IntPoint
aRotation
)
;
virtual
already_AddRefed
<
SourceSurface
>
CreateSourceSurfaceFromData
(
unsigned
char
*
aData
const
IntSize
&
aSize
int32_t
aStride
SurfaceFormat
aFormat
)
const
=
0
;
virtual
already_AddRefed
<
SourceSurface
>
OptimizeSourceSurface
(
SourceSurface
*
aSurface
)
const
=
0
;
virtual
already_AddRefed
<
SourceSurface
>
OptimizeSourceSurfaceForUnknownAlpha
(
SourceSurface
*
aSurface
)
const
{
return
OptimizeSourceSurface
(
aSurface
)
;
}
virtual
already_AddRefed
<
SourceSurface
>
CreateSourceSurfaceFromNativeSurface
(
const
NativeSurface
&
aSurface
)
const
=
0
;
virtual
already_AddRefed
<
DrawTarget
>
CreateSimilarDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
const
=
0
;
virtual
already_AddRefed
<
DrawTarget
>
CreateSimilarDrawTargetWithBacking
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
const
{
return
CreateSimilarDrawTarget
(
aSize
aFormat
)
;
}
virtual
already_AddRefed
<
DrawTarget
>
CreateSimilarDrawTargetForFilter
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
FilterNode
*
aFilter
FilterNode
*
aSource
const
Rect
&
aSourceRect
const
Point
&
aDestPoint
)
{
return
CreateSimilarDrawTarget
(
aSize
aFormat
)
;
}
virtual
bool
CanCreateSimilarDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
const
{
return
true
;
}
virtual
already_AddRefed
<
DrawTarget
>
CreateShadowDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
float
aSigma
)
const
{
return
CreateSimilarDrawTarget
(
aSize
aFormat
)
;
}
virtual
RefPtr
<
DrawTarget
>
CreateClippedDrawTarget
(
const
Rect
&
aBounds
SurfaceFormat
aFormat
)
=
0
;
virtual
RefPtr
<
DrawTarget
>
CreateSimilarRasterTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
const
{
return
CreateSimilarDrawTarget
(
aSize
aFormat
)
;
}
virtual
already_AddRefed
<
PathBuilder
>
CreatePathBuilder
(
FillRule
aFillRule
=
FillRule
:
:
FILL_WINDING
)
const
=
0
;
virtual
already_AddRefed
<
GradientStops
>
CreateGradientStops
(
GradientStop
*
aStops
uint32_t
aNumStops
ExtendMode
aExtendMode
=
ExtendMode
:
:
CLAMP
)
const
=
0
;
virtual
already_AddRefed
<
FilterNode
>
CreateFilter
(
FilterType
aType
)
=
0
;
Matrix
GetTransform
(
)
const
{
return
mTransform
;
}
virtual
void
SetTransform
(
const
Matrix
&
aTransform
)
{
mTransform
=
aTransform
;
mTransformDirty
=
true
;
}
inline
void
ConcatTransform
(
const
Matrix
&
aTransform
)
{
SetTransform
(
aTransform
*
Matrix
(
GetTransform
(
)
)
)
;
}
SurfaceFormat
GetFormat
(
)
const
{
return
mFormat
;
}
virtual
void
*
GetNativeSurface
(
NativeSurfaceType
aType
)
{
return
nullptr
;
}
virtual
bool
IsTiledDrawTarget
(
)
const
{
return
false
;
}
virtual
bool
SupportsRegionClipping
(
)
const
{
return
true
;
}
void
AddUserData
(
UserDataKey
*
key
void
*
userData
void
(
*
destroy
)
(
void
*
)
)
{
mUserData
.
Add
(
key
userData
destroy
)
;
}
void
*
GetUserData
(
UserDataKey
*
key
)
const
{
return
mUserData
.
Get
(
key
)
;
}
void
*
RemoveUserData
(
UserDataKey
*
key
)
{
return
mUserData
.
Remove
(
key
)
;
}
void
SetOpaqueRect
(
const
IntRect
&
aRect
)
{
mOpaqueRect
=
aRect
;
}
const
IntRect
&
GetOpaqueRect
(
)
const
{
return
mOpaqueRect
;
}
virtual
bool
IsCurrentGroupOpaque
(
)
{
return
GetFormat
(
)
=
=
SurfaceFormat
:
:
B8G8R8X8
;
}
virtual
void
SetPermitSubpixelAA
(
bool
aPermitSubpixelAA
)
{
mPermitSubpixelAA
=
aPermitSubpixelAA
;
}
bool
GetPermitSubpixelAA
(
)
{
return
mPermitSubpixelAA
;
}
virtual
void
FlushItem
(
const
IntRect
&
aBounds
)
{
}
virtual
void
DetachAllSnapshots
(
)
=
0
;
protected
:
UserData
mUserData
;
Matrix
mTransform
;
IntRect
mOpaqueRect
;
bool
mTransformDirty
:
1
;
bool
mPermitSubpixelAA
:
1
;
SurfaceFormat
mFormat
;
}
;
class
DrawEventRecorder
:
public
RefCounted
<
DrawEventRecorder
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
DrawEventRecorder
)
virtual
bool
Finish
(
)
=
0
;
virtual
~
DrawEventRecorder
(
)
=
default
;
}
;
struct
Tile
{
RefPtr
<
DrawTarget
>
mDrawTarget
;
IntPoint
mTileOrigin
;
}
;
struct
TileSet
{
Tile
*
mTiles
;
size_t
mTileCount
;
}
;
struct
Config
{
LogForwarder
*
mLogForwarder
;
int32_t
mMaxTextureSize
;
int32_t
mMaxAllocSize
;
Config
(
)
:
mLogForwarder
(
nullptr
)
mMaxTextureSize
(
kReasonableSurfaceSize
)
mMaxAllocSize
(
52000000
)
{
}
}
;
class
GFX2D_API
Factory
{
using
char_type
=
filesystem
:
:
Path
:
:
value_type
;
public
:
static
void
Init
(
const
Config
&
aConfig
)
;
static
void
ShutDown
(
)
;
static
bool
HasSSE2
(
)
;
static
bool
HasSSE4
(
)
;
static
bool
CheckSurfaceSize
(
const
IntSize
&
sz
int32_t
limit
=
0
int32_t
allocLimit
=
0
)
;
static
bool
CheckBufferSize
(
int32_t
bufSize
)
;
static
bool
ReasonableSurfaceSize
(
const
IntSize
&
aSize
)
;
static
bool
AllowedSurfaceSize
(
const
IntSize
&
aSize
)
;
static
already_AddRefed
<
DrawTarget
>
CreateDrawTargetForCairoSurface
(
cairo_surface_t
*
aSurface
const
IntSize
&
aSize
SurfaceFormat
*
aFormat
=
nullptr
)
;
static
already_AddRefed
<
SourceSurface
>
CreateSourceSurfaceForCairoSurface
(
cairo_surface_t
*
aSurface
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
;
static
already_AddRefed
<
DrawTarget
>
CreateDrawTarget
(
BackendType
aBackend
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
;
static
already_AddRefed
<
PathBuilder
>
CreateSimplePathBuilder
(
)
;
static
already_AddRefed
<
DrawTarget
>
CreateRecordingDrawTarget
(
DrawEventRecorder
*
aRecorder
DrawTarget
*
aDT
IntRect
aRect
)
;
static
already_AddRefed
<
DrawTarget
>
CreateDrawTargetForData
(
BackendType
aBackend
unsigned
char
*
aData
const
IntSize
&
aSize
int32_t
aStride
SurfaceFormat
aFormat
bool
aUninitialized
=
false
)
;
#
ifdef
XP_DARWIN
static
already_AddRefed
<
ScaledFont
>
CreateScaledFontForMacFont
(
CGFontRef
aCGFont
const
RefPtr
<
UnscaledFont
>
&
aUnscaledFont
Float
aSize
const
DeviceColor
&
aFontSmoothingBackgroundColor
bool
aUseFontSmoothing
=
true
bool
aApplySyntheticBold
=
false
bool
aHasColorGlyphs
=
false
)
;
#
endif
#
ifdef
MOZ_WIDGET_GTK
static
already_AddRefed
<
ScaledFont
>
CreateScaledFontForFontconfigFont
(
const
RefPtr
<
UnscaledFont
>
&
aUnscaledFont
Float
aSize
RefPtr
<
SharedFTFace
>
aFace
FcPattern
*
aPattern
)
;
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
static
already_AddRefed
<
ScaledFont
>
CreateScaledFontForFreeTypeFont
(
const
RefPtr
<
UnscaledFont
>
&
aUnscaledFont
Float
aSize
RefPtr
<
SharedFTFace
>
aFace
bool
aApplySyntheticBold
=
false
)
;
#
endif
static
already_AddRefed
<
NativeFontResource
>
CreateNativeFontResource
(
uint8_t
*
aData
uint32_t
aSize
FontType
aFontType
void
*
aFontContext
=
nullptr
)
;
static
already_AddRefed
<
UnscaledFont
>
CreateUnscaledFontFromFontDescriptor
(
FontType
aType
const
uint8_t
*
aData
uint32_t
aDataLength
uint32_t
aIndex
)
;
static
already_AddRefed
<
DataSourceSurface
>
CreateDataSourceSurface
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
bool
aZero
=
false
)
;
static
already_AddRefed
<
DataSourceSurface
>
CreateDataSourceSurfaceWithStride
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
int32_t
aStride
bool
aZero
=
false
)
;
typedef
void
(
*
SourceSurfaceDeallocator
)
(
void
*
aClosure
)
;
static
already_AddRefed
<
DataSourceSurface
>
CreateWrappingDataSourceSurface
(
uint8_t
*
aData
int32_t
aStride
const
IntSize
&
aSize
SurfaceFormat
aFormat
SourceSurfaceDeallocator
aDeallocator
=
nullptr
void
*
aClosure
=
nullptr
)
;
static
void
CopyDataSourceSurface
(
DataSourceSurface
*
aSource
DataSourceSurface
*
aDest
)
;
static
uint32_t
GetMaxSurfaceSize
(
BackendType
aType
)
;
static
LogForwarder
*
GetLogForwarder
(
)
{
return
sConfig
?
sConfig
-
>
mLogForwarder
:
nullptr
;
}
private
:
static
Config
*
sConfig
;
public
:
static
void
PurgeAllCaches
(
)
;
static
already_AddRefed
<
DrawTarget
>
CreateOffsetDrawTarget
(
DrawTarget
*
aDrawTarget
IntPoint
aTileOrigin
)
;
static
bool
DoesBackendSupportDataDrawtarget
(
BackendType
aType
)
;
static
void
SetBGRSubpixelOrder
(
bool
aBGR
)
;
static
bool
GetBGRSubpixelOrder
(
)
;
private
:
static
bool
mBGRSubpixelOrder
;
public
:
static
already_AddRefed
<
DrawTarget
>
CreateDrawTargetWithSkCanvas
(
SkCanvas
*
aCanvas
)
;
#
ifdef
MOZ_ENABLE_FREETYPE
static
void
SetFTLibrary
(
FT_Library
aFTLibrary
)
;
static
FT_Library
GetFTLibrary
(
)
;
static
FT_Library
NewFTLibrary
(
)
;
static
void
ReleaseFTLibrary
(
FT_Library
aFTLibrary
)
;
static
void
LockFTLibrary
(
FT_Library
aFTLibrary
)
;
static
void
UnlockFTLibrary
(
FT_Library
aFTLibrary
)
;
static
FT_Face
NewFTFace
(
FT_Library
aFTLibrary
const
char
*
aFileName
int
aFaceIndex
)
;
static
already_AddRefed
<
SharedFTFace
>
NewSharedFTFace
(
FT_Library
aFTLibrary
const
char
*
aFilename
int
aFaceIndex
)
;
static
FT_Face
NewFTFaceFromData
(
FT_Library
aFTLibrary
const
uint8_t
*
aData
size_t
aDataSize
int
aFaceIndex
)
;
static
already_AddRefed
<
SharedFTFace
>
NewSharedFTFaceFromData
(
FT_Library
aFTLibrary
const
uint8_t
*
aData
size_t
aDataSize
int
aFaceIndex
SharedFTFaceData
*
aSharedData
=
nullptr
)
;
static
void
ReleaseFTFace
(
FT_Face
aFace
)
;
static
FT_Error
LoadFTGlyph
(
FT_Face
aFace
uint32_t
aGlyphIndex
int32_t
aFlags
)
;
private
:
static
FT_Library
mFTLibrary
;
static
StaticMutex
mFTLock
;
public
:
#
endif
#
ifdef
WIN32
static
already_AddRefed
<
DrawTarget
>
CreateDrawTargetForD3D11Texture
(
ID3D11Texture2D
*
aTexture
SurfaceFormat
aFormat
)
;
static
bool
SetDirect3D11Device
(
ID3D11Device
*
aDevice
)
;
static
RefPtr
<
ID3D11Device
>
GetDirect3D11Device
(
)
;
static
RefPtr
<
ID2D1Device
>
GetD2D1Device
(
uint32_t
*
aOutSeqNo
=
nullptr
)
;
static
bool
HasD2D1Device
(
)
;
static
RefPtr
<
IDWriteFactory
>
GetDWriteFactory
(
)
;
static
RefPtr
<
IDWriteFactory
>
EnsureDWriteFactory
(
)
;
static
bool
SupportsD2D1
(
)
;
static
RefPtr
<
IDWriteFontCollection
>
GetDWriteSystemFonts
(
bool
aUpdate
=
false
)
;
static
RefPtr
<
ID2D1DeviceContext
>
GetD2DDeviceContext
(
)
;
static
uint64_t
GetD2DVRAMUsageDrawTarget
(
)
;
static
uint64_t
GetD2DVRAMUsageSourceSurface
(
)
;
static
void
D2DCleanup
(
)
;
static
already_AddRefed
<
ScaledFont
>
CreateScaledFontForDWriteFont
(
IDWriteFontFace
*
aFontFace
const
gfxFontStyle
*
aStyle
const
RefPtr
<
UnscaledFont
>
&
aUnscaledFont
Float
aSize
bool
aUseEmbeddedBitmap
bool
aUseMultistrikeBold
bool
aGDIForced
)
;
static
already_AddRefed
<
ScaledFont
>
CreateScaledFontForGDIFont
(
const
void
*
aLogFont
const
RefPtr
<
UnscaledFont
>
&
aUnscaledFont
Float
aSize
)
;
static
void
SetSystemTextQuality
(
uint8_t
aQuality
)
;
static
already_AddRefed
<
DataSourceSurface
>
CreateBGRA8DataSourceSurfaceForD3D11Texture
(
ID3D11Texture2D
*
aSrcTexture
uint32_t
aArrayIndex
=
0
)
;
static
bool
ReadbackTexture
(
layers
:
:
TextureData
*
aDestCpuTexture
ID3D11Texture2D
*
aSrcTexture
)
;
static
bool
ReadbackTexture
(
DataSourceSurface
*
aDestCpuTexture
ID3D11Texture2D
*
aSrcTexture
uint32_t
aArrayIndex
=
0
)
;
private
:
static
StaticRefPtr
<
ID2D1Device
>
mD2D1Device
;
static
StaticRefPtr
<
ID3D11Device
>
mD3D11Device
;
static
StaticRefPtr
<
IDWriteFactory
>
mDWriteFactory
;
static
bool
mDWriteFactoryInitialized
;
static
StaticRefPtr
<
IDWriteFontCollection
>
mDWriteSystemFonts
;
static
StaticRefPtr
<
ID2D1DeviceContext
>
mMTDC
;
static
StaticRefPtr
<
ID2D1DeviceContext
>
mOffMTDC
;
static
bool
ReadbackTexture
(
uint8_t
*
aDestData
int32_t
aDestStride
ID3D11Texture2D
*
aSrcTexture
)
;
template
<
typename
DestTextureT
>
static
bool
ConvertSourceAndRetryReadback
(
DestTextureT
*
aDestCpuTexture
ID3D11Texture2D
*
aSrcTexture
uint32_t
aArrayIndex
=
0
)
;
protected
:
static
StaticMutex
mDeviceLock
;
static
StaticMutex
mDTDependencyLock
;
friend
class
DrawTargetD2D1
;
#
endif
}
;
class
MOZ_RAII
AutoSerializeWithMoz2D
final
{
public
:
explicit
AutoSerializeWithMoz2D
(
BackendType
aBackendType
)
;
~
AutoSerializeWithMoz2D
(
)
;
private
:
#
if
defined
(
WIN32
)
RefPtr
<
ID2D1Multithread
>
mMT
;
#
endif
}
;
}
}
#
endif
