#
include
"
Matrix
.
h
"
#
include
"
Quaternion
.
h
"
#
include
"
Tools
.
h
"
#
include
<
algorithm
>
#
include
<
ostream
>
#
include
<
math
.
h
>
#
include
<
float
.
h
>
#
include
"
mozilla
/
FloatingPoint
.
h
"
using
namespace
std
;
namespace
mozilla
{
namespace
gfx
{
double
FlushToZero
(
double
aVal
)
{
if
(
-
FLT_EPSILON
<
aVal
&
&
aVal
<
FLT_EPSILON
)
{
return
0
.
0f
;
}
else
{
return
aVal
;
}
}
double
SafeTangent
(
double
aTheta
)
{
const
double
kEpsilon
=
0
.
0001
;
double
sinTheta
=
sin
(
aTheta
)
;
double
cosTheta
=
cos
(
aTheta
)
;
if
(
cosTheta
>
=
0
&
&
cosTheta
<
kEpsilon
)
{
cosTheta
=
kEpsilon
;
}
else
if
(
cosTheta
<
0
&
&
cosTheta
>
=
-
kEpsilon
)
{
cosTheta
=
-
kEpsilon
;
}
return
FlushToZero
(
sinTheta
/
cosTheta
)
;
}
template
<
>
Matrix
Matrix
:
:
Rotation
(
Float
aAngle
)
{
Matrix
newMatrix
;
Float
s
=
sinf
(
aAngle
)
;
Float
c
=
cosf
(
aAngle
)
;
newMatrix
.
_11
=
c
;
newMatrix
.
_12
=
s
;
newMatrix
.
_21
=
-
s
;
newMatrix
.
_22
=
c
;
return
newMatrix
;
}
template
<
>
Rect
Matrix
:
:
TransformBounds
(
const
Rect
&
aRect
)
const
{
int
i
;
Point
quad
[
4
]
;
Float
min_x
max_x
;
Float
min_y
max_y
;
quad
[
0
]
=
TransformPoint
(
aRect
.
TopLeft
(
)
)
;
quad
[
1
]
=
TransformPoint
(
aRect
.
TopRight
(
)
)
;
quad
[
2
]
=
TransformPoint
(
aRect
.
BottomLeft
(
)
)
;
quad
[
3
]
=
TransformPoint
(
aRect
.
BottomRight
(
)
)
;
min_x
=
max_x
=
quad
[
0
]
.
x
;
min_y
=
max_y
=
quad
[
0
]
.
y
;
for
(
i
=
1
;
i
<
4
;
i
+
+
)
{
if
(
quad
[
i
]
.
x
<
min_x
)
min_x
=
quad
[
i
]
.
x
;
if
(
quad
[
i
]
.
x
>
max_x
)
max_x
=
quad
[
i
]
.
x
;
if
(
quad
[
i
]
.
y
<
min_y
)
min_y
=
quad
[
i
]
.
y
;
if
(
quad
[
i
]
.
y
>
max_y
)
max_y
=
quad
[
i
]
.
y
;
}
return
Rect
(
min_x
min_y
max_x
-
min_x
max_y
-
min_y
)
;
}
template
<
>
Matrix
&
Matrix
:
:
NudgeToIntegers
(
)
{
NudgeToInteger
(
&
_11
)
;
NudgeToInteger
(
&
_12
)
;
NudgeToInteger
(
&
_21
)
;
NudgeToInteger
(
&
_22
)
;
NudgeToInteger
(
&
_31
)
;
NudgeToInteger
(
&
_32
)
;
return
*
this
;
}
}
}
