#
ifndef
MOZILLA_GFX_DRAWTARGETD2D1_H_
#
define
MOZILLA_GFX_DRAWTARGETD2D1_H_
#
include
"
2D
.
h
"
#
include
<
d3d11
.
h
>
#
include
<
d2d1_1
.
h
>
#
include
"
PathD2D
.
h
"
#
include
"
HelpersD2D
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
<
vector
>
#
include
<
sstream
>
#
include
<
unordered_set
>
struct
IDWriteFactory
;
namespace
mozilla
{
namespace
gfx
{
class
SourceSurfaceD2D1
;
const
int32_t
kLayerCacheSize1
=
5
;
class
DrawTargetD2D1
:
public
DrawTarget
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
DrawTargetD2D1
override
)
DrawTargetD2D1
(
)
;
virtual
~
DrawTargetD2D1
(
)
;
virtual
bool
IsValid
(
)
const
override
;
virtual
DrawTargetType
GetType
(
)
const
override
{
return
DrawTargetType
:
:
HARDWARE_RASTER
;
}
virtual
BackendType
GetBackendType
(
)
const
override
{
return
BackendType
:
:
DIRECT2D1_1
;
}
virtual
already_AddRefed
<
SourceSurface
>
Snapshot
(
)
override
;
virtual
already_AddRefed
<
SourceSurface
>
IntoLuminanceSource
(
LuminanceType
aLuminanceType
float
aOpacity
)
override
;
virtual
IntSize
GetSize
(
)
const
override
{
return
mSize
;
}
virtual
void
Flush
(
)
override
;
virtual
void
DrawSurface
(
SourceSurface
*
aSurface
const
Rect
&
aDest
const
Rect
&
aSource
const
DrawSurfaceOptions
&
aSurfOptions
const
DrawOptions
&
aOptions
)
override
;
virtual
void
DrawFilter
(
FilterNode
*
aNode
const
Rect
&
aSourceRect
const
Point
&
aDestPoint
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
override
;
virtual
void
DrawSurfaceWithShadow
(
SourceSurface
*
aSurface
const
Point
&
aDest
const
Color
&
aColor
const
Point
&
aOffset
Float
aSigma
CompositionOp
aOperator
)
override
;
virtual
void
ClearRect
(
const
Rect
&
aRect
)
override
;
virtual
void
MaskSurface
(
const
Pattern
&
aSource
SourceSurface
*
aMask
Point
aOffset
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
override
;
virtual
void
CopySurface
(
SourceSurface
*
aSurface
const
IntRect
&
aSourceRect
const
IntPoint
&
aDestination
)
override
;
virtual
void
FillRect
(
const
Rect
&
aRect
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
override
;
virtual
void
FillRoundedRect
(
const
RoundedRect
&
aRect
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
override
;
virtual
void
StrokeRect
(
const
Rect
&
aRect
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
=
StrokeOptions
(
)
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
override
;
virtual
void
StrokeLine
(
const
Point
&
aStart
const
Point
&
aEnd
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
=
StrokeOptions
(
)
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
override
;
virtual
void
Stroke
(
const
Path
*
aPath
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
=
StrokeOptions
(
)
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
override
;
virtual
void
Fill
(
const
Path
*
aPath
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
override
;
virtual
void
FillGlyphs
(
ScaledFont
*
aFont
const
GlyphBuffer
&
aBuffer
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
override
;
virtual
void
Mask
(
const
Pattern
&
aSource
const
Pattern
&
aMask
const
DrawOptions
&
aOptions
=
DrawOptions
(
)
)
override
;
virtual
void
PushClip
(
const
Path
*
aPath
)
override
;
virtual
void
PushClipRect
(
const
Rect
&
aRect
)
override
;
virtual
void
PushDeviceSpaceClipRects
(
const
IntRect
*
aRects
uint32_t
aCount
)
override
;
virtual
void
PopClip
(
)
override
;
virtual
void
PushLayer
(
bool
aOpaque
Float
aOpacity
SourceSurface
*
aMask
const
Matrix
&
aMaskTransform
const
IntRect
&
aBounds
=
IntRect
(
)
bool
aCopyBackground
=
false
)
override
;
virtual
void
PopLayer
(
)
override
;
virtual
already_AddRefed
<
SourceSurface
>
CreateSourceSurfaceFromData
(
unsigned
char
*
aData
const
IntSize
&
aSize
int32_t
aStride
SurfaceFormat
aFormat
)
const
override
;
virtual
already_AddRefed
<
SourceSurface
>
OptimizeSourceSurface
(
SourceSurface
*
aSurface
)
const
override
;
virtual
already_AddRefed
<
SourceSurface
>
CreateSourceSurfaceFromNativeSurface
(
const
NativeSurface
&
aSurface
)
const
override
{
return
nullptr
;
}
virtual
already_AddRefed
<
DrawTarget
>
CreateSimilarDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
const
override
;
virtual
bool
CanCreateSimilarDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
const
override
;
virtual
already_AddRefed
<
PathBuilder
>
CreatePathBuilder
(
FillRule
aFillRule
=
FillRule
:
:
FILL_WINDING
)
const
override
;
virtual
already_AddRefed
<
GradientStops
>
CreateGradientStops
(
GradientStop
*
aStops
uint32_t
aNumStops
ExtendMode
aExtendMode
=
ExtendMode
:
:
CLAMP
)
const
override
;
virtual
already_AddRefed
<
FilterNode
>
CreateFilter
(
FilterType
aType
)
override
;
virtual
bool
SupportsRegionClipping
(
)
const
override
{
return
false
;
}
virtual
bool
IsCurrentGroupOpaque
(
)
override
{
return
CurrentLayer
(
)
.
mIsOpaque
;
}
virtual
void
*
GetNativeSurface
(
NativeSurfaceType
aType
)
override
{
return
nullptr
;
}
virtual
void
DetachAllSnapshots
(
)
override
{
MarkChanged
(
)
;
}
virtual
void
GetGlyphRasterizationMetrics
(
ScaledFont
*
aScaledFont
const
uint16_t
*
aGlyphIndices
uint32_t
aNumGlyphs
GlyphMetrics
*
aGlyphMetrics
)
override
;
bool
Init
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
;
bool
Init
(
ID3D11Texture2D
*
aTexture
SurfaceFormat
aFormat
)
;
uint32_t
GetByteSize
(
)
const
;
already_AddRefed
<
ID2D1Image
>
GetImageForSurface
(
SourceSurface
*
aSurface
Matrix
&
aSourceTransform
ExtendMode
aExtendMode
const
IntRect
*
aSourceRect
=
nullptr
bool
aUserSpace
=
true
)
;
already_AddRefed
<
ID2D1Image
>
GetImageForSurface
(
SourceSurface
*
aSurface
ExtendMode
aExtendMode
)
{
Matrix
mat
;
return
GetImageForSurface
(
aSurface
mat
aExtendMode
nullptr
)
;
}
static
RefPtr
<
ID2D1Factory1
>
factory
(
)
;
static
void
CleanupD2D
(
)
;
operator
std
:
:
string
(
)
const
{
std
:
:
stringstream
stream
;
stream
<
<
"
DrawTargetD2D
1
.
1
(
"
<
<
this
<
<
"
)
"
;
return
stream
.
str
(
)
;
}
static
uint32_t
GetMaxSurfaceSize
(
)
{
return
D3D11_REQ_TEXTURE2D_U_OR_V_DIMENSION
;
}
static
uint64_t
mVRAMUsageDT
;
static
uint64_t
mVRAMUsageSS
;
private
:
friend
class
SourceSurfaceD2D1
;
void
FlushInternal
(
bool
aHasDependencyMutex
=
false
)
;
bool
EnsureInitialized
(
)
;
typedef
std
:
:
unordered_set
<
DrawTargetD2D1
*
>
TargetSet
;
void
MarkChanged
(
)
;
bool
ShouldClipTemporarySurfaceDrawing
(
CompositionOp
aOp
const
Pattern
&
aPattern
bool
aClipIsComplex
)
;
void
PrepareForDrawing
(
CompositionOp
aOp
const
Pattern
&
aPattern
)
;
void
FinalizeDrawing
(
CompositionOp
aOp
const
Pattern
&
aPattern
)
;
void
FlushTransformToDC
(
)
{
if
(
mTransformDirty
)
{
mDC
-
>
SetTransform
(
D2DMatrix
(
mTransform
)
)
;
mTransformDirty
=
false
;
}
}
void
AddDependencyOnSource
(
SourceSurfaceD2D1
*
aSource
)
;
already_AddRefed
<
ID2D1Image
>
GetImageForLayerContent
(
bool
aShouldPreserveContent
=
true
)
;
ID2D1Image
*
CurrentTarget
(
)
{
if
(
CurrentLayer
(
)
.
mCurrentList
)
{
return
CurrentLayer
(
)
.
mCurrentList
;
}
return
mBitmap
;
}
already_AddRefed
<
ID2D1Geometry
>
GetClippedGeometry
(
IntRect
*
aClipBounds
)
;
already_AddRefed
<
ID2D1Geometry
>
GetInverseClippedGeometry
(
)
;
bool
GetDeviceSpaceClipRect
(
D2D1_RECT_F
&
aClipRect
bool
&
aIsPixelAligned
)
;
void
PopAllClips
(
)
;
void
PushAllClips
(
)
;
void
PushClipsToDC
(
ID2D1DeviceContext
*
aDC
bool
aForceIgnoreAlpha
=
false
const
D2D1_RECT_F
&
aMaxRect
=
D2D1
:
:
InfiniteRect
(
)
)
;
void
PopClipsFromDC
(
ID2D1DeviceContext
*
aDC
)
;
already_AddRefed
<
ID2D1Brush
>
CreateTransparentBlackBrush
(
)
;
already_AddRefed
<
ID2D1SolidColorBrush
>
GetSolidColorBrush
(
const
D2D_COLOR_F
&
aColor
)
;
already_AddRefed
<
ID2D1Brush
>
CreateBrushForPattern
(
const
Pattern
&
aPattern
Float
aAlpha
=
1
.
0f
)
;
void
PushClipGeometry
(
ID2D1Geometry
*
aGeometry
const
D2D1_MATRIX_3X2_F
&
aTransform
bool
aPixelAligned
=
false
)
;
void
PushD2DLayer
(
ID2D1DeviceContext
*
aDC
ID2D1Geometry
*
aGeometry
const
D2D1_MATRIX_3X2_F
&
aTransform
bool
aPixelAligned
=
false
bool
aForceIgnoreAlpha
=
false
const
D2D1_RECT_F
&
aLayerRect
=
D2D1
:
:
InfiniteRect
(
)
)
;
bool
IsDeviceContextValid
(
)
;
IntSize
mSize
;
RefPtr
<
ID2D1Geometry
>
mCurrentClippedGeometry
;
IntRect
mCurrentClipBounds
;
mutable
RefPtr
<
ID2D1DeviceContext
>
mDC
;
RefPtr
<
ID2D1Bitmap1
>
mBitmap
;
RefPtr
<
ID2D1CommandList
>
mCommandList
;
RefPtr
<
ID2D1SolidColorBrush
>
mSolidColorBrush
;
RefPtr
<
IDWriteRenderingParams
>
mTextRenderingParams
;
struct
PushedClip
{
D2D1_RECT_F
mBounds
;
D2D1_MATRIX_3X2_F
mTransform
;
RefPtr
<
ID2D1Geometry
>
mGeometry
;
bool
mIsPixelAligned
;
}
;
struct
PushedLayer
{
PushedLayer
(
)
:
mClipsArePushed
(
false
)
mIsOpaque
(
false
)
mOldPermitSubpixelAA
(
false
)
{
}
std
:
:
vector
<
PushedClip
>
mPushedClips
;
RefPtr
<
ID2D1CommandList
>
mCurrentList
;
bool
mClipsArePushed
;
bool
mIsOpaque
;
bool
mOldPermitSubpixelAA
;
}
;
std
:
:
vector
<
PushedLayer
>
mPushedLayers
;
PushedLayer
&
CurrentLayer
(
)
{
return
mPushedLayers
.
back
(
)
;
}
RefPtr
<
SourceSurfaceD2D1
>
mSnapshot
;
std
:
:
shared_ptr
<
Mutex
>
mSnapshotLock
;
TargetSet
mDependentTargets
;
TargetSet
mDependingOnTargets
;
uint32_t
mUsedCommandListsSincePurge
;
uint32_t
mTransformedGlyphsSinceLastPurge
;
uint32_t
mComplexBlendsWithListInList
;
static
StaticRefPtr
<
ID2D1Factory1
>
mFactory
;
uint32_t
mDeviceSeq
;
bool
EnsureLuminanceEffect
(
)
;
RefPtr
<
ID2D1Effect
>
mLuminanceEffect
;
enum
class
InitState
{
Uninitialized
Success
Failure
}
;
InitState
mInitState
;
RefPtr
<
IDXGISurface
>
mSurface
;
}
;
}
}
#
endif
