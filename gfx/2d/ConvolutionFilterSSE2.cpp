#
include
"
SkConvolver
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
<
immintrin
.
h
>
namespace
skia
{
static
MOZ_ALWAYS_INLINE
void
AccumRemainder
(
const
unsigned
char
*
pixelsLeft
const
SkConvolutionFilter1D
:
:
ConvolutionFixed
*
filterValues
__m128i
&
accum
int
r
)
{
int
remainder
[
4
]
=
{
0
}
;
for
(
int
i
=
0
;
i
<
r
;
i
+
+
)
{
SkConvolutionFilter1D
:
:
ConvolutionFixed
coeff
=
filterValues
[
i
]
;
remainder
[
0
]
+
=
coeff
*
pixelsLeft
[
i
*
4
+
0
]
;
remainder
[
1
]
+
=
coeff
*
pixelsLeft
[
i
*
4
+
1
]
;
remainder
[
2
]
+
=
coeff
*
pixelsLeft
[
i
*
4
+
2
]
;
remainder
[
3
]
+
=
coeff
*
pixelsLeft
[
i
*
4
+
3
]
;
}
__m128i
t
=
_mm_setr_epi32
(
remainder
[
0
]
remainder
[
1
]
remainder
[
2
]
remainder
[
3
]
)
;
accum
=
_mm_add_epi32
(
accum
t
)
;
}
void
convolve_horizontally_sse2
(
const
unsigned
char
*
srcData
const
SkConvolutionFilter1D
&
filter
unsigned
char
*
outRow
bool
)
{
int
numValues
=
filter
.
numValues
(
)
;
for
(
int
outX
=
0
;
outX
<
numValues
;
outX
+
+
)
{
int
filterOffset
filterLength
;
const
SkConvolutionFilter1D
:
:
ConvolutionFixed
*
filterValues
=
filter
.
FilterForValue
(
outX
&
filterOffset
&
filterLength
)
;
const
unsigned
char
*
rowToFilter
=
&
srcData
[
filterOffset
*
4
]
;
__m128i
zero
=
_mm_setzero_si128
(
)
;
__m128i
accum
=
_mm_setzero_si128
(
)
;
for
(
int
filterX
=
0
;
filterX
<
filterLength
>
>
2
;
filterX
+
+
)
{
__m128i
coeff
coeff16
;
coeff
=
_mm_loadl_epi64
(
reinterpret_cast
<
const
__m128i
*
>
(
filterValues
)
)
;
coeff16
=
_mm_shufflelo_epi16
(
coeff
_MM_SHUFFLE
(
1
1
0
0
)
)
;
coeff16
=
_mm_unpacklo_epi16
(
coeff16
coeff16
)
;
__m128i
src8
=
_mm_loadu_si128
(
reinterpret_cast
<
const
__m128i
*
>
(
rowToFilter
)
)
;
__m128i
src16
=
_mm_unpacklo_epi8
(
src8
zero
)
;
__m128i
mul_hi
=
_mm_mulhi_epi16
(
src16
coeff16
)
;
__m128i
mul_lo
=
_mm_mullo_epi16
(
src16
coeff16
)
;
__m128i
t
=
_mm_unpacklo_epi16
(
mul_lo
mul_hi
)
;
accum
=
_mm_add_epi32
(
accum
t
)
;
t
=
_mm_unpackhi_epi16
(
mul_lo
mul_hi
)
;
accum
=
_mm_add_epi32
(
accum
t
)
;
coeff16
=
_mm_shufflelo_epi16
(
coeff
_MM_SHUFFLE
(
3
3
2
2
)
)
;
coeff16
=
_mm_unpacklo_epi16
(
coeff16
coeff16
)
;
src16
=
_mm_unpackhi_epi8
(
src8
zero
)
;
mul_hi
=
_mm_mulhi_epi16
(
src16
coeff16
)
;
mul_lo
=
_mm_mullo_epi16
(
src16
coeff16
)
;
t
=
_mm_unpacklo_epi16
(
mul_lo
mul_hi
)
;
accum
=
_mm_add_epi32
(
accum
t
)
;
t
=
_mm_unpackhi_epi16
(
mul_lo
mul_hi
)
;
accum
=
_mm_add_epi32
(
accum
t
)
;
rowToFilter
+
=
16
;
filterValues
+
=
4
;
}
int
r
=
filterLength
&
3
;
if
(
r
)
{
int
remainderOffset
=
(
filterOffset
+
filterLength
-
r
)
*
4
;
AccumRemainder
(
srcData
+
remainderOffset
filterValues
accum
r
)
;
}
accum
=
_mm_srai_epi32
(
accum
SkConvolutionFilter1D
:
:
kShiftBits
)
;
accum
=
_mm_packs_epi32
(
accum
zero
)
;
accum
=
_mm_packus_epi16
(
accum
zero
)
;
*
(
reinterpret_cast
<
int
*
>
(
outRow
)
)
=
_mm_cvtsi128_si32
(
accum
)
;
outRow
+
=
4
;
}
}
template
<
bool
hasAlpha
>
static
void
ConvolveVertically
(
const
SkConvolutionFilter1D
:
:
ConvolutionFixed
*
filterValues
int
filterLength
unsigned
char
*
const
*
sourceDataRows
int
pixelWidth
unsigned
char
*
outRow
)
{
int
width
=
pixelWidth
&
~
3
;
__m128i
zero
=
_mm_setzero_si128
(
)
;
for
(
int
outX
=
0
;
outX
<
width
;
outX
+
=
4
)
{
__m128i
accum0
=
_mm_setzero_si128
(
)
;
__m128i
accum1
=
_mm_setzero_si128
(
)
;
__m128i
accum2
=
_mm_setzero_si128
(
)
;
__m128i
accum3
=
_mm_setzero_si128
(
)
;
for
(
int
filterY
=
0
;
filterY
<
filterLength
;
filterY
+
+
)
{
__m128i
coeff16
=
_mm_set1_epi16
(
filterValues
[
filterY
]
)
;
const
__m128i
*
src
=
reinterpret_cast
<
const
__m128i
*
>
(
&
sourceDataRows
[
filterY
]
[
outX
<
<
2
]
)
;
__m128i
src8
=
_mm_loadu_si128
(
src
)
;
__m128i
src16
=
_mm_unpacklo_epi8
(
src8
zero
)
;
__m128i
mul_hi
=
_mm_mulhi_epi16
(
src16
coeff16
)
;
__m128i
mul_lo
=
_mm_mullo_epi16
(
src16
coeff16
)
;
__m128i
t
=
_mm_unpacklo_epi16
(
mul_lo
mul_hi
)
;
accum0
=
_mm_add_epi32
(
accum0
t
)
;
t
=
_mm_unpackhi_epi16
(
mul_lo
mul_hi
)
;
accum1
=
_mm_add_epi32
(
accum1
t
)
;
src16
=
_mm_unpackhi_epi8
(
src8
zero
)
;
mul_hi
=
_mm_mulhi_epi16
(
src16
coeff16
)
;
mul_lo
=
_mm_mullo_epi16
(
src16
coeff16
)
;
t
=
_mm_unpacklo_epi16
(
mul_lo
mul_hi
)
;
accum2
=
_mm_add_epi32
(
accum2
t
)
;
t
=
_mm_unpackhi_epi16
(
mul_lo
mul_hi
)
;
accum3
=
_mm_add_epi32
(
accum3
t
)
;
}
accum0
=
_mm_srai_epi32
(
accum0
SkConvolutionFilter1D
:
:
kShiftBits
)
;
accum1
=
_mm_srai_epi32
(
accum1
SkConvolutionFilter1D
:
:
kShiftBits
)
;
accum2
=
_mm_srai_epi32
(
accum2
SkConvolutionFilter1D
:
:
kShiftBits
)
;
accum3
=
_mm_srai_epi32
(
accum3
SkConvolutionFilter1D
:
:
kShiftBits
)
;
accum0
=
_mm_packs_epi32
(
accum0
accum1
)
;
accum2
=
_mm_packs_epi32
(
accum2
accum3
)
;
accum0
=
_mm_packus_epi16
(
accum0
accum2
)
;
if
(
hasAlpha
)
{
__m128i
a
=
_mm_srli_epi32
(
accum0
8
)
;
__m128i
b
=
_mm_max_epu8
(
a
accum0
)
;
a
=
_mm_srli_epi32
(
accum0
16
)
;
b
=
_mm_max_epu8
(
a
b
)
;
b
=
_mm_slli_epi32
(
b
24
)
;
accum0
=
_mm_max_epu8
(
b
accum0
)
;
}
else
{
__m128i
mask
=
_mm_set1_epi32
(
0xff000000
)
;
accum0
=
_mm_or_si128
(
accum0
mask
)
;
}
_mm_storeu_si128
(
reinterpret_cast
<
__m128i
*
>
(
outRow
)
accum0
)
;
outRow
+
=
16
;
}
int
r
=
pixelWidth
&
3
;
if
(
r
)
{
__m128i
accum0
=
_mm_setzero_si128
(
)
;
__m128i
accum1
=
_mm_setzero_si128
(
)
;
__m128i
accum2
=
_mm_setzero_si128
(
)
;
for
(
int
filterY
=
0
;
filterY
<
filterLength
;
+
+
filterY
)
{
__m128i
coeff16
=
_mm_set1_epi16
(
filterValues
[
filterY
]
)
;
const
__m128i
*
src
=
reinterpret_cast
<
const
__m128i
*
>
(
&
sourceDataRows
[
filterY
]
[
width
<
<
2
]
)
;
__m128i
src8
=
_mm_loadu_si128
(
src
)
;
__m128i
src16
=
_mm_unpacklo_epi8
(
src8
zero
)
;
__m128i
mul_hi
=
_mm_mulhi_epi16
(
src16
coeff16
)
;
__m128i
mul_lo
=
_mm_mullo_epi16
(
src16
coeff16
)
;
__m128i
t
=
_mm_unpacklo_epi16
(
mul_lo
mul_hi
)
;
accum0
=
_mm_add_epi32
(
accum0
t
)
;
t
=
_mm_unpackhi_epi16
(
mul_lo
mul_hi
)
;
accum1
=
_mm_add_epi32
(
accum1
t
)
;
src16
=
_mm_unpackhi_epi8
(
src8
zero
)
;
mul_hi
=
_mm_mulhi_epi16
(
src16
coeff16
)
;
mul_lo
=
_mm_mullo_epi16
(
src16
coeff16
)
;
t
=
_mm_unpacklo_epi16
(
mul_lo
mul_hi
)
;
accum2
=
_mm_add_epi32
(
accum2
t
)
;
}
accum0
=
_mm_srai_epi32
(
accum0
SkConvolutionFilter1D
:
:
kShiftBits
)
;
accum1
=
_mm_srai_epi32
(
accum1
SkConvolutionFilter1D
:
:
kShiftBits
)
;
accum2
=
_mm_srai_epi32
(
accum2
SkConvolutionFilter1D
:
:
kShiftBits
)
;
accum0
=
_mm_packs_epi32
(
accum0
accum1
)
;
accum2
=
_mm_packs_epi32
(
accum2
zero
)
;
accum0
=
_mm_packus_epi16
(
accum0
accum2
)
;
if
(
hasAlpha
)
{
__m128i
a
=
_mm_srli_epi32
(
accum0
8
)
;
__m128i
b
=
_mm_max_epu8
(
a
accum0
)
;
a
=
_mm_srli_epi32
(
accum0
16
)
;
b
=
_mm_max_epu8
(
a
b
)
;
b
=
_mm_slli_epi32
(
b
24
)
;
accum0
=
_mm_max_epu8
(
b
accum0
)
;
}
else
{
__m128i
mask
=
_mm_set1_epi32
(
0xff000000
)
;
accum0
=
_mm_or_si128
(
accum0
mask
)
;
}
for
(
int
i
=
0
;
i
<
r
;
i
+
+
)
{
*
(
reinterpret_cast
<
int
*
>
(
outRow
)
)
=
_mm_cvtsi128_si32
(
accum0
)
;
accum0
=
_mm_srli_si128
(
accum0
4
)
;
outRow
+
=
4
;
}
}
}
void
convolve_vertically_sse2
(
const
SkConvolutionFilter1D
:
:
ConvolutionFixed
*
filterValues
int
filterLength
unsigned
char
*
const
*
sourceDataRows
int
pixelWidth
unsigned
char
*
outRow
bool
hasAlpha
)
{
if
(
hasAlpha
)
{
ConvolveVertically
<
true
>
(
filterValues
filterLength
sourceDataRows
pixelWidth
outRow
)
;
}
else
{
ConvolveVertically
<
false
>
(
filterValues
filterLength
sourceDataRows
pixelWidth
outRow
)
;
}
}
}
