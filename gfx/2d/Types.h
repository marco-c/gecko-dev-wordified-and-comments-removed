#
ifndef
MOZILLA_GFX_TYPES_H_
#
define
MOZILLA_GFX_TYPES_H_
#
include
"
mozilla
/
DefineEnum
.
h
"
#
include
"
mozilla
/
EndianUtils
.
h
"
#
include
"
mozilla
/
EnumeratedRange
.
h
"
#
include
"
mozilla
/
MacroArgs
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
namespace
mozilla
{
namespace
gfx
{
typedef
float
Float
;
typedef
double
Double
;
enum
class
SurfaceType
:
int8_t
{
DATA
D2D1_BITMAP
D2D1_DRAWTARGET
CAIRO
CAIRO_IMAGE
COREGRAPHICS_IMAGE
COREGRAPHICS_CGCONTEXT
SKIA
DUAL_DT
D2D1_1_IMAGE
RECORDING
WRAP_AND_RECORD
TILED
DATA_SHARED
CAPTURE
DATA_RECYCLING_SHARED
OFFSET
DATA_ALIGNED
}
;
enum
class
SurfaceFormat
:
int8_t
{
B8G8R8A8
B8G8R8X8
R8G8B8A8
R8G8B8X8
A8R8G8B8
X8R8G8B8
R8G8B8
B8G8R8
R5G6B5_UINT16
A8
A16
R8G8
R16G16
YUV
NV12
P016
P010
YUV422
HSV
Lab
Depth
UNKNOWN
#
if
MOZ_LITTLE_ENDIAN
(
)
A8R8G8B8_UINT32
=
B8G8R8A8
X8R8G8B8_UINT32
=
B8G8R8X8
#
elif
MOZ_BIG_ENDIAN
(
)
A8R8G8B8_UINT32
=
A8R8G8B8
X8R8G8B8_UINT32
=
X8R8G8B8
#
else
#
error
"
bad
endianness
"
#
endif
OS_RGBA
=
A8R8G8B8_UINT32
OS_RGBX
=
X8R8G8B8_UINT32
}
;
enum
class
SurfaceFormatBit
:
uint32_t
{
#
if
MOZ_LITTLE_ENDIAN
(
)
R8G8B8A8_R
=
0
R8G8B8A8_G
=
8
R8G8B8A8_B
=
16
R8G8B8A8_A
=
24
#
elif
MOZ_BIG_ENDIAN
(
)
R8G8B8A8_A
=
0
R8G8B8A8_B
=
8
R8G8B8A8_G
=
16
R8G8B8A8_R
=
24
#
else
#
error
"
bad
endianness
"
#
endif
A8R8G8B8_UINT32_B
=
0
A8R8G8B8_UINT32_G
=
8
A8R8G8B8_UINT32_R
=
16
A8R8G8B8_UINT32_A
=
24
OS_R
=
A8R8G8B8_UINT32_R
OS_G
=
A8R8G8B8_UINT32_G
OS_B
=
A8R8G8B8_UINT32_B
OS_A
=
A8R8G8B8_UINT32_A
}
;
inline
uint32_t
operator
<
<
(
uint8_t
a
SurfaceFormatBit
b
)
{
return
a
<
<
static_cast
<
uint32_t
>
(
b
)
;
}
inline
uint32_t
operator
>
>
(
uint32_t
a
SurfaceFormatBit
b
)
{
return
a
>
>
static_cast
<
uint32_t
>
(
b
)
;
}
static
inline
int
BytesPerPixel
(
SurfaceFormat
aFormat
)
{
switch
(
aFormat
)
{
case
SurfaceFormat
:
:
A8
:
return
1
;
case
SurfaceFormat
:
:
R5G6B5_UINT16
:
case
SurfaceFormat
:
:
A16
:
return
2
;
case
SurfaceFormat
:
:
R8G8B8
:
case
SurfaceFormat
:
:
B8G8R8
:
return
3
;
case
SurfaceFormat
:
:
HSV
:
case
SurfaceFormat
:
:
Lab
:
return
3
*
sizeof
(
float
)
;
case
SurfaceFormat
:
:
Depth
:
return
sizeof
(
uint16_t
)
;
default
:
return
4
;
}
}
inline
bool
IsOpaque
(
SurfaceFormat
aFormat
)
{
switch
(
aFormat
)
{
case
SurfaceFormat
:
:
B8G8R8X8
:
case
SurfaceFormat
:
:
R8G8B8X8
:
case
SurfaceFormat
:
:
X8R8G8B8
:
case
SurfaceFormat
:
:
R5G6B5_UINT16
:
case
SurfaceFormat
:
:
R8G8B8
:
case
SurfaceFormat
:
:
B8G8R8
:
case
SurfaceFormat
:
:
R8G8
:
case
SurfaceFormat
:
:
HSV
:
case
SurfaceFormat
:
:
Lab
:
case
SurfaceFormat
:
:
Depth
:
case
SurfaceFormat
:
:
YUV
:
case
SurfaceFormat
:
:
NV12
:
case
SurfaceFormat
:
:
P010
:
case
SurfaceFormat
:
:
P016
:
case
SurfaceFormat
:
:
YUV422
:
return
true
;
default
:
return
false
;
}
}
enum
class
YUVColorSpace
:
uint8_t
{
BT601
BT709
BT2020
UNKNOWN
_NUM_COLORSPACE
}
;
enum
class
ColorDepth
:
uint8_t
{
COLOR_8
COLOR_10
COLOR_12
COLOR_16
UNKNOWN
}
;
enum
class
ColorRange
:
uint8_t
{
LIMITED
FULL
UNKNOWN
}
;
static
inline
SurfaceFormat
SurfaceFormatForColorDepth
(
ColorDepth
aColorDepth
)
{
SurfaceFormat
format
=
SurfaceFormat
:
:
A8
;
switch
(
aColorDepth
)
{
case
ColorDepth
:
:
COLOR_8
:
break
;
case
ColorDepth
:
:
COLOR_10
:
case
ColorDepth
:
:
COLOR_12
:
case
ColorDepth
:
:
COLOR_16
:
format
=
SurfaceFormat
:
:
A16
;
break
;
case
ColorDepth
:
:
UNKNOWN
:
MOZ_ASSERT_UNREACHABLE
(
"
invalid
color
depth
value
"
)
;
}
return
format
;
}
static
inline
uint32_t
BitDepthForColorDepth
(
ColorDepth
aColorDepth
)
{
uint32_t
depth
=
8
;
switch
(
aColorDepth
)
{
case
ColorDepth
:
:
COLOR_8
:
break
;
case
ColorDepth
:
:
COLOR_10
:
depth
=
10
;
break
;
case
ColorDepth
:
:
COLOR_12
:
depth
=
12
;
break
;
case
ColorDepth
:
:
COLOR_16
:
depth
=
16
;
break
;
case
ColorDepth
:
:
UNKNOWN
:
MOZ_ASSERT_UNREACHABLE
(
"
invalid
color
depth
value
"
)
;
}
return
depth
;
}
static
inline
ColorDepth
ColorDepthForBitDepth
(
uint8_t
aBitDepth
)
{
ColorDepth
depth
=
ColorDepth
:
:
COLOR_8
;
switch
(
aBitDepth
)
{
case
8
:
break
;
case
10
:
depth
=
ColorDepth
:
:
COLOR_10
;
break
;
case
12
:
depth
=
ColorDepth
:
:
COLOR_12
;
break
;
case
16
:
depth
=
ColorDepth
:
:
COLOR_16
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
invalid
color
depth
value
"
)
;
}
return
depth
;
}
static
inline
uint32_t
RescalingFactorForColorDepth
(
ColorDepth
aColorDepth
)
{
uint32_t
factor
=
1
;
switch
(
aColorDepth
)
{
case
ColorDepth
:
:
COLOR_8
:
break
;
case
ColorDepth
:
:
COLOR_10
:
factor
=
64
;
break
;
case
ColorDepth
:
:
COLOR_12
:
factor
=
16
;
break
;
case
ColorDepth
:
:
COLOR_16
:
break
;
case
ColorDepth
:
:
UNKNOWN
:
MOZ_ASSERT_UNREACHABLE
(
"
invalid
color
depth
value
"
)
;
}
return
factor
;
}
enum
class
FilterType
:
int8_t
{
BLEND
=
0
TRANSFORM
MORPHOLOGY
COLOR_MATRIX
FLOOD
TILE
TABLE_TRANSFER
DISCRETE_TRANSFER
LINEAR_TRANSFER
GAMMA_TRANSFER
CONVOLVE_MATRIX
DISPLACEMENT_MAP
TURBULENCE
ARITHMETIC_COMBINE
COMPOSITE
DIRECTIONAL_BLUR
GAUSSIAN_BLUR
POINT_DIFFUSE
POINT_SPECULAR
SPOT_DIFFUSE
SPOT_SPECULAR
DISTANT_DIFFUSE
DISTANT_SPECULAR
CROP
PREMULTIPLY
UNPREMULTIPLY
OPACITY
}
;
enum
class
DrawTargetType
:
int8_t
{
SOFTWARE_RASTER
=
0
HARDWARE_RASTER
VECTOR
}
;
enum
class
BackendType
:
int8_t
{
NONE
=
0
DIRECT2D
CAIRO
SKIA
RECORDING
DIRECT2D1_1
WEBRENDER_TEXT
CAPTURE
BACKEND_LAST
}
;
enum
class
FontType
:
int8_t
{
DWRITE
GDI
MAC
FONTCONFIG
FREETYPE
UNKNOWN
}
;
enum
class
NativeSurfaceType
:
int8_t
{
D3D10_TEXTURE
CAIRO_CONTEXT
CGCONTEXT
CGCONTEXT_ACCELERATED
OPENGL_TEXTURE
}
;
enum
class
FontStyle
:
int8_t
{
NORMAL
ITALIC
BOLD
BOLD_ITALIC
}
;
enum
class
FontHinting
:
int8_t
{
NONE
LIGHT
NORMAL
FULL
}
;
enum
class
CompositionOp
:
int8_t
{
OP_OVER
OP_ADD
OP_ATOP
OP_OUT
OP_IN
OP_SOURCE
OP_DEST_IN
OP_DEST_OUT
OP_DEST_OVER
OP_DEST_ATOP
OP_XOR
OP_MULTIPLY
OP_SCREEN
OP_OVERLAY
OP_DARKEN
OP_LIGHTEN
OP_COLOR_DODGE
OP_COLOR_BURN
OP_HARD_LIGHT
OP_SOFT_LIGHT
OP_DIFFERENCE
OP_EXCLUSION
OP_HUE
OP_SATURATION
OP_COLOR
OP_LUMINOSITY
OP_COUNT
}
;
enum
class
Axis
:
int8_t
{
X_AXIS
Y_AXIS
BOTH
}
;
enum
class
ExtendMode
:
int8_t
{
CLAMP
REPEAT
REPEAT_X
REPEAT_Y
REFLECT
}
;
enum
class
FillRule
:
int8_t
{
FILL_WINDING
FILL_EVEN_ODD
}
;
enum
class
AntialiasMode
:
int8_t
{
NONE
GRAY
SUBPIXEL
DEFAULT
}
;
enum
class
SamplingFilter
:
int8_t
{
GOOD
LINEAR
POINT
SENTINEL
}
;
MOZ_DEFINE_ENUM_CLASS_WITH_BASE
(
PatternType
int8_t
(
COLOR
SURFACE
LINEAR_GRADIENT
RADIAL_GRADIENT
CONIC_GRADIENT
)
)
;
enum
class
JoinStyle
:
int8_t
{
BEVEL
ROUND
MITER
MITER_OR_BEVEL
}
;
enum
class
CapStyle
:
int8_t
{
BUTT
ROUND
SQUARE
}
;
enum
class
SamplingBounds
:
int8_t
{
UNBOUNDED
BOUNDED
}
;
enum
class
LuminanceType
:
int8_t
{
LUMINANCE
LINEARRGB
}
;
struct
sRGBColor
{
public
:
sRGBColor
(
)
:
r
(
0
.
0f
)
g
(
0
.
0f
)
b
(
0
.
0f
)
a
(
0
.
0f
)
{
}
sRGBColor
(
Float
aR
Float
aG
Float
aB
Float
aA
)
:
r
(
aR
)
g
(
aG
)
b
(
aB
)
a
(
aA
)
{
}
sRGBColor
(
Float
aR
Float
aG
Float
aB
)
:
r
(
aR
)
g
(
aG
)
b
(
aB
)
a
(
1
.
0f
)
{
}
static
sRGBColor
White
(
float
aA
)
{
return
sRGBColor
(
1
.
f
1
.
f
1
.
f
aA
)
;
}
static
sRGBColor
Black
(
float
aA
)
{
return
sRGBColor
(
0
.
f
0
.
f
0
.
f
aA
)
;
}
static
sRGBColor
OpaqueWhite
(
)
{
return
White
(
1
.
f
)
;
}
static
sRGBColor
OpaqueBlack
(
)
{
return
Black
(
1
.
f
)
;
}
static
sRGBColor
FromU8
(
uint8_t
aR
uint8_t
aG
uint8_t
aB
uint8_t
aA
)
{
return
sRGBColor
(
float
(
aR
)
/
255
.
f
float
(
aG
)
/
255
.
f
float
(
aB
)
/
255
.
f
float
(
aA
)
/
255
.
f
)
;
}
static
sRGBColor
FromABGR
(
uint32_t
aColor
)
{
sRGBColor
newColor
(
(
(
aColor
>
>
0
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
(
(
aColor
>
>
8
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
(
(
aColor
>
>
16
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
(
(
aColor
>
>
24
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
)
;
return
newColor
;
}
static
sRGBColor
UnusualFromARGB
(
uint32_t
aColor
)
{
sRGBColor
newColor
(
(
(
aColor
>
>
16
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
(
(
aColor
>
>
8
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
(
(
aColor
>
>
0
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
(
(
aColor
>
>
24
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
)
;
return
newColor
;
}
uint32_t
ToABGR
(
)
const
{
return
uint32_t
(
r
*
255
.
0f
)
|
uint32_t
(
g
*
255
.
0f
)
<
<
8
|
uint32_t
(
b
*
255
.
0f
)
<
<
16
|
uint32_t
(
a
*
255
.
0f
)
<
<
24
;
}
uint32_t
UnusualToARGB
(
)
const
{
return
uint32_t
(
b
*
255
.
0f
)
|
uint32_t
(
g
*
255
.
0f
)
<
<
8
|
uint32_t
(
r
*
255
.
0f
)
<
<
16
|
uint32_t
(
a
*
255
.
0f
)
<
<
24
;
}
bool
operator
=
=
(
const
sRGBColor
&
aColor
)
const
{
return
r
=
=
aColor
.
r
&
&
g
=
=
aColor
.
g
&
&
b
=
=
aColor
.
b
&
&
a
=
=
aColor
.
a
;
}
bool
operator
!
=
(
const
sRGBColor
&
aColor
)
const
{
return
!
(
*
this
=
=
aColor
)
;
}
Float
r
g
b
a
;
}
;
struct
DeviceColor
{
public
:
DeviceColor
(
)
:
r
(
0
.
0f
)
g
(
0
.
0f
)
b
(
0
.
0f
)
a
(
0
.
0f
)
{
}
DeviceColor
(
Float
aR
Float
aG
Float
aB
Float
aA
)
:
r
(
aR
)
g
(
aG
)
b
(
aB
)
a
(
aA
)
{
}
DeviceColor
(
Float
aR
Float
aG
Float
aB
)
:
r
(
aR
)
g
(
aG
)
b
(
aB
)
a
(
1
.
0f
)
{
}
static
DeviceColor
Mask
(
float
aC
float
aA
)
{
return
DeviceColor
(
aC
aC
aC
aA
)
;
}
static
DeviceColor
MaskWhite
(
float
aA
)
{
return
Mask
(
1
.
f
aA
)
;
}
static
DeviceColor
MaskBlack
(
float
aA
)
{
return
Mask
(
0
.
f
aA
)
;
}
static
DeviceColor
MaskOpaqueWhite
(
)
{
return
MaskWhite
(
1
.
f
)
;
}
static
DeviceColor
MaskOpaqueBlack
(
)
{
return
MaskBlack
(
1
.
f
)
;
}
static
DeviceColor
FromU8
(
uint8_t
aR
uint8_t
aG
uint8_t
aB
uint8_t
aA
)
{
return
DeviceColor
(
float
(
aR
)
/
255
.
f
float
(
aG
)
/
255
.
f
float
(
aB
)
/
255
.
f
float
(
aA
)
/
255
.
f
)
;
}
static
DeviceColor
FromABGR
(
uint32_t
aColor
)
{
DeviceColor
newColor
(
(
(
aColor
>
>
0
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
(
(
aColor
>
>
8
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
(
(
aColor
>
>
16
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
(
(
aColor
>
>
24
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
)
;
return
newColor
;
}
static
DeviceColor
UnusualFromARGB
(
uint32_t
aColor
)
{
DeviceColor
newColor
(
(
(
aColor
>
>
16
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
(
(
aColor
>
>
8
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
(
(
aColor
>
>
0
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
(
(
aColor
>
>
24
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
)
;
return
newColor
;
}
uint32_t
ToABGR
(
)
const
{
return
uint32_t
(
r
*
255
.
0f
)
|
uint32_t
(
g
*
255
.
0f
)
<
<
8
|
uint32_t
(
b
*
255
.
0f
)
<
<
16
|
uint32_t
(
a
*
255
.
0f
)
<
<
24
;
}
uint32_t
UnusualToARGB
(
)
const
{
return
uint32_t
(
b
*
255
.
0f
)
|
uint32_t
(
g
*
255
.
0f
)
<
<
8
|
uint32_t
(
r
*
255
.
0f
)
<
<
16
|
uint32_t
(
a
*
255
.
0f
)
<
<
24
;
}
bool
operator
=
=
(
const
DeviceColor
&
aColor
)
const
{
return
r
=
=
aColor
.
r
&
&
g
=
=
aColor
.
g
&
&
b
=
=
aColor
.
b
&
&
a
=
=
aColor
.
a
;
}
bool
operator
!
=
(
const
DeviceColor
&
aColor
)
const
{
return
!
(
*
this
=
=
aColor
)
;
}
Float
r
g
b
a
;
}
;
struct
GradientStop
{
bool
operator
<
(
const
GradientStop
&
aOther
)
const
{
return
offset
<
aOther
.
offset
;
}
Float
offset
;
DeviceColor
color
;
}
;
enum
class
JobStatus
{
Complete
Wait
Yield
Error
}
;
}
}
typedef
mozilla
:
:
gfx
:
:
SurfaceFormat
gfxImageFormat
;
#
if
defined
(
XP_WIN
)
&
&
defined
(
MOZ_GFX
)
#
ifdef
GFX2D_INTERNAL
#
define
GFX2D_API
__declspec
(
dllexport
)
#
else
#
define
GFX2D_API
__declspec
(
dllimport
)
#
endif
#
else
#
define
GFX2D_API
#
endif
namespace
mozilla
{
enum
Side
:
uint8_t
{
eSideTop
eSideRight
eSideBottom
eSideLeft
}
;
constexpr
auto
AllPhysicalSides
(
)
{
return
mozilla
:
:
MakeInclusiveEnumeratedRange
(
eSideTop
eSideLeft
)
;
}
enum
class
SideBits
{
eNone
=
0
eTop
=
1
<
<
eSideTop
eRight
=
1
<
<
eSideRight
eBottom
=
1
<
<
eSideBottom
eLeft
=
1
<
<
eSideLeft
eTopBottom
=
SideBits
:
:
eTop
|
SideBits
:
:
eBottom
eLeftRight
=
SideBits
:
:
eLeft
|
SideBits
:
:
eRight
eAll
=
SideBits
:
:
eTopBottom
|
SideBits
:
:
eLeftRight
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
SideBits
)
enum
Corner
:
uint8_t
{
eCornerTopLeft
=
0
eCornerTopRight
=
1
eCornerBottomRight
=
2
eCornerBottomLeft
=
3
}
;
constexpr
int
eCornerCount
=
4
;
constexpr
auto
AllPhysicalCorners
(
)
{
return
mozilla
:
:
MakeInclusiveEnumeratedRange
(
eCornerTopLeft
eCornerBottomLeft
)
;
}
enum
HalfCorner
:
uint8_t
{
eCornerTopLeftX
=
0
eCornerTopLeftY
=
1
eCornerTopRightX
=
2
eCornerTopRightY
=
3
eCornerBottomRightX
=
4
eCornerBottomRightY
=
5
eCornerBottomLeftX
=
6
eCornerBottomLeftY
=
7
}
;
constexpr
auto
AllPhysicalHalfCorners
(
)
{
return
mozilla
:
:
MakeInclusiveEnumeratedRange
(
eCornerTopLeftX
eCornerBottomLeftY
)
;
}
constexpr
bool
HalfCornerIsX
(
HalfCorner
aHalfCorner
)
{
return
!
(
aHalfCorner
%
2
)
;
}
constexpr
Corner
HalfToFullCorner
(
HalfCorner
aHalfCorner
)
{
return
Corner
(
aHalfCorner
/
2
)
;
}
constexpr
HalfCorner
FullToHalfCorner
(
Corner
aCorner
bool
aIsVertical
)
{
return
HalfCorner
(
aCorner
*
2
+
aIsVertical
)
;
}
constexpr
bool
SideIsVertical
(
Side
aSide
)
{
return
aSide
%
2
;
}
constexpr
Corner
SideToFullCorner
(
Side
aSide
bool
aIsSecond
)
{
return
Corner
(
(
aSide
+
aIsSecond
)
%
4
)
;
}
constexpr
HalfCorner
SideToHalfCorner
(
Side
aSide
bool
aIsSecond
bool
aIsParallel
)
{
return
HalfCorner
(
(
(
aSide
+
aIsSecond
)
*
2
+
(
aSide
+
!
aIsParallel
)
%
2
)
%
8
)
;
}
}
#
endif
