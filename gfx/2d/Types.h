#
ifndef
MOZILLA_GFX_TYPES_H_
#
define
MOZILLA_GFX_TYPES_H_
#
include
"
mozilla
/
EndianUtils
.
h
"
#
include
"
mozilla
/
MacroArgs
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
namespace
mozilla
{
namespace
gfx
{
typedef
float
Float
;
typedef
double
Double
;
enum
class
SurfaceType
:
int8_t
{
DATA
D2D1_BITMAP
D2D1_DRAWTARGET
CAIRO
CAIRO_IMAGE
COREGRAPHICS_IMAGE
COREGRAPHICS_CGCONTEXT
SKIA
DUAL_DT
D2D1_1_IMAGE
RECORDING
TILED
DATA_SHARED
CAPTURE
DATA_RECYCLING_SHARED
OFFSET
}
;
enum
class
SurfaceFormat
:
int8_t
{
B8G8R8A8
B8G8R8X8
R8G8B8A8
R8G8B8X8
A8R8G8B8
X8R8G8B8
R8G8B8
B8G8R8
R5G6B5_UINT16
A8
A16
R8G8
YUV
NV12
P016
P010
YUV422
HSV
Lab
Depth
UNKNOWN
#
if
MOZ_LITTLE_ENDIAN
A8R8G8B8_UINT32
=
B8G8R8A8
X8R8G8B8_UINT32
=
B8G8R8X8
#
elif
MOZ_BIG_ENDIAN
A8R8G8B8_UINT32
=
A8R8G8B8
X8R8G8B8_UINT32
=
X8R8G8B8
#
else
#
error
"
bad
endianness
"
#
endif
}
;
static
inline
int
BytesPerPixel
(
SurfaceFormat
aFormat
)
{
switch
(
aFormat
)
{
case
SurfaceFormat
:
:
A8
:
return
1
;
case
SurfaceFormat
:
:
R5G6B5_UINT16
:
case
SurfaceFormat
:
:
A16
:
return
2
;
case
SurfaceFormat
:
:
R8G8B8
:
case
SurfaceFormat
:
:
B8G8R8
:
return
3
;
case
SurfaceFormat
:
:
HSV
:
case
SurfaceFormat
:
:
Lab
:
return
3
*
sizeof
(
float
)
;
case
SurfaceFormat
:
:
Depth
:
return
sizeof
(
uint16_t
)
;
default
:
return
4
;
}
}
inline
bool
IsOpaque
(
SurfaceFormat
aFormat
)
{
switch
(
aFormat
)
{
case
SurfaceFormat
:
:
B8G8R8X8
:
case
SurfaceFormat
:
:
R8G8B8X8
:
case
SurfaceFormat
:
:
X8R8G8B8
:
case
SurfaceFormat
:
:
R5G6B5_UINT16
:
case
SurfaceFormat
:
:
R8G8B8
:
case
SurfaceFormat
:
:
B8G8R8
:
case
SurfaceFormat
:
:
R8G8
:
case
SurfaceFormat
:
:
HSV
:
case
SurfaceFormat
:
:
Lab
:
case
SurfaceFormat
:
:
Depth
:
case
SurfaceFormat
:
:
YUV
:
case
SurfaceFormat
:
:
NV12
:
case
SurfaceFormat
:
:
P010
:
case
SurfaceFormat
:
:
P016
:
case
SurfaceFormat
:
:
YUV422
:
return
true
;
default
:
return
false
;
}
}
enum
class
YUVColorSpace
:
uint8_t
{
BT601
BT709
BT2020
UNKNOWN
_NUM_COLORSPACE
}
;
enum
class
ColorDepth
:
uint8_t
{
COLOR_8
COLOR_10
COLOR_12
COLOR_16
UNKNOWN
}
;
static
inline
SurfaceFormat
SurfaceFormatForColorDepth
(
ColorDepth
aColorDepth
)
{
SurfaceFormat
format
=
SurfaceFormat
:
:
A8
;
switch
(
aColorDepth
)
{
case
ColorDepth
:
:
COLOR_8
:
break
;
case
ColorDepth
:
:
COLOR_10
:
case
ColorDepth
:
:
COLOR_12
:
case
ColorDepth
:
:
COLOR_16
:
format
=
SurfaceFormat
:
:
A16
;
break
;
case
ColorDepth
:
:
UNKNOWN
:
MOZ_ASSERT_UNREACHABLE
(
"
invalid
color
depth
value
"
)
;
}
return
format
;
}
static
inline
uint32_t
BitDepthForColorDepth
(
ColorDepth
aColorDepth
)
{
uint32_t
depth
=
8
;
switch
(
aColorDepth
)
{
case
ColorDepth
:
:
COLOR_8
:
break
;
case
ColorDepth
:
:
COLOR_10
:
depth
=
10
;
break
;
case
ColorDepth
:
:
COLOR_12
:
depth
=
12
;
break
;
case
ColorDepth
:
:
COLOR_16
:
depth
=
16
;
break
;
case
ColorDepth
:
:
UNKNOWN
:
MOZ_ASSERT_UNREACHABLE
(
"
invalid
color
depth
value
"
)
;
}
return
depth
;
}
static
inline
ColorDepth
ColorDepthForBitDepth
(
uint8_t
aBitDepth
)
{
ColorDepth
depth
=
ColorDepth
:
:
COLOR_8
;
switch
(
aBitDepth
)
{
case
8
:
break
;
case
10
:
depth
=
ColorDepth
:
:
COLOR_10
;
break
;
case
12
:
depth
=
ColorDepth
:
:
COLOR_12
;
break
;
case
16
:
depth
=
ColorDepth
:
:
COLOR_16
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
invalid
color
depth
value
"
)
;
}
return
depth
;
}
static
inline
uint32_t
RescalingFactorForColorDepth
(
ColorDepth
aColorDepth
)
{
uint32_t
factor
=
1
;
switch
(
aColorDepth
)
{
case
ColorDepth
:
:
COLOR_8
:
break
;
case
ColorDepth
:
:
COLOR_10
:
factor
=
64
;
break
;
case
ColorDepth
:
:
COLOR_12
:
factor
=
16
;
break
;
case
ColorDepth
:
:
COLOR_16
:
break
;
case
ColorDepth
:
:
UNKNOWN
:
MOZ_ASSERT_UNREACHABLE
(
"
invalid
color
depth
value
"
)
;
}
return
factor
;
}
enum
class
FilterType
:
int8_t
{
BLEND
=
0
TRANSFORM
MORPHOLOGY
COLOR_MATRIX
FLOOD
TILE
TABLE_TRANSFER
DISCRETE_TRANSFER
LINEAR_TRANSFER
GAMMA_TRANSFER
CONVOLVE_MATRIX
DISPLACEMENT_MAP
TURBULENCE
ARITHMETIC_COMBINE
COMPOSITE
DIRECTIONAL_BLUR
GAUSSIAN_BLUR
POINT_DIFFUSE
POINT_SPECULAR
SPOT_DIFFUSE
SPOT_SPECULAR
DISTANT_DIFFUSE
DISTANT_SPECULAR
CROP
PREMULTIPLY
UNPREMULTIPLY
OPACITY
}
;
enum
class
DrawTargetType
:
int8_t
{
SOFTWARE_RASTER
=
0
HARDWARE_RASTER
VECTOR
}
;
enum
class
BackendType
:
int8_t
{
NONE
=
0
DIRECT2D
CAIRO
SKIA
RECORDING
DIRECT2D1_1
WEBRENDER_TEXT
CAPTURE
BACKEND_LAST
}
;
enum
class
FontType
:
int8_t
{
DWRITE
GDI
MAC
FONTCONFIG
FREETYPE
UNKNOWN
}
;
enum
class
NativeSurfaceType
:
int8_t
{
D3D10_TEXTURE
CAIRO_CONTEXT
CGCONTEXT
CGCONTEXT_ACCELERATED
OPENGL_TEXTURE
}
;
enum
class
NativeFontType
:
int8_t
{
GDI_LOGFONT
FREETYPE_FACE
FONTCONFIG_PATTERN
}
;
enum
class
FontStyle
:
int8_t
{
NORMAL
ITALIC
BOLD
BOLD_ITALIC
}
;
enum
class
FontHinting
:
int8_t
{
NONE
LIGHT
NORMAL
FULL
}
;
enum
class
CompositionOp
:
int8_t
{
OP_OVER
OP_ADD
OP_ATOP
OP_OUT
OP_IN
OP_SOURCE
OP_DEST_IN
OP_DEST_OUT
OP_DEST_OVER
OP_DEST_ATOP
OP_XOR
OP_MULTIPLY
OP_SCREEN
OP_OVERLAY
OP_DARKEN
OP_LIGHTEN
OP_COLOR_DODGE
OP_COLOR_BURN
OP_HARD_LIGHT
OP_SOFT_LIGHT
OP_DIFFERENCE
OP_EXCLUSION
OP_HUE
OP_SATURATION
OP_COLOR
OP_LUMINOSITY
OP_COUNT
}
;
enum
class
Axis
:
int8_t
{
X_AXIS
Y_AXIS
BOTH
}
;
enum
class
ExtendMode
:
int8_t
{
CLAMP
REPEAT
REPEAT_X
REPEAT_Y
REFLECT
}
;
enum
class
FillRule
:
int8_t
{
FILL_WINDING
FILL_EVEN_ODD
}
;
enum
class
AntialiasMode
:
int8_t
{
NONE
GRAY
SUBPIXEL
DEFAULT
}
;
enum
class
SamplingFilter
:
int8_t
{
GOOD
LINEAR
POINT
SENTINEL
}
;
enum
class
PatternType
:
int8_t
{
COLOR
SURFACE
LINEAR_GRADIENT
RADIAL_GRADIENT
}
;
enum
class
JoinStyle
:
int8_t
{
BEVEL
ROUND
MITER
MITER_OR_BEVEL
}
;
enum
class
CapStyle
:
int8_t
{
BUTT
ROUND
SQUARE
}
;
enum
class
SamplingBounds
:
int8_t
{
UNBOUNDED
BOUNDED
}
;
enum
class
LuminanceType
:
int8_t
{
LUMINANCE
LINEARRGB
}
;
struct
Color
{
public
:
Color
(
)
:
r
(
0
.
0f
)
g
(
0
.
0f
)
b
(
0
.
0f
)
a
(
0
.
0f
)
{
}
Color
(
Float
aR
Float
aG
Float
aB
Float
aA
)
:
r
(
aR
)
g
(
aG
)
b
(
aB
)
a
(
aA
)
{
}
Color
(
Float
aR
Float
aG
Float
aB
)
:
r
(
aR
)
g
(
aG
)
b
(
aB
)
a
(
1
.
0f
)
{
}
static
Color
FromABGR
(
uint32_t
aColor
)
{
Color
newColor
(
(
(
aColor
>
>
0
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
(
(
aColor
>
>
8
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
(
(
aColor
>
>
16
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
(
(
aColor
>
>
24
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
)
;
return
newColor
;
}
static
Color
UnusualFromARGB
(
uint32_t
aColor
)
{
Color
newColor
(
(
(
aColor
>
>
16
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
(
(
aColor
>
>
8
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
(
(
aColor
>
>
0
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
(
(
aColor
>
>
24
)
&
0xff
)
*
(
1
.
0f
/
255
.
0f
)
)
;
return
newColor
;
}
uint32_t
ToABGR
(
)
const
{
return
uint32_t
(
r
*
255
.
0f
)
|
uint32_t
(
g
*
255
.
0f
)
<
<
8
|
uint32_t
(
b
*
255
.
0f
)
<
<
16
|
uint32_t
(
a
*
255
.
0f
)
<
<
24
;
}
uint32_t
UnusualToARGB
(
)
const
{
return
uint32_t
(
b
*
255
.
0f
)
|
uint32_t
(
g
*
255
.
0f
)
<
<
8
|
uint32_t
(
r
*
255
.
0f
)
<
<
16
|
uint32_t
(
a
*
255
.
0f
)
<
<
24
;
}
bool
operator
=
=
(
const
Color
&
aColor
)
const
{
return
r
=
=
aColor
.
r
&
&
g
=
=
aColor
.
g
&
&
b
=
=
aColor
.
b
&
&
a
=
=
aColor
.
a
;
}
bool
operator
!
=
(
const
Color
&
aColor
)
const
{
return
!
(
*
this
=
=
aColor
)
;
}
Float
r
g
b
a
;
}
;
struct
GradientStop
{
bool
operator
<
(
const
GradientStop
&
aOther
)
const
{
return
offset
<
aOther
.
offset
;
}
Float
offset
;
Color
color
;
}
;
enum
class
JobStatus
{
Complete
Wait
Yield
Error
}
;
}
}
typedef
mozilla
:
:
gfx
:
:
SurfaceFormat
gfxImageFormat
;
#
if
defined
(
XP_WIN
)
&
&
defined
(
MOZ_GFX
)
#
ifdef
GFX2D_INTERNAL
#
define
GFX2D_API
__declspec
(
dllexport
)
#
else
#
define
GFX2D_API
__declspec
(
dllimport
)
#
endif
#
else
#
define
GFX2D_API
#
endif
namespace
mozilla
{
enum
Side
{
eSideTop
eSideRight
eSideBottom
eSideLeft
}
;
enum
SideBits
{
eSideBitsNone
=
0
eSideBitsTop
=
1
<
<
eSideTop
eSideBitsRight
=
1
<
<
eSideRight
eSideBitsBottom
=
1
<
<
eSideBottom
eSideBitsLeft
=
1
<
<
eSideLeft
eSideBitsTopBottom
=
eSideBitsTop
|
eSideBitsBottom
eSideBitsLeftRight
=
eSideBitsLeft
|
eSideBitsRight
eSideBitsAll
=
eSideBitsTopBottom
|
eSideBitsLeftRight
}
;
#
define
NS_FOR_CSS_SIDES
(
var_
)
\
int32_t
MOZ_CONCAT
(
var_
__LINE__
)
=
mozilla
:
:
eSideTop
;
\
for
(
mozilla
:
:
Side
var_
;
\
MOZ_CONCAT
(
var_
__LINE__
)
<
=
mozilla
:
:
eSideLeft
&
&
\
(
static_cast
<
void
>
(
var_
=
mozilla
:
:
Side
(
MOZ_CONCAT
(
var_
__LINE__
)
)
)
\
true
)
;
\
+
+
MOZ_CONCAT
(
var_
__LINE__
)
)
static
inline
Side
&
operator
+
+
(
Side
&
side
)
{
MOZ_ASSERT
(
side
>
=
eSideTop
&
&
side
<
=
eSideLeft
"
Out
of
range
side
"
)
;
side
=
Side
(
side
+
1
)
;
return
side
;
}
enum
Corner
{
eCornerTopLeft
=
0
eCornerTopRight
=
1
eCornerBottomRight
=
2
eCornerBottomLeft
=
3
}
;
constexpr
int
eCornerCount
=
4
;
#
define
NS_FOR_CSS_FULL_CORNERS
(
var_
)
\
int32_t
MOZ_CONCAT
(
var_
__LINE__
)
=
mozilla
:
:
eCornerTopLeft
;
\
for
(
mozilla
:
:
Corner
var_
;
\
MOZ_CONCAT
(
var_
__LINE__
)
<
=
mozilla
:
:
eCornerBottomLeft
&
&
\
(
static_cast
<
void
>
(
var_
=
mozilla
:
:
Corner
(
MOZ_CONCAT
(
var_
__LINE__
)
)
)
\
true
)
;
\
+
+
MOZ_CONCAT
(
var_
__LINE__
)
)
static
inline
Corner
operator
+
+
(
Corner
&
aCorner
)
{
MOZ_ASSERT
(
aCorner
>
=
eCornerTopLeft
&
&
aCorner
<
=
eCornerBottomLeft
"
Out
of
range
corner
!
"
)
;
aCorner
=
Corner
(
aCorner
+
1
)
;
return
aCorner
;
}
enum
HalfCorner
:
uint8_t
{
eCornerTopLeftX
=
0
eCornerTopLeftY
=
1
eCornerTopRightX
=
2
eCornerTopRightY
=
3
eCornerBottomRightX
=
4
eCornerBottomRightY
=
5
eCornerBottomLeftX
=
6
eCornerBottomLeftY
=
7
}
;
#
define
NS_FOR_CSS_HALF_CORNERS
(
var_
)
\
int32_t
MOZ_CONCAT
(
var_
__LINE__
)
=
mozilla
:
:
eCornerTopLeftX
;
\
for
(
mozilla
:
:
HalfCorner
var_
;
\
MOZ_CONCAT
(
var_
__LINE__
)
<
=
mozilla
:
:
eCornerBottomLeftY
&
&
\
(
static_cast
<
void
>
(
\
var_
=
mozilla
:
:
HalfCorner
(
MOZ_CONCAT
(
var_
__LINE__
)
)
)
\
true
)
;
\
+
+
MOZ_CONCAT
(
var_
__LINE__
)
)
static
inline
HalfCorner
operator
+
+
(
HalfCorner
&
aHalfCorner
)
{
MOZ_ASSERT
(
aHalfCorner
>
=
eCornerTopLeftX
&
&
aHalfCorner
<
=
eCornerBottomLeftY
"
Out
of
range
half
corner
!
"
)
;
aHalfCorner
=
HalfCorner
(
aHalfCorner
+
1
)
;
return
aHalfCorner
;
}
constexpr
bool
HalfCornerIsX
(
HalfCorner
aHalfCorner
)
{
return
!
(
aHalfCorner
%
2
)
;
}
constexpr
Corner
HalfToFullCorner
(
HalfCorner
aHalfCorner
)
{
return
Corner
(
aHalfCorner
/
2
)
;
}
constexpr
HalfCorner
FullToHalfCorner
(
Corner
aCorner
bool
aIsVertical
)
{
return
HalfCorner
(
aCorner
*
2
+
aIsVertical
)
;
}
constexpr
bool
SideIsVertical
(
Side
aSide
)
{
return
aSide
%
2
;
}
constexpr
Corner
SideToFullCorner
(
Side
aSide
bool
aIsSecond
)
{
return
Corner
(
(
aSide
+
aIsSecond
)
%
4
)
;
}
constexpr
HalfCorner
SideToHalfCorner
(
Side
aSide
bool
aIsSecond
bool
aIsParallel
)
{
return
HalfCorner
(
(
(
aSide
+
aIsSecond
)
*
2
+
(
aSide
+
!
aIsParallel
)
%
2
)
%
8
)
;
}
}
#
endif
