#
include
"
InlineTranslator
.
h
"
#
include
"
RecordedEventImpl
.
h
"
#
include
"
DrawEventRecorder
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
mozilla
/
gfx
/
RecordingTypes
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
namespace
gfx
{
InlineTranslator
:
:
InlineTranslator
(
DrawTarget
*
aDT
void
*
aFontContext
)
:
mBaseDT
(
aDT
)
mFontContext
(
aFontContext
)
{
}
bool
InlineTranslator
:
:
TranslateRecording
(
char
*
aData
size_t
aLen
)
{
struct
MemReader
{
MemReader
(
char
*
aData
size_t
aLen
)
:
mData
(
aData
)
mEnd
(
aData
+
aLen
)
{
}
void
read
(
char
*
s
streamsize
n
)
{
if
(
n
<
=
(
mEnd
-
mData
)
)
{
memcpy
(
s
mData
n
)
;
mData
+
=
n
;
}
else
{
mData
=
mEnd
+
1
;
}
}
bool
eof
(
)
{
return
mData
>
mEnd
;
}
bool
good
(
)
{
return
!
eof
(
)
;
}
char
*
mData
;
char
*
mEnd
;
}
;
MemReader
reader
(
aData
aLen
)
;
uint32_t
magicInt
;
ReadElement
(
reader
magicInt
)
;
if
(
magicInt
!
=
mozilla
:
:
gfx
:
:
kMagicInt
)
{
return
false
;
}
uint16_t
majorRevision
;
ReadElement
(
reader
majorRevision
)
;
if
(
majorRevision
!
=
kMajorRevision
)
{
return
false
;
}
uint16_t
minorRevision
;
ReadElement
(
reader
minorRevision
)
;
if
(
minorRevision
>
kMinorRevision
)
{
return
false
;
}
int32_t
eventType
;
ReadElement
(
reader
eventType
)
;
while
(
reader
.
good
(
)
)
{
UniquePtr
<
RecordedEvent
>
recordedEvent
(
RecordedEvent
:
:
LoadEvent
(
reader
static_cast
<
RecordedEvent
:
:
EventType
>
(
eventType
)
)
)
;
if
(
!
reader
.
good
(
)
|
|
!
recordedEvent
)
{
return
false
;
}
if
(
!
recordedEvent
-
>
PlayEvent
(
this
)
)
{
return
false
;
}
ReadElement
(
reader
eventType
)
;
}
return
true
;
}
already_AddRefed
<
DrawTarget
>
InlineTranslator
:
:
CreateDrawTarget
(
ReferencePtr
aRefPtr
const
gfx
:
:
IntSize
&
aSize
gfx
:
:
SurfaceFormat
aFormat
)
{
RefPtr
<
DrawTarget
>
drawTarget
=
mBaseDT
;
AddDrawTarget
(
aRefPtr
drawTarget
)
;
return
drawTarget
.
forget
(
)
;
}
}
}
