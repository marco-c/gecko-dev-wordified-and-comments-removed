#
ifndef
MOZILLA_GFX_DRAWEVENTRECORDER_H_
#
define
MOZILLA_GFX_DRAWEVENTRECORDER_H_
#
include
"
2D
.
h
"
#
include
"
RecordedEvent
.
h
"
#
include
<
ostream
>
#
include
<
fstream
>
#
if
defined
(
_MSC_VER
)
#
include
<
unordered_set
>
#
else
#
include
<
set
>
#
endif
namespace
mozilla
{
namespace
gfx
{
class
PathRecording
;
class
DrawEventRecorderPrivate
:
public
DrawEventRecorder
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
DrawEventRecorderPrivate
)
explicit
DrawEventRecorderPrivate
(
std
:
:
ostream
*
aStream
)
;
virtual
~
DrawEventRecorderPrivate
(
)
{
}
virtual
void
Finish
(
)
{
for
(
auto
font
=
mStoredFonts
.
begin
(
)
;
font
!
=
mStoredFonts
.
end
(
)
;
)
{
auto
oldFont
=
font
+
+
;
(
*
oldFont
)
-
>
RemoveUserData
(
reinterpret_cast
<
UserDataKey
*
>
(
this
)
)
;
}
for
(
auto
surface
=
mStoredSurfaces
.
begin
(
)
;
surface
!
=
mStoredSurfaces
.
end
(
)
;
)
{
auto
oldSurface
=
surface
+
+
;
(
*
oldSurface
)
-
>
RemoveUserData
(
reinterpret_cast
<
UserDataKey
*
>
(
this
)
)
;
}
}
void
WriteHeader
(
)
;
void
RecordEvent
(
const
RecordedEvent
&
aEvent
)
;
void
WritePath
(
const
PathRecording
*
aPath
)
;
void
AddStoredObject
(
const
ReferencePtr
aObject
)
{
mStoredObjects
.
insert
(
aObject
)
;
}
void
RemoveStoredObject
(
const
ReferencePtr
aObject
)
{
mStoredObjects
.
erase
(
aObject
)
;
}
void
AddScaledFont
(
ScaledFont
*
aFont
)
{
mStoredFonts
.
insert
(
aFont
)
;
}
void
RemoveScaledFont
(
ScaledFont
*
aFont
)
{
mStoredFonts
.
erase
(
aFont
)
;
}
void
AddSourceSurface
(
SourceSurface
*
aSurface
)
{
mStoredSurfaces
.
insert
(
aSurface
)
;
}
void
RemoveSourceSurface
(
SourceSurface
*
aSurface
)
{
mStoredSurfaces
.
erase
(
aSurface
)
;
}
bool
HasStoredObject
(
const
ReferencePtr
aObject
)
{
return
mStoredObjects
.
find
(
aObject
)
!
=
mStoredObjects
.
end
(
)
;
}
void
AddStoredFontData
(
const
uint64_t
aFontDataKey
)
{
mStoredFontData
.
insert
(
aFontDataKey
)
;
}
bool
HasStoredFontData
(
const
uint64_t
aFontDataKey
)
{
return
mStoredFontData
.
find
(
aFontDataKey
)
!
=
mStoredFontData
.
end
(
)
;
}
protected
:
std
:
:
ostream
*
mOutputStream
;
virtual
void
Flush
(
)
=
0
;
#
if
defined
(
_MSC_VER
)
typedef
std
:
:
unordered_set
<
const
void
*
>
ObjectSet
;
typedef
std
:
:
unordered_set
<
uint64_t
>
Uint64Set
;
typedef
std
:
:
unordered_set
<
ScaledFont
*
>
FontSet
;
typedef
std
:
:
unordered_set
<
SourceSurface
*
>
SurfaceSet
;
#
else
typedef
std
:
:
set
<
const
void
*
>
ObjectSet
;
typedef
std
:
:
set
<
uint64_t
>
Uint64Set
;
typedef
std
:
:
set
<
ScaledFont
*
>
FontSet
;
typedef
std
:
:
set
<
SourceSurface
*
>
SurfaceSet
;
#
endif
ObjectSet
mStoredObjects
;
Uint64Set
mStoredFontData
;
FontSet
mStoredFonts
;
SurfaceSet
mStoredSurfaces
;
}
;
class
DrawEventRecorderFile
:
public
DrawEventRecorderPrivate
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
DrawEventRecorderFile
)
explicit
DrawEventRecorderFile
(
const
char
*
aFilename
)
;
~
DrawEventRecorderFile
(
)
;
bool
IsOpen
(
)
;
void
OpenNew
(
const
char
*
aFilename
)
;
void
Close
(
)
;
private
:
virtual
void
Flush
(
)
;
std
:
:
ofstream
mOutputFile
;
}
;
class
DrawEventRecorderMemory
final
:
public
DrawEventRecorderPrivate
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
DrawEventRecorderMemory
)
DrawEventRecorderMemory
(
)
;
size_t
RecordingSize
(
)
;
bool
CopyRecording
(
char
*
aBuffer
size_t
aBufferLen
)
;
void
WipeRecording
(
)
;
std
:
:
istream
&
GetInputStream
(
)
{
mMemoryStream
.
seekg
(
0
)
;
return
mMemoryStream
;
}
private
:
~
DrawEventRecorderMemory
(
)
{
}
;
void
Flush
(
)
final
;
std
:
:
stringstream
mMemoryStream
;
}
;
}
}
#
endif
