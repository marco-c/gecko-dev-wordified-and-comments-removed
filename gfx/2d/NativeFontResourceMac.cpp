#
include
<
unordered_map
>
#
include
<
unordered_set
>
#
include
"
NativeFontResourceMac
.
h
"
#
include
"
UnscaledFontMac
.
h
"
#
include
"
Types
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
ifdef
MOZ_WIDGET_UIKIT
#
include
<
CoreFoundation
/
CoreFoundation
.
h
>
#
endif
#
include
"
nsIMemoryReporter
.
h
"
namespace
mozilla
{
namespace
gfx
{
#
define
FONT_NAME_MAX
32
MOZ_RUNINIT
static
StaticDataMutex
<
std
:
:
unordered_map
<
void
*
nsAutoCStringN
<
FONT_NAME_MAX
>
>
>
sWeakFontDataMap
(
"
WeakFonts
"
)
;
void
FontDataDeallocate
(
void
*
void
*
info
)
{
auto
fontMap
=
sWeakFontDataMap
.
Lock
(
)
;
fontMap
-
>
erase
(
info
)
;
free
(
info
)
;
}
class
NativeFontResourceMacReporter
final
:
public
nsIMemoryReporter
{
~
NativeFontResourceMacReporter
(
)
=
default
;
MOZ_DEFINE_MALLOC_SIZE_OF
(
MallocSizeOf
)
public
:
NS_DECL_ISUPPORTS
NS_IMETHOD
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
override
{
auto
fontMap
=
sWeakFontDataMap
.
Lock
(
)
;
nsAutoCString
path
(
"
explicit
/
gfx
/
native
-
font
-
resource
-
mac
/
font
(
"
)
;
unsigned
int
unknownFontIndex
=
0
;
for
(
auto
&
i
:
*
fontMap
)
{
nsAutoCString
subPath
(
path
)
;
if
(
aAnonymize
)
{
subPath
.
AppendPrintf
(
"
<
anonymized
-
%
p
>
"
this
)
;
}
else
{
if
(
i
.
second
.
Length
(
)
)
{
subPath
.
AppendLiteral
(
"
psname
=
"
)
;
subPath
.
Append
(
i
.
second
)
;
}
else
{
subPath
.
AppendPrintf
(
"
Unknown
(
%
d
)
"
unknownFontIndex
)
;
}
}
size_t
bytes
=
MallocSizeOf
(
i
.
first
)
+
FONT_NAME_MAX
;
subPath
.
Append
(
"
)
"
)
;
aHandleReport
-
>
Callback
(
"
"
_ns
subPath
KIND_HEAP
UNITS_BYTES
bytes
"
Memory
used
by
this
native
font
.
"
_ns
aData
)
;
unknownFontIndex
+
+
;
}
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
NativeFontResourceMacReporter
nsIMemoryReporter
)
void
NativeFontResourceMac
:
:
RegisterMemoryReporter
(
)
{
RegisterStrongMemoryReporter
(
new
NativeFontResourceMacReporter
)
;
}
already_AddRefed
<
NativeFontResourceMac
>
NativeFontResourceMac
:
:
Create
(
uint8_t
*
aFontData
uint32_t
aDataLength
)
{
uint8_t
*
fontData
=
(
uint8_t
*
)
malloc
(
aDataLength
)
;
if
(
!
fontData
)
{
return
nullptr
;
}
memcpy
(
fontData
aFontData
aDataLength
)
;
CFAllocatorContext
context
=
{
0
fontData
nullptr
nullptr
nullptr
nullptr
nullptr
FontDataDeallocate
nullptr
}
;
CFAllocatorRef
allocator
=
CFAllocatorCreate
(
kCFAllocatorDefault
&
context
)
;
CFDataRef
data
=
CFDataCreateWithBytesNoCopy
(
kCFAllocatorDefault
fontData
aDataLength
allocator
)
;
if
(
!
data
)
{
free
(
fontData
)
;
return
nullptr
;
}
CTFontDescriptorRef
ctFontDesc
=
CTFontManagerCreateFontDescriptorFromData
(
data
)
;
if
(
!
ctFontDesc
)
{
CFRelease
(
data
)
;
return
nullptr
;
}
CTFontRef
ctFont
=
CTFontCreateWithFontDescriptor
(
ctFontDesc
0
NULL
)
;
CGFontRef
fontRef
=
CTFontCopyGraphicsFont
(
ctFont
NULL
)
;
CFRelease
(
ctFont
)
;
if
(
!
fontRef
)
{
CFRelease
(
data
)
;
CFRelease
(
ctFontDesc
)
;
return
nullptr
;
}
nsAutoCStringN
<
FONT_NAME_MAX
>
fontName
;
CFStringRef
psname
=
CGFontCopyPostScriptName
(
fontRef
)
;
if
(
psname
)
{
const
char
*
cstr
=
CFStringGetCStringPtr
(
psname
kCFStringEncodingUTF8
)
;
if
(
cstr
)
{
fontName
.
Assign
(
cstr
)
;
}
else
{
char
buf
[
FONT_NAME_MAX
]
;
if
(
CFStringGetCString
(
psname
buf
FONT_NAME_MAX
kCFStringEncodingUTF8
)
)
{
fontName
.
Assign
(
buf
)
;
}
}
CFRelease
(
psname
)
;
}
{
auto
fontMap
=
sWeakFontDataMap
.
Lock
(
)
;
void
*
key
=
(
void
*
)
fontData
;
fontMap
-
>
insert
(
{
key
fontName
}
)
;
}
CFRelease
(
data
)
;
RefPtr
<
NativeFontResourceMac
>
fontResource
=
new
NativeFontResourceMac
(
ctFontDesc
fontRef
aDataLength
)
;
return
fontResource
.
forget
(
)
;
}
already_AddRefed
<
UnscaledFont
>
NativeFontResourceMac
:
:
CreateUnscaledFont
(
uint32_t
aIndex
const
uint8_t
*
aInstanceData
uint32_t
aInstanceDataLength
)
{
RefPtr
<
UnscaledFont
>
unscaledFont
=
new
UnscaledFontMac
(
mFontDescRef
mFontRef
true
)
;
return
unscaledFont
.
forget
(
)
;
}
}
}
