#
ifndef
MOZILLA_GFX_COMMANDBUFFER_H_
#
define
MOZILLA_GFX_COMMANDBUFFER_H_
#
include
<
stdint
.
h
>
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
mozilla
/
gfx
/
TaskScheduler
.
h
"
#
include
"
mozilla
/
gfx
/
IterableArena
.
h
"
#
include
"
DrawCommand
.
h
"
namespace
mozilla
{
namespace
gfx
{
class
DrawingCommand
;
class
PrintCommand
;
class
SignalCommand
;
class
DrawingTask
;
class
WaitCommand
;
class
SyncObject
;
class
MultiThreadedTaskQueue
;
class
DrawTarget
;
class
DrawingTaskBuilder
;
class
CommandBufferBuilder
;
class
CommandBuffer
:
public
external
:
:
AtomicRefCounted
<
CommandBuffer
>
{
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
CommandBuffer
)
~
CommandBuffer
(
)
;
DrawingCommand
*
GetDrawingCommand
(
ptrdiff_t
aId
)
;
protected
:
CommandBuffer
(
size_t
aSize
=
256
)
:
mStorage
(
IterableArena
:
:
GROWABLE
aSize
)
{
}
IterableArena
mStorage
;
friend
class
CommandBufferBuilder
;
}
;
class
CommandBufferBuilder
{
public
:
void
BeginCommandBuffer
(
size_t
aBufferSize
=
256
)
;
already_AddRefed
<
CommandBuffer
>
EndCommandBuffer
(
)
;
template
<
typename
T
typename
.
.
.
Args
>
ptrdiff_t
AddCommand
(
Args
&
&
.
.
.
aArgs
)
{
static_assert
(
IsBaseOf
<
DrawingCommand
T
>
:
:
value
"
T
must
derive
from
DrawingCommand
"
)
;
return
mCommands
-
>
mStorage
.
Alloc
<
T
>
(
Forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
bool
HasCommands
(
)
const
{
return
!
!
mCommands
;
}
protected
:
RefPtr
<
CommandBuffer
>
mCommands
;
}
;
class
DrawingTask
:
public
Task
{
public
:
DrawingTask
(
MultiThreadedTaskQueue
*
aTaskQueue
DrawTarget
*
aTarget
IntPoint
aOffset
SyncObject
*
aStart
)
;
~
DrawingTask
(
)
;
virtual
TaskStatus
Run
(
)
override
;
protected
:
void
Clear
(
)
;
std
:
:
vector
<
ptrdiff_t
>
mCommandOffsets
;
RefPtr
<
CommandBuffer
>
mCommandBuffer
;
uint32_t
mCursor
;
RefPtr
<
DrawTarget
>
mDrawTarget
;
IntPoint
mOffset
;
friend
class
DrawingTaskBuilder
;
}
;
class
DrawingTaskBuilder
{
public
:
DrawingTaskBuilder
(
)
;
~
DrawingTaskBuilder
(
)
;
void
BeginDrawingTask
(
MultiThreadedTaskQueue
*
aTaskQueue
DrawTarget
*
aTarget
IntPoint
aOffset
SyncObject
*
aStart
=
nullptr
)
;
void
AddCommand
(
ptrdiff_t
offset
)
{
MOZ_ASSERT
(
mTask
)
;
mTask
-
>
mCommandOffsets
.
push_back
(
offset
)
;
}
DrawingTask
*
EndDrawingTask
(
CommandBuffer
*
aCmdBuffer
SyncObject
*
aCompletion
=
nullptr
)
;
bool
HasDrawingTask
(
)
const
{
return
!
!
mTask
;
}
protected
:
DrawingTask
*
mTask
;
}
;
}
}
#
endif
