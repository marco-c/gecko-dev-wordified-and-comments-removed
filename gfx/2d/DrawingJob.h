#
ifndef
MOZILLA_GFX_COMMANDBUFFER_H_
#
define
MOZILLA_GFX_COMMANDBUFFER_H_
#
include
<
stdint
.
h
>
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
mozilla
/
gfx
/
JobScheduler
.
h
"
#
include
"
mozilla
/
gfx
/
IterableArena
.
h
"
#
include
"
mozilla
/
RefCounted
.
h
"
#
include
"
DrawCommand
.
h
"
namespace
mozilla
{
namespace
gfx
{
class
DrawingCommand
;
class
PrintCommand
;
class
SignalCommand
;
class
DrawingJob
;
class
WaitCommand
;
class
SyncObject
;
class
MultiThreadedJobQueue
;
class
DrawTarget
;
class
DrawingJobBuilder
;
class
CommandBufferBuilder
;
class
CommandBuffer
:
public
external
:
:
AtomicRefCounted
<
CommandBuffer
>
{
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
CommandBuffer
)
~
CommandBuffer
(
)
;
const
DrawingCommand
*
GetDrawingCommand
(
ptrdiff_t
aId
)
;
protected
:
explicit
CommandBuffer
(
size_t
aSize
=
256
)
:
mStorage
(
IterableArena
:
:
GROWABLE
aSize
)
{
}
IterableArena
mStorage
;
friend
class
CommandBufferBuilder
;
}
;
class
CommandBufferBuilder
{
public
:
void
BeginCommandBuffer
(
size_t
aBufferSize
=
256
)
;
already_AddRefed
<
CommandBuffer
>
EndCommandBuffer
(
)
;
template
<
typename
T
typename
.
.
.
Args
>
ptrdiff_t
AddCommand
(
Args
&
&
.
.
.
aArgs
)
{
static_assert
(
IsBaseOf
<
DrawingCommand
T
>
:
:
value
"
T
must
derive
from
DrawingCommand
"
)
;
return
mCommands
-
>
mStorage
.
Alloc
<
T
>
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
bool
HasCommands
(
)
const
{
return
!
!
mCommands
;
}
protected
:
RefPtr
<
CommandBuffer
>
mCommands
;
}
;
class
DrawingJob
:
public
Job
{
public
:
~
DrawingJob
(
)
;
virtual
JobStatus
Run
(
)
override
;
protected
:
DrawingJob
(
DrawTarget
*
aTarget
IntPoint
aOffset
SyncObject
*
aStart
SyncObject
*
aCompletion
WorkerThread
*
aPinToWorker
=
nullptr
)
;
void
Clear
(
)
;
std
:
:
vector
<
ptrdiff_t
>
mCommandOffsets
;
RefPtr
<
CommandBuffer
>
mCommandBuffer
;
uint32_t
mCursor
;
RefPtr
<
DrawTarget
>
mDrawTarget
;
IntPoint
mOffset
;
friend
class
DrawingJobBuilder
;
}
;
class
DrawingJobBuilder
{
public
:
DrawingJobBuilder
(
)
;
~
DrawingJobBuilder
(
)
;
void
BeginDrawingJob
(
DrawTarget
*
aTarget
IntPoint
aOffset
SyncObject
*
aStart
=
nullptr
)
;
void
AddCommand
(
ptrdiff_t
offset
)
{
mCommandOffsets
.
push_back
(
offset
)
;
}
DrawingJob
*
EndDrawingJob
(
CommandBuffer
*
aCmdBuffer
SyncObject
*
aCompletion
=
nullptr
WorkerThread
*
aPinToWorker
=
nullptr
)
;
bool
HasDrawingJob
(
)
const
{
return
!
!
mDrawTarget
;
}
protected
:
std
:
:
vector
<
ptrdiff_t
>
mCommandOffsets
;
RefPtr
<
DrawTarget
>
mDrawTarget
;
IntPoint
mOffset
;
RefPtr
<
SyncObject
>
mStart
;
}
;
}
}
#
endif
