#
ifndef
MOZILLA_GFX_TASKSCHEDULER_H_
#
define
MOZILLA_GFX_TASKSCHEDULER_H_
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
RefCounted
.
h
"
#
ifdef
WIN32
#
include
"
mozilla
/
gfx
/
JobScheduler_win32
.
h
"
#
else
#
include
"
mozilla
/
gfx
/
JobScheduler_posix
.
h
"
#
endif
#
include
<
vector
>
namespace
mozilla
{
namespace
gfx
{
class
MultiThreadedJobQueue
;
class
SyncObject
;
class
WorkerThread
;
class
JobScheduler
{
public
:
static
MultiThreadedJobQueue
*
GetDrawingQueue
(
)
{
return
sSingleton
-
>
mDrawingQueues
[
sSingleton
-
>
mNextQueue
+
+
%
sSingleton
-
>
mDrawingQueues
.
size
(
)
]
;
}
static
MultiThreadedJobQueue
*
GetDrawingQueue
(
uint32_t
aHash
)
{
return
sSingleton
-
>
mDrawingQueues
[
aHash
%
sSingleton
-
>
mDrawingQueues
.
size
(
)
]
;
}
static
MultiThreadedJobQueue
*
GetQueueForJob
(
Job
*
aJob
)
;
static
bool
Init
(
uint32_t
aNumThreads
uint32_t
aNumQueues
)
;
static
void
ShutDown
(
)
;
static
bool
IsEnabled
(
)
{
return
!
!
sSingleton
;
}
static
void
SubmitJob
(
Job
*
aJobs
)
;
static
JobStatus
ProcessJob
(
Job
*
aJobs
)
;
protected
:
static
JobScheduler
*
sSingleton
;
std
:
:
vector
<
MultiThreadedJobQueue
*
>
mDrawingQueues
;
std
:
:
vector
<
WorkerThread
*
>
mWorkerThreads
;
Atomic
<
uint32_t
>
mNextQueue
;
}
;
class
Job
{
public
:
Job
(
SyncObject
*
aStart
SyncObject
*
aCompletion
WorkerThread
*
aThread
=
nullptr
)
;
virtual
~
Job
(
)
;
virtual
JobStatus
Run
(
)
=
0
;
SyncObject
*
GetStartSync
(
)
{
return
mStartSync
;
}
bool
IsPinnedToAThread
(
)
const
{
return
!
!
mPinToThread
;
}
WorkerThread
*
GetWorkerThread
(
)
{
return
mPinToThread
;
}
protected
:
Job
*
mNextWaitingJob
;
RefPtr
<
SyncObject
>
mStartSync
;
RefPtr
<
SyncObject
>
mCompletionSync
;
WorkerThread
*
mPinToThread
;
friend
class
SyncObject
;
}
;
class
EventObject
;
class
SetEventJob
:
public
Job
{
public
:
explicit
SetEventJob
(
EventObject
*
aEvent
SyncObject
*
aStart
SyncObject
*
aCompletion
=
nullptr
WorkerThread
*
aPinToWorker
=
nullptr
)
;
~
SetEventJob
(
)
;
JobStatus
Run
(
)
override
;
EventObject
*
GetEvent
(
)
{
return
mEvent
;
}
protected
:
RefPtr
<
EventObject
>
mEvent
;
}
;
class
SyncObject
final
:
public
external
:
:
AtomicRefCounted
<
SyncObject
>
{
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
SyncObject
)
explicit
SyncObject
(
uint32_t
aNumPrerequisites
=
1
)
;
~
SyncObject
(
)
;
bool
Register
(
Job
*
aJob
)
;
void
Signal
(
)
;
bool
IsSignaled
(
)
;
void
FreezePrerequisites
(
)
;
private
:
void
AddSubsequent
(
Job
*
aJob
)
;
void
AddPrerequisite
(
Job
*
aJob
)
;
void
AddWaitingJob
(
Job
*
aJob
)
;
void
SubmitWaitingJobs
(
)
;
Atomic
<
int32_t
>
mSignals
;
Atomic
<
Job
*
>
mFirstWaitingJob
;
#
ifdef
DEBUG
uint32_t
mNumPrerequisites
;
Atomic
<
uint32_t
>
mAddedPrerequisites
;
#
endif
friend
class
Job
;
friend
class
JobScheduler
;
}
;
class
WorkerThread
{
public
:
static
WorkerThread
*
Create
(
MultiThreadedJobQueue
*
aJobQueue
)
;
virtual
~
WorkerThread
(
)
{
}
void
Run
(
)
;
MultiThreadedJobQueue
*
GetJobQueue
(
)
{
return
mQueue
;
}
protected
:
explicit
WorkerThread
(
MultiThreadedJobQueue
*
aJobQueue
)
;
virtual
void
SetName
(
const
char
*
aName
)
{
}
MultiThreadedJobQueue
*
mQueue
;
}
;
}
}
#
endif
