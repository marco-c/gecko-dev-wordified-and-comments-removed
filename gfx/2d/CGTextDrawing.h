#
ifndef
_MOZILLA_GFX_SKIACGPOPUPDRAWER_H
#
define
_MOZILLA_GFX_SKIACGPOPUPDRAWER_H
#
include
<
ApplicationServices
/
ApplicationServices
.
h
>
#
include
"
nsDebug
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
ScaledFontMac
.
h
"
#
include
<
dlfcn
.
h
>
namespace
mozilla
{
namespace
gfx
{
typedef
void
(
*
CGContextSetFontSmoothingBackgroundColorFunc
)
(
CGContextRef
cgContext
CGColorRef
color
)
;
static
CGContextSetFontSmoothingBackgroundColorFunc
GetCGContextSetFontSmoothingBackgroundColorFunc
(
)
{
static
CGContextSetFontSmoothingBackgroundColorFunc
func
=
nullptr
;
static
bool
lookedUpFunc
=
false
;
if
(
!
lookedUpFunc
)
{
func
=
(
CGContextSetFontSmoothingBackgroundColorFunc
)
dlsym
(
RTLD_DEFAULT
"
CGContextSetFontSmoothingBackgroundColor
"
)
;
lookedUpFunc
=
true
;
}
return
func
;
}
static
CGColorRef
ColorToCGColor
(
CGColorSpaceRef
aColorSpace
const
DeviceColor
&
aColor
)
{
CGFloat
components
[
4
]
=
{
aColor
.
r
aColor
.
g
aColor
.
b
aColor
.
a
}
;
return
CGColorCreate
(
aColorSpace
components
)
;
}
static
bool
SetFontSmoothingBackgroundColor
(
CGContextRef
aCGContext
CGColorSpaceRef
aColorSpace
const
DeviceColor
&
aFontSmoothingBackgroundColor
)
{
if
(
aFontSmoothingBackgroundColor
.
a
>
0
)
{
CGContextSetFontSmoothingBackgroundColorFunc
setFontSmoothingBGColorFunc
=
GetCGContextSetFontSmoothingBackgroundColorFunc
(
)
;
if
(
setFontSmoothingBGColorFunc
)
{
CGColorRef
color
=
ColorToCGColor
(
aColorSpace
aFontSmoothingBackgroundColor
)
;
setFontSmoothingBGColorFunc
(
aCGContext
color
)
;
CGColorRelease
(
color
)
;
return
true
;
}
}
return
false
;
}
static
void
EnsureValidPremultipliedData
(
CGContextRef
aContext
CGRect
aTextBounds
=
CGRectInfinite
)
{
if
(
CGBitmapContextGetBitsPerPixel
(
aContext
)
!
=
32
|
|
CGBitmapContextGetAlphaInfo
(
aContext
)
!
=
kCGImageAlphaPremultipliedFirst
)
{
return
;
}
uint8_t
*
bitmapData
=
(
uint8_t
*
)
CGBitmapContextGetData
(
aContext
)
;
CGRect
bitmapBounds
=
CGRectMake
(
0
0
CGBitmapContextGetWidth
(
aContext
)
CGBitmapContextGetHeight
(
aContext
)
)
;
int
stride
=
CGBitmapContextGetBytesPerRow
(
aContext
)
;
CGRect
bounds
=
CGRectIntersection
(
bitmapBounds
aTextBounds
)
;
if
(
CGRectIsEmpty
(
bounds
)
)
{
return
;
}
int
startX
=
bounds
.
origin
.
x
;
int
endX
=
startX
+
bounds
.
size
.
width
;
MOZ_ASSERT
(
endX
<
=
bitmapBounds
.
size
.
width
)
;
int
startY
=
bitmapBounds
.
size
.
height
-
(
bounds
.
origin
.
y
+
bounds
.
size
.
height
)
;
int
endY
=
startY
+
bounds
.
size
.
height
;
MOZ_ASSERT
(
endY
<
=
(
int
)
CGBitmapContextGetHeight
(
aContext
)
)
;
for
(
int
y
=
startY
;
y
<
endY
;
y
+
+
)
{
for
(
int
x
=
startX
;
x
<
endX
;
x
+
+
)
{
int
i
=
y
*
stride
+
x
*
4
;
uint8_t
a
=
bitmapData
[
i
+
3
]
;
bitmapData
[
i
+
0
]
=
std
:
:
min
(
a
bitmapData
[
i
+
0
]
)
;
bitmapData
[
i
+
1
]
=
std
:
:
min
(
a
bitmapData
[
i
+
1
]
)
;
bitmapData
[
i
+
2
]
=
std
:
:
min
(
a
bitmapData
[
i
+
2
]
)
;
}
}
}
static
CGRect
ComputeGlyphsExtents
(
CGRect
*
bboxes
CGPoint
*
positions
CFIndex
count
float
scale
)
{
CGFloat
x1
x2
y1
y2
;
if
(
count
<
1
)
return
CGRectZero
;
x1
=
bboxes
[
0
]
.
origin
.
x
+
positions
[
0
]
.
x
;
x2
=
bboxes
[
0
]
.
origin
.
x
+
positions
[
0
]
.
x
+
scale
*
bboxes
[
0
]
.
size
.
width
;
y1
=
bboxes
[
0
]
.
origin
.
y
+
positions
[
0
]
.
y
;
y2
=
bboxes
[
0
]
.
origin
.
y
+
positions
[
0
]
.
y
+
scale
*
bboxes
[
0
]
.
size
.
height
;
for
(
int
i
=
1
;
i
<
count
;
i
+
+
)
{
x1
=
std
:
:
min
(
x1
bboxes
[
i
]
.
origin
.
x
+
positions
[
i
]
.
x
)
;
y1
=
std
:
:
min
(
y1
bboxes
[
i
]
.
origin
.
y
+
positions
[
i
]
.
y
)
;
x2
=
std
:
:
max
(
x2
bboxes
[
i
]
.
origin
.
x
+
positions
[
i
]
.
x
+
scale
*
bboxes
[
i
]
.
size
.
width
)
;
y2
=
std
:
:
max
(
y2
bboxes
[
i
]
.
origin
.
y
+
positions
[
i
]
.
y
+
scale
*
bboxes
[
i
]
.
size
.
height
)
;
}
CGRect
extents
=
{
{
x1
y1
}
{
x2
-
x1
y2
-
y1
}
}
;
return
extents
;
}
}
}
#
endif
