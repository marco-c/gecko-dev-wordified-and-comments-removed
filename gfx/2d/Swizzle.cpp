#
include
"
Swizzle
.
h
"
#
include
"
Logging
.
h
"
#
include
"
Tools
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
EndianUtils
.
h
"
#
ifdef
BUILD_ARM_NEON
#
include
"
mozilla
/
arm
.
h
"
#
endif
namespace
mozilla
{
namespace
gfx
{
#
define
FORMAT_KEY
(
aSrcFormat
aDstFormat
)
\
(
int
(
aSrcFormat
)
*
6
+
int
(
aDstFormat
)
+
(
int
(
int
(
aDstFormat
)
>
=
6
)
<
<
6
)
)
#
define
FORMAT_CASE_EXPR
(
aSrcFormat
aDstFormat
.
.
.
)
\
case
FORMAT_KEY
(
aSrcFormat
aDstFormat
)
:
\
__VA_ARGS__
;
\
return
true
;
#
define
FORMAT_CASE
(
aSrcFormat
aDstFormat
.
.
.
)
\
FORMAT_CASE_EXPR
(
aSrcFormat
aDstFormat
FORMAT_CASE_CALL
(
__VA_ARGS__
)
)
static
constexpr
bool
IsBGRFormat
(
SurfaceFormat
aFormat
)
{
return
aFormat
=
=
SurfaceFormat
:
:
B8G8R8A8
|
|
#
if
MOZ_LITTLE_ENDIAN
aFormat
=
=
SurfaceFormat
:
:
R5G6B5_UINT16
|
|
#
endif
aFormat
=
=
SurfaceFormat
:
:
B8G8R8X8
|
|
aFormat
=
=
SurfaceFormat
:
:
B8G8R8
;
}
static
constexpr
bool
ShouldSwapRB
(
SurfaceFormat
aSrcFormat
SurfaceFormat
aDstFormat
)
{
return
IsBGRFormat
(
aSrcFormat
)
!
=
IsBGRFormat
(
aDstFormat
)
;
}
static
constexpr
uint32_t
RGBByteIndex
(
SurfaceFormat
aFormat
)
{
return
aFormat
=
=
SurfaceFormat
:
:
A8R8G8B8
|
|
aFormat
=
=
SurfaceFormat
:
:
X8R8G8B8
?
1
:
0
;
}
static
constexpr
uint32_t
AlphaByteIndex
(
SurfaceFormat
aFormat
)
{
return
(
RGBByteIndex
(
aFormat
)
+
3
)
%
4
;
}
static
constexpr
uint32_t
RGBBitShift
(
SurfaceFormat
aFormat
)
{
#
if
MOZ_LITTLE_ENDIAN
return
8
*
RGBByteIndex
(
aFormat
)
;
#
else
return
24
-
8
*
RGBByteIndex
(
aFormat
)
;
#
endif
}
static
constexpr
uint32_t
AlphaBitShift
(
SurfaceFormat
aFormat
)
{
return
(
RGBBitShift
(
aFormat
)
+
24
)
%
32
;
}
static
constexpr
bool
IgnoreAlpha
(
SurfaceFormat
aFormat
)
{
return
aFormat
=
=
SurfaceFormat
:
:
B8G8R8X8
|
|
aFormat
=
=
SurfaceFormat
:
:
R8G8B8X8
|
|
aFormat
=
=
SurfaceFormat
:
:
X8R8G8B8
;
}
static
constexpr
bool
ShouldForceOpaque
(
SurfaceFormat
aSrcFormat
SurfaceFormat
aDstFormat
)
{
return
IgnoreAlpha
(
aSrcFormat
)
!
=
IgnoreAlpha
(
aDstFormat
)
;
}
#
ifdef
USE_SSE2
template
<
bool
aSwapRB
bool
aOpaqueAlpha
>
void
Premultiply_SSE2
(
const
uint8_t
*
int32_t
uint8_t
*
int32_t
IntSize
)
;
#
define
PREMULTIPLY_SSE2
(
aSrcFormat
aDstFormat
)
\
FORMAT_CASE
(
aSrcFormat
aDstFormat
\
Premultiply_SSE2
\
<
ShouldSwapRB
(
aSrcFormat
aDstFormat
)
\
ShouldForceOpaque
(
aSrcFormat
aDstFormat
)
>
)
template
<
bool
aSwapRB
>
void
Unpremultiply_SSE2
(
const
uint8_t
*
int32_t
uint8_t
*
int32_t
IntSize
)
;
#
define
UNPREMULTIPLY_SSE2
(
aSrcFormat
aDstFormat
)
\
FORMAT_CASE
(
aSrcFormat
aDstFormat
\
Unpremultiply_SSE2
<
ShouldSwapRB
(
aSrcFormat
aDstFormat
)
>
)
template
<
bool
aSwapRB
bool
aOpaqueAlpha
>
void
Swizzle_SSE2
(
const
uint8_t
*
int32_t
uint8_t
*
int32_t
IntSize
)
;
#
define
SWIZZLE_SSE2
(
aSrcFormat
aDstFormat
)
\
FORMAT_CASE
(
aSrcFormat
aDstFormat
\
Swizzle_SSE2
\
<
ShouldSwapRB
(
aSrcFormat
aDstFormat
)
\
ShouldForceOpaque
(
aSrcFormat
aDstFormat
)
>
)
#
endif
#
ifdef
BUILD_ARM_NEON
template
<
bool
aSwapRB
bool
aOpaqueAlpha
>
void
Premultiply_NEON
(
const
uint8_t
*
int32_t
uint8_t
*
int32_t
IntSize
)
;
#
define
PREMULTIPLY_NEON
(
aSrcFormat
aDstFormat
)
\
FORMAT_CASE
(
aSrcFormat
aDstFormat
\
Premultiply_NEON
\
<
ShouldSwapRB
(
aSrcFormat
aDstFormat
)
\
ShouldForceOpaque
(
aSrcFormat
aDstFormat
)
>
)
template
<
bool
aSwapRB
>
void
Unpremultiply_NEON
(
const
uint8_t
*
int32_t
uint8_t
*
int32_t
IntSize
)
;
#
define
UNPREMULTIPLY_NEON
(
aSrcFormat
aDstFormat
)
\
FORMAT_CASE
(
aSrcFormat
aDstFormat
\
Unpremultiply_NEON
<
ShouldSwapRB
(
aSrcFormat
aDstFormat
)
>
)
template
<
bool
aSwapRB
bool
aOpaqueAlpha
>
void
Swizzle_NEON
(
const
uint8_t
*
int32_t
uint8_t
*
int32_t
IntSize
)
;
#
define
SWIZZLE_NEON
(
aSrcFormat
aDstFormat
)
\
FORMAT_CASE
(
aSrcFormat
aDstFormat
\
Swizzle_NEON
\
<
ShouldSwapRB
(
aSrcFormat
aDstFormat
)
\
ShouldForceOpaque
(
aSrcFormat
aDstFormat
)
>
)
#
endif
template
<
bool
aSwapRB
bool
aOpaqueAlpha
uint32_t
aSrcRGBShift
uint32_t
aSrcAShift
uint32_t
aDstRGBShift
uint32_t
aDstAShift
>
static
void
PremultiplyFallback
(
const
uint8_t
*
aSrc
int32_t
aSrcGap
uint8_t
*
aDst
int32_t
aDstGap
IntSize
aSize
)
{
for
(
int32_t
height
=
aSize
.
height
;
height
>
0
;
height
-
-
)
{
const
uint8_t
*
end
=
aSrc
+
4
*
aSize
.
width
;
do
{
uint32_t
color
=
*
reinterpret_cast
<
const
uint32_t
*
>
(
aSrc
)
;
uint32_t
a
=
aSrcAShift
?
color
>
>
aSrcAShift
:
color
&
0xFF
;
uint32_t
rb
=
(
color
>
>
aSrcRGBShift
)
&
0x00FF00FF
;
if
(
aSwapRB
)
{
rb
=
(
rb
>
>
16
)
|
(
rb
<
<
16
)
;
}
rb
=
rb
*
a
+
0x00FF00FF
;
rb
=
(
rb
+
(
(
rb
>
>
8
)
&
0x00FF00FF
)
)
&
0xFF00FF00
;
uint32_t
g
=
color
&
(
0xFF00
<
<
aSrcRGBShift
)
;
g
=
g
*
a
+
(
0xFF00
<
<
aSrcRGBShift
)
;
g
=
(
g
+
(
g
>
>
8
)
)
&
(
0xFF0000
<
<
aSrcRGBShift
)
;
*
reinterpret_cast
<
uint32_t
*
>
(
aDst
)
=
(
rb
>
>
(
8
-
aDstRGBShift
)
)
|
(
g
>
>
(
8
+
aSrcRGBShift
-
aDstRGBShift
)
)
|
(
aOpaqueAlpha
?
0xFF
<
<
aDstAShift
:
a
<
<
aDstAShift
)
;
aSrc
+
=
4
;
aDst
+
=
4
;
}
while
(
aSrc
<
end
)
;
aSrc
+
=
aSrcGap
;
aDst
+
=
aDstGap
;
}
}
#
define
PREMULTIPLY_FALLBACK_CASE
(
aSrcFormat
aDstFormat
)
\
FORMAT_CASE
(
aSrcFormat
aDstFormat
\
PremultiplyFallback
\
<
ShouldSwapRB
(
aSrcFormat
aDstFormat
)
\
ShouldForceOpaque
(
aSrcFormat
aDstFormat
)
\
RGBBitShift
(
aSrcFormat
)
AlphaBitShift
(
aSrcFormat
)
\
RGBBitShift
(
aDstFormat
)
AlphaBitShift
(
aDstFormat
)
>
)
#
define
PREMULTIPLY_FALLBACK
(
aSrcFormat
)
\
PREMULTIPLY_FALLBACK_CASE
(
aSrcFormat
SurfaceFormat
:
:
B8G8R8A8
)
\
PREMULTIPLY_FALLBACK_CASE
(
aSrcFormat
SurfaceFormat
:
:
B8G8R8X8
)
\
PREMULTIPLY_FALLBACK_CASE
(
aSrcFormat
SurfaceFormat
:
:
R8G8B8A8
)
\
PREMULTIPLY_FALLBACK_CASE
(
aSrcFormat
SurfaceFormat
:
:
R8G8B8X8
)
\
PREMULTIPLY_FALLBACK_CASE
(
aSrcFormat
SurfaceFormat
:
:
A8R8G8B8
)
\
PREMULTIPLY_FALLBACK_CASE
(
aSrcFormat
SurfaceFormat
:
:
X8R8G8B8
)
static
inline
IntSize
CollapseSize
(
const
IntSize
&
aSize
int32_t
aSrcStride
int32_t
aDstStride
)
{
if
(
aSrcStride
=
=
aDstStride
&
&
aSrcStride
=
=
4
*
aSize
.
width
)
{
CheckedInt32
area
=
CheckedInt32
(
aSize
.
width
)
*
CheckedInt32
(
aSize
.
height
)
;
if
(
area
.
isValid
(
)
)
{
return
IntSize
(
area
.
value
(
)
1
)
;
}
}
return
aSize
;
}
bool
PremultiplyData
(
const
uint8_t
*
aSrc
int32_t
aSrcStride
SurfaceFormat
aSrcFormat
uint8_t
*
aDst
int32_t
aDstStride
SurfaceFormat
aDstFormat
const
IntSize
&
aSize
)
{
if
(
aSize
.
IsEmpty
(
)
)
{
return
true
;
}
IntSize
size
=
CollapseSize
(
aSize
aSrcStride
aDstStride
)
;
int32_t
srcGap
=
aSrcStride
-
BytesPerPixel
(
aSrcFormat
)
*
aSize
.
width
;
int32_t
dstGap
=
aDstStride
-
BytesPerPixel
(
aDstFormat
)
*
aSize
.
width
;
MOZ_ASSERT
(
srcGap
>
=
0
&
&
dstGap
>
=
0
)
;
#
define
FORMAT_CASE_CALL
(
.
.
.
)
__VA_ARGS__
(
aSrc
srcGap
aDst
dstGap
size
)
#
ifdef
USE_SSE2
switch
(
FORMAT_KEY
(
aSrcFormat
aDstFormat
)
)
{
PREMULTIPLY_SSE2
(
SurfaceFormat
:
:
B8G8R8A8
SurfaceFormat
:
:
B8G8R8A8
)
PREMULTIPLY_SSE2
(
SurfaceFormat
:
:
B8G8R8A8
SurfaceFormat
:
:
B8G8R8X8
)
PREMULTIPLY_SSE2
(
SurfaceFormat
:
:
B8G8R8A8
SurfaceFormat
:
:
R8G8B8A8
)
PREMULTIPLY_SSE2
(
SurfaceFormat
:
:
B8G8R8A8
SurfaceFormat
:
:
R8G8B8X8
)
PREMULTIPLY_SSE2
(
SurfaceFormat
:
:
R8G8B8A8
SurfaceFormat
:
:
R8G8B8A8
)
PREMULTIPLY_SSE2
(
SurfaceFormat
:
:
R8G8B8A8
SurfaceFormat
:
:
R8G8B8X8
)
PREMULTIPLY_SSE2
(
SurfaceFormat
:
:
R8G8B8A8
SurfaceFormat
:
:
B8G8R8A8
)
PREMULTIPLY_SSE2
(
SurfaceFormat
:
:
R8G8B8A8
SurfaceFormat
:
:
B8G8R8X8
)
default
:
break
;
}
#
endif
#
ifdef
BUILD_ARM_NEON
if
(
mozilla
:
:
supports_neon
(
)
)
switch
(
FORMAT_KEY
(
aSrcFormat
aDstFormat
)
)
{
PREMULTIPLY_NEON
(
SurfaceFormat
:
:
B8G8R8A8
SurfaceFormat
:
:
B8G8R8A8
)
PREMULTIPLY_NEON
(
SurfaceFormat
:
:
B8G8R8A8
SurfaceFormat
:
:
B8G8R8X8
)
PREMULTIPLY_NEON
(
SurfaceFormat
:
:
B8G8R8A8
SurfaceFormat
:
:
R8G8B8A8
)
PREMULTIPLY_NEON
(
SurfaceFormat
:
:
B8G8R8A8
SurfaceFormat
:
:
R8G8B8X8
)
PREMULTIPLY_NEON
(
SurfaceFormat
:
:
R8G8B8A8
SurfaceFormat
:
:
R8G8B8A8
)
PREMULTIPLY_NEON
(
SurfaceFormat
:
:
R8G8B8A8
SurfaceFormat
:
:
R8G8B8X8
)
PREMULTIPLY_NEON
(
SurfaceFormat
:
:
R8G8B8A8
SurfaceFormat
:
:
B8G8R8A8
)
PREMULTIPLY_NEON
(
SurfaceFormat
:
:
R8G8B8A8
SurfaceFormat
:
:
B8G8R8X8
)
default
:
break
;
}
#
endif
switch
(
FORMAT_KEY
(
aSrcFormat
aDstFormat
)
)
{
PREMULTIPLY_FALLBACK
(
SurfaceFormat
:
:
B8G8R8A8
)
PREMULTIPLY_FALLBACK
(
SurfaceFormat
:
:
R8G8B8A8
)
PREMULTIPLY_FALLBACK
(
SurfaceFormat
:
:
A8R8G8B8
)
default
:
break
;
}
#
undef
FORMAT_CASE_CALL
gfxCriticalError
(
)
<
<
"
Unsupported
premultiply
formats
:
"
<
<
aSrcFormat
<
<
"
-
>
"
<
<
aDstFormat
;
return
false
;
}
#
define
UNPREMULQ
(
x
)
(
0xFF00FFU
/
(
x
)
)
#
define
UNPREMULQ_2
(
x
)
UNPREMULQ
(
x
)
UNPREMULQ
(
(
x
)
+
1
)
#
define
UNPREMULQ_4
(
x
)
UNPREMULQ_2
(
x
)
UNPREMULQ_2
(
(
x
)
+
2
)
#
define
UNPREMULQ_8
(
x
)
UNPREMULQ_4
(
x
)
UNPREMULQ_4
(
(
x
)
+
4
)
#
define
UNPREMULQ_16
(
x
)
UNPREMULQ_8
(
x
)
UNPREMULQ_8
(
(
x
)
+
8
)
#
define
UNPREMULQ_32
(
x
)
UNPREMULQ_16
(
x
)
UNPREMULQ_16
(
(
x
)
+
16
)
static
const
uint32_t
sUnpremultiplyTable
[
256
]
=
{
0
UNPREMULQ
(
1
)
UNPREMULQ_2
(
2
)
UNPREMULQ_4
(
4
)
UNPREMULQ_8
(
8
)
UNPREMULQ_16
(
16
)
UNPREMULQ_32
(
32
)
UNPREMULQ_32
(
64
)
UNPREMULQ_32
(
96
)
UNPREMULQ_32
(
128
)
UNPREMULQ_32
(
160
)
UNPREMULQ_32
(
192
)
UNPREMULQ_32
(
224
)
}
;
template
<
bool
aSwapRB
uint32_t
aSrcRGBIndex
uint32_t
aSrcAIndex
uint32_t
aDstRGBIndex
uint32_t
aDstAIndex
>
static
void
UnpremultiplyFallback
(
const
uint8_t
*
aSrc
int32_t
aSrcGap
uint8_t
*
aDst
int32_t
aDstGap
IntSize
aSize
)
{
for
(
int32_t
height
=
aSize
.
height
;
height
>
0
;
height
-
-
)
{
const
uint8_t
*
end
=
aSrc
+
4
*
aSize
.
width
;
do
{
uint8_t
r
=
aSrc
[
aSrcRGBIndex
+
(
aSwapRB
?
2
:
0
)
]
;
uint8_t
g
=
aSrc
[
aSrcRGBIndex
+
1
]
;
uint8_t
b
=
aSrc
[
aSrcRGBIndex
+
(
aSwapRB
?
0
:
2
)
]
;
uint8_t
a
=
aSrc
[
aSrcAIndex
]
;
uint32_t
q
=
sUnpremultiplyTable
[
a
]
;
aDst
[
aDstRGBIndex
+
0
]
=
(
r
*
q
)
>
>
16
;
aDst
[
aDstRGBIndex
+
1
]
=
(
g
*
q
)
>
>
16
;
aDst
[
aDstRGBIndex
+
2
]
=
(
b
*
q
)
>
>
16
;
aDst
[
aDstAIndex
]
=
a
;
aSrc
+
=
4
;
aDst
+
=
4
;
}
while
(
aSrc
<
end
)
;
aSrc
+
=
aSrcGap
;
aDst
+
=
aDstGap
;
}
}
#
define
UNPREMULTIPLY_FALLBACK_CASE
(
aSrcFormat
aDstFormat
)
\
FORMAT_CASE
(
aSrcFormat
aDstFormat
\
UnpremultiplyFallback
\
<
ShouldSwapRB
(
aSrcFormat
aDstFormat
)
\
RGBByteIndex
(
aSrcFormat
)
AlphaByteIndex
(
aSrcFormat
)
\
RGBByteIndex
(
aDstFormat
)
AlphaByteIndex
(
aDstFormat
)
>
)
#
define
UNPREMULTIPLY_FALLBACK
(
aSrcFormat
)
\
UNPREMULTIPLY_FALLBACK_CASE
(
aSrcFormat
SurfaceFormat
:
:
B8G8R8A8
)
\
UNPREMULTIPLY_FALLBACK_CASE
(
aSrcFormat
SurfaceFormat
:
:
R8G8B8A8
)
\
UNPREMULTIPLY_FALLBACK_CASE
(
aSrcFormat
SurfaceFormat
:
:
A8R8G8B8
)
bool
UnpremultiplyData
(
const
uint8_t
*
aSrc
int32_t
aSrcStride
SurfaceFormat
aSrcFormat
uint8_t
*
aDst
int32_t
aDstStride
SurfaceFormat
aDstFormat
const
IntSize
&
aSize
)
{
if
(
aSize
.
IsEmpty
(
)
)
{
return
true
;
}
IntSize
size
=
CollapseSize
(
aSize
aSrcStride
aDstStride
)
;
int32_t
srcGap
=
aSrcStride
-
BytesPerPixel
(
aSrcFormat
)
*
aSize
.
width
;
int32_t
dstGap
=
aDstStride
-
BytesPerPixel
(
aDstFormat
)
*
aSize
.
width
;
MOZ_ASSERT
(
srcGap
>
=
0
&
&
dstGap
>
=
0
)
;
#
define
FORMAT_CASE_CALL
(
.
.
.
)
__VA_ARGS__
(
aSrc
srcGap
aDst
dstGap
size
)
#
ifdef
USE_SSE2
switch
(
FORMAT_KEY
(
aSrcFormat
aDstFormat
)
)
{
UNPREMULTIPLY_SSE2
(
SurfaceFormat
:
:
B8G8R8A8
SurfaceFormat
:
:
B8G8R8A8
)
UNPREMULTIPLY_SSE2
(
SurfaceFormat
:
:
B8G8R8A8
SurfaceFormat
:
:
R8G8B8A8
)
UNPREMULTIPLY_SSE2
(
SurfaceFormat
:
:
R8G8B8A8
SurfaceFormat
:
:
R8G8B8A8
)
UNPREMULTIPLY_SSE2
(
SurfaceFormat
:
:
R8G8B8A8
SurfaceFormat
:
:
B8G8R8A8
)
default
:
break
;
}
#
endif
#
ifdef
BUILD_ARM_NEON
if
(
mozilla
:
:
supports_neon
(
)
)
switch
(
FORMAT_KEY
(
aSrcFormat
aDstFormat
)
)
{
UNPREMULTIPLY_NEON
(
SurfaceFormat
:
:
B8G8R8A8
SurfaceFormat
:
:
B8G8R8A8
)
UNPREMULTIPLY_NEON
(
SurfaceFormat
:
:
B8G8R8A8
SurfaceFormat
:
:
R8G8B8A8
)
UNPREMULTIPLY_NEON
(
SurfaceFormat
:
:
R8G8B8A8
SurfaceFormat
:
:
R8G8B8A8
)
UNPREMULTIPLY_NEON
(
SurfaceFormat
:
:
R8G8B8A8
SurfaceFormat
:
:
B8G8R8A8
)
default
:
break
;
}
#
endif
switch
(
FORMAT_KEY
(
aSrcFormat
aDstFormat
)
)
{
UNPREMULTIPLY_FALLBACK
(
SurfaceFormat
:
:
B8G8R8A8
)
UNPREMULTIPLY_FALLBACK
(
SurfaceFormat
:
:
R8G8B8A8
)
UNPREMULTIPLY_FALLBACK
(
SurfaceFormat
:
:
A8R8G8B8
)
default
:
break
;
}
#
undef
FORMAT_CASE_CALL
gfxCriticalError
(
)
<
<
"
Unsupported
unpremultiply
formats
:
"
<
<
aSrcFormat
<
<
"
-
>
"
<
<
aDstFormat
;
return
false
;
}
template
<
bool
aSwapRB
bool
aOpaqueAlpha
uint32_t
aSrcRGBShift
uint32_t
aSrcAShift
uint32_t
aDstRGBShift
uint32_t
aDstAShift
>
static
void
SwizzleFallback
(
const
uint8_t
*
aSrc
int32_t
aSrcGap
uint8_t
*
aDst
int32_t
aDstGap
IntSize
aSize
)
{
for
(
int32_t
height
=
aSize
.
height
;
height
>
0
;
height
-
-
)
{
const
uint8_t
*
end
=
aSrc
+
4
*
aSize
.
width
;
do
{
uint32_t
rgba
=
*
reinterpret_cast
<
const
uint32_t
*
>
(
aSrc
)
;
if
(
aSwapRB
)
{
uint32_t
rb
=
(
(
rgba
<
<
16
)
|
(
rgba
>
>
16
)
)
&
(
0x00FF00FF
<
<
aSrcRGBShift
)
;
uint32_t
ga
=
rgba
&
(
(
0xFF
<
<
aSrcAShift
)
|
(
0xFF00
<
<
aSrcRGBShift
)
)
;
rgba
=
rb
|
ga
;
}
if
(
aDstRGBShift
>
aSrcRGBShift
)
{
rgba
=
(
rgba
<
<
8
)
|
(
aOpaqueAlpha
?
0x000000FF
:
rgba
>
>
24
)
;
}
else
if
(
aSrcRGBShift
>
aDstRGBShift
)
{
rgba
=
(
rgba
>
>
8
)
|
(
aOpaqueAlpha
?
0xFF000000
:
rgba
<
<
24
)
;
}
else
if
(
aOpaqueAlpha
)
{
rgba
|
=
0xFF
<
<
aDstAShift
;
}
*
reinterpret_cast
<
uint32_t
*
>
(
aDst
)
=
rgba
;
aSrc
+
=
4
;
aDst
+
=
4
;
}
while
(
aSrc
<
end
)
;
aSrc
+
=
aSrcGap
;
aDst
+
=
aDstGap
;
}
}
#
define
SWIZZLE_FALLBACK
(
aSrcFormat
aDstFormat
)
\
FORMAT_CASE
(
aSrcFormat
aDstFormat
\
SwizzleFallback
\
<
ShouldSwapRB
(
aSrcFormat
aDstFormat
)
\
ShouldForceOpaque
(
aSrcFormat
aDstFormat
)
\
RGBBitShift
(
aSrcFormat
)
AlphaBitShift
(
aSrcFormat
)
\
RGBBitShift
(
aDstFormat
)
AlphaBitShift
(
aDstFormat
)
>
)
static
void
SwizzleCopy
(
const
uint8_t
*
aSrc
int32_t
aSrcGap
uint8_t
*
aDst
int32_t
aDstGap
IntSize
aSize
int32_t
aBPP
)
{
if
(
aSrc
!
=
aDst
)
{
int32_t
rowLength
=
aBPP
*
aSize
.
width
;
for
(
int32_t
height
=
aSize
.
height
;
height
>
0
;
height
-
-
)
{
memcpy
(
aDst
aSrc
rowLength
)
;
aSrc
+
=
rowLength
+
aSrcGap
;
aDst
+
=
rowLength
+
aDstGap
;
}
}
}
template
<
bool
aOpaqueAlpha
uint32_t
aSrcAShift
uint32_t
aDstAShift
>
static
void
SwizzleSwap
(
const
uint8_t
*
aSrc
int32_t
aSrcGap
uint8_t
*
aDst
int32_t
aDstGap
IntSize
aSize
)
{
for
(
int32_t
height
=
aSize
.
height
;
height
>
0
;
height
-
-
)
{
const
uint8_t
*
end
=
aSrc
+
4
*
aSize
.
width
;
do
{
uint32_t
rgba
=
*
reinterpret_cast
<
const
uint32_t
*
>
(
aSrc
)
;
#
if
MOZ_LITTLE_ENDIAN
rgba
=
NativeEndian
:
:
swapToBigEndian
(
rgba
)
;
#
else
rgba
=
NativeEndian
:
:
swapToLittleEndian
(
rgba
)
;
#
endif
if
(
aOpaqueAlpha
)
{
rgba
|
=
0xFF
<
<
aDstAShift
;
}
*
reinterpret_cast
<
uint32_t
*
>
(
aDst
)
=
rgba
;
aSrc
+
=
4
;
aDst
+
=
4
;
}
while
(
aSrc
<
end
)
;
aSrc
+
=
aSrcGap
;
aDst
+
=
aDstGap
;
}
}
#
define
SWIZZLE_SWAP
(
aSrcFormat
aDstFormat
)
\
FORMAT_CASE
(
aSrcFormat
aDstFormat
\
SwizzleSwap
\
<
ShouldForceOpaque
(
aSrcFormat
aDstFormat
)
\
AlphaBitShift
(
aSrcFormat
)
AlphaBitShift
(
aDstFormat
)
>
)
template
<
uint32_t
aDstAShift
>
static
void
SwizzleOpaque
(
const
uint8_t
*
aSrc
int32_t
aSrcGap
uint8_t
*
aDst
int32_t
aDstGap
IntSize
aSize
)
{
if
(
aSrc
=
=
aDst
)
{
for
(
int32_t
height
=
aSize
.
height
;
height
>
0
;
height
-
-
)
{
const
uint8_t
*
end
=
aDst
+
4
*
aSize
.
width
;
do
{
*
reinterpret_cast
<
uint32_t
*
>
(
aDst
)
|
=
0xFF
<
<
aDstAShift
;
aDst
+
=
4
;
}
while
(
aDst
<
end
)
;
aDst
+
=
aDstGap
;
}
}
else
{
for
(
int32_t
height
=
aSize
.
height
;
height
>
0
;
height
-
-
)
{
const
uint8_t
*
end
=
aSrc
+
4
*
aSize
.
width
;
do
{
uint32_t
rgba
=
*
reinterpret_cast
<
const
uint32_t
*
>
(
aSrc
)
;
rgba
|
=
0xFF
<
<
aDstAShift
;
*
reinterpret_cast
<
uint32_t
*
>
(
aDst
)
=
rgba
;
aSrc
+
=
4
;
aDst
+
=
4
;
}
while
(
aSrc
<
end
)
;
aSrc
+
=
aSrcGap
;
aDst
+
=
aDstGap
;
}
}
}
#
define
SWIZZLE_OPAQUE
(
aSrcFormat
aDstFormat
)
\
FORMAT_CASE
(
aSrcFormat
aDstFormat
\
SwizzleOpaque
<
AlphaBitShift
(
aDstFormat
)
>
)
template
<
bool
aSwapRB
uint32_t
aSrcRGBShift
uint32_t
aSrcRGBIndex
>
static
void
PackToRGB565
(
const
uint8_t
*
aSrc
int32_t
aSrcGap
uint8_t
*
aDst
int32_t
aDstGap
IntSize
aSize
)
{
for
(
int32_t
height
=
aSize
.
height
;
height
>
0
;
height
-
-
)
{
const
uint8_t
*
end
=
aSrc
+
4
*
aSize
.
width
;
do
{
uint32_t
rgba
=
*
reinterpret_cast
<
const
uint32_t
*
>
(
aSrc
)
;
uint16_t
rgb565
;
if
(
aSwapRB
)
{
rgb565
=
(
(
rgba
&
(
0xF8
<
<
aSrcRGBShift
)
)
<
<
(
8
-
aSrcRGBShift
)
)
|
(
(
rgba
&
(
0xFC00
<
<
aSrcRGBShift
)
)
>
>
(
5
+
aSrcRGBShift
)
)
|
(
(
rgba
&
(
0xF80000
<
<
aSrcRGBShift
)
)
>
>
(
19
+
aSrcRGBShift
)
)
;
}
else
{
rgb565
=
(
(
rgba
&
(
0xF8
<
<
aSrcRGBShift
)
)
>
>
(
3
+
aSrcRGBShift
)
)
|
(
(
rgba
&
(
0xFC00
<
<
aSrcRGBShift
)
)
>
>
(
5
+
aSrcRGBShift
)
)
|
(
(
rgba
&
(
0xF80000
<
<
aSrcRGBShift
)
)
>
>
(
8
+
aSrcRGBShift
)
)
;
}
*
reinterpret_cast
<
uint16_t
*
>
(
aDst
)
=
rgb565
;
aSrc
+
=
4
;
aDst
+
=
2
;
}
while
(
aSrc
<
end
)
;
aSrc
+
=
aSrcGap
;
aDst
+
=
aDstGap
;
}
}
template
<
bool
aSwapRB
uint32_t
aSrcRGBShift
uint32_t
aSrcRGBIndex
>
static
void
PackToRGB24
(
const
uint8_t
*
aSrc
int32_t
aSrcGap
uint8_t
*
aDst
int32_t
aDstGap
IntSize
aSize
)
{
for
(
int32_t
height
=
aSize
.
height
;
height
>
0
;
height
-
-
)
{
const
uint8_t
*
end
=
aSrc
+
4
*
aSize
.
width
;
do
{
uint8_t
r
=
aSrc
[
aSrcRGBIndex
+
(
aSwapRB
?
2
:
0
)
]
;
uint8_t
g
=
aSrc
[
aSrcRGBIndex
+
1
]
;
uint8_t
b
=
aSrc
[
aSrcRGBIndex
+
(
aSwapRB
?
0
:
2
)
]
;
aDst
[
0
]
=
r
;
aDst
[
1
]
=
g
;
aDst
[
2
]
=
b
;
aSrc
+
=
4
;
aDst
+
=
3
;
}
while
(
aSrc
<
end
)
;
aSrc
+
=
aSrcGap
;
aDst
+
=
aDstGap
;
}
}
#
define
PACK_RGB_CASE
(
aSrcFormat
aDstFormat
aPackFunc
)
\
FORMAT_CASE
(
aSrcFormat
aDstFormat
\
aPackFunc
\
<
ShouldSwapRB
(
aSrcFormat
aDstFormat
)
\
RGBBitShift
(
aSrcFormat
)
RGBByteIndex
(
aSrcFormat
)
>
)
#
define
PACK_RGB
(
aDstFormat
aPackFunc
)
\
PACK_RGB_CASE
(
SurfaceFormat
:
:
B8G8R8A8
aDstFormat
aPackFunc
)
\
PACK_RGB_CASE
(
SurfaceFormat
:
:
B8G8R8X8
aDstFormat
aPackFunc
)
\
PACK_RGB_CASE
(
SurfaceFormat
:
:
R8G8B8A8
aDstFormat
aPackFunc
)
\
PACK_RGB_CASE
(
SurfaceFormat
:
:
R8G8B8X8
aDstFormat
aPackFunc
)
\
PACK_RGB_CASE
(
SurfaceFormat
:
:
A8R8G8B8
aDstFormat
aPackFunc
)
\
PACK_RGB_CASE
(
SurfaceFormat
:
:
X8R8G8B8
aDstFormat
aPackFunc
)
template
<
uint32_t
aSrcAIndex
>
static
void
PackToA8
(
const
uint8_t
*
aSrc
int32_t
aSrcGap
uint8_t
*
aDst
int32_t
aDstGap
IntSize
aSize
)
{
for
(
int32_t
height
=
aSize
.
height
;
height
>
0
;
height
-
-
)
{
const
uint8_t
*
end
=
aSrc
+
4
*
aSize
.
width
;
do
{
*
aDst
+
+
=
aSrc
[
aSrcAIndex
]
;
aSrc
+
=
4
;
}
while
(
aSrc
<
end
)
;
aSrc
+
=
aSrcGap
;
aDst
+
=
aDstGap
;
}
}
#
define
PACK_ALPHA_CASE
(
aSrcFormat
aDstFormat
aPackFunc
)
\
FORMAT_CASE
(
aSrcFormat
aDstFormat
\
aPackFunc
<
AlphaByteIndex
(
aSrcFormat
)
>
)
#
define
PACK_ALPHA
(
aDstFormat
aPackFunc
)
\
PACK_ALPHA_CASE
(
SurfaceFormat
:
:
B8G8R8A8
aDstFormat
aPackFunc
)
\
PACK_ALPHA_CASE
(
SurfaceFormat
:
:
R8G8B8A8
aDstFormat
aPackFunc
)
\
PACK_ALPHA_CASE
(
SurfaceFormat
:
:
A8R8G8B8
aDstFormat
aPackFunc
)
bool
SwizzleData
(
const
uint8_t
*
aSrc
int32_t
aSrcStride
SurfaceFormat
aSrcFormat
uint8_t
*
aDst
int32_t
aDstStride
SurfaceFormat
aDstFormat
const
IntSize
&
aSize
)
{
if
(
aSize
.
IsEmpty
(
)
)
{
return
true
;
}
IntSize
size
=
CollapseSize
(
aSize
aSrcStride
aDstStride
)
;
int32_t
srcGap
=
aSrcStride
-
BytesPerPixel
(
aSrcFormat
)
*
aSize
.
width
;
int32_t
dstGap
=
aDstStride
-
BytesPerPixel
(
aDstFormat
)
*
aSize
.
width
;
MOZ_ASSERT
(
srcGap
>
=
0
&
&
dstGap
>
=
0
)
;
#
define
FORMAT_CASE_CALL
(
.
.
.
)
__VA_ARGS__
(
aSrc
srcGap
aDst
dstGap
size
)
#
ifdef
USE_SSE2
switch
(
FORMAT_KEY
(
aSrcFormat
aDstFormat
)
)
{
SWIZZLE_SSE2
(
SurfaceFormat
:
:
B8G8R8A8
SurfaceFormat
:
:
R8G8B8A8
)
SWIZZLE_SSE2
(
SurfaceFormat
:
:
B8G8R8X8
SurfaceFormat
:
:
R8G8B8X8
)
SWIZZLE_SSE2
(
SurfaceFormat
:
:
B8G8R8A8
SurfaceFormat
:
:
R8G8B8X8
)
SWIZZLE_SSE2
(
SurfaceFormat
:
:
B8G8R8X8
SurfaceFormat
:
:
R8G8B8A8
)
SWIZZLE_SSE2
(
SurfaceFormat
:
:
R8G8B8A8
SurfaceFormat
:
:
B8G8R8A8
)
SWIZZLE_SSE2
(
SurfaceFormat
:
:
R8G8B8X8
SurfaceFormat
:
:
B8G8R8X8
)
SWIZZLE_SSE2
(
SurfaceFormat
:
:
R8G8B8A8
SurfaceFormat
:
:
B8G8R8X8
)
SWIZZLE_SSE2
(
SurfaceFormat
:
:
R8G8B8X8
SurfaceFormat
:
:
B8G8R8A8
)
default
:
break
;
}
#
endif
#
ifdef
BUILD_ARM_NEON
if
(
mozilla
:
:
supports_neon
(
)
)
switch
(
FORMAT_KEY
(
aSrcFormat
aDstFormat
)
)
{
SWIZZLE_NEON
(
SurfaceFormat
:
:
B8G8R8A8
SurfaceFormat
:
:
R8G8B8A8
)
SWIZZLE_NEON
(
SurfaceFormat
:
:
B8G8R8X8
SurfaceFormat
:
:
R8G8B8X8
)
SWIZZLE_NEON
(
SurfaceFormat
:
:
B8G8R8A8
SurfaceFormat
:
:
R8G8B8X8
)
SWIZZLE_NEON
(
SurfaceFormat
:
:
B8G8R8X8
SurfaceFormat
:
:
R8G8B8A8
)
SWIZZLE_NEON
(
SurfaceFormat
:
:
R8G8B8A8
SurfaceFormat
:
:
B8G8R8A8
)
SWIZZLE_NEON
(
SurfaceFormat
:
:
R8G8B8X8
SurfaceFormat
:
:
B8G8R8X8
)
SWIZZLE_NEON
(
SurfaceFormat
:
:
R8G8B8A8
SurfaceFormat
:
:
B8G8R8X8
)
SWIZZLE_NEON
(
SurfaceFormat
:
:
R8G8B8X8
SurfaceFormat
:
:
B8G8R8A8
)
default
:
break
;
}
#
endif
switch
(
FORMAT_KEY
(
aSrcFormat
aDstFormat
)
)
{
SWIZZLE_FALLBACK
(
SurfaceFormat
:
:
B8G8R8A8
SurfaceFormat
:
:
R8G8B8A8
)
SWIZZLE_FALLBACK
(
SurfaceFormat
:
:
B8G8R8X8
SurfaceFormat
:
:
R8G8B8X8
)
SWIZZLE_FALLBACK
(
SurfaceFormat
:
:
B8G8R8A8
SurfaceFormat
:
:
R8G8B8X8
)
SWIZZLE_FALLBACK
(
SurfaceFormat
:
:
B8G8R8X8
SurfaceFormat
:
:
R8G8B8A8
)
SWIZZLE_FALLBACK
(
SurfaceFormat
:
:
R8G8B8A8
SurfaceFormat
:
:
B8G8R8A8
)
SWIZZLE_FALLBACK
(
SurfaceFormat
:
:
R8G8B8X8
SurfaceFormat
:
:
B8G8R8X8
)
SWIZZLE_FALLBACK
(
SurfaceFormat
:
:
R8G8B8A8
SurfaceFormat
:
:
B8G8R8X8
)
SWIZZLE_FALLBACK
(
SurfaceFormat
:
:
R8G8B8X8
SurfaceFormat
:
:
B8G8R8A8
)
SWIZZLE_FALLBACK
(
SurfaceFormat
:
:
R8G8B8A8
SurfaceFormat
:
:
A8R8G8B8
)
SWIZZLE_FALLBACK
(
SurfaceFormat
:
:
R8G8B8X8
SurfaceFormat
:
:
X8R8G8B8
)
SWIZZLE_FALLBACK
(
SurfaceFormat
:
:
A8R8G8B8
SurfaceFormat
:
:
R8G8B8A8
)
SWIZZLE_FALLBACK
(
SurfaceFormat
:
:
X8R8G8B8
SurfaceFormat
:
:
R8G8B8X8
)
SWIZZLE_FALLBACK
(
SurfaceFormat
:
:
A8R8G8B8
SurfaceFormat
:
:
R8G8B8X8
)
SWIZZLE_FALLBACK
(
SurfaceFormat
:
:
X8R8G8B8
SurfaceFormat
:
:
R8G8B8A8
)
SWIZZLE_SWAP
(
SurfaceFormat
:
:
B8G8R8A8
SurfaceFormat
:
:
A8R8G8B8
)
SWIZZLE_SWAP
(
SurfaceFormat
:
:
B8G8R8A8
SurfaceFormat
:
:
X8R8G8B8
)
SWIZZLE_SWAP
(
SurfaceFormat
:
:
B8G8R8X8
SurfaceFormat
:
:
X8R8G8B8
)
SWIZZLE_SWAP
(
SurfaceFormat
:
:
B8G8R8X8
SurfaceFormat
:
:
A8R8G8B8
)
SWIZZLE_SWAP
(
SurfaceFormat
:
:
A8R8G8B8
SurfaceFormat
:
:
B8G8R8A8
)
SWIZZLE_SWAP
(
SurfaceFormat
:
:
A8R8G8B8
SurfaceFormat
:
:
B8G8R8X8
)
SWIZZLE_SWAP
(
SurfaceFormat
:
:
X8R8G8B8
SurfaceFormat
:
:
B8G8R8X8
)
SWIZZLE_SWAP
(
SurfaceFormat
:
:
X8R8G8B8
SurfaceFormat
:
:
B8G8R8A8
)
SWIZZLE_OPAQUE
(
SurfaceFormat
:
:
B8G8R8A8
SurfaceFormat
:
:
B8G8R8X8
)
SWIZZLE_OPAQUE
(
SurfaceFormat
:
:
B8G8R8X8
SurfaceFormat
:
:
B8G8R8A8
)
SWIZZLE_OPAQUE
(
SurfaceFormat
:
:
R8G8B8A8
SurfaceFormat
:
:
R8G8B8X8
)
SWIZZLE_OPAQUE
(
SurfaceFormat
:
:
R8G8B8X8
SurfaceFormat
:
:
R8G8B8A8
)
SWIZZLE_OPAQUE
(
SurfaceFormat
:
:
A8R8G8B8
SurfaceFormat
:
:
X8R8G8B8
)
SWIZZLE_OPAQUE
(
SurfaceFormat
:
:
X8R8G8B8
SurfaceFormat
:
:
A8R8G8B8
)
PACK_RGB
(
SurfaceFormat
:
:
R5G6B5_UINT16
PackToRGB565
)
PACK_RGB
(
SurfaceFormat
:
:
B8G8R8
PackToRGB24
)
PACK_RGB
(
SurfaceFormat
:
:
R8G8B8
PackToRGB24
)
PACK_ALPHA
(
SurfaceFormat
:
:
A8
PackToA8
)
default
:
break
;
}
if
(
aSrcFormat
=
=
aDstFormat
)
{
SwizzleCopy
(
aSrc
srcGap
aDst
dstGap
size
BytesPerPixel
(
aSrcFormat
)
)
;
return
true
;
}
#
undef
FORMAT_CASE_CALL
gfxCriticalError
(
)
<
<
"
Unsupported
swizzle
formats
:
"
<
<
aSrcFormat
<
<
"
-
>
"
<
<
aDstFormat
;
return
false
;
}
}
}
