#
include
<
stdlib
.
h
>
#
include
<
mmintrin
.
h
>
#
include
<
xmmintrin
.
h
>
#
include
<
emmintrin
.
h
>
#
include
<
tmmintrin
.
h
>
#
include
<
stdint
.
h
>
#
include
<
assert
.
h
>
#
include
"
ssse3
-
scaler
.
h
"
typedef
int32_t
pixman_fixed_16_16_t
;
typedef
pixman_fixed_16_16_t
pixman_fixed_t
;
#
define
pixman_fixed_1
(
pixman_int_to_fixed
(
1
)
)
#
define
pixman_fixed_to_int
(
f
)
(
(
int
)
(
(
f
)
>
>
16
)
)
#
define
pixman_int_to_fixed
(
i
)
(
(
pixman_fixed_t
)
(
(
i
)
<
<
16
)
)
#
define
pixman_double_to_fixed
(
d
)
(
(
pixman_fixed_t
)
(
(
d
)
*
65536
.
0
)
)
typedef
struct
pixman_vector
pixman_vector_t
;
typedef
int
pixman_bool_t
;
typedef
int64_t
pixman_fixed_32_32_t
;
typedef
pixman_fixed_32_32_t
pixman_fixed_48_16_t
;
typedef
struct
{
pixman_fixed_48_16_t
v
[
3
]
;
}
pixman_vector_48_16_t
;
struct
pixman_vector
{
pixman_fixed_t
vector
[
3
]
;
}
;
typedef
struct
pixman_transform
pixman_transform_t
;
struct
pixman_transform
{
pixman_fixed_t
matrix
[
3
]
[
3
]
;
}
;
#
ifdef
_MSC_VER
#
define
force_inline
__forceinline
#
else
#
define
force_inline
__inline__
__attribute__
(
(
always_inline
)
)
#
endif
#
define
BILINEAR_INTERPOLATION_BITS
6
static
force_inline
int
pixman_fixed_to_bilinear_weight
(
pixman_fixed_t
x
)
{
return
(
x
>
>
(
16
-
BILINEAR_INTERPOLATION_BITS
)
)
&
(
(
1
<
<
BILINEAR_INTERPOLATION_BITS
)
-
1
)
;
}
static
void
pixman_transform_point_31_16_3d
(
const
pixman_transform_t
*
t
const
pixman_vector_48_16_t
*
v
pixman_vector_48_16_t
*
result
)
{
int
i
;
int64_t
tmp
[
3
]
[
2
]
;
assert
(
v
-
>
v
[
0
]
<
(
(
pixman_fixed_48_16_t
)
1
<
<
(
30
+
16
)
)
)
;
assert
(
v
-
>
v
[
0
]
>
=
-
(
(
pixman_fixed_48_16_t
)
1
<
<
(
30
+
16
)
)
)
;
assert
(
v
-
>
v
[
1
]
<
(
(
pixman_fixed_48_16_t
)
1
<
<
(
30
+
16
)
)
)
;
assert
(
v
-
>
v
[
1
]
>
=
-
(
(
pixman_fixed_48_16_t
)
1
<
<
(
30
+
16
)
)
)
;
assert
(
v
-
>
v
[
2
]
<
(
(
pixman_fixed_48_16_t
)
1
<
<
(
30
+
16
)
)
)
;
assert
(
v
-
>
v
[
2
]
>
=
-
(
(
pixman_fixed_48_16_t
)
1
<
<
(
30
+
16
)
)
)
;
for
(
i
=
0
;
i
<
3
;
i
+
+
)
{
tmp
[
i
]
[
0
]
=
(
int64_t
)
t
-
>
matrix
[
i
]
[
0
]
*
(
v
-
>
v
[
0
]
>
>
16
)
;
tmp
[
i
]
[
1
]
=
(
int64_t
)
t
-
>
matrix
[
i
]
[
0
]
*
(
v
-
>
v
[
0
]
&
0xFFFF
)
;
tmp
[
i
]
[
0
]
+
=
(
int64_t
)
t
-
>
matrix
[
i
]
[
1
]
*
(
v
-
>
v
[
1
]
>
>
16
)
;
tmp
[
i
]
[
1
]
+
=
(
int64_t
)
t
-
>
matrix
[
i
]
[
1
]
*
(
v
-
>
v
[
1
]
&
0xFFFF
)
;
tmp
[
i
]
[
0
]
+
=
(
int64_t
)
t
-
>
matrix
[
i
]
[
2
]
*
(
v
-
>
v
[
2
]
>
>
16
)
;
tmp
[
i
]
[
1
]
+
=
(
int64_t
)
t
-
>
matrix
[
i
]
[
2
]
*
(
v
-
>
v
[
2
]
&
0xFFFF
)
;
}
result
-
>
v
[
0
]
=
tmp
[
0
]
[
0
]
+
(
(
tmp
[
0
]
[
1
]
+
0x8000
)
>
>
16
)
;
result
-
>
v
[
1
]
=
tmp
[
1
]
[
0
]
+
(
(
tmp
[
1
]
[
1
]
+
0x8000
)
>
>
16
)
;
result
-
>
v
[
2
]
=
tmp
[
2
]
[
0
]
+
(
(
tmp
[
2
]
[
1
]
+
0x8000
)
>
>
16
)
;
}
static
pixman_bool_t
pixman_transform_point_3d
(
const
struct
pixman_transform
*
transform
struct
pixman_vector
*
vector
)
{
pixman_vector_48_16_t
tmp
;
tmp
.
v
[
0
]
=
vector
-
>
vector
[
0
]
;
tmp
.
v
[
1
]
=
vector
-
>
vector
[
1
]
;
tmp
.
v
[
2
]
=
vector
-
>
vector
[
2
]
;
pixman_transform_point_31_16_3d
(
transform
&
tmp
&
tmp
)
;
vector
-
>
vector
[
0
]
=
tmp
.
v
[
0
]
;
vector
-
>
vector
[
1
]
=
tmp
.
v
[
1
]
;
vector
-
>
vector
[
2
]
=
tmp
.
v
[
2
]
;
return
vector
-
>
vector
[
0
]
=
=
tmp
.
v
[
0
]
&
&
vector
-
>
vector
[
1
]
=
=
tmp
.
v
[
1
]
&
&
vector
-
>
vector
[
2
]
=
=
tmp
.
v
[
2
]
;
}
struct
bits_image_t
{
uint32_t
*
bits
;
int
rowstride
;
pixman_transform_t
*
transform
;
}
;
typedef
struct
bits_image_t
bits_image_t
;
typedef
struct
{
int
unused
;
}
pixman_iter_info_t
;
typedef
struct
pixman_iter_t
pixman_iter_t
;
typedef
void
(
*
pixman_iter_fini_t
)
(
pixman_iter_t
*
iter
)
;
struct
pixman_iter_t
{
int
x
y
;
pixman_iter_fini_t
fini
;
bits_image_t
*
image
;
uint32_t
*
buffer
;
int
width
;
int
height
;
void
*
data
;
}
;
typedef
struct
{
int
y
;
uint64_t
*
buffer
;
}
line_t
;
typedef
struct
{
line_t
lines
[
2
]
;
pixman_fixed_t
y
;
pixman_fixed_t
x
;
uint64_t
data
[
1
]
;
}
bilinear_info_t
;
static
void
ssse3_fetch_horizontal
(
bits_image_t
*
image
line_t
*
line
int
y
pixman_fixed_t
x
pixman_fixed_t
ux
int
n
)
{
uint32_t
*
bits
=
image
-
>
bits
+
y
*
image
-
>
rowstride
;
__m128i
vx
=
_mm_set_epi16
(
-
(
x
+
1
)
x
-
(
x
+
1
)
x
-
(
x
+
ux
+
1
)
x
+
ux
-
(
x
+
ux
+
1
)
x
+
ux
)
;
__m128i
vux
=
_mm_set_epi16
(
-
2
*
ux
2
*
ux
-
2
*
ux
2
*
ux
-
2
*
ux
2
*
ux
-
2
*
ux
2
*
ux
)
;
__m128i
vaddc
=
_mm_set_epi16
(
1
0
1
0
1
0
1
0
)
;
__m128i
*
b
=
(
__m128i
*
)
line
-
>
buffer
;
__m128i
vrl0
vrl1
;
while
(
(
n
-
=
2
)
>
=
0
)
{
__m128i
vw
vr
s
;
#
ifdef
HACKY_PADDING
if
(
pixman_fixed_to_int
(
x
+
ux
)
>
=
image
-
>
rowstride
)
{
vrl1
=
_mm_setzero_si128
(
)
;
printf
(
"
overread
2loop
\
n
"
)
;
}
else
{
if
(
pixman_fixed_to_int
(
x
+
ux
)
<
0
)
printf
(
"
underflow
\
n
"
)
;
vrl1
=
_mm_loadl_epi64
(
(
__m128i
*
)
(
bits
+
(
pixman_fixed_to_int
(
x
+
ux
)
<
0
?
0
:
pixman_fixed_to_int
(
x
+
ux
)
)
)
)
;
}
#
else
vrl1
=
_mm_loadl_epi64
(
(
__m128i
*
)
(
bits
+
pixman_fixed_to_int
(
x
+
ux
)
)
)
;
#
endif
final_pixel
:
#
ifdef
HACKY_PADDING
vrl0
=
_mm_loadl_epi64
(
(
__m128i
*
)
(
bits
+
(
pixman_fixed_to_int
(
x
)
<
0
?
0
:
pixman_fixed_to_int
(
x
)
)
)
)
;
#
else
vrl0
=
_mm_loadl_epi64
(
(
__m128i
*
)
(
bits
+
pixman_fixed_to_int
(
x
)
)
)
;
#
endif
vw
=
_mm_add_epi16
(
vaddc
_mm_srli_epi16
(
vx
16
-
BILINEAR_INTERPOLATION_BITS
)
)
;
vw
=
_mm_packus_epi16
(
vw
vw
)
;
vx
=
_mm_add_epi16
(
vx
vux
)
;
x
+
=
2
*
ux
;
vr
=
_mm_unpacklo_epi16
(
vrl1
vrl0
)
;
s
=
_mm_shuffle_epi32
(
vr
_MM_SHUFFLE
(
1
0
3
2
)
)
;
vr
=
_mm_unpackhi_epi8
(
vr
s
)
;
vr
=
_mm_maddubs_epi16
(
vr
vw
)
;
vr
=
_mm_shuffle_epi32
(
vr
_MM_SHUFFLE
(
2
0
3
1
)
)
;
_mm_store_si128
(
b
+
+
vr
)
;
}
if
(
n
=
=
-
1
)
{
vrl1
=
_mm_setzero_si128
(
)
;
goto
final_pixel
;
}
line
-
>
y
=
y
;
}
static
uint32_t
*
ssse3_fetch_bilinear_cover
(
pixman_iter_t
*
iter
const
uint32_t
*
mask
)
{
pixman_fixed_t
fx
ux
;
bilinear_info_t
*
info
=
iter
-
>
data
;
line_t
*
line0
*
line1
;
int
y0
y1
;
int32_t
dist_y
;
__m128i
vw
uvw
;
int
i
;
fx
=
info
-
>
x
;
ux
=
iter
-
>
image
-
>
transform
-
>
matrix
[
0
]
[
0
]
;
y0
=
pixman_fixed_to_int
(
info
-
>
y
)
;
if
(
y0
<
0
)
*
(
volatile
char
*
)
0
=
9
;
y1
=
y0
+
1
;
if
(
y1
>
=
iter
-
>
height
)
{
y1
=
iter
-
>
height
-
1
;
}
line0
=
&
info
-
>
lines
[
y0
&
0x01
]
;
line1
=
&
info
-
>
lines
[
y1
&
0x01
]
;
if
(
line0
-
>
y
!
=
y0
)
{
ssse3_fetch_horizontal
(
iter
-
>
image
line0
y0
fx
ux
iter
-
>
width
)
;
}
if
(
line1
-
>
y
!
=
y1
)
{
ssse3_fetch_horizontal
(
iter
-
>
image
line1
y1
fx
ux
iter
-
>
width
)
;
}
#
ifdef
PIXMAN_STYLE_INTERPOLATION
dist_y
=
pixman_fixed_to_bilinear_weight
(
info
-
>
y
)
;
dist_y
<
<
=
(
16
-
BILINEAR_INTERPOLATION_BITS
)
;
vw
=
_mm_set_epi16
(
dist_y
dist_y
dist_y
dist_y
dist_y
dist_y
dist_y
dist_y
)
;
#
else
dist_y
=
pixman_fixed_to_bilinear_weight
(
info
-
>
y
)
;
dist_y
<
<
=
(
15
-
BILINEAR_INTERPOLATION_BITS
)
;
vw
=
_mm_set_epi16
(
dist_y
dist_y
dist_y
dist_y
dist_y
dist_y
dist_y
dist_y
)
;
dist_y
=
(
1
<
<
BILINEAR_INTERPOLATION_BITS
)
-
pixman_fixed_to_bilinear_weight
(
info
-
>
y
)
;
dist_y
<
<
=
(
15
-
BILINEAR_INTERPOLATION_BITS
)
;
uvw
=
_mm_set_epi16
(
dist_y
dist_y
dist_y
dist_y
dist_y
dist_y
dist_y
dist_y
)
;
#
endif
for
(
i
=
0
;
i
+
3
<
iter
-
>
width
;
i
+
=
4
)
{
__m128i
top0
=
_mm_load_si128
(
(
__m128i
*
)
(
line0
-
>
buffer
+
i
)
)
;
__m128i
bot0
=
_mm_load_si128
(
(
__m128i
*
)
(
line1
-
>
buffer
+
i
)
)
;
__m128i
top1
=
_mm_load_si128
(
(
__m128i
*
)
(
line0
-
>
buffer
+
i
+
2
)
)
;
__m128i
bot1
=
_mm_load_si128
(
(
__m128i
*
)
(
line1
-
>
buffer
+
i
+
2
)
)
;
#
ifdef
PIXMAN_STYLE_INTERPOLATION
__m128i
r0
r1
tmp
p
;
r0
=
_mm_mulhi_epu16
(
_mm_sub_epi16
(
bot0
top0
)
vw
)
;
tmp
=
_mm_cmplt_epi16
(
bot0
top0
)
;
tmp
=
_mm_and_si128
(
tmp
vw
)
;
r0
=
_mm_sub_epi16
(
r0
tmp
)
;
r0
=
_mm_add_epi16
(
r0
top0
)
;
r0
=
_mm_srli_epi16
(
r0
BILINEAR_INTERPOLATION_BITS
)
;
r1
=
_mm_mulhi_epu16
(
_mm_sub_epi16
(
bot1
top1
)
vw
)
;
tmp
=
_mm_cmplt_epi16
(
bot1
top1
)
;
tmp
=
_mm_and_si128
(
tmp
vw
)
;
r1
=
_mm_sub_epi16
(
r1
tmp
)
;
r1
=
_mm_add_epi16
(
r1
top1
)
;
r1
=
_mm_srli_epi16
(
r1
BILINEAR_INTERPOLATION_BITS
)
;
#
else
__m128i
r0
r1
p
;
top0
=
_mm_mulhi_epu16
(
top0
uvw
)
;
bot0
=
_mm_mulhi_epu16
(
bot0
vw
)
;
r0
=
_mm_add_epi16
(
top0
bot0
)
;
r0
=
_mm_srli_epi16
(
r0
BILINEAR_INTERPOLATION_BITS
-
1
)
;
top1
=
_mm_mulhi_epu16
(
top1
uvw
)
;
bot1
=
_mm_mulhi_epu16
(
bot1
vw
)
;
r1
=
_mm_add_epi16
(
top1
bot1
)
;
r1
=
_mm_srli_epi16
(
r1
BILINEAR_INTERPOLATION_BITS
-
1
)
;
#
endif
p
=
_mm_packus_epi16
(
r0
r1
)
;
_mm_storeu_si128
(
(
__m128i
*
)
(
iter
-
>
buffer
+
i
)
p
)
;
}
while
(
i
<
iter
-
>
width
)
{
__m128i
top0
=
_mm_load_si128
(
(
__m128i
*
)
(
line0
-
>
buffer
+
i
)
)
;
__m128i
bot0
=
_mm_load_si128
(
(
__m128i
*
)
(
line1
-
>
buffer
+
i
)
)
;
#
ifdef
PIXMAN_STYLE_INTERPOLATION
__m128i
r0
tmp
p
;
r0
=
_mm_mulhi_epu16
(
_mm_sub_epi16
(
bot0
top0
)
vw
)
;
tmp
=
_mm_cmplt_epi16
(
bot0
top0
)
;
tmp
=
_mm_and_si128
(
tmp
vw
)
;
r0
=
_mm_sub_epi16
(
r0
tmp
)
;
r0
=
_mm_add_epi16
(
r0
top0
)
;
r0
=
_mm_srli_epi16
(
r0
BILINEAR_INTERPOLATION_BITS
)
;
r0
=
_mm_shuffle_epi32
(
r0
_MM_SHUFFLE
(
2
0
3
1
)
)
;
#
else
__m128i
r0
p
;
top0
=
_mm_mulhi_epu16
(
top0
uvw
)
;
bot0
=
_mm_mulhi_epu16
(
bot0
vw
)
;
r0
=
_mm_add_epi16
(
top0
bot0
)
;
r0
=
_mm_srli_epi16
(
r0
BILINEAR_INTERPOLATION_BITS
-
1
)
;
#
endif
p
=
_mm_packus_epi16
(
r0
r0
)
;
if
(
iter
-
>
width
-
i
=
=
1
)
{
*
(
uint32_t
*
)
(
iter
-
>
buffer
+
i
)
=
_mm_cvtsi128_si32
(
p
)
;
i
+
+
;
}
else
{
_mm_storel_epi64
(
(
__m128i
*
)
(
iter
-
>
buffer
+
i
)
p
)
;
i
+
=
2
;
}
}
info
-
>
y
+
=
iter
-
>
image
-
>
transform
-
>
matrix
[
1
]
[
1
]
;
return
iter
-
>
buffer
;
}
static
void
ssse3_bilinear_cover_iter_fini
(
pixman_iter_t
*
iter
)
{
free
(
iter
-
>
data
)
;
}
static
void
ssse3_bilinear_cover_iter_init
(
pixman_iter_t
*
iter
)
{
int
width
=
iter
-
>
width
;
bilinear_info_t
*
info
;
pixman_vector_t
v
;
v
.
vector
[
0
]
=
pixman_int_to_fixed
(
iter
-
>
x
)
+
pixman_fixed_1
/
2
;
v
.
vector
[
1
]
=
pixman_int_to_fixed
(
iter
-
>
y
)
+
pixman_fixed_1
/
2
;
v
.
vector
[
2
]
=
pixman_fixed_1
;
if
(
!
pixman_transform_point_3d
(
iter
-
>
image
-
>
transform
&
v
)
)
goto
fail
;
info
=
malloc
(
sizeof
(
*
info
)
+
(
2
*
width
-
1
)
*
sizeof
(
uint64_t
)
+
64
)
;
if
(
!
info
)
goto
fail
;
info
-
>
x
=
v
.
vector
[
0
]
-
pixman_fixed_1
/
2
;
info
-
>
y
=
v
.
vector
[
1
]
-
pixman_fixed_1
/
2
;
#
define
ALIGN
(
addr
)
\
(
(
void
*
)
(
(
(
(
uintptr_t
)
(
addr
)
)
+
15
)
&
(
~
15
)
)
)
info
-
>
lines
[
0
]
.
y
=
-
1
;
info
-
>
lines
[
0
]
.
buffer
=
ALIGN
(
&
(
info
-
>
data
[
0
]
)
)
;
info
-
>
lines
[
1
]
.
y
=
-
1
;
info
-
>
lines
[
1
]
.
buffer
=
ALIGN
(
info
-
>
lines
[
0
]
.
buffer
+
width
)
;
iter
-
>
fini
=
ssse3_bilinear_cover_iter_fini
;
iter
-
>
data
=
info
;
return
;
fail
:
iter
-
>
fini
=
NULL
;
}
bool
ssse3_scale_data
(
uint32_t
*
src
int
src_width
int
src_height
int
src_stride
uint32_t
*
dest
int
dest_width
int
dest_height
int
dest_stride
int
x
int
y
int
width
int
height
)
{
pixman_transform_t
transform
=
{
{
{
pixman_fixed_1
0
0
}
{
0
pixman_fixed_1
0
}
{
0
0
pixman_fixed_1
}
}
}
;
double
width_scale
=
(
(
double
)
src_width
)
/
dest_width
;
double
height_scale
=
(
(
double
)
src_height
)
/
dest_height
;
#
define
AVOID_PADDING
#
ifdef
AVOID_PADDING
if
(
width_scale
<
1
)
{
width_scale
=
(
double
)
(
src_width
-
1
)
/
dest_width
;
transform
.
matrix
[
0
]
[
2
]
=
pixman_fixed_1
/
2
;
}
if
(
height_scale
<
1
)
{
height_scale
=
(
double
)
(
src_height
-
1
)
/
dest_height
;
transform
.
matrix
[
1
]
[
2
]
=
pixman_fixed_1
/
2
;
}
#
endif
transform
.
matrix
[
0
]
[
0
]
=
pixman_double_to_fixed
(
width_scale
)
;
transform
.
matrix
[
1
]
[
1
]
=
pixman_double_to_fixed
(
height_scale
)
;
transform
.
matrix
[
2
]
[
2
]
=
pixman_fixed_1
;
bits_image_t
image
;
image
.
bits
=
src
;
image
.
transform
=
&
transform
;
image
.
rowstride
=
src_stride
;
pixman_iter_t
iter
;
iter
.
image
=
&
image
;
iter
.
x
=
x
;
iter
.
y
=
y
;
iter
.
width
=
width
;
iter
.
height
=
src_height
;
iter
.
buffer
=
dest
;
iter
.
data
=
NULL
;
ssse3_bilinear_cover_iter_init
(
&
iter
)
;
if
(
!
iter
.
fini
)
return
false
;
if
(
iter
.
data
)
{
for
(
int
iy
=
0
;
iy
<
height
;
iy
+
+
)
{
ssse3_fetch_bilinear_cover
(
&
iter
NULL
)
;
iter
.
buffer
+
=
dest_stride
;
}
ssse3_bilinear_cover_iter_fini
(
&
iter
)
;
}
return
true
;
}
