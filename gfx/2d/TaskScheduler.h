#
ifndef
MOZILLA_GFX_TASKSCHEDULER_H_
#
define
MOZILLA_GFX_TASKSCHEDULER_H_
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
ifdef
WIN32
#
include
"
mozilla
/
gfx
/
TaskScheduler_win32
.
h
"
#
else
#
include
"
mozilla
/
gfx
/
TaskScheduler_posix
.
h
"
#
endif
#
include
<
vector
>
namespace
mozilla
{
namespace
gfx
{
class
MultiThreadedTaskQueue
;
class
SyncObject
;
class
WorkerThread
;
class
TaskScheduler
{
public
:
static
MultiThreadedTaskQueue
*
GetDrawingQueue
(
)
{
return
sSingleton
-
>
mDrawingQueues
[
sSingleton
-
>
mNextQueue
+
+
%
sSingleton
-
>
mDrawingQueues
.
size
(
)
]
;
}
static
MultiThreadedTaskQueue
*
GetDrawingQueue
(
uint32_t
aHash
)
{
return
sSingleton
-
>
mDrawingQueues
[
aHash
%
sSingleton
-
>
mDrawingQueues
.
size
(
)
]
;
}
static
bool
Init
(
uint32_t
aNumThreads
uint32_t
aNumQueues
)
;
static
void
ShutDown
(
)
;
static
bool
IsEnabled
(
)
{
return
!
!
sSingleton
;
}
static
void
SubmitTask
(
Task
*
aTasks
)
;
static
TaskStatus
ProcessTask
(
Task
*
aTasks
)
;
protected
:
static
TaskScheduler
*
sSingleton
;
std
:
:
vector
<
MultiThreadedTaskQueue
*
>
mDrawingQueues
;
std
:
:
vector
<
WorkerThread
*
>
mWorkerThreads
;
Atomic
<
uint32_t
>
mNextQueue
;
}
;
class
Task
{
public
:
Task
(
MultiThreadedTaskQueue
*
aQueue
SyncObject
*
aStart
=
nullptr
SyncObject
*
aCompletion
=
nullptr
)
;
virtual
~
Task
(
)
;
virtual
TaskStatus
Run
(
)
=
0
;
SyncObject
*
GetStartSync
(
)
{
return
mStartSync
;
}
MultiThreadedTaskQueue
*
GetTaskQueue
(
)
{
return
mQueue
;
}
protected
:
MultiThreadedTaskQueue
*
mQueue
;
RefPtr
<
SyncObject
>
mStartSync
;
RefPtr
<
SyncObject
>
mCompletionSync
;
}
;
class
EventObject
;
class
SetEventTask
:
public
Task
{
public
:
explicit
SetEventTask
(
MultiThreadedTaskQueue
*
aQueue
SyncObject
*
aStart
=
nullptr
SyncObject
*
aCompletion
=
nullptr
)
;
~
SetEventTask
(
)
;
TaskStatus
Run
(
)
override
;
EventObject
*
GetEvent
(
)
{
return
mEvent
;
}
protected
:
RefPtr
<
EventObject
>
mEvent
;
}
;
class
SyncObject
final
:
public
external
:
:
AtomicRefCounted
<
SyncObject
>
{
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
SyncObject
)
SyncObject
(
)
;
~
SyncObject
(
)
;
bool
Register
(
Task
*
aTask
)
;
void
Signal
(
)
;
bool
IsSignaled
(
)
;
private
:
void
AddSubsequent
(
Task
*
aTask
)
;
void
AddPrerequisite
(
Task
*
aTask
)
;
void
AddWaitingTask
(
Task
*
aTask
)
;
void
SubmitWaitingTasks
(
)
;
#
ifdef
DEBUG
std
:
:
vector
<
Task
*
>
mPrerequisites
;
std
:
:
vector
<
Task
*
>
mSubsequents
;
Atomic
<
bool
>
mHasSubmittedSubsequent
;
#
endif
std
:
:
vector
<
Task
*
>
mWaitingTasks
;
Mutex
mMutex
;
Atomic
<
uint32_t
>
mSignals
;
friend
class
Task
;
friend
class
TaskScheduler
;
}
;
struct
MutexAutoLock
{
explicit
MutexAutoLock
(
Mutex
*
aMutex
)
:
mMutex
(
aMutex
)
{
mMutex
-
>
Lock
(
)
;
}
~
MutexAutoLock
(
)
{
mMutex
-
>
Unlock
(
)
;
}
protected
:
Mutex
*
mMutex
;
}
;
class
WorkerThread
{
public
:
static
WorkerThread
*
Create
(
MultiThreadedTaskQueue
*
aTaskQueue
)
;
virtual
~
WorkerThread
(
)
{
}
void
Run
(
)
;
protected
:
explicit
WorkerThread
(
MultiThreadedTaskQueue
*
aTaskQueue
)
;
MultiThreadedTaskQueue
*
mQueue
;
}
;
}
}
#
endif
