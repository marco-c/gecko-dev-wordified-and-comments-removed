#
ifndef
mozilla_gfx_2d_SourceSurfaceCapture_h
#
define
mozilla_gfx_2d_SourceSurfaceCapture_h
#
include
"
2D
.
h
"
#
include
"
CaptureCommandList
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
namespace
mozilla
{
namespace
gfx
{
class
DrawTargetCaptureImpl
;
class
SourceSurfaceCapture
:
public
SourceSurface
{
friend
class
DrawTargetCaptureImpl
;
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
SourceSurfaceCapture
override
)
explicit
SourceSurfaceCapture
(
DrawTargetCaptureImpl
*
aOwner
)
;
explicit
SourceSurfaceCapture
(
DrawTargetCaptureImpl
*
aOwner
LuminanceType
aLuminanceType
float
aOpacity
)
;
explicit
SourceSurfaceCapture
(
DrawTargetCaptureImpl
*
aOwner
SourceSurface
*
aSurfToOptimize
)
;
~
SourceSurfaceCapture
(
)
;
SurfaceType
GetType
(
)
const
override
{
return
SurfaceType
:
:
CAPTURE
;
}
IntSize
GetSize
(
)
const
override
{
return
mSize
;
}
SurfaceFormat
GetFormat
(
)
const
override
{
return
mFormat
;
}
bool
IsValid
(
)
const
override
;
already_AddRefed
<
DataSourceSurface
>
GetDataSurface
(
)
override
;
RefPtr
<
SourceSurface
>
Resolve
(
BackendType
aBackendType
=
BackendType
:
:
NONE
)
;
protected
:
RefPtr
<
SourceSurface
>
ResolveImpl
(
BackendType
aBackendType
)
;
void
DrawTargetWillDestroy
(
)
;
void
DrawTargetWillChange
(
)
;
private
:
IntSize
mSize
;
SurfaceFormat
mFormat
;
int32_t
mStride
;
int32_t
mSurfaceAllocationSize
;
RefPtr
<
DrawTarget
>
mRefDT
;
DrawTargetCaptureImpl
*
mOwner
;
CaptureCommandList
mCommands
;
bool
mHasCommandList
;
bool
mShouldResolveToLuminance
;
LuminanceType
mLuminanceType
;
float
mOpacity
;
mutable
Mutex
mLock
;
RefPtr
<
SourceSurface
>
mResolved
;
RefPtr
<
SourceSurface
>
mSurfToOptimize
;
}
;
}
}
#
endif
