#
include
"
DrawTargetSkia
.
h
"
#
include
"
SourceSurfaceSkia
.
h
"
#
include
"
ScaledFontBase
.
h
"
#
include
"
ScaledFontCairo
.
h
"
#
include
"
skia
/
include
/
core
/
SkBitmapDevice
.
h
"
#
include
"
FilterNodeSoftware
.
h
"
#
include
"
HelpersSkia
.
h
"
#
include
"
skia
/
include
/
core
/
SkSurface
.
h
"
#
include
"
skia
/
include
/
core
/
SkTypeface
.
h
"
#
include
"
skia
/
include
/
effects
/
SkGradientShader
.
h
"
#
include
"
skia
/
include
/
core
/
SkColorFilter
.
h
"
#
include
"
skia
/
include
/
effects
/
SkBlurImageFilter
.
h
"
#
include
"
skia
/
include
/
effects
/
SkLayerRasterizer
.
h
"
#
include
"
Blur
.
h
"
#
include
"
Logging
.
h
"
#
include
"
Tools
.
h
"
#
include
"
DataSurfaceHelpers
.
h
"
#
include
<
algorithm
>
#
ifdef
USE_SKIA_GPU
#
include
"
GLDefs
.
h
"
#
include
"
skia
/
include
/
gpu
/
SkGr
.
h
"
#
include
"
skia
/
include
/
gpu
/
GrContext
.
h
"
#
include
"
skia
/
include
/
gpu
/
gl
/
GrGLInterface
.
h
"
#
endif
namespace
mozilla
{
namespace
gfx
{
class
GradientStopsSkia
:
public
GradientStops
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
GradientStopsSkia
)
GradientStopsSkia
(
const
std
:
:
vector
<
GradientStop
>
&
aStops
uint32_t
aNumStops
ExtendMode
aExtendMode
)
:
mCount
(
aNumStops
)
mExtendMode
(
aExtendMode
)
{
if
(
mCount
=
=
0
)
{
return
;
}
uint32_t
shift
=
0
;
if
(
aStops
[
0
]
.
offset
!
=
0
)
{
mCount
+
+
;
shift
=
1
;
}
if
(
aStops
[
aNumStops
-
1
]
.
offset
!
=
1
)
{
mCount
+
+
;
}
mColors
.
resize
(
mCount
)
;
mPositions
.
resize
(
mCount
)
;
if
(
aStops
[
0
]
.
offset
!
=
0
)
{
mColors
[
0
]
=
ColorToSkColor
(
aStops
[
0
]
.
color
1
.
0
)
;
mPositions
[
0
]
=
0
;
}
for
(
uint32_t
i
=
0
;
i
<
aNumStops
;
i
+
+
)
{
mColors
[
i
+
shift
]
=
ColorToSkColor
(
aStops
[
i
]
.
color
1
.
0
)
;
mPositions
[
i
+
shift
]
=
SkFloatToScalar
(
aStops
[
i
]
.
offset
)
;
}
if
(
aStops
[
aNumStops
-
1
]
.
offset
!
=
1
)
{
mColors
[
mCount
-
1
]
=
ColorToSkColor
(
aStops
[
aNumStops
-
1
]
.
color
1
.
0
)
;
mPositions
[
mCount
-
1
]
=
SK_Scalar1
;
}
}
BackendType
GetBackendType
(
)
const
{
return
BackendType
:
:
SKIA
;
}
std
:
:
vector
<
SkColor
>
mColors
;
std
:
:
vector
<
SkScalar
>
mPositions
;
int
mCount
;
ExtendMode
mExtendMode
;
}
;
static
void
ReleaseTemporarySurface
(
void
*
aPixels
void
*
aContext
)
{
DataSourceSurface
*
surf
=
static_cast
<
DataSourceSurface
*
>
(
aContext
)
;
if
(
surf
)
{
surf
-
>
Release
(
)
;
}
}
static
SkBitmap
GetBitmapForSurface
(
SourceSurface
*
aSurface
)
{
SkBitmap
bitmap
;
if
(
!
aSurface
)
{
gfxDebug
(
)
<
<
"
Creating
empty
Skia
bitmap
from
null
SourceSurface
"
;
return
bitmap
;
}
if
(
aSurface
-
>
GetType
(
)
=
=
SurfaceType
:
:
SKIA
)
{
bitmap
=
static_cast
<
SourceSurfaceSkia
*
>
(
aSurface
)
-
>
GetBitmap
(
)
;
return
bitmap
;
}
DataSourceSurface
*
surf
=
aSurface
-
>
GetDataSurface
(
)
.
take
(
)
;
if
(
!
surf
)
{
gfxDevCrash
(
LogReason
:
:
SourceSurfaceIncompatible
)
<
<
"
Non
-
Skia
SourceSurfaces
need
to
be
DataSourceSurfaces
"
;
return
bitmap
;
}
if
(
!
bitmap
.
installPixels
(
MakeSkiaImageInfo
(
surf
-
>
GetSize
(
)
surf
-
>
GetFormat
(
)
)
surf
-
>
GetData
(
)
surf
-
>
Stride
(
)
nullptr
ReleaseTemporarySurface
surf
)
)
{
gfxDebug
(
)
<
<
"
Failed
installing
pixels
on
Skia
bitmap
for
temporary
surface
"
;
}
return
bitmap
;
}
DrawTargetSkia
:
:
DrawTargetSkia
(
)
:
mSnapshot
(
nullptr
)
{
}
DrawTargetSkia
:
:
~
DrawTargetSkia
(
)
{
}
already_AddRefed
<
SourceSurface
>
DrawTargetSkia
:
:
Snapshot
(
)
{
RefPtr
<
SourceSurfaceSkia
>
snapshot
=
mSnapshot
;
if
(
!
snapshot
)
{
snapshot
=
new
SourceSurfaceSkia
(
)
;
mSnapshot
=
snapshot
;
if
(
!
snapshot
-
>
InitFromCanvas
(
mCanvas
.
get
(
)
mFormat
this
)
)
return
nullptr
;
}
return
snapshot
.
forget
(
)
;
}
bool
DrawTargetSkia
:
:
LockBits
(
uint8_t
*
*
aData
IntSize
*
aSize
int32_t
*
aStride
SurfaceFormat
*
aFormat
IntPoint
*
aOrigin
)
{
SkIPoint
origin
=
mCanvas
-
>
getTopDevice
(
)
-
>
getOrigin
(
)
;
if
(
!
aOrigin
&
&
!
origin
.
isZero
(
)
)
{
return
false
;
}
if
(
!
mCanvas
-
>
peekPixels
(
nullptr
)
)
{
return
false
;
}
SkImageInfo
info
;
size_t
rowBytes
;
void
*
pixels
=
mCanvas
-
>
accessTopLayerPixels
(
&
info
&
rowBytes
)
;
if
(
!
pixels
)
{
return
false
;
}
MarkChanged
(
)
;
*
aData
=
reinterpret_cast
<
uint8_t
*
>
(
pixels
)
;
*
aSize
=
IntSize
(
info
.
width
(
)
info
.
height
(
)
)
;
*
aStride
=
int32_t
(
rowBytes
)
;
*
aFormat
=
SkiaColorTypeToGfxFormat
(
info
.
colorType
(
)
)
;
if
(
aOrigin
)
{
*
aOrigin
=
IntPoint
(
origin
.
x
(
)
origin
.
y
(
)
)
;
}
return
true
;
}
void
DrawTargetSkia
:
:
ReleaseBits
(
uint8_t
*
aData
)
{
}
static
void
SetPaintPattern
(
SkPaint
&
aPaint
const
Pattern
&
aPattern
Float
aAlpha
=
1
.
0
)
{
switch
(
aPattern
.
GetType
(
)
)
{
case
PatternType
:
:
COLOR
:
{
Color
color
=
static_cast
<
const
ColorPattern
&
>
(
aPattern
)
.
mColor
;
aPaint
.
setColor
(
ColorToSkColor
(
color
aAlpha
)
)
;
break
;
}
case
PatternType
:
:
LINEAR_GRADIENT
:
{
const
LinearGradientPattern
&
pat
=
static_cast
<
const
LinearGradientPattern
&
>
(
aPattern
)
;
GradientStopsSkia
*
stops
=
static_cast
<
GradientStopsSkia
*
>
(
pat
.
mStops
.
get
(
)
)
;
SkShader
:
:
TileMode
mode
=
ExtendModeToTileMode
(
stops
-
>
mExtendMode
Axis
:
:
BOTH
)
;
if
(
stops
-
>
mCount
>
=
2
)
{
SkPoint
points
[
2
]
;
points
[
0
]
=
SkPoint
:
:
Make
(
SkFloatToScalar
(
pat
.
mBegin
.
x
)
SkFloatToScalar
(
pat
.
mBegin
.
y
)
)
;
points
[
1
]
=
SkPoint
:
:
Make
(
SkFloatToScalar
(
pat
.
mEnd
.
x
)
SkFloatToScalar
(
pat
.
mEnd
.
y
)
)
;
SkMatrix
mat
;
GfxMatrixToSkiaMatrix
(
pat
.
mMatrix
mat
)
;
sk_sp
<
SkShader
>
shader
=
SkGradientShader
:
:
MakeLinear
(
points
&
stops
-
>
mColors
.
front
(
)
&
stops
-
>
mPositions
.
front
(
)
stops
-
>
mCount
mode
0
&
mat
)
;
aPaint
.
setShader
(
shader
)
;
}
else
{
aPaint
.
setColor
(
SK_ColorTRANSPARENT
)
;
}
break
;
}
case
PatternType
:
:
RADIAL_GRADIENT
:
{
const
RadialGradientPattern
&
pat
=
static_cast
<
const
RadialGradientPattern
&
>
(
aPattern
)
;
GradientStopsSkia
*
stops
=
static_cast
<
GradientStopsSkia
*
>
(
pat
.
mStops
.
get
(
)
)
;
SkShader
:
:
TileMode
mode
=
ExtendModeToTileMode
(
stops
-
>
mExtendMode
Axis
:
:
BOTH
)
;
if
(
stops
-
>
mCount
>
=
2
)
{
SkPoint
points
[
2
]
;
points
[
0
]
=
SkPoint
:
:
Make
(
SkFloatToScalar
(
pat
.
mCenter1
.
x
)
SkFloatToScalar
(
pat
.
mCenter1
.
y
)
)
;
points
[
1
]
=
SkPoint
:
:
Make
(
SkFloatToScalar
(
pat
.
mCenter2
.
x
)
SkFloatToScalar
(
pat
.
mCenter2
.
y
)
)
;
SkMatrix
mat
;
GfxMatrixToSkiaMatrix
(
pat
.
mMatrix
mat
)
;
sk_sp
<
SkShader
>
shader
=
SkGradientShader
:
:
MakeTwoPointConical
(
points
[
0
]
SkFloatToScalar
(
pat
.
mRadius1
)
points
[
1
]
SkFloatToScalar
(
pat
.
mRadius2
)
&
stops
-
>
mColors
.
front
(
)
&
stops
-
>
mPositions
.
front
(
)
stops
-
>
mCount
mode
0
&
mat
)
;
aPaint
.
setShader
(
shader
)
;
}
else
{
aPaint
.
setColor
(
SK_ColorTRANSPARENT
)
;
}
break
;
}
case
PatternType
:
:
SURFACE
:
{
const
SurfacePattern
&
pat
=
static_cast
<
const
SurfacePattern
&
>
(
aPattern
)
;
SkBitmap
bitmap
=
GetBitmapForSurface
(
pat
.
mSurface
)
;
SkMatrix
mat
;
GfxMatrixToSkiaMatrix
(
pat
.
mMatrix
mat
)
;
if
(
!
pat
.
mSamplingRect
.
IsEmpty
(
)
)
{
SkIRect
rect
=
IntRectToSkIRect
(
pat
.
mSamplingRect
)
;
bitmap
.
extractSubset
(
&
bitmap
rect
)
;
mat
.
preTranslate
(
rect
.
x
(
)
rect
.
y
(
)
)
;
}
SkShader
:
:
TileMode
xTileMode
=
ExtendModeToTileMode
(
pat
.
mExtendMode
Axis
:
:
X_AXIS
)
;
SkShader
:
:
TileMode
yTileMode
=
ExtendModeToTileMode
(
pat
.
mExtendMode
Axis
:
:
Y_AXIS
)
;
sk_sp
<
SkShader
>
shader
=
SkShader
:
:
MakeBitmapShader
(
bitmap
xTileMode
yTileMode
&
mat
)
;
aPaint
.
setShader
(
shader
)
;
if
(
pat
.
mFilter
=
=
Filter
:
:
POINT
)
{
aPaint
.
setFilterQuality
(
kNone_SkFilterQuality
)
;
}
break
;
}
}
}
static
inline
Rect
GetClipBounds
(
SkCanvas
*
aCanvas
)
{
SkRect
clipBounds
;
if
(
!
aCanvas
-
>
getClipBounds
(
&
clipBounds
)
)
{
return
Rect
(
)
;
}
return
SkRectToRect
(
clipBounds
)
;
}
struct
AutoPaintSetup
{
AutoPaintSetup
(
SkCanvas
*
aCanvas
const
DrawOptions
&
aOptions
const
Pattern
&
aPattern
const
Rect
*
aMaskBounds
=
nullptr
)
:
mNeedsRestore
(
false
)
mAlpha
(
1
.
0
)
{
Init
(
aCanvas
aOptions
aMaskBounds
)
;
SetPaintPattern
(
mPaint
aPattern
mAlpha
)
;
}
AutoPaintSetup
(
SkCanvas
*
aCanvas
const
DrawOptions
&
aOptions
const
Rect
*
aMaskBounds
=
nullptr
)
:
mNeedsRestore
(
false
)
mAlpha
(
1
.
0
)
{
Init
(
aCanvas
aOptions
aMaskBounds
)
;
}
~
AutoPaintSetup
(
)
{
if
(
mNeedsRestore
)
{
mCanvas
-
>
restore
(
)
;
}
}
void
Init
(
SkCanvas
*
aCanvas
const
DrawOptions
&
aOptions
const
Rect
*
aMaskBounds
)
{
mPaint
.
setXfermodeMode
(
GfxOpToSkiaOp
(
aOptions
.
mCompositionOp
)
)
;
mCanvas
=
aCanvas
;
if
(
aOptions
.
mAntialiasMode
!
=
AntialiasMode
:
:
NONE
)
{
mPaint
.
setAntiAlias
(
true
)
;
}
else
{
mPaint
.
setAntiAlias
(
false
)
;
}
bool
needsGroup
=
!
IsOperatorBoundByMask
(
aOptions
.
mCompositionOp
)
&
&
(
!
aMaskBounds
|
|
!
aMaskBounds
-
>
Contains
(
GetClipBounds
(
aCanvas
)
)
)
;
if
(
needsGroup
)
{
mPaint
.
setXfermodeMode
(
SkXfermode
:
:
kSrcOver_Mode
)
;
SkPaint
temp
;
temp
.
setXfermodeMode
(
GfxOpToSkiaOp
(
aOptions
.
mCompositionOp
)
)
;
temp
.
setAlpha
(
ColorFloatToByte
(
aOptions
.
mAlpha
)
)
;
mCanvas
-
>
saveLayer
(
nullptr
&
temp
)
;
mNeedsRestore
=
true
;
}
else
{
mPaint
.
setAlpha
(
ColorFloatToByte
(
aOptions
.
mAlpha
)
)
;
mAlpha
=
aOptions
.
mAlpha
;
}
mPaint
.
setFilterQuality
(
kLow_SkFilterQuality
)
;
}
SkPaint
mPaint
;
bool
mNeedsRestore
;
SkCanvas
*
mCanvas
;
Float
mAlpha
;
}
;
void
DrawTargetSkia
:
:
Flush
(
)
{
mCanvas
-
>
flush
(
)
;
}
void
DrawTargetSkia
:
:
DrawSurface
(
SourceSurface
*
aSurface
const
Rect
&
aDest
const
Rect
&
aSource
const
DrawSurfaceOptions
&
aSurfOptions
const
DrawOptions
&
aOptions
)
{
RefPtr
<
SourceSurface
>
dataSurface
;
if
(
!
(
aSurface
-
>
GetType
(
)
=
=
SurfaceType
:
:
SKIA
|
|
aSurface
-
>
GetType
(
)
=
=
SurfaceType
:
:
DATA
)
)
{
dataSurface
=
aSurface
-
>
GetDataSurface
(
)
;
if
(
!
dataSurface
)
{
gfxDebug
(
)
<
<
*
this
<
<
"
:
DrawSurface
(
)
can
'
t
draw
surface
"
;
return
;
}
aSurface
=
dataSurface
.
get
(
)
;
}
if
(
aSource
.
IsEmpty
(
)
)
{
return
;
}
MarkChanged
(
)
;
SkRect
destRect
=
RectToSkRect
(
aDest
)
;
SkRect
sourceRect
=
RectToSkRect
(
aSource
)
;
SkBitmap
bitmap
=
GetBitmapForSurface
(
aSurface
)
;
AutoPaintSetup
paint
(
mCanvas
.
get
(
)
aOptions
&
aDest
)
;
if
(
aSurfOptions
.
mFilter
=
=
Filter
:
:
POINT
)
{
paint
.
mPaint
.
setFilterQuality
(
kNone_SkFilterQuality
)
;
}
mCanvas
-
>
drawBitmapRect
(
bitmap
sourceRect
destRect
&
paint
.
mPaint
)
;
}
DrawTargetType
DrawTargetSkia
:
:
GetType
(
)
const
{
#
ifdef
USE_SKIA_GPU
if
(
mGrContext
)
{
return
DrawTargetType
:
:
HARDWARE_RASTER
;
}
#
endif
return
DrawTargetType
:
:
SOFTWARE_RASTER
;
}
void
DrawTargetSkia
:
:
DrawFilter
(
FilterNode
*
aNode
const
Rect
&
aSourceRect
const
Point
&
aDestPoint
const
DrawOptions
&
aOptions
)
{
FilterNodeSoftware
*
filter
=
static_cast
<
FilterNodeSoftware
*
>
(
aNode
)
;
filter
-
>
Draw
(
this
aSourceRect
aDestPoint
aOptions
)
;
}
void
DrawTargetSkia
:
:
DrawSurfaceWithShadow
(
SourceSurface
*
aSurface
const
Point
&
aDest
const
Color
&
aColor
const
Point
&
aOffset
Float
aSigma
CompositionOp
aOperator
)
{
if
(
!
(
aSurface
-
>
GetType
(
)
=
=
SurfaceType
:
:
SKIA
|
|
aSurface
-
>
GetType
(
)
=
=
SurfaceType
:
:
DATA
)
|
|
aSurface
-
>
GetSize
(
)
.
IsEmpty
(
)
)
{
return
;
}
MarkChanged
(
)
;
mCanvas
-
>
save
(
)
;
mCanvas
-
>
resetMatrix
(
)
;
SkBitmap
bitmap
=
GetBitmapForSurface
(
aSurface
)
;
SkPaint
paint
;
paint
.
setXfermodeMode
(
GfxOpToSkiaOp
(
aOperator
)
)
;
SkPaint
shadowPaint
;
shadowPaint
.
setXfermodeMode
(
GfxOpToSkiaOp
(
aOperator
)
)
;
IntPoint
shadowDest
=
RoundedToInt
(
aDest
+
aOffset
)
;
SkBitmap
blurMask
;
if
(
!
UsingSkiaGPU
(
)
&
&
bitmap
.
extractAlpha
(
&
blurMask
)
)
{
AlphaBoxBlur
blur
(
Rect
(
0
0
blurMask
.
width
(
)
blurMask
.
height
(
)
)
int32_t
(
blurMask
.
rowBytes
(
)
)
aSigma
aSigma
)
;
blurMask
.
lockPixels
(
)
;
blur
.
Blur
(
reinterpret_cast
<
uint8_t
*
>
(
blurMask
.
getPixels
(
)
)
)
;
blurMask
.
unlockPixels
(
)
;
blurMask
.
notifyPixelsChanged
(
)
;
shadowPaint
.
setColor
(
ColorToSkColor
(
aColor
1
.
0f
)
)
;
mCanvas
-
>
drawBitmap
(
blurMask
shadowDest
.
x
shadowDest
.
y
&
shadowPaint
)
;
}
else
{
sk_sp
<
SkImageFilter
>
blurFilter
(
SkBlurImageFilter
:
:
Make
(
aSigma
aSigma
nullptr
)
)
;
sk_sp
<
SkColorFilter
>
colorFilter
(
SkColorFilter
:
:
MakeModeFilter
(
ColorToSkColor
(
aColor
1
.
0f
)
SkXfermode
:
:
kSrcIn_Mode
)
)
;
shadowPaint
.
setImageFilter
(
blurFilter
)
;
shadowPaint
.
setColorFilter
(
colorFilter
)
;
mCanvas
-
>
drawBitmap
(
bitmap
shadowDest
.
x
shadowDest
.
y
&
shadowPaint
)
;
}
IntPoint
dest
=
RoundedToInt
(
aDest
)
;
mCanvas
-
>
drawBitmap
(
bitmap
dest
.
x
dest
.
y
&
paint
)
;
mCanvas
-
>
restore
(
)
;
}
void
DrawTargetSkia
:
:
FillRect
(
const
Rect
&
aRect
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
)
{
MarkChanged
(
)
;
SkRect
rect
=
RectToSkRect
(
aRect
)
;
AutoPaintSetup
paint
(
mCanvas
.
get
(
)
aOptions
aPattern
&
aRect
)
;
mCanvas
-
>
drawRect
(
rect
paint
.
mPaint
)
;
}
void
DrawTargetSkia
:
:
Stroke
(
const
Path
*
aPath
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
const
DrawOptions
&
aOptions
)
{
MarkChanged
(
)
;
MOZ_ASSERT
(
aPath
"
Null
path
"
)
;
if
(
aPath
-
>
GetBackendType
(
)
!
=
BackendType
:
:
SKIA
)
{
return
;
}
const
PathSkia
*
skiaPath
=
static_cast
<
const
PathSkia
*
>
(
aPath
)
;
AutoPaintSetup
paint
(
mCanvas
.
get
(
)
aOptions
aPattern
)
;
if
(
!
StrokeOptionsToPaint
(
paint
.
mPaint
aStrokeOptions
)
)
{
return
;
}
if
(
!
skiaPath
-
>
GetPath
(
)
.
isFinite
(
)
)
{
return
;
}
mCanvas
-
>
drawPath
(
skiaPath
-
>
GetPath
(
)
paint
.
mPaint
)
;
}
void
DrawTargetSkia
:
:
StrokeRect
(
const
Rect
&
aRect
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
const
DrawOptions
&
aOptions
)
{
MarkChanged
(
)
;
AutoPaintSetup
paint
(
mCanvas
.
get
(
)
aOptions
aPattern
)
;
if
(
!
StrokeOptionsToPaint
(
paint
.
mPaint
aStrokeOptions
)
)
{
return
;
}
mCanvas
-
>
drawRect
(
RectToSkRect
(
aRect
)
paint
.
mPaint
)
;
}
void
DrawTargetSkia
:
:
StrokeLine
(
const
Point
&
aStart
const
Point
&
aEnd
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
const
DrawOptions
&
aOptions
)
{
MarkChanged
(
)
;
AutoPaintSetup
paint
(
mCanvas
.
get
(
)
aOptions
aPattern
)
;
if
(
!
StrokeOptionsToPaint
(
paint
.
mPaint
aStrokeOptions
)
)
{
return
;
}
mCanvas
-
>
drawLine
(
SkFloatToScalar
(
aStart
.
x
)
SkFloatToScalar
(
aStart
.
y
)
SkFloatToScalar
(
aEnd
.
x
)
SkFloatToScalar
(
aEnd
.
y
)
paint
.
mPaint
)
;
}
void
DrawTargetSkia
:
:
Fill
(
const
Path
*
aPath
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
)
{
MarkChanged
(
)
;
if
(
aPath
-
>
GetBackendType
(
)
!
=
BackendType
:
:
SKIA
)
{
return
;
}
const
PathSkia
*
skiaPath
=
static_cast
<
const
PathSkia
*
>
(
aPath
)
;
AutoPaintSetup
paint
(
mCanvas
.
get
(
)
aOptions
aPattern
)
;
if
(
!
skiaPath
-
>
GetPath
(
)
.
isFinite
(
)
)
{
return
;
}
mCanvas
-
>
drawPath
(
skiaPath
-
>
GetPath
(
)
paint
.
mPaint
)
;
}
bool
DrawTargetSkia
:
:
ShouldLCDRenderText
(
FontType
aFontType
AntialiasMode
aAntialiasMode
)
{
if
(
!
IsOpaque
(
mFormat
)
&
&
!
mPermitSubpixelAA
)
{
return
false
;
}
if
(
aAntialiasMode
=
=
AntialiasMode
:
:
DEFAULT
)
{
switch
(
aFontType
)
{
case
FontType
:
:
MAC
:
case
FontType
:
:
GDI
:
case
FontType
:
:
DWRITE
:
return
true
;
default
:
return
false
;
}
}
return
(
aAntialiasMode
=
=
AntialiasMode
:
:
SUBPIXEL
)
;
}
void
DrawTargetSkia
:
:
FillGlyphs
(
ScaledFont
*
aFont
const
GlyphBuffer
&
aBuffer
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
const
GlyphRenderingOptions
*
aRenderingOptions
)
{
if
(
aFont
-
>
GetType
(
)
!
=
FontType
:
:
MAC
&
&
aFont
-
>
GetType
(
)
!
=
FontType
:
:
SKIA
&
&
aFont
-
>
GetType
(
)
!
=
FontType
:
:
GDI
&
&
aFont
-
>
GetType
(
)
!
=
FontType
:
:
DWRITE
)
{
return
;
}
MarkChanged
(
)
;
ScaledFontBase
*
skiaFont
=
static_cast
<
ScaledFontBase
*
>
(
aFont
)
;
AutoPaintSetup
paint
(
mCanvas
.
get
(
)
aOptions
aPattern
)
;
paint
.
mPaint
.
setTypeface
(
skiaFont
-
>
GetSkTypeface
(
)
)
;
paint
.
mPaint
.
setTextSize
(
SkFloatToScalar
(
skiaFont
-
>
mSize
)
)
;
paint
.
mPaint
.
setTextEncoding
(
SkPaint
:
:
kGlyphID_TextEncoding
)
;
bool
shouldLCDRenderText
=
ShouldLCDRenderText
(
aFont
-
>
GetType
(
)
aOptions
.
mAntialiasMode
)
;
paint
.
mPaint
.
setLCDRenderText
(
shouldLCDRenderText
)
;
if
(
aRenderingOptions
&
&
aRenderingOptions
-
>
GetType
(
)
=
=
FontType
:
:
CAIRO
)
{
const
GlyphRenderingOptionsCairo
*
cairoOptions
=
static_cast
<
const
GlyphRenderingOptionsCairo
*
>
(
aRenderingOptions
)
;
paint
.
mPaint
.
setHinting
(
GfxHintingToSkiaHinting
(
cairoOptions
-
>
GetHinting
(
)
)
)
;
if
(
cairoOptions
-
>
GetAutoHinting
(
)
)
{
paint
.
mPaint
.
setAutohinted
(
true
)
;
}
if
(
cairoOptions
-
>
GetAntialiasMode
(
)
=
=
AntialiasMode
:
:
NONE
)
{
paint
.
mPaint
.
setAntiAlias
(
false
)
;
}
}
else
{
paint
.
mPaint
.
setSubpixelText
(
true
)
;
if
(
aFont
-
>
GetType
(
)
=
=
FontType
:
:
MAC
&
&
aOptions
.
mAntialiasMode
=
=
AntialiasMode
:
:
GRAY
)
{
paint
.
mPaint
.
setHinting
(
SkPaint
:
:
kNo_Hinting
)
;
}
else
{
paint
.
mPaint
.
setHinting
(
SkPaint
:
:
kNormal_Hinting
)
;
}
}
std
:
:
vector
<
uint16_t
>
indices
;
std
:
:
vector
<
SkPoint
>
offsets
;
indices
.
resize
(
aBuffer
.
mNumGlyphs
)
;
offsets
.
resize
(
aBuffer
.
mNumGlyphs
)
;
for
(
unsigned
int
i
=
0
;
i
<
aBuffer
.
mNumGlyphs
;
i
+
+
)
{
indices
[
i
]
=
aBuffer
.
mGlyphs
[
i
]
.
mIndex
;
offsets
[
i
]
.
fX
=
SkFloatToScalar
(
aBuffer
.
mGlyphs
[
i
]
.
mPosition
.
x
)
;
offsets
[
i
]
.
fY
=
SkFloatToScalar
(
aBuffer
.
mGlyphs
[
i
]
.
mPosition
.
y
)
;
}
mCanvas
-
>
drawPosText
(
&
indices
.
front
(
)
aBuffer
.
mNumGlyphs
*
2
&
offsets
.
front
(
)
paint
.
mPaint
)
;
}
void
DrawTargetSkia
:
:
Mask
(
const
Pattern
&
aSource
const
Pattern
&
aMask
const
DrawOptions
&
aOptions
)
{
MarkChanged
(
)
;
AutoPaintSetup
paint
(
mCanvas
.
get
(
)
aOptions
aSource
)
;
SkPaint
maskPaint
;
SetPaintPattern
(
maskPaint
aMask
)
;
SkLayerRasterizer
:
:
Builder
builder
;
builder
.
addLayer
(
maskPaint
)
;
sk_sp
<
SkLayerRasterizer
>
raster
(
builder
.
detach
(
)
)
;
paint
.
mPaint
.
setRasterizer
(
raster
)
;
mCanvas
-
>
drawPaint
(
paint
.
mPaint
)
;
}
void
DrawTargetSkia
:
:
MaskSurface
(
const
Pattern
&
aSource
SourceSurface
*
aMask
Point
aOffset
const
DrawOptions
&
aOptions
)
{
MarkChanged
(
)
;
AutoPaintSetup
paint
(
mCanvas
.
get
(
)
aOptions
aSource
)
;
SkBitmap
bitmap
=
GetBitmapForSurface
(
aMask
)
;
if
(
bitmap
.
colorType
(
)
!
=
kAlpha_8_SkColorType
&
&
!
bitmap
.
extractAlpha
(
&
bitmap
)
)
{
gfxDebug
(
)
<
<
*
this
<
<
"
:
MaskSurface
(
)
failed
to
extract
alpha
for
mask
"
;
return
;
}
if
(
aOffset
!
=
Point
(
0
0
)
&
&
paint
.
mPaint
.
getShader
(
)
)
{
SkMatrix
transform
;
transform
.
setTranslate
(
PointToSkPoint
(
-
aOffset
)
)
;
sk_sp
<
SkShader
>
matrixShader
=
paint
.
mPaint
.
getShader
(
)
-
>
makeWithLocalMatrix
(
transform
)
;
paint
.
mPaint
.
setShader
(
matrixShader
)
;
}
mCanvas
-
>
drawBitmap
(
bitmap
aOffset
.
x
aOffset
.
y
&
paint
.
mPaint
)
;
}
bool
DrawTarget
:
:
Draw3DTransformedSurface
(
SourceSurface
*
aSurface
const
Matrix4x4
&
aMatrix
)
{
Matrix4x4
fullMat
=
aMatrix
*
Matrix4x4
:
:
From2D
(
mTransform
)
;
if
(
fullMat
.
IsSingular
(
)
)
{
return
false
;
}
IntRect
xformBounds
=
RoundedOut
(
fullMat
.
TransformAndClipBounds
(
Rect
(
Point
(
0
0
)
Size
(
aSurface
-
>
GetSize
(
)
)
)
Rect
(
Point
(
0
0
)
Size
(
GetSize
(
)
)
)
)
)
;
if
(
xformBounds
.
IsEmpty
(
)
)
{
return
true
;
}
fullMat
.
PostTranslate
(
-
xformBounds
.
x
-
xformBounds
.
y
0
)
;
SkBitmap
srcBitmap
=
GetBitmapForSurface
(
aSurface
)
;
RefPtr
<
DataSourceSurface
>
dstSurf
=
Factory
:
:
CreateDataSourceSurface
(
xformBounds
.
Size
(
)
srcBitmap
.
alphaType
(
)
=
=
kPremul_SkAlphaType
?
aSurface
-
>
GetFormat
(
)
:
SurfaceFormat
:
:
A8R8G8B8_UINT32
true
)
;
if
(
!
dstSurf
)
{
return
false
;
}
SkAutoTUnref
<
SkCanvas
>
dstCanvas
(
SkCanvas
:
:
NewRasterDirect
(
SkImageInfo
:
:
Make
(
xformBounds
.
width
xformBounds
.
height
srcBitmap
.
alphaType
(
)
=
=
kPremul_SkAlphaType
?
srcBitmap
.
colorType
(
)
:
kBGRA_8888_SkColorType
kPremul_SkAlphaType
)
dstSurf
-
>
GetData
(
)
dstSurf
-
>
Stride
(
)
)
)
;
if
(
!
dstCanvas
)
{
return
false
;
}
SkPaint
paint
;
paint
.
setAntiAlias
(
true
)
;
paint
.
setFilterQuality
(
kLow_SkFilterQuality
)
;
paint
.
setXfermodeMode
(
SkXfermode
:
:
kSrc_Mode
)
;
SkMatrix
xform
;
GfxMatrixToSkiaMatrix
(
fullMat
xform
)
;
dstCanvas
-
>
setMatrix
(
xform
)
;
dstCanvas
-
>
drawBitmap
(
srcBitmap
0
0
&
paint
)
;
dstCanvas
-
>
flush
(
)
;
Matrix
origTransform
=
mTransform
;
SetTransform
(
Matrix
(
)
)
;
DrawSurface
(
dstSurf
Rect
(
xformBounds
)
Rect
(
Point
(
0
0
)
Size
(
xformBounds
.
Size
(
)
)
)
)
;
SetTransform
(
origTransform
)
;
return
true
;
}
bool
DrawTargetSkia
:
:
Draw3DTransformedSurface
(
SourceSurface
*
aSurface
const
Matrix4x4
&
aMatrix
)
{
if
(
aMatrix
.
IsSingular
(
)
)
{
return
false
;
}
MarkChanged
(
)
;
SkBitmap
bitmap
=
GetBitmapForSurface
(
aSurface
)
;
mCanvas
-
>
save
(
)
;
SkPaint
paint
;
paint
.
setAntiAlias
(
true
)
;
paint
.
setFilterQuality
(
kLow_SkFilterQuality
)
;
SkMatrix
xform
;
GfxMatrixToSkiaMatrix
(
aMatrix
xform
)
;
mCanvas
-
>
concat
(
xform
)
;
mCanvas
-
>
drawBitmap
(
bitmap
0
0
&
paint
)
;
mCanvas
-
>
restore
(
)
;
return
true
;
}
already_AddRefed
<
SourceSurface
>
DrawTargetSkia
:
:
CreateSourceSurfaceFromData
(
unsigned
char
*
aData
const
IntSize
&
aSize
int32_t
aStride
SurfaceFormat
aFormat
)
const
{
RefPtr
<
SourceSurfaceSkia
>
newSurf
=
new
SourceSurfaceSkia
(
)
;
if
(
!
newSurf
-
>
InitFromData
(
aData
aSize
aStride
aFormat
)
)
{
gfxDebug
(
)
<
<
*
this
<
<
"
:
Failure
to
create
source
surface
from
data
.
Size
:
"
<
<
aSize
;
return
nullptr
;
}
return
newSurf
.
forget
(
)
;
}
already_AddRefed
<
DrawTarget
>
DrawTargetSkia
:
:
CreateSimilarDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
const
{
RefPtr
<
DrawTargetSkia
>
target
=
new
DrawTargetSkia
(
)
;
#
ifdef
USE_SKIA_GPU
if
(
UsingSkiaGPU
(
)
)
{
if
(
target
-
>
InitWithGrContext
(
mGrContext
.
get
(
)
aSize
aFormat
true
)
)
{
return
target
.
forget
(
)
;
}
}
#
endif
if
(
!
target
-
>
Init
(
aSize
aFormat
)
)
{
return
nullptr
;
}
return
target
.
forget
(
)
;
}
bool
DrawTargetSkia
:
:
UsingSkiaGPU
(
)
const
{
#
ifdef
USE_SKIA_GPU
return
!
!
mGrContext
;
#
else
return
false
;
#
endif
}
already_AddRefed
<
SourceSurface
>
DrawTargetSkia
:
:
OptimizeSourceSurface
(
SourceSurface
*
aSurface
)
const
{
#
ifdef
USE_SKIA_GPU
if
(
UsingSkiaGPU
(
)
)
{
if
(
aSurface
-
>
GetType
(
)
=
=
SurfaceType
:
:
SKIA
&
&
static_cast
<
SourceSurfaceSkia
*
>
(
aSurface
)
-
>
GetBitmap
(
)
.
getTexture
(
)
)
{
RefPtr
<
SourceSurface
>
surface
(
aSurface
)
;
return
surface
.
forget
(
)
;
}
SkBitmap
bitmap
=
GetBitmapForSurface
(
aSurface
)
;
SkAutoTUnref
<
GrTexture
>
texture
(
GrRefCachedBitmapTexture
(
mGrContext
.
get
(
)
bitmap
GrTextureParams
:
:
ClampBilerp
(
)
)
)
;
if
(
texture
)
{
RefPtr
<
SourceSurfaceSkia
>
surface
=
new
SourceSurfaceSkia
(
)
;
if
(
surface
-
>
InitFromGrTexture
(
texture
aSurface
-
>
GetSize
(
)
aSurface
-
>
GetFormat
(
)
)
)
{
return
surface
.
forget
(
)
;
}
}
if
(
aSurface
-
>
GetType
(
)
=
=
SurfaceType
:
:
SKIA
)
{
RefPtr
<
SourceSurface
>
surface
(
aSurface
)
;
return
surface
.
forget
(
)
;
}
RefPtr
<
SourceSurfaceSkia
>
surface
=
new
SourceSurfaceSkia
(
)
;
surface
-
>
InitFromBitmap
(
bitmap
)
;
return
surface
.
forget
(
)
;
}
#
endif
if
(
aSurface
-
>
GetType
(
)
=
=
SurfaceType
:
:
SKIA
)
{
RefPtr
<
SourceSurface
>
surface
(
aSurface
)
;
return
surface
.
forget
(
)
;
}
return
aSurface
-
>
GetDataSurface
(
)
;
}
already_AddRefed
<
SourceSurface
>
DrawTargetSkia
:
:
CreateSourceSurfaceFromNativeSurface
(
const
NativeSurface
&
aSurface
)
const
{
#
if
USE_SKIA_GPU
if
(
aSurface
.
mType
=
=
NativeSurfaceType
:
:
OPENGL_TEXTURE
&
&
UsingSkiaGPU
(
)
)
{
GrBackendTextureDesc
texDesc
;
texDesc
.
fWidth
=
aSurface
.
mSize
.
width
;
texDesc
.
fHeight
=
aSurface
.
mSize
.
height
;
texDesc
.
fOrigin
=
kTopLeft_GrSurfaceOrigin
;
texDesc
.
fConfig
=
GfxFormatToGrConfig
(
aSurface
.
mFormat
)
;
GrGLTextureInfo
texInfo
;
texInfo
.
fTarget
=
LOCAL_GL_TEXTURE_2D
;
texInfo
.
fID
=
(
GrGLuint
)
(
uintptr_t
)
aSurface
.
mSurface
;
texDesc
.
fTextureHandle
=
reinterpret_cast
<
GrBackendObject
>
(
&
texInfo
)
;
SkAutoTUnref
<
GrTexture
>
texture
(
mGrContext
-
>
textureProvider
(
)
-
>
wrapBackendTexture
(
texDesc
)
)
;
RefPtr
<
SourceSurfaceSkia
>
newSurf
=
new
SourceSurfaceSkia
(
)
;
if
(
newSurf
-
>
InitFromGrTexture
(
texture
aSurface
.
mSize
aSurface
.
mFormat
)
)
{
return
newSurf
.
forget
(
)
;
}
return
nullptr
;
}
#
endif
return
nullptr
;
}
void
DrawTargetSkia
:
:
CopySurface
(
SourceSurface
*
aSurface
const
IntRect
&
aSourceRect
const
IntPoint
&
aDestination
)
{
if
(
aSurface
-
>
GetType
(
)
!
=
SurfaceType
:
:
SKIA
&
&
aSurface
-
>
GetType
(
)
!
=
SurfaceType
:
:
DATA
)
{
return
;
}
MarkChanged
(
)
;
SkBitmap
bitmap
=
GetBitmapForSurface
(
aSurface
)
;
mCanvas
-
>
save
(
)
;
mCanvas
-
>
resetMatrix
(
)
;
SkRect
dest
=
IntRectToSkRect
(
IntRect
(
aDestination
.
x
aDestination
.
y
aSourceRect
.
width
aSourceRect
.
height
)
)
;
SkIRect
source
=
IntRectToSkIRect
(
aSourceRect
)
;
mCanvas
-
>
clipRect
(
dest
SkRegion
:
:
kReplace_Op
)
;
SkPaint
paint
;
if
(
!
bitmap
.
isOpaque
(
)
)
{
paint
.
setXfermodeMode
(
SkXfermode
:
:
kSrc_Mode
)
;
}
if
(
bitmap
.
colorType
(
)
=
=
kAlpha_8_SkColorType
)
{
mCanvas
-
>
clear
(
SK_ColorTRANSPARENT
)
;
}
mCanvas
-
>
drawBitmapRect
(
bitmap
source
dest
&
paint
)
;
mCanvas
-
>
restore
(
)
;
}
bool
DrawTargetSkia
:
:
Init
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
if
(
size_t
(
std
:
:
max
(
aSize
.
width
aSize
.
height
)
)
>
GetMaxSurfaceSize
(
)
)
{
return
false
;
}
int
stride
=
(
BytesPerPixel
(
aFormat
)
*
aSize
.
width
+
(
4
-
1
)
)
&
-
4
;
SkBitmap
bitmap
;
bitmap
.
setInfo
(
MakeSkiaImageInfo
(
aSize
aFormat
)
stride
)
;
if
(
!
bitmap
.
tryAllocPixels
(
)
)
{
return
false
;
}
bitmap
.
eraseColor
(
SK_ColorTRANSPARENT
)
;
mCanvas
.
adopt
(
new
SkCanvas
(
bitmap
)
)
;
mSize
=
aSize
;
mFormat
=
aFormat
;
return
true
;
}
#
ifdef
USE_SKIA_GPU
bool
DrawTargetSkia
:
:
InitWithGrContext
(
GrContext
*
aGrContext
const
IntSize
&
aSize
SurfaceFormat
aFormat
bool
aCached
)
{
MOZ_ASSERT
(
aGrContext
"
null
GrContext
"
)
;
if
(
size_t
(
std
:
:
max
(
aSize
.
width
aSize
.
height
)
)
>
GetMaxSurfaceSize
(
)
)
{
return
false
;
}
sk_sp
<
SkSurface
>
gpuSurface
=
SkSurface
:
:
MakeRenderTarget
(
aGrContext
SkBudgeted
(
aCached
)
MakeSkiaImageInfo
(
aSize
aFormat
)
)
;
if
(
!
gpuSurface
)
{
return
false
;
}
mGrContext
=
aGrContext
;
mSize
=
aSize
;
mFormat
=
aFormat
;
mCanvas
=
gpuSurface
-
>
getCanvas
(
)
;
return
true
;
}
#
endif
#
ifdef
DEBUG
bool
VerifyRGBXFormat
(
uint8_t
*
aData
const
IntSize
&
aSize
const
int32_t
aStride
SurfaceFormat
aFormat
)
{
int
height
=
aSize
.
height
;
int
width
=
aSize
.
width
;
for
(
int
row
=
0
;
row
<
height
;
+
+
row
)
{
for
(
int
column
=
0
;
column
<
width
;
column
+
=
4
)
{
#
ifdef
IS_BIG_ENDIAN
MOZ_ASSERT
(
aData
[
column
]
=
=
0xFF
)
;
#
else
MOZ_ASSERT
(
aData
[
column
+
3
]
=
=
0xFF
)
;
#
endif
}
aData
+
=
aStride
;
}
return
true
;
}
#
endif
void
DrawTargetSkia
:
:
Init
(
unsigned
char
*
aData
const
IntSize
&
aSize
int32_t
aStride
SurfaceFormat
aFormat
bool
aUninitialized
)
{
MOZ_ASSERT
(
(
aFormat
!
=
SurfaceFormat
:
:
B8G8R8X8
)
|
|
aUninitialized
|
|
VerifyRGBXFormat
(
aData
aSize
aStride
aFormat
)
)
;
SkBitmap
bitmap
;
bitmap
.
setInfo
(
MakeSkiaImageInfo
(
aSize
aFormat
)
aStride
)
;
bitmap
.
setPixels
(
aData
)
;
mCanvas
.
adopt
(
new
SkCanvas
(
bitmap
)
)
;
mSize
=
aSize
;
mFormat
=
aFormat
;
}
void
DrawTargetSkia
:
:
SetTransform
(
const
Matrix
&
aTransform
)
{
SkMatrix
mat
;
GfxMatrixToSkiaMatrix
(
aTransform
mat
)
;
mCanvas
-
>
setMatrix
(
mat
)
;
mTransform
=
aTransform
;
}
void
*
DrawTargetSkia
:
:
GetNativeSurface
(
NativeSurfaceType
aType
)
{
#
ifdef
USE_SKIA_GPU
if
(
aType
=
=
NativeSurfaceType
:
:
OPENGL_TEXTURE
)
{
GrRenderTarget
*
rt
=
mCanvas
-
>
getDevice
(
)
-
>
accessRenderTarget
(
)
;
if
(
rt
)
{
GrTexture
*
tex
=
rt
-
>
asTexture
(
)
;
if
(
tex
)
{
return
(
void
*
)
(
uintptr_t
)
reinterpret_cast
<
GrGLTextureInfo
*
>
(
tex
-
>
getTextureHandle
(
)
)
-
>
fID
;
}
}
}
#
endif
return
nullptr
;
}
already_AddRefed
<
PathBuilder
>
DrawTargetSkia
:
:
CreatePathBuilder
(
FillRule
aFillRule
)
const
{
return
MakeAndAddRef
<
PathBuilderSkia
>
(
aFillRule
)
;
}
void
DrawTargetSkia
:
:
ClearRect
(
const
Rect
&
aRect
)
{
MarkChanged
(
)
;
mCanvas
-
>
save
(
)
;
mCanvas
-
>
clipRect
(
RectToSkRect
(
aRect
)
SkRegion
:
:
kIntersect_Op
true
)
;
mCanvas
-
>
clear
(
SK_ColorTRANSPARENT
)
;
mCanvas
-
>
restore
(
)
;
}
void
DrawTargetSkia
:
:
PushClip
(
const
Path
*
aPath
)
{
if
(
aPath
-
>
GetBackendType
(
)
!
=
BackendType
:
:
SKIA
)
{
return
;
}
const
PathSkia
*
skiaPath
=
static_cast
<
const
PathSkia
*
>
(
aPath
)
;
mCanvas
-
>
save
(
)
;
mCanvas
-
>
clipPath
(
skiaPath
-
>
GetPath
(
)
SkRegion
:
:
kIntersect_Op
true
)
;
}
void
DrawTargetSkia
:
:
PushClipRect
(
const
Rect
&
aRect
)
{
SkRect
rect
=
RectToSkRect
(
aRect
)
;
mCanvas
-
>
save
(
)
;
mCanvas
-
>
clipRect
(
rect
SkRegion
:
:
kIntersect_Op
true
)
;
}
void
DrawTargetSkia
:
:
PopClip
(
)
{
mCanvas
-
>
restore
(
)
;
}
class
CopyLayerImageFilter
:
public
SkImageFilter
{
public
:
CopyLayerImageFilter
(
)
:
SkImageFilter
(
0
nullptr
)
{
}
virtual
bool
onFilterImageDeprecated
(
Proxy
*
const
SkBitmap
&
src
const
Context
&
SkBitmap
*
result
SkIPoint
*
offset
)
const
override
{
*
result
=
src
;
offset
-
>
set
(
0
0
)
;
return
true
;
}
SK_TO_STRING_OVERRIDE
(
)
SK_DECLARE_PUBLIC_FLATTENABLE_DESERIALIZATION_PROCS
(
CopyLayerImageFilter
)
}
;
sk_sp
<
SkFlattenable
>
CopyLayerImageFilter
:
:
CreateProc
(
SkReadBuffer
&
buffer
)
{
SK_IMAGEFILTER_UNFLATTEN_COMMON
(
common
0
)
;
return
sk_make_sp
<
CopyLayerImageFilter
>
(
)
;
}
#
ifndef
SK_IGNORE_TO_STRING
void
CopyLayerImageFilter
:
:
toString
(
SkString
*
str
)
const
{
str
-
>
append
(
"
CopyLayerImageFilter
:
(
)
"
)
;
}
#
endif
void
DrawTargetSkia
:
:
PushLayer
(
bool
aOpaque
Float
aOpacity
SourceSurface
*
aMask
const
Matrix
&
aMaskTransform
const
IntRect
&
aBounds
bool
aCopyBackground
)
{
PushedLayer
layer
(
GetPermitSubpixelAA
(
)
aOpaque
aOpacity
aMask
aMaskTransform
)
;
mPushedLayers
.
push_back
(
layer
)
;
SkPaint
paint
;
paint
.
setAlpha
(
aMask
?
0
:
ColorFloatToByte
(
aOpacity
)
)
;
SkRect
bounds
=
IntRectToSkRect
(
aBounds
)
;
SkAutoTUnref
<
SkImageFilter
>
backdrop
(
aCopyBackground
?
new
CopyLayerImageFilter
:
nullptr
)
;
SkCanvas
:
:
SaveLayerRec
saveRec
(
aBounds
.
IsEmpty
(
)
?
nullptr
:
&
bounds
&
paint
backdrop
.
get
(
)
aOpaque
?
SkCanvas
:
:
kIsOpaque_SaveLayerFlag
:
0
)
;
mCanvas
-
>
saveLayer
(
saveRec
)
;
SetPermitSubpixelAA
(
aOpaque
)
;
}
void
DrawTargetSkia
:
:
PopLayer
(
)
{
MarkChanged
(
)
;
MOZ_ASSERT
(
mPushedLayers
.
size
(
)
)
;
const
PushedLayer
&
layer
=
mPushedLayers
.
back
(
)
;
if
(
layer
.
mMask
)
{
SkAutoTUnref
<
SkBaseDevice
>
layerDevice
(
SkSafeRef
(
mCanvas
-
>
getTopDevice
(
)
)
)
;
SkIRect
layerBounds
=
layerDevice
-
>
getGlobalBounds
(
)
;
SkBitmap
layerBitmap
=
layerDevice
-
>
accessBitmap
(
false
)
;
mCanvas
-
>
restore
(
)
;
SkPaint
paint
;
paint
.
setAlpha
(
ColorFloatToByte
(
layer
.
mOpacity
)
)
;
SkMatrix
maskMat
layerMat
;
GfxMatrixToSkiaMatrix
(
layer
.
mMaskTransform
maskMat
)
;
maskMat
.
postConcat
(
mCanvas
-
>
getTotalMatrix
(
)
)
;
if
(
!
maskMat
.
invert
(
&
layerMat
)
)
{
gfxDebug
(
)
<
<
*
this
<
<
"
:
PopLayer
(
)
failed
to
invert
mask
transform
"
;
}
else
{
layerMat
.
preTranslate
(
layerBounds
.
x
(
)
layerBounds
.
y
(
)
)
;
sk_sp
<
SkShader
>
shader
=
SkShader
:
:
MakeBitmapShader
(
layerBitmap
SkShader
:
:
kClamp_TileMode
SkShader
:
:
kClamp_TileMode
&
layerMat
)
;
paint
.
setShader
(
shader
)
;
SkBitmap
mask
=
GetBitmapForSurface
(
layer
.
mMask
)
;
if
(
mask
.
colorType
(
)
!
=
kAlpha_8_SkColorType
&
&
!
mask
.
extractAlpha
(
&
mask
)
)
{
gfxDebug
(
)
<
<
*
this
<
<
"
:
PopLayer
(
)
failed
to
extract
alpha
for
mask
"
;
}
else
{
mCanvas
-
>
save
(
)
;
mCanvas
-
>
resetMatrix
(
)
;
mCanvas
-
>
clipRect
(
SkRect
:
:
Make
(
layerBounds
)
)
;
mCanvas
-
>
setMatrix
(
maskMat
)
;
mCanvas
-
>
drawBitmap
(
mask
0
0
&
paint
)
;
mCanvas
-
>
restore
(
)
;
}
}
}
else
{
mCanvas
-
>
restore
(
)
;
}
SetPermitSubpixelAA
(
layer
.
mOldPermitSubpixelAA
)
;
mPushedLayers
.
pop_back
(
)
;
}
already_AddRefed
<
GradientStops
>
DrawTargetSkia
:
:
CreateGradientStops
(
GradientStop
*
aStops
uint32_t
aNumStops
ExtendMode
aExtendMode
)
const
{
std
:
:
vector
<
GradientStop
>
stops
;
stops
.
resize
(
aNumStops
)
;
for
(
uint32_t
i
=
0
;
i
<
aNumStops
;
i
+
+
)
{
stops
[
i
]
=
aStops
[
i
]
;
}
std
:
:
stable_sort
(
stops
.
begin
(
)
stops
.
end
(
)
)
;
return
MakeAndAddRef
<
GradientStopsSkia
>
(
stops
aNumStops
aExtendMode
)
;
}
already_AddRefed
<
FilterNode
>
DrawTargetSkia
:
:
CreateFilter
(
FilterType
aType
)
{
return
FilterNodeSoftware
:
:
Create
(
aType
)
;
}
void
DrawTargetSkia
:
:
MarkChanged
(
)
{
if
(
mSnapshot
)
{
mSnapshot
-
>
DrawTargetWillChange
(
)
;
mSnapshot
=
nullptr
;
}
}
void
DrawTargetSkia
:
:
SnapshotDestroyed
(
)
{
mSnapshot
=
nullptr
;
}
}
}
