#
include
"
JobScheduler
.
h
"
namespace
mozilla
{
namespace
gfx
{
JobScheduler
*
JobScheduler
:
:
sSingleton
=
nullptr
;
bool
JobScheduler
:
:
Init
(
uint32_t
aNumThreads
uint32_t
aNumQueues
)
{
MOZ_ASSERT
(
!
sSingleton
)
;
MOZ_ASSERT
(
aNumThreads
>
=
aNumQueues
)
;
sSingleton
=
new
JobScheduler
(
)
;
sSingleton
-
>
mNextQueue
=
0
;
for
(
uint32_t
i
=
0
;
i
<
aNumQueues
;
+
+
i
)
{
sSingleton
-
>
mDrawingQueues
.
push_back
(
new
MultiThreadedJobQueue
(
)
)
;
}
for
(
uint32_t
i
=
0
;
i
<
aNumThreads
;
+
+
i
)
{
sSingleton
-
>
mWorkerThreads
.
push_back
(
WorkerThread
:
:
Create
(
sSingleton
-
>
mDrawingQueues
[
i
%
aNumQueues
]
)
)
;
}
return
true
;
}
void
JobScheduler
:
:
ShutDown
(
)
{
MOZ_ASSERT
(
IsEnabled
(
)
)
;
if
(
!
IsEnabled
(
)
)
{
return
;
}
for
(
auto
queue
:
sSingleton
-
>
mDrawingQueues
)
{
queue
-
>
ShutDown
(
)
;
delete
queue
;
}
for
(
WorkerThread
*
thread
:
sSingleton
-
>
mWorkerThreads
)
{
delete
thread
;
}
sSingleton
-
>
mWorkerThreads
.
clear
(
)
;
delete
sSingleton
;
sSingleton
=
nullptr
;
}
JobStatus
JobScheduler
:
:
ProcessJob
(
Job
*
aJob
)
{
MOZ_ASSERT
(
aJob
)
;
auto
status
=
aJob
-
>
Run
(
)
;
if
(
status
=
=
JobStatus
:
:
Error
|
|
status
=
=
JobStatus
:
:
Complete
)
{
delete
aJob
;
}
return
status
;
}
void
JobScheduler
:
:
SubmitJob
(
Job
*
aJob
)
{
MOZ_ASSERT
(
aJob
)
;
RefPtr
<
SyncObject
>
start
=
aJob
-
>
GetStartSync
(
)
;
if
(
start
&
&
start
-
>
Register
(
aJob
)
)
{
return
;
}
GetQueueForJob
(
aJob
)
-
>
SubmitJob
(
aJob
)
;
}
MultiThreadedJobQueue
*
JobScheduler
:
:
GetQueueForJob
(
Job
*
aJob
)
{
return
aJob
-
>
IsPinnedToAThread
(
)
?
aJob
-
>
GetWorkerThread
(
)
-
>
GetJobQueue
(
)
:
GetDrawingQueue
(
)
;
}
Job
:
:
Job
(
SyncObject
*
aStart
SyncObject
*
aCompletion
WorkerThread
*
aThread
)
:
mNextWaitingJob
(
nullptr
)
mStartSync
(
aStart
)
mCompletionSync
(
aCompletion
)
mPinToThread
(
aThread
)
{
if
(
mStartSync
)
{
mStartSync
-
>
AddSubsequent
(
this
)
;
}
if
(
mCompletionSync
)
{
mCompletionSync
-
>
AddPrerequisite
(
this
)
;
}
}
Job
:
:
~
Job
(
)
{
if
(
mCompletionSync
)
{
mCompletionSync
-
>
Signal
(
)
;
mCompletionSync
=
nullptr
;
}
}
JobStatus
SetEventJob
:
:
Run
(
)
{
mEvent
-
>
Set
(
)
;
return
JobStatus
:
:
Complete
;
}
SetEventJob
:
:
SetEventJob
(
EventObject
*
aEvent
SyncObject
*
aStart
SyncObject
*
aCompletion
WorkerThread
*
aWorker
)
:
Job
(
aStart
aCompletion
aWorker
)
mEvent
(
aEvent
)
{
}
SetEventJob
:
:
~
SetEventJob
(
)
{
}
SyncObject
:
:
SyncObject
(
uint32_t
aNumPrerequisites
)
:
mSignals
(
aNumPrerequisites
)
mFirstWaitingJob
(
nullptr
)
#
ifdef
DEBUG
mNumPrerequisites
(
aNumPrerequisites
)
mAddedPrerequisites
(
0
)
#
endif
{
}
SyncObject
:
:
~
SyncObject
(
)
{
MOZ_ASSERT
(
mFirstWaitingJob
=
=
nullptr
)
;
}
bool
SyncObject
:
:
Register
(
Job
*
aJob
)
{
MOZ_ASSERT
(
aJob
)
;
FreezePrerequisites
(
)
;
int32_t
signals
=
mSignals
;
if
(
signals
>
0
)
{
AddWaitingJob
(
aJob
)
;
int32_t
signals2
=
mSignals
;
if
(
signals2
=
=
0
)
{
SubmitWaitingJobs
(
)
;
}
return
true
;
}
return
false
;
}
void
SyncObject
:
:
Signal
(
)
{
int32_t
signals
=
-
-
mSignals
;
MOZ_ASSERT
(
signals
>
=
0
)
;
if
(
signals
=
=
0
)
{
SubmitWaitingJobs
(
)
;
}
}
void
SyncObject
:
:
AddWaitingJob
(
Job
*
aJob
)
{
for
(
;
;
)
{
Job
*
first
=
mFirstWaitingJob
;
aJob
-
>
mNextWaitingJob
=
first
;
if
(
mFirstWaitingJob
.
compareExchange
(
first
aJob
)
)
{
break
;
}
}
}
void
SyncObject
:
:
SubmitWaitingJobs
(
)
{
RefPtr
<
SyncObject
>
kungFuDeathGrip
(
this
)
;
Job
*
waitingJobs
=
nullptr
;
for
(
;
;
)
{
waitingJobs
=
mFirstWaitingJob
;
if
(
mFirstWaitingJob
.
compareExchange
(
waitingJobs
nullptr
)
)
{
break
;
}
}
while
(
waitingJobs
)
{
Job
*
next
=
waitingJobs
-
>
mNextWaitingJob
;
waitingJobs
-
>
mNextWaitingJob
=
nullptr
;
JobScheduler
:
:
GetQueueForJob
(
waitingJobs
)
-
>
SubmitJob
(
waitingJobs
)
;
waitingJobs
=
next
;
}
}
bool
SyncObject
:
:
IsSignaled
(
)
{
return
mSignals
=
=
0
;
}
void
SyncObject
:
:
FreezePrerequisites
(
)
{
MOZ_ASSERT
(
mAddedPrerequisites
=
=
mNumPrerequisites
)
;
}
void
SyncObject
:
:
AddPrerequisite
(
Job
*
aJob
)
{
MOZ_ASSERT
(
+
+
mAddedPrerequisites
<
=
mNumPrerequisites
)
;
}
void
SyncObject
:
:
AddSubsequent
(
Job
*
aJob
)
{
}
WorkerThread
:
:
WorkerThread
(
MultiThreadedJobQueue
*
aJobQueue
)
:
mQueue
(
aJobQueue
)
{
aJobQueue
-
>
RegisterThread
(
)
;
}
void
WorkerThread
:
:
Run
(
)
{
SetName
(
"
gfx
worker
"
)
;
for
(
;
;
)
{
Job
*
commands
=
nullptr
;
if
(
!
mQueue
-
>
WaitForJob
(
commands
)
)
{
mQueue
-
>
UnregisterThread
(
)
;
return
;
}
JobStatus
status
=
JobScheduler
:
:
ProcessJob
(
commands
)
;
if
(
status
=
=
JobStatus
:
:
Error
)
{
MOZ_CRASH
(
)
;
}
}
}
}
}
