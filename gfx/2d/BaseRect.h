#
ifndef
MOZILLA_GFX_BASERECT_H_
#
define
MOZILLA_GFX_BASERECT_H_
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
ostream
>
#
include
<
type_traits
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
Types
.
h
"
namespace
mozilla
{
namespace
gfx
{
template
<
class
T
class
Sub
class
Point
class
SizeT
class
MarginT
>
struct
BaseRect
{
T
x
y
width
height
;
BaseRect
(
)
:
x
(
0
)
y
(
0
)
width
(
0
)
height
(
0
)
{
}
BaseRect
(
const
Point
&
aOrigin
const
SizeT
&
aSize
)
:
x
(
aOrigin
.
x
)
y
(
aOrigin
.
y
)
width
(
aSize
.
width
)
height
(
aSize
.
height
)
{
}
BaseRect
(
T
aX
T
aY
T
aWidth
T
aHeight
)
:
x
(
aX
)
y
(
aY
)
width
(
aWidth
)
height
(
aHeight
)
{
}
MOZ_ALWAYS_INLINE
bool
IsZeroArea
(
)
const
{
return
height
=
=
0
|
|
width
=
=
0
;
}
MOZ_ALWAYS_INLINE
bool
IsEmpty
(
)
const
{
return
height
<
=
0
|
|
width
<
=
0
;
}
void
SetEmpty
(
)
{
width
=
height
=
0
;
}
bool
IsFinite
(
)
const
{
using
FloatType
=
std
:
:
conditional_t
<
std
:
:
is_same_v
<
T
float
>
float
double
>
;
return
(
mozilla
:
:
IsFinite
(
FloatType
(
x
)
)
&
&
mozilla
:
:
IsFinite
(
FloatType
(
y
)
)
&
&
mozilla
:
:
IsFinite
(
FloatType
(
width
)
)
&
&
mozilla
:
:
IsFinite
(
FloatType
(
height
)
)
)
;
}
bool
Contains
(
const
Sub
&
aRect
)
const
{
return
aRect
.
IsEmpty
(
)
|
|
(
x
<
=
aRect
.
x
&
&
aRect
.
XMost
(
)
<
=
XMost
(
)
&
&
y
<
=
aRect
.
y
&
&
aRect
.
YMost
(
)
<
=
YMost
(
)
)
;
}
MOZ_ALWAYS_INLINE
bool
Contains
(
T
aX
T
aY
)
const
{
return
x
<
=
aX
&
&
aX
<
XMost
(
)
&
&
y
<
=
aY
&
&
aY
<
YMost
(
)
;
}
MOZ_ALWAYS_INLINE
bool
ContainsX
(
T
aX
)
const
{
return
x
<
=
aX
&
&
aX
<
XMost
(
)
;
}
MOZ_ALWAYS_INLINE
bool
ContainsY
(
T
aY
)
const
{
return
y
<
=
aY
&
&
aY
<
YMost
(
)
;
}
bool
Contains
(
const
Point
&
aPoint
)
const
{
return
Contains
(
aPoint
.
x
aPoint
.
y
)
;
}
bool
Intersects
(
const
Sub
&
aRect
)
const
{
return
!
IsEmpty
(
)
&
&
!
aRect
.
IsEmpty
(
)
&
&
x
<
aRect
.
XMost
(
)
&
&
aRect
.
x
<
XMost
(
)
&
&
y
<
aRect
.
YMost
(
)
&
&
aRect
.
y
<
YMost
(
)
;
}
[
[
nodiscard
]
]
Sub
Intersect
(
const
Sub
&
aRect
)
const
{
Sub
result
;
result
.
x
=
std
:
:
max
<
T
>
(
x
aRect
.
x
)
;
result
.
y
=
std
:
:
max
<
T
>
(
y
aRect
.
y
)
;
result
.
width
=
std
:
:
min
<
T
>
(
x
-
result
.
x
+
width
aRect
.
x
-
result
.
x
+
aRect
.
width
)
;
result
.
height
=
std
:
:
min
<
T
>
(
y
-
result
.
y
+
height
aRect
.
y
-
result
.
y
+
aRect
.
height
)
;
if
(
result
.
width
<
0
|
|
result
.
height
<
0
)
{
result
.
SizeTo
(
0
0
)
;
}
return
result
;
}
bool
IntersectRect
(
const
Sub
&
aRect1
const
Sub
&
aRect2
)
{
T
newX
=
std
:
:
max
<
T
>
(
aRect1
.
x
aRect2
.
x
)
;
T
newY
=
std
:
:
max
<
T
>
(
aRect1
.
y
aRect2
.
y
)
;
width
=
std
:
:
min
<
T
>
(
aRect1
.
x
-
newX
+
aRect1
.
width
aRect2
.
x
-
newX
+
aRect2
.
width
)
;
height
=
std
:
:
min
<
T
>
(
aRect1
.
y
-
newY
+
aRect1
.
height
aRect2
.
y
-
newY
+
aRect2
.
height
)
;
x
=
newX
;
y
=
newY
;
if
(
width
<
=
0
|
|
height
<
=
0
)
{
SizeTo
(
0
0
)
;
return
false
;
}
return
true
;
}
[
[
nodiscard
]
]
Sub
Union
(
const
Sub
&
aRect
)
const
{
if
(
IsEmpty
(
)
)
{
return
aRect
;
}
else
if
(
aRect
.
IsEmpty
(
)
)
{
return
*
static_cast
<
const
Sub
*
>
(
this
)
;
}
else
{
return
UnionEdges
(
aRect
)
;
}
}
[
[
nodiscard
]
]
Sub
UnionEdges
(
const
Sub
&
aRect
)
const
{
Sub
result
;
result
.
x
=
std
:
:
min
(
x
aRect
.
x
)
;
result
.
y
=
std
:
:
min
(
y
aRect
.
y
)
;
result
.
width
=
std
:
:
max
(
XMost
(
)
aRect
.
XMost
(
)
)
-
result
.
x
;
result
.
height
=
std
:
:
max
(
YMost
(
)
aRect
.
YMost
(
)
)
-
result
.
y
;
return
result
;
}
void
UnionRect
(
const
Sub
&
aRect1
const
Sub
&
aRect2
)
{
*
static_cast
<
Sub
*
>
(
this
)
=
aRect1
.
Union
(
aRect2
)
;
}
void
OrWith
(
const
Sub
&
aRect1
)
{
UnionRect
(
*
static_cast
<
Sub
*
>
(
this
)
aRect1
)
;
}
void
UnionRectEdges
(
const
Sub
&
aRect1
const
Sub
&
aRect2
)
{
*
static_cast
<
Sub
*
>
(
this
)
=
aRect1
.
UnionEdges
(
aRect2
)
;
}
void
ExpandToEnclose
(
const
Point
&
aPoint
)
{
if
(
aPoint
.
x
<
x
)
{
width
=
XMost
(
)
-
aPoint
.
x
;
x
=
aPoint
.
x
;
}
else
if
(
aPoint
.
x
>
XMost
(
)
)
{
width
=
aPoint
.
x
-
x
;
}
if
(
aPoint
.
y
<
y
)
{
height
=
YMost
(
)
-
aPoint
.
y
;
y
=
aPoint
.
y
;
}
else
if
(
aPoint
.
y
>
YMost
(
)
)
{
height
=
aPoint
.
y
-
y
;
}
}
MOZ_ALWAYS_INLINE
void
SetRect
(
T
aX
T
aY
T
aWidth
T
aHeight
)
{
x
=
aX
;
y
=
aY
;
width
=
aWidth
;
height
=
aHeight
;
}
MOZ_ALWAYS_INLINE
void
SetRectX
(
T
aX
T
aWidth
)
{
x
=
aX
;
width
=
aWidth
;
}
MOZ_ALWAYS_INLINE
void
SetRectY
(
T
aY
T
aHeight
)
{
y
=
aY
;
height
=
aHeight
;
}
MOZ_ALWAYS_INLINE
void
SetBox
(
T
aX
T
aY
T
aXMost
T
aYMost
)
{
x
=
aX
;
y
=
aY
;
width
=
aXMost
-
aX
;
height
=
aYMost
-
aY
;
}
MOZ_ALWAYS_INLINE
void
SetNonEmptyBox
(
T
aX
T
aY
T
aXMost
T
aYMost
)
{
x
=
aX
;
y
=
aY
;
width
=
std
:
:
max
(
0
aXMost
-
aX
)
;
height
=
std
:
:
max
(
0
aYMost
-
aY
)
;
}
MOZ_ALWAYS_INLINE
void
SetBoxX
(
T
aX
T
aXMost
)
{
x
=
aX
;
width
=
aXMost
-
aX
;
}
MOZ_ALWAYS_INLINE
void
SetBoxY
(
T
aY
T
aYMost
)
{
y
=
aY
;
height
=
aYMost
-
aY
;
}
void
SetRect
(
const
Point
&
aPt
const
SizeT
&
aSize
)
{
SetRect
(
aPt
.
x
aPt
.
y
aSize
.
width
aSize
.
height
)
;
}
MOZ_ALWAYS_INLINE
void
GetRect
(
T
*
aX
T
*
aY
T
*
aWidth
T
*
aHeight
)
const
{
*
aX
=
x
;
*
aY
=
y
;
*
aWidth
=
width
;
*
aHeight
=
height
;
}
MOZ_ALWAYS_INLINE
void
MoveTo
(
T
aX
T
aY
)
{
x
=
aX
;
y
=
aY
;
}
MOZ_ALWAYS_INLINE
void
MoveToX
(
T
aX
)
{
x
=
aX
;
}
MOZ_ALWAYS_INLINE
void
MoveToY
(
T
aY
)
{
y
=
aY
;
}
MOZ_ALWAYS_INLINE
void
MoveTo
(
const
Point
&
aPoint
)
{
x
=
aPoint
.
x
;
y
=
aPoint
.
y
;
}
MOZ_ALWAYS_INLINE
void
MoveBy
(
T
aDx
T
aDy
)
{
x
+
=
aDx
;
y
+
=
aDy
;
}
MOZ_ALWAYS_INLINE
void
MoveByX
(
T
aDx
)
{
x
+
=
aDx
;
}
MOZ_ALWAYS_INLINE
void
MoveByY
(
T
aDy
)
{
y
+
=
aDy
;
}
MOZ_ALWAYS_INLINE
void
MoveBy
(
const
Point
&
aPoint
)
{
x
+
=
aPoint
.
x
;
y
+
=
aPoint
.
y
;
}
MOZ_ALWAYS_INLINE
void
SizeTo
(
T
aWidth
T
aHeight
)
{
width
=
aWidth
;
height
=
aHeight
;
}
MOZ_ALWAYS_INLINE
void
SizeTo
(
const
SizeT
&
aSize
)
{
width
=
aSize
.
width
;
height
=
aSize
.
height
;
}
void
Inflate
(
T
aD
)
{
Inflate
(
aD
aD
)
;
}
void
Inflate
(
T
aDx
T
aDy
)
{
x
-
=
aDx
;
y
-
=
aDy
;
width
+
=
2
*
aDx
;
height
+
=
2
*
aDy
;
}
void
Inflate
(
const
MarginT
&
aMargin
)
{
x
-
=
aMargin
.
left
;
y
-
=
aMargin
.
top
;
width
+
=
aMargin
.
LeftRight
(
)
;
height
+
=
aMargin
.
TopBottom
(
)
;
}
void
Inflate
(
const
SizeT
&
aSize
)
{
Inflate
(
aSize
.
width
aSize
.
height
)
;
}
void
Deflate
(
T
aD
)
{
Deflate
(
aD
aD
)
;
}
void
Deflate
(
T
aDx
T
aDy
)
{
x
+
=
aDx
;
y
+
=
aDy
;
width
=
std
:
:
max
(
T
(
0
)
width
-
2
*
aDx
)
;
height
=
std
:
:
max
(
T
(
0
)
height
-
2
*
aDy
)
;
}
void
Deflate
(
const
MarginT
&
aMargin
)
{
x
+
=
aMargin
.
left
;
y
+
=
aMargin
.
top
;
width
=
std
:
:
max
(
T
(
0
)
width
-
aMargin
.
LeftRight
(
)
)
;
height
=
std
:
:
max
(
T
(
0
)
height
-
aMargin
.
TopBottom
(
)
)
;
}
void
Deflate
(
const
SizeT
&
aSize
)
{
Deflate
(
aSize
.
width
aSize
.
height
)
;
}
bool
IsEqualEdges
(
const
Sub
&
aRect
)
const
{
return
x
=
=
aRect
.
x
&
&
y
=
=
aRect
.
y
&
&
width
=
=
aRect
.
width
&
&
height
=
=
aRect
.
height
;
}
MOZ_ALWAYS_INLINE
bool
IsEqualRect
(
T
aX
T
aY
T
aW
T
aH
)
{
return
x
=
=
aX
&
&
y
=
=
aY
&
&
width
=
=
aW
&
&
height
=
=
aH
;
}
MOZ_ALWAYS_INLINE
bool
IsEqualXY
(
T
aX
T
aY
)
{
return
x
=
=
aX
&
&
y
=
=
aY
;
}
MOZ_ALWAYS_INLINE
bool
IsEqualSize
(
T
aW
T
aH
)
{
return
width
=
=
aW
&
&
height
=
=
aH
;
}
bool
IsEqualInterior
(
const
Sub
&
aRect
)
const
{
return
IsEqualEdges
(
aRect
)
|
|
(
IsEmpty
(
)
&
&
aRect
.
IsEmpty
(
)
)
;
}
friend
Sub
operator
+
(
Sub
aSub
const
Point
&
aPoint
)
{
aSub
+
=
aPoint
;
return
aSub
;
}
friend
Sub
operator
-
(
Sub
aSub
const
Point
&
aPoint
)
{
aSub
-
=
aPoint
;
return
aSub
;
}
friend
Sub
operator
+
(
Sub
aSub
const
SizeT
&
aSize
)
{
aSub
+
=
aSize
;
return
aSub
;
}
friend
Sub
operator
-
(
Sub
aSub
const
SizeT
&
aSize
)
{
aSub
-
=
aSize
;
return
aSub
;
}
Sub
&
operator
+
=
(
const
Point
&
aPoint
)
{
MoveBy
(
aPoint
)
;
return
*
static_cast
<
Sub
*
>
(
this
)
;
}
Sub
&
operator
-
=
(
const
Point
&
aPoint
)
{
MoveBy
(
-
aPoint
)
;
return
*
static_cast
<
Sub
*
>
(
this
)
;
}
Sub
&
operator
+
=
(
const
SizeT
&
aSize
)
{
width
+
=
aSize
.
width
;
height
+
=
aSize
.
height
;
return
*
static_cast
<
Sub
*
>
(
this
)
;
}
Sub
&
operator
-
=
(
const
SizeT
&
aSize
)
{
width
-
=
aSize
.
width
;
height
-
=
aSize
.
height
;
return
*
static_cast
<
Sub
*
>
(
this
)
;
}
MarginT
operator
-
(
const
Sub
&
aRect
)
const
{
return
MarginT
(
aRect
.
y
-
y
XMost
(
)
-
aRect
.
XMost
(
)
YMost
(
)
-
aRect
.
YMost
(
)
aRect
.
x
-
x
)
;
}
Point
TopLeft
(
)
const
{
return
Point
(
x
y
)
;
}
Point
TopRight
(
)
const
{
return
Point
(
XMost
(
)
y
)
;
}
Point
BottomLeft
(
)
const
{
return
Point
(
x
YMost
(
)
)
;
}
Point
BottomRight
(
)
const
{
return
Point
(
XMost
(
)
YMost
(
)
)
;
}
Point
AtCorner
(
Corner
aCorner
)
const
{
switch
(
aCorner
)
{
case
eCornerTopLeft
:
return
TopLeft
(
)
;
case
eCornerTopRight
:
return
TopRight
(
)
;
case
eCornerBottomRight
:
return
BottomRight
(
)
;
case
eCornerBottomLeft
:
return
BottomLeft
(
)
;
}
MOZ_CRASH
(
"
GFX
:
Incomplete
switch
"
)
;
}
Point
CCWCorner
(
mozilla
:
:
Side
side
)
const
{
switch
(
side
)
{
case
eSideTop
:
return
TopLeft
(
)
;
case
eSideRight
:
return
TopRight
(
)
;
case
eSideBottom
:
return
BottomRight
(
)
;
case
eSideLeft
:
return
BottomLeft
(
)
;
}
MOZ_CRASH
(
"
GFX
:
Incomplete
switch
"
)
;
}
Point
CWCorner
(
mozilla
:
:
Side
side
)
const
{
switch
(
side
)
{
case
eSideTop
:
return
TopRight
(
)
;
case
eSideRight
:
return
BottomRight
(
)
;
case
eSideBottom
:
return
BottomLeft
(
)
;
case
eSideLeft
:
return
TopLeft
(
)
;
}
MOZ_CRASH
(
"
GFX
:
Incomplete
switch
"
)
;
}
Point
Center
(
)
const
{
return
Point
(
x
y
)
+
Point
(
width
height
)
/
2
;
}
SizeT
Size
(
)
const
{
return
SizeT
(
width
height
)
;
}
T
Area
(
)
const
{
return
width
*
height
;
}
MOZ_ALWAYS_INLINE
T
X
(
)
const
{
return
x
;
}
MOZ_ALWAYS_INLINE
T
Y
(
)
const
{
return
y
;
}
MOZ_ALWAYS_INLINE
T
Width
(
)
const
{
return
width
;
}
MOZ_ALWAYS_INLINE
T
Height
(
)
const
{
return
height
;
}
MOZ_ALWAYS_INLINE
T
XMost
(
)
const
{
return
x
+
width
;
}
MOZ_ALWAYS_INLINE
T
YMost
(
)
const
{
return
y
+
height
;
}
MOZ_ALWAYS_INLINE
void
SetWidth
(
T
aWidth
)
{
width
=
aWidth
;
}
MOZ_ALWAYS_INLINE
void
SetHeight
(
T
aHeight
)
{
height
=
aHeight
;
}
T
Edge
(
mozilla
:
:
Side
aSide
)
const
{
switch
(
aSide
)
{
case
eSideTop
:
return
Y
(
)
;
case
eSideRight
:
return
XMost
(
)
;
case
eSideBottom
:
return
YMost
(
)
;
case
eSideLeft
:
return
X
(
)
;
}
MOZ_CRASH
(
"
GFX
:
Incomplete
switch
"
)
;
}
void
SetLeftEdge
(
T
aX
)
{
width
=
XMost
(
)
-
aX
;
x
=
aX
;
}
void
SetRightEdge
(
T
aXMost
)
{
width
=
aXMost
-
x
;
}
void
SetTopEdge
(
T
aY
)
{
height
=
YMost
(
)
-
aY
;
y
=
aY
;
}
void
SetBottomEdge
(
T
aYMost
)
{
height
=
aYMost
-
y
;
}
void
Swap
(
)
{
std
:
:
swap
(
x
y
)
;
std
:
:
swap
(
width
height
)
;
}
void
Round
(
)
{
T
x0
=
static_cast
<
T
>
(
std
:
:
floor
(
T
(
X
(
)
)
+
0
.
5f
)
)
;
T
y0
=
static_cast
<
T
>
(
std
:
:
floor
(
T
(
Y
(
)
)
+
0
.
5f
)
)
;
T
x1
=
static_cast
<
T
>
(
std
:
:
floor
(
T
(
XMost
(
)
)
+
0
.
5f
)
)
;
T
y1
=
static_cast
<
T
>
(
std
:
:
floor
(
T
(
YMost
(
)
)
+
0
.
5f
)
)
;
x
=
x0
;
y
=
y0
;
width
=
x1
-
x0
;
height
=
y1
-
y0
;
}
void
RoundIn
(
)
{
T
x0
=
static_cast
<
T
>
(
std
:
:
ceil
(
T
(
X
(
)
)
)
)
;
T
y0
=
static_cast
<
T
>
(
std
:
:
ceil
(
T
(
Y
(
)
)
)
)
;
T
x1
=
static_cast
<
T
>
(
std
:
:
floor
(
T
(
XMost
(
)
)
)
)
;
T
y1
=
static_cast
<
T
>
(
std
:
:
floor
(
T
(
YMost
(
)
)
)
)
;
x
=
x0
;
y
=
y0
;
width
=
x1
-
x0
;
height
=
y1
-
y0
;
}
void
RoundOut
(
)
{
T
x0
=
static_cast
<
T
>
(
std
:
:
floor
(
T
(
X
(
)
)
)
)
;
T
y0
=
static_cast
<
T
>
(
std
:
:
floor
(
T
(
Y
(
)
)
)
)
;
T
x1
=
static_cast
<
T
>
(
std
:
:
ceil
(
T
(
XMost
(
)
)
)
)
;
T
y1
=
static_cast
<
T
>
(
std
:
:
ceil
(
T
(
YMost
(
)
)
)
)
;
x
=
x0
;
y
=
y0
;
width
=
x1
-
x0
;
height
=
y1
-
y0
;
}
void
Scale
(
T
aScale
)
{
Scale
(
aScale
aScale
)
;
}
void
Scale
(
T
aXScale
T
aYScale
)
{
T
right
=
XMost
(
)
*
aXScale
;
T
bottom
=
YMost
(
)
*
aYScale
;
x
=
x
*
aXScale
;
y
=
y
*
aYScale
;
width
=
right
-
x
;
height
=
bottom
-
y
;
}
void
ScaleRoundOut
(
double
aScale
)
{
ScaleRoundOut
(
aScale
aScale
)
;
}
void
ScaleRoundOut
(
double
aXScale
double
aYScale
)
{
T
right
=
static_cast
<
T
>
(
ceil
(
double
(
XMost
(
)
)
*
aXScale
)
)
;
T
bottom
=
static_cast
<
T
>
(
ceil
(
double
(
YMost
(
)
)
*
aYScale
)
)
;
x
=
static_cast
<
T
>
(
floor
(
double
(
x
)
*
aXScale
)
)
;
y
=
static_cast
<
T
>
(
floor
(
double
(
y
)
*
aYScale
)
)
;
width
=
right
-
x
;
height
=
bottom
-
y
;
}
void
ScaleRoundIn
(
double
aScale
)
{
ScaleRoundIn
(
aScale
aScale
)
;
}
void
ScaleRoundIn
(
double
aXScale
double
aYScale
)
{
T
right
=
static_cast
<
T
>
(
floor
(
double
(
XMost
(
)
)
*
aXScale
)
)
;
T
bottom
=
static_cast
<
T
>
(
floor
(
double
(
YMost
(
)
)
*
aYScale
)
)
;
x
=
static_cast
<
T
>
(
ceil
(
double
(
x
)
*
aXScale
)
)
;
y
=
static_cast
<
T
>
(
ceil
(
double
(
y
)
*
aYScale
)
)
;
width
=
std
:
:
max
<
T
>
(
0
right
-
x
)
;
height
=
std
:
:
max
<
T
>
(
0
bottom
-
y
)
;
}
void
ScaleInverseRoundOut
(
double
aScale
)
{
ScaleInverseRoundOut
(
aScale
aScale
)
;
}
void
ScaleInverseRoundOut
(
double
aXScale
double
aYScale
)
{
T
right
=
static_cast
<
T
>
(
ceil
(
double
(
XMost
(
)
)
/
aXScale
)
)
;
T
bottom
=
static_cast
<
T
>
(
ceil
(
double
(
YMost
(
)
)
/
aYScale
)
)
;
x
=
static_cast
<
T
>
(
floor
(
double
(
x
)
/
aXScale
)
)
;
y
=
static_cast
<
T
>
(
floor
(
double
(
y
)
/
aYScale
)
)
;
width
=
right
-
x
;
height
=
bottom
-
y
;
}
void
ScaleInverseRoundIn
(
double
aScale
)
{
ScaleInverseRoundIn
(
aScale
aScale
)
;
}
void
ScaleInverseRoundIn
(
double
aXScale
double
aYScale
)
{
T
right
=
static_cast
<
T
>
(
floor
(
double
(
XMost
(
)
)
/
aXScale
)
)
;
T
bottom
=
static_cast
<
T
>
(
floor
(
double
(
YMost
(
)
)
/
aYScale
)
)
;
x
=
static_cast
<
T
>
(
ceil
(
double
(
x
)
/
aXScale
)
)
;
y
=
static_cast
<
T
>
(
ceil
(
double
(
y
)
/
aYScale
)
)
;
width
=
std
:
:
max
<
T
>
(
0
right
-
x
)
;
height
=
std
:
:
max
<
T
>
(
0
bottom
-
y
)
;
}
[
[
nodiscard
]
]
Point
ClampPoint
(
const
Point
&
aPoint
)
const
{
return
Point
(
std
:
:
max
(
x
std
:
:
min
(
XMost
(
)
aPoint
.
x
)
)
std
:
:
max
(
y
std
:
:
min
(
YMost
(
)
aPoint
.
y
)
)
)
;
}
[
[
nodiscard
]
]
Sub
MoveInsideAndClamp
(
const
Sub
&
aRect
)
const
{
Sub
rect
(
std
:
:
max
(
aRect
.
x
x
)
std
:
:
max
(
aRect
.
y
y
)
std
:
:
min
(
aRect
.
width
width
)
std
:
:
min
(
aRect
.
height
height
)
)
;
rect
.
x
=
std
:
:
min
(
rect
.
XMost
(
)
aRect
.
XMost
(
)
)
-
rect
.
width
;
rect
.
y
=
std
:
:
min
(
rect
.
YMost
(
)
aRect
.
YMost
(
)
)
-
rect
.
height
;
return
rect
;
}
static
Sub
MaxIntRect
(
)
{
return
Sub
(
static_cast
<
T
>
(
-
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
*
0
.
5
)
static_cast
<
T
>
(
-
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
*
0
.
5
)
static_cast
<
T
>
(
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
static_cast
<
T
>
(
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
)
;
}
;
Point
DistanceTo
(
const
Point
&
aPoint
)
const
{
return
{
DistanceFromInterval
(
aPoint
.
x
x
XMost
(
)
)
DistanceFromInterval
(
aPoint
.
y
y
YMost
(
)
)
}
;
}
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
stream
const
BaseRect
<
T
Sub
Point
SizeT
MarginT
>
&
aRect
)
{
return
stream
<
<
"
(
x
=
"
<
<
aRect
.
x
<
<
"
y
=
"
<
<
aRect
.
y
<
<
"
w
=
"
<
<
aRect
.
width
<
<
"
h
=
"
<
<
aRect
.
height
<
<
'
)
'
;
}
private
:
bool
operator
=
=
(
const
Sub
&
aRect
)
const
{
return
false
;
}
bool
operator
!
=
(
const
Sub
&
aRect
)
const
{
return
false
;
}
static
T
DistanceFromInterval
(
T
aCoord
T
aIntervalStart
T
aIntervalEnd
)
{
if
(
aCoord
<
aIntervalStart
)
{
return
aIntervalStart
-
aCoord
;
}
if
(
aCoord
>
aIntervalEnd
)
{
return
aCoord
-
aIntervalEnd
;
}
return
0
;
}
}
;
}
}
#
endif
