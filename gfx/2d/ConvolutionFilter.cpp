#
include
"
2D
.
h
"
#
include
"
ConvolutionFilter
.
h
"
#
include
"
skia
/
src
/
core
/
SkBitmapFilter
.
h
"
#
include
"
skia
/
src
/
core
/
SkConvolver
.
h
"
#
include
"
skia
/
src
/
core
/
SkOpts
.
h
"
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
"
mozilla
/
Vector
.
h
"
namespace
mozilla
:
:
gfx
{
ConvolutionFilter
:
:
ConvolutionFilter
(
)
:
mFilter
(
MakeUnique
<
SkConvolutionFilter1D
>
(
)
)
{
}
ConvolutionFilter
:
:
~
ConvolutionFilter
(
)
{
}
int32_t
ConvolutionFilter
:
:
MaxFilter
(
)
const
{
return
mFilter
-
>
maxFilter
(
)
;
}
int32_t
ConvolutionFilter
:
:
NumValues
(
)
const
{
return
mFilter
-
>
numValues
(
)
;
}
bool
ConvolutionFilter
:
:
GetFilterOffsetAndLength
(
int32_t
aRowIndex
int32_t
*
aResultOffset
int32_t
*
aResultLength
)
{
if
(
aRowIndex
>
=
mFilter
-
>
numValues
(
)
)
{
return
false
;
}
mFilter
-
>
FilterForValue
(
aRowIndex
aResultOffset
aResultLength
)
;
return
true
;
}
void
ConvolutionFilter
:
:
ConvolveHorizontally
(
const
uint8_t
*
aSrc
uint8_t
*
aDst
bool
aHasAlpha
)
{
SkOpts
:
:
convolve_horizontally
(
aSrc
*
mFilter
aDst
aHasAlpha
)
;
}
void
ConvolutionFilter
:
:
ConvolveVertically
(
uint8_t
*
const
*
aSrc
uint8_t
*
aDst
int32_t
aRowIndex
int32_t
aRowSize
bool
aHasAlpha
)
{
MOZ_ASSERT
(
aRowIndex
<
mFilter
-
>
numValues
(
)
)
;
int32_t
filterOffset
;
int32_t
filterLength
;
auto
filterValues
=
mFilter
-
>
FilterForValue
(
aRowIndex
&
filterOffset
&
filterLength
)
;
SkOpts
:
:
convolve_vertically
(
filterValues
filterLength
aSrc
aRowSize
aDst
aHasAlpha
)
;
}
bool
ConvolutionFilter
:
:
ComputeResizeFilter
(
ResizeMethod
aResizeMethod
int32_t
aSrcSize
int32_t
aDstSize
)
{
typedef
SkConvolutionFilter1D
:
:
ConvolutionFixed
Fixed
;
UniquePtr
<
SkBitmapFilter
>
bitmapFilter
;
switch
(
aResizeMethod
)
{
case
ResizeMethod
:
:
BOX
:
bitmapFilter
=
MakeUnique
<
SkBoxFilter
>
(
)
;
break
;
case
ResizeMethod
:
:
TRIANGLE
:
bitmapFilter
=
MakeUnique
<
SkTriangleFilter
>
(
)
;
break
;
case
ResizeMethod
:
:
LANCZOS3
:
bitmapFilter
=
MakeUnique
<
SkLanczosFilter
>
(
)
;
break
;
case
ResizeMethod
:
:
HAMMING
:
bitmapFilter
=
MakeUnique
<
SkHammingFilter
>
(
)
;
break
;
case
ResizeMethod
:
:
MITCHELL
:
bitmapFilter
=
MakeUnique
<
SkMitchellFilter
>
(
)
;
break
;
default
:
return
false
;
}
float
scale
=
float
(
aDstSize
)
/
float
(
aSrcSize
)
;
float
clampedScale
=
std
:
:
min
(
1
.
0f
scale
)
;
float
srcSupport
=
bitmapFilter
-
>
width
(
)
/
clampedScale
;
float
invScale
=
1
.
0f
/
scale
;
Vector
<
float
64
>
filterValues
;
Vector
<
Fixed
64
>
fixedFilterValues
;
mFilter
-
>
reserveAdditional
(
aDstSize
int32_t
(
ceil
(
aDstSize
*
srcSupport
*
2
)
)
)
;
for
(
int32_t
destI
=
0
;
destI
<
aDstSize
;
destI
+
+
)
{
float
srcPixel
=
(
static_cast
<
float
>
(
destI
)
+
0
.
5f
)
*
invScale
;
float
srcBegin
=
std
:
:
max
(
0
.
0f
floorf
(
srcPixel
-
srcSupport
)
)
;
float
srcEnd
=
std
:
:
min
(
aSrcSize
-
1
.
0f
ceilf
(
srcPixel
+
srcSupport
)
)
;
float
destFilterDist
=
(
srcBegin
+
0
.
5f
-
srcPixel
)
*
clampedScale
;
int32_t
filterCount
=
int32_t
(
srcEnd
-
srcBegin
)
+
1
;
if
(
filterCount
<
=
0
|
|
!
filterValues
.
resize
(
filterCount
)
|
|
!
fixedFilterValues
.
resize
(
filterCount
)
)
{
return
false
;
}
float
filterSum
=
bitmapFilter
-
>
evaluate_n
(
destFilterDist
clampedScale
filterCount
filterValues
.
begin
(
)
)
;
Fixed
fixedSum
=
0
;
float
invFilterSum
=
1
.
0f
/
filterSum
;
for
(
int32_t
fixedI
=
0
;
fixedI
<
filterCount
;
fixedI
+
+
)
{
Fixed
curFixed
=
SkConvolutionFilter1D
:
:
FloatToFixed
(
filterValues
[
fixedI
]
*
invFilterSum
)
;
fixedSum
+
=
curFixed
;
fixedFilterValues
[
fixedI
]
=
curFixed
;
}
Fixed
leftovers
=
SkConvolutionFilter1D
:
:
FloatToFixed
(
1
)
-
fixedSum
;
fixedFilterValues
[
filterCount
/
2
]
+
=
leftovers
;
mFilter
-
>
AddFilter
(
int32_t
(
srcBegin
)
fixedFilterValues
.
begin
(
)
filterCount
)
;
}
return
mFilter
-
>
maxFilter
(
)
>
0
&
&
mFilter
-
>
numValues
(
)
=
=
aDstSize
;
}
}
