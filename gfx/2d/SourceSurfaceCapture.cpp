#
include
"
SourceSurfaceCapture
.
h
"
#
include
"
DrawCommand
.
h
"
#
include
"
DrawTargetCapture
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
namespace
mozilla
{
namespace
gfx
{
SourceSurfaceCapture
:
:
SourceSurfaceCapture
(
DrawTargetCaptureImpl
*
aOwner
)
:
mOwner
(
aOwner
)
mHasCommandList
(
false
)
mShouldResolveToLuminance
{
false
}
mLuminanceType
{
LuminanceType
:
:
LUMINANCE
}
mOpacity
{
1
.
0f
}
mLock
(
"
SourceSurfaceCapture
.
mLock
"
)
{
mSize
=
mOwner
-
>
GetSize
(
)
;
mFormat
=
mOwner
-
>
GetFormat
(
)
;
mRefDT
=
mOwner
-
>
mRefDT
;
mStride
=
mOwner
-
>
mStride
;
mSurfaceAllocationSize
=
mOwner
-
>
mSurfaceAllocationSize
;
}
SourceSurfaceCapture
:
:
SourceSurfaceCapture
(
DrawTargetCaptureImpl
*
aOwner
LuminanceType
aLuminanceType
Float
aOpacity
)
:
mOwner
{
aOwner
}
mHasCommandList
{
false
}
mShouldResolveToLuminance
{
true
}
mLuminanceType
{
aLuminanceType
}
mOpacity
{
aOpacity
}
mLock
{
"
SourceSurfaceCapture
.
mLock
"
}
{
mSize
=
mOwner
-
>
GetSize
(
)
;
mFormat
=
mOwner
-
>
GetFormat
(
)
;
mRefDT
=
mOwner
-
>
mRefDT
;
mStride
=
mOwner
-
>
mStride
;
mSurfaceAllocationSize
=
mOwner
-
>
mSurfaceAllocationSize
;
DrawTargetWillChange
(
)
;
}
SourceSurfaceCapture
:
:
SourceSurfaceCapture
(
DrawTargetCaptureImpl
*
aOwner
SourceSurface
*
aSurfToOptimize
)
:
mOwner
{
aOwner
}
mHasCommandList
{
false
}
mShouldResolveToLuminance
{
false
}
mLuminanceType
{
LuminanceType
:
:
LUMINANCE
}
mOpacity
{
1
.
0f
}
mLock
{
"
SourceSurfaceCapture
.
mLock
"
}
mSurfToOptimize
(
aSurfToOptimize
)
{
mSize
=
aSurfToOptimize
-
>
GetSize
(
)
;
mFormat
=
aSurfToOptimize
-
>
GetFormat
(
)
;
mRefDT
=
mOwner
-
>
mRefDT
;
}
SourceSurfaceCapture
:
:
~
SourceSurfaceCapture
(
)
{
}
bool
SourceSurfaceCapture
:
:
IsValid
(
)
const
{
MutexAutoLock
lock
(
mLock
)
;
return
(
mOwner
|
|
mHasCommandList
|
|
mSurfToOptimize
)
|
|
mResolved
;
}
RefPtr
<
SourceSurface
>
SourceSurfaceCapture
:
:
Resolve
(
BackendType
aBackendType
)
{
MutexAutoLock
lock
(
mLock
)
;
if
(
mSurfToOptimize
)
{
mResolved
=
mRefDT
-
>
OptimizeSourceSurface
(
mSurfToOptimize
)
;
mSurfToOptimize
=
nullptr
;
}
if
(
mResolved
|
|
(
!
mOwner
&
&
!
mHasCommandList
)
)
{
return
mResolved
;
}
BackendType
backendType
=
aBackendType
;
if
(
backendType
=
=
BackendType
:
:
NONE
)
{
backendType
=
mRefDT
-
>
GetBackendType
(
)
;
}
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
|
|
!
mOwner
)
;
mResolved
=
ResolveImpl
(
backendType
)
;
return
mResolved
;
}
RefPtr
<
SourceSurface
>
SourceSurfaceCapture
:
:
ResolveImpl
(
BackendType
aBackendType
)
{
RefPtr
<
DrawTarget
>
dt
;
uint8_t
*
data
=
nullptr
;
if
(
!
mSurfaceAllocationSize
)
{
if
(
aBackendType
=
=
mRefDT
-
>
GetBackendType
(
)
)
{
dt
=
mRefDT
-
>
CreateSimilarDrawTarget
(
mSize
mFormat
)
;
}
else
{
dt
=
Factory
:
:
CreateDrawTarget
(
aBackendType
mSize
mFormat
)
;
}
}
else
{
data
=
static_cast
<
uint8_t
*
>
(
calloc
(
1
mSurfaceAllocationSize
)
)
;
if
(
!
data
)
{
return
nullptr
;
}
BackendType
type
=
Factory
:
:
DoesBackendSupportDataDrawtarget
(
aBackendType
)
?
aBackendType
:
BackendType
:
:
SKIA
;
dt
=
Factory
:
:
CreateDrawTargetForData
(
type
data
mSize
mStride
mFormat
)
;
if
(
!
dt
|
|
!
dt
-
>
IsValid
(
)
)
{
free
(
data
)
;
return
nullptr
;
}
}
if
(
!
dt
|
|
!
dt
-
>
IsValid
(
)
)
{
MOZ_ASSERT
(
!
data
)
;
return
nullptr
;
}
CaptureCommandList
&
commands
=
mHasCommandList
?
mCommands
:
mOwner
-
>
mCommands
;
for
(
CaptureCommandList
:
:
iterator
iter
(
commands
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
DrawingCommand
*
cmd
=
iter
.
Get
(
)
;
cmd
-
>
ExecuteOnDT
(
dt
nullptr
)
;
}
RefPtr
<
SourceSurface
>
surf
;
if
(
!
mShouldResolveToLuminance
)
{
surf
=
dt
-
>
Snapshot
(
)
;
}
else
{
surf
=
dt
-
>
IntoLuminanceSource
(
mLuminanceType
mOpacity
)
;
}
if
(
data
)
{
surf
-
>
AddUserData
(
reinterpret_cast
<
UserDataKey
*
>
(
dt
.
get
(
)
)
data
free
)
;
}
return
surf
.
forget
(
)
;
}
already_AddRefed
<
DataSourceSurface
>
SourceSurfaceCapture
:
:
GetDataSurface
(
)
{
RefPtr
<
SourceSurface
>
surface
=
Resolve
(
)
;
if
(
!
surface
)
{
return
nullptr
;
}
return
surface
-
>
GetDataSurface
(
)
;
}
void
SourceSurfaceCapture
:
:
DrawTargetWillDestroy
(
)
{
MutexAutoLock
lock
(
mLock
)
;
mCommands
=
std
:
:
move
(
mOwner
-
>
mCommands
)
;
mHasCommandList
=
true
;
mOwner
=
nullptr
;
}
void
SourceSurfaceCapture
:
:
DrawTargetWillChange
(
)
{
MutexAutoLock
lock
(
mLock
)
;
for
(
CaptureCommandList
:
:
iterator
iter
(
mOwner
-
>
mCommands
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
DrawingCommand
*
cmd
=
iter
.
Get
(
)
;
cmd
-
>
CloneInto
(
&
mCommands
)
;
}
mHasCommandList
=
true
;
mOwner
=
nullptr
;
}
}
}
