#
ifndef
MOZILLA_GFX_USERDATA_H_
#
define
MOZILLA_GFX_USERDATA_H_
#
include
<
stdlib
.
h
>
#
include
"
Types
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
namespace
mozilla
{
namespace
gfx
{
struct
UserDataKey
{
int
unused
;
}
;
class
UserData
{
public
:
typedef
void
(
*
DestroyFunc
)
(
void
*
data
)
;
UserData
(
)
:
count
(
0
)
entries
(
nullptr
)
{
}
void
Add
(
UserDataKey
*
key
void
*
userData
DestroyFunc
destroy
)
{
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
key
=
=
entries
[
i
]
.
key
)
{
if
(
entries
[
i
]
.
destroy
)
{
entries
[
i
]
.
destroy
(
entries
[
i
]
.
userData
)
;
}
entries
[
i
]
.
userData
=
userData
;
entries
[
i
]
.
destroy
=
destroy
;
return
;
}
}
entries
=
static_cast
<
Entry
*
>
(
realloc
(
entries
sizeof
(
Entry
)
*
(
count
+
1
)
)
)
;
if
(
!
entries
)
{
MOZ_CRASH
(
"
GFX
:
UserData
:
:
Add
"
)
;
}
entries
[
count
]
.
key
=
key
;
entries
[
count
]
.
userData
=
userData
;
entries
[
count
]
.
destroy
=
destroy
;
count
+
+
;
}
void
*
Remove
(
UserDataKey
*
key
)
{
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
key
=
=
entries
[
i
]
.
key
)
{
void
*
userData
=
entries
[
i
]
.
userData
;
-
-
count
;
for
(
;
i
<
count
;
i
+
+
)
{
entries
[
i
]
=
entries
[
i
+
1
]
;
}
return
userData
;
}
}
return
nullptr
;
}
void
RemoveAndDestroy
(
UserDataKey
*
key
)
{
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
key
=
=
entries
[
i
]
.
key
)
{
if
(
entries
[
i
]
.
destroy
)
{
entries
[
i
]
.
destroy
(
entries
[
i
]
.
userData
)
;
}
-
-
count
;
for
(
;
i
<
count
;
i
+
+
)
{
entries
[
i
]
=
entries
[
i
+
1
]
;
}
}
}
}
void
*
Get
(
UserDataKey
*
key
)
const
{
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
key
=
=
entries
[
i
]
.
key
)
{
return
entries
[
i
]
.
userData
;
}
}
return
nullptr
;
}
bool
Has
(
UserDataKey
*
key
)
{
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
key
=
=
entries
[
i
]
.
key
)
{
return
true
;
}
}
return
false
;
}
void
Destroy
(
)
{
if
(
!
entries
)
{
return
;
}
for
(
int
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
entries
[
i
]
.
destroy
)
{
entries
[
i
]
.
destroy
(
entries
[
i
]
.
userData
)
;
}
}
free
(
entries
)
;
entries
=
nullptr
;
count
=
0
;
}
~
UserData
(
)
{
Destroy
(
)
;
}
private
:
struct
Entry
{
const
UserDataKey
*
key
;
void
*
userData
;
DestroyFunc
destroy
;
}
;
int
count
;
Entry
*
entries
;
}
;
class
ThreadSafeUserData
{
protected
:
struct
LockedUserData
:
public
UserData
{
Mutex
mLock
;
LockedUserData
(
)
:
mLock
(
"
LockedUserData
:
:
mLock
"
)
{
}
}
;
public
:
~
ThreadSafeUserData
(
)
{
if
(
LockedUserData
*
userData
=
mUserData
.
exchange
(
nullptr
)
)
{
{
MutexAutoLock
lock
(
userData
-
>
mLock
)
;
userData
-
>
Destroy
(
)
;
}
delete
userData
;
}
}
void
Add
(
UserDataKey
*
key
void
*
value
UserData
:
:
DestroyFunc
destroy
)
{
LockedUserData
*
userData
=
GetUserData
(
)
;
MutexAutoLock
lock
(
userData
-
>
mLock
)
;
userData
-
>
Add
(
key
value
destroy
)
;
}
void
*
Remove
(
UserDataKey
*
key
)
{
LockedUserData
*
userData
=
GetUserData
(
)
;
MutexAutoLock
lock
(
userData
-
>
mLock
)
;
return
userData
-
>
Remove
(
key
)
;
}
void
RemoveAndDestroy
(
UserDataKey
*
key
)
{
LockedUserData
*
userData
=
GetUserData
(
)
;
MutexAutoLock
lock
(
userData
-
>
mLock
)
;
userData
-
>
RemoveAndDestroy
(
key
)
;
}
void
*
Get
(
UserDataKey
*
key
)
const
{
LockedUserData
*
userData
=
GetUserData
(
)
;
MutexAutoLock
lock
(
userData
-
>
mLock
)
;
return
userData
-
>
Get
(
key
)
;
}
bool
Has
(
UserDataKey
*
key
)
{
LockedUserData
*
userData
=
GetUserData
(
)
;
MutexAutoLock
lock
(
userData
-
>
mLock
)
;
return
userData
-
>
Has
(
key
)
;
}
private
:
LockedUserData
*
GetUserData
(
)
const
{
LockedUserData
*
userData
=
mUserData
;
if
(
!
userData
)
{
userData
=
new
LockedUserData
;
if
(
!
mUserData
.
compareExchange
(
nullptr
userData
)
)
{
delete
userData
;
userData
=
mUserData
;
MOZ_ASSERT
(
userData
)
;
}
}
return
userData
;
}
mutable
Atomic
<
LockedUserData
*
>
mUserData
;
}
;
}
}
#
endif
