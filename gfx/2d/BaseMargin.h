#
ifndef
MOZILLA_GFX_BASEMARGIN_H_
#
define
MOZILLA_GFX_BASEMARGIN_H_
#
include
<
ostream
>
#
include
"
Types
.
h
"
namespace
mozilla
{
struct
Sides
final
{
Sides
(
)
:
mBits
(
SideBits
:
:
eNone
)
{
}
explicit
Sides
(
SideBits
aSideBits
)
{
MOZ_ASSERT
(
(
aSideBits
&
~
SideBits
:
:
eAll
)
=
=
SideBits
:
:
eNone
"
illegal
side
bits
"
)
;
mBits
=
aSideBits
;
}
bool
IsEmpty
(
)
const
{
return
mBits
=
=
SideBits
:
:
eNone
;
}
bool
Intersects
(
SideBits
aSideBits
)
const
{
return
bool
(
mBits
&
aSideBits
)
;
}
bool
Top
(
)
const
{
return
Intersects
(
SideBits
:
:
eTop
)
;
}
bool
Right
(
)
const
{
return
Intersects
(
SideBits
:
:
eRight
)
;
}
bool
Bottom
(
)
const
{
return
Intersects
(
SideBits
:
:
eBottom
)
;
}
bool
Left
(
)
const
{
return
Intersects
(
SideBits
:
:
eLeft
)
;
}
bool
Contains
(
SideBits
aSideBits
)
const
{
MOZ_ASSERT
(
!
(
aSideBits
&
~
SideBits
:
:
eAll
)
"
illegal
side
bits
"
)
;
return
(
mBits
&
aSideBits
)
=
=
aSideBits
;
}
Sides
operator
|
(
Sides
aOther
)
const
{
return
Sides
(
SideBits
(
mBits
|
aOther
.
mBits
)
)
;
}
Sides
operator
|
(
SideBits
aSideBits
)
const
{
return
*
this
|
Sides
(
aSideBits
)
;
}
Sides
&
operator
|
=
(
Sides
aOther
)
{
mBits
|
=
aOther
.
mBits
;
return
*
this
;
}
Sides
&
operator
|
=
(
SideBits
aSideBits
)
{
return
*
this
|
=
Sides
(
aSideBits
)
;
}
bool
operator
=
=
(
Sides
aOther
)
const
{
return
mBits
=
=
aOther
.
mBits
;
}
bool
operator
!
=
(
Sides
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
SideBits
mBits
;
}
;
namespace
gfx
{
template
<
class
T
class
Sub
class
Coord
=
T
>
struct
BaseMargin
{
typedef
mozilla
:
:
Side
SideT
;
Coord
top
right
bottom
left
;
constexpr
BaseMargin
(
)
:
top
(
0
)
right
(
0
)
bottom
(
0
)
left
(
0
)
{
}
constexpr
BaseMargin
(
Coord
aTop
Coord
aRight
Coord
aBottom
Coord
aLeft
)
:
top
(
aTop
)
right
(
aRight
)
bottom
(
aBottom
)
left
(
aLeft
)
{
}
void
SizeTo
(
Coord
aTop
Coord
aRight
Coord
aBottom
Coord
aLeft
)
{
top
=
aTop
;
right
=
aRight
;
bottom
=
aBottom
;
left
=
aLeft
;
}
Coord
LeftRight
(
)
const
{
return
left
+
right
;
}
Coord
TopBottom
(
)
const
{
return
top
+
bottom
;
}
Coord
&
Side
(
SideT
aSide
)
{
return
*
(
&
top
+
int
(
aSide
)
)
;
}
Coord
Side
(
SideT
aSide
)
const
{
return
*
(
&
top
+
int
(
aSide
)
)
;
}
Sub
&
ApplySkipSides
(
Sides
aSkipSides
)
{
if
(
aSkipSides
.
Top
(
)
)
{
top
=
0
;
}
if
(
aSkipSides
.
Right
(
)
)
{
right
=
0
;
}
if
(
aSkipSides
.
Bottom
(
)
)
{
bottom
=
0
;
}
if
(
aSkipSides
.
Left
(
)
)
{
left
=
0
;
}
return
*
static_cast
<
Sub
*
>
(
this
)
;
}
void
EnsureAtLeast
(
const
BaseMargin
&
aMargin
)
{
top
=
std
:
:
max
(
top
aMargin
.
top
)
;
right
=
std
:
:
max
(
right
aMargin
.
right
)
;
bottom
=
std
:
:
max
(
bottom
aMargin
.
bottom
)
;
left
=
std
:
:
max
(
left
aMargin
.
left
)
;
}
void
EnsureAtMost
(
const
BaseMargin
&
aMargin
)
{
top
=
std
:
:
min
(
top
aMargin
.
top
)
;
right
=
std
:
:
min
(
right
aMargin
.
right
)
;
bottom
=
std
:
:
min
(
bottom
aMargin
.
bottom
)
;
left
=
std
:
:
min
(
left
aMargin
.
left
)
;
}
bool
IsAll
(
Coord
aCoord
)
const
{
return
left
=
=
aCoord
&
&
top
=
=
aCoord
&
&
right
=
=
aCoord
&
&
bottom
=
=
aCoord
;
}
bool
IsAllZero
(
)
const
{
return
IsAll
(
0
)
;
}
bool
IsAllEqual
(
)
const
{
return
IsAll
(
top
)
;
}
bool
operator
=
=
(
const
Sub
&
aMargin
)
const
{
return
top
=
=
aMargin
.
top
&
&
right
=
=
aMargin
.
right
&
&
bottom
=
=
aMargin
.
bottom
&
&
left
=
=
aMargin
.
left
;
}
bool
operator
!
=
(
const
Sub
&
aMargin
)
const
{
return
!
(
*
this
=
=
aMargin
)
;
}
Sub
operator
+
(
const
Sub
&
aMargin
)
const
{
return
Sub
(
top
+
aMargin
.
top
right
+
aMargin
.
right
bottom
+
aMargin
.
bottom
left
+
aMargin
.
left
)
;
}
Sub
operator
-
(
const
Sub
&
aMargin
)
const
{
return
Sub
(
top
-
aMargin
.
top
right
-
aMargin
.
right
bottom
-
aMargin
.
bottom
left
-
aMargin
.
left
)
;
}
Sub
operator
-
(
)
const
{
return
Sub
(
-
top
-
right
-
bottom
-
left
)
;
}
Sub
&
operator
+
=
(
const
Sub
&
aMargin
)
{
top
+
=
aMargin
.
top
;
right
+
=
aMargin
.
right
;
bottom
+
=
aMargin
.
bottom
;
left
+
=
aMargin
.
left
;
return
*
static_cast
<
Sub
*
>
(
this
)
;
}
Sub
&
operator
-
=
(
const
Sub
&
aMargin
)
{
top
-
=
aMargin
.
top
;
right
-
=
aMargin
.
right
;
bottom
-
=
aMargin
.
bottom
;
left
-
=
aMargin
.
left
;
return
*
static_cast
<
Sub
*
>
(
this
)
;
}
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
BaseMargin
&
aMargin
)
{
return
aStream
<
<
"
(
t
=
"
<
<
aMargin
.
top
<
<
"
r
=
"
<
<
aMargin
.
right
<
<
"
b
=
"
<
<
aMargin
.
bottom
<
<
"
l
=
"
<
<
aMargin
.
left
<
<
'
)
'
;
}
}
;
}
}
#
endif
