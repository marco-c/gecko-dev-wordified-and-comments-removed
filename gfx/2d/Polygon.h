#
ifndef
MOZILLA_GFX_POLYGON_H
#
define
MOZILLA_GFX_POLYGON_H
#
include
"
mozilla
/
InitializerList
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
Point
.
h
"
namespace
mozilla
{
namespace
gfx
{
template
<
class
Units
>
class
BasePolygon3D
{
public
:
explicit
BasePolygon3D
(
const
std
:
:
initializer_list
<
Point3DTyped
<
Units
>
>
&
aPoints
)
:
mPoints
(
aPoints
)
{
CalculateNormal
(
)
;
}
explicit
BasePolygon3D
(
nsTArray
<
Point3DTyped
<
Units
>
>
&
&
aPoints
)
:
mPoints
(
aPoints
)
{
CalculateNormal
(
)
;
}
const
Point3DTyped
<
Units
>
&
GetNormal
(
)
const
{
return
mNormal
;
}
const
nsTArray
<
Point3D
>
&
GetPoints
(
)
const
{
return
mPoints
;
}
const
Point3DTyped
<
Units
>
&
operator
[
]
(
size_t
aIndex
)
const
{
MOZ_ASSERT
(
mPoints
.
Length
(
)
>
aIndex
)
;
return
mPoints
[
aIndex
]
;
}
private
:
void
CalculateNormal
(
)
{
MOZ_ASSERT
(
mPoints
.
Length
(
)
>
=
3
)
;
mNormal
=
(
mPoints
[
1
]
-
mPoints
[
0
]
)
.
CrossProduct
(
mPoints
[
2
]
-
mPoints
[
0
]
)
;
const
float
epsilon
=
0
.
001f
;
if
(
mNormal
.
Length
(
)
<
epsilon
)
{
for
(
size_t
i
=
2
;
i
<
mPoints
.
Length
(
)
-
1
;
+
+
i
)
{
mNormal
+
=
(
mPoints
[
i
]
-
mPoints
[
0
]
)
.
CrossProduct
(
mPoints
[
i
+
1
]
-
mPoints
[
0
]
)
;
}
}
mNormal
.
Normalize
(
)
;
#
ifdef
DEBUG
for
(
const
gfx
:
:
Point3DTyped
<
Units
>
&
point
:
mPoints
)
{
float
d
=
mNormal
.
DotProduct
(
point
-
mPoints
[
0
]
)
;
MOZ_ASSERT
(
std
:
:
abs
(
d
)
<
epsilon
)
;
}
#
endif
}
nsTArray
<
Point3DTyped
<
Units
>
>
mPoints
;
Point3DTyped
<
Units
>
mNormal
;
}
;
typedef
BasePolygon3D
<
UnknownUnits
>
Polygon3D
;
}
}
#
endif
