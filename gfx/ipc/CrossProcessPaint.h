#
ifndef
_include_mozilla_gfx_ipc_CrossProcessPaint_h_
#
define
_include_mozilla_gfx_ipc_CrossProcessPaint_h_
#
include
"
nsISupportsImpl
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
IdType
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
RecordedEvent
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
ipc
/
ByteBuf
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsTHashtable
.
h
"
class
nsIDocShell
;
namespace
IPC
{
template
<
typename
T
>
struct
ParamTraits
;
}
namespace
mozilla
{
namespace
dom
{
class
DOMRect
;
class
Promise
;
class
WindowGlobalParent
;
}
namespace
gfx
{
class
CrossProcessPaint
;
enum
class
CrossProcessPaintFlags
{
None
=
0
DrawView
=
1
<
<
1
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
CrossProcessPaintFlags
)
class
PaintFragment
final
{
public
:
PaintFragment
(
)
=
default
;
static
PaintFragment
Record
(
nsIDocShell
*
aDocShell
const
Maybe
<
IntRect
>
&
aRect
float
aScale
nscolor
aBackgroundColor
CrossProcessPaintFlags
aFlags
)
;
bool
IsEmpty
(
)
const
;
PaintFragment
(
PaintFragment
&
&
)
=
default
;
PaintFragment
&
operator
=
(
PaintFragment
&
&
)
=
default
;
protected
:
friend
struct
mozilla
:
:
ipc
:
:
IPDLParamTraits
<
PaintFragment
>
;
friend
CrossProcessPaint
;
typedef
mozilla
:
:
ipc
:
:
ByteBuf
ByteBuf
;
PaintFragment
(
IntSize
ByteBuf
&
&
nsTHashtable
<
nsUint64HashKey
>
&
&
)
;
IntSize
mSize
;
ByteBuf
mRecording
;
nsTHashtable
<
nsUint64HashKey
>
mDependencies
;
}
;
class
CrossProcessPaint
final
{
NS_INLINE_DECL_REFCOUNTING
(
CrossProcessPaint
)
;
public
:
typedef
nsRefPtrHashtable
<
nsUint64HashKey
RecordedDependentSurface
>
ResolvedFragmentMap
;
typedef
MozPromise
<
ResolvedFragmentMap
nsresult
true
>
ResolvePromise
;
static
bool
Start
(
dom
:
:
WindowGlobalParent
*
aRoot
const
dom
:
:
DOMRect
*
aRect
float
aScale
nscolor
aBackgroundColor
CrossProcessPaintFlags
aFlags
dom
:
:
Promise
*
aPromise
)
;
static
RefPtr
<
ResolvePromise
>
Start
(
nsTHashtable
<
nsUint64HashKey
>
&
&
aDependencies
)
;
void
ReceiveFragment
(
dom
:
:
WindowGlobalParent
*
aWGP
PaintFragment
&
&
aFragment
)
;
void
LostFragment
(
dom
:
:
WindowGlobalParent
*
aWGP
)
;
private
:
typedef
nsDataHashtable
<
nsUint64HashKey
PaintFragment
>
ReceivedFragmentMap
;
CrossProcessPaint
(
float
aScale
dom
:
:
TabId
aRoot
)
;
~
CrossProcessPaint
(
)
;
void
QueueDependencies
(
const
nsTHashtable
<
nsUint64HashKey
>
&
aDependencies
)
;
void
QueuePaint
(
dom
:
:
WindowGlobalParent
*
aWGP
const
Maybe
<
IntRect
>
&
aRect
nscolor
aBackgroundColor
=
NS_RGBA
(
0
0
0
0
)
CrossProcessPaintFlags
aFlags
=
CrossProcessPaintFlags
:
:
DrawView
)
;
void
Clear
(
nsresult
aStatus
)
;
bool
IsCleared
(
)
const
;
void
MaybeResolve
(
)
;
nsresult
ResolveInternal
(
dom
:
:
TabId
aTabId
ResolvedFragmentMap
*
aResolved
)
;
RefPtr
<
ResolvePromise
>
Init
(
)
{
MOZ_ASSERT
(
mPromise
.
IsEmpty
(
)
)
;
return
mPromise
.
Ensure
(
__func__
)
;
}
MozPromiseHolder
<
ResolvePromise
>
mPromise
;
dom
:
:
TabId
mRoot
;
float
mScale
;
uint32_t
mPendingFragments
;
ReceivedFragmentMap
mReceivedFragments
;
}
;
}
}
#
endif
