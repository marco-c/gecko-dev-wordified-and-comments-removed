#
ifndef
_include_mozilla_gfx_ipc_CrossProcessPaint_h_
#
define
_include_mozilla_gfx_ipc_CrossProcessPaint_h_
#
include
"
nsISupportsImpl
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
IdType
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
DOMRect
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ipc
/
ByteBuf
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsTHashtable
.
h
"
namespace
IPC
{
template
<
typename
T
>
struct
ParamTraits
;
}
namespace
mozilla
{
namespace
dom
{
class
WindowGlobalParent
;
}
namespace
gfx
{
class
CrossProcessPaint
;
class
PaintFragment
final
{
public
:
PaintFragment
(
)
=
default
;
static
PaintFragment
Record
(
nsIDocShell
*
aDocShell
const
Maybe
<
IntRect
>
&
aRect
float
aScale
nscolor
aBackgroundColor
)
;
bool
IsEmpty
(
)
const
;
PaintFragment
(
PaintFragment
&
&
)
=
default
;
PaintFragment
&
operator
=
(
PaintFragment
&
&
)
=
default
;
protected
:
friend
struct
IPC
:
:
ParamTraits
<
PaintFragment
>
;
friend
CrossProcessPaint
;
typedef
mozilla
:
:
ipc
:
:
ByteBuf
ByteBuf
;
PaintFragment
(
IntSize
ByteBuf
&
&
nsTHashtable
<
nsUint64HashKey
>
&
&
)
;
IntSize
mSize
;
ByteBuf
mRecording
;
nsTHashtable
<
nsUint64HashKey
>
mDependencies
;
}
;
class
CrossProcessPaint
final
{
NS_INLINE_DECL_REFCOUNTING
(
CrossProcessPaint
)
;
public
:
static
bool
Start
(
dom
:
:
WindowGlobalParent
*
aRoot
const
dom
:
:
DOMRect
*
aRect
float
aScale
nscolor
aBackgroundColor
dom
:
:
Promise
*
aPromise
)
;
void
ReceiveFragment
(
dom
:
:
WindowGlobalParent
*
aWGP
PaintFragment
&
&
aFragment
)
;
void
LostFragment
(
dom
:
:
WindowGlobalParent
*
aWGP
)
;
private
:
typedef
nsRefPtrHashtable
<
nsUint64HashKey
SourceSurface
>
ResolvedSurfaceMap
;
typedef
nsDataHashtable
<
nsUint64HashKey
PaintFragment
>
ReceivedFragmentMap
;
CrossProcessPaint
(
dom
:
:
Promise
*
aPromise
float
aScale
dom
:
:
WindowGlobalParent
*
aRoot
)
;
~
CrossProcessPaint
(
)
;
void
QueuePaint
(
dom
:
:
WindowGlobalParent
*
aWGP
const
Maybe
<
IntRect
>
&
aRect
nscolor
aBackgroundColor
=
NS_RGBA
(
0
0
0
0
)
)
;
void
Clear
(
)
;
bool
IsCleared
(
)
const
;
void
MaybeResolve
(
)
;
nsresult
ResolveInternal
(
dom
:
:
TabId
aTabId
ResolvedSurfaceMap
*
aResolved
)
;
RefPtr
<
dom
:
:
Promise
>
mPromise
;
RefPtr
<
dom
:
:
WindowGlobalParent
>
mRoot
;
float
mScale
;
uint32_t
mPendingFragments
;
ReceivedFragmentMap
mReceivedFragments
;
}
;
}
}
#
endif
