#
include
"
GPUChild
.
h
"
#
include
"
gfxConfig
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
GPUProcessHost
.
h
"
#
include
"
GPUProcessManager
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TelemetryIPC
.
h
"
#
include
"
mozilla
/
dom
/
CheckerboardReportService
.
h
"
#
include
"
mozilla
/
dom
/
MemoryReportRequest
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
mozilla
/
gfx
/
DeviceManagerDx
.
h
"
#
endif
#
include
"
mozilla
/
ipc
/
CrashReporterHost
.
h
"
#
include
"
mozilla
/
layers
/
LayerTreeOwnerTracker
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
ifdef
MOZ_GECKO_PROFILER
#
include
"
ProfilerParent
.
h
"
#
endif
namespace
mozilla
{
namespace
gfx
{
using
namespace
layers
;
GPUChild
:
:
GPUChild
(
GPUProcessHost
*
aHost
)
:
mHost
(
aHost
)
mGPUReady
(
false
)
{
MOZ_COUNT_CTOR
(
GPUChild
)
;
}
GPUChild
:
:
~
GPUChild
(
)
{
MOZ_COUNT_DTOR
(
GPUChild
)
;
}
void
GPUChild
:
:
Init
(
)
{
nsTArray
<
GfxPrefSetting
>
prefs
;
for
(
auto
pref
:
gfxPrefs
:
:
all
(
)
)
{
if
(
pref
-
>
HasDefaultValue
(
)
)
{
continue
;
}
GfxPrefValue
value
;
pref
-
>
GetCachedValue
(
&
value
)
;
prefs
.
AppendElement
(
GfxPrefSetting
(
pref
-
>
Index
(
)
value
)
)
;
}
nsTArray
<
GfxVarUpdate
>
updates
=
gfxVars
:
:
FetchNonDefaultVars
(
)
;
DevicePrefs
devicePrefs
;
devicePrefs
.
hwCompositing
(
)
=
gfxConfig
:
:
GetValue
(
Feature
:
:
HW_COMPOSITING
)
;
devicePrefs
.
d3d11Compositing
(
)
=
gfxConfig
:
:
GetValue
(
Feature
:
:
D3D11_COMPOSITING
)
;
devicePrefs
.
oglCompositing
(
)
=
gfxConfig
:
:
GetValue
(
Feature
:
:
OPENGL_COMPOSITING
)
;
devicePrefs
.
useD2D1
(
)
=
gfxConfig
:
:
GetValue
(
Feature
:
:
DIRECT2D
)
;
nsTArray
<
LayerTreeIdMapping
>
mappings
;
LayerTreeOwnerTracker
:
:
Get
(
)
-
>
Iterate
(
[
&
]
(
uint64_t
aLayersId
base
:
:
ProcessId
aProcessId
)
{
mappings
.
AppendElement
(
LayerTreeIdMapping
(
aLayersId
aProcessId
)
)
;
}
)
;
SendInit
(
prefs
updates
devicePrefs
mappings
)
;
gfxVars
:
:
AddReceiver
(
this
)
;
#
ifdef
MOZ_GECKO_PROFILER
Unused
<
<
SendInitProfiler
(
ProfilerParent
:
:
CreateForProcess
(
OtherPid
(
)
)
)
;
#
endif
}
void
GPUChild
:
:
OnVarChanged
(
const
GfxVarUpdate
&
aVar
)
{
SendUpdateVar
(
aVar
)
;
}
bool
GPUChild
:
:
EnsureGPUReady
(
)
{
if
(
mGPUReady
)
{
return
true
;
}
GPUDeviceData
data
;
if
(
!
SendGetDeviceStatus
(
&
data
)
)
{
return
false
;
}
gfxPlatform
:
:
GetPlatform
(
)
-
>
ImportGPUDeviceData
(
data
)
;
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
GPU_PROCESS_LAUNCH_TIME_MS_2
mHost
-
>
GetLaunchTime
(
)
)
;
mGPUReady
=
true
;
return
true
;
}
mozilla
:
:
ipc
:
:
IPCResult
GPUChild
:
:
RecvInitComplete
(
const
GPUDeviceData
&
aData
)
{
if
(
mGPUReady
)
{
return
IPC_OK
(
)
;
}
gfxPlatform
:
:
GetPlatform
(
)
-
>
ImportGPUDeviceData
(
aData
)
;
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
GPU_PROCESS_LAUNCH_TIME_MS_2
mHost
-
>
GetLaunchTime
(
)
)
;
mGPUReady
=
true
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
GPUChild
:
:
RecvReportCheckerboard
(
const
uint32_t
&
aSeverity
const
nsCString
&
aLog
)
{
layers
:
:
CheckerboardEventStorage
:
:
Report
(
aSeverity
std
:
:
string
(
aLog
.
get
(
)
)
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
GPUChild
:
:
RecvGraphicsError
(
const
nsCString
&
aError
)
{
gfx
:
:
LogForwarder
*
lf
=
gfx
:
:
Factory
:
:
GetLogForwarder
(
)
;
if
(
lf
)
{
std
:
:
stringstream
message
;
message
<
<
"
GP
+
"
<
<
aError
.
get
(
)
;
lf
-
>
UpdateStringsVector
(
message
.
str
(
)
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
GPUChild
:
:
RecvInitCrashReporter
(
Shmem
&
&
aShmem
const
NativeThreadId
&
aThreadId
)
{
#
ifdef
MOZ_CRASHREPORTER
mCrashReporter
=
MakeUnique
<
ipc
:
:
CrashReporterHost
>
(
GeckoProcessType_GPU
aShmem
aThreadId
)
;
#
endif
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
GPUChild
:
:
RecvNotifyUiObservers
(
const
nsCString
&
aTopic
)
{
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
obsSvc
)
;
if
(
obsSvc
)
{
obsSvc
-
>
NotifyObservers
(
nullptr
aTopic
.
get
(
)
nullptr
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
GPUChild
:
:
RecvAccumulateChildHistograms
(
InfallibleTArray
<
Accumulation
>
&
&
aAccumulations
)
{
TelemetryIPC
:
:
AccumulateChildHistograms
(
Telemetry
:
:
ProcessID
:
:
Gpu
aAccumulations
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
GPUChild
:
:
RecvAccumulateChildKeyedHistograms
(
InfallibleTArray
<
KeyedAccumulation
>
&
&
aAccumulations
)
{
TelemetryIPC
:
:
AccumulateChildKeyedHistograms
(
Telemetry
:
:
ProcessID
:
:
Gpu
aAccumulations
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
GPUChild
:
:
RecvUpdateChildScalars
(
InfallibleTArray
<
ScalarAction
>
&
&
aScalarActions
)
{
TelemetryIPC
:
:
UpdateChildScalars
(
Telemetry
:
:
ProcessID
:
:
Gpu
aScalarActions
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
GPUChild
:
:
RecvUpdateChildKeyedScalars
(
InfallibleTArray
<
KeyedScalarAction
>
&
&
aScalarActions
)
{
TelemetryIPC
:
:
UpdateChildKeyedScalars
(
Telemetry
:
:
ProcessID
:
:
Gpu
aScalarActions
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
GPUChild
:
:
RecvRecordChildEvents
(
nsTArray
<
mozilla
:
:
Telemetry
:
:
ChildEventData
>
&
&
aEvents
)
{
TelemetryIPC
:
:
RecordChildEvents
(
Telemetry
:
:
ProcessID
:
:
Gpu
aEvents
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
GPUChild
:
:
RecvNotifyDeviceReset
(
const
GPUDeviceData
&
aData
)
{
gfxPlatform
:
:
GetPlatform
(
)
-
>
ImportGPUDeviceData
(
aData
)
;
mHost
-
>
mListener
-
>
OnRemoteProcessDeviceReset
(
mHost
)
;
return
IPC_OK
(
)
;
}
bool
GPUChild
:
:
SendRequestMemoryReport
(
const
uint32_t
&
aGeneration
const
bool
&
aAnonymize
const
bool
&
aMinimizeMemoryUsage
const
MaybeFileDesc
&
aDMDFile
)
{
mMemoryReportRequest
=
MakeUnique
<
MemoryReportRequestHost
>
(
aGeneration
)
;
Unused
<
<
PGPUChild
:
:
SendRequestMemoryReport
(
aGeneration
aAnonymize
aMinimizeMemoryUsage
aDMDFile
)
;
return
true
;
}
mozilla
:
:
ipc
:
:
IPCResult
GPUChild
:
:
RecvAddMemoryReport
(
const
MemoryReport
&
aReport
)
{
if
(
mMemoryReportRequest
)
{
mMemoryReportRequest
-
>
RecvReport
(
aReport
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
GPUChild
:
:
RecvFinishMemoryReport
(
const
uint32_t
&
aGeneration
)
{
if
(
mMemoryReportRequest
)
{
mMemoryReportRequest
-
>
Finish
(
aGeneration
)
;
mMemoryReportRequest
=
nullptr
;
}
return
IPC_OK
(
)
;
}
void
GPUChild
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
if
(
aWhy
=
=
AbnormalShutdown
)
{
#
ifdef
MOZ_CRASHREPORTER
if
(
mCrashReporter
)
{
mCrashReporter
-
>
GenerateCrashReport
(
OtherPid
(
)
)
;
mCrashReporter
=
nullptr
;
}
#
endif
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SUBPROCESS_ABNORMAL_ABORT
nsDependentCString
(
XRE_ChildProcessTypeToString
(
GeckoProcessType_GPU
)
)
1
)
;
if
(
nsCOMPtr
<
nsIObserverService
>
obsvc
=
services
:
:
GetObserverService
(
)
)
{
obsvc
-
>
NotifyObservers
(
nullptr
"
compositor
:
process
-
aborted
"
nullptr
)
;
}
}
gfxVars
:
:
RemoveReceiver
(
this
)
;
mHost
-
>
OnChannelClosed
(
)
;
}
class
DeferredDeleteGPUChild
:
public
Runnable
{
public
:
explicit
DeferredDeleteGPUChild
(
UniquePtr
<
GPUChild
>
&
&
aChild
)
:
mChild
(
Move
(
aChild
)
)
{
}
NS_IMETHODIMP
Run
(
)
override
{
return
NS_OK
;
}
private
:
UniquePtr
<
GPUChild
>
mChild
;
}
;
void
GPUChild
:
:
Destroy
(
UniquePtr
<
GPUChild
>
&
&
aChild
)
{
NS_DispatchToMainThread
(
new
DeferredDeleteGPUChild
(
Move
(
aChild
)
)
)
;
}
}
}
