#
include
"
GPUProcessHost
.
h
"
#
include
"
chrome
/
common
/
process_watcher
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
nsITimer
.
h
"
namespace
mozilla
{
namespace
gfx
{
using
namespace
ipc
;
GPUProcessHost
:
:
GPUProcessHost
(
Listener
*
aListener
)
:
GeckoChildProcessHost
(
GeckoProcessType_GPU
)
mListener
(
aListener
)
mTaskFactory
(
this
)
mLaunchPhase
(
LaunchPhase
:
:
Unlaunched
)
mProcessToken
(
0
)
mShutdownRequested
(
false
)
mChannelClosed
(
false
)
{
MOZ_COUNT_CTOR
(
GPUProcessHost
)
;
}
GPUProcessHost
:
:
~
GPUProcessHost
(
)
{
MOZ_COUNT_DTOR
(
GPUProcessHost
)
;
}
bool
GPUProcessHost
:
:
Launch
(
)
{
MOZ_ASSERT
(
mLaunchPhase
=
=
LaunchPhase
:
:
Unlaunched
)
;
MOZ_ASSERT
(
!
mGPUChild
)
;
mLaunchPhase
=
LaunchPhase
:
:
Waiting
;
if
(
!
GeckoChildProcessHost
:
:
AsyncLaunch
(
)
)
{
mLaunchPhase
=
LaunchPhase
:
:
Complete
;
return
false
;
}
return
true
;
}
bool
GPUProcessHost
:
:
WaitForLaunch
(
)
{
if
(
mLaunchPhase
=
=
LaunchPhase
:
:
Complete
)
{
return
!
!
mGPUChild
;
}
int32_t
timeoutMs
=
gfxPrefs
:
:
GPUProcessDevTimeoutMs
(
)
;
bool
result
=
GeckoChildProcessHost
:
:
WaitUntilConnected
(
timeoutMs
)
;
InitAfterConnect
(
result
)
;
return
result
;
}
void
GPUProcessHost
:
:
OnChannelConnected
(
int32_t
peer_pid
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
GeckoChildProcessHost
:
:
OnChannelConnected
(
peer_pid
)
;
RefPtr
<
Runnable
>
runnable
;
{
MonitorAutoLock
lock
(
mMonitor
)
;
runnable
=
mTaskFactory
.
NewRunnableMethod
(
&
GPUProcessHost
:
:
OnChannelConnectedTask
)
;
}
NS_DispatchToMainThread
(
runnable
)
;
}
void
GPUProcessHost
:
:
OnChannelError
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
GeckoChildProcessHost
:
:
OnChannelError
(
)
;
RefPtr
<
Runnable
>
runnable
;
{
MonitorAutoLock
lock
(
mMonitor
)
;
runnable
=
mTaskFactory
.
NewRunnableMethod
(
&
GPUProcessHost
:
:
OnChannelErrorTask
)
;
}
NS_DispatchToMainThread
(
runnable
)
;
}
void
GPUProcessHost
:
:
OnChannelConnectedTask
(
)
{
if
(
mLaunchPhase
=
=
LaunchPhase
:
:
Waiting
)
{
InitAfterConnect
(
true
)
;
}
}
void
GPUProcessHost
:
:
OnChannelErrorTask
(
)
{
if
(
mLaunchPhase
=
=
LaunchPhase
:
:
Waiting
)
{
InitAfterConnect
(
false
)
;
}
}
static
uint64_t
sProcessTokenCounter
=
0
;
void
GPUProcessHost
:
:
InitAfterConnect
(
bool
aSucceeded
)
{
MOZ_ASSERT
(
mLaunchPhase
=
=
LaunchPhase
:
:
Waiting
)
;
MOZ_ASSERT
(
!
mGPUChild
)
;
mLaunchPhase
=
LaunchPhase
:
:
Complete
;
if
(
aSucceeded
)
{
mProcessToken
=
+
+
sProcessTokenCounter
;
mGPUChild
=
MakeUnique
<
GPUChild
>
(
this
)
;
DebugOnly
<
bool
>
rv
=
mGPUChild
-
>
Open
(
GetChannel
(
)
base
:
:
GetProcId
(
GetChildProcessHandle
(
)
)
)
;
MOZ_ASSERT
(
rv
)
;
mGPUChild
-
>
Init
(
)
;
}
if
(
mListener
)
{
mListener
-
>
OnProcessLaunchComplete
(
this
)
;
}
}
void
GPUProcessHost
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
!
mShutdownRequested
)
;
mListener
=
nullptr
;
if
(
mGPUChild
)
{
mShutdownRequested
=
true
;
#
ifdef
NS_FREE_PERMANENT_DATA
if
(
!
mChannelClosed
)
{
mGPUChild
-
>
Close
(
)
;
}
#
else
KillHard
(
"
NormalShutdown
"
)
;
#
endif
return
;
}
DestroyProcess
(
)
;
}
void
GPUProcessHost
:
:
OnChannelClosed
(
)
{
if
(
!
mShutdownRequested
)
{
mChannelClosed
=
true
;
if
(
mListener
)
{
mListener
-
>
OnProcessUnexpectedShutdown
(
this
)
;
}
}
GPUChild
:
:
Destroy
(
Move
(
mGPUChild
)
)
;
MOZ_ASSERT
(
!
mGPUChild
)
;
if
(
mShutdownRequested
)
{
DestroyProcess
(
)
;
}
}
void
GPUProcessHost
:
:
KillHard
(
const
char
*
aReason
)
{
ProcessHandle
handle
=
GetChildProcessHandle
(
)
;
if
(
!
base
:
:
KillProcess
(
handle
base
:
:
PROCESS_END_KILLED_BY_USER
false
)
)
{
NS_WARNING
(
"
failed
to
kill
subprocess
!
"
)
;
}
SetAlreadyDead
(
)
;
}
uint64_t
GPUProcessHost
:
:
GetProcessToken
(
)
const
{
return
mProcessToken
;
}
static
void
DelayedDeleteSubprocess
(
GeckoChildProcessHost
*
aSubprocess
)
{
XRE_GetIOMessageLoop
(
)
-
>
PostTask
(
mozilla
:
:
MakeAndAddRef
<
DeleteTask
<
GeckoChildProcessHost
>
>
(
aSubprocess
)
)
;
}
void
GPUProcessHost
:
:
DestroyProcess
(
)
{
{
MonitorAutoLock
lock
(
mMonitor
)
;
mTaskFactory
.
RevokeAll
(
)
;
}
MessageLoop
:
:
current
(
)
-
>
PostTask
(
NewRunnableFunction
(
DelayedDeleteSubprocess
this
)
)
;
}
}
}
