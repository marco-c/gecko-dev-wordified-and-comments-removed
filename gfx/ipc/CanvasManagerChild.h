#
ifndef
_include_gfx_ipc_CanvasManagerChild_h__
#
define
_include_gfx_ipc_CanvasManagerChild_h__
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
gfx
/
PCanvasManagerChild
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
<
set
>
namespace
mozilla
{
namespace
dom
{
class
CanvasRenderingContext2D
;
class
ThreadSafeWorkerRef
;
class
WorkerPrivate
;
}
namespace
layers
{
class
CanvasChild
;
class
ActiveResourceTracker
;
}
namespace
webgpu
{
class
WebGPUChild
;
}
namespace
gfx
{
class
DataSourceSurface
;
class
CanvasManagerChild
final
:
public
PCanvasManagerChild
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
CanvasManagerChild
override
)
;
explicit
CanvasManagerChild
(
uint32_t
aId
)
;
uint32_t
Id
(
)
const
{
return
mId
;
}
already_AddRefed
<
DataSourceSurface
>
GetSnapshot
(
uint32_t
aManagerId
int32_t
aProtocolId
const
Maybe
<
RemoteTextureOwnerId
>
&
aOwnerId
SurfaceFormat
aFormat
bool
aPremultiply
bool
aYFlip
)
;
void
ActorDestroy
(
ActorDestroyReason
aReason
)
override
;
static
CanvasManagerChild
*
Get
(
)
;
static
CanvasManagerChild
*
MaybeGet
(
)
;
static
void
Shutdown
(
)
;
static
bool
CreateParent
(
mozilla
:
:
ipc
:
:
Endpoint
<
PCanvasManagerParent
>
&
&
aEndpoint
)
;
void
AddShutdownObserver
(
dom
:
:
CanvasRenderingContext2D
*
aCanvas
)
;
void
RemoveShutdownObserver
(
dom
:
:
CanvasRenderingContext2D
*
aCanvas
)
;
bool
IsCanvasActive
(
)
{
return
mActive
;
}
void
EndCanvasTransaction
(
)
;
void
ClearCachedResources
(
)
;
void
DeactivateCanvas
(
)
;
void
BlockCanvas
(
)
;
RefPtr
<
layers
:
:
CanvasChild
>
GetCanvasChild
(
)
;
RefPtr
<
webgpu
:
:
WebGPUChild
>
GetWebGPUChild
(
)
;
layers
:
:
ActiveResourceTracker
*
GetActiveResourceTracker
(
)
;
private
:
~
CanvasManagerChild
(
)
;
void
DestroyInternal
(
)
;
void
Destroy
(
)
;
RefPtr
<
mozilla
:
:
dom
:
:
ThreadSafeWorkerRef
>
mWorkerRef
;
RefPtr
<
layers
:
:
CanvasChild
>
mCanvasChild
;
UniquePtr
<
layers
:
:
ActiveResourceTracker
>
mActiveResourceTracker
;
std
:
:
set
<
dom
:
:
CanvasRenderingContext2D
*
>
mActiveCanvas
;
const
uint32_t
mId
;
bool
mActive
=
true
;
bool
mBlocked
=
false
;
static
MOZ_THREAD_LOCAL
(
CanvasManagerChild
*
)
sLocalManager
;
static
Atomic
<
uint32_t
>
sNextId
;
}
;
}
}
#
endif
