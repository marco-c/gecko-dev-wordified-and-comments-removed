#
include
"
CanvasManagerParent
.
h
"
#
include
"
mozilla
/
dom
/
WebGLParent
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
ipc
/
Endpoint
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
webgpu
/
WebGPUParent
.
h
"
#
include
"
mozilla
/
webrender
/
RenderThread
.
h
"
#
include
"
nsIThread
.
h
"
namespace
mozilla
:
:
gfx
{
CanvasManagerParent
:
:
ManagerSet
CanvasManagerParent
:
:
sManagers
;
void
CanvasManagerParent
:
:
Init
(
Endpoint
<
PCanvasManagerParent
>
&
&
aEndpoint
)
{
MOZ_ASSERT
(
layers
:
:
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
auto
manager
=
MakeRefPtr
<
CanvasManagerParent
>
(
)
;
if
(
gfxVars
:
:
SupportsThreadsafeGL
(
)
)
{
manager
-
>
Bind
(
std
:
:
move
(
aEndpoint
)
)
;
}
else
{
nsCOMPtr
<
nsIThread
>
owningThread
;
owningThread
=
wr
:
:
RenderThread
:
:
GetRenderThread
(
)
;
MOZ_ASSERT
(
owningThread
)
;
owningThread
-
>
Dispatch
(
NewRunnableMethod
<
Endpoint
<
PCanvasManagerParent
>
&
&
>
(
"
CanvasManagerParent
:
:
Bind
"
manager
&
CanvasManagerParent
:
:
Bind
std
:
:
move
(
aEndpoint
)
)
)
;
}
}
void
CanvasManagerParent
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsISerialEventTarget
>
owningThread
;
if
(
gfxVars
:
:
SupportsThreadsafeGL
(
)
)
{
owningThread
=
layers
:
:
CompositorThread
(
)
;
}
else
{
owningThread
=
wr
:
:
RenderThread
:
:
GetRenderThread
(
)
;
}
if
(
!
owningThread
)
{
return
;
}
owningThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
CanvasManagerParent
:
:
Shutdown
"
[
]
(
)
-
>
void
{
CanvasManagerParent
:
:
ShutdownInternal
(
)
;
}
)
NS_DISPATCH_SYNC
)
;
}
void
CanvasManagerParent
:
:
ShutdownInternal
(
)
{
nsTArray
<
RefPtr
<
CanvasManagerParent
>
>
actors
(
sManagers
.
Count
(
)
)
;
for
(
const
auto
&
actor
:
sManagers
)
{
actors
.
AppendElement
(
actor
)
;
}
for
(
auto
const
&
actor
:
actors
)
{
actor
-
>
Close
(
)
;
}
}
CanvasManagerParent
:
:
CanvasManagerParent
(
)
=
default
;
CanvasManagerParent
:
:
~
CanvasManagerParent
(
)
=
default
;
void
CanvasManagerParent
:
:
Bind
(
Endpoint
<
PCanvasManagerParent
>
&
&
aEndpoint
)
{
if
(
!
aEndpoint
.
Bind
(
this
)
)
{
NS_WARNING
(
"
Failed
to
bind
CanvasManagerParent
!
"
)
;
return
;
}
sManagers
.
Insert
(
this
)
;
}
void
CanvasManagerParent
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
sManagers
.
Remove
(
this
)
;
}
already_AddRefed
<
dom
:
:
PWebGLParent
>
CanvasManagerParent
:
:
AllocPWebGLParent
(
)
{
return
MakeAndAddRef
<
dom
:
:
WebGLParent
>
(
)
;
}
already_AddRefed
<
webgpu
:
:
PWebGPUParent
>
CanvasManagerParent
:
:
AllocPWebGPUParent
(
)
{
if
(
!
gfxVars
:
:
AllowWebGPU
(
)
)
{
return
nullptr
;
}
return
MakeAndAddRef
<
webgpu
:
:
WebGPUParent
>
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CanvasManagerParent
:
:
RecvInitialize
(
const
uint32_t
&
aId
)
{
if
(
!
aId
)
{
return
IPC_FAIL
(
this
"
invalid
id
"
)
;
}
if
(
mId
)
{
return
IPC_FAIL
(
this
"
already
initialized
"
)
;
}
mId
=
aId
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CanvasManagerParent
:
:
RecvGetSnapshot
(
const
uint32_t
&
aManagerId
const
int32_t
&
aProtocolId
webgl
:
:
FrontBufferSnapshotIpc
*
aResult
)
{
if
(
!
aManagerId
)
{
return
IPC_FAIL
(
this
"
invalid
id
"
)
;
}
IProtocol
*
actor
=
nullptr
;
for
(
CanvasManagerParent
*
i
:
sManagers
)
{
if
(
i
-
>
OtherPidMaybeInvalid
(
)
=
=
OtherPidMaybeInvalid
(
)
&
&
i
-
>
mId
=
=
aManagerId
)
{
actor
=
i
-
>
Lookup
(
aProtocolId
)
;
break
;
}
}
if
(
!
actor
)
{
return
IPC_FAIL
(
this
"
invalid
actor
"
)
;
}
if
(
actor
-
>
GetProtocolId
(
)
!
=
ProtocolId
:
:
PWebGLMsgStart
|
|
actor
-
>
GetSide
(
)
!
=
mozilla
:
:
ipc
:
:
Side
:
:
ParentSide
)
{
return
IPC_FAIL
(
this
"
unsupported
actor
"
)
;
}
RefPtr
<
dom
:
:
WebGLParent
>
webgl
=
static_cast
<
dom
:
:
WebGLParent
*
>
(
actor
)
;
webgl
:
:
FrontBufferSnapshotIpc
buffer
;
mozilla
:
:
ipc
:
:
IPCResult
rv
=
webgl
-
>
GetFrontBufferSnapshot
(
&
buffer
this
)
;
if
(
!
rv
)
{
return
rv
;
}
*
aResult
=
std
:
:
move
(
buffer
)
;
return
IPC_OK
(
)
;
}
}
