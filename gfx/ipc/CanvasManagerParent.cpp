#
include
"
CanvasManagerParent
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
dom
/
WebGLParent
.
h
"
#
include
"
mozilla
/
gfx
/
CanvasRenderThread
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
gfx
/
GPUParent
.
h
"
#
include
"
mozilla
/
ipc
/
Endpoint
.
h
"
#
include
"
mozilla
/
layers
/
CanvasTranslator
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
ISurfaceAllocator
.
h
"
#
include
"
mozilla
/
webgpu
/
WebGPUParent
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
:
:
gfx
{
CanvasManagerParent
:
:
ManagerSet
CanvasManagerParent
:
:
sManagers
;
StaticMonitor
CanvasManagerParent
:
:
sReplayTexturesMonitor
;
nsTArray
<
CanvasManagerParent
:
:
ReplayTexture
>
CanvasManagerParent
:
:
sReplayTextures
;
bool
CanvasManagerParent
:
:
sReplayTexturesEnabled
(
true
)
;
void
CanvasManagerParent
:
:
Init
(
Endpoint
<
PCanvasManagerParent
>
&
&
aEndpoint
const
dom
:
:
ContentParentId
&
aContentId
)
{
MOZ_ASSERT
(
layers
:
:
CompositorThreadHolder
:
:
IsInCompositorThread
(
)
)
;
auto
manager
=
MakeRefPtr
<
CanvasManagerParent
>
(
aContentId
)
;
nsCOMPtr
<
nsIThread
>
owningThread
=
gfx
:
:
CanvasRenderThread
:
:
GetCanvasRenderThread
(
)
;
MOZ_ASSERT
(
owningThread
)
;
owningThread
-
>
Dispatch
(
NewRunnableMethod
<
Endpoint
<
PCanvasManagerParent
>
&
&
>
(
"
CanvasManagerParent
:
:
Bind
"
manager
&
CanvasManagerParent
:
:
Bind
std
:
:
move
(
aEndpoint
)
)
)
;
}
void
CanvasManagerParent
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIThread
>
owningThread
=
gfx
:
:
CanvasRenderThread
:
:
GetCanvasRenderThread
(
)
;
MOZ_ASSERT
(
owningThread
)
;
NS_DispatchAndSpinEventLoopUntilComplete
(
"
CanvasManagerParent
:
:
Shutdown
"
_ns
owningThread
NS_NewRunnableFunction
(
"
CanvasManagerParent
:
:
Shutdown
"
[
]
(
)
-
>
void
{
CanvasManagerParent
:
:
ShutdownInternal
(
)
;
}
)
)
;
}
void
CanvasManagerParent
:
:
ShutdownInternal
(
)
{
nsTArray
<
RefPtr
<
CanvasManagerParent
>
>
actors
(
sManagers
.
Count
(
)
)
;
for
(
const
auto
&
actor
:
sManagers
)
{
actors
.
AppendElement
(
actor
)
;
}
for
(
auto
const
&
actor
:
actors
)
{
actor
-
>
Close
(
)
;
}
StaticMonitorAutoLock
lock
(
sReplayTexturesMonitor
)
;
sReplayTextures
.
Clear
(
)
;
lock
.
NotifyAll
(
)
;
}
void
CanvasManagerParent
:
:
DisableRemoteCanvas
(
)
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
CanvasManagerParent
:
:
DisableRemoteCanvas
"
[
]
{
if
(
XRE_IsGPUProcess
(
)
)
{
GPUParent
:
:
GetSingleton
(
)
-
>
NotifyDisableRemoteCanvas
(
)
;
}
else
{
gfxPlatform
:
:
DisableRemoteCanvas
(
)
;
}
}
)
)
;
if
(
CanvasRenderThread
:
:
IsInCanvasRenderThread
(
)
)
{
DisableRemoteCanvasInternal
(
)
;
return
;
}
CanvasRenderThread
:
:
Dispatch
(
NS_NewRunnableFunction
(
"
CanvasManagerParent
:
:
DisableRemoteCanvas
"
[
]
{
CanvasManagerParent
:
:
DisableRemoteCanvasInternal
(
)
;
}
)
)
;
}
void
CanvasManagerParent
:
:
DisableRemoteCanvasInternal
(
)
{
MOZ_ASSERT
(
CanvasRenderThread
:
:
IsInCanvasRenderThread
(
)
)
;
AutoTArray
<
RefPtr
<
layers
:
:
CanvasTranslator
>
16
>
actors
;
for
(
const
auto
&
manager
:
sManagers
)
{
for
(
const
auto
&
canvas
:
manager
-
>
ManagedPCanvasParent
(
)
)
{
actors
.
AppendElement
(
static_cast
<
layers
:
:
CanvasTranslator
*
>
(
canvas
)
)
;
}
}
{
StaticMonitorAutoLock
lock
(
sReplayTexturesMonitor
)
;
sReplayTexturesEnabled
=
false
;
sReplayTextures
.
Clear
(
)
;
}
for
(
const
auto
&
actor
:
actors
)
{
Unused
<
<
NS_WARN_IF
(
!
actor
-
>
SendDeactivate
(
)
)
;
}
{
StaticMonitorAutoLock
lock
(
sReplayTexturesMonitor
)
;
lock
.
NotifyAll
(
)
;
}
}
void
CanvasManagerParent
:
:
AddReplayTexture
(
layers
:
:
CanvasTranslator
*
aOwner
int64_t
aTextureId
layers
:
:
TextureData
*
aTextureData
)
{
auto
desc
=
MakeUnique
<
layers
:
:
SurfaceDescriptor
>
(
)
;
if
(
!
aTextureData
-
>
Serialize
(
*
desc
)
)
{
MOZ_CRASH
(
"
Failed
to
serialize
"
)
;
}
StaticMonitorAutoLock
lock
(
sReplayTexturesMonitor
)
;
sReplayTextures
.
AppendElement
(
ReplayTexture
{
std
:
:
move
(
desc
)
aOwner
-
>
GetContentId
(
)
aTextureId
aOwner
-
>
GetManagerId
(
)
}
)
;
lock
.
NotifyAll
(
)
;
}
void
CanvasManagerParent
:
:
RemoveReplayTexture
(
layers
:
:
CanvasTranslator
*
aOwner
int64_t
aTextureId
)
{
StaticMonitorAutoLock
lock
(
sReplayTexturesMonitor
)
;
auto
i
=
sReplayTextures
.
Length
(
)
;
while
(
i
>
0
)
{
-
-
i
;
const
auto
&
texture
=
sReplayTextures
[
i
]
;
if
(
texture
.
mContentId
=
=
aOwner
-
>
GetContentId
(
)
&
&
texture
.
mTextureId
=
=
aTextureId
)
{
MOZ_ASSERT
(
texture
.
mManagerId
=
=
aOwner
-
>
GetManagerId
(
)
)
;
sReplayTextures
.
RemoveElementAt
(
i
)
;
break
;
}
}
}
void
CanvasManagerParent
:
:
RemoveReplayTextures
(
layers
:
:
CanvasTranslator
*
aOwner
)
{
StaticMonitorAutoLock
lock
(
sReplayTexturesMonitor
)
;
auto
i
=
sReplayTextures
.
Length
(
)
;
while
(
i
>
0
)
{
-
-
i
;
const
auto
&
texture
=
sReplayTextures
[
i
]
;
if
(
texture
.
mContentId
=
=
aOwner
-
>
GetContentId
(
)
&
&
texture
.
mManagerId
=
=
aOwner
-
>
GetManagerId
(
)
)
{
sReplayTextures
.
RemoveElementAt
(
i
)
;
}
}
}
UniquePtr
<
layers
:
:
SurfaceDescriptor
>
CanvasManagerParent
:
:
TakeReplayTexture
(
const
dom
:
:
ContentParentId
&
aContentId
int64_t
aTextureId
)
{
auto
i
=
sReplayTextures
.
Length
(
)
;
while
(
i
>
0
)
{
-
-
i
;
const
auto
&
texture
=
sReplayTextures
[
i
]
;
if
(
texture
.
mContentId
=
=
aContentId
&
&
texture
.
mTextureId
=
=
aTextureId
)
{
UniquePtr
<
layers
:
:
SurfaceDescriptor
>
desc
=
std
:
:
move
(
sReplayTextures
[
i
]
.
mDesc
)
;
sReplayTextures
.
RemoveElementAt
(
i
)
;
return
desc
;
}
}
return
nullptr
;
}
UniquePtr
<
layers
:
:
SurfaceDescriptor
>
CanvasManagerParent
:
:
WaitForReplayTexture
(
layers
:
:
HostIPCAllocator
*
aAllocator
int64_t
aTextureId
)
{
MOZ_ASSERT
(
!
CanvasRenderThread
:
:
IsInCanvasRenderThread
(
)
)
;
StaticMonitorAutoLock
lock
(
sReplayTexturesMonitor
)
;
dom
:
:
ContentParentId
contentId
=
aAllocator
-
>
GetContentId
(
)
;
UniquePtr
<
layers
:
:
SurfaceDescriptor
>
desc
;
while
(
!
(
desc
=
TakeReplayTexture
(
contentId
aTextureId
)
)
)
{
if
(
NS_WARN_IF
(
!
sReplayTexturesEnabled
)
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
!
aAllocator
-
>
IPCOpen
(
)
)
)
{
return
nullptr
;
}
TimeDuration
timeout
=
TimeDuration
:
:
FromMilliseconds
(
StaticPrefs
:
:
gfx_canvas_remote_texture_timeout_ms
(
)
)
;
CVStatus
status
=
lock
.
Wait
(
timeout
)
;
if
(
status
=
=
CVStatus
:
:
Timeout
)
{
return
nullptr
;
}
}
return
desc
;
}
CanvasManagerParent
:
:
CanvasManagerParent
(
const
dom
:
:
ContentParentId
&
aContentId
)
:
mContentId
(
aContentId
)
{
}
CanvasManagerParent
:
:
~
CanvasManagerParent
(
)
=
default
;
void
CanvasManagerParent
:
:
Bind
(
Endpoint
<
PCanvasManagerParent
>
&
&
aEndpoint
)
{
if
(
!
aEndpoint
.
Bind
(
this
)
)
{
NS_WARNING
(
"
Failed
to
bind
CanvasManagerParent
!
"
)
;
return
;
}
#
ifdef
DEBUG
for
(
CanvasManagerParent
*
i
:
sManagers
)
{
MOZ_ASSERT_IF
(
i
-
>
mContentId
=
=
mContentId
i
-
>
OtherPidMaybeInvalid
(
)
=
=
OtherPidMaybeInvalid
(
)
)
;
}
#
endif
sManagers
.
Insert
(
this
)
;
}
void
CanvasManagerParent
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
sManagers
.
Remove
(
this
)
;
}
already_AddRefed
<
dom
:
:
PWebGLParent
>
CanvasManagerParent
:
:
AllocPWebGLParent
(
)
{
return
MakeAndAddRef
<
dom
:
:
WebGLParent
>
(
mContentId
)
;
}
already_AddRefed
<
webgpu
:
:
PWebGPUParent
>
CanvasManagerParent
:
:
AllocPWebGPUParent
(
)
{
if
(
!
gfxVars
:
:
AllowWebGPU
(
)
)
{
return
nullptr
;
}
return
MakeAndAddRef
<
webgpu
:
:
WebGPUParent
>
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CanvasManagerParent
:
:
RecvInitialize
(
const
uint32_t
&
aId
)
{
if
(
!
aId
)
{
return
IPC_FAIL
(
this
"
invalid
id
"
)
;
}
if
(
mId
)
{
return
IPC_FAIL
(
this
"
already
initialized
"
)
;
}
mId
=
aId
;
return
IPC_OK
(
)
;
}
already_AddRefed
<
layers
:
:
PCanvasParent
>
CanvasManagerParent
:
:
AllocPCanvasParent
(
)
{
MOZ_RELEASE_ASSERT
(
mId
!
=
0
)
;
return
MakeAndAddRef
<
layers
:
:
CanvasTranslator
>
(
mContentId
mId
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CanvasManagerParent
:
:
RecvGetSnapshot
(
const
uint32_t
&
aManagerId
const
int32_t
&
aProtocolId
const
Maybe
<
RemoteTextureOwnerId
>
&
aOwnerId
webgl
:
:
FrontBufferSnapshotIpc
*
aResult
)
{
if
(
!
aManagerId
)
{
return
IPC_FAIL
(
this
"
invalid
id
"
)
;
}
IProtocol
*
actor
=
nullptr
;
for
(
CanvasManagerParent
*
i
:
sManagers
)
{
if
(
i
-
>
mContentId
=
=
mContentId
&
&
i
-
>
mId
=
=
aManagerId
)
{
actor
=
i
-
>
Lookup
(
aProtocolId
)
;
break
;
}
}
if
(
!
actor
)
{
return
IPC_FAIL
(
this
"
invalid
actor
"
)
;
}
if
(
actor
-
>
GetSide
(
)
!
=
mozilla
:
:
ipc
:
:
Side
:
:
ParentSide
)
{
return
IPC_FAIL
(
this
"
unsupported
actor
"
)
;
}
webgl
:
:
FrontBufferSnapshotIpc
buffer
;
switch
(
actor
-
>
GetProtocolId
(
)
)
{
case
ProtocolId
:
:
PWebGLMsgStart
:
{
RefPtr
<
dom
:
:
WebGLParent
>
webgl
=
static_cast
<
dom
:
:
WebGLParent
*
>
(
actor
)
;
mozilla
:
:
ipc
:
:
IPCResult
rv
=
webgl
-
>
GetFrontBufferSnapshot
(
&
buffer
this
)
;
if
(
!
rv
)
{
return
rv
;
}
}
break
;
case
ProtocolId
:
:
PWebGPUMsgStart
:
{
RefPtr
<
webgpu
:
:
WebGPUParent
>
webgpu
=
static_cast
<
webgpu
:
:
WebGPUParent
*
>
(
actor
)
;
IntSize
size
;
if
(
aOwnerId
.
isNothing
(
)
)
{
return
IPC_FAIL
(
this
"
invalid
OwnerId
"
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
rv
=
webgpu
-
>
GetFrontBufferSnapshot
(
this
*
aOwnerId
buffer
.
shmem
size
)
;
if
(
!
rv
)
{
return
rv
;
}
buffer
.
surfSize
.
x
=
static_cast
<
uint32_t
>
(
size
.
width
)
;
buffer
.
surfSize
.
y
=
static_cast
<
uint32_t
>
(
size
.
height
)
;
}
break
;
default
:
return
IPC_FAIL
(
this
"
unsupported
protocol
"
)
;
}
*
aResult
=
std
:
:
move
(
buffer
)
;
return
IPC_OK
(
)
;
}
}
