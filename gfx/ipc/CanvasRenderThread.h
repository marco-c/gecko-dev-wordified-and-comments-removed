#
ifndef
_include_gfx_ipc_CanvasRenderThread_h__
#
define
_include_gfx_ipc_CanvasRenderThread_h__
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
class
nsIRunnable
;
class
nsIThread
;
class
nsIThreadPool
;
namespace
mozilla
{
class
TaskQueue
;
namespace
gfx
{
class
CanvasRenderThread
final
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING_WITH_DELETE_ON_MAIN_THREAD
(
CanvasRenderThread
)
public
:
static
void
Start
(
)
;
static
void
Shutdown
(
)
;
static
bool
IsInCanvasRenderThread
(
)
;
static
bool
IsInCanvasWorkerThread
(
)
;
static
bool
IsInCanvasRenderOrWorkerThread
(
)
;
static
already_AddRefed
<
nsIThread
>
GetCanvasRenderThread
(
)
;
static
already_AddRefed
<
TaskQueue
>
CreateWorkerTaskQueue
(
)
;
static
void
ShutdownWorkerTaskQueue
(
TaskQueue
*
aTaskQueue
)
;
static
void
FinishShutdownWorkerTaskQueue
(
TaskQueue
*
aTaskQueue
)
;
static
void
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
;
private
:
CanvasRenderThread
(
nsCOMPtr
<
nsIThread
>
&
&
aThread
nsCOMPtr
<
nsIThreadPool
>
&
&
aWorkers
bool
aCreatedThread
)
;
~
CanvasRenderThread
(
)
;
Mutex
mMutex
;
nsCOMPtr
<
nsIThread
>
const
mThread
;
nsCOMPtr
<
nsIThreadPool
>
const
mWorkers
;
nsTArray
<
RefPtr
<
TaskQueue
>
>
mPendingShutdownTaskQueues
MOZ_GUARDED_BY
(
mMutex
)
;
const
bool
mCreatedThread
;
}
;
}
}
#
endif
