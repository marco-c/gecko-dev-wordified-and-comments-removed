#
include
"
VsyncBridgeChild
.
h
"
#
include
"
VsyncIOThreadHolder
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessManager
.
h
"
namespace
mozilla
{
namespace
gfx
{
VsyncBridgeChild
:
:
VsyncBridgeChild
(
RefPtr
<
VsyncIOThreadHolder
>
aThread
const
uint64_t
&
aProcessToken
)
:
mThread
(
aThread
)
mProcessToken
(
aProcessToken
)
{
}
VsyncBridgeChild
:
:
~
VsyncBridgeChild
(
)
=
default
;
RefPtr
<
VsyncBridgeChild
>
VsyncBridgeChild
:
:
Create
(
RefPtr
<
VsyncIOThreadHolder
>
aThread
const
uint64_t
&
aProcessToken
Endpoint
<
PVsyncBridgeChild
>
&
&
aEndpoint
)
{
RefPtr
<
VsyncBridgeChild
>
child
=
new
VsyncBridgeChild
(
aThread
aProcessToken
)
;
RefPtr
<
nsIRunnable
>
task
=
NewRunnableMethod
<
Endpoint
<
PVsyncBridgeChild
>
&
&
>
(
"
gfx
:
:
VsyncBridgeChild
:
:
Open
"
child
&
VsyncBridgeChild
:
:
Open
std
:
:
move
(
aEndpoint
)
)
;
aThread
-
>
GetThread
(
)
-
>
Dispatch
(
task
.
forget
(
)
nsIThread
:
:
DISPATCH_NORMAL
)
;
return
child
;
}
void
VsyncBridgeChild
:
:
Open
(
Endpoint
<
PVsyncBridgeChild
>
&
&
aEndpoint
)
{
if
(
!
aEndpoint
.
Bind
(
this
)
)
{
if
(
GPUProcessManager
*
gpm
=
GPUProcessManager
:
:
Get
(
)
)
gpm
-
>
NotifyRemoteActorDestroyed
(
mProcessToken
)
;
return
;
}
AddRef
(
)
;
}
class
NotifyVsyncTask
:
public
Runnable
{
public
:
NotifyVsyncTask
(
RefPtr
<
VsyncBridgeChild
>
aVsyncBridge
const
VsyncEvent
&
aVsync
const
layers
:
:
LayersId
&
aLayersId
)
:
Runnable
(
"
gfx
:
:
NotifyVsyncTask
"
)
mVsyncBridge
(
aVsyncBridge
)
mVsync
(
aVsync
)
mLayersId
(
aLayersId
)
{
}
NS_IMETHOD
Run
(
)
override
{
mVsyncBridge
-
>
NotifyVsyncImpl
(
mVsync
mLayersId
)
;
return
NS_OK
;
}
private
:
RefPtr
<
VsyncBridgeChild
>
mVsyncBridge
;
VsyncEvent
mVsync
;
layers
:
:
LayersId
mLayersId
;
}
;
bool
VsyncBridgeChild
:
:
IsOnVsyncIOThread
(
)
const
{
return
mThread
-
>
IsOnCurrentThread
(
)
;
}
void
VsyncBridgeChild
:
:
NotifyVsync
(
const
VsyncEvent
&
aVsync
const
layers
:
:
LayersId
&
aLayersId
)
{
MOZ_ASSERT
(
!
IsOnVsyncIOThread
(
)
)
;
RefPtr
<
NotifyVsyncTask
>
task
=
new
NotifyVsyncTask
(
this
aVsync
aLayersId
)
;
mThread
-
>
Dispatch
(
task
.
forget
(
)
)
;
}
void
VsyncBridgeChild
:
:
NotifyVsyncImpl
(
const
VsyncEvent
&
aVsync
const
layers
:
:
LayersId
&
aLayersId
)
{
MOZ_ASSERT
(
IsOnVsyncIOThread
(
)
)
;
if
(
!
mProcessToken
)
{
return
;
}
SendNotifyVsync
(
aVsync
aLayersId
)
;
}
void
VsyncBridgeChild
:
:
Close
(
)
{
if
(
!
IsOnVsyncIOThread
(
)
)
{
mThread
-
>
Dispatch
(
NewRunnableMethod
(
"
gfx
:
:
VsyncBridgeChild
:
:
Close
"
this
&
VsyncBridgeChild
:
:
Close
)
)
;
return
;
}
if
(
!
mProcessToken
)
{
return
;
}
mProcessToken
=
0
;
PVsyncBridgeChild
:
:
Close
(
)
;
}
void
VsyncBridgeChild
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
if
(
mProcessToken
)
{
GPUProcessManager
:
:
Get
(
)
-
>
NotifyRemoteActorDestroyed
(
mProcessToken
)
;
mProcessToken
=
0
;
}
}
void
VsyncBridgeChild
:
:
ActorDealloc
(
)
{
Release
(
)
;
}
void
VsyncBridgeChild
:
:
ProcessingError
(
Result
aCode
const
char
*
aReason
)
{
MOZ_RELEASE_ASSERT
(
aCode
=
=
MsgDropped
"
Processing
error
in
VsyncBridgeChild
"
)
;
}
void
VsyncBridgeChild
:
:
HandleFatalError
(
const
char
*
aMsg
)
const
{
dom
:
:
ContentChild
:
:
FatalErrorIfNotUsingGPUProcess
(
aMsg
OtherPid
(
)
)
;
}
}
}
