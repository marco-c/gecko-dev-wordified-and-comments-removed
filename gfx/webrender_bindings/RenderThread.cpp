#
include
"
base
/
task
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
RenderThread
.
h
"
#
include
"
nsThread
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
transport
/
runnable_utils
.
h
"
#
include
"
mozilla
/
BackgroundHangMonitor
.
h
"
#
include
"
mozilla
/
layers
/
AsyncImagePipelineManager
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
gfx
/
GPUParent
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessManager
.
h
"
#
include
"
mozilla
/
glean
/
GleanMetrics
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
CompositorManagerParent
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
SharedSurfacesParent
.
h
"
#
include
"
mozilla
/
layers
/
SurfacePool
.
h
"
#
include
"
mozilla
/
layers
/
SynchronousTask
.
h
"
#
include
"
mozilla
/
PerfStats
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
webrender
/
RendererOGL
.
h
"
#
include
"
mozilla
/
webrender
/
RenderTextureHost
.
h
"
#
include
"
mozilla
/
widget
/
CompositorWidget
.
h
"
#
include
"
OGLShaderProgram
.
h
"
#
ifdef
XP_WIN
#
include
"
GLContextEGL
.
h
"
#
include
"
GLLibraryEGL
.
h
"
#
include
"
mozilla
/
widget
/
WinCompositorWindowThread
.
h
"
#
include
"
mozilla
/
gfx
/
DeviceManagerDx
.
h
"
#
include
"
mozilla
/
webrender
/
DCLayerTree
.
h
"
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
GLLibraryEGL
.
h
"
#
include
"
mozilla
/
webrender
/
RenderAndroidSurfaceTextureHost
.
h
"
#
endif
#
ifdef
MOZ_WIDGET_GTK
#
include
"
mozilla
/
WidgetUtilsGtk
.
h
"
#
include
"
GLLibraryEGL
.
h
"
#
endif
using
namespace
mozilla
;
static
already_AddRefed
<
gl
:
:
GLContext
>
CreateGLContext
(
nsACString
&
aError
)
;
MOZ_DEFINE_MALLOC_SIZE_OF
(
WebRenderRendererMallocSizeOf
)
namespace
mozilla
:
:
wr
{
LazyLogModule
gRenderThreadLog
(
"
RenderThread
"
)
;
#
define
LOG
(
.
.
.
)
MOZ_LOG
(
gRenderThreadLog
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
static
StaticRefPtr
<
RenderThread
>
sRenderThread
;
static
mozilla
:
:
BackgroundHangMonitor
*
sBackgroundHangMonitor
;
#
ifdef
DEBUG
static
bool
sRenderThreadEverStarted
=
false
;
#
endif
size_t
RenderThread
:
:
sRendererCount
=
0
;
size_t
RenderThread
:
:
sActiveRendererCount
=
0
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
|
|
defined
(
MOZ_WIDGET_GTK
)
static
bool
USE_DEDICATED_GLYPH_RASTER_THREAD
=
true
;
#
else
static
bool
USE_DEDICATED_GLYPH_RASTER_THREAD
=
false
;
#
endif
RenderThread
:
:
RenderThread
(
RefPtr
<
nsIThread
>
aThread
)
:
mThread
(
std
:
:
move
(
aThread
)
)
mThreadPool
(
false
)
mThreadPoolLP
(
true
)
mChunkPool
(
wr_chunk_pool_new
(
)
)
mGlyphRasterThread
(
USE_DEDICATED_GLYPH_RASTER_THREAD
)
mSingletonGLIsForHardwareWebRender
(
true
)
mBatteryInfo
(
"
RenderThread
.
mBatteryInfo
"
)
mWindowInfos
(
"
RenderThread
.
mWindowInfos
"
)
mRenderTextureMapLock
(
"
RenderThread
.
mRenderTextureMapLock
"
)
mHasShutdown
(
false
)
mHandlingDeviceReset
(
false
)
mHandlingWebRenderError
(
false
)
{
}
RenderThread
:
:
~
RenderThread
(
)
{
MOZ_ASSERT
(
mRenderTexturesDeferred
.
empty
(
)
)
;
wr_chunk_pool_delete
(
mChunkPool
)
;
}
RenderThread
*
RenderThread
:
:
Get
(
)
{
return
sRenderThread
;
}
void
RenderThread
:
:
Start
(
uint32_t
aNamespace
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
sRenderThread
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
!
sRenderThreadEverStarted
)
;
sRenderThreadEverStarted
=
true
;
#
endif
uint32_t
stackSize
=
nsIThreadManager
:
:
DEFAULT_STACK_SIZE
;
if
(
stackSize
&
&
!
gfx
:
:
gfxVars
:
:
SupportsThreadsafeGL
(
)
)
{
stackSize
=
std
:
:
max
(
stackSize
4096U
<
<
10
)
;
}
#
if
!
defined
(
__OPTIMIZE__
)
stackSize
=
std
:
:
max
(
stackSize
4
*
1024
*
1024U
)
;
#
endif
RefPtr
<
nsIThread
>
thread
;
nsresult
rv
=
NS_NewNamedThread
(
"
Renderer
"
getter_AddRefs
(
thread
)
NS_NewRunnableFunction
(
"
Renderer
:
:
BackgroundHanSetup
"
[
]
(
)
{
sBackgroundHangMonitor
=
new
mozilla
:
:
BackgroundHangMonitor
(
"
Render
"
128
2048
)
;
nsCOMPtr
<
nsIThread
>
thread
=
NS_GetCurrentThread
(
)
;
nsThread
*
nsthread
=
static_cast
<
nsThread
*
>
(
thread
.
get
(
)
)
;
nsthread
-
>
SetUseHangMonitor
(
true
)
;
nsthread
-
>
SetPriority
(
nsISupportsPriority
:
:
PRIORITY_HIGH
)
;
}
)
{
.
stackSize
=
stackSize
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
gfxCriticalNote
<
<
"
Failed
to
create
Renderer
thread
:
"
<
<
gfx
:
:
hexa
(
(
uint32_t
)
rv
)
;
return
;
}
sRenderThread
=
new
RenderThread
(
thread
)
;
CrashReporter
:
:
RegisterAnnotationUSize
(
CrashReporter
:
:
Annotation
:
:
GraphicsNumRenderers
&
sRendererCount
)
;
CrashReporter
:
:
RegisterAnnotationUSize
(
CrashReporter
:
:
Annotation
:
:
GraphicsNumActiveRenderers
&
sActiveRendererCount
)
;
#
ifdef
XP_WIN
widget
:
:
WinCompositorWindowThread
:
:
Start
(
)
;
#
endif
layers
:
:
SharedSurfacesParent
:
:
Initialize
(
)
;
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
RefPtr
<
RenderThread
>
(
sRenderThread
.
get
(
)
)
&
RenderThread
:
:
InitDeviceTask
)
;
sRenderThread
-
>
PostRunnable
(
runnable
.
forget
(
)
)
;
}
void
RenderThread
:
:
ShutDown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
sRenderThread
)
;
{
MutexAutoLock
lock
(
sRenderThread
-
>
mRenderTextureMapLock
)
;
sRenderThread
-
>
mHasShutdown
=
true
;
}
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
RefPtr
<
RenderThread
>
(
sRenderThread
.
get
(
)
)
&
RenderThread
:
:
ShutDownTask
)
;
sRenderThread
-
>
PostRunnable
(
runnable
.
forget
(
)
)
;
nsCOMPtr
<
nsIThread
>
oldThread
=
sRenderThread
-
>
GetRenderThread
(
)
;
oldThread
-
>
Shutdown
(
)
;
layers
:
:
SharedSurfacesParent
:
:
Shutdown
(
)
;
#
ifdef
XP_WIN
if
(
widget
:
:
WinCompositorWindowThread
:
:
Get
(
)
)
{
widget
:
:
WinCompositorWindowThread
:
:
ShutDown
(
)
;
}
#
endif
sRenderThread
=
nullptr
;
}
extern
void
ClearAllBlobImageResources
(
)
;
void
RenderThread
:
:
ShutDownTask
(
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
LOG
(
"
RenderThread
:
:
ShutDownTask
(
)
"
)
;
{
MutexAutoLock
lock
(
mRenderTextureMapLock
)
;
mRenderTexturesDeferred
.
clear
(
)
;
mRenderTextures
.
clear
(
)
;
mSyncObjectNeededRenderTextures
.
clear
(
)
;
mRenderTextureOps
.
clear
(
)
;
}
mThreadPool
.
Release
(
)
;
mThreadPoolLP
.
Release
(
)
;
layers
:
:
SharedSurfacesParent
:
:
ShutdownRenderThread
(
)
;
#
ifdef
XP_WIN
DCLayerTree
:
:
Shutdown
(
)
;
#
endif
ClearAllBlobImageResources
(
)
;
ClearSingletonGL
(
)
;
ClearSharedSurfacePool
(
)
;
}
bool
RenderThread
:
:
IsInRenderThread
(
)
{
return
sRenderThread
&
&
sRenderThread
-
>
mThread
=
=
NS_GetCurrentThread
(
)
;
}
already_AddRefed
<
nsIThread
>
RenderThread
:
:
GetRenderThread
(
)
{
nsCOMPtr
<
nsIThread
>
thread
;
if
(
sRenderThread
)
{
thread
=
sRenderThread
-
>
mThread
;
}
return
thread
.
forget
(
)
;
}
void
RenderThread
:
:
DoAccumulateMemoryReport
(
MemoryReport
aReport
const
RefPtr
<
MemoryReportPromise
:
:
Private
>
&
aPromise
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
for
(
auto
&
r
:
mRenderers
)
{
r
.
second
-
>
AccumulateMemoryReport
(
&
aReport
)
;
}
MOZ_ASSERT
(
aReport
.
shader_cache
=
=
0
)
;
if
(
mProgramCache
)
{
aReport
.
shader_cache
=
wr_program_cache_report_memory
(
mProgramCache
-
>
Raw
(
)
&
WebRenderRendererMallocSizeOf
)
;
}
size_t
renderTextureMemory
=
0
;
{
MutexAutoLock
lock
(
mRenderTextureMapLock
)
;
for
(
const
auto
&
entry
:
mRenderTextures
)
{
renderTextureMemory
+
=
entry
.
second
-
>
Bytes
(
)
;
}
}
aReport
.
render_texture_hosts
=
renderTextureMemory
;
aPromise
-
>
Resolve
(
aReport
__func__
)
;
}
RefPtr
<
MemoryReportPromise
>
RenderThread
:
:
AccumulateMemoryReport
(
MemoryReport
aInitial
)
{
RefPtr
<
MemoryReportPromise
:
:
Private
>
p
=
new
MemoryReportPromise
:
:
Private
(
__func__
)
;
MOZ_ASSERT
(
!
IsInRenderThread
(
)
)
;
if
(
!
Get
(
)
)
{
NS_WARNING
(
"
No
render
thread
returning
empty
memory
report
"
)
;
p
-
>
Resolve
(
aInitial
__func__
)
;
return
p
;
}
Get
(
)
-
>
PostRunnable
(
NewRunnableMethod
<
MemoryReport
RefPtr
<
MemoryReportPromise
:
:
Private
>
>
(
"
wr
:
:
RenderThread
:
:
DoAccumulateMemoryReport
"
Get
(
)
&
RenderThread
:
:
DoAccumulateMemoryReport
aInitial
p
)
)
;
return
p
;
}
void
RenderThread
:
:
SetBatteryInfo
(
const
hal
:
:
BatteryInformation
&
aBatteryInfo
)
{
MOZ_ASSERT
(
XRE_IsGPUProcess
(
)
)
;
auto
batteryInfo
=
mBatteryInfo
.
Lock
(
)
;
batteryInfo
.
ref
(
)
=
Some
(
aBatteryInfo
)
;
}
bool
RenderThread
:
:
GetPowerIsCharging
(
)
{
MOZ_ASSERT
(
XRE_IsGPUProcess
(
)
)
;
auto
batteryInfo
=
mBatteryInfo
.
Lock
(
)
;
if
(
batteryInfo
.
ref
(
)
.
isSome
(
)
)
{
return
batteryInfo
.
ref
(
)
.
ref
(
)
.
charging
(
)
;
}
gfxCriticalNoteOnce
<
<
"
BatteryInfo
is
not
set
"
;
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
to
be
called
"
)
;
return
false
;
}
void
RenderThread
:
:
AddRenderer
(
wr
:
:
WindowId
aWindowId
UniquePtr
<
RendererOGL
>
aRenderer
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
LOG
(
"
RenderThread
:
:
AddRenderer
(
)
aWindowId
%
"
PRIx64
"
"
AsUint64
(
aWindowId
)
)
;
if
(
mHasShutdown
)
{
return
;
}
mRenderers
[
aWindowId
]
=
std
:
:
move
(
aRenderer
)
;
sRendererCount
=
mRenderers
.
size
(
)
;
auto
windows
=
mWindowInfos
.
Lock
(
)
;
windows
-
>
emplace
(
AsUint64
(
aWindowId
)
new
WindowInfo
(
)
)
;
mWrNotifierEventsQueues
.
emplace
(
AsUint64
(
aWindowId
)
new
std
:
:
queue
<
WrNotifierEvent
>
)
;
}
void
RenderThread
:
:
RemoveRenderer
(
wr
:
:
WindowId
aWindowId
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
LOG
(
"
RenderThread
:
:
RemoveRenderer
(
)
aWindowId
%
"
PRIx64
"
"
AsUint64
(
aWindowId
)
)
;
if
(
mHasShutdown
)
{
return
;
}
mRenderers
.
erase
(
aWindowId
)
;
sRendererCount
=
mRenderers
.
size
(
)
;
if
(
mRenderers
.
empty
(
)
)
{
if
(
mHandlingDeviceReset
)
{
ClearSingletonGL
(
)
;
}
mHandlingDeviceReset
=
false
;
mHandlingWebRenderError
=
false
;
}
auto
windows
=
mWindowInfos
.
Lock
(
)
;
auto
it
=
windows
-
>
find
(
AsUint64
(
aWindowId
)
)
;
MOZ_ASSERT
(
it
!
=
windows
-
>
end
(
)
)
;
windows
-
>
erase
(
it
)
;
RefPtr
<
Runnable
>
runnable
=
NS_NewRunnableFunction
(
"
RenderThread
:
:
RemoveRenderer
"
[
aWindowId
]
(
)
{
auto
*
self
=
RenderThread
:
:
Get
(
)
;
auto
it
=
self
-
>
mWrNotifierEventsQueues
.
find
(
AsUint64
(
aWindowId
)
)
;
if
(
it
=
=
self
-
>
mWrNotifierEventsQueues
.
end
(
)
)
{
return
;
}
self
-
>
mWrNotifierEventsQueues
.
erase
(
it
)
;
}
)
;
RenderThread
:
:
Get
(
)
-
>
PostRunnable
(
runnable
.
forget
(
)
)
;
}
RendererOGL
*
RenderThread
:
:
GetRenderer
(
wr
:
:
WindowId
aWindowId
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
auto
it
=
mRenderers
.
find
(
aWindowId
)
;
MOZ_ASSERT
(
it
!
=
mRenderers
.
end
(
)
)
;
if
(
it
=
=
mRenderers
.
end
(
)
)
{
return
nullptr
;
}
return
it
-
>
second
.
get
(
)
;
}
size_t
RenderThread
:
:
RendererCount
(
)
const
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
return
mRenderers
.
size
(
)
;
}
void
RenderThread
:
:
UpdateActiveRendererCount
(
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
size_t
num_active
=
0
;
for
(
const
auto
&
it
:
mRenderers
)
{
if
(
!
it
.
second
-
>
IsPaused
(
)
)
{
num_active
+
+
;
}
}
sActiveRendererCount
=
num_active
;
}
void
RenderThread
:
:
WrNotifierEvent_WakeUp
(
WrWindowId
aWindowId
bool
aCompositeNeeded
)
{
auto
windows
=
mWindowInfos
.
Lock
(
)
;
auto
it
=
windows
-
>
find
(
AsUint64
(
aWindowId
)
)
;
if
(
it
=
=
windows
-
>
end
(
)
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
WindowInfo
*
info
=
it
-
>
second
.
get
(
)
;
info
-
>
mPendingWrNotifierEvents
.
emplace
(
WrNotifierEvent
:
:
WakeUp
(
aCompositeNeeded
)
)
;
PostWrNotifierEvents
(
aWindowId
info
)
;
}
void
RenderThread
:
:
WrNotifierEvent_NewFrameReady
(
WrWindowId
aWindowId
bool
aCompositeNeeded
FramePublishId
aPublishId
)
{
auto
windows
=
mWindowInfos
.
Lock
(
)
;
auto
it
=
windows
-
>
find
(
AsUint64
(
aWindowId
)
)
;
if
(
it
=
=
windows
-
>
end
(
)
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
WindowInfo
*
info
=
it
-
>
second
.
get
(
)
;
info
-
>
mPendingWrNotifierEvents
.
emplace
(
WrNotifierEvent
:
:
NewFrameReady
(
aCompositeNeeded
aPublishId
)
)
;
PostWrNotifierEvents
(
aWindowId
info
)
;
}
void
RenderThread
:
:
WrNotifierEvent_ExternalEvent
(
WrWindowId
aWindowId
size_t
aRawEvent
)
{
UniquePtr
<
RendererEvent
>
evt
(
reinterpret_cast
<
RendererEvent
*
>
(
aRawEvent
)
)
;
{
auto
windows
=
mWindowInfos
.
Lock
(
)
;
auto
it
=
windows
-
>
find
(
AsUint64
(
aWindowId
)
)
;
if
(
it
=
=
windows
-
>
end
(
)
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
WindowInfo
*
info
=
it
-
>
second
.
get
(
)
;
info
-
>
mPendingWrNotifierEvents
.
emplace
(
WrNotifierEvent
:
:
ExternalEvent
(
std
:
:
move
(
evt
)
)
)
;
PostWrNotifierEvents
(
aWindowId
info
)
;
}
}
void
RenderThread
:
:
PostWrNotifierEvents
(
WrWindowId
aWindowId
)
{
{
auto
windows
=
mWindowInfos
.
Lock
(
)
;
auto
it
=
windows
-
>
find
(
AsUint64
(
aWindowId
)
)
;
if
(
it
=
=
windows
-
>
end
(
)
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
WindowInfo
*
info
=
it
-
>
second
.
get
(
)
;
PostWrNotifierEvents
(
aWindowId
info
)
;
}
}
void
RenderThread
:
:
PostWrNotifierEvents
(
WrWindowId
aWindowId
WindowInfo
*
aInfo
)
{
if
(
aInfo
-
>
mWrNotifierEventsRunnable
)
{
return
;
}
RefPtr
<
nsIRunnable
>
runnable
=
NewRunnableMethod
<
WrWindowId
>
(
"
RenderThread
:
:
HandleWrNotifierEvents
"
this
&
RenderThread
:
:
HandleWrNotifierEvents
aWindowId
)
;
aInfo
-
>
mWrNotifierEventsRunnable
=
runnable
;
PostRunnable
(
runnable
.
forget
(
)
)
;
}
void
RenderThread
:
:
HandleWrNotifierEvents
(
WrWindowId
aWindowId
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
auto
eventsIt
=
mWrNotifierEventsQueues
.
find
(
AsUint64
(
aWindowId
)
)
;
if
(
eventsIt
=
=
mWrNotifierEventsQueues
.
end
(
)
)
{
return
;
}
auto
*
events
=
eventsIt
-
>
second
.
get
(
)
;
{
auto
windows
=
mWindowInfos
.
Lock
(
)
;
auto
infoIt
=
windows
-
>
find
(
AsUint64
(
aWindowId
)
)
;
if
(
infoIt
=
=
windows
-
>
end
(
)
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
WindowInfo
*
info
=
infoIt
-
>
second
.
get
(
)
;
info
-
>
mWrNotifierEventsRunnable
=
nullptr
;
if
(
events
-
>
empty
(
)
&
&
!
info
-
>
mPendingWrNotifierEvents
.
empty
(
)
)
{
events
-
>
swap
(
info
-
>
mPendingWrNotifierEvents
)
;
}
}
bool
handleNext
=
true
;
while
(
!
events
-
>
empty
(
)
&
&
handleNext
)
{
auto
&
front
=
events
-
>
front
(
)
;
switch
(
front
.
mTag
)
{
case
WrNotifierEvent
:
:
Tag
:
:
WakeUp
:
WrNotifierEvent_HandleWakeUp
(
aWindowId
front
.
CompositeNeeded
(
)
)
;
handleNext
=
false
;
break
;
case
WrNotifierEvent
:
:
Tag
:
:
NewFrameReady
:
WrNotifierEvent_HandleNewFrameReady
(
aWindowId
front
.
CompositeNeeded
(
)
front
.
PublishId
(
)
)
;
handleNext
=
false
;
break
;
case
WrNotifierEvent
:
:
Tag
:
:
ExternalEvent
:
WrNotifierEvent_HandleExternalEvent
(
aWindowId
front
.
ExternalEvent
(
)
)
;
break
;
}
events
-
>
pop
(
)
;
}
{
auto
windows
=
mWindowInfos
.
Lock
(
)
;
auto
it
=
windows
-
>
find
(
AsUint64
(
aWindowId
)
)
;
if
(
it
=
=
windows
-
>
end
(
)
)
{
return
;
}
WindowInfo
*
info
=
it
-
>
second
.
get
(
)
;
if
(
!
events
-
>
empty
(
)
|
|
!
info
-
>
mPendingWrNotifierEvents
.
empty
(
)
)
{
PostWrNotifierEvents
(
aWindowId
info
)
;
}
}
}
void
RenderThread
:
:
WrNotifierEvent_HandleWakeUp
(
wr
:
:
WindowId
aWindowId
bool
aCompositeNeeded
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
bool
isTrackedFrame
=
false
;
HandleFrameOneDoc
(
aWindowId
aCompositeNeeded
isTrackedFrame
Nothing
(
)
)
;
}
void
RenderThread
:
:
WrNotifierEvent_HandleNewFrameReady
(
wr
:
:
WindowId
aWindowId
bool
aCompositeNeeded
FramePublishId
aPublishId
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
bool
isTrackedFrame
=
true
;
HandleFrameOneDoc
(
aWindowId
aCompositeNeeded
isTrackedFrame
Some
(
aPublishId
)
)
;
}
void
RenderThread
:
:
WrNotifierEvent_HandleExternalEvent
(
wr
:
:
WindowId
aWindowId
UniquePtr
<
RendererEvent
>
aRendererEvent
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
RunEvent
(
aWindowId
std
:
:
move
(
aRendererEvent
)
)
;
}
void
RenderThread
:
:
BeginRecordingForWindow
(
wr
:
:
WindowId
aWindowId
const
TimeStamp
&
aRecordingStart
wr
:
:
PipelineId
aRootPipelineId
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
RendererOGL
*
renderer
=
GetRenderer
(
aWindowId
)
;
MOZ_ASSERT
(
renderer
)
;
renderer
-
>
BeginRecording
(
aRecordingStart
aRootPipelineId
)
;
}
Maybe
<
layers
:
:
FrameRecording
>
RenderThread
:
:
EndRecordingForWindow
(
wr
:
:
WindowId
aWindowId
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
RendererOGL
*
renderer
=
GetRenderer
(
aWindowId
)
;
MOZ_ASSERT
(
renderer
)
;
return
renderer
-
>
EndRecording
(
)
;
}
void
RenderThread
:
:
HandleFrameOneDoc
(
wr
:
:
WindowId
aWindowId
bool
aRender
bool
aTrackedFrame
Maybe
<
FramePublishId
>
aPublishId
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
if
(
mHasShutdown
)
{
return
;
}
HandleFrameOneDocInner
(
aWindowId
aRender
aTrackedFrame
aPublishId
)
;
if
(
aTrackedFrame
)
{
DecPendingFrameCount
(
aWindowId
)
;
}
}
void
RenderThread
:
:
HandleFrameOneDocInner
(
wr
:
:
WindowId
aWindowId
bool
aRender
bool
aTrackedFrame
Maybe
<
FramePublishId
>
aPublishId
)
{
if
(
IsDestroyed
(
aWindowId
)
)
{
return
;
}
if
(
mHandlingDeviceReset
)
{
return
;
}
bool
render
=
aRender
;
PendingFrameInfo
frame
;
if
(
aTrackedFrame
)
{
auto
windows
=
mWindowInfos
.
Lock
(
)
;
auto
it
=
windows
-
>
find
(
AsUint64
(
aWindowId
)
)
;
if
(
it
=
=
windows
-
>
end
(
)
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
WindowInfo
*
info
=
it
-
>
second
.
get
(
)
;
PendingFrameInfo
&
frameInfo
=
info
-
>
mPendingFrames
.
front
(
)
;
frame
=
frameInfo
;
}
else
{
frame
=
{
TimeStamp
:
:
Now
(
)
VsyncId
(
)
}
;
}
glean
:
:
wr
:
:
time_to_render_start
.
AccumulateRawDuration
(
TimeStamp
:
:
Now
(
)
-
frame
.
mStartTime
)
;
HandleRenderTextureOps
(
)
;
if
(
aPublishId
.
isSome
(
)
)
{
SetFramePublishId
(
aWindowId
aPublishId
.
ref
(
)
)
;
}
RendererStats
stats
=
{
0
}
;
UpdateAndRender
(
aWindowId
frame
.
mStartId
frame
.
mStartTime
render
Nothing
(
)
Nothing
(
)
Nothing
(
)
&
stats
)
;
TimeDuration
compositeDuration
=
TimeStamp
:
:
Now
(
)
-
frame
.
mStartTime
;
mozilla
:
:
glean
:
:
gfx
:
:
composite_time
.
AccumulateRawDuration
(
compositeDuration
)
;
PerfStats
:
:
RecordMeasurement
(
PerfStats
:
:
Metric
:
:
Compositing
compositeDuration
)
;
if
(
stats
.
frame_build_time
>
0
.
0
)
{
TimeDuration
fbTime
=
TimeDuration
:
:
FromMilliseconds
(
stats
.
frame_build_time
)
;
mozilla
:
:
glean
:
:
wr
:
:
framebuild_time
.
AccumulateRawDuration
(
fbTime
)
;
PerfStats
:
:
RecordMeasurement
(
PerfStats
:
:
Metric
:
:
FrameBuilding
fbTime
)
;
}
}
void
RenderThread
:
:
SetClearColor
(
wr
:
:
WindowId
aWindowId
wr
:
:
ColorF
aColor
)
{
if
(
mHasShutdown
)
{
return
;
}
if
(
!
IsInRenderThread
(
)
)
{
PostRunnable
(
NewRunnableMethod
<
wr
:
:
WindowId
wr
:
:
ColorF
>
(
"
wr
:
:
RenderThread
:
:
SetClearColor
"
this
&
RenderThread
:
:
SetClearColor
aWindowId
aColor
)
)
;
return
;
}
if
(
IsDestroyed
(
aWindowId
)
)
{
return
;
}
auto
it
=
mRenderers
.
find
(
aWindowId
)
;
MOZ_ASSERT
(
it
!
=
mRenderers
.
end
(
)
)
;
if
(
it
!
=
mRenderers
.
end
(
)
)
{
wr_renderer_set_clear_color
(
it
-
>
second
-
>
GetRenderer
(
)
aColor
)
;
}
}
void
RenderThread
:
:
SetProfilerUI
(
wr
:
:
WindowId
aWindowId
const
nsACString
&
aUI
)
{
if
(
mHasShutdown
)
{
return
;
}
if
(
!
IsInRenderThread
(
)
)
{
PostRunnable
(
NewRunnableMethod
<
wr
:
:
WindowId
nsCString
>
(
"
wr
:
:
RenderThread
:
:
SetProfilerUI
"
this
&
RenderThread
:
:
SetProfilerUI
aWindowId
nsCString
(
aUI
)
)
)
;
return
;
}
auto
it
=
mRenderers
.
find
(
aWindowId
)
;
if
(
it
!
=
mRenderers
.
end
(
)
)
{
it
-
>
second
-
>
SetProfilerUI
(
aUI
)
;
}
}
void
RenderThread
:
:
PostEvent
(
wr
:
:
WindowId
aWindowId
UniquePtr
<
RendererEvent
>
aEvent
)
{
PostRunnable
(
NewRunnableMethod
<
wr
:
:
WindowId
UniquePtr
<
RendererEvent
>
&
&
>
(
"
wr
:
:
RenderThread
:
:
PostEvent
"
this
&
RenderThread
:
:
RunEvent
aWindowId
std
:
:
move
(
aEvent
)
)
)
;
}
void
RenderThread
:
:
RunEvent
(
wr
:
:
WindowId
aWindowId
UniquePtr
<
RendererEvent
>
aEvent
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
aEvent
-
>
Run
(
*
this
aWindowId
)
;
aEvent
=
nullptr
;
}
static
void
NotifyDidRender
(
layers
:
:
CompositorBridgeParent
*
aBridge
const
RefPtr
<
const
WebRenderPipelineInfo
>
&
aInfo
VsyncId
aCompositeStartId
TimeStamp
aCompositeStart
TimeStamp
aRenderStart
TimeStamp
aEnd
bool
aRender
RendererStats
aStats
)
{
if
(
aRender
&
&
aBridge
-
>
GetWrBridge
(
)
)
{
aBridge
-
>
GetWrBridge
(
)
-
>
RecordFrame
(
)
;
}
aBridge
-
>
NotifyDidRender
(
aCompositeStartId
aCompositeStart
aRenderStart
aEnd
&
aStats
)
;
for
(
const
auto
&
epoch
:
aInfo
-
>
Raw
(
)
.
epochs
)
{
aBridge
-
>
NotifyPipelineRendered
(
epoch
.
pipeline_id
epoch
.
epoch
aCompositeStartId
aCompositeStart
aRenderStart
aEnd
&
aStats
)
;
}
if
(
aBridge
-
>
GetWrBridge
(
)
)
{
aBridge
-
>
GetWrBridge
(
)
-
>
RetrySkippedComposite
(
)
;
}
}
static
void
NotifyDidStartRender
(
layers
:
:
CompositorBridgeParent
*
aBridge
)
{
if
(
aBridge
-
>
GetWrBridge
(
)
)
{
aBridge
-
>
GetWrBridge
(
)
-
>
RetrySkippedComposite
(
)
;
}
}
void
RenderThread
:
:
SetFramePublishId
(
wr
:
:
WindowId
aWindowId
FramePublishId
aPublishId
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
auto
it
=
mRenderers
.
find
(
aWindowId
)
;
MOZ_ASSERT
(
it
!
=
mRenderers
.
end
(
)
)
;
if
(
it
=
=
mRenderers
.
end
(
)
)
{
return
;
}
auto
&
renderer
=
it
-
>
second
;
renderer
-
>
SetFramePublishId
(
aPublishId
)
;
}
void
RenderThread
:
:
UpdateAndRender
(
wr
:
:
WindowId
aWindowId
const
VsyncId
&
aStartId
const
TimeStamp
&
aStartTime
bool
aRender
const
Maybe
<
gfx
:
:
IntSize
>
&
aReadbackSize
const
Maybe
<
wr
:
:
ImageFormat
>
&
aReadbackFormat
const
Maybe
<
Range
<
uint8_t
>
>
&
aReadbackBuffer
RendererStats
*
aStats
bool
*
aNeedsYFlip
)
{
AUTO_PROFILER_LABEL
(
"
RenderThread
:
:
UpdateAndRender
"
GRAPHICS
)
;
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
MOZ_ASSERT
(
aRender
|
|
aReadbackBuffer
.
isNothing
(
)
)
;
auto
it
=
mRenderers
.
find
(
aWindowId
)
;
MOZ_ASSERT
(
it
!
=
mRenderers
.
end
(
)
)
;
if
(
it
=
=
mRenderers
.
end
(
)
)
{
return
;
}
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
auto
&
renderer
=
it
-
>
second
;
std
:
:
string
markerName
=
"
Composite
#
"
+
std
:
:
to_string
(
AsUint64
(
aWindowId
)
)
;
AutoProfilerTracing
tracingCompositeMarker
(
"
Paint
"
markerName
.
c_str
(
)
geckoprofiler
:
:
category
:
:
GRAPHICS
Some
(
renderer
-
>
GetCompositorBridge
(
)
-
>
GetInnerWindowId
(
)
)
)
;
if
(
renderer
-
>
IsPaused
(
)
)
{
aRender
=
false
;
}
LOG
(
"
RenderThread
:
:
UpdateAndRender
(
)
aWindowId
%
"
PRIx64
"
aRender
%
d
"
AsUint64
(
aWindowId
)
aRender
)
;
layers
:
:
CompositorThread
(
)
-
>
Dispatch
(
NewRunnableFunction
(
"
NotifyDidStartRenderRunnable
"
&
NotifyDidStartRender
renderer
-
>
GetCompositorBridge
(
)
)
)
;
wr
:
:
RenderedFrameId
latestFrameId
;
if
(
aRender
)
{
latestFrameId
=
renderer
-
>
UpdateAndRender
(
aReadbackSize
aReadbackFormat
aReadbackBuffer
aNeedsYFlip
aStats
)
;
}
else
{
renderer
-
>
Update
(
)
;
}
renderer
-
>
CheckGraphicsResetStatus
(
gfx
:
:
DeviceResetDetectPlace
:
:
WR_POST_UPDATE
false
)
;
TimeStamp
end
=
TimeStamp
:
:
Now
(
)
;
RefPtr
<
const
WebRenderPipelineInfo
>
info
=
renderer
-
>
GetLastPipelineInfo
(
)
;
layers
:
:
CompositorThread
(
)
-
>
Dispatch
(
NewRunnableFunction
(
"
NotifyDidRenderRunnable
"
&
NotifyDidRender
renderer
-
>
GetCompositorBridge
(
)
info
aStartId
aStartTime
start
end
aRender
*
aStats
)
)
;
ipc
:
:
FileDescriptor
fenceFd
;
if
(
latestFrameId
.
IsValid
(
)
)
{
fenceFd
=
renderer
-
>
GetAndResetReleaseFence
(
)
;
auto
timerId
=
glean
:
:
wr
:
:
gpu_wait_time
.
Start
(
)
;
renderer
-
>
WaitForGPU
(
)
;
glean
:
:
wr
:
:
gpu_wait_time
.
StopAndAccumulate
(
std
:
:
move
(
timerId
)
)
;
}
else
{
latestFrameId
=
renderer
-
>
UpdateFrameId
(
)
;
}
RenderedFrameId
lastCompletedFrameId
=
renderer
-
>
GetLastCompletedFrameId
(
)
;
RefPtr
<
layers
:
:
AsyncImagePipelineManager
>
pipelineMgr
=
renderer
-
>
GetCompositorBridge
(
)
-
>
GetAsyncImagePipelineManager
(
)
;
MOZ_ASSERT
(
pipelineMgr
)
;
pipelineMgr
-
>
NotifyPipelinesUpdated
(
info
latestFrameId
lastCompletedFrameId
std
:
:
move
(
fenceFd
)
)
;
}
void
RenderThread
:
:
Pause
(
wr
:
:
WindowId
aWindowId
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
LOG
(
"
RenderThread
:
:
Pause
(
)
aWindowId
%
"
PRIx64
"
"
AsUint64
(
aWindowId
)
)
;
auto
it
=
mRenderers
.
find
(
aWindowId
)
;
MOZ_ASSERT
(
it
!
=
mRenderers
.
end
(
)
)
;
if
(
it
=
=
mRenderers
.
end
(
)
)
{
gfxCriticalNote
<
<
"
RenderThread
cannot
find
renderer
for
window
"
<
<
gfx
:
:
hexa
(
aWindowId
)
<
<
"
to
pause
.
"
;
return
;
}
auto
&
renderer
=
it
-
>
second
;
renderer
-
>
Pause
(
)
;
UpdateActiveRendererCount
(
)
;
}
bool
RenderThread
:
:
Resume
(
wr
:
:
WindowId
aWindowId
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
LOG
(
"
enderThread
:
:
Resume
(
)
aWindowId
%
"
PRIx64
"
"
AsUint64
(
aWindowId
)
)
;
auto
it
=
mRenderers
.
find
(
aWindowId
)
;
MOZ_ASSERT
(
it
!
=
mRenderers
.
end
(
)
)
;
if
(
it
=
=
mRenderers
.
end
(
)
)
{
gfxCriticalNote
<
<
"
RenderThread
cannot
find
renderer
for
window
"
<
<
gfx
:
:
hexa
(
aWindowId
)
<
<
"
to
resume
.
"
;
return
false
;
}
auto
&
renderer
=
it
-
>
second
;
bool
resumed
=
renderer
-
>
Resume
(
)
;
UpdateActiveRendererCount
(
)
;
return
resumed
;
}
bool
RenderThread
:
:
TooManyPendingFrames
(
wr
:
:
WindowId
aWindowId
)
{
const
int64_t
maxFrameCount
=
1
;
auto
windows
=
mWindowInfos
.
Lock
(
)
;
auto
it
=
windows
-
>
find
(
AsUint64
(
aWindowId
)
)
;
if
(
it
=
=
windows
-
>
end
(
)
)
{
MOZ_ASSERT
(
false
)
;
return
true
;
}
WindowInfo
*
info
=
it
-
>
second
.
get
(
)
;
if
(
info
-
>
PendingCount
(
)
>
maxFrameCount
)
{
return
true
;
}
return
info
-
>
mPendingFrameBuild
>
0
;
}
bool
RenderThread
:
:
IsDestroyed
(
wr
:
:
WindowId
aWindowId
)
{
auto
windows
=
mWindowInfos
.
Lock
(
)
;
auto
it
=
windows
-
>
find
(
AsUint64
(
aWindowId
)
)
;
if
(
it
=
=
windows
-
>
end
(
)
)
{
return
true
;
}
return
it
-
>
second
-
>
mIsDestroyed
;
}
void
RenderThread
:
:
SetDestroyed
(
wr
:
:
WindowId
aWindowId
)
{
auto
windows
=
mWindowInfos
.
Lock
(
)
;
auto
it
=
windows
-
>
find
(
AsUint64
(
aWindowId
)
)
;
if
(
it
=
=
windows
-
>
end
(
)
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
it
-
>
second
-
>
mIsDestroyed
=
true
;
}
void
RenderThread
:
:
IncPendingFrameCount
(
wr
:
:
WindowId
aWindowId
const
VsyncId
&
aStartId
const
TimeStamp
&
aStartTime
)
{
auto
windows
=
mWindowInfos
.
Lock
(
)
;
auto
it
=
windows
-
>
find
(
AsUint64
(
aWindowId
)
)
;
if
(
it
=
=
windows
-
>
end
(
)
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
it
-
>
second
-
>
mPendingFrameBuild
+
+
;
it
-
>
second
-
>
mPendingFrames
.
push
(
PendingFrameInfo
{
aStartTime
aStartId
}
)
;
}
void
RenderThread
:
:
DecPendingFrameBuildCount
(
wr
:
:
WindowId
aWindowId
)
{
auto
windows
=
mWindowInfos
.
Lock
(
)
;
auto
it
=
windows
-
>
find
(
AsUint64
(
aWindowId
)
)
;
if
(
it
=
=
windows
-
>
end
(
)
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
WindowInfo
*
info
=
it
-
>
second
.
get
(
)
;
MOZ_RELEASE_ASSERT
(
info
-
>
mPendingFrameBuild
>
=
1
)
;
info
-
>
mPendingFrameBuild
-
-
;
}
void
RenderThread
:
:
DecPendingFrameCount
(
wr
:
:
WindowId
aWindowId
)
{
auto
windows
=
mWindowInfos
.
Lock
(
)
;
auto
it
=
windows
-
>
find
(
AsUint64
(
aWindowId
)
)
;
if
(
it
=
=
windows
-
>
end
(
)
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
WindowInfo
*
info
=
it
-
>
second
.
get
(
)
;
info
-
>
mPendingFrames
.
pop
(
)
;
}
void
RenderThread
:
:
RegisterExternalImage
(
const
wr
:
:
ExternalImageId
&
aExternalImageId
already_AddRefed
<
RenderTextureHost
>
aTexture
)
{
MutexAutoLock
lock
(
mRenderTextureMapLock
)
;
if
(
mHasShutdown
)
{
return
;
}
MOZ_ASSERT
(
mRenderTextures
.
find
(
aExternalImageId
)
=
=
mRenderTextures
.
end
(
)
)
;
RefPtr
<
RenderTextureHost
>
texture
=
aTexture
;
if
(
texture
-
>
SyncObjectNeeded
(
)
)
{
mSyncObjectNeededRenderTextures
.
emplace
(
aExternalImageId
texture
)
;
}
mRenderTextures
.
emplace
(
aExternalImageId
texture
)
;
#
ifdef
DEBUG
int32_t
maxAllowedIncrease
=
StaticPrefs
:
:
gfx_testing_assert_render_textures_increase
(
)
;
if
(
maxAllowedIncrease
<
=
0
)
{
mRenderTexturesLastTime
=
-
1
;
}
else
{
if
(
mRenderTexturesLastTime
<
0
)
{
mRenderTexturesLastTime
=
static_cast
<
int32_t
>
(
mRenderTextures
.
size
(
)
)
;
}
MOZ_ASSERT
(
(
static_cast
<
int32_t
>
(
mRenderTextures
.
size
(
)
)
-
mRenderTexturesLastTime
)
<
maxAllowedIncrease
)
;
}
#
endif
}
void
RenderThread
:
:
UnregisterExternalImage
(
const
wr
:
:
ExternalImageId
&
aExternalImageId
)
{
MutexAutoLock
lock
(
mRenderTextureMapLock
)
;
if
(
mHasShutdown
)
{
return
;
}
auto
it
=
mRenderTextures
.
find
(
aExternalImageId
)
;
if
(
it
=
=
mRenderTextures
.
end
(
)
)
{
return
;
}
auto
&
texture
=
it
-
>
second
;
if
(
texture
-
>
SyncObjectNeeded
(
)
)
{
MOZ_RELEASE_ASSERT
(
mSyncObjectNeededRenderTextures
.
erase
(
aExternalImageId
)
=
=
1
)
;
}
if
(
!
IsInRenderThread
(
)
)
{
RefPtr
<
RenderTextureHost
>
texture
=
it
-
>
second
;
mRenderTextures
.
erase
(
it
)
;
mRenderTexturesDeferred
.
emplace_back
(
std
:
:
move
(
texture
)
)
;
PostRunnable
(
NewRunnableMethod
(
"
RenderThread
:
:
DeferredRenderTextureHostDestroy
"
this
&
RenderThread
:
:
DeferredRenderTextureHostDestroy
)
)
;
}
else
{
mRenderTextures
.
erase
(
it
)
;
}
}
void
RenderThread
:
:
DestroyExternalImagesSyncWait
(
const
std
:
:
vector
<
wr
:
:
ExternalImageId
>
&
&
aIds
)
{
if
(
!
IsInRenderThread
(
)
)
{
layers
:
:
SynchronousTask
task
(
"
Destroy
external
images
"
)
;
RefPtr
<
Runnable
>
runnable
=
NS_NewRunnableFunction
(
"
RenderThread
:
:
DestroyExternalImagesSyncWait
:
:
Runnable
"
[
&
task
ids
=
std
:
:
move
(
aIds
)
]
(
)
{
layers
:
:
AutoCompleteTask
complete
(
&
task
)
;
RenderThread
:
:
Get
(
)
-
>
DestroyExternalImages
(
std
:
:
move
(
ids
)
)
;
}
)
;
PostRunnable
(
runnable
.
forget
(
)
)
;
task
.
Wait
(
)
;
return
;
}
DestroyExternalImages
(
std
:
:
move
(
aIds
)
)
;
}
void
RenderThread
:
:
DestroyExternalImages
(
const
std
:
:
vector
<
wr
:
:
ExternalImageId
>
&
&
aIds
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
std
:
:
vector
<
RefPtr
<
RenderTextureHost
>
>
hosts
;
{
MutexAutoLock
lock
(
mRenderTextureMapLock
)
;
if
(
mHasShutdown
)
{
return
;
}
for
(
auto
&
id
:
aIds
)
{
auto
it
=
mRenderTextures
.
find
(
id
)
;
if
(
it
=
=
mRenderTextures
.
end
(
)
)
{
continue
;
}
hosts
.
emplace_back
(
it
-
>
second
)
;
}
}
for
(
auto
&
host
:
hosts
)
{
host
-
>
Destroy
(
)
;
}
}
void
RenderThread
:
:
PrepareForUse
(
const
wr
:
:
ExternalImageId
&
aExternalImageId
)
{
AddRenderTextureOp
(
RenderTextureOp
:
:
PrepareForUse
aExternalImageId
)
;
}
void
RenderThread
:
:
NotifyNotUsed
(
const
wr
:
:
ExternalImageId
&
aExternalImageId
)
{
AddRenderTextureOp
(
RenderTextureOp
:
:
NotifyNotUsed
aExternalImageId
)
;
}
void
RenderThread
:
:
NotifyForUse
(
const
wr
:
:
ExternalImageId
&
aExternalImageId
)
{
AddRenderTextureOp
(
RenderTextureOp
:
:
NotifyForUse
aExternalImageId
)
;
}
void
RenderThread
:
:
AddRenderTextureOp
(
RenderTextureOp
aOp
const
wr
:
:
ExternalImageId
&
aExternalImageId
)
{
MOZ_ASSERT
(
!
IsInRenderThread
(
)
)
;
MutexAutoLock
lock
(
mRenderTextureMapLock
)
;
auto
it
=
mRenderTextures
.
find
(
aExternalImageId
)
;
MOZ_ASSERT
(
it
!
=
mRenderTextures
.
end
(
)
)
;
if
(
it
=
=
mRenderTextures
.
end
(
)
)
{
return
;
}
RefPtr
<
RenderTextureHost
>
texture
=
it
-
>
second
;
mRenderTextureOps
.
emplace_back
(
aOp
std
:
:
move
(
texture
)
)
;
if
(
mRenderTextureOpsRunnable
)
{
return
;
}
RefPtr
<
nsIRunnable
>
runnable
=
NewRunnableMethod
(
"
RenderThread
:
:
HandleRenderTextureOps
"
this
&
RenderThread
:
:
HandleRenderTextureOps
)
;
mRenderTextureOpsRunnable
=
runnable
;
PostRunnable
(
runnable
.
forget
(
)
)
;
}
void
RenderThread
:
:
HandleRenderTextureOps
(
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
std
:
:
list
<
std
:
:
pair
<
RenderTextureOp
RefPtr
<
RenderTextureHost
>
>
>
renderTextureOps
;
{
MutexAutoLock
lock
(
mRenderTextureMapLock
)
;
mRenderTextureOps
.
swap
(
renderTextureOps
)
;
mRenderTextureOpsRunnable
=
nullptr
;
}
for
(
auto
&
it
:
renderTextureOps
)
{
switch
(
it
.
first
)
{
case
RenderTextureOp
:
:
PrepareForUse
:
it
.
second
-
>
PrepareForUse
(
)
;
break
;
case
RenderTextureOp
:
:
NotifyForUse
:
it
.
second
-
>
NotifyForUse
(
)
;
break
;
case
RenderTextureOp
:
:
NotifyNotUsed
:
it
.
second
-
>
NotifyNotUsed
(
)
;
break
;
}
}
}
RefPtr
<
RenderTextureHostUsageInfo
>
RenderThread
:
:
GetOrMergeUsageInfo
(
const
wr
:
:
ExternalImageId
&
aExternalImageId
RefPtr
<
RenderTextureHostUsageInfo
>
aUsageInfo
)
{
MutexAutoLock
lock
(
mRenderTextureMapLock
)
;
if
(
mHasShutdown
)
{
return
nullptr
;
}
auto
it
=
mRenderTextures
.
find
(
aExternalImageId
)
;
if
(
it
=
=
mRenderTextures
.
end
(
)
)
{
return
nullptr
;
}
auto
&
texture
=
it
-
>
second
;
return
texture
-
>
GetOrMergeUsageInfo
(
lock
aUsageInfo
)
;
}
void
RenderThread
:
:
UnregisterExternalImageDuringShutdown
(
const
wr
:
:
ExternalImageId
&
aExternalImageId
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
MutexAutoLock
lock
(
mRenderTextureMapLock
)
;
MOZ_ASSERT
(
mHasShutdown
)
;
mRenderTextures
.
erase
(
aExternalImageId
)
;
}
bool
RenderThread
:
:
SyncObjectNeeded
(
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
MutexAutoLock
lock
(
mRenderTextureMapLock
)
;
return
!
mSyncObjectNeededRenderTextures
.
empty
(
)
;
}
void
RenderThread
:
:
DeferredRenderTextureHostDestroy
(
)
{
MutexAutoLock
lock
(
mRenderTextureMapLock
)
;
mRenderTexturesDeferred
.
clear
(
)
;
}
RenderTextureHost
*
RenderThread
:
:
GetRenderTexture
(
const
wr
:
:
ExternalImageId
&
aExternalImageId
)
{
MutexAutoLock
lock
(
mRenderTextureMapLock
)
;
auto
it
=
mRenderTextures
.
find
(
aExternalImageId
)
;
MOZ_ASSERT
(
it
!
=
mRenderTextures
.
end
(
)
)
;
if
(
it
=
=
mRenderTextures
.
end
(
)
)
{
return
nullptr
;
}
return
it
-
>
second
;
}
std
:
:
tuple
<
RenderTextureHost
*
RefPtr
<
RenderTextureHostUsageInfo
>
>
RenderThread
:
:
GetRenderTextureAndUsageInfo
(
const
wr
:
:
ExternalImageId
&
aExternalImageId
)
{
MutexAutoLock
lock
(
mRenderTextureMapLock
)
;
auto
it
=
mRenderTextures
.
find
(
aExternalImageId
)
;
MOZ_ASSERT
(
it
!
=
mRenderTextures
.
end
(
)
)
;
if
(
it
=
=
mRenderTextures
.
end
(
)
)
{
return
{
}
;
}
return
{
it
-
>
second
it
-
>
second
-
>
GetTextureHostUsageInfo
(
lock
)
}
;
}
void
RenderThread
:
:
InitDeviceTask
(
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
MOZ_ASSERT
(
!
mSingletonGL
)
;
LOG
(
"
RenderThread
:
:
InitDeviceTask
(
)
"
)
;
if
(
gfx
:
:
gfxVars
:
:
UseSoftwareWebRender
(
)
)
{
return
;
}
nsAutoCString
err
;
CreateSingletonGL
(
err
)
;
if
(
gfx
:
:
gfxVars
:
:
UseWebRenderProgramBinaryDisk
(
)
)
{
mProgramCache
=
MakeUnique
<
WebRenderProgramCache
>
(
ThreadPool
(
)
.
Raw
(
)
)
;
}
SingletonGL
(
)
;
}
void
RenderThread
:
:
PostRunnable
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
aRunnable
;
mThread
-
>
Dispatch
(
runnable
.
forget
(
)
)
;
}
void
RenderThread
:
:
HandleDeviceReset
(
gfx
:
:
DeviceResetDetectPlace
aPlace
gfx
:
:
DeviceResetReason
aReason
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
if
(
aReason
=
=
gfx
:
:
DeviceResetReason
:
:
FORCED_RESET
)
{
if
(
!
mHandlingDeviceReset
)
{
mHandlingDeviceReset
=
true
;
MutexAutoLock
lock
(
mRenderTextureMapLock
)
;
mRenderTexturesDeferred
.
clear
(
)
;
for
(
const
auto
&
entry
:
mRenderTextures
)
{
entry
.
second
-
>
ClearCachedResources
(
)
;
}
gfx
:
:
GPUProcessManager
:
:
GPUProcessManager
:
:
NotifyDeviceReset
(
gfx
:
:
DeviceResetReason
:
:
FORCED_RESET
aPlace
)
;
}
return
;
}
if
(
mHandlingDeviceReset
)
{
return
;
}
mHandlingDeviceReset
=
true
;
#
ifndef
XP_WIN
gfx
:
:
GPUProcessManager
:
:
RecordDeviceReset
(
aReason
)
;
#
endif
{
MutexAutoLock
lock
(
mRenderTextureMapLock
)
;
mRenderTexturesDeferred
.
clear
(
)
;
for
(
const
auto
&
entry
:
mRenderTextures
)
{
entry
.
second
-
>
ClearCachedResources
(
)
;
}
}
if
(
XRE_IsGPUProcess
(
)
)
{
gfx
:
:
GPUProcessManager
:
:
GPUProcessManager
:
:
NotifyDeviceReset
(
aReason
aPlace
)
;
}
else
{
#
ifndef
XP_WIN
gfx
:
:
GPUProcessManager
:
:
GPUProcessManager
:
:
NotifyDeviceReset
(
aReason
aPlace
)
;
#
endif
}
}
bool
RenderThread
:
:
IsHandlingDeviceReset
(
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
return
mHandlingDeviceReset
;
}
void
RenderThread
:
:
SimulateDeviceReset
(
)
{
if
(
!
IsInRenderThread
(
)
)
{
PostRunnable
(
NewRunnableMethod
(
"
RenderThread
:
:
SimulateDeviceReset
"
this
&
RenderThread
:
:
SimulateDeviceReset
)
)
;
}
else
{
HandleDeviceReset
(
gfx
:
:
DeviceResetDetectPlace
:
:
WR_SIMULATE
gfx
:
:
DeviceResetReason
:
:
FORCED_RESET
)
;
}
}
static
void
DoNotifyWebRenderError
(
WebRenderError
aError
)
{
layers
:
:
CompositorManagerParent
:
:
NotifyWebRenderError
(
aError
)
;
}
void
RenderThread
:
:
NotifyWebRenderError
(
WebRenderError
aError
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
layers
:
:
CompositorThread
(
)
-
>
Dispatch
(
NewRunnableFunction
(
"
DoNotifyWebRenderErrorRunnable
"
&
DoNotifyWebRenderError
aError
)
)
;
}
void
RenderThread
:
:
HandleWebRenderError
(
WebRenderError
aError
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
if
(
mHandlingWebRenderError
)
{
return
;
}
NotifyWebRenderError
(
aError
)
;
{
MutexAutoLock
lock
(
mRenderTextureMapLock
)
;
mRenderTexturesDeferred
.
clear
(
)
;
for
(
const
auto
&
entry
:
mRenderTextures
)
{
entry
.
second
-
>
ClearCachedResources
(
)
;
}
}
mHandlingWebRenderError
=
true
;
}
bool
RenderThread
:
:
IsHandlingWebRenderError
(
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
return
mHandlingWebRenderError
;
}
gl
:
:
GLContext
*
RenderThread
:
:
SingletonGL
(
)
{
nsAutoCString
err
;
auto
*
gl
=
SingletonGL
(
err
)
;
if
(
!
err
.
IsEmpty
(
)
)
{
gfxCriticalNote
<
<
err
.
get
(
)
;
}
return
gl
;
}
void
RenderThread
:
:
CreateSingletonGL
(
nsACString
&
aError
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
LOG
(
"
RenderThread
:
:
CreateSingletonGL
(
)
"
)
;
mSingletonGL
=
CreateGLContext
(
aError
)
;
mSingletonGLIsForHardwareWebRender
=
!
gfx
:
:
gfxVars
:
:
UseSoftwareWebRender
(
)
;
}
gl
:
:
GLContext
*
RenderThread
:
:
SingletonGL
(
nsACString
&
aError
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
if
(
!
mSingletonGL
)
{
CreateSingletonGL
(
aError
)
;
mShaders
=
nullptr
;
}
if
(
mSingletonGL
&
&
mSingletonGLIsForHardwareWebRender
&
&
!
mShaders
)
{
mShaders
=
MakeUnique
<
WebRenderShaders
>
(
mSingletonGL
mProgramCache
.
get
(
)
)
;
}
return
mSingletonGL
.
get
(
)
;
}
gl
:
:
GLContext
*
RenderThread
:
:
SingletonGLForCompositorOGL
(
)
{
MOZ_RELEASE_ASSERT
(
gfx
:
:
gfxVars
:
:
UseSoftwareWebRender
(
)
)
;
if
(
mSingletonGLIsForHardwareWebRender
)
{
ClearSingletonGL
(
)
;
}
return
SingletonGL
(
)
;
}
void
RenderThread
:
:
ClearSingletonGL
(
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
LOG
(
"
RenderThread
:
:
ClearSingletonGL
(
)
"
)
;
if
(
mSurfacePool
)
{
mSurfacePool
-
>
DestroyGLResourcesForContext
(
mSingletonGL
)
;
}
if
(
mProgramsForCompositorOGL
)
{
mProgramsForCompositorOGL
-
>
Clear
(
)
;
mProgramsForCompositorOGL
=
nullptr
;
}
if
(
mShaders
)
{
if
(
mSingletonGL
)
{
mSingletonGL
-
>
MakeCurrent
(
)
;
}
mShaders
=
nullptr
;
}
mSingletonGL
=
nullptr
;
}
RefPtr
<
layers
:
:
ShaderProgramOGLsHolder
>
RenderThread
:
:
GetProgramsForCompositorOGL
(
)
{
if
(
!
mSingletonGL
)
{
return
nullptr
;
}
if
(
!
mProgramsForCompositorOGL
)
{
mProgramsForCompositorOGL
=
MakeAndAddRef
<
layers
:
:
ShaderProgramOGLsHolder
>
(
mSingletonGL
)
;
}
return
mProgramsForCompositorOGL
;
}
RefPtr
<
layers
:
:
SurfacePool
>
RenderThread
:
:
SharedSurfacePool
(
)
{
#
if
defined
(
XP_DARWIN
)
|
|
defined
(
MOZ_WAYLAND
)
if
(
!
mSurfacePool
)
{
size_t
poolSizeLimit
=
StaticPrefs
:
:
gfx_webrender_compositor_surface_pool_size_AtStartup
(
)
;
mSurfacePool
=
layers
:
:
SurfacePool
:
:
Create
(
poolSizeLimit
)
;
}
#
endif
return
mSurfacePool
;
}
void
RenderThread
:
:
ClearSharedSurfacePool
(
)
{
mSurfacePool
=
nullptr
;
}
static
void
GLAPIENTRY
DebugMessageCallback
(
GLenum
aSource
GLenum
aType
GLuint
aId
GLenum
aSeverity
GLsizei
aLength
const
GLchar
*
aMessage
const
GLvoid
*
aUserParam
)
{
constexpr
const
char
*
kContextLost
=
"
Context
has
been
lost
.
"
;
if
(
StaticPrefs
:
:
gfx_webrender_gl_debug_message_critical_note_AtStartup
(
)
&
&
aSeverity
=
=
LOCAL_GL_DEBUG_SEVERITY_HIGH
)
{
auto
message
=
std
:
:
string
(
aMessage
aLength
)
;
if
(
message
!
=
kContextLost
)
{
gfxCriticalNote
<
<
message
;
}
else
{
gfxCriticalNoteOnce
<
<
message
;
}
}
if
(
StaticPrefs
:
:
gfx_webrender_gl_debug_message_print_AtStartup
(
)
)
{
gl
:
:
GLContext
*
gl
=
(
gl
:
:
GLContext
*
)
aUserParam
;
gl
-
>
DebugCallback
(
aSource
aType
aId
aSeverity
aLength
aMessage
)
;
}
}
void
RenderThread
:
:
MaybeEnableGLDebugMessage
(
gl
:
:
GLContext
*
aGLContext
)
{
if
(
!
aGLContext
)
{
return
;
}
bool
enableDebugMessage
=
StaticPrefs
:
:
gfx_webrender_gl_debug_message_critical_note_AtStartup
(
)
|
|
StaticPrefs
:
:
gfx_webrender_gl_debug_message_print_AtStartup
(
)
;
if
(
enableDebugMessage
&
&
aGLContext
-
>
IsExtensionSupported
(
gl
:
:
GLContext
:
:
KHR_debug
)
)
{
aGLContext
-
>
fEnable
(
LOCAL_GL_DEBUG_OUTPUT
)
;
aGLContext
-
>
fDisable
(
LOCAL_GL_DEBUG_OUTPUT_SYNCHRONOUS
)
;
aGLContext
-
>
fDebugMessageCallback
(
&
DebugMessageCallback
(
void
*
)
aGLContext
)
;
aGLContext
-
>
fDebugMessageControl
(
LOCAL_GL_DONT_CARE
LOCAL_GL_DONT_CARE
LOCAL_GL_DONT_CARE
0
nullptr
true
)
;
}
}
WebRenderShaders
:
:
WebRenderShaders
(
gl
:
:
GLContext
*
gl
WebRenderProgramCache
*
programCache
)
{
mGL
=
gl
;
mShaders
=
wr_shaders_new
(
gl
programCache
?
programCache
-
>
Raw
(
)
:
nullptr
StaticPrefs
:
:
gfx_webrender_precache_shaders_AtStartup
(
)
)
;
}
WebRenderShaders
:
:
~
WebRenderShaders
(
)
{
wr_shaders_delete
(
mShaders
mGL
.
get
(
)
)
;
}
WebRenderThreadPool
:
:
WebRenderThreadPool
(
bool
low_priority
)
{
mThreadPool
=
wr_thread_pool_new
(
low_priority
)
;
}
WebRenderThreadPool
:
:
~
WebRenderThreadPool
(
)
{
Release
(
)
;
}
void
WebRenderThreadPool
:
:
Release
(
)
{
if
(
mThreadPool
)
{
wr_thread_pool_delete
(
mThreadPool
)
;
mThreadPool
=
nullptr
;
}
}
MaybeWebRenderGlyphRasterThread
:
:
MaybeWebRenderGlyphRasterThread
(
bool
aEnable
)
{
if
(
aEnable
)
{
mThread
=
wr_glyph_raster_thread_new
(
)
;
}
else
{
mThread
=
nullptr
;
}
}
MaybeWebRenderGlyphRasterThread
:
:
~
MaybeWebRenderGlyphRasterThread
(
)
{
if
(
mThread
)
{
wr_glyph_raster_thread_delete
(
mThread
)
;
}
}
WebRenderProgramCache
:
:
WebRenderProgramCache
(
wr
:
:
WrThreadPool
*
aThreadPool
)
{
MOZ_ASSERT
(
aThreadPool
)
;
nsAutoString
path
;
if
(
gfx
:
:
gfxVars
:
:
UseWebRenderProgramBinaryDisk
(
)
)
{
path
.
Append
(
gfx
:
:
gfxVars
:
:
ProfDirectory
(
)
)
;
}
mProgramCache
=
wr_program_cache_new
(
&
path
aThreadPool
)
;
if
(
gfx
:
:
gfxVars
:
:
UseWebRenderProgramBinaryDisk
(
)
)
{
wr_try_load_startup_shaders_from_disk
(
mProgramCache
)
;
}
}
WebRenderProgramCache
:
:
~
WebRenderProgramCache
(
)
{
wr_program_cache_delete
(
mProgramCache
)
;
}
}
#
ifdef
XP_WIN
static
already_AddRefed
<
gl
:
:
GLContext
>
CreateGLContextANGLE
(
nsACString
&
aError
)
{
const
RefPtr
<
ID3D11Device
>
d3d11Device
=
gfx
:
:
DeviceManagerDx
:
:
Get
(
)
-
>
GetCompositorDevice
(
)
;
if
(
!
d3d11Device
)
{
aError
.
Assign
(
"
RcANGLE
(
no
compositor
device
for
EGLDisplay
)
"
_ns
)
;
return
nullptr
;
}
nsCString
failureId
;
const
auto
lib
=
gl
:
:
GLLibraryEGL
:
:
Get
(
&
failureId
)
;
if
(
!
lib
)
{
aError
.
Assign
(
nsPrintfCString
(
"
RcANGLE
(
load
EGL
lib
failed
:
%
s
)
"
failureId
.
get
(
)
)
)
;
return
nullptr
;
}
const
auto
egl
=
lib
-
>
CreateDisplay
(
d3d11Device
.
get
(
)
)
;
if
(
!
egl
)
{
aError
.
Assign
(
nsPrintfCString
(
"
RcANGLE
(
create
EGLDisplay
failed
:
%
s
)
"
failureId
.
get
(
)
)
)
;
return
nullptr
;
}
gl
:
:
CreateContextFlags
flags
=
gl
:
:
CreateContextFlags
:
:
PREFER_ES3
;
if
(
StaticPrefs
:
:
gfx_webrender_prefer_robustness_AtStartup
(
)
)
{
flags
|
=
gl
:
:
CreateContextFlags
:
:
PREFER_ROBUSTNESS
;
}
if
(
egl
-
>
IsExtensionSupported
(
gl
:
:
EGLExtension
:
:
MOZ_create_context_provoking_vertex_dont_care
)
)
{
flags
|
=
gl
:
:
CreateContextFlags
:
:
PROVOKING_VERTEX_DONT_CARE
;
}
auto
gl
=
gl
:
:
GLContextEGL
:
:
CreateWithoutSurface
(
egl
{
flags
}
&
failureId
)
;
if
(
!
gl
|
|
!
gl
-
>
IsANGLE
(
)
)
{
aError
.
Assign
(
nsPrintfCString
(
"
RcANGLE
(
create
GL
context
failed
:
%
p
%
s
)
"
gl
.
get
(
)
failureId
.
get
(
)
)
)
;
return
nullptr
;
}
if
(
!
gl
-
>
MakeCurrent
(
)
)
{
aError
.
Assign
(
nsPrintfCString
(
"
RcANGLE
(
make
current
GL
context
failed
:
%
p
%
x
)
"
gl
.
get
(
)
gl
-
>
mEgl
-
>
mLib
-
>
fGetError
(
)
)
)
;
return
nullptr
;
}
return
gl
.
forget
(
)
;
}
#
endif
#
if
defined
(
MOZ_WIDGET_ANDROID
)
|
|
defined
(
MOZ_WIDGET_GTK
)
static
already_AddRefed
<
gl
:
:
GLContext
>
CreateGLContextEGL
(
)
{
bool
forHardwareWebRender
=
true
;
if
(
gfx
:
:
gfxVars
:
:
UseSoftwareWebRender
(
)
)
{
forHardwareWebRender
=
false
;
}
RefPtr
<
gl
:
:
GLContext
>
gl
=
gl
:
:
GLContextProviderEGL
:
:
CreateForCompositorWidget
(
nullptr
forHardwareWebRender
true
)
;
if
(
!
gl
|
|
!
gl
-
>
MakeCurrent
(
)
)
{
gfxCriticalNote
<
<
"
Failed
GL
context
creation
for
hardware
WebRender
:
"
<
<
forHardwareWebRender
;
return
nullptr
;
}
return
gl
.
forget
(
)
;
}
#
endif
#
ifdef
XP_DARWIN
static
already_AddRefed
<
gl
:
:
GLContext
>
CreateGLContextCGL
(
)
{
nsCString
failureUnused
;
return
gl
:
:
GLContextProvider
:
:
CreateHeadless
(
{
gl
:
:
CreateContextFlags
:
:
ALLOW_OFFLINE_RENDERER
|
gl
:
:
CreateContextFlags
:
:
FORBID_SOFTWARE
}
&
failureUnused
)
;
}
#
endif
static
already_AddRefed
<
gl
:
:
GLContext
>
CreateGLContext
(
nsACString
&
aError
)
{
RefPtr
<
gl
:
:
GLContext
>
gl
;
#
ifdef
XP_WIN
if
(
gfx
:
:
gfxVars
:
:
UseWebRenderANGLE
(
)
)
{
gl
=
CreateGLContextANGLE
(
aError
)
;
}
#
elif
defined
(
MOZ_WIDGET_ANDROID
)
gl
=
CreateGLContextEGL
(
)
;
#
elif
defined
(
MOZ_WIDGET_GTK
)
if
(
gfx
:
:
gfxVars
:
:
UseEGL
(
)
)
{
gl
=
CreateGLContextEGL
(
)
;
}
#
elif
XP_DARWIN
gl
=
CreateGLContextCGL
(
)
;
#
endif
wr
:
:
RenderThread
:
:
MaybeEnableGLDebugMessage
(
gl
)
;
return
gl
.
forget
(
)
;
}
extern
"
C
"
{
void
wr_notifier_wake_up
(
mozilla
:
:
wr
:
:
WrWindowId
aWindowId
bool
aCompositeNeeded
)
{
mozilla
:
:
wr
:
:
RenderThread
:
:
Get
(
)
-
>
WrNotifierEvent_WakeUp
(
aWindowId
aCompositeNeeded
)
;
}
void
wr_notifier_new_frame_ready
(
mozilla
:
:
wr
:
:
WrWindowId
aWindowId
bool
aCompositeNeeded
mozilla
:
:
wr
:
:
FramePublishId
aPublishId
)
{
auto
*
renderThread
=
mozilla
:
:
wr
:
:
RenderThread
:
:
Get
(
)
;
renderThread
-
>
DecPendingFrameBuildCount
(
aWindowId
)
;
renderThread
-
>
WrNotifierEvent_NewFrameReady
(
aWindowId
aCompositeNeeded
aPublishId
)
;
}
void
wr_notifier_external_event
(
mozilla
:
:
wr
:
:
WrWindowId
aWindowId
size_t
aRawEvent
)
{
mozilla
:
:
wr
:
:
RenderThread
:
:
Get
(
)
-
>
WrNotifierEvent_ExternalEvent
(
mozilla
:
:
wr
:
:
WindowId
(
aWindowId
)
aRawEvent
)
;
}
static
void
NotifyScheduleRender
(
mozilla
:
:
wr
:
:
WrWindowId
aWindowId
wr
:
:
RenderReasons
aReasons
)
{
RefPtr
<
mozilla
:
:
layers
:
:
CompositorBridgeParent
>
cbp
=
mozilla
:
:
layers
:
:
CompositorBridgeParent
:
:
GetCompositorBridgeParentFromWindowId
(
aWindowId
)
;
if
(
cbp
)
{
cbp
-
>
ScheduleComposition
(
aReasons
)
;
}
}
void
wr_schedule_render
(
mozilla
:
:
wr
:
:
WrWindowId
aWindowId
wr
:
:
RenderReasons
aReasons
)
{
layers
:
:
CompositorThread
(
)
-
>
Dispatch
(
NewRunnableFunction
(
"
NotifyScheduleRender
"
&
NotifyScheduleRender
aWindowId
aReasons
)
)
;
}
static
void
NotifyDidSceneBuild
(
mozilla
:
:
wr
:
:
WrWindowId
aWindowId
const
RefPtr
<
const
wr
:
:
WebRenderPipelineInfo
>
&
aInfo
)
{
RefPtr
<
mozilla
:
:
layers
:
:
CompositorBridgeParent
>
cbp
=
mozilla
:
:
layers
:
:
CompositorBridgeParent
:
:
GetCompositorBridgeParentFromWindowId
(
aWindowId
)
;
if
(
cbp
)
{
cbp
-
>
NotifyDidSceneBuild
(
aInfo
)
;
}
}
void
wr_finished_scene_build
(
mozilla
:
:
wr
:
:
WrWindowId
aWindowId
mozilla
:
:
wr
:
:
WrPipelineInfo
*
aPipelineInfo
)
{
RefPtr
<
wr
:
:
WebRenderPipelineInfo
>
info
=
new
wr
:
:
WebRenderPipelineInfo
(
)
;
info
-
>
Raw
(
)
=
std
:
:
move
(
*
aPipelineInfo
)
;
layers
:
:
CompositorThread
(
)
-
>
Dispatch
(
NewRunnableFunction
(
"
NotifyDidSceneBuild
"
&
NotifyDidSceneBuild
aWindowId
info
)
)
;
}
}
