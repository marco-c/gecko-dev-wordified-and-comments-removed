use
bindings
:
:
{
GeckoProfilerThreadListener
WrCompositor
}
;
use
gleam
:
:
{
gl
gl
:
:
GLenum
gl
:
:
Gl
}
;
use
std
:
:
cell
:
:
{
Cell
RefCell
}
;
use
std
:
:
collections
:
:
hash_map
:
:
HashMap
;
use
std
:
:
os
:
:
raw
:
:
c_void
;
use
std
:
:
ptr
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicU32
AtomicU8
AtomicUsize
Ordering
}
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
thread
;
use
webrender
:
:
{
api
:
:
channel
api
:
:
units
:
:
*
api
:
:
ColorDepth
api
:
:
ExternalImageId
api
:
:
ImageRendering
api
:
:
YuvColorSpace
Compositor
CompositorCapabilities
CompositorSurfaceTransform
NativeSurfaceId
NativeSurfaceInfo
NativeTileId
ThreadListener
}
;
#
[
no_mangle
]
pub
extern
"
C
"
fn
wr_swgl_create_context
(
)
-
>
*
mut
c_void
{
swgl
:
:
Context
:
:
create
(
)
.
into
(
)
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
wr_swgl_reference_context
(
ctx
:
*
mut
c_void
)
{
swgl
:
:
Context
:
:
from
(
ctx
)
.
reference
(
)
;
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
wr_swgl_destroy_context
(
ctx
:
*
mut
c_void
)
{
swgl
:
:
Context
:
:
from
(
ctx
)
.
destroy
(
)
;
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
wr_swgl_make_current
(
ctx
:
*
mut
c_void
)
{
swgl
:
:
Context
:
:
from
(
ctx
)
.
make_current
(
)
;
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
wr_swgl_init_default_framebuffer
(
ctx
:
*
mut
c_void
width
:
i32
height
:
i32
stride
:
i32
buf
:
*
mut
c_void
)
{
swgl
:
:
Context
:
:
from
(
ctx
)
.
init_default_framebuffer
(
width
height
stride
buf
)
;
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
wr_swgl_gen_texture
(
ctx
:
*
mut
c_void
)
-
>
u32
{
swgl
:
:
Context
:
:
from
(
ctx
)
.
gen_textures
(
1
)
[
0
]
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
wr_swgl_delete_texture
(
ctx
:
*
mut
c_void
tex
:
u32
)
{
swgl
:
:
Context
:
:
from
(
ctx
)
.
delete_textures
(
&
[
tex
]
)
;
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
wr_swgl_set_texture_parameter
(
ctx
:
*
mut
c_void
tex
:
u32
pname
:
u32
param
:
i32
)
{
swgl
:
:
Context
:
:
from
(
ctx
)
.
set_texture_parameter
(
tex
pname
param
)
;
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
wr_swgl_set_texture_buffer
(
ctx
:
*
mut
c_void
tex
:
u32
internal_format
:
u32
width
:
i32
height
:
i32
stride
:
i32
buf
:
*
mut
c_void
min_width
:
i32
min_height
:
i32
)
{
swgl
:
:
Context
:
:
from
(
ctx
)
.
set_texture_buffer
(
tex
internal_format
width
height
stride
buf
min_width
min_height
)
;
}
#
[
repr
(
C
)
]
struct
WrSWGLCompositeSurfaceInfo
{
yuv_planes
:
u32
textures
:
[
u32
;
3
]
color_space
:
YuvColorSpace
color_depth
:
ColorDepth
size
:
DeviceIntSize
}
extern
"
C
"
{
fn
wr_swgl_lock_composite_surface
(
ctx
:
*
mut
c_void
external_image_id
:
ExternalImageId
composite_info
:
*
mut
WrSWGLCompositeSurfaceInfo
)
-
>
bool
;
fn
wr_swgl_unlock_composite_surface
(
ctx
:
*
mut
c_void
external_image_id
:
ExternalImageId
)
;
}
pub
struct
SwTile
{
x
:
i32
y
:
i32
fbo_id
:
u32
color_id
:
u32
tex_id
:
u32
pbo_id
:
u32
dirty_rect
:
DeviceIntRect
valid_rect
:
DeviceIntRect
overlaps
:
Cell
<
u32
>
invalid
:
Cell
<
bool
>
graph_node
:
Arc
<
SwCompositeGraphNode
>
}
impl
SwTile
{
fn
new
(
x
:
i32
y
:
i32
)
-
>
Self
{
SwTile
{
x
y
fbo_id
:
0
color_id
:
0
tex_id
:
0
pbo_id
:
0
dirty_rect
:
DeviceIntRect
:
:
zero
(
)
valid_rect
:
DeviceIntRect
:
:
zero
(
)
overlaps
:
Cell
:
:
new
(
0
)
invalid
:
Cell
:
:
new
(
false
)
graph_node
:
SwCompositeGraphNode
:
:
new
(
)
}
}
fn
origin
(
&
self
surface
:
&
SwSurface
)
-
>
DeviceIntPoint
{
DeviceIntPoint
:
:
new
(
self
.
x
*
surface
.
tile_size
.
width
self
.
y
*
surface
.
tile_size
.
height
)
}
fn
overlap_rect
(
&
self
surface
:
&
SwSurface
transform
:
&
CompositorSurfaceTransform
clip_rect
:
&
DeviceIntRect
)
-
>
Option
<
DeviceIntRect
>
{
let
origin
=
self
.
origin
(
surface
)
;
let
bounds
=
if
self
.
invalid
.
get
(
)
{
DeviceIntRect
:
:
new
(
origin
surface
.
tile_size
)
}
else
{
self
.
valid_rect
.
translate
(
origin
.
to_vector
(
)
)
}
;
let
device_rect
=
transform
.
outer_transformed_rect
(
&
bounds
.
to_f32
(
)
)
?
.
round_out
(
)
.
to_i32
(
)
;
device_rect
.
intersection
(
clip_rect
)
}
fn
may_overlap
(
&
self
surface
:
&
SwSurface
transform
:
&
CompositorSurfaceTransform
clip_rect
:
&
DeviceIntRect
dep_rect
:
&
DeviceIntRect
)
-
>
bool
{
self
.
overlap_rect
(
surface
transform
clip_rect
)
.
map_or
(
false
|
r
|
r
.
intersects
(
dep_rect
)
)
}
fn
composite_rects
(
&
self
surface
:
&
SwSurface
transform
:
&
CompositorSurfaceTransform
clip_rect
:
&
DeviceIntRect
)
-
>
Option
<
(
DeviceIntRect
DeviceIntRect
bool
)
>
{
let
valid
=
self
.
valid_rect
.
translate
(
self
.
origin
(
surface
)
.
to_vector
(
)
)
;
let
dest_rect
=
transform
.
outer_transformed_rect
(
&
valid
.
to_f32
(
)
)
?
.
round_out
(
)
.
to_i32
(
)
.
intersection
(
clip_rect
)
?
;
let
inv_transform
=
transform
.
inverse
(
)
?
;
let
src_rect
=
inv_transform
.
outer_transformed_rect
(
&
dest_rect
.
to_f32
(
)
)
?
.
round
(
)
.
to_i32
(
)
.
translate
(
-
valid
.
origin
.
to_vector
(
)
)
;
Some
(
(
src_rect
dest_rect
transform
.
m22
<
0
.
0
)
)
}
}
pub
struct
SwSurface
{
tile_size
:
DeviceIntSize
is_opaque
:
bool
tiles
:
Vec
<
SwTile
>
external_image
:
Option
<
ExternalImageId
>
composite_surface
:
Option
<
WrSWGLCompositeSurfaceInfo
>
}
impl
SwSurface
{
fn
new
(
tile_size
:
DeviceIntSize
is_opaque
:
bool
)
-
>
Self
{
SwSurface
{
tile_size
is_opaque
tiles
:
Vec
:
:
new
(
)
external_image
:
None
composite_surface
:
None
}
}
}
fn
image_rendering_to_gl_filter
(
filter
:
ImageRendering
)
-
>
gl
:
:
GLenum
{
match
filter
{
ImageRendering
:
:
Pixelated
=
>
gl
:
:
NEAREST
ImageRendering
:
:
Auto
|
ImageRendering
:
:
CrispEdges
=
>
gl
:
:
LINEAR
}
}
struct
DrawTileHelper
{
gl
:
Rc
<
dyn
gl
:
:
Gl
>
prog
:
u32
quad_vbo
:
u32
quad_vao
:
u32
dest_matrix_loc
:
i32
tex_matrix_loc
:
i32
}
impl
DrawTileHelper
{
fn
new
(
gl
:
Rc
<
dyn
gl
:
:
Gl
>
)
-
>
Self
{
let
quad_vbo
=
gl
.
gen_buffers
(
1
)
[
0
]
;
gl
.
bind_buffer
(
gl
:
:
ARRAY_BUFFER
quad_vbo
)
;
let
quad_data
:
[
f32
;
8
]
=
[
0
.
0
0
.
0
1
.
0
0
.
0
0
.
0
1
.
0
1
.
0
1
.
0
]
;
gl
:
:
buffer_data
(
&
*
gl
gl
:
:
ARRAY_BUFFER
&
quad_data
gl
:
:
STATIC_DRAW
)
;
let
quad_vao
=
gl
.
gen_vertex_arrays
(
1
)
[
0
]
;
gl
.
bind_vertex_array
(
quad_vao
)
;
gl
.
enable_vertex_attrib_array
(
0
)
;
gl
.
vertex_attrib_pointer
(
0
2
gl
:
:
FLOAT
false
0
0
)
;
gl
.
bind_vertex_array
(
0
)
;
let
version
=
match
gl
.
get_type
(
)
{
gl
:
:
GlType
:
:
Gl
=
>
"
#
version
150
"
gl
:
:
GlType
:
:
Gles
=
>
"
#
version
300
es
"
}
;
let
vert_source
=
"
in
vec2
aVert
;
uniform
mat3
uDestMatrix
;
uniform
mat3
uTexMatrix
;
out
vec2
vTexCoord
;
void
main
(
void
)
{
gl_Position
=
vec4
(
(
uDestMatrix
*
vec3
(
aVert
1
.
0
)
)
.
xy
0
.
0
1
.
0
)
;
vTexCoord
=
(
uTexMatrix
*
vec3
(
aVert
1
.
0
)
)
.
xy
;
}
"
;
let
vs
=
gl
.
create_shader
(
gl
:
:
VERTEX_SHADER
)
;
gl
.
shader_source
(
vs
&
[
version
.
as_bytes
(
)
vert_source
.
as_bytes
(
)
]
)
;
gl
.
compile_shader
(
vs
)
;
let
frag_source
=
"
#
ifdef
GL_ES
#
ifdef
GL_FRAGMENT_PRECISION_HIGH
precision
highp
float
;
#
else
precision
mediump
float
;
#
endif
#
endif
in
vec2
vTexCoord
;
out
vec4
oFragColor
;
uniform
sampler2D
uTex
;
void
main
(
void
)
{
oFragColor
=
texture
(
uTex
vTexCoord
)
;
}
"
;
let
fs
=
gl
.
create_shader
(
gl
:
:
FRAGMENT_SHADER
)
;
gl
.
shader_source
(
fs
&
[
version
.
as_bytes
(
)
frag_source
.
as_bytes
(
)
]
)
;
gl
.
compile_shader
(
fs
)
;
let
prog
=
gl
.
create_program
(
)
;
gl
.
attach_shader
(
prog
vs
)
;
gl
.
attach_shader
(
prog
fs
)
;
gl
.
bind_attrib_location
(
prog
0
"
aVert
"
)
;
gl
.
link_program
(
prog
)
;
let
mut
status
=
[
0
]
;
unsafe
{
gl
.
get_program_iv
(
prog
gl
:
:
LINK_STATUS
&
mut
status
)
;
}
assert
!
(
status
[
0
]
!
=
0
)
;
gl
.
use_program
(
prog
)
;
let
dest_matrix_loc
=
gl
.
get_uniform_location
(
prog
"
uDestMatrix
"
)
;
assert
!
(
dest_matrix_loc
!
=
-
1
)
;
let
tex_matrix_loc
=
gl
.
get_uniform_location
(
prog
"
uTexMatrix
"
)
;
assert
!
(
tex_matrix_loc
!
=
-
1
)
;
let
tex_loc
=
gl
.
get_uniform_location
(
prog
"
uTex
"
)
;
assert
!
(
tex_loc
!
=
-
1
)
;
gl
.
uniform_1i
(
tex_loc
0
)
;
gl
.
use_program
(
0
)
;
gl
.
delete_shader
(
vs
)
;
gl
.
delete_shader
(
fs
)
;
DrawTileHelper
{
gl
prog
quad_vao
quad_vbo
dest_matrix_loc
tex_matrix_loc
}
}
fn
deinit
(
&
self
)
{
self
.
gl
.
delete_program
(
self
.
prog
)
;
self
.
gl
.
delete_vertex_arrays
(
&
[
self
.
quad_vao
]
)
;
self
.
gl
.
delete_buffers
(
&
[
self
.
quad_vbo
]
)
;
}
fn
enable
(
&
self
viewport
:
&
DeviceIntRect
)
{
self
.
gl
.
viewport
(
viewport
.
origin
.
x
viewport
.
origin
.
y
viewport
.
size
.
width
viewport
.
size
.
height
)
;
self
.
gl
.
bind_vertex_array
(
self
.
quad_vao
)
;
self
.
gl
.
use_program
(
self
.
prog
)
;
self
.
gl
.
active_texture
(
gl
:
:
TEXTURE0
)
;
}
fn
draw
(
&
self
viewport
:
&
DeviceIntRect
dest
:
&
DeviceIntRect
src
:
&
DeviceIntRect
surface
:
&
SwSurface
tile
:
&
SwTile
flip_y
:
bool
filter
:
GLenum
)
{
let
dx
=
dest
.
origin
.
x
as
f32
/
viewport
.
size
.
width
as
f32
;
let
dy
=
dest
.
origin
.
y
as
f32
/
viewport
.
size
.
height
as
f32
;
let
dw
=
dest
.
size
.
width
as
f32
/
viewport
.
size
.
width
as
f32
;
let
dh
=
dest
.
size
.
height
as
f32
/
viewport
.
size
.
height
as
f32
;
self
.
gl
.
uniform_matrix_3fv
(
self
.
dest_matrix_loc
false
&
[
2
.
0
*
dw
0
.
0
0
.
0
0
.
0
if
flip_y
{
2
.
0
*
dh
}
else
{
-
2
.
0
*
dh
}
0
.
0
-
1
.
0
+
2
.
0
*
dx
if
flip_y
{
-
1
.
0
+
2
.
0
*
dy
}
else
{
1
.
0
-
2
.
0
*
dy
}
1
.
0
]
)
;
let
sx
=
src
.
origin
.
x
as
f32
/
surface
.
tile_size
.
width
as
f32
;
let
sy
=
src
.
origin
.
y
as
f32
/
surface
.
tile_size
.
height
as
f32
;
let
sw
=
src
.
size
.
width
as
f32
/
surface
.
tile_size
.
width
as
f32
;
let
sh
=
src
.
size
.
height
as
f32
/
surface
.
tile_size
.
height
as
f32
;
self
.
gl
.
uniform_matrix_3fv
(
self
.
tex_matrix_loc
false
&
[
sw
0
.
0
0
.
0
0
.
0
sh
0
.
0
sx
sy
1
.
0
]
)
;
self
.
gl
.
bind_texture
(
gl
:
:
TEXTURE_2D
tile
.
tex_id
)
;
self
.
gl
.
tex_parameter_i
(
gl
:
:
TEXTURE_2D
gl
:
:
TEXTURE_MIN_FILTER
filter
as
gl
:
:
GLint
)
;
self
.
gl
.
tex_parameter_i
(
gl
:
:
TEXTURE_2D
gl
:
:
TEXTURE_MAG_FILTER
filter
as
gl
:
:
GLint
)
;
self
.
gl
.
draw_arrays
(
gl
:
:
TRIANGLE_STRIP
0
4
)
;
}
fn
disable
(
&
self
)
{
self
.
gl
.
use_program
(
0
)
;
self
.
gl
.
bind_vertex_array
(
0
)
;
}
}
#
[
derive
(
Clone
)
]
enum
SwCompositeSource
{
BGRA
(
swgl
:
:
LockedResource
)
YUV
(
swgl
:
:
LockedResource
swgl
:
:
LockedResource
swgl
:
:
LockedResource
YuvColorSpace
ColorDepth
)
}
unsafe
impl
Send
for
SwCompositeSource
{
}
#
[
derive
(
Clone
)
]
struct
SwCompositeJob
{
locked_src
:
SwCompositeSource
locked_dst
:
swgl
:
:
LockedResource
src_rect
:
DeviceIntRect
dst_rect
:
DeviceIntRect
opaque
:
bool
flip_y
:
bool
filter
:
ImageRendering
num_bands
:
u8
}
impl
SwCompositeJob
{
fn
process
(
&
self
band_index
:
u8
)
{
let
band_index
=
band_index
as
i32
;
let
num_bands
=
self
.
num_bands
as
i32
;
let
band_offset
=
(
self
.
dst_rect
.
size
.
height
*
band_index
)
/
num_bands
;
let
band_height
=
(
self
.
dst_rect
.
size
.
height
*
(
band_index
+
1
)
)
/
num_bands
-
band_offset
;
match
self
.
locked_src
{
SwCompositeSource
:
:
BGRA
(
ref
resource
)
=
>
{
self
.
locked_dst
.
composite
(
resource
self
.
src_rect
.
origin
.
x
self
.
src_rect
.
origin
.
y
self
.
src_rect
.
size
.
width
self
.
src_rect
.
size
.
height
self
.
dst_rect
.
origin
.
x
self
.
dst_rect
.
origin
.
y
self
.
dst_rect
.
size
.
width
self
.
dst_rect
.
size
.
height
self
.
opaque
self
.
flip_y
image_rendering_to_gl_filter
(
self
.
filter
)
band_offset
band_height
)
;
}
SwCompositeSource
:
:
YUV
(
ref
y
ref
u
ref
v
color_space
color_depth
)
=
>
{
let
swgl_color_space
=
match
color_space
{
YuvColorSpace
:
:
Rec601
=
>
swgl
:
:
YUVColorSpace
:
:
Rec601
YuvColorSpace
:
:
Rec709
=
>
swgl
:
:
YUVColorSpace
:
:
Rec709
YuvColorSpace
:
:
Rec2020
=
>
swgl
:
:
YUVColorSpace
:
:
Rec2020
YuvColorSpace
:
:
Identity
=
>
swgl
:
:
YUVColorSpace
:
:
Identity
}
;
self
.
locked_dst
.
composite_yuv
(
y
u
v
swgl_color_space
color_depth
.
bit_depth
(
)
self
.
src_rect
.
origin
.
x
self
.
src_rect
.
origin
.
y
self
.
src_rect
.
size
.
width
self
.
src_rect
.
size
.
height
self
.
dst_rect
.
origin
.
x
self
.
dst_rect
.
origin
.
y
self
.
dst_rect
.
size
.
width
self
.
dst_rect
.
size
.
height
self
.
flip_y
band_offset
band_height
)
;
}
}
}
}
struct
SwCompositeGraphNode
{
job
:
RefCell
<
Option
<
SwCompositeJob
>
>
num_bands
:
AtomicU8
band_index
:
AtomicU8
parents
:
AtomicU32
children
:
RefCell
<
Vec
<
Arc
<
SwCompositeGraphNode
>
>
>
}
unsafe
impl
Sync
for
SwCompositeGraphNode
{
}
impl
SwCompositeGraphNode
{
fn
new
(
)
-
>
Arc
<
SwCompositeGraphNode
>
{
Arc
:
:
new
(
SwCompositeGraphNode
{
job
:
RefCell
:
:
new
(
None
)
num_bands
:
AtomicU8
:
:
new
(
0
)
band_index
:
AtomicU8
:
:
new
(
0
)
parents
:
AtomicU32
:
:
new
(
0
)
children
:
RefCell
:
:
new
(
Vec
:
:
new
(
)
)
}
)
}
fn
reset
(
&
self
)
{
self
.
job
.
replace
(
None
)
;
self
.
num_bands
.
store
(
0
Ordering
:
:
SeqCst
)
;
self
.
band_index
.
store
(
0
Ordering
:
:
SeqCst
)
;
self
.
parents
.
store
(
1
Ordering
:
:
SeqCst
)
;
self
.
children
.
borrow_mut
(
)
.
clear
(
)
;
}
fn
add_child
(
&
self
child
:
Arc
<
SwCompositeGraphNode
>
)
{
child
.
parents
.
fetch_add
(
1
Ordering
:
:
SeqCst
)
;
self
.
children
.
borrow_mut
(
)
.
push
(
child
)
;
}
fn
set_job
(
&
self
job
:
SwCompositeJob
num_bands
:
u8
)
-
>
bool
{
self
.
job
.
replace
(
Some
(
job
)
)
;
self
.
num_bands
.
store
(
num_bands
Ordering
:
:
SeqCst
)
;
self
.
parents
.
fetch_sub
(
1
Ordering
:
:
SeqCst
)
<
=
1
}
fn
process_job
(
&
self
)
{
unsafe
{
if
let
Ok
(
Some
(
ref
job
)
)
=
self
.
job
.
try_borrow_unguarded
(
)
{
let
band_index
=
self
.
band_index
.
fetch_add
(
1
Ordering
:
:
SeqCst
)
;
job
.
process
(
band_index
)
;
}
}
}
fn
unblock_children
(
&
self
sender
:
&
channel
:
:
crossbeam
:
:
Sender
<
Arc
<
SwCompositeGraphNode
>
>
)
{
if
self
.
num_bands
.
fetch_sub
(
1
Ordering
:
:
SeqCst
)
>
1
{
return
;
}
self
.
job
.
replace
(
None
)
;
for
child
in
self
.
children
.
borrow
(
)
.
iter
(
)
{
if
child
.
parents
.
fetch_sub
(
1
Ordering
:
:
SeqCst
)
<
=
1
{
let
num_bands
=
child
.
num_bands
.
load
(
Ordering
:
:
SeqCst
)
;
for
_
in
0
.
.
num_bands
{
sender
.
send
(
child
.
clone
(
)
)
.
expect
(
"
Failed
sending
SwComposite
job
"
)
;
}
}
}
}
}
struct
SwCompositeThread
{
job_sender
:
channel
:
:
crossbeam
:
:
Sender
<
Arc
<
SwCompositeGraphNode
>
>
job_receiver
:
channel
:
:
crossbeam
:
:
Receiver
<
Arc
<
SwCompositeGraphNode
>
>
job_count
:
AtomicUsize
jobs_completed
:
channel
:
:
crossbeam
:
:
Receiver
<
(
)
>
}
unsafe
impl
Sync
for
SwCompositeThread
{
}
impl
SwCompositeThread
{
fn
new
(
)
-
>
Arc
<
SwCompositeThread
>
{
let
(
job_sender
job_receiver
)
=
channel
:
:
crossbeam
:
:
unbounded
(
)
;
let
(
notify_completed
jobs_completed
)
=
channel
:
:
crossbeam
:
:
bounded
(
1
)
;
let
info
=
Arc
:
:
new
(
SwCompositeThread
{
job_sender
job_receiver
job_count
:
AtomicUsize
:
:
new
(
0
)
jobs_completed
}
)
;
let
result
=
info
.
clone
(
)
;
let
thread_name
=
"
SwComposite
"
;
thread
:
:
Builder
:
:
new
(
)
.
name
(
thread_name
.
into
(
)
)
.
spawn
(
move
|
|
{
let
thread_listener
=
GeckoProfilerThreadListener
:
:
new
(
)
;
thread_listener
.
thread_started
(
thread_name
)
;
while
let
Ok
(
graph_node
)
=
info
.
job_receiver
.
recv
(
)
{
if
info
.
process_job
(
graph_node
)
{
let
_
=
notify_completed
.
try_send
(
(
)
)
;
}
}
thread_listener
.
thread_stopped
(
thread_name
)
;
}
)
.
expect
(
"
Failed
creating
SwComposite
thread
"
)
;
result
}
fn
process_job
(
&
self
graph_node
:
Arc
<
SwCompositeGraphNode
>
)
-
>
bool
{
graph_node
.
process_job
(
)
;
graph_node
.
unblock_children
(
&
self
.
job_sender
)
;
self
.
job_count
.
fetch_sub
(
1
Ordering
:
:
SeqCst
)
<
=
1
}
fn
queue_composite
(
&
self
locked_src
:
SwCompositeSource
locked_dst
:
swgl
:
:
LockedResource
src_rect
:
DeviceIntRect
dst_rect
:
DeviceIntRect
opaque
:
bool
flip_y
:
bool
filter
:
ImageRendering
graph_node
:
&
Arc
<
SwCompositeGraphNode
>
)
{
let
num_bands
=
if
dst_rect
.
size
.
width
>
=
64
&
&
dst_rect
.
size
.
height
>
=
64
{
(
dst_rect
.
size
.
height
/
64
)
.
min
(
4
)
as
u8
}
else
{
1
}
;
let
job
=
SwCompositeJob
{
locked_src
locked_dst
src_rect
dst_rect
opaque
flip_y
filter
num_bands
}
;
self
.
job_count
.
fetch_add
(
num_bands
as
usize
Ordering
:
:
SeqCst
)
;
if
graph_node
.
set_job
(
job
num_bands
)
{
for
_
in
0
.
.
num_bands
{
self
.
job_sender
.
send
(
graph_node
.
clone
(
)
)
.
expect
(
"
Failed
sending
SwComposite
job
"
)
;
}
}
}
fn
start_compositing
(
&
self
)
{
self
.
job_count
.
store
(
1
Ordering
:
:
SeqCst
)
;
while
self
.
jobs_completed
.
try_recv
(
)
.
is_ok
(
)
{
}
}
fn
wait_for_composites
(
&
self
sync
:
bool
)
{
if
self
.
job_count
.
fetch_sub
(
1
Ordering
:
:
SeqCst
)
<
=
1
{
return
;
}
if
sync
{
let
_
=
self
.
jobs_completed
.
recv
(
)
;
return
;
}
loop
{
channel
:
:
crossbeam
:
:
select
!
{
/
/
Steal
jobs
from
the
SwComposite
thread
if
it
is
busy
.
recv
(
self
.
job_receiver
)
-
>
graph_node
=
>
if
let
Ok
(
graph_node
)
=
graph_node
{
if
self
.
process_job
(
graph_node
)
{
/
/
If
this
was
the
final
job
then
just
exit
.
break
;
}
}
/
/
If
all
jobs
have
been
completed
it
is
safe
to
exit
.
recv
(
self
.
jobs_completed
)
-
>
_
=
>
break
}
}
}
fn
is_busy_compositing
(
&
self
)
-
>
bool
{
self
.
job_count
.
load
(
Ordering
:
:
SeqCst
)
>
0
}
}
pub
struct
SwCompositor
{
gl
:
swgl
:
:
Context
native_gl
:
Option
<
Rc
<
dyn
gl
:
:
Gl
>
>
compositor
:
Option
<
WrCompositor
>
surfaces
:
HashMap
<
NativeSurfaceId
SwSurface
>
frame_surfaces
:
Vec
<
(
NativeSurfaceId
CompositorSurfaceTransform
DeviceIntRect
ImageRendering
)
>
late_surfaces
:
Vec
<
(
NativeSurfaceId
CompositorSurfaceTransform
DeviceIntRect
ImageRendering
)
>
cur_tile
:
NativeTileId
draw_tile
:
Option
<
DrawTileHelper
>
max_tile_size
:
DeviceIntSize
depth_id
:
u32
composite_thread
:
Option
<
Arc
<
SwCompositeThread
>
>
locked_framebuffer
:
Option
<
swgl
:
:
LockedResource
>
}
impl
SwCompositor
{
pub
fn
new
(
gl
:
swgl
:
:
Context
native_gl
:
Option
<
Rc
<
dyn
gl
:
:
Gl
>
>
compositor
:
Option
<
WrCompositor
>
)
-
>
Self
{
let
depth_id
=
gl
.
gen_textures
(
1
)
[
0
]
;
let
composite_thread
=
if
native_gl
.
is_none
(
)
&
&
compositor
.
is_none
(
)
{
Some
(
SwCompositeThread
:
:
new
(
)
)
}
else
{
None
}
;
SwCompositor
{
gl
compositor
surfaces
:
HashMap
:
:
new
(
)
frame_surfaces
:
Vec
:
:
new
(
)
late_surfaces
:
Vec
:
:
new
(
)
cur_tile
:
NativeTileId
{
surface_id
:
NativeSurfaceId
(
0
)
x
:
0
y
:
0
}
draw_tile
:
native_gl
.
as_ref
(
)
.
map
(
|
gl
|
DrawTileHelper
:
:
new
(
gl
.
clone
(
)
)
)
native_gl
max_tile_size
:
DeviceIntSize
:
:
zero
(
)
depth_id
composite_thread
locked_framebuffer
:
None
}
}
fn
deinit_shader
(
&
mut
self
)
{
if
let
Some
(
draw_tile
)
=
&
self
.
draw_tile
{
draw_tile
.
deinit
(
)
;
}
self
.
draw_tile
=
None
;
}
fn
deinit_tile
(
&
self
tile
:
&
SwTile
)
{
self
.
gl
.
delete_framebuffers
(
&
[
tile
.
fbo_id
]
)
;
self
.
gl
.
delete_textures
(
&
[
tile
.
color_id
]
)
;
if
let
Some
(
native_gl
)
=
&
self
.
native_gl
{
native_gl
.
delete_textures
(
&
[
tile
.
tex_id
]
)
;
native_gl
.
delete_buffers
(
&
[
tile
.
pbo_id
]
)
;
}
}
fn
deinit_surface
(
&
self
surface
:
&
SwSurface
)
{
for
tile
in
&
surface
.
tiles
{
self
.
deinit_tile
(
tile
)
;
}
}
fn
reset_overlaps
(
&
mut
self
)
{
for
surface
in
self
.
surfaces
.
values_mut
(
)
{
for
tile
in
&
mut
surface
.
tiles
{
tile
.
overlaps
.
set
(
0
)
;
tile
.
invalid
.
set
(
false
)
;
tile
.
graph_node
.
reset
(
)
;
}
}
}
fn
init_overlaps
(
&
self
overlap_surface
:
&
SwSurface
overlap_tile
:
&
SwTile
overlap_transform
:
&
CompositorSurfaceTransform
overlap_clip_rect
:
&
DeviceIntRect
)
{
let
overlap_rect
=
match
overlap_tile
.
overlap_rect
(
overlap_surface
overlap_transform
overlap_clip_rect
)
{
Some
(
overlap_rect
)
=
>
overlap_rect
None
=
>
return
}
;
let
mut
overlaps
=
if
overlap_tile
.
invalid
.
get
(
)
{
1
}
else
{
0
}
;
for
&
(
ref
id
ref
transform
ref
clip_rect
_
)
in
&
self
.
frame_surfaces
{
if
!
overlap_rect
.
intersects
(
clip_rect
)
{
continue
;
}
if
let
Some
(
surface
)
=
self
.
surfaces
.
get
(
id
)
{
for
tile
in
&
surface
.
tiles
{
if
tile
.
may_overlap
(
surface
transform
clip_rect
&
overlap_rect
)
{
if
tile
.
overlaps
.
get
(
)
>
0
{
overlaps
+
=
1
;
}
tile
.
graph_node
.
add_child
(
overlap_tile
.
graph_node
.
clone
(
)
)
;
}
}
}
}
if
overlaps
>
0
{
overlap_tile
.
overlaps
.
set
(
overlaps
)
;
}
}
fn
queue_composite
(
&
self
surface
:
&
SwSurface
transform
:
&
CompositorSurfaceTransform
clip_rect
:
&
DeviceIntRect
filter
:
ImageRendering
tile
:
&
SwTile
)
{
if
let
Some
(
ref
composite_thread
)
=
self
.
composite_thread
{
if
let
Some
(
(
src_rect
dst_rect
flip_y
)
)
=
tile
.
composite_rects
(
surface
transform
clip_rect
)
{
let
source
=
if
surface
.
external_image
.
is_some
(
)
{
match
surface
.
composite_surface
{
Some
(
ref
info
)
=
>
match
info
.
yuv_planes
{
0
=
>
match
self
.
gl
.
lock_texture
(
info
.
textures
[
0
]
)
{
Some
(
texture
)
=
>
SwCompositeSource
:
:
BGRA
(
texture
)
None
=
>
return
}
3
=
>
match
(
self
.
gl
.
lock_texture
(
info
.
textures
[
0
]
)
self
.
gl
.
lock_texture
(
info
.
textures
[
1
]
)
self
.
gl
.
lock_texture
(
info
.
textures
[
2
]
)
)
{
(
Some
(
y_texture
)
Some
(
u_texture
)
Some
(
v_texture
)
)
=
>
SwCompositeSource
:
:
YUV
(
y_texture
u_texture
v_texture
info
.
color_space
info
.
color_depth
)
_
=
>
return
}
_
=
>
panic
!
(
"
unsupported
number
of
YUV
planes
:
{
}
"
info
.
yuv_planes
)
}
None
=
>
return
}
}
else
if
let
Some
(
texture
)
=
self
.
gl
.
lock_texture
(
tile
.
color_id
)
{
SwCompositeSource
:
:
BGRA
(
texture
)
}
else
{
return
;
}
;
let
framebuffer
=
self
.
locked_framebuffer
.
clone
(
)
.
unwrap
(
)
;
composite_thread
.
queue_composite
(
source
framebuffer
src_rect
dst_rect
surface
.
is_opaque
flip_y
filter
&
tile
.
graph_node
)
;
}
}
}
fn
try_lock_composite_surface
(
&
mut
self
id
:
&
NativeSurfaceId
)
{
if
let
Some
(
surface
)
=
self
.
surfaces
.
get_mut
(
id
)
{
if
let
Some
(
external_image
)
=
surface
.
external_image
{
let
mut
info
=
WrSWGLCompositeSurfaceInfo
{
yuv_planes
:
0
textures
:
[
0
;
3
]
color_space
:
YuvColorSpace
:
:
Identity
color_depth
:
ColorDepth
:
:
Color8
size
:
DeviceIntSize
:
:
zero
(
)
}
;
assert
!
(
surface
.
tiles
.
len
(
)
>
0
)
;
let
mut
tile
=
&
mut
surface
.
tiles
[
0
]
;
if
unsafe
{
wr_swgl_lock_composite_surface
(
self
.
gl
.
into
(
)
external_image
&
mut
info
)
}
{
tile
.
valid_rect
=
DeviceIntRect
:
:
from_size
(
info
.
size
)
;
surface
.
composite_surface
=
Some
(
info
)
;
}
else
{
tile
.
valid_rect
=
DeviceIntRect
:
:
zero
(
)
;
surface
.
composite_surface
=
None
;
}
}
}
}
fn
unlock_composite_surfaces
(
&
mut
self
)
{
for
&
(
ref
id
_
_
_
)
in
self
.
frame_surfaces
.
iter
(
)
.
chain
(
self
.
late_surfaces
.
iter
(
)
)
{
if
let
Some
(
surface
)
=
self
.
surfaces
.
get_mut
(
id
)
{
if
let
Some
(
external_image
)
=
surface
.
external_image
{
if
surface
.
composite_surface
.
is_some
(
)
{
unsafe
{
wr_swgl_unlock_composite_surface
(
self
.
gl
.
into
(
)
external_image
)
}
;
surface
.
composite_surface
=
None
;
}
}
}
}
}
fn
flush_composites
(
&
self
tile_id
:
&
NativeTileId
surface
:
&
SwSurface
tile
:
&
SwTile
)
{
if
self
.
composite_thread
.
is_none
(
)
{
return
;
}
let
mut
frame_surfaces
=
self
.
frame_surfaces
.
iter
(
)
.
skip_while
(
|
&
(
ref
id
_
_
_
)
|
*
id
!
=
tile_id
.
surface_id
)
;
let
overlap_rect
=
match
frame_surfaces
.
next
(
)
{
Some
(
&
(
_
ref
transform
ref
clip_rect
filter
)
)
=
>
{
if
tile
.
invalid
.
get
(
)
{
tile
.
overlaps
.
set
(
tile
.
overlaps
.
get
(
)
-
1
)
;
}
if
tile
.
overlaps
.
get
(
)
>
0
{
return
;
}
self
.
queue_composite
(
surface
transform
clip_rect
filter
tile
)
;
match
tile
.
overlap_rect
(
surface
transform
clip_rect
)
{
Some
(
overlap_rect
)
=
>
overlap_rect
None
=
>
return
}
}
None
=
>
return
}
;
let
mut
flushed_bounds
=
overlap_rect
;
let
mut
flushed_rects
=
vec
!
[
overlap_rect
]
;
for
&
(
ref
id
ref
transform
ref
clip_rect
filter
)
in
frame_surfaces
{
if
!
flushed_bounds
.
intersects
(
clip_rect
)
{
continue
;
}
if
let
Some
(
surface
)
=
self
.
surfaces
.
get
(
&
id
)
{
for
tile
in
&
surface
.
tiles
{
let
mut
overlaps
=
tile
.
overlaps
.
get
(
)
;
if
overlaps
=
=
0
{
continue
;
}
let
overlap_rect
=
match
tile
.
overlap_rect
(
surface
transform
clip_rect
)
{
Some
(
overlap_rect
)
=
>
overlap_rect
None
=
>
continue
}
;
if
!
overlap_rect
.
intersects
(
&
flushed_bounds
)
{
continue
;
}
for
flushed_rect
in
&
flushed_rects
{
if
overlap_rect
.
intersects
(
flushed_rect
)
{
overlaps
-
=
1
;
}
}
if
overlaps
!
=
tile
.
overlaps
.
get
(
)
{
tile
.
overlaps
.
set
(
overlaps
)
;
if
overlaps
=
=
0
{
self
.
queue_composite
(
surface
transform
clip_rect
filter
tile
)
;
flushed_bounds
=
flushed_bounds
.
union
(
&
overlap_rect
)
;
flushed_rects
.
push
(
overlap_rect
)
;
}
}
}
}
}
}
}
impl
Compositor
for
SwCompositor
{
fn
create_surface
(
&
mut
self
id
:
NativeSurfaceId
virtual_offset
:
DeviceIntPoint
tile_size
:
DeviceIntSize
is_opaque
:
bool
)
{
if
let
Some
(
compositor
)
=
&
mut
self
.
compositor
{
compositor
.
create_surface
(
id
virtual_offset
tile_size
is_opaque
)
;
}
self
.
max_tile_size
=
DeviceIntSize
:
:
new
(
self
.
max_tile_size
.
width
.
max
(
tile_size
.
width
)
self
.
max_tile_size
.
height
.
max
(
tile_size
.
height
)
)
;
self
.
surfaces
.
insert
(
id
SwSurface
:
:
new
(
tile_size
is_opaque
)
)
;
}
fn
create_external_surface
(
&
mut
self
id
:
NativeSurfaceId
is_opaque
:
bool
)
{
if
let
Some
(
compositor
)
=
&
mut
self
.
compositor
{
compositor
.
create_external_surface
(
id
is_opaque
)
;
}
self
.
surfaces
.
insert
(
id
SwSurface
:
:
new
(
DeviceIntSize
:
:
zero
(
)
is_opaque
)
)
;
}
fn
destroy_surface
(
&
mut
self
id
:
NativeSurfaceId
)
{
if
let
Some
(
surface
)
=
self
.
surfaces
.
remove
(
&
id
)
{
self
.
deinit_surface
(
&
surface
)
;
}
if
let
Some
(
compositor
)
=
&
mut
self
.
compositor
{
compositor
.
destroy_surface
(
id
)
;
}
}
fn
deinit
(
&
mut
self
)
{
for
surface
in
self
.
surfaces
.
values
(
)
{
self
.
deinit_surface
(
surface
)
;
}
self
.
gl
.
delete_textures
(
&
[
self
.
depth_id
]
)
;
self
.
deinit_shader
(
)
;
if
let
Some
(
compositor
)
=
&
mut
self
.
compositor
{
compositor
.
deinit
(
)
;
}
}
fn
create_tile
(
&
mut
self
id
:
NativeTileId
)
{
if
let
Some
(
compositor
)
=
&
mut
self
.
compositor
{
compositor
.
create_tile
(
id
)
;
}
if
let
Some
(
surface
)
=
self
.
surfaces
.
get_mut
(
&
id
.
surface_id
)
{
let
mut
tile
=
SwTile
:
:
new
(
id
.
x
id
.
y
)
;
tile
.
color_id
=
self
.
gl
.
gen_textures
(
1
)
[
0
]
;
tile
.
fbo_id
=
self
.
gl
.
gen_framebuffers
(
1
)
[
0
]
;
self
.
gl
.
bind_framebuffer
(
gl
:
:
DRAW_FRAMEBUFFER
tile
.
fbo_id
)
;
self
.
gl
.
framebuffer_texture_2d
(
gl
:
:
DRAW_FRAMEBUFFER
gl
:
:
COLOR_ATTACHMENT0
gl
:
:
TEXTURE_2D
tile
.
color_id
0
)
;
self
.
gl
.
framebuffer_texture_2d
(
gl
:
:
DRAW_FRAMEBUFFER
gl
:
:
DEPTH_ATTACHMENT
gl
:
:
TEXTURE_2D
self
.
depth_id
0
)
;
self
.
gl
.
bind_framebuffer
(
gl
:
:
DRAW_FRAMEBUFFER
0
)
;
if
let
Some
(
native_gl
)
=
&
self
.
native_gl
{
tile
.
tex_id
=
native_gl
.
gen_textures
(
1
)
[
0
]
;
native_gl
.
bind_texture
(
gl
:
:
TEXTURE_2D
tile
.
tex_id
)
;
native_gl
.
tex_image_2d
(
gl
:
:
TEXTURE_2D
0
gl
:
:
RGBA8
as
gl
:
:
GLint
surface
.
tile_size
.
width
surface
.
tile_size
.
height
0
gl
:
:
RGBA
gl
:
:
UNSIGNED_BYTE
None
)
;
native_gl
.
tex_parameter_i
(
gl
:
:
TEXTURE_2D
gl
:
:
TEXTURE_MIN_FILTER
gl
:
:
LINEAR
as
gl
:
:
GLint
)
;
native_gl
.
tex_parameter_i
(
gl
:
:
TEXTURE_2D
gl
:
:
TEXTURE_MAG_FILTER
gl
:
:
LINEAR
as
gl
:
:
GLint
)
;
native_gl
.
tex_parameter_i
(
gl
:
:
TEXTURE_2D
gl
:
:
TEXTURE_WRAP_S
gl
:
:
CLAMP_TO_EDGE
as
gl
:
:
GLint
)
;
native_gl
.
tex_parameter_i
(
gl
:
:
TEXTURE_2D
gl
:
:
TEXTURE_WRAP_T
gl
:
:
CLAMP_TO_EDGE
as
gl
:
:
GLint
)
;
native_gl
.
bind_texture
(
gl
:
:
TEXTURE_2D
0
)
;
tile
.
pbo_id
=
native_gl
.
gen_buffers
(
1
)
[
0
]
;
native_gl
.
bind_buffer
(
gl
:
:
PIXEL_UNPACK_BUFFER
tile
.
pbo_id
)
;
native_gl
.
buffer_data_untyped
(
gl
:
:
PIXEL_UNPACK_BUFFER
surface
.
tile_size
.
area
(
)
as
isize
*
4
+
16
ptr
:
:
null
(
)
gl
:
:
DYNAMIC_DRAW
)
;
native_gl
.
bind_buffer
(
gl
:
:
PIXEL_UNPACK_BUFFER
0
)
;
}
surface
.
tiles
.
push
(
tile
)
;
}
}
fn
destroy_tile
(
&
mut
self
id
:
NativeTileId
)
{
if
let
Some
(
surface
)
=
self
.
surfaces
.
get_mut
(
&
id
.
surface_id
)
{
if
let
Some
(
idx
)
=
surface
.
tiles
.
iter
(
)
.
position
(
|
t
|
t
.
x
=
=
id
.
x
&
&
t
.
y
=
=
id
.
y
)
{
let
tile
=
surface
.
tiles
.
remove
(
idx
)
;
self
.
deinit_tile
(
&
tile
)
;
}
}
if
let
Some
(
compositor
)
=
&
mut
self
.
compositor
{
compositor
.
destroy_tile
(
id
)
;
}
}
fn
attach_external_image
(
&
mut
self
id
:
NativeSurfaceId
external_image
:
ExternalImageId
)
{
if
let
Some
(
compositor
)
=
&
mut
self
.
compositor
{
compositor
.
attach_external_image
(
id
external_image
)
;
}
if
let
Some
(
surface
)
=
self
.
surfaces
.
get_mut
(
&
id
)
{
assert
!
(
surface
.
tile_size
.
is_empty
(
)
)
;
surface
.
external_image
=
Some
(
external_image
)
;
if
surface
.
tiles
.
is_empty
(
)
{
surface
.
tiles
.
push
(
SwTile
:
:
new
(
0
0
)
)
;
}
}
}
fn
invalidate_tile
(
&
mut
self
id
:
NativeTileId
)
{
if
let
Some
(
compositor
)
=
&
mut
self
.
compositor
{
compositor
.
invalidate_tile
(
id
)
;
}
if
let
Some
(
surface
)
=
self
.
surfaces
.
get_mut
(
&
id
.
surface_id
)
{
if
let
Some
(
tile
)
=
surface
.
tiles
.
iter_mut
(
)
.
find
(
|
t
|
t
.
x
=
=
id
.
x
&
&
t
.
y
=
=
id
.
y
)
{
tile
.
invalid
.
set
(
true
)
;
}
}
}
fn
bind
(
&
mut
self
id
:
NativeTileId
dirty_rect
:
DeviceIntRect
valid_rect
:
DeviceIntRect
)
-
>
NativeSurfaceInfo
{
let
mut
surface_info
=
NativeSurfaceInfo
{
origin
:
DeviceIntPoint
:
:
zero
(
)
fbo_id
:
0
}
;
self
.
cur_tile
=
id
;
if
let
Some
(
surface
)
=
self
.
surfaces
.
get_mut
(
&
id
.
surface_id
)
{
if
let
Some
(
tile
)
=
surface
.
tiles
.
iter_mut
(
)
.
find
(
|
t
|
t
.
x
=
=
id
.
x
&
&
t
.
y
=
=
id
.
y
)
{
tile
.
dirty_rect
=
dirty_rect
;
tile
.
valid_rect
=
valid_rect
;
if
valid_rect
.
is_empty
(
)
{
return
surface_info
;
}
let
mut
stride
=
0
;
let
mut
buf
=
ptr
:
:
null_mut
(
)
;
if
let
Some
(
compositor
)
=
&
mut
self
.
compositor
{
if
let
Some
(
tile_info
)
=
compositor
.
map_tile
(
id
dirty_rect
valid_rect
)
{
stride
=
tile_info
.
stride
;
buf
=
tile_info
.
data
;
}
}
else
if
let
Some
(
native_gl
)
=
&
self
.
native_gl
{
if
tile
.
pbo_id
!
=
0
{
native_gl
.
bind_buffer
(
gl
:
:
PIXEL_UNPACK_BUFFER
tile
.
pbo_id
)
;
buf
=
native_gl
.
map_buffer_range
(
gl
:
:
PIXEL_UNPACK_BUFFER
0
valid_rect
.
size
.
area
(
)
as
isize
*
4
+
16
gl
:
:
MAP_WRITE_BIT
|
gl
:
:
MAP_INVALIDATE_BUFFER_BIT
)
;
if
buf
!
=
ptr
:
:
null_mut
(
)
{
stride
=
valid_rect
.
size
.
width
*
4
;
}
else
{
native_gl
.
bind_buffer
(
gl
:
:
PIXEL_UNPACK_BUFFER
0
)
;
native_gl
.
delete_buffers
(
&
[
tile
.
pbo_id
]
)
;
tile
.
pbo_id
=
0
;
}
}
}
self
.
gl
.
set_texture_buffer
(
tile
.
color_id
gl
:
:
RGBA8
valid_rect
.
size
.
width
valid_rect
.
size
.
height
stride
buf
surface
.
tile_size
.
width
surface
.
tile_size
.
height
)
;
self
.
gl
.
set_texture_buffer
(
self
.
depth_id
gl
:
:
DEPTH_COMPONENT16
valid_rect
.
size
.
width
valid_rect
.
size
.
height
0
ptr
:
:
null_mut
(
)
self
.
max_tile_size
.
width
self
.
max_tile_size
.
height
)
;
surface_info
.
fbo_id
=
tile
.
fbo_id
;
surface_info
.
origin
-
=
valid_rect
.
origin
.
to_vector
(
)
;
}
}
surface_info
}
fn
unbind
(
&
mut
self
)
{
let
id
=
self
.
cur_tile
;
if
let
Some
(
surface
)
=
self
.
surfaces
.
get
(
&
id
.
surface_id
)
{
if
let
Some
(
tile
)
=
surface
.
tiles
.
iter
(
)
.
find
(
|
t
|
t
.
x
=
=
id
.
x
&
&
t
.
y
=
=
id
.
y
)
{
if
tile
.
valid_rect
.
is_empty
(
)
{
self
.
flush_composites
(
&
id
surface
tile
)
;
return
;
}
let
(
swbuf
_
_
stride
)
=
self
.
gl
.
get_color_buffer
(
tile
.
fbo_id
true
)
;
if
let
Some
(
compositor
)
=
&
mut
self
.
compositor
{
compositor
.
unmap_tile
(
)
;
return
;
}
let
native_gl
=
match
&
self
.
native_gl
{
Some
(
native_gl
)
=
>
native_gl
None
=
>
{
self
.
flush_composites
(
&
id
surface
tile
)
;
return
;
}
}
;
assert
!
(
stride
%
4
=
=
0
)
;
let
buf
=
if
tile
.
pbo_id
!
=
0
{
native_gl
.
unmap_buffer
(
gl
:
:
PIXEL_UNPACK_BUFFER
)
;
0
as
*
mut
c_void
}
else
{
swbuf
}
;
let
dirty
=
tile
.
dirty_rect
;
let
src
=
unsafe
{
(
buf
as
*
mut
u32
)
.
offset
(
(
dirty
.
origin
.
y
-
tile
.
valid_rect
.
origin
.
y
)
as
isize
*
(
stride
/
4
)
as
isize
+
(
dirty
.
origin
.
x
-
tile
.
valid_rect
.
origin
.
x
)
as
isize
)
}
;
native_gl
.
active_texture
(
gl
:
:
TEXTURE0
)
;
native_gl
.
bind_texture
(
gl
:
:
TEXTURE_2D
tile
.
tex_id
)
;
native_gl
.
pixel_store_i
(
gl
:
:
UNPACK_ROW_LENGTH
stride
/
4
)
;
native_gl
.
tex_sub_image_2d_pbo
(
gl
:
:
TEXTURE_2D
0
dirty
.
origin
.
x
dirty
.
origin
.
y
dirty
.
size
.
width
dirty
.
size
.
height
gl
:
:
BGRA
gl
:
:
UNSIGNED_BYTE
src
as
_
)
;
native_gl
.
pixel_store_i
(
gl
:
:
UNPACK_ROW_LENGTH
0
)
;
if
tile
.
pbo_id
!
=
0
{
native_gl
.
bind_buffer
(
gl
:
:
PIXEL_UNPACK_BUFFER
0
)
;
}
if
let
Some
(
compositor
)
=
&
mut
self
.
compositor
{
let
info
=
compositor
.
bind
(
id
tile
.
dirty_rect
tile
.
valid_rect
)
;
native_gl
.
bind_framebuffer
(
gl
:
:
DRAW_FRAMEBUFFER
info
.
fbo_id
)
;
let
viewport
=
dirty
.
translate
(
info
.
origin
.
to_vector
(
)
)
;
let
draw_tile
=
self
.
draw_tile
.
as_ref
(
)
.
unwrap
(
)
;
draw_tile
.
enable
(
&
viewport
)
;
draw_tile
.
draw
(
&
viewport
&
viewport
&
dirty
&
surface
&
tile
false
gl
:
:
LINEAR
)
;
draw_tile
.
disable
(
)
;
native_gl
.
bind_framebuffer
(
gl
:
:
DRAW_FRAMEBUFFER
0
)
;
compositor
.
unbind
(
)
;
}
native_gl
.
bind_texture
(
gl
:
:
TEXTURE_2D
0
)
;
}
}
}
fn
begin_frame
(
&
mut
self
)
{
if
let
Some
(
compositor
)
=
&
mut
self
.
compositor
{
compositor
.
begin_frame
(
)
;
}
self
.
frame_surfaces
.
clear
(
)
;
self
.
late_surfaces
.
clear
(
)
;
self
.
reset_overlaps
(
)
;
if
self
.
composite_thread
.
is_some
(
)
{
self
.
locked_framebuffer
=
self
.
gl
.
lock_framebuffer
(
0
)
;
}
}
fn
add_surface
(
&
mut
self
id
:
NativeSurfaceId
transform
:
CompositorSurfaceTransform
clip_rect
:
DeviceIntRect
filter
:
ImageRendering
)
{
if
let
Some
(
compositor
)
=
&
mut
self
.
compositor
{
compositor
.
add_surface
(
id
transform
clip_rect
filter
)
;
}
if
self
.
composite_thread
.
is_some
(
)
{
self
.
try_lock_composite_surface
(
&
id
)
;
if
self
.
composite_thread
.
as_ref
(
)
.
unwrap
(
)
.
is_busy_compositing
(
)
{
self
.
late_surfaces
.
push
(
(
id
transform
clip_rect
filter
)
)
;
return
;
}
if
let
Some
(
surface
)
=
self
.
surfaces
.
get
(
&
id
)
{
for
tile
in
&
surface
.
tiles
{
self
.
init_overlaps
(
surface
tile
&
transform
&
clip_rect
)
;
}
}
}
self
.
frame_surfaces
.
push
(
(
id
transform
clip_rect
filter
)
)
;
}
fn
start_compositing
(
&
mut
self
)
{
if
let
Some
(
ref
composite_thread
)
=
self
.
composite_thread
{
composite_thread
.
start_compositing
(
)
;
for
&
(
ref
id
ref
transform
ref
clip_rect
filter
)
in
&
self
.
frame_surfaces
{
if
let
Some
(
surface
)
=
self
.
surfaces
.
get
(
id
)
{
for
tile
in
&
surface
.
tiles
{
if
tile
.
overlaps
.
get
(
)
=
=
0
{
self
.
queue_composite
(
surface
transform
clip_rect
filter
tile
)
;
}
}
}
}
}
}
fn
end_frame
(
&
mut
self
)
{
if
let
Some
(
compositor
)
=
&
mut
self
.
compositor
{
compositor
.
end_frame
(
)
;
}
else
if
let
Some
(
native_gl
)
=
&
self
.
native_gl
{
let
(
_
fw
fh
_
)
=
self
.
gl
.
get_color_buffer
(
0
false
)
;
let
viewport
=
DeviceIntRect
:
:
from_size
(
DeviceIntSize
:
:
new
(
fw
fh
)
)
;
let
draw_tile
=
self
.
draw_tile
.
as_ref
(
)
.
unwrap
(
)
;
draw_tile
.
enable
(
&
viewport
)
;
let
mut
blend
=
false
;
native_gl
.
blend_func
(
gl
:
:
ONE
gl
:
:
ONE_MINUS_SRC_ALPHA
)
;
for
&
(
ref
id
ref
transform
ref
clip_rect
filter
)
in
&
self
.
frame_surfaces
{
if
let
Some
(
surface
)
=
self
.
surfaces
.
get
(
id
)
{
if
surface
.
is_opaque
{
if
blend
{
native_gl
.
disable
(
gl
:
:
BLEND
)
;
blend
=
false
;
}
}
else
if
!
blend
{
native_gl
.
enable
(
gl
:
:
BLEND
)
;
blend
=
true
;
}
for
tile
in
&
surface
.
tiles
{
if
let
Some
(
(
src_rect
dst_rect
flip_y
)
)
=
tile
.
composite_rects
(
surface
transform
clip_rect
)
{
draw_tile
.
draw
(
&
viewport
&
dst_rect
&
src_rect
surface
tile
flip_y
image_rendering_to_gl_filter
(
filter
)
)
;
}
}
}
}
if
blend
{
native_gl
.
disable
(
gl
:
:
BLEND
)
;
}
draw_tile
.
disable
(
)
;
}
else
if
let
Some
(
ref
composite_thread
)
=
self
.
composite_thread
{
composite_thread
.
wait_for_composites
(
false
)
;
if
!
self
.
late_surfaces
.
is_empty
(
)
{
composite_thread
.
start_compositing
(
)
;
for
&
(
ref
id
ref
transform
ref
clip_rect
filter
)
in
&
self
.
late_surfaces
{
if
let
Some
(
surface
)
=
self
.
surfaces
.
get
(
id
)
{
for
tile
in
&
surface
.
tiles
{
self
.
queue_composite
(
surface
transform
clip_rect
filter
tile
)
;
}
}
}
composite_thread
.
wait_for_composites
(
true
)
;
}
self
.
locked_framebuffer
=
None
;
self
.
unlock_composite_surfaces
(
)
;
}
}
fn
enable_native_compositor
(
&
mut
self
enable
:
bool
)
{
if
let
Some
(
compositor
)
=
&
mut
self
.
compositor
{
compositor
.
enable_native_compositor
(
enable
)
;
}
}
fn
get_capabilities
(
&
self
)
-
>
CompositorCapabilities
{
if
let
Some
(
compositor
)
=
&
self
.
compositor
{
compositor
.
get_capabilities
(
)
}
else
{
CompositorCapabilities
{
virtual_surface_size
:
0
}
}
}
}
