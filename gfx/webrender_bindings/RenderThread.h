#
ifndef
MOZILLA_LAYERS_RENDERTHREAD_H
#
define
MOZILLA_LAYERS_RENDERTHREAD_H
#
include
"
base
/
basictypes
.
h
"
#
include
"
base
/
platform_thread
.
h
"
#
include
"
base
/
thread
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
ThreadSafeRefcountingWithMainThreadDestruction
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
webrender
/
webrender_ffi
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderTypes
.
h
"
#
include
"
mozilla
/
layers
/
SynchronousTask
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderCompositionRecorder
.
h
"
#
include
"
mozilla
/
VsyncDispatcher
.
h
"
#
include
<
list
>
#
include
<
queue
>
#
include
<
unordered_map
>
namespace
mozilla
{
namespace
gl
{
class
GLContext
;
}
namespace
layers
{
class
SurfacePool
;
}
namespace
wr
{
typedef
MozPromise
<
MemoryReport
bool
true
>
MemoryReportPromise
;
class
RendererOGL
;
class
RenderTextureHost
;
class
RenderThread
;
class
WebRenderThreadPool
{
public
:
explicit
WebRenderThreadPool
(
bool
low_priority
)
;
~
WebRenderThreadPool
(
)
;
wr
:
:
WrThreadPool
*
Raw
(
)
{
MOZ_RELEASE_ASSERT
(
mThreadPool
)
;
return
mThreadPool
;
}
void
Release
(
)
;
protected
:
wr
:
:
WrThreadPool
*
mThreadPool
;
}
;
class
WebRenderProgramCache
final
{
public
:
explicit
WebRenderProgramCache
(
wr
:
:
WrThreadPool
*
aThreadPool
)
;
~
WebRenderProgramCache
(
)
;
wr
:
:
WrProgramCache
*
Raw
(
)
{
return
mProgramCache
;
}
protected
:
wr
:
:
WrProgramCache
*
mProgramCache
;
}
;
class
WebRenderShaders
final
{
public
:
WebRenderShaders
(
gl
:
:
GLContext
*
gl
WebRenderProgramCache
*
programCache
)
;
~
WebRenderShaders
(
)
;
wr
:
:
WrShaders
*
RawShaders
(
)
{
return
mShaders
;
}
protected
:
RefPtr
<
gl
:
:
GLContext
>
mGL
;
wr
:
:
WrShaders
*
mShaders
;
}
;
class
WebRenderPipelineInfo
final
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
WebRenderPipelineInfo
)
;
const
wr
:
:
WrPipelineInfo
&
Raw
(
)
const
{
return
mPipelineInfo
;
}
wr
:
:
WrPipelineInfo
&
Raw
(
)
{
return
mPipelineInfo
;
}
protected
:
~
WebRenderPipelineInfo
(
)
=
default
;
wr
:
:
WrPipelineInfo
mPipelineInfo
;
}
;
class
RendererEvent
{
public
:
virtual
~
RendererEvent
(
)
=
default
;
virtual
void
Run
(
RenderThread
&
aRenderThread
wr
:
:
WindowId
aWindow
)
=
0
;
}
;
class
RenderThread
final
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING_WITH_MAIN_THREAD_DESTRUCTION
(
RenderThread
)
public
:
static
RenderThread
*
Get
(
)
;
static
void
Start
(
)
;
static
void
ShutDown
(
)
;
static
MessageLoop
*
Loop
(
)
;
static
bool
IsInRenderThread
(
)
;
static
RefPtr
<
MemoryReportPromise
>
AccumulateMemoryReport
(
MemoryReport
aInitial
)
;
void
AddRenderer
(
wr
:
:
WindowId
aWindowId
UniquePtr
<
RendererOGL
>
aRenderer
)
;
void
RemoveRenderer
(
wr
:
:
WindowId
aWindowId
)
;
RendererOGL
*
GetRenderer
(
wr
:
:
WindowId
aWindowId
)
;
void
HandleFrameOneDoc
(
wr
:
:
WindowId
aWindowId
bool
aRender
)
;
void
WakeUp
(
wr
:
:
WindowId
aWindowId
)
;
void
PipelineSizeChanged
(
wr
:
:
WindowId
aWindowId
uint64_t
aPipelineId
float
aWidth
float
aHeight
)
;
void
RunEvent
(
wr
:
:
WindowId
aWindowId
UniquePtr
<
RendererEvent
>
aCallBack
)
;
void
UpdateAndRender
(
wr
:
:
WindowId
aWindowId
const
VsyncId
&
aStartId
const
TimeStamp
&
aStartTime
bool
aRender
const
Maybe
<
gfx
:
:
IntSize
>
&
aReadbackSize
const
Maybe
<
wr
:
:
ImageFormat
>
&
aReadbackFormat
const
Maybe
<
Range
<
uint8_t
>
>
&
aReadbackBuffer
bool
*
aNeedsYFlip
=
nullptr
)
;
void
Pause
(
wr
:
:
WindowId
aWindowId
)
;
bool
Resume
(
wr
:
:
WindowId
aWindowId
)
;
void
RegisterExternalImage
(
uint64_t
aExternalImageId
already_AddRefed
<
RenderTextureHost
>
aTexture
)
;
void
UnregisterExternalImage
(
uint64_t
aExternalImageId
)
;
void
PrepareForUse
(
uint64_t
aExternalImageId
)
;
void
NotifyNotUsed
(
uint64_t
aExternalImageId
)
;
void
NotifyForUse
(
uint64_t
aExternalImageId
)
;
void
HandleRenderTextureOps
(
)
;
void
UnregisterExternalImageDuringShutdown
(
uint64_t
aExternalImageId
)
;
RenderTextureHost
*
GetRenderTexture
(
ExternalImageId
aExternalImageId
)
;
bool
IsDestroyed
(
wr
:
:
WindowId
aWindowId
)
;
void
SetDestroyed
(
wr
:
:
WindowId
aWindowId
)
;
bool
TooManyPendingFrames
(
wr
:
:
WindowId
aWindowId
)
;
void
IncPendingFrameCount
(
wr
:
:
WindowId
aWindowId
const
VsyncId
&
aStartId
const
TimeStamp
&
aStartTime
)
;
void
DecPendingFrameBuildCount
(
wr
:
:
WindowId
aWindowId
)
;
WebRenderThreadPool
&
ThreadPool
(
)
{
return
mThreadPool
;
}
WebRenderThreadPool
&
ThreadPoolLP
(
)
{
return
mThreadPoolLP
;
}
WebRenderProgramCache
*
GetProgramCache
(
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
return
mProgramCache
.
get
(
)
;
}
WebRenderShaders
*
GetShaders
(
)
{
MOZ_ASSERT
(
IsInRenderThread
(
)
)
;
return
mShaders
.
get
(
)
;
}
gl
:
:
GLContext
*
SharedGL
(
nsACString
&
aError
)
;
gl
:
:
GLContext
*
SharedGL
(
)
;
void
ClearSharedGL
(
)
;
RefPtr
<
layers
:
:
SurfacePool
>
SharedSurfacePool
(
)
;
void
ClearSharedSurfacePool
(
)
;
void
HandleDeviceReset
(
const
char
*
aWhere
bool
aNotify
)
;
bool
IsHandlingDeviceReset
(
)
;
void
SimulateDeviceReset
(
)
;
void
NotifyWebRenderError
(
WebRenderError
aError
)
;
void
HandleWebRenderError
(
WebRenderError
aError
)
;
bool
IsHandlingWebRenderError
(
)
;
bool
SyncObjectNeeded
(
)
;
size_t
RendererCount
(
)
;
void
SetCompositionRecorderForWindow
(
wr
:
:
WindowId
aWindowId
UniquePtr
<
layers
:
:
WebRenderCompositionRecorder
>
aCompositionRecorder
)
;
void
WriteCollectedFramesForWindow
(
wr
:
:
WindowId
aWindowId
)
;
Maybe
<
layers
:
:
CollectedFrames
>
GetCollectedFramesForWindow
(
wr
:
:
WindowId
aWindowId
)
;
static
void
MaybeEnableGLDebugMessage
(
gl
:
:
GLContext
*
aGLContext
)
;
private
:
enum
class
RenderTextureOp
{
PrepareForUse
NotifyForUse
NotifyNotUsed
}
;
explicit
RenderThread
(
base
:
:
Thread
*
aThread
)
;
void
DeferredRenderTextureHostDestroy
(
)
;
void
ShutDownTask
(
layers
:
:
SynchronousTask
*
aTask
)
;
void
InitDeviceTask
(
)
;
void
DoAccumulateMemoryReport
(
MemoryReport
const
RefPtr
<
MemoryReportPromise
:
:
Private
>
&
)
;
void
AddRenderTextureOp
(
RenderTextureOp
aOp
uint64_t
aExternalImageId
)
;
~
RenderThread
(
)
;
base
:
:
Thread
*
const
mThread
;
WebRenderThreadPool
mThreadPool
;
WebRenderThreadPool
mThreadPoolLP
;
UniquePtr
<
WebRenderProgramCache
>
mProgramCache
;
UniquePtr
<
WebRenderShaders
>
mShaders
;
RefPtr
<
gl
:
:
GLContext
>
mSharedGL
;
RefPtr
<
layers
:
:
SurfacePool
>
mSurfacePool
;
std
:
:
map
<
wr
:
:
WindowId
UniquePtr
<
RendererOGL
>
>
mRenderers
;
std
:
:
map
<
wr
:
:
WindowId
UniquePtr
<
layers
:
:
WebRenderCompositionRecorder
>
>
mCompositionRecorders
;
struct
PendingFrameInfo
{
TimeStamp
mStartTime
;
VsyncId
mStartId
;
bool
mFrameNeedsRender
=
false
;
}
;
struct
WindowInfo
{
int64_t
PendingCount
(
)
{
return
mPendingFrames
.
size
(
)
;
}
std
:
:
queue
<
PendingFrameInfo
>
mPendingFrames
;
uint8_t
mPendingFrameBuild
=
0
;
bool
mIsDestroyed
=
false
;
}
;
DataMutex
<
std
:
:
unordered_map
<
uint64_t
WindowInfo
*
>
>
mWindowInfos
;
Mutex
mRenderTextureMapLock
;
std
:
:
unordered_map
<
uint64_t
RefPtr
<
RenderTextureHost
>
>
mRenderTextures
;
std
:
:
unordered_map
<
uint64_t
RefPtr
<
RenderTextureHost
>
>
mSyncObjectNeededRenderTextures
;
std
:
:
list
<
std
:
:
pair
<
RenderTextureOp
RefPtr
<
RenderTextureHost
>
>
>
mRenderTextureOps
;
std
:
:
list
<
RefPtr
<
RenderTextureHost
>
>
mRenderTexturesDeferred
;
bool
mHasShutdown
;
bool
mHandlingDeviceReset
;
bool
mHandlingWebRenderError
;
}
;
}
}
#
endif
