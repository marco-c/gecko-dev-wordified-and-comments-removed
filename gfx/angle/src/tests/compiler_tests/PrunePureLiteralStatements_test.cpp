#
include
"
angle_gl
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
tests
/
test_utils
/
compiler_test
.
h
"
using
namespace
sh
;
namespace
{
class
PrunePureLiteralStatementsTest
:
public
MatchOutputCodeTest
{
public
:
PrunePureLiteralStatementsTest
(
)
:
MatchOutputCodeTest
(
GL_FRAGMENT_SHADER
0
SH_ESSL_OUTPUT
)
{
}
}
;
TEST_F
(
PrunePureLiteralStatementsTest
FloatLiteralStatement
)
{
const
std
:
:
string
shaderString
=
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
float
f
=
41
.
0
;
\
n
"
"
42
.
0
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
foundInCode
(
"
41
"
)
)
;
ASSERT_TRUE
(
notFoundInCode
(
"
42
"
)
)
;
}
TEST_F
(
PrunePureLiteralStatementsTest
ConstructorLiteralStatement
)
{
const
std
:
:
string
shaderString
=
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
vec2
f
=
vec2
(
41
.
0
41
.
0
)
;
\
n
"
"
vec2
(
42
.
0
42
.
0
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
foundInCode
(
"
41
"
)
)
;
ASSERT_TRUE
(
notFoundInCode
(
"
42
"
)
)
;
}
TEST_F
(
PrunePureLiteralStatementsTest
ExpressionLiteralStatement
)
{
const
std
:
:
string
shaderString
=
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
vec2
(
21
.
0
21
.
0
)
+
vec2
(
21
.
0
21
.
0
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
notFoundInCode
(
"
21
"
)
)
;
ASSERT_TRUE
(
notFoundInCode
(
"
42
"
)
)
;
}
TEST_F
(
PrunePureLiteralStatementsTest
ForLoopLiteralExpression
)
{
const
std
:
:
string
shaderString
=
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
for
(
;
;
vec2
(
42
.
0
42
.
0
)
)
{
}
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
notFoundInCode
(
"
42
"
)
)
;
}
TEST_F
(
PrunePureLiteralStatementsTest
SwitchLiteralExpressionEmptyCase
)
{
const
std
:
:
string
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
switch
(
1
)
\
n
"
"
{
\
n
"
"
default
:
\
n
"
"
42
;
\
n
"
"
}
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
notFoundInCode
(
"
default
"
)
)
;
ASSERT_TRUE
(
notFoundInCode
(
"
42
"
)
)
;
}
TEST_F
(
PrunePureLiteralStatementsTest
SwitchLiteralExpressionEmptyCases
)
{
const
std
:
:
string
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
switch
(
1
)
\
n
"
"
{
\
n
"
"
case
1
:
\
n
"
"
case
2
:
\
n
"
"
default
:
\
n
"
"
42
;
\
n
"
"
}
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
notFoundInCode
(
"
default
"
)
)
;
ASSERT_TRUE
(
notFoundInCode
(
"
case
"
)
)
;
ASSERT_TRUE
(
notFoundInCode
(
"
42
"
)
)
;
}
TEST_F
(
PrunePureLiteralStatementsTest
SwitchLiteralExpressionOnlyLastCase
)
{
const
std
:
:
string
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
switch
(
1
)
\
n
"
"
{
\
n
"
"
case
1
:
\
n
"
"
default
:
\
n
"
"
42
;
\
n
"
"
break
;
\
n
"
"
}
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
foundInCode
(
"
default
"
)
)
;
ASSERT_TRUE
(
foundInCode
(
"
case
"
)
)
;
ASSERT_TRUE
(
notFoundInCode
(
"
42
"
)
)
;
}
TEST_F
(
PrunePureLiteralStatementsTest
SwitchLiteralExpressionLiteralDoesntStop
)
{
const
std
:
:
string
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
switch
(
1
)
\
n
"
"
{
\
n
"
"
case
1
:
\
n
"
"
42
;
\
n
"
"
case
2
:
\
n
"
"
43
;
\
n
"
"
}
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
notFoundInCode
(
"
case
"
)
)
;
ASSERT_TRUE
(
notFoundInCode
(
"
42
"
)
)
;
ASSERT_TRUE
(
notFoundInCode
(
"
43
"
)
)
;
}
}
