#
include
"
angle_gl
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
GLSLANG
/
ShaderLang
.
h
"
using
testing
:
:
Combine
;
using
testing
:
:
Values
;
using
testing
:
:
make_tuple
;
namespace
{
const
char
ESSLVersion100
[
]
=
"
#
version
100
\
n
"
;
const
char
ESSLVersion300
[
]
=
"
#
version
300
es
\
n
"
;
const
char
ESSLVersion310
[
]
=
"
#
version
310
es
\
n
"
;
const
char
EXTBFEPragma
[
]
=
"
#
extension
GL_EXT_blend_func_extended
:
require
\
n
"
;
const
char
ESSL100_SimpleShader1
[
]
=
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
gl_SecondaryFragColorEXT
=
vec4
(
gl_MaxDualSourceDrawBuffersEXT
/
10
)
;
\
n
"
"
}
\
n
"
;
const
char
ESSL100_MaxDualSourceAccessShader
[
]
=
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
{
gl_FragColor
=
vec4
(
gl_MaxDualSourceDrawBuffersEXT
/
10
)
;
}
\
n
"
;
const
char
ESSL100_FragDataShader
[
]
=
"
#
extension
GL_EXT_draw_buffers
:
require
\
n
"
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragData
[
gl_MaxDrawBuffers
-
1
]
=
vec4
(
1
.
0
)
;
\
n
"
"
gl_SecondaryFragDataEXT
[
gl_MaxDualSourceDrawBuffersEXT
-
1
]
=
vec4
(
0
.
1
)
;
\
n
"
"
}
\
n
"
;
const
char
ESSL100_ColorAndDataWriteFailureShader1
[
]
=
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_SecondaryFragColorEXT
=
vec4
(
1
.
0
)
;
\
n
"
"
gl_SecondaryFragDataEXT
[
gl_MaxDualSourceDrawBuffersEXT
]
=
vec4
(
0
.
1
)
;
\
n
"
"
}
\
n
"
;
const
char
ESSL100_ColorAndDataWriteFailureShader2
[
]
=
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
gl_SecondaryFragDataEXT
[
gl_MaxDualSourceDrawBuffersEXT
]
=
vec4
(
0
.
1
)
;
\
n
"
"
}
\
n
"
;
const
char
ESSL100_ColorAndDataWriteFailureShader3
[
]
=
"
#
extension
GL_EXT_draw_buffers
:
require
\
n
"
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_SecondaryFragColorEXT
=
vec4
(
1
.
0
)
;
\
n
"
"
gl_FragData
[
gl_MaxDrawBuffers
]
=
vec4
(
0
.
1
)
;
\
n
"
"
}
\
n
"
;
const
char
ESSL300_MaxDualSourceAccessShader
[
]
=
"
precision
mediump
float
;
\
n
"
"
layout
(
location
=
0
)
out
mediump
vec4
fragColor
;
"
"
void
main
(
)
{
\
n
"
"
fragColor
=
vec4
(
gl_MaxDualSourceDrawBuffersEXT
/
10
)
;
\
n
"
"
}
\
n
"
;
const
char
ESSL300_LocationAndUnspecifiedOutputShader
[
]
=
"
precision
mediump
float
;
\
n
"
"
layout
(
location
=
0
)
out
mediump
vec4
fragColor
;
"
"
out
mediump
vec4
secondaryFragColor
;
"
"
void
main
(
)
{
\
n
"
"
fragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
secondaryFragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
const
char
ESSL300_TwoUnspecifiedLocationOutputsShader
[
]
=
"
precision
mediump
float
;
\
n
"
"
out
mediump
vec4
fragColor
;
"
"
out
mediump
vec4
secondaryFragColor
;
"
"
void
main
(
)
{
\
n
"
"
fragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
secondaryFragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
const
char
ESSL310_LocationIndexShader
[
]
=
"
precision
mediump
float
;
\
n
"
"
layout
(
location
=
0
)
out
mediump
vec4
fragColor
;
"
"
layout
(
location
=
0
index
=
1
)
out
mediump
vec4
secondaryFragColor
;
"
"
void
main
(
)
{
\
n
"
"
fragColor
=
vec4
(
1
)
;
\
n
"
"
secondaryFragColor
=
vec4
(
1
)
;
\
n
"
"
}
\
n
"
;
const
char
ESSL310_LocationIndexFailureShader
[
]
=
"
precision
mediump
float
;
\
n
"
"
layout
(
location
=
0
)
out
mediump
vec4
fragColor
;
"
"
layout
(
index
=
1
)
out
mediump
vec4
secondaryFragColor
;
"
"
void
main
(
)
{
\
n
"
"
fragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
secondaryFragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
class
EXTBlendFuncExtendedTest
:
public
testing
:
:
TestWithParam
<
testing
:
:
tuple
<
ShShaderSpec
const
char
*
const
char
*
>
>
{
protected
:
virtual
void
SetUp
(
)
{
ShInitBuiltInResources
(
&
mResources
)
;
mResources
.
EXT_draw_buffers
=
1
;
mResources
.
NV_draw_buffers
=
2
;
mCompiler
=
NULL
;
}
virtual
void
TearDown
(
)
{
DestroyCompiler
(
)
;
}
void
DestroyCompiler
(
)
{
if
(
mCompiler
)
{
ShDestruct
(
mCompiler
)
;
mCompiler
=
NULL
;
}
}
void
InitializeCompiler
(
)
{
DestroyCompiler
(
)
;
mCompiler
=
ShConstructCompiler
(
GL_FRAGMENT_SHADER
testing
:
:
get
<
0
>
(
GetParam
(
)
)
SH_GLSL_COMPATIBILITY_OUTPUT
&
mResources
)
;
ASSERT_TRUE
(
mCompiler
!
=
NULL
)
<
<
"
Compiler
could
not
be
constructed
.
"
;
}
testing
:
:
AssertionResult
TestShaderCompile
(
const
char
*
pragma
)
{
return
TestShaderCompile
(
testing
:
:
get
<
1
>
(
GetParam
(
)
)
pragma
testing
:
:
get
<
2
>
(
GetParam
(
)
)
)
;
}
testing
:
:
AssertionResult
TestShaderCompile
(
const
char
*
version
const
char
*
pragma
const
char
*
shader
)
{
const
char
*
shaderStrings
[
]
=
{
version
pragma
shader
}
;
bool
success
=
ShCompile
(
mCompiler
shaderStrings
3
0
)
;
if
(
success
)
{
return
:
:
testing
:
:
AssertionSuccess
(
)
<
<
"
Compilation
success
"
;
}
return
:
:
testing
:
:
AssertionFailure
(
)
<
<
ShGetInfoLog
(
mCompiler
)
;
}
protected
:
ShBuiltInResources
mResources
;
ShHandle
mCompiler
;
}
;
TEST_P
(
EXTBlendFuncExtendedTest
CompileFailsWithoutExtension
)
{
mResources
.
EXT_blend_func_extended
=
0
;
InitializeCompiler
(
)
;
EXPECT_FALSE
(
TestShaderCompile
(
EXTBFEPragma
)
)
;
}
TEST_P
(
EXTBlendFuncExtendedTest
CompileFailsWithExtensionWithoutPragma
)
{
mResources
.
EXT_blend_func_extended
=
1
;
mResources
.
MaxDualSourceDrawBuffers
=
1
;
InitializeCompiler
(
)
;
EXPECT_FALSE
(
TestShaderCompile
(
"
"
)
)
;
}
TEST_P
(
EXTBlendFuncExtendedTest
CompileSucceedsWithExtensionAndPragma
)
{
mResources
.
EXT_blend_func_extended
=
1
;
mResources
.
MaxDualSourceDrawBuffers
=
1
;
InitializeCompiler
(
)
;
EXPECT_TRUE
(
TestShaderCompile
(
EXTBFEPragma
)
)
;
EXPECT_FALSE
(
TestShaderCompile
(
"
"
)
)
;
EXPECT_TRUE
(
TestShaderCompile
(
EXTBFEPragma
)
)
;
}
INSTANTIATE_TEST_CASE_P
(
CorrectESSL100Shaders
EXTBlendFuncExtendedTest
Combine
(
Values
(
SH_GLES2_SPEC
SH_GLES3_SPEC
)
Values
(
"
"
ESSLVersion100
)
Values
(
ESSL100_SimpleShader1
ESSL100_MaxDualSourceAccessShader
ESSL100_FragDataShader
)
)
)
;
INSTANTIATE_TEST_CASE_P
(
CorrectESSL300Shaders
EXTBlendFuncExtendedTest
Combine
(
Values
(
SH_GLES3_SPEC
)
Values
(
ESSLVersion300
)
Values
(
ESSL300_MaxDualSourceAccessShader
ESSL300_LocationAndUnspecifiedOutputShader
ESSL300_TwoUnspecifiedLocationOutputsShader
)
)
)
;
class
EXTBlendFuncExtendedCompileFailureTest
:
public
EXTBlendFuncExtendedTest
{
}
;
TEST_P
(
EXTBlendFuncExtendedCompileFailureTest
CompileFails
)
{
mResources
.
EXT_blend_func_extended
=
1
;
mResources
.
MaxDualSourceDrawBuffers
=
1
;
InitializeCompiler
(
)
;
EXPECT_FALSE
(
TestShaderCompile
(
EXTBFEPragma
)
)
;
}
INSTANTIATE_TEST_CASE_P
(
IncorrectESSL100Shaders
EXTBlendFuncExtendedCompileFailureTest
Combine
(
Values
(
SH_GLES2_SPEC
)
Values
(
ESSLVersion100
)
Values
(
ESSL100_ColorAndDataWriteFailureShader1
ESSL100_ColorAndDataWriteFailureShader2
ESSL100_ColorAndDataWriteFailureShader3
)
)
)
;
INSTANTIATE_TEST_CASE_P
(
CorrectESSL300Shaders
EXTBlendFuncExtendedCompileFailureTest
Combine
(
Values
(
SH_GLES2_SPEC
)
Values
(
"
"
ESSLVersion100
ESSLVersion300
)
Values
(
ESSL300_LocationAndUnspecifiedOutputShader
ESSL300_TwoUnspecifiedLocationOutputsShader
)
)
)
;
INSTANTIATE_TEST_CASE_P
(
CorrectESSL100Shaders
EXTBlendFuncExtendedCompileFailureTest
Combine
(
Values
(
SH_GLES3_SPEC
)
Values
(
ESSLVersion300
)
Values
(
ESSL100_SimpleShader1
ESSL100_FragDataShader
)
)
)
;
INSTANTIATE_TEST_CASE_P
(
IncorrectESSL310Shaders
EXTBlendFuncExtendedCompileFailureTest
Combine
(
Values
(
SH_GLES3_SPEC
)
Values
(
ESSLVersion300
ESSLVersion310
)
Values
(
ESSL310_LocationIndexFailureShader
)
)
)
;
INSTANTIATE_TEST_CASE_P
(
CorrectESSL310ShadersInESSL300
EXTBlendFuncExtendedCompileFailureTest
Values
(
make_tuple
(
SH_GLES3_SPEC
&
ESSLVersion300
[
0
]
&
ESSL310_LocationIndexShader
[
0
]
)
)
)
;
INSTANTIATE_TEST_CASE_P
(
CorrectESSL310Shaders
EXTBlendFuncExtendedCompileFailureTest
Values
(
make_tuple
(
SH_GLES3_SPEC
&
ESSLVersion310
[
0
]
&
ESSL310_LocationIndexShader
[
0
]
)
)
)
;
}
