#
include
"
angle_gl
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
GLSLANG
/
ShaderLang
.
h
"
#
include
"
compiler
/
translator
/
TranslatorESSL
.
h
"
class
MalformedShaderTest
:
public
testing
:
:
Test
{
public
:
MalformedShaderTest
(
)
{
}
protected
:
virtual
void
SetUp
(
)
{
ShBuiltInResources
resources
;
ShInitBuiltInResources
(
&
resources
)
;
mTranslator
=
new
TranslatorESSL
(
GL_FRAGMENT_SHADER
SH_GLES3_SPEC
)
;
ASSERT_TRUE
(
mTranslator
-
>
Init
(
resources
)
)
;
}
virtual
void
TearDown
(
)
{
delete
mTranslator
;
}
bool
compile
(
const
std
:
:
string
&
shaderString
)
{
const
char
*
shaderStrings
[
]
=
{
shaderString
.
c_str
(
)
}
;
bool
compilationSuccess
=
mTranslator
-
>
compile
(
shaderStrings
1
SH_INTERMEDIATE_TREE
)
;
TInfoSink
&
infoSink
=
mTranslator
-
>
getInfoSink
(
)
;
mInfoLog
=
infoSink
.
info
.
c_str
(
)
;
return
compilationSuccess
;
}
bool
hasWarning
(
)
const
{
return
mInfoLog
.
find
(
"
WARNING
:
"
)
!
=
std
:
:
string
:
:
npos
;
}
protected
:
std
:
:
string
mInfoLog
;
TranslatorESSL
*
mTranslator
;
}
;
class
MalformedVertexShaderTest
:
public
MalformedShaderTest
{
public
:
MalformedVertexShaderTest
(
)
{
}
protected
:
void
SetUp
(
)
override
{
ShBuiltInResources
resources
;
ShInitBuiltInResources
(
&
resources
)
;
mTranslator
=
new
TranslatorESSL
(
GL_VERTEX_SHADER
SH_GLES3_SPEC
)
;
ASSERT_TRUE
(
mTranslator
-
>
Init
(
resources
)
)
;
}
}
;
class
MalformedWebGL2ShaderTest
:
public
MalformedShaderTest
{
public
:
MalformedWebGL2ShaderTest
(
)
{
}
protected
:
void
SetUp
(
)
override
{
ShBuiltInResources
resources
;
ShInitBuiltInResources
(
&
resources
)
;
mTranslator
=
new
TranslatorESSL
(
GL_FRAGMENT_SHADER
SH_WEBGL2_SPEC
)
;
ASSERT_TRUE
(
mTranslator
-
>
Init
(
resources
)
)
;
}
}
;
TEST_F
(
MalformedShaderTest
FunctionParameterMismatch
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
float
fun
(
float
a
)
{
\
n
"
"
return
a
*
2
.
0
;
\
n
"
"
}
\
n
"
"
void
main
(
)
{
\
n
"
"
float
ff
=
fun
(
)
;
\
n
"
"
gl_FragColor
=
vec4
(
ff
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
RedeclaringFunctionAsVariable
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
float
fun
(
float
a
)
{
\
n
"
"
return
a
*
2
.
0
;
\
n
"
"
}
\
n
"
"
float
fun
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
RedeclaringFunctionAsStruct
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
float
fun
(
float
a
)
{
\
n
"
"
return
a
*
2
.
0
;
\
n
"
"
}
\
n
"
"
struct
fun
{
float
a
;
}
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
RedeclaringFunctionWithDifferentQualifiers
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
float
fun
(
out
float
a
)
;
\
n
"
"
float
fun
(
float
a
)
{
\
n
"
"
return
a
*
2
.
0
;
\
n
"
"
}
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
CompareStructsContainingArrays
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
struct
s
{
float
a
[
3
]
;
}
;
\
n
"
"
void
main
(
)
{
\
n
"
"
s
a
;
\
n
"
"
s
b
;
\
n
"
"
bool
c
=
(
a
=
=
b
)
;
\
n
"
"
gl_FragColor
=
vec4
(
c
?
1
.
0
:
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
AssignStructsContainingArrays
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
struct
s
{
float
a
[
3
]
;
}
;
\
n
"
"
void
main
(
)
{
\
n
"
"
s
a
;
\
n
"
"
s
b
;
\
n
"
"
b
.
a
[
0
]
=
0
.
0
;
\
n
"
"
a
=
b
;
\
n
"
"
gl_FragColor
=
vec4
(
a
.
a
[
0
]
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
CompareStructsContainingSamplers
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
struct
s
{
sampler2D
foo
;
}
;
\
n
"
"
uniform
s
a
;
\
n
"
"
uniform
s
b
;
\
n
"
"
void
main
(
)
{
\
n
"
"
bool
c
=
(
a
=
=
b
)
;
\
n
"
"
gl_FragColor
=
vec4
(
c
?
1
.
0
:
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
AssignStructsContainingSamplers
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
struct
s
{
sampler2D
foo
;
}
;
\
n
"
"
uniform
s
a
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
s
b
;
\
n
"
"
b
=
a
;
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
ArrayWithNoSizeInInitializerList
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
{
\
n
"
"
float
a
[
2
]
b
[
]
;
\
n
"
"
gl_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
ConstVarNotInitialized
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
float
a
;
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
ConstStructNotInitialized
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
struct
S
{
\
n
"
"
float
a
[
3
]
;
\
n
"
"
}
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
S
b
;
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
ConstArrayNotInitialized
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
float
a
[
3
]
;
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
BlockLayoutQualifierOnRegularUniform
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
packed
)
uniform
mat2
x
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
BlockLayoutQualifierOnUniformWithEmptyDecl
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
packed
)
uniform
mat2
x
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
ArraysOfArrays1
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
float
[
5
]
a
[
3
]
;
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
ArraysOfArrays2
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
float
[
2
]
a
b
[
3
]
;
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
UninitializedImplicitArraySize
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
float
[
]
a
;
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
TernaryOperatorNotConstantExpression
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
uniform
bool
u
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
bool
a
=
true
?
true
:
u
;
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
TernaryOperatorOnArrays
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
float
[
1
]
a
=
float
[
1
]
(
0
.
0
)
;
\
n
"
"
float
[
1
]
b
=
float
[
1
]
(
1
.
0
)
;
\
n
"
"
float
[
1
]
c
=
true
?
a
:
b
;
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
TernaryOperatorOnStructs
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
struct
S
{
float
foo
;
}
;
\
n
"
"
void
main
(
)
{
\
n
"
"
S
a
=
S
(
0
.
0
)
;
\
n
"
"
S
b
=
S
(
1
.
0
)
;
\
n
"
"
S
c
=
true
?
a
:
b
;
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
AssignArrayLengthToUnsigned
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
int
[
1
]
arr
;
\
n
"
"
uint
l
=
arr
.
length
(
)
;
\
n
"
"
my_FragColor
=
vec4
(
float
(
l
)
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
AssignVaryingToGlobal
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
varying
float
a
;
\
n
"
"
float
b
=
a
*
2
.
0
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
vec4
(
b
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
AssignUniformToGlobalESSL3
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
float
a
;
\
n
"
"
float
b
=
a
*
2
.
0
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
b
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
AssignUniformToGlobalESSL1
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
uniform
float
a
;
\
n
"
"
float
b
=
a
*
2
.
0
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
vec4
(
b
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
if
(
!
hasWarning
(
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
without
warnings
expecting
warning
"
<
<
mInfoLog
;
}
}
else
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
with
warning
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
AssignFunctionCallToGlobal
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
float
foo
(
)
{
return
1
.
0
;
}
\
n
"
"
float
b
=
foo
(
)
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
vec4
(
b
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
AssignAssignmentToGlobal
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
float
c
=
1
.
0
;
\
n
"
"
float
b
=
(
c
=
0
.
0
)
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
vec4
(
b
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
AssignIncrementToGlobal
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
float
c
=
1
.
0
;
\
n
"
"
float
b
=
(
c
+
+
)
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
vec4
(
b
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
AssignTexture2DToGlobal
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
uniform
mediump
sampler2D
s
;
\
n
"
"
float
b
=
texture2D
(
s
vec2
(
0
.
5
0
.
5
)
)
.
x
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
vec4
(
b
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
AssignNonConstGlobalToGlobal
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
float
a
=
1
.
0
;
\
n
"
"
float
b
=
a
*
2
.
0
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
b
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
AssignConstGlobalToGlobal
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
const
float
a
=
1
.
0
;
\
n
"
"
float
b
=
a
*
2
.
0
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
b
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
WriteBothFragDataAndFragColor
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
void
foo
(
)
{
\
n
"
"
gl_FragData
[
0
]
.
a
+
+
;
\
n
"
"
}
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
.
x
+
=
0
.
0
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
VersionOnSecondLine
)
{
const
std
:
:
string
&
shaderString
=
"
\
n
"
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
LayoutQualifierInCondition
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
vec4
u
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
int
i
=
0
;
\
n
"
"
for
(
int
j
=
0
;
layout
(
location
=
0
)
bool
b
=
false
;
+
+
j
)
{
\
n
"
"
+
+
i
;
\
n
"
"
}
\
n
"
"
my_FragColor
=
u
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
LayoutQualifierInFunctionReturnType
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
vec4
u
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
layout
(
location
=
0
)
vec4
foo
(
)
{
\
n
"
"
return
u
;
\
n
"
"
}
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
foo
(
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
TwoOutputsNoLayoutQualifiers
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
vec4
u
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
out
vec4
my_SecondaryFragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
my_SecondaryFragColor
=
vec4
(
0
.
5
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
TwoOutputsFirstLayoutQualifier
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
vec4
u
;
\
n
"
"
layout
(
location
=
0
)
out
vec4
my_FragColor
;
\
n
"
"
out
vec4
my_SecondaryFragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
my_SecondaryFragColor
=
vec4
(
0
.
5
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
TwoOutputsSecondLayoutQualifier
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
vec4
u
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
layout
(
location
=
0
)
out
vec4
my_SecondaryFragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
my_SecondaryFragColor
=
vec4
(
0
.
5
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
UniformArray
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
vec4
[
2
]
u
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
u
[
0
]
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
FragmentInputArrayOfStructs
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
struct
S
{
\
n
"
"
vec4
foo
;
\
n
"
"
}
;
\
n
"
"
in
S
i
[
2
]
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
i
[
0
]
.
foo
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedVertexShaderTest
VertexShaderInputArray
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
in
vec4
i
[
2
]
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_Position
=
i
[
0
]
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedVertexShaderTest
VertexShaderInputArrayType
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
in
vec4
[
2
]
i
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_Position
=
i
[
0
]
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
FragmentShaderInputStructWithBool
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
struct
S
{
\
n
"
"
bool
foo
;
\
n
"
"
}
;
\
n
"
"
in
S
s
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
FragmentShaderInputStructWithInt
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
struct
S
{
\
n
"
"
int
foo
;
\
n
"
"
}
;
\
n
"
"
in
S
s
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
ShaderSelectingFieldOfVectorIndexedFromArray
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
uniform
int
i
;
\
n
"
"
void
main
(
)
{
\
n
"
"
float
f
=
vec2
[
1
]
(
vec2
(
0
.
0
0
.
1
)
)
[
i
]
.
x
;
\
n
"
"
my_FragColor
=
vec4
(
f
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
ArrayValueFromFunctionParameterAsParameter
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
uniform
float
u
;
\
n
"
"
float
foo
(
float
f
)
{
\
n
"
"
return
f
*
2
.
0
;
\
n
"
"
}
\
n
"
"
float
bar
(
float
[
2
]
f
)
{
\
n
"
"
return
foo
(
f
[
0
]
)
;
\
n
"
"
}
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
float
arr
[
2
]
;
\
n
"
"
arr
[
0
]
=
u
;
\
n
"
"
gl_FragColor
=
vec4
(
bar
(
arr
)
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
OutOfRangeIntegerLiteral
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
highp
int
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
0x100000000
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
FieldSelectionFromVectorArrayConstructorIsConst
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
const
float
f
=
vec2
[
1
]
(
vec2
(
0
.
0
1
.
0
)
)
[
0
]
.
x
;
\
n
"
"
my_FragColor
=
vec4
(
f
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
FieldSelectionFromStructArrayConstructorIsConst
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
struct
S
{
float
member
;
}
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
const
float
f
=
S
[
1
]
(
S
(
0
.
0
)
)
[
0
]
.
member
;
\
n
"
"
my_FragColor
=
vec4
(
f
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
ArraySymbolIsConst
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
const
float
[
2
]
arr
=
float
[
2
]
(
0
.
0
1
.
0
)
;
\
n
"
"
const
float
f
=
arr
[
0
]
;
\
n
"
"
my_FragColor
=
vec4
(
f
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
BuiltInFunctionAppliedToArrayConstructorIsConst
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
const
float
f
=
sin
(
float
[
2
]
(
0
.
0
1
.
0
)
[
0
]
)
;
\
n
"
"
my_FragColor
=
vec4
(
f
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
BuiltInFunctionWithMultipleParametersAppliedToArrayConstructorIsConst
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
const
float
f
=
pow
(
1
.
0
float
[
2
]
(
0
.
0
1
.
0
)
[
0
]
)
;
\
n
"
"
my_FragColor
=
vec4
(
f
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
ConstructorWithMultipleParametersAppliedToArrayConstructorIsConst
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
const
vec2
f
=
vec2
(
1
.
0
float
[
2
]
(
0
.
0
1
.
0
)
[
0
]
)
;
\
n
"
"
my_FragColor
=
vec4
(
f
.
x
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
TernaryOperatorAppliedToArrayConstructorIsConst
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
const
float
f
=
true
?
float
[
2
]
(
0
.
0
1
.
0
)
[
0
]
:
1
.
0
;
\
n
"
"
my_FragColor
=
vec4
(
f
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
TernaryOperatorNonConstantOperand
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
uniform
float
u
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
const
float
f
=
true
?
1
.
0
:
u
;
\
n
"
"
gl_FragColor
=
vec4
(
f
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
SamplerInConstructorArguments
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
uniform
sampler2D
s
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
vec2
v
=
vec2
(
0
.
0
s
)
;
\
n
"
"
gl_FragColor
=
vec4
(
v
0
.
0
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
VoidInConstructorArguments
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
void
foo
(
)
{
}
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
vec2
v
=
vec2
(
0
.
0
foo
(
)
)
;
\
n
"
"
gl_FragColor
=
vec4
(
v
0
.
0
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
SingleStructArrayConstructor
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
uniform
float
u
;
\
n
"
"
struct
S
{
float
member
;
}
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
S
[
1
]
sarr
=
S
[
1
]
(
S
(
u
)
)
;
\
n
"
"
my_FragColor
=
vec4
(
sarr
[
0
]
.
member
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
EmptyArrayConstructor
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
uniform
float
u
;
\
n
"
"
const
float
[
]
f
=
f
[
]
(
)
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
my_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
DynamicallyIndexedFragmentOutput
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
"
"
precision
mediump
float
;
\
n
"
"
uniform
int
a
;
\
n
"
"
out
vec4
[
2
]
my_FragData
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
my_FragData
[
true
?
0
:
a
]
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
DynamicallyIndexedInterfaceBlock
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
"
"
precision
mediump
float
;
\
n
"
"
uniform
int
a
;
\
n
"
"
uniform
B
\
n
"
"
{
\
n
"
"
vec4
f
;
\
n
"
"
}
\
n
"
"
blocks
[
2
]
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
my_FragColor
=
blocks
[
true
?
0
:
a
]
.
f
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
StructConstructorWithStructDefinition
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
struct
s
{
float
f
;
}
(
0
.
0
)
;
\
n
"
"
gl_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedWebGL2ShaderTest
IndexFragDataWithNonConstant
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
for
(
int
i
=
0
;
i
<
2
;
+
+
i
)
{
\
n
"
"
gl_FragData
[
true
?
0
:
i
]
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
TextureOffsetNonConst
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
uniform
vec3
u_texCoord
;
\
n
"
"
uniform
mediump
sampler3D
u_sampler
;
\
n
"
"
uniform
int
x
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
my_FragColor
=
textureOffset
(
u_sampler
u_texCoord
ivec3
(
x
3
-
8
)
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
TextureProjOffsetNonConst
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
uniform
vec4
u_texCoord
;
\
n
"
"
uniform
mediump
sampler3D
u_sampler
;
\
n
"
"
uniform
int
x
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
my_FragColor
=
textureProjOffset
(
u_sampler
u_texCoord
ivec3
(
x
3
-
8
)
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
MalformedShaderTest
TextureLodOffsetOutOfRange
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
uniform
vec3
u_texCoord
;
\
n
"
"
uniform
mediump
sampler3D
u_sampler
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
my_FragColor
=
textureLodOffset
(
u_sampler
u_texCoord
0
.
0
ivec3
(
0
0
8
)
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
