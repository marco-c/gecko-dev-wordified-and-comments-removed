#
include
"
angle_gl
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
GLSLANG
/
ShaderLang
.
h
"
#
include
"
tests
/
test_utils
/
ShaderCompileTreeTest
.
h
"
using
namespace
sh
;
class
FragmentShaderValidationTest
:
public
ShaderCompileTreeTest
{
public
:
FragmentShaderValidationTest
(
)
{
}
protected
:
:
:
GLenum
getShaderType
(
)
const
override
{
return
GL_FRAGMENT_SHADER
;
}
ShShaderSpec
getShaderSpec
(
)
const
override
{
return
SH_GLES3_1_SPEC
;
}
}
;
class
VertexShaderValidationTest
:
public
ShaderCompileTreeTest
{
public
:
VertexShaderValidationTest
(
)
{
}
protected
:
:
:
GLenum
getShaderType
(
)
const
override
{
return
GL_VERTEX_SHADER
;
}
ShShaderSpec
getShaderSpec
(
)
const
override
{
return
SH_GLES3_1_SPEC
;
}
}
;
class
WebGL2FragmentShaderValidationTest
:
public
ShaderCompileTreeTest
{
public
:
WebGL2FragmentShaderValidationTest
(
)
{
}
protected
:
:
:
GLenum
getShaderType
(
)
const
override
{
return
GL_FRAGMENT_SHADER
;
}
ShShaderSpec
getShaderSpec
(
)
const
override
{
return
SH_WEBGL2_SPEC
;
}
}
;
class
WebGL1FragmentShaderValidationTest
:
public
ShaderCompileTreeTest
{
public
:
WebGL1FragmentShaderValidationTest
(
)
{
}
protected
:
:
:
GLenum
getShaderType
(
)
const
override
{
return
GL_FRAGMENT_SHADER
;
}
ShShaderSpec
getShaderSpec
(
)
const
override
{
return
SH_WEBGL_SPEC
;
}
}
;
class
ComputeShaderValidationTest
:
public
ShaderCompileTreeTest
{
public
:
ComputeShaderValidationTest
(
)
{
}
protected
:
:
:
GLenum
getShaderType
(
)
const
override
{
return
GL_COMPUTE_SHADER
;
}
ShShaderSpec
getShaderSpec
(
)
const
override
{
return
SH_GLES3_1_SPEC
;
}
}
;
class
ComputeShaderEnforcePackingValidationTest
:
public
ComputeShaderValidationTest
{
public
:
ComputeShaderEnforcePackingValidationTest
(
)
{
}
protected
:
void
initResources
(
ShBuiltInResources
*
resources
)
override
{
resources
-
>
MaxComputeUniformComponents
=
kMaxComputeUniformComponents
;
resources
-
>
MaxVertexUniformVectors
=
16
;
resources
-
>
MaxFragmentUniformVectors
=
16
;
}
void
SetUp
(
)
override
{
mExtraCompileOptions
|
=
(
SH_VARIABLES
|
SH_ENFORCE_PACKING_RESTRICTIONS
)
;
ShaderCompileTreeTest
:
:
SetUp
(
)
;
}
static
constexpr
GLint
kMaxComputeUniformComponents
=
128
;
}
;
class
GeometryShaderValidationTest
:
public
ShaderCompileTreeTest
{
public
:
GeometryShaderValidationTest
(
)
{
}
protected
:
void
initResources
(
ShBuiltInResources
*
resources
)
override
{
resources
-
>
OES_geometry_shader
=
1
;
}
:
:
GLenum
getShaderType
(
)
const
override
{
return
GL_GEOMETRY_SHADER_OES
;
}
ShShaderSpec
getShaderSpec
(
)
const
override
{
return
SH_GLES3_1_SPEC
;
}
}
;
class
FragmentShaderOESGeometryShaderValidationTest
:
public
FragmentShaderValidationTest
{
public
:
FragmentShaderOESGeometryShaderValidationTest
(
)
{
}
protected
:
void
initResources
(
ShBuiltInResources
*
resources
)
override
{
resources
-
>
OES_geometry_shader
=
1
;
}
}
;
TEST_F
(
FragmentShaderValidationTest
FunctionParameterMismatch
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
float
fun
(
float
a
)
{
\
n
"
"
return
a
*
2
.
0
;
\
n
"
"
}
\
n
"
"
void
main
(
)
{
\
n
"
"
float
ff
=
fun
(
)
;
\
n
"
"
gl_FragColor
=
vec4
(
ff
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
RedeclaringFunctionAsVariable
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
float
fun
(
float
a
)
{
\
n
"
"
return
a
*
2
.
0
;
\
n
"
"
}
\
n
"
"
float
fun
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
RedeclaringFunctionAsStruct
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
float
fun
(
float
a
)
{
\
n
"
"
return
a
*
2
.
0
;
\
n
"
"
}
\
n
"
"
struct
fun
{
float
a
;
}
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
RedeclaringFunctionWithDifferentQualifiers
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
float
fun
(
out
float
a
)
;
\
n
"
"
float
fun
(
float
a
)
{
\
n
"
"
return
a
*
2
.
0
;
\
n
"
"
}
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
CompareStructsContainingArrays
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
struct
s
{
float
a
[
3
]
;
}
;
\
n
"
"
void
main
(
)
{
\
n
"
"
s
a
;
\
n
"
"
s
b
;
\
n
"
"
bool
c
=
(
a
=
=
b
)
;
\
n
"
"
gl_FragColor
=
vec4
(
c
?
1
.
0
:
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
AssignStructsContainingArrays
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
struct
s
{
float
a
[
3
]
;
}
;
\
n
"
"
void
main
(
)
{
\
n
"
"
s
a
;
\
n
"
"
s
b
;
\
n
"
"
b
.
a
[
0
]
=
0
.
0
;
\
n
"
"
a
=
b
;
\
n
"
"
gl_FragColor
=
vec4
(
a
.
a
[
0
]
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
CompareStructsContainingSamplers
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
struct
s
{
sampler2D
foo
;
}
;
\
n
"
"
uniform
s
a
;
\
n
"
"
uniform
s
b
;
\
n
"
"
void
main
(
)
{
\
n
"
"
bool
c
=
(
a
=
=
b
)
;
\
n
"
"
gl_FragColor
=
vec4
(
c
?
1
.
0
:
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
AssignStructsContainingSamplers
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
struct
s
{
sampler2D
foo
;
}
;
\
n
"
"
uniform
s
a
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
s
b
;
\
n
"
"
b
=
a
;
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ArrayWithNoSizeInInitializerList
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
{
\
n
"
"
float
a
[
2
]
b
[
]
;
\
n
"
"
gl_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ConstVarNotInitialized
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
float
a
;
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ConstStructNotInitialized
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
struct
S
{
\
n
"
"
float
a
[
3
]
;
\
n
"
"
}
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
S
b
;
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ConstArrayNotInitialized
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
float
a
[
3
]
;
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
BlockLayoutQualifierOnRegularUniform
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
packed
)
uniform
mat2
x
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
BlockLayoutQualifierOnUniformWithEmptyDecl
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
packed
)
uniform
mat2
x
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ArraysOfArrays1
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
float
[
5
]
a
[
3
]
;
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ArraysOfArrays2
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
float
[
2
]
a
b
[
3
]
;
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ArraysOfArraysInStruct
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
struct
S
{
\
n
"
"
float
[
2
]
foo
[
3
]
;
\
n
"
"
}
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
TooHighDimensionalityOfImplicitlySizedArrayOfArraysConstructorArguments
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
float
[
]
[
]
a
=
float
[
]
[
]
(
float
[
1
]
[
1
]
(
float
[
1
]
(
1
.
0
)
)
float
[
1
]
[
1
]
(
float
[
1
]
(
2
.
0
)
)
)
;
\
n
"
"
my_FragColor
=
vec4
(
a
[
0
]
[
0
]
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
TooLowDimensionalityOfImplicitlySizedArrayOfArraysConstructorArguments
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
float
[
]
[
]
[
]
a
=
float
[
]
[
]
[
]
(
float
[
2
]
(
1
.
0
2
.
0
)
float
[
2
]
(
3
.
0
4
.
0
)
)
;
\
n
"
"
my_FragColor
=
vec4
(
a
[
0
]
[
0
]
[
0
]
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
UninitializedImplicitArraySize
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
float
[
]
a
;
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
TernaryOperatorNotConstantExpression
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
uniform
bool
u
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
bool
a
=
true
?
true
:
u
;
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
TernaryOperatorOnArrays
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
float
[
1
]
a
=
float
[
1
]
(
0
.
0
)
;
\
n
"
"
float
[
1
]
b
=
float
[
1
]
(
1
.
0
)
;
\
n
"
"
float
[
1
]
c
=
true
?
a
:
b
;
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
TernaryOperatorOnStructs
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
struct
S
{
float
foo
;
}
;
\
n
"
"
void
main
(
)
{
\
n
"
"
S
a
=
S
(
0
.
0
)
;
\
n
"
"
S
b
=
S
(
1
.
0
)
;
\
n
"
"
S
c
=
true
?
a
:
b
;
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
AssignArrayLengthToUnsigned
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
int
[
1
]
arr
;
\
n
"
"
uint
l
=
arr
.
length
(
)
;
\
n
"
"
my_FragColor
=
vec4
(
float
(
l
)
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
AssignVaryingToGlobal
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
varying
float
a
;
\
n
"
"
float
b
=
a
*
2
.
0
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
vec4
(
b
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
AssignUniformToGlobalESSL3
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
float
a
;
\
n
"
"
float
b
=
a
*
2
.
0
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
b
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
AssignUniformToGlobalESSL1
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
uniform
float
a
;
\
n
"
"
float
b
=
a
*
2
.
0
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
vec4
(
b
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
if
(
!
hasWarning
(
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
without
warnings
expecting
warning
:
\
n
"
<
<
mInfoLog
;
}
}
else
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
with
warning
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
AssignFunctionCallToGlobal
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
float
foo
(
)
{
return
1
.
0
;
}
\
n
"
"
float
b
=
foo
(
)
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
vec4
(
b
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
AssignAssignmentToGlobal
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
float
c
=
1
.
0
;
\
n
"
"
float
b
=
(
c
=
0
.
0
)
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
vec4
(
b
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
AssignIncrementToGlobal
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
float
c
=
1
.
0
;
\
n
"
"
float
b
=
(
c
+
+
)
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
vec4
(
b
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
AssignTexture2DToGlobal
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
uniform
mediump
sampler2D
s
;
\
n
"
"
float
b
=
texture2D
(
s
vec2
(
0
.
5
0
.
5
)
)
.
x
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
vec4
(
b
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
AssignNonConstGlobalToGlobal
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
float
a
=
1
.
0
;
\
n
"
"
float
b
=
a
*
2
.
0
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
b
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
AssignConstGlobalToGlobal
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
const
float
a
=
1
.
0
;
\
n
"
"
float
b
=
a
*
2
.
0
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
b
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
WriteBothFragDataAndFragColor
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
void
foo
(
)
{
\
n
"
"
gl_FragData
[
0
]
.
a
+
+
;
\
n
"
"
}
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
.
x
+
=
0
.
0
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
VersionOnSecondLine
)
{
const
std
:
:
string
&
shaderString
=
"
\
n
"
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
LayoutQualifierInCondition
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
vec4
u
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
int
i
=
0
;
\
n
"
"
for
(
int
j
=
0
;
layout
(
location
=
0
)
bool
b
=
false
;
+
+
j
)
{
\
n
"
"
+
+
i
;
\
n
"
"
}
\
n
"
"
my_FragColor
=
u
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
LayoutQualifierInFunctionReturnType
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
vec4
u
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
layout
(
location
=
0
)
vec4
foo
(
)
{
\
n
"
"
return
u
;
\
n
"
"
}
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
foo
(
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
TwoOutputsNoLayoutQualifiers
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
vec4
u
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
out
vec4
my_SecondaryFragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
my_SecondaryFragColor
=
vec4
(
0
.
5
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
TwoOutputsFirstLayoutQualifier
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
vec4
u
;
\
n
"
"
layout
(
location
=
0
)
out
vec4
my_FragColor
;
\
n
"
"
out
vec4
my_SecondaryFragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
my_SecondaryFragColor
=
vec4
(
0
.
5
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
TwoOutputsSecondLayoutQualifier
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
vec4
u
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
layout
(
location
=
0
)
out
vec4
my_SecondaryFragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
1
.
0
)
;
\
n
"
"
my_SecondaryFragColor
=
vec4
(
0
.
5
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
UniformArray
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
vec4
[
2
]
u
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
u
[
0
]
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
FragmentInputArrayOfStructs
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
struct
S
{
\
n
"
"
vec4
foo
;
\
n
"
"
}
;
\
n
"
"
in
S
i
[
2
]
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
i
[
0
]
.
foo
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
VertexShaderValidationTest
VertexShaderInputArray
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
in
vec4
i
[
2
]
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_Position
=
i
[
0
]
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
VertexShaderValidationTest
VertexShaderInputArrayType
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
in
vec4
[
2
]
i
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_Position
=
i
[
0
]
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
FragmentShaderInputStructWithBool
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
struct
S
{
\
n
"
"
bool
foo
;
\
n
"
"
}
;
\
n
"
"
in
S
s
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
FragmentShaderInputStructWithInt
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
struct
S
{
\
n
"
"
int
foo
;
\
n
"
"
}
;
\
n
"
"
in
S
s
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ShaderSelectingFieldOfVectorIndexedFromArray
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
uniform
int
i
;
\
n
"
"
void
main
(
)
{
\
n
"
"
float
f
=
vec2
[
1
]
(
vec2
(
0
.
0
0
.
1
)
)
[
i
]
.
x
;
\
n
"
"
my_FragColor
=
vec4
(
f
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ArrayValueFromFunctionParameterAsParameter
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
uniform
float
u
;
\
n
"
"
float
foo
(
float
f
)
{
\
n
"
"
return
f
*
2
.
0
;
\
n
"
"
}
\
n
"
"
float
bar
(
float
[
2
]
f
)
{
\
n
"
"
return
foo
(
f
[
0
]
)
;
\
n
"
"
}
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
float
arr
[
2
]
;
\
n
"
"
arr
[
0
]
=
u
;
\
n
"
"
gl_FragColor
=
vec4
(
bar
(
arr
)
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
OutOfRangeIntegerLiteral
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
highp
int
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
my_FragColor
=
vec4
(
0x100000000
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
FieldSelectionFromVectorArrayConstructorIsConst
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
const
float
f
=
vec2
[
1
]
(
vec2
(
0
.
0
1
.
0
)
)
[
0
]
.
x
;
\
n
"
"
my_FragColor
=
vec4
(
f
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
FieldSelectionFromStructArrayConstructorIsConst
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
struct
S
{
float
member
;
}
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
const
float
f
=
S
[
1
]
(
S
(
0
.
0
)
)
[
0
]
.
member
;
\
n
"
"
my_FragColor
=
vec4
(
f
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ArraySymbolIsConst
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
const
float
[
2
]
arr
=
float
[
2
]
(
0
.
0
1
.
0
)
;
\
n
"
"
const
float
f
=
arr
[
0
]
;
\
n
"
"
my_FragColor
=
vec4
(
f
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
BuiltInFunctionAppliedToArrayConstructorIsConst
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
const
float
f
=
sin
(
float
[
2
]
(
0
.
0
1
.
0
)
[
0
]
)
;
\
n
"
"
my_FragColor
=
vec4
(
f
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
BuiltInFunctionWithMultipleParametersAppliedToArrayConstructorIsConst
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
const
float
f
=
pow
(
1
.
0
float
[
2
]
(
0
.
0
1
.
0
)
[
0
]
)
;
\
n
"
"
my_FragColor
=
vec4
(
f
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ConstructorWithMultipleParametersAppliedToArrayConstructorIsConst
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
const
vec2
f
=
vec2
(
1
.
0
float
[
2
]
(
0
.
0
1
.
0
)
[
0
]
)
;
\
n
"
"
my_FragColor
=
vec4
(
f
.
x
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
TernaryOperatorAppliedToArrayConstructorIsConst
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
const
float
f
=
true
?
float
[
2
]
(
0
.
0
1
.
0
)
[
0
]
:
1
.
0
;
\
n
"
"
my_FragColor
=
vec4
(
f
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
TernaryOperatorNonConstantOperand
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
uniform
float
u
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
const
float
f
=
true
?
1
.
0
:
u
;
\
n
"
"
gl_FragColor
=
vec4
(
f
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
SamplerInConstructorArguments
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
uniform
sampler2D
s
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
vec2
v
=
vec2
(
0
.
0
s
)
;
\
n
"
"
gl_FragColor
=
vec4
(
v
0
.
0
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
VoidInConstructorArguments
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
void
foo
(
)
{
}
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
vec2
v
=
vec2
(
0
.
0
foo
(
)
)
;
\
n
"
"
gl_FragColor
=
vec4
(
v
0
.
0
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
SingleStructArrayConstructor
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
uniform
float
u
;
\
n
"
"
struct
S
{
float
member
;
}
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
S
[
1
]
sarr
=
S
[
1
]
(
S
(
u
)
)
;
\
n
"
"
my_FragColor
=
vec4
(
sarr
[
0
]
.
member
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
EmptyArrayConstructor
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
uniform
float
u
;
\
n
"
"
const
float
[
]
f
=
f
[
]
(
)
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
my_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
DynamicallyIndexedFragmentOutput
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
int
a
;
\
n
"
"
out
vec4
[
2
]
my_FragData
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
my_FragData
[
true
?
0
:
a
]
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
DynamicallyIndexedInterfaceBlock
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
int
a
;
\
n
"
"
uniform
B
\
n
"
"
{
\
n
"
"
vec4
f
;
\
n
"
"
}
\
n
"
"
blocks
[
2
]
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
my_FragColor
=
blocks
[
true
?
0
:
a
]
.
f
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
StructConstructorWithStructDefinition
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
struct
s
{
float
f
;
}
(
0
.
0
)
;
\
n
"
"
gl_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
WebGL2FragmentShaderValidationTest
IndexFragDataWithNonConstant
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
for
(
int
i
=
0
;
i
<
2
;
+
+
i
)
{
\
n
"
"
gl_FragData
[
true
?
0
:
i
]
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
TextureOffsetNonConst
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
uniform
vec3
u_texCoord
;
\
n
"
"
uniform
mediump
sampler3D
u_sampler
;
\
n
"
"
uniform
int
x
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
my_FragColor
=
textureOffset
(
u_sampler
u_texCoord
ivec3
(
x
3
-
8
)
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
TextureProjOffsetNonConst
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
uniform
vec4
u_texCoord
;
\
n
"
"
uniform
mediump
sampler3D
u_sampler
;
\
n
"
"
uniform
int
x
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
my_FragColor
=
textureProjOffset
(
u_sampler
u_texCoord
ivec3
(
x
3
-
8
)
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
TextureLodOffsetOutOfRange
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
uniform
vec3
u_texCoord
;
\
n
"
"
uniform
mediump
sampler3D
u_sampler
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
my_FragColor
=
textureLodOffset
(
u_sampler
u_texCoord
0
.
0
ivec3
(
0
0
8
)
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
DefaultPrecisionUint
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
uint
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
my_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
NoPrecisionSampler3D
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
sampler3D
s
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
my_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
WebGL1FragmentShaderValidationTest
NonConstantLoopIndex
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
uniform
int
u
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
for
(
int
i
=
(
true
?
1
:
u
)
;
i
<
5
;
+
+
i
)
{
\
n
"
"
gl_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
NonIntegerIndex
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
float
f
[
3
]
;
\
n
"
"
const
float
i
=
2
.
0
;
\
n
"
"
gl_FragColor
=
vec4
(
f
[
i
]
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
DuplicatePrototypeESSL1
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
void
foo
(
)
;
\
n
"
"
void
foo
(
)
;
\
n
"
"
void
foo
(
)
{
}
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
gl_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
DuplicatePrototypeESSL3
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
foo
(
)
;
\
n
"
"
void
foo
(
)
;
\
n
"
"
void
foo
(
)
{
}
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
my_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
LocalFunctionPrototype
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
void
foo
(
)
;
\
n
"
"
my_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ESSL300FragmentInvariantAll
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
#
pragma
STDGL
invariant
(
all
)
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
my_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ESSL100BuiltInFunctionOverload
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
int
sin
(
int
x
)
\
n
"
"
{
\
n
"
"
return
int
(
sin
(
float
(
x
)
)
)
;
\
n
"
"
}
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
gl_FragColor
=
vec4
(
sin
(
1
)
)
;
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ESSL300BuiltInFunctionOverload
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
int
sin
(
int
x
)
\
n
"
"
{
\
n
"
"
return
int
(
sin
(
float
(
x
)
)
)
;
\
n
"
"
}
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
my_FragColor
=
vec4
(
sin
(
1
)
)
;
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
CompoundMultiplyMatrixIdenticalNonSquareDimensions
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
mat4x2
foo
;
\
n
"
"
foo
*
=
mat4x2
(
4
.
0
)
;
\
n
"
"
my_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
CompoundMultiplyMatrixValidNonSquareDimensions
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
mat2x4
foo
;
\
n
"
"
foo
*
=
mat2x2
(
4
.
0
)
;
\
n
"
"
my_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
OutOfBoundsVectorSwizzle
)
{
const
std
:
:
string
&
shaderString
=
"
void
main
(
)
{
\
n
"
"
vec2
(
0
)
.
qq
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
DefineWithSemicolon
)
{
const
std
:
:
string
&
shaderString
=
"
#
define
Def
;
highp
\
n
"
"
uniform
Def
vec2
a
;
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
LineDirectiveUndefinedShift
)
{
const
std
:
:
string
&
shaderString
=
"
#
line
x
<
<
y
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
LineDirectiveNegativeShift
)
{
const
std
:
:
string
&
shaderString
=
"
#
line
x
<
<
-
1
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
MaxImageUnitsInES3Shader
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
myOutput
;
"
"
void
main
(
)
{
\
n
"
"
float
ff
=
float
(
gl_MaxImageUnits
)
;
\
n
"
"
myOutput
=
vec4
(
ff
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
StructCompoundAssignStruct
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
myOutput
;
\
n
"
"
struct
S
{
float
foo
;
}
;
\
n
"
"
void
main
(
)
{
\
n
"
"
S
a
b
;
\
n
"
"
a
+
=
b
;
\
n
"
"
myOutput
=
vec4
(
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
StructEqDifferentStruct
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
myOutput
;
\
n
"
"
struct
S
{
float
foo
;
}
;
\
n
"
"
struct
S2
{
float
foobar
;
}
;
\
n
"
"
void
main
(
)
{
\
n
"
"
S
a
;
\
n
"
"
S2
b
;
\
n
"
"
a
=
=
b
;
\
n
"
"
myOutput
=
vec4
(
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
Version100
)
{
const
std
:
:
string
&
shaderString
=
"
void
main
(
)
\
n
"
"
layout
(
local_size_x
=
1
)
in
;
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
Version300
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
void
main
(
)
\
n
"
"
layout
(
local_size_x
=
1
)
in
;
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
NoWorkGroupSizeSpecified
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
WorkGroupSizeTooSmallXdimension
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
0
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
WorkGroupSizeTooSmallZDimension
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
4
local_size_y
=
6
local_size_z
=
0
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
WorkGroupSizeTooBigXDimension
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
9989899
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
WorkGroupSizeTooBigYDimension
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
5
local_size_y
=
9989899
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
WorkGroupSizeTooBigZDimension
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
5
local_size_y
=
5
local_size_z
=
9989899
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
WorkGroupSizeMacro
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
#
define
MYDEF
(
x
)
x
"
"
layout
(
local_size_x
=
MYDEF
(
127
)
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
WorkGroupSizeUnsignedInteger
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
123u
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
WorkGroupSizeHexadecimal
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
0x3A
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
WorkGroupSizeMinusOneHexadecimal
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
0xFFFFFFFF
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
WorkGroupSizeOctal
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
013
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
WorkGroupSizeNegativeHexadecimal
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
0xFFFFFFEC
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
DifferingLayoutQualifiers
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
5
local_size_x
=
6
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
MultipleInputVariablesDifferingLocalSize
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
5
local_size_y
=
6
)
in
;
\
n
"
"
layout
(
local_size_x
=
5
local_size_y
=
7
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
MultipleInputVariablesDifferingLocalSize2
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
5
)
in
;
\
n
"
"
layout
(
local_size_x
=
5
local_size_y
=
7
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
MultipleInputVariablesSameLocalSize
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
5
local_size_y
=
6
)
in
;
\
n
"
"
layout
(
local_size_x
=
5
local_size_y
=
6
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
MultipleInputVariablesSameLocalSize2
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
5
)
in
;
\
n
"
"
layout
(
local_size_x
=
5
local_size_y
=
1
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
MultipleInputVariablesSameLocalSize3
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
5
local_size_y
=
1
)
in
;
\
n
"
"
layout
(
local_size_x
=
5
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
RowMajorInComputeInputLayout
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
5
row_major
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
UniformComputeInputLayout
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
5
)
uniform
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
UniformBufferComputeInputLayout
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
5
)
uniform
SomeBuffer
{
vec4
something
;
}
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
StructComputeInputLayout
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
5
)
struct
SomeBuffer
{
vec4
something
;
}
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
StructBodyComputeInputLayout
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
struct
S
{
\
n
"
"
layout
(
local_size_x
=
12
)
vec4
foo
;
\
n
"
"
}
;
\
n
"
"
void
main
(
)
"
"
{
"
"
}
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
TypeComputeInputLayout
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
5
)
vec4
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
InvalidOutStorageQualifier
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
15
)
in
;
\
n
"
"
out
vec4
myOutput
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
InvalidOutStorageQualifier2
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
15
)
in
;
\
n
"
"
out
myOutput
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
InvalidInStorageQualifier
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
15
)
in
;
\
n
"
"
in
vec4
myInput
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
InvalidInStorageQualifier2
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
15
)
in
;
\
n
"
"
in
myInput
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
VertexShaderValidationTest
InvalidUseOfLocalSizeX
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
local_size_x
=
15
)
in
vec4
myInput
;
\
n
"
"
out
vec4
myOutput
;
\
n
"
"
void
main
(
)
{
\
n
"
"
myOutput
=
myInput
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
InvalidUseOfLocalSizeX
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
local_size_x
=
15
)
in
vec4
myInput
;
\
n
"
"
out
vec4
myOutput
;
\
n
"
"
void
main
(
)
{
\
n
"
"
myOutput
=
myInput
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
GeometryShaderValidationTest
InvalidUseOfLocalSizeX
)
{
const
std
:
:
string
&
shaderString1
=
"
#
version
310
es
\
n
"
"
#
extension
GL_OES_geometry_shader
:
require
\
n
"
"
layout
(
points
local_size_x
=
15
)
in
;
\
n
"
"
layout
(
points
max_vertices
=
2
)
out
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
const
std
:
:
string
&
shaderString2
=
"
#
version
310
es
\
n
"
"
#
extension
GL_OES_geometry_shader
:
require
\
n
"
"
layout
(
points
)
in
;
\
n
"
"
layout
(
invocations
=
2
local_size_x
=
15
)
in
;
\
n
"
"
layout
(
points
max_vertices
=
2
)
out
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
const
std
:
:
string
&
shaderString3
=
"
#
version
310
es
\
n
"
"
#
extension
GL_OES_geometry_shader
:
require
\
n
"
"
layout
(
points
)
in
;
\
n
"
"
layout
(
points
local_size_x
=
15
max_vertices
=
2
)
out
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
const
std
:
:
string
&
shaderString4
=
"
#
version
310
es
\
n
"
"
#
extension
GL_OES_geometry_shader
:
require
\
n
"
"
layout
(
points
)
in
;
\
n
"
"
layout
(
points
)
out
;
\
n
"
"
layout
(
max_vertices
=
2
local_size_x
=
15
)
out
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString1
)
|
|
compile
(
shaderString2
)
|
|
compile
(
shaderString3
)
|
|
compile
(
shaderString4
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
InvalidUsageOfWorkGroupSize
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
uvec3
WorkGroupSize
=
gl_WorkGroupSize
;
\
n
"
"
}
\
n
"
"
layout
(
local_size_x
=
12
)
in
;
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
CorrectUsageOfComputeBuiltins
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
12
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
uvec3
NumWorkGroups
=
gl_NumWorkGroups
;
\
n
"
"
uvec3
WorkGroupSize
=
gl_WorkGroupSize
;
\
n
"
"
uvec3
WorkGroupID
=
gl_WorkGroupID
;
\
n
"
"
uvec3
GlobalInvocationID
=
gl_GlobalInvocationID
;
\
n
"
"
uvec3
LocalInvocationID
=
gl_LocalInvocationID
;
\
n
"
"
uint
LocalInvocationIndex
=
gl_LocalInvocationIndex
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
SpecialVariableNumWorkGroups
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
12
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
gl_NumWorkGroups
=
uvec3
(
1
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
SpecialVariableWorkGroupID
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
12
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
gl_WorkGroupID
=
uvec3
(
1
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
SpecialVariableLocalInvocationID
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
12
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
gl_LocalInvocationID
=
uvec3
(
1
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
SpecialVariableGlobalInvocationID
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
12
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
gl_GlobalInvocationID
=
uvec3
(
1
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
SpecialVariableLocalInvocationIndex
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
12
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
gl_LocalInvocationIndex
=
1
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
SpecialVariableWorkGroupSize
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
12
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
gl_WorkGroupSize
=
uvec3
(
1
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
SamplerUnaryOperator
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
uniform
sampler2D
s
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
-
s
;
\
n
"
"
gl_FragColor
=
vec4
(
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
InvariantBlockSize
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
invariant
layout
(
local_size_x
=
15
)
in
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
InvariantNonOuput
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
invariant
int
value
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
InvariantNonOuputEmptyDeclaration
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
invariant
in
float
;
\
n
"
"
void
main
(
)
{
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
InvariantDeclarationWithStorageQualifier
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
foo
;
\
n
"
"
invariant
centroid
foo
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
InvariantDeclarationWithPrecisionQualifier
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
foo
;
\
n
"
"
invariant
highp
foo
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
InvariantDeclarationWithLayoutQualifier
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
foo
;
\
n
"
"
invariant
layout
(
location
=
0
)
foo
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
VariableDeclarationWithInvariantAndLayoutQualifierESSL300
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
invariant
layout
(
location
=
0
)
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ShiftBy32
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
{
\
n
"
"
uint
u
=
1u
<
<
32u
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
if
(
!
hasWarning
(
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
without
warnings
expecting
warning
:
\
n
"
<
<
mInfoLog
;
}
}
else
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
with
warning
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ShiftByNegative
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
{
\
n
"
"
uint
u
=
1u
<
<
(
-
1
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
if
(
!
hasWarning
(
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
without
warnings
expecting
warning
:
\
n
"
<
<
mInfoLog
;
}
}
else
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
with
warning
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
DeferGlobalVariableInitWithEmptyMain
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
uniform
float
u
;
\
n
"
"
float
foo
=
u
;
\
n
"
"
void
main
(
)
{
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
EmptyDeclarationAsLoopInit
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
int
i
=
0
;
\
n
"
"
for
(
int
;
i
<
3
;
i
+
+
)
\
n
"
"
{
\
n
"
"
my_FragColor
=
vec4
(
i
)
;
\
n
"
"
}
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ImageR32FNoMemoryQualifier
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2D
;
\
n
"
"
in
vec4
myInput
;
\
n
"
"
layout
(
r32f
)
uniform
image2D
myImage
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ImageRGBA32FWithIncorrectMemoryQualifier
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2D
;
\
n
"
"
in
vec4
myInput
;
\
n
"
"
layout
(
rgba32f
)
uniform
image2D
myImage
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
StoreInReadOnlyImage
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2D
;
\
n
"
"
in
vec4
myInput
;
\
n
"
"
layout
(
r32f
)
uniform
readonly
image2D
myImage
;
\
n
"
"
void
main
(
)
{
\
n
"
"
imageStore
(
myImage
ivec2
(
0
)
vec4
(
1
.
0
)
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
LoadFromWriteOnlyImage
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2D
;
\
n
"
"
in
vec4
myInput
;
\
n
"
"
layout
(
r32f
)
uniform
writeonly
image2D
myImage
;
\
n
"
"
void
main
(
)
{
\
n
"
"
imageLoad
(
myImage
ivec2
(
0
)
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
StoreInReadOnlyImageArray
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2D
;
\
n
"
"
in
vec4
myInput
;
\
n
"
"
layout
(
r32f
)
uniform
readonly
image2D
myImage
[
2
]
;
\
n
"
"
void
main
(
)
{
\
n
"
"
imageStore
(
myImage
[
0
]
ivec2
(
0
)
vec4
(
1
.
0
)
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
StoreInReadOnlyImageInStruct
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2D
;
\
n
"
"
in
vec4
myInput
;
\
n
"
"
uniform
struct
S
{
\
n
"
"
layout
(
r32f
)
readonly
image2D
myImage
;
\
n
"
"
}
s
;
\
n
"
"
void
main
(
)
{
\
n
"
"
imageStore
(
s
.
myImage
ivec2
(
0
)
vec4
(
1
.
0
)
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ValidImage3D
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image3D
;
\
n
"
"
in
vec4
myInput
;
\
n
"
"
layout
(
rgba32f
)
uniform
readonly
image3D
myImage
;
\
n
"
"
void
main
(
)
{
\
n
"
"
imageLoad
(
myImage
ivec3
(
0
)
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ValidImageCube
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
imageCube
;
\
n
"
"
in
vec4
myInput
;
\
n
"
"
layout
(
rgba32f
)
uniform
readonly
imageCube
myImage
;
\
n
"
"
void
main
(
)
{
\
n
"
"
imageLoad
(
myImage
ivec3
(
0
)
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ValidImage2DArray
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2DArray
;
\
n
"
"
in
vec4
myInput
;
\
n
"
"
layout
(
rgba32f
)
uniform
readonly
image2DArray
myImage
;
\
n
"
"
void
main
(
)
{
\
n
"
"
imageLoad
(
myImage
ivec3
(
0
)
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ImageLValueFunctionDefinitionInOut
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2D
;
\
n
"
"
void
myFunc
(
inout
image2D
someImage
)
{
}
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ImageAssignment
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2D
;
\
n
"
"
layout
(
rgba32f
)
uniform
readonly
image2D
myImage
;
\
n
"
"
layout
(
rgba32f
)
uniform
readonly
image2D
myImage2
;
\
n
"
"
void
main
(
)
{
\
n
"
"
myImage
=
myImage2
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ReadOnlyQualifierMissingInFunctionArgument
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2D
;
\
n
"
"
layout
(
rgba32f
)
uniform
readonly
image2D
myImage
;
\
n
"
"
void
myFunc
(
in
image2D
someImage
)
{
}
\
n
"
"
void
main
(
)
{
\
n
"
"
myFunc
(
myImage
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ReadOnlyQualifierMissingInFunctionArgumentArray
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2D
;
\
n
"
"
layout
(
rgba32f
)
uniform
readonly
image2D
myImage
[
2
]
;
\
n
"
"
void
myFunc
(
in
image2D
someImage
)
{
}
\
n
"
"
void
main
(
)
{
\
n
"
"
myFunc
(
myImage
[
0
]
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ReadOnlyQualifierMissingInFunctionArgumentStruct
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2D
;
\
n
"
"
uniform
struct
S
{
\
n
"
"
layout
(
r32f
)
readonly
image2D
myImage
;
\
n
"
"
}
s
;
\
n
"
"
void
myFunc
(
in
image2D
someImage
)
{
}
\
n
"
"
void
main
(
)
{
\
n
"
"
myFunc
(
s
.
myImage
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
WriteOnlyQualifierMissingInFunctionArgument
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2D
;
\
n
"
"
layout
(
rgba32f
)
uniform
writeonly
image2D
myImage
;
\
n
"
"
void
myFunc
(
in
image2D
someImage
)
{
}
\
n
"
"
void
main
(
)
{
\
n
"
"
myFunc
(
myImage
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
DiscardWriteonlyInFunctionBody
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2D
;
\
n
"
"
layout
(
rgba32f
)
uniform
writeonly
image2D
myImage
;
\
n
"
"
void
myFunc1
(
in
image2D
someImage
)
{
}
\
n
"
"
void
myFunc2
(
in
writeonly
image2D
someImage
)
{
myFunc1
(
someImage
)
;
}
\
n
"
"
void
main
(
)
{
\
n
"
"
myFunc2
(
myImage
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
CorrectImageMemoryQualifierSpecified
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2D
;
\
n
"
"
layout
(
r32f
)
uniform
image2D
myImage
;
\
n
"
"
void
myFunc
(
in
image2D
someImage
)
{
}
\
n
"
"
void
main
(
)
{
\
n
"
"
myFunc
(
myImage
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
CorrectImageMemoryQualifierSpecified2
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2D
;
\
n
"
"
layout
(
r32f
)
uniform
image2D
myImage
;
\
n
"
"
void
myFunc
(
in
readonly
writeonly
image2D
someImage
)
{
}
\
n
"
"
void
main
(
)
{
\
n
"
"
myFunc
(
myImage
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ImageInStruct
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2D
;
\
n
"
"
struct
myStruct
{
layout
(
r32f
)
image2D
myImage
;
}
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ImageInInterfaceBlock
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2D
;
\
n
"
"
uniform
myBlock
{
layout
(
r32f
)
image2D
myImage
;
}
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ReadonlyWithInterfaceBlock
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
readonly
myBlock
{
float
something
;
}
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ReadonlyWithInvariant
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
something
;
\
n
"
"
invariant
readonly
something
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ReadonlyWithStructMember
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
something
;
\
n
"
"
struct
MyStruct
{
readonly
float
myMember
;
}
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ImageInternalFormatWithInterfaceBlock
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
something
;
\
n
"
"
layout
(
rgba32f
)
uniform
MyStruct
{
float
myMember
;
}
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ImageInternalFormatInGlobalLayoutQualifier
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
something
;
\
n
"
"
layout
(
rgba32f
)
uniform
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
SamplerAsTernaryOperand
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
uniform
bool
u
;
\
n
"
"
uniform
sampler2D
s1
;
\
n
"
"
uniform
sampler2D
s2
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
texture2D
(
u
?
s1
:
s2
vec2
(
0
0
)
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
FloatDeclarationNoQualifiersNoPrecision
)
{
const
std
:
:
string
&
shaderString
=
"
vec4
foo
=
vec4
(
0
.
0
)
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
gl_FragColor
=
foo
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
IncorrectUnsizedArray
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
float
foo
[
]
=
0
.
0
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
foo
[
0
]
=
1
.
0
;
\
n
"
"
my_FragColor
=
vec4
(
foo
[
0
]
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
LogicalOpRHSIsBVec
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
bool
b
;
\
n
"
"
bvec3
b3
;
\
n
"
"
b
&
&
b3
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
UnsizedArrayConstructorNoParameters
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
int
[
]
(
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
CoherentQualifierMissingInFunctionArgument
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2D
;
\
n
"
"
layout
(
r32f
)
uniform
coherent
image2D
myImage
;
\
n
"
"
void
myFunc
(
in
image2D
someImage
)
{
}
\
n
"
"
void
main
(
)
{
\
n
"
"
myFunc
(
myImage
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
VolatileQualifierMissingInFunctionArgument
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2D
;
\
n
"
"
layout
(
r32f
)
uniform
volatile
image2D
myImage
;
\
n
"
"
void
myFunc
(
in
image2D
someImage
)
{
}
\
n
"
"
void
main
(
)
{
\
n
"
"
myFunc
(
myImage
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
RestrictQualifierDiscardedInFunctionArgument
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2D
;
\
n
"
"
layout
(
r32f
)
uniform
restrict
image2D
myImage
;
\
n
"
"
void
myFunc
(
in
image2D
someImage
)
{
}
\
n
"
"
void
main
(
)
{
\
n
"
"
myFunc
(
myImage
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
OverqualifyingImageParameter
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2D
;
\
n
"
"
layout
(
r32f
)
uniform
image2D
myImage
;
\
n
"
"
void
myFunc
(
in
coherent
volatile
image2D
someImage
)
{
}
\
n
"
"
void
main
(
)
{
\
n
"
"
myFunc
(
myImage
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
WorkGroupSizeAsArraySize
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
5
local_size_y
=
3
local_size_z
=
1
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
int
[
gl_WorkGroupSize
.
x
]
a
=
int
[
5
]
(
0
0
0
0
0
)
;
\
n
"
"
int
[
gl_WorkGroupSize
.
y
]
b
=
int
[
3
]
(
0
0
0
)
;
\
n
"
"
int
[
gl_WorkGroupSize
.
z
]
c
=
int
[
1
]
(
0
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
VertexShaderValidationTest
VertexShaderSharedMemory
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
in
vec4
i
;
\
n
"
"
shared
float
myShared
[
10
]
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_Position
=
i
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
FragmentShaderSharedMemory
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
shared
float
myShared
[
10
]
;
\
n
"
"
out
vec4
color
;
\
n
"
"
void
main
(
)
{
\
n
"
"
color
=
vec4
(
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
UniformSharedMemory
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
local_size_x
=
5
)
in
;
\
n
"
"
uniform
shared
float
myShared
[
100
]
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
CorrectUsageOfSharedMemory
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
local_size_x
=
5
)
in
;
\
n
"
"
shared
float
myShared
[
100
]
;
\
n
"
"
void
main
(
)
{
\
n
"
"
myShared
[
gl_LocalInvocationID
.
x
]
=
1
.
0
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
SharedVariableInitialization
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
local_size_x
=
5
)
in
;
\
n
"
"
shared
int
myShared
=
0
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
SharedMemoryInFunctionBody
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
local_size_x
=
5
)
in
;
\
n
"
"
void
func
(
)
{
\
n
"
"
shared
int
myShared
;
\
n
"
"
}
\
n
"
"
void
main
(
)
{
\
n
"
"
func
(
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
SharedMemoryInStruct
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
local_size_x
=
5
)
in
;
\
n
"
"
struct
MyStruct
{
\
n
"
"
shared
int
myShared
;
\
n
"
"
}
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
SharedMemoryInInterfaceBlock
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
local_size_x
=
5
)
in
;
\
n
"
"
uniform
Myblock
{
\
n
"
"
shared
int
myShared
;
\
n
"
"
}
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
SharedWithInvariant
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
local_size_x
=
5
)
in
;
\
n
"
"
invariant
shared
int
myShared
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
SharedWithMemoryQualifier
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
local_size_x
=
5
)
in
;
\
n
"
"
readonly
shared
int
myShared
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
SharedGlobalLayoutDeclaration
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
local_size_x
=
5
)
in
;
\
n
"
"
layout
(
row_major
)
shared
mat4
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
BuiltinESSL31FunctionDeclaredInESSL30Shader
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
void
imageSize
(
)
{
}
\
n
"
"
void
main
(
)
{
\
n
"
"
imageSize
(
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
VertexShaderValidationTest
InvalidNumViews
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
num_views
=
2
)
in
;
\
n
"
"
void
main
(
)
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
InvalidUseOfMemoryBarrierShared
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
{
\
n
"
"
memoryBarrierShared
(
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
InvalidUseOfGroupMemoryBarrier
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
{
\
n
"
"
groupMemoryBarrier
(
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
ValidUseOfBarrier
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
15
)
in
;
\
n
"
"
void
main
(
)
{
\
n
"
"
barrier
(
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ValidUseOfMemoryBarrierImageInFragmentShader
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
highp
image2D
;
\
n
"
"
layout
(
r32f
)
uniform
image2D
myImage
;
\
n
"
"
void
main
(
)
{
\
n
"
"
imageStore
(
myImage
ivec2
(
0
)
vec4
(
1
.
0
)
)
;
\
n
"
"
memoryBarrierImage
(
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
Sampler2DMSInESSL300Shader
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
uniform
highp
sampler2DMS
s
;
\
n
"
"
void
main
(
)
{
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
InvalidMainPrototypeParameters
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
void
main
(
int
a
)
;
\
n
"
"
void
main
(
)
{
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
VoidFieldStructUnsizedArrayEmptyConstructor
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
struct
S
{
void
a
;
}
;
"
"
void
main
(
)
{
S
s
[
]
=
S
[
]
(
)
;
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
SamplerFieldStructUnsizedArrayEmptyConstructor
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
struct
S
{
sampler2D
a
;
}
;
"
"
void
main
(
)
{
S
s
[
]
=
S
[
]
(
)
;
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
VertexShaderValidationTest
InvalidArrayConstruction
)
{
const
std
:
:
string
&
shaderString
=
"
struct
S
{
mediump
float
i
;
mediump
int
ggb
;
}
;
\
n
"
"
void
main
(
)
{
\
n
"
"
S
s
[
2
]
;
\
n
"
"
s
=
S
[
]
(
s
.
x
0
.
0
)
;
\
n
"
"
gl_Position
=
vec4
(
1
0
0
1
)
;
\
n
"
"
}
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
CorrectImageBindingLayoutQualifier
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
image2D
;
\
n
"
"
layout
(
local_size_x
=
5
)
in
;
\
n
"
"
layout
(
binding
=
1
rgba32f
)
writeonly
uniform
image2D
myImage
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
imageStore
(
myImage
ivec2
(
gl_LocalInvocationID
.
xy
)
vec4
(
1
.
0
)
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
IncorrectGlobalBindingLayoutQualifier
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
5
binding
=
0
)
in
;
\
n
"
"
void
main
(
)
{
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
IncorrectStructFieldBindingLayoutQualifier
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
local_size_x
=
1
)
in
;
\
n
"
"
struct
S
\
n
"
"
{
\
n
"
"
layout
(
binding
=
0
)
float
f
;
\
n
"
"
}
;
\
n
"
"
void
main
(
)
{
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ImageBindingUnitNegative
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
rgba32f
binding
=
0xffffffff
)
writeonly
uniform
mediump
image2D
myImage
;
\
n
"
"
out
vec4
outFrag
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
outFrag
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ImageBindingUnitTooBig
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
rgba32f
binding
=
9999
)
writeonly
uniform
mediump
image2D
myImage
;
\
n
"
"
out
vec4
outFrag
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
outFrag
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
NonOpaqueUniformBinding
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
binding
=
0
)
uniform
float
myFloat
;
\
n
"
"
out
vec4
outFrag
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
outFrag
=
vec4
(
myFloat
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
SamplerUniformBinding
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
binding
=
0
)
uniform
mediump
sampler2D
mySampler
;
\
n
"
"
out
vec4
outFrag
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
outFrag
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
SamplerUniformBindingESSL300
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
binding
=
0
)
uniform
mediump
sampler2D
mySampler
;
\
n
"
"
out
vec4
outFrag
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
outFrag
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ConstructStructContainingVoidArray
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
outFrag
;
\
n
"
"
struct
S
\
n
"
"
{
\
n
"
"
void
A
[
1
]
;
\
n
"
"
}
s
=
S
(
)
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
outFrag
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
UniformLocationEmptyDeclaration
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
location
=
0
)
uniform
float
;
\
n
"
"
void
main
(
)
{
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
OpaqueParameterCanNotBeLValue
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
uniform
sampler2D
s
;
\
n
"
"
void
foo
(
sampler2D
as
)
{
\
n
"
"
as
=
s
;
\
n
"
"
}
\
n
"
"
void
main
(
)
{
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
InvalidExpressionForSamplerOperands
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
uniform
sampler2D
s
;
\
n
"
"
uniform
sampler2D
s2
;
\
n
"
"
void
main
(
)
{
\
n
"
"
s
+
s2
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
InvalidInterfaceBlockBinaryExpression
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
uniform
U
\
n
"
"
{
\
n
"
"
int
foo
;
\
n
"
"
}
u
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
u
+
u
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
InvalidInterfaceBlockUnaryExpression
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
uniform
U
\
n
"
"
{
\
n
"
"
int
foo
;
\
n
"
"
}
u
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
+
u
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
InvalidInterfaceBlockTernaryExpression
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
uniform
U
\
n
"
"
{
\
n
"
"
int
foo
;
\
n
"
"
}
u
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
true
?
u
:
u
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
BufferAndSharedAsIdentifierOnES3
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
int
buffer
;
\
n
"
"
int
shared
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
StructAsBoolConstructorArgument
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
struct
my_struct
\
n
"
"
{
\
n
"
"
float
f
;
\
n
"
"
}
;
\
n
"
"
my_struct
a
=
my_struct
(
1
.
0
)
;
\
n
"
"
void
main
(
void
)
\
n
"
"
{
\
n
"
"
bool
test
=
bool
(
a
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderEnforcePackingValidationTest
MaxComputeUniformComponents
)
{
GLint
uniformVectorCount
=
kMaxComputeUniformComponents
/
4
;
std
:
:
ostringstream
ostream
;
ostream
<
<
"
#
version
310
es
\
n
"
"
layout
(
local_size_x
=
1
)
in
;
\
n
"
;
for
(
GLint
i
=
0
;
i
<
uniformVectorCount
;
+
+
i
)
{
ostream
<
<
"
uniform
vec4
u_value
"
<
<
i
<
<
"
;
\
n
"
;
}
ostream
<
<
"
void
main
(
)
\
n
"
"
{
\
n
"
;
for
(
GLint
i
=
0
;
i
<
uniformVectorCount
;
+
+
i
)
{
ostream
<
<
"
vec4
v
"
<
<
i
<
<
"
=
u_value
"
<
<
i
<
<
"
;
\
n
"
;
}
ostream
<
<
"
}
\
n
"
;
if
(
!
compile
(
ostream
.
str
(
)
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
FunctionDeclaredWithReservedName
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
void
gl_
(
)
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
gl_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
FunctionDefinedWithReservedName
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
void
gl_
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
gl_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
InvalidOpsWithConstantOperandsDontAssert
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
float
f1
=
0
.
5
/
2
;
\
n
"
"
float
f2
=
true
+
0
.
5
;
\
n
"
"
float
f3
=
float
[
2
]
(
0
.
0
1
.
0
)
[
1
.
0
]
;
\
n
"
"
float
f4
=
float
[
2
]
(
0
.
0
1
.
0
)
[
true
]
;
\
n
"
"
float
f5
=
true
?
1
.
0
:
0
;
\
n
"
"
float
f6
=
1
.
0
?
1
.
0
:
2
.
0
;
\
n
"
"
my_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
CaseLabelsWithInvalidTypesDontAssert
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
uniform
int
i
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
float
f
=
0
.
0
;
\
n
"
"
switch
(
i
)
\
n
"
"
{
\
n
"
"
case
0u
:
\
n
"
"
f
=
0
.
0
;
\
n
"
"
case
true
:
\
n
"
"
f
=
1
.
0
;
\
n
"
"
case
2
.
0
:
\
n
"
"
f
=
2
.
0
;
\
n
"
"
}
\
n
"
"
my_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ArrayAsIndex
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
int
i
[
2
]
=
int
[
2
]
(
0
1
)
;
\
n
"
"
float
f
[
2
]
=
float
[
2
]
(
2
.
0
3
.
0
)
;
\
n
"
"
my_FragColor
=
vec4
(
f
[
i
]
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
ArrayAsArraySize
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
const
int
i
[
2
]
=
int
[
2
]
(
1
2
)
;
\
n
"
"
float
f
[
i
]
;
\
n
"
"
my_FragColor
=
vec4
(
f
[
0
]
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
VertexShaderValidationTest
InvalidUseOfInputPrimitives
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
points
)
in
vec4
myInput
;
\
n
"
"
out
vec4
myOutput
;
\
n
"
"
void
main
(
)
{
\
n
"
"
myOutput
=
myInput
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
InvalidUseOfInputPrimitives
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
points
)
in
vec4
myInput
;
\
n
"
"
out
vec4
myOutput
;
\
n
"
"
void
main
(
)
{
\
n
"
"
myOutput
=
myInput
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
InvalidUseOfInputPrimitives
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
points
local_size_x
=
12
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
uvec3
WorkGroupSize
=
gl_WorkGroupSize
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
VertexShaderValidationTest
InvalidUseOfOutputPrimitives
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
in
vec4
myInput
;
\
n
"
"
layout
(
points
)
out
vec4
myOutput
;
\
n
"
"
void
main
(
)
{
\
n
"
"
myOutput
=
myInput
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
InvalidUseOfOutputPrimitives
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
in
vec4
myInput
;
\
n
"
"
layout
(
points
)
out
vec4
myOutput
;
\
n
"
"
void
main
(
)
{
\
n
"
"
myOutput
=
myInput
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
VertexShaderValidationTest
InvalidUseOfInvocations
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
invocations
=
3
)
in
vec4
myInput
;
\
n
"
"
out
vec4
myOutput
;
\
n
"
"
void
main
(
)
{
\
n
"
"
myOutput
=
myInput
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
InvalidUseOfInvocations
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
invocations
=
3
)
in
vec4
myInput
;
\
n
"
"
out
vec4
myOutput
;
\
n
"
"
void
main
(
)
{
\
n
"
"
myOutput
=
myInput
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
ComputeShaderValidationTest
InvalidUseOfInvocations
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
layout
(
invocations
=
3
local_size_x
=
12
)
in
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
uvec3
WorkGroupSize
=
gl_WorkGroupSize
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
VertexShaderValidationTest
InvalidUseOfMaxVertices
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
in
vec4
myInput
;
\
n
"
"
layout
(
max_vertices
=
3
)
out
vec4
myOutput
;
\
n
"
"
void
main
(
)
{
\
n
"
"
myOutput
=
myInput
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
InvalidUseOfMaxVertices
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
in
vec4
myInput
;
\
n
"
"
layout
(
max_vertices
=
3
)
out
vec4
myOutput
;
\
n
"
"
void
main
(
)
{
\
n
"
"
myOutput
=
myInput
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
RedefinedParamInFunctionHeader
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
foo
(
int
a
float
a
)
\
n
"
"
{
\
n
"
"
return
;
\
n
"
"
}
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
my_FragColor
=
vec4
(
0
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
VertexShaderValidationTest
ViewportIndexInESSL310
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
gl_Position
=
vec4
(
gl_ViewportIndex
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderOESGeometryShaderValidationTest
PrimitiveIDWithExtension
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
#
extension
GL_OES_geometry_shader
:
require
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
location
=
0
)
out
mediump
vec4
fragColor
;
\
n
"
"
void
main
(
void
)
\
n
"
"
{
\
n
"
"
vec4
data
=
vec4
(
0
.
1
0
.
2
0
.
3
0
.
4
)
;
\
n
"
"
float
value
=
data
[
gl_PrimitiveID
%
4
]
;
\
n
"
"
fragColor
=
vec4
(
value
0
0
1
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderOESGeometryShaderValidationTest
PrimitiveIDWithoutExtension
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
location
=
0
)
out
mediump
vec4
fragColor
;
\
n
"
"
void
main
(
void
)
\
n
"
"
{
\
n
"
"
vec4
data
=
vec4
(
0
.
1
0
.
2
0
.
3
0
.
4
)
;
\
n
"
"
float
value
=
data
[
gl_PrimitiveID
%
4
]
;
\
n
"
"
fragColor
=
vec4
(
value
0
0
1
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderOESGeometryShaderValidationTest
AssignValueToPrimitiveID
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
#
extension
GL_OES_geometry_shader
:
require
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
location
=
0
)
out
mediump
vec4
fragColor
;
\
n
"
"
void
main
(
void
)
\
n
"
"
{
\
n
"
"
gl_PrimitiveID
=
1
;
\
n
"
"
fragColor
=
vec4
(
1
.
0
0
.
0
0
.
0
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderOESGeometryShaderValidationTest
LayerWithExtension
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
#
extension
GL_OES_geometry_shader
:
require
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
location
=
0
)
out
mediump
vec4
fragColor
;
\
n
"
"
void
main
(
void
)
\
n
"
"
{
\
n
"
"
vec4
data
=
vec4
(
0
.
1
0
.
2
0
.
3
0
.
4
)
;
\
n
"
"
float
value
=
data
[
gl_Layer
%
4
]
;
\
n
"
"
fragColor
=
vec4
(
value
0
0
1
)
;
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderOESGeometryShaderValidationTest
LayerWithoutExtension
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
location
=
0
)
out
mediump
vec4
fragColor
;
\
n
"
"
void
main
(
void
)
\
n
"
"
{
\
n
"
"
vec4
data
=
vec4
(
0
.
1
0
.
2
0
.
3
0
.
4
)
;
\
n
"
"
float
value
=
data
[
gl_Layer
%
4
]
;
\
n
"
"
fragColor
=
vec4
(
value
0
0
1
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderOESGeometryShaderValidationTest
AssignValueToLayer
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
#
extension
GL_OES_geometry_shader
:
require
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
location
=
0
)
out
mediump
vec4
fragColor
;
\
n
"
"
void
main
(
void
)
\
n
"
"
{
\
n
"
"
gl_Layer
=
1
;
\
n
"
"
fragColor
=
vec4
(
1
.
0
0
.
0
0
.
0
1
.
0
)
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderOESGeometryShaderValidationTest
GeometryShaderBuiltInConstants
)
{
const
std
:
:
string
&
kShaderHeader
=
"
#
version
310
es
\
n
"
"
#
extension
GL_OES_geometry_shader
:
require
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
location
=
0
)
out
mediump
vec4
fragColor
;
\
n
"
"
void
main
(
void
)
\
n
"
"
{
\
n
"
"
int
val
=
"
;
const
std
:
:
array
<
std
:
:
string
9
>
kGeometryShaderBuiltinConstants
=
{
{
"
gl_MaxGeometryInputComponents
"
"
gl_MaxGeometryOutputComponents
"
"
gl_MaxGeometryImageUniforms
"
"
gl_MaxGeometryTextureImageUnits
"
"
gl_MaxGeometryOutputVertices
"
"
gl_MaxGeometryTotalOutputComponents
"
"
gl_MaxGeometryUniformComponents
"
"
gl_MaxGeometryAtomicCounters
"
"
gl_MaxGeometryAtomicCounterBuffers
"
}
}
;
const
std
:
:
string
&
kShaderTail
=
"
;
\
n
"
"
fragColor
=
vec4
(
1
.
0
0
.
0
0
.
0
1
.
0
)
;
\
n
"
"
}
\
n
"
;
for
(
const
std
:
:
string
&
kGSBuiltinConstant
:
kGeometryShaderBuiltinConstants
)
{
std
:
:
ostringstream
ostream
;
ostream
<
<
kShaderHeader
<
<
kGSBuiltinConstant
<
<
kShaderTail
;
if
(
!
compile
(
ostream
.
str
(
)
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
}
TEST_F
(
FragmentShaderOESGeometryShaderValidationTest
GeometryShaderBuiltInConstantsWithoutExtension
)
{
const
std
:
:
string
&
kShaderHeader
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
location
=
0
)
out
mediump
vec4
fragColor
;
\
n
"
"
void
main
(
void
)
\
n
"
"
{
\
n
"
"
int
val
=
"
;
const
std
:
:
array
<
std
:
:
string
9
>
kGeometryShaderBuiltinConstants
=
{
{
"
gl_MaxGeometryInputComponents
"
"
gl_MaxGeometryOutputComponents
"
"
gl_MaxGeometryImageUniforms
"
"
gl_MaxGeometryTextureImageUnits
"
"
gl_MaxGeometryOutputVertices
"
"
gl_MaxGeometryTotalOutputComponents
"
"
gl_MaxGeometryUniformComponents
"
"
gl_MaxGeometryAtomicCounters
"
"
gl_MaxGeometryAtomicCounterBuffers
"
}
}
;
const
std
:
:
string
&
kShaderTail
=
"
;
\
n
"
"
fragColor
=
vec4
(
1
.
0
0
.
0
0
.
0
1
.
0
)
;
\
n
"
"
}
\
n
"
;
for
(
const
std
:
:
string
&
kGSBuiltinConstant
:
kGeometryShaderBuiltinConstants
)
{
std
:
:
ostringstream
ostream
;
ostream
<
<
kShaderHeader
<
<
kGSBuiltinConstant
<
<
kShaderTail
;
if
(
compile
(
ostream
.
str
(
)
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
}
TEST_F
(
VertexShaderValidationTest
InterfaceBlockUsingConstQualifier
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
const
block
\
n
"
"
{
\
n
"
"
vec2
value
;
\
n
"
"
}
ConstBlock
[
2
]
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
int
i
=
0
;
\
n
"
"
vec2
value1
=
ConstBlock
[
i
]
.
value
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
VertexShaderValidationTest
IOBlockWithoutExtension
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
out
block
\
n
"
"
{
\
n
"
"
vec2
value
;
\
n
"
"
}
VSOutput
[
2
]
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
int
i
=
0
;
\
n
"
"
vec2
value1
=
VSOutput
[
i
]
.
value
;
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
IOBlockWithoutExtension
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
in
block
\
n
"
"
{
\
n
"
"
vec4
i_color
;
\
n
"
"
}
FSInput
[
2
]
;
\
n
"
"
out
vec4
o_color
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
int
i
=
0
;
\
n
"
"
o_color
=
FSInput
[
i
]
.
i_color
;
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
AssignValueToFlatIn
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
flat
in
float
value
;
\
n
"
"
out
vec4
o_color
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
value
=
1
.
0
;
\
n
"
"
o_color
=
vec4
(
1
.
0
0
.
0
0
.
0
1
.
0
)
;
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
AssignValueToSmoothIn
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
smooth
in
float
value
;
\
n
"
"
out
vec4
o_color
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
value
=
1
.
0
;
\
n
"
"
o_color
=
vec4
(
1
.
0
0
.
0
0
.
0
1
.
0
)
;
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
AssignValueToCentroidIn
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
centroid
in
float
value
;
\
n
"
"
out
vec4
o_color
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
value
=
1
.
0
;
\
n
"
"
o_color
=
vec4
(
1
.
0
0
.
0
0
.
0
1
.
0
)
;
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
DynamicComponentTextureGather
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
sampler2D
;
\
n
"
"
uniform
sampler2D
tex
;
\
n
"
"
out
vec4
o_color
;
\
n
"
"
uniform
int
uComp
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
o_color
=
textureGather
(
tex
vec2
(
0
)
uComp
)
;
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
TextureGatherNegativeComponent
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
sampler2D
;
\
n
"
"
uniform
sampler2D
tex
;
\
n
"
"
out
vec4
o_color
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
o_color
=
textureGather
(
tex
vec2
(
0
)
-
1
)
;
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
TextureGatherTooGreatComponent
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
sampler2D
;
\
n
"
"
uniform
sampler2D
tex
;
\
n
"
"
out
vec4
o_color
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
o_color
=
textureGather
(
tex
vec2
(
0
)
4
)
;
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
TextureGatherTooGreatOffset
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
mediump
sampler2D
;
\
n
"
"
uniform
sampler2D
tex
;
\
n
"
"
out
vec4
o_color
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
o_color
=
textureGatherOffset
(
tex
vec2
(
0
)
ivec2
(
-
100
)
2
)
;
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
VertexShaderValidationTest
UseLocationOnVertexOutES30
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
in
vec4
v1
;
\
n
"
"
layout
(
location
=
1
)
out
vec4
o_color
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
VertexShaderValidationTest
UseLocationOnVertexOutES31
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
in
vec4
v1
;
\
n
"
"
layout
(
location
=
1
)
out
vec4
o_color1
;
\
n
"
"
layout
(
location
=
2
)
out
vec4
o_color2
;
\
n
"
"
out
vec3
v3
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
UseLocationOnFragmentInES30
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
location
=
0
)
in
vec4
v_color1
;
\
n
"
"
layout
(
location
=
0
)
out
vec4
o_color
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
UseLocationOnFragmentInES31
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
layout
(
location
=
0
)
in
mat4
v_mat
;
\
n
"
"
layout
(
location
=
4
)
in
vec4
v_color1
;
\
n
"
"
in
vec2
v_color2
;
\
n
"
"
layout
(
location
=
0
)
out
vec4
o_color
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
!
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
failed
expecting
success
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
VertexShaderValidationTest
DeclareSameLocationOnVertexOut
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
in
float
i_value
;
\
n
"
"
layout
(
location
=
1
)
out
vec4
o_color1
;
\
n
"
"
layout
(
location
=
1
)
out
vec4
o_color2
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
FragmentShaderValidationTest
DeclareSameLocationOnFragmentIn
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
in
float
i_value
;
\
n
"
"
layout
(
location
=
1
)
in
vec4
i_color1
;
\
n
"
"
layout
(
location
=
1
)
in
vec4
i_color2
;
\
n
"
"
layout
(
location
=
0
)
out
vec4
o_color
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
VertexShaderValidationTest
LocationConflictsnOnArrayElement
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
in
float
i_value
;
\
n
"
"
layout
(
location
=
0
)
out
vec4
o_color1
[
3
]
;
\
n
"
"
layout
(
location
=
1
)
out
vec4
o_color2
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
VertexShaderValidationTest
LocationConflictsOnMatrixElement
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
in
float
i_value
;
\
n
"
"
layout
(
location
=
0
)
out
mat4
o_mvp
;
\
n
"
"
layout
(
location
=
2
)
out
vec4
o_color
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
TEST_F
(
VertexShaderValidationTest
LocationConflictsOnStructElement
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
310
es
\
n
"
"
in
float
i_value
;
\
n
"
"
struct
S
\
n
"
"
{
\
n
"
"
float
value1
;
\
n
"
"
vec3
value2
;
\
n
"
"
}
;
\
n
"
"
layout
(
location
=
0
)
out
S
s_in
;
"
"
layout
(
location
=
1
)
out
vec4
o_color
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
}
\
n
"
;
if
(
compile
(
shaderString
)
)
{
FAIL
(
)
<
<
"
Shader
compilation
succeeded
expecting
failure
:
\
n
"
<
<
mInfoLog
;
}
}
