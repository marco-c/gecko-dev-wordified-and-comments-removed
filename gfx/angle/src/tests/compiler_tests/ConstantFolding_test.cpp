#
include
"
tests
/
test_utils
/
ConstantFoldingTest
.
h
"
using
namespace
sh
;
TEST_F
(
ConstantFoldingExpressionTest
FoldFloatTestSanityCheck
)
{
const
std
:
:
string
&
floatString
=
"
1
.
0
"
;
evaluateFloat
(
floatString
)
;
ASSERT_FALSE
(
constantFoundInAST
(
0
.
0f
)
)
;
ASSERT_FALSE
(
constantFoundInAST
(
true
)
)
;
ASSERT_FALSE
(
constantFoundInAST
(
false
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldIntegerAdd
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
int
my_Int
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
int
i
=
1124
+
5
;
\
n
"
"
my_Int
=
i
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_FALSE
(
constantFoundInAST
(
1124
)
)
;
ASSERT_FALSE
(
constantFoundInAST
(
5
)
)
;
ASSERT_TRUE
(
constantFoundInAST
(
1129
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldIntegerSub
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
int
my_Int
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
int
i
=
1124
-
5
;
\
n
"
"
my_Int
=
i
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_FALSE
(
constantFoundInAST
(
1124
)
)
;
ASSERT_FALSE
(
constantFoundInAST
(
5
)
)
;
ASSERT_TRUE
(
constantFoundInAST
(
1119
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldIntegerMul
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
int
my_Int
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
int
i
=
1124
*
5
;
\
n
"
"
my_Int
=
i
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_FALSE
(
constantFoundInAST
(
1124
)
)
;
ASSERT_FALSE
(
constantFoundInAST
(
5
)
)
;
ASSERT_TRUE
(
constantFoundInAST
(
5620
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldIntegerDiv
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
int
my_Int
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
int
i
=
1124
/
5
;
\
n
"
"
my_Int
=
i
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_FALSE
(
constantFoundInAST
(
1124
)
)
;
ASSERT_FALSE
(
constantFoundInAST
(
5
)
)
;
ASSERT_TRUE
(
constantFoundInAST
(
224
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldIntegerModulus
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
int
my_Int
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
int
i
=
1124
%
5
;
\
n
"
"
my_Int
=
i
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_FALSE
(
constantFoundInAST
(
1124
)
)
;
ASSERT_FALSE
(
constantFoundInAST
(
5
)
)
;
ASSERT_TRUE
(
constantFoundInAST
(
4
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldVectorCrossProduct
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec3
my_Vec3
;
"
"
void
main
(
)
{
\
n
"
"
const
vec3
v3
=
cross
(
vec3
(
1
.
0f
1
.
0f
1
.
0f
)
vec3
(
1
.
0f
-
1
.
0f
1
.
0f
)
)
;
\
n
"
"
my_Vec3
=
v3
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
std
:
:
vector
<
float
>
input1
(
3
1
.
0f
)
;
ASSERT_FALSE
(
constantVectorFoundInAST
(
input1
)
)
;
std
:
:
vector
<
float
>
input2
;
input2
.
push_back
(
1
.
0f
)
;
input2
.
push_back
(
-
1
.
0f
)
;
input2
.
push_back
(
1
.
0f
)
;
ASSERT_FALSE
(
constantVectorFoundInAST
(
input2
)
)
;
std
:
:
vector
<
float
>
result
;
result
.
push_back
(
2
.
0f
)
;
result
.
push_back
(
0
.
0f
)
;
result
.
push_back
(
-
2
.
0f
)
;
ASSERT_TRUE
(
constantVectorFoundInAST
(
result
)
)
;
}
TEST_F
(
ConstantFoldingTest
Fold2x2MatrixInverse
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
in
float
i
;
\
n
"
"
out
vec2
my_Vec
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
mat2
m2
=
inverse
(
mat2
(
2
.
0f
3
.
0f
\
n
"
"
5
.
0f
7
.
0f
)
)
;
\
n
"
"
mat2
m
=
m2
*
mat2
(
i
)
;
\
n
"
"
my_Vec
=
m
[
0
]
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
float
inputElements
[
]
=
{
2
.
0f
3
.
0f
5
.
0f
7
.
0f
}
;
std
:
:
vector
<
float
>
input
(
inputElements
inputElements
+
4
)
;
ASSERT_FALSE
(
constantColumnMajorMatrixFoundInAST
(
input
)
)
;
float
outputElements
[
]
=
{
-
7
.
0f
3
.
0f
5
.
0f
-
2
.
0f
}
;
std
:
:
vector
<
float
>
result
(
outputElements
outputElements
+
4
)
;
ASSERT_TRUE
(
constantColumnMajorMatrixFoundInAST
(
result
)
)
;
}
TEST_F
(
ConstantFoldingTest
Fold3x3MatrixInverse
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
in
float
i
;
\
n
"
"
out
vec3
my_Vec
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
mat3
m3
=
inverse
(
mat3
(
11
.
0f
13
.
0f
19
.
0f
\
n
"
"
23
.
0f
29
.
0f
31
.
0f
\
n
"
"
37
.
0f
41
.
0f
43
.
0f
)
)
;
\
n
"
"
mat3
m
=
m3
*
mat3
(
i
)
;
\
n
"
"
my_Vec
=
m3
[
0
]
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
float
inputElements
[
]
=
{
11
.
0f
13
.
0f
19
.
0f
23
.
0f
29
.
0f
31
.
0f
37
.
0f
41
.
0f
43
.
0f
}
;
std
:
:
vector
<
float
>
input
(
inputElements
inputElements
+
9
)
;
ASSERT_FALSE
(
constantVectorFoundInAST
(
input
)
)
;
float
outputElements
[
]
=
{
3
.
0f
/
85
.
0f
-
11
.
0f
/
34
.
0f
37
.
0f
/
170
.
0f
-
79
.
0f
/
340
.
0f
23
.
0f
/
68
.
0f
-
12
.
0f
/
85
.
0f
13
.
0f
/
68
.
0f
-
3
.
0f
/
68
.
0f
-
1
.
0f
/
34
.
0f
}
;
std
:
:
vector
<
float
>
result
(
outputElements
outputElements
+
9
)
;
const
float
floatFaultTolerance
=
0
.
000001f
;
ASSERT_TRUE
(
constantVectorNearFoundInAST
(
result
floatFaultTolerance
)
)
;
}
TEST_F
(
ConstantFoldingTest
Fold4x4MatrixInverse
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
in
float
i
;
\
n
"
"
out
vec4
my_Vec
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
mat4
m4
=
inverse
(
mat4
(
29
.
0f
31
.
0f
37
.
0f
41
.
0f
\
n
"
"
43
.
0f
47
.
0f
53
.
0f
59
.
0f
\
n
"
"
61
.
0f
67
.
0f
71
.
0f
73
.
0f
\
n
"
"
79
.
0f
83
.
0f
89
.
0f
97
.
0f
)
)
;
\
n
"
"
mat4
m
=
m4
*
mat4
(
i
)
;
\
n
"
"
my_Vec
=
m
[
0
]
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
float
inputElements
[
]
=
{
29
.
0f
31
.
0f
37
.
0f
41
.
0f
43
.
0f
47
.
0f
53
.
0f
59
.
0f
61
.
0f
67
.
0f
71
.
0f
73
.
0f
79
.
0f
83
.
0f
89
.
0f
97
.
0f
}
;
std
:
:
vector
<
float
>
input
(
inputElements
inputElements
+
16
)
;
ASSERT_FALSE
(
constantVectorFoundInAST
(
input
)
)
;
float
outputElements
[
]
=
{
43
.
0f
/
126
.
0f
-
11
.
0f
/
21
.
0f
-
2
.
0f
/
21
.
0f
31
.
0f
/
126
.
0f
-
5
.
0f
/
7
.
0f
9
.
0f
/
14
.
0f
1
.
0f
/
14
.
0f
-
1
.
0f
/
7
.
0f
85
.
0f
/
126
.
0f
-
11
.
0f
/
21
.
0f
43
.
0f
/
210
.
0f
-
38
.
0f
/
315
.
0f
-
2
.
0f
/
7
.
0f
5
.
0f
/
14
.
0f
-
6
.
0f
/
35
.
0f
3
.
0f
/
70
.
0f
}
;
std
:
:
vector
<
float
>
result
(
outputElements
outputElements
+
16
)
;
const
float
floatFaultTolerance
=
0
.
00001f
;
ASSERT_TRUE
(
constantVectorNearFoundInAST
(
result
floatFaultTolerance
)
)
;
}
TEST_F
(
ConstantFoldingTest
Fold2x2MatrixDeterminant
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
float
my_Float
;
"
"
void
main
(
)
{
\
n
"
"
const
float
f
=
determinant
(
mat2
(
2
.
0f
3
.
0f
\
n
"
"
5
.
0f
7
.
0f
)
)
;
\
n
"
"
my_Float
=
f
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
float
inputElements
[
]
=
{
2
.
0f
3
.
0f
5
.
0f
7
.
0f
}
;
std
:
:
vector
<
float
>
input
(
inputElements
inputElements
+
4
)
;
ASSERT_FALSE
(
constantColumnMajorMatrixFoundInAST
(
input
)
)
;
ASSERT_TRUE
(
constantFoundInAST
(
-
1
.
0f
)
)
;
}
TEST_F
(
ConstantFoldingTest
Fold3x3MatrixDeterminant
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
float
my_Float
;
"
"
void
main
(
)
{
\
n
"
"
const
float
f
=
determinant
(
mat3
(
11
.
0f
13
.
0f
19
.
0f
\
n
"
"
23
.
0f
29
.
0f
31
.
0f
\
n
"
"
37
.
0f
41
.
0f
43
.
0f
)
)
;
\
n
"
"
my_Float
=
f
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
float
inputElements
[
]
=
{
11
.
0f
13
.
0f
19
.
0f
23
.
0f
29
.
0f
31
.
0f
37
.
0f
41
.
0f
43
.
0f
}
;
std
:
:
vector
<
float
>
input
(
inputElements
inputElements
+
9
)
;
ASSERT_FALSE
(
constantColumnMajorMatrixFoundInAST
(
input
)
)
;
ASSERT_TRUE
(
constantFoundInAST
(
-
680
.
0f
)
)
;
}
TEST_F
(
ConstantFoldingTest
Fold4x4MatrixDeterminant
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
float
my_Float
;
"
"
void
main
(
)
{
\
n
"
"
const
float
f
=
determinant
(
mat4
(
29
.
0f
31
.
0f
37
.
0f
41
.
0f
\
n
"
"
43
.
0f
47
.
0f
53
.
0f
59
.
0f
\
n
"
"
61
.
0f
67
.
0f
71
.
0f
73
.
0f
\
n
"
"
79
.
0f
83
.
0f
89
.
0f
97
.
0f
)
)
;
\
n
"
"
my_Float
=
f
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
float
inputElements
[
]
=
{
29
.
0f
31
.
0f
37
.
0f
41
.
0f
43
.
0f
47
.
0f
53
.
0f
59
.
0f
61
.
0f
67
.
0f
71
.
0f
73
.
0f
79
.
0f
83
.
0f
89
.
0f
97
.
0f
}
;
std
:
:
vector
<
float
>
input
(
inputElements
inputElements
+
16
)
;
ASSERT_FALSE
(
constantColumnMajorMatrixFoundInAST
(
input
)
)
;
ASSERT_TRUE
(
constantFoundInAST
(
-
2520
.
0f
)
)
;
}
TEST_F
(
ConstantFoldingTest
Fold3x3MatrixTranspose
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
in
float
i
;
\
n
"
"
out
vec3
my_Vec
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
mat3
m3
=
transpose
(
mat3
(
11
.
0f
13
.
0f
19
.
0f
\
n
"
"
23
.
0f
29
.
0f
31
.
0f
\
n
"
"
37
.
0f
41
.
0f
43
.
0f
)
)
;
\
n
"
"
mat3
m
=
m3
*
mat3
(
i
)
;
\
n
"
"
my_Vec
=
m
[
0
]
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
float
inputElements
[
]
=
{
11
.
0f
13
.
0f
19
.
0f
23
.
0f
29
.
0f
31
.
0f
37
.
0f
41
.
0f
43
.
0f
}
;
std
:
:
vector
<
float
>
input
(
inputElements
inputElements
+
9
)
;
ASSERT_FALSE
(
constantColumnMajorMatrixFoundInAST
(
input
)
)
;
float
outputElements
[
]
=
{
11
.
0f
23
.
0f
37
.
0f
13
.
0f
29
.
0f
41
.
0f
19
.
0f
31
.
0f
43
.
0f
}
;
std
:
:
vector
<
float
>
result
(
outputElements
outputElements
+
9
)
;
ASSERT_TRUE
(
constantColumnMajorMatrixFoundInAST
(
result
)
)
;
}
TEST_F
(
ConstantFoldingTest
ParseWrappedHexIntLiteral
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
highp
int
;
\
n
"
"
uniform
int
inInt
;
\
n
"
"
out
vec4
my_Vec
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
int
i
=
0xFFFFFFFF
;
\
n
"
"
my_Vec
=
vec4
(
i
*
inInt
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
-
1
)
)
;
}
TEST_F
(
ConstantFoldingTest
ParseWrappedDecimalIntLiteral
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
highp
int
;
\
n
"
"
uniform
int
inInt
;
\
n
"
"
out
vec4
my_Vec
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
int
i
=
3000000000
;
\
n
"
"
my_Vec
=
vec4
(
i
*
inInt
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
-
1294967296
)
)
;
}
TEST_F
(
ConstantFoldingTest
ParseMaxUintLiteral
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
highp
int
;
\
n
"
"
uniform
uint
inInt
;
\
n
"
"
out
vec4
my_Vec
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
uint
i
=
0xFFFFFFFFu
;
\
n
"
"
my_Vec
=
vec4
(
i
*
inInt
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
0xFFFFFFFFu
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldUnaryMinusOnUintLiteral
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
precision
highp
int
;
\
n
"
"
uniform
uint
inInt
;
\
n
"
"
out
vec4
my_Vec
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
uint
i
=
-
1u
;
\
n
"
"
my_Vec
=
vec4
(
i
*
inInt
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
0xFFFFFFFFu
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldMat2ConstructorTakingMat2
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
uniform
float
mult
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
mat2
cm
=
mat2
(
mat2
(
0
.
0
1
.
0
2
.
0
3
.
0
)
)
;
\
n
"
"
mat2
m
=
cm
*
mult
;
\
n
"
"
gl_FragColor
=
vec4
(
m
[
0
]
m
[
1
]
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
float
outputElements
[
]
=
{
0
.
0f
1
.
0f
2
.
0f
3
.
0f
}
;
std
:
:
vector
<
float
>
result
(
outputElements
outputElements
+
4
)
;
ASSERT_TRUE
(
constantColumnMajorMatrixFoundInAST
(
result
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldMat2ConstructorTakingScalar
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
uniform
float
mult
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
mat2
cm
=
mat2
(
3
)
;
\
n
"
"
mat2
m
=
cm
*
mult
;
\
n
"
"
gl_FragColor
=
vec4
(
m
[
0
]
m
[
1
]
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
float
outputElements
[
]
=
{
3
.
0f
0
.
0f
0
.
0f
3
.
0f
}
;
std
:
:
vector
<
float
>
result
(
outputElements
outputElements
+
4
)
;
ASSERT_TRUE
(
constantColumnMajorMatrixFoundInAST
(
result
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldMat2ConstructorTakingMix
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
uniform
float
mult
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
mat2
cm
=
mat2
(
-
1
vec2
(
0
.
0
1
.
0
)
vec4
(
2
.
0
)
)
;
\
n
"
"
mat2
m
=
cm
*
mult
;
\
n
"
"
gl_FragColor
=
vec4
(
m
[
0
]
m
[
1
]
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
float
outputElements
[
]
=
{
-
1
.
0
0
.
0f
1
.
0f
2
.
0f
}
;
std
:
:
vector
<
float
>
result
(
outputElements
outputElements
+
4
)
;
ASSERT_TRUE
(
constantColumnMajorMatrixFoundInAST
(
result
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldMat2ConstructorTakingMat3
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
uniform
float
mult
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
mat2
cm
=
mat2
(
mat3
(
0
.
0
1
.
0
2
.
0
3
.
0
4
.
0
5
.
0
6
.
0
7
.
0
8
.
0
)
)
;
\
n
"
"
mat2
m
=
cm
*
mult
;
\
n
"
"
gl_FragColor
=
vec4
(
m
[
0
]
m
[
1
]
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
float
outputElements
[
]
=
{
0
.
0f
1
.
0f
3
.
0f
4
.
0f
}
;
std
:
:
vector
<
float
>
result
(
outputElements
outputElements
+
4
)
;
ASSERT_TRUE
(
constantColumnMajorMatrixFoundInAST
(
result
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldMat4x3ConstructorTakingMat3x2
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
float
mult
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
mat4x3
cm
=
mat4x3
(
mat3x2
(
1
.
0
2
.
0
\
n
"
"
3
.
0
4
.
0
\
n
"
"
5
.
0
6
.
0
)
)
;
\
n
"
"
mat4x3
m
=
cm
*
mult
;
\
n
"
"
my_FragColor
=
vec4
(
m
[
0
]
m
[
1
]
[
0
]
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
float
outputElements
[
]
=
{
1
.
0f
2
.
0f
0
.
0f
3
.
0f
4
.
0f
0
.
0f
5
.
0f
6
.
0f
1
.
0f
0
.
0f
0
.
0f
0
.
0f
}
;
std
:
:
vector
<
float
>
result
(
outputElements
outputElements
+
12
)
;
ASSERT_TRUE
(
constantColumnMajorMatrixFoundInAST
(
result
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldMat2ConstructorTakingVec4
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
uniform
float
mult
;
\
n
"
"
void
main
(
)
{
\
n
"
"
const
mat2
cm
=
mat2
(
vec4
(
0
.
0
1
.
0
2
.
0
3
.
0
)
)
;
\
n
"
"
mat2
m
=
cm
*
mult
;
\
n
"
"
gl_FragColor
=
vec4
(
m
[
0
]
m
[
1
]
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
float
outputElements
[
]
=
{
0
.
0f
1
.
0f
2
.
0f
3
.
0f
}
;
std
:
:
vector
<
float
>
result
(
outputElements
outputElements
+
4
)
;
ASSERT_TRUE
(
constantColumnMajorMatrixFoundInAST
(
result
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldNestedDifferentStructEqualityComparison
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
struct
nested
{
\
n
"
"
float
f
\
n
;
"
"
}
;
\
n
"
"
struct
S
{
\
n
"
"
nested
a
;
\
n
"
"
float
f
;
\
n
"
"
}
;
\
n
"
"
uniform
vec4
mult
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
const
S
s1
=
S
(
nested
(
0
.
0
)
2
.
0
)
;
\
n
"
"
const
S
s2
=
S
(
nested
(
0
.
0
)
3
.
0
)
;
\
n
"
"
gl_FragColor
=
(
s1
=
=
s2
?
1
.
0
:
0
.
5
)
*
mult
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
0
.
5f
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldNestedIdenticalStructEqualityComparison
)
{
const
std
:
:
string
&
shaderString
=
"
precision
mediump
float
;
\
n
"
"
struct
nested
{
\
n
"
"
float
f
\
n
;
"
"
}
;
\
n
"
"
struct
S
{
\
n
"
"
nested
a
;
\
n
"
"
float
f
;
\
n
"
"
int
i
;
\
n
"
"
}
;
\
n
"
"
uniform
vec4
mult
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
const
S
s1
=
S
(
nested
(
0
.
0
)
2
.
0
3
)
;
\
n
"
"
const
S
s2
=
S
(
nested
(
0
.
0
)
2
.
0
3
)
;
\
n
"
"
gl_FragColor
=
(
s1
=
=
s2
?
1
.
0
:
0
.
5
)
*
mult
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
1
.
0f
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldNonSquareMatrixIndexing
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
my_FragColor
=
mat3x4
(
0
1
2
3
4
5
6
7
8
9
10
11
)
[
1
]
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
float
outputElements
[
]
=
{
4
.
0f
5
.
0f
6
.
0f
7
.
0f
}
;
std
:
:
vector
<
float
>
result
(
outputElements
outputElements
+
4
)
;
ASSERT_TRUE
(
constantVectorFoundInAST
(
result
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldNonSquareOuterProduct
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
mat3x2
prod
=
outerProduct
(
vec2
(
2
.
0
3
.
0
)
vec3
(
5
.
0
7
.
0
11
.
0
)
)
;
\
n
"
"
my_FragColor
=
vec4
(
prod
[
0
]
.
x
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
float
outputElements
[
]
=
{
10
.
0f
15
.
0f
14
.
0f
21
.
0f
22
.
0f
33
.
0f
}
;
std
:
:
vector
<
float
>
result
(
outputElements
outputElements
+
6
)
;
ASSERT_TRUE
(
constantColumnMajorMatrixFoundInAST
(
result
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldBitShiftLeftDifferentSignedness
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
uint
u
=
0xffffffffu
<
<
31
;
\
n
"
"
my_FragColor
=
vec4
(
u
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
0x80000000u
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldBitShiftRightDifferentSignedness
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
uint
u
=
0xffffffffu
>
>
30
;
\
n
"
"
my_FragColor
=
vec4
(
u
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
0x3u
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldBitShiftRightExtendSignBit
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
const
int
i
=
0x8fffe000
>
>
6
;
\
n
"
"
uint
u
=
uint
(
i
)
;
"
"
my_FragColor
=
vec4
(
u
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
0xfe3fff80u
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldBitShiftLeftInterpretedAsBitPattern
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
const
int
i
=
0x1fffffff
<
<
3
;
\
n
"
"
uint
u
=
uint
(
i
)
;
"
"
my_FragColor
=
vec4
(
u
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
0xfffffff8u
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldDivideMinimumIntegerByMinusOne
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
int
i
=
0x80000000
/
(
-
1
)
;
\
n
"
"
my_FragColor
=
vec4
(
i
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
0x7fffffff
)
|
|
constantFoundInAST
(
-
0x7fffffff
-
1
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldUnsignedIntegerAddOverflow
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
uint
u
=
0xffffffffu
+
43u
;
\
n
"
"
my_FragColor
=
vec4
(
u
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
42u
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldSignedIntegerAddOverflow
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
int
i
=
0x7fffffff
+
4
;
\
n
"
"
my_FragColor
=
vec4
(
i
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
-
0x7ffffffd
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldUnsignedIntegerDiffOverflow
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
uint
u
=
0u
-
5u
;
\
n
"
"
my_FragColor
=
vec4
(
u
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
0xfffffffbu
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldSignedIntegerDiffOverflow
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
int
i
=
-
0x7fffffff
-
7
;
\
n
"
"
my_FragColor
=
vec4
(
i
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
0x7ffffffa
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldUnsignedIntegerMultiplyOverflow
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
uint
u
=
0xffffffffu
*
10u
;
\
n
"
"
my_FragColor
=
vec4
(
u
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
0xfffffff6u
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldSignedIntegerMultiplyOverflow
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
int
i
=
0x7fffffff
*
42
;
\
n
"
"
my_FragColor
=
vec4
(
i
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
-
42
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldMinimumSignedIntegerNegation
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
int
i
=
-
0x80000000
;
\
n
"
"
my_FragColor
=
vec4
(
i
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
-
0x7fffffff
-
1
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldMinimumSignedIntegerRightShift
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
int
i
=
(
0x80000000
>
>
1
)
;
\
n
"
"
int
j
=
(
0x80000000
>
>
7
)
;
\
n
"
"
my_FragColor
=
vec4
(
i
j
i
j
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
-
0x40000000
)
)
;
ASSERT_TRUE
(
constantFoundInAST
(
-
0x01000000
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldShiftByZero
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
int
i
=
(
3
>
>
0
)
;
\
n
"
"
int
j
=
(
73
<
<
0
)
;
\
n
"
"
my_FragColor
=
vec4
(
i
j
i
j
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
3
)
)
;
ASSERT_TRUE
(
constantFoundInAST
(
73
)
)
;
}
TEST_F
(
ConstantFoldingTest
FoldIsInfOutOfRangeFloatLiteral
)
{
const
std
:
:
string
&
shaderString
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
out
vec4
my_FragColor
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
bool
b
=
isinf
(
1
.
0e2048
)
;
\
n
"
"
my_FragColor
=
vec4
(
b
)
;
\
n
"
"
}
\
n
"
;
compile
(
shaderString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
true
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldTooSmallFloat
)
{
const
std
:
:
string
&
floatString
=
"
1
.
0e
-
2048
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
0
.
0f
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldRadiansInfinity
)
{
const
std
:
:
string
&
floatString
=
"
radians
(
1
.
0e2048
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldDegreesInfinity
)
{
const
std
:
:
string
&
floatString
=
"
degrees
(
1
.
0e2048
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldSinhInfinity
)
{
const
std
:
:
string
&
floatString
=
"
sinh
(
1
.
0e2048
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldSinhNegativeInfinity
)
{
const
std
:
:
string
&
floatString
=
"
sinh
(
-
1
.
0e2048
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
-
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldCoshInfinity
)
{
const
std
:
:
string
&
floatString
=
"
cosh
(
1
.
0e2048
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldCoshNegativeInfinity
)
{
const
std
:
:
string
&
floatString
=
"
cosh
(
-
1
.
0e2048
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldAsinhInfinity
)
{
const
std
:
:
string
&
floatString
=
"
asinh
(
1
.
0e2048
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldAsinhNegativeInfinity
)
{
const
std
:
:
string
&
floatString
=
"
asinh
(
-
1
.
0e2048
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
-
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldAcoshInfinity
)
{
const
std
:
:
string
&
floatString
=
"
acosh
(
1
.
0e2048
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldPowInfinity
)
{
const
std
:
:
string
&
floatString
=
"
pow
(
0
.
0
1
.
0e2048
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
0
.
0f
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldExpInfinity
)
{
const
std
:
:
string
&
floatString
=
"
exp
(
1
.
0e2048
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldExpNegativeInfinity
)
{
const
std
:
:
string
&
floatString
=
"
exp
(
-
1
.
0e2048
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
0
.
0f
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldLogInfinity
)
{
const
std
:
:
string
&
floatString
=
"
log
(
1
.
0e2048
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldExp2Infinity
)
{
const
std
:
:
string
&
floatString
=
"
exp2
(
1
.
0e2048
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldExp2NegativeInfinity
)
{
const
std
:
:
string
&
floatString
=
"
exp2
(
-
1
.
0e2048
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
0
.
0f
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldLog2Infinity
)
{
const
std
:
:
string
&
floatString
=
"
log2
(
1
.
0e2048
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldSqrtInfinity
)
{
const
std
:
:
string
&
floatString
=
"
sqrt
(
1
.
0e2048
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldInversesqrtInfinity
)
{
const
std
:
:
string
&
floatString
=
"
inversesqrt
(
1
.
0e2048
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
0
.
0f
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldLengthInfinity
)
{
const
std
:
:
string
&
floatString
=
"
length
(
1
.
0e2048
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldDotInfinity
)
{
const
std
:
:
string
&
floatString
=
"
dot
(
1
.
0e2048
1
.
0
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldDotInfinity2
)
{
const
std
:
:
string
&
floatString
=
"
dot
(
vec2
(
1
.
0e2048
-
1
.
0
)
vec2
(
1
.
0
)
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldFaceForwardInfinity
)
{
const
std
:
:
string
&
floatString
=
"
faceforward
(
4
.
0
1
.
0e2048
1
.
0
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
-
4
.
0f
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldFaceForwardInfinity2
)
{
const
std
:
:
string
&
floatString
=
"
faceforward
(
vec2
(
4
.
0
)
vec2
(
1
.
0e2048
-
1
.
0
)
vec2
(
1
.
0
)
)
.
x
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
-
4
.
0f
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldInfinityMinusFinite
)
{
const
std
:
:
string
&
floatString
=
"
1
.
0e2048
-
1
.
0e20
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldMinusInfinityPlusFinite
)
{
const
std
:
:
string
&
floatString
=
"
(
-
1
.
0e2048
)
+
1
.
0e20
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
-
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldInfinityMultipliedByFinite
)
{
const
std
:
:
string
&
floatString
=
"
1
.
0e2048
*
1
.
0e
-
20
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldInfinityMultipliedByInfinity
)
{
const
std
:
:
string
&
floatString
=
"
1
.
0e2048
*
1
.
0e2048
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldInfinityMultipliedByNegativeInfinity
)
{
const
std
:
:
string
&
floatString
=
"
1
.
0e2048
*
(
-
1
.
0e2048
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
-
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldDivideByNegativeZero
)
{
const
std
:
:
string
&
floatString
=
"
1
.
0
/
(
-
0
.
0
)
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
-
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
ASSERT_TRUE
(
hasWarning
(
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldInfinityDividedByZero
)
{
const
std
:
:
string
&
floatString
=
"
1
.
0e2048
/
0
.
0
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
ASSERT_TRUE
(
hasWarning
(
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldMinusInfinityDividedByZero
)
{
const
std
:
:
string
&
floatString
=
"
(
-
1
.
0e2048
)
/
0
.
0
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
-
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
)
)
;
ASSERT_TRUE
(
hasWarning
(
)
)
;
}
TEST_F
(
ConstantFoldingExpressionTest
FoldDivideByInfinity
)
{
const
std
:
:
string
&
floatString
=
"
1
.
0e30
/
1
.
0e2048
"
;
evaluateFloat
(
floatString
)
;
ASSERT_TRUE
(
constantFoundInAST
(
0
.
0f
)
)
;
}
