#
include
"
test_utils
/
ANGLETest
.
h
"
using
namespace
angle
;
namespace
{
class
TransformFeedbackTest
:
public
ANGLETest
{
protected
:
TransformFeedbackTest
(
)
{
setWindowWidth
(
128
)
;
setWindowHeight
(
128
)
;
setConfigRedBits
(
8
)
;
setConfigGreenBits
(
8
)
;
setConfigBlueBits
(
8
)
;
setConfigAlphaBits
(
8
)
;
}
void
SetUp
(
)
override
{
ANGLETest
:
:
SetUp
(
)
;
const
std
:
:
string
vertexShaderSource
=
SHADER_SOURCE
(
precision
highp
float
;
attribute
vec4
position
;
void
main
(
)
{
gl_Position
=
position
;
}
)
;
const
std
:
:
string
fragmentShaderSource
=
SHADER_SOURCE
(
precision
highp
float
;
void
main
(
)
{
gl_FragColor
=
vec4
(
1
.
0
0
.
0
0
.
0
1
.
0
)
;
}
)
;
mProgram
=
CompileProgram
(
vertexShaderSource
fragmentShaderSource
)
;
if
(
mProgram
=
=
0
)
{
FAIL
(
)
<
<
"
shader
compilation
failed
.
"
;
}
glGenBuffers
(
1
&
mTransformFeedbackBuffer
)
;
mTransformFeedbackBufferSize
=
1
<
<
24
;
glBindBuffer
(
GL_TRANSFORM_FEEDBACK_BUFFER
mTransformFeedbackBuffer
)
;
glBufferData
(
GL_TRANSFORM_FEEDBACK_BUFFER
mTransformFeedbackBufferSize
NULL
GL_STATIC_DRAW
)
;
ASSERT_GL_NO_ERROR
(
)
;
}
void
TearDown
(
)
override
{
glDeleteProgram
(
mProgram
)
;
glDeleteBuffers
(
1
&
mTransformFeedbackBuffer
)
;
ANGLETest
:
:
TearDown
(
)
;
}
GLuint
mProgram
;
size_t
mTransformFeedbackBufferSize
;
GLuint
mTransformFeedbackBuffer
;
}
;
TEST_P
(
TransformFeedbackTest
ZeroSizedViewport
)
{
const
GLchar
*
transformFeedbackVaryings
[
]
=
{
"
gl_Position
"
}
;
glTransformFeedbackVaryings
(
mProgram
ArraySize
(
transformFeedbackVaryings
)
transformFeedbackVaryings
GL_INTERLEAVED_ATTRIBS
)
;
glLinkProgram
(
mProgram
)
;
GLint
linkStatus
;
glGetProgramiv
(
mProgram
GL_LINK_STATUS
&
linkStatus
)
;
ASSERT_NE
(
linkStatus
0
)
;
glUseProgram
(
mProgram
)
;
glBindBufferBase
(
GL_TRANSFORM_FEEDBACK_BUFFER
0
mTransformFeedbackBuffer
)
;
glBeginTransformFeedback
(
GL_TRIANGLES
)
;
GLuint
primitivesWrittenQuery
=
0
;
glGenQueries
(
1
&
primitivesWrittenQuery
)
;
glBeginQuery
(
GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN
primitivesWrittenQuery
)
;
glViewport
(
0
0
0
0
)
;
drawQuad
(
mProgram
"
position
"
0
.
5f
)
;
glEndQuery
(
GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN
)
;
glEndTransformFeedback
(
)
;
GLuint
primitivesWritten
=
0
;
glGetQueryObjectuiv
(
primitivesWrittenQuery
GL_QUERY_RESULT_EXT
&
primitivesWritten
)
;
EXPECT_GL_NO_ERROR
(
)
;
EXPECT_EQ
(
2u
primitivesWritten
)
;
}
TEST_P
(
TransformFeedbackTest
RecordAndDraw
)
{
const
GLchar
*
transformFeedbackVaryings
[
]
=
{
"
gl_Position
"
}
;
glTransformFeedbackVaryings
(
mProgram
ArraySize
(
transformFeedbackVaryings
)
transformFeedbackVaryings
GL_INTERLEAVED_ATTRIBS
)
;
glLinkProgram
(
mProgram
)
;
GLint
linkStatus
;
glGetProgramiv
(
mProgram
GL_LINK_STATUS
&
linkStatus
)
;
ASSERT_NE
(
linkStatus
0
)
;
glUseProgram
(
mProgram
)
;
GLint
positionLocation
=
glGetAttribLocation
(
mProgram
"
position
"
)
;
glEnable
(
GL_RASTERIZER_DISCARD
)
;
const
GLfloat
vertices
[
]
=
{
-
1
.
0f
1
.
0f
0
.
5f
-
1
.
0f
-
1
.
0f
0
.
5f
1
.
0f
-
1
.
0f
0
.
5f
-
1
.
0f
1
.
0f
0
.
5f
1
.
0f
-
1
.
0f
0
.
5f
1
.
0f
1
.
0f
0
.
5f
}
;
glVertexAttribPointer
(
positionLocation
3
GL_FLOAT
GL_FALSE
0
vertices
)
;
glEnableVertexAttribArray
(
positionLocation
)
;
glBindBufferBase
(
GL_TRANSFORM_FEEDBACK_BUFFER
0
mTransformFeedbackBuffer
)
;
glBeginTransformFeedback
(
GL_POINTS
)
;
GLuint
primitivesWrittenQuery
=
0
;
glGenQueries
(
1
&
primitivesWrittenQuery
)
;
glBeginQuery
(
GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN
primitivesWrittenQuery
)
;
glDrawArrays
(
GL_POINTS
0
6
)
;
glDisableVertexAttribArray
(
positionLocation
)
;
glVertexAttribPointer
(
positionLocation
4
GL_FLOAT
GL_FALSE
0
NULL
)
;
glEndQuery
(
GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN
)
;
glEndTransformFeedback
(
)
;
glBindBufferBase
(
GL_TRANSFORM_FEEDBACK_BUFFER
0
0
)
;
glDisable
(
GL_RASTERIZER_DISCARD
)
;
GLuint
primitivesWritten
=
0
;
glGetQueryObjectuiv
(
primitivesWrittenQuery
GL_QUERY_RESULT_EXT
&
primitivesWritten
)
;
EXPECT_GL_NO_ERROR
(
)
;
EXPECT_EQ
(
6u
primitivesWritten
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
0
0
0
0
)
;
glBindBuffer
(
GL_ARRAY_BUFFER
mTransformFeedbackBuffer
)
;
glVertexAttribPointer
(
positionLocation
4
GL_FLOAT
GL_FALSE
0
0
)
;
glEnableVertexAttribArray
(
positionLocation
)
;
glDrawArrays
(
GL_TRIANGLES
0
6
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
255
0
0
255
)
;
EXPECT_GL_NO_ERROR
(
)
;
}
TEST_P
(
TransformFeedbackTest
BufferBinding
)
{
glBindTransformFeedback
(
GL_TRANSFORM_FEEDBACK
0
)
;
glBindBuffer
(
GL_TRANSFORM_FEEDBACK_BUFFER
0
)
;
GLuint
transformFeedbackObject
=
0
;
glGenTransformFeedbacks
(
1
&
transformFeedbackObject
)
;
GLuint
scratchBuffer
=
0
;
glGenBuffers
(
1
&
scratchBuffer
)
;
EXPECT_GL_NO_ERROR
(
)
;
glBindTransformFeedback
(
GL_TRANSFORM_FEEDBACK
0
)
;
glBindBuffer
(
GL_TRANSFORM_FEEDBACK_BUFFER
mTransformFeedbackBuffer
)
;
EXPECT_GL_NO_ERROR
(
)
;
GLint
currentBufferBinding
=
0
;
glGetIntegerv
(
GL_TRANSFORM_FEEDBACK_BUFFER_BINDING
&
currentBufferBinding
)
;
EXPECT_EQ
(
static_cast
<
GLuint
>
(
currentBufferBinding
)
mTransformFeedbackBuffer
)
;
EXPECT_GL_NO_ERROR
(
)
;
glBindTransformFeedback
(
GL_TRANSFORM_FEEDBACK
transformFeedbackObject
)
;
glGetIntegerv
(
GL_TRANSFORM_FEEDBACK_BUFFER_BINDING
&
currentBufferBinding
)
;
EXPECT_EQ
(
0
currentBufferBinding
)
;
EXPECT_GL_NO_ERROR
(
)
;
glBindBufferRange
(
GL_TRANSFORM_FEEDBACK_BUFFER
0
scratchBuffer
0
32
)
;
glGetIntegeri_v
(
GL_TRANSFORM_FEEDBACK_BUFFER_BINDING
0
&
currentBufferBinding
)
;
EXPECT_EQ
(
static_cast
<
GLuint
>
(
currentBufferBinding
)
scratchBuffer
)
;
EXPECT_GL_NO_ERROR
(
)
;
glBindTransformFeedback
(
GL_TRANSFORM_FEEDBACK
0
)
;
glGetIntegeri_v
(
GL_TRANSFORM_FEEDBACK_BUFFER_BINDING
0
&
currentBufferBinding
)
;
EXPECT_EQ
(
0
currentBufferBinding
)
;
EXPECT_GL_NO_ERROR
(
)
;
glDeleteTransformFeedbacks
(
1
&
transformFeedbackObject
)
;
glDeleteBuffers
(
1
&
scratchBuffer
)
;
}
ANGLE_INSTANTIATE_TEST
(
TransformFeedbackTest
ES3_D3D11
(
)
)
;
}
