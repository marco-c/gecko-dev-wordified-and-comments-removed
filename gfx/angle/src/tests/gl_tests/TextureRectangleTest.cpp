#
include
"
test_utils
/
ANGLETest
.
h
"
#
include
"
test_utils
/
gl_raii
.
h
"
using
namespace
angle
;
namespace
{
class
TextureRectangleTest
:
public
ANGLETest
{
protected
:
TextureRectangleTest
(
)
{
setWindowWidth
(
64
)
;
setWindowHeight
(
64
)
;
setConfigRedBits
(
8
)
;
setConfigGreenBits
(
8
)
;
setConfigBlueBits
(
8
)
;
setConfigAlphaBits
(
8
)
;
}
bool
checkExtensionSupported
(
)
const
{
if
(
!
extensionEnabled
(
"
GL_ANGLE_texture_rectangle
"
)
)
{
std
:
:
cout
<
<
"
Test
skipped
because
GL_ANGLE_texture_rectangle
is
not
available
.
"
<
<
std
:
:
endl
;
return
false
;
}
return
true
;
}
}
;
class
TextureRectangleTestES3
:
public
TextureRectangleTest
{
}
;
class
TextureRectangleTestES31
:
public
TextureRectangleTest
{
}
;
TEST_P
(
TextureRectangleTest
TexImage2D
)
{
ANGLE_SKIP_TEST_IF
(
!
checkExtensionSupported
(
)
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_RECTANGLE_ANGLE
tex
)
;
glTexImage2D
(
GL_TEXTURE_RECTANGLE_ANGLE
0
GL_RGBA
16
16
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
ASSERT_GL_NO_ERROR
(
)
;
glTexImage2D
(
GL_TEXTURE_RECTANGLE_ANGLE
1
GL_RGBA
16
16
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
ASSERT_GL_ERROR
(
GL_INVALID_VALUE
)
;
GLint
maxSize
=
0
;
glGetIntegerv
(
GL_MAX_RECTANGLE_TEXTURE_SIZE_ANGLE
&
maxSize
)
;
{
ScopedIgnorePlatformMessages
ignore
(
this
)
;
glTexImage2D
(
GL_TEXTURE_RECTANGLE_ANGLE
0
GL_RGBA
maxSize
maxSize
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
GLenum
error
=
glGetError
(
)
;
ASSERT_TRUE
(
error
=
=
GL_NO_ERROR
|
|
error
=
=
GL_OUT_OF_MEMORY
)
;
}
glTexImage2D
(
GL_TEXTURE_RECTANGLE_ANGLE
0
GL_RGBA
maxSize
+
1
maxSize
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
ASSERT_GL_ERROR
(
GL_INVALID_VALUE
)
;
glTexImage2D
(
GL_TEXTURE_RECTANGLE_ANGLE
0
GL_RGBA
maxSize
maxSize
+
1
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
ASSERT_GL_ERROR
(
GL_INVALID_VALUE
)
;
}
TEST_P
(
TextureRectangleTest
CompressedTexImage2DDisallowed
)
{
ANGLE_SKIP_TEST_IF
(
!
checkExtensionSupported
(
)
)
;
ANGLE_SKIP_TEST_IF
(
!
extensionEnabled
(
"
GL_EXT_texture_compression_dxt1
"
)
)
;
const
char
data
[
128
]
=
{
0
}
;
{
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_2D
tex
)
;
glCompressedTexImage2D
(
GL_TEXTURE_2D
0
GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
16
16
0
128
data
)
;
ASSERT_GL_NO_ERROR
(
)
;
}
{
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_RECTANGLE_ANGLE
tex
)
;
glCompressedTexImage2D
(
GL_TEXTURE_RECTANGLE_ANGLE
0
GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
16
16
0
128
data
)
;
ASSERT_GL_ERROR
(
GL_INVALID_ENUM
)
;
}
}
TEST_P
(
TextureRectangleTest
TexStorage2D
)
{
ANGLE_SKIP_TEST_IF
(
!
checkExtensionSupported
(
)
)
;
ANGLE_SKIP_TEST_IF
(
getClientMajorVersion
(
)
<
3
&
&
!
extensionEnabled
(
"
GL_EXT_texture_storage
"
)
)
;
bool
useES3
=
getClientMajorVersion
(
)
>
=
3
;
auto
TexStorage2D
=
[
useES3
]
(
GLenum
target
GLint
levels
GLenum
format
GLint
width
GLint
height
)
{
if
(
useES3
)
{
glTexStorage2D
(
target
levels
format
width
height
)
;
}
else
{
glTexStorage2DEXT
(
target
levels
format
width
height
)
;
}
}
;
{
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_RECTANGLE_ANGLE
tex
)
;
TexStorage2D
(
GL_TEXTURE_RECTANGLE_ANGLE
1
GL_RGBA8UI
16
16
)
;
ASSERT_GL_NO_ERROR
(
)
;
}
{
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_RECTANGLE_ANGLE
tex
)
;
TexStorage2D
(
GL_TEXTURE_RECTANGLE_ANGLE
5
GL_RGBA8UI
16
16
)
;
ASSERT_GL_ERROR
(
GL_INVALID_VALUE
)
;
}
GLint
maxSize
=
0
;
glGetIntegerv
(
GL_MAX_RECTANGLE_TEXTURE_SIZE_ANGLE
&
maxSize
)
;
{
ScopedIgnorePlatformMessages
ignore
(
this
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_RECTANGLE_ANGLE
tex
)
;
TexStorage2D
(
GL_TEXTURE_RECTANGLE_ANGLE
1
GL_RGBA8UI
maxSize
maxSize
)
;
GLenum
error
=
glGetError
(
)
;
ASSERT_TRUE
(
error
=
=
GL_NO_ERROR
|
|
error
=
=
GL_OUT_OF_MEMORY
)
;
}
{
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_RECTANGLE_ANGLE
tex
)
;
TexStorage2D
(
GL_TEXTURE_RECTANGLE_ANGLE
1
GL_RGBA8UI
maxSize
+
1
maxSize
)
;
ASSERT_GL_ERROR
(
GL_INVALID_VALUE
)
;
TexStorage2D
(
GL_TEXTURE_RECTANGLE_ANGLE
1
GL_RGBA8UI
maxSize
maxSize
+
1
)
;
ASSERT_GL_ERROR
(
GL_INVALID_VALUE
)
;
}
if
(
extensionEnabled
(
"
GL_EXT_texture_compression_dxt1
"
)
)
{
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_RECTANGLE_ANGLE
tex
)
;
TexStorage2D
(
GL_TEXTURE_RECTANGLE_ANGLE
1
GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
16
16
)
;
ASSERT_GL_ERROR
(
GL_INVALID_ENUM
)
;
}
}
TEST_P
(
TextureRectangleTest
TexParameterRestriction
)
{
ANGLE_SKIP_TEST_IF
(
!
checkExtensionSupported
(
)
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_RECTANGLE_ANGLE
tex
)
;
glTexParameteri
(
GL_TEXTURE_RECTANGLE_ANGLE
GL_TEXTURE_WRAP_S
GL_CLAMP_TO_EDGE
)
;
ASSERT_GL_NO_ERROR
(
)
;
glTexParameteri
(
GL_TEXTURE_RECTANGLE_ANGLE
GL_TEXTURE_WRAP_S
GL_REPEAT
)
;
ASSERT_GL_ERROR
(
GL_INVALID_ENUM
)
;
glTexParameteri
(
GL_TEXTURE_RECTANGLE_ANGLE
GL_TEXTURE_WRAP_S
GL_MIRRORED_REPEAT
)
;
ASSERT_GL_ERROR
(
GL_INVALID_ENUM
)
;
glTexParameteri
(
GL_TEXTURE_RECTANGLE_ANGLE
GL_TEXTURE_WRAP_T
GL_CLAMP_TO_EDGE
)
;
ASSERT_GL_NO_ERROR
(
)
;
glTexParameteri
(
GL_TEXTURE_RECTANGLE_ANGLE
GL_TEXTURE_WRAP_T
GL_REPEAT
)
;
ASSERT_GL_ERROR
(
GL_INVALID_ENUM
)
;
glTexParameteri
(
GL_TEXTURE_RECTANGLE_ANGLE
GL_TEXTURE_WRAP_T
GL_MIRRORED_REPEAT
)
;
ASSERT_GL_ERROR
(
GL_INVALID_ENUM
)
;
glTexParameteri
(
GL_TEXTURE_RECTANGLE_ANGLE
GL_TEXTURE_MIN_FILTER
GL_NEAREST
)
;
ASSERT_GL_NO_ERROR
(
)
;
glTexParameteri
(
GL_TEXTURE_RECTANGLE_ANGLE
GL_TEXTURE_MIN_FILTER
GL_LINEAR
)
;
ASSERT_GL_NO_ERROR
(
)
;
glTexParameteri
(
GL_TEXTURE_RECTANGLE_ANGLE
GL_TEXTURE_MIN_FILTER
GL_NEAREST_MIPMAP_NEAREST
)
;
ASSERT_GL_ERROR
(
GL_INVALID_ENUM
)
;
glTexParameteri
(
GL_TEXTURE_RECTANGLE_ANGLE
GL_TEXTURE_MIN_FILTER
GL_NEAREST_MIPMAP_LINEAR
)
;
ASSERT_GL_ERROR
(
GL_INVALID_ENUM
)
;
glTexParameteri
(
GL_TEXTURE_RECTANGLE_ANGLE
GL_TEXTURE_MIN_FILTER
GL_LINEAR_MIPMAP_NEAREST
)
;
ASSERT_GL_ERROR
(
GL_INVALID_ENUM
)
;
glTexParameteri
(
GL_TEXTURE_RECTANGLE_ANGLE
GL_TEXTURE_MIN_FILTER
GL_LINEAR_MIPMAP_LINEAR
)
;
ASSERT_GL_ERROR
(
GL_INVALID_ENUM
)
;
if
(
getClientMajorVersion
(
)
>
=
3
)
{
glTexParameteri
(
GL_TEXTURE_RECTANGLE_ANGLE
GL_TEXTURE_BASE_LEVEL
0
)
;
ASSERT_GL_NO_ERROR
(
)
;
glTexParameteri
(
GL_TEXTURE_RECTANGLE_ANGLE
GL_TEXTURE_BASE_LEVEL
1
)
;
ASSERT_GL_ERROR
(
GL_INVALID_OPERATION
)
;
}
}
TEST_P
(
TextureRectangleTestES31
GetTexLevelParameter
)
{
ANGLE_SKIP_TEST_IF
(
!
checkExtensionSupported
(
)
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_RECTANGLE_ANGLE
tex
)
;
glTexImage2D
(
GL_TEXTURE_RECTANGLE_ANGLE
0
GL_RGBA
16
16
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
ASSERT_GL_NO_ERROR
(
)
;
GLint
param
;
glGetTexLevelParameteriv
(
GL_TEXTURE_RECTANGLE_ANGLE
0
GL_TEXTURE_INTERNAL_FORMAT
&
param
)
;
ASSERT_GL_NO_ERROR
(
)
;
glGetTexLevelParameteriv
(
GL_TEXTURE_RECTANGLE_ANGLE
1
GL_TEXTURE_INTERNAL_FORMAT
&
param
)
;
ASSERT_GL_ERROR
(
GL_INVALID_VALUE
)
;
}
TEST_P
(
TextureRectangleTest
FramebufferTexture2DLevel
)
{
ANGLE_SKIP_TEST_IF
(
!
checkExtensionSupported
(
)
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_RECTANGLE_ANGLE
tex
)
;
glTexImage2D
(
GL_TEXTURE_RECTANGLE_ANGLE
0
GL_RGBA
16
16
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
ASSERT_GL_NO_ERROR
(
)
;
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
glFramebufferTexture2D
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_TEXTURE_RECTANGLE_ANGLE
tex
0
)
;
EXPECT_GLENUM_EQ
(
GL_FRAMEBUFFER_COMPLETE
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
ASSERT_GL_NO_ERROR
(
)
;
glFramebufferTexture2D
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_TEXTURE_RECTANGLE_ANGLE
tex
1
)
;
ASSERT_GL_ERROR
(
GL_INVALID_VALUE
)
;
}
TEST_P
(
TextureRectangleTest
SamplingFromRectangle
)
{
ANGLE_SKIP_TEST_IF
(
!
checkExtensionSupported
(
)
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_RECTANGLE_ANGLE
tex
)
;
glTexImage2D
(
GL_TEXTURE_RECTANGLE_ANGLE
0
GL_RGBA
1
1
0
GL_RGBA
GL_UNSIGNED_BYTE
&
GLColor
:
:
green
)
;
const
std
:
:
string
vs
=
"
attribute
vec4
position
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
gl_Position
=
vec4
(
position
.
xy
0
.
0
1
.
0
)
;
\
n
"
"
}
\
n
"
;
const
std
:
:
string
fs
=
"
#
extension
GL_ARB_texture_rectangle
:
require
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
sampler2DRect
tex
;
\
n
"
"
void
main
(
)
\
n
"
"
{
\
n
"
"
gl_FragColor
=
texture2DRect
(
tex
vec2
(
0
0
)
)
;
\
n
"
"
}
\
n
"
;
ANGLE_GL_PROGRAM
(
program
vs
fs
)
;
glClearColor
(
0
.
0
0
.
0
0
.
0
0
.
0
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
drawQuad
(
program
"
position
"
0
.
5f
1
.
0f
false
)
;
EXPECT_PIXEL_COLOR_EQ
(
0
0
GLColor
:
:
green
)
;
ASSERT_GL_NO_ERROR
(
)
;
}
TEST_P
(
TextureRectangleTest
RenderToRectangle
)
{
ANGLE_SKIP_TEST_IF
(
!
checkExtensionSupported
(
)
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_RECTANGLE_ANGLE
tex
)
;
glTexImage2D
(
GL_TEXTURE_RECTANGLE_ANGLE
0
GL_RGBA
1
1
0
GL_RGBA
GL_UNSIGNED_BYTE
&
GLColor
:
:
black
)
;
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
glFramebufferTexture2D
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_TEXTURE_RECTANGLE_ANGLE
tex
0
)
;
EXPECT_GLENUM_EQ
(
GL_FRAMEBUFFER_COMPLETE
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
ASSERT_GL_NO_ERROR
(
)
;
glClearColor
(
0
.
0
1
.
0
0
.
0
1
.
0
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
EXPECT_PIXEL_COLOR_EQ
(
0
0
GLColor
:
:
green
)
;
ASSERT_GL_NO_ERROR
(
)
;
}
TEST_P
(
TextureRectangleTestES3
CopyTexImage
)
{
ANGLE_SKIP_TEST_IF
(
!
checkExtensionSupported
(
)
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_RECTANGLE_ANGLE
tex
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
0
)
;
glClearColor
(
0
1
0
1
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
ASSERT_GL_NO_ERROR
(
)
;
glCopyTexImage2D
(
GL_TEXTURE_RECTANGLE_ANGLE
1
GL_RGBA8
0
0
1
1
0
)
;
ASSERT_GL_ERROR
(
GL_INVALID_VALUE
)
;
glCopyTexImage2D
(
GL_TEXTURE_RECTANGLE_ANGLE
0
GL_RGBA8
0
0
1
1
0
)
;
ASSERT_GL_NO_ERROR
(
)
;
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
glFramebufferTexture2D
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_TEXTURE_RECTANGLE_ANGLE
tex
0
)
;
EXPECT_PIXEL_COLOR_EQ
(
0
0
GLColor
:
:
green
)
;
ASSERT_GL_NO_ERROR
(
)
;
}
TEST_P
(
TextureRectangleTestES3
CopyTexSubImage
)
{
ANGLE_SKIP_TEST_IF
(
!
checkExtensionSupported
(
)
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_RECTANGLE_ANGLE
tex
)
;
glTexImage2D
(
GL_TEXTURE_RECTANGLE_ANGLE
0
GL_RGBA
1
1
0
GL_RGBA
GL_UNSIGNED_BYTE
&
GLColor
:
:
black
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
0
)
;
glClearColor
(
0
1
0
1
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
ASSERT_GL_NO_ERROR
(
)
;
glCopyTexSubImage2D
(
GL_TEXTURE_RECTANGLE_ANGLE
1
0
0
0
0
1
1
)
;
ASSERT_GL_ERROR
(
GL_INVALID_VALUE
)
;
glCopyTexSubImage2D
(
GL_TEXTURE_RECTANGLE_ANGLE
0
0
0
0
0
1
1
)
;
ASSERT_GL_NO_ERROR
(
)
;
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
glFramebufferTexture2D
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_TEXTURE_RECTANGLE_ANGLE
tex
0
)
;
EXPECT_PIXEL_COLOR_EQ
(
0
0
GLColor
:
:
green
)
;
ASSERT_GL_NO_ERROR
(
)
;
}
ANGLE_INSTANTIATE_TEST
(
TextureRectangleTest
ES2_OPENGL
(
)
ES3_OPENGL
(
)
)
;
ANGLE_INSTANTIATE_TEST
(
TextureRectangleTestES3
ES3_OPENGL
(
)
)
;
ANGLE_INSTANTIATE_TEST
(
TextureRectangleTestES31
ES31_OPENGL
(
)
)
;
}
