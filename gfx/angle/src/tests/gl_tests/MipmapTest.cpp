#
include
"
test_utils
/
ANGLETest
.
h
"
using
namespace
angle
;
class
MipmapTest
:
public
ANGLETest
{
protected
:
MipmapTest
(
)
{
setWindowWidth
(
128
)
;
setWindowHeight
(
128
)
;
setConfigRedBits
(
8
)
;
setConfigGreenBits
(
8
)
;
setConfigBlueBits
(
8
)
;
setConfigAlphaBits
(
8
)
;
}
virtual
void
SetUp
(
)
{
ANGLETest
:
:
SetUp
(
)
;
const
std
:
:
string
vs
=
SHADER_SOURCE
(
attribute
vec4
aPosition
;
attribute
vec2
aTexCoord
;
varying
vec2
vTexCoord
;
void
main
(
)
{
gl_Position
=
aPosition
;
vTexCoord
=
aTexCoord
;
}
)
;
const
std
:
:
string
fs
=
SHADER_SOURCE
(
precision
mediump
float
;
uniform
sampler2D
uTexture
;
varying
vec2
vTexCoord
;
void
main
(
)
{
gl_FragColor
=
texture2D
(
uTexture
vTexCoord
)
;
}
)
;
m2DProgram
=
CompileProgram
(
vs
fs
)
;
if
(
m2DProgram
=
=
0
)
{
FAIL
(
)
<
<
"
shader
compilation
failed
.
"
;
}
const
std
:
:
string
cubeVS
=
SHADER_SOURCE
(
attribute
vec4
aPosition
;
varying
vec4
vPosition
;
void
main
(
)
{
gl_Position
=
aPosition
;
vPosition
=
aPosition
;
}
)
;
const
std
:
:
string
cubeFS
=
SHADER_SOURCE
(
precision
mediump
float
;
uniform
samplerCube
uTexture
;
varying
vec4
vPosition
;
void
main
(
)
{
gl_FragColor
=
textureCube
(
uTexture
vec3
(
vPosition
.
x
-
1
vPosition
.
y
)
)
;
}
)
;
mCubeProgram
=
CompileProgram
(
cubeVS
cubeFS
)
;
if
(
mCubeProgram
=
=
0
)
{
FAIL
(
)
<
<
"
shader
compilation
failed
.
"
;
}
m2DTextureUniformPosition
=
glGetUniformLocation
(
m2DProgram
"
uTexture
"
)
;
m2DPositionAttributePosition
=
glGetAttribLocation
(
m2DProgram
"
aPosition
"
)
;
m2DTexCoordAttributePosition
=
glGetAttribLocation
(
m2DProgram
"
aTexCoord
"
)
;
mCubeTextureUniformPosition
=
glGetUniformLocation
(
mCubeProgram
"
uTexture
"
)
;
mCubePositionAttributePosition
=
glGetAttribLocation
(
mCubeProgram
"
aPosition
"
)
;
mLevelZeroBlueInitData
=
createRGBInitData
(
getWindowWidth
(
)
getWindowHeight
(
)
0
0
255
)
;
mLevelZeroWhiteInitData
=
createRGBInitData
(
getWindowWidth
(
)
getWindowHeight
(
)
255
255
255
)
;
mLevelOneInitData
=
createRGBInitData
(
(
getWindowWidth
(
)
/
2
)
(
getWindowHeight
(
)
/
2
)
0
255
0
)
;
mLevelTwoInitData
=
createRGBInitData
(
(
getWindowWidth
(
)
/
4
)
(
getWindowHeight
(
)
/
4
)
255
0
0
)
;
glGenFramebuffers
(
1
&
mOffscreenFramebuffer
)
;
glGenTextures
(
1
&
mOffscreenTexture2D
)
;
glBindTexture
(
GL_TEXTURE_2D
mOffscreenTexture2D
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGB
getWindowWidth
(
)
getWindowHeight
(
)
0
GL_RGB
GL_UNSIGNED_BYTE
NULL
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MAG_FILTER
GL_LINEAR
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_LINEAR
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mOffscreenFramebuffer
)
;
glFramebufferTexture2D
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_TEXTURE_2D
mOffscreenTexture2D
0
)
;
ASSERT_GLENUM_EQ
(
GL_FRAMEBUFFER_COMPLETE
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
glGenTextures
(
1
&
mOffscreenTextureCube
)
;
glBindTexture
(
GL_TEXTURE_CUBE_MAP
mOffscreenTextureCube
)
;
glTexImage2D
(
GL_TEXTURE_CUBE_MAP_POSITIVE_X
0
GL_RGB
getWindowWidth
(
)
getWindowHeight
(
)
0
GL_RGB
GL_UNSIGNED_BYTE
NULL
)
;
glTexImage2D
(
GL_TEXTURE_CUBE_MAP_NEGATIVE_X
0
GL_RGB
getWindowWidth
(
)
getWindowHeight
(
)
0
GL_RGB
GL_UNSIGNED_BYTE
NULL
)
;
glTexImage2D
(
GL_TEXTURE_CUBE_MAP_POSITIVE_Y
0
GL_RGB
getWindowWidth
(
)
getWindowHeight
(
)
0
GL_RGB
GL_UNSIGNED_BYTE
NULL
)
;
glTexImage2D
(
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
0
GL_RGB
getWindowWidth
(
)
getWindowHeight
(
)
0
GL_RGB
GL_UNSIGNED_BYTE
mLevelZeroBlueInitData
)
;
glTexImage2D
(
GL_TEXTURE_CUBE_MAP_POSITIVE_Z
0
GL_RGB
getWindowWidth
(
)
getWindowHeight
(
)
0
GL_RGB
GL_UNSIGNED_BYTE
NULL
)
;
glTexImage2D
(
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
0
GL_RGB
getWindowWidth
(
)
getWindowHeight
(
)
0
GL_RGB
GL_UNSIGNED_BYTE
NULL
)
;
glTexParameteri
(
GL_TEXTURE_CUBE_MAP
GL_TEXTURE_MAG_FILTER
GL_NEAREST
)
;
glTexParameteri
(
GL_TEXTURE_CUBE_MAP
GL_TEXTURE_MIN_FILTER
GL_NEAREST
)
;
ASSERT_GL_NO_ERROR
(
)
;
}
virtual
void
TearDown
(
)
{
glDeleteProgram
(
m2DProgram
)
;
glDeleteProgram
(
mCubeProgram
)
;
glDeleteFramebuffers
(
1
&
mOffscreenFramebuffer
)
;
glDeleteTextures
(
1
&
mOffscreenTexture2D
)
;
glDeleteTextures
(
1
&
mOffscreenTextureCube
)
;
SafeDeleteArray
(
mLevelZeroBlueInitData
)
;
SafeDeleteArray
(
mLevelZeroWhiteInitData
)
;
SafeDeleteArray
(
mLevelOneInitData
)
;
SafeDeleteArray
(
mLevelTwoInitData
)
;
ANGLETest
:
:
TearDown
(
)
;
}
GLubyte
*
createRGBInitData
(
GLint
width
GLint
height
GLint
r
GLint
g
GLint
b
)
{
GLubyte
*
data
=
new
GLubyte
[
3
*
width
*
height
]
;
for
(
int
i
=
0
;
i
<
width
*
height
;
i
+
=
1
)
{
data
[
3
*
i
+
0
]
=
static_cast
<
GLubyte
>
(
r
)
;
data
[
3
*
i
+
1
]
=
static_cast
<
GLubyte
>
(
g
)
;
data
[
3
*
i
+
2
]
=
static_cast
<
GLubyte
>
(
b
)
;
}
return
data
;
}
void
ClearAndDrawTexturedQuad
(
GLuint
texture
GLsizei
viewportWidth
GLsizei
viewportHeight
)
{
glBindFramebuffer
(
GL_FRAMEBUFFER
0
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glViewport
(
0
0
viewportWidth
viewportHeight
)
;
ASSERT_GL_NO_ERROR
(
)
;
GLfloat
vertexLocations
[
]
=
{
-
1
.
0f
1
.
0f
0
.
0f
-
1
.
0f
-
1
.
0f
0
.
0f
1
.
0f
1
.
0f
0
.
0f
1
.
0f
-
1
.
0f
0
.
0f
}
;
GLfloat
vertexTexCoords
[
]
=
{
0
.
0f
1
.
0f
0
.
0f
0
.
0f
1
.
0f
1
.
0f
1
.
0f
0
.
0f
}
;
glUseProgram
(
m2DProgram
)
;
glActiveTexture
(
GL_TEXTURE0
)
;
glBindTexture
(
GL_TEXTURE_2D
texture
)
;
glUniform1i
(
m2DTextureUniformPosition
0
)
;
glVertexAttribPointer
(
m2DPositionAttributePosition
3
GL_FLOAT
GL_FALSE
0
vertexLocations
)
;
glEnableVertexAttribArray
(
m2DPositionAttributePosition
)
;
glVertexAttribPointer
(
m2DTexCoordAttributePosition
2
GL_FLOAT
GL_FALSE
0
vertexTexCoords
)
;
glEnableVertexAttribArray
(
m2DTexCoordAttributePosition
)
;
glDrawArrays
(
GL_TRIANGLE_STRIP
0
4
)
;
}
GLuint
m2DProgram
;
GLuint
mCubeProgram
;
GLuint
mOffscreenFramebuffer
;
GLuint
mOffscreenTexture2D
;
GLuint
mOffscreenTextureCube
;
GLint
m2DTextureUniformPosition
;
GLint
m2DPositionAttributePosition
;
GLint
m2DTexCoordAttributePosition
;
GLint
mCubeTextureUniformPosition
;
GLint
mCubePositionAttributePosition
;
GLubyte
*
mLevelZeroBlueInitData
;
GLubyte
*
mLevelZeroWhiteInitData
;
GLubyte
*
mLevelOneInitData
;
GLubyte
*
mLevelTwoInitData
;
}
;
class
MipmapTestES3
:
public
ANGLETest
{
protected
:
MipmapTestES3
(
)
{
setWindowWidth
(
128
)
;
setWindowHeight
(
128
)
;
setConfigRedBits
(
8
)
;
setConfigGreenBits
(
8
)
;
setConfigBlueBits
(
8
)
;
setConfigAlphaBits
(
8
)
;
}
virtual
void
SetUp
(
)
{
ANGLETest
:
:
SetUp
(
)
;
glGenTextures
(
1
&
mTextureArray
)
;
EXPECT_GL_NO_ERROR
(
)
;
ASSERT_GL_NO_ERROR
(
)
;
const
std
:
:
string
vertexShaderSource
=
SHADER_SOURCE
(
#
version
300
es
\
n
precision
highp
float
;
in
vec4
position
;
out
vec2
texcoord
;
uniform
vec2
textureScale
;
void
main
(
)
{
gl_Position
=
vec4
(
position
.
xy
*
textureScale
0
.
0
1
.
0
)
;
texcoord
=
(
position
.
xy
*
0
.
5
)
+
0
.
5
;
}
)
;
const
std
:
:
string
fragmentShaderSourceArray
=
SHADER_SOURCE
(
#
version
300
es
\
n
precision
highp
float
;
uniform
highp
sampler2DArray
tex
;
uniform
int
slice
;
in
vec2
texcoord
;
out
vec4
out_FragColor
;
void
main
(
)
{
out_FragColor
=
texture
(
tex
vec3
(
texcoord
float
(
slice
)
)
)
;
}
)
;
mArrayProgram
=
CompileProgram
(
vertexShaderSource
fragmentShaderSourceArray
)
;
if
(
mArrayProgram
=
=
0
)
{
FAIL
(
)
<
<
"
shader
compilation
failed
.
"
;
}
mTextureArrayUniformLocation
=
glGetUniformLocation
(
mArrayProgram
"
tex
"
)
;
ASSERT_NE
(
-
1
mTextureArrayUniformLocation
)
;
mTextureArrayScaleUniformLocation
=
glGetUniformLocation
(
mArrayProgram
"
textureScale
"
)
;
ASSERT_NE
(
-
1
mTextureArrayScaleUniformLocation
)
;
mTextureArraySliceUniformLocation
=
glGetUniformLocation
(
mArrayProgram
"
slice
"
)
;
ASSERT_NE
(
-
1
mTextureArraySliceUniformLocation
)
;
glUseProgram
(
mArrayProgram
)
;
glUniform2f
(
mTextureArrayScaleUniformLocation
1
.
0f
1
.
0f
)
;
glUseProgram
(
0
)
;
ASSERT_GL_NO_ERROR
(
)
;
glGenTextures
(
1
&
mTexture3D
)
;
ASSERT_GL_NO_ERROR
(
)
;
const
std
:
:
string
fragmentShaderSource3D
=
SHADER_SOURCE
(
#
version
300
es
\
n
precision
highp
float
;
uniform
highp
sampler3D
tex
;
uniform
float
slice
;
uniform
float
lod
;
in
vec2
texcoord
;
out
vec4
out_FragColor
;
void
main
(
)
{
out_FragColor
=
textureLod
(
tex
vec3
(
texcoord
slice
)
lod
)
;
}
)
;
m3DProgram
=
CompileProgram
(
vertexShaderSource
fragmentShaderSource3D
)
;
if
(
m3DProgram
=
=
0
)
{
FAIL
(
)
<
<
"
shader
compilation
failed
.
"
;
}
mTexture3DUniformLocation
=
glGetUniformLocation
(
m3DProgram
"
tex
"
)
;
ASSERT_NE
(
-
1
mTexture3DUniformLocation
)
;
mTexture3DScaleUniformLocation
=
glGetUniformLocation
(
m3DProgram
"
textureScale
"
)
;
ASSERT_NE
(
-
1
mTexture3DScaleUniformLocation
)
;
mTexture3DSliceUniformLocation
=
glGetUniformLocation
(
m3DProgram
"
slice
"
)
;
ASSERT_NE
(
-
1
mTexture3DSliceUniformLocation
)
;
mTexture3DLODUniformLocation
=
glGetUniformLocation
(
m3DProgram
"
lod
"
)
;
ASSERT_NE
(
-
1
mTexture3DLODUniformLocation
)
;
glUseProgram
(
m3DProgram
)
;
glUniform2f
(
mTexture3DScaleUniformLocation
1
.
0f
1
.
0f
)
;
glUniform1f
(
mTexture3DLODUniformLocation
0
)
;
glUseProgram
(
0
)
;
ASSERT_GL_NO_ERROR
(
)
;
}
virtual
void
TearDown
(
)
{
glDeleteTextures
(
1
&
mTextureArray
)
;
glDeleteProgram
(
mArrayProgram
)
;
glDeleteTextures
(
1
&
mTexture3D
)
;
glDeleteProgram
(
m3DProgram
)
;
ANGLETest
:
:
TearDown
(
)
;
}
GLuint
mTextureArray
;
GLuint
mTexture3D
;
GLuint
mArrayProgram
;
GLint
mTextureArrayUniformLocation
;
GLint
mTextureArrayScaleUniformLocation
;
GLint
mTextureArraySliceUniformLocation
;
GLuint
m3DProgram
;
GLint
mTexture3DUniformLocation
;
GLint
mTexture3DScaleUniformLocation
;
GLint
mTexture3DSliceUniformLocation
;
GLint
mTexture3DLODUniformLocation
;
}
;
TEST_P
(
MipmapTest
DISABLED_ThreeLevelsInitData
)
{
glBindTexture
(
GL_TEXTURE_2D
mOffscreenTexture2D
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGB
getWindowWidth
(
)
getWindowHeight
(
)
0
GL_RGB
GL_UNSIGNED_BYTE
mLevelZeroBlueInitData
)
;
ASSERT_GL_NO_ERROR
(
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_NEAREST
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
0
0
255
255
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
0
0
255
255
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
0
0
255
255
)
;
int
n
=
1
;
while
(
getWindowWidth
(
)
/
(
1U
<
<
n
)
>
=
1
)
{
glTexImage2D
(
GL_TEXTURE_2D
n
GL_RGB
getWindowWidth
(
)
/
(
1U
<
<
n
)
getWindowWidth
(
)
/
(
1U
<
<
n
)
0
GL_RGB
GL_UNSIGNED_BYTE
NULL
)
;
ASSERT_GL_NO_ERROR
(
)
;
n
+
=
1
;
}
glTexImage2D
(
GL_TEXTURE_2D
1
GL_RGB
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
0
GL_RGB
GL_UNSIGNED_BYTE
mLevelOneInitData
)
;
ASSERT_GL_NO_ERROR
(
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
0
0
255
255
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
0
0
255
255
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_LINEAR_MIPMAP_NEAREST
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
0
255
0
255
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
0
0
0
255
)
;
glTexImage2D
(
GL_TEXTURE_2D
2
GL_RGB
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
0
GL_RGB
GL_UNSIGNED_BYTE
mLevelTwoInitData
)
;
ASSERT_GL_NO_ERROR
(
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
0
0
255
255
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
0
255
0
255
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
255
0
0
255
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_NEAREST
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
0
0
255
255
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
0
0
255
255
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
0
0
255
255
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGB
getWindowWidth
(
)
getWindowHeight
(
)
0
GL_RGB
GL_UNSIGNED_BYTE
mLevelZeroWhiteInitData
)
;
ASSERT_GL_NO_ERROR
(
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
255
255
255
255
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
255
255
255
255
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
255
255
255
255
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_LINEAR_MIPMAP_NEAREST
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
255
255
255
255
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
0
255
0
255
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
255
0
0
255
)
;
}
TEST_P
(
MipmapTest
GenerateMipmapFromInitDataThenRender
)
{
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGB
getWindowWidth
(
)
getWindowHeight
(
)
0
GL_RGB
GL_UNSIGNED_BYTE
mLevelZeroBlueInitData
)
;
glGenerateMipmap
(
GL_TEXTURE_2D
)
;
ASSERT_GL_NO_ERROR
(
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_LINEAR_MIPMAP_NEAREST
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
0
0
255
255
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
0
0
255
255
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
0
0
255
255
)
;
ASSERT_GL_NO_ERROR
(
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_NEAREST
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
0
0
255
255
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mOffscreenFramebuffer
)
;
glClearColor
(
1
.
0f
0
.
0f
0
.
0f
1
.
0f
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_LINEAR_MIPMAP_NEAREST
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
255
0
0
255
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
0
0
255
255
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
0
0
255
255
)
;
}
TEST_P
(
MipmapTest
GenerateMipmapFromRenderedImage
)
{
glBindFramebuffer
(
GL_FRAMEBUFFER
mOffscreenFramebuffer
)
;
glClearColor
(
0
.
0f
0
.
0f
1
.
0f
1
.
0f
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glGenerateMipmap
(
GL_TEXTURE_2D
)
;
ASSERT_GL_NO_ERROR
(
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_LINEAR_MIPMAP_NEAREST
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
0
0
255
255
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
0
0
255
255
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
0
0
255
255
)
;
}
TEST_P
(
MipmapTest
RenderOntoLevelZeroAfterGenerateMipmap
)
{
if
(
(
isAMD
(
)
|
|
isIntel
(
)
)
&
&
getPlatformRenderer
(
)
=
=
EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE
)
{
std
:
:
cout
<
<
"
Test
skipped
on
Intel
/
AMD
OpenGL
.
"
<
<
std
:
:
endl
;
return
;
}
glBindFramebuffer
(
GL_FRAMEBUFFER
mOffscreenFramebuffer
)
;
glClearColor
(
0
.
0f
0
.
0f
1
.
0f
1
.
0f
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glClearColor
(
0
.
0f
0
.
0f
0
.
0f
1
.
0f
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
0
0
255
255
)
;
glGenerateMipmap
(
GL_TEXTURE_2D
)
;
ASSERT_GL_NO_ERROR
(
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
0
0
255
255
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_LINEAR_MIPMAP_NEAREST
)
;
EXPECT_GL_NO_ERROR
(
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
0
0
255
255
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
0
0
255
255
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mOffscreenFramebuffer
)
;
glClearColor
(
0
.
0f
1
.
0f
0
.
0f
1
.
0f
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glClearColor
(
0
.
0f
0
.
0f
0
.
0f
1
.
0f
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
0
255
0
255
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
0
0
255
255
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_LINEAR
)
;
ASSERT_GL_NO_ERROR
(
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
0
255
0
255
)
;
ClearAndDrawTexturedQuad
(
mOffscreenTexture2D
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
0
255
0
255
)
;
}
TEST_P
(
MipmapTest
TextureCubeGeneralLevelZero
)
{
GLfloat
vertexLocations
[
]
=
{
-
1
.
0f
1
.
0f
0
.
0f
-
1
.
0f
-
1
.
0f
0
.
0f
1
.
0f
1
.
0f
0
.
0f
1
.
0f
-
1
.
0f
0
.
0f
}
;
glBindFramebuffer
(
GL_FRAMEBUFFER
0
)
;
glViewport
(
0
0
getWindowWidth
(
)
getWindowHeight
(
)
)
;
glUseProgram
(
mCubeProgram
)
;
glVertexAttribPointer
(
mCubePositionAttributePosition
3
GL_FLOAT
GL_FALSE
0
vertexLocations
)
;
glEnableVertexAttribArray
(
mCubePositionAttributePosition
)
;
glUniform1i
(
mCubeTextureUniformPosition
0
)
;
glActiveTexture
(
GL_TEXTURE0
)
;
glBindTexture
(
GL_TEXTURE_CUBE_MAP
mOffscreenTextureCube
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glDrawArrays
(
GL_TRIANGLE_STRIP
0
4
)
;
EXPECT_PIXEL_EQ
(
0
0
0
0
255
255
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glGenerateMipmap
(
GL_TEXTURE_CUBE_MAP
)
;
glTexParameteri
(
GL_TEXTURE_CUBE_MAP
GL_TEXTURE_MIN_FILTER
GL_LINEAR_MIPMAP_NEAREST
)
;
glTexParameteri
(
GL_TEXTURE_CUBE_MAP
GL_TEXTURE_MIN_FILTER
GL_LINEAR_MIPMAP_NEAREST
)
;
glDrawArrays
(
GL_TRIANGLE_STRIP
0
4
)
;
EXPECT_PIXEL_EQ
(
0
0
0
0
255
255
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glViewport
(
0
0
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
glDrawArrays
(
GL_TRIANGLE_STRIP
0
4
)
;
EXPECT_PIXEL_EQ
(
0
0
0
0
255
255
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mOffscreenFramebuffer
)
;
glFramebufferTexture2D
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
mOffscreenTextureCube
0
)
;
ASSERT_GLENUM_EQ
(
GL_FRAMEBUFFER_COMPLETE
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
glClearColor
(
1
.
0f
0
.
0f
0
.
0f
1
.
0f
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
0
)
;
glBindTexture
(
GL_TEXTURE_CUBE_MAP
mOffscreenTextureCube
)
;
glClearColor
(
0
.
0f
0
.
0f
0
.
0f
1
.
0f
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glViewport
(
0
0
getWindowWidth
(
)
getWindowHeight
(
)
)
;
glDrawArrays
(
GL_TRIANGLE_STRIP
0
4
)
;
EXPECT_PIXEL_EQ
(
0
0
255
0
0
255
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glViewport
(
0
0
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
glDrawArrays
(
GL_TRIANGLE_STRIP
0
4
)
;
EXPECT_PIXEL_EQ
(
0
0
0
0
255
255
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glTexParameteri
(
GL_TEXTURE_CUBE_MAP
GL_TEXTURE_MIN_FILTER
GL_NEAREST
)
;
glTexParameteri
(
GL_TEXTURE_CUBE_MAP
GL_TEXTURE_MIN_FILTER
GL_NEAREST
)
;
glViewport
(
0
0
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
glDrawArrays
(
GL_TRIANGLE_STRIP
0
4
)
;
}
TEST_P
(
MipmapTest
TextureCubeRenderToLevelZero
)
{
GLfloat
vertexLocations
[
]
=
{
-
1
.
0f
1
.
0f
0
.
0f
-
1
.
0f
-
1
.
0f
0
.
0f
1
.
0f
1
.
0f
0
.
0f
1
.
0f
-
1
.
0f
0
.
0f
}
;
glBindFramebuffer
(
GL_FRAMEBUFFER
0
)
;
glViewport
(
0
0
getWindowWidth
(
)
getWindowHeight
(
)
)
;
glUseProgram
(
mCubeProgram
)
;
glVertexAttribPointer
(
mCubePositionAttributePosition
3
GL_FLOAT
GL_FALSE
0
vertexLocations
)
;
glEnableVertexAttribArray
(
mCubePositionAttributePosition
)
;
glUniform1i
(
mCubeTextureUniformPosition
0
)
;
glActiveTexture
(
GL_TEXTURE0
)
;
glBindTexture
(
GL_TEXTURE_CUBE_MAP
mOffscreenTextureCube
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glDrawArrays
(
GL_TRIANGLE_STRIP
0
4
)
;
EXPECT_PIXEL_EQ
(
0
0
0
0
255
255
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mOffscreenFramebuffer
)
;
glFramebufferTexture2D
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
mOffscreenTextureCube
0
)
;
ASSERT_GLENUM_EQ
(
GL_FRAMEBUFFER_COMPLETE
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
glClearColor
(
1
.
0f
0
.
0f
0
.
0f
1
.
0f
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
0
)
;
glBindTexture
(
GL_TEXTURE_CUBE_MAP
mOffscreenTextureCube
)
;
glClearColor
(
0
.
0f
0
.
0f
0
.
0f
1
.
0f
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glViewport
(
0
0
getWindowWidth
(
)
getWindowHeight
(
)
)
;
glDrawArrays
(
GL_TRIANGLE_STRIP
0
4
)
;
EXPECT_PIXEL_EQ
(
0
0
255
0
0
255
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glViewport
(
0
0
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
glDrawArrays
(
GL_TRIANGLE_STRIP
0
4
)
;
EXPECT_PIXEL_EQ
(
0
0
255
0
0
255
)
;
}
TEST_P
(
MipmapTestES3
MipmapsForTextureArray
)
{
int
px
=
getWindowWidth
(
)
/
2
;
int
py
=
getWindowHeight
(
)
/
2
;
glActiveTexture
(
GL_TEXTURE0
)
;
glBindTexture
(
GL_TEXTURE_2D_ARRAY
mTextureArray
)
;
glTexStorage3D
(
GL_TEXTURE_2D_ARRAY
5
GL_RGBA8
16
16
3
)
;
std
:
:
vector
<
GLubyte
>
pixels
(
4
*
16
*
16
)
;
for
(
size_t
pixelId
=
0
;
pixelId
<
16
*
16
;
+
+
pixelId
)
{
pixels
[
pixelId
*
4
+
0
]
=
255
;
pixels
[
pixelId
*
4
+
1
]
=
0
;
pixels
[
pixelId
*
4
+
2
]
=
0
;
pixels
[
pixelId
*
4
+
3
]
=
255
;
}
glTexSubImage3D
(
GL_TEXTURE_2D_ARRAY
0
0
0
0
16
16
1
GL_RGBA
GL_UNSIGNED_BYTE
pixels
.
data
(
)
)
;
for
(
size_t
pixelId
=
0
;
pixelId
<
16
*
16
;
+
+
pixelId
)
{
pixels
[
pixelId
*
4
+
0
]
=
0
;
pixels
[
pixelId
*
4
+
1
]
=
255
;
pixels
[
pixelId
*
4
+
2
]
=
0
;
pixels
[
pixelId
*
4
+
3
]
=
255
;
}
glTexSubImage3D
(
GL_TEXTURE_2D_ARRAY
0
0
0
1
16
16
1
GL_RGBA
GL_UNSIGNED_BYTE
pixels
.
data
(
)
)
;
for
(
size_t
pixelId
=
0
;
pixelId
<
16
*
16
;
+
+
pixelId
)
{
pixels
[
pixelId
*
4
+
0
]
=
0
;
pixels
[
pixelId
*
4
+
1
]
=
0
;
pixels
[
pixelId
*
4
+
2
]
=
255
;
pixels
[
pixelId
*
4
+
3
]
=
255
;
}
glTexSubImage3D
(
GL_TEXTURE_2D_ARRAY
0
0
0
2
16
16
1
GL_RGBA
GL_UNSIGNED_BYTE
pixels
.
data
(
)
)
;
glTexParameteri
(
GL_TEXTURE_2D_ARRAY
GL_TEXTURE_MIN_FILTER
GL_LINEAR_MIPMAP_NEAREST
)
;
glTexParameteri
(
GL_TEXTURE_2D_ARRAY
GL_TEXTURE_MAG_FILTER
GL_LINEAR
)
;
EXPECT_GL_NO_ERROR
(
)
;
glGenerateMipmap
(
GL_TEXTURE_2D_ARRAY
)
;
EXPECT_GL_NO_ERROR
(
)
;
glUseProgram
(
mArrayProgram
)
;
glUniform1i
(
mTextureArrayUniformLocation
0
)
;
EXPECT_GL_NO_ERROR
(
)
;
glUseProgram
(
mArrayProgram
)
;
glUniform1i
(
mTextureArraySliceUniformLocation
0
)
;
drawQuad
(
mArrayProgram
"
position
"
0
.
5f
)
;
EXPECT_GL_NO_ERROR
(
)
;
EXPECT_PIXEL_EQ
(
px
py
255
0
0
255
)
;
glUseProgram
(
mArrayProgram
)
;
glUniform1i
(
mTextureArraySliceUniformLocation
1
)
;
drawQuad
(
mArrayProgram
"
position
"
0
.
5f
)
;
EXPECT_GL_NO_ERROR
(
)
;
EXPECT_PIXEL_EQ
(
px
py
0
255
0
255
)
;
glUseProgram
(
mArrayProgram
)
;
glUniform1i
(
mTextureArraySliceUniformLocation
2
)
;
drawQuad
(
mArrayProgram
"
position
"
0
.
5f
)
;
EXPECT_GL_NO_ERROR
(
)
;
EXPECT_PIXEL_EQ
(
px
py
0
0
255
255
)
;
}
TEST_P
(
MipmapTestES3
MipmapsForTexture3D
)
{
int
px
=
getWindowWidth
(
)
/
2
;
int
py
=
getWindowHeight
(
)
/
2
;
glActiveTexture
(
GL_TEXTURE0
)
;
glBindTexture
(
GL_TEXTURE_3D
mTexture3D
)
;
glTexStorage3D
(
GL_TEXTURE_3D
5
GL_RGBA8
16
16
2
)
;
std
:
:
vector
<
GLubyte
>
pixels
(
4
*
16
*
16
)
;
for
(
size_t
pixelId
=
0
;
pixelId
<
16
*
16
;
+
+
pixelId
)
{
pixels
[
pixelId
*
4
+
0
]
=
255
;
pixels
[
pixelId
*
4
+
1
]
=
0
;
pixels
[
pixelId
*
4
+
2
]
=
0
;
pixels
[
pixelId
*
4
+
3
]
=
255
;
}
glTexSubImage3D
(
GL_TEXTURE_3D
0
0
0
0
16
16
1
GL_RGBA
GL_UNSIGNED_BYTE
pixels
.
data
(
)
)
;
for
(
size_t
pixelId
=
0
;
pixelId
<
16
*
16
;
+
+
pixelId
)
{
pixels
[
pixelId
*
4
+
0
]
=
0
;
pixels
[
pixelId
*
4
+
1
]
=
255
;
pixels
[
pixelId
*
4
+
2
]
=
0
;
pixels
[
pixelId
*
4
+
3
]
=
255
;
}
glTexSubImage3D
(
GL_TEXTURE_3D
0
0
0
1
16
16
1
GL_RGBA
GL_UNSIGNED_BYTE
pixels
.
data
(
)
)
;
glTexParameteri
(
GL_TEXTURE_3D
GL_TEXTURE_MIN_FILTER
GL_NEAREST_MIPMAP_NEAREST
)
;
glTexParameteri
(
GL_TEXTURE_3D
GL_TEXTURE_MAG_FILTER
GL_LINEAR
)
;
EXPECT_GL_NO_ERROR
(
)
;
glGenerateMipmap
(
GL_TEXTURE_3D
)
;
EXPECT_GL_NO_ERROR
(
)
;
glUseProgram
(
m3DProgram
)
;
glUniform1i
(
mTexture3DUniformLocation
0
)
;
EXPECT_GL_NO_ERROR
(
)
;
glUseProgram
(
m3DProgram
)
;
glUniform1f
(
mTexture3DLODUniformLocation
0
.
)
;
glUniform1f
(
mTexture3DSliceUniformLocation
0
.
25f
)
;
drawQuad
(
m3DProgram
"
position
"
0
.
5f
)
;
EXPECT_GL_NO_ERROR
(
)
;
EXPECT_PIXEL_EQ
(
px
py
255
0
0
255
)
;
glUseProgram
(
m3DProgram
)
;
glUniform1f
(
mTexture3DSliceUniformLocation
0
.
75f
)
;
drawQuad
(
m3DProgram
"
position
"
0
.
5f
)
;
EXPECT_GL_NO_ERROR
(
)
;
EXPECT_PIXEL_EQ
(
px
py
0
255
0
255
)
;
glUseProgram
(
m3DProgram
)
;
glUniform1f
(
mTexture3DLODUniformLocation
1
.
)
;
drawQuad
(
m3DProgram
"
position
"
0
.
5f
)
;
EXPECT_GL_NO_ERROR
(
)
;
EXPECT_PIXEL_EQ
(
px
py
127
127
0
255
)
;
glUseProgram
(
m3DProgram
)
;
glUniform1f
(
mTexture3DSliceUniformLocation
0
.
75f
)
;
drawQuad
(
m3DProgram
"
position
"
0
.
5f
)
;
EXPECT_GL_NO_ERROR
(
)
;
EXPECT_PIXEL_EQ
(
px
py
127
127
0
255
)
;
}
ANGLE_INSTANTIATE_TEST
(
MipmapTest
ES2_D3D9
(
)
ES2_D3D11
(
)
ES2_D3D11_FL9_3_WARP
(
)
ES2_OPENGL
(
)
ES3_OPENGL
(
)
)
;
ANGLE_INSTANTIATE_TEST
(
MipmapTestES3
ES3_D3D11
(
)
)
;
