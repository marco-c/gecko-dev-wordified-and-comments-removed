#
include
"
test_utils
/
ANGLETest
.
h
"
using
namespace
angle
;
namespace
{
void
TexImageCubeMapFaces
(
GLint
level
GLenum
internalformat
GLsizei
width
GLenum
format
GLenum
type
void
*
pixels
)
{
glTexImage2D
(
GL_TEXTURE_CUBE_MAP_POSITIVE_X
level
internalformat
width
width
0
format
type
pixels
)
;
glTexImage2D
(
GL_TEXTURE_CUBE_MAP_NEGATIVE_X
level
internalformat
width
width
0
format
type
pixels
)
;
glTexImage2D
(
GL_TEXTURE_CUBE_MAP_POSITIVE_Y
level
internalformat
width
width
0
format
type
pixels
)
;
glTexImage2D
(
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
level
internalformat
width
width
0
format
type
pixels
)
;
glTexImage2D
(
GL_TEXTURE_CUBE_MAP_POSITIVE_Z
level
internalformat
width
width
0
format
type
pixels
)
;
glTexImage2D
(
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
level
internalformat
width
width
0
format
type
pixels
)
;
}
class
BaseMipmapTest
:
public
ANGLETest
{
protected
:
void
clearAndDrawQuad
(
GLuint
program
GLsizei
viewportWidth
GLsizei
viewportHeight
)
{
glClearColor
(
0
.
0f
0
.
0f
0
.
0f
1
.
0f
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glViewport
(
0
0
viewportWidth
viewportHeight
)
;
ASSERT_GL_NO_ERROR
(
)
;
drawQuad
(
program
"
position
"
0
.
0f
)
;
}
}
;
}
class
MipmapTest
:
public
BaseMipmapTest
{
protected
:
MipmapTest
(
)
:
m2DProgram
(
0
)
mCubeProgram
(
0
)
mTexture2D
(
0
)
mTextureCube
(
0
)
mLevelZeroBlueInitData
(
nullptr
)
mLevelZeroWhiteInitData
(
nullptr
)
mLevelOneInitData
(
nullptr
)
mLevelTwoInitData
(
nullptr
)
mOffscreenFramebuffer
(
0
)
{
setWindowWidth
(
128
)
;
setWindowHeight
(
128
)
;
setConfigRedBits
(
8
)
;
setConfigGreenBits
(
8
)
;
setConfigBlueBits
(
8
)
;
setConfigAlphaBits
(
8
)
;
}
void
setUp2DProgram
(
)
{
const
std
:
:
string
vs
=
SHADER_SOURCE
(
attribute
vec4
position
;
varying
vec2
vTexCoord
;
void
main
(
)
{
gl_Position
=
position
;
vTexCoord
=
(
position
.
xy
*
0
.
5
)
+
0
.
5
;
}
)
;
const
std
:
:
string
fs
=
SHADER_SOURCE
(
precision
mediump
float
;
uniform
sampler2D
uTexture
;
varying
vec2
vTexCoord
;
void
main
(
)
{
gl_FragColor
=
texture2D
(
uTexture
vTexCoord
)
;
}
)
;
m2DProgram
=
CompileProgram
(
vs
fs
)
;
ASSERT_NE
(
0u
m2DProgram
)
;
}
void
setUpCubeProgram
(
)
{
const
std
:
:
string
cubeVS
=
SHADER_SOURCE
(
attribute
vec4
position
;
varying
vec4
vPosition
;
void
main
(
)
{
gl_Position
=
position
;
vPosition
=
position
;
}
)
;
const
std
:
:
string
cubeFS
=
SHADER_SOURCE
(
precision
mediump
float
;
uniform
samplerCube
uTexture
;
varying
vec4
vPosition
;
void
main
(
)
{
gl_FragColor
=
textureCube
(
uTexture
vec3
(
vPosition
.
x
-
1
vPosition
.
y
)
)
;
}
)
;
mCubeProgram
=
CompileProgram
(
cubeVS
cubeFS
)
;
ASSERT_NE
(
0u
mCubeProgram
)
;
}
void
SetUp
(
)
override
{
ANGLETest
:
:
SetUp
(
)
;
setUp2DProgram
(
)
;
setUpCubeProgram
(
)
;
mLevelZeroBlueInitData
=
createRGBInitData
(
getWindowWidth
(
)
getWindowHeight
(
)
0
0
255
)
;
mLevelZeroWhiteInitData
=
createRGBInitData
(
getWindowWidth
(
)
getWindowHeight
(
)
255
255
255
)
;
mLevelOneInitData
=
createRGBInitData
(
(
getWindowWidth
(
)
/
2
)
(
getWindowHeight
(
)
/
2
)
0
255
0
)
;
mLevelTwoInitData
=
createRGBInitData
(
(
getWindowWidth
(
)
/
4
)
(
getWindowHeight
(
)
/
4
)
255
0
0
)
;
glGenFramebuffers
(
1
&
mOffscreenFramebuffer
)
;
glGenTextures
(
1
&
mTexture2D
)
;
glBindTexture
(
GL_TEXTURE_2D
mTexture2D
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGB
getWindowWidth
(
)
getWindowHeight
(
)
0
GL_RGB
GL_UNSIGNED_BYTE
NULL
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MAG_FILTER
GL_LINEAR
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_LINEAR
)
;
ASSERT_EQ
(
getWindowWidth
(
)
getWindowHeight
(
)
)
;
glGenTextures
(
1
&
mTextureCube
)
;
glBindTexture
(
GL_TEXTURE_CUBE_MAP
mTextureCube
)
;
TexImageCubeMapFaces
(
0
GL_RGB
getWindowWidth
(
)
GL_RGB
GL_UNSIGNED_BYTE
nullptr
)
;
glTexImage2D
(
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
0
GL_RGB
getWindowWidth
(
)
getWindowWidth
(
)
0
GL_RGB
GL_UNSIGNED_BYTE
mLevelZeroBlueInitData
)
;
glTexParameteri
(
GL_TEXTURE_CUBE_MAP
GL_TEXTURE_MAG_FILTER
GL_NEAREST
)
;
glTexParameteri
(
GL_TEXTURE_CUBE_MAP
GL_TEXTURE_MIN_FILTER
GL_NEAREST
)
;
ASSERT_GL_NO_ERROR
(
)
;
}
void
TearDown
(
)
override
{
glDeleteProgram
(
m2DProgram
)
;
glDeleteProgram
(
mCubeProgram
)
;
glDeleteFramebuffers
(
1
&
mOffscreenFramebuffer
)
;
glDeleteTextures
(
1
&
mTexture2D
)
;
glDeleteTextures
(
1
&
mTextureCube
)
;
SafeDeleteArray
(
mLevelZeroBlueInitData
)
;
SafeDeleteArray
(
mLevelZeroWhiteInitData
)
;
SafeDeleteArray
(
mLevelOneInitData
)
;
SafeDeleteArray
(
mLevelTwoInitData
)
;
ANGLETest
:
:
TearDown
(
)
;
}
GLubyte
*
createRGBInitData
(
GLint
width
GLint
height
GLint
r
GLint
g
GLint
b
)
{
GLubyte
*
data
=
new
GLubyte
[
3
*
width
*
height
]
;
for
(
int
i
=
0
;
i
<
width
*
height
;
i
+
=
1
)
{
data
[
3
*
i
+
0
]
=
static_cast
<
GLubyte
>
(
r
)
;
data
[
3
*
i
+
1
]
=
static_cast
<
GLubyte
>
(
g
)
;
data
[
3
*
i
+
2
]
=
static_cast
<
GLubyte
>
(
b
)
;
}
return
data
;
}
void
clearTextureLevel0
(
GLenum
textarget
GLuint
texture
GLfloat
red
GLfloat
green
GLfloat
blue
GLfloat
alpha
)
{
glBindFramebuffer
(
GL_FRAMEBUFFER
mOffscreenFramebuffer
)
;
glFramebufferTexture2D
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
textarget
texture
0
)
;
ASSERT_GLENUM_EQ
(
GL_FRAMEBUFFER_COMPLETE
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
glClearColor
(
red
green
blue
alpha
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
0
)
;
}
GLuint
m2DProgram
;
GLuint
mCubeProgram
;
GLuint
mTexture2D
;
GLuint
mTextureCube
;
GLubyte
*
mLevelZeroBlueInitData
;
GLubyte
*
mLevelZeroWhiteInitData
;
GLubyte
*
mLevelOneInitData
;
GLubyte
*
mLevelTwoInitData
;
private
:
GLuint
mOffscreenFramebuffer
;
}
;
class
MipmapTestES3
:
public
BaseMipmapTest
{
protected
:
MipmapTestES3
(
)
:
mTexture
(
0
)
mArrayProgram
(
0
)
mTextureArraySliceUniformLocation
(
-
1
)
m3DProgram
(
0
)
mTexture3DSliceUniformLocation
(
-
1
)
mTexture3DLODUniformLocation
(
-
1
)
m2DProgram
(
0
)
{
setWindowWidth
(
128
)
;
setWindowHeight
(
128
)
;
setConfigRedBits
(
8
)
;
setConfigGreenBits
(
8
)
;
setConfigBlueBits
(
8
)
;
setConfigAlphaBits
(
8
)
;
}
std
:
:
string
vertexShaderSource
(
)
{
return
SHADER_SOURCE
(
#
version
300
es
\
n
precision
highp
float
;
in
vec4
position
;
out
vec2
texcoord
;
void
main
(
)
{
gl_Position
=
vec4
(
position
.
xy
0
.
0
1
.
0
)
;
texcoord
=
(
position
.
xy
*
0
.
5
)
+
0
.
5
;
}
)
;
}
void
setUpArrayProgram
(
)
{
const
std
:
:
string
fragmentShaderSourceArray
=
SHADER_SOURCE
(
#
version
300
es
\
n
precision
highp
float
;
uniform
highp
sampler2DArray
tex
;
uniform
int
slice
;
in
vec2
texcoord
;
out
vec4
out_FragColor
;
void
main
(
)
{
out_FragColor
=
texture
(
tex
vec3
(
texcoord
float
(
slice
)
)
)
;
}
)
;
mArrayProgram
=
CompileProgram
(
vertexShaderSource
(
)
fragmentShaderSourceArray
)
;
if
(
mArrayProgram
=
=
0
)
{
FAIL
(
)
<
<
"
shader
compilation
failed
.
"
;
}
mTextureArraySliceUniformLocation
=
glGetUniformLocation
(
mArrayProgram
"
slice
"
)
;
ASSERT_NE
(
-
1
mTextureArraySliceUniformLocation
)
;
glUseProgram
(
mArrayProgram
)
;
glUseProgram
(
0
)
;
ASSERT_GL_NO_ERROR
(
)
;
}
void
setUp3DProgram
(
)
{
const
std
:
:
string
fragmentShaderSource3D
=
SHADER_SOURCE
(
#
version
300
es
\
n
precision
highp
float
;
uniform
highp
sampler3D
tex
;
uniform
float
slice
;
uniform
float
lod
;
in
vec2
texcoord
;
out
vec4
out_FragColor
;
void
main
(
)
{
out_FragColor
=
textureLod
(
tex
vec3
(
texcoord
slice
)
lod
)
;
}
)
;
m3DProgram
=
CompileProgram
(
vertexShaderSource
(
)
fragmentShaderSource3D
)
;
if
(
m3DProgram
=
=
0
)
{
FAIL
(
)
<
<
"
shader
compilation
failed
.
"
;
}
mTexture3DSliceUniformLocation
=
glGetUniformLocation
(
m3DProgram
"
slice
"
)
;
ASSERT_NE
(
-
1
mTexture3DSliceUniformLocation
)
;
mTexture3DLODUniformLocation
=
glGetUniformLocation
(
m3DProgram
"
lod
"
)
;
ASSERT_NE
(
-
1
mTexture3DLODUniformLocation
)
;
glUseProgram
(
m3DProgram
)
;
glUniform1f
(
mTexture3DLODUniformLocation
0
)
;
glUseProgram
(
0
)
;
ASSERT_GL_NO_ERROR
(
)
;
}
void
setUp2DProgram
(
)
{
const
std
:
:
string
fragmentShaderSource2D
=
SHADER_SOURCE
(
#
version
300
es
\
n
precision
highp
float
;
uniform
highp
sampler2D
tex
;
in
vec2
texcoord
;
out
vec4
out_FragColor
;
void
main
(
)
{
out_FragColor
=
texture
(
tex
texcoord
)
;
}
)
;
m2DProgram
=
CompileProgram
(
vertexShaderSource
(
)
fragmentShaderSource2D
)
;
ASSERT_NE
(
0u
m2DProgram
)
;
ASSERT_GL_NO_ERROR
(
)
;
}
void
setUpCubeProgram
(
)
{
const
std
:
:
string
cubeFS
=
SHADER_SOURCE
(
#
version
300
es
\
n
precision
mediump
float
;
uniform
samplerCube
uTexture
;
in
vec2
texcoord
;
out
vec4
out_FragColor
;
void
main
(
)
{
out_FragColor
=
texture
(
uTexture
vec3
(
texcoord
.
x
-
1
texcoord
.
y
)
)
;
}
)
;
mCubeProgram
=
CompileProgram
(
vertexShaderSource
(
)
cubeFS
)
;
ASSERT_NE
(
0u
mCubeProgram
)
;
ASSERT_GL_NO_ERROR
(
)
;
}
void
SetUp
(
)
override
{
ANGLETest
:
:
SetUp
(
)
;
glGenTextures
(
1
&
mTexture
)
;
ASSERT_GL_NO_ERROR
(
)
;
setUpArrayProgram
(
)
;
setUp3DProgram
(
)
;
setUp2DProgram
(
)
;
setUpCubeProgram
(
)
;
}
void
TearDown
(
)
override
{
glDeleteTextures
(
1
&
mTexture
)
;
glDeleteProgram
(
mArrayProgram
)
;
glDeleteProgram
(
m3DProgram
)
;
glDeleteProgram
(
m2DProgram
)
;
glDeleteProgram
(
mCubeProgram
)
;
ANGLETest
:
:
TearDown
(
)
;
}
GLuint
mTexture
;
GLuint
mArrayProgram
;
GLint
mTextureArraySliceUniformLocation
;
GLuint
m3DProgram
;
GLint
mTexture3DSliceUniformLocation
;
GLint
mTexture3DLODUniformLocation
;
GLuint
m2DProgram
;
GLuint
mCubeProgram
;
}
;
TEST_P
(
MipmapTest
DISABLED_ThreeLevelsInitData
)
{
glBindTexture
(
GL_TEXTURE_2D
mTexture2D
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGB
getWindowWidth
(
)
getWindowHeight
(
)
0
GL_RGB
GL_UNSIGNED_BYTE
mLevelZeroBlueInitData
)
;
ASSERT_GL_NO_ERROR
(
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_NEAREST
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
GLColor
:
:
blue
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
GLColor
:
:
blue
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
GLColor
:
:
blue
)
;
int
n
=
1
;
while
(
getWindowWidth
(
)
/
(
1U
<
<
n
)
>
=
1
)
{
glTexImage2D
(
GL_TEXTURE_2D
n
GL_RGB
getWindowWidth
(
)
/
(
1U
<
<
n
)
getWindowWidth
(
)
/
(
1U
<
<
n
)
0
GL_RGB
GL_UNSIGNED_BYTE
NULL
)
;
ASSERT_GL_NO_ERROR
(
)
;
n
+
=
1
;
}
glTexImage2D
(
GL_TEXTURE_2D
1
GL_RGB
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
0
GL_RGB
GL_UNSIGNED_BYTE
mLevelOneInitData
)
;
ASSERT_GL_NO_ERROR
(
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
GLColor
:
:
blue
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
GLColor
:
:
blue
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_LINEAR_MIPMAP_NEAREST
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
GLColor
:
:
green
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
GLColor
:
:
black
)
;
glTexImage2D
(
GL_TEXTURE_2D
2
GL_RGB
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
0
GL_RGB
GL_UNSIGNED_BYTE
mLevelTwoInitData
)
;
ASSERT_GL_NO_ERROR
(
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
GLColor
:
:
blue
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
GLColor
:
:
green
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
GLColor
:
:
red
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_NEAREST
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
GLColor
:
:
blue
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
GLColor
:
:
blue
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
GLColor
:
:
blue
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGB
getWindowWidth
(
)
getWindowHeight
(
)
0
GL_RGB
GL_UNSIGNED_BYTE
mLevelZeroWhiteInitData
)
;
ASSERT_GL_NO_ERROR
(
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
GLColor
:
:
white
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
GLColor
:
:
white
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
GLColor
:
:
white
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_LINEAR_MIPMAP_NEAREST
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
GLColor
:
:
white
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
GLColor
:
:
green
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
GLColor
:
:
red
)
;
}
TEST_P
(
MipmapTest
GenerateMipmapFromInitDataThenRender
)
{
glBindTexture
(
GL_TEXTURE_2D
mTexture2D
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGB
getWindowWidth
(
)
getWindowHeight
(
)
0
GL_RGB
GL_UNSIGNED_BYTE
mLevelZeroBlueInitData
)
;
glGenerateMipmap
(
GL_TEXTURE_2D
)
;
ASSERT_GL_NO_ERROR
(
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_LINEAR_MIPMAP_NEAREST
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
GLColor
:
:
blue
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
GLColor
:
:
blue
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
GLColor
:
:
blue
)
;
ASSERT_GL_NO_ERROR
(
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_NEAREST
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
GLColor
:
:
blue
)
;
clearTextureLevel0
(
GL_TEXTURE_2D
mTexture2D
1
.
0f
0
.
0f
0
.
0f
1
.
0f
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_LINEAR_MIPMAP_NEAREST
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
GLColor
:
:
red
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
GLColor
:
:
blue
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
GLColor
:
:
blue
)
;
}
TEST_P
(
MipmapTest
GenerateMipmapFromRenderedImage
)
{
glBindTexture
(
GL_TEXTURE_2D
mTexture2D
)
;
clearTextureLevel0
(
GL_TEXTURE_2D
mTexture2D
0
.
0f
0
.
0f
1
.
0f
1
.
0f
)
;
glGenerateMipmap
(
GL_TEXTURE_2D
)
;
ASSERT_GL_NO_ERROR
(
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_LINEAR_MIPMAP_NEAREST
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
GLColor
:
:
blue
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
GLColor
:
:
blue
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
GLColor
:
:
blue
)
;
}
TEST_P
(
MipmapTest
RenderOntoLevelZeroAfterGenerateMipmap
)
{
if
(
(
IsAMD
(
)
|
|
IsIntel
(
)
)
&
&
getPlatformRenderer
(
)
=
=
EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE
)
{
std
:
:
cout
<
<
"
Test
skipped
on
Intel
/
AMD
OpenGL
.
"
<
<
std
:
:
endl
;
return
;
}
glBindTexture
(
GL_TEXTURE_2D
mTexture2D
)
;
clearTextureLevel0
(
GL_TEXTURE_2D
mTexture2D
0
.
0f
0
.
0f
1
.
0f
1
.
0f
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
GLColor
:
:
blue
)
;
glGenerateMipmap
(
GL_TEXTURE_2D
)
;
ASSERT_GL_NO_ERROR
(
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
GLColor
:
:
blue
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_LINEAR_MIPMAP_NEAREST
)
;
EXPECT_GL_NO_ERROR
(
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
GLColor
:
:
blue
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
GLColor
:
:
blue
)
;
clearTextureLevel0
(
GL_TEXTURE_2D
mTexture2D
0
.
0f
1
.
0f
0
.
0f
1
.
0f
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
GLColor
:
:
green
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
GLColor
:
:
blue
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_LINEAR
)
;
ASSERT_GL_NO_ERROR
(
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
GLColor
:
:
green
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
GLColor
:
:
green
)
;
}
TEST_P
(
MipmapTest
TextureCubeGeneralLevelZero
)
{
glBindTexture
(
GL_TEXTURE_CUBE_MAP
mTextureCube
)
;
clearAndDrawQuad
(
mCubeProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
0
0
GLColor
:
:
blue
)
;
glGenerateMipmap
(
GL_TEXTURE_CUBE_MAP
)
;
glTexParameteri
(
GL_TEXTURE_CUBE_MAP
GL_TEXTURE_MIN_FILTER
GL_LINEAR_MIPMAP_NEAREST
)
;
clearAndDrawQuad
(
mCubeProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
0
0
GLColor
:
:
blue
)
;
clearAndDrawQuad
(
mCubeProgram
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_COLOR_EQ
(
0
0
GLColor
:
:
blue
)
;
clearTextureLevel0
(
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
mTextureCube
1
.
0f
0
.
0f
0
.
0f
1
.
0f
)
;
clearAndDrawQuad
(
mCubeProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
0
0
GLColor
:
:
red
)
;
clearAndDrawQuad
(
mCubeProgram
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_COLOR_EQ
(
0
0
GLColor
:
:
blue
)
;
glTexParameteri
(
GL_TEXTURE_CUBE_MAP
GL_TEXTURE_MIN_FILTER
GL_NEAREST
)
;
clearAndDrawQuad
(
mCubeProgram
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_COLOR_EQ
(
0
0
GLColor
:
:
red
)
;
}
TEST_P
(
MipmapTest
TextureCubeRenderToLevelZero
)
{
glBindTexture
(
GL_TEXTURE_CUBE_MAP
mTextureCube
)
;
clearAndDrawQuad
(
mCubeProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
0
0
GLColor
:
:
blue
)
;
clearTextureLevel0
(
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
mTextureCube
1
.
0f
0
.
0f
0
.
0f
1
.
0f
)
;
clearAndDrawQuad
(
mCubeProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
0
0
GLColor
:
:
red
)
;
clearAndDrawQuad
(
mCubeProgram
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_COLOR_EQ
(
0
0
GLColor
:
:
red
)
;
}
TEST_P
(
MipmapTestES3
MipmapsForTextureArray
)
{
int
px
=
getWindowWidth
(
)
/
2
;
int
py
=
getWindowHeight
(
)
/
2
;
glBindTexture
(
GL_TEXTURE_2D_ARRAY
mTexture
)
;
glTexStorage3D
(
GL_TEXTURE_2D_ARRAY
5
GL_RGBA8
16
16
3
)
;
std
:
:
vector
<
GLColor
>
pixelsRed
(
16
*
16
GLColor
:
:
red
)
;
glTexSubImage3D
(
GL_TEXTURE_2D_ARRAY
0
0
0
0
16
16
1
GL_RGBA
GL_UNSIGNED_BYTE
pixelsRed
.
data
(
)
)
;
std
:
:
vector
<
GLColor
>
pixelsGreen
(
16
*
16
GLColor
:
:
green
)
;
glTexSubImage3D
(
GL_TEXTURE_2D_ARRAY
0
0
0
1
16
16
1
GL_RGBA
GL_UNSIGNED_BYTE
pixelsGreen
.
data
(
)
)
;
std
:
:
vector
<
GLColor
>
pixelsBlue
(
16
*
16
GLColor
:
:
blue
)
;
glTexSubImage3D
(
GL_TEXTURE_2D_ARRAY
0
0
0
2
16
16
1
GL_RGBA
GL_UNSIGNED_BYTE
pixelsBlue
.
data
(
)
)
;
glTexParameteri
(
GL_TEXTURE_2D_ARRAY
GL_TEXTURE_MIN_FILTER
GL_LINEAR_MIPMAP_NEAREST
)
;
glTexParameteri
(
GL_TEXTURE_2D_ARRAY
GL_TEXTURE_MAG_FILTER
GL_LINEAR
)
;
EXPECT_GL_NO_ERROR
(
)
;
glGenerateMipmap
(
GL_TEXTURE_2D_ARRAY
)
;
EXPECT_GL_NO_ERROR
(
)
;
glUseProgram
(
mArrayProgram
)
;
EXPECT_GL_NO_ERROR
(
)
;
glUniform1i
(
mTextureArraySliceUniformLocation
0
)
;
drawQuad
(
mArrayProgram
"
position
"
0
.
5f
)
;
EXPECT_GL_NO_ERROR
(
)
;
EXPECT_PIXEL_COLOR_EQ
(
px
py
GLColor
:
:
red
)
;
glUniform1i
(
mTextureArraySliceUniformLocation
1
)
;
drawQuad
(
mArrayProgram
"
position
"
0
.
5f
)
;
EXPECT_GL_NO_ERROR
(
)
;
EXPECT_PIXEL_COLOR_EQ
(
px
py
GLColor
:
:
green
)
;
glUniform1i
(
mTextureArraySliceUniformLocation
2
)
;
drawQuad
(
mArrayProgram
"
position
"
0
.
5f
)
;
EXPECT_GL_NO_ERROR
(
)
;
EXPECT_PIXEL_COLOR_EQ
(
px
py
GLColor
:
:
blue
)
;
}
TEST_P
(
MipmapTestES3
MipmapForDeepTextureArray
)
{
int
px
=
getWindowWidth
(
)
/
2
;
int
py
=
getWindowHeight
(
)
/
2
;
glBindTexture
(
GL_TEXTURE_2D_ARRAY
mTexture
)
;
std
:
:
vector
<
GLColor
>
pixelsRed
(
2
*
2
*
4
GLColor
:
:
red
)
;
glTexImage3D
(
GL_TEXTURE_2D_ARRAY
0
GL_RGBA8
2
2
4
0
GL_RGBA
GL_UNSIGNED_BYTE
pixelsRed
.
data
(
)
)
;
glTexParameteri
(
GL_TEXTURE_2D_ARRAY
GL_TEXTURE_MIN_FILTER
GL_LINEAR_MIPMAP_NEAREST
)
;
glTexParameteri
(
GL_TEXTURE_2D_ARRAY
GL_TEXTURE_MAG_FILTER
GL_LINEAR
)
;
EXPECT_GL_NO_ERROR
(
)
;
glGenerateMipmap
(
GL_TEXTURE_2D_ARRAY
)
;
EXPECT_GL_NO_ERROR
(
)
;
glUseProgram
(
mArrayProgram
)
;
EXPECT_GL_NO_ERROR
(
)
;
glUniform1i
(
mTextureArraySliceUniformLocation
0
)
;
drawQuad
(
mArrayProgram
"
position
"
0
.
5f
)
;
EXPECT_GL_NO_ERROR
(
)
;
EXPECT_PIXEL_COLOR_EQ
(
px
py
GLColor
:
:
red
)
;
glUniform1i
(
mTextureArraySliceUniformLocation
3
)
;
drawQuad
(
mArrayProgram
"
position
"
0
.
5f
)
;
EXPECT_GL_NO_ERROR
(
)
;
EXPECT_PIXEL_COLOR_EQ
(
px
py
GLColor
:
:
red
)
;
}
TEST_P
(
MipmapTestES3
MipmapsForTexture3D
)
{
int
px
=
getWindowWidth
(
)
/
2
;
int
py
=
getWindowHeight
(
)
/
2
;
glBindTexture
(
GL_TEXTURE_3D
mTexture
)
;
glTexStorage3D
(
GL_TEXTURE_3D
5
GL_RGBA8
16
16
2
)
;
std
:
:
vector
<
GLColor
>
pixelsRed
(
16
*
16
GLColor
:
:
red
)
;
glTexSubImage3D
(
GL_TEXTURE_3D
0
0
0
0
16
16
1
GL_RGBA
GL_UNSIGNED_BYTE
pixelsRed
.
data
(
)
)
;
std
:
:
vector
<
GLColor
>
pixelsGreen
(
16
*
16
GLColor
:
:
green
)
;
glTexSubImage3D
(
GL_TEXTURE_3D
0
0
0
1
16
16
1
GL_RGBA
GL_UNSIGNED_BYTE
pixelsGreen
.
data
(
)
)
;
glTexParameteri
(
GL_TEXTURE_3D
GL_TEXTURE_MIN_FILTER
GL_NEAREST_MIPMAP_NEAREST
)
;
glTexParameteri
(
GL_TEXTURE_3D
GL_TEXTURE_MAG_FILTER
GL_LINEAR
)
;
EXPECT_GL_NO_ERROR
(
)
;
glGenerateMipmap
(
GL_TEXTURE_3D
)
;
EXPECT_GL_NO_ERROR
(
)
;
glUseProgram
(
m3DProgram
)
;
EXPECT_GL_NO_ERROR
(
)
;
glUniform1f
(
mTexture3DLODUniformLocation
0
.
)
;
glUniform1f
(
mTexture3DSliceUniformLocation
0
.
25f
)
;
drawQuad
(
m3DProgram
"
position
"
0
.
5f
)
;
EXPECT_GL_NO_ERROR
(
)
;
EXPECT_PIXEL_COLOR_EQ
(
px
py
GLColor
:
:
red
)
;
glUniform1f
(
mTexture3DSliceUniformLocation
0
.
75f
)
;
drawQuad
(
m3DProgram
"
position
"
0
.
5f
)
;
EXPECT_GL_NO_ERROR
(
)
;
EXPECT_PIXEL_COLOR_EQ
(
px
py
GLColor
:
:
green
)
;
glUniform1f
(
mTexture3DLODUniformLocation
1
.
)
;
drawQuad
(
m3DProgram
"
position
"
0
.
5f
)
;
EXPECT_GL_NO_ERROR
(
)
;
EXPECT_PIXEL_NEAR
(
px
py
127
127
0
255
1
.
0
)
;
glUniform1f
(
mTexture3DSliceUniformLocation
0
.
75f
)
;
drawQuad
(
m3DProgram
"
position
"
0
.
5f
)
;
EXPECT_GL_NO_ERROR
(
)
;
EXPECT_PIXEL_NEAR
(
px
py
127
127
0
255
1
.
0
)
;
}
TEST_P
(
MipmapTestES3
GenerateMipmapBaseLevel
)
{
if
(
IsAMD
(
)
&
&
IsDesktopOpenGL
(
)
)
{
std
:
:
cout
<
<
"
Test
skipped
on
AMD
OpenGL
.
"
<
<
std
:
:
endl
;
return
;
}
glBindTexture
(
GL_TEXTURE_2D
mTexture
)
;
std
:
:
vector
<
GLColor
>
pixelsBlue
(
getWindowWidth
(
)
*
getWindowHeight
(
)
GLColor
:
:
blue
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA8
getWindowWidth
(
)
getWindowHeight
(
)
0
GL_RGBA
GL_UNSIGNED_BYTE
pixelsBlue
.
data
(
)
)
;
std
:
:
vector
<
GLColor
>
pixelsRed
(
getWindowWidth
(
)
*
getWindowHeight
(
)
/
4
GLColor
:
:
red
)
;
glTexImage2D
(
GL_TEXTURE_2D
1
GL_RGBA8
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
0
GL_RGBA
GL_UNSIGNED_BYTE
pixelsRed
.
data
(
)
)
;
std
:
:
vector
<
GLColor
>
pixelsGreen
(
getWindowWidth
(
)
*
getWindowHeight
(
)
/
16
GLColor
:
:
green
)
;
glTexImage2D
(
GL_TEXTURE_2D
2
GL_RGBA8
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
0
GL_RGBA
GL_UNSIGNED_BYTE
pixelsGreen
.
data
(
)
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_NEAREST_MIPMAP_NEAREST
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MAG_FILTER
GL_LINEAR
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_BASE_LEVEL
1
)
;
EXPECT_GL_NO_ERROR
(
)
;
glGenerateMipmap
(
GL_TEXTURE_2D
)
;
EXPECT_GL_NO_ERROR
(
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
GLColor
:
:
red
)
;
if
(
IsNVIDIA
(
)
&
&
IsOpenGL
(
)
)
{
std
:
:
cout
<
<
"
Test
partially
skipped
on
NVIDIA
OpenGL
.
"
<
<
std
:
:
endl
;
return
;
}
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_BASE_LEVEL
0
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
GLColor
:
:
blue
)
;
}
TEST_P
(
MipmapTestES3
GenerateMipmapCubeBaseLevel
)
{
if
(
IsAMD
(
)
&
&
IsDesktopOpenGL
(
)
)
{
std
:
:
cout
<
<
"
Test
skipped
on
AMD
OpenGL
.
"
<
<
std
:
:
endl
;
return
;
}
ASSERT_EQ
(
getWindowWidth
(
)
getWindowHeight
(
)
)
;
glBindTexture
(
GL_TEXTURE_CUBE_MAP
mTexture
)
;
std
:
:
vector
<
GLColor
>
pixelsBlue
(
getWindowWidth
(
)
*
getWindowWidth
(
)
GLColor
:
:
blue
)
;
TexImageCubeMapFaces
(
0
GL_RGBA8
getWindowWidth
(
)
GL_RGBA
GL_UNSIGNED_BYTE
pixelsBlue
.
data
(
)
)
;
std
:
:
vector
<
GLColor
>
pixelsRed
(
getWindowWidth
(
)
*
getWindowWidth
(
)
/
4
GLColor
:
:
red
)
;
TexImageCubeMapFaces
(
1
GL_RGBA8
getWindowWidth
(
)
/
2
GL_RGBA
GL_UNSIGNED_BYTE
pixelsRed
.
data
(
)
)
;
std
:
:
vector
<
GLColor
>
pixelsGreen
(
getWindowWidth
(
)
*
getWindowWidth
(
)
/
16
GLColor
:
:
green
)
;
TexImageCubeMapFaces
(
2
GL_RGBA8
getWindowWidth
(
)
/
4
GL_RGBA
GL_UNSIGNED_BYTE
pixelsGreen
.
data
(
)
)
;
glTexParameteri
(
GL_TEXTURE_CUBE_MAP
GL_TEXTURE_MIN_FILTER
GL_NEAREST_MIPMAP_NEAREST
)
;
glTexParameteri
(
GL_TEXTURE_CUBE_MAP
GL_TEXTURE_MAG_FILTER
GL_LINEAR
)
;
glTexParameteri
(
GL_TEXTURE_CUBE_MAP
GL_TEXTURE_BASE_LEVEL
1
)
;
EXPECT_GL_NO_ERROR
(
)
;
glGenerateMipmap
(
GL_TEXTURE_CUBE_MAP
)
;
EXPECT_GL_NO_ERROR
(
)
;
clearAndDrawQuad
(
mCubeProgram
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
GLColor
:
:
red
)
;
if
(
IsNVIDIA
(
)
&
&
IsOpenGL
(
)
)
{
std
:
:
cout
<
<
"
Test
partially
skipped
on
NVIDIA
OpenGL
.
"
<
<
std
:
:
endl
;
return
;
}
glTexParameteri
(
GL_TEXTURE_CUBE_MAP
GL_TEXTURE_BASE_LEVEL
0
)
;
clearAndDrawQuad
(
mCubeProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
GLColor
:
:
blue
)
;
}
TEST_P
(
MipmapTestES3
GenerateMipmapMaxLevel
)
{
glBindTexture
(
GL_TEXTURE_2D
mTexture
)
;
std
:
:
vector
<
GLColor
>
pixelsBlue
(
getWindowWidth
(
)
*
getWindowHeight
(
)
GLColor
:
:
blue
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA8
getWindowWidth
(
)
getWindowHeight
(
)
0
GL_RGBA
GL_UNSIGNED_BYTE
pixelsBlue
.
data
(
)
)
;
std
:
:
vector
<
GLColor
>
pixelsRed
(
getWindowWidth
(
)
*
getWindowHeight
(
)
/
4
GLColor
:
:
red
)
;
glTexImage2D
(
GL_TEXTURE_2D
1
GL_RGBA8
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
0
GL_RGBA
GL_UNSIGNED_BYTE
pixelsRed
.
data
(
)
)
;
std
:
:
vector
<
GLColor
>
pixelsGreen
(
getWindowWidth
(
)
*
getWindowHeight
(
)
/
16
GLColor
:
:
green
)
;
glTexImage2D
(
GL_TEXTURE_2D
2
GL_RGBA8
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
0
GL_RGBA
GL_UNSIGNED_BYTE
pixelsGreen
.
data
(
)
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_NEAREST_MIPMAP_NEAREST
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MAG_FILTER
GL_LINEAR
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MAX_LEVEL
1
)
;
EXPECT_GL_NO_ERROR
(
)
;
glGenerateMipmap
(
GL_TEXTURE_2D
)
;
EXPECT_GL_NO_ERROR
(
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
GLColor
:
:
blue
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MAX_LEVEL
2
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
/
4
getWindowHeight
(
)
/
4
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
8
getWindowHeight
(
)
/
8
GLColor
:
:
green
)
;
}
TEST_P
(
MipmapTestES3
GenerateMipmapBaseLevelOutOfRange
)
{
glBindTexture
(
GL_TEXTURE_2D
mTexture
)
;
std
:
:
vector
<
GLColor
>
pixelsBlue
(
getWindowWidth
(
)
*
getWindowHeight
(
)
GLColor
:
:
blue
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA8
getWindowWidth
(
)
getWindowHeight
(
)
0
GL_RGBA
GL_UNSIGNED_BYTE
pixelsBlue
.
data
(
)
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_BASE_LEVEL
1000
)
;
EXPECT_GL_NO_ERROR
(
)
;
glGenerateMipmap
(
GL_TEXTURE_2D
)
;
EXPECT_GL_ERROR
(
GL_INVALID_OPERATION
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_BASE_LEVEL
0
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_NEAREST
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MAG_FILTER
GL_NEAREST
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
GLColor
:
:
blue
)
;
}
TEST_P
(
MipmapTestES3
GenerateMipmapBaseLevelOutOfRangeImmutableTexture
)
{
glBindTexture
(
GL_TEXTURE_2D
mTexture
)
;
glTexStorage2D
(
GL_TEXTURE_2D
1
GL_RGBA8
1
1
)
;
glTexSubImage2D
(
GL_TEXTURE_2D
0
0
0
1
1
GL_RGBA
GL_UNSIGNED_BYTE
&
GLColor
:
:
green
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_BASE_LEVEL
1000
)
;
EXPECT_GL_NO_ERROR
(
)
;
glGenerateMipmap
(
GL_TEXTURE_2D
)
;
EXPECT_GL_NO_ERROR
(
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_NEAREST
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MAG_FILTER
GL_NEAREST
)
;
clearAndDrawQuad
(
m2DProgram
getWindowWidth
(
)
getWindowHeight
(
)
)
;
EXPECT_PIXEL_COLOR_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
GLColor
:
:
green
)
;
}
ANGLE_INSTANTIATE_TEST
(
MipmapTest
ES2_D3D9
(
)
ES2_D3D11
(
EGL_EXPERIMENTAL_PRESENT_PATH_COPY_ANGLE
)
ES2_D3D11
(
EGL_EXPERIMENTAL_PRESENT_PATH_FAST_ANGLE
)
ES2_D3D11_FL9_3_WARP
(
)
ES2_OPENGL
(
)
ES3_OPENGL
(
)
ES2_OPENGLES
(
)
ES3_OPENGLES
(
)
)
;
ANGLE_INSTANTIATE_TEST
(
MipmapTestES3
ES3_D3D11
(
)
ES3_OPENGL
(
)
ES3_OPENGLES
(
)
)
;
