#
include
"
test_utils
/
ANGLETest
.
h
"
#
include
"
shader_utils
.
h
"
using
namespace
angle
;
namespace
{
const
GLint
kWidth
=
64
;
const
GLint
kHeight
=
64
;
class
EXTMultisampleCompatibilityTest
:
public
ANGLETest
{
protected
:
EXTMultisampleCompatibilityTest
(
)
{
setWindowWidth
(
64
)
;
setWindowHeight
(
64
)
;
setConfigRedBits
(
8
)
;
setConfigBlueBits
(
8
)
;
setConfigAlphaBits
(
8
)
;
}
void
SetUp
(
)
override
{
ANGLETest
:
:
SetUp
(
)
;
static
const
char
*
v_shader_str
=
"
attribute
vec4
a_Position
;
\
n
"
"
void
main
(
)
\
n
"
"
{
gl_Position
=
a_Position
;
}
"
;
static
const
char
*
f_shader_str
=
"
precision
mediump
float
;
\
n
"
"
uniform
vec4
color
;
"
"
void
main
(
)
{
gl_FragColor
=
color
;
}
"
;
mProgram
=
CompileProgram
(
v_shader_str
f_shader_str
)
;
GLuint
position_loc
=
glGetAttribLocation
(
mProgram
"
a_Position
"
)
;
mColorLoc
=
glGetUniformLocation
(
mProgram
"
color
"
)
;
glGenBuffers
(
1
&
mVBO
)
;
glBindBuffer
(
GL_ARRAY_BUFFER
mVBO
)
;
static
float
vertices
[
]
=
{
1
.
0f
1
.
0f
-
1
.
0f
1
.
0f
-
1
.
0f
-
1
.
0f
-
1
.
0f
1
.
0f
-
1
.
0f
-
1
.
0f
1
.
0f
-
1
.
0f
-
1
.
0f
-
1
.
0f
1
.
0f
-
1
.
0f
1
.
0f
1
.
0f
}
;
glBufferData
(
GL_ARRAY_BUFFER
sizeof
(
vertices
)
vertices
GL_STATIC_DRAW
)
;
glEnableVertexAttribArray
(
position_loc
)
;
glVertexAttribPointer
(
position_loc
2
GL_FLOAT
GL_FALSE
0
0
)
;
}
void
TearDown
(
)
override
{
glDeleteBuffers
(
1
&
mVBO
)
;
glDeleteProgram
(
mProgram
)
;
ANGLETest
:
:
TearDown
(
)
;
}
void
prepareForDraw
(
)
{
GLsizei
num_samples
=
4
max_samples
=
0
;
glGetIntegerv
(
GL_MAX_SAMPLES
&
max_samples
)
;
num_samples
=
std
:
:
min
(
num_samples
max_samples
)
;
glGenRenderbuffers
(
1
&
mSampleRB
)
;
glBindRenderbuffer
(
GL_RENDERBUFFER
mSampleRB
)
;
glRenderbufferStorageMultisampleANGLE
(
GL_RENDERBUFFER
num_samples
GL_RGBA8_OES
kWidth
kHeight
)
;
GLint
param
=
0
;
glGetRenderbufferParameteriv
(
GL_RENDERBUFFER
GL_RENDERBUFFER_SAMPLES
&
param
)
;
EXPECT_GE
(
param
num_samples
)
;
glGenFramebuffers
(
1
&
mSampleFBO
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mSampleFBO
)
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_RENDERBUFFER
mSampleRB
)
;
EXPECT_EQ
(
static_cast
<
GLenum
>
(
GL_FRAMEBUFFER_COMPLETE
)
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
0
)
;
glGenTextures
(
1
&
mResolveTex
)
;
glBindTexture
(
GL_TEXTURE_2D
mResolveTex
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA
kWidth
kHeight
0
GL_RGBA
GL_UNSIGNED_BYTE
NULL
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_LINEAR
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MAG_FILTER
GL_LINEAR
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_WRAP_S
GL_CLAMP_TO_EDGE
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_WRAP_T
GL_CLAMP_TO_EDGE
)
;
glGenFramebuffers
(
1
&
mResolveFBO
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mResolveFBO
)
;
glFramebufferTexture2D
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_TEXTURE_2D
mResolveTex
0
)
;
EXPECT_EQ
(
static_cast
<
GLenum
>
(
GL_FRAMEBUFFER_COMPLETE
)
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
glUseProgram
(
mProgram
)
;
glViewport
(
0
0
kWidth
kHeight
)
;
glBlendFunc
(
GL_SRC_ALPHA
GL_ONE_MINUS_SRC_ALPHA
)
;
glEnable
(
GL_BLEND
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mSampleFBO
)
;
glClearColor
(
0
.
0f
0
.
0f
0
.
0f
0
.
0f
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
}
void
prepareForVerify
(
)
{
glBindFramebuffer
(
GL_READ_FRAMEBUFFER
mSampleFBO
)
;
glBindFramebuffer
(
GL_DRAW_FRAMEBUFFER
mResolveFBO
)
;
glClearColor
(
1
.
0f
0
.
0f
0
.
0f
0
.
0f
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glBlitFramebufferANGLE
(
0
0
kWidth
kHeight
0
0
kWidth
kHeight
GL_COLOR_BUFFER_BIT
GL_NEAREST
)
;
glBindFramebuffer
(
GL_READ_FRAMEBUFFER
mResolveFBO
)
;
ASSERT_GL_NO_ERROR
(
)
;
}
void
cleanup
(
)
{
glBindFramebuffer
(
GL_FRAMEBUFFER
0
)
;
glDeleteFramebuffers
(
1
&
mResolveFBO
)
;
glDeleteFramebuffers
(
1
&
mSampleFBO
)
;
glDeleteTextures
(
1
&
mResolveTex
)
;
glDeleteRenderbuffers
(
1
&
mSampleRB
)
;
ASSERT_GL_NO_ERROR
(
)
;
}
bool
isApplicable
(
)
const
{
return
extensionEnabled
(
"
GL_EXT_multisample_compatibility
"
)
&
&
extensionEnabled
(
"
GL_ANGLE_framebuffer_multisample
"
)
&
&
extensionEnabled
(
"
GL_OES_rgb8_rgba8
"
)
&
&
!
IsAMD
(
)
;
}
GLuint
mSampleFBO
;
GLuint
mResolveFBO
;
GLuint
mSampleRB
;
GLuint
mResolveTex
;
GLuint
mColorLoc
;
GLuint
mProgram
;
GLuint
mVBO
;
}
;
}
TEST_P
(
EXTMultisampleCompatibilityTest
TestStateTracking
)
{
if
(
!
isApplicable
(
)
)
return
;
EXPECT_TRUE
(
glIsEnabled
(
GL_MULTISAMPLE_EXT
)
)
;
glDisable
(
GL_MULTISAMPLE_EXT
)
;
EXPECT_FALSE
(
glIsEnabled
(
GL_MULTISAMPLE_EXT
)
)
;
glEnable
(
GL_MULTISAMPLE_EXT
)
;
EXPECT_TRUE
(
glIsEnabled
(
GL_MULTISAMPLE_EXT
)
)
;
EXPECT_FALSE
(
glIsEnabled
(
GL_SAMPLE_ALPHA_TO_ONE_EXT
)
)
;
glEnable
(
GL_SAMPLE_ALPHA_TO_ONE_EXT
)
;
EXPECT_TRUE
(
glIsEnabled
(
GL_SAMPLE_ALPHA_TO_ONE_EXT
)
)
;
glDisable
(
GL_SAMPLE_ALPHA_TO_ONE_EXT
)
;
EXPECT_FALSE
(
glIsEnabled
(
GL_SAMPLE_ALPHA_TO_ONE_EXT
)
)
;
EXPECT_EQ
(
static_cast
<
GLenum
>
(
GL_NO_ERROR
)
glGetError
(
)
)
;
}
TEST_P
(
EXTMultisampleCompatibilityTest
DrawAndResolve
)
{
if
(
!
isApplicable
(
)
)
return
;
static
const
float
kBlue
[
]
=
{
0
.
0f
0
.
0f
1
.
0f
1
.
0f
}
;
static
const
float
kGreen
[
]
=
{
0
.
0f
1
.
0f
0
.
0f
1
.
0f
}
;
static
const
float
kRed
[
]
=
{
1
.
0f
0
.
0f
0
.
0f
1
.
0f
}
;
std
:
:
unique_ptr
<
uint8_t
[
]
>
results
[
3
]
;
const
GLint
kResultSize
=
kWidth
*
kHeight
*
4
;
for
(
int
pass
=
0
;
pass
<
3
;
pass
+
+
)
{
prepareForDraw
(
)
;
glUniform4fv
(
mColorLoc
1
kGreen
)
;
glDrawArrays
(
GL_TRIANGLES
0
3
)
;
glUniform4fv
(
mColorLoc
1
kBlue
)
;
glDrawArrays
(
GL_TRIANGLES
3
3
)
;
if
(
pass
=
=
1
)
{
glDisable
(
GL_MULTISAMPLE_EXT
)
;
}
glUniform4fv
(
mColorLoc
1
kRed
)
;
glDrawArrays
(
GL_TRIANGLES
6
3
)
;
if
(
pass
=
=
1
)
{
glEnable
(
GL_MULTISAMPLE_EXT
)
;
}
prepareForVerify
(
)
;
results
[
pass
]
.
reset
(
new
uint8_t
[
kResultSize
]
)
;
memset
(
results
[
pass
]
.
get
(
)
123u
kResultSize
)
;
glReadPixels
(
0
0
kWidth
kHeight
GL_RGBA
GL_UNSIGNED_BYTE
results
[
pass
]
.
get
(
)
)
;
cleanup
(
)
;
}
EXPECT_NE
(
0
memcmp
(
results
[
0
]
.
get
(
)
results
[
1
]
.
get
(
)
kResultSize
)
)
;
EXPECT_EQ
(
0
memcmp
(
results
[
0
]
.
get
(
)
results
[
2
]
.
get
(
)
kResultSize
)
)
;
}
TEST_P
(
EXTMultisampleCompatibilityTest
DrawAlphaOneAndResolve
)
{
if
(
!
isApplicable
(
)
)
return
;
static
const
float
kBlue
[
]
=
{
0
.
0f
0
.
0f
1
.
0f
0
.
5f
}
;
static
const
float
kGreen
[
]
=
{
0
.
0f
1
.
0f
0
.
0f
0
.
5f
}
;
static
const
float
kRed
[
]
=
{
1
.
0f
0
.
0f
0
.
0f
0
.
5f
}
;
std
:
:
unique_ptr
<
uint8_t
[
]
>
results
[
3
]
;
const
GLint
kResultSize
=
kWidth
*
kHeight
*
4
;
for
(
int
pass
=
0
;
pass
<
3
;
+
+
pass
)
{
prepareForDraw
(
)
;
if
(
pass
=
=
1
)
{
glEnable
(
GL_SAMPLE_ALPHA_TO_ONE_EXT
)
;
}
glEnable
(
GL_MULTISAMPLE_EXT
)
;
glUniform4fv
(
mColorLoc
1
kGreen
)
;
glDrawArrays
(
GL_TRIANGLES
0
3
)
;
glUniform4fv
(
mColorLoc
1
kBlue
)
;
glDrawArrays
(
GL_TRIANGLES
3
3
)
;
glDisable
(
GL_MULTISAMPLE_EXT
)
;
glUniform4fv
(
mColorLoc
1
kRed
)
;
glDrawArrays
(
GL_TRIANGLES
6
3
)
;
prepareForVerify
(
)
;
results
[
pass
]
.
reset
(
new
uint8_t
[
kResultSize
]
)
;
memset
(
results
[
pass
]
.
get
(
)
123u
kResultSize
)
;
glReadPixels
(
0
0
kWidth
kHeight
GL_RGBA
GL_UNSIGNED_BYTE
results
[
pass
]
.
get
(
)
)
;
if
(
pass
=
=
1
)
{
glDisable
(
GL_SAMPLE_ALPHA_TO_ONE_EXT
)
;
}
cleanup
(
)
;
}
EXPECT_NE
(
0
memcmp
(
results
[
0
]
.
get
(
)
results
[
1
]
.
get
(
)
kResultSize
)
)
;
EXPECT_EQ
(
0
memcmp
(
results
[
0
]
.
get
(
)
results
[
2
]
.
get
(
)
kResultSize
)
)
;
}
ANGLE_INSTANTIATE_TEST
(
EXTMultisampleCompatibilityTest
ES2_OPENGL
(
)
ES2_OPENGLES
(
)
ES3_OPENGL
(
)
)
;
