#
include
"
test_utils
/
ANGLETest
.
h
"
#
include
"
common
/
string_utils
.
h
"
using
namespace
angle
;
namespace
{
class
RendererTest
:
public
ANGLETest
{
protected
:
RendererTest
(
)
{
setWindowWidth
(
128
)
;
setWindowHeight
(
128
)
;
}
}
;
TEST_P
(
RendererTest
RequestedRendererCreated
)
{
std
:
:
string
rendererString
=
std
:
:
string
(
reinterpret_cast
<
const
char
*
>
(
glGetString
(
GL_RENDERER
)
)
)
;
angle
:
:
ToLower
(
&
rendererString
)
;
std
:
:
string
versionString
=
std
:
:
string
(
reinterpret_cast
<
const
char
*
>
(
glGetString
(
GL_VERSION
)
)
)
;
angle
:
:
ToLower
(
&
versionString
)
;
const
EGLPlatformParameters
&
platform
=
GetParam
(
)
.
eglParameters
;
if
(
platform
.
renderer
=
=
EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE
)
{
ASSERT_NE
(
rendererString
.
find
(
std
:
:
string
(
"
direct3d11
"
)
)
std
:
:
string
:
:
npos
)
;
}
if
(
platform
.
renderer
=
=
EGL_PLATFORM_ANGLE_TYPE_D3D9_ANGLE
)
{
ASSERT_NE
(
rendererString
.
find
(
std
:
:
string
(
"
direct3d9
"
)
)
std
:
:
string
:
:
npos
)
;
}
if
(
platform
.
renderer
=
=
EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE
)
{
if
(
platform
.
deviceType
=
=
EGL_PLATFORM_ANGLE_DEVICE_TYPE_WARP_ANGLE
)
{
auto
basicRenderPos
=
rendererString
.
find
(
std
:
:
string
(
"
microsoft
basic
render
"
)
)
;
auto
softwareAdapterPos
=
rendererString
.
find
(
std
:
:
string
(
"
software
adapter
"
)
)
;
ASSERT_TRUE
(
basicRenderPos
!
=
std
:
:
string
:
:
npos
|
|
softwareAdapterPos
!
=
std
:
:
string
:
:
npos
)
;
}
std
:
:
vector
<
std
:
:
string
>
acceptableShaderModels
;
if
(
platform
.
majorVersion
>
=
11
|
|
platform
.
majorVersion
=
=
EGL_DONT_CARE
)
{
acceptableShaderModels
.
push_back
(
"
ps_5_0
"
)
;
}
if
(
platform
.
majorVersion
>
=
10
|
|
platform
.
majorVersion
=
=
EGL_DONT_CARE
)
{
if
(
platform
.
minorVersion
>
=
1
|
|
platform
.
minorVersion
=
=
EGL_DONT_CARE
)
{
acceptableShaderModels
.
push_back
(
"
ps_4_1
"
)
;
}
if
(
platform
.
minorVersion
>
=
0
|
|
platform
.
minorVersion
=
=
EGL_DONT_CARE
)
{
acceptableShaderModels
.
push_back
(
"
ps_4_0
"
)
;
}
}
if
(
platform
.
majorVersion
=
=
9
&
&
platform
.
minorVersion
=
=
3
)
{
acceptableShaderModels
.
push_back
(
"
ps_4_0_level_9_3
"
)
;
}
bool
found
=
false
;
for
(
size_t
i
=
0
;
i
<
acceptableShaderModels
.
size
(
)
;
i
+
+
)
{
if
(
rendererString
.
find
(
acceptableShaderModels
[
i
]
)
!
=
std
:
:
string
:
:
npos
)
{
found
=
true
;
}
}
ASSERT_TRUE
(
found
)
;
}
if
(
platform
.
renderer
=
=
EGL_PLATFORM_ANGLE_TYPE_NULL_ANGLE
)
{
ASSERT_TRUE
(
IsNULL
(
)
)
;
}
if
(
platform
.
renderer
=
=
EGL_PLATFORM_ANGLE_TYPE_VULKAN_ANGLE
)
{
ASSERT_TRUE
(
IsVulkan
(
)
)
;
}
EGLint
glesMajorVersion
=
GetParam
(
)
.
majorVersion
;
EGLint
glesMinorVersion
=
GetParam
(
)
.
minorVersion
;
if
(
glesMajorVersion
=
=
3
&
&
glesMinorVersion
=
=
1
)
{
ASSERT_NE
(
versionString
.
find
(
std
:
:
string
(
"
es
3
.
1
"
)
)
std
:
:
string
:
:
npos
)
;
}
else
if
(
glesMajorVersion
=
=
3
&
&
glesMinorVersion
=
=
0
)
{
ASSERT_NE
(
versionString
.
find
(
std
:
:
string
(
"
es
3
.
0
"
)
)
std
:
:
string
:
:
npos
)
;
}
else
if
(
glesMajorVersion
=
=
2
&
&
glesMinorVersion
=
=
0
)
{
ASSERT_NE
(
versionString
.
find
(
std
:
:
string
(
"
es
2
.
0
"
)
)
std
:
:
string
:
:
npos
)
;
}
else
{
FAIL
(
)
<
<
"
Unhandled
GL
ES
client
version
.
"
;
}
ASSERT_GL_NO_ERROR
(
)
;
ASSERT_EGL_SUCCESS
(
)
;
}
TEST_P
(
RendererTest
SimpleOperation
)
{
if
(
IsNULL
(
)
)
{
std
:
:
cout
<
<
"
ANGLE
NULL
backend
clears
are
not
functional
"
<
<
std
:
:
endl
;
return
;
}
glClearColor
(
0
.
0f
1
.
0f
0
.
0f
1
.
0f
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
EXPECT_PIXEL_EQ
(
0
0
0
255
0
255
)
;
ASSERT_GL_NO_ERROR
(
)
;
}
ANGLE_INSTANTIATE_TEST
(
RendererTest
ES2_D3D9
(
)
ES2_D3D9_REFERENCE
(
)
ES2_D3D11
(
)
ES2_D3D11_FL11_0
(
)
ES2_D3D11_FL10_1
(
)
ES2_D3D11_FL10_0
(
)
ES2_D3D11_FL9_3
(
)
ES2_D3D11_WARP
(
)
ES2_D3D11_FL11_0_WARP
(
)
ES2_D3D11_FL10_1_WARP
(
)
ES2_D3D11_FL10_0_WARP
(
)
ES2_D3D11_FL9_3_WARP
(
)
ES2_D3D11_REFERENCE
(
)
ES2_D3D11_FL11_0_REFERENCE
(
)
ES2_D3D11_FL10_1_REFERENCE
(
)
ES2_D3D11_FL10_0_REFERENCE
(
)
ES2_D3D11_FL9_3_REFERENCE
(
)
ES3_D3D11
(
)
ES3_D3D11_FL11_0
(
)
ES3_D3D11_FL10_1
(
)
ES3_D3D11_WARP
(
)
ES3_D3D11_FL11_0_WARP
(
)
ES3_D3D11_FL10_1_WARP
(
)
ES3_D3D11_REFERENCE
(
)
ES3_D3D11_FL11_0_REFERENCE
(
)
ES3_D3D11_FL10_1_REFERENCE
(
)
ES2_OPENGL
(
)
ES2_OPENGL
(
2
1
)
ES2_OPENGL
(
3
0
)
ES2_OPENGL
(
3
1
)
ES2_OPENGL
(
3
2
)
ES2_OPENGL
(
3
3
)
ES2_OPENGL
(
4
0
)
ES2_OPENGL
(
4
1
)
ES2_OPENGL
(
4
2
)
ES2_OPENGL
(
4
3
)
ES2_OPENGL
(
4
4
)
ES2_OPENGL
(
4
5
)
ES3_OPENGL
(
)
ES3_OPENGL
(
3
2
)
ES3_OPENGL
(
3
3
)
ES3_OPENGL
(
4
0
)
ES3_OPENGL
(
4
1
)
ES3_OPENGL
(
4
2
)
ES3_OPENGL
(
4
3
)
ES3_OPENGL
(
4
4
)
ES3_OPENGL
(
4
5
)
ES2_OPENGLES
(
)
ES2_OPENGLES
(
2
0
)
ES2_OPENGLES
(
3
0
)
ES2_OPENGLES
(
3
1
)
ES2_OPENGLES
(
3
2
)
ES3_OPENGLES
(
)
ES3_OPENGLES
(
3
0
)
ES3_OPENGLES
(
3
1
)
ES3_OPENGLES
(
3
2
)
ES2_NULL
(
)
ES3_NULL
(
)
ES31_NULL
(
)
ES2_VULKAN
(
)
)
;
}
