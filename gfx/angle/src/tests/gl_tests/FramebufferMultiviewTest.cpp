#
include
"
test_utils
/
ANGLETest
.
h
"
#
include
"
test_utils
/
gl_raii
.
h
"
using
namespace
angle
;
namespace
{
std
:
:
vector
<
GLenum
>
GetDrawBufferRange
(
size_t
numColorAttachments
)
{
std
:
:
vector
<
GLenum
>
drawBuffers
(
numColorAttachments
)
;
const
size_t
kBase
=
static_cast
<
size_t
>
(
GL_COLOR_ATTACHMENT0
)
;
for
(
size_t
i
=
0u
;
i
<
drawBuffers
.
size
(
)
;
+
+
i
)
{
drawBuffers
[
i
]
=
static_cast
<
GLenum
>
(
kBase
+
i
)
;
}
return
drawBuffers
;
}
}
class
FramebufferMultiviewTest
:
public
ANGLETest
{
protected
:
FramebufferMultiviewTest
(
)
{
setWindowWidth
(
128
)
;
setWindowHeight
(
128
)
;
setWebGLCompatibilityEnabled
(
true
)
;
}
void
SetUp
(
)
override
{
ANGLETest
:
:
SetUp
(
)
;
glRequestExtensionANGLE
=
reinterpret_cast
<
PFNGLREQUESTEXTENSIONANGLEPROC
>
(
eglGetProcAddress
(
"
glRequestExtensionANGLE
"
)
)
;
}
bool
requestMultiviewExtension
(
)
{
if
(
extensionRequestable
(
"
GL_ANGLE_multiview
"
)
)
{
glRequestExtensionANGLE
(
"
GL_ANGLE_multiview
"
)
;
}
if
(
!
extensionEnabled
(
"
GL_ANGLE_multiview
"
)
)
{
std
:
:
cout
<
<
"
Test
skipped
due
to
missing
GL_ANGLE_multiview
.
"
<
<
std
:
:
endl
;
return
false
;
}
return
true
;
}
PFNGLREQUESTEXTENSIONANGLEPROC
glRequestExtensionANGLE
=
nullptr
;
}
;
class
FramebufferMultiviewSideBySideClearTest
:
public
FramebufferMultiviewTest
{
protected
:
FramebufferMultiviewSideBySideClearTest
(
)
{
}
void
initializeFBOs
(
size_t
numColorBuffers
bool
stencil
bool
depth
)
{
const
std
:
:
vector
<
GLenum
>
&
drawBuffers
=
GetDrawBufferRange
(
2
)
;
mColorTex
.
resize
(
numColorBuffers
)
;
for
(
size_t
i
=
0u
;
i
<
numColorBuffers
;
+
+
i
)
{
glBindTexture
(
GL_TEXTURE_2D
mColorTex
[
i
]
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA8
4
2
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
}
if
(
stencil
)
{
glBindTexture
(
GL_TEXTURE_2D
mStencilTex
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_DEPTH24_STENCIL8
4
2
0
GL_DEPTH_STENCIL
GL_UNSIGNED_INT_24_8
nullptr
)
;
}
else
if
(
depth
)
{
glBindTexture
(
GL_TEXTURE_2D
mDepthTex
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_DEPTH_COMPONENT32F
4
2
0
GL_DEPTH_COMPONENT
GL_FLOAT
nullptr
)
;
}
const
GLint
kViewportOffsets
[
4
]
=
{
1
0
3
0
}
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mMultiviewFBO
)
;
const
size_t
kBase
=
static_cast
<
size_t
>
(
GL_COLOR_ATTACHMENT0
)
;
for
(
size_t
i
=
0u
;
i
<
numColorBuffers
;
+
+
i
)
{
glFramebufferTextureMultiviewSideBySideANGLE
(
GL_FRAMEBUFFER
static_cast
<
GLenum
>
(
kBase
+
i
)
mColorTex
[
i
]
0
2
&
kViewportOffsets
[
0
]
)
;
}
if
(
stencil
)
{
glFramebufferTextureMultiviewSideBySideANGLE
(
GL_FRAMEBUFFER
GL_DEPTH_STENCIL_ATTACHMENT
mStencilTex
0
2
&
kViewportOffsets
[
0
]
)
;
}
else
if
(
depth
)
{
glFramebufferTextureMultiviewSideBySideANGLE
(
GL_FRAMEBUFFER
GL_DEPTH_ATTACHMENT
mDepthTex
0
2
&
kViewportOffsets
[
0
]
)
;
}
glDrawBuffers
(
static_cast
<
GLsizei
>
(
drawBuffers
.
size
(
)
)
drawBuffers
.
data
(
)
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mNonMultiviewFBO
)
;
for
(
size_t
i
=
0u
;
i
<
numColorBuffers
;
+
+
i
)
{
glFramebufferTexture2D
(
GL_FRAMEBUFFER
static_cast
<
GLenum
>
(
kBase
+
i
)
GL_TEXTURE_2D
mColorTex
[
i
]
0
)
;
}
if
(
stencil
)
{
glFramebufferTexture2D
(
GL_FRAMEBUFFER
GL_DEPTH_STENCIL_ATTACHMENT
GL_TEXTURE_2D
mStencilTex
0
)
;
}
else
if
(
depth
)
{
glFramebufferTexture2D
(
GL_FRAMEBUFFER
GL_DEPTH_ATTACHMENT
GL_TEXTURE_2D
mDepthTex
0
)
;
}
glDrawBuffers
(
static_cast
<
GLsizei
>
(
drawBuffers
.
size
(
)
)
drawBuffers
.
data
(
)
)
;
ASSERT_GL_NO_ERROR
(
)
;
}
void
checkAlternatingColumnsOfRedAndGreenInFBO
(
)
{
EXPECT_PIXEL_COLOR_EQ
(
0
0
GLColor
:
:
red
)
;
EXPECT_PIXEL_COLOR_EQ
(
0
1
GLColor
:
:
red
)
;
EXPECT_PIXEL_COLOR_EQ
(
1
0
GLColor
:
:
green
)
;
EXPECT_PIXEL_COLOR_EQ
(
1
1
GLColor
:
:
green
)
;
EXPECT_PIXEL_COLOR_EQ
(
2
0
GLColor
:
:
red
)
;
EXPECT_PIXEL_COLOR_EQ
(
2
1
GLColor
:
:
red
)
;
EXPECT_PIXEL_COLOR_EQ
(
3
0
GLColor
:
:
green
)
;
EXPECT_PIXEL_COLOR_EQ
(
3
1
GLColor
:
:
green
)
;
}
GLFramebuffer
mMultiviewFBO
;
GLFramebuffer
mNonMultiviewFBO
;
std
:
:
vector
<
GLTexture
>
mColorTex
;
GLTexture
mDepthTex
;
GLTexture
mStencilTex
;
}
;
class
FramebufferMultiviewLayeredClearTest
:
public
FramebufferMultiviewTest
{
protected
:
FramebufferMultiviewLayeredClearTest
(
)
{
}
void
initializeFBOs
(
int
width
int
height
int
numLayers
int
baseViewIndex
int
numViews
int
numColorAttachments
bool
stencil
bool
depth
)
{
ASSERT
(
baseViewIndex
+
numViews
<
=
numLayers
)
;
mColorTex
.
resize
(
numColorAttachments
)
;
for
(
int
i
=
0
;
i
<
numColorAttachments
;
+
+
i
)
{
glBindTexture
(
GL_TEXTURE_2D_ARRAY
mColorTex
[
i
]
)
;
glTexImage3D
(
GL_TEXTURE_2D_ARRAY
0
GL_RGBA8
width
height
numLayers
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
}
if
(
stencil
)
{
glBindTexture
(
GL_TEXTURE_2D_ARRAY
mStencilTex
)
;
glTexImage3D
(
GL_TEXTURE_2D_ARRAY
0
GL_DEPTH24_STENCIL8
width
height
numLayers
0
GL_DEPTH_STENCIL
GL_UNSIGNED_INT_24_8
nullptr
)
;
}
else
if
(
depth
)
{
glBindTexture
(
GL_TEXTURE_2D_ARRAY
mDepthTex
)
;
glTexImage3D
(
GL_TEXTURE_2D_ARRAY
0
GL_DEPTH_COMPONENT32F
width
height
numLayers
0
GL_DEPTH_COMPONENT
GL_FLOAT
nullptr
)
;
}
glBindFramebuffer
(
GL_FRAMEBUFFER
mMultiviewFBO
)
;
for
(
int
i
=
0
;
i
<
numColorAttachments
;
+
+
i
)
{
glFramebufferTextureMultiviewLayeredANGLE
(
GL_FRAMEBUFFER
static_cast
<
GLenum
>
(
GL_COLOR_ATTACHMENT0
+
i
)
mColorTex
[
i
]
0
baseViewIndex
numViews
)
;
}
if
(
stencil
)
{
glFramebufferTextureMultiviewLayeredANGLE
(
GL_FRAMEBUFFER
GL_DEPTH_STENCIL_ATTACHMENT
mStencilTex
0
baseViewIndex
numViews
)
;
}
else
if
(
depth
)
{
glFramebufferTextureMultiviewLayeredANGLE
(
GL_FRAMEBUFFER
GL_DEPTH_ATTACHMENT
mDepthTex
0
baseViewIndex
numViews
)
;
}
const
auto
&
drawBuffers
=
GetDrawBufferRange
(
numColorAttachments
)
;
glDrawBuffers
(
numColorAttachments
drawBuffers
.
data
(
)
)
;
mNonMultiviewFBO
.
resize
(
numLayers
)
;
for
(
int
i
=
0
;
i
<
numLayers
;
+
+
i
)
{
glBindFramebuffer
(
GL_FRAMEBUFFER
mNonMultiviewFBO
[
i
]
)
;
for
(
int
j
=
0
;
j
<
numColorAttachments
;
+
+
j
)
{
glFramebufferTextureLayer
(
GL_FRAMEBUFFER
static_cast
<
GLenum
>
(
GL_COLOR_ATTACHMENT0
+
j
)
mColorTex
[
j
]
0
i
)
;
}
if
(
stencil
)
{
glFramebufferTextureLayer
(
GL_FRAMEBUFFER
GL_DEPTH_STENCIL_ATTACHMENT
mStencilTex
0
i
)
;
}
else
if
(
depth
)
{
glFramebufferTextureLayer
(
GL_FRAMEBUFFER
GL_DEPTH_ATTACHMENT
mDepthTex
0
i
)
;
}
glDrawBuffers
(
numColorAttachments
drawBuffers
.
data
(
)
)
;
glClearColor
(
1
0
0
1
)
;
glClear
(
GL_COLOR_BUFFER_BIT
|
GL_DEPTH_BUFFER_BIT
|
GL_STENCIL_BUFFER_BIT
)
;
}
ASSERT_GL_NO_ERROR
(
)
;
}
GLColor
getLayerColor
(
size_t
layer
GLenum
attachment
GLint
x
GLint
y
)
{
ASSERT
(
layer
<
mNonMultiviewFBO
.
size
(
)
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mNonMultiviewFBO
[
layer
]
)
;
glReadBuffer
(
attachment
)
;
return
angle
:
:
ReadColor
(
x
y
)
;
}
GLColor
getLayerColor
(
size_t
layer
GLenum
attachment
)
{
return
getLayerColor
(
layer
attachment
0
0
)
;
}
GLFramebuffer
mMultiviewFBO
;
std
:
:
vector
<
GLFramebuffer
>
mNonMultiviewFBO
;
std
:
:
vector
<
GLTexture
>
mColorTex
;
GLTexture
mDepthTex
;
GLTexture
mStencilTex
;
}
;
TEST_P
(
FramebufferMultiviewTest
DefaultState
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_2D
tex
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA8
1
1
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
glFramebufferTexture2D
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_TEXTURE_2D
tex
0
)
;
GLint
numViews
=
-
1
;
glGetFramebufferAttachmentParameteriv
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_ANGLE
&
numViews
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_EQ
(
1
numViews
)
;
GLint
baseViewIndex
=
-
1
;
glGetFramebufferAttachmentParameteriv
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_ANGLE
&
baseViewIndex
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_EQ
(
0
baseViewIndex
)
;
GLint
multiviewLayout
=
GL_FRAMEBUFFER_MULTIVIEW_SIDE_BY_SIDE_ANGLE
;
glGetFramebufferAttachmentParameteriv
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_MULTIVIEW_LAYOUT_ANGLE
&
multiviewLayout
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_EQ
(
GL_NONE
multiviewLayout
)
;
GLint
viewportOffsets
[
2
]
=
{
-
1
-
1
}
;
glGetFramebufferAttachmentParameteriv
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_VIEWPORT_OFFSETS_ANGLE
&
viewportOffsets
[
0
]
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_EQ
(
0
viewportOffsets
[
0
]
)
;
EXPECT_EQ
(
0
viewportOffsets
[
1
]
)
;
}
TEST_P
(
FramebufferMultiviewTest
NegativeFramebufferStateQueries
)
{
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_2D
tex
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA8
1
1
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
glFramebufferTexture2D
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_TEXTURE_2D
tex
0
)
;
GLint
numViews
=
-
1
;
glGetFramebufferAttachmentParameteriv
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_ANGLE
&
numViews
)
;
EXPECT_GL_ERROR
(
GL_INVALID_ENUM
)
;
GLint
baseViewIndex
=
-
1
;
glGetFramebufferAttachmentParameteriv
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_ANGLE
&
baseViewIndex
)
;
EXPECT_GL_ERROR
(
GL_INVALID_ENUM
)
;
GLint
multiviewLayout
=
GL_FRAMEBUFFER_MULTIVIEW_SIDE_BY_SIDE_ANGLE
;
glGetFramebufferAttachmentParameteriv
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_MULTIVIEW_LAYOUT_ANGLE
&
multiviewLayout
)
;
EXPECT_GL_ERROR
(
GL_INVALID_ENUM
)
;
GLint
viewportOffsets
[
2
]
=
{
-
1
-
1
}
;
glGetFramebufferAttachmentParameteriv
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_VIEWPORT_OFFSETS_ANGLE
&
viewportOffsets
[
0
]
)
;
EXPECT_GL_ERROR
(
GL_INVALID_ENUM
)
;
}
TEST_P
(
FramebufferMultiviewTest
InvalidMultiviewSideBySideArguments
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_2D
tex
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA8
1
1
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
GLint
viewportOffsets
[
2
]
=
{
-
1
}
;
glFramebufferTextureMultiviewSideBySideANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
tex
0
1
&
viewportOffsets
[
0
]
)
;
EXPECT_GL_ERROR
(
GL_INVALID_VALUE
)
;
viewportOffsets
[
0
]
=
0
;
viewportOffsets
[
1
]
=
0
;
glFramebufferTextureMultiviewSideBySideANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
tex
0
-
1
&
viewportOffsets
[
0
]
)
;
EXPECT_GL_ERROR
(
GL_INVALID_VALUE
)
;
}
TEST_P
(
FramebufferMultiviewTest
InvalidMultiviewLayeredArguments
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_2D_ARRAY
tex
)
;
glTexImage3D
(
GL_TEXTURE_2D_ARRAY
0
GL_RGBA8
1
1
2
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
ASSERT_GL_NO_ERROR
(
)
;
glFramebufferTextureMultiviewLayeredANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
tex
0
-
1
1
)
;
EXPECT_GL_ERROR
(
GL_INVALID_VALUE
)
;
GLint
maxTextureLayers
=
0
;
glGetIntegerv
(
GL_MAX_ARRAY_TEXTURE_LAYERS
&
maxTextureLayers
)
;
glFramebufferTextureMultiviewLayeredANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
tex
0
maxTextureLayers
1
)
;
EXPECT_GL_ERROR
(
GL_INVALID_VALUE
)
;
}
TEST_P
(
FramebufferMultiviewTest
ExtensionNotAvailableCheck
)
{
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_2D
tex
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA8
1
1
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
ASSERT_GL_NO_ERROR
(
)
;
const
GLint
kViewportOffsets
[
2
]
=
{
0
}
;
glFramebufferTextureMultiviewSideBySideANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
tex
0
1
&
kViewportOffsets
[
0
]
)
;
EXPECT_GL_ERROR
(
GL_INVALID_OPERATION
)
;
}
TEST_P
(
FramebufferMultiviewTest
ModifySideBySideState
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_2D
tex
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA8
1
1
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
const
GLint
kViewportOffsets
[
4
]
=
{
0
0
1
2
}
;
glFramebufferTextureMultiviewSideBySideANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
tex
0
2
&
kViewportOffsets
[
0
]
)
;
ASSERT_GL_NO_ERROR
(
)
;
GLint
numViews
=
-
1
;
glGetFramebufferAttachmentParameteriv
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_ANGLE
&
numViews
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_EQ
(
2
numViews
)
;
GLint
baseViewIndex
=
-
1
;
glGetFramebufferAttachmentParameteriv
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_ANGLE
&
baseViewIndex
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_EQ
(
0
baseViewIndex
)
;
GLint
multiviewLayout
=
GL_NONE
;
glGetFramebufferAttachmentParameteriv
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_MULTIVIEW_LAYOUT_ANGLE
&
multiviewLayout
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_EQ
(
GL_FRAMEBUFFER_MULTIVIEW_SIDE_BY_SIDE_ANGLE
multiviewLayout
)
;
GLint
internalViewportOffsets
[
4
]
=
{
-
1
}
;
glGetFramebufferAttachmentParameteriv
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_VIEWPORT_OFFSETS_ANGLE
&
internalViewportOffsets
[
0
]
)
;
ASSERT_GL_NO_ERROR
(
)
;
for
(
size_t
i
=
0u
;
i
<
4u
;
+
+
i
)
{
EXPECT_EQ
(
kViewportOffsets
[
i
]
internalViewportOffsets
[
i
]
)
;
}
}
TEST_P
(
FramebufferMultiviewTest
IncompleteViewTargetsSideBySide
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_2D
tex
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA8
1
1
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
const
GLint
kViewportOffsets
[
4
]
=
{
0
0
2
0
}
;
const
GLint
kOtherViewportOffsets
[
4
]
=
{
2
0
4
0
}
;
glFramebufferTextureMultiviewSideBySideANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
tex
0
2
&
kViewportOffsets
[
0
]
)
;
ASSERT_GL_NO_ERROR
(
)
;
{
GLTexture
otherTex
;
glBindTexture
(
GL_TEXTURE_2D
otherTex
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA8
1
1
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
glFramebufferTextureMultiviewSideBySideANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT1
otherTex
0
1
&
kViewportOffsets
[
0
]
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_GLENUM_EQ
(
GL_FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_ANGLE
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
glFramebufferTextureMultiviewSideBySideANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT1
otherTex
0
2
&
kOtherViewportOffsets
[
0
]
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_GLENUM_EQ
(
GL_FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_ANGLE
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
glFramebufferTexture2D
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT1
GL_TEXTURE_2D
otherTex
0
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_GLENUM_EQ
(
GL_FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_ANGLE
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
glFramebufferTextureMultiviewSideBySideANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT1
otherTex
0
2
&
kViewportOffsets
[
0
]
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_GLENUM_EQ
(
GL_FRAMEBUFFER_COMPLETE
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
glFramebufferTextureMultiviewSideBySideANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT1
0
0
1
&
kViewportOffsets
[
0
]
)
;
}
{
GLTexture
depthTex
;
glBindTexture
(
GL_TEXTURE_2D
depthTex
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_DEPTH_COMPONENT32F
1
1
0
GL_DEPTH_COMPONENT
GL_FLOAT
nullptr
)
;
glFramebufferTextureMultiviewSideBySideANGLE
(
GL_FRAMEBUFFER
GL_DEPTH_ATTACHMENT
depthTex
0
1
&
kViewportOffsets
[
0
]
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_GLENUM_EQ
(
GL_FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_ANGLE
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
glFramebufferTextureMultiviewSideBySideANGLE
(
GL_FRAMEBUFFER
GL_DEPTH_ATTACHMENT
depthTex
0
2
&
kOtherViewportOffsets
[
0
]
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_GLENUM_EQ
(
GL_FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_ANGLE
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
glFramebufferTexture2D
(
GL_FRAMEBUFFER
GL_DEPTH_ATTACHMENT
GL_TEXTURE_2D
depthTex
0
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_GLENUM_EQ
(
GL_FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_ANGLE
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
glFramebufferTextureMultiviewSideBySideANGLE
(
GL_FRAMEBUFFER
GL_DEPTH_ATTACHMENT
depthTex
0
2
&
kViewportOffsets
[
0
]
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_GLENUM_EQ
(
GL_FRAMEBUFFER_COMPLETE
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
}
}
TEST_P
(
FramebufferMultiviewTest
InvalidCopyTex
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_2D
tex
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA8
1
1
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
const
GLint
kViewportOffsets
[
2
]
=
{
0
}
;
glFramebufferTextureMultiviewSideBySideANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
tex
0
1
&
kViewportOffsets
[
0
]
)
;
ASSERT_GL_NO_ERROR
(
)
;
{
GLTexture
tex2
;
glBindTexture
(
GL_TEXTURE_2D
tex2
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA8
1
1
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
glCopyTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA8
0
0
1
1
0
)
;
EXPECT_GL_ERROR
(
GL_INVALID_FRAMEBUFFER_OPERATION
)
;
glCopyTexSubImage2D
(
GL_TEXTURE_2D
0
0
0
0
0
1
1
)
;
EXPECT_GL_ERROR
(
GL_INVALID_FRAMEBUFFER_OPERATION
)
;
}
{
GLTexture
tex2
;
glBindTexture
(
GL_TEXTURE_3D
tex2
)
;
glTexImage3D
(
GL_TEXTURE_3D
0
GL_RGBA8
1
1
1
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
glCopyTexSubImage3D
(
GL_TEXTURE_3D
0
0
0
0
0
0
1
1
)
;
EXPECT_GL_ERROR
(
GL_INVALID_FRAMEBUFFER_OPERATION
)
;
}
}
TEST_P
(
FramebufferMultiviewTest
InvalidBlit
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_2D
tex
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA8
1
1
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
const
GLint
kViewportOffsets
[
2
]
=
{
0
}
;
glFramebufferTextureMultiviewSideBySideANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
tex
0
1
&
kViewportOffsets
[
0
]
)
;
ASSERT_GLENUM_EQ
(
GL_FRAMEBUFFER_COMPLETE
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
ASSERT_GL_NO_ERROR
(
)
;
{
glBindFramebuffer
(
GL_READ_FRAMEBUFFER
fbo
)
;
glBindFramebuffer
(
GL_DRAW_FRAMEBUFFER
0
)
;
glBlitFramebuffer
(
0
0
1
1
0
0
1
1
GL_COLOR_BUFFER_BIT
GL_NEAREST
)
;
EXPECT_GL_ERROR
(
GL_INVALID_FRAMEBUFFER_OPERATION
)
;
}
{
glBindFramebuffer
(
GL_READ_FRAMEBUFFER
0
)
;
glBindFramebuffer
(
GL_DRAW_FRAMEBUFFER
fbo
)
;
glBlitFramebuffer
(
0
0
1
1
0
0
1
1
GL_COLOR_BUFFER_BIT
GL_NEAREST
)
;
EXPECT_GL_ERROR
(
GL_INVALID_FRAMEBUFFER_OPERATION
)
;
}
}
TEST_P
(
FramebufferMultiviewTest
InvalidReadPixels
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_2D
tex
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA8
1
1
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
const
GLint
kViewportOffsets
[
2
]
=
{
0
}
;
glFramebufferTextureMultiviewSideBySideANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
tex
0
1
&
kViewportOffsets
[
0
]
)
;
ASSERT_GLENUM_EQ
(
GL_FRAMEBUFFER_COMPLETE
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
ASSERT_GL_NO_ERROR
(
)
;
GLColor
pixelColor
;
glReadPixels
(
0
0
1
1
GL_RGBA
GL_UNSIGNED_BYTE
&
pixelColor
.
R
)
;
EXPECT_GL_ERROR
(
GL_INVALID_FRAMEBUFFER_OPERATION
)
;
}
TEST_P
(
FramebufferMultiviewSideBySideClearTest
ColorBufferClear
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
initializeFBOs
(
1
false
false
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mNonMultiviewFBO
)
;
glClearColor
(
1
0
0
1
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mMultiviewFBO
)
;
glViewport
(
0
0
1
2
)
;
glScissor
(
0
0
1
2
)
;
glEnable
(
GL_SCISSOR_TEST
)
;
glClearColor
(
0
1
0
1
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mNonMultiviewFBO
)
;
checkAlternatingColumnsOfRedAndGreenInFBO
(
)
;
}
TEST_P
(
FramebufferMultiviewTest
ModifyLayeredState
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
GLFramebuffer
multiviewFBO
;
glBindFramebuffer
(
GL_FRAMEBUFFER
multiviewFBO
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_2D_ARRAY
tex
)
;
glTexImage3D
(
GL_TEXTURE_2D_ARRAY
0
GL_RGBA8
1
1
4
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
ASSERT_GL_NO_ERROR
(
)
;
glFramebufferTextureMultiviewLayeredANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
tex
0
1
2
)
;
ASSERT_GL_NO_ERROR
(
)
;
GLint
numViews
=
-
1
;
glGetFramebufferAttachmentParameteriv
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_ANGLE
&
numViews
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_EQ
(
2
numViews
)
;
GLint
baseViewIndex
=
-
1
;
glGetFramebufferAttachmentParameteriv
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_ANGLE
&
baseViewIndex
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_EQ
(
1
baseViewIndex
)
;
GLint
multiviewLayout
=
GL_NONE
;
glGetFramebufferAttachmentParameteriv
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_MULTIVIEW_LAYOUT_ANGLE
&
multiviewLayout
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_EQ
(
GL_FRAMEBUFFER_MULTIVIEW_LAYERED_ANGLE
multiviewLayout
)
;
GLint
internalViewportOffsets
[
2
]
=
{
-
1
}
;
glGetFramebufferAttachmentParameteriv
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_VIEWPORT_OFFSETS_ANGLE
&
internalViewportOffsets
[
0
]
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_EQ
(
0
internalViewportOffsets
[
0
]
)
;
EXPECT_EQ
(
0
internalViewportOffsets
[
1
]
)
;
}
TEST_P
(
FramebufferMultiviewTest
IncompleteViewTargetsLayered
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_2D_ARRAY
tex
)
;
glTexImage3D
(
GL_TEXTURE_2D_ARRAY
0
GL_RGBA8
1
1
4
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
glFramebufferTextureMultiviewLayeredANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
tex
0
0
2
)
;
ASSERT_GL_NO_ERROR
(
)
;
GLTexture
otherTexLayered
;
glBindTexture
(
GL_TEXTURE_2D_ARRAY
otherTexLayered
)
;
glTexImage3D
(
GL_TEXTURE_2D_ARRAY
0
GL_RGBA8
1
1
4
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
glFramebufferTextureMultiviewLayeredANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT1
otherTexLayered
0
1
2
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_GLENUM_EQ
(
GL_FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_ANGLE
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
const
int
kViewportOffsets
[
4
]
=
{
0
0
0
0
}
;
GLTexture
otherTex2D
;
glBindTexture
(
GL_TEXTURE_2D
otherTex2D
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA8
4
2
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
glFramebufferTextureMultiviewSideBySideANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT1
otherTex2D
0
2
kViewportOffsets
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_GLENUM_EQ
(
GL_FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_ANGLE
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
glFramebufferTextureLayer
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT1
otherTexLayered
0
0
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_GLENUM_EQ
(
GL_FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_ANGLE
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
glFramebufferTextureMultiviewLayeredANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT1
otherTexLayered
0
0
2
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_GLENUM_EQ
(
GL_FRAMEBUFFER_COMPLETE
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
}
TEST_P
(
FramebufferMultiviewSideBySideClearTest
ClearWithDisabledScissorTest
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
initializeFBOs
(
1
false
false
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mNonMultiviewFBO
)
;
glClearColor
(
0
0
0
1
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mMultiviewFBO
)
;
glViewport
(
0
0
1
2
)
;
glScissor
(
0
0
1
2
)
;
glClearColor
(
1
0
0
1
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mNonMultiviewFBO
)
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
for
(
int
j
=
0
;
j
<
2
;
+
+
j
)
{
EXPECT_PIXEL_COLOR_EQ
(
i
j
GLColor
:
:
red
)
;
}
}
}
TEST_P
(
FramebufferMultiviewSideBySideClearTest
DepthBufferClear
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
const
std
:
:
string
&
vs
=
"
#
version
300
es
\
n
"
"
in
vec3
vPos
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_Position
=
vec4
(
vPos
1
.
)
;
\
n
"
"
}
\
n
"
;
const
std
:
:
string
&
fs
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
vec3
uCol
;
\
n
"
"
out
vec4
col
;
\
n
"
"
void
main
(
)
{
\
n
"
"
col
=
vec4
(
uCol
1
.
)
;
\
n
"
"
}
\
n
"
;
ANGLE_GL_PROGRAM
(
program
vs
fs
)
;
glUseProgram
(
program
)
;
GLuint
mColorUniformLoc
=
glGetUniformLocation
(
program
"
uCol
"
)
;
initializeFBOs
(
1
false
true
)
;
glEnable
(
GL_DEPTH_TEST
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mNonMultiviewFBO
)
;
glClearColor
(
0
0
0
0
)
;
glClear
(
GL_COLOR_BUFFER_BIT
|
GL_DEPTH_BUFFER_BIT
)
;
glUniform3f
(
mColorUniformLoc
1
.
0f
0
.
0f
0
.
0f
)
;
drawQuad
(
program
"
vPos
"
0
.
0f
1
.
0f
true
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mMultiviewFBO
)
;
glViewport
(
0
0
1
2
)
;
glScissor
(
0
0
1
2
)
;
glEnable
(
GL_SCISSOR_TEST
)
;
glClear
(
GL_DEPTH_BUFFER_BIT
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mNonMultiviewFBO
)
;
glViewport
(
0
0
4
2
)
;
glScissor
(
0
0
4
2
)
;
glUniform3f
(
mColorUniformLoc
0
.
0f
1
.
0f
0
.
0f
)
;
drawQuad
(
program
"
vPos
"
0
.
5f
1
.
0f
true
)
;
checkAlternatingColumnsOfRedAndGreenInFBO
(
)
;
}
TEST_P
(
FramebufferMultiviewSideBySideClearTest
StencilBufferClear
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
const
std
:
:
string
&
vs
=
"
#
version
300
es
\
n
"
"
in
vec3
vPos
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_Position
=
vec4
(
vPos
1
.
)
;
\
n
"
"
}
\
n
"
;
const
std
:
:
string
&
fs
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
vec3
uCol
;
\
n
"
"
out
vec4
col
;
\
n
"
"
void
main
(
)
{
\
n
"
"
col
=
vec4
(
uCol
1
.
)
;
\
n
"
"
}
\
n
"
;
ANGLE_GL_PROGRAM
(
program
vs
fs
)
;
glUseProgram
(
program
)
;
GLuint
mColorUniformLoc
=
glGetUniformLocation
(
program
"
uCol
"
)
;
initializeFBOs
(
1
true
false
)
;
glEnable
(
GL_STENCIL_TEST
)
;
glDisable
(
GL_DEPTH_TEST
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mNonMultiviewFBO
)
;
glClearColor
(
0
0
0
0
)
;
glClearStencil
(
0
)
;
glClear
(
GL_COLOR_BUFFER_BIT
|
GL_STENCIL_BUFFER_BIT
)
;
glStencilOp
(
GL_KEEP
GL_KEEP
GL_REPLACE
)
;
glStencilFunc
(
GL_ALWAYS
0xFF
0
)
;
glUniform3f
(
mColorUniformLoc
1
.
0f
0
.
0f
0
.
0f
)
;
drawQuad
(
program
"
vPos
"
0
.
0f
1
.
0f
true
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mMultiviewFBO
)
;
glViewport
(
0
0
1
2
)
;
glScissor
(
0
0
1
2
)
;
glEnable
(
GL_SCISSOR_TEST
)
;
glClear
(
GL_STENCIL_BUFFER_BIT
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mNonMultiviewFBO
)
;
glViewport
(
0
0
4
2
)
;
glScissor
(
0
0
4
2
)
;
glStencilFunc
(
GL_EQUAL
0x00
0xFF
)
;
glUniform3f
(
mColorUniformLoc
0
.
0f
1
.
0f
0
.
0f
)
;
drawQuad
(
program
"
vPos
"
0
.
0f
1
.
0f
true
)
;
checkAlternatingColumnsOfRedAndGreenInFBO
(
)
;
}
TEST_P
(
FramebufferMultiviewSideBySideClearTest
ClearBufferF
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
initializeFBOs
(
2
false
false
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mNonMultiviewFBO
)
;
glClearColor
(
1
0
0
1
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mMultiviewFBO
)
;
glViewport
(
0
0
1
2
)
;
glScissor
(
0
0
1
2
)
;
glEnable
(
GL_SCISSOR_TEST
)
;
float
kClearValues
[
4
]
=
{
0
.
f
1
.
f
0
.
f
1
.
f
}
;
glClearBufferfv
(
GL_COLOR
1
kClearValues
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mNonMultiviewFBO
)
;
glReadBuffer
(
GL_COLOR_ATTACHMENT0
)
;
for
(
int
i
=
0
;
i
<
4
;
+
+
i
)
{
for
(
int
j
=
0
;
j
<
2
;
+
+
j
)
{
EXPECT_PIXEL_COLOR_EQ
(
i
j
GLColor
:
:
red
)
;
}
}
glReadBuffer
(
GL_COLOR_ATTACHMENT1
)
;
checkAlternatingColumnsOfRedAndGreenInFBO
(
)
;
}
TEST_P
(
FramebufferMultiviewLayeredClearTest
ColorBufferClear
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
initializeFBOs
(
1
1
4
1
2
1
false
false
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mMultiviewFBO
)
;
glClearColor
(
0
1
0
1
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
0
GL_COLOR_ATTACHMENT0
)
)
;
EXPECT_EQ
(
GLColor
:
:
green
getLayerColor
(
1
GL_COLOR_ATTACHMENT0
)
)
;
EXPECT_EQ
(
GLColor
:
:
green
getLayerColor
(
2
GL_COLOR_ATTACHMENT0
)
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
3
GL_COLOR_ATTACHMENT0
)
)
;
}
TEST_P
(
FramebufferMultiviewLayeredClearTest
ClearIndividualColorBuffer
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
initializeFBOs
(
1
1
4
1
2
2
false
false
)
;
for
(
int
i
=
0
;
i
<
2
;
+
+
i
)
{
for
(
int
layer
=
0
;
layer
<
4
;
+
+
layer
)
{
GLenum
colorAttachment
=
static_cast
<
GLenum
>
(
GL_COLOR_ATTACHMENT0
+
i
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
layer
colorAttachment
)
)
;
}
}
glBindFramebuffer
(
GL_FRAMEBUFFER
mMultiviewFBO
)
;
float
clearValues0
[
4
]
=
{
0
.
f
0
.
f
1
.
f
1
.
f
}
;
glClearBufferfv
(
GL_COLOR
0
clearValues0
)
;
float
clearValues1
[
4
]
=
{
0
.
f
1
.
f
0
.
f
1
.
f
}
;
glClearBufferfv
(
GL_COLOR
1
clearValues1
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
0
GL_COLOR_ATTACHMENT0
)
)
;
EXPECT_EQ
(
GLColor
:
:
blue
getLayerColor
(
1
GL_COLOR_ATTACHMENT0
)
)
;
EXPECT_EQ
(
GLColor
:
:
blue
getLayerColor
(
2
GL_COLOR_ATTACHMENT0
)
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
3
GL_COLOR_ATTACHMENT0
)
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
0
GL_COLOR_ATTACHMENT1
)
)
;
EXPECT_EQ
(
GLColor
:
:
green
getLayerColor
(
1
GL_COLOR_ATTACHMENT1
)
)
;
EXPECT_EQ
(
GLColor
:
:
green
getLayerColor
(
2
GL_COLOR_ATTACHMENT1
)
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
3
GL_COLOR_ATTACHMENT1
)
)
;
}
TEST_P
(
FramebufferMultiviewLayeredClearTest
ClearBufferfi
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
const
std
:
:
string
&
vs
=
"
#
version
300
es
\
n
"
"
in
vec3
vPos
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_Position
=
vec4
(
vPos
1
.
)
;
\
n
"
"
}
\
n
"
;
const
std
:
:
string
&
fs
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
vec3
uCol
;
\
n
"
"
out
vec4
col
;
\
n
"
"
void
main
(
)
{
\
n
"
"
col
=
vec4
(
uCol
1
.
)
;
\
n
"
"
}
\
n
"
;
ANGLE_GL_PROGRAM
(
program
vs
fs
)
;
glUseProgram
(
program
)
;
GLuint
mColorUniformLoc
=
glGetUniformLocation
(
program
"
uCol
"
)
;
initializeFBOs
(
1
1
4
1
2
1
true
false
)
;
glEnable
(
GL_STENCIL_TEST
)
;
glDisable
(
GL_DEPTH_TEST
)
;
glClearColor
(
1
0
0
1
)
;
glClearStencil
(
0xFF
)
;
for
(
size_t
i
=
0u
;
i
<
mNonMultiviewFBO
.
size
(
)
;
+
+
i
)
{
glBindFramebuffer
(
GL_FRAMEBUFFER
mNonMultiviewFBO
[
i
]
)
;
glClear
(
GL_COLOR_BUFFER_BIT
|
GL_STENCIL_BUFFER_BIT
)
;
}
glBindFramebuffer
(
GL_FRAMEBUFFER
mMultiviewFBO
)
;
glClearBufferfi
(
GL_DEPTH_STENCIL
0
0
.
0f
0
)
;
glStencilOp
(
GL_KEEP
GL_KEEP
GL_REPLACE
)
;
glStencilFunc
(
GL_EQUAL
0x00
0xFF
)
;
for
(
size_t
i
=
0u
;
i
<
mNonMultiviewFBO
.
size
(
)
;
+
+
i
)
{
glBindFramebuffer
(
GL_FRAMEBUFFER
mNonMultiviewFBO
[
i
]
)
;
glUniform3f
(
mColorUniformLoc
0
.
0f
1
.
0f
0
.
0f
)
;
drawQuad
(
program
"
vPos
"
0
.
0f
1
.
0f
true
)
;
}
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
0
GL_COLOR_ATTACHMENT0
)
)
;
EXPECT_EQ
(
GLColor
:
:
green
getLayerColor
(
1
GL_COLOR_ATTACHMENT0
)
)
;
EXPECT_EQ
(
GLColor
:
:
green
getLayerColor
(
2
GL_COLOR_ATTACHMENT0
)
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
3
GL_COLOR_ATTACHMENT0
)
)
;
}
TEST_P
(
FramebufferMultiviewLayeredClearTest
UnmodifiedDetachedTexture
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
initializeFBOs
(
1
1
4
1
2
2
false
false
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mMultiviewFBO
)
;
glClearColor
(
0
1
0
1
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
for
(
int
i
=
0
;
i
<
2
;
+
+
i
)
{
GLenum
colorAttachment
=
static_cast
<
GLenum
>
(
GL_COLOR_ATTACHMENT0
+
i
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
0
colorAttachment
)
)
;
EXPECT_EQ
(
GLColor
:
:
green
getLayerColor
(
1
colorAttachment
)
)
;
EXPECT_EQ
(
GLColor
:
:
green
getLayerColor
(
2
colorAttachment
)
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
3
colorAttachment
)
)
;
}
glBindFramebuffer
(
GL_FRAMEBUFFER
mMultiviewFBO
)
;
glFramebufferTextureMultiviewLayeredANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT1
0
0
1
2
)
;
glClearColor
(
1
1
0
1
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
0
GL_COLOR_ATTACHMENT0
)
)
;
EXPECT_EQ
(
GLColor
:
:
yellow
getLayerColor
(
1
GL_COLOR_ATTACHMENT0
)
)
;
EXPECT_EQ
(
GLColor
:
:
yellow
getLayerColor
(
2
GL_COLOR_ATTACHMENT0
)
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
3
GL_COLOR_ATTACHMENT0
)
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
0
GL_COLOR_ATTACHMENT1
)
)
;
EXPECT_EQ
(
GLColor
:
:
green
getLayerColor
(
1
GL_COLOR_ATTACHMENT1
)
)
;
EXPECT_EQ
(
GLColor
:
:
green
getLayerColor
(
2
GL_COLOR_ATTACHMENT1
)
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
3
GL_COLOR_ATTACHMENT1
)
)
;
}
TEST_P
(
FramebufferMultiviewLayeredClearTest
ScissoredClear
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
initializeFBOs
(
2
1
4
1
2
1
false
false
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mMultiviewFBO
)
;
glEnable
(
GL_SCISSOR_TEST
)
;
glScissor
(
1
0
1
1
)
;
glClearColor
(
0
1
0
1
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
0
GL_COLOR_ATTACHMENT0
0
0
)
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
0
GL_COLOR_ATTACHMENT0
1
0
)
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
1
GL_COLOR_ATTACHMENT0
0
0
)
)
;
EXPECT_EQ
(
GLColor
:
:
green
getLayerColor
(
1
GL_COLOR_ATTACHMENT0
1
0
)
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
2
GL_COLOR_ATTACHMENT0
0
0
)
)
;
EXPECT_EQ
(
GLColor
:
:
green
getLayerColor
(
2
GL_COLOR_ATTACHMENT0
1
0
)
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
3
GL_COLOR_ATTACHMENT0
0
0
)
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
3
GL_COLOR_ATTACHMENT0
1
0
)
)
;
}
TEST_P
(
FramebufferMultiviewLayeredClearTest
ScissoredClearBufferfi
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
const
std
:
:
string
&
vs
=
"
#
version
300
es
\
n
"
"
in
vec3
vPos
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_Position
=
vec4
(
vPos
1
.
)
;
\
n
"
"
}
\
n
"
;
const
std
:
:
string
&
fs
=
"
#
version
300
es
\
n
"
"
precision
mediump
float
;
\
n
"
"
uniform
vec3
uCol
;
\
n
"
"
out
vec4
col
;
\
n
"
"
void
main
(
)
{
\
n
"
"
col
=
vec4
(
uCol
1
.
)
;
\
n
"
"
}
\
n
"
;
ANGLE_GL_PROGRAM
(
program
vs
fs
)
;
glUseProgram
(
program
)
;
GLuint
mColorUniformLoc
=
glGetUniformLocation
(
program
"
uCol
"
)
;
initializeFBOs
(
1
2
4
1
2
1
true
false
)
;
glEnable
(
GL_STENCIL_TEST
)
;
glDisable
(
GL_DEPTH_TEST
)
;
glClearColor
(
1
0
0
1
)
;
glClearStencil
(
0xFF
)
;
for
(
size_t
i
=
0u
;
i
<
mNonMultiviewFBO
.
size
(
)
;
+
+
i
)
{
glBindFramebuffer
(
GL_FRAMEBUFFER
mNonMultiviewFBO
[
i
]
)
;
glClear
(
GL_COLOR_BUFFER_BIT
|
GL_STENCIL_BUFFER_BIT
)
;
}
glBindFramebuffer
(
GL_FRAMEBUFFER
mMultiviewFBO
)
;
glEnable
(
GL_SCISSOR_TEST
)
;
glScissor
(
0
0
1
1
)
;
glClearBufferfi
(
GL_DEPTH_STENCIL
0
0
.
0f
0
)
;
glDisable
(
GL_SCISSOR_TEST
)
;
glStencilOp
(
GL_KEEP
GL_KEEP
GL_REPLACE
)
;
glStencilFunc
(
GL_EQUAL
0x00
0xFF
)
;
for
(
size_t
i
=
0u
;
i
<
mNonMultiviewFBO
.
size
(
)
;
+
+
i
)
{
glBindFramebuffer
(
GL_FRAMEBUFFER
mNonMultiviewFBO
[
i
]
)
;
glUniform3f
(
mColorUniformLoc
0
.
0f
1
.
0f
0
.
0f
)
;
drawQuad
(
program
"
vPos
"
0
.
0f
1
.
0f
true
)
;
}
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
0
GL_COLOR_ATTACHMENT0
0
0
)
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
0
GL_COLOR_ATTACHMENT0
0
1
)
)
;
EXPECT_EQ
(
GLColor
:
:
green
getLayerColor
(
1
GL_COLOR_ATTACHMENT0
0
0
)
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
1
GL_COLOR_ATTACHMENT0
0
1
)
)
;
EXPECT_EQ
(
GLColor
:
:
green
getLayerColor
(
2
GL_COLOR_ATTACHMENT0
0
0
)
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
2
GL_COLOR_ATTACHMENT0
0
1
)
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
3
GL_COLOR_ATTACHMENT0
0
0
)
)
;
EXPECT_EQ
(
GLColor
:
:
red
getLayerColor
(
3
GL_COLOR_ATTACHMENT0
0
1
)
)
;
}
TEST_P
(
FramebufferMultiviewTest
InvalidMultiviewArgumentsOnDetach
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
glFramebufferTextureMultiviewLayeredANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
0
0
-
1
1
)
;
EXPECT_GL_NO_ERROR
(
)
;
glFramebufferTextureMultiviewLayeredANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
0
0
0
0
)
;
EXPECT_GL_NO_ERROR
(
)
;
const
GLint
kValidViewportOffsets
[
2
]
=
{
0
0
}
;
glFramebufferTextureMultiviewSideBySideANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
0
0
0
kValidViewportOffsets
)
;
EXPECT_GL_NO_ERROR
(
)
;
const
GLint
kInvalidViewportOffsets
[
2
]
=
{
-
1
-
1
}
;
glFramebufferTextureMultiviewSideBySideANGLE
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
0
0
1
kInvalidViewportOffsets
)
;
EXPECT_GL_NO_ERROR
(
)
;
}
TEST_P
(
FramebufferMultiviewLayeredClearTest
ColorBufferClearAllLayersAttached
)
{
if
(
!
requestMultiviewExtension
(
)
)
{
return
;
}
initializeFBOs
(
1
1
2
0
2
1
false
false
)
;
glBindFramebuffer
(
GL_FRAMEBUFFER
mMultiviewFBO
)
;
glClearColor
(
0
1
0
1
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
EXPECT_EQ
(
GLColor
:
:
green
getLayerColor
(
0
GL_COLOR_ATTACHMENT0
)
)
;
EXPECT_EQ
(
GLColor
:
:
green
getLayerColor
(
1
GL_COLOR_ATTACHMENT0
)
)
;
}
ANGLE_INSTANTIATE_TEST
(
FramebufferMultiviewTest
ES3_OPENGL
(
)
)
;
ANGLE_INSTANTIATE_TEST
(
FramebufferMultiviewSideBySideClearTest
ES3_OPENGL
(
)
ES3_D3D11
(
)
)
;
ANGLE_INSTANTIATE_TEST
(
FramebufferMultiviewLayeredClearTest
ES3_OPENGL
(
)
ES3_D3D11
(
)
)
;
