#
include
"
test_utils
/
ANGLETest
.
h
"
#
include
"
test_utils
/
gl_raii
.
h
"
namespace
angle
{
class
WebGLFramebufferTest
:
public
ANGLETest
{
protected
:
WebGLFramebufferTest
(
)
{
setWindowWidth
(
128
)
;
setWindowHeight
(
128
)
;
setConfigRedBits
(
8
)
;
setConfigGreenBits
(
8
)
;
setConfigBlueBits
(
8
)
;
setConfigAlphaBits
(
8
)
;
setWebGLCompatibilityEnabled
(
true
)
;
}
void
SetUp
(
)
override
{
ANGLETest
:
:
SetUp
(
)
;
glRequestExtensionANGLE
=
reinterpret_cast
<
PFNGLREQUESTEXTENSIONANGLEPROC
>
(
eglGetProcAddress
(
"
glRequestExtensionANGLE
"
)
)
;
}
void
drawUByteColorQuad
(
GLuint
program
GLint
uniformLoc
const
GLColor
&
color
)
;
void
testDepthStencilDepthStencil
(
GLint
width
GLint
height
)
;
void
testDepthStencilRenderbuffer
(
GLint
width
GLint
height
GLRenderbuffer
*
colorBuffer
GLbitfield
allowedStatuses
)
;
void
testRenderingAndReading
(
GLuint
program
)
;
void
testUsingIncompleteFramebuffer
(
GLenum
depthFormat
GLenum
depthAttachment
)
;
void
testDrawingMissingAttachment
(
)
;
PFNGLREQUESTEXTENSIONANGLEPROC
glRequestExtensionANGLE
=
nullptr
;
}
;
constexpr
GLint
ALLOW_COMPLETE
=
0x1
;
constexpr
GLint
ALLOW_UNSUPPORTED
=
0x2
;
constexpr
GLint
ALLOW_INCOMPLETE_ATTACHMENT
=
0x4
;
void
checkFramebufferForAllowedStatuses
(
GLbitfield
allowedStatuses
)
{
GLenum
status
=
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
;
bool
statusAllowed
=
(
(
allowedStatuses
&
ALLOW_COMPLETE
)
&
&
(
status
=
=
GL_FRAMEBUFFER_COMPLETE
)
)
|
|
(
(
allowedStatuses
&
ALLOW_UNSUPPORTED
)
&
&
(
status
=
=
GL_FRAMEBUFFER_UNSUPPORTED
)
)
|
|
(
(
allowedStatuses
&
ALLOW_INCOMPLETE_ATTACHMENT
)
&
&
(
status
=
=
GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
)
)
;
EXPECT_TRUE
(
statusAllowed
)
;
}
void
checkBufferBits
(
GLenum
attachment0
GLenum
attachment1
)
{
if
(
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
!
=
GL_FRAMEBUFFER_COMPLETE
)
return
;
bool
haveDepthBuffer
=
attachment0
=
=
GL_DEPTH_ATTACHMENT
|
|
attachment0
=
=
GL_DEPTH_STENCIL_ATTACHMENT
|
|
attachment1
=
=
GL_DEPTH_ATTACHMENT
|
|
attachment1
=
=
GL_DEPTH_STENCIL_ATTACHMENT
;
bool
haveStencilBuffer
=
attachment0
=
=
GL_STENCIL_ATTACHMENT
|
|
attachment0
=
=
GL_DEPTH_STENCIL_ATTACHMENT
|
|
attachment1
=
=
GL_STENCIL_ATTACHMENT
|
|
attachment1
=
=
GL_DEPTH_STENCIL_ATTACHMENT
;
GLint
redBits
=
0
;
GLint
greenBits
=
0
;
GLint
blueBits
=
0
;
GLint
alphaBits
=
0
;
GLint
depthBits
=
0
;
GLint
stencilBits
=
0
;
glGetIntegerv
(
GL_RED_BITS
&
redBits
)
;
glGetIntegerv
(
GL_GREEN_BITS
&
greenBits
)
;
glGetIntegerv
(
GL_BLUE_BITS
&
blueBits
)
;
glGetIntegerv
(
GL_ALPHA_BITS
&
alphaBits
)
;
glGetIntegerv
(
GL_DEPTH_BITS
&
depthBits
)
;
glGetIntegerv
(
GL_STENCIL_BITS
&
stencilBits
)
;
EXPECT_GE
(
redBits
+
greenBits
+
blueBits
+
alphaBits
16
)
;
if
(
haveDepthBuffer
)
EXPECT_GE
(
depthBits
16
)
;
else
EXPECT_EQ
(
0
depthBits
)
;
if
(
haveStencilBuffer
)
EXPECT_GE
(
stencilBits
8
)
;
else
EXPECT_EQ
(
0
stencilBits
)
;
}
TEST_P
(
WebGLFramebufferTest
TestFramebufferRequiredCombinations
)
{
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
constexpr
int
width
=
64
;
constexpr
int
height
=
64
;
GLTexture
texture
;
glBindTexture
(
GL_TEXTURE_2D
texture
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MIN_FILTER
GL_NEAREST
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_MAG_FILTER
GL_NEAREST
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_WRAP_S
GL_CLAMP_TO_EDGE
)
;
glTexParameteri
(
GL_TEXTURE_2D
GL_TEXTURE_WRAP_T
GL_CLAMP_TO_EDGE
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA
width
height
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
glFramebufferTexture2D
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_TEXTURE_2D
texture
0
)
;
EXPECT_GL_NO_ERROR
(
)
;
checkFramebufferForAllowedStatuses
(
ALLOW_COMPLETE
)
;
checkBufferBits
(
GL_NONE
GL_NONE
)
;
GLRenderbuffer
renderbuffer
;
glBindRenderbuffer
(
GL_RENDERBUFFER
renderbuffer
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
GL_DEPTH_COMPONENT16
width
height
)
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
GL_DEPTH_ATTACHMENT
GL_RENDERBUFFER
renderbuffer
)
;
EXPECT_GL_NO_ERROR
(
)
;
checkFramebufferForAllowedStatuses
(
ALLOW_COMPLETE
)
;
checkBufferBits
(
GL_DEPTH_ATTACHMENT
GL_NONE
)
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
GL_DEPTH_ATTACHMENT
GL_RENDERBUFFER
0
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
GL_DEPTH_STENCIL
width
height
)
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
GL_DEPTH_STENCIL_ATTACHMENT
GL_RENDERBUFFER
renderbuffer
)
;
EXPECT_GL_NO_ERROR
(
)
;
checkFramebufferForAllowedStatuses
(
ALLOW_COMPLETE
)
;
checkBufferBits
(
GL_DEPTH_STENCIL_ATTACHMENT
GL_NONE
)
;
}
void
testAttachment
(
GLint
width
GLint
height
GLRenderbuffer
*
colorBuffer
GLenum
attachment
GLRenderbuffer
*
buffer
GLbitfield
allowedStatuses
)
{
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_RENDERBUFFER
*
colorBuffer
)
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
attachment
GL_RENDERBUFFER
*
buffer
)
;
EXPECT_GL_NO_ERROR
(
)
;
checkFramebufferForAllowedStatuses
(
allowedStatuses
)
;
if
(
(
allowedStatuses
&
ALLOW_COMPLETE
)
=
=
0
)
{
std
:
:
vector
<
uint8_t
>
tempBuffer
(
width
*
height
*
4
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
EXPECT_GL_ERROR
(
GL_INVALID_FRAMEBUFFER_OPERATION
)
;
glReadPixels
(
0
0
width
height
GL_RGBA
GL_UNSIGNED_BYTE
tempBuffer
.
data
(
)
)
;
EXPECT_GL_ERROR
(
GL_INVALID_FRAMEBUFFER_OPERATION
)
;
}
checkBufferBits
(
attachment
GL_NONE
)
;
}
void
testAttachments
(
GLRenderbuffer
&
colorBuffer
GLenum
attachment0
GLRenderbuffer
&
buffer0
GLenum
attachment1
GLRenderbuffer
&
buffer1
GLbitfield
allowedStatuses
)
{
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_RENDERBUFFER
colorBuffer
)
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
attachment0
GL_RENDERBUFFER
buffer0
)
;
EXPECT_GL_NO_ERROR
(
)
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
attachment1
GL_RENDERBUFFER
buffer1
)
;
EXPECT_GL_NO_ERROR
(
)
;
checkFramebufferForAllowedStatuses
(
allowedStatuses
)
;
checkBufferBits
(
attachment0
attachment1
)
;
}
void
testColorRenderbuffer
(
GLint
width
GLint
height
GLenum
internalformat
GLbitfield
allowedStatuses
)
{
GLRenderbuffer
colorBuffer
;
glBindRenderbuffer
(
GL_RENDERBUFFER
colorBuffer
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
internalformat
width
height
)
;
EXPECT_GL_NO_ERROR
(
)
;
testAttachment
(
width
height
&
colorBuffer
GL_COLOR_ATTACHMENT0
&
colorBuffer
allowedStatuses
)
;
}
GLint
getRenderbufferParameter
(
GLenum
paramName
)
{
GLint
paramValue
=
0
;
glGetRenderbufferParameteriv
(
GL_RENDERBUFFER
paramName
&
paramValue
)
;
return
paramValue
;
}
void
WebGLFramebufferTest
:
:
drawUByteColorQuad
(
GLuint
program
GLint
uniformLoc
const
GLColor
&
color
)
{
Vector4
vecColor
=
color
.
toNormalizedVector
(
)
;
glUseProgram
(
program
)
;
glUniform4fv
(
uniformLoc
1
vecColor
.
data
(
)
)
;
drawQuad
(
program
"
position
"
0
.
5f
1
.
0f
true
)
;
}
void
WebGLFramebufferTest
:
:
testDepthStencilDepthStencil
(
GLint
width
GLint
height
)
{
const
std
:
:
string
&
vertexShader
=
"
attribute
vec4
position
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_Position
=
position
;
\
n
"
"
}
"
;
const
std
:
:
string
&
fragmentShader
=
"
precision
mediump
float
;
\
n
"
"
uniform
vec4
color
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
color
;
\
n
"
"
}
"
;
if
(
width
=
=
0
|
|
height
=
=
0
)
{
return
;
}
ANGLE_GL_PROGRAM
(
program
vertexShader
fragmentShader
)
;
GLint
uniformLoc
=
glGetUniformLocation
(
program
.
get
(
)
"
color
"
)
;
ASSERT_NE
(
-
1
uniformLoc
)
;
struct
TestInfo
{
GLenum
firstFormat
;
GLenum
firstAttach
;
GLenum
secondFormat
;
GLenum
secondAttach
;
}
;
TestInfo
tests
[
2
]
=
{
{
GL_DEPTH_COMPONENT16
GL_DEPTH_ATTACHMENT
GL_DEPTH_STENCIL
GL_DEPTH_STENCIL_ATTACHMENT
}
{
GL_DEPTH_STENCIL
GL_DEPTH_STENCIL_ATTACHMENT
GL_DEPTH_COMPONENT16
GL_DEPTH_ATTACHMENT
}
}
;
for
(
const
TestInfo
&
test
:
tests
)
{
for
(
GLint
opIndex
=
0
;
opIndex
<
2
;
+
+
opIndex
)
{
GLFramebuffer
fbo
;
GLTexture
tex
;
GLRenderbuffer
firstRb
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
glBindTexture
(
GL_TEXTURE_2D
tex
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA
width
height
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
glFramebufferTexture2D
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_TEXTURE_2D
tex
0
)
;
glBindRenderbuffer
(
GL_RENDERBUFFER
firstRb
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
test
.
firstFormat
width
height
)
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
test
.
firstAttach
GL_RENDERBUFFER
firstRb
)
;
EXPECT_GLENUM_EQ
(
GL_FRAMEBUFFER_COMPLETE
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
glClear
(
GL_DEPTH_BUFFER_BIT
)
;
glEnable
(
GL_DEPTH_TEST
)
;
drawUByteColorQuad
(
program
.
get
(
)
uniformLoc
GLColor
:
:
green
)
;
drawUByteColorQuad
(
program
.
get
(
)
uniformLoc
GLColor
:
:
red
)
;
EXPECT_PIXEL_COLOR_EQ
(
0
0
GLColor
:
:
green
)
;
GLuint
secondRb
=
0
;
glGenRenderbuffers
(
1
&
secondRb
)
;
glBindRenderbuffer
(
GL_RENDERBUFFER
secondRb
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
test
.
secondFormat
width
height
)
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
test
.
secondAttach
GL_RENDERBUFFER
secondRb
)
;
if
(
opIndex
=
=
0
)
{
glDeleteRenderbuffers
(
1
&
secondRb
)
;
secondRb
=
0
;
}
else
{
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
test
.
secondAttach
GL_RENDERBUFFER
0
)
;
}
EXPECT_GLENUM_EQ
(
GL_FRAMEBUFFER_COMPLETE
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
)
;
EXPECT_GL_NO_ERROR
(
)
;
glClear
(
GL_DEPTH_BUFFER_BIT
)
;
drawUByteColorQuad
(
program
.
get
(
)
uniformLoc
GLColor
:
:
green
)
;
drawUByteColorQuad
(
program
.
get
(
)
uniformLoc
GLColor
:
:
red
)
;
EXPECT_PIXEL_COLOR_EQ
(
0
0
GLColor
:
:
green
)
;
glDisable
(
GL_DEPTH_TEST
)
;
if
(
opIndex
=
=
1
)
{
glDeleteRenderbuffers
(
1
&
secondRb
)
;
secondRb
=
0
;
}
}
}
EXPECT_GL_NO_ERROR
(
)
;
}
void
WebGLFramebufferTest
:
:
testDepthStencilRenderbuffer
(
GLint
width
GLint
height
GLRenderbuffer
*
colorBuffer
GLbitfield
allowedStatuses
)
{
GLRenderbuffer
depthStencilBuffer
;
glBindRenderbuffer
(
GL_RENDERBUFFER
depthStencilBuffer
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
GL_DEPTH_STENCIL
width
height
)
;
EXPECT_GL_NO_ERROR
(
)
;
if
(
!
(
height
=
=
0
&
&
width
>
0
)
)
EXPECT_EQ
(
width
getRenderbufferParameter
(
GL_RENDERBUFFER_WIDTH
)
)
;
if
(
!
(
width
=
=
0
&
&
height
>
0
)
)
EXPECT_EQ
(
height
getRenderbufferParameter
(
GL_RENDERBUFFER_HEIGHT
)
)
;
EXPECT_EQ
(
GL_DEPTH_STENCIL
getRenderbufferParameter
(
GL_RENDERBUFFER_INTERNAL_FORMAT
)
)
;
EXPECT_EQ
(
0
getRenderbufferParameter
(
GL_RENDERBUFFER_RED_SIZE
)
)
;
EXPECT_EQ
(
0
getRenderbufferParameter
(
GL_RENDERBUFFER_GREEN_SIZE
)
)
;
EXPECT_EQ
(
0
getRenderbufferParameter
(
GL_RENDERBUFFER_BLUE_SIZE
)
)
;
EXPECT_EQ
(
0
getRenderbufferParameter
(
GL_RENDERBUFFER_ALPHA_SIZE
)
)
;
if
(
width
>
0
&
&
height
>
0
)
{
EXPECT_GT
(
getRenderbufferParameter
(
GL_RENDERBUFFER_DEPTH_SIZE
)
0
)
;
EXPECT_GT
(
getRenderbufferParameter
(
GL_RENDERBUFFER_STENCIL_SIZE
)
0
)
;
}
EXPECT_GL_NO_ERROR
(
)
;
testAttachment
(
width
height
colorBuffer
GL_DEPTH_STENCIL_ATTACHMENT
&
depthStencilBuffer
allowedStatuses
)
;
testDepthStencilDepthStencil
(
width
height
)
;
}
TEST_P
(
WebGLFramebufferTest
TestAttachments
)
{
for
(
GLint
width
=
2
;
width
<
=
2
;
width
+
=
2
)
{
for
(
GLint
height
=
2
;
height
<
=
2
;
height
+
=
2
)
{
GLRenderbuffer
colorBuffer
;
glBindRenderbuffer
(
GL_RENDERBUFFER
colorBuffer
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
GL_RGBA4
width
height
)
;
EXPECT_GL_NO_ERROR
(
)
;
GLRenderbuffer
depthBuffer
;
glBindRenderbuffer
(
GL_RENDERBUFFER
depthBuffer
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
GL_DEPTH_COMPONENT16
width
height
)
;
EXPECT_GL_NO_ERROR
(
)
;
GLRenderbuffer
stencilBuffer
;
glBindRenderbuffer
(
GL_RENDERBUFFER
stencilBuffer
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
GL_STENCIL_INDEX8
width
height
)
;
EXPECT_GL_NO_ERROR
(
)
;
GLRenderbuffer
depthStencilBuffer
;
glBindRenderbuffer
(
GL_RENDERBUFFER
depthStencilBuffer
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
GL_DEPTH_STENCIL
width
height
)
;
EXPECT_GL_NO_ERROR
(
)
;
GLbitfield
allowedStatusForGoodCase
=
(
width
=
=
0
|
|
height
=
=
0
)
?
ALLOW_INCOMPLETE_ATTACHMENT
:
ALLOW_COMPLETE
;
GLbitfield
allowedStatusForImplDependentCase
=
allowedStatusForGoodCase
|
ALLOW_UNSUPPORTED
;
testAttachment
(
width
height
&
colorBuffer
GL_DEPTH_ATTACHMENT
&
depthBuffer
allowedStatusForGoodCase
)
;
testAttachment
(
width
height
&
colorBuffer
GL_STENCIL_ATTACHMENT
&
depthBuffer
ALLOW_INCOMPLETE_ATTACHMENT
)
;
testAttachment
(
width
height
&
colorBuffer
GL_DEPTH_STENCIL_ATTACHMENT
&
depthBuffer
ALLOW_INCOMPLETE_ATTACHMENT
)
;
testAttachment
(
width
height
&
colorBuffer
GL_STENCIL_ATTACHMENT
&
stencilBuffer
allowedStatusForImplDependentCase
)
;
testAttachment
(
width
height
&
colorBuffer
GL_DEPTH_ATTACHMENT
&
stencilBuffer
ALLOW_INCOMPLETE_ATTACHMENT
)
;
testAttachment
(
width
height
&
colorBuffer
GL_DEPTH_STENCIL_ATTACHMENT
&
stencilBuffer
ALLOW_INCOMPLETE_ATTACHMENT
)
;
testAttachment
(
width
height
&
colorBuffer
GL_DEPTH_STENCIL_ATTACHMENT
&
depthStencilBuffer
allowedStatusForGoodCase
)
;
testAttachment
(
width
height
&
colorBuffer
GL_DEPTH_ATTACHMENT
&
depthStencilBuffer
ALLOW_INCOMPLETE_ATTACHMENT
)
;
testAttachment
(
width
height
&
colorBuffer
GL_STENCIL_ATTACHMENT
&
depthStencilBuffer
ALLOW_INCOMPLETE_ATTACHMENT
)
;
GLbitfield
allowedStatusForConflictedAttachment
=
(
width
=
=
0
|
|
height
=
=
0
)
?
ALLOW_UNSUPPORTED
|
ALLOW_INCOMPLETE_ATTACHMENT
:
ALLOW_UNSUPPORTED
;
testAttachments
(
colorBuffer
GL_DEPTH_ATTACHMENT
depthBuffer
GL_STENCIL_ATTACHMENT
stencilBuffer
allowedStatusForConflictedAttachment
)
;
testAttachments
(
colorBuffer
GL_STENCIL_ATTACHMENT
stencilBuffer
GL_DEPTH_ATTACHMENT
depthBuffer
allowedStatusForConflictedAttachment
)
;
testAttachments
(
colorBuffer
GL_DEPTH_ATTACHMENT
depthBuffer
GL_DEPTH_STENCIL_ATTACHMENT
depthStencilBuffer
allowedStatusForConflictedAttachment
)
;
testAttachments
(
colorBuffer
GL_DEPTH_STENCIL_ATTACHMENT
depthStencilBuffer
GL_DEPTH_ATTACHMENT
depthBuffer
allowedStatusForConflictedAttachment
)
;
testAttachments
(
colorBuffer
GL_DEPTH_ATTACHMENT
depthBuffer
GL_DEPTH_STENCIL_ATTACHMENT
depthStencilBuffer
allowedStatusForConflictedAttachment
)
;
testAttachments
(
colorBuffer
GL_DEPTH_STENCIL_ATTACHMENT
depthStencilBuffer
GL_STENCIL_ATTACHMENT
stencilBuffer
allowedStatusForConflictedAttachment
)
;
testColorRenderbuffer
(
width
height
GL_RGBA4
allowedStatusForGoodCase
)
;
if
(
!
(
IsNVIDIA
(
)
&
&
IsOSX
(
)
&
&
IsOpenGL
(
)
)
)
{
testColorRenderbuffer
(
width
height
GL_RGB5_A1
allowedStatusForGoodCase
)
;
}
testColorRenderbuffer
(
width
height
GL_RGB565
allowedStatusForGoodCase
)
;
testDepthStencilRenderbuffer
(
width
height
&
colorBuffer
allowedStatusForGoodCase
)
;
}
}
}
bool
tryDepth
(
GLRenderbuffer
*
depthBuffer
GLenum
*
depthFormat
GLenum
*
depthAttachment
GLenum
try_format
GLenum
try_attachment
)
{
if
(
*
depthAttachment
!
=
GL_NONE
)
{
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
*
depthAttachment
GL_RENDERBUFFER
0
)
;
}
*
depthFormat
=
try_format
;
*
depthAttachment
=
try_attachment
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
*
depthAttachment
GL_RENDERBUFFER
*
depthBuffer
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
*
depthFormat
16
16
)
;
EXPECT_GL_NO_ERROR
(
)
;
return
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
=
=
GL_FRAMEBUFFER_COMPLETE
;
}
bool
checkValidColorDepthCombination
(
GLenum
*
depthFormat
GLenum
*
depthAttachment
)
{
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
GLRenderbuffer
colorBuffer
;
glBindRenderbuffer
(
GL_RENDERBUFFER
colorBuffer
)
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_RENDERBUFFER
colorBuffer
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
GL_RGBA4
16
16
)
;
GLRenderbuffer
depthBuffer
;
glBindRenderbuffer
(
GL_RENDERBUFFER
depthBuffer
)
;
return
tryDepth
(
&
depthBuffer
depthFormat
depthAttachment
GL_DEPTH_COMPONENT16
GL_DEPTH_ATTACHMENT
)
|
|
tryDepth
(
&
depthBuffer
depthFormat
depthAttachment
GL_DEPTH_STENCIL
GL_DEPTH_STENCIL_ATTACHMENT
)
;
}
void
checkFramebuffer
(
GLenum
expected
)
{
GLenum
actual
=
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
;
EXPECT_TRUE
(
actual
=
=
expected
|
|
(
expected
!
=
GL_FRAMEBUFFER_COMPLETE
&
&
actual
=
=
GL_FRAMEBUFFER_UNSUPPORTED
)
)
;
}
void
WebGLFramebufferTest
:
:
testRenderingAndReading
(
GLuint
program
)
{
EXPECT_GL_NO_ERROR
(
)
;
drawQuad
(
program
"
position
"
0
.
5f
1
.
0f
true
)
;
EXPECT_GL_ERROR
(
GL_INVALID_FRAMEBUFFER_OPERATION
)
;
std
:
:
vector
<
uint8_t
>
dummyBuffer
(
4
)
;
glReadPixels
(
0
0
1
1
GL_RGBA
GL_UNSIGNED_BYTE
dummyBuffer
.
data
(
)
)
;
EXPECT_GL_ERROR
(
GL_INVALID_FRAMEBUFFER_OPERATION
)
;
glCopyTexSubImage2D
(
GL_TEXTURE_2D
0
0
0
0
0
1
1
)
;
GLenum
error
=
glGetError
(
)
;
EXPECT_TRUE
(
error
=
=
GL_INVALID_FRAMEBUFFER_OPERATION
|
|
error
=
=
GL_INVALID_OPERATION
)
;
glCopyTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA
0
0
1
1
0
)
;
error
=
glGetError
(
)
;
EXPECT_TRUE
(
error
=
=
GL_INVALID_FRAMEBUFFER_OPERATION
|
|
error
=
=
GL_INVALID_OPERATION
)
;
glClear
(
GL_COLOR_BUFFER_BIT
|
GL_DEPTH_BUFFER_BIT
)
;
EXPECT_GL_ERROR
(
GL_INVALID_FRAMEBUFFER_OPERATION
)
;
}
void
WebGLFramebufferTest
:
:
testUsingIncompleteFramebuffer
(
GLenum
depthFormat
GLenum
depthAttachment
)
{
const
std
:
:
string
&
vertexShader
=
"
attribute
vec4
position
;
void
main
(
)
{
gl_Position
=
position
;
}
"
;
const
std
:
:
string
&
fragmentShader
=
"
void
main
(
)
{
gl_FragColor
=
vec4
(
1
0
0
1
)
;
}
"
;
ANGLE_GL_PROGRAM
(
program
vertexShader
fragmentShader
)
;
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
GLRenderbuffer
colorBuffer
;
glBindRenderbuffer
(
GL_RENDERBUFFER
colorBuffer
)
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_RENDERBUFFER
colorBuffer
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
GL_RGBA4
16
16
)
;
GLRenderbuffer
depthBuffer
;
glBindRenderbuffer
(
GL_RENDERBUFFER
depthBuffer
)
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
depthAttachment
GL_RENDERBUFFER
depthBuffer
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
depthFormat
16
16
)
;
EXPECT_GL_NO_ERROR
(
)
;
checkFramebuffer
(
GL_FRAMEBUFFER_COMPLETE
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
depthFormat
32
16
)
;
checkFramebuffer
(
GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS
)
;
testRenderingAndReading
(
program
.
get
(
)
)
;
GLFramebuffer
fbo2
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo2
)
;
checkFramebuffer
(
GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT
)
;
testRenderingAndReading
(
program
.
get
(
)
)
;
GLRenderbuffer
colorBuffer2
;
glBindRenderbuffer
(
GL_RENDERBUFFER
colorBuffer2
)
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_RENDERBUFFER
colorBuffer2
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
GL_RGBA4
0
0
)
;
testRenderingAndReading
(
program
.
get
(
)
)
;
}
void
testFramebufferIncompleteAttachment
(
GLenum
depthFormat
)
{
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
GLRenderbuffer
colorBuffer
;
glBindRenderbuffer
(
GL_RENDERBUFFER
colorBuffer
)
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_RENDERBUFFER
colorBuffer
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
GL_RGBA4
16
16
)
;
checkFramebuffer
(
GL_FRAMEBUFFER_COMPLETE
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
depthFormat
16
16
)
;
checkFramebuffer
(
GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
GL_RGBA4
16
16
)
;
checkFramebuffer
(
GL_FRAMEBUFFER_COMPLETE
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
GL_RGBA4
0
0
)
;
checkFramebuffer
(
GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
)
;
EXPECT_GL_NO_ERROR
(
)
;
}
void
testFramebufferIncompleteMissingAttachment
(
)
{
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
checkFramebuffer
(
GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT
)
;
GLRenderbuffer
colorBuffer
;
glBindRenderbuffer
(
GL_RENDERBUFFER
colorBuffer
)
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_RENDERBUFFER
colorBuffer
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
GL_RGBA4
16
16
)
;
checkFramebuffer
(
GL_FRAMEBUFFER_COMPLETE
)
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_RENDERBUFFER
0
)
;
checkFramebuffer
(
GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT
)
;
EXPECT_GL_NO_ERROR
(
)
;
}
void
testFramebufferIncompleteDimensions
(
GLenum
depthFormat
GLenum
depthAttachment
)
{
GLFramebuffer
fbo
;
glBindFramebuffer
(
GL_FRAMEBUFFER
fbo
)
;
GLRenderbuffer
colorBuffer
;
glBindRenderbuffer
(
GL_RENDERBUFFER
colorBuffer
)
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_RENDERBUFFER
colorBuffer
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
GL_RGBA4
16
16
)
;
GLRenderbuffer
depthBuffer
;
glBindRenderbuffer
(
GL_RENDERBUFFER
depthBuffer
)
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
depthAttachment
GL_RENDERBUFFER
depthBuffer
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
depthFormat
16
16
)
;
EXPECT_GL_NO_ERROR
(
)
;
checkFramebuffer
(
GL_FRAMEBUFFER_COMPLETE
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
depthFormat
32
16
)
;
checkFramebuffer
(
GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
depthFormat
16
16
)
;
checkFramebuffer
(
GL_FRAMEBUFFER_COMPLETE
)
;
glBindRenderbuffer
(
GL_RENDERBUFFER
colorBuffer
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
GL_RGBA4
16
32
)
;
checkFramebuffer
(
GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
GL_RGBA4
16
16
)
;
checkFramebuffer
(
GL_FRAMEBUFFER_COMPLETE
)
;
EXPECT_GL_NO_ERROR
(
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_2D
tex
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA
16
16
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
glFramebufferTexture2D
(
GL_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
GL_TEXTURE_2D
tex
0
)
;
EXPECT_GL_NO_ERROR
(
)
;
if
(
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
!
=
GL_FRAMEBUFFER_COMPLETE
)
{
return
;
}
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA
32
16
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
checkFramebuffer
(
GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA
16
16
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
checkFramebuffer
(
GL_FRAMEBUFFER_COMPLETE
)
;
EXPECT_GL_NO_ERROR
(
)
;
}
class
NoColorFB
final
:
angle
:
:
NonCopyable
{
public
:
NoColorFB
(
int
size
)
{
glBindFramebuffer
(
GL_FRAMEBUFFER
mFBO
)
;
glBindRenderbuffer
(
GL_RENDERBUFFER
mDepthBuffer
)
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
GL_DEPTH_ATTACHMENT
GL_RENDERBUFFER
mDepthBuffer
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
GL_DEPTH_COMPONENT16
size
size
)
;
EXPECT_GL_NO_ERROR
(
)
;
if
(
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
!
=
GL_FRAMEBUFFER_COMPLETE
)
{
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
GL_DEPTH_ATTACHMENT
GL_RENDERBUFFER
0
)
;
glBindRenderbuffer
(
GL_RENDERBUFFER
mDepthStencilBuffer
)
;
glFramebufferRenderbuffer
(
GL_FRAMEBUFFER
GL_DEPTH_STENCIL_ATTACHMENT
GL_RENDERBUFFER
mDepthStencilBuffer
)
;
glRenderbufferStorage
(
GL_RENDERBUFFER
GL_DEPTH_STENCIL
size
size
)
;
EXPECT_GL_NO_ERROR
(
)
;
}
}
private
:
GLRenderbuffer
mDepthBuffer
;
GLRenderbuffer
mDepthStencilBuffer
;
GLFramebuffer
mFBO
;
}
;
void
TestReadingMissingAttachment
(
int
size
)
{
std
:
:
vector
<
uint8_t
>
dummyBuffer
(
4
)
;
EXPECT_GL_NO_ERROR
(
)
;
glReadPixels
(
0
0
1
1
GL_RGBA
GL_UNSIGNED_BYTE
dummyBuffer
.
data
(
)
)
;
EXPECT_GL_ERROR
(
GL_INVALID_OPERATION
)
;
GLTexture
tex
;
glBindTexture
(
GL_TEXTURE_2D
tex
)
;
EXPECT_GL_NO_ERROR
(
)
;
glCopyTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA
0
0
size
size
0
)
;
EXPECT_GL_ERROR
(
GL_INVALID_OPERATION
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_RGBA
size
size
0
GL_RGBA
GL_UNSIGNED_BYTE
nullptr
)
;
EXPECT_GL_NO_ERROR
(
)
;
glCopyTexSubImage2D
(
GL_TEXTURE_2D
0
0
0
0
0
size
size
)
;
EXPECT_GL_ERROR
(
GL_INVALID_OPERATION
)
;
}
void
WebGLFramebufferTest
:
:
testDrawingMissingAttachment
(
)
{
const
std
:
:
string
&
vertexShader
=
"
attribute
vec4
pos
;
void
main
(
)
{
gl_Position
=
pos
;
}
"
;
const
std
:
:
string
&
fragmentShader
=
"
void
main
(
)
{
gl_FragColor
=
vec4
(
1
0
0
1
)
;
}
"
;
ANGLE_GL_PROGRAM
(
program
vertexShader
fragmentShader
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
EXPECT_GL_NO_ERROR
(
)
;
drawQuad
(
program
"
pos
"
0
.
5f
1
.
0f
true
)
;
EXPECT_GL_NO_ERROR
(
)
;
drawIndexedQuad
(
program
"
pos
"
0
.
5f
1
.
0f
true
)
;
EXPECT_GL_NO_ERROR
(
)
;
}
TEST_P
(
WebGLFramebufferTest
CheckValidColorDepthCombination
)
{
if
(
IsD3D11_FL93
(
)
)
{
ignoreD3D11SDKLayersWarnings
(
)
;
}
GLenum
depthFormat
=
GL_NONE
;
GLenum
depthAttachment
=
GL_NONE
;
if
(
checkValidColorDepthCombination
(
&
depthFormat
&
depthAttachment
)
)
{
testFramebufferIncompleteDimensions
(
depthFormat
depthAttachment
)
;
testFramebufferIncompleteAttachment
(
depthFormat
)
;
testFramebufferIncompleteMissingAttachment
(
)
;
testUsingIncompleteFramebuffer
(
depthFormat
depthAttachment
)
;
constexpr
int
size
=
16
;
NoColorFB
fb
(
size
)
;
if
(
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
=
=
GL_FRAMEBUFFER_COMPLETE
)
{
TestReadingMissingAttachment
(
size
)
;
testDrawingMissingAttachment
(
)
;
}
}
}
TEST_P
(
WebGLFramebufferTest
TextureAttachmentCommitBug
)
{
if
(
extensionRequestable
(
"
GL_ANGLE_depth_texture
"
)
)
{
glRequestExtensionANGLE
(
"
GL_ANGLE_depth_texture
"
)
;
}
if
(
!
extensionEnabled
(
"
GL_ANGLE_depth_texture
"
)
)
{
std
:
:
cout
<
<
"
Test
skipped
because
depth
textures
are
not
available
.
\
n
"
;
return
;
}
GLTexture
depthTexture
;
glBindTexture
(
GL_TEXTURE_2D
depthTexture
.
get
(
)
)
;
glTexImage2D
(
GL_TEXTURE_2D
0
GL_DEPTH_COMPONENT
1
1
0
GL_DEPTH_COMPONENT
GL_UNSIGNED_INT
nullptr
)
;
GLFramebuffer
framebuffer
;
glBindFramebuffer
(
GL_FRAMEBUFFER
framebuffer
)
;
glFramebufferTexture2D
(
GL_FRAMEBUFFER
GL_DEPTH_ATTACHMENT
GL_TEXTURE_2D
depthTexture
.
get
(
)
0
)
;
glCheckFramebufferStatus
(
GL_FRAMEBUFFER
)
;
EXPECT_GL_NO_ERROR
(
)
;
}
ANGLE_INSTANTIATE_TEST
(
WebGLFramebufferTest
ES2_D3D9
(
)
ES2_D3D11
(
)
ES2_D3D11_FL9_3
(
)
ES2_OPENGL
(
)
ES2_OPENGLES
(
)
)
;
}
