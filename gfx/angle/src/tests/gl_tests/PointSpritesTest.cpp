#
include
"
test_utils
/
ANGLETest
.
h
"
#
include
<
cmath
>
using
namespace
angle
;
class
PointSpritesTest
:
public
ANGLETest
{
protected
:
const
int
windowWidth
=
256
;
const
int
windowHeight
=
256
;
PointSpritesTest
(
)
{
setWindowWidth
(
windowWidth
)
;
setWindowHeight
(
windowHeight
)
;
setConfigRedBits
(
8
)
;
setConfigGreenBits
(
8
)
;
setConfigBlueBits
(
8
)
;
setConfigAlphaBits
(
8
)
;
}
virtual
void
SetUp
(
)
{
ANGLETest
:
:
SetUp
(
)
;
}
float
s2p
(
float
s
)
{
return
(
s
+
1
.
0f
)
*
0
.
5f
*
(
GLfloat
)
windowWidth
;
}
}
;
TEST_P
(
PointSpritesTest
PointCoordAndPointSizeCompliance
)
{
if
(
isIntel
(
)
&
&
GetParam
(
)
=
=
ES2_D3D9
(
)
)
{
std
:
:
cout
<
<
"
Test
skipped
on
Intel
due
to
failures
.
"
<
<
std
:
:
endl
;
return
;
}
const
std
:
:
string
fs
=
SHADER_SOURCE
(
precision
mediump
float
;
void
main
(
)
{
gl_FragColor
=
vec4
(
gl_PointCoord
.
x
gl_PointCoord
.
y
0
1
)
;
}
)
;
const
std
:
:
string
vs
=
SHADER_SOURCE
(
attribute
vec4
vPosition
;
uniform
float
uPointSize
;
void
main
(
)
{
gl_PointSize
=
uPointSize
;
gl_Position
=
vPosition
;
}
)
;
GLuint
program
=
CompileProgram
(
vs
fs
)
;
ASSERT_NE
(
program
0u
)
;
ASSERT_GL_NO_ERROR
(
)
;
glUseProgram
(
program
)
;
GLfloat
pointSizeRange
[
2
]
=
{
}
;
glGetFloatv
(
GL_ALIASED_POINT_SIZE_RANGE
pointSizeRange
)
;
GLfloat
maxPointSize
=
pointSizeRange
[
1
]
;
ASSERT_TRUE
(
maxPointSize
>
=
1
)
;
maxPointSize
=
floorf
(
maxPointSize
)
;
ASSERT_TRUE
(
(
int
)
maxPointSize
%
1
=
=
0
)
;
maxPointSize
=
std
:
:
min
(
maxPointSize
64
.
0f
)
;
GLfloat
pointWidth
=
maxPointSize
/
windowWidth
;
GLint
step
=
static_cast
<
GLint
>
(
floorf
(
maxPointSize
/
4
)
)
;
GLint
pointStep
=
std
:
:
max
<
GLint
>
(
1
step
)
;
GLint
pointSizeLoc
=
glGetUniformLocation
(
program
"
uPointSize
"
)
;
ASSERT_GL_NO_ERROR
(
)
;
glUniform1f
(
pointSizeLoc
maxPointSize
)
;
ASSERT_GL_NO_ERROR
(
)
;
GLfloat
pixelOffset
=
(
(
int
)
maxPointSize
%
2
)
?
(
1
.
0f
/
(
GLfloat
)
windowWidth
)
:
0
;
GLuint
vertexObject
=
0
;
glGenBuffers
(
1
&
vertexObject
)
;
ASSERT_NE
(
vertexObject
0U
)
;
ASSERT_GL_NO_ERROR
(
)
;
glBindBuffer
(
GL_ARRAY_BUFFER
vertexObject
)
;
ASSERT_GL_NO_ERROR
(
)
;
GLfloat
thePoints
[
]
=
{
-
0
.
5f
+
pixelOffset
-
0
.
5f
+
pixelOffset
0
.
5f
+
pixelOffset
-
0
.
5f
+
pixelOffset
-
0
.
5f
+
pixelOffset
0
.
5f
+
pixelOffset
0
.
5f
+
pixelOffset
0
.
5f
+
pixelOffset
}
;
glBufferData
(
GL_ARRAY_BUFFER
sizeof
(
thePoints
)
thePoints
GL_STATIC_DRAW
)
;
ASSERT_GL_NO_ERROR
(
)
;
glEnableVertexAttribArray
(
0
)
;
glVertexAttribPointer
(
0
2
GL_FLOAT
GL_FALSE
0
0
)
;
glClear
(
GL_COLOR_BUFFER_BIT
|
GL_DEPTH_BUFFER_BIT
)
;
glDrawArrays
(
GL_POINTS
0
4
)
;
ASSERT_GL_NO_ERROR
(
)
;
glDeleteBuffers
(
1
&
vertexObject
)
;
std
:
:
string
debugText
;
for
(
float
py
=
0
;
py
<
2
;
+
+
py
)
{
for
(
float
px
=
0
;
px
<
2
;
+
+
px
)
{
float
pointX
=
-
0
.
5f
+
px
+
pixelOffset
;
float
pointY
=
-
0
.
5f
+
py
+
pixelOffset
;
for
(
int
yy
=
0
;
yy
<
maxPointSize
;
yy
+
=
pointStep
)
{
for
(
int
xx
=
0
;
xx
<
maxPointSize
;
xx
+
=
pointStep
)
{
float
xw
=
s2p
(
pointX
)
;
float
yw
=
s2p
(
pointY
)
;
float
u
=
xx
/
maxPointSize
*
2
-
1
;
float
v
=
yy
/
maxPointSize
*
2
-
1
;
int
xf
=
static_cast
<
int
>
(
floorf
(
s2p
(
pointX
+
u
*
pointWidth
)
)
)
;
int
yf
=
static_cast
<
int
>
(
floorf
(
s2p
(
pointY
+
v
*
pointWidth
)
)
)
;
float
s
=
0
.
5f
+
(
xf
+
0
.
5f
-
xw
)
/
maxPointSize
;
float
t
=
0
.
5f
+
(
yf
+
0
.
5f
-
yw
)
/
maxPointSize
;
GLubyte
color
[
4
]
=
{
static_cast
<
GLubyte
>
(
floorf
(
s
*
255
)
)
static_cast
<
GLubyte
>
(
floorf
(
(
1
-
t
)
*
255
)
)
0
255
}
;
EXPECT_PIXEL_NEAR
(
xf
yf
color
[
0
]
color
[
1
]
color
[
2
]
color
[
3
]
4
)
;
}
}
}
}
}
TEST_P
(
PointSpritesTest
PointWithoutAttributesCompliance
)
{
const
std
:
:
string
fs
=
SHADER_SOURCE
(
precision
mediump
float
;
void
main
(
)
{
gl_FragColor
=
vec4
(
0
.
0
1
.
0
0
.
0
1
.
0
)
;
}
)
;
const
std
:
:
string
vs
=
SHADER_SOURCE
(
void
main
(
)
{
gl_PointSize
=
2
.
0
;
gl_Position
=
vec4
(
0
.
0
0
.
0
0
.
0
1
.
0
)
;
}
)
;
GLuint
program
=
CompileProgram
(
vs
fs
)
;
ASSERT_NE
(
program
0u
)
;
ASSERT_GL_NO_ERROR
(
)
;
glUseProgram
(
program
)
;
glDrawArrays
(
GL_POINTS
0
1
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_PIXEL_EQ
(
(
windowWidth
-
1
)
/
2
(
windowHeight
-
1
)
/
2
0
255
0
255
)
;
}
TEST_P
(
PointSpritesTest
PointCoordRegressionTest
)
{
const
std
:
:
string
fs
=
SHADER_SOURCE
(
precision
mediump
float
;
varying
vec4
v_color
;
void
main
(
)
{
vec2
diff
=
gl_PointCoord
-
vec2
(
.
5
.
5
)
;
if
(
length
(
diff
)
>
0
.
5
)
discard
;
gl_FragColor
=
v_color
;
}
)
;
const
std
:
:
string
vs
=
SHADER_SOURCE
(
varying
vec4
v_color
;
attribute
vec2
a_vertex
;
uniform
float
u_pointSize
;
void
main
(
)
{
gl_PointSize
=
u_pointSize
;
gl_Position
=
vec4
(
a_vertex
0
.
0
1
.
0
)
;
v_color
=
vec4
(
0
.
0
1
.
0
0
.
0
1
.
0
)
;
}
)
;
GLuint
program
=
CompileProgram
(
vs
fs
)
;
ASSERT_NE
(
program
0u
)
;
ASSERT_GL_NO_ERROR
(
)
;
glUseProgram
(
program
)
;
GLfloat
pointSizeRange
[
2
]
=
{
}
;
glGetFloatv
(
GL_ALIASED_POINT_SIZE_RANGE
pointSizeRange
)
;
GLfloat
maxPointSize
=
pointSizeRange
[
1
]
;
ASSERT_TRUE
(
maxPointSize
>
2
)
;
glClearColor
(
0
0
0
1
)
;
glDisable
(
GL_DEPTH_TEST
)
;
glClear
(
GL_COLOR_BUFFER_BIT
)
;
GLint
pointSizeLoc
=
glGetUniformLocation
(
program
"
u_pointSize
"
)
;
ASSERT_GL_NO_ERROR
(
)
;
GLfloat
pointSize
=
std
:
:
min
<
GLfloat
>
(
20
.
0f
maxPointSize
)
;
glUniform1f
(
pointSizeLoc
pointSize
)
;
ASSERT_GL_NO_ERROR
(
)
;
GLuint
vertexObject
=
0
;
glGenBuffers
(
1
&
vertexObject
)
;
ASSERT_NE
(
vertexObject
0U
)
;
ASSERT_GL_NO_ERROR
(
)
;
glBindBuffer
(
GL_ARRAY_BUFFER
vertexObject
)
;
ASSERT_GL_NO_ERROR
(
)
;
GLfloat
thePoints
[
]
=
{
0
.
0f
0
.
0f
}
;
glBufferData
(
GL_ARRAY_BUFFER
sizeof
(
thePoints
)
thePoints
GL_STATIC_DRAW
)
;
ASSERT_GL_NO_ERROR
(
)
;
glEnableVertexAttribArray
(
0
)
;
glVertexAttribPointer
(
0
2
GL_FLOAT
GL_FALSE
0
0
)
;
glDrawArrays
(
GL_POINTS
0
1
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_PIXEL_EQ
(
(
windowWidth
-
1
)
/
2
(
windowHeight
-
1
)
/
2
0
255
0
255
)
;
glDeleteBuffers
(
1
&
vertexObject
)
;
}
TEST_P
(
PointSpritesTest
PointSizeEnabledCompliance
)
{
const
std
:
:
string
fs
=
SHADER_SOURCE
(
precision
mediump
float
;
varying
vec4
color
;
void
main
(
)
{
gl_FragColor
=
color
;
}
)
;
const
std
:
:
string
vs
=
SHADER_SOURCE
(
attribute
vec3
pos
;
attribute
vec4
colorIn
;
uniform
float
pointSize
;
varying
vec4
color
;
void
main
(
)
{
gl_PointSize
=
pointSize
;
color
=
colorIn
;
gl_Position
=
vec4
(
pos
1
.
0
)
;
}
)
;
glViewport
(
0
0
2
2
)
;
GLuint
program
=
CompileProgram
(
vs
fs
)
;
ASSERT_NE
(
program
0u
)
;
ASSERT_GL_NO_ERROR
(
)
;
glUseProgram
(
program
)
;
glDisable
(
GL_BLEND
)
;
GLfloat
vertices
[
]
=
{
0
.
4f
0
.
4f
0
.
0f
}
;
GLubyte
colors
[
]
=
{
255
0
0
255
}
;
GLuint
vertexObject
=
0
;
glGenBuffers
(
1
&
vertexObject
)
;
ASSERT_NE
(
vertexObject
0U
)
;
ASSERT_GL_NO_ERROR
(
)
;
glBindBuffer
(
GL_ARRAY_BUFFER
vertexObject
)
;
ASSERT_GL_NO_ERROR
(
)
;
glBufferData
(
GL_ARRAY_BUFFER
sizeof
(
vertices
)
+
sizeof
(
colors
)
NULL
GL_STATIC_DRAW
)
;
ASSERT_GL_NO_ERROR
(
)
;
glBufferSubData
(
GL_ARRAY_BUFFER
0
sizeof
(
vertices
)
vertices
)
;
ASSERT_GL_NO_ERROR
(
)
;
glBufferSubData
(
GL_ARRAY_BUFFER
sizeof
(
vertices
)
sizeof
(
colors
)
colors
)
;
ASSERT_GL_NO_ERROR
(
)
;
glClear
(
GL_COLOR_BUFFER_BIT
|
GL_DEPTH_BUFFER_BIT
)
;
glVertexAttribPointer
(
0
3
GL_FLOAT
GL_FALSE
0
0
)
;
glEnableVertexAttribArray
(
0
)
;
glVertexAttribPointer
(
1
4
GL_UNSIGNED_BYTE
GL_TRUE
0
(
GLvoid
*
)
sizeof
(
vertices
)
)
;
glEnableVertexAttribArray
(
1
)
;
GLint
pointSizeLoc
=
glGetUniformLocation
(
program
"
pointSize
"
)
;
ASSERT_GL_NO_ERROR
(
)
;
glUniform1f
(
pointSizeLoc
1
.
0f
)
;
ASSERT_GL_NO_ERROR
(
)
;
glDrawArrays
(
GL_POINTS
0
static_cast
<
GLsizei
>
(
ArraySize
(
vertices
)
)
/
3
)
;
ASSERT_GL_NO_ERROR
(
)
;
for
(
GLint
y
=
0
;
y
<
2
;
+
+
y
)
{
for
(
GLint
x
=
0
;
x
<
2
;
+
+
x
)
{
GLubyte
expectedColor
[
4
]
=
{
0
0
0
0
}
;
if
(
x
=
=
1
&
&
y
=
=
1
)
{
expectedColor
[
0
]
=
255
;
expectedColor
[
3
]
=
255
;
}
EXPECT_PIXEL_EQ
(
x
y
expectedColor
[
0
]
expectedColor
[
1
]
expectedColor
[
2
]
expectedColor
[
3
]
)
;
}
}
GLfloat
pointSizeRange
[
2
]
=
{
}
;
glGetFloatv
(
GL_ALIASED_POINT_SIZE_RANGE
pointSizeRange
)
;
if
(
pointSizeRange
[
1
]
>
=
2
.
0
)
{
glClear
(
GL_COLOR_BUFFER_BIT
|
GL_DEPTH_BUFFER_BIT
)
;
glUniform1f
(
pointSizeLoc
2
.
0f
)
;
ASSERT_GL_NO_ERROR
(
)
;
glDrawArrays
(
GL_POINTS
0
static_cast
<
GLsizei
>
(
ArraySize
(
vertices
)
)
/
3
)
;
ASSERT_GL_NO_ERROR
(
)
;
for
(
GLint
y
=
0
;
y
<
2
;
+
+
y
)
{
for
(
GLint
x
=
0
;
x
<
2
;
+
+
x
)
{
EXPECT_PIXEL_EQ
(
x
y
255
0
0
255
)
;
}
}
}
glDeleteBuffers
(
1
&
vertexObject
)
;
}
TEST_P
(
PointSpritesTest
PointSizeDeclaredButUnused
)
{
const
std
:
:
string
vs
=
SHADER_SOURCE
(
attribute
highp
vec4
position
;
void
main
(
void
)
{
gl_PointSize
=
1
.
0
;
gl_Position
=
position
;
}
)
;
const
std
:
:
string
fs
=
SHADER_SOURCE
(
void
main
(
void
)
{
gl_FragColor
=
vec4
(
1
.
0
0
.
0
0
.
0
1
.
0
)
;
}
)
;
GLuint
program
=
CompileProgram
(
vs
fs
)
;
ASSERT_NE
(
program
0u
)
;
ASSERT_GL_NO_ERROR
(
)
;
glUseProgram
(
program
)
;
drawQuad
(
program
"
position
"
0
.
5f
1
.
0f
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
255
0
0
255
)
;
glDeleteProgram
(
program
)
;
}
TEST_P
(
PointSpritesTest
PointSpriteAlternatingDrawTypes
)
{
const
std
:
:
string
pointFS
=
SHADER_SOURCE
(
precision
mediump
float
;
void
main
(
)
{
gl_FragColor
=
vec4
(
0
.
0
1
.
0
0
.
0
1
.
0
)
;
}
)
;
const
std
:
:
string
pointVS
=
SHADER_SOURCE
(
void
main
(
)
{
gl_PointSize
=
16
.
0
;
gl_Position
=
vec4
(
0
.
0
0
.
0
0
.
0
1
.
0
)
;
}
)
;
const
std
:
:
string
quadFS
=
SHADER_SOURCE
(
precision
mediump
float
;
void
main
(
)
{
gl_FragColor
=
vec4
(
1
.
0
0
.
0
0
.
0
1
.
0
)
;
}
)
;
const
std
:
:
string
quadVS
=
SHADER_SOURCE
(
precision
mediump
float
;
attribute
vec4
pos
;
void
main
(
)
{
gl_Position
=
pos
;
}
)
;
GLuint
pointProgram
=
CompileProgram
(
pointVS
pointFS
)
;
ASSERT_NE
(
pointProgram
0u
)
;
ASSERT_GL_NO_ERROR
(
)
;
GLuint
quadProgram
=
CompileProgram
(
quadVS
quadFS
)
;
ASSERT_NE
(
pointProgram
0u
)
;
ASSERT_GL_NO_ERROR
(
)
;
glEnable
(
GL_CULL_FACE
)
;
glCullFace
(
GL_FRONT
)
;
const
GLfloat
quadVertices
[
]
=
{
-
1
.
0f
1
.
0f
0
.
5f
1
.
0f
-
1
.
0f
0
.
5f
-
1
.
0f
-
1
.
0f
0
.
5f
-
1
.
0f
1
.
0f
0
.
5f
1
.
0f
1
.
0f
0
.
5f
1
.
0f
-
1
.
0f
0
.
5f
}
;
glUseProgram
(
quadProgram
)
;
GLint
positionLocation
=
glGetAttribLocation
(
quadProgram
"
pos
"
)
;
glVertexAttribPointer
(
positionLocation
3
GL_FLOAT
GL_FALSE
0
quadVertices
)
;
glEnableVertexAttribArray
(
positionLocation
)
;
glDrawArrays
(
GL_TRIANGLES
0
6
)
;
glUseProgram
(
pointProgram
)
;
glDrawArrays
(
GL_POINTS
0
1
)
;
ASSERT_GL_NO_ERROR
(
)
;
EXPECT_PIXEL_EQ
(
getWindowWidth
(
)
/
2
getWindowHeight
(
)
/
2
0
255
0
255
)
;
glDeleteProgram
(
pointProgram
)
;
glDeleteProgram
(
quadProgram
)
;
}
ANGLE_INSTANTIATE_TEST
(
PointSpritesTest
ES2_D3D9
(
)
ES2_D3D11
(
)
ES2_D3D11_FL9_3
(
)
ES2_OPENGL
(
)
ES2_OPENGLES
(
)
)
;
