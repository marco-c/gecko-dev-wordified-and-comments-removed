#
include
"
compiler
/
preprocessor
/
Input
.
h
"
#
include
<
algorithm
>
#
include
<
cstring
>
#
include
"
common
/
debug
.
h
"
namespace
pp
{
Input
:
:
Input
(
)
:
mCount
(
0
)
mString
(
0
)
{
}
Input
:
:
Input
(
size_t
count
const
char
*
const
string
[
]
const
int
length
[
]
)
:
mCount
(
count
)
mString
(
string
)
{
mLength
.
reserve
(
mCount
)
;
for
(
size_t
i
=
0
;
i
<
mCount
;
+
+
i
)
{
int
len
=
length
?
length
[
i
]
:
-
1
;
mLength
.
push_back
(
len
<
0
?
std
:
:
strlen
(
mString
[
i
]
)
:
len
)
;
}
}
const
char
*
Input
:
:
skipChar
(
)
{
ASSERT
(
mReadLoc
.
cIndex
<
mLength
[
mReadLoc
.
sIndex
]
)
;
+
+
mReadLoc
.
cIndex
;
if
(
mReadLoc
.
cIndex
=
=
mLength
[
mReadLoc
.
sIndex
]
)
{
+
+
mReadLoc
.
sIndex
;
mReadLoc
.
cIndex
=
0
;
}
if
(
mReadLoc
.
sIndex
>
=
mCount
)
{
return
nullptr
;
}
return
mString
[
mReadLoc
.
sIndex
]
+
mReadLoc
.
cIndex
;
}
size_t
Input
:
:
read
(
char
*
buf
size_t
maxSize
int
*
lineNo
)
{
size_t
nRead
=
0
;
if
(
mReadLoc
.
sIndex
<
mCount
&
&
maxSize
>
0
)
{
const
char
*
c
=
mString
[
mReadLoc
.
sIndex
]
+
mReadLoc
.
cIndex
;
if
(
(
*
c
)
=
=
'
\
\
'
)
{
c
=
skipChar
(
)
;
if
(
c
!
=
nullptr
&
&
(
*
c
)
=
=
'
\
n
'
)
{
skipChar
(
)
;
+
+
(
*
lineNo
)
;
}
else
if
(
c
!
=
nullptr
&
&
(
*
c
)
=
=
'
\
r
'
)
{
c
=
skipChar
(
)
;
if
(
c
!
=
nullptr
&
&
(
*
c
)
=
=
'
\
n
'
)
{
skipChar
(
)
;
}
+
+
(
*
lineNo
)
;
}
else
{
*
buf
=
'
\
\
'
;
+
+
nRead
;
}
}
}
size_t
maxRead
=
maxSize
;
while
(
(
nRead
<
maxRead
)
&
&
(
mReadLoc
.
sIndex
<
mCount
)
)
{
size_t
size
=
mLength
[
mReadLoc
.
sIndex
]
-
mReadLoc
.
cIndex
;
size
=
std
:
:
min
(
size
maxSize
)
;
for
(
size_t
i
=
0
;
i
<
size
;
+
+
i
)
{
if
(
*
(
mString
[
mReadLoc
.
sIndex
]
+
mReadLoc
.
cIndex
+
i
)
=
=
'
\
\
'
)
{
size
=
i
;
maxRead
=
nRead
+
size
;
}
}
std
:
:
memcpy
(
buf
+
nRead
mString
[
mReadLoc
.
sIndex
]
+
mReadLoc
.
cIndex
size
)
;
nRead
+
=
size
;
mReadLoc
.
cIndex
+
=
size
;
if
(
mReadLoc
.
cIndex
=
=
mLength
[
mReadLoc
.
sIndex
]
)
{
+
+
mReadLoc
.
sIndex
;
mReadLoc
.
cIndex
=
0
;
}
}
return
nRead
;
}
}
