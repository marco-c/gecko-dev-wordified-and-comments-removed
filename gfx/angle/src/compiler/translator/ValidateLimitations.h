#
ifndef
COMPILER_TRANSLATOR_VALIDATELIMITATIONS_H_
#
define
COMPILER_TRANSLATOR_VALIDATELIMITATIONS_H_
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
namespace
sh
{
class
TInfoSinkBase
;
class
ValidateLimitations
:
public
TIntermTraverser
{
public
:
ValidateLimitations
(
sh
:
:
GLenum
shaderType
TInfoSinkBase
*
sink
)
;
int
numErrors
(
)
const
{
return
mNumErrors
;
}
bool
visitBinary
(
Visit
TIntermBinary
*
)
override
;
bool
visitUnary
(
Visit
TIntermUnary
*
)
override
;
bool
visitAggregate
(
Visit
TIntermAggregate
*
)
override
;
bool
visitLoop
(
Visit
TIntermLoop
*
)
override
;
static
bool
IsLimitedForLoop
(
TIntermLoop
*
node
)
;
private
:
void
error
(
TSourceLoc
loc
const
char
*
reason
const
char
*
token
)
;
bool
withinLoopBody
(
)
const
;
bool
isLoopIndex
(
TIntermSymbol
*
symbol
)
;
bool
validateLoopType
(
TIntermLoop
*
node
)
;
bool
validateForLoopHeader
(
TIntermLoop
*
node
)
;
int
validateForLoopInit
(
TIntermLoop
*
node
)
;
bool
validateForLoopCond
(
TIntermLoop
*
node
int
indexSymbolId
)
;
bool
validateForLoopExpr
(
TIntermLoop
*
node
int
indexSymbolId
)
;
bool
validateFunctionCall
(
TIntermAggregate
*
node
)
;
bool
validateOperation
(
TIntermOperator
*
node
TIntermNode
*
operand
)
;
bool
isConstExpr
(
TIntermNode
*
node
)
;
bool
isConstIndexExpr
(
TIntermNode
*
node
)
;
bool
validateIndexing
(
TIntermBinary
*
node
)
;
sh
:
:
GLenum
mShaderType
;
TInfoSinkBase
*
mSink
;
int
mNumErrors
;
std
:
:
vector
<
int
>
mLoopSymbolIds
;
bool
mValidateIndexing
;
bool
mValidateInnerLoops
;
}
;
}
#
endif
