#
include
"
compiler
/
translator
/
CallDAG
.
h
"
#
include
"
compiler
/
translator
/
InfoSink
.
h
"
namespace
sh
{
class
CallDAG
:
:
CallDAGCreator
:
public
TIntermTraverser
{
public
:
CallDAGCreator
(
TInfoSinkBase
*
info
)
:
TIntermTraverser
(
true
false
true
)
mCreationInfo
(
info
)
mCurrentFunction
(
nullptr
)
mCurrentIndex
(
0
)
{
}
InitResult
assignIndices
(
)
{
int
skipped
=
0
;
for
(
auto
&
it
:
mFunctions
)
{
if
(
it
.
second
.
node
)
{
InitResult
result
=
assignIndicesInternal
(
&
it
.
second
)
;
if
(
result
!
=
INITDAG_SUCCESS
)
{
*
mCreationInfo
<
<
"
\
n
"
;
return
result
;
}
}
else
{
skipped
+
+
;
}
}
ASSERT
(
mFunctions
.
size
(
)
=
=
mCurrentIndex
+
skipped
)
;
return
INITDAG_SUCCESS
;
}
void
fillDataStructures
(
std
:
:
vector
<
Record
>
*
records
std
:
:
map
<
int
int
>
*
idToIndex
)
{
ASSERT
(
records
-
>
empty
(
)
)
;
ASSERT
(
idToIndex
-
>
empty
(
)
)
;
records
-
>
resize
(
mCurrentIndex
)
;
for
(
auto
&
it
:
mFunctions
)
{
CreatorFunctionData
&
data
=
it
.
second
;
if
(
!
data
.
node
)
{
continue
;
}
ASSERT
(
data
.
index
<
records
-
>
size
(
)
)
;
Record
&
record
=
(
*
records
)
[
data
.
index
]
;
record
.
name
=
data
.
name
.
data
(
)
;
record
.
node
=
data
.
node
;
record
.
callees
.
reserve
(
data
.
callees
.
size
(
)
)
;
for
(
auto
&
callee
:
data
.
callees
)
{
record
.
callees
.
push_back
(
static_cast
<
int
>
(
callee
-
>
index
)
)
;
}
(
*
idToIndex
)
[
data
.
node
-
>
getFunctionSymbolInfo
(
)
-
>
getId
(
)
]
=
static_cast
<
int
>
(
data
.
index
)
;
}
}
private
:
struct
CreatorFunctionData
{
CreatorFunctionData
(
)
:
node
(
nullptr
)
index
(
0
)
indexAssigned
(
false
)
visiting
(
false
)
{
}
std
:
:
set
<
CreatorFunctionData
*
>
callees
;
TIntermFunctionDefinition
*
node
;
TString
name
;
size_t
index
;
bool
indexAssigned
;
bool
visiting
;
}
;
bool
visitFunctionDefinition
(
Visit
visit
TIntermFunctionDefinition
*
node
)
override
{
if
(
visit
=
=
PreVisit
)
{
auto
it
=
mFunctions
.
find
(
node
-
>
getFunctionSymbolInfo
(
)
-
>
getName
(
)
)
;
if
(
it
=
=
mFunctions
.
end
(
)
)
{
mCurrentFunction
=
&
mFunctions
[
node
-
>
getFunctionSymbolInfo
(
)
-
>
getName
(
)
]
;
}
else
{
mCurrentFunction
=
&
it
-
>
second
;
}
mCurrentFunction
-
>
node
=
node
;
mCurrentFunction
-
>
name
=
node
-
>
getFunctionSymbolInfo
(
)
-
>
getName
(
)
;
}
else
if
(
visit
=
=
PostVisit
)
{
mCurrentFunction
=
nullptr
;
}
return
true
;
}
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
{
switch
(
node
-
>
getOp
(
)
)
{
case
EOpPrototype
:
if
(
visit
=
=
PreVisit
)
{
auto
&
record
=
mFunctions
[
node
-
>
getFunctionSymbolInfo
(
)
-
>
getName
(
)
]
;
record
.
name
=
node
-
>
getFunctionSymbolInfo
(
)
-
>
getName
(
)
;
}
break
;
case
EOpFunctionCall
:
{
if
(
visit
=
=
PreVisit
)
{
if
(
node
-
>
isUserDefined
(
)
)
{
auto
it
=
mFunctions
.
find
(
node
-
>
getFunctionSymbolInfo
(
)
-
>
getName
(
)
)
;
ASSERT
(
it
!
=
mFunctions
.
end
(
)
)
;
if
(
mCurrentFunction
)
{
mCurrentFunction
-
>
callees
.
insert
(
&
it
-
>
second
)
;
}
}
}
break
;
}
default
:
break
;
}
return
true
;
}
InitResult
assignIndicesInternal
(
CreatorFunctionData
*
root
)
{
ASSERT
(
root
)
;
if
(
root
-
>
indexAssigned
)
{
return
INITDAG_SUCCESS
;
}
TVector
<
CreatorFunctionData
*
>
functionsToProcess
;
functionsToProcess
.
push_back
(
root
)
;
InitResult
result
=
INITDAG_SUCCESS
;
while
(
!
functionsToProcess
.
empty
(
)
)
{
CreatorFunctionData
*
function
=
functionsToProcess
.
back
(
)
;
if
(
function
-
>
visiting
)
{
function
-
>
visiting
=
false
;
function
-
>
index
=
mCurrentIndex
+
+
;
function
-
>
indexAssigned
=
true
;
functionsToProcess
.
pop_back
(
)
;
continue
;
}
if
(
!
function
-
>
node
)
{
*
mCreationInfo
<
<
"
Undefined
function
'
"
<
<
function
-
>
name
<
<
"
)
'
used
in
the
following
call
chain
:
"
;
result
=
INITDAG_UNDEFINED
;
break
;
}
if
(
function
-
>
indexAssigned
)
{
functionsToProcess
.
pop_back
(
)
;
continue
;
}
function
-
>
visiting
=
true
;
for
(
auto
callee
:
function
-
>
callees
)
{
functionsToProcess
.
push_back
(
callee
)
;
if
(
callee
-
>
visiting
)
{
*
mCreationInfo
<
<
"
Recursive
function
call
in
the
following
call
chain
:
"
;
result
=
INITDAG_RECURSION
;
break
;
}
}
if
(
result
!
=
INITDAG_SUCCESS
)
{
break
;
}
}
if
(
result
!
=
INITDAG_SUCCESS
)
{
bool
first
=
true
;
for
(
auto
function
:
functionsToProcess
)
{
if
(
function
-
>
visiting
)
{
if
(
!
first
)
{
*
mCreationInfo
<
<
"
-
>
"
;
}
*
mCreationInfo
<
<
function
-
>
name
<
<
"
)
"
;
first
=
false
;
}
}
}
return
result
;
}
TInfoSinkBase
*
mCreationInfo
;
std
:
:
map
<
TString
CreatorFunctionData
>
mFunctions
;
CreatorFunctionData
*
mCurrentFunction
;
size_t
mCurrentIndex
;
}
;
CallDAG
:
:
CallDAG
(
)
{
}
CallDAG
:
:
~
CallDAG
(
)
{
}
const
size_t
CallDAG
:
:
InvalidIndex
=
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
;
size_t
CallDAG
:
:
findIndex
(
const
TFunctionSymbolInfo
*
functionInfo
)
const
{
auto
it
=
mFunctionIdToIndex
.
find
(
functionInfo
-
>
getId
(
)
)
;
if
(
it
=
=
mFunctionIdToIndex
.
end
(
)
)
{
return
InvalidIndex
;
}
else
{
return
it
-
>
second
;
}
}
const
CallDAG
:
:
Record
&
CallDAG
:
:
getRecordFromIndex
(
size_t
index
)
const
{
ASSERT
(
index
!
=
InvalidIndex
&
&
index
<
mRecords
.
size
(
)
)
;
return
mRecords
[
index
]
;
}
const
CallDAG
:
:
Record
&
CallDAG
:
:
getRecord
(
const
TIntermAggregate
*
function
)
const
{
size_t
index
=
findIndex
(
function
-
>
getFunctionSymbolInfo
(
)
)
;
ASSERT
(
index
!
=
InvalidIndex
&
&
index
<
mRecords
.
size
(
)
)
;
return
mRecords
[
index
]
;
}
size_t
CallDAG
:
:
size
(
)
const
{
return
mRecords
.
size
(
)
;
}
void
CallDAG
:
:
clear
(
)
{
mRecords
.
clear
(
)
;
mFunctionIdToIndex
.
clear
(
)
;
}
CallDAG
:
:
InitResult
CallDAG
:
:
init
(
TIntermNode
*
root
TInfoSinkBase
*
info
)
{
ASSERT
(
info
)
;
CallDAGCreator
creator
(
info
)
;
root
-
>
traverse
(
&
creator
)
;
InitResult
result
=
creator
.
assignIndices
(
)
;
if
(
result
!
=
INITDAG_SUCCESS
)
{
return
result
;
}
creator
.
fillDataStructures
(
&
mRecords
&
mFunctionIdToIndex
)
;
return
INITDAG_SUCCESS
;
}
}
