#
include
"
compiler
/
translator
/
PruneEmptyDeclarations
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
namespace
sh
{
namespace
{
class
PruneEmptyDeclarationsTraverser
:
private
TIntermTraverser
{
public
:
static
void
apply
(
TIntermNode
*
root
)
;
private
:
PruneEmptyDeclarationsTraverser
(
)
;
bool
visitDeclaration
(
Visit
TIntermDeclaration
*
node
)
override
;
}
;
void
PruneEmptyDeclarationsTraverser
:
:
apply
(
TIntermNode
*
root
)
{
PruneEmptyDeclarationsTraverser
prune
;
root
-
>
traverse
(
&
prune
)
;
prune
.
updateTree
(
)
;
}
PruneEmptyDeclarationsTraverser
:
:
PruneEmptyDeclarationsTraverser
(
)
:
TIntermTraverser
(
true
false
false
)
{
}
bool
PruneEmptyDeclarationsTraverser
:
:
visitDeclaration
(
Visit
TIntermDeclaration
*
node
)
{
TIntermSequence
*
sequence
=
node
-
>
getSequence
(
)
;
if
(
sequence
-
>
size
(
)
>
=
1
)
{
TIntermSymbol
*
sym
=
sequence
-
>
front
(
)
-
>
getAsSymbolNode
(
)
;
if
(
sym
!
=
nullptr
&
&
sym
-
>
getSymbol
(
)
=
=
"
"
&
&
!
sym
-
>
isInterfaceBlock
(
)
)
{
if
(
sequence
-
>
size
(
)
>
1
)
{
TIntermSequence
emptyReplacement
;
mMultiReplacements
.
push_back
(
NodeReplaceWithMultipleEntry
(
node
sym
emptyReplacement
)
)
;
}
else
if
(
sym
-
>
getBasicType
(
)
!
=
EbtStruct
)
{
TIntermSequence
emptyReplacement
;
TIntermBlock
*
parentAsBlock
=
getParentNode
(
)
-
>
getAsBlock
(
)
;
ASSERT
(
parentAsBlock
!
=
nullptr
|
|
getParentNode
(
)
-
>
getAsLoopNode
(
)
!
=
nullptr
)
;
if
(
parentAsBlock
)
{
mMultiReplacements
.
push_back
(
NodeReplaceWithMultipleEntry
(
parentAsBlock
node
emptyReplacement
)
)
;
}
else
{
queueReplacement
(
node
nullptr
OriginalNode
:
:
IS_DROPPED
)
;
}
}
else
if
(
sym
-
>
getType
(
)
.
getQualifier
(
)
!
=
EvqGlobal
&
&
sym
-
>
getType
(
)
.
getQualifier
(
)
!
=
EvqTemporary
)
{
if
(
mInGlobalScope
)
{
sym
-
>
getTypePointer
(
)
-
>
setQualifier
(
EvqGlobal
)
;
}
else
{
sym
-
>
getTypePointer
(
)
-
>
setQualifier
(
EvqTemporary
)
;
}
}
}
}
return
false
;
}
}
void
PruneEmptyDeclarations
(
TIntermNode
*
root
)
{
PruneEmptyDeclarationsTraverser
:
:
apply
(
root
)
;
}
}
