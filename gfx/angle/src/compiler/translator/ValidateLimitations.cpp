#
include
"
compiler
/
translator
/
ValidateLimitations
.
h
"
#
include
"
compiler
/
translator
/
InfoSink
.
h
"
#
include
"
compiler
/
translator
/
InitializeParseContext
.
h
"
#
include
"
compiler
/
translator
/
ParseContext
.
h
"
#
include
"
angle_gl
.
h
"
namespace
sh
{
namespace
{
int
GetLoopSymbolId
(
TIntermLoop
*
loop
)
{
TIntermSequence
*
declSeq
=
loop
-
>
getInit
(
)
-
>
getAsDeclarationNode
(
)
-
>
getSequence
(
)
;
TIntermBinary
*
declInit
=
(
*
declSeq
)
[
0
]
-
>
getAsBinaryNode
(
)
;
TIntermSymbol
*
symbol
=
declInit
-
>
getLeft
(
)
-
>
getAsSymbolNode
(
)
;
return
symbol
-
>
getId
(
)
;
}
class
ValidateConstIndexExpr
:
public
TIntermTraverser
{
public
:
ValidateConstIndexExpr
(
const
std
:
:
vector
<
int
>
&
loopSymbols
)
:
TIntermTraverser
(
true
false
false
)
mValid
(
true
)
mLoopSymbolIds
(
loopSymbols
)
{
}
bool
isValid
(
)
const
{
return
mValid
;
}
void
visitSymbol
(
TIntermSymbol
*
symbol
)
override
{
if
(
mValid
)
{
bool
isLoopSymbol
=
std
:
:
find
(
mLoopSymbolIds
.
begin
(
)
mLoopSymbolIds
.
end
(
)
symbol
-
>
getId
(
)
)
!
=
mLoopSymbolIds
.
end
(
)
;
mValid
=
(
symbol
-
>
getQualifier
(
)
=
=
EvqConst
)
|
|
isLoopSymbol
;
}
}
private
:
bool
mValid
;
const
std
:
:
vector
<
int
>
mLoopSymbolIds
;
}
;
}
ValidateLimitations
:
:
ValidateLimitations
(
sh
:
:
GLenum
shaderType
TInfoSinkBase
*
sink
)
:
TIntermTraverser
(
true
false
false
)
mShaderType
(
shaderType
)
mSink
(
sink
)
mNumErrors
(
0
)
mValidateIndexing
(
true
)
mValidateInnerLoops
(
true
)
{
}
bool
ValidateLimitations
:
:
IsLimitedForLoop
(
TIntermLoop
*
loop
)
{
ValidateLimitations
validate
(
GL_FRAGMENT_SHADER
nullptr
)
;
validate
.
mValidateIndexing
=
false
;
validate
.
mValidateInnerLoops
=
false
;
if
(
!
validate
.
validateLoopType
(
loop
)
)
return
false
;
if
(
!
validate
.
validateForLoopHeader
(
loop
)
)
return
false
;
TIntermNode
*
body
=
loop
-
>
getBody
(
)
;
if
(
body
!
=
nullptr
)
{
validate
.
mLoopSymbolIds
.
push_back
(
GetLoopSymbolId
(
loop
)
)
;
body
-
>
traverse
(
&
validate
)
;
validate
.
mLoopSymbolIds
.
pop_back
(
)
;
}
return
(
validate
.
mNumErrors
=
=
0
)
;
}
bool
ValidateLimitations
:
:
visitBinary
(
Visit
TIntermBinary
*
node
)
{
validateOperation
(
node
node
-
>
getLeft
(
)
)
;
switch
(
node
-
>
getOp
(
)
)
{
case
EOpIndexDirect
:
case
EOpIndexIndirect
:
if
(
mValidateIndexing
)
validateIndexing
(
node
)
;
break
;
default
:
break
;
}
return
true
;
}
bool
ValidateLimitations
:
:
visitUnary
(
Visit
TIntermUnary
*
node
)
{
validateOperation
(
node
node
-
>
getOperand
(
)
)
;
return
true
;
}
bool
ValidateLimitations
:
:
visitAggregate
(
Visit
TIntermAggregate
*
node
)
{
switch
(
node
-
>
getOp
(
)
)
{
case
EOpFunctionCall
:
validateFunctionCall
(
node
)
;
break
;
default
:
break
;
}
return
true
;
}
bool
ValidateLimitations
:
:
visitLoop
(
Visit
TIntermLoop
*
node
)
{
if
(
!
mValidateInnerLoops
)
return
true
;
if
(
!
validateLoopType
(
node
)
)
return
false
;
if
(
!
validateForLoopHeader
(
node
)
)
return
false
;
TIntermNode
*
body
=
node
-
>
getBody
(
)
;
if
(
body
!
=
NULL
)
{
mLoopSymbolIds
.
push_back
(
GetLoopSymbolId
(
node
)
)
;
body
-
>
traverse
(
this
)
;
mLoopSymbolIds
.
pop_back
(
)
;
}
return
false
;
}
void
ValidateLimitations
:
:
error
(
TSourceLoc
loc
const
char
*
reason
const
char
*
token
)
{
if
(
mSink
)
{
mSink
-
>
prefix
(
EPrefixError
)
;
mSink
-
>
location
(
loc
)
;
(
*
mSink
)
<
<
"
'
"
<
<
token
<
<
"
'
:
"
<
<
reason
<
<
"
\
n
"
;
}
+
+
mNumErrors
;
}
bool
ValidateLimitations
:
:
withinLoopBody
(
)
const
{
return
!
mLoopSymbolIds
.
empty
(
)
;
}
bool
ValidateLimitations
:
:
isLoopIndex
(
TIntermSymbol
*
symbol
)
{
return
std
:
:
find
(
mLoopSymbolIds
.
begin
(
)
mLoopSymbolIds
.
end
(
)
symbol
-
>
getId
(
)
)
!
=
mLoopSymbolIds
.
end
(
)
;
}
bool
ValidateLimitations
:
:
validateLoopType
(
TIntermLoop
*
node
)
{
TLoopType
type
=
node
-
>
getType
(
)
;
if
(
type
=
=
ELoopFor
)
return
true
;
error
(
node
-
>
getLine
(
)
"
This
type
of
loop
is
not
allowed
"
type
=
=
ELoopWhile
?
"
while
"
:
"
do
"
)
;
return
false
;
}
bool
ValidateLimitations
:
:
validateForLoopHeader
(
TIntermLoop
*
node
)
{
ASSERT
(
node
-
>
getType
(
)
=
=
ELoopFor
)
;
int
indexSymbolId
=
validateForLoopInit
(
node
)
;
if
(
indexSymbolId
<
0
)
return
false
;
if
(
!
validateForLoopCond
(
node
indexSymbolId
)
)
return
false
;
if
(
!
validateForLoopExpr
(
node
indexSymbolId
)
)
return
false
;
return
true
;
}
int
ValidateLimitations
:
:
validateForLoopInit
(
TIntermLoop
*
node
)
{
TIntermNode
*
init
=
node
-
>
getInit
(
)
;
if
(
init
=
=
NULL
)
{
error
(
node
-
>
getLine
(
)
"
Missing
init
declaration
"
"
for
"
)
;
return
-
1
;
}
TIntermDeclaration
*
decl
=
init
-
>
getAsDeclarationNode
(
)
;
if
(
decl
=
=
nullptr
)
{
error
(
init
-
>
getLine
(
)
"
Invalid
init
declaration
"
"
for
"
)
;
return
-
1
;
}
TIntermSequence
*
declSeq
=
decl
-
>
getSequence
(
)
;
if
(
declSeq
-
>
size
(
)
!
=
1
)
{
error
(
decl
-
>
getLine
(
)
"
Invalid
init
declaration
"
"
for
"
)
;
return
-
1
;
}
TIntermBinary
*
declInit
=
(
*
declSeq
)
[
0
]
-
>
getAsBinaryNode
(
)
;
if
(
(
declInit
=
=
NULL
)
|
|
(
declInit
-
>
getOp
(
)
!
=
EOpInitialize
)
)
{
error
(
decl
-
>
getLine
(
)
"
Invalid
init
declaration
"
"
for
"
)
;
return
-
1
;
}
TIntermSymbol
*
symbol
=
declInit
-
>
getLeft
(
)
-
>
getAsSymbolNode
(
)
;
if
(
symbol
=
=
NULL
)
{
error
(
declInit
-
>
getLine
(
)
"
Invalid
init
declaration
"
"
for
"
)
;
return
-
1
;
}
TBasicType
type
=
symbol
-
>
getBasicType
(
)
;
if
(
(
type
!
=
EbtInt
)
&
&
(
type
!
=
EbtUInt
)
&
&
(
type
!
=
EbtFloat
)
)
{
error
(
symbol
-
>
getLine
(
)
"
Invalid
type
for
loop
index
"
getBasicString
(
type
)
)
;
return
-
1
;
}
if
(
!
isConstExpr
(
declInit
-
>
getRight
(
)
)
)
{
error
(
declInit
-
>
getLine
(
)
"
Loop
index
cannot
be
initialized
with
non
-
constant
expression
"
symbol
-
>
getSymbol
(
)
.
c_str
(
)
)
;
return
-
1
;
}
return
symbol
-
>
getId
(
)
;
}
bool
ValidateLimitations
:
:
validateForLoopCond
(
TIntermLoop
*
node
int
indexSymbolId
)
{
TIntermNode
*
cond
=
node
-
>
getCondition
(
)
;
if
(
cond
=
=
NULL
)
{
error
(
node
-
>
getLine
(
)
"
Missing
condition
"
"
for
"
)
;
return
false
;
}
TIntermBinary
*
binOp
=
cond
-
>
getAsBinaryNode
(
)
;
if
(
binOp
=
=
NULL
)
{
error
(
node
-
>
getLine
(
)
"
Invalid
condition
"
"
for
"
)
;
return
false
;
}
TIntermSymbol
*
symbol
=
binOp
-
>
getLeft
(
)
-
>
getAsSymbolNode
(
)
;
if
(
symbol
=
=
NULL
)
{
error
(
binOp
-
>
getLine
(
)
"
Invalid
condition
"
"
for
"
)
;
return
false
;
}
if
(
symbol
-
>
getId
(
)
!
=
indexSymbolId
)
{
error
(
symbol
-
>
getLine
(
)
"
Expected
loop
index
"
symbol
-
>
getSymbol
(
)
.
c_str
(
)
)
;
return
false
;
}
switch
(
binOp
-
>
getOp
(
)
)
{
case
EOpEqual
:
case
EOpNotEqual
:
case
EOpLessThan
:
case
EOpGreaterThan
:
case
EOpLessThanEqual
:
case
EOpGreaterThanEqual
:
break
;
default
:
error
(
binOp
-
>
getLine
(
)
"
Invalid
relational
operator
"
GetOperatorString
(
binOp
-
>
getOp
(
)
)
)
;
break
;
}
if
(
!
isConstExpr
(
binOp
-
>
getRight
(
)
)
)
{
error
(
binOp
-
>
getLine
(
)
"
Loop
index
cannot
be
compared
with
non
-
constant
expression
"
symbol
-
>
getSymbol
(
)
.
c_str
(
)
)
;
return
false
;
}
return
true
;
}
bool
ValidateLimitations
:
:
validateForLoopExpr
(
TIntermLoop
*
node
int
indexSymbolId
)
{
TIntermNode
*
expr
=
node
-
>
getExpression
(
)
;
if
(
expr
=
=
NULL
)
{
error
(
node
-
>
getLine
(
)
"
Missing
expression
"
"
for
"
)
;
return
false
;
}
TIntermUnary
*
unOp
=
expr
-
>
getAsUnaryNode
(
)
;
TIntermBinary
*
binOp
=
unOp
?
NULL
:
expr
-
>
getAsBinaryNode
(
)
;
TOperator
op
=
EOpNull
;
TIntermSymbol
*
symbol
=
NULL
;
if
(
unOp
!
=
NULL
)
{
op
=
unOp
-
>
getOp
(
)
;
symbol
=
unOp
-
>
getOperand
(
)
-
>
getAsSymbolNode
(
)
;
}
else
if
(
binOp
!
=
NULL
)
{
op
=
binOp
-
>
getOp
(
)
;
symbol
=
binOp
-
>
getLeft
(
)
-
>
getAsSymbolNode
(
)
;
}
if
(
symbol
=
=
NULL
)
{
error
(
expr
-
>
getLine
(
)
"
Invalid
expression
"
"
for
"
)
;
return
false
;
}
if
(
symbol
-
>
getId
(
)
!
=
indexSymbolId
)
{
error
(
symbol
-
>
getLine
(
)
"
Expected
loop
index
"
symbol
-
>
getSymbol
(
)
.
c_str
(
)
)
;
return
false
;
}
switch
(
op
)
{
case
EOpPostIncrement
:
case
EOpPostDecrement
:
case
EOpPreIncrement
:
case
EOpPreDecrement
:
ASSERT
(
(
unOp
!
=
NULL
)
&
&
(
binOp
=
=
NULL
)
)
;
break
;
case
EOpAddAssign
:
case
EOpSubAssign
:
ASSERT
(
(
unOp
=
=
NULL
)
&
&
(
binOp
!
=
NULL
)
)
;
break
;
default
:
error
(
expr
-
>
getLine
(
)
"
Invalid
operator
"
GetOperatorString
(
op
)
)
;
return
false
;
}
if
(
binOp
!
=
NULL
)
{
if
(
!
isConstExpr
(
binOp
-
>
getRight
(
)
)
)
{
error
(
binOp
-
>
getLine
(
)
"
Loop
index
cannot
be
modified
by
non
-
constant
expression
"
symbol
-
>
getSymbol
(
)
.
c_str
(
)
)
;
return
false
;
}
}
return
true
;
}
bool
ValidateLimitations
:
:
validateFunctionCall
(
TIntermAggregate
*
node
)
{
ASSERT
(
node
-
>
getOp
(
)
=
=
EOpFunctionCall
)
;
if
(
!
withinLoopBody
(
)
)
return
true
;
typedef
std
:
:
vector
<
size_t
>
ParamIndex
;
ParamIndex
pIndex
;
TIntermSequence
*
params
=
node
-
>
getSequence
(
)
;
for
(
TIntermSequence
:
:
size_type
i
=
0
;
i
<
params
-
>
size
(
)
;
+
+
i
)
{
TIntermSymbol
*
symbol
=
(
*
params
)
[
i
]
-
>
getAsSymbolNode
(
)
;
if
(
symbol
&
&
isLoopIndex
(
symbol
)
)
pIndex
.
push_back
(
i
)
;
}
if
(
pIndex
.
empty
(
)
)
return
true
;
bool
valid
=
true
;
TSymbolTable
&
symbolTable
=
GetGlobalParseContext
(
)
-
>
symbolTable
;
TSymbol
*
symbol
=
symbolTable
.
find
(
node
-
>
getFunctionSymbolInfo
(
)
-
>
getName
(
)
GetGlobalParseContext
(
)
-
>
getShaderVersion
(
)
)
;
ASSERT
(
symbol
&
&
symbol
-
>
isFunction
(
)
)
;
TFunction
*
function
=
static_cast
<
TFunction
*
>
(
symbol
)
;
for
(
ParamIndex
:
:
const_iterator
i
=
pIndex
.
begin
(
)
;
i
!
=
pIndex
.
end
(
)
;
+
+
i
)
{
const
TConstParameter
&
param
=
function
-
>
getParam
(
*
i
)
;
TQualifier
qual
=
param
.
type
-
>
getQualifier
(
)
;
if
(
(
qual
=
=
EvqOut
)
|
|
(
qual
=
=
EvqInOut
)
)
{
error
(
(
*
params
)
[
*
i
]
-
>
getLine
(
)
"
Loop
index
cannot
be
used
as
argument
to
a
function
out
or
inout
parameter
"
(
*
params
)
[
*
i
]
-
>
getAsSymbolNode
(
)
-
>
getSymbol
(
)
.
c_str
(
)
)
;
valid
=
false
;
}
}
return
valid
;
}
bool
ValidateLimitations
:
:
validateOperation
(
TIntermOperator
*
node
TIntermNode
*
operand
)
{
if
(
!
withinLoopBody
(
)
|
|
!
node
-
>
isAssignment
(
)
)
return
true
;
TIntermSymbol
*
symbol
=
operand
-
>
getAsSymbolNode
(
)
;
if
(
symbol
&
&
isLoopIndex
(
symbol
)
)
{
error
(
node
-
>
getLine
(
)
"
Loop
index
cannot
be
statically
assigned
to
within
the
body
of
the
loop
"
symbol
-
>
getSymbol
(
)
.
c_str
(
)
)
;
}
return
true
;
}
bool
ValidateLimitations
:
:
isConstExpr
(
TIntermNode
*
node
)
{
ASSERT
(
node
!
=
nullptr
)
;
return
node
-
>
getAsConstantUnion
(
)
!
=
nullptr
&
&
node
-
>
getAsTyped
(
)
-
>
getQualifier
(
)
=
=
EvqConst
;
}
bool
ValidateLimitations
:
:
isConstIndexExpr
(
TIntermNode
*
node
)
{
ASSERT
(
node
!
=
NULL
)
;
ValidateConstIndexExpr
validate
(
mLoopSymbolIds
)
;
node
-
>
traverse
(
&
validate
)
;
return
validate
.
isValid
(
)
;
}
bool
ValidateLimitations
:
:
validateIndexing
(
TIntermBinary
*
node
)
{
ASSERT
(
(
node
-
>
getOp
(
)
=
=
EOpIndexDirect
)
|
|
(
node
-
>
getOp
(
)
=
=
EOpIndexIndirect
)
)
;
bool
valid
=
true
;
TIntermTyped
*
index
=
node
-
>
getRight
(
)
;
TIntermTyped
*
operand
=
node
-
>
getLeft
(
)
;
bool
skip
=
(
mShaderType
=
=
GL_VERTEX_SHADER
)
&
&
(
operand
-
>
getQualifier
(
)
=
=
EvqUniform
)
;
if
(
!
skip
&
&
!
isConstIndexExpr
(
index
)
)
{
error
(
index
-
>
getLine
(
)
"
Index
expression
must
be
constant
"
"
[
]
"
)
;
valid
=
false
;
}
return
valid
;
}
}
