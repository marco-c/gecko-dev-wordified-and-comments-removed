#
include
"
compiler
/
translator
/
UnfoldShortCircuitAST
.
h
"
namespace
{
TIntermSelection
*
UnfoldOR
(
TIntermTyped
*
x
TIntermTyped
*
y
)
{
const
TType
boolType
(
EbtBool
EbpUndefined
)
;
TConstantUnion
*
u
=
new
TConstantUnion
;
u
-
>
setBConst
(
true
)
;
TIntermConstantUnion
*
trueNode
=
new
TIntermConstantUnion
(
u
TType
(
EbtBool
EbpUndefined
EvqConst
1
)
)
;
return
new
TIntermSelection
(
x
trueNode
y
boolType
)
;
}
TIntermSelection
*
UnfoldAND
(
TIntermTyped
*
x
TIntermTyped
*
y
)
{
const
TType
boolType
(
EbtBool
EbpUndefined
)
;
TConstantUnion
*
u
=
new
TConstantUnion
;
u
-
>
setBConst
(
false
)
;
TIntermConstantUnion
*
falseNode
=
new
TIntermConstantUnion
(
u
TType
(
EbtBool
EbpUndefined
EvqConst
1
)
)
;
return
new
TIntermSelection
(
x
y
falseNode
boolType
)
;
}
}
bool
UnfoldShortCircuitAST
:
:
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
{
TIntermSelection
*
replacement
=
NULL
;
switch
(
node
-
>
getOp
(
)
)
{
case
EOpLogicalOr
:
replacement
=
UnfoldOR
(
node
-
>
getLeft
(
)
node
-
>
getRight
(
)
)
;
break
;
case
EOpLogicalAnd
:
replacement
=
UnfoldAND
(
node
-
>
getLeft
(
)
node
-
>
getRight
(
)
)
;
break
;
default
:
break
;
}
if
(
replacement
)
{
mReplacements
.
push_back
(
NodeUpdateEntry
(
getParentNode
(
)
node
replacement
false
)
)
;
}
return
true
;
}
