#
include
"
compiler
/
translator
/
UnfoldShortCircuitAST
.
h
"
namespace
sh
{
namespace
{
TIntermTernary
*
UnfoldOR
(
TIntermTyped
*
x
TIntermTyped
*
y
)
{
TConstantUnion
*
u
=
new
TConstantUnion
;
u
-
>
setBConst
(
true
)
;
TIntermConstantUnion
*
trueNode
=
new
TIntermConstantUnion
(
u
TType
(
EbtBool
EbpUndefined
EvqConst
1
)
)
;
return
new
TIntermTernary
(
x
trueNode
y
)
;
}
TIntermTernary
*
UnfoldAND
(
TIntermTyped
*
x
TIntermTyped
*
y
)
{
TConstantUnion
*
u
=
new
TConstantUnion
;
u
-
>
setBConst
(
false
)
;
TIntermConstantUnion
*
falseNode
=
new
TIntermConstantUnion
(
u
TType
(
EbtBool
EbpUndefined
EvqConst
1
)
)
;
return
new
TIntermTernary
(
x
y
falseNode
)
;
}
}
bool
UnfoldShortCircuitAST
:
:
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
{
TIntermTernary
*
replacement
=
nullptr
;
switch
(
node
-
>
getOp
(
)
)
{
case
EOpLogicalOr
:
replacement
=
UnfoldOR
(
node
-
>
getLeft
(
)
node
-
>
getRight
(
)
)
;
break
;
case
EOpLogicalAnd
:
replacement
=
UnfoldAND
(
node
-
>
getLeft
(
)
node
-
>
getRight
(
)
)
;
break
;
default
:
break
;
}
if
(
replacement
)
{
queueReplacement
(
replacement
OriginalNode
:
:
IS_DROPPED
)
;
}
return
true
;
}
}
