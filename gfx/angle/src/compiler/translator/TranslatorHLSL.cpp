#
include
"
compiler
/
translator
/
TranslatorHLSL
.
h
"
#
include
"
compiler
/
translator
/
ArrayReturnValueToOutParameter
.
h
"
#
include
"
compiler
/
translator
/
OutputHLSL
.
h
"
#
include
"
compiler
/
translator
/
RemoveDynamicIndexing
.
h
"
#
include
"
compiler
/
translator
/
RewriteElseBlocks
.
h
"
#
include
"
compiler
/
translator
/
SeparateArrayInitialization
.
h
"
#
include
"
compiler
/
translator
/
SeparateDeclarations
.
h
"
#
include
"
compiler
/
translator
/
SeparateExpressionsReturningArrays
.
h
"
#
include
"
compiler
/
translator
/
UnfoldShortCircuitToIf
.
h
"
TranslatorHLSL
:
:
TranslatorHLSL
(
sh
:
:
GLenum
type
ShShaderSpec
spec
ShShaderOutput
output
)
:
TCompiler
(
type
spec
output
)
{
}
void
TranslatorHLSL
:
:
translate
(
TIntermNode
*
root
int
compileOptions
)
{
const
ShBuiltInResources
&
resources
=
getResources
(
)
;
int
numRenderTargets
=
resources
.
EXT_draw_buffers
?
resources
.
MaxDrawBuffers
:
1
;
SeparateDeclarations
(
root
)
;
unsigned
int
temporaryIndex
=
0
;
UnfoldShortCircuitToIf
(
root
&
temporaryIndex
)
;
SeparateExpressionsReturningArrays
(
root
&
temporaryIndex
)
;
SeparateArrayInitialization
(
root
)
;
ArrayReturnValueToOutParameter
(
root
&
temporaryIndex
)
;
if
(
!
shouldRunLoopAndIndexingValidation
(
compileOptions
)
)
{
RemoveDynamicIndexing
(
root
&
temporaryIndex
getSymbolTable
(
)
getShaderVersion
(
)
)
;
}
if
(
getOutputType
(
)
=
=
SH_HLSL9_OUTPUT
&
&
getShaderType
(
)
=
=
GL_VERTEX_SHADER
)
{
sh
:
:
RewriteElseBlocks
(
root
&
temporaryIndex
)
;
}
sh
:
:
OutputHLSL
outputHLSL
(
getShaderType
(
)
getShaderVersion
(
)
getExtensionBehavior
(
)
getSourcePath
(
)
getOutputType
(
)
numRenderTargets
getUniforms
(
)
compileOptions
)
;
outputHLSL
.
output
(
root
getInfoSink
(
)
.
obj
)
;
mInterfaceBlockRegisterMap
=
outputHLSL
.
getInterfaceBlockRegisterMap
(
)
;
mUniformRegisterMap
=
outputHLSL
.
getUniformRegisterMap
(
)
;
}
bool
TranslatorHLSL
:
:
hasInterfaceBlock
(
const
std
:
:
string
&
interfaceBlockName
)
const
{
return
(
mInterfaceBlockRegisterMap
.
count
(
interfaceBlockName
)
>
0
)
;
}
unsigned
int
TranslatorHLSL
:
:
getInterfaceBlockRegister
(
const
std
:
:
string
&
interfaceBlockName
)
const
{
ASSERT
(
hasInterfaceBlock
(
interfaceBlockName
)
)
;
return
mInterfaceBlockRegisterMap
.
find
(
interfaceBlockName
)
-
>
second
;
}
bool
TranslatorHLSL
:
:
hasUniform
(
const
std
:
:
string
&
uniformName
)
const
{
return
(
mUniformRegisterMap
.
count
(
uniformName
)
>
0
)
;
}
unsigned
int
TranslatorHLSL
:
:
getUniformRegister
(
const
std
:
:
string
&
uniformName
)
const
{
ASSERT
(
hasUniform
(
uniformName
)
)
;
return
mUniformRegisterMap
.
find
(
uniformName
)
-
>
second
;
}
