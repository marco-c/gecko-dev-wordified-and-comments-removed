#
include
"
compiler
/
translator
/
OutputVulkanGLSL
.
h
"
namespace
sh
{
TOutputVulkanGLSL
:
:
TOutputVulkanGLSL
(
TInfoSinkBase
&
objSink
ShArrayIndexClampingStrategy
clampingStrategy
ShHashFunction64
hashFunction
NameMap
&
nameMap
TSymbolTable
*
symbolTable
sh
:
:
GLenum
shaderType
int
shaderVersion
ShShaderOutput
output
ShCompileOptions
compileOptions
)
:
TOutputGLSLBase
(
objSink
clampingStrategy
hashFunction
nameMap
symbolTable
shaderType
shaderVersion
output
compileOptions
)
{
}
void
TOutputVulkanGLSL
:
:
writeLayoutQualifier
(
const
TType
&
type
)
{
TInfoSinkBase
&
out
=
objSink
(
)
;
const
TLayoutQualifier
&
layoutQualifier
=
type
.
getLayoutQualifier
(
)
;
out
<
<
"
layout
(
"
;
if
(
type
.
getQualifier
(
)
=
=
EvqAttribute
|
|
type
.
getQualifier
(
)
=
=
EvqFragmentOut
|
|
type
.
getQualifier
(
)
=
=
EvqVertexIn
)
{
out
<
<
"
location
=
"
<
<
"
0
"
;
}
if
(
IsImage
(
type
.
getBasicType
(
)
)
&
&
layoutQualifier
.
imageInternalFormat
!
=
EiifUnspecified
)
{
ASSERT
(
type
.
getQualifier
(
)
=
=
EvqTemporary
|
|
type
.
getQualifier
(
)
=
=
EvqUniform
)
;
out
<
<
getImageInternalFormatString
(
layoutQualifier
.
imageInternalFormat
)
;
}
out
<
<
"
)
"
;
}
bool
TOutputVulkanGLSL
:
:
writeVariablePrecision
(
TPrecision
precision
)
{
if
(
precision
=
=
EbpUndefined
)
return
false
;
TInfoSinkBase
&
out
=
objSink
(
)
;
out
<
<
getPrecisionString
(
precision
)
;
return
true
;
}
void
TOutputVulkanGLSL
:
:
visitSymbol
(
TIntermSymbol
*
node
)
{
TInfoSinkBase
&
out
=
objSink
(
)
;
const
TString
&
symbol
=
node
-
>
getSymbol
(
)
;
if
(
symbol
=
=
"
gl_FragColor
"
)
{
out
<
<
"
webgl_FragColor
"
;
}
else
if
(
symbol
=
=
"
gl_FragData
"
)
{
out
<
<
"
webgl_FragData
"
;
}
else
{
TOutputGLSLBase
:
:
visitSymbol
(
node
)
;
}
}
}
