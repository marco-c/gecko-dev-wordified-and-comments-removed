#
ifndef
COMPILER_TRANSLATOR_INTERMTRAVERSE_H_
#
define
COMPILER_TRANSLATOR_INTERMTRAVERSE_H_
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
namespace
sh
{
class
TSymbolTable
;
class
TSymbolUniqueId
;
enum
Visit
{
PreVisit
InVisit
PostVisit
}
;
class
TIntermTraverser
:
angle
:
:
NonCopyable
{
public
:
POOL_ALLOCATOR_NEW_DELETE
(
)
;
TIntermTraverser
(
bool
preVisit
bool
inVisit
bool
postVisit
TSymbolTable
*
symbolTable
=
nullptr
)
;
virtual
~
TIntermTraverser
(
)
;
virtual
void
visitSymbol
(
TIntermSymbol
*
node
)
{
}
virtual
void
visitRaw
(
TIntermRaw
*
node
)
{
}
virtual
void
visitConstantUnion
(
TIntermConstantUnion
*
node
)
{
}
virtual
bool
visitSwizzle
(
Visit
visit
TIntermSwizzle
*
node
)
{
return
true
;
}
virtual
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
{
return
true
;
}
virtual
bool
visitUnary
(
Visit
visit
TIntermUnary
*
node
)
{
return
true
;
}
virtual
bool
visitTernary
(
Visit
visit
TIntermTernary
*
node
)
{
return
true
;
}
virtual
bool
visitIfElse
(
Visit
visit
TIntermIfElse
*
node
)
{
return
true
;
}
virtual
bool
visitSwitch
(
Visit
visit
TIntermSwitch
*
node
)
{
return
true
;
}
virtual
bool
visitCase
(
Visit
visit
TIntermCase
*
node
)
{
return
true
;
}
virtual
bool
visitFunctionPrototype
(
Visit
visit
TIntermFunctionPrototype
*
node
)
{
return
true
;
}
virtual
bool
visitFunctionDefinition
(
Visit
visit
TIntermFunctionDefinition
*
node
)
{
return
true
;
}
virtual
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
{
return
true
;
}
virtual
bool
visitBlock
(
Visit
visit
TIntermBlock
*
node
)
{
return
true
;
}
virtual
bool
visitInvariantDeclaration
(
Visit
visit
TIntermInvariantDeclaration
*
node
)
{
return
true
;
}
virtual
bool
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
node
)
{
return
true
;
}
virtual
bool
visitLoop
(
Visit
visit
TIntermLoop
*
node
)
{
return
true
;
}
virtual
bool
visitBranch
(
Visit
visit
TIntermBranch
*
node
)
{
return
true
;
}
virtual
void
traverseSymbol
(
TIntermSymbol
*
node
)
;
virtual
void
traverseRaw
(
TIntermRaw
*
node
)
;
virtual
void
traverseConstantUnion
(
TIntermConstantUnion
*
node
)
;
virtual
void
traverseSwizzle
(
TIntermSwizzle
*
node
)
;
virtual
void
traverseBinary
(
TIntermBinary
*
node
)
;
virtual
void
traverseUnary
(
TIntermUnary
*
node
)
;
virtual
void
traverseTernary
(
TIntermTernary
*
node
)
;
virtual
void
traverseIfElse
(
TIntermIfElse
*
node
)
;
virtual
void
traverseSwitch
(
TIntermSwitch
*
node
)
;
virtual
void
traverseCase
(
TIntermCase
*
node
)
;
virtual
void
traverseFunctionPrototype
(
TIntermFunctionPrototype
*
node
)
;
virtual
void
traverseFunctionDefinition
(
TIntermFunctionDefinition
*
node
)
;
virtual
void
traverseAggregate
(
TIntermAggregate
*
node
)
;
virtual
void
traverseBlock
(
TIntermBlock
*
node
)
;
virtual
void
traverseInvariantDeclaration
(
TIntermInvariantDeclaration
*
node
)
;
virtual
void
traverseDeclaration
(
TIntermDeclaration
*
node
)
;
virtual
void
traverseLoop
(
TIntermLoop
*
node
)
;
virtual
void
traverseBranch
(
TIntermBranch
*
node
)
;
int
getMaxDepth
(
)
const
{
return
mMaxDepth
;
}
void
updateTree
(
)
;
protected
:
void
incrementDepth
(
TIntermNode
*
current
)
{
mDepth
+
+
;
mMaxDepth
=
std
:
:
max
(
mMaxDepth
mDepth
)
;
mPath
.
push_back
(
current
)
;
}
void
decrementDepth
(
)
{
mDepth
-
-
;
mPath
.
pop_back
(
)
;
}
class
ScopedNodeInTraversalPath
{
public
:
ScopedNodeInTraversalPath
(
TIntermTraverser
*
traverser
TIntermNode
*
current
)
:
mTraverser
(
traverser
)
{
mTraverser
-
>
incrementDepth
(
current
)
;
}
~
ScopedNodeInTraversalPath
(
)
{
mTraverser
-
>
decrementDepth
(
)
;
}
private
:
TIntermTraverser
*
mTraverser
;
}
;
TIntermNode
*
getParentNode
(
)
{
return
mPath
.
size
(
)
<
=
1
?
nullptr
:
mPath
[
mPath
.
size
(
)
-
2u
]
;
}
TIntermNode
*
getAncestorNode
(
unsigned
int
n
)
{
if
(
mPath
.
size
(
)
>
n
+
1u
)
{
return
mPath
[
mPath
.
size
(
)
-
n
-
2u
]
;
}
return
nullptr
;
}
void
pushParentBlock
(
TIntermBlock
*
node
)
;
void
incrementParentBlockPos
(
)
;
void
popParentBlock
(
)
;
struct
NodeReplaceWithMultipleEntry
{
NodeReplaceWithMultipleEntry
(
TIntermAggregateBase
*
_parent
TIntermNode
*
_original
TIntermSequence
_replacements
)
:
parent
(
_parent
)
original
(
_original
)
replacements
(
_replacements
)
{
}
TIntermAggregateBase
*
parent
;
TIntermNode
*
original
;
TIntermSequence
replacements
;
}
;
struct
NodeInsertMultipleEntry
{
NodeInsertMultipleEntry
(
TIntermBlock
*
_parent
TIntermSequence
:
:
size_type
_position
TIntermSequence
_insertionsBefore
TIntermSequence
_insertionsAfter
)
:
parent
(
_parent
)
position
(
_position
)
insertionsBefore
(
_insertionsBefore
)
insertionsAfter
(
_insertionsAfter
)
{
}
TIntermBlock
*
parent
;
TIntermSequence
:
:
size_type
position
;
TIntermSequence
insertionsBefore
;
TIntermSequence
insertionsAfter
;
}
;
void
insertStatementsInParentBlock
(
const
TIntermSequence
&
insertions
)
;
void
insertStatementsInParentBlock
(
const
TIntermSequence
&
insertionsBefore
const
TIntermSequence
&
insertionsAfter
)
;
void
insertStatementInParentBlock
(
TIntermNode
*
statement
)
;
TIntermSymbol
*
createTempSymbol
(
const
TType
&
type
TQualifier
qualifier
)
;
TIntermSymbol
*
createTempSymbol
(
const
TType
&
type
)
;
TIntermDeclaration
*
createTempDeclaration
(
const
TType
&
type
)
;
TIntermDeclaration
*
createTempInitDeclaration
(
TIntermTyped
*
initializer
TQualifier
qualifier
)
;
TIntermDeclaration
*
createTempInitDeclaration
(
TIntermTyped
*
initializer
)
;
TIntermBinary
*
createTempAssignment
(
TIntermTyped
*
rightNode
)
;
void
nextTemporaryId
(
)
;
enum
class
OriginalNode
{
BECOMES_CHILD
IS_DROPPED
}
;
void
clearReplacementQueue
(
)
;
void
queueReplacement
(
TIntermNode
*
replacement
OriginalNode
originalStatus
)
;
void
queueReplacementWithParent
(
TIntermNode
*
parent
TIntermNode
*
original
TIntermNode
*
replacement
OriginalNode
originalStatus
)
;
const
bool
preVisit
;
const
bool
inVisit
;
const
bool
postVisit
;
int
mDepth
;
int
mMaxDepth
;
bool
mInGlobalScope
;
std
:
:
vector
<
NodeReplaceWithMultipleEntry
>
mMultiReplacements
;
std
:
:
vector
<
NodeInsertMultipleEntry
>
mInsertions
;
TSymbolTable
*
mSymbolTable
;
private
:
static
bool
CompareInsertion
(
const
NodeInsertMultipleEntry
&
a
const
NodeInsertMultipleEntry
&
b
)
;
struct
NodeUpdateEntry
{
NodeUpdateEntry
(
TIntermNode
*
_parent
TIntermNode
*
_original
TIntermNode
*
_replacement
bool
_originalBecomesChildOfReplacement
)
:
parent
(
_parent
)
original
(
_original
)
replacement
(
_replacement
)
originalBecomesChildOfReplacement
(
_originalBecomesChildOfReplacement
)
{
}
TIntermNode
*
parent
;
TIntermNode
*
original
;
TIntermNode
*
replacement
;
bool
originalBecomesChildOfReplacement
;
}
;
struct
ParentBlock
{
ParentBlock
(
TIntermBlock
*
nodeIn
TIntermSequence
:
:
size_type
posIn
)
:
node
(
nodeIn
)
pos
(
posIn
)
{
}
TIntermBlock
*
node
;
TIntermSequence
:
:
size_type
pos
;
}
;
std
:
:
vector
<
NodeUpdateEntry
>
mReplacements
;
TVector
<
TIntermNode
*
>
mPath
;
std
:
:
vector
<
ParentBlock
>
mParentBlockStack
;
TSymbolUniqueId
*
mTemporaryId
;
}
;
class
TLValueTrackingTraverser
:
public
TIntermTraverser
{
public
:
TLValueTrackingTraverser
(
bool
preVisit
bool
inVisit
bool
postVisit
TSymbolTable
*
symbolTable
int
shaderVersion
)
;
virtual
~
TLValueTrackingTraverser
(
)
{
}
void
traverseBinary
(
TIntermBinary
*
node
)
final
;
void
traverseUnary
(
TIntermUnary
*
node
)
final
;
void
traverseFunctionPrototype
(
TIntermFunctionPrototype
*
node
)
final
;
void
traverseAggregate
(
TIntermAggregate
*
node
)
final
;
protected
:
bool
isLValueRequiredHere
(
)
const
{
return
mOperatorRequiresLValue
|
|
mInFunctionCallOutParameter
;
}
private
:
void
setOperatorRequiresLValue
(
bool
lValueRequired
)
{
mOperatorRequiresLValue
=
lValueRequired
;
}
bool
operatorRequiresLValue
(
)
const
{
return
mOperatorRequiresLValue
;
}
void
addToFunctionMap
(
const
TSymbolUniqueId
&
id
TIntermSequence
*
paramSequence
)
;
bool
isInFunctionMap
(
const
TIntermAggregate
*
callNode
)
const
;
TIntermSequence
*
getFunctionParameters
(
const
TIntermAggregate
*
callNode
)
;
void
setInFunctionCallOutParameter
(
bool
inOutParameter
)
;
bool
isInFunctionCallOutParameter
(
)
const
;
bool
mOperatorRequiresLValue
;
bool
mInFunctionCallOutParameter
;
TMap
<
int
TIntermSequence
*
>
mFunctionMap
;
const
int
mShaderVersion
;
}
;
}
#
endif
