#
include
"
compiler
/
translator
/
SeparateExpressionsReturningArrays
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
namespace
{
class
SeparateExpressionsTraverser
:
public
TIntermTraverser
{
public
:
SeparateExpressionsTraverser
(
)
;
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
;
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
;
void
nextIteration
(
)
;
bool
foundArrayExpression
(
)
const
{
return
mFoundArrayExpression
;
}
protected
:
bool
mFoundArrayExpression
;
}
;
SeparateExpressionsTraverser
:
:
SeparateExpressionsTraverser
(
)
:
TIntermTraverser
(
true
false
false
)
mFoundArrayExpression
(
false
)
{
}
TIntermBinary
*
CopyAssignmentNode
(
TIntermBinary
*
node
)
{
TIntermBinary
*
copyNode
=
new
TIntermBinary
(
node
-
>
getOp
(
)
)
;
copyNode
-
>
setLeft
(
node
-
>
getLeft
(
)
)
;
copyNode
-
>
setRight
(
node
-
>
getRight
(
)
)
;
copyNode
-
>
setType
(
node
-
>
getType
(
)
)
;
return
copyNode
;
}
TIntermAggregate
*
CopyAggregateNode
(
TIntermAggregate
*
node
)
{
TIntermAggregate
*
copyNode
=
new
TIntermAggregate
(
node
-
>
getOp
(
)
)
;
TIntermSequence
*
copySeq
=
copyNode
-
>
getSequence
(
)
;
copySeq
-
>
insert
(
copySeq
-
>
begin
(
)
node
-
>
getSequence
(
)
-
>
begin
(
)
node
-
>
getSequence
(
)
-
>
end
(
)
)
;
copyNode
-
>
setType
(
node
-
>
getType
(
)
)
;
copyNode
-
>
setFunctionId
(
node
-
>
getFunctionId
(
)
)
;
if
(
node
-
>
isUserDefined
(
)
)
{
copyNode
-
>
setUserDefined
(
)
;
}
copyNode
-
>
setNameObj
(
node
-
>
getNameObj
(
)
)
;
return
copyNode
;
}
bool
SeparateExpressionsTraverser
:
:
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
{
if
(
mFoundArrayExpression
)
return
false
;
if
(
!
node
-
>
getType
(
)
.
isArray
(
)
|
|
parentNodeIsBlock
(
)
)
return
true
;
switch
(
node
-
>
getOp
(
)
)
{
case
EOpAssign
:
{
mFoundArrayExpression
=
true
;
TIntermSequence
insertions
;
insertions
.
push_back
(
CopyAssignmentNode
(
node
)
)
;
insertions
.
push_back
(
createTempInitDeclaration
(
node
-
>
getLeft
(
)
)
)
;
insertStatementsInParentBlock
(
insertions
)
;
NodeUpdateEntry
replaceVariable
(
getParentNode
(
)
node
createTempSymbol
(
node
-
>
getType
(
)
)
false
)
;
mReplacements
.
push_back
(
replaceVariable
)
;
}
return
false
;
default
:
return
true
;
}
}
bool
SeparateExpressionsTraverser
:
:
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
{
if
(
mFoundArrayExpression
)
return
false
;
if
(
getParentNode
(
)
!
=
nullptr
)
{
TIntermBinary
*
parentBinary
=
getParentNode
(
)
-
>
getAsBinaryNode
(
)
;
bool
parentIsAssignment
=
(
parentBinary
!
=
nullptr
&
&
(
parentBinary
-
>
getOp
(
)
=
=
EOpAssign
|
|
parentBinary
-
>
getOp
(
)
=
=
EOpInitialize
)
)
;
if
(
!
node
-
>
getType
(
)
.
isArray
(
)
|
|
parentNodeIsBlock
(
)
|
|
parentIsAssignment
)
return
true
;
if
(
node
-
>
isConstructor
(
)
)
{
mFoundArrayExpression
=
true
;
TIntermSequence
insertions
;
insertions
.
push_back
(
createTempInitDeclaration
(
CopyAggregateNode
(
node
)
)
)
;
insertStatementsInParentBlock
(
insertions
)
;
NodeUpdateEntry
replaceVariable
(
getParentNode
(
)
node
createTempSymbol
(
node
-
>
getType
(
)
)
false
)
;
mReplacements
.
push_back
(
replaceVariable
)
;
return
false
;
}
else
if
(
node
-
>
getOp
(
)
=
=
EOpFunctionCall
)
{
mFoundArrayExpression
=
true
;
TIntermSequence
insertions
;
insertions
.
push_back
(
createTempInitDeclaration
(
CopyAggregateNode
(
node
)
)
)
;
insertStatementsInParentBlock
(
insertions
)
;
NodeUpdateEntry
replaceVariable
(
getParentNode
(
)
node
createTempSymbol
(
node
-
>
getType
(
)
)
false
)
;
mReplacements
.
push_back
(
replaceVariable
)
;
return
false
;
}
}
return
true
;
}
void
SeparateExpressionsTraverser
:
:
nextIteration
(
)
{
mFoundArrayExpression
=
false
;
nextTemporaryIndex
(
)
;
}
}
void
SeparateExpressionsReturningArrays
(
TIntermNode
*
root
unsigned
int
*
temporaryIndex
)
{
SeparateExpressionsTraverser
traverser
;
ASSERT
(
temporaryIndex
!
=
nullptr
)
;
traverser
.
useTemporaryIndex
(
temporaryIndex
)
;
do
{
traverser
.
nextIteration
(
)
;
root
-
>
traverse
(
&
traverser
)
;
if
(
traverser
.
foundArrayExpression
(
)
)
traverser
.
updateTree
(
)
;
}
while
(
traverser
.
foundArrayExpression
(
)
)
;
}
