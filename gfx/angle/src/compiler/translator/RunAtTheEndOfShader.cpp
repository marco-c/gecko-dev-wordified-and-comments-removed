#
include
"
compiler
/
translator
/
RunAtTheEndOfShader
.
h
"
#
include
"
compiler
/
translator
/
FindMain
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
#
include
"
compiler
/
translator
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
IntermTraverse
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
namespace
sh
{
namespace
{
class
ContainsReturnTraverser
:
public
TIntermTraverser
{
public
:
ContainsReturnTraverser
(
)
:
TIntermTraverser
(
true
false
false
)
mContainsReturn
(
false
)
{
}
bool
visitBranch
(
Visit
visit
TIntermBranch
*
node
)
override
{
if
(
node
-
>
getFlowOp
(
)
=
=
EOpReturn
)
{
mContainsReturn
=
true
;
}
return
false
;
}
bool
containsReturn
(
)
{
return
mContainsReturn
;
}
private
:
bool
mContainsReturn
;
}
;
bool
ContainsReturn
(
TIntermNode
*
node
)
{
ContainsReturnTraverser
traverser
;
node
-
>
traverse
(
&
traverser
)
;
return
traverser
.
containsReturn
(
)
;
}
void
WrapMainAndAppend
(
TIntermBlock
*
root
TIntermFunctionDefinition
*
main
TIntermNode
*
codeToRun
TSymbolTable
*
symbolTable
)
{
TSymbolUniqueId
oldMainId
(
symbolTable
)
;
std
:
:
stringstream
oldMainName
;
oldMainName
<
<
"
main
"
<
<
oldMainId
.
get
(
)
;
TIntermFunctionDefinition
*
oldMain
=
CreateInternalFunctionDefinitionNode
(
TType
(
EbtVoid
)
oldMainName
.
str
(
)
.
c_str
(
)
main
-
>
getBody
(
)
oldMainId
)
;
bool
replaced
=
root
-
>
replaceChildNode
(
main
oldMain
)
;
ASSERT
(
replaced
)
;
TIntermFunctionPrototype
*
newMainProto
=
new
TIntermFunctionPrototype
(
TType
(
EbtVoid
)
main
-
>
getFunctionPrototype
(
)
-
>
getFunctionSymbolInfo
(
)
-
>
getId
(
)
)
;
newMainProto
-
>
getFunctionSymbolInfo
(
)
-
>
setName
(
"
main
"
)
;
TIntermBlock
*
newMainBody
=
new
TIntermBlock
(
)
;
TIntermAggregate
*
oldMainCall
=
CreateInternalFunctionCallNode
(
TType
(
EbtVoid
)
oldMainName
.
str
(
)
.
c_str
(
)
oldMainId
new
TIntermSequence
(
)
)
;
newMainBody
-
>
appendStatement
(
oldMainCall
)
;
newMainBody
-
>
appendStatement
(
codeToRun
)
;
TIntermFunctionDefinition
*
newMain
=
new
TIntermFunctionDefinition
(
newMainProto
newMainBody
)
;
root
-
>
appendStatement
(
newMain
)
;
}
}
void
RunAtTheEndOfShader
(
TIntermBlock
*
root
TIntermNode
*
codeToRun
TSymbolTable
*
symbolTable
)
{
TIntermFunctionDefinition
*
main
=
FindMain
(
root
)
;
if
(
!
ContainsReturn
(
main
)
)
{
main
-
>
getBody
(
)
-
>
appendStatement
(
codeToRun
)
;
return
;
}
WrapMainAndAppend
(
root
main
codeToRun
symbolTable
)
;
}
}
