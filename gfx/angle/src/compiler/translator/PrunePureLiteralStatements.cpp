#
include
"
compiler
/
translator
/
PrunePureLiteralStatements
.
h
"
#
include
"
compiler
/
translator
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
class
PrunePureLiteralStatementsTraverser
:
public
TIntermTraverser
{
public
:
PrunePureLiteralStatementsTraverser
(
)
:
TIntermTraverser
(
true
false
false
)
{
}
bool
visitBlock
(
Visit
visit
TIntermBlock
*
node
)
override
{
TIntermSequence
*
statements
=
node
-
>
getSequence
(
)
;
if
(
statements
=
=
nullptr
)
{
return
false
;
}
bool
deleteCaseStatements
=
false
;
for
(
int
i
=
static_cast
<
int
>
(
statements
-
>
size
(
)
)
;
i
-
-
>
0
;
)
{
TIntermNode
*
statement
=
(
*
statements
)
[
i
]
;
if
(
statement
-
>
getAsConstantUnion
(
)
!
=
nullptr
)
{
TIntermSequence
emptyReplacement
;
mMultiReplacements
.
push_back
(
NodeReplaceWithMultipleEntry
(
node
statement
emptyReplacement
)
)
;
if
(
i
=
=
static_cast
<
int
>
(
statements
-
>
size
(
)
)
-
1
)
{
deleteCaseStatements
=
true
;
}
continue
;
}
if
(
deleteCaseStatements
)
{
if
(
statement
-
>
getAsCaseNode
(
)
!
=
nullptr
)
{
TIntermSequence
emptyReplacement
;
mMultiReplacements
.
push_back
(
NodeReplaceWithMultipleEntry
(
node
statement
emptyReplacement
)
)
;
}
else
{
deleteCaseStatements
=
false
;
}
}
}
return
true
;
}
bool
visitLoop
(
Visit
visit
TIntermLoop
*
loop
)
override
{
TIntermTyped
*
expr
=
loop
-
>
getExpression
(
)
;
if
(
expr
!
=
nullptr
&
&
expr
-
>
getAsConstantUnion
(
)
!
=
nullptr
)
{
loop
-
>
setExpression
(
nullptr
)
;
}
return
true
;
}
}
;
}
void
PrunePureLiteralStatements
(
TIntermNode
*
root
)
{
PrunePureLiteralStatementsTraverser
prune
;
root
-
>
traverse
(
&
prune
)
;
prune
.
updateTree
(
)
;
}
}
