#
ifndef
COMPILER_TRANSLATOR_EMULATE_PRECISION_H_
#
define
COMPILER_TRANSLATOR_EMULATE_PRECISION_H_
#
include
"
common
/
angleutils
.
h
"
#
include
"
compiler
/
translator
/
Compiler
.
h
"
#
include
"
compiler
/
translator
/
InfoSink
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
#
include
"
GLSLANG
/
ShaderLang
.
h
"
class
EmulatePrecision
:
public
TIntermTraverser
{
public
:
EmulatePrecision
(
)
;
virtual
void
visitSymbol
(
TIntermSymbol
*
node
)
;
virtual
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
;
virtual
bool
visitUnary
(
Visit
visit
TIntermUnary
*
node
)
;
virtual
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
;
void
writeEmulationHelpers
(
TInfoSinkBase
&
sink
ShShaderOutput
outputLanguage
)
;
private
:
struct
TypePair
{
TypePair
(
const
char
*
l
const
char
*
r
)
:
lType
(
l
)
rType
(
r
)
{
}
const
char
*
lType
;
const
char
*
rType
;
}
;
struct
TypePairComparator
{
bool
operator
(
)
(
const
TypePair
&
l
const
TypePair
&
r
)
const
{
if
(
l
.
lType
=
=
r
.
lType
)
return
l
.
rType
<
r
.
rType
;
return
l
.
lType
<
r
.
lType
;
}
}
;
typedef
std
:
:
set
<
TypePair
TypePairComparator
>
EmulationSet
;
EmulationSet
mEmulateCompoundAdd
;
EmulationSet
mEmulateCompoundSub
;
EmulationSet
mEmulateCompoundMul
;
EmulationSet
mEmulateCompoundDiv
;
std
:
:
vector
<
TIntermSequence
:
:
const_iterator
>
mSeqIterStack
;
bool
mDeclaringVariables
;
bool
mInLValue
;
bool
mInFunctionCallOutParameter
;
struct
TStringComparator
{
bool
operator
(
)
(
const
TString
&
a
const
TString
&
b
)
const
{
return
a
.
compare
(
b
)
<
0
;
}
}
;
std
:
:
map
<
TString
TIntermSequence
*
TStringComparator
>
mFunctionMap
;
}
;
#
endif
