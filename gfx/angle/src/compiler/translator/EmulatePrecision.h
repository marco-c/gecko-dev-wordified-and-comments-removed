#
ifndef
COMPILER_TRANSLATOR_EMULATE_PRECISION_H_
#
define
COMPILER_TRANSLATOR_EMULATE_PRECISION_H_
#
include
"
common
/
angleutils
.
h
"
#
include
"
compiler
/
translator
/
Compiler
.
h
"
#
include
"
compiler
/
translator
/
InfoSink
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
#
include
"
GLSLANG
/
ShaderLang
.
h
"
namespace
sh
{
class
EmulatePrecision
:
public
TLValueTrackingTraverser
{
public
:
EmulatePrecision
(
const
TSymbolTable
&
symbolTable
int
shaderVersion
)
;
void
visitSymbol
(
TIntermSymbol
*
node
)
override
;
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
;
bool
visitUnary
(
Visit
visit
TIntermUnary
*
node
)
override
;
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
;
bool
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
node
)
override
;
void
writeEmulationHelpers
(
TInfoSinkBase
&
sink
const
int
shaderVersion
const
ShShaderOutput
outputLanguage
)
;
static
bool
SupportedInLanguage
(
const
ShShaderOutput
outputLanguage
)
;
private
:
struct
TypePair
{
TypePair
(
const
char
*
l
const
char
*
r
)
:
lType
(
l
)
rType
(
r
)
{
}
const
char
*
lType
;
const
char
*
rType
;
}
;
struct
TypePairComparator
{
bool
operator
(
)
(
const
TypePair
&
l
const
TypePair
&
r
)
const
{
if
(
l
.
lType
=
=
r
.
lType
)
return
l
.
rType
<
r
.
rType
;
return
l
.
lType
<
r
.
lType
;
}
}
;
typedef
std
:
:
set
<
TypePair
TypePairComparator
>
EmulationSet
;
EmulationSet
mEmulateCompoundAdd
;
EmulationSet
mEmulateCompoundSub
;
EmulationSet
mEmulateCompoundMul
;
EmulationSet
mEmulateCompoundDiv
;
bool
mDeclaringVariables
;
}
;
}
#
endif
