#
ifndef
COMPILER_TRANSLATOR_BASETYPES_H_
#
define
COMPILER_TRANSLATOR_BASETYPES_H_
#
include
<
algorithm
>
#
include
<
array
>
#
include
"
common
/
debug
.
h
"
#
include
"
GLSLANG
/
ShaderLang
.
h
"
enum
TPrecision
{
EbpUndefined
EbpLow
EbpMedium
EbpHigh
EbpLast
}
;
inline
const
char
*
getPrecisionString
(
TPrecision
p
)
{
switch
(
p
)
{
case
EbpHigh
:
return
"
highp
"
;
break
;
case
EbpMedium
:
return
"
mediump
"
;
break
;
case
EbpLow
:
return
"
lowp
"
;
break
;
default
:
return
"
mediump
"
;
break
;
}
}
enum
TBasicType
{
EbtVoid
EbtFloat
EbtInt
EbtUInt
EbtBool
EbtGVec4
EbtGenType
EbtGenIType
EbtGenUType
EbtGenBType
EbtVec
EbtIVec
EbtUVec
EbtBVec
EbtGuardSamplerBegin
EbtSampler2D
EbtSampler3D
EbtSamplerCube
EbtSampler2DArray
EbtSamplerExternalOES
EbtSampler2DRect
EbtISampler2D
EbtISampler3D
EbtISamplerCube
EbtISampler2DArray
EbtUSampler2D
EbtUSampler3D
EbtUSamplerCube
EbtUSampler2DArray
EbtSampler2DShadow
EbtSamplerCubeShadow
EbtSampler2DArrayShadow
EbtGuardSamplerEnd
EbtGSampler2D
EbtGSampler3D
EbtGSamplerCube
EbtGSampler2DArray
EbtStruct
EbtInterfaceBlock
EbtAddress
EbtLast
}
;
const
char
*
getBasicString
(
TBasicType
t
)
;
inline
bool
IsSampler
(
TBasicType
type
)
{
return
type
>
EbtGuardSamplerBegin
&
&
type
<
EbtGuardSamplerEnd
;
}
inline
bool
IsIntegerSampler
(
TBasicType
type
)
{
switch
(
type
)
{
case
EbtISampler2D
:
case
EbtISampler3D
:
case
EbtISamplerCube
:
case
EbtISampler2DArray
:
case
EbtUSampler2D
:
case
EbtUSampler3D
:
case
EbtUSamplerCube
:
case
EbtUSampler2DArray
:
return
true
;
case
EbtSampler2D
:
case
EbtSampler3D
:
case
EbtSamplerCube
:
case
EbtSamplerExternalOES
:
case
EbtSampler2DRect
:
case
EbtSampler2DArray
:
case
EbtSampler2DShadow
:
case
EbtSamplerCubeShadow
:
case
EbtSampler2DArrayShadow
:
return
false
;
default
:
assert
(
!
IsSampler
(
type
)
)
;
}
return
false
;
}
inline
bool
IsSampler2D
(
TBasicType
type
)
{
switch
(
type
)
{
case
EbtSampler2D
:
case
EbtISampler2D
:
case
EbtUSampler2D
:
case
EbtSampler2DArray
:
case
EbtISampler2DArray
:
case
EbtUSampler2DArray
:
case
EbtSampler2DRect
:
case
EbtSamplerExternalOES
:
case
EbtSampler2DShadow
:
case
EbtSampler2DArrayShadow
:
return
true
;
case
EbtSampler3D
:
case
EbtISampler3D
:
case
EbtUSampler3D
:
case
EbtISamplerCube
:
case
EbtUSamplerCube
:
case
EbtSamplerCube
:
case
EbtSamplerCubeShadow
:
return
false
;
default
:
assert
(
!
IsSampler
(
type
)
)
;
}
return
false
;
}
inline
bool
IsSamplerCube
(
TBasicType
type
)
{
switch
(
type
)
{
case
EbtSamplerCube
:
case
EbtISamplerCube
:
case
EbtUSamplerCube
:
case
EbtSamplerCubeShadow
:
return
true
;
case
EbtSampler2D
:
case
EbtSampler3D
:
case
EbtSamplerExternalOES
:
case
EbtSampler2DRect
:
case
EbtSampler2DArray
:
case
EbtISampler2D
:
case
EbtISampler3D
:
case
EbtISampler2DArray
:
case
EbtUSampler2D
:
case
EbtUSampler3D
:
case
EbtUSampler2DArray
:
case
EbtSampler2DShadow
:
case
EbtSampler2DArrayShadow
:
return
false
;
default
:
assert
(
!
IsSampler
(
type
)
)
;
}
return
false
;
}
inline
bool
IsSampler3D
(
TBasicType
type
)
{
switch
(
type
)
{
case
EbtSampler3D
:
case
EbtISampler3D
:
case
EbtUSampler3D
:
return
true
;
case
EbtSampler2D
:
case
EbtSamplerCube
:
case
EbtSamplerExternalOES
:
case
EbtSampler2DRect
:
case
EbtSampler2DArray
:
case
EbtISampler2D
:
case
EbtISamplerCube
:
case
EbtISampler2DArray
:
case
EbtUSampler2D
:
case
EbtUSamplerCube
:
case
EbtUSampler2DArray
:
case
EbtSampler2DShadow
:
case
EbtSamplerCubeShadow
:
case
EbtSampler2DArrayShadow
:
return
false
;
default
:
assert
(
!
IsSampler
(
type
)
)
;
}
return
false
;
}
inline
bool
IsSamplerArray
(
TBasicType
type
)
{
switch
(
type
)
{
case
EbtSampler2DArray
:
case
EbtISampler2DArray
:
case
EbtUSampler2DArray
:
case
EbtSampler2DArrayShadow
:
return
true
;
case
EbtSampler2D
:
case
EbtISampler2D
:
case
EbtUSampler2D
:
case
EbtSampler2DRect
:
case
EbtSamplerExternalOES
:
case
EbtSampler3D
:
case
EbtISampler3D
:
case
EbtUSampler3D
:
case
EbtISamplerCube
:
case
EbtUSamplerCube
:
case
EbtSamplerCube
:
case
EbtSampler2DShadow
:
case
EbtSamplerCubeShadow
:
return
false
;
default
:
assert
(
!
IsSampler
(
type
)
)
;
}
return
false
;
}
inline
bool
IsShadowSampler
(
TBasicType
type
)
{
switch
(
type
)
{
case
EbtSampler2DShadow
:
case
EbtSamplerCubeShadow
:
case
EbtSampler2DArrayShadow
:
return
true
;
case
EbtISampler2D
:
case
EbtISampler3D
:
case
EbtISamplerCube
:
case
EbtISampler2DArray
:
case
EbtUSampler2D
:
case
EbtUSampler3D
:
case
EbtUSamplerCube
:
case
EbtUSampler2DArray
:
case
EbtSampler2D
:
case
EbtSampler3D
:
case
EbtSamplerCube
:
case
EbtSamplerExternalOES
:
case
EbtSampler2DRect
:
case
EbtSampler2DArray
:
return
false
;
default
:
assert
(
!
IsSampler
(
type
)
)
;
}
return
false
;
}
inline
bool
IsInteger
(
TBasicType
type
)
{
return
type
=
=
EbtInt
|
|
type
=
=
EbtUInt
;
}
inline
bool
SupportsPrecision
(
TBasicType
type
)
{
return
type
=
=
EbtFloat
|
|
type
=
=
EbtInt
|
|
type
=
=
EbtUInt
|
|
IsSampler
(
type
)
;
}
enum
TQualifier
{
EvqTemporary
EvqGlobal
EvqConst
EvqAttribute
EvqVaryingIn
EvqVaryingOut
EvqUniform
EvqVertexIn
EvqFragmentOut
EvqVertexOut
EvqFragmentIn
EvqIn
EvqOut
EvqInOut
EvqConstReadOnly
EvqInstanceID
EvqVertexID
EvqPosition
EvqPointSize
EvqFragCoord
EvqFrontFacing
EvqPointCoord
EvqFragColor
EvqFragData
EvqFragDepth
EvqFragDepthEXT
EvqSecondaryFragColorEXT
EvqSecondaryFragDataEXT
EvqLastFragColor
EvqLastFragData
EvqSmooth
EvqFlat
EvqCentroid
EvqSmoothOut
EvqFlatOut
EvqCentroidOut
EvqSmoothIn
EvqFlatIn
EvqCentroidIn
EvqComputeIn
EvqNumWorkGroups
EvqWorkGroupSize
EvqWorkGroupID
EvqLocalInvocationID
EvqGlobalInvocationID
EvqLocalInvocationIndex
EvqLast
}
;
inline
bool
IsQualifierUnspecified
(
TQualifier
qualifier
)
{
return
(
qualifier
=
=
EvqTemporary
|
|
qualifier
=
=
EvqGlobal
)
;
}
enum
TLayoutMatrixPacking
{
EmpUnspecified
EmpRowMajor
EmpColumnMajor
}
;
enum
TLayoutBlockStorage
{
EbsUnspecified
EbsShared
EbsPacked
EbsStd140
}
;
struct
TLayoutQualifier
{
int
location
;
unsigned
int
locationsSpecified
;
TLayoutMatrixPacking
matrixPacking
;
TLayoutBlockStorage
blockStorage
;
sh
:
:
WorkGroupSize
localSize
;
static
TLayoutQualifier
create
(
)
{
TLayoutQualifier
layoutQualifier
;
layoutQualifier
.
location
=
-
1
;
layoutQualifier
.
locationsSpecified
=
0
;
layoutQualifier
.
matrixPacking
=
EmpUnspecified
;
layoutQualifier
.
blockStorage
=
EbsUnspecified
;
layoutQualifier
.
localSize
.
fill
(
-
1
)
;
return
layoutQualifier
;
}
bool
isEmpty
(
)
const
{
return
location
=
=
-
1
&
&
matrixPacking
=
=
EmpUnspecified
&
&
blockStorage
=
=
EbsUnspecified
&
&
!
localSize
.
isAnyValueSet
(
)
;
}
bool
isCombinationValid
(
)
const
{
bool
workSizeSpecified
=
localSize
.
isAnyValueSet
(
)
;
bool
otherLayoutQualifiersSpecified
=
(
location
!
=
-
1
|
|
matrixPacking
!
=
EmpUnspecified
|
|
blockStorage
!
=
EbsUnspecified
)
;
return
!
(
workSizeSpecified
&
&
otherLayoutQualifiersSpecified
)
;
}
bool
isLocalSizeEqual
(
const
sh
:
:
WorkGroupSize
&
localSizeIn
)
const
{
return
localSize
.
isWorkGroupSizeMatching
(
localSizeIn
)
;
}
}
;
inline
const
char
*
getWorkGroupSizeString
(
size_t
dimension
)
{
switch
(
dimension
)
{
case
0u
:
return
"
local_size_x
"
;
case
1u
:
return
"
local_size_y
"
;
case
2u
:
return
"
local_size_z
"
;
default
:
UNREACHABLE
(
)
;
return
"
dimension
out
of
bounds
"
;
}
}
inline
const
char
*
getQualifierString
(
TQualifier
q
)
{
switch
(
q
)
{
case
EvqTemporary
:
return
"
Temporary
"
;
case
EvqGlobal
:
return
"
Global
"
;
case
EvqConst
:
return
"
const
"
;
case
EvqAttribute
:
return
"
attribute
"
;
case
EvqVaryingIn
:
return
"
varying
"
;
case
EvqVaryingOut
:
return
"
varying
"
;
case
EvqUniform
:
return
"
uniform
"
;
case
EvqVertexIn
:
return
"
in
"
;
case
EvqFragmentOut
:
return
"
out
"
;
case
EvqVertexOut
:
return
"
out
"
;
case
EvqFragmentIn
:
return
"
in
"
;
case
EvqIn
:
return
"
in
"
;
case
EvqOut
:
return
"
out
"
;
case
EvqInOut
:
return
"
inout
"
;
case
EvqConstReadOnly
:
return
"
const
"
;
case
EvqInstanceID
:
return
"
InstanceID
"
;
case
EvqVertexID
:
return
"
VertexID
"
;
case
EvqPosition
:
return
"
Position
"
;
case
EvqPointSize
:
return
"
PointSize
"
;
case
EvqFragCoord
:
return
"
FragCoord
"
;
case
EvqFrontFacing
:
return
"
FrontFacing
"
;
case
EvqPointCoord
:
return
"
PointCoord
"
;
case
EvqFragColor
:
return
"
FragColor
"
;
case
EvqFragData
:
return
"
FragData
"
;
case
EvqFragDepthEXT
:
return
"
FragDepth
"
;
case
EvqFragDepth
:
return
"
FragDepth
"
;
case
EvqSecondaryFragColorEXT
:
return
"
SecondaryFragColorEXT
"
;
case
EvqSecondaryFragDataEXT
:
return
"
SecondaryFragDataEXT
"
;
case
EvqLastFragColor
:
return
"
LastFragColor
"
;
case
EvqLastFragData
:
return
"
LastFragData
"
;
case
EvqSmoothOut
:
return
"
smooth
out
"
;
case
EvqCentroidOut
:
return
"
smooth
centroid
out
"
;
case
EvqFlatOut
:
return
"
flat
out
"
;
case
EvqSmoothIn
:
return
"
smooth
in
"
;
case
EvqFlatIn
:
return
"
flat
in
"
;
case
EvqCentroidIn
:
return
"
smooth
centroid
in
"
;
case
EvqCentroid
:
return
"
centroid
"
;
case
EvqFlat
:
return
"
flat
"
;
case
EvqSmooth
:
return
"
smooth
"
;
case
EvqComputeIn
:
return
"
in
"
;
case
EvqNumWorkGroups
:
return
"
NumWorkGroups
"
;
case
EvqWorkGroupSize
:
return
"
WorkGroupSize
"
;
case
EvqWorkGroupID
:
return
"
WorkGroupID
"
;
case
EvqLocalInvocationID
:
return
"
LocalInvocationID
"
;
case
EvqGlobalInvocationID
:
return
"
GlobalInvocationID
"
;
case
EvqLocalInvocationIndex
:
return
"
LocalInvocationIndex
"
;
default
:
UNREACHABLE
(
)
;
return
"
unknown
qualifier
"
;
}
}
inline
const
char
*
getMatrixPackingString
(
TLayoutMatrixPacking
mpq
)
{
switch
(
mpq
)
{
case
EmpUnspecified
:
return
"
mp_unspecified
"
;
case
EmpRowMajor
:
return
"
row_major
"
;
case
EmpColumnMajor
:
return
"
column_major
"
;
default
:
UNREACHABLE
(
)
;
return
"
unknown
matrix
packing
"
;
}
}
inline
const
char
*
getBlockStorageString
(
TLayoutBlockStorage
bsq
)
{
switch
(
bsq
)
{
case
EbsUnspecified
:
return
"
bs_unspecified
"
;
case
EbsShared
:
return
"
shared
"
;
case
EbsPacked
:
return
"
packed
"
;
case
EbsStd140
:
return
"
std140
"
;
default
:
UNREACHABLE
(
)
;
return
"
unknown
block
storage
"
;
}
}
inline
const
char
*
getInterpolationString
(
TQualifier
q
)
{
switch
(
q
)
{
case
EvqSmoothOut
:
return
"
smooth
"
;
break
;
case
EvqCentroidOut
:
return
"
smooth
centroid
"
;
break
;
case
EvqFlatOut
:
return
"
flat
"
;
break
;
case
EvqSmoothIn
:
return
"
smooth
"
;
break
;
case
EvqCentroidIn
:
return
"
smooth
centroid
"
;
break
;
case
EvqFlatIn
:
return
"
flat
"
;
break
;
default
:
UNREACHABLE
(
)
;
return
"
unknown
interpolation
"
;
}
}
#
endif
