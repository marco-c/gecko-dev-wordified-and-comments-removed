#
include
"
compiler
/
translator
/
SimplifyLoopConditions
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
#
include
"
compiler
/
translator
/
IntermNodePatternMatcher
.
h
"
namespace
{
TIntermConstantUnion
*
CreateBoolConstantNode
(
bool
value
)
{
TConstantUnion
*
u
=
new
TConstantUnion
;
u
-
>
setBConst
(
value
)
;
TIntermConstantUnion
*
node
=
new
TIntermConstantUnion
(
u
TType
(
EbtBool
EbpUndefined
EvqConst
1
)
)
;
return
node
;
}
class
SimplifyLoopConditionsTraverser
:
public
TLValueTrackingTraverser
{
public
:
SimplifyLoopConditionsTraverser
(
unsigned
int
conditionsToSimplifyMask
const
TSymbolTable
&
symbolTable
int
shaderVersion
)
;
void
traverseLoop
(
TIntermLoop
*
node
)
override
;
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
;
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
;
bool
visitSelection
(
Visit
visit
TIntermSelection
*
node
)
override
;
void
nextIteration
(
)
;
bool
foundLoopToChange
(
)
const
{
return
mFoundLoopToChange
;
}
protected
:
bool
mFoundLoopToChange
;
bool
mInsideLoopConditionOrExpression
;
IntermNodePatternMatcher
mConditionsToSimplify
;
}
;
SimplifyLoopConditionsTraverser
:
:
SimplifyLoopConditionsTraverser
(
unsigned
int
conditionsToSimplifyMask
const
TSymbolTable
&
symbolTable
int
shaderVersion
)
:
TLValueTrackingTraverser
(
true
false
false
symbolTable
shaderVersion
)
mFoundLoopToChange
(
false
)
mInsideLoopConditionOrExpression
(
false
)
mConditionsToSimplify
(
conditionsToSimplifyMask
)
{
}
void
SimplifyLoopConditionsTraverser
:
:
nextIteration
(
)
{
mFoundLoopToChange
=
false
;
mInsideLoopConditionOrExpression
=
false
;
nextTemporaryIndex
(
)
;
}
bool
SimplifyLoopConditionsTraverser
:
:
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
{
if
(
mFoundLoopToChange
)
return
false
;
if
(
!
mInsideLoopConditionOrExpression
)
return
false
;
mFoundLoopToChange
=
mConditionsToSimplify
.
match
(
node
getParentNode
(
)
isLValueRequiredHere
(
)
)
;
return
!
mFoundLoopToChange
;
}
bool
SimplifyLoopConditionsTraverser
:
:
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
{
if
(
mFoundLoopToChange
)
return
false
;
if
(
!
mInsideLoopConditionOrExpression
)
return
(
node
-
>
getOp
(
)
=
=
EOpSequence
|
|
node
-
>
getOp
(
)
=
=
EOpFunction
)
;
mFoundLoopToChange
=
mConditionsToSimplify
.
match
(
node
getParentNode
(
)
)
;
return
!
mFoundLoopToChange
;
}
bool
SimplifyLoopConditionsTraverser
:
:
visitSelection
(
Visit
visit
TIntermSelection
*
node
)
{
if
(
mFoundLoopToChange
)
return
false
;
if
(
!
mInsideLoopConditionOrExpression
)
return
!
node
-
>
usesTernaryOperator
(
)
;
mFoundLoopToChange
=
mConditionsToSimplify
.
match
(
node
)
;
return
!
mFoundLoopToChange
;
}
void
SimplifyLoopConditionsTraverser
:
:
traverseLoop
(
TIntermLoop
*
node
)
{
if
(
mFoundLoopToChange
)
return
;
incrementDepth
(
node
)
;
mInsideLoopConditionOrExpression
=
true
;
TLoopType
loopType
=
node
-
>
getType
(
)
;
if
(
node
-
>
getCondition
(
)
)
{
node
-
>
getCondition
(
)
-
>
traverse
(
this
)
;
if
(
mFoundLoopToChange
)
{
if
(
loopType
=
=
ELoopWhile
)
{
TIntermSequence
tempInitSeq
;
tempInitSeq
.
push_back
(
createTempInitDeclaration
(
node
-
>
getCondition
(
)
-
>
deepCopy
(
)
)
)
;
insertStatementsInParentBlock
(
tempInitSeq
)
;
TIntermAggregate
*
newBody
=
new
TIntermAggregate
(
EOpSequence
)
;
if
(
node
-
>
getBody
(
)
)
{
ASSERT
(
node
-
>
getBody
(
)
-
>
getOp
(
)
=
=
EOpSequence
)
;
newBody
-
>
getSequence
(
)
-
>
push_back
(
node
-
>
getBody
(
)
)
;
}
newBody
-
>
getSequence
(
)
-
>
push_back
(
createTempAssignment
(
node
-
>
getCondition
(
)
-
>
deepCopy
(
)
)
)
;
node
-
>
setBody
(
newBody
)
;
node
-
>
setCondition
(
createTempSymbol
(
node
-
>
getCondition
(
)
-
>
getType
(
)
)
)
;
}
else
if
(
loopType
=
=
ELoopDoWhile
)
{
TIntermSequence
tempInitSeq
;
tempInitSeq
.
push_back
(
createTempInitDeclaration
(
CreateBoolConstantNode
(
true
)
)
)
;
insertStatementsInParentBlock
(
tempInitSeq
)
;
TIntermAggregate
*
newBody
=
new
TIntermAggregate
(
EOpSequence
)
;
if
(
node
-
>
getBody
(
)
)
{
ASSERT
(
node
-
>
getBody
(
)
-
>
getOp
(
)
=
=
EOpSequence
)
;
newBody
-
>
getSequence
(
)
-
>
push_back
(
node
-
>
getBody
(
)
)
;
}
newBody
-
>
getSequence
(
)
-
>
push_back
(
createTempAssignment
(
node
-
>
getCondition
(
)
-
>
deepCopy
(
)
)
)
;
node
-
>
setBody
(
newBody
)
;
node
-
>
setCondition
(
createTempSymbol
(
node
-
>
getCondition
(
)
-
>
getType
(
)
)
)
;
}
else
if
(
loopType
=
=
ELoopFor
)
{
TIntermAggregate
*
loopScope
=
new
TIntermAggregate
(
EOpSequence
)
;
if
(
node
-
>
getInit
(
)
)
{
loopScope
-
>
getSequence
(
)
-
>
push_back
(
node
-
>
getInit
(
)
)
;
}
loopScope
-
>
getSequence
(
)
-
>
push_back
(
createTempInitDeclaration
(
node
-
>
getCondition
(
)
-
>
deepCopy
(
)
)
)
;
TIntermAggregate
*
whileLoopBody
=
new
TIntermAggregate
(
EOpSequence
)
;
if
(
node
-
>
getBody
(
)
)
{
whileLoopBody
-
>
getSequence
(
)
-
>
push_back
(
node
-
>
getBody
(
)
)
;
}
whileLoopBody
-
>
getSequence
(
)
-
>
push_back
(
node
-
>
getExpression
(
)
)
;
whileLoopBody
-
>
getSequence
(
)
-
>
push_back
(
createTempAssignment
(
node
-
>
getCondition
(
)
-
>
deepCopy
(
)
)
)
;
TIntermLoop
*
whileLoop
=
new
TIntermLoop
(
ELoopWhile
nullptr
createTempSymbol
(
node
-
>
getCondition
(
)
-
>
getType
(
)
)
nullptr
whileLoopBody
)
;
loopScope
-
>
getSequence
(
)
-
>
push_back
(
whileLoop
)
;
queueReplacementWithParent
(
getAncestorNode
(
1
)
node
loopScope
OriginalNode
:
:
IS_DROPPED
)
;
}
}
}
if
(
!
mFoundLoopToChange
&
&
node
-
>
getExpression
(
)
)
{
node
-
>
getExpression
(
)
-
>
traverse
(
this
)
;
if
(
mFoundLoopToChange
)
{
ASSERT
(
loopType
=
=
ELoopFor
)
;
TIntermTyped
*
loopExpression
=
node
-
>
getExpression
(
)
;
node
-
>
setExpression
(
nullptr
)
;
TIntermAggregate
*
oldBody
=
node
-
>
getBody
(
)
;
node
-
>
setBody
(
new
TIntermAggregate
(
EOpSequence
)
)
;
if
(
oldBody
!
=
nullptr
)
{
node
-
>
getBody
(
)
-
>
getSequence
(
)
-
>
push_back
(
oldBody
)
;
}
node
-
>
getBody
(
)
-
>
getSequence
(
)
-
>
push_back
(
loopExpression
)
;
}
}
mInsideLoopConditionOrExpression
=
false
;
if
(
!
mFoundLoopToChange
&
&
node
-
>
getBody
(
)
)
node
-
>
getBody
(
)
-
>
traverse
(
this
)
;
decrementDepth
(
)
;
}
}
void
SimplifyLoopConditions
(
TIntermNode
*
root
unsigned
int
conditionsToSimplifyMask
unsigned
int
*
temporaryIndex
const
TSymbolTable
&
symbolTable
int
shaderVersion
)
{
SimplifyLoopConditionsTraverser
traverser
(
conditionsToSimplifyMask
symbolTable
shaderVersion
)
;
ASSERT
(
temporaryIndex
!
=
nullptr
)
;
traverser
.
useTemporaryIndex
(
temporaryIndex
)
;
do
{
traverser
.
nextIteration
(
)
;
root
-
>
traverse
(
&
traverser
)
;
if
(
traverser
.
foundLoopToChange
(
)
)
traverser
.
updateTree
(
)
;
}
while
(
traverser
.
foundLoopToChange
(
)
)
;
}
