#
include
"
compiler
/
translator
/
PoolAlloc
.
h
"
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
<
assert
.
h
>
#
include
"
common
/
angleutils
.
h
"
#
include
"
common
/
debug
.
h
"
#
include
"
common
/
platform
.
h
"
#
include
"
common
/
tls
.
h
"
#
include
"
compiler
/
translator
/
InitializeGlobals
.
h
"
TLSIndex
PoolIndex
=
TLS_INVALID_INDEX
;
bool
InitializePoolIndex
(
)
{
assert
(
PoolIndex
=
=
TLS_INVALID_INDEX
)
;
PoolIndex
=
CreateTLSIndex
(
)
;
return
PoolIndex
!
=
TLS_INVALID_INDEX
;
}
void
FreePoolIndex
(
)
{
assert
(
PoolIndex
!
=
TLS_INVALID_INDEX
)
;
DestroyTLSIndex
(
PoolIndex
)
;
PoolIndex
=
TLS_INVALID_INDEX
;
}
TPoolAllocator
*
GetGlobalPoolAllocator
(
)
{
assert
(
PoolIndex
!
=
TLS_INVALID_INDEX
)
;
return
static_cast
<
TPoolAllocator
*
>
(
GetTLSValue
(
PoolIndex
)
)
;
}
void
SetGlobalPoolAllocator
(
TPoolAllocator
*
poolAllocator
)
{
assert
(
PoolIndex
!
=
TLS_INVALID_INDEX
)
;
SetTLSValue
(
PoolIndex
poolAllocator
)
;
}
TPoolAllocator
:
:
TPoolAllocator
(
int
growthIncrement
int
allocationAlignment
)
:
alignment
(
allocationAlignment
)
#
if
!
defined
(
ANGLE_TRANSLATOR_DISABLE_POOL_ALLOC
)
pageSize
(
growthIncrement
)
freeList
(
0
)
inUseList
(
0
)
numCalls
(
0
)
totalBytes
(
0
)
#
endif
mLocked
(
false
)
{
size_t
minAlign
=
sizeof
(
void
*
)
;
alignment
&
=
~
(
minAlign
-
1
)
;
if
(
alignment
<
minAlign
)
alignment
=
minAlign
;
size_t
a
=
1
;
while
(
a
<
alignment
)
a
<
<
=
1
;
alignment
=
a
;
alignmentMask
=
a
-
1
;
#
if
!
defined
(
ANGLE_TRANSLATOR_DISABLE_POOL_ALLOC
)
if
(
pageSize
<
4
*
1024
)
pageSize
=
4
*
1024
;
currentPageOffset
=
pageSize
;
headerSkip
=
minAlign
;
if
(
headerSkip
<
sizeof
(
tHeader
)
)
{
headerSkip
=
(
sizeof
(
tHeader
)
+
alignmentMask
)
&
~
alignmentMask
;
}
#
else
mStack
.
push_back
(
{
}
)
;
#
endif
}
TPoolAllocator
:
:
~
TPoolAllocator
(
)
{
#
if
!
defined
(
ANGLE_TRANSLATOR_DISABLE_POOL_ALLOC
)
while
(
inUseList
)
{
tHeader
*
next
=
inUseList
-
>
nextPage
;
inUseList
-
>
~
tHeader
(
)
;
delete
[
]
reinterpret_cast
<
char
*
>
(
inUseList
)
;
inUseList
=
next
;
}
while
(
freeList
)
{
tHeader
*
next
=
freeList
-
>
nextPage
;
delete
[
]
reinterpret_cast
<
char
*
>
(
freeList
)
;
freeList
=
next
;
}
#
else
for
(
auto
&
allocs
:
mStack
)
{
for
(
auto
alloc
:
allocs
)
{
free
(
alloc
)
;
}
}
mStack
.
clear
(
)
;
#
endif
}
const
unsigned
char
TAllocation
:
:
guardBlockBeginVal
=
0xfb
;
const
unsigned
char
TAllocation
:
:
guardBlockEndVal
=
0xfe
;
const
unsigned
char
TAllocation
:
:
userDataFill
=
0xcd
;
#
ifdef
GUARD_BLOCKS
const
size_t
TAllocation
:
:
guardBlockSize
=
16
;
#
else
const
size_t
TAllocation
:
:
guardBlockSize
=
0
;
#
endif
void
TAllocation
:
:
checkGuardBlock
(
unsigned
char
*
blockMem
unsigned
char
val
const
char
*
locText
)
const
{
#
ifdef
GUARD_BLOCKS
for
(
size_t
x
=
0
;
x
<
guardBlockSize
;
x
+
+
)
{
if
(
blockMem
[
x
]
!
=
val
)
{
char
assertMsg
[
80
]
;
#
if
defined
(
_MSC_VER
)
snprintf
(
assertMsg
sizeof
(
assertMsg
)
"
PoolAlloc
:
Damage
%
s
%
Iu
byte
allocation
at
0x
%
p
\
n
"
locText
size
data
(
)
)
;
#
else
snprintf
(
assertMsg
sizeof
(
assertMsg
)
"
PoolAlloc
:
Damage
%
s
%
zu
byte
allocation
at
0x
%
p
\
n
"
locText
size
data
(
)
)
;
#
endif
assert
(
0
&
&
"
PoolAlloc
:
Damage
in
guard
block
"
)
;
}
}
#
endif
}
void
TPoolAllocator
:
:
push
(
)
{
#
if
!
defined
(
ANGLE_TRANSLATOR_DISABLE_POOL_ALLOC
)
tAllocState
state
=
{
currentPageOffset
inUseList
}
;
mStack
.
push_back
(
state
)
;
currentPageOffset
=
pageSize
;
#
else
mStack
.
push_back
(
{
}
)
;
#
endif
}
void
TPoolAllocator
:
:
pop
(
)
{
if
(
mStack
.
size
(
)
<
1
)
return
;
#
if
!
defined
(
ANGLE_TRANSLATOR_DISABLE_POOL_ALLOC
)
tHeader
*
page
=
mStack
.
back
(
)
.
page
;
currentPageOffset
=
mStack
.
back
(
)
.
offset
;
while
(
inUseList
!
=
page
)
{
inUseList
-
>
~
tHeader
(
)
;
tHeader
*
nextInUse
=
inUseList
-
>
nextPage
;
if
(
inUseList
-
>
pageCount
>
1
)
delete
[
]
reinterpret_cast
<
char
*
>
(
inUseList
)
;
else
{
inUseList
-
>
nextPage
=
freeList
;
freeList
=
inUseList
;
}
inUseList
=
nextInUse
;
}
mStack
.
pop_back
(
)
;
#
else
for
(
auto
&
alloc
:
mStack
.
back
(
)
)
{
free
(
alloc
)
;
}
mStack
.
pop_back
(
)
;
#
endif
}
void
TPoolAllocator
:
:
popAll
(
)
{
while
(
mStack
.
size
(
)
>
0
)
pop
(
)
;
}
void
*
TPoolAllocator
:
:
allocate
(
size_t
numBytes
)
{
ASSERT
(
!
mLocked
)
;
#
if
!
defined
(
ANGLE_TRANSLATOR_DISABLE_POOL_ALLOC
)
+
+
numCalls
;
totalBytes
+
=
numBytes
;
size_t
allocationSize
=
TAllocation
:
:
allocationSize
(
numBytes
)
;
if
(
allocationSize
<
numBytes
)
return
0
;
if
(
allocationSize
<
=
pageSize
-
currentPageOffset
)
{
unsigned
char
*
memory
=
reinterpret_cast
<
unsigned
char
*
>
(
inUseList
)
+
currentPageOffset
;
currentPageOffset
+
=
allocationSize
;
currentPageOffset
=
(
currentPageOffset
+
alignmentMask
)
&
~
alignmentMask
;
return
initializeAllocation
(
inUseList
memory
numBytes
)
;
}
if
(
allocationSize
>
pageSize
-
headerSkip
)
{
size_t
numBytesToAlloc
=
allocationSize
+
headerSkip
;
if
(
numBytesToAlloc
<
allocationSize
)
return
0
;
tHeader
*
memory
=
reinterpret_cast
<
tHeader
*
>
(
:
:
new
char
[
numBytesToAlloc
]
)
;
if
(
memory
=
=
0
)
return
0
;
new
(
memory
)
tHeader
(
inUseList
(
numBytesToAlloc
+
pageSize
-
1
)
/
pageSize
)
;
inUseList
=
memory
;
currentPageOffset
=
pageSize
;
return
reinterpret_cast
<
void
*
>
(
reinterpret_cast
<
uintptr_t
>
(
memory
)
+
headerSkip
)
;
}
tHeader
*
memory
;
if
(
freeList
)
{
memory
=
freeList
;
freeList
=
freeList
-
>
nextPage
;
}
else
{
memory
=
reinterpret_cast
<
tHeader
*
>
(
:
:
new
char
[
pageSize
]
)
;
if
(
memory
=
=
0
)
return
0
;
}
new
(
memory
)
tHeader
(
inUseList
1
)
;
inUseList
=
memory
;
unsigned
char
*
ret
=
reinterpret_cast
<
unsigned
char
*
>
(
inUseList
)
+
headerSkip
;
currentPageOffset
=
(
headerSkip
+
allocationSize
+
alignmentMask
)
&
~
alignmentMask
;
return
initializeAllocation
(
inUseList
ret
numBytes
)
;
#
else
void
*
alloc
=
malloc
(
numBytes
+
alignmentMask
)
;
mStack
.
back
(
)
.
push_back
(
alloc
)
;
intptr_t
intAlloc
=
reinterpret_cast
<
intptr_t
>
(
alloc
)
;
intAlloc
=
(
intAlloc
+
alignmentMask
)
&
~
alignmentMask
;
return
reinterpret_cast
<
void
*
>
(
intAlloc
)
;
#
endif
}
void
TPoolAllocator
:
:
lock
(
)
{
ASSERT
(
!
mLocked
)
;
mLocked
=
true
;
}
void
TPoolAllocator
:
:
unlock
(
)
{
ASSERT
(
mLocked
)
;
mLocked
=
false
;
}
void
TAllocation
:
:
checkAllocList
(
)
const
{
for
(
const
TAllocation
*
alloc
=
this
;
alloc
!
=
0
;
alloc
=
alloc
-
>
prevAlloc
)
alloc
-
>
check
(
)
;
}
