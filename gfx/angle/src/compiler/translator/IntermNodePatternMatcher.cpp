#
include
"
compiler
/
translator
/
IntermNodePatternMatcher
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
namespace
{
bool
IsNodeBlock
(
TIntermNode
*
node
)
{
ASSERT
(
node
!
=
nullptr
)
;
return
(
node
-
>
getAsAggregate
(
)
&
&
node
-
>
getAsAggregate
(
)
-
>
getOp
(
)
=
=
EOpSequence
)
;
}
}
IntermNodePatternMatcher
:
:
IntermNodePatternMatcher
(
const
unsigned
int
mask
)
:
mMask
(
mask
)
{
}
bool
IntermNodePatternMatcher
:
:
IsDynamicIndexingOfVectorOrMatrix
(
TIntermBinary
*
node
)
{
return
node
-
>
getOp
(
)
=
=
EOpIndexIndirect
&
&
!
node
-
>
getLeft
(
)
-
>
isArray
(
)
&
&
node
-
>
getLeft
(
)
-
>
getBasicType
(
)
!
=
EbtStruct
;
}
bool
IntermNodePatternMatcher
:
:
matchInternal
(
TIntermBinary
*
node
TIntermNode
*
parentNode
)
{
if
(
(
mMask
&
kExpressionReturningArray
)
!
=
0
)
{
if
(
node
-
>
isArray
(
)
&
&
node
-
>
getOp
(
)
=
=
EOpAssign
&
&
parentNode
!
=
nullptr
&
&
!
IsNodeBlock
(
parentNode
)
)
{
return
true
;
}
}
if
(
(
mMask
&
kUnfoldedShortCircuitExpression
)
!
=
0
)
{
if
(
node
-
>
getRight
(
)
-
>
hasSideEffects
(
)
&
&
(
node
-
>
getOp
(
)
=
=
EOpLogicalOr
|
|
node
-
>
getOp
(
)
=
=
EOpLogicalAnd
)
)
{
return
true
;
}
}
return
false
;
}
bool
IntermNodePatternMatcher
:
:
match
(
TIntermBinary
*
node
TIntermNode
*
parentNode
)
{
ASSERT
(
(
mMask
&
kDynamicIndexingOfVectorOrMatrixInLValue
)
=
=
0
)
;
return
matchInternal
(
node
parentNode
)
;
}
bool
IntermNodePatternMatcher
:
:
match
(
TIntermBinary
*
node
TIntermNode
*
parentNode
bool
isLValueRequiredHere
)
{
if
(
matchInternal
(
node
parentNode
)
)
{
return
true
;
}
if
(
(
mMask
&
kDynamicIndexingOfVectorOrMatrixInLValue
)
!
=
0
)
{
if
(
isLValueRequiredHere
&
&
IsDynamicIndexingOfVectorOrMatrix
(
node
)
)
{
return
true
;
}
}
return
false
;
}
bool
IntermNodePatternMatcher
:
:
match
(
TIntermAggregate
*
node
TIntermNode
*
parentNode
)
{
if
(
(
mMask
&
kExpressionReturningArray
)
!
=
0
)
{
if
(
parentNode
!
=
nullptr
)
{
TIntermBinary
*
parentBinary
=
parentNode
-
>
getAsBinaryNode
(
)
;
bool
parentIsAssignment
=
(
parentBinary
!
=
nullptr
&
&
(
parentBinary
-
>
getOp
(
)
=
=
EOpAssign
|
|
parentBinary
-
>
getOp
(
)
=
=
EOpInitialize
)
)
;
if
(
node
-
>
getType
(
)
.
isArray
(
)
&
&
!
parentIsAssignment
&
&
(
node
-
>
isConstructor
(
)
|
|
node
-
>
getOp
(
)
=
=
EOpFunctionCall
)
&
&
!
IsNodeBlock
(
parentNode
)
)
{
return
true
;
}
}
}
return
false
;
}
bool
IntermNodePatternMatcher
:
:
match
(
TIntermSelection
*
node
)
{
if
(
(
mMask
&
kUnfoldedShortCircuitExpression
)
!
=
0
)
{
if
(
node
-
>
usesTernaryOperator
(
)
)
{
return
true
;
}
}
return
false
;
}
