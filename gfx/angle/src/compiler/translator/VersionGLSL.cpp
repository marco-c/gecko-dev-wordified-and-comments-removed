#
include
"
compiler
/
translator
/
VersionGLSL
.
h
"
#
include
"
angle_gl
.
h
"
namespace
sh
{
int
ShaderOutputTypeToGLSLVersion
(
ShShaderOutput
output
)
{
switch
(
output
)
{
case
SH_GLSL_130_OUTPUT
:
return
GLSL_VERSION_130
;
case
SH_GLSL_140_OUTPUT
:
return
GLSL_VERSION_140
;
case
SH_GLSL_150_CORE_OUTPUT
:
return
GLSL_VERSION_150
;
case
SH_GLSL_330_CORE_OUTPUT
:
return
GLSL_VERSION_330
;
case
SH_GLSL_400_CORE_OUTPUT
:
return
GLSL_VERSION_400
;
case
SH_GLSL_410_CORE_OUTPUT
:
return
GLSL_VERSION_410
;
case
SH_GLSL_420_CORE_OUTPUT
:
return
GLSL_VERSION_420
;
case
SH_GLSL_430_CORE_OUTPUT
:
return
GLSL_VERSION_430
;
case
SH_GLSL_440_CORE_OUTPUT
:
return
GLSL_VERSION_440
;
case
SH_GLSL_450_CORE_OUTPUT
:
return
GLSL_VERSION_450
;
case
SH_GLSL_COMPATIBILITY_OUTPUT
:
return
GLSL_VERSION_110
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
TVersionGLSL
:
:
TVersionGLSL
(
sh
:
:
GLenum
type
const
TPragma
&
pragma
ShShaderOutput
output
)
:
TIntermTraverser
(
true
false
false
)
{
mVersion
=
ShaderOutputTypeToGLSLVersion
(
output
)
;
if
(
pragma
.
stdgl
.
invariantAll
)
{
ensureVersionIsAtLeast
(
GLSL_VERSION_120
)
;
}
if
(
type
=
=
GL_COMPUTE_SHADER
)
{
ensureVersionIsAtLeast
(
GLSL_VERSION_430
)
;
}
}
void
TVersionGLSL
:
:
visitSymbol
(
TIntermSymbol
*
node
)
{
if
(
node
-
>
getSymbol
(
)
=
=
"
gl_PointCoord
"
)
{
ensureVersionIsAtLeast
(
GLSL_VERSION_120
)
;
}
}
bool
TVersionGLSL
:
:
visitDeclaration
(
Visit
TIntermDeclaration
*
node
)
{
const
TIntermSequence
&
sequence
=
*
(
node
-
>
getSequence
(
)
)
;
if
(
sequence
.
front
(
)
-
>
getAsTyped
(
)
-
>
getType
(
)
.
isInvariant
(
)
)
{
ensureVersionIsAtLeast
(
GLSL_VERSION_120
)
;
}
return
true
;
}
bool
TVersionGLSL
:
:
visitInvariantDeclaration
(
Visit
TIntermInvariantDeclaration
*
node
)
{
ensureVersionIsAtLeast
(
GLSL_VERSION_120
)
;
return
true
;
}
bool
TVersionGLSL
:
:
visitFunctionPrototype
(
Visit
TIntermFunctionPrototype
*
node
)
{
const
TIntermSequence
&
params
=
*
(
node
-
>
getSequence
(
)
)
;
for
(
TIntermSequence
:
:
const_iterator
iter
=
params
.
begin
(
)
;
iter
!
=
params
.
end
(
)
;
+
+
iter
)
{
const
TIntermTyped
*
param
=
(
*
iter
)
-
>
getAsTyped
(
)
;
if
(
param
-
>
isArray
(
)
)
{
TQualifier
qualifier
=
param
-
>
getQualifier
(
)
;
if
(
(
qualifier
=
=
EvqOut
)
|
|
(
qualifier
=
=
EvqInOut
)
)
{
ensureVersionIsAtLeast
(
GLSL_VERSION_120
)
;
break
;
}
}
}
return
false
;
}
bool
TVersionGLSL
:
:
visitAggregate
(
Visit
TIntermAggregate
*
node
)
{
if
(
node
-
>
getOp
(
)
=
=
EOpConstruct
&
&
node
-
>
getType
(
)
.
isMatrix
(
)
)
{
const
TIntermSequence
&
sequence
=
*
(
node
-
>
getSequence
(
)
)
;
if
(
sequence
.
size
(
)
=
=
1
)
{
TIntermTyped
*
typed
=
sequence
.
front
(
)
-
>
getAsTyped
(
)
;
if
(
typed
&
&
typed
-
>
isMatrix
(
)
)
{
ensureVersionIsAtLeast
(
GLSL_VERSION_120
)
;
}
}
}
return
true
;
}
void
TVersionGLSL
:
:
ensureVersionIsAtLeast
(
int
version
)
{
mVersion
=
std
:
:
max
(
version
mVersion
)
;
}
}
