#
ifndef
COMPILER_TRANSLATOR_COMPILER_H_
#
define
COMPILER_TRANSLATOR_COMPILER_H_
#
include
"
compiler
/
translator
/
BuiltInFunctionEmulator
.
h
"
#
include
"
compiler
/
translator
/
CallDAG
.
h
"
#
include
"
compiler
/
translator
/
ExtensionBehavior
.
h
"
#
include
"
compiler
/
translator
/
HashNames
.
h
"
#
include
"
compiler
/
translator
/
InfoSink
.
h
"
#
include
"
compiler
/
translator
/
Pragma
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
"
compiler
/
translator
/
VariableInfo
.
h
"
#
include
"
third_party
/
compiler
/
ArrayBoundsClamper
.
h
"
class
TCompiler
;
class
TDependencyGraph
;
#
ifdef
ANGLE_ENABLE_HLSL
class
TranslatorHLSL
;
#
endif
bool
IsWebGLBasedSpec
(
ShShaderSpec
spec
)
;
bool
IsGLSL130OrNewer
(
ShShaderOutput
output
)
;
class
TShHandleBase
{
public
:
TShHandleBase
(
)
;
virtual
~
TShHandleBase
(
)
;
virtual
TCompiler
*
getAsCompiler
(
)
{
return
0
;
}
#
ifdef
ANGLE_ENABLE_HLSL
virtual
TranslatorHLSL
*
getAsTranslatorHLSL
(
)
{
return
0
;
}
#
endif
protected
:
TPoolAllocator
allocator
;
}
;
class
TCompiler
:
public
TShHandleBase
{
public
:
TCompiler
(
sh
:
:
GLenum
type
ShShaderSpec
spec
ShShaderOutput
output
)
;
~
TCompiler
(
)
override
;
TCompiler
*
getAsCompiler
(
)
override
{
return
this
;
}
bool
Init
(
const
ShBuiltInResources
&
resources
)
;
TIntermNode
*
compileTreeForTesting
(
const
char
*
const
shaderStrings
[
]
size_t
numStrings
int
compileOptions
)
;
bool
compile
(
const
char
*
const
shaderStrings
[
]
size_t
numStrings
int
compileOptions
)
;
int
getShaderVersion
(
)
const
{
return
shaderVersion
;
}
TInfoSink
&
getInfoSink
(
)
{
return
infoSink
;
}
void
clearResults
(
)
;
const
std
:
:
vector
<
sh
:
:
Attribute
>
&
getAttributes
(
)
const
{
return
attributes
;
}
const
std
:
:
vector
<
sh
:
:
OutputVariable
>
&
getOutputVariables
(
)
const
{
return
outputVariables
;
}
const
std
:
:
vector
<
sh
:
:
Uniform
>
&
getUniforms
(
)
const
{
return
uniforms
;
}
const
std
:
:
vector
<
sh
:
:
Varying
>
&
getVaryings
(
)
const
{
return
varyings
;
}
const
std
:
:
vector
<
sh
:
:
InterfaceBlock
>
&
getInterfaceBlocks
(
)
const
{
return
interfaceBlocks
;
}
ShHashFunction64
getHashFunction
(
)
const
{
return
hashFunction
;
}
NameMap
&
getNameMap
(
)
{
return
nameMap
;
}
TSymbolTable
&
getSymbolTable
(
)
{
return
symbolTable
;
}
ShShaderSpec
getShaderSpec
(
)
const
{
return
shaderSpec
;
}
ShShaderOutput
getOutputType
(
)
const
{
return
outputType
;
}
const
std
:
:
string
&
getBuiltInResourcesString
(
)
const
{
return
builtInResourcesString
;
}
bool
shouldRunLoopAndIndexingValidation
(
int
compileOptions
)
const
;
const
ShBuiltInResources
&
getResources
(
)
const
;
protected
:
sh
:
:
GLenum
getShaderType
(
)
const
{
return
shaderType
;
}
bool
InitBuiltInSymbolTable
(
const
ShBuiltInResources
&
resources
)
;
void
setResourceString
(
)
;
bool
checkCallDepth
(
)
;
bool
validateOutputs
(
TIntermNode
*
root
)
;
void
rewriteCSSShader
(
TIntermNode
*
root
)
;
bool
validateLimitations
(
TIntermNode
*
root
)
;
void
collectVariables
(
TIntermNode
*
root
)
;
virtual
void
initBuiltInFunctionEmulator
(
BuiltInFunctionEmulator
*
emu
int
compileOptions
)
{
}
;
virtual
void
translate
(
TIntermNode
*
root
int
compileOptions
)
=
0
;
bool
enforcePackingRestrictions
(
)
;
void
initializeVaryingsWithoutStaticUse
(
TIntermNode
*
root
)
;
void
initializeGLPosition
(
TIntermNode
*
root
)
;
bool
enforceTimingRestrictions
(
TIntermNode
*
root
bool
outputGraph
)
;
bool
enforceVertexShaderTimingRestrictions
(
TIntermNode
*
root
)
;
bool
enforceFragmentShaderTimingRestrictions
(
const
TDependencyGraph
&
graph
)
;
bool
limitExpressionComplexity
(
TIntermNode
*
root
)
;
const
TExtensionBehavior
&
getExtensionBehavior
(
)
const
;
const
char
*
getSourcePath
(
)
const
;
const
TPragma
&
getPragma
(
)
const
{
return
mPragma
;
}
void
writePragma
(
)
;
const
ArrayBoundsClamper
&
getArrayBoundsClamper
(
)
const
;
ShArrayIndexClampingStrategy
getArrayIndexClampingStrategy
(
)
const
;
const
BuiltInFunctionEmulator
&
getBuiltInFunctionEmulator
(
)
const
;
std
:
:
vector
<
sh
:
:
Attribute
>
attributes
;
std
:
:
vector
<
sh
:
:
OutputVariable
>
outputVariables
;
std
:
:
vector
<
sh
:
:
Uniform
>
uniforms
;
std
:
:
vector
<
sh
:
:
ShaderVariable
>
expandedUniforms
;
std
:
:
vector
<
sh
:
:
Varying
>
varyings
;
std
:
:
vector
<
sh
:
:
InterfaceBlock
>
interfaceBlocks
;
virtual
bool
shouldCollectVariables
(
int
compileOptions
)
{
return
(
compileOptions
&
SH_VARIABLES
)
!
=
0
;
}
private
:
bool
initCallDag
(
TIntermNode
*
root
)
;
bool
tagUsedFunctions
(
)
;
void
internalTagUsedFunction
(
size_t
index
)
;
class
UnusedPredicate
;
bool
pruneUnusedFunctions
(
TIntermNode
*
root
)
;
TIntermNode
*
compileTreeImpl
(
const
char
*
const
shaderStrings
[
]
size_t
numStrings
const
int
compileOptions
)
;
sh
:
:
GLenum
shaderType
;
ShShaderSpec
shaderSpec
;
ShShaderOutput
outputType
;
struct
FunctionMetadata
{
FunctionMetadata
(
)
:
used
(
false
)
{
}
bool
used
;
}
;
CallDAG
mCallDag
;
std
:
:
vector
<
FunctionMetadata
>
functionMetadata
;
int
maxUniformVectors
;
int
maxExpressionComplexity
;
int
maxCallStackDepth
;
ShBuiltInResources
compileResources
;
std
:
:
string
builtInResourcesString
;
TSymbolTable
symbolTable
;
TExtensionBehavior
extensionBehavior
;
bool
fragmentPrecisionHigh
;
ArrayBoundsClamper
arrayBoundsClamper
;
ShArrayIndexClampingStrategy
clampingStrategy
;
BuiltInFunctionEmulator
builtInFunctionEmulator
;
int
shaderVersion
;
TInfoSink
infoSink
;
const
char
*
mSourcePath
;
ShHashFunction64
hashFunction
;
NameMap
nameMap
;
TPragma
mPragma
;
}
;
TCompiler
*
ConstructCompiler
(
sh
:
:
GLenum
type
ShShaderSpec
spec
ShShaderOutput
output
)
;
void
DeleteCompiler
(
TCompiler
*
)
;
#
endif
