#
include
"
compiler
/
translator
/
RemoveDynamicIndexing
.
h
"
#
include
"
compiler
/
translator
/
InfoSink
.
h
"
#
include
"
compiler
/
translator
/
IntermNodePatternMatcher
.
h
"
#
include
"
compiler
/
translator
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
IntermTraverse
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
namespace
sh
{
namespace
{
std
:
:
string
GetIndexFunctionName
(
const
TType
&
type
bool
write
)
{
TInfoSinkBase
nameSink
;
nameSink
<
<
"
dyn_index_
"
;
if
(
write
)
{
nameSink
<
<
"
write_
"
;
}
if
(
type
.
isMatrix
(
)
)
{
nameSink
<
<
"
mat
"
<
<
type
.
getCols
(
)
<
<
"
x
"
<
<
type
.
getRows
(
)
;
}
else
{
switch
(
type
.
getBasicType
(
)
)
{
case
EbtInt
:
nameSink
<
<
"
ivec
"
;
break
;
case
EbtBool
:
nameSink
<
<
"
bvec
"
;
break
;
case
EbtUInt
:
nameSink
<
<
"
uvec
"
;
break
;
case
EbtFloat
:
nameSink
<
<
"
vec
"
;
break
;
default
:
UNREACHABLE
(
)
;
}
nameSink
<
<
type
.
getNominalSize
(
)
;
}
return
nameSink
.
str
(
)
;
}
TIntermSymbol
*
CreateBaseSymbol
(
const
TType
&
type
TQualifier
qualifier
TSymbolTable
*
symbolTable
)
{
TIntermSymbol
*
symbol
=
new
TIntermSymbol
(
symbolTable
-
>
nextUniqueId
(
)
"
base
"
type
)
;
symbol
-
>
setInternal
(
true
)
;
symbol
-
>
getTypePointer
(
)
-
>
setQualifier
(
qualifier
)
;
return
symbol
;
}
TIntermSymbol
*
CreateIndexSymbol
(
TSymbolTable
*
symbolTable
)
{
TIntermSymbol
*
symbol
=
new
TIntermSymbol
(
symbolTable
-
>
nextUniqueId
(
)
"
index
"
TType
(
EbtInt
EbpHigh
)
)
;
symbol
-
>
setInternal
(
true
)
;
symbol
-
>
getTypePointer
(
)
-
>
setQualifier
(
EvqIn
)
;
return
symbol
;
}
TIntermSymbol
*
CreateValueSymbol
(
const
TType
&
type
TSymbolTable
*
symbolTable
)
{
TIntermSymbol
*
symbol
=
new
TIntermSymbol
(
symbolTable
-
>
nextUniqueId
(
)
"
value
"
type
)
;
symbol
-
>
setInternal
(
true
)
;
symbol
-
>
getTypePointer
(
)
-
>
setQualifier
(
EvqIn
)
;
return
symbol
;
}
TIntermConstantUnion
*
CreateIntConstantNode
(
int
i
)
{
TConstantUnion
*
constant
=
new
TConstantUnion
(
)
;
constant
-
>
setIConst
(
i
)
;
return
new
TIntermConstantUnion
(
constant
TType
(
EbtInt
EbpHigh
)
)
;
}
TIntermTyped
*
EnsureSignedInt
(
TIntermTyped
*
node
)
{
if
(
node
-
>
getBasicType
(
)
=
=
EbtInt
)
return
node
;
TIntermSequence
*
arguments
=
new
TIntermSequence
(
)
;
arguments
-
>
push_back
(
node
)
;
return
TIntermAggregate
:
:
CreateConstructor
(
TType
(
EbtInt
)
arguments
)
;
}
TType
GetFieldType
(
const
TType
&
indexedType
)
{
if
(
indexedType
.
isMatrix
(
)
)
{
TType
fieldType
=
TType
(
indexedType
.
getBasicType
(
)
indexedType
.
getPrecision
(
)
)
;
fieldType
.
setPrimarySize
(
static_cast
<
unsigned
char
>
(
indexedType
.
getRows
(
)
)
)
;
return
fieldType
;
}
else
{
return
TType
(
indexedType
.
getBasicType
(
)
indexedType
.
getPrecision
(
)
)
;
}
}
TIntermFunctionDefinition
*
GetIndexFunctionDefinition
(
TType
type
bool
write
const
TSymbolUniqueId
&
functionId
TSymbolTable
*
symbolTable
)
{
ASSERT
(
!
type
.
isArray
(
)
)
;
type
.
setPrecision
(
EbpHigh
)
;
TType
fieldType
=
GetFieldType
(
type
)
;
int
numCases
=
0
;
if
(
type
.
isMatrix
(
)
)
{
numCases
=
type
.
getCols
(
)
;
}
else
{
numCases
=
type
.
getNominalSize
(
)
;
}
TType
returnType
(
EbtVoid
)
;
if
(
!
write
)
{
returnType
=
fieldType
;
}
std
:
:
string
functionName
=
GetIndexFunctionName
(
type
write
)
;
TIntermFunctionPrototype
*
prototypeNode
=
CreateInternalFunctionPrototypeNode
(
returnType
functionName
.
c_str
(
)
functionId
)
;
TQualifier
baseQualifier
=
EvqInOut
;
if
(
!
write
)
baseQualifier
=
EvqIn
;
TIntermSymbol
*
baseParam
=
CreateBaseSymbol
(
type
baseQualifier
symbolTable
)
;
prototypeNode
-
>
getSequence
(
)
-
>
push_back
(
baseParam
)
;
TIntermSymbol
*
indexParam
=
CreateIndexSymbol
(
symbolTable
)
;
prototypeNode
-
>
getSequence
(
)
-
>
push_back
(
indexParam
)
;
TIntermSymbol
*
valueParam
=
nullptr
;
if
(
write
)
{
valueParam
=
CreateValueSymbol
(
fieldType
symbolTable
)
;
prototypeNode
-
>
getSequence
(
)
-
>
push_back
(
valueParam
)
;
}
TIntermBlock
*
statementList
=
new
TIntermBlock
(
)
;
for
(
int
i
=
0
;
i
<
numCases
;
+
+
i
)
{
TIntermCase
*
caseNode
=
new
TIntermCase
(
CreateIntConstantNode
(
i
)
)
;
statementList
-
>
getSequence
(
)
-
>
push_back
(
caseNode
)
;
TIntermBinary
*
indexNode
=
new
TIntermBinary
(
EOpIndexDirect
baseParam
-
>
deepCopy
(
)
CreateIndexNode
(
i
)
)
;
if
(
write
)
{
TIntermBinary
*
assignNode
=
new
TIntermBinary
(
EOpAssign
indexNode
valueParam
-
>
deepCopy
(
)
)
;
statementList
-
>
getSequence
(
)
-
>
push_back
(
assignNode
)
;
TIntermBranch
*
returnNode
=
new
TIntermBranch
(
EOpReturn
nullptr
)
;
statementList
-
>
getSequence
(
)
-
>
push_back
(
returnNode
)
;
}
else
{
TIntermBranch
*
returnNode
=
new
TIntermBranch
(
EOpReturn
indexNode
)
;
statementList
-
>
getSequence
(
)
-
>
push_back
(
returnNode
)
;
}
}
TIntermCase
*
defaultNode
=
new
TIntermCase
(
nullptr
)
;
statementList
-
>
getSequence
(
)
-
>
push_back
(
defaultNode
)
;
TIntermBranch
*
breakNode
=
new
TIntermBranch
(
EOpBreak
nullptr
)
;
statementList
-
>
getSequence
(
)
-
>
push_back
(
breakNode
)
;
TIntermSwitch
*
switchNode
=
new
TIntermSwitch
(
indexParam
-
>
deepCopy
(
)
statementList
)
;
TIntermBlock
*
bodyNode
=
new
TIntermBlock
(
)
;
bodyNode
-
>
getSequence
(
)
-
>
push_back
(
switchNode
)
;
TIntermBinary
*
cond
=
new
TIntermBinary
(
EOpLessThan
indexParam
-
>
deepCopy
(
)
CreateIntConstantNode
(
0
)
)
;
cond
-
>
setType
(
TType
(
EbtBool
EbpUndefined
)
)
;
TIntermBlock
*
useFirstBlock
=
new
TIntermBlock
(
)
;
TIntermBlock
*
useLastBlock
=
new
TIntermBlock
(
)
;
TIntermBinary
*
indexFirstNode
=
new
TIntermBinary
(
EOpIndexDirect
baseParam
-
>
deepCopy
(
)
CreateIndexNode
(
0
)
)
;
TIntermBinary
*
indexLastNode
=
new
TIntermBinary
(
EOpIndexDirect
baseParam
-
>
deepCopy
(
)
CreateIndexNode
(
numCases
-
1
)
)
;
if
(
write
)
{
TIntermBinary
*
assignFirstNode
=
new
TIntermBinary
(
EOpAssign
indexFirstNode
valueParam
-
>
deepCopy
(
)
)
;
useFirstBlock
-
>
getSequence
(
)
-
>
push_back
(
assignFirstNode
)
;
TIntermBranch
*
returnNode
=
new
TIntermBranch
(
EOpReturn
nullptr
)
;
useFirstBlock
-
>
getSequence
(
)
-
>
push_back
(
returnNode
)
;
TIntermBinary
*
assignLastNode
=
new
TIntermBinary
(
EOpAssign
indexLastNode
valueParam
-
>
deepCopy
(
)
)
;
useLastBlock
-
>
getSequence
(
)
-
>
push_back
(
assignLastNode
)
;
}
else
{
TIntermBranch
*
returnFirstNode
=
new
TIntermBranch
(
EOpReturn
indexFirstNode
)
;
useFirstBlock
-
>
getSequence
(
)
-
>
push_back
(
returnFirstNode
)
;
TIntermBranch
*
returnLastNode
=
new
TIntermBranch
(
EOpReturn
indexLastNode
)
;
useLastBlock
-
>
getSequence
(
)
-
>
push_back
(
returnLastNode
)
;
}
TIntermIfElse
*
ifNode
=
new
TIntermIfElse
(
cond
useFirstBlock
nullptr
)
;
bodyNode
-
>
getSequence
(
)
-
>
push_back
(
ifNode
)
;
bodyNode
-
>
getSequence
(
)
-
>
push_back
(
useLastBlock
)
;
TIntermFunctionDefinition
*
indexingFunction
=
new
TIntermFunctionDefinition
(
prototypeNode
bodyNode
)
;
return
indexingFunction
;
}
class
RemoveDynamicIndexingTraverser
:
public
TLValueTrackingTraverser
{
public
:
RemoveDynamicIndexingTraverser
(
TSymbolTable
*
symbolTable
int
shaderVersion
)
;
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
;
void
insertHelperDefinitions
(
TIntermNode
*
root
)
;
void
nextIteration
(
)
;
bool
usedTreeInsertion
(
)
const
{
return
mUsedTreeInsertion
;
}
protected
:
std
:
:
map
<
TType
TSymbolUniqueId
*
>
mIndexedVecAndMatrixTypes
;
std
:
:
map
<
TType
TSymbolUniqueId
*
>
mWrittenVecAndMatrixTypes
;
bool
mUsedTreeInsertion
;
bool
mRemoveIndexSideEffectsInSubtree
;
}
;
RemoveDynamicIndexingTraverser
:
:
RemoveDynamicIndexingTraverser
(
TSymbolTable
*
symbolTable
int
shaderVersion
)
:
TLValueTrackingTraverser
(
true
false
false
symbolTable
shaderVersion
)
mUsedTreeInsertion
(
false
)
mRemoveIndexSideEffectsInSubtree
(
false
)
{
}
void
RemoveDynamicIndexingTraverser
:
:
insertHelperDefinitions
(
TIntermNode
*
root
)
{
TIntermBlock
*
rootBlock
=
root
-
>
getAsBlock
(
)
;
ASSERT
(
rootBlock
!
=
nullptr
)
;
TIntermSequence
insertions
;
for
(
auto
&
type
:
mIndexedVecAndMatrixTypes
)
{
insertions
.
push_back
(
GetIndexFunctionDefinition
(
type
.
first
false
*
type
.
second
mSymbolTable
)
)
;
}
for
(
auto
&
type
:
mWrittenVecAndMatrixTypes
)
{
insertions
.
push_back
(
GetIndexFunctionDefinition
(
type
.
first
true
*
type
.
second
mSymbolTable
)
)
;
}
mInsertions
.
push_back
(
NodeInsertMultipleEntry
(
rootBlock
0
insertions
TIntermSequence
(
)
)
)
;
}
TIntermAggregate
*
CreateIndexFunctionCall
(
TIntermBinary
*
node
TIntermTyped
*
index
const
TSymbolUniqueId
&
functionId
)
{
ASSERT
(
node
-
>
getOp
(
)
=
=
EOpIndexIndirect
)
;
TIntermSequence
*
arguments
=
new
TIntermSequence
(
)
;
arguments
-
>
push_back
(
node
-
>
getLeft
(
)
)
;
arguments
-
>
push_back
(
index
)
;
TType
fieldType
=
GetFieldType
(
node
-
>
getLeft
(
)
-
>
getType
(
)
)
;
std
:
:
string
functionName
=
GetIndexFunctionName
(
node
-
>
getLeft
(
)
-
>
getType
(
)
false
)
;
TIntermAggregate
*
indexingCall
=
CreateInternalFunctionCallNode
(
fieldType
functionName
.
c_str
(
)
functionId
arguments
)
;
indexingCall
-
>
setLine
(
node
-
>
getLine
(
)
)
;
indexingCall
-
>
getFunctionSymbolInfo
(
)
-
>
setKnownToNotHaveSideEffects
(
true
)
;
return
indexingCall
;
}
TIntermAggregate
*
CreateIndexedWriteFunctionCall
(
TIntermBinary
*
node
TIntermTyped
*
index
TIntermTyped
*
writtenValue
const
TSymbolUniqueId
&
functionId
)
{
ASSERT
(
node
-
>
getOp
(
)
=
=
EOpIndexIndirect
)
;
TIntermSequence
*
arguments
=
new
TIntermSequence
(
)
;
arguments
-
>
push_back
(
node
-
>
getLeft
(
)
-
>
deepCopy
(
)
)
;
arguments
-
>
push_back
(
index
-
>
deepCopy
(
)
)
;
arguments
-
>
push_back
(
writtenValue
)
;
std
:
:
string
functionName
=
GetIndexFunctionName
(
node
-
>
getLeft
(
)
-
>
getType
(
)
true
)
;
TIntermAggregate
*
indexedWriteCall
=
CreateInternalFunctionCallNode
(
TType
(
EbtVoid
)
functionName
.
c_str
(
)
functionId
arguments
)
;
indexedWriteCall
-
>
setLine
(
node
-
>
getLine
(
)
)
;
return
indexedWriteCall
;
}
bool
RemoveDynamicIndexingTraverser
:
:
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
{
if
(
mUsedTreeInsertion
)
return
false
;
if
(
node
-
>
getOp
(
)
=
=
EOpIndexIndirect
)
{
if
(
mRemoveIndexSideEffectsInSubtree
)
{
ASSERT
(
node
-
>
getRight
(
)
-
>
hasSideEffects
(
)
)
;
TIntermDeclaration
*
initIndex
=
createTempInitDeclaration
(
node
-
>
getRight
(
)
)
;
insertStatementInParentBlock
(
initIndex
)
;
mUsedTreeInsertion
=
true
;
TIntermSymbol
*
tempIndex
=
createTempSymbol
(
node
-
>
getRight
(
)
-
>
getType
(
)
)
;
queueReplacementWithParent
(
node
node
-
>
getRight
(
)
tempIndex
OriginalNode
:
:
IS_DROPPED
)
;
}
else
if
(
IntermNodePatternMatcher
:
:
IsDynamicIndexingOfVectorOrMatrix
(
node
)
)
{
bool
write
=
isLValueRequiredHere
(
)
;
#
if
defined
(
ANGLE_ENABLE_ASSERTS
)
IntermNodePatternMatcher
matcher
(
IntermNodePatternMatcher
:
:
kDynamicIndexingOfVectorOrMatrixInLValue
)
;
ASSERT
(
matcher
.
match
(
node
getParentNode
(
)
isLValueRequiredHere
(
)
)
=
=
write
)
;
#
endif
const
TType
&
type
=
node
-
>
getLeft
(
)
-
>
getType
(
)
;
TSymbolUniqueId
*
indexingFunctionId
=
new
TSymbolUniqueId
(
mSymbolTable
)
;
if
(
mIndexedVecAndMatrixTypes
.
find
(
type
)
=
=
mIndexedVecAndMatrixTypes
.
end
(
)
)
{
mIndexedVecAndMatrixTypes
[
type
]
=
indexingFunctionId
;
}
else
{
indexingFunctionId
=
mIndexedVecAndMatrixTypes
[
type
]
;
}
if
(
write
)
{
if
(
node
-
>
getLeft
(
)
-
>
hasSideEffects
(
)
)
{
mRemoveIndexSideEffectsInSubtree
=
true
;
return
true
;
}
TIntermBinary
*
leftBinary
=
node
-
>
getLeft
(
)
-
>
getAsBinaryNode
(
)
;
if
(
leftBinary
!
=
nullptr
&
&
IntermNodePatternMatcher
:
:
IsDynamicIndexingOfVectorOrMatrix
(
leftBinary
)
)
{
return
true
;
}
TSymbolUniqueId
*
indexedWriteFunctionId
=
new
TSymbolUniqueId
(
mSymbolTable
)
;
if
(
mWrittenVecAndMatrixTypes
.
find
(
type
)
=
=
mWrittenVecAndMatrixTypes
.
end
(
)
)
{
mWrittenVecAndMatrixTypes
[
type
]
=
indexedWriteFunctionId
;
}
else
{
indexedWriteFunctionId
=
mWrittenVecAndMatrixTypes
[
type
]
;
}
TType
fieldType
=
GetFieldType
(
type
)
;
TIntermSequence
insertionsBefore
;
TIntermSequence
insertionsAfter
;
TIntermTyped
*
indexInitializer
=
EnsureSignedInt
(
node
-
>
getRight
(
)
)
;
TIntermDeclaration
*
initIndex
=
createTempInitDeclaration
(
indexInitializer
)
;
initIndex
-
>
setLine
(
node
-
>
getLine
(
)
)
;
insertionsBefore
.
push_back
(
initIndex
)
;
TIntermSymbol
*
tempIndex
=
createTempSymbol
(
indexInitializer
-
>
getType
(
)
)
;
TIntermAggregate
*
indexingCall
=
CreateIndexFunctionCall
(
node
tempIndex
*
indexingFunctionId
)
;
nextTemporaryId
(
)
;
insertionsBefore
.
push_back
(
createTempInitDeclaration
(
indexingCall
)
)
;
TIntermAggregate
*
indexedWriteCall
=
CreateIndexedWriteFunctionCall
(
node
tempIndex
createTempSymbol
(
fieldType
)
*
indexedWriteFunctionId
)
;
insertionsAfter
.
push_back
(
indexedWriteCall
)
;
insertStatementsInParentBlock
(
insertionsBefore
insertionsAfter
)
;
queueReplacement
(
createTempSymbol
(
fieldType
)
OriginalNode
:
:
IS_DROPPED
)
;
mUsedTreeInsertion
=
true
;
}
else
{
ASSERT
(
!
mRemoveIndexSideEffectsInSubtree
)
;
TIntermAggregate
*
indexingCall
=
CreateIndexFunctionCall
(
node
EnsureSignedInt
(
node
-
>
getRight
(
)
)
*
indexingFunctionId
)
;
queueReplacement
(
indexingCall
OriginalNode
:
:
IS_DROPPED
)
;
}
}
}
return
!
mUsedTreeInsertion
;
}
void
RemoveDynamicIndexingTraverser
:
:
nextIteration
(
)
{
mUsedTreeInsertion
=
false
;
mRemoveIndexSideEffectsInSubtree
=
false
;
nextTemporaryId
(
)
;
}
}
void
RemoveDynamicIndexing
(
TIntermNode
*
root
TSymbolTable
*
symbolTable
int
shaderVersion
)
{
RemoveDynamicIndexingTraverser
traverser
(
symbolTable
shaderVersion
)
;
do
{
traverser
.
nextIteration
(
)
;
root
-
>
traverse
(
&
traverser
)
;
traverser
.
updateTree
(
)
;
}
while
(
traverser
.
usedTreeInsertion
(
)
)
;
traverser
.
insertHelperDefinitions
(
root
)
;
traverser
.
updateTree
(
)
;
}
}
