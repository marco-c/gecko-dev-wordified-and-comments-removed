#
include
"
compiler
/
translator
/
RewriteElseBlocks
.
h
"
#
include
"
compiler
/
translator
/
NodeSearch
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
namespace
sh
{
namespace
{
class
ElseBlockRewriter
:
public
TIntermTraverser
{
public
:
ElseBlockRewriter
(
)
;
protected
:
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
aggregate
)
override
;
private
:
const
TType
*
mFunctionType
;
TIntermNode
*
rewriteSelection
(
TIntermSelection
*
selection
)
;
}
;
ElseBlockRewriter
:
:
ElseBlockRewriter
(
)
:
TIntermTraverser
(
true
false
true
)
mFunctionType
(
NULL
)
{
}
bool
ElseBlockRewriter
:
:
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
{
switch
(
node
-
>
getOp
(
)
)
{
case
EOpSequence
:
if
(
visit
=
=
PostVisit
)
{
for
(
size_t
statementIndex
=
0
;
statementIndex
!
=
node
-
>
getSequence
(
)
-
>
size
(
)
;
statementIndex
+
+
)
{
TIntermNode
*
statement
=
(
*
node
-
>
getSequence
(
)
)
[
statementIndex
]
;
TIntermSelection
*
selection
=
statement
-
>
getAsSelectionNode
(
)
;
if
(
selection
&
&
selection
-
>
getFalseBlock
(
)
!
=
nullptr
)
{
TIntermSelection
*
elseIfBranch
=
selection
-
>
getFalseBlock
(
)
-
>
getAsSelectionNode
(
)
;
if
(
elseIfBranch
)
{
selection
-
>
replaceChildNode
(
elseIfBranch
rewriteSelection
(
elseIfBranch
)
)
;
delete
elseIfBranch
;
}
(
*
node
-
>
getSequence
(
)
)
[
statementIndex
]
=
rewriteSelection
(
selection
)
;
delete
selection
;
}
}
}
break
;
case
EOpFunction
:
mFunctionType
=
(
(
visit
=
=
PreVisit
)
?
&
node
-
>
getType
(
)
:
NULL
)
;
break
;
default
:
break
;
}
return
true
;
}
TIntermNode
*
ElseBlockRewriter
:
:
rewriteSelection
(
TIntermSelection
*
selection
)
{
ASSERT
(
selection
!
=
nullptr
)
;
nextTemporaryIndex
(
)
;
TIntermTyped
*
typedCondition
=
selection
-
>
getCondition
(
)
-
>
getAsTyped
(
)
;
TIntermAggregate
*
storeCondition
=
createTempInitDeclaration
(
typedCondition
)
;
TIntermSelection
*
falseBlock
=
nullptr
;
TType
boolType
(
EbtBool
EbpUndefined
EvqTemporary
)
;
if
(
selection
-
>
getFalseBlock
(
)
)
{
TIntermAggregate
*
negatedElse
=
nullptr
;
if
(
mFunctionType
&
&
mFunctionType
-
>
getBasicType
(
)
!
=
EbtVoid
)
{
TString
typeString
=
mFunctionType
-
>
getStruct
(
)
?
mFunctionType
-
>
getStruct
(
)
-
>
name
(
)
:
mFunctionType
-
>
getBasicString
(
)
;
TString
rawText
=
"
return
(
"
+
typeString
+
"
)
0
"
;
TIntermRaw
*
returnNode
=
new
TIntermRaw
(
*
mFunctionType
rawText
)
;
negatedElse
=
new
TIntermAggregate
(
EOpSequence
)
;
negatedElse
-
>
getSequence
(
)
-
>
push_back
(
returnNode
)
;
}
TIntermSymbol
*
conditionSymbolElse
=
createTempSymbol
(
boolType
)
;
TIntermUnary
*
negatedCondition
=
new
TIntermUnary
(
EOpLogicalNot
conditionSymbolElse
)
;
falseBlock
=
new
TIntermSelection
(
negatedCondition
selection
-
>
getFalseBlock
(
)
negatedElse
)
;
}
TIntermSymbol
*
conditionSymbolSel
=
createTempSymbol
(
boolType
)
;
TIntermSelection
*
newSelection
=
new
TIntermSelection
(
conditionSymbolSel
selection
-
>
getTrueBlock
(
)
falseBlock
)
;
TIntermAggregate
*
block
=
new
TIntermAggregate
(
EOpSequence
)
;
block
-
>
getSequence
(
)
-
>
push_back
(
storeCondition
)
;
block
-
>
getSequence
(
)
-
>
push_back
(
newSelection
)
;
return
block
;
}
}
void
RewriteElseBlocks
(
TIntermNode
*
node
unsigned
int
*
temporaryIndex
)
{
ElseBlockRewriter
rewriter
;
rewriter
.
useTemporaryIndex
(
temporaryIndex
)
;
node
-
>
traverse
(
&
rewriter
)
;
}
}
