#
ifndef
COMPILER_TRANSLATOR_BUILTINFUNCTIONEMULATOR_H_
#
define
COMPILER_TRANSLATOR_BUILTINFUNCTIONEMULATOR_H_
#
include
"
compiler
/
translator
/
InfoSink
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
namespace
sh
{
class
BuiltInFunctionEmulator
{
public
:
BuiltInFunctionEmulator
(
)
;
void
MarkBuiltInFunctionsForEmulation
(
TIntermNode
*
root
)
;
void
Cleanup
(
)
;
static
TString
GetEmulatedFunctionName
(
const
TString
&
name
)
;
bool
IsOutputEmpty
(
)
const
;
void
OutputEmulatedFunctions
(
TInfoSinkBase
&
out
)
const
;
void
addEmulatedFunction
(
TOperator
op
const
TType
*
param
const
char
*
emulatedFunctionDefinition
)
;
void
addEmulatedFunction
(
TOperator
op
const
TType
*
param1
const
TType
*
param2
const
char
*
emulatedFunctionDefinition
)
;
void
addEmulatedFunction
(
TOperator
op
const
TType
*
param1
const
TType
*
param2
const
TType
*
param3
const
char
*
emulatedFunctionDefinition
)
;
private
:
class
BuiltInFunctionEmulationMarker
;
bool
SetFunctionCalled
(
TOperator
op
const
TType
&
param
)
;
bool
SetFunctionCalled
(
TOperator
op
const
TType
&
param1
const
TType
&
param2
)
;
bool
SetFunctionCalled
(
TOperator
op
const
TType
&
param1
const
TType
&
param2
const
TType
&
param3
)
;
class
FunctionId
{
public
:
FunctionId
(
TOperator
op
const
TType
*
param
)
;
FunctionId
(
TOperator
op
const
TType
*
param1
const
TType
*
param2
)
;
FunctionId
(
TOperator
op
const
TType
*
param1
const
TType
*
param2
const
TType
*
param3
)
;
bool
operator
=
=
(
const
FunctionId
&
other
)
const
;
bool
operator
<
(
const
FunctionId
&
other
)
const
;
FunctionId
getCopy
(
)
const
;
private
:
TOperator
mOp
;
const
TType
*
mParam1
;
const
TType
*
mParam2
;
const
TType
*
mParam3
;
}
;
bool
SetFunctionCalled
(
const
FunctionId
&
functionId
)
;
std
:
:
map
<
FunctionId
std
:
:
string
>
mEmulatedFunctions
;
std
:
:
vector
<
FunctionId
>
mFunctions
;
}
;
}
#
endif
