#
ifndef
COMPILER_TRANSLATOR_INTERMNODE_H_
#
define
COMPILER_TRANSLATOR_INTERMNODE_H_
#
include
"
GLSLANG
/
ShaderLang
.
h
"
#
include
<
algorithm
>
#
include
<
queue
>
#
include
"
common
/
angleutils
.
h
"
#
include
"
compiler
/
translator
/
Common
.
h
"
#
include
"
compiler
/
translator
/
ConstantUnion
.
h
"
#
include
"
compiler
/
translator
/
Operator
.
h
"
#
include
"
compiler
/
translator
/
Types
.
h
"
class
TDiagnostics
;
class
TIntermTraverser
;
class
TIntermAggregate
;
class
TIntermBinary
;
class
TIntermUnary
;
class
TIntermConstantUnion
;
class
TIntermTernary
;
class
TIntermSelection
;
class
TIntermSwitch
;
class
TIntermCase
;
class
TIntermTyped
;
class
TIntermSymbol
;
class
TIntermLoop
;
class
TInfoSink
;
class
TInfoSinkBase
;
class
TIntermRaw
;
class
TIntermBranch
;
class
TSymbolTable
;
class
TName
{
public
:
POOL_ALLOCATOR_NEW_DELETE
(
)
;
explicit
TName
(
const
TString
&
name
)
:
mName
(
name
)
mIsInternal
(
false
)
{
}
TName
(
)
:
mName
(
)
mIsInternal
(
false
)
{
}
TName
(
const
TName
&
)
=
default
;
TName
&
operator
=
(
const
TName
&
)
=
default
;
const
TString
&
getString
(
)
const
{
return
mName
;
}
void
setString
(
const
TString
&
string
)
{
mName
=
string
;
}
bool
isInternal
(
)
const
{
return
mIsInternal
;
}
void
setInternal
(
bool
isInternal
)
{
mIsInternal
=
isInternal
;
}
private
:
TString
mName
;
bool
mIsInternal
;
}
;
class
TIntermNode
:
angle
:
:
NonCopyable
{
public
:
POOL_ALLOCATOR_NEW_DELETE
(
)
;
TIntermNode
(
)
{
mLine
.
first_file
=
mLine
.
last_file
=
0
;
mLine
.
first_line
=
mLine
.
last_line
=
0
;
}
virtual
~
TIntermNode
(
)
{
}
const
TSourceLoc
&
getLine
(
)
const
{
return
mLine
;
}
void
setLine
(
const
TSourceLoc
&
l
)
{
mLine
=
l
;
}
virtual
void
traverse
(
TIntermTraverser
*
)
=
0
;
virtual
TIntermTyped
*
getAsTyped
(
)
{
return
0
;
}
virtual
TIntermConstantUnion
*
getAsConstantUnion
(
)
{
return
0
;
}
virtual
TIntermAggregate
*
getAsAggregate
(
)
{
return
0
;
}
virtual
TIntermBinary
*
getAsBinaryNode
(
)
{
return
0
;
}
virtual
TIntermUnary
*
getAsUnaryNode
(
)
{
return
0
;
}
virtual
TIntermTernary
*
getAsTernaryNode
(
)
{
return
nullptr
;
}
virtual
TIntermSelection
*
getAsSelectionNode
(
)
{
return
0
;
}
virtual
TIntermSwitch
*
getAsSwitchNode
(
)
{
return
0
;
}
virtual
TIntermCase
*
getAsCaseNode
(
)
{
return
0
;
}
virtual
TIntermSymbol
*
getAsSymbolNode
(
)
{
return
0
;
}
virtual
TIntermLoop
*
getAsLoopNode
(
)
{
return
0
;
}
virtual
TIntermRaw
*
getAsRawNode
(
)
{
return
0
;
}
virtual
TIntermBranch
*
getAsBranchNode
(
)
{
return
0
;
}
virtual
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
=
0
;
protected
:
TSourceLoc
mLine
;
}
;
struct
TIntermNodePair
{
TIntermNode
*
node1
;
TIntermNode
*
node2
;
}
;
class
TIntermTyped
:
public
TIntermNode
{
public
:
TIntermTyped
(
const
TType
&
t
)
:
mType
(
t
)
{
}
virtual
TIntermTyped
*
deepCopy
(
)
const
=
0
;
TIntermTyped
*
getAsTyped
(
)
override
{
return
this
;
}
virtual
bool
hasSideEffects
(
)
const
=
0
;
void
setType
(
const
TType
&
t
)
{
mType
=
t
;
}
void
setTypePreservePrecision
(
const
TType
&
t
)
;
const
TType
&
getType
(
)
const
{
return
mType
;
}
TType
*
getTypePointer
(
)
{
return
&
mType
;
}
TBasicType
getBasicType
(
)
const
{
return
mType
.
getBasicType
(
)
;
}
TQualifier
getQualifier
(
)
const
{
return
mType
.
getQualifier
(
)
;
}
TPrecision
getPrecision
(
)
const
{
return
mType
.
getPrecision
(
)
;
}
int
getCols
(
)
const
{
return
mType
.
getCols
(
)
;
}
int
getRows
(
)
const
{
return
mType
.
getRows
(
)
;
}
int
getNominalSize
(
)
const
{
return
mType
.
getNominalSize
(
)
;
}
int
getSecondarySize
(
)
const
{
return
mType
.
getSecondarySize
(
)
;
}
bool
isInterfaceBlock
(
)
const
{
return
mType
.
isInterfaceBlock
(
)
;
}
bool
isMatrix
(
)
const
{
return
mType
.
isMatrix
(
)
;
}
bool
isArray
(
)
const
{
return
mType
.
isArray
(
)
;
}
bool
isVector
(
)
const
{
return
mType
.
isVector
(
)
;
}
bool
isScalar
(
)
const
{
return
mType
.
isScalar
(
)
;
}
bool
isScalarInt
(
)
const
{
return
mType
.
isScalarInt
(
)
;
}
const
char
*
getBasicString
(
)
const
{
return
mType
.
getBasicString
(
)
;
}
TString
getCompleteString
(
)
const
{
return
mType
.
getCompleteString
(
)
;
}
unsigned
int
getArraySize
(
)
const
{
return
mType
.
getArraySize
(
)
;
}
bool
isConstructorWithOnlyConstantUnionParameters
(
)
;
static
TIntermTyped
*
CreateIndexNode
(
int
index
)
;
static
TIntermTyped
*
CreateZero
(
const
TType
&
type
)
;
protected
:
TType
mType
;
TIntermTyped
(
const
TIntermTyped
&
node
)
;
}
;
enum
TLoopType
{
ELoopFor
ELoopWhile
ELoopDoWhile
}
;
class
TIntermLoop
:
public
TIntermNode
{
public
:
TIntermLoop
(
TLoopType
type
TIntermNode
*
init
TIntermTyped
*
cond
TIntermTyped
*
expr
TIntermAggregate
*
body
)
:
mType
(
type
)
mInit
(
init
)
mCond
(
cond
)
mExpr
(
expr
)
mBody
(
body
)
mUnrollFlag
(
false
)
{
}
TIntermLoop
*
getAsLoopNode
(
)
override
{
return
this
;
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
TLoopType
getType
(
)
const
{
return
mType
;
}
TIntermNode
*
getInit
(
)
{
return
mInit
;
}
TIntermTyped
*
getCondition
(
)
{
return
mCond
;
}
TIntermTyped
*
getExpression
(
)
{
return
mExpr
;
}
TIntermAggregate
*
getBody
(
)
{
return
mBody
;
}
void
setCondition
(
TIntermTyped
*
condition
)
{
mCond
=
condition
;
}
void
setExpression
(
TIntermTyped
*
expression
)
{
mExpr
=
expression
;
}
void
setBody
(
TIntermAggregate
*
body
)
{
mBody
=
body
;
}
void
setUnrollFlag
(
bool
flag
)
{
mUnrollFlag
=
flag
;
}
bool
getUnrollFlag
(
)
const
{
return
mUnrollFlag
;
}
protected
:
TLoopType
mType
;
TIntermNode
*
mInit
;
TIntermTyped
*
mCond
;
TIntermTyped
*
mExpr
;
TIntermAggregate
*
mBody
;
bool
mUnrollFlag
;
}
;
class
TIntermBranch
:
public
TIntermNode
{
public
:
TIntermBranch
(
TOperator
op
TIntermTyped
*
e
)
:
mFlowOp
(
op
)
mExpression
(
e
)
{
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
TIntermBranch
*
getAsBranchNode
(
)
override
{
return
this
;
}
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
TOperator
getFlowOp
(
)
{
return
mFlowOp
;
}
TIntermTyped
*
getExpression
(
)
{
return
mExpression
;
}
protected
:
TOperator
mFlowOp
;
TIntermTyped
*
mExpression
;
}
;
class
TIntermSymbol
:
public
TIntermTyped
{
public
:
TIntermSymbol
(
int
id
const
TString
&
symbol
const
TType
&
type
)
:
TIntermTyped
(
type
)
mId
(
id
)
mSymbol
(
symbol
)
{
}
TIntermTyped
*
deepCopy
(
)
const
override
{
return
new
TIntermSymbol
(
*
this
)
;
}
bool
hasSideEffects
(
)
const
override
{
return
false
;
}
int
getId
(
)
const
{
return
mId
;
}
const
TString
&
getSymbol
(
)
const
{
return
mSymbol
.
getString
(
)
;
}
const
TName
&
getName
(
)
const
{
return
mSymbol
;
}
void
setId
(
int
newId
)
{
mId
=
newId
;
}
void
setInternal
(
bool
internal
)
{
mSymbol
.
setInternal
(
internal
)
;
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
TIntermSymbol
*
getAsSymbolNode
(
)
override
{
return
this
;
}
bool
replaceChildNode
(
TIntermNode
*
TIntermNode
*
)
override
{
return
false
;
}
protected
:
int
mId
;
TName
mSymbol
;
private
:
TIntermSymbol
(
const
TIntermSymbol
&
)
=
default
;
}
;
class
TIntermRaw
:
public
TIntermTyped
{
public
:
TIntermRaw
(
const
TType
&
type
const
TString
&
rawText
)
:
TIntermTyped
(
type
)
mRawText
(
rawText
)
{
}
TIntermRaw
(
const
TIntermRaw
&
)
=
delete
;
TIntermTyped
*
deepCopy
(
)
const
override
{
UNREACHABLE
(
)
;
return
nullptr
;
}
bool
hasSideEffects
(
)
const
override
{
return
false
;
}
TString
getRawText
(
)
const
{
return
mRawText
;
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
TIntermRaw
*
getAsRawNode
(
)
override
{
return
this
;
}
bool
replaceChildNode
(
TIntermNode
*
TIntermNode
*
)
override
{
return
false
;
}
protected
:
TString
mRawText
;
}
;
class
TIntermConstantUnion
:
public
TIntermTyped
{
public
:
TIntermConstantUnion
(
const
TConstantUnion
*
unionPointer
const
TType
&
type
)
:
TIntermTyped
(
type
)
mUnionArrayPointer
(
unionPointer
)
{
ASSERT
(
unionPointer
)
;
}
TIntermTyped
*
deepCopy
(
)
const
override
{
return
new
TIntermConstantUnion
(
*
this
)
;
}
bool
hasSideEffects
(
)
const
override
{
return
false
;
}
const
TConstantUnion
*
getUnionArrayPointer
(
)
const
{
return
mUnionArrayPointer
;
}
int
getIConst
(
size_t
index
)
const
{
return
mUnionArrayPointer
?
mUnionArrayPointer
[
index
]
.
getIConst
(
)
:
0
;
}
unsigned
int
getUConst
(
size_t
index
)
const
{
return
mUnionArrayPointer
?
mUnionArrayPointer
[
index
]
.
getUConst
(
)
:
0
;
}
float
getFConst
(
size_t
index
)
const
{
return
mUnionArrayPointer
?
mUnionArrayPointer
[
index
]
.
getFConst
(
)
:
0
.
0f
;
}
bool
getBConst
(
size_t
index
)
const
{
return
mUnionArrayPointer
?
mUnionArrayPointer
[
index
]
.
getBConst
(
)
:
false
;
}
void
replaceConstantUnion
(
const
TConstantUnion
*
safeConstantUnion
)
{
ASSERT
(
safeConstantUnion
)
;
mUnionArrayPointer
=
safeConstantUnion
;
}
TIntermConstantUnion
*
getAsConstantUnion
(
)
override
{
return
this
;
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
TIntermNode
*
)
override
{
return
false
;
}
TConstantUnion
*
foldBinary
(
TOperator
op
TIntermConstantUnion
*
rightNode
TDiagnostics
*
diagnostics
)
;
const
TConstantUnion
*
foldIndexing
(
int
index
)
;
TConstantUnion
*
foldUnaryNonComponentWise
(
TOperator
op
)
;
TConstantUnion
*
foldUnaryComponentWise
(
TOperator
op
TDiagnostics
*
diagnostics
)
;
static
TConstantUnion
*
FoldAggregateConstructor
(
TIntermAggregate
*
aggregate
)
;
static
TConstantUnion
*
FoldAggregateBuiltIn
(
TIntermAggregate
*
aggregate
TDiagnostics
*
diagnostics
)
;
protected
:
const
TConstantUnion
*
mUnionArrayPointer
;
private
:
typedef
float
(
*
FloatTypeUnaryFunc
)
(
float
)
;
void
foldFloatTypeUnary
(
const
TConstantUnion
&
parameter
FloatTypeUnaryFunc
builtinFunc
TConstantUnion
*
result
)
const
;
TIntermConstantUnion
(
const
TIntermConstantUnion
&
node
)
;
}
;
class
TIntermOperator
:
public
TIntermTyped
{
public
:
TOperator
getOp
(
)
const
{
return
mOp
;
}
bool
isAssignment
(
)
const
;
bool
isMultiplication
(
)
const
;
bool
isConstructor
(
)
const
;
bool
hasSideEffects
(
)
const
override
{
return
isAssignment
(
)
;
}
protected
:
TIntermOperator
(
TOperator
op
)
:
TIntermTyped
(
TType
(
EbtFloat
EbpUndefined
)
)
mOp
(
op
)
{
}
TIntermOperator
(
TOperator
op
const
TType
&
type
)
:
TIntermTyped
(
type
)
mOp
(
op
)
{
}
TIntermOperator
(
const
TIntermOperator
&
)
=
default
;
TOperator
mOp
;
}
;
class
TIntermBinary
:
public
TIntermOperator
{
public
:
TIntermBinary
(
TOperator
op
TIntermTyped
*
left
TIntermTyped
*
right
)
;
TIntermTyped
*
deepCopy
(
)
const
override
{
return
new
TIntermBinary
(
*
this
)
;
}
static
TOperator
GetMulOpBasedOnOperands
(
const
TType
&
left
const
TType
&
right
)
;
static
TOperator
GetMulAssignOpBasedOnOperands
(
const
TType
&
left
const
TType
&
right
)
;
TIntermBinary
*
getAsBinaryNode
(
)
override
{
return
this
;
}
;
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
bool
hasSideEffects
(
)
const
override
{
return
isAssignment
(
)
|
|
mLeft
-
>
hasSideEffects
(
)
|
|
mRight
-
>
hasSideEffects
(
)
;
}
TIntermTyped
*
getLeft
(
)
const
{
return
mLeft
;
}
TIntermTyped
*
getRight
(
)
const
{
return
mRight
;
}
TIntermTyped
*
fold
(
TDiagnostics
*
diagnostics
)
;
void
setAddIndexClamp
(
)
{
mAddIndexClamp
=
true
;
}
bool
getAddIndexClamp
(
)
{
return
mAddIndexClamp
;
}
protected
:
TIntermTyped
*
mLeft
;
TIntermTyped
*
mRight
;
bool
mAddIndexClamp
;
private
:
void
promote
(
)
;
TIntermBinary
(
const
TIntermBinary
&
node
)
;
}
;
class
TIntermUnary
:
public
TIntermOperator
{
public
:
TIntermUnary
(
TOperator
op
TIntermTyped
*
operand
)
;
TIntermTyped
*
deepCopy
(
)
const
override
{
return
new
TIntermUnary
(
*
this
)
;
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
TIntermUnary
*
getAsUnaryNode
(
)
override
{
return
this
;
}
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
bool
hasSideEffects
(
)
const
override
{
return
isAssignment
(
)
|
|
mOperand
-
>
hasSideEffects
(
)
;
}
TIntermTyped
*
getOperand
(
)
{
return
mOperand
;
}
TIntermTyped
*
fold
(
TDiagnostics
*
diagnostics
)
;
void
setUseEmulatedFunction
(
)
{
mUseEmulatedFunction
=
true
;
}
bool
getUseEmulatedFunction
(
)
{
return
mUseEmulatedFunction
;
}
protected
:
TIntermTyped
*
mOperand
;
bool
mUseEmulatedFunction
;
private
:
void
promote
(
)
;
TIntermUnary
(
const
TIntermUnary
&
node
)
;
}
;
typedef
TVector
<
TIntermNode
*
>
TIntermSequence
;
typedef
TVector
<
int
>
TQualifierList
;
class
TIntermAggregate
:
public
TIntermOperator
{
public
:
TIntermAggregate
(
)
:
TIntermOperator
(
EOpNull
)
mUserDefined
(
false
)
mFunctionId
(
0
)
mUseEmulatedFunction
(
false
)
mGotPrecisionFromChildren
(
false
)
{
}
TIntermAggregate
(
TOperator
op
)
:
TIntermOperator
(
op
)
mUserDefined
(
false
)
mFunctionId
(
0
)
mUseEmulatedFunction
(
false
)
mGotPrecisionFromChildren
(
false
)
{
}
~
TIntermAggregate
(
)
{
}
TIntermTyped
*
deepCopy
(
)
const
override
{
return
new
TIntermAggregate
(
*
this
)
;
}
void
setOp
(
TOperator
op
)
{
mOp
=
op
;
}
TIntermAggregate
*
getAsAggregate
(
)
override
{
return
this
;
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
bool
replaceChildNodeWithMultiple
(
TIntermNode
*
original
TIntermSequence
replacements
)
;
bool
insertChildNodes
(
TIntermSequence
:
:
size_type
position
TIntermSequence
insertions
)
;
bool
hasSideEffects
(
)
const
override
{
return
true
;
}
TIntermTyped
*
fold
(
TDiagnostics
*
diagnostics
)
;
TIntermSequence
*
getSequence
(
)
{
return
&
mSequence
;
}
const
TIntermSequence
*
getSequence
(
)
const
{
return
&
mSequence
;
}
void
setNameObj
(
const
TName
&
name
)
{
mName
=
name
;
}
const
TName
&
getNameObj
(
)
const
{
return
mName
;
}
void
setName
(
const
TString
&
name
)
{
mName
.
setString
(
name
)
;
}
const
TString
&
getName
(
)
const
{
return
mName
.
getString
(
)
;
}
void
setUserDefined
(
)
{
mUserDefined
=
true
;
}
bool
isUserDefined
(
)
const
{
return
mUserDefined
;
}
void
setFunctionId
(
int
functionId
)
{
mFunctionId
=
functionId
;
}
int
getFunctionId
(
)
const
{
return
mFunctionId
;
}
void
setUseEmulatedFunction
(
)
{
mUseEmulatedFunction
=
true
;
}
bool
getUseEmulatedFunction
(
)
{
return
mUseEmulatedFunction
;
}
bool
areChildrenConstQualified
(
)
;
void
setPrecisionFromChildren
(
)
;
void
setBuiltInFunctionPrecision
(
)
;
bool
gotPrecisionFromChildren
(
)
const
{
return
mGotPrecisionFromChildren
;
}
protected
:
TIntermSequence
mSequence
;
TName
mName
;
bool
mUserDefined
;
int
mFunctionId
;
bool
mUseEmulatedFunction
;
bool
mGotPrecisionFromChildren
;
private
:
TIntermAggregate
(
const
TIntermAggregate
&
node
)
;
}
;
class
TIntermTernary
:
public
TIntermTyped
{
public
:
TIntermTernary
(
TIntermTyped
*
cond
TIntermTyped
*
trueExpression
TIntermTyped
*
falseExpression
)
;
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
TIntermTyped
*
getCondition
(
)
const
{
return
mCondition
;
}
TIntermTyped
*
getTrueExpression
(
)
const
{
return
mTrueExpression
;
}
TIntermTyped
*
getFalseExpression
(
)
const
{
return
mFalseExpression
;
}
TIntermTernary
*
getAsTernaryNode
(
)
override
{
return
this
;
}
TIntermTyped
*
deepCopy
(
)
const
override
{
return
new
TIntermTernary
(
*
this
)
;
}
bool
hasSideEffects
(
)
const
override
{
return
mCondition
-
>
hasSideEffects
(
)
|
|
mTrueExpression
-
>
hasSideEffects
(
)
|
|
mFalseExpression
-
>
hasSideEffects
(
)
;
}
static
TQualifier
DetermineQualifier
(
TIntermTyped
*
cond
TIntermTyped
*
trueExpression
TIntermTyped
*
falseExpression
)
;
private
:
TIntermTernary
(
const
TIntermTernary
&
node
)
;
TIntermTyped
*
mCondition
;
TIntermTyped
*
mTrueExpression
;
TIntermTyped
*
mFalseExpression
;
}
;
class
TIntermSelection
:
public
TIntermNode
{
public
:
TIntermSelection
(
TIntermTyped
*
cond
TIntermNode
*
trueB
TIntermNode
*
falseB
)
:
TIntermNode
(
)
mCondition
(
cond
)
mTrueBlock
(
trueB
)
mFalseBlock
(
falseB
)
{
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
TIntermTyped
*
getCondition
(
)
const
{
return
mCondition
;
}
TIntermNode
*
getTrueBlock
(
)
const
{
return
mTrueBlock
;
}
TIntermNode
*
getFalseBlock
(
)
const
{
return
mFalseBlock
;
}
TIntermSelection
*
getAsSelectionNode
(
)
override
{
return
this
;
}
protected
:
TIntermTyped
*
mCondition
;
TIntermNode
*
mTrueBlock
;
TIntermNode
*
mFalseBlock
;
}
;
class
TIntermSwitch
:
public
TIntermNode
{
public
:
TIntermSwitch
(
TIntermTyped
*
init
TIntermAggregate
*
statementList
)
:
TIntermNode
(
)
mInit
(
init
)
mStatementList
(
statementList
)
{
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
TIntermSwitch
*
getAsSwitchNode
(
)
override
{
return
this
;
}
TIntermTyped
*
getInit
(
)
{
return
mInit
;
}
TIntermAggregate
*
getStatementList
(
)
{
return
mStatementList
;
}
void
setStatementList
(
TIntermAggregate
*
statementList
)
{
mStatementList
=
statementList
;
}
protected
:
TIntermTyped
*
mInit
;
TIntermAggregate
*
mStatementList
;
}
;
class
TIntermCase
:
public
TIntermNode
{
public
:
TIntermCase
(
TIntermTyped
*
condition
)
:
TIntermNode
(
)
mCondition
(
condition
)
{
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
TIntermCase
*
getAsCaseNode
(
)
override
{
return
this
;
}
bool
hasCondition
(
)
const
{
return
mCondition
!
=
nullptr
;
}
TIntermTyped
*
getCondition
(
)
const
{
return
mCondition
;
}
protected
:
TIntermTyped
*
mCondition
;
}
;
enum
Visit
{
PreVisit
InVisit
PostVisit
}
;
class
TIntermTraverser
:
angle
:
:
NonCopyable
{
public
:
POOL_ALLOCATOR_NEW_DELETE
(
)
;
TIntermTraverser
(
bool
preVisit
bool
inVisit
bool
postVisit
)
;
virtual
~
TIntermTraverser
(
)
;
virtual
void
visitSymbol
(
TIntermSymbol
*
node
)
{
}
virtual
void
visitRaw
(
TIntermRaw
*
node
)
{
}
virtual
void
visitConstantUnion
(
TIntermConstantUnion
*
node
)
{
}
virtual
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
{
return
true
;
}
virtual
bool
visitUnary
(
Visit
visit
TIntermUnary
*
node
)
{
return
true
;
}
virtual
bool
visitTernary
(
Visit
visit
TIntermTernary
*
node
)
{
return
true
;
}
virtual
bool
visitSelection
(
Visit
visit
TIntermSelection
*
node
)
{
return
true
;
}
virtual
bool
visitSwitch
(
Visit
visit
TIntermSwitch
*
node
)
{
return
true
;
}
virtual
bool
visitCase
(
Visit
visit
TIntermCase
*
node
)
{
return
true
;
}
virtual
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
{
return
true
;
}
virtual
bool
visitLoop
(
Visit
visit
TIntermLoop
*
node
)
{
return
true
;
}
virtual
bool
visitBranch
(
Visit
visit
TIntermBranch
*
node
)
{
return
true
;
}
virtual
void
traverseSymbol
(
TIntermSymbol
*
node
)
;
virtual
void
traverseRaw
(
TIntermRaw
*
node
)
;
virtual
void
traverseConstantUnion
(
TIntermConstantUnion
*
node
)
;
virtual
void
traverseBinary
(
TIntermBinary
*
node
)
;
virtual
void
traverseUnary
(
TIntermUnary
*
node
)
;
virtual
void
traverseTernary
(
TIntermTernary
*
node
)
;
virtual
void
traverseSelection
(
TIntermSelection
*
node
)
;
virtual
void
traverseSwitch
(
TIntermSwitch
*
node
)
;
virtual
void
traverseCase
(
TIntermCase
*
node
)
;
virtual
void
traverseAggregate
(
TIntermAggregate
*
node
)
;
virtual
void
traverseLoop
(
TIntermLoop
*
node
)
;
virtual
void
traverseBranch
(
TIntermBranch
*
node
)
;
int
getMaxDepth
(
)
const
{
return
mMaxDepth
;
}
static
TString
hash
(
const
TString
&
name
ShHashFunction64
hashFunction
)
;
void
updateTree
(
)
;
void
useTemporaryIndex
(
unsigned
int
*
temporaryIndex
)
;
protected
:
void
incrementDepth
(
TIntermNode
*
current
)
{
mDepth
+
+
;
mMaxDepth
=
std
:
:
max
(
mMaxDepth
mDepth
)
;
mPath
.
push_back
(
current
)
;
}
void
decrementDepth
(
)
{
mDepth
-
-
;
mPath
.
pop_back
(
)
;
}
TIntermNode
*
getParentNode
(
)
{
return
mPath
.
size
(
)
=
=
0
?
NULL
:
mPath
.
back
(
)
;
}
TIntermNode
*
getAncestorNode
(
unsigned
int
n
)
{
if
(
mPath
.
size
(
)
>
n
)
{
return
mPath
[
mPath
.
size
(
)
-
n
-
1u
]
;
}
return
nullptr
;
}
void
pushParentBlock
(
TIntermAggregate
*
node
)
;
void
incrementParentBlockPos
(
)
;
void
popParentBlock
(
)
;
bool
parentNodeIsBlock
(
)
{
return
!
mParentBlockStack
.
empty
(
)
&
&
getParentNode
(
)
=
=
mParentBlockStack
.
back
(
)
.
node
;
}
struct
NodeReplaceWithMultipleEntry
{
NodeReplaceWithMultipleEntry
(
TIntermAggregate
*
_parent
TIntermNode
*
_original
TIntermSequence
_replacements
)
:
parent
(
_parent
)
original
(
_original
)
replacements
(
_replacements
)
{
}
TIntermAggregate
*
parent
;
TIntermNode
*
original
;
TIntermSequence
replacements
;
}
;
struct
NodeInsertMultipleEntry
{
NodeInsertMultipleEntry
(
TIntermAggregate
*
_parent
TIntermSequence
:
:
size_type
_position
TIntermSequence
_insertionsBefore
TIntermSequence
_insertionsAfter
)
:
parent
(
_parent
)
position
(
_position
)
insertionsBefore
(
_insertionsBefore
)
insertionsAfter
(
_insertionsAfter
)
{
}
TIntermAggregate
*
parent
;
TIntermSequence
:
:
size_type
position
;
TIntermSequence
insertionsBefore
;
TIntermSequence
insertionsAfter
;
}
;
void
insertStatementsInParentBlock
(
const
TIntermSequence
&
insertions
)
;
void
insertStatementsInParentBlock
(
const
TIntermSequence
&
insertionsBefore
const
TIntermSequence
&
insertionsAfter
)
;
void
insertStatementInParentBlock
(
TIntermNode
*
statement
)
;
TIntermSymbol
*
createTempSymbol
(
const
TType
&
type
TQualifier
qualifier
)
;
TIntermSymbol
*
createTempSymbol
(
const
TType
&
type
)
;
TIntermAggregate
*
createTempDeclaration
(
const
TType
&
type
)
;
TIntermAggregate
*
createTempInitDeclaration
(
TIntermTyped
*
initializer
TQualifier
qualifier
)
;
TIntermAggregate
*
createTempInitDeclaration
(
TIntermTyped
*
initializer
)
;
TIntermBinary
*
createTempAssignment
(
TIntermTyped
*
rightNode
)
;
void
nextTemporaryIndex
(
)
;
enum
class
OriginalNode
{
BECOMES_CHILD
IS_DROPPED
}
;
void
clearReplacementQueue
(
)
;
void
queueReplacement
(
TIntermNode
*
original
TIntermNode
*
replacement
OriginalNode
originalStatus
)
;
void
queueReplacementWithParent
(
TIntermNode
*
parent
TIntermNode
*
original
TIntermNode
*
replacement
OriginalNode
originalStatus
)
;
const
bool
preVisit
;
const
bool
inVisit
;
const
bool
postVisit
;
int
mDepth
;
int
mMaxDepth
;
TVector
<
TIntermNode
*
>
mPath
;
bool
mInGlobalScope
;
std
:
:
vector
<
NodeReplaceWithMultipleEntry
>
mMultiReplacements
;
std
:
:
vector
<
NodeInsertMultipleEntry
>
mInsertions
;
private
:
struct
NodeUpdateEntry
{
NodeUpdateEntry
(
TIntermNode
*
_parent
TIntermNode
*
_original
TIntermNode
*
_replacement
bool
_originalBecomesChildOfReplacement
)
:
parent
(
_parent
)
original
(
_original
)
replacement
(
_replacement
)
originalBecomesChildOfReplacement
(
_originalBecomesChildOfReplacement
)
{
}
TIntermNode
*
parent
;
TIntermNode
*
original
;
TIntermNode
*
replacement
;
bool
originalBecomesChildOfReplacement
;
}
;
struct
ParentBlock
{
ParentBlock
(
TIntermAggregate
*
nodeIn
TIntermSequence
:
:
size_type
posIn
)
:
node
(
nodeIn
)
pos
(
posIn
)
{
}
TIntermAggregate
*
node
;
TIntermSequence
:
:
size_type
pos
;
}
;
std
:
:
vector
<
NodeUpdateEntry
>
mReplacements
;
std
:
:
vector
<
ParentBlock
>
mParentBlockStack
;
unsigned
int
*
mTemporaryIndex
;
}
;
class
TLValueTrackingTraverser
:
public
TIntermTraverser
{
public
:
TLValueTrackingTraverser
(
bool
preVisit
bool
inVisit
bool
postVisit
const
TSymbolTable
&
symbolTable
int
shaderVersion
)
:
TIntermTraverser
(
preVisit
inVisit
postVisit
)
mOperatorRequiresLValue
(
false
)
mInFunctionCallOutParameter
(
false
)
mSymbolTable
(
symbolTable
)
mShaderVersion
(
shaderVersion
)
{
}
virtual
~
TLValueTrackingTraverser
(
)
{
}
void
traverseBinary
(
TIntermBinary
*
node
)
final
;
void
traverseUnary
(
TIntermUnary
*
node
)
final
;
void
traverseAggregate
(
TIntermAggregate
*
node
)
final
;
protected
:
bool
isLValueRequiredHere
(
)
const
{
return
mOperatorRequiresLValue
|
|
mInFunctionCallOutParameter
;
}
bool
isInFunctionMap
(
const
TIntermAggregate
*
callNode
)
const
;
private
:
void
setOperatorRequiresLValue
(
bool
lValueRequired
)
{
mOperatorRequiresLValue
=
lValueRequired
;
}
bool
operatorRequiresLValue
(
)
const
{
return
mOperatorRequiresLValue
;
}
void
addToFunctionMap
(
const
TName
&
name
TIntermSequence
*
paramSequence
)
;
TIntermSequence
*
getFunctionParameters
(
const
TIntermAggregate
*
callNode
)
;
void
setInFunctionCallOutParameter
(
bool
inOutParameter
)
;
bool
isInFunctionCallOutParameter
(
)
const
;
bool
mOperatorRequiresLValue
;
bool
mInFunctionCallOutParameter
;
struct
TNameComparator
{
bool
operator
(
)
(
const
TName
&
a
const
TName
&
b
)
const
{
int
compareResult
=
a
.
getString
(
)
.
compare
(
b
.
getString
(
)
)
;
if
(
compareResult
!
=
0
)
return
compareResult
<
0
;
return
!
a
.
isInternal
(
)
&
&
b
.
isInternal
(
)
;
}
}
;
TMap
<
TName
TIntermSequence
*
TNameComparator
>
mFunctionMap
;
const
TSymbolTable
&
mSymbolTable
;
const
int
mShaderVersion
;
}
;
class
TMaxDepthTraverser
:
public
TIntermTraverser
{
public
:
POOL_ALLOCATOR_NEW_DELETE
(
)
;
TMaxDepthTraverser
(
int
depthLimit
)
:
TIntermTraverser
(
true
true
false
)
mDepthLimit
(
depthLimit
)
{
}
bool
visitBinary
(
Visit
TIntermBinary
*
)
override
{
return
depthCheck
(
)
;
}
bool
visitUnary
(
Visit
TIntermUnary
*
)
override
{
return
depthCheck
(
)
;
}
bool
visitTernary
(
Visit
TIntermTernary
*
)
override
{
return
depthCheck
(
)
;
}
bool
visitSelection
(
Visit
TIntermSelection
*
)
override
{
return
depthCheck
(
)
;
}
bool
visitAggregate
(
Visit
TIntermAggregate
*
)
override
{
return
depthCheck
(
)
;
}
bool
visitLoop
(
Visit
TIntermLoop
*
)
override
{
return
depthCheck
(
)
;
}
bool
visitBranch
(
Visit
TIntermBranch
*
)
override
{
return
depthCheck
(
)
;
}
protected
:
bool
depthCheck
(
)
const
{
return
mMaxDepth
<
mDepthLimit
;
}
int
mDepthLimit
;
}
;
#
endif
