#
ifndef
COMPILER_TRANSLATOR_INTERMNODE_H_
#
define
COMPILER_TRANSLATOR_INTERMNODE_H_
#
include
"
GLSLANG
/
ShaderLang
.
h
"
#
include
<
algorithm
>
#
include
<
queue
>
#
include
"
common
/
angleutils
.
h
"
#
include
"
compiler
/
translator
/
Common
.
h
"
#
include
"
compiler
/
translator
/
ConstantUnion
.
h
"
#
include
"
compiler
/
translator
/
Operator
.
h
"
#
include
"
compiler
/
translator
/
Types
.
h
"
namespace
sh
{
class
TDiagnostics
;
class
TIntermTraverser
;
class
TIntermAggregate
;
class
TIntermBlock
;
class
TIntermInvariantDeclaration
;
class
TIntermDeclaration
;
class
TIntermFunctionPrototype
;
class
TIntermFunctionDefinition
;
class
TIntermSwizzle
;
class
TIntermBinary
;
class
TIntermUnary
;
class
TIntermConstantUnion
;
class
TIntermTernary
;
class
TIntermIfElse
;
class
TIntermSwitch
;
class
TIntermCase
;
class
TIntermTyped
;
class
TIntermSymbol
;
class
TIntermLoop
;
class
TInfoSink
;
class
TInfoSinkBase
;
class
TIntermRaw
;
class
TIntermBranch
;
class
TSymbolTable
;
class
TSymbolUniqueId
;
class
TFunction
;
class
TName
{
public
:
POOL_ALLOCATOR_NEW_DELETE
(
)
;
explicit
TName
(
const
TString
&
name
)
:
mName
(
name
)
mIsInternal
(
false
)
{
}
TName
(
)
:
mName
(
)
mIsInternal
(
false
)
{
}
TName
(
const
TName
&
)
=
default
;
TName
&
operator
=
(
const
TName
&
)
=
default
;
const
TString
&
getString
(
)
const
{
return
mName
;
}
void
setString
(
const
TString
&
string
)
{
mName
=
string
;
}
bool
isInternal
(
)
const
{
return
mIsInternal
;
}
void
setInternal
(
bool
isInternal
)
{
mIsInternal
=
isInternal
;
}
private
:
TString
mName
;
bool
mIsInternal
;
}
;
class
TIntermNode
:
angle
:
:
NonCopyable
{
public
:
POOL_ALLOCATOR_NEW_DELETE
(
)
;
TIntermNode
(
)
{
mLine
.
first_file
=
mLine
.
last_file
=
0
;
mLine
.
first_line
=
mLine
.
last_line
=
0
;
}
virtual
~
TIntermNode
(
)
{
}
const
TSourceLoc
&
getLine
(
)
const
{
return
mLine
;
}
void
setLine
(
const
TSourceLoc
&
l
)
{
mLine
=
l
;
}
virtual
void
traverse
(
TIntermTraverser
*
)
=
0
;
virtual
TIntermTyped
*
getAsTyped
(
)
{
return
0
;
}
virtual
TIntermConstantUnion
*
getAsConstantUnion
(
)
{
return
0
;
}
virtual
TIntermFunctionDefinition
*
getAsFunctionDefinition
(
)
{
return
nullptr
;
}
virtual
TIntermAggregate
*
getAsAggregate
(
)
{
return
0
;
}
virtual
TIntermBlock
*
getAsBlock
(
)
{
return
nullptr
;
}
virtual
TIntermFunctionPrototype
*
getAsFunctionPrototypeNode
(
)
{
return
nullptr
;
}
virtual
TIntermDeclaration
*
getAsDeclarationNode
(
)
{
return
nullptr
;
}
virtual
TIntermSwizzle
*
getAsSwizzleNode
(
)
{
return
nullptr
;
}
virtual
TIntermBinary
*
getAsBinaryNode
(
)
{
return
0
;
}
virtual
TIntermUnary
*
getAsUnaryNode
(
)
{
return
0
;
}
virtual
TIntermTernary
*
getAsTernaryNode
(
)
{
return
nullptr
;
}
virtual
TIntermIfElse
*
getAsIfElseNode
(
)
{
return
nullptr
;
}
virtual
TIntermSwitch
*
getAsSwitchNode
(
)
{
return
0
;
}
virtual
TIntermCase
*
getAsCaseNode
(
)
{
return
0
;
}
virtual
TIntermSymbol
*
getAsSymbolNode
(
)
{
return
0
;
}
virtual
TIntermLoop
*
getAsLoopNode
(
)
{
return
0
;
}
virtual
TIntermRaw
*
getAsRawNode
(
)
{
return
0
;
}
virtual
TIntermBranch
*
getAsBranchNode
(
)
{
return
0
;
}
virtual
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
=
0
;
protected
:
TSourceLoc
mLine
;
}
;
struct
TIntermNodePair
{
TIntermNode
*
node1
;
TIntermNode
*
node2
;
}
;
class
TIntermTyped
:
public
TIntermNode
{
public
:
TIntermTyped
(
const
TType
&
t
)
:
mType
(
t
)
{
}
virtual
TIntermTyped
*
deepCopy
(
)
const
=
0
;
TIntermTyped
*
getAsTyped
(
)
override
{
return
this
;
}
virtual
bool
hasSideEffects
(
)
const
=
0
;
void
setType
(
const
TType
&
t
)
{
mType
=
t
;
}
void
setTypePreservePrecision
(
const
TType
&
t
)
;
const
TType
&
getType
(
)
const
{
return
mType
;
}
TType
*
getTypePointer
(
)
{
return
&
mType
;
}
TBasicType
getBasicType
(
)
const
{
return
mType
.
getBasicType
(
)
;
}
TQualifier
getQualifier
(
)
const
{
return
mType
.
getQualifier
(
)
;
}
TPrecision
getPrecision
(
)
const
{
return
mType
.
getPrecision
(
)
;
}
TMemoryQualifier
getMemoryQualifier
(
)
const
{
return
mType
.
getMemoryQualifier
(
)
;
}
int
getCols
(
)
const
{
return
mType
.
getCols
(
)
;
}
int
getRows
(
)
const
{
return
mType
.
getRows
(
)
;
}
int
getNominalSize
(
)
const
{
return
mType
.
getNominalSize
(
)
;
}
int
getSecondarySize
(
)
const
{
return
mType
.
getSecondarySize
(
)
;
}
bool
isInterfaceBlock
(
)
const
{
return
mType
.
isInterfaceBlock
(
)
;
}
bool
isMatrix
(
)
const
{
return
mType
.
isMatrix
(
)
;
}
bool
isArray
(
)
const
{
return
mType
.
isArray
(
)
;
}
bool
isVector
(
)
const
{
return
mType
.
isVector
(
)
;
}
bool
isScalar
(
)
const
{
return
mType
.
isScalar
(
)
;
}
bool
isScalarInt
(
)
const
{
return
mType
.
isScalarInt
(
)
;
}
const
char
*
getBasicString
(
)
const
{
return
mType
.
getBasicString
(
)
;
}
TString
getCompleteString
(
)
const
{
return
mType
.
getCompleteString
(
)
;
}
unsigned
int
getOutermostArraySize
(
)
const
{
return
mType
.
getOutermostArraySize
(
)
;
}
bool
isConstructorWithOnlyConstantUnionParameters
(
)
;
protected
:
TType
mType
;
TIntermTyped
(
const
TIntermTyped
&
node
)
;
}
;
enum
TLoopType
{
ELoopFor
ELoopWhile
ELoopDoWhile
}
;
class
TIntermLoop
:
public
TIntermNode
{
public
:
TIntermLoop
(
TLoopType
type
TIntermNode
*
init
TIntermTyped
*
cond
TIntermTyped
*
expr
TIntermBlock
*
body
)
;
TIntermLoop
*
getAsLoopNode
(
)
override
{
return
this
;
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
TLoopType
getType
(
)
const
{
return
mType
;
}
TIntermNode
*
getInit
(
)
{
return
mInit
;
}
TIntermTyped
*
getCondition
(
)
{
return
mCond
;
}
TIntermTyped
*
getExpression
(
)
{
return
mExpr
;
}
TIntermBlock
*
getBody
(
)
{
return
mBody
;
}
void
setCondition
(
TIntermTyped
*
condition
)
{
mCond
=
condition
;
}
void
setExpression
(
TIntermTyped
*
expression
)
{
mExpr
=
expression
;
}
void
setBody
(
TIntermBlock
*
body
)
{
mBody
=
body
;
}
protected
:
TLoopType
mType
;
TIntermNode
*
mInit
;
TIntermTyped
*
mCond
;
TIntermTyped
*
mExpr
;
TIntermBlock
*
mBody
;
}
;
class
TIntermBranch
:
public
TIntermNode
{
public
:
TIntermBranch
(
TOperator
op
TIntermTyped
*
e
)
:
mFlowOp
(
op
)
mExpression
(
e
)
{
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
TIntermBranch
*
getAsBranchNode
(
)
override
{
return
this
;
}
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
TOperator
getFlowOp
(
)
{
return
mFlowOp
;
}
TIntermTyped
*
getExpression
(
)
{
return
mExpression
;
}
protected
:
TOperator
mFlowOp
;
TIntermTyped
*
mExpression
;
}
;
class
TIntermSymbol
:
public
TIntermTyped
{
public
:
TIntermSymbol
(
int
id
const
TString
&
symbol
const
TType
&
type
)
:
TIntermTyped
(
type
)
mId
(
id
)
mSymbol
(
symbol
)
{
}
TIntermTyped
*
deepCopy
(
)
const
override
{
return
new
TIntermSymbol
(
*
this
)
;
}
bool
hasSideEffects
(
)
const
override
{
return
false
;
}
int
getId
(
)
const
{
return
mId
;
}
const
TString
&
getSymbol
(
)
const
{
return
mSymbol
.
getString
(
)
;
}
const
TName
&
getName
(
)
const
{
return
mSymbol
;
}
TName
&
getName
(
)
{
return
mSymbol
;
}
void
setInternal
(
bool
internal
)
{
mSymbol
.
setInternal
(
internal
)
;
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
TIntermSymbol
*
getAsSymbolNode
(
)
override
{
return
this
;
}
bool
replaceChildNode
(
TIntermNode
*
TIntermNode
*
)
override
{
return
false
;
}
protected
:
const
int
mId
;
TName
mSymbol
;
private
:
TIntermSymbol
(
const
TIntermSymbol
&
)
=
default
;
}
;
class
TIntermRaw
:
public
TIntermTyped
{
public
:
TIntermRaw
(
const
TType
&
type
const
TString
&
rawText
)
:
TIntermTyped
(
type
)
mRawText
(
rawText
)
{
}
TIntermRaw
(
const
TIntermRaw
&
)
=
delete
;
TIntermTyped
*
deepCopy
(
)
const
override
{
UNREACHABLE
(
)
;
return
nullptr
;
}
bool
hasSideEffects
(
)
const
override
{
return
false
;
}
TString
getRawText
(
)
const
{
return
mRawText
;
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
TIntermRaw
*
getAsRawNode
(
)
override
{
return
this
;
}
bool
replaceChildNode
(
TIntermNode
*
TIntermNode
*
)
override
{
return
false
;
}
protected
:
TString
mRawText
;
}
;
class
TIntermConstantUnion
:
public
TIntermTyped
{
public
:
TIntermConstantUnion
(
const
TConstantUnion
*
unionPointer
const
TType
&
type
)
:
TIntermTyped
(
type
)
mUnionArrayPointer
(
unionPointer
)
{
ASSERT
(
unionPointer
)
;
}
TIntermTyped
*
deepCopy
(
)
const
override
{
return
new
TIntermConstantUnion
(
*
this
)
;
}
bool
hasSideEffects
(
)
const
override
{
return
false
;
}
const
TConstantUnion
*
getUnionArrayPointer
(
)
const
{
return
mUnionArrayPointer
;
}
int
getIConst
(
size_t
index
)
const
{
return
mUnionArrayPointer
?
mUnionArrayPointer
[
index
]
.
getIConst
(
)
:
0
;
}
unsigned
int
getUConst
(
size_t
index
)
const
{
return
mUnionArrayPointer
?
mUnionArrayPointer
[
index
]
.
getUConst
(
)
:
0
;
}
float
getFConst
(
size_t
index
)
const
{
return
mUnionArrayPointer
?
mUnionArrayPointer
[
index
]
.
getFConst
(
)
:
0
.
0f
;
}
bool
getBConst
(
size_t
index
)
const
{
return
mUnionArrayPointer
?
mUnionArrayPointer
[
index
]
.
getBConst
(
)
:
false
;
}
void
replaceConstantUnion
(
const
TConstantUnion
*
safeConstantUnion
)
{
ASSERT
(
safeConstantUnion
)
;
mUnionArrayPointer
=
safeConstantUnion
;
}
TIntermConstantUnion
*
getAsConstantUnion
(
)
override
{
return
this
;
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
TIntermNode
*
)
override
{
return
false
;
}
TConstantUnion
*
foldBinary
(
TOperator
op
TIntermConstantUnion
*
rightNode
TDiagnostics
*
diagnostics
const
TSourceLoc
&
line
)
;
const
TConstantUnion
*
foldIndexing
(
int
index
)
;
TConstantUnion
*
foldUnaryNonComponentWise
(
TOperator
op
)
;
TConstantUnion
*
foldUnaryComponentWise
(
TOperator
op
TDiagnostics
*
diagnostics
)
;
static
TConstantUnion
*
FoldAggregateConstructor
(
TIntermAggregate
*
aggregate
)
;
static
TConstantUnion
*
FoldAggregateBuiltIn
(
TIntermAggregate
*
aggregate
TDiagnostics
*
diagnostics
)
;
protected
:
const
TConstantUnion
*
mUnionArrayPointer
;
private
:
typedef
float
(
*
FloatTypeUnaryFunc
)
(
float
)
;
void
foldFloatTypeUnary
(
const
TConstantUnion
&
parameter
FloatTypeUnaryFunc
builtinFunc
TConstantUnion
*
result
)
const
;
TIntermConstantUnion
(
const
TIntermConstantUnion
&
node
)
;
}
;
class
TIntermOperator
:
public
TIntermTyped
{
public
:
TOperator
getOp
(
)
const
{
return
mOp
;
}
bool
isAssignment
(
)
const
;
bool
isMultiplication
(
)
const
;
bool
isConstructor
(
)
const
;
bool
isFunctionCall
(
)
const
;
bool
hasSideEffects
(
)
const
override
{
return
isAssignment
(
)
;
}
protected
:
TIntermOperator
(
TOperator
op
)
:
TIntermTyped
(
TType
(
EbtFloat
EbpUndefined
)
)
mOp
(
op
)
{
}
TIntermOperator
(
TOperator
op
const
TType
&
type
)
:
TIntermTyped
(
type
)
mOp
(
op
)
{
}
TIntermOperator
(
const
TIntermOperator
&
)
=
default
;
const
TOperator
mOp
;
}
;
class
TIntermSwizzle
:
public
TIntermTyped
{
public
:
TIntermSwizzle
(
TIntermTyped
*
operand
const
TVector
<
int
>
&
swizzleOffsets
)
;
TIntermTyped
*
deepCopy
(
)
const
override
{
return
new
TIntermSwizzle
(
*
this
)
;
}
TIntermSwizzle
*
getAsSwizzleNode
(
)
override
{
return
this
;
}
;
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
bool
hasSideEffects
(
)
const
override
{
return
mOperand
-
>
hasSideEffects
(
)
;
}
TIntermTyped
*
getOperand
(
)
{
return
mOperand
;
}
void
writeOffsetsAsXYZW
(
TInfoSinkBase
*
out
)
const
;
bool
hasDuplicateOffsets
(
)
const
;
bool
offsetsMatch
(
int
offset
)
const
;
TIntermTyped
*
fold
(
)
;
protected
:
TIntermTyped
*
mOperand
;
TVector
<
int
>
mSwizzleOffsets
;
private
:
void
promote
(
)
;
TIntermSwizzle
(
const
TIntermSwizzle
&
node
)
;
}
;
class
TIntermBinary
:
public
TIntermOperator
{
public
:
TIntermBinary
(
TOperator
op
TIntermTyped
*
left
TIntermTyped
*
right
)
;
TIntermTyped
*
deepCopy
(
)
const
override
{
return
new
TIntermBinary
(
*
this
)
;
}
static
TOperator
GetMulOpBasedOnOperands
(
const
TType
&
left
const
TType
&
right
)
;
static
TOperator
GetMulAssignOpBasedOnOperands
(
const
TType
&
left
const
TType
&
right
)
;
static
TQualifier
GetCommaQualifier
(
int
shaderVersion
const
TIntermTyped
*
left
const
TIntermTyped
*
right
)
;
TIntermBinary
*
getAsBinaryNode
(
)
override
{
return
this
;
}
;
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
bool
hasSideEffects
(
)
const
override
{
return
isAssignment
(
)
|
|
mLeft
-
>
hasSideEffects
(
)
|
|
mRight
-
>
hasSideEffects
(
)
;
}
TIntermTyped
*
getLeft
(
)
const
{
return
mLeft
;
}
TIntermTyped
*
getRight
(
)
const
{
return
mRight
;
}
TIntermTyped
*
fold
(
TDiagnostics
*
diagnostics
)
;
void
setAddIndexClamp
(
)
{
mAddIndexClamp
=
true
;
}
bool
getAddIndexClamp
(
)
{
return
mAddIndexClamp
;
}
protected
:
TIntermTyped
*
mLeft
;
TIntermTyped
*
mRight
;
bool
mAddIndexClamp
;
private
:
void
promote
(
)
;
TIntermBinary
(
const
TIntermBinary
&
node
)
;
}
;
class
TIntermUnary
:
public
TIntermOperator
{
public
:
TIntermUnary
(
TOperator
op
TIntermTyped
*
operand
)
;
TIntermTyped
*
deepCopy
(
)
const
override
{
return
new
TIntermUnary
(
*
this
)
;
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
TIntermUnary
*
getAsUnaryNode
(
)
override
{
return
this
;
}
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
bool
hasSideEffects
(
)
const
override
{
return
isAssignment
(
)
|
|
mOperand
-
>
hasSideEffects
(
)
;
}
TIntermTyped
*
getOperand
(
)
{
return
mOperand
;
}
TIntermTyped
*
fold
(
TDiagnostics
*
diagnostics
)
;
void
setUseEmulatedFunction
(
)
{
mUseEmulatedFunction
=
true
;
}
bool
getUseEmulatedFunction
(
)
{
return
mUseEmulatedFunction
;
}
protected
:
TIntermTyped
*
mOperand
;
bool
mUseEmulatedFunction
;
private
:
void
promote
(
)
;
TIntermUnary
(
const
TIntermUnary
&
node
)
;
}
;
class
TFunctionSymbolInfo
{
public
:
POOL_ALLOCATOR_NEW_DELETE
(
)
;
TFunctionSymbolInfo
(
const
TSymbolUniqueId
&
id
)
;
TFunctionSymbolInfo
(
)
:
mId
(
nullptr
)
mKnownToNotHaveSideEffects
(
false
)
{
}
TFunctionSymbolInfo
(
const
TFunctionSymbolInfo
&
info
)
;
TFunctionSymbolInfo
&
operator
=
(
const
TFunctionSymbolInfo
&
info
)
;
void
setFromFunction
(
const
TFunction
&
function
)
;
void
setNameObj
(
const
TName
&
name
)
{
mName
=
name
;
}
const
TName
&
getNameObj
(
)
const
{
return
mName
;
}
const
TString
&
getName
(
)
const
{
return
mName
.
getString
(
)
;
}
void
setName
(
const
TString
&
name
)
{
mName
.
setString
(
name
)
;
}
bool
isMain
(
)
const
{
return
mName
.
getString
(
)
=
=
"
main
"
;
}
void
setKnownToNotHaveSideEffects
(
bool
knownToNotHaveSideEffects
)
{
mKnownToNotHaveSideEffects
=
knownToNotHaveSideEffects
;
}
bool
isKnownToNotHaveSideEffects
(
)
const
{
return
mKnownToNotHaveSideEffects
;
}
void
setId
(
const
TSymbolUniqueId
&
functionId
)
;
const
TSymbolUniqueId
&
getId
(
)
const
;
private
:
TName
mName
;
TSymbolUniqueId
*
mId
;
bool
mKnownToNotHaveSideEffects
;
}
;
typedef
TVector
<
TIntermNode
*
>
TIntermSequence
;
typedef
TVector
<
int
>
TQualifierList
;
struct
TIntermFunctionCallOrMethod
{
TIntermSequence
*
arguments
;
TIntermNode
*
thisNode
;
}
;
class
TIntermAggregateBase
{
public
:
virtual
~
TIntermAggregateBase
(
)
{
}
virtual
TIntermSequence
*
getSequence
(
)
=
0
;
virtual
const
TIntermSequence
*
getSequence
(
)
const
=
0
;
bool
replaceChildNodeWithMultiple
(
TIntermNode
*
original
const
TIntermSequence
&
replacements
)
;
bool
insertChildNodes
(
TIntermSequence
:
:
size_type
position
const
TIntermSequence
&
insertions
)
;
protected
:
TIntermAggregateBase
(
)
{
}
bool
replaceChildNodeInternal
(
TIntermNode
*
original
TIntermNode
*
replacement
)
;
}
;
class
TIntermAggregate
:
public
TIntermOperator
public
TIntermAggregateBase
{
public
:
static
TIntermAggregate
*
CreateFunctionCall
(
const
TFunction
&
func
TIntermSequence
*
arguments
)
;
static
TIntermAggregate
*
CreateFunctionCall
(
const
TType
&
type
const
TSymbolUniqueId
&
id
const
TName
&
name
TIntermSequence
*
arguments
)
;
static
TIntermAggregate
*
CreateBuiltInFunctionCall
(
const
TFunction
&
func
TIntermSequence
*
arguments
)
;
static
TIntermAggregate
*
CreateConstructor
(
const
TType
&
type
TIntermSequence
*
arguments
)
;
static
TIntermAggregate
*
Create
(
const
TType
&
type
TOperator
op
TIntermSequence
*
arguments
)
;
~
TIntermAggregate
(
)
{
}
TIntermTyped
*
deepCopy
(
)
const
override
{
return
new
TIntermAggregate
(
*
this
)
;
}
TIntermAggregate
*
shallowCopy
(
)
const
;
TIntermAggregate
*
getAsAggregate
(
)
override
{
return
this
;
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
bool
hasSideEffects
(
)
const
override
;
static
bool
CanFoldAggregateBuiltInOp
(
TOperator
op
)
;
TIntermTyped
*
fold
(
TDiagnostics
*
diagnostics
)
;
TIntermSequence
*
getSequence
(
)
override
{
return
&
mArguments
;
}
const
TIntermSequence
*
getSequence
(
)
const
override
{
return
&
mArguments
;
}
TString
getSymbolTableMangledName
(
)
const
;
void
setUseEmulatedFunction
(
)
{
mUseEmulatedFunction
=
true
;
}
bool
getUseEmulatedFunction
(
)
{
return
mUseEmulatedFunction
;
}
bool
gotPrecisionFromChildren
(
)
const
{
return
mGotPrecisionFromChildren
;
}
TFunctionSymbolInfo
*
getFunctionSymbolInfo
(
)
{
return
&
mFunctionInfo
;
}
const
TFunctionSymbolInfo
*
getFunctionSymbolInfo
(
)
const
{
return
&
mFunctionInfo
;
}
protected
:
TIntermSequence
mArguments
;
bool
mUseEmulatedFunction
;
bool
mGotPrecisionFromChildren
;
TFunctionSymbolInfo
mFunctionInfo
;
private
:
TIntermAggregate
(
const
TType
&
type
TOperator
op
TIntermSequence
*
arguments
)
;
TIntermAggregate
(
const
TIntermAggregate
&
node
)
;
void
setTypePrecisionAndQualifier
(
const
TType
&
type
)
;
bool
areChildrenConstQualified
(
)
;
void
setPrecisionFromChildren
(
)
;
void
setPrecisionForBuiltInOp
(
)
;
bool
setPrecisionForSpecialBuiltInOp
(
)
;
void
setBuiltInFunctionPrecision
(
)
;
}
;
class
TIntermBlock
:
public
TIntermNode
public
TIntermAggregateBase
{
public
:
TIntermBlock
(
)
:
TIntermNode
(
)
{
}
~
TIntermBlock
(
)
{
}
TIntermBlock
*
getAsBlock
(
)
override
{
return
this
;
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
void
appendStatement
(
TIntermNode
*
statement
)
;
TIntermSequence
*
getSequence
(
)
override
{
return
&
mStatements
;
}
const
TIntermSequence
*
getSequence
(
)
const
override
{
return
&
mStatements
;
}
protected
:
TIntermSequence
mStatements
;
}
;
class
TIntermFunctionPrototype
:
public
TIntermTyped
public
TIntermAggregateBase
{
public
:
TIntermFunctionPrototype
(
const
TType
&
type
const
TSymbolUniqueId
&
id
)
:
TIntermTyped
(
type
)
mFunctionInfo
(
id
)
{
}
~
TIntermFunctionPrototype
(
)
{
}
TIntermFunctionPrototype
*
getAsFunctionPrototypeNode
(
)
override
{
return
this
;
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
TIntermTyped
*
deepCopy
(
)
const
override
{
UNREACHABLE
(
)
;
return
nullptr
;
}
bool
hasSideEffects
(
)
const
override
{
UNREACHABLE
(
)
;
return
true
;
}
void
appendParameter
(
TIntermSymbol
*
parameter
)
;
TIntermSequence
*
getSequence
(
)
override
{
return
&
mParameters
;
}
const
TIntermSequence
*
getSequence
(
)
const
override
{
return
&
mParameters
;
}
TFunctionSymbolInfo
*
getFunctionSymbolInfo
(
)
{
return
&
mFunctionInfo
;
}
const
TFunctionSymbolInfo
*
getFunctionSymbolInfo
(
)
const
{
return
&
mFunctionInfo
;
}
protected
:
TIntermSequence
mParameters
;
TFunctionSymbolInfo
mFunctionInfo
;
}
;
class
TIntermFunctionDefinition
:
public
TIntermNode
{
public
:
TIntermFunctionDefinition
(
TIntermFunctionPrototype
*
prototype
TIntermBlock
*
body
)
:
TIntermNode
(
)
mPrototype
(
prototype
)
mBody
(
body
)
{
ASSERT
(
prototype
!
=
nullptr
)
;
ASSERT
(
body
!
=
nullptr
)
;
}
TIntermFunctionDefinition
*
getAsFunctionDefinition
(
)
override
{
return
this
;
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
TIntermFunctionPrototype
*
getFunctionPrototype
(
)
const
{
return
mPrototype
;
}
TIntermBlock
*
getBody
(
)
const
{
return
mBody
;
}
const
TFunctionSymbolInfo
*
getFunctionSymbolInfo
(
)
const
{
return
mPrototype
-
>
getFunctionSymbolInfo
(
)
;
}
private
:
TIntermFunctionPrototype
*
mPrototype
;
TIntermBlock
*
mBody
;
}
;
class
TIntermDeclaration
:
public
TIntermNode
public
TIntermAggregateBase
{
public
:
TIntermDeclaration
(
)
:
TIntermNode
(
)
{
}
~
TIntermDeclaration
(
)
{
}
TIntermDeclaration
*
getAsDeclarationNode
(
)
override
{
return
this
;
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
void
appendDeclarator
(
TIntermTyped
*
declarator
)
;
TIntermSequence
*
getSequence
(
)
override
{
return
&
mDeclarators
;
}
const
TIntermSequence
*
getSequence
(
)
const
override
{
return
&
mDeclarators
;
}
protected
:
TIntermSequence
mDeclarators
;
}
;
class
TIntermInvariantDeclaration
:
public
TIntermNode
{
public
:
TIntermInvariantDeclaration
(
TIntermSymbol
*
symbol
const
TSourceLoc
&
line
)
;
TIntermSymbol
*
getSymbol
(
)
{
return
mSymbol
;
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
private
:
TIntermSymbol
*
mSymbol
;
}
;
class
TIntermTernary
:
public
TIntermTyped
{
public
:
TIntermTernary
(
TIntermTyped
*
cond
TIntermTyped
*
trueExpression
TIntermTyped
*
falseExpression
)
;
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
TIntermTyped
*
getCondition
(
)
const
{
return
mCondition
;
}
TIntermTyped
*
getTrueExpression
(
)
const
{
return
mTrueExpression
;
}
TIntermTyped
*
getFalseExpression
(
)
const
{
return
mFalseExpression
;
}
TIntermTernary
*
getAsTernaryNode
(
)
override
{
return
this
;
}
TIntermTyped
*
deepCopy
(
)
const
override
{
return
new
TIntermTernary
(
*
this
)
;
}
bool
hasSideEffects
(
)
const
override
{
return
mCondition
-
>
hasSideEffects
(
)
|
|
mTrueExpression
-
>
hasSideEffects
(
)
|
|
mFalseExpression
-
>
hasSideEffects
(
)
;
}
TIntermTyped
*
fold
(
)
;
private
:
TIntermTernary
(
const
TIntermTernary
&
node
)
;
static
TQualifier
DetermineQualifier
(
TIntermTyped
*
cond
TIntermTyped
*
trueExpression
TIntermTyped
*
falseExpression
)
;
TIntermTyped
*
mCondition
;
TIntermTyped
*
mTrueExpression
;
TIntermTyped
*
mFalseExpression
;
}
;
class
TIntermIfElse
:
public
TIntermNode
{
public
:
TIntermIfElse
(
TIntermTyped
*
cond
TIntermBlock
*
trueB
TIntermBlock
*
falseB
)
:
TIntermNode
(
)
mCondition
(
cond
)
mTrueBlock
(
trueB
)
mFalseBlock
(
falseB
)
{
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
TIntermTyped
*
getCondition
(
)
const
{
return
mCondition
;
}
TIntermBlock
*
getTrueBlock
(
)
const
{
return
mTrueBlock
;
}
TIntermBlock
*
getFalseBlock
(
)
const
{
return
mFalseBlock
;
}
TIntermIfElse
*
getAsIfElseNode
(
)
override
{
return
this
;
}
protected
:
TIntermTyped
*
mCondition
;
TIntermBlock
*
mTrueBlock
;
TIntermBlock
*
mFalseBlock
;
}
;
class
TIntermSwitch
:
public
TIntermNode
{
public
:
TIntermSwitch
(
TIntermTyped
*
init
TIntermBlock
*
statementList
)
:
TIntermNode
(
)
mInit
(
init
)
mStatementList
(
statementList
)
{
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
TIntermSwitch
*
getAsSwitchNode
(
)
override
{
return
this
;
}
TIntermTyped
*
getInit
(
)
{
return
mInit
;
}
TIntermBlock
*
getStatementList
(
)
{
return
mStatementList
;
}
void
setStatementList
(
TIntermBlock
*
statementList
)
{
mStatementList
=
statementList
;
}
protected
:
TIntermTyped
*
mInit
;
TIntermBlock
*
mStatementList
;
}
;
class
TIntermCase
:
public
TIntermNode
{
public
:
TIntermCase
(
TIntermTyped
*
condition
)
:
TIntermNode
(
)
mCondition
(
condition
)
{
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
TIntermCase
*
getAsCaseNode
(
)
override
{
return
this
;
}
bool
hasCondition
(
)
const
{
return
mCondition
!
=
nullptr
;
}
TIntermTyped
*
getCondition
(
)
const
{
return
mCondition
;
}
protected
:
TIntermTyped
*
mCondition
;
}
;
}
#
endif
