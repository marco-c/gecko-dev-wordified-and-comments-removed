#
ifndef
COMPILER_TRANSLATOR_INTERMNODE_H_
#
define
COMPILER_TRANSLATOR_INTERMNODE_H_
#
include
"
GLSLANG
/
ShaderLang
.
h
"
#
include
<
algorithm
>
#
include
<
queue
>
#
include
"
common
/
angleutils
.
h
"
#
include
"
compiler
/
translator
/
Common
.
h
"
#
include
"
compiler
/
translator
/
ConstantUnion
.
h
"
#
include
"
compiler
/
translator
/
Operator
.
h
"
#
include
"
compiler
/
translator
/
Types
.
h
"
class
TIntermTraverser
;
class
TIntermAggregate
;
class
TIntermBinary
;
class
TIntermUnary
;
class
TIntermConstantUnion
;
class
TIntermSelection
;
class
TIntermSwitch
;
class
TIntermCase
;
class
TIntermTyped
;
class
TIntermSymbol
;
class
TIntermLoop
;
class
TInfoSink
;
class
TInfoSinkBase
;
class
TIntermRaw
;
class
TIntermNode
{
public
:
POOL_ALLOCATOR_NEW_DELETE
(
)
;
TIntermNode
(
)
{
mLine
.
first_file
=
mLine
.
last_file
=
0
;
mLine
.
first_line
=
mLine
.
last_line
=
0
;
}
virtual
~
TIntermNode
(
)
{
}
const
TSourceLoc
&
getLine
(
)
const
{
return
mLine
;
}
void
setLine
(
const
TSourceLoc
&
l
)
{
mLine
=
l
;
}
virtual
void
traverse
(
TIntermTraverser
*
)
=
0
;
virtual
TIntermTyped
*
getAsTyped
(
)
{
return
0
;
}
virtual
TIntermConstantUnion
*
getAsConstantUnion
(
)
{
return
0
;
}
virtual
TIntermAggregate
*
getAsAggregate
(
)
{
return
0
;
}
virtual
TIntermBinary
*
getAsBinaryNode
(
)
{
return
0
;
}
virtual
TIntermUnary
*
getAsUnaryNode
(
)
{
return
0
;
}
virtual
TIntermSelection
*
getAsSelectionNode
(
)
{
return
0
;
}
virtual
TIntermSwitch
*
getAsSwitchNode
(
)
{
return
0
;
}
virtual
TIntermCase
*
getAsCaseNode
(
)
{
return
0
;
}
virtual
TIntermSymbol
*
getAsSymbolNode
(
)
{
return
0
;
}
virtual
TIntermLoop
*
getAsLoopNode
(
)
{
return
0
;
}
virtual
TIntermRaw
*
getAsRawNode
(
)
{
return
0
;
}
virtual
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
=
0
;
protected
:
TSourceLoc
mLine
;
}
;
struct
TIntermNodePair
{
TIntermNode
*
node1
;
TIntermNode
*
node2
;
}
;
class
TIntermTyped
:
public
TIntermNode
{
public
:
TIntermTyped
(
const
TType
&
t
)
:
mType
(
t
)
{
}
virtual
TIntermTyped
*
getAsTyped
(
)
{
return
this
;
}
virtual
bool
hasSideEffects
(
)
const
=
0
;
void
setType
(
const
TType
&
t
)
{
mType
=
t
;
}
void
setTypePreservePrecision
(
const
TType
&
t
)
;
const
TType
&
getType
(
)
const
{
return
mType
;
}
TType
*
getTypePointer
(
)
{
return
&
mType
;
}
TBasicType
getBasicType
(
)
const
{
return
mType
.
getBasicType
(
)
;
}
TQualifier
getQualifier
(
)
const
{
return
mType
.
getQualifier
(
)
;
}
TPrecision
getPrecision
(
)
const
{
return
mType
.
getPrecision
(
)
;
}
int
getCols
(
)
const
{
return
mType
.
getCols
(
)
;
}
int
getRows
(
)
const
{
return
mType
.
getRows
(
)
;
}
int
getNominalSize
(
)
const
{
return
mType
.
getNominalSize
(
)
;
}
int
getSecondarySize
(
)
const
{
return
mType
.
getSecondarySize
(
)
;
}
bool
isInterfaceBlock
(
)
const
{
return
mType
.
isInterfaceBlock
(
)
;
}
bool
isMatrix
(
)
const
{
return
mType
.
isMatrix
(
)
;
}
bool
isArray
(
)
const
{
return
mType
.
isArray
(
)
;
}
bool
isVector
(
)
const
{
return
mType
.
isVector
(
)
;
}
bool
isScalar
(
)
const
{
return
mType
.
isScalar
(
)
;
}
bool
isScalarInt
(
)
const
{
return
mType
.
isScalarInt
(
)
;
}
const
char
*
getBasicString
(
)
const
{
return
mType
.
getBasicString
(
)
;
}
TString
getCompleteString
(
)
const
{
return
mType
.
getCompleteString
(
)
;
}
int
getArraySize
(
)
const
{
return
mType
.
getArraySize
(
)
;
}
protected
:
TType
mType
;
}
;
enum
TLoopType
{
ELoopFor
ELoopWhile
ELoopDoWhile
}
;
class
TIntermLoop
:
public
TIntermNode
{
public
:
TIntermLoop
(
TLoopType
type
TIntermNode
*
init
TIntermTyped
*
cond
TIntermTyped
*
expr
TIntermNode
*
body
)
:
mType
(
type
)
mInit
(
init
)
mCond
(
cond
)
mExpr
(
expr
)
mBody
(
body
)
mUnrollFlag
(
false
)
{
}
virtual
TIntermLoop
*
getAsLoopNode
(
)
{
return
this
;
}
virtual
void
traverse
(
TIntermTraverser
*
)
;
virtual
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
;
TLoopType
getType
(
)
const
{
return
mType
;
}
TIntermNode
*
getInit
(
)
{
return
mInit
;
}
TIntermTyped
*
getCondition
(
)
{
return
mCond
;
}
TIntermTyped
*
getExpression
(
)
{
return
mExpr
;
}
TIntermNode
*
getBody
(
)
{
return
mBody
;
}
void
setUnrollFlag
(
bool
flag
)
{
mUnrollFlag
=
flag
;
}
bool
getUnrollFlag
(
)
const
{
return
mUnrollFlag
;
}
protected
:
TLoopType
mType
;
TIntermNode
*
mInit
;
TIntermTyped
*
mCond
;
TIntermTyped
*
mExpr
;
TIntermNode
*
mBody
;
bool
mUnrollFlag
;
}
;
class
TIntermBranch
:
public
TIntermNode
{
public
:
TIntermBranch
(
TOperator
op
TIntermTyped
*
e
)
:
mFlowOp
(
op
)
mExpression
(
e
)
{
}
virtual
void
traverse
(
TIntermTraverser
*
)
;
virtual
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
;
TOperator
getFlowOp
(
)
{
return
mFlowOp
;
}
TIntermTyped
*
getExpression
(
)
{
return
mExpression
;
}
protected
:
TOperator
mFlowOp
;
TIntermTyped
*
mExpression
;
}
;
class
TIntermSymbol
:
public
TIntermTyped
{
public
:
TIntermSymbol
(
int
id
const
TString
&
symbol
const
TType
&
type
)
:
TIntermTyped
(
type
)
mId
(
id
)
mInternal
(
false
)
{
mSymbol
=
symbol
;
}
virtual
bool
hasSideEffects
(
)
const
{
return
false
;
}
int
getId
(
)
const
{
return
mId
;
}
const
TString
&
getSymbol
(
)
const
{
return
mSymbol
;
}
void
setId
(
int
newId
)
{
mId
=
newId
;
}
bool
isInternal
(
)
const
{
return
mInternal
;
}
void
setInternal
(
bool
isInternal
)
{
mInternal
=
isInternal
;
}
virtual
void
traverse
(
TIntermTraverser
*
)
;
virtual
TIntermSymbol
*
getAsSymbolNode
(
)
{
return
this
;
}
virtual
bool
replaceChildNode
(
TIntermNode
*
TIntermNode
*
)
{
return
false
;
}
protected
:
int
mId
;
bool
mInternal
;
TString
mSymbol
;
}
;
class
TIntermRaw
:
public
TIntermTyped
{
public
:
TIntermRaw
(
const
TType
&
type
const
TString
&
rawText
)
:
TIntermTyped
(
type
)
mRawText
(
rawText
)
{
}
virtual
bool
hasSideEffects
(
)
const
{
return
false
;
}
TString
getRawText
(
)
const
{
return
mRawText
;
}
virtual
void
traverse
(
TIntermTraverser
*
)
;
virtual
TIntermRaw
*
getAsRawNode
(
)
{
return
this
;
}
virtual
bool
replaceChildNode
(
TIntermNode
*
TIntermNode
*
)
{
return
false
;
}
protected
:
TString
mRawText
;
}
;
class
TIntermConstantUnion
:
public
TIntermTyped
{
public
:
TIntermConstantUnion
(
TConstantUnion
*
unionPointer
const
TType
&
type
)
:
TIntermTyped
(
type
)
mUnionArrayPointer
(
unionPointer
)
{
}
virtual
bool
hasSideEffects
(
)
const
{
return
false
;
}
const
TConstantUnion
*
getUnionArrayPointer
(
)
const
{
return
mUnionArrayPointer
;
}
TConstantUnion
*
getUnionArrayPointer
(
)
{
return
mUnionArrayPointer
;
}
int
getIConst
(
size_t
index
)
const
{
return
mUnionArrayPointer
?
mUnionArrayPointer
[
index
]
.
getIConst
(
)
:
0
;
}
unsigned
int
getUConst
(
size_t
index
)
const
{
return
mUnionArrayPointer
?
mUnionArrayPointer
[
index
]
.
getUConst
(
)
:
0
;
}
float
getFConst
(
size_t
index
)
const
{
return
mUnionArrayPointer
?
mUnionArrayPointer
[
index
]
.
getFConst
(
)
:
0
.
0f
;
}
bool
getBConst
(
size_t
index
)
const
{
return
mUnionArrayPointer
?
mUnionArrayPointer
[
index
]
.
getBConst
(
)
:
false
;
}
void
replaceConstantUnion
(
TConstantUnion
*
safeConstantUnion
)
{
mUnionArrayPointer
=
safeConstantUnion
;
}
virtual
TIntermConstantUnion
*
getAsConstantUnion
(
)
{
return
this
;
}
virtual
void
traverse
(
TIntermTraverser
*
)
;
virtual
bool
replaceChildNode
(
TIntermNode
*
TIntermNode
*
)
{
return
false
;
}
TConstantUnion
*
foldBinary
(
TOperator
op
TIntermConstantUnion
*
rightNode
TInfoSink
&
infoSink
)
;
TConstantUnion
*
foldUnaryWithDifferentReturnType
(
TOperator
op
TInfoSink
&
infoSink
)
;
TConstantUnion
*
foldUnaryWithSameReturnType
(
TOperator
op
TInfoSink
&
infoSink
)
;
static
TConstantUnion
*
FoldAggregateBuiltIn
(
TIntermAggregate
*
aggregate
TInfoSink
&
infoSink
)
;
protected
:
TConstantUnion
*
mUnionArrayPointer
;
private
:
typedef
float
(
*
FloatTypeUnaryFunc
)
(
float
)
;
bool
foldFloatTypeUnary
(
const
TConstantUnion
&
parameter
FloatTypeUnaryFunc
builtinFunc
TInfoSink
&
infoSink
TConstantUnion
*
result
)
const
;
}
;
class
TIntermOperator
:
public
TIntermTyped
{
public
:
TOperator
getOp
(
)
const
{
return
mOp
;
}
void
setOp
(
TOperator
op
)
{
mOp
=
op
;
}
bool
isAssignment
(
)
const
;
bool
isMultiplication
(
)
const
;
bool
isConstructor
(
)
const
;
virtual
bool
hasSideEffects
(
)
const
{
return
isAssignment
(
)
;
}
protected
:
TIntermOperator
(
TOperator
op
)
:
TIntermTyped
(
TType
(
EbtFloat
EbpUndefined
)
)
mOp
(
op
)
{
}
TIntermOperator
(
TOperator
op
const
TType
&
type
)
:
TIntermTyped
(
type
)
mOp
(
op
)
{
}
TOperator
mOp
;
}
;
class
TIntermBinary
:
public
TIntermOperator
{
public
:
TIntermBinary
(
TOperator
op
)
:
TIntermOperator
(
op
)
mAddIndexClamp
(
false
)
{
}
virtual
TIntermBinary
*
getAsBinaryNode
(
)
{
return
this
;
}
virtual
void
traverse
(
TIntermTraverser
*
)
;
virtual
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
;
virtual
bool
hasSideEffects
(
)
const
{
return
isAssignment
(
)
|
|
mLeft
-
>
hasSideEffects
(
)
|
|
mRight
-
>
hasSideEffects
(
)
;
}
void
setLeft
(
TIntermTyped
*
node
)
{
mLeft
=
node
;
}
void
setRight
(
TIntermTyped
*
node
)
{
mRight
=
node
;
}
TIntermTyped
*
getLeft
(
)
const
{
return
mLeft
;
}
TIntermTyped
*
getRight
(
)
const
{
return
mRight
;
}
bool
promote
(
TInfoSink
&
)
;
TIntermTyped
*
fold
(
TInfoSink
&
infoSink
)
;
void
setAddIndexClamp
(
)
{
mAddIndexClamp
=
true
;
}
bool
getAddIndexClamp
(
)
{
return
mAddIndexClamp
;
}
protected
:
TIntermTyped
*
mLeft
;
TIntermTyped
*
mRight
;
bool
mAddIndexClamp
;
}
;
class
TIntermUnary
:
public
TIntermOperator
{
public
:
TIntermUnary
(
TOperator
op
const
TType
&
type
)
:
TIntermOperator
(
op
type
)
mOperand
(
NULL
)
mUseEmulatedFunction
(
false
)
{
}
TIntermUnary
(
TOperator
op
)
:
TIntermOperator
(
op
)
mOperand
(
NULL
)
mUseEmulatedFunction
(
false
)
{
}
virtual
void
traverse
(
TIntermTraverser
*
)
;
virtual
TIntermUnary
*
getAsUnaryNode
(
)
{
return
this
;
}
virtual
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
;
virtual
bool
hasSideEffects
(
)
const
{
return
isAssignment
(
)
|
|
mOperand
-
>
hasSideEffects
(
)
;
}
void
setOperand
(
TIntermTyped
*
operand
)
{
mOperand
=
operand
;
}
TIntermTyped
*
getOperand
(
)
{
return
mOperand
;
}
void
promote
(
const
TType
*
funcReturnType
)
;
TIntermTyped
*
fold
(
TInfoSink
&
infoSink
)
;
void
setUseEmulatedFunction
(
)
{
mUseEmulatedFunction
=
true
;
}
bool
getUseEmulatedFunction
(
)
{
return
mUseEmulatedFunction
;
}
protected
:
TIntermTyped
*
mOperand
;
bool
mUseEmulatedFunction
;
}
;
typedef
TVector
<
TIntermNode
*
>
TIntermSequence
;
typedef
TVector
<
int
>
TQualifierList
;
class
TIntermAggregate
:
public
TIntermOperator
{
public
:
TIntermAggregate
(
)
:
TIntermOperator
(
EOpNull
)
mUserDefined
(
false
)
mUseEmulatedFunction
(
false
)
mGotPrecisionFromChildren
(
false
)
{
}
TIntermAggregate
(
TOperator
op
)
:
TIntermOperator
(
op
)
mUseEmulatedFunction
(
false
)
mGotPrecisionFromChildren
(
false
)
{
}
~
TIntermAggregate
(
)
{
}
virtual
TIntermAggregate
*
getAsAggregate
(
)
{
return
this
;
}
virtual
void
traverse
(
TIntermTraverser
*
)
;
virtual
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
;
bool
replaceChildNodeWithMultiple
(
TIntermNode
*
original
TIntermSequence
replacements
)
;
bool
insertChildNodes
(
TIntermSequence
:
:
size_type
position
TIntermSequence
insertions
)
;
virtual
bool
hasSideEffects
(
)
const
{
return
true
;
}
TIntermTyped
*
fold
(
TInfoSink
&
infoSink
)
;
TIntermSequence
*
getSequence
(
)
{
return
&
mSequence
;
}
void
setName
(
const
TString
&
name
)
{
mName
=
name
;
}
const
TString
&
getName
(
)
const
{
return
mName
;
}
void
setUserDefined
(
)
{
mUserDefined
=
true
;
}
bool
isUserDefined
(
)
const
{
return
mUserDefined
;
}
void
setOptimize
(
bool
optimize
)
{
mOptimize
=
optimize
;
}
bool
getOptimize
(
)
const
{
return
mOptimize
;
}
void
setDebug
(
bool
debug
)
{
mDebug
=
debug
;
}
bool
getDebug
(
)
const
{
return
mDebug
;
}
void
setFunctionId
(
int
functionId
)
{
mFunctionId
=
functionId
;
}
int
getFunctionId
(
)
const
{
return
mFunctionId
;
}
void
setUseEmulatedFunction
(
)
{
mUseEmulatedFunction
=
true
;
}
bool
getUseEmulatedFunction
(
)
{
return
mUseEmulatedFunction
;
}
void
setPrecisionFromChildren
(
)
;
void
setBuiltInFunctionPrecision
(
)
;
bool
gotPrecisionFromChildren
(
)
const
{
return
mGotPrecisionFromChildren
;
}
protected
:
TIntermAggregate
(
const
TIntermAggregate
&
)
;
TIntermAggregate
&
operator
=
(
const
TIntermAggregate
&
)
;
TIntermSequence
mSequence
;
TString
mName
;
bool
mUserDefined
;
int
mFunctionId
;
bool
mOptimize
;
bool
mDebug
;
bool
mUseEmulatedFunction
;
bool
mGotPrecisionFromChildren
;
}
;
class
TIntermSelection
:
public
TIntermTyped
{
public
:
TIntermSelection
(
TIntermTyped
*
cond
TIntermNode
*
trueB
TIntermNode
*
falseB
)
:
TIntermTyped
(
TType
(
EbtVoid
EbpUndefined
)
)
mCondition
(
cond
)
mTrueBlock
(
trueB
)
mFalseBlock
(
falseB
)
{
}
TIntermSelection
(
TIntermTyped
*
cond
TIntermNode
*
trueB
TIntermNode
*
falseB
const
TType
&
type
)
:
TIntermTyped
(
type
)
mCondition
(
cond
)
mTrueBlock
(
trueB
)
mFalseBlock
(
falseB
)
{
}
virtual
void
traverse
(
TIntermTraverser
*
)
;
virtual
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
;
virtual
bool
hasSideEffects
(
)
const
{
return
true
;
}
bool
usesTernaryOperator
(
)
const
{
return
getBasicType
(
)
!
=
EbtVoid
;
}
TIntermNode
*
getCondition
(
)
const
{
return
mCondition
;
}
TIntermNode
*
getTrueBlock
(
)
const
{
return
mTrueBlock
;
}
TIntermNode
*
getFalseBlock
(
)
const
{
return
mFalseBlock
;
}
TIntermSelection
*
getAsSelectionNode
(
)
{
return
this
;
}
protected
:
TIntermTyped
*
mCondition
;
TIntermNode
*
mTrueBlock
;
TIntermNode
*
mFalseBlock
;
}
;
class
TIntermSwitch
:
public
TIntermNode
{
public
:
TIntermSwitch
(
TIntermTyped
*
init
TIntermAggregate
*
statementList
)
:
TIntermNode
(
)
mInit
(
init
)
mStatementList
(
statementList
)
{
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
TIntermSwitch
*
getAsSwitchNode
(
)
override
{
return
this
;
}
TIntermAggregate
*
getStatementList
(
)
{
return
mStatementList
;
}
void
setStatementList
(
TIntermAggregate
*
statementList
)
{
mStatementList
=
statementList
;
}
protected
:
TIntermTyped
*
mInit
;
TIntermAggregate
*
mStatementList
;
}
;
class
TIntermCase
:
public
TIntermNode
{
public
:
TIntermCase
(
TIntermTyped
*
condition
)
:
TIntermNode
(
)
mCondition
(
condition
)
{
}
void
traverse
(
TIntermTraverser
*
it
)
override
;
bool
replaceChildNode
(
TIntermNode
*
original
TIntermNode
*
replacement
)
override
;
TIntermCase
*
getAsCaseNode
(
)
override
{
return
this
;
}
bool
hasCondition
(
)
const
{
return
mCondition
!
=
nullptr
;
}
TIntermTyped
*
getCondition
(
)
const
{
return
mCondition
;
}
protected
:
TIntermTyped
*
mCondition
;
}
;
enum
Visit
{
PreVisit
InVisit
PostVisit
}
;
class
TIntermTraverser
:
angle
:
:
NonCopyable
{
public
:
POOL_ALLOCATOR_NEW_DELETE
(
)
;
TIntermTraverser
(
bool
preVisit
bool
inVisit
bool
postVisit
)
:
preVisit
(
preVisit
)
inVisit
(
inVisit
)
postVisit
(
postVisit
)
mDepth
(
0
)
mMaxDepth
(
0
)
mTemporaryIndex
(
nullptr
)
{
}
virtual
~
TIntermTraverser
(
)
{
}
virtual
void
visitSymbol
(
TIntermSymbol
*
)
{
}
virtual
void
visitRaw
(
TIntermRaw
*
)
{
}
virtual
void
visitConstantUnion
(
TIntermConstantUnion
*
)
{
}
virtual
bool
visitBinary
(
Visit
TIntermBinary
*
)
{
return
true
;
}
virtual
bool
visitUnary
(
Visit
TIntermUnary
*
)
{
return
true
;
}
virtual
bool
visitSelection
(
Visit
TIntermSelection
*
)
{
return
true
;
}
virtual
bool
visitSwitch
(
Visit
TIntermSwitch
*
)
{
return
true
;
}
virtual
bool
visitCase
(
Visit
TIntermCase
*
)
{
return
true
;
}
virtual
bool
visitAggregate
(
Visit
TIntermAggregate
*
)
{
return
true
;
}
virtual
bool
visitLoop
(
Visit
TIntermLoop
*
)
{
return
true
;
}
virtual
bool
visitBranch
(
Visit
TIntermBranch
*
)
{
return
true
;
}
int
getMaxDepth
(
)
const
{
return
mMaxDepth
;
}
void
incrementDepth
(
TIntermNode
*
current
)
{
mDepth
+
+
;
mMaxDepth
=
std
:
:
max
(
mMaxDepth
mDepth
)
;
mPath
.
push_back
(
current
)
;
}
void
decrementDepth
(
)
{
mDepth
-
-
;
mPath
.
pop_back
(
)
;
}
TIntermNode
*
getParentNode
(
)
{
return
mPath
.
size
(
)
=
=
0
?
NULL
:
mPath
.
back
(
)
;
}
void
pushParentBlock
(
TIntermAggregate
*
node
)
;
void
incrementParentBlockPos
(
)
;
void
popParentBlock
(
)
;
bool
parentNodeIsBlock
(
)
{
return
!
mParentBlockStack
.
empty
(
)
&
&
getParentNode
(
)
=
=
mParentBlockStack
.
back
(
)
.
node
;
}
static
TString
hash
(
const
TString
&
name
ShHashFunction64
hashFunction
)
;
const
bool
preVisit
;
const
bool
inVisit
;
const
bool
postVisit
;
void
updateTree
(
)
;
void
useTemporaryIndex
(
unsigned
int
*
temporaryIndex
)
;
protected
:
int
mDepth
;
int
mMaxDepth
;
TVector
<
TIntermNode
*
>
mPath
;
struct
NodeUpdateEntry
{
NodeUpdateEntry
(
TIntermNode
*
_parent
TIntermNode
*
_original
TIntermNode
*
_replacement
bool
_originalBecomesChildOfReplacement
)
:
parent
(
_parent
)
original
(
_original
)
replacement
(
_replacement
)
originalBecomesChildOfReplacement
(
_originalBecomesChildOfReplacement
)
{
}
TIntermNode
*
parent
;
TIntermNode
*
original
;
TIntermNode
*
replacement
;
bool
originalBecomesChildOfReplacement
;
}
;
struct
NodeReplaceWithMultipleEntry
{
NodeReplaceWithMultipleEntry
(
TIntermAggregate
*
_parent
TIntermNode
*
_original
TIntermSequence
_replacements
)
:
parent
(
_parent
)
original
(
_original
)
replacements
(
_replacements
)
{
}
TIntermAggregate
*
parent
;
TIntermNode
*
original
;
TIntermSequence
replacements
;
}
;
struct
NodeInsertMultipleEntry
{
NodeInsertMultipleEntry
(
TIntermAggregate
*
_parent
TIntermSequence
:
:
size_type
_position
TIntermSequence
_insertions
)
:
parent
(
_parent
)
position
(
_position
)
insertions
(
_insertions
)
{
}
TIntermAggregate
*
parent
;
TIntermSequence
:
:
size_type
position
;
TIntermSequence
insertions
;
}
;
std
:
:
vector
<
NodeUpdateEntry
>
mReplacements
;
std
:
:
vector
<
NodeReplaceWithMultipleEntry
>
mMultiReplacements
;
std
:
:
vector
<
NodeInsertMultipleEntry
>
mInsertions
;
void
insertStatementsInParentBlock
(
const
TIntermSequence
&
insertions
)
;
TIntermSymbol
*
createTempSymbol
(
const
TType
&
type
TQualifier
qualifier
)
;
TIntermSymbol
*
createTempSymbol
(
const
TType
&
type
)
;
TIntermAggregate
*
createTempDeclaration
(
const
TType
&
type
)
;
TIntermAggregate
*
createTempInitDeclaration
(
TIntermTyped
*
initializer
TQualifier
qualifier
)
;
TIntermAggregate
*
createTempInitDeclaration
(
TIntermTyped
*
initializer
)
;
TIntermBinary
*
createTempAssignment
(
TIntermTyped
*
rightNode
)
;
void
nextTemporaryIndex
(
)
;
private
:
struct
ParentBlock
{
ParentBlock
(
TIntermAggregate
*
nodeIn
TIntermSequence
:
:
size_type
posIn
)
:
node
(
nodeIn
)
pos
(
posIn
)
{
}
TIntermAggregate
*
node
;
TIntermSequence
:
:
size_type
pos
;
}
;
std
:
:
vector
<
ParentBlock
>
mParentBlockStack
;
unsigned
int
*
mTemporaryIndex
;
}
;
class
TMaxDepthTraverser
:
public
TIntermTraverser
{
public
:
POOL_ALLOCATOR_NEW_DELETE
(
)
;
TMaxDepthTraverser
(
int
depthLimit
)
:
TIntermTraverser
(
true
true
false
)
mDepthLimit
(
depthLimit
)
{
}
virtual
bool
visitBinary
(
Visit
TIntermBinary
*
)
{
return
depthCheck
(
)
;
}
virtual
bool
visitUnary
(
Visit
TIntermUnary
*
)
{
return
depthCheck
(
)
;
}
virtual
bool
visitSelection
(
Visit
TIntermSelection
*
)
{
return
depthCheck
(
)
;
}
virtual
bool
visitAggregate
(
Visit
TIntermAggregate
*
)
{
return
depthCheck
(
)
;
}
virtual
bool
visitLoop
(
Visit
TIntermLoop
*
)
{
return
depthCheck
(
)
;
}
virtual
bool
visitBranch
(
Visit
TIntermBranch
*
)
{
return
depthCheck
(
)
;
}
protected
:
bool
depthCheck
(
)
const
{
return
mMaxDepth
<
mDepthLimit
;
}
int
mDepthLimit
;
}
;
#
endif
