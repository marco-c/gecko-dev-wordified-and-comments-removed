#
ifndef
COMPILER_TRANSLATOR_SYMBOLTABLE_H_
#
define
COMPILER_TRANSLATOR_SYMBOLTABLE_H_
#
include
<
array
>
#
include
<
assert
.
h
>
#
include
<
set
>
#
include
"
common
/
angleutils
.
h
"
#
include
"
compiler
/
translator
/
InfoSink
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
class
TSymbol
:
angle
:
:
NonCopyable
{
public
:
POOL_ALLOCATOR_NEW_DELETE
(
)
;
TSymbol
(
const
TString
*
n
)
:
uniqueId
(
0
)
name
(
n
)
{
}
virtual
~
TSymbol
(
)
{
}
const
TString
&
getName
(
)
const
{
return
*
name
;
}
virtual
const
TString
&
getMangledName
(
)
const
{
return
getName
(
)
;
}
virtual
bool
isFunction
(
)
const
{
return
false
;
}
virtual
bool
isVariable
(
)
const
{
return
false
;
}
void
setUniqueId
(
int
id
)
{
uniqueId
=
id
;
}
int
getUniqueId
(
)
const
{
return
uniqueId
;
}
void
relateToExtension
(
const
TString
&
ext
)
{
extension
=
ext
;
}
const
TString
&
getExtension
(
)
const
{
return
extension
;
}
private
:
int
uniqueId
;
const
TString
*
name
;
TString
extension
;
}
;
class
TVariable
:
public
TSymbol
{
public
:
TVariable
(
const
TString
*
name
const
TType
&
t
bool
uT
=
false
)
:
TSymbol
(
name
)
type
(
t
)
userType
(
uT
)
unionArray
(
0
)
{
}
~
TVariable
(
)
override
{
}
bool
isVariable
(
)
const
override
{
return
true
;
}
TType
&
getType
(
)
{
return
type
;
}
const
TType
&
getType
(
)
const
{
return
type
;
}
bool
isUserType
(
)
const
{
return
userType
;
}
void
setQualifier
(
TQualifier
qualifier
)
{
type
.
setQualifier
(
qualifier
)
;
}
const
TConstantUnion
*
getConstPointer
(
)
const
{
return
unionArray
;
}
void
shareConstPointer
(
const
TConstantUnion
*
constArray
)
{
unionArray
=
constArray
;
}
private
:
TType
type
;
bool
userType
;
const
TConstantUnion
*
unionArray
;
}
;
struct
TConstParameter
{
TConstParameter
(
)
:
name
(
nullptr
)
type
(
nullptr
)
{
}
explicit
TConstParameter
(
const
TString
*
n
)
:
name
(
n
)
type
(
nullptr
)
{
}
explicit
TConstParameter
(
const
TType
*
t
)
:
name
(
nullptr
)
type
(
t
)
{
}
TConstParameter
(
const
TString
*
n
const
TType
*
t
)
:
name
(
n
)
type
(
t
)
{
}
TConstParameter
(
TString
*
n
TType
*
t
)
=
delete
;
TConstParameter
(
const
TString
*
n
TType
*
t
)
=
delete
;
TConstParameter
(
TString
*
n
const
TType
*
t
)
=
delete
;
const
TString
*
name
;
const
TType
*
type
;
}
;
struct
TParameter
{
TConstParameter
turnToConst
(
)
{
const
TString
*
constName
=
name
;
const
TType
*
constType
=
type
;
name
=
nullptr
;
type
=
nullptr
;
return
TConstParameter
(
constName
constType
)
;
}
TString
*
name
;
TType
*
type
;
}
;
class
TFunction
:
public
TSymbol
{
public
:
TFunction
(
const
TString
*
name
const
TType
*
retType
TOperator
tOp
=
EOpNull
const
char
*
ext
=
"
"
)
:
TSymbol
(
name
)
returnType
(
retType
)
mangledName
(
nullptr
)
op
(
tOp
)
defined
(
false
)
mHasPrototypeDeclaration
(
false
)
{
relateToExtension
(
ext
)
;
}
~
TFunction
(
)
override
;
bool
isFunction
(
)
const
override
{
return
true
;
}
static
TString
mangleName
(
const
TString
&
name
)
{
return
name
+
'
(
'
;
}
static
TString
unmangleName
(
const
TString
&
mangledName
)
{
return
TString
(
mangledName
.
c_str
(
)
mangledName
.
find_first_of
(
'
(
'
)
)
;
}
void
addParameter
(
const
TConstParameter
&
p
)
{
parameters
.
push_back
(
p
)
;
mangledName
=
nullptr
;
}
const
TString
&
getMangledName
(
)
const
override
{
if
(
mangledName
=
=
nullptr
)
{
mangledName
=
buildMangledName
(
)
;
}
return
*
mangledName
;
}
const
TType
&
getReturnType
(
)
const
{
return
*
returnType
;
}
TOperator
getBuiltInOp
(
)
const
{
return
op
;
}
void
setDefined
(
)
{
defined
=
true
;
}
bool
isDefined
(
)
{
return
defined
;
}
void
setHasPrototypeDeclaration
(
)
{
mHasPrototypeDeclaration
=
true
;
}
bool
hasPrototypeDeclaration
(
)
const
{
return
mHasPrototypeDeclaration
;
}
size_t
getParamCount
(
)
const
{
return
parameters
.
size
(
)
;
}
const
TConstParameter
&
getParam
(
size_t
i
)
const
{
return
parameters
[
i
]
;
}
private
:
const
TString
*
buildMangledName
(
)
const
;
typedef
TVector
<
TConstParameter
>
TParamList
;
TParamList
parameters
;
const
TType
*
returnType
;
mutable
const
TString
*
mangledName
;
TOperator
op
;
bool
defined
;
bool
mHasPrototypeDeclaration
;
}
;
class
TInterfaceBlockName
:
public
TSymbol
{
public
:
TInterfaceBlockName
(
const
TString
*
name
)
:
TSymbol
(
name
)
{
}
virtual
~
TInterfaceBlockName
(
)
{
}
}
;
class
TSymbolTableLevel
{
public
:
typedef
TMap
<
TString
TSymbol
*
>
tLevel
;
typedef
tLevel
:
:
const_iterator
const_iterator
;
typedef
const
tLevel
:
:
value_type
tLevelPair
;
typedef
std
:
:
pair
<
tLevel
:
:
iterator
bool
>
tInsertResult
;
TSymbolTableLevel
(
)
:
mGlobalInvariant
(
false
)
{
}
~
TSymbolTableLevel
(
)
;
bool
insert
(
TSymbol
*
symbol
)
;
bool
insertUnmangled
(
TFunction
*
function
)
;
TSymbol
*
find
(
const
TString
&
name
)
const
;
void
addInvariantVarying
(
const
std
:
:
string
&
name
)
{
mInvariantVaryings
.
insert
(
name
)
;
}
bool
isVaryingInvariant
(
const
std
:
:
string
&
name
)
{
return
(
mGlobalInvariant
|
|
mInvariantVaryings
.
count
(
name
)
>
0
)
;
}
void
setGlobalInvariant
(
bool
invariant
)
{
mGlobalInvariant
=
invariant
;
}
protected
:
tLevel
level
;
std
:
:
set
<
std
:
:
string
>
mInvariantVaryings
;
bool
mGlobalInvariant
;
}
;
typedef
int
ESymbolLevel
;
const
int
COMMON_BUILTINS
=
0
;
const
int
ESSL1_BUILTINS
=
1
;
const
int
ESSL3_BUILTINS
=
2
;
const
int
ESSL3_1_BUILTINS
=
3
;
const
int
LAST_BUILTIN_LEVEL
=
ESSL3_1_BUILTINS
;
const
int
GLOBAL_LEVEL
=
4
;
class
TSymbolTable
:
angle
:
:
NonCopyable
{
public
:
TSymbolTable
(
)
{
}
~
TSymbolTable
(
)
;
bool
isEmpty
(
)
const
{
return
table
.
empty
(
)
;
}
bool
atBuiltInLevel
(
)
const
{
return
currentLevel
(
)
<
=
LAST_BUILTIN_LEVEL
;
}
bool
atGlobalLevel
(
)
const
{
return
currentLevel
(
)
=
=
GLOBAL_LEVEL
;
}
void
push
(
)
{
table
.
push_back
(
new
TSymbolTableLevel
)
;
precisionStack
.
push_back
(
new
PrecisionStackLevel
)
;
}
void
pop
(
)
{
delete
table
.
back
(
)
;
table
.
pop_back
(
)
;
delete
precisionStack
.
back
(
)
;
precisionStack
.
pop_back
(
)
;
}
bool
declare
(
TSymbol
*
symbol
)
{
return
insert
(
currentLevel
(
)
symbol
)
;
}
bool
insert
(
ESymbolLevel
level
TSymbol
*
symbol
)
{
return
table
[
level
]
-
>
insert
(
symbol
)
;
}
bool
insert
(
ESymbolLevel
level
const
char
*
ext
TSymbol
*
symbol
)
{
symbol
-
>
relateToExtension
(
ext
)
;
return
table
[
level
]
-
>
insert
(
symbol
)
;
}
bool
insertConstInt
(
ESymbolLevel
level
const
char
*
name
int
value
TPrecision
precision
)
{
TVariable
*
constant
=
new
TVariable
(
NewPoolTString
(
name
)
TType
(
EbtInt
precision
EvqConst
1
)
)
;
TConstantUnion
*
unionArray
=
new
TConstantUnion
[
1
]
;
unionArray
[
0
]
.
setIConst
(
value
)
;
constant
-
>
shareConstPointer
(
unionArray
)
;
return
insert
(
level
constant
)
;
}
bool
insertConstIntExt
(
ESymbolLevel
level
const
char
*
ext
const
char
*
name
int
value
)
{
TVariable
*
constant
=
new
TVariable
(
NewPoolTString
(
name
)
TType
(
EbtInt
EbpUndefined
EvqConst
1
)
)
;
TConstantUnion
*
unionArray
=
new
TConstantUnion
[
1
]
;
unionArray
[
0
]
.
setIConst
(
value
)
;
constant
-
>
shareConstPointer
(
unionArray
)
;
return
insert
(
level
ext
constant
)
;
}
bool
insertConstIvec3
(
ESymbolLevel
level
const
char
*
name
const
std
:
:
array
<
int
3
>
&
values
TPrecision
precision
)
{
TVariable
*
constantIvec3
=
new
TVariable
(
NewPoolTString
(
name
)
TType
(
EbtInt
precision
EvqConst
3
)
)
;
TConstantUnion
*
unionArray
=
new
TConstantUnion
[
3
]
;
for
(
size_t
index
=
0u
;
index
<
3u
;
+
+
index
)
{
unionArray
[
index
]
.
setIConst
(
values
[
index
]
)
;
}
constantIvec3
-
>
shareConstPointer
(
unionArray
)
;
return
insert
(
level
constantIvec3
)
;
}
void
insertBuiltIn
(
ESymbolLevel
level
TOperator
op
const
char
*
ext
const
TType
*
rvalue
const
char
*
name
const
TType
*
ptype1
const
TType
*
ptype2
=
0
const
TType
*
ptype3
=
0
const
TType
*
ptype4
=
0
const
TType
*
ptype5
=
0
)
;
void
insertBuiltIn
(
ESymbolLevel
level
const
TType
*
rvalue
const
char
*
name
const
TType
*
ptype1
const
TType
*
ptype2
=
0
const
TType
*
ptype3
=
0
const
TType
*
ptype4
=
0
const
TType
*
ptype5
=
0
)
{
insertUnmangledBuiltIn
(
name
)
;
insertBuiltIn
(
level
EOpNull
"
"
rvalue
name
ptype1
ptype2
ptype3
ptype4
ptype5
)
;
}
void
insertBuiltIn
(
ESymbolLevel
level
const
char
*
ext
const
TType
*
rvalue
const
char
*
name
const
TType
*
ptype1
const
TType
*
ptype2
=
0
const
TType
*
ptype3
=
0
const
TType
*
ptype4
=
0
const
TType
*
ptype5
=
0
)
{
insertUnmangledBuiltIn
(
name
)
;
insertBuiltIn
(
level
EOpNull
ext
rvalue
name
ptype1
ptype2
ptype3
ptype4
ptype5
)
;
}
void
insertBuiltIn
(
ESymbolLevel
level
TOperator
op
const
TType
*
rvalue
const
char
*
name
const
TType
*
ptype1
const
TType
*
ptype2
=
0
const
TType
*
ptype3
=
0
const
TType
*
ptype4
=
0
const
TType
*
ptype5
=
0
)
{
insertUnmangledBuiltIn
(
name
)
;
insertBuiltIn
(
level
op
"
"
rvalue
name
ptype1
ptype2
ptype3
ptype4
ptype5
)
;
}
TSymbol
*
find
(
const
TString
&
name
int
shaderVersion
bool
*
builtIn
=
NULL
bool
*
sameScope
=
NULL
)
const
;
TSymbol
*
findBuiltIn
(
const
TString
&
name
int
shaderVersion
)
const
;
TSymbolTableLevel
*
getOuterLevel
(
)
{
assert
(
currentLevel
(
)
>
=
1
)
;
return
table
[
currentLevel
(
)
-
1
]
;
}
void
dump
(
TInfoSink
&
infoSink
)
const
;
bool
setDefaultPrecision
(
const
TPublicType
&
type
TPrecision
prec
)
{
if
(
!
SupportsPrecision
(
type
.
type
)
)
return
false
;
if
(
type
.
type
=
=
EbtUInt
)
return
false
;
if
(
type
.
isAggregate
(
)
)
return
false
;
int
indexOfLastElement
=
static_cast
<
int
>
(
precisionStack
.
size
(
)
)
-
1
;
(
*
precisionStack
[
indexOfLastElement
]
)
[
type
.
type
]
=
prec
;
return
true
;
}
TPrecision
getDefaultPrecision
(
TBasicType
type
)
const
;
void
addInvariantVarying
(
const
std
:
:
string
&
originalName
)
{
ASSERT
(
atGlobalLevel
(
)
)
;
table
[
currentLevel
(
)
]
-
>
addInvariantVarying
(
originalName
)
;
}
bool
isVaryingInvariant
(
const
std
:
:
string
&
originalName
)
const
{
ASSERT
(
atGlobalLevel
(
)
)
;
return
table
[
currentLevel
(
)
]
-
>
isVaryingInvariant
(
originalName
)
;
}
void
setGlobalInvariant
(
bool
invariant
)
{
ASSERT
(
atGlobalLevel
(
)
)
;
table
[
currentLevel
(
)
]
-
>
setGlobalInvariant
(
invariant
)
;
}
static
int
nextUniqueId
(
)
{
return
+
+
uniqueIdCounter
;
}
bool
hasUnmangledBuiltIn
(
const
char
*
name
)
{
return
mUnmangledBuiltinNames
.
count
(
std
:
:
string
(
name
)
)
>
0
;
}
private
:
ESymbolLevel
currentLevel
(
)
const
{
return
static_cast
<
ESymbolLevel
>
(
table
.
size
(
)
-
1
)
;
}
void
insertUnmangledBuiltIn
(
const
char
*
name
)
{
mUnmangledBuiltinNames
.
insert
(
std
:
:
string
(
name
)
)
;
}
std
:
:
vector
<
TSymbolTableLevel
*
>
table
;
typedef
TMap
<
TBasicType
TPrecision
>
PrecisionStackLevel
;
std
:
:
vector
<
PrecisionStackLevel
*
>
precisionStack
;
std
:
:
set
<
std
:
:
string
>
mUnmangledBuiltinNames
;
static
int
uniqueIdCounter
;
}
;
#
endif
