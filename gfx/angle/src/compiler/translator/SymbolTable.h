#
ifndef
COMPILER_TRANSLATOR_SYMBOLTABLE_H_
#
define
COMPILER_TRANSLATOR_SYMBOLTABLE_H_
#
include
<
array
>
#
include
<
assert
.
h
>
#
include
<
set
>
#
include
"
common
/
angleutils
.
h
"
#
include
"
compiler
/
translator
/
ExtensionBehavior
.
h
"
#
include
"
compiler
/
translator
/
InfoSink
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
namespace
sh
{
class
TSymbolUniqueId
{
public
:
POOL_ALLOCATOR_NEW_DELETE
(
)
;
TSymbolUniqueId
(
TSymbolTable
*
symbolTable
)
;
TSymbolUniqueId
(
const
TSymbol
&
symbol
)
;
TSymbolUniqueId
(
const
TSymbolUniqueId
&
)
=
default
;
TSymbolUniqueId
&
operator
=
(
const
TSymbolUniqueId
&
)
=
default
;
int
get
(
)
const
;
private
:
int
mId
;
}
;
class
TSymbol
:
angle
:
:
NonCopyable
{
public
:
POOL_ALLOCATOR_NEW_DELETE
(
)
;
TSymbol
(
TSymbolTable
*
symbolTable
const
TString
*
n
)
;
virtual
~
TSymbol
(
)
{
}
const
TString
&
getName
(
)
const
{
return
*
name
;
}
virtual
const
TString
&
getMangledName
(
)
const
{
return
getName
(
)
;
}
virtual
bool
isFunction
(
)
const
{
return
false
;
}
virtual
bool
isVariable
(
)
const
{
return
false
;
}
int
getUniqueId
(
)
const
{
return
uniqueId
;
}
void
relateToExtension
(
TExtension
ext
)
{
extension
=
ext
;
}
TExtension
getExtension
(
)
const
{
return
extension
;
}
private
:
const
int
uniqueId
;
const
TString
*
name
;
TExtension
extension
;
}
;
class
TVariable
:
public
TSymbol
{
public
:
~
TVariable
(
)
override
{
}
bool
isVariable
(
)
const
override
{
return
true
;
}
TType
&
getType
(
)
{
return
type
;
}
const
TType
&
getType
(
)
const
{
return
type
;
}
bool
isUserType
(
)
const
{
return
userType
;
}
void
setQualifier
(
TQualifier
qualifier
)
{
type
.
setQualifier
(
qualifier
)
;
}
const
TConstantUnion
*
getConstPointer
(
)
const
{
return
unionArray
;
}
void
shareConstPointer
(
const
TConstantUnion
*
constArray
)
{
unionArray
=
constArray
;
}
private
:
friend
class
TSymbolTable
;
TVariable
(
TSymbolTable
*
symbolTable
const
TString
*
name
const
TType
&
t
bool
isUserTypeDefinition
=
false
)
:
TSymbol
(
symbolTable
name
)
type
(
t
)
userType
(
isUserTypeDefinition
)
unionArray
(
0
)
{
}
TType
type
;
bool
userType
;
const
TConstantUnion
*
unionArray
;
}
;
struct
TConstParameter
{
TConstParameter
(
)
:
name
(
nullptr
)
type
(
nullptr
)
{
}
explicit
TConstParameter
(
const
TString
*
n
)
:
name
(
n
)
type
(
nullptr
)
{
}
explicit
TConstParameter
(
const
TType
*
t
)
:
name
(
nullptr
)
type
(
t
)
{
}
TConstParameter
(
const
TString
*
n
const
TType
*
t
)
:
name
(
n
)
type
(
t
)
{
}
TConstParameter
(
TString
*
n
TType
*
t
)
=
delete
;
TConstParameter
(
const
TString
*
n
TType
*
t
)
=
delete
;
TConstParameter
(
TString
*
n
const
TType
*
t
)
=
delete
;
const
TString
*
const
name
;
const
TType
*
const
type
;
}
;
struct
TParameter
{
TConstParameter
turnToConst
(
)
{
const
TString
*
constName
=
name
;
const
TType
*
constType
=
type
;
name
=
nullptr
;
type
=
nullptr
;
return
TConstParameter
(
constName
constType
)
;
}
const
TString
*
name
;
TType
*
type
;
}
;
class
TFunction
:
public
TSymbol
{
public
:
TFunction
(
TSymbolTable
*
symbolTable
const
TString
*
name
const
TType
*
retType
TOperator
tOp
=
EOpNull
TExtension
ext
=
TExtension
:
:
UNDEFINED
)
:
TSymbol
(
symbolTable
name
)
returnType
(
retType
)
mangledName
(
nullptr
)
op
(
tOp
)
defined
(
false
)
mHasPrototypeDeclaration
(
false
)
{
relateToExtension
(
ext
)
;
}
~
TFunction
(
)
override
;
bool
isFunction
(
)
const
override
{
return
true
;
}
void
addParameter
(
const
TConstParameter
&
p
)
{
parameters
.
push_back
(
p
)
;
mangledName
=
nullptr
;
}
void
swapParameters
(
const
TFunction
&
parametersSource
)
;
const
TString
&
getMangledName
(
)
const
override
{
if
(
mangledName
=
=
nullptr
)
{
mangledName
=
buildMangledName
(
)
;
}
return
*
mangledName
;
}
static
const
TString
&
GetMangledNameFromCall
(
const
TString
&
functionName
const
TIntermSequence
&
arguments
)
;
const
TType
&
getReturnType
(
)
const
{
return
*
returnType
;
}
TOperator
getBuiltInOp
(
)
const
{
return
op
;
}
void
setDefined
(
)
{
defined
=
true
;
}
bool
isDefined
(
)
{
return
defined
;
}
void
setHasPrototypeDeclaration
(
)
{
mHasPrototypeDeclaration
=
true
;
}
bool
hasPrototypeDeclaration
(
)
const
{
return
mHasPrototypeDeclaration
;
}
size_t
getParamCount
(
)
const
{
return
parameters
.
size
(
)
;
}
const
TConstParameter
&
getParam
(
size_t
i
)
const
{
return
parameters
[
i
]
;
}
private
:
void
clearParameters
(
)
;
const
TString
*
buildMangledName
(
)
const
;
typedef
TVector
<
TConstParameter
>
TParamList
;
TParamList
parameters
;
const
TType
*
returnType
;
mutable
const
TString
*
mangledName
;
TOperator
op
;
bool
defined
;
bool
mHasPrototypeDeclaration
;
}
;
class
TInterfaceBlockName
:
public
TSymbol
{
public
:
virtual
~
TInterfaceBlockName
(
)
{
}
private
:
friend
class
TSymbolTable
;
TInterfaceBlockName
(
TSymbolTable
*
symbolTable
const
TString
*
name
)
:
TSymbol
(
symbolTable
name
)
{
}
}
;
class
TSymbolTableLevel
{
public
:
typedef
TMap
<
TString
TSymbol
*
>
tLevel
;
typedef
tLevel
:
:
const_iterator
const_iterator
;
typedef
const
tLevel
:
:
value_type
tLevelPair
;
typedef
std
:
:
pair
<
tLevel
:
:
iterator
bool
>
tInsertResult
;
TSymbolTableLevel
(
)
:
mGlobalInvariant
(
false
)
{
}
~
TSymbolTableLevel
(
)
;
bool
insert
(
TSymbol
*
symbol
)
;
bool
insertUnmangled
(
TFunction
*
function
)
;
TSymbol
*
find
(
const
TString
&
name
)
const
;
void
addInvariantVarying
(
const
std
:
:
string
&
name
)
{
mInvariantVaryings
.
insert
(
name
)
;
}
bool
isVaryingInvariant
(
const
std
:
:
string
&
name
)
{
return
(
mGlobalInvariant
|
|
mInvariantVaryings
.
count
(
name
)
>
0
)
;
}
void
setGlobalInvariant
(
bool
invariant
)
{
mGlobalInvariant
=
invariant
;
}
void
insertUnmangledBuiltInName
(
const
std
:
:
string
&
name
)
{
mUnmangledBuiltInNames
.
insert
(
name
)
;
}
bool
hasUnmangledBuiltIn
(
const
std
:
:
string
&
name
)
{
return
mUnmangledBuiltInNames
.
count
(
name
)
>
0
;
}
protected
:
tLevel
level
;
std
:
:
set
<
std
:
:
string
>
mInvariantVaryings
;
bool
mGlobalInvariant
;
private
:
std
:
:
set
<
std
:
:
string
>
mUnmangledBuiltInNames
;
}
;
typedef
int
ESymbolLevel
;
const
int
COMMON_BUILTINS
=
0
;
const
int
ESSL1_BUILTINS
=
1
;
const
int
ESSL3_BUILTINS
=
2
;
const
int
ESSL3_1_BUILTINS
=
3
;
const
int
GLSL_BUILTINS
=
4
;
const
int
LAST_BUILTIN_LEVEL
=
GLSL_BUILTINS
;
const
int
GLOBAL_LEVEL
=
5
;
class
TSymbolTable
:
angle
:
:
NonCopyable
{
public
:
TSymbolTable
(
)
:
mUniqueIdCounter
(
0
)
{
}
~
TSymbolTable
(
)
;
bool
isEmpty
(
)
const
{
return
table
.
empty
(
)
;
}
bool
atBuiltInLevel
(
)
const
{
return
currentLevel
(
)
<
=
LAST_BUILTIN_LEVEL
;
}
bool
atGlobalLevel
(
)
const
{
return
currentLevel
(
)
=
=
GLOBAL_LEVEL
;
}
void
push
(
)
{
table
.
push_back
(
new
TSymbolTableLevel
)
;
precisionStack
.
push_back
(
new
PrecisionStackLevel
)
;
}
void
pop
(
)
{
delete
table
.
back
(
)
;
table
.
pop_back
(
)
;
delete
precisionStack
.
back
(
)
;
precisionStack
.
pop_back
(
)
;
}
TVariable
*
declareVariable
(
const
TString
*
name
const
TType
&
type
)
;
TVariable
*
declareStructType
(
TStructure
*
str
)
;
TInterfaceBlockName
*
declareInterfaceBlockName
(
const
TString
*
name
)
;
TVariable
*
insertVariable
(
ESymbolLevel
level
const
char
*
name
const
TType
&
type
)
;
TVariable
*
insertVariableExt
(
ESymbolLevel
level
TExtension
ext
const
char
*
name
const
TType
&
type
)
;
TVariable
*
insertStructType
(
ESymbolLevel
level
TStructure
*
str
)
;
TInterfaceBlockName
*
insertInterfaceBlockNameExt
(
ESymbolLevel
level
TExtension
ext
const
TString
*
name
)
;
bool
insertConstInt
(
ESymbolLevel
level
const
char
*
name
int
value
TPrecision
precision
)
{
TVariable
*
constant
=
new
TVariable
(
this
NewPoolTString
(
name
)
TType
(
EbtInt
precision
EvqConst
1
)
)
;
TConstantUnion
*
unionArray
=
new
TConstantUnion
[
1
]
;
unionArray
[
0
]
.
setIConst
(
value
)
;
constant
-
>
shareConstPointer
(
unionArray
)
;
return
insert
(
level
constant
)
;
}
bool
insertConstIntExt
(
ESymbolLevel
level
TExtension
ext
const
char
*
name
int
value
TPrecision
precision
)
{
TVariable
*
constant
=
new
TVariable
(
this
NewPoolTString
(
name
)
TType
(
EbtInt
precision
EvqConst
1
)
)
;
TConstantUnion
*
unionArray
=
new
TConstantUnion
[
1
]
;
unionArray
[
0
]
.
setIConst
(
value
)
;
constant
-
>
shareConstPointer
(
unionArray
)
;
return
insert
(
level
ext
constant
)
;
}
bool
insertConstIvec3
(
ESymbolLevel
level
const
char
*
name
const
std
:
:
array
<
int
3
>
&
values
TPrecision
precision
)
{
TVariable
*
constantIvec3
=
new
TVariable
(
this
NewPoolTString
(
name
)
TType
(
EbtInt
precision
EvqConst
3
)
)
;
TConstantUnion
*
unionArray
=
new
TConstantUnion
[
3
]
;
for
(
size_t
index
=
0u
;
index
<
3u
;
+
+
index
)
{
unionArray
[
index
]
.
setIConst
(
values
[
index
]
)
;
}
constantIvec3
-
>
shareConstPointer
(
unionArray
)
;
return
insert
(
level
constantIvec3
)
;
}
void
insertBuiltIn
(
ESymbolLevel
level
TOperator
op
TExtension
ext
const
TType
*
rvalue
const
char
*
name
const
TType
*
ptype1
const
TType
*
ptype2
=
0
const
TType
*
ptype3
=
0
const
TType
*
ptype4
=
0
const
TType
*
ptype5
=
0
)
;
void
insertBuiltIn
(
ESymbolLevel
level
const
TType
*
rvalue
const
char
*
name
const
TType
*
ptype1
const
TType
*
ptype2
=
0
const
TType
*
ptype3
=
0
const
TType
*
ptype4
=
0
const
TType
*
ptype5
=
0
)
{
insertUnmangledBuiltInName
(
name
level
)
;
insertBuiltIn
(
level
EOpNull
TExtension
:
:
UNDEFINED
rvalue
name
ptype1
ptype2
ptype3
ptype4
ptype5
)
;
}
void
insertBuiltIn
(
ESymbolLevel
level
TExtension
ext
const
TType
*
rvalue
const
char
*
name
const
TType
*
ptype1
const
TType
*
ptype2
=
0
const
TType
*
ptype3
=
0
const
TType
*
ptype4
=
0
const
TType
*
ptype5
=
0
)
{
insertUnmangledBuiltInName
(
name
level
)
;
insertBuiltIn
(
level
EOpNull
ext
rvalue
name
ptype1
ptype2
ptype3
ptype4
ptype5
)
;
}
void
insertBuiltInOp
(
ESymbolLevel
level
TOperator
op
const
TType
*
rvalue
const
TType
*
ptype1
const
TType
*
ptype2
=
0
const
TType
*
ptype3
=
0
const
TType
*
ptype4
=
0
const
TType
*
ptype5
=
0
)
;
void
insertBuiltInOp
(
ESymbolLevel
level
TOperator
op
TExtension
ext
const
TType
*
rvalue
const
TType
*
ptype1
const
TType
*
ptype2
=
0
const
TType
*
ptype3
=
0
const
TType
*
ptype4
=
0
const
TType
*
ptype5
=
0
)
;
void
insertBuiltInFunctionNoParameters
(
ESymbolLevel
level
TOperator
op
const
TType
*
rvalue
const
char
*
name
)
;
void
insertBuiltInFunctionNoParametersExt
(
ESymbolLevel
level
TExtension
ext
TOperator
op
const
TType
*
rvalue
const
char
*
name
)
;
TSymbol
*
find
(
const
TString
&
name
int
shaderVersion
bool
*
builtIn
=
nullptr
bool
*
sameScope
=
nullptr
)
const
;
TSymbol
*
findGlobal
(
const
TString
&
name
)
const
;
TSymbol
*
findBuiltIn
(
const
TString
&
name
int
shaderVersion
)
const
;
TSymbol
*
findBuiltIn
(
const
TString
&
name
int
shaderVersion
bool
includeGLSLBuiltins
)
const
;
TSymbolTableLevel
*
getOuterLevel
(
)
{
assert
(
currentLevel
(
)
>
=
1
)
;
return
table
[
currentLevel
(
)
-
1
]
;
}
void
setDefaultPrecision
(
TBasicType
type
TPrecision
prec
)
{
int
indexOfLastElement
=
static_cast
<
int
>
(
precisionStack
.
size
(
)
)
-
1
;
(
*
precisionStack
[
indexOfLastElement
]
)
[
type
]
=
prec
;
}
TPrecision
getDefaultPrecision
(
TBasicType
type
)
const
;
void
addInvariantVarying
(
const
std
:
:
string
&
originalName
)
{
ASSERT
(
atGlobalLevel
(
)
)
;
table
[
currentLevel
(
)
]
-
>
addInvariantVarying
(
originalName
)
;
}
bool
isVaryingInvariant
(
const
std
:
:
string
&
originalName
)
const
{
ASSERT
(
atGlobalLevel
(
)
)
;
return
table
[
currentLevel
(
)
]
-
>
isVaryingInvariant
(
originalName
)
;
}
void
setGlobalInvariant
(
bool
invariant
)
{
ASSERT
(
atGlobalLevel
(
)
)
;
table
[
currentLevel
(
)
]
-
>
setGlobalInvariant
(
invariant
)
;
}
int
nextUniqueId
(
)
{
return
+
+
mUniqueIdCounter
;
}
bool
hasUnmangledBuiltInForShaderVersion
(
const
char
*
name
int
shaderVersion
)
;
private
:
ESymbolLevel
currentLevel
(
)
const
{
return
static_cast
<
ESymbolLevel
>
(
table
.
size
(
)
-
1
)
;
}
TVariable
*
insertVariable
(
ESymbolLevel
level
const
TString
*
name
const
TType
&
type
)
;
bool
insert
(
ESymbolLevel
level
TSymbol
*
symbol
)
{
return
table
[
level
]
-
>
insert
(
symbol
)
;
}
bool
insert
(
ESymbolLevel
level
TExtension
ext
TSymbol
*
symbol
)
{
symbol
-
>
relateToExtension
(
ext
)
;
return
table
[
level
]
-
>
insert
(
symbol
)
;
}
void
insertUnmangledBuiltInName
(
const
char
*
name
ESymbolLevel
level
)
;
bool
hasUnmangledBuiltInAtLevel
(
const
char
*
name
ESymbolLevel
level
)
;
std
:
:
vector
<
TSymbolTableLevel
*
>
table
;
typedef
TMap
<
TBasicType
TPrecision
>
PrecisionStackLevel
;
std
:
:
vector
<
PrecisionStackLevel
*
>
precisionStack
;
int
mUniqueIdCounter
;
}
;
}
#
endif
