#
include
"
compiler
/
translator
/
EmulatePrecision
.
h
"
#
include
<
memory
>
namespace
sh
{
namespace
{
class
RoundingHelperWriter
:
angle
:
:
NonCopyable
{
public
:
static
RoundingHelperWriter
*
createHelperWriter
(
const
ShShaderOutput
outputLanguage
)
;
void
writeCommonRoundingHelpers
(
TInfoSinkBase
&
sink
const
int
shaderVersion
)
;
void
writeCompoundAssignmentHelper
(
TInfoSinkBase
&
sink
const
char
*
lType
const
char
*
rType
const
char
*
opStr
const
char
*
opNameStr
)
;
virtual
~
RoundingHelperWriter
(
)
{
}
protected
:
RoundingHelperWriter
(
const
ShShaderOutput
outputLanguage
)
:
mOutputLanguage
(
outputLanguage
)
{
}
RoundingHelperWriter
(
)
=
delete
;
const
ShShaderOutput
mOutputLanguage
;
private
:
virtual
std
:
:
string
getTypeString
(
const
char
*
glslType
)
=
0
;
virtual
void
writeFloatRoundingHelpers
(
TInfoSinkBase
&
sink
)
=
0
;
virtual
void
writeVectorRoundingHelpers
(
TInfoSinkBase
&
sink
const
unsigned
int
size
)
=
0
;
virtual
void
writeMatrixRoundingHelper
(
TInfoSinkBase
&
sink
const
unsigned
int
columns
const
unsigned
int
rows
const
char
*
functionName
)
=
0
;
}
;
class
RoundingHelperWriterGLSL
:
public
RoundingHelperWriter
{
public
:
RoundingHelperWriterGLSL
(
const
ShShaderOutput
outputLanguage
)
:
RoundingHelperWriter
(
outputLanguage
)
{
}
private
:
std
:
:
string
getTypeString
(
const
char
*
glslType
)
override
;
void
writeFloatRoundingHelpers
(
TInfoSinkBase
&
sink
)
override
;
void
writeVectorRoundingHelpers
(
TInfoSinkBase
&
sink
const
unsigned
int
size
)
override
;
void
writeMatrixRoundingHelper
(
TInfoSinkBase
&
sink
const
unsigned
int
columns
const
unsigned
int
rows
const
char
*
functionName
)
override
;
}
;
class
RoundingHelperWriterESSL
:
public
RoundingHelperWriterGLSL
{
public
:
RoundingHelperWriterESSL
(
const
ShShaderOutput
outputLanguage
)
:
RoundingHelperWriterGLSL
(
outputLanguage
)
{
}
private
:
std
:
:
string
getTypeString
(
const
char
*
glslType
)
override
;
}
;
class
RoundingHelperWriterHLSL
:
public
RoundingHelperWriter
{
public
:
RoundingHelperWriterHLSL
(
const
ShShaderOutput
outputLanguage
)
:
RoundingHelperWriter
(
outputLanguage
)
{
}
private
:
std
:
:
string
getTypeString
(
const
char
*
glslType
)
override
;
void
writeFloatRoundingHelpers
(
TInfoSinkBase
&
sink
)
override
;
void
writeVectorRoundingHelpers
(
TInfoSinkBase
&
sink
const
unsigned
int
size
)
override
;
void
writeMatrixRoundingHelper
(
TInfoSinkBase
&
sink
const
unsigned
int
columns
const
unsigned
int
rows
const
char
*
functionName
)
override
;
}
;
RoundingHelperWriter
*
RoundingHelperWriter
:
:
createHelperWriter
(
const
ShShaderOutput
outputLanguage
)
{
ASSERT
(
EmulatePrecision
:
:
SupportedInLanguage
(
outputLanguage
)
)
;
switch
(
outputLanguage
)
{
case
SH_HLSL_4_1_OUTPUT
:
return
new
RoundingHelperWriterHLSL
(
outputLanguage
)
;
case
SH_ESSL_OUTPUT
:
return
new
RoundingHelperWriterESSL
(
outputLanguage
)
;
default
:
return
new
RoundingHelperWriterGLSL
(
outputLanguage
)
;
}
}
void
RoundingHelperWriter
:
:
writeCommonRoundingHelpers
(
TInfoSinkBase
&
sink
const
int
shaderVersion
)
{
writeFloatRoundingHelpers
(
sink
)
;
writeVectorRoundingHelpers
(
sink
2
)
;
writeVectorRoundingHelpers
(
sink
3
)
;
writeVectorRoundingHelpers
(
sink
4
)
;
if
(
shaderVersion
>
100
)
{
for
(
unsigned
int
columns
=
2
;
columns
<
=
4
;
+
+
columns
)
{
for
(
unsigned
int
rows
=
2
;
rows
<
=
4
;
+
+
rows
)
{
writeMatrixRoundingHelper
(
sink
columns
rows
"
angle_frm
"
)
;
writeMatrixRoundingHelper
(
sink
columns
rows
"
angle_frl
"
)
;
}
}
}
else
{
for
(
unsigned
int
size
=
2
;
size
<
=
4
;
+
+
size
)
{
writeMatrixRoundingHelper
(
sink
size
size
"
angle_frm
"
)
;
writeMatrixRoundingHelper
(
sink
size
size
"
angle_frl
"
)
;
}
}
}
void
RoundingHelperWriter
:
:
writeCompoundAssignmentHelper
(
TInfoSinkBase
&
sink
const
char
*
lType
const
char
*
rType
const
char
*
opStr
const
char
*
opNameStr
)
{
std
:
:
string
lTypeStr
=
getTypeString
(
lType
)
;
std
:
:
string
rTypeStr
=
getTypeString
(
rType
)
;
sink
<
<
lTypeStr
<
<
"
angle_compound_
"
<
<
opNameStr
<
<
"
_frm
(
inout
"
<
<
lTypeStr
<
<
"
x
in
"
<
<
rTypeStr
<
<
"
y
)
{
\
n
"
"
x
=
angle_frm
(
angle_frm
(
x
)
"
<
<
opStr
<
<
"
y
)
;
\
n
"
"
return
x
;
\
n
"
"
}
\
n
"
;
sink
<
<
lTypeStr
<
<
"
angle_compound_
"
<
<
opNameStr
<
<
"
_frl
(
inout
"
<
<
lTypeStr
<
<
"
x
in
"
<
<
rTypeStr
<
<
"
y
)
{
\
n
"
"
x
=
angle_frl
(
angle_frl
(
x
)
"
<
<
opStr
<
<
"
y
)
;
\
n
"
"
return
x
;
\
n
"
"
}
\
n
"
;
}
std
:
:
string
RoundingHelperWriterGLSL
:
:
getTypeString
(
const
char
*
glslType
)
{
return
glslType
;
}
std
:
:
string
RoundingHelperWriterESSL
:
:
getTypeString
(
const
char
*
glslType
)
{
std
:
:
stringstream
typeStrStr
;
typeStrStr
<
<
"
highp
"
<
<
glslType
;
return
typeStrStr
.
str
(
)
;
}
void
RoundingHelperWriterGLSL
:
:
writeFloatRoundingHelpers
(
TInfoSinkBase
&
sink
)
{
std
:
:
string
floatType
=
getTypeString
(
"
float
"
)
;
sink
<
<
floatType
<
<
"
angle_frm
(
in
"
<
<
floatType
<
<
"
x
)
{
\
n
"
"
x
=
clamp
(
x
-
65504
.
0
65504
.
0
)
;
\
n
"
"
"
<
<
floatType
<
<
"
exponent
=
floor
(
log2
(
abs
(
x
)
+
1e
-
30
)
)
-
10
.
0
;
\
n
"
"
bool
isNonZero
=
(
exponent
>
=
-
25
.
0
)
;
\
n
"
"
x
=
x
*
exp2
(
-
exponent
)
;
\
n
"
"
x
=
sign
(
x
)
*
floor
(
abs
(
x
)
)
;
\
n
"
"
return
x
*
exp2
(
exponent
)
*
float
(
isNonZero
)
;
\
n
"
"
}
\
n
"
;
sink
<
<
floatType
<
<
"
angle_frl
(
in
"
<
<
floatType
<
<
"
x
)
{
\
n
"
"
x
=
clamp
(
x
-
2
.
0
2
.
0
)
;
\
n
"
"
x
=
x
*
256
.
0
;
\
n
"
"
x
=
sign
(
x
)
*
floor
(
abs
(
x
)
)
;
\
n
"
"
return
x
*
0
.
00390625
;
\
n
"
"
}
\
n
"
;
}
void
RoundingHelperWriterGLSL
:
:
writeVectorRoundingHelpers
(
TInfoSinkBase
&
sink
const
unsigned
int
size
)
{
std
:
:
stringstream
vecTypeStrStr
;
vecTypeStrStr
<
<
"
vec
"
<
<
size
;
std
:
:
string
vecType
=
getTypeString
(
vecTypeStrStr
.
str
(
)
.
c_str
(
)
)
;
sink
<
<
vecType
<
<
"
angle_frm
(
in
"
<
<
vecType
<
<
"
v
)
{
\
n
"
"
v
=
clamp
(
v
-
65504
.
0
65504
.
0
)
;
\
n
"
"
"
<
<
vecType
<
<
"
exponent
=
floor
(
log2
(
abs
(
v
)
+
1e
-
30
)
)
-
10
.
0
;
\
n
"
"
bvec
"
<
<
size
<
<
"
isNonZero
=
greaterThanEqual
(
exponent
vec
"
<
<
size
<
<
"
(
-
25
.
0
)
)
;
\
n
"
"
v
=
v
*
exp2
(
-
exponent
)
;
\
n
"
"
v
=
sign
(
v
)
*
floor
(
abs
(
v
)
)
;
\
n
"
"
return
v
*
exp2
(
exponent
)
*
vec
"
<
<
size
<
<
"
(
isNonZero
)
;
\
n
"
"
}
\
n
"
;
sink
<
<
vecType
<
<
"
angle_frl
(
in
"
<
<
vecType
<
<
"
v
)
{
\
n
"
"
v
=
clamp
(
v
-
2
.
0
2
.
0
)
;
\
n
"
"
v
=
v
*
256
.
0
;
\
n
"
"
v
=
sign
(
v
)
*
floor
(
abs
(
v
)
)
;
\
n
"
"
return
v
*
0
.
00390625
;
\
n
"
"
}
\
n
"
;
}
void
RoundingHelperWriterGLSL
:
:
writeMatrixRoundingHelper
(
TInfoSinkBase
&
sink
const
unsigned
int
columns
const
unsigned
int
rows
const
char
*
functionName
)
{
std
:
:
stringstream
matTypeStrStr
;
matTypeStrStr
<
<
"
mat
"
<
<
columns
;
if
(
rows
!
=
columns
)
{
matTypeStrStr
<
<
"
x
"
<
<
rows
;
}
std
:
:
string
matType
=
getTypeString
(
matTypeStrStr
.
str
(
)
.
c_str
(
)
)
;
sink
<
<
matType
<
<
"
"
<
<
functionName
<
<
"
(
in
"
<
<
matType
<
<
"
m
)
{
\
n
"
<
<
"
"
<
<
matType
<
<
"
rounded
;
\
n
"
;
for
(
unsigned
int
i
=
0
;
i
<
columns
;
+
+
i
)
{
sink
<
<
"
rounded
[
"
<
<
i
<
<
"
]
=
"
<
<
functionName
<
<
"
(
m
[
"
<
<
i
<
<
"
]
)
;
\
n
"
;
}
sink
<
<
"
return
rounded
;
\
n
"
"
}
\
n
"
;
}
static
const
char
*
GetHLSLTypeStr
(
const
char
*
floatTypeStr
)
{
if
(
strcmp
(
floatTypeStr
"
float
"
)
=
=
0
)
{
return
"
float
"
;
}
if
(
strcmp
(
floatTypeStr
"
vec2
"
)
=
=
0
)
{
return
"
float2
"
;
}
if
(
strcmp
(
floatTypeStr
"
vec3
"
)
=
=
0
)
{
return
"
float3
"
;
}
if
(
strcmp
(
floatTypeStr
"
vec4
"
)
=
=
0
)
{
return
"
float4
"
;
}
if
(
strcmp
(
floatTypeStr
"
mat2
"
)
=
=
0
)
{
return
"
float2x2
"
;
}
if
(
strcmp
(
floatTypeStr
"
mat3
"
)
=
=
0
)
{
return
"
float3x3
"
;
}
if
(
strcmp
(
floatTypeStr
"
mat4
"
)
=
=
0
)
{
return
"
float4x4
"
;
}
if
(
strcmp
(
floatTypeStr
"
mat2x3
"
)
=
=
0
)
{
return
"
float2x3
"
;
}
if
(
strcmp
(
floatTypeStr
"
mat2x4
"
)
=
=
0
)
{
return
"
float2x4
"
;
}
if
(
strcmp
(
floatTypeStr
"
mat3x2
"
)
=
=
0
)
{
return
"
float3x2
"
;
}
if
(
strcmp
(
floatTypeStr
"
mat3x4
"
)
=
=
0
)
{
return
"
float3x4
"
;
}
if
(
strcmp
(
floatTypeStr
"
mat4x2
"
)
=
=
0
)
{
return
"
float4x2
"
;
}
if
(
strcmp
(
floatTypeStr
"
mat4x3
"
)
=
=
0
)
{
return
"
float4x3
"
;
}
UNREACHABLE
(
)
;
return
nullptr
;
}
std
:
:
string
RoundingHelperWriterHLSL
:
:
getTypeString
(
const
char
*
glslType
)
{
return
GetHLSLTypeStr
(
glslType
)
;
}
void
RoundingHelperWriterHLSL
:
:
writeFloatRoundingHelpers
(
TInfoSinkBase
&
sink
)
{
writeVectorRoundingHelpers
(
sink
1
)
;
}
void
RoundingHelperWriterHLSL
:
:
writeVectorRoundingHelpers
(
TInfoSinkBase
&
sink
const
unsigned
int
size
)
{
std
:
:
stringstream
vecTypeStrStr
;
vecTypeStrStr
<
<
"
float
"
<
<
size
;
std
:
:
string
vecType
=
vecTypeStrStr
.
str
(
)
;
sink
<
<
vecType
<
<
"
angle_frm
(
"
<
<
vecType
<
<
"
v
)
{
\
n
"
"
v
=
clamp
(
v
-
65504
.
0
65504
.
0
)
;
\
n
"
"
"
<
<
vecType
<
<
"
exponent
=
floor
(
log2
(
abs
(
v
)
+
1e
-
30
)
)
-
10
.
0
;
\
n
"
"
bool
"
<
<
size
<
<
"
isNonZero
=
exponent
<
-
25
.
0
;
\
n
"
"
v
=
v
*
exp2
(
-
exponent
)
;
\
n
"
"
v
=
sign
(
v
)
*
floor
(
abs
(
v
)
)
;
\
n
"
"
return
v
*
exp2
(
exponent
)
*
(
float
"
<
<
size
<
<
"
)
(
isNonZero
)
;
\
n
"
"
}
\
n
"
;
sink
<
<
vecType
<
<
"
angle_frl
(
"
<
<
vecType
<
<
"
v
)
{
\
n
"
"
v
=
clamp
(
v
-
2
.
0
2
.
0
)
;
\
n
"
"
v
=
v
*
256
.
0
;
\
n
"
"
v
=
sign
(
v
)
*
floor
(
abs
(
v
)
)
;
\
n
"
"
return
v
*
0
.
00390625
;
\
n
"
"
}
\
n
"
;
}
void
RoundingHelperWriterHLSL
:
:
writeMatrixRoundingHelper
(
TInfoSinkBase
&
sink
const
unsigned
int
columns
const
unsigned
int
rows
const
char
*
functionName
)
{
std
:
:
stringstream
matTypeStrStr
;
matTypeStrStr
<
<
"
float
"
<
<
columns
<
<
"
x
"
<
<
rows
;
std
:
:
string
matType
=
matTypeStrStr
.
str
(
)
;
sink
<
<
matType
<
<
"
"
<
<
functionName
<
<
"
(
"
<
<
matType
<
<
"
m
)
{
\
n
"
<
<
"
"
<
<
matType
<
<
"
rounded
;
\
n
"
;
for
(
unsigned
int
i
=
0
;
i
<
columns
;
+
+
i
)
{
sink
<
<
"
rounded
[
"
<
<
i
<
<
"
]
=
"
<
<
functionName
<
<
"
(
m
[
"
<
<
i
<
<
"
]
)
;
\
n
"
;
}
sink
<
<
"
return
rounded
;
\
n
"
"
}
\
n
"
;
}
bool
canRoundFloat
(
const
TType
&
type
)
{
return
type
.
getBasicType
(
)
=
=
EbtFloat
&
&
!
type
.
isArray
(
)
&
&
(
type
.
getPrecision
(
)
=
=
EbpLow
|
|
type
.
getPrecision
(
)
=
=
EbpMedium
)
;
}
TIntermAggregate
*
createInternalFunctionCallNode
(
const
TType
&
type
TString
name
TIntermSequence
*
arguments
)
{
TName
nameObj
(
name
)
;
nameObj
.
setInternal
(
true
)
;
TIntermAggregate
*
callNode
=
TIntermAggregate
:
:
Create
(
type
EOpCallInternalRawFunction
arguments
)
;
callNode
-
>
getFunctionSymbolInfo
(
)
-
>
setNameObj
(
nameObj
)
;
return
callNode
;
}
TIntermAggregate
*
createRoundingFunctionCallNode
(
TIntermTyped
*
roundedChild
)
{
TString
roundFunctionName
;
if
(
roundedChild
-
>
getPrecision
(
)
=
=
EbpMedium
)
roundFunctionName
=
"
angle_frm
"
;
else
roundFunctionName
=
"
angle_frl
"
;
TIntermSequence
*
arguments
=
new
TIntermSequence
(
)
;
arguments
-
>
push_back
(
roundedChild
)
;
TIntermAggregate
*
callNode
=
createInternalFunctionCallNode
(
roundedChild
-
>
getType
(
)
roundFunctionName
arguments
)
;
callNode
-
>
getFunctionSymbolInfo
(
)
-
>
setKnownToNotHaveSideEffects
(
true
)
;
return
callNode
;
}
TIntermAggregate
*
createCompoundAssignmentFunctionCallNode
(
TIntermTyped
*
left
TIntermTyped
*
right
const
char
*
opNameStr
)
{
std
:
:
stringstream
strstr
;
if
(
left
-
>
getPrecision
(
)
=
=
EbpMedium
)
strstr
<
<
"
angle_compound_
"
<
<
opNameStr
<
<
"
_frm
"
;
else
strstr
<
<
"
angle_compound_
"
<
<
opNameStr
<
<
"
_frl
"
;
TString
functionName
=
strstr
.
str
(
)
.
c_str
(
)
;
TIntermSequence
*
arguments
=
new
TIntermSequence
(
)
;
arguments
-
>
push_back
(
left
)
;
arguments
-
>
push_back
(
right
)
;
return
createInternalFunctionCallNode
(
left
-
>
getType
(
)
functionName
arguments
)
;
}
bool
ParentUsesResult
(
TIntermNode
*
parent
TIntermTyped
*
node
)
{
if
(
!
parent
)
{
return
false
;
}
TIntermBlock
*
blockParent
=
parent
-
>
getAsBlock
(
)
;
if
(
blockParent
)
{
return
false
;
}
TIntermBinary
*
binaryParent
=
parent
-
>
getAsBinaryNode
(
)
;
if
(
binaryParent
&
&
binaryParent
-
>
getOp
(
)
=
=
EOpComma
&
&
(
binaryParent
-
>
getRight
(
)
!
=
node
)
)
{
return
false
;
}
return
true
;
}
bool
ParentConstructorTakesCareOfRounding
(
TIntermNode
*
parent
TIntermTyped
*
node
)
{
if
(
!
parent
)
{
return
false
;
}
TIntermAggregate
*
parentConstructor
=
parent
-
>
getAsAggregate
(
)
;
if
(
!
parentConstructor
|
|
parentConstructor
-
>
getOp
(
)
!
=
EOpConstruct
)
{
return
false
;
}
if
(
parentConstructor
-
>
getPrecision
(
)
!
=
node
-
>
getPrecision
(
)
)
{
return
false
;
}
return
canRoundFloat
(
parentConstructor
-
>
getType
(
)
)
;
}
}
EmulatePrecision
:
:
EmulatePrecision
(
TSymbolTable
*
symbolTable
int
shaderVersion
)
:
TLValueTrackingTraverser
(
true
true
true
symbolTable
shaderVersion
)
mDeclaringVariables
(
false
)
{
}
void
EmulatePrecision
:
:
visitSymbol
(
TIntermSymbol
*
node
)
{
TIntermNode
*
parent
=
getParentNode
(
)
;
if
(
canRoundFloat
(
node
-
>
getType
(
)
)
&
&
ParentUsesResult
(
parent
node
)
&
&
!
ParentConstructorTakesCareOfRounding
(
parent
node
)
&
&
!
mDeclaringVariables
&
&
!
isLValueRequiredHere
(
)
)
{
TIntermNode
*
replacement
=
createRoundingFunctionCallNode
(
node
)
;
queueReplacement
(
replacement
OriginalNode
:
:
BECOMES_CHILD
)
;
}
}
bool
EmulatePrecision
:
:
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
{
bool
visitChildren
=
true
;
TOperator
op
=
node
-
>
getOp
(
)
;
if
(
op
=
=
EOpInitialize
&
&
visit
=
=
InVisit
)
mDeclaringVariables
=
false
;
if
(
(
op
=
=
EOpIndexDirectStruct
)
&
&
visit
=
=
InVisit
)
visitChildren
=
false
;
if
(
visit
!
=
PreVisit
)
return
visitChildren
;
const
TType
&
type
=
node
-
>
getType
(
)
;
bool
roundFloat
=
canRoundFloat
(
type
)
;
if
(
roundFloat
)
{
switch
(
op
)
{
case
EOpAssign
:
case
EOpAdd
:
case
EOpSub
:
case
EOpMul
:
case
EOpDiv
:
case
EOpVectorTimesScalar
:
case
EOpVectorTimesMatrix
:
case
EOpMatrixTimesVector
:
case
EOpMatrixTimesScalar
:
case
EOpMatrixTimesMatrix
:
{
TIntermNode
*
parent
=
getParentNode
(
)
;
if
(
!
ParentUsesResult
(
parent
node
)
|
|
ParentConstructorTakesCareOfRounding
(
parent
node
)
)
{
break
;
}
TIntermNode
*
replacement
=
createRoundingFunctionCallNode
(
node
)
;
queueReplacement
(
replacement
OriginalNode
:
:
BECOMES_CHILD
)
;
break
;
}
case
EOpAddAssign
:
{
mEmulateCompoundAdd
.
insert
(
TypePair
(
type
.
getBuiltInTypeNameString
(
)
node
-
>
getRight
(
)
-
>
getType
(
)
.
getBuiltInTypeNameString
(
)
)
)
;
TIntermNode
*
replacement
=
createCompoundAssignmentFunctionCallNode
(
node
-
>
getLeft
(
)
node
-
>
getRight
(
)
"
add
"
)
;
queueReplacement
(
replacement
OriginalNode
:
:
IS_DROPPED
)
;
break
;
}
case
EOpSubAssign
:
{
mEmulateCompoundSub
.
insert
(
TypePair
(
type
.
getBuiltInTypeNameString
(
)
node
-
>
getRight
(
)
-
>
getType
(
)
.
getBuiltInTypeNameString
(
)
)
)
;
TIntermNode
*
replacement
=
createCompoundAssignmentFunctionCallNode
(
node
-
>
getLeft
(
)
node
-
>
getRight
(
)
"
sub
"
)
;
queueReplacement
(
replacement
OriginalNode
:
:
IS_DROPPED
)
;
break
;
}
case
EOpMulAssign
:
case
EOpVectorTimesMatrixAssign
:
case
EOpVectorTimesScalarAssign
:
case
EOpMatrixTimesScalarAssign
:
case
EOpMatrixTimesMatrixAssign
:
{
mEmulateCompoundMul
.
insert
(
TypePair
(
type
.
getBuiltInTypeNameString
(
)
node
-
>
getRight
(
)
-
>
getType
(
)
.
getBuiltInTypeNameString
(
)
)
)
;
TIntermNode
*
replacement
=
createCompoundAssignmentFunctionCallNode
(
node
-
>
getLeft
(
)
node
-
>
getRight
(
)
"
mul
"
)
;
queueReplacement
(
replacement
OriginalNode
:
:
IS_DROPPED
)
;
break
;
}
case
EOpDivAssign
:
{
mEmulateCompoundDiv
.
insert
(
TypePair
(
type
.
getBuiltInTypeNameString
(
)
node
-
>
getRight
(
)
-
>
getType
(
)
.
getBuiltInTypeNameString
(
)
)
)
;
TIntermNode
*
replacement
=
createCompoundAssignmentFunctionCallNode
(
node
-
>
getLeft
(
)
node
-
>
getRight
(
)
"
div
"
)
;
queueReplacement
(
replacement
OriginalNode
:
:
IS_DROPPED
)
;
break
;
}
default
:
break
;
}
}
return
visitChildren
;
}
bool
EmulatePrecision
:
:
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
node
)
{
if
(
visit
=
=
PreVisit
)
{
mDeclaringVariables
=
true
;
}
else
if
(
visit
=
=
InVisit
)
{
mDeclaringVariables
=
true
;
}
else
{
mDeclaringVariables
=
false
;
}
return
true
;
}
bool
EmulatePrecision
:
:
visitInvariantDeclaration
(
Visit
visit
TIntermInvariantDeclaration
*
node
)
{
return
false
;
}
bool
EmulatePrecision
:
:
visitFunctionPrototype
(
Visit
visit
TIntermFunctionPrototype
*
node
)
{
return
false
;
}
bool
EmulatePrecision
:
:
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
{
if
(
visit
!
=
PreVisit
)
return
true
;
switch
(
node
-
>
getOp
(
)
)
{
case
EOpCallInternalRawFunction
:
case
EOpCallFunctionInAST
:
break
;
case
EOpConstruct
:
if
(
node
-
>
getBasicType
(
)
=
=
EbtStruct
)
{
break
;
}
default
:
TIntermNode
*
parent
=
getParentNode
(
)
;
if
(
canRoundFloat
(
node
-
>
getType
(
)
)
&
&
ParentUsesResult
(
parent
node
)
&
&
!
ParentConstructorTakesCareOfRounding
(
parent
node
)
)
{
TIntermNode
*
replacement
=
createRoundingFunctionCallNode
(
node
)
;
queueReplacement
(
replacement
OriginalNode
:
:
BECOMES_CHILD
)
;
}
break
;
}
return
true
;
}
bool
EmulatePrecision
:
:
visitUnary
(
Visit
visit
TIntermUnary
*
node
)
{
switch
(
node
-
>
getOp
(
)
)
{
case
EOpNegative
:
case
EOpLogicalNot
:
case
EOpPostIncrement
:
case
EOpPostDecrement
:
case
EOpPreIncrement
:
case
EOpPreDecrement
:
case
EOpLogicalNotComponentWise
:
break
;
default
:
if
(
canRoundFloat
(
node
-
>
getType
(
)
)
&
&
visit
=
=
PreVisit
)
{
TIntermNode
*
replacement
=
createRoundingFunctionCallNode
(
node
)
;
queueReplacement
(
replacement
OriginalNode
:
:
BECOMES_CHILD
)
;
}
break
;
}
return
true
;
}
void
EmulatePrecision
:
:
writeEmulationHelpers
(
TInfoSinkBase
&
sink
const
int
shaderVersion
const
ShShaderOutput
outputLanguage
)
{
std
:
:
unique_ptr
<
RoundingHelperWriter
>
roundingHelperWriter
(
RoundingHelperWriter
:
:
createHelperWriter
(
outputLanguage
)
)
;
roundingHelperWriter
-
>
writeCommonRoundingHelpers
(
sink
shaderVersion
)
;
EmulationSet
:
:
const_iterator
it
;
for
(
it
=
mEmulateCompoundAdd
.
begin
(
)
;
it
!
=
mEmulateCompoundAdd
.
end
(
)
;
it
+
+
)
roundingHelperWriter
-
>
writeCompoundAssignmentHelper
(
sink
it
-
>
lType
it
-
>
rType
"
+
"
"
add
"
)
;
for
(
it
=
mEmulateCompoundSub
.
begin
(
)
;
it
!
=
mEmulateCompoundSub
.
end
(
)
;
it
+
+
)
roundingHelperWriter
-
>
writeCompoundAssignmentHelper
(
sink
it
-
>
lType
it
-
>
rType
"
-
"
"
sub
"
)
;
for
(
it
=
mEmulateCompoundDiv
.
begin
(
)
;
it
!
=
mEmulateCompoundDiv
.
end
(
)
;
it
+
+
)
roundingHelperWriter
-
>
writeCompoundAssignmentHelper
(
sink
it
-
>
lType
it
-
>
rType
"
/
"
"
div
"
)
;
for
(
it
=
mEmulateCompoundMul
.
begin
(
)
;
it
!
=
mEmulateCompoundMul
.
end
(
)
;
it
+
+
)
roundingHelperWriter
-
>
writeCompoundAssignmentHelper
(
sink
it
-
>
lType
it
-
>
rType
"
*
"
"
mul
"
)
;
}
bool
EmulatePrecision
:
:
SupportedInLanguage
(
const
ShShaderOutput
outputLanguage
)
{
switch
(
outputLanguage
)
{
case
SH_HLSL_4_1_OUTPUT
:
case
SH_ESSL_OUTPUT
:
return
true
;
default
:
return
(
outputLanguage
=
=
SH_GLSL_COMPATIBILITY_OUTPUT
|
|
sh
:
:
IsGLSL130OrNewer
(
outputLanguage
)
)
;
}
}
}
