#
include
"
compiler
/
translator
/
ParseContext
.
h
"
#
include
<
stdarg
.
h
>
#
include
<
stdio
.
h
>
#
include
"
common
/
mathutil
.
h
"
#
include
"
compiler
/
preprocessor
/
SourceLocation
.
h
"
#
include
"
compiler
/
translator
/
Cache
.
h
"
#
include
"
compiler
/
translator
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
ValidateGlobalInitializer
.
h
"
#
include
"
compiler
/
translator
/
ValidateSwitch
.
h
"
#
include
"
compiler
/
translator
/
glslang
.
h
"
#
include
"
compiler
/
translator
/
util
.
h
"
namespace
sh
{
namespace
{
const
int
kWebGLMaxStructNesting
=
4
;
bool
ContainsSampler
(
const
TStructure
*
structType
)
;
bool
ContainsSampler
(
const
TType
&
type
)
{
if
(
IsSampler
(
type
.
getBasicType
(
)
)
)
{
return
true
;
}
if
(
type
.
getBasicType
(
)
=
=
EbtStruct
)
{
return
ContainsSampler
(
type
.
getStruct
(
)
)
;
}
return
false
;
}
bool
ContainsSampler
(
const
TStructure
*
structType
)
{
for
(
const
auto
&
field
:
structType
-
>
fields
(
)
)
{
if
(
ContainsSampler
(
*
field
-
>
type
(
)
)
)
return
true
;
}
return
false
;
}
const
char
*
GetImageArgumentToken
(
TIntermTyped
*
imageNode
)
{
ASSERT
(
IsImage
(
imageNode
-
>
getBasicType
(
)
)
)
;
while
(
imageNode
-
>
getAsBinaryNode
(
)
&
&
(
imageNode
-
>
getAsBinaryNode
(
)
-
>
getOp
(
)
=
=
EOpIndexIndirect
|
|
imageNode
-
>
getAsBinaryNode
(
)
-
>
getOp
(
)
=
=
EOpIndexDirect
)
)
{
imageNode
=
imageNode
-
>
getAsBinaryNode
(
)
-
>
getLeft
(
)
;
}
TIntermSymbol
*
imageSymbol
=
imageNode
-
>
getAsSymbolNode
(
)
;
if
(
imageSymbol
)
{
return
imageSymbol
-
>
getSymbol
(
)
.
c_str
(
)
;
}
return
"
image
"
;
}
bool
CanSetDefaultPrecisionOnType
(
const
TPublicType
&
type
)
{
if
(
!
SupportsPrecision
(
type
.
getBasicType
(
)
)
)
{
return
false
;
}
if
(
type
.
getBasicType
(
)
=
=
EbtUInt
)
{
return
false
;
}
if
(
type
.
isAggregate
(
)
)
{
return
false
;
}
return
true
;
}
GLuint
GetGeometryShaderInputArraySize
(
TLayoutPrimitiveType
primitiveType
)
{
switch
(
primitiveType
)
{
case
EptPoints
:
return
1u
;
case
EptLines
:
return
2u
;
case
EptTriangles
:
return
3u
;
case
EptLinesAdjacency
:
return
4u
;
case
EptTrianglesAdjacency
:
return
6u
;
default
:
UNREACHABLE
(
)
;
return
0u
;
}
}
}
class
TParseContext
:
:
AtomicCounterBindingState
{
public
:
AtomicCounterBindingState
(
)
:
mDefaultOffset
(
0
)
{
}
int
insertSpan
(
int
start
size_t
length
)
{
gl
:
:
RangeI
newSpan
(
start
start
+
static_cast
<
int
>
(
length
)
)
;
for
(
const
auto
&
span
:
mSpans
)
{
if
(
newSpan
.
intersects
(
span
)
)
{
return
-
1
;
}
}
mSpans
.
push_back
(
newSpan
)
;
mDefaultOffset
=
newSpan
.
high
(
)
;
return
start
;
}
int
appendSpan
(
size_t
length
)
{
return
insertSpan
(
mDefaultOffset
length
)
;
}
void
setDefaultOffset
(
int
offset
)
{
mDefaultOffset
=
offset
;
}
private
:
int
mDefaultOffset
;
std
:
:
vector
<
gl
:
:
RangeI
>
mSpans
;
}
;
TParseContext
:
:
TParseContext
(
TSymbolTable
&
symt
TExtensionBehavior
&
ext
sh
:
:
GLenum
type
ShShaderSpec
spec
ShCompileOptions
options
bool
checksPrecErrors
TDiagnostics
*
diagnostics
const
ShBuiltInResources
&
resources
)
:
symbolTable
(
symt
)
mDeferredNonEmptyDeclarationErrorCheck
(
false
)
mShaderType
(
type
)
mShaderSpec
(
spec
)
mCompileOptions
(
options
)
mShaderVersion
(
100
)
mTreeRoot
(
nullptr
)
mLoopNestingLevel
(
0
)
mStructNestingLevel
(
0
)
mSwitchNestingLevel
(
0
)
mCurrentFunctionType
(
nullptr
)
mFunctionReturnsValue
(
false
)
mChecksPrecisionErrors
(
checksPrecErrors
)
mFragmentPrecisionHighOnESSL1
(
false
)
mDefaultUniformMatrixPacking
(
EmpColumnMajor
)
mDefaultUniformBlockStorage
(
sh
:
:
IsWebGLBasedSpec
(
spec
)
?
EbsStd140
:
EbsShared
)
mDefaultBufferMatrixPacking
(
EmpColumnMajor
)
mDefaultBufferBlockStorage
(
sh
:
:
IsWebGLBasedSpec
(
spec
)
?
EbsStd140
:
EbsShared
)
mDiagnostics
(
diagnostics
)
mDirectiveHandler
(
ext
*
mDiagnostics
mShaderVersion
mShaderType
resources
.
WEBGL_debug_shader_precision
=
=
1
)
mPreprocessor
(
mDiagnostics
&
mDirectiveHandler
pp
:
:
PreprocessorSettings
(
)
)
mScanner
(
nullptr
)
mUsesFragData
(
false
)
mUsesFragColor
(
false
)
mUsesSecondaryOutputs
(
false
)
mMinProgramTexelOffset
(
resources
.
MinProgramTexelOffset
)
mMaxProgramTexelOffset
(
resources
.
MaxProgramTexelOffset
)
mMinProgramTextureGatherOffset
(
resources
.
MinProgramTextureGatherOffset
)
mMaxProgramTextureGatherOffset
(
resources
.
MaxProgramTextureGatherOffset
)
mComputeShaderLocalSizeDeclared
(
false
)
mNumViews
(
-
1
)
mMaxNumViews
(
resources
.
MaxViewsOVR
)
mMaxImageUnits
(
resources
.
MaxImageUnits
)
mMaxCombinedTextureImageUnits
(
resources
.
MaxCombinedTextureImageUnits
)
mMaxUniformLocations
(
resources
.
MaxUniformLocations
)
mMaxUniformBufferBindings
(
resources
.
MaxUniformBufferBindings
)
mMaxAtomicCounterBindings
(
resources
.
MaxAtomicCounterBindings
)
mMaxShaderStorageBufferBindings
(
resources
.
MaxShaderStorageBufferBindings
)
mDeclaringFunction
(
false
)
mGeometryShaderInputPrimitiveType
(
EptUndefined
)
mGeometryShaderOutputPrimitiveType
(
EptUndefined
)
mGeometryShaderInvocations
(
0
)
mGeometryShaderMaxVertices
(
-
1
)
mMaxGeometryShaderInvocations
(
resources
.
MaxGeometryShaderInvocations
)
mMaxGeometryShaderMaxVertices
(
resources
.
MaxGeometryOutputVertices
)
mGeometryShaderInputArraySize
(
0
)
{
mComputeShaderLocalSize
.
fill
(
-
1
)
;
}
TParseContext
:
:
~
TParseContext
(
)
{
}
bool
TParseContext
:
:
parseVectorFields
(
const
TSourceLoc
&
line
const
TString
&
compString
int
vecSize
TVector
<
int
>
*
fieldOffsets
)
{
ASSERT
(
fieldOffsets
)
;
size_t
fieldCount
=
compString
.
size
(
)
;
if
(
fieldCount
>
4u
)
{
error
(
line
"
illegal
vector
field
selection
"
compString
.
c_str
(
)
)
;
return
false
;
}
fieldOffsets
-
>
resize
(
fieldCount
)
;
enum
{
exyzw
ergba
estpq
}
fieldSet
[
4
]
;
for
(
unsigned
int
i
=
0u
;
i
<
fieldOffsets
-
>
size
(
)
;
+
+
i
)
{
switch
(
compString
[
i
]
)
{
case
'
x
'
:
(
*
fieldOffsets
)
[
i
]
=
0
;
fieldSet
[
i
]
=
exyzw
;
break
;
case
'
r
'
:
(
*
fieldOffsets
)
[
i
]
=
0
;
fieldSet
[
i
]
=
ergba
;
break
;
case
'
s
'
:
(
*
fieldOffsets
)
[
i
]
=
0
;
fieldSet
[
i
]
=
estpq
;
break
;
case
'
y
'
:
(
*
fieldOffsets
)
[
i
]
=
1
;
fieldSet
[
i
]
=
exyzw
;
break
;
case
'
g
'
:
(
*
fieldOffsets
)
[
i
]
=
1
;
fieldSet
[
i
]
=
ergba
;
break
;
case
'
t
'
:
(
*
fieldOffsets
)
[
i
]
=
1
;
fieldSet
[
i
]
=
estpq
;
break
;
case
'
z
'
:
(
*
fieldOffsets
)
[
i
]
=
2
;
fieldSet
[
i
]
=
exyzw
;
break
;
case
'
b
'
:
(
*
fieldOffsets
)
[
i
]
=
2
;
fieldSet
[
i
]
=
ergba
;
break
;
case
'
p
'
:
(
*
fieldOffsets
)
[
i
]
=
2
;
fieldSet
[
i
]
=
estpq
;
break
;
case
'
w
'
:
(
*
fieldOffsets
)
[
i
]
=
3
;
fieldSet
[
i
]
=
exyzw
;
break
;
case
'
a
'
:
(
*
fieldOffsets
)
[
i
]
=
3
;
fieldSet
[
i
]
=
ergba
;
break
;
case
'
q
'
:
(
*
fieldOffsets
)
[
i
]
=
3
;
fieldSet
[
i
]
=
estpq
;
break
;
default
:
error
(
line
"
illegal
vector
field
selection
"
compString
.
c_str
(
)
)
;
return
false
;
}
}
for
(
unsigned
int
i
=
0u
;
i
<
fieldOffsets
-
>
size
(
)
;
+
+
i
)
{
if
(
(
*
fieldOffsets
)
[
i
]
>
=
vecSize
)
{
error
(
line
"
vector
field
selection
out
of
range
"
compString
.
c_str
(
)
)
;
return
false
;
}
if
(
i
>
0
)
{
if
(
fieldSet
[
i
]
!
=
fieldSet
[
i
-
1
]
)
{
error
(
line
"
illegal
-
vector
component
fields
not
from
the
same
set
"
compString
.
c_str
(
)
)
;
return
false
;
}
}
}
return
true
;
}
void
TParseContext
:
:
error
(
const
TSourceLoc
&
loc
const
char
*
reason
const
char
*
token
)
{
mDiagnostics
-
>
error
(
loc
reason
token
)
;
}
void
TParseContext
:
:
warning
(
const
TSourceLoc
&
loc
const
char
*
reason
const
char
*
token
)
{
mDiagnostics
-
>
warning
(
loc
reason
token
)
;
}
void
TParseContext
:
:
outOfRangeError
(
bool
isError
const
TSourceLoc
&
loc
const
char
*
reason
const
char
*
token
)
{
if
(
isError
)
{
error
(
loc
reason
token
)
;
}
else
{
warning
(
loc
reason
token
)
;
}
}
void
TParseContext
:
:
assignError
(
const
TSourceLoc
&
line
const
char
*
op
TString
left
TString
right
)
{
std
:
:
stringstream
reasonStream
;
reasonStream
<
<
"
cannot
convert
from
'
"
<
<
right
<
<
"
'
to
'
"
<
<
left
<
<
"
'
"
;
std
:
:
string
reason
=
reasonStream
.
str
(
)
;
error
(
line
reason
.
c_str
(
)
op
)
;
}
void
TParseContext
:
:
unaryOpError
(
const
TSourceLoc
&
line
const
char
*
op
TString
operand
)
{
std
:
:
stringstream
reasonStream
;
reasonStream
<
<
"
wrong
operand
type
-
no
operation
'
"
<
<
op
<
<
"
'
exists
that
takes
an
operand
of
type
"
<
<
operand
<
<
"
(
or
there
is
no
acceptable
conversion
)
"
;
std
:
:
string
reason
=
reasonStream
.
str
(
)
;
error
(
line
reason
.
c_str
(
)
op
)
;
}
void
TParseContext
:
:
binaryOpError
(
const
TSourceLoc
&
line
const
char
*
op
TString
left
TString
right
)
{
std
:
:
stringstream
reasonStream
;
reasonStream
<
<
"
wrong
operand
types
-
no
operation
'
"
<
<
op
<
<
"
'
exists
that
takes
a
left
-
hand
operand
of
type
'
"
<
<
left
<
<
"
'
and
a
right
operand
of
type
'
"
<
<
right
<
<
"
'
(
or
there
is
no
acceptable
conversion
)
"
;
std
:
:
string
reason
=
reasonStream
.
str
(
)
;
error
(
line
reason
.
c_str
(
)
op
)
;
}
void
TParseContext
:
:
checkPrecisionSpecified
(
const
TSourceLoc
&
line
TPrecision
precision
TBasicType
type
)
{
if
(
!
mChecksPrecisionErrors
)
return
;
if
(
precision
!
=
EbpUndefined
&
&
!
SupportsPrecision
(
type
)
)
{
error
(
line
"
illegal
type
for
precision
qualifier
"
getBasicString
(
type
)
)
;
}
if
(
precision
=
=
EbpUndefined
)
{
switch
(
type
)
{
case
EbtFloat
:
error
(
line
"
No
precision
specified
for
(
float
)
"
"
"
)
;
return
;
case
EbtInt
:
case
EbtUInt
:
UNREACHABLE
(
)
;
error
(
line
"
No
precision
specified
(
int
)
"
"
"
)
;
return
;
default
:
if
(
IsOpaqueType
(
type
)
)
{
error
(
line
"
No
precision
specified
"
getBasicString
(
type
)
)
;
return
;
}
}
}
}
bool
TParseContext
:
:
checkCanBeLValue
(
const
TSourceLoc
&
line
const
char
*
op
TIntermTyped
*
node
)
{
TIntermSymbol
*
symNode
=
node
-
>
getAsSymbolNode
(
)
;
TIntermBinary
*
binaryNode
=
node
-
>
getAsBinaryNode
(
)
;
TIntermSwizzle
*
swizzleNode
=
node
-
>
getAsSwizzleNode
(
)
;
if
(
swizzleNode
)
{
bool
ok
=
checkCanBeLValue
(
line
op
swizzleNode
-
>
getOperand
(
)
)
;
if
(
ok
&
&
swizzleNode
-
>
hasDuplicateOffsets
(
)
)
{
error
(
line
"
l
-
value
of
swizzle
cannot
have
duplicate
components
"
op
)
;
return
false
;
}
return
ok
;
}
if
(
binaryNode
)
{
switch
(
binaryNode
-
>
getOp
(
)
)
{
case
EOpIndexDirect
:
case
EOpIndexIndirect
:
case
EOpIndexDirectStruct
:
case
EOpIndexDirectInterfaceBlock
:
return
checkCanBeLValue
(
line
op
binaryNode
-
>
getLeft
(
)
)
;
default
:
break
;
}
error
(
line
"
l
-
value
required
"
op
)
;
return
false
;
}
std
:
:
string
message
;
switch
(
node
-
>
getQualifier
(
)
)
{
case
EvqConst
:
message
=
"
can
'
t
modify
a
const
"
;
break
;
case
EvqConstReadOnly
:
message
=
"
can
'
t
modify
a
const
"
;
break
;
case
EvqAttribute
:
message
=
"
can
'
t
modify
an
attribute
"
;
break
;
case
EvqFragmentIn
:
case
EvqVertexIn
:
case
EvqFlatIn
:
case
EvqSmoothIn
:
case
EvqCentroidIn
:
message
=
"
can
'
t
modify
an
input
"
;
break
;
case
EvqUniform
:
message
=
"
can
'
t
modify
a
uniform
"
;
break
;
case
EvqVaryingIn
:
message
=
"
can
'
t
modify
a
varying
"
;
break
;
case
EvqFragCoord
:
message
=
"
can
'
t
modify
gl_FragCoord
"
;
break
;
case
EvqFrontFacing
:
message
=
"
can
'
t
modify
gl_FrontFacing
"
;
break
;
case
EvqPointCoord
:
message
=
"
can
'
t
modify
gl_PointCoord
"
;
break
;
case
EvqNumWorkGroups
:
message
=
"
can
'
t
modify
gl_NumWorkGroups
"
;
break
;
case
EvqWorkGroupSize
:
message
=
"
can
'
t
modify
gl_WorkGroupSize
"
;
break
;
case
EvqWorkGroupID
:
message
=
"
can
'
t
modify
gl_WorkGroupID
"
;
break
;
case
EvqLocalInvocationID
:
message
=
"
can
'
t
modify
gl_LocalInvocationID
"
;
break
;
case
EvqGlobalInvocationID
:
message
=
"
can
'
t
modify
gl_GlobalInvocationID
"
;
break
;
case
EvqLocalInvocationIndex
:
message
=
"
can
'
t
modify
gl_LocalInvocationIndex
"
;
break
;
case
EvqViewIDOVR
:
message
=
"
can
'
t
modify
gl_ViewID_OVR
"
;
break
;
case
EvqComputeIn
:
message
=
"
can
'
t
modify
work
group
size
variable
"
;
break
;
case
EvqPerVertexIn
:
message
=
"
can
'
t
modify
any
member
in
gl_in
"
;
break
;
case
EvqPrimitiveIDIn
:
message
=
"
can
'
t
modify
gl_PrimitiveIDIn
"
;
break
;
case
EvqInvocationID
:
message
=
"
can
'
t
modify
gl_InvocationID
"
;
break
;
case
EvqPrimitiveID
:
if
(
mShaderType
=
=
GL_FRAGMENT_SHADER
)
{
message
=
"
can
'
t
modify
gl_PrimitiveID
in
a
fragment
shader
"
;
}
break
;
case
EvqLayer
:
if
(
mShaderType
=
=
GL_FRAGMENT_SHADER
)
{
message
=
"
can
'
t
modify
gl_Layer
in
a
fragment
shader
"
;
}
break
;
default
:
if
(
node
-
>
getBasicType
(
)
=
=
EbtVoid
)
{
message
=
"
can
'
t
modify
void
"
;
}
if
(
IsOpaqueType
(
node
-
>
getBasicType
(
)
)
)
{
message
=
"
can
'
t
modify
a
variable
with
type
"
;
message
+
=
getBasicString
(
node
-
>
getBasicType
(
)
)
;
}
else
if
(
node
-
>
getMemoryQualifier
(
)
.
readonly
)
{
message
=
"
can
'
t
modify
a
readonly
variable
"
;
}
}
if
(
message
.
empty
(
)
&
&
binaryNode
=
=
0
&
&
symNode
=
=
0
)
{
error
(
line
"
l
-
value
required
"
op
)
;
return
false
;
}
if
(
message
.
empty
(
)
)
return
true
;
if
(
symNode
)
{
const
char
*
symbol
=
symNode
-
>
getSymbol
(
)
.
c_str
(
)
;
std
:
:
stringstream
reasonStream
;
reasonStream
<
<
"
l
-
value
required
(
"
<
<
message
<
<
"
\
"
"
<
<
symbol
<
<
"
\
"
)
"
;
std
:
:
string
reason
=
reasonStream
.
str
(
)
;
error
(
line
reason
.
c_str
(
)
op
)
;
}
else
{
std
:
:
stringstream
reasonStream
;
reasonStream
<
<
"
l
-
value
required
(
"
<
<
message
<
<
"
)
"
;
std
:
:
string
reason
=
reasonStream
.
str
(
)
;
error
(
line
reason
.
c_str
(
)
op
)
;
}
return
false
;
}
void
TParseContext
:
:
checkIsConst
(
TIntermTyped
*
node
)
{
if
(
node
-
>
getQualifier
(
)
!
=
EvqConst
)
{
error
(
node
-
>
getLine
(
)
"
constant
expression
required
"
"
"
)
;
}
}
void
TParseContext
:
:
checkIsScalarInteger
(
TIntermTyped
*
node
const
char
*
token
)
{
if
(
!
node
-
>
isScalarInt
(
)
)
{
error
(
node
-
>
getLine
(
)
"
integer
expression
required
"
token
)
;
}
}
bool
TParseContext
:
:
checkIsAtGlobalLevel
(
const
TSourceLoc
&
line
const
char
*
token
)
{
if
(
!
symbolTable
.
atGlobalLevel
(
)
)
{
error
(
line
"
only
allowed
at
global
scope
"
token
)
;
return
false
;
}
return
true
;
}
bool
TParseContext
:
:
checkIsNotReserved
(
const
TSourceLoc
&
line
const
TString
&
identifier
)
{
static
const
char
*
reservedErrMsg
=
"
reserved
built
-
in
name
"
;
if
(
identifier
.
compare
(
0
3
"
gl_
"
)
=
=
0
)
{
error
(
line
reservedErrMsg
"
gl_
"
)
;
return
false
;
}
if
(
sh
:
:
IsWebGLBasedSpec
(
mShaderSpec
)
)
{
if
(
identifier
.
compare
(
0
6
"
webgl_
"
)
=
=
0
)
{
error
(
line
reservedErrMsg
"
webgl_
"
)
;
return
false
;
}
if
(
identifier
.
compare
(
0
7
"
_webgl_
"
)
=
=
0
)
{
error
(
line
reservedErrMsg
"
_webgl_
"
)
;
return
false
;
}
}
if
(
identifier
.
find
(
"
__
"
)
!
=
TString
:
:
npos
)
{
error
(
line
"
identifiers
containing
two
consecutive
underscores
(
__
)
are
reserved
as
"
"
possible
future
keywords
"
identifier
.
c_str
(
)
)
;
return
false
;
}
return
true
;
}
bool
TParseContext
:
:
checkConstructorArguments
(
const
TSourceLoc
&
line
const
TIntermSequence
*
arguments
const
TType
&
type
)
{
if
(
arguments
-
>
empty
(
)
)
{
error
(
line
"
constructor
does
not
have
any
arguments
"
"
constructor
"
)
;
return
false
;
}
for
(
TIntermNode
*
arg
:
*
arguments
)
{
const
TIntermTyped
*
argTyped
=
arg
-
>
getAsTyped
(
)
;
ASSERT
(
argTyped
!
=
nullptr
)
;
if
(
type
.
getBasicType
(
)
!
=
EbtStruct
&
&
IsOpaqueType
(
argTyped
-
>
getBasicType
(
)
)
)
{
std
:
:
string
reason
(
"
cannot
convert
a
variable
with
type
"
)
;
reason
+
=
getBasicString
(
argTyped
-
>
getBasicType
(
)
)
;
error
(
line
reason
.
c_str
(
)
"
constructor
"
)
;
return
false
;
}
else
if
(
argTyped
-
>
getMemoryQualifier
(
)
.
writeonly
)
{
error
(
line
"
cannot
convert
a
variable
with
writeonly
"
"
constructor
"
)
;
return
false
;
}
if
(
argTyped
-
>
getBasicType
(
)
=
=
EbtVoid
)
{
error
(
line
"
cannot
convert
a
void
"
"
constructor
"
)
;
return
false
;
}
}
if
(
type
.
isArray
(
)
)
{
ASSERT
(
!
type
.
isUnsizedArray
(
)
)
;
if
(
static_cast
<
size_t
>
(
type
.
getOutermostArraySize
(
)
)
!
=
arguments
-
>
size
(
)
)
{
error
(
line
"
array
constructor
needs
one
argument
per
array
element
"
"
constructor
"
)
;
return
false
;
}
for
(
TIntermNode
*
const
&
argNode
:
*
arguments
)
{
const
TType
&
argType
=
argNode
-
>
getAsTyped
(
)
-
>
getType
(
)
;
if
(
argType
.
isArray
(
)
)
{
error
(
line
"
constructing
from
a
non
-
dereferenced
array
"
"
constructor
"
)
;
return
false
;
}
if
(
!
argType
.
isElementTypeOf
(
type
)
)
{
error
(
line
"
Array
constructor
argument
has
an
incorrect
type
"
"
constructor
"
)
;
return
false
;
}
}
}
else
if
(
type
.
getBasicType
(
)
=
=
EbtStruct
)
{
const
TFieldList
&
fields
=
type
.
getStruct
(
)
-
>
fields
(
)
;
if
(
fields
.
size
(
)
!
=
arguments
-
>
size
(
)
)
{
error
(
line
"
Number
of
constructor
parameters
does
not
match
the
number
of
structure
fields
"
"
constructor
"
)
;
return
false
;
}
for
(
size_t
i
=
0
;
i
<
fields
.
size
(
)
;
i
+
+
)
{
if
(
i
>
=
arguments
-
>
size
(
)
|
|
(
*
arguments
)
[
i
]
-
>
getAsTyped
(
)
-
>
getType
(
)
!
=
*
fields
[
i
]
-
>
type
(
)
)
{
error
(
line
"
Structure
constructor
arguments
do
not
match
structure
fields
"
"
constructor
"
)
;
return
false
;
}
}
}
else
{
size_t
size
=
0
;
bool
full
=
false
;
bool
overFull
=
false
;
bool
matrixArg
=
false
;
for
(
TIntermNode
*
arg
:
*
arguments
)
{
const
TIntermTyped
*
argTyped
=
arg
-
>
getAsTyped
(
)
;
ASSERT
(
argTyped
!
=
nullptr
)
;
if
(
argTyped
-
>
getBasicType
(
)
=
=
EbtStruct
)
{
error
(
line
"
a
struct
cannot
be
used
as
a
constructor
argument
for
this
type
"
"
constructor
"
)
;
return
false
;
}
if
(
argTyped
-
>
getType
(
)
.
isArray
(
)
)
{
error
(
line
"
constructing
from
a
non
-
dereferenced
array
"
"
constructor
"
)
;
return
false
;
}
if
(
argTyped
-
>
getType
(
)
.
isMatrix
(
)
)
{
matrixArg
=
true
;
}
size
+
=
argTyped
-
>
getType
(
)
.
getObjectSize
(
)
;
if
(
full
)
{
overFull
=
true
;
}
if
(
size
>
=
type
.
getObjectSize
(
)
)
{
full
=
true
;
}
}
if
(
type
.
isMatrix
(
)
&
&
matrixArg
)
{
if
(
arguments
-
>
size
(
)
!
=
1
)
{
error
(
line
"
constructing
matrix
from
matrix
can
only
take
one
argument
"
"
constructor
"
)
;
return
false
;
}
}
else
{
if
(
size
!
=
1
&
&
size
<
type
.
getObjectSize
(
)
)
{
error
(
line
"
not
enough
data
provided
for
construction
"
"
constructor
"
)
;
return
false
;
}
if
(
overFull
)
{
error
(
line
"
too
many
arguments
"
"
constructor
"
)
;
return
false
;
}
}
}
return
true
;
}
bool
TParseContext
:
:
checkIsNonVoid
(
const
TSourceLoc
&
line
const
TString
&
identifier
const
TBasicType
&
type
)
{
if
(
type
=
=
EbtVoid
)
{
error
(
line
"
illegal
use
of
type
'
void
'
"
identifier
.
c_str
(
)
)
;
return
false
;
}
return
true
;
}
bool
TParseContext
:
:
checkIsScalarBool
(
const
TSourceLoc
&
line
const
TIntermTyped
*
type
)
{
if
(
type
-
>
getBasicType
(
)
!
=
EbtBool
|
|
!
type
-
>
isScalar
(
)
)
{
error
(
line
"
boolean
expression
expected
"
"
"
)
;
return
false
;
}
return
true
;
}
void
TParseContext
:
:
checkIsScalarBool
(
const
TSourceLoc
&
line
const
TPublicType
&
pType
)
{
if
(
pType
.
getBasicType
(
)
!
=
EbtBool
|
|
pType
.
isAggregate
(
)
)
{
error
(
line
"
boolean
expression
expected
"
"
"
)
;
}
}
bool
TParseContext
:
:
checkIsNotOpaqueType
(
const
TSourceLoc
&
line
const
TTypeSpecifierNonArray
&
pType
const
char
*
reason
)
{
if
(
pType
.
type
=
=
EbtStruct
)
{
if
(
ContainsSampler
(
pType
.
userDef
)
)
{
std
:
:
stringstream
reasonStream
;
reasonStream
<
<
reason
<
<
"
(
structure
contains
a
sampler
)
"
;
std
:
:
string
reasonStr
=
reasonStream
.
str
(
)
;
error
(
line
reasonStr
.
c_str
(
)
getBasicString
(
pType
.
type
)
)
;
return
false
;
}
return
true
;
}
else
if
(
IsOpaqueType
(
pType
.
type
)
)
{
error
(
line
reason
getBasicString
(
pType
.
type
)
)
;
return
false
;
}
return
true
;
}
void
TParseContext
:
:
checkDeclaratorLocationIsNotSpecified
(
const
TSourceLoc
&
line
const
TPublicType
&
pType
)
{
if
(
pType
.
layoutQualifier
.
location
!
=
-
1
)
{
error
(
line
"
location
must
only
be
specified
for
a
single
input
or
output
variable
"
"
location
"
)
;
}
}
void
TParseContext
:
:
checkLocationIsNotSpecified
(
const
TSourceLoc
&
location
const
TLayoutQualifier
&
layoutQualifier
)
{
if
(
layoutQualifier
.
location
!
=
-
1
)
{
const
char
*
errorMsg
=
"
invalid
layout
qualifier
:
only
valid
on
program
inputs
and
outputs
"
;
if
(
mShaderVersion
>
=
310
)
{
errorMsg
=
"
invalid
layout
qualifier
:
only
valid
on
shader
inputs
outputs
and
uniforms
"
;
}
error
(
location
errorMsg
"
location
"
)
;
}
}
void
TParseContext
:
:
checkOutParameterIsNotOpaqueType
(
const
TSourceLoc
&
line
TQualifier
qualifier
const
TType
&
type
)
{
ASSERT
(
qualifier
=
=
EvqOut
|
|
qualifier
=
=
EvqInOut
)
;
if
(
IsOpaqueType
(
type
.
getBasicType
(
)
)
)
{
error
(
line
"
opaque
types
cannot
be
output
parameters
"
type
.
getBasicString
(
)
)
;
}
}
unsigned
int
TParseContext
:
:
checkIsValidArraySize
(
const
TSourceLoc
&
line
TIntermTyped
*
expr
)
{
TIntermConstantUnion
*
constant
=
expr
-
>
getAsConstantUnion
(
)
;
if
(
expr
-
>
getQualifier
(
)
!
=
EvqConst
|
|
constant
=
=
nullptr
|
|
!
constant
-
>
isScalarInt
(
)
)
{
error
(
line
"
array
size
must
be
a
constant
integer
expression
"
"
"
)
;
return
1u
;
}
unsigned
int
size
=
0u
;
if
(
constant
-
>
getBasicType
(
)
=
=
EbtUInt
)
{
size
=
constant
-
>
getUConst
(
0
)
;
}
else
{
int
signedSize
=
constant
-
>
getIConst
(
0
)
;
if
(
signedSize
<
0
)
{
error
(
line
"
array
size
must
be
non
-
negative
"
"
"
)
;
return
1u
;
}
size
=
static_cast
<
unsigned
int
>
(
signedSize
)
;
}
if
(
size
=
=
0u
)
{
error
(
line
"
array
size
must
be
greater
than
zero
"
"
"
)
;
return
1u
;
}
const
unsigned
int
sizeLimit
=
65536
;
if
(
size
>
sizeLimit
)
{
error
(
line
"
array
size
too
large
"
"
"
)
;
return
1u
;
}
return
size
;
}
bool
TParseContext
:
:
checkIsValidQualifierForArray
(
const
TSourceLoc
&
line
const
TPublicType
&
elementQualifier
)
{
if
(
(
elementQualifier
.
qualifier
=
=
EvqAttribute
)
|
|
(
elementQualifier
.
qualifier
=
=
EvqVertexIn
)
|
|
(
elementQualifier
.
qualifier
=
=
EvqConst
&
&
mShaderVersion
<
300
)
)
{
error
(
line
"
cannot
declare
arrays
of
this
qualifier
"
TType
(
elementQualifier
)
.
getQualifierString
(
)
)
;
return
false
;
}
return
true
;
}
bool
TParseContext
:
:
checkArrayElementIsNotArray
(
const
TSourceLoc
&
line
const
TPublicType
&
elementType
)
{
if
(
elementType
.
array
)
{
error
(
line
"
cannot
declare
arrays
of
arrays
"
TType
(
elementType
)
.
getCompleteString
(
)
.
c_str
(
)
)
;
return
false
;
}
return
true
;
}
bool
TParseContext
:
:
checkIsValidTypeAndQualifierForArray
(
const
TSourceLoc
&
indexLocation
const
TPublicType
&
elementType
)
{
if
(
!
checkArrayElementIsNotArray
(
indexLocation
elementType
)
)
{
return
false
;
}
if
(
mShaderVersion
>
=
300
&
&
elementType
.
getBasicType
(
)
=
=
EbtStruct
&
&
sh
:
:
IsVarying
(
elementType
.
qualifier
)
)
{
error
(
indexLocation
"
cannot
declare
arrays
of
structs
of
this
qualifier
"
TType
(
elementType
)
.
getCompleteString
(
)
.
c_str
(
)
)
;
return
false
;
}
return
checkIsValidQualifierForArray
(
indexLocation
elementType
)
;
}
void
TParseContext
:
:
checkCanBeDeclaredWithoutInitializer
(
const
TSourceLoc
&
line
const
TString
&
identifier
TPublicType
*
type
)
{
ASSERT
(
type
!
=
nullptr
)
;
if
(
type
-
>
qualifier
=
=
EvqConst
)
{
type
-
>
qualifier
=
EvqTemporary
;
if
(
mShaderVersion
<
300
&
&
type
-
>
isStructureContainingArrays
(
)
)
{
error
(
line
"
structures
containing
arrays
may
not
be
declared
constant
since
they
cannot
be
"
"
initialized
"
identifier
.
c_str
(
)
)
;
}
else
{
error
(
line
"
variables
with
qualifier
'
const
'
must
be
initialized
"
identifier
.
c_str
(
)
)
;
}
return
;
}
if
(
type
-
>
isUnsizedArray
(
)
)
{
error
(
line
"
implicitly
sized
arrays
need
to
be
initialized
"
identifier
.
c_str
(
)
)
;
}
}
bool
TParseContext
:
:
declareVariable
(
const
TSourceLoc
&
line
const
TString
&
identifier
const
TType
&
type
TVariable
*
*
variable
)
{
ASSERT
(
(
*
variable
)
=
=
nullptr
)
;
checkBindingIsValid
(
line
type
)
;
bool
needsReservedCheck
=
true
;
if
(
type
.
isArray
(
)
&
&
identifier
.
compare
(
0
15
"
gl_LastFragData
"
)
=
=
0
)
{
const
TVariable
*
maxDrawBuffers
=
static_cast
<
const
TVariable
*
>
(
symbolTable
.
findBuiltIn
(
"
gl_MaxDrawBuffers
"
mShaderVersion
)
)
;
if
(
type
.
isArrayOfArrays
(
)
)
{
error
(
line
"
redeclaration
of
gl_LastFragData
as
an
array
of
arrays
"
identifier
.
c_str
(
)
)
;
return
false
;
}
else
if
(
static_cast
<
int
>
(
type
.
getOutermostArraySize
(
)
)
=
=
maxDrawBuffers
-
>
getConstPointer
(
)
-
>
getIConst
(
)
)
{
if
(
TSymbol
*
builtInSymbol
=
symbolTable
.
findBuiltIn
(
identifier
mShaderVersion
)
)
{
needsReservedCheck
=
!
checkCanUseExtension
(
line
builtInSymbol
-
>
getExtension
(
)
)
;
}
}
else
{
error
(
line
"
redeclaration
of
gl_LastFragData
with
size
!
=
gl_MaxDrawBuffers
"
identifier
.
c_str
(
)
)
;
return
false
;
}
}
if
(
needsReservedCheck
&
&
!
checkIsNotReserved
(
line
identifier
)
)
return
false
;
(
*
variable
)
=
symbolTable
.
declareVariable
(
&
identifier
type
)
;
if
(
!
(
*
variable
)
)
{
error
(
line
"
redefinition
"
identifier
.
c_str
(
)
)
;
return
false
;
}
if
(
!
checkIsNonVoid
(
line
identifier
type
.
getBasicType
(
)
)
)
return
false
;
return
true
;
}
void
TParseContext
:
:
checkIsParameterQualifierValid
(
const
TSourceLoc
&
line
const
TTypeQualifierBuilder
&
typeQualifierBuilder
TType
*
type
)
{
TTypeQualifier
typeQualifier
=
typeQualifierBuilder
.
getParameterTypeQualifier
(
mDiagnostics
)
;
if
(
typeQualifier
.
qualifier
=
=
EvqOut
|
|
typeQualifier
.
qualifier
=
=
EvqInOut
)
{
checkOutParameterIsNotOpaqueType
(
line
typeQualifier
.
qualifier
*
type
)
;
}
if
(
!
IsImage
(
type
-
>
getBasicType
(
)
)
)
{
checkMemoryQualifierIsNotSpecified
(
typeQualifier
.
memoryQualifier
line
)
;
}
else
{
type
-
>
setMemoryQualifier
(
typeQualifier
.
memoryQualifier
)
;
}
type
-
>
setQualifier
(
typeQualifier
.
qualifier
)
;
if
(
typeQualifier
.
precision
!
=
EbpUndefined
)
{
type
-
>
setPrecision
(
typeQualifier
.
precision
)
;
}
}
bool
TParseContext
:
:
checkCanUseExtension
(
const
TSourceLoc
&
line
TExtension
extension
)
{
ASSERT
(
extension
!
=
TExtension
:
:
UNDEFINED
)
;
const
TExtensionBehavior
&
extBehavior
=
extensionBehavior
(
)
;
TExtensionBehavior
:
:
const_iterator
iter
=
extBehavior
.
find
(
extension
)
;
if
(
iter
=
=
extBehavior
.
end
(
)
)
{
error
(
line
"
extension
is
not
supported
"
GetExtensionNameString
(
extension
)
)
;
return
false
;
}
if
(
iter
-
>
second
=
=
EBhDisable
|
|
iter
-
>
second
=
=
EBhUndefined
)
{
error
(
line
"
extension
is
disabled
"
GetExtensionNameString
(
extension
)
)
;
return
false
;
}
if
(
iter
-
>
second
=
=
EBhWarn
)
{
warning
(
line
"
extension
is
being
used
"
GetExtensionNameString
(
extension
)
)
;
return
true
;
}
return
true
;
}
void
TParseContext
:
:
declarationQualifierErrorCheck
(
const
sh
:
:
TQualifier
qualifier
const
sh
:
:
TLayoutQualifier
&
layoutQualifier
const
TSourceLoc
&
location
)
{
if
(
qualifier
=
=
EvqShared
&
&
!
layoutQualifier
.
isEmpty
(
)
)
{
error
(
location
"
Shared
memory
declarations
cannot
have
layout
specified
"
"
layout
"
)
;
}
if
(
layoutQualifier
.
matrixPacking
!
=
EmpUnspecified
)
{
error
(
location
"
layout
qualifier
only
valid
for
interface
blocks
"
getMatrixPackingString
(
layoutQualifier
.
matrixPacking
)
)
;
return
;
}
if
(
layoutQualifier
.
blockStorage
!
=
EbsUnspecified
)
{
error
(
location
"
layout
qualifier
only
valid
for
interface
blocks
"
getBlockStorageString
(
layoutQualifier
.
blockStorage
)
)
;
return
;
}
if
(
qualifier
=
=
EvqFragmentOut
)
{
if
(
layoutQualifier
.
location
!
=
-
1
&
&
layoutQualifier
.
yuv
=
=
true
)
{
error
(
location
"
invalid
layout
qualifier
combination
"
"
yuv
"
)
;
return
;
}
}
else
{
checkYuvIsNotSpecified
(
location
layoutQualifier
.
yuv
)
;
}
if
(
isExtensionEnabled
(
TExtension
:
:
OVR_multiview
)
&
&
mShaderVersion
<
300
&
&
qualifier
=
=
EvqVertexIn
)
{
error
(
location
"
storage
qualifier
supported
in
GLSL
ES
3
.
00
and
above
only
"
"
in
"
)
;
}
bool
canHaveLocation
=
qualifier
=
=
EvqVertexIn
|
|
qualifier
=
=
EvqFragmentOut
;
if
(
mShaderVersion
>
=
310
)
{
canHaveLocation
=
canHaveLocation
|
|
qualifier
=
=
EvqUniform
|
|
IsVarying
(
qualifier
)
;
}
if
(
!
canHaveLocation
)
{
checkLocationIsNotSpecified
(
location
layoutQualifier
)
;
}
}
void
TParseContext
:
:
atomicCounterQualifierErrorCheck
(
const
TPublicType
&
publicType
const
TSourceLoc
&
location
)
{
if
(
publicType
.
precision
!
=
EbpHigh
)
{
error
(
location
"
Can
only
be
highp
"
"
atomic
counter
"
)
;
}
if
(
publicType
.
layoutQualifier
.
location
!
=
-
1
)
{
error
(
location
"
location
must
not
be
set
for
atomic_uint
"
"
layout
"
)
;
}
if
(
publicType
.
layoutQualifier
.
binding
=
=
-
1
)
{
error
(
location
"
no
binding
specified
"
"
atomic
counter
"
)
;
}
}
void
TParseContext
:
:
emptyDeclarationErrorCheck
(
const
TPublicType
&
publicType
const
TSourceLoc
&
location
)
{
if
(
publicType
.
isUnsizedArray
(
)
)
{
error
(
location
"
empty
array
declaration
needs
to
specify
a
size
"
"
"
)
;
}
}
void
TParseContext
:
:
nonEmptyDeclarationErrorCheck
(
const
TPublicType
&
publicType
const
TSourceLoc
&
identifierLocation
)
{
switch
(
publicType
.
qualifier
)
{
case
EvqVaryingIn
:
case
EvqVaryingOut
:
case
EvqAttribute
:
case
EvqVertexIn
:
case
EvqFragmentOut
:
case
EvqComputeIn
:
if
(
publicType
.
getBasicType
(
)
=
=
EbtStruct
)
{
error
(
identifierLocation
"
cannot
be
used
with
a
structure
"
getQualifierString
(
publicType
.
qualifier
)
)
;
return
;
}
break
;
case
EvqBuffer
:
if
(
publicType
.
getBasicType
(
)
!
=
EbtInterfaceBlock
)
{
error
(
identifierLocation
"
cannot
declare
buffer
variables
at
global
scope
(
outside
a
block
)
"
getQualifierString
(
publicType
.
qualifier
)
)
;
return
;
}
break
;
default
:
break
;
}
std
:
:
string
reason
(
getBasicString
(
publicType
.
getBasicType
(
)
)
)
;
reason
+
=
"
s
must
be
uniform
"
;
if
(
publicType
.
qualifier
!
=
EvqUniform
&
&
!
checkIsNotOpaqueType
(
identifierLocation
publicType
.
typeSpecifierNonArray
reason
.
c_str
(
)
)
)
{
return
;
}
if
(
(
publicType
.
qualifier
!
=
EvqTemporary
&
&
publicType
.
qualifier
!
=
EvqGlobal
&
&
publicType
.
qualifier
!
=
EvqConst
)
&
&
publicType
.
getBasicType
(
)
=
=
EbtYuvCscStandardEXT
)
{
error
(
identifierLocation
"
cannot
be
used
with
a
yuvCscStandardEXT
"
getQualifierString
(
publicType
.
qualifier
)
)
;
return
;
}
if
(
mShaderVersion
>
=
310
&
&
publicType
.
qualifier
=
=
EvqUniform
)
{
if
(
!
publicType
.
isUnsizedArray
(
)
)
{
TType
type
(
publicType
)
;
checkUniformLocationInRange
(
identifierLocation
type
.
getLocationCount
(
)
publicType
.
layoutQualifier
)
;
}
}
const
TLayoutQualifier
layoutQualifier
=
publicType
.
layoutQualifier
;
if
(
IsImage
(
publicType
.
getBasicType
(
)
)
)
{
switch
(
layoutQualifier
.
imageInternalFormat
)
{
case
EiifRGBA32F
:
case
EiifRGBA16F
:
case
EiifR32F
:
case
EiifRGBA8
:
case
EiifRGBA8_SNORM
:
if
(
!
IsFloatImage
(
publicType
.
getBasicType
(
)
)
)
{
error
(
identifierLocation
"
internal
image
format
requires
a
floating
image
type
"
getBasicString
(
publicType
.
getBasicType
(
)
)
)
;
return
;
}
break
;
case
EiifRGBA32I
:
case
EiifRGBA16I
:
case
EiifRGBA8I
:
case
EiifR32I
:
if
(
!
IsIntegerImage
(
publicType
.
getBasicType
(
)
)
)
{
error
(
identifierLocation
"
internal
image
format
requires
an
integer
image
type
"
getBasicString
(
publicType
.
getBasicType
(
)
)
)
;
return
;
}
break
;
case
EiifRGBA32UI
:
case
EiifRGBA16UI
:
case
EiifRGBA8UI
:
case
EiifR32UI
:
if
(
!
IsUnsignedImage
(
publicType
.
getBasicType
(
)
)
)
{
error
(
identifierLocation
"
internal
image
format
requires
an
unsigned
image
type
"
getBasicString
(
publicType
.
getBasicType
(
)
)
)
;
return
;
}
break
;
case
EiifUnspecified
:
error
(
identifierLocation
"
layout
qualifier
"
"
No
image
internal
format
specified
"
)
;
return
;
default
:
error
(
identifierLocation
"
layout
qualifier
"
"
unrecognized
token
"
)
;
return
;
}
switch
(
layoutQualifier
.
imageInternalFormat
)
{
case
EiifR32F
:
case
EiifR32I
:
case
EiifR32UI
:
break
;
default
:
if
(
!
publicType
.
memoryQualifier
.
readonly
&
&
!
publicType
.
memoryQualifier
.
writeonly
)
{
error
(
identifierLocation
"
layout
qualifier
"
"
Except
for
images
with
the
r32f
r32i
and
r32ui
format
qualifiers
"
"
image
variables
must
be
qualified
readonly
and
/
or
writeonly
"
)
;
return
;
}
break
;
}
}
else
{
checkInternalFormatIsNotSpecified
(
identifierLocation
layoutQualifier
.
imageInternalFormat
)
;
checkMemoryQualifierIsNotSpecified
(
publicType
.
memoryQualifier
identifierLocation
)
;
}
if
(
IsAtomicCounter
(
publicType
.
getBasicType
(
)
)
)
{
atomicCounterQualifierErrorCheck
(
publicType
identifierLocation
)
;
}
else
{
checkOffsetIsNotSpecified
(
identifierLocation
layoutQualifier
.
offset
)
;
}
}
void
TParseContext
:
:
checkBindingIsValid
(
const
TSourceLoc
&
identifierLocation
const
TType
&
type
)
{
TLayoutQualifier
layoutQualifier
=
type
.
getLayoutQualifier
(
)
;
int
arrayTotalElementCount
=
type
.
getArraySizeProduct
(
)
;
if
(
IsImage
(
type
.
getBasicType
(
)
)
)
{
checkImageBindingIsValid
(
identifierLocation
layoutQualifier
.
binding
arrayTotalElementCount
)
;
}
else
if
(
IsSampler
(
type
.
getBasicType
(
)
)
)
{
checkSamplerBindingIsValid
(
identifierLocation
layoutQualifier
.
binding
arrayTotalElementCount
)
;
}
else
if
(
IsAtomicCounter
(
type
.
getBasicType
(
)
)
)
{
checkAtomicCounterBindingIsValid
(
identifierLocation
layoutQualifier
.
binding
)
;
}
else
{
ASSERT
(
!
IsOpaqueType
(
type
.
getBasicType
(
)
)
)
;
checkBindingIsNotSpecified
(
identifierLocation
layoutQualifier
.
binding
)
;
}
}
void
TParseContext
:
:
checkLayoutQualifierSupported
(
const
TSourceLoc
&
location
const
TString
&
layoutQualifierName
int
versionRequired
)
{
if
(
mShaderVersion
<
versionRequired
)
{
error
(
location
"
invalid
layout
qualifier
:
not
supported
"
layoutQualifierName
.
c_str
(
)
)
;
}
}
bool
TParseContext
:
:
checkWorkGroupSizeIsNotSpecified
(
const
TSourceLoc
&
location
const
TLayoutQualifier
&
layoutQualifier
)
{
const
sh
:
:
WorkGroupSize
&
localSize
=
layoutQualifier
.
localSize
;
for
(
size_t
i
=
0u
;
i
<
localSize
.
size
(
)
;
+
+
i
)
{
if
(
localSize
[
i
]
!
=
-
1
)
{
error
(
location
"
invalid
layout
qualifier
:
only
valid
when
used
with
'
in
'
in
a
compute
shader
"
"
global
layout
declaration
"
getWorkGroupSizeString
(
i
)
)
;
return
false
;
}
}
return
true
;
}
void
TParseContext
:
:
checkInternalFormatIsNotSpecified
(
const
TSourceLoc
&
location
TLayoutImageInternalFormat
internalFormat
)
{
if
(
internalFormat
!
=
EiifUnspecified
)
{
error
(
location
"
invalid
layout
qualifier
:
only
valid
when
used
with
images
"
getImageInternalFormatString
(
internalFormat
)
)
;
}
}
void
TParseContext
:
:
checkBindingIsNotSpecified
(
const
TSourceLoc
&
location
int
binding
)
{
if
(
binding
!
=
-
1
)
{
error
(
location
"
invalid
layout
qualifier
:
only
valid
when
used
with
opaque
types
or
blocks
"
"
binding
"
)
;
}
}
void
TParseContext
:
:
checkOffsetIsNotSpecified
(
const
TSourceLoc
&
location
int
offset
)
{
if
(
offset
!
=
-
1
)
{
error
(
location
"
invalid
layout
qualifier
:
only
valid
when
used
with
atomic
counters
"
"
offset
"
)
;
}
}
void
TParseContext
:
:
checkImageBindingIsValid
(
const
TSourceLoc
&
location
int
binding
int
arrayTotalElementCount
)
{
if
(
binding
>
=
0
&
&
binding
+
arrayTotalElementCount
>
mMaxImageUnits
)
{
error
(
location
"
image
binding
greater
than
gl_MaxImageUnits
"
"
binding
"
)
;
}
}
void
TParseContext
:
:
checkSamplerBindingIsValid
(
const
TSourceLoc
&
location
int
binding
int
arrayTotalElementCount
)
{
if
(
binding
>
=
0
&
&
binding
+
arrayTotalElementCount
>
mMaxCombinedTextureImageUnits
)
{
error
(
location
"
sampler
binding
greater
than
maximum
texture
units
"
"
binding
"
)
;
}
}
void
TParseContext
:
:
checkBlockBindingIsValid
(
const
TSourceLoc
&
location
const
TQualifier
&
qualifier
int
binding
int
arraySize
)
{
int
size
=
(
arraySize
=
=
0
?
1
:
arraySize
)
;
if
(
qualifier
=
=
EvqUniform
)
{
if
(
binding
+
size
>
mMaxUniformBufferBindings
)
{
error
(
location
"
uniform
block
binding
greater
than
MAX_UNIFORM_BUFFER_BINDINGS
"
"
binding
"
)
;
}
}
else
if
(
qualifier
=
=
EvqBuffer
)
{
if
(
binding
+
size
>
mMaxShaderStorageBufferBindings
)
{
error
(
location
"
shader
storage
block
binding
greater
than
MAX_SHADER_STORAGE_BUFFER_BINDINGS
"
"
binding
"
)
;
}
}
}
void
TParseContext
:
:
checkAtomicCounterBindingIsValid
(
const
TSourceLoc
&
location
int
binding
)
{
if
(
binding
>
=
mMaxAtomicCounterBindings
)
{
error
(
location
"
atomic
counter
binding
greater
than
gl_MaxAtomicCounterBindings
"
"
binding
"
)
;
}
}
void
TParseContext
:
:
checkUniformLocationInRange
(
const
TSourceLoc
&
location
int
objectLocationCount
const
TLayoutQualifier
&
layoutQualifier
)
{
int
loc
=
layoutQualifier
.
location
;
if
(
loc
>
=
0
&
&
loc
+
objectLocationCount
>
mMaxUniformLocations
)
{
error
(
location
"
Uniform
location
out
of
range
"
"
location
"
)
;
}
}
void
TParseContext
:
:
checkYuvIsNotSpecified
(
const
TSourceLoc
&
location
bool
yuv
)
{
if
(
yuv
!
=
false
)
{
error
(
location
"
invalid
layout
qualifier
:
only
valid
on
program
outputs
"
"
yuv
"
)
;
}
}
void
TParseContext
:
:
functionCallRValueLValueErrorCheck
(
const
TFunction
*
fnCandidate
TIntermAggregate
*
fnCall
)
{
for
(
size_t
i
=
0
;
i
<
fnCandidate
-
>
getParamCount
(
)
;
+
+
i
)
{
TQualifier
qual
=
fnCandidate
-
>
getParam
(
i
)
.
type
-
>
getQualifier
(
)
;
TIntermTyped
*
argument
=
(
*
(
fnCall
-
>
getSequence
(
)
)
)
[
i
]
-
>
getAsTyped
(
)
;
if
(
!
IsImage
(
argument
-
>
getBasicType
(
)
)
&
&
(
IsQualifierUnspecified
(
qual
)
|
|
qual
=
=
EvqIn
|
|
qual
=
=
EvqInOut
|
|
qual
=
=
EvqConstReadOnly
)
)
{
if
(
argument
-
>
getMemoryQualifier
(
)
.
writeonly
)
{
error
(
argument
-
>
getLine
(
)
"
Writeonly
value
cannot
be
passed
for
'
in
'
or
'
inout
'
parameters
.
"
fnCall
-
>
getFunctionSymbolInfo
(
)
-
>
getName
(
)
.
c_str
(
)
)
;
return
;
}
}
if
(
qual
=
=
EvqOut
|
|
qual
=
=
EvqInOut
)
{
if
(
!
checkCanBeLValue
(
argument
-
>
getLine
(
)
"
assign
"
argument
)
)
{
error
(
argument
-
>
getLine
(
)
"
Constant
value
cannot
be
passed
for
'
out
'
or
'
inout
'
parameters
.
"
fnCall
-
>
getFunctionSymbolInfo
(
)
-
>
getName
(
)
.
c_str
(
)
)
;
return
;
}
}
}
}
void
TParseContext
:
:
checkInvariantVariableQualifier
(
bool
invariant
const
TQualifier
qualifier
const
TSourceLoc
&
invariantLocation
)
{
if
(
!
invariant
)
return
;
if
(
mShaderVersion
<
300
)
{
if
(
!
sh
:
:
CanBeInvariantESSL1
(
qualifier
)
)
{
error
(
invariantLocation
"
Cannot
be
qualified
as
invariant
.
"
"
invariant
"
)
;
}
}
else
{
if
(
!
sh
:
:
CanBeInvariantESSL3OrGreater
(
qualifier
)
)
{
error
(
invariantLocation
"
Cannot
be
qualified
as
invariant
.
"
"
invariant
"
)
;
}
}
}
bool
TParseContext
:
:
supportsExtension
(
TExtension
extension
)
{
const
TExtensionBehavior
&
extbehavior
=
extensionBehavior
(
)
;
TExtensionBehavior
:
:
const_iterator
iter
=
extbehavior
.
find
(
extension
)
;
return
(
iter
!
=
extbehavior
.
end
(
)
)
;
}
bool
TParseContext
:
:
isExtensionEnabled
(
TExtension
extension
)
const
{
return
IsExtensionEnabled
(
extensionBehavior
(
)
extension
)
;
}
void
TParseContext
:
:
handleExtensionDirective
(
const
TSourceLoc
&
loc
const
char
*
extName
const
char
*
behavior
)
{
pp
:
:
SourceLocation
srcLoc
;
srcLoc
.
file
=
loc
.
first_file
;
srcLoc
.
line
=
loc
.
first_line
;
mDirectiveHandler
.
handleExtension
(
srcLoc
extName
behavior
)
;
}
void
TParseContext
:
:
handlePragmaDirective
(
const
TSourceLoc
&
loc
const
char
*
name
const
char
*
value
bool
stdgl
)
{
pp
:
:
SourceLocation
srcLoc
;
srcLoc
.
file
=
loc
.
first_file
;
srcLoc
.
line
=
loc
.
first_line
;
mDirectiveHandler
.
handlePragma
(
srcLoc
name
value
stdgl
)
;
}
sh
:
:
WorkGroupSize
TParseContext
:
:
getComputeShaderLocalSize
(
)
const
{
sh
:
:
WorkGroupSize
result
;
for
(
size_t
i
=
0u
;
i
<
result
.
size
(
)
;
+
+
i
)
{
if
(
mComputeShaderLocalSizeDeclared
&
&
mComputeShaderLocalSize
[
i
]
=
=
-
1
)
{
result
[
i
]
=
1
;
}
else
{
result
[
i
]
=
mComputeShaderLocalSize
[
i
]
;
}
}
return
result
;
}
TIntermConstantUnion
*
TParseContext
:
:
addScalarLiteral
(
const
TConstantUnion
*
constantUnion
const
TSourceLoc
&
line
)
{
TIntermConstantUnion
*
node
=
new
TIntermConstantUnion
(
constantUnion
TType
(
constantUnion
-
>
getType
(
)
EbpUndefined
EvqConst
)
)
;
node
-
>
setLine
(
line
)
;
return
node
;
}
const
TVariable
*
TParseContext
:
:
getNamedVariable
(
const
TSourceLoc
&
location
const
TString
*
name
const
TSymbol
*
symbol
)
{
if
(
!
symbol
)
{
error
(
location
"
undeclared
identifier
"
name
-
>
c_str
(
)
)
;
return
nullptr
;
}
if
(
!
symbol
-
>
isVariable
(
)
)
{
error
(
location
"
variable
expected
"
name
-
>
c_str
(
)
)
;
return
nullptr
;
}
const
TVariable
*
variable
=
static_cast
<
const
TVariable
*
>
(
symbol
)
;
if
(
variable
-
>
getExtension
(
)
!
=
TExtension
:
:
UNDEFINED
)
{
checkCanUseExtension
(
location
variable
-
>
getExtension
(
)
)
;
}
TQualifier
qualifier
=
variable
-
>
getType
(
)
.
getQualifier
(
)
;
if
(
qualifier
=
=
EvqFragData
|
|
qualifier
=
=
EvqSecondaryFragDataEXT
)
{
mUsesFragData
=
true
;
}
else
if
(
qualifier
=
=
EvqFragColor
|
|
qualifier
=
=
EvqSecondaryFragColorEXT
)
{
mUsesFragColor
=
true
;
}
if
(
qualifier
=
=
EvqSecondaryFragDataEXT
|
|
qualifier
=
=
EvqSecondaryFragColorEXT
)
{
mUsesSecondaryOutputs
=
true
;
}
if
(
mUsesFragData
&
&
mUsesFragColor
)
{
const
char
*
errorMessage
=
"
cannot
use
both
gl_FragData
and
gl_FragColor
"
;
if
(
mUsesSecondaryOutputs
)
{
errorMessage
=
"
cannot
use
both
output
variable
sets
(
gl_FragData
gl_SecondaryFragDataEXT
)
"
"
and
(
gl_FragColor
gl_SecondaryFragColorEXT
)
"
;
}
error
(
location
errorMessage
name
-
>
c_str
(
)
)
;
}
if
(
getShaderType
(
)
=
=
GL_COMPUTE_SHADER
&
&
!
mComputeShaderLocalSizeDeclared
&
&
qualifier
=
=
EvqWorkGroupSize
)
{
error
(
location
"
It
is
an
error
to
use
gl_WorkGroupSize
before
declaring
the
local
group
size
"
"
gl_WorkGroupSize
"
)
;
}
return
variable
;
}
TIntermTyped
*
TParseContext
:
:
parseVariableIdentifier
(
const
TSourceLoc
&
location
const
TString
*
name
const
TSymbol
*
symbol
)
{
const
TVariable
*
variable
=
getNamedVariable
(
location
name
symbol
)
;
if
(
!
variable
)
{
TIntermTyped
*
node
=
CreateZeroNode
(
TType
(
EbtFloat
EbpHigh
EvqConst
)
)
;
node
-
>
setLine
(
location
)
;
return
node
;
}
TIntermTyped
*
node
=
nullptr
;
if
(
variable
-
>
getConstPointer
(
)
)
{
const
TConstantUnion
*
constArray
=
variable
-
>
getConstPointer
(
)
;
node
=
new
TIntermConstantUnion
(
constArray
variable
-
>
getType
(
)
)
;
}
else
if
(
variable
-
>
getType
(
)
.
getQualifier
(
)
=
=
EvqWorkGroupSize
&
&
mComputeShaderLocalSizeDeclared
)
{
sh
:
:
WorkGroupSize
workGroupSize
=
getComputeShaderLocalSize
(
)
;
TConstantUnion
*
constArray
=
new
TConstantUnion
[
3
]
;
for
(
size_t
i
=
0
;
i
<
3
;
+
+
i
)
{
constArray
[
i
]
.
setUConst
(
static_cast
<
unsigned
int
>
(
workGroupSize
[
i
]
)
)
;
}
ASSERT
(
variable
-
>
getType
(
)
.
getBasicType
(
)
=
=
EbtUInt
)
;
ASSERT
(
variable
-
>
getType
(
)
.
getObjectSize
(
)
=
=
3
)
;
TType
type
(
variable
-
>
getType
(
)
)
;
type
.
setQualifier
(
EvqConst
)
;
node
=
new
TIntermConstantUnion
(
constArray
type
)
;
}
else
if
(
variable
-
>
getType
(
)
.
getQualifier
(
)
=
=
EvqPerVertexIn
)
{
TType
type
(
variable
-
>
getType
(
)
)
;
type
.
setArraySize
(
0
mGeometryShaderInputArraySize
)
;
node
=
new
TIntermSymbol
(
variable
-
>
getUniqueId
(
)
variable
-
>
getName
(
)
type
)
;
}
else
{
node
=
new
TIntermSymbol
(
variable
-
>
getUniqueId
(
)
variable
-
>
getName
(
)
variable
-
>
getType
(
)
)
;
}
ASSERT
(
node
!
=
nullptr
)
;
node
-
>
setLine
(
location
)
;
return
node
;
}
bool
TParseContext
:
:
executeInitializer
(
const
TSourceLoc
&
line
const
TString
&
identifier
const
TPublicType
&
pType
TIntermTyped
*
initializer
TIntermBinary
*
*
initNode
)
{
ASSERT
(
initNode
!
=
nullptr
)
;
ASSERT
(
*
initNode
=
=
nullptr
)
;
TType
type
=
TType
(
pType
)
;
TVariable
*
variable
=
nullptr
;
if
(
type
.
isUnsizedArray
(
)
)
{
type
.
sizeUnsizedArrays
(
initializer
-
>
getType
(
)
.
getArraySizes
(
)
)
;
}
if
(
!
declareVariable
(
line
identifier
type
&
variable
)
)
{
return
false
;
}
bool
globalInitWarning
=
false
;
if
(
symbolTable
.
atGlobalLevel
(
)
&
&
!
ValidateGlobalInitializer
(
initializer
this
&
globalInitWarning
)
)
{
error
(
line
"
global
variable
initializers
must
be
constant
expressions
"
"
=
"
)
;
return
false
;
}
if
(
globalInitWarning
)
{
warning
(
line
"
global
variable
initializers
should
be
constant
expressions
"
"
(
uniforms
and
globals
are
allowed
in
global
initializers
for
legacy
compatibility
)
"
"
=
"
)
;
}
TQualifier
qualifier
=
variable
-
>
getType
(
)
.
getQualifier
(
)
;
if
(
(
qualifier
!
=
EvqTemporary
)
&
&
(
qualifier
!
=
EvqGlobal
)
&
&
(
qualifier
!
=
EvqConst
)
)
{
error
(
line
"
cannot
initialize
this
type
of
qualifier
"
variable
-
>
getType
(
)
.
getQualifierString
(
)
)
;
return
false
;
}
if
(
qualifier
=
=
EvqConst
)
{
if
(
qualifier
!
=
initializer
-
>
getType
(
)
.
getQualifier
(
)
)
{
std
:
:
stringstream
reasonStream
;
reasonStream
<
<
"
assigning
non
-
constant
to
'
"
<
<
variable
-
>
getType
(
)
.
getCompleteString
(
)
<
<
"
'
"
;
std
:
:
string
reason
=
reasonStream
.
str
(
)
;
error
(
line
reason
.
c_str
(
)
"
=
"
)
;
variable
-
>
getType
(
)
.
setQualifier
(
EvqTemporary
)
;
return
false
;
}
if
(
type
!
=
initializer
-
>
getType
(
)
)
{
error
(
line
"
non
-
matching
types
for
const
initializer
"
variable
-
>
getType
(
)
.
getQualifierString
(
)
)
;
variable
-
>
getType
(
)
.
setQualifier
(
EvqTemporary
)
;
return
false
;
}
if
(
initializer
-
>
getAsConstantUnion
(
)
)
{
variable
-
>
shareConstPointer
(
initializer
-
>
getAsConstantUnion
(
)
-
>
getUnionArrayPointer
(
)
)
;
ASSERT
(
*
initNode
=
=
nullptr
)
;
return
true
;
}
else
if
(
initializer
-
>
getAsSymbolNode
(
)
)
{
const
TSymbol
*
symbol
=
symbolTable
.
find
(
initializer
-
>
getAsSymbolNode
(
)
-
>
getSymbol
(
)
0
)
;
const
TVariable
*
tVar
=
static_cast
<
const
TVariable
*
>
(
symbol
)
;
const
TConstantUnion
*
constArray
=
tVar
-
>
getConstPointer
(
)
;
if
(
constArray
)
{
variable
-
>
shareConstPointer
(
constArray
)
;
ASSERT
(
*
initNode
=
=
nullptr
)
;
return
true
;
}
}
}
TIntermSymbol
*
intermSymbol
=
new
TIntermSymbol
(
variable
-
>
getUniqueId
(
)
variable
-
>
getName
(
)
variable
-
>
getType
(
)
)
;
intermSymbol
-
>
setLine
(
line
)
;
*
initNode
=
createAssign
(
EOpInitialize
intermSymbol
initializer
line
)
;
if
(
*
initNode
=
=
nullptr
)
{
assignError
(
line
"
=
"
intermSymbol
-
>
getCompleteString
(
)
initializer
-
>
getCompleteString
(
)
)
;
return
false
;
}
return
true
;
}
TIntermNode
*
TParseContext
:
:
addConditionInitializer
(
const
TPublicType
&
pType
const
TString
&
identifier
TIntermTyped
*
initializer
const
TSourceLoc
&
loc
)
{
checkIsScalarBool
(
loc
pType
)
;
TIntermBinary
*
initNode
=
nullptr
;
if
(
executeInitializer
(
loc
identifier
pType
initializer
&
initNode
)
)
{
if
(
initNode
=
=
nullptr
)
{
return
initializer
;
}
else
{
TIntermDeclaration
*
declaration
=
new
TIntermDeclaration
(
)
;
declaration
-
>
appendDeclarator
(
initNode
)
;
return
declaration
;
}
}
return
nullptr
;
}
TIntermNode
*
TParseContext
:
:
addLoop
(
TLoopType
type
TIntermNode
*
init
TIntermNode
*
cond
TIntermTyped
*
expr
TIntermNode
*
body
const
TSourceLoc
&
line
)
{
TIntermNode
*
node
=
nullptr
;
TIntermTyped
*
typedCond
=
nullptr
;
if
(
cond
)
{
typedCond
=
cond
-
>
getAsTyped
(
)
;
}
if
(
cond
=
=
nullptr
|
|
typedCond
)
{
if
(
type
=
=
ELoopDoWhile
)
{
checkIsScalarBool
(
line
typedCond
)
;
}
ASSERT
(
mDiagnostics
-
>
numErrors
(
)
>
0
|
|
typedCond
=
=
nullptr
|
|
(
typedCond
-
>
getBasicType
(
)
=
=
EbtBool
&
&
!
typedCond
-
>
isArray
(
)
&
&
!
typedCond
-
>
isVector
(
)
)
)
;
node
=
new
TIntermLoop
(
type
init
typedCond
expr
EnsureBlock
(
body
)
)
;
node
-
>
setLine
(
line
)
;
return
node
;
}
ASSERT
(
type
!
=
ELoopDoWhile
)
;
TIntermDeclaration
*
declaration
=
cond
-
>
getAsDeclarationNode
(
)
;
ASSERT
(
declaration
)
;
TIntermBinary
*
declarator
=
declaration
-
>
getSequence
(
)
-
>
front
(
)
-
>
getAsBinaryNode
(
)
;
ASSERT
(
declarator
-
>
getLeft
(
)
-
>
getAsSymbolNode
(
)
)
;
TIntermBlock
*
block
=
new
TIntermBlock
(
)
;
TIntermDeclaration
*
declareCondition
=
new
TIntermDeclaration
(
)
;
declareCondition
-
>
appendDeclarator
(
declarator
-
>
getLeft
(
)
-
>
deepCopy
(
)
)
;
block
-
>
appendStatement
(
declareCondition
)
;
TIntermBinary
*
conditionInit
=
new
TIntermBinary
(
EOpAssign
declarator
-
>
getLeft
(
)
-
>
deepCopy
(
)
declarator
-
>
getRight
(
)
-
>
deepCopy
(
)
)
;
TIntermLoop
*
loop
=
new
TIntermLoop
(
type
init
conditionInit
expr
EnsureBlock
(
body
)
)
;
block
-
>
appendStatement
(
loop
)
;
loop
-
>
setLine
(
line
)
;
block
-
>
setLine
(
line
)
;
return
block
;
}
TIntermNode
*
TParseContext
:
:
addIfElse
(
TIntermTyped
*
cond
TIntermNodePair
code
const
TSourceLoc
&
loc
)
{
bool
isScalarBool
=
checkIsScalarBool
(
loc
cond
)
;
if
(
isScalarBool
&
&
cond
-
>
getAsConstantUnion
(
)
)
{
if
(
cond
-
>
getAsConstantUnion
(
)
-
>
getBConst
(
0
)
=
=
true
)
{
return
EnsureBlock
(
code
.
node1
)
;
}
else
{
return
EnsureBlock
(
code
.
node2
)
;
}
}
TIntermIfElse
*
node
=
new
TIntermIfElse
(
cond
EnsureBlock
(
code
.
node1
)
EnsureBlock
(
code
.
node2
)
)
;
node
-
>
setLine
(
loc
)
;
return
node
;
}
void
TParseContext
:
:
addFullySpecifiedType
(
TPublicType
*
typeSpecifier
)
{
checkPrecisionSpecified
(
typeSpecifier
-
>
getLine
(
)
typeSpecifier
-
>
precision
typeSpecifier
-
>
getBasicType
(
)
)
;
if
(
mShaderVersion
<
300
&
&
typeSpecifier
-
>
array
)
{
error
(
typeSpecifier
-
>
getLine
(
)
"
not
supported
"
"
first
-
class
array
"
)
;
typeSpecifier
-
>
clearArrayness
(
)
;
}
}
TPublicType
TParseContext
:
:
addFullySpecifiedType
(
const
TTypeQualifierBuilder
&
typeQualifierBuilder
const
TPublicType
&
typeSpecifier
)
{
TTypeQualifier
typeQualifier
=
typeQualifierBuilder
.
getVariableTypeQualifier
(
mDiagnostics
)
;
TPublicType
returnType
=
typeSpecifier
;
returnType
.
qualifier
=
typeQualifier
.
qualifier
;
returnType
.
invariant
=
typeQualifier
.
invariant
;
returnType
.
layoutQualifier
=
typeQualifier
.
layoutQualifier
;
returnType
.
memoryQualifier
=
typeQualifier
.
memoryQualifier
;
returnType
.
precision
=
typeSpecifier
.
precision
;
if
(
typeQualifier
.
precision
!
=
EbpUndefined
)
{
returnType
.
precision
=
typeQualifier
.
precision
;
}
checkPrecisionSpecified
(
typeSpecifier
.
getLine
(
)
returnType
.
precision
typeSpecifier
.
getBasicType
(
)
)
;
checkInvariantVariableQualifier
(
returnType
.
invariant
returnType
.
qualifier
typeSpecifier
.
getLine
(
)
)
;
checkWorkGroupSizeIsNotSpecified
(
typeSpecifier
.
getLine
(
)
returnType
.
layoutQualifier
)
;
if
(
mShaderVersion
<
300
)
{
if
(
typeSpecifier
.
array
)
{
error
(
typeSpecifier
.
getLine
(
)
"
not
supported
"
"
first
-
class
array
"
)
;
returnType
.
clearArrayness
(
)
;
}
if
(
returnType
.
qualifier
=
=
EvqAttribute
&
&
(
typeSpecifier
.
getBasicType
(
)
=
=
EbtBool
|
|
typeSpecifier
.
getBasicType
(
)
=
=
EbtInt
)
)
{
error
(
typeSpecifier
.
getLine
(
)
"
cannot
be
bool
or
int
"
getQualifierString
(
returnType
.
qualifier
)
)
;
}
if
(
(
returnType
.
qualifier
=
=
EvqVaryingIn
|
|
returnType
.
qualifier
=
=
EvqVaryingOut
)
&
&
(
typeSpecifier
.
getBasicType
(
)
=
=
EbtBool
|
|
typeSpecifier
.
getBasicType
(
)
=
=
EbtInt
)
)
{
error
(
typeSpecifier
.
getLine
(
)
"
cannot
be
bool
or
int
"
getQualifierString
(
returnType
.
qualifier
)
)
;
}
}
else
{
if
(
!
returnType
.
layoutQualifier
.
isEmpty
(
)
)
{
checkIsAtGlobalLevel
(
typeSpecifier
.
getLine
(
)
"
layout
"
)
;
}
if
(
sh
:
:
IsVarying
(
returnType
.
qualifier
)
|
|
returnType
.
qualifier
=
=
EvqVertexIn
|
|
returnType
.
qualifier
=
=
EvqFragmentOut
)
{
checkInputOutputTypeIsValidES3
(
returnType
.
qualifier
typeSpecifier
typeSpecifier
.
getLine
(
)
)
;
}
if
(
returnType
.
qualifier
=
=
EvqComputeIn
)
{
error
(
typeSpecifier
.
getLine
(
)
"
'
in
'
can
be
only
used
to
specify
the
local
group
size
"
"
in
"
)
;
}
}
return
returnType
;
}
void
TParseContext
:
:
checkInputOutputTypeIsValidES3
(
const
TQualifier
qualifier
const
TPublicType
&
type
const
TSourceLoc
&
qualifierLocation
)
{
if
(
type
.
getBasicType
(
)
=
=
EbtBool
)
{
error
(
qualifierLocation
"
cannot
be
bool
"
getQualifierString
(
qualifier
)
)
;
}
switch
(
qualifier
)
{
case
EvqVertexIn
:
if
(
type
.
array
)
{
error
(
qualifierLocation
"
cannot
be
array
"
getQualifierString
(
qualifier
)
)
;
}
return
;
case
EvqFragmentOut
:
if
(
type
.
typeSpecifierNonArray
.
isMatrix
(
)
)
{
error
(
qualifierLocation
"
cannot
be
matrix
"
getQualifierString
(
qualifier
)
)
;
}
return
;
default
:
break
;
}
bool
typeContainsIntegers
=
(
type
.
getBasicType
(
)
=
=
EbtInt
|
|
type
.
getBasicType
(
)
=
=
EbtUInt
|
|
type
.
isStructureContainingType
(
EbtInt
)
|
|
type
.
isStructureContainingType
(
EbtUInt
)
)
;
if
(
typeContainsIntegers
&
&
qualifier
!
=
EvqFlatIn
&
&
qualifier
!
=
EvqFlatOut
)
{
error
(
qualifierLocation
"
must
use
'
flat
'
interpolation
here
"
getQualifierString
(
qualifier
)
)
;
}
if
(
type
.
getBasicType
(
)
=
=
EbtStruct
)
{
if
(
type
.
array
)
{
error
(
qualifierLocation
"
cannot
be
an
array
of
structures
"
getQualifierString
(
qualifier
)
)
;
}
if
(
type
.
isStructureContainingArrays
(
)
)
{
error
(
qualifierLocation
"
cannot
be
a
structure
containing
an
array
"
getQualifierString
(
qualifier
)
)
;
}
if
(
type
.
isStructureContainingType
(
EbtStruct
)
)
{
error
(
qualifierLocation
"
cannot
be
a
structure
containing
a
structure
"
getQualifierString
(
qualifier
)
)
;
}
if
(
type
.
isStructureContainingType
(
EbtBool
)
)
{
error
(
qualifierLocation
"
cannot
be
a
structure
containing
a
bool
"
getQualifierString
(
qualifier
)
)
;
}
}
}
void
TParseContext
:
:
checkLocalVariableConstStorageQualifier
(
const
TQualifierWrapperBase
&
qualifier
)
{
if
(
qualifier
.
getType
(
)
=
=
QtStorage
)
{
const
TStorageQualifierWrapper
&
storageQualifier
=
static_cast
<
const
TStorageQualifierWrapper
&
>
(
qualifier
)
;
if
(
!
declaringFunction
(
)
&
&
storageQualifier
.
getQualifier
(
)
!
=
EvqConst
&
&
!
symbolTable
.
atGlobalLevel
(
)
)
{
error
(
storageQualifier
.
getLine
(
)
"
Local
variables
can
only
use
the
const
storage
qualifier
.
"
storageQualifier
.
getQualifierString
(
)
.
c_str
(
)
)
;
}
}
}
void
TParseContext
:
:
checkMemoryQualifierIsNotSpecified
(
const
TMemoryQualifier
&
memoryQualifier
const
TSourceLoc
&
location
)
{
const
std
:
:
string
reason
(
"
Only
allowed
with
shader
storage
blocks
variables
declared
within
shader
storage
blocks
"
"
and
variables
declared
as
image
types
.
"
)
;
if
(
memoryQualifier
.
readonly
)
{
error
(
location
reason
.
c_str
(
)
"
readonly
"
)
;
}
if
(
memoryQualifier
.
writeonly
)
{
error
(
location
reason
.
c_str
(
)
"
writeonly
"
)
;
}
if
(
memoryQualifier
.
coherent
)
{
error
(
location
reason
.
c_str
(
)
"
coherent
"
)
;
}
if
(
memoryQualifier
.
restrictQualifier
)
{
error
(
location
reason
.
c_str
(
)
"
restrict
"
)
;
}
if
(
memoryQualifier
.
volatileQualifier
)
{
error
(
location
reason
.
c_str
(
)
"
volatile
"
)
;
}
}
void
TParseContext
:
:
checkAtomicCounterOffsetIsNotOverlapped
(
TPublicType
&
publicType
size_t
size
bool
forceAppend
const
TSourceLoc
&
loc
TType
&
type
)
{
auto
&
bindingState
=
mAtomicCounterBindingStates
[
publicType
.
layoutQualifier
.
binding
]
;
int
offset
;
if
(
publicType
.
layoutQualifier
.
offset
=
=
-
1
|
|
forceAppend
)
{
offset
=
bindingState
.
appendSpan
(
size
)
;
}
else
{
offset
=
bindingState
.
insertSpan
(
publicType
.
layoutQualifier
.
offset
size
)
;
}
if
(
offset
=
=
-
1
)
{
error
(
loc
"
Offset
overlapping
"
"
atomic
counter
"
)
;
return
;
}
TLayoutQualifier
qualifier
=
type
.
getLayoutQualifier
(
)
;
qualifier
.
offset
=
offset
;
type
.
setLayoutQualifier
(
qualifier
)
;
}
TIntermDeclaration
*
TParseContext
:
:
parseSingleDeclaration
(
TPublicType
&
publicType
const
TSourceLoc
&
identifierOrTypeLocation
const
TString
&
identifier
)
{
TType
type
(
publicType
)
;
if
(
(
mCompileOptions
&
SH_FLATTEN_PRAGMA_STDGL_INVARIANT_ALL
)
&
&
mDirectiveHandler
.
pragma
(
)
.
stdgl
.
invariantAll
)
{
TQualifier
qualifier
=
type
.
getQualifier
(
)
;
if
(
qualifier
=
=
EvqVaryingOut
|
|
qualifier
=
=
EvqVertexOut
|
|
qualifier
=
=
EvqVaryingIn
)
{
type
.
setInvariant
(
true
)
;
}
}
declarationQualifierErrorCheck
(
publicType
.
qualifier
publicType
.
layoutQualifier
identifierOrTypeLocation
)
;
bool
emptyDeclaration
=
(
identifier
=
=
"
"
)
;
mDeferredNonEmptyDeclarationErrorCheck
=
emptyDeclaration
;
TIntermSymbol
*
symbol
=
nullptr
;
if
(
emptyDeclaration
)
{
emptyDeclarationErrorCheck
(
publicType
identifierOrTypeLocation
)
;
if
(
type
.
getBasicType
(
)
=
=
EbtStruct
)
{
symbol
=
new
TIntermSymbol
(
0
"
"
type
)
;
}
else
if
(
IsAtomicCounter
(
publicType
.
getBasicType
(
)
)
)
{
setAtomicCounterBindingDefaultOffset
(
publicType
identifierOrTypeLocation
)
;
}
}
else
{
nonEmptyDeclarationErrorCheck
(
publicType
identifierOrTypeLocation
)
;
checkCanBeDeclaredWithoutInitializer
(
identifierOrTypeLocation
identifier
&
publicType
)
;
if
(
IsAtomicCounter
(
publicType
.
getBasicType
(
)
)
)
{
checkAtomicCounterOffsetIsNotOverlapped
(
publicType
kAtomicCounterSize
false
identifierOrTypeLocation
type
)
;
}
TVariable
*
variable
=
nullptr
;
declareVariable
(
identifierOrTypeLocation
identifier
type
&
variable
)
;
if
(
variable
)
{
symbol
=
new
TIntermSymbol
(
variable
-
>
getUniqueId
(
)
identifier
type
)
;
}
}
TIntermDeclaration
*
declaration
=
new
TIntermDeclaration
(
)
;
declaration
-
>
setLine
(
identifierOrTypeLocation
)
;
if
(
symbol
)
{
symbol
-
>
setLine
(
identifierOrTypeLocation
)
;
declaration
-
>
appendDeclarator
(
symbol
)
;
}
return
declaration
;
}
TIntermDeclaration
*
TParseContext
:
:
parseSingleArrayDeclaration
(
TPublicType
&
publicType
const
TSourceLoc
&
identifierLocation
const
TString
&
identifier
const
TSourceLoc
&
indexLocation
TIntermTyped
*
indexExpression
)
{
mDeferredNonEmptyDeclarationErrorCheck
=
false
;
declarationQualifierErrorCheck
(
publicType
.
qualifier
publicType
.
layoutQualifier
identifierLocation
)
;
nonEmptyDeclarationErrorCheck
(
publicType
identifierLocation
)
;
checkCanBeDeclaredWithoutInitializer
(
identifierLocation
identifier
&
publicType
)
;
checkIsValidTypeAndQualifierForArray
(
indexLocation
publicType
)
;
TType
arrayType
(
publicType
)
;
unsigned
int
size
=
checkIsValidArraySize
(
identifierLocation
indexExpression
)
;
arrayType
.
makeArray
(
size
)
;
if
(
IsAtomicCounter
(
publicType
.
getBasicType
(
)
)
)
{
checkAtomicCounterOffsetIsNotOverlapped
(
publicType
kAtomicCounterArrayStride
*
size
false
identifierLocation
arrayType
)
;
}
TVariable
*
variable
=
nullptr
;
declareVariable
(
identifierLocation
identifier
arrayType
&
variable
)
;
TIntermDeclaration
*
declaration
=
new
TIntermDeclaration
(
)
;
declaration
-
>
setLine
(
identifierLocation
)
;
if
(
variable
)
{
TIntermSymbol
*
symbol
=
new
TIntermSymbol
(
variable
-
>
getUniqueId
(
)
identifier
arrayType
)
;
symbol
-
>
setLine
(
identifierLocation
)
;
declaration
-
>
appendDeclarator
(
symbol
)
;
}
return
declaration
;
}
TIntermDeclaration
*
TParseContext
:
:
parseSingleInitDeclaration
(
const
TPublicType
&
publicType
const
TSourceLoc
&
identifierLocation
const
TString
&
identifier
const
TSourceLoc
&
initLocation
TIntermTyped
*
initializer
)
{
mDeferredNonEmptyDeclarationErrorCheck
=
false
;
declarationQualifierErrorCheck
(
publicType
.
qualifier
publicType
.
layoutQualifier
identifierLocation
)
;
nonEmptyDeclarationErrorCheck
(
publicType
identifierLocation
)
;
TIntermDeclaration
*
declaration
=
new
TIntermDeclaration
(
)
;
declaration
-
>
setLine
(
identifierLocation
)
;
TIntermBinary
*
initNode
=
nullptr
;
if
(
executeInitializer
(
identifierLocation
identifier
publicType
initializer
&
initNode
)
)
{
if
(
initNode
)
{
declaration
-
>
appendDeclarator
(
initNode
)
;
}
}
return
declaration
;
}
TIntermDeclaration
*
TParseContext
:
:
parseSingleArrayInitDeclaration
(
TPublicType
&
publicType
const
TSourceLoc
&
identifierLocation
const
TString
&
identifier
const
TSourceLoc
&
indexLocation
TIntermTyped
*
indexExpression
const
TSourceLoc
&
initLocation
TIntermTyped
*
initializer
)
{
mDeferredNonEmptyDeclarationErrorCheck
=
false
;
declarationQualifierErrorCheck
(
publicType
.
qualifier
publicType
.
layoutQualifier
identifierLocation
)
;
nonEmptyDeclarationErrorCheck
(
publicType
identifierLocation
)
;
checkIsValidTypeAndQualifierForArray
(
indexLocation
publicType
)
;
TPublicType
arrayType
(
publicType
)
;
unsigned
int
size
=
0u
;
if
(
indexExpression
!
=
nullptr
)
{
size
=
checkIsValidArraySize
(
identifierLocation
indexExpression
)
;
}
arrayType
.
setArraySize
(
size
)
;
TIntermDeclaration
*
declaration
=
new
TIntermDeclaration
(
)
;
declaration
-
>
setLine
(
identifierLocation
)
;
TIntermBinary
*
initNode
=
nullptr
;
if
(
executeInitializer
(
identifierLocation
identifier
arrayType
initializer
&
initNode
)
)
{
if
(
initNode
)
{
declaration
-
>
appendDeclarator
(
initNode
)
;
}
}
return
declaration
;
}
TIntermInvariantDeclaration
*
TParseContext
:
:
parseInvariantDeclaration
(
const
TTypeQualifierBuilder
&
typeQualifierBuilder
const
TSourceLoc
&
identifierLoc
const
TString
*
identifier
const
TSymbol
*
symbol
)
{
TTypeQualifier
typeQualifier
=
typeQualifierBuilder
.
getVariableTypeQualifier
(
mDiagnostics
)
;
if
(
!
typeQualifier
.
invariant
)
{
error
(
identifierLoc
"
Expected
invariant
"
identifier
-
>
c_str
(
)
)
;
return
nullptr
;
}
if
(
!
checkIsAtGlobalLevel
(
identifierLoc
"
invariant
varying
"
)
)
{
return
nullptr
;
}
if
(
!
symbol
)
{
error
(
identifierLoc
"
undeclared
identifier
declared
as
invariant
"
identifier
-
>
c_str
(
)
)
;
return
nullptr
;
}
if
(
!
IsQualifierUnspecified
(
typeQualifier
.
qualifier
)
)
{
error
(
identifierLoc
"
invariant
declaration
specifies
qualifier
"
getQualifierString
(
typeQualifier
.
qualifier
)
)
;
}
if
(
typeQualifier
.
precision
!
=
EbpUndefined
)
{
error
(
identifierLoc
"
invariant
declaration
specifies
precision
"
getPrecisionString
(
typeQualifier
.
precision
)
)
;
}
if
(
!
typeQualifier
.
layoutQualifier
.
isEmpty
(
)
)
{
error
(
identifierLoc
"
invariant
declaration
specifies
layout
"
"
'
layout
'
"
)
;
}
const
TVariable
*
variable
=
getNamedVariable
(
identifierLoc
identifier
symbol
)
;
if
(
!
variable
)
{
return
nullptr
;
}
const
TType
&
type
=
variable
-
>
getType
(
)
;
checkInvariantVariableQualifier
(
typeQualifier
.
invariant
type
.
getQualifier
(
)
typeQualifier
.
line
)
;
checkMemoryQualifierIsNotSpecified
(
typeQualifier
.
memoryQualifier
typeQualifier
.
line
)
;
symbolTable
.
addInvariantVarying
(
std
:
:
string
(
identifier
-
>
c_str
(
)
)
)
;
TIntermSymbol
*
intermSymbol
=
new
TIntermSymbol
(
variable
-
>
getUniqueId
(
)
*
identifier
type
)
;
intermSymbol
-
>
setLine
(
identifierLoc
)
;
return
new
TIntermInvariantDeclaration
(
intermSymbol
identifierLoc
)
;
}
void
TParseContext
:
:
parseDeclarator
(
TPublicType
&
publicType
const
TSourceLoc
&
identifierLocation
const
TString
&
identifier
TIntermDeclaration
*
declarationOut
)
{
if
(
mDeferredNonEmptyDeclarationErrorCheck
)
{
nonEmptyDeclarationErrorCheck
(
publicType
identifierLocation
)
;
mDeferredNonEmptyDeclarationErrorCheck
=
false
;
}
checkDeclaratorLocationIsNotSpecified
(
identifierLocation
publicType
)
;
checkCanBeDeclaredWithoutInitializer
(
identifierLocation
identifier
&
publicType
)
;
TVariable
*
variable
=
nullptr
;
TType
type
(
publicType
)
;
if
(
IsAtomicCounter
(
publicType
.
getBasicType
(
)
)
)
{
checkAtomicCounterOffsetIsNotOverlapped
(
publicType
kAtomicCounterSize
true
identifierLocation
type
)
;
}
declareVariable
(
identifierLocation
identifier
type
&
variable
)
;
if
(
variable
)
{
TIntermSymbol
*
symbol
=
new
TIntermSymbol
(
variable
-
>
getUniqueId
(
)
identifier
type
)
;
symbol
-
>
setLine
(
identifierLocation
)
;
declarationOut
-
>
appendDeclarator
(
symbol
)
;
}
}
void
TParseContext
:
:
parseArrayDeclarator
(
TPublicType
&
publicType
const
TSourceLoc
&
identifierLocation
const
TString
&
identifier
const
TSourceLoc
&
arrayLocation
TIntermTyped
*
indexExpression
TIntermDeclaration
*
declarationOut
)
{
if
(
mDeferredNonEmptyDeclarationErrorCheck
)
{
nonEmptyDeclarationErrorCheck
(
publicType
identifierLocation
)
;
mDeferredNonEmptyDeclarationErrorCheck
=
false
;
}
checkDeclaratorLocationIsNotSpecified
(
identifierLocation
publicType
)
;
checkCanBeDeclaredWithoutInitializer
(
identifierLocation
identifier
&
publicType
)
;
if
(
checkIsValidTypeAndQualifierForArray
(
arrayLocation
publicType
)
)
{
TType
arrayType
=
TType
(
publicType
)
;
unsigned
int
size
=
checkIsValidArraySize
(
arrayLocation
indexExpression
)
;
arrayType
.
makeArray
(
size
)
;
if
(
IsAtomicCounter
(
publicType
.
getBasicType
(
)
)
)
{
checkAtomicCounterOffsetIsNotOverlapped
(
publicType
kAtomicCounterArrayStride
*
size
true
identifierLocation
arrayType
)
;
}
TVariable
*
variable
=
nullptr
;
declareVariable
(
identifierLocation
identifier
arrayType
&
variable
)
;
if
(
variable
)
{
TIntermSymbol
*
symbol
=
new
TIntermSymbol
(
variable
-
>
getUniqueId
(
)
identifier
arrayType
)
;
symbol
-
>
setLine
(
identifierLocation
)
;
declarationOut
-
>
appendDeclarator
(
symbol
)
;
}
}
}
void
TParseContext
:
:
parseInitDeclarator
(
const
TPublicType
&
publicType
const
TSourceLoc
&
identifierLocation
const
TString
&
identifier
const
TSourceLoc
&
initLocation
TIntermTyped
*
initializer
TIntermDeclaration
*
declarationOut
)
{
if
(
mDeferredNonEmptyDeclarationErrorCheck
)
{
nonEmptyDeclarationErrorCheck
(
publicType
identifierLocation
)
;
mDeferredNonEmptyDeclarationErrorCheck
=
false
;
}
checkDeclaratorLocationIsNotSpecified
(
identifierLocation
publicType
)
;
TIntermBinary
*
initNode
=
nullptr
;
if
(
executeInitializer
(
identifierLocation
identifier
publicType
initializer
&
initNode
)
)
{
if
(
initNode
)
{
declarationOut
-
>
appendDeclarator
(
initNode
)
;
}
}
}
void
TParseContext
:
:
parseArrayInitDeclarator
(
const
TPublicType
&
publicType
const
TSourceLoc
&
identifierLocation
const
TString
&
identifier
const
TSourceLoc
&
indexLocation
TIntermTyped
*
indexExpression
const
TSourceLoc
&
initLocation
TIntermTyped
*
initializer
TIntermDeclaration
*
declarationOut
)
{
if
(
mDeferredNonEmptyDeclarationErrorCheck
)
{
nonEmptyDeclarationErrorCheck
(
publicType
identifierLocation
)
;
mDeferredNonEmptyDeclarationErrorCheck
=
false
;
}
checkDeclaratorLocationIsNotSpecified
(
identifierLocation
publicType
)
;
checkIsValidTypeAndQualifierForArray
(
indexLocation
publicType
)
;
TPublicType
arrayType
(
publicType
)
;
unsigned
int
size
=
0u
;
if
(
indexExpression
!
=
nullptr
)
{
size
=
checkIsValidArraySize
(
identifierLocation
indexExpression
)
;
}
arrayType
.
setArraySize
(
size
)
;
TIntermBinary
*
initNode
=
nullptr
;
if
(
executeInitializer
(
identifierLocation
identifier
arrayType
initializer
&
initNode
)
)
{
if
(
initNode
)
{
declarationOut
-
>
appendDeclarator
(
initNode
)
;
}
}
}
void
TParseContext
:
:
setAtomicCounterBindingDefaultOffset
(
const
TPublicType
&
publicType
const
TSourceLoc
&
location
)
{
const
TLayoutQualifier
&
layoutQualifier
=
publicType
.
layoutQualifier
;
checkAtomicCounterBindingIsValid
(
location
layoutQualifier
.
binding
)
;
if
(
layoutQualifier
.
binding
=
=
-
1
|
|
layoutQualifier
.
offset
=
=
-
1
)
{
error
(
location
"
Requires
both
binding
and
offset
"
"
layout
"
)
;
return
;
}
mAtomicCounterBindingStates
[
layoutQualifier
.
binding
]
.
setDefaultOffset
(
layoutQualifier
.
offset
)
;
}
void
TParseContext
:
:
parseDefaultPrecisionQualifier
(
const
TPrecision
precision
const
TPublicType
&
type
const
TSourceLoc
&
loc
)
{
if
(
(
precision
=
=
EbpHigh
)
&
&
(
getShaderType
(
)
=
=
GL_FRAGMENT_SHADER
)
&
&
!
getFragmentPrecisionHigh
(
)
)
{
error
(
loc
"
precision
is
not
supported
in
fragment
shader
"
"
highp
"
)
;
}
if
(
!
CanSetDefaultPrecisionOnType
(
type
)
)
{
error
(
loc
"
illegal
type
argument
for
default
precision
qualifier
"
getBasicString
(
type
.
getBasicType
(
)
)
)
;
return
;
}
symbolTable
.
setDefaultPrecision
(
type
.
getBasicType
(
)
precision
)
;
}
bool
TParseContext
:
:
checkPrimitiveTypeMatchesTypeQualifier
(
const
TTypeQualifier
&
typeQualifier
)
{
switch
(
typeQualifier
.
layoutQualifier
.
primitiveType
)
{
case
EptLines
:
case
EptLinesAdjacency
:
case
EptTriangles
:
case
EptTrianglesAdjacency
:
return
typeQualifier
.
qualifier
=
=
EvqGeometryIn
;
case
EptLineStrip
:
case
EptTriangleStrip
:
return
typeQualifier
.
qualifier
=
=
EvqGeometryOut
;
case
EptPoints
:
return
true
;
default
:
UNREACHABLE
(
)
;
return
false
;
}
}
void
TParseContext
:
:
setGeometryShaderInputArraySizes
(
)
{
ASSERT
(
mGeometryShaderInputArraySize
=
=
0
)
;
mGeometryShaderInputArraySize
=
GetGeometryShaderInputArraySize
(
mGeometryShaderInputPrimitiveType
)
;
}
bool
TParseContext
:
:
parseGeometryShaderInputLayoutQualifier
(
const
TTypeQualifier
&
typeQualifier
)
{
ASSERT
(
typeQualifier
.
qualifier
=
=
EvqGeometryIn
)
;
const
TLayoutQualifier
&
layoutQualifier
=
typeQualifier
.
layoutQualifier
;
if
(
layoutQualifier
.
maxVertices
!
=
-
1
)
{
error
(
typeQualifier
.
line
"
max_vertices
can
only
be
declared
in
'
out
'
layout
in
a
geometry
shader
"
"
layout
"
)
;
return
false
;
}
if
(
layoutQualifier
.
primitiveType
!
=
EptUndefined
)
{
if
(
!
checkPrimitiveTypeMatchesTypeQualifier
(
typeQualifier
)
)
{
error
(
typeQualifier
.
line
"
invalid
primitive
type
for
'
in
'
layout
"
"
layout
"
)
;
return
false
;
}
if
(
mGeometryShaderInputPrimitiveType
=
=
EptUndefined
)
{
mGeometryShaderInputPrimitiveType
=
layoutQualifier
.
primitiveType
;
setGeometryShaderInputArraySizes
(
)
;
}
else
if
(
mGeometryShaderInputPrimitiveType
!
=
layoutQualifier
.
primitiveType
)
{
error
(
typeQualifier
.
line
"
primitive
doesn
'
t
match
earlier
input
primitive
declaration
"
"
layout
"
)
;
return
false
;
}
}
if
(
layoutQualifier
.
invocations
>
0
)
{
if
(
mGeometryShaderInvocations
=
=
0
)
{
mGeometryShaderInvocations
=
layoutQualifier
.
invocations
;
}
else
if
(
mGeometryShaderInvocations
!
=
layoutQualifier
.
invocations
)
{
error
(
typeQualifier
.
line
"
invocations
contradicts
to
the
earlier
declaration
"
"
layout
"
)
;
return
false
;
}
}
return
true
;
}
bool
TParseContext
:
:
parseGeometryShaderOutputLayoutQualifier
(
const
TTypeQualifier
&
typeQualifier
)
{
ASSERT
(
typeQualifier
.
qualifier
=
=
EvqGeometryOut
)
;
const
TLayoutQualifier
&
layoutQualifier
=
typeQualifier
.
layoutQualifier
;
if
(
layoutQualifier
.
invocations
>
0
)
{
error
(
typeQualifier
.
line
"
invocations
can
only
be
declared
in
'
in
'
layout
in
a
geometry
shader
"
"
layout
"
)
;
return
false
;
}
if
(
layoutQualifier
.
primitiveType
!
=
EptUndefined
)
{
if
(
!
checkPrimitiveTypeMatchesTypeQualifier
(
typeQualifier
)
)
{
error
(
typeQualifier
.
line
"
invalid
primitive
type
for
'
out
'
layout
"
"
layout
"
)
;
return
false
;
}
if
(
mGeometryShaderOutputPrimitiveType
=
=
EptUndefined
)
{
mGeometryShaderOutputPrimitiveType
=
layoutQualifier
.
primitiveType
;
}
else
if
(
mGeometryShaderOutputPrimitiveType
!
=
layoutQualifier
.
primitiveType
)
{
error
(
typeQualifier
.
line
"
primitive
doesn
'
t
match
earlier
output
primitive
declaration
"
"
layout
"
)
;
return
false
;
}
}
if
(
layoutQualifier
.
maxVertices
>
-
1
)
{
if
(
mGeometryShaderMaxVertices
=
=
-
1
)
{
mGeometryShaderMaxVertices
=
layoutQualifier
.
maxVertices
;
}
else
if
(
mGeometryShaderMaxVertices
!
=
layoutQualifier
.
maxVertices
)
{
error
(
typeQualifier
.
line
"
max_vertices
contradicts
to
the
earlier
declaration
"
"
layout
"
)
;
return
false
;
}
}
return
true
;
}
void
TParseContext
:
:
parseGlobalLayoutQualifier
(
const
TTypeQualifierBuilder
&
typeQualifierBuilder
)
{
TTypeQualifier
typeQualifier
=
typeQualifierBuilder
.
getVariableTypeQualifier
(
mDiagnostics
)
;
const
TLayoutQualifier
layoutQualifier
=
typeQualifier
.
layoutQualifier
;
checkInvariantVariableQualifier
(
typeQualifier
.
invariant
typeQualifier
.
qualifier
typeQualifier
.
line
)
;
if
(
layoutQualifier
.
isEmpty
(
)
)
{
error
(
typeQualifier
.
line
"
Error
during
layout
qualifier
parsing
.
"
"
?
"
)
;
return
;
}
if
(
!
layoutQualifier
.
isCombinationValid
(
)
)
{
error
(
typeQualifier
.
line
"
invalid
layout
qualifier
combination
"
"
layout
"
)
;
return
;
}
checkBindingIsNotSpecified
(
typeQualifier
.
line
layoutQualifier
.
binding
)
;
checkMemoryQualifierIsNotSpecified
(
typeQualifier
.
memoryQualifier
typeQualifier
.
line
)
;
checkInternalFormatIsNotSpecified
(
typeQualifier
.
line
layoutQualifier
.
imageInternalFormat
)
;
checkYuvIsNotSpecified
(
typeQualifier
.
line
layoutQualifier
.
yuv
)
;
checkOffsetIsNotSpecified
(
typeQualifier
.
line
layoutQualifier
.
offset
)
;
if
(
typeQualifier
.
qualifier
=
=
EvqComputeIn
)
{
if
(
mComputeShaderLocalSizeDeclared
&
&
!
layoutQualifier
.
isLocalSizeEqual
(
mComputeShaderLocalSize
)
)
{
error
(
typeQualifier
.
line
"
Work
group
size
does
not
match
the
previous
declaration
"
"
layout
"
)
;
return
;
}
if
(
mShaderVersion
<
310
)
{
error
(
typeQualifier
.
line
"
in
type
qualifier
supported
in
GLSL
ES
3
.
10
only
"
"
layout
"
)
;
return
;
}
if
(
!
layoutQualifier
.
localSize
.
isAnyValueSet
(
)
)
{
error
(
typeQualifier
.
line
"
No
local
work
group
size
specified
"
"
layout
"
)
;
return
;
}
const
TVariable
*
maxComputeWorkGroupSize
=
static_cast
<
const
TVariable
*
>
(
symbolTable
.
findBuiltIn
(
"
gl_MaxComputeWorkGroupSize
"
mShaderVersion
)
)
;
const
TConstantUnion
*
maxComputeWorkGroupSizeData
=
maxComputeWorkGroupSize
-
>
getConstPointer
(
)
;
for
(
size_t
i
=
0u
;
i
<
layoutQualifier
.
localSize
.
size
(
)
;
+
+
i
)
{
if
(
layoutQualifier
.
localSize
[
i
]
!
=
-
1
)
{
mComputeShaderLocalSize
[
i
]
=
layoutQualifier
.
localSize
[
i
]
;
const
int
maxComputeWorkGroupSizeValue
=
maxComputeWorkGroupSizeData
[
i
]
.
getIConst
(
)
;
if
(
mComputeShaderLocalSize
[
i
]
<
1
|
|
mComputeShaderLocalSize
[
i
]
>
maxComputeWorkGroupSizeValue
)
{
std
:
:
stringstream
reasonStream
;
reasonStream
<
<
"
invalid
value
:
Value
must
be
at
least
1
and
no
greater
than
"
<
<
maxComputeWorkGroupSizeValue
;
const
std
:
:
string
&
reason
=
reasonStream
.
str
(
)
;
error
(
typeQualifier
.
line
reason
.
c_str
(
)
getWorkGroupSizeString
(
i
)
)
;
return
;
}
}
}
mComputeShaderLocalSizeDeclared
=
true
;
}
else
if
(
typeQualifier
.
qualifier
=
=
EvqGeometryIn
)
{
if
(
mShaderVersion
<
310
)
{
error
(
typeQualifier
.
line
"
in
type
qualifier
supported
in
GLSL
ES
3
.
10
only
"
"
layout
"
)
;
return
;
}
if
(
!
parseGeometryShaderInputLayoutQualifier
(
typeQualifier
)
)
{
return
;
}
}
else
if
(
typeQualifier
.
qualifier
=
=
EvqGeometryOut
)
{
if
(
mShaderVersion
<
310
)
{
error
(
typeQualifier
.
line
"
out
type
qualifier
supported
in
GLSL
ES
3
.
10
only
"
"
layout
"
)
;
return
;
}
if
(
!
parseGeometryShaderOutputLayoutQualifier
(
typeQualifier
)
)
{
return
;
}
}
else
if
(
isExtensionEnabled
(
TExtension
:
:
OVR_multiview
)
&
&
typeQualifier
.
qualifier
=
=
EvqVertexIn
)
{
if
(
mNumViews
!
=
-
1
&
&
layoutQualifier
.
numViews
!
=
mNumViews
)
{
error
(
typeQualifier
.
line
"
Number
of
views
does
not
match
the
previous
declaration
"
"
layout
"
)
;
return
;
}
if
(
layoutQualifier
.
numViews
=
=
-
1
)
{
error
(
typeQualifier
.
line
"
No
num_views
specified
"
"
layout
"
)
;
return
;
}
if
(
layoutQualifier
.
numViews
>
mMaxNumViews
)
{
error
(
typeQualifier
.
line
"
num_views
greater
than
the
value
of
GL_MAX_VIEWS_OVR
"
"
layout
"
)
;
return
;
}
mNumViews
=
layoutQualifier
.
numViews
;
}
else
{
if
(
!
checkWorkGroupSizeIsNotSpecified
(
typeQualifier
.
line
layoutQualifier
)
)
{
return
;
}
if
(
typeQualifier
.
qualifier
!
=
EvqUniform
&
&
typeQualifier
.
qualifier
!
=
EvqBuffer
)
{
error
(
typeQualifier
.
line
"
invalid
qualifier
:
global
layout
can
only
be
set
for
blocks
"
getQualifierString
(
typeQualifier
.
qualifier
)
)
;
return
;
}
if
(
mShaderVersion
<
300
)
{
error
(
typeQualifier
.
line
"
layout
qualifiers
supported
in
GLSL
ES
3
.
00
and
above
"
"
layout
"
)
;
return
;
}
checkLocationIsNotSpecified
(
typeQualifier
.
line
layoutQualifier
)
;
if
(
layoutQualifier
.
matrixPacking
!
=
EmpUnspecified
)
{
if
(
typeQualifier
.
qualifier
=
=
EvqUniform
)
{
mDefaultUniformMatrixPacking
=
layoutQualifier
.
matrixPacking
;
}
else
if
(
typeQualifier
.
qualifier
=
=
EvqBuffer
)
{
mDefaultBufferMatrixPacking
=
layoutQualifier
.
matrixPacking
;
}
}
if
(
layoutQualifier
.
blockStorage
!
=
EbsUnspecified
)
{
if
(
typeQualifier
.
qualifier
=
=
EvqUniform
)
{
mDefaultUniformBlockStorage
=
layoutQualifier
.
blockStorage
;
}
else
if
(
typeQualifier
.
qualifier
=
=
EvqBuffer
)
{
mDefaultBufferBlockStorage
=
layoutQualifier
.
blockStorage
;
}
}
}
}
TIntermFunctionPrototype
*
TParseContext
:
:
createPrototypeNodeFromFunction
(
const
TFunction
&
function
const
TSourceLoc
&
location
bool
insertParametersToSymbolTable
)
{
checkIsNotReserved
(
location
function
.
getName
(
)
)
;
TIntermFunctionPrototype
*
prototype
=
new
TIntermFunctionPrototype
(
function
.
getReturnType
(
)
TSymbolUniqueId
(
function
)
)
;
prototype
-
>
getFunctionSymbolInfo
(
)
-
>
setFromFunction
(
function
)
;
prototype
-
>
setLine
(
location
)
;
for
(
size_t
i
=
0
;
i
<
function
.
getParamCount
(
)
;
i
+
+
)
{
const
TConstParameter
&
param
=
function
.
getParam
(
i
)
;
TIntermSymbol
*
symbol
=
nullptr
;
if
(
param
.
name
!
=
nullptr
)
{
if
(
insertParametersToSymbolTable
)
{
TVariable
*
variable
=
symbolTable
.
declareVariable
(
param
.
name
*
param
.
type
)
;
if
(
variable
)
{
symbol
=
new
TIntermSymbol
(
variable
-
>
getUniqueId
(
)
variable
-
>
getName
(
)
variable
-
>
getType
(
)
)
;
}
else
{
error
(
location
"
redefinition
"
param
.
name
-
>
c_str
(
)
)
;
}
}
}
if
(
!
symbol
)
{
symbol
=
new
TIntermSymbol
(
0
"
"
*
param
.
type
)
;
}
symbol
-
>
setLine
(
location
)
;
prototype
-
>
appendParameter
(
symbol
)
;
}
return
prototype
;
}
TIntermFunctionPrototype
*
TParseContext
:
:
addFunctionPrototypeDeclaration
(
const
TFunction
&
parsedFunction
const
TSourceLoc
&
location
)
{
TFunction
*
function
=
static_cast
<
TFunction
*
>
(
symbolTable
.
find
(
parsedFunction
.
getMangledName
(
)
getShaderVersion
(
)
)
)
;
if
(
function
-
>
hasPrototypeDeclaration
(
)
&
&
mShaderVersion
=
=
100
)
{
error
(
location
"
duplicate
function
prototype
declarations
are
not
allowed
"
"
function
"
)
;
}
function
-
>
setHasPrototypeDeclaration
(
)
;
TIntermFunctionPrototype
*
prototype
=
createPrototypeNodeFromFunction
(
*
function
location
false
)
;
symbolTable
.
pop
(
)
;
if
(
!
symbolTable
.
atGlobalLevel
(
)
)
{
error
(
location
"
local
function
prototype
declarations
are
not
allowed
"
"
function
"
)
;
}
return
prototype
;
}
TIntermFunctionDefinition
*
TParseContext
:
:
addFunctionDefinition
(
TIntermFunctionPrototype
*
functionPrototype
TIntermBlock
*
functionBody
const
TSourceLoc
&
location
)
{
if
(
mCurrentFunctionType
-
>
getBasicType
(
)
!
=
EbtVoid
&
&
!
mFunctionReturnsValue
)
{
error
(
location
"
function
does
not
return
a
value
:
"
functionPrototype
-
>
getFunctionSymbolInfo
(
)
-
>
getName
(
)
.
c_str
(
)
)
;
}
if
(
functionBody
=
=
nullptr
)
{
functionBody
=
new
TIntermBlock
(
)
;
functionBody
-
>
setLine
(
location
)
;
}
TIntermFunctionDefinition
*
functionNode
=
new
TIntermFunctionDefinition
(
functionPrototype
functionBody
)
;
functionNode
-
>
setLine
(
location
)
;
symbolTable
.
pop
(
)
;
return
functionNode
;
}
void
TParseContext
:
:
parseFunctionDefinitionHeader
(
const
TSourceLoc
&
location
TFunction
*
*
function
TIntermFunctionPrototype
*
*
prototypeOut
)
{
ASSERT
(
function
)
;
ASSERT
(
*
function
)
;
const
TSymbol
*
builtIn
=
symbolTable
.
findBuiltIn
(
(
*
function
)
-
>
getMangledName
(
)
getShaderVersion
(
)
)
;
if
(
builtIn
)
{
error
(
location
"
built
-
in
functions
cannot
be
redefined
"
(
*
function
)
-
>
getName
(
)
.
c_str
(
)
)
;
}
else
{
TFunction
*
prevDec
=
static_cast
<
TFunction
*
>
(
symbolTable
.
find
(
(
*
function
)
-
>
getMangledName
(
)
getShaderVersion
(
)
)
)
;
if
(
*
function
!
=
prevDec
)
{
prevDec
-
>
swapParameters
(
*
*
function
)
;
*
function
=
prevDec
;
}
if
(
(
*
function
)
-
>
isDefined
(
)
)
{
error
(
location
"
function
already
has
a
body
"
(
*
function
)
-
>
getName
(
)
.
c_str
(
)
)
;
}
(
*
function
)
-
>
setDefined
(
)
;
}
mCurrentFunctionType
=
&
(
(
*
function
)
-
>
getReturnType
(
)
)
;
mFunctionReturnsValue
=
false
;
*
prototypeOut
=
createPrototypeNodeFromFunction
(
*
*
function
location
true
)
;
setLoopNestingLevel
(
0
)
;
}
TFunction
*
TParseContext
:
:
parseFunctionDeclarator
(
const
TSourceLoc
&
location
TFunction
*
function
)
{
TFunction
*
prevDec
=
static_cast
<
TFunction
*
>
(
symbolTable
.
find
(
function
-
>
getMangledName
(
)
getShaderVersion
(
)
)
)
;
if
(
getShaderVersion
(
)
>
=
300
&
&
symbolTable
.
hasUnmangledBuiltInForShaderVersion
(
function
-
>
getName
(
)
.
c_str
(
)
getShaderVersion
(
)
)
)
{
error
(
location
"
Name
of
a
built
-
in
function
cannot
be
redeclared
as
function
"
function
-
>
getName
(
)
.
c_str
(
)
)
;
}
else
if
(
prevDec
)
{
if
(
prevDec
-
>
getReturnType
(
)
!
=
function
-
>
getReturnType
(
)
)
{
error
(
location
"
function
must
have
the
same
return
type
in
all
of
its
declarations
"
function
-
>
getReturnType
(
)
.
getBasicString
(
)
)
;
}
for
(
size_t
i
=
0
;
i
<
prevDec
-
>
getParamCount
(
)
;
+
+
i
)
{
if
(
prevDec
-
>
getParam
(
i
)
.
type
-
>
getQualifier
(
)
!
=
function
-
>
getParam
(
i
)
.
type
-
>
getQualifier
(
)
)
{
error
(
location
"
function
must
have
the
same
parameter
qualifiers
in
all
of
its
declarations
"
function
-
>
getParam
(
i
)
.
type
-
>
getQualifierString
(
)
)
;
}
}
}
TSymbol
*
prevSym
=
symbolTable
.
find
(
function
-
>
getName
(
)
getShaderVersion
(
)
)
;
if
(
prevSym
)
{
if
(
!
prevSym
-
>
isFunction
(
)
)
{
error
(
location
"
redefinition
of
a
function
"
function
-
>
getName
(
)
.
c_str
(
)
)
;
}
}
else
{
symbolTable
.
getOuterLevel
(
)
-
>
insertUnmangled
(
function
)
;
}
symbolTable
.
getOuterLevel
(
)
-
>
insert
(
function
)
;
if
(
function
-
>
getName
(
)
=
=
"
main
"
)
{
if
(
function
-
>
getParamCount
(
)
>
0
)
{
error
(
location
"
function
cannot
take
any
parameter
(
s
)
"
"
main
"
)
;
}
if
(
function
-
>
getReturnType
(
)
.
getBasicType
(
)
!
=
EbtVoid
)
{
error
(
location
"
main
function
cannot
return
a
value
"
function
-
>
getReturnType
(
)
.
getBasicString
(
)
)
;
}
}
return
function
;
}
TFunction
*
TParseContext
:
:
parseFunctionHeader
(
const
TPublicType
&
type
const
TString
*
name
const
TSourceLoc
&
location
)
{
if
(
type
.
qualifier
!
=
EvqGlobal
&
&
type
.
qualifier
!
=
EvqTemporary
)
{
error
(
location
"
no
qualifiers
allowed
for
function
return
"
getQualifierString
(
type
.
qualifier
)
)
;
}
if
(
!
type
.
layoutQualifier
.
isEmpty
(
)
)
{
error
(
location
"
no
qualifiers
allowed
for
function
return
"
"
layout
"
)
;
}
std
:
:
string
reason
(
getBasicString
(
type
.
getBasicType
(
)
)
)
;
reason
+
=
"
s
can
'
t
be
function
return
values
"
;
checkIsNotOpaqueType
(
location
type
.
typeSpecifierNonArray
reason
.
c_str
(
)
)
;
if
(
mShaderVersion
<
300
)
{
ASSERT
(
type
.
arraySize
=
=
0
|
|
mDiagnostics
-
>
numErrors
(
)
>
0
)
;
if
(
type
.
isStructureContainingArrays
(
)
)
{
error
(
location
"
structures
containing
arrays
can
'
t
be
function
return
values
"
TType
(
type
)
.
getCompleteString
(
)
.
c_str
(
)
)
;
}
}
return
new
TFunction
(
&
symbolTable
name
new
TType
(
type
)
)
;
}
TFunction
*
TParseContext
:
:
addNonConstructorFunc
(
const
TString
*
name
const
TSourceLoc
&
loc
)
{
const
TType
*
returnType
=
TCache
:
:
getType
(
EbtVoid
EbpUndefined
)
;
return
new
TFunction
(
&
symbolTable
name
returnType
)
;
}
TFunction
*
TParseContext
:
:
addConstructorFunc
(
const
TPublicType
&
publicType
)
{
if
(
mShaderVersion
<
300
&
&
publicType
.
array
)
{
error
(
publicType
.
getLine
(
)
"
array
constructor
supported
in
GLSL
ES
3
.
00
and
above
only
"
"
[
]
"
)
;
}
if
(
publicType
.
isStructSpecifier
(
)
)
{
error
(
publicType
.
getLine
(
)
"
constructor
can
'
t
be
a
structure
definition
"
getBasicString
(
publicType
.
getBasicType
(
)
)
)
;
}
TType
*
type
=
new
TType
(
publicType
)
;
if
(
!
type
-
>
canBeConstructed
(
)
)
{
error
(
publicType
.
getLine
(
)
"
cannot
construct
this
type
"
getBasicString
(
publicType
.
getBasicType
(
)
)
)
;
type
-
>
setBasicType
(
EbtFloat
)
;
}
return
new
TFunction
(
&
symbolTable
nullptr
type
EOpConstruct
)
;
}
TParameter
TParseContext
:
:
parseParameterDeclarator
(
const
TPublicType
&
publicType
const
TString
*
name
const
TSourceLoc
&
nameLoc
)
{
if
(
publicType
.
getBasicType
(
)
=
=
EbtVoid
)
{
error
(
nameLoc
"
illegal
use
of
type
'
void
'
"
name
-
>
c_str
(
)
)
;
}
checkIsNotReserved
(
nameLoc
*
name
)
;
TType
*
type
=
new
TType
(
publicType
)
;
TParameter
param
=
{
name
type
}
;
return
param
;
}
TParameter
TParseContext
:
:
parseParameterArrayDeclarator
(
const
TString
*
identifier
const
TSourceLoc
&
identifierLoc
TIntermTyped
*
arraySize
const
TSourceLoc
&
arrayLoc
TPublicType
*
type
)
{
checkArrayElementIsNotArray
(
arrayLoc
*
type
)
;
unsigned
int
size
=
checkIsValidArraySize
(
arrayLoc
arraySize
)
;
type
-
>
setArraySize
(
size
)
;
return
parseParameterDeclarator
(
*
type
identifier
identifierLoc
)
;
}
bool
TParseContext
:
:
checkUnsizedArrayConstructorArgumentDimensionality
(
TIntermSequence
*
arguments
TType
type
const
TSourceLoc
&
line
)
{
if
(
arguments
-
>
empty
(
)
)
{
error
(
line
"
implicitly
sized
array
constructor
must
have
at
least
one
argument
"
"
[
]
"
)
;
return
false
;
}
for
(
TIntermNode
*
arg
:
*
arguments
)
{
TIntermTyped
*
element
=
arg
-
>
getAsTyped
(
)
;
ASSERT
(
element
)
;
size_t
dimensionalityFromElement
=
element
-
>
getType
(
)
.
getArraySizes
(
)
.
size
(
)
+
1u
;
if
(
dimensionalityFromElement
>
type
.
getArraySizes
(
)
.
size
(
)
)
{
error
(
line
"
constructing
from
a
non
-
dereferenced
array
"
"
constructor
"
)
;
return
false
;
}
else
if
(
dimensionalityFromElement
<
type
.
getArraySizes
(
)
.
size
(
)
)
{
if
(
dimensionalityFromElement
=
=
1u
)
{
error
(
line
"
implicitly
sized
array
of
arrays
constructor
argument
is
not
an
array
"
"
constructor
"
)
;
}
else
{
error
(
line
"
implicitly
sized
array
of
arrays
constructor
argument
dimensionality
is
too
"
"
low
"
"
constructor
"
)
;
}
return
false
;
}
}
return
true
;
}
TIntermTyped
*
TParseContext
:
:
addConstructor
(
TIntermSequence
*
arguments
TType
type
const
TSourceLoc
&
line
)
{
if
(
type
.
isUnsizedArray
(
)
)
{
if
(
!
checkUnsizedArrayConstructorArgumentDimensionality
(
arguments
type
line
)
)
{
type
.
sizeUnsizedArrays
(
TVector
<
unsigned
int
>
(
)
)
;
return
CreateZeroNode
(
type
)
;
}
TIntermTyped
*
firstElement
=
arguments
-
>
at
(
0
)
-
>
getAsTyped
(
)
;
ASSERT
(
firstElement
)
;
type
.
setArraySize
(
type
.
getArraySizes
(
)
.
size
(
)
-
1u
static_cast
<
unsigned
int
>
(
arguments
-
>
size
(
)
)
)
;
for
(
size_t
i
=
0
;
i
<
firstElement
-
>
getType
(
)
.
getArraySizes
(
)
.
size
(
)
;
+
+
i
)
{
if
(
type
.
getArraySizes
(
)
[
i
]
=
=
0u
)
{
type
.
setArraySize
(
i
firstElement
-
>
getType
(
)
.
getArraySizes
(
)
.
at
(
i
)
)
;
}
}
ASSERT
(
!
type
.
isUnsizedArray
(
)
)
;
}
if
(
!
checkConstructorArguments
(
line
arguments
type
)
)
{
return
CreateZeroNode
(
type
)
;
}
TIntermAggregate
*
constructorNode
=
TIntermAggregate
:
:
CreateConstructor
(
type
arguments
)
;
constructorNode
-
>
setLine
(
line
)
;
if
(
!
constructorNode
-
>
isArray
(
)
)
{
return
constructorNode
-
>
fold
(
mDiagnostics
)
;
}
return
constructorNode
;
}
TIntermDeclaration
*
TParseContext
:
:
addInterfaceBlock
(
const
TTypeQualifierBuilder
&
typeQualifierBuilder
const
TSourceLoc
&
nameLine
const
TString
&
blockName
TFieldList
*
fieldList
const
TString
*
instanceName
const
TSourceLoc
&
instanceLine
TIntermTyped
*
arrayIndex
const
TSourceLoc
&
arrayIndexLine
)
{
checkIsNotReserved
(
nameLine
blockName
)
;
TTypeQualifier
typeQualifier
=
typeQualifierBuilder
.
getVariableTypeQualifier
(
mDiagnostics
)
;
if
(
mShaderVersion
<
310
&
&
typeQualifier
.
qualifier
!
=
EvqUniform
)
{
error
(
typeQualifier
.
line
"
invalid
qualifier
:
interface
blocks
must
be
uniform
in
version
lower
than
GLSL
ES
"
"
3
.
10
"
getQualifierString
(
typeQualifier
.
qualifier
)
)
;
}
else
if
(
typeQualifier
.
qualifier
!
=
EvqUniform
&
&
typeQualifier
.
qualifier
!
=
EvqBuffer
)
{
error
(
typeQualifier
.
line
"
invalid
qualifier
:
interface
blocks
must
be
uniform
or
buffer
"
getQualifierString
(
typeQualifier
.
qualifier
)
)
;
}
if
(
typeQualifier
.
invariant
)
{
error
(
typeQualifier
.
line
"
invalid
qualifier
on
interface
block
member
"
"
invariant
"
)
;
}
if
(
typeQualifier
.
qualifier
!
=
EvqBuffer
)
{
checkMemoryQualifierIsNotSpecified
(
typeQualifier
.
memoryQualifier
typeQualifier
.
line
)
;
}
unsigned
int
arraySize
=
0
;
if
(
arrayIndex
!
=
nullptr
)
{
arraySize
=
checkIsValidArraySize
(
arrayIndexLine
arrayIndex
)
;
}
if
(
mShaderVersion
<
310
)
{
checkBindingIsNotSpecified
(
typeQualifier
.
line
typeQualifier
.
layoutQualifier
.
binding
)
;
}
else
{
checkBlockBindingIsValid
(
typeQualifier
.
line
typeQualifier
.
qualifier
typeQualifier
.
layoutQualifier
.
binding
arraySize
)
;
}
checkYuvIsNotSpecified
(
typeQualifier
.
line
typeQualifier
.
layoutQualifier
.
yuv
)
;
TLayoutQualifier
blockLayoutQualifier
=
typeQualifier
.
layoutQualifier
;
checkLocationIsNotSpecified
(
typeQualifier
.
line
blockLayoutQualifier
)
;
if
(
blockLayoutQualifier
.
matrixPacking
=
=
EmpUnspecified
)
{
if
(
typeQualifier
.
qualifier
=
=
EvqUniform
)
{
blockLayoutQualifier
.
matrixPacking
=
mDefaultUniformMatrixPacking
;
}
else
if
(
typeQualifier
.
qualifier
=
=
EvqBuffer
)
{
blockLayoutQualifier
.
matrixPacking
=
mDefaultBufferMatrixPacking
;
}
}
if
(
blockLayoutQualifier
.
blockStorage
=
=
EbsUnspecified
)
{
if
(
typeQualifier
.
qualifier
=
=
EvqUniform
)
{
blockLayoutQualifier
.
blockStorage
=
mDefaultUniformBlockStorage
;
}
else
if
(
typeQualifier
.
qualifier
=
=
EvqBuffer
)
{
blockLayoutQualifier
.
blockStorage
=
mDefaultBufferBlockStorage
;
}
}
checkWorkGroupSizeIsNotSpecified
(
nameLine
blockLayoutQualifier
)
;
checkInternalFormatIsNotSpecified
(
nameLine
blockLayoutQualifier
.
imageInternalFormat
)
;
if
(
!
symbolTable
.
declareInterfaceBlockName
(
&
blockName
)
)
{
error
(
nameLine
"
redefinition
of
an
interface
block
name
"
blockName
.
c_str
(
)
)
;
}
for
(
size_t
memberIndex
=
0
;
memberIndex
<
fieldList
-
>
size
(
)
;
+
+
memberIndex
)
{
TField
*
field
=
(
*
fieldList
)
[
memberIndex
]
;
TType
*
fieldType
=
field
-
>
type
(
)
;
if
(
IsOpaqueType
(
fieldType
-
>
getBasicType
(
)
)
)
{
std
:
:
string
reason
(
"
unsupported
type
-
"
)
;
reason
+
=
fieldType
-
>
getBasicString
(
)
;
reason
+
=
"
types
are
not
allowed
in
interface
blocks
"
;
error
(
field
-
>
line
(
)
reason
.
c_str
(
)
fieldType
-
>
getBasicString
(
)
)
;
}
const
TQualifier
qualifier
=
fieldType
-
>
getQualifier
(
)
;
switch
(
qualifier
)
{
case
EvqGlobal
:
break
;
case
EvqUniform
:
if
(
typeQualifier
.
qualifier
=
=
EvqBuffer
)
{
error
(
field
-
>
line
(
)
"
invalid
qualifier
on
shader
storage
block
member
"
getQualifierString
(
qualifier
)
)
;
}
break
;
case
EvqBuffer
:
if
(
typeQualifier
.
qualifier
=
=
EvqUniform
)
{
error
(
field
-
>
line
(
)
"
invalid
qualifier
on
uniform
block
member
"
getQualifierString
(
qualifier
)
)
;
}
break
;
default
:
error
(
field
-
>
line
(
)
"
invalid
qualifier
on
interface
block
member
"
getQualifierString
(
qualifier
)
)
;
break
;
}
if
(
fieldType
-
>
isInvariant
(
)
)
{
error
(
field
-
>
line
(
)
"
invalid
qualifier
on
interface
block
member
"
"
invariant
"
)
;
}
TLayoutQualifier
fieldLayoutQualifier
=
fieldType
-
>
getLayoutQualifier
(
)
;
checkLocationIsNotSpecified
(
field
-
>
line
(
)
fieldLayoutQualifier
)
;
checkBindingIsNotSpecified
(
field
-
>
line
(
)
fieldLayoutQualifier
.
binding
)
;
if
(
fieldLayoutQualifier
.
blockStorage
!
=
EbsUnspecified
)
{
error
(
field
-
>
line
(
)
"
invalid
layout
qualifier
:
cannot
be
used
here
"
getBlockStorageString
(
fieldLayoutQualifier
.
blockStorage
)
)
;
}
if
(
fieldLayoutQualifier
.
matrixPacking
=
=
EmpUnspecified
)
{
fieldLayoutQualifier
.
matrixPacking
=
blockLayoutQualifier
.
matrixPacking
;
}
else
if
(
!
fieldType
-
>
isMatrix
(
)
&
&
fieldType
-
>
getBasicType
(
)
!
=
EbtStruct
)
{
warning
(
field
-
>
line
(
)
"
extraneous
layout
qualifier
:
only
has
an
effect
on
matrix
types
"
getMatrixPackingString
(
fieldLayoutQualifier
.
matrixPacking
)
)
;
}
fieldType
-
>
setLayoutQualifier
(
fieldLayoutQualifier
)
;
if
(
typeQualifier
.
qualifier
=
=
EvqBuffer
)
{
const
TMemoryQualifier
&
blockMemoryQualifier
=
typeQualifier
.
memoryQualifier
;
TMemoryQualifier
fieldMemoryQualifier
=
fieldType
-
>
getMemoryQualifier
(
)
;
fieldMemoryQualifier
.
readonly
|
=
blockMemoryQualifier
.
readonly
;
fieldMemoryQualifier
.
writeonly
|
=
blockMemoryQualifier
.
writeonly
;
fieldMemoryQualifier
.
coherent
|
=
blockMemoryQualifier
.
coherent
;
fieldMemoryQualifier
.
restrictQualifier
|
=
blockMemoryQualifier
.
restrictQualifier
;
fieldMemoryQualifier
.
volatileQualifier
|
=
blockMemoryQualifier
.
volatileQualifier
;
fieldType
-
>
setMemoryQualifier
(
fieldMemoryQualifier
)
;
}
}
TInterfaceBlock
*
interfaceBlock
=
new
TInterfaceBlock
(
&
blockName
fieldList
instanceName
blockLayoutQualifier
)
;
TType
interfaceBlockType
(
interfaceBlock
typeQualifier
.
qualifier
blockLayoutQualifier
)
;
if
(
arrayIndex
!
=
nullptr
)
{
interfaceBlockType
.
makeArray
(
arraySize
)
;
}
TString
symbolName
=
"
"
;
int
symbolId
=
0
;
if
(
!
instanceName
)
{
for
(
size_t
memberIndex
=
0
;
memberIndex
<
fieldList
-
>
size
(
)
;
+
+
memberIndex
)
{
TField
*
field
=
(
*
fieldList
)
[
memberIndex
]
;
TType
*
fieldType
=
field
-
>
type
(
)
;
fieldType
-
>
setInterfaceBlock
(
interfaceBlock
)
;
TVariable
*
fieldVariable
=
symbolTable
.
declareVariable
(
&
field
-
>
name
(
)
*
fieldType
)
;
if
(
fieldVariable
)
{
fieldVariable
-
>
setQualifier
(
typeQualifier
.
qualifier
)
;
}
else
{
error
(
field
-
>
line
(
)
"
redefinition
of
an
interface
block
member
name
"
field
-
>
name
(
)
.
c_str
(
)
)
;
}
}
}
else
{
checkIsNotReserved
(
instanceLine
*
instanceName
)
;
TVariable
*
instanceTypeDef
=
symbolTable
.
declareVariable
(
instanceName
interfaceBlockType
)
;
if
(
instanceTypeDef
)
{
instanceTypeDef
-
>
setQualifier
(
typeQualifier
.
qualifier
)
;
symbolId
=
instanceTypeDef
-
>
getUniqueId
(
)
;
}
else
{
error
(
instanceLine
"
redefinition
of
an
interface
block
instance
name
"
instanceName
-
>
c_str
(
)
)
;
}
symbolName
=
*
instanceName
;
}
TIntermSymbol
*
blockSymbol
=
new
TIntermSymbol
(
symbolId
symbolName
interfaceBlockType
)
;
blockSymbol
-
>
setLine
(
typeQualifier
.
line
)
;
TIntermDeclaration
*
declaration
=
new
TIntermDeclaration
(
)
;
declaration
-
>
appendDeclarator
(
blockSymbol
)
;
declaration
-
>
setLine
(
nameLine
)
;
exitStructDeclaration
(
)
;
return
declaration
;
}
void
TParseContext
:
:
enterStructDeclaration
(
const
TSourceLoc
&
line
const
TString
&
identifier
)
{
+
+
mStructNestingLevel
;
if
(
mStructNestingLevel
>
1
)
{
error
(
line
"
Embedded
struct
definitions
are
not
allowed
"
"
struct
"
)
;
}
}
void
TParseContext
:
:
exitStructDeclaration
(
)
{
-
-
mStructNestingLevel
;
}
void
TParseContext
:
:
checkIsBelowStructNestingLimit
(
const
TSourceLoc
&
line
const
TField
&
field
)
{
if
(
!
sh
:
:
IsWebGLBasedSpec
(
mShaderSpec
)
)
{
return
;
}
if
(
field
.
type
(
)
-
>
getBasicType
(
)
!
=
EbtStruct
)
{
return
;
}
if
(
1
+
field
.
type
(
)
-
>
getDeepestStructNesting
(
)
>
kWebGLMaxStructNesting
)
{
std
:
:
stringstream
reasonStream
;
reasonStream
<
<
"
Reference
of
struct
type
"
<
<
field
.
type
(
)
-
>
getStruct
(
)
-
>
name
(
)
.
c_str
(
)
<
<
"
exceeds
maximum
allowed
nesting
level
of
"
<
<
kWebGLMaxStructNesting
;
std
:
:
string
reason
=
reasonStream
.
str
(
)
;
error
(
line
reason
.
c_str
(
)
field
.
name
(
)
.
c_str
(
)
)
;
return
;
}
}
TIntermTyped
*
TParseContext
:
:
addIndexExpression
(
TIntermTyped
*
baseExpression
const
TSourceLoc
&
location
TIntermTyped
*
indexExpression
)
{
if
(
!
baseExpression
-
>
isArray
(
)
&
&
!
baseExpression
-
>
isMatrix
(
)
&
&
!
baseExpression
-
>
isVector
(
)
)
{
if
(
baseExpression
-
>
getAsSymbolNode
(
)
)
{
error
(
location
"
left
of
'
[
'
is
not
of
type
array
matrix
or
vector
"
baseExpression
-
>
getAsSymbolNode
(
)
-
>
getSymbol
(
)
.
c_str
(
)
)
;
}
else
{
error
(
location
"
left
of
'
[
'
is
not
of
type
array
matrix
or
vector
"
"
expression
"
)
;
}
return
CreateZeroNode
(
TType
(
EbtFloat
EbpHigh
EvqConst
)
)
;
}
if
(
baseExpression
-
>
getQualifier
(
)
=
=
EvqPerVertexIn
)
{
ASSERT
(
mShaderType
=
=
GL_GEOMETRY_SHADER_OES
)
;
if
(
mGeometryShaderInputPrimitiveType
=
=
EptUndefined
)
{
error
(
location
"
missing
input
primitive
declaration
before
indexing
gl_in
.
"
"
[
"
)
;
return
CreateZeroNode
(
TType
(
EbtFloat
EbpHigh
EvqConst
)
)
;
}
}
TIntermConstantUnion
*
indexConstantUnion
=
indexExpression
-
>
getAsConstantUnion
(
)
;
if
(
indexExpression
-
>
getQualifier
(
)
!
=
EvqConst
|
|
indexConstantUnion
=
=
nullptr
)
{
if
(
baseExpression
-
>
isInterfaceBlock
(
)
)
{
switch
(
baseExpression
-
>
getQualifier
(
)
)
{
case
EvqPerVertexIn
:
break
;
case
EvqUniform
:
case
EvqBuffer
:
error
(
location
"
array
indexes
for
uniform
block
arrays
and
shader
storage
block
arrays
"
"
must
be
constant
integral
expressions
"
"
[
"
)
;
break
;
default
:
ASSERT
(
mDiagnostics
-
>
numErrors
(
)
>
0
)
;
break
;
}
}
else
if
(
baseExpression
-
>
getQualifier
(
)
=
=
EvqFragmentOut
)
{
error
(
location
"
array
indexes
for
fragment
outputs
must
be
constant
integral
expressions
"
"
[
"
)
;
}
else
if
(
mShaderSpec
=
=
SH_WEBGL2_SPEC
&
&
baseExpression
-
>
getQualifier
(
)
=
=
EvqFragData
)
{
error
(
location
"
array
index
for
gl_FragData
must
be
constant
zero
"
"
[
"
)
;
}
}
if
(
indexConstantUnion
)
{
bool
outOfRangeIndexIsError
=
indexExpression
-
>
getQualifier
(
)
=
=
EvqConst
;
int
index
=
0
;
if
(
indexConstantUnion
-
>
getBasicType
(
)
=
=
EbtInt
)
{
index
=
indexConstantUnion
-
>
getIConst
(
0
)
;
}
else
if
(
indexConstantUnion
-
>
getBasicType
(
)
=
=
EbtUInt
)
{
index
=
static_cast
<
int
>
(
indexConstantUnion
-
>
getUConst
(
0
)
)
;
}
int
safeIndex
=
-
1
;
if
(
baseExpression
-
>
isArray
(
)
)
{
if
(
baseExpression
-
>
getQualifier
(
)
=
=
EvqFragData
&
&
index
>
0
)
{
if
(
!
isExtensionEnabled
(
TExtension
:
:
EXT_draw_buffers
)
)
{
outOfRangeError
(
outOfRangeIndexIsError
location
"
array
index
for
gl_FragData
must
be
zero
when
"
"
GL_EXT_draw_buffers
is
disabled
"
"
[
"
)
;
safeIndex
=
0
;
}
}
if
(
safeIndex
<
0
)
{
safeIndex
=
checkIndexOutOfRange
(
outOfRangeIndexIsError
location
index
baseExpression
-
>
getOutermostArraySize
(
)
"
array
index
out
of
range
"
)
;
}
}
else
if
(
baseExpression
-
>
isMatrix
(
)
)
{
safeIndex
=
checkIndexOutOfRange
(
outOfRangeIndexIsError
location
index
baseExpression
-
>
getType
(
)
.
getCols
(
)
"
matrix
field
selection
out
of
range
"
)
;
}
else
if
(
baseExpression
-
>
isVector
(
)
)
{
safeIndex
=
checkIndexOutOfRange
(
outOfRangeIndexIsError
location
index
baseExpression
-
>
getType
(
)
.
getNominalSize
(
)
"
vector
field
selection
out
of
range
"
)
;
}
ASSERT
(
safeIndex
>
=
0
)
;
if
(
safeIndex
!
=
index
|
|
indexConstantUnion
-
>
getBasicType
(
)
!
=
EbtInt
)
{
TConstantUnion
*
safeConstantUnion
=
new
TConstantUnion
(
)
;
safeConstantUnion
-
>
setIConst
(
safeIndex
)
;
indexConstantUnion
-
>
replaceConstantUnion
(
safeConstantUnion
)
;
indexConstantUnion
-
>
getTypePointer
(
)
-
>
setBasicType
(
EbtInt
)
;
}
TIntermBinary
*
node
=
new
TIntermBinary
(
EOpIndexDirect
baseExpression
indexExpression
)
;
node
-
>
setLine
(
location
)
;
return
node
-
>
fold
(
mDiagnostics
)
;
}
else
{
TIntermBinary
*
node
=
new
TIntermBinary
(
EOpIndexIndirect
baseExpression
indexExpression
)
;
node
-
>
setLine
(
location
)
;
return
node
;
}
}
int
TParseContext
:
:
checkIndexOutOfRange
(
bool
outOfRangeIndexIsError
const
TSourceLoc
&
location
int
index
int
arraySize
const
char
*
reason
)
{
if
(
index
>
=
arraySize
|
|
index
<
0
)
{
std
:
:
stringstream
reasonStream
;
reasonStream
<
<
reason
<
<
"
'
"
<
<
index
<
<
"
'
"
;
std
:
:
string
token
=
reasonStream
.
str
(
)
;
outOfRangeError
(
outOfRangeIndexIsError
location
reason
"
[
]
"
)
;
if
(
index
<
0
)
{
return
0
;
}
else
{
return
arraySize
-
1
;
}
}
return
index
;
}
TIntermTyped
*
TParseContext
:
:
addFieldSelectionExpression
(
TIntermTyped
*
baseExpression
const
TSourceLoc
&
dotLocation
const
TString
&
fieldString
const
TSourceLoc
&
fieldLocation
)
{
if
(
baseExpression
-
>
isArray
(
)
)
{
error
(
fieldLocation
"
cannot
apply
dot
operator
to
an
array
"
"
.
"
)
;
return
baseExpression
;
}
if
(
baseExpression
-
>
isVector
(
)
)
{
TVector
<
int
>
fieldOffsets
;
if
(
!
parseVectorFields
(
fieldLocation
fieldString
baseExpression
-
>
getNominalSize
(
)
&
fieldOffsets
)
)
{
fieldOffsets
.
resize
(
1
)
;
fieldOffsets
[
0
]
=
0
;
}
TIntermSwizzle
*
node
=
new
TIntermSwizzle
(
baseExpression
fieldOffsets
)
;
node
-
>
setLine
(
dotLocation
)
;
return
node
-
>
fold
(
)
;
}
else
if
(
baseExpression
-
>
getBasicType
(
)
=
=
EbtStruct
)
{
const
TFieldList
&
fields
=
baseExpression
-
>
getType
(
)
.
getStruct
(
)
-
>
fields
(
)
;
if
(
fields
.
empty
(
)
)
{
error
(
dotLocation
"
structure
has
no
fields
"
"
Internal
Error
"
)
;
return
baseExpression
;
}
else
{
bool
fieldFound
=
false
;
unsigned
int
i
;
for
(
i
=
0
;
i
<
fields
.
size
(
)
;
+
+
i
)
{
if
(
fields
[
i
]
-
>
name
(
)
=
=
fieldString
)
{
fieldFound
=
true
;
break
;
}
}
if
(
fieldFound
)
{
TIntermTyped
*
index
=
CreateIndexNode
(
i
)
;
index
-
>
setLine
(
fieldLocation
)
;
TIntermBinary
*
node
=
new
TIntermBinary
(
EOpIndexDirectStruct
baseExpression
index
)
;
node
-
>
setLine
(
dotLocation
)
;
return
node
-
>
fold
(
mDiagnostics
)
;
}
else
{
error
(
dotLocation
"
no
such
field
in
structure
"
fieldString
.
c_str
(
)
)
;
return
baseExpression
;
}
}
}
else
if
(
baseExpression
-
>
isInterfaceBlock
(
)
)
{
const
TFieldList
&
fields
=
baseExpression
-
>
getType
(
)
.
getInterfaceBlock
(
)
-
>
fields
(
)
;
if
(
fields
.
empty
(
)
)
{
error
(
dotLocation
"
interface
block
has
no
fields
"
"
Internal
Error
"
)
;
return
baseExpression
;
}
else
{
bool
fieldFound
=
false
;
unsigned
int
i
;
for
(
i
=
0
;
i
<
fields
.
size
(
)
;
+
+
i
)
{
if
(
fields
[
i
]
-
>
name
(
)
=
=
fieldString
)
{
fieldFound
=
true
;
break
;
}
}
if
(
fieldFound
)
{
TIntermTyped
*
index
=
CreateIndexNode
(
i
)
;
index
-
>
setLine
(
fieldLocation
)
;
TIntermBinary
*
node
=
new
TIntermBinary
(
EOpIndexDirectInterfaceBlock
baseExpression
index
)
;
node
-
>
setLine
(
dotLocation
)
;
return
node
;
}
else
{
error
(
dotLocation
"
no
such
field
in
interface
block
"
fieldString
.
c_str
(
)
)
;
return
baseExpression
;
}
}
}
else
{
if
(
mShaderVersion
<
300
)
{
error
(
dotLocation
"
field
selection
requires
structure
or
vector
on
left
hand
side
"
fieldString
.
c_str
(
)
)
;
}
else
{
error
(
dotLocation
"
field
selection
requires
structure
vector
or
interface
block
on
left
hand
"
"
side
"
fieldString
.
c_str
(
)
)
;
}
return
baseExpression
;
}
}
TLayoutQualifier
TParseContext
:
:
parseLayoutQualifier
(
const
TString
&
qualifierType
const
TSourceLoc
&
qualifierTypeLine
)
{
TLayoutQualifier
qualifier
=
TLayoutQualifier
:
:
create
(
)
;
if
(
qualifierType
=
=
"
shared
"
)
{
if
(
sh
:
:
IsWebGLBasedSpec
(
mShaderSpec
)
)
{
error
(
qualifierTypeLine
"
Only
std140
layout
is
allowed
in
WebGL
"
"
shared
"
)
;
}
qualifier
.
blockStorage
=
EbsShared
;
}
else
if
(
qualifierType
=
=
"
packed
"
)
{
if
(
sh
:
:
IsWebGLBasedSpec
(
mShaderSpec
)
)
{
error
(
qualifierTypeLine
"
Only
std140
layout
is
allowed
in
WebGL
"
"
packed
"
)
;
}
qualifier
.
blockStorage
=
EbsPacked
;
}
else
if
(
qualifierType
=
=
"
std140
"
)
{
qualifier
.
blockStorage
=
EbsStd140
;
}
else
if
(
qualifierType
=
=
"
row_major
"
)
{
qualifier
.
matrixPacking
=
EmpRowMajor
;
}
else
if
(
qualifierType
=
=
"
column_major
"
)
{
qualifier
.
matrixPacking
=
EmpColumnMajor
;
}
else
if
(
qualifierType
=
=
"
location
"
)
{
error
(
qualifierTypeLine
"
invalid
layout
qualifier
:
location
requires
an
argument
"
qualifierType
.
c_str
(
)
)
;
}
else
if
(
qualifierType
=
=
"
yuv
"
&
&
isExtensionEnabled
(
TExtension
:
:
EXT_YUV_target
)
&
&
mShaderType
=
=
GL_FRAGMENT_SHADER
)
{
qualifier
.
yuv
=
true
;
}
else
if
(
qualifierType
=
=
"
rgba32f
"
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
qualifier
.
imageInternalFormat
=
EiifRGBA32F
;
}
else
if
(
qualifierType
=
=
"
rgba16f
"
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
qualifier
.
imageInternalFormat
=
EiifRGBA16F
;
}
else
if
(
qualifierType
=
=
"
r32f
"
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
qualifier
.
imageInternalFormat
=
EiifR32F
;
}
else
if
(
qualifierType
=
=
"
rgba8
"
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
qualifier
.
imageInternalFormat
=
EiifRGBA8
;
}
else
if
(
qualifierType
=
=
"
rgba8_snorm
"
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
qualifier
.
imageInternalFormat
=
EiifRGBA8_SNORM
;
}
else
if
(
qualifierType
=
=
"
rgba32i
"
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
qualifier
.
imageInternalFormat
=
EiifRGBA32I
;
}
else
if
(
qualifierType
=
=
"
rgba16i
"
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
qualifier
.
imageInternalFormat
=
EiifRGBA16I
;
}
else
if
(
qualifierType
=
=
"
rgba8i
"
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
qualifier
.
imageInternalFormat
=
EiifRGBA8I
;
}
else
if
(
qualifierType
=
=
"
r32i
"
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
qualifier
.
imageInternalFormat
=
EiifR32I
;
}
else
if
(
qualifierType
=
=
"
rgba32ui
"
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
qualifier
.
imageInternalFormat
=
EiifRGBA32UI
;
}
else
if
(
qualifierType
=
=
"
rgba16ui
"
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
qualifier
.
imageInternalFormat
=
EiifRGBA16UI
;
}
else
if
(
qualifierType
=
=
"
rgba8ui
"
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
qualifier
.
imageInternalFormat
=
EiifRGBA8UI
;
}
else
if
(
qualifierType
=
=
"
r32ui
"
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
qualifier
.
imageInternalFormat
=
EiifR32UI
;
}
else
if
(
qualifierType
=
=
"
points
"
&
&
isExtensionEnabled
(
TExtension
:
:
OES_geometry_shader
)
&
&
mShaderType
=
=
GL_GEOMETRY_SHADER_OES
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
qualifier
.
primitiveType
=
EptPoints
;
}
else
if
(
qualifierType
=
=
"
lines
"
&
&
isExtensionEnabled
(
TExtension
:
:
OES_geometry_shader
)
&
&
mShaderType
=
=
GL_GEOMETRY_SHADER_OES
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
qualifier
.
primitiveType
=
EptLines
;
}
else
if
(
qualifierType
=
=
"
lines_adjacency
"
&
&
isExtensionEnabled
(
TExtension
:
:
OES_geometry_shader
)
&
&
mShaderType
=
=
GL_GEOMETRY_SHADER_OES
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
qualifier
.
primitiveType
=
EptLinesAdjacency
;
}
else
if
(
qualifierType
=
=
"
triangles
"
&
&
isExtensionEnabled
(
TExtension
:
:
OES_geometry_shader
)
&
&
mShaderType
=
=
GL_GEOMETRY_SHADER_OES
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
qualifier
.
primitiveType
=
EptTriangles
;
}
else
if
(
qualifierType
=
=
"
triangles_adjacency
"
&
&
isExtensionEnabled
(
TExtension
:
:
OES_geometry_shader
)
&
&
mShaderType
=
=
GL_GEOMETRY_SHADER_OES
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
qualifier
.
primitiveType
=
EptTrianglesAdjacency
;
}
else
if
(
qualifierType
=
=
"
line_strip
"
&
&
isExtensionEnabled
(
TExtension
:
:
OES_geometry_shader
)
&
&
mShaderType
=
=
GL_GEOMETRY_SHADER_OES
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
qualifier
.
primitiveType
=
EptLineStrip
;
}
else
if
(
qualifierType
=
=
"
triangle_strip
"
&
&
isExtensionEnabled
(
TExtension
:
:
OES_geometry_shader
)
&
&
mShaderType
=
=
GL_GEOMETRY_SHADER_OES
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
qualifier
.
primitiveType
=
EptTriangleStrip
;
}
else
{
error
(
qualifierTypeLine
"
invalid
layout
qualifier
"
qualifierType
.
c_str
(
)
)
;
}
return
qualifier
;
}
void
TParseContext
:
:
parseLocalSize
(
const
TString
&
qualifierType
const
TSourceLoc
&
qualifierTypeLine
int
intValue
const
TSourceLoc
&
intValueLine
const
std
:
:
string
&
intValueString
size_t
index
sh
:
:
WorkGroupSize
*
localSize
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
if
(
intValue
<
1
)
{
std
:
:
stringstream
reasonStream
;
reasonStream
<
<
"
out
of
range
:
"
<
<
getWorkGroupSizeString
(
index
)
<
<
"
must
be
positive
"
;
std
:
:
string
reason
=
reasonStream
.
str
(
)
;
error
(
intValueLine
reason
.
c_str
(
)
intValueString
.
c_str
(
)
)
;
}
(
*
localSize
)
[
index
]
=
intValue
;
}
void
TParseContext
:
:
parseNumViews
(
int
intValue
const
TSourceLoc
&
intValueLine
const
std
:
:
string
&
intValueString
int
*
numViews
)
{
if
(
intValue
<
1
)
{
error
(
intValueLine
"
out
of
range
:
num_views
must
be
positive
"
intValueString
.
c_str
(
)
)
;
}
*
numViews
=
intValue
;
}
void
TParseContext
:
:
parseInvocations
(
int
intValue
const
TSourceLoc
&
intValueLine
const
std
:
:
string
&
intValueString
int
*
numInvocations
)
{
if
(
intValue
<
1
|
|
intValue
>
mMaxGeometryShaderInvocations
)
{
error
(
intValueLine
"
out
of
range
:
invocations
must
be
in
the
range
of
[
1
"
"
MAX_GEOMETRY_SHADER_INVOCATIONS_OES
]
"
intValueString
.
c_str
(
)
)
;
}
else
{
*
numInvocations
=
intValue
;
}
}
void
TParseContext
:
:
parseMaxVertices
(
int
intValue
const
TSourceLoc
&
intValueLine
const
std
:
:
string
&
intValueString
int
*
maxVertices
)
{
if
(
intValue
<
0
|
|
intValue
>
mMaxGeometryShaderMaxVertices
)
{
error
(
intValueLine
"
out
of
range
:
max_vertices
must
be
in
the
range
of
[
0
gl_MaxGeometryOutputVertices
]
"
intValueString
.
c_str
(
)
)
;
}
else
{
*
maxVertices
=
intValue
;
}
}
TLayoutQualifier
TParseContext
:
:
parseLayoutQualifier
(
const
TString
&
qualifierType
const
TSourceLoc
&
qualifierTypeLine
int
intValue
const
TSourceLoc
&
intValueLine
)
{
TLayoutQualifier
qualifier
=
TLayoutQualifier
:
:
create
(
)
;
std
:
:
string
intValueString
=
Str
(
intValue
)
;
if
(
qualifierType
=
=
"
location
"
)
{
if
(
intValue
<
0
)
{
error
(
intValueLine
"
out
of
range
:
location
must
be
non
-
negative
"
intValueString
.
c_str
(
)
)
;
}
else
{
qualifier
.
location
=
intValue
;
qualifier
.
locationsSpecified
=
1
;
}
}
else
if
(
qualifierType
=
=
"
binding
"
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
if
(
intValue
<
0
)
{
error
(
intValueLine
"
out
of
range
:
binding
must
be
non
-
negative
"
intValueString
.
c_str
(
)
)
;
}
else
{
qualifier
.
binding
=
intValue
;
}
}
else
if
(
qualifierType
=
=
"
offset
"
)
{
checkLayoutQualifierSupported
(
qualifierTypeLine
qualifierType
310
)
;
if
(
intValue
<
0
)
{
error
(
intValueLine
"
out
of
range
:
offset
must
be
non
-
negative
"
intValueString
.
c_str
(
)
)
;
}
else
{
qualifier
.
offset
=
intValue
;
}
}
else
if
(
qualifierType
=
=
"
local_size_x
"
)
{
parseLocalSize
(
qualifierType
qualifierTypeLine
intValue
intValueLine
intValueString
0u
&
qualifier
.
localSize
)
;
}
else
if
(
qualifierType
=
=
"
local_size_y
"
)
{
parseLocalSize
(
qualifierType
qualifierTypeLine
intValue
intValueLine
intValueString
1u
&
qualifier
.
localSize
)
;
}
else
if
(
qualifierType
=
=
"
local_size_z
"
)
{
parseLocalSize
(
qualifierType
qualifierTypeLine
intValue
intValueLine
intValueString
2u
&
qualifier
.
localSize
)
;
}
else
if
(
qualifierType
=
=
"
num_views
"
&
&
isExtensionEnabled
(
TExtension
:
:
OVR_multiview
)
&
&
mShaderType
=
=
GL_VERTEX_SHADER
)
{
parseNumViews
(
intValue
intValueLine
intValueString
&
qualifier
.
numViews
)
;
}
else
if
(
qualifierType
=
=
"
invocations
"
&
&
isExtensionEnabled
(
TExtension
:
:
OES_geometry_shader
)
&
&
mShaderType
=
=
GL_GEOMETRY_SHADER_OES
)
{
parseInvocations
(
intValue
intValueLine
intValueString
&
qualifier
.
invocations
)
;
}
else
if
(
qualifierType
=
=
"
max_vertices
"
&
&
isExtensionEnabled
(
TExtension
:
:
OES_geometry_shader
)
&
&
mShaderType
=
=
GL_GEOMETRY_SHADER_OES
)
{
parseMaxVertices
(
intValue
intValueLine
intValueString
&
qualifier
.
maxVertices
)
;
}
else
{
error
(
qualifierTypeLine
"
invalid
layout
qualifier
"
qualifierType
.
c_str
(
)
)
;
}
return
qualifier
;
}
TTypeQualifierBuilder
*
TParseContext
:
:
createTypeQualifierBuilder
(
const
TSourceLoc
&
loc
)
{
return
new
TTypeQualifierBuilder
(
new
TStorageQualifierWrapper
(
symbolTable
.
atGlobalLevel
(
)
?
EvqGlobal
:
EvqTemporary
loc
)
mShaderVersion
)
;
}
TStorageQualifierWrapper
*
TParseContext
:
:
parseGlobalStorageQualifier
(
TQualifier
qualifier
const
TSourceLoc
&
loc
)
{
checkIsAtGlobalLevel
(
loc
getQualifierString
(
qualifier
)
)
;
return
new
TStorageQualifierWrapper
(
qualifier
loc
)
;
}
TStorageQualifierWrapper
*
TParseContext
:
:
parseVaryingQualifier
(
const
TSourceLoc
&
loc
)
{
if
(
getShaderType
(
)
=
=
GL_VERTEX_SHADER
)
{
return
parseGlobalStorageQualifier
(
EvqVaryingOut
loc
)
;
}
return
parseGlobalStorageQualifier
(
EvqVaryingIn
loc
)
;
}
TStorageQualifierWrapper
*
TParseContext
:
:
parseInQualifier
(
const
TSourceLoc
&
loc
)
{
if
(
declaringFunction
(
)
)
{
return
new
TStorageQualifierWrapper
(
EvqIn
loc
)
;
}
switch
(
getShaderType
(
)
)
{
case
GL_VERTEX_SHADER
:
{
if
(
mShaderVersion
<
300
&
&
!
isExtensionEnabled
(
TExtension
:
:
OVR_multiview
)
)
{
error
(
loc
"
storage
qualifier
supported
in
GLSL
ES
3
.
00
and
above
only
"
"
in
"
)
;
}
return
new
TStorageQualifierWrapper
(
EvqVertexIn
loc
)
;
}
case
GL_FRAGMENT_SHADER
:
{
if
(
mShaderVersion
<
300
)
{
error
(
loc
"
storage
qualifier
supported
in
GLSL
ES
3
.
00
and
above
only
"
"
in
"
)
;
}
return
new
TStorageQualifierWrapper
(
EvqFragmentIn
loc
)
;
}
case
GL_COMPUTE_SHADER
:
{
return
new
TStorageQualifierWrapper
(
EvqComputeIn
loc
)
;
}
case
GL_GEOMETRY_SHADER_OES
:
{
return
new
TStorageQualifierWrapper
(
EvqGeometryIn
loc
)
;
}
default
:
{
UNREACHABLE
(
)
;
return
new
TStorageQualifierWrapper
(
EvqLast
loc
)
;
}
}
}
TStorageQualifierWrapper
*
TParseContext
:
:
parseOutQualifier
(
const
TSourceLoc
&
loc
)
{
if
(
declaringFunction
(
)
)
{
return
new
TStorageQualifierWrapper
(
EvqOut
loc
)
;
}
switch
(
getShaderType
(
)
)
{
case
GL_VERTEX_SHADER
:
{
if
(
mShaderVersion
<
300
)
{
error
(
loc
"
storage
qualifier
supported
in
GLSL
ES
3
.
00
and
above
only
"
"
out
"
)
;
}
return
new
TStorageQualifierWrapper
(
EvqVertexOut
loc
)
;
}
case
GL_FRAGMENT_SHADER
:
{
if
(
mShaderVersion
<
300
)
{
error
(
loc
"
storage
qualifier
supported
in
GLSL
ES
3
.
00
and
above
only
"
"
out
"
)
;
}
return
new
TStorageQualifierWrapper
(
EvqFragmentOut
loc
)
;
}
case
GL_COMPUTE_SHADER
:
{
error
(
loc
"
storage
qualifier
isn
'
t
supported
in
compute
shaders
"
"
out
"
)
;
return
new
TStorageQualifierWrapper
(
EvqLast
loc
)
;
}
case
GL_GEOMETRY_SHADER_OES
:
{
return
new
TStorageQualifierWrapper
(
EvqGeometryOut
loc
)
;
}
default
:
{
UNREACHABLE
(
)
;
return
new
TStorageQualifierWrapper
(
EvqLast
loc
)
;
}
}
}
TStorageQualifierWrapper
*
TParseContext
:
:
parseInOutQualifier
(
const
TSourceLoc
&
loc
)
{
if
(
!
declaringFunction
(
)
)
{
error
(
loc
"
invalid
qualifier
:
can
be
only
used
with
function
parameters
"
"
inout
"
)
;
}
return
new
TStorageQualifierWrapper
(
EvqInOut
loc
)
;
}
TLayoutQualifier
TParseContext
:
:
joinLayoutQualifiers
(
TLayoutQualifier
leftQualifier
TLayoutQualifier
rightQualifier
const
TSourceLoc
&
rightQualifierLocation
)
{
return
sh
:
:
JoinLayoutQualifiers
(
leftQualifier
rightQualifier
rightQualifierLocation
mDiagnostics
)
;
}
TField
*
TParseContext
:
:
parseStructDeclarator
(
TString
*
identifier
const
TSourceLoc
&
loc
)
{
checkIsNotReserved
(
loc
*
identifier
)
;
TType
*
type
=
new
TType
(
EbtVoid
EbpUndefined
)
;
return
new
TField
(
type
identifier
loc
)
;
}
TField
*
TParseContext
:
:
parseStructArrayDeclarator
(
TString
*
identifier
const
TSourceLoc
&
loc
TIntermTyped
*
arraySize
const
TSourceLoc
&
arraySizeLoc
)
{
checkIsNotReserved
(
loc
*
identifier
)
;
TType
*
type
=
new
TType
(
EbtVoid
EbpUndefined
)
;
unsigned
int
size
=
checkIsValidArraySize
(
arraySizeLoc
arraySize
)
;
type
-
>
makeArray
(
size
)
;
return
new
TField
(
type
identifier
loc
)
;
}
TFieldList
*
TParseContext
:
:
combineStructFieldLists
(
TFieldList
*
processedFields
const
TFieldList
*
newlyAddedFields
const
TSourceLoc
&
location
)
{
for
(
TField
*
field
:
*
newlyAddedFields
)
{
for
(
TField
*
oldField
:
*
processedFields
)
{
if
(
oldField
-
>
name
(
)
=
=
field
-
>
name
(
)
)
{
error
(
location
"
duplicate
field
name
in
structure
"
field
-
>
name
(
)
.
c_str
(
)
)
;
}
}
processedFields
-
>
push_back
(
field
)
;
}
return
processedFields
;
}
TFieldList
*
TParseContext
:
:
addStructDeclaratorListWithQualifiers
(
const
TTypeQualifierBuilder
&
typeQualifierBuilder
TPublicType
*
typeSpecifier
TFieldList
*
fieldList
)
{
TTypeQualifier
typeQualifier
=
typeQualifierBuilder
.
getVariableTypeQualifier
(
mDiagnostics
)
;
typeSpecifier
-
>
qualifier
=
typeQualifier
.
qualifier
;
typeSpecifier
-
>
layoutQualifier
=
typeQualifier
.
layoutQualifier
;
typeSpecifier
-
>
memoryQualifier
=
typeQualifier
.
memoryQualifier
;
typeSpecifier
-
>
invariant
=
typeQualifier
.
invariant
;
if
(
typeQualifier
.
precision
!
=
EbpUndefined
)
{
typeSpecifier
-
>
precision
=
typeQualifier
.
precision
;
}
return
addStructDeclaratorList
(
*
typeSpecifier
fieldList
)
;
}
TFieldList
*
TParseContext
:
:
addStructDeclaratorList
(
const
TPublicType
&
typeSpecifier
TFieldList
*
declaratorList
)
{
checkPrecisionSpecified
(
typeSpecifier
.
getLine
(
)
typeSpecifier
.
precision
typeSpecifier
.
getBasicType
(
)
)
;
checkIsNonVoid
(
typeSpecifier
.
getLine
(
)
(
*
declaratorList
)
[
0
]
-
>
name
(
)
typeSpecifier
.
getBasicType
(
)
)
;
checkWorkGroupSizeIsNotSpecified
(
typeSpecifier
.
getLine
(
)
typeSpecifier
.
layoutQualifier
)
;
for
(
unsigned
int
i
=
0
;
i
<
declaratorList
-
>
size
(
)
;
+
+
i
)
{
auto
declaratorArraySizes
=
(
*
declaratorList
)
[
i
]
-
>
type
(
)
-
>
getArraySizes
(
)
;
if
(
!
declaratorArraySizes
.
empty
(
)
)
{
checkArrayElementIsNotArray
(
typeSpecifier
.
getLine
(
)
typeSpecifier
)
;
}
TType
*
type
=
(
*
declaratorList
)
[
i
]
-
>
type
(
)
;
*
type
=
TType
(
typeSpecifier
)
;
for
(
unsigned
int
arraySize
:
declaratorArraySizes
)
{
type
-
>
makeArray
(
arraySize
)
;
}
checkIsBelowStructNestingLimit
(
typeSpecifier
.
getLine
(
)
*
(
*
declaratorList
)
[
i
]
)
;
}
return
declaratorList
;
}
TTypeSpecifierNonArray
TParseContext
:
:
addStructure
(
const
TSourceLoc
&
structLine
const
TSourceLoc
&
nameLine
const
TString
*
structName
TFieldList
*
fieldList
)
{
TStructure
*
structure
=
new
TStructure
(
&
symbolTable
structName
fieldList
)
;
structure
-
>
setAtGlobalScope
(
symbolTable
.
atGlobalLevel
(
)
)
;
if
(
!
structName
-
>
empty
(
)
)
{
checkIsNotReserved
(
nameLine
*
structName
)
;
if
(
!
symbolTable
.
declareStructType
(
structure
)
)
{
error
(
nameLine
"
redefinition
of
a
struct
"
structName
-
>
c_str
(
)
)
;
}
}
for
(
unsigned
int
typeListIndex
=
0
;
typeListIndex
<
fieldList
-
>
size
(
)
;
typeListIndex
+
+
)
{
const
TField
&
field
=
*
(
*
fieldList
)
[
typeListIndex
]
;
const
TQualifier
qualifier
=
field
.
type
(
)
-
>
getQualifier
(
)
;
switch
(
qualifier
)
{
case
EvqGlobal
:
case
EvqTemporary
:
break
;
default
:
error
(
field
.
line
(
)
"
invalid
qualifier
on
struct
member
"
getQualifierString
(
qualifier
)
)
;
break
;
}
if
(
field
.
type
(
)
-
>
isInvariant
(
)
)
{
error
(
field
.
line
(
)
"
invalid
qualifier
on
struct
member
"
"
invariant
"
)
;
}
if
(
IsImage
(
field
.
type
(
)
-
>
getBasicType
(
)
)
|
|
IsAtomicCounter
(
field
.
type
(
)
-
>
getBasicType
(
)
)
)
{
error
(
field
.
line
(
)
"
disallowed
type
in
struct
"
field
.
type
(
)
-
>
getBasicString
(
)
)
;
}
checkMemoryQualifierIsNotSpecified
(
field
.
type
(
)
-
>
getMemoryQualifier
(
)
field
.
line
(
)
)
;
checkBindingIsNotSpecified
(
field
.
line
(
)
field
.
type
(
)
-
>
getLayoutQualifier
(
)
.
binding
)
;
checkLocationIsNotSpecified
(
field
.
line
(
)
field
.
type
(
)
-
>
getLayoutQualifier
(
)
)
;
}
TTypeSpecifierNonArray
typeSpecifierNonArray
;
typeSpecifierNonArray
.
initializeStruct
(
structure
true
structLine
)
;
exitStructDeclaration
(
)
;
return
typeSpecifierNonArray
;
}
TIntermSwitch
*
TParseContext
:
:
addSwitch
(
TIntermTyped
*
init
TIntermBlock
*
statementList
const
TSourceLoc
&
loc
)
{
TBasicType
switchType
=
init
-
>
getBasicType
(
)
;
if
(
(
switchType
!
=
EbtInt
&
&
switchType
!
=
EbtUInt
)
|
|
init
-
>
isMatrix
(
)
|
|
init
-
>
isArray
(
)
|
|
init
-
>
isVector
(
)
)
{
error
(
init
-
>
getLine
(
)
"
init
-
expression
in
a
switch
statement
must
be
a
scalar
integer
"
"
switch
"
)
;
return
nullptr
;
}
if
(
statementList
)
{
if
(
!
ValidateSwitchStatementList
(
switchType
mDiagnostics
statementList
loc
)
)
{
return
nullptr
;
}
}
TIntermSwitch
*
node
=
new
TIntermSwitch
(
init
statementList
)
;
node
-
>
setLine
(
loc
)
;
return
node
;
}
TIntermCase
*
TParseContext
:
:
addCase
(
TIntermTyped
*
condition
const
TSourceLoc
&
loc
)
{
if
(
mSwitchNestingLevel
=
=
0
)
{
error
(
loc
"
case
labels
need
to
be
inside
switch
statements
"
"
case
"
)
;
return
nullptr
;
}
if
(
condition
=
=
nullptr
)
{
error
(
loc
"
case
label
must
have
a
condition
"
"
case
"
)
;
return
nullptr
;
}
if
(
(
condition
-
>
getBasicType
(
)
!
=
EbtInt
&
&
condition
-
>
getBasicType
(
)
!
=
EbtUInt
)
|
|
condition
-
>
isMatrix
(
)
|
|
condition
-
>
isArray
(
)
|
|
condition
-
>
isVector
(
)
)
{
error
(
condition
-
>
getLine
(
)
"
case
label
must
be
a
scalar
integer
"
"
case
"
)
;
}
TIntermConstantUnion
*
conditionConst
=
condition
-
>
getAsConstantUnion
(
)
;
if
(
condition
-
>
getQualifier
(
)
!
=
EvqConst
|
|
conditionConst
=
=
nullptr
)
{
error
(
condition
-
>
getLine
(
)
"
case
label
must
be
constant
"
"
case
"
)
;
}
TIntermCase
*
node
=
new
TIntermCase
(
condition
)
;
node
-
>
setLine
(
loc
)
;
return
node
;
}
TIntermCase
*
TParseContext
:
:
addDefault
(
const
TSourceLoc
&
loc
)
{
if
(
mSwitchNestingLevel
=
=
0
)
{
error
(
loc
"
default
labels
need
to
be
inside
switch
statements
"
"
default
"
)
;
return
nullptr
;
}
TIntermCase
*
node
=
new
TIntermCase
(
nullptr
)
;
node
-
>
setLine
(
loc
)
;
return
node
;
}
TIntermTyped
*
TParseContext
:
:
createUnaryMath
(
TOperator
op
TIntermTyped
*
child
const
TSourceLoc
&
loc
)
{
ASSERT
(
child
!
=
nullptr
)
;
switch
(
op
)
{
case
EOpLogicalNot
:
if
(
child
-
>
getBasicType
(
)
!
=
EbtBool
|
|
child
-
>
isMatrix
(
)
|
|
child
-
>
isArray
(
)
|
|
child
-
>
isVector
(
)
)
{
unaryOpError
(
loc
GetOperatorString
(
op
)
child
-
>
getCompleteString
(
)
)
;
return
nullptr
;
}
break
;
case
EOpBitwiseNot
:
if
(
(
child
-
>
getBasicType
(
)
!
=
EbtInt
&
&
child
-
>
getBasicType
(
)
!
=
EbtUInt
)
|
|
child
-
>
isMatrix
(
)
|
|
child
-
>
isArray
(
)
)
{
unaryOpError
(
loc
GetOperatorString
(
op
)
child
-
>
getCompleteString
(
)
)
;
return
nullptr
;
}
break
;
case
EOpPostIncrement
:
case
EOpPreIncrement
:
case
EOpPostDecrement
:
case
EOpPreDecrement
:
case
EOpNegative
:
case
EOpPositive
:
if
(
child
-
>
getBasicType
(
)
=
=
EbtStruct
|
|
child
-
>
isInterfaceBlock
(
)
|
|
child
-
>
getBasicType
(
)
=
=
EbtBool
|
|
child
-
>
isArray
(
)
|
|
IsOpaqueType
(
child
-
>
getBasicType
(
)
)
)
{
unaryOpError
(
loc
GetOperatorString
(
op
)
child
-
>
getCompleteString
(
)
)
;
return
nullptr
;
}
default
:
break
;
}
if
(
child
-
>
getMemoryQualifier
(
)
.
writeonly
)
{
unaryOpError
(
loc
GetOperatorString
(
op
)
child
-
>
getCompleteString
(
)
)
;
return
nullptr
;
}
TIntermUnary
*
node
=
new
TIntermUnary
(
op
child
)
;
node
-
>
setLine
(
loc
)
;
return
node
-
>
fold
(
mDiagnostics
)
;
}
TIntermTyped
*
TParseContext
:
:
addUnaryMath
(
TOperator
op
TIntermTyped
*
child
const
TSourceLoc
&
loc
)
{
ASSERT
(
op
!
=
EOpNull
)
;
TIntermTyped
*
node
=
createUnaryMath
(
op
child
loc
)
;
if
(
node
=
=
nullptr
)
{
return
child
;
}
return
node
;
}
TIntermTyped
*
TParseContext
:
:
addUnaryMathLValue
(
TOperator
op
TIntermTyped
*
child
const
TSourceLoc
&
loc
)
{
checkCanBeLValue
(
loc
GetOperatorString
(
op
)
child
)
;
return
addUnaryMath
(
op
child
loc
)
;
}
bool
TParseContext
:
:
binaryOpCommonCheck
(
TOperator
op
TIntermTyped
*
left
TIntermTyped
*
right
const
TSourceLoc
&
loc
)
{
if
(
IsOpaqueType
(
left
-
>
getBasicType
(
)
)
|
|
IsOpaqueType
(
right
-
>
getBasicType
(
)
)
)
{
switch
(
op
)
{
case
EOpIndexDirect
:
case
EOpIndexIndirect
:
break
;
case
EOpIndexDirectStruct
:
UNREACHABLE
(
)
;
default
:
error
(
loc
"
Invalid
operation
for
variables
with
an
opaque
type
"
GetOperatorString
(
op
)
)
;
return
false
;
}
}
if
(
right
-
>
getMemoryQualifier
(
)
.
writeonly
)
{
error
(
loc
"
Invalid
operation
for
variables
with
writeonly
"
GetOperatorString
(
op
)
)
;
return
false
;
}
if
(
left
-
>
getMemoryQualifier
(
)
.
writeonly
)
{
switch
(
op
)
{
case
EOpAssign
:
case
EOpInitialize
:
case
EOpIndexDirect
:
case
EOpIndexIndirect
:
case
EOpIndexDirectStruct
:
case
EOpIndexDirectInterfaceBlock
:
break
;
default
:
error
(
loc
"
Invalid
operation
for
variables
with
writeonly
"
GetOperatorString
(
op
)
)
;
return
false
;
}
}
if
(
left
-
>
getType
(
)
.
getStruct
(
)
|
|
right
-
>
getType
(
)
.
getStruct
(
)
)
{
switch
(
op
)
{
case
EOpIndexDirectStruct
:
ASSERT
(
left
-
>
getType
(
)
.
getStruct
(
)
)
;
break
;
case
EOpEqual
:
case
EOpNotEqual
:
case
EOpAssign
:
case
EOpInitialize
:
if
(
left
-
>
getType
(
)
!
=
right
-
>
getType
(
)
)
{
return
false
;
}
break
;
default
:
error
(
loc
"
Invalid
operation
for
structs
"
GetOperatorString
(
op
)
)
;
return
false
;
}
}
if
(
left
-
>
isInterfaceBlock
(
)
|
|
right
-
>
isInterfaceBlock
(
)
)
{
switch
(
op
)
{
case
EOpIndexDirectInterfaceBlock
:
ASSERT
(
left
-
>
getType
(
)
.
getInterfaceBlock
(
)
)
;
break
;
default
:
error
(
loc
"
Invalid
operation
for
interface
blocks
"
GetOperatorString
(
op
)
)
;
return
false
;
}
}
if
(
left
-
>
isArray
(
)
|
|
right
-
>
isArray
(
)
)
{
if
(
mShaderVersion
<
300
)
{
error
(
loc
"
Invalid
operation
for
arrays
"
GetOperatorString
(
op
)
)
;
return
false
;
}
if
(
left
-
>
isArray
(
)
!
=
right
-
>
isArray
(
)
)
{
error
(
loc
"
array
/
non
-
array
mismatch
"
GetOperatorString
(
op
)
)
;
return
false
;
}
switch
(
op
)
{
case
EOpEqual
:
case
EOpNotEqual
:
case
EOpAssign
:
case
EOpInitialize
:
break
;
default
:
error
(
loc
"
Invalid
operation
for
arrays
"
GetOperatorString
(
op
)
)
;
return
false
;
}
if
(
left
-
>
getType
(
)
.
getArraySizes
(
)
!
=
right
-
>
getType
(
)
.
getArraySizes
(
)
)
{
error
(
loc
"
array
size
mismatch
"
GetOperatorString
(
op
)
)
;
return
false
;
}
}
bool
isBitShift
=
false
;
switch
(
op
)
{
case
EOpBitShiftLeft
:
case
EOpBitShiftRight
:
case
EOpBitShiftLeftAssign
:
case
EOpBitShiftRightAssign
:
isBitShift
=
true
;
if
(
!
IsInteger
(
left
-
>
getBasicType
(
)
)
|
|
!
IsInteger
(
right
-
>
getBasicType
(
)
)
)
{
return
false
;
}
break
;
case
EOpBitwiseAnd
:
case
EOpBitwiseXor
:
case
EOpBitwiseOr
:
case
EOpBitwiseAndAssign
:
case
EOpBitwiseXorAssign
:
case
EOpBitwiseOrAssign
:
if
(
!
IsInteger
(
left
-
>
getBasicType
(
)
)
)
{
return
false
;
}
break
;
default
:
break
;
}
if
(
!
isBitShift
&
&
left
-
>
getBasicType
(
)
!
=
right
-
>
getBasicType
(
)
)
{
return
false
;
}
switch
(
op
)
{
case
EOpAssign
:
case
EOpInitialize
:
case
EOpEqual
:
case
EOpNotEqual
:
if
(
mShaderVersion
<
300
&
&
left
-
>
getType
(
)
.
isStructureContainingArrays
(
)
)
{
error
(
loc
"
undefined
operation
for
structs
containing
arrays
"
GetOperatorString
(
op
)
)
;
return
false
;
}
if
(
(
mShaderVersion
<
300
|
|
op
=
=
EOpAssign
|
|
op
=
=
EOpInitialize
)
&
&
left
-
>
getType
(
)
.
isStructureContainingSamplers
(
)
)
{
error
(
loc
"
undefined
operation
for
structs
containing
samplers
"
GetOperatorString
(
op
)
)
;
return
false
;
}
if
(
(
left
-
>
getNominalSize
(
)
!
=
right
-
>
getNominalSize
(
)
)
|
|
(
left
-
>
getSecondarySize
(
)
!
=
right
-
>
getSecondarySize
(
)
)
)
{
error
(
loc
"
dimension
mismatch
"
GetOperatorString
(
op
)
)
;
return
false
;
}
break
;
case
EOpLessThan
:
case
EOpGreaterThan
:
case
EOpLessThanEqual
:
case
EOpGreaterThanEqual
:
if
(
!
left
-
>
isScalar
(
)
|
|
!
right
-
>
isScalar
(
)
)
{
error
(
loc
"
comparison
operator
only
defined
for
scalars
"
GetOperatorString
(
op
)
)
;
return
false
;
}
break
;
case
EOpAdd
:
case
EOpSub
:
case
EOpDiv
:
case
EOpIMod
:
case
EOpBitShiftLeft
:
case
EOpBitShiftRight
:
case
EOpBitwiseAnd
:
case
EOpBitwiseXor
:
case
EOpBitwiseOr
:
case
EOpAddAssign
:
case
EOpSubAssign
:
case
EOpDivAssign
:
case
EOpIModAssign
:
case
EOpBitShiftLeftAssign
:
case
EOpBitShiftRightAssign
:
case
EOpBitwiseAndAssign
:
case
EOpBitwiseXorAssign
:
case
EOpBitwiseOrAssign
:
if
(
(
left
-
>
isMatrix
(
)
&
&
right
-
>
isVector
(
)
)
|
|
(
left
-
>
isVector
(
)
&
&
right
-
>
isMatrix
(
)
)
)
{
return
false
;
}
if
(
left
-
>
getNominalSize
(
)
!
=
right
-
>
getNominalSize
(
)
|
|
left
-
>
getSecondarySize
(
)
!
=
right
-
>
getSecondarySize
(
)
)
{
if
(
!
left
-
>
isScalar
(
)
&
&
!
right
-
>
isScalar
(
)
)
return
false
;
if
(
!
right
-
>
isScalar
(
)
&
&
(
IsAssignment
(
op
)
|
|
op
=
=
EOpBitShiftLeft
|
|
op
=
=
EOpBitShiftRight
)
)
return
false
;
}
break
;
default
:
break
;
}
return
true
;
}
bool
TParseContext
:
:
isMultiplicationTypeCombinationValid
(
TOperator
op
const
TType
&
left
const
TType
&
right
)
{
switch
(
op
)
{
case
EOpMul
:
case
EOpMulAssign
:
return
left
.
getNominalSize
(
)
=
=
right
.
getNominalSize
(
)
&
&
left
.
getSecondarySize
(
)
=
=
right
.
getSecondarySize
(
)
;
case
EOpVectorTimesScalar
:
return
true
;
case
EOpVectorTimesScalarAssign
:
ASSERT
(
!
left
.
isMatrix
(
)
&
&
!
right
.
isMatrix
(
)
)
;
return
left
.
isVector
(
)
&
&
!
right
.
isVector
(
)
;
case
EOpVectorTimesMatrix
:
return
left
.
getNominalSize
(
)
=
=
right
.
getRows
(
)
;
case
EOpVectorTimesMatrixAssign
:
ASSERT
(
!
left
.
isMatrix
(
)
&
&
right
.
isMatrix
(
)
)
;
return
left
.
isVector
(
)
&
&
left
.
getNominalSize
(
)
=
=
right
.
getRows
(
)
&
&
left
.
getNominalSize
(
)
=
=
right
.
getCols
(
)
;
case
EOpMatrixTimesVector
:
return
left
.
getCols
(
)
=
=
right
.
getNominalSize
(
)
;
case
EOpMatrixTimesScalar
:
return
true
;
case
EOpMatrixTimesScalarAssign
:
ASSERT
(
left
.
isMatrix
(
)
&
&
!
right
.
isMatrix
(
)
)
;
return
!
right
.
isVector
(
)
;
case
EOpMatrixTimesMatrix
:
return
left
.
getCols
(
)
=
=
right
.
getRows
(
)
;
case
EOpMatrixTimesMatrixAssign
:
ASSERT
(
left
.
isMatrix
(
)
&
&
right
.
isMatrix
(
)
)
;
return
left
.
getCols
(
)
=
=
right
.
getRows
(
)
&
&
left
.
getCols
(
)
=
=
right
.
getCols
(
)
;
default
:
UNREACHABLE
(
)
;
return
false
;
}
}
TIntermTyped
*
TParseContext
:
:
addBinaryMathInternal
(
TOperator
op
TIntermTyped
*
left
TIntermTyped
*
right
const
TSourceLoc
&
loc
)
{
if
(
!
binaryOpCommonCheck
(
op
left
right
loc
)
)
return
nullptr
;
switch
(
op
)
{
case
EOpEqual
:
case
EOpNotEqual
:
case
EOpLessThan
:
case
EOpGreaterThan
:
case
EOpLessThanEqual
:
case
EOpGreaterThanEqual
:
break
;
case
EOpLogicalOr
:
case
EOpLogicalXor
:
case
EOpLogicalAnd
:
ASSERT
(
!
left
-
>
isArray
(
)
&
&
!
right
-
>
isArray
(
)
&
&
!
left
-
>
getType
(
)
.
getStruct
(
)
&
&
!
right
-
>
getType
(
)
.
getStruct
(
)
)
;
if
(
left
-
>
getBasicType
(
)
!
=
EbtBool
|
|
!
left
-
>
isScalar
(
)
|
|
!
right
-
>
isScalar
(
)
)
{
return
nullptr
;
}
ASSERT
(
right
-
>
getBasicType
(
)
=
=
EbtBool
)
;
break
;
case
EOpAdd
:
case
EOpSub
:
case
EOpDiv
:
case
EOpMul
:
ASSERT
(
!
left
-
>
isArray
(
)
&
&
!
right
-
>
isArray
(
)
&
&
!
left
-
>
getType
(
)
.
getStruct
(
)
&
&
!
right
-
>
getType
(
)
.
getStruct
(
)
)
;
if
(
left
-
>
getBasicType
(
)
=
=
EbtBool
)
{
return
nullptr
;
}
break
;
case
EOpIMod
:
ASSERT
(
!
left
-
>
isArray
(
)
&
&
!
right
-
>
isArray
(
)
&
&
!
left
-
>
getType
(
)
.
getStruct
(
)
&
&
!
right
-
>
getType
(
)
.
getStruct
(
)
)
;
if
(
left
-
>
getBasicType
(
)
=
=
EbtBool
|
|
left
-
>
getBasicType
(
)
=
=
EbtFloat
)
{
return
nullptr
;
}
break
;
default
:
break
;
}
if
(
op
=
=
EOpMul
)
{
op
=
TIntermBinary
:
:
GetMulOpBasedOnOperands
(
left
-
>
getType
(
)
right
-
>
getType
(
)
)
;
if
(
!
isMultiplicationTypeCombinationValid
(
op
left
-
>
getType
(
)
right
-
>
getType
(
)
)
)
{
return
nullptr
;
}
}
TIntermBinary
*
node
=
new
TIntermBinary
(
op
left
right
)
;
node
-
>
setLine
(
loc
)
;
return
node
-
>
fold
(
mDiagnostics
)
;
}
TIntermTyped
*
TParseContext
:
:
addBinaryMath
(
TOperator
op
TIntermTyped
*
left
TIntermTyped
*
right
const
TSourceLoc
&
loc
)
{
TIntermTyped
*
node
=
addBinaryMathInternal
(
op
left
right
loc
)
;
if
(
node
=
=
0
)
{
binaryOpError
(
loc
GetOperatorString
(
op
)
left
-
>
getCompleteString
(
)
right
-
>
getCompleteString
(
)
)
;
return
left
;
}
return
node
;
}
TIntermTyped
*
TParseContext
:
:
addBinaryMathBooleanResult
(
TOperator
op
TIntermTyped
*
left
TIntermTyped
*
right
const
TSourceLoc
&
loc
)
{
TIntermTyped
*
node
=
addBinaryMathInternal
(
op
left
right
loc
)
;
if
(
node
=
=
nullptr
)
{
binaryOpError
(
loc
GetOperatorString
(
op
)
left
-
>
getCompleteString
(
)
right
-
>
getCompleteString
(
)
)
;
node
=
CreateBoolNode
(
false
)
;
node
-
>
setLine
(
loc
)
;
}
return
node
;
}
TIntermBinary
*
TParseContext
:
:
createAssign
(
TOperator
op
TIntermTyped
*
left
TIntermTyped
*
right
const
TSourceLoc
&
loc
)
{
if
(
binaryOpCommonCheck
(
op
left
right
loc
)
)
{
if
(
op
=
=
EOpMulAssign
)
{
op
=
TIntermBinary
:
:
GetMulAssignOpBasedOnOperands
(
left
-
>
getType
(
)
right
-
>
getType
(
)
)
;
if
(
!
isMultiplicationTypeCombinationValid
(
op
left
-
>
getType
(
)
right
-
>
getType
(
)
)
)
{
return
nullptr
;
}
}
TIntermBinary
*
node
=
new
TIntermBinary
(
op
left
right
)
;
node
-
>
setLine
(
loc
)
;
return
node
;
}
return
nullptr
;
}
TIntermTyped
*
TParseContext
:
:
addAssign
(
TOperator
op
TIntermTyped
*
left
TIntermTyped
*
right
const
TSourceLoc
&
loc
)
{
checkCanBeLValue
(
loc
"
assign
"
left
)
;
TIntermTyped
*
node
=
createAssign
(
op
left
right
loc
)
;
if
(
node
=
=
nullptr
)
{
assignError
(
loc
"
assign
"
left
-
>
getCompleteString
(
)
right
-
>
getCompleteString
(
)
)
;
return
left
;
}
return
node
;
}
TIntermTyped
*
TParseContext
:
:
addComma
(
TIntermTyped
*
left
TIntermTyped
*
right
const
TSourceLoc
&
loc
)
{
if
(
mShaderSpec
=
=
SH_WEBGL2_SPEC
&
&
(
left
-
>
isArray
(
)
|
|
left
-
>
getBasicType
(
)
=
=
EbtVoid
|
|
left
-
>
getType
(
)
.
isStructureContainingArrays
(
)
|
|
right
-
>
isArray
(
)
|
|
right
-
>
getBasicType
(
)
=
=
EbtVoid
|
|
right
-
>
getType
(
)
.
isStructureContainingArrays
(
)
)
)
{
error
(
loc
"
sequence
operator
is
not
allowed
for
void
arrays
or
structs
containing
arrays
"
"
"
)
;
}
TIntermBinary
*
commaNode
=
new
TIntermBinary
(
EOpComma
left
right
)
;
TQualifier
resultQualifier
=
TIntermBinary
:
:
GetCommaQualifier
(
mShaderVersion
left
right
)
;
commaNode
-
>
getTypePointer
(
)
-
>
setQualifier
(
resultQualifier
)
;
return
commaNode
-
>
fold
(
mDiagnostics
)
;
}
TIntermBranch
*
TParseContext
:
:
addBranch
(
TOperator
op
const
TSourceLoc
&
loc
)
{
switch
(
op
)
{
case
EOpContinue
:
if
(
mLoopNestingLevel
<
=
0
)
{
error
(
loc
"
continue
statement
only
allowed
in
loops
"
"
"
)
;
}
break
;
case
EOpBreak
:
if
(
mLoopNestingLevel
<
=
0
&
&
mSwitchNestingLevel
<
=
0
)
{
error
(
loc
"
break
statement
only
allowed
in
loops
and
switch
statements
"
"
"
)
;
}
break
;
case
EOpReturn
:
if
(
mCurrentFunctionType
-
>
getBasicType
(
)
!
=
EbtVoid
)
{
error
(
loc
"
non
-
void
function
must
return
a
value
"
"
return
"
)
;
}
break
;
case
EOpKill
:
if
(
mShaderType
!
=
GL_FRAGMENT_SHADER
)
{
error
(
loc
"
discard
supported
in
fragment
shaders
only
"
"
discard
"
)
;
}
break
;
default
:
UNREACHABLE
(
)
;
break
;
}
return
addBranch
(
op
nullptr
loc
)
;
}
TIntermBranch
*
TParseContext
:
:
addBranch
(
TOperator
op
TIntermTyped
*
expression
const
TSourceLoc
&
loc
)
{
if
(
expression
!
=
nullptr
)
{
ASSERT
(
op
=
=
EOpReturn
)
;
mFunctionReturnsValue
=
true
;
if
(
mCurrentFunctionType
-
>
getBasicType
(
)
=
=
EbtVoid
)
{
error
(
loc
"
void
function
cannot
return
a
value
"
"
return
"
)
;
}
else
if
(
*
mCurrentFunctionType
!
=
expression
-
>
getType
(
)
)
{
error
(
loc
"
function
return
is
not
matching
type
:
"
"
return
"
)
;
}
}
TIntermBranch
*
node
=
new
TIntermBranch
(
op
expression
)
;
node
-
>
setLine
(
loc
)
;
return
node
;
}
void
TParseContext
:
:
checkTextureGather
(
TIntermAggregate
*
functionCall
)
{
ASSERT
(
functionCall
-
>
getOp
(
)
=
=
EOpCallBuiltInFunction
)
;
const
TString
&
name
=
functionCall
-
>
getFunctionSymbolInfo
(
)
-
>
getName
(
)
;
bool
isTextureGather
=
(
name
=
=
"
textureGather
"
)
;
bool
isTextureGatherOffset
=
(
name
=
=
"
textureGatherOffset
"
)
;
if
(
isTextureGather
|
|
isTextureGatherOffset
)
{
TIntermNode
*
componentNode
=
nullptr
;
TIntermSequence
*
arguments
=
functionCall
-
>
getSequence
(
)
;
ASSERT
(
arguments
-
>
size
(
)
>
=
2u
&
&
arguments
-
>
size
(
)
<
=
4u
)
;
const
TIntermTyped
*
sampler
=
arguments
-
>
front
(
)
-
>
getAsTyped
(
)
;
ASSERT
(
sampler
!
=
nullptr
)
;
switch
(
sampler
-
>
getBasicType
(
)
)
{
case
EbtSampler2D
:
case
EbtISampler2D
:
case
EbtUSampler2D
:
case
EbtSampler2DArray
:
case
EbtISampler2DArray
:
case
EbtUSampler2DArray
:
if
(
(
isTextureGather
&
&
arguments
-
>
size
(
)
=
=
3u
)
|
|
(
isTextureGatherOffset
&
&
arguments
-
>
size
(
)
=
=
4u
)
)
{
componentNode
=
arguments
-
>
back
(
)
;
}
break
;
case
EbtSamplerCube
:
case
EbtISamplerCube
:
case
EbtUSamplerCube
:
ASSERT
(
!
isTextureGatherOffset
)
;
if
(
arguments
-
>
size
(
)
=
=
3u
)
{
componentNode
=
arguments
-
>
back
(
)
;
}
break
;
case
EbtSampler2DShadow
:
case
EbtSampler2DArrayShadow
:
case
EbtSamplerCubeShadow
:
break
;
default
:
UNREACHABLE
(
)
;
break
;
}
if
(
componentNode
)
{
const
TIntermConstantUnion
*
componentConstantUnion
=
componentNode
-
>
getAsConstantUnion
(
)
;
if
(
componentNode
-
>
getAsTyped
(
)
-
>
getQualifier
(
)
!
=
EvqConst
|
|
!
componentConstantUnion
)
{
error
(
functionCall
-
>
getLine
(
)
"
Texture
component
must
be
a
constant
expression
"
name
.
c_str
(
)
)
;
}
else
{
int
component
=
componentConstantUnion
-
>
getIConst
(
0
)
;
if
(
component
<
0
|
|
component
>
3
)
{
error
(
functionCall
-
>
getLine
(
)
"
Component
must
be
in
the
range
[
0
;
3
]
"
name
.
c_str
(
)
)
;
}
}
}
}
}
void
TParseContext
:
:
checkTextureOffsetConst
(
TIntermAggregate
*
functionCall
)
{
ASSERT
(
functionCall
-
>
getOp
(
)
=
=
EOpCallBuiltInFunction
)
;
const
TString
&
name
=
functionCall
-
>
getFunctionSymbolInfo
(
)
-
>
getName
(
)
;
TIntermNode
*
offset
=
nullptr
;
TIntermSequence
*
arguments
=
functionCall
-
>
getSequence
(
)
;
bool
useTextureGatherOffsetConstraints
=
false
;
if
(
name
=
=
"
texelFetchOffset
"
|
|
name
=
=
"
textureLodOffset
"
|
|
name
=
=
"
textureProjLodOffset
"
|
|
name
=
=
"
textureGradOffset
"
|
|
name
=
=
"
textureProjGradOffset
"
)
{
offset
=
arguments
-
>
back
(
)
;
}
else
if
(
name
=
=
"
textureOffset
"
|
|
name
=
=
"
textureProjOffset
"
)
{
ASSERT
(
arguments
-
>
size
(
)
>
=
3
)
;
offset
=
(
*
arguments
)
[
2
]
;
}
else
if
(
name
=
=
"
textureGatherOffset
"
)
{
ASSERT
(
arguments
-
>
size
(
)
>
=
3u
)
;
const
TIntermTyped
*
sampler
=
arguments
-
>
front
(
)
-
>
getAsTyped
(
)
;
ASSERT
(
sampler
!
=
nullptr
)
;
switch
(
sampler
-
>
getBasicType
(
)
)
{
case
EbtSampler2D
:
case
EbtISampler2D
:
case
EbtUSampler2D
:
case
EbtSampler2DArray
:
case
EbtISampler2DArray
:
case
EbtUSampler2DArray
:
offset
=
(
*
arguments
)
[
2
]
;
break
;
case
EbtSampler2DShadow
:
case
EbtSampler2DArrayShadow
:
offset
=
(
*
arguments
)
[
3
]
;
break
;
default
:
UNREACHABLE
(
)
;
break
;
}
useTextureGatherOffsetConstraints
=
true
;
}
if
(
offset
!
=
nullptr
)
{
TIntermConstantUnion
*
offsetConstantUnion
=
offset
-
>
getAsConstantUnion
(
)
;
if
(
offset
-
>
getAsTyped
(
)
-
>
getQualifier
(
)
!
=
EvqConst
|
|
!
offsetConstantUnion
)
{
error
(
functionCall
-
>
getLine
(
)
"
Texture
offset
must
be
a
constant
expression
"
name
.
c_str
(
)
)
;
}
else
{
ASSERT
(
offsetConstantUnion
-
>
getBasicType
(
)
=
=
EbtInt
)
;
size_t
size
=
offsetConstantUnion
-
>
getType
(
)
.
getObjectSize
(
)
;
const
TConstantUnion
*
values
=
offsetConstantUnion
-
>
getUnionArrayPointer
(
)
;
int
minOffsetValue
=
useTextureGatherOffsetConstraints
?
mMinProgramTextureGatherOffset
:
mMinProgramTexelOffset
;
int
maxOffsetValue
=
useTextureGatherOffsetConstraints
?
mMaxProgramTextureGatherOffset
:
mMaxProgramTexelOffset
;
for
(
size_t
i
=
0u
;
i
<
size
;
+
+
i
)
{
int
offsetValue
=
values
[
i
]
.
getIConst
(
)
;
if
(
offsetValue
>
maxOffsetValue
|
|
offsetValue
<
minOffsetValue
)
{
std
:
:
stringstream
tokenStream
;
tokenStream
<
<
offsetValue
;
std
:
:
string
token
=
tokenStream
.
str
(
)
;
error
(
offset
-
>
getLine
(
)
"
Texture
offset
value
out
of
valid
range
"
token
.
c_str
(
)
)
;
}
}
}
}
}
void
TParseContext
:
:
checkImageMemoryAccessForBuiltinFunctions
(
TIntermAggregate
*
functionCall
)
{
ASSERT
(
functionCall
-
>
getOp
(
)
=
=
EOpCallBuiltInFunction
)
;
const
TString
&
name
=
functionCall
-
>
getFunctionSymbolInfo
(
)
-
>
getName
(
)
;
if
(
name
.
compare
(
0
5
"
image
"
)
=
=
0
)
{
TIntermSequence
*
arguments
=
functionCall
-
>
getSequence
(
)
;
TIntermTyped
*
imageNode
=
(
*
arguments
)
[
0
]
-
>
getAsTyped
(
)
;
const
TMemoryQualifier
&
memoryQualifier
=
imageNode
-
>
getMemoryQualifier
(
)
;
if
(
name
.
compare
(
5
5
"
Store
"
)
=
=
0
)
{
if
(
memoryQualifier
.
readonly
)
{
error
(
imageNode
-
>
getLine
(
)
"
'
imageStore
'
cannot
be
used
with
images
qualified
as
'
readonly
'
"
GetImageArgumentToken
(
imageNode
)
)
;
}
}
else
if
(
name
.
compare
(
5
4
"
Load
"
)
=
=
0
)
{
if
(
memoryQualifier
.
writeonly
)
{
error
(
imageNode
-
>
getLine
(
)
"
'
imageLoad
'
cannot
be
used
with
images
qualified
as
'
writeonly
'
"
GetImageArgumentToken
(
imageNode
)
)
;
}
}
}
}
void
TParseContext
:
:
checkImageMemoryAccessForUserDefinedFunctions
(
const
TFunction
*
functionDefinition
const
TIntermAggregate
*
functionCall
)
{
ASSERT
(
functionCall
-
>
getOp
(
)
=
=
EOpCallFunctionInAST
)
;
const
TIntermSequence
&
arguments
=
*
functionCall
-
>
getSequence
(
)
;
ASSERT
(
functionDefinition
-
>
getParamCount
(
)
=
=
arguments
.
size
(
)
)
;
for
(
size_t
i
=
0
;
i
<
arguments
.
size
(
)
;
+
+
i
)
{
TIntermTyped
*
typedArgument
=
arguments
[
i
]
-
>
getAsTyped
(
)
;
const
TType
&
functionArgumentType
=
typedArgument
-
>
getType
(
)
;
const
TType
&
functionParameterType
=
*
functionDefinition
-
>
getParam
(
i
)
.
type
;
ASSERT
(
functionArgumentType
.
getBasicType
(
)
=
=
functionParameterType
.
getBasicType
(
)
)
;
if
(
IsImage
(
functionArgumentType
.
getBasicType
(
)
)
)
{
const
TMemoryQualifier
&
functionArgumentMemoryQualifier
=
functionArgumentType
.
getMemoryQualifier
(
)
;
const
TMemoryQualifier
&
functionParameterMemoryQualifier
=
functionParameterType
.
getMemoryQualifier
(
)
;
if
(
functionArgumentMemoryQualifier
.
readonly
&
&
!
functionParameterMemoryQualifier
.
readonly
)
{
error
(
functionCall
-
>
getLine
(
)
"
Function
call
discards
the
'
readonly
'
qualifier
from
image
"
GetImageArgumentToken
(
typedArgument
)
)
;
}
if
(
functionArgumentMemoryQualifier
.
writeonly
&
&
!
functionParameterMemoryQualifier
.
writeonly
)
{
error
(
functionCall
-
>
getLine
(
)
"
Function
call
discards
the
'
writeonly
'
qualifier
from
image
"
GetImageArgumentToken
(
typedArgument
)
)
;
}
if
(
functionArgumentMemoryQualifier
.
coherent
&
&
!
functionParameterMemoryQualifier
.
coherent
)
{
error
(
functionCall
-
>
getLine
(
)
"
Function
call
discards
the
'
coherent
'
qualifier
from
image
"
GetImageArgumentToken
(
typedArgument
)
)
;
}
if
(
functionArgumentMemoryQualifier
.
volatileQualifier
&
&
!
functionParameterMemoryQualifier
.
volatileQualifier
)
{
error
(
functionCall
-
>
getLine
(
)
"
Function
call
discards
the
'
volatile
'
qualifier
from
image
"
GetImageArgumentToken
(
typedArgument
)
)
;
}
}
}
}
TIntermSequence
*
TParseContext
:
:
createEmptyArgumentsList
(
)
{
return
new
TIntermSequence
(
)
;
}
TIntermTyped
*
TParseContext
:
:
addFunctionCallOrMethod
(
TFunction
*
fnCall
TIntermSequence
*
arguments
TIntermNode
*
thisNode
const
TSourceLoc
&
loc
)
{
if
(
thisNode
!
=
nullptr
)
{
return
addMethod
(
fnCall
arguments
thisNode
loc
)
;
}
TOperator
op
=
fnCall
-
>
getBuiltInOp
(
)
;
if
(
op
=
=
EOpConstruct
)
{
return
addConstructor
(
arguments
fnCall
-
>
getReturnType
(
)
loc
)
;
}
else
{
ASSERT
(
op
=
=
EOpNull
)
;
return
addNonConstructorFunctionCall
(
fnCall
arguments
loc
)
;
}
}
TIntermTyped
*
TParseContext
:
:
addMethod
(
TFunction
*
fnCall
TIntermSequence
*
arguments
TIntermNode
*
thisNode
const
TSourceLoc
&
loc
)
{
TIntermTyped
*
typedThis
=
thisNode
-
>
getAsTyped
(
)
;
if
(
fnCall
-
>
getName
(
)
!
=
"
length
"
)
{
error
(
loc
"
invalid
method
"
fnCall
-
>
getName
(
)
.
c_str
(
)
)
;
}
else
if
(
!
arguments
-
>
empty
(
)
)
{
error
(
loc
"
method
takes
no
parameters
"
"
length
"
)
;
}
else
if
(
typedThis
=
=
nullptr
|
|
!
typedThis
-
>
isArray
(
)
)
{
error
(
loc
"
length
can
only
be
called
on
arrays
"
"
length
"
)
;
}
else
if
(
typedThis
-
>
getQualifier
(
)
=
=
EvqPerVertexIn
&
&
mGeometryShaderInputPrimitiveType
=
=
EptUndefined
)
{
error
(
loc
"
missing
input
primitive
declaration
before
calling
length
on
gl_in
"
"
length
"
)
;
}
else
{
TIntermUnary
*
node
=
new
TIntermUnary
(
EOpArrayLength
typedThis
)
;
node
-
>
setLine
(
loc
)
;
return
node
-
>
fold
(
mDiagnostics
)
;
}
return
CreateZeroNode
(
TType
(
EbtInt
EbpUndefined
EvqConst
)
)
;
}
TIntermTyped
*
TParseContext
:
:
addNonConstructorFunctionCall
(
TFunction
*
fnCall
TIntermSequence
*
arguments
const
TSourceLoc
&
loc
)
{
bool
builtIn
;
const
TSymbol
*
symbol
=
symbolTable
.
find
(
fnCall
-
>
getName
(
)
mShaderVersion
&
builtIn
)
;
if
(
symbol
!
=
nullptr
&
&
!
symbol
-
>
isFunction
(
)
)
{
error
(
loc
"
function
name
expected
"
fnCall
-
>
getName
(
)
.
c_str
(
)
)
;
}
else
{
symbol
=
symbolTable
.
find
(
TFunction
:
:
GetMangledNameFromCall
(
fnCall
-
>
getName
(
)
*
arguments
)
mShaderVersion
&
builtIn
)
;
if
(
symbol
=
=
nullptr
)
{
error
(
loc
"
no
matching
overloaded
function
found
"
fnCall
-
>
getName
(
)
.
c_str
(
)
)
;
}
else
{
const
TFunction
*
fnCandidate
=
static_cast
<
const
TFunction
*
>
(
symbol
)
;
if
(
builtIn
&
&
fnCandidate
-
>
getExtension
(
)
!
=
TExtension
:
:
UNDEFINED
)
{
checkCanUseExtension
(
loc
fnCandidate
-
>
getExtension
(
)
)
;
}
TOperator
op
=
fnCandidate
-
>
getBuiltInOp
(
)
;
if
(
builtIn
&
&
op
!
=
EOpNull
)
{
if
(
fnCandidate
-
>
getParamCount
(
)
=
=
1
)
{
TIntermNode
*
unaryParamNode
=
arguments
-
>
front
(
)
;
TIntermTyped
*
callNode
=
createUnaryMath
(
op
unaryParamNode
-
>
getAsTyped
(
)
loc
)
;
ASSERT
(
callNode
!
=
nullptr
)
;
return
callNode
;
}
else
{
TIntermAggregate
*
callNode
=
TIntermAggregate
:
:
Create
(
fnCandidate
-
>
getReturnType
(
)
op
arguments
)
;
callNode
-
>
setLine
(
loc
)
;
functionCallRValueLValueErrorCheck
(
fnCandidate
callNode
)
;
if
(
TIntermAggregate
:
:
CanFoldAggregateBuiltInOp
(
callNode
-
>
getOp
(
)
)
)
{
return
callNode
-
>
fold
(
mDiagnostics
)
;
}
else
{
return
callNode
;
}
}
}
else
{
TIntermAggregate
*
callNode
=
nullptr
;
if
(
builtIn
)
{
callNode
=
TIntermAggregate
:
:
CreateBuiltInFunctionCall
(
*
fnCandidate
arguments
)
;
checkTextureOffsetConst
(
callNode
)
;
checkTextureGather
(
callNode
)
;
checkImageMemoryAccessForBuiltinFunctions
(
callNode
)
;
}
else
{
callNode
=
TIntermAggregate
:
:
CreateFunctionCall
(
*
fnCandidate
arguments
)
;
checkImageMemoryAccessForUserDefinedFunctions
(
fnCandidate
callNode
)
;
}
functionCallRValueLValueErrorCheck
(
fnCandidate
callNode
)
;
callNode
-
>
setLine
(
loc
)
;
return
callNode
;
}
}
}
return
CreateZeroNode
(
TType
(
EbtFloat
EbpMedium
EvqConst
)
)
;
}
TIntermTyped
*
TParseContext
:
:
addTernarySelection
(
TIntermTyped
*
cond
TIntermTyped
*
trueExpression
TIntermTyped
*
falseExpression
const
TSourceLoc
&
loc
)
{
if
(
!
checkIsScalarBool
(
loc
cond
)
)
{
return
falseExpression
;
}
if
(
trueExpression
-
>
getType
(
)
!
=
falseExpression
-
>
getType
(
)
)
{
std
:
:
stringstream
reasonStream
;
reasonStream
<
<
"
mismatching
ternary
operator
operand
types
'
"
<
<
trueExpression
-
>
getCompleteString
(
)
<
<
"
and
'
"
<
<
falseExpression
-
>
getCompleteString
(
)
<
<
"
'
"
;
std
:
:
string
reason
=
reasonStream
.
str
(
)
;
error
(
loc
reason
.
c_str
(
)
"
?
:
"
)
;
return
falseExpression
;
}
if
(
IsOpaqueType
(
trueExpression
-
>
getBasicType
(
)
)
)
{
error
(
loc
"
ternary
operator
is
not
allowed
for
opaque
types
"
"
?
:
"
)
;
return
falseExpression
;
}
if
(
cond
-
>
getMemoryQualifier
(
)
.
writeonly
|
|
trueExpression
-
>
getMemoryQualifier
(
)
.
writeonly
|
|
falseExpression
-
>
getMemoryQualifier
(
)
.
writeonly
)
{
error
(
loc
"
ternary
operator
is
not
allowed
for
variables
with
writeonly
"
"
?
:
"
)
;
return
falseExpression
;
}
if
(
trueExpression
-
>
isArray
(
)
|
|
trueExpression
-
>
getBasicType
(
)
=
=
EbtStruct
)
{
error
(
loc
"
ternary
operator
is
not
allowed
for
structures
or
arrays
"
"
?
:
"
)
;
return
falseExpression
;
}
if
(
trueExpression
-
>
getBasicType
(
)
=
=
EbtInterfaceBlock
)
{
error
(
loc
"
ternary
operator
is
not
allowed
for
interface
blocks
"
"
?
:
"
)
;
return
falseExpression
;
}
if
(
mShaderSpec
=
=
SH_WEBGL2_SPEC
&
&
trueExpression
-
>
getBasicType
(
)
=
=
EbtVoid
)
{
error
(
loc
"
ternary
operator
is
not
allowed
for
void
"
"
?
:
"
)
;
return
falseExpression
;
}
TIntermTernary
*
node
=
new
TIntermTernary
(
cond
trueExpression
falseExpression
)
;
node
-
>
setLine
(
loc
)
;
return
node
-
>
fold
(
)
;
}
int
PaParseStrings
(
size_t
count
const
char
*
const
string
[
]
const
int
length
[
]
TParseContext
*
context
)
{
if
(
(
count
=
=
0
)
|
|
(
string
=
=
nullptr
)
)
return
1
;
if
(
glslang_initialize
(
context
)
)
return
1
;
int
error
=
glslang_scan
(
count
string
length
context
)
;
if
(
!
error
)
error
=
glslang_parse
(
context
)
;
glslang_finalize
(
context
)
;
return
(
error
=
=
0
)
&
&
(
context
-
>
numErrors
(
)
=
=
0
)
?
0
:
1
;
}
}
