#
include
<
float
.
h
>
#
include
<
limits
.
h
>
#
include
<
algorithm
>
#
include
"
compiler
/
translator
/
Intermediate
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
TIntermSymbol
*
TIntermediate
:
:
addSymbol
(
int
id
const
TString
&
name
const
TType
&
type
const
TSourceLoc
&
line
)
{
TIntermSymbol
*
node
=
new
TIntermSymbol
(
id
name
type
)
;
node
-
>
setLine
(
line
)
;
return
node
;
}
TIntermTyped
*
TIntermediate
:
:
addBinaryMath
(
TOperator
op
TIntermTyped
*
left
TIntermTyped
*
right
const
TSourceLoc
&
line
)
{
TIntermBinary
*
node
=
new
TIntermBinary
(
op
)
;
node
-
>
setLine
(
line
)
;
node
-
>
setLeft
(
left
)
;
node
-
>
setRight
(
right
)
;
if
(
!
node
-
>
promote
(
mInfoSink
)
)
return
NULL
;
TIntermTyped
*
foldedNode
=
node
-
>
fold
(
mInfoSink
)
;
if
(
foldedNode
)
return
foldedNode
;
return
node
;
}
TIntermTyped
*
TIntermediate
:
:
addAssign
(
TOperator
op
TIntermTyped
*
left
TIntermTyped
*
right
const
TSourceLoc
&
line
)
{
if
(
left
-
>
getType
(
)
.
getStruct
(
)
|
|
right
-
>
getType
(
)
.
getStruct
(
)
)
{
if
(
left
-
>
getType
(
)
!
=
right
-
>
getType
(
)
)
{
return
NULL
;
}
}
TIntermBinary
*
node
=
new
TIntermBinary
(
op
)
;
node
-
>
setLine
(
line
)
;
node
-
>
setLeft
(
left
)
;
node
-
>
setRight
(
right
)
;
if
(
!
node
-
>
promote
(
mInfoSink
)
)
return
NULL
;
return
node
;
}
TIntermTyped
*
TIntermediate
:
:
addIndex
(
TOperator
op
TIntermTyped
*
base
TIntermTyped
*
index
const
TSourceLoc
&
line
)
{
TIntermBinary
*
node
=
new
TIntermBinary
(
op
)
;
node
-
>
setLine
(
line
)
;
node
-
>
setLeft
(
base
)
;
node
-
>
setRight
(
index
)
;
return
node
;
}
TIntermTyped
*
TIntermediate
:
:
addUnaryMath
(
TOperator
op
TIntermTyped
*
child
const
TSourceLoc
&
line
const
TType
*
funcReturnType
)
{
TIntermUnary
*
node
=
new
TIntermUnary
(
op
)
;
node
-
>
setLine
(
line
)
;
node
-
>
setOperand
(
child
)
;
node
-
>
promote
(
funcReturnType
)
;
TIntermTyped
*
foldedNode
=
node
-
>
fold
(
mInfoSink
)
;
if
(
foldedNode
)
return
foldedNode
;
return
node
;
}
TIntermAggregate
*
TIntermediate
:
:
setAggregateOperator
(
TIntermNode
*
node
TOperator
op
const
TSourceLoc
&
line
)
{
TIntermAggregate
*
aggNode
;
if
(
node
)
{
aggNode
=
node
-
>
getAsAggregate
(
)
;
if
(
aggNode
=
=
NULL
|
|
aggNode
-
>
getOp
(
)
!
=
EOpNull
)
{
aggNode
=
new
TIntermAggregate
(
)
;
aggNode
-
>
getSequence
(
)
-
>
push_back
(
node
)
;
}
}
else
{
aggNode
=
new
TIntermAggregate
(
)
;
}
aggNode
-
>
setOp
(
op
)
;
aggNode
-
>
setLine
(
line
)
;
return
aggNode
;
}
TIntermAggregate
*
TIntermediate
:
:
growAggregate
(
TIntermNode
*
left
TIntermNode
*
right
const
TSourceLoc
&
line
)
{
if
(
left
=
=
NULL
&
&
right
=
=
NULL
)
return
NULL
;
TIntermAggregate
*
aggNode
=
NULL
;
if
(
left
)
aggNode
=
left
-
>
getAsAggregate
(
)
;
if
(
!
aggNode
|
|
aggNode
-
>
getOp
(
)
!
=
EOpNull
)
{
aggNode
=
new
TIntermAggregate
;
if
(
left
)
aggNode
-
>
getSequence
(
)
-
>
push_back
(
left
)
;
}
if
(
right
)
aggNode
-
>
getSequence
(
)
-
>
push_back
(
right
)
;
aggNode
-
>
setLine
(
line
)
;
return
aggNode
;
}
TIntermAggregate
*
TIntermediate
:
:
makeAggregate
(
TIntermNode
*
node
const
TSourceLoc
&
line
)
{
if
(
node
=
=
NULL
)
return
NULL
;
TIntermAggregate
*
aggNode
=
new
TIntermAggregate
;
aggNode
-
>
getSequence
(
)
-
>
push_back
(
node
)
;
aggNode
-
>
setLine
(
line
)
;
return
aggNode
;
}
TIntermAggregate
*
TIntermediate
:
:
ensureSequence
(
TIntermNode
*
node
)
{
if
(
node
=
=
nullptr
)
return
nullptr
;
TIntermAggregate
*
aggNode
=
node
-
>
getAsAggregate
(
)
;
if
(
aggNode
!
=
nullptr
&
&
aggNode
-
>
getOp
(
)
=
=
EOpSequence
)
return
aggNode
;
aggNode
=
makeAggregate
(
node
node
-
>
getLine
(
)
)
;
aggNode
-
>
setOp
(
EOpSequence
)
;
return
aggNode
;
}
TIntermNode
*
TIntermediate
:
:
addSelection
(
TIntermTyped
*
cond
TIntermNodePair
nodePair
const
TSourceLoc
&
line
)
{
if
(
cond
-
>
getAsConstantUnion
(
)
)
{
if
(
cond
-
>
getAsConstantUnion
(
)
-
>
getBConst
(
0
)
=
=
true
)
{
return
nodePair
.
node1
?
setAggregateOperator
(
nodePair
.
node1
EOpSequence
nodePair
.
node1
-
>
getLine
(
)
)
:
NULL
;
}
else
{
return
nodePair
.
node2
?
setAggregateOperator
(
nodePair
.
node2
EOpSequence
nodePair
.
node2
-
>
getLine
(
)
)
:
NULL
;
}
}
TIntermSelection
*
node
=
new
TIntermSelection
(
cond
ensureSequence
(
nodePair
.
node1
)
ensureSequence
(
nodePair
.
node2
)
)
;
node
-
>
setLine
(
line
)
;
return
node
;
}
TIntermTyped
*
TIntermediate
:
:
addComma
(
TIntermTyped
*
left
TIntermTyped
*
right
const
TSourceLoc
&
line
int
shaderVersion
)
{
TQualifier
resultQualifier
=
EvqConst
;
if
(
shaderVersion
>
=
300
|
|
left
-
>
getQualifier
(
)
!
=
EvqConst
|
|
right
-
>
getQualifier
(
)
!
=
EvqConst
)
{
resultQualifier
=
EvqTemporary
;
}
TIntermTyped
*
commaNode
=
nullptr
;
if
(
!
left
-
>
hasSideEffects
(
)
)
{
commaNode
=
right
;
}
else
{
commaNode
=
growAggregate
(
left
right
line
)
;
commaNode
-
>
getAsAggregate
(
)
-
>
setOp
(
EOpComma
)
;
commaNode
-
>
setType
(
right
-
>
getType
(
)
)
;
}
commaNode
-
>
getTypePointer
(
)
-
>
setQualifier
(
resultQualifier
)
;
return
commaNode
;
}
TIntermTyped
*
TIntermediate
:
:
addSelection
(
TIntermTyped
*
cond
TIntermTyped
*
trueBlock
TIntermTyped
*
falseBlock
const
TSourceLoc
&
line
)
{
TQualifier
resultQualifier
=
EvqTemporary
;
if
(
cond
-
>
getQualifier
(
)
=
=
EvqConst
&
&
trueBlock
-
>
getQualifier
(
)
=
=
EvqConst
&
&
falseBlock
-
>
getQualifier
(
)
=
=
EvqConst
)
{
resultQualifier
=
EvqConst
;
}
if
(
cond
-
>
getAsConstantUnion
(
)
)
{
if
(
cond
-
>
getAsConstantUnion
(
)
-
>
getBConst
(
0
)
)
{
trueBlock
-
>
getTypePointer
(
)
-
>
setQualifier
(
resultQualifier
)
;
return
trueBlock
;
}
else
{
falseBlock
-
>
getTypePointer
(
)
-
>
setQualifier
(
resultQualifier
)
;
return
falseBlock
;
}
}
TIntermSelection
*
node
=
new
TIntermSelection
(
cond
trueBlock
falseBlock
trueBlock
-
>
getType
(
)
)
;
node
-
>
getTypePointer
(
)
-
>
setQualifier
(
resultQualifier
)
;
node
-
>
setLine
(
line
)
;
return
node
;
}
TIntermSwitch
*
TIntermediate
:
:
addSwitch
(
TIntermTyped
*
init
TIntermAggregate
*
statementList
const
TSourceLoc
&
line
)
{
TIntermSwitch
*
node
=
new
TIntermSwitch
(
init
statementList
)
;
node
-
>
setLine
(
line
)
;
return
node
;
}
TIntermCase
*
TIntermediate
:
:
addCase
(
TIntermTyped
*
condition
const
TSourceLoc
&
line
)
{
TIntermCase
*
node
=
new
TIntermCase
(
condition
)
;
node
-
>
setLine
(
line
)
;
return
node
;
}
TIntermConstantUnion
*
TIntermediate
:
:
addConstantUnion
(
const
TConstantUnion
*
constantUnion
const
TType
&
type
const
TSourceLoc
&
line
)
{
TIntermConstantUnion
*
node
=
new
TIntermConstantUnion
(
constantUnion
type
)
;
node
-
>
setLine
(
line
)
;
return
node
;
}
TIntermTyped
*
TIntermediate
:
:
addSwizzle
(
TVectorFields
&
fields
const
TSourceLoc
&
line
)
{
TIntermAggregate
*
node
=
new
TIntermAggregate
(
EOpSequence
)
;
node
-
>
setLine
(
line
)
;
TIntermConstantUnion
*
constIntNode
;
TIntermSequence
*
sequenceVector
=
node
-
>
getSequence
(
)
;
TConstantUnion
*
unionArray
;
for
(
int
i
=
0
;
i
<
fields
.
num
;
i
+
+
)
{
unionArray
=
new
TConstantUnion
[
1
]
;
unionArray
-
>
setIConst
(
fields
.
offsets
[
i
]
)
;
constIntNode
=
addConstantUnion
(
unionArray
TType
(
EbtInt
EbpUndefined
EvqConst
)
line
)
;
sequenceVector
-
>
push_back
(
constIntNode
)
;
}
return
node
;
}
TIntermNode
*
TIntermediate
:
:
addLoop
(
TLoopType
type
TIntermNode
*
init
TIntermTyped
*
cond
TIntermTyped
*
expr
TIntermNode
*
body
const
TSourceLoc
&
line
)
{
TIntermNode
*
node
=
new
TIntermLoop
(
type
init
cond
expr
ensureSequence
(
body
)
)
;
node
-
>
setLine
(
line
)
;
return
node
;
}
TIntermBranch
*
TIntermediate
:
:
addBranch
(
TOperator
branchOp
const
TSourceLoc
&
line
)
{
return
addBranch
(
branchOp
0
line
)
;
}
TIntermBranch
*
TIntermediate
:
:
addBranch
(
TOperator
branchOp
TIntermTyped
*
expression
const
TSourceLoc
&
line
)
{
TIntermBranch
*
node
=
new
TIntermBranch
(
branchOp
expression
)
;
node
-
>
setLine
(
line
)
;
return
node
;
}
TIntermAggregate
*
TIntermediate
:
:
postProcess
(
TIntermNode
*
root
)
{
if
(
root
=
=
nullptr
)
return
nullptr
;
TIntermAggregate
*
aggRoot
=
root
-
>
getAsAggregate
(
)
;
if
(
aggRoot
!
=
nullptr
&
&
aggRoot
-
>
getOp
(
)
=
=
EOpNull
)
{
aggRoot
-
>
setOp
(
EOpSequence
)
;
}
else
if
(
aggRoot
=
=
nullptr
|
|
aggRoot
-
>
getOp
(
)
!
=
EOpSequence
)
{
aggRoot
=
new
TIntermAggregate
(
EOpSequence
)
;
aggRoot
-
>
setLine
(
root
-
>
getLine
(
)
)
;
aggRoot
-
>
getSequence
(
)
-
>
push_back
(
root
)
;
}
return
aggRoot
;
}
TIntermTyped
*
TIntermediate
:
:
foldAggregateBuiltIn
(
TIntermAggregate
*
aggregate
)
{
switch
(
aggregate
-
>
getOp
(
)
)
{
case
EOpAtan
:
case
EOpPow
:
case
EOpMod
:
case
EOpMin
:
case
EOpMax
:
case
EOpClamp
:
case
EOpMix
:
case
EOpStep
:
case
EOpSmoothStep
:
case
EOpMul
:
case
EOpOuterProduct
:
case
EOpLessThan
:
case
EOpLessThanEqual
:
case
EOpGreaterThan
:
case
EOpGreaterThanEqual
:
case
EOpVectorEqual
:
case
EOpVectorNotEqual
:
case
EOpDistance
:
case
EOpDot
:
case
EOpCross
:
case
EOpFaceForward
:
case
EOpReflect
:
case
EOpRefract
:
return
aggregate
-
>
fold
(
mInfoSink
)
;
default
:
if
(
aggregate
-
>
isConstructor
(
)
&
&
!
aggregate
-
>
isArray
(
)
)
{
return
aggregate
-
>
fold
(
mInfoSink
)
;
}
return
nullptr
;
}
return
nullptr
;
}
