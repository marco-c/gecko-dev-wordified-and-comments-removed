#
include
<
float
.
h
>
#
include
<
limits
.
h
>
#
include
<
algorithm
>
#
include
"
compiler
/
translator
/
Intermediate
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
namespace
sh
{
TIntermSymbol
*
TIntermediate
:
:
addSymbol
(
int
id
const
TString
&
name
const
TType
&
type
const
TSourceLoc
&
line
)
{
TIntermSymbol
*
node
=
new
TIntermSymbol
(
id
name
type
)
;
node
-
>
setLine
(
line
)
;
return
node
;
}
TIntermTyped
*
TIntermediate
:
:
addIndex
(
TOperator
op
TIntermTyped
*
base
TIntermTyped
*
index
const
TSourceLoc
&
line
TDiagnostics
*
diagnostics
)
{
TIntermBinary
*
node
=
new
TIntermBinary
(
op
base
index
)
;
node
-
>
setLine
(
line
)
;
TIntermTyped
*
folded
=
node
-
>
fold
(
diagnostics
)
;
if
(
folded
)
{
return
folded
;
}
return
node
;
}
TIntermAggregate
*
TIntermediate
:
:
setAggregateOperator
(
TIntermNode
*
node
TOperator
op
const
TSourceLoc
&
line
)
{
TIntermAggregate
*
aggNode
;
if
(
node
)
{
aggNode
=
node
-
>
getAsAggregate
(
)
;
if
(
aggNode
=
=
NULL
|
|
aggNode
-
>
getOp
(
)
!
=
EOpNull
)
{
aggNode
=
new
TIntermAggregate
(
)
;
aggNode
-
>
getSequence
(
)
-
>
push_back
(
node
)
;
}
}
else
{
aggNode
=
new
TIntermAggregate
(
)
;
}
aggNode
-
>
setOp
(
op
)
;
aggNode
-
>
setLine
(
line
)
;
return
aggNode
;
}
TIntermAggregate
*
TIntermediate
:
:
growAggregate
(
TIntermNode
*
left
TIntermNode
*
right
const
TSourceLoc
&
line
)
{
if
(
left
=
=
NULL
&
&
right
=
=
NULL
)
return
NULL
;
TIntermAggregate
*
aggNode
=
NULL
;
if
(
left
)
aggNode
=
left
-
>
getAsAggregate
(
)
;
if
(
!
aggNode
|
|
aggNode
-
>
getOp
(
)
!
=
EOpNull
)
{
aggNode
=
new
TIntermAggregate
;
if
(
left
)
aggNode
-
>
getSequence
(
)
-
>
push_back
(
left
)
;
}
if
(
right
)
aggNode
-
>
getSequence
(
)
-
>
push_back
(
right
)
;
aggNode
-
>
setLine
(
line
)
;
return
aggNode
;
}
TIntermAggregate
*
TIntermediate
:
:
MakeAggregate
(
TIntermNode
*
node
const
TSourceLoc
&
line
)
{
if
(
node
=
=
nullptr
)
return
nullptr
;
TIntermAggregate
*
aggNode
=
new
TIntermAggregate
;
aggNode
-
>
getSequence
(
)
-
>
push_back
(
node
)
;
aggNode
-
>
setLine
(
line
)
;
return
aggNode
;
}
TIntermBlock
*
TIntermediate
:
:
EnsureBlock
(
TIntermNode
*
node
)
{
if
(
node
=
=
nullptr
)
return
nullptr
;
TIntermBlock
*
blockNode
=
node
-
>
getAsBlock
(
)
;
if
(
blockNode
!
=
nullptr
)
return
blockNode
;
blockNode
=
new
TIntermBlock
(
)
;
blockNode
-
>
setLine
(
node
-
>
getLine
(
)
)
;
blockNode
-
>
getSequence
(
)
-
>
push_back
(
node
)
;
return
blockNode
;
}
TIntermNode
*
TIntermediate
:
:
addIfElse
(
TIntermTyped
*
cond
TIntermNodePair
nodePair
const
TSourceLoc
&
line
)
{
if
(
cond
-
>
getAsConstantUnion
(
)
)
{
if
(
cond
-
>
getAsConstantUnion
(
)
-
>
getBConst
(
0
)
=
=
true
)
{
return
EnsureBlock
(
nodePair
.
node1
)
;
}
else
{
return
EnsureBlock
(
nodePair
.
node2
)
;
}
}
TIntermIfElse
*
node
=
new
TIntermIfElse
(
cond
EnsureBlock
(
nodePair
.
node1
)
EnsureBlock
(
nodePair
.
node2
)
)
;
node
-
>
setLine
(
line
)
;
return
node
;
}
TIntermTyped
*
TIntermediate
:
:
AddComma
(
TIntermTyped
*
left
TIntermTyped
*
right
const
TSourceLoc
&
line
int
shaderVersion
)
{
TIntermTyped
*
commaNode
=
nullptr
;
if
(
!
left
-
>
hasSideEffects
(
)
)
{
commaNode
=
right
;
}
else
{
commaNode
=
new
TIntermBinary
(
EOpComma
left
right
)
;
commaNode
-
>
setLine
(
line
)
;
}
TQualifier
resultQualifier
=
TIntermBinary
:
:
GetCommaQualifier
(
shaderVersion
left
right
)
;
commaNode
-
>
getTypePointer
(
)
-
>
setQualifier
(
resultQualifier
)
;
return
commaNode
;
}
TIntermTyped
*
TIntermediate
:
:
AddTernarySelection
(
TIntermTyped
*
cond
TIntermTyped
*
trueExpression
TIntermTyped
*
falseExpression
const
TSourceLoc
&
line
)
{
if
(
cond
-
>
getAsConstantUnion
(
)
)
{
TQualifier
resultQualifier
=
TIntermTernary
:
:
DetermineQualifier
(
cond
trueExpression
falseExpression
)
;
if
(
cond
-
>
getAsConstantUnion
(
)
-
>
getBConst
(
0
)
)
{
trueExpression
-
>
getTypePointer
(
)
-
>
setQualifier
(
resultQualifier
)
;
return
trueExpression
;
}
else
{
falseExpression
-
>
getTypePointer
(
)
-
>
setQualifier
(
resultQualifier
)
;
return
falseExpression
;
}
}
TIntermTernary
*
node
=
new
TIntermTernary
(
cond
trueExpression
falseExpression
)
;
node
-
>
setLine
(
line
)
;
return
node
;
}
TIntermSwitch
*
TIntermediate
:
:
addSwitch
(
TIntermTyped
*
init
TIntermBlock
*
statementList
const
TSourceLoc
&
line
)
{
TIntermSwitch
*
node
=
new
TIntermSwitch
(
init
statementList
)
;
node
-
>
setLine
(
line
)
;
return
node
;
}
TIntermCase
*
TIntermediate
:
:
addCase
(
TIntermTyped
*
condition
const
TSourceLoc
&
line
)
{
TIntermCase
*
node
=
new
TIntermCase
(
condition
)
;
node
-
>
setLine
(
line
)
;
return
node
;
}
TIntermConstantUnion
*
TIntermediate
:
:
addConstantUnion
(
const
TConstantUnion
*
constantUnion
const
TType
&
type
const
TSourceLoc
&
line
)
{
TIntermConstantUnion
*
node
=
new
TIntermConstantUnion
(
constantUnion
type
)
;
node
-
>
setLine
(
line
)
;
return
node
;
}
TIntermTyped
*
TIntermediate
:
:
AddSwizzle
(
TIntermTyped
*
baseExpression
const
TVectorFields
&
fields
const
TSourceLoc
&
dotLocation
)
{
TVector
<
int
>
fieldsVector
;
for
(
int
i
=
0
;
i
<
fields
.
num
;
+
+
i
)
{
fieldsVector
.
push_back
(
fields
.
offsets
[
i
]
)
;
}
TIntermSwizzle
*
node
=
new
TIntermSwizzle
(
baseExpression
fieldsVector
)
;
node
-
>
setLine
(
dotLocation
)
;
TIntermTyped
*
folded
=
node
-
>
fold
(
)
;
if
(
folded
)
{
return
folded
;
}
return
node
;
}
TIntermNode
*
TIntermediate
:
:
addLoop
(
TLoopType
type
TIntermNode
*
init
TIntermTyped
*
cond
TIntermTyped
*
expr
TIntermNode
*
body
const
TSourceLoc
&
line
)
{
TIntermNode
*
node
=
new
TIntermLoop
(
type
init
cond
expr
EnsureBlock
(
body
)
)
;
node
-
>
setLine
(
line
)
;
return
node
;
}
TIntermBranch
*
TIntermediate
:
:
addBranch
(
TOperator
branchOp
const
TSourceLoc
&
line
)
{
return
addBranch
(
branchOp
0
line
)
;
}
TIntermBranch
*
TIntermediate
:
:
addBranch
(
TOperator
branchOp
TIntermTyped
*
expression
const
TSourceLoc
&
line
)
{
TIntermBranch
*
node
=
new
TIntermBranch
(
branchOp
expression
)
;
node
-
>
setLine
(
line
)
;
return
node
;
}
TIntermTyped
*
TIntermediate
:
:
foldAggregateBuiltIn
(
TIntermAggregate
*
aggregate
TDiagnostics
*
diagnostics
)
{
switch
(
aggregate
-
>
getOp
(
)
)
{
case
EOpAtan
:
case
EOpPow
:
case
EOpMod
:
case
EOpMin
:
case
EOpMax
:
case
EOpClamp
:
case
EOpMix
:
case
EOpStep
:
case
EOpSmoothStep
:
case
EOpMul
:
case
EOpOuterProduct
:
case
EOpLessThan
:
case
EOpLessThanEqual
:
case
EOpGreaterThan
:
case
EOpGreaterThanEqual
:
case
EOpVectorEqual
:
case
EOpVectorNotEqual
:
case
EOpDistance
:
case
EOpDot
:
case
EOpCross
:
case
EOpFaceForward
:
case
EOpReflect
:
case
EOpRefract
:
return
aggregate
-
>
fold
(
diagnostics
)
;
default
:
if
(
aggregate
-
>
isConstructor
(
)
&
&
!
aggregate
-
>
isArray
(
)
)
{
return
aggregate
-
>
fold
(
diagnostics
)
;
}
return
nullptr
;
}
}
}
