#
include
"
compiler
/
translator
/
RewriteTexelFetchOffset
.
h
"
#
include
"
common
/
angleutils
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
namespace
sh
{
namespace
{
class
Traverser
:
public
TIntermTraverser
{
public
:
static
void
Apply
(
TIntermNode
*
root
const
TSymbolTable
&
symbolTable
int
shaderVersion
)
;
private
:
Traverser
(
const
TSymbolTable
&
symbolTable
int
shaderVersion
)
;
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
;
void
nextIteration
(
)
;
const
TSymbolTable
*
symbolTable
;
const
int
shaderVersion
;
bool
mFound
=
false
;
}
;
Traverser
:
:
Traverser
(
const
TSymbolTable
&
symbolTable
int
shaderVersion
)
:
TIntermTraverser
(
true
false
false
)
symbolTable
(
&
symbolTable
)
shaderVersion
(
shaderVersion
)
{
}
void
Traverser
:
:
Apply
(
TIntermNode
*
root
const
TSymbolTable
&
symbolTable
int
shaderVersion
)
{
Traverser
traverser
(
symbolTable
shaderVersion
)
;
do
{
traverser
.
nextIteration
(
)
;
root
-
>
traverse
(
&
traverser
)
;
if
(
traverser
.
mFound
)
{
traverser
.
updateTree
(
)
;
}
}
while
(
traverser
.
mFound
)
;
}
void
Traverser
:
:
nextIteration
(
)
{
mFound
=
false
;
}
bool
Traverser
:
:
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
{
if
(
mFound
)
{
return
false
;
}
if
(
node
-
>
getOp
(
)
!
=
EOpFunctionCall
|
|
node
-
>
isUserDefined
(
)
)
{
return
true
;
}
if
(
node
-
>
getFunctionSymbolInfo
(
)
-
>
getName
(
)
.
compare
(
0
16
"
texelFetchOffset
"
)
!
=
0
)
{
return
true
;
}
const
TIntermSequence
*
sequence
=
node
-
>
getSequence
(
)
;
ASSERT
(
sequence
-
>
size
(
)
=
=
4u
)
;
bool
is2DArray
=
node
-
>
getFunctionSymbolInfo
(
)
-
>
getName
(
)
.
find
(
"
s2a1
"
)
!
=
TString
:
:
npos
;
TString
newArgs
=
node
-
>
getFunctionSymbolInfo
(
)
-
>
getName
(
)
.
substr
(
16
node
-
>
getFunctionSymbolInfo
(
)
-
>
getName
(
)
.
length
(
)
-
20
)
;
TString
newName
=
"
texelFetch
"
+
newArgs
;
TSymbol
*
texelFetchSymbol
=
symbolTable
-
>
findBuiltIn
(
newName
shaderVersion
)
;
ASSERT
(
texelFetchSymbol
)
;
int
uniqueId
=
texelFetchSymbol
-
>
getUniqueId
(
)
;
TIntermAggregate
*
texelFetchNode
=
new
TIntermAggregate
(
EOpFunctionCall
)
;
texelFetchNode
-
>
getFunctionSymbolInfo
(
)
-
>
setName
(
newName
)
;
texelFetchNode
-
>
getFunctionSymbolInfo
(
)
-
>
setId
(
uniqueId
)
;
texelFetchNode
-
>
setType
(
node
-
>
getType
(
)
)
;
texelFetchNode
-
>
setLine
(
node
-
>
getLine
(
)
)
;
texelFetchNode
-
>
getSequence
(
)
-
>
push_back
(
sequence
-
>
at
(
0
)
)
;
TIntermTyped
*
texCoordNode
=
sequence
-
>
at
(
1
)
-
>
getAsTyped
(
)
;
ASSERT
(
texCoordNode
)
;
TIntermTyped
*
offsetNode
=
nullptr
;
ASSERT
(
sequence
-
>
at
(
3
)
-
>
getAsTyped
(
)
)
;
if
(
is2DArray
)
{
TIntermAggregate
*
constructIVec3Node
=
new
TIntermAggregate
(
EOpConstructIVec3
)
;
constructIVec3Node
-
>
setLine
(
texCoordNode
-
>
getLine
(
)
)
;
constructIVec3Node
-
>
setType
(
texCoordNode
-
>
getType
(
)
)
;
constructIVec3Node
-
>
getSequence
(
)
-
>
push_back
(
sequence
-
>
at
(
3
)
-
>
getAsTyped
(
)
)
;
TConstantUnion
*
zero
=
new
TConstantUnion
(
)
;
zero
-
>
setIConst
(
0
)
;
TType
*
intType
=
new
TType
(
EbtInt
)
;
TIntermConstantUnion
*
zeroNode
=
new
TIntermConstantUnion
(
zero
*
intType
)
;
constructIVec3Node
-
>
getSequence
(
)
-
>
push_back
(
zeroNode
)
;
offsetNode
=
constructIVec3Node
;
}
else
{
offsetNode
=
sequence
-
>
at
(
3
)
-
>
getAsTyped
(
)
;
}
TIntermBinary
*
add
=
new
TIntermBinary
(
EOpAdd
texCoordNode
offsetNode
)
;
add
-
>
setLine
(
texCoordNode
-
>
getLine
(
)
)
;
texelFetchNode
-
>
getSequence
(
)
-
>
push_back
(
add
)
;
texelFetchNode
-
>
getSequence
(
)
-
>
push_back
(
sequence
-
>
at
(
2
)
)
;
ASSERT
(
texelFetchNode
-
>
getSequence
(
)
-
>
size
(
)
=
=
3u
)
;
queueReplacement
(
node
texelFetchNode
OriginalNode
:
:
IS_DROPPED
)
;
mFound
=
true
;
return
false
;
}
}
void
RewriteTexelFetchOffset
(
TIntermNode
*
root
const
TSymbolTable
&
symbolTable
int
shaderVersion
)
{
if
(
shaderVersion
<
300
)
return
;
Traverser
:
:
Apply
(
root
symbolTable
shaderVersion
)
;
}
}
