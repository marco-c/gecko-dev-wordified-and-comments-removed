#
include
"
compiler
/
translator
/
ArrayReturnValueToOutParameter
.
h
"
#
include
<
map
>
#
include
"
compiler
/
translator
/
IntermTraverse
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
namespace
sh
{
namespace
{
void
CopyAggregateChildren
(
TIntermAggregateBase
*
from
TIntermAggregateBase
*
to
)
{
const
TIntermSequence
*
fromSequence
=
from
-
>
getSequence
(
)
;
for
(
size_t
ii
=
0
;
ii
<
fromSequence
-
>
size
(
)
;
+
+
ii
)
{
to
-
>
getSequence
(
)
-
>
push_back
(
fromSequence
-
>
at
(
ii
)
)
;
}
}
TIntermSymbol
*
CreateReturnValueSymbol
(
const
TSymbolUniqueId
&
id
const
TType
&
type
)
{
TIntermSymbol
*
node
=
new
TIntermSymbol
(
id
.
get
(
)
"
angle_return
"
type
)
;
node
-
>
setInternal
(
true
)
;
node
-
>
getTypePointer
(
)
-
>
setQualifier
(
EvqOut
)
;
return
node
;
}
TIntermAggregate
*
CreateReplacementCall
(
TIntermAggregate
*
originalCall
TIntermTyped
*
returnValueTarget
)
{
TIntermSequence
*
replacementArguments
=
new
TIntermSequence
(
)
;
TIntermSequence
*
originalArguments
=
originalCall
-
>
getSequence
(
)
;
for
(
auto
&
arg
:
*
originalArguments
)
{
replacementArguments
-
>
push_back
(
arg
)
;
}
replacementArguments
-
>
push_back
(
returnValueTarget
)
;
TIntermAggregate
*
replacementCall
=
TIntermAggregate
:
:
CreateFunctionCall
(
TType
(
EbtVoid
)
originalCall
-
>
getFunctionSymbolInfo
(
)
-
>
getId
(
)
originalCall
-
>
getFunctionSymbolInfo
(
)
-
>
getNameObj
(
)
replacementArguments
)
;
replacementCall
-
>
setLine
(
originalCall
-
>
getLine
(
)
)
;
return
replacementCall
;
}
class
ArrayReturnValueToOutParameterTraverser
:
private
TIntermTraverser
{
public
:
static
void
apply
(
TIntermNode
*
root
TSymbolTable
*
symbolTable
)
;
private
:
ArrayReturnValueToOutParameterTraverser
(
TSymbolTable
*
symbolTable
)
;
bool
visitFunctionPrototype
(
Visit
visit
TIntermFunctionPrototype
*
node
)
override
;
bool
visitFunctionDefinition
(
Visit
visit
TIntermFunctionDefinition
*
node
)
override
;
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
;
bool
visitBranch
(
Visit
visit
TIntermBranch
*
node
)
override
;
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
;
TIntermFunctionDefinition
*
mFunctionWithArrayReturnValue
;
std
:
:
map
<
int
TSymbolUniqueId
*
>
mReturnValueIds
;
}
;
void
ArrayReturnValueToOutParameterTraverser
:
:
apply
(
TIntermNode
*
root
TSymbolTable
*
symbolTable
)
{
ArrayReturnValueToOutParameterTraverser
arrayReturnValueToOutParam
(
symbolTable
)
;
root
-
>
traverse
(
&
arrayReturnValueToOutParam
)
;
arrayReturnValueToOutParam
.
updateTree
(
)
;
}
ArrayReturnValueToOutParameterTraverser
:
:
ArrayReturnValueToOutParameterTraverser
(
TSymbolTable
*
symbolTable
)
:
TIntermTraverser
(
true
false
true
symbolTable
)
mFunctionWithArrayReturnValue
(
nullptr
)
{
}
bool
ArrayReturnValueToOutParameterTraverser
:
:
visitFunctionDefinition
(
Visit
visit
TIntermFunctionDefinition
*
node
)
{
if
(
node
-
>
getFunctionPrototype
(
)
-
>
isArray
(
)
&
&
visit
=
=
PreVisit
)
{
mFunctionWithArrayReturnValue
=
node
;
}
if
(
visit
=
=
PostVisit
)
{
mFunctionWithArrayReturnValue
=
nullptr
;
}
return
true
;
}
bool
ArrayReturnValueToOutParameterTraverser
:
:
visitFunctionPrototype
(
Visit
visit
TIntermFunctionPrototype
*
node
)
{
if
(
visit
=
=
PreVisit
&
&
node
-
>
isArray
(
)
)
{
TIntermFunctionPrototype
*
replacement
=
new
TIntermFunctionPrototype
(
TType
(
EbtVoid
)
node
-
>
getFunctionSymbolInfo
(
)
-
>
getId
(
)
)
;
CopyAggregateChildren
(
node
replacement
)
;
const
TSymbolUniqueId
&
functionId
=
node
-
>
getFunctionSymbolInfo
(
)
-
>
getId
(
)
;
if
(
mReturnValueIds
.
find
(
functionId
.
get
(
)
)
=
=
mReturnValueIds
.
end
(
)
)
{
mReturnValueIds
[
functionId
.
get
(
)
]
=
new
TSymbolUniqueId
(
mSymbolTable
)
;
}
replacement
-
>
getSequence
(
)
-
>
push_back
(
CreateReturnValueSymbol
(
*
mReturnValueIds
[
functionId
.
get
(
)
]
node
-
>
getType
(
)
)
)
;
*
replacement
-
>
getFunctionSymbolInfo
(
)
=
*
node
-
>
getFunctionSymbolInfo
(
)
;
replacement
-
>
setLine
(
node
-
>
getLine
(
)
)
;
queueReplacement
(
replacement
OriginalNode
:
:
IS_DROPPED
)
;
}
return
false
;
}
bool
ArrayReturnValueToOutParameterTraverser
:
:
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
{
ASSERT
(
!
node
-
>
isArray
(
)
|
|
node
-
>
getOp
(
)
!
=
EOpCallInternalRawFunction
)
;
if
(
visit
=
=
PreVisit
&
&
node
-
>
isArray
(
)
&
&
node
-
>
getOp
(
)
=
=
EOpCallFunctionInAST
)
{
TIntermBlock
*
parentBlock
=
getParentNode
(
)
-
>
getAsBlock
(
)
;
if
(
parentBlock
)
{
nextTemporaryId
(
)
;
TIntermSequence
replacements
;
replacements
.
push_back
(
createTempDeclaration
(
node
-
>
getType
(
)
)
)
;
TIntermSymbol
*
returnSymbol
=
createTempSymbol
(
node
-
>
getType
(
)
)
;
replacements
.
push_back
(
CreateReplacementCall
(
node
returnSymbol
)
)
;
mMultiReplacements
.
push_back
(
NodeReplaceWithMultipleEntry
(
parentBlock
node
replacements
)
)
;
}
return
false
;
}
return
true
;
}
bool
ArrayReturnValueToOutParameterTraverser
:
:
visitBranch
(
Visit
visit
TIntermBranch
*
node
)
{
if
(
mFunctionWithArrayReturnValue
&
&
node
-
>
getFlowOp
(
)
=
=
EOpReturn
)
{
TIntermSequence
replacements
;
TIntermTyped
*
expression
=
node
-
>
getExpression
(
)
;
ASSERT
(
expression
!
=
nullptr
)
;
const
TSymbolUniqueId
&
functionId
=
mFunctionWithArrayReturnValue
-
>
getFunctionSymbolInfo
(
)
-
>
getId
(
)
;
ASSERT
(
mReturnValueIds
.
find
(
functionId
.
get
(
)
)
!
=
mReturnValueIds
.
end
(
)
)
;
const
TSymbolUniqueId
&
returnValueId
=
*
mReturnValueIds
[
functionId
.
get
(
)
]
;
TIntermSymbol
*
returnValueSymbol
=
CreateReturnValueSymbol
(
returnValueId
expression
-
>
getType
(
)
)
;
TIntermBinary
*
replacementAssignment
=
new
TIntermBinary
(
EOpAssign
returnValueSymbol
expression
)
;
replacementAssignment
-
>
setLine
(
expression
-
>
getLine
(
)
)
;
replacements
.
push_back
(
replacementAssignment
)
;
TIntermBranch
*
replacementBranch
=
new
TIntermBranch
(
EOpReturn
nullptr
)
;
replacementBranch
-
>
setLine
(
node
-
>
getLine
(
)
)
;
replacements
.
push_back
(
replacementBranch
)
;
mMultiReplacements
.
push_back
(
NodeReplaceWithMultipleEntry
(
getParentNode
(
)
-
>
getAsBlock
(
)
node
replacements
)
)
;
}
return
false
;
}
bool
ArrayReturnValueToOutParameterTraverser
:
:
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
{
if
(
node
-
>
getOp
(
)
=
=
EOpAssign
&
&
node
-
>
getLeft
(
)
-
>
isArray
(
)
)
{
TIntermAggregate
*
rightAgg
=
node
-
>
getRight
(
)
-
>
getAsAggregate
(
)
;
ASSERT
(
rightAgg
=
=
nullptr
|
|
rightAgg
-
>
getOp
(
)
!
=
EOpCallInternalRawFunction
)
;
if
(
rightAgg
!
=
nullptr
&
&
rightAgg
-
>
getOp
(
)
=
=
EOpCallFunctionInAST
)
{
TIntermAggregate
*
replacementCall
=
CreateReplacementCall
(
rightAgg
node
-
>
getLeft
(
)
)
;
queueReplacement
(
replacementCall
OriginalNode
:
:
IS_DROPPED
)
;
}
}
return
false
;
}
}
void
ArrayReturnValueToOutParameter
(
TIntermNode
*
root
TSymbolTable
*
symbolTable
)
{
ArrayReturnValueToOutParameterTraverser
:
:
apply
(
root
symbolTable
)
;
}
}
