#
include
"
compiler
/
translator
/
TranslatorVulkan
.
h
"
#
include
"
angle_gl
.
h
"
#
include
"
compiler
/
translator
/
OutputVulkanGLSL
.
h
"
namespace
sh
{
TranslatorVulkan
:
:
TranslatorVulkan
(
sh
:
:
GLenum
type
ShShaderSpec
spec
)
:
TCompiler
(
type
spec
SH_GLSL_450_CORE_OUTPUT
)
{
}
void
TranslatorVulkan
:
:
translate
(
TIntermBlock
*
root
ShCompileOptions
compileOptions
)
{
TInfoSinkBase
&
sink
=
getInfoSink
(
)
.
obj
;
sink
<
<
"
#
version
450
core
\
n
"
;
if
(
getShaderType
(
)
=
=
GL_FRAGMENT_SHADER
)
{
bool
hasGLFragColor
=
false
;
bool
hasGLFragData
=
false
;
for
(
const
auto
&
outputVar
:
outputVariables
)
{
if
(
outputVar
.
name
=
=
"
gl_FragColor
"
)
{
ASSERT
(
!
hasGLFragColor
)
;
hasGLFragColor
=
true
;
continue
;
}
else
if
(
outputVar
.
name
=
=
"
gl_FragData
"
)
{
ASSERT
(
!
hasGLFragData
)
;
hasGLFragData
=
true
;
continue
;
}
}
ASSERT
(
!
(
hasGLFragColor
&
&
hasGLFragData
)
)
;
if
(
hasGLFragColor
)
{
sink
<
<
"
layout
(
location
=
0
)
out
vec4
webgl_FragColor
;
\
n
"
;
}
if
(
hasGLFragData
)
{
sink
<
<
"
layout
(
location
=
0
)
out
vec4
webgl_FragData
[
gl_MaxDrawBuffers
]
;
\
n
"
;
}
}
TOutputVulkanGLSL
outputGLSL
(
sink
getArrayIndexClampingStrategy
(
)
getHashFunction
(
)
getNameMap
(
)
&
getSymbolTable
(
)
getShaderType
(
)
getShaderVersion
(
)
getOutputType
(
)
compileOptions
)
;
root
-
>
traverse
(
&
outputGLSL
)
;
}
bool
TranslatorVulkan
:
:
shouldFlattenPragmaStdglInvariantAll
(
)
{
return
false
;
}
}
