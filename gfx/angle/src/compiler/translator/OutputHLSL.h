#
ifndef
COMPILER_TRANSLATOR_OUTPUTHLSL_H_
#
define
COMPILER_TRANSLATOR_OUTPUTHLSL_H_
#
include
<
list
>
#
include
<
map
>
#
include
<
stack
>
#
include
"
angle_gl
.
h
"
#
include
"
compiler
/
translator
/
ASTMetadataHLSL
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
#
include
"
compiler
/
translator
/
ParseContext
.
h
"
class
BuiltInFunctionEmulator
;
namespace
sh
{
class
StructureHLSL
;
class
TextureFunctionHLSL
;
class
UnfoldShortCircuit
;
class
UniformHLSL
;
typedef
std
:
:
map
<
TString
TIntermSymbol
*
>
ReferencedSymbols
;
class
OutputHLSL
:
public
TIntermTraverser
{
public
:
OutputHLSL
(
sh
:
:
GLenum
shaderType
int
shaderVersion
const
TExtensionBehavior
&
extensionBehavior
const
char
*
sourcePath
ShShaderOutput
outputType
int
numRenderTargets
const
std
:
:
vector
<
Uniform
>
&
uniforms
ShCompileOptions
compileOptions
)
;
~
OutputHLSL
(
)
;
void
output
(
TIntermNode
*
treeRoot
TInfoSinkBase
&
objSink
)
;
const
std
:
:
map
<
std
:
:
string
unsigned
int
>
&
getInterfaceBlockRegisterMap
(
)
const
;
const
std
:
:
map
<
std
:
:
string
unsigned
int
>
&
getUniformRegisterMap
(
)
const
;
static
TString
initializer
(
const
TType
&
type
)
;
TInfoSinkBase
&
getInfoSink
(
)
{
ASSERT
(
!
mInfoSinkStack
.
empty
(
)
)
;
return
*
mInfoSinkStack
.
top
(
)
;
}
static
bool
canWriteAsHLSLLiteral
(
TIntermTyped
*
expression
)
;
protected
:
void
header
(
TInfoSinkBase
&
out
const
BuiltInFunctionEmulator
*
builtInFunctionEmulator
)
;
void
visitSymbol
(
TIntermSymbol
*
)
;
void
visitRaw
(
TIntermRaw
*
)
;
void
visitConstantUnion
(
TIntermConstantUnion
*
)
;
bool
visitBinary
(
Visit
visit
TIntermBinary
*
)
;
bool
visitUnary
(
Visit
visit
TIntermUnary
*
)
;
bool
visitTernary
(
Visit
visit
TIntermTernary
*
)
;
bool
visitSelection
(
Visit
visit
TIntermSelection
*
)
;
bool
visitSwitch
(
Visit
visit
TIntermSwitch
*
)
;
bool
visitCase
(
Visit
visit
TIntermCase
*
)
;
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
)
;
bool
visitLoop
(
Visit
visit
TIntermLoop
*
)
;
bool
visitBranch
(
Visit
visit
TIntermBranch
*
)
;
bool
isSingleStatement
(
TIntermNode
*
node
)
;
bool
handleExcessiveLoop
(
TInfoSinkBase
&
out
TIntermLoop
*
node
)
;
void
outputTriplet
(
TInfoSinkBase
&
out
Visit
visit
const
char
*
preString
const
char
*
inString
const
char
*
postString
)
;
void
outputLineDirective
(
TInfoSinkBase
&
out
int
line
)
;
TString
argumentString
(
const
TIntermSymbol
*
symbol
)
;
int
vectorSize
(
const
TType
&
type
)
const
;
void
outputConstructor
(
TInfoSinkBase
&
out
Visit
visit
const
TType
&
type
const
char
*
name
const
TIntermSequence
*
parameters
)
;
const
TConstantUnion
*
writeConstantUnion
(
TInfoSinkBase
&
out
const
TType
&
type
const
TConstantUnion
*
constUnion
)
;
void
outputEqual
(
Visit
visit
const
TType
&
type
TOperator
op
TInfoSinkBase
&
out
)
;
void
writeEmulatedFunctionTriplet
(
TInfoSinkBase
&
out
Visit
visit
const
char
*
preStr
)
;
void
makeFlaggedStructMaps
(
const
std
:
:
vector
<
TIntermTyped
*
>
&
flaggedStructs
)
;
bool
writeSameSymbolInitializer
(
TInfoSinkBase
&
out
TIntermSymbol
*
symbolNode
TIntermTyped
*
expression
)
;
bool
writeConstantInitialization
(
TInfoSinkBase
&
out
TIntermSymbol
*
symbolNode
TIntermTyped
*
expression
)
;
void
writeDeferredGlobalInitializers
(
TInfoSinkBase
&
out
)
;
void
writeSelection
(
TInfoSinkBase
&
out
TIntermSelection
*
node
)
;
TString
addStructEqualityFunction
(
const
TStructure
&
structure
)
;
TString
addArrayEqualityFunction
(
const
TType
&
type
)
;
TString
addArrayAssignmentFunction
(
const
TType
&
type
)
;
TString
addArrayConstructIntoFunction
(
const
TType
&
type
)
;
void
ensureStructDefined
(
const
TType
&
type
)
;
sh
:
:
GLenum
mShaderType
;
int
mShaderVersion
;
const
TExtensionBehavior
&
mExtensionBehavior
;
const
char
*
mSourcePath
;
const
ShShaderOutput
mOutputType
;
ShCompileOptions
mCompileOptions
;
bool
mInsideFunction
;
TInfoSinkBase
mHeader
;
TInfoSinkBase
mBody
;
TInfoSinkBase
mFooter
;
std
:
:
stack
<
TInfoSinkBase
*
>
mInfoSinkStack
;
ReferencedSymbols
mReferencedUniforms
;
ReferencedSymbols
mReferencedInterfaceBlocks
;
ReferencedSymbols
mReferencedAttributes
;
ReferencedSymbols
mReferencedVaryings
;
ReferencedSymbols
mReferencedOutputVariables
;
StructureHLSL
*
mStructureHLSL
;
UniformHLSL
*
mUniformHLSL
;
TextureFunctionHLSL
*
mTextureFunctionHLSL
;
bool
mUsesFragColor
;
bool
mUsesFragData
;
bool
mUsesDepthRange
;
bool
mUsesFragCoord
;
bool
mUsesPointCoord
;
bool
mUsesFrontFacing
;
bool
mUsesPointSize
;
bool
mUsesInstanceID
;
bool
mUsesVertexID
;
bool
mUsesFragDepth
;
bool
mUsesXor
;
bool
mUsesDiscardRewriting
;
bool
mUsesNestedBreak
;
bool
mRequiresIEEEStrictCompiling
;
int
mNumRenderTargets
;
int
mUniqueIndex
;
CallDAG
mCallDag
;
MetadataList
mASTMetadataList
;
ASTMetadataHLSL
*
mCurrentFunctionMetadata
;
bool
mOutputLod0Function
;
bool
mInsideDiscontinuousLoop
;
int
mNestedLoopDepth
;
TIntermSymbol
*
mExcessiveLoopIndex
;
TString
structInitializerString
(
int
indent
const
TStructure
&
structure
const
TString
&
rhsStructName
)
;
std
:
:
map
<
TIntermTyped
*
TString
>
mFlaggedStructMappedNames
;
std
:
:
map
<
TIntermTyped
*
TString
>
mFlaggedStructOriginalNames
;
struct
HelperFunction
{
TString
functionName
;
TString
functionDefinition
;
virtual
~
HelperFunction
(
)
{
}
}
;
std
:
:
vector
<
HelperFunction
*
>
mEqualityFunctions
;
struct
StructEqualityFunction
:
public
HelperFunction
{
const
TStructure
*
structure
;
}
;
std
:
:
vector
<
StructEqualityFunction
*
>
mStructEqualityFunctions
;
struct
ArrayHelperFunction
:
public
HelperFunction
{
TType
type
;
}
;
std
:
:
vector
<
ArrayHelperFunction
*
>
mArrayEqualityFunctions
;
std
:
:
vector
<
ArrayHelperFunction
>
mArrayAssignmentFunctions
;
std
:
:
vector
<
ArrayHelperFunction
>
mArrayConstructIntoFunctions
;
private
:
TString
samplerNamePrefixFromStruct
(
TIntermTyped
*
node
)
;
bool
ancestorEvaluatesToSamplerInStruct
(
Visit
visit
)
;
}
;
}
#
endif
