#
include
"
compiler
/
translator
/
UnfoldShortCircuitToIf
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
namespace
{
class
UnfoldShortCircuitTraverser
:
public
TIntermTraverser
{
public
:
UnfoldShortCircuitTraverser
(
)
;
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
;
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
;
bool
visitSelection
(
Visit
visit
TIntermSelection
*
node
)
override
;
void
nextIteration
(
)
;
bool
foundShortCircuit
(
)
const
{
return
mFoundShortCircuit
;
}
protected
:
bool
mFoundShortCircuit
;
}
;
UnfoldShortCircuitTraverser
:
:
UnfoldShortCircuitTraverser
(
)
:
TIntermTraverser
(
true
false
true
)
mFoundShortCircuit
(
false
)
{
}
bool
UnfoldShortCircuitTraverser
:
:
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
{
if
(
mFoundShortCircuit
)
return
false
;
if
(
!
node
-
>
getRight
(
)
-
>
hasSideEffects
(
)
)
{
return
true
;
}
switch
(
node
-
>
getOp
(
)
)
{
case
EOpLogicalOr
:
mFoundShortCircuit
=
true
;
{
TIntermSequence
insertions
;
TType
boolType
(
EbtBool
EbpUndefined
EvqTemporary
)
;
ASSERT
(
node
-
>
getLeft
(
)
-
>
getType
(
)
=
=
boolType
)
;
insertions
.
push_back
(
createTempInitDeclaration
(
node
-
>
getLeft
(
)
)
)
;
TIntermAggregate
*
assignRightBlock
=
new
TIntermAggregate
(
EOpSequence
)
;
ASSERT
(
node
-
>
getRight
(
)
-
>
getType
(
)
=
=
boolType
)
;
assignRightBlock
-
>
getSequence
(
)
-
>
push_back
(
createTempAssignment
(
node
-
>
getRight
(
)
)
)
;
TIntermUnary
*
notTempSymbol
=
new
TIntermUnary
(
EOpLogicalNot
boolType
)
;
notTempSymbol
-
>
setOperand
(
createTempSymbol
(
boolType
)
)
;
TIntermSelection
*
ifNode
=
new
TIntermSelection
(
notTempSymbol
assignRightBlock
nullptr
)
;
insertions
.
push_back
(
ifNode
)
;
insertStatementsInParentBlock
(
insertions
)
;
NodeUpdateEntry
replaceVariable
(
getParentNode
(
)
node
createTempSymbol
(
boolType
)
false
)
;
mReplacements
.
push_back
(
replaceVariable
)
;
}
return
false
;
case
EOpLogicalAnd
:
mFoundShortCircuit
=
true
;
{
TIntermSequence
insertions
;
TType
boolType
(
EbtBool
EbpUndefined
EvqTemporary
)
;
ASSERT
(
node
-
>
getLeft
(
)
-
>
getType
(
)
=
=
boolType
)
;
insertions
.
push_back
(
createTempInitDeclaration
(
node
-
>
getLeft
(
)
)
)
;
TIntermAggregate
*
assignRightBlock
=
new
TIntermAggregate
(
EOpSequence
)
;
ASSERT
(
node
-
>
getRight
(
)
-
>
getType
(
)
=
=
boolType
)
;
assignRightBlock
-
>
getSequence
(
)
-
>
push_back
(
createTempAssignment
(
node
-
>
getRight
(
)
)
)
;
TIntermSelection
*
ifNode
=
new
TIntermSelection
(
createTempSymbol
(
boolType
)
assignRightBlock
nullptr
)
;
insertions
.
push_back
(
ifNode
)
;
insertStatementsInParentBlock
(
insertions
)
;
NodeUpdateEntry
replaceVariable
(
getParentNode
(
)
node
createTempSymbol
(
boolType
)
false
)
;
mReplacements
.
push_back
(
replaceVariable
)
;
}
return
false
;
default
:
return
true
;
}
}
bool
UnfoldShortCircuitTraverser
:
:
visitSelection
(
Visit
visit
TIntermSelection
*
node
)
{
if
(
mFoundShortCircuit
)
return
false
;
if
(
visit
=
=
PreVisit
&
&
node
-
>
usesTernaryOperator
(
)
)
{
mFoundShortCircuit
=
true
;
TIntermSequence
insertions
;
TIntermSymbol
*
tempSymbol
=
createTempSymbol
(
node
-
>
getType
(
)
)
;
TIntermAggregate
*
tempDeclaration
=
new
TIntermAggregate
(
EOpDeclaration
)
;
tempDeclaration
-
>
getSequence
(
)
-
>
push_back
(
tempSymbol
)
;
insertions
.
push_back
(
tempDeclaration
)
;
TIntermAggregate
*
trueBlock
=
new
TIntermAggregate
(
EOpSequence
)
;
TIntermBinary
*
trueAssignment
=
createTempAssignment
(
node
-
>
getTrueBlock
(
)
-
>
getAsTyped
(
)
)
;
trueBlock
-
>
getSequence
(
)
-
>
push_back
(
trueAssignment
)
;
TIntermAggregate
*
falseBlock
=
new
TIntermAggregate
(
EOpSequence
)
;
TIntermBinary
*
falseAssignment
=
createTempAssignment
(
node
-
>
getFalseBlock
(
)
-
>
getAsTyped
(
)
)
;
falseBlock
-
>
getSequence
(
)
-
>
push_back
(
falseAssignment
)
;
TIntermSelection
*
ifNode
=
new
TIntermSelection
(
node
-
>
getCondition
(
)
-
>
getAsTyped
(
)
trueBlock
falseBlock
)
;
insertions
.
push_back
(
ifNode
)
;
insertStatementsInParentBlock
(
insertions
)
;
TIntermSymbol
*
ternaryResult
=
createTempSymbol
(
node
-
>
getType
(
)
)
;
NodeUpdateEntry
replaceVariable
(
getParentNode
(
)
node
ternaryResult
false
)
;
mReplacements
.
push_back
(
replaceVariable
)
;
return
false
;
}
return
true
;
}
bool
UnfoldShortCircuitTraverser
:
:
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
{
if
(
visit
=
=
PreVisit
&
&
mFoundShortCircuit
)
return
false
;
if
(
node
-
>
getOp
(
)
=
=
EOpComma
)
{
ASSERT
(
visit
!
=
PreVisit
|
|
!
mFoundShortCircuit
)
;
if
(
visit
=
=
PostVisit
&
&
mFoundShortCircuit
)
{
mReplacements
.
clear
(
)
;
mMultiReplacements
.
clear
(
)
;
mInsertions
.
clear
(
)
;
TIntermSequence
insertions
;
TIntermSequence
*
seq
=
node
-
>
getSequence
(
)
;
TIntermSequence
:
:
size_type
i
=
0
;
ASSERT
(
!
seq
-
>
empty
(
)
)
;
while
(
i
<
seq
-
>
size
(
)
-
1
)
{
TIntermTyped
*
child
=
(
*
seq
)
[
i
]
-
>
getAsTyped
(
)
;
insertions
.
push_back
(
child
)
;
+
+
i
;
}
insertStatementsInParentBlock
(
insertions
)
;
NodeUpdateEntry
replaceVariable
(
getParentNode
(
)
node
(
*
seq
)
[
i
]
false
)
;
mReplacements
.
push_back
(
replaceVariable
)
;
}
}
return
true
;
}
void
UnfoldShortCircuitTraverser
:
:
nextIteration
(
)
{
mFoundShortCircuit
=
false
;
nextTemporaryIndex
(
)
;
}
}
void
UnfoldShortCircuitToIf
(
TIntermNode
*
root
unsigned
int
*
temporaryIndex
)
{
UnfoldShortCircuitTraverser
traverser
;
ASSERT
(
temporaryIndex
!
=
nullptr
)
;
traverser
.
useTemporaryIndex
(
temporaryIndex
)
;
do
{
traverser
.
nextIteration
(
)
;
root
-
>
traverse
(
&
traverser
)
;
if
(
traverser
.
foundShortCircuit
(
)
)
traverser
.
updateTree
(
)
;
}
while
(
traverser
.
foundShortCircuit
(
)
)
;
}
