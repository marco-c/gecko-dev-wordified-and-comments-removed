#
include
"
compiler
/
translator
/
UnfoldShortCircuitToIf
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
namespace
{
class
UnfoldShortCircuitTraverser
:
public
TIntermTraverser
{
public
:
UnfoldShortCircuitTraverser
(
)
;
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
;
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
;
bool
visitSelection
(
Visit
visit
TIntermSelection
*
node
)
override
;
bool
visitLoop
(
Visit
visit
TIntermLoop
*
node
)
override
;
void
nextIteration
(
)
;
bool
foundShortCircuit
(
)
const
{
return
mFoundShortCircuit
;
}
protected
:
bool
copyLoopConditionOrExpression
(
TIntermNode
*
parent
TIntermTyped
*
node
)
;
bool
mFoundShortCircuit
;
TIntermLoop
*
mParentLoop
;
TIntermNode
*
mLoopParent
;
bool
mInLoopCondition
;
bool
mInLoopExpression
;
}
;
UnfoldShortCircuitTraverser
:
:
UnfoldShortCircuitTraverser
(
)
:
TIntermTraverser
(
true
false
true
)
mFoundShortCircuit
(
false
)
mParentLoop
(
nullptr
)
mLoopParent
(
nullptr
)
mInLoopCondition
(
false
)
mInLoopExpression
(
false
)
{
}
bool
UnfoldShortCircuitTraverser
:
:
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
{
if
(
mFoundShortCircuit
)
return
false
;
if
(
!
node
-
>
getRight
(
)
-
>
hasSideEffects
(
)
)
{
return
true
;
}
switch
(
node
-
>
getOp
(
)
)
{
case
EOpLogicalOr
:
mFoundShortCircuit
=
true
;
if
(
!
copyLoopConditionOrExpression
(
getParentNode
(
)
node
)
)
{
TIntermSequence
insertions
;
TType
boolType
(
EbtBool
EbpUndefined
EvqTemporary
)
;
ASSERT
(
node
-
>
getLeft
(
)
-
>
getType
(
)
=
=
boolType
)
;
insertions
.
push_back
(
createTempInitDeclaration
(
node
-
>
getLeft
(
)
)
)
;
TIntermAggregate
*
assignRightBlock
=
new
TIntermAggregate
(
EOpSequence
)
;
ASSERT
(
node
-
>
getRight
(
)
-
>
getType
(
)
=
=
boolType
)
;
assignRightBlock
-
>
getSequence
(
)
-
>
push_back
(
createTempAssignment
(
node
-
>
getRight
(
)
)
)
;
TIntermUnary
*
notTempSymbol
=
new
TIntermUnary
(
EOpLogicalNot
boolType
)
;
notTempSymbol
-
>
setOperand
(
createTempSymbol
(
boolType
)
)
;
TIntermSelection
*
ifNode
=
new
TIntermSelection
(
notTempSymbol
assignRightBlock
nullptr
)
;
insertions
.
push_back
(
ifNode
)
;
insertStatementsInParentBlock
(
insertions
)
;
NodeUpdateEntry
replaceVariable
(
getParentNode
(
)
node
createTempSymbol
(
boolType
)
false
)
;
mReplacements
.
push_back
(
replaceVariable
)
;
}
return
false
;
case
EOpLogicalAnd
:
mFoundShortCircuit
=
true
;
if
(
!
copyLoopConditionOrExpression
(
getParentNode
(
)
node
)
)
{
TIntermSequence
insertions
;
TType
boolType
(
EbtBool
EbpUndefined
EvqTemporary
)
;
ASSERT
(
node
-
>
getLeft
(
)
-
>
getType
(
)
=
=
boolType
)
;
insertions
.
push_back
(
createTempInitDeclaration
(
node
-
>
getLeft
(
)
)
)
;
TIntermAggregate
*
assignRightBlock
=
new
TIntermAggregate
(
EOpSequence
)
;
ASSERT
(
node
-
>
getRight
(
)
-
>
getType
(
)
=
=
boolType
)
;
assignRightBlock
-
>
getSequence
(
)
-
>
push_back
(
createTempAssignment
(
node
-
>
getRight
(
)
)
)
;
TIntermSelection
*
ifNode
=
new
TIntermSelection
(
createTempSymbol
(
boolType
)
assignRightBlock
nullptr
)
;
insertions
.
push_back
(
ifNode
)
;
insertStatementsInParentBlock
(
insertions
)
;
NodeUpdateEntry
replaceVariable
(
getParentNode
(
)
node
createTempSymbol
(
boolType
)
false
)
;
mReplacements
.
push_back
(
replaceVariable
)
;
}
return
false
;
default
:
return
true
;
}
}
bool
UnfoldShortCircuitTraverser
:
:
visitSelection
(
Visit
visit
TIntermSelection
*
node
)
{
if
(
mFoundShortCircuit
)
return
false
;
if
(
visit
=
=
PreVisit
&
&
node
-
>
usesTernaryOperator
(
)
)
{
mFoundShortCircuit
=
true
;
if
(
!
copyLoopConditionOrExpression
(
getParentNode
(
)
node
)
)
{
TIntermSequence
insertions
;
TIntermSymbol
*
tempSymbol
=
createTempSymbol
(
node
-
>
getType
(
)
)
;
TIntermAggregate
*
tempDeclaration
=
new
TIntermAggregate
(
EOpDeclaration
)
;
tempDeclaration
-
>
getSequence
(
)
-
>
push_back
(
tempSymbol
)
;
insertions
.
push_back
(
tempDeclaration
)
;
TIntermAggregate
*
trueBlock
=
new
TIntermAggregate
(
EOpSequence
)
;
TIntermBinary
*
trueAssignment
=
createTempAssignment
(
node
-
>
getTrueBlock
(
)
-
>
getAsTyped
(
)
)
;
trueBlock
-
>
getSequence
(
)
-
>
push_back
(
trueAssignment
)
;
TIntermAggregate
*
falseBlock
=
new
TIntermAggregate
(
EOpSequence
)
;
TIntermBinary
*
falseAssignment
=
createTempAssignment
(
node
-
>
getFalseBlock
(
)
-
>
getAsTyped
(
)
)
;
falseBlock
-
>
getSequence
(
)
-
>
push_back
(
falseAssignment
)
;
TIntermSelection
*
ifNode
=
new
TIntermSelection
(
node
-
>
getCondition
(
)
-
>
getAsTyped
(
)
trueBlock
falseBlock
)
;
insertions
.
push_back
(
ifNode
)
;
insertStatementsInParentBlock
(
insertions
)
;
TIntermSymbol
*
ternaryResult
=
createTempSymbol
(
node
-
>
getType
(
)
)
;
NodeUpdateEntry
replaceVariable
(
getParentNode
(
)
node
ternaryResult
false
)
;
mReplacements
.
push_back
(
replaceVariable
)
;
}
return
false
;
}
return
true
;
}
bool
UnfoldShortCircuitTraverser
:
:
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
{
if
(
visit
=
=
PreVisit
&
&
mFoundShortCircuit
)
return
false
;
if
(
node
-
>
getOp
(
)
=
=
EOpComma
)
{
ASSERT
(
visit
!
=
PreVisit
|
|
!
mFoundShortCircuit
)
;
if
(
visit
=
=
PostVisit
&
&
mFoundShortCircuit
)
{
mReplacements
.
clear
(
)
;
mMultiReplacements
.
clear
(
)
;
mInsertions
.
clear
(
)
;
if
(
!
copyLoopConditionOrExpression
(
getParentNode
(
)
node
)
)
{
TIntermSequence
insertions
;
TIntermSequence
*
seq
=
node
-
>
getSequence
(
)
;
TIntermSequence
:
:
size_type
i
=
0
;
ASSERT
(
!
seq
-
>
empty
(
)
)
;
while
(
i
<
seq
-
>
size
(
)
-
1
)
{
TIntermTyped
*
child
=
(
*
seq
)
[
i
]
-
>
getAsTyped
(
)
;
insertions
.
push_back
(
child
)
;
+
+
i
;
}
insertStatementsInParentBlock
(
insertions
)
;
NodeUpdateEntry
replaceVariable
(
getParentNode
(
)
node
(
*
seq
)
[
i
]
false
)
;
mReplacements
.
push_back
(
replaceVariable
)
;
}
}
}
return
true
;
}
bool
UnfoldShortCircuitTraverser
:
:
visitLoop
(
Visit
visit
TIntermLoop
*
node
)
{
if
(
visit
=
=
PreVisit
)
{
if
(
mFoundShortCircuit
)
return
false
;
mLoopParent
=
getParentNode
(
)
;
mParentLoop
=
node
;
incrementDepth
(
node
)
;
if
(
node
-
>
getInit
(
)
)
{
node
-
>
getInit
(
)
-
>
traverse
(
this
)
;
if
(
mFoundShortCircuit
)
{
decrementDepth
(
)
;
return
false
;
}
}
if
(
node
-
>
getCondition
(
)
)
{
mInLoopCondition
=
true
;
node
-
>
getCondition
(
)
-
>
traverse
(
this
)
;
mInLoopCondition
=
false
;
if
(
mFoundShortCircuit
)
{
decrementDepth
(
)
;
return
false
;
}
}
if
(
node
-
>
getExpression
(
)
)
{
mInLoopExpression
=
true
;
node
-
>
getExpression
(
)
-
>
traverse
(
this
)
;
mInLoopExpression
=
false
;
if
(
mFoundShortCircuit
)
{
decrementDepth
(
)
;
return
false
;
}
}
if
(
node
-
>
getBody
(
)
)
node
-
>
getBody
(
)
-
>
traverse
(
this
)
;
decrementDepth
(
)
;
}
return
false
;
}
bool
UnfoldShortCircuitTraverser
:
:
copyLoopConditionOrExpression
(
TIntermNode
*
parent
TIntermTyped
*
node
)
{
if
(
mInLoopCondition
)
{
mReplacements
.
push_back
(
NodeUpdateEntry
(
parent
node
createTempSymbol
(
node
-
>
getType
(
)
)
false
)
)
;
TIntermAggregate
*
body
=
mParentLoop
-
>
getBody
(
)
;
TIntermSequence
empty
;
if
(
mParentLoop
-
>
getType
(
)
=
=
ELoopDoWhile
)
{
TIntermSequence
insertionsBeforeLoop
;
insertionsBeforeLoop
.
push_back
(
createTempDeclaration
(
node
-
>
getType
(
)
)
)
;
insertStatementsInParentBlock
(
insertionsBeforeLoop
)
;
TIntermSequence
insertionsInLoop
;
insertionsInLoop
.
push_back
(
createTempAssignment
(
node
)
)
;
mInsertions
.
push_back
(
NodeInsertMultipleEntry
(
body
body
-
>
getSequence
(
)
-
>
size
(
)
-
1
empty
insertionsInLoop
)
)
;
}
else
{
TIntermAggregate
*
loopScope
=
new
TIntermAggregate
(
EOpSequence
)
;
TIntermNode
*
initializer
=
mParentLoop
-
>
getInit
(
)
;
if
(
initializer
!
=
nullptr
)
{
mReplacements
.
push_back
(
NodeUpdateEntry
(
mParentLoop
initializer
nullptr
false
)
)
;
loopScope
-
>
getSequence
(
)
-
>
push_back
(
initializer
)
;
}
loopScope
-
>
getSequence
(
)
-
>
push_back
(
createTempInitDeclaration
(
node
)
)
;
loopScope
-
>
getSequence
(
)
-
>
push_back
(
mParentLoop
)
;
mReplacements
.
push_back
(
NodeUpdateEntry
(
mLoopParent
mParentLoop
loopScope
true
)
)
;
TIntermSequence
insertionsInLoop
;
insertionsInLoop
.
push_back
(
createTempAssignment
(
node
-
>
deepCopy
(
)
)
)
;
mInsertions
.
push_back
(
NodeInsertMultipleEntry
(
body
body
-
>
getSequence
(
)
-
>
size
(
)
-
1
empty
insertionsInLoop
)
)
;
}
return
true
;
}
if
(
mInLoopExpression
)
{
TIntermTyped
*
movedExpression
=
mParentLoop
-
>
getExpression
(
)
;
mReplacements
.
push_back
(
NodeUpdateEntry
(
mParentLoop
movedExpression
nullptr
false
)
)
;
TIntermAggregate
*
body
=
mParentLoop
-
>
getBody
(
)
;
TIntermSequence
empty
;
TIntermSequence
insertions
;
insertions
.
push_back
(
movedExpression
)
;
mInsertions
.
push_back
(
NodeInsertMultipleEntry
(
body
body
-
>
getSequence
(
)
-
>
size
(
)
-
1
empty
insertions
)
)
;
return
true
;
}
return
false
;
}
void
UnfoldShortCircuitTraverser
:
:
nextIteration
(
)
{
mFoundShortCircuit
=
false
;
nextTemporaryIndex
(
)
;
}
}
void
UnfoldShortCircuitToIf
(
TIntermNode
*
root
unsigned
int
*
temporaryIndex
)
{
UnfoldShortCircuitTraverser
traverser
;
ASSERT
(
temporaryIndex
!
=
nullptr
)
;
traverser
.
useTemporaryIndex
(
temporaryIndex
)
;
do
{
traverser
.
nextIteration
(
)
;
root
-
>
traverse
(
&
traverser
)
;
if
(
traverser
.
foundShortCircuit
(
)
)
traverser
.
updateTree
(
)
;
}
while
(
traverser
.
foundShortCircuit
(
)
)
;
}
