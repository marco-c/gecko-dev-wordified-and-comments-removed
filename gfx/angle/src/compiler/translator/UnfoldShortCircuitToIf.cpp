#
include
"
compiler
/
translator
/
UnfoldShortCircuitToIf
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
#
include
"
compiler
/
translator
/
IntermNodePatternMatcher
.
h
"
namespace
{
class
UnfoldShortCircuitTraverser
:
public
TIntermTraverser
{
public
:
UnfoldShortCircuitTraverser
(
)
;
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
;
bool
visitTernary
(
Visit
visit
TIntermTernary
*
node
)
override
;
void
nextIteration
(
)
;
bool
foundShortCircuit
(
)
const
{
return
mFoundShortCircuit
;
}
protected
:
bool
mFoundShortCircuit
;
IntermNodePatternMatcher
mPatternToUnfoldMatcher
;
}
;
UnfoldShortCircuitTraverser
:
:
UnfoldShortCircuitTraverser
(
)
:
TIntermTraverser
(
true
false
true
)
mFoundShortCircuit
(
false
)
mPatternToUnfoldMatcher
(
IntermNodePatternMatcher
:
:
kUnfoldedShortCircuitExpression
)
{
}
bool
UnfoldShortCircuitTraverser
:
:
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
{
if
(
mFoundShortCircuit
)
return
false
;
if
(
visit
!
=
PreVisit
)
return
true
;
if
(
!
mPatternToUnfoldMatcher
.
match
(
node
getParentNode
(
)
)
)
return
true
;
ASSERT
(
node
-
>
getRight
(
)
-
>
hasSideEffects
(
)
)
;
mFoundShortCircuit
=
true
;
switch
(
node
-
>
getOp
(
)
)
{
case
EOpLogicalOr
:
{
TIntermSequence
insertions
;
TType
boolType
(
EbtBool
EbpUndefined
EvqTemporary
)
;
ASSERT
(
node
-
>
getLeft
(
)
-
>
getType
(
)
=
=
boolType
)
;
insertions
.
push_back
(
createTempInitDeclaration
(
node
-
>
getLeft
(
)
)
)
;
TIntermAggregate
*
assignRightBlock
=
new
TIntermAggregate
(
EOpSequence
)
;
ASSERT
(
node
-
>
getRight
(
)
-
>
getType
(
)
=
=
boolType
)
;
assignRightBlock
-
>
getSequence
(
)
-
>
push_back
(
createTempAssignment
(
node
-
>
getRight
(
)
)
)
;
TIntermUnary
*
notTempSymbol
=
new
TIntermUnary
(
EOpLogicalNot
createTempSymbol
(
boolType
)
)
;
TIntermSelection
*
ifNode
=
new
TIntermSelection
(
notTempSymbol
assignRightBlock
nullptr
)
;
insertions
.
push_back
(
ifNode
)
;
insertStatementsInParentBlock
(
insertions
)
;
queueReplacement
(
node
createTempSymbol
(
boolType
)
OriginalNode
:
:
IS_DROPPED
)
;
return
false
;
}
case
EOpLogicalAnd
:
{
TIntermSequence
insertions
;
TType
boolType
(
EbtBool
EbpUndefined
EvqTemporary
)
;
ASSERT
(
node
-
>
getLeft
(
)
-
>
getType
(
)
=
=
boolType
)
;
insertions
.
push_back
(
createTempInitDeclaration
(
node
-
>
getLeft
(
)
)
)
;
TIntermAggregate
*
assignRightBlock
=
new
TIntermAggregate
(
EOpSequence
)
;
ASSERT
(
node
-
>
getRight
(
)
-
>
getType
(
)
=
=
boolType
)
;
assignRightBlock
-
>
getSequence
(
)
-
>
push_back
(
createTempAssignment
(
node
-
>
getRight
(
)
)
)
;
TIntermSelection
*
ifNode
=
new
TIntermSelection
(
createTempSymbol
(
boolType
)
assignRightBlock
nullptr
)
;
insertions
.
push_back
(
ifNode
)
;
insertStatementsInParentBlock
(
insertions
)
;
queueReplacement
(
node
createTempSymbol
(
boolType
)
OriginalNode
:
:
IS_DROPPED
)
;
return
false
;
}
default
:
UNREACHABLE
(
)
;
return
true
;
}
}
bool
UnfoldShortCircuitTraverser
:
:
visitTernary
(
Visit
visit
TIntermTernary
*
node
)
{
if
(
mFoundShortCircuit
)
return
false
;
if
(
visit
!
=
PreVisit
)
return
true
;
if
(
!
mPatternToUnfoldMatcher
.
match
(
node
)
)
return
true
;
mFoundShortCircuit
=
true
;
TIntermSequence
insertions
;
TIntermSymbol
*
tempSymbol
=
createTempSymbol
(
node
-
>
getType
(
)
)
;
TIntermAggregate
*
tempDeclaration
=
new
TIntermAggregate
(
EOpDeclaration
)
;
tempDeclaration
-
>
getSequence
(
)
-
>
push_back
(
tempSymbol
)
;
insertions
.
push_back
(
tempDeclaration
)
;
TIntermAggregate
*
trueBlock
=
new
TIntermAggregate
(
EOpSequence
)
;
TIntermBinary
*
trueAssignment
=
createTempAssignment
(
node
-
>
getTrueExpression
(
)
)
;
trueBlock
-
>
getSequence
(
)
-
>
push_back
(
trueAssignment
)
;
TIntermAggregate
*
falseBlock
=
new
TIntermAggregate
(
EOpSequence
)
;
TIntermBinary
*
falseAssignment
=
createTempAssignment
(
node
-
>
getFalseExpression
(
)
)
;
falseBlock
-
>
getSequence
(
)
-
>
push_back
(
falseAssignment
)
;
TIntermSelection
*
ifNode
=
new
TIntermSelection
(
node
-
>
getCondition
(
)
-
>
getAsTyped
(
)
trueBlock
falseBlock
)
;
insertions
.
push_back
(
ifNode
)
;
insertStatementsInParentBlock
(
insertions
)
;
TIntermSymbol
*
ternaryResult
=
createTempSymbol
(
node
-
>
getType
(
)
)
;
queueReplacement
(
node
ternaryResult
OriginalNode
:
:
IS_DROPPED
)
;
return
false
;
}
void
UnfoldShortCircuitTraverser
:
:
nextIteration
(
)
{
mFoundShortCircuit
=
false
;
nextTemporaryIndex
(
)
;
}
}
void
UnfoldShortCircuitToIf
(
TIntermNode
*
root
unsigned
int
*
temporaryIndex
)
{
UnfoldShortCircuitTraverser
traverser
;
ASSERT
(
temporaryIndex
!
=
nullptr
)
;
traverser
.
useTemporaryIndex
(
temporaryIndex
)
;
do
{
traverser
.
nextIteration
(
)
;
root
-
>
traverse
(
&
traverser
)
;
if
(
traverser
.
foundShortCircuit
(
)
)
traverser
.
updateTree
(
)
;
}
while
(
traverser
.
foundShortCircuit
(
)
)
;
}
