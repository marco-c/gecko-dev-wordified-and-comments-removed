#
include
"
vector_utils
.
h
"
#
include
<
gtest
/
gtest
.
h
>
using
namespace
angle
;
namespace
{
TEST
(
VectorUtilsTest
Comparison
)
{
ASSERT_TRUE
(
Vector2
(
2
.
0
3
.
0
)
=
=
Vector2
(
2
.
0
3
.
0
)
)
;
ASSERT_TRUE
(
Vector2
(
2
.
0
3
.
0
)
!
=
Vector2
(
2
.
0
4
.
0
)
)
;
ASSERT_EQ
(
Vector2
(
2
.
0
3
.
0
)
Vector2
(
2
.
0
3
.
0
)
)
;
ASSERT_NE
(
Vector2
(
2
.
0
3
.
0
)
Vector2
(
2
.
0
4
.
0
)
)
;
ASSERT_EQ
(
Vector4
(
0
.
0
)
Vector4
(
0
.
0
)
)
;
ASSERT_NE
(
Vector4
(
1
.
0
0
.
0
0
.
0
0
.
0
)
Vector4
(
0
.
0
)
)
;
ASSERT_NE
(
Vector4
(
0
.
0
1
.
0
0
.
0
0
.
0
)
Vector4
(
0
.
0
)
)
;
ASSERT_NE
(
Vector4
(
0
.
0
0
.
0
1
.
0
0
.
0
)
Vector4
(
0
.
0
)
)
;
ASSERT_NE
(
Vector4
(
0
.
0
0
.
0
0
.
0
1
.
0
)
Vector4
(
0
.
0
)
)
;
}
TEST
(
VectorUtilsTest
Indexing
)
{
Vector2
vec
(
1
.
0
2
.
0
)
;
ASSERT_EQ
(
1
.
0
vec
[
0
]
)
;
ASSERT_EQ
(
2
.
0
vec
[
1
]
)
;
vec
[
0
]
=
3
.
0
;
vec
[
1
]
=
4
.
0
;
ASSERT_EQ
(
Vector2
(
3
.
0
4
.
0
)
vec
)
;
}
TEST
(
VectorUtilsTest
Constructors
)
{
{
Vector2
vec
(
3
.
0
)
;
ASSERT_EQ
(
3
.
0
vec
[
0
]
)
;
ASSERT_EQ
(
3
.
0
vec
[
1
]
)
;
}
{
Vector2
vec
(
Vector2
(
1
.
0
2
.
0
)
)
;
ASSERT_EQ
(
1
.
0
vec
[
0
]
)
;
ASSERT_EQ
(
2
.
0
vec
[
1
]
)
;
}
{
Vector4
vec
(
1
.
0
Vector2
(
2
.
0
3
.
0
)
4
.
0
)
;
ASSERT_EQ
(
1
.
0
vec
[
0
]
)
;
ASSERT_EQ
(
2
.
0
vec
[
1
]
)
;
ASSERT_EQ
(
3
.
0
vec
[
2
]
)
;
ASSERT_EQ
(
4
.
0
vec
[
3
]
)
;
}
}
TEST
(
VectorUtilsTest
DataAccess
)
{
Vector2
vec
(
1
.
0
2
.
0
)
;
ASSERT_EQ
(
2u
vec
.
size
(
)
)
;
ASSERT_EQ
(
1
.
0
vec
.
data
(
)
[
0
]
)
;
ASSERT_EQ
(
2
.
0
vec
.
data
(
)
[
1
]
)
;
vec
.
data
(
)
[
0
]
=
3
.
0
;
vec
.
data
(
)
[
1
]
=
4
.
0
;
ASSERT_EQ
(
Vector2
(
3
.
0
4
.
0
)
vec
)
;
}
TEST
(
VectorUtilsTest
LoadStore
)
{
float
data
[
]
=
{
1
.
0
2
.
0
}
;
Vector2
vec
=
Vector2
:
:
Load
(
data
)
;
ASSERT_EQ
(
1
.
0
vec
.
data
(
)
[
0
]
)
;
ASSERT_EQ
(
2
.
0
vec
.
data
(
)
[
1
]
)
;
vec
=
Vector2
(
3
.
0
4
.
0
)
;
Vector2
:
:
Store
(
vec
data
)
;
ASSERT_EQ
(
3
.
0
data
[
0
]
)
;
ASSERT_EQ
(
4
.
0
data
[
1
]
)
;
}
TEST
(
VectorUtilsTest
BasicArithmetic
)
{
ASSERT_EQ
(
Vector2
(
2
.
0
3
.
0
)
+
Vector2
(
2
.
0
3
.
0
)
)
;
ASSERT_EQ
(
Vector2
(
-
2
.
0
-
3
.
0
)
-
Vector2
(
2
.
0
3
.
0
)
)
;
ASSERT_EQ
(
Vector2
(
4
.
0
6
.
0
)
Vector2
(
1
.
0
2
.
0
)
+
Vector2
(
3
.
0
4
.
0
)
)
;
ASSERT_EQ
(
Vector2
(
-
2
.
0
-
2
.
0
)
Vector2
(
1
.
0
2
.
0
)
-
Vector2
(
3
.
0
4
.
0
)
)
;
ASSERT_EQ
(
Vector2
(
3
.
0
8
.
0
)
Vector2
(
1
.
0
2
.
0
)
*
Vector2
(
3
.
0
4
.
0
)
)
;
ASSERT_EQ
(
Vector2
(
3
.
0
2
.
0
)
Vector2
(
3
.
0
4
.
0
)
/
Vector2
(
1
.
0
2
.
0
)
)
;
ASSERT_EQ
(
Vector2
(
2
.
0
4
.
0
)
Vector2
(
1
.
0
2
.
0
)
*
2
)
;
ASSERT_EQ
(
Vector2
(
2
.
0
4
.
0
)
2
*
Vector2
(
1
.
0
2
.
0
)
)
;
ASSERT_EQ
(
Vector2
(
0
.
5
1
.
0
)
Vector2
(
1
.
0
2
.
0
)
/
2
)
;
}
TEST
(
VectorUtilsTest
CompoundArithmetic
)
{
{
Vector2
vec
(
1
.
0
2
.
0
)
;
vec
+
=
Vector2
(
3
.
0
4
.
0
)
;
ASSERT_EQ
(
Vector2
(
4
.
0
6
.
0
)
vec
)
;
}
{
Vector2
vec
(
1
.
0
2
.
0
)
;
vec
-
=
Vector2
(
3
.
0
4
.
0
)
;
ASSERT_EQ
(
Vector2
(
-
2
.
0
-
2
.
0
)
vec
)
;
}
{
Vector2
vec
(
1
.
0
2
.
0
)
;
vec
*
=
Vector2
(
3
.
0
4
.
0
)
;
ASSERT_EQ
(
Vector2
(
3
.
0
8
.
0
)
vec
)
;
}
{
Vector2
vec
(
3
.
0
4
.
0
)
;
vec
/
=
Vector2
(
1
.
0
2
.
0
)
;
ASSERT_EQ
(
Vector2
(
3
.
0
2
.
0
)
vec
)
;
}
{
Vector2
vec
(
1
.
0
2
.
0
)
;
vec
*
=
2
.
0
;
ASSERT_EQ
(
Vector2
(
2
.
0
4
.
0
)
vec
)
;
}
{
Vector2
vec
(
1
.
0
2
.
0
)
;
vec
/
=
2
.
0
;
ASSERT_EQ
(
Vector2
(
0
.
5
1
.
0
)
vec
)
;
}
}
TEST
(
VectorUtilsTest
OtherArithmeticOperations
)
{
Vector2
vec
(
3
.
0
4
.
0
)
;
ASSERT_EQ
(
25
.
0
vec
.
lengthSquared
(
)
)
;
ASSERT_EQ
(
5
.
0
vec
.
length
(
)
)
;
ASSERT_EQ
(
Vector2
(
0
.
6
0
.
8
)
vec
.
normalized
(
)
)
;
ASSERT_EQ
(
11
.
0
vec
.
dot
(
Vector2
(
1
.
0
2
.
0
)
)
)
;
}
TEST
(
VectorUtilsTest
ElementShortcuts
)
{
Vector2
vec2
(
1
.
0
2
.
0
)
;
Vector3
vec3
(
1
.
0
2
.
0
3
.
0
)
;
Vector4
vec4
(
1
.
0
2
.
0
3
.
0
4
.
0
)
;
ASSERT_EQ
(
1
.
0
vec2
.
x
(
)
)
;
ASSERT_EQ
(
1
.
0
vec3
.
x
(
)
)
;
ASSERT_EQ
(
1
.
0
vec4
.
x
(
)
)
;
ASSERT_EQ
(
2
.
0
vec2
.
y
(
)
)
;
ASSERT_EQ
(
2
.
0
vec3
.
y
(
)
)
;
ASSERT_EQ
(
2
.
0
vec4
.
y
(
)
)
;
ASSERT_EQ
(
3
.
0
vec3
.
z
(
)
)
;
ASSERT_EQ
(
3
.
0
vec4
.
z
(
)
)
;
ASSERT_EQ
(
4
.
0
vec4
.
w
(
)
)
;
vec2
.
x
(
)
=
0
.
0
;
ASSERT_EQ
(
Vector2
(
0
.
0
2
.
0
)
vec2
)
;
}
TEST
(
VectorUtilsTest
CrossProduct
)
{
ASSERT_EQ
(
Vector3
(
0
.
0
0
.
0
1
.
0
)
Vector3
(
1
.
0
0
.
0
0
.
0
)
.
cross
(
Vector3
(
0
.
0
1
.
0
0
.
0
)
)
)
;
ASSERT_EQ
(
Vector3
(
-
3
.
0
6
.
0
-
3
.
0
)
Vector3
(
1
.
0
2
.
0
3
.
0
)
.
cross
(
Vector3
(
4
.
0
5
.
0
6
.
0
)
)
)
;
}
TEST
(
VectorUtilsTest
IntVector
)
{
Vector2I
vec
(
0
)
;
int
*
data
=
vec
.
data
(
)
;
data
[
1
]
=
1
;
ASSERT_EQ
(
0
vec
[
0
]
)
;
ASSERT_EQ
(
1
vec
[
1
]
)
;
}
TEST
(
VectorUtilsTest
UIntVector
)
{
Vector2U
vec
(
0
)
;
unsigned
int
*
data
=
vec
.
data
(
)
;
data
[
1
]
=
1
;
ASSERT_EQ
(
0u
vec
[
0
]
)
;
ASSERT_EQ
(
1u
vec
[
1
]
)
;
}
}
