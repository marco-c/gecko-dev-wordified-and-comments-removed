#
ifndef
COMMON_UTILITIES_H_
#
define
COMMON_UTILITIES_H_
#
include
<
EGL
/
egl
.
h
>
#
include
<
EGL
/
eglext
.
h
>
#
include
"
angle_gl
.
h
"
#
include
<
string
>
#
include
<
math
.
h
>
#
include
"
common
/
mathutil
.
h
"
namespace
gl
{
int
VariableComponentCount
(
GLenum
type
)
;
GLenum
VariableComponentType
(
GLenum
type
)
;
size_t
VariableComponentSize
(
GLenum
type
)
;
size_t
VariableInternalSize
(
GLenum
type
)
;
size_t
VariableExternalSize
(
GLenum
type
)
;
GLenum
VariableBoolVectorType
(
GLenum
type
)
;
int
VariableRowCount
(
GLenum
type
)
;
int
VariableColumnCount
(
GLenum
type
)
;
bool
IsSamplerType
(
GLenum
type
)
;
GLenum
SamplerTypeToTextureType
(
GLenum
samplerType
)
;
bool
IsMatrixType
(
GLenum
type
)
;
GLenum
TransposeMatrixType
(
GLenum
type
)
;
int
VariableRegisterCount
(
GLenum
type
)
;
int
MatrixRegisterCount
(
GLenum
type
bool
isRowMajorMatrix
)
;
int
MatrixComponentCount
(
GLenum
type
bool
isRowMajorMatrix
)
;
int
VariableSortOrder
(
GLenum
type
)
;
int
AllocateFirstFreeBits
(
unsigned
int
*
bits
unsigned
int
allocationSize
unsigned
int
bitsSize
)
;
static
const
GLenum
FirstCubeMapTextureTarget
=
GL_TEXTURE_CUBE_MAP_POSITIVE_X
;
static
const
GLenum
LastCubeMapTextureTarget
=
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
;
bool
IsCubeMapTextureTarget
(
GLenum
target
)
;
size_t
CubeMapTextureTargetToLayerIndex
(
GLenum
target
)
;
GLenum
LayerIndexToCubeMapTextureTarget
(
size_t
index
)
;
std
:
:
string
ParseUniformName
(
const
std
:
:
string
&
name
size_t
*
outSubscript
)
;
IndexRange
ComputeIndexRange
(
GLenum
indexType
const
GLvoid
*
indices
size_t
count
bool
primitiveRestartEnabled
)
;
GLuint
GetPrimitiveRestartIndex
(
GLenum
indexType
)
;
bool
IsTriangleMode
(
GLenum
drawMode
)
;
template
<
typename
outT
>
outT
iround
(
GLfloat
value
)
{
return
static_cast
<
outT
>
(
value
>
0
.
0f
?
floor
(
value
+
0
.
5f
)
:
ceil
(
value
-
0
.
5f
)
)
;
}
template
<
typename
outT
>
outT
uiround
(
GLfloat
value
)
{
return
static_cast
<
outT
>
(
value
+
0
.
5f
)
;
}
template
<
typename
ParamType
>
GLuint
ConvertToGLuint
(
ParamType
param
)
{
return
static_cast
<
GLuint
>
(
param
)
;
}
template
<
>
GLuint
ConvertToGLuint
(
GLfloat
param
)
;
template
<
typename
ParamType
>
GLint
ConvertToGLint
(
ParamType
param
)
{
return
static_cast
<
GLint
>
(
param
)
;
}
template
<
>
GLint
ConvertToGLint
(
GLfloat
param
)
;
template
<
typename
ParamType
>
GLenum
ConvertToGLenum
(
ParamType
param
)
{
return
static_cast
<
GLenum
>
(
ConvertToGLuint
(
param
)
)
;
}
template
<
typename
ParamType
>
GLfloat
ConvertToGLfloat
(
ParamType
param
)
{
return
static_cast
<
GLfloat
>
(
param
)
;
}
template
<
typename
ParamType
>
ParamType
ConvertFromGLfloat
(
GLfloat
param
)
{
return
static_cast
<
ParamType
>
(
param
)
;
}
template
<
>
GLint
ConvertFromGLfloat
(
GLfloat
param
)
;
template
<
>
GLuint
ConvertFromGLfloat
(
GLfloat
param
)
;
template
<
typename
ParamType
>
ParamType
ConvertFromGLenum
(
GLenum
param
)
{
return
static_cast
<
ParamType
>
(
param
)
;
}
template
<
typename
ParamType
>
ParamType
ConvertFromGLuint
(
GLuint
param
)
{
return
static_cast
<
ParamType
>
(
param
)
;
}
template
<
typename
ParamType
>
ParamType
ConvertFromGLint
(
GLint
param
)
{
return
static_cast
<
ParamType
>
(
param
)
;
}
template
<
typename
ParamType
>
ParamType
ConvertFromGLboolean
(
GLboolean
param
)
{
return
static_cast
<
ParamType
>
(
param
?
GL_TRUE
:
GL_FALSE
)
;
}
template
<
typename
ParamType
>
ParamType
ConvertFromGLint64
(
GLint64
param
)
{
return
clampCast
<
ParamType
>
(
param
)
;
}
unsigned
int
ParseAndStripArrayIndex
(
std
:
:
string
*
name
)
;
}
namespace
egl
{
static
const
EGLenum
FirstCubeMapTextureTarget
=
EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X_KHR
;
static
const
EGLenum
LastCubeMapTextureTarget
=
EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_KHR
;
bool
IsCubeMapTextureTarget
(
EGLenum
target
)
;
size_t
CubeMapTextureTargetToLayerIndex
(
EGLenum
target
)
;
EGLenum
LayerIndexToCubeMapTextureTarget
(
size_t
index
)
;
bool
IsTextureTarget
(
EGLenum
target
)
;
bool
IsRenderbufferTarget
(
EGLenum
target
)
;
}
namespace
egl_gl
{
GLenum
EGLCubeMapTargetToGLCubeMapTarget
(
EGLenum
eglTarget
)
;
GLenum
EGLImageTargetToGLTextureTarget
(
EGLenum
eglTarget
)
;
GLuint
EGLClientBufferToGLObjectHandle
(
EGLClientBuffer
buffer
)
;
}
#
if
!
defined
(
ANGLE_ENABLE_WINDOWS_STORE
)
std
:
:
string
getTempPath
(
)
;
void
writeFile
(
const
char
*
path
const
void
*
data
size_t
size
)
;
#
endif
#
if
defined
(
ANGLE_PLATFORM_WINDOWS
)
void
ScheduleYield
(
)
;
#
endif
#
endif
