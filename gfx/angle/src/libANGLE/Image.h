#
ifndef
LIBANGLE_IMAGE_H_
#
define
LIBANGLE_IMAGE_H_
#
include
"
common
/
angleutils
.
h
"
#
include
"
libANGLE
/
AttributeMap
.
h
"
#
include
"
libANGLE
/
Error
.
h
"
#
include
"
libANGLE
/
FramebufferAttachment
.
h
"
#
include
"
libANGLE
/
RefCountObject
.
h
"
#
include
"
libANGLE
/
formatutils
.
h
"
#
include
<
set
>
namespace
rx
{
class
EGLImplFactory
;
class
ImageImpl
;
}
namespace
egl
{
class
Image
;
class
ImageSibling
:
public
gl
:
:
RefCountObject
public
gl
:
:
FramebufferAttachmentObject
{
public
:
ImageSibling
(
GLuint
id
)
;
virtual
~
ImageSibling
(
)
;
protected
:
void
setTargetImage
(
const
gl
:
:
Context
*
context
egl
:
:
Image
*
imageTarget
)
;
gl
:
:
Error
orphanImages
(
const
gl
:
:
Context
*
context
)
;
private
:
friend
class
Image
;
void
addImageSource
(
egl
:
:
Image
*
imageSource
)
;
void
removeImageSource
(
egl
:
:
Image
*
imageSource
)
;
std
:
:
set
<
Image
*
>
mSourcesOf
;
gl
:
:
BindingPointer
<
Image
>
mTargetOf
;
}
;
struct
ImageState
:
private
angle
:
:
NonCopyable
{
ImageState
(
EGLenum
target
ImageSibling
*
buffer
const
AttributeMap
&
attribs
)
;
gl
:
:
ImageIndex
imageIndex
;
gl
:
:
BindingPointer
<
ImageSibling
>
source
;
std
:
:
set
<
ImageSibling
*
>
targets
;
}
;
class
Image
final
:
public
gl
:
:
RefCountObject
{
public
:
Image
(
rx
:
:
EGLImplFactory
*
factory
EGLenum
target
ImageSibling
*
buffer
const
AttributeMap
&
attribs
)
;
gl
:
:
Error
onDestroy
(
const
gl
:
:
Context
*
context
)
override
;
~
Image
(
)
;
const
gl
:
:
Format
&
getFormat
(
)
const
;
size_t
getWidth
(
)
const
;
size_t
getHeight
(
)
const
;
size_t
getSamples
(
)
const
;
Error
initialize
(
)
;
rx
:
:
ImageImpl
*
getImplementation
(
)
const
;
private
:
friend
class
ImageSibling
;
void
addTargetSibling
(
ImageSibling
*
sibling
)
;
gl
:
:
Error
orphanSibling
(
const
gl
:
:
Context
*
context
ImageSibling
*
sibling
)
;
ImageState
mState
;
rx
:
:
ImageImpl
*
mImplementation
;
}
;
}
#
endif
