#
include
"
libANGLE
/
VaryingPacking
.
h
"
#
include
"
common
/
utilities
.
h
"
#
include
"
libANGLE
/
Program
.
h
"
namespace
gl
{
VaryingPacking
:
:
VaryingPacking
(
GLuint
maxVaryingVectors
PackMode
packMode
)
:
mRegisterMap
(
maxVaryingVectors
)
mPackMode
(
packMode
)
{
}
bool
VaryingPacking
:
:
packVarying
(
const
PackedVarying
&
packedVarying
)
{
const
auto
&
varying
=
*
packedVarying
.
varying
;
ASSERT
(
!
varying
.
isStruct
(
)
)
;
GLenum
transposedType
=
gl
:
:
TransposeMatrixType
(
varying
.
type
)
;
unsigned
int
varyingRows
=
gl
:
:
VariableRowCount
(
transposedType
)
;
unsigned
int
varyingColumns
=
gl
:
:
VariableColumnCount
(
transposedType
)
;
if
(
mPackMode
=
=
PackMode
:
:
WEBGL_STRICT
&
&
varying
.
type
=
=
GL_FLOAT_MAT2
)
{
varyingColumns
=
4
;
}
varyingRows
*
=
(
packedVarying
.
isArrayElement
(
)
?
1
:
varying
.
elementCount
(
)
)
;
unsigned
int
maxVaryingVectors
=
static_cast
<
unsigned
int
>
(
mRegisterMap
.
size
(
)
)
;
if
(
varyingRows
>
maxVaryingVectors
)
{
return
false
;
}
if
(
varyingColumns
>
=
2
&
&
varyingColumns
<
=
4
)
{
for
(
unsigned
int
row
=
0
;
row
<
=
maxVaryingVectors
-
varyingRows
;
+
+
row
)
{
if
(
isFree
(
row
0
varyingRows
varyingColumns
)
)
{
insert
(
row
0
packedVarying
)
;
return
true
;
}
}
if
(
varyingColumns
=
=
2
)
{
for
(
unsigned
int
r
=
maxVaryingVectors
-
varyingRows
+
1
;
r
-
-
>
=
1
;
)
{
if
(
isFree
(
r
2
varyingRows
2
)
)
{
insert
(
r
2
packedVarying
)
;
return
true
;
}
}
}
return
false
;
}
ASSERT
(
varyingColumns
=
=
1
)
;
unsigned
int
contiguousSpace
[
4
]
=
{
0
}
;
unsigned
int
bestContiguousSpace
[
4
]
=
{
0
}
;
unsigned
int
totalSpace
[
4
]
=
{
0
}
;
for
(
unsigned
int
row
=
0
;
row
<
maxVaryingVectors
;
+
+
row
)
{
for
(
unsigned
int
column
=
0
;
column
<
4
;
+
+
column
)
{
if
(
mRegisterMap
[
row
]
[
column
]
)
{
contiguousSpace
[
column
]
=
0
;
}
else
{
contiguousSpace
[
column
]
+
+
;
totalSpace
[
column
]
+
+
;
if
(
contiguousSpace
[
column
]
>
bestContiguousSpace
[
column
]
)
{
bestContiguousSpace
[
column
]
=
contiguousSpace
[
column
]
;
}
}
}
}
unsigned
int
bestColumn
=
0
;
for
(
unsigned
int
column
=
1
;
column
<
4
;
+
+
column
)
{
if
(
bestContiguousSpace
[
column
]
>
=
varyingRows
&
&
(
bestContiguousSpace
[
bestColumn
]
<
varyingRows
|
|
totalSpace
[
column
]
<
totalSpace
[
bestColumn
]
)
)
{
bestColumn
=
column
;
}
}
if
(
bestContiguousSpace
[
bestColumn
]
>
=
varyingRows
)
{
for
(
unsigned
int
row
=
0
;
row
<
maxVaryingVectors
;
row
+
+
)
{
if
(
isFree
(
row
bestColumn
varyingRows
1
)
)
{
for
(
unsigned
int
arrayIndex
=
0
;
arrayIndex
<
varyingRows
;
+
+
arrayIndex
)
{
PackedVaryingRegister
registerInfo
;
registerInfo
.
packedVarying
=
&
packedVarying
;
registerInfo
.
registerRow
=
row
+
arrayIndex
;
registerInfo
.
registerColumn
=
bestColumn
;
registerInfo
.
varyingArrayIndex
=
(
packedVarying
.
isArrayElement
(
)
?
packedVarying
.
arrayIndex
:
arrayIndex
)
;
registerInfo
.
varyingRowIndex
=
0
;
if
(
!
packedVarying
.
varying
-
>
isBuiltIn
(
)
)
{
mRegisterList
.
push_back
(
registerInfo
)
;
}
mRegisterMap
[
row
+
arrayIndex
]
[
bestColumn
]
=
true
;
}
break
;
}
}
return
true
;
}
return
false
;
}
bool
VaryingPacking
:
:
isFree
(
unsigned
int
registerRow
unsigned
int
registerColumn
unsigned
int
varyingRows
unsigned
int
varyingColumns
)
const
{
for
(
unsigned
int
row
=
0
;
row
<
varyingRows
;
+
+
row
)
{
ASSERT
(
registerRow
+
row
<
mRegisterMap
.
size
(
)
)
;
for
(
unsigned
int
column
=
0
;
column
<
varyingColumns
;
+
+
column
)
{
ASSERT
(
registerColumn
+
column
<
4
)
;
if
(
mRegisterMap
[
registerRow
+
row
]
[
registerColumn
+
column
]
)
{
return
false
;
}
}
}
return
true
;
}
void
VaryingPacking
:
:
insert
(
unsigned
int
registerRow
unsigned
int
registerColumn
const
PackedVarying
&
packedVarying
)
{
unsigned
int
varyingRows
=
0
;
unsigned
int
varyingColumns
=
0
;
const
auto
&
varying
=
*
packedVarying
.
varying
;
ASSERT
(
!
varying
.
isStruct
(
)
)
;
GLenum
transposedType
=
gl
:
:
TransposeMatrixType
(
varying
.
type
)
;
varyingRows
=
gl
:
:
VariableRowCount
(
transposedType
)
;
varyingColumns
=
gl
:
:
VariableColumnCount
(
transposedType
)
;
PackedVaryingRegister
registerInfo
;
registerInfo
.
packedVarying
=
&
packedVarying
;
registerInfo
.
registerColumn
=
registerColumn
;
for
(
unsigned
int
arrayElement
=
0
;
arrayElement
<
varying
.
elementCount
(
)
;
+
+
arrayElement
)
{
if
(
packedVarying
.
isArrayElement
(
)
&
&
arrayElement
!
=
packedVarying
.
arrayIndex
)
{
continue
;
}
for
(
unsigned
int
varyingRow
=
0
;
varyingRow
<
varyingRows
;
+
+
varyingRow
)
{
registerInfo
.
registerRow
=
registerRow
+
(
arrayElement
*
varyingRows
)
+
varyingRow
;
registerInfo
.
varyingRowIndex
=
varyingRow
;
registerInfo
.
varyingArrayIndex
=
arrayElement
;
if
(
!
packedVarying
.
varying
-
>
isBuiltIn
(
)
)
{
mRegisterList
.
push_back
(
registerInfo
)
;
}
for
(
unsigned
int
columnIndex
=
0
;
columnIndex
<
varyingColumns
;
+
+
columnIndex
)
{
mRegisterMap
[
registerInfo
.
registerRow
]
[
registerColumn
+
columnIndex
]
=
true
;
}
}
}
}
bool
VaryingPacking
:
:
packUserVaryings
(
gl
:
:
InfoLog
&
infoLog
const
std
:
:
vector
<
PackedVarying
>
&
packedVaryings
const
std
:
:
vector
<
std
:
:
string
>
&
transformFeedbackVaryings
)
{
std
:
:
set
<
std
:
:
string
>
uniqueVaryingNames
;
for
(
const
PackedVarying
&
packedVarying
:
packedVaryings
)
{
const
auto
&
varying
=
*
packedVarying
.
varying
;
if
(
!
varying
.
staticUse
&
&
!
packedVarying
.
isStructField
(
)
)
{
continue
;
}
ASSERT
(
!
varying
.
isStruct
(
)
)
;
ASSERT
(
uniqueVaryingNames
.
count
(
packedVarying
.
nameWithArrayIndex
(
)
)
=
=
0
)
;
if
(
packVarying
(
packedVarying
)
)
{
uniqueVaryingNames
.
insert
(
packedVarying
.
nameWithArrayIndex
(
)
)
;
}
else
{
infoLog
<
<
"
Could
not
pack
varying
"
<
<
packedVarying
.
nameWithArrayIndex
(
)
;
return
false
;
}
}
for
(
const
std
:
:
string
&
transformFeedbackVaryingName
:
transformFeedbackVaryings
)
{
size_t
subscript
=
GL_INVALID_INDEX
;
std
:
:
string
tfVaryingBaseName
=
ParseResourceName
(
transformFeedbackVaryingName
&
subscript
)
;
bool
found
=
(
uniqueVaryingNames
.
count
(
transformFeedbackVaryingName
)
>
0
|
|
uniqueVaryingNames
.
count
(
tfVaryingBaseName
)
>
0
)
;
if
(
!
found
)
{
for
(
const
PackedVarying
&
packedVarying
:
packedVaryings
)
{
const
auto
&
varying
=
*
packedVarying
.
varying
;
if
(
tfVaryingBaseName
=
=
varying
.
name
)
{
if
(
transformFeedbackVaryingName
.
compare
(
0
3
"
gl_
"
)
!
=
0
)
{
if
(
!
packVarying
(
packedVarying
)
)
{
infoLog
<
<
"
Could
not
pack
varying
"
<
<
varying
.
name
;
return
false
;
}
uniqueVaryingNames
.
insert
(
packedVarying
.
nameWithArrayIndex
(
)
)
;
}
found
=
true
;
break
;
}
}
}
if
(
!
found
)
{
infoLog
<
<
"
Transform
feedback
varying
"
<
<
transformFeedbackVaryingName
<
<
"
does
not
exist
in
the
vertex
shader
.
"
;
return
false
;
}
}
std
:
:
sort
(
mRegisterList
.
begin
(
)
mRegisterList
.
end
(
)
)
;
for
(
unsigned
int
semanticIndex
=
0
;
semanticIndex
<
static_cast
<
unsigned
int
>
(
mRegisterList
.
size
(
)
)
;
+
+
semanticIndex
)
{
mRegisterList
[
semanticIndex
]
.
semanticIndex
=
semanticIndex
;
}
return
true
;
}
unsigned
int
VaryingPacking
:
:
getRegisterCount
(
)
const
{
unsigned
int
count
=
0
;
for
(
const
Register
&
reg
:
mRegisterMap
)
{
if
(
reg
.
data
[
0
]
|
|
reg
.
data
[
1
]
|
|
reg
.
data
[
2
]
|
|
reg
.
data
[
3
]
)
{
+
+
count
;
}
}
return
count
;
}
}
