#
include
"
libANGLE
/
renderer
/
gl
/
wgl
/
WindowSurfaceWGL
.
h
"
#
include
"
common
/
debug
.
h
"
#
include
"
libANGLE
/
renderer
/
gl
/
RendererGL
.
h
"
#
include
"
libANGLE
/
renderer
/
gl
/
wgl
/
FunctionsWGL
.
h
"
#
include
"
libANGLE
/
renderer
/
gl
/
wgl
/
wgl_utils
.
h
"
namespace
rx
{
WindowSurfaceWGL
:
:
WindowSurfaceWGL
(
const
egl
:
:
SurfaceState
&
state
RendererGL
*
renderer
EGLNativeWindowType
window
int
pixelFormat
const
FunctionsWGL
*
functions
EGLint
orientation
)
:
SurfaceWGL
(
state
renderer
)
mPixelFormat
(
pixelFormat
)
mWindow
(
window
)
mDeviceContext
(
nullptr
)
mFunctionsWGL
(
functions
)
mSwapBehavior
(
0
)
{
ASSERT
(
orientation
=
=
0
)
;
}
WindowSurfaceWGL
:
:
~
WindowSurfaceWGL
(
)
{
ReleaseDC
(
mWindow
mDeviceContext
)
;
mDeviceContext
=
nullptr
;
}
egl
:
:
Error
WindowSurfaceWGL
:
:
initialize
(
const
egl
:
:
Display
*
display
)
{
mDeviceContext
=
GetDC
(
mWindow
)
;
if
(
!
mDeviceContext
)
{
return
egl
:
:
EglBadNativeWindow
(
)
<
<
"
Failed
to
get
the
device
context
from
the
native
window
"
<
<
gl
:
:
FmtErr
(
GetLastError
(
)
)
;
}
int
windowPixelFormat
=
GetPixelFormat
(
mDeviceContext
)
;
if
(
windowPixelFormat
=
=
0
)
{
PIXELFORMATDESCRIPTOR
pixelFormatDescriptor
=
{
0
}
;
if
(
!
DescribePixelFormat
(
mDeviceContext
mPixelFormat
sizeof
(
pixelFormatDescriptor
)
&
pixelFormatDescriptor
)
)
{
return
egl
:
:
EglBadNativeWindow
(
)
<
<
"
Failed
to
DescribePixelFormat
"
<
<
gl
:
:
FmtErr
(
GetLastError
(
)
)
;
}
if
(
!
SetPixelFormat
(
mDeviceContext
mPixelFormat
&
pixelFormatDescriptor
)
)
{
return
egl
:
:
EglNotInitialized
(
)
<
<
"
Failed
to
set
the
pixel
format
on
the
device
context
"
<
<
gl
:
:
FmtErr
(
GetLastError
(
)
)
;
}
}
else
if
(
windowPixelFormat
!
=
mPixelFormat
)
{
return
egl
:
:
EglNotInitialized
(
)
<
<
"
Pixel
format
of
the
NativeWindow
and
NativeDisplayType
must
match
.
"
;
}
switch
(
wgl
:
:
QueryWGLFormatAttrib
(
mDeviceContext
mPixelFormat
WGL_SWAP_METHOD_ARB
mFunctionsWGL
)
)
{
case
WGL_SWAP_COPY_ARB
:
mSwapBehavior
=
EGL_BUFFER_PRESERVED
;
break
;
case
WGL_SWAP_EXCHANGE_ARB
:
case
WGL_SWAP_UNDEFINED_ARB
:
default
:
mSwapBehavior
=
EGL_BUFFER_DESTROYED
;
break
;
}
return
egl
:
:
NoError
(
)
;
}
egl
:
:
Error
WindowSurfaceWGL
:
:
makeCurrent
(
)
{
return
egl
:
:
NoError
(
)
;
}
egl
:
:
Error
WindowSurfaceWGL
:
:
swap
(
const
gl
:
:
Context
*
context
)
{
if
(
!
mFunctionsWGL
-
>
swapBuffers
(
mDeviceContext
)
)
{
return
egl
:
:
EglContextLost
(
)
<
<
"
Failed
to
swap
buffers
on
the
child
window
.
"
;
}
return
egl
:
:
NoError
(
)
;
}
egl
:
:
Error
WindowSurfaceWGL
:
:
postSubBuffer
(
const
gl
:
:
Context
*
context
EGLint
x
EGLint
y
EGLint
width
EGLint
height
)
{
UNIMPLEMENTED
(
)
;
return
egl
:
:
NoError
(
)
;
}
egl
:
:
Error
WindowSurfaceWGL
:
:
querySurfacePointerANGLE
(
EGLint
attribute
void
*
*
value
)
{
*
value
=
nullptr
;
return
egl
:
:
NoError
(
)
;
}
egl
:
:
Error
WindowSurfaceWGL
:
:
bindTexImage
(
gl
:
:
Texture
*
texture
EGLint
buffer
)
{
UNIMPLEMENTED
(
)
;
return
egl
:
:
NoError
(
)
;
}
egl
:
:
Error
WindowSurfaceWGL
:
:
releaseTexImage
(
EGLint
buffer
)
{
UNIMPLEMENTED
(
)
;
return
egl
:
:
NoError
(
)
;
}
void
WindowSurfaceWGL
:
:
setSwapInterval
(
EGLint
interval
)
{
if
(
mFunctionsWGL
-
>
swapIntervalEXT
)
{
mFunctionsWGL
-
>
swapIntervalEXT
(
interval
)
;
}
}
EGLint
WindowSurfaceWGL
:
:
getWidth
(
)
const
{
RECT
rect
;
if
(
!
GetClientRect
(
mWindow
&
rect
)
)
{
return
0
;
}
return
rect
.
right
-
rect
.
left
;
}
EGLint
WindowSurfaceWGL
:
:
getHeight
(
)
const
{
RECT
rect
;
if
(
!
GetClientRect
(
mWindow
&
rect
)
)
{
return
0
;
}
return
rect
.
bottom
-
rect
.
top
;
}
EGLint
WindowSurfaceWGL
:
:
isPostSubBufferSupported
(
)
const
{
UNIMPLEMENTED
(
)
;
return
EGL_FALSE
;
}
EGLint
WindowSurfaceWGL
:
:
getSwapBehavior
(
)
const
{
return
mSwapBehavior
;
}
HDC
WindowSurfaceWGL
:
:
getDC
(
)
const
{
return
mDeviceContext
;
}
}
