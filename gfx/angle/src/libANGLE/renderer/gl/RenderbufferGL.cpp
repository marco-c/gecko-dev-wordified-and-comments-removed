#
include
"
libANGLE
/
renderer
/
gl
/
RenderbufferGL
.
h
"
#
include
"
common
/
debug
.
h
"
#
include
"
libANGLE
/
Caps
.
h
"
#
include
"
libANGLE
/
angletypes
.
h
"
#
include
"
libANGLE
/
renderer
/
gl
/
FunctionsGL
.
h
"
#
include
"
libANGLE
/
renderer
/
gl
/
StateManagerGL
.
h
"
#
include
"
libANGLE
/
renderer
/
gl
/
formatutilsgl
.
h
"
#
include
"
libANGLE
/
renderer
/
gl
/
renderergl_utils
.
h
"
namespace
rx
{
RenderbufferGL
:
:
RenderbufferGL
(
const
FunctionsGL
*
functions
StateManagerGL
*
stateManager
const
gl
:
:
TextureCapsMap
&
textureCaps
)
:
RenderbufferImpl
(
)
mFunctions
(
functions
)
mStateManager
(
stateManager
)
mTextureCaps
(
textureCaps
)
mRenderbufferID
(
0
)
{
mFunctions
-
>
genRenderbuffers
(
1
&
mRenderbufferID
)
;
mStateManager
-
>
bindRenderbuffer
(
GL_RENDERBUFFER
mRenderbufferID
)
;
}
RenderbufferGL
:
:
~
RenderbufferGL
(
)
{
mStateManager
-
>
deleteRenderbuffer
(
mRenderbufferID
)
;
mRenderbufferID
=
0
;
}
gl
:
:
Error
RenderbufferGL
:
:
setStorage
(
GLenum
internalformat
size_t
width
size_t
height
)
{
mStateManager
-
>
bindRenderbuffer
(
GL_RENDERBUFFER
mRenderbufferID
)
;
const
nativegl
:
:
InternalFormat
&
nativeInternalFormatInfo
=
nativegl
:
:
GetInternalFormatInfo
(
internalformat
mFunctions
-
>
standard
)
;
mFunctions
-
>
renderbufferStorage
(
GL_RENDERBUFFER
nativeInternalFormatInfo
.
internalFormat
width
height
)
;
return
gl
:
:
Error
(
GL_NO_ERROR
)
;
}
gl
:
:
Error
RenderbufferGL
:
:
setStorageMultisample
(
size_t
samples
GLenum
internalformat
size_t
width
size_t
height
)
{
mStateManager
-
>
bindRenderbuffer
(
GL_RENDERBUFFER
mRenderbufferID
)
;
const
nativegl
:
:
InternalFormat
&
nativeInternalFormatInfo
=
nativegl
:
:
GetInternalFormatInfo
(
internalformat
mFunctions
-
>
standard
)
;
mFunctions
-
>
renderbufferStorageMultisample
(
GL_RENDERBUFFER
samples
nativeInternalFormatInfo
.
internalFormat
width
height
)
;
const
gl
:
:
TextureCaps
&
formatCaps
=
mTextureCaps
.
get
(
internalformat
)
;
if
(
samples
>
formatCaps
.
getMaxSamples
(
)
)
{
GLenum
error
=
GL_NO_ERROR
;
do
{
error
=
mFunctions
-
>
getError
(
)
;
if
(
error
=
=
GL_OUT_OF_MEMORY
)
{
return
gl
:
:
Error
(
GL_OUT_OF_MEMORY
)
;
}
ASSERT
(
error
=
=
GL_NO_ERROR
)
;
}
while
(
error
!
=
GL_NO_ERROR
)
;
}
return
gl
:
:
Error
(
GL_NO_ERROR
)
;
}
GLuint
RenderbufferGL
:
:
getRenderbufferID
(
)
const
{
return
mRenderbufferID
;
}
}
