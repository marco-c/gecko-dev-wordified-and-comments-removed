#
include
"
libANGLE
/
renderer
/
gl
/
ProgramGL
.
h
"
#
include
"
common
/
debug
.
h
"
#
include
"
common
/
utilities
.
h
"
#
include
"
libANGLE
/
renderer
/
gl
/
FunctionsGL
.
h
"
#
include
"
libANGLE
/
renderer
/
gl
/
ShaderGL
.
h
"
#
include
"
libANGLE
/
renderer
/
gl
/
StateManagerGL
.
h
"
#
include
"
libANGLE
/
renderer
/
gl
/
WorkaroundsGL
.
h
"
#
include
"
libANGLE
/
Uniform
.
h
"
#
include
"
platform
/
Platform
.
h
"
namespace
rx
{
ProgramGL
:
:
ProgramGL
(
const
gl
:
:
ProgramState
&
data
const
FunctionsGL
*
functions
const
WorkaroundsGL
&
workarounds
StateManagerGL
*
stateManager
)
:
ProgramImpl
(
data
)
mFunctions
(
functions
)
mWorkarounds
(
workarounds
)
mStateManager
(
stateManager
)
mProgramID
(
0
)
{
ASSERT
(
mFunctions
)
;
ASSERT
(
mStateManager
)
;
mProgramID
=
mFunctions
-
>
createProgram
(
)
;
}
ProgramGL
:
:
~
ProgramGL
(
)
{
mFunctions
-
>
deleteProgram
(
mProgramID
)
;
mProgramID
=
0
;
}
LinkResult
ProgramGL
:
:
load
(
gl
:
:
InfoLog
&
infoLog
gl
:
:
BinaryInputStream
*
stream
)
{
preLink
(
)
;
GLenum
binaryFormat
=
stream
-
>
readInt
<
GLenum
>
(
)
;
GLint
binaryLength
=
stream
-
>
readInt
<
GLint
>
(
)
;
const
uint8_t
*
binary
=
stream
-
>
data
(
)
+
stream
-
>
offset
(
)
;
stream
-
>
skip
(
binaryLength
)
;
mFunctions
-
>
programBinary
(
mProgramID
binaryFormat
binary
binaryLength
)
;
if
(
!
checkLinkStatus
(
infoLog
)
)
{
return
LinkResult
(
false
gl
:
:
Error
(
GL_NO_ERROR
)
)
;
}
postLink
(
)
;
return
LinkResult
(
true
gl
:
:
Error
(
GL_NO_ERROR
)
)
;
}
gl
:
:
Error
ProgramGL
:
:
save
(
gl
:
:
BinaryOutputStream
*
stream
)
{
GLint
binaryLength
=
0
;
mFunctions
-
>
getProgramiv
(
mProgramID
GL_PROGRAM_BINARY_LENGTH
&
binaryLength
)
;
std
:
:
vector
<
uint8_t
>
binary
(
binaryLength
)
;
GLenum
binaryFormat
=
GL_NONE
;
mFunctions
-
>
getProgramBinary
(
mProgramID
binaryLength
&
binaryLength
&
binaryFormat
&
binary
[
0
]
)
;
stream
-
>
writeInt
(
binaryFormat
)
;
stream
-
>
writeInt
(
binaryLength
)
;
stream
-
>
writeBytes
(
&
binary
[
0
]
binaryLength
)
;
return
gl
:
:
Error
(
GL_NO_ERROR
)
;
}
void
ProgramGL
:
:
setBinaryRetrievableHint
(
bool
retrievable
)
{
if
(
mFunctions
-
>
programParameteri
)
{
mFunctions
-
>
programParameteri
(
mProgramID
GL_PROGRAM_BINARY_RETRIEVABLE_HINT
retrievable
?
GL_TRUE
:
GL_FALSE
)
;
}
}
LinkResult
ProgramGL
:
:
link
(
const
gl
:
:
ContextState
&
data
gl
:
:
InfoLog
&
infoLog
)
{
preLink
(
)
;
std
:
:
vector
<
const
GLchar
*
>
transformFeedbackVaryings
;
for
(
const
auto
&
tfVarying
:
mState
.
getTransformFeedbackVaryingNames
(
)
)
{
transformFeedbackVaryings
.
push_back
(
tfVarying
.
c_str
(
)
)
;
}
if
(
transformFeedbackVaryings
.
empty
(
)
)
{
if
(
mFunctions
-
>
transformFeedbackVaryings
)
{
mFunctions
-
>
transformFeedbackVaryings
(
mProgramID
0
nullptr
mState
.
getTransformFeedbackBufferMode
(
)
)
;
}
}
else
{
ASSERT
(
mFunctions
-
>
transformFeedbackVaryings
)
;
mFunctions
-
>
transformFeedbackVaryings
(
mProgramID
static_cast
<
GLsizei
>
(
transformFeedbackVaryings
.
size
(
)
)
&
transformFeedbackVaryings
[
0
]
mState
.
getTransformFeedbackBufferMode
(
)
)
;
}
const
ShaderGL
*
vertexShaderGL
=
GetImplAs
<
ShaderGL
>
(
mState
.
getAttachedVertexShader
(
)
)
;
const
ShaderGL
*
fragmentShaderGL
=
GetImplAs
<
ShaderGL
>
(
mState
.
getAttachedFragmentShader
(
)
)
;
mFunctions
-
>
attachShader
(
mProgramID
vertexShaderGL
-
>
getShaderID
(
)
)
;
mFunctions
-
>
attachShader
(
mProgramID
fragmentShaderGL
-
>
getShaderID
(
)
)
;
for
(
const
sh
:
:
Attribute
&
attribute
:
mState
.
getAttributes
(
)
)
{
if
(
!
attribute
.
staticUse
)
{
continue
;
}
mFunctions
-
>
bindAttribLocation
(
mProgramID
attribute
.
location
attribute
.
name
.
c_str
(
)
)
;
}
mFunctions
-
>
linkProgram
(
mProgramID
)
;
mFunctions
-
>
detachShader
(
mProgramID
vertexShaderGL
-
>
getShaderID
(
)
)
;
mFunctions
-
>
detachShader
(
mProgramID
fragmentShaderGL
-
>
getShaderID
(
)
)
;
if
(
!
checkLinkStatus
(
infoLog
)
)
{
return
LinkResult
(
false
gl
:
:
Error
(
GL_NO_ERROR
)
)
;
}
if
(
mWorkarounds
.
alwaysCallUseProgramAfterLink
)
{
mStateManager
-
>
forceUseProgram
(
mProgramID
)
;
}
postLink
(
)
;
return
LinkResult
(
true
gl
:
:
Error
(
GL_NO_ERROR
)
)
;
}
GLboolean
ProgramGL
:
:
validate
(
const
gl
:
:
Caps
&
gl
:
:
InfoLog
*
)
{
return
true
;
}
void
ProgramGL
:
:
setUniform1fv
(
GLint
location
GLsizei
count
const
GLfloat
*
v
)
{
mStateManager
-
>
useProgram
(
mProgramID
)
;
mFunctions
-
>
uniform1fv
(
uniLoc
(
location
)
count
v
)
;
}
void
ProgramGL
:
:
setUniform2fv
(
GLint
location
GLsizei
count
const
GLfloat
*
v
)
{
mStateManager
-
>
useProgram
(
mProgramID
)
;
mFunctions
-
>
uniform2fv
(
uniLoc
(
location
)
count
v
)
;
}
void
ProgramGL
:
:
setUniform3fv
(
GLint
location
GLsizei
count
const
GLfloat
*
v
)
{
mStateManager
-
>
useProgram
(
mProgramID
)
;
mFunctions
-
>
uniform3fv
(
uniLoc
(
location
)
count
v
)
;
}
void
ProgramGL
:
:
setUniform4fv
(
GLint
location
GLsizei
count
const
GLfloat
*
v
)
{
mStateManager
-
>
useProgram
(
mProgramID
)
;
mFunctions
-
>
uniform4fv
(
uniLoc
(
location
)
count
v
)
;
}
void
ProgramGL
:
:
setUniform1iv
(
GLint
location
GLsizei
count
const
GLint
*
v
)
{
mStateManager
-
>
useProgram
(
mProgramID
)
;
mFunctions
-
>
uniform1iv
(
uniLoc
(
location
)
count
v
)
;
const
gl
:
:
VariableLocation
&
locationEntry
=
mState
.
getUniformLocations
(
)
[
location
]
;
size_t
samplerIndex
=
mUniformIndexToSamplerIndex
[
locationEntry
.
index
]
;
if
(
samplerIndex
!
=
GL_INVALID_INDEX
)
{
std
:
:
vector
<
GLuint
>
&
boundTextureUnits
=
mSamplerBindings
[
samplerIndex
]
.
boundTextureUnits
;
size_t
copyCount
=
std
:
:
max
<
size_t
>
(
count
boundTextureUnits
.
size
(
)
-
locationEntry
.
element
)
;
std
:
:
copy
(
v
v
+
copyCount
boundTextureUnits
.
begin
(
)
+
locationEntry
.
element
)
;
}
}
void
ProgramGL
:
:
setUniform2iv
(
GLint
location
GLsizei
count
const
GLint
*
v
)
{
mStateManager
-
>
useProgram
(
mProgramID
)
;
mFunctions
-
>
uniform2iv
(
uniLoc
(
location
)
count
v
)
;
}
void
ProgramGL
:
:
setUniform3iv
(
GLint
location
GLsizei
count
const
GLint
*
v
)
{
mStateManager
-
>
useProgram
(
mProgramID
)
;
mFunctions
-
>
uniform3iv
(
uniLoc
(
location
)
count
v
)
;
}
void
ProgramGL
:
:
setUniform4iv
(
GLint
location
GLsizei
count
const
GLint
*
v
)
{
mStateManager
-
>
useProgram
(
mProgramID
)
;
mFunctions
-
>
uniform4iv
(
uniLoc
(
location
)
count
v
)
;
}
void
ProgramGL
:
:
setUniform1uiv
(
GLint
location
GLsizei
count
const
GLuint
*
v
)
{
mStateManager
-
>
useProgram
(
mProgramID
)
;
mFunctions
-
>
uniform1uiv
(
uniLoc
(
location
)
count
v
)
;
}
void
ProgramGL
:
:
setUniform2uiv
(
GLint
location
GLsizei
count
const
GLuint
*
v
)
{
mStateManager
-
>
useProgram
(
mProgramID
)
;
mFunctions
-
>
uniform2uiv
(
uniLoc
(
location
)
count
v
)
;
}
void
ProgramGL
:
:
setUniform3uiv
(
GLint
location
GLsizei
count
const
GLuint
*
v
)
{
mStateManager
-
>
useProgram
(
mProgramID
)
;
mFunctions
-
>
uniform3uiv
(
uniLoc
(
location
)
count
v
)
;
}
void
ProgramGL
:
:
setUniform4uiv
(
GLint
location
GLsizei
count
const
GLuint
*
v
)
{
mStateManager
-
>
useProgram
(
mProgramID
)
;
mFunctions
-
>
uniform4uiv
(
uniLoc
(
location
)
count
v
)
;
}
void
ProgramGL
:
:
setUniformMatrix2fv
(
GLint
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
value
)
{
mStateManager
-
>
useProgram
(
mProgramID
)
;
mFunctions
-
>
uniformMatrix2fv
(
uniLoc
(
location
)
count
transpose
value
)
;
}
void
ProgramGL
:
:
setUniformMatrix3fv
(
GLint
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
value
)
{
mStateManager
-
>
useProgram
(
mProgramID
)
;
mFunctions
-
>
uniformMatrix3fv
(
uniLoc
(
location
)
count
transpose
value
)
;
}
void
ProgramGL
:
:
setUniformMatrix4fv
(
GLint
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
value
)
{
mStateManager
-
>
useProgram
(
mProgramID
)
;
mFunctions
-
>
uniformMatrix4fv
(
uniLoc
(
location
)
count
transpose
value
)
;
}
void
ProgramGL
:
:
setUniformMatrix2x3fv
(
GLint
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
value
)
{
mStateManager
-
>
useProgram
(
mProgramID
)
;
mFunctions
-
>
uniformMatrix2x3fv
(
uniLoc
(
location
)
count
transpose
value
)
;
}
void
ProgramGL
:
:
setUniformMatrix3x2fv
(
GLint
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
value
)
{
mStateManager
-
>
useProgram
(
mProgramID
)
;
mFunctions
-
>
uniformMatrix3x2fv
(
uniLoc
(
location
)
count
transpose
value
)
;
}
void
ProgramGL
:
:
setUniformMatrix2x4fv
(
GLint
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
value
)
{
mStateManager
-
>
useProgram
(
mProgramID
)
;
mFunctions
-
>
uniformMatrix2x4fv
(
uniLoc
(
location
)
count
transpose
value
)
;
}
void
ProgramGL
:
:
setUniformMatrix4x2fv
(
GLint
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
value
)
{
mStateManager
-
>
useProgram
(
mProgramID
)
;
mFunctions
-
>
uniformMatrix4x2fv
(
uniLoc
(
location
)
count
transpose
value
)
;
}
void
ProgramGL
:
:
setUniformMatrix3x4fv
(
GLint
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
value
)
{
mStateManager
-
>
useProgram
(
mProgramID
)
;
mFunctions
-
>
uniformMatrix3x4fv
(
uniLoc
(
location
)
count
transpose
value
)
;
}
void
ProgramGL
:
:
setUniformMatrix4x3fv
(
GLint
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
value
)
{
mStateManager
-
>
useProgram
(
mProgramID
)
;
mFunctions
-
>
uniformMatrix4x3fv
(
uniLoc
(
location
)
count
transpose
value
)
;
}
void
ProgramGL
:
:
setUniformBlockBinding
(
GLuint
uniformBlockIndex
GLuint
uniformBlockBinding
)
{
if
(
mUniformBlockRealLocationMap
.
empty
(
)
)
{
mUniformBlockRealLocationMap
.
reserve
(
mState
.
getUniformBlocks
(
)
.
size
(
)
)
;
for
(
const
gl
:
:
UniformBlock
&
uniformBlock
:
mState
.
getUniformBlocks
(
)
)
{
const
std
:
:
string
&
nameWithIndex
=
uniformBlock
.
nameWithArrayIndex
(
)
;
GLuint
blockIndex
=
mFunctions
-
>
getUniformBlockIndex
(
mProgramID
nameWithIndex
.
c_str
(
)
)
;
mUniformBlockRealLocationMap
.
push_back
(
blockIndex
)
;
}
}
GLuint
realBlockIndex
=
mUniformBlockRealLocationMap
[
uniformBlockIndex
]
;
if
(
realBlockIndex
!
=
GL_INVALID_INDEX
)
{
mFunctions
-
>
uniformBlockBinding
(
mProgramID
realBlockIndex
uniformBlockBinding
)
;
}
}
GLuint
ProgramGL
:
:
getProgramID
(
)
const
{
return
mProgramID
;
}
const
std
:
:
vector
<
SamplerBindingGL
>
&
ProgramGL
:
:
getAppliedSamplerUniforms
(
)
const
{
return
mSamplerBindings
;
}
bool
ProgramGL
:
:
getUniformBlockSize
(
const
std
:
:
string
&
blockName
size_t
*
sizeOut
)
const
{
ASSERT
(
mProgramID
!
=
0u
)
;
GLuint
blockIndex
=
mFunctions
-
>
getUniformBlockIndex
(
mProgramID
blockName
.
c_str
(
)
)
;
if
(
blockIndex
=
=
GL_INVALID_INDEX
)
{
*
sizeOut
=
0
;
return
false
;
}
GLint
dataSize
=
0
;
mFunctions
-
>
getActiveUniformBlockiv
(
mProgramID
blockIndex
GL_UNIFORM_BLOCK_DATA_SIZE
&
dataSize
)
;
*
sizeOut
=
static_cast
<
size_t
>
(
dataSize
)
;
return
true
;
}
bool
ProgramGL
:
:
getUniformBlockMemberInfo
(
const
std
:
:
string
&
memberUniformName
sh
:
:
BlockMemberInfo
*
memberInfoOut
)
const
{
GLuint
uniformIndex
;
const
GLchar
*
memberNameGLStr
=
memberUniformName
.
c_str
(
)
;
mFunctions
-
>
getUniformIndices
(
mProgramID
1
&
memberNameGLStr
&
uniformIndex
)
;
if
(
uniformIndex
=
=
GL_INVALID_INDEX
)
{
*
memberInfoOut
=
sh
:
:
BlockMemberInfo
:
:
getDefaultBlockInfo
(
)
;
return
false
;
}
mFunctions
-
>
getActiveUniformsiv
(
mProgramID
1
&
uniformIndex
GL_UNIFORM_OFFSET
&
memberInfoOut
-
>
offset
)
;
mFunctions
-
>
getActiveUniformsiv
(
mProgramID
1
&
uniformIndex
GL_UNIFORM_ARRAY_STRIDE
&
memberInfoOut
-
>
arrayStride
)
;
mFunctions
-
>
getActiveUniformsiv
(
mProgramID
1
&
uniformIndex
GL_UNIFORM_MATRIX_STRIDE
&
memberInfoOut
-
>
matrixStride
)
;
GLint
isRowMajorMatrix
=
0
;
mFunctions
-
>
getActiveUniformsiv
(
mProgramID
1
&
uniformIndex
GL_UNIFORM_IS_ROW_MAJOR
&
isRowMajorMatrix
)
;
memberInfoOut
-
>
isRowMajorMatrix
=
isRowMajorMatrix
!
=
GL_FALSE
;
return
true
;
}
void
ProgramGL
:
:
preLink
(
)
{
mUniformRealLocationMap
.
clear
(
)
;
mUniformBlockRealLocationMap
.
clear
(
)
;
mSamplerBindings
.
clear
(
)
;
mUniformIndexToSamplerIndex
.
clear
(
)
;
}
bool
ProgramGL
:
:
checkLinkStatus
(
gl
:
:
InfoLog
&
infoLog
)
{
GLint
linkStatus
=
GL_FALSE
;
mFunctions
-
>
getProgramiv
(
mProgramID
GL_LINK_STATUS
&
linkStatus
)
;
if
(
linkStatus
=
=
GL_FALSE
)
{
GLint
infoLogLength
=
0
;
mFunctions
-
>
getProgramiv
(
mProgramID
GL_INFO_LOG_LENGTH
&
infoLogLength
)
;
std
:
:
string
warning
;
if
(
infoLogLength
>
1
)
{
std
:
:
vector
<
char
>
buf
(
infoLogLength
)
;
mFunctions
-
>
getProgramInfoLog
(
mProgramID
infoLogLength
nullptr
&
buf
[
0
]
)
;
mFunctions
-
>
deleteProgram
(
mProgramID
)
;
mProgramID
=
0
;
infoLog
<
<
buf
.
data
(
)
;
warning
=
FormatString
(
"
Program
link
failed
unexpectedly
:
%
s
"
buf
.
data
(
)
)
;
}
else
{
warning
=
"
Program
link
failed
unexpectedly
with
no
info
log
.
"
;
}
ANGLEPlatformCurrent
(
)
-
>
logWarning
(
warning
.
c_str
(
)
)
;
TRACE
(
"
\
n
%
s
"
warning
.
c_str
(
)
)
;
return
false
;
}
return
true
;
}
void
ProgramGL
:
:
postLink
(
)
{
ASSERT
(
mUniformRealLocationMap
.
empty
(
)
)
;
const
auto
&
uniformLocations
=
mState
.
getUniformLocations
(
)
;
const
auto
&
uniforms
=
mState
.
getUniforms
(
)
;
mUniformRealLocationMap
.
resize
(
uniformLocations
.
size
(
)
GL_INVALID_INDEX
)
;
for
(
size_t
uniformLocation
=
0
;
uniformLocation
<
uniformLocations
.
size
(
)
;
uniformLocation
+
+
)
{
const
auto
&
entry
=
uniformLocations
[
uniformLocation
]
;
if
(
!
entry
.
used
)
{
continue
;
}
const
gl
:
:
LinkedUniform
&
uniform
=
uniforms
[
entry
.
index
]
;
std
:
:
stringstream
fullNameStr
;
fullNameStr
<
<
uniform
.
name
;
if
(
uniform
.
isArray
(
)
)
{
fullNameStr
<
<
"
[
"
<
<
entry
.
element
<
<
"
]
"
;
}
const
std
:
:
string
&
fullName
=
fullNameStr
.
str
(
)
;
GLint
realLocation
=
mFunctions
-
>
getUniformLocation
(
mProgramID
fullName
.
c_str
(
)
)
;
mUniformRealLocationMap
[
uniformLocation
]
=
realLocation
;
}
mUniformIndexToSamplerIndex
.
resize
(
mState
.
getUniforms
(
)
.
size
(
)
GL_INVALID_INDEX
)
;
for
(
size_t
uniformId
=
0
;
uniformId
<
uniforms
.
size
(
)
;
+
+
uniformId
)
{
const
gl
:
:
LinkedUniform
&
linkedUniform
=
uniforms
[
uniformId
]
;
if
(
!
linkedUniform
.
isSampler
(
)
|
|
!
linkedUniform
.
staticUse
)
continue
;
mUniformIndexToSamplerIndex
[
uniformId
]
=
mSamplerBindings
.
size
(
)
;
SamplerBindingGL
samplerBinding
;
samplerBinding
.
textureType
=
gl
:
:
SamplerTypeToTextureType
(
linkedUniform
.
type
)
;
samplerBinding
.
boundTextureUnits
.
resize
(
linkedUniform
.
elementCount
(
)
0
)
;
mSamplerBindings
.
push_back
(
samplerBinding
)
;
}
}
}
