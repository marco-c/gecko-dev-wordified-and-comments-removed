#
include
"
libANGLE
/
renderer
/
gl
/
glx
/
WindowSurfaceGLX
.
h
"
#
include
"
common
/
debug
.
h
"
#
include
"
libANGLE
/
renderer
/
gl
/
glx
/
DisplayGLX
.
h
"
#
include
"
libANGLE
/
renderer
/
gl
/
glx
/
FunctionsGLX
.
h
"
namespace
rx
{
WindowSurfaceGLX
:
:
WindowSurfaceGLX
(
const
FunctionsGLX
&
glx
DisplayGLX
*
glxDisplay
RendererGL
*
renderer
Window
window
Display
*
display
glx
:
:
Context
context
glx
:
:
FBConfig
fbConfig
)
:
SurfaceGL
(
renderer
)
mParent
(
window
)
mWindow
(
0
)
mDisplay
(
display
)
mGLX
(
glx
)
mGLXDisplay
(
*
glxDisplay
)
mContext
(
context
)
mFBConfig
(
fbConfig
)
mGLXWindow
(
0
)
mMaxSwapInterval
(
1
)
{
}
WindowSurfaceGLX
:
:
~
WindowSurfaceGLX
(
)
{
if
(
mGLXWindow
)
{
mGLX
.
destroyWindow
(
mGLXWindow
)
;
}
if
(
mWindow
)
{
XDestroyWindow
(
mDisplay
mWindow
)
;
}
mGLXDisplay
.
syncXCommands
(
)
;
}
egl
:
:
Error
WindowSurfaceGLX
:
:
initialize
(
)
{
XVisualInfo
*
visualInfo
=
mGLX
.
getVisualFromFBConfig
(
mFBConfig
)
;
if
(
!
visualInfo
)
{
return
egl
:
:
Error
(
EGL_BAD_NATIVE_WINDOW
"
Failed
to
get
the
XVisualInfo
for
the
child
window
.
"
)
;
}
Visual
*
visual
=
visualInfo
-
>
visual
;
if
(
!
getWindowDimensions
(
mParent
&
mParentWidth
&
mParentHeight
)
)
{
return
egl
:
:
Error
(
EGL_BAD_NATIVE_WINDOW
"
Failed
to
get
the
parent
window
'
s
dimensions
.
"
)
;
}
XSetWindowAttributes
attributes
;
unsigned
long
attributeMask
=
CWColormap
|
CWBorderPixel
;
Colormap
colormap
=
XCreateColormap
(
mDisplay
mParent
visual
AllocNone
)
;
if
(
!
colormap
)
{
XFree
(
visualInfo
)
;
return
egl
:
:
Error
(
EGL_BAD_NATIVE_WINDOW
"
Failed
to
create
the
Colormap
for
the
child
window
.
"
)
;
}
attributes
.
colormap
=
colormap
;
attributes
.
border_pixel
=
0
;
mWindow
=
XCreateWindow
(
mDisplay
mParent
0
0
mParentWidth
mParentHeight
0
visualInfo
-
>
depth
InputOutput
visual
attributeMask
&
attributes
)
;
mGLXWindow
=
mGLX
.
createWindow
(
mFBConfig
mWindow
nullptr
)
;
if
(
mGLX
.
hasExtension
(
"
GLX_EXT_swap_control
"
)
)
{
mGLX
.
queryDrawable
(
mGLXWindow
GLX_MAX_SWAP_INTERVAL_EXT
&
mMaxSwapInterval
)
;
}
XMapWindow
(
mDisplay
mWindow
)
;
XFlush
(
mDisplay
)
;
XFree
(
visualInfo
)
;
XFreeColormap
(
mDisplay
colormap
)
;
mGLXDisplay
.
syncXCommands
(
)
;
return
egl
:
:
Error
(
EGL_SUCCESS
)
;
}
egl
:
:
Error
WindowSurfaceGLX
:
:
makeCurrent
(
)
{
if
(
mGLX
.
makeCurrent
(
mGLXWindow
mContext
)
!
=
True
)
{
return
egl
:
:
Error
(
EGL_BAD_DISPLAY
)
;
}
return
egl
:
:
Error
(
EGL_SUCCESS
)
;
}
egl
:
:
Error
WindowSurfaceGLX
:
:
swap
(
)
{
unsigned
int
newParentWidth
newParentHeight
;
if
(
!
getWindowDimensions
(
mParent
&
newParentWidth
&
newParentHeight
)
)
{
return
egl
:
:
Error
(
EGL_BAD_CURRENT_SURFACE
"
Failed
to
retrieve
the
size
of
the
parent
window
.
"
)
;
}
if
(
mParentWidth
!
=
newParentWidth
|
|
mParentHeight
!
=
newParentHeight
)
{
mParentWidth
=
newParentWidth
;
mParentHeight
=
newParentHeight
;
mGLX
.
waitGL
(
)
;
XResizeWindow
(
mDisplay
mWindow
mParentWidth
mParentHeight
)
;
mGLX
.
waitX
(
)
;
}
mGLX
.
swapBuffers
(
mGLXWindow
)
;
return
egl
:
:
Error
(
EGL_SUCCESS
)
;
}
egl
:
:
Error
WindowSurfaceGLX
:
:
postSubBuffer
(
EGLint
x
EGLint
y
EGLint
width
EGLint
height
)
{
UNIMPLEMENTED
(
)
;
return
egl
:
:
Error
(
EGL_SUCCESS
)
;
}
egl
:
:
Error
WindowSurfaceGLX
:
:
querySurfacePointerANGLE
(
EGLint
attribute
void
*
*
value
)
{
UNIMPLEMENTED
(
)
;
return
egl
:
:
Error
(
EGL_SUCCESS
)
;
}
egl
:
:
Error
WindowSurfaceGLX
:
:
bindTexImage
(
EGLint
buffer
)
{
UNIMPLEMENTED
(
)
;
return
egl
:
:
Error
(
EGL_SUCCESS
)
;
}
egl
:
:
Error
WindowSurfaceGLX
:
:
releaseTexImage
(
EGLint
buffer
)
{
UNIMPLEMENTED
(
)
;
return
egl
:
:
Error
(
EGL_SUCCESS
)
;
}
void
WindowSurfaceGLX
:
:
setSwapInterval
(
EGLint
interval
)
{
if
(
mGLX
.
hasExtension
(
"
GLX_EXT_swap_control
"
)
)
{
const
int
realInterval
=
std
:
:
min
(
interval
static_cast
<
int
>
(
mMaxSwapInterval
)
)
;
mGLX
.
swapIntervalEXT
(
mGLXWindow
realInterval
)
;
}
}
EGLint
WindowSurfaceGLX
:
:
getWidth
(
)
const
{
return
mParentWidth
;
}
EGLint
WindowSurfaceGLX
:
:
getHeight
(
)
const
{
return
mParentHeight
;
}
EGLint
WindowSurfaceGLX
:
:
isPostSubBufferSupported
(
)
const
{
UNIMPLEMENTED
(
)
;
return
EGL_FALSE
;
}
EGLint
WindowSurfaceGLX
:
:
getSwapBehavior
(
)
const
{
return
EGL_BUFFER_PRESERVED
;
}
bool
WindowSurfaceGLX
:
:
getWindowDimensions
(
Window
window
unsigned
int
*
width
unsigned
int
*
height
)
const
{
Window
root
;
int
x
y
;
unsigned
int
border
depth
;
return
XGetGeometry
(
mDisplay
window
&
root
&
x
&
y
width
height
&
border
&
depth
)
!
=
0
;
}
}
