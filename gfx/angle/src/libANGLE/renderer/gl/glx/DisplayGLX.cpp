#
include
"
libANGLE
/
renderer
/
gl
/
glx
/
DisplayGLX
.
h
"
#
include
<
EGL
/
eglext
.
h
>
#
include
<
algorithm
>
#
include
"
common
/
debug
.
h
"
#
include
"
libANGLE
/
Config
.
h
"
#
include
"
libANGLE
/
Display
.
h
"
#
include
"
libANGLE
/
Surface
.
h
"
#
include
"
libANGLE
/
renderer
/
gl
/
glx
/
PbufferSurfaceGLX
.
h
"
#
include
"
libANGLE
/
renderer
/
gl
/
glx
/
WindowSurfaceGLX
.
h
"
#
include
"
libANGLE
/
renderer
/
gl
/
renderergl_utils
.
h
"
namespace
rx
{
static
int
IgnoreX11Errors
(
Display
*
XErrorEvent
*
)
{
return
0
;
}
SwapControlData
:
:
SwapControlData
(
)
:
targetSwapInterval
(
0
)
maxSwapInterval
(
-
1
)
currentSwapInterval
(
-
1
)
{
}
class
FunctionsGLGLX
:
public
FunctionsGL
{
public
:
FunctionsGLGLX
(
PFNGETPROCPROC
getProc
)
:
mGetProc
(
getProc
)
{
}
~
FunctionsGLGLX
(
)
override
{
}
private
:
void
*
loadProcAddress
(
const
std
:
:
string
&
function
)
override
{
return
reinterpret_cast
<
void
*
>
(
mGetProc
(
function
.
c_str
(
)
)
)
;
}
PFNGETPROCPROC
mGetProc
;
}
;
DisplayGLX
:
:
DisplayGLX
(
)
:
DisplayGL
(
)
mFunctionsGL
(
nullptr
)
mRequestedVisual
(
-
1
)
mContextConfig
(
nullptr
)
mContext
(
nullptr
)
mDummyPbuffer
(
0
)
mUsesNewXDisplay
(
false
)
mIsMesa
(
false
)
mHasMultisample
(
false
)
mHasARBCreateContext
(
false
)
mHasARBCreateContextProfile
(
false
)
mHasEXTCreateContextES2Profile
(
false
)
mSwapControl
(
SwapControl
:
:
Absent
)
mMinSwapInterval
(
0
)
mMaxSwapInterval
(
0
)
mCurrentSwapInterval
(
-
1
)
mEGLDisplay
(
nullptr
)
{
}
DisplayGLX
:
:
~
DisplayGLX
(
)
{
}
egl
:
:
Error
DisplayGLX
:
:
initialize
(
egl
:
:
Display
*
display
)
{
mEGLDisplay
=
display
;
Display
*
xDisplay
=
display
-
>
getNativeDisplayId
(
)
;
const
auto
&
attribMap
=
display
-
>
getAttributeMap
(
)
;
if
(
xDisplay
=
=
EGL_DEFAULT_DISPLAY
)
{
mUsesNewXDisplay
=
true
;
xDisplay
=
XOpenDisplay
(
NULL
)
;
if
(
!
xDisplay
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Could
not
open
the
default
X
display
.
"
)
;
}
}
std
:
:
string
glxInitError
;
if
(
!
mGLX
.
initialize
(
xDisplay
DefaultScreen
(
xDisplay
)
&
glxInitError
)
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
glxInitError
.
c_str
(
)
)
;
}
mHasMultisample
=
mGLX
.
minorVersion
>
3
|
|
mGLX
.
hasExtension
(
"
GLX_ARB_multisample
"
)
;
mHasARBCreateContext
=
mGLX
.
hasExtension
(
"
GLX_ARB_create_context
"
)
;
mHasARBCreateContextProfile
=
mGLX
.
hasExtension
(
"
GLX_ARB_create_context_profile
"
)
;
mHasEXTCreateContextES2Profile
=
mGLX
.
hasExtension
(
"
GLX_EXT_create_context_es2_profile
"
)
;
if
(
mGLX
.
hasExtension
(
"
GLX_EXT_swap_control
"
)
)
{
mSwapControl
=
SwapControl
:
:
EXT
;
mMinSwapInterval
=
0
;
mMaxSwapInterval
=
4
;
}
else
if
(
mGLX
.
hasExtension
(
"
GLX_MESA_swap_control
"
)
)
{
mSwapControl
=
SwapControl
:
:
Mesa
;
mMinSwapInterval
=
0
;
mMinSwapInterval
=
1
;
}
else
if
(
mGLX
.
hasExtension
(
"
GLX_SGI_swap_control
"
)
)
{
mSwapControl
=
SwapControl
:
:
SGI
;
mMinSwapInterval
=
0
;
mMinSwapInterval
=
1
;
}
else
{
mSwapControl
=
SwapControl
:
:
Absent
;
mMinSwapInterval
=
1
;
mMinSwapInterval
=
1
;
}
if
(
attribMap
.
contains
(
EGL_X11_VISUAL_ID_ANGLE
)
)
{
mRequestedVisual
=
attribMap
.
get
(
EGL_X11_VISUAL_ID_ANGLE
-
1
)
;
int
nConfigs
;
int
attribList
[
]
=
{
None
}
;
glx
:
:
FBConfig
*
allConfigs
=
mGLX
.
chooseFBConfig
(
attribList
&
nConfigs
)
;
for
(
int
i
=
0
;
i
<
nConfigs
;
+
+
i
)
{
if
(
getGLXFBConfigAttrib
(
allConfigs
[
i
]
GLX_VISUAL_ID
)
=
=
mRequestedVisual
)
{
mContextConfig
=
allConfigs
[
i
]
;
break
;
}
}
XFree
(
allConfigs
)
;
if
(
mContextConfig
=
=
nullptr
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Invalid
visual
ID
requested
.
"
)
;
}
}
else
{
int
nConfigs
;
int
attribList
[
]
=
{
GLX_RED_SIZE
8
GLX_GREEN_SIZE
8
GLX_BLUE_SIZE
8
GLX_ALPHA_SIZE
8
GLX_DEPTH_SIZE
24
GLX_STENCIL_SIZE
8
GLX_RENDER_TYPE
GLX_RGBA_BIT
GLX_DOUBLEBUFFER
True
GLX_DRAWABLE_TYPE
GLX_WINDOW_BIT
|
GLX_PBUFFER_BIT
|
GLX_PIXMAP_BIT
GLX_X_RENDERABLE
True
GLX_CONFIG_CAVEAT
GLX_NONE
None
}
;
glx
:
:
FBConfig
*
candidates
=
mGLX
.
chooseFBConfig
(
attribList
&
nConfigs
)
;
if
(
nConfigs
=
=
0
)
{
XFree
(
candidates
)
;
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Could
not
find
a
decent
GLX
FBConfig
to
create
the
context
.
"
)
;
}
mContextConfig
=
candidates
[
0
]
;
XFree
(
candidates
)
;
}
const
auto
&
eglAttributes
=
display
-
>
getAttributeMap
(
)
;
if
(
mHasARBCreateContext
)
{
egl
:
:
Error
error
=
initializeContext
(
mContextConfig
eglAttributes
&
mContext
)
;
if
(
error
.
isError
(
)
)
{
return
error
;
}
}
else
{
if
(
eglAttributes
.
get
(
EGL_PLATFORM_ANGLE_TYPE_ANGLE
EGL_PLATFORM_ANGLE_TYPE_DEFAULT_ANGLE
)
=
=
EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Cannot
create
an
OpenGL
ES
platform
on
GLX
without
the
"
"
GLX_ARB_create_context
extension
.
"
)
;
}
XVisualInfo
visualTemplate
;
visualTemplate
.
visualid
=
getGLXFBConfigAttrib
(
mContextConfig
GLX_VISUAL_ID
)
;
int
numVisuals
=
0
;
XVisualInfo
*
visuals
=
XGetVisualInfo
(
xDisplay
VisualIDMask
&
visualTemplate
&
numVisuals
)
;
if
(
numVisuals
<
=
0
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Could
not
get
the
visual
info
from
the
fb
config
"
)
;
}
ASSERT
(
numVisuals
=
=
1
)
;
mContext
=
mGLX
.
createContext
(
&
visuals
[
0
]
nullptr
true
)
;
XFree
(
visuals
)
;
if
(
!
mContext
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Could
not
create
GL
context
.
"
)
;
}
}
ASSERT
(
mContext
)
;
int
dummyPbufferAttribs
[
]
=
{
GLX_PBUFFER_WIDTH
1
GLX_PBUFFER_HEIGHT
1
None
}
;
mDummyPbuffer
=
mGLX
.
createPbuffer
(
mContextConfig
dummyPbufferAttribs
)
;
if
(
!
mDummyPbuffer
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Could
not
create
the
dummy
pbuffer
.
"
)
;
}
if
(
!
mGLX
.
makeCurrent
(
mDummyPbuffer
mContext
)
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Could
not
make
the
dummy
pbuffer
current
.
"
)
;
}
mFunctionsGL
=
new
FunctionsGLGLX
(
mGLX
.
getProc
)
;
mFunctionsGL
-
>
initialize
(
)
;
VendorID
vendor
=
GetVendorID
(
mFunctionsGL
)
;
bool
isOpenGLES
=
eglAttributes
.
get
(
EGL_PLATFORM_ANGLE_TYPE_ANGLE
EGL_PLATFORM_ANGLE_TYPE_DEFAULT_ANGLE
)
=
=
EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE
;
if
(
isOpenGLES
&
&
(
vendor
=
=
VENDOR_ID_INTEL
|
|
vendor
=
=
VENDOR_ID_NVIDIA
)
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Intel
or
NVIDIA
OpenGL
ES
drivers
are
not
supported
.
"
)
;
}
syncXCommands
(
)
;
std
:
:
string
rendererString
=
reinterpret_cast
<
const
char
*
>
(
mFunctionsGL
-
>
getString
(
GL_RENDERER
)
)
;
mIsMesa
=
rendererString
.
find
(
"
Mesa
"
)
!
=
std
:
:
string
:
:
npos
;
return
DisplayGL
:
:
initialize
(
display
)
;
}
void
DisplayGLX
:
:
terminate
(
)
{
DisplayGL
:
:
terminate
(
)
;
if
(
mDummyPbuffer
)
{
mGLX
.
destroyPbuffer
(
mDummyPbuffer
)
;
mDummyPbuffer
=
0
;
}
if
(
mContext
)
{
mGLX
.
destroyContext
(
mContext
)
;
mContext
=
nullptr
;
}
mGLX
.
terminate
(
)
;
SafeDelete
(
mFunctionsGL
)
;
}
SurfaceImpl
*
DisplayGLX
:
:
createWindowSurface
(
const
egl
:
:
Config
*
configuration
EGLNativeWindowType
window
const
egl
:
:
AttributeMap
&
attribs
)
{
ASSERT
(
configIdToGLXConfig
.
count
(
configuration
-
>
configID
)
>
0
)
;
glx
:
:
FBConfig
fbConfig
=
configIdToGLXConfig
[
configuration
-
>
configID
]
;
return
new
WindowSurfaceGLX
(
mGLX
this
this
-
>
getRenderer
(
)
window
mGLX
.
getDisplay
(
)
mContext
fbConfig
)
;
}
SurfaceImpl
*
DisplayGLX
:
:
createPbufferSurface
(
const
egl
:
:
Config
*
configuration
const
egl
:
:
AttributeMap
&
attribs
)
{
ASSERT
(
configIdToGLXConfig
.
count
(
configuration
-
>
configID
)
>
0
)
;
glx
:
:
FBConfig
fbConfig
=
configIdToGLXConfig
[
configuration
-
>
configID
]
;
EGLint
width
=
attribs
.
get
(
EGL_WIDTH
0
)
;
EGLint
height
=
attribs
.
get
(
EGL_HEIGHT
0
)
;
bool
largest
=
(
attribs
.
get
(
EGL_LARGEST_PBUFFER
EGL_FALSE
)
=
=
EGL_TRUE
)
;
return
new
PbufferSurfaceGLX
(
this
-
>
getRenderer
(
)
width
height
largest
mGLX
mContext
fbConfig
)
;
}
SurfaceImpl
*
DisplayGLX
:
:
createPbufferFromClientBuffer
(
const
egl
:
:
Config
*
configuration
EGLClientBuffer
shareHandle
const
egl
:
:
AttributeMap
&
attribs
)
{
UNIMPLEMENTED
(
)
;
return
nullptr
;
}
SurfaceImpl
*
DisplayGLX
:
:
createPixmapSurface
(
const
egl
:
:
Config
*
configuration
NativePixmapType
nativePixmap
const
egl
:
:
AttributeMap
&
attribs
)
{
UNIMPLEMENTED
(
)
;
return
nullptr
;
}
egl
:
:
Error
DisplayGLX
:
:
getDevice
(
DeviceImpl
*
*
device
)
{
UNIMPLEMENTED
(
)
;
return
egl
:
:
Error
(
EGL_BAD_DISPLAY
)
;
}
egl
:
:
Error
DisplayGLX
:
:
initializeContext
(
glx
:
:
FBConfig
config
const
egl
:
:
AttributeMap
&
eglAttributes
glx
:
:
Context
*
context
)
{
int
profileMask
=
0
;
EGLint
requestedDisplayType
=
eglAttributes
.
get
(
EGL_PLATFORM_ANGLE_TYPE_ANGLE
EGL_PLATFORM_ANGLE_TYPE_DEFAULT_ANGLE
)
;
if
(
requestedDisplayType
=
=
EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE
)
{
if
(
!
mHasEXTCreateContextES2Profile
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Cannot
create
an
OpenGL
ES
platform
on
GLX
without
the
"
"
GLX_EXT_create_context_es_profile
extension
.
"
)
;
}
ASSERT
(
mHasARBCreateContextProfile
)
;
profileMask
|
=
GLX_CONTEXT_ES2_PROFILE_BIT_EXT
;
}
gl
:
:
Version
requestedVersion
(
eglAttributes
.
get
(
EGL_PLATFORM_ANGLE_MAX_VERSION_MAJOR_ANGLE
EGL_DONT_CARE
)
eglAttributes
.
get
(
EGL_PLATFORM_ANGLE_MAX_VERSION_MINOR_ANGLE
EGL_DONT_CARE
)
)
;
if
(
static_cast
<
EGLint
>
(
requestedVersion
.
major
)
!
=
EGL_DONT_CARE
&
&
static_cast
<
EGLint
>
(
requestedVersion
.
minor
)
!
=
EGL_DONT_CARE
)
{
if
(
!
(
profileMask
&
GLX_CONTEXT_ES2_PROFILE_BIT_EXT
)
&
&
requestedVersion
>
=
gl
:
:
Version
(
3
2
)
)
{
profileMask
|
=
GLX_CONTEXT_CORE_PROFILE_BIT_ARB
;
}
return
createContextAttribs
(
config
requestedVersion
profileMask
context
)
;
}
const
gl
:
:
Version
desktopVersionsFrom3_2
[
]
=
{
gl
:
:
Version
(
4
5
)
gl
:
:
Version
(
4
4
)
gl
:
:
Version
(
4
3
)
gl
:
:
Version
(
4
2
)
gl
:
:
Version
(
4
1
)
gl
:
:
Version
(
4
0
)
gl
:
:
Version
(
3
3
)
gl
:
:
Version
(
3
2
)
}
;
const
gl
:
:
Version
desktopVersionsPre3_2
[
]
=
{
gl
:
:
Version
(
3
1
)
gl
:
:
Version
(
3
0
)
gl
:
:
Version
(
2
0
)
gl
:
:
Version
(
1
5
)
gl
:
:
Version
(
1
4
)
gl
:
:
Version
(
1
3
)
gl
:
:
Version
(
1
2
)
gl
:
:
Version
(
1
1
)
gl
:
:
Version
(
1
0
)
}
;
const
gl
:
:
Version
esVersionsFrom2_0
[
]
=
{
gl
:
:
Version
(
3
2
)
gl
:
:
Version
(
3
1
)
gl
:
:
Version
(
3
0
)
gl
:
:
Version
(
2
0
)
}
;
if
(
requestedDisplayType
!
=
EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE
)
{
for
(
auto
&
version
:
desktopVersionsFrom3_2
)
{
egl
:
:
Error
error
=
createContextAttribs
(
config
version
GLX_CONTEXT_CORE_PROFILE_BIT_ARB
context
)
;
if
(
!
error
.
isError
(
)
)
{
return
error
;
}
}
for
(
auto
&
version
:
desktopVersionsPre3_2
)
{
egl
:
:
Error
error
=
createContextAttribs
(
config
version
0
context
)
;
if
(
!
error
.
isError
(
)
)
{
return
error
;
}
}
}
if
(
requestedDisplayType
!
=
EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE
)
{
for
(
auto
&
version
:
esVersionsFrom2_0
)
{
egl
:
:
Error
error
=
createContextAttribs
(
config
version
GLX_CONTEXT_ES2_PROFILE_BIT_EXT
context
)
;
if
(
!
error
.
isError
(
)
)
{
return
error
;
}
}
}
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Could
not
create
a
backing
OpenGL
context
.
"
)
;
}
egl
:
:
ConfigSet
DisplayGLX
:
:
generateConfigs
(
)
const
{
egl
:
:
ConfigSet
configs
;
configIdToGLXConfig
.
clear
(
)
;
const
gl
:
:
Version
&
maxVersion
=
getMaxSupportedESVersion
(
)
;
ASSERT
(
maxVersion
>
=
gl
:
:
Version
(
2
0
)
)
;
bool
supportsES3
=
maxVersion
>
=
gl
:
:
Version
(
3
0
)
;
int
contextRedSize
=
getGLXFBConfigAttrib
(
mContextConfig
GLX_RED_SIZE
)
;
int
contextGreenSize
=
getGLXFBConfigAttrib
(
mContextConfig
GLX_GREEN_SIZE
)
;
int
contextBlueSize
=
getGLXFBConfigAttrib
(
mContextConfig
GLX_BLUE_SIZE
)
;
int
contextAlphaSize
=
getGLXFBConfigAttrib
(
mContextConfig
GLX_ALPHA_SIZE
)
;
int
contextDepthSize
=
getGLXFBConfigAttrib
(
mContextConfig
GLX_DEPTH_SIZE
)
;
int
contextStencilSize
=
getGLXFBConfigAttrib
(
mContextConfig
GLX_STENCIL_SIZE
)
;
int
contextSamples
=
mHasMultisample
?
getGLXFBConfigAttrib
(
mContextConfig
GLX_SAMPLES
)
:
0
;
int
contextSampleBuffers
=
mHasMultisample
?
getGLXFBConfigAttrib
(
mContextConfig
GLX_SAMPLE_BUFFERS
)
:
0
;
int
contextAccumRedSize
=
getGLXFBConfigAttrib
(
mContextConfig
GLX_ACCUM_RED_SIZE
)
;
int
contextAccumGreenSize
=
getGLXFBConfigAttrib
(
mContextConfig
GLX_ACCUM_GREEN_SIZE
)
;
int
contextAccumBlueSize
=
getGLXFBConfigAttrib
(
mContextConfig
GLX_ACCUM_BLUE_SIZE
)
;
int
contextAccumAlphaSize
=
getGLXFBConfigAttrib
(
mContextConfig
GLX_ACCUM_ALPHA_SIZE
)
;
int
attribList
[
]
=
{
GLX_RENDER_TYPE
GLX_RGBA_BIT
GLX_X_RENDERABLE
True
GLX_DOUBLEBUFFER
True
None
}
;
int
glxConfigCount
;
glx
:
:
FBConfig
*
glxConfigs
=
mGLX
.
chooseFBConfig
(
attribList
&
glxConfigCount
)
;
for
(
int
i
=
0
;
i
<
glxConfigCount
;
i
+
+
)
{
glx
:
:
FBConfig
glxConfig
=
glxConfigs
[
i
]
;
egl
:
:
Config
config
;
config
.
nativeVisualID
=
getGLXFBConfigAttrib
(
glxConfig
GLX_VISUAL_ID
)
;
config
.
nativeVisualType
=
getGLXFBConfigAttrib
(
glxConfig
GLX_X_VISUAL_TYPE
)
;
config
.
nativeRenderable
=
EGL_TRUE
;
if
(
mRequestedVisual
!
=
-
1
&
&
config
.
nativeVisualID
!
=
mRequestedVisual
)
{
continue
;
}
config
.
redSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_RED_SIZE
)
;
config
.
greenSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_GREEN_SIZE
)
;
config
.
blueSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_BLUE_SIZE
)
;
config
.
alphaSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_ALPHA_SIZE
)
;
config
.
depthSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_DEPTH_SIZE
)
;
config
.
stencilSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_STENCIL_SIZE
)
;
if
(
config
.
redSize
!
=
contextRedSize
|
|
config
.
greenSize
!
=
contextGreenSize
|
|
config
.
blueSize
!
=
contextBlueSize
|
|
config
.
alphaSize
!
=
contextAlphaSize
)
{
continue
;
}
bool
hasSameDepthStencil
=
config
.
depthSize
=
=
contextDepthSize
&
&
config
.
stencilSize
=
=
contextStencilSize
;
bool
hasNoDepthStencil
=
config
.
depthSize
=
=
0
&
&
config
.
stencilSize
=
=
0
;
if
(
!
hasSameDepthStencil
&
&
(
mIsMesa
|
|
!
hasNoDepthStencil
)
)
{
continue
;
}
config
.
colorBufferType
=
EGL_RGB_BUFFER
;
config
.
luminanceSize
=
0
;
config
.
alphaMaskSize
=
0
;
config
.
bufferSize
=
config
.
redSize
+
config
.
greenSize
+
config
.
blueSize
+
config
.
alphaSize
;
int
samples
=
mHasMultisample
?
getGLXFBConfigAttrib
(
glxConfig
GLX_SAMPLES
)
:
0
;
int
sampleBuffers
=
mHasMultisample
?
getGLXFBConfigAttrib
(
glxConfig
GLX_SAMPLE_BUFFERS
)
:
0
;
int
accumRedSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_ACCUM_RED_SIZE
)
;
int
accumGreenSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_ACCUM_GREEN_SIZE
)
;
int
accumBlueSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_ACCUM_BLUE_SIZE
)
;
int
accumAlphaSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_ACCUM_ALPHA_SIZE
)
;
if
(
samples
!
=
contextSamples
|
|
sampleBuffers
!
=
contextSampleBuffers
|
|
accumRedSize
!
=
contextAccumRedSize
|
|
accumGreenSize
!
=
contextAccumGreenSize
|
|
accumBlueSize
!
=
contextAccumBlueSize
|
|
accumAlphaSize
!
=
contextAccumAlphaSize
)
{
continue
;
}
config
.
samples
=
samples
;
config
.
sampleBuffers
=
sampleBuffers
;
if
(
getGLXFBConfigAttrib
(
glxConfig
GLX_TRANSPARENT_TYPE
)
=
=
GLX_TRANSPARENT_RGB
)
{
config
.
transparentType
=
EGL_TRANSPARENT_RGB
;
config
.
transparentRedValue
=
getGLXFBConfigAttrib
(
glxConfig
GLX_TRANSPARENT_RED_VALUE
)
;
config
.
transparentGreenValue
=
getGLXFBConfigAttrib
(
glxConfig
GLX_TRANSPARENT_GREEN_VALUE
)
;
config
.
transparentBlueValue
=
getGLXFBConfigAttrib
(
glxConfig
GLX_TRANSPARENT_BLUE_VALUE
)
;
}
else
{
config
.
transparentType
=
EGL_NONE
;
}
config
.
maxPBufferWidth
=
getGLXFBConfigAttrib
(
glxConfig
GLX_MAX_PBUFFER_WIDTH
)
;
config
.
maxPBufferHeight
=
getGLXFBConfigAttrib
(
glxConfig
GLX_MAX_PBUFFER_HEIGHT
)
;
config
.
maxPBufferPixels
=
getGLXFBConfigAttrib
(
glxConfig
GLX_MAX_PBUFFER_PIXELS
)
;
config
.
configCaveat
=
EGL_NONE
;
int
caveat
=
getGLXFBConfigAttrib
(
glxConfig
GLX_CONFIG_CAVEAT
)
;
if
(
caveat
=
=
GLX_SLOW_CONFIG
)
{
config
.
configCaveat
=
EGL_SLOW_CONFIG
;
}
else
if
(
caveat
=
=
GLX_NON_CONFORMANT_CONFIG
)
{
continue
;
}
config
.
level
=
getGLXFBConfigAttrib
(
glxConfig
GLX_LEVEL
)
;
config
.
bindToTextureRGB
=
EGL_FALSE
;
config
.
bindToTextureRGBA
=
EGL_FALSE
;
int
glxDrawable
=
getGLXFBConfigAttrib
(
glxConfig
GLX_DRAWABLE_TYPE
)
;
config
.
surfaceType
=
0
|
(
glxDrawable
&
GLX_WINDOW_BIT
?
EGL_WINDOW_BIT
:
0
)
|
(
glxDrawable
&
GLX_PBUFFER_BIT
?
EGL_PBUFFER_BIT
:
0
)
|
(
glxDrawable
&
GLX_PIXMAP_BIT
?
EGL_PIXMAP_BIT
:
0
)
;
config
.
minSwapInterval
=
mMinSwapInterval
;
config
.
maxSwapInterval
=
mMaxSwapInterval
;
config
.
renderTargetFormat
=
GL_RGBA8
;
config
.
depthStencilFormat
=
GL_DEPTH24_STENCIL8
;
config
.
conformant
=
EGL_OPENGL_ES2_BIT
|
(
supportsES3
?
EGL_OPENGL_ES3_BIT_KHR
:
0
)
;
config
.
renderableType
=
config
.
conformant
;
config
.
matchNativePixmap
=
EGL_NONE
;
int
id
=
configs
.
add
(
config
)
;
configIdToGLXConfig
[
id
]
=
glxConfig
;
}
XFree
(
glxConfigs
)
;
return
configs
;
}
bool
DisplayGLX
:
:
isDeviceLost
(
)
const
{
return
false
;
}
bool
DisplayGLX
:
:
testDeviceLost
(
)
{
return
false
;
}
egl
:
:
Error
DisplayGLX
:
:
restoreLostDevice
(
)
{
UNIMPLEMENTED
(
)
;
return
egl
:
:
Error
(
EGL_BAD_DISPLAY
)
;
}
bool
DisplayGLX
:
:
isValidNativeWindow
(
EGLNativeWindowType
window
)
const
{
Window
root
;
Window
parent
;
Window
*
children
=
nullptr
;
unsigned
nChildren
;
int
status
=
XQueryTree
(
mGLX
.
getDisplay
(
)
window
&
root
&
parent
&
children
&
nChildren
)
;
if
(
children
)
{
XFree
(
children
)
;
}
return
status
!
=
0
;
}
std
:
:
string
DisplayGLX
:
:
getVendorString
(
)
const
{
return
"
"
;
}
egl
:
:
Error
DisplayGLX
:
:
waitClient
(
)
const
{
mGLX
.
waitGL
(
)
;
return
egl
:
:
Error
(
EGL_SUCCESS
)
;
}
egl
:
:
Error
DisplayGLX
:
:
waitNative
(
EGLint
engine
egl
:
:
Surface
*
drawSurface
egl
:
:
Surface
*
readSurface
)
const
{
if
(
drawSurface
!
=
nullptr
)
{
SurfaceGLX
*
glxDrawSurface
=
GetImplAs
<
SurfaceGLX
>
(
drawSurface
)
;
egl
:
:
Error
error
=
glxDrawSurface
-
>
checkForResize
(
)
;
if
(
error
.
isError
(
)
)
{
return
error
;
}
}
if
(
readSurface
!
=
drawSurface
&
&
readSurface
!
=
nullptr
)
{
SurfaceGLX
*
glxReadSurface
=
GetImplAs
<
SurfaceGLX
>
(
readSurface
)
;
egl
:
:
Error
error
=
glxReadSurface
-
>
checkForResize
(
)
;
if
(
error
.
isError
(
)
)
{
return
error
;
}
}
mGLX
.
waitX
(
)
;
return
egl
:
:
Error
(
EGL_SUCCESS
)
;
}
void
DisplayGLX
:
:
syncXCommands
(
)
const
{
if
(
mUsesNewXDisplay
)
{
XSync
(
mGLX
.
getDisplay
(
)
False
)
;
}
}
void
DisplayGLX
:
:
setSwapInterval
(
glx
:
:
Drawable
drawable
SwapControlData
*
data
)
{
ASSERT
(
data
!
=
nullptr
)
;
if
(
mSwapControl
=
=
SwapControl
:
:
EXT
)
{
if
(
data
-
>
maxSwapInterval
<
0
)
{
unsigned
int
maxSwapInterval
=
0
;
mGLX
.
queryDrawable
(
drawable
GLX_MAX_SWAP_INTERVAL_EXT
&
maxSwapInterval
)
;
data
-
>
maxSwapInterval
=
static_cast
<
int
>
(
maxSwapInterval
)
;
}
const
int
realInterval
=
std
:
:
min
(
data
-
>
targetSwapInterval
data
-
>
maxSwapInterval
)
;
if
(
data
-
>
currentSwapInterval
!
=
realInterval
)
{
mGLX
.
swapIntervalEXT
(
drawable
realInterval
)
;
data
-
>
currentSwapInterval
=
realInterval
;
}
}
else
if
(
mCurrentSwapInterval
!
=
data
-
>
targetSwapInterval
)
{
if
(
mSwapControl
=
=
SwapControl
:
:
Mesa
)
{
mGLX
.
swapIntervalMESA
(
data
-
>
targetSwapInterval
)
;
}
else
if
(
mSwapControl
=
=
SwapControl
:
:
SGI
)
{
mGLX
.
swapIntervalSGI
(
data
-
>
targetSwapInterval
)
;
}
mCurrentSwapInterval
=
data
-
>
targetSwapInterval
;
}
}
bool
DisplayGLX
:
:
isValidWindowVisualId
(
unsigned
long
visualId
)
const
{
return
mRequestedVisual
=
=
-
1
|
|
static_cast
<
unsigned
long
>
(
mRequestedVisual
)
=
=
visualId
;
}
const
FunctionsGL
*
DisplayGLX
:
:
getFunctionsGL
(
)
const
{
return
mFunctionsGL
;
}
void
DisplayGLX
:
:
generateExtensions
(
egl
:
:
DisplayExtensions
*
outExtensions
)
const
{
outExtensions
-
>
createContext
=
true
;
outExtensions
-
>
createContextNoError
=
true
;
}
void
DisplayGLX
:
:
generateCaps
(
egl
:
:
Caps
*
outCaps
)
const
{
outCaps
-
>
textureNPOT
=
true
;
}
int
DisplayGLX
:
:
getGLXFBConfigAttrib
(
glx
:
:
FBConfig
config
int
attrib
)
const
{
int
result
;
mGLX
.
getFBConfigAttrib
(
config
attrib
&
result
)
;
return
result
;
}
egl
:
:
Error
DisplayGLX
:
:
createContextAttribs
(
glx
:
:
FBConfig
gl
:
:
Version
version
int
profileMask
glx
:
:
Context
*
context
)
const
{
std
:
:
vector
<
int
>
attribs
;
attribs
.
push_back
(
GLX_CONTEXT_MAJOR_VERSION_ARB
)
;
attribs
.
push_back
(
version
.
major
)
;
attribs
.
push_back
(
GLX_CONTEXT_MINOR_VERSION_ARB
)
;
attribs
.
push_back
(
version
.
minor
)
;
if
(
profileMask
!
=
0
&
&
mHasARBCreateContextProfile
)
{
attribs
.
push_back
(
GLX_CONTEXT_PROFILE_MASK_ARB
)
;
attribs
.
push_back
(
profileMask
)
;
}
attribs
.
push_back
(
None
)
;
auto
oldErrorHandler
=
XSetErrorHandler
(
IgnoreX11Errors
)
;
*
context
=
mGLX
.
createContextAttribsARB
(
mContextConfig
nullptr
True
attribs
.
data
(
)
)
;
XSetErrorHandler
(
oldErrorHandler
)
;
if
(
!
*
context
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Could
not
create
GL
context
.
"
)
;
}
return
egl
:
:
Error
(
EGL_SUCCESS
)
;
}
}
