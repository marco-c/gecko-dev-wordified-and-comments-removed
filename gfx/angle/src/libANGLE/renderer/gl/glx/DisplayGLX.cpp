#
include
"
libANGLE
/
renderer
/
gl
/
glx
/
DisplayGLX
.
h
"
#
include
<
EGL
/
eglext
.
h
>
#
include
<
algorithm
>
#
include
<
cstring
>
#
include
<
fstream
>
#
include
"
common
/
debug
.
h
"
#
include
"
libANGLE
/
Config
.
h
"
#
include
"
libANGLE
/
Display
.
h
"
#
include
"
libANGLE
/
Surface
.
h
"
#
include
"
libANGLE
/
renderer
/
gl
/
glx
/
PbufferSurfaceGLX
.
h
"
#
include
"
libANGLE
/
renderer
/
gl
/
glx
/
WindowSurfaceGLX
.
h
"
#
include
"
libANGLE
/
renderer
/
gl
/
RendererGL
.
h
"
#
include
"
libANGLE
/
renderer
/
gl
/
renderergl_utils
.
h
"
#
include
"
third_party
/
libXNVCtrl
/
NVCtrl
.
h
"
#
include
"
third_party
/
libXNVCtrl
/
NVCtrlLib
.
h
"
namespace
{
egl
:
:
Error
GetAMDDriverVersion
(
std
:
:
string
*
version
)
{
*
version
=
"
"
;
const
char
kAMDDriverInfoFileName
[
]
=
"
/
etc
/
ati
/
amdpcsdb
.
default
"
;
std
:
:
ifstream
file
(
kAMDDriverInfoFileName
)
;
if
(
!
file
)
{
return
egl
:
:
Error
(
EGL_SUCCESS
)
;
}
std
:
:
string
line
;
while
(
std
:
:
getline
(
file
line
)
)
{
static
const
char
kReleaseVersion
[
]
=
"
ReleaseVersion
=
"
;
if
(
line
.
compare
(
0
std
:
:
strlen
(
kReleaseVersion
)
kReleaseVersion
)
!
=
0
)
{
continue
;
}
const
size_t
begin
=
line
.
find_first_of
(
"
0123456789
"
)
;
if
(
begin
=
=
std
:
:
string
:
:
npos
)
{
continue
;
}
const
size_t
end
=
line
.
find_first_not_of
(
"
0123456789
.
"
begin
)
;
if
(
end
=
=
std
:
:
string
:
:
npos
)
{
*
version
=
line
.
substr
(
begin
)
;
}
else
{
*
version
=
line
.
substr
(
begin
end
-
begin
)
;
}
return
egl
:
:
Error
(
EGL_SUCCESS
)
;
}
return
egl
:
:
Error
(
EGL_SUCCESS
)
;
}
}
namespace
rx
{
static
int
IgnoreX11Errors
(
Display
*
XErrorEvent
*
)
{
return
0
;
}
SwapControlData
:
:
SwapControlData
(
)
:
targetSwapInterval
(
0
)
maxSwapInterval
(
-
1
)
currentSwapInterval
(
-
1
)
{
}
class
FunctionsGLGLX
:
public
FunctionsGL
{
public
:
FunctionsGLGLX
(
PFNGETPROCPROC
getProc
)
:
mGetProc
(
getProc
)
{
}
~
FunctionsGLGLX
(
)
override
{
}
private
:
void
*
loadProcAddress
(
const
std
:
:
string
&
function
)
override
{
return
reinterpret_cast
<
void
*
>
(
mGetProc
(
function
.
c_str
(
)
)
)
;
}
PFNGETPROCPROC
mGetProc
;
}
;
DisplayGLX
:
:
DisplayGLX
(
)
:
DisplayGL
(
)
mFunctionsGL
(
nullptr
)
mRequestedVisual
(
-
1
)
mContextConfig
(
nullptr
)
mContext
(
nullptr
)
mDummyPbuffer
(
0
)
mUsesNewXDisplay
(
false
)
mIsMesa
(
false
)
mHasMultisample
(
false
)
mHasARBCreateContext
(
false
)
mHasARBCreateContextProfile
(
false
)
mHasARBCreateContextRobustness
(
false
)
mHasEXTCreateContextES2Profile
(
false
)
mSwapControl
(
SwapControl
:
:
Absent
)
mMinSwapInterval
(
0
)
mMaxSwapInterval
(
0
)
mCurrentSwapInterval
(
-
1
)
mXDisplay
(
nullptr
)
mEGLDisplay
(
nullptr
)
{
}
DisplayGLX
:
:
~
DisplayGLX
(
)
{
}
egl
:
:
Error
DisplayGLX
:
:
initialize
(
egl
:
:
Display
*
display
)
{
mEGLDisplay
=
display
;
mXDisplay
=
display
-
>
getNativeDisplayId
(
)
;
const
auto
&
attribMap
=
display
-
>
getAttributeMap
(
)
;
if
(
mXDisplay
=
=
EGL_DEFAULT_DISPLAY
)
{
mUsesNewXDisplay
=
true
;
mXDisplay
=
XOpenDisplay
(
NULL
)
;
if
(
!
mXDisplay
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Could
not
open
the
default
X
display
.
"
)
;
}
}
std
:
:
string
glxInitError
;
if
(
!
mGLX
.
initialize
(
mXDisplay
DefaultScreen
(
mXDisplay
)
&
glxInitError
)
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
glxInitError
.
c_str
(
)
)
;
}
mHasMultisample
=
mGLX
.
minorVersion
>
3
|
|
mGLX
.
hasExtension
(
"
GLX_ARB_multisample
"
)
;
mHasARBCreateContext
=
mGLX
.
hasExtension
(
"
GLX_ARB_create_context
"
)
;
mHasARBCreateContextProfile
=
mGLX
.
hasExtension
(
"
GLX_ARB_create_context_profile
"
)
;
mHasARBCreateContextRobustness
=
mGLX
.
hasExtension
(
"
GLX_ARB_create_context_robustness
"
)
;
mHasEXTCreateContextES2Profile
=
mGLX
.
hasExtension
(
"
GLX_EXT_create_context_es2_profile
"
)
;
std
:
:
string
clientVendor
=
mGLX
.
getClientString
(
GLX_VENDOR
)
;
mIsMesa
=
clientVendor
.
find
(
"
Mesa
"
)
!
=
std
:
:
string
:
:
npos
;
if
(
mGLX
.
hasExtension
(
"
GLX_EXT_swap_control
"
)
)
{
mSwapControl
=
SwapControl
:
:
EXT
;
mMinSwapInterval
=
0
;
mMaxSwapInterval
=
4
;
}
else
if
(
mGLX
.
hasExtension
(
"
GLX_MESA_swap_control
"
)
)
{
mSwapControl
=
SwapControl
:
:
Mesa
;
mMinSwapInterval
=
0
;
mMinSwapInterval
=
1
;
}
else
if
(
mGLX
.
hasExtension
(
"
GLX_SGI_swap_control
"
)
)
{
mSwapControl
=
SwapControl
:
:
SGI
;
mMinSwapInterval
=
0
;
mMinSwapInterval
=
1
;
}
else
{
mSwapControl
=
SwapControl
:
:
Absent
;
mMinSwapInterval
=
1
;
mMinSwapInterval
=
1
;
}
if
(
attribMap
.
contains
(
EGL_X11_VISUAL_ID_ANGLE
)
)
{
mRequestedVisual
=
static_cast
<
EGLint
>
(
attribMap
.
get
(
EGL_X11_VISUAL_ID_ANGLE
-
1
)
)
;
int
nConfigs
;
int
attribList
[
]
=
{
None
}
;
glx
:
:
FBConfig
*
allConfigs
=
mGLX
.
chooseFBConfig
(
attribList
&
nConfigs
)
;
for
(
int
i
=
0
;
i
<
nConfigs
;
+
+
i
)
{
if
(
getGLXFBConfigAttrib
(
allConfigs
[
i
]
GLX_VISUAL_ID
)
=
=
mRequestedVisual
)
{
mContextConfig
=
allConfigs
[
i
]
;
break
;
}
}
XFree
(
allConfigs
)
;
if
(
mContextConfig
=
=
nullptr
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Invalid
visual
ID
requested
.
"
)
;
}
}
else
{
int
nConfigs
;
int
attribList
[
]
=
{
GLX_RED_SIZE
8
GLX_GREEN_SIZE
8
GLX_BLUE_SIZE
8
GLX_ALPHA_SIZE
8
GLX_DEPTH_SIZE
24
GLX_STENCIL_SIZE
8
GLX_RENDER_TYPE
GLX_RGBA_BIT
GLX_DOUBLEBUFFER
True
GLX_DRAWABLE_TYPE
GLX_WINDOW_BIT
|
GLX_PBUFFER_BIT
|
GLX_PIXMAP_BIT
GLX_X_RENDERABLE
True
GLX_CONFIG_CAVEAT
GLX_NONE
None
}
;
glx
:
:
FBConfig
*
candidates
=
mGLX
.
chooseFBConfig
(
attribList
&
nConfigs
)
;
if
(
nConfigs
=
=
0
)
{
XFree
(
candidates
)
;
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Could
not
find
a
decent
GLX
FBConfig
to
create
the
context
.
"
)
;
}
mContextConfig
=
candidates
[
0
]
;
XFree
(
candidates
)
;
}
const
auto
&
eglAttributes
=
display
-
>
getAttributeMap
(
)
;
if
(
mHasARBCreateContext
)
{
egl
:
:
Error
error
=
initializeContext
(
mContextConfig
eglAttributes
&
mContext
)
;
if
(
error
.
isError
(
)
)
{
return
error
;
}
}
else
{
if
(
eglAttributes
.
get
(
EGL_PLATFORM_ANGLE_TYPE_ANGLE
EGL_PLATFORM_ANGLE_TYPE_DEFAULT_ANGLE
)
=
=
EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Cannot
create
an
OpenGL
ES
platform
on
GLX
without
the
"
"
GLX_ARB_create_context
extension
.
"
)
;
}
XVisualInfo
visualTemplate
;
visualTemplate
.
visualid
=
getGLXFBConfigAttrib
(
mContextConfig
GLX_VISUAL_ID
)
;
int
numVisuals
=
0
;
XVisualInfo
*
visuals
=
XGetVisualInfo
(
mXDisplay
VisualIDMask
&
visualTemplate
&
numVisuals
)
;
if
(
numVisuals
<
=
0
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Could
not
get
the
visual
info
from
the
fb
config
"
)
;
}
ASSERT
(
numVisuals
=
=
1
)
;
mContext
=
mGLX
.
createContext
(
&
visuals
[
0
]
nullptr
true
)
;
XFree
(
visuals
)
;
if
(
!
mContext
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Could
not
create
GL
context
.
"
)
;
}
}
ASSERT
(
mContext
)
;
int
dummyPbufferAttribs
[
]
=
{
GLX_PBUFFER_WIDTH
1
GLX_PBUFFER_HEIGHT
1
None
}
;
mDummyPbuffer
=
mGLX
.
createPbuffer
(
mContextConfig
dummyPbufferAttribs
)
;
if
(
!
mDummyPbuffer
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Could
not
create
the
dummy
pbuffer
.
"
)
;
}
if
(
!
mGLX
.
makeCurrent
(
mDummyPbuffer
mContext
)
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Could
not
make
the
dummy
pbuffer
current
.
"
)
;
}
mFunctionsGL
=
new
FunctionsGLGLX
(
mGLX
.
getProc
)
;
mFunctionsGL
-
>
initialize
(
)
;
VendorID
vendor
=
GetVendorID
(
mFunctionsGL
)
;
bool
isOpenGLES
=
eglAttributes
.
get
(
EGL_PLATFORM_ANGLE_TYPE_ANGLE
EGL_PLATFORM_ANGLE_TYPE_DEFAULT_ANGLE
)
=
=
EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE
;
if
(
isOpenGLES
&
&
(
IsIntel
(
vendor
)
|
|
IsNvidia
(
vendor
)
)
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Intel
or
NVIDIA
OpenGL
ES
drivers
are
not
supported
.
"
)
;
}
syncXCommands
(
)
;
return
DisplayGL
:
:
initialize
(
display
)
;
}
void
DisplayGLX
:
:
terminate
(
)
{
DisplayGL
:
:
terminate
(
)
;
if
(
mDummyPbuffer
)
{
mGLX
.
destroyPbuffer
(
mDummyPbuffer
)
;
mDummyPbuffer
=
0
;
}
if
(
mContext
)
{
mGLX
.
destroyContext
(
mContext
)
;
mContext
=
nullptr
;
}
mGLX
.
terminate
(
)
;
SafeDelete
(
mFunctionsGL
)
;
}
SurfaceImpl
*
DisplayGLX
:
:
createWindowSurface
(
const
egl
:
:
SurfaceState
&
state
const
egl
:
:
Config
*
configuration
EGLNativeWindowType
window
const
egl
:
:
AttributeMap
&
attribs
)
{
ASSERT
(
configIdToGLXConfig
.
count
(
configuration
-
>
configID
)
>
0
)
;
glx
:
:
FBConfig
fbConfig
=
configIdToGLXConfig
[
configuration
-
>
configID
]
;
return
new
WindowSurfaceGLX
(
state
mGLX
this
getRenderer
(
)
window
mGLX
.
getDisplay
(
)
mContext
fbConfig
)
;
}
SurfaceImpl
*
DisplayGLX
:
:
createPbufferSurface
(
const
egl
:
:
SurfaceState
&
state
const
egl
:
:
Config
*
configuration
const
egl
:
:
AttributeMap
&
attribs
)
{
ASSERT
(
configIdToGLXConfig
.
count
(
configuration
-
>
configID
)
>
0
)
;
glx
:
:
FBConfig
fbConfig
=
configIdToGLXConfig
[
configuration
-
>
configID
]
;
EGLint
width
=
static_cast
<
EGLint
>
(
attribs
.
get
(
EGL_WIDTH
0
)
)
;
EGLint
height
=
static_cast
<
EGLint
>
(
attribs
.
get
(
EGL_HEIGHT
0
)
)
;
bool
largest
=
(
attribs
.
get
(
EGL_LARGEST_PBUFFER
EGL_FALSE
)
=
=
EGL_TRUE
)
;
return
new
PbufferSurfaceGLX
(
state
getRenderer
(
)
width
height
largest
mGLX
mContext
fbConfig
)
;
}
SurfaceImpl
*
DisplayGLX
:
:
createPbufferFromClientBuffer
(
const
egl
:
:
SurfaceState
&
state
const
egl
:
:
Config
*
configuration
EGLenum
buftype
EGLClientBuffer
clientBuffer
const
egl
:
:
AttributeMap
&
attribs
)
{
UNIMPLEMENTED
(
)
;
return
nullptr
;
}
SurfaceImpl
*
DisplayGLX
:
:
createPixmapSurface
(
const
egl
:
:
SurfaceState
&
state
const
egl
:
:
Config
*
configuration
NativePixmapType
nativePixmap
const
egl
:
:
AttributeMap
&
attribs
)
{
UNIMPLEMENTED
(
)
;
return
nullptr
;
}
egl
:
:
Error
DisplayGLX
:
:
getDevice
(
DeviceImpl
*
*
device
)
{
UNIMPLEMENTED
(
)
;
return
egl
:
:
Error
(
EGL_BAD_DISPLAY
)
;
}
egl
:
:
Error
DisplayGLX
:
:
initializeContext
(
glx
:
:
FBConfig
config
const
egl
:
:
AttributeMap
&
eglAttributes
glx
:
:
Context
*
context
)
{
int
profileMask
=
0
;
EGLint
requestedDisplayType
=
static_cast
<
EGLint
>
(
eglAttributes
.
get
(
EGL_PLATFORM_ANGLE_TYPE_ANGLE
EGL_PLATFORM_ANGLE_TYPE_DEFAULT_ANGLE
)
)
;
if
(
requestedDisplayType
=
=
EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE
)
{
if
(
!
mHasEXTCreateContextES2Profile
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Cannot
create
an
OpenGL
ES
platform
on
GLX
without
the
"
"
GLX_EXT_create_context_es_profile
extension
.
"
)
;
}
ASSERT
(
mHasARBCreateContextProfile
)
;
profileMask
|
=
GLX_CONTEXT_ES2_PROFILE_BIT_EXT
;
}
gl
:
:
Version
requestedVersion
(
static_cast
<
EGLint
>
(
eglAttributes
.
get
(
EGL_PLATFORM_ANGLE_MAX_VERSION_MAJOR_ANGLE
EGL_DONT_CARE
)
)
static_cast
<
EGLint
>
(
eglAttributes
.
get
(
EGL_PLATFORM_ANGLE_MAX_VERSION_MINOR_ANGLE
EGL_DONT_CARE
)
)
)
;
if
(
static_cast
<
EGLint
>
(
requestedVersion
.
major
)
!
=
EGL_DONT_CARE
&
&
static_cast
<
EGLint
>
(
requestedVersion
.
minor
)
!
=
EGL_DONT_CARE
)
{
if
(
!
(
profileMask
&
GLX_CONTEXT_ES2_PROFILE_BIT_EXT
)
&
&
requestedVersion
>
=
gl
:
:
Version
(
3
2
)
)
{
profileMask
|
=
GLX_CONTEXT_CORE_PROFILE_BIT_ARB
;
}
return
createContextAttribs
(
config
requestedVersion
profileMask
context
)
;
}
struct
ContextCreationInfo
{
EGLint
displayType
;
int
profileFlag
;
Optional
<
gl
:
:
Version
>
version
;
}
;
const
ContextCreationInfo
contextsToTry
[
]
=
{
{
EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE
GLX_CONTEXT_CORE_PROFILE_BIT_ARB
{
}
}
{
EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE
0
{
}
}
{
EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE
GLX_CONTEXT_ES2_PROFILE_BIT_EXT
{
}
}
}
;
const
ContextCreationInfo
mesaContextsToTry
[
]
=
{
{
EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE
GLX_CONTEXT_CORE_PROFILE_BIT_ARB
{
gl
:
:
Version
(
4
5
)
}
}
{
EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE
GLX_CONTEXT_CORE_PROFILE_BIT_ARB
{
gl
:
:
Version
(
4
4
)
}
}
{
EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE
GLX_CONTEXT_CORE_PROFILE_BIT_ARB
{
gl
:
:
Version
(
4
3
)
}
}
{
EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE
GLX_CONTEXT_CORE_PROFILE_BIT_ARB
{
gl
:
:
Version
(
4
2
)
}
}
{
EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE
GLX_CONTEXT_CORE_PROFILE_BIT_ARB
{
gl
:
:
Version
(
4
1
)
}
}
{
EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE
GLX_CONTEXT_CORE_PROFILE_BIT_ARB
{
gl
:
:
Version
(
4
0
)
}
}
{
EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE
GLX_CONTEXT_CORE_PROFILE_BIT_ARB
{
gl
:
:
Version
(
3
3
)
}
}
{
EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE
GLX_CONTEXT_CORE_PROFILE_BIT_ARB
{
gl
:
:
Version
(
3
2
)
}
}
{
EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE
0
{
gl
:
:
Version
(
3
1
)
}
}
{
EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE
0
{
gl
:
:
Version
(
3
0
)
}
}
{
EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE
0
{
gl
:
:
Version
(
2
0
)
}
}
{
EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE
0
{
gl
:
:
Version
(
1
5
)
}
}
{
EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE
0
{
gl
:
:
Version
(
1
4
)
}
}
{
EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE
0
{
gl
:
:
Version
(
1
3
)
}
}
{
EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE
0
{
gl
:
:
Version
(
1
2
)
}
}
{
EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE
0
{
gl
:
:
Version
(
1
1
)
}
}
{
EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE
0
{
gl
:
:
Version
(
1
0
)
}
}
{
EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE
GLX_CONTEXT_ES2_PROFILE_BIT_EXT
{
gl
:
:
Version
(
3
2
)
}
}
{
EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE
GLX_CONTEXT_ES2_PROFILE_BIT_EXT
{
gl
:
:
Version
(
3
1
)
}
}
{
EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE
GLX_CONTEXT_ES2_PROFILE_BIT_EXT
{
gl
:
:
Version
(
3
0
)
}
}
{
EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE
GLX_CONTEXT_ES2_PROFILE_BIT_EXT
{
gl
:
:
Version
(
2
0
)
}
}
}
;
const
ContextCreationInfo
*
toTry
=
contextsToTry
;
size_t
toTryLength
=
ArraySize
(
contextsToTry
)
;
if
(
mIsMesa
)
{
toTry
=
mesaContextsToTry
;
toTryLength
=
ArraySize
(
mesaContextsToTry
)
;
}
for
(
size_t
i
=
0
;
i
<
toTryLength
;
+
+
i
)
{
const
ContextCreationInfo
&
info
=
toTry
[
i
]
;
if
(
requestedDisplayType
!
=
EGL_PLATFORM_ANGLE_TYPE_DEFAULT_ANGLE
&
&
requestedDisplayType
!
=
info
.
displayType
)
{
continue
;
}
egl
:
:
Error
error
=
createContextAttribs
(
config
info
.
version
info
.
profileFlag
context
)
;
if
(
!
error
.
isError
(
)
)
{
return
error
;
}
}
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Could
not
create
a
backing
OpenGL
context
.
"
)
;
}
egl
:
:
ConfigSet
DisplayGLX
:
:
generateConfigs
(
)
{
egl
:
:
ConfigSet
configs
;
configIdToGLXConfig
.
clear
(
)
;
const
gl
:
:
Version
&
maxVersion
=
getMaxSupportedESVersion
(
)
;
ASSERT
(
maxVersion
>
=
gl
:
:
Version
(
2
0
)
)
;
bool
supportsES3
=
maxVersion
>
=
gl
:
:
Version
(
3
0
)
;
int
contextRedSize
=
getGLXFBConfigAttrib
(
mContextConfig
GLX_RED_SIZE
)
;
int
contextGreenSize
=
getGLXFBConfigAttrib
(
mContextConfig
GLX_GREEN_SIZE
)
;
int
contextBlueSize
=
getGLXFBConfigAttrib
(
mContextConfig
GLX_BLUE_SIZE
)
;
int
contextAlphaSize
=
getGLXFBConfigAttrib
(
mContextConfig
GLX_ALPHA_SIZE
)
;
int
contextDepthSize
=
getGLXFBConfigAttrib
(
mContextConfig
GLX_DEPTH_SIZE
)
;
int
contextStencilSize
=
getGLXFBConfigAttrib
(
mContextConfig
GLX_STENCIL_SIZE
)
;
int
contextSamples
=
mHasMultisample
?
getGLXFBConfigAttrib
(
mContextConfig
GLX_SAMPLES
)
:
0
;
int
contextSampleBuffers
=
mHasMultisample
?
getGLXFBConfigAttrib
(
mContextConfig
GLX_SAMPLE_BUFFERS
)
:
0
;
int
contextAccumRedSize
=
getGLXFBConfigAttrib
(
mContextConfig
GLX_ACCUM_RED_SIZE
)
;
int
contextAccumGreenSize
=
getGLXFBConfigAttrib
(
mContextConfig
GLX_ACCUM_GREEN_SIZE
)
;
int
contextAccumBlueSize
=
getGLXFBConfigAttrib
(
mContextConfig
GLX_ACCUM_BLUE_SIZE
)
;
int
contextAccumAlphaSize
=
getGLXFBConfigAttrib
(
mContextConfig
GLX_ACCUM_ALPHA_SIZE
)
;
int
attribList
[
]
=
{
GLX_RENDER_TYPE
GLX_RGBA_BIT
GLX_X_RENDERABLE
True
GLX_DOUBLEBUFFER
True
None
}
;
int
glxConfigCount
;
glx
:
:
FBConfig
*
glxConfigs
=
mGLX
.
chooseFBConfig
(
attribList
&
glxConfigCount
)
;
for
(
int
i
=
0
;
i
<
glxConfigCount
;
i
+
+
)
{
glx
:
:
FBConfig
glxConfig
=
glxConfigs
[
i
]
;
egl
:
:
Config
config
;
config
.
nativeVisualID
=
getGLXFBConfigAttrib
(
glxConfig
GLX_VISUAL_ID
)
;
config
.
nativeVisualType
=
getGLXFBConfigAttrib
(
glxConfig
GLX_X_VISUAL_TYPE
)
;
config
.
nativeRenderable
=
EGL_TRUE
;
if
(
mRequestedVisual
!
=
-
1
&
&
config
.
nativeVisualID
!
=
mRequestedVisual
)
{
continue
;
}
config
.
redSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_RED_SIZE
)
;
config
.
greenSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_GREEN_SIZE
)
;
config
.
blueSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_BLUE_SIZE
)
;
config
.
alphaSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_ALPHA_SIZE
)
;
config
.
depthSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_DEPTH_SIZE
)
;
config
.
stencilSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_STENCIL_SIZE
)
;
if
(
config
.
redSize
!
=
contextRedSize
|
|
config
.
greenSize
!
=
contextGreenSize
|
|
config
.
blueSize
!
=
contextBlueSize
|
|
config
.
alphaSize
!
=
contextAlphaSize
)
{
continue
;
}
bool
hasSameDepthStencil
=
config
.
depthSize
=
=
contextDepthSize
&
&
config
.
stencilSize
=
=
contextStencilSize
;
bool
hasNoDepthStencil
=
config
.
depthSize
=
=
0
&
&
config
.
stencilSize
=
=
0
;
if
(
!
hasSameDepthStencil
&
&
(
mIsMesa
|
|
!
hasNoDepthStencil
)
)
{
continue
;
}
config
.
colorBufferType
=
EGL_RGB_BUFFER
;
config
.
luminanceSize
=
0
;
config
.
alphaMaskSize
=
0
;
config
.
bufferSize
=
config
.
redSize
+
config
.
greenSize
+
config
.
blueSize
+
config
.
alphaSize
;
int
samples
=
mHasMultisample
?
getGLXFBConfigAttrib
(
glxConfig
GLX_SAMPLES
)
:
0
;
int
sampleBuffers
=
mHasMultisample
?
getGLXFBConfigAttrib
(
glxConfig
GLX_SAMPLE_BUFFERS
)
:
0
;
int
accumRedSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_ACCUM_RED_SIZE
)
;
int
accumGreenSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_ACCUM_GREEN_SIZE
)
;
int
accumBlueSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_ACCUM_BLUE_SIZE
)
;
int
accumAlphaSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_ACCUM_ALPHA_SIZE
)
;
if
(
samples
!
=
contextSamples
|
|
sampleBuffers
!
=
contextSampleBuffers
|
|
accumRedSize
!
=
contextAccumRedSize
|
|
accumGreenSize
!
=
contextAccumGreenSize
|
|
accumBlueSize
!
=
contextAccumBlueSize
|
|
accumAlphaSize
!
=
contextAccumAlphaSize
)
{
continue
;
}
config
.
samples
=
samples
;
config
.
sampleBuffers
=
sampleBuffers
;
if
(
getGLXFBConfigAttrib
(
glxConfig
GLX_TRANSPARENT_TYPE
)
=
=
GLX_TRANSPARENT_RGB
)
{
config
.
transparentType
=
EGL_TRANSPARENT_RGB
;
config
.
transparentRedValue
=
getGLXFBConfigAttrib
(
glxConfig
GLX_TRANSPARENT_RED_VALUE
)
;
config
.
transparentGreenValue
=
getGLXFBConfigAttrib
(
glxConfig
GLX_TRANSPARENT_GREEN_VALUE
)
;
config
.
transparentBlueValue
=
getGLXFBConfigAttrib
(
glxConfig
GLX_TRANSPARENT_BLUE_VALUE
)
;
}
else
{
config
.
transparentType
=
EGL_NONE
;
}
config
.
maxPBufferWidth
=
getGLXFBConfigAttrib
(
glxConfig
GLX_MAX_PBUFFER_WIDTH
)
;
config
.
maxPBufferHeight
=
getGLXFBConfigAttrib
(
glxConfig
GLX_MAX_PBUFFER_HEIGHT
)
;
config
.
maxPBufferPixels
=
getGLXFBConfigAttrib
(
glxConfig
GLX_MAX_PBUFFER_PIXELS
)
;
config
.
configCaveat
=
EGL_NONE
;
int
caveat
=
getGLXFBConfigAttrib
(
glxConfig
GLX_CONFIG_CAVEAT
)
;
if
(
caveat
=
=
GLX_SLOW_CONFIG
)
{
config
.
configCaveat
=
EGL_SLOW_CONFIG
;
}
else
if
(
caveat
=
=
GLX_NON_CONFORMANT_CONFIG
)
{
continue
;
}
config
.
level
=
getGLXFBConfigAttrib
(
glxConfig
GLX_LEVEL
)
;
config
.
bindToTextureRGB
=
EGL_FALSE
;
config
.
bindToTextureRGBA
=
EGL_FALSE
;
int
glxDrawable
=
getGLXFBConfigAttrib
(
glxConfig
GLX_DRAWABLE_TYPE
)
;
config
.
surfaceType
=
0
|
(
glxDrawable
&
GLX_WINDOW_BIT
?
EGL_WINDOW_BIT
:
0
)
|
(
glxDrawable
&
GLX_PBUFFER_BIT
?
EGL_PBUFFER_BIT
:
0
)
|
(
glxDrawable
&
GLX_PIXMAP_BIT
?
EGL_PIXMAP_BIT
:
0
)
;
config
.
minSwapInterval
=
mMinSwapInterval
;
config
.
maxSwapInterval
=
mMaxSwapInterval
;
config
.
renderTargetFormat
=
GL_RGBA8
;
config
.
depthStencilFormat
=
GL_DEPTH24_STENCIL8
;
config
.
conformant
=
EGL_OPENGL_ES2_BIT
|
(
supportsES3
?
EGL_OPENGL_ES3_BIT_KHR
:
0
)
;
config
.
renderableType
=
config
.
conformant
;
config
.
matchNativePixmap
=
EGL_NONE
;
int
id
=
configs
.
add
(
config
)
;
configIdToGLXConfig
[
id
]
=
glxConfig
;
}
XFree
(
glxConfigs
)
;
return
configs
;
}
bool
DisplayGLX
:
:
testDeviceLost
(
)
{
if
(
mHasARBCreateContextRobustness
)
{
return
getRenderer
(
)
-
>
getResetStatus
(
)
!
=
GL_NO_ERROR
;
}
return
false
;
}
egl
:
:
Error
DisplayGLX
:
:
restoreLostDevice
(
)
{
return
egl
:
:
Error
(
EGL_BAD_DISPLAY
)
;
}
bool
DisplayGLX
:
:
isValidNativeWindow
(
EGLNativeWindowType
window
)
const
{
Window
root
;
Window
parent
;
Window
*
children
=
nullptr
;
unsigned
nChildren
;
int
status
=
XQueryTree
(
mGLX
.
getDisplay
(
)
window
&
root
&
parent
&
children
&
nChildren
)
;
if
(
children
)
{
XFree
(
children
)
;
}
return
status
!
=
0
;
}
std
:
:
string
DisplayGLX
:
:
getVendorString
(
)
const
{
return
"
"
;
}
egl
:
:
Error
DisplayGLX
:
:
waitClient
(
)
const
{
mGLX
.
waitGL
(
)
;
return
egl
:
:
Error
(
EGL_SUCCESS
)
;
}
egl
:
:
Error
DisplayGLX
:
:
getDriverVersion
(
std
:
:
string
*
version
)
const
{
VendorID
vendor
=
GetVendorID
(
mFunctionsGL
)
;
switch
(
vendor
)
{
case
VENDOR_ID_NVIDIA
:
return
getNVIDIADriverVersion
(
version
)
;
case
VENDOR_ID_AMD
:
return
GetAMDDriverVersion
(
version
)
;
default
:
*
version
=
"
"
;
return
egl
:
:
Error
(
EGL_SUCCESS
)
;
}
}
egl
:
:
Error
DisplayGLX
:
:
waitNative
(
EGLint
engine
egl
:
:
Surface
*
drawSurface
egl
:
:
Surface
*
readSurface
)
const
{
if
(
drawSurface
!
=
nullptr
)
{
SurfaceGLX
*
glxDrawSurface
=
GetImplAs
<
SurfaceGLX
>
(
drawSurface
)
;
egl
:
:
Error
error
=
glxDrawSurface
-
>
checkForResize
(
)
;
if
(
error
.
isError
(
)
)
{
return
error
;
}
}
if
(
readSurface
!
=
drawSurface
&
&
readSurface
!
=
nullptr
)
{
SurfaceGLX
*
glxReadSurface
=
GetImplAs
<
SurfaceGLX
>
(
readSurface
)
;
egl
:
:
Error
error
=
glxReadSurface
-
>
checkForResize
(
)
;
if
(
error
.
isError
(
)
)
{
return
error
;
}
}
mGLX
.
waitX
(
)
;
return
egl
:
:
Error
(
EGL_SUCCESS
)
;
}
void
DisplayGLX
:
:
syncXCommands
(
)
const
{
if
(
mUsesNewXDisplay
)
{
XSync
(
mGLX
.
getDisplay
(
)
False
)
;
}
}
void
DisplayGLX
:
:
setSwapInterval
(
glx
:
:
Drawable
drawable
SwapControlData
*
data
)
{
ASSERT
(
data
!
=
nullptr
)
;
if
(
mSwapControl
=
=
SwapControl
:
:
EXT
)
{
if
(
data
-
>
maxSwapInterval
<
0
)
{
unsigned
int
maxSwapInterval
=
0
;
mGLX
.
queryDrawable
(
drawable
GLX_MAX_SWAP_INTERVAL_EXT
&
maxSwapInterval
)
;
data
-
>
maxSwapInterval
=
static_cast
<
int
>
(
maxSwapInterval
)
;
}
const
int
realInterval
=
std
:
:
min
(
data
-
>
targetSwapInterval
data
-
>
maxSwapInterval
)
;
if
(
data
-
>
currentSwapInterval
!
=
realInterval
)
{
mGLX
.
swapIntervalEXT
(
drawable
realInterval
)
;
data
-
>
currentSwapInterval
=
realInterval
;
}
}
else
if
(
mCurrentSwapInterval
!
=
data
-
>
targetSwapInterval
)
{
if
(
mSwapControl
=
=
SwapControl
:
:
Mesa
)
{
mGLX
.
swapIntervalMESA
(
data
-
>
targetSwapInterval
)
;
}
else
if
(
mSwapControl
=
=
SwapControl
:
:
SGI
)
{
mGLX
.
swapIntervalSGI
(
data
-
>
targetSwapInterval
)
;
}
mCurrentSwapInterval
=
data
-
>
targetSwapInterval
;
}
}
bool
DisplayGLX
:
:
isValidWindowVisualId
(
unsigned
long
visualId
)
const
{
return
mRequestedVisual
=
=
-
1
|
|
static_cast
<
unsigned
long
>
(
mRequestedVisual
)
=
=
visualId
;
}
const
FunctionsGL
*
DisplayGLX
:
:
getFunctionsGL
(
)
const
{
return
mFunctionsGL
;
}
void
DisplayGLX
:
:
generateExtensions
(
egl
:
:
DisplayExtensions
*
outExtensions
)
const
{
outExtensions
-
>
createContextRobustness
=
mHasARBCreateContextRobustness
;
}
void
DisplayGLX
:
:
generateCaps
(
egl
:
:
Caps
*
outCaps
)
const
{
outCaps
-
>
textureNPOT
=
true
;
}
int
DisplayGLX
:
:
getGLXFBConfigAttrib
(
glx
:
:
FBConfig
config
int
attrib
)
const
{
int
result
;
mGLX
.
getFBConfigAttrib
(
config
attrib
&
result
)
;
return
result
;
}
egl
:
:
Error
DisplayGLX
:
:
createContextAttribs
(
glx
:
:
FBConfig
const
Optional
<
gl
:
:
Version
>
&
version
int
profileMask
glx
:
:
Context
*
context
)
const
{
std
:
:
vector
<
int
>
attribs
;
if
(
mHasARBCreateContextRobustness
)
{
attribs
.
push_back
(
GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB
)
;
attribs
.
push_back
(
GLX_LOSE_CONTEXT_ON_RESET_ARB
)
;
}
if
(
version
.
valid
(
)
)
{
attribs
.
push_back
(
GLX_CONTEXT_MAJOR_VERSION_ARB
)
;
attribs
.
push_back
(
version
.
value
(
)
.
major
)
;
attribs
.
push_back
(
GLX_CONTEXT_MINOR_VERSION_ARB
)
;
attribs
.
push_back
(
version
.
value
(
)
.
minor
)
;
}
if
(
profileMask
!
=
0
&
&
mHasARBCreateContextProfile
)
{
attribs
.
push_back
(
GLX_CONTEXT_PROFILE_MASK_ARB
)
;
attribs
.
push_back
(
profileMask
)
;
}
attribs
.
push_back
(
None
)
;
XSync
(
mXDisplay
False
)
;
auto
oldErrorHandler
=
XSetErrorHandler
(
IgnoreX11Errors
)
;
*
context
=
mGLX
.
createContextAttribsARB
(
mContextConfig
nullptr
True
attribs
.
data
(
)
)
;
XSetErrorHandler
(
oldErrorHandler
)
;
if
(
!
*
context
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Could
not
create
GL
context
.
"
)
;
}
return
egl
:
:
Error
(
EGL_SUCCESS
)
;
}
egl
:
:
Error
DisplayGLX
:
:
getNVIDIADriverVersion
(
std
:
:
string
*
version
)
const
{
*
version
=
"
"
;
int
eventBase
=
0
;
int
errorBase
=
0
;
if
(
XNVCTRLQueryExtension
(
mXDisplay
&
eventBase
&
errorBase
)
)
{
int
screenCount
=
ScreenCount
(
mXDisplay
)
;
for
(
int
screen
=
0
;
screen
<
screenCount
;
+
+
screen
)
{
char
*
buffer
=
nullptr
;
if
(
XNVCTRLIsNvScreen
(
mXDisplay
screen
)
&
&
XNVCTRLQueryStringAttribute
(
mXDisplay
screen
0
NV_CTRL_STRING_NVIDIA_DRIVER_VERSION
&
buffer
)
)
{
*
version
=
buffer
;
XFree
(
buffer
)
;
}
}
}
return
egl
:
:
Error
(
EGL_SUCCESS
)
;
}
}
