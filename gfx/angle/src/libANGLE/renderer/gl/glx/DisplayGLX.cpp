#
include
"
libANGLE
/
renderer
/
gl
/
glx
/
DisplayGLX
.
h
"
#
include
<
EGL
/
eglext
.
h
>
#
include
<
algorithm
>
#
include
"
common
/
debug
.
h
"
#
include
"
libANGLE
/
Config
.
h
"
#
include
"
libANGLE
/
Display
.
h
"
#
include
"
libANGLE
/
Surface
.
h
"
#
include
"
libANGLE
/
renderer
/
gl
/
glx
/
PbufferSurfaceGLX
.
h
"
#
include
"
libANGLE
/
renderer
/
gl
/
glx
/
WindowSurfaceGLX
.
h
"
namespace
rx
{
class
FunctionsGLGLX
:
public
FunctionsGL
{
public
:
FunctionsGLGLX
(
PFNGETPROCPROC
getProc
)
:
mGetProc
(
getProc
)
{
}
virtual
~
FunctionsGLGLX
(
)
{
}
private
:
void
*
loadProcAddress
(
const
std
:
:
string
&
function
)
override
{
return
reinterpret_cast
<
void
*
>
(
mGetProc
(
function
.
c_str
(
)
)
)
;
}
PFNGETPROCPROC
mGetProc
;
}
;
DisplayGLX
:
:
DisplayGLX
(
)
:
DisplayGL
(
)
mFunctionsGL
(
nullptr
)
mContext
(
nullptr
)
mDummyPbuffer
(
0
)
mUsesNewXDisplay
(
false
)
mEGLDisplay
(
nullptr
)
{
}
DisplayGLX
:
:
~
DisplayGLX
(
)
{
}
egl
:
:
Error
DisplayGLX
:
:
initialize
(
egl
:
:
Display
*
display
)
{
mEGLDisplay
=
display
;
Display
*
xDisplay
=
display
-
>
getNativeDisplayId
(
)
;
if
(
xDisplay
=
=
EGL_DEFAULT_DISPLAY
)
{
mUsesNewXDisplay
=
true
;
xDisplay
=
XOpenDisplay
(
NULL
)
;
if
(
!
xDisplay
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Could
not
open
the
default
X
display
.
"
)
;
}
}
std
:
:
string
glxInitError
;
if
(
!
mGLX
.
initialize
(
xDisplay
DefaultScreen
(
xDisplay
)
&
glxInitError
)
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
glxInitError
.
c_str
(
)
)
;
}
{
if
(
mGLX
.
minorVersion
=
=
3
&
&
!
mGLX
.
hasExtension
(
"
GLX_ARB_multisample
"
)
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
GLX
doesn
'
t
support
ARB_multisample
.
"
)
;
}
if
(
!
mGLX
.
hasExtension
(
"
GLX_ARB_create_context
"
)
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
GLX
doesn
'
t
support
ARB_create_context
.
"
)
;
}
}
glx
:
:
FBConfig
contextConfig
;
{
int
nConfigs
;
int
attribList
[
]
=
{
GLX_RED_SIZE
8
GLX_GREEN_SIZE
8
GLX_BLUE_SIZE
8
GLX_ALPHA_SIZE
8
GLX_DEPTH_SIZE
24
GLX_STENCIL_SIZE
8
GLX_RENDER_TYPE
GLX_RGBA_BIT
GLX_DOUBLEBUFFER
True
GLX_DRAWABLE_TYPE
GLX_WINDOW_BIT
|
GLX_PBUFFER_BIT
|
GLX_PIXMAP_BIT
GLX_X_RENDERABLE
True
GLX_CONFIG_CAVEAT
GLX_NONE
None
}
;
glx
:
:
FBConfig
*
candidates
=
mGLX
.
chooseFBConfig
(
attribList
&
nConfigs
)
;
if
(
nConfigs
=
=
0
)
{
XFree
(
candidates
)
;
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Could
not
find
a
decent
GLX
FBConfig
to
create
the
context
.
"
)
;
}
contextConfig
=
candidates
[
0
]
;
XFree
(
candidates
)
;
}
mContext
=
mGLX
.
createContextAttribsARB
(
contextConfig
nullptr
True
nullptr
)
;
if
(
!
mContext
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Could
not
create
GL
context
.
"
)
;
}
mDummyPbuffer
=
mGLX
.
createPbuffer
(
contextConfig
nullptr
)
;
if
(
!
mDummyPbuffer
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Could
not
create
the
dummy
pbuffer
.
"
)
;
}
if
(
!
mGLX
.
makeCurrent
(
mDummyPbuffer
mContext
)
)
{
return
egl
:
:
Error
(
EGL_NOT_INITIALIZED
"
Could
not
make
the
dummy
pbuffer
current
.
"
)
;
}
mFunctionsGL
=
new
FunctionsGLGLX
(
mGLX
.
getProc
)
;
mFunctionsGL
-
>
initialize
(
)
;
syncXCommands
(
)
;
return
DisplayGL
:
:
initialize
(
display
)
;
}
void
DisplayGLX
:
:
terminate
(
)
{
DisplayGL
:
:
terminate
(
)
;
if
(
mDummyPbuffer
)
{
mGLX
.
destroyPbuffer
(
mDummyPbuffer
)
;
mDummyPbuffer
=
0
;
}
if
(
mContext
)
{
mGLX
.
destroyContext
(
mContext
)
;
mContext
=
nullptr
;
}
mGLX
.
terminate
(
)
;
SafeDelete
(
mFunctionsGL
)
;
}
SurfaceImpl
*
DisplayGLX
:
:
createWindowSurface
(
const
egl
:
:
Config
*
configuration
EGLNativeWindowType
window
const
egl
:
:
AttributeMap
&
attribs
)
{
ASSERT
(
configIdToGLXConfig
.
count
(
configuration
-
>
configID
)
>
0
)
;
glx
:
:
FBConfig
fbConfig
=
configIdToGLXConfig
[
configuration
-
>
configID
]
;
return
new
WindowSurfaceGLX
(
mGLX
*
this
window
mGLX
.
getDisplay
(
)
mContext
fbConfig
)
;
}
SurfaceImpl
*
DisplayGLX
:
:
createPbufferSurface
(
const
egl
:
:
Config
*
configuration
const
egl
:
:
AttributeMap
&
attribs
)
{
ASSERT
(
configIdToGLXConfig
.
count
(
configuration
-
>
configID
)
>
0
)
;
glx
:
:
FBConfig
fbConfig
=
configIdToGLXConfig
[
configuration
-
>
configID
]
;
EGLint
width
=
attribs
.
get
(
EGL_WIDTH
0
)
;
EGLint
height
=
attribs
.
get
(
EGL_HEIGHT
0
)
;
bool
largest
=
(
attribs
.
get
(
EGL_LARGEST_PBUFFER
EGL_FALSE
)
=
=
EGL_TRUE
)
;
return
new
PbufferSurfaceGLX
(
width
height
largest
mGLX
mContext
fbConfig
)
;
}
SurfaceImpl
*
DisplayGLX
:
:
createPbufferFromClientBuffer
(
const
egl
:
:
Config
*
configuration
EGLClientBuffer
shareHandle
const
egl
:
:
AttributeMap
&
attribs
)
{
UNIMPLEMENTED
(
)
;
return
nullptr
;
}
SurfaceImpl
*
DisplayGLX
:
:
createPixmapSurface
(
const
egl
:
:
Config
*
configuration
NativePixmapType
nativePixmap
const
egl
:
:
AttributeMap
&
attribs
)
{
UNIMPLEMENTED
(
)
;
return
nullptr
;
}
egl
:
:
Error
DisplayGLX
:
:
getDevice
(
DeviceImpl
*
*
device
)
{
UNIMPLEMENTED
(
)
;
return
egl
:
:
Error
(
EGL_BAD_DISPLAY
)
;
}
egl
:
:
ConfigSet
DisplayGLX
:
:
generateConfigs
(
)
const
{
egl
:
:
ConfigSet
configs
;
configIdToGLXConfig
.
clear
(
)
;
bool
hasSwapControl
=
mGLX
.
hasExtension
(
"
GLX_EXT_swap_control
"
)
;
int
attribList
[
]
=
{
GLX_RENDER_TYPE
GLX_RGBA_BIT
GLX_X_RENDERABLE
True
GLX_DOUBLEBUFFER
True
None
}
;
int
glxConfigCount
;
glx
:
:
FBConfig
*
glxConfigs
=
mGLX
.
chooseFBConfig
(
attribList
&
glxConfigCount
)
;
for
(
int
i
=
0
;
i
<
glxConfigCount
;
i
+
+
)
{
glx
:
:
FBConfig
glxConfig
=
glxConfigs
[
i
]
;
egl
:
:
Config
config
;
config
.
nativeVisualID
=
getGLXFBConfigAttrib
(
glxConfig
GLX_VISUAL_ID
)
;
config
.
nativeVisualType
=
getGLXFBConfigAttrib
(
glxConfig
GLX_X_VISUAL_TYPE
)
;
config
.
nativeRenderable
=
EGL_TRUE
;
config
.
redSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_RED_SIZE
)
;
config
.
greenSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_GREEN_SIZE
)
;
config
.
blueSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_BLUE_SIZE
)
;
config
.
alphaSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_ALPHA_SIZE
)
;
config
.
depthSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_DEPTH_SIZE
)
;
config
.
stencilSize
=
getGLXFBConfigAttrib
(
glxConfig
GLX_STENCIL_SIZE
)
;
if
(
config
.
redSize
!
=
8
|
|
config
.
greenSize
!
=
8
|
|
config
.
blueSize
!
=
8
|
|
config
.
alphaSize
!
=
8
)
{
continue
;
}
if
(
!
(
config
.
depthSize
=
=
24
&
&
config
.
stencilSize
=
=
8
)
&
&
!
(
config
.
depthSize
=
=
0
&
&
config
.
stencilSize
=
=
0
)
)
{
continue
;
}
config
.
colorBufferType
=
EGL_RGB_BUFFER
;
config
.
luminanceSize
=
0
;
config
.
alphaMaskSize
=
0
;
config
.
bufferSize
=
config
.
redSize
+
config
.
greenSize
+
config
.
blueSize
+
config
.
alphaSize
;
if
(
getGLXFBConfigAttrib
(
glxConfig
GLX_TRANSPARENT_TYPE
)
=
=
GLX_TRANSPARENT_RGB
)
{
config
.
transparentType
=
EGL_TRANSPARENT_RGB
;
config
.
transparentRedValue
=
getGLXFBConfigAttrib
(
glxConfig
GLX_TRANSPARENT_RED_VALUE
)
;
config
.
transparentGreenValue
=
getGLXFBConfigAttrib
(
glxConfig
GLX_TRANSPARENT_GREEN_VALUE
)
;
config
.
transparentBlueValue
=
getGLXFBConfigAttrib
(
glxConfig
GLX_TRANSPARENT_BLUE_VALUE
)
;
}
else
{
config
.
transparentType
=
EGL_NONE
;
}
config
.
maxPBufferWidth
=
getGLXFBConfigAttrib
(
glxConfig
GLX_MAX_PBUFFER_WIDTH
)
;
config
.
maxPBufferHeight
=
getGLXFBConfigAttrib
(
glxConfig
GLX_MAX_PBUFFER_HEIGHT
)
;
config
.
maxPBufferPixels
=
getGLXFBConfigAttrib
(
glxConfig
GLX_MAX_PBUFFER_PIXELS
)
;
config
.
configCaveat
=
EGL_NONE
;
int
caveat
=
getGLXFBConfigAttrib
(
glxConfig
GLX_CONFIG_CAVEAT
)
;
if
(
caveat
=
=
GLX_SLOW_CONFIG
)
{
config
.
configCaveat
=
EGL_SLOW_CONFIG
;
}
else
if
(
caveat
=
=
GLX_NON_CONFORMANT_CONFIG
)
{
continue
;
}
config
.
sampleBuffers
=
getGLXFBConfigAttrib
(
glxConfig
GLX_SAMPLE_BUFFERS
)
;
config
.
samples
=
getGLXFBConfigAttrib
(
glxConfig
GLX_SAMPLES
)
;
config
.
level
=
getGLXFBConfigAttrib
(
glxConfig
GLX_LEVEL
)
;
config
.
bindToTextureRGB
=
EGL_FALSE
;
config
.
bindToTextureRGBA
=
EGL_FALSE
;
int
glxDrawable
=
getGLXFBConfigAttrib
(
glxConfig
GLX_DRAWABLE_TYPE
)
;
config
.
surfaceType
=
0
|
(
glxDrawable
&
GLX_WINDOW_BIT
?
EGL_WINDOW_BIT
:
0
)
|
(
glxDrawable
&
GLX_PBUFFER_BIT
?
EGL_PBUFFER_BIT
:
0
)
|
(
glxDrawable
&
GLX_PIXMAP_BIT
?
EGL_PIXMAP_BIT
:
0
)
;
if
(
hasSwapControl
)
{
config
.
minSwapInterval
=
0
;
config
.
maxSwapInterval
=
4
;
}
else
{
config
.
minSwapInterval
=
1
;
config
.
maxSwapInterval
=
1
;
}
config
.
renderTargetFormat
=
GL_RGBA8
;
config
.
depthStencilFormat
=
GL_DEPTH24_STENCIL8
;
config
.
conformant
=
EGL_OPENGL_ES2_BIT
|
EGL_OPENGL_ES3_BIT_KHR
;
config
.
renderableType
=
EGL_OPENGL_ES2_BIT
|
EGL_OPENGL_ES3_BIT_KHR
;
config
.
matchNativePixmap
=
EGL_NONE
;
int
id
=
configs
.
add
(
config
)
;
configIdToGLXConfig
[
id
]
=
glxConfig
;
}
return
configs
;
}
bool
DisplayGLX
:
:
isDeviceLost
(
)
const
{
return
false
;
}
bool
DisplayGLX
:
:
testDeviceLost
(
)
{
return
false
;
}
egl
:
:
Error
DisplayGLX
:
:
restoreLostDevice
(
)
{
UNIMPLEMENTED
(
)
;
return
egl
:
:
Error
(
EGL_BAD_DISPLAY
)
;
}
bool
DisplayGLX
:
:
isValidNativeWindow
(
EGLNativeWindowType
window
)
const
{
Window
root
;
Window
parent
;
Window
*
children
=
nullptr
;
unsigned
nChildren
;
int
status
=
XQueryTree
(
mGLX
.
getDisplay
(
)
window
&
root
&
parent
&
children
&
nChildren
)
;
if
(
children
)
{
XFree
(
children
)
;
}
return
status
!
=
0
;
}
std
:
:
string
DisplayGLX
:
:
getVendorString
(
)
const
{
return
"
"
;
}
void
DisplayGLX
:
:
syncXCommands
(
)
const
{
if
(
mUsesNewXDisplay
)
{
XSync
(
mGLX
.
getDisplay
(
)
False
)
;
}
}
const
FunctionsGL
*
DisplayGLX
:
:
getFunctionsGL
(
)
const
{
return
mFunctionsGL
;
}
void
DisplayGLX
:
:
generateExtensions
(
egl
:
:
DisplayExtensions
*
outExtensions
)
const
{
}
void
DisplayGLX
:
:
generateCaps
(
egl
:
:
Caps
*
outCaps
)
const
{
outCaps
-
>
textureNPOT
=
true
;
}
int
DisplayGLX
:
:
getGLXFBConfigAttrib
(
glx
:
:
FBConfig
config
int
attrib
)
const
{
int
result
;
mGLX
.
getFBConfigAttrib
(
config
attrib
&
result
)
;
return
result
;
}
}
