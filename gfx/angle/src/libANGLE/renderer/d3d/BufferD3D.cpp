#
include
"
libANGLE
/
renderer
/
d3d
/
BufferD3D
.
h
"
#
include
"
common
/
mathutil
.
h
"
#
include
"
common
/
utilities
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
IndexBuffer
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
VertexBuffer
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
RendererD3D
.
h
"
namespace
rx
{
unsigned
int
BufferD3D
:
:
mNextSerial
=
1
;
BufferD3D
:
:
BufferD3D
(
const
gl
:
:
BufferState
&
state
BufferFactoryD3D
*
factory
)
:
BufferImpl
(
state
)
mFactory
(
factory
)
mStaticIndexBuffer
(
nullptr
)
mStaticBufferCacheTotalSize
(
0
)
mStaticVertexBufferOutOfDate
(
false
)
mUnmodifiedDataUse
(
0
)
mUsage
(
D3DBufferUsage
:
:
STATIC
)
{
updateSerial
(
)
;
}
BufferD3D
:
:
~
BufferD3D
(
)
{
SafeDelete
(
mStaticIndexBuffer
)
;
}
void
BufferD3D
:
:
emptyStaticBufferCache
(
)
{
mStaticVertexBuffers
.
clear
(
)
;
mStaticBufferCacheTotalSize
=
0
;
}
void
BufferD3D
:
:
updateSerial
(
)
{
mSerial
=
mNextSerial
+
+
;
}
void
BufferD3D
:
:
updateD3DBufferUsage
(
GLenum
usage
)
{
switch
(
usage
)
{
case
GL_STATIC_DRAW
:
case
GL_STATIC_READ
:
case
GL_STATIC_COPY
:
mUsage
=
D3DBufferUsage
:
:
STATIC
;
initializeStaticData
(
)
;
break
;
case
GL_STREAM_DRAW
:
case
GL_STREAM_READ
:
case
GL_STREAM_COPY
:
case
GL_DYNAMIC_READ
:
case
GL_DYNAMIC_COPY
:
case
GL_DYNAMIC_DRAW
:
mUsage
=
D3DBufferUsage
:
:
DYNAMIC
;
break
;
default
:
UNREACHABLE
(
)
;
}
}
void
BufferD3D
:
:
initializeStaticData
(
)
{
if
(
mStaticVertexBuffers
.
empty
(
)
)
{
auto
newStaticBuffer
=
new
StaticVertexBufferInterface
(
mFactory
)
;
mStaticVertexBuffers
.
push_back
(
std
:
:
unique_ptr
<
StaticVertexBufferInterface
>
(
newStaticBuffer
)
)
;
}
if
(
!
mStaticIndexBuffer
)
{
mStaticIndexBuffer
=
new
StaticIndexBufferInterface
(
mFactory
)
;
}
}
StaticIndexBufferInterface
*
BufferD3D
:
:
getStaticIndexBuffer
(
)
{
return
mStaticIndexBuffer
;
}
StaticVertexBufferInterface
*
BufferD3D
:
:
getStaticVertexBuffer
(
const
gl
:
:
VertexAttribute
&
attribute
)
{
if
(
mStaticVertexBuffers
.
empty
(
)
)
{
return
nullptr
;
}
if
(
mStaticVertexBuffers
.
size
(
)
=
=
1
&
&
mStaticVertexBuffers
[
0
]
-
>
empty
(
)
)
{
return
mStaticVertexBuffers
[
0
]
.
get
(
)
;
}
size_t
currentTotalSize
=
0
;
for
(
const
auto
&
staticBuffer
:
mStaticVertexBuffers
)
{
if
(
staticBuffer
-
>
matchesAttribute
(
attribute
)
)
{
return
staticBuffer
.
get
(
)
;
}
currentTotalSize
+
=
staticBuffer
-
>
getBufferSize
(
)
;
}
ASSERT
(
getSize
(
)
<
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
/
4u
)
;
size_t
sizeThreshold
=
std
:
:
max
(
getSize
(
)
*
4u
static_cast
<
size_t
>
(
0x1000u
)
)
;
if
(
currentTotalSize
>
sizeThreshold
)
{
emptyStaticBufferCache
(
)
;
}
auto
newStaticBuffer
=
new
StaticVertexBufferInterface
(
mFactory
)
;
newStaticBuffer
-
>
setAttribute
(
attribute
)
;
mStaticVertexBuffers
.
push_back
(
std
:
:
unique_ptr
<
StaticVertexBufferInterface
>
(
newStaticBuffer
)
)
;
return
newStaticBuffer
;
}
void
BufferD3D
:
:
invalidateStaticData
(
)
{
emptyStaticBufferCache
(
)
;
if
(
mStaticIndexBuffer
&
&
mStaticIndexBuffer
-
>
getBufferSize
(
)
!
=
0
)
{
SafeDelete
(
mStaticIndexBuffer
)
;
}
if
(
mUsage
=
=
D3DBufferUsage
:
:
STATIC
)
{
initializeStaticData
(
)
;
}
mUnmodifiedDataUse
=
0
;
}
void
BufferD3D
:
:
promoteStaticUsage
(
int
dataSize
)
{
if
(
mUsage
=
=
D3DBufferUsage
:
:
DYNAMIC
)
{
mUnmodifiedDataUse
+
=
dataSize
;
if
(
mUnmodifiedDataUse
>
3
*
getSize
(
)
)
{
updateD3DBufferUsage
(
GL_STATIC_DRAW
)
;
}
}
}
gl
:
:
Error
BufferD3D
:
:
getIndexRange
(
GLenum
type
size_t
offset
size_t
count
bool
primitiveRestartEnabled
gl
:
:
IndexRange
*
outRange
)
{
const
uint8_t
*
data
=
nullptr
;
ANGLE_TRY
(
getData
(
&
data
)
)
;
*
outRange
=
gl
:
:
ComputeIndexRange
(
type
data
+
offset
count
primitiveRestartEnabled
)
;
return
gl
:
:
Error
(
GL_NO_ERROR
)
;
}
}
