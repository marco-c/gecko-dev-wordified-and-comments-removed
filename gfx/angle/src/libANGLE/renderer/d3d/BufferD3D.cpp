#
include
"
libANGLE
/
renderer
/
d3d
/
BufferD3D
.
h
"
#
include
"
common
/
utilities
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
IndexBuffer
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
VertexBuffer
.
h
"
namespace
rx
{
unsigned
int
BufferD3D
:
:
mNextSerial
=
1
;
BufferD3D
:
:
BufferD3D
(
BufferFactoryD3D
*
factory
)
:
BufferImpl
(
)
mFactory
(
factory
)
mStaticVertexBuffer
(
nullptr
)
mStaticIndexBuffer
(
nullptr
)
mUnmodifiedDataUse
(
0
)
{
updateSerial
(
)
;
}
BufferD3D
:
:
~
BufferD3D
(
)
{
SafeDelete
(
mStaticVertexBuffer
)
;
SafeDelete
(
mStaticIndexBuffer
)
;
}
void
BufferD3D
:
:
updateSerial
(
)
{
mSerial
=
mNextSerial
+
+
;
}
void
BufferD3D
:
:
initializeStaticData
(
)
{
if
(
!
mStaticVertexBuffer
)
{
mStaticVertexBuffer
=
new
StaticVertexBufferInterface
(
mFactory
)
;
}
if
(
!
mStaticIndexBuffer
)
{
mStaticIndexBuffer
=
new
StaticIndexBufferInterface
(
mFactory
)
;
}
}
void
BufferD3D
:
:
invalidateStaticData
(
)
{
if
(
(
mStaticVertexBuffer
&
&
mStaticVertexBuffer
-
>
getBufferSize
(
)
!
=
0
)
|
|
(
mStaticIndexBuffer
&
&
mStaticIndexBuffer
-
>
getBufferSize
(
)
!
=
0
)
)
{
SafeDelete
(
mStaticVertexBuffer
)
;
SafeDelete
(
mStaticIndexBuffer
)
;
initializeStaticData
(
)
;
}
mUnmodifiedDataUse
=
0
;
}
void
BufferD3D
:
:
promoteStaticUsage
(
int
dataSize
)
{
if
(
!
mStaticVertexBuffer
&
&
!
mStaticIndexBuffer
)
{
mUnmodifiedDataUse
+
=
dataSize
;
if
(
mUnmodifiedDataUse
>
3
*
getSize
(
)
)
{
initializeStaticData
(
)
;
}
}
}
gl
:
:
Error
BufferD3D
:
:
getIndexRange
(
GLenum
type
size_t
offset
size_t
count
gl
:
:
RangeUI
*
outRange
)
{
const
uint8_t
*
data
=
nullptr
;
gl
:
:
Error
error
=
getData
(
&
data
)
;
if
(
error
.
isError
(
)
)
{
return
error
;
}
*
outRange
=
gl
:
:
ComputeIndexRange
(
type
data
+
offset
count
)
;
return
gl
:
:
Error
(
GL_NO_ERROR
)
;
}
}
