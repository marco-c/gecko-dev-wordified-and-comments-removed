#
include
"
libANGLE
/
renderer
/
d3d
/
VaryingPacking
.
h
"
#
include
"
common
/
utilities
.
h
"
#
include
"
compiler
/
translator
/
blocklayoutHLSL
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
DynamicHLSL
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
ProgramD3D
.
h
"
namespace
rx
{
VaryingPacking
:
:
BuiltinVarying
:
:
BuiltinVarying
(
)
:
enabled
(
false
)
index
(
0
)
systemValue
(
false
)
{
}
std
:
:
string
VaryingPacking
:
:
BuiltinVarying
:
:
str
(
)
const
{
return
(
systemValue
?
semantic
:
(
semantic
+
Str
(
index
)
)
)
;
}
void
VaryingPacking
:
:
BuiltinVarying
:
:
enableSystem
(
const
std
:
:
string
&
systemValueSemantic
)
{
enabled
=
true
;
semantic
=
systemValueSemantic
;
systemValue
=
true
;
}
void
VaryingPacking
:
:
BuiltinVarying
:
:
enable
(
const
std
:
:
string
&
semanticVal
unsigned
int
indexVal
)
{
enabled
=
true
;
semantic
=
semanticVal
;
index
=
indexVal
;
}
VaryingPacking
:
:
VaryingPacking
(
GLuint
maxVaryingVectors
)
:
mRegisterMap
(
maxVaryingVectors
)
mBuiltinInfo
(
SHADER_TYPE_MAX
)
{
}
bool
VaryingPacking
:
:
packVarying
(
const
PackedVarying
&
packedVarying
)
{
unsigned
int
varyingRows
=
0
;
unsigned
int
varyingColumns
=
0
;
const
auto
&
varying
=
*
packedVarying
.
varying
;
ASSERT
(
!
varying
.
isStruct
(
)
)
;
GLenum
transposedType
=
gl
:
:
TransposeMatrixType
(
varying
.
type
)
;
varyingRows
=
gl
:
:
VariableRowCount
(
transposedType
)
;
varyingColumns
=
gl
:
:
VariableColumnCount
(
transposedType
)
;
varyingRows
*
=
varying
.
elementCount
(
)
;
unsigned
int
maxVaryingVectors
=
static_cast
<
unsigned
int
>
(
mRegisterMap
.
size
(
)
)
;
if
(
varyingRows
>
maxVaryingVectors
)
{
return
false
;
}
if
(
varyingColumns
>
=
2
&
&
varyingColumns
<
=
4
)
{
for
(
unsigned
int
row
=
0
;
row
<
=
maxVaryingVectors
-
varyingRows
;
+
+
row
)
{
if
(
isFree
(
row
0
varyingRows
varyingColumns
)
)
{
insert
(
row
0
packedVarying
)
;
return
true
;
}
}
if
(
varyingColumns
=
=
2
)
{
for
(
unsigned
int
r
=
maxVaryingVectors
-
varyingRows
+
1
;
r
-
-
>
=
1
;
)
{
if
(
isFree
(
r
2
varyingRows
2
)
)
{
insert
(
r
2
packedVarying
)
;
return
true
;
}
}
}
return
false
;
}
ASSERT
(
varyingColumns
=
=
1
)
;
unsigned
int
contiguousSpace
[
4
]
=
{
0
}
;
unsigned
int
bestContiguousSpace
[
4
]
=
{
0
}
;
unsigned
int
totalSpace
[
4
]
=
{
0
}
;
for
(
unsigned
int
row
=
0
;
row
<
maxVaryingVectors
;
+
+
row
)
{
for
(
unsigned
int
column
=
0
;
column
<
4
;
+
+
column
)
{
if
(
mRegisterMap
[
row
]
[
column
]
)
{
contiguousSpace
[
column
]
=
0
;
}
else
{
contiguousSpace
[
column
]
+
+
;
totalSpace
[
column
]
+
+
;
if
(
contiguousSpace
[
column
]
>
bestContiguousSpace
[
column
]
)
{
bestContiguousSpace
[
column
]
=
contiguousSpace
[
column
]
;
}
}
}
}
unsigned
int
bestColumn
=
0
;
for
(
unsigned
int
column
=
1
;
column
<
4
;
+
+
column
)
{
if
(
bestContiguousSpace
[
column
]
>
=
varyingRows
&
&
(
bestContiguousSpace
[
bestColumn
]
<
varyingRows
|
|
totalSpace
[
column
]
<
totalSpace
[
bestColumn
]
)
)
{
bestColumn
=
column
;
}
}
if
(
bestContiguousSpace
[
bestColumn
]
>
=
varyingRows
)
{
for
(
unsigned
int
row
=
0
;
row
<
maxVaryingVectors
;
row
+
+
)
{
if
(
isFree
(
row
bestColumn
varyingRows
1
)
)
{
for
(
unsigned
int
arrayIndex
=
0
;
arrayIndex
<
varyingRows
;
+
+
arrayIndex
)
{
PackedVaryingRegister
registerInfo
;
registerInfo
.
packedVarying
=
&
packedVarying
;
registerInfo
.
registerRow
=
row
+
arrayIndex
;
registerInfo
.
registerColumn
=
bestColumn
;
registerInfo
.
varyingArrayIndex
=
arrayIndex
;
registerInfo
.
varyingRowIndex
=
0
;
mRegisterList
.
push_back
(
registerInfo
)
;
mRegisterMap
[
row
+
arrayIndex
]
[
bestColumn
]
=
true
;
}
break
;
}
}
return
true
;
}
return
false
;
}
bool
VaryingPacking
:
:
isFree
(
unsigned
int
registerRow
unsigned
int
registerColumn
unsigned
int
varyingRows
unsigned
int
varyingColumns
)
const
{
for
(
unsigned
int
row
=
0
;
row
<
varyingRows
;
+
+
row
)
{
ASSERT
(
registerRow
+
row
<
mRegisterMap
.
size
(
)
)
;
for
(
unsigned
int
column
=
0
;
column
<
varyingColumns
;
+
+
column
)
{
ASSERT
(
registerColumn
+
column
<
4
)
;
if
(
mRegisterMap
[
registerRow
+
row
]
[
registerColumn
+
column
]
)
{
return
false
;
}
}
}
return
true
;
}
void
VaryingPacking
:
:
insert
(
unsigned
int
registerRow
unsigned
int
registerColumn
const
PackedVarying
&
packedVarying
)
{
unsigned
int
varyingRows
=
0
;
unsigned
int
varyingColumns
=
0
;
const
auto
&
varying
=
*
packedVarying
.
varying
;
ASSERT
(
!
varying
.
isStruct
(
)
)
;
GLenum
transposedType
=
gl
:
:
TransposeMatrixType
(
varying
.
type
)
;
varyingRows
=
gl
:
:
VariableRowCount
(
transposedType
)
;
varyingColumns
=
gl
:
:
VariableColumnCount
(
transposedType
)
;
PackedVaryingRegister
registerInfo
;
registerInfo
.
packedVarying
=
&
packedVarying
;
registerInfo
.
registerColumn
=
registerColumn
;
for
(
unsigned
int
arrayElement
=
0
;
arrayElement
<
varying
.
elementCount
(
)
;
+
+
arrayElement
)
{
for
(
unsigned
int
varyingRow
=
0
;
varyingRow
<
varyingRows
;
+
+
varyingRow
)
{
registerInfo
.
registerRow
=
registerRow
+
(
arrayElement
*
varyingRows
)
+
varyingRow
;
registerInfo
.
varyingRowIndex
=
varyingRow
;
registerInfo
.
varyingArrayIndex
=
arrayElement
;
mRegisterList
.
push_back
(
registerInfo
)
;
for
(
unsigned
int
columnIndex
=
0
;
columnIndex
<
varyingColumns
;
+
+
columnIndex
)
{
mRegisterMap
[
registerInfo
.
registerRow
]
[
registerColumn
+
columnIndex
]
=
true
;
}
}
}
}
bool
VaryingPacking
:
:
packVaryings
(
gl
:
:
InfoLog
&
infoLog
const
std
:
:
vector
<
PackedVarying
>
&
packedVaryings
const
std
:
:
vector
<
std
:
:
string
>
&
transformFeedbackVaryings
)
{
std
:
:
set
<
std
:
:
string
>
uniqueVaryingNames
;
for
(
const
PackedVarying
&
packedVarying
:
packedVaryings
)
{
const
auto
&
varying
=
*
packedVarying
.
varying
;
if
(
varying
.
isBuiltIn
(
)
|
|
(
!
varying
.
staticUse
&
&
!
packedVarying
.
isStructField
(
)
)
)
{
continue
;
}
ASSERT
(
!
varying
.
isStruct
(
)
)
;
ASSERT
(
uniqueVaryingNames
.
count
(
varying
.
name
)
=
=
0
)
;
if
(
packVarying
(
packedVarying
)
)
{
uniqueVaryingNames
.
insert
(
varying
.
name
)
;
}
else
{
infoLog
<
<
"
Could
not
pack
varying
"
<
<
varying
.
name
;
return
false
;
}
}
for
(
const
std
:
:
string
&
transformFeedbackVaryingName
:
transformFeedbackVaryings
)
{
if
(
transformFeedbackVaryingName
.
compare
(
0
3
"
gl_
"
)
=
=
0
)
{
continue
;
}
for
(
const
PackedVarying
&
packedVarying
:
packedVaryings
)
{
const
auto
&
varying
=
*
packedVarying
.
varying
;
if
(
uniqueVaryingNames
.
count
(
transformFeedbackVaryingName
)
=
=
0
)
{
bool
found
=
false
;
if
(
transformFeedbackVaryingName
=
=
varying
.
name
)
{
if
(
!
packVarying
(
packedVarying
)
)
{
infoLog
<
<
"
Could
not
pack
varying
"
<
<
varying
.
name
;
return
false
;
}
found
=
true
;
break
;
}
if
(
!
found
)
{
infoLog
<
<
"
Transform
feedback
varying
"
<
<
transformFeedbackVaryingName
<
<
"
does
not
exist
in
the
vertex
shader
.
"
;
return
false
;
}
}
}
}
std
:
:
sort
(
mRegisterList
.
begin
(
)
mRegisterList
.
end
(
)
)
;
for
(
unsigned
int
semanticIndex
=
0
;
semanticIndex
<
static_cast
<
unsigned
int
>
(
mRegisterList
.
size
(
)
)
;
+
+
semanticIndex
)
{
mRegisterList
[
semanticIndex
]
.
semanticIndex
=
semanticIndex
;
}
return
true
;
}
unsigned
int
VaryingPacking
:
:
getRegisterCount
(
)
const
{
unsigned
int
count
=
0
;
for
(
const
Register
&
reg
:
mRegisterMap
)
{
if
(
reg
.
data
[
0
]
|
|
reg
.
data
[
1
]
|
|
reg
.
data
[
2
]
|
|
reg
.
data
[
3
]
)
{
+
+
count
;
}
}
if
(
mBuiltinInfo
[
SHADER_PIXEL
]
.
glFragCoord
.
enabled
)
{
+
+
count
;
}
if
(
mBuiltinInfo
[
SHADER_PIXEL
]
.
glPointCoord
.
enabled
)
{
+
+
count
;
}
return
count
;
}
void
VaryingPacking
:
:
enableBuiltins
(
ShaderType
shaderType
const
ProgramD3DMetadata
&
programMetadata
)
{
int
majorShaderModel
=
programMetadata
.
getRendererMajorShaderModel
(
)
;
bool
position
=
programMetadata
.
usesTransformFeedbackGLPosition
(
)
;
bool
fragCoord
=
programMetadata
.
usesFragCoord
(
)
;
bool
pointCoord
=
shaderType
=
=
SHADER_VERTEX
?
programMetadata
.
addsPointCoordToVertexShader
(
)
:
programMetadata
.
usesPointCoord
(
)
;
bool
pointSize
=
programMetadata
.
usesSystemValuePointSize
(
)
;
bool
hlsl4
=
(
majorShaderModel
>
=
4
)
;
const
std
:
:
string
&
userSemantic
=
GetVaryingSemantic
(
majorShaderModel
pointSize
)
;
unsigned
int
reservedSemanticIndex
=
getMaxSemanticIndex
(
)
;
BuiltinInfo
*
builtins
=
&
mBuiltinInfo
[
shaderType
]
;
if
(
hlsl4
)
{
builtins
-
>
dxPosition
.
enableSystem
(
"
SV_Position
"
)
;
}
else
if
(
shaderType
=
=
SHADER_PIXEL
)
{
builtins
-
>
dxPosition
.
enableSystem
(
"
VPOS
"
)
;
}
else
{
builtins
-
>
dxPosition
.
enableSystem
(
"
POSITION
"
)
;
}
if
(
position
)
{
builtins
-
>
glPosition
.
enable
(
userSemantic
reservedSemanticIndex
+
+
)
;
}
if
(
fragCoord
)
{
builtins
-
>
glFragCoord
.
enable
(
userSemantic
reservedSemanticIndex
+
+
)
;
}
if
(
pointCoord
)
{
if
(
hlsl4
)
{
builtins
-
>
glPointCoord
.
enable
(
userSemantic
reservedSemanticIndex
+
+
)
;
}
else
{
builtins
-
>
glPointCoord
.
enable
(
"
TEXCOORD
"
0
)
;
}
}
if
(
pointSize
&
&
(
shaderType
!
=
SHADER_PIXEL
|
|
hlsl4
)
)
{
builtins
-
>
glPointSize
.
enableSystem
(
"
PSIZE
"
)
;
}
}
}
