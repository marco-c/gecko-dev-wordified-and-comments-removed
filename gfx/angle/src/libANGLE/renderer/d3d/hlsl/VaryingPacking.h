#
ifndef
LIBANGLE_RENDERER_D3D_HLSL_VARYINGPACKING_H_
#
define
LIBANGLE_RENDERER_D3D_HLSL_VARYINGPACKING_H_
#
include
<
GLSLANG
/
ShaderVars
.
h
>
#
include
"
angle_gl
.
h
"
#
include
"
common
/
angleutils
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
hlsl
/
hlsl_utils
.
h
"
namespace
gl
{
class
InfoLog
;
}
namespace
rx
{
struct
PackedVarying
{
PackedVarying
(
const
sh
:
:
ShaderVariable
&
varyingIn
sh
:
:
InterpolationType
interpolationIn
)
:
varying
(
&
varyingIn
)
vertexOnly
(
false
)
interpolation
(
interpolationIn
)
{
}
PackedVarying
(
const
sh
:
:
ShaderVariable
&
varyingIn
sh
:
:
InterpolationType
interpolationIn
const
std
:
:
string
&
parentStructNameIn
)
:
varying
(
&
varyingIn
)
vertexOnly
(
false
)
interpolation
(
interpolationIn
)
parentStructName
(
parentStructNameIn
)
{
}
bool
isStructField
(
)
const
{
return
!
parentStructName
.
empty
(
)
;
}
const
sh
:
:
ShaderVariable
*
varying
;
bool
vertexOnly
;
sh
:
:
InterpolationType
interpolation
;
std
:
:
string
parentStructName
;
}
;
struct
PackedVaryingRegister
final
{
PackedVaryingRegister
(
)
:
packedVarying
(
nullptr
)
varyingArrayIndex
(
0
)
varyingRowIndex
(
0
)
registerRow
(
0
)
registerColumn
(
0
)
{
}
PackedVaryingRegister
(
const
PackedVaryingRegister
&
)
=
default
;
PackedVaryingRegister
&
operator
=
(
const
PackedVaryingRegister
&
)
=
default
;
bool
operator
<
(
const
PackedVaryingRegister
&
other
)
const
{
return
sortOrder
(
)
<
other
.
sortOrder
(
)
;
}
unsigned
int
sortOrder
(
)
const
{
return
registerRow
*
4
+
registerColumn
;
}
bool
isStructField
(
)
const
{
return
!
structFieldName
.
empty
(
)
;
}
const
PackedVarying
*
packedVarying
;
unsigned
int
varyingArrayIndex
;
unsigned
int
varyingRowIndex
;
unsigned
int
registerRow
;
unsigned
int
registerColumn
;
unsigned
int
semanticIndex
;
std
:
:
string
structFieldName
;
}
;
class
VaryingPacking
final
:
angle
:
:
NonCopyable
{
public
:
VaryingPacking
(
GLuint
maxVaryingVectors
)
;
bool
packUserVaryings
(
gl
:
:
InfoLog
&
infoLog
const
std
:
:
vector
<
PackedVarying
>
&
packedVaryings
const
std
:
:
vector
<
std
:
:
string
>
&
transformFeedbackVaryings
)
;
bool
validateBuiltins
(
)
const
;
struct
Register
{
Register
(
)
{
data
[
0
]
=
data
[
1
]
=
data
[
2
]
=
data
[
3
]
=
false
;
}
bool
&
operator
[
]
(
unsigned
int
index
)
{
return
data
[
index
]
;
}
bool
operator
[
]
(
unsigned
int
index
)
const
{
return
data
[
index
]
;
}
bool
data
[
4
]
;
}
;
Register
&
operator
[
]
(
unsigned
int
index
)
{
return
mRegisterMap
[
index
]
;
}
const
Register
&
operator
[
]
(
unsigned
int
index
)
const
{
return
mRegisterMap
[
index
]
;
}
const
std
:
:
vector
<
PackedVaryingRegister
>
&
getRegisterList
(
)
const
{
return
mRegisterList
;
}
unsigned
int
getMaxSemanticIndex
(
)
const
{
return
static_cast
<
unsigned
int
>
(
mRegisterList
.
size
(
)
)
;
}
unsigned
int
getRegisterCount
(
)
const
;
struct
BuiltinVarying
final
:
angle
:
:
NonCopyable
{
BuiltinVarying
(
)
;
std
:
:
string
str
(
)
const
;
void
enableSystem
(
const
std
:
:
string
&
systemValueSemantic
)
;
void
enable
(
const
std
:
:
string
&
semanticVal
unsigned
int
indexVal
)
;
bool
enabled
;
std
:
:
string
semantic
;
unsigned
int
index
;
bool
systemValue
;
}
;
struct
BuiltinInfo
{
BuiltinVarying
dxPosition
;
BuiltinVarying
glPosition
;
BuiltinVarying
glFragCoord
;
BuiltinVarying
glPointCoord
;
BuiltinVarying
glPointSize
;
}
;
const
BuiltinInfo
&
builtins
(
ShaderType
shaderType
)
const
{
return
mBuiltinInfo
[
shaderType
]
;
}
BuiltinInfo
&
builtins
(
ShaderType
shaderType
)
{
return
mBuiltinInfo
[
shaderType
]
;
}
bool
usesPointSize
(
)
const
{
return
mBuiltinInfo
[
SHADER_VERTEX
]
.
glPointSize
.
enabled
;
}
private
:
bool
packVarying
(
const
PackedVarying
&
packedVarying
)
;
bool
isFree
(
unsigned
int
registerRow
unsigned
int
registerColumn
unsigned
int
varyingRows
unsigned
int
varyingColumns
)
const
;
void
insert
(
unsigned
int
registerRow
unsigned
int
registerColumn
const
PackedVarying
&
packedVarying
)
;
std
:
:
vector
<
Register
>
mRegisterMap
;
std
:
:
vector
<
PackedVaryingRegister
>
mRegisterList
;
std
:
:
vector
<
BuiltinInfo
>
mBuiltinInfo
;
}
;
}
#
endif
