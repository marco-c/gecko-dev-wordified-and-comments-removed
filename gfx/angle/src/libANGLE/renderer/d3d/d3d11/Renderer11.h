#
ifndef
LIBANGLE_RENDERER_D3D_D3D11_RENDERER11_H_
#
define
LIBANGLE_RENDERER_D3D_D3D11_RENDERER11_H_
#
include
"
common
/
angleutils
.
h
"
#
include
"
common
/
mathutil
.
h
"
#
include
"
libANGLE
/
AttributeMap
.
h
"
#
include
"
libANGLE
/
angletypes
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
HLSLCompiler
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
RendererD3D
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
RenderTargetD3D
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
DebugAnnotator11
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
InputLayoutCache
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
RenderStateCache
.
h
"
namespace
gl
{
class
FramebufferAttachment
;
struct
ImageIndex
;
}
namespace
rx
{
class
VertexDataManager
;
class
IndexDataManager
;
class
StreamingIndexBufferInterface
;
class
Blit11
;
class
Buffer11
;
class
Clear11
;
class
PixelTransfer11
;
class
RenderTarget11
;
class
Trim11
;
struct
PackPixelsParams
;
struct
Renderer11DeviceCaps
{
D3D_FEATURE_LEVEL
featureLevel
;
bool
supportsDXGI1_2
;
bool
supportsClearView
;
bool
supportsConstantBufferOffsets
;
UINT
B5G6R5support
;
UINT
B4G4R4A4support
;
UINT
B5G5R5A1support
;
}
;
enum
{
MAX_VERTEX_UNIFORM_VECTORS_D3D11
=
1024
MAX_FRAGMENT_UNIFORM_VECTORS_D3D11
=
1024
}
;
enum
D3D11InitError
{
D3D11_INIT_SUCCESS
=
0
D3D11_INIT_COMPILER_ERROR
D3D11_INIT_MISSING_DEP
D3D11_INIT_CREATEDEVICE_INVALIDARG
D3D11_INIT_CREATEDEVICE_ERROR
D3D11_INIT_INCOMPATIBLE_DXGI
D3D11_INIT_OTHER_ERROR
D3D11_INIT_CREATEDEVICE_FAIL
D3D11_INIT_CREATEDEVICE_NOTIMPL
D3D11_INIT_CREATEDEVICE_OUTOFMEMORY
D3D11_INIT_CREATEDEVICE_INVALIDCALL
D3D11_INIT_CREATEDEVICE_COMPONENTMISSING
D3D11_INIT_CREATEDEVICE_WASSTILLDRAWING
D3D11_INIT_CREATEDEVICE_NOTAVAILABLE
D3D11_INIT_CREATEDEVICE_DEVICEHUNG
D3D11_INIT_CREATEDEVICE_NULL
NUM_D3D11_INIT_ERRORS
}
;
class
Renderer11
:
public
RendererD3D
{
public
:
explicit
Renderer11
(
egl
:
:
Display
*
display
)
;
virtual
~
Renderer11
(
)
;
egl
:
:
Error
initialize
(
)
override
;
virtual
bool
resetDevice
(
)
;
egl
:
:
ConfigSet
generateConfigs
(
)
const
override
;
gl
:
:
Error
flush
(
)
override
;
gl
:
:
Error
finish
(
)
override
;
virtual
SwapChainD3D
*
createSwapChain
(
NativeWindow
nativeWindow
HANDLE
shareHandle
GLenum
backBufferFormat
GLenum
depthBufferFormat
)
;
virtual
gl
:
:
Error
generateSwizzle
(
gl
:
:
Texture
*
texture
)
;
virtual
gl
:
:
Error
setSamplerState
(
gl
:
:
SamplerType
type
int
index
gl
:
:
Texture
*
texture
const
gl
:
:
SamplerState
&
sampler
)
;
virtual
gl
:
:
Error
setTexture
(
gl
:
:
SamplerType
type
int
index
gl
:
:
Texture
*
texture
)
;
gl
:
:
Error
setUniformBuffers
(
const
gl
:
:
Data
&
data
const
std
:
:
vector
<
GLint
>
&
vertexUniformBuffers
const
std
:
:
vector
<
GLint
>
&
fragmentUniformBuffers
)
override
;
virtual
gl
:
:
Error
setRasterizerState
(
const
gl
:
:
RasterizerState
&
rasterState
)
;
gl
:
:
Error
setBlendState
(
const
gl
:
:
Framebuffer
*
framebuffer
const
gl
:
:
BlendState
&
blendState
const
gl
:
:
ColorF
&
blendColor
unsigned
int
sampleMask
)
override
;
virtual
gl
:
:
Error
setDepthStencilState
(
const
gl
:
:
DepthStencilState
&
depthStencilState
int
stencilRef
int
stencilBackRef
bool
frontFaceCCW
)
;
virtual
void
setScissorRectangle
(
const
gl
:
:
Rectangle
&
scissor
bool
enabled
)
;
virtual
void
setViewport
(
const
gl
:
:
Rectangle
&
viewport
float
zNear
float
zFar
GLenum
drawMode
GLenum
frontFace
bool
ignoreViewport
)
;
virtual
bool
applyPrimitiveType
(
GLenum
mode
GLsizei
count
bool
usesPointSize
)
;
gl
:
:
Error
applyRenderTarget
(
const
gl
:
:
Framebuffer
*
frameBuffer
)
override
;
gl
:
:
Error
applyShaders
(
gl
:
:
Program
*
program
const
gl
:
:
Framebuffer
*
framebuffer
bool
rasterizerDiscard
bool
transformFeedbackActive
)
override
;
virtual
gl
:
:
Error
applyUniforms
(
const
ProgramImpl
&
program
const
std
:
:
vector
<
gl
:
:
LinkedUniform
*
>
&
uniformArray
)
;
virtual
gl
:
:
Error
applyVertexBuffer
(
const
gl
:
:
State
&
state
GLenum
mode
GLint
first
GLsizei
count
GLsizei
instances
SourceIndexData
*
sourceIndexInfo
)
;
virtual
gl
:
:
Error
applyIndexBuffer
(
const
GLvoid
*
indices
gl
:
:
Buffer
*
elementArrayBuffer
GLsizei
count
GLenum
mode
GLenum
type
TranslatedIndexData
*
indexInfo
SourceIndexData
*
sourceIndexInfo
)
;
void
applyTransformFeedbackBuffers
(
const
gl
:
:
State
&
state
)
override
;
gl
:
:
Error
drawArrays
(
const
gl
:
:
Data
&
data
GLenum
mode
GLsizei
count
GLsizei
instances
bool
usesPointSize
)
override
;
virtual
gl
:
:
Error
drawElements
(
GLenum
mode
GLsizei
count
GLenum
type
const
GLvoid
*
indices
gl
:
:
Buffer
*
elementArrayBuffer
const
TranslatedIndexData
&
indexInfo
GLsizei
instances
bool
usesPointSize
)
;
virtual
void
markAllStateDirty
(
)
;
bool
testDeviceLost
(
)
override
;
bool
testDeviceResettable
(
)
override
;
VendorID
getVendorId
(
)
const
override
;
SIZE_T
getMaxResourceSize
(
)
const
;
std
:
:
string
getRendererDescription
(
)
const
override
;
DeviceIdentifier
getAdapterIdentifier
(
)
const
override
;
virtual
unsigned
int
getReservedVertexUniformVectors
(
)
const
;
virtual
unsigned
int
getReservedFragmentUniformVectors
(
)
const
;
virtual
unsigned
int
getReservedVertexUniformBuffers
(
)
const
;
virtual
unsigned
int
getReservedFragmentUniformBuffers
(
)
const
;
virtual
bool
getShareHandleSupport
(
)
const
;
bool
getKeyedMutexSupport
(
)
const
override
;
virtual
bool
getPostSubBufferSupport
(
)
const
;
virtual
int
getMajorShaderModel
(
)
const
;
int
getMinorShaderModel
(
)
const
override
;
std
:
:
string
getShaderModelSuffix
(
)
const
override
;
virtual
gl
:
:
Error
copyImage2D
(
const
gl
:
:
Framebuffer
*
framebuffer
const
gl
:
:
Rectangle
&
sourceRect
GLenum
destFormat
const
gl
:
:
Offset
&
destOffset
TextureStorage
*
storage
GLint
level
)
;
virtual
gl
:
:
Error
copyImageCube
(
const
gl
:
:
Framebuffer
*
framebuffer
const
gl
:
:
Rectangle
&
sourceRect
GLenum
destFormat
const
gl
:
:
Offset
&
destOffset
TextureStorage
*
storage
GLenum
target
GLint
level
)
;
virtual
gl
:
:
Error
copyImage3D
(
const
gl
:
:
Framebuffer
*
framebuffer
const
gl
:
:
Rectangle
&
sourceRect
GLenum
destFormat
const
gl
:
:
Offset
&
destOffset
TextureStorage
*
storage
GLint
level
)
;
virtual
gl
:
:
Error
copyImage2DArray
(
const
gl
:
:
Framebuffer
*
framebuffer
const
gl
:
:
Rectangle
&
sourceRect
GLenum
destFormat
const
gl
:
:
Offset
&
destOffset
TextureStorage
*
storage
GLint
level
)
;
virtual
gl
:
:
Error
createRenderTarget
(
int
width
int
height
GLenum
format
GLsizei
samples
RenderTargetD3D
*
*
outRT
)
;
FramebufferImpl
*
createDefaultFramebuffer
(
const
gl
:
:
Framebuffer
:
:
Data
&
data
)
override
;
FramebufferImpl
*
createFramebuffer
(
const
gl
:
:
Framebuffer
:
:
Data
&
data
)
override
;
virtual
CompilerImpl
*
createCompiler
(
const
gl
:
:
Data
&
data
)
;
virtual
ShaderImpl
*
createShader
(
GLenum
type
)
;
virtual
ProgramImpl
*
createProgram
(
)
;
virtual
gl
:
:
Error
loadExecutable
(
const
void
*
function
size_t
length
ShaderType
type
const
std
:
:
vector
<
gl
:
:
LinkedVarying
>
&
transformFeedbackVaryings
bool
separatedOutputBuffers
ShaderExecutableD3D
*
*
outExecutable
)
;
virtual
gl
:
:
Error
compileToExecutable
(
gl
:
:
InfoLog
&
infoLog
const
std
:
:
string
&
shaderHLSL
ShaderType
type
const
std
:
:
vector
<
gl
:
:
LinkedVarying
>
&
transformFeedbackVaryings
bool
separatedOutputBuffers
const
D3DCompilerWorkarounds
&
workarounds
ShaderExecutableD3D
*
*
outExectuable
)
;
virtual
UniformStorageD3D
*
createUniformStorage
(
size_t
storageSize
)
;
virtual
ImageD3D
*
createImage
(
)
;
gl
:
:
Error
generateMipmap
(
ImageD3D
*
dest
ImageD3D
*
source
)
override
;
gl
:
:
Error
generateMipmapsUsingD3D
(
TextureStorage
*
storage
const
gl
:
:
SamplerState
&
samplerState
)
override
;
virtual
TextureStorage
*
createTextureStorage2D
(
SwapChainD3D
*
swapChain
)
;
virtual
TextureStorage
*
createTextureStorage2D
(
GLenum
internalformat
bool
renderTarget
GLsizei
width
GLsizei
height
int
levels
bool
hintLevelZeroOnly
)
;
virtual
TextureStorage
*
createTextureStorageCube
(
GLenum
internalformat
bool
renderTarget
int
size
int
levels
bool
hintLevelZeroOnly
)
;
virtual
TextureStorage
*
createTextureStorage3D
(
GLenum
internalformat
bool
renderTarget
GLsizei
width
GLsizei
height
GLsizei
depth
int
levels
)
;
virtual
TextureStorage
*
createTextureStorage2DArray
(
GLenum
internalformat
bool
renderTarget
GLsizei
width
GLsizei
height
GLsizei
depth
int
levels
)
;
virtual
TextureImpl
*
createTexture
(
GLenum
target
)
;
virtual
RenderbufferImpl
*
createRenderbuffer
(
)
;
virtual
BufferImpl
*
createBuffer
(
)
;
virtual
VertexBuffer
*
createVertexBuffer
(
)
;
virtual
IndexBuffer
*
createIndexBuffer
(
)
;
VertexArrayImpl
*
createVertexArray
(
const
gl
:
:
VertexArray
:
:
Data
&
data
)
override
;
virtual
QueryImpl
*
createQuery
(
GLenum
type
)
;
virtual
FenceNVImpl
*
createFenceNV
(
)
;
virtual
FenceSyncImpl
*
createFenceSync
(
)
;
virtual
TransformFeedbackImpl
*
createTransformFeedback
(
)
;
ID3D11Device
*
getDevice
(
)
{
return
mDevice
;
}
void
*
getD3DDevice
(
)
override
;
ID3D11DeviceContext
*
getDeviceContext
(
)
{
return
mDeviceContext
;
}
;
ID3D11DeviceContext1
*
getDeviceContext1IfSupported
(
)
{
return
mDeviceContext1
;
}
;
DXGIFactory
*
getDxgiFactory
(
)
{
return
mDxgiFactory
;
}
;
Blit11
*
getBlitter
(
)
{
return
mBlit
;
}
Clear11
*
getClearer
(
)
{
return
mClear
;
}
virtual
bool
supportsFastCopyBufferToTexture
(
GLenum
internalFormat
)
const
;
virtual
gl
:
:
Error
fastCopyBufferToTexture
(
const
gl
:
:
PixelUnpackState
&
unpack
unsigned
int
offset
RenderTargetD3D
*
destRenderTarget
GLenum
destinationFormat
GLenum
sourcePixelsType
const
gl
:
:
Box
&
destArea
)
;
void
unapplyRenderTargets
(
)
;
void
setOneTimeRenderTarget
(
ID3D11RenderTargetView
*
renderTargetView
)
;
gl
:
:
Error
packPixels
(
ID3D11Texture2D
*
readTexture
const
PackPixelsParams
&
params
uint8_t
*
pixelsOut
)
;
bool
getLUID
(
LUID
*
adapterLuid
)
const
override
;
VertexConversionType
getVertexConversionType
(
gl
:
:
VertexFormatType
vertexFormatType
)
const
override
;
GLenum
getVertexComponentType
(
gl
:
:
VertexFormatType
vertexFormatType
)
const
override
;
gl
:
:
Error
readTextureData
(
ID3D11Texture2D
*
texture
unsigned
int
subResource
const
gl
:
:
Rectangle
&
area
GLenum
format
GLenum
type
GLuint
outputPitch
const
gl
:
:
PixelPackState
&
pack
uint8_t
*
pixels
)
;
void
setShaderResource
(
gl
:
:
SamplerType
shaderType
UINT
resourceSlot
ID3D11ShaderResourceView
*
srv
)
;
gl
:
:
Error
blitRenderbufferRect
(
const
gl
:
:
Rectangle
&
readRect
const
gl
:
:
Rectangle
&
drawRect
RenderTargetD3D
*
readRenderTarget
RenderTargetD3D
*
drawRenderTarget
GLenum
filter
const
gl
:
:
Rectangle
*
scissor
bool
colorBlit
bool
depthBlit
bool
stencilBlit
)
;
bool
isES3Capable
(
)
const
;
const
Renderer11DeviceCaps
&
getRenderer11DeviceCaps
(
)
{
return
mRenderer11DeviceCaps
;
}
;
RendererClass
getRendererClass
(
)
const
override
{
return
RENDERER_D3D11
;
}
InputLayoutCache
*
getInputLayoutCache
(
)
{
return
&
mInputLayoutCache
;
}
void
onSwap
(
)
;
void
onBufferDelete
(
const
Buffer11
*
deleted
)
;
protected
:
void
createAnnotator
(
)
override
;
gl
:
:
Error
clearTextures
(
gl
:
:
SamplerType
samplerType
size_t
rangeStart
size_t
rangeEnd
)
override
;
private
:
void
generateCaps
(
gl
:
:
Caps
*
outCaps
gl
:
:
TextureCapsMap
*
outTextureCaps
gl
:
:
Extensions
*
outExtensions
gl
:
:
Limitations
*
outLimitations
)
const
override
;
Workarounds
generateWorkarounds
(
)
const
override
;
gl
:
:
Error
drawLineLoop
(
GLsizei
count
GLenum
type
const
GLvoid
*
indices
int
minIndex
gl
:
:
Buffer
*
elementArrayBuffer
)
;
gl
:
:
Error
drawTriangleFan
(
GLsizei
count
GLenum
type
const
GLvoid
*
indices
int
minIndex
gl
:
:
Buffer
*
elementArrayBuffer
int
instances
)
;
ID3D11Texture2D
*
resolveMultisampledTexture
(
ID3D11Texture2D
*
source
unsigned
int
subresource
)
;
void
unsetConflictingSRVs
(
gl
:
:
SamplerType
shaderType
uintptr_t
resource
const
gl
:
:
ImageIndex
&
index
)
;
void
populateRenderer11DeviceCaps
(
)
;
void
updateHistograms
(
)
;
HMODULE
mD3d11Module
;
HMODULE
mDxgiModule
;
std
:
:
vector
<
D3D_FEATURE_LEVEL
>
mAvailableFeatureLevels
;
D3D_DRIVER_TYPE
mDriverType
;
HLSLCompiler
mCompiler
;
void
initializeDevice
(
)
;
void
releaseDeviceResources
(
)
;
void
release
(
)
;
RenderStateCache
mStateCache
;
uintptr_t
mAppliedRTVs
[
gl
:
:
IMPLEMENTATION_MAX_DRAW_BUFFERS
]
;
uintptr_t
mAppliedDSV
;
bool
mDepthStencilInitialized
;
bool
mRenderTargetDescInitialized
;
struct
RenderTargetDesc
{
size_t
width
;
size_t
height
;
DXGI_FORMAT
format
;
}
;
RenderTargetDesc
mRenderTargetDesc
;
std
:
:
vector
<
bool
>
mForceSetVertexSamplerStates
;
std
:
:
vector
<
gl
:
:
SamplerState
>
mCurVertexSamplerStates
;
std
:
:
vector
<
bool
>
mForceSetPixelSamplerStates
;
std
:
:
vector
<
gl
:
:
SamplerState
>
mCurPixelSamplerStates
;
struct
SRVRecord
{
uintptr_t
srv
;
uintptr_t
resource
;
D3D11_SHADER_RESOURCE_VIEW_DESC
desc
;
}
;
class
SRVCache
:
angle
:
:
NonCopyable
{
public
:
SRVCache
(
)
:
mHighestUsedSRV
(
0
)
{
}
void
initialize
(
size_t
size
)
{
mCurrentSRVs
.
resize
(
size
)
;
}
size_t
size
(
)
const
{
return
mCurrentSRVs
.
size
(
)
;
}
size_t
highestUsed
(
)
const
{
return
mHighestUsedSRV
;
}
const
SRVRecord
&
operator
[
]
(
size_t
index
)
const
{
return
mCurrentSRVs
[
index
]
;
}
void
clear
(
)
;
void
update
(
size_t
resourceIndex
ID3D11ShaderResourceView
*
srv
)
;
private
:
std
:
:
vector
<
SRVRecord
>
mCurrentSRVs
;
size_t
mHighestUsedSRV
;
}
;
SRVCache
mCurVertexSRVs
;
SRVCache
mCurPixelSRVs
;
std
:
:
vector
<
ID3D11ShaderResourceView
*
>
mNullSRVs
;
bool
mForceSetBlendState
;
gl
:
:
BlendState
mCurBlendState
;
gl
:
:
ColorF
mCurBlendColor
;
unsigned
int
mCurSampleMask
;
bool
mForceSetRasterState
;
gl
:
:
RasterizerState
mCurRasterState
;
bool
mForceSetDepthStencilState
;
gl
:
:
DepthStencilState
mCurDepthStencilState
;
int
mCurStencilRef
;
int
mCurStencilBackRef
;
bool
mForceSetScissor
;
bool
mScissorEnabled
;
gl
:
:
Rectangle
mCurScissor
;
bool
mForceSetViewport
;
gl
:
:
Rectangle
mCurViewport
;
float
mCurNear
;
float
mCurFar
;
D3D11_PRIMITIVE_TOPOLOGY
mCurrentPrimitiveTopology
;
ID3D11Buffer
*
mAppliedIB
;
DXGI_FORMAT
mAppliedIBFormat
;
unsigned
int
mAppliedIBOffset
;
bool
mAppliedIBChanged
;
size_t
mAppliedNumXFBBindings
;
ID3D11Buffer
*
mAppliedTFBuffers
[
gl
:
:
IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_BUFFERS
]
;
GLintptr
mAppliedTFOffsets
[
gl
:
:
IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_BUFFERS
]
;
UINT
mCurrentD3DOffsets
[
gl
:
:
IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_BUFFERS
]
;
uintptr_t
mAppliedVertexShader
;
uintptr_t
mAppliedGeometryShader
;
uintptr_t
mAppliedPixelShader
;
dx_VertexConstants
mVertexConstants
;
dx_VertexConstants
mAppliedVertexConstants
;
ID3D11Buffer
*
mDriverConstantBufferVS
;
ID3D11Buffer
*
mCurrentVertexConstantBuffer
;
unsigned
int
mCurrentConstantBufferVS
[
gl
:
:
IMPLEMENTATION_MAX_VERTEX_SHADER_UNIFORM_BUFFERS
]
;
GLintptr
mCurrentConstantBufferVSOffset
[
gl
:
:
IMPLEMENTATION_MAX_VERTEX_SHADER_UNIFORM_BUFFERS
]
;
GLsizeiptr
mCurrentConstantBufferVSSize
[
gl
:
:
IMPLEMENTATION_MAX_VERTEX_SHADER_UNIFORM_BUFFERS
]
;
dx_PixelConstants
mPixelConstants
;
dx_PixelConstants
mAppliedPixelConstants
;
ID3D11Buffer
*
mDriverConstantBufferPS
;
ID3D11Buffer
*
mCurrentPixelConstantBuffer
;
unsigned
int
mCurrentConstantBufferPS
[
gl
:
:
IMPLEMENTATION_MAX_FRAGMENT_SHADER_UNIFORM_BUFFERS
]
;
GLintptr
mCurrentConstantBufferPSOffset
[
gl
:
:
IMPLEMENTATION_MAX_FRAGMENT_SHADER_UNIFORM_BUFFERS
]
;
GLsizeiptr
mCurrentConstantBufferPSSize
[
gl
:
:
IMPLEMENTATION_MAX_FRAGMENT_SHADER_UNIFORM_BUFFERS
]
;
ID3D11Buffer
*
mCurrentGeometryConstantBuffer
;
VertexDataManager
*
mVertexDataManager
;
IndexDataManager
*
mIndexDataManager
;
InputLayoutCache
mInputLayoutCache
;
StreamingIndexBufferInterface
*
mLineLoopIB
;
StreamingIndexBufferInterface
*
mTriangleFanIB
;
Blit11
*
mBlit
;
PixelTransfer11
*
mPixelTransfer
;
Clear11
*
mClear
;
Trim11
*
mTrim
;
ID3D11Query
*
mSyncQuery
;
std
:
:
set
<
const
Buffer11
*
>
mAliveBuffers
;
double
mLastHistogramUpdateTime
;
ID3D11Device
*
mDevice
;
Renderer11DeviceCaps
mRenderer11DeviceCaps
;
ID3D11DeviceContext
*
mDeviceContext
;
ID3D11DeviceContext1
*
mDeviceContext1
;
IDXGIAdapter
*
mDxgiAdapter
;
DXGI_ADAPTER_DESC
mAdapterDescription
;
char
mDescription
[
128
]
;
DXGIFactory
*
mDxgiFactory
;
ID3D11Debug
*
mDebug
;
}
;
}
#
endif
