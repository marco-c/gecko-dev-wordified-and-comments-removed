#
include
"
libANGLE
/
renderer
/
d3d
/
HLSLCompiler
.
h
"
#
include
"
common
/
utilities
.
h
"
#
include
"
libANGLE
/
Program
.
h
"
#
include
"
libANGLE
/
features
.
h
"
#
include
"
libANGLE
/
histogram_macros
.
h
"
#
include
"
third_party
/
trace_event
/
trace_event
.
h
"
#
if
ANGLE_APPEND_ASSEMBLY_TO_SHADER_DEBUG_INFO
=
=
ANGLE_ENABLED
namespace
{
#
ifdef
CREATE_COMPILER_FLAG_INFO
#
undef
CREATE_COMPILER_FLAG_INFO
#
endif
#
define
CREATE_COMPILER_FLAG_INFO
(
flag
)
{
flag
#
flag
}
struct
CompilerFlagInfo
{
UINT
mFlag
;
const
char
*
mName
;
}
;
CompilerFlagInfo
CompilerFlagInfos
[
]
=
{
CREATE_COMPILER_FLAG_INFO
(
D3DCOMPILE_DEBUG
)
CREATE_COMPILER_FLAG_INFO
(
D3DCOMPILE_SKIP_VALIDATION
)
CREATE_COMPILER_FLAG_INFO
(
D3DCOMPILE_SKIP_OPTIMIZATION
)
CREATE_COMPILER_FLAG_INFO
(
D3DCOMPILE_PACK_MATRIX_ROW_MAJOR
)
CREATE_COMPILER_FLAG_INFO
(
D3DCOMPILE_PACK_MATRIX_COLUMN_MAJOR
)
CREATE_COMPILER_FLAG_INFO
(
D3DCOMPILE_PARTIAL_PRECISION
)
CREATE_COMPILER_FLAG_INFO
(
D3DCOMPILE_FORCE_VS_SOFTWARE_NO_OPT
)
CREATE_COMPILER_FLAG_INFO
(
D3DCOMPILE_FORCE_PS_SOFTWARE_NO_OPT
)
CREATE_COMPILER_FLAG_INFO
(
D3DCOMPILE_NO_PRESHADER
)
CREATE_COMPILER_FLAG_INFO
(
D3DCOMPILE_AVOID_FLOW_CONTROL
)
CREATE_COMPILER_FLAG_INFO
(
D3DCOMPILE_PREFER_FLOW_CONTROL
)
CREATE_COMPILER_FLAG_INFO
(
D3DCOMPILE_ENABLE_STRICTNESS
)
CREATE_COMPILER_FLAG_INFO
(
D3DCOMPILE_ENABLE_BACKWARDS_COMPATIBILITY
)
CREATE_COMPILER_FLAG_INFO
(
D3DCOMPILE_IEEE_STRICTNESS
)
CREATE_COMPILER_FLAG_INFO
(
D3DCOMPILE_OPTIMIZATION_LEVEL0
)
CREATE_COMPILER_FLAG_INFO
(
D3DCOMPILE_OPTIMIZATION_LEVEL1
)
CREATE_COMPILER_FLAG_INFO
(
D3DCOMPILE_OPTIMIZATION_LEVEL2
)
CREATE_COMPILER_FLAG_INFO
(
D3DCOMPILE_OPTIMIZATION_LEVEL3
)
CREATE_COMPILER_FLAG_INFO
(
D3DCOMPILE_RESERVED16
)
CREATE_COMPILER_FLAG_INFO
(
D3DCOMPILE_RESERVED17
)
CREATE_COMPILER_FLAG_INFO
(
D3DCOMPILE_WARNINGS_ARE_ERRORS
)
}
;
#
undef
CREATE_COMPILER_FLAG_INFO
bool
IsCompilerFlagSet
(
UINT
mask
UINT
flag
)
{
bool
isFlagSet
=
IsMaskFlagSet
(
mask
flag
)
;
switch
(
flag
)
{
case
D3DCOMPILE_OPTIMIZATION_LEVEL0
:
return
isFlagSet
&
&
!
IsMaskFlagSet
(
mask
UINT
(
D3DCOMPILE_OPTIMIZATION_LEVEL3
)
)
;
case
D3DCOMPILE_OPTIMIZATION_LEVEL1
:
return
(
mask
&
D3DCOMPILE_OPTIMIZATION_LEVEL2
)
=
=
UINT
(
0
)
;
case
D3DCOMPILE_OPTIMIZATION_LEVEL3
:
return
isFlagSet
&
&
!
IsMaskFlagSet
(
mask
UINT
(
D3DCOMPILE_OPTIMIZATION_LEVEL0
)
)
;
default
:
return
isFlagSet
;
}
}
}
#
endif
namespace
rx
{
CompileConfig
:
:
CompileConfig
(
)
:
flags
(
0
)
name
(
)
{
}
CompileConfig
:
:
CompileConfig
(
UINT
flags
const
std
:
:
string
&
name
)
:
flags
(
flags
)
name
(
name
)
{
}
HLSLCompiler
:
:
HLSLCompiler
(
)
:
mInitialized
(
false
)
mD3DCompilerModule
(
nullptr
)
mD3DCompileFunc
(
nullptr
)
mD3DDisassembleFunc
(
nullptr
)
{
}
HLSLCompiler
:
:
~
HLSLCompiler
(
)
{
release
(
)
;
}
gl
:
:
Error
HLSLCompiler
:
:
initialize
(
)
{
if
(
mInitialized
)
{
return
gl
:
:
Error
(
GL_NO_ERROR
)
;
}
TRACE_EVENT0
(
"
gpu
.
angle
"
"
HLSLCompiler
:
:
initialize
"
)
;
#
if
!
defined
(
ANGLE_ENABLE_WINDOWS_STORE
)
#
if
defined
(
ANGLE_PRELOADED_D3DCOMPILER_MODULE_NAMES
)
static
const
char
*
d3dCompilerNames
[
]
=
ANGLE_PRELOADED_D3DCOMPILER_MODULE_NAMES
;
for
(
size_t
i
=
0
;
i
<
ArraySize
(
d3dCompilerNames
)
;
+
+
i
)
{
if
(
GetModuleHandleExA
(
0
d3dCompilerNames
[
i
]
&
mD3DCompilerModule
)
)
{
break
;
}
}
#
endif
if
(
!
mD3DCompilerModule
)
{
mD3DCompilerModule
=
LoadLibrary
(
D3DCOMPILER_DLL
)
;
}
if
(
!
mD3DCompilerModule
)
{
ERR
(
"
D3D
compiler
module
not
found
.
"
)
;
return
gl
:
:
Error
(
GL_OUT_OF_MEMORY
"
D3D
compiler
module
not
found
.
"
)
;
}
mD3DCompileFunc
=
reinterpret_cast
<
pD3DCompile
>
(
GetProcAddress
(
mD3DCompilerModule
"
D3DCompile
"
)
)
;
ASSERT
(
mD3DCompileFunc
)
;
mD3DDisassembleFunc
=
reinterpret_cast
<
pD3DDisassemble
>
(
GetProcAddress
(
mD3DCompilerModule
"
D3DDisassemble
"
)
)
;
ASSERT
(
mD3DDisassembleFunc
)
;
#
else
mD3DCompilerModule
=
nullptr
;
mD3DCompileFunc
=
reinterpret_cast
<
pD3DCompile
>
(
D3DCompile
)
;
mD3DDisassembleFunc
=
reinterpret_cast
<
pD3DDisassemble
>
(
D3DDisassemble
)
;
#
endif
if
(
mD3DCompileFunc
=
=
nullptr
)
{
return
gl
:
:
Error
(
GL_OUT_OF_MEMORY
"
Error
finding
D3DCompile
entry
point
.
"
)
;
}
mInitialized
=
true
;
return
gl
:
:
Error
(
GL_NO_ERROR
)
;
}
void
HLSLCompiler
:
:
release
(
)
{
if
(
mInitialized
)
{
FreeLibrary
(
mD3DCompilerModule
)
;
mD3DCompilerModule
=
nullptr
;
mD3DCompileFunc
=
nullptr
;
mD3DDisassembleFunc
=
nullptr
;
mInitialized
=
false
;
}
}
gl
:
:
Error
HLSLCompiler
:
:
compileToBinary
(
gl
:
:
InfoLog
&
infoLog
const
std
:
:
string
&
hlsl
const
std
:
:
string
&
profile
const
std
:
:
vector
<
CompileConfig
>
&
configs
const
D3D_SHADER_MACRO
*
overrideMacros
ID3DBlob
*
*
outCompiledBlob
std
:
:
string
*
outDebugInfo
)
{
gl
:
:
Error
error
=
initialize
(
)
;
if
(
error
.
isError
(
)
)
{
return
error
;
}
#
if
!
defined
(
ANGLE_ENABLE_WINDOWS_STORE
)
ASSERT
(
mD3DCompilerModule
)
;
#
endif
ASSERT
(
mD3DCompileFunc
)
;
#
if
!
defined
(
ANGLE_ENABLE_WINDOWS_STORE
)
if
(
gl
:
:
DebugAnnotationsActive
(
)
)
{
std
:
:
string
sourcePath
=
getTempPath
(
)
;
std
:
:
string
sourceText
=
FormatString
(
"
#
line
2
\
"
%
s
\
"
\
n
\
n
%
s
"
sourcePath
.
c_str
(
)
hlsl
.
c_str
(
)
)
;
writeFile
(
sourcePath
.
c_str
(
)
sourceText
.
c_str
(
)
sourceText
.
size
(
)
)
;
}
#
endif
const
D3D_SHADER_MACRO
*
macros
=
overrideMacros
?
overrideMacros
:
nullptr
;
for
(
size_t
i
=
0
;
i
<
configs
.
size
(
)
;
+
+
i
)
{
ID3DBlob
*
errorMessage
=
nullptr
;
ID3DBlob
*
binary
=
nullptr
;
HRESULT
result
=
S_OK
;
{
TRACE_EVENT0
(
"
gpu
.
angle
"
"
D3DCompile
"
)
;
SCOPED_ANGLE_HISTOGRAM_TIMER
(
"
GPU
.
ANGLE
.
D3DCompileMS
"
)
;
result
=
mD3DCompileFunc
(
hlsl
.
c_str
(
)
hlsl
.
length
(
)
gl
:
:
g_fakepath
macros
nullptr
"
main
"
profile
.
c_str
(
)
configs
[
i
]
.
flags
0
&
binary
&
errorMessage
)
;
}
if
(
errorMessage
)
{
std
:
:
string
message
=
reinterpret_cast
<
const
char
*
>
(
errorMessage
-
>
GetBufferPointer
(
)
)
;
SafeRelease
(
errorMessage
)
;
infoLog
.
appendSanitized
(
message
.
c_str
(
)
)
;
TRACE
(
"
\
n
%
s
"
hlsl
.
c_str
(
)
)
;
TRACE
(
"
\
n
%
s
"
message
.
c_str
(
)
)
;
if
(
(
message
.
find
(
"
error
X3531
:
"
)
!
=
std
:
:
string
:
:
npos
|
|
message
.
find
(
"
error
X4014
:
"
)
!
=
std
:
:
string
:
:
npos
)
&
&
macros
!
=
nullptr
)
{
macros
=
nullptr
;
i
-
-
;
continue
;
}
}
if
(
SUCCEEDED
(
result
)
)
{
*
outCompiledBlob
=
binary
;
(
*
outDebugInfo
)
+
=
"
/
/
COMPILER
INPUT
HLSL
BEGIN
\
n
\
n
"
+
hlsl
+
"
\
n
/
/
COMPILER
INPUT
HLSL
END
\
n
"
;
#
if
ANGLE_APPEND_ASSEMBLY_TO_SHADER_DEBUG_INFO
=
=
ANGLE_ENABLED
(
*
outDebugInfo
)
+
=
"
\
n
\
n
/
/
ASSEMBLY
BEGIN
\
n
\
n
"
;
(
*
outDebugInfo
)
+
=
"
/
/
Compiler
configuration
:
"
+
configs
[
i
]
.
name
+
"
\
n
/
/
Flags
:
\
n
"
;
for
(
size_t
fIx
=
0
;
fIx
<
ArraySize
(
CompilerFlagInfos
)
;
+
+
fIx
)
{
if
(
IsCompilerFlagSet
(
configs
[
i
]
.
flags
CompilerFlagInfos
[
fIx
]
.
mFlag
)
)
{
(
*
outDebugInfo
)
+
=
std
:
:
string
(
"
/
/
"
)
+
CompilerFlagInfos
[
fIx
]
.
mName
+
"
\
n
"
;
}
}
(
*
outDebugInfo
)
+
=
"
/
/
Macros
:
\
n
"
;
if
(
macros
=
=
nullptr
)
{
(
*
outDebugInfo
)
+
=
"
/
/
-
:
-
\
n
"
;
}
else
{
for
(
const
D3D_SHADER_MACRO
*
mIt
=
macros
;
mIt
-
>
Name
!
=
nullptr
;
+
+
mIt
)
{
(
*
outDebugInfo
)
+
=
std
:
:
string
(
"
/
/
"
)
+
mIt
-
>
Name
+
"
:
"
+
mIt
-
>
Definition
+
"
\
n
"
;
}
}
std
:
:
string
disassembly
;
error
=
disassembleBinary
(
binary
&
disassembly
)
;
if
(
error
.
isError
(
)
)
{
return
error
;
}
(
*
outDebugInfo
)
+
=
"
\
n
"
+
disassembly
+
"
\
n
/
/
ASSEMBLY
END
\
n
"
;
#
endif
return
gl
:
:
Error
(
GL_NO_ERROR
)
;
}
if
(
result
=
=
E_OUTOFMEMORY
)
{
*
outCompiledBlob
=
nullptr
;
return
gl
:
:
Error
(
GL_OUT_OF_MEMORY
"
HLSL
compiler
had
an
unexpected
failure
result
:
0x
%
X
.
"
result
)
;
}
infoLog
<
<
"
Warning
:
D3D
shader
compilation
failed
with
"
<
<
configs
[
i
]
.
name
<
<
"
flags
.
(
"
<
<
profile
<
<
"
)
"
;
if
(
i
+
1
<
configs
.
size
(
)
)
{
infoLog
<
<
"
Retrying
with
"
<
<
configs
[
i
+
1
]
.
name
;
}
}
*
outCompiledBlob
=
nullptr
;
return
gl
:
:
Error
(
GL_NO_ERROR
)
;
}
gl
:
:
Error
HLSLCompiler
:
:
disassembleBinary
(
ID3DBlob
*
shaderBinary
std
:
:
string
*
disassemblyOut
)
{
gl
:
:
Error
error
=
initialize
(
)
;
if
(
error
.
isError
(
)
)
{
return
error
;
}
UINT
flags
=
D3D_DISASM_ENABLE_DEFAULT_VALUE_PRINTS
|
D3D_DISASM_ENABLE_INSTRUCTION_NUMBERING
;
ID3DBlob
*
disassembly
=
nullptr
;
pD3DDisassemble
disassembleFunc
=
reinterpret_cast
<
pD3DDisassemble
>
(
mD3DDisassembleFunc
)
;
LPCVOID
buffer
=
shaderBinary
-
>
GetBufferPointer
(
)
;
SIZE_T
bufSize
=
shaderBinary
-
>
GetBufferSize
(
)
;
HRESULT
result
=
disassembleFunc
(
buffer
bufSize
flags
"
"
&
disassembly
)
;
if
(
SUCCEEDED
(
result
)
)
{
*
disassemblyOut
=
std
:
:
string
(
reinterpret_cast
<
const
char
*
>
(
disassembly
-
>
GetBufferPointer
(
)
)
)
;
}
else
{
*
disassemblyOut
=
"
"
;
}
SafeRelease
(
disassembly
)
;
return
gl
:
:
Error
(
GL_NO_ERROR
)
;
}
}
