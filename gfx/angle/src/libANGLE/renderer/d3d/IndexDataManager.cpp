#
include
"
libANGLE
/
renderer
/
d3d
/
IndexDataManager
.
h
"
#
include
"
common
/
utilities
.
h
"
#
include
"
libANGLE
/
Buffer
.
h
"
#
include
"
libANGLE
/
Context
.
h
"
#
include
"
libANGLE
/
VertexArray
.
h
"
#
include
"
libANGLE
/
formatutils
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
BufferD3D
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
IndexBuffer
.
h
"
namespace
rx
{
namespace
{
template
<
typename
InputT
typename
DestT
>
void
ConvertIndexArray
(
const
void
*
input
GLenum
sourceType
void
*
output
GLenum
destinationType
GLsizei
count
bool
usePrimitiveRestartFixedIndex
)
{
const
InputT
*
in
=
static_cast
<
const
InputT
*
>
(
input
)
;
DestT
*
out
=
static_cast
<
DestT
*
>
(
output
)
;
if
(
usePrimitiveRestartFixedIndex
)
{
InputT
srcRestartIndex
=
static_cast
<
InputT
>
(
gl
:
:
GetPrimitiveRestartIndex
(
sourceType
)
)
;
DestT
destRestartIndex
=
static_cast
<
DestT
>
(
gl
:
:
GetPrimitiveRestartIndex
(
destinationType
)
)
;
for
(
GLsizei
i
=
0
;
i
<
count
;
i
+
+
)
{
out
[
i
]
=
(
in
[
i
]
=
=
srcRestartIndex
?
destRestartIndex
:
static_cast
<
DestT
>
(
in
[
i
]
)
)
;
}
}
else
{
for
(
GLsizei
i
=
0
;
i
<
count
;
i
+
+
)
{
out
[
i
]
=
static_cast
<
DestT
>
(
in
[
i
]
)
;
}
}
}
void
ConvertIndices
(
GLenum
sourceType
GLenum
destinationType
const
void
*
input
GLsizei
count
void
*
output
bool
usePrimitiveRestartFixedIndex
)
{
if
(
sourceType
=
=
destinationType
)
{
const
gl
:
:
Type
&
typeInfo
=
gl
:
:
GetTypeInfo
(
destinationType
)
;
memcpy
(
output
input
count
*
typeInfo
.
bytes
)
;
return
;
}
if
(
sourceType
=
=
GL_UNSIGNED_BYTE
)
{
ASSERT
(
destinationType
=
=
GL_UNSIGNED_SHORT
)
;
ConvertIndexArray
<
GLubyte
GLushort
>
(
input
sourceType
output
destinationType
count
usePrimitiveRestartFixedIndex
)
;
}
else
if
(
sourceType
=
=
GL_UNSIGNED_SHORT
)
{
ASSERT
(
destinationType
=
=
GL_UNSIGNED_INT
)
;
ConvertIndexArray
<
GLushort
GLuint
>
(
input
sourceType
output
destinationType
count
usePrimitiveRestartFixedIndex
)
;
}
else
UNREACHABLE
(
)
;
}
gl
:
:
Error
StreamInIndexBuffer
(
IndexBufferInterface
*
buffer
const
void
*
data
unsigned
int
count
GLenum
srcType
GLenum
dstType
bool
usePrimitiveRestartFixedIndex
unsigned
int
*
offset
)
{
const
gl
:
:
Type
&
dstTypeInfo
=
gl
:
:
GetTypeInfo
(
dstType
)
;
if
(
count
>
(
std
:
:
numeric_limits
<
unsigned
int
>
:
:
max
(
)
>
>
dstTypeInfo
.
bytesShift
)
)
{
return
gl
:
:
OutOfMemory
(
)
<
<
"
Reserving
"
<
<
count
<
<
"
indices
of
"
<
<
dstTypeInfo
.
bytes
<
<
"
bytes
each
exceeds
the
maximum
buffer
size
.
"
;
}
unsigned
int
bufferSizeRequired
=
count
<
<
dstTypeInfo
.
bytesShift
;
gl
:
:
Error
error
=
buffer
-
>
reserveBufferSpace
(
bufferSizeRequired
dstType
)
;
if
(
error
.
isError
(
)
)
{
return
error
;
}
void
*
output
=
nullptr
;
error
=
buffer
-
>
mapBuffer
(
bufferSizeRequired
&
output
offset
)
;
if
(
error
.
isError
(
)
)
{
return
error
;
}
ConvertIndices
(
srcType
dstType
data
count
output
usePrimitiveRestartFixedIndex
)
;
error
=
buffer
-
>
unmapBuffer
(
)
;
if
(
error
.
isError
(
)
)
{
return
error
;
}
return
gl
:
:
NoError
(
)
;
}
}
IndexDataManager
:
:
IndexDataManager
(
BufferFactoryD3D
*
factory
RendererClass
rendererClass
)
:
mFactory
(
factory
)
mRendererClass
(
rendererClass
)
mStreamingBufferShort
(
)
mStreamingBufferInt
(
)
{
}
IndexDataManager
:
:
~
IndexDataManager
(
)
{
}
void
IndexDataManager
:
:
deinitialize
(
)
{
mStreamingBufferShort
.
reset
(
)
;
mStreamingBufferInt
.
reset
(
)
;
}
bool
IndexDataManager
:
:
UsePrimitiveRestartWorkaround
(
bool
primitiveRestartFixedIndexEnabled
GLenum
type
RendererClass
rendererClass
)
{
return
(
!
primitiveRestartFixedIndexEnabled
&
&
type
=
=
GL_UNSIGNED_SHORT
&
&
rendererClass
=
=
RENDERER_D3D11
)
;
}
bool
IndexDataManager
:
:
IsStreamingIndexData
(
const
gl
:
:
Context
*
context
GLenum
srcType
RendererClass
rendererClass
)
{
const
auto
&
glState
=
context
-
>
getGLState
(
)
;
bool
primitiveRestartWorkaround
=
UsePrimitiveRestartWorkaround
(
glState
.
isPrimitiveRestartEnabled
(
)
srcType
rendererClass
)
;
gl
:
:
Buffer
*
glBuffer
=
glState
.
getVertexArray
(
)
-
>
getElementArrayBuffer
(
)
.
get
(
)
;
if
(
glBuffer
=
=
nullptr
)
{
return
true
;
}
BufferD3D
*
buffer
=
GetImplAs
<
BufferD3D
>
(
glBuffer
)
;
const
GLenum
dstType
=
(
srcType
=
=
GL_UNSIGNED_INT
|
|
primitiveRestartWorkaround
)
?
GL_UNSIGNED_INT
:
GL_UNSIGNED_SHORT
;
if
(
buffer
-
>
supportsDirectBinding
(
)
&
&
dstType
=
=
srcType
)
{
return
false
;
}
StaticIndexBufferInterface
*
staticBuffer
=
buffer
-
>
getStaticIndexBuffer
(
)
;
if
(
staticBuffer
=
=
nullptr
)
{
return
true
;
}
if
(
(
staticBuffer
-
>
getBufferSize
(
)
=
=
0
)
|
|
(
staticBuffer
-
>
getIndexType
(
)
!
=
dstType
)
)
{
return
true
;
}
return
false
;
}
gl
:
:
Error
IndexDataManager
:
:
prepareIndexData
(
const
gl
:
:
Context
*
context
GLenum
srcType
GLsizei
count
gl
:
:
Buffer
*
glBuffer
const
void
*
indices
TranslatedIndexData
*
translated
bool
primitiveRestartFixedIndexEnabled
)
{
bool
hasPrimitiveRestartIndex
=
translated
-
>
indexRange
.
vertexIndexCount
<
static_cast
<
size_t
>
(
count
)
|
|
translated
-
>
indexRange
.
end
=
=
gl
:
:
GetPrimitiveRestartIndex
(
srcType
)
;
bool
primitiveRestartWorkaround
=
UsePrimitiveRestartWorkaround
(
primitiveRestartFixedIndexEnabled
srcType
mRendererClass
)
&
&
hasPrimitiveRestartIndex
;
ASSERT
(
!
(
mRendererClass
=
=
RENDERER_D3D11
&
&
!
primitiveRestartFixedIndexEnabled
&
&
hasPrimitiveRestartIndex
&
&
srcType
=
=
GL_UNSIGNED_INT
)
)
;
const
GLenum
dstType
=
(
srcType
=
=
GL_UNSIGNED_INT
|
|
primitiveRestartWorkaround
)
?
GL_UNSIGNED_INT
:
GL_UNSIGNED_SHORT
;
const
gl
:
:
Type
&
srcTypeInfo
=
gl
:
:
GetTypeInfo
(
srcType
)
;
const
gl
:
:
Type
&
dstTypeInfo
=
gl
:
:
GetTypeInfo
(
dstType
)
;
BufferD3D
*
buffer
=
glBuffer
?
GetImplAs
<
BufferD3D
>
(
glBuffer
)
:
nullptr
;
translated
-
>
indexType
=
dstType
;
translated
-
>
srcIndexData
.
srcBuffer
=
buffer
;
translated
-
>
srcIndexData
.
srcIndices
=
indices
;
translated
-
>
srcIndexData
.
srcIndexType
=
srcType
;
translated
-
>
srcIndexData
.
srcCount
=
count
;
if
(
glBuffer
=
=
nullptr
)
{
translated
-
>
storage
=
nullptr
;
return
streamIndexData
(
indices
count
srcType
dstType
primitiveRestartFixedIndexEnabled
translated
)
;
}
unsigned
int
offset
=
static_cast
<
unsigned
int
>
(
reinterpret_cast
<
uintptr_t
>
(
indices
)
)
;
ASSERT
(
srcTypeInfo
.
bytes
*
static_cast
<
unsigned
int
>
(
count
)
+
offset
<
=
buffer
-
>
getSize
(
)
)
;
bool
offsetAligned
;
switch
(
srcType
)
{
case
GL_UNSIGNED_BYTE
:
offsetAligned
=
(
offset
%
sizeof
(
GLubyte
)
=
=
0
)
;
break
;
case
GL_UNSIGNED_SHORT
:
offsetAligned
=
(
offset
%
sizeof
(
GLushort
)
=
=
0
)
;
break
;
case
GL_UNSIGNED_INT
:
offsetAligned
=
(
offset
%
sizeof
(
GLuint
)
=
=
0
)
;
break
;
default
:
UNREACHABLE
(
)
;
offsetAligned
=
false
;
}
if
(
offsetAligned
&
&
buffer
-
>
supportsDirectBinding
(
)
&
&
dstType
=
=
srcType
)
{
translated
-
>
storage
=
buffer
;
translated
-
>
indexBuffer
=
nullptr
;
translated
-
>
serial
=
buffer
-
>
getSerial
(
)
;
translated
-
>
startIndex
=
(
offset
>
>
srcTypeInfo
.
bytesShift
)
;
translated
-
>
startOffset
=
offset
;
return
gl
:
:
NoError
(
)
;
}
else
{
translated
-
>
storage
=
nullptr
;
}
StaticIndexBufferInterface
*
staticBuffer
=
buffer
-
>
getStaticIndexBuffer
(
)
;
bool
staticBufferInitialized
=
staticBuffer
&
&
staticBuffer
-
>
getBufferSize
(
)
!
=
0
;
bool
staticBufferUsable
=
staticBuffer
&
&
offsetAligned
&
&
staticBuffer
-
>
getIndexType
(
)
=
=
dstType
;
if
(
staticBufferInitialized
&
&
!
staticBufferUsable
)
{
buffer
-
>
invalidateStaticData
(
context
)
;
staticBuffer
=
nullptr
;
}
if
(
staticBuffer
=
=
nullptr
|
|
!
offsetAligned
)
{
const
uint8_t
*
bufferData
=
nullptr
;
gl
:
:
Error
error
=
buffer
-
>
getData
(
context
&
bufferData
)
;
if
(
error
.
isError
(
)
)
{
return
error
;
}
ASSERT
(
bufferData
!
=
nullptr
)
;
error
=
streamIndexData
(
bufferData
+
offset
count
srcType
dstType
primitiveRestartFixedIndexEnabled
translated
)
;
if
(
error
.
isError
(
)
)
{
return
error
;
}
buffer
-
>
promoteStaticUsage
(
context
count
<
<
srcTypeInfo
.
bytesShift
)
;
}
else
{
if
(
!
staticBufferInitialized
)
{
const
uint8_t
*
bufferData
=
nullptr
;
gl
:
:
Error
error
=
buffer
-
>
getData
(
context
&
bufferData
)
;
if
(
error
.
isError
(
)
)
{
return
error
;
}
ASSERT
(
bufferData
!
=
nullptr
)
;
unsigned
int
convertCount
=
static_cast
<
unsigned
int
>
(
buffer
-
>
getSize
(
)
)
>
>
srcTypeInfo
.
bytesShift
;
error
=
StreamInIndexBuffer
(
staticBuffer
bufferData
convertCount
srcType
dstType
primitiveRestartFixedIndexEnabled
nullptr
)
;
if
(
error
.
isError
(
)
)
{
return
error
;
}
}
ASSERT
(
offsetAligned
&
&
staticBuffer
-
>
getIndexType
(
)
=
=
dstType
)
;
translated
-
>
indexBuffer
=
staticBuffer
-
>
getIndexBuffer
(
)
;
translated
-
>
serial
=
staticBuffer
-
>
getSerial
(
)
;
translated
-
>
startIndex
=
(
offset
>
>
srcTypeInfo
.
bytesShift
)
;
translated
-
>
startOffset
=
(
offset
>
>
srcTypeInfo
.
bytesShift
)
<
<
dstTypeInfo
.
bytesShift
;
}
return
gl
:
:
NoError
(
)
;
}
gl
:
:
Error
IndexDataManager
:
:
streamIndexData
(
const
void
*
data
unsigned
int
count
GLenum
srcType
GLenum
dstType
bool
usePrimitiveRestartFixedIndex
TranslatedIndexData
*
translated
)
{
const
gl
:
:
Type
&
dstTypeInfo
=
gl
:
:
GetTypeInfo
(
dstType
)
;
IndexBufferInterface
*
indexBuffer
=
nullptr
;
gl
:
:
Error
error
=
getStreamingIndexBuffer
(
dstType
&
indexBuffer
)
;
if
(
error
.
isError
(
)
)
{
return
error
;
}
ASSERT
(
indexBuffer
!
=
nullptr
)
;
unsigned
int
offset
;
ANGLE_TRY
(
StreamInIndexBuffer
(
indexBuffer
data
count
srcType
dstType
usePrimitiveRestartFixedIndex
&
offset
)
)
;
translated
-
>
indexBuffer
=
indexBuffer
-
>
getIndexBuffer
(
)
;
translated
-
>
serial
=
indexBuffer
-
>
getSerial
(
)
;
translated
-
>
startIndex
=
(
offset
>
>
dstTypeInfo
.
bytesShift
)
;
translated
-
>
startOffset
=
offset
;
return
gl
:
:
NoError
(
)
;
}
gl
:
:
Error
IndexDataManager
:
:
getStreamingIndexBuffer
(
GLenum
destinationIndexType
IndexBufferInterface
*
*
outBuffer
)
{
ASSERT
(
outBuffer
)
;
ASSERT
(
destinationIndexType
=
=
GL_UNSIGNED_SHORT
|
|
destinationIndexType
=
=
GL_UNSIGNED_INT
)
;
auto
&
streamingBuffer
=
(
destinationIndexType
=
=
GL_UNSIGNED_INT
)
?
mStreamingBufferInt
:
mStreamingBufferShort
;
if
(
!
streamingBuffer
)
{
StreamingBuffer
newBuffer
(
new
StreamingIndexBufferInterface
(
mFactory
)
)
;
ANGLE_TRY
(
newBuffer
-
>
reserveBufferSpace
(
INITIAL_INDEX_BUFFER_SIZE
destinationIndexType
)
)
;
streamingBuffer
=
std
:
:
move
(
newBuffer
)
;
}
*
outBuffer
=
streamingBuffer
.
get
(
)
;
return
gl
:
:
NoError
(
)
;
}
}
