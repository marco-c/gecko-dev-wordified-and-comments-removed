#
include
"
libANGLE
/
renderer
/
vulkan
/
GlslangWrapper
.
h
"
#
include
<
ShaderLang
.
h
>
#
include
<
StandAlone
/
ResourceLimits
.
h
>
#
include
<
SPIRV
/
GlslangToSpv
.
h
>
#
include
<
array
>
namespace
rx
{
GlslangWrapper
*
GlslangWrapper
:
:
mInstance
=
nullptr
;
GlslangWrapper
*
GlslangWrapper
:
:
GetReference
(
)
{
if
(
!
mInstance
)
{
mInstance
=
new
GlslangWrapper
(
)
;
}
mInstance
-
>
addRef
(
)
;
return
mInstance
;
}
void
GlslangWrapper
:
:
ReleaseReference
(
)
{
if
(
mInstance
-
>
getRefCount
(
)
=
=
1
)
{
mInstance
-
>
release
(
)
;
mInstance
=
nullptr
;
}
else
{
mInstance
-
>
release
(
)
;
}
}
GlslangWrapper
:
:
GlslangWrapper
(
)
{
int
result
=
ShInitialize
(
)
;
ASSERT
(
result
!
=
0
)
;
}
GlslangWrapper
:
:
~
GlslangWrapper
(
)
{
int
result
=
ShFinalize
(
)
;
ASSERT
(
result
!
=
0
)
;
}
gl
:
:
LinkResult
GlslangWrapper
:
:
linkProgram
(
const
std
:
:
string
&
vertexSource
const
std
:
:
string
&
fragmentSource
std
:
:
vector
<
uint32_t
>
*
vertexCodeOut
std
:
:
vector
<
uint32_t
>
*
fragmentCodeOut
)
{
std
:
:
array
<
const
char
*
2
>
strings
=
{
{
vertexSource
.
c_str
(
)
fragmentSource
.
c_str
(
)
}
}
;
std
:
:
array
<
int
2
>
lengths
=
{
{
static_cast
<
int
>
(
vertexSource
.
length
(
)
)
static_cast
<
int
>
(
fragmentSource
.
length
(
)
)
}
}
;
EShMessages
messages
=
static_cast
<
EShMessages
>
(
EShMsgSpvRules
|
EShMsgVulkanRules
)
;
glslang
:
:
TShader
vertexShader
(
EShLangVertex
)
;
vertexShader
.
setStringsWithLengths
(
&
strings
[
0
]
&
lengths
[
0
]
1
)
;
vertexShader
.
setEntryPoint
(
"
main
"
)
;
bool
vertexResult
=
vertexShader
.
parse
(
&
glslang
:
:
DefaultTBuiltInResource
450
ECoreProfile
false
false
messages
)
;
if
(
!
vertexResult
)
{
return
gl
:
:
InternalError
(
)
<
<
"
Internal
error
parsing
Vulkan
vertex
shader
:
\
n
"
<
<
vertexShader
.
getInfoLog
(
)
<
<
"
\
n
"
<
<
vertexShader
.
getInfoDebugLog
(
)
<
<
"
\
n
"
;
}
glslang
:
:
TShader
fragmentShader
(
EShLangFragment
)
;
fragmentShader
.
setStringsWithLengths
(
&
strings
[
1
]
&
lengths
[
1
]
1
)
;
fragmentShader
.
setEntryPoint
(
"
main
"
)
;
bool
fragmentResult
=
fragmentShader
.
parse
(
&
glslang
:
:
DefaultTBuiltInResource
450
ECoreProfile
false
false
messages
)
;
if
(
!
fragmentResult
)
{
return
gl
:
:
InternalError
(
)
<
<
"
Internal
error
parsing
Vulkan
fragment
shader
:
\
n
"
<
<
fragmentShader
.
getInfoLog
(
)
<
<
"
\
n
"
<
<
fragmentShader
.
getInfoDebugLog
(
)
<
<
"
\
n
"
;
}
glslang
:
:
TProgram
program
;
program
.
addShader
(
&
vertexShader
)
;
program
.
addShader
(
&
fragmentShader
)
;
bool
linkResult
=
program
.
link
(
messages
)
;
if
(
!
linkResult
)
{
return
gl
:
:
InternalError
(
)
<
<
"
Internal
error
linking
Vulkan
shaders
:
\
n
"
<
<
program
.
getInfoLog
(
)
<
<
"
\
n
"
;
}
glslang
:
:
TIntermediate
*
vertexStage
=
program
.
getIntermediate
(
EShLangVertex
)
;
glslang
:
:
TIntermediate
*
fragmentStage
=
program
.
getIntermediate
(
EShLangFragment
)
;
glslang
:
:
GlslangToSpv
(
*
vertexStage
*
vertexCodeOut
)
;
glslang
:
:
GlslangToSpv
(
*
fragmentStage
*
fragmentCodeOut
)
;
return
true
;
}
}
