#
include
"
libANGLE
/
Observer
.
h
"
#
include
<
algorithm
>
#
include
"
common
/
debug
.
h
"
namespace
angle
{
namespace
{
}
ObserverInterface
:
:
~
ObserverInterface
(
)
=
default
;
Subject
:
:
Subject
(
)
{
}
Subject
:
:
~
Subject
(
)
{
resetObservers
(
)
;
}
bool
Subject
:
:
hasObservers
(
)
const
{
return
!
mObservers
.
empty
(
)
;
}
void
Subject
:
:
onStateChange
(
SubjectMessage
message
)
const
{
if
(
mObservers
.
empty
(
)
)
return
;
for
(
const
ObserverBindingBase
*
binding
:
mObservers
)
{
binding
-
>
getObserver
(
)
-
>
onSubjectStateChange
(
binding
-
>
getSubjectIndex
(
)
message
)
;
}
}
void
Subject
:
:
resetObservers
(
)
{
for
(
angle
:
:
ObserverBindingBase
*
binding
:
mObservers
)
{
binding
-
>
onSubjectReset
(
)
;
}
mObservers
.
clear
(
)
;
}
ObserverBinding
:
:
ObserverBinding
(
)
:
ObserverBindingBase
(
nullptr
0
)
mSubject
(
nullptr
)
{
}
ObserverBinding
:
:
ObserverBinding
(
ObserverInterface
*
observer
SubjectIndex
index
)
:
ObserverBindingBase
(
observer
index
)
mSubject
(
nullptr
)
{
ASSERT
(
observer
)
;
}
ObserverBinding
:
:
~
ObserverBinding
(
)
{
reset
(
)
;
}
ObserverBinding
:
:
ObserverBinding
(
const
ObserverBinding
&
other
)
:
ObserverBindingBase
(
other
)
mSubject
(
nullptr
)
{
bind
(
other
.
mSubject
)
;
}
ObserverBinding
&
ObserverBinding
:
:
operator
=
(
const
ObserverBinding
&
other
)
{
reset
(
)
;
ObserverBindingBase
:
:
operator
=
(
other
)
;
bind
(
other
.
mSubject
)
;
return
*
this
;
}
void
ObserverBinding
:
:
bind
(
Subject
*
subject
)
{
ASSERT
(
getObserver
(
)
|
|
!
subject
)
;
if
(
mSubject
)
{
mSubject
-
>
removeObserver
(
this
)
;
}
mSubject
=
subject
;
if
(
mSubject
)
{
mSubject
-
>
addObserver
(
this
)
;
}
}
void
ObserverBinding
:
:
onStateChange
(
SubjectMessage
message
)
const
{
getObserver
(
)
-
>
onSubjectStateChange
(
getSubjectIndex
(
)
message
)
;
}
void
ObserverBinding
:
:
onSubjectReset
(
)
{
mSubject
=
nullptr
;
}
}
