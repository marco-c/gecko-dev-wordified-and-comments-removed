#
ifndef
LIBANGLE_PROGRAM_H_
#
define
LIBANGLE_PROGRAM_H_
#
include
<
GLES2
/
gl2
.
h
>
#
include
<
GLSLANG
/
ShaderVars
.
h
>
#
include
<
array
>
#
include
<
map
>
#
include
<
set
>
#
include
<
sstream
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
common
/
angleutils
.
h
"
#
include
"
common
/
mathutil
.
h
"
#
include
"
common
/
Optional
.
h
"
#
include
"
libANGLE
/
Constants
.
h
"
#
include
"
libANGLE
/
Debug
.
h
"
#
include
"
libANGLE
/
Error
.
h
"
#
include
"
libANGLE
/
RefCountObject
.
h
"
#
include
"
libANGLE
/
Uniform
.
h
"
#
include
"
libANGLE
/
angletypes
.
h
"
namespace
rx
{
class
GLImplFactory
;
class
ProgramImpl
;
struct
TranslatedAttribute
;
}
namespace
gl
{
struct
Caps
;
class
Context
;
class
ContextState
;
class
Shader
;
class
ShaderProgramManager
;
class
State
;
class
InfoLog
;
class
Buffer
;
class
Framebuffer
;
extern
const
char
*
const
g_fakepath
;
enum
class
LinkMismatchError
{
NO_MISMATCH
TYPE_MISMATCH
ARRAY_SIZE_MISMATCH
PRECISION_MISMATCH
STRUCT_NAME_MISMATCH
FIELD_NUMBER_MISMATCH
FIELD_NAME_MISMATCH
INTERPOLATION_TYPE_MISMATCH
INVARIANCE_MISMATCH
BINDING_MISMATCH
LOCATION_MISMATCH
OFFSET_MISMATCH
LAYOUT_QUALIFIER_MISMATCH
MATRIX_PACKING_MISMATCH
}
;
class
InfoLog
:
angle
:
:
NonCopyable
{
public
:
InfoLog
(
)
;
~
InfoLog
(
)
;
size_t
getLength
(
)
const
;
void
getLog
(
GLsizei
bufSize
GLsizei
*
length
char
*
infoLog
)
const
;
void
appendSanitized
(
const
char
*
message
)
;
void
reset
(
)
;
class
StreamHelper
:
angle
:
:
NonCopyable
{
public
:
StreamHelper
(
StreamHelper
&
&
rhs
)
:
mStream
(
rhs
.
mStream
)
{
rhs
.
mStream
=
nullptr
;
}
StreamHelper
&
operator
=
(
StreamHelper
&
&
rhs
)
{
std
:
:
swap
(
mStream
rhs
.
mStream
)
;
return
*
this
;
}
~
StreamHelper
(
)
{
if
(
mStream
)
{
(
*
mStream
)
<
<
std
:
:
endl
;
}
}
template
<
typename
T
>
StreamHelper
&
operator
<
<
(
const
T
&
value
)
{
(
*
mStream
)
<
<
value
;
return
*
this
;
}
private
:
friend
class
InfoLog
;
StreamHelper
(
std
:
:
stringstream
*
stream
)
:
mStream
(
stream
)
{
ASSERT
(
stream
)
;
}
std
:
:
stringstream
*
mStream
;
}
;
template
<
typename
T
>
StreamHelper
operator
<
<
(
const
T
&
value
)
{
ensureInitialized
(
)
;
StreamHelper
helper
(
mLazyStream
.
get
(
)
)
;
helper
<
<
value
;
return
helper
;
}
std
:
:
string
str
(
)
const
{
return
mLazyStream
?
mLazyStream
-
>
str
(
)
:
"
"
;
}
bool
empty
(
)
const
;
private
:
void
ensureInitialized
(
)
{
if
(
!
mLazyStream
)
{
mLazyStream
.
reset
(
new
std
:
:
stringstream
(
)
)
;
}
}
std
:
:
unique_ptr
<
std
:
:
stringstream
>
mLazyStream
;
}
;
void
LogLinkMismatch
(
InfoLog
&
infoLog
const
std
:
:
string
&
variableName
const
char
*
variableType
LinkMismatchError
linkError
const
std
:
:
string
&
mismatchedStructOrBlockFieldName
GLenum
shaderType1
GLenum
shaderType2
)
;
struct
VariableLocation
{
static
constexpr
unsigned
int
kUnused
=
GL_INVALID_INDEX
;
VariableLocation
(
)
;
VariableLocation
(
unsigned
int
arrayIndex
unsigned
int
index
)
;
bool
used
(
)
const
{
return
(
index
!
=
kUnused
)
;
}
void
markUnused
(
)
{
index
=
kUnused
;
}
void
markIgnored
(
)
{
ignored
=
true
;
}
unsigned
int
arrayIndex
;
unsigned
int
index
;
bool
ignored
;
}
;
struct
BindingInfo
{
GLenum
type
;
std
:
:
string
name
;
bool
valid
;
}
;
struct
SamplerBinding
{
SamplerBinding
(
GLenum
textureTypeIn
size_t
elementCount
bool
unreferenced
)
;
SamplerBinding
(
const
SamplerBinding
&
other
)
;
~
SamplerBinding
(
)
;
GLenum
textureType
;
std
:
:
vector
<
GLuint
>
boundTextureUnits
;
bool
unreferenced
;
}
;
struct
TransformFeedbackVarying
:
public
sh
:
:
Varying
{
TransformFeedbackVarying
(
const
sh
:
:
Varying
&
varyingIn
GLuint
index
)
:
sh
:
:
Varying
(
varyingIn
)
arrayIndex
(
index
)
{
ASSERT
(
!
isArrayOfArrays
(
)
)
;
}
TransformFeedbackVarying
(
const
sh
:
:
ShaderVariable
&
field
const
sh
:
:
Varying
&
parent
)
:
arrayIndex
(
GL_INVALID_INDEX
)
{
sh
:
:
ShaderVariable
*
thisVar
=
this
;
*
thisVar
=
field
;
interpolation
=
parent
.
interpolation
;
isInvariant
=
parent
.
isInvariant
;
name
=
parent
.
name
+
"
.
"
+
name
;
}
std
:
:
string
nameWithArrayIndex
(
)
const
{
std
:
:
stringstream
fullNameStr
;
fullNameStr
<
<
name
;
if
(
arrayIndex
!
=
GL_INVALID_INDEX
)
{
fullNameStr
<
<
"
[
"
<
<
arrayIndex
<
<
"
]
"
;
}
return
fullNameStr
.
str
(
)
;
}
GLsizei
size
(
)
const
{
return
(
isArray
(
)
&
&
arrayIndex
=
=
GL_INVALID_INDEX
?
getOutermostArraySize
(
)
:
1
)
;
}
GLuint
arrayIndex
;
}
;
struct
ImageBinding
{
ImageBinding
(
size_t
count
)
;
ImageBinding
(
GLuint
imageUnit
size_t
count
)
;
ImageBinding
(
const
ImageBinding
&
other
)
;
~
ImageBinding
(
)
;
std
:
:
vector
<
GLuint
>
boundImageUnits
;
}
;
using
ShaderStagesMask
=
angle
:
:
BitSet
<
SHADER_TYPE_MAX
>
;
class
ProgramState
final
:
angle
:
:
NonCopyable
{
public
:
ProgramState
(
)
;
~
ProgramState
(
)
;
const
std
:
:
string
&
getLabel
(
)
;
Shader
*
getAttachedVertexShader
(
)
const
{
return
mAttachedVertexShader
;
}
Shader
*
getAttachedFragmentShader
(
)
const
{
return
mAttachedFragmentShader
;
}
Shader
*
getAttachedComputeShader
(
)
const
{
return
mAttachedComputeShader
;
}
Shader
*
getAttachedGeometryShader
(
)
const
{
return
mAttachedGeometryShader
;
}
const
std
:
:
vector
<
std
:
:
string
>
&
getTransformFeedbackVaryingNames
(
)
const
{
return
mTransformFeedbackVaryingNames
;
}
GLint
getTransformFeedbackBufferMode
(
)
const
{
return
mTransformFeedbackBufferMode
;
}
GLuint
getUniformBlockBinding
(
GLuint
uniformBlockIndex
)
const
{
ASSERT
(
uniformBlockIndex
<
mUniformBlocks
.
size
(
)
)
;
return
mUniformBlocks
[
uniformBlockIndex
]
.
binding
;
}
GLuint
getShaderStorageBlockBinding
(
GLuint
blockIndex
)
const
{
ASSERT
(
blockIndex
<
mShaderStorageBlocks
.
size
(
)
)
;
return
mShaderStorageBlocks
[
blockIndex
]
.
binding
;
}
const
UniformBlockBindingMask
&
getActiveUniformBlockBindingsMask
(
)
const
{
return
mActiveUniformBlockBindings
;
}
const
std
:
:
vector
<
sh
:
:
Attribute
>
&
getAttributes
(
)
const
{
return
mAttributes
;
}
const
AttributesMask
&
getActiveAttribLocationsMask
(
)
const
{
return
mActiveAttribLocationsMask
;
}
unsigned
int
getMaxActiveAttribLocation
(
)
const
{
return
mMaxActiveAttribLocation
;
}
DrawBufferMask
getActiveOutputVariables
(
)
const
{
return
mActiveOutputVariables
;
}
const
std
:
:
vector
<
sh
:
:
OutputVariable
>
&
getOutputVariables
(
)
const
{
return
mOutputVariables
;
}
const
std
:
:
vector
<
VariableLocation
>
&
getOutputLocations
(
)
const
{
return
mOutputLocations
;
}
const
std
:
:
vector
<
LinkedUniform
>
&
getUniforms
(
)
const
{
return
mUniforms
;
}
const
std
:
:
vector
<
VariableLocation
>
&
getUniformLocations
(
)
const
{
return
mUniformLocations
;
}
const
std
:
:
vector
<
InterfaceBlock
>
&
getUniformBlocks
(
)
const
{
return
mUniformBlocks
;
}
const
std
:
:
vector
<
InterfaceBlock
>
&
getShaderStorageBlocks
(
)
const
{
return
mShaderStorageBlocks
;
}
const
std
:
:
vector
<
BufferVariable
>
&
getBufferVariables
(
)
const
{
return
mBufferVariables
;
}
const
std
:
:
vector
<
SamplerBinding
>
&
getSamplerBindings
(
)
const
{
return
mSamplerBindings
;
}
const
std
:
:
vector
<
ImageBinding
>
&
getImageBindings
(
)
const
{
return
mImageBindings
;
}
const
sh
:
:
WorkGroupSize
&
getComputeShaderLocalSize
(
)
const
{
return
mComputeShaderLocalSize
;
}
const
RangeUI
&
getSamplerUniformRange
(
)
const
{
return
mSamplerUniformRange
;
}
const
RangeUI
&
getImageUniformRange
(
)
const
{
return
mImageUniformRange
;
}
const
RangeUI
&
getAtomicCounterUniformRange
(
)
const
{
return
mAtomicCounterUniformRange
;
}
const
std
:
:
vector
<
TransformFeedbackVarying
>
&
getLinkedTransformFeedbackVaryings
(
)
const
{
return
mLinkedTransformFeedbackVaryings
;
}
const
std
:
:
vector
<
AtomicCounterBuffer
>
&
getAtomicCounterBuffers
(
)
const
{
return
mAtomicCounterBuffers
;
}
GLuint
getUniformIndexFromName
(
const
std
:
:
string
&
name
)
const
;
GLuint
getUniformIndexFromLocation
(
GLint
location
)
const
;
Optional
<
GLuint
>
getSamplerIndex
(
GLint
location
)
const
;
bool
isSamplerUniformIndex
(
GLuint
index
)
const
;
GLuint
getSamplerIndexFromUniformIndex
(
GLuint
uniformIndex
)
const
;
GLuint
getAttributeLocation
(
const
std
:
:
string
&
name
)
const
;
GLuint
getBufferVariableIndexFromName
(
const
std
:
:
string
&
name
)
const
;
int
getNumViews
(
)
const
{
return
mNumViews
;
}
bool
usesMultiview
(
)
const
{
return
mNumViews
!
=
-
1
;
}
const
ShaderStagesMask
&
getLinkedShaderStages
(
)
const
{
return
mLinkedShaderStages
;
}
private
:
friend
class
MemoryProgramCache
;
friend
class
Program
;
std
:
:
string
mLabel
;
sh
:
:
WorkGroupSize
mComputeShaderLocalSize
;
Shader
*
mAttachedFragmentShader
;
Shader
*
mAttachedVertexShader
;
Shader
*
mAttachedComputeShader
;
Shader
*
mAttachedGeometryShader
;
std
:
:
vector
<
std
:
:
string
>
mTransformFeedbackVaryingNames
;
std
:
:
vector
<
TransformFeedbackVarying
>
mLinkedTransformFeedbackVaryings
;
GLenum
mTransformFeedbackBufferMode
;
UniformBlockBindingMask
mActiveUniformBlockBindings
;
std
:
:
vector
<
sh
:
:
Attribute
>
mAttributes
;
angle
:
:
BitSet
<
MAX_VERTEX_ATTRIBS
>
mActiveAttribLocationsMask
;
unsigned
int
mMaxActiveAttribLocation
;
ComponentTypeMask
mAttributesTypeMask
;
AttributesMask
mAttributesMask
;
std
:
:
vector
<
LinkedUniform
>
mUniforms
;
std
:
:
vector
<
VariableLocation
>
mUniformLocations
;
std
:
:
vector
<
InterfaceBlock
>
mUniformBlocks
;
std
:
:
vector
<
BufferVariable
>
mBufferVariables
;
std
:
:
vector
<
InterfaceBlock
>
mShaderStorageBlocks
;
std
:
:
vector
<
AtomicCounterBuffer
>
mAtomicCounterBuffers
;
RangeUI
mSamplerUniformRange
;
RangeUI
mImageUniformRange
;
RangeUI
mAtomicCounterUniformRange
;
std
:
:
vector
<
gl
:
:
SamplerBinding
>
mSamplerBindings
;
std
:
:
vector
<
gl
:
:
ImageBinding
>
mImageBindings
;
std
:
:
vector
<
sh
:
:
OutputVariable
>
mOutputVariables
;
std
:
:
vector
<
VariableLocation
>
mOutputLocations
;
DrawBufferMask
mActiveOutputVariables
;
std
:
:
vector
<
GLenum
>
mOutputVariableTypes
;
ComponentTypeMask
mDrawBufferTypeMask
;
bool
mBinaryRetrieveableHint
;
bool
mSeparable
;
ShaderStagesMask
mLinkedShaderStages
;
int
mNumViews
;
GLenum
mGeometryShaderInputPrimitiveType
;
GLenum
mGeometryShaderOutputPrimitiveType
;
int
mGeometryShaderInvocations
;
int
mGeometryShaderMaxVertices
;
}
;
class
ProgramBindings
final
:
angle
:
:
NonCopyable
{
public
:
ProgramBindings
(
)
;
~
ProgramBindings
(
)
;
void
bindLocation
(
GLuint
index
const
std
:
:
string
&
name
)
;
int
getBinding
(
const
std
:
:
string
&
name
)
const
;
using
const_iterator
=
std
:
:
unordered_map
<
std
:
:
string
GLuint
>
:
:
const_iterator
;
const_iterator
begin
(
)
const
;
const_iterator
end
(
)
const
;
private
:
std
:
:
unordered_map
<
std
:
:
string
GLuint
>
mBindings
;
}
;
struct
ProgramVaryingRef
{
const
sh
:
:
Varying
*
get
(
)
const
{
return
vertex
?
vertex
:
fragment
;
}
const
sh
:
:
Varying
*
vertex
=
nullptr
;
const
sh
:
:
Varying
*
fragment
=
nullptr
;
}
;
using
ProgramMergedVaryings
=
std
:
:
map
<
std
:
:
string
ProgramVaryingRef
>
;
class
Program
final
:
angle
:
:
NonCopyable
public
LabeledObject
{
public
:
Program
(
rx
:
:
GLImplFactory
*
factory
ShaderProgramManager
*
manager
GLuint
handle
)
;
void
onDestroy
(
const
Context
*
context
)
;
GLuint
id
(
)
const
{
return
mHandle
;
}
void
setLabel
(
const
std
:
:
string
&
label
)
override
;
const
std
:
:
string
&
getLabel
(
)
const
override
;
rx
:
:
ProgramImpl
*
getImplementation
(
)
const
{
return
mProgram
;
}
void
attachShader
(
Shader
*
shader
)
;
void
detachShader
(
const
Context
*
context
Shader
*
shader
)
;
int
getAttachedShadersCount
(
)
const
;
const
Shader
*
getAttachedVertexShader
(
)
const
{
return
mState
.
mAttachedVertexShader
;
}
const
Shader
*
getAttachedFragmentShader
(
)
const
{
return
mState
.
mAttachedFragmentShader
;
}
const
Shader
*
getAttachedComputeShader
(
)
const
{
return
mState
.
mAttachedComputeShader
;
}
const
Shader
*
getAttachedGeometryShader
(
)
const
{
return
mState
.
mAttachedGeometryShader
;
}
void
bindAttributeLocation
(
GLuint
index
const
char
*
name
)
;
void
bindUniformLocation
(
GLuint
index
const
char
*
name
)
;
BindingInfo
getFragmentInputBindingInfo
(
const
Context
*
context
GLint
index
)
const
;
void
bindFragmentInputLocation
(
GLint
index
const
char
*
name
)
;
void
pathFragmentInputGen
(
const
Context
*
context
GLint
index
GLenum
genMode
GLint
components
const
GLfloat
*
coeffs
)
;
Error
link
(
const
gl
:
:
Context
*
context
)
;
bool
isLinked
(
)
const
;
bool
hasLinkedVertexShader
(
)
const
{
return
mState
.
mLinkedShaderStages
[
SHADER_VERTEX
]
;
}
bool
hasLinkedFragmentShader
(
)
const
{
return
mState
.
mLinkedShaderStages
[
SHADER_FRAGMENT
]
;
}
bool
hasLinkedComputeShader
(
)
const
{
return
mState
.
mLinkedShaderStages
[
SHADER_COMPUTE
]
;
}
bool
hasLinkedGeometryShader
(
)
const
{
return
mState
.
mLinkedShaderStages
[
SHADER_GEOMETRY
]
;
}
Error
loadBinary
(
const
Context
*
context
GLenum
binaryFormat
const
void
*
binary
GLsizei
length
)
;
Error
saveBinary
(
const
Context
*
context
GLenum
*
binaryFormat
void
*
binary
GLsizei
bufSize
GLsizei
*
length
)
const
;
GLint
getBinaryLength
(
const
Context
*
context
)
const
;
void
setBinaryRetrievableHint
(
bool
retrievable
)
;
bool
getBinaryRetrievableHint
(
)
const
;
void
setSeparable
(
bool
separable
)
;
bool
isSeparable
(
)
const
;
int
getInfoLogLength
(
)
const
;
void
getInfoLog
(
GLsizei
bufSize
GLsizei
*
length
char
*
infoLog
)
const
;
void
getAttachedShaders
(
GLsizei
maxCount
GLsizei
*
count
GLuint
*
shaders
)
const
;
GLuint
getAttributeLocation
(
const
std
:
:
string
&
name
)
const
;
bool
isAttribLocationActive
(
size_t
attribLocation
)
const
;
void
getActiveAttribute
(
GLuint
index
GLsizei
bufsize
GLsizei
*
length
GLint
*
size
GLenum
*
type
GLchar
*
name
)
const
;
GLint
getActiveAttributeCount
(
)
const
;
GLint
getActiveAttributeMaxLength
(
)
const
;
const
std
:
:
vector
<
sh
:
:
Attribute
>
&
getAttributes
(
)
const
{
return
mState
.
mAttributes
;
}
GLint
getFragDataLocation
(
const
std
:
:
string
&
name
)
const
;
size_t
getOutputResourceCount
(
)
const
;
const
std
:
:
vector
<
GLenum
>
&
getOutputVariableTypes
(
)
const
{
return
mState
.
mOutputVariableTypes
;
}
DrawBufferMask
getActiveOutputVariables
(
)
const
{
return
mState
.
mActiveOutputVariables
;
}
void
getActiveUniform
(
GLuint
index
GLsizei
bufsize
GLsizei
*
length
GLint
*
size
GLenum
*
type
GLchar
*
name
)
const
;
GLint
getActiveUniformCount
(
)
const
;
size_t
getActiveBufferVariableCount
(
)
const
;
GLint
getActiveUniformMaxLength
(
)
const
;
bool
isValidUniformLocation
(
GLint
location
)
const
;
const
LinkedUniform
&
getUniformByLocation
(
GLint
location
)
const
;
const
VariableLocation
&
getUniformLocation
(
GLint
location
)
const
;
const
std
:
:
vector
<
VariableLocation
>
&
getUniformLocations
(
)
const
;
const
LinkedUniform
&
getUniformByIndex
(
GLuint
index
)
const
;
const
BufferVariable
&
getBufferVariableByIndex
(
GLuint
index
)
const
;
enum
SetUniformResult
{
SamplerChanged
NoSamplerChange
}
;
GLint
getUniformLocation
(
const
std
:
:
string
&
name
)
const
;
GLuint
getUniformIndex
(
const
std
:
:
string
&
name
)
const
;
void
setUniform1fv
(
GLint
location
GLsizei
count
const
GLfloat
*
v
)
;
void
setUniform2fv
(
GLint
location
GLsizei
count
const
GLfloat
*
v
)
;
void
setUniform3fv
(
GLint
location
GLsizei
count
const
GLfloat
*
v
)
;
void
setUniform4fv
(
GLint
location
GLsizei
count
const
GLfloat
*
v
)
;
SetUniformResult
setUniform1iv
(
GLint
location
GLsizei
count
const
GLint
*
v
)
;
void
setUniform2iv
(
GLint
location
GLsizei
count
const
GLint
*
v
)
;
void
setUniform3iv
(
GLint
location
GLsizei
count
const
GLint
*
v
)
;
void
setUniform4iv
(
GLint
location
GLsizei
count
const
GLint
*
v
)
;
void
setUniform1uiv
(
GLint
location
GLsizei
count
const
GLuint
*
v
)
;
void
setUniform2uiv
(
GLint
location
GLsizei
count
const
GLuint
*
v
)
;
void
setUniform3uiv
(
GLint
location
GLsizei
count
const
GLuint
*
v
)
;
void
setUniform4uiv
(
GLint
location
GLsizei
count
const
GLuint
*
v
)
;
void
setUniformMatrix2fv
(
GLint
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
value
)
;
void
setUniformMatrix3fv
(
GLint
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
value
)
;
void
setUniformMatrix4fv
(
GLint
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
value
)
;
void
setUniformMatrix2x3fv
(
GLint
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
value
)
;
void
setUniformMatrix3x2fv
(
GLint
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
value
)
;
void
setUniformMatrix2x4fv
(
GLint
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
value
)
;
void
setUniformMatrix4x2fv
(
GLint
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
value
)
;
void
setUniformMatrix3x4fv
(
GLint
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
value
)
;
void
setUniformMatrix4x3fv
(
GLint
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
value
)
;
void
getUniformfv
(
const
Context
*
context
GLint
location
GLfloat
*
params
)
const
;
void
getUniformiv
(
const
Context
*
context
GLint
location
GLint
*
params
)
const
;
void
getUniformuiv
(
const
Context
*
context
GLint
location
GLuint
*
params
)
const
;
void
getActiveUniformBlockName
(
const
GLuint
blockIndex
GLsizei
bufSize
GLsizei
*
length
GLchar
*
blockName
)
const
;
void
getActiveShaderStorageBlockName
(
const
GLuint
blockIndex
GLsizei
bufSize
GLsizei
*
length
GLchar
*
blockName
)
const
;
GLuint
getActiveUniformBlockCount
(
)
const
;
GLuint
getActiveAtomicCounterBufferCount
(
)
const
;
GLuint
getActiveShaderStorageBlockCount
(
)
const
;
GLint
getActiveUniformBlockMaxNameLength
(
)
const
;
GLint
getActiveShaderStorageBlockMaxNameLength
(
)
const
;
GLuint
getUniformBlockIndex
(
const
std
:
:
string
&
name
)
const
;
GLuint
getShaderStorageBlockIndex
(
const
std
:
:
string
&
name
)
const
;
void
bindUniformBlock
(
GLuint
uniformBlockIndex
GLuint
uniformBlockBinding
)
;
GLuint
getUniformBlockBinding
(
GLuint
uniformBlockIndex
)
const
;
GLuint
getShaderStorageBlockBinding
(
GLuint
shaderStorageBlockIndex
)
const
;
const
InterfaceBlock
&
getUniformBlockByIndex
(
GLuint
index
)
const
;
const
InterfaceBlock
&
getShaderStorageBlockByIndex
(
GLuint
index
)
const
;
void
setTransformFeedbackVaryings
(
GLsizei
count
const
GLchar
*
const
*
varyings
GLenum
bufferMode
)
;
void
getTransformFeedbackVarying
(
GLuint
index
GLsizei
bufSize
GLsizei
*
length
GLsizei
*
size
GLenum
*
type
GLchar
*
name
)
const
;
GLsizei
getTransformFeedbackVaryingCount
(
)
const
;
GLsizei
getTransformFeedbackVaryingMaxLength
(
)
const
;
GLenum
getTransformFeedbackBufferMode
(
)
const
;
GLuint
getTransformFeedbackVaryingResourceIndex
(
const
GLchar
*
name
)
const
;
const
TransformFeedbackVarying
&
getTransformFeedbackVaryingResource
(
GLuint
index
)
const
;
static
LinkMismatchError
LinkValidateInterfaceBlockFields
(
const
sh
:
:
InterfaceBlockField
&
blockField1
const
sh
:
:
InterfaceBlockField
&
blockField2
bool
webglCompatibility
std
:
:
string
*
mismatchedBlockFieldName
)
;
void
addRef
(
)
;
void
release
(
const
Context
*
context
)
;
unsigned
int
getRefCount
(
)
const
;
void
flagForDeletion
(
)
;
bool
isFlaggedForDeletion
(
)
const
;
void
validate
(
const
Caps
&
caps
)
;
bool
validateSamplers
(
InfoLog
*
infoLog
const
Caps
&
caps
)
;
bool
isValidated
(
)
const
;
bool
samplesFromTexture
(
const
gl
:
:
State
&
state
GLuint
textureID
)
const
;
const
AttributesMask
&
getActiveAttribLocationsMask
(
)
const
{
return
mState
.
mActiveAttribLocationsMask
;
}
const
std
:
:
vector
<
SamplerBinding
>
&
getSamplerBindings
(
)
const
{
return
mState
.
mSamplerBindings
;
}
const
std
:
:
vector
<
ImageBinding
>
&
getImageBindings
(
)
const
{
return
mState
.
mImageBindings
;
}
const
sh
:
:
WorkGroupSize
&
getComputeShaderLocalSize
(
)
const
{
return
mState
.
mComputeShaderLocalSize
;
}
const
ProgramState
&
getState
(
)
const
{
return
mState
;
}
static
LinkMismatchError
LinkValidateVariablesBase
(
const
sh
:
:
ShaderVariable
&
variable1
const
sh
:
:
ShaderVariable
&
variable2
bool
validatePrecision
bool
validateArraySize
std
:
:
string
*
mismatchedStructOrBlockMemberName
)
;
GLuint
getInputResourceIndex
(
const
GLchar
*
name
)
const
;
GLuint
getOutputResourceIndex
(
const
GLchar
*
name
)
const
;
void
getInputResourceName
(
GLuint
index
GLsizei
bufSize
GLsizei
*
length
GLchar
*
name
)
const
;
void
getOutputResourceName
(
GLuint
index
GLsizei
bufSize
GLsizei
*
length
GLchar
*
name
)
const
;
void
getUniformResourceName
(
GLuint
index
GLsizei
bufSize
GLsizei
*
length
GLchar
*
name
)
const
;
void
getBufferVariableResourceName
(
GLuint
index
GLsizei
bufSize
GLsizei
*
length
GLchar
*
name
)
const
;
const
sh
:
:
Attribute
&
getInputResource
(
GLuint
index
)
const
;
const
sh
:
:
OutputVariable
&
getOutputResource
(
GLuint
index
)
const
;
const
ProgramBindings
&
getAttributeBindings
(
)
const
{
return
mAttributeBindings
;
}
const
ProgramBindings
&
getUniformLocationBindings
(
)
const
{
return
mUniformLocationBindings
;
}
const
ProgramBindings
&
getFragmentInputBindings
(
)
const
{
return
mFragmentInputBindings
;
}
int
getNumViews
(
)
const
{
return
mState
.
getNumViews
(
)
;
}
bool
usesMultiview
(
)
const
{
return
mState
.
usesMultiview
(
)
;
}
ComponentTypeMask
getDrawBufferTypeMask
(
)
const
{
return
mState
.
mDrawBufferTypeMask
;
}
ComponentTypeMask
getAttributesTypeMask
(
)
const
{
return
mState
.
mAttributesTypeMask
;
}
AttributesMask
getAttributesMask
(
)
const
{
return
mState
.
mAttributesMask
;
}
private
:
~
Program
(
)
override
;
void
unlink
(
)
;
bool
linkValidateShaders
(
const
Context
*
context
InfoLog
&
infoLog
)
;
bool
linkAttributes
(
const
Context
*
context
InfoLog
&
infoLog
)
;
static
bool
ValidateGraphicsInterfaceBlocks
(
const
std
:
:
vector
<
sh
:
:
InterfaceBlock
>
&
vertexInterfaceBlocks
const
std
:
:
vector
<
sh
:
:
InterfaceBlock
>
&
fragmentInterfaceBlocks
InfoLog
&
infoLog
bool
webglCompatibility
sh
:
:
BlockType
blockType
GLuint
maxCombinedInterfaceBlocks
)
;
bool
linkInterfaceBlocks
(
const
Context
*
context
InfoLog
&
infoLog
)
;
bool
linkVaryings
(
const
Context
*
context
InfoLog
&
infoLog
)
const
;
bool
linkUniforms
(
const
Context
*
context
InfoLog
&
infoLog
const
ProgramBindings
&
uniformLocationBindings
)
;
void
linkSamplerAndImageBindings
(
)
;
bool
linkAtomicCounterBuffers
(
)
;
void
updateLinkedShaderStages
(
)
;
static
LinkMismatchError
AreMatchingInterfaceBlocks
(
const
sh
:
:
InterfaceBlock
&
interfaceBlock1
const
sh
:
:
InterfaceBlock
&
interfaceBlock2
bool
webglCompatibility
std
:
:
string
*
mismatchedBlockFieldName
)
;
static
LinkMismatchError
LinkValidateVaryings
(
const
sh
:
:
Varying
&
outputVarying
const
sh
:
:
Varying
&
inputVarying
int
shaderVersion
bool
validateGeometryShaderInputVarying
std
:
:
string
*
mismatchedStructFieldName
)
;
bool
linkValidateShaderInterfaceMatching
(
const
Context
*
context
Shader
*
generatingShader
Shader
*
consumingShader
InfoLog
&
infoLog
)
const
;
bool
linkValidateFragmentInputBindings
(
const
Context
*
context
InfoLog
&
infoLog
)
const
;
bool
linkValidateBuiltInVaryings
(
const
Context
*
context
InfoLog
&
infoLog
)
const
;
bool
linkValidateTransformFeedback
(
const
gl
:
:
Context
*
context
InfoLog
&
infoLog
const
ProgramMergedVaryings
&
linkedVaryings
const
Caps
&
caps
)
const
;
bool
linkValidateGlobalNames
(
const
Context
*
context
InfoLog
&
infoLog
)
const
;
void
gatherTransformFeedbackVaryings
(
const
ProgramMergedVaryings
&
varyings
)
;
ProgramMergedVaryings
getMergedVaryings
(
const
Context
*
context
)
const
;
void
linkOutputVariables
(
const
Context
*
context
)
;
void
setUniformValuesFromBindingQualifiers
(
)
;
void
initInterfaceBlockBindings
(
)
;
template
<
typename
T
>
GLsizei
clampUniformCount
(
const
VariableLocation
&
locationInfo
GLsizei
count
int
vectorSize
const
T
*
v
)
;
template
<
size_t
cols
size_t
rows
typename
T
>
GLsizei
clampMatrixUniformCount
(
GLint
location
GLsizei
count
GLboolean
transpose
const
T
*
v
)
;
void
updateSamplerUniform
(
const
VariableLocation
&
locationInfo
GLsizei
clampedCount
const
GLint
*
v
)
;
template
<
typename
DestT
>
void
getUniformInternal
(
const
Context
*
context
DestT
*
dataOut
GLint
location
GLenum
nativeType
int
components
)
const
;
template
<
typename
T
>
void
getResourceName
(
GLuint
index
const
std
:
:
vector
<
T
>
&
resources
GLsizei
bufSize
GLsizei
*
length
GLchar
*
name
)
const
;
template
<
typename
T
>
GLint
getActiveInterfaceBlockMaxNameLength
(
const
std
:
:
vector
<
T
>
&
resources
)
const
;
ProgramState
mState
;
rx
:
:
ProgramImpl
*
mProgram
;
bool
mValidated
;
ProgramBindings
mAttributeBindings
;
ProgramBindings
mUniformLocationBindings
;
ProgramBindings
mFragmentInputBindings
;
bool
mLinked
;
bool
mDeleteStatus
;
unsigned
int
mRefCount
;
ShaderProgramManager
*
mResourceManager
;
const
GLuint
mHandle
;
InfoLog
mInfoLog
;
Optional
<
bool
>
mCachedValidateSamplersResult
;
std
:
:
vector
<
GLenum
>
mTextureUnitTypesCache
;
}
;
}
#
endif
