#
ifndef
LIBANGLE_OBSERVER_H_
#
define
LIBANGLE_OBSERVER_H_
#
include
"
common
/
FastVector
.
h
"
#
include
"
common
/
angleutils
.
h
"
namespace
angle
{
template
<
typename
HaystackT
typename
NeedleT
>
bool
IsInContainer
(
const
HaystackT
&
haystack
const
NeedleT
&
needle
)
{
return
std
:
:
find
(
haystack
.
begin
(
)
haystack
.
end
(
)
needle
)
!
=
haystack
.
end
(
)
;
}
using
SubjectIndex
=
size_t
;
enum
class
SubjectMessage
{
BindingChanged
ContentsChanged
DirtyBitsFlagged
SubjectChanged
SubjectMapped
SubjectUnmapped
}
;
class
ObserverInterface
{
public
:
virtual
~
ObserverInterface
(
)
;
virtual
void
onSubjectStateChange
(
SubjectIndex
index
SubjectMessage
message
)
=
0
;
}
;
class
ObserverBindingBase
{
public
:
ObserverBindingBase
(
ObserverInterface
*
observer
SubjectIndex
subjectIndex
)
:
mObserver
(
observer
)
mIndex
(
subjectIndex
)
{
}
virtual
~
ObserverBindingBase
(
)
{
}
ObserverInterface
*
getObserver
(
)
const
{
return
mObserver
;
}
SubjectIndex
getSubjectIndex
(
)
const
{
return
mIndex
;
}
virtual
void
onSubjectReset
(
)
{
}
private
:
ObserverInterface
*
mObserver
;
SubjectIndex
mIndex
;
}
;
class
Subject
:
NonCopyable
{
public
:
Subject
(
)
;
virtual
~
Subject
(
)
;
void
onStateChange
(
SubjectMessage
message
)
const
;
bool
hasObservers
(
)
const
;
void
resetObservers
(
)
;
ANGLE_INLINE
void
addObserver
(
ObserverBindingBase
*
observer
)
{
ASSERT
(
!
IsInContainer
(
mObservers
observer
)
)
;
mObservers
.
push_back
(
observer
)
;
}
ANGLE_INLINE
void
removeObserver
(
ObserverBindingBase
*
observer
)
{
ASSERT
(
IsInContainer
(
mObservers
observer
)
)
;
mObservers
.
remove_and_permute
(
observer
)
;
}
private
:
static
constexpr
size_t
kMaxFixedObservers
=
8
;
angle
:
:
FastVector
<
ObserverBindingBase
*
kMaxFixedObservers
>
mObservers
;
}
;
class
ObserverBinding
final
:
public
ObserverBindingBase
{
public
:
ObserverBinding
(
ObserverInterface
*
observer
SubjectIndex
index
)
;
~
ObserverBinding
(
)
override
;
ObserverBinding
(
const
ObserverBinding
&
other
)
;
ObserverBinding
&
operator
=
(
const
ObserverBinding
&
other
)
;
void
bind
(
Subject
*
subject
)
;
ANGLE_INLINE
void
reset
(
)
{
bind
(
nullptr
)
;
}
void
onStateChange
(
SubjectMessage
message
)
const
;
void
onSubjectReset
(
)
override
;
ANGLE_INLINE
const
Subject
*
getSubject
(
)
const
{
return
mSubject
;
}
ANGLE_INLINE
void
assignSubject
(
Subject
*
subject
)
{
mSubject
=
subject
;
}
private
:
Subject
*
mSubject
;
}
;
}
#
endif
