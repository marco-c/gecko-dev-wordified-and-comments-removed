#
include
"
libANGLE
/
params
.
h
"
#
include
"
common
/
utilities
.
h
"
#
include
"
libANGLE
/
Context
.
h
"
#
include
"
libANGLE
/
VertexArray
.
h
"
namespace
gl
{
constexpr
ParamTypeInfo
ParamsBase
:
:
TypeInfo
;
constexpr
ParamTypeInfo
DrawCallParams
:
:
TypeInfo
;
DrawCallParams
:
:
DrawCallParams
(
PrimitiveMode
mode
GLint
firstVertex
GLsizei
vertexCount
GLsizei
instances
)
:
mMode
(
mode
)
mFirstVertex
(
firstVertex
)
mVertexCount
(
vertexCount
)
mIndexCount
(
0
)
mBaseVertex
(
0
)
mType
(
GL_NONE
)
mIndices
(
nullptr
)
mInstances
(
instances
)
mIndirect
(
nullptr
)
{
}
DrawCallParams
:
:
DrawCallParams
(
PrimitiveMode
mode
GLint
indexCount
GLenum
type
const
void
*
indices
GLint
baseVertex
GLsizei
instances
)
:
mMode
(
mode
)
mFirstVertex
(
0
)
mVertexCount
(
0
)
mIndexCount
(
indexCount
)
mBaseVertex
(
baseVertex
)
mType
(
type
)
mIndices
(
indices
)
mInstances
(
instances
)
mIndirect
(
nullptr
)
{
}
DrawCallParams
:
:
DrawCallParams
(
PrimitiveMode
mode
const
void
*
indirect
)
:
mMode
(
mode
)
mFirstVertex
(
0
)
mVertexCount
(
0
)
mIndexCount
(
0
)
mBaseVertex
(
0
)
mType
(
GL_NONE
)
mIndices
(
nullptr
)
mInstances
(
0
)
mIndirect
(
indirect
)
{
}
DrawCallParams
:
:
DrawCallParams
(
PrimitiveMode
mode
GLenum
type
const
void
*
indirect
)
:
mMode
(
mode
)
mFirstVertex
(
0
)
mVertexCount
(
0
)
mIndexCount
(
0
)
mBaseVertex
(
0
)
mType
(
type
)
mIndices
(
nullptr
)
mInstances
(
0
)
mIndirect
(
indirect
)
{
}
GLint
DrawCallParams
:
:
firstVertex
(
)
const
{
ASSERT
(
mFirstVertex
=
=
0
|
|
(
!
isDrawElements
(
)
|
|
mIndexRange
.
valid
(
)
)
)
;
return
mFirstVertex
;
}
GLsizei
DrawCallParams
:
:
indexCount
(
)
const
{
ASSERT
(
isDrawElements
(
)
)
;
return
mIndexCount
;
}
GLint
DrawCallParams
:
:
baseVertex
(
)
const
{
return
mBaseVertex
;
}
GLenum
DrawCallParams
:
:
type
(
)
const
{
ASSERT
(
isDrawElements
(
)
)
;
return
mType
;
}
const
void
*
DrawCallParams
:
:
indices
(
)
const
{
return
mIndices
;
}
GLsizei
DrawCallParams
:
:
instances
(
)
const
{
return
mInstances
;
}
const
void
*
DrawCallParams
:
:
indirect
(
)
const
{
return
mIndirect
;
}
bool
DrawCallParams
:
:
isDrawIndirect
(
)
const
{
return
(
mIndexCount
=
=
0
&
&
mVertexCount
=
=
0
)
;
}
Error
DrawCallParams
:
:
ensureIndexRangeResolved
(
const
Context
*
context
)
const
{
if
(
mIndexRange
.
valid
(
)
|
|
!
isDrawElements
(
)
)
{
return
NoError
(
)
;
}
const
State
&
state
=
context
-
>
getGLState
(
)
;
const
gl
:
:
VertexArray
*
vao
=
state
.
getVertexArray
(
)
;
gl
:
:
Buffer
*
elementArrayBuffer
=
vao
-
>
getElementArrayBuffer
(
)
.
get
(
)
;
if
(
elementArrayBuffer
)
{
uintptr_t
offset
=
reinterpret_cast
<
uintptr_t
>
(
mIndices
)
;
IndexRange
indexRange
;
ANGLE_TRY
(
elementArrayBuffer
-
>
getIndexRange
(
context
mType
static_cast
<
size_t
>
(
offset
)
mIndexCount
state
.
isPrimitiveRestartEnabled
(
)
&
indexRange
)
)
;
mIndexRange
=
indexRange
;
}
else
{
mIndexRange
=
ComputeIndexRange
(
mType
mIndices
mIndexCount
state
.
isPrimitiveRestartEnabled
(
)
)
;
}
const
IndexRange
&
indexRange
=
mIndexRange
.
value
(
)
;
ASSERT
(
indexRange
.
start
<
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
&
&
indexRange
.
end
<
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
)
;
int64_t
startVertexInt64
=
static_cast
<
int64_t
>
(
mBaseVertex
)
+
static_cast
<
int64_t
>
(
indexRange
.
start
)
;
if
(
startVertexInt64
<
0
)
{
return
gl
:
:
InternalError
(
)
<
<
"
Negative
index
value
.
"
;
}
if
(
startVertexInt64
>
std
:
:
numeric_limits
<
GLint
>
:
:
max
(
)
)
{
return
gl
:
:
InternalError
(
)
<
<
"
Negative
value
overflow
.
"
;
}
mFirstVertex
=
static_cast
<
GLint
>
(
startVertexInt64
)
;
mVertexCount
=
indexRange
.
vertexCount
(
)
;
return
NoError
(
)
;
}
const
IndexRange
&
DrawCallParams
:
:
getIndexRange
(
)
const
{
ASSERT
(
isDrawElements
(
)
&
&
mIndexRange
.
valid
(
)
)
;
return
mIndexRange
.
value
(
)
;
}
}
