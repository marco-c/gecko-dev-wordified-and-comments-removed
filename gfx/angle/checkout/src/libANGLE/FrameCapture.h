#
ifndef
LIBANGLE_FRAME_CAPTURE_H_
#
define
LIBANGLE_FRAME_CAPTURE_H_
#
include
"
common
/
PackedEnums
.
h
"
#
include
"
libANGLE
/
Context
.
h
"
#
include
"
libANGLE
/
angletypes
.
h
"
#
include
"
libANGLE
/
entry_points_utils
.
h
"
#
include
"
libANGLE
/
frame_capture_utils_autogen
.
h
"
namespace
gl
{
enum
class
GLenumGroup
;
}
namespace
angle
{
using
ParamData
=
std
:
:
vector
<
std
:
:
vector
<
uint8_t
>
>
;
struct
ParamCapture
:
angle
:
:
NonCopyable
{
ParamCapture
(
)
;
ParamCapture
(
const
char
*
nameIn
ParamType
typeIn
)
;
~
ParamCapture
(
)
;
ParamCapture
(
ParamCapture
&
&
other
)
;
ParamCapture
&
operator
=
(
ParamCapture
&
&
other
)
;
std
:
:
string
name
;
ParamType
type
;
ParamValue
value
;
gl
:
:
GLenumGroup
enumGroup
;
ParamData
data
;
int
arrayClientPointerIndex
=
-
1
;
size_t
readBufferSizeBytes
=
0
;
}
;
class
ParamBuffer
final
:
angle
:
:
NonCopyable
{
public
:
ParamBuffer
(
)
;
~
ParamBuffer
(
)
;
ParamBuffer
(
ParamBuffer
&
&
other
)
;
ParamBuffer
&
operator
=
(
ParamBuffer
&
&
other
)
;
template
<
typename
T
>
void
addValueParam
(
const
char
*
paramName
ParamType
paramType
T
paramValue
)
;
template
<
typename
T
>
void
addEnumParam
(
const
char
*
paramName
gl
:
:
GLenumGroup
enumGroup
ParamType
paramType
T
paramValue
)
;
ParamCapture
&
getParam
(
const
char
*
paramName
ParamType
paramType
int
index
)
;
const
ParamCapture
&
getParam
(
const
char
*
paramName
ParamType
paramType
int
index
)
const
;
ParamCapture
&
getParamFlexName
(
const
char
*
paramName1
const
char
*
paramName2
ParamType
paramType
int
index
)
;
const
ParamCapture
&
getParamFlexName
(
const
char
*
paramName1
const
char
*
paramName2
ParamType
paramType
int
index
)
const
;
const
ParamCapture
&
getReturnValue
(
)
const
{
return
mReturnValueCapture
;
}
void
addParam
(
ParamCapture
&
&
param
)
;
void
addReturnValue
(
ParamCapture
&
&
returnValue
)
;
bool
hasClientArrayData
(
)
const
{
return
mClientArrayDataParam
!
=
-
1
;
}
ParamCapture
&
getClientArrayPointerParameter
(
)
;
size_t
getReadBufferSize
(
)
const
{
return
mReadBufferSize
;
}
const
std
:
:
vector
<
ParamCapture
>
&
getParamCaptures
(
)
const
{
return
mParamCaptures
;
}
void
setMappedBufferID
(
gl
:
:
BufferID
bufferID
)
{
mMappedBufferID
=
bufferID
;
}
gl
:
:
BufferID
getMappedBufferID
(
)
const
{
return
mMappedBufferID
;
}
private
:
std
:
:
vector
<
ParamCapture
>
mParamCaptures
;
ParamCapture
mReturnValueCapture
;
int
mClientArrayDataParam
=
-
1
;
size_t
mReadBufferSize
=
0
;
gl
:
:
BufferID
mMappedBufferID
;
}
;
struct
CallCapture
{
CallCapture
(
gl
:
:
EntryPoint
entryPointIn
ParamBuffer
&
&
paramsIn
)
;
CallCapture
(
const
std
:
:
string
&
customFunctionNameIn
ParamBuffer
&
&
paramsIn
)
;
~
CallCapture
(
)
;
CallCapture
(
CallCapture
&
&
other
)
;
CallCapture
&
operator
=
(
CallCapture
&
&
other
)
;
const
char
*
name
(
)
const
;
gl
:
:
EntryPoint
entryPoint
;
std
:
:
string
customFunctionName
;
ParamBuffer
params
;
}
;
class
ReplayContext
{
public
:
ReplayContext
(
size_t
readBufferSizebytes
const
gl
:
:
AttribArray
<
size_t
>
&
clientArraysSizebytes
)
;
~
ReplayContext
(
)
;
template
<
typename
T
>
T
getReadBufferPointer
(
const
ParamCapture
&
param
)
{
ASSERT
(
param
.
readBufferSizeBytes
>
0
)
;
ASSERT
(
mReadBuffer
.
size
(
)
>
=
param
.
readBufferSizeBytes
)
;
return
reinterpret_cast
<
T
>
(
mReadBuffer
.
data
(
)
)
;
}
template
<
typename
T
>
T
getAsConstPointer
(
const
ParamCapture
&
param
)
{
if
(
param
.
arrayClientPointerIndex
!
=
-
1
)
{
return
reinterpret_cast
<
T
>
(
mClientArraysBuffer
[
param
.
arrayClientPointerIndex
]
.
data
(
)
)
;
}
if
(
!
param
.
data
.
empty
(
)
)
{
ASSERT
(
param
.
data
.
size
(
)
=
=
1
)
;
return
reinterpret_cast
<
T
>
(
param
.
data
[
0
]
.
data
(
)
)
;
}
return
nullptr
;
}
template
<
typename
T
>
T
getAsPointerConstPointer
(
const
ParamCapture
&
param
)
{
static_assert
(
sizeof
(
typename
std
:
:
remove_pointer
<
T
>
:
:
type
)
=
=
sizeof
(
uint8_t
*
)
"
pointer
size
not
match
!
"
)
;
ASSERT
(
!
param
.
data
.
empty
(
)
)
;
mPointersBuffer
.
clear
(
)
;
mPointersBuffer
.
reserve
(
param
.
data
.
size
(
)
)
;
for
(
const
std
:
:
vector
<
uint8_t
>
&
data
:
param
.
data
)
{
mPointersBuffer
.
emplace_back
(
data
.
data
(
)
)
;
}
return
reinterpret_cast
<
T
>
(
mPointersBuffer
.
data
(
)
)
;
}
gl
:
:
AttribArray
<
std
:
:
vector
<
uint8_t
>
>
&
getClientArraysBuffer
(
)
{
return
mClientArraysBuffer
;
}
private
:
std
:
:
vector
<
uint8_t
>
mReadBuffer
;
std
:
:
vector
<
const
uint8_t
*
>
mPointersBuffer
;
gl
:
:
AttribArray
<
std
:
:
vector
<
uint8_t
>
>
mClientArraysBuffer
;
}
;
class
DataCounters
final
:
angle
:
:
NonCopyable
{
public
:
DataCounters
(
)
;
~
DataCounters
(
)
;
int
getAndIncrement
(
gl
:
:
EntryPoint
entryPoint
const
std
:
:
string
&
paramName
)
;
private
:
using
Counter
=
std
:
:
pair
<
gl
:
:
EntryPoint
std
:
:
string
>
;
std
:
:
map
<
Counter
int
>
mData
;
}
;
constexpr
int
kStringsNotFound
=
-
1
;
class
StringCounters
final
:
angle
:
:
NonCopyable
{
public
:
StringCounters
(
)
;
~
StringCounters
(
)
;
int
getStringCounter
(
std
:
:
vector
<
std
:
:
string
>
&
str
)
;
void
setStringCounter
(
std
:
:
vector
<
std
:
:
string
>
&
str
int
&
counter
)
;
private
:
std
:
:
map
<
std
:
:
vector
<
std
:
:
string
>
int
>
mStringCounterMap
;
}
;
class
DataTracker
final
:
angle
:
:
NonCopyable
{
public
:
DataTracker
(
)
;
~
DataTracker
(
)
;
DataCounters
&
getCounters
(
)
{
return
mCounters
;
}
StringCounters
&
getStringCounters
(
)
{
return
mStringCounters
;
}
private
:
DataCounters
mCounters
;
StringCounters
mStringCounters
;
}
;
using
BufferSet
=
std
:
:
set
<
gl
:
:
BufferID
>
;
using
BufferCalls
=
std
:
:
map
<
gl
:
:
BufferID
std
:
:
vector
<
CallCapture
>
>
;
using
BufferMapStatusMap
=
std
:
:
map
<
gl
:
:
BufferID
bool
>
;
class
ResourceTracker
final
:
angle
:
:
NonCopyable
{
public
:
ResourceTracker
(
)
;
~
ResourceTracker
(
)
;
BufferCalls
&
getBufferRegenCalls
(
)
{
return
mBufferRegenCalls
;
}
BufferCalls
&
getBufferRestoreCalls
(
)
{
return
mBufferRestoreCalls
;
}
BufferCalls
&
getBufferMapCalls
(
)
{
return
mBufferMapCalls
;
}
BufferCalls
&
getBufferUnmapCalls
(
)
{
return
mBufferUnmapCalls
;
}
std
:
:
vector
<
CallCapture
>
&
getBufferBindingCalls
(
)
{
return
mBufferBindingCalls
;
}
BufferSet
&
getStartingBuffers
(
)
{
return
mStartingBuffers
;
}
BufferSet
&
getNewBuffers
(
)
{
return
mNewBuffers
;
}
BufferSet
&
getBuffersToRegen
(
)
{
return
mBuffersToRegen
;
}
BufferSet
&
getBuffersToRestore
(
)
{
return
mBuffersToRestore
;
}
void
setGennedBuffer
(
gl
:
:
BufferID
id
)
;
void
setDeletedBuffer
(
gl
:
:
BufferID
id
)
;
void
setBufferModified
(
gl
:
:
BufferID
id
)
;
void
setBufferMapped
(
gl
:
:
BufferID
id
)
;
void
setBufferUnmapped
(
gl
:
:
BufferID
id
)
;
const
bool
&
getStartingBuffersMappedCurrent
(
gl
:
:
BufferID
id
)
{
return
mStartingBuffersMappedCurrent
[
id
]
;
}
const
bool
&
getStartingBuffersMappedInitial
(
gl
:
:
BufferID
id
)
{
return
mStartingBuffersMappedInitial
[
id
]
;
}
void
setStartingBufferMapped
(
gl
:
:
BufferID
id
bool
mapped
)
{
mStartingBuffersMappedCurrent
[
id
]
=
mapped
;
mStartingBuffersMappedInitial
[
id
]
=
mapped
;
}
void
onShaderProgramAccess
(
gl
:
:
ShaderProgramID
shaderProgramID
)
;
uint32_t
getMaxShaderPrograms
(
)
const
{
return
mMaxShaderPrograms
;
}
private
:
BufferCalls
mBufferRegenCalls
;
BufferCalls
mBufferRestoreCalls
;
BufferCalls
mBufferMapCalls
;
BufferCalls
mBufferUnmapCalls
;
std
:
:
vector
<
CallCapture
>
mBufferBindingCalls
;
BufferSet
mStartingBuffers
;
BufferSet
mNewBuffers
;
BufferSet
mBuffersToRegen
;
BufferSet
mBuffersToRestore
;
BufferMapStatusMap
mStartingBuffersMappedInitial
;
BufferMapStatusMap
mStartingBuffersMappedCurrent
;
uint32_t
mMaxShaderPrograms
=
0
;
}
;
using
HasResourceTypeMap
=
angle
:
:
PackedEnumBitSet
<
ResourceIDType
>
;
using
BufferDataMap
=
std
:
:
map
<
gl
:
:
BufferID
std
:
:
pair
<
GLintptr
GLsizeiptr
>
>
;
using
ProgramSources
=
gl
:
:
ShaderMap
<
std
:
:
string
>
;
using
ShaderSourceMap
=
std
:
:
map
<
gl
:
:
ShaderProgramID
std
:
:
string
>
;
using
ProgramSourceMap
=
std
:
:
map
<
gl
:
:
ShaderProgramID
ProgramSources
>
;
using
TextureLevels
=
std
:
:
map
<
GLint
std
:
:
vector
<
uint8_t
>
>
;
using
TextureLevelDataMap
=
std
:
:
map
<
gl
:
:
TextureID
TextureLevels
>
;
using
SurfaceDimensions
=
std
:
:
map
<
gl
:
:
ContextID
gl
:
:
Extents
>
;
class
FrameCapture
final
:
angle
:
:
NonCopyable
{
public
:
FrameCapture
(
)
;
~
FrameCapture
(
)
;
void
captureCall
(
const
gl
:
:
Context
*
context
CallCapture
&
&
call
)
;
void
checkForCaptureTrigger
(
)
;
void
onEndFrame
(
const
gl
:
:
Context
*
context
)
;
void
onDestroyContext
(
const
gl
:
:
Context
*
context
)
;
void
onMakeCurrent
(
const
gl
:
:
Context
*
context
const
egl
:
:
Surface
*
drawSurface
)
;
bool
enabled
(
)
const
{
return
mEnabled
;
}
bool
isCapturing
(
)
const
;
void
replay
(
gl
:
:
Context
*
context
)
;
uint32_t
getFrameCount
(
)
const
;
uint32_t
getReplayFrameIndex
(
)
const
;
void
trackBufferMapping
(
CallCapture
*
call
gl
:
:
BufferID
id
GLintptr
offset
GLsizeiptr
length
bool
writable
)
;
ResourceTracker
&
getResouceTracker
(
)
{
return
mResourceTracker
;
}
private
:
void
captureClientArraySnapshot
(
const
gl
:
:
Context
*
context
size_t
vertexCount
size_t
instanceCount
)
;
void
captureMappedBufferSnapshot
(
const
gl
:
:
Context
*
context
const
CallCapture
&
call
)
;
void
captureCompressedTextureData
(
const
gl
:
:
Context
*
context
const
CallCapture
&
call
)
;
void
reset
(
)
;
void
maybeOverrideEntryPoint
(
const
gl
:
:
Context
*
context
CallCapture
&
call
)
;
void
maybeCapturePreCallUpdates
(
const
gl
:
:
Context
*
context
CallCapture
&
call
)
;
void
maybeCapturePostCallUpdates
(
const
gl
:
:
Context
*
context
)
;
static
void
ReplayCall
(
gl
:
:
Context
*
context
ReplayContext
*
replayContext
const
CallCapture
&
call
)
;
std
:
:
vector
<
CallCapture
>
mSetupCalls
;
std
:
:
vector
<
CallCapture
>
mFrameCalls
;
std
:
:
vector
<
uint8_t
>
mBinaryData
;
bool
mEnabled
=
false
;
bool
mSerializeStateEnabled
;
std
:
:
string
mOutDirectory
;
std
:
:
string
mCaptureLabel
;
bool
mCompression
;
gl
:
:
AttribArray
<
int
>
mClientVertexArrayMap
;
uint32_t
mFrameIndex
;
uint32_t
mCaptureStartFrame
;
uint32_t
mCaptureEndFrame
;
bool
mIsFirstFrame
=
true
;
bool
mWroteIndexFile
=
false
;
SurfaceDimensions
mDrawSurfaceDimensions
;
gl
:
:
AttribArray
<
size_t
>
mClientArraySizes
;
size_t
mReadBufferSize
;
HasResourceTypeMap
mHasResourceType
;
BufferDataMap
mBufferDataMap
;
ResourceTracker
mResourceTracker
;
uint32_t
mCaptureTrigger
;
}
;
class
FrameCaptureShared
final
:
angle
:
:
NonCopyable
{
public
:
FrameCaptureShared
(
)
;
~
FrameCaptureShared
(
)
;
const
std
:
:
string
&
getShaderSource
(
gl
:
:
ShaderProgramID
id
)
const
;
void
setShaderSource
(
gl
:
:
ShaderProgramID
id
std
:
:
string
sources
)
;
const
ProgramSources
&
getProgramSources
(
gl
:
:
ShaderProgramID
id
)
const
;
void
setProgramSources
(
gl
:
:
ShaderProgramID
id
ProgramSources
sources
)
;
const
std
:
:
vector
<
uint8_t
>
&
retrieveCachedTextureLevel
(
gl
:
:
TextureID
id
GLint
level
)
;
std
:
:
vector
<
uint8_t
>
&
getTextureLevelCacheLocation
(
gl
:
:
Texture
*
texture
gl
:
:
TextureTarget
target
GLint
level
)
;
void
deleteCachedTextureLevelData
(
gl
:
:
TextureID
id
)
;
private
:
ShaderSourceMap
mCachedShaderSource
;
ProgramSourceMap
mCachedProgramSources
;
TextureLevels
mCachedTextureLevels
;
TextureLevelDataMap
mCachedTextureLevelData
;
}
;
template
<
typename
CaptureFuncT
typename
.
.
.
ArgsT
>
void
CaptureCallToFrameCapture
(
CaptureFuncT
captureFunc
bool
isCallValid
gl
:
:
Context
*
context
ArgsT
.
.
.
captureParams
)
{
FrameCapture
*
frameCapture
=
context
-
>
getFrameCapture
(
)
;
if
(
!
frameCapture
-
>
isCapturing
(
)
)
return
;
CallCapture
call
=
captureFunc
(
context
-
>
getState
(
)
isCallValid
captureParams
.
.
.
)
;
if
(
!
isCallValid
)
INFO
(
)
<
<
"
FrameCapture
:
Capturing
invalid
call
to
"
<
<
GetEntryPointName
(
call
.
entryPoint
)
;
frameCapture
-
>
captureCall
(
context
std
:
:
move
(
call
)
)
;
}
template
<
typename
T
>
void
ParamBuffer
:
:
addValueParam
(
const
char
*
paramName
ParamType
paramType
T
paramValue
)
{
ParamCapture
capture
(
paramName
paramType
)
;
InitParamValue
(
paramType
paramValue
&
capture
.
value
)
;
mParamCaptures
.
emplace_back
(
std
:
:
move
(
capture
)
)
;
}
template
<
typename
T
>
void
ParamBuffer
:
:
addEnumParam
(
const
char
*
paramName
gl
:
:
GLenumGroup
enumGroup
ParamType
paramType
T
paramValue
)
{
ParamCapture
capture
(
paramName
paramType
)
;
InitParamValue
(
paramType
paramValue
&
capture
.
value
)
;
capture
.
enumGroup
=
enumGroup
;
mParamCaptures
.
emplace_back
(
std
:
:
move
(
capture
)
)
;
}
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
const
ParamCapture
&
capture
)
;
void
CaptureMemory
(
const
void
*
source
size_t
size
ParamCapture
*
paramCapture
)
;
void
CaptureString
(
const
GLchar
*
str
ParamCapture
*
paramCapture
)
;
void
CaptureStringLimit
(
const
GLchar
*
str
uint32_t
limit
ParamCapture
*
paramCapture
)
;
gl
:
:
Program
*
GetProgramForCapture
(
const
gl
:
:
State
&
glState
gl
:
:
ShaderProgramID
handle
)
;
void
CaptureGetParameter
(
const
gl
:
:
State
&
glState
GLenum
pname
size_t
typeSize
ParamCapture
*
paramCapture
)
;
void
CaptureGetActiveUniformBlockivParameters
(
const
gl
:
:
State
&
glState
gl
:
:
ShaderProgramID
handle
GLuint
uniformBlockIndex
GLenum
pname
ParamCapture
*
paramCapture
)
;
template
<
typename
T
>
void
CaptureClearBufferValue
(
GLenum
buffer
const
T
*
value
ParamCapture
*
paramCapture
)
{
uint32_t
valueSize
=
(
buffer
=
=
GL_COLOR
)
?
4
:
1
;
CaptureMemory
(
value
valueSize
*
sizeof
(
T
)
paramCapture
)
;
}
void
CaptureGenHandlesImpl
(
GLsizei
n
GLuint
*
handles
ParamCapture
*
paramCapture
)
;
template
<
typename
T
>
void
CaptureGenHandles
(
GLsizei
n
T
*
handles
ParamCapture
*
paramCapture
)
{
CaptureGenHandlesImpl
(
n
reinterpret_cast
<
GLuint
*
>
(
handles
)
paramCapture
)
;
}
template
<
ParamType
ParamT
typename
T
>
void
WriteParamValueReplay
(
std
:
:
ostream
&
os
const
CallCapture
&
call
T
value
)
;
template
<
>
void
WriteParamValueReplay
<
ParamType
:
:
TGLboolean
>
(
std
:
:
ostream
&
os
const
CallCapture
&
call
GLboolean
value
)
;
template
<
>
void
WriteParamValueReplay
<
ParamType
:
:
TvoidConstPointer
>
(
std
:
:
ostream
&
os
const
CallCapture
&
call
const
void
*
value
)
;
template
<
>
void
WriteParamValueReplay
<
ParamType
:
:
TGLDEBUGPROCKHR
>
(
std
:
:
ostream
&
os
const
CallCapture
&
call
GLDEBUGPROCKHR
value
)
;
template
<
>
void
WriteParamValueReplay
<
ParamType
:
:
TGLDEBUGPROC
>
(
std
:
:
ostream
&
os
const
CallCapture
&
call
GLDEBUGPROC
value
)
;
template
<
>
void
WriteParamValueReplay
<
ParamType
:
:
TBufferID
>
(
std
:
:
ostream
&
os
const
CallCapture
&
call
gl
:
:
BufferID
value
)
;
template
<
>
void
WriteParamValueReplay
<
ParamType
:
:
TFenceNVID
>
(
std
:
:
ostream
&
os
const
CallCapture
&
call
gl
:
:
FenceNVID
value
)
;
template
<
>
void
WriteParamValueReplay
<
ParamType
:
:
TFramebufferID
>
(
std
:
:
ostream
&
os
const
CallCapture
&
call
gl
:
:
FramebufferID
value
)
;
template
<
>
void
WriteParamValueReplay
<
ParamType
:
:
TMemoryObjectID
>
(
std
:
:
ostream
&
os
const
CallCapture
&
call
gl
:
:
MemoryObjectID
value
)
;
template
<
>
void
WriteParamValueReplay
<
ParamType
:
:
TProgramPipelineID
>
(
std
:
:
ostream
&
os
const
CallCapture
&
call
gl
:
:
ProgramPipelineID
value
)
;
template
<
>
void
WriteParamValueReplay
<
ParamType
:
:
TQueryID
>
(
std
:
:
ostream
&
os
const
CallCapture
&
call
gl
:
:
QueryID
value
)
;
template
<
>
void
WriteParamValueReplay
<
ParamType
:
:
TRenderbufferID
>
(
std
:
:
ostream
&
os
const
CallCapture
&
call
gl
:
:
RenderbufferID
value
)
;
template
<
>
void
WriteParamValueReplay
<
ParamType
:
:
TSamplerID
>
(
std
:
:
ostream
&
os
const
CallCapture
&
call
gl
:
:
SamplerID
value
)
;
template
<
>
void
WriteParamValueReplay
<
ParamType
:
:
TSemaphoreID
>
(
std
:
:
ostream
&
os
const
CallCapture
&
call
gl
:
:
SemaphoreID
value
)
;
template
<
>
void
WriteParamValueReplay
<
ParamType
:
:
TShaderProgramID
>
(
std
:
:
ostream
&
os
const
CallCapture
&
call
gl
:
:
ShaderProgramID
value
)
;
template
<
>
void
WriteParamValueReplay
<
ParamType
:
:
TTextureID
>
(
std
:
:
ostream
&
os
const
CallCapture
&
call
gl
:
:
TextureID
value
)
;
template
<
>
void
WriteParamValueReplay
<
ParamType
:
:
TTransformFeedbackID
>
(
std
:
:
ostream
&
os
const
CallCapture
&
call
gl
:
:
TransformFeedbackID
value
)
;
template
<
>
void
WriteParamValueReplay
<
ParamType
:
:
TVertexArrayID
>
(
std
:
:
ostream
&
os
const
CallCapture
&
call
gl
:
:
VertexArrayID
value
)
;
template
<
>
void
WriteParamValueReplay
<
ParamType
:
:
TUniformLocation
>
(
std
:
:
ostream
&
os
const
CallCapture
&
call
gl
:
:
UniformLocation
value
)
;
template
<
>
void
WriteParamValueReplay
<
ParamType
:
:
TGLsync
>
(
std
:
:
ostream
&
os
const
CallCapture
&
call
GLsync
value
)
;
template
<
ParamType
ParamT
typename
T
>
void
WriteParamValueReplay
(
std
:
:
ostream
&
os
const
CallCapture
&
call
T
value
)
{
os
<
<
value
;
}
}
template
<
typename
T
>
void
CaptureTextureAndSamplerParameter_params
(
GLenum
pname
const
T
*
param
angle
:
:
ParamCapture
*
paramCapture
)
{
if
(
pname
=
=
GL_TEXTURE_BORDER_COLOR
)
{
CaptureMemory
(
param
sizeof
(
T
)
*
4
paramCapture
)
;
}
else
{
CaptureMemory
(
param
sizeof
(
T
)
paramCapture
)
;
}
}
#
endif
