#
ifndef
LIBANGLE_IMAGE_H_
#
define
LIBANGLE_IMAGE_H_
#
include
"
common
/
angleutils
.
h
"
#
include
"
libANGLE
/
AttributeMap
.
h
"
#
include
"
libANGLE
/
Debug
.
h
"
#
include
"
libANGLE
/
Error
.
h
"
#
include
"
libANGLE
/
FramebufferAttachment
.
h
"
#
include
"
libANGLE
/
RefCountObject
.
h
"
#
include
"
libANGLE
/
formatutils
.
h
"
#
include
<
set
>
namespace
rx
{
class
EGLImplFactory
;
class
ImageImpl
;
}
namespace
egl
{
class
Image
;
class
Display
;
class
ImageSibling
:
public
gl
:
:
FramebufferAttachmentObject
{
public
:
ImageSibling
(
)
;
~
ImageSibling
(
)
override
;
bool
isEGLImageTarget
(
)
const
;
gl
:
:
InitState
sourceEGLImageInitState
(
)
const
;
void
setSourceEGLImageInitState
(
gl
:
:
InitState
initState
)
const
;
protected
:
void
setTargetImage
(
const
gl
:
:
Context
*
context
egl
:
:
Image
*
imageTarget
)
;
gl
:
:
Error
orphanImages
(
const
gl
:
:
Context
*
context
)
;
private
:
friend
class
Image
;
void
addImageSource
(
egl
:
:
Image
*
imageSource
)
;
void
removeImageSource
(
egl
:
:
Image
*
imageSource
)
;
std
:
:
set
<
Image
*
>
mSourcesOf
;
BindingPointer
<
Image
>
mTargetOf
;
}
;
struct
ImageState
:
private
angle
:
:
NonCopyable
{
ImageState
(
EGLenum
target
ImageSibling
*
buffer
const
AttributeMap
&
attribs
)
;
~
ImageState
(
)
;
EGLLabelKHR
label
;
gl
:
:
ImageIndex
imageIndex
;
ImageSibling
*
source
;
std
:
:
set
<
ImageSibling
*
>
targets
;
gl
:
:
Format
format
;
gl
:
:
Extents
size
;
size_t
samples
;
}
;
class
Image
final
:
public
RefCountObject
public
LabeledObject
{
public
:
Image
(
rx
:
:
EGLImplFactory
*
factory
const
gl
:
:
Context
*
context
EGLenum
target
ImageSibling
*
buffer
const
AttributeMap
&
attribs
)
;
Error
onDestroy
(
const
Display
*
display
)
override
;
~
Image
(
)
override
;
void
setLabel
(
EGLLabelKHR
label
)
override
;
EGLLabelKHR
getLabel
(
)
const
override
;
const
gl
:
:
Format
&
getFormat
(
)
const
;
size_t
getWidth
(
)
const
;
size_t
getHeight
(
)
const
;
size_t
getSamples
(
)
const
;
Error
initialize
(
const
Display
*
display
)
;
rx
:
:
ImageImpl
*
getImplementation
(
)
const
;
bool
orphaned
(
)
const
;
gl
:
:
InitState
sourceInitState
(
)
const
;
void
setInitState
(
gl
:
:
InitState
initState
)
;
private
:
friend
class
ImageSibling
;
void
addTargetSibling
(
ImageSibling
*
sibling
)
;
gl
:
:
Error
orphanSibling
(
const
gl
:
:
Context
*
context
ImageSibling
*
sibling
)
;
ImageState
mState
;
rx
:
:
ImageImpl
*
mImplementation
;
bool
mOrphanedAndNeedsInit
;
}
;
}
#
endif
