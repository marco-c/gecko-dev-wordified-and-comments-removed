#
include
"
libANGLE
/
PixelLocalStorage
.
h
"
#
include
<
numeric
>
#
include
"
libANGLE
/
Context
.
h
"
#
include
"
libANGLE
/
Framebuffer
.
h
"
#
include
"
libANGLE
/
Texture
.
h
"
#
include
"
libANGLE
/
renderer
/
ContextImpl
.
h
"
namespace
gl
{
namespace
{
class
ScopedBindTexture2D
{
public
:
ScopedBindTexture2D
(
Context
*
context
TextureID
texture
)
:
mContext
(
context
)
mSavedTexBinding2D
(
mContext
-
>
getState
(
)
.
getSamplerTextureId
(
mContext
-
>
getState
(
)
.
getActiveSampler
(
)
TextureType
:
:
_2D
)
)
{
mContext
-
>
bindTexture
(
TextureType
:
:
_2D
texture
)
;
}
~
ScopedBindTexture2D
(
)
{
mContext
-
>
bindTexture
(
TextureType
:
:
_2D
mSavedTexBinding2D
)
;
}
private
:
Context
*
const
mContext
;
TextureID
mSavedTexBinding2D
;
}
;
class
ScopedRestoreDrawFramebuffer
{
public
:
ScopedRestoreDrawFramebuffer
(
Context
*
context
)
:
mContext
(
context
)
mSavedFramebuffer
(
mContext
-
>
getState
(
)
.
getDrawFramebuffer
(
)
)
{
ASSERT
(
mSavedFramebuffer
)
;
}
~
ScopedRestoreDrawFramebuffer
(
)
{
mContext
-
>
bindDrawFramebuffer
(
mSavedFramebuffer
-
>
id
(
)
)
;
}
private
:
Context
*
const
mContext
;
Framebuffer
*
const
mSavedFramebuffer
;
}
;
class
ScopedDisableScissor
{
public
:
ScopedDisableScissor
(
Context
*
context
)
:
mContext
(
context
)
mScissorTestEnabled
(
mContext
-
>
getState
(
)
.
isScissorTestEnabled
(
)
)
{
if
(
mScissorTestEnabled
)
{
mContext
-
>
disable
(
GL_SCISSOR_TEST
)
;
}
}
~
ScopedDisableScissor
(
)
{
if
(
mScissorTestEnabled
)
{
mContext
-
>
enable
(
GL_SCISSOR_TEST
)
;
}
}
private
:
Context
*
const
mContext
;
const
GLint
mScissorTestEnabled
;
}
;
}
PixelLocalStoragePlane
:
:
~
PixelLocalStoragePlane
(
)
{
ASSERT
(
mMemorylessTextureID
.
value
=
=
0
)
;
ASSERT
(
mTextureRef
=
=
nullptr
)
;
}
void
PixelLocalStoragePlane
:
:
onContextObjectsLost
(
)
{
mMemorylessTextureID
=
TextureID
(
)
;
}
void
PixelLocalStoragePlane
:
:
onFramebufferDestroyed
(
const
Context
*
context
)
{
if
(
mTextureRef
!
=
nullptr
)
{
mTextureRef
-
>
release
(
context
)
;
mTextureRef
=
nullptr
;
}
}
void
PixelLocalStoragePlane
:
:
deinitialize
(
Context
*
context
)
{
mInternalformat
=
GL_NONE
;
mMemoryless
=
false
;
if
(
mMemorylessTextureID
.
value
!
=
0
)
{
context
-
>
deleteTexture
(
mMemorylessTextureID
)
;
mMemorylessTextureID
=
TextureID
(
)
;
}
if
(
mTextureRef
!
=
nullptr
)
{
mTextureRef
-
>
release
(
context
)
;
mTextureRef
=
nullptr
;
}
}
void
PixelLocalStoragePlane
:
:
setMemoryless
(
Context
*
context
GLenum
internalformat
)
{
deinitialize
(
context
)
;
mInternalformat
=
internalformat
;
mMemoryless
=
true
;
mTextureImageIndex
=
ImageIndex
:
:
MakeFromType
(
TextureType
:
:
_2D
0
0
)
;
ASSERT
(
mMemorylessTextureID
.
value
=
=
0
)
;
ASSERT
(
mTextureRef
=
=
nullptr
)
;
}
void
PixelLocalStoragePlane
:
:
setTextureBacked
(
Context
*
context
Texture
*
tex
int
level
int
layer
)
{
deinitialize
(
context
)
;
ASSERT
(
tex
-
>
getImmutableFormat
(
)
)
;
mInternalformat
=
tex
-
>
getState
(
)
.
getBaseLevelDesc
(
)
.
format
.
info
-
>
internalFormat
;
mMemoryless
=
false
;
mTextureImageIndex
=
ImageIndex
:
:
MakeFromType
(
tex
-
>
getType
(
)
level
layer
)
;
mTextureRef
=
tex
;
mTextureRef
-
>
addRef
(
)
;
}
bool
PixelLocalStoragePlane
:
:
isTextureIDDeleted
(
const
Context
*
context
)
const
{
ASSERT
(
!
isDeinitialized
(
)
|
|
mTextureRef
=
=
nullptr
)
;
return
mTextureRef
!
=
nullptr
&
&
context
-
>
getTexture
(
mTextureRef
-
>
id
(
)
)
!
=
mTextureRef
;
}
GLint
PixelLocalStoragePlane
:
:
getIntegeri
(
const
Context
*
context
GLenum
target
GLuint
index
)
const
{
if
(
!
isDeinitialized
(
)
)
{
bool
memoryless
=
isMemoryless
(
)
|
|
isTextureIDDeleted
(
context
)
;
switch
(
target
)
{
case
GL_PIXEL_LOCAL_FORMAT_ANGLE
:
return
mInternalformat
;
case
GL_PIXEL_LOCAL_TEXTURE_NAME_ANGLE
:
return
memoryless
?
0
:
mTextureRef
-
>
id
(
)
.
value
;
case
GL_PIXEL_LOCAL_TEXTURE_LEVEL_ANGLE
:
return
memoryless
?
0
:
mTextureImageIndex
.
getLevelIndex
(
)
;
case
GL_PIXEL_LOCAL_TEXTURE_LAYER_ANGLE
:
return
memoryless
?
0
:
mTextureImageIndex
.
getLayerIndex
(
)
;
}
}
static_assert
(
GL_NONE
=
=
0
"
Expecting
GL_NONE
to
be
zero
.
"
)
;
return
0
;
}
bool
PixelLocalStoragePlane
:
:
getTextureImageExtents
(
const
Context
*
context
Extents
*
extents
)
const
{
if
(
isDeinitialized
(
)
|
|
isMemoryless
(
)
|
|
isTextureIDDeleted
(
context
)
)
{
return
false
;
}
ASSERT
(
mTextureRef
!
=
nullptr
)
;
*
extents
=
mTextureRef
-
>
getExtents
(
mTextureImageIndex
.
getTarget
(
)
mTextureImageIndex
.
getLevelIndex
(
)
)
;
extents
-
>
depth
=
0
;
return
true
;
}
void
PixelLocalStoragePlane
:
:
ensureBackingIfMemoryless
(
Context
*
context
Extents
plsExtents
)
{
ASSERT
(
!
isDeinitialized
(
)
)
;
ASSERT
(
!
isTextureIDDeleted
(
context
)
)
;
if
(
!
isMemoryless
(
)
)
{
ASSERT
(
mTextureRef
!
=
nullptr
)
;
return
;
}
ASSERT
(
mTextureImageIndex
.
getType
(
)
=
=
TextureType
:
:
_2D
)
;
ASSERT
(
mTextureImageIndex
.
getLevelIndex
(
)
=
=
0
)
;
ASSERT
(
mTextureImageIndex
.
getLayerIndex
(
)
=
=
0
)
;
const
bool
hasMemorylessTextureId
=
mMemorylessTextureID
.
value
!
=
0
;
const
bool
hasTextureRef
=
mTextureRef
!
=
nullptr
;
ASSERT
(
hasMemorylessTextureId
=
=
hasTextureRef
)
;
if
(
mTextureRef
=
=
nullptr
|
|
static_cast
<
GLsizei
>
(
mTextureRef
-
>
getWidth
(
TextureTarget
:
:
_2D
0
)
)
!
=
plsExtents
.
width
|
|
static_cast
<
GLsizei
>
(
mTextureRef
-
>
getHeight
(
TextureTarget
:
:
_2D
0
)
)
!
=
plsExtents
.
height
)
{
setMemoryless
(
context
mInternalformat
)
;
ASSERT
(
mTextureRef
=
=
nullptr
)
;
ASSERT
(
mMemorylessTextureID
.
value
=
=
0
)
;
context
-
>
genTextures
(
1
&
mMemorylessTextureID
)
;
{
ScopedBindTexture2D
scopedBindTexture2D
(
context
mMemorylessTextureID
)
;
context
-
>
bindTexture
(
TextureType
:
:
_2D
mMemorylessTextureID
)
;
context
-
>
texStorage2D
(
TextureType
:
:
_2D
1
mInternalformat
plsExtents
.
width
plsExtents
.
height
)
;
}
mTextureRef
=
context
-
>
getTexture
(
mMemorylessTextureID
)
;
ASSERT
(
mTextureRef
!
=
nullptr
)
;
ASSERT
(
mTextureRef
-
>
id
(
)
=
=
mMemorylessTextureID
)
;
mTextureRef
-
>
addRef
(
)
;
}
}
void
PixelLocalStoragePlane
:
:
attachToDrawFramebuffer
(
Context
*
context
Extents
plsExtents
GLenum
colorAttachment
)
{
ASSERT
(
!
isDeinitialized
(
)
)
;
ensureBackingIfMemoryless
(
context
plsExtents
)
;
ASSERT
(
mTextureRef
!
=
nullptr
)
;
if
(
mTextureImageIndex
.
usesTex3D
(
)
)
{
context
-
>
framebufferTextureLayer
(
GL_DRAW_FRAMEBUFFER
colorAttachment
mTextureRef
-
>
id
(
)
mTextureImageIndex
.
getLevelIndex
(
)
mTextureImageIndex
.
getLayerIndex
(
)
)
;
}
else
{
context
-
>
framebufferTexture2D
(
GL_DRAW_FRAMEBUFFER
colorAttachment
mTextureImageIndex
.
getTarget
(
)
mTextureRef
-
>
id
(
)
mTextureImageIndex
.
getLevelIndex
(
)
)
;
}
}
void
PixelLocalStoragePlane
:
:
performLoadOperationClear
(
Context
*
context
GLint
drawBuffer
GLenum
loadop
const
void
*
data
)
{
ASSERT
(
!
context
-
>
getState
(
)
.
isScissorTestEnabled
(
)
)
;
switch
(
mInternalformat
)
{
case
GL_RGBA8
:
case
GL_R32F
:
{
GLfloat
clearValue
[
4
]
{
}
;
if
(
loadop
=
=
GL_CLEAR_ANGLE
)
{
memcpy
(
clearValue
data
sizeof
(
clearValue
)
)
;
}
context
-
>
clearBufferfv
(
GL_COLOR
drawBuffer
clearValue
)
;
break
;
}
case
GL_RGBA8I
:
{
GLint
clearValue
[
4
]
{
}
;
if
(
loadop
=
=
GL_CLEAR_ANGLE
)
{
memcpy
(
clearValue
data
sizeof
(
clearValue
)
)
;
}
context
-
>
clearBufferiv
(
GL_COLOR
drawBuffer
clearValue
)
;
break
;
}
case
GL_RGBA8UI
:
case
GL_R32UI
:
{
GLuint
clearValue
[
4
]
{
}
;
if
(
loadop
=
=
GL_CLEAR_ANGLE
)
{
memcpy
(
clearValue
data
sizeof
(
clearValue
)
)
;
}
context
-
>
clearBufferuiv
(
GL_COLOR
drawBuffer
clearValue
)
;
break
;
}
default
:
UNREACHABLE
(
)
;
}
}
void
PixelLocalStoragePlane
:
:
bindToImage
(
Context
*
context
Extents
plsExtents
GLuint
unit
bool
needsR32Packing
)
{
ASSERT
(
!
isDeinitialized
(
)
)
;
ensureBackingIfMemoryless
(
context
plsExtents
)
;
ASSERT
(
mTextureRef
!
=
nullptr
)
;
GLenum
imageBindingFormat
=
mInternalformat
;
if
(
needsR32Packing
)
{
switch
(
imageBindingFormat
)
{
case
GL_RGBA8
:
case
GL_RGBA8UI
:
imageBindingFormat
=
GL_R32UI
;
break
;
case
GL_RGBA8I
:
imageBindingFormat
=
GL_R32I
;
break
;
}
}
if
(
mTextureRef
-
>
getType
(
)
!
=
TextureType
:
:
_2D
)
{
UNIMPLEMENTED
(
)
;
}
context
-
>
bindImageTexture
(
unit
mTextureRef
-
>
id
(
)
mTextureImageIndex
.
getLevelIndex
(
)
GL_FALSE
mTextureImageIndex
.
getLayerIndex
(
)
GL_READ_WRITE
imageBindingFormat
)
;
}
PixelLocalStorage
:
:
PixelLocalStorage
(
)
{
}
PixelLocalStorage
:
:
~
PixelLocalStorage
(
)
{
}
void
PixelLocalStorage
:
:
onFramebufferDestroyed
(
const
Context
*
context
)
{
if
(
context
-
>
getRefCount
(
)
=
=
0
)
{
onContextObjectsLost
(
)
;
for
(
PixelLocalStoragePlane
&
plane
:
mPlanes
)
{
plane
.
onContextObjectsLost
(
)
;
}
}
for
(
PixelLocalStoragePlane
&
plane
:
mPlanes
)
{
plane
.
onFramebufferDestroyed
(
context
)
;
}
}
void
PixelLocalStorage
:
:
deleteContextObjects
(
Context
*
context
)
{
onDeleteContextObjects
(
context
)
;
for
(
PixelLocalStoragePlane
&
plane
:
mPlanes
)
{
plane
.
deinitialize
(
context
)
;
}
}
void
PixelLocalStorage
:
:
begin
(
Context
*
context
GLsizei
n
const
GLenum
loadops
[
]
const
void
*
cleardata
)
{
Extents
plsExtents
;
bool
hasPLSExtents
=
false
;
for
(
int
i
=
0
;
i
<
n
;
+
+
i
)
{
if
(
loadops
[
i
]
=
=
GL_DISABLE_ANGLE
)
{
continue
;
}
PixelLocalStoragePlane
&
plane
=
mPlanes
[
i
]
;
if
(
plane
.
isTextureIDDeleted
(
context
)
)
{
plane
.
setMemoryless
(
context
plane
.
getInternalformat
(
)
)
;
}
if
(
!
hasPLSExtents
&
&
plane
.
getTextureImageExtents
(
context
&
plsExtents
)
)
{
hasPLSExtents
=
true
;
}
}
if
(
!
hasPLSExtents
)
{
plsExtents
=
context
-
>
getState
(
)
.
getDrawFramebuffer
(
)
-
>
getState
(
)
.
getAttachmentExtentsIntersection
(
)
;
ASSERT
(
plsExtents
.
depth
=
=
0
)
;
}
onBegin
(
context
n
loadops
reinterpret_cast
<
const
char
*
>
(
cleardata
)
plsExtents
)
;
mNumActivePLSPlanes
=
n
;
}
void
PixelLocalStorage
:
:
end
(
Context
*
context
)
{
onEnd
(
context
mNumActivePLSPlanes
)
;
mNumActivePLSPlanes
=
0
;
}
void
PixelLocalStorage
:
:
barrier
(
Context
*
context
)
{
ASSERT
(
!
context
-
>
getExtensions
(
)
.
shaderPixelLocalStorageCoherentANGLE
)
;
onBarrier
(
context
)
;
}
namespace
{
class
PixelLocalStorageImageLoadStore
:
public
PixelLocalStorage
{
public
:
PixelLocalStorageImageLoadStore
(
bool
needsR32Packing
)
:
mNeedsR32Packing
(
needsR32Packing
)
{
}
~
PixelLocalStorageImageLoadStore
(
)
override
{
ASSERT
(
mScratchFramebufferForClearing
.
value
=
=
0
)
;
}
void
onContextObjectsLost
(
)
override
{
mScratchFramebufferForClearing
=
FramebufferID
(
)
;
}
void
onDeleteContextObjects
(
Context
*
context
)
override
{
if
(
mScratchFramebufferForClearing
.
value
!
=
0
)
{
context
-
>
deleteFramebuffer
(
mScratchFramebufferForClearing
)
;
mScratchFramebufferForClearing
=
FramebufferID
(
)
;
}
}
void
onBegin
(
Context
*
context
GLsizei
n
const
GLenum
loadops
[
]
const
char
*
cleardata
Extents
plsExtents
)
override
{
const
State
&
state
=
context
-
>
getState
(
)
;
ASSERT
(
static_cast
<
size_t
>
(
n
)
<
=
state
.
getImageUnits
(
)
.
size
(
)
)
;
mSavedImageBindings
.
clear
(
)
;
mSavedImageBindings
.
reserve
(
n
)
;
for
(
int
i
=
0
;
i
<
n
;
+
+
i
)
{
mSavedImageBindings
.
emplace_back
(
state
.
getImageUnit
(
i
)
)
;
}
Framebuffer
*
framebuffer
=
state
.
getDrawFramebuffer
(
)
;
mSavedFramebufferDefaultWidth
=
framebuffer
-
>
getDefaultWidth
(
)
;
mSavedFramebufferDefaultHeight
=
framebuffer
-
>
getDefaultHeight
(
)
;
context
-
>
framebufferParameteri
(
GL_DRAW_FRAMEBUFFER
GL_FRAMEBUFFER_DEFAULT_WIDTH
plsExtents
.
width
)
;
context
-
>
framebufferParameteri
(
GL_DRAW_FRAMEBUFFER
GL_FRAMEBUFFER_DEFAULT_HEIGHT
plsExtents
.
height
)
;
const
size_t
maxDrawBuffers
=
context
-
>
getCaps
(
)
.
maxDrawBuffers
;
ScopedRestoreDrawFramebuffer
ScopedRestoreDrawFramebuffer
(
context
)
;
if
(
mScratchFramebufferForClearing
.
value
=
=
0
)
{
context
-
>
genFramebuffers
(
1
&
mScratchFramebufferForClearing
)
;
context
-
>
bindFramebuffer
(
GL_DRAW_FRAMEBUFFER
mScratchFramebufferForClearing
)
;
DrawBuffersVector
<
GLenum
>
drawBuffers
(
maxDrawBuffers
)
;
std
:
:
iota
(
drawBuffers
.
begin
(
)
drawBuffers
.
end
(
)
GL_COLOR_ATTACHMENT0
)
;
context
-
>
drawBuffers
(
static_cast
<
int
>
(
drawBuffers
.
size
(
)
)
drawBuffers
.
data
(
)
)
;
}
else
{
context
-
>
bindFramebuffer
(
GL_DRAW_FRAMEBUFFER
mScratchFramebufferForClearing
)
;
}
ScopedDisableScissor
scopedDisableScissor
(
context
)
;
size_t
maxClearedAttachments
=
0
;
for
(
int
i
=
0
;
i
<
n
;
)
{
angle
:
:
FixedVector
<
int
IMPLEMENTATION_MAX_DRAW_BUFFERS
>
pendingClears
;
for
(
;
pendingClears
.
size
(
)
<
maxDrawBuffers
&
&
i
<
n
;
+
+
i
)
{
GLenum
loadop
=
loadops
[
i
]
;
if
(
loadop
=
=
GL_DISABLE_ANGLE
)
{
continue
;
}
PixelLocalStoragePlane
&
plane
=
getPlane
(
i
)
;
ASSERT
(
!
plane
.
isDeinitialized
(
)
)
;
plane
.
bindToImage
(
context
plsExtents
i
mNeedsR32Packing
)
;
if
(
loadop
=
=
GL_ZERO
|
|
loadop
=
=
GL_CLEAR_ANGLE
)
{
plane
.
attachToDrawFramebuffer
(
context
plsExtents
GL_COLOR_ATTACHMENT0
+
static_cast
<
GLenum
>
(
pendingClears
.
size
(
)
)
)
;
pendingClears
.
push_back
(
i
)
;
}
}
for
(
size_t
drawBufferIdx
=
0
;
drawBufferIdx
<
pendingClears
.
size
(
)
;
+
+
drawBufferIdx
)
{
int
plsIdx
=
pendingClears
[
drawBufferIdx
]
;
getPlane
(
plsIdx
)
.
performLoadOperationClear
(
context
static_cast
<
GLint
>
(
drawBufferIdx
)
loadops
[
plsIdx
]
cleardata
+
plsIdx
*
4
*
4
)
;
}
maxClearedAttachments
=
std
:
:
max
(
maxClearedAttachments
pendingClears
.
size
(
)
)
;
}
for
(
size_t
i
=
0
;
i
<
maxClearedAttachments
;
+
+
i
)
{
context
-
>
framebufferTexture2D
(
GL_DRAW_FRAMEBUFFER
GL_COLOR_ATTACHMENT0
+
static_cast
<
GLenum
>
(
i
)
TextureTarget
:
:
_2D
TextureID
(
)
0
)
;
}
context
-
>
memoryBarrier
(
GL_SHADER_IMAGE_ACCESS_BARRIER_BIT
)
;
}
void
onEnd
(
Context
*
context
GLsizei
numActivePLSPlanes
)
override
{
ASSERT
(
mSavedImageBindings
.
size
(
)
=
=
static_cast
<
size_t
>
(
numActivePLSPlanes
)
)
;
for
(
GLuint
unit
=
0
;
unit
<
mSavedImageBindings
.
size
(
)
;
+
+
unit
)
{
ImageUnit
&
binding
=
mSavedImageBindings
[
unit
]
;
context
-
>
bindImageTexture
(
unit
binding
.
texture
.
id
(
)
binding
.
level
binding
.
layered
binding
.
layer
binding
.
access
binding
.
format
)
;
binding
.
texture
.
set
(
context
nullptr
)
;
}
mSavedImageBindings
.
clear
(
)
;
context
-
>
framebufferParameteri
(
GL_DRAW_FRAMEBUFFER
GL_FRAMEBUFFER_DEFAULT_WIDTH
mSavedFramebufferDefaultWidth
)
;
context
-
>
framebufferParameteri
(
GL_DRAW_FRAMEBUFFER
GL_FRAMEBUFFER_DEFAULT_HEIGHT
mSavedFramebufferDefaultHeight
)
;
context
-
>
memoryBarrier
(
GL_ALL_BARRIER_BITS
)
;
}
void
onBarrier
(
Context
*
context
)
override
{
context
-
>
memoryBarrier
(
GL_SHADER_IMAGE_ACCESS_BARRIER_BIT
)
;
}
private
:
const
bool
mNeedsR32Packing
;
FramebufferID
mScratchFramebufferForClearing
{
}
;
GLint
mSavedFramebufferDefaultWidth
;
GLint
mSavedFramebufferDefaultHeight
;
std
:
:
vector
<
ImageUnit
>
mSavedImageBindings
;
}
;
class
PixelLocalStorageFramebufferFetch
:
public
PixelLocalStorage
{
public
:
void
onContextObjectsLost
(
)
override
{
}
void
onDeleteContextObjects
(
Context
*
)
override
{
}
void
onBegin
(
Context
*
context
GLsizei
n
const
GLenum
loadops
[
]
const
char
*
cleardata
Extents
plsExtents
)
override
{
const
State
&
state
=
context
-
>
getState
(
)
;
const
Caps
&
caps
=
context
-
>
getCaps
(
)
;
Framebuffer
*
framebuffer
=
context
-
>
getState
(
)
.
getDrawFramebuffer
(
)
;
const
DrawBuffersVector
<
GLenum
>
&
appDrawBuffers
=
framebuffer
-
>
getDrawBufferStates
(
)
;
mSavedDrawBuffers
.
resize
(
appDrawBuffers
.
size
(
)
)
;
std
:
:
copy
(
appDrawBuffers
.
begin
(
)
appDrawBuffers
.
end
(
)
mSavedDrawBuffers
.
begin
(
)
)
;
int
firstPLSDrawBuffer
=
caps
.
maxCombinedDrawBuffersAndPixelLocalStoragePlanes
-
n
;
int
numAppDrawBuffers
=
std
:
:
min
(
static_cast
<
int
>
(
appDrawBuffers
.
size
(
)
)
firstPLSDrawBuffer
)
;
DrawBuffersArray
<
GLenum
>
plsDrawBuffers
;
std
:
:
copy
(
appDrawBuffers
.
begin
(
)
appDrawBuffers
.
begin
(
)
+
numAppDrawBuffers
plsDrawBuffers
.
begin
(
)
)
;
std
:
:
fill
(
plsDrawBuffers
.
begin
(
)
+
numAppDrawBuffers
plsDrawBuffers
.
begin
(
)
+
firstPLSDrawBuffer
GL_NONE
)
;
mBlendsToReEnable
.
reset
(
)
;
mColorMasksToRestore
.
reset
(
)
;
mInvalidateList
.
clear
(
)
;
bool
needsClear
=
false
;
bool
hasIndexedBlendAndColorMask
=
context
-
>
getExtensions
(
)
.
drawBuffersIndexedAny
(
)
;
if
(
!
hasIndexedBlendAndColorMask
)
{
ASSERT
(
caps
.
maxColorAttachmentsWithActivePixelLocalStorage
=
=
0
)
;
if
(
state
.
isBlendEnabled
(
)
)
{
context
-
>
disable
(
GL_BLEND
)
;
mBlendsToReEnable
.
set
(
0
)
;
}
std
:
:
array
<
bool
4
>
&
mask
=
mSavedColorMasks
[
0
]
;
state
.
getBlendStateExt
(
)
.
getColorMaskIndexed
(
0
&
mask
[
0
]
&
mask
[
1
]
&
mask
[
2
]
&
mask
[
3
]
)
;
if
(
!
(
mask
[
0
]
&
&
mask
[
1
]
&
&
mask
[
2
]
&
&
mask
[
3
]
)
)
{
context
-
>
colorMask
(
GL_TRUE
GL_TRUE
GL_TRUE
GL_TRUE
)
;
mColorMasksToRestore
.
set
(
0
)
;
}
}
for
(
GLsizei
i
=
0
;
i
<
n
;
+
+
i
)
{
GLuint
drawBufferIdx
=
getDrawBufferIdx
(
caps
i
)
;
GLenum
loadop
=
loadops
[
i
]
;
if
(
loadop
=
=
GL_DISABLE_ANGLE
)
{
plsDrawBuffers
[
drawBufferIdx
]
=
GL_NONE
;
continue
;
}
PixelLocalStoragePlane
&
plane
=
getPlane
(
i
)
;
ASSERT
(
!
plane
.
isDeinitialized
(
)
)
;
GLenum
colorAttachment
=
GL_COLOR_ATTACHMENT0
+
drawBufferIdx
;
ASSERT
(
!
framebuffer
-
>
getAttachment
(
context
colorAttachment
)
)
;
plane
.
attachToDrawFramebuffer
(
context
plsExtents
colorAttachment
)
;
plsDrawBuffers
[
drawBufferIdx
]
=
colorAttachment
;
if
(
hasIndexedBlendAndColorMask
)
{
if
(
state
.
isBlendEnabledIndexed
(
drawBufferIdx
)
)
{
context
-
>
disablei
(
GL_BLEND
drawBufferIdx
)
;
mBlendsToReEnable
.
set
(
drawBufferIdx
)
;
}
std
:
:
array
<
bool
4
>
&
mask
=
mSavedColorMasks
[
drawBufferIdx
]
;
state
.
getBlendStateExt
(
)
.
getColorMaskIndexed
(
drawBufferIdx
&
mask
[
0
]
&
mask
[
1
]
&
mask
[
2
]
&
mask
[
3
]
)
;
if
(
!
(
mask
[
0
]
&
&
mask
[
1
]
&
&
mask
[
2
]
&
&
mask
[
3
]
)
)
{
context
-
>
colorMaski
(
drawBufferIdx
GL_TRUE
GL_TRUE
GL_TRUE
GL_TRUE
)
;
mColorMasksToRestore
.
set
(
drawBufferIdx
)
;
}
}
if
(
plane
.
isMemoryless
(
)
)
{
mInvalidateList
.
push_back
(
colorAttachment
)
;
}
needsClear
=
needsClear
|
|
(
loadop
!
=
GL_KEEP
)
;
}
context
-
>
drawBuffers
(
caps
.
maxCombinedDrawBuffersAndPixelLocalStoragePlanes
plsDrawBuffers
.
data
(
)
)
;
if
(
needsClear
)
{
ScopedDisableScissor
scopedDisableScissor
(
context
)
;
for
(
GLsizei
i
=
0
;
i
<
n
;
+
+
i
)
{
GLenum
loadop
=
loadops
[
i
]
;
if
(
loadop
!
=
GL_DISABLE_ANGLE
&
&
loadop
!
=
GL_KEEP
)
{
GLuint
drawBufferIdx
=
getDrawBufferIdx
(
caps
i
)
;
getPlane
(
i
)
.
performLoadOperationClear
(
context
drawBufferIdx
loadop
cleardata
+
i
*
4
*
4
)
;
}
}
}
if
(
!
context
-
>
getExtensions
(
)
.
shaderPixelLocalStorageCoherentANGLE
)
{
barrier
(
context
)
;
}
}
void
onEnd
(
Context
*
context
GLint
numActivePLSPlanes
)
override
{
const
Caps
&
caps
=
context
-
>
getCaps
(
)
;
if
(
!
mInvalidateList
.
empty
(
)
)
{
context
-
>
invalidateFramebuffer
(
GL_DRAW_FRAMEBUFFER
static_cast
<
GLsizei
>
(
mInvalidateList
.
size
(
)
)
mInvalidateList
.
data
(
)
)
;
mInvalidateList
.
clear
(
)
;
}
bool
hasIndexedBlendAndColorMask
=
context
-
>
getExtensions
(
)
.
drawBuffersIndexedAny
(
)
;
if
(
!
hasIndexedBlendAndColorMask
)
{
if
(
mBlendsToReEnable
[
0
]
)
{
context
-
>
enable
(
GL_BLEND
)
;
}
if
(
mColorMasksToRestore
[
0
]
)
{
const
std
:
:
array
<
bool
4
>
&
mask
=
mSavedColorMasks
[
0
]
;
context
-
>
colorMask
(
mask
[
0
]
mask
[
1
]
mask
[
2
]
mask
[
3
]
)
;
}
}
for
(
GLsizei
i
=
0
;
i
<
numActivePLSPlanes
;
+
+
i
)
{
GLuint
drawBufferIdx
=
getDrawBufferIdx
(
caps
i
)
;
GLenum
colorAttachment
=
GL_COLOR_ATTACHMENT0
+
drawBufferIdx
;
context
-
>
framebufferTexture2D
(
GL_DRAW_FRAMEBUFFER
colorAttachment
TextureTarget
:
:
_2D
TextureID
(
)
0
)
;
if
(
hasIndexedBlendAndColorMask
)
{
if
(
mBlendsToReEnable
[
drawBufferIdx
]
)
{
context
-
>
enablei
(
GL_BLEND
drawBufferIdx
)
;
}
if
(
mColorMasksToRestore
[
drawBufferIdx
]
)
{
const
std
:
:
array
<
bool
4
>
&
mask
=
mSavedColorMasks
[
drawBufferIdx
]
;
context
-
>
colorMaski
(
drawBufferIdx
mask
[
0
]
mask
[
1
]
mask
[
2
]
mask
[
3
]
)
;
}
}
}
context
-
>
drawBuffers
(
static_cast
<
GLsizei
>
(
mSavedDrawBuffers
.
size
(
)
)
mSavedDrawBuffers
.
data
(
)
)
;
mSavedDrawBuffers
.
clear
(
)
;
}
void
onBarrier
(
Context
*
context
)
override
{
context
-
>
framebufferFetchBarrier
(
)
;
}
private
:
GLuint
getDrawBufferIdx
(
const
Caps
&
caps
GLuint
plsPlaneIdx
)
{
return
caps
.
maxCombinedDrawBuffersAndPixelLocalStoragePlanes
-
plsPlaneIdx
-
1
;
}
DrawBuffersVector
<
GLenum
>
mSavedDrawBuffers
;
DrawBufferMask
mBlendsToReEnable
;
DrawBufferMask
mColorMasksToRestore
;
DrawBuffersArray
<
std
:
:
array
<
bool
4
>
>
mSavedColorMasks
;
DrawBuffersVector
<
GLenum
>
mInvalidateList
;
}
;
}
std
:
:
unique_ptr
<
PixelLocalStorage
>
PixelLocalStorage
:
:
Make
(
const
Context
*
context
)
{
switch
(
context
-
>
getImplementation
(
)
-
>
getNativePixelLocalStorageType
(
)
)
{
case
ShPixelLocalStorageType
:
:
ImageStoreR32PackedFormats
:
return
std
:
:
make_unique
<
PixelLocalStorageImageLoadStore
>
(
true
)
;
case
ShPixelLocalStorageType
:
:
ImageStoreNativeFormats
:
return
std
:
:
make_unique
<
PixelLocalStorageImageLoadStore
>
(
false
)
;
case
ShPixelLocalStorageType
:
:
FramebufferFetch
:
return
std
:
:
make_unique
<
PixelLocalStorageFramebufferFetch
>
(
)
;
default
:
UNREACHABLE
(
)
;
return
nullptr
;
}
}
}
