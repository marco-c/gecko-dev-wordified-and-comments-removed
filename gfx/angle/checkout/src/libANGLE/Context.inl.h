#
ifndef
LIBANGLE_CONTEXT_INL_H_
#
define
LIBANGLE_CONTEXT_INL_H_
#
include
"
libANGLE
/
Context
.
h
"
#
include
"
libANGLE
/
GLES1Renderer
.
h
"
#
include
"
libANGLE
/
renderer
/
ContextImpl
.
h
"
#
define
ANGLE_HANDLE_ERR
(
X
)
\
(
void
)
(
X
)
;
\
return
;
#
define
ANGLE_CONTEXT_TRY
(
EXPR
)
ANGLE_TRY_TEMPLATE
(
EXPR
ANGLE_HANDLE_ERR
)
namespace
gl
{
constexpr
angle
:
:
PackedEnumMap
<
PrimitiveMode
GLsizei
>
kMinimumPrimitiveCounts
=
{
{
{
PrimitiveMode
:
:
Points
1
}
{
PrimitiveMode
:
:
Lines
2
}
{
PrimitiveMode
:
:
LineLoop
2
}
{
PrimitiveMode
:
:
LineStrip
2
}
{
PrimitiveMode
:
:
Triangles
3
}
{
PrimitiveMode
:
:
TriangleStrip
3
}
{
PrimitiveMode
:
:
TriangleFan
3
}
{
PrimitiveMode
:
:
LinesAdjacency
2
}
{
PrimitiveMode
:
:
LineStripAdjacency
2
}
{
PrimitiveMode
:
:
TrianglesAdjacency
3
}
{
PrimitiveMode
:
:
TriangleStripAdjacency
3
}
}
}
;
ANGLE_INLINE
void
MarkTransformFeedbackBufferUsage
(
const
Context
*
context
GLsizei
count
GLsizei
instanceCount
)
{
if
(
context
-
>
getStateCache
(
)
.
isTransformFeedbackActiveUnpaused
(
)
)
{
TransformFeedback
*
transformFeedback
=
context
-
>
getState
(
)
.
getCurrentTransformFeedback
(
)
;
transformFeedback
-
>
onVerticesDrawn
(
context
count
instanceCount
)
;
}
}
ANGLE_INLINE
void
MarkShaderStorageUsage
(
const
Context
*
context
)
{
for
(
size_t
index
:
context
-
>
getStateCache
(
)
.
getActiveShaderStorageBufferIndices
(
)
)
{
Buffer
*
buffer
=
context
-
>
getState
(
)
.
getIndexedShaderStorageBuffer
(
index
)
.
get
(
)
;
if
(
buffer
)
{
buffer
-
>
onDataChanged
(
)
;
}
}
for
(
size_t
index
:
context
-
>
getStateCache
(
)
.
getActiveImageUnitIndices
(
)
)
{
const
ImageUnit
&
imageUnit
=
context
-
>
getState
(
)
.
getImageUnit
(
index
)
;
const
Texture
*
texture
=
imageUnit
.
texture
.
get
(
)
;
if
(
texture
)
{
texture
-
>
onStateChange
(
angle
:
:
SubjectMessage
:
:
ContentsChanged
)
;
}
}
}
ANGLE_INLINE
bool
Context
:
:
noopDraw
(
PrimitiveMode
mode
GLsizei
count
)
const
{
if
(
!
mStateCache
.
getCanDraw
(
)
)
{
return
true
;
}
return
count
<
kMinimumPrimitiveCounts
[
mode
]
;
}
ANGLE_INLINE
angle
:
:
Result
Context
:
:
syncDirtyBits
(
Command
command
)
{
const
State
:
:
DirtyBits
&
dirtyBits
=
mState
.
getDirtyBits
(
)
;
ANGLE_TRY
(
mImplementation
-
>
syncState
(
this
dirtyBits
mAllDirtyBits
command
)
)
;
mState
.
clearDirtyBits
(
)
;
return
angle
:
:
Result
:
:
Continue
;
}
ANGLE_INLINE
angle
:
:
Result
Context
:
:
syncDirtyBits
(
const
State
:
:
DirtyBits
&
bitMask
Command
command
)
{
const
State
:
:
DirtyBits
&
dirtyBits
=
(
mState
.
getDirtyBits
(
)
&
bitMask
)
;
ANGLE_TRY
(
mImplementation
-
>
syncState
(
this
dirtyBits
bitMask
command
)
)
;
mState
.
clearDirtyBits
(
dirtyBits
)
;
return
angle
:
:
Result
:
:
Continue
;
}
ANGLE_INLINE
angle
:
:
Result
Context
:
:
syncDirtyObjects
(
const
State
:
:
DirtyObjects
&
objectMask
Command
command
)
{
return
mState
.
syncDirtyObjects
(
this
objectMask
command
)
;
}
ANGLE_INLINE
angle
:
:
Result
Context
:
:
prepareForDraw
(
PrimitiveMode
mode
)
{
if
(
mGLES1Renderer
)
{
ANGLE_TRY
(
mGLES1Renderer
-
>
prepareForDraw
(
mode
this
&
mState
)
)
;
}
ANGLE_TRY
(
syncDirtyObjects
(
mDrawDirtyObjects
Command
:
:
Draw
)
)
;
ASSERT
(
!
isRobustResourceInitEnabled
(
)
|
|
!
mState
.
getDrawFramebuffer
(
)
-
>
hasResourceThatNeedsInit
(
)
)
;
return
syncDirtyBits
(
Command
:
:
Draw
)
;
}
ANGLE_INLINE
void
Context
:
:
drawArrays
(
PrimitiveMode
mode
GLint
first
GLsizei
count
)
{
if
(
noopDraw
(
mode
count
)
)
{
ANGLE_CONTEXT_TRY
(
mImplementation
-
>
handleNoopDrawEvent
(
)
)
;
return
;
}
ANGLE_CONTEXT_TRY
(
prepareForDraw
(
mode
)
)
;
ANGLE_CONTEXT_TRY
(
mImplementation
-
>
drawArrays
(
this
mode
first
count
)
)
;
MarkTransformFeedbackBufferUsage
(
this
count
1
)
;
}
ANGLE_INLINE
void
Context
:
:
drawElements
(
PrimitiveMode
mode
GLsizei
count
DrawElementsType
type
const
void
*
indices
)
{
if
(
noopDraw
(
mode
count
)
)
{
ANGLE_CONTEXT_TRY
(
mImplementation
-
>
handleNoopDrawEvent
(
)
)
;
return
;
}
ANGLE_CONTEXT_TRY
(
prepareForDraw
(
mode
)
)
;
ANGLE_CONTEXT_TRY
(
mImplementation
-
>
drawElements
(
this
mode
count
type
indices
)
)
;
}
ANGLE_INLINE
void
StateCache
:
:
onBufferBindingChange
(
Context
*
context
)
{
updateBasicDrawStatesError
(
)
;
updateBasicDrawElementsError
(
)
;
}
ANGLE_INLINE
void
Context
:
:
bindBuffer
(
BufferBinding
target
BufferID
buffer
)
{
Buffer
*
bufferObject
=
mState
.
mBufferManager
-
>
checkBufferAllocation
(
mImplementation
.
get
(
)
buffer
)
;
if
(
bufferObject
=
=
mState
.
getTargetBuffer
(
target
)
)
{
return
;
}
mState
.
setBufferBinding
(
this
target
bufferObject
)
;
mStateCache
.
onBufferBindingChange
(
this
)
;
}
}
#
endif
