#
ifndef
LIBANGLE_OVERLAYWIDGETS_H_
#
define
LIBANGLE_OVERLAYWIDGETS_H_
#
include
"
common
/
angleutils
.
h
"
#
include
"
libANGLE
/
Overlay_autogen
.
h
"
namespace
gl
{
class
Overlay
;
class
OverlayState
;
namespace
overlay_impl
{
class
AppendWidgetDataHelper
;
}
enum
class
WidgetType
{
Count
Text
PerSecond
RunningGraph
RunningHistogram
InvalidEnum
EnumCount
=
InvalidEnum
}
;
namespace
overlay
{
class
Text
;
class
Widget
{
public
:
virtual
~
Widget
(
)
{
}
virtual
const
Text
*
getDescriptionWidget
(
)
const
;
protected
:
WidgetType
type
;
bool
enabled
=
false
;
int
fontSize
;
int32_t
coords
[
4
]
;
float
color
[
4
]
;
Widget
*
matchToWidget
;
friend
class
gl
:
:
Overlay
;
friend
class
gl
:
:
OverlayState
;
friend
class
overlay_impl
:
:
AppendWidgetDataHelper
;
}
;
class
Count
:
public
Widget
{
public
:
~
Count
(
)
override
{
}
void
add
(
uint64_t
n
)
{
count
+
=
n
;
}
void
set
(
uint64_t
n
)
{
count
=
n
;
}
void
reset
(
)
{
count
=
0
;
}
protected
:
uint64_t
count
=
0
;
friend
class
gl
:
:
Overlay
;
friend
class
overlay_impl
:
:
AppendWidgetDataHelper
;
}
;
class
PerSecond
:
public
Count
{
public
:
~
PerSecond
(
)
override
{
}
protected
:
uint64_t
lastPerSecondCount
=
0
;
friend
class
gl
:
:
Overlay
;
friend
class
overlay_impl
:
:
AppendWidgetDataHelper
;
}
;
class
Text
:
public
Widget
{
public
:
~
Text
(
)
override
{
}
void
set
(
std
:
:
string
&
&
str
)
{
text
=
std
:
:
move
(
str
)
;
}
protected
:
std
:
:
string
text
;
friend
class
overlay_impl
:
:
AppendWidgetDataHelper
;
}
;
class
RunningGraph
:
public
Widget
{
public
:
RunningGraph
(
size_t
n
)
;
~
RunningGraph
(
)
override
;
void
add
(
uint64_t
n
)
{
if
(
!
ignoreFirstValue
)
{
runningValues
[
lastValueIndex
]
+
=
n
;
}
}
void
next
(
)
{
if
(
ignoreFirstValue
)
{
ignoreFirstValue
=
false
;
}
else
{
lastValueIndex
=
(
lastValueIndex
+
1
)
%
runningValues
.
size
(
)
;
runningValues
[
lastValueIndex
]
=
0
;
}
}
const
Text
*
getDescriptionWidget
(
)
const
override
;
protected
:
std
:
:
vector
<
uint64_t
>
runningValues
;
size_t
lastValueIndex
=
0
;
Text
description
;
bool
ignoreFirstValue
=
true
;
friend
class
gl
:
:
Overlay
;
friend
class
gl
:
:
OverlayState
;
friend
class
overlay_impl
:
:
AppendWidgetDataHelper
;
}
;
class
RunningHistogram
:
public
RunningGraph
{
public
:
RunningHistogram
(
size_t
n
)
:
RunningGraph
(
n
)
{
}
~
RunningHistogram
(
)
override
{
}
void
set
(
float
n
)
{
ASSERT
(
n
>
=
0
.
0f
&
&
n
<
=
1
.
0f
)
;
uint64_t
rank
=
n
=
=
1
.
0f
?
runningValues
.
size
(
)
-
1
:
static_cast
<
uint64_t
>
(
n
*
runningValues
.
size
(
)
)
;
runningValues
[
lastValueIndex
]
=
rank
;
}
private
:
using
RunningGraph
:
:
add
;
}
;
class
Mock
{
public
:
void
reset
(
)
const
{
}
template
<
typename
T
>
void
set
(
T
)
const
{
}
template
<
typename
T
>
void
add
(
T
)
const
{
}
void
next
(
)
const
{
}
}
;
}
}
#
endif
