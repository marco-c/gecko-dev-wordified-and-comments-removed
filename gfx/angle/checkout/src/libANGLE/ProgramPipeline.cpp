#
include
"
libANGLE
/
ProgramPipeline
.
h
"
#
include
<
algorithm
>
#
include
"
libANGLE
/
Context
.
h
"
#
include
"
libANGLE
/
Program
.
h
"
#
include
"
libANGLE
/
angletypes
.
h
"
#
include
"
libANGLE
/
renderer
/
GLImplFactory
.
h
"
#
include
"
libANGLE
/
renderer
/
ProgramPipelineImpl
.
h
"
namespace
gl
{
enum
SubjectIndexes
:
angle
:
:
SubjectIndex
{
kExecutableSubjectIndex
=
0
}
;
ProgramPipelineState
:
:
ProgramPipelineState
(
)
:
mLabel
(
)
mActiveShaderProgram
(
nullptr
)
mValid
(
false
)
mExecutable
(
new
ProgramExecutable
(
)
)
mIsLinked
(
false
)
{
for
(
const
ShaderType
shaderType
:
gl
:
:
AllShaderTypes
(
)
)
{
mPrograms
[
shaderType
]
=
nullptr
;
}
}
ProgramPipelineState
:
:
~
ProgramPipelineState
(
)
{
SafeDelete
(
mExecutable
)
;
}
const
std
:
:
string
&
ProgramPipelineState
:
:
getLabel
(
)
const
{
return
mLabel
;
}
void
ProgramPipelineState
:
:
activeShaderProgram
(
Program
*
shaderProgram
)
{
mActiveShaderProgram
=
shaderProgram
;
}
void
ProgramPipelineState
:
:
useProgramStage
(
const
Context
*
context
const
ShaderType
shaderType
Program
*
shaderProgram
angle
:
:
ObserverBinding
*
programObserverBindings
)
{
Program
*
oldProgram
=
mPrograms
[
shaderType
]
;
if
(
oldProgram
)
{
oldProgram
-
>
release
(
context
)
;
}
if
(
shaderProgram
&
&
(
shaderProgram
-
>
id
(
)
.
value
!
=
0
)
&
&
shaderProgram
-
>
getExecutable
(
)
.
hasLinkedShaderStage
(
shaderType
)
)
{
mPrograms
[
shaderType
]
=
shaderProgram
;
shaderProgram
-
>
addRef
(
)
;
}
else
{
mPrograms
[
shaderType
]
=
nullptr
;
}
Program
*
program
=
mPrograms
[
shaderType
]
;
programObserverBindings
-
>
bind
(
program
)
;
}
void
ProgramPipelineState
:
:
useProgramStages
(
const
Context
*
context
GLbitfield
stages
Program
*
shaderProgram
std
:
:
vector
<
angle
:
:
ObserverBinding
>
*
programObserverBindings
)
{
if
(
stages
=
=
GL_ALL_SHADER_BITS
)
{
for
(
const
ShaderType
shaderType
:
gl
:
:
AllShaderTypes
(
)
)
{
size_t
index
=
static_cast
<
size_t
>
(
shaderType
)
;
ASSERT
(
index
<
programObserverBindings
-
>
size
(
)
)
;
useProgramStage
(
context
shaderType
shaderProgram
&
programObserverBindings
-
>
at
(
index
)
)
;
}
}
else
{
if
(
stages
&
GL_VERTEX_SHADER_BIT
)
{
size_t
index
=
static_cast
<
size_t
>
(
ShaderType
:
:
Vertex
)
;
ASSERT
(
index
<
programObserverBindings
-
>
size
(
)
)
;
useProgramStage
(
context
ShaderType
:
:
Vertex
shaderProgram
&
programObserverBindings
-
>
at
(
index
)
)
;
}
if
(
stages
&
GL_FRAGMENT_SHADER_BIT
)
{
size_t
index
=
static_cast
<
size_t
>
(
ShaderType
:
:
Fragment
)
;
ASSERT
(
index
<
programObserverBindings
-
>
size
(
)
)
;
useProgramStage
(
context
ShaderType
:
:
Fragment
shaderProgram
&
programObserverBindings
-
>
at
(
index
)
)
;
}
if
(
stages
&
GL_COMPUTE_SHADER_BIT
)
{
size_t
index
=
static_cast
<
size_t
>
(
ShaderType
:
:
Compute
)
;
ASSERT
(
index
<
programObserverBindings
-
>
size
(
)
)
;
useProgramStage
(
context
ShaderType
:
:
Compute
shaderProgram
&
programObserverBindings
-
>
at
(
index
)
)
;
}
}
}
bool
ProgramPipelineState
:
:
usesShaderProgram
(
ShaderProgramID
programId
)
const
{
for
(
const
Program
*
program
:
mPrograms
)
{
if
(
program
&
&
(
program
-
>
id
(
)
=
=
programId
)
)
{
return
true
;
}
}
return
false
;
}
void
ProgramPipelineState
:
:
updateExecutableTextures
(
)
{
for
(
const
ShaderType
shaderType
:
mExecutable
-
>
getLinkedShaderStages
(
)
)
{
const
Program
*
program
=
getShaderProgram
(
shaderType
)
;
ASSERT
(
program
)
;
mExecutable
-
>
setActiveTextureMask
(
program
-
>
getExecutable
(
)
.
getActiveSamplersMask
(
)
)
;
mExecutable
-
>
setActiveImagesMask
(
program
-
>
getExecutable
(
)
.
getActiveImagesMask
(
)
)
;
mExecutable
-
>
updateActiveSamplers
(
program
-
>
getState
(
)
)
;
}
}
ProgramPipeline
:
:
ProgramPipeline
(
rx
:
:
GLImplFactory
*
factory
ProgramPipelineID
handle
)
:
RefCountObject
(
factory
-
>
generateSerial
(
)
handle
)
mProgramPipelineImpl
(
factory
-
>
createProgramPipeline
(
mState
)
)
mExecutableObserverBinding
(
this
kExecutableSubjectIndex
)
{
ASSERT
(
mProgramPipelineImpl
)
;
for
(
const
ShaderType
shaderType
:
gl
:
:
AllShaderTypes
(
)
)
{
mProgramObserverBindings
.
emplace_back
(
this
static_cast
<
angle
:
:
SubjectIndex
>
(
shaderType
)
)
;
}
mExecutableObserverBinding
.
bind
(
mState
.
mExecutable
)
;
}
ProgramPipeline
:
:
~
ProgramPipeline
(
)
{
mProgramPipelineImpl
.
release
(
)
;
}
void
ProgramPipeline
:
:
onDestroy
(
const
Context
*
context
)
{
for
(
Program
*
program
:
mState
.
mPrograms
)
{
if
(
program
)
{
ASSERT
(
program
-
>
getRefCount
(
)
)
;
program
-
>
release
(
context
)
;
}
}
getImplementation
(
)
-
>
destroy
(
context
)
;
}
void
ProgramPipeline
:
:
setLabel
(
const
Context
*
context
const
std
:
:
string
&
label
)
{
mState
.
mLabel
=
label
;
}
const
std
:
:
string
&
ProgramPipeline
:
:
getLabel
(
)
const
{
return
mState
.
mLabel
;
}
rx
:
:
ProgramPipelineImpl
*
ProgramPipeline
:
:
getImplementation
(
)
const
{
return
mProgramPipelineImpl
.
get
(
)
;
}
void
ProgramPipeline
:
:
activeShaderProgram
(
Program
*
shaderProgram
)
{
mState
.
activeShaderProgram
(
shaderProgram
)
;
}
void
ProgramPipeline
:
:
useProgramStages
(
const
Context
*
context
GLbitfield
stages
Program
*
shaderProgram
)
{
mState
.
useProgramStages
(
context
stages
shaderProgram
&
mProgramObserverBindings
)
;
updateLinkedShaderStages
(
)
;
updateExecutable
(
)
;
mState
.
mIsLinked
=
false
;
}
void
ProgramPipeline
:
:
updateLinkedShaderStages
(
)
{
mState
.
mExecutable
-
>
resetLinkedShaderStages
(
)
;
for
(
const
ShaderType
shaderType
:
gl
:
:
AllShaderTypes
(
)
)
{
Program
*
program
=
mState
.
mPrograms
[
shaderType
]
;
if
(
program
)
{
mState
.
mExecutable
-
>
setLinkedShaderStages
(
shaderType
)
;
}
}
mState
.
mExecutable
-
>
updateCanDrawWith
(
)
;
}
void
ProgramPipeline
:
:
updateExecutableAttributes
(
)
{
Program
*
vertexProgram
=
getShaderProgram
(
gl
:
:
ShaderType
:
:
Vertex
)
;
if
(
!
vertexProgram
)
{
return
;
}
const
ProgramExecutable
&
vertexExecutable
=
vertexProgram
-
>
getExecutable
(
)
;
mState
.
mExecutable
-
>
mActiveAttribLocationsMask
=
vertexExecutable
.
mActiveAttribLocationsMask
;
mState
.
mExecutable
-
>
mMaxActiveAttribLocation
=
vertexExecutable
.
mMaxActiveAttribLocation
;
mState
.
mExecutable
-
>
mAttributesTypeMask
=
vertexExecutable
.
mAttributesTypeMask
;
mState
.
mExecutable
-
>
mAttributesMask
=
vertexExecutable
.
mAttributesMask
;
}
void
ProgramPipeline
:
:
updateTransformFeedbackMembers
(
)
{
Program
*
vertexProgram
=
getShaderProgram
(
gl
:
:
ShaderType
:
:
Vertex
)
;
if
(
!
vertexProgram
)
{
return
;
}
const
ProgramExecutable
&
vertexExecutable
=
vertexProgram
-
>
getExecutable
(
)
;
mState
.
mExecutable
-
>
mTransformFeedbackStrides
=
vertexExecutable
.
mTransformFeedbackStrides
;
mState
.
mExecutable
-
>
mLinkedTransformFeedbackVaryings
=
vertexExecutable
.
mLinkedTransformFeedbackVaryings
;
}
void
ProgramPipeline
:
:
updateShaderStorageBlocks
(
)
{
mState
.
mExecutable
-
>
mComputeShaderStorageBlocks
.
clear
(
)
;
mState
.
mExecutable
-
>
mGraphicsShaderStorageBlocks
.
clear
(
)
;
ShaderBitSet
handledStages
;
for
(
const
gl
:
:
ShaderType
shaderType
:
kAllGraphicsShaderTypes
)
{
const
Program
*
shaderProgram
=
getShaderProgram
(
shaderType
)
;
if
(
shaderProgram
&
&
!
handledStages
.
test
(
shaderType
)
)
{
handledStages
|
=
shaderProgram
-
>
getExecutable
(
)
.
getLinkedShaderStages
(
)
;
for
(
const
InterfaceBlock
&
block
:
shaderProgram
-
>
getExecutable
(
)
.
getShaderStorageBlocks
(
)
)
{
mState
.
mExecutable
-
>
mGraphicsShaderStorageBlocks
.
emplace_back
(
block
)
;
}
}
}
const
Program
*
computeProgram
=
getShaderProgram
(
ShaderType
:
:
Compute
)
;
if
(
computeProgram
)
{
for
(
const
InterfaceBlock
&
block
:
computeProgram
-
>
getExecutable
(
)
.
getShaderStorageBlocks
(
)
)
{
mState
.
mExecutable
-
>
mComputeShaderStorageBlocks
.
emplace_back
(
block
)
;
}
}
}
void
ProgramPipeline
:
:
updateImageBindings
(
)
{
mState
.
mExecutable
-
>
mComputeImageBindings
.
clear
(
)
;
mState
.
mExecutable
-
>
mGraphicsImageBindings
.
clear
(
)
;
ShaderBitSet
handledStages
;
for
(
const
gl
:
:
ShaderType
shaderType
:
kAllGraphicsShaderTypes
)
{
const
Program
*
shaderProgram
=
getShaderProgram
(
shaderType
)
;
if
(
shaderProgram
&
&
!
handledStages
.
test
(
shaderType
)
)
{
handledStages
|
=
shaderProgram
-
>
getExecutable
(
)
.
getLinkedShaderStages
(
)
;
for
(
const
ImageBinding
&
imageBinding
:
shaderProgram
-
>
getState
(
)
.
getImageBindings
(
)
)
{
mState
.
mExecutable
-
>
mGraphicsImageBindings
.
emplace_back
(
imageBinding
)
;
}
}
}
const
Program
*
computeProgram
=
getShaderProgram
(
ShaderType
:
:
Compute
)
;
if
(
computeProgram
)
{
for
(
const
ImageBinding
&
imageBinding
:
computeProgram
-
>
getState
(
)
.
getImageBindings
(
)
)
{
mState
.
mExecutable
-
>
mComputeImageBindings
.
emplace_back
(
imageBinding
)
;
}
}
}
void
ProgramPipeline
:
:
updateHasBooleans
(
)
{
for
(
const
gl
:
:
ShaderType
shaderType
:
kAllGraphicsShaderTypes
)
{
const
Program
*
shaderProgram
=
getShaderProgram
(
shaderType
)
;
if
(
shaderProgram
)
{
const
ProgramExecutable
&
executable
=
shaderProgram
-
>
getExecutable
(
)
;
if
(
executable
.
hasUniformBuffers
(
)
)
{
mState
.
mExecutable
-
>
mPipelineHasGraphicsUniformBuffers
=
true
;
}
if
(
executable
.
hasGraphicsStorageBuffers
(
)
)
{
mState
.
mExecutable
-
>
mPipelineHasGraphicsStorageBuffers
=
true
;
}
if
(
executable
.
hasAtomicCounterBuffers
(
)
)
{
mState
.
mExecutable
-
>
mPipelineHasGraphicsAtomicCounterBuffers
=
true
;
}
if
(
executable
.
hasDefaultUniforms
(
)
)
{
mState
.
mExecutable
-
>
mPipelineHasGraphicsDefaultUniforms
=
true
;
}
if
(
executable
.
hasTextures
(
)
)
{
mState
.
mExecutable
-
>
mPipelineHasGraphicsTextures
=
true
;
}
if
(
executable
.
hasGraphicsImages
(
)
)
{
mState
.
mExecutable
-
>
mPipelineHasGraphicsImages
=
true
;
}
}
}
const
Program
*
computeProgram
=
getShaderProgram
(
ShaderType
:
:
Compute
)
;
if
(
computeProgram
)
{
const
ProgramExecutable
&
executable
=
computeProgram
-
>
getExecutable
(
)
;
if
(
executable
.
hasUniformBuffers
(
)
)
{
mState
.
mExecutable
-
>
mPipelineHasComputeUniformBuffers
=
true
;
}
if
(
executable
.
hasComputeStorageBuffers
(
)
)
{
mState
.
mExecutable
-
>
mPipelineHasComputeStorageBuffers
=
true
;
}
if
(
executable
.
hasAtomicCounterBuffers
(
)
)
{
mState
.
mExecutable
-
>
mPipelineHasComputeAtomicCounterBuffers
=
true
;
}
if
(
executable
.
hasDefaultUniforms
(
)
)
{
mState
.
mExecutable
-
>
mPipelineHasComputeDefaultUniforms
=
true
;
}
if
(
executable
.
hasTextures
(
)
)
{
mState
.
mExecutable
-
>
mPipelineHasComputeTextures
=
true
;
}
if
(
executable
.
hasComputeImages
(
)
)
{
mState
.
mExecutable
-
>
mPipelineHasComputeImages
=
true
;
}
}
}
void
ProgramPipeline
:
:
updateExecutable
(
)
{
mState
.
mExecutable
-
>
reset
(
)
;
updateExecutableAttributes
(
)
;
updateTransformFeedbackMembers
(
)
;
updateShaderStorageBlocks
(
)
;
updateImageBindings
(
)
;
mState
.
updateExecutableTextures
(
)
;
updateHasBooleans
(
)
;
}
ProgramMergedVaryings
ProgramPipeline
:
:
getMergedVaryings
(
)
const
{
ASSERT
(
!
mState
.
mExecutable
-
>
isCompute
(
)
)
;
ShaderMap
<
ShaderType
>
previousActiveStage
;
ShaderType
lastActiveStage
=
ShaderType
:
:
InvalidEnum
;
for
(
ShaderType
shaderType
:
getExecutable
(
)
.
getLinkedShaderStages
(
)
)
{
previousActiveStage
[
shaderType
]
=
lastActiveStage
;
const
Program
*
program
=
getShaderProgram
(
shaderType
)
;
ASSERT
(
program
)
;
lastActiveStage
=
shaderType
;
}
ShaderMap
<
std
:
:
map
<
std
:
:
string
size_t
>
>
outputVaryingNameToIndexShaderMap
;
ShaderMap
<
std
:
:
map
<
int
size_t
>
>
outputVaryingLocationToIndexShaderMap
;
ProgramMergedVaryings
merged
;
for
(
ShaderType
shaderType
:
getExecutable
(
)
.
getLinkedShaderStages
(
)
)
{
const
Program
*
program
=
getShaderProgram
(
shaderType
)
;
ASSERT
(
program
)
;
Shader
*
shader
=
program
-
>
getState
(
)
.
getAttachedShader
(
shaderType
)
;
ASSERT
(
shader
)
;
for
(
const
sh
:
:
ShaderVariable
&
varying
:
shader
-
>
getOutputVaryings
(
)
)
{
merged
.
push_back
(
{
}
)
;
ProgramVaryingRef
*
ref
=
&
merged
.
back
(
)
;
ref
-
>
frontShader
=
&
varying
;
ref
-
>
frontShaderStage
=
shaderType
;
outputVaryingNameToIndexShaderMap
[
shaderType
]
[
varying
.
name
]
=
merged
.
size
(
)
-
1
;
if
(
varying
.
location
!
=
-
1
)
{
outputVaryingLocationToIndexShaderMap
[
shaderType
]
[
varying
.
location
]
=
merged
.
size
(
)
-
1
;
}
}
}
for
(
ShaderType
shaderType
:
getExecutable
(
)
.
getLinkedShaderStages
(
)
)
{
const
Program
*
program
=
getShaderProgram
(
shaderType
)
;
ASSERT
(
program
)
;
Shader
*
shader
=
program
-
>
getState
(
)
.
getAttachedShader
(
shaderType
)
;
ASSERT
(
shader
)
;
ShaderType
previousStage
=
previousActiveStage
[
shaderType
]
;
for
(
const
sh
:
:
ShaderVariable
&
varying
:
shader
-
>
getInputVaryings
(
)
)
{
size_t
mergedIndex
=
merged
.
size
(
)
;
if
(
previousStage
!
=
ShaderType
:
:
InvalidEnum
)
{
if
(
varying
.
location
!
=
-
1
)
{
std
:
:
map
<
int
size_t
>
outputVaryingLocationToIndex
=
outputVaryingLocationToIndexShaderMap
[
previousStage
]
;
auto
byLocationIter
=
outputVaryingLocationToIndex
.
find
(
varying
.
location
)
;
if
(
byLocationIter
!
=
outputVaryingLocationToIndex
.
end
(
)
)
{
mergedIndex
=
byLocationIter
-
>
second
;
}
}
if
(
mergedIndex
=
=
merged
.
size
(
)
)
{
std
:
:
map
<
std
:
:
string
size_t
>
outputVaryingNameToIndex
=
outputVaryingNameToIndexShaderMap
[
previousStage
]
;
auto
byNameIter
=
outputVaryingNameToIndex
.
find
(
varying
.
name
)
;
if
(
byNameIter
!
=
outputVaryingNameToIndex
.
end
(
)
)
{
mergedIndex
=
byNameIter
-
>
second
;
}
}
}
if
(
mergedIndex
=
=
merged
.
size
(
)
)
{
merged
.
push_back
(
{
}
)
;
mergedIndex
=
merged
.
size
(
)
-
1
;
}
ProgramVaryingRef
*
ref
=
&
merged
[
mergedIndex
]
;
ref
-
>
backShader
=
&
varying
;
ref
-
>
backShaderStage
=
shaderType
;
}
}
return
merged
;
}
angle
:
:
Result
ProgramPipeline
:
:
link
(
const
Context
*
context
)
{
if
(
mState
.
mIsLinked
)
{
return
angle
:
:
Result
:
:
Continue
;
}
ProgramMergedVaryings
mergedVaryings
;
if
(
!
getExecutable
(
)
.
isCompute
(
)
)
{
InfoLog
&
infoLog
=
mState
.
mExecutable
-
>
getInfoLog
(
)
;
infoLog
.
reset
(
)
;
const
State
&
state
=
context
-
>
getState
(
)
;
gl
:
:
PackMode
packMode
=
PackMode
:
:
ANGLE_RELAXED
;
if
(
state
.
getLimitations
(
)
.
noFlexibleVaryingPacking
)
{
packMode
=
PackMode
:
:
ANGLE_NON_CONFORMANT_D3D9
;
}
else
if
(
state
.
getExtensions
(
)
.
webglCompatibility
)
{
packMode
=
PackMode
:
:
WEBGL_STRICT
;
}
if
(
!
linkVaryings
(
infoLog
)
)
{
return
angle
:
:
Result
:
:
Stop
;
}
gl
:
:
ShaderMap
<
const
gl
:
:
ProgramState
*
>
programStates
;
fillProgramStateMap
(
&
programStates
)
;
if
(
!
mState
.
mExecutable
-
>
linkValidateGlobalNames
(
infoLog
programStates
)
)
{
return
angle
:
:
Result
:
:
Stop
;
}
GLuint
maxVaryingVectors
=
static_cast
<
GLuint
>
(
context
-
>
getState
(
)
.
getCaps
(
)
.
maxVaryingVectors
)
;
VaryingPacking
varyingPacking
(
maxVaryingVectors
packMode
)
;
mergedVaryings
=
getMergedVaryings
(
)
;
for
(
ShaderType
shaderType
:
getExecutable
(
)
.
getLinkedShaderStages
(
)
)
{
Program
*
program
=
mState
.
mPrograms
[
shaderType
]
;
ASSERT
(
program
)
;
program
-
>
getExecutable
(
)
.
getResources
(
)
.
varyingPacking
.
reset
(
)
;
ANGLE_TRY
(
program
-
>
linkMergedVaryings
(
context
program
-
>
getExecutable
(
)
mergedVaryings
)
)
;
}
}
ANGLE_TRY
(
getImplementation
(
)
-
>
link
(
context
mergedVaryings
)
)
;
mState
.
mIsLinked
=
true
;
return
angle
:
:
Result
:
:
Continue
;
}
bool
ProgramPipeline
:
:
linkVaryings
(
InfoLog
&
infoLog
)
const
{
ShaderType
previousShaderType
=
ShaderType
:
:
InvalidEnum
;
for
(
ShaderType
shaderType
:
getExecutable
(
)
.
getLinkedShaderStages
(
)
)
{
Program
*
program
=
getShaderProgram
(
shaderType
)
;
ASSERT
(
program
)
;
ProgramExecutable
&
executable
=
program
-
>
getExecutable
(
)
;
if
(
previousShaderType
!
=
ShaderType
:
:
InvalidEnum
)
{
Program
*
previousProgram
=
getShaderProgram
(
previousShaderType
)
;
ASSERT
(
previousProgram
)
;
ProgramExecutable
&
previousExecutable
=
previousProgram
-
>
getExecutable
(
)
;
if
(
!
Program
:
:
linkValidateShaderInterfaceMatching
(
previousExecutable
.
getLinkedOutputVaryings
(
previousShaderType
)
executable
.
getLinkedInputVaryings
(
shaderType
)
previousShaderType
shaderType
previousExecutable
.
getLinkedShaderVersion
(
previousShaderType
)
executable
.
getLinkedShaderVersion
(
shaderType
)
true
infoLog
)
)
{
return
false
;
}
}
previousShaderType
=
shaderType
;
}
Program
*
vertexProgram
=
mState
.
mPrograms
[
ShaderType
:
:
Vertex
]
;
Program
*
fragmentProgram
=
mState
.
mPrograms
[
ShaderType
:
:
Fragment
]
;
if
(
!
vertexProgram
|
|
!
fragmentProgram
)
{
return
false
;
}
ProgramExecutable
&
vertexExecutable
=
vertexProgram
-
>
getExecutable
(
)
;
ProgramExecutable
&
fragmentExecutable
=
fragmentProgram
-
>
getExecutable
(
)
;
return
Program
:
:
linkValidateBuiltInVaryings
(
vertexExecutable
.
getLinkedOutputVaryings
(
ShaderType
:
:
Vertex
)
fragmentExecutable
.
getLinkedInputVaryings
(
ShaderType
:
:
Fragment
)
vertexExecutable
.
getLinkedShaderVersion
(
ShaderType
:
:
Vertex
)
infoLog
)
;
}
void
ProgramPipeline
:
:
validate
(
const
gl
:
:
Context
*
context
)
{
const
Caps
&
caps
=
context
-
>
getCaps
(
)
;
mState
.
mValid
=
true
;
InfoLog
&
infoLog
=
mState
.
mExecutable
-
>
getInfoLog
(
)
;
infoLog
.
reset
(
)
;
for
(
const
ShaderType
shaderType
:
mState
.
mExecutable
-
>
getLinkedShaderStages
(
)
)
{
Program
*
shaderProgram
=
mState
.
mPrograms
[
shaderType
]
;
if
(
shaderProgram
)
{
shaderProgram
-
>
resolveLink
(
context
)
;
shaderProgram
-
>
validate
(
caps
)
;
std
:
:
string
shaderInfoString
=
shaderProgram
-
>
getExecutable
(
)
.
getInfoLogString
(
)
;
if
(
shaderInfoString
.
length
(
)
)
{
mState
.
mValid
=
false
;
infoLog
<
<
shaderInfoString
<
<
"
\
n
"
;
return
;
}
if
(
!
shaderProgram
-
>
isSeparable
(
)
)
{
mState
.
mValid
=
false
;
infoLog
<
<
GetShaderTypeString
(
shaderType
)
<
<
"
is
not
marked
separable
.
"
<
<
"
\
n
"
;
return
;
}
}
}
if
(
!
linkVaryings
(
infoLog
)
)
{
mState
.
mValid
=
false
;
for
(
const
ShaderType
shaderType
:
mState
.
mExecutable
-
>
getLinkedShaderStages
(
)
)
{
Program
*
shaderProgram
=
mState
.
mPrograms
[
shaderType
]
;
ASSERT
(
shaderProgram
)
;
shaderProgram
-
>
validate
(
caps
)
;
std
:
:
string
shaderInfoString
=
shaderProgram
-
>
getExecutable
(
)
.
getInfoLogString
(
)
;
if
(
shaderInfoString
.
length
(
)
)
{
infoLog
<
<
shaderInfoString
<
<
"
\
n
"
;
}
}
}
}
bool
ProgramPipeline
:
:
validateSamplers
(
InfoLog
*
infoLog
const
Caps
&
caps
)
{
for
(
const
ShaderType
shaderType
:
gl
:
:
AllShaderTypes
(
)
)
{
Program
*
shaderProgram
=
mState
.
mPrograms
[
shaderType
]
;
if
(
shaderProgram
&
&
!
shaderProgram
-
>
validateSamplers
(
infoLog
caps
)
)
{
return
false
;
}
}
return
true
;
}
void
ProgramPipeline
:
:
onSubjectStateChange
(
angle
:
:
SubjectIndex
index
angle
:
:
SubjectMessage
message
)
{
switch
(
message
)
{
case
angle
:
:
SubjectMessage
:
:
SubjectChanged
:
mState
.
mIsLinked
=
false
;
mState
.
updateExecutableTextures
(
)
;
break
;
default
:
UNREACHABLE
(
)
;
break
;
}
}
void
ProgramPipeline
:
:
fillProgramStateMap
(
ShaderMap
<
const
ProgramState
*
>
*
programStatesOut
)
{
for
(
ShaderType
shaderType
:
AllShaderTypes
(
)
)
{
(
*
programStatesOut
)
[
shaderType
]
=
nullptr
;
Program
*
program
=
getShaderProgram
(
shaderType
)
;
if
(
program
)
{
(
*
programStatesOut
)
[
shaderType
]
=
&
program
-
>
getState
(
)
;
}
}
}
}
