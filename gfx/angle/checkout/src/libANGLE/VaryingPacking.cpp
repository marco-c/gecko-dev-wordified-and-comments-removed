#
include
"
libANGLE
/
VaryingPacking
.
h
"
#
include
"
common
/
utilities
.
h
"
#
include
"
libANGLE
/
Program
.
h
"
#
include
"
libANGLE
/
Shader
.
h
"
namespace
gl
{
namespace
{
bool
ComparePackedVarying
(
const
PackedVarying
&
x
const
PackedVarying
&
y
)
{
sh
:
:
ShaderVariable
vx
vy
;
const
sh
:
:
ShaderVariable
*
px
*
py
;
px
=
&
x
.
varying
(
)
;
py
=
&
y
.
varying
(
)
;
if
(
x
.
isArrayElement
(
)
)
{
vx
=
*
px
;
vx
.
arraySizes
.
clear
(
)
;
px
=
&
vx
;
}
if
(
y
.
isArrayElement
(
)
)
{
vy
=
*
py
;
vy
.
arraySizes
.
clear
(
)
;
py
=
&
vy
;
}
return
gl
:
:
CompareShaderVar
(
*
px
*
py
)
;
}
}
VaryingInShaderRef
:
:
VaryingInShaderRef
(
ShaderType
stageIn
const
sh
:
:
ShaderVariable
*
varyingIn
)
:
varying
(
varyingIn
)
stage
(
stageIn
)
{
}
VaryingInShaderRef
:
:
~
VaryingInShaderRef
(
)
=
default
;
VaryingInShaderRef
:
:
VaryingInShaderRef
(
VaryingInShaderRef
&
&
other
)
{
*
this
=
std
:
:
move
(
other
)
;
}
VaryingInShaderRef
&
VaryingInShaderRef
:
:
operator
=
(
VaryingInShaderRef
&
&
other
)
{
std
:
:
swap
(
varying
other
.
varying
)
;
std
:
:
swap
(
stage
other
.
stage
)
;
std
:
:
swap
(
parentStructName
other
.
parentStructName
)
;
std
:
:
swap
(
parentStructMappedName
other
.
parentStructMappedName
)
;
return
*
this
;
}
PackedVarying
:
:
PackedVarying
(
VaryingInShaderRef
&
&
frontVaryingIn
VaryingInShaderRef
&
&
backVaryingIn
sh
:
:
InterpolationType
interpolationIn
)
:
PackedVarying
(
std
:
:
move
(
frontVaryingIn
)
std
:
:
move
(
backVaryingIn
)
interpolationIn
0
)
{
}
PackedVarying
:
:
PackedVarying
(
VaryingInShaderRef
&
&
frontVaryingIn
VaryingInShaderRef
&
&
backVaryingIn
sh
:
:
InterpolationType
interpolationIn
GLuint
fieldIndexIn
)
:
frontVarying
(
std
:
:
move
(
frontVaryingIn
)
)
backVarying
(
std
:
:
move
(
backVaryingIn
)
)
interpolation
(
interpolationIn
)
arrayIndex
(
GL_INVALID_INDEX
)
fieldIndex
(
fieldIndexIn
)
{
}
PackedVarying
:
:
~
PackedVarying
(
)
=
default
;
PackedVarying
:
:
PackedVarying
(
PackedVarying
&
&
other
)
:
frontVarying
(
other
.
frontVarying
.
stage
other
.
frontVarying
.
varying
)
backVarying
(
other
.
backVarying
.
stage
other
.
backVarying
.
varying
)
{
*
this
=
std
:
:
move
(
other
)
;
}
PackedVarying
&
PackedVarying
:
:
operator
=
(
PackedVarying
&
&
other
)
{
std
:
:
swap
(
frontVarying
other
.
frontVarying
)
;
std
:
:
swap
(
backVarying
other
.
backVarying
)
;
std
:
:
swap
(
interpolation
other
.
interpolation
)
;
std
:
:
swap
(
arrayIndex
other
.
arrayIndex
)
;
std
:
:
swap
(
fieldIndex
other
.
fieldIndex
)
;
return
*
this
;
}
VaryingPacking
:
:
VaryingPacking
(
GLuint
maxVaryingVectors
PackMode
packMode
)
:
mRegisterMap
(
maxVaryingVectors
)
mPackMode
(
packMode
)
{
}
VaryingPacking
:
:
~
VaryingPacking
(
)
=
default
;
void
VaryingPacking
:
:
reset
(
)
{
clearRegisterMap
(
)
;
mRegisterList
.
clear
(
)
;
mPackedVaryings
.
clear
(
)
;
for
(
std
:
:
vector
<
std
:
:
string
>
inactiveVaryingMappedNames
:
mInactiveVaryingMappedNames
)
{
inactiveVaryingMappedNames
.
clear
(
)
;
}
}
void
VaryingPacking
:
:
clearRegisterMap
(
)
{
std
:
:
fill
(
mRegisterMap
.
begin
(
)
mRegisterMap
.
end
(
)
Register
(
)
)
;
}
bool
VaryingPacking
:
:
packVarying
(
const
PackedVarying
&
packedVarying
)
{
const
sh
:
:
ShaderVariable
&
varying
=
packedVarying
.
varying
(
)
;
ASSERT
(
!
varying
.
isStruct
(
)
)
;
GLenum
transposedType
=
gl
:
:
TransposeMatrixType
(
varying
.
type
)
;
unsigned
int
varyingRows
=
gl
:
:
VariableRowCount
(
transposedType
)
;
unsigned
int
varyingColumns
=
gl
:
:
VariableColumnCount
(
transposedType
)
;
if
(
mPackMode
=
=
PackMode
:
:
ANGLE_NON_CONFORMANT_D3D9
)
{
varyingColumns
=
4
;
}
else
if
(
mPackMode
=
=
PackMode
:
:
WEBGL_STRICT
&
&
varying
.
type
=
=
GL_FLOAT_MAT2
)
{
varyingColumns
=
4
;
}
const
unsigned
int
elementCount
=
varying
.
getBasicTypeElementCount
(
)
;
varyingRows
*
=
(
packedVarying
.
isArrayElement
(
)
?
1
:
elementCount
)
;
unsigned
int
maxVaryingVectors
=
static_cast
<
unsigned
int
>
(
mRegisterMap
.
size
(
)
)
;
if
(
varyingRows
>
maxVaryingVectors
)
{
return
false
;
}
if
(
varyingColumns
>
=
2
&
&
varyingColumns
<
=
4
)
{
for
(
unsigned
int
row
=
0
;
row
<
=
maxVaryingVectors
-
varyingRows
;
+
+
row
)
{
if
(
isFree
(
row
0
varyingRows
varyingColumns
)
)
{
insert
(
row
0
packedVarying
)
;
return
true
;
}
}
if
(
varyingColumns
=
=
2
)
{
for
(
unsigned
int
r
=
maxVaryingVectors
-
varyingRows
+
1
;
r
-
-
>
=
1
;
)
{
if
(
isFree
(
r
2
varyingRows
2
)
)
{
insert
(
r
2
packedVarying
)
;
return
true
;
}
}
}
return
false
;
}
ASSERT
(
varyingColumns
=
=
1
)
;
unsigned
int
contiguousSpace
[
4
]
=
{
0
}
;
unsigned
int
bestContiguousSpace
[
4
]
=
{
0
}
;
unsigned
int
totalSpace
[
4
]
=
{
0
}
;
for
(
unsigned
int
row
=
0
;
row
<
maxVaryingVectors
;
+
+
row
)
{
for
(
unsigned
int
column
=
0
;
column
<
4
;
+
+
column
)
{
if
(
mRegisterMap
[
row
]
[
column
]
)
{
contiguousSpace
[
column
]
=
0
;
}
else
{
contiguousSpace
[
column
]
+
+
;
totalSpace
[
column
]
+
+
;
if
(
contiguousSpace
[
column
]
>
bestContiguousSpace
[
column
]
)
{
bestContiguousSpace
[
column
]
=
contiguousSpace
[
column
]
;
}
}
}
}
unsigned
int
bestColumn
=
0
;
for
(
unsigned
int
column
=
1
;
column
<
4
;
+
+
column
)
{
if
(
bestContiguousSpace
[
column
]
>
=
varyingRows
&
&
(
bestContiguousSpace
[
bestColumn
]
<
varyingRows
|
|
totalSpace
[
column
]
<
totalSpace
[
bestColumn
]
)
)
{
bestColumn
=
column
;
}
}
if
(
bestContiguousSpace
[
bestColumn
]
>
=
varyingRows
)
{
for
(
unsigned
int
row
=
0
;
row
<
maxVaryingVectors
;
row
+
+
)
{
if
(
isFree
(
row
bestColumn
varyingRows
1
)
)
{
for
(
unsigned
int
arrayIndex
=
0
;
arrayIndex
<
varyingRows
;
+
+
arrayIndex
)
{
PackedVaryingRegister
registerInfo
;
registerInfo
.
packedVarying
=
&
packedVarying
;
registerInfo
.
registerRow
=
row
+
arrayIndex
;
registerInfo
.
registerColumn
=
bestColumn
;
registerInfo
.
varyingArrayIndex
=
(
packedVarying
.
isArrayElement
(
)
?
packedVarying
.
arrayIndex
:
arrayIndex
)
;
registerInfo
.
varyingRowIndex
=
0
;
if
(
!
varying
.
isBuiltIn
(
)
)
{
mRegisterList
.
push_back
(
registerInfo
)
;
}
mRegisterMap
[
row
+
arrayIndex
]
[
bestColumn
]
=
true
;
}
break
;
}
}
return
true
;
}
return
false
;
}
bool
VaryingPacking
:
:
isFree
(
unsigned
int
registerRow
unsigned
int
registerColumn
unsigned
int
varyingRows
unsigned
int
varyingColumns
)
const
{
for
(
unsigned
int
row
=
0
;
row
<
varyingRows
;
+
+
row
)
{
ASSERT
(
registerRow
+
row
<
mRegisterMap
.
size
(
)
)
;
for
(
unsigned
int
column
=
0
;
column
<
varyingColumns
;
+
+
column
)
{
ASSERT
(
registerColumn
+
column
<
4
)
;
if
(
mRegisterMap
[
registerRow
+
row
]
[
registerColumn
+
column
]
)
{
return
false
;
}
}
}
return
true
;
}
void
VaryingPacking
:
:
insert
(
unsigned
int
registerRow
unsigned
int
registerColumn
const
PackedVarying
&
packedVarying
)
{
unsigned
int
varyingRows
=
0
;
unsigned
int
varyingColumns
=
0
;
const
sh
:
:
ShaderVariable
&
varying
=
packedVarying
.
varying
(
)
;
ASSERT
(
!
varying
.
isStruct
(
)
)
;
GLenum
transposedType
=
gl
:
:
TransposeMatrixType
(
varying
.
type
)
;
varyingRows
=
gl
:
:
VariableRowCount
(
transposedType
)
;
varyingColumns
=
gl
:
:
VariableColumnCount
(
transposedType
)
;
PackedVaryingRegister
registerInfo
;
registerInfo
.
packedVarying
=
&
packedVarying
;
registerInfo
.
registerColumn
=
registerColumn
;
const
unsigned
int
arrayElementCount
=
varying
.
getBasicTypeElementCount
(
)
;
for
(
unsigned
int
arrayElement
=
0
;
arrayElement
<
arrayElementCount
;
+
+
arrayElement
)
{
if
(
packedVarying
.
isArrayElement
(
)
&
&
arrayElement
!
=
packedVarying
.
arrayIndex
)
{
continue
;
}
for
(
unsigned
int
varyingRow
=
0
;
varyingRow
<
varyingRows
;
+
+
varyingRow
)
{
registerInfo
.
registerRow
=
registerRow
+
(
arrayElement
*
varyingRows
)
+
varyingRow
;
registerInfo
.
varyingRowIndex
=
varyingRow
;
registerInfo
.
varyingArrayIndex
=
arrayElement
;
if
(
!
varying
.
isBuiltIn
(
)
)
{
mRegisterList
.
push_back
(
registerInfo
)
;
}
for
(
unsigned
int
columnIndex
=
0
;
columnIndex
<
varyingColumns
;
+
+
columnIndex
)
{
mRegisterMap
[
registerInfo
.
registerRow
]
[
registerColumn
+
columnIndex
]
=
true
;
}
}
}
}
void
VaryingPacking
:
:
packUserVarying
(
const
ProgramVaryingRef
&
ref
VaryingUniqueFullNames
*
uniqueFullNames
)
{
const
sh
:
:
ShaderVariable
*
input
=
ref
.
frontShader
;
const
sh
:
:
ShaderVariable
*
output
=
ref
.
backShader
;
sh
:
:
InterpolationType
interpolation
=
input
?
input
-
>
interpolation
:
output
-
>
interpolation
;
VaryingInShaderRef
frontVarying
(
ref
.
frontShaderStage
input
)
;
VaryingInShaderRef
backVarying
(
ref
.
backShaderStage
output
)
;
mPackedVaryings
.
emplace_back
(
std
:
:
move
(
frontVarying
)
std
:
:
move
(
backVarying
)
interpolation
)
;
if
(
input
)
{
(
*
uniqueFullNames
)
[
ref
.
frontShaderStage
]
.
insert
(
mPackedVaryings
.
back
(
)
.
fullName
(
ref
.
frontShaderStage
)
)
;
}
if
(
output
)
{
(
*
uniqueFullNames
)
[
ref
.
backShaderStage
]
.
insert
(
mPackedVaryings
.
back
(
)
.
fullName
(
ref
.
backShaderStage
)
)
;
}
}
void
VaryingPacking
:
:
packUserVaryingField
(
const
ProgramVaryingRef
&
ref
GLuint
fieldIndex
VaryingUniqueFullNames
*
uniqueFullNames
)
{
const
sh
:
:
ShaderVariable
*
input
=
ref
.
frontShader
;
const
sh
:
:
ShaderVariable
*
output
=
ref
.
backShader
;
sh
:
:
InterpolationType
interpolation
=
input
?
input
-
>
interpolation
:
output
-
>
interpolation
;
const
sh
:
:
ShaderVariable
*
frontField
=
input
?
&
input
-
>
fields
[
fieldIndex
]
:
nullptr
;
const
sh
:
:
ShaderVariable
*
backField
=
output
?
&
output
-
>
fields
[
fieldIndex
]
:
nullptr
;
VaryingInShaderRef
frontVarying
(
ref
.
frontShaderStage
frontField
)
;
VaryingInShaderRef
backVarying
(
ref
.
backShaderStage
backField
)
;
if
(
input
)
{
ASSERT
(
!
frontField
-
>
isStruct
(
)
&
&
!
frontField
-
>
isArray
(
)
)
;
frontVarying
.
parentStructName
=
input
-
>
name
;
frontVarying
.
parentStructMappedName
=
input
-
>
mappedName
;
}
if
(
output
)
{
ASSERT
(
!
backField
-
>
isStruct
(
)
&
&
!
backField
-
>
isArray
(
)
)
;
backVarying
.
parentStructName
=
output
-
>
name
;
backVarying
.
parentStructMappedName
=
output
-
>
mappedName
;
}
mPackedVaryings
.
emplace_back
(
std
:
:
move
(
frontVarying
)
std
:
:
move
(
backVarying
)
interpolation
fieldIndex
)
;
if
(
input
)
{
(
*
uniqueFullNames
)
[
ref
.
frontShaderStage
]
.
insert
(
mPackedVaryings
.
back
(
)
.
fullName
(
ref
.
frontShaderStage
)
)
;
}
if
(
output
)
{
(
*
uniqueFullNames
)
[
ref
.
backShaderStage
]
.
insert
(
mPackedVaryings
.
back
(
)
.
fullName
(
ref
.
backShaderStage
)
)
;
}
}
void
VaryingPacking
:
:
packUserVaryingTF
(
const
ProgramVaryingRef
&
ref
size_t
subscript
)
{
const
sh
:
:
ShaderVariable
*
input
=
ref
.
frontShader
;
VaryingInShaderRef
frontVarying
(
ref
.
frontShaderStage
input
)
;
VaryingInShaderRef
backVarying
(
ref
.
backShaderStage
nullptr
)
;
mPackedVaryings
.
emplace_back
(
std
:
:
move
(
frontVarying
)
std
:
:
move
(
backVarying
)
input
-
>
interpolation
)
;
mPackedVaryings
.
back
(
)
.
arrayIndex
=
static_cast
<
GLuint
>
(
subscript
)
;
}
void
VaryingPacking
:
:
packUserVaryingFieldTF
(
const
ProgramVaryingRef
&
ref
const
sh
:
:
ShaderVariable
&
field
GLuint
fieldIndex
)
{
const
sh
:
:
ShaderVariable
*
input
=
ref
.
frontShader
;
VaryingInShaderRef
frontVarying
(
ref
.
frontShaderStage
&
field
)
;
VaryingInShaderRef
backVarying
(
ref
.
backShaderStage
nullptr
)
;
frontVarying
.
parentStructName
=
input
-
>
name
;
frontVarying
.
parentStructMappedName
=
input
-
>
mappedName
;
mPackedVaryings
.
emplace_back
(
std
:
:
move
(
frontVarying
)
std
:
:
move
(
backVarying
)
input
-
>
interpolation
fieldIndex
)
;
}
bool
VaryingPacking
:
:
collectAndPackUserVaryings
(
gl
:
:
InfoLog
&
infoLog
const
ProgramMergedVaryings
&
mergedVaryings
const
std
:
:
vector
<
std
:
:
string
>
&
tfVaryings
const
bool
isSeparableProgram
)
{
VaryingUniqueFullNames
uniqueFullNames
;
mPackedVaryings
.
clear
(
)
;
clearRegisterMap
(
)
;
for
(
const
ProgramVaryingRef
&
ref
:
mergedVaryings
)
{
const
sh
:
:
ShaderVariable
*
input
=
ref
.
frontShader
;
const
sh
:
:
ShaderVariable
*
output
=
ref
.
backShader
;
if
(
(
input
&
&
output
&
&
output
-
>
staticUse
)
|
|
(
input
&
&
input
-
>
isBuiltIn
(
)
&
&
input
-
>
active
)
|
|
(
output
&
&
output
-
>
isBuiltIn
(
)
&
&
output
-
>
active
)
|
|
(
isSeparableProgram
&
&
(
(
input
&
&
input
-
>
active
)
|
|
(
output
&
&
output
-
>
active
)
)
)
)
{
const
sh
:
:
ShaderVariable
*
varying
=
output
?
output
:
input
;
if
(
varying
-
>
name
!
=
"
gl_Position
"
&
&
!
(
varying
-
>
name
=
=
"
gl_PointSize
"
&
&
mPackMode
=
=
PackMode
:
:
ANGLE_NON_CONFORMANT_D3D9
)
)
{
if
(
varying
-
>
isStruct
(
)
)
{
ASSERT
(
!
(
varying
-
>
isArray
(
)
&
&
varying
=
=
input
)
)
;
for
(
GLuint
fieldIndex
=
0
;
fieldIndex
<
varying
-
>
fields
.
size
(
)
;
+
+
fieldIndex
)
{
packUserVaryingField
(
ref
fieldIndex
&
uniqueFullNames
)
;
}
if
(
input
)
{
uniqueFullNames
[
ref
.
frontShaderStage
]
.
insert
(
input
-
>
name
)
;
}
if
(
output
)
{
uniqueFullNames
[
ref
.
backShaderStage
]
.
insert
(
output
-
>
name
)
;
}
}
else
{
packUserVarying
(
ref
&
uniqueFullNames
)
;
}
continue
;
}
}
if
(
!
input
&
&
!
isSeparableProgram
)
{
mInactiveVaryingMappedNames
[
ref
.
backShaderStage
]
.
push_back
(
output
-
>
mappedName
)
;
continue
;
}
for
(
const
std
:
:
string
&
tfVarying
:
tfVaryings
)
{
std
:
:
vector
<
unsigned
int
>
subscripts
;
std
:
:
string
baseName
=
ParseResourceName
(
tfVarying
&
subscripts
)
;
size_t
subscript
=
GL_INVALID_INDEX
;
if
(
!
subscripts
.
empty
(
)
)
{
subscript
=
subscripts
.
back
(
)
;
}
if
(
uniqueFullNames
[
ref
.
frontShaderStage
]
.
count
(
tfVarying
)
>
0
|
|
uniqueFullNames
[
ref
.
frontShaderStage
]
.
count
(
baseName
)
>
0
)
{
continue
;
}
if
(
input
-
>
isStruct
(
)
)
{
GLuint
fieldIndex
=
0
;
const
sh
:
:
ShaderVariable
*
field
=
input
-
>
findField
(
tfVarying
&
fieldIndex
)
;
if
(
field
!
=
nullptr
)
{
ASSERT
(
!
field
-
>
isStruct
(
)
&
&
!
field
-
>
isArray
(
)
)
;
packUserVaryingFieldTF
(
ref
*
field
fieldIndex
)
;
uniqueFullNames
[
ref
.
frontShaderStage
]
.
insert
(
tfVarying
)
;
}
uniqueFullNames
[
ref
.
frontShaderStage
]
.
insert
(
input
-
>
name
)
;
}
else
if
(
baseName
=
=
input
-
>
name
)
{
if
(
tfVarying
.
compare
(
0
3
"
gl_
"
)
!
=
0
)
{
packUserVaryingTF
(
ref
subscript
)
;
uniqueFullNames
[
ref
.
frontShaderStage
]
.
insert
(
tfVarying
)
;
}
if
(
subscript
=
=
GL_INVALID_INDEX
)
{
break
;
}
}
}
if
(
input
&
&
uniqueFullNames
[
ref
.
frontShaderStage
]
.
count
(
input
-
>
name
)
=
=
0
)
{
mInactiveVaryingMappedNames
[
ref
.
frontShaderStage
]
.
push_back
(
input
-
>
mappedName
)
;
}
if
(
output
&
&
uniqueFullNames
[
ref
.
backShaderStage
]
.
count
(
output
-
>
name
)
=
=
0
)
{
mInactiveVaryingMappedNames
[
ref
.
backShaderStage
]
.
push_back
(
output
-
>
mappedName
)
;
}
}
std
:
:
sort
(
mPackedVaryings
.
begin
(
)
mPackedVaryings
.
end
(
)
ComparePackedVarying
)
;
return
packUserVaryings
(
infoLog
mPackedVaryings
)
;
}
bool
VaryingPacking
:
:
packUserVaryings
(
gl
:
:
InfoLog
&
infoLog
const
std
:
:
vector
<
PackedVarying
>
&
packedVaryings
)
{
for
(
const
PackedVarying
&
packedVarying
:
packedVaryings
)
{
if
(
!
packVarying
(
packedVarying
)
)
{
ShaderType
eitherStage
=
packedVarying
.
frontVarying
.
varying
?
packedVarying
.
frontVarying
.
stage
:
packedVarying
.
backVarying
.
stage
;
infoLog
<
<
"
Could
not
pack
varying
"
<
<
packedVarying
.
fullName
(
eitherStage
)
;
if
(
mPackMode
=
=
PackMode
:
:
ANGLE_NON_CONFORMANT_D3D9
)
{
infoLog
<
<
"
Note
:
Additional
non
-
conformant
packing
restrictions
are
enforced
on
"
"
D3D9
.
"
;
}
return
false
;
}
}
std
:
:
sort
(
mRegisterList
.
begin
(
)
mRegisterList
.
end
(
)
)
;
return
true
;
}
}
