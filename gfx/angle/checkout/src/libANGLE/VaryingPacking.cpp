#
include
"
libANGLE
/
VaryingPacking
.
h
"
#
include
"
common
/
utilities
.
h
"
#
include
"
libANGLE
/
Program
.
h
"
#
include
"
libANGLE
/
Shader
.
h
"
namespace
gl
{
namespace
{
bool
ComparePackedVarying
(
const
PackedVarying
&
x
const
PackedVarying
&
y
)
{
sh
:
:
ShaderVariable
vx
vy
;
const
sh
:
:
ShaderVariable
*
px
*
py
;
if
(
x
.
isArrayElement
(
)
)
{
vx
=
*
x
.
varying
;
vx
.
arraySizes
.
clear
(
)
;
px
=
&
vx
;
}
else
{
px
=
x
.
varying
;
}
if
(
y
.
isArrayElement
(
)
)
{
vy
=
*
y
.
varying
;
vy
.
arraySizes
.
clear
(
)
;
py
=
&
vy
;
}
else
{
py
=
y
.
varying
;
}
return
gl
:
:
CompareShaderVar
(
*
px
*
py
)
;
}
}
VaryingPacking
:
:
VaryingPacking
(
GLuint
maxVaryingVectors
PackMode
packMode
)
:
mRegisterMap
(
maxVaryingVectors
)
mPackMode
(
packMode
)
{
}
VaryingPacking
:
:
~
VaryingPacking
(
)
=
default
;
bool
VaryingPacking
:
:
packVarying
(
const
PackedVarying
&
packedVarying
)
{
const
sh
:
:
ShaderVariable
&
varying
=
*
packedVarying
.
varying
;
ASSERT
(
!
varying
.
isStruct
(
)
)
;
GLenum
transposedType
=
gl
:
:
TransposeMatrixType
(
varying
.
type
)
;
unsigned
int
varyingRows
=
gl
:
:
VariableRowCount
(
transposedType
)
;
unsigned
int
varyingColumns
=
gl
:
:
VariableColumnCount
(
transposedType
)
;
if
(
mPackMode
=
=
PackMode
:
:
ANGLE_NON_CONFORMANT_D3D9
)
{
varyingColumns
=
4
;
}
else
if
(
mPackMode
=
=
PackMode
:
:
WEBGL_STRICT
&
&
varying
.
type
=
=
GL_FLOAT_MAT2
)
{
varyingColumns
=
4
;
}
const
unsigned
int
elementCount
=
varying
.
getBasicTypeElementCount
(
)
;
varyingRows
*
=
(
packedVarying
.
isArrayElement
(
)
?
1
:
elementCount
)
;
unsigned
int
maxVaryingVectors
=
static_cast
<
unsigned
int
>
(
mRegisterMap
.
size
(
)
)
;
if
(
varyingRows
>
maxVaryingVectors
)
{
return
false
;
}
if
(
varyingColumns
>
=
2
&
&
varyingColumns
<
=
4
)
{
for
(
unsigned
int
row
=
0
;
row
<
=
maxVaryingVectors
-
varyingRows
;
+
+
row
)
{
if
(
isFree
(
row
0
varyingRows
varyingColumns
)
)
{
insert
(
row
0
packedVarying
)
;
return
true
;
}
}
if
(
varyingColumns
=
=
2
)
{
for
(
unsigned
int
r
=
maxVaryingVectors
-
varyingRows
+
1
;
r
-
-
>
=
1
;
)
{
if
(
isFree
(
r
2
varyingRows
2
)
)
{
insert
(
r
2
packedVarying
)
;
return
true
;
}
}
}
return
false
;
}
ASSERT
(
varyingColumns
=
=
1
)
;
unsigned
int
contiguousSpace
[
4
]
=
{
0
}
;
unsigned
int
bestContiguousSpace
[
4
]
=
{
0
}
;
unsigned
int
totalSpace
[
4
]
=
{
0
}
;
for
(
unsigned
int
row
=
0
;
row
<
maxVaryingVectors
;
+
+
row
)
{
for
(
unsigned
int
column
=
0
;
column
<
4
;
+
+
column
)
{
if
(
mRegisterMap
[
row
]
[
column
]
)
{
contiguousSpace
[
column
]
=
0
;
}
else
{
contiguousSpace
[
column
]
+
+
;
totalSpace
[
column
]
+
+
;
if
(
contiguousSpace
[
column
]
>
bestContiguousSpace
[
column
]
)
{
bestContiguousSpace
[
column
]
=
contiguousSpace
[
column
]
;
}
}
}
}
unsigned
int
bestColumn
=
0
;
for
(
unsigned
int
column
=
1
;
column
<
4
;
+
+
column
)
{
if
(
bestContiguousSpace
[
column
]
>
=
varyingRows
&
&
(
bestContiguousSpace
[
bestColumn
]
<
varyingRows
|
|
totalSpace
[
column
]
<
totalSpace
[
bestColumn
]
)
)
{
bestColumn
=
column
;
}
}
if
(
bestContiguousSpace
[
bestColumn
]
>
=
varyingRows
)
{
for
(
unsigned
int
row
=
0
;
row
<
maxVaryingVectors
;
row
+
+
)
{
if
(
isFree
(
row
bestColumn
varyingRows
1
)
)
{
for
(
unsigned
int
arrayIndex
=
0
;
arrayIndex
<
varyingRows
;
+
+
arrayIndex
)
{
PackedVaryingRegister
registerInfo
;
registerInfo
.
packedVarying
=
&
packedVarying
;
registerInfo
.
registerRow
=
row
+
arrayIndex
;
registerInfo
.
registerColumn
=
bestColumn
;
registerInfo
.
varyingArrayIndex
=
(
packedVarying
.
isArrayElement
(
)
?
packedVarying
.
arrayIndex
:
arrayIndex
)
;
registerInfo
.
varyingRowIndex
=
0
;
if
(
!
packedVarying
.
varying
-
>
isBuiltIn
(
)
)
{
mRegisterList
.
push_back
(
registerInfo
)
;
}
mRegisterMap
[
row
+
arrayIndex
]
[
bestColumn
]
=
true
;
}
break
;
}
}
return
true
;
}
return
false
;
}
bool
VaryingPacking
:
:
isFree
(
unsigned
int
registerRow
unsigned
int
registerColumn
unsigned
int
varyingRows
unsigned
int
varyingColumns
)
const
{
for
(
unsigned
int
row
=
0
;
row
<
varyingRows
;
+
+
row
)
{
ASSERT
(
registerRow
+
row
<
mRegisterMap
.
size
(
)
)
;
for
(
unsigned
int
column
=
0
;
column
<
varyingColumns
;
+
+
column
)
{
ASSERT
(
registerColumn
+
column
<
4
)
;
if
(
mRegisterMap
[
registerRow
+
row
]
[
registerColumn
+
column
]
)
{
return
false
;
}
}
}
return
true
;
}
void
VaryingPacking
:
:
insert
(
unsigned
int
registerRow
unsigned
int
registerColumn
const
PackedVarying
&
packedVarying
)
{
unsigned
int
varyingRows
=
0
;
unsigned
int
varyingColumns
=
0
;
const
auto
&
varying
=
*
packedVarying
.
varying
;
ASSERT
(
!
varying
.
isStruct
(
)
)
;
GLenum
transposedType
=
gl
:
:
TransposeMatrixType
(
varying
.
type
)
;
varyingRows
=
gl
:
:
VariableRowCount
(
transposedType
)
;
varyingColumns
=
gl
:
:
VariableColumnCount
(
transposedType
)
;
PackedVaryingRegister
registerInfo
;
registerInfo
.
packedVarying
=
&
packedVarying
;
registerInfo
.
registerColumn
=
registerColumn
;
const
unsigned
int
arrayElementCount
=
varying
.
getBasicTypeElementCount
(
)
;
for
(
unsigned
int
arrayElement
=
0
;
arrayElement
<
arrayElementCount
;
+
+
arrayElement
)
{
if
(
packedVarying
.
isArrayElement
(
)
&
&
arrayElement
!
=
packedVarying
.
arrayIndex
)
{
continue
;
}
for
(
unsigned
int
varyingRow
=
0
;
varyingRow
<
varyingRows
;
+
+
varyingRow
)
{
registerInfo
.
registerRow
=
registerRow
+
(
arrayElement
*
varyingRows
)
+
varyingRow
;
registerInfo
.
varyingRowIndex
=
varyingRow
;
registerInfo
.
varyingArrayIndex
=
arrayElement
;
if
(
!
packedVarying
.
varying
-
>
isBuiltIn
(
)
)
{
mRegisterList
.
push_back
(
registerInfo
)
;
}
for
(
unsigned
int
columnIndex
=
0
;
columnIndex
<
varyingColumns
;
+
+
columnIndex
)
{
mRegisterMap
[
registerInfo
.
registerRow
]
[
registerColumn
+
columnIndex
]
=
true
;
}
}
}
}
bool
VaryingPacking
:
:
collectAndPackUserVaryings
(
gl
:
:
InfoLog
&
infoLog
const
ProgramMergedVaryings
&
mergedVaryings
const
std
:
:
vector
<
std
:
:
string
>
&
tfVaryings
)
{
std
:
:
set
<
std
:
:
string
>
uniqueFullNames
;
mPackedVaryings
.
clear
(
)
;
for
(
const
auto
&
ref
:
mergedVaryings
)
{
const
sh
:
:
Varying
*
input
=
ref
.
second
.
vertex
;
const
sh
:
:
Varying
*
output
=
ref
.
second
.
fragment
;
if
(
(
input
&
&
output
&
&
output
-
>
staticUse
)
|
|
(
input
&
&
input
-
>
isBuiltIn
(
)
&
&
input
-
>
active
)
|
|
(
output
&
&
output
-
>
isBuiltIn
(
)
&
&
output
-
>
active
)
)
{
const
sh
:
:
Varying
*
varying
=
output
?
output
:
input
;
if
(
varying
-
>
name
!
=
"
gl_Position
"
&
&
!
(
varying
-
>
name
=
=
"
gl_PointSize
"
&
&
mPackMode
=
=
PackMode
:
:
ANGLE_NON_CONFORMANT_D3D9
)
)
{
auto
interpolation
=
ref
.
second
.
get
(
)
-
>
interpolation
;
if
(
varying
-
>
isStruct
(
)
)
{
ASSERT
(
!
varying
-
>
isArray
(
)
)
;
for
(
GLuint
fieldIndex
=
0
;
fieldIndex
<
varying
-
>
fields
.
size
(
)
;
+
+
fieldIndex
)
{
const
sh
:
:
ShaderVariable
&
field
=
varying
-
>
fields
[
fieldIndex
]
;
ASSERT
(
!
field
.
isStruct
(
)
&
&
!
field
.
isArray
(
)
)
;
mPackedVaryings
.
emplace_back
(
field
interpolation
varying
-
>
name
fieldIndex
)
;
uniqueFullNames
.
insert
(
mPackedVaryings
.
back
(
)
.
fullName
(
)
)
;
}
}
else
{
mPackedVaryings
.
emplace_back
(
*
varying
interpolation
)
;
uniqueFullNames
.
insert
(
mPackedVaryings
.
back
(
)
.
fullName
(
)
)
;
}
continue
;
}
}
if
(
!
input
)
{
mInactiveVaryingNames
.
push_back
(
ref
.
first
)
;
continue
;
}
for
(
const
std
:
:
string
&
tfVarying
:
tfVaryings
)
{
std
:
:
vector
<
unsigned
int
>
subscripts
;
std
:
:
string
baseName
=
ParseResourceName
(
tfVarying
&
subscripts
)
;
size_t
subscript
=
GL_INVALID_INDEX
;
if
(
!
subscripts
.
empty
(
)
)
{
subscript
=
subscripts
.
back
(
)
;
}
if
(
uniqueFullNames
.
count
(
tfVarying
)
>
0
|
|
uniqueFullNames
.
count
(
baseName
)
>
0
)
{
continue
;
}
if
(
input
-
>
isStruct
(
)
)
{
GLuint
fieldIndex
=
0
;
const
sh
:
:
ShaderVariable
*
field
=
FindShaderVarField
(
*
input
tfVarying
&
fieldIndex
)
;
if
(
field
!
=
nullptr
)
{
ASSERT
(
!
field
-
>
isStruct
(
)
&
&
!
field
-
>
isArray
(
)
)
;
mPackedVaryings
.
emplace_back
(
*
field
input
-
>
interpolation
input
-
>
name
fieldIndex
)
;
mPackedVaryings
.
back
(
)
.
vertexOnly
=
true
;
mPackedVaryings
.
back
(
)
.
arrayIndex
=
GL_INVALID_INDEX
;
uniqueFullNames
.
insert
(
tfVarying
)
;
}
}
else
if
(
baseName
=
=
input
-
>
name
)
{
if
(
tfVarying
.
compare
(
0
3
"
gl_
"
)
!
=
0
)
{
mPackedVaryings
.
emplace_back
(
*
input
input
-
>
interpolation
)
;
mPackedVaryings
.
back
(
)
.
vertexOnly
=
true
;
mPackedVaryings
.
back
(
)
.
arrayIndex
=
static_cast
<
GLuint
>
(
subscript
)
;
uniqueFullNames
.
insert
(
tfVarying
)
;
}
if
(
subscript
=
=
GL_INVALID_INDEX
)
{
break
;
}
}
}
if
(
uniqueFullNames
.
count
(
ref
.
first
)
=
=
0
)
{
mInactiveVaryingNames
.
push_back
(
ref
.
first
)
;
}
}
std
:
:
sort
(
mPackedVaryings
.
begin
(
)
mPackedVaryings
.
end
(
)
ComparePackedVarying
)
;
return
packUserVaryings
(
infoLog
mPackedVaryings
)
;
}
bool
VaryingPacking
:
:
packUserVaryings
(
gl
:
:
InfoLog
&
infoLog
const
std
:
:
vector
<
PackedVarying
>
&
packedVaryings
)
{
for
(
const
PackedVarying
&
packedVarying
:
packedVaryings
)
{
if
(
!
packVarying
(
packedVarying
)
)
{
infoLog
<
<
"
Could
not
pack
varying
"
<
<
packedVarying
.
fullName
(
)
;
if
(
mPackMode
=
=
PackMode
:
:
ANGLE_NON_CONFORMANT_D3D9
)
{
infoLog
<
<
"
Note
:
Additional
non
-
conformant
packing
restrictions
are
enforced
on
"
"
D3D9
.
"
;
}
return
false
;
}
}
std
:
:
sort
(
mRegisterList
.
begin
(
)
mRegisterList
.
end
(
)
)
;
return
true
;
}
}
