#
ifndef
LIBANGLE_RENDERER_D3D11_STATEMANAGER11_H_
#
define
LIBANGLE_RENDERER_D3D11_STATEMANAGER11_H_
#
include
<
array
>
#
include
"
libANGLE
/
ContextState
.
h
"
#
include
"
libANGLE
/
State
.
h
"
#
include
"
libANGLE
/
angletypes
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
IndexDataManager
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
RendererD3D
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
InputLayoutCache
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
Query11
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
RenderStateCache
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
renderer11_utils
.
h
"
namespace
rx
{
class
Buffer11
;
struct
RenderTargetDesc
;
struct
Renderer11DeviceCaps
;
class
ShaderConstants11
:
angle
:
:
NonCopyable
{
public
:
ShaderConstants11
(
)
;
~
ShaderConstants11
(
)
;
void
init
(
const
gl
:
:
Caps
&
caps
)
;
size_t
getRequiredBufferSize
(
gl
:
:
ShaderType
shaderType
)
const
;
void
markDirty
(
)
;
void
setComputeWorkGroups
(
GLuint
numGroupsX
GLuint
numGroupsY
GLuint
numGroupsZ
)
;
void
setMultiviewWriteToViewportIndex
(
GLfloat
index
)
;
void
onViewportChange
(
const
gl
:
:
Rectangle
&
glViewport
const
D3D11_VIEWPORT
&
dxViewport
bool
is9_3
bool
presentPathFast
)
;
void
onSamplerChange
(
gl
:
:
ShaderType
shaderType
unsigned
int
samplerIndex
const
gl
:
:
Texture
&
texture
)
;
gl
:
:
Error
updateBuffer
(
Renderer11
*
renderer
gl
:
:
ShaderType
shaderType
const
ProgramD3D
&
programD3D
const
d3d11
:
:
Buffer
&
driverConstantBuffer
)
;
private
:
struct
Vertex
{
Vertex
(
)
:
depthRange
{
.
0f
}
viewAdjust
{
.
0f
}
viewCoords
{
.
0f
}
viewScale
{
.
0f
}
multiviewWriteToViewportIndex
{
.
0f
}
padding
{
.
0f
}
{
}
float
depthRange
[
4
]
;
float
viewAdjust
[
4
]
;
float
viewCoords
[
4
]
;
float
viewScale
[
2
]
;
float
multiviewWriteToViewportIndex
;
float
padding
;
}
;
struct
Pixel
{
Pixel
(
)
:
depthRange
{
.
0f
}
viewCoords
{
.
0f
}
depthFront
{
.
0f
}
viewScale
{
.
0f
}
multiviewWriteToViewportIndex
(
0
)
padding
(
0
)
{
}
float
depthRange
[
4
]
;
float
viewCoords
[
4
]
;
float
depthFront
[
4
]
;
float
viewScale
[
2
]
;
float
multiviewWriteToViewportIndex
;
float
padding
;
}
;
struct
Compute
{
Compute
(
)
:
numWorkGroups
{
0u
}
padding
(
0u
)
{
}
unsigned
int
numWorkGroups
[
3
]
;
unsigned
int
padding
;
}
;
struct
SamplerMetadata
{
SamplerMetadata
(
)
:
baseLevel
(
0
)
internalFormatBits
(
0
)
wrapModes
(
0
)
padding
(
0
)
{
}
int
baseLevel
;
int
internalFormatBits
;
int
wrapModes
;
int
padding
;
}
;
static_assert
(
sizeof
(
SamplerMetadata
)
=
=
16u
"
Sampler
metadata
struct
must
be
one
4
-
vec
/
16
bytes
.
"
)
;
bool
updateSamplerMetadata
(
SamplerMetadata
*
data
const
gl
:
:
Texture
&
texture
)
;
Vertex
mVertex
;
Pixel
mPixel
;
Compute
mCompute
;
gl
:
:
ShaderBitSet
mShaderConstantsDirty
;
std
:
:
vector
<
SamplerMetadata
>
mSamplerMetadataVS
;
int
mNumActiveVSSamplers
;
std
:
:
vector
<
SamplerMetadata
>
mSamplerMetadataPS
;
int
mNumActivePSSamplers
;
std
:
:
vector
<
SamplerMetadata
>
mSamplerMetadataCS
;
int
mNumActiveCSSamplers
;
}
;
class
StateManager11
final
:
angle
:
:
NonCopyable
{
public
:
StateManager11
(
Renderer11
*
renderer
)
;
~
StateManager11
(
)
;
gl
:
:
Error
initialize
(
const
gl
:
:
Caps
&
caps
const
gl
:
:
Extensions
&
extensions
)
;
void
deinitialize
(
)
;
void
syncState
(
const
gl
:
:
Context
*
context
const
gl
:
:
State
:
:
DirtyBits
&
dirtyBits
)
;
gl
:
:
Error
updateStateForCompute
(
const
gl
:
:
Context
*
context
GLuint
numGroupsX
GLuint
numGroupsY
GLuint
numGroupsZ
)
;
void
updateStencilSizeIfChanged
(
bool
depthStencilInitialized
unsigned
int
stencilSize
)
;
void
invalidateBoundViews
(
)
;
void
invalidateCurrentValueAttrib
(
size_t
attribIndex
)
;
void
invalidateRenderTarget
(
)
;
void
invalidateVertexBuffer
(
)
;
void
invalidateViewport
(
const
gl
:
:
Context
*
context
)
;
void
invalidateSwizzles
(
)
;
void
invalidateShaders
(
)
;
void
invalidateProgramUniformBuffers
(
)
;
void
invalidateTransformFeedback
(
)
;
void
invalidateInputLayout
(
)
;
void
invalidateIndexBuffer
(
)
;
void
setRenderTarget
(
ID3D11RenderTargetView
*
rtv
ID3D11DepthStencilView
*
dsv
)
;
void
setRenderTargets
(
ID3D11RenderTargetView
*
*
rtvs
UINT
numRtvs
ID3D11DepthStencilView
*
dsv
)
;
void
onBeginQuery
(
Query11
*
query
)
;
void
onDeleteQueryObject
(
Query11
*
query
)
;
gl
:
:
Error
onMakeCurrent
(
const
gl
:
:
Context
*
context
)
;
void
setInputLayout
(
const
d3d11
:
:
InputLayout
*
inputLayout
)
;
void
setSingleVertexBuffer
(
const
d3d11
:
:
Buffer
*
buffer
UINT
stride
UINT
offset
)
;
gl
:
:
Error
updateState
(
const
gl
:
:
Context
*
context
const
gl
:
:
DrawCallParams
&
drawCallParams
)
;
void
setShaderResourceShared
(
gl
:
:
ShaderType
shaderType
UINT
resourceSlot
const
d3d11
:
:
SharedSRV
*
srv
)
;
void
setShaderResource
(
gl
:
:
ShaderType
shaderType
UINT
resourceSlot
const
d3d11
:
:
ShaderResourceView
*
srv
)
;
void
setPrimitiveTopology
(
D3D11_PRIMITIVE_TOPOLOGY
primitiveTopology
)
;
void
setDrawShaders
(
const
d3d11
:
:
VertexShader
*
vertexShader
const
d3d11
:
:
GeometryShader
*
geometryShader
const
d3d11
:
:
PixelShader
*
pixelShader
)
;
void
setVertexShader
(
const
d3d11
:
:
VertexShader
*
shader
)
;
void
setGeometryShader
(
const
d3d11
:
:
GeometryShader
*
shader
)
;
void
setPixelShader
(
const
d3d11
:
:
PixelShader
*
shader
)
;
void
setComputeShader
(
const
d3d11
:
:
ComputeShader
*
shader
)
;
void
setVertexConstantBuffer
(
unsigned
int
slot
const
d3d11
:
:
Buffer
*
buffer
)
;
void
setPixelConstantBuffer
(
unsigned
int
slot
const
d3d11
:
:
Buffer
*
buffer
)
;
void
setDepthStencilState
(
const
d3d11
:
:
DepthStencilState
*
depthStencilState
UINT
stencilRef
)
;
void
setSimpleBlendState
(
const
d3d11
:
:
BlendState
*
blendState
)
;
void
setRasterizerState
(
const
d3d11
:
:
RasterizerState
*
rasterizerState
)
;
void
setSimpleViewport
(
const
gl
:
:
Extents
&
viewportExtents
)
;
void
setSimpleViewport
(
int
width
int
height
)
;
void
setSimplePixelTextureAndSampler
(
const
d3d11
:
:
SharedSRV
&
srv
const
d3d11
:
:
SamplerState
&
samplerState
)
;
void
setSimpleScissorRect
(
const
gl
:
:
Rectangle
&
glRect
)
;
void
setScissorRectD3D
(
const
D3D11_RECT
&
d3dRect
)
;
void
setIndexBuffer
(
ID3D11Buffer
*
buffer
DXGI_FORMAT
indexFormat
unsigned
int
offset
)
;
gl
:
:
Error
updateVertexOffsetsForPointSpritesEmulation
(
GLint
startVertex
GLsizei
emulatedInstanceId
)
;
gl
:
:
Error
applyComputeUniforms
(
ProgramD3D
*
programD3D
)
;
InputLayoutCache
*
getInputLayoutCache
(
)
{
return
&
mInputLayoutCache
;
}
GLsizei
getCurrentMinimumDrawCount
(
)
const
{
return
mCurrentMinimumDrawCount
;
}
VertexDataManager
*
getVertexDataManager
(
)
{
return
&
mVertexDataManager
;
}
private
:
template
<
typename
SRVType
>
void
setShaderResourceInternal
(
gl
:
:
ShaderType
shaderType
UINT
resourceSlot
const
SRVType
*
srv
)
;
template
<
typename
UAVType
>
void
setUnorderedAccessViewInternal
(
gl
:
:
ShaderType
shaderType
UINT
resourceSlot
const
UAVType
*
uav
)
;
bool
unsetConflictingView
(
ID3D11View
*
view
)
;
bool
unsetConflictingSRVs
(
gl
:
:
ShaderType
shaderType
uintptr_t
resource
const
gl
:
:
ImageIndex
*
index
)
;
void
unsetConflictingAttachmentResources
(
const
gl
:
:
FramebufferAttachment
*
attachment
ID3D11Resource
*
resource
)
;
gl
:
:
Error
syncBlendState
(
const
gl
:
:
Context
*
context
const
gl
:
:
Framebuffer
*
framebuffer
const
gl
:
:
BlendState
&
blendState
const
gl
:
:
ColorF
&
blendColor
unsigned
int
sampleMask
)
;
gl
:
:
Error
syncDepthStencilState
(
const
gl
:
:
State
&
glState
)
;
gl
:
:
Error
syncRasterizerState
(
const
gl
:
:
Context
*
context
const
gl
:
:
DrawCallParams
&
drawCallParams
)
;
void
syncScissorRectangle
(
const
gl
:
:
Rectangle
&
scissor
bool
enabled
)
;
void
syncViewport
(
const
gl
:
:
Context
*
context
)
;
void
checkPresentPath
(
const
gl
:
:
Context
*
context
)
;
gl
:
:
Error
syncFramebuffer
(
const
gl
:
:
Context
*
context
gl
:
:
Framebuffer
*
framebuffer
)
;
gl
:
:
Error
syncProgram
(
const
gl
:
:
Context
*
context
GLenum
drawMode
)
;
gl
:
:
Error
syncTextures
(
const
gl
:
:
Context
*
context
)
;
gl
:
:
Error
applyTextures
(
const
gl
:
:
Context
*
context
gl
:
:
ShaderType
shaderType
)
;
gl
:
:
Error
syncTexturesForCompute
(
const
gl
:
:
Context
*
context
)
;
gl
:
:
Error
setSamplerState
(
const
gl
:
:
Context
*
context
gl
:
:
ShaderType
type
int
index
gl
:
:
Texture
*
texture
const
gl
:
:
SamplerState
&
sampler
)
;
gl
:
:
Error
setTexture
(
const
gl
:
:
Context
*
context
gl
:
:
ShaderType
type
int
index
gl
:
:
Texture
*
texture
)
;
gl
:
:
Error
setTextureForImage
(
const
gl
:
:
Context
*
context
gl
:
:
ShaderType
type
int
index
bool
readonly
const
gl
:
:
ImageUnit
&
imageUnit
)
;
gl
:
:
Error
clearSRVs
(
gl
:
:
ShaderType
shaderType
size_t
rangeStart
size_t
rangeEnd
)
;
gl
:
:
Error
clearUAVs
(
gl
:
:
ShaderType
shaderType
size_t
rangeStart
size_t
rangeEnd
)
;
void
handleMultiviewDrawFramebufferChange
(
const
gl
:
:
Context
*
context
)
;
gl
:
:
Error
syncCurrentValueAttribs
(
const
gl
:
:
State
&
glState
)
;
gl
:
:
Error
generateSwizzle
(
const
gl
:
:
Context
*
context
gl
:
:
Texture
*
texture
)
;
gl
:
:
Error
generateSwizzlesForShader
(
const
gl
:
:
Context
*
context
gl
:
:
ShaderType
type
)
;
gl
:
:
Error
generateSwizzles
(
const
gl
:
:
Context
*
context
)
;
gl
:
:
Error
applyDriverUniforms
(
const
ProgramD3D
&
programD3D
)
;
gl
:
:
Error
applyUniforms
(
ProgramD3D
*
programD3D
)
;
gl
:
:
Error
syncUniformBuffers
(
const
gl
:
:
Context
*
context
ProgramD3D
*
programD3D
)
;
gl
:
:
Error
syncTransformFeedbackBuffers
(
const
gl
:
:
Context
*
context
)
;
void
invalidateTexturesAndSamplers
(
)
;
void
invalidateDriverUniforms
(
)
;
void
invalidateProgramUniforms
(
)
;
void
invalidateConstantBuffer
(
unsigned
int
slot
)
;
void
processFramebufferInvalidation
(
const
gl
:
:
Context
*
context
)
;
bool
syncIndexBuffer
(
ID3D11Buffer
*
buffer
DXGI_FORMAT
indexFormat
unsigned
int
offset
)
;
gl
:
:
Error
syncVertexBuffersAndInputLayout
(
const
gl
:
:
Context
*
context
const
gl
:
:
DrawCallParams
&
vertexParams
)
;
bool
setInputLayoutInternal
(
const
d3d11
:
:
InputLayout
*
inputLayout
)
;
gl
:
:
Error
applyVertexBuffers
(
const
gl
:
:
Context
*
context
const
gl
:
:
DrawCallParams
&
drawCallParams
)
;
bool
queueVertexBufferChange
(
size_t
bufferIndex
ID3D11Buffer
*
buffer
UINT
stride
UINT
offset
)
;
void
applyVertexBufferChanges
(
)
;
bool
setPrimitiveTopologyInternal
(
D3D11_PRIMITIVE_TOPOLOGY
primitiveTopology
)
;
void
syncPrimitiveTopology
(
const
gl
:
:
State
&
glState
ProgramD3D
*
programD3D
GLenum
currentDrawMode
)
;
gl
:
:
Error
applyIndexBuffer
(
const
gl
:
:
Context
*
context
const
gl
:
:
DrawCallParams
&
drawCallParams
)
;
enum
DirtyBitType
{
DIRTY_BIT_RENDER_TARGET
DIRTY_BIT_VIEWPORT_STATE
DIRTY_BIT_SCISSOR_STATE
DIRTY_BIT_RASTERIZER_STATE
DIRTY_BIT_BLEND_STATE
DIRTY_BIT_DEPTH_STENCIL_STATE
DIRTY_BIT_TEXTURE_AND_SAMPLER_STATE
DIRTY_BIT_PROGRAM_UNIFORMS
DIRTY_BIT_DRIVER_UNIFORMS
DIRTY_BIT_PROGRAM_UNIFORM_BUFFERS
DIRTY_BIT_SHADERS
DIRTY_BIT_CURRENT_VALUE_ATTRIBS
DIRTY_BIT_TRANSFORM_FEEDBACK
DIRTY_BIT_VERTEX_BUFFERS_AND_INPUT_LAYOUT
DIRTY_BIT_PRIMITIVE_TOPOLOGY
DIRTY_BIT_INVALID
DIRTY_BIT_MAX
=
DIRTY_BIT_INVALID
}
;
using
DirtyBits
=
angle
:
:
BitSet
<
DIRTY_BIT_MAX
>
;
Renderer11
*
mRenderer
;
DirtyBits
mInternalDirtyBits
;
gl
:
:
BlendState
mCurBlendState
;
gl
:
:
ColorF
mCurBlendColor
;
unsigned
int
mCurSampleMask
;
gl
:
:
DepthStencilState
mCurDepthStencilState
;
int
mCurStencilRef
;
int
mCurStencilBackRef
;
unsigned
int
mCurStencilSize
;
Optional
<
bool
>
mCurDisableDepth
;
Optional
<
bool
>
mCurDisableStencil
;
gl
:
:
RasterizerState
mCurRasterState
;
bool
mCurScissorEnabled
;
gl
:
:
Rectangle
mCurScissorRect
;
gl
:
:
Rectangle
mCurViewport
;
float
mCurNear
;
float
mCurFar
;
std
:
:
vector
<
gl
:
:
Offset
>
mViewportOffsets
;
ShaderConstants11
mShaderConstants
;
gl
:
:
Extents
mViewportBounds
;
bool
mRenderTargetIsDirty
;
bool
mCurPresentPathFastEnabled
;
int
mCurPresentPathFastColorBufferHeight
;
std
:
:
set
<
Query11
*
>
mCurrentQueries
;
template
<
typename
DescType
>
struct
ViewRecord
{
uintptr_t
view
;
uintptr_t
resource
;
DescType
desc
;
}
;
template
<
typename
ViewType
typename
DescType
>
class
ViewCache
:
angle
:
:
NonCopyable
{
public
:
ViewCache
(
)
;
~
ViewCache
(
)
;
void
initialize
(
size_t
size
)
{
mCurrentViews
.
resize
(
size
)
;
}
size_t
size
(
)
const
{
return
mCurrentViews
.
size
(
)
;
}
size_t
highestUsed
(
)
const
{
return
mHighestUsedView
;
}
const
ViewRecord
<
DescType
>
&
operator
[
]
(
size_t
index
)
const
{
return
mCurrentViews
[
index
]
;
}
void
clear
(
)
;
void
update
(
size_t
resourceIndex
ViewType
*
view
)
;
private
:
std
:
:
vector
<
ViewRecord
<
DescType
>
>
mCurrentViews
;
size_t
mHighestUsedView
;
}
;
using
SRVCache
=
ViewCache
<
ID3D11ShaderResourceView
D3D11_SHADER_RESOURCE_VIEW_DESC
>
;
using
UAVCache
=
ViewCache
<
ID3D11UnorderedAccessView
D3D11_UNORDERED_ACCESS_VIEW_DESC
>
;
SRVCache
mCurVertexSRVs
;
SRVCache
mCurPixelSRVs
;
SRVCache
mCurComputeSRVs
;
UAVCache
mCurComputeUAVs
;
SRVCache
*
getSRVCache
(
gl
:
:
ShaderType
shaderType
)
;
std
:
:
vector
<
ID3D11ShaderResourceView
*
>
mNullSRVs
;
std
:
:
vector
<
ID3D11UnorderedAccessView
*
>
mNullUAVs
;
gl
:
:
AttributesMask
mDirtyCurrentValueAttribs
;
std
:
:
vector
<
TranslatedAttribute
>
mCurrentValueAttribs
;
ResourceSerial
mCurrentInputLayout
;
gl
:
:
AttribArray
<
ID3D11Buffer
*
>
mCurrentVertexBuffers
;
gl
:
:
AttribArray
<
UINT
>
mCurrentVertexStrides
;
gl
:
:
AttribArray
<
UINT
>
mCurrentVertexOffsets
;
gl
:
:
RangeUI
mDirtyVertexBufferRange
;
D3D11_PRIMITIVE_TOPOLOGY
mCurrentPrimitiveTopology
;
GLenum
mLastAppliedDrawMode
;
GLsizei
mCurrentMinimumDrawCount
;
ResourceSerial
mAppliedVertexShader
;
ResourceSerial
mAppliedGeometryShader
;
ResourceSerial
mAppliedPixelShader
;
ResourceSerial
mAppliedComputeShader
;
std
:
:
vector
<
bool
>
mForceSetVertexSamplerStates
;
std
:
:
vector
<
gl
:
:
SamplerState
>
mCurVertexSamplerStates
;
std
:
:
vector
<
bool
>
mForceSetPixelSamplerStates
;
std
:
:
vector
<
gl
:
:
SamplerState
>
mCurPixelSamplerStates
;
std
:
:
vector
<
bool
>
mForceSetComputeSamplerStates
;
std
:
:
vector
<
gl
:
:
SamplerState
>
mCurComputeSamplerStates
;
bool
mDirtySwizzles
;
ID3D11Buffer
*
mAppliedIB
;
DXGI_FORMAT
mAppliedIBFormat
;
unsigned
int
mAppliedIBOffset
;
bool
mIndexBufferIsDirty
;
VertexDataManager
mVertexDataManager
;
IndexDataManager
mIndexDataManager
;
InputLayoutCache
mInputLayoutCache
;
std
:
:
vector
<
const
TranslatedAttribute
*
>
mCurrentAttributes
;
Optional
<
GLint
>
mLastFirstVertex
;
bool
mIsMultiviewEnabled
;
d3d11
:
:
Buffer
mDriverConstantBufferVS
;
d3d11
:
:
Buffer
mDriverConstantBufferPS
;
d3d11
:
:
Buffer
mDriverConstantBufferCS
;
ResourceSerial
mCurrentComputeConstantBuffer
;
ResourceSerial
mCurrentGeometryConstantBuffer
;
d3d11
:
:
Buffer
mPointSpriteVertexBuffer
;
d3d11
:
:
Buffer
mPointSpriteIndexBuffer
;
template
<
typename
T
>
using
VertexConstantBufferArray
=
std
:
:
array
<
T
gl
:
:
IMPLEMENTATION_MAX_VERTEX_SHADER_UNIFORM_BUFFERS
>
;
VertexConstantBufferArray
<
ResourceSerial
>
mCurrentConstantBufferVS
;
VertexConstantBufferArray
<
GLintptr
>
mCurrentConstantBufferVSOffset
;
VertexConstantBufferArray
<
GLsizeiptr
>
mCurrentConstantBufferVSSize
;
template
<
typename
T
>
using
FragmentConstantBufferArray
=
std
:
:
array
<
T
gl
:
:
IMPLEMENTATION_MAX_FRAGMENT_SHADER_UNIFORM_BUFFERS
>
;
FragmentConstantBufferArray
<
ResourceSerial
>
mCurrentConstantBufferPS
;
FragmentConstantBufferArray
<
GLintptr
>
mCurrentConstantBufferPSOffset
;
FragmentConstantBufferArray
<
GLsizeiptr
>
mCurrentConstantBufferPSSize
;
class
ConstantBufferObserver
:
public
angle
:
:
ObserverInterface
{
public
:
ConstantBufferObserver
(
)
;
~
ConstantBufferObserver
(
)
override
;
void
onSubjectStateChange
(
const
gl
:
:
Context
*
context
angle
:
:
SubjectIndex
index
angle
:
:
SubjectMessage
message
)
override
;
void
reset
(
)
;
void
bindVS
(
size_t
index
Buffer11
*
buffer
)
;
void
bindPS
(
size_t
index
Buffer11
*
buffer
)
;
private
:
std
:
:
vector
<
angle
:
:
ObserverBinding
>
mBindingsVS
;
std
:
:
vector
<
angle
:
:
ObserverBinding
>
mBindingsPS
;
}
;
ConstantBufferObserver
mConstantBufferObserver
;
Serial
mAppliedTFSerial
;
Serial
mEmptySerial
;
}
;
}
#
endif
