#
ifndef
LIBANGLE_RENDERER_D3D_D3D11_BUFFER11_H_
#
define
LIBANGLE_RENDERER_D3D_D3D11_BUFFER11_H_
#
include
<
array
>
#
include
<
map
>
#
include
"
libANGLE
/
angletypes
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
BufferD3D
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
renderer11_utils
.
h
"
namespace
gl
{
class
FramebufferAttachment
;
}
namespace
rx
{
struct
PackPixelsParams
;
class
Renderer11
;
struct
SourceIndexData
;
struct
TranslatedAttribute
;
enum
BufferUsage
{
BUFFER_USAGE_SYSTEM_MEMORY
BUFFER_USAGE_STAGING
BUFFER_USAGE_VERTEX_OR_TRANSFORM_FEEDBACK
BUFFER_USAGE_INDEX
BUFFER_USAGE_INDIRECT
BUFFER_USAGE_PIXEL_UNPACK
BUFFER_USAGE_PIXEL_PACK
BUFFER_USAGE_UNIFORM
BUFFER_USAGE_EMULATED_INDEXED_VERTEX
BUFFER_USAGE_COUNT
}
;
typedef
size_t
DataRevision
;
class
Buffer11
:
public
BufferD3D
{
public
:
Buffer11
(
const
gl
:
:
BufferState
&
state
Renderer11
*
renderer
)
;
~
Buffer11
(
)
override
;
angle
:
:
Result
getBuffer
(
const
gl
:
:
Context
*
context
BufferUsage
usage
ID3D11Buffer
*
*
bufferOut
)
;
angle
:
:
Result
getEmulatedIndexedBuffer
(
const
gl
:
:
Context
*
context
SourceIndexData
*
indexInfo
const
TranslatedAttribute
&
attribute
GLint
startVertex
ID3D11Buffer
*
*
bufferOut
)
;
angle
:
:
Result
getConstantBufferRange
(
const
gl
:
:
Context
*
context
GLintptr
offset
GLsizeiptr
size
const
d3d11
:
:
Buffer
*
*
bufferOut
UINT
*
firstConstantOut
UINT
*
numConstantsOut
)
;
angle
:
:
Result
getSRV
(
const
gl
:
:
Context
*
context
DXGI_FORMAT
srvFormat
const
d3d11
:
:
ShaderResourceView
*
*
srvOut
)
;
bool
isMapped
(
)
const
{
return
mMappedStorage
!
=
nullptr
;
}
angle
:
:
Result
packPixels
(
const
gl
:
:
Context
*
context
const
gl
:
:
FramebufferAttachment
&
readAttachment
const
PackPixelsParams
&
params
)
;
size_t
getTotalCPUBufferMemoryBytes
(
)
const
;
size_t
getSize
(
)
const
override
;
bool
supportsDirectBinding
(
)
const
override
;
angle
:
:
Result
getData
(
const
gl
:
:
Context
*
context
const
uint8_t
*
*
outData
)
override
;
void
initializeStaticData
(
const
gl
:
:
Context
*
context
)
override
;
void
invalidateStaticData
(
const
gl
:
:
Context
*
context
)
override
;
gl
:
:
Error
setData
(
const
gl
:
:
Context
*
context
gl
:
:
BufferBinding
target
const
void
*
data
size_t
size
gl
:
:
BufferUsage
usage
)
override
;
gl
:
:
Error
setSubData
(
const
gl
:
:
Context
*
context
gl
:
:
BufferBinding
target
const
void
*
data
size_t
size
size_t
offset
)
override
;
gl
:
:
Error
copySubData
(
const
gl
:
:
Context
*
context
BufferImpl
*
source
GLintptr
sourceOffset
GLintptr
destOffset
GLsizeiptr
size
)
override
;
gl
:
:
Error
map
(
const
gl
:
:
Context
*
context
GLenum
access
void
*
*
mapPtr
)
override
;
gl
:
:
Error
mapRange
(
const
gl
:
:
Context
*
context
size_t
offset
size_t
length
GLbitfield
access
void
*
*
mapPtr
)
override
;
gl
:
:
Error
unmap
(
const
gl
:
:
Context
*
context
GLboolean
*
result
)
override
;
angle
:
:
Result
markTransformFeedbackUsage
(
const
gl
:
:
Context
*
context
)
override
;
private
:
class
BufferStorage
;
class
EmulatedIndexedStorage
;
class
NativeStorage
;
class
PackStorage
;
class
SystemMemoryStorage
;
struct
ConstantBufferCacheEntry
{
ConstantBufferCacheEntry
(
)
:
storage
(
nullptr
)
lruCount
(
0
)
{
}
BufferStorage
*
storage
;
unsigned
int
lruCount
;
}
;
void
markBufferUsage
(
BufferUsage
usage
)
;
angle
:
:
Result
garbageCollection
(
const
gl
:
:
Context
*
context
BufferUsage
currentUsage
)
;
angle
:
:
Result
updateBufferStorage
(
const
gl
:
:
Context
*
context
BufferStorage
*
storage
size_t
sourceOffset
size_t
storageSize
)
;
template
<
typename
StorageOutT
>
angle
:
:
Result
getBufferStorage
(
const
gl
:
:
Context
*
context
BufferUsage
usage
StorageOutT
*
*
storageOut
)
;
template
<
typename
StorageOutT
>
angle
:
:
Result
getStagingStorage
(
const
gl
:
:
Context
*
context
StorageOutT
*
*
storageOut
)
;
angle
:
:
Result
getLatestBufferStorage
(
const
gl
:
:
Context
*
context
BufferStorage
*
*
storageOut
)
const
;
angle
:
:
Result
getConstantBufferRangeStorage
(
const
gl
:
:
Context
*
context
GLintptr
offset
GLsizeiptr
size
NativeStorage
*
*
storageOut
)
;
BufferStorage
*
allocateStorage
(
BufferUsage
usage
)
;
void
updateDeallocThreshold
(
BufferUsage
usage
)
;
angle
:
:
Result
checkForDeallocation
(
const
gl
:
:
Context
*
context
BufferUsage
usage
)
;
bool
canDeallocateSystemMemory
(
)
const
;
void
onCopyStorage
(
BufferStorage
*
dest
BufferStorage
*
source
)
;
void
onStorageUpdate
(
BufferStorage
*
updatedStorage
)
;
Renderer11
*
mRenderer
;
size_t
mSize
;
BufferStorage
*
mMappedStorage
;
std
:
:
array
<
BufferStorage
*
BUFFER_USAGE_COUNT
>
mBufferStorages
;
BufferStorage
*
mLatestBufferStorage
;
std
:
:
array
<
unsigned
int
BUFFER_USAGE_COUNT
>
mDeallocThresholds
;
std
:
:
array
<
unsigned
int
BUFFER_USAGE_COUNT
>
mIdleness
;
typedef
std
:
:
map
<
GLintptr
ConstantBufferCacheEntry
>
ConstantBufferCache
;
ConstantBufferCache
mConstantBufferRangeStoragesCache
;
size_t
mConstantBufferStorageAdditionalSize
;
unsigned
int
mMaxConstantBufferLruCount
;
}
;
}
#
endif
