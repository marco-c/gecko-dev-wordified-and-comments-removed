#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
StateManager11
.
h
"
#
include
"
common
/
bitset_utils
.
h
"
#
include
"
common
/
mathutil
.
h
"
#
include
"
common
/
utilities
.
h
"
#
include
"
libANGLE
/
Context
.
h
"
#
include
"
libANGLE
/
Query
.
h
"
#
include
"
libANGLE
/
VertexArray
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
DisplayD3D
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
TextureD3D
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
Buffer11
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
Context11
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
Framebuffer11
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
IndexBuffer11
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
RenderTarget11
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
Renderer11
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
ShaderExecutable11
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
TextureStorage11
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
TransformFeedback11
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
VertexArray11
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
VertexBuffer11
.
h
"
namespace
rx
{
namespace
{
bool
ImageIndexConflictsWithSRV
(
const
gl
:
:
ImageIndex
&
index
D3D11_SHADER_RESOURCE_VIEW_DESC
desc
)
{
unsigned
mipLevel
=
index
.
getLevelIndex
(
)
;
gl
:
:
TextureType
textureType
=
index
.
getType
(
)
;
switch
(
desc
.
ViewDimension
)
{
case
D3D11_SRV_DIMENSION_TEXTURE2D
:
{
bool
allLevels
=
(
desc
.
Texture2D
.
MipLevels
=
=
std
:
:
numeric_limits
<
UINT
>
:
:
max
(
)
)
;
unsigned
int
maxSrvMip
=
desc
.
Texture2D
.
MipLevels
+
desc
.
Texture2D
.
MostDetailedMip
;
maxSrvMip
=
allLevels
?
INT_MAX
:
maxSrvMip
;
unsigned
mipMin
=
index
.
getLevelIndex
(
)
;
unsigned
mipMax
=
INT_MAX
;
return
textureType
=
=
gl
:
:
TextureType
:
:
_2D
&
&
gl
:
:
RangeUI
(
mipMin
mipMax
)
.
intersects
(
gl
:
:
RangeUI
(
desc
.
Texture2D
.
MostDetailedMip
maxSrvMip
)
)
;
}
case
D3D11_SRV_DIMENSION_TEXTURE2DARRAY
:
{
GLint
layerIndex
=
index
.
getLayerIndex
(
)
;
bool
allLevels
=
(
desc
.
Texture2DArray
.
MipLevels
=
=
std
:
:
numeric_limits
<
UINT
>
:
:
max
(
)
)
;
unsigned
int
maxSrvMip
=
desc
.
Texture2DArray
.
MipLevels
+
desc
.
Texture2DArray
.
MostDetailedMip
;
maxSrvMip
=
allLevels
?
INT_MAX
:
maxSrvMip
;
unsigned
maxSlice
=
desc
.
Texture2DArray
.
FirstArraySlice
+
desc
.
Texture2DArray
.
ArraySize
;
return
(
textureType
=
=
gl
:
:
TextureType
:
:
_2DArray
|
|
textureType
=
=
gl
:
:
TextureType
:
:
CubeMap
)
&
&
desc
.
Texture2DArray
.
MostDetailedMip
<
=
mipLevel
&
&
mipLevel
<
maxSrvMip
&
&
desc
.
Texture2DArray
.
FirstArraySlice
<
=
static_cast
<
UINT
>
(
layerIndex
)
&
&
static_cast
<
UINT
>
(
layerIndex
)
<
maxSlice
;
}
case
D3D11_SRV_DIMENSION_TEXTURECUBE
:
{
bool
allLevels
=
(
desc
.
TextureCube
.
MipLevels
=
=
std
:
:
numeric_limits
<
UINT
>
:
:
max
(
)
)
;
unsigned
int
maxSrvMip
=
desc
.
TextureCube
.
MipLevels
+
desc
.
TextureCube
.
MostDetailedMip
;
maxSrvMip
=
allLevels
?
INT_MAX
:
maxSrvMip
;
return
textureType
=
=
gl
:
:
TextureType
:
:
CubeMap
&
&
desc
.
TextureCube
.
MostDetailedMip
<
=
mipLevel
&
&
mipLevel
<
maxSrvMip
;
}
case
D3D11_SRV_DIMENSION_TEXTURE3D
:
{
bool
allLevels
=
(
desc
.
Texture3D
.
MipLevels
=
=
std
:
:
numeric_limits
<
UINT
>
:
:
max
(
)
)
;
unsigned
int
maxSrvMip
=
desc
.
Texture3D
.
MipLevels
+
desc
.
Texture3D
.
MostDetailedMip
;
maxSrvMip
=
allLevels
?
INT_MAX
:
maxSrvMip
;
return
textureType
=
=
gl
:
:
TextureType
:
:
_3D
&
&
desc
.
Texture3D
.
MostDetailedMip
<
=
mipLevel
&
&
mipLevel
<
maxSrvMip
;
}
default
:
UNIMPLEMENTED
(
)
;
}
return
false
;
}
ID3D11Resource
*
GetViewResource
(
ID3D11View
*
view
)
{
ID3D11Resource
*
resource
=
nullptr
;
ASSERT
(
view
)
;
view
-
>
GetResource
(
&
resource
)
;
resource
-
>
Release
(
)
;
return
resource
;
}
int
GetWrapBits
(
GLenum
wrap
)
{
switch
(
wrap
)
{
case
GL_CLAMP_TO_EDGE
:
return
0x1
;
case
GL_REPEAT
:
return
0x2
;
case
GL_MIRRORED_REPEAT
:
return
0x3
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
Optional
<
size_t
>
FindFirstNonInstanced
(
const
std
:
:
vector
<
const
TranslatedAttribute
*
>
&
currentAttributes
)
{
for
(
size_t
index
=
0
;
index
<
currentAttributes
.
size
(
)
;
+
+
index
)
{
if
(
currentAttributes
[
index
]
-
>
divisor
=
=
0
)
{
return
Optional
<
size_t
>
(
index
)
;
}
}
return
Optional
<
size_t
>
:
:
Invalid
(
)
;
}
void
SortAttributesByLayout
(
const
ProgramD3D
&
programD3D
const
std
:
:
vector
<
TranslatedAttribute
>
&
vertexArrayAttribs
const
std
:
:
vector
<
TranslatedAttribute
>
&
currentValueAttribs
AttribIndexArray
*
sortedD3DSemanticsOut
std
:
:
vector
<
const
TranslatedAttribute
*
>
*
sortedAttributesOut
)
{
sortedAttributesOut
-
>
clear
(
)
;
const
AttribIndexArray
&
locationToSemantic
=
programD3D
.
getAttribLocationToD3DSemantics
(
)
;
for
(
auto
locationIndex
:
programD3D
.
getState
(
)
.
getActiveAttribLocationsMask
(
)
)
{
int
d3dSemantic
=
locationToSemantic
[
locationIndex
]
;
if
(
sortedAttributesOut
-
>
size
(
)
<
=
static_cast
<
size_t
>
(
d3dSemantic
)
)
{
sortedAttributesOut
-
>
resize
(
d3dSemantic
+
1
)
;
}
(
*
sortedD3DSemanticsOut
)
[
d3dSemantic
]
=
d3dSemantic
;
const
auto
*
arrayAttrib
=
&
vertexArrayAttribs
[
locationIndex
]
;
if
(
arrayAttrib
-
>
attribute
&
&
arrayAttrib
-
>
attribute
-
>
enabled
)
{
(
*
sortedAttributesOut
)
[
d3dSemantic
]
=
arrayAttrib
;
}
else
{
ASSERT
(
currentValueAttribs
[
locationIndex
]
.
attribute
)
;
(
*
sortedAttributesOut
)
[
d3dSemantic
]
=
&
currentValueAttribs
[
locationIndex
]
;
}
}
}
void
UpdateUniformBuffer
(
ID3D11DeviceContext
*
deviceContext
UniformStorage11
*
storage
const
d3d11
:
:
Buffer
*
buffer
)
{
deviceContext
-
>
UpdateSubresource
(
buffer
-
>
get
(
)
0
nullptr
storage
-
>
getDataPointer
(
0
0
)
0
0
)
;
}
size_t
GetReservedBufferCount
(
bool
usesPointSpriteEmulation
)
{
return
usesPointSpriteEmulation
?
1
:
0
;
}
bool
CullsEverything
(
const
gl
:
:
State
&
glState
)
{
return
(
glState
.
getRasterizerState
(
)
.
cullFace
&
&
glState
.
getRasterizerState
(
)
.
cullMode
=
=
gl
:
:
CullFaceMode
:
:
FrontAndBack
)
;
}
}
template
<
typename
ViewType
typename
DescType
>
StateManager11
:
:
ViewCache
<
ViewType
DescType
>
:
:
ViewCache
(
)
:
mHighestUsedView
(
0
)
{
}
template
<
typename
ViewType
typename
DescType
>
StateManager11
:
:
ViewCache
<
ViewType
DescType
>
:
:
~
ViewCache
(
)
{
}
template
<
typename
ViewType
typename
DescType
>
void
StateManager11
:
:
ViewCache
<
ViewType
DescType
>
:
:
update
(
size_t
resourceIndex
ViewType
*
view
)
{
ASSERT
(
resourceIndex
<
mCurrentViews
.
size
(
)
)
;
ViewRecord
<
DescType
>
*
record
=
&
mCurrentViews
[
resourceIndex
]
;
record
-
>
view
=
reinterpret_cast
<
uintptr_t
>
(
view
)
;
if
(
view
)
{
record
-
>
resource
=
reinterpret_cast
<
uintptr_t
>
(
GetViewResource
(
view
)
)
;
view
-
>
GetDesc
(
&
record
-
>
desc
)
;
mHighestUsedView
=
std
:
:
max
(
resourceIndex
+
1
mHighestUsedView
)
;
}
else
{
record
-
>
resource
=
0
;
if
(
resourceIndex
+
1
=
=
mHighestUsedView
)
{
do
{
-
-
mHighestUsedView
;
}
while
(
mHighestUsedView
>
0
&
&
mCurrentViews
[
mHighestUsedView
]
.
view
=
=
0
)
;
}
}
}
template
<
typename
ViewType
typename
DescType
>
void
StateManager11
:
:
ViewCache
<
ViewType
DescType
>
:
:
clear
(
)
{
if
(
mCurrentViews
.
empty
(
)
)
{
return
;
}
memset
(
&
mCurrentViews
[
0
]
0
sizeof
(
ViewRecord
<
DescType
>
)
*
mCurrentViews
.
size
(
)
)
;
mHighestUsedView
=
0
;
}
StateManager11
:
:
SRVCache
*
StateManager11
:
:
getSRVCache
(
gl
:
:
ShaderType
shaderType
)
{
ASSERT
(
shaderType
!
=
gl
:
:
ShaderType
:
:
InvalidEnum
)
;
return
&
mCurShaderSRVs
[
shaderType
]
;
}
ShaderConstants11
:
:
ShaderConstants11
(
)
:
mNumActiveShaderSamplers
(
{
}
)
{
mShaderConstantsDirty
.
set
(
)
;
}
ShaderConstants11
:
:
~
ShaderConstants11
(
)
{
}
void
ShaderConstants11
:
:
init
(
const
gl
:
:
Caps
&
caps
)
{
for
(
gl
:
:
ShaderType
shaderType
:
gl
:
:
AllShaderTypes
(
)
)
{
mShaderSamplerMetadata
[
shaderType
]
.
resize
(
caps
.
maxShaderTextureImageUnits
[
shaderType
]
)
;
}
}
size_t
ShaderConstants11
:
:
GetShaderConstantsStructSize
(
gl
:
:
ShaderType
shaderType
)
{
switch
(
shaderType
)
{
case
gl
:
:
ShaderType
:
:
Vertex
:
return
sizeof
(
Vertex
)
;
case
gl
:
:
ShaderType
:
:
Fragment
:
return
sizeof
(
Pixel
)
;
case
gl
:
:
ShaderType
:
:
Compute
:
return
sizeof
(
Compute
)
;
case
gl
:
:
ShaderType
:
:
Geometry
:
return
0u
;
default
:
UNREACHABLE
(
)
;
return
0u
;
}
}
size_t
ShaderConstants11
:
:
getRequiredBufferSize
(
gl
:
:
ShaderType
shaderType
)
const
{
ASSERT
(
shaderType
!
=
gl
:
:
ShaderType
:
:
InvalidEnum
)
;
return
GetShaderConstantsStructSize
(
shaderType
)
+
mShaderSamplerMetadata
[
shaderType
]
.
size
(
)
*
sizeof
(
SamplerMetadata
)
;
}
void
ShaderConstants11
:
:
markDirty
(
)
{
mShaderConstantsDirty
.
set
(
)
;
mNumActiveShaderSamplers
.
fill
(
0
)
;
}
bool
ShaderConstants11
:
:
updateSamplerMetadata
(
SamplerMetadata
*
data
const
gl
:
:
Texture
&
texture
)
{
bool
dirty
=
false
;
unsigned
int
baseLevel
=
texture
.
getTextureState
(
)
.
getEffectiveBaseLevel
(
)
;
gl
:
:
TextureTarget
target
=
(
texture
.
getType
(
)
=
=
gl
:
:
TextureType
:
:
CubeMap
)
?
gl
:
:
kCubeMapTextureTargetMin
:
gl
:
:
NonCubeTextureTypeToTarget
(
texture
.
getType
(
)
)
;
GLenum
sizedFormat
=
texture
.
getFormat
(
target
baseLevel
)
.
info
-
>
sizedInternalFormat
;
if
(
data
-
>
baseLevel
!
=
static_cast
<
int
>
(
baseLevel
)
)
{
data
-
>
baseLevel
=
static_cast
<
int
>
(
baseLevel
)
;
dirty
=
true
;
}
bool
needIntegerTextureMetadata
=
false
;
int
internalFormatBits
=
0
;
switch
(
sizedFormat
)
{
case
GL_RGBA32I
:
case
GL_RGBA32UI
:
case
GL_RGB32I
:
case
GL_RGB32UI
:
case
GL_RG32I
:
case
GL_RG32UI
:
case
GL_R32I
:
case
GL_R32UI
:
needIntegerTextureMetadata
=
true
;
break
;
case
GL_RGBA16I
:
case
GL_RGBA16UI
:
case
GL_RGB16I
:
case
GL_RGB16UI
:
case
GL_RG16I
:
case
GL_RG16UI
:
case
GL_R16I
:
case
GL_R16UI
:
needIntegerTextureMetadata
=
true
;
internalFormatBits
=
16
;
break
;
case
GL_RGBA8I
:
case
GL_RGBA8UI
:
case
GL_RGB8I
:
case
GL_RGB8UI
:
case
GL_RG8I
:
case
GL_RG8UI
:
case
GL_R8I
:
case
GL_R8UI
:
needIntegerTextureMetadata
=
true
;
internalFormatBits
=
8
;
break
;
case
GL_RGB10_A2UI
:
needIntegerTextureMetadata
=
true
;
internalFormatBits
=
10
;
break
;
default
:
break
;
}
if
(
needIntegerTextureMetadata
)
{
if
(
data
-
>
internalFormatBits
!
=
internalFormatBits
)
{
data
-
>
internalFormatBits
=
internalFormatBits
;
dirty
=
true
;
}
GLenum
wrapS
=
texture
.
getWrapS
(
)
;
GLenum
wrapT
=
texture
.
getWrapT
(
)
;
GLenum
wrapR
=
texture
.
getWrapR
(
)
;
int
wrapModes
=
GetWrapBits
(
wrapS
)
|
(
GetWrapBits
(
wrapT
)
<
<
2
)
|
(
GetWrapBits
(
wrapR
)
<
<
4
)
;
if
(
data
-
>
wrapModes
!
=
wrapModes
)
{
data
-
>
wrapModes
=
wrapModes
;
dirty
=
true
;
}
}
return
dirty
;
}
void
ShaderConstants11
:
:
setComputeWorkGroups
(
GLuint
numGroupsX
GLuint
numGroupsY
GLuint
numGroupsZ
)
{
mCompute
.
numWorkGroups
[
0
]
=
numGroupsX
;
mCompute
.
numWorkGroups
[
1
]
=
numGroupsY
;
mCompute
.
numWorkGroups
[
2
]
=
numGroupsZ
;
mShaderConstantsDirty
.
set
(
gl
:
:
ShaderType
:
:
Compute
)
;
}
void
ShaderConstants11
:
:
setMultiviewWriteToViewportIndex
(
GLfloat
index
)
{
mVertex
.
multiviewWriteToViewportIndex
=
index
;
mPixel
.
multiviewWriteToViewportIndex
=
index
;
mShaderConstantsDirty
.
set
(
gl
:
:
ShaderType
:
:
Vertex
)
;
mShaderConstantsDirty
.
set
(
gl
:
:
ShaderType
:
:
Fragment
)
;
}
void
ShaderConstants11
:
:
onViewportChange
(
const
gl
:
:
Rectangle
&
glViewport
const
D3D11_VIEWPORT
&
dxViewport
bool
is9_3
bool
presentPathFast
)
{
mShaderConstantsDirty
.
set
(
gl
:
:
ShaderType
:
:
Vertex
)
;
mShaderConstantsDirty
.
set
(
gl
:
:
ShaderType
:
:
Fragment
)
;
if
(
is9_3
)
{
mVertex
.
viewAdjust
[
0
]
=
static_cast
<
float
>
(
(
glViewport
.
width
-
dxViewport
.
Width
)
+
2
*
(
glViewport
.
x
-
dxViewport
.
TopLeftX
)
)
/
dxViewport
.
Width
;
mVertex
.
viewAdjust
[
1
]
=
static_cast
<
float
>
(
(
glViewport
.
height
-
dxViewport
.
Height
)
+
2
*
(
glViewport
.
y
-
dxViewport
.
TopLeftY
)
)
/
dxViewport
.
Height
;
mVertex
.
viewAdjust
[
2
]
=
static_cast
<
float
>
(
glViewport
.
width
)
/
dxViewport
.
Width
;
mVertex
.
viewAdjust
[
3
]
=
static_cast
<
float
>
(
glViewport
.
height
)
/
dxViewport
.
Height
;
}
mPixel
.
viewCoords
[
0
]
=
glViewport
.
width
*
0
.
5f
;
mPixel
.
viewCoords
[
1
]
=
glViewport
.
height
*
0
.
5f
;
mPixel
.
viewCoords
[
2
]
=
glViewport
.
x
+
(
glViewport
.
width
*
0
.
5f
)
;
mPixel
.
viewCoords
[
3
]
=
glViewport
.
y
+
(
glViewport
.
height
*
0
.
5f
)
;
mVertex
.
viewCoords
[
0
]
=
mPixel
.
viewCoords
[
0
]
;
mVertex
.
viewCoords
[
1
]
=
mPixel
.
viewCoords
[
1
]
;
mVertex
.
viewCoords
[
2
]
=
mPixel
.
viewCoords
[
2
]
;
mVertex
.
viewCoords
[
3
]
=
mPixel
.
viewCoords
[
3
]
;
const
float
zNear
=
dxViewport
.
MinDepth
;
const
float
zFar
=
dxViewport
.
MaxDepth
;
mPixel
.
depthFront
[
0
]
=
(
zFar
-
zNear
)
*
0
.
5f
;
mPixel
.
depthFront
[
1
]
=
(
zNear
+
zFar
)
*
0
.
5f
;
mVertex
.
depthRange
[
0
]
=
zNear
;
mVertex
.
depthRange
[
1
]
=
zFar
;
mVertex
.
depthRange
[
2
]
=
zFar
-
zNear
;
mPixel
.
depthRange
[
0
]
=
zNear
;
mPixel
.
depthRange
[
1
]
=
zFar
;
mPixel
.
depthRange
[
2
]
=
zFar
-
zNear
;
mPixel
.
viewScale
[
0
]
=
1
.
0f
;
mPixel
.
viewScale
[
1
]
=
presentPathFast
?
1
.
0f
:
-
1
.
0f
;
mVertex
.
viewScale
[
0
]
=
mPixel
.
viewScale
[
0
]
;
mVertex
.
viewScale
[
1
]
=
mPixel
.
viewScale
[
1
]
;
}
void
ShaderConstants11
:
:
onSamplerChange
(
gl
:
:
ShaderType
shaderType
unsigned
int
samplerIndex
const
gl
:
:
Texture
&
texture
)
{
ASSERT
(
shaderType
!
=
gl
:
:
ShaderType
:
:
InvalidEnum
)
;
if
(
updateSamplerMetadata
(
&
mShaderSamplerMetadata
[
shaderType
]
[
samplerIndex
]
texture
)
)
{
mNumActiveShaderSamplers
[
shaderType
]
=
0
;
}
}
angle
:
:
Result
ShaderConstants11
:
:
updateBuffer
(
const
gl
:
:
Context
*
context
Renderer11
*
renderer
gl
:
:
ShaderType
shaderType
const
ProgramD3D
&
programD3D
const
d3d11
:
:
Buffer
&
driverConstantBuffer
)
{
const
int
numSamplers
=
programD3D
.
getUsedSamplerRange
(
shaderType
)
.
length
(
)
;
const
bool
dirty
=
mShaderConstantsDirty
[
shaderType
]
|
|
(
mNumActiveShaderSamplers
[
shaderType
]
<
numSamplers
)
;
const
size_t
dataSize
=
GetShaderConstantsStructSize
(
shaderType
)
;
const
uint8_t
*
samplerData
=
reinterpret_cast
<
const
uint8_t
*
>
(
mShaderSamplerMetadata
[
shaderType
]
.
data
(
)
)
;
mNumActiveShaderSamplers
[
shaderType
]
=
numSamplers
;
mShaderConstantsDirty
.
set
(
shaderType
false
)
;
const
uint8_t
*
data
=
nullptr
;
switch
(
shaderType
)
{
case
gl
:
:
ShaderType
:
:
Vertex
:
data
=
reinterpret_cast
<
const
uint8_t
*
>
(
&
mVertex
)
;
break
;
case
gl
:
:
ShaderType
:
:
Fragment
:
data
=
reinterpret_cast
<
const
uint8_t
*
>
(
&
mPixel
)
;
break
;
case
gl
:
:
ShaderType
:
:
Compute
:
data
=
reinterpret_cast
<
const
uint8_t
*
>
(
&
mCompute
)
;
break
;
default
:
UNREACHABLE
(
)
;
break
;
}
ASSERT
(
driverConstantBuffer
.
valid
(
)
)
;
if
(
!
dirty
)
{
return
angle
:
:
Result
:
:
Continue
(
)
;
}
D3D11_MAPPED_SUBRESOURCE
mapping
=
{
0
}
;
ANGLE_TRY
(
renderer
-
>
mapResource
(
context
driverConstantBuffer
.
get
(
)
0
D3D11_MAP_WRITE_DISCARD
0
&
mapping
)
)
;
memcpy
(
mapping
.
pData
data
dataSize
)
;
memcpy
(
static_cast
<
uint8_t
*
>
(
mapping
.
pData
)
+
dataSize
samplerData
sizeof
(
SamplerMetadata
)
*
numSamplers
)
;
renderer
-
>
getDeviceContext
(
)
-
>
Unmap
(
driverConstantBuffer
.
get
(
)
0
)
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
StateManager11
:
:
StateManager11
(
Renderer11
*
renderer
)
:
mRenderer
(
renderer
)
mInternalDirtyBits
(
)
mCurBlendColor
(
0
0
0
0
)
mCurSampleMask
(
0
)
mCurStencilRef
(
0
)
mCurStencilBackRef
(
0
)
mCurStencilSize
(
0
)
mCurScissorEnabled
(
false
)
mCurScissorRect
(
)
mCurViewport
(
)
mCurNear
(
0
.
0f
)
mCurFar
(
0
.
0f
)
mViewportBounds
(
)
mRenderTargetIsDirty
(
true
)
mCurPresentPathFastEnabled
(
false
)
mCurPresentPathFastColorBufferHeight
(
0
)
mDirtyCurrentValueAttribs
(
)
mCurrentValueAttribs
(
)
mCurrentInputLayout
(
)
mDirtyVertexBufferRange
(
gl
:
:
MAX_VERTEX_ATTRIBS
0
)
mCurrentPrimitiveTopology
(
D3D_PRIMITIVE_TOPOLOGY_UNDEFINED
)
mLastAppliedDrawMode
(
gl
:
:
PrimitiveMode
:
:
InvalidEnum
)
mCullEverything
(
false
)
mDirtySwizzles
(
false
)
mAppliedIB
(
nullptr
)
mAppliedIBFormat
(
DXGI_FORMAT_UNKNOWN
)
mAppliedIBOffset
(
0
)
mIndexBufferIsDirty
(
false
)
mVertexDataManager
(
renderer
)
mIndexDataManager
(
renderer
)
mIsMultiviewEnabled
(
false
)
mEmptySerial
(
mRenderer
-
>
generateSerial
(
)
)
mProgramD3D
(
nullptr
)
mVertexArray11
(
nullptr
)
mFramebuffer11
(
nullptr
)
{
mCurBlendState
.
blend
=
false
;
mCurBlendState
.
sourceBlendRGB
=
GL_ONE
;
mCurBlendState
.
destBlendRGB
=
GL_ZERO
;
mCurBlendState
.
sourceBlendAlpha
=
GL_ONE
;
mCurBlendState
.
destBlendAlpha
=
GL_ZERO
;
mCurBlendState
.
blendEquationRGB
=
GL_FUNC_ADD
;
mCurBlendState
.
blendEquationAlpha
=
GL_FUNC_ADD
;
mCurBlendState
.
colorMaskRed
=
true
;
mCurBlendState
.
colorMaskBlue
=
true
;
mCurBlendState
.
colorMaskGreen
=
true
;
mCurBlendState
.
colorMaskAlpha
=
true
;
mCurBlendState
.
sampleAlphaToCoverage
=
false
;
mCurBlendState
.
dither
=
false
;
mCurDepthStencilState
.
depthTest
=
false
;
mCurDepthStencilState
.
depthFunc
=
GL_LESS
;
mCurDepthStencilState
.
depthMask
=
true
;
mCurDepthStencilState
.
stencilTest
=
false
;
mCurDepthStencilState
.
stencilMask
=
true
;
mCurDepthStencilState
.
stencilFail
=
GL_KEEP
;
mCurDepthStencilState
.
stencilPassDepthFail
=
GL_KEEP
;
mCurDepthStencilState
.
stencilPassDepthPass
=
GL_KEEP
;
mCurDepthStencilState
.
stencilWritemask
=
static_cast
<
GLuint
>
(
-
1
)
;
mCurDepthStencilState
.
stencilBackFunc
=
GL_ALWAYS
;
mCurDepthStencilState
.
stencilBackMask
=
static_cast
<
GLuint
>
(
-
1
)
;
mCurDepthStencilState
.
stencilBackFail
=
GL_KEEP
;
mCurDepthStencilState
.
stencilBackPassDepthFail
=
GL_KEEP
;
mCurDepthStencilState
.
stencilBackPassDepthPass
=
GL_KEEP
;
mCurDepthStencilState
.
stencilBackWritemask
=
static_cast
<
GLuint
>
(
-
1
)
;
mCurRasterState
.
rasterizerDiscard
=
false
;
mCurRasterState
.
cullFace
=
false
;
mCurRasterState
.
cullMode
=
gl
:
:
CullFaceMode
:
:
Back
;
mCurRasterState
.
frontFace
=
GL_CCW
;
mCurRasterState
.
polygonOffsetFill
=
false
;
mCurRasterState
.
polygonOffsetFactor
=
0
.
0f
;
mCurRasterState
.
polygonOffsetUnits
=
0
.
0f
;
mCurRasterState
.
pointDrawMode
=
false
;
mCurRasterState
.
multiSample
=
false
;
mInternalDirtyBits
.
set
(
)
;
mDirtyCurrentValueAttribs
.
set
(
)
;
mCurrentVertexBuffers
.
fill
(
nullptr
)
;
mCurrentVertexStrides
.
fill
(
std
:
:
numeric_limits
<
UINT
>
:
:
max
(
)
)
;
mCurrentVertexOffsets
.
fill
(
std
:
:
numeric_limits
<
UINT
>
:
:
max
(
)
)
;
}
StateManager11
:
:
~
StateManager11
(
)
{
}
template
<
typename
SRVType
>
void
StateManager11
:
:
setShaderResourceInternal
(
gl
:
:
ShaderType
shaderType
UINT
resourceSlot
const
SRVType
*
srv
)
{
auto
*
currentSRVs
=
getSRVCache
(
shaderType
)
;
ASSERT
(
static_cast
<
size_t
>
(
resourceSlot
)
<
currentSRVs
-
>
size
(
)
)
;
const
ViewRecord
<
D3D11_SHADER_RESOURCE_VIEW_DESC
>
&
record
=
(
*
currentSRVs
)
[
resourceSlot
]
;
if
(
record
.
view
!
=
reinterpret_cast
<
uintptr_t
>
(
srv
)
)
{
ID3D11DeviceContext
*
deviceContext
=
mRenderer
-
>
getDeviceContext
(
)
;
ID3D11ShaderResourceView
*
srvPtr
=
srv
?
srv
-
>
get
(
)
:
nullptr
;
switch
(
shaderType
)
{
case
gl
:
:
ShaderType
:
:
Vertex
:
deviceContext
-
>
VSSetShaderResources
(
resourceSlot
1
&
srvPtr
)
;
break
;
case
gl
:
:
ShaderType
:
:
Fragment
:
deviceContext
-
>
PSSetShaderResources
(
resourceSlot
1
&
srvPtr
)
;
break
;
case
gl
:
:
ShaderType
:
:
Compute
:
deviceContext
-
>
CSSetShaderResources
(
resourceSlot
1
&
srvPtr
)
;
break
;
default
:
UNREACHABLE
(
)
;
}
currentSRVs
-
>
update
(
resourceSlot
srvPtr
)
;
}
}
template
<
typename
UAVType
>
void
StateManager11
:
:
setUnorderedAccessViewInternal
(
gl
:
:
ShaderType
shaderType
UINT
resourceSlot
const
UAVType
*
uav
)
{
ASSERT
(
shaderType
=
=
gl
:
:
ShaderType
:
:
Compute
)
;
ASSERT
(
static_cast
<
size_t
>
(
resourceSlot
)
<
mCurComputeUAVs
.
size
(
)
)
;
const
ViewRecord
<
D3D11_UNORDERED_ACCESS_VIEW_DESC
>
&
record
=
mCurComputeUAVs
[
resourceSlot
]
;
if
(
record
.
view
!
=
reinterpret_cast
<
uintptr_t
>
(
uav
)
)
{
auto
deviceContext
=
mRenderer
-
>
getDeviceContext
(
)
;
ID3D11UnorderedAccessView
*
uavPtr
=
uav
?
uav
-
>
get
(
)
:
nullptr
;
deviceContext
-
>
CSSetUnorderedAccessViews
(
resourceSlot
1
&
uavPtr
nullptr
)
;
mCurComputeUAVs
.
update
(
resourceSlot
uavPtr
)
;
}
}
void
StateManager11
:
:
updateStencilSizeIfChanged
(
bool
depthStencilInitialized
unsigned
int
stencilSize
)
{
if
(
!
depthStencilInitialized
|
|
stencilSize
!
=
mCurStencilSize
)
{
mCurStencilSize
=
stencilSize
;
mInternalDirtyBits
.
set
(
DIRTY_BIT_DEPTH_STENCIL_STATE
)
;
}
}
void
StateManager11
:
:
checkPresentPath
(
const
gl
:
:
Context
*
context
)
{
if
(
!
mRenderer
-
>
presentPathFastEnabled
(
)
)
return
;
const
auto
*
framebuffer
=
context
-
>
getGLState
(
)
.
getDrawFramebuffer
(
)
;
const
auto
*
firstColorAttachment
=
framebuffer
-
>
getFirstColorbuffer
(
)
;
const
bool
presentPathFastActive
=
UsePresentPathFast
(
mRenderer
firstColorAttachment
)
;
const
int
colorBufferHeight
=
firstColorAttachment
?
firstColorAttachment
-
>
getSize
(
)
.
height
:
0
;
if
(
(
mCurPresentPathFastEnabled
!
=
presentPathFastActive
)
|
|
(
presentPathFastActive
&
&
(
colorBufferHeight
!
=
mCurPresentPathFastColorBufferHeight
)
)
)
{
mCurPresentPathFastEnabled
=
presentPathFastActive
;
mCurPresentPathFastColorBufferHeight
=
colorBufferHeight
;
mInternalDirtyBits
.
set
(
DIRTY_BIT_SCISSOR_STATE
)
;
mInternalDirtyBits
.
set
(
DIRTY_BIT_RASTERIZER_STATE
)
;
invalidateViewport
(
context
)
;
}
}
angle
:
:
Result
StateManager11
:
:
updateStateForCompute
(
const
gl
:
:
Context
*
context
GLuint
numGroupsX
GLuint
numGroupsY
GLuint
numGroupsZ
)
{
mShaderConstants
.
setComputeWorkGroups
(
numGroupsX
numGroupsY
numGroupsZ
)
;
mProgramD3D
-
>
updateSamplerMapping
(
)
;
ANGLE_TRY
(
generateSwizzlesForShader
(
context
gl
:
:
ShaderType
:
:
Compute
)
)
;
ANGLE_TRY
(
syncTexturesForCompute
(
context
)
)
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
void
StateManager11
:
:
syncState
(
const
gl
:
:
Context
*
context
const
gl
:
:
State
:
:
DirtyBits
&
dirtyBits
)
{
if
(
!
dirtyBits
.
any
(
)
)
{
return
;
}
const
gl
:
:
State
&
state
=
context
-
>
getGLState
(
)
;
for
(
size_t
dirtyBit
:
dirtyBits
)
{
switch
(
dirtyBit
)
{
case
gl
:
:
State
:
:
DIRTY_BIT_BLEND_EQUATIONS
:
{
const
gl
:
:
BlendState
&
blendState
=
state
.
getBlendState
(
)
;
if
(
blendState
.
blendEquationRGB
!
=
mCurBlendState
.
blendEquationRGB
|
|
blendState
.
blendEquationAlpha
!
=
mCurBlendState
.
blendEquationAlpha
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_BLEND_STATE
)
;
}
break
;
}
case
gl
:
:
State
:
:
DIRTY_BIT_BLEND_FUNCS
:
{
const
gl
:
:
BlendState
&
blendState
=
state
.
getBlendState
(
)
;
if
(
blendState
.
sourceBlendRGB
!
=
mCurBlendState
.
sourceBlendRGB
|
|
blendState
.
destBlendRGB
!
=
mCurBlendState
.
destBlendRGB
|
|
blendState
.
sourceBlendAlpha
!
=
mCurBlendState
.
sourceBlendAlpha
|
|
blendState
.
destBlendAlpha
!
=
mCurBlendState
.
destBlendAlpha
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_BLEND_STATE
)
;
}
break
;
}
case
gl
:
:
State
:
:
DIRTY_BIT_BLEND_ENABLED
:
if
(
state
.
getBlendState
(
)
.
blend
!
=
mCurBlendState
.
blend
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_BLEND_STATE
)
;
}
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_SAMPLE_ALPHA_TO_COVERAGE_ENABLED
:
if
(
state
.
getBlendState
(
)
.
sampleAlphaToCoverage
!
=
mCurBlendState
.
sampleAlphaToCoverage
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_BLEND_STATE
)
;
}
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_DITHER_ENABLED
:
if
(
state
.
getBlendState
(
)
.
dither
!
=
mCurBlendState
.
dither
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_BLEND_STATE
)
;
}
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_COLOR_MASK
:
{
const
gl
:
:
BlendState
&
blendState
=
state
.
getBlendState
(
)
;
if
(
blendState
.
colorMaskRed
!
=
mCurBlendState
.
colorMaskRed
|
|
blendState
.
colorMaskGreen
!
=
mCurBlendState
.
colorMaskGreen
|
|
blendState
.
colorMaskBlue
!
=
mCurBlendState
.
colorMaskBlue
|
|
blendState
.
colorMaskAlpha
!
=
mCurBlendState
.
colorMaskAlpha
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_BLEND_STATE
)
;
}
break
;
}
case
gl
:
:
State
:
:
DIRTY_BIT_BLEND_COLOR
:
if
(
state
.
getBlendColor
(
)
!
=
mCurBlendColor
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_BLEND_STATE
)
;
}
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_DEPTH_MASK
:
if
(
state
.
getDepthStencilState
(
)
.
depthMask
!
=
mCurDepthStencilState
.
depthMask
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_DEPTH_STENCIL_STATE
)
;
}
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_DEPTH_TEST_ENABLED
:
if
(
state
.
getDepthStencilState
(
)
.
depthTest
!
=
mCurDepthStencilState
.
depthTest
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_DEPTH_STENCIL_STATE
)
;
}
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_DEPTH_FUNC
:
if
(
state
.
getDepthStencilState
(
)
.
depthFunc
!
=
mCurDepthStencilState
.
depthFunc
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_DEPTH_STENCIL_STATE
)
;
}
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_STENCIL_TEST_ENABLED
:
if
(
state
.
getDepthStencilState
(
)
.
stencilTest
!
=
mCurDepthStencilState
.
stencilTest
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_DEPTH_STENCIL_STATE
)
;
}
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_STENCIL_FUNCS_FRONT
:
{
const
gl
:
:
DepthStencilState
&
depthStencil
=
state
.
getDepthStencilState
(
)
;
if
(
depthStencil
.
stencilFunc
!
=
mCurDepthStencilState
.
stencilFunc
|
|
depthStencil
.
stencilMask
!
=
mCurDepthStencilState
.
stencilMask
|
|
state
.
getStencilRef
(
)
!
=
mCurStencilRef
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_DEPTH_STENCIL_STATE
)
;
}
break
;
}
case
gl
:
:
State
:
:
DIRTY_BIT_STENCIL_FUNCS_BACK
:
{
const
gl
:
:
DepthStencilState
&
depthStencil
=
state
.
getDepthStencilState
(
)
;
if
(
depthStencil
.
stencilBackFunc
!
=
mCurDepthStencilState
.
stencilBackFunc
|
|
depthStencil
.
stencilBackMask
!
=
mCurDepthStencilState
.
stencilBackMask
|
|
state
.
getStencilBackRef
(
)
!
=
mCurStencilBackRef
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_DEPTH_STENCIL_STATE
)
;
}
break
;
}
case
gl
:
:
State
:
:
DIRTY_BIT_STENCIL_WRITEMASK_FRONT
:
if
(
state
.
getDepthStencilState
(
)
.
stencilWritemask
!
=
mCurDepthStencilState
.
stencilWritemask
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_DEPTH_STENCIL_STATE
)
;
}
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_STENCIL_WRITEMASK_BACK
:
if
(
state
.
getDepthStencilState
(
)
.
stencilBackWritemask
!
=
mCurDepthStencilState
.
stencilBackWritemask
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_DEPTH_STENCIL_STATE
)
;
}
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_STENCIL_OPS_FRONT
:
{
const
gl
:
:
DepthStencilState
&
depthStencil
=
state
.
getDepthStencilState
(
)
;
if
(
depthStencil
.
stencilFail
!
=
mCurDepthStencilState
.
stencilFail
|
|
depthStencil
.
stencilPassDepthFail
!
=
mCurDepthStencilState
.
stencilPassDepthFail
|
|
depthStencil
.
stencilPassDepthPass
!
=
mCurDepthStencilState
.
stencilPassDepthPass
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_DEPTH_STENCIL_STATE
)
;
}
break
;
}
case
gl
:
:
State
:
:
DIRTY_BIT_STENCIL_OPS_BACK
:
{
const
gl
:
:
DepthStencilState
&
depthStencil
=
state
.
getDepthStencilState
(
)
;
if
(
depthStencil
.
stencilBackFail
!
=
mCurDepthStencilState
.
stencilBackFail
|
|
depthStencil
.
stencilBackPassDepthFail
!
=
mCurDepthStencilState
.
stencilBackPassDepthFail
|
|
depthStencil
.
stencilBackPassDepthPass
!
=
mCurDepthStencilState
.
stencilBackPassDepthPass
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_DEPTH_STENCIL_STATE
)
;
}
break
;
}
case
gl
:
:
State
:
:
DIRTY_BIT_CULL_FACE_ENABLED
:
if
(
state
.
getRasterizerState
(
)
.
cullFace
!
=
mCurRasterState
.
cullFace
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_RASTERIZER_STATE
)
;
mInternalDirtyBits
.
set
(
DIRTY_BIT_PRIMITIVE_TOPOLOGY
)
;
}
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_CULL_FACE
:
if
(
state
.
getRasterizerState
(
)
.
cullMode
!
=
mCurRasterState
.
cullMode
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_RASTERIZER_STATE
)
;
mInternalDirtyBits
.
set
(
DIRTY_BIT_PRIMITIVE_TOPOLOGY
)
;
}
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_FRONT_FACE
:
if
(
state
.
getRasterizerState
(
)
.
frontFace
!
=
mCurRasterState
.
frontFace
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_RASTERIZER_STATE
)
;
mInternalDirtyBits
.
set
(
DIRTY_BIT_PRIMITIVE_TOPOLOGY
)
;
}
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_POLYGON_OFFSET_FILL_ENABLED
:
if
(
state
.
getRasterizerState
(
)
.
polygonOffsetFill
!
=
mCurRasterState
.
polygonOffsetFill
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_RASTERIZER_STATE
)
;
}
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_POLYGON_OFFSET
:
{
const
gl
:
:
RasterizerState
&
rasterState
=
state
.
getRasterizerState
(
)
;
if
(
rasterState
.
polygonOffsetFactor
!
=
mCurRasterState
.
polygonOffsetFactor
|
|
rasterState
.
polygonOffsetUnits
!
=
mCurRasterState
.
polygonOffsetUnits
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_RASTERIZER_STATE
)
;
}
break
;
}
case
gl
:
:
State
:
:
DIRTY_BIT_RASTERIZER_DISCARD_ENABLED
:
if
(
state
.
getRasterizerState
(
)
.
rasterizerDiscard
!
=
mCurRasterState
.
rasterizerDiscard
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_RASTERIZER_STATE
)
;
invalidateShaders
(
)
;
}
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_SCISSOR
:
if
(
state
.
getScissor
(
)
!
=
mCurScissorRect
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_SCISSOR_STATE
)
;
}
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_SCISSOR_TEST_ENABLED
:
if
(
state
.
isScissorTestEnabled
(
)
!
=
mCurScissorEnabled
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_SCISSOR_STATE
)
;
mInternalDirtyBits
.
set
(
DIRTY_BIT_RASTERIZER_STATE
)
;
}
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_DEPTH_RANGE
:
if
(
state
.
getNearPlane
(
)
!
=
mCurNear
|
|
state
.
getFarPlane
(
)
!
=
mCurFar
)
{
invalidateViewport
(
context
)
;
}
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_VIEWPORT
:
if
(
state
.
getViewport
(
)
!
=
mCurViewport
)
{
invalidateViewport
(
context
)
;
}
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_DRAW_FRAMEBUFFER_BINDING
:
invalidateRenderTarget
(
)
;
if
(
mIsMultiviewEnabled
)
{
handleMultiviewDrawFramebufferChange
(
context
)
;
}
mFramebuffer11
=
GetImplAs
<
Framebuffer11
>
(
state
.
getDrawFramebuffer
(
)
)
;
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_VERTEX_ARRAY_BINDING
:
invalidateVertexBuffer
(
)
;
mDirtyCurrentValueAttribs
.
set
(
)
;
invalidateIndexBuffer
(
)
;
mVertexArray11
=
GetImplAs
<
VertexArray11
>
(
state
.
getVertexArray
(
)
)
;
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_UNIFORM_BUFFER_BINDINGS
:
invalidateProgramUniformBuffers
(
)
;
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_TEXTURE_BINDINGS
:
invalidateTexturesAndSamplers
(
)
;
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_SAMPLER_BINDINGS
:
invalidateTexturesAndSamplers
(
)
;
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_TRANSFORM_FEEDBACK_BINDING
:
invalidateTransformFeedback
(
)
;
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_PROGRAM_BINDING
:
mProgramD3D
=
GetImplAs
<
ProgramD3D
>
(
state
.
getProgram
(
)
)
;
break
;
case
gl
:
:
State
:
:
DIRTY_BIT_PROGRAM_EXECUTABLE
:
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_PRIMITIVE_TOPOLOGY
)
;
invalidateShaders
(
)
;
invalidateVertexBuffer
(
)
;
invalidateRenderTarget
(
)
;
invalidateTexturesAndSamplers
(
)
;
invalidateProgramUniforms
(
)
;
invalidateProgramUniformBuffers
(
)
;
invalidateDriverUniforms
(
)
;
if
(
mIsMultiviewEnabled
&
&
mVertexArray11
)
{
ASSERT
(
mProgramD3D
)
;
const
gl
:
:
ProgramState
&
programState
=
mProgramD3D
-
>
getState
(
)
;
int
numViews
=
programState
.
usesMultiview
(
)
?
programState
.
getNumViews
(
)
:
1
;
mVertexArray11
-
>
markAllAttributeDivisorsForAdjustment
(
numViews
)
;
}
break
;
}
case
gl
:
:
State
:
:
DIRTY_BIT_CURRENT_VALUES
:
{
for
(
auto
attribIndex
:
state
.
getAndResetDirtyCurrentValues
(
)
)
{
invalidateCurrentValueAttrib
(
attribIndex
)
;
}
break
;
}
default
:
break
;
}
}
}
void
StateManager11
:
:
handleMultiviewDrawFramebufferChange
(
const
gl
:
:
Context
*
context
)
{
const
auto
&
glState
=
context
-
>
getGLState
(
)
;
const
gl
:
:
Framebuffer
*
drawFramebuffer
=
glState
.
getDrawFramebuffer
(
)
;
ASSERT
(
drawFramebuffer
!
=
nullptr
)
;
const
std
:
:
vector
<
gl
:
:
Offset
>
*
attachmentViewportOffsets
=
drawFramebuffer
-
>
getViewportOffsets
(
)
;
const
std
:
:
vector
<
gl
:
:
Offset
>
&
viewportOffsets
=
attachmentViewportOffsets
!
=
nullptr
?
*
attachmentViewportOffsets
:
gl
:
:
FramebufferAttachment
:
:
GetDefaultViewportOffsetVector
(
)
;
if
(
mViewportOffsets
!
=
viewportOffsets
)
{
mViewportOffsets
=
viewportOffsets
;
invalidateViewport
(
context
)
;
mInternalDirtyBits
.
set
(
DIRTY_BIT_SCISSOR_STATE
)
;
}
switch
(
drawFramebuffer
-
>
getMultiviewLayout
(
)
)
{
case
GL_FRAMEBUFFER_MULTIVIEW_SIDE_BY_SIDE_ANGLE
:
mShaderConstants
.
setMultiviewWriteToViewportIndex
(
1
.
0f
)
;
break
;
case
GL_FRAMEBUFFER_MULTIVIEW_LAYERED_ANGLE
:
mShaderConstants
.
setMultiviewWriteToViewportIndex
(
0
.
0f
)
;
break
;
default
:
break
;
}
}
angle
:
:
Result
StateManager11
:
:
syncBlendState
(
const
gl
:
:
Context
*
context
const
gl
:
:
BlendState
&
blendState
const
gl
:
:
ColorF
&
blendColor
unsigned
int
sampleMask
)
{
const
d3d11
:
:
BlendState
*
dxBlendState
=
nullptr
;
const
d3d11
:
:
BlendStateKey
&
key
=
RenderStateCache
:
:
GetBlendStateKey
(
context
mFramebuffer11
blendState
)
;
ANGLE_TRY
(
mRenderer
-
>
getBlendState
(
context
key
&
dxBlendState
)
)
;
ASSERT
(
dxBlendState
!
=
nullptr
)
;
float
blendColors
[
4
]
=
{
0
.
0f
}
;
if
(
blendState
.
sourceBlendRGB
!
=
GL_CONSTANT_ALPHA
&
&
blendState
.
sourceBlendRGB
!
=
GL_ONE_MINUS_CONSTANT_ALPHA
&
&
blendState
.
destBlendRGB
!
=
GL_CONSTANT_ALPHA
&
&
blendState
.
destBlendRGB
!
=
GL_ONE_MINUS_CONSTANT_ALPHA
)
{
blendColors
[
0
]
=
blendColor
.
red
;
blendColors
[
1
]
=
blendColor
.
green
;
blendColors
[
2
]
=
blendColor
.
blue
;
blendColors
[
3
]
=
blendColor
.
alpha
;
}
else
{
blendColors
[
0
]
=
blendColor
.
alpha
;
blendColors
[
1
]
=
blendColor
.
alpha
;
blendColors
[
2
]
=
blendColor
.
alpha
;
blendColors
[
3
]
=
blendColor
.
alpha
;
}
mRenderer
-
>
getDeviceContext
(
)
-
>
OMSetBlendState
(
dxBlendState
-
>
get
(
)
blendColors
sampleMask
)
;
mCurBlendState
=
blendState
;
mCurBlendColor
=
blendColor
;
mCurSampleMask
=
sampleMask
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
syncDepthStencilState
(
const
gl
:
:
Context
*
context
)
{
const
gl
:
:
State
&
glState
=
context
-
>
getGLState
(
)
;
mCurDepthStencilState
=
glState
.
getDepthStencilState
(
)
;
mCurStencilRef
=
glState
.
getStencilRef
(
)
;
mCurStencilBackRef
=
glState
.
getStencilBackRef
(
)
;
unsigned
int
maxStencil
=
0
;
if
(
mCurDepthStencilState
.
stencilTest
&
&
mCurStencilSize
>
0
)
{
maxStencil
=
(
1
<
<
mCurStencilSize
)
-
1
;
}
ASSERT
(
(
mCurDepthStencilState
.
stencilWritemask
&
maxStencil
)
=
=
(
mCurDepthStencilState
.
stencilBackWritemask
&
maxStencil
)
)
;
ASSERT
(
gl
:
:
clamp
(
mCurStencilRef
0
static_cast
<
int
>
(
maxStencil
)
)
=
=
gl
:
:
clamp
(
mCurStencilBackRef
0
static_cast
<
int
>
(
maxStencil
)
)
)
;
ASSERT
(
(
mCurDepthStencilState
.
stencilMask
&
maxStencil
)
=
=
(
mCurDepthStencilState
.
stencilBackMask
&
maxStencil
)
)
;
gl
:
:
DepthStencilState
modifiedGLState
=
glState
.
getDepthStencilState
(
)
;
ASSERT
(
mCurDisableDepth
.
valid
(
)
&
&
mCurDisableStencil
.
valid
(
)
)
;
if
(
mCurDisableDepth
.
value
(
)
)
{
modifiedGLState
.
depthTest
=
false
;
modifiedGLState
.
depthMask
=
false
;
}
if
(
mCurDisableStencil
.
value
(
)
)
{
modifiedGLState
.
stencilTest
=
false
;
}
if
(
!
modifiedGLState
.
stencilTest
)
{
modifiedGLState
.
stencilWritemask
=
0
;
modifiedGLState
.
stencilBackWritemask
=
0
;
}
ASSERT
(
glState
.
getDepthStencilState
(
)
.
stencilTest
|
|
(
!
modifiedGLState
.
stencilTest
&
&
modifiedGLState
.
stencilWritemask
=
=
0
&
&
modifiedGLState
.
stencilBackWritemask
=
=
0
)
)
;
const
d3d11
:
:
DepthStencilState
*
d3dState
=
nullptr
;
ANGLE_TRY
(
mRenderer
-
>
getDepthStencilState
(
context
modifiedGLState
&
d3dState
)
)
;
ASSERT
(
d3dState
)
;
static_assert
(
D3D11_DEFAULT_STENCIL_READ_MASK
=
=
0xFF
"
Unexpected
value
of
D3D11_DEFAULT_STENCIL_READ_MASK
"
)
;
static_assert
(
D3D11_DEFAULT_STENCIL_WRITE_MASK
=
=
0xFF
"
Unexpected
value
of
D3D11_DEFAULT_STENCIL_WRITE_MASK
"
)
;
UINT
dxStencilRef
=
static_cast
<
UINT
>
(
gl
:
:
clamp
(
mCurStencilRef
0
0xFF
)
)
;
mRenderer
-
>
getDeviceContext
(
)
-
>
OMSetDepthStencilState
(
d3dState
-
>
get
(
)
dxStencilRef
)
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
syncRasterizerState
(
const
gl
:
:
Context
*
context
const
gl
:
:
DrawCallParams
&
drawCallParams
)
{
gl
:
:
RasterizerState
rasterState
=
context
-
>
getGLState
(
)
.
getRasterizerState
(
)
;
rasterState
.
pointDrawMode
=
(
drawCallParams
.
mode
(
)
=
=
gl
:
:
PrimitiveMode
:
:
Points
)
;
rasterState
.
multiSample
=
mCurRasterState
.
multiSample
;
ID3D11RasterizerState
*
dxRasterState
=
nullptr
;
if
(
mCurPresentPathFastEnabled
)
{
gl
:
:
RasterizerState
modifiedRasterState
=
rasterState
;
if
(
modifiedRasterState
.
frontFace
=
=
GL_CCW
)
{
modifiedRasterState
.
frontFace
=
GL_CW
;
}
else
{
ASSERT
(
modifiedRasterState
.
frontFace
=
=
GL_CW
)
;
modifiedRasterState
.
frontFace
=
GL_CCW
;
}
ANGLE_TRY
(
mRenderer
-
>
getRasterizerState
(
context
modifiedRasterState
mCurScissorEnabled
&
dxRasterState
)
)
;
}
else
{
ANGLE_TRY
(
mRenderer
-
>
getRasterizerState
(
context
rasterState
mCurScissorEnabled
&
dxRasterState
)
)
;
}
mRenderer
-
>
getDeviceContext
(
)
-
>
RSSetState
(
dxRasterState
)
;
mCurRasterState
=
rasterState
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
void
StateManager11
:
:
syncScissorRectangle
(
const
gl
:
:
Rectangle
&
scissor
bool
enabled
)
{
int
modifiedScissorY
=
scissor
.
y
;
if
(
mCurPresentPathFastEnabled
)
{
modifiedScissorY
=
mCurPresentPathFastColorBufferHeight
-
scissor
.
height
-
scissor
.
y
;
}
if
(
enabled
)
{
std
:
:
array
<
D3D11_RECT
gl
:
:
IMPLEMENTATION_ANGLE_MULTIVIEW_MAX_VIEWS
>
rectangles
;
const
UINT
numRectangles
=
static_cast
<
UINT
>
(
mViewportOffsets
.
size
(
)
)
;
for
(
UINT
i
=
0u
;
i
<
numRectangles
;
+
+
i
)
{
D3D11_RECT
&
rect
=
rectangles
[
i
]
;
int
x
=
scissor
.
x
+
mViewportOffsets
[
i
]
.
x
;
int
y
=
modifiedScissorY
+
mViewportOffsets
[
i
]
.
y
;
rect
.
left
=
std
:
:
max
(
0
x
)
;
rect
.
top
=
std
:
:
max
(
0
y
)
;
rect
.
right
=
x
+
std
:
:
max
(
0
scissor
.
width
)
;
rect
.
bottom
=
y
+
std
:
:
max
(
0
scissor
.
height
)
;
}
mRenderer
-
>
getDeviceContext
(
)
-
>
RSSetScissorRects
(
numRectangles
rectangles
.
data
(
)
)
;
}
mCurScissorRect
=
scissor
;
mCurScissorEnabled
=
enabled
;
}
void
StateManager11
:
:
syncViewport
(
const
gl
:
:
Context
*
context
)
{
const
auto
&
glState
=
context
-
>
getGLState
(
)
;
gl
:
:
Framebuffer
*
framebuffer
=
glState
.
getDrawFramebuffer
(
)
;
float
actualZNear
=
gl
:
:
clamp01
(
glState
.
getNearPlane
(
)
)
;
float
actualZFar
=
gl
:
:
clamp01
(
glState
.
getFarPlane
(
)
)
;
const
auto
&
caps
=
context
-
>
getCaps
(
)
;
int
dxMaxViewportBoundsX
=
static_cast
<
int
>
(
caps
.
maxViewportWidth
)
;
int
dxMaxViewportBoundsY
=
static_cast
<
int
>
(
caps
.
maxViewportHeight
)
;
int
dxMinViewportBoundsX
=
-
dxMaxViewportBoundsX
;
int
dxMinViewportBoundsY
=
-
dxMaxViewportBoundsY
;
bool
is9_3
=
mRenderer
-
>
getRenderer11DeviceCaps
(
)
.
featureLevel
<
=
D3D_FEATURE_LEVEL_9_3
;
if
(
is9_3
)
{
dxMaxViewportBoundsX
=
static_cast
<
int
>
(
mViewportBounds
.
width
)
;
dxMaxViewportBoundsY
=
static_cast
<
int
>
(
mViewportBounds
.
height
)
;
dxMinViewportBoundsX
=
0
;
dxMinViewportBoundsY
=
0
;
}
const
auto
&
viewport
=
glState
.
getViewport
(
)
;
std
:
:
array
<
D3D11_VIEWPORT
gl
:
:
IMPLEMENTATION_ANGLE_MULTIVIEW_MAX_VIEWS
>
dxViewports
;
const
UINT
numRectangles
=
static_cast
<
UINT
>
(
mViewportOffsets
.
size
(
)
)
;
int
dxViewportTopLeftX
=
0
;
int
dxViewportTopLeftY
=
0
;
int
dxViewportWidth
=
0
;
int
dxViewportHeight
=
0
;
for
(
UINT
i
=
0u
;
i
<
numRectangles
;
+
+
i
)
{
dxViewportTopLeftX
=
gl
:
:
clamp
(
viewport
.
x
+
mViewportOffsets
[
i
]
.
x
dxMinViewportBoundsX
dxMaxViewportBoundsX
)
;
dxViewportTopLeftY
=
gl
:
:
clamp
(
viewport
.
y
+
mViewportOffsets
[
i
]
.
y
dxMinViewportBoundsY
dxMaxViewportBoundsY
)
;
dxViewportWidth
=
gl
:
:
clamp
(
viewport
.
width
0
dxMaxViewportBoundsX
-
dxViewportTopLeftX
)
;
dxViewportHeight
=
gl
:
:
clamp
(
viewport
.
height
0
dxMaxViewportBoundsY
-
dxViewportTopLeftY
)
;
D3D11_VIEWPORT
&
dxViewport
=
dxViewports
[
i
]
;
dxViewport
.
TopLeftX
=
static_cast
<
float
>
(
dxViewportTopLeftX
)
;
if
(
mCurPresentPathFastEnabled
)
{
dxViewport
.
TopLeftY
=
static_cast
<
float
>
(
mCurPresentPathFastColorBufferHeight
-
dxViewportTopLeftY
-
dxViewportHeight
)
;
}
else
{
dxViewport
.
TopLeftY
=
static_cast
<
float
>
(
dxViewportTopLeftY
)
;
}
if
(
!
framebuffer
-
>
getFirstNonNullAttachment
(
)
&
&
(
framebuffer
-
>
getDefaultWidth
(
)
|
|
framebuffer
-
>
getDefaultHeight
(
)
)
)
{
dxViewport
.
Width
=
static_cast
<
GLfloat
>
(
std
:
:
min
(
viewport
.
width
framebuffer
-
>
getDefaultWidth
(
)
)
)
;
dxViewport
.
Height
=
static_cast
<
GLfloat
>
(
std
:
:
min
(
viewport
.
height
framebuffer
-
>
getDefaultHeight
(
)
)
)
;
}
else
{
dxViewport
.
Width
=
static_cast
<
float
>
(
dxViewportWidth
)
;
dxViewport
.
Height
=
static_cast
<
float
>
(
dxViewportHeight
)
;
}
dxViewport
.
MinDepth
=
actualZNear
;
dxViewport
.
MaxDepth
=
actualZFar
;
}
mRenderer
-
>
getDeviceContext
(
)
-
>
RSSetViewports
(
numRectangles
dxViewports
.
data
(
)
)
;
mCurViewport
=
viewport
;
mCurNear
=
actualZNear
;
mCurFar
=
actualZFar
;
const
D3D11_VIEWPORT
adjustViewport
=
{
static_cast
<
FLOAT
>
(
dxViewportTopLeftX
)
static_cast
<
FLOAT
>
(
dxViewportTopLeftY
)
static_cast
<
FLOAT
>
(
dxViewportWidth
)
static_cast
<
FLOAT
>
(
dxViewportHeight
)
actualZNear
actualZFar
}
;
mShaderConstants
.
onViewportChange
(
viewport
adjustViewport
is9_3
mCurPresentPathFastEnabled
)
;
}
void
StateManager11
:
:
invalidateRenderTarget
(
)
{
mRenderTargetIsDirty
=
true
;
}
void
StateManager11
:
:
processFramebufferInvalidation
(
const
gl
:
:
Context
*
context
)
{
ASSERT
(
mRenderTargetIsDirty
)
;
ASSERT
(
context
)
;
mInternalDirtyBits
.
set
(
DIRTY_BIT_RENDER_TARGET
)
;
invalidateShaders
(
)
;
mInternalDirtyBits
.
set
(
DIRTY_BIT_BLEND_STATE
)
;
gl
:
:
Framebuffer
*
fbo
=
context
-
>
getGLState
(
)
.
getDrawFramebuffer
(
)
;
ASSERT
(
fbo
)
;
bool
disableDepth
=
(
!
fbo
-
>
hasDepth
(
)
&
&
fbo
-
>
hasStencil
(
)
)
;
bool
disableStencil
=
(
fbo
-
>
hasDepth
(
)
&
&
!
fbo
-
>
hasStencil
(
)
)
;
if
(
!
mCurDisableDepth
.
valid
(
)
|
|
disableDepth
!
=
mCurDisableDepth
.
value
(
)
|
|
!
mCurDisableStencil
.
valid
(
)
|
|
disableStencil
!
=
mCurDisableStencil
.
value
(
)
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_DEPTH_STENCIL_STATE
)
;
mCurDisableDepth
=
disableDepth
;
mCurDisableStencil
=
disableStencil
;
}
bool
multiSample
=
(
fbo
-
>
getCachedSamples
(
context
)
!
=
0
)
;
if
(
multiSample
!
=
mCurRasterState
.
multiSample
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_RASTERIZER_STATE
)
;
mCurRasterState
.
multiSample
=
multiSample
;
}
checkPresentPath
(
context
)
;
if
(
mRenderer
-
>
getRenderer11DeviceCaps
(
)
.
featureLevel
<
=
D3D_FEATURE_LEVEL_9_3
)
{
const
auto
*
firstAttachment
=
fbo
-
>
getFirstNonNullAttachment
(
)
;
if
(
firstAttachment
)
{
const
auto
&
size
=
firstAttachment
-
>
getSize
(
)
;
if
(
mViewportBounds
.
width
!
=
size
.
width
|
|
mViewportBounds
.
height
!
=
size
.
height
)
{
mViewportBounds
=
gl
:
:
Extents
(
size
.
width
size
.
height
1
)
;
invalidateViewport
(
context
)
;
}
}
}
}
void
StateManager11
:
:
invalidateBoundViews
(
)
{
for
(
SRVCache
&
curShaderSRV
:
mCurShaderSRVs
)
{
curShaderSRV
.
clear
(
)
;
}
invalidateRenderTarget
(
)
;
}
void
StateManager11
:
:
invalidateVertexBuffer
(
)
{
unsigned
int
limit
=
std
:
:
min
<
unsigned
int
>
(
mRenderer
-
>
getNativeCaps
(
)
.
maxVertexAttributes
gl
:
:
MAX_VERTEX_ATTRIBS
)
;
mDirtyVertexBufferRange
=
gl
:
:
RangeUI
(
0
limit
)
;
invalidateInputLayout
(
)
;
invalidateShaders
(
)
;
mInternalDirtyBits
.
set
(
DIRTY_BIT_CURRENT_VALUE_ATTRIBS
)
;
}
void
StateManager11
:
:
invalidateViewport
(
const
gl
:
:
Context
*
context
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_VIEWPORT_STATE
)
;
invalidateDriverUniforms
(
)
;
}
void
StateManager11
:
:
invalidateTexturesAndSamplers
(
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_TEXTURE_AND_SAMPLER_STATE
)
;
invalidateSwizzles
(
)
;
invalidateDriverUniforms
(
)
;
}
void
StateManager11
:
:
invalidateSwizzles
(
)
{
mDirtySwizzles
=
true
;
}
void
StateManager11
:
:
invalidateProgramUniforms
(
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_PROGRAM_UNIFORMS
)
;
}
void
StateManager11
:
:
invalidateDriverUniforms
(
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_DRIVER_UNIFORMS
)
;
}
void
StateManager11
:
:
invalidateProgramUniformBuffers
(
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_PROGRAM_UNIFORM_BUFFERS
)
;
}
void
StateManager11
:
:
invalidateConstantBuffer
(
unsigned
int
slot
)
{
if
(
slot
=
=
d3d11
:
:
RESERVED_CONSTANT_BUFFER_SLOT_DRIVER
)
{
invalidateDriverUniforms
(
)
;
}
else
if
(
slot
=
=
d3d11
:
:
RESERVED_CONSTANT_BUFFER_SLOT_DEFAULT_UNIFORM_BLOCK
)
{
invalidateProgramUniforms
(
)
;
}
else
{
invalidateProgramUniformBuffers
(
)
;
}
}
void
StateManager11
:
:
invalidateShaders
(
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_SHADERS
)
;
}
void
StateManager11
:
:
invalidateTransformFeedback
(
)
{
invalidateShaders
(
)
;
mInternalDirtyBits
.
set
(
DIRTY_BIT_TRANSFORM_FEEDBACK
)
;
mInternalDirtyBits
.
set
(
DIRTY_BIT_PRIMITIVE_TOPOLOGY
)
;
}
void
StateManager11
:
:
invalidateInputLayout
(
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_VERTEX_BUFFERS_AND_INPUT_LAYOUT
)
;
}
void
StateManager11
:
:
invalidateIndexBuffer
(
)
{
mIndexBufferIsDirty
=
true
;
}
void
StateManager11
:
:
setRenderTarget
(
ID3D11RenderTargetView
*
rtv
ID3D11DepthStencilView
*
dsv
)
{
if
(
(
rtv
&
&
unsetConflictingView
(
rtv
)
)
|
|
(
dsv
&
&
unsetConflictingView
(
dsv
)
)
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_TEXTURE_AND_SAMPLER_STATE
)
;
}
mRenderer
-
>
getDeviceContext
(
)
-
>
OMSetRenderTargets
(
1
&
rtv
dsv
)
;
mInternalDirtyBits
.
set
(
DIRTY_BIT_RENDER_TARGET
)
;
}
void
StateManager11
:
:
setRenderTargets
(
ID3D11RenderTargetView
*
*
rtvs
UINT
numRTVs
ID3D11DepthStencilView
*
dsv
)
{
bool
anyDirty
=
false
;
for
(
UINT
rtvIndex
=
0
;
rtvIndex
<
numRTVs
;
+
+
rtvIndex
)
{
anyDirty
=
anyDirty
|
|
unsetConflictingView
(
rtvs
[
rtvIndex
]
)
;
}
if
(
dsv
)
{
anyDirty
=
anyDirty
|
|
unsetConflictingView
(
dsv
)
;
}
if
(
anyDirty
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_TEXTURE_AND_SAMPLER_STATE
)
;
}
mRenderer
-
>
getDeviceContext
(
)
-
>
OMSetRenderTargets
(
numRTVs
(
numRTVs
>
0
)
?
rtvs
:
nullptr
dsv
)
;
mInternalDirtyBits
.
set
(
DIRTY_BIT_RENDER_TARGET
)
;
}
void
StateManager11
:
:
onBeginQuery
(
Query11
*
query
)
{
mCurrentQueries
.
insert
(
query
)
;
}
void
StateManager11
:
:
onDeleteQueryObject
(
Query11
*
query
)
{
mCurrentQueries
.
erase
(
query
)
;
}
angle
:
:
Result
StateManager11
:
:
onMakeCurrent
(
const
gl
:
:
Context
*
context
)
{
ANGLE_TRY
(
ensureInitialized
(
context
)
)
;
const
gl
:
:
State
&
state
=
context
-
>
getGLState
(
)
;
Context11
*
context11
=
GetImplAs
<
Context11
>
(
context
)
;
for
(
Query11
*
query
:
mCurrentQueries
)
{
ANGLE_TRY
(
query
-
>
pause
(
context11
)
)
;
}
mCurrentQueries
.
clear
(
)
;
for
(
gl
:
:
QueryType
type
:
angle
:
:
AllEnums
<
gl
:
:
QueryType
>
(
)
)
{
gl
:
:
Query
*
query
=
state
.
getActiveQuery
(
type
)
;
if
(
query
!
=
nullptr
)
{
Query11
*
query11
=
GetImplAs
<
Query11
>
(
query
)
;
ANGLE_TRY
(
query11
-
>
resume
(
context11
)
)
;
mCurrentQueries
.
insert
(
query11
)
;
}
}
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
clearSRVs
(
gl
:
:
ShaderType
shaderType
size_t
rangeStart
size_t
rangeEnd
)
{
if
(
rangeStart
=
=
rangeEnd
)
{
return
angle
:
:
Result
:
:
Continue
(
)
;
}
auto
*
currentSRVs
=
getSRVCache
(
shaderType
)
;
gl
:
:
Range
<
size_t
>
clearRange
(
rangeStart
std
:
:
min
(
rangeEnd
currentSRVs
-
>
highestUsed
(
)
)
)
;
if
(
clearRange
.
empty
(
)
)
{
return
angle
:
:
Result
:
:
Continue
(
)
;
}
ID3D11DeviceContext
*
deviceContext
=
mRenderer
-
>
getDeviceContext
(
)
;
switch
(
shaderType
)
{
case
gl
:
:
ShaderType
:
:
Vertex
:
deviceContext
-
>
VSSetShaderResources
(
static_cast
<
unsigned
int
>
(
clearRange
.
low
(
)
)
static_cast
<
unsigned
int
>
(
clearRange
.
length
(
)
)
&
mNullSRVs
[
0
]
)
;
break
;
case
gl
:
:
ShaderType
:
:
Fragment
:
deviceContext
-
>
PSSetShaderResources
(
static_cast
<
unsigned
int
>
(
clearRange
.
low
(
)
)
static_cast
<
unsigned
int
>
(
clearRange
.
length
(
)
)
&
mNullSRVs
[
0
]
)
;
break
;
case
gl
:
:
ShaderType
:
:
Compute
:
deviceContext
-
>
CSSetShaderResources
(
static_cast
<
unsigned
int
>
(
clearRange
.
low
(
)
)
static_cast
<
unsigned
int
>
(
clearRange
.
length
(
)
)
&
mNullSRVs
[
0
]
)
;
break
;
default
:
UNREACHABLE
(
)
;
break
;
}
for
(
size_t
samplerIndex
:
clearRange
)
{
currentSRVs
-
>
update
(
samplerIndex
nullptr
)
;
}
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
clearUAVs
(
gl
:
:
ShaderType
shaderType
size_t
rangeStart
size_t
rangeEnd
)
{
ASSERT
(
shaderType
=
=
gl
:
:
ShaderType
:
:
Compute
)
;
if
(
rangeStart
=
=
rangeEnd
)
{
return
angle
:
:
Result
:
:
Continue
(
)
;
}
gl
:
:
Range
<
size_t
>
clearRange
(
rangeStart
std
:
:
min
(
rangeEnd
mCurComputeUAVs
.
highestUsed
(
)
)
)
;
if
(
clearRange
.
empty
(
)
)
{
return
angle
:
:
Result
:
:
Continue
(
)
;
}
auto
deviceContext
=
mRenderer
-
>
getDeviceContext
(
)
;
deviceContext
-
>
CSSetUnorderedAccessViews
(
static_cast
<
unsigned
int
>
(
clearRange
.
low
(
)
)
static_cast
<
unsigned
int
>
(
clearRange
.
length
(
)
)
&
mNullUAVs
[
0
]
nullptr
)
;
for
(
size_t
index
:
clearRange
)
{
mCurComputeUAVs
.
update
(
index
nullptr
)
;
}
return
angle
:
:
Result
:
:
Continue
(
)
;
}
bool
StateManager11
:
:
unsetConflictingView
(
ID3D11View
*
view
)
{
uintptr_t
resource
=
reinterpret_cast
<
uintptr_t
>
(
GetViewResource
(
view
)
)
;
return
unsetConflictingSRVs
(
gl
:
:
ShaderType
:
:
Vertex
resource
nullptr
)
|
|
unsetConflictingSRVs
(
gl
:
:
ShaderType
:
:
Fragment
resource
nullptr
)
;
}
bool
StateManager11
:
:
unsetConflictingSRVs
(
gl
:
:
ShaderType
shaderType
uintptr_t
resource
const
gl
:
:
ImageIndex
*
index
)
{
auto
*
currentSRVs
=
getSRVCache
(
shaderType
)
;
bool
foundOne
=
false
;
for
(
size_t
resourceIndex
=
0
;
resourceIndex
<
currentSRVs
-
>
size
(
)
;
+
+
resourceIndex
)
{
auto
&
record
=
(
*
currentSRVs
)
[
resourceIndex
]
;
if
(
record
.
view
&
&
record
.
resource
=
=
resource
&
&
(
!
index
|
|
ImageIndexConflictsWithSRV
(
*
index
record
.
desc
)
)
)
{
setShaderResourceInternal
<
d3d11
:
:
ShaderResourceView
>
(
shaderType
static_cast
<
UINT
>
(
resourceIndex
)
nullptr
)
;
foundOne
=
true
;
}
}
return
foundOne
;
}
void
StateManager11
:
:
unsetConflictingAttachmentResources
(
const
gl
:
:
FramebufferAttachment
&
attachment
ID3D11Resource
*
resource
)
{
if
(
attachment
.
type
(
)
=
=
GL_TEXTURE
)
{
uintptr_t
resourcePtr
=
reinterpret_cast
<
uintptr_t
>
(
resource
)
;
const
gl
:
:
ImageIndex
&
index
=
attachment
.
getTextureImageIndex
(
)
;
unsetConflictingSRVs
(
gl
:
:
ShaderType
:
:
Vertex
resourcePtr
&
index
)
;
unsetConflictingSRVs
(
gl
:
:
ShaderType
:
:
Fragment
resourcePtr
&
index
)
;
}
else
if
(
attachment
.
type
(
)
=
=
GL_FRAMEBUFFER_DEFAULT
)
{
uintptr_t
resourcePtr
=
reinterpret_cast
<
uintptr_t
>
(
resource
)
;
unsetConflictingSRVs
(
gl
:
:
ShaderType
:
:
Vertex
resourcePtr
nullptr
)
;
unsetConflictingSRVs
(
gl
:
:
ShaderType
:
:
Fragment
resourcePtr
nullptr
)
;
}
}
angle
:
:
Result
StateManager11
:
:
ensureInitialized
(
const
gl
:
:
Context
*
context
)
{
Renderer11
*
renderer
=
GetImplAs
<
Context11
>
(
context
)
-
>
getRenderer
(
)
;
const
gl
:
:
Caps
&
caps
=
renderer
-
>
getNativeCaps
(
)
;
const
gl
:
:
Extensions
&
extensions
=
renderer
-
>
getNativeExtensions
(
)
;
for
(
gl
:
:
ShaderType
shaderType
:
gl
:
:
AllShaderTypes
(
)
)
{
const
GLuint
maxShaderTextureImageUnits
=
caps
.
maxShaderTextureImageUnits
[
shaderType
]
;
mCurShaderSRVs
[
shaderType
]
.
initialize
(
maxShaderTextureImageUnits
)
;
mForceSetShaderSamplerStates
[
shaderType
]
.
resize
(
maxShaderTextureImageUnits
true
)
;
mCurShaderSamplerStates
[
shaderType
]
.
resize
(
maxShaderTextureImageUnits
)
;
}
mCurComputeUAVs
.
initialize
(
caps
.
maxImageUnits
)
;
mNullSRVs
.
resize
(
caps
.
maxShaderTextureImageUnits
[
gl
:
:
ShaderType
:
:
Fragment
]
nullptr
)
;
mNullUAVs
.
resize
(
caps
.
maxImageUnits
nullptr
)
;
mCurrentValueAttribs
.
resize
(
caps
.
maxVertexAttributes
)
;
mShaderConstants
.
init
(
caps
)
;
mIsMultiviewEnabled
=
extensions
.
multiview
;
mViewportOffsets
.
resize
(
1u
)
;
ANGLE_TRY
(
mVertexDataManager
.
initialize
(
context
)
)
;
mCurrentAttributes
.
reserve
(
gl
:
:
MAX_VERTEX_ATTRIBS
)
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
void
StateManager11
:
:
deinitialize
(
)
{
mCurrentValueAttribs
.
clear
(
)
;
mInputLayoutCache
.
clear
(
)
;
mVertexDataManager
.
deinitialize
(
)
;
mIndexDataManager
.
deinitialize
(
)
;
for
(
d3d11
:
:
Buffer
&
ShaderDriverConstantBuffer
:
mShaderDriverConstantBuffers
)
{
ShaderDriverConstantBuffer
.
reset
(
)
;
}
mPointSpriteVertexBuffer
.
reset
(
)
;
mPointSpriteIndexBuffer
.
reset
(
)
;
}
angle
:
:
Result
StateManager11
:
:
syncFramebuffer
(
const
gl
:
:
Context
*
context
)
{
if
(
mFramebuffer11
-
>
getState
(
)
.
id
(
)
=
=
0
)
{
RenderTarget11
*
firstRT
=
mFramebuffer11
-
>
getFirstRenderTarget
(
)
;
const
gl
:
:
Extents
&
size
=
firstRT
-
>
getExtents
(
)
;
if
(
size
.
empty
(
)
)
{
return
angle
:
:
Result
:
:
Continue
(
)
;
}
}
RTVArray
framebufferRTVs
=
{
{
}
}
;
const
auto
&
colorRTs
=
mFramebuffer11
-
>
getCachedColorRenderTargets
(
)
;
size_t
appliedRTIndex
=
0
;
bool
skipInactiveRTs
=
mRenderer
-
>
getWorkarounds
(
)
.
mrtPerfWorkaround
;
const
auto
&
drawStates
=
mFramebuffer11
-
>
getState
(
)
.
getDrawBufferStates
(
)
;
gl
:
:
DrawBufferMask
activeProgramOutputs
=
mProgramD3D
-
>
getState
(
)
.
getActiveOutputVariables
(
)
;
UINT
maxExistingRT
=
0
;
const
auto
&
colorAttachments
=
mFramebuffer11
-
>
getState
(
)
.
getColorAttachments
(
)
;
for
(
size_t
rtIndex
=
0
;
rtIndex
<
colorRTs
.
size
(
)
;
+
+
rtIndex
)
{
const
RenderTarget11
*
renderTarget
=
colorRTs
[
rtIndex
]
;
if
(
skipInactiveRTs
&
&
(
!
renderTarget
|
|
drawStates
[
rtIndex
]
=
=
GL_NONE
|
|
!
activeProgramOutputs
[
rtIndex
]
)
)
{
continue
;
}
if
(
renderTarget
)
{
framebufferRTVs
[
appliedRTIndex
]
=
renderTarget
-
>
getRenderTargetView
(
)
.
get
(
)
;
ASSERT
(
framebufferRTVs
[
appliedRTIndex
]
)
;
maxExistingRT
=
static_cast
<
UINT
>
(
appliedRTIndex
)
+
1
;
const
gl
:
:
FramebufferAttachment
&
attachment
=
colorAttachments
[
rtIndex
]
;
ASSERT
(
attachment
.
isAttached
(
)
)
;
unsetConflictingAttachmentResources
(
attachment
renderTarget
-
>
getTexture
(
)
.
get
(
)
)
;
}
appliedRTIndex
+
+
;
}
ID3D11DepthStencilView
*
framebufferDSV
=
nullptr
;
const
auto
*
depthStencilRenderTarget
=
mFramebuffer11
-
>
getCachedDepthStencilRenderTarget
(
)
;
if
(
depthStencilRenderTarget
)
{
framebufferDSV
=
depthStencilRenderTarget
-
>
getDepthStencilView
(
)
.
get
(
)
;
ASSERT
(
framebufferDSV
)
;
const
gl
:
:
FramebufferAttachment
*
attachment
=
mFramebuffer11
-
>
getState
(
)
.
getDepthOrStencilAttachment
(
)
;
ASSERT
(
attachment
)
;
unsetConflictingAttachmentResources
(
*
attachment
depthStencilRenderTarget
-
>
getTexture
(
)
.
get
(
)
)
;
}
ASSERT
(
maxExistingRT
<
=
static_cast
<
UINT
>
(
mRenderer
-
>
getNativeCaps
(
)
.
maxDrawBuffers
)
)
;
mRenderer
-
>
getDeviceContext
(
)
-
>
OMSetRenderTargets
(
maxExistingRT
framebufferRTVs
.
data
(
)
framebufferDSV
)
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
void
StateManager11
:
:
invalidateCurrentValueAttrib
(
size_t
attribIndex
)
{
mDirtyCurrentValueAttribs
.
set
(
attribIndex
)
;
mInternalDirtyBits
.
set
(
DIRTY_BIT_CURRENT_VALUE_ATTRIBS
)
;
invalidateInputLayout
(
)
;
invalidateShaders
(
)
;
}
angle
:
:
Result
StateManager11
:
:
syncCurrentValueAttribs
(
const
gl
:
:
Context
*
context
const
std
:
:
vector
<
gl
:
:
VertexAttribCurrentValueData
>
&
currentValues
)
{
const
auto
&
activeAttribsMask
=
mProgramD3D
-
>
getState
(
)
.
getActiveAttribLocationsMask
(
)
;
const
auto
&
dirtyActiveAttribs
=
(
activeAttribsMask
&
mDirtyCurrentValueAttribs
)
;
if
(
!
dirtyActiveAttribs
.
any
(
)
)
{
return
angle
:
:
Result
:
:
Continue
(
)
;
}
const
auto
&
vertexAttributes
=
mVertexArray11
-
>
getState
(
)
.
getVertexAttributes
(
)
;
const
auto
&
vertexBindings
=
mVertexArray11
-
>
getState
(
)
.
getVertexBindings
(
)
;
mDirtyCurrentValueAttribs
=
(
mDirtyCurrentValueAttribs
&
~
dirtyActiveAttribs
)
;
for
(
auto
attribIndex
:
dirtyActiveAttribs
)
{
if
(
vertexAttributes
[
attribIndex
]
.
enabled
)
continue
;
const
auto
*
attrib
=
&
vertexAttributes
[
attribIndex
]
;
const
auto
&
currentValue
=
currentValues
[
attribIndex
]
;
TranslatedAttribute
*
currentValueAttrib
=
&
mCurrentValueAttribs
[
attribIndex
]
;
currentValueAttrib
-
>
currentValueType
=
currentValue
.
Type
;
currentValueAttrib
-
>
attribute
=
attrib
;
currentValueAttrib
-
>
binding
=
&
vertexBindings
[
attrib
-
>
bindingIndex
]
;
mDirtyVertexBufferRange
.
extend
(
static_cast
<
unsigned
int
>
(
attribIndex
)
)
;
ANGLE_TRY
(
mVertexDataManager
.
storeCurrentValue
(
context
currentValue
currentValueAttrib
static_cast
<
size_t
>
(
attribIndex
)
)
)
;
}
return
angle
:
:
Result
:
:
Continue
(
)
;
}
void
StateManager11
:
:
setInputLayout
(
const
d3d11
:
:
InputLayout
*
inputLayout
)
{
if
(
setInputLayoutInternal
(
inputLayout
)
)
{
invalidateInputLayout
(
)
;
}
}
bool
StateManager11
:
:
setInputLayoutInternal
(
const
d3d11
:
:
InputLayout
*
inputLayout
)
{
ID3D11DeviceContext
*
deviceContext
=
mRenderer
-
>
getDeviceContext
(
)
;
if
(
inputLayout
=
=
nullptr
)
{
if
(
!
mCurrentInputLayout
.
empty
(
)
)
{
deviceContext
-
>
IASetInputLayout
(
nullptr
)
;
mCurrentInputLayout
.
clear
(
)
;
return
true
;
}
}
else
if
(
inputLayout
-
>
getSerial
(
)
!
=
mCurrentInputLayout
)
{
deviceContext
-
>
IASetInputLayout
(
inputLayout
-
>
get
(
)
)
;
mCurrentInputLayout
=
inputLayout
-
>
getSerial
(
)
;
return
true
;
}
return
false
;
}
bool
StateManager11
:
:
queueVertexBufferChange
(
size_t
bufferIndex
ID3D11Buffer
*
buffer
UINT
stride
UINT
offset
)
{
if
(
buffer
!
=
mCurrentVertexBuffers
[
bufferIndex
]
|
|
stride
!
=
mCurrentVertexStrides
[
bufferIndex
]
|
|
offset
!
=
mCurrentVertexOffsets
[
bufferIndex
]
)
{
mDirtyVertexBufferRange
.
extend
(
static_cast
<
unsigned
int
>
(
bufferIndex
)
)
;
mCurrentVertexBuffers
[
bufferIndex
]
=
buffer
;
mCurrentVertexStrides
[
bufferIndex
]
=
stride
;
mCurrentVertexOffsets
[
bufferIndex
]
=
offset
;
return
true
;
}
return
false
;
}
void
StateManager11
:
:
applyVertexBufferChanges
(
)
{
if
(
mDirtyVertexBufferRange
.
empty
(
)
)
{
return
;
}
ASSERT
(
mDirtyVertexBufferRange
.
high
(
)
<
=
gl
:
:
MAX_VERTEX_ATTRIBS
)
;
UINT
start
=
static_cast
<
UINT
>
(
mDirtyVertexBufferRange
.
low
(
)
)
;
ID3D11DeviceContext
*
deviceContext
=
mRenderer
-
>
getDeviceContext
(
)
;
deviceContext
-
>
IASetVertexBuffers
(
start
static_cast
<
UINT
>
(
mDirtyVertexBufferRange
.
length
(
)
)
&
mCurrentVertexBuffers
[
start
]
&
mCurrentVertexStrides
[
start
]
&
mCurrentVertexOffsets
[
start
]
)
;
mDirtyVertexBufferRange
=
gl
:
:
RangeUI
(
gl
:
:
MAX_VERTEX_ATTRIBS
0
)
;
}
void
StateManager11
:
:
setSingleVertexBuffer
(
const
d3d11
:
:
Buffer
*
buffer
UINT
stride
UINT
offset
)
{
ID3D11Buffer
*
native
=
buffer
?
buffer
-
>
get
(
)
:
nullptr
;
if
(
queueVertexBufferChange
(
0
native
stride
offset
)
)
{
invalidateInputLayout
(
)
;
applyVertexBufferChanges
(
)
;
}
}
angle
:
:
Result
StateManager11
:
:
updateState
(
const
gl
:
:
Context
*
context
const
gl
:
:
DrawCallParams
&
drawCallParams
)
{
const
gl
:
:
State
&
glState
=
context
-
>
getGLState
(
)
;
if
(
mRenderTargetIsDirty
)
{
processFramebufferInvalidation
(
context
)
;
mRenderTargetIsDirty
=
false
;
}
if
(
mProgramD3D
-
>
updateSamplerMapping
(
)
=
=
ProgramD3D
:
:
SamplerMapping
:
:
WasDirty
)
{
invalidateTexturesAndSamplers
(
)
;
}
if
(
mProgramD3D
-
>
anyShaderUniformsDirty
(
)
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_PROGRAM_UNIFORMS
)
;
}
if
(
mDirtySwizzles
)
{
ANGLE_TRY
(
generateSwizzles
(
context
)
)
;
mDirtySwizzles
=
false
;
}
ANGLE_TRY
(
mFramebuffer11
-
>
markAttachmentsDirty
(
context
)
)
;
RenderTarget11
*
firstRT
=
mFramebuffer11
-
>
getFirstRenderTarget
(
)
;
int
samples
=
(
firstRT
?
firstRT
-
>
getSamples
(
)
:
0
)
;
unsigned
int
sampleMask
=
GetBlendSampleMask
(
glState
samples
)
;
if
(
sampleMask
!
=
mCurSampleMask
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_BLEND_STATE
)
;
}
ANGLE_TRY
(
mVertexArray11
-
>
syncStateForDraw
(
context
drawCallParams
)
)
;
if
(
!
mLastFirstVertex
.
valid
(
)
|
|
mLastFirstVertex
.
value
(
)
!
=
drawCallParams
.
firstVertex
(
)
)
{
mLastFirstVertex
=
drawCallParams
.
firstVertex
(
)
;
invalidateInputLayout
(
)
;
}
if
(
drawCallParams
.
isDrawElements
(
)
)
{
ANGLE_TRY
(
applyIndexBuffer
(
context
drawCallParams
)
)
;
}
if
(
mLastAppliedDrawMode
!
=
drawCallParams
.
mode
(
)
)
{
mLastAppliedDrawMode
=
drawCallParams
.
mode
(
)
;
mInternalDirtyBits
.
set
(
DIRTY_BIT_PRIMITIVE_TOPOLOGY
)
;
bool
pointDrawMode
=
(
drawCallParams
.
mode
(
)
=
=
gl
:
:
PrimitiveMode
:
:
Points
)
;
if
(
pointDrawMode
!
=
mCurRasterState
.
pointDrawMode
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_RASTERIZER_STATE
)
;
invalidateShaders
(
)
;
}
}
auto
dirtyBitsCopy
=
mInternalDirtyBits
;
mInternalDirtyBits
.
reset
(
)
;
for
(
auto
dirtyBit
:
dirtyBitsCopy
)
{
switch
(
dirtyBit
)
{
case
DIRTY_BIT_RENDER_TARGET
:
ANGLE_TRY
(
syncFramebuffer
(
context
)
)
;
break
;
case
DIRTY_BIT_VIEWPORT_STATE
:
syncViewport
(
context
)
;
break
;
case
DIRTY_BIT_SCISSOR_STATE
:
syncScissorRectangle
(
glState
.
getScissor
(
)
glState
.
isScissorTestEnabled
(
)
)
;
break
;
case
DIRTY_BIT_RASTERIZER_STATE
:
ANGLE_TRY
(
syncRasterizerState
(
context
drawCallParams
)
)
;
break
;
case
DIRTY_BIT_BLEND_STATE
:
ANGLE_TRY
(
syncBlendState
(
context
glState
.
getBlendState
(
)
glState
.
getBlendColor
(
)
sampleMask
)
)
;
break
;
case
DIRTY_BIT_DEPTH_STENCIL_STATE
:
ANGLE_TRY
(
syncDepthStencilState
(
context
)
)
;
break
;
case
DIRTY_BIT_TEXTURE_AND_SAMPLER_STATE
:
ANGLE_TRY
(
syncTextures
(
context
)
)
;
break
;
case
DIRTY_BIT_PROGRAM_UNIFORMS
:
ANGLE_TRY
(
applyUniforms
(
context
)
)
;
break
;
case
DIRTY_BIT_DRIVER_UNIFORMS
:
ANGLE_TRY
(
applyDriverUniforms
(
context
)
)
;
break
;
case
DIRTY_BIT_PROGRAM_UNIFORM_BUFFERS
:
ANGLE_TRY
(
syncUniformBuffers
(
context
)
)
;
break
;
case
DIRTY_BIT_SHADERS
:
ANGLE_TRY
(
syncProgram
(
context
drawCallParams
.
mode
(
)
)
)
;
break
;
case
DIRTY_BIT_CURRENT_VALUE_ATTRIBS
:
ANGLE_TRY
(
syncCurrentValueAttribs
(
context
glState
.
getVertexAttribCurrentValues
(
)
)
)
;
break
;
case
DIRTY_BIT_TRANSFORM_FEEDBACK
:
ANGLE_TRY
(
syncTransformFeedbackBuffers
(
context
)
)
;
break
;
case
DIRTY_BIT_VERTEX_BUFFERS_AND_INPUT_LAYOUT
:
ANGLE_TRY
(
syncVertexBuffersAndInputLayout
(
context
drawCallParams
)
)
;
break
;
case
DIRTY_BIT_PRIMITIVE_TOPOLOGY
:
syncPrimitiveTopology
(
glState
drawCallParams
.
mode
(
)
)
;
break
;
default
:
UNREACHABLE
(
)
;
break
;
}
}
ASSERT
(
mInternalDirtyBits
.
none
(
)
)
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
void
StateManager11
:
:
setShaderResourceShared
(
gl
:
:
ShaderType
shaderType
UINT
resourceSlot
const
d3d11
:
:
SharedSRV
*
srv
)
{
setShaderResourceInternal
(
shaderType
resourceSlot
srv
)
;
mInternalDirtyBits
.
set
(
DIRTY_BIT_TEXTURE_AND_SAMPLER_STATE
)
;
}
void
StateManager11
:
:
setShaderResource
(
gl
:
:
ShaderType
shaderType
UINT
resourceSlot
const
d3d11
:
:
ShaderResourceView
*
srv
)
{
setShaderResourceInternal
(
shaderType
resourceSlot
srv
)
;
mInternalDirtyBits
.
set
(
DIRTY_BIT_TEXTURE_AND_SAMPLER_STATE
)
;
}
void
StateManager11
:
:
setPrimitiveTopology
(
D3D11_PRIMITIVE_TOPOLOGY
primitiveTopology
)
{
if
(
setPrimitiveTopologyInternal
(
primitiveTopology
)
)
{
mInternalDirtyBits
.
set
(
DIRTY_BIT_PRIMITIVE_TOPOLOGY
)
;
}
}
bool
StateManager11
:
:
setPrimitiveTopologyInternal
(
D3D11_PRIMITIVE_TOPOLOGY
primitiveTopology
)
{
if
(
primitiveTopology
!
=
mCurrentPrimitiveTopology
)
{
mRenderer
-
>
getDeviceContext
(
)
-
>
IASetPrimitiveTopology
(
primitiveTopology
)
;
mCurrentPrimitiveTopology
=
primitiveTopology
;
return
true
;
}
else
{
return
false
;
}
}
void
StateManager11
:
:
setDrawShaders
(
const
d3d11
:
:
VertexShader
*
vertexShader
const
d3d11
:
:
GeometryShader
*
geometryShader
const
d3d11
:
:
PixelShader
*
pixelShader
)
{
setVertexShader
(
vertexShader
)
;
setGeometryShader
(
geometryShader
)
;
setPixelShader
(
pixelShader
)
;
}
void
StateManager11
:
:
setVertexShader
(
const
d3d11
:
:
VertexShader
*
shader
)
{
ResourceSerial
serial
=
shader
?
shader
-
>
getSerial
(
)
:
ResourceSerial
(
0
)
;
if
(
serial
!
=
mAppliedShaders
[
gl
:
:
ShaderType
:
:
Vertex
]
)
{
ID3D11VertexShader
*
appliedShader
=
shader
?
shader
-
>
get
(
)
:
nullptr
;
mRenderer
-
>
getDeviceContext
(
)
-
>
VSSetShader
(
appliedShader
nullptr
0
)
;
mAppliedShaders
[
gl
:
:
ShaderType
:
:
Vertex
]
=
serial
;
invalidateShaders
(
)
;
}
}
void
StateManager11
:
:
setGeometryShader
(
const
d3d11
:
:
GeometryShader
*
shader
)
{
ResourceSerial
serial
=
shader
?
shader
-
>
getSerial
(
)
:
ResourceSerial
(
0
)
;
if
(
serial
!
=
mAppliedShaders
[
gl
:
:
ShaderType
:
:
Geometry
]
)
{
ID3D11GeometryShader
*
appliedShader
=
shader
?
shader
-
>
get
(
)
:
nullptr
;
mRenderer
-
>
getDeviceContext
(
)
-
>
GSSetShader
(
appliedShader
nullptr
0
)
;
mAppliedShaders
[
gl
:
:
ShaderType
:
:
Geometry
]
=
serial
;
invalidateShaders
(
)
;
}
}
void
StateManager11
:
:
setPixelShader
(
const
d3d11
:
:
PixelShader
*
shader
)
{
ResourceSerial
serial
=
shader
?
shader
-
>
getSerial
(
)
:
ResourceSerial
(
0
)
;
if
(
serial
!
=
mAppliedShaders
[
gl
:
:
ShaderType
:
:
Fragment
]
)
{
ID3D11PixelShader
*
appliedShader
=
shader
?
shader
-
>
get
(
)
:
nullptr
;
mRenderer
-
>
getDeviceContext
(
)
-
>
PSSetShader
(
appliedShader
nullptr
0
)
;
mAppliedShaders
[
gl
:
:
ShaderType
:
:
Fragment
]
=
serial
;
invalidateShaders
(
)
;
}
}
void
StateManager11
:
:
setComputeShader
(
const
d3d11
:
:
ComputeShader
*
shader
)
{
ResourceSerial
serial
=
shader
?
shader
-
>
getSerial
(
)
:
ResourceSerial
(
0
)
;
if
(
serial
!
=
mAppliedShaders
[
gl
:
:
ShaderType
:
:
Compute
]
)
{
ID3D11ComputeShader
*
appliedShader
=
shader
?
shader
-
>
get
(
)
:
nullptr
;
mRenderer
-
>
getDeviceContext
(
)
-
>
CSSetShader
(
appliedShader
nullptr
0
)
;
mAppliedShaders
[
gl
:
:
ShaderType
:
:
Compute
]
=
serial
;
}
}
void
StateManager11
:
:
setVertexConstantBuffer
(
unsigned
int
slot
const
d3d11
:
:
Buffer
*
buffer
)
{
ID3D11DeviceContext
*
deviceContext
=
mRenderer
-
>
getDeviceContext
(
)
;
auto
&
currentSerial
=
mCurrentConstantBufferVS
[
slot
]
;
mCurrentConstantBufferVSOffset
[
slot
]
=
0
;
mCurrentConstantBufferVSSize
[
slot
]
=
0
;
if
(
buffer
)
{
if
(
currentSerial
!
=
buffer
-
>
getSerial
(
)
)
{
deviceContext
-
>
VSSetConstantBuffers
(
slot
1
buffer
-
>
getPointer
(
)
)
;
currentSerial
=
buffer
-
>
getSerial
(
)
;
invalidateConstantBuffer
(
slot
)
;
}
}
else
{
if
(
!
currentSerial
.
empty
(
)
)
{
ID3D11Buffer
*
nullBuffer
=
nullptr
;
deviceContext
-
>
VSSetConstantBuffers
(
slot
1
&
nullBuffer
)
;
currentSerial
.
clear
(
)
;
invalidateConstantBuffer
(
slot
)
;
}
}
}
void
StateManager11
:
:
setPixelConstantBuffer
(
unsigned
int
slot
const
d3d11
:
:
Buffer
*
buffer
)
{
ID3D11DeviceContext
*
deviceContext
=
mRenderer
-
>
getDeviceContext
(
)
;
auto
&
currentSerial
=
mCurrentConstantBufferPS
[
slot
]
;
mCurrentConstantBufferPSOffset
[
slot
]
=
0
;
mCurrentConstantBufferPSSize
[
slot
]
=
0
;
if
(
buffer
)
{
if
(
currentSerial
!
=
buffer
-
>
getSerial
(
)
)
{
deviceContext
-
>
PSSetConstantBuffers
(
slot
1
buffer
-
>
getPointer
(
)
)
;
currentSerial
=
buffer
-
>
getSerial
(
)
;
invalidateConstantBuffer
(
slot
)
;
}
}
else
{
if
(
!
currentSerial
.
empty
(
)
)
{
ID3D11Buffer
*
nullBuffer
=
nullptr
;
deviceContext
-
>
PSSetConstantBuffers
(
slot
1
&
nullBuffer
)
;
currentSerial
.
clear
(
)
;
invalidateConstantBuffer
(
slot
)
;
}
}
}
void
StateManager11
:
:
setDepthStencilState
(
const
d3d11
:
:
DepthStencilState
*
depthStencilState
UINT
stencilRef
)
{
ID3D11DeviceContext
*
deviceContext
=
mRenderer
-
>
getDeviceContext
(
)
;
if
(
depthStencilState
)
{
deviceContext
-
>
OMSetDepthStencilState
(
depthStencilState
-
>
get
(
)
stencilRef
)
;
}
else
{
deviceContext
-
>
OMSetDepthStencilState
(
nullptr
stencilRef
)
;
}
mInternalDirtyBits
.
set
(
DIRTY_BIT_DEPTH_STENCIL_STATE
)
;
}
void
StateManager11
:
:
setSimpleBlendState
(
const
d3d11
:
:
BlendState
*
blendState
)
{
ID3D11DeviceContext
*
deviceContext
=
mRenderer
-
>
getDeviceContext
(
)
;
if
(
blendState
)
{
deviceContext
-
>
OMSetBlendState
(
blendState
-
>
get
(
)
nullptr
0xFFFFFFFF
)
;
}
else
{
deviceContext
-
>
OMSetBlendState
(
nullptr
nullptr
0xFFFFFFFF
)
;
}
mInternalDirtyBits
.
set
(
DIRTY_BIT_BLEND_STATE
)
;
}
void
StateManager11
:
:
setRasterizerState
(
const
d3d11
:
:
RasterizerState
*
rasterizerState
)
{
ID3D11DeviceContext
*
deviceContext
=
mRenderer
-
>
getDeviceContext
(
)
;
if
(
rasterizerState
)
{
deviceContext
-
>
RSSetState
(
rasterizerState
-
>
get
(
)
)
;
}
else
{
deviceContext
-
>
RSSetState
(
nullptr
)
;
}
mInternalDirtyBits
.
set
(
DIRTY_BIT_RASTERIZER_STATE
)
;
}
void
StateManager11
:
:
setSimpleViewport
(
const
gl
:
:
Extents
&
extents
)
{
setSimpleViewport
(
extents
.
width
extents
.
height
)
;
}
void
StateManager11
:
:
setSimpleViewport
(
int
width
int
height
)
{
D3D11_VIEWPORT
viewport
;
viewport
.
TopLeftX
=
0
;
viewport
.
TopLeftY
=
0
;
viewport
.
Width
=
static_cast
<
FLOAT
>
(
width
)
;
viewport
.
Height
=
static_cast
<
FLOAT
>
(
height
)
;
viewport
.
MinDepth
=
0
.
0f
;
viewport
.
MaxDepth
=
1
.
0f
;
mRenderer
-
>
getDeviceContext
(
)
-
>
RSSetViewports
(
1
&
viewport
)
;
mInternalDirtyBits
.
set
(
DIRTY_BIT_VIEWPORT_STATE
)
;
}
void
StateManager11
:
:
setSimplePixelTextureAndSampler
(
const
d3d11
:
:
SharedSRV
&
srv
const
d3d11
:
:
SamplerState
&
samplerState
)
{
ID3D11DeviceContext
*
deviceContext
=
mRenderer
-
>
getDeviceContext
(
)
;
setShaderResourceInternal
(
gl
:
:
ShaderType
:
:
Fragment
0
&
srv
)
;
deviceContext
-
>
PSSetSamplers
(
0
1
samplerState
.
getPointer
(
)
)
;
mInternalDirtyBits
.
set
(
DIRTY_BIT_TEXTURE_AND_SAMPLER_STATE
)
;
mForceSetShaderSamplerStates
[
gl
:
:
ShaderType
:
:
Fragment
]
[
0
]
=
true
;
}
void
StateManager11
:
:
setSimpleScissorRect
(
const
gl
:
:
Rectangle
&
glRect
)
{
D3D11_RECT
scissorRect
;
scissorRect
.
left
=
glRect
.
x
;
scissorRect
.
right
=
glRect
.
x
+
glRect
.
width
;
scissorRect
.
top
=
glRect
.
y
;
scissorRect
.
bottom
=
glRect
.
y
+
glRect
.
height
;
setScissorRectD3D
(
scissorRect
)
;
}
void
StateManager11
:
:
setScissorRectD3D
(
const
D3D11_RECT
&
d3dRect
)
{
mRenderer
-
>
getDeviceContext
(
)
-
>
RSSetScissorRects
(
1
&
d3dRect
)
;
mInternalDirtyBits
.
set
(
DIRTY_BIT_SCISSOR_STATE
)
;
}
angle
:
:
Result
StateManager11
:
:
applyTexturesForSamplers
(
const
gl
:
:
Context
*
context
gl
:
:
ShaderType
shaderType
)
{
const
auto
&
glState
=
context
-
>
getGLState
(
)
;
const
auto
&
caps
=
context
-
>
getCaps
(
)
;
ASSERT
(
!
mProgramD3D
-
>
isSamplerMappingDirty
(
)
)
;
const
gl
:
:
ActiveTexturePointerArray
&
completeTextures
=
glState
.
getActiveTexturesCache
(
)
;
const
gl
:
:
RangeUI
samplerRange
=
mProgramD3D
-
>
getUsedSamplerRange
(
shaderType
)
;
for
(
unsigned
int
samplerIndex
=
samplerRange
.
low
(
)
;
samplerIndex
<
samplerRange
.
high
(
)
;
samplerIndex
+
+
)
{
GLint
textureUnit
=
mProgramD3D
-
>
getSamplerMapping
(
shaderType
samplerIndex
caps
)
;
ASSERT
(
textureUnit
!
=
-
1
)
;
gl
:
:
Texture
*
texture
=
completeTextures
[
textureUnit
]
;
if
(
texture
)
{
gl
:
:
Sampler
*
samplerObject
=
glState
.
getSampler
(
textureUnit
)
;
const
gl
:
:
SamplerState
&
samplerState
=
samplerObject
?
samplerObject
-
>
getSamplerState
(
)
:
texture
-
>
getSamplerState
(
)
;
ANGLE_TRY
(
setSamplerState
(
context
shaderType
samplerIndex
texture
samplerState
)
)
;
ANGLE_TRY
(
setTextureForSampler
(
context
shaderType
samplerIndex
texture
samplerState
)
)
;
}
else
{
gl
:
:
TextureType
textureType
=
mProgramD3D
-
>
getSamplerTextureType
(
shaderType
samplerIndex
)
;
gl
:
:
Texture
*
incompleteTexture
=
nullptr
;
ANGLE_TRY
(
mRenderer
-
>
getIncompleteTexture
(
context
textureType
&
incompleteTexture
)
)
;
ANGLE_TRY
(
setSamplerState
(
context
shaderType
samplerIndex
incompleteTexture
incompleteTexture
-
>
getSamplerState
(
)
)
)
;
ANGLE_TRY
(
setTextureForSampler
(
context
shaderType
samplerIndex
incompleteTexture
incompleteTexture
-
>
getSamplerState
(
)
)
)
;
}
}
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
syncTextures
(
const
gl
:
:
Context
*
context
)
{
ANGLE_TRY
(
applyTexturesForSamplers
(
context
gl
:
:
ShaderType
:
:
Vertex
)
)
;
ANGLE_TRY
(
applyTexturesForSamplers
(
context
gl
:
:
ShaderType
:
:
Fragment
)
)
;
if
(
mProgramD3D
-
>
hasShaderStage
(
gl
:
:
ShaderType
:
:
Geometry
)
)
{
ANGLE_TRY
(
applyTexturesForSamplers
(
context
gl
:
:
ShaderType
:
:
Geometry
)
)
;
}
const
auto
&
caps
=
context
-
>
getCaps
(
)
;
const
gl
:
:
RangeUI
vertexSamplerRange
=
mProgramD3D
-
>
getUsedSamplerRange
(
gl
:
:
ShaderType
:
:
Vertex
)
;
const
gl
:
:
RangeUI
fragmentSamplerRange
=
mProgramD3D
-
>
getUsedSamplerRange
(
gl
:
:
ShaderType
:
:
Fragment
)
;
size_t
vertexSamplerCount
=
caps
.
maxShaderTextureImageUnits
[
gl
:
:
ShaderType
:
:
Vertex
]
;
size_t
fragmentSamplerCount
=
caps
.
maxShaderTextureImageUnits
[
gl
:
:
ShaderType
:
:
Fragment
]
;
ANGLE_TRY
(
clearSRVs
(
gl
:
:
ShaderType
:
:
Vertex
vertexSamplerRange
.
high
(
)
vertexSamplerCount
)
)
;
ANGLE_TRY
(
clearSRVs
(
gl
:
:
ShaderType
:
:
Fragment
fragmentSamplerRange
.
high
(
)
fragmentSamplerCount
)
)
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
setSamplerState
(
const
gl
:
:
Context
*
context
gl
:
:
ShaderType
type
int
index
gl
:
:
Texture
*
texture
const
gl
:
:
SamplerState
&
samplerState
)
{
#
if
!
defined
(
NDEBUG
)
TextureD3D
*
textureD3D
=
GetImplAs
<
TextureD3D
>
(
texture
)
;
TextureStorage
*
storage
=
nullptr
;
ANGLE_TRY
(
textureD3D
-
>
getNativeTexture
(
context
&
storage
)
)
;
ASSERT
(
storage
)
;
#
endif
auto
*
deviceContext
=
mRenderer
-
>
getDeviceContext
(
)
;
ASSERT
(
static_cast
<
unsigned
int
>
(
index
)
<
mRenderer
-
>
getNativeCaps
(
)
.
maxShaderTextureImageUnits
[
type
]
)
;
if
(
mForceSetShaderSamplerStates
[
type
]
[
index
]
|
|
memcmp
(
&
samplerState
&
mCurShaderSamplerStates
[
type
]
[
index
]
sizeof
(
gl
:
:
SamplerState
)
)
!
=
0
)
{
ID3D11SamplerState
*
dxSamplerState
=
nullptr
;
ANGLE_TRY
(
mRenderer
-
>
getSamplerState
(
context
samplerState
&
dxSamplerState
)
)
;
ASSERT
(
dxSamplerState
!
=
nullptr
)
;
switch
(
type
)
{
case
gl
:
:
ShaderType
:
:
Vertex
:
deviceContext
-
>
VSSetSamplers
(
index
1
&
dxSamplerState
)
;
break
;
case
gl
:
:
ShaderType
:
:
Fragment
:
deviceContext
-
>
PSSetSamplers
(
index
1
&
dxSamplerState
)
;
break
;
case
gl
:
:
ShaderType
:
:
Compute
:
deviceContext
-
>
CSSetSamplers
(
index
1
&
dxSamplerState
)
;
break
;
case
gl
:
:
ShaderType
:
:
Geometry
:
deviceContext
-
>
GSSetSamplers
(
index
1
&
dxSamplerState
)
;
break
;
default
:
UNREACHABLE
(
)
;
break
;
}
mCurShaderSamplerStates
[
type
]
[
index
]
=
samplerState
;
}
mForceSetShaderSamplerStates
[
type
]
[
index
]
=
false
;
mShaderConstants
.
onSamplerChange
(
type
index
*
texture
)
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
setTextureForSampler
(
const
gl
:
:
Context
*
context
gl
:
:
ShaderType
type
int
index
gl
:
:
Texture
*
texture
const
gl
:
:
SamplerState
&
sampler
)
{
const
d3d11
:
:
SharedSRV
*
textureSRV
=
nullptr
;
if
(
texture
)
{
TextureD3D
*
textureImpl
=
GetImplAs
<
TextureD3D
>
(
texture
)
;
TextureStorage
*
texStorage
=
nullptr
;
ANGLE_TRY
(
textureImpl
-
>
getNativeTexture
(
context
&
texStorage
)
)
;
ASSERT
(
texStorage
)
;
TextureStorage11
*
storage11
=
GetAs
<
TextureStorage11
>
(
texStorage
)
;
ANGLE_TRY
(
storage11
-
>
getSRVForSampler
(
context
texture
-
>
getTextureState
(
)
sampler
&
textureSRV
)
)
;
ASSERT
(
textureSRV
-
>
valid
(
)
)
;
textureImpl
-
>
resetDirty
(
)
;
}
ASSERT
(
(
type
=
=
gl
:
:
ShaderType
:
:
Fragment
&
&
static_cast
<
unsigned
int
>
(
index
)
<
mRenderer
-
>
getNativeCaps
(
)
.
maxShaderTextureImageUnits
[
gl
:
:
ShaderType
:
:
Fragment
]
)
|
|
(
type
=
=
gl
:
:
ShaderType
:
:
Vertex
&
&
static_cast
<
unsigned
int
>
(
index
)
<
mRenderer
-
>
getNativeCaps
(
)
.
maxShaderTextureImageUnits
[
gl
:
:
ShaderType
:
:
Vertex
]
)
|
|
(
type
=
=
gl
:
:
ShaderType
:
:
Compute
&
&
static_cast
<
unsigned
int
>
(
index
)
<
mRenderer
-
>
getNativeCaps
(
)
.
maxShaderTextureImageUnits
[
gl
:
:
ShaderType
:
:
Compute
]
)
)
;
setShaderResourceInternal
(
type
index
textureSRV
)
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
applyTexturesForImages
(
const
gl
:
:
Context
*
context
gl
:
:
ShaderType
shaderType
)
{
ASSERT
(
shaderType
=
=
gl
:
:
ShaderType
:
:
Compute
)
;
const
auto
&
glState
=
context
-
>
getGLState
(
)
;
const
auto
&
caps
=
context
-
>
getCaps
(
)
;
const
gl
:
:
RangeUI
readonlyImageRange
=
mProgramD3D
-
>
getUsedImageRange
(
shaderType
true
)
;
for
(
unsigned
int
readonlyImageIndex
=
readonlyImageRange
.
low
(
)
;
readonlyImageIndex
<
readonlyImageRange
.
high
(
)
;
readonlyImageIndex
+
+
)
{
GLint
imageUnitIndex
=
mProgramD3D
-
>
getImageMapping
(
shaderType
readonlyImageIndex
true
caps
)
;
ASSERT
(
imageUnitIndex
!
=
-
1
)
;
const
gl
:
:
ImageUnit
&
imageUnit
=
glState
.
getImageUnit
(
imageUnitIndex
)
;
ANGLE_TRY
(
setTextureForImage
(
context
shaderType
readonlyImageIndex
true
imageUnit
)
)
;
}
const
gl
:
:
RangeUI
imageRange
=
mProgramD3D
-
>
getUsedImageRange
(
shaderType
false
)
;
for
(
unsigned
int
imageIndex
=
imageRange
.
low
(
)
;
imageIndex
<
imageRange
.
high
(
)
;
imageIndex
+
+
)
{
GLint
imageUnitIndex
=
mProgramD3D
-
>
getImageMapping
(
shaderType
imageIndex
false
caps
)
;
ASSERT
(
imageUnitIndex
!
=
-
1
)
;
const
gl
:
:
ImageUnit
&
imageUnit
=
glState
.
getImageUnit
(
imageUnitIndex
)
;
ANGLE_TRY
(
setTextureForImage
(
context
shaderType
imageIndex
false
imageUnit
)
)
;
}
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
syncTexturesForCompute
(
const
gl
:
:
Context
*
context
)
{
ANGLE_TRY
(
applyTexturesForSamplers
(
context
gl
:
:
ShaderType
:
:
Compute
)
)
;
ANGLE_TRY
(
applyTexturesForImages
(
context
gl
:
:
ShaderType
:
:
Compute
)
)
;
const
auto
&
caps
=
context
-
>
getCaps
(
)
;
const
gl
:
:
RangeUI
samplerRange
=
mProgramD3D
-
>
getUsedSamplerRange
(
gl
:
:
ShaderType
:
:
Compute
)
;
const
gl
:
:
RangeUI
readonlyImageRange
=
mProgramD3D
-
>
getUsedImageRange
(
gl
:
:
ShaderType
:
:
Compute
true
)
;
const
gl
:
:
RangeUI
imageRange
=
mProgramD3D
-
>
getUsedImageRange
(
gl
:
:
ShaderType
:
:
Compute
false
)
;
size_t
samplerCount
=
caps
.
maxShaderTextureImageUnits
[
gl
:
:
ShaderType
:
:
Compute
]
;
size_t
readonlyImageCount
=
caps
.
maxImageUnits
;
size_t
imageCount
=
caps
.
maxImageUnits
;
ANGLE_TRY
(
clearSRVs
(
gl
:
:
ShaderType
:
:
Compute
std
:
:
max
(
samplerRange
.
high
(
)
readonlyImageRange
.
high
(
)
)
samplerCount
+
readonlyImageCount
)
)
;
ANGLE_TRY
(
clearUAVs
(
gl
:
:
ShaderType
:
:
Compute
imageRange
.
high
(
)
imageCount
)
)
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
setTextureForImage
(
const
gl
:
:
Context
*
context
gl
:
:
ShaderType
type
int
index
bool
readonly
const
gl
:
:
ImageUnit
&
imageUnit
)
{
TextureD3D
*
textureImpl
=
nullptr
;
if
(
!
imageUnit
.
texture
.
get
(
)
)
{
return
angle
:
:
Result
:
:
Continue
(
)
;
}
textureImpl
=
GetImplAs
<
TextureD3D
>
(
imageUnit
.
texture
.
get
(
)
)
;
TextureStorage
*
texStorage
=
nullptr
;
ANGLE_TRY
(
textureImpl
-
>
getNativeTexture
(
context
&
texStorage
)
)
;
ASSERT
(
texStorage
)
;
TextureStorage11
*
storage11
=
GetAs
<
TextureStorage11
>
(
texStorage
)
;
if
(
readonly
)
{
const
d3d11
:
:
SharedSRV
*
textureSRV
=
nullptr
;
ANGLE_TRY
(
storage11
-
>
getSRVForImage
(
context
imageUnit
&
textureSRV
)
)
;
ASSERT
(
textureSRV
-
>
valid
(
)
)
;
ASSERT
(
(
static_cast
<
unsigned
int
>
(
index
)
<
mRenderer
-
>
getNativeCaps
(
)
.
maxImageUnits
)
)
;
setShaderResourceInternal
(
type
index
textureSRV
)
;
}
else
{
const
d3d11
:
:
SharedUAV
*
textureUAV
=
nullptr
;
ANGLE_TRY
(
storage11
-
>
getUAVForImage
(
context
imageUnit
&
textureUAV
)
)
;
ASSERT
(
textureUAV
-
>
valid
(
)
)
;
ASSERT
(
(
static_cast
<
unsigned
int
>
(
index
)
<
mRenderer
-
>
getNativeCaps
(
)
.
maxImageUnits
)
)
;
setUnorderedAccessViewInternal
(
type
index
textureUAV
)
;
}
textureImpl
-
>
resetDirty
(
)
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
syncProgram
(
const
gl
:
:
Context
*
context
gl
:
:
PrimitiveMode
drawMode
)
{
Context11
*
context11
=
GetImplAs
<
Context11
>
(
context
)
;
ANGLE_TRY
(
context11
-
>
triggerDrawCallProgramRecompilation
(
context
drawMode
)
)
;
const
auto
&
glState
=
context
-
>
getGLState
(
)
;
mProgramD3D
-
>
updateCachedInputLayout
(
mVertexArray11
-
>
getCurrentStateSerial
(
)
glState
)
;
ASSERT
(
mProgramD3D
-
>
hasVertexExecutableForCachedInputLayout
(
)
)
;
ASSERT
(
mProgramD3D
-
>
hasGeometryExecutableForPrimitiveType
(
context
drawMode
)
)
;
ASSERT
(
mProgramD3D
-
>
hasPixelExecutableForCachedOutputLayout
(
)
)
;
ShaderExecutableD3D
*
vertexExe
=
nullptr
;
ANGLE_TRY
(
mProgramD3D
-
>
getVertexExecutableForCachedInputLayout
(
context
&
vertexExe
nullptr
)
)
;
ShaderExecutableD3D
*
pixelExe
=
nullptr
;
ANGLE_TRY
(
mProgramD3D
-
>
getPixelExecutableForCachedOutputLayout
(
context
&
pixelExe
nullptr
)
)
;
ShaderExecutableD3D
*
geometryExe
=
nullptr
;
ANGLE_TRY
(
mProgramD3D
-
>
getGeometryExecutableForPrimitiveType
(
context
drawMode
&
geometryExe
nullptr
)
)
;
const
d3d11
:
:
VertexShader
*
vertexShader
=
(
vertexExe
?
&
GetAs
<
ShaderExecutable11
>
(
vertexExe
)
-
>
getVertexShader
(
)
:
nullptr
)
;
const
d3d11
:
:
PixelShader
*
pixelShader
=
nullptr
;
if
(
!
glState
.
getRasterizerState
(
)
.
rasterizerDiscard
)
{
pixelShader
=
(
pixelExe
?
&
GetAs
<
ShaderExecutable11
>
(
pixelExe
)
-
>
getPixelShader
(
)
:
nullptr
)
;
}
const
d3d11
:
:
GeometryShader
*
geometryShader
=
nullptr
;
if
(
glState
.
isTransformFeedbackActiveUnpaused
(
)
)
{
geometryShader
=
(
vertexExe
?
&
GetAs
<
ShaderExecutable11
>
(
vertexExe
)
-
>
getStreamOutShader
(
)
:
nullptr
)
;
}
else
{
geometryShader
=
(
geometryExe
?
&
GetAs
<
ShaderExecutable11
>
(
geometryExe
)
-
>
getGeometryShader
(
)
:
nullptr
)
;
}
setDrawShaders
(
vertexShader
geometryShader
pixelShader
)
;
mInternalDirtyBits
.
reset
(
DIRTY_BIT_SHADERS
)
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
syncVertexBuffersAndInputLayout
(
const
gl
:
:
Context
*
context
const
gl
:
:
DrawCallParams
&
drawCallParams
)
{
const
auto
&
vertexArrayAttribs
=
mVertexArray11
-
>
getTranslatedAttribs
(
)
;
AttribIndexArray
sortedSemanticIndices
;
SortAttributesByLayout
(
*
mProgramD3D
vertexArrayAttribs
mCurrentValueAttribs
&
sortedSemanticIndices
&
mCurrentAttributes
)
;
D3D_FEATURE_LEVEL
featureLevel
=
mRenderer
-
>
getRenderer11DeviceCaps
(
)
.
featureLevel
;
if
(
featureLevel
<
=
D3D_FEATURE_LEVEL_9_3
&
&
!
mCurrentAttributes
.
empty
(
)
)
{
if
(
mCurrentAttributes
[
0
]
-
>
divisor
>
0
)
{
Optional
<
size_t
>
firstNonInstancedIndex
=
FindFirstNonInstanced
(
mCurrentAttributes
)
;
if
(
firstNonInstancedIndex
.
valid
(
)
)
{
size_t
index
=
firstNonInstancedIndex
.
value
(
)
;
std
:
:
swap
(
mCurrentAttributes
[
0
]
mCurrentAttributes
[
index
]
)
;
std
:
:
swap
(
sortedSemanticIndices
[
0
]
sortedSemanticIndices
[
index
]
)
;
}
}
}
const
gl
:
:
State
&
state
=
context
-
>
getGLState
(
)
;
const
d3d11
:
:
InputLayout
*
inputLayout
=
nullptr
;
ANGLE_TRY
(
mInputLayoutCache
.
getInputLayout
(
context
mRenderer
state
mCurrentAttributes
sortedSemanticIndices
drawCallParams
&
inputLayout
)
)
;
setInputLayoutInternal
(
inputLayout
)
;
ANGLE_TRY
(
applyVertexBuffers
(
context
drawCallParams
)
)
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
applyVertexBuffers
(
const
gl
:
:
Context
*
context
const
gl
:
:
DrawCallParams
&
drawCallParams
)
{
bool
programUsesInstancedPointSprites
=
mProgramD3D
-
>
usesPointSize
(
)
&
&
mProgramD3D
-
>
usesInstancedPointSpriteEmulation
(
)
;
bool
instancedPointSpritesActive
=
programUsesInstancedPointSprites
&
&
(
drawCallParams
.
mode
(
)
=
=
gl
:
:
PrimitiveMode
:
:
Points
)
;
size_t
reservedBuffers
=
GetReservedBufferCount
(
programUsesInstancedPointSprites
)
;
for
(
size_t
attribIndex
=
0
;
attribIndex
<
(
gl
:
:
MAX_VERTEX_ATTRIBS
-
reservedBuffers
)
;
+
+
attribIndex
)
{
ID3D11Buffer
*
buffer
=
nullptr
;
UINT
vertexStride
=
0
;
UINT
vertexOffset
=
0
;
if
(
attribIndex
<
mCurrentAttributes
.
size
(
)
)
{
const
TranslatedAttribute
&
attrib
=
*
mCurrentAttributes
[
attribIndex
]
;
Buffer11
*
bufferStorage
=
attrib
.
storage
?
GetAs
<
Buffer11
>
(
attrib
.
storage
)
:
nullptr
;
if
(
bufferStorage
=
=
nullptr
)
{
ASSERT
(
attrib
.
vertexBuffer
.
get
(
)
)
;
buffer
=
GetAs
<
VertexBuffer11
>
(
attrib
.
vertexBuffer
.
get
(
)
)
-
>
getBuffer
(
)
.
get
(
)
;
}
else
if
(
instancedPointSpritesActive
&
&
drawCallParams
.
isDrawElements
(
)
)
{
ASSERT
(
mVertexArray11
-
>
isCachedIndexInfoValid
(
)
)
;
TranslatedIndexData
indexInfo
=
mVertexArray11
-
>
getCachedIndexInfo
(
)
;
if
(
indexInfo
.
srcIndexData
.
srcBuffer
!
=
nullptr
)
{
const
uint8_t
*
bufferData
=
nullptr
;
ANGLE_TRY
(
indexInfo
.
srcIndexData
.
srcBuffer
-
>
getData
(
context
&
bufferData
)
)
;
ASSERT
(
bufferData
!
=
nullptr
)
;
ptrdiff_t
offset
=
reinterpret_cast
<
ptrdiff_t
>
(
indexInfo
.
srcIndexData
.
srcIndices
)
;
indexInfo
.
srcIndexData
.
srcBuffer
=
nullptr
;
indexInfo
.
srcIndexData
.
srcIndices
=
bufferData
+
offset
;
}
ANGLE_TRY
(
bufferStorage
-
>
getEmulatedIndexedBuffer
(
context
&
indexInfo
.
srcIndexData
attrib
drawCallParams
.
firstVertex
(
)
&
buffer
)
)
;
mVertexArray11
-
>
updateCachedIndexInfo
(
indexInfo
)
;
}
else
{
ANGLE_TRY
(
bufferStorage
-
>
getBuffer
(
context
BUFFER_USAGE_VERTEX_OR_TRANSFORM_FEEDBACK
&
buffer
)
)
;
}
vertexStride
=
attrib
.
stride
;
ANGLE_TRY
(
attrib
.
computeOffset
(
context
drawCallParams
.
firstVertex
(
)
&
vertexOffset
)
)
;
}
size_t
bufferIndex
=
reservedBuffers
+
attribIndex
;
queueVertexBufferChange
(
bufferIndex
buffer
vertexStride
vertexOffset
)
;
}
Context11
*
context11
=
GetImplAs
<
Context11
>
(
context
)
;
if
(
programUsesInstancedPointSprites
)
{
constexpr
UINT
kPointSpriteVertexStride
=
sizeof
(
float
)
*
5
;
if
(
!
mPointSpriteVertexBuffer
.
valid
(
)
)
{
static
constexpr
float
kPointSpriteVertices
[
]
=
{
-
1
.
0f
-
1
.
0f
0
.
0f
0
.
0f
1
.
0f
-
1
.
0f
1
.
0f
0
.
0f
0
.
0f
0
.
0f
1
.
0f
1
.
0f
0
.
0f
1
.
0f
0
.
0f
1
.
0f
-
1
.
0f
0
.
0f
1
.
0f
1
.
0f
-
1
.
0f
-
1
.
0f
0
.
0f
0
.
0f
1
.
0f
1
.
0f
1
.
0f
0
.
0f
1
.
0f
0
.
0f
}
;
D3D11_SUBRESOURCE_DATA
vertexBufferData
=
{
kPointSpriteVertices
0
0
}
;
D3D11_BUFFER_DESC
vertexBufferDesc
;
vertexBufferDesc
.
ByteWidth
=
sizeof
(
kPointSpriteVertices
)
;
vertexBufferDesc
.
BindFlags
=
D3D11_BIND_VERTEX_BUFFER
;
vertexBufferDesc
.
Usage
=
D3D11_USAGE_IMMUTABLE
;
vertexBufferDesc
.
CPUAccessFlags
=
0
;
vertexBufferDesc
.
MiscFlags
=
0
;
vertexBufferDesc
.
StructureByteStride
=
0
;
ANGLE_TRY
(
mRenderer
-
>
allocateResource
(
context11
vertexBufferDesc
&
vertexBufferData
&
mPointSpriteVertexBuffer
)
)
;
}
UINT
stride
=
instancedPointSpritesActive
?
kPointSpriteVertexStride
:
0
;
queueVertexBufferChange
(
0
mPointSpriteVertexBuffer
.
get
(
)
stride
0
)
;
if
(
!
mPointSpriteIndexBuffer
.
valid
(
)
)
{
static
constexpr
unsigned
short
kPointSpriteIndices
[
]
=
{
0
1
2
3
4
5
}
;
D3D11_SUBRESOURCE_DATA
indexBufferData
=
{
kPointSpriteIndices
0
0
}
;
D3D11_BUFFER_DESC
indexBufferDesc
;
indexBufferDesc
.
ByteWidth
=
sizeof
(
kPointSpriteIndices
)
;
indexBufferDesc
.
BindFlags
=
D3D11_BIND_INDEX_BUFFER
;
indexBufferDesc
.
Usage
=
D3D11_USAGE_IMMUTABLE
;
indexBufferDesc
.
CPUAccessFlags
=
0
;
indexBufferDesc
.
MiscFlags
=
0
;
indexBufferDesc
.
StructureByteStride
=
0
;
ANGLE_TRY
(
mRenderer
-
>
allocateResource
(
context11
indexBufferDesc
&
indexBufferData
&
mPointSpriteIndexBuffer
)
)
;
}
if
(
instancedPointSpritesActive
)
{
syncIndexBuffer
(
mPointSpriteIndexBuffer
.
get
(
)
DXGI_FORMAT_R16_UINT
0
)
;
}
}
applyVertexBufferChanges
(
)
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
applyIndexBuffer
(
const
gl
:
:
Context
*
context
const
gl
:
:
DrawCallParams
&
params
)
{
if
(
!
mIndexBufferIsDirty
)
{
return
angle
:
:
Result
:
:
Continue
(
)
;
}
GLenum
destElementType
=
mVertexArray11
-
>
getCachedDestinationIndexType
(
)
;
gl
:
:
Buffer
*
elementArrayBuffer
=
mVertexArray11
-
>
getState
(
)
.
getElementArrayBuffer
(
)
.
get
(
)
;
TranslatedIndexData
indexInfo
;
ANGLE_TRY
(
mIndexDataManager
.
prepareIndexData
(
context
params
.
type
(
)
destElementType
params
.
indexCount
(
)
elementArrayBuffer
params
.
indices
(
)
&
indexInfo
)
)
;
ID3D11Buffer
*
buffer
=
nullptr
;
DXGI_FORMAT
bufferFormat
=
(
indexInfo
.
indexType
=
=
GL_UNSIGNED_INT
)
?
DXGI_FORMAT_R32_UINT
:
DXGI_FORMAT_R16_UINT
;
if
(
indexInfo
.
storage
)
{
Buffer11
*
storage
=
GetAs
<
Buffer11
>
(
indexInfo
.
storage
)
;
ANGLE_TRY
(
storage
-
>
getBuffer
(
context
BUFFER_USAGE_INDEX
&
buffer
)
)
;
}
else
{
IndexBuffer11
*
indexBuffer
=
GetAs
<
IndexBuffer11
>
(
indexInfo
.
indexBuffer
)
;
buffer
=
indexBuffer
-
>
getBuffer
(
)
.
get
(
)
;
}
indexInfo
.
srcIndexData
.
srcIndicesChanged
=
syncIndexBuffer
(
buffer
bufferFormat
indexInfo
.
startOffset
)
;
mIndexBufferIsDirty
=
false
;
mVertexArray11
-
>
updateCachedIndexInfo
(
indexInfo
)
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
void
StateManager11
:
:
setIndexBuffer
(
ID3D11Buffer
*
buffer
DXGI_FORMAT
indexFormat
unsigned
int
offset
)
{
if
(
syncIndexBuffer
(
buffer
indexFormat
offset
)
)
{
invalidateIndexBuffer
(
)
;
}
}
bool
StateManager11
:
:
syncIndexBuffer
(
ID3D11Buffer
*
buffer
DXGI_FORMAT
indexFormat
unsigned
int
offset
)
{
if
(
buffer
!
=
mAppliedIB
|
|
indexFormat
!
=
mAppliedIBFormat
|
|
offset
!
=
mAppliedIBOffset
)
{
mRenderer
-
>
getDeviceContext
(
)
-
>
IASetIndexBuffer
(
buffer
indexFormat
offset
)
;
mAppliedIB
=
buffer
;
mAppliedIBFormat
=
indexFormat
;
mAppliedIBOffset
=
offset
;
return
true
;
}
return
false
;
}
angle
:
:
Result
StateManager11
:
:
updateVertexOffsetsForPointSpritesEmulation
(
const
gl
:
:
Context
*
context
GLint
startVertex
GLsizei
emulatedInstanceId
)
{
size_t
reservedBuffers
=
GetReservedBufferCount
(
true
)
;
for
(
size_t
attribIndex
=
0
;
attribIndex
<
mCurrentAttributes
.
size
(
)
;
+
+
attribIndex
)
{
const
auto
&
attrib
=
*
mCurrentAttributes
[
attribIndex
]
;
size_t
bufferIndex
=
reservedBuffers
+
attribIndex
;
if
(
attrib
.
divisor
>
0
)
{
unsigned
int
offset
=
0
;
ANGLE_TRY
(
attrib
.
computeOffset
(
context
startVertex
&
offset
)
)
;
offset
+
=
(
attrib
.
stride
*
(
emulatedInstanceId
/
attrib
.
divisor
)
)
;
if
(
offset
!
=
mCurrentVertexOffsets
[
bufferIndex
]
)
{
invalidateInputLayout
(
)
;
mDirtyVertexBufferRange
.
extend
(
static_cast
<
unsigned
int
>
(
bufferIndex
)
)
;
mCurrentVertexOffsets
[
bufferIndex
]
=
offset
;
}
}
}
applyVertexBufferChanges
(
)
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
generateSwizzle
(
const
gl
:
:
Context
*
context
gl
:
:
Texture
*
texture
)
{
if
(
!
texture
)
{
return
angle
:
:
Result
:
:
Continue
(
)
;
}
TextureD3D
*
textureD3D
=
GetImplAs
<
TextureD3D
>
(
texture
)
;
ASSERT
(
textureD3D
)
;
TextureStorage
*
texStorage
=
nullptr
;
ANGLE_TRY
(
textureD3D
-
>
getNativeTexture
(
context
&
texStorage
)
)
;
if
(
texStorage
)
{
TextureStorage11
*
storage11
=
GetAs
<
TextureStorage11
>
(
texStorage
)
;
const
gl
:
:
TextureState
&
textureState
=
texture
-
>
getTextureState
(
)
;
ANGLE_TRY
(
storage11
-
>
generateSwizzles
(
context
textureState
.
getSwizzleState
(
)
)
)
;
}
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
generateSwizzlesForShader
(
const
gl
:
:
Context
*
context
gl
:
:
ShaderType
type
)
{
const
gl
:
:
State
&
glState
=
context
-
>
getGLState
(
)
;
const
gl
:
:
RangeUI
samplerRange
=
mProgramD3D
-
>
getUsedSamplerRange
(
type
)
;
for
(
unsigned
int
i
=
samplerRange
.
low
(
)
;
i
<
samplerRange
.
high
(
)
;
i
+
+
)
{
gl
:
:
TextureType
textureType
=
mProgramD3D
-
>
getSamplerTextureType
(
type
i
)
;
GLint
textureUnit
=
mProgramD3D
-
>
getSamplerMapping
(
type
i
context
-
>
getCaps
(
)
)
;
if
(
textureUnit
!
=
-
1
)
{
gl
:
:
Texture
*
texture
=
glState
.
getSamplerTexture
(
textureUnit
textureType
)
;
ASSERT
(
texture
)
;
if
(
texture
-
>
getTextureState
(
)
.
swizzleRequired
(
)
)
{
ANGLE_TRY
(
generateSwizzle
(
context
texture
)
)
;
}
}
}
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
generateSwizzles
(
const
gl
:
:
Context
*
context
)
{
ANGLE_TRY
(
generateSwizzlesForShader
(
context
gl
:
:
ShaderType
:
:
Vertex
)
)
;
ANGLE_TRY
(
generateSwizzlesForShader
(
context
gl
:
:
ShaderType
:
:
Fragment
)
)
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
applyUniformsForShader
(
const
gl
:
:
Context
*
context
gl
:
:
ShaderType
shaderType
)
{
UniformStorage11
*
shaderUniformStorage
=
GetAs
<
UniformStorage11
>
(
mProgramD3D
-
>
getShaderUniformStorage
(
shaderType
)
)
;
ASSERT
(
shaderUniformStorage
)
;
ID3D11DeviceContext
*
deviceContext
=
mRenderer
-
>
getDeviceContext
(
)
;
const
d3d11
:
:
Buffer
*
shaderConstantBuffer
=
nullptr
;
ANGLE_TRY
(
shaderUniformStorage
-
>
getConstantBuffer
(
context
mRenderer
&
shaderConstantBuffer
)
)
;
if
(
shaderUniformStorage
-
>
size
(
)
>
0
&
&
mProgramD3D
-
>
areShaderUniformsDirty
(
shaderType
)
)
{
UpdateUniformBuffer
(
deviceContext
shaderUniformStorage
shaderConstantBuffer
)
;
}
unsigned
int
slot
=
d3d11
:
:
RESERVED_CONSTANT_BUFFER_SLOT_DEFAULT_UNIFORM_BLOCK
;
switch
(
shaderType
)
{
case
gl
:
:
ShaderType
:
:
Vertex
:
if
(
mCurrentConstantBufferVS
[
slot
]
!
=
shaderConstantBuffer
-
>
getSerial
(
)
)
{
deviceContext
-
>
VSSetConstantBuffers
(
slot
1
shaderConstantBuffer
-
>
getPointer
(
)
)
;
mCurrentConstantBufferVS
[
slot
]
=
shaderConstantBuffer
-
>
getSerial
(
)
;
mCurrentConstantBufferVSOffset
[
slot
]
=
0
;
mCurrentConstantBufferVSSize
[
slot
]
=
0
;
}
break
;
case
gl
:
:
ShaderType
:
:
Fragment
:
if
(
mCurrentConstantBufferPS
[
slot
]
!
=
shaderConstantBuffer
-
>
getSerial
(
)
)
{
deviceContext
-
>
PSSetConstantBuffers
(
slot
1
shaderConstantBuffer
-
>
getPointer
(
)
)
;
mCurrentConstantBufferPS
[
slot
]
=
shaderConstantBuffer
-
>
getSerial
(
)
;
mCurrentConstantBufferPSOffset
[
slot
]
=
0
;
mCurrentConstantBufferPSSize
[
slot
]
=
0
;
}
break
;
case
gl
:
:
ShaderType
:
:
Geometry
:
UNIMPLEMENTED
(
)
;
break
;
default
:
UNREACHABLE
(
)
;
break
;
}
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
applyUniforms
(
const
gl
:
:
Context
*
context
)
{
ANGLE_TRY
(
applyUniformsForShader
(
context
gl
:
:
ShaderType
:
:
Vertex
)
)
;
ANGLE_TRY
(
applyUniformsForShader
(
context
gl
:
:
ShaderType
:
:
Fragment
)
)
;
if
(
mProgramD3D
-
>
hasShaderStage
(
gl
:
:
ShaderType
:
:
Geometry
)
)
{
ANGLE_TRY
(
applyUniformsForShader
(
context
gl
:
:
ShaderType
:
:
Geometry
)
)
;
}
mProgramD3D
-
>
markUniformsClean
(
)
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
applyDriverUniformsForShader
(
const
gl
:
:
Context
*
context
gl
:
:
ShaderType
shaderType
)
{
ID3D11DeviceContext
*
deviceContext
=
mRenderer
-
>
getDeviceContext
(
)
;
d3d11
:
:
Buffer
&
shaderDriverConstantBuffer
=
mShaderDriverConstantBuffers
[
shaderType
]
;
if
(
!
shaderDriverConstantBuffer
.
valid
(
)
)
{
size_t
requiredSize
=
mShaderConstants
.
getRequiredBufferSize
(
shaderType
)
;
D3D11_BUFFER_DESC
constantBufferDescription
=
{
0
}
;
d3d11
:
:
InitConstantBufferDesc
(
&
constantBufferDescription
requiredSize
)
;
ANGLE_TRY
(
mRenderer
-
>
allocateResource
(
GetImplAs
<
Context11
>
(
context
)
constantBufferDescription
&
shaderDriverConstantBuffer
)
)
;
ID3D11Buffer
*
driverConstants
=
shaderDriverConstantBuffer
.
get
(
)
;
switch
(
shaderType
)
{
case
gl
:
:
ShaderType
:
:
Vertex
:
deviceContext
-
>
VSSetConstantBuffers
(
d3d11
:
:
RESERVED_CONSTANT_BUFFER_SLOT_DRIVER
1
&
driverConstants
)
;
break
;
case
gl
:
:
ShaderType
:
:
Fragment
:
deviceContext
-
>
PSSetConstantBuffers
(
d3d11
:
:
RESERVED_CONSTANT_BUFFER_SLOT_DRIVER
1
&
driverConstants
)
;
break
;
case
gl
:
:
ShaderType
:
:
Geometry
:
deviceContext
-
>
GSSetConstantBuffers
(
d3d11
:
:
RESERVED_CONSTANT_BUFFER_SLOT_DRIVER
1
&
driverConstants
)
;
break
;
default
:
UNREACHABLE
(
)
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
}
ANGLE_TRY
(
mShaderConstants
.
updateBuffer
(
context
mRenderer
shaderType
*
mProgramD3D
shaderDriverConstantBuffer
)
)
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
applyDriverUniforms
(
const
gl
:
:
Context
*
context
)
{
ID3D11DeviceContext
*
deviceContext
=
mRenderer
-
>
getDeviceContext
(
)
;
ANGLE_TRY
(
applyDriverUniformsForShader
(
context
gl
:
:
ShaderType
:
:
Vertex
)
)
;
ANGLE_TRY
(
applyDriverUniformsForShader
(
context
gl
:
:
ShaderType
:
:
Fragment
)
)
;
if
(
mProgramD3D
-
>
hasShaderStage
(
gl
:
:
ShaderType
:
:
Geometry
)
)
{
ANGLE_TRY
(
applyDriverUniformsForShader
(
context
gl
:
:
ShaderType
:
:
Geometry
)
)
;
}
if
(
mRenderer
-
>
isES3Capable
(
)
)
{
d3d11
:
:
Buffer
&
driverConstantBufferPS
=
mShaderDriverConstantBuffers
[
gl
:
:
ShaderType
:
:
Fragment
]
;
if
(
mCurrentGeometryConstantBuffer
!
=
driverConstantBufferPS
.
getSerial
(
)
)
{
ASSERT
(
driverConstantBufferPS
.
valid
(
)
)
;
deviceContext
-
>
GSSetConstantBuffers
(
0
1
driverConstantBufferPS
.
getPointer
(
)
)
;
mCurrentGeometryConstantBuffer
=
driverConstantBufferPS
.
getSerial
(
)
;
}
}
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
applyComputeUniforms
(
const
gl
:
:
Context
*
context
ProgramD3D
*
programD3D
)
{
UniformStorage11
*
computeUniformStorage
=
GetAs
<
UniformStorage11
>
(
programD3D
-
>
getShaderUniformStorage
(
gl
:
:
ShaderType
:
:
Compute
)
)
;
ASSERT
(
computeUniformStorage
)
;
const
d3d11
:
:
Buffer
*
constantBuffer
=
nullptr
;
ANGLE_TRY
(
computeUniformStorage
-
>
getConstantBuffer
(
context
mRenderer
&
constantBuffer
)
)
;
ID3D11DeviceContext
*
deviceContext
=
mRenderer
-
>
getDeviceContext
(
)
;
if
(
computeUniformStorage
-
>
size
(
)
>
0
&
&
programD3D
-
>
areShaderUniformsDirty
(
gl
:
:
ShaderType
:
:
Compute
)
)
{
UpdateUniformBuffer
(
deviceContext
computeUniformStorage
constantBuffer
)
;
programD3D
-
>
markUniformsClean
(
)
;
}
if
(
mCurrentComputeConstantBuffer
!
=
constantBuffer
-
>
getSerial
(
)
)
{
deviceContext
-
>
CSSetConstantBuffers
(
d3d11
:
:
RESERVED_CONSTANT_BUFFER_SLOT_DEFAULT_UNIFORM_BLOCK
1
constantBuffer
-
>
getPointer
(
)
)
;
mCurrentComputeConstantBuffer
=
constantBuffer
-
>
getSerial
(
)
;
}
if
(
!
mShaderDriverConstantBuffers
[
gl
:
:
ShaderType
:
:
Compute
]
.
valid
(
)
)
{
size_t
requiredSize
=
mShaderConstants
.
getRequiredBufferSize
(
gl
:
:
ShaderType
:
:
Compute
)
;
D3D11_BUFFER_DESC
constantBufferDescription
=
{
0
}
;
d3d11
:
:
InitConstantBufferDesc
(
&
constantBufferDescription
requiredSize
)
;
ANGLE_TRY
(
mRenderer
-
>
allocateResource
(
GetImplAs
<
Context11
>
(
context
)
constantBufferDescription
&
mShaderDriverConstantBuffers
[
gl
:
:
ShaderType
:
:
Compute
]
)
)
;
ID3D11Buffer
*
buffer
=
mShaderDriverConstantBuffers
[
gl
:
:
ShaderType
:
:
Compute
]
.
get
(
)
;
deviceContext
-
>
CSSetConstantBuffers
(
d3d11
:
:
RESERVED_CONSTANT_BUFFER_SLOT_DRIVER
1
&
buffer
)
;
}
ANGLE_TRY
(
mShaderConstants
.
updateBuffer
(
context
mRenderer
gl
:
:
ShaderType
:
:
Compute
*
programD3D
mShaderDriverConstantBuffers
[
gl
:
:
ShaderType
:
:
Compute
]
)
)
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
syncUniformBuffersForShader
(
const
gl
:
:
Context
*
context
gl
:
:
ShaderType
shaderType
)
{
gl
:
:
ShaderMap
<
unsigned
int
>
shaderReservedUBOs
=
mRenderer
-
>
getReservedShaderUniformBuffers
(
)
;
const
auto
&
glState
=
context
-
>
getGLState
(
)
;
ID3D11DeviceContext
*
deviceContext
=
mRenderer
-
>
getDeviceContext
(
)
;
ID3D11DeviceContext1
*
deviceContext1
=
mRenderer
-
>
getDeviceContext1IfSupported
(
)
;
const
auto
&
shaderUniformBuffers
=
mProgramD3D
-
>
getShaderUniformBufferCache
(
shaderType
)
;
const
unsigned
int
reservedUBOs
=
shaderReservedUBOs
[
shaderType
]
;
for
(
size_t
bufferIndex
=
0
;
bufferIndex
<
shaderUniformBuffers
.
size
(
)
;
+
+
bufferIndex
)
{
const
GLint
binding
=
shaderUniformBuffers
[
bufferIndex
]
;
if
(
binding
=
=
-
1
)
{
continue
;
}
const
auto
&
uniformBuffer
=
glState
.
getIndexedUniformBuffer
(
binding
)
;
const
GLintptr
uniformBufferOffset
=
uniformBuffer
.
getOffset
(
)
;
const
GLsizeiptr
uniformBufferSize
=
uniformBuffer
.
getSize
(
)
;
if
(
uniformBuffer
.
get
(
)
=
=
nullptr
)
{
continue
;
}
Buffer11
*
bufferStorage
=
GetImplAs
<
Buffer11
>
(
uniformBuffer
.
get
(
)
)
;
const
d3d11
:
:
Buffer
*
constantBuffer
=
nullptr
;
UINT
firstConstant
=
0
;
UINT
numConstants
=
0
;
ANGLE_TRY
(
bufferStorage
-
>
getConstantBufferRange
(
context
uniformBufferOffset
uniformBufferSize
&
constantBuffer
&
firstConstant
&
numConstants
)
)
;
ASSERT
(
constantBuffer
)
;
const
unsigned
int
appliedIndex
=
reservedUBOs
+
static_cast
<
unsigned
int
>
(
bufferIndex
)
;
switch
(
shaderType
)
{
case
gl
:
:
ShaderType
:
:
Vertex
:
{
if
(
mCurrentConstantBufferVS
[
bufferIndex
]
=
=
constantBuffer
-
>
getSerial
(
)
&
&
mCurrentConstantBufferVSOffset
[
bufferIndex
]
=
=
uniformBufferOffset
&
&
mCurrentConstantBufferVSSize
[
bufferIndex
]
=
=
uniformBufferSize
)
{
continue
;
}
if
(
firstConstant
!
=
0
&
&
uniformBufferSize
!
=
0
)
{
ASSERT
(
numConstants
!
=
0
)
;
deviceContext1
-
>
VSSetConstantBuffers1
(
appliedIndex
1
constantBuffer
-
>
getPointer
(
)
&
firstConstant
&
numConstants
)
;
}
else
{
deviceContext
-
>
VSSetConstantBuffers
(
appliedIndex
1
constantBuffer
-
>
getPointer
(
)
)
;
}
mCurrentConstantBufferVS
[
appliedIndex
]
=
constantBuffer
-
>
getSerial
(
)
;
mCurrentConstantBufferVSOffset
[
appliedIndex
]
=
uniformBufferOffset
;
mCurrentConstantBufferVSSize
[
appliedIndex
]
=
uniformBufferSize
;
break
;
}
case
gl
:
:
ShaderType
:
:
Fragment
:
{
if
(
mCurrentConstantBufferPS
[
bufferIndex
]
=
=
constantBuffer
-
>
getSerial
(
)
&
&
mCurrentConstantBufferPSOffset
[
bufferIndex
]
=
=
uniformBufferOffset
&
&
mCurrentConstantBufferPSSize
[
bufferIndex
]
=
=
uniformBufferSize
)
{
continue
;
}
if
(
firstConstant
!
=
0
&
&
uniformBufferSize
!
=
0
)
{
deviceContext1
-
>
PSSetConstantBuffers1
(
appliedIndex
1
constantBuffer
-
>
getPointer
(
)
&
firstConstant
&
numConstants
)
;
}
else
{
deviceContext
-
>
PSSetConstantBuffers
(
appliedIndex
1
constantBuffer
-
>
getPointer
(
)
)
;
}
mCurrentConstantBufferPS
[
appliedIndex
]
=
constantBuffer
-
>
getSerial
(
)
;
mCurrentConstantBufferPSOffset
[
appliedIndex
]
=
uniformBufferOffset
;
mCurrentConstantBufferPSSize
[
appliedIndex
]
=
uniformBufferSize
;
break
;
}
case
gl
:
:
ShaderType
:
:
Geometry
:
UNIMPLEMENTED
(
)
;
break
;
default
:
UNREACHABLE
(
)
;
}
}
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
syncUniformBuffers
(
const
gl
:
:
Context
*
context
)
{
gl
:
:
ShaderMap
<
unsigned
int
>
shaderReservedUBOs
=
mRenderer
-
>
getReservedShaderUniformBuffers
(
)
;
mProgramD3D
-
>
updateUniformBufferCache
(
context
-
>
getCaps
(
)
shaderReservedUBOs
)
;
ANGLE_TRY
(
syncUniformBuffersForShader
(
context
gl
:
:
ShaderType
:
:
Vertex
)
)
;
ANGLE_TRY
(
syncUniformBuffersForShader
(
context
gl
:
:
ShaderType
:
:
Fragment
)
)
;
if
(
mProgramD3D
-
>
hasShaderStage
(
gl
:
:
ShaderType
:
:
Geometry
)
)
{
ANGLE_TRY
(
syncUniformBuffersForShader
(
context
gl
:
:
ShaderType
:
:
Geometry
)
)
;
}
return
angle
:
:
Result
:
:
Continue
(
)
;
}
angle
:
:
Result
StateManager11
:
:
syncTransformFeedbackBuffers
(
const
gl
:
:
Context
*
context
)
{
const
auto
&
glState
=
context
-
>
getGLState
(
)
;
ID3D11DeviceContext
*
deviceContext
=
mRenderer
-
>
getDeviceContext
(
)
;
if
(
!
glState
.
isTransformFeedbackActiveUnpaused
(
)
)
{
if
(
mAppliedTFSerial
!
=
mEmptySerial
)
{
deviceContext
-
>
SOSetTargets
(
0
nullptr
nullptr
)
;
mAppliedTFSerial
=
mEmptySerial
;
}
return
angle
:
:
Result
:
:
Continue
(
)
;
}
gl
:
:
TransformFeedback
*
transformFeedback
=
glState
.
getCurrentTransformFeedback
(
)
;
TransformFeedback11
*
tf11
=
GetImplAs
<
TransformFeedback11
>
(
transformFeedback
)
;
if
(
mAppliedTFSerial
=
=
tf11
-
>
getSerial
(
)
&
&
!
tf11
-
>
isDirty
(
)
)
{
return
angle
:
:
Result
:
:
Continue
(
)
;
}
const
std
:
:
vector
<
ID3D11Buffer
*
>
*
soBuffers
=
nullptr
;
ANGLE_TRY
(
tf11
-
>
getSOBuffers
(
context
&
soBuffers
)
)
;
const
std
:
:
vector
<
UINT
>
&
soOffsets
=
tf11
-
>
getSOBufferOffsets
(
)
;
deviceContext
-
>
SOSetTargets
(
tf11
-
>
getNumSOBuffers
(
)
soBuffers
-
>
data
(
)
soOffsets
.
data
(
)
)
;
mAppliedTFSerial
=
tf11
-
>
getSerial
(
)
;
tf11
-
>
onApply
(
)
;
return
angle
:
:
Result
:
:
Continue
(
)
;
}
void
StateManager11
:
:
syncPrimitiveTopology
(
const
gl
:
:
State
&
glState
gl
:
:
PrimitiveMode
currentDrawMode
)
{
D3D11_PRIMITIVE_TOPOLOGY
primitiveTopology
=
D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED
;
mCullEverything
=
false
;
switch
(
currentDrawMode
)
{
case
gl
:
:
PrimitiveMode
:
:
Points
:
{
bool
usesPointSize
=
mProgramD3D
-
>
usesPointSize
(
)
;
if
(
!
usesPointSize
&
&
!
glState
.
isTransformFeedbackActiveUnpaused
(
)
)
{
WARN
(
)
<
<
"
Point
rendering
without
writing
to
gl_PointSize
.
"
;
mCullEverything
=
true
;
return
;
}
if
(
usesPointSize
&
&
mRenderer
-
>
getWorkarounds
(
)
.
useInstancedPointSpriteEmulation
)
{
primitiveTopology
=
D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST
;
}
else
{
primitiveTopology
=
D3D11_PRIMITIVE_TOPOLOGY_POINTLIST
;
}
break
;
}
case
gl
:
:
PrimitiveMode
:
:
Lines
:
primitiveTopology
=
D3D_PRIMITIVE_TOPOLOGY_LINELIST
;
break
;
case
gl
:
:
PrimitiveMode
:
:
LineLoop
:
primitiveTopology
=
D3D_PRIMITIVE_TOPOLOGY_LINESTRIP
;
break
;
case
gl
:
:
PrimitiveMode
:
:
LineStrip
:
primitiveTopology
=
D3D_PRIMITIVE_TOPOLOGY_LINESTRIP
;
break
;
case
gl
:
:
PrimitiveMode
:
:
Triangles
:
primitiveTopology
=
D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST
;
mCullEverything
=
CullsEverything
(
glState
)
;
break
;
case
gl
:
:
PrimitiveMode
:
:
TriangleStrip
:
primitiveTopology
=
D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP
;
mCullEverything
=
CullsEverything
(
glState
)
;
break
;
case
gl
:
:
PrimitiveMode
:
:
TriangleFan
:
primitiveTopology
=
D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST
;
mCullEverything
=
CullsEverything
(
glState
)
;
break
;
default
:
UNREACHABLE
(
)
;
break
;
}
setPrimitiveTopologyInternal
(
primitiveTopology
)
;
}
}
