#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
renderer11_utils
.
h
"
#
include
<
versionhelpers
.
h
>
#
include
<
algorithm
>
#
include
"
common
/
debug
.
h
"
#
include
"
libANGLE
/
Buffer
.
h
"
#
include
"
libANGLE
/
Context
.
h
"
#
include
"
libANGLE
/
Framebuffer
.
h
"
#
include
"
libANGLE
/
Program
.
h
"
#
include
"
libANGLE
/
State
.
h
"
#
include
"
libANGLE
/
VertexArray
.
h
"
#
include
"
libANGLE
/
formatutils
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
BufferD3D
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
FramebufferD3D
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
Context11
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
RenderTarget11
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
Renderer11
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
formatutils11
.
h
"
#
include
"
libANGLE
/
renderer
/
d3d
/
d3d11
/
texture_format_table
.
h
"
#
include
"
libANGLE
/
renderer
/
driver_utils
.
h
"
#
include
"
libANGLE
/
renderer
/
dxgi_support_table
.
h
"
#
include
"
platform
/
FeaturesD3D
.
h
"
#
include
"
platform
/
PlatformMethods
.
h
"
namespace
rx
{
namespace
d3d11_gl
{
namespace
{
static
D3D_FEATURE_LEVEL
kMinimumFeatureLevelForES31
=
D3D_FEATURE_LEVEL_11_0
;
class
DXGISupportHelper
:
angle
:
:
NonCopyable
{
public
:
DXGISupportHelper
(
ID3D11Device
*
device
D3D_FEATURE_LEVEL
featureLevel
)
:
mDevice
(
device
)
mFeatureLevel
(
featureLevel
)
{
}
bool
query
(
DXGI_FORMAT
dxgiFormat
UINT
supportMask
)
{
if
(
dxgiFormat
=
=
DXGI_FORMAT_UNKNOWN
)
return
false
;
auto
dxgiSupport
=
d3d11
:
:
GetDXGISupport
(
dxgiFormat
mFeatureLevel
)
;
UINT
supportedBits
=
dxgiSupport
.
alwaysSupportedFlags
;
if
(
(
dxgiSupport
.
optionallySupportedFlags
&
supportMask
)
!
=
0
)
{
UINT
formatSupport
;
if
(
SUCCEEDED
(
mDevice
-
>
CheckFormatSupport
(
dxgiFormat
&
formatSupport
)
)
)
{
supportedBits
|
=
(
formatSupport
&
supportMask
)
;
}
else
{
}
}
return
(
(
supportedBits
&
supportMask
)
=
=
supportMask
)
;
}
private
:
ID3D11Device
*
mDevice
;
D3D_FEATURE_LEVEL
mFeatureLevel
;
}
;
gl
:
:
TextureCaps
GenerateTextureFormatCaps
(
gl
:
:
Version
maxClientVersion
GLenum
internalFormat
ID3D11Device
*
device
const
Renderer11DeviceCaps
&
renderer11DeviceCaps
)
{
gl
:
:
TextureCaps
textureCaps
;
DXGISupportHelper
support
(
device
renderer11DeviceCaps
.
featureLevel
)
;
const
d3d11
:
:
Format
&
formatInfo
=
d3d11
:
:
Format
:
:
Get
(
internalFormat
renderer11DeviceCaps
)
;
const
gl
:
:
InternalFormat
&
internalFormatInfo
=
gl
:
:
GetSizedInternalFormatInfo
(
internalFormat
)
;
UINT
texSupportMask
=
D3D11_FORMAT_SUPPORT_TEXTURE2D
;
if
(
internalFormatInfo
.
depthBits
=
=
0
&
&
internalFormatInfo
.
stencilBits
=
=
0
)
{
texSupportMask
|
=
D3D11_FORMAT_SUPPORT_TEXTURECUBE
;
if
(
maxClientVersion
.
major
>
2
)
{
texSupportMask
|
=
D3D11_FORMAT_SUPPORT_TEXTURE3D
;
}
}
textureCaps
.
texturable
=
support
.
query
(
formatInfo
.
texFormat
texSupportMask
)
;
textureCaps
.
filterable
=
support
.
query
(
formatInfo
.
srvFormat
D3D11_FORMAT_SUPPORT_SHADER_SAMPLE
)
;
textureCaps
.
textureAttachment
=
(
support
.
query
(
formatInfo
.
rtvFormat
D3D11_FORMAT_SUPPORT_RENDER_TARGET
)
)
|
|
(
support
.
query
(
formatInfo
.
dsvFormat
D3D11_FORMAT_SUPPORT_DEPTH_STENCIL
)
)
;
textureCaps
.
renderbuffer
=
textureCaps
.
textureAttachment
;
textureCaps
.
blendable
=
textureCaps
.
renderbuffer
;
DXGI_FORMAT
renderFormat
=
DXGI_FORMAT_UNKNOWN
;
if
(
formatInfo
.
dsvFormat
!
=
DXGI_FORMAT_UNKNOWN
)
{
renderFormat
=
formatInfo
.
dsvFormat
;
}
else
if
(
formatInfo
.
rtvFormat
!
=
DXGI_FORMAT_UNKNOWN
)
{
renderFormat
=
formatInfo
.
rtvFormat
;
}
if
(
renderFormat
!
=
DXGI_FORMAT_UNKNOWN
&
&
support
.
query
(
renderFormat
D3D11_FORMAT_SUPPORT_MULTISAMPLE_RENDERTARGET
)
)
{
textureCaps
.
sampleCounts
.
insert
(
1
)
;
for
(
unsigned
int
sampleCount
=
2
;
sampleCount
<
=
D3D11_MAX_MULTISAMPLE_SAMPLE_COUNT
;
sampleCount
*
=
2
)
{
UINT
qualityCount
=
0
;
if
(
SUCCEEDED
(
device
-
>
CheckMultisampleQualityLevels
(
renderFormat
sampleCount
&
qualityCount
)
)
)
{
if
(
qualityCount
=
=
0
)
{
break
;
}
textureCaps
.
sampleCounts
.
insert
(
sampleCount
)
;
}
}
}
return
textureCaps
;
}
bool
GetNPOTTextureSupport
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
true
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
false
;
default
:
UNREACHABLE
(
)
;
return
false
;
}
}
float
GetMaximumAnisotropy
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_MAX_MAXANISOTROPY
;
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
D3D10_MAX_MAXANISOTROPY
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
return
16
;
case
D3D_FEATURE_LEVEL_9_1
:
return
D3D_FL9_1_DEFAULT_MAX_ANISOTROPY
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
bool
GetOcclusionQuerySupport
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
true
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
return
true
;
case
D3D_FEATURE_LEVEL_9_1
:
return
false
;
default
:
UNREACHABLE
(
)
;
return
false
;
}
}
bool
GetEventQuerySupport
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
true
;
default
:
UNREACHABLE
(
)
;
return
false
;
}
}
bool
GetInstancingSupport
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
true
;
case
D3D_FEATURE_LEVEL_9_3
:
return
true
;
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
false
;
default
:
UNREACHABLE
(
)
;
return
false
;
}
}
bool
GetFramebufferMultisampleSupport
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
true
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
false
;
default
:
UNREACHABLE
(
)
;
return
false
;
}
}
bool
GetFramebufferBlitSupport
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
true
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
false
;
default
:
UNREACHABLE
(
)
;
return
false
;
}
}
bool
GetDerivativeInstructionSupport
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
case
D3D_FEATURE_LEVEL_9_3
:
return
true
;
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
false
;
default
:
UNREACHABLE
(
)
;
return
false
;
}
}
bool
GetShaderTextureLODSupport
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
true
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
false
;
default
:
UNREACHABLE
(
)
;
return
false
;
}
}
int
GetMaximumSimultaneousRenderTargets
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT
;
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
D3D10_SIMULTANEOUS_RENDER_TARGET_COUNT
;
case
D3D_FEATURE_LEVEL_9_3
:
return
D3D_FL9_3_SIMULTANEOUS_RENDER_TARGET_COUNT
;
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
D3D_FL9_1_SIMULTANEOUS_RENDER_TARGET_COUNT
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMaximum2DTextureSize
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_REQ_TEXTURE2D_U_OR_V_DIMENSION
;
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
D3D10_REQ_TEXTURE2D_U_OR_V_DIMENSION
;
case
D3D_FEATURE_LEVEL_9_3
:
return
D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION
;
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMaximumCubeMapTextureSize
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_REQ_TEXTURECUBE_DIMENSION
;
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
D3D10_REQ_TEXTURECUBE_DIMENSION
;
case
D3D_FEATURE_LEVEL_9_3
:
return
D3D_FL9_3_REQ_TEXTURECUBE_DIMENSION
;
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
D3D_FL9_1_REQ_TEXTURECUBE_DIMENSION
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMaximum2DTextureArraySize
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION
;
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
D3D10_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
0
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMaximum3DTextureSize
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_REQ_TEXTURE3D_U_V_OR_W_DIMENSION
;
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
D3D10_REQ_TEXTURE3D_U_V_OR_W_DIMENSION
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
D3D_FL9_1_REQ_TEXTURE3D_U_V_OR_W_DIMENSION
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMaximumViewportSize
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_VIEWPORT_BOUNDS_MAX
;
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
D3D10_VIEWPORT_BOUNDS_MAX
;
case
D3D_FEATURE_LEVEL_9_3
:
return
D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION
;
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMaximumDrawIndexedIndexCount
(
D3D_FEATURE_LEVEL
featureLevel
)
{
static_assert
(
D3D11_REQ_DRAWINDEXED_INDEX_COUNT_2_TO_EXP
=
=
32
"
Unexpected
D3D11
constant
value
.
"
)
;
static_assert
(
D3D10_REQ_DRAWINDEXED_INDEX_COUNT_2_TO_EXP
=
=
32
"
Unexpected
D3D11
constant
value
.
"
)
;
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
std
:
:
numeric_limits
<
GLint
>
:
:
max
(
)
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
return
D3D_FL9_2_IA_PRIMITIVE_MAX_COUNT
;
case
D3D_FEATURE_LEVEL_9_1
:
return
D3D_FL9_1_IA_PRIMITIVE_MAX_COUNT
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMaximumDrawVertexCount
(
D3D_FEATURE_LEVEL
featureLevel
)
{
static_assert
(
D3D11_REQ_DRAW_VERTEX_COUNT_2_TO_EXP
=
=
32
"
Unexpected
D3D11
constant
value
.
"
)
;
static_assert
(
D3D10_REQ_DRAW_VERTEX_COUNT_2_TO_EXP
=
=
32
"
Unexpected
D3D11
constant
value
.
"
)
;
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
std
:
:
numeric_limits
<
GLint
>
:
:
max
(
)
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
return
D3D_FL9_2_IA_PRIMITIVE_MAX_COUNT
;
case
D3D_FEATURE_LEVEL_9_1
:
return
D3D_FL9_1_IA_PRIMITIVE_MAX_COUNT
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMaximumVertexInputSlots
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_STANDARD_VERTEX_ELEMENT_COUNT
;
case
D3D_FEATURE_LEVEL_10_1
:
return
D3D10_1_STANDARD_VERTEX_ELEMENT_COUNT
;
case
D3D_FEATURE_LEVEL_10_0
:
return
D3D10_STANDARD_VERTEX_ELEMENT_COUNT
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
16
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMaximumVertexUniformVectors
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
;
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
D3D10_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
255
-
d3d11_gl
:
:
GetReservedVertexUniformVectors
(
featureLevel
)
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMaximumVertexUniformBlocks
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
-
d3d11
:
:
RESERVED_CONSTANT_BUFFER_SLOT_COUNT
;
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
D3D10_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
-
d3d11
:
:
RESERVED_CONSTANT_BUFFER_SLOT_COUNT
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
0
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetReservedVertexOutputVectors
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
2
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
1
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMaximumVertexOutputVectors
(
D3D_FEATURE_LEVEL
featureLevel
)
{
static_assert
(
gl
:
:
IMPLEMENTATION_MAX_VARYING_VECTORS
=
=
D3D11_VS_OUTPUT_REGISTER_COUNT
"
Unexpected
D3D11
constant
value
.
"
)
;
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_VS_OUTPUT_REGISTER_COUNT
-
GetReservedVertexOutputVectors
(
featureLevel
)
;
case
D3D_FEATURE_LEVEL_10_1
:
return
D3D10_1_VS_OUTPUT_REGISTER_COUNT
-
GetReservedVertexOutputVectors
(
featureLevel
)
;
case
D3D_FEATURE_LEVEL_10_0
:
return
D3D10_VS_OUTPUT_REGISTER_COUNT
-
GetReservedVertexOutputVectors
(
featureLevel
)
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
8
-
GetReservedVertexOutputVectors
(
featureLevel
)
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMaximumVertexTextureUnits
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT
;
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
D3D10_COMMONSHADER_SAMPLER_SLOT_COUNT
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
0
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMaximumPixelUniformVectors
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
1024
;
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
1024
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
32
-
d3d11_gl
:
:
GetReservedFragmentUniformVectors
(
featureLevel
)
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMaximumPixelUniformBlocks
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
-
d3d11
:
:
RESERVED_CONSTANT_BUFFER_SLOT_COUNT
;
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
D3D10_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
-
d3d11
:
:
RESERVED_CONSTANT_BUFFER_SLOT_COUNT
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
0
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMaximumPixelInputVectors
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_PS_INPUT_REGISTER_COUNT
-
GetReservedVertexOutputVectors
(
featureLevel
)
;
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
D3D10_PS_INPUT_REGISTER_COUNT
-
GetReservedVertexOutputVectors
(
featureLevel
)
;
case
D3D_FEATURE_LEVEL_9_3
:
return
8
-
GetReservedVertexOutputVectors
(
featureLevel
)
;
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
8
-
GetReservedVertexOutputVectors
(
featureLevel
)
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMaximumPixelTextureUnits
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT
;
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
D3D10_COMMONSHADER_SAMPLER_SLOT_COUNT
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
16
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
std
:
:
array
<
GLint
3
>
GetMaxComputeWorkGroupCount
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
{
{
D3D11_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION
D3D11_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION
D3D11_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION
}
}
;
break
;
default
:
return
{
{
0
0
0
}
}
;
}
}
std
:
:
array
<
GLint
3
>
GetMaxComputeWorkGroupSize
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
{
{
D3D11_CS_THREAD_GROUP_MAX_X
D3D11_CS_THREAD_GROUP_MAX_Y
D3D11_CS_THREAD_GROUP_MAX_Z
}
}
;
break
;
default
:
return
{
{
0
0
0
}
}
;
}
}
int
GetMaxComputeWorkGroupInvocations
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_CS_THREAD_GROUP_MAX_THREADS_PER_GROUP
;
default
:
return
0
;
}
}
int
GetMaxComputeSharedMemorySize
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
32768
;
default
:
return
0
;
}
}
int
GetMaximumComputeUniformVectors
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
;
default
:
return
0
;
}
}
int
GetMaximumComputeUniformBlocks
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT
-
d3d11
:
:
RESERVED_CONSTANT_BUFFER_SLOT_COUNT
;
default
:
return
0
;
}
}
int
GetMaximumComputeTextureUnits
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT
;
default
:
return
0
;
}
}
void
SetUAVRelatedResourceLimits
(
D3D_FEATURE_LEVEL
featureLevel
gl
:
:
Caps
*
caps
)
{
ASSERT
(
caps
)
;
GLuint
reservedUAVsForAtomicCounterBuffers
=
0u
;
GLuint
maxNumRTVsAndUAVs
=
0u
;
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
reservedUAVsForAtomicCounterBuffers
=
4u
;
maxNumRTVsAndUAVs
=
D3D11_1_UAV_SLOT_COUNT
;
break
;
case
D3D_FEATURE_LEVEL_11_0
:
reservedUAVsForAtomicCounterBuffers
=
1u
;
maxNumRTVsAndUAVs
=
D3D11_PS_CS_UAV_REGISTER_COUNT
;
break
;
default
:
return
;
}
caps
-
>
maxCombinedAtomicCounterBuffers
=
reservedUAVsForAtomicCounterBuffers
;
caps
-
>
maxShaderAtomicCounterBuffers
[
gl
:
:
ShaderType
:
:
Compute
]
=
reservedUAVsForAtomicCounterBuffers
;
caps
-
>
maxShaderAtomicCounterBuffers
[
gl
:
:
ShaderType
:
:
Fragment
]
=
reservedUAVsForAtomicCounterBuffers
;
caps
-
>
maxAtomicCounterBufferBindings
=
reservedUAVsForAtomicCounterBuffers
;
caps
-
>
maxCombinedAtomicCounters
=
reservedUAVsForAtomicCounterBuffers
*
1024
;
caps
-
>
maxShaderAtomicCounters
[
gl
:
:
ShaderType
:
:
Compute
]
=
caps
-
>
maxCombinedAtomicCounters
;
caps
-
>
maxShaderStorageBlockSize
=
D3D11_REQ_RESOURCE_SIZE_IN_MEGABYTES_EXPRESSION_A_TERM
*
1024
*
1024
;
caps
-
>
maxCombinedShaderOutputResources
=
maxNumRTVsAndUAVs
-
reservedUAVsForAtomicCounterBuffers
;
caps
-
>
maxCombinedShaderStorageBlocks
=
caps
-
>
maxCombinedShaderOutputResources
;
caps
-
>
maxShaderStorageBlocks
[
gl
:
:
ShaderType
:
:
Compute
]
=
caps
-
>
maxCombinedShaderOutputResources
;
caps
-
>
maxShaderStorageBlocks
[
gl
:
:
ShaderType
:
:
Fragment
]
=
caps
-
>
maxCombinedShaderOutputResources
;
caps
-
>
maxShaderStorageBufferBindings
=
caps
-
>
maxCombinedShaderOutputResources
;
caps
-
>
maxImageUnits
=
caps
-
>
maxCombinedShaderOutputResources
;
caps
-
>
maxCombinedImageUniforms
=
caps
-
>
maxCombinedShaderOutputResources
;
caps
-
>
maxShaderImageUniforms
[
gl
:
:
ShaderType
:
:
Compute
]
=
caps
-
>
maxCombinedShaderOutputResources
;
caps
-
>
maxShaderImageUniforms
[
gl
:
:
ShaderType
:
:
Fragment
]
=
caps
-
>
maxCombinedShaderOutputResources
;
if
(
featureLevel
=
=
D3D_FEATURE_LEVEL_11_1
)
{
caps
-
>
maxShaderAtomicCounterBuffers
[
gl
:
:
ShaderType
:
:
Vertex
]
=
caps
-
>
maxCombinedAtomicCounterBuffers
;
caps
-
>
maxShaderAtomicCounterBuffers
[
gl
:
:
ShaderType
:
:
Geometry
]
=
caps
-
>
maxCombinedAtomicCounterBuffers
;
caps
-
>
maxShaderImageUniforms
[
gl
:
:
ShaderType
:
:
Vertex
]
=
caps
-
>
maxCombinedShaderOutputResources
;
caps
-
>
maxShaderStorageBlocks
[
gl
:
:
ShaderType
:
:
Vertex
]
=
caps
-
>
maxCombinedShaderOutputResources
;
caps
-
>
maxShaderImageUniforms
[
gl
:
:
ShaderType
:
:
Geometry
]
=
caps
-
>
maxCombinedShaderOutputResources
;
caps
-
>
maxShaderStorageBlocks
[
gl
:
:
ShaderType
:
:
Geometry
]
=
caps
-
>
maxCombinedShaderOutputResources
;
}
}
int
GetMinimumTexelOffset
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_COMMONSHADER_TEXEL_OFFSET_MAX_NEGATIVE
;
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
D3D10_COMMONSHADER_TEXEL_OFFSET_MAX_NEGATIVE
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
0
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMaximumTexelOffset
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_COMMONSHADER_TEXEL_OFFSET_MAX_POSITIVE
;
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
D3D11_COMMONSHADER_TEXEL_OFFSET_MAX_POSITIVE
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
0
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMinimumTextureGatherOffset
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
-
32
;
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
0
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMaximumTextureGatherOffset
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
31
;
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
0
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
size_t
GetMaximumConstantBufferSize
(
D3D_FEATURE_LEVEL
featureLevel
)
{
const
size_t
bytesPerComponent
=
4
*
sizeof
(
float
)
;
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
*
bytesPerComponent
;
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
D3D10_REQ_CONSTANT_BUFFER_ELEMENT_COUNT
*
bytesPerComponent
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
4096
*
bytesPerComponent
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMaximumStreamOutputBuffers
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_SO_BUFFER_SLOT_COUNT
;
case
D3D_FEATURE_LEVEL_10_1
:
return
D3D10_1_SO_BUFFER_SLOT_COUNT
;
case
D3D_FEATURE_LEVEL_10_0
:
return
D3D10_SO_BUFFER_SLOT_COUNT
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
0
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMaximumStreamOutputInterleavedComponents
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
GetMaximumVertexOutputVectors
(
featureLevel
)
*
4
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
0
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMaximumStreamOutputSeparateComponents
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
GetMaximumStreamOutputInterleavedComponents
(
featureLevel
)
/
GetMaximumStreamOutputBuffers
(
featureLevel
)
;
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
4
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
0
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
int
GetMaximumRenderToBufferWindowSize
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_REQ_RENDER_TO_BUFFER_WINDOW_WIDTH
;
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
D3D10_REQ_RENDER_TO_BUFFER_WINDOW_WIDTH
;
case
D3D_FEATURE_LEVEL_9_3
:
return
D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION
;
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
IntelDriverVersion
GetIntelDriverVersion
(
const
Optional
<
LARGE_INTEGER
>
driverVersion
)
{
if
(
!
driverVersion
.
valid
(
)
)
return
IntelDriverVersion
(
0
)
;
WORD
part
=
LOWORD
(
driverVersion
.
value
(
)
.
LowPart
)
;
return
IntelDriverVersion
(
part
)
;
}
}
unsigned
int
GetReservedVertexUniformVectors
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
0
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
3
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
unsigned
int
GetReservedFragmentUniformVectors
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
0
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
3
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
gl
:
:
Version
GetMaximumClientVersion
(
const
Renderer11DeviceCaps
&
caps
)
{
switch
(
caps
.
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
gl
:
:
Version
(
3
1
)
;
case
D3D_FEATURE_LEVEL_10_1
:
return
gl
:
:
Version
(
3
0
)
;
case
D3D_FEATURE_LEVEL_10_0
:
if
(
caps
.
allowES3OnFL10_0
)
{
return
gl
:
:
Version
(
3
0
)
;
}
else
{
return
gl
:
:
Version
(
2
0
)
;
}
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
gl
:
:
Version
(
2
0
)
;
default
:
UNREACHABLE
(
)
;
return
gl
:
:
Version
(
0
0
)
;
}
}
D3D_FEATURE_LEVEL
GetMinimumFeatureLevelForES31
(
)
{
return
kMinimumFeatureLevelForES31
;
}
unsigned
int
GetMaxViewportAndScissorRectanglesPerPipeline
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE
;
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
1
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
bool
IsMultiviewSupported
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
return
true
;
default
:
return
false
;
}
}
int
GetMaxSampleMaskWords
(
D3D_FEATURE_LEVEL
featureLevel
)
{
switch
(
featureLevel
)
{
case
D3D_FEATURE_LEVEL_11_1
:
case
D3D_FEATURE_LEVEL_11_0
:
case
D3D_FEATURE_LEVEL_10_1
:
case
D3D_FEATURE_LEVEL_10_0
:
return
1
;
case
D3D_FEATURE_LEVEL_9_3
:
case
D3D_FEATURE_LEVEL_9_2
:
case
D3D_FEATURE_LEVEL_9_1
:
return
0
;
default
:
UNREACHABLE
(
)
;
return
0
;
}
}
void
GenerateCaps
(
ID3D11Device
*
device
ID3D11DeviceContext
*
deviceContext
const
Renderer11DeviceCaps
&
renderer11DeviceCaps
const
angle
:
:
FeaturesD3D
&
features
const
char
*
description
gl
:
:
Caps
*
caps
gl
:
:
TextureCapsMap
*
textureCapsMap
gl
:
:
Extensions
*
extensions
gl
:
:
Limitations
*
limitations
)
{
D3D_FEATURE_LEVEL
featureLevel
=
renderer11DeviceCaps
.
featureLevel
;
const
gl
:
:
FormatSet
&
allFormats
=
gl
:
:
GetAllSizedInternalFormats
(
)
;
for
(
GLenum
internalFormat
:
allFormats
)
{
gl
:
:
TextureCaps
textureCaps
=
GenerateTextureFormatCaps
(
GetMaximumClientVersion
(
renderer11DeviceCaps
)
internalFormat
device
renderer11DeviceCaps
)
;
textureCapsMap
-
>
insert
(
internalFormat
textureCaps
)
;
if
(
gl
:
:
GetSizedInternalFormatInfo
(
internalFormat
)
.
compressed
)
{
caps
-
>
compressedTextureFormats
.
push_back
(
internalFormat
)
;
}
}
caps
-
>
maxElementIndex
=
static_cast
<
GLint64
>
(
std
:
:
numeric_limits
<
unsigned
int
>
:
:
max
(
)
-
1
)
;
caps
-
>
max3DTextureSize
=
GetMaximum3DTextureSize
(
featureLevel
)
;
caps
-
>
max2DTextureSize
=
GetMaximum2DTextureSize
(
featureLevel
)
;
caps
-
>
maxCubeMapTextureSize
=
GetMaximumCubeMapTextureSize
(
featureLevel
)
;
caps
-
>
maxArrayTextureLayers
=
GetMaximum2DTextureArraySize
(
featureLevel
)
;
caps
-
>
maxLODBias
=
2
.
0f
;
caps
-
>
maxRenderbufferSize
=
caps
-
>
max2DTextureSize
;
caps
-
>
maxDrawBuffers
=
GetMaximumSimultaneousRenderTargets
(
featureLevel
)
;
caps
-
>
maxColorAttachments
=
GetMaximumSimultaneousRenderTargets
(
featureLevel
)
;
caps
-
>
maxViewportWidth
=
GetMaximumViewportSize
(
featureLevel
)
;
caps
-
>
maxViewportHeight
=
caps
-
>
maxViewportWidth
;
caps
-
>
minAliasedPointSize
=
1
.
0f
;
caps
-
>
maxAliasedPointSize
=
1024
.
0f
;
caps
-
>
minAliasedLineWidth
=
1
.
0f
;
caps
-
>
maxAliasedLineWidth
=
1
.
0f
;
caps
-
>
maxElementsIndices
=
GetMaximumDrawIndexedIndexCount
(
featureLevel
)
;
caps
-
>
maxElementsVertices
=
GetMaximumDrawVertexCount
(
featureLevel
)
;
caps
-
>
programBinaryFormats
.
push_back
(
GL_PROGRAM_BINARY_ANGLE
)
;
caps
-
>
vertexHighpFloat
.
setIEEEFloat
(
)
;
caps
-
>
vertexMediumpFloat
.
setIEEEFloat
(
)
;
caps
-
>
vertexLowpFloat
.
setIEEEFloat
(
)
;
caps
-
>
fragmentHighpFloat
.
setIEEEFloat
(
)
;
caps
-
>
fragmentMediumpFloat
.
setIEEEFloat
(
)
;
caps
-
>
fragmentLowpFloat
.
setIEEEFloat
(
)
;
caps
-
>
vertexHighpInt
.
setTwosComplementInt
(
32
)
;
caps
-
>
vertexMediumpInt
.
setTwosComplementInt
(
32
)
;
caps
-
>
vertexLowpInt
.
setTwosComplementInt
(
32
)
;
caps
-
>
fragmentHighpInt
.
setTwosComplementInt
(
32
)
;
caps
-
>
fragmentMediumpInt
.
setTwosComplementInt
(
32
)
;
caps
-
>
fragmentLowpInt
.
setTwosComplementInt
(
32
)
;
caps
-
>
maxServerWaitTimeout
=
0
;
caps
-
>
maxVertexAttributes
=
GetMaximumVertexInputSlots
(
featureLevel
)
;
caps
-
>
maxVertexUniformVectors
=
GetMaximumVertexUniformVectors
(
featureLevel
)
;
if
(
features
.
skipVSConstantRegisterZero
.
enabled
)
{
caps
-
>
maxVertexUniformVectors
-
=
1
;
}
caps
-
>
maxShaderUniformComponents
[
gl
:
:
ShaderType
:
:
Vertex
]
=
caps
-
>
maxVertexUniformVectors
*
4
;
caps
-
>
maxShaderUniformBlocks
[
gl
:
:
ShaderType
:
:
Vertex
]
=
GetMaximumVertexUniformBlocks
(
featureLevel
)
;
caps
-
>
maxVertexOutputComponents
=
GetMaximumVertexOutputVectors
(
featureLevel
)
*
4
;
caps
-
>
maxShaderTextureImageUnits
[
gl
:
:
ShaderType
:
:
Vertex
]
=
GetMaximumVertexTextureUnits
(
featureLevel
)
;
caps
-
>
maxVertexAttribBindings
=
caps
-
>
maxVertexAttributes
;
caps
-
>
maxVertexAttribRelativeOffset
=
std
:
:
numeric_limits
<
GLint
>
:
:
max
(
)
;
caps
-
>
maxVertexAttribStride
=
2048
;
caps
-
>
maxFragmentUniformVectors
=
GetMaximumPixelUniformVectors
(
featureLevel
)
;
caps
-
>
maxShaderUniformComponents
[
gl
:
:
ShaderType
:
:
Fragment
]
=
caps
-
>
maxFragmentUniformVectors
*
4
;
caps
-
>
maxShaderUniformBlocks
[
gl
:
:
ShaderType
:
:
Fragment
]
=
GetMaximumPixelUniformBlocks
(
featureLevel
)
;
caps
-
>
maxFragmentInputComponents
=
GetMaximumPixelInputVectors
(
featureLevel
)
*
4
;
caps
-
>
maxShaderTextureImageUnits
[
gl
:
:
ShaderType
:
:
Fragment
]
=
GetMaximumPixelTextureUnits
(
featureLevel
)
;
caps
-
>
minProgramTexelOffset
=
GetMinimumTexelOffset
(
featureLevel
)
;
caps
-
>
maxProgramTexelOffset
=
GetMaximumTexelOffset
(
featureLevel
)
;
caps
-
>
maxComputeWorkGroupCount
=
GetMaxComputeWorkGroupCount
(
featureLevel
)
;
caps
-
>
maxComputeWorkGroupSize
=
GetMaxComputeWorkGroupSize
(
featureLevel
)
;
caps
-
>
maxComputeWorkGroupInvocations
=
GetMaxComputeWorkGroupInvocations
(
featureLevel
)
;
caps
-
>
maxComputeSharedMemorySize
=
GetMaxComputeSharedMemorySize
(
featureLevel
)
;
caps
-
>
maxShaderUniformComponents
[
gl
:
:
ShaderType
:
:
Compute
]
=
GetMaximumComputeUniformVectors
(
featureLevel
)
*
4
;
caps
-
>
maxShaderUniformBlocks
[
gl
:
:
ShaderType
:
:
Compute
]
=
GetMaximumComputeUniformBlocks
(
featureLevel
)
;
caps
-
>
maxShaderTextureImageUnits
[
gl
:
:
ShaderType
:
:
Compute
]
=
GetMaximumComputeTextureUnits
(
featureLevel
)
;
SetUAVRelatedResourceLimits
(
featureLevel
caps
)
;
caps
-
>
maxUniformBufferBindings
=
caps
-
>
maxShaderUniformBlocks
[
gl
:
:
ShaderType
:
:
Vertex
]
+
caps
-
>
maxShaderUniformBlocks
[
gl
:
:
ShaderType
:
:
Fragment
]
;
caps
-
>
maxUniformBlockSize
=
static_cast
<
GLuint64
>
(
GetMaximumConstantBufferSize
(
featureLevel
)
)
;
caps
-
>
maxUniformLocations
=
1024
;
caps
-
>
uniformBufferOffsetAlignment
=
256
;
caps
-
>
maxCombinedUniformBlocks
=
caps
-
>
maxShaderUniformBlocks
[
gl
:
:
ShaderType
:
:
Vertex
]
+
caps
-
>
maxShaderUniformBlocks
[
gl
:
:
ShaderType
:
:
Fragment
]
;
caps
-
>
shaderStorageBufferOffsetAlignment
=
16
;
for
(
gl
:
:
ShaderType
shaderType
:
gl
:
:
AllShaderTypes
(
)
)
{
caps
-
>
maxCombinedShaderUniformComponents
[
shaderType
]
=
static_cast
<
GLint64
>
(
caps
-
>
maxShaderUniformBlocks
[
shaderType
]
)
*
static_cast
<
GLint64
>
(
caps
-
>
maxUniformBlockSize
/
4
)
+
static_cast
<
GLint64
>
(
caps
-
>
maxShaderUniformComponents
[
shaderType
]
)
;
}
caps
-
>
maxVaryingComponents
=
GetMaximumVertexOutputVectors
(
featureLevel
)
*
4
;
caps
-
>
maxVaryingVectors
=
GetMaximumVertexOutputVectors
(
featureLevel
)
;
caps
-
>
maxCombinedTextureImageUnits
=
caps
-
>
maxShaderTextureImageUnits
[
gl
:
:
ShaderType
:
:
Vertex
]
+
caps
-
>
maxShaderTextureImageUnits
[
gl
:
:
ShaderType
:
:
Fragment
]
;
caps
-
>
maxTransformFeedbackInterleavedComponents
=
GetMaximumStreamOutputInterleavedComponents
(
featureLevel
)
;
caps
-
>
maxTransformFeedbackSeparateAttributes
=
GetMaximumStreamOutputBuffers
(
featureLevel
)
;
caps
-
>
maxTransformFeedbackSeparateComponents
=
GetMaximumStreamOutputSeparateComponents
(
featureLevel
)
;
caps
-
>
maxSamples
=
std
:
:
numeric_limits
<
GLint
>
:
:
max
(
)
;
caps
-
>
maxColorTextureSamples
=
std
:
:
numeric_limits
<
GLint
>
:
:
max
(
)
;
caps
-
>
maxDepthTextureSamples
=
std
:
:
numeric_limits
<
GLint
>
:
:
max
(
)
;
caps
-
>
maxIntegerSamples
=
std
:
:
numeric_limits
<
GLint
>
:
:
max
(
)
;
caps
-
>
maxSampleMaskWords
=
GetMaxSampleMaskWords
(
featureLevel
)
;
caps
-
>
maxFramebufferSamples
=
std
:
:
numeric_limits
<
GLint
>
:
:
max
(
)
;
caps
-
>
maxFramebufferWidth
=
GetMaximumRenderToBufferWindowSize
(
featureLevel
)
;
caps
-
>
maxFramebufferHeight
=
caps
-
>
maxFramebufferWidth
;
caps
-
>
minProgramTextureGatherOffset
=
GetMinimumTextureGatherOffset
(
featureLevel
)
;
caps
-
>
maxProgramTextureGatherOffset
=
GetMaximumTextureGatherOffset
(
featureLevel
)
;
extensions
-
>
setTextureExtensionSupport
(
*
textureCapsMap
)
;
extensions
-
>
compressedETC1RGB8TextureOES
=
false
;
extensions
-
>
compressedETC1RGB8SubTexture
=
false
;
extensions
-
>
elementIndexUintOES
=
true
;
extensions
-
>
getProgramBinaryOES
=
true
;
extensions
-
>
rgb8rgba8OES
=
true
;
extensions
-
>
readFormatBGRA
=
true
;
extensions
-
>
pixelBufferObjectNV
=
true
;
extensions
-
>
mapBufferOES
=
true
;
extensions
-
>
mapBufferRange
=
true
;
extensions
-
>
textureNPOTOES
=
GetNPOTTextureSupport
(
featureLevel
)
;
extensions
-
>
drawBuffers
=
GetMaximumSimultaneousRenderTargets
(
featureLevel
)
>
1
;
extensions
-
>
drawBuffersIndexedEXT
=
(
renderer11DeviceCaps
.
featureLevel
>
=
D3D_FEATURE_LEVEL_10_1
)
;
extensions
-
>
drawBuffersIndexedOES
=
extensions
-
>
drawBuffersIndexedEXT
;
extensions
-
>
textureStorage
=
true
;
extensions
-
>
textureFilterAnisotropic
=
true
;
extensions
-
>
maxTextureAnisotropy
=
GetMaximumAnisotropy
(
featureLevel
)
;
extensions
-
>
occlusionQueryBoolean
=
GetOcclusionQuerySupport
(
featureLevel
)
;
extensions
-
>
fenceNV
=
GetEventQuerySupport
(
featureLevel
)
;
extensions
-
>
disjointTimerQuery
=
true
;
extensions
-
>
queryCounterBitsTimeElapsed
=
64
;
extensions
-
>
queryCounterBitsTimestamp
=
0
;
extensions
-
>
robustness
=
true
;
extensions
-
>
robustBufferAccessBehavior
=
true
;
extensions
-
>
blendMinMax
=
true
;
extensions
-
>
floatBlend
=
true
;
extensions
-
>
framebufferBlitANGLE
=
GetFramebufferBlitSupport
(
featureLevel
)
;
extensions
-
>
framebufferMultisample
=
GetFramebufferMultisampleSupport
(
featureLevel
)
;
extensions
-
>
instancedArraysANGLE
=
GetInstancingSupport
(
featureLevel
)
;
extensions
-
>
instancedArraysEXT
=
GetInstancingSupport
(
featureLevel
)
;
extensions
-
>
packReverseRowOrder
=
true
;
extensions
-
>
standardDerivativesOES
=
GetDerivativeInstructionSupport
(
featureLevel
)
;
extensions
-
>
shaderTextureLOD
=
GetShaderTextureLODSupport
(
featureLevel
)
;
extensions
-
>
fragDepth
=
true
;
extensions
-
>
multiview
=
IsMultiviewSupported
(
featureLevel
)
;
extensions
-
>
multiview2
=
IsMultiviewSupported
(
featureLevel
)
;
if
(
extensions
-
>
multiview
|
|
extensions
-
>
multiview2
)
{
extensions
-
>
maxViews
=
std
:
:
min
(
static_cast
<
GLuint
>
(
gl
:
:
IMPLEMENTATION_ANGLE_MULTIVIEW_MAX_VIEWS
)
std
:
:
min
(
static_cast
<
GLuint
>
(
GetMaximum2DTextureArraySize
(
featureLevel
)
)
GetMaxViewportAndScissorRectanglesPerPipeline
(
featureLevel
)
)
)
;
}
extensions
-
>
textureUsage
=
true
;
extensions
-
>
discardFramebuffer
=
true
;
extensions
-
>
translatedShaderSource
=
true
;
extensions
-
>
fboRenderMipmapOES
=
true
;
extensions
-
>
debugMarker
=
true
;
extensions
-
>
eglImageOES
=
true
;
extensions
-
>
eglImageExternalOES
=
true
;
extensions
-
>
eglImageExternalWrapModesEXT
=
true
;
extensions
-
>
eglImageExternalEssl3OES
=
true
;
extensions
-
>
eglStreamConsumerExternalNV
=
true
;
extensions
-
>
unpackSubimage
=
true
;
extensions
-
>
packSubimage
=
true
;
extensions
-
>
lossyETCDecode
=
true
;
extensions
-
>
syncQuery
=
GetEventQuerySupport
(
featureLevel
)
;
extensions
-
>
copyTexture
=
true
;
extensions
-
>
copyCompressedTexture
=
true
;
extensions
-
>
textureStorageMultisample2DArrayOES
=
true
;
extensions
-
>
multiviewMultisample
=
(
(
extensions
-
>
multiview
|
|
extensions
-
>
multiview2
)
&
&
extensions
-
>
textureStorageMultisample2DArrayOES
)
;
extensions
-
>
copyTexture3d
=
true
;
extensions
-
>
textureBorderClampOES
=
true
;
extensions
-
>
textureMultisample
=
true
;
extensions
-
>
provokingVertex
=
true
;
extensions
-
>
blendFuncExtended
=
true
;
extensions
-
>
maxDualSourceDrawBuffers
=
1
;
extensions
-
>
texture3DOES
=
false
;
extensions
-
>
baseVertexBaseInstance
=
true
;
extensions
-
>
drawElementsBaseVertexOES
=
true
;
extensions
-
>
drawElementsBaseVertexEXT
=
true
;
if
(
!
strstr
(
description
"
Adreno
"
)
)
{
extensions
-
>
multisampledRenderToTexture
=
true
;
}
extensions
-
>
webglVideoTexture
=
true
;
extensions
-
>
depthTextureOES
=
false
;
extensions
-
>
readDepthNV
=
false
;
extensions
-
>
readStencilNV
=
false
;
extensions
-
>
depthBufferFloat2NV
=
false
;
limitations
-
>
noFrontFacingSupport
=
(
renderer11DeviceCaps
.
featureLevel
<
=
D3D_FEATURE_LEVEL_9_3
)
;
limitations
-
>
noSampleAlphaToCoverageSupport
=
(
renderer11DeviceCaps
.
featureLevel
<
=
D3D_FEATURE_LEVEL_9_3
)
;
limitations
-
>
shadersRequireIndexedLoopValidation
=
(
renderer11DeviceCaps
.
featureLevel
<
=
D3D_FEATURE_LEVEL_9_3
)
;
limitations
-
>
noSeparateStencilRefsAndMasks
=
true
;
limitations
-
>
noSimultaneousConstantColorAndAlphaBlendFunc
=
true
;
limitations
-
>
noDoubleBoundTransformFeedbackBuffers
=
true
;
limitations
-
>
noVertexAttributeAliasing
=
true
;
#
ifdef
ANGLE_ENABLE_WINDOWS_UWP
limitations
-
>
attributeZeroRequiresZeroDivisorInEXT
=
true
;
#
endif
}
}
namespace
gl_d3d11
{
D3D11_BLEND
ConvertBlendFunc
(
GLenum
glBlend
bool
isAlpha
)
{
D3D11_BLEND
d3dBlend
=
D3D11_BLEND_ZERO
;
switch
(
glBlend
)
{
case
GL_ZERO
:
d3dBlend
=
D3D11_BLEND_ZERO
;
break
;
case
GL_ONE
:
d3dBlend
=
D3D11_BLEND_ONE
;
break
;
case
GL_SRC_COLOR
:
d3dBlend
=
(
isAlpha
?
D3D11_BLEND_SRC_ALPHA
:
D3D11_BLEND_SRC_COLOR
)
;
break
;
case
GL_ONE_MINUS_SRC_COLOR
:
d3dBlend
=
(
isAlpha
?
D3D11_BLEND_INV_SRC_ALPHA
:
D3D11_BLEND_INV_SRC_COLOR
)
;
break
;
case
GL_DST_COLOR
:
d3dBlend
=
(
isAlpha
?
D3D11_BLEND_DEST_ALPHA
:
D3D11_BLEND_DEST_COLOR
)
;
break
;
case
GL_ONE_MINUS_DST_COLOR
:
d3dBlend
=
(
isAlpha
?
D3D11_BLEND_INV_DEST_ALPHA
:
D3D11_BLEND_INV_DEST_COLOR
)
;
break
;
case
GL_SRC_ALPHA
:
d3dBlend
=
D3D11_BLEND_SRC_ALPHA
;
break
;
case
GL_ONE_MINUS_SRC_ALPHA
:
d3dBlend
=
D3D11_BLEND_INV_SRC_ALPHA
;
break
;
case
GL_DST_ALPHA
:
d3dBlend
=
D3D11_BLEND_DEST_ALPHA
;
break
;
case
GL_ONE_MINUS_DST_ALPHA
:
d3dBlend
=
D3D11_BLEND_INV_DEST_ALPHA
;
break
;
case
GL_CONSTANT_COLOR
:
d3dBlend
=
D3D11_BLEND_BLEND_FACTOR
;
break
;
case
GL_ONE_MINUS_CONSTANT_COLOR
:
d3dBlend
=
D3D11_BLEND_INV_BLEND_FACTOR
;
break
;
case
GL_CONSTANT_ALPHA
:
d3dBlend
=
D3D11_BLEND_BLEND_FACTOR
;
break
;
case
GL_ONE_MINUS_CONSTANT_ALPHA
:
d3dBlend
=
D3D11_BLEND_INV_BLEND_FACTOR
;
break
;
case
GL_SRC_ALPHA_SATURATE
:
d3dBlend
=
D3D11_BLEND_SRC_ALPHA_SAT
;
break
;
case
GL_SRC1_COLOR_EXT
:
d3dBlend
=
(
isAlpha
?
D3D11_BLEND_SRC1_ALPHA
:
D3D11_BLEND_SRC1_COLOR
)
;
break
;
case
GL_SRC1_ALPHA_EXT
:
d3dBlend
=
D3D11_BLEND_SRC1_ALPHA
;
break
;
case
GL_ONE_MINUS_SRC1_COLOR_EXT
:
d3dBlend
=
(
isAlpha
?
D3D11_BLEND_INV_SRC1_ALPHA
:
D3D11_BLEND_INV_SRC1_COLOR
)
;
break
;
case
GL_ONE_MINUS_SRC1_ALPHA_EXT
:
d3dBlend
=
D3D11_BLEND_INV_SRC1_ALPHA
;
break
;
default
:
UNREACHABLE
(
)
;
}
return
d3dBlend
;
}
D3D11_BLEND_OP
ConvertBlendOp
(
GLenum
glBlendOp
)
{
D3D11_BLEND_OP
d3dBlendOp
=
D3D11_BLEND_OP_ADD
;
switch
(
glBlendOp
)
{
case
GL_FUNC_ADD
:
d3dBlendOp
=
D3D11_BLEND_OP_ADD
;
break
;
case
GL_FUNC_SUBTRACT
:
d3dBlendOp
=
D3D11_BLEND_OP_SUBTRACT
;
break
;
case
GL_FUNC_REVERSE_SUBTRACT
:
d3dBlendOp
=
D3D11_BLEND_OP_REV_SUBTRACT
;
break
;
case
GL_MIN
:
d3dBlendOp
=
D3D11_BLEND_OP_MIN
;
break
;
case
GL_MAX
:
d3dBlendOp
=
D3D11_BLEND_OP_MAX
;
break
;
default
:
UNREACHABLE
(
)
;
}
return
d3dBlendOp
;
}
UINT8
ConvertColorMask
(
bool
red
bool
green
bool
blue
bool
alpha
)
{
UINT8
mask
=
0
;
if
(
red
)
{
mask
|
=
D3D11_COLOR_WRITE_ENABLE_RED
;
}
if
(
green
)
{
mask
|
=
D3D11_COLOR_WRITE_ENABLE_GREEN
;
}
if
(
blue
)
{
mask
|
=
D3D11_COLOR_WRITE_ENABLE_BLUE
;
}
if
(
alpha
)
{
mask
|
=
D3D11_COLOR_WRITE_ENABLE_ALPHA
;
}
return
mask
;
}
D3D11_CULL_MODE
ConvertCullMode
(
bool
cullEnabled
gl
:
:
CullFaceMode
cullMode
)
{
D3D11_CULL_MODE
cull
=
D3D11_CULL_NONE
;
if
(
cullEnabled
)
{
switch
(
cullMode
)
{
case
gl
:
:
CullFaceMode
:
:
Front
:
cull
=
D3D11_CULL_FRONT
;
break
;
case
gl
:
:
CullFaceMode
:
:
Back
:
cull
=
D3D11_CULL_BACK
;
break
;
case
gl
:
:
CullFaceMode
:
:
FrontAndBack
:
cull
=
D3D11_CULL_NONE
;
break
;
default
:
UNREACHABLE
(
)
;
}
}
else
{
cull
=
D3D11_CULL_NONE
;
}
return
cull
;
}
D3D11_COMPARISON_FUNC
ConvertComparison
(
GLenum
comparison
)
{
D3D11_COMPARISON_FUNC
d3dComp
=
D3D11_COMPARISON_NEVER
;
switch
(
comparison
)
{
case
GL_NEVER
:
d3dComp
=
D3D11_COMPARISON_NEVER
;
break
;
case
GL_ALWAYS
:
d3dComp
=
D3D11_COMPARISON_ALWAYS
;
break
;
case
GL_LESS
:
d3dComp
=
D3D11_COMPARISON_LESS
;
break
;
case
GL_LEQUAL
:
d3dComp
=
D3D11_COMPARISON_LESS_EQUAL
;
break
;
case
GL_EQUAL
:
d3dComp
=
D3D11_COMPARISON_EQUAL
;
break
;
case
GL_GREATER
:
d3dComp
=
D3D11_COMPARISON_GREATER
;
break
;
case
GL_GEQUAL
:
d3dComp
=
D3D11_COMPARISON_GREATER_EQUAL
;
break
;
case
GL_NOTEQUAL
:
d3dComp
=
D3D11_COMPARISON_NOT_EQUAL
;
break
;
default
:
UNREACHABLE
(
)
;
}
return
d3dComp
;
}
D3D11_DEPTH_WRITE_MASK
ConvertDepthMask
(
bool
depthWriteEnabled
)
{
return
depthWriteEnabled
?
D3D11_DEPTH_WRITE_MASK_ALL
:
D3D11_DEPTH_WRITE_MASK_ZERO
;
}
UINT8
ConvertStencilMask
(
GLuint
stencilmask
)
{
return
static_cast
<
UINT8
>
(
stencilmask
)
;
}
D3D11_STENCIL_OP
ConvertStencilOp
(
GLenum
stencilOp
)
{
D3D11_STENCIL_OP
d3dStencilOp
=
D3D11_STENCIL_OP_KEEP
;
switch
(
stencilOp
)
{
case
GL_ZERO
:
d3dStencilOp
=
D3D11_STENCIL_OP_ZERO
;
break
;
case
GL_KEEP
:
d3dStencilOp
=
D3D11_STENCIL_OP_KEEP
;
break
;
case
GL_REPLACE
:
d3dStencilOp
=
D3D11_STENCIL_OP_REPLACE
;
break
;
case
GL_INCR
:
d3dStencilOp
=
D3D11_STENCIL_OP_INCR_SAT
;
break
;
case
GL_DECR
:
d3dStencilOp
=
D3D11_STENCIL_OP_DECR_SAT
;
break
;
case
GL_INVERT
:
d3dStencilOp
=
D3D11_STENCIL_OP_INVERT
;
break
;
case
GL_INCR_WRAP
:
d3dStencilOp
=
D3D11_STENCIL_OP_INCR
;
break
;
case
GL_DECR_WRAP
:
d3dStencilOp
=
D3D11_STENCIL_OP_DECR
;
break
;
default
:
UNREACHABLE
(
)
;
}
return
d3dStencilOp
;
}
D3D11_FILTER
ConvertFilter
(
GLenum
minFilter
GLenum
magFilter
float
maxAnisotropy
GLenum
comparisonMode
)
{
bool
comparison
=
comparisonMode
!
=
GL_NONE
;
if
(
maxAnisotropy
>
1
.
0f
)
{
return
D3D11_ENCODE_ANISOTROPIC_FILTER
(
static_cast
<
D3D11_COMPARISON_FUNC
>
(
comparison
)
)
;
}
else
{
D3D11_FILTER_TYPE
dxMin
=
D3D11_FILTER_TYPE_POINT
;
D3D11_FILTER_TYPE
dxMip
=
D3D11_FILTER_TYPE_POINT
;
switch
(
minFilter
)
{
case
GL_NEAREST
:
dxMin
=
D3D11_FILTER_TYPE_POINT
;
dxMip
=
D3D11_FILTER_TYPE_POINT
;
break
;
case
GL_LINEAR
:
dxMin
=
D3D11_FILTER_TYPE_LINEAR
;
dxMip
=
D3D11_FILTER_TYPE_POINT
;
break
;
case
GL_NEAREST_MIPMAP_NEAREST
:
dxMin
=
D3D11_FILTER_TYPE_POINT
;
dxMip
=
D3D11_FILTER_TYPE_POINT
;
break
;
case
GL_LINEAR_MIPMAP_NEAREST
:
dxMin
=
D3D11_FILTER_TYPE_LINEAR
;
dxMip
=
D3D11_FILTER_TYPE_POINT
;
break
;
case
GL_NEAREST_MIPMAP_LINEAR
:
dxMin
=
D3D11_FILTER_TYPE_POINT
;
dxMip
=
D3D11_FILTER_TYPE_LINEAR
;
break
;
case
GL_LINEAR_MIPMAP_LINEAR
:
dxMin
=
D3D11_FILTER_TYPE_LINEAR
;
dxMip
=
D3D11_FILTER_TYPE_LINEAR
;
break
;
default
:
UNREACHABLE
(
)
;
}
D3D11_FILTER_TYPE
dxMag
=
D3D11_FILTER_TYPE_POINT
;
switch
(
magFilter
)
{
case
GL_NEAREST
:
dxMag
=
D3D11_FILTER_TYPE_POINT
;
break
;
case
GL_LINEAR
:
dxMag
=
D3D11_FILTER_TYPE_LINEAR
;
break
;
default
:
UNREACHABLE
(
)
;
}
return
D3D11_ENCODE_BASIC_FILTER
(
dxMin
dxMag
dxMip
static_cast
<
D3D11_COMPARISON_FUNC
>
(
comparison
)
)
;
}
}
D3D11_TEXTURE_ADDRESS_MODE
ConvertTextureWrap
(
GLenum
wrap
)
{
switch
(
wrap
)
{
case
GL_REPEAT
:
return
D3D11_TEXTURE_ADDRESS_WRAP
;
case
GL_CLAMP_TO_EDGE
:
return
D3D11_TEXTURE_ADDRESS_CLAMP
;
case
GL_CLAMP_TO_BORDER
:
return
D3D11_TEXTURE_ADDRESS_BORDER
;
case
GL_MIRRORED_REPEAT
:
return
D3D11_TEXTURE_ADDRESS_MIRROR
;
default
:
UNREACHABLE
(
)
;
}
return
D3D11_TEXTURE_ADDRESS_WRAP
;
}
UINT
ConvertMaxAnisotropy
(
float
maxAnisotropy
D3D_FEATURE_LEVEL
featureLevel
)
{
return
static_cast
<
UINT
>
(
std
:
:
min
(
maxAnisotropy
d3d11_gl
:
:
GetMaximumAnisotropy
(
featureLevel
)
)
)
;
}
D3D11_QUERY
ConvertQueryType
(
gl
:
:
QueryType
type
)
{
switch
(
type
)
{
case
gl
:
:
QueryType
:
:
AnySamples
:
case
gl
:
:
QueryType
:
:
AnySamplesConservative
:
return
D3D11_QUERY_OCCLUSION
;
case
gl
:
:
QueryType
:
:
TransformFeedbackPrimitivesWritten
:
return
D3D11_QUERY_SO_STATISTICS
;
case
gl
:
:
QueryType
:
:
TimeElapsed
:
return
D3D11_QUERY_TIMESTAMP_DISJOINT
;
case
gl
:
:
QueryType
:
:
CommandsCompleted
:
return
D3D11_QUERY_EVENT
;
default
:
UNREACHABLE
(
)
;
return
D3D11_QUERY_EVENT
;
}
}
UINT8
GetColorMask
(
const
gl
:
:
InternalFormat
&
format
)
{
return
ConvertColorMask
(
format
.
redBits
>
0
format
.
greenBits
>
0
format
.
blueBits
>
0
format
.
alphaBits
>
0
)
;
}
}
namespace
d3d11
{
ANGLED3D11DeviceType
GetDeviceType
(
ID3D11Device
*
device
)
{
IDXGIDevice
*
dxgiDevice
=
nullptr
;
IDXGIAdapter
*
dxgiAdapter
=
nullptr
;
IDXGIAdapter2
*
dxgiAdapter2
=
nullptr
;
ANGLED3D11DeviceType
retDeviceType
=
ANGLE_D3D11_DEVICE_TYPE_UNKNOWN
;
HRESULT
hr
=
device
-
>
QueryInterface
(
__uuidof
(
IDXGIDevice
)
(
void
*
*
)
&
dxgiDevice
)
;
if
(
SUCCEEDED
(
hr
)
)
{
hr
=
dxgiDevice
-
>
GetParent
(
__uuidof
(
IDXGIAdapter
)
(
void
*
*
)
&
dxgiAdapter
)
;
if
(
SUCCEEDED
(
hr
)
)
{
std
:
:
wstring
adapterString
;
HRESULT
adapter2hr
=
dxgiAdapter
-
>
QueryInterface
(
__uuidof
(
dxgiAdapter2
)
(
void
*
*
)
&
dxgiAdapter2
)
;
if
(
SUCCEEDED
(
adapter2hr
)
)
{
DXGI_ADAPTER_DESC2
adapterDesc2
;
dxgiAdapter2
-
>
GetDesc2
(
&
adapterDesc2
)
;
adapterString
=
std
:
:
wstring
(
adapterDesc2
.
Description
)
;
}
else
{
DXGI_ADAPTER_DESC
adapterDesc
;
dxgiAdapter
-
>
GetDesc
(
&
adapterDesc
)
;
adapterString
=
std
:
:
wstring
(
adapterDesc
.
Description
)
;
}
const
bool
isSoftwareDevice
=
(
adapterString
.
find
(
std
:
:
wstring
(
L
"
Software
Adapter
"
)
)
!
=
std
:
:
string
:
:
npos
)
;
const
bool
isNullDevice
=
(
adapterString
=
=
L
"
"
)
;
const
bool
isWARPDevice
=
(
adapterString
.
find
(
std
:
:
wstring
(
L
"
Basic
Render
"
)
)
!
=
std
:
:
string
:
:
npos
)
;
if
(
isSoftwareDevice
|
|
isNullDevice
)
{
ASSERT
(
!
isWARPDevice
)
;
retDeviceType
=
ANGLE_D3D11_DEVICE_TYPE_SOFTWARE_REF_OR_NULL
;
}
else
if
(
isWARPDevice
)
{
retDeviceType
=
ANGLE_D3D11_DEVICE_TYPE_WARP
;
}
else
{
retDeviceType
=
ANGLE_D3D11_DEVICE_TYPE_HARDWARE
;
}
}
}
SafeRelease
(
dxgiDevice
)
;
SafeRelease
(
dxgiAdapter
)
;
SafeRelease
(
dxgiAdapter2
)
;
return
retDeviceType
;
}
void
MakeValidSize
(
bool
isImage
DXGI_FORMAT
format
GLsizei
*
requestWidth
GLsizei
*
requestHeight
int
*
levelOffset
)
{
const
DXGIFormatSize
&
dxgiFormatInfo
=
d3d11
:
:
GetDXGIFormatSizeInfo
(
format
)
;
bool
validFormat
=
format
!
=
DXGI_FORMAT_UNKNOWN
;
bool
validImage
=
isImage
&
&
validFormat
;
int
upsampleCount
=
0
;
if
(
validImage
|
|
*
requestWidth
<
static_cast
<
GLsizei
>
(
dxgiFormatInfo
.
blockWidth
)
|
|
*
requestHeight
<
static_cast
<
GLsizei
>
(
dxgiFormatInfo
.
blockHeight
)
)
{
while
(
*
requestWidth
%
dxgiFormatInfo
.
blockWidth
!
=
0
|
|
*
requestHeight
%
dxgiFormatInfo
.
blockHeight
!
=
0
)
{
*
requestWidth
<
<
=
1
;
*
requestHeight
<
<
=
1
;
upsampleCount
+
+
;
}
}
else
if
(
validFormat
)
{
if
(
*
requestWidth
%
dxgiFormatInfo
.
blockWidth
!
=
0
)
{
*
requestWidth
=
roundUp
(
*
requestWidth
static_cast
<
GLsizei
>
(
dxgiFormatInfo
.
blockWidth
)
)
;
}
if
(
*
requestHeight
%
dxgiFormatInfo
.
blockHeight
!
=
0
)
{
*
requestHeight
=
roundUp
(
*
requestHeight
static_cast
<
GLsizei
>
(
dxgiFormatInfo
.
blockHeight
)
)
;
}
}
if
(
levelOffset
)
{
*
levelOffset
=
upsampleCount
;
}
}
angle
:
:
Result
GenerateInitialTextureData
(
const
gl
:
:
Context
*
context
GLint
internalFormat
const
Renderer11DeviceCaps
&
renderer11DeviceCaps
GLuint
width
GLuint
height
GLuint
depth
GLuint
mipLevels
gl
:
:
TexLevelArray
<
D3D11_SUBRESOURCE_DATA
>
*
outSubresourceData
)
{
const
d3d11
:
:
Format
&
d3dFormatInfo
=
d3d11
:
:
Format
:
:
Get
(
internalFormat
renderer11DeviceCaps
)
;
ASSERT
(
d3dFormatInfo
.
dataInitializerFunction
!
=
nullptr
)
;
const
d3d11
:
:
DXGIFormatSize
&
dxgiFormatInfo
=
d3d11
:
:
GetDXGIFormatSizeInfo
(
d3dFormatInfo
.
texFormat
)
;
using
CheckedSize
=
angle
:
:
CheckedNumeric
<
size_t
>
;
CheckedSize
rowPitch
=
CheckedSize
(
dxgiFormatInfo
.
pixelBytes
)
*
CheckedSize
(
width
)
;
CheckedSize
depthPitch
=
rowPitch
*
CheckedSize
(
height
)
;
CheckedSize
maxImageSize
=
depthPitch
*
CheckedSize
(
depth
)
;
Context11
*
context11
=
GetImplAs
<
Context11
>
(
context
)
;
ANGLE_CHECK_GL_ALLOC
(
context11
maxImageSize
.
IsValid
(
)
)
;
angle
:
:
MemoryBuffer
*
scratchBuffer
=
nullptr
;
ANGLE_CHECK_GL_ALLOC
(
context11
context
-
>
getScratchBuffer
(
maxImageSize
.
ValueOrDie
(
)
&
scratchBuffer
)
)
;
d3dFormatInfo
.
dataInitializerFunction
(
width
height
depth
scratchBuffer
-
>
data
(
)
rowPitch
.
ValueOrDie
(
)
depthPitch
.
ValueOrDie
(
)
)
;
for
(
unsigned
int
i
=
0
;
i
<
mipLevels
;
i
+
+
)
{
unsigned
int
mipWidth
=
std
:
:
max
(
width
>
>
i
1U
)
;
unsigned
int
mipHeight
=
std
:
:
max
(
height
>
>
i
1U
)
;
using
CheckedUINT
=
angle
:
:
CheckedNumeric
<
UINT
>
;
CheckedUINT
mipRowPitch
=
CheckedUINT
(
dxgiFormatInfo
.
pixelBytes
)
*
CheckedUINT
(
mipWidth
)
;
CheckedUINT
mipDepthPitch
=
mipRowPitch
*
CheckedUINT
(
mipHeight
)
;
ANGLE_CHECK_GL_ALLOC
(
context11
mipRowPitch
.
IsValid
(
)
&
&
mipDepthPitch
.
IsValid
(
)
)
;
outSubresourceData
-
>
at
(
i
)
.
pSysMem
=
scratchBuffer
-
>
data
(
)
;
outSubresourceData
-
>
at
(
i
)
.
SysMemPitch
=
mipRowPitch
.
ValueOrDie
(
)
;
outSubresourceData
-
>
at
(
i
)
.
SysMemSlicePitch
=
mipDepthPitch
.
ValueOrDie
(
)
;
}
return
angle
:
:
Result
:
:
Continue
;
}
UINT
GetPrimitiveRestartIndex
(
)
{
return
std
:
:
numeric_limits
<
UINT
>
:
:
max
(
)
;
}
void
SetPositionTexCoordVertex
(
PositionTexCoordVertex
*
vertex
float
x
float
y
float
u
float
v
)
{
vertex
-
>
x
=
x
;
vertex
-
>
y
=
y
;
vertex
-
>
u
=
u
;
vertex
-
>
v
=
v
;
}
void
SetPositionLayerTexCoord3DVertex
(
PositionLayerTexCoord3DVertex
*
vertex
float
x
float
y
unsigned
int
layer
float
u
float
v
float
s
)
{
vertex
-
>
x
=
x
;
vertex
-
>
y
=
y
;
vertex
-
>
l
=
layer
;
vertex
-
>
u
=
u
;
vertex
-
>
v
=
v
;
vertex
-
>
s
=
s
;
}
BlendStateKey
:
:
BlendStateKey
(
)
{
memset
(
this
0
sizeof
(
BlendStateKey
)
)
;
blendStateExt
=
gl
:
:
BlendStateExt
(
)
;
}
BlendStateKey
:
:
BlendStateKey
(
const
BlendStateKey
&
other
)
{
memcpy
(
this
&
other
sizeof
(
BlendStateKey
)
)
;
}
bool
operator
=
=
(
const
BlendStateKey
&
a
const
BlendStateKey
&
b
)
{
return
memcmp
(
&
a
&
b
sizeof
(
BlendStateKey
)
)
=
=
0
;
}
bool
operator
!
=
(
const
BlendStateKey
&
a
const
BlendStateKey
&
b
)
{
return
!
(
a
=
=
b
)
;
}
RasterizerStateKey
:
:
RasterizerStateKey
(
)
{
memset
(
this
0
sizeof
(
RasterizerStateKey
)
)
;
}
bool
operator
=
=
(
const
RasterizerStateKey
&
a
const
RasterizerStateKey
&
b
)
{
return
memcmp
(
&
a
&
b
sizeof
(
RasterizerStateKey
)
)
=
=
0
;
}
bool
operator
!
=
(
const
RasterizerStateKey
&
a
const
RasterizerStateKey
&
b
)
{
return
!
(
a
=
=
b
)
;
}
HRESULT
SetDebugName
(
ID3D11DeviceChild
*
resource
const
char
*
name
)
{
UINT
existingDataSize
=
0
;
resource
-
>
GetPrivateData
(
WKPDID_D3DDebugObjectName
&
existingDataSize
nullptr
)
;
if
(
existingDataSize
>
0
)
{
static
const
char
*
multipleNamesUsed
=
"
MultipleNamesSetByANGLE
"
;
const
HRESULT
hr
=
resource
-
>
SetPrivateData
(
WKPDID_D3DDebugObjectName
0
nullptr
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
name
=
multipleNamesUsed
;
}
const
std
:
:
string
d3dName
=
std
:
:
string
(
"
ANGLE_
"
)
+
name
;
return
resource
-
>
SetPrivateData
(
WKPDID_D3DDebugObjectName
static_cast
<
UINT
>
(
d3dName
.
size
(
)
)
d3dName
.
c_str
(
)
)
;
}
template
<
ResourceType
ResourceT
>
angle
:
:
Result
LazyResource
<
ResourceT
>
:
:
resolveImpl
(
d3d
:
:
Context
*
context
Renderer11
*
renderer
const
GetDescType
<
ResourceT
>
&
desc
GetInitDataType
<
ResourceT
>
*
initData
const
char
*
name
)
{
if
(
!
mResource
.
valid
(
)
)
{
ANGLE_TRY
(
renderer
-
>
allocateResource
(
context
desc
initData
&
mResource
)
)
;
mResource
.
setDebugName
(
name
)
;
}
return
angle
:
:
Result
:
:
Continue
;
}
template
angle
:
:
Result
LazyResource
<
ResourceType
:
:
BlendState
>
:
:
resolveImpl
(
d3d
:
:
Context
*
context
Renderer11
*
renderer
const
D3D11_BLEND_DESC
&
desc
void
*
initData
const
char
*
name
)
;
template
angle
:
:
Result
LazyResource
<
ResourceType
:
:
ComputeShader
>
:
:
resolveImpl
(
d3d
:
:
Context
*
context
Renderer11
*
renderer
const
ShaderData
&
desc
void
*
initData
const
char
*
name
)
;
template
angle
:
:
Result
LazyResource
<
ResourceType
:
:
GeometryShader
>
:
:
resolveImpl
(
d3d
:
:
Context
*
context
Renderer11
*
renderer
const
ShaderData
&
desc
const
std
:
:
vector
<
D3D11_SO_DECLARATION_ENTRY
>
*
initData
const
char
*
name
)
;
template
angle
:
:
Result
LazyResource
<
ResourceType
:
:
InputLayout
>
:
:
resolveImpl
(
d3d
:
:
Context
*
context
Renderer11
*
renderer
const
InputElementArray
&
desc
const
ShaderData
*
initData
const
char
*
name
)
;
template
angle
:
:
Result
LazyResource
<
ResourceType
:
:
PixelShader
>
:
:
resolveImpl
(
d3d
:
:
Context
*
context
Renderer11
*
renderer
const
ShaderData
&
desc
void
*
initData
const
char
*
name
)
;
template
angle
:
:
Result
LazyResource
<
ResourceType
:
:
VertexShader
>
:
:
resolveImpl
(
d3d
:
:
Context
*
context
Renderer11
*
renderer
const
ShaderData
&
desc
void
*
initData
const
char
*
name
)
;
LazyInputLayout
:
:
LazyInputLayout
(
const
D3D11_INPUT_ELEMENT_DESC
*
inputDesc
size_t
inputDescLen
const
BYTE
*
byteCode
size_t
byteCodeLen
const
char
*
debugName
)
:
mInputDesc
(
inputDesc
inputDescLen
)
mByteCode
(
byteCode
byteCodeLen
)
mDebugName
(
debugName
)
{
}
LazyInputLayout
:
:
~
LazyInputLayout
(
)
{
}
angle
:
:
Result
LazyInputLayout
:
:
resolve
(
d3d
:
:
Context
*
context
Renderer11
*
renderer
)
{
return
resolveImpl
(
context
renderer
mInputDesc
&
mByteCode
mDebugName
)
;
}
LazyBlendState
:
:
LazyBlendState
(
const
D3D11_BLEND_DESC
&
desc
const
char
*
debugName
)
:
mDesc
(
desc
)
mDebugName
(
debugName
)
{
}
angle
:
:
Result
LazyBlendState
:
:
resolve
(
d3d
:
:
Context
*
context
Renderer11
*
renderer
)
{
return
resolveImpl
(
context
renderer
mDesc
nullptr
mDebugName
)
;
}
void
InitializeFeatures
(
const
Renderer11DeviceCaps
&
deviceCaps
const
DXGI_ADAPTER_DESC
&
adapterDesc
angle
:
:
FeaturesD3D
*
features
)
{
bool
isNvidia
=
IsNvidia
(
adapterDesc
.
VendorId
)
;
bool
isIntel
=
IsIntel
(
adapterDesc
.
VendorId
)
;
bool
isSkylake
=
false
;
bool
isBroadwell
=
false
;
bool
isHaswell
=
false
;
bool
isIvyBridge
=
false
;
bool
isSandyBridge
=
false
;
bool
isAMD
=
IsAMD
(
adapterDesc
.
VendorId
)
;
bool
isFeatureLevel9_3
=
(
deviceCaps
.
featureLevel
<
=
D3D_FEATURE_LEVEL_9_3
)
;
IntelDriverVersion
capsVersion
=
IntelDriverVersion
(
0
)
;
if
(
isIntel
)
{
capsVersion
=
d3d11_gl
:
:
GetIntelDriverVersion
(
deviceCaps
.
driverVersion
)
;
isSkylake
=
IsSkylake
(
adapterDesc
.
DeviceId
)
;
isBroadwell
=
IsBroadwell
(
adapterDesc
.
DeviceId
)
;
isHaswell
=
IsHaswell
(
adapterDesc
.
DeviceId
)
;
isIvyBridge
=
IsIvyBridge
(
adapterDesc
.
DeviceId
)
;
isSandyBridge
=
IsSandyBridge
(
adapterDesc
.
DeviceId
)
;
}
if
(
isNvidia
)
{
bool
driverVersionValid
=
deviceCaps
.
driverVersion
.
valid
(
)
;
if
(
driverVersionValid
)
{
WORD
part1
=
HIWORD
(
deviceCaps
.
driverVersion
.
value
(
)
.
LowPart
)
;
WORD
part2
=
LOWORD
(
deviceCaps
.
driverVersion
.
value
(
)
.
LowPart
)
;
ANGLE_FEATURE_CONDITION
(
features
depthStencilBlitExtraCopy
(
part1
<
=
13u
&
&
part2
<
6881
)
&
&
isNvidia
&
&
driverVersionValid
)
;
}
else
{
ANGLE_FEATURE_CONDITION
(
features
depthStencilBlitExtraCopy
isNvidia
&
&
!
driverVersionValid
)
;
}
}
ANGLE_FEATURE_CONDITION
(
features
mrtPerfWorkaround
true
)
;
ANGLE_FEATURE_CONDITION
(
features
zeroMaxLodWorkaround
isFeatureLevel9_3
)
;
ANGLE_FEATURE_CONDITION
(
features
useInstancedPointSpriteEmulation
isFeatureLevel9_3
)
;
ANGLE_FEATURE_CONDITION
(
features
allowES3OnFL10_0
false
)
;
ANGLE_FEATURE_CONDITION
(
features
expandIntegerPowExpressions
true
)
;
ANGLE_FEATURE_CONDITION
(
features
flushAfterEndingTransformFeedback
isNvidia
)
;
ANGLE_FEATURE_CONDITION
(
features
getDimensionsIgnoresBaseLevel
isNvidia
)
;
ANGLE_FEATURE_CONDITION
(
features
skipVSConstantRegisterZero
isNvidia
)
;
ANGLE_FEATURE_CONDITION
(
features
forceAtomicValueResolution
isNvidia
)
;
ANGLE_FEATURE_CONDITION
(
features
preAddTexelFetchOffsets
isIntel
)
;
ANGLE_FEATURE_CONDITION
(
features
useSystemMemoryForConstantBuffers
isIntel
)
;
ANGLE_FEATURE_CONDITION
(
features
callClearTwice
isIntel
&
&
isSkylake
&
&
capsVersion
<
IntelDriverVersion
(
4771
)
)
;
ANGLE_FEATURE_CONDITION
(
features
emulateIsnanFloat
isIntel
&
&
isSkylake
&
&
capsVersion
<
IntelDriverVersion
(
4542
)
)
;
ANGLE_FEATURE_CONDITION
(
features
rewriteUnaryMinusOperator
isIntel
&
&
(
isBroadwell
|
|
isHaswell
)
&
&
capsVersion
<
IntelDriverVersion
(
4624
)
)
;
ANGLE_FEATURE_CONDITION
(
features
addMockTextureNoRenderTarget
isIntel
&
&
capsVersion
<
IntelDriverVersion
(
4815
)
)
;
ANGLE_FEATURE_CONDITION
(
features
setDataFasterThanImageUpload
true
)
;
ANGLE_FEATURE_CONDITION
(
features
setDataFasterThanImageUploadOn128bitFormats
!
(
isIvyBridge
|
|
isBroadwell
|
|
isHaswell
)
)
;
ANGLE_FEATURE_CONDITION
(
features
emulateClearViewAfterDualSourceBlending
isSandyBridge
)
;
ANGLE_FEATURE_CONDITION
(
features
disableB5G6R5Support
(
isIntel
&
&
capsVersion
<
IntelDriverVersion
(
4539
)
)
|
|
isAMD
)
;
ANGLE_FEATURE_CONDITION
(
features
emulateTinyStencilTextures
isAMD
&
&
!
(
deviceCaps
.
featureLevel
<
D3D_FEATURE_LEVEL_10_1
)
)
;
ANGLE_FEATURE_CONDITION
(
features
selectViewInGeometryShader
!
deviceCaps
.
supportsVpRtIndexWriteFromVertexShader
)
;
ANGLE_FEATURE_CONDITION
(
features
allowClearForRobustResourceInit
true
)
;
ANGLE_FEATURE_CONDITION
(
features
allowTranslateUniformBlockToStructuredBuffer
IsWin10OrGreater
(
)
)
;
auto
*
platform
=
ANGLEPlatformCurrent
(
)
;
platform
-
>
overrideWorkaroundsD3D
(
platform
features
)
;
}
void
InitConstantBufferDesc
(
D3D11_BUFFER_DESC
*
constantBufferDescription
size_t
byteWidth
)
{
constantBufferDescription
-
>
ByteWidth
=
static_cast
<
UINT
>
(
byteWidth
)
;
constantBufferDescription
-
>
Usage
=
D3D11_USAGE_DYNAMIC
;
constantBufferDescription
-
>
BindFlags
=
D3D11_BIND_CONSTANT_BUFFER
;
constantBufferDescription
-
>
CPUAccessFlags
=
D3D11_CPU_ACCESS_WRITE
;
constantBufferDescription
-
>
MiscFlags
=
0
;
constantBufferDescription
-
>
StructureByteStride
=
0
;
}
}
TextureHelper11
:
:
TextureHelper11
(
)
:
mFormatSet
(
nullptr
)
mSampleCount
(
0
)
{
}
TextureHelper11
:
:
TextureHelper11
(
TextureHelper11
&
&
toCopy
)
:
TextureHelper11
(
)
{
*
this
=
std
:
:
move
(
toCopy
)
;
}
TextureHelper11
:
:
TextureHelper11
(
const
TextureHelper11
&
other
)
:
mFormatSet
(
other
.
mFormatSet
)
mExtents
(
other
.
mExtents
)
mSampleCount
(
other
.
mSampleCount
)
{
mData
=
other
.
mData
;
}
TextureHelper11
:
:
~
TextureHelper11
(
)
{
}
void
TextureHelper11
:
:
getDesc
(
D3D11_TEXTURE2D_DESC
*
desc
)
const
{
static_cast
<
ID3D11Texture2D
*
>
(
mData
-
>
object
)
-
>
GetDesc
(
desc
)
;
}
void
TextureHelper11
:
:
getDesc
(
D3D11_TEXTURE3D_DESC
*
desc
)
const
{
static_cast
<
ID3D11Texture3D
*
>
(
mData
-
>
object
)
-
>
GetDesc
(
desc
)
;
}
void
TextureHelper11
:
:
initDesc
(
const
D3D11_TEXTURE2D_DESC
&
desc2D
)
{
mData
-
>
resourceType
=
ResourceType
:
:
Texture2D
;
mExtents
.
width
=
static_cast
<
int
>
(
desc2D
.
Width
)
;
mExtents
.
height
=
static_cast
<
int
>
(
desc2D
.
Height
)
;
mExtents
.
depth
=
1
;
mSampleCount
=
desc2D
.
SampleDesc
.
Count
;
}
void
TextureHelper11
:
:
initDesc
(
const
D3D11_TEXTURE3D_DESC
&
desc3D
)
{
mData
-
>
resourceType
=
ResourceType
:
:
Texture3D
;
mExtents
.
width
=
static_cast
<
int
>
(
desc3D
.
Width
)
;
mExtents
.
height
=
static_cast
<
int
>
(
desc3D
.
Height
)
;
mExtents
.
depth
=
static_cast
<
int
>
(
desc3D
.
Depth
)
;
mSampleCount
=
1
;
}
TextureHelper11
&
TextureHelper11
:
:
operator
=
(
TextureHelper11
&
&
other
)
{
std
:
:
swap
(
mData
other
.
mData
)
;
std
:
:
swap
(
mExtents
other
.
mExtents
)
;
std
:
:
swap
(
mFormatSet
other
.
mFormatSet
)
;
std
:
:
swap
(
mSampleCount
other
.
mSampleCount
)
;
return
*
this
;
}
TextureHelper11
&
TextureHelper11
:
:
operator
=
(
const
TextureHelper11
&
other
)
{
mData
=
other
.
mData
;
mExtents
=
other
.
mExtents
;
mFormatSet
=
other
.
mFormatSet
;
mSampleCount
=
other
.
mSampleCount
;
return
*
this
;
}
bool
TextureHelper11
:
:
operator
=
=
(
const
TextureHelper11
&
other
)
const
{
return
mData
-
>
object
=
=
other
.
mData
-
>
object
;
}
bool
TextureHelper11
:
:
operator
!
=
(
const
TextureHelper11
&
other
)
const
{
return
mData
-
>
object
!
=
other
.
mData
-
>
object
;
}
bool
UsePresentPathFast
(
const
Renderer11
*
renderer
const
gl
:
:
FramebufferAttachment
*
framebufferAttachment
)
{
if
(
framebufferAttachment
=
=
nullptr
)
{
return
false
;
}
return
(
framebufferAttachment
-
>
type
(
)
=
=
GL_FRAMEBUFFER_DEFAULT
&
&
renderer
-
>
presentPathFastEnabled
(
)
)
;
}
bool
UsePrimitiveRestartWorkaround
(
bool
primitiveRestartFixedIndexEnabled
gl
:
:
DrawElementsType
type
)
{
return
(
!
primitiveRestartFixedIndexEnabled
&
&
type
=
=
gl
:
:
DrawElementsType
:
:
UnsignedShort
)
;
}
IndexStorageType
ClassifyIndexStorage
(
const
gl
:
:
State
&
glState
const
gl
:
:
Buffer
*
elementArrayBuffer
gl
:
:
DrawElementsType
elementType
gl
:
:
DrawElementsType
destElementType
unsigned
int
offset
)
{
if
(
!
elementArrayBuffer
|
|
!
IsOffsetAligned
(
elementType
offset
)
)
{
return
IndexStorageType
:
:
Dynamic
;
}
BufferD3D
*
bufferD3D
=
GetImplAs
<
BufferD3D
>
(
elementArrayBuffer
)
;
if
(
bufferD3D
-
>
supportsDirectBinding
(
)
&
&
destElementType
=
=
elementType
)
{
return
IndexStorageType
:
:
Direct
;
}
StaticIndexBufferInterface
*
staticBuffer
=
bufferD3D
-
>
getStaticIndexBuffer
(
)
;
if
(
staticBuffer
!
=
nullptr
)
{
return
IndexStorageType
:
:
Static
;
}
return
IndexStorageType
:
:
Dynamic
;
}
}
