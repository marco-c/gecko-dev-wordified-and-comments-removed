#
ifndef
LIBANGLE_RENDERER_RENDER_TARGET_CACHE_H_
#
define
LIBANGLE_RENDERER_RENDER_TARGET_CACHE_H_
#
include
"
libANGLE
/
Framebuffer
.
h
"
#
include
"
libANGLE
/
FramebufferAttachment
.
h
"
namespace
rx
{
template
<
typename
RenderTargetT
>
class
RenderTargetCache
final
:
angle
:
:
NonCopyable
{
public
:
RenderTargetCache
(
)
;
~
RenderTargetCache
(
)
;
angle
:
:
Result
update
(
const
gl
:
:
Context
*
context
const
gl
:
:
FramebufferState
&
state
const
gl
:
:
Framebuffer
:
:
DirtyBits
&
dirtyBits
)
;
angle
:
:
Result
updateColorRenderTarget
(
const
gl
:
:
Context
*
context
const
gl
:
:
FramebufferState
&
state
size_t
colorIndex
)
;
angle
:
:
Result
updateDepthStencilRenderTarget
(
const
gl
:
:
Context
*
context
const
gl
:
:
FramebufferState
&
state
)
;
using
RenderTargetArray
=
gl
:
:
AttachmentArray
<
RenderTargetT
*
>
;
const
RenderTargetArray
&
getColors
(
)
const
;
RenderTargetT
*
getDepthStencil
(
)
const
;
RenderTargetT
*
getColorRead
(
const
gl
:
:
FramebufferState
&
state
)
const
;
private
:
angle
:
:
Result
updateCachedRenderTarget
(
const
gl
:
:
Context
*
context
const
gl
:
:
FramebufferAttachment
*
attachment
RenderTargetT
*
*
cachedRenderTarget
)
;
gl
:
:
AttachmentArray
<
RenderTargetT
*
>
mColorRenderTargets
;
RenderTargetT
*
mDepthStencilRenderTarget
;
}
;
template
<
typename
RenderTargetT
>
RenderTargetCache
<
RenderTargetT
>
:
:
RenderTargetCache
(
)
:
mColorRenderTargets
{
{
nullptr
}
}
mDepthStencilRenderTarget
(
nullptr
)
{
}
template
<
typename
RenderTargetT
>
RenderTargetCache
<
RenderTargetT
>
:
:
~
RenderTargetCache
(
)
{
}
template
<
typename
RenderTargetT
>
angle
:
:
Result
RenderTargetCache
<
RenderTargetT
>
:
:
update
(
const
gl
:
:
Context
*
context
const
gl
:
:
FramebufferState
&
state
const
gl
:
:
Framebuffer
:
:
DirtyBits
&
dirtyBits
)
{
for
(
auto
dirtyBit
:
dirtyBits
)
{
switch
(
dirtyBit
)
{
case
gl
:
:
Framebuffer
:
:
DIRTY_BIT_DEPTH_ATTACHMENT
:
case
gl
:
:
Framebuffer
:
:
DIRTY_BIT_STENCIL_ATTACHMENT
:
ANGLE_TRY
(
updateDepthStencilRenderTarget
(
context
state
)
)
;
break
;
case
gl
:
:
Framebuffer
:
:
DIRTY_BIT_DRAW_BUFFERS
:
case
gl
:
:
Framebuffer
:
:
DIRTY_BIT_READ_BUFFER
:
case
gl
:
:
Framebuffer
:
:
DIRTY_BIT_DEFAULT_WIDTH
:
case
gl
:
:
Framebuffer
:
:
DIRTY_BIT_DEFAULT_HEIGHT
:
case
gl
:
:
Framebuffer
:
:
DIRTY_BIT_DEFAULT_SAMPLES
:
case
gl
:
:
Framebuffer
:
:
DIRTY_BIT_DEFAULT_FIXED_SAMPLE_LOCATIONS
:
break
;
default
:
{
static_assert
(
gl
:
:
Framebuffer
:
:
DIRTY_BIT_COLOR_ATTACHMENT_0
=
=
0
"
FB
dirty
bits
"
)
;
if
(
dirtyBit
<
gl
:
:
Framebuffer
:
:
DIRTY_BIT_COLOR_ATTACHMENT_MAX
)
{
size_t
colorIndex
=
static_cast
<
size_t
>
(
dirtyBit
-
gl
:
:
Framebuffer
:
:
DIRTY_BIT_COLOR_ATTACHMENT_0
)
;
ANGLE_TRY
(
updateColorRenderTarget
(
context
state
colorIndex
)
)
;
}
break
;
}
}
}
return
angle
:
:
Result
:
:
Continue
;
}
template
<
typename
RenderTargetT
>
const
gl
:
:
AttachmentArray
<
RenderTargetT
*
>
&
RenderTargetCache
<
RenderTargetT
>
:
:
getColors
(
)
const
{
return
mColorRenderTargets
;
}
template
<
typename
RenderTargetT
>
RenderTargetT
*
RenderTargetCache
<
RenderTargetT
>
:
:
getDepthStencil
(
)
const
{
return
mDepthStencilRenderTarget
;
}
template
<
typename
RenderTargetT
>
angle
:
:
Result
RenderTargetCache
<
RenderTargetT
>
:
:
updateColorRenderTarget
(
const
gl
:
:
Context
*
context
const
gl
:
:
FramebufferState
&
state
size_t
colorIndex
)
{
return
updateCachedRenderTarget
(
context
state
.
getColorAttachment
(
colorIndex
)
&
mColorRenderTargets
[
colorIndex
]
)
;
}
template
<
typename
RenderTargetT
>
angle
:
:
Result
RenderTargetCache
<
RenderTargetT
>
:
:
updateDepthStencilRenderTarget
(
const
gl
:
:
Context
*
context
const
gl
:
:
FramebufferState
&
state
)
{
return
updateCachedRenderTarget
(
context
state
.
getDepthOrStencilAttachment
(
)
&
mDepthStencilRenderTarget
)
;
}
template
<
typename
RenderTargetT
>
angle
:
:
Result
RenderTargetCache
<
RenderTargetT
>
:
:
updateCachedRenderTarget
(
const
gl
:
:
Context
*
context
const
gl
:
:
FramebufferAttachment
*
attachment
RenderTargetT
*
*
cachedRenderTarget
)
{
RenderTargetT
*
newRenderTarget
=
nullptr
;
if
(
attachment
)
{
ASSERT
(
attachment
-
>
isAttached
(
)
)
;
ANGLE_TRY
(
attachment
-
>
getRenderTarget
(
context
&
newRenderTarget
)
)
;
}
*
cachedRenderTarget
=
newRenderTarget
;
return
angle
:
:
Result
:
:
Continue
;
}
template
<
typename
RenderTargetT
>
RenderTargetT
*
RenderTargetCache
<
RenderTargetT
>
:
:
getColorRead
(
const
gl
:
:
FramebufferState
&
state
)
const
{
ASSERT
(
mColorRenderTargets
[
state
.
getReadIndex
(
)
]
&
&
state
.
getReadIndex
(
)
<
mColorRenderTargets
.
size
(
)
)
;
return
mColorRenderTargets
[
state
.
getReadIndex
(
)
]
;
}
}
#
endif
