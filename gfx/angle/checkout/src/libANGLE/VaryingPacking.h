#
ifndef
LIBANGLE_VARYINGPACKING_H_
#
define
LIBANGLE_VARYINGPACKING_H_
#
include
<
GLSLANG
/
ShaderVars
.
h
>
#
include
"
angle_gl
.
h
"
#
include
"
common
/
angleutils
.
h
"
#
include
"
libANGLE
/
angletypes
.
h
"
#
include
<
map
>
namespace
gl
{
class
HasAttachedShaders
;
class
InfoLog
;
class
ProgramExecutable
;
struct
Caps
;
struct
ProgramVaryingRef
;
using
ProgramMergedVaryings
=
std
:
:
vector
<
ProgramVaryingRef
>
;
struct
VaryingInShaderRef
:
angle
:
:
NonCopyable
{
VaryingInShaderRef
(
ShaderType
stageIn
const
sh
:
:
ShaderVariable
*
varyingIn
)
;
VaryingInShaderRef
(
VaryingInShaderRef
&
&
other
)
;
~
VaryingInShaderRef
(
)
;
VaryingInShaderRef
&
operator
=
(
VaryingInShaderRef
&
&
other
)
;
const
sh
:
:
ShaderVariable
*
varying
;
ShaderType
stage
;
std
:
:
string
parentStructName
;
std
:
:
string
parentStructMappedName
;
}
;
struct
PackedVarying
:
angle
:
:
NonCopyable
{
PackedVarying
(
VaryingInShaderRef
&
&
frontVaryingIn
VaryingInShaderRef
&
&
backVaryingIn
sh
:
:
InterpolationType
interpolationIn
)
;
PackedVarying
(
VaryingInShaderRef
&
&
frontVaryingIn
VaryingInShaderRef
&
&
backVaryingIn
sh
:
:
InterpolationType
interpolationIn
GLuint
arrayIndexIn
GLuint
fieldIndexIn
GLuint
secondaryFieldIndexIn
)
;
PackedVarying
(
PackedVarying
&
&
other
)
;
~
PackedVarying
(
)
;
PackedVarying
&
operator
=
(
PackedVarying
&
&
other
)
;
bool
isStructField
(
)
const
{
return
frontVarying
.
varying
?
!
frontVarying
.
parentStructName
.
empty
(
)
:
!
backVarying
.
parentStructName
.
empty
(
)
;
}
bool
isTransformFeedbackArrayElement
(
)
const
{
return
isTransformFeedback
&
&
arrayIndex
!
=
GL_INVALID_INDEX
;
}
const
sh
:
:
ShaderVariable
&
varying
(
)
const
{
return
frontVarying
.
varying
?
*
frontVarying
.
varying
:
*
backVarying
.
varying
;
}
const
std
:
:
string
&
getParentStructName
(
)
const
{
ASSERT
(
isStructField
(
)
)
;
return
frontVarying
.
varying
?
frontVarying
.
parentStructName
:
backVarying
.
parentStructName
;
}
std
:
:
string
fullName
(
ShaderType
stage
)
const
{
ASSERT
(
stage
=
=
frontVarying
.
stage
|
|
stage
=
=
backVarying
.
stage
)
;
const
VaryingInShaderRef
&
varying
=
stage
=
=
frontVarying
.
stage
?
frontVarying
:
backVarying
;
std
:
:
stringstream
fullNameStr
;
if
(
isStructField
(
)
)
{
fullNameStr
<
<
varying
.
parentStructName
<
<
"
.
"
;
}
fullNameStr
<
<
varying
.
varying
-
>
name
;
if
(
arrayIndex
!
=
GL_INVALID_INDEX
)
{
fullNameStr
<
<
"
[
"
<
<
arrayIndex
<
<
"
]
"
;
}
return
fullNameStr
.
str
(
)
;
}
bool
vertexOnly
(
)
const
{
return
frontVarying
.
stage
=
=
ShaderType
:
:
Vertex
&
&
backVarying
.
varying
=
=
nullptr
;
}
unsigned
int
getBasicTypeElementCount
(
)
const
;
VaryingInShaderRef
frontVarying
;
VaryingInShaderRef
backVarying
;
sh
:
:
InterpolationType
interpolation
;
GLuint
arrayIndex
;
bool
isTransformFeedback
;
GLuint
fieldIndex
;
GLuint
secondaryFieldIndex
;
}
;
struct
PackedVaryingRegister
final
{
PackedVaryingRegister
(
)
:
packedVarying
(
nullptr
)
varyingArrayIndex
(
0
)
varyingRowIndex
(
0
)
registerRow
(
0
)
registerColumn
(
0
)
{
}
PackedVaryingRegister
(
const
PackedVaryingRegister
&
)
=
default
;
PackedVaryingRegister
&
operator
=
(
const
PackedVaryingRegister
&
)
=
default
;
bool
operator
<
(
const
PackedVaryingRegister
&
other
)
const
{
return
sortOrder
(
)
<
other
.
sortOrder
(
)
;
}
unsigned
int
sortOrder
(
)
const
{
return
registerRow
*
4
+
registerColumn
;
}
std
:
:
string
tfVaryingName
(
)
const
{
return
packedVarying
-
>
fullName
(
packedVarying
-
>
frontVarying
.
stage
)
;
}
const
PackedVarying
*
packedVarying
;
unsigned
int
varyingArrayIndex
;
unsigned
int
varyingRowIndex
;
unsigned
int
registerRow
;
unsigned
int
registerColumn
;
}
;
enum
class
PackMode
{
WEBGL_STRICT
ANGLE_RELAXED
ANGLE_NON_CONFORMANT_D3D9
}
;
class
VaryingPacking
final
:
angle
:
:
NonCopyable
{
public
:
VaryingPacking
(
)
;
~
VaryingPacking
(
)
;
ANGLE_NO_DISCARD
bool
collectAndPackUserVaryings
(
InfoLog
&
infoLog
GLint
maxVaryingVectors
PackMode
packMode
ShaderType
frontShaderStage
ShaderType
backShaderStage
const
ProgramMergedVaryings
&
mergedVaryings
const
std
:
:
vector
<
std
:
:
string
>
&
tfVaryings
const
bool
isSeparableProgram
)
;
struct
Register
{
Register
(
)
{
data
[
0
]
=
data
[
1
]
=
data
[
2
]
=
data
[
3
]
=
false
;
}
bool
&
operator
[
]
(
unsigned
int
index
)
{
return
data
[
index
]
;
}
bool
operator
[
]
(
unsigned
int
index
)
const
{
return
data
[
index
]
;
}
bool
data
[
4
]
;
}
;
Register
&
operator
[
]
(
unsigned
int
index
)
{
return
mRegisterMap
[
index
]
;
}
const
Register
&
operator
[
]
(
unsigned
int
index
)
const
{
return
mRegisterMap
[
index
]
;
}
const
std
:
:
vector
<
PackedVaryingRegister
>
&
getRegisterList
(
)
const
{
return
mRegisterList
;
}
unsigned
int
getMaxSemanticIndex
(
)
const
{
return
static_cast
<
unsigned
int
>
(
mRegisterList
.
size
(
)
)
;
}
const
ShaderMap
<
std
:
:
vector
<
std
:
:
string
>
>
&
getInactiveVaryingMappedNames
(
)
const
{
return
mInactiveVaryingMappedNames
;
}
const
ShaderMap
<
std
:
:
vector
<
std
:
:
string
>
>
&
getActiveOutputBuiltInNames
(
)
const
{
return
mActiveOutputBuiltIns
;
}
void
reset
(
)
;
private
:
using
VaryingUniqueFullNames
=
ShaderMap
<
std
:
:
set
<
std
:
:
string
>
>
;
bool
packUserVaryings
(
InfoLog
&
infoLog
GLint
maxVaryingVectors
PackMode
packMode
const
std
:
:
vector
<
PackedVarying
>
&
packedVaryings
)
;
bool
packVaryingIntoRegisterMap
(
PackMode
packMode
const
PackedVarying
&
packedVarying
)
;
bool
isRegisterRangeFree
(
unsigned
int
registerRow
unsigned
int
registerColumn
unsigned
int
varyingRows
unsigned
int
varyingColumns
)
const
;
void
insertVaryingIntoRegisterMap
(
unsigned
int
registerRow
unsigned
int
registerColumn
unsigned
int
varyingColumns
const
PackedVarying
&
packedVarying
)
;
void
clearRegisterMap
(
)
;
void
collectUserVarying
(
const
ProgramVaryingRef
&
ref
VaryingUniqueFullNames
*
uniqueFullNames
)
;
void
collectUserVaryingField
(
const
ProgramVaryingRef
&
ref
GLuint
arrayIndex
GLuint
fieldIndex
GLuint
secondaryFieldIndex
VaryingUniqueFullNames
*
uniqueFullNames
)
;
void
collectUserVaryingTF
(
const
ProgramVaryingRef
&
ref
size_t
subscript
)
;
void
collectUserVaryingFieldTF
(
const
ProgramVaryingRef
&
ref
const
sh
:
:
ShaderVariable
&
field
GLuint
fieldIndex
GLuint
secondaryFieldIndex
)
;
void
collectVarying
(
const
sh
:
:
ShaderVariable
&
varying
const
ProgramVaryingRef
&
ref
PackMode
packMode
VaryingUniqueFullNames
*
uniqueFullNames
)
;
void
collectTFVarying
(
const
std
:
:
string
&
tfVarying
const
ProgramVaryingRef
&
ref
VaryingUniqueFullNames
*
uniqueFullNames
)
;
std
:
:
vector
<
Register
>
mRegisterMap
;
std
:
:
vector
<
PackedVaryingRegister
>
mRegisterList
;
std
:
:
vector
<
PackedVarying
>
mPackedVaryings
;
ShaderMap
<
std
:
:
vector
<
std
:
:
string
>
>
mInactiveVaryingMappedNames
;
ShaderMap
<
std
:
:
vector
<
std
:
:
string
>
>
mActiveOutputBuiltIns
;
}
;
class
ProgramVaryingPacking
final
:
angle
:
:
NonCopyable
{
public
:
ProgramVaryingPacking
(
)
;
~
ProgramVaryingPacking
(
)
;
const
VaryingPacking
&
getInputPacking
(
ShaderType
backShaderStage
)
const
;
const
VaryingPacking
&
getOutputPacking
(
ShaderType
frontShaderStage
)
const
;
ANGLE_NO_DISCARD
bool
collectAndPackUserVaryings
(
InfoLog
&
infoLog
const
Caps
&
caps
PackMode
packMode
const
ShaderBitSet
&
activeShadersMask
const
ProgramMergedVaryings
&
mergedVaryings
const
std
:
:
vector
<
std
:
:
string
>
&
tfVaryings
bool
isSeparableProgram
)
;
private
:
ShaderMap
<
VaryingPacking
>
mVaryingPackings
;
ShaderMap
<
ShaderType
>
mBackToFrontStageMap
;
}
;
ProgramMergedVaryings
GetMergedVaryingsFromShaders
(
const
HasAttachedShaders
&
programOrPipeline
const
ProgramExecutable
&
programExecutable
)
;
}
#
endif
