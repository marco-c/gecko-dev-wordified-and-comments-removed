#
ifndef
LIBANGLE_VARYINGPACKING_H_
#
define
LIBANGLE_VARYINGPACKING_H_
#
include
<
GLSLANG
/
ShaderVars
.
h
>
#
include
"
angle_gl
.
h
"
#
include
"
common
/
angleutils
.
h
"
#
include
<
map
>
namespace
gl
{
class
InfoLog
;
struct
ProgramVaryingRef
;
using
ProgramMergedVaryings
=
std
:
:
map
<
std
:
:
string
ProgramVaryingRef
>
;
struct
PackedVarying
{
PackedVarying
(
const
sh
:
:
ShaderVariable
&
varyingIn
sh
:
:
InterpolationType
interpolationIn
)
:
PackedVarying
(
varyingIn
interpolationIn
"
"
)
{
}
PackedVarying
(
const
sh
:
:
ShaderVariable
&
varyingIn
sh
:
:
InterpolationType
interpolationIn
const
std
:
:
string
&
parentStructNameIn
)
:
varying
(
&
varyingIn
)
vertexOnly
(
false
)
interpolation
(
interpolationIn
)
parentStructName
(
parentStructNameIn
)
arrayIndex
(
GL_INVALID_INDEX
)
{
}
bool
isStructField
(
)
const
{
return
!
parentStructName
.
empty
(
)
;
}
bool
isArrayElement
(
)
const
{
return
arrayIndex
!
=
GL_INVALID_INDEX
;
}
std
:
:
string
fullName
(
)
const
{
std
:
:
stringstream
fullNameStr
;
if
(
isStructField
(
)
)
{
fullNameStr
<
<
parentStructName
<
<
"
.
"
;
}
fullNameStr
<
<
varying
-
>
name
;
if
(
arrayIndex
!
=
GL_INVALID_INDEX
)
{
fullNameStr
<
<
"
[
"
<
<
arrayIndex
<
<
"
]
"
;
}
return
fullNameStr
.
str
(
)
;
}
const
sh
:
:
ShaderVariable
*
varying
;
bool
vertexOnly
;
sh
:
:
InterpolationType
interpolation
;
std
:
:
string
parentStructName
;
GLuint
arrayIndex
;
}
;
struct
PackedVaryingRegister
final
{
PackedVaryingRegister
(
)
:
packedVarying
(
nullptr
)
varyingArrayIndex
(
0
)
varyingRowIndex
(
0
)
registerRow
(
0
)
registerColumn
(
0
)
{
}
PackedVaryingRegister
(
const
PackedVaryingRegister
&
)
=
default
;
PackedVaryingRegister
&
operator
=
(
const
PackedVaryingRegister
&
)
=
default
;
bool
operator
<
(
const
PackedVaryingRegister
&
other
)
const
{
return
sortOrder
(
)
<
other
.
sortOrder
(
)
;
}
unsigned
int
sortOrder
(
)
const
{
return
registerRow
*
4
+
registerColumn
;
}
std
:
:
string
tfVaryingName
(
)
const
{
if
(
packedVarying
-
>
isArrayElement
(
)
|
|
packedVarying
-
>
isStructField
(
)
)
{
return
packedVarying
-
>
fullName
(
)
;
}
else
{
return
packedVarying
-
>
varying
-
>
name
;
}
}
const
PackedVarying
*
packedVarying
;
unsigned
int
varyingArrayIndex
;
unsigned
int
varyingRowIndex
;
unsigned
int
registerRow
;
unsigned
int
registerColumn
;
unsigned
int
semanticIndex
;
}
;
enum
class
PackMode
{
WEBGL_STRICT
ANGLE_RELAXED
ANGLE_NON_CONFORMANT_D3D9
}
;
class
VaryingPacking
final
:
angle
:
:
NonCopyable
{
public
:
VaryingPacking
(
GLuint
maxVaryingVectors
PackMode
packMode
)
;
~
VaryingPacking
(
)
;
bool
packUserVaryings
(
gl
:
:
InfoLog
&
infoLog
const
std
:
:
vector
<
PackedVarying
>
&
packedVaryings
const
std
:
:
vector
<
std
:
:
string
>
&
tfVaryings
)
;
bool
collectAndPackUserVaryings
(
gl
:
:
InfoLog
&
infoLog
const
ProgramMergedVaryings
&
mergedVaryings
const
std
:
:
vector
<
std
:
:
string
>
&
tfVaryings
)
;
struct
Register
{
Register
(
)
{
data
[
0
]
=
data
[
1
]
=
data
[
2
]
=
data
[
3
]
=
false
;
}
bool
&
operator
[
]
(
unsigned
int
index
)
{
return
data
[
index
]
;
}
bool
operator
[
]
(
unsigned
int
index
)
const
{
return
data
[
index
]
;
}
bool
data
[
4
]
;
}
;
Register
&
operator
[
]
(
unsigned
int
index
)
{
return
mRegisterMap
[
index
]
;
}
const
Register
&
operator
[
]
(
unsigned
int
index
)
const
{
return
mRegisterMap
[
index
]
;
}
const
std
:
:
vector
<
PackedVaryingRegister
>
&
getRegisterList
(
)
const
{
return
mRegisterList
;
}
unsigned
int
getMaxSemanticIndex
(
)
const
{
return
static_cast
<
unsigned
int
>
(
mRegisterList
.
size
(
)
)
;
}
private
:
bool
packVarying
(
const
PackedVarying
&
packedVarying
)
;
bool
isFree
(
unsigned
int
registerRow
unsigned
int
registerColumn
unsigned
int
varyingRows
unsigned
int
varyingColumns
)
const
;
void
insert
(
unsigned
int
registerRow
unsigned
int
registerColumn
const
PackedVarying
&
packedVarying
)
;
std
:
:
vector
<
Register
>
mRegisterMap
;
std
:
:
vector
<
PackedVaryingRegister
>
mRegisterList
;
std
:
:
vector
<
PackedVarying
>
mPackedVaryings
;
PackMode
mPackMode
;
}
;
}
#
endif
