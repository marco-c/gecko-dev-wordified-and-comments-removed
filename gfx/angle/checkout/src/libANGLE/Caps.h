#
ifndef
LIBANGLE_CAPS_H_
#
define
LIBANGLE_CAPS_H_
#
include
"
angle_gl
.
h
"
#
include
"
libANGLE
/
Version
.
h
"
#
include
"
libANGLE
/
angletypes
.
h
"
#
include
"
libANGLE
/
renderer
/
Format
.
h
"
#
include
<
array
>
#
include
<
map
>
#
include
<
set
>
#
include
<
string
>
#
include
<
vector
>
namespace
gl
{
struct
Extensions
;
struct
TextureCaps
{
TextureCaps
(
)
;
TextureCaps
(
const
TextureCaps
&
other
)
;
~
TextureCaps
(
)
;
bool
texturable
=
false
;
bool
filterable
=
false
;
bool
textureAttachment
=
false
;
bool
renderbuffer
=
false
;
SupportedSampleSet
sampleCounts
;
GLuint
getMaxSamples
(
)
const
;
GLuint
getNearestSamples
(
GLuint
requestedSamples
)
const
;
}
;
TextureCaps
GenerateMinimumTextureCaps
(
GLenum
internalFormat
const
Version
&
clientVersion
const
Extensions
&
extensions
)
;
class
TextureCapsMap
final
:
angle
:
:
NonCopyable
{
public
:
TextureCapsMap
(
)
;
~
TextureCapsMap
(
)
;
void
insert
(
GLenum
internalFormat
const
TextureCaps
&
caps
)
;
const
TextureCaps
&
get
(
GLenum
internalFormat
)
const
;
void
clear
(
)
;
const
TextureCaps
&
get
(
angle
:
:
FormatID
formatID
)
const
;
void
set
(
angle
:
:
FormatID
formatID
const
TextureCaps
&
caps
)
;
private
:
TextureCaps
&
get
(
angle
:
:
FormatID
formatID
)
;
std
:
:
array
<
TextureCaps
angle
:
:
kNumANGLEFormats
>
mFormatData
;
}
;
void
InitMinimumTextureCapsMap
(
const
Version
&
clientVersion
const
Extensions
&
extensions
TextureCapsMap
*
capsMap
)
;
bool
DetermineCompressedTextureETCSupport
(
const
TextureCapsMap
&
textureCaps
)
;
struct
Extensions
{
Extensions
(
)
;
Extensions
(
const
Extensions
&
other
)
;
std
:
:
vector
<
std
:
:
string
>
getStrings
(
)
const
;
void
setTextureExtensionSupport
(
const
TextureCapsMap
&
textureCaps
)
;
bool
depthTextureAny
(
)
const
{
return
(
depthTextureANGLE
|
|
depthTextureOES
)
;
}
bool
elementIndexUint
=
false
;
bool
packedDepthStencil
=
false
;
bool
getProgramBinary
=
false
;
bool
rgb8rgba8
=
false
;
bool
textureFormatBGRA8888
=
false
;
bool
readFormatBGRA
=
false
;
bool
pixelBufferObject
=
false
;
bool
mapBuffer
=
false
;
bool
mapBufferRange
=
false
;
bool
colorBufferHalfFloat
=
false
;
bool
textureHalfFloat
=
false
;
bool
textureHalfFloatLinear
=
false
;
bool
textureFloat
=
false
;
bool
textureFloatLinear
=
false
;
bool
textureRG
=
false
;
bool
textureCompressionDXT1
=
false
;
bool
textureCompressionDXT3
=
false
;
bool
textureCompressionDXT5
=
false
;
bool
textureCompressionS3TCsRGB
=
false
;
bool
textureCompressionASTCLDRKHR
=
false
;
bool
textureCompressionASTCHDRKHR
=
false
;
bool
textureCompressionASTCOES
=
false
;
bool
textureCompressionBPTC
=
false
;
bool
compressedETC1RGB8Texture
=
false
;
bool
compressedETC2RGB8Texture
=
false
;
bool
compressedETC2sRGB8Texture
=
false
;
bool
compressedETC2PunchthroughARGB8Texture
=
false
;
bool
compressedETC2PunchthroughAsRGB8AlphaTexture
=
false
;
bool
compressedETC2RGBA8Texture
=
false
;
bool
compressedETC2sRGB8Alpha8Texture
=
false
;
bool
compressedEACR11UnsignedTexture
=
false
;
bool
compressedEACR11SignedTexture
=
false
;
bool
compressedEACRG11UnsignedTexture
=
false
;
bool
compressedEACRG11SignedTexture
=
false
;
bool
compressedTextureETC
=
false
;
bool
sRGB
=
false
;
bool
depthTextureANGLE
=
false
;
bool
depthTextureOES
=
false
;
bool
depth24OES
=
false
;
bool
depth32
=
false
;
bool
texture3DOES
=
false
;
bool
textureStorage
=
false
;
bool
textureNPOT
=
false
;
bool
drawBuffers
=
false
;
bool
textureFilterAnisotropic
=
false
;
GLfloat
maxTextureAnisotropy
=
0
.
0f
;
bool
occlusionQueryBoolean
=
false
;
bool
fence
=
false
;
bool
disjointTimerQuery
=
false
;
GLuint
queryCounterBitsTimeElapsed
=
0
;
GLuint
queryCounterBitsTimestamp
=
0
;
bool
robustness
=
false
;
bool
robustBufferAccessBehavior
=
false
;
bool
blendMinMax
=
false
;
bool
framebufferBlit
=
false
;
bool
framebufferMultisample
=
false
;
bool
instancedArraysANGLE
=
false
;
bool
instancedArraysEXT
=
false
;
bool
instancedArraysAny
(
)
const
{
return
(
instancedArraysANGLE
|
|
instancedArraysEXT
)
;
}
bool
packReverseRowOrder
=
false
;
bool
standardDerivatives
=
false
;
bool
shaderTextureLOD
=
false
;
bool
fragDepth
=
false
;
bool
multiview
=
false
;
GLuint
maxViews
=
1
;
bool
multiview2
=
false
;
bool
textureUsage
=
false
;
bool
translatedShaderSource
=
false
;
bool
fboRenderMipmap
=
false
;
bool
discardFramebuffer
=
false
;
bool
debugMarker
=
false
;
bool
eglImage
=
false
;
bool
eglImageExternal
=
false
;
bool
eglImageExternalEssl3
=
false
;
bool
eglSync
=
false
;
bool
memoryObject
=
false
;
bool
memoryObjectFd
=
false
;
bool
semaphore
=
false
;
bool
semaphoreFd
=
false
;
bool
eglStreamConsumerExternal
=
false
;
bool
unpackSubimage
=
false
;
bool
packSubimage
=
false
;
bool
vertexArrayObject
=
false
;
bool
debug
=
false
;
GLuint
maxDebugMessageLength
=
0
;
GLuint
maxDebugLoggedMessages
=
0
;
GLuint
maxDebugGroupStackDepth
=
0
;
GLuint
maxLabelLength
=
0
;
bool
noError
=
false
;
bool
lossyETCDecode
=
false
;
bool
bindUniformLocation
=
false
;
bool
syncQuery
=
false
;
bool
copyTexture
=
false
;
bool
copyCompressedTexture
=
false
;
bool
copyTexture3d
=
false
;
bool
webglCompatibility
=
false
;
bool
requestExtension
=
false
;
bool
bindGeneratesResource
=
false
;
bool
robustClientMemory
=
false
;
bool
textureBorderClamp
=
false
;
bool
textureSRGBDecode
=
false
;
bool
sRGBWriteControl
=
false
;
bool
colorBufferFloatRGB
=
false
;
bool
colorBufferFloatRGBA
=
false
;
bool
colorBufferFloat
=
false
;
bool
multisampleCompatibility
=
false
;
bool
framebufferMixedSamples
=
false
;
bool
textureNorm16
=
false
;
bool
pathRendering
=
false
;
bool
surfacelessContext
=
false
;
bool
clientArrays
=
false
;
bool
robustResourceInitialization
=
false
;
bool
programCacheControl
=
false
;
bool
textureRectangle
=
false
;
bool
geometryShader
=
false
;
bool
pointSizeArray
=
false
;
bool
textureCubeMap
=
false
;
bool
pointSprite
=
false
;
bool
drawTexture
=
false
;
bool
explicitContextGles1
=
false
;
bool
explicitContext
=
false
;
bool
parallelShaderCompile
=
false
;
bool
textureStorageMultisample2DArray
=
false
;
bool
multiviewMultisample
=
false
;
bool
blendFuncExtended
=
false
;
GLuint
maxDualSourceDrawBuffers
=
0
;
bool
floatBlend
=
false
;
bool
memorySize
=
false
;
bool
textureMultisample
=
false
;
bool
multiDraw
=
false
;
bool
provokingVertex
=
false
;
bool
loseContextCHROMIUM
=
false
;
bool
textureExternalUpdateANGLE
=
false
;
bool
baseVertexBaseInstance
=
false
;
}
;
struct
ExtensionInfo
{
bool
Requestable
=
false
;
typedef
bool
(
Extensions
:
:
*
ExtensionBool
)
;
ExtensionBool
ExtensionsMember
=
nullptr
;
}
;
using
ExtensionInfoMap
=
std
:
:
map
<
std
:
:
string
ExtensionInfo
>
;
const
ExtensionInfoMap
&
GetExtensionInfoMap
(
)
;
struct
Limitations
{
Limitations
(
)
;
bool
noFrontFacingSupport
=
false
;
bool
noSampleAlphaToCoverageSupport
=
false
;
bool
attributeZeroRequiresZeroDivisorInEXT
=
false
;
bool
noSeparateStencilRefsAndMasks
=
false
;
bool
shadersRequireIndexedLoopValidation
=
false
;
bool
noSimultaneousConstantColorAndAlphaBlendFunc
=
false
;
bool
noFlexibleVaryingPacking
=
false
;
bool
noDoubleBoundTransformFeedbackBuffers
=
false
;
bool
noVertexAttributeAliasing
=
false
;
}
;
struct
TypePrecision
{
TypePrecision
(
)
;
TypePrecision
(
const
TypePrecision
&
other
)
;
void
setIEEEFloat
(
)
;
void
setTwosComplementInt
(
unsigned
int
bits
)
;
void
setSimulatedFloat
(
unsigned
int
range
unsigned
int
precision
)
;
void
setSimulatedInt
(
unsigned
int
range
)
;
void
get
(
GLint
*
returnRange
GLint
*
returnPrecision
)
const
;
std
:
:
array
<
GLint
2
>
range
=
{
0
0
}
;
GLint
precision
=
0
;
}
;
struct
Caps
{
Caps
(
)
;
Caps
(
const
Caps
&
other
)
;
~
Caps
(
)
;
GLuint64
maxElementIndex
=
0
;
GLuint
max3DTextureSize
=
0
;
GLuint
max2DTextureSize
=
0
;
GLuint
maxRectangleTextureSize
=
0
;
GLuint
maxArrayTextureLayers
=
0
;
GLfloat
maxLODBias
=
0
.
0f
;
GLuint
maxCubeMapTextureSize
=
0
;
GLuint
maxRenderbufferSize
=
0
;
GLfloat
minAliasedPointSize
=
1
.
0f
;
GLfloat
maxAliasedPointSize
=
1
.
0f
;
GLfloat
minAliasedLineWidth
=
0
.
0f
;
GLfloat
maxAliasedLineWidth
=
0
.
0f
;
GLuint
maxDrawBuffers
=
0
;
GLuint
maxFramebufferWidth
=
0
;
GLuint
maxFramebufferHeight
=
0
;
GLuint
maxFramebufferSamples
=
0
;
GLuint
maxColorAttachments
=
0
;
GLuint
maxViewportWidth
=
0
;
GLuint
maxViewportHeight
=
0
;
GLuint
maxSampleMaskWords
=
0
;
GLuint
maxColorTextureSamples
=
0
;
GLuint
maxDepthTextureSamples
=
0
;
GLuint
maxIntegerSamples
=
0
;
GLuint64
maxServerWaitTimeout
=
0
;
GLint
maxVertexAttribRelativeOffset
=
0
;
GLuint
maxVertexAttribBindings
=
0
;
GLint
maxVertexAttribStride
=
0
;
GLuint
maxElementsIndices
=
0
;
GLuint
maxElementsVertices
=
0
;
std
:
:
vector
<
GLenum
>
compressedTextureFormats
;
std
:
:
vector
<
GLenum
>
programBinaryFormats
;
std
:
:
vector
<
GLenum
>
shaderBinaryFormats
;
TypePrecision
vertexHighpFloat
;
TypePrecision
vertexMediumpFloat
;
TypePrecision
vertexLowpFloat
;
TypePrecision
vertexHighpInt
;
TypePrecision
vertexMediumpInt
;
TypePrecision
vertexLowpInt
;
TypePrecision
fragmentHighpFloat
;
TypePrecision
fragmentMediumpFloat
;
TypePrecision
fragmentLowpFloat
;
TypePrecision
fragmentHighpInt
;
TypePrecision
fragmentMediumpInt
;
TypePrecision
fragmentLowpInt
;
ShaderMap
<
GLuint
>
maxShaderUniformBlocks
=
{
}
;
ShaderMap
<
GLuint
>
maxShaderTextureImageUnits
=
{
}
;
ShaderMap
<
GLuint
>
maxShaderStorageBlocks
=
{
}
;
ShaderMap
<
GLuint
>
maxShaderUniformComponents
=
{
}
;
ShaderMap
<
GLuint
>
maxShaderAtomicCounterBuffers
=
{
}
;
ShaderMap
<
GLuint
>
maxShaderAtomicCounters
=
{
}
;
ShaderMap
<
GLuint
>
maxShaderImageUniforms
=
{
}
;
ShaderMap
<
GLuint64
>
maxCombinedShaderUniformComponents
=
{
}
;
GLuint
maxVertexAttributes
=
0
;
GLuint
maxVertexUniformVectors
=
0
;
GLuint
maxVertexOutputComponents
=
0
;
GLuint
maxFragmentUniformVectors
=
0
;
GLuint
maxFragmentInputComponents
=
0
;
GLint
minProgramTextureGatherOffset
=
0
;
GLuint
maxProgramTextureGatherOffset
=
0
;
GLint
minProgramTexelOffset
=
0
;
GLint
maxProgramTexelOffset
=
0
;
std
:
:
array
<
GLuint
3
>
maxComputeWorkGroupCount
=
{
0
0
0
}
;
std
:
:
array
<
GLuint
3
>
maxComputeWorkGroupSize
=
{
0
0
0
}
;
GLuint
maxComputeWorkGroupInvocations
=
0
;
GLuint
maxComputeSharedMemorySize
=
0
;
GLuint
maxUniformBufferBindings
=
0
;
GLuint64
maxUniformBlockSize
=
0
;
GLuint
uniformBufferOffsetAlignment
=
0
;
GLuint
maxCombinedUniformBlocks
=
0
;
GLuint
maxVaryingComponents
=
0
;
GLuint
maxVaryingVectors
=
0
;
GLuint
maxCombinedTextureImageUnits
=
0
;
GLuint
maxCombinedShaderOutputResources
=
0
;
GLuint
maxUniformLocations
=
0
;
GLuint
maxAtomicCounterBufferBindings
=
0
;
GLuint
maxAtomicCounterBufferSize
=
0
;
GLuint
maxCombinedAtomicCounterBuffers
=
0
;
GLuint
maxCombinedAtomicCounters
=
0
;
GLuint
maxImageUnits
=
0
;
GLuint
maxCombinedImageUniforms
=
0
;
GLuint
maxShaderStorageBufferBindings
=
0
;
GLuint64
maxShaderStorageBlockSize
=
0
;
GLuint
maxCombinedShaderStorageBlocks
=
0
;
GLuint
shaderStorageBufferOffsetAlignment
=
0
;
GLuint
maxTransformFeedbackInterleavedComponents
=
0
;
GLuint
maxTransformFeedbackSeparateAttributes
=
0
;
GLuint
maxTransformFeedbackSeparateComponents
=
0
;
GLuint
maxSamples
=
0
;
GLuint
maxFramebufferLayers
=
0
;
GLuint
layerProvokingVertex
=
0
;
GLuint
maxGeometryInputComponents
=
0
;
GLuint
maxGeometryOutputComponents
=
0
;
GLuint
maxGeometryOutputVertices
=
0
;
GLuint
maxGeometryTotalOutputComponents
=
0
;
GLuint
maxGeometryShaderInvocations
=
0
;
GLuint
subPixelBits
=
4
;
GLuint
maxMultitextureUnits
=
0
;
GLuint
maxClipPlanes
=
0
;
GLuint
maxLights
=
0
;
static
constexpr
int
GlobalMatrixStackDepth
=
16
;
GLuint
maxModelviewMatrixStackDepth
=
0
;
GLuint
maxProjectionMatrixStackDepth
=
0
;
GLuint
maxTextureMatrixStackDepth
=
0
;
GLfloat
minSmoothPointSize
=
0
.
0f
;
GLfloat
maxSmoothPointSize
=
0
.
0f
;
GLfloat
minSmoothLineWidth
=
0
.
0f
;
GLfloat
maxSmoothLineWidth
=
0
.
0f
;
}
;
Caps
GenerateMinimumCaps
(
const
Version
&
clientVersion
const
Extensions
&
extensions
)
;
}
namespace
egl
{
struct
Caps
{
Caps
(
)
;
bool
textureNPOT
;
}
;
struct
DisplayExtensions
{
DisplayExtensions
(
)
;
std
:
:
vector
<
std
:
:
string
>
getStrings
(
)
const
;
bool
createContextRobustness
=
false
;
bool
d3dShareHandleClientBuffer
=
false
;
bool
d3dTextureClientBuffer
=
false
;
bool
surfaceD3DTexture2DShareHandle
=
false
;
bool
querySurfacePointer
=
false
;
bool
windowFixedSize
=
false
;
bool
keyedMutex
=
false
;
bool
surfaceOrientation
=
false
;
bool
postSubBuffer
=
false
;
bool
createContext
=
false
;
bool
deviceQuery
=
false
;
bool
image
=
false
;
bool
imageBase
=
false
;
bool
imagePixmap
=
false
;
bool
glTexture2DImage
=
false
;
bool
glTextureCubemapImage
=
false
;
bool
glTexture3DImage
=
false
;
bool
glRenderbufferImage
=
false
;
bool
getAllProcAddresses
=
false
;
bool
flexibleSurfaceCompatibility
=
false
;
bool
directComposition
=
false
;
bool
windowsUIComposition
=
false
;
bool
createContextNoError
=
false
;
bool
stream
=
false
;
bool
streamConsumerGLTexture
=
false
;
bool
streamConsumerGLTextureYUV
=
false
;
bool
streamProducerD3DTexture
=
false
;
bool
fenceSync
=
false
;
bool
waitSync
=
false
;
bool
createContextWebGLCompatibility
=
false
;
bool
createContextBindGeneratesResource
=
false
;
bool
getSyncValues
=
false
;
bool
swapBuffersWithDamage
=
false
;
bool
pixelFormatFloat
=
false
;
bool
surfacelessContext
=
false
;
bool
displayTextureShareGroup
=
false
;
bool
createContextClientArrays
=
false
;
bool
programCacheControl
=
false
;
bool
robustResourceInitialization
=
false
;
bool
iosurfaceClientBuffer
=
false
;
bool
createContextExtensionsEnabled
=
false
;
bool
presentationTime
=
false
;
bool
blobCache
=
false
;
bool
imageNativeBuffer
=
false
;
bool
getFrameTimestamps
=
false
;
bool
recordable
=
false
;
bool
powerPreference
=
false
;
bool
imageD3D11Texture
=
false
;
bool
getNativeClientBufferANDROID
=
false
;
bool
nativeFenceSyncANDROID
=
false
;
bool
createContextBackwardsCompatible
=
false
;
}
;
struct
DeviceExtensions
{
DeviceExtensions
(
)
;
std
:
:
vector
<
std
:
:
string
>
getStrings
(
)
const
;
bool
deviceD3D
=
false
;
}
;
struct
ClientExtensions
{
ClientExtensions
(
)
;
ClientExtensions
(
const
ClientExtensions
&
other
)
;
std
:
:
vector
<
std
:
:
string
>
getStrings
(
)
const
;
bool
clientExtensions
=
false
;
bool
platformBase
=
false
;
bool
platformDevice
=
false
;
bool
platformANGLE
=
false
;
bool
platformANGLED3D
=
false
;
bool
platformANGLEOpenGL
=
false
;
bool
platformANGLENULL
=
false
;
bool
platformANGLEVulkan
=
false
;
bool
platformANGLEContextVirtualization
=
false
;
bool
deviceCreation
=
false
;
bool
deviceCreationD3D11
=
false
;
bool
x11Visual
=
false
;
bool
experimentalPresentPath
=
false
;
bool
clientGetAllProcAddresses
=
false
;
bool
debug
=
false
;
bool
explicitContext
=
false
;
bool
featureControlANGLE
=
false
;
}
;
}
#
endif
