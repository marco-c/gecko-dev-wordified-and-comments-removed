#
ifndef
LIBANGLE_CAPS_H_
#
define
LIBANGLE_CAPS_H_
#
include
"
angle_gl
.
h
"
#
include
"
libANGLE
/
Version
.
h
"
#
include
"
libANGLE
/
angletypes
.
h
"
#
include
"
libANGLE
/
renderer
/
Format
.
h
"
#
include
<
array
>
#
include
<
map
>
#
include
<
set
>
#
include
<
string
>
#
include
<
vector
>
namespace
gl
{
struct
Extensions
;
struct
TextureCaps
{
TextureCaps
(
)
;
TextureCaps
(
const
TextureCaps
&
other
)
;
~
TextureCaps
(
)
;
bool
texturable
=
false
;
bool
filterable
=
false
;
bool
textureAttachment
=
false
;
bool
renderbuffer
=
false
;
bool
blendable
=
false
;
SupportedSampleSet
sampleCounts
;
GLuint
getMaxSamples
(
)
const
;
GLuint
getNearestSamples
(
GLuint
requestedSamples
)
const
;
}
;
TextureCaps
GenerateMinimumTextureCaps
(
GLenum
internalFormat
const
Version
&
clientVersion
const
Extensions
&
extensions
)
;
class
TextureCapsMap
final
:
angle
:
:
NonCopyable
{
public
:
TextureCapsMap
(
)
;
~
TextureCapsMap
(
)
;
void
insert
(
GLenum
internalFormat
const
TextureCaps
&
caps
)
;
const
TextureCaps
&
get
(
GLenum
internalFormat
)
const
;
void
clear
(
)
;
const
TextureCaps
&
get
(
angle
:
:
FormatID
formatID
)
const
;
void
set
(
angle
:
:
FormatID
formatID
const
TextureCaps
&
caps
)
;
private
:
TextureCaps
&
get
(
angle
:
:
FormatID
formatID
)
;
std
:
:
array
<
TextureCaps
angle
:
:
kNumANGLEFormats
>
mFormatData
;
}
;
void
InitMinimumTextureCapsMap
(
const
Version
&
clientVersion
const
Extensions
&
extensions
TextureCapsMap
*
capsMap
)
;
bool
DetermineCompressedTextureETCSupport
(
const
TextureCapsMap
&
textureCaps
)
;
struct
Extensions
{
Extensions
(
)
;
Extensions
(
const
Extensions
&
other
)
;
Extensions
&
operator
=
(
const
Extensions
&
other
)
;
std
:
:
vector
<
std
:
:
string
>
getStrings
(
)
const
;
void
setTextureExtensionSupport
(
const
TextureCapsMap
&
textureCaps
)
;
bool
depthTextureAny
(
)
const
{
return
(
depthTextureANGLE
|
|
depthTextureOES
)
;
}
bool
elementIndexUintOES
=
false
;
bool
packedDepthStencilOES
=
false
;
bool
readDepthNV
=
false
;
bool
readStencilNV
=
false
;
bool
depthBufferFloat2NV
=
false
;
bool
getProgramBinaryOES
=
false
;
bool
rgb8rgba8OES
=
false
;
bool
textureFormatBGRA8888
=
false
;
bool
readFormatBGRA
=
false
;
bool
pixelBufferObjectNV
=
false
;
bool
glSyncARB
=
false
;
bool
mapBufferOES
=
false
;
bool
mapBufferRange
=
false
;
bool
colorBufferHalfFloat
=
false
;
bool
textureHalfFloat
=
false
;
bool
textureHalfFloatLinear
=
false
;
bool
textureFormat2101010REV
=
false
;
bool
textureFloatOES
=
false
;
bool
textureFloatLinearOES
=
false
;
bool
textureRG
=
false
;
bool
textureCompressionDXT1
=
false
;
bool
textureCompressionDXT3
=
false
;
bool
textureCompressionDXT5
=
false
;
bool
textureCompressionS3TCsRGB
=
false
;
bool
textureCompressionASTCLDRKHR
=
false
;
bool
textureCompressionASTCHDRKHR
=
false
;
bool
textureCompressionASTCOES
=
false
;
bool
textureCompressionSliced3dASTCKHR
=
false
;
bool
textureCompressionBPTC
=
false
;
bool
textureCompressionRGTC
=
false
;
bool
compressedETC1RGB8TextureOES
=
false
;
bool
compressedETC1RGB8SubTexture
=
false
;
bool
compressedETC2RGB8TextureOES
=
false
;
bool
compressedETC2sRGB8TextureOES
=
false
;
bool
compressedETC2PunchthroughARGB8TextureOES
=
false
;
bool
compressedETC2PunchthroughAsRGB8AlphaTextureOES
=
false
;
bool
compressedETC2RGBA8TextureOES
=
false
;
bool
compressedETC2sRGB8Alpha8TextureOES
=
false
;
bool
compressedEACR11UnsignedTextureOES
=
false
;
bool
compressedEACR11SignedTextureOES
=
false
;
bool
compressedEACRG11UnsignedTextureOES
=
false
;
bool
compressedEACRG11SignedTextureOES
=
false
;
bool
compressedTextureETC
=
false
;
bool
compressedTexturePVRTC
=
false
;
bool
compressedTexturePVRTCsRGB
=
false
;
bool
sRGB
=
false
;
bool
sRGBR8EXT
=
false
;
bool
depthTextureANGLE
=
false
;
bool
depthTextureOES
=
false
;
bool
depthTextureCubeMapOES
=
false
;
bool
depth24OES
=
false
;
bool
depth32OES
=
false
;
bool
texture3DOES
=
false
;
bool
textureStorage
=
false
;
bool
textureNPOTOES
=
false
;
bool
drawBuffers
=
false
;
bool
drawBuffersIndexedEXT
=
false
;
bool
drawBuffersIndexedOES
=
false
;
bool
drawBuffersIndexedAny
(
)
const
{
return
(
drawBuffersIndexedEXT
|
|
drawBuffersIndexedOES
)
;
}
bool
textureFilterAnisotropic
=
false
;
GLfloat
maxTextureAnisotropy
=
0
.
0f
;
bool
occlusionQueryBoolean
=
false
;
bool
fenceNV
=
false
;
bool
disjointTimerQuery
=
false
;
GLuint
queryCounterBitsTimeElapsed
=
0
;
GLuint
queryCounterBitsTimestamp
=
0
;
bool
robustness
=
false
;
bool
robustBufferAccessBehavior
=
false
;
bool
blendMinMax
=
false
;
bool
framebufferBlit
=
false
;
bool
framebufferMultisample
=
false
;
bool
multisampledRenderToTexture
=
false
;
bool
multisampledRenderToTexture2
=
false
;
bool
instancedArraysANGLE
=
false
;
bool
instancedArraysEXT
=
false
;
bool
instancedArraysAny
(
)
const
{
return
(
instancedArraysANGLE
|
|
instancedArraysEXT
)
;
}
bool
packReverseRowOrder
=
false
;
bool
standardDerivativesOES
=
false
;
bool
shaderTextureLOD
=
false
;
bool
fragDepth
=
false
;
bool
multiview
=
false
;
GLuint
maxViews
=
1
;
bool
multiview2
=
false
;
bool
textureUsage
=
false
;
bool
translatedShaderSource
=
false
;
bool
fboRenderMipmapOES
=
false
;
bool
discardFramebuffer
=
false
;
bool
debugMarker
=
false
;
bool
eglImageOES
=
false
;
bool
eglImageExternalOES
=
false
;
bool
eglImageExternalEssl3OES
=
false
;
bool
eglImageExternalWrapModesEXT
=
false
;
bool
eglSyncOES
=
false
;
bool
memoryObject
=
false
;
bool
memoryObjectFd
=
false
;
bool
memoryObjectFlagsANGLE
=
false
;
bool
memoryObjectFuchsiaANGLE
=
false
;
bool
semaphore
=
false
;
bool
semaphoreFd
=
false
;
bool
semaphoreFuchsiaANGLE
=
false
;
bool
eglStreamConsumerExternalNV
=
false
;
bool
unpackSubimage
=
false
;
bool
packSubimage
=
false
;
bool
noperspectiveInterpolationNV
=
false
;
bool
vertexHalfFloatOES
=
false
;
bool
vertexArrayObjectOES
=
false
;
bool
vertexAttribType1010102OES
=
false
;
bool
debug
=
false
;
GLuint
maxDebugMessageLength
=
0
;
GLuint
maxDebugLoggedMessages
=
0
;
GLuint
maxDebugGroupStackDepth
=
0
;
GLuint
maxLabelLength
=
0
;
bool
noError
=
false
;
bool
lossyETCDecode
=
false
;
bool
bindUniformLocation
=
false
;
bool
syncQuery
=
false
;
bool
copyTexture
=
false
;
bool
copyCompressedTexture
=
false
;
bool
copyTexture3d
=
false
;
bool
webglCompatibility
=
false
;
bool
requestExtension
=
false
;
bool
bindGeneratesResource
=
false
;
bool
robustClientMemory
=
false
;
bool
textureBorderClampOES
=
false
;
bool
textureSRGBDecode
=
false
;
bool
textureSRGBOverride
=
false
;
bool
sRGBWriteControl
=
false
;
bool
colorBufferFloatRGB
=
false
;
bool
colorBufferFloatRGBA
=
false
;
bool
eglImageArray
=
false
;
bool
colorBufferFloat
=
false
;
bool
multisampleCompatibility
=
false
;
bool
framebufferMixedSamples
=
false
;
bool
textureNorm16
=
false
;
bool
surfacelessContextOES
=
false
;
bool
clientArrays
=
false
;
bool
robustResourceInitialization
=
false
;
bool
programCacheControl
=
false
;
bool
textureRectangle
=
false
;
bool
geometryShader
=
false
;
bool
pointSizeArrayOES
=
false
;
bool
textureCubeMapOES
=
false
;
bool
pointSpriteOES
=
false
;
bool
drawTextureOES
=
false
;
bool
explicitContextGles1
=
false
;
bool
explicitContext
=
false
;
bool
parallelShaderCompile
=
false
;
bool
textureStorageMultisample2DArrayOES
=
false
;
bool
multiviewMultisample
=
false
;
bool
blendFuncExtended
=
false
;
GLuint
maxDualSourceDrawBuffers
=
0
;
bool
floatBlend
=
false
;
bool
memorySize
=
false
;
bool
textureMultisample
=
false
;
bool
multiDraw
=
false
;
bool
provokingVertex
=
false
;
bool
textureFilteringCHROMIUM
=
false
;
bool
loseContextCHROMIUM
=
false
;
bool
textureExternalUpdateANGLE
=
false
;
bool
baseVertexBaseInstance
=
false
;
bool
getImageANGLE
=
false
;
bool
drawElementsBaseVertexOES
=
false
;
bool
drawElementsBaseVertexEXT
=
false
;
bool
drawElementsBaseVertexAny
(
)
const
{
return
(
drawElementsBaseVertexOES
|
|
drawElementsBaseVertexEXT
)
;
}
bool
shaderNonConstGlobalInitializersEXT
=
false
;
bool
gpuShader5EXT
=
false
;
bool
webglVideoTexture
=
false
;
bool
clipDistanceAPPLE
=
false
;
bool
textureCubeMapArrayOES
=
false
;
bool
textureCubeMapArrayEXT
=
false
;
bool
textureCubeMapArrayAny
(
)
const
{
return
(
textureCubeMapArrayOES
|
|
textureCubeMapArrayEXT
)
;
}
bool
shadowSamplersEXT
=
false
;
bool
bufferStorageEXT
=
false
;
bool
externalBufferEXT
=
false
;
bool
stencilIndex8
=
false
;
bool
sampleShadingOES
=
false
;
bool
multisampleInterpolationOES
=
false
;
bool
shaderImageAtomicOES
=
false
;
bool
robustnessVideoMemoryPurgeNV
=
false
;
bool
getTexLevelParameterANGLE
=
false
;
bool
copyImageEXT
=
false
;
bool
textureBufferOES
=
false
;
bool
textureBufferEXT
=
false
;
bool
textureBufferAny
(
)
const
{
return
(
textureBufferOES
|
|
textureBufferEXT
)
;
}
}
;
using
ExtensionBool
=
bool
Extensions
:
:
*
;
struct
ExtensionInfo
{
bool
Requestable
=
false
;
bool
Disablable
=
false
;
ExtensionBool
ExtensionsMember
=
nullptr
;
}
;
using
ExtensionInfoMap
=
std
:
:
map
<
std
:
:
string
ExtensionInfo
>
;
const
ExtensionInfoMap
&
GetExtensionInfoMap
(
)
;
struct
Limitations
{
Limitations
(
)
;
Limitations
(
const
Limitations
&
other
)
;
Limitations
&
operator
=
(
const
Limitations
&
other
)
;
bool
noFrontFacingSupport
=
false
;
bool
noSampleAlphaToCoverageSupport
=
false
;
bool
attributeZeroRequiresZeroDivisorInEXT
=
false
;
bool
noSeparateStencilRefsAndMasks
=
false
;
bool
shadersRequireIndexedLoopValidation
=
false
;
bool
noSimultaneousConstantColorAndAlphaBlendFunc
=
false
;
bool
noFlexibleVaryingPacking
=
false
;
bool
noDoubleBoundTransformFeedbackBuffers
=
false
;
bool
noVertexAttributeAliasing
=
false
;
bool
noShadowSamplerCompareModeNone
=
false
;
}
;
struct
TypePrecision
{
TypePrecision
(
)
;
TypePrecision
(
const
TypePrecision
&
other
)
;
TypePrecision
&
operator
=
(
const
TypePrecision
&
other
)
;
void
setIEEEFloat
(
)
;
void
setTwosComplementInt
(
unsigned
int
bits
)
;
void
setSimulatedFloat
(
unsigned
int
range
unsigned
int
precision
)
;
void
setSimulatedInt
(
unsigned
int
range
)
;
void
get
(
GLint
*
returnRange
GLint
*
returnPrecision
)
const
;
std
:
:
array
<
GLint
2
>
range
=
{
0
0
}
;
GLint
precision
=
0
;
}
;
struct
Caps
{
Caps
(
)
;
Caps
(
const
Caps
&
other
)
;
~
Caps
(
)
;
GLfloat
minInterpolationOffset
=
0
;
GLfloat
maxInterpolationOffset
=
0
;
GLint
subPixelInterpolationOffsetBits
=
0
;
GLint64
maxElementIndex
=
0
;
GLint
max3DTextureSize
=
0
;
GLint
max2DTextureSize
=
0
;
GLint
maxRectangleTextureSize
=
0
;
GLint
maxArrayTextureLayers
=
0
;
GLfloat
maxLODBias
=
0
.
0f
;
GLint
maxCubeMapTextureSize
=
0
;
GLint
maxRenderbufferSize
=
0
;
GLfloat
minAliasedPointSize
=
1
.
0f
;
GLfloat
maxAliasedPointSize
=
1
.
0f
;
GLfloat
minAliasedLineWidth
=
0
.
0f
;
GLfloat
maxAliasedLineWidth
=
0
.
0f
;
GLint
maxDrawBuffers
=
0
;
GLint
maxFramebufferWidth
=
0
;
GLint
maxFramebufferHeight
=
0
;
GLint
maxFramebufferSamples
=
0
;
GLint
maxColorAttachments
=
0
;
GLint
maxViewportWidth
=
0
;
GLint
maxViewportHeight
=
0
;
GLint
maxSampleMaskWords
=
0
;
GLint
maxColorTextureSamples
=
0
;
GLint
maxDepthTextureSamples
=
0
;
GLint
maxIntegerSamples
=
0
;
GLint64
maxServerWaitTimeout
=
0
;
GLint
maxVertexAttribRelativeOffset
=
0
;
GLint
maxVertexAttribBindings
=
0
;
GLint
maxVertexAttribStride
=
0
;
GLint
maxElementsIndices
=
0
;
GLint
maxElementsVertices
=
0
;
std
:
:
vector
<
GLenum
>
compressedTextureFormats
;
std
:
:
vector
<
GLenum
>
programBinaryFormats
;
std
:
:
vector
<
GLenum
>
shaderBinaryFormats
;
TypePrecision
vertexHighpFloat
;
TypePrecision
vertexMediumpFloat
;
TypePrecision
vertexLowpFloat
;
TypePrecision
vertexHighpInt
;
TypePrecision
vertexMediumpInt
;
TypePrecision
vertexLowpInt
;
TypePrecision
fragmentHighpFloat
;
TypePrecision
fragmentMediumpFloat
;
TypePrecision
fragmentLowpFloat
;
TypePrecision
fragmentHighpInt
;
TypePrecision
fragmentMediumpInt
;
TypePrecision
fragmentLowpInt
;
ShaderMap
<
GLint
>
maxShaderUniformBlocks
=
{
}
;
ShaderMap
<
GLint
>
maxShaderTextureImageUnits
=
{
}
;
ShaderMap
<
GLint
>
maxShaderStorageBlocks
=
{
}
;
ShaderMap
<
GLint
>
maxShaderUniformComponents
=
{
}
;
ShaderMap
<
GLint
>
maxShaderAtomicCounterBuffers
=
{
}
;
ShaderMap
<
GLint
>
maxShaderAtomicCounters
=
{
}
;
ShaderMap
<
GLint
>
maxShaderImageUniforms
=
{
}
;
ShaderMap
<
GLint64
>
maxCombinedShaderUniformComponents
=
{
}
;
GLint
maxVertexAttributes
=
0
;
GLint
maxVertexUniformVectors
=
0
;
GLint
maxVertexOutputComponents
=
0
;
GLint
maxFragmentUniformVectors
=
0
;
GLint
maxFragmentInputComponents
=
0
;
GLint
minProgramTextureGatherOffset
=
0
;
GLint
maxProgramTextureGatherOffset
=
0
;
GLint
minProgramTexelOffset
=
0
;
GLint
maxProgramTexelOffset
=
0
;
std
:
:
array
<
GLint
3
>
maxComputeWorkGroupCount
=
{
0
0
0
}
;
std
:
:
array
<
GLint
3
>
maxComputeWorkGroupSize
=
{
0
0
0
}
;
GLint
maxComputeWorkGroupInvocations
=
0
;
GLint
maxComputeSharedMemorySize
=
0
;
GLint
maxUniformBufferBindings
=
0
;
GLint64
maxUniformBlockSize
=
0
;
GLint
uniformBufferOffsetAlignment
=
0
;
GLint
maxCombinedUniformBlocks
=
0
;
GLint
maxVaryingComponents
=
0
;
GLint
maxVaryingVectors
=
0
;
GLint
maxCombinedTextureImageUnits
=
0
;
GLint
maxCombinedShaderOutputResources
=
0
;
GLint
maxUniformLocations
=
0
;
GLint
maxAtomicCounterBufferBindings
=
0
;
GLint
maxAtomicCounterBufferSize
=
0
;
GLint
maxCombinedAtomicCounterBuffers
=
0
;
GLint
maxCombinedAtomicCounters
=
0
;
GLint
maxImageUnits
=
0
;
GLint
maxCombinedImageUniforms
=
0
;
GLint
maxShaderStorageBufferBindings
=
0
;
GLint64
maxShaderStorageBlockSize
=
0
;
GLint
maxCombinedShaderStorageBlocks
=
0
;
GLint
shaderStorageBufferOffsetAlignment
=
0
;
GLint
maxTransformFeedbackInterleavedComponents
=
0
;
GLint
maxTransformFeedbackSeparateAttributes
=
0
;
GLint
maxTransformFeedbackSeparateComponents
=
0
;
GLint
maxSamples
=
0
;
GLint
maxFramebufferLayers
=
0
;
GLint
layerProvokingVertex
=
0
;
GLint
maxGeometryInputComponents
=
0
;
GLint
maxGeometryOutputComponents
=
0
;
GLint
maxGeometryOutputVertices
=
0
;
GLint
maxGeometryTotalOutputComponents
=
0
;
GLint
maxGeometryShaderInvocations
=
0
;
GLuint
subPixelBits
=
4
;
GLuint
maxClipDistances
=
0
;
GLuint
maxMultitextureUnits
=
0
;
GLuint
maxClipPlanes
=
0
;
GLuint
maxLights
=
0
;
static
constexpr
int
GlobalMatrixStackDepth
=
16
;
GLuint
maxModelviewMatrixStackDepth
=
0
;
GLuint
maxProjectionMatrixStackDepth
=
0
;
GLuint
maxTextureMatrixStackDepth
=
0
;
GLfloat
minSmoothPointSize
=
0
.
0f
;
GLfloat
maxSmoothPointSize
=
0
.
0f
;
GLfloat
minSmoothLineWidth
=
0
.
0f
;
GLfloat
maxSmoothLineWidth
=
0
.
0f
;
GLint
maxTextureBufferSize
=
0
;
GLint
textureBufferOffsetAlignment
=
0
;
}
;
Caps
GenerateMinimumCaps
(
const
Version
&
clientVersion
const
Extensions
&
extensions
)
;
}
namespace
egl
{
struct
Caps
{
Caps
(
)
;
bool
textureNPOT
;
bool
stencil8
;
}
;
struct
DisplayExtensions
{
DisplayExtensions
(
)
;
std
:
:
vector
<
std
:
:
string
>
getStrings
(
)
const
;
bool
createContextRobustness
=
false
;
bool
d3dShareHandleClientBuffer
=
false
;
bool
d3dTextureClientBuffer
=
false
;
bool
surfaceD3DTexture2DShareHandle
=
false
;
bool
querySurfacePointer
=
false
;
bool
windowFixedSize
=
false
;
bool
keyedMutex
=
false
;
bool
surfaceOrientation
=
false
;
bool
postSubBuffer
=
false
;
bool
createContext
=
false
;
bool
deviceQuery
=
false
;
bool
image
=
false
;
bool
imageBase
=
false
;
bool
imagePixmap
=
false
;
bool
glTexture2DImage
=
false
;
bool
glTextureCubemapImage
=
false
;
bool
glTexture3DImage
=
false
;
bool
glRenderbufferImage
=
false
;
bool
getAllProcAddresses
=
false
;
bool
flexibleSurfaceCompatibility
=
false
;
bool
directComposition
=
false
;
bool
windowsUIComposition
=
false
;
bool
createContextNoError
=
false
;
bool
stream
=
false
;
bool
streamConsumerGLTexture
=
false
;
bool
streamConsumerGLTextureYUV
=
false
;
bool
streamProducerD3DTexture
=
false
;
bool
fenceSync
=
false
;
bool
waitSync
=
false
;
bool
createContextWebGLCompatibility
=
false
;
bool
createContextBindGeneratesResource
=
false
;
bool
syncControlCHROMIUM
=
false
;
bool
syncControlRateANGLE
=
false
;
bool
swapBuffersWithDamage
=
false
;
bool
pixelFormatFloat
=
false
;
bool
surfacelessContext
=
false
;
bool
displayTextureShareGroup
=
false
;
bool
displaySemaphoreShareGroup
=
false
;
bool
createContextClientArrays
=
false
;
bool
programCacheControl
=
false
;
bool
robustResourceInitialization
=
false
;
bool
iosurfaceClientBuffer
=
false
;
bool
createContextExtensionsEnabled
=
false
;
bool
presentationTime
=
false
;
bool
blobCache
=
false
;
bool
imageNativeBuffer
=
false
;
bool
getFrameTimestamps
=
false
;
bool
recordable
=
false
;
bool
powerPreference
=
false
;
bool
imageD3D11Texture
=
false
;
bool
getNativeClientBufferANDROID
=
false
;
bool
createNativeClientBufferANDROID
=
false
;
bool
nativeFenceSyncANDROID
=
false
;
bool
createContextBackwardsCompatible
=
false
;
bool
noConfigContext
=
false
;
bool
contextPriority
=
false
;
bool
ggpStreamDescriptor
=
false
;
bool
swapWithFrameToken
=
false
;
bool
glColorspace
=
false
;
bool
glColorspaceDisplayP3Linear
=
false
;
bool
glColorspaceDisplayP3
=
false
;
bool
glColorspaceScrgb
=
false
;
bool
glColorspaceScrgbLinear
=
false
;
bool
glColorspaceDisplayP3Passthrough
=
false
;
bool
framebufferTargetANDROID
=
false
;
bool
imageGlColorspace
=
false
;
bool
imageDmaBufImportEXT
=
false
;
bool
imageDmaBufImportModifiersEXT
=
false
;
bool
textureFromPixmapNOK
=
false
;
bool
robustnessVideoMemoryPurgeNV
=
false
;
bool
reusableSyncKHR
=
false
;
}
;
struct
DeviceExtensions
{
DeviceExtensions
(
)
;
std
:
:
vector
<
std
:
:
string
>
getStrings
(
)
const
;
bool
deviceD3D
=
false
;
bool
deviceCGL
=
false
;
bool
deviceEAGL
=
false
;
}
;
struct
ClientExtensions
{
ClientExtensions
(
)
;
ClientExtensions
(
const
ClientExtensions
&
other
)
;
std
:
:
vector
<
std
:
:
string
>
getStrings
(
)
const
;
bool
clientExtensions
=
false
;
bool
platformBase
=
false
;
bool
platformDevice
=
false
;
bool
platformANGLE
=
false
;
bool
platformANGLED3D
=
false
;
bool
platformANGLED3D11ON12
=
false
;
bool
platformANGLEOpenGL
=
false
;
bool
platformANGLENULL
=
false
;
bool
platformANGLEVulkan
=
false
;
bool
platformANGLEMetal
=
false
;
bool
platformANGLEContextVirtualization
=
false
;
bool
platformANGLEDeviceContextVolatileEagl
=
false
;
bool
platformANGLEDeviceContextVolatileCgl
=
false
;
bool
deviceCreation
=
false
;
bool
deviceCreationD3D11
=
false
;
bool
x11Visual
=
false
;
bool
experimentalPresentPath
=
false
;
bool
clientGetAllProcAddresses
=
false
;
bool
debug
=
false
;
bool
explicitContext
=
false
;
bool
featureControlANGLE
=
false
;
bool
platformANGLEDeviceTypeSwiftShader
=
false
;
bool
platformANGLEDeviceTypeEGLANGLE
=
false
;
}
;
}
#
endif
