#
ifndef
LIBANGLE_CAPS_H_
#
define
LIBANGLE_CAPS_H_
#
include
"
angle_gl
.
h
"
#
include
"
libANGLE
/
Version
.
h
"
#
include
"
libANGLE
/
angletypes
.
h
"
#
include
"
libANGLE
/
renderer
/
Format
.
h
"
#
include
<
array
>
#
include
<
map
>
#
include
<
set
>
#
include
<
string
>
#
include
<
vector
>
namespace
gl
{
struct
Extensions
;
typedef
std
:
:
set
<
GLuint
>
SupportedSampleSet
;
struct
TextureCaps
{
TextureCaps
(
)
;
TextureCaps
(
const
TextureCaps
&
other
)
;
~
TextureCaps
(
)
;
bool
texturable
;
bool
filterable
;
bool
renderable
;
SupportedSampleSet
sampleCounts
;
GLuint
getMaxSamples
(
)
const
;
GLuint
getNearestSamples
(
GLuint
requestedSamples
)
const
;
}
;
TextureCaps
GenerateMinimumTextureCaps
(
GLenum
internalFormat
const
Version
&
clientVersion
const
Extensions
&
extensions
)
;
class
TextureCapsMap
final
:
angle
:
:
NonCopyable
{
public
:
TextureCapsMap
(
)
;
~
TextureCapsMap
(
)
;
void
insert
(
GLenum
internalFormat
const
TextureCaps
&
caps
)
;
const
TextureCaps
&
get
(
GLenum
internalFormat
)
const
;
void
clear
(
)
;
const
TextureCaps
&
get
(
angle
:
:
Format
:
:
ID
formatID
)
const
;
void
set
(
angle
:
:
Format
:
:
ID
formatID
const
TextureCaps
&
caps
)
;
private
:
TextureCaps
&
get
(
angle
:
:
Format
:
:
ID
formatID
)
;
std
:
:
array
<
TextureCaps
angle
:
:
kNumANGLEFormats
>
mFormatData
;
}
;
void
InitMinimumTextureCapsMap
(
const
Version
&
clientVersion
const
Extensions
&
extensions
TextureCapsMap
*
capsMap
)
;
struct
Extensions
{
Extensions
(
)
;
std
:
:
vector
<
std
:
:
string
>
getStrings
(
)
const
;
void
setTextureExtensionSupport
(
const
TextureCapsMap
&
textureCaps
)
;
bool
elementIndexUint
;
bool
packedDepthStencil
;
bool
getProgramBinary
;
bool
rgb8rgba8
;
bool
textureFormatBGRA8888
;
bool
readFormatBGRA
;
bool
pixelBufferObject
;
bool
mapBuffer
;
bool
mapBufferRange
;
bool
colorBufferHalfFloat
;
bool
textureHalfFloat
;
bool
textureHalfFloatLinear
;
bool
textureFloat
;
bool
textureFloatLinear
;
bool
textureRG
;
bool
textureCompressionDXT1
;
bool
textureCompressionDXT3
;
bool
textureCompressionDXT5
;
bool
textureCompressionS3TCsRGB
;
bool
textureCompressionASTCHDR
;
bool
textureCompressionASTCLDR
;
bool
compressedETC1RGB8Texture
;
bool
compressedETC2RGB8Texture
;
bool
compressedETC2sRGB8Texture
;
bool
compressedETC2PunchthroughARGB8Texture
;
bool
compressedETC2PunchthroughAsRGB8AlphaTexture
;
bool
compressedETC2RGBA8Texture
;
bool
compressedETC2sRGB8Alpha8Texture
;
bool
compressedEACR11UnsignedTexture
;
bool
compressedEACR11SignedTexture
;
bool
compressedEACRG11UnsignedTexture
;
bool
compressedEACRG11SignedTexture
;
bool
sRGB
;
bool
depthTextures
;
bool
depth32
;
bool
textureStorage
;
bool
textureNPOT
;
bool
drawBuffers
;
bool
textureFilterAnisotropic
;
GLfloat
maxTextureAnisotropy
;
bool
occlusionQueryBoolean
;
bool
fence
;
bool
disjointTimerQuery
;
GLuint
queryCounterBitsTimeElapsed
;
GLuint
queryCounterBitsTimestamp
;
bool
robustness
;
bool
robustBufferAccessBehavior
;
bool
blendMinMax
;
bool
framebufferBlit
;
bool
framebufferMultisample
;
bool
instancedArrays
;
bool
packReverseRowOrder
;
bool
standardDerivatives
;
bool
shaderTextureLOD
;
bool
fragDepth
;
bool
multiview
;
GLuint
maxViews
;
bool
textureUsage
;
bool
translatedShaderSource
;
bool
fboRenderMipmap
;
bool
discardFramebuffer
;
bool
debugMarker
;
bool
eglImage
;
bool
eglImageExternal
;
bool
eglImageExternalEssl3
;
bool
eglStreamConsumerExternal
;
bool
unpackSubimage
;
bool
packSubimage
;
bool
vertexArrayObject
;
bool
debug
;
GLuint
maxDebugMessageLength
;
GLuint
maxDebugLoggedMessages
;
GLuint
maxDebugGroupStackDepth
;
GLuint
maxLabelLength
;
bool
noError
;
bool
lossyETCDecode
;
bool
bindUniformLocation
;
bool
syncQuery
;
bool
copyTexture
;
bool
copyCompressedTexture
;
bool
webglCompatibility
;
bool
requestExtension
;
bool
bindGeneratesResource
;
bool
robustClientMemory
;
bool
textureSRGBDecode
;
bool
sRGBWriteControl
;
bool
colorBufferFloatRGB
;
bool
colorBufferFloatRGBA
;
bool
colorBufferFloat
;
bool
multisampleCompatibility
;
bool
framebufferMixedSamples
;
bool
textureNorm16
;
bool
pathRendering
;
bool
surfacelessContext
;
bool
clientArrays
;
bool
robustResourceInitialization
;
bool
programCacheControl
;
bool
textureRectangle
;
bool
geometryShader
;
bool
pointSizeArray
;
bool
textureCubeMap
;
bool
explicitContextGles1
;
bool
explicitContext
;
}
;
struct
ExtensionInfo
{
bool
Requestable
=
false
;
typedef
bool
(
Extensions
:
:
*
ExtensionBool
)
;
ExtensionBool
ExtensionsMember
=
nullptr
;
}
;
using
ExtensionInfoMap
=
std
:
:
map
<
std
:
:
string
ExtensionInfo
>
;
const
ExtensionInfoMap
&
GetExtensionInfoMap
(
)
;
struct
Limitations
{
Limitations
(
)
;
bool
noFrontFacingSupport
;
bool
noSampleAlphaToCoverageSupport
;
bool
attributeZeroRequiresZeroDivisorInEXT
;
bool
noSeparateStencilRefsAndMasks
;
bool
shadersRequireIndexedLoopValidation
;
bool
noSimultaneousConstantColorAndAlphaBlendFunc
;
bool
noFlexibleVaryingPacking
;
}
;
struct
TypePrecision
{
TypePrecision
(
)
;
TypePrecision
(
const
TypePrecision
&
other
)
;
void
setIEEEFloat
(
)
;
void
setTwosComplementInt
(
unsigned
int
bits
)
;
void
setSimulatedFloat
(
unsigned
int
range
unsigned
int
precision
)
;
void
setSimulatedInt
(
unsigned
int
range
)
;
void
get
(
GLint
*
returnRange
GLint
*
returnPrecision
)
const
;
std
:
:
array
<
GLint
2
>
range
;
GLint
precision
;
}
;
struct
Caps
{
Caps
(
)
;
Caps
(
const
Caps
&
other
)
;
~
Caps
(
)
;
GLuint64
maxElementIndex
;
GLuint
max3DTextureSize
;
GLuint
max2DTextureSize
;
GLuint
maxRectangleTextureSize
;
GLuint
maxArrayTextureLayers
;
GLfloat
maxLODBias
;
GLuint
maxCubeMapTextureSize
;
GLuint
maxRenderbufferSize
;
GLfloat
minAliasedPointSize
;
GLfloat
maxAliasedPointSize
;
GLfloat
minAliasedLineWidth
;
GLfloat
maxAliasedLineWidth
;
GLuint
maxDrawBuffers
;
GLuint
maxFramebufferWidth
;
GLuint
maxFramebufferHeight
;
GLuint
maxFramebufferSamples
;
GLuint
maxColorAttachments
;
GLuint
maxViewportWidth
;
GLuint
maxViewportHeight
;
GLuint
maxSampleMaskWords
;
GLuint
maxColorTextureSamples
;
GLuint
maxDepthTextureSamples
;
GLuint
maxIntegerSamples
;
GLuint64
maxServerWaitTimeout
;
GLint
maxVertexAttribRelativeOffset
;
GLuint
maxVertexAttribBindings
;
GLint
maxVertexAttribStride
;
GLuint
maxElementsIndices
;
GLuint
maxElementsVertices
;
std
:
:
vector
<
GLenum
>
compressedTextureFormats
;
std
:
:
vector
<
GLenum
>
programBinaryFormats
;
std
:
:
vector
<
GLenum
>
shaderBinaryFormats
;
TypePrecision
vertexHighpFloat
;
TypePrecision
vertexMediumpFloat
;
TypePrecision
vertexLowpFloat
;
TypePrecision
vertexHighpInt
;
TypePrecision
vertexMediumpInt
;
TypePrecision
vertexLowpInt
;
TypePrecision
fragmentHighpFloat
;
TypePrecision
fragmentMediumpFloat
;
TypePrecision
fragmentLowpFloat
;
TypePrecision
fragmentHighpInt
;
TypePrecision
fragmentMediumpInt
;
TypePrecision
fragmentLowpInt
;
ShaderMap
<
GLuint
>
maxShaderUniformBlocks
;
ShaderMap
<
GLuint
>
maxShaderTextureImageUnits
;
ShaderMap
<
GLuint
>
maxShaderStorageBlocks
;
GLuint
maxVertexAttributes
;
GLuint
maxVertexUniformComponents
;
GLuint
maxVertexUniformVectors
;
GLuint
maxVertexOutputComponents
;
GLuint
maxVertexAtomicCounterBuffers
;
GLuint
maxVertexAtomicCounters
;
GLuint
maxVertexImageUniforms
;
GLuint
maxFragmentUniformComponents
;
GLuint
maxFragmentUniformVectors
;
GLuint
maxFragmentInputComponents
;
GLuint
maxFragmentAtomicCounterBuffers
;
GLuint
maxFragmentAtomicCounters
;
GLuint
maxFragmentImageUniforms
;
GLint
minProgramTextureGatherOffset
;
GLuint
maxProgramTextureGatherOffset
;
GLint
minProgramTexelOffset
;
GLint
maxProgramTexelOffset
;
std
:
:
array
<
GLuint
3
>
maxComputeWorkGroupCount
;
std
:
:
array
<
GLuint
3
>
maxComputeWorkGroupSize
;
GLuint
maxComputeWorkGroupInvocations
;
GLuint
maxComputeSharedMemorySize
;
GLuint
maxComputeUniformComponents
;
GLuint
maxComputeAtomicCounterBuffers
;
GLuint
maxComputeAtomicCounters
;
GLuint
maxComputeImageUniforms
;
GLuint
maxCombinedComputeUniformComponents
;
GLuint
maxUniformBufferBindings
;
GLuint64
maxUniformBlockSize
;
GLuint
uniformBufferOffsetAlignment
;
GLuint
maxCombinedUniformBlocks
;
GLuint64
maxCombinedVertexUniformComponents
;
GLuint64
maxCombinedFragmentUniformComponents
;
GLuint
maxVaryingComponents
;
GLuint
maxVaryingVectors
;
GLuint
maxCombinedTextureImageUnits
;
GLuint
maxCombinedShaderOutputResources
;
GLuint
maxUniformLocations
;
GLuint
maxAtomicCounterBufferBindings
;
GLuint
maxAtomicCounterBufferSize
;
GLuint
maxCombinedAtomicCounterBuffers
;
GLuint
maxCombinedAtomicCounters
;
GLuint
maxImageUnits
;
GLuint
maxCombinedImageUniforms
;
GLuint
maxShaderStorageBufferBindings
;
GLuint64
maxShaderStorageBlockSize
;
GLuint
maxCombinedShaderStorageBlocks
;
GLuint
shaderStorageBufferOffsetAlignment
;
GLuint
maxTransformFeedbackInterleavedComponents
;
GLuint
maxTransformFeedbackSeparateAttributes
;
GLuint
maxTransformFeedbackSeparateComponents
;
GLuint
maxSamples
;
GLuint
maxFramebufferLayers
;
GLuint
layerProvokingVertex
;
GLuint
maxGeometryUniformComponents
;
GLuint
maxGeometryInputComponents
;
GLuint
maxGeometryOutputComponents
;
GLuint
maxGeometryOutputVertices
;
GLuint
maxGeometryTotalOutputComponents
;
GLuint
maxGeometryAtomicCounterBuffers
;
GLuint
maxGeometryAtomicCounters
;
GLuint
maxGeometryShaderInvocations
;
GLuint
maxGeometryImageUniforms
;
GLuint
maxCombinedGeometryUniformComponents
;
GLuint
maxMultitextureUnits
;
GLuint
maxClipPlanes
;
GLuint
maxLights
;
static
constexpr
int
GlobalMatrixStackDepth
=
16
;
GLuint
maxModelviewMatrixStackDepth
;
GLuint
maxProjectionMatrixStackDepth
;
GLuint
maxTextureMatrixStackDepth
;
}
;
Caps
GenerateMinimumCaps
(
const
Version
&
clientVersion
const
Extensions
&
extensions
)
;
}
namespace
egl
{
struct
Caps
{
Caps
(
)
;
bool
textureNPOT
;
}
;
struct
DisplayExtensions
{
DisplayExtensions
(
)
;
std
:
:
vector
<
std
:
:
string
>
getStrings
(
)
const
;
bool
createContextRobustness
;
bool
d3dShareHandleClientBuffer
;
bool
d3dTextureClientBuffer
;
bool
surfaceD3DTexture2DShareHandle
;
bool
querySurfacePointer
;
bool
windowFixedSize
;
bool
keyedMutex
;
bool
surfaceOrientation
;
bool
postSubBuffer
;
bool
createContext
;
bool
deviceQuery
;
bool
image
;
bool
imageBase
;
bool
imagePixmap
;
bool
glTexture2DImage
;
bool
glTextureCubemapImage
;
bool
glTexture3DImage
;
bool
glRenderbufferImage
;
bool
getAllProcAddresses
;
bool
flexibleSurfaceCompatibility
;
bool
directComposition
;
bool
createContextNoError
;
bool
stream
;
bool
streamConsumerGLTexture
;
bool
streamConsumerGLTextureYUV
;
bool
streamProducerD3DTexture
;
bool
createContextWebGLCompatibility
;
bool
createContextBindGeneratesResource
;
bool
getSyncValues
;
bool
swapBuffersWithDamage
;
bool
pixelFormatFloat
;
bool
surfacelessContext
;
bool
displayTextureShareGroup
;
bool
createContextClientArrays
;
bool
programCacheControl
;
bool
robustResourceInitialization
;
bool
iosurfaceClientBuffer
;
bool
createContextExtensionsEnabled
;
}
;
struct
DeviceExtensions
{
DeviceExtensions
(
)
;
std
:
:
vector
<
std
:
:
string
>
getStrings
(
)
const
;
bool
deviceD3D
;
}
;
struct
ClientExtensions
{
ClientExtensions
(
)
;
ClientExtensions
(
const
ClientExtensions
&
other
)
;
std
:
:
vector
<
std
:
:
string
>
getStrings
(
)
const
;
bool
clientExtensions
;
bool
platformBase
;
bool
platformDevice
;
bool
platformANGLE
;
bool
platformANGLED3D
;
bool
platformANGLEOpenGL
;
bool
platformANGLENULL
;
bool
platformANGLEVulkan
;
bool
deviceCreation
;
bool
deviceCreationD3D11
;
bool
x11Visual
;
bool
experimentalPresentPath
;
bool
clientGetAllProcAddresses
;
bool
explicitContext
;
}
;
}
#
endif
