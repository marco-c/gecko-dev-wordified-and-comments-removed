#
include
"
libANGLE
/
Program
.
h
"
#
include
<
algorithm
>
#
include
<
utility
>
#
include
"
common
/
angle_version
.
h
"
#
include
"
common
/
bitset_utils
.
h
"
#
include
"
common
/
debug
.
h
"
#
include
"
common
/
platform
.
h
"
#
include
"
common
/
string_utils
.
h
"
#
include
"
common
/
utilities
.
h
"
#
include
"
compiler
/
translator
/
blocklayout
.
h
"
#
include
"
libANGLE
/
Context
.
h
"
#
include
"
libANGLE
/
ErrorStrings
.
h
"
#
include
"
libANGLE
/
MemoryProgramCache
.
h
"
#
include
"
libANGLE
/
ProgramLinkedResources
.
h
"
#
include
"
libANGLE
/
ResourceManager
.
h
"
#
include
"
libANGLE
/
Uniform
.
h
"
#
include
"
libANGLE
/
VaryingPacking
.
h
"
#
include
"
libANGLE
/
Version
.
h
"
#
include
"
libANGLE
/
features
.
h
"
#
include
"
libANGLE
/
histogram_macros
.
h
"
#
include
"
libANGLE
/
queryconversions
.
h
"
#
include
"
libANGLE
/
renderer
/
GLImplFactory
.
h
"
#
include
"
libANGLE
/
renderer
/
ProgramImpl
.
h
"
#
include
"
platform
/
FrontendFeatures
.
h
"
#
include
"
platform
/
PlatformMethods
.
h
"
namespace
gl
{
namespace
{
template
<
typename
DestT
typename
SrcT
>
DestT
UniformStateQueryCast
(
SrcT
value
)
;
template
<
>
GLint
UniformStateQueryCast
(
GLfloat
value
)
{
return
clampCast
<
GLint
>
(
roundf
(
value
)
)
;
}
template
<
>
GLuint
UniformStateQueryCast
(
GLfloat
value
)
{
return
clampCast
<
GLuint
>
(
roundf
(
value
)
)
;
}
template
<
>
GLint
UniformStateQueryCast
(
GLuint
value
)
{
return
clampCast
<
GLint
>
(
value
)
;
}
template
<
>
GLuint
UniformStateQueryCast
(
GLint
value
)
{
return
clampCast
<
GLuint
>
(
value
)
;
}
template
<
>
GLfloat
UniformStateQueryCast
(
GLboolean
value
)
{
return
(
ConvertToBool
(
value
)
?
1
.
0f
:
0
.
0f
)
;
}
template
<
>
GLint
UniformStateQueryCast
(
GLboolean
value
)
{
return
(
ConvertToBool
(
value
)
?
1
:
0
)
;
}
template
<
>
GLuint
UniformStateQueryCast
(
GLboolean
value
)
{
return
(
ConvertToBool
(
value
)
?
1u
:
0u
)
;
}
template
<
typename
DestT
typename
SrcT
>
DestT
UniformStateQueryCast
(
SrcT
value
)
{
return
static_cast
<
DestT
>
(
value
)
;
}
template
<
typename
SrcT
typename
DestT
>
void
UniformStateQueryCastLoop
(
DestT
*
dataOut
const
uint8_t
*
srcPointer
int
components
)
{
for
(
int
comp
=
0
;
comp
<
components
;
+
+
comp
)
{
size_t
offset
=
comp
*
4
;
const
SrcT
*
typedSrcPointer
=
reinterpret_cast
<
const
SrcT
*
>
(
&
srcPointer
[
offset
]
)
;
dataOut
[
comp
]
=
UniformStateQueryCast
<
DestT
>
(
*
typedSrcPointer
)
;
}
}
template
<
typename
VarT
>
GLuint
GetResourceIndexFromName
(
const
std
:
:
vector
<
VarT
>
&
list
const
std
:
:
string
&
name
)
{
std
:
:
string
nameAsArrayName
=
name
+
"
[
0
]
"
;
for
(
size_t
index
=
0
;
index
<
list
.
size
(
)
;
index
+
+
)
{
const
VarT
&
resource
=
list
[
index
]
;
if
(
resource
.
name
=
=
name
|
|
(
resource
.
isArray
(
)
&
&
resource
.
name
=
=
nameAsArrayName
)
)
{
return
static_cast
<
GLuint
>
(
index
)
;
}
}
return
GL_INVALID_INDEX
;
}
GLint
GetVariableLocation
(
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
list
const
std
:
:
vector
<
VariableLocation
>
&
locationList
const
std
:
:
string
&
name
)
{
size_t
nameLengthWithoutArrayIndex
;
unsigned
int
arrayIndex
=
ParseArrayIndex
(
name
&
nameLengthWithoutArrayIndex
)
;
for
(
size_t
location
=
0u
;
location
<
locationList
.
size
(
)
;
+
+
location
)
{
const
VariableLocation
&
variableLocation
=
locationList
[
location
]
;
if
(
!
variableLocation
.
used
(
)
)
{
continue
;
}
const
sh
:
:
ShaderVariable
&
variable
=
list
[
variableLocation
.
index
]
;
if
(
(
variable
.
name
=
=
name
)
&
&
(
variableLocation
.
arrayIndex
=
=
0
)
)
{
return
static_cast
<
GLint
>
(
location
)
;
}
if
(
variable
.
isArray
(
)
&
&
variableLocation
.
arrayIndex
=
=
arrayIndex
&
&
angle
:
:
BeginsWith
(
variable
.
name
name
nameLengthWithoutArrayIndex
)
)
{
return
static_cast
<
GLint
>
(
location
)
;
}
}
return
-
1
;
}
GLint
GetVariableLocation
(
const
std
:
:
vector
<
LinkedUniform
>
&
list
const
std
:
:
vector
<
VariableLocation
>
&
locationList
const
std
:
:
string
&
name
)
{
size_t
nameLengthWithoutArrayIndex
;
unsigned
int
arrayIndex
=
ParseArrayIndex
(
name
&
nameLengthWithoutArrayIndex
)
;
for
(
size_t
location
=
0u
;
location
<
locationList
.
size
(
)
;
+
+
location
)
{
const
VariableLocation
&
variableLocation
=
locationList
[
location
]
;
if
(
!
variableLocation
.
used
(
)
)
{
continue
;
}
const
LinkedUniform
&
variable
=
list
[
variableLocation
.
index
]
;
if
(
angle
:
:
BeginsWith
(
variable
.
name
name
)
&
&
(
variableLocation
.
arrayIndex
=
=
0
)
)
{
if
(
name
.
length
(
)
=
=
variable
.
name
.
length
(
)
)
{
ASSERT
(
name
=
=
variable
.
name
)
;
return
static_cast
<
GLint
>
(
location
)
;
}
if
(
name
.
length
(
)
+
3u
=
=
variable
.
name
.
length
(
)
&
&
variable
.
isArray
(
)
)
{
ASSERT
(
name
+
"
[
0
]
"
=
=
variable
.
name
)
;
return
static_cast
<
GLint
>
(
location
)
;
}
}
if
(
variable
.
isArray
(
)
&
&
variableLocation
.
arrayIndex
=
=
arrayIndex
&
&
nameLengthWithoutArrayIndex
+
3u
=
=
variable
.
name
.
length
(
)
&
&
angle
:
:
BeginsWith
(
variable
.
name
name
nameLengthWithoutArrayIndex
)
)
{
ASSERT
(
name
.
substr
(
0u
nameLengthWithoutArrayIndex
)
+
"
[
0
]
"
=
=
variable
.
name
)
;
return
static_cast
<
GLint
>
(
location
)
;
}
}
return
-
1
;
}
void
CopyStringToBuffer
(
GLchar
*
buffer
const
std
:
:
string
&
string
GLsizei
bufSize
GLsizei
*
lengthOut
)
{
ASSERT
(
bufSize
>
0
)
;
size_t
length
=
std
:
:
min
<
size_t
>
(
bufSize
-
1
string
.
length
(
)
)
;
memcpy
(
buffer
string
.
c_str
(
)
length
)
;
buffer
[
length
]
=
'
\
0
'
;
if
(
lengthOut
)
{
*
lengthOut
=
static_cast
<
GLsizei
>
(
length
)
;
}
}
bool
IncludeSameArrayElement
(
const
std
:
:
set
<
std
:
:
string
>
&
nameSet
const
std
:
:
string
&
name
)
{
std
:
:
vector
<
unsigned
int
>
subscripts
;
std
:
:
string
baseName
=
ParseResourceName
(
name
&
subscripts
)
;
for
(
const
std
:
:
string
&
nameInSet
:
nameSet
)
{
std
:
:
vector
<
unsigned
int
>
arrayIndices
;
std
:
:
string
arrayName
=
ParseResourceName
(
nameInSet
&
arrayIndices
)
;
if
(
baseName
=
=
arrayName
&
&
(
subscripts
.
empty
(
)
|
|
arrayIndices
.
empty
(
)
|
|
subscripts
=
=
arrayIndices
)
)
{
return
true
;
}
}
return
false
;
}
std
:
:
string
GetInterfaceBlockLimitName
(
ShaderType
shaderType
sh
:
:
BlockType
blockType
)
{
std
:
:
ostringstream
stream
;
stream
<
<
"
GL_MAX_
"
<
<
GetShaderTypeString
(
shaderType
)
<
<
"
_
"
;
switch
(
blockType
)
{
case
sh
:
:
BlockType
:
:
BLOCK_UNIFORM
:
stream
<
<
"
UNIFORM_BUFFERS
"
;
break
;
case
sh
:
:
BlockType
:
:
BLOCK_BUFFER
:
stream
<
<
"
SHADER_STORAGE_BLOCKS
"
;
break
;
default
:
UNREACHABLE
(
)
;
return
"
"
;
}
if
(
shaderType
=
=
ShaderType
:
:
Geometry
)
{
stream
<
<
"
_EXT
"
;
}
return
stream
.
str
(
)
;
}
const
char
*
GetInterfaceBlockTypeString
(
sh
:
:
BlockType
blockType
)
{
switch
(
blockType
)
{
case
sh
:
:
BlockType
:
:
BLOCK_UNIFORM
:
return
"
uniform
block
"
;
case
sh
:
:
BlockType
:
:
BLOCK_BUFFER
:
return
"
shader
storage
block
"
;
default
:
UNREACHABLE
(
)
;
return
"
"
;
}
}
void
LogInterfaceBlocksExceedLimit
(
InfoLog
&
infoLog
ShaderType
shaderType
sh
:
:
BlockType
blockType
GLuint
limit
)
{
infoLog
<
<
GetShaderTypeString
(
shaderType
)
<
<
"
shader
"
<
<
GetInterfaceBlockTypeString
(
blockType
)
<
<
"
count
exceeds
"
<
<
GetInterfaceBlockLimitName
(
shaderType
blockType
)
<
<
"
(
"
<
<
limit
<
<
"
)
"
;
}
bool
ValidateInterfaceBlocksCount
(
GLuint
maxInterfaceBlocks
const
std
:
:
vector
<
sh
:
:
InterfaceBlock
>
&
interfaceBlocks
ShaderType
shaderType
sh
:
:
BlockType
blockType
GLuint
*
combinedInterfaceBlocksCount
InfoLog
&
infoLog
)
{
GLuint
blockCount
=
0
;
for
(
const
sh
:
:
InterfaceBlock
&
block
:
interfaceBlocks
)
{
if
(
IsActiveInterfaceBlock
(
block
)
)
{
blockCount
+
=
std
:
:
max
(
block
.
arraySize
1u
)
;
if
(
blockCount
>
maxInterfaceBlocks
)
{
LogInterfaceBlocksExceedLimit
(
infoLog
shaderType
blockType
maxInterfaceBlocks
)
;
return
false
;
}
}
}
if
(
combinedInterfaceBlocksCount
)
{
*
combinedInterfaceBlocksCount
+
=
blockCount
;
}
return
true
;
}
GLuint
GetInterfaceBlockIndex
(
const
std
:
:
vector
<
InterfaceBlock
>
&
list
const
std
:
:
string
&
name
)
{
std
:
:
vector
<
unsigned
int
>
subscripts
;
std
:
:
string
baseName
=
ParseResourceName
(
name
&
subscripts
)
;
unsigned
int
numBlocks
=
static_cast
<
unsigned
int
>
(
list
.
size
(
)
)
;
for
(
unsigned
int
blockIndex
=
0
;
blockIndex
<
numBlocks
;
blockIndex
+
+
)
{
const
auto
&
block
=
list
[
blockIndex
]
;
if
(
block
.
name
=
=
baseName
)
{
const
bool
arrayElementZero
=
(
subscripts
.
empty
(
)
&
&
(
!
block
.
isArray
|
|
block
.
arrayElement
=
=
0
)
)
;
const
bool
arrayElementMatches
=
(
subscripts
.
size
(
)
=
=
1
&
&
subscripts
[
0
]
=
=
block
.
arrayElement
)
;
if
(
arrayElementMatches
|
|
arrayElementZero
)
{
return
blockIndex
;
}
}
}
return
GL_INVALID_INDEX
;
}
void
GetInterfaceBlockName
(
const
GLuint
index
const
std
:
:
vector
<
InterfaceBlock
>
&
list
GLsizei
bufSize
GLsizei
*
length
GLchar
*
name
)
{
ASSERT
(
index
<
list
.
size
(
)
)
;
const
auto
&
block
=
list
[
index
]
;
if
(
bufSize
>
0
)
{
std
:
:
string
blockName
=
block
.
name
;
if
(
block
.
isArray
)
{
blockName
+
=
ArrayString
(
block
.
arrayElement
)
;
}
CopyStringToBuffer
(
name
blockName
bufSize
length
)
;
}
}
void
InitUniformBlockLinker
(
const
ProgramState
&
state
UniformBlockLinker
*
blockLinker
)
{
for
(
ShaderType
shaderType
:
AllShaderTypes
(
)
)
{
Shader
*
shader
=
state
.
getAttachedShader
(
shaderType
)
;
if
(
shader
)
{
blockLinker
-
>
addShaderBlocks
(
shaderType
&
shader
-
>
getUniformBlocks
(
)
)
;
}
}
}
void
InitShaderStorageBlockLinker
(
const
ProgramState
&
state
ShaderStorageBlockLinker
*
blockLinker
)
{
for
(
ShaderType
shaderType
:
AllShaderTypes
(
)
)
{
Shader
*
shader
=
state
.
getAttachedShader
(
shaderType
)
;
if
(
shader
!
=
nullptr
)
{
blockLinker
-
>
addShaderBlocks
(
shaderType
&
shader
-
>
getShaderStorageBlocks
(
)
)
;
}
}
}
const
sh
:
:
ShaderVariable
*
FindOutputVaryingOrField
(
const
ProgramMergedVaryings
&
varyings
ShaderType
stage
const
std
:
:
string
&
name
)
{
const
sh
:
:
ShaderVariable
*
var
=
nullptr
;
for
(
const
ProgramVaryingRef
&
ref
:
varyings
)
{
if
(
ref
.
frontShaderStage
!
=
stage
)
{
continue
;
}
const
sh
:
:
ShaderVariable
*
varying
=
ref
.
get
(
stage
)
;
if
(
varying
-
>
name
=
=
name
)
{
var
=
varying
;
break
;
}
GLuint
fieldIndex
=
0
;
var
=
varying
-
>
findField
(
name
&
fieldIndex
)
;
if
(
var
!
=
nullptr
)
{
break
;
}
}
return
var
;
}
void
AddParentPrefix
(
const
std
:
:
string
&
parentName
std
:
:
string
*
mismatchedFieldName
)
{
ASSERT
(
mismatchedFieldName
)
;
if
(
mismatchedFieldName
-
>
empty
(
)
)
{
*
mismatchedFieldName
=
parentName
;
}
else
{
std
:
:
ostringstream
stream
;
stream
<
<
parentName
<
<
"
.
"
<
<
*
mismatchedFieldName
;
*
mismatchedFieldName
=
stream
.
str
(
)
;
}
}
const
char
*
GetLinkMismatchErrorString
(
LinkMismatchError
linkError
)
{
switch
(
linkError
)
{
case
LinkMismatchError
:
:
TYPE_MISMATCH
:
return
"
Type
"
;
case
LinkMismatchError
:
:
ARRAY_SIZE_MISMATCH
:
return
"
Array
size
"
;
case
LinkMismatchError
:
:
PRECISION_MISMATCH
:
return
"
Precision
"
;
case
LinkMismatchError
:
:
STRUCT_NAME_MISMATCH
:
return
"
Structure
name
"
;
case
LinkMismatchError
:
:
FIELD_NUMBER_MISMATCH
:
return
"
Field
number
"
;
case
LinkMismatchError
:
:
FIELD_NAME_MISMATCH
:
return
"
Field
name
"
;
case
LinkMismatchError
:
:
INTERPOLATION_TYPE_MISMATCH
:
return
"
Interpolation
type
"
;
case
LinkMismatchError
:
:
INVARIANCE_MISMATCH
:
return
"
Invariance
"
;
case
LinkMismatchError
:
:
BINDING_MISMATCH
:
return
"
Binding
layout
qualifier
"
;
case
LinkMismatchError
:
:
LOCATION_MISMATCH
:
return
"
Location
layout
qualifier
"
;
case
LinkMismatchError
:
:
OFFSET_MISMATCH
:
return
"
Offset
layout
qualifier
"
;
case
LinkMismatchError
:
:
INSTANCE_NAME_MISMATCH
:
return
"
Instance
name
qualifier
"
;
case
LinkMismatchError
:
:
FORMAT_MISMATCH
:
return
"
Format
qualifier
"
;
case
LinkMismatchError
:
:
LAYOUT_QUALIFIER_MISMATCH
:
return
"
Layout
qualifier
"
;
case
LinkMismatchError
:
:
MATRIX_PACKING_MISMATCH
:
return
"
Matrix
Packing
"
;
default
:
UNREACHABLE
(
)
;
return
"
"
;
}
}
LinkMismatchError
LinkValidateInterfaceBlockFields
(
const
sh
:
:
ShaderVariable
&
blockField1
const
sh
:
:
ShaderVariable
&
blockField2
bool
webglCompatibility
std
:
:
string
*
mismatchedBlockFieldName
)
{
if
(
blockField1
.
name
!
=
blockField2
.
name
)
{
return
LinkMismatchError
:
:
FIELD_NAME_MISMATCH
;
}
LinkMismatchError
linkError
=
Program
:
:
LinkValidateVariablesBase
(
blockField1
blockField2
webglCompatibility
true
mismatchedBlockFieldName
)
;
if
(
linkError
!
=
LinkMismatchError
:
:
NO_MISMATCH
)
{
AddParentPrefix
(
blockField1
.
name
mismatchedBlockFieldName
)
;
return
linkError
;
}
if
(
blockField1
.
isRowMajorLayout
!
=
blockField2
.
isRowMajorLayout
)
{
AddParentPrefix
(
blockField1
.
name
mismatchedBlockFieldName
)
;
return
LinkMismatchError
:
:
MATRIX_PACKING_MISMATCH
;
}
return
LinkMismatchError
:
:
NO_MISMATCH
;
}
LinkMismatchError
AreMatchingInterfaceBlocks
(
const
sh
:
:
InterfaceBlock
&
interfaceBlock1
const
sh
:
:
InterfaceBlock
&
interfaceBlock2
bool
webglCompatibility
std
:
:
string
*
mismatchedBlockFieldName
)
{
if
(
interfaceBlock1
.
fields
.
size
(
)
!
=
interfaceBlock2
.
fields
.
size
(
)
)
{
return
LinkMismatchError
:
:
FIELD_NUMBER_MISMATCH
;
}
if
(
interfaceBlock1
.
arraySize
!
=
interfaceBlock2
.
arraySize
)
{
return
LinkMismatchError
:
:
ARRAY_SIZE_MISMATCH
;
}
if
(
interfaceBlock1
.
layout
!
=
interfaceBlock2
.
layout
|
|
interfaceBlock1
.
binding
!
=
interfaceBlock2
.
binding
)
{
return
LinkMismatchError
:
:
LAYOUT_QUALIFIER_MISMATCH
;
}
if
(
interfaceBlock1
.
instanceName
.
empty
(
)
!
=
interfaceBlock2
.
instanceName
.
empty
(
)
)
{
return
LinkMismatchError
:
:
INSTANCE_NAME_MISMATCH
;
}
const
unsigned
int
numBlockMembers
=
static_cast
<
unsigned
int
>
(
interfaceBlock1
.
fields
.
size
(
)
)
;
for
(
unsigned
int
blockMemberIndex
=
0
;
blockMemberIndex
<
numBlockMembers
;
blockMemberIndex
+
+
)
{
const
sh
:
:
ShaderVariable
&
member1
=
interfaceBlock1
.
fields
[
blockMemberIndex
]
;
const
sh
:
:
ShaderVariable
&
member2
=
interfaceBlock2
.
fields
[
blockMemberIndex
]
;
LinkMismatchError
linkError
=
LinkValidateInterfaceBlockFields
(
member1
member2
webglCompatibility
mismatchedBlockFieldName
)
;
if
(
linkError
!
=
LinkMismatchError
:
:
NO_MISMATCH
)
{
return
linkError
;
}
}
return
LinkMismatchError
:
:
NO_MISMATCH
;
}
using
ShaderInterfaceBlock
=
std
:
:
pair
<
ShaderType
const
sh
:
:
InterfaceBlock
*
>
;
using
InterfaceBlockMap
=
std
:
:
map
<
std
:
:
string
ShaderInterfaceBlock
>
;
void
InitializeInterfaceBlockMap
(
const
std
:
:
vector
<
sh
:
:
InterfaceBlock
>
&
interfaceBlocks
ShaderType
shaderType
InterfaceBlockMap
*
linkedInterfaceBlocks
)
{
ASSERT
(
linkedInterfaceBlocks
)
;
for
(
const
sh
:
:
InterfaceBlock
&
interfaceBlock
:
interfaceBlocks
)
{
(
*
linkedInterfaceBlocks
)
[
interfaceBlock
.
name
]
=
std
:
:
make_pair
(
shaderType
&
interfaceBlock
)
;
}
}
bool
ValidateGraphicsInterfaceBlocksPerShader
(
const
std
:
:
vector
<
sh
:
:
InterfaceBlock
>
&
interfaceBlocksToLink
ShaderType
shaderType
bool
webglCompatibility
InterfaceBlockMap
*
linkedBlocks
InfoLog
&
infoLog
)
{
ASSERT
(
linkedBlocks
)
;
for
(
const
sh
:
:
InterfaceBlock
&
block
:
interfaceBlocksToLink
)
{
const
auto
&
entry
=
linkedBlocks
-
>
find
(
block
.
name
)
;
if
(
entry
!
=
linkedBlocks
-
>
end
(
)
)
{
const
sh
:
:
InterfaceBlock
&
linkedBlock
=
*
(
entry
-
>
second
.
second
)
;
std
:
:
string
mismatchedStructFieldName
;
LinkMismatchError
linkError
=
AreMatchingInterfaceBlocks
(
block
linkedBlock
webglCompatibility
&
mismatchedStructFieldName
)
;
if
(
linkError
!
=
LinkMismatchError
:
:
NO_MISMATCH
)
{
LogLinkMismatch
(
infoLog
block
.
name
GetInterfaceBlockTypeString
(
block
.
blockType
)
linkError
mismatchedStructFieldName
entry
-
>
second
.
first
shaderType
)
;
return
false
;
}
}
else
{
(
*
linkedBlocks
)
[
block
.
name
]
=
std
:
:
make_pair
(
shaderType
&
block
)
;
}
}
return
true
;
}
bool
ValidateInterfaceBlocksMatch
(
GLuint
numShadersHasInterfaceBlocks
const
ShaderMap
<
const
std
:
:
vector
<
sh
:
:
InterfaceBlock
>
*
>
&
shaderInterfaceBlocks
InfoLog
&
infoLog
bool
webglCompatibility
)
{
if
(
numShadersHasInterfaceBlocks
<
2u
)
{
return
true
;
}
ASSERT
(
!
shaderInterfaceBlocks
[
ShaderType
:
:
Compute
]
)
;
InterfaceBlockMap
linkedInterfaceBlocks
;
bool
interfaceBlockMapInitialized
=
false
;
for
(
ShaderType
shaderType
:
kAllGraphicsShaderTypes
)
{
if
(
!
shaderInterfaceBlocks
[
shaderType
]
)
{
continue
;
}
if
(
!
interfaceBlockMapInitialized
)
{
InitializeInterfaceBlockMap
(
*
shaderInterfaceBlocks
[
shaderType
]
shaderType
&
linkedInterfaceBlocks
)
;
interfaceBlockMapInitialized
=
true
;
}
else
if
(
!
ValidateGraphicsInterfaceBlocksPerShader
(
*
shaderInterfaceBlocks
[
shaderType
]
shaderType
webglCompatibility
&
linkedInterfaceBlocks
infoLog
)
)
{
return
false
;
}
}
return
true
;
}
void
WriteShaderVariableBuffer
(
BinaryOutputStream
*
stream
const
ShaderVariableBuffer
&
var
)
{
stream
-
>
writeInt
(
var
.
binding
)
;
stream
-
>
writeInt
(
var
.
dataSize
)
;
for
(
ShaderType
shaderType
:
AllShaderTypes
(
)
)
{
stream
-
>
writeBool
(
var
.
isActive
(
shaderType
)
)
;
}
stream
-
>
writeInt
(
var
.
memberIndexes
.
size
(
)
)
;
for
(
unsigned
int
memberCounterIndex
:
var
.
memberIndexes
)
{
stream
-
>
writeInt
(
memberCounterIndex
)
;
}
}
void
LoadShaderVariableBuffer
(
BinaryInputStream
*
stream
ShaderVariableBuffer
*
var
)
{
var
-
>
binding
=
stream
-
>
readInt
<
int
>
(
)
;
var
-
>
dataSize
=
stream
-
>
readInt
<
unsigned
int
>
(
)
;
for
(
ShaderType
shaderType
:
AllShaderTypes
(
)
)
{
var
-
>
setActive
(
shaderType
stream
-
>
readBool
(
)
)
;
}
size_t
numMembers
=
stream
-
>
readInt
<
size_t
>
(
)
;
for
(
size_t
blockMemberIndex
=
0
;
blockMemberIndex
<
numMembers
;
blockMemberIndex
+
+
)
{
var
-
>
memberIndexes
.
push_back
(
stream
-
>
readInt
<
unsigned
int
>
(
)
)
;
}
}
void
WriteBufferVariable
(
BinaryOutputStream
*
stream
const
BufferVariable
&
var
)
{
WriteShaderVar
(
stream
var
)
;
stream
-
>
writeInt
(
var
.
bufferIndex
)
;
WriteBlockMemberInfo
(
stream
var
.
blockInfo
)
;
stream
-
>
writeInt
(
var
.
topLevelArraySize
)
;
for
(
ShaderType
shaderType
:
AllShaderTypes
(
)
)
{
stream
-
>
writeBool
(
var
.
isActive
(
shaderType
)
)
;
}
}
void
LoadBufferVariable
(
BinaryInputStream
*
stream
BufferVariable
*
var
)
{
LoadShaderVar
(
stream
var
)
;
var
-
>
bufferIndex
=
stream
-
>
readInt
<
int
>
(
)
;
LoadBlockMemberInfo
(
stream
&
var
-
>
blockInfo
)
;
var
-
>
topLevelArraySize
=
stream
-
>
readInt
<
int
>
(
)
;
for
(
ShaderType
shaderType
:
AllShaderTypes
(
)
)
{
var
-
>
setActive
(
shaderType
stream
-
>
readBool
(
)
)
;
}
}
void
WriteInterfaceBlock
(
BinaryOutputStream
*
stream
const
InterfaceBlock
&
block
)
{
stream
-
>
writeString
(
block
.
name
)
;
stream
-
>
writeString
(
block
.
mappedName
)
;
stream
-
>
writeBool
(
block
.
isArray
)
;
stream
-
>
writeInt
(
block
.
arrayElement
)
;
WriteShaderVariableBuffer
(
stream
block
)
;
}
void
LoadInterfaceBlock
(
BinaryInputStream
*
stream
InterfaceBlock
*
block
)
{
block
-
>
name
=
stream
-
>
readString
(
)
;
block
-
>
mappedName
=
stream
-
>
readString
(
)
;
block
-
>
isArray
=
stream
-
>
readBool
(
)
;
block
-
>
arrayElement
=
stream
-
>
readInt
<
unsigned
int
>
(
)
;
LoadShaderVariableBuffer
(
stream
block
)
;
}
}
struct
Program
:
:
LinkingState
{
std
:
:
shared_ptr
<
ProgramExecutable
>
linkedExecutable
;
std
:
:
unique_ptr
<
ProgramLinkedResources
>
resources
;
egl
:
:
BlobCache
:
:
Key
programHash
;
std
:
:
unique_ptr
<
rx
:
:
LinkEvent
>
linkEvent
;
bool
linkingFromBinary
;
}
;
const
char
*
const
g_fakepath
=
"
C
:
\
\
fakepath
"
;
InfoLog
:
:
InfoLog
(
)
:
mLazyStream
(
nullptr
)
{
}
InfoLog
:
:
~
InfoLog
(
)
{
}
size_t
InfoLog
:
:
getLength
(
)
const
{
if
(
!
mLazyStream
)
{
return
0
;
}
const
std
:
:
string
&
logString
=
mLazyStream
-
>
str
(
)
;
return
logString
.
empty
(
)
?
0
:
logString
.
length
(
)
+
1
;
}
void
InfoLog
:
:
getLog
(
GLsizei
bufSize
GLsizei
*
length
char
*
infoLog
)
const
{
size_t
index
=
0
;
if
(
bufSize
>
0
)
{
const
std
:
:
string
logString
(
str
(
)
)
;
if
(
!
logString
.
empty
(
)
)
{
index
=
std
:
:
min
(
static_cast
<
size_t
>
(
bufSize
)
-
1
logString
.
length
(
)
)
;
memcpy
(
infoLog
logString
.
c_str
(
)
index
)
;
}
infoLog
[
index
]
=
'
\
0
'
;
}
if
(
length
)
{
*
length
=
static_cast
<
GLsizei
>
(
index
)
;
}
}
void
InfoLog
:
:
appendSanitized
(
const
char
*
message
)
{
ensureInitialized
(
)
;
std
:
:
string
msg
(
message
)
;
size_t
found
;
do
{
found
=
msg
.
find
(
g_fakepath
)
;
if
(
found
!
=
std
:
:
string
:
:
npos
)
{
msg
.
erase
(
found
strlen
(
g_fakepath
)
)
;
}
}
while
(
found
!
=
std
:
:
string
:
:
npos
)
;
*
mLazyStream
<
<
message
<
<
std
:
:
endl
;
}
void
InfoLog
:
:
reset
(
)
{
if
(
mLazyStream
)
{
mLazyStream
.
reset
(
nullptr
)
;
}
}
bool
InfoLog
:
:
empty
(
)
const
{
if
(
!
mLazyStream
)
{
return
true
;
}
return
mLazyStream
-
>
rdbuf
(
)
-
>
in_avail
(
)
=
=
0
;
}
void
LogLinkMismatch
(
InfoLog
&
infoLog
const
std
:
:
string
&
variableName
const
char
*
variableType
LinkMismatchError
linkError
const
std
:
:
string
&
mismatchedStructOrBlockFieldName
ShaderType
shaderType1
ShaderType
shaderType2
)
{
std
:
:
ostringstream
stream
;
stream
<
<
GetLinkMismatchErrorString
(
linkError
)
<
<
"
s
of
"
<
<
variableType
<
<
"
'
"
<
<
variableName
;
if
(
!
mismatchedStructOrBlockFieldName
.
empty
(
)
)
{
stream
<
<
"
'
member
'
"
<
<
variableName
<
<
"
.
"
<
<
mismatchedStructOrBlockFieldName
;
}
stream
<
<
"
'
differ
between
"
<
<
GetShaderTypeString
(
shaderType1
)
<
<
"
and
"
<
<
GetShaderTypeString
(
shaderType2
)
<
<
"
shaders
.
"
;
infoLog
<
<
stream
.
str
(
)
;
}
bool
IsActiveInterfaceBlock
(
const
sh
:
:
InterfaceBlock
&
interfaceBlock
)
{
return
interfaceBlock
.
active
|
|
interfaceBlock
.
layout
!
=
sh
:
:
BLOCKLAYOUT_PACKED
;
}
void
WriteBlockMemberInfo
(
BinaryOutputStream
*
stream
const
sh
:
:
BlockMemberInfo
&
var
)
{
stream
-
>
writeInt
(
var
.
arrayStride
)
;
stream
-
>
writeBool
(
var
.
isRowMajorMatrix
)
;
stream
-
>
writeInt
(
var
.
matrixStride
)
;
stream
-
>
writeInt
(
var
.
offset
)
;
stream
-
>
writeInt
(
var
.
topLevelArrayStride
)
;
}
void
LoadBlockMemberInfo
(
BinaryInputStream
*
stream
sh
:
:
BlockMemberInfo
*
var
)
{
var
-
>
arrayStride
=
stream
-
>
readInt
<
int
>
(
)
;
var
-
>
isRowMajorMatrix
=
stream
-
>
readBool
(
)
;
var
-
>
matrixStride
=
stream
-
>
readInt
<
int
>
(
)
;
var
-
>
offset
=
stream
-
>
readInt
<
int
>
(
)
;
var
-
>
topLevelArrayStride
=
stream
-
>
readInt
<
int
>
(
)
;
}
void
WriteShaderVar
(
BinaryOutputStream
*
stream
const
sh
:
:
ShaderVariable
&
var
)
{
stream
-
>
writeInt
(
var
.
type
)
;
stream
-
>
writeInt
(
var
.
precision
)
;
stream
-
>
writeString
(
var
.
name
)
;
stream
-
>
writeString
(
var
.
mappedName
)
;
stream
-
>
writeIntVector
(
var
.
arraySizes
)
;
stream
-
>
writeBool
(
var
.
staticUse
)
;
stream
-
>
writeBool
(
var
.
active
)
;
stream
-
>
writeInt
(
var
.
binding
)
;
stream
-
>
writeString
(
var
.
structName
)
;
stream
-
>
writeInt
(
var
.
hasParentArrayIndex
(
)
?
var
.
parentArrayIndex
(
)
:
-
1
)
;
stream
-
>
writeInt
(
var
.
imageUnitFormat
)
;
stream
-
>
writeInt
(
var
.
offset
)
;
stream
-
>
writeBool
(
var
.
readonly
)
;
stream
-
>
writeBool
(
var
.
writeonly
)
;
stream
-
>
writeBool
(
var
.
texelFetchStaticUse
)
;
ASSERT
(
var
.
fields
.
empty
(
)
)
;
}
void
LoadShaderVar
(
BinaryInputStream
*
stream
sh
:
:
ShaderVariable
*
var
)
{
var
-
>
type
=
stream
-
>
readInt
<
GLenum
>
(
)
;
var
-
>
precision
=
stream
-
>
readInt
<
GLenum
>
(
)
;
var
-
>
name
=
stream
-
>
readString
(
)
;
var
-
>
mappedName
=
stream
-
>
readString
(
)
;
stream
-
>
readIntVector
<
unsigned
int
>
(
&
var
-
>
arraySizes
)
;
var
-
>
staticUse
=
stream
-
>
readBool
(
)
;
var
-
>
active
=
stream
-
>
readBool
(
)
;
var
-
>
binding
=
stream
-
>
readInt
<
int
>
(
)
;
var
-
>
structName
=
stream
-
>
readString
(
)
;
var
-
>
setParentArrayIndex
(
stream
-
>
readInt
<
int
>
(
)
)
;
var
-
>
imageUnitFormat
=
stream
-
>
readInt
<
GLenum
>
(
)
;
var
-
>
offset
=
stream
-
>
readInt
<
int
>
(
)
;
var
-
>
readonly
=
stream
-
>
readBool
(
)
;
var
-
>
writeonly
=
stream
-
>
readBool
(
)
;
var
-
>
texelFetchStaticUse
=
stream
-
>
readBool
(
)
;
}
VariableLocation
:
:
VariableLocation
(
)
:
arrayIndex
(
0
)
index
(
kUnused
)
ignored
(
false
)
{
}
VariableLocation
:
:
VariableLocation
(
unsigned
int
arrayIndex
unsigned
int
index
)
:
arrayIndex
(
arrayIndex
)
index
(
index
)
ignored
(
false
)
{
ASSERT
(
arrayIndex
!
=
GL_INVALID_INDEX
)
;
}
SamplerBinding
:
:
SamplerBinding
(
TextureType
textureTypeIn
SamplerFormat
formatIn
size_t
elementCount
)
:
textureType
(
textureTypeIn
)
format
(
formatIn
)
boundTextureUnits
(
elementCount
0
)
{
}
SamplerBinding
:
:
SamplerBinding
(
const
SamplerBinding
&
other
)
=
default
;
SamplerBinding
:
:
~
SamplerBinding
(
)
=
default
;
ProgramBindings
:
:
ProgramBindings
(
)
{
}
ProgramBindings
:
:
~
ProgramBindings
(
)
{
}
void
ProgramBindings
:
:
bindLocation
(
GLuint
index
const
std
:
:
string
&
name
)
{
mBindings
[
name
]
=
index
;
}
int
ProgramBindings
:
:
getBindingByName
(
const
std
:
:
string
&
name
)
const
{
auto
iter
=
mBindings
.
find
(
name
)
;
return
(
iter
!
=
mBindings
.
end
(
)
)
?
iter
-
>
second
:
-
1
;
}
int
ProgramBindings
:
:
getBinding
(
const
sh
:
:
ShaderVariable
&
variable
)
const
{
return
getBindingByName
(
variable
.
name
)
;
}
ProgramBindings
:
:
const_iterator
ProgramBindings
:
:
begin
(
)
const
{
return
mBindings
.
begin
(
)
;
}
ProgramBindings
:
:
const_iterator
ProgramBindings
:
:
end
(
)
const
{
return
mBindings
.
end
(
)
;
}
ProgramAliasedBindings
:
:
ProgramAliasedBindings
(
)
{
}
ProgramAliasedBindings
:
:
~
ProgramAliasedBindings
(
)
{
}
void
ProgramAliasedBindings
:
:
bindLocation
(
GLuint
index
const
std
:
:
string
&
name
)
{
mBindings
[
name
]
=
ProgramBinding
(
index
)
;
size_t
nameLengthWithoutArrayIndex
;
unsigned
int
arrayIndex
=
ParseArrayIndex
(
name
&
nameLengthWithoutArrayIndex
)
;
if
(
arrayIndex
=
=
0
)
{
std
:
:
string
baseName
=
name
.
substr
(
0u
nameLengthWithoutArrayIndex
)
;
auto
iter
=
mBindings
.
find
(
baseName
)
;
if
(
iter
!
=
mBindings
.
end
(
)
)
{
iter
-
>
second
.
aliased
=
true
;
}
}
}
int
ProgramAliasedBindings
:
:
getBindingByName
(
const
std
:
:
string
&
name
)
const
{
auto
iter
=
mBindings
.
find
(
name
)
;
return
(
iter
!
=
mBindings
.
end
(
)
)
?
iter
-
>
second
.
location
:
-
1
;
}
int
ProgramAliasedBindings
:
:
getBindingByLocation
(
GLuint
location
)
const
{
for
(
const
auto
&
iter
:
mBindings
)
{
if
(
iter
.
second
.
location
=
=
location
)
{
return
iter
.
second
.
location
;
}
}
return
-
1
;
}
int
ProgramAliasedBindings
:
:
getBinding
(
const
sh
:
:
ShaderVariable
&
variable
)
const
{
const
std
:
:
string
&
name
=
variable
.
name
;
if
(
variable
.
isArray
(
)
)
{
size_t
nameLengthWithoutArrayIndex
;
unsigned
int
arrayIndex
=
ParseArrayIndex
(
name
&
nameLengthWithoutArrayIndex
)
;
if
(
arrayIndex
=
=
0
)
{
std
:
:
string
baseName
=
name
.
substr
(
0u
nameLengthWithoutArrayIndex
)
;
auto
iter
=
mBindings
.
find
(
baseName
)
;
if
(
iter
!
=
mBindings
.
end
(
)
&
&
!
iter
-
>
second
.
aliased
)
{
return
iter
-
>
second
.
location
;
}
}
else
if
(
arrayIndex
=
=
GL_INVALID_INDEX
)
{
auto
iter
=
mBindings
.
find
(
variable
.
name
)
;
if
(
iter
!
=
mBindings
.
end
(
)
&
&
!
iter
-
>
second
.
aliased
)
{
return
iter
-
>
second
.
location
;
}
return
getBindingByName
(
name
+
"
[
0
]
"
)
;
}
}
return
getBindingByName
(
name
)
;
}
ProgramAliasedBindings
:
:
const_iterator
ProgramAliasedBindings
:
:
begin
(
)
const
{
return
mBindings
.
begin
(
)
;
}
ProgramAliasedBindings
:
:
const_iterator
ProgramAliasedBindings
:
:
end
(
)
const
{
return
mBindings
.
end
(
)
;
}
ImageBinding
:
:
ImageBinding
(
size_t
count
)
:
boundImageUnits
(
count
0
)
{
}
ImageBinding
:
:
ImageBinding
(
GLuint
imageUnit
size_t
count
)
{
for
(
size_t
index
=
0
;
index
<
count
;
+
+
index
)
{
boundImageUnits
.
push_back
(
imageUnit
+
static_cast
<
GLuint
>
(
index
)
)
;
}
}
ImageBinding
:
:
ImageBinding
(
const
ImageBinding
&
other
)
=
default
;
ImageBinding
:
:
~
ImageBinding
(
)
=
default
;
ProgramState
:
:
ProgramState
(
)
:
mLabel
(
)
mAttachedShaders
{
}
mAttachedShadersMarkedForDetach
{
}
mLocationsUsedForXfbExtension
(
0
)
mAtomicCounterUniformRange
(
0
0
)
mBinaryRetrieveableHint
(
false
)
mSeparable
(
false
)
mNumViews
(
-
1
)
mGeometryShaderInputPrimitiveType
(
PrimitiveMode
:
:
Triangles
)
mGeometryShaderOutputPrimitiveType
(
PrimitiveMode
:
:
TriangleStrip
)
mGeometryShaderInvocations
(
1
)
mGeometryShaderMaxVertices
(
0
)
mDrawIDLocation
(
-
1
)
mBaseVertexLocation
(
-
1
)
mBaseInstanceLocation
(
-
1
)
mCachedBaseVertex
(
0
)
mCachedBaseInstance
(
0
)
mExecutable
(
new
ProgramExecutable
(
)
)
{
mComputeShaderLocalSize
.
fill
(
1
)
;
}
ProgramState
:
:
~
ProgramState
(
)
{
ASSERT
(
!
hasAttachedShader
(
)
)
;
}
const
std
:
:
string
&
ProgramState
:
:
getLabel
(
)
{
return
mLabel
;
}
Shader
*
ProgramState
:
:
getAttachedShader
(
ShaderType
shaderType
)
const
{
ASSERT
(
shaderType
!
=
ShaderType
:
:
InvalidEnum
)
;
return
mAttachedShaders
[
shaderType
]
;
}
GLuint
ProgramState
:
:
getUniformIndexFromName
(
const
std
:
:
string
&
name
)
const
{
return
GetResourceIndexFromName
(
mExecutable
-
>
mUniforms
name
)
;
}
GLuint
ProgramState
:
:
getBufferVariableIndexFromName
(
const
std
:
:
string
&
name
)
const
{
return
GetResourceIndexFromName
(
mBufferVariables
name
)
;
}
GLuint
ProgramState
:
:
getUniformIndexFromLocation
(
UniformLocation
location
)
const
{
ASSERT
(
location
.
value
>
=
0
&
&
static_cast
<
size_t
>
(
location
.
value
)
<
mUniformLocations
.
size
(
)
)
;
return
mUniformLocations
[
location
.
value
]
.
index
;
}
Optional
<
GLuint
>
ProgramState
:
:
getSamplerIndex
(
UniformLocation
location
)
const
{
GLuint
index
=
getUniformIndexFromLocation
(
location
)
;
if
(
!
isSamplerUniformIndex
(
index
)
)
{
return
Optional
<
GLuint
>
:
:
Invalid
(
)
;
}
return
getSamplerIndexFromUniformIndex
(
index
)
;
}
bool
ProgramState
:
:
isSamplerUniformIndex
(
GLuint
index
)
const
{
return
mExecutable
-
>
mSamplerUniformRange
.
contains
(
index
)
;
}
GLuint
ProgramState
:
:
getSamplerIndexFromUniformIndex
(
GLuint
uniformIndex
)
const
{
ASSERT
(
isSamplerUniformIndex
(
uniformIndex
)
)
;
return
uniformIndex
-
mExecutable
-
>
mSamplerUniformRange
.
low
(
)
;
}
GLuint
ProgramState
:
:
getUniformIndexFromSamplerIndex
(
GLuint
samplerIndex
)
const
{
ASSERT
(
samplerIndex
<
mExecutable
-
>
mSamplerUniformRange
.
length
(
)
)
;
return
samplerIndex
+
mExecutable
-
>
mSamplerUniformRange
.
low
(
)
;
}
bool
ProgramState
:
:
isImageUniformIndex
(
GLuint
index
)
const
{
return
mExecutable
-
>
mImageUniformRange
.
contains
(
index
)
;
}
GLuint
ProgramState
:
:
getImageIndexFromUniformIndex
(
GLuint
uniformIndex
)
const
{
ASSERT
(
isImageUniformIndex
(
uniformIndex
)
)
;
return
uniformIndex
-
mExecutable
-
>
mImageUniformRange
.
low
(
)
;
}
GLuint
ProgramState
:
:
getAttributeLocation
(
const
std
:
:
string
&
name
)
const
{
for
(
const
sh
:
:
ShaderVariable
&
attribute
:
mExecutable
-
>
mProgramInputs
)
{
if
(
attribute
.
name
=
=
name
)
{
return
attribute
.
location
;
}
}
return
static_cast
<
GLuint
>
(
-
1
)
;
}
bool
ProgramState
:
:
hasAttachedShader
(
)
const
{
for
(
const
Shader
*
shader
:
mAttachedShaders
)
{
if
(
shader
)
{
return
true
;
}
}
return
false
;
}
ShaderType
ProgramState
:
:
getFirstAttachedShaderStageType
(
)
const
{
if
(
mExecutable
-
>
getLinkedShaderStages
(
)
.
none
(
)
)
{
return
ShaderType
:
:
InvalidEnum
;
}
return
*
mExecutable
-
>
getLinkedShaderStages
(
)
.
begin
(
)
;
}
ShaderType
ProgramState
:
:
getLastAttachedShaderStageType
(
)
const
{
for
(
int
i
=
gl
:
:
kAllGraphicsShaderTypes
.
size
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
const
gl
:
:
ShaderType
shaderType
=
gl
:
:
kAllGraphicsShaderTypes
[
i
]
;
if
(
mExecutable
-
>
hasLinkedShaderStage
(
shaderType
)
)
{
return
shaderType
;
}
}
if
(
mExecutable
-
>
hasLinkedShaderStage
(
ShaderType
:
:
Compute
)
)
{
return
ShaderType
:
:
Compute
;
}
return
ShaderType
:
:
InvalidEnum
;
}
Program
:
:
Program
(
rx
:
:
GLImplFactory
*
factory
ShaderProgramManager
*
manager
ShaderProgramID
handle
)
:
mSerial
(
factory
-
>
generateSerial
(
)
)
mProgram
(
factory
-
>
createProgram
(
mState
)
)
mValidated
(
false
)
mLinked
(
false
)
mDeleteStatus
(
false
)
mRefCount
(
0
)
mResourceManager
(
manager
)
mHandle
(
handle
)
{
ASSERT
(
mProgram
)
;
unlink
(
)
;
}
Program
:
:
~
Program
(
)
{
ASSERT
(
!
mProgram
)
;
}
void
Program
:
:
onDestroy
(
const
Context
*
context
)
{
resolveLink
(
context
)
;
for
(
ShaderType
shaderType
:
AllShaderTypes
(
)
)
{
if
(
mState
.
mAttachedShaders
[
shaderType
]
)
{
mState
.
mAttachedShaders
[
shaderType
]
-
>
release
(
context
)
;
mState
.
mAttachedShaders
[
shaderType
]
=
nullptr
;
mState
.
mAttachedShadersMarkedForDetach
[
shaderType
]
=
false
;
}
}
mProgram
-
>
destroy
(
context
)
;
ASSERT
(
!
mState
.
hasAttachedShader
(
)
)
;
SafeDelete
(
mProgram
)
;
delete
this
;
}
ShaderProgramID
Program
:
:
id
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mHandle
;
}
void
Program
:
:
setLabel
(
const
Context
*
context
const
std
:
:
string
&
label
)
{
ASSERT
(
!
mLinkingState
)
;
mState
.
mLabel
=
label
;
}
const
std
:
:
string
&
Program
:
:
getLabel
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mState
.
mLabel
;
}
void
Program
:
:
attachShader
(
const
Context
*
context
Shader
*
shader
)
{
ASSERT
(
!
mLinkingState
)
;
ShaderType
shaderType
=
shader
-
>
getType
(
)
;
ASSERT
(
shaderType
!
=
ShaderType
:
:
InvalidEnum
)
;
if
(
mState
.
mAttachedShaders
[
shaderType
]
)
{
mState
.
mAttachedShaders
[
shaderType
]
-
>
release
(
context
)
;
mState
.
mAttachedShaders
[
shaderType
]
=
nullptr
;
mState
.
mAttachedShadersMarkedForDetach
[
shaderType
]
=
false
;
}
mState
.
mAttachedShaders
[
shaderType
]
=
shader
;
mState
.
mAttachedShaders
[
shaderType
]
-
>
addRef
(
)
;
}
void
Program
:
:
detachShader
(
const
Context
*
context
Shader
*
shader
)
{
ASSERT
(
!
mLinkingState
)
;
ShaderType
shaderType
=
shader
-
>
getType
(
)
;
ASSERT
(
shaderType
!
=
ShaderType
:
:
InvalidEnum
)
;
ASSERT
(
mState
.
mAttachedShaders
[
shaderType
]
=
=
shader
)
;
if
(
isSeparable
(
)
)
{
mState
.
mAttachedShadersMarkedForDetach
[
shaderType
]
=
true
;
return
;
}
shader
-
>
release
(
context
)
;
mState
.
mAttachedShaders
[
shaderType
]
=
nullptr
;
mState
.
mAttachedShadersMarkedForDetach
[
shaderType
]
=
false
;
}
int
Program
:
:
getAttachedShadersCount
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
int
numAttachedShaders
=
0
;
for
(
const
Shader
*
shader
:
mState
.
mAttachedShaders
)
{
if
(
shader
)
{
+
+
numAttachedShaders
;
}
}
return
numAttachedShaders
;
}
const
Shader
*
Program
:
:
getAttachedShader
(
ShaderType
shaderType
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mState
.
getAttachedShader
(
shaderType
)
;
}
void
Program
:
:
bindAttributeLocation
(
GLuint
index
const
char
*
name
)
{
ASSERT
(
!
mLinkingState
)
;
mAttributeBindings
.
bindLocation
(
index
name
)
;
}
void
Program
:
:
bindUniformLocation
(
UniformLocation
location
const
char
*
name
)
{
ASSERT
(
!
mLinkingState
)
;
mState
.
mUniformLocationBindings
.
bindLocation
(
location
.
value
name
)
;
}
void
Program
:
:
bindFragmentOutputLocation
(
GLuint
index
const
char
*
name
)
{
mFragmentOutputLocations
.
bindLocation
(
index
name
)
;
}
void
Program
:
:
bindFragmentOutputIndex
(
GLuint
index
const
char
*
name
)
{
mFragmentOutputIndexes
.
bindLocation
(
index
name
)
;
}
angle
:
:
Result
Program
:
:
linkMergedVaryings
(
const
Context
*
context
const
ProgramExecutable
&
executable
const
ProgramMergedVaryings
&
mergedVaryings
)
{
ShaderType
tfStage
=
mState
.
mAttachedShaders
[
ShaderType
:
:
Geometry
]
?
ShaderType
:
:
Geometry
:
ShaderType
:
:
Vertex
;
InfoLog
&
infoLog
=
getExecutable
(
)
.
getInfoLog
(
)
;
if
(
!
linkValidateTransformFeedback
(
context
-
>
getClientVersion
(
)
infoLog
mergedVaryings
tfStage
context
-
>
getCaps
(
)
)
)
{
return
angle
:
:
Result
:
:
Stop
;
}
if
(
!
executable
.
mResources
-
>
varyingPacking
.
collectAndPackUserVaryings
(
infoLog
mergedVaryings
mState
.
getTransformFeedbackVaryingNames
(
)
isSeparable
(
)
)
)
{
return
angle
:
:
Result
:
:
Stop
;
}
gatherTransformFeedbackVaryings
(
mergedVaryings
tfStage
)
;
mState
.
updateTransformFeedbackStrides
(
)
;
return
angle
:
:
Result
:
:
Continue
;
}
angle
:
:
Result
Program
:
:
link
(
const
Context
*
context
)
{
angle
:
:
Result
result
=
linkImpl
(
context
)
;
if
(
mLinkingState
&
&
mLinkingState
-
>
linkedExecutable
)
{
mState
.
mExecutable
=
mLinkingState
-
>
linkedExecutable
;
}
return
result
;
}
angle
:
:
Result
Program
:
:
linkImpl
(
const
Context
*
context
)
{
ASSERT
(
!
mLinkingState
)
;
const
auto
&
data
=
context
-
>
getState
(
)
;
auto
*
platform
=
ANGLEPlatformCurrent
(
)
;
double
startTime
=
platform
-
>
currentTime
(
platform
)
;
mLinked
=
false
;
mState
.
mExecutable
-
>
getInfoLog
(
)
.
reset
(
)
;
if
(
!
linkValidateShaders
(
mState
.
mExecutable
-
>
getInfoLog
(
)
)
)
{
return
angle
:
:
Result
:
:
Continue
;
}
egl
:
:
BlobCache
:
:
Key
programHash
=
{
0
}
;
MemoryProgramCache
*
cache
=
context
-
>
getMemoryProgramCache
(
)
;
if
(
cache
&
&
!
isSeparable
(
)
)
{
std
:
:
lock_guard
<
std
:
:
mutex
>
cacheLock
(
context
-
>
getProgramCacheMutex
(
)
)
;
angle
:
:
Result
cacheResult
=
cache
-
>
getProgram
(
context
this
&
programHash
)
;
ANGLE_TRY
(
cacheResult
)
;
if
(
cacheResult
=
=
angle
:
:
Result
:
:
Continue
)
{
double
delta
=
platform
-
>
currentTime
(
platform
)
-
startTime
;
int
us
=
static_cast
<
int
>
(
delta
*
1000000
.
0
)
;
ANGLE_HISTOGRAM_COUNTS
(
"
GPU
.
ANGLE
.
ProgramCache
.
ProgramCacheHitTimeUS
"
us
)
;
return
angle
:
:
Result
:
:
Continue
;
}
}
unlink
(
)
;
InfoLog
&
infoLog
=
mState
.
mExecutable
-
>
getInfoLog
(
)
;
bool
result
=
linkValidateShaders
(
infoLog
)
;
ASSERT
(
result
)
;
ProgramMergedVaryings
mergedVaryings
;
if
(
mState
.
mAttachedShaders
[
ShaderType
:
:
Compute
]
)
{
mState
.
mExecutable
-
>
mResources
.
reset
(
new
ProgramLinkedResources
(
0
PackMode
:
:
ANGLE_RELAXED
&
mState
.
mExecutable
-
>
mUniformBlocks
&
mState
.
mExecutable
-
>
mUniforms
&
mState
.
mExecutable
-
>
mComputeShaderStorageBlocks
&
mState
.
mBufferVariables
&
mState
.
mExecutable
-
>
mAtomicCounterBuffers
)
)
;
GLuint
combinedImageUniforms
=
0u
;
if
(
!
linkUniforms
(
context
-
>
getCaps
(
)
context
-
>
getClientVersion
(
)
infoLog
mState
.
mUniformLocationBindings
&
combinedImageUniforms
&
mState
.
mExecutable
-
>
getResources
(
)
.
unusedUniforms
)
)
{
return
angle
:
:
Result
:
:
Continue
;
}
GLuint
combinedShaderStorageBlocks
=
0u
;
if
(
!
linkInterfaceBlocks
(
context
-
>
getCaps
(
)
context
-
>
getClientVersion
(
)
context
-
>
getExtensions
(
)
.
webglCompatibility
infoLog
&
combinedShaderStorageBlocks
)
)
{
return
angle
:
:
Result
:
:
Continue
;
}
if
(
combinedImageUniforms
+
combinedShaderStorageBlocks
>
static_cast
<
GLuint
>
(
context
-
>
getCaps
(
)
.
maxCombinedShaderOutputResources
)
)
{
infoLog
<
<
"
The
sum
of
the
number
of
active
image
uniforms
active
shader
storage
blocks
"
"
and
active
fragment
shader
outputs
exceeds
"
"
MAX_COMBINED_SHADER_OUTPUT_RESOURCES
(
"
<
<
context
-
>
getCaps
(
)
.
maxCombinedShaderOutputResources
<
<
"
)
"
;
return
angle
:
:
Result
:
:
Continue
;
}
InitUniformBlockLinker
(
mState
&
mState
.
mExecutable
-
>
getResources
(
)
.
uniformBlockLinker
)
;
InitShaderStorageBlockLinker
(
mState
&
mState
.
mExecutable
-
>
getResources
(
)
.
shaderStorageBlockLinker
)
;
}
else
{
gl
:
:
PackMode
packMode
=
PackMode
:
:
ANGLE_RELAXED
;
if
(
data
.
getLimitations
(
)
.
noFlexibleVaryingPacking
)
{
packMode
=
PackMode
:
:
ANGLE_NON_CONFORMANT_D3D9
;
}
else
if
(
data
.
getExtensions
(
)
.
webglCompatibility
)
{
packMode
=
PackMode
:
:
WEBGL_STRICT
;
}
mState
.
mExecutable
-
>
mResources
.
reset
(
new
ProgramLinkedResources
(
static_cast
<
GLuint
>
(
data
.
getCaps
(
)
.
maxVaryingVectors
)
packMode
&
mState
.
mExecutable
-
>
mUniformBlocks
&
mState
.
mExecutable
-
>
mUniforms
&
mState
.
mExecutable
-
>
mGraphicsShaderStorageBlocks
&
mState
.
mBufferVariables
&
mState
.
mExecutable
-
>
mAtomicCounterBuffers
)
)
;
if
(
!
linkAttributes
(
context
infoLog
)
)
{
return
angle
:
:
Result
:
:
Continue
;
}
if
(
!
linkVaryings
(
infoLog
)
)
{
return
angle
:
:
Result
:
:
Continue
;
}
GLuint
combinedImageUniforms
=
0u
;
if
(
!
linkUniforms
(
context
-
>
getCaps
(
)
context
-
>
getClientVersion
(
)
infoLog
mState
.
mUniformLocationBindings
&
combinedImageUniforms
&
mState
.
mExecutable
-
>
getResources
(
)
.
unusedUniforms
)
)
{
return
angle
:
:
Result
:
:
Continue
;
}
GLuint
combinedShaderStorageBlocks
=
0u
;
if
(
!
linkInterfaceBlocks
(
context
-
>
getCaps
(
)
context
-
>
getClientVersion
(
)
context
-
>
getExtensions
(
)
.
webglCompatibility
infoLog
&
combinedShaderStorageBlocks
)
)
{
return
angle
:
:
Result
:
:
Continue
;
}
gl
:
:
ShaderMap
<
const
gl
:
:
ProgramState
*
>
programStates
;
fillProgramStateMap
(
&
programStates
)
;
if
(
!
mState
.
mExecutable
-
>
linkValidateGlobalNames
(
infoLog
programStates
)
)
{
return
angle
:
:
Result
:
:
Continue
;
}
if
(
!
linkOutputVariables
(
context
-
>
getCaps
(
)
context
-
>
getExtensions
(
)
context
-
>
getClientVersion
(
)
combinedImageUniforms
combinedShaderStorageBlocks
)
)
{
return
angle
:
:
Result
:
:
Continue
;
}
gl
:
:
Shader
*
vertexShader
=
mState
.
mAttachedShaders
[
ShaderType
:
:
Vertex
]
;
if
(
vertexShader
)
{
mState
.
mNumViews
=
vertexShader
-
>
getNumViews
(
)
;
}
gl
:
:
Shader
*
fragmentShader
=
mState
.
mAttachedShaders
[
ShaderType
:
:
Fragment
]
;
if
(
fragmentShader
)
{
mState
.
mEarlyFramentTestsOptimization
=
fragmentShader
-
>
hasEarlyFragmentTestsOptimization
(
)
;
}
InitUniformBlockLinker
(
mState
&
mState
.
mExecutable
-
>
getResources
(
)
.
uniformBlockLinker
)
;
InitShaderStorageBlockLinker
(
mState
&
mState
.
mExecutable
-
>
getResources
(
)
.
shaderStorageBlockLinker
)
;
ProgramPipeline
*
programPipeline
=
context
-
>
getState
(
)
.
getProgramPipeline
(
)
;
if
(
programPipeline
&
&
programPipeline
-
>
usesShaderProgram
(
id
(
)
)
)
{
mergedVaryings
=
context
-
>
getState
(
)
.
getProgramPipeline
(
)
-
>
getMergedVaryings
(
)
;
}
else
{
mergedVaryings
=
getMergedVaryings
(
)
;
}
ANGLE_TRY
(
linkMergedVaryings
(
context
*
mState
.
mExecutable
mergedVaryings
)
)
;
}
updateLinkedShaderStages
(
)
;
mLinkingState
.
reset
(
new
LinkingState
(
)
)
;
mLinkingState
-
>
linkingFromBinary
=
false
;
mLinkingState
-
>
programHash
=
programHash
;
mLinkingState
-
>
linkEvent
=
mProgram
-
>
link
(
context
mState
.
mExecutable
-
>
getResources
(
)
infoLog
mergedVaryings
)
;
mState
.
updateProgramInterfaceInputs
(
)
;
mState
.
updateProgramInterfaceOutputs
(
)
;
if
(
mState
.
mSeparable
)
{
mState
.
mExecutable
-
>
saveLinkedStateInfo
(
mState
)
;
mLinkingState
-
>
linkedExecutable
=
mState
.
mExecutable
;
}
return
angle
:
:
Result
:
:
Continue
;
}
bool
Program
:
:
isLinking
(
)
const
{
return
(
mLinkingState
.
get
(
)
&
&
mLinkingState
-
>
linkEvent
&
&
mLinkingState
-
>
linkEvent
-
>
isLinking
(
)
)
;
}
void
Program
:
:
resolveLinkImpl
(
const
Context
*
context
)
{
ASSERT
(
mLinkingState
.
get
(
)
)
;
angle
:
:
Result
result
=
mLinkingState
-
>
linkEvent
-
>
wait
(
context
)
;
mLinked
=
result
=
=
angle
:
:
Result
:
:
Continue
;
std
:
:
unique_ptr
<
LinkingState
>
linkingState
=
std
:
:
move
(
mLinkingState
)
;
if
(
!
mLinked
)
{
return
;
}
if
(
linkingState
-
>
linkingFromBinary
)
{
return
;
}
initInterfaceBlockBindings
(
)
;
ASSERT
(
mLinked
)
;
std
:
:
vector
<
ImageBinding
>
*
imageBindings
=
getExecutable
(
)
.
getImageBindings
(
)
;
mProgram
-
>
markUnusedUniformLocations
(
&
mState
.
mUniformLocations
&
mState
.
mExecutable
-
>
mSamplerBindings
imageBindings
)
;
postResolveLink
(
context
)
;
std
:
:
lock_guard
<
std
:
:
mutex
>
cacheLock
(
context
-
>
getProgramCacheMutex
(
)
)
;
MemoryProgramCache
*
cache
=
context
-
>
getMemoryProgramCache
(
)
;
if
(
cache
&
&
!
isSeparable
(
)
&
&
(
mState
.
mExecutable
-
>
mLinkedTransformFeedbackVaryings
.
empty
(
)
|
|
!
context
-
>
getFrontendFeatures
(
)
.
disableProgramCachingForTransformFeedback
.
enabled
)
)
{
if
(
cache
-
>
putProgram
(
linkingState
-
>
programHash
context
this
)
=
=
angle
:
:
Result
:
:
Stop
)
{
WARN
(
)
<
<
"
Failed
to
save
linked
program
to
memory
program
cache
.
"
;
}
}
}
void
Program
:
:
updateLinkedShaderStages
(
)
{
mState
.
mExecutable
-
>
resetLinkedShaderStages
(
)
;
for
(
const
Shader
*
shader
:
mState
.
mAttachedShaders
)
{
if
(
shader
)
{
mState
.
mExecutable
-
>
setLinkedShaderStages
(
shader
-
>
getType
(
)
)
;
}
}
if
(
mState
.
mExecutable
-
>
hasLinkedShaderStage
(
ShaderType
:
:
Compute
)
)
{
mState
.
mExecutable
-
>
setIsCompute
(
true
)
;
}
else
{
mState
.
mExecutable
-
>
setIsCompute
(
false
)
;
}
}
void
ProgramState
:
:
updateTransformFeedbackStrides
(
)
{
if
(
mExecutable
-
>
mTransformFeedbackBufferMode
=
=
GL_INTERLEAVED_ATTRIBS
)
{
mExecutable
-
>
mTransformFeedbackStrides
.
resize
(
1
)
;
size_t
totalSize
=
0
;
for
(
const
TransformFeedbackVarying
&
varying
:
mExecutable
-
>
mLinkedTransformFeedbackVaryings
)
{
totalSize
+
=
varying
.
size
(
)
*
VariableExternalSize
(
varying
.
type
)
;
}
mExecutable
-
>
mTransformFeedbackStrides
[
0
]
=
static_cast
<
GLsizei
>
(
totalSize
)
;
}
else
{
mExecutable
-
>
mTransformFeedbackStrides
.
resize
(
mExecutable
-
>
mLinkedTransformFeedbackVaryings
.
size
(
)
)
;
for
(
size_t
i
=
0
;
i
<
mExecutable
-
>
mLinkedTransformFeedbackVaryings
.
size
(
)
;
i
+
+
)
{
TransformFeedbackVarying
&
varying
=
mExecutable
-
>
mLinkedTransformFeedbackVaryings
[
i
]
;
mExecutable
-
>
mTransformFeedbackStrides
[
i
]
=
static_cast
<
GLsizei
>
(
varying
.
size
(
)
*
VariableExternalSize
(
varying
.
type
)
)
;
}
}
}
void
ProgramState
:
:
updateActiveSamplers
(
)
{
mExecutable
-
>
mActiveSamplerRefCounts
.
fill
(
0
)
;
mExecutable
-
>
updateActiveSamplers
(
*
this
)
;
}
void
ProgramState
:
:
updateProgramInterfaceInputs
(
)
{
const
ShaderType
firstAttachedShaderType
=
getFirstAttachedShaderStageType
(
)
;
if
(
firstAttachedShaderType
=
=
ShaderType
:
:
Vertex
)
{
return
;
}
Shader
*
shader
=
getAttachedShader
(
firstAttachedShaderType
)
;
ASSERT
(
shader
)
;
if
(
shader
-
>
getType
(
)
=
=
ShaderType
:
:
Compute
)
{
for
(
const
sh
:
:
ShaderVariable
&
attribute
:
shader
-
>
getAllAttributes
(
)
)
{
mExecutable
-
>
mProgramInputs
.
emplace_back
(
attribute
)
;
}
}
else
if
(
shader
-
>
getType
(
)
=
=
ShaderType
:
:
Fragment
)
{
for
(
const
sh
:
:
ShaderVariable
&
varying
:
shader
-
>
getInputVaryings
(
)
)
{
if
(
varying
.
isStruct
(
)
)
{
for
(
const
sh
:
:
ShaderVariable
&
field
:
varying
.
fields
)
{
sh
:
:
ShaderVariable
fieldVarying
=
sh
:
:
ShaderVariable
(
field
)
;
fieldVarying
.
location
=
varying
.
location
;
fieldVarying
.
name
=
varying
.
name
+
"
.
"
+
field
.
name
;
mExecutable
-
>
mProgramInputs
.
emplace_back
(
fieldVarying
)
;
}
}
else
{
mExecutable
-
>
mProgramInputs
.
emplace_back
(
varying
)
;
}
}
}
}
void
ProgramState
:
:
updateProgramInterfaceOutputs
(
)
{
const
ShaderType
lastAttachedShaderType
=
getLastAttachedShaderStageType
(
)
;
if
(
lastAttachedShaderType
=
=
ShaderType
:
:
Fragment
)
{
return
;
}
if
(
lastAttachedShaderType
=
=
ShaderType
:
:
Compute
)
{
return
;
}
Shader
*
shader
=
getAttachedShader
(
lastAttachedShaderType
)
;
ASSERT
(
shader
)
;
for
(
const
sh
:
:
ShaderVariable
&
varying
:
shader
-
>
getOutputVaryings
(
)
)
{
if
(
varying
.
isStruct
(
)
)
{
for
(
const
sh
:
:
ShaderVariable
&
field
:
varying
.
fields
)
{
sh
:
:
ShaderVariable
fieldVarying
=
sh
:
:
ShaderVariable
(
field
)
;
fieldVarying
.
location
=
varying
.
location
;
fieldVarying
.
name
=
varying
.
name
+
"
.
"
+
field
.
name
;
mExecutable
-
>
mOutputVariables
.
emplace_back
(
fieldVarying
)
;
}
}
else
{
mExecutable
-
>
mOutputVariables
.
emplace_back
(
varying
)
;
}
}
}
void
Program
:
:
unlink
(
)
{
if
(
mLinkingState
&
&
mLinkingState
-
>
linkedExecutable
)
{
mState
.
mExecutable
.
reset
(
new
ProgramExecutable
(
*
mLinkingState
-
>
linkedExecutable
)
)
;
}
mState
.
mExecutable
-
>
reset
(
)
;
mState
.
mUniformLocations
.
clear
(
)
;
mState
.
mBufferVariables
.
clear
(
)
;
mState
.
mActiveUniformBlockBindings
.
reset
(
)
;
mState
.
mSecondaryOutputLocations
.
clear
(
)
;
mState
.
mOutputVariableTypes
.
clear
(
)
;
mState
.
mDrawBufferTypeMask
.
reset
(
)
;
mState
.
mActiveOutputVariables
.
reset
(
)
;
mState
.
mComputeShaderLocalSize
.
fill
(
1
)
;
mState
.
mNumViews
=
-
1
;
mState
.
mGeometryShaderInputPrimitiveType
=
PrimitiveMode
:
:
Triangles
;
mState
.
mGeometryShaderOutputPrimitiveType
=
PrimitiveMode
:
:
TriangleStrip
;
mState
.
mGeometryShaderInvocations
=
1
;
mState
.
mGeometryShaderMaxVertices
=
0
;
mState
.
mDrawIDLocation
=
-
1
;
mState
.
mBaseVertexLocation
=
-
1
;
mState
.
mBaseInstanceLocation
=
-
1
;
mState
.
mCachedBaseVertex
=
0
;
mState
.
mCachedBaseInstance
=
0
;
mState
.
mEarlyFramentTestsOptimization
=
false
;
mValidated
=
false
;
mLinked
=
false
;
}
angle
:
:
Result
Program
:
:
loadBinary
(
const
Context
*
context
GLenum
binaryFormat
const
void
*
binary
GLsizei
length
)
{
ASSERT
(
!
mLinkingState
)
;
unlink
(
)
;
InfoLog
&
infoLog
=
mState
.
mExecutable
-
>
getInfoLog
(
)
;
#
if
ANGLE_PROGRAM_BINARY_LOAD
!
=
ANGLE_ENABLED
return
angle
:
:
Result
:
:
Continue
;
#
else
ASSERT
(
binaryFormat
=
=
GL_PROGRAM_BINARY_ANGLE
)
;
if
(
binaryFormat
!
=
GL_PROGRAM_BINARY_ANGLE
)
{
infoLog
<
<
"
Invalid
program
binary
format
.
"
;
return
angle
:
:
Result
:
:
Continue
;
}
BinaryInputStream
stream
(
binary
length
)
;
ANGLE_TRY
(
deserialize
(
context
stream
infoLog
)
)
;
for
(
size_t
uniformBlockIndex
=
0
;
uniformBlockIndex
<
mState
.
mExecutable
-
>
getActiveUniformBlockCount
(
)
;
+
+
uniformBlockIndex
)
{
mDirtyBits
.
set
(
uniformBlockIndex
)
;
}
angle
:
:
Result
result
;
std
:
:
unique_ptr
<
LinkingState
>
linkingState
;
std
:
:
unique_ptr
<
rx
:
:
LinkEvent
>
linkEvent
=
mProgram
-
>
load
(
context
&
stream
infoLog
)
;
if
(
linkEvent
)
{
linkingState
=
std
:
:
make_unique
<
LinkingState
>
(
)
;
linkingState
-
>
linkingFromBinary
=
true
;
linkingState
-
>
linkEvent
=
std
:
:
move
(
linkEvent
)
;
result
=
angle
:
:
Result
:
:
Continue
;
}
else
{
result
=
angle
:
:
Result
:
:
Incomplete
;
}
mLinkingState
=
std
:
:
move
(
linkingState
)
;
return
result
;
#
endif
}
angle
:
:
Result
Program
:
:
saveBinary
(
Context
*
context
GLenum
*
binaryFormat
void
*
binary
GLsizei
bufSize
GLsizei
*
length
)
const
{
ASSERT
(
!
mLinkingState
)
;
if
(
binaryFormat
)
{
*
binaryFormat
=
GL_PROGRAM_BINARY_ANGLE
;
}
angle
:
:
MemoryBuffer
memoryBuf
;
ANGLE_TRY
(
serialize
(
context
&
memoryBuf
)
)
;
GLsizei
streamLength
=
static_cast
<
GLsizei
>
(
memoryBuf
.
size
(
)
)
;
const
uint8_t
*
streamState
=
memoryBuf
.
data
(
)
;
if
(
streamLength
>
bufSize
)
{
if
(
length
)
{
*
length
=
0
;
}
ANGLE_CHECK
(
context
false
"
Insufficient
buffer
size
"
GL_INVALID_OPERATION
)
;
}
if
(
binary
)
{
char
*
ptr
=
reinterpret_cast
<
char
*
>
(
binary
)
;
memcpy
(
ptr
streamState
streamLength
)
;
ptr
+
=
streamLength
;
ASSERT
(
ptr
-
streamLength
=
=
binary
)
;
}
if
(
length
)
{
*
length
=
streamLength
;
}
return
angle
:
:
Result
:
:
Continue
;
}
GLint
Program
:
:
getBinaryLength
(
Context
*
context
)
const
{
ASSERT
(
!
mLinkingState
)
;
if
(
!
mLinked
)
{
return
0
;
}
GLint
length
;
angle
:
:
Result
result
=
saveBinary
(
context
nullptr
nullptr
std
:
:
numeric_limits
<
GLint
>
:
:
max
(
)
&
length
)
;
if
(
result
!
=
angle
:
:
Result
:
:
Continue
)
{
return
0
;
}
return
length
;
}
void
Program
:
:
setBinaryRetrievableHint
(
bool
retrievable
)
{
ASSERT
(
!
mLinkingState
)
;
mProgram
-
>
setBinaryRetrievableHint
(
retrievable
)
;
mState
.
mBinaryRetrieveableHint
=
retrievable
;
}
bool
Program
:
:
getBinaryRetrievableHint
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mState
.
mBinaryRetrieveableHint
;
}
void
Program
:
:
setSeparable
(
bool
separable
)
{
ASSERT
(
!
mLinkingState
)
;
if
(
mState
.
mSeparable
!
=
separable
)
{
mProgram
-
>
setSeparable
(
separable
)
;
mState
.
mSeparable
=
separable
;
}
}
bool
Program
:
:
isSeparable
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mState
.
mSeparable
;
}
void
Program
:
:
deleteSelf
(
const
Context
*
context
)
{
ASSERT
(
mRefCount
=
=
0
&
&
mDeleteStatus
)
;
mResourceManager
-
>
deleteProgram
(
context
mHandle
)
;
}
unsigned
int
Program
:
:
getRefCount
(
)
const
{
return
mRefCount
;
}
void
Program
:
:
getAttachedShaders
(
GLsizei
maxCount
GLsizei
*
count
ShaderProgramID
*
shaders
)
const
{
ASSERT
(
!
mLinkingState
)
;
int
total
=
0
;
for
(
const
Shader
*
shader
:
mState
.
mAttachedShaders
)
{
if
(
shader
&
&
(
total
<
maxCount
)
)
{
shaders
[
total
]
=
shader
-
>
getHandle
(
)
;
+
+
total
;
}
}
if
(
count
)
{
*
count
=
total
;
}
}
GLuint
Program
:
:
getAttributeLocation
(
const
std
:
:
string
&
name
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mState
.
getAttributeLocation
(
name
)
;
}
void
Program
:
:
getActiveAttribute
(
GLuint
index
GLsizei
bufsize
GLsizei
*
length
GLint
*
size
GLenum
*
type
GLchar
*
name
)
const
{
ASSERT
(
!
mLinkingState
)
;
if
(
!
mLinked
)
{
if
(
bufsize
>
0
)
{
name
[
0
]
=
'
\
0
'
;
}
if
(
length
)
{
*
length
=
0
;
}
*
type
=
GL_NONE
;
*
size
=
1
;
return
;
}
ASSERT
(
index
<
mState
.
mExecutable
-
>
getProgramInputs
(
)
.
size
(
)
)
;
const
sh
:
:
ShaderVariable
&
attrib
=
mState
.
mExecutable
-
>
getProgramInputs
(
)
[
index
]
;
if
(
bufsize
>
0
)
{
CopyStringToBuffer
(
name
attrib
.
name
bufsize
length
)
;
}
*
size
=
1
;
*
type
=
attrib
.
type
;
}
GLint
Program
:
:
getActiveAttributeCount
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
if
(
!
mLinked
)
{
return
0
;
}
return
static_cast
<
GLint
>
(
mState
.
mExecutable
-
>
getProgramInputs
(
)
.
size
(
)
)
;
}
GLint
Program
:
:
getActiveAttributeMaxLength
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
if
(
!
mLinked
)
{
return
0
;
}
size_t
maxLength
=
0
;
for
(
const
sh
:
:
ShaderVariable
&
attrib
:
mState
.
mExecutable
-
>
getProgramInputs
(
)
)
{
maxLength
=
std
:
:
max
(
attrib
.
name
.
length
(
)
+
1
maxLength
)
;
}
return
static_cast
<
GLint
>
(
maxLength
)
;
}
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
Program
:
:
getAttributes
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mState
.
mExecutable
-
>
getProgramInputs
(
)
;
}
const
sh
:
:
WorkGroupSize
&
Program
:
:
getComputeShaderLocalSize
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mState
.
mComputeShaderLocalSize
;
}
PrimitiveMode
Program
:
:
getGeometryShaderInputPrimitiveType
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mState
.
mGeometryShaderInputPrimitiveType
;
}
PrimitiveMode
Program
:
:
getGeometryShaderOutputPrimitiveType
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mState
.
mGeometryShaderOutputPrimitiveType
;
}
GLint
Program
:
:
getGeometryShaderInvocations
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mState
.
mGeometryShaderInvocations
;
}
GLint
Program
:
:
getGeometryShaderMaxVertices
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mState
.
mGeometryShaderMaxVertices
;
}
const
sh
:
:
ShaderVariable
&
Program
:
:
getInputResource
(
size_t
index
)
const
{
ASSERT
(
!
mLinkingState
)
;
ASSERT
(
index
<
mState
.
mExecutable
-
>
getProgramInputs
(
)
.
size
(
)
)
;
return
mState
.
mExecutable
-
>
getProgramInputs
(
)
[
index
]
;
}
GLuint
Program
:
:
getInputResourceIndex
(
const
GLchar
*
name
)
const
{
ASSERT
(
!
mLinkingState
)
;
const
std
:
:
string
nameString
=
StripLastArrayIndex
(
name
)
;
for
(
size_t
index
=
0
;
index
<
mState
.
mExecutable
-
>
getProgramInputs
(
)
.
size
(
)
;
index
+
+
)
{
sh
:
:
ShaderVariable
resource
=
getInputResource
(
index
)
;
if
(
resource
.
name
=
=
nameString
)
{
return
static_cast
<
GLuint
>
(
index
)
;
}
}
return
GL_INVALID_INDEX
;
}
GLuint
Program
:
:
getResourceMaxNameSize
(
const
sh
:
:
ShaderVariable
&
resource
GLint
max
)
const
{
if
(
resource
.
isArray
(
)
)
{
return
std
:
:
max
(
max
clampCast
<
GLint
>
(
(
resource
.
name
+
"
[
0
]
"
)
.
size
(
)
)
)
;
}
else
{
return
std
:
:
max
(
max
clampCast
<
GLint
>
(
(
resource
.
name
)
.
size
(
)
)
)
;
}
}
GLuint
Program
:
:
getInputResourceMaxNameSize
(
)
const
{
GLint
max
=
0
;
for
(
const
sh
:
:
ShaderVariable
&
resource
:
mState
.
mExecutable
-
>
getProgramInputs
(
)
)
{
max
=
getResourceMaxNameSize
(
resource
max
)
;
}
return
max
;
}
GLuint
Program
:
:
getOutputResourceMaxNameSize
(
)
const
{
GLint
max
=
0
;
for
(
const
sh
:
:
ShaderVariable
&
resource
:
mState
.
mExecutable
-
>
getOutputVariables
(
)
)
{
max
=
getResourceMaxNameSize
(
resource
max
)
;
}
return
max
;
}
GLuint
Program
:
:
getResourceLocation
(
const
GLchar
*
name
const
sh
:
:
ShaderVariable
&
variable
)
const
{
if
(
variable
.
isBuiltIn
(
)
)
{
return
GL_INVALID_INDEX
;
}
GLint
location
=
variable
.
location
;
if
(
variable
.
isArray
(
)
)
{
size_t
nameLengthWithoutArrayIndexOut
;
size_t
arrayIndex
=
ParseArrayIndex
(
name
&
nameLengthWithoutArrayIndexOut
)
;
if
(
arrayIndex
!
=
GL_INVALID_INDEX
)
{
location
+
=
arrayIndex
;
}
}
return
location
;
}
GLuint
Program
:
:
getInputResourceLocation
(
const
GLchar
*
name
)
const
{
const
GLuint
index
=
getInputResourceIndex
(
name
)
;
if
(
index
=
=
GL_INVALID_INDEX
)
{
return
index
;
}
const
sh
:
:
ShaderVariable
&
variable
=
getInputResource
(
index
)
;
return
getResourceLocation
(
name
variable
)
;
}
GLuint
Program
:
:
getOutputResourceLocation
(
const
GLchar
*
name
)
const
{
const
GLuint
index
=
getOutputResourceIndex
(
name
)
;
if
(
index
=
=
GL_INVALID_INDEX
)
{
return
index
;
}
const
sh
:
:
ShaderVariable
&
variable
=
getOutputResource
(
index
)
;
return
getResourceLocation
(
name
variable
)
;
}
GLuint
Program
:
:
getOutputResourceIndex
(
const
GLchar
*
name
)
const
{
ASSERT
(
!
mLinkingState
)
;
const
std
:
:
string
nameString
=
StripLastArrayIndex
(
name
)
;
for
(
size_t
index
=
0
;
index
<
mState
.
mExecutable
-
>
getOutputVariables
(
)
.
size
(
)
;
index
+
+
)
{
sh
:
:
ShaderVariable
resource
=
getOutputResource
(
index
)
;
if
(
resource
.
name
=
=
nameString
)
{
return
static_cast
<
GLuint
>
(
index
)
;
}
}
return
GL_INVALID_INDEX
;
}
size_t
Program
:
:
getOutputResourceCount
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
(
mLinked
?
mState
.
mExecutable
-
>
getOutputVariables
(
)
.
size
(
)
:
0
)
;
}
const
std
:
:
vector
<
GLenum
>
&
Program
:
:
getOutputVariableTypes
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mState
.
mOutputVariableTypes
;
}
void
Program
:
:
getResourceName
(
const
std
:
:
string
name
GLsizei
bufSize
GLsizei
*
length
GLchar
*
dest
)
const
{
if
(
length
)
{
*
length
=
0
;
}
if
(
!
mLinked
)
{
if
(
bufSize
>
0
)
{
dest
[
0
]
=
'
\
0
'
;
}
return
;
}
if
(
bufSize
>
0
)
{
CopyStringToBuffer
(
dest
name
bufSize
length
)
;
}
}
void
Program
:
:
getInputResourceName
(
GLuint
index
GLsizei
bufSize
GLsizei
*
length
GLchar
*
name
)
const
{
ASSERT
(
!
mLinkingState
)
;
getResourceName
(
getInputResourceName
(
index
)
bufSize
length
name
)
;
}
void
Program
:
:
getOutputResourceName
(
GLuint
index
GLsizei
bufSize
GLsizei
*
length
GLchar
*
name
)
const
{
ASSERT
(
!
mLinkingState
)
;
getResourceName
(
getOutputResourceName
(
index
)
bufSize
length
name
)
;
}
void
Program
:
:
getUniformResourceName
(
GLuint
index
GLsizei
bufSize
GLsizei
*
length
GLchar
*
name
)
const
{
ASSERT
(
!
mLinkingState
)
;
ASSERT
(
index
<
mState
.
mExecutable
-
>
getUniforms
(
)
.
size
(
)
)
;
getResourceName
(
mState
.
mExecutable
-
>
getUniforms
(
)
[
index
]
.
name
bufSize
length
name
)
;
}
void
Program
:
:
getBufferVariableResourceName
(
GLuint
index
GLsizei
bufSize
GLsizei
*
length
GLchar
*
name
)
const
{
ASSERT
(
!
mLinkingState
)
;
ASSERT
(
index
<
mState
.
mBufferVariables
.
size
(
)
)
;
getResourceName
(
mState
.
mBufferVariables
[
index
]
.
name
bufSize
length
name
)
;
}
const
std
:
:
string
Program
:
:
getResourceName
(
const
sh
:
:
ShaderVariable
&
resource
)
const
{
std
:
:
string
resourceName
=
resource
.
name
;
if
(
resource
.
isArray
(
)
)
{
resourceName
+
=
"
[
0
]
"
;
}
return
resourceName
;
}
const
std
:
:
string
Program
:
:
getInputResourceName
(
GLuint
index
)
const
{
ASSERT
(
!
mLinkingState
)
;
const
sh
:
:
ShaderVariable
&
resource
=
getInputResource
(
index
)
;
return
getResourceName
(
resource
)
;
}
const
std
:
:
string
Program
:
:
getOutputResourceName
(
GLuint
index
)
const
{
ASSERT
(
!
mLinkingState
)
;
const
sh
:
:
ShaderVariable
&
resource
=
getOutputResource
(
index
)
;
return
getResourceName
(
resource
)
;
}
const
sh
:
:
ShaderVariable
&
Program
:
:
getOutputResource
(
size_t
index
)
const
{
ASSERT
(
!
mLinkingState
)
;
ASSERT
(
index
<
mState
.
mExecutable
-
>
getOutputVariables
(
)
.
size
(
)
)
;
return
mState
.
mExecutable
-
>
getOutputVariables
(
)
[
index
]
;
}
const
ProgramBindings
&
Program
:
:
getAttributeBindings
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mAttributeBindings
;
}
const
ProgramAliasedBindings
&
Program
:
:
getUniformLocationBindings
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mState
.
mUniformLocationBindings
;
}
const
gl
:
:
ProgramAliasedBindings
&
Program
:
:
getFragmentOutputLocations
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mFragmentOutputLocations
;
}
const
gl
:
:
ProgramAliasedBindings
&
Program
:
:
getFragmentOutputIndexes
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mFragmentOutputIndexes
;
}
ComponentTypeMask
Program
:
:
getDrawBufferTypeMask
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mState
.
mDrawBufferTypeMask
;
}
const
std
:
:
vector
<
GLsizei
>
&
Program
:
:
getTransformFeedbackStrides
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mState
.
mExecutable
-
>
getTransformFeedbackStrides
(
)
;
}
GLint
Program
:
:
getFragDataLocation
(
const
std
:
:
string
&
name
)
const
{
ASSERT
(
!
mLinkingState
)
;
GLint
primaryLocation
=
GetVariableLocation
(
mState
.
mExecutable
-
>
getOutputVariables
(
)
mState
.
mExecutable
-
>
getOutputLocations
(
)
name
)
;
if
(
primaryLocation
!
=
-
1
)
{
return
primaryLocation
;
}
return
GetVariableLocation
(
mState
.
mExecutable
-
>
getOutputVariables
(
)
mState
.
mSecondaryOutputLocations
name
)
;
}
GLint
Program
:
:
getFragDataIndex
(
const
std
:
:
string
&
name
)
const
{
ASSERT
(
!
mLinkingState
)
;
if
(
GetVariableLocation
(
mState
.
mExecutable
-
>
getOutputVariables
(
)
mState
.
mExecutable
-
>
getOutputLocations
(
)
name
)
!
=
-
1
)
{
return
0
;
}
if
(
GetVariableLocation
(
mState
.
mExecutable
-
>
getOutputVariables
(
)
mState
.
mSecondaryOutputLocations
name
)
!
=
-
1
)
{
return
1
;
}
return
-
1
;
}
void
Program
:
:
getActiveUniform
(
GLuint
index
GLsizei
bufsize
GLsizei
*
length
GLint
*
size
GLenum
*
type
GLchar
*
name
)
const
{
ASSERT
(
!
mLinkingState
)
;
if
(
mLinked
)
{
ASSERT
(
index
<
mState
.
mExecutable
-
>
getUniforms
(
)
.
size
(
)
)
;
const
LinkedUniform
&
uniform
=
mState
.
mExecutable
-
>
getUniforms
(
)
[
index
]
;
if
(
bufsize
>
0
)
{
std
:
:
string
string
=
uniform
.
name
;
CopyStringToBuffer
(
name
string
bufsize
length
)
;
}
*
size
=
clampCast
<
GLint
>
(
uniform
.
getBasicTypeElementCount
(
)
)
;
*
type
=
uniform
.
type
;
}
else
{
if
(
bufsize
>
0
)
{
name
[
0
]
=
'
\
0
'
;
}
if
(
length
)
{
*
length
=
0
;
}
*
size
=
0
;
*
type
=
GL_NONE
;
}
}
GLint
Program
:
:
getActiveUniformCount
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
if
(
mLinked
)
{
return
static_cast
<
GLint
>
(
mState
.
mExecutable
-
>
getUniforms
(
)
.
size
(
)
)
;
}
else
{
return
0
;
}
}
size_t
Program
:
:
getActiveBufferVariableCount
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mLinked
?
mState
.
mBufferVariables
.
size
(
)
:
0
;
}
GLint
Program
:
:
getActiveUniformMaxLength
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
size_t
maxLength
=
0
;
if
(
mLinked
)
{
for
(
const
LinkedUniform
&
uniform
:
mState
.
mExecutable
-
>
getUniforms
(
)
)
{
if
(
!
uniform
.
name
.
empty
(
)
)
{
size_t
length
=
uniform
.
name
.
length
(
)
+
1u
;
if
(
uniform
.
isArray
(
)
)
{
length
+
=
3
;
}
maxLength
=
std
:
:
max
(
length
maxLength
)
;
}
}
}
return
static_cast
<
GLint
>
(
maxLength
)
;
}
bool
Program
:
:
isValidUniformLocation
(
UniformLocation
location
)
const
{
ASSERT
(
!
mLinkingState
)
;
ASSERT
(
angle
:
:
IsValueInRangeForNumericType
<
GLint
>
(
mState
.
mUniformLocations
.
size
(
)
)
)
;
return
(
location
.
value
>
=
0
&
&
static_cast
<
size_t
>
(
location
.
value
)
<
mState
.
mUniformLocations
.
size
(
)
&
&
mState
.
mUniformLocations
[
static_cast
<
size_t
>
(
location
.
value
)
]
.
used
(
)
)
;
}
const
LinkedUniform
&
Program
:
:
getUniformByLocation
(
UniformLocation
location
)
const
{
ASSERT
(
!
mLinkingState
)
;
ASSERT
(
location
.
value
>
=
0
&
&
static_cast
<
size_t
>
(
location
.
value
)
<
mState
.
mUniformLocations
.
size
(
)
)
;
return
mState
.
mExecutable
-
>
getUniforms
(
)
[
mState
.
getUniformIndexFromLocation
(
location
)
]
;
}
const
VariableLocation
&
Program
:
:
getUniformLocation
(
UniformLocation
location
)
const
{
ASSERT
(
!
mLinkingState
)
;
ASSERT
(
location
.
value
>
=
0
&
&
static_cast
<
size_t
>
(
location
.
value
)
<
mState
.
mUniformLocations
.
size
(
)
)
;
return
mState
.
mUniformLocations
[
location
.
value
]
;
}
const
BufferVariable
&
Program
:
:
getBufferVariableByIndex
(
GLuint
index
)
const
{
ASSERT
(
!
mLinkingState
)
;
ASSERT
(
index
<
static_cast
<
size_t
>
(
mState
.
mBufferVariables
.
size
(
)
)
)
;
return
mState
.
mBufferVariables
[
index
]
;
}
UniformLocation
Program
:
:
getUniformLocation
(
const
std
:
:
string
&
name
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
{
GetVariableLocation
(
mState
.
mExecutable
-
>
getUniforms
(
)
mState
.
mUniformLocations
name
)
}
;
}
GLuint
Program
:
:
getUniformIndex
(
const
std
:
:
string
&
name
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mState
.
getUniformIndexFromName
(
name
)
;
}
bool
Program
:
:
shouldIgnoreUniform
(
UniformLocation
location
)
const
{
if
(
location
.
value
=
=
-
1
)
{
return
true
;
}
if
(
mState
.
mUniformLocations
[
static_cast
<
size_t
>
(
location
.
value
)
]
.
ignored
)
{
return
true
;
}
return
false
;
}
void
Program
:
:
setUniform1fv
(
UniformLocation
location
GLsizei
count
const
GLfloat
*
v
)
{
ASSERT
(
!
mLinkingState
)
;
if
(
shouldIgnoreUniform
(
location
)
)
{
return
;
}
const
VariableLocation
&
locationInfo
=
mState
.
mUniformLocations
[
location
.
value
]
;
GLsizei
clampedCount
=
clampUniformCount
(
locationInfo
count
1
v
)
;
mProgram
-
>
setUniform1fv
(
location
.
value
clampedCount
v
)
;
}
void
Program
:
:
setUniform2fv
(
UniformLocation
location
GLsizei
count
const
GLfloat
*
v
)
{
ASSERT
(
!
mLinkingState
)
;
if
(
shouldIgnoreUniform
(
location
)
)
{
return
;
}
const
VariableLocation
&
locationInfo
=
mState
.
mUniformLocations
[
location
.
value
]
;
GLsizei
clampedCount
=
clampUniformCount
(
locationInfo
count
2
v
)
;
mProgram
-
>
setUniform2fv
(
location
.
value
clampedCount
v
)
;
}
void
Program
:
:
setUniform3fv
(
UniformLocation
location
GLsizei
count
const
GLfloat
*
v
)
{
ASSERT
(
!
mLinkingState
)
;
if
(
shouldIgnoreUniform
(
location
)
)
{
return
;
}
const
VariableLocation
&
locationInfo
=
mState
.
mUniformLocations
[
location
.
value
]
;
GLsizei
clampedCount
=
clampUniformCount
(
locationInfo
count
3
v
)
;
mProgram
-
>
setUniform3fv
(
location
.
value
clampedCount
v
)
;
}
void
Program
:
:
setUniform4fv
(
UniformLocation
location
GLsizei
count
const
GLfloat
*
v
)
{
ASSERT
(
!
mLinkingState
)
;
if
(
shouldIgnoreUniform
(
location
)
)
{
return
;
}
const
VariableLocation
&
locationInfo
=
mState
.
mUniformLocations
[
location
.
value
]
;
GLsizei
clampedCount
=
clampUniformCount
(
locationInfo
count
4
v
)
;
mProgram
-
>
setUniform4fv
(
location
.
value
clampedCount
v
)
;
}
void
Program
:
:
setUniform1iv
(
Context
*
context
UniformLocation
location
GLsizei
count
const
GLint
*
v
)
{
ASSERT
(
!
mLinkingState
)
;
if
(
shouldIgnoreUniform
(
location
)
)
{
return
;
}
const
VariableLocation
&
locationInfo
=
mState
.
mUniformLocations
[
location
.
value
]
;
GLsizei
clampedCount
=
clampUniformCount
(
locationInfo
count
1
v
)
;
mProgram
-
>
setUniform1iv
(
location
.
value
clampedCount
v
)
;
if
(
mState
.
isSamplerUniformIndex
(
locationInfo
.
index
)
)
{
updateSamplerUniform
(
context
locationInfo
clampedCount
v
)
;
}
}
void
Program
:
:
setUniform2iv
(
UniformLocation
location
GLsizei
count
const
GLint
*
v
)
{
ASSERT
(
!
mLinkingState
)
;
if
(
shouldIgnoreUniform
(
location
)
)
{
return
;
}
const
VariableLocation
&
locationInfo
=
mState
.
mUniformLocations
[
location
.
value
]
;
GLsizei
clampedCount
=
clampUniformCount
(
locationInfo
count
2
v
)
;
mProgram
-
>
setUniform2iv
(
location
.
value
clampedCount
v
)
;
}
void
Program
:
:
setUniform3iv
(
UniformLocation
location
GLsizei
count
const
GLint
*
v
)
{
ASSERT
(
!
mLinkingState
)
;
if
(
shouldIgnoreUniform
(
location
)
)
{
return
;
}
const
VariableLocation
&
locationInfo
=
mState
.
mUniformLocations
[
location
.
value
]
;
GLsizei
clampedCount
=
clampUniformCount
(
locationInfo
count
3
v
)
;
mProgram
-
>
setUniform3iv
(
location
.
value
clampedCount
v
)
;
}
void
Program
:
:
setUniform4iv
(
UniformLocation
location
GLsizei
count
const
GLint
*
v
)
{
ASSERT
(
!
mLinkingState
)
;
if
(
shouldIgnoreUniform
(
location
)
)
{
return
;
}
const
VariableLocation
&
locationInfo
=
mState
.
mUniformLocations
[
location
.
value
]
;
GLsizei
clampedCount
=
clampUniformCount
(
locationInfo
count
4
v
)
;
mProgram
-
>
setUniform4iv
(
location
.
value
clampedCount
v
)
;
}
void
Program
:
:
setUniform1uiv
(
UniformLocation
location
GLsizei
count
const
GLuint
*
v
)
{
ASSERT
(
!
mLinkingState
)
;
if
(
shouldIgnoreUniform
(
location
)
)
{
return
;
}
const
VariableLocation
&
locationInfo
=
mState
.
mUniformLocations
[
location
.
value
]
;
GLsizei
clampedCount
=
clampUniformCount
(
locationInfo
count
1
v
)
;
mProgram
-
>
setUniform1uiv
(
location
.
value
clampedCount
v
)
;
}
void
Program
:
:
setUniform2uiv
(
UniformLocation
location
GLsizei
count
const
GLuint
*
v
)
{
ASSERT
(
!
mLinkingState
)
;
if
(
shouldIgnoreUniform
(
location
)
)
{
return
;
}
const
VariableLocation
&
locationInfo
=
mState
.
mUniformLocations
[
location
.
value
]
;
GLsizei
clampedCount
=
clampUniformCount
(
locationInfo
count
2
v
)
;
mProgram
-
>
setUniform2uiv
(
location
.
value
clampedCount
v
)
;
}
void
Program
:
:
setUniform3uiv
(
UniformLocation
location
GLsizei
count
const
GLuint
*
v
)
{
ASSERT
(
!
mLinkingState
)
;
if
(
shouldIgnoreUniform
(
location
)
)
{
return
;
}
const
VariableLocation
&
locationInfo
=
mState
.
mUniformLocations
[
location
.
value
]
;
GLsizei
clampedCount
=
clampUniformCount
(
locationInfo
count
3
v
)
;
mProgram
-
>
setUniform3uiv
(
location
.
value
clampedCount
v
)
;
}
void
Program
:
:
setUniform4uiv
(
UniformLocation
location
GLsizei
count
const
GLuint
*
v
)
{
ASSERT
(
!
mLinkingState
)
;
if
(
shouldIgnoreUniform
(
location
)
)
{
return
;
}
const
VariableLocation
&
locationInfo
=
mState
.
mUniformLocations
[
location
.
value
]
;
GLsizei
clampedCount
=
clampUniformCount
(
locationInfo
count
4
v
)
;
mProgram
-
>
setUniform4uiv
(
location
.
value
clampedCount
v
)
;
}
void
Program
:
:
setUniformMatrix2fv
(
UniformLocation
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
v
)
{
ASSERT
(
!
mLinkingState
)
;
if
(
shouldIgnoreUniform
(
location
)
)
{
return
;
}
GLsizei
clampedCount
=
clampMatrixUniformCount
<
2
2
>
(
location
count
transpose
v
)
;
mProgram
-
>
setUniformMatrix2fv
(
location
.
value
clampedCount
transpose
v
)
;
}
void
Program
:
:
setUniformMatrix3fv
(
UniformLocation
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
v
)
{
ASSERT
(
!
mLinkingState
)
;
if
(
shouldIgnoreUniform
(
location
)
)
{
return
;
}
GLsizei
clampedCount
=
clampMatrixUniformCount
<
3
3
>
(
location
count
transpose
v
)
;
mProgram
-
>
setUniformMatrix3fv
(
location
.
value
clampedCount
transpose
v
)
;
}
void
Program
:
:
setUniformMatrix4fv
(
UniformLocation
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
v
)
{
ASSERT
(
!
mLinkingState
)
;
if
(
shouldIgnoreUniform
(
location
)
)
{
return
;
}
GLsizei
clampedCount
=
clampMatrixUniformCount
<
4
4
>
(
location
count
transpose
v
)
;
mProgram
-
>
setUniformMatrix4fv
(
location
.
value
clampedCount
transpose
v
)
;
}
void
Program
:
:
setUniformMatrix2x3fv
(
UniformLocation
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
v
)
{
ASSERT
(
!
mLinkingState
)
;
if
(
shouldIgnoreUniform
(
location
)
)
{
return
;
}
GLsizei
clampedCount
=
clampMatrixUniformCount
<
2
3
>
(
location
count
transpose
v
)
;
mProgram
-
>
setUniformMatrix2x3fv
(
location
.
value
clampedCount
transpose
v
)
;
}
void
Program
:
:
setUniformMatrix2x4fv
(
UniformLocation
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
v
)
{
ASSERT
(
!
mLinkingState
)
;
if
(
shouldIgnoreUniform
(
location
)
)
{
return
;
}
GLsizei
clampedCount
=
clampMatrixUniformCount
<
2
4
>
(
location
count
transpose
v
)
;
mProgram
-
>
setUniformMatrix2x4fv
(
location
.
value
clampedCount
transpose
v
)
;
}
void
Program
:
:
setUniformMatrix3x2fv
(
UniformLocation
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
v
)
{
ASSERT
(
!
mLinkingState
)
;
if
(
shouldIgnoreUniform
(
location
)
)
{
return
;
}
GLsizei
clampedCount
=
clampMatrixUniformCount
<
3
2
>
(
location
count
transpose
v
)
;
mProgram
-
>
setUniformMatrix3x2fv
(
location
.
value
clampedCount
transpose
v
)
;
}
void
Program
:
:
setUniformMatrix3x4fv
(
UniformLocation
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
v
)
{
ASSERT
(
!
mLinkingState
)
;
if
(
shouldIgnoreUniform
(
location
)
)
{
return
;
}
GLsizei
clampedCount
=
clampMatrixUniformCount
<
3
4
>
(
location
count
transpose
v
)
;
mProgram
-
>
setUniformMatrix3x4fv
(
location
.
value
clampedCount
transpose
v
)
;
}
void
Program
:
:
setUniformMatrix4x2fv
(
UniformLocation
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
v
)
{
ASSERT
(
!
mLinkingState
)
;
if
(
shouldIgnoreUniform
(
location
)
)
{
return
;
}
GLsizei
clampedCount
=
clampMatrixUniformCount
<
4
2
>
(
location
count
transpose
v
)
;
mProgram
-
>
setUniformMatrix4x2fv
(
location
.
value
clampedCount
transpose
v
)
;
}
void
Program
:
:
setUniformMatrix4x3fv
(
UniformLocation
location
GLsizei
count
GLboolean
transpose
const
GLfloat
*
v
)
{
ASSERT
(
!
mLinkingState
)
;
if
(
shouldIgnoreUniform
(
location
)
)
{
return
;
}
GLsizei
clampedCount
=
clampMatrixUniformCount
<
4
3
>
(
location
count
transpose
v
)
;
mProgram
-
>
setUniformMatrix4x3fv
(
location
.
value
clampedCount
transpose
v
)
;
}
GLuint
Program
:
:
getSamplerUniformBinding
(
const
VariableLocation
&
uniformLocation
)
const
{
ASSERT
(
!
mLinkingState
)
;
GLuint
samplerIndex
=
mState
.
getSamplerIndexFromUniformIndex
(
uniformLocation
.
index
)
;
const
std
:
:
vector
<
GLuint
>
&
boundTextureUnits
=
mState
.
mExecutable
-
>
mSamplerBindings
[
samplerIndex
]
.
boundTextureUnits
;
return
(
uniformLocation
.
arrayIndex
<
boundTextureUnits
.
size
(
)
)
?
boundTextureUnits
[
uniformLocation
.
arrayIndex
]
:
0
;
}
GLuint
Program
:
:
getImageUniformBinding
(
const
VariableLocation
&
uniformLocation
)
const
{
ASSERT
(
!
mLinkingState
)
;
GLuint
imageIndex
=
mState
.
getImageIndexFromUniformIndex
(
uniformLocation
.
index
)
;
const
std
:
:
vector
<
ImageBinding
>
&
imageBindings
=
getExecutable
(
)
.
getImageBindings
(
)
;
const
std
:
:
vector
<
GLuint
>
&
boundImageUnits
=
imageBindings
[
imageIndex
]
.
boundImageUnits
;
return
boundImageUnits
[
uniformLocation
.
arrayIndex
]
;
}
void
Program
:
:
getUniformfv
(
const
Context
*
context
UniformLocation
location
GLfloat
*
v
)
const
{
ASSERT
(
!
mLinkingState
)
;
const
VariableLocation
&
uniformLocation
=
mState
.
getUniformLocations
(
)
[
location
.
value
]
;
const
LinkedUniform
&
uniform
=
mState
.
getUniforms
(
)
[
uniformLocation
.
index
]
;
if
(
uniform
.
isSampler
(
)
)
{
*
v
=
static_cast
<
GLfloat
>
(
getSamplerUniformBinding
(
uniformLocation
)
)
;
return
;
}
else
if
(
uniform
.
isImage
(
)
)
{
*
v
=
static_cast
<
GLfloat
>
(
getImageUniformBinding
(
uniformLocation
)
)
;
return
;
}
const
GLenum
nativeType
=
gl
:
:
VariableComponentType
(
uniform
.
type
)
;
if
(
nativeType
=
=
GL_FLOAT
)
{
mProgram
-
>
getUniformfv
(
context
location
.
value
v
)
;
}
else
{
getUniformInternal
(
context
v
location
nativeType
VariableComponentCount
(
uniform
.
type
)
)
;
}
}
void
Program
:
:
getUniformiv
(
const
Context
*
context
UniformLocation
location
GLint
*
v
)
const
{
ASSERT
(
!
mLinkingState
)
;
const
VariableLocation
&
uniformLocation
=
mState
.
getUniformLocations
(
)
[
location
.
value
]
;
const
LinkedUniform
&
uniform
=
mState
.
getUniforms
(
)
[
uniformLocation
.
index
]
;
if
(
uniform
.
isSampler
(
)
)
{
*
v
=
static_cast
<
GLint
>
(
getSamplerUniformBinding
(
uniformLocation
)
)
;
return
;
}
else
if
(
uniform
.
isImage
(
)
)
{
*
v
=
static_cast
<
GLint
>
(
getImageUniformBinding
(
uniformLocation
)
)
;
return
;
}
const
GLenum
nativeType
=
gl
:
:
VariableComponentType
(
uniform
.
type
)
;
if
(
nativeType
=
=
GL_INT
|
|
nativeType
=
=
GL_BOOL
)
{
mProgram
-
>
getUniformiv
(
context
location
.
value
v
)
;
}
else
{
getUniformInternal
(
context
v
location
nativeType
VariableComponentCount
(
uniform
.
type
)
)
;
}
}
void
Program
:
:
getUniformuiv
(
const
Context
*
context
UniformLocation
location
GLuint
*
v
)
const
{
ASSERT
(
!
mLinkingState
)
;
const
VariableLocation
&
uniformLocation
=
mState
.
getUniformLocations
(
)
[
location
.
value
]
;
const
LinkedUniform
&
uniform
=
mState
.
getUniforms
(
)
[
uniformLocation
.
index
]
;
if
(
uniform
.
isSampler
(
)
)
{
*
v
=
getSamplerUniformBinding
(
uniformLocation
)
;
return
;
}
else
if
(
uniform
.
isImage
(
)
)
{
*
v
=
getImageUniformBinding
(
uniformLocation
)
;
return
;
}
const
GLenum
nativeType
=
VariableComponentType
(
uniform
.
type
)
;
if
(
nativeType
=
=
GL_UNSIGNED_INT
)
{
mProgram
-
>
getUniformuiv
(
context
location
.
value
v
)
;
}
else
{
getUniformInternal
(
context
v
location
nativeType
VariableComponentCount
(
uniform
.
type
)
)
;
}
}
void
Program
:
:
flagForDeletion
(
)
{
ASSERT
(
!
mLinkingState
)
;
mDeleteStatus
=
true
;
}
bool
Program
:
:
isFlaggedForDeletion
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mDeleteStatus
;
}
void
Program
:
:
validate
(
const
Caps
&
caps
)
{
ASSERT
(
!
mLinkingState
)
;
mState
.
mExecutable
-
>
resetInfoLog
(
)
;
InfoLog
&
infoLog
=
mState
.
mExecutable
-
>
getInfoLog
(
)
;
if
(
mLinked
)
{
mValidated
=
ConvertToBool
(
mProgram
-
>
validate
(
caps
&
infoLog
)
)
;
}
else
{
infoLog
<
<
"
Program
has
not
been
successfully
linked
.
"
;
}
}
bool
Program
:
:
validateSamplersImpl
(
InfoLog
*
infoLog
const
Caps
&
caps
)
{
const
ProgramExecutable
*
executable
=
mState
.
mExecutable
.
get
(
)
;
ASSERT
(
!
mLinkingState
)
;
for
(
size_t
textureUnit
:
executable
-
>
mActiveSamplersMask
)
{
if
(
executable
-
>
mActiveSamplerTypes
[
textureUnit
]
=
=
TextureType
:
:
InvalidEnum
)
{
if
(
infoLog
)
{
(
*
infoLog
)
<
<
"
Samplers
of
conflicting
types
refer
to
the
same
texture
"
"
image
unit
(
"
<
<
textureUnit
<
<
"
)
.
"
;
}
mCachedValidateSamplersResult
=
false
;
return
false
;
}
}
mCachedValidateSamplersResult
=
true
;
return
true
;
}
bool
Program
:
:
isValidated
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mValidated
;
}
void
Program
:
:
getActiveUniformBlockName
(
const
GLuint
blockIndex
GLsizei
bufSize
GLsizei
*
length
GLchar
*
blockName
)
const
{
ASSERT
(
!
mLinkingState
)
;
GetInterfaceBlockName
(
blockIndex
mState
.
mExecutable
-
>
getUniformBlocks
(
)
bufSize
length
blockName
)
;
}
void
Program
:
:
getActiveShaderStorageBlockName
(
const
GLuint
blockIndex
GLsizei
bufSize
GLsizei
*
length
GLchar
*
blockName
)
const
{
ASSERT
(
!
mLinkingState
)
;
GetInterfaceBlockName
(
blockIndex
mState
.
mExecutable
-
>
getShaderStorageBlocks
(
)
bufSize
length
blockName
)
;
}
template
<
typename
T
>
GLint
Program
:
:
getActiveInterfaceBlockMaxNameLength
(
const
std
:
:
vector
<
T
>
&
resources
)
const
{
int
maxLength
=
0
;
if
(
mLinked
)
{
for
(
const
T
&
resource
:
resources
)
{
if
(
!
resource
.
name
.
empty
(
)
)
{
int
length
=
static_cast
<
int
>
(
resource
.
nameWithArrayIndex
(
)
.
length
(
)
)
;
maxLength
=
std
:
:
max
(
length
+
1
maxLength
)
;
}
}
}
return
maxLength
;
}
GLint
Program
:
:
getActiveUniformBlockMaxNameLength
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
getActiveInterfaceBlockMaxNameLength
(
mState
.
mExecutable
-
>
getUniformBlocks
(
)
)
;
}
GLint
Program
:
:
getActiveShaderStorageBlockMaxNameLength
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
getActiveInterfaceBlockMaxNameLength
(
mState
.
mExecutable
-
>
getShaderStorageBlocks
(
)
)
;
}
GLuint
Program
:
:
getUniformBlockIndex
(
const
std
:
:
string
&
name
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
GetInterfaceBlockIndex
(
mState
.
mExecutable
-
>
getUniformBlocks
(
)
name
)
;
}
GLuint
Program
:
:
getShaderStorageBlockIndex
(
const
std
:
:
string
&
name
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
GetInterfaceBlockIndex
(
mState
.
mExecutable
-
>
getShaderStorageBlocks
(
)
name
)
;
}
const
InterfaceBlock
&
Program
:
:
getUniformBlockByIndex
(
GLuint
index
)
const
{
ASSERT
(
!
mLinkingState
)
;
ASSERT
(
index
<
static_cast
<
GLuint
>
(
mState
.
mExecutable
-
>
getActiveUniformBlockCount
(
)
)
)
;
return
mState
.
mExecutable
-
>
getUniformBlocks
(
)
[
index
]
;
}
const
InterfaceBlock
&
Program
:
:
getShaderStorageBlockByIndex
(
GLuint
index
)
const
{
ASSERT
(
!
mLinkingState
)
;
ASSERT
(
index
<
static_cast
<
GLuint
>
(
mState
.
mExecutable
-
>
getActiveShaderStorageBlockCount
(
)
)
)
;
return
mState
.
mExecutable
-
>
getShaderStorageBlocks
(
)
[
index
]
;
}
void
Program
:
:
bindUniformBlock
(
GLuint
uniformBlockIndex
GLuint
uniformBlockBinding
)
{
ASSERT
(
!
mLinkingState
)
;
mState
.
mExecutable
-
>
mUniformBlocks
[
uniformBlockIndex
]
.
binding
=
uniformBlockBinding
;
mState
.
mActiveUniformBlockBindings
.
set
(
uniformBlockIndex
uniformBlockBinding
!
=
0
)
;
mDirtyBits
.
set
(
DIRTY_BIT_UNIFORM_BLOCK_BINDING_0
+
uniformBlockIndex
)
;
}
GLuint
Program
:
:
getUniformBlockBinding
(
GLuint
uniformBlockIndex
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mState
.
getUniformBlockBinding
(
uniformBlockIndex
)
;
}
GLuint
Program
:
:
getShaderStorageBlockBinding
(
GLuint
shaderStorageBlockIndex
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mState
.
getShaderStorageBlockBinding
(
shaderStorageBlockIndex
)
;
}
void
Program
:
:
setTransformFeedbackVaryings
(
GLsizei
count
const
GLchar
*
const
*
varyings
GLenum
bufferMode
)
{
ASSERT
(
!
mLinkingState
)
;
mState
.
mTransformFeedbackVaryingNames
.
resize
(
count
)
;
for
(
GLsizei
i
=
0
;
i
<
count
;
i
+
+
)
{
mState
.
mTransformFeedbackVaryingNames
[
i
]
=
varyings
[
i
]
;
}
mState
.
mExecutable
-
>
mTransformFeedbackBufferMode
=
bufferMode
;
}
void
Program
:
:
getTransformFeedbackVarying
(
GLuint
index
GLsizei
bufSize
GLsizei
*
length
GLsizei
*
size
GLenum
*
type
GLchar
*
name
)
const
{
ASSERT
(
!
mLinkingState
)
;
if
(
mLinked
)
{
ASSERT
(
index
<
mState
.
mExecutable
-
>
mLinkedTransformFeedbackVaryings
.
size
(
)
)
;
const
auto
&
var
=
mState
.
mExecutable
-
>
mLinkedTransformFeedbackVaryings
[
index
]
;
std
:
:
string
varName
=
var
.
nameWithArrayIndex
(
)
;
GLsizei
lastNameIdx
=
std
:
:
min
(
bufSize
-
1
static_cast
<
GLsizei
>
(
varName
.
length
(
)
)
)
;
if
(
length
)
{
*
length
=
lastNameIdx
;
}
if
(
size
)
{
*
size
=
var
.
size
(
)
;
}
if
(
type
)
{
*
type
=
var
.
type
;
}
if
(
name
)
{
memcpy
(
name
varName
.
c_str
(
)
lastNameIdx
)
;
name
[
lastNameIdx
]
=
'
\
0
'
;
}
}
}
GLsizei
Program
:
:
getTransformFeedbackVaryingCount
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
if
(
mLinked
)
{
return
static_cast
<
GLsizei
>
(
mState
.
mExecutable
-
>
mLinkedTransformFeedbackVaryings
.
size
(
)
)
;
}
else
{
return
0
;
}
}
GLsizei
Program
:
:
getTransformFeedbackVaryingMaxLength
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
if
(
mLinked
)
{
GLsizei
maxSize
=
0
;
for
(
const
auto
&
var
:
mState
.
mExecutable
-
>
mLinkedTransformFeedbackVaryings
)
{
maxSize
=
std
:
:
max
(
maxSize
static_cast
<
GLsizei
>
(
var
.
nameWithArrayIndex
(
)
.
length
(
)
+
1
)
)
;
}
return
maxSize
;
}
else
{
return
0
;
}
}
GLenum
Program
:
:
getTransformFeedbackBufferMode
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mState
.
mExecutable
-
>
getTransformFeedbackBufferMode
(
)
;
}
bool
Program
:
:
linkValidateShaders
(
InfoLog
&
infoLog
)
{
Shader
*
vertexShader
=
mState
.
mAttachedShaders
[
ShaderType
:
:
Vertex
]
;
Shader
*
fragmentShader
=
mState
.
mAttachedShaders
[
ShaderType
:
:
Fragment
]
;
Shader
*
computeShader
=
mState
.
mAttachedShaders
[
ShaderType
:
:
Compute
]
;
Shader
*
geometryShader
=
mState
.
mAttachedShaders
[
ShaderType
:
:
Geometry
]
;
bool
isComputeShaderAttached
=
(
computeShader
!
=
nullptr
)
;
bool
isGraphicsShaderAttached
=
(
vertexShader
!
=
nullptr
|
|
fragmentShader
!
=
nullptr
|
|
geometryShader
!
=
nullptr
)
;
if
(
isComputeShaderAttached
=
=
true
&
&
isGraphicsShaderAttached
=
=
true
)
{
infoLog
<
<
"
Both
compute
and
graphics
shaders
are
attached
to
the
same
program
.
"
;
return
false
;
}
if
(
computeShader
)
{
if
(
!
computeShader
-
>
isCompiled
(
)
)
{
infoLog
<
<
"
Attached
compute
shader
is
not
compiled
.
"
;
return
false
;
}
ASSERT
(
computeShader
-
>
getType
(
)
=
=
ShaderType
:
:
Compute
)
;
mState
.
mComputeShaderLocalSize
=
computeShader
-
>
getWorkGroupSize
(
)
;
if
(
!
mState
.
mComputeShaderLocalSize
.
isDeclared
(
)
)
{
infoLog
<
<
"
Work
group
size
is
not
specified
.
"
;
return
false
;
}
}
else
{
if
(
isSeparable
(
)
)
{
if
(
!
fragmentShader
&
&
!
vertexShader
)
{
infoLog
<
<
"
No
compiled
shaders
.
"
;
return
false
;
}
ASSERT
(
!
fragmentShader
|
|
fragmentShader
-
>
getType
(
)
=
=
ShaderType
:
:
Fragment
)
;
if
(
fragmentShader
&
&
!
fragmentShader
-
>
isCompiled
(
)
)
{
infoLog
<
<
"
Fragment
shader
is
not
compiled
.
"
;
return
false
;
}
ASSERT
(
!
vertexShader
|
|
vertexShader
-
>
getType
(
)
=
=
ShaderType
:
:
Vertex
)
;
if
(
vertexShader
&
&
!
vertexShader
-
>
isCompiled
(
)
)
{
infoLog
<
<
"
Vertex
shader
is
not
compiled
.
"
;
return
false
;
}
}
else
{
if
(
!
fragmentShader
|
|
!
fragmentShader
-
>
isCompiled
(
)
)
{
infoLog
<
<
"
No
compiled
fragment
shader
when
at
least
one
graphics
shader
is
attached
.
"
;
return
false
;
}
ASSERT
(
fragmentShader
-
>
getType
(
)
=
=
ShaderType
:
:
Fragment
)
;
if
(
!
vertexShader
|
|
!
vertexShader
-
>
isCompiled
(
)
)
{
infoLog
<
<
"
No
compiled
vertex
shader
when
at
least
one
graphics
shader
is
attached
.
"
;
return
false
;
}
ASSERT
(
vertexShader
-
>
getType
(
)
=
=
ShaderType
:
:
Vertex
)
;
}
if
(
vertexShader
&
&
fragmentShader
)
{
int
vertexShaderVersion
=
vertexShader
-
>
getShaderVersion
(
)
;
int
fragmentShaderVersion
=
fragmentShader
-
>
getShaderVersion
(
)
;
if
(
fragmentShaderVersion
!
=
vertexShaderVersion
)
{
infoLog
<
<
"
Fragment
shader
version
does
not
match
vertex
shader
version
.
"
;
return
false
;
}
}
if
(
geometryShader
)
{
if
(
!
geometryShader
-
>
isCompiled
(
)
)
{
infoLog
<
<
"
The
attached
geometry
shader
isn
'
t
compiled
.
"
;
return
false
;
}
if
(
vertexShader
&
&
(
geometryShader
-
>
getShaderVersion
(
)
!
=
vertexShader
-
>
getShaderVersion
(
)
)
)
{
infoLog
<
<
"
Geometry
shader
version
does
not
match
vertex
shader
version
.
"
;
return
false
;
}
ASSERT
(
geometryShader
-
>
getType
(
)
=
=
ShaderType
:
:
Geometry
)
;
Optional
<
PrimitiveMode
>
inputPrimitive
=
geometryShader
-
>
getGeometryShaderInputPrimitiveType
(
)
;
if
(
!
inputPrimitive
.
valid
(
)
)
{
infoLog
<
<
"
Input
primitive
type
is
not
specified
in
the
geometry
shader
.
"
;
return
false
;
}
Optional
<
PrimitiveMode
>
outputPrimitive
=
geometryShader
-
>
getGeometryShaderOutputPrimitiveType
(
)
;
if
(
!
outputPrimitive
.
valid
(
)
)
{
infoLog
<
<
"
Output
primitive
type
is
not
specified
in
the
geometry
shader
.
"
;
return
false
;
}
Optional
<
GLint
>
maxVertices
=
geometryShader
-
>
getGeometryShaderMaxVertices
(
)
;
if
(
!
maxVertices
.
valid
(
)
)
{
infoLog
<
<
"
'
max_vertices
'
is
not
specified
in
the
geometry
shader
.
"
;
return
false
;
}
mState
.
mGeometryShaderInputPrimitiveType
=
inputPrimitive
.
value
(
)
;
mState
.
mGeometryShaderOutputPrimitiveType
=
outputPrimitive
.
value
(
)
;
mState
.
mGeometryShaderMaxVertices
=
maxVertices
.
value
(
)
;
mState
.
mGeometryShaderInvocations
=
geometryShader
-
>
getGeometryShaderInvocations
(
)
;
}
}
return
true
;
}
GLuint
Program
:
:
getTransformFeedbackVaryingResourceIndex
(
const
GLchar
*
name
)
const
{
ASSERT
(
!
mLinkingState
)
;
for
(
GLuint
tfIndex
=
0
;
tfIndex
<
mState
.
mExecutable
-
>
mLinkedTransformFeedbackVaryings
.
size
(
)
;
+
+
tfIndex
)
{
const
auto
&
tf
=
mState
.
mExecutable
-
>
mLinkedTransformFeedbackVaryings
[
tfIndex
]
;
if
(
tf
.
nameWithArrayIndex
(
)
=
=
name
)
{
return
tfIndex
;
}
}
return
GL_INVALID_INDEX
;
}
const
TransformFeedbackVarying
&
Program
:
:
getTransformFeedbackVaryingResource
(
GLuint
index
)
const
{
ASSERT
(
!
mLinkingState
)
;
ASSERT
(
index
<
mState
.
mExecutable
-
>
mLinkedTransformFeedbackVaryings
.
size
(
)
)
;
return
mState
.
mExecutable
-
>
mLinkedTransformFeedbackVaryings
[
index
]
;
}
bool
Program
:
:
hasDrawIDUniform
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mState
.
mDrawIDLocation
>
=
0
;
}
void
Program
:
:
setDrawIDUniform
(
GLint
drawid
)
{
ASSERT
(
!
mLinkingState
)
;
ASSERT
(
mState
.
mDrawIDLocation
>
=
0
)
;
mProgram
-
>
setUniform1iv
(
mState
.
mDrawIDLocation
1
&
drawid
)
;
}
bool
Program
:
:
hasBaseVertexUniform
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mState
.
mBaseVertexLocation
>
=
0
;
}
void
Program
:
:
setBaseVertexUniform
(
GLint
baseVertex
)
{
ASSERT
(
!
mLinkingState
)
;
ASSERT
(
mState
.
mBaseVertexLocation
>
=
0
)
;
if
(
baseVertex
=
=
mState
.
mCachedBaseVertex
)
{
return
;
}
mState
.
mCachedBaseVertex
=
baseVertex
;
mProgram
-
>
setUniform1iv
(
mState
.
mBaseVertexLocation
1
&
baseVertex
)
;
}
bool
Program
:
:
hasBaseInstanceUniform
(
)
const
{
ASSERT
(
!
mLinkingState
)
;
return
mState
.
mBaseInstanceLocation
>
=
0
;
}
void
Program
:
:
setBaseInstanceUniform
(
GLuint
baseInstance
)
{
ASSERT
(
!
mLinkingState
)
;
ASSERT
(
mState
.
mBaseInstanceLocation
>
=
0
)
;
if
(
baseInstance
=
=
mState
.
mCachedBaseInstance
)
{
return
;
}
mState
.
mCachedBaseInstance
=
baseInstance
;
GLint
baseInstanceInt
=
baseInstance
;
mProgram
-
>
setUniform1iv
(
mState
.
mBaseInstanceLocation
1
&
baseInstanceInt
)
;
}
bool
Program
:
:
linkVaryings
(
InfoLog
&
infoLog
)
const
{
ShaderType
previousShaderType
=
ShaderType
:
:
InvalidEnum
;
for
(
ShaderType
shaderType
:
kAllGraphicsShaderTypes
)
{
Shader
*
currentShader
=
mState
.
mAttachedShaders
[
shaderType
]
;
if
(
!
currentShader
)
{
continue
;
}
if
(
previousShaderType
!
=
ShaderType
:
:
InvalidEnum
)
{
Shader
*
previousShader
=
mState
.
mAttachedShaders
[
previousShaderType
]
;
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
outputVaryings
=
previousShader
-
>
getOutputVaryings
(
)
;
if
(
!
linkValidateShaderInterfaceMatching
(
outputVaryings
currentShader
-
>
getInputVaryings
(
)
previousShaderType
currentShader
-
>
getType
(
)
previousShader
-
>
getShaderVersion
(
)
currentShader
-
>
getShaderVersion
(
)
isSeparable
(
)
infoLog
)
)
{
return
false
;
}
}
previousShaderType
=
currentShader
-
>
getType
(
)
;
}
Shader
*
vertexShader
=
mState
.
mAttachedShaders
[
ShaderType
:
:
Vertex
]
;
Shader
*
fragmentShader
=
mState
.
mAttachedShaders
[
ShaderType
:
:
Fragment
]
;
if
(
vertexShader
&
&
fragmentShader
&
&
!
linkValidateBuiltInVaryings
(
vertexShader
-
>
getOutputVaryings
(
)
fragmentShader
-
>
getInputVaryings
(
)
vertexShader
-
>
getShaderVersion
(
)
infoLog
)
)
{
return
false
;
}
return
true
;
}
void
Program
:
:
getFilteredVaryings
(
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
varyings
std
:
:
vector
<
const
sh
:
:
ShaderVariable
*
>
*
filteredVaryingsOut
)
{
for
(
const
sh
:
:
ShaderVariable
&
varying
:
varyings
)
{
if
(
varying
.
isBuiltIn
(
)
)
{
continue
;
}
filteredVaryingsOut
-
>
push_back
(
&
varying
)
;
}
}
bool
Program
:
:
doShaderVariablesMatch
(
int
outputShaderVersion
ShaderType
outputShaderType
ShaderType
inputShaderType
const
sh
:
:
ShaderVariable
&
input
const
sh
:
:
ShaderVariable
&
output
bool
validateGeometryShaderInputs
bool
isSeparable
gl
:
:
InfoLog
&
infoLog
)
{
bool
namesMatch
=
input
.
name
=
=
output
.
name
;
bool
locationsMatch
=
(
input
.
location
!
=
-
1
)
&
&
(
input
.
location
=
=
output
.
location
)
;
if
(
namesMatch
|
|
locationsMatch
)
{
std
:
:
string
mismatchedStructFieldName
;
LinkMismatchError
linkError
=
LinkValidateVaryings
(
output
input
outputShaderVersion
validateGeometryShaderInputs
isSeparable
&
mismatchedStructFieldName
)
;
if
(
linkError
!
=
LinkMismatchError
:
:
NO_MISMATCH
)
{
LogLinkMismatch
(
infoLog
input
.
name
"
varying
"
linkError
mismatchedStructFieldName
outputShaderType
inputShaderType
)
;
return
false
;
}
return
true
;
}
return
false
;
}
bool
Program
:
:
linkValidateShaderInterfaceMatching
(
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
outputVaryings
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
inputVaryings
ShaderType
outputShaderType
ShaderType
inputShaderType
int
outputShaderVersion
int
inputShaderVersion
bool
isSeparable
gl
:
:
InfoLog
&
infoLog
)
{
ASSERT
(
outputShaderVersion
=
=
inputShaderVersion
)
;
std
:
:
vector
<
const
sh
:
:
ShaderVariable
*
>
filteredInputVaryings
;
std
:
:
vector
<
const
sh
:
:
ShaderVariable
*
>
filteredOutputVaryings
;
bool
validateGeometryShaderInputs
=
inputShaderType
=
=
ShaderType
:
:
Geometry
;
getFilteredVaryings
(
inputVaryings
&
filteredInputVaryings
)
;
getFilteredVaryings
(
outputVaryings
&
filteredOutputVaryings
)
;
if
(
isSeparable
&
&
filteredInputVaryings
.
size
(
)
<
filteredOutputVaryings
.
size
(
)
)
{
infoLog
<
<
GetShaderTypeString
(
inputShaderType
)
<
<
"
does
not
consume
all
varyings
generated
by
"
<
<
GetShaderTypeString
(
outputShaderType
)
;
return
false
;
}
if
(
isSeparable
&
&
filteredInputVaryings
.
size
(
)
>
filteredOutputVaryings
.
size
(
)
)
{
infoLog
<
<
GetShaderTypeString
(
outputShaderType
)
<
<
"
does
not
generate
all
varyings
consumed
by
"
<
<
GetShaderTypeString
(
inputShaderType
)
;
return
false
;
}
for
(
const
sh
:
:
ShaderVariable
*
input
:
filteredInputVaryings
)
{
bool
match
=
false
;
for
(
const
sh
:
:
ShaderVariable
*
output
:
filteredOutputVaryings
)
{
if
(
doShaderVariablesMatch
(
outputShaderVersion
outputShaderType
inputShaderType
*
input
*
output
validateGeometryShaderInputs
isSeparable
infoLog
)
)
{
match
=
true
;
break
;
}
}
if
(
!
match
&
&
input
-
>
staticUse
)
{
infoLog
<
<
GetShaderTypeString
(
inputShaderType
)
<
<
"
varying
"
<
<
input
-
>
name
<
<
"
does
not
match
any
"
<
<
GetShaderTypeString
(
outputShaderType
)
<
<
"
varying
"
;
return
false
;
}
}
return
true
;
}
bool
Program
:
:
linkUniforms
(
const
Caps
&
caps
const
Version
&
version
InfoLog
&
infoLog
const
ProgramAliasedBindings
&
uniformLocationBindings
GLuint
*
combinedImageUniformsCount
std
:
:
vector
<
UnusedUniform
>
*
unusedUniforms
)
{
UniformLinker
linker
(
mState
)
;
if
(
!
linker
.
link
(
caps
infoLog
uniformLocationBindings
)
)
{
return
false
;
}
linker
.
getResults
(
&
mState
.
mExecutable
-
>
mUniforms
unusedUniforms
&
mState
.
mUniformLocations
)
;
linkSamplerAndImageBindings
(
combinedImageUniformsCount
)
;
if
(
!
linkAtomicCounterBuffers
(
)
)
{
return
false
;
}
if
(
version
>
=
Version
(
3
1
)
)
{
GLint
locationSize
=
static_cast
<
GLint
>
(
mState
.
getUniformLocations
(
)
.
size
(
)
)
;
if
(
locationSize
>
caps
.
maxUniformLocations
)
{
infoLog
<
<
"
Exceeded
maximum
uniform
location
size
"
;
return
false
;
}
}
return
true
;
}
void
Program
:
:
linkSamplerAndImageBindings
(
GLuint
*
combinedImageUniforms
)
{
ASSERT
(
combinedImageUniforms
)
;
auto
highIter
=
mState
.
mExecutable
-
>
getUniforms
(
)
.
rbegin
(
)
;
auto
lowIter
=
highIter
;
unsigned
int
high
=
static_cast
<
unsigned
int
>
(
mState
.
mExecutable
-
>
getUniforms
(
)
.
size
(
)
)
;
unsigned
int
low
=
high
;
ASSERT
(
mState
.
mExecutable
-
>
getUniforms
(
)
.
size
(
)
=
=
0
|
|
highIter
-
>
isAtomicCounter
(
)
|
|
highIter
-
>
isImage
(
)
|
|
highIter
-
>
isSampler
(
)
|
|
highIter
-
>
isInDefaultBlock
(
)
)
;
for
(
;
lowIter
!
=
mState
.
mExecutable
-
>
getUniforms
(
)
.
rend
(
)
&
&
lowIter
-
>
isAtomicCounter
(
)
;
+
+
lowIter
)
{
-
-
low
;
}
mState
.
mAtomicCounterUniformRange
=
RangeUI
(
low
high
)
;
highIter
=
lowIter
;
high
=
low
;
for
(
;
lowIter
!
=
mState
.
mExecutable
-
>
getUniforms
(
)
.
rend
(
)
&
&
lowIter
-
>
isImage
(
)
;
+
+
lowIter
)
{
-
-
low
;
}
mState
.
mExecutable
-
>
mImageUniformRange
=
RangeUI
(
low
high
)
;
*
combinedImageUniforms
=
0u
;
bool
hasComputeShader
=
mState
.
mAttachedShaders
[
ShaderType
:
:
Compute
]
!
=
nullptr
;
std
:
:
vector
<
ImageBinding
>
&
imageBindings
=
hasComputeShader
?
mState
.
mExecutable
-
>
mComputeImageBindings
:
mState
.
mExecutable
-
>
mGraphicsImageBindings
;
uint32_t
arrayOffset
=
0
;
for
(
unsigned
int
imageIndex
:
mState
.
mExecutable
-
>
getImageUniformRange
(
)
)
{
auto
&
imageUniform
=
mState
.
mExecutable
-
>
getUniforms
(
)
[
imageIndex
]
;
if
(
imageUniform
.
binding
=
=
-
1
)
{
imageBindings
.
emplace_back
(
ImageBinding
(
imageUniform
.
getBasicTypeElementCount
(
)
)
)
;
}
else
{
imageBindings
.
emplace_back
(
ImageBinding
(
imageUniform
.
binding
+
arrayOffset
imageUniform
.
getBasicTypeElementCount
(
)
)
)
;
}
GLuint
arraySize
=
imageUniform
.
isArray
(
)
?
imageUniform
.
arraySizes
[
0
]
:
1u
;
*
combinedImageUniforms
+
=
imageUniform
.
activeShaderCount
(
)
*
arraySize
;
if
(
imageUniform
.
hasParentArrayIndex
(
)
&
&
imageUniform
.
isArray
(
)
)
{
arrayOffset
+
=
arraySize
;
}
else
{
arrayOffset
=
0
;
}
}
highIter
=
lowIter
;
high
=
low
;
for
(
;
lowIter
!
=
mState
.
mExecutable
-
>
getUniforms
(
)
.
rend
(
)
&
&
lowIter
-
>
isSampler
(
)
;
+
+
lowIter
)
{
-
-
low
;
}
mState
.
mExecutable
-
>
mSamplerUniformRange
=
RangeUI
(
low
high
)
;
for
(
unsigned
int
samplerIndex
:
mState
.
mExecutable
-
>
getSamplerUniformRange
(
)
)
{
const
auto
&
samplerUniform
=
mState
.
mExecutable
-
>
getUniforms
(
)
[
samplerIndex
]
;
TextureType
textureType
=
SamplerTypeToTextureType
(
samplerUniform
.
type
)
;
unsigned
int
elementCount
=
samplerUniform
.
getBasicTypeElementCount
(
)
;
SamplerFormat
format
=
samplerUniform
.
typeInfo
-
>
samplerFormat
;
mState
.
mExecutable
-
>
mSamplerBindings
.
emplace_back
(
textureType
format
elementCount
)
;
}
mState
.
mExecutable
-
>
mDefaultUniformRange
=
RangeUI
(
0
low
)
;
}
bool
Program
:
:
linkAtomicCounterBuffers
(
)
{
for
(
unsigned
int
index
:
mState
.
mAtomicCounterUniformRange
)
{
auto
&
uniform
=
mState
.
mExecutable
-
>
mUniforms
[
index
]
;
uniform
.
blockInfo
.
offset
=
uniform
.
offset
;
uniform
.
blockInfo
.
arrayStride
=
(
uniform
.
isArray
(
)
?
4
:
0
)
;
uniform
.
blockInfo
.
matrixStride
=
0
;
uniform
.
blockInfo
.
isRowMajorMatrix
=
false
;
bool
found
=
false
;
for
(
unsigned
int
bufferIndex
=
0
;
bufferIndex
<
mState
.
mExecutable
-
>
getActiveAtomicCounterBufferCount
(
)
;
+
+
bufferIndex
)
{
auto
&
buffer
=
mState
.
mExecutable
-
>
mAtomicCounterBuffers
[
bufferIndex
]
;
if
(
buffer
.
binding
=
=
uniform
.
binding
)
{
buffer
.
memberIndexes
.
push_back
(
index
)
;
uniform
.
bufferIndex
=
bufferIndex
;
found
=
true
;
buffer
.
unionReferencesWith
(
uniform
)
;
break
;
}
}
if
(
!
found
)
{
AtomicCounterBuffer
atomicCounterBuffer
;
atomicCounterBuffer
.
binding
=
uniform
.
binding
;
atomicCounterBuffer
.
memberIndexes
.
push_back
(
index
)
;
atomicCounterBuffer
.
unionReferencesWith
(
uniform
)
;
mState
.
mExecutable
-
>
mAtomicCounterBuffers
.
push_back
(
atomicCounterBuffer
)
;
uniform
.
bufferIndex
=
static_cast
<
int
>
(
mState
.
mExecutable
-
>
getActiveAtomicCounterBufferCount
(
)
-
1
)
;
}
}
return
true
;
}
bool
Program
:
:
linkAttributes
(
const
Context
*
context
InfoLog
&
infoLog
)
{
const
Caps
&
caps
=
context
-
>
getCaps
(
)
;
const
Limitations
&
limitations
=
context
-
>
getLimitations
(
)
;
bool
webglCompatibility
=
context
-
>
getExtensions
(
)
.
webglCompatibility
;
int
shaderVersion
=
-
1
;
unsigned
int
usedLocations
=
0
;
Shader
*
vertexShader
=
mState
.
getAttachedShader
(
gl
:
:
ShaderType
:
:
Vertex
)
;
if
(
!
vertexShader
)
{
return
true
;
}
shaderVersion
=
vertexShader
-
>
getShaderVersion
(
)
;
if
(
shaderVersion
>
=
300
)
{
mState
.
mExecutable
-
>
mProgramInputs
=
vertexShader
-
>
getAllAttributes
(
)
;
}
else
{
mState
.
mExecutable
-
>
mProgramInputs
=
vertexShader
-
>
getActiveAttributes
(
)
;
}
GLuint
maxAttribs
=
static_cast
<
GLuint
>
(
caps
.
maxVertexAttributes
)
;
std
:
:
vector
<
sh
:
:
ShaderVariable
*
>
usedAttribMap
(
maxAttribs
nullptr
)
;
for
(
sh
:
:
ShaderVariable
&
attribute
:
mState
.
mExecutable
-
>
mProgramInputs
)
{
ASSERT
(
!
attribute
.
isArray
(
)
&
&
!
attribute
.
isStruct
(
)
)
;
int
bindingLocation
=
mAttributeBindings
.
getBinding
(
attribute
)
;
if
(
attribute
.
location
=
=
-
1
&
&
bindingLocation
!
=
-
1
)
{
attribute
.
location
=
bindingLocation
;
}
if
(
attribute
.
location
!
=
-
1
)
{
const
int
regs
=
VariableRegisterCount
(
attribute
.
type
)
;
if
(
static_cast
<
GLuint
>
(
regs
+
attribute
.
location
)
>
maxAttribs
)
{
infoLog
<
<
"
Attribute
(
"
<
<
attribute
.
name
<
<
"
)
at
location
"
<
<
attribute
.
location
<
<
"
is
too
big
to
fit
"
;
return
false
;
}
for
(
int
reg
=
0
;
reg
<
regs
;
reg
+
+
)
{
const
int
regLocation
=
attribute
.
location
+
reg
;
sh
:
:
ShaderVariable
*
linkedAttribute
=
usedAttribMap
[
regLocation
]
;
if
(
linkedAttribute
)
{
if
(
shaderVersion
>
=
300
|
|
webglCompatibility
|
|
limitations
.
noVertexAttributeAliasing
)
{
infoLog
<
<
"
Attribute
'
"
<
<
attribute
.
name
<
<
"
'
aliases
attribute
'
"
<
<
linkedAttribute
-
>
name
<
<
"
'
at
location
"
<
<
regLocation
;
return
false
;
}
}
else
{
usedAttribMap
[
regLocation
]
=
&
attribute
;
}
usedLocations
|
=
1
<
<
regLocation
;
}
}
}
for
(
sh
:
:
ShaderVariable
&
attribute
:
mState
.
mExecutable
-
>
mProgramInputs
)
{
if
(
attribute
.
location
=
=
-
1
)
{
int
regs
=
VariableRegisterCount
(
attribute
.
type
)
;
int
availableIndex
=
AllocateFirstFreeBits
(
&
usedLocations
regs
maxAttribs
)
;
if
(
availableIndex
=
=
-
1
|
|
static_cast
<
GLuint
>
(
availableIndex
+
regs
)
>
maxAttribs
)
{
infoLog
<
<
"
Too
many
attributes
(
"
<
<
attribute
.
name
<
<
"
)
"
;
return
false
;
}
attribute
.
location
=
availableIndex
;
}
}
ASSERT
(
mState
.
mExecutable
-
>
mAttributesTypeMask
.
none
(
)
)
;
ASSERT
(
mState
.
mExecutable
-
>
mAttributesMask
.
none
(
)
)
;
if
(
shaderVersion
>
=
300
)
{
for
(
auto
attributeIter
=
mState
.
mExecutable
-
>
getProgramInputs
(
)
.
begin
(
)
;
attributeIter
!
=
mState
.
mExecutable
-
>
getProgramInputs
(
)
.
end
(
)
;
)
{
if
(
attributeIter
-
>
active
)
{
+
+
attributeIter
;
}
else
{
attributeIter
=
mState
.
mExecutable
-
>
mProgramInputs
.
erase
(
attributeIter
)
;
}
}
}
for
(
const
sh
:
:
ShaderVariable
&
attribute
:
mState
.
mExecutable
-
>
getProgramInputs
(
)
)
{
ASSERT
(
attribute
.
active
)
;
ASSERT
(
attribute
.
location
!
=
-
1
)
;
unsigned
int
regs
=
static_cast
<
unsigned
int
>
(
VariableRegisterCount
(
attribute
.
type
)
)
;
unsigned
int
location
=
static_cast
<
unsigned
int
>
(
attribute
.
location
)
;
for
(
unsigned
int
r
=
0
;
r
<
regs
;
r
+
+
)
{
if
(
!
attribute
.
isBuiltIn
(
)
)
{
mState
.
mExecutable
-
>
mActiveAttribLocationsMask
.
set
(
location
)
;
mState
.
mExecutable
-
>
mMaxActiveAttribLocation
=
std
:
:
max
(
mState
.
mExecutable
-
>
mMaxActiveAttribLocation
location
+
1
)
;
ComponentType
componentType
=
GLenumToComponentType
(
VariableComponentType
(
attribute
.
type
)
)
;
SetComponentTypeMask
(
componentType
location
&
mState
.
mExecutable
-
>
mAttributesTypeMask
)
;
mState
.
mExecutable
-
>
mAttributesMask
.
set
(
location
)
;
location
+
+
;
}
}
}
return
true
;
}
bool
Program
:
:
linkInterfaceBlocks
(
const
Caps
&
caps
const
Version
&
version
bool
webglCompatibility
InfoLog
&
infoLog
GLuint
*
combinedShaderStorageBlocksCount
)
{
ASSERT
(
combinedShaderStorageBlocksCount
)
;
GLuint
combinedUniformBlocksCount
=
0u
;
GLuint
numShadersHasUniformBlocks
=
0u
;
ShaderMap
<
const
std
:
:
vector
<
sh
:
:
InterfaceBlock
>
*
>
allShaderUniformBlocks
=
{
}
;
for
(
ShaderType
shaderType
:
AllShaderTypes
(
)
)
{
Shader
*
shader
=
mState
.
mAttachedShaders
[
shaderType
]
;
if
(
!
shader
)
{
continue
;
}
const
auto
&
uniformBlocks
=
shader
-
>
getUniformBlocks
(
)
;
if
(
!
uniformBlocks
.
empty
(
)
)
{
if
(
!
ValidateInterfaceBlocksCount
(
static_cast
<
GLuint
>
(
caps
.
maxShaderUniformBlocks
[
shaderType
]
)
uniformBlocks
shaderType
sh
:
:
BlockType
:
:
BLOCK_UNIFORM
&
combinedUniformBlocksCount
infoLog
)
)
{
return
false
;
}
allShaderUniformBlocks
[
shaderType
]
=
&
uniformBlocks
;
+
+
numShadersHasUniformBlocks
;
}
}
if
(
combinedUniformBlocksCount
>
static_cast
<
GLuint
>
(
caps
.
maxCombinedUniformBlocks
)
)
{
infoLog
<
<
"
The
sum
of
the
number
of
active
uniform
blocks
exceeds
"
"
MAX_COMBINED_UNIFORM_BLOCKS
(
"
<
<
caps
.
maxCombinedUniformBlocks
<
<
"
)
.
"
;
return
false
;
}
if
(
!
ValidateInterfaceBlocksMatch
(
numShadersHasUniformBlocks
allShaderUniformBlocks
infoLog
webglCompatibility
)
)
{
return
false
;
}
if
(
version
>
=
Version
(
3
1
)
)
{
*
combinedShaderStorageBlocksCount
=
0u
;
GLuint
numShadersHasShaderStorageBlocks
=
0u
;
ShaderMap
<
const
std
:
:
vector
<
sh
:
:
InterfaceBlock
>
*
>
allShaderStorageBlocks
=
{
}
;
for
(
ShaderType
shaderType
:
AllShaderTypes
(
)
)
{
Shader
*
shader
=
mState
.
mAttachedShaders
[
shaderType
]
;
if
(
!
shader
)
{
continue
;
}
const
auto
&
shaderStorageBlocks
=
shader
-
>
getShaderStorageBlocks
(
)
;
if
(
!
shaderStorageBlocks
.
empty
(
)
)
{
if
(
!
ValidateInterfaceBlocksCount
(
static_cast
<
GLuint
>
(
caps
.
maxShaderStorageBlocks
[
shaderType
]
)
shaderStorageBlocks
shaderType
sh
:
:
BlockType
:
:
BLOCK_BUFFER
combinedShaderStorageBlocksCount
infoLog
)
)
{
return
false
;
}
allShaderStorageBlocks
[
shaderType
]
=
&
shaderStorageBlocks
;
+
+
numShadersHasShaderStorageBlocks
;
}
}
if
(
*
combinedShaderStorageBlocksCount
>
static_cast
<
GLuint
>
(
caps
.
maxCombinedShaderStorageBlocks
)
)
{
infoLog
<
<
"
The
sum
of
the
number
of
active
shader
storage
blocks
exceeds
"
"
MAX_COMBINED_SHADER_STORAGE_BLOCKS
(
"
<
<
caps
.
maxCombinedShaderStorageBlocks
<
<
"
)
.
"
;
return
false
;
}
if
(
!
ValidateInterfaceBlocksMatch
(
numShadersHasShaderStorageBlocks
allShaderStorageBlocks
infoLog
webglCompatibility
)
)
{
return
false
;
}
}
return
true
;
}
LinkMismatchError
Program
:
:
LinkValidateVariablesBase
(
const
sh
:
:
ShaderVariable
&
variable1
const
sh
:
:
ShaderVariable
&
variable2
bool
validatePrecision
bool
validateArraySize
std
:
:
string
*
mismatchedStructOrBlockMemberName
)
{
if
(
variable1
.
type
!
=
variable2
.
type
)
{
return
LinkMismatchError
:
:
TYPE_MISMATCH
;
}
if
(
validateArraySize
&
&
variable1
.
arraySizes
!
=
variable2
.
arraySizes
)
{
return
LinkMismatchError
:
:
ARRAY_SIZE_MISMATCH
;
}
if
(
validatePrecision
&
&
variable1
.
precision
!
=
variable2
.
precision
)
{
return
LinkMismatchError
:
:
PRECISION_MISMATCH
;
}
if
(
variable1
.
structName
!
=
variable2
.
structName
)
{
return
LinkMismatchError
:
:
STRUCT_NAME_MISMATCH
;
}
if
(
variable1
.
imageUnitFormat
!
=
variable2
.
imageUnitFormat
)
{
return
LinkMismatchError
:
:
FORMAT_MISMATCH
;
}
if
(
variable1
.
fields
.
size
(
)
!
=
variable2
.
fields
.
size
(
)
)
{
return
LinkMismatchError
:
:
FIELD_NUMBER_MISMATCH
;
}
const
unsigned
int
numMembers
=
static_cast
<
unsigned
int
>
(
variable1
.
fields
.
size
(
)
)
;
for
(
unsigned
int
memberIndex
=
0
;
memberIndex
<
numMembers
;
memberIndex
+
+
)
{
const
sh
:
:
ShaderVariable
&
member1
=
variable1
.
fields
[
memberIndex
]
;
const
sh
:
:
ShaderVariable
&
member2
=
variable2
.
fields
[
memberIndex
]
;
if
(
member1
.
name
!
=
member2
.
name
)
{
return
LinkMismatchError
:
:
FIELD_NAME_MISMATCH
;
}
LinkMismatchError
linkErrorOnField
=
LinkValidateVariablesBase
(
member1
member2
validatePrecision
true
mismatchedStructOrBlockMemberName
)
;
if
(
linkErrorOnField
!
=
LinkMismatchError
:
:
NO_MISMATCH
)
{
AddParentPrefix
(
member1
.
name
mismatchedStructOrBlockMemberName
)
;
return
linkErrorOnField
;
}
}
return
LinkMismatchError
:
:
NO_MISMATCH
;
}
LinkMismatchError
Program
:
:
LinkValidateVaryings
(
const
sh
:
:
ShaderVariable
&
outputVarying
const
sh
:
:
ShaderVariable
&
inputVarying
int
shaderVersion
bool
validateGeometryShaderInputVarying
bool
isSeparable
std
:
:
string
*
mismatchedStructFieldName
)
{
if
(
validateGeometryShaderInputVarying
)
{
ASSERT
(
inputVarying
.
arraySizes
.
size
(
)
=
=
1u
)
;
if
(
outputVarying
.
isArray
(
)
)
{
return
LinkMismatchError
:
:
ARRAY_SIZE_MISMATCH
;
}
}
bool
validatePrecision
=
isSeparable
&
&
(
shaderVersion
>
100
)
;
LinkMismatchError
linkError
=
LinkValidateVariablesBase
(
outputVarying
inputVarying
validatePrecision
!
validateGeometryShaderInputVarying
mismatchedStructFieldName
)
;
if
(
linkError
!
=
LinkMismatchError
:
:
NO_MISMATCH
)
{
return
linkError
;
}
if
(
(
outputVarying
.
name
=
=
inputVarying
.
name
)
&
&
(
outputVarying
.
location
!
=
inputVarying
.
location
)
)
{
return
LinkMismatchError
:
:
LOCATION_MISMATCH
;
}
if
(
!
sh
:
:
InterpolationTypesMatch
(
outputVarying
.
interpolation
inputVarying
.
interpolation
)
)
{
return
LinkMismatchError
:
:
INTERPOLATION_TYPE_MISMATCH
;
}
if
(
shaderVersion
=
=
100
&
&
outputVarying
.
isInvariant
!
=
inputVarying
.
isInvariant
)
{
return
LinkMismatchError
:
:
INVARIANCE_MISMATCH
;
}
return
LinkMismatchError
:
:
NO_MISMATCH
;
}
bool
Program
:
:
linkValidateBuiltInVaryings
(
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
vertexVaryings
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
fragmentVaryings
int
vertexShaderVersion
InfoLog
&
infoLog
)
{
if
(
vertexShaderVersion
!
=
100
)
{
return
true
;
}
bool
glPositionIsInvariant
=
false
;
bool
glPointSizeIsInvariant
=
false
;
bool
glFragCoordIsInvariant
=
false
;
bool
glPointCoordIsInvariant
=
false
;
for
(
const
sh
:
:
ShaderVariable
&
varying
:
vertexVaryings
)
{
if
(
!
varying
.
isBuiltIn
(
)
)
{
continue
;
}
if
(
varying
.
name
.
compare
(
"
gl_Position
"
)
=
=
0
)
{
glPositionIsInvariant
=
varying
.
isInvariant
;
}
else
if
(
varying
.
name
.
compare
(
"
gl_PointSize
"
)
=
=
0
)
{
glPointSizeIsInvariant
=
varying
.
isInvariant
;
}
}
for
(
const
sh
:
:
ShaderVariable
&
varying
:
fragmentVaryings
)
{
if
(
!
varying
.
isBuiltIn
(
)
)
{
continue
;
}
if
(
varying
.
name
.
compare
(
"
gl_FragCoord
"
)
=
=
0
)
{
glFragCoordIsInvariant
=
varying
.
isInvariant
;
}
else
if
(
varying
.
name
.
compare
(
"
gl_PointCoord
"
)
=
=
0
)
{
glPointCoordIsInvariant
=
varying
.
isInvariant
;
}
}
if
(
glFragCoordIsInvariant
&
&
!
glPositionIsInvariant
)
{
infoLog
<
<
"
gl_FragCoord
can
only
be
declared
invariant
if
and
only
if
gl_Position
is
"
"
declared
invariant
.
"
;
return
false
;
}
if
(
glPointCoordIsInvariant
&
&
!
glPointSizeIsInvariant
)
{
infoLog
<
<
"
gl_PointCoord
can
only
be
declared
invariant
if
and
only
if
gl_PointSize
is
"
"
declared
invariant
.
"
;
return
false
;
}
return
true
;
}
bool
Program
:
:
linkValidateTransformFeedback
(
const
Version
&
version
InfoLog
&
infoLog
const
ProgramMergedVaryings
&
varyings
ShaderType
stage
const
Caps
&
caps
)
const
{
std
:
:
set
<
std
:
:
string
>
uniqueNames
;
for
(
const
std
:
:
string
&
tfVaryingName
:
mState
.
mTransformFeedbackVaryingNames
)
{
if
(
version
<
Version
(
3
1
)
&
&
tfVaryingName
.
find
(
'
[
'
)
!
=
std
:
:
string
:
:
npos
)
{
infoLog
<
<
"
Capture
of
array
elements
is
undefined
and
not
supported
.
"
;
return
false
;
}
if
(
version
>
=
Version
(
3
1
)
)
{
if
(
IncludeSameArrayElement
(
uniqueNames
tfVaryingName
)
)
{
infoLog
<
<
"
Two
transform
feedback
varyings
include
the
same
array
element
(
"
<
<
tfVaryingName
<
<
"
)
.
"
;
return
false
;
}
}
else
{
if
(
uniqueNames
.
count
(
tfVaryingName
)
>
0
)
{
infoLog
<
<
"
Two
transform
feedback
varyings
specify
the
same
output
variable
(
"
<
<
tfVaryingName
<
<
"
)
.
"
;
return
false
;
}
}
uniqueNames
.
insert
(
tfVaryingName
)
;
}
size_t
totalComponents
=
0
;
for
(
const
std
:
:
string
&
tfVaryingName
:
mState
.
mTransformFeedbackVaryingNames
)
{
std
:
:
vector
<
unsigned
int
>
subscripts
;
std
:
:
string
baseName
=
ParseResourceName
(
tfVaryingName
&
subscripts
)
;
const
sh
:
:
ShaderVariable
*
var
=
FindOutputVaryingOrField
(
varyings
stage
baseName
)
;
if
(
var
=
=
nullptr
)
{
infoLog
<
<
"
Transform
feedback
varying
"
<
<
tfVaryingName
<
<
"
does
not
exist
in
the
vertex
shader
.
"
;
return
false
;
}
if
(
var
-
>
isStruct
(
)
)
{
infoLog
<
<
"
Struct
cannot
be
captured
directly
(
"
<
<
baseName
<
<
"
)
.
"
;
return
false
;
}
size_t
elementCount
=
0
;
size_t
componentCount
=
0
;
if
(
var
-
>
isArray
(
)
)
{
if
(
version
<
Version
(
3
1
)
)
{
infoLog
<
<
"
Capture
of
arrays
is
undefined
and
not
supported
.
"
;
return
false
;
}
ASSERT
(
!
var
-
>
isArrayOfArrays
(
)
)
;
if
(
!
subscripts
.
empty
(
)
&
&
subscripts
[
0
]
>
=
var
-
>
getOutermostArraySize
(
)
)
{
infoLog
<
<
"
Cannot
capture
outbound
array
element
'
"
<
<
tfVaryingName
<
<
"
'
.
"
;
return
false
;
}
elementCount
=
(
subscripts
.
empty
(
)
?
var
-
>
getOutermostArraySize
(
)
:
1
)
;
}
else
{
if
(
!
subscripts
.
empty
(
)
)
{
infoLog
<
<
"
Varying
'
"
<
<
baseName
<
<
"
'
is
not
an
array
to
be
captured
by
element
.
"
;
return
false
;
}
elementCount
=
1
;
}
componentCount
=
VariableComponentCount
(
var
-
>
type
)
*
elementCount
;
if
(
mState
.
mExecutable
-
>
getTransformFeedbackBufferMode
(
)
=
=
GL_SEPARATE_ATTRIBS
&
&
componentCount
>
static_cast
<
GLuint
>
(
caps
.
maxTransformFeedbackSeparateComponents
)
)
{
infoLog
<
<
"
Transform
feedback
varying
"
<
<
tfVaryingName
<
<
"
components
(
"
<
<
componentCount
<
<
"
)
exceed
the
maximum
separate
components
(
"
<
<
caps
.
maxTransformFeedbackSeparateComponents
<
<
"
)
.
"
;
return
false
;
}
totalComponents
+
=
componentCount
;
if
(
mState
.
mExecutable
-
>
getTransformFeedbackBufferMode
(
)
=
=
GL_INTERLEAVED_ATTRIBS
&
&
totalComponents
>
static_cast
<
GLuint
>
(
caps
.
maxTransformFeedbackInterleavedComponents
)
)
{
infoLog
<
<
"
Transform
feedback
varying
total
components
(
"
<
<
totalComponents
<
<
"
)
exceed
the
maximum
interleaved
components
(
"
<
<
caps
.
maxTransformFeedbackInterleavedComponents
<
<
"
)
.
"
;
return
false
;
}
}
return
true
;
}
void
Program
:
:
gatherTransformFeedbackVaryings
(
const
ProgramMergedVaryings
&
varyings
ShaderType
stage
)
{
mState
.
mExecutable
-
>
mLinkedTransformFeedbackVaryings
.
clear
(
)
;
for
(
const
std
:
:
string
&
tfVaryingName
:
mState
.
mTransformFeedbackVaryingNames
)
{
std
:
:
vector
<
unsigned
int
>
subscripts
;
std
:
:
string
baseName
=
ParseResourceName
(
tfVaryingName
&
subscripts
)
;
size_t
subscript
=
GL_INVALID_INDEX
;
if
(
!
subscripts
.
empty
(
)
)
{
subscript
=
subscripts
.
back
(
)
;
}
for
(
const
ProgramVaryingRef
&
ref
:
varyings
)
{
if
(
ref
.
frontShaderStage
!
=
stage
)
{
continue
;
}
const
sh
:
:
ShaderVariable
*
varying
=
ref
.
get
(
stage
)
;
if
(
baseName
=
=
varying
-
>
name
)
{
mState
.
mExecutable
-
>
mLinkedTransformFeedbackVaryings
.
emplace_back
(
*
varying
static_cast
<
GLuint
>
(
subscript
)
)
;
break
;
}
else
if
(
varying
-
>
isStruct
(
)
)
{
GLuint
fieldIndex
=
0
;
const
auto
*
field
=
varying
-
>
findField
(
tfVaryingName
&
fieldIndex
)
;
if
(
field
!
=
nullptr
)
{
mState
.
mExecutable
-
>
mLinkedTransformFeedbackVaryings
.
emplace_back
(
*
field
*
varying
)
;
break
;
}
}
}
}
}
ProgramMergedVaryings
Program
:
:
getMergedVaryings
(
)
const
{
ASSERT
(
mState
.
mAttachedShaders
[
ShaderType
:
:
Compute
]
=
=
nullptr
)
;
ShaderMap
<
ShaderType
>
previousActiveStage
;
ShaderType
lastActiveStage
=
ShaderType
:
:
InvalidEnum
;
for
(
ShaderType
stage
:
kAllGraphicsShaderTypes
)
{
previousActiveStage
[
stage
]
=
lastActiveStage
;
if
(
mState
.
mAttachedShaders
[
stage
]
)
{
lastActiveStage
=
stage
;
}
}
ShaderMap
<
std
:
:
map
<
std
:
:
string
size_t
>
>
outputVaryingNameToIndex
;
ShaderMap
<
std
:
:
map
<
int
size_t
>
>
outputVaryingLocationToIndex
;
ProgramMergedVaryings
merged
;
for
(
Shader
*
shader
:
mState
.
mAttachedShaders
)
{
if
(
!
shader
)
{
continue
;
}
ShaderType
stage
=
shader
-
>
getType
(
)
;
for
(
const
sh
:
:
ShaderVariable
&
varying
:
shader
-
>
getOutputVaryings
(
)
)
{
merged
.
push_back
(
{
}
)
;
ProgramVaryingRef
*
ref
=
&
merged
.
back
(
)
;
ref
-
>
frontShader
=
&
varying
;
ref
-
>
frontShaderStage
=
stage
;
outputVaryingNameToIndex
[
stage
]
[
varying
.
name
]
=
merged
.
size
(
)
-
1
;
if
(
varying
.
location
!
=
-
1
)
{
outputVaryingLocationToIndex
[
stage
]
[
varying
.
location
]
=
merged
.
size
(
)
-
1
;
}
}
}
for
(
Shader
*
shader
:
mState
.
mAttachedShaders
)
{
if
(
!
shader
)
{
continue
;
}
ShaderType
stage
=
shader
-
>
getType
(
)
;
ShaderType
previousStage
=
previousActiveStage
[
stage
]
;
for
(
const
sh
:
:
ShaderVariable
&
varying
:
shader
-
>
getInputVaryings
(
)
)
{
size_t
mergedIndex
=
merged
.
size
(
)
;
if
(
previousStage
!
=
ShaderType
:
:
InvalidEnum
)
{
if
(
varying
.
location
!
=
-
1
)
{
auto
byLocationIter
=
outputVaryingLocationToIndex
[
previousStage
]
.
find
(
varying
.
location
)
;
if
(
byLocationIter
!
=
outputVaryingLocationToIndex
[
previousStage
]
.
end
(
)
)
{
mergedIndex
=
byLocationIter
-
>
second
;
}
}
if
(
mergedIndex
=
=
merged
.
size
(
)
)
{
auto
byNameIter
=
outputVaryingNameToIndex
[
previousStage
]
.
find
(
varying
.
name
)
;
if
(
byNameIter
!
=
outputVaryingNameToIndex
[
previousStage
]
.
end
(
)
)
{
mergedIndex
=
byNameIter
-
>
second
;
}
}
}
if
(
mergedIndex
=
=
merged
.
size
(
)
)
{
merged
.
push_back
(
{
}
)
;
mergedIndex
=
merged
.
size
(
)
-
1
;
}
ProgramVaryingRef
*
ref
=
&
merged
[
mergedIndex
]
;
ref
-
>
backShader
=
&
varying
;
ref
-
>
backShaderStage
=
stage
;
}
}
return
merged
;
}
bool
CompareOutputVariable
(
const
sh
:
:
ShaderVariable
&
a
const
sh
:
:
ShaderVariable
&
b
)
{
return
a
.
getArraySizeProduct
(
)
>
b
.
getArraySizeProduct
(
)
;
}
int
Program
:
:
getOutputLocationForLink
(
const
sh
:
:
ShaderVariable
&
outputVariable
)
const
{
if
(
outputVariable
.
location
!
=
-
1
)
{
return
outputVariable
.
location
;
}
int
apiLocation
=
mFragmentOutputLocations
.
getBinding
(
outputVariable
)
;
if
(
apiLocation
!
=
-
1
)
{
return
apiLocation
;
}
return
-
1
;
}
bool
Program
:
:
isOutputSecondaryForLink
(
const
sh
:
:
ShaderVariable
&
outputVariable
)
const
{
if
(
outputVariable
.
index
!
=
-
1
)
{
ASSERT
(
outputVariable
.
index
=
=
0
|
|
outputVariable
.
index
=
=
1
)
;
return
(
outputVariable
.
index
=
=
1
)
;
}
int
apiIndex
=
mFragmentOutputIndexes
.
getBinding
(
outputVariable
)
;
if
(
apiIndex
!
=
-
1
)
{
return
(
apiIndex
=
=
1
)
;
}
return
false
;
}
namespace
{
bool
FindUsedOutputLocation
(
std
:
:
vector
<
VariableLocation
>
&
outputLocations
unsigned
int
baseLocation
unsigned
int
elementCount
const
std
:
:
vector
<
VariableLocation
>
&
reservedLocations
unsigned
int
variableIndex
)
{
if
(
baseLocation
+
elementCount
>
outputLocations
.
size
(
)
)
{
elementCount
=
baseLocation
<
outputLocations
.
size
(
)
?
static_cast
<
unsigned
int
>
(
outputLocations
.
size
(
)
-
baseLocation
)
:
0
;
}
for
(
unsigned
int
elementIndex
=
0
;
elementIndex
<
elementCount
;
elementIndex
+
+
)
{
const
unsigned
int
location
=
baseLocation
+
elementIndex
;
if
(
outputLocations
[
location
]
.
used
(
)
)
{
VariableLocation
locationInfo
(
elementIndex
variableIndex
)
;
if
(
std
:
:
find
(
reservedLocations
.
begin
(
)
reservedLocations
.
end
(
)
locationInfo
)
=
=
reservedLocations
.
end
(
)
)
{
return
true
;
}
}
}
return
false
;
}
void
AssignOutputLocations
(
std
:
:
vector
<
VariableLocation
>
&
outputLocations
unsigned
int
baseLocation
unsigned
int
elementCount
const
std
:
:
vector
<
VariableLocation
>
&
reservedLocations
unsigned
int
variableIndex
sh
:
:
ShaderVariable
&
outputVariable
)
{
if
(
baseLocation
+
elementCount
>
outputLocations
.
size
(
)
)
{
outputLocations
.
resize
(
baseLocation
+
elementCount
)
;
}
for
(
unsigned
int
elementIndex
=
0
;
elementIndex
<
elementCount
;
elementIndex
+
+
)
{
VariableLocation
locationInfo
(
elementIndex
variableIndex
)
;
if
(
std
:
:
find
(
reservedLocations
.
begin
(
)
reservedLocations
.
end
(
)
locationInfo
)
=
=
reservedLocations
.
end
(
)
)
{
outputVariable
.
location
=
baseLocation
;
const
unsigned
int
location
=
baseLocation
+
elementIndex
;
outputLocations
[
location
]
=
locationInfo
;
}
}
}
}
bool
Program
:
:
linkOutputVariables
(
const
Caps
&
caps
const
Extensions
&
extensions
const
Version
&
version
GLuint
combinedImageUniformsCount
GLuint
combinedShaderStorageBlocksCount
)
{
InfoLog
&
infoLog
=
mState
.
mExecutable
-
>
getInfoLog
(
)
;
Shader
*
fragmentShader
=
mState
.
mAttachedShaders
[
ShaderType
:
:
Fragment
]
;
ASSERT
(
mState
.
mOutputVariableTypes
.
empty
(
)
)
;
ASSERT
(
mState
.
mActiveOutputVariables
.
none
(
)
)
;
ASSERT
(
mState
.
mDrawBufferTypeMask
.
none
(
)
)
;
if
(
!
fragmentShader
)
{
return
true
;
}
const
auto
&
outputVariables
=
fragmentShader
-
>
getActiveOutputVariables
(
)
;
for
(
const
auto
&
outputVariable
:
outputVariables
)
{
if
(
outputVariable
.
isBuiltIn
(
)
&
&
outputVariable
.
name
!
=
"
gl_FragColor
"
&
&
outputVariable
.
name
!
=
"
gl_FragData
"
)
{
continue
;
}
unsigned
int
baseLocation
=
(
outputVariable
.
location
=
=
-
1
?
0u
:
static_cast
<
unsigned
int
>
(
outputVariable
.
location
)
)
;
unsigned
int
elementCount
=
outputVariable
.
getBasicTypeElementCount
(
)
;
for
(
unsigned
int
elementIndex
=
0
;
elementIndex
<
elementCount
;
elementIndex
+
+
)
{
const
unsigned
int
location
=
baseLocation
+
elementIndex
;
if
(
location
>
=
mState
.
mOutputVariableTypes
.
size
(
)
)
{
mState
.
mOutputVariableTypes
.
resize
(
location
+
1
GL_NONE
)
;
}
ASSERT
(
location
<
mState
.
mActiveOutputVariables
.
size
(
)
)
;
mState
.
mActiveOutputVariables
.
set
(
location
)
;
mState
.
mOutputVariableTypes
[
location
]
=
VariableComponentType
(
outputVariable
.
type
)
;
ComponentType
componentType
=
GLenumToComponentType
(
mState
.
mOutputVariableTypes
[
location
]
)
;
SetComponentTypeMask
(
componentType
location
&
mState
.
mDrawBufferTypeMask
)
;
}
}
if
(
version
>
=
ES_3_1
)
{
if
(
combinedImageUniformsCount
+
combinedShaderStorageBlocksCount
+
mState
.
mActiveOutputVariables
.
count
(
)
>
static_cast
<
GLuint
>
(
caps
.
maxCombinedShaderOutputResources
)
)
{
infoLog
<
<
"
The
sum
of
the
number
of
active
image
uniforms
active
shader
storage
blocks
"
"
and
active
fragment
shader
outputs
exceeds
"
"
MAX_COMBINED_SHADER_OUTPUT_RESOURCES
(
"
<
<
caps
.
maxCombinedShaderOutputResources
<
<
"
)
"
;
return
false
;
}
}
if
(
fragmentShader
&
&
fragmentShader
-
>
getShaderVersion
(
)
=
=
100
)
return
true
;
mState
.
mExecutable
-
>
mOutputVariables
=
outputVariables
;
std
:
:
vector
<
VariableLocation
>
reservedLocations
;
for
(
const
auto
&
binding
:
mFragmentOutputLocations
)
{
size_t
nameLengthWithoutArrayIndex
;
unsigned
int
arrayIndex
=
ParseArrayIndex
(
binding
.
first
&
nameLengthWithoutArrayIndex
)
;
if
(
arrayIndex
=
=
0
|
|
arrayIndex
=
=
GL_INVALID_INDEX
)
{
continue
;
}
for
(
unsigned
int
outputVariableIndex
=
0
;
outputVariableIndex
<
mState
.
mExecutable
-
>
getOutputVariables
(
)
.
size
(
)
;
outputVariableIndex
+
+
)
{
const
sh
:
:
ShaderVariable
&
outputVariable
=
mState
.
mExecutable
-
>
getOutputVariables
(
)
[
outputVariableIndex
]
;
if
(
outputVariable
.
isBuiltIn
(
)
|
|
!
outputVariable
.
isArray
(
)
|
|
!
angle
:
:
BeginsWith
(
outputVariable
.
name
binding
.
first
nameLengthWithoutArrayIndex
)
|
|
arrayIndex
>
=
outputVariable
.
getOutermostArraySize
(
)
)
{
continue
;
}
auto
&
outputLocations
=
mFragmentOutputIndexes
.
getBindingByName
(
binding
.
first
)
=
=
1
?
mState
.
mSecondaryOutputLocations
:
mState
.
mExecutable
-
>
mOutputLocations
;
unsigned
int
location
=
binding
.
second
.
location
;
VariableLocation
locationInfo
(
arrayIndex
outputVariableIndex
)
;
if
(
location
>
=
outputLocations
.
size
(
)
)
{
outputLocations
.
resize
(
location
+
1
)
;
}
if
(
outputLocations
[
location
]
.
used
(
)
)
{
infoLog
<
<
"
Location
of
variable
"
<
<
outputVariable
.
name
<
<
"
conflicts
with
another
variable
.
"
;
return
false
;
}
outputLocations
[
location
]
=
locationInfo
;
reservedLocations
.
push_back
(
locationInfo
)
;
}
}
for
(
unsigned
int
outputVariableIndex
=
0
;
outputVariableIndex
<
mState
.
mExecutable
-
>
getOutputVariables
(
)
.
size
(
)
;
outputVariableIndex
+
+
)
{
const
sh
:
:
ShaderVariable
&
outputVariable
=
mState
.
mExecutable
-
>
getOutputVariables
(
)
[
outputVariableIndex
]
;
if
(
outputVariable
.
isBuiltIn
(
)
)
continue
;
int
fixedLocation
=
getOutputLocationForLink
(
outputVariable
)
;
if
(
fixedLocation
=
=
-
1
)
{
continue
;
}
unsigned
int
baseLocation
=
static_cast
<
unsigned
int
>
(
fixedLocation
)
;
auto
&
outputLocations
=
isOutputSecondaryForLink
(
outputVariable
)
?
mState
.
mSecondaryOutputLocations
:
mState
.
mExecutable
-
>
mOutputLocations
;
unsigned
int
elementCount
=
outputVariable
.
getBasicTypeElementCount
(
)
;
if
(
FindUsedOutputLocation
(
outputLocations
baseLocation
elementCount
reservedLocations
outputVariableIndex
)
)
{
infoLog
<
<
"
Location
of
variable
"
<
<
outputVariable
.
name
<
<
"
conflicts
with
another
variable
.
"
;
return
false
;
}
AssignOutputLocations
(
outputLocations
baseLocation
elementCount
reservedLocations
outputVariableIndex
mState
.
mExecutable
-
>
mOutputVariables
[
outputVariableIndex
]
)
;
}
GLuint
maxLocation
=
static_cast
<
GLuint
>
(
caps
.
maxDrawBuffers
)
;
if
(
!
mState
.
mSecondaryOutputLocations
.
empty
(
)
)
{
maxLocation
=
extensions
.
maxDualSourceDrawBuffers
;
}
for
(
unsigned
int
outputVariableIndex
=
0
;
outputVariableIndex
<
mState
.
mExecutable
-
>
getOutputVariables
(
)
.
size
(
)
;
outputVariableIndex
+
+
)
{
const
sh
:
:
ShaderVariable
&
outputVariable
=
mState
.
mExecutable
-
>
getOutputVariables
(
)
[
outputVariableIndex
]
;
if
(
outputVariable
.
isBuiltIn
(
)
)
continue
;
int
fixedLocation
=
getOutputLocationForLink
(
outputVariable
)
;
auto
&
outputLocations
=
isOutputSecondaryForLink
(
outputVariable
)
?
mState
.
mSecondaryOutputLocations
:
mState
.
mExecutable
-
>
mOutputLocations
;
unsigned
int
baseLocation
=
0
;
unsigned
int
elementCount
=
outputVariable
.
getBasicTypeElementCount
(
)
;
if
(
fixedLocation
!
=
-
1
)
{
baseLocation
=
static_cast
<
unsigned
int
>
(
fixedLocation
)
;
}
else
{
while
(
FindUsedOutputLocation
(
outputLocations
baseLocation
elementCount
reservedLocations
outputVariableIndex
)
)
{
baseLocation
+
+
;
}
AssignOutputLocations
(
outputLocations
baseLocation
elementCount
reservedLocations
outputVariableIndex
mState
.
mExecutable
-
>
mOutputVariables
[
outputVariableIndex
]
)
;
}
if
(
baseLocation
+
elementCount
>
maxLocation
&
&
(
baseLocation
>
=
maxLocation
|
|
FindUsedOutputLocation
(
outputLocations
maxLocation
baseLocation
+
elementCount
-
maxLocation
reservedLocations
outputVariableIndex
)
)
)
{
infoLog
<
<
"
Could
not
fit
output
variable
into
available
locations
:
"
<
<
outputVariable
.
name
;
return
false
;
}
}
return
true
;
}
void
Program
:
:
setUniformValuesFromBindingQualifiers
(
)
{
for
(
unsigned
int
samplerIndex
:
mState
.
mExecutable
-
>
getSamplerUniformRange
(
)
)
{
const
auto
&
samplerUniform
=
mState
.
mExecutable
-
>
getUniforms
(
)
[
samplerIndex
]
;
if
(
samplerUniform
.
binding
!
=
-
1
)
{
UniformLocation
location
=
getUniformLocation
(
samplerUniform
.
name
)
;
ASSERT
(
location
.
value
!
=
-
1
)
;
std
:
:
vector
<
GLint
>
boundTextureUnits
;
for
(
unsigned
int
elementIndex
=
0
;
elementIndex
<
samplerUniform
.
getBasicTypeElementCount
(
)
;
+
+
elementIndex
)
{
boundTextureUnits
.
push_back
(
samplerUniform
.
binding
+
elementIndex
)
;
}
setUniform1iv
(
nullptr
location
static_cast
<
GLsizei
>
(
boundTextureUnits
.
size
(
)
)
boundTextureUnits
.
data
(
)
)
;
}
}
}
void
Program
:
:
initInterfaceBlockBindings
(
)
{
for
(
unsigned
int
blockIndex
=
0
;
blockIndex
<
mState
.
mExecutable
-
>
getActiveUniformBlockCount
(
)
;
blockIndex
+
+
)
{
InterfaceBlock
&
uniformBlock
=
mState
.
mExecutable
-
>
mUniformBlocks
[
blockIndex
]
;
bindUniformBlock
(
blockIndex
uniformBlock
.
binding
)
;
}
}
void
Program
:
:
updateSamplerUniform
(
Context
*
context
const
VariableLocation
&
locationInfo
GLsizei
clampedCount
const
GLint
*
v
)
{
ASSERT
(
mState
.
isSamplerUniformIndex
(
locationInfo
.
index
)
)
;
GLuint
samplerIndex
=
mState
.
getSamplerIndexFromUniformIndex
(
locationInfo
.
index
)
;
SamplerBinding
&
samplerBinding
=
mState
.
mExecutable
-
>
mSamplerBindings
[
samplerIndex
]
;
std
:
:
vector
<
GLuint
>
&
boundTextureUnits
=
samplerBinding
.
boundTextureUnits
;
if
(
locationInfo
.
arrayIndex
>
=
boundTextureUnits
.
size
(
)
)
{
return
;
}
GLsizei
safeUniformCount
=
std
:
:
min
(
clampedCount
static_cast
<
GLsizei
>
(
boundTextureUnits
.
size
(
)
-
locationInfo
.
arrayIndex
)
)
;
for
(
GLsizei
arrayIndex
=
0
;
arrayIndex
<
safeUniformCount
;
+
+
arrayIndex
)
{
GLint
oldTextureUnit
=
boundTextureUnits
[
arrayIndex
+
locationInfo
.
arrayIndex
]
;
GLint
newTextureUnit
=
v
[
arrayIndex
]
;
if
(
oldTextureUnit
=
=
newTextureUnit
)
{
continue
;
}
boundTextureUnits
[
arrayIndex
+
locationInfo
.
arrayIndex
]
=
newTextureUnit
;
uint32_t
&
oldRefCount
=
mState
.
mExecutable
-
>
mActiveSamplerRefCounts
[
oldTextureUnit
]
;
uint32_t
&
newRefCount
=
mState
.
mExecutable
-
>
mActiveSamplerRefCounts
[
newTextureUnit
]
;
ASSERT
(
oldRefCount
>
0
)
;
ASSERT
(
newRefCount
<
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
)
;
oldRefCount
-
-
;
newRefCount
+
+
;
TextureType
&
newSamplerType
=
mState
.
mExecutable
-
>
mActiveSamplerTypes
[
newTextureUnit
]
;
TextureType
&
oldSamplerType
=
mState
.
mExecutable
-
>
mActiveSamplerTypes
[
oldTextureUnit
]
;
SamplerFormat
&
newSamplerFormat
=
mState
.
mExecutable
-
>
mActiveSamplerFormats
[
newTextureUnit
]
;
SamplerFormat
&
oldSamplerFormat
=
mState
.
mExecutable
-
>
mActiveSamplerFormats
[
oldTextureUnit
]
;
if
(
newRefCount
=
=
1
)
{
newSamplerType
=
samplerBinding
.
textureType
;
newSamplerFormat
=
samplerBinding
.
format
;
mState
.
mExecutable
-
>
mActiveSamplersMask
.
set
(
newTextureUnit
)
;
mState
.
mExecutable
-
>
mActiveSamplerShaderBits
[
newTextureUnit
]
=
mState
.
mExecutable
-
>
getUniforms
(
)
[
locationInfo
.
index
]
.
activeShaders
(
)
;
}
else
{
if
(
newSamplerType
!
=
samplerBinding
.
textureType
)
{
newSamplerType
=
TextureType
:
:
InvalidEnum
;
}
if
(
newSamplerFormat
!
=
samplerBinding
.
format
)
{
newSamplerFormat
=
SamplerFormat
:
:
InvalidEnum
;
}
}
if
(
oldRefCount
=
=
0
)
{
oldSamplerType
=
TextureType
:
:
InvalidEnum
;
oldSamplerFormat
=
SamplerFormat
:
:
InvalidEnum
;
mState
.
mExecutable
-
>
mActiveSamplersMask
.
reset
(
oldTextureUnit
)
;
}
else
{
if
(
oldSamplerType
=
=
TextureType
:
:
InvalidEnum
|
|
oldSamplerFormat
=
=
SamplerFormat
:
:
InvalidEnum
)
{
mState
.
setSamplerUniformTextureTypeAndFormat
(
oldTextureUnit
)
;
}
}
if
(
context
)
{
context
-
>
onSamplerUniformChange
(
newTextureUnit
)
;
context
-
>
onSamplerUniformChange
(
oldTextureUnit
)
;
}
}
mCachedValidateSamplersResult
.
reset
(
)
;
}
void
ProgramState
:
:
setSamplerUniformTextureTypeAndFormat
(
size_t
textureUnitIndex
)
{
mExecutable
-
>
setSamplerUniformTextureTypeAndFormat
(
textureUnitIndex
mExecutable
-
>
mSamplerBindings
)
;
}
template
<
typename
T
>
GLsizei
Program
:
:
clampUniformCount
(
const
VariableLocation
&
locationInfo
GLsizei
count
int
vectorSize
const
T
*
v
)
{
if
(
count
=
=
1
)
return
1
;
const
LinkedUniform
&
linkedUniform
=
mState
.
mExecutable
-
>
getUniforms
(
)
[
locationInfo
.
index
]
;
unsigned
int
remainingElements
=
linkedUniform
.
getBasicTypeElementCount
(
)
-
locationInfo
.
arrayIndex
;
GLsizei
maxElementCount
=
static_cast
<
GLsizei
>
(
remainingElements
*
linkedUniform
.
getElementComponents
(
)
)
;
if
(
count
*
vectorSize
>
maxElementCount
)
{
return
maxElementCount
/
vectorSize
;
}
return
count
;
}
template
<
size_t
cols
size_t
rows
typename
T
>
GLsizei
Program
:
:
clampMatrixUniformCount
(
UniformLocation
location
GLsizei
count
GLboolean
transpose
const
T
*
v
)
{
const
VariableLocation
&
locationInfo
=
mState
.
mUniformLocations
[
location
.
value
]
;
if
(
!
transpose
)
{
return
clampUniformCount
(
locationInfo
count
cols
*
rows
v
)
;
}
const
LinkedUniform
&
linkedUniform
=
mState
.
mExecutable
-
>
getUniforms
(
)
[
locationInfo
.
index
]
;
unsigned
int
remainingElements
=
linkedUniform
.
getBasicTypeElementCount
(
)
-
locationInfo
.
arrayIndex
;
return
std
:
:
min
(
count
static_cast
<
GLsizei
>
(
remainingElements
)
)
;
}
template
<
typename
DestT
>
void
Program
:
:
getUniformInternal
(
const
Context
*
context
DestT
*
dataOut
UniformLocation
location
GLenum
nativeType
int
components
)
const
{
switch
(
nativeType
)
{
case
GL_BOOL
:
{
GLint
tempValue
[
16
]
=
{
0
}
;
mProgram
-
>
getUniformiv
(
context
location
.
value
tempValue
)
;
UniformStateQueryCastLoop
<
GLboolean
>
(
dataOut
reinterpret_cast
<
const
uint8_t
*
>
(
tempValue
)
components
)
;
break
;
}
case
GL_INT
:
{
GLint
tempValue
[
16
]
=
{
0
}
;
mProgram
-
>
getUniformiv
(
context
location
.
value
tempValue
)
;
UniformStateQueryCastLoop
<
GLint
>
(
dataOut
reinterpret_cast
<
const
uint8_t
*
>
(
tempValue
)
components
)
;
break
;
}
case
GL_UNSIGNED_INT
:
{
GLuint
tempValue
[
16
]
=
{
0
}
;
mProgram
-
>
getUniformuiv
(
context
location
.
value
tempValue
)
;
UniformStateQueryCastLoop
<
GLuint
>
(
dataOut
reinterpret_cast
<
const
uint8_t
*
>
(
tempValue
)
components
)
;
break
;
}
case
GL_FLOAT
:
{
GLfloat
tempValue
[
16
]
=
{
0
}
;
mProgram
-
>
getUniformfv
(
context
location
.
value
tempValue
)
;
UniformStateQueryCastLoop
<
GLfloat
>
(
dataOut
reinterpret_cast
<
const
uint8_t
*
>
(
tempValue
)
components
)
;
break
;
}
default
:
UNREACHABLE
(
)
;
break
;
}
}
angle
:
:
Result
Program
:
:
syncState
(
const
Context
*
context
)
{
if
(
mDirtyBits
.
any
(
)
)
{
ASSERT
(
!
mLinkingState
)
;
ANGLE_TRY
(
mProgram
-
>
syncState
(
context
mDirtyBits
)
)
;
mDirtyBits
.
reset
(
)
;
}
return
angle
:
:
Result
:
:
Continue
;
}
angle
:
:
Result
Program
:
:
serialize
(
const
Context
*
context
angle
:
:
MemoryBuffer
*
binaryOut
)
const
{
BinaryOutputStream
stream
;
stream
.
writeBytes
(
reinterpret_cast
<
const
unsigned
char
*
>
(
ANGLE_COMMIT_HASH
)
ANGLE_COMMIT_HASH_SIZE
)
;
if
(
context
)
{
stream
.
writeInt
(
context
-
>
getClientVersion
(
)
.
major
)
;
stream
.
writeInt
(
context
-
>
getClientVersion
(
)
.
minor
)
;
}
else
{
stream
.
writeInt
(
2
)
;
stream
.
writeInt
(
0
)
;
}
mState
.
mExecutable
-
>
save
(
&
stream
)
;
const
auto
&
computeLocalSize
=
mState
.
getComputeShaderLocalSize
(
)
;
stream
.
writeInt
(
computeLocalSize
[
0
]
)
;
stream
.
writeInt
(
computeLocalSize
[
1
]
)
;
stream
.
writeInt
(
computeLocalSize
[
2
]
)
;
ASSERT
(
mState
.
mGeometryShaderInvocations
>
=
1
&
&
mState
.
mGeometryShaderMaxVertices
>
=
0
)
;
stream
.
writeEnum
(
mState
.
mGeometryShaderInputPrimitiveType
)
;
stream
.
writeEnum
(
mState
.
mGeometryShaderOutputPrimitiveType
)
;
stream
.
writeInt
(
mState
.
mGeometryShaderInvocations
)
;
stream
.
writeInt
(
mState
.
mGeometryShaderMaxVertices
)
;
stream
.
writeInt
(
mState
.
mNumViews
)
;
stream
.
writeBool
(
mState
.
mEarlyFramentTestsOptimization
)
;
stream
.
writeInt
(
mState
.
getProgramInputs
(
)
.
size
(
)
)
;
for
(
const
sh
:
:
ShaderVariable
&
attrib
:
mState
.
getProgramInputs
(
)
)
{
WriteShaderVar
(
&
stream
attrib
)
;
stream
.
writeInt
(
attrib
.
location
)
;
}
stream
.
writeInt
(
mState
.
getUniforms
(
)
.
size
(
)
)
;
for
(
const
LinkedUniform
&
uniform
:
mState
.
getUniforms
(
)
)
{
WriteShaderVar
(
&
stream
uniform
)
;
stream
.
writeInt
(
uniform
.
bufferIndex
)
;
WriteBlockMemberInfo
(
&
stream
uniform
.
blockInfo
)
;
stream
.
writeIntVector
(
uniform
.
outerArraySizes
)
;
for
(
ShaderType
shaderType
:
gl
:
:
AllShaderTypes
(
)
)
{
stream
.
writeBool
(
uniform
.
isActive
(
shaderType
)
)
;
}
}
stream
.
writeInt
(
mState
.
getUniformLocations
(
)
.
size
(
)
)
;
for
(
const
auto
&
variable
:
mState
.
getUniformLocations
(
)
)
{
stream
.
writeInt
(
variable
.
arrayIndex
)
;
stream
.
writeIntOrNegOne
(
variable
.
index
)
;
stream
.
writeBool
(
variable
.
ignored
)
;
}
stream
.
writeInt
(
mState
.
getUniformBlocks
(
)
.
size
(
)
)
;
for
(
const
InterfaceBlock
&
uniformBlock
:
mState
.
getUniformBlocks
(
)
)
{
WriteInterfaceBlock
(
&
stream
uniformBlock
)
;
}
stream
.
writeInt
(
mState
.
getBufferVariables
(
)
.
size
(
)
)
;
for
(
const
BufferVariable
&
bufferVariable
:
mState
.
getBufferVariables
(
)
)
{
WriteBufferVariable
(
&
stream
bufferVariable
)
;
}
stream
.
writeInt
(
mState
.
getShaderStorageBlocks
(
)
.
size
(
)
)
;
for
(
const
InterfaceBlock
&
shaderStorageBlock
:
mState
.
getShaderStorageBlocks
(
)
)
{
WriteInterfaceBlock
(
&
stream
shaderStorageBlock
)
;
}
stream
.
writeInt
(
mState
.
mExecutable
-
>
mAtomicCounterBuffers
.
size
(
)
)
;
for
(
const
AtomicCounterBuffer
&
atomicCounterBuffer
:
mState
.
mExecutable
-
>
getAtomicCounterBuffers
(
)
)
{
WriteShaderVariableBuffer
(
&
stream
atomicCounterBuffer
)
;
}
if
(
!
mState
.
getLinkedTransformFeedbackVaryings
(
)
.
empty
(
)
&
&
context
-
>
getFrontendFeatures
(
)
.
disableProgramCachingForTransformFeedback
.
enabled
)
{
WARN
(
)
<
<
"
Saving
program
binary
with
transform
feedback
which
is
not
supported
on
this
"
"
driver
.
"
;
}
stream
.
writeInt
(
mState
.
getLinkedTransformFeedbackVaryings
(
)
.
size
(
)
)
;
for
(
const
auto
&
var
:
mState
.
getLinkedTransformFeedbackVaryings
(
)
)
{
stream
.
writeIntVector
(
var
.
arraySizes
)
;
stream
.
writeInt
(
var
.
type
)
;
stream
.
writeString
(
var
.
name
)
;
stream
.
writeIntOrNegOne
(
var
.
arrayIndex
)
;
}
stream
.
writeInt
(
mState
.
getTransformFeedbackBufferMode
(
)
)
;
stream
.
writeInt
(
mState
.
getOutputVariables
(
)
.
size
(
)
)
;
for
(
const
sh
:
:
ShaderVariable
&
output
:
mState
.
getOutputVariables
(
)
)
{
WriteShaderVar
(
&
stream
output
)
;
stream
.
writeInt
(
output
.
location
)
;
stream
.
writeInt
(
output
.
index
)
;
}
stream
.
writeInt
(
mState
.
getOutputLocations
(
)
.
size
(
)
)
;
for
(
const
auto
&
outputVar
:
mState
.
getOutputLocations
(
)
)
{
stream
.
writeInt
(
outputVar
.
arrayIndex
)
;
stream
.
writeIntOrNegOne
(
outputVar
.
index
)
;
stream
.
writeBool
(
outputVar
.
ignored
)
;
}
stream
.
writeInt
(
mState
.
getSecondaryOutputLocations
(
)
.
size
(
)
)
;
for
(
const
auto
&
outputVar
:
mState
.
getSecondaryOutputLocations
(
)
)
{
stream
.
writeInt
(
outputVar
.
arrayIndex
)
;
stream
.
writeIntOrNegOne
(
outputVar
.
index
)
;
stream
.
writeBool
(
outputVar
.
ignored
)
;
}
stream
.
writeInt
(
mState
.
mOutputVariableTypes
.
size
(
)
)
;
for
(
const
auto
&
outputVariableType
:
mState
.
mOutputVariableTypes
)
{
stream
.
writeInt
(
outputVariableType
)
;
}
static_assert
(
IMPLEMENTATION_MAX_DRAW_BUFFERS
*
2
<
=
8
*
sizeof
(
uint32_t
)
"
All
bits
of
mDrawBufferTypeMask
and
mActiveOutputVariables
can
be
contained
in
32
bits
"
)
;
stream
.
writeInt
(
static_cast
<
int
>
(
mState
.
mDrawBufferTypeMask
.
to_ulong
(
)
)
)
;
stream
.
writeInt
(
static_cast
<
int
>
(
mState
.
mActiveOutputVariables
.
to_ulong
(
)
)
)
;
stream
.
writeInt
(
mState
.
getDefaultUniformRange
(
)
.
low
(
)
)
;
stream
.
writeInt
(
mState
.
getDefaultUniformRange
(
)
.
high
(
)
)
;
stream
.
writeInt
(
mState
.
getSamplerUniformRange
(
)
.
low
(
)
)
;
stream
.
writeInt
(
mState
.
getSamplerUniformRange
(
)
.
high
(
)
)
;
stream
.
writeInt
(
mState
.
getSamplerBindings
(
)
.
size
(
)
)
;
for
(
const
auto
&
samplerBinding
:
mState
.
getSamplerBindings
(
)
)
{
stream
.
writeEnum
(
samplerBinding
.
textureType
)
;
stream
.
writeEnum
(
samplerBinding
.
format
)
;
stream
.
writeInt
(
samplerBinding
.
boundTextureUnits
.
size
(
)
)
;
}
stream
.
writeInt
(
mState
.
getImageUniformRange
(
)
.
low
(
)
)
;
stream
.
writeInt
(
mState
.
getImageUniformRange
(
)
.
high
(
)
)
;
stream
.
writeInt
(
mState
.
getImageBindings
(
)
.
size
(
)
)
;
for
(
const
auto
&
imageBinding
:
mState
.
getImageBindings
(
)
)
{
stream
.
writeInt
(
imageBinding
.
boundImageUnits
.
size
(
)
)
;
for
(
size_t
i
=
0
;
i
<
imageBinding
.
boundImageUnits
.
size
(
)
;
+
+
i
)
{
stream
.
writeInt
(
imageBinding
.
boundImageUnits
[
i
]
)
;
}
}
stream
.
writeInt
(
mState
.
getAtomicCounterUniformRange
(
)
.
low
(
)
)
;
stream
.
writeInt
(
mState
.
getAtomicCounterUniformRange
(
)
.
high
(
)
)
;
mProgram
-
>
save
(
context
&
stream
)
;
ASSERT
(
binaryOut
)
;
if
(
!
binaryOut
-
>
resize
(
stream
.
length
(
)
)
)
{
WARN
(
)
<
<
"
Failed
to
allocate
enough
memory
to
serialize
a
program
.
(
"
<
<
stream
.
length
(
)
<
<
"
bytes
)
"
;
return
angle
:
:
Result
:
:
Incomplete
;
}
memcpy
(
binaryOut
-
>
data
(
)
stream
.
data
(
)
stream
.
length
(
)
)
;
return
angle
:
:
Result
:
:
Continue
;
}
angle
:
:
Result
Program
:
:
deserialize
(
const
Context
*
context
BinaryInputStream
&
stream
InfoLog
&
infoLog
)
{
unsigned
char
commitString
[
ANGLE_COMMIT_HASH_SIZE
]
;
stream
.
readBytes
(
commitString
ANGLE_COMMIT_HASH_SIZE
)
;
if
(
memcmp
(
commitString
ANGLE_COMMIT_HASH
sizeof
(
unsigned
char
)
*
ANGLE_COMMIT_HASH_SIZE
)
!
=
0
)
{
infoLog
<
<
"
Invalid
program
binary
version
.
"
;
return
angle
:
:
Result
:
:
Incomplete
;
}
int
majorVersion
=
stream
.
readInt
<
int
>
(
)
;
int
minorVersion
=
stream
.
readInt
<
int
>
(
)
;
if
(
majorVersion
!
=
context
-
>
getClientMajorVersion
(
)
|
|
minorVersion
!
=
context
-
>
getClientMinorVersion
(
)
)
{
infoLog
<
<
"
Cannot
load
program
binaries
across
different
ES
context
versions
.
"
;
return
angle
:
:
Result
:
:
Incomplete
;
}
mState
.
mExecutable
-
>
load
(
&
stream
)
;
mState
.
mComputeShaderLocalSize
[
0
]
=
stream
.
readInt
<
int
>
(
)
;
mState
.
mComputeShaderLocalSize
[
1
]
=
stream
.
readInt
<
int
>
(
)
;
mState
.
mComputeShaderLocalSize
[
2
]
=
stream
.
readInt
<
int
>
(
)
;
mState
.
mGeometryShaderInputPrimitiveType
=
stream
.
readEnum
<
PrimitiveMode
>
(
)
;
mState
.
mGeometryShaderOutputPrimitiveType
=
stream
.
readEnum
<
PrimitiveMode
>
(
)
;
mState
.
mGeometryShaderInvocations
=
stream
.
readInt
<
int
>
(
)
;
mState
.
mGeometryShaderMaxVertices
=
stream
.
readInt
<
int
>
(
)
;
mState
.
mNumViews
=
stream
.
readInt
<
int
>
(
)
;
mState
.
mEarlyFramentTestsOptimization
=
stream
.
readBool
(
)
;
size_t
attribCount
=
stream
.
readInt
<
size_t
>
(
)
;
ASSERT
(
mState
.
mExecutable
-
>
getProgramInputs
(
)
.
empty
(
)
)
;
for
(
size_t
attribIndex
=
0
;
attribIndex
<
attribCount
;
+
+
attribIndex
)
{
sh
:
:
ShaderVariable
attrib
;
LoadShaderVar
(
&
stream
&
attrib
)
;
attrib
.
location
=
stream
.
readInt
<
int
>
(
)
;
mState
.
mExecutable
-
>
mProgramInputs
.
push_back
(
attrib
)
;
}
size_t
uniformCount
=
stream
.
readInt
<
size_t
>
(
)
;
ASSERT
(
mState
.
mExecutable
-
>
getUniforms
(
)
.
empty
(
)
)
;
for
(
size_t
uniformIndex
=
0
;
uniformIndex
<
uniformCount
;
+
+
uniformIndex
)
{
LinkedUniform
uniform
;
LoadShaderVar
(
&
stream
&
uniform
)
;
uniform
.
bufferIndex
=
stream
.
readInt
<
int
>
(
)
;
LoadBlockMemberInfo
(
&
stream
&
uniform
.
blockInfo
)
;
stream
.
readIntVector
<
unsigned
int
>
(
&
uniform
.
outerArraySizes
)
;
uniform
.
typeInfo
=
&
GetUniformTypeInfo
(
uniform
.
type
)
;
for
(
ShaderType
shaderType
:
gl
:
:
AllShaderTypes
(
)
)
{
uniform
.
setActive
(
shaderType
stream
.
readBool
(
)
)
;
}
mState
.
mExecutable
-
>
mUniforms
.
push_back
(
uniform
)
;
}
const
size_t
uniformIndexCount
=
stream
.
readInt
<
size_t
>
(
)
;
ASSERT
(
mState
.
mUniformLocations
.
empty
(
)
)
;
for
(
size_t
uniformIndexIndex
=
0
;
uniformIndexIndex
<
uniformIndexCount
;
+
+
uniformIndexIndex
)
{
VariableLocation
variable
;
stream
.
readInt
(
&
variable
.
arrayIndex
)
;
stream
.
readInt
(
&
variable
.
index
)
;
stream
.
readBool
(
&
variable
.
ignored
)
;
mState
.
mUniformLocations
.
push_back
(
variable
)
;
}
size_t
uniformBlockCount
=
stream
.
readInt
<
size_t
>
(
)
;
ASSERT
(
mState
.
mExecutable
-
>
getUniformBlocks
(
)
.
empty
(
)
)
;
for
(
size_t
uniformBlockIndex
=
0
;
uniformBlockIndex
<
uniformBlockCount
;
+
+
uniformBlockIndex
)
{
InterfaceBlock
uniformBlock
;
LoadInterfaceBlock
(
&
stream
&
uniformBlock
)
;
mState
.
mExecutable
-
>
mUniformBlocks
.
push_back
(
uniformBlock
)
;
mState
.
mActiveUniformBlockBindings
.
set
(
uniformBlockIndex
uniformBlock
.
binding
!
=
0
)
;
}
size_t
bufferVariableCount
=
stream
.
readInt
<
size_t
>
(
)
;
ASSERT
(
mState
.
mBufferVariables
.
empty
(
)
)
;
for
(
size_t
bufferVarIndex
=
0
;
bufferVarIndex
<
bufferVariableCount
;
+
+
bufferVarIndex
)
{
BufferVariable
bufferVariable
;
LoadBufferVariable
(
&
stream
&
bufferVariable
)
;
mState
.
mBufferVariables
.
push_back
(
bufferVariable
)
;
}
size_t
shaderStorageBlockCount
=
stream
.
readInt
<
size_t
>
(
)
;
ASSERT
(
mState
.
mExecutable
-
>
getShaderStorageBlocks
(
)
.
empty
(
)
)
;
for
(
size_t
shaderStorageBlockIndex
=
0
;
shaderStorageBlockIndex
<
shaderStorageBlockCount
;
+
+
shaderStorageBlockIndex
)
{
InterfaceBlock
shaderStorageBlock
;
LoadInterfaceBlock
(
&
stream
&
shaderStorageBlock
)
;
if
(
getExecutable
(
)
.
isCompute
(
)
)
{
mState
.
mExecutable
-
>
mComputeShaderStorageBlocks
.
push_back
(
shaderStorageBlock
)
;
}
else
{
mState
.
mExecutable
-
>
mGraphicsShaderStorageBlocks
.
push_back
(
shaderStorageBlock
)
;
}
}
size_t
atomicCounterBufferCount
=
stream
.
readInt
<
size_t
>
(
)
;
ASSERT
(
mState
.
mExecutable
-
>
getAtomicCounterBuffers
(
)
.
empty
(
)
)
;
for
(
size_t
bufferIndex
=
0
;
bufferIndex
<
atomicCounterBufferCount
;
+
+
bufferIndex
)
{
AtomicCounterBuffer
atomicCounterBuffer
;
LoadShaderVariableBuffer
(
&
stream
&
atomicCounterBuffer
)
;
mState
.
mExecutable
-
>
mAtomicCounterBuffers
.
push_back
(
atomicCounterBuffer
)
;
}
size_t
transformFeedbackVaryingCount
=
stream
.
readInt
<
size_t
>
(
)
;
if
(
transformFeedbackVaryingCount
>
0
&
&
context
-
>
getFrontendFeatures
(
)
.
disableProgramCachingForTransformFeedback
.
enabled
)
{
infoLog
<
<
"
Current
driver
does
not
support
transform
feedback
in
binary
programs
.
"
;
return
angle
:
:
Result
:
:
Incomplete
;
}
ASSERT
(
mState
.
mExecutable
-
>
mLinkedTransformFeedbackVaryings
.
empty
(
)
)
;
for
(
size_t
transformFeedbackVaryingIndex
=
0
;
transformFeedbackVaryingIndex
<
transformFeedbackVaryingCount
;
+
+
transformFeedbackVaryingIndex
)
{
sh
:
:
ShaderVariable
varying
;
stream
.
readIntVector
<
unsigned
int
>
(
&
varying
.
arraySizes
)
;
stream
.
readInt
(
&
varying
.
type
)
;
stream
.
readString
(
&
varying
.
name
)
;
GLuint
arrayIndex
=
stream
.
readInt
<
GLuint
>
(
)
;
mState
.
mExecutable
-
>
mLinkedTransformFeedbackVaryings
.
emplace_back
(
varying
arrayIndex
)
;
}
stream
.
readInt
(
&
mState
.
mExecutable
-
>
mTransformFeedbackBufferMode
)
;
size_t
outputCount
=
stream
.
readInt
<
size_t
>
(
)
;
ASSERT
(
mState
.
mExecutable
-
>
getOutputVariables
(
)
.
empty
(
)
)
;
for
(
size_t
outputIndex
=
0
;
outputIndex
<
outputCount
;
+
+
outputIndex
)
{
sh
:
:
ShaderVariable
output
;
LoadShaderVar
(
&
stream
&
output
)
;
output
.
location
=
stream
.
readInt
<
int
>
(
)
;
output
.
index
=
stream
.
readInt
<
int
>
(
)
;
mState
.
mExecutable
-
>
mOutputVariables
.
push_back
(
output
)
;
}
size_t
outputVarCount
=
stream
.
readInt
<
size_t
>
(
)
;
ASSERT
(
mState
.
mExecutable
-
>
getOutputLocations
(
)
.
empty
(
)
)
;
for
(
size_t
outputIndex
=
0
;
outputIndex
<
outputVarCount
;
+
+
outputIndex
)
{
VariableLocation
locationData
;
stream
.
readInt
(
&
locationData
.
arrayIndex
)
;
stream
.
readInt
(
&
locationData
.
index
)
;
stream
.
readBool
(
&
locationData
.
ignored
)
;
mState
.
mExecutable
-
>
mOutputLocations
.
push_back
(
locationData
)
;
}
size_t
secondaryOutputVarCount
=
stream
.
readInt
<
size_t
>
(
)
;
ASSERT
(
mState
.
mSecondaryOutputLocations
.
empty
(
)
)
;
for
(
size_t
outputIndex
=
0
;
outputIndex
<
secondaryOutputVarCount
;
+
+
outputIndex
)
{
VariableLocation
locationData
;
stream
.
readInt
(
&
locationData
.
arrayIndex
)
;
stream
.
readInt
(
&
locationData
.
index
)
;
stream
.
readBool
(
&
locationData
.
ignored
)
;
mState
.
mSecondaryOutputLocations
.
push_back
(
locationData
)
;
}
size_t
outputTypeCount
=
stream
.
readInt
<
size_t
>
(
)
;
for
(
size_t
outputIndex
=
0
;
outputIndex
<
outputTypeCount
;
+
+
outputIndex
)
{
mState
.
mOutputVariableTypes
.
push_back
(
stream
.
readInt
<
GLenum
>
(
)
)
;
}
static_assert
(
IMPLEMENTATION_MAX_DRAW_BUFFERS
*
2
<
=
8
*
sizeof
(
uint32_t
)
"
All
bits
of
mDrawBufferTypeMask
and
mActiveOutputVariables
types
and
mask
fit
"
"
into
32
bits
each
"
)
;
mState
.
mDrawBufferTypeMask
=
gl
:
:
ComponentTypeMask
(
stream
.
readInt
<
uint32_t
>
(
)
)
;
mState
.
mActiveOutputVariables
=
gl
:
:
DrawBufferMask
(
stream
.
readInt
<
gl
:
:
DrawBufferMask
:
:
value_type
>
(
)
)
;
unsigned
int
defaultUniformRangeLow
=
stream
.
readInt
<
unsigned
int
>
(
)
;
unsigned
int
defaultUniformRangeHigh
=
stream
.
readInt
<
unsigned
int
>
(
)
;
mState
.
mExecutable
-
>
mDefaultUniformRange
=
RangeUI
(
defaultUniformRangeLow
defaultUniformRangeHigh
)
;
unsigned
int
samplerRangeLow
=
stream
.
readInt
<
unsigned
int
>
(
)
;
unsigned
int
samplerRangeHigh
=
stream
.
readInt
<
unsigned
int
>
(
)
;
mState
.
mExecutable
-
>
mSamplerUniformRange
=
RangeUI
(
samplerRangeLow
samplerRangeHigh
)
;
size_t
samplerCount
=
stream
.
readInt
<
size_t
>
(
)
;
for
(
size_t
samplerIndex
=
0
;
samplerIndex
<
samplerCount
;
+
+
samplerIndex
)
{
TextureType
textureType
=
stream
.
readEnum
<
TextureType
>
(
)
;
SamplerFormat
format
=
stream
.
readEnum
<
SamplerFormat
>
(
)
;
size_t
bindingCount
=
stream
.
readInt
<
size_t
>
(
)
;
mState
.
mExecutable
-
>
mSamplerBindings
.
emplace_back
(
textureType
format
bindingCount
)
;
}
unsigned
int
imageRangeLow
=
stream
.
readInt
<
unsigned
int
>
(
)
;
unsigned
int
imageRangeHigh
=
stream
.
readInt
<
unsigned
int
>
(
)
;
mState
.
mExecutable
-
>
mImageUniformRange
=
RangeUI
(
imageRangeLow
imageRangeHigh
)
;
size_t
imageBindingCount
=
stream
.
readInt
<
size_t
>
(
)
;
for
(
size_t
imageIndex
=
0
;
imageIndex
<
imageBindingCount
;
+
+
imageIndex
)
{
size_t
elementCount
=
stream
.
readInt
<
size_t
>
(
)
;
ImageBinding
imageBinding
(
elementCount
)
;
for
(
size_t
elementIndex
=
0
;
elementIndex
<
elementCount
;
+
+
elementIndex
)
{
imageBinding
.
boundImageUnits
[
elementIndex
]
=
stream
.
readInt
<
unsigned
int
>
(
)
;
}
if
(
getExecutable
(
)
.
isCompute
(
)
)
{
mState
.
mExecutable
-
>
mComputeImageBindings
.
emplace_back
(
imageBinding
)
;
}
else
{
mState
.
mExecutable
-
>
mGraphicsImageBindings
.
emplace_back
(
imageBinding
)
;
}
}
unsigned
int
atomicCounterRangeLow
=
stream
.
readInt
<
unsigned
int
>
(
)
;
unsigned
int
atomicCounterRangeHigh
=
stream
.
readInt
<
unsigned
int
>
(
)
;
mState
.
mAtomicCounterUniformRange
=
RangeUI
(
atomicCounterRangeLow
atomicCounterRangeHigh
)
;
static_assert
(
static_cast
<
unsigned
long
>
(
ShaderType
:
:
EnumCount
)
<
=
sizeof
(
unsigned
long
)
*
8
"
Too
many
shader
types
"
)
;
if
(
!
mState
.
mAttachedShaders
[
ShaderType
:
:
Compute
]
)
{
mState
.
updateTransformFeedbackStrides
(
)
;
}
postResolveLink
(
context
)
;
mState
.
mExecutable
-
>
updateCanDrawWith
(
)
;
return
angle
:
:
Result
:
:
Continue
;
}
void
Program
:
:
postResolveLink
(
const
gl
:
:
Context
*
context
)
{
mState
.
updateActiveSamplers
(
)
;
mState
.
mExecutable
-
>
updateActiveImages
(
getExecutable
(
)
)
;
setUniformValuesFromBindingQualifiers
(
)
;
if
(
context
-
>
getExtensions
(
)
.
multiDraw
)
{
mState
.
mDrawIDLocation
=
getUniformLocation
(
"
gl_DrawID
"
)
.
value
;
}
if
(
context
-
>
getExtensions
(
)
.
baseVertexBaseInstance
)
{
mState
.
mBaseVertexLocation
=
getUniformLocation
(
"
gl_BaseVertex
"
)
.
value
;
mState
.
mBaseInstanceLocation
=
getUniformLocation
(
"
gl_BaseInstance
"
)
.
value
;
}
}
void
Program
:
:
fillProgramStateMap
(
ShaderMap
<
const
ProgramState
*
>
*
programStatesOut
)
{
for
(
ShaderType
shaderType
:
AllShaderTypes
(
)
)
{
(
*
programStatesOut
)
[
shaderType
]
=
nullptr
;
if
(
mState
.
getExecutable
(
)
.
hasLinkedShaderStage
(
shaderType
)
|
|
mState
.
getAttachedShader
(
shaderType
)
)
{
(
*
programStatesOut
)
[
shaderType
]
=
&
mState
;
}
}
}
}
