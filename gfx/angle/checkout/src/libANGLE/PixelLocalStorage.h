#
ifndef
LIBANGLE_PIXEL_LOCAL_STORAGE_H_
#
define
LIBANGLE_PIXEL_LOCAL_STORAGE_H_
#
include
"
angle_gl
.
h
"
#
include
"
libANGLE
/
ImageIndex
.
h
"
#
include
"
libANGLE
/
angletypes
.
h
"
namespace
gl
{
class
Context
;
class
Texture
;
class
PixelLocalStoragePlane
:
angle
:
:
NonCopyable
{
public
:
~
PixelLocalStoragePlane
(
)
;
void
onContextObjectsLost
(
)
;
void
onFramebufferDestroyed
(
const
Context
*
)
;
void
deinitialize
(
Context
*
)
;
void
setMemoryless
(
Context
*
GLenum
internalformat
)
;
void
setTextureBacked
(
Context
*
Texture
*
int
level
int
layer
)
;
bool
isDeinitialized
(
)
const
{
return
mInternalformat
=
=
GL_NONE
;
}
bool
isTextureIDDeleted
(
const
Context
*
)
const
;
bool
isMemoryless
(
)
const
{
ASSERT
(
!
(
isDeinitialized
(
)
&
&
mMemoryless
)
)
;
return
mMemoryless
;
}
GLenum
getInternalformat
(
)
const
{
return
mInternalformat
;
}
GLint
getIntegeri
(
const
Context
*
GLenum
target
GLuint
index
)
const
;
bool
getTextureImageExtents
(
const
Context
*
Extents
*
extents
)
const
;
void
attachToDrawFramebuffer
(
Context
*
Extents
plsExtents
GLenum
colorAttachment
)
;
void
performLoadOperationClear
(
Context
*
GLint
drawbuffer
GLenum
loadop
const
void
*
data
)
;
void
bindToImage
(
Context
*
Extents
plsExtents
GLuint
unit
bool
needsR32Packing
)
;
private
:
void
ensureBackingIfMemoryless
(
Context
*
Extents
plsSize
)
;
GLenum
mInternalformat
=
GL_NONE
;
bool
mMemoryless
=
false
;
TextureID
mMemorylessTextureID
{
}
;
ImageIndex
mTextureImageIndex
;
Texture
*
mTextureRef
=
nullptr
;
}
;
class
PixelLocalStorage
{
public
:
static
std
:
:
unique_ptr
<
PixelLocalStorage
>
Make
(
const
Context
*
)
;
PixelLocalStorage
(
)
;
virtual
~
PixelLocalStorage
(
)
;
void
onFramebufferDestroyed
(
const
Context
*
)
;
void
deleteContextObjects
(
Context
*
)
;
const
PixelLocalStoragePlane
&
getPlane
(
GLint
plane
)
const
{
ASSERT
(
0
<
=
plane
&
&
plane
<
IMPLEMENTATION_MAX_PIXEL_LOCAL_STORAGE_PLANES
)
;
return
mPlanes
[
plane
]
;
}
PixelLocalStoragePlane
&
getPlane
(
GLint
plane
)
{
ASSERT
(
0
<
=
plane
&
&
plane
<
IMPLEMENTATION_MAX_PIXEL_LOCAL_STORAGE_PLANES
)
;
return
mPlanes
[
plane
]
;
}
void
deinitialize
(
Context
*
context
GLint
plane
)
{
mPlanes
[
plane
]
.
deinitialize
(
context
)
;
}
void
setMemoryless
(
Context
*
context
GLint
plane
GLenum
internalformat
)
{
mPlanes
[
plane
]
.
setMemoryless
(
context
internalformat
)
;
}
void
setTextureBacked
(
Context
*
context
GLint
plane
Texture
*
tex
int
level
int
layer
)
{
mPlanes
[
plane
]
.
setTextureBacked
(
context
tex
level
layer
)
;
}
void
begin
(
Context
*
GLsizei
n
const
GLenum
loadops
[
]
const
void
*
cleardata
)
;
void
end
(
Context
*
)
;
void
barrier
(
Context
*
)
;
protected
:
virtual
void
onContextObjectsLost
(
)
=
0
;
virtual
void
onDeleteContextObjects
(
Context
*
)
=
0
;
virtual
void
onBegin
(
Context
*
GLsizei
n
const
GLenum
loadops
[
]
const
char
*
cleardata
Extents
plsSize
)
=
0
;
virtual
void
onEnd
(
Context
*
GLsizei
numActivePLSPlanes
)
=
0
;
virtual
void
onBarrier
(
Context
*
)
=
0
;
private
:
std
:
:
array
<
PixelLocalStoragePlane
IMPLEMENTATION_MAX_PIXEL_LOCAL_STORAGE_PLANES
>
mPlanes
;
GLsizei
mNumActivePLSPlanes
=
0
;
}
;
}
#
endif
