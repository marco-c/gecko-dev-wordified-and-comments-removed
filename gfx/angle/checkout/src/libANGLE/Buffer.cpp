#
include
"
libANGLE
/
Buffer
.
h
"
#
include
"
libANGLE
/
Context
.
h
"
#
include
"
libANGLE
/
renderer
/
BufferImpl
.
h
"
#
include
"
libANGLE
/
renderer
/
GLImplFactory
.
h
"
namespace
gl
{
BufferState
:
:
BufferState
(
)
:
mLabel
(
)
mUsage
(
BufferUsage
:
:
StaticDraw
)
mSize
(
0
)
mAccessFlags
(
0
)
mAccess
(
GL_WRITE_ONLY_OES
)
mMapped
(
GL_FALSE
)
mMapPointer
(
nullptr
)
mMapOffset
(
0
)
mMapLength
(
0
)
mBindingCount
(
0
)
mTransformFeedbackBindingCount
(
0
)
{
}
BufferState
:
:
~
BufferState
(
)
{
}
Buffer
:
:
Buffer
(
rx
:
:
GLImplFactory
*
factory
GLuint
id
)
:
RefCountObject
(
id
)
mImpl
(
factory
-
>
createBuffer
(
mState
)
)
{
}
Buffer
:
:
~
Buffer
(
)
{
SafeDelete
(
mImpl
)
;
}
Error
Buffer
:
:
onDestroy
(
const
Context
*
context
)
{
if
(
mImpl
)
mImpl
-
>
destroy
(
context
)
;
return
NoError
(
)
;
}
void
Buffer
:
:
setLabel
(
const
std
:
:
string
&
label
)
{
mState
.
mLabel
=
label
;
}
const
std
:
:
string
&
Buffer
:
:
getLabel
(
)
const
{
return
mState
.
mLabel
;
}
Error
Buffer
:
:
bufferData
(
const
Context
*
context
BufferBinding
target
const
void
*
data
GLsizeiptr
size
BufferUsage
usage
)
{
const
void
*
dataForImpl
=
data
;
if
(
context
&
&
context
-
>
getGLState
(
)
.
isRobustResourceInitEnabled
(
)
&
&
!
data
&
&
size
>
0
)
{
angle
:
:
MemoryBuffer
*
scratchBuffer
=
nullptr
;
ANGLE_TRY
(
context
-
>
getZeroFilledBuffer
(
static_cast
<
size_t
>
(
size
)
&
scratchBuffer
)
)
;
dataForImpl
=
scratchBuffer
-
>
data
(
)
;
}
ANGLE_TRY
(
mImpl
-
>
setData
(
context
target
dataForImpl
size
usage
)
)
;
mIndexRangeCache
.
clear
(
)
;
mState
.
mUsage
=
usage
;
mState
.
mSize
=
size
;
mImpl
-
>
onStateChange
(
context
angle
:
:
SubjectMessage
:
:
STORAGE_CHANGED
)
;
return
NoError
(
)
;
}
Error
Buffer
:
:
bufferSubData
(
const
Context
*
context
BufferBinding
target
const
void
*
data
GLsizeiptr
size
GLintptr
offset
)
{
ANGLE_TRY
(
mImpl
-
>
setSubData
(
context
target
data
size
offset
)
)
;
mIndexRangeCache
.
invalidateRange
(
static_cast
<
unsigned
int
>
(
offset
)
static_cast
<
unsigned
int
>
(
size
)
)
;
mImpl
-
>
onStateChange
(
context
angle
:
:
SubjectMessage
:
:
CONTENTS_CHANGED
)
;
return
NoError
(
)
;
}
Error
Buffer
:
:
copyBufferSubData
(
const
Context
*
context
Buffer
*
source
GLintptr
sourceOffset
GLintptr
destOffset
GLsizeiptr
size
)
{
ANGLE_TRY
(
mImpl
-
>
copySubData
(
context
source
-
>
getImplementation
(
)
sourceOffset
destOffset
size
)
)
;
mIndexRangeCache
.
invalidateRange
(
static_cast
<
unsigned
int
>
(
destOffset
)
static_cast
<
unsigned
int
>
(
size
)
)
;
mImpl
-
>
onStateChange
(
context
angle
:
:
SubjectMessage
:
:
CONTENTS_CHANGED
)
;
return
NoError
(
)
;
}
Error
Buffer
:
:
map
(
const
Context
*
context
GLenum
access
)
{
ASSERT
(
!
mState
.
mMapped
)
;
mState
.
mMapPointer
=
nullptr
;
ANGLE_TRY
(
mImpl
-
>
map
(
context
access
&
mState
.
mMapPointer
)
)
;
ASSERT
(
access
=
=
GL_WRITE_ONLY_OES
)
;
mState
.
mMapped
=
GL_TRUE
;
mState
.
mMapOffset
=
0
;
mState
.
mMapLength
=
mState
.
mSize
;
mState
.
mAccess
=
access
;
mState
.
mAccessFlags
=
GL_MAP_WRITE_BIT
;
mIndexRangeCache
.
clear
(
)
;
return
NoError
(
)
;
}
Error
Buffer
:
:
mapRange
(
const
Context
*
context
GLintptr
offset
GLsizeiptr
length
GLbitfield
access
)
{
ASSERT
(
!
mState
.
mMapped
)
;
ASSERT
(
offset
+
length
<
=
mState
.
mSize
)
;
mState
.
mMapPointer
=
nullptr
;
ANGLE_TRY
(
mImpl
-
>
mapRange
(
context
offset
length
access
&
mState
.
mMapPointer
)
)
;
mState
.
mMapped
=
GL_TRUE
;
mState
.
mMapOffset
=
static_cast
<
GLint64
>
(
offset
)
;
mState
.
mMapLength
=
static_cast
<
GLint64
>
(
length
)
;
mState
.
mAccess
=
GL_WRITE_ONLY_OES
;
mState
.
mAccessFlags
=
access
;
if
(
(
access
&
GL_MAP_WRITE_BIT
)
>
0
)
{
mIndexRangeCache
.
invalidateRange
(
static_cast
<
unsigned
int
>
(
offset
)
static_cast
<
unsigned
int
>
(
length
)
)
;
}
return
NoError
(
)
;
}
Error
Buffer
:
:
unmap
(
const
Context
*
context
GLboolean
*
result
)
{
ASSERT
(
mState
.
mMapped
)
;
*
result
=
GL_FALSE
;
ANGLE_TRY
(
mImpl
-
>
unmap
(
context
result
)
)
;
mState
.
mMapped
=
GL_FALSE
;
mState
.
mMapPointer
=
nullptr
;
mState
.
mMapOffset
=
0
;
mState
.
mMapLength
=
0
;
mState
.
mAccess
=
GL_WRITE_ONLY_OES
;
mState
.
mAccessFlags
=
0
;
mImpl
-
>
onStateChange
(
context
angle
:
:
SubjectMessage
:
:
CONTENTS_CHANGED
)
;
return
NoError
(
)
;
}
void
Buffer
:
:
onTransformFeedback
(
const
Context
*
context
)
{
mIndexRangeCache
.
clear
(
)
;
mImpl
-
>
onStateChange
(
context
angle
:
:
SubjectMessage
:
:
CONTENTS_CHANGED
)
;
}
void
Buffer
:
:
onPixelPack
(
const
Context
*
context
)
{
mIndexRangeCache
.
clear
(
)
;
mImpl
-
>
onStateChange
(
context
angle
:
:
SubjectMessage
:
:
CONTENTS_CHANGED
)
;
}
Error
Buffer
:
:
getIndexRange
(
const
gl
:
:
Context
*
context
GLenum
type
size_t
offset
size_t
count
bool
primitiveRestartEnabled
IndexRange
*
outRange
)
const
{
if
(
mIndexRangeCache
.
findRange
(
type
offset
count
primitiveRestartEnabled
outRange
)
)
{
return
NoError
(
)
;
}
ANGLE_TRY
(
mImpl
-
>
getIndexRange
(
context
type
offset
count
primitiveRestartEnabled
outRange
)
)
;
mIndexRangeCache
.
addRange
(
type
offset
count
primitiveRestartEnabled
*
outRange
)
;
return
NoError
(
)
;
}
bool
Buffer
:
:
isBound
(
)
const
{
return
mState
.
mBindingCount
;
}
bool
Buffer
:
:
isBoundForTransformFeedbackAndOtherUse
(
)
const
{
return
mState
.
mTransformFeedbackBindingCount
>
0
&
&
mState
.
mTransformFeedbackBindingCount
!
=
mState
.
mBindingCount
;
}
void
Buffer
:
:
onBindingChanged
(
const
Context
*
context
bool
bound
BufferBinding
target
)
{
ASSERT
(
bound
|
|
mState
.
mBindingCount
>
0
)
;
mState
.
mBindingCount
+
=
bound
?
1
:
-
1
;
if
(
target
=
=
BufferBinding
:
:
TransformFeedback
)
{
ASSERT
(
bound
|
|
mState
.
mTransformFeedbackBindingCount
>
0
)
;
mState
.
mTransformFeedbackBindingCount
+
=
bound
?
1
:
-
1
;
mImpl
-
>
onStateChange
(
context
angle
:
:
SubjectMessage
:
:
BINDING_CHANGED
)
;
}
}
}
