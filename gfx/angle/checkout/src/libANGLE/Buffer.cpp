#
include
"
libANGLE
/
Buffer
.
h
"
#
include
"
libANGLE
/
Context
.
h
"
#
include
"
libANGLE
/
renderer
/
BufferImpl
.
h
"
#
include
"
libANGLE
/
renderer
/
GLImplFactory
.
h
"
namespace
gl
{
namespace
{
constexpr
angle
:
:
SubjectIndex
kImplementationSubjectIndex
=
0
;
}
BufferState
:
:
BufferState
(
)
:
mLabel
(
)
mUsage
(
BufferUsage
:
:
StaticDraw
)
mSize
(
0
)
mAccessFlags
(
0
)
mAccess
(
GL_WRITE_ONLY_OES
)
mMapped
(
GL_FALSE
)
mMapPointer
(
nullptr
)
mMapOffset
(
0
)
mMapLength
(
0
)
mBindingCount
(
0
)
mTransformFeedbackIndexedBindingCount
(
0
)
mTransformFeedbackGenericBindingCount
(
0
)
{
}
BufferState
:
:
~
BufferState
(
)
{
}
Buffer
:
:
Buffer
(
rx
:
:
GLImplFactory
*
factory
GLuint
id
)
:
RefCountObject
(
id
)
mImpl
(
factory
-
>
createBuffer
(
mState
)
)
mImplObserver
(
this
kImplementationSubjectIndex
)
{
mImplObserver
.
bind
(
mImpl
)
;
}
Buffer
:
:
~
Buffer
(
)
{
SafeDelete
(
mImpl
)
;
}
void
Buffer
:
:
onDestroy
(
const
Context
*
context
)
{
if
(
mImpl
)
mImpl
-
>
destroy
(
context
)
;
}
void
Buffer
:
:
setLabel
(
const
Context
*
context
const
std
:
:
string
&
label
)
{
mState
.
mLabel
=
label
;
}
const
std
:
:
string
&
Buffer
:
:
getLabel
(
)
const
{
return
mState
.
mLabel
;
}
angle
:
:
Result
Buffer
:
:
bufferData
(
Context
*
context
BufferBinding
target
const
void
*
data
GLsizeiptr
size
BufferUsage
usage
)
{
const
void
*
dataForImpl
=
data
;
if
(
context
&
&
context
-
>
getState
(
)
.
isRobustResourceInitEnabled
(
)
&
&
!
data
&
&
size
>
0
)
{
angle
:
:
MemoryBuffer
*
scratchBuffer
=
nullptr
;
ANGLE_CHECK_GL_ALLOC
(
context
context
-
>
getZeroFilledBuffer
(
static_cast
<
size_t
>
(
size
)
&
scratchBuffer
)
)
;
dataForImpl
=
scratchBuffer
-
>
data
(
)
;
}
ANGLE_TRY
(
mImpl
-
>
setData
(
context
target
dataForImpl
size
usage
)
)
;
mIndexRangeCache
.
clear
(
)
;
mState
.
mUsage
=
usage
;
mState
.
mSize
=
size
;
onStateChange
(
context
angle
:
:
SubjectMessage
:
:
STORAGE_CHANGED
)
;
return
angle
:
:
Result
:
:
Continue
;
}
angle
:
:
Result
Buffer
:
:
bufferSubData
(
const
Context
*
context
BufferBinding
target
const
void
*
data
GLsizeiptr
size
GLintptr
offset
)
{
ANGLE_TRY
(
mImpl
-
>
setSubData
(
context
target
data
size
offset
)
)
;
mIndexRangeCache
.
invalidateRange
(
static_cast
<
unsigned
int
>
(
offset
)
static_cast
<
unsigned
int
>
(
size
)
)
;
onStateChange
(
context
angle
:
:
SubjectMessage
:
:
CONTENTS_CHANGED
)
;
return
angle
:
:
Result
:
:
Continue
;
}
angle
:
:
Result
Buffer
:
:
copyBufferSubData
(
const
Context
*
context
Buffer
*
source
GLintptr
sourceOffset
GLintptr
destOffset
GLsizeiptr
size
)
{
ANGLE_TRY
(
mImpl
-
>
copySubData
(
context
source
-
>
getImplementation
(
)
sourceOffset
destOffset
size
)
)
;
mIndexRangeCache
.
invalidateRange
(
static_cast
<
unsigned
int
>
(
destOffset
)
static_cast
<
unsigned
int
>
(
size
)
)
;
onStateChange
(
context
angle
:
:
SubjectMessage
:
:
CONTENTS_CHANGED
)
;
return
angle
:
:
Result
:
:
Continue
;
}
angle
:
:
Result
Buffer
:
:
map
(
const
Context
*
context
GLenum
access
)
{
ASSERT
(
!
mState
.
mMapped
)
;
mState
.
mMapPointer
=
nullptr
;
ANGLE_TRY
(
mImpl
-
>
map
(
context
access
&
mState
.
mMapPointer
)
)
;
ASSERT
(
access
=
=
GL_WRITE_ONLY_OES
)
;
mState
.
mMapped
=
GL_TRUE
;
mState
.
mMapOffset
=
0
;
mState
.
mMapLength
=
mState
.
mSize
;
mState
.
mAccess
=
access
;
mState
.
mAccessFlags
=
GL_MAP_WRITE_BIT
;
mIndexRangeCache
.
clear
(
)
;
onStateChange
(
context
angle
:
:
SubjectMessage
:
:
RESOURCE_MAPPED
)
;
return
angle
:
:
Result
:
:
Continue
;
}
angle
:
:
Result
Buffer
:
:
mapRange
(
const
Context
*
context
GLintptr
offset
GLsizeiptr
length
GLbitfield
access
)
{
ASSERT
(
!
mState
.
mMapped
)
;
ASSERT
(
offset
+
length
<
=
mState
.
mSize
)
;
mState
.
mMapPointer
=
nullptr
;
ANGLE_TRY
(
mImpl
-
>
mapRange
(
context
offset
length
access
&
mState
.
mMapPointer
)
)
;
mState
.
mMapped
=
GL_TRUE
;
mState
.
mMapOffset
=
static_cast
<
GLint64
>
(
offset
)
;
mState
.
mMapLength
=
static_cast
<
GLint64
>
(
length
)
;
mState
.
mAccess
=
GL_WRITE_ONLY_OES
;
mState
.
mAccessFlags
=
access
;
if
(
(
access
&
GL_MAP_WRITE_BIT
)
>
0
)
{
mIndexRangeCache
.
invalidateRange
(
static_cast
<
unsigned
int
>
(
offset
)
static_cast
<
unsigned
int
>
(
length
)
)
;
}
onStateChange
(
context
angle
:
:
SubjectMessage
:
:
RESOURCE_MAPPED
)
;
return
angle
:
:
Result
:
:
Continue
;
}
angle
:
:
Result
Buffer
:
:
unmap
(
const
Context
*
context
GLboolean
*
result
)
{
ASSERT
(
mState
.
mMapped
)
;
*
result
=
GL_FALSE
;
ANGLE_TRY
(
mImpl
-
>
unmap
(
context
result
)
)
;
mState
.
mMapped
=
GL_FALSE
;
mState
.
mMapPointer
=
nullptr
;
mState
.
mMapOffset
=
0
;
mState
.
mMapLength
=
0
;
mState
.
mAccess
=
GL_WRITE_ONLY_OES
;
mState
.
mAccessFlags
=
0
;
onStateChange
(
context
angle
:
:
SubjectMessage
:
:
RESOURCE_UNMAPPED
)
;
return
angle
:
:
Result
:
:
Continue
;
}
void
Buffer
:
:
onTransformFeedback
(
const
Context
*
context
)
{
mIndexRangeCache
.
clear
(
)
;
onStateChange
(
context
angle
:
:
SubjectMessage
:
:
CONTENTS_CHANGED
)
;
}
void
Buffer
:
:
onPixelPack
(
const
Context
*
context
)
{
mIndexRangeCache
.
clear
(
)
;
onStateChange
(
context
angle
:
:
SubjectMessage
:
:
CONTENTS_CHANGED
)
;
}
angle
:
:
Result
Buffer
:
:
getIndexRange
(
const
gl
:
:
Context
*
context
DrawElementsType
type
size_t
offset
size_t
count
bool
primitiveRestartEnabled
IndexRange
*
outRange
)
const
{
if
(
mIndexRangeCache
.
findRange
(
type
offset
count
primitiveRestartEnabled
outRange
)
)
{
return
angle
:
:
Result
:
:
Continue
;
}
ANGLE_TRY
(
mImpl
-
>
getIndexRange
(
context
type
offset
count
primitiveRestartEnabled
outRange
)
)
;
mIndexRangeCache
.
addRange
(
type
offset
count
primitiveRestartEnabled
*
outRange
)
;
return
angle
:
:
Result
:
:
Continue
;
}
GLint64
Buffer
:
:
getMemorySize
(
)
const
{
GLint64
implSize
=
mImpl
-
>
getMemorySize
(
)
;
return
implSize
>
0
?
implSize
:
mState
.
mSize
;
}
bool
Buffer
:
:
isDoubleBoundForTransformFeedback
(
)
const
{
return
mState
.
mTransformFeedbackIndexedBindingCount
>
1
;
}
void
Buffer
:
:
onTFBindingChanged
(
const
Context
*
context
bool
bound
bool
indexed
)
{
ASSERT
(
bound
|
|
mState
.
mBindingCount
>
0
)
;
mState
.
mBindingCount
+
=
bound
?
1
:
-
1
;
if
(
indexed
)
{
ASSERT
(
bound
|
|
mState
.
mTransformFeedbackIndexedBindingCount
>
0
)
;
mState
.
mTransformFeedbackIndexedBindingCount
+
=
bound
?
1
:
-
1
;
onStateChange
(
context
angle
:
:
SubjectMessage
:
:
BINDING_CHANGED
)
;
}
else
{
mState
.
mTransformFeedbackGenericBindingCount
+
=
bound
?
1
:
-
1
;
}
}
void
Buffer
:
:
onSubjectStateChange
(
const
gl
:
:
Context
*
context
angle
:
:
SubjectIndex
index
angle
:
:
SubjectMessage
message
)
{
ASSERT
(
index
=
=
kImplementationSubjectIndex
)
;
onStateChange
(
context
message
)
;
}
}
