#
include
"
libGLESv2
/
global_state
.
h
"
#
include
"
common
/
debug
.
h
"
#
include
"
common
/
platform
.
h
"
#
include
"
common
/
tls
.
h
"
namespace
gl
{
Context
*
gSingleThreadedContext
=
nullptr
;
bool
gIsMultiThreadedContext
=
false
;
}
namespace
egl
{
namespace
{
static
TLSIndex
threadTLS
=
TLS_INVALID_INDEX
;
Debug
*
g_Debug
=
nullptr
;
std
:
:
atomic
<
std
:
:
mutex
*
>
g_Mutex
;
static_assert
(
std
:
:
is_trivially_constructible
<
decltype
(
g_Mutex
)
>
:
:
value
"
global
mutex
is
not
trivially
constructible
"
)
;
static_assert
(
std
:
:
is_trivially_destructible
<
decltype
(
g_Mutex
)
>
:
:
value
"
global
mutex
is
not
trivially
destructible
"
)
;
Thread
*
AllocateCurrentThread
(
)
{
ASSERT
(
threadTLS
!
=
TLS_INVALID_INDEX
)
;
if
(
threadTLS
=
=
TLS_INVALID_INDEX
)
{
return
nullptr
;
}
Thread
*
thread
=
new
Thread
(
)
;
if
(
!
SetTLSValue
(
threadTLS
thread
)
)
{
ERR
(
)
<
<
"
Could
not
set
thread
local
storage
.
"
;
return
nullptr
;
}
return
thread
;
}
void
AllocateDebug
(
)
{
if
(
g_Debug
=
=
nullptr
)
{
g_Debug
=
new
Debug
(
)
;
}
}
void
AllocateMutex
(
)
{
if
(
g_Mutex
=
=
nullptr
)
{
std
:
:
unique_ptr
<
std
:
:
mutex
>
newMutex
(
new
std
:
:
mutex
(
)
)
;
std
:
:
mutex
*
expected
=
nullptr
;
if
(
g_Mutex
.
compare_exchange_strong
(
expected
newMutex
.
get
(
)
)
)
{
newMutex
.
release
(
)
;
}
}
}
}
std
:
:
mutex
&
GetGlobalMutex
(
)
{
AllocateMutex
(
)
;
return
*
g_Mutex
;
}
Thread
*
GetCurrentThread
(
)
{
if
(
threadTLS
=
=
TLS_INVALID_INDEX
)
{
threadTLS
=
CreateTLSIndex
(
)
;
}
Thread
*
current
=
static_cast
<
Thread
*
>
(
GetTLSValue
(
threadTLS
)
)
;
return
(
current
?
current
:
AllocateCurrentThread
(
)
)
;
}
Debug
*
GetDebug
(
)
{
AllocateDebug
(
)
;
return
g_Debug
;
}
void
SetContextCurrent
(
Thread
*
thread
gl
:
:
Context
*
context
)
{
if
(
!
gl
:
:
gIsMultiThreadedContext
)
{
if
(
gl
:
:
gSingleThreadedContext
=
=
nullptr
|
|
gl
:
:
gSingleThreadedContext
=
=
thread
-
>
getContext
(
)
)
{
gl
:
:
gSingleThreadedContext
=
context
;
}
else
{
gl
:
:
gSingleThreadedContext
=
nullptr
;
gl
:
:
gIsMultiThreadedContext
=
true
;
}
}
thread
-
>
setCurrent
(
context
)
;
}
}
#
ifdef
ANGLE_PLATFORM_WINDOWS
namespace
egl
{
namespace
{
bool
DeallocateCurrentThread
(
)
{
Thread
*
thread
=
static_cast
<
Thread
*
>
(
GetTLSValue
(
threadTLS
)
)
;
SafeDelete
(
thread
)
;
return
SetTLSValue
(
threadTLS
nullptr
)
;
}
void
DeallocateDebug
(
)
{
SafeDelete
(
g_Debug
)
;
}
void
DeallocateMutex
(
)
{
std
:
:
mutex
*
mutex
=
g_Mutex
.
exchange
(
nullptr
)
;
{
std
:
:
lock_guard
<
std
:
:
mutex
>
lock
(
*
mutex
)
;
}
SafeDelete
(
mutex
)
;
}
bool
InitializeProcess
(
)
{
ASSERT
(
g_Debug
=
=
nullptr
)
;
AllocateDebug
(
)
;
AllocateMutex
(
)
;
threadTLS
=
CreateTLSIndex
(
)
;
if
(
threadTLS
=
=
TLS_INVALID_INDEX
)
{
return
false
;
}
return
AllocateCurrentThread
(
)
!
=
nullptr
;
}
bool
TerminateProcess
(
)
{
DeallocateDebug
(
)
;
DeallocateMutex
(
)
;
if
(
!
DeallocateCurrentThread
(
)
)
{
return
false
;
}
if
(
threadTLS
!
=
TLS_INVALID_INDEX
)
{
TLSIndex
tlsCopy
=
threadTLS
;
threadTLS
=
TLS_INVALID_INDEX
;
if
(
!
DestroyTLSIndex
(
tlsCopy
)
)
{
return
false
;
}
}
return
true
;
}
}
}
extern
"
C
"
BOOL
WINAPI
DllMain
(
HINSTANCE
DWORD
reason
LPVOID
)
{
switch
(
reason
)
{
case
DLL_PROCESS_ATTACH
:
return
static_cast
<
BOOL
>
(
egl
:
:
InitializeProcess
(
)
)
;
case
DLL_THREAD_ATTACH
:
return
static_cast
<
BOOL
>
(
egl
:
:
AllocateCurrentThread
(
)
!
=
nullptr
)
;
case
DLL_THREAD_DETACH
:
return
static_cast
<
BOOL
>
(
egl
:
:
DeallocateCurrentThread
(
)
)
;
case
DLL_PROCESS_DETACH
:
return
static_cast
<
BOOL
>
(
egl
:
:
TerminateProcess
(
)
)
;
}
return
TRUE
;
}
#
endif
