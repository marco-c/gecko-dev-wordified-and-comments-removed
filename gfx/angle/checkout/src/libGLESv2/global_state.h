#
ifndef
LIBGLESV2_GLOBALSTATE_H_
#
define
LIBGLESV2_GLOBALSTATE_H_
#
include
"
libANGLE
/
Context
.
h
"
#
include
"
libANGLE
/
Debug
.
h
"
#
include
"
libANGLE
/
Thread
.
h
"
#
include
"
libANGLE
/
features
.
h
"
#
include
<
mutex
>
namespace
angle
{
using
GlobalMutex
=
std
:
:
recursive_mutex
;
constexpr
size_t
kAndroidOpenGLTlsSlot
=
3
;
#
if
defined
(
ANGLE_PLATFORM_ANDROID
)
#
if
defined
(
__aarch64__
)
#
define
ANGLE_ANDROID_GET_GL_TLS
(
)
\
(
{
\
void
*
*
__val
;
\
__asm__
(
"
mrs
%
0
tpidr_el0
"
:
"
=
r
"
(
__val
)
)
;
\
__val
;
\
}
)
#
elif
defined
(
__arm__
)
#
define
ANGLE_ANDROID_GET_GL_TLS
(
)
\
(
{
\
void
*
*
__val
;
\
__asm__
(
"
mrc
p15
0
%
0
c13
c0
3
"
:
"
=
r
"
(
__val
)
)
;
\
__val
;
\
}
)
#
elif
defined
(
__mips__
)
#
define
ANGLE_ANDROID_GET_GL_TLS
(
)
\
(
{
\
register
void
*
*
__val
asm
(
"
v1
"
)
;
\
__asm__
(
\
"
.
set
push
\
n
"
\
"
.
set
mips32r2
\
n
"
\
"
rdhwr
%
0
29
\
n
"
\
"
.
set
pop
\
n
"
\
:
"
=
r
"
(
__val
)
)
;
\
__val
;
\
}
)
#
elif
defined
(
__i386__
)
#
define
ANGLE_ANDROID_GET_GL_TLS
(
)
\
(
{
\
void
*
*
__val
;
\
__asm__
(
"
movl
%
%
gs
:
0
%
0
"
:
"
=
r
"
(
__val
)
)
;
\
__val
;
\
}
)
#
elif
defined
(
__x86_64__
)
#
define
ANGLE_ANDROID_GET_GL_TLS
(
)
\
(
{
\
void
*
*
__val
;
\
__asm__
(
"
mov
%
%
fs
:
0
%
0
"
:
"
=
r
"
(
__val
)
)
;
\
__val
;
\
}
)
#
else
#
error
unsupported
architecture
#
endif
#
endif
}
namespace
egl
{
class
Debug
;
class
Thread
;
extern
thread_local
Thread
*
gCurrentThread
;
angle
:
:
GlobalMutex
&
GetGlobalMutex
(
)
;
gl
:
:
Context
*
GetGlobalLastContext
(
)
;
void
SetGlobalLastContext
(
gl
:
:
Context
*
context
)
;
Thread
*
GetCurrentThread
(
)
;
Debug
*
GetDebug
(
)
;
void
SetContextCurrent
(
Thread
*
thread
gl
:
:
Context
*
context
)
;
}
#
define
ANGLE_SCOPED_GLOBAL_LOCK
(
)
\
std
:
:
lock_guard
<
angle
:
:
GlobalMutex
>
globalMutexLock
(
egl
:
:
GetGlobalMutex
(
)
)
namespace
gl
{
ANGLE_INLINE
Context
*
GetGlobalContext
(
)
{
#
if
defined
(
ANGLE_PLATFORM_ANDROID
)
if
(
angle
:
:
gUseAndroidOpenGLTlsSlot
)
{
return
static_cast
<
gl
:
:
Context
*
>
(
ANGLE_ANDROID_GET_GL_TLS
(
)
[
angle
:
:
kAndroidOpenGLTlsSlot
]
)
;
}
#
endif
ASSERT
(
egl
:
:
gCurrentThread
)
;
return
egl
:
:
gCurrentThread
-
>
getContext
(
)
;
}
ANGLE_INLINE
Context
*
GetValidGlobalContext
(
)
{
#
if
defined
(
ANGLE_PLATFORM_ANDROID
)
if
(
angle
:
:
gUseAndroidOpenGLTlsSlot
)
{
Context
*
context
=
static_cast
<
gl
:
:
Context
*
>
(
ANGLE_ANDROID_GET_GL_TLS
(
)
[
angle
:
:
kAndroidOpenGLTlsSlot
]
)
;
if
(
context
&
&
!
context
-
>
isContextLost
(
)
)
{
return
context
;
}
}
#
endif
return
gCurrentValidContext
;
}
void
GenerateContextLostErrorOnContext
(
Context
*
context
)
;
void
GenerateContextLostErrorOnCurrentGlobalContext
(
)
;
#
if
defined
(
ANGLE_FORCE_CONTEXT_CHECK_EVERY_CALL
)
static
ANGLE_INLINE
void
DirtyContextIfNeeded
(
Context
*
context
)
{
if
(
context
&
&
context
!
=
egl
:
:
GetGlobalLastContext
(
)
)
{
context
-
>
dirtyAllState
(
)
;
SetGlobalLastContext
(
context
)
;
}
}
#
endif
ANGLE_INLINE
std
:
:
unique_lock
<
angle
:
:
GlobalMutex
>
GetContextLock
(
Context
*
context
)
{
#
if
defined
(
ANGLE_FORCE_CONTEXT_CHECK_EVERY_CALL
)
auto
lock
=
std
:
:
unique_lock
<
angle
:
:
GlobalMutex
>
(
egl
:
:
GetGlobalMutex
(
)
)
;
DirtyContextIfNeeded
(
context
)
;
return
lock
;
#
else
return
context
-
>
isShared
(
)
?
std
:
:
unique_lock
<
angle
:
:
GlobalMutex
>
(
egl
:
:
GetGlobalMutex
(
)
)
:
std
:
:
unique_lock
<
angle
:
:
GlobalMutex
>
(
)
;
#
endif
}
}
#
endif
