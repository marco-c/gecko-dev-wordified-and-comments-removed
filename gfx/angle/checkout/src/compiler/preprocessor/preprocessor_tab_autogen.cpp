#
define
YYBISON
30802
#
define
YYBISON_VERSION
"
3
.
8
.
2
"
#
define
YYSKELETON_NAME
"
yacc
.
c
"
#
define
YYPURE
1
#
define
YYPUSH
0
#
define
YYPULL
1
#
define
YYSTYPE
PPSTYPE
#
define
yyparse
ppparse
#
define
yylex
pplex
#
define
yyerror
pperror
#
define
yydebug
ppdebug
#
define
yynerrs
ppnerrs
#
if
defined
(
__GNUC__
)
#
if
!
defined
(
__clang__
)
&
&
(
(
__GNUC__
>
4
)
|
|
(
__GNUC__
=
=
4
&
&
__GNUC_MINOR__
>
=
7
)
)
#
pragma
GCC
diagnostic
ignored
"
-
Wmaybe
-
uninitialized
"
#
else
#
pragma
GCC
diagnostic
ignored
"
-
Wuninitialized
"
#
endif
#
elif
defined
(
_MSC_VER
)
#
pragma
warning
(
disable
:
4065
4244
4701
4702
)
#
endif
#
if
defined
(
__clang__
)
#
pragma
clang
diagnostic
ignored
"
-
Wunreachable
-
code
"
#
pragma
clang
diagnostic
ignored
"
-
Wunused
-
but
-
set
-
variable
"
#
endif
#
include
"
ExpressionParser
.
h
"
#
if
defined
(
_MSC_VER
)
#
include
<
malloc
.
h
>
#
else
#
include
<
stdlib
.
h
>
#
endif
#
include
<
stdint
.
h
>
#
include
<
cassert
>
#
include
<
sstream
>
#
include
"
DiagnosticsBase
.
h
"
#
include
"
Lexer
.
h
"
#
include
"
Token
.
h
"
#
include
"
common
/
mathutil
.
h
"
typedef
int32_t
YYSTYPE
;
typedef
uint32_t
UNSIGNED_TYPE
;
#
define
YYENABLE_NLS
0
#
define
YYLTYPE_IS_TRIVIAL
1
#
define
YYSTYPE_IS_TRIVIAL
1
#
define
YYSTYPE_IS_DECLARED
1
namespace
{
struct
Context
{
angle
:
:
pp
:
:
Diagnostics
*
diagnostics
;
angle
:
:
pp
:
:
Lexer
*
lexer
;
angle
:
:
pp
:
:
Token
*
token
;
int
*
result
;
bool
parsePresetToken
;
angle
:
:
pp
:
:
ExpressionParser
:
:
ErrorSettings
errorSettings
;
bool
*
valid
;
void
startIgnoreErrors
(
)
{
+
+
ignoreErrors
;
}
void
endIgnoreErrors
(
)
{
-
-
ignoreErrors
;
}
bool
isIgnoringErrors
(
)
{
return
ignoreErrors
>
0
;
}
int
ignoreErrors
;
}
;
}
static
int
yylex
(
YYSTYPE
*
lvalp
Context
*
context
)
;
static
void
yyerror
(
Context
*
context
const
char
*
reason
)
;
#
ifndef
YY_CAST
#
ifdef
__cplusplus
#
define
YY_CAST
(
Type
Val
)
static_cast
<
Type
>
(
Val
)
#
define
YY_REINTERPRET_CAST
(
Type
Val
)
reinterpret_cast
<
Type
>
(
Val
)
#
else
#
define
YY_CAST
(
Type
Val
)
(
(
Type
)
(
Val
)
)
#
define
YY_REINTERPRET_CAST
(
Type
Val
)
(
(
Type
)
(
Val
)
)
#
endif
#
endif
#
ifndef
YY_NULLPTR
#
if
defined
__cplusplus
#
if
201103L
<
=
__cplusplus
#
define
YY_NULLPTR
nullptr
#
else
#
define
YY_NULLPTR
0
#
endif
#
else
#
define
YY_NULLPTR
(
(
void
*
)
0
)
#
endif
#
endif
#
ifndef
PPDEBUG
#
if
defined
YYDEBUG
#
if
YYDEBUG
#
define
PPDEBUG
1
#
else
#
define
PPDEBUG
0
#
endif
#
else
#
define
PPDEBUG
0
#
endif
#
endif
#
if
PPDEBUG
extern
int
ppdebug
;
#
endif
#
ifndef
PPTOKENTYPE
#
define
PPTOKENTYPE
enum
pptokentype
{
PPEMPTY
=
-
2
PPEOF
=
0
PPerror
=
256
PPUNDEF
=
257
TOK_CONST_INT
=
258
TOK_IDENTIFIER
=
259
TOK_OP_OR
=
260
TOK_OP_AND
=
261
TOK_OP_EQ
=
262
TOK_OP_NE
=
263
TOK_OP_LE
=
264
TOK_OP_GE
=
265
TOK_OP_LEFT
=
266
TOK_OP_RIGHT
=
267
TOK_UNARY
=
268
}
;
typedef
enum
pptokentype
pptoken_kind_t
;
#
endif
#
if
!
defined
PPSTYPE
&
&
!
defined
PPSTYPE_IS_DECLARED
typedef
int
PPSTYPE
;
#
define
PPSTYPE_IS_TRIVIAL
1
#
define
PPSTYPE_IS_DECLARED
1
#
endif
int
ppparse
(
Context
*
context
)
;
enum
yysymbol_kind_t
{
YYSYMBOL_YYEMPTY
=
-
2
YYSYMBOL_YYEOF
=
0
YYSYMBOL_YYerror
=
1
YYSYMBOL_YYUNDEF
=
2
YYSYMBOL_TOK_CONST_INT
=
3
YYSYMBOL_TOK_IDENTIFIER
=
4
YYSYMBOL_TOK_OP_OR
=
5
YYSYMBOL_TOK_OP_AND
=
6
YYSYMBOL_7_
=
7
YYSYMBOL_8_
=
8
YYSYMBOL_9_
=
9
YYSYMBOL_TOK_OP_EQ
=
10
YYSYMBOL_TOK_OP_NE
=
11
YYSYMBOL_12_
=
12
YYSYMBOL_13_
=
13
YYSYMBOL_TOK_OP_LE
=
14
YYSYMBOL_TOK_OP_GE
=
15
YYSYMBOL_TOK_OP_LEFT
=
16
YYSYMBOL_TOK_OP_RIGHT
=
17
YYSYMBOL_18_
=
18
YYSYMBOL_19_
=
19
YYSYMBOL_20_
=
20
YYSYMBOL_21_
=
21
YYSYMBOL_22_
=
22
YYSYMBOL_TOK_UNARY
=
23
YYSYMBOL_24_
=
24
YYSYMBOL_25_
=
25
YYSYMBOL_26_
=
26
YYSYMBOL_27_
=
27
YYSYMBOL_YYACCEPT
=
28
YYSYMBOL_input
=
29
YYSYMBOL_expression
=
30
YYSYMBOL_31_1
=
31
YYSYMBOL_32_2
=
32
}
;
typedef
enum
yysymbol_kind_t
yysymbol_kind_t
;
#
ifdef
short
#
undef
short
#
endif
#
ifndef
__PTRDIFF_MAX__
#
include
<
limits
.
h
>
#
if
defined
__STDC_VERSION__
&
&
199901
<
=
__STDC_VERSION__
#
include
<
stdint
.
h
>
#
define
YY_STDINT_H
#
endif
#
endif
#
ifdef
__INT_LEAST8_MAX__
typedef
__INT_LEAST8_TYPE__
yytype_int8
;
#
elif
defined
YY_STDINT_H
typedef
int_least8_t
yytype_int8
;
#
else
typedef
signed
char
yytype_int8
;
#
endif
#
ifdef
__INT_LEAST16_MAX__
typedef
__INT_LEAST16_TYPE__
yytype_int16
;
#
elif
defined
YY_STDINT_H
typedef
int_least16_t
yytype_int16
;
#
else
typedef
short
yytype_int16
;
#
endif
#
ifdef
__hpux
#
undef
UINT_LEAST8_MAX
#
undef
UINT_LEAST16_MAX
#
define
UINT_LEAST8_MAX
255
#
define
UINT_LEAST16_MAX
65535
#
endif
#
if
defined
__UINT_LEAST8_MAX__
&
&
__UINT_LEAST8_MAX__
<
=
__INT_MAX__
typedef
__UINT_LEAST8_TYPE__
yytype_uint8
;
#
elif
(
!
defined
__UINT_LEAST8_MAX__
&
&
defined
YY_STDINT_H
&
&
UINT_LEAST8_MAX
<
=
INT_MAX
)
typedef
uint_least8_t
yytype_uint8
;
#
elif
!
defined
__UINT_LEAST8_MAX__
&
&
UCHAR_MAX
<
=
INT_MAX
typedef
unsigned
char
yytype_uint8
;
#
else
typedef
short
yytype_uint8
;
#
endif
#
if
defined
__UINT_LEAST16_MAX__
&
&
__UINT_LEAST16_MAX__
<
=
__INT_MAX__
typedef
__UINT_LEAST16_TYPE__
yytype_uint16
;
#
elif
(
!
defined
__UINT_LEAST16_MAX__
&
&
defined
YY_STDINT_H
&
&
UINT_LEAST16_MAX
<
=
INT_MAX
)
typedef
uint_least16_t
yytype_uint16
;
#
elif
!
defined
__UINT_LEAST16_MAX__
&
&
USHRT_MAX
<
=
INT_MAX
typedef
unsigned
short
yytype_uint16
;
#
else
typedef
int
yytype_uint16
;
#
endif
#
ifndef
YYPTRDIFF_T
#
if
defined
__PTRDIFF_TYPE__
&
&
defined
__PTRDIFF_MAX__
#
define
YYPTRDIFF_T
__PTRDIFF_TYPE__
#
define
YYPTRDIFF_MAXIMUM
__PTRDIFF_MAX__
#
elif
defined
PTRDIFF_MAX
#
ifndef
ptrdiff_t
#
include
<
stddef
.
h
>
#
endif
#
define
YYPTRDIFF_T
ptrdiff_t
#
define
YYPTRDIFF_MAXIMUM
PTRDIFF_MAX
#
else
#
define
YYPTRDIFF_T
long
#
define
YYPTRDIFF_MAXIMUM
LONG_MAX
#
endif
#
endif
#
ifndef
YYSIZE_T
#
ifdef
__SIZE_TYPE__
#
define
YYSIZE_T
__SIZE_TYPE__
#
elif
defined
size_t
#
define
YYSIZE_T
size_t
#
elif
defined
__STDC_VERSION__
&
&
199901
<
=
__STDC_VERSION__
#
include
<
stddef
.
h
>
#
define
YYSIZE_T
size_t
#
else
#
define
YYSIZE_T
unsigned
#
endif
#
endif
#
define
YYSIZE_MAXIMUM
\
YY_CAST
(
YYPTRDIFF_T
(
YYPTRDIFF_MAXIMUM
<
YY_CAST
(
YYSIZE_T
-
1
)
?
YYPTRDIFF_MAXIMUM
\
:
YY_CAST
(
YYSIZE_T
-
1
)
)
)
#
define
YYSIZEOF
(
X
)
YY_CAST
(
YYPTRDIFF_T
sizeof
(
X
)
)
typedef
yytype_int8
yy_state_t
;
typedef
int
yy_state_fast_t
;
#
ifndef
YY_
#
if
defined
YYENABLE_NLS
&
&
YYENABLE_NLS
#
if
ENABLE_NLS
#
include
<
libintl
.
h
>
#
define
YY_
(
Msgid
)
dgettext
(
"
bison
-
runtime
"
Msgid
)
#
endif
#
endif
#
ifndef
YY_
#
define
YY_
(
Msgid
)
Msgid
#
endif
#
endif
#
ifndef
YY_ATTRIBUTE_PURE
#
if
defined
__GNUC__
&
&
2
<
__GNUC__
+
(
96
<
=
__GNUC_MINOR__
)
#
define
YY_ATTRIBUTE_PURE
__attribute__
(
(
__pure__
)
)
#
else
#
define
YY_ATTRIBUTE_PURE
#
endif
#
endif
#
ifndef
YY_ATTRIBUTE_UNUSED
#
if
defined
__GNUC__
&
&
2
<
__GNUC__
+
(
7
<
=
__GNUC_MINOR__
)
#
define
YY_ATTRIBUTE_UNUSED
__attribute__
(
(
__unused__
)
)
#
else
#
define
YY_ATTRIBUTE_UNUSED
#
endif
#
endif
#
if
!
defined
lint
|
|
defined
__GNUC__
#
define
YY_USE
(
E
)
(
(
void
)
(
E
)
)
#
else
#
define
YY_USE
(
E
)
#
endif
#
if
defined
__GNUC__
&
&
!
defined
__ICC
&
&
406
<
=
__GNUC__
*
100
+
__GNUC_MINOR__
#
if
__GNUC__
*
100
+
__GNUC_MINOR__
<
407
#
define
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
\
_Pragma
(
"
GCC
diagnostic
push
"
)
_Pragma
(
"
GCC
diagnostic
ignored
\
"
-
Wuninitialized
\
"
"
)
#
else
#
define
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
\
_Pragma
(
"
GCC
diagnostic
push
"
)
_Pragma
(
"
GCC
diagnostic
ignored
\
"
-
Wuninitialized
\
"
"
)
\
_Pragma
(
"
GCC
diagnostic
ignored
\
"
-
Wmaybe
-
uninitialized
\
"
"
)
#
endif
#
define
YY_IGNORE_MAYBE_UNINITIALIZED_END
_Pragma
(
"
GCC
diagnostic
pop
"
)
#
else
#
define
YY_INITIAL_VALUE
(
Value
)
Value
#
endif
#
ifndef
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
#
define
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
#
define
YY_IGNORE_MAYBE_UNINITIALIZED_END
#
endif
#
ifndef
YY_INITIAL_VALUE
#
define
YY_INITIAL_VALUE
(
Value
)
#
endif
#
if
defined
__cplusplus
&
&
defined
__GNUC__
&
&
!
defined
__ICC
&
&
6
<
=
__GNUC__
#
define
YY_IGNORE_USELESS_CAST_BEGIN
\
_Pragma
(
"
GCC
diagnostic
push
"
)
_Pragma
(
"
GCC
diagnostic
ignored
\
"
-
Wuseless
-
cast
\
"
"
)
#
define
YY_IGNORE_USELESS_CAST_END
_Pragma
(
"
GCC
diagnostic
pop
"
)
#
endif
#
ifndef
YY_IGNORE_USELESS_CAST_BEGIN
#
define
YY_IGNORE_USELESS_CAST_BEGIN
#
define
YY_IGNORE_USELESS_CAST_END
#
endif
#
define
YY_ASSERT
(
E
)
(
(
void
)
(
0
&
&
(
E
)
)
)
#
if
!
defined
yyoverflow
#
ifdef
YYSTACK_USE_ALLOCA
#
if
YYSTACK_USE_ALLOCA
#
ifdef
__GNUC__
#
define
YYSTACK_ALLOC
__builtin_alloca
#
elif
defined
__BUILTIN_VA_ARG_INCR
#
include
<
alloca
.
h
>
#
elif
defined
_AIX
#
define
YYSTACK_ALLOC
__alloca
#
elif
defined
_MSC_VER
#
include
<
malloc
.
h
>
#
define
alloca
_alloca
#
else
#
define
YYSTACK_ALLOC
alloca
#
if
!
defined
_ALLOCA_H
&
&
!
defined
EXIT_SUCCESS
#
include
<
stdlib
.
h
>
#
ifndef
EXIT_SUCCESS
#
define
EXIT_SUCCESS
0
#
endif
#
endif
#
endif
#
endif
#
endif
#
ifdef
YYSTACK_ALLOC
#
define
YYSTACK_FREE
(
Ptr
)
\
do
\
{
/
*
empty
*
/
\
;
\
}
while
(
0
)
#
ifndef
YYSTACK_ALLOC_MAXIMUM
#
define
YYSTACK_ALLOC_MAXIMUM
4032
/
*
reasonable
circa
2006
*
/
#
endif
#
else
#
define
YYSTACK_ALLOC
YYMALLOC
#
define
YYSTACK_FREE
YYFREE
#
ifndef
YYSTACK_ALLOC_MAXIMUM
#
define
YYSTACK_ALLOC_MAXIMUM
YYSIZE_MAXIMUM
#
endif
#
if
(
defined
__cplusplus
&
&
!
defined
EXIT_SUCCESS
&
&
\
!
(
(
defined
YYMALLOC
|
|
defined
malloc
)
&
&
(
defined
YYFREE
|
|
defined
free
)
)
)
#
include
<
stdlib
.
h
>
#
ifndef
EXIT_SUCCESS
#
define
EXIT_SUCCESS
0
#
endif
#
endif
#
ifndef
YYMALLOC
#
define
YYMALLOC
malloc
#
if
!
defined
malloc
&
&
!
defined
EXIT_SUCCESS
void
*
malloc
(
YYSIZE_T
)
;
#
endif
#
endif
#
ifndef
YYFREE
#
define
YYFREE
free
#
if
!
defined
free
&
&
!
defined
EXIT_SUCCESS
void
free
(
void
*
)
;
#
endif
#
endif
#
endif
#
endif
#
if
(
!
defined
yyoverflow
&
&
\
(
!
defined
__cplusplus
|
|
(
defined
PPSTYPE_IS_TRIVIAL
&
&
PPSTYPE_IS_TRIVIAL
)
)
)
union
yyalloc
{
yy_state_t
yyss_alloc
;
YYSTYPE
yyvs_alloc
;
}
;
#
define
YYSTACK_GAP_MAXIMUM
(
YYSIZEOF
(
union
yyalloc
)
-
1
)
#
define
YYSTACK_BYTES
(
N
)
\
(
(
N
)
*
(
YYSIZEOF
(
yy_state_t
)
+
YYSIZEOF
(
YYSTYPE
)
)
+
YYSTACK_GAP_MAXIMUM
)
#
define
YYCOPY_NEEDED
1
#
define
YYSTACK_RELOCATE
(
Stack_alloc
Stack
)
\
do
\
{
\
YYPTRDIFF_T
yynewbytes
;
\
YYCOPY
(
&
yyptr
-
>
Stack_alloc
Stack
yysize
)
;
\
Stack
=
&
yyptr
-
>
Stack_alloc
;
\
yynewbytes
=
yystacksize
*
YYSIZEOF
(
*
Stack
)
+
YYSTACK_GAP_MAXIMUM
;
\
yyptr
+
=
yynewbytes
/
YYSIZEOF
(
*
yyptr
)
;
\
}
while
(
0
)
#
endif
#
if
defined
YYCOPY_NEEDED
&
&
YYCOPY_NEEDED
#
ifndef
YYCOPY
#
if
defined
__GNUC__
&
&
1
<
__GNUC__
#
define
YYCOPY
(
Dst
Src
Count
)
\
__builtin_memcpy
(
Dst
Src
YY_CAST
(
YYSIZE_T
(
Count
)
)
*
sizeof
(
*
(
Src
)
)
)
#
else
#
define
YYCOPY
(
Dst
Src
Count
)
\
do
\
{
\
YYPTRDIFF_T
yyi
;
\
for
(
yyi
=
0
;
yyi
<
(
Count
)
;
yyi
+
+
)
\
(
Dst
)
[
yyi
]
=
(
Src
)
[
yyi
]
;
\
}
while
(
0
)
#
endif
#
endif
#
endif
#
define
YYFINAL
15
#
define
YYLAST
176
#
define
YYNTOKENS
28
#
define
YYNNTS
5
#
define
YYNRULES
29
#
define
YYNSTATES
55
#
define
YYMAXUTOK
268
#
define
YYTRANSLATE
(
YYX
)
\
(
0
<
=
(
YYX
)
&
&
(
YYX
)
<
=
YYMAXUTOK
?
YY_CAST
(
yysymbol_kind_t
yytranslate
[
YYX
]
)
\
:
YYSYMBOL_YYUNDEF
)
static
const
yytype_int8
yytranslate
[
]
=
{
0
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
24
2
2
2
22
9
2
26
27
20
18
2
19
2
21
2
2
2
2
2
2
2
2
2
2
2
2
12
2
13
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
8
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
7
2
25
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
1
2
3
4
5
6
10
11
14
15
16
17
23
}
;
#
if
PPDEBUG
static
const
yytype_int16
yyrline
[
]
=
{
0
114
114
121
122
133
133
154
154
175
178
181
184
187
190
193
196
199
202
227
249
252
255
281
308
311
314
317
329
332
}
;
#
endif
#
define
YY_ACCESSING_SYMBOL
(
State
)
YY_CAST
(
yysymbol_kind_t
yystos
[
State
]
)
#
if
PPDEBUG
|
|
0
static
const
char
*
yysymbol_name
(
yysymbol_kind_t
yysymbol
)
YY_ATTRIBUTE_UNUSED
;
static
const
char
*
const
yytname
[
]
=
{
"
\
"
end
of
file
\
"
"
"
error
"
"
\
"
invalid
token
\
"
"
"
TOK_CONST_INT
"
"
TOK_IDENTIFIER
"
"
TOK_OP_OR
"
"
TOK_OP_AND
"
"
'
|
'
"
"
'
^
'
"
"
'
&
'
"
"
TOK_OP_EQ
"
"
TOK_OP_NE
"
"
'
<
'
"
"
'
>
'
"
"
TOK_OP_LE
"
"
TOK_OP_GE
"
"
TOK_OP_LEFT
"
"
TOK_OP_RIGHT
"
"
'
+
'
"
"
'
-
'
"
"
'
*
'
"
"
'
/
'
"
"
'
%
'
"
"
TOK_UNARY
"
"
'
!
'
"
"
'
~
'
"
"
'
(
'
"
"
'
)
'
"
"
accept
"
"
input
"
"
expression
"
"
1
"
"
2
"
YY_NULLPTR
}
;
static
const
char
*
yysymbol_name
(
yysymbol_kind_t
yysymbol
)
{
return
yytname
[
yysymbol
]
;
}
#
endif
#
define
YYPACT_NINF
(
-
12
)
#
define
yypact_value_is_default
(
Yyn
)
(
(
Yyn
)
=
=
YYPACT_NINF
)
#
define
YYTABLE_NINF
(
-
1
)
#
define
yytable_value_is_error
(
Yyn
)
0
static
const
yytype_int16
yypact
[
]
=
{
31
-
12
-
12
31
31
31
31
31
51
76
-
12
-
12
-
12
-
12
53
-
12
-
12
-
12
31
31
31
31
31
31
31
31
31
31
31
31
31
31
31
31
-
12
31
31
124
138
26
149
149
-
11
-
11
-
11
-
11
154
154
-
8
-
8
-
12
-
12
-
12
93
109
}
;
static
const
yytype_int8
yydefact
[
]
=
{
0
3
4
0
0
0
0
0
0
2
28
27
25
26
0
1
5
7
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
29
0
0
9
10
11
13
12
17
16
15
14
19
18
21
20
24
23
22
6
8
}
;
static
const
yytype_int8
yypgoto
[
]
=
{
-
12
-
12
-
3
-
12
-
12
}
;
static
const
yytype_int8
yydefgoto
[
]
=
{
0
8
9
35
36
}
;
static
const
yytype_int8
yytable
[
]
=
{
10
11
12
13
14
27
28
29
30
31
32
33
31
32
33
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
0
53
54
1
2
21
22
23
24
25
26
27
28
29
30
31
32
33
3
4
15
0
0
0
5
6
7
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
0
0
0
0
34
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
20
21
22
23
24
25
26
27
28
29
30
31
32
33
23
24
25
26
27
28
29
30
31
32
33
29
30
31
32
33
}
;
static
const
yytype_int8
yycheck
[
]
=
{
3
4
5
6
7
16
17
18
19
20
21
22
20
21
22
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
-
1
35
36
3
4
10
11
12
13
14
15
16
17
18
19
20
21
22
18
19
0
-
1
-
1
-
1
24
25
26
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
-
1
-
1
-
1
-
1
27
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
9
10
11
12
13
14
15
16
17
18
19
20
21
22
12
13
14
15
16
17
18
19
20
21
22
18
19
20
21
22
}
;
static
const
yytype_int8
yystos
[
]
=
{
0
3
4
18
19
24
25
26
29
30
30
30
30
30
30
0
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
27
31
32
30
30
30
30
30
30
30
30
30
30
30
30
30
30
30
30
30
30
}
;
static
const
yytype_int8
yyr1
[
]
=
{
0
28
29
30
30
31
30
32
30
30
30
30
30
30
30
30
30
30
30
30
30
30
30
30
30
30
30
30
30
30
}
;
static
const
yytype_int8
yyr2
[
]
=
{
0
2
1
1
1
0
4
0
4
3
3
3
3
3
3
3
3
3
3
3
3
3
3
3
3
2
2
2
2
3
}
;
enum
{
YYENOMEM
=
-
2
}
;
#
define
yyerrok
(
yyerrstatus
=
0
)
#
define
yyclearin
(
yychar
=
PPEMPTY
)
#
define
YYACCEPT
goto
yyacceptlab
#
define
YYABORT
goto
yyabortlab
#
define
YYERROR
goto
yyerrorlab
#
define
YYNOMEM
goto
yyexhaustedlab
#
define
YYRECOVERING
(
)
(
!
!
yyerrstatus
)
#
define
YYBACKUP
(
Token
Value
)
\
do
\
if
(
yychar
=
=
PPEMPTY
)
\
{
\
yychar
=
(
Token
)
;
\
yylval
=
(
Value
)
;
\
YYPOPSTACK
(
yylen
)
;
\
yystate
=
*
yyssp
;
\
goto
yybackup
;
\
}
\
else
\
{
\
yyerror
(
context
YY_
(
"
syntax
error
:
cannot
back
up
"
)
)
;
\
YYERROR
;
\
}
\
while
(
0
)
#
define
YYERRCODE
PPUNDEF
#
if
PPDEBUG
#
ifndef
YYFPRINTF
#
include
<
stdio
.
h
>
#
define
YYFPRINTF
fprintf
#
endif
#
define
YYDPRINTF
(
Args
)
\
do
\
{
\
if
(
yydebug
)
\
YYFPRINTF
Args
;
\
}
while
(
0
)
#
define
YY_SYMBOL_PRINT
(
Title
Kind
Value
Location
)
\
do
\
{
\
if
(
yydebug
)
\
{
\
YYFPRINTF
(
stderr
"
%
s
"
Title
)
;
\
yy_symbol_print
(
stderr
Kind
Value
context
)
;
\
YYFPRINTF
(
stderr
"
\
n
"
)
;
\
}
\
}
while
(
0
)
static
void
yy_symbol_value_print
(
FILE
*
yyo
yysymbol_kind_t
yykind
YYSTYPE
const
*
const
yyvaluep
Context
*
context
)
{
FILE
*
yyoutput
=
yyo
;
YY_USE
(
yyoutput
)
;
YY_USE
(
context
)
;
if
(
!
yyvaluep
)
return
;
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
YY_USE
(
yykind
)
;
YY_IGNORE_MAYBE_UNINITIALIZED_END
}
static
void
yy_symbol_print
(
FILE
*
yyo
yysymbol_kind_t
yykind
YYSTYPE
const
*
const
yyvaluep
Context
*
context
)
{
YYFPRINTF
(
yyo
"
%
s
%
s
(
"
yykind
<
YYNTOKENS
?
"
token
"
:
"
nterm
"
yysymbol_name
(
yykind
)
)
;
yy_symbol_value_print
(
yyo
yykind
yyvaluep
context
)
;
YYFPRINTF
(
yyo
"
)
"
)
;
}
static
void
yy_stack_print
(
yy_state_t
*
yybottom
yy_state_t
*
yytop
)
{
YYFPRINTF
(
stderr
"
Stack
now
"
)
;
for
(
;
yybottom
<
=
yytop
;
yybottom
+
+
)
{
int
yybot
=
*
yybottom
;
YYFPRINTF
(
stderr
"
%
d
"
yybot
)
;
}
YYFPRINTF
(
stderr
"
\
n
"
)
;
}
#
define
YY_STACK_PRINT
(
Bottom
Top
)
\
do
\
{
\
if
(
yydebug
)
\
yy_stack_print
(
(
Bottom
)
(
Top
)
)
;
\
}
while
(
0
)
static
void
yy_reduce_print
(
yy_state_t
*
yyssp
YYSTYPE
*
yyvsp
int
yyrule
Context
*
context
)
{
int
yylno
=
yyrline
[
yyrule
]
;
int
yynrhs
=
yyr2
[
yyrule
]
;
int
yyi
;
YYFPRINTF
(
stderr
"
Reducing
stack
by
rule
%
d
(
line
%
d
)
:
\
n
"
yyrule
-
1
yylno
)
;
for
(
yyi
=
0
;
yyi
<
yynrhs
;
yyi
+
+
)
{
YYFPRINTF
(
stderr
"
%
d
=
"
yyi
+
1
)
;
yy_symbol_print
(
stderr
YY_ACCESSING_SYMBOL
(
+
yyssp
[
yyi
+
1
-
yynrhs
]
)
&
yyvsp
[
(
yyi
+
1
)
-
(
yynrhs
)
]
context
)
;
YYFPRINTF
(
stderr
"
\
n
"
)
;
}
}
#
define
YY_REDUCE_PRINT
(
Rule
)
\
do
\
{
\
if
(
yydebug
)
\
yy_reduce_print
(
yyssp
yyvsp
Rule
context
)
;
\
}
while
(
0
)
int
yydebug
;
#
else
#
define
YYDPRINTF
(
Args
)
(
(
void
)
0
)
#
define
YY_SYMBOL_PRINT
(
Title
Kind
Value
Location
)
#
define
YY_STACK_PRINT
(
Bottom
Top
)
#
define
YY_REDUCE_PRINT
(
Rule
)
#
endif
#
ifndef
YYINITDEPTH
#
define
YYINITDEPTH
200
#
endif
#
ifndef
YYMAXDEPTH
#
define
YYMAXDEPTH
10000
#
endif
static
void
yydestruct
(
const
char
*
yymsg
yysymbol_kind_t
yykind
YYSTYPE
*
yyvaluep
Context
*
context
)
{
YY_USE
(
yyvaluep
)
;
YY_USE
(
context
)
;
if
(
!
yymsg
)
yymsg
=
"
Deleting
"
;
YY_SYMBOL_PRINT
(
yymsg
yykind
yyvaluep
yylocationp
)
;
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
YY_USE
(
yykind
)
;
YY_IGNORE_MAYBE_UNINITIALIZED_END
}
int
yyparse
(
Context
*
context
)
{
int
yychar
;
YY_INITIAL_VALUE
(
static
YYSTYPE
yyval_default
;
)
YYSTYPE
yylval
YY_INITIAL_VALUE
(
=
yyval_default
)
;
int
yynerrs
=
0
;
yy_state_fast_t
yystate
=
0
;
int
yyerrstatus
=
0
;
YYPTRDIFF_T
yystacksize
=
YYINITDEPTH
;
yy_state_t
yyssa
[
YYINITDEPTH
]
;
yy_state_t
*
yyss
=
yyssa
;
yy_state_t
*
yyssp
=
yyss
;
YYSTYPE
yyvsa
[
YYINITDEPTH
]
;
YYSTYPE
*
yyvs
=
yyvsa
;
YYSTYPE
*
yyvsp
=
yyvs
;
int
yyn
;
int
yyresult
;
yysymbol_kind_t
yytoken
=
YYSYMBOL_YYEMPTY
;
YYSTYPE
yyval
;
#
define
YYPOPSTACK
(
N
)
(
yyvsp
-
=
(
N
)
yyssp
-
=
(
N
)
)
int
yylen
=
0
;
YYDPRINTF
(
(
stderr
"
Starting
parse
\
n
"
)
)
;
yychar
=
PPEMPTY
;
goto
yysetstate
;
yynewstate
:
yyssp
+
+
;
yysetstate
:
YYDPRINTF
(
(
stderr
"
Entering
state
%
d
\
n
"
yystate
)
)
;
YY_ASSERT
(
0
<
=
yystate
&
&
yystate
<
YYNSTATES
)
;
YY_IGNORE_USELESS_CAST_BEGIN
*
yyssp
=
YY_CAST
(
yy_state_t
yystate
)
;
YY_IGNORE_USELESS_CAST_END
YY_STACK_PRINT
(
yyss
yyssp
)
;
if
(
yyss
+
yystacksize
-
1
<
=
yyssp
)
#
if
!
defined
yyoverflow
&
&
!
defined
YYSTACK_RELOCATE
YYNOMEM
;
#
else
{
YYPTRDIFF_T
yysize
=
yyssp
-
yyss
+
1
;
#
if
defined
yyoverflow
{
yy_state_t
*
yyss1
=
yyss
;
YYSTYPE
*
yyvs1
=
yyvs
;
yyoverflow
(
YY_
(
"
memory
exhausted
"
)
&
yyss1
yysize
*
YYSIZEOF
(
*
yyssp
)
&
yyvs1
yysize
*
YYSIZEOF
(
*
yyvsp
)
&
yystacksize
)
;
yyss
=
yyss1
;
yyvs
=
yyvs1
;
}
#
else
if
(
YYMAXDEPTH
<
=
yystacksize
)
YYNOMEM
;
yystacksize
*
=
2
;
if
(
YYMAXDEPTH
<
yystacksize
)
yystacksize
=
YYMAXDEPTH
;
{
yy_state_t
*
yyss1
=
yyss
;
union
yyalloc
*
yyptr
=
YY_CAST
(
union
yyalloc
*
YYSTACK_ALLOC
(
YY_CAST
(
YYSIZE_T
YYSTACK_BYTES
(
yystacksize
)
)
)
)
;
if
(
!
yyptr
)
YYNOMEM
;
YYSTACK_RELOCATE
(
yyss_alloc
yyss
)
;
YYSTACK_RELOCATE
(
yyvs_alloc
yyvs
)
;
#
undef
YYSTACK_RELOCATE
if
(
yyss1
!
=
yyssa
)
YYSTACK_FREE
(
yyss1
)
;
}
#
endif
yyssp
=
yyss
+
yysize
-
1
;
yyvsp
=
yyvs
+
yysize
-
1
;
YY_IGNORE_USELESS_CAST_BEGIN
YYDPRINTF
(
(
stderr
"
Stack
size
increased
to
%
ld
\
n
"
YY_CAST
(
long
yystacksize
)
)
)
;
YY_IGNORE_USELESS_CAST_END
if
(
yyss
+
yystacksize
-
1
<
=
yyssp
)
YYABORT
;
}
#
endif
if
(
yystate
=
=
YYFINAL
)
YYACCEPT
;
goto
yybackup
;
yybackup
:
yyn
=
yypact
[
yystate
]
;
if
(
yypact_value_is_default
(
yyn
)
)
goto
yydefault
;
if
(
yychar
=
=
PPEMPTY
)
{
YYDPRINTF
(
(
stderr
"
Reading
a
token
\
n
"
)
)
;
yychar
=
yylex
(
&
yylval
context
)
;
}
if
(
yychar
<
=
PPEOF
)
{
yychar
=
PPEOF
;
yytoken
=
YYSYMBOL_YYEOF
;
YYDPRINTF
(
(
stderr
"
Now
at
end
of
input
.
\
n
"
)
)
;
}
else
if
(
yychar
=
=
PPerror
)
{
yychar
=
PPUNDEF
;
yytoken
=
YYSYMBOL_YYerror
;
goto
yyerrlab1
;
}
else
{
yytoken
=
YYTRANSLATE
(
yychar
)
;
YY_SYMBOL_PRINT
(
"
Next
token
is
"
yytoken
&
yylval
&
yylloc
)
;
}
yyn
+
=
yytoken
;
if
(
yyn
<
0
|
|
YYLAST
<
yyn
|
|
yycheck
[
yyn
]
!
=
yytoken
)
goto
yydefault
;
yyn
=
yytable
[
yyn
]
;
if
(
yyn
<
=
0
)
{
if
(
yytable_value_is_error
(
yyn
)
)
goto
yyerrlab
;
yyn
=
-
yyn
;
goto
yyreduce
;
}
if
(
yyerrstatus
)
yyerrstatus
-
-
;
YY_SYMBOL_PRINT
(
"
Shifting
"
yytoken
&
yylval
&
yylloc
)
;
yystate
=
yyn
;
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
*
+
+
yyvsp
=
yylval
;
YY_IGNORE_MAYBE_UNINITIALIZED_END
yychar
=
PPEMPTY
;
goto
yynewstate
;
yydefault
:
yyn
=
yydefact
[
yystate
]
;
if
(
yyn
=
=
0
)
goto
yyerrlab
;
goto
yyreduce
;
yyreduce
:
yylen
=
yyr2
[
yyn
]
;
yyval
=
yyvsp
[
1
-
yylen
]
;
YY_REDUCE_PRINT
(
yyn
)
;
switch
(
yyn
)
{
case
2
:
{
*
(
context
-
>
result
)
=
static_cast
<
int
>
(
yyvsp
[
0
]
)
;
YYACCEPT
;
}
break
;
case
4
:
{
if
(
!
context
-
>
isIgnoringErrors
(
)
)
{
context
-
>
diagnostics
-
>
report
(
context
-
>
errorSettings
.
unexpectedIdentifier
context
-
>
token
-
>
location
context
-
>
token
-
>
text
)
;
*
(
context
-
>
valid
)
=
false
;
}
yyval
=
yyvsp
[
0
]
;
}
break
;
case
5
:
{
if
(
yyvsp
[
-
1
]
!
=
0
)
{
context
-
>
startIgnoreErrors
(
)
;
}
}
break
;
case
6
:
{
if
(
yyvsp
[
-
3
]
!
=
0
)
{
context
-
>
endIgnoreErrors
(
)
;
yyval
=
static_cast
<
YYSTYPE
>
(
1
)
;
}
else
{
yyval
=
yyvsp
[
-
3
]
|
|
yyvsp
[
0
]
;
}
}
break
;
case
7
:
{
if
(
yyvsp
[
-
1
]
=
=
0
)
{
context
-
>
startIgnoreErrors
(
)
;
}
}
break
;
case
8
:
{
if
(
yyvsp
[
-
3
]
=
=
0
)
{
context
-
>
endIgnoreErrors
(
)
;
yyval
=
static_cast
<
YYSTYPE
>
(
0
)
;
}
else
{
yyval
=
yyvsp
[
-
3
]
&
&
yyvsp
[
0
]
;
}
}
break
;
case
9
:
{
yyval
=
yyvsp
[
-
2
]
|
yyvsp
[
0
]
;
}
break
;
case
10
:
{
yyval
=
yyvsp
[
-
2
]
^
yyvsp
[
0
]
;
}
break
;
case
11
:
{
yyval
=
yyvsp
[
-
2
]
&
yyvsp
[
0
]
;
}
break
;
case
12
:
{
yyval
=
yyvsp
[
-
2
]
!
=
yyvsp
[
0
]
;
}
break
;
case
13
:
{
yyval
=
yyvsp
[
-
2
]
=
=
yyvsp
[
0
]
;
}
break
;
case
14
:
{
yyval
=
yyvsp
[
-
2
]
>
=
yyvsp
[
0
]
;
}
break
;
case
15
:
{
yyval
=
yyvsp
[
-
2
]
<
=
yyvsp
[
0
]
;
}
break
;
case
16
:
{
yyval
=
yyvsp
[
-
2
]
>
yyvsp
[
0
]
;
}
break
;
case
17
:
{
yyval
=
yyvsp
[
-
2
]
<
yyvsp
[
0
]
;
}
break
;
case
18
:
{
if
(
yyvsp
[
0
]
<
0
|
|
yyvsp
[
0
]
>
31
)
{
if
(
!
context
-
>
isIgnoringErrors
(
)
)
{
std
:
:
ostringstream
stream
;
stream
<
<
yyvsp
[
-
2
]
<
<
"
>
>
"
<
<
yyvsp
[
0
]
;
std
:
:
string
text
=
stream
.
str
(
)
;
context
-
>
diagnostics
-
>
report
(
angle
:
:
pp
:
:
Diagnostics
:
:
PP_UNDEFINED_SHIFT
context
-
>
token
-
>
location
text
.
c_str
(
)
)
;
*
(
context
-
>
valid
)
=
false
;
}
yyval
=
static_cast
<
YYSTYPE
>
(
0
)
;
}
else
if
(
yyvsp
[
-
2
]
<
0
)
{
yyval
=
static_cast
<
YYSTYPE
>
(
static_cast
<
UNSIGNED_TYPE
>
(
yyvsp
[
-
2
]
)
>
>
yyvsp
[
0
]
)
;
}
else
{
yyval
=
yyvsp
[
-
2
]
>
>
yyvsp
[
0
]
;
}
}
break
;
case
19
:
{
if
(
yyvsp
[
0
]
<
0
|
|
yyvsp
[
0
]
>
31
)
{
if
(
!
context
-
>
isIgnoringErrors
(
)
)
{
std
:
:
ostringstream
stream
;
stream
<
<
yyvsp
[
-
2
]
<
<
"
<
<
"
<
<
yyvsp
[
0
]
;
std
:
:
string
text
=
stream
.
str
(
)
;
context
-
>
diagnostics
-
>
report
(
angle
:
:
pp
:
:
Diagnostics
:
:
PP_UNDEFINED_SHIFT
context
-
>
token
-
>
location
text
.
c_str
(
)
)
;
*
(
context
-
>
valid
)
=
false
;
}
yyval
=
static_cast
<
YYSTYPE
>
(
0
)
;
}
else
{
yyval
=
static_cast
<
YYSTYPE
>
(
static_cast
<
UNSIGNED_TYPE
>
(
yyvsp
[
-
2
]
)
<
<
yyvsp
[
0
]
)
;
}
}
break
;
case
20
:
{
yyval
=
gl
:
:
WrappingDiff
<
YYSTYPE
>
(
yyvsp
[
-
2
]
yyvsp
[
0
]
)
;
}
break
;
case
21
:
{
yyval
=
gl
:
:
WrappingSum
<
YYSTYPE
>
(
yyvsp
[
-
2
]
yyvsp
[
0
]
)
;
}
break
;
case
22
:
{
if
(
yyvsp
[
0
]
=
=
0
)
{
if
(
!
context
-
>
isIgnoringErrors
(
)
)
{
std
:
:
ostringstream
stream
;
stream
<
<
yyvsp
[
-
2
]
<
<
"
%
"
<
<
yyvsp
[
0
]
;
std
:
:
string
text
=
stream
.
str
(
)
;
context
-
>
diagnostics
-
>
report
(
angle
:
:
pp
:
:
Diagnostics
:
:
PP_DIVISION_BY_ZERO
context
-
>
token
-
>
location
text
.
c_str
(
)
)
;
*
(
context
-
>
valid
)
=
false
;
}
yyval
=
static_cast
<
YYSTYPE
>
(
0
)
;
}
else
if
(
(
yyvsp
[
-
2
]
=
=
std
:
:
numeric_limits
<
YYSTYPE
>
:
:
min
(
)
)
&
&
(
yyvsp
[
0
]
=
=
-
1
)
)
{
yyval
=
0
;
}
else
{
yyval
=
yyvsp
[
-
2
]
%
yyvsp
[
0
]
;
}
}
break
;
case
23
:
{
if
(
yyvsp
[
0
]
=
=
0
)
{
if
(
!
context
-
>
isIgnoringErrors
(
)
)
{
std
:
:
ostringstream
stream
;
stream
<
<
yyvsp
[
-
2
]
<
<
"
/
"
<
<
yyvsp
[
0
]
;
std
:
:
string
text
=
stream
.
str
(
)
;
context
-
>
diagnostics
-
>
report
(
angle
:
:
pp
:
:
Diagnostics
:
:
PP_DIVISION_BY_ZERO
context
-
>
token
-
>
location
text
.
c_str
(
)
)
;
*
(
context
-
>
valid
)
=
false
;
}
yyval
=
static_cast
<
YYSTYPE
>
(
0
)
;
}
else
if
(
(
yyvsp
[
-
2
]
=
=
std
:
:
numeric_limits
<
YYSTYPE
>
:
:
min
(
)
)
&
&
(
yyvsp
[
0
]
=
=
-
1
)
)
{
yyval
=
std
:
:
numeric_limits
<
YYSTYPE
>
:
:
max
(
)
;
}
else
{
yyval
=
yyvsp
[
-
2
]
/
yyvsp
[
0
]
;
}
}
break
;
case
24
:
{
yyval
=
gl
:
:
WrappingMul
(
yyvsp
[
-
2
]
yyvsp
[
0
]
)
;
}
break
;
case
25
:
{
yyval
=
!
yyvsp
[
0
]
;
}
break
;
case
26
:
{
yyval
=
~
yyvsp
[
0
]
;
}
break
;
case
27
:
{
if
(
yyvsp
[
0
]
=
=
std
:
:
numeric_limits
<
YYSTYPE
>
:
:
min
(
)
)
{
yyval
=
std
:
:
numeric_limits
<
YYSTYPE
>
:
:
min
(
)
;
}
else
{
yyval
=
-
yyvsp
[
0
]
;
}
}
break
;
case
28
:
{
yyval
=
+
yyvsp
[
0
]
;
}
break
;
case
29
:
{
yyval
=
yyvsp
[
-
1
]
;
}
break
;
default
:
break
;
}
YY_SYMBOL_PRINT
(
"
-
>
=
"
YY_CAST
(
yysymbol_kind_t
yyr1
[
yyn
]
)
&
yyval
&
yyloc
)
;
YYPOPSTACK
(
yylen
)
;
yylen
=
0
;
*
+
+
yyvsp
=
yyval
;
{
const
int
yylhs
=
yyr1
[
yyn
]
-
YYNTOKENS
;
const
int
yyi
=
yypgoto
[
yylhs
]
+
*
yyssp
;
yystate
=
(
0
<
=
yyi
&
&
yyi
<
=
YYLAST
&
&
yycheck
[
yyi
]
=
=
*
yyssp
?
yytable
[
yyi
]
:
yydefgoto
[
yylhs
]
)
;
}
goto
yynewstate
;
yyerrlab
:
yytoken
=
yychar
=
=
PPEMPTY
?
YYSYMBOL_YYEMPTY
:
YYTRANSLATE
(
yychar
)
;
if
(
!
yyerrstatus
)
{
+
+
yynerrs
;
yyerror
(
context
YY_
(
"
syntax
error
"
)
)
;
}
if
(
yyerrstatus
=
=
3
)
{
if
(
yychar
<
=
PPEOF
)
{
if
(
yychar
=
=
PPEOF
)
YYABORT
;
}
else
{
yydestruct
(
"
Error
:
discarding
"
yytoken
&
yylval
context
)
;
yychar
=
PPEMPTY
;
}
}
goto
yyerrlab1
;
yyerrorlab
:
if
(
0
)
YYERROR
;
+
+
yynerrs
;
YYPOPSTACK
(
yylen
)
;
yylen
=
0
;
YY_STACK_PRINT
(
yyss
yyssp
)
;
yystate
=
*
yyssp
;
goto
yyerrlab1
;
yyerrlab1
:
yyerrstatus
=
3
;
for
(
;
;
)
{
yyn
=
yypact
[
yystate
]
;
if
(
!
yypact_value_is_default
(
yyn
)
)
{
yyn
+
=
YYSYMBOL_YYerror
;
if
(
0
<
=
yyn
&
&
yyn
<
=
YYLAST
&
&
yycheck
[
yyn
]
=
=
YYSYMBOL_YYerror
)
{
yyn
=
yytable
[
yyn
]
;
if
(
0
<
yyn
)
break
;
}
}
if
(
yyssp
=
=
yyss
)
YYABORT
;
yydestruct
(
"
Error
:
popping
"
YY_ACCESSING_SYMBOL
(
yystate
)
yyvsp
context
)
;
YYPOPSTACK
(
1
)
;
yystate
=
*
yyssp
;
YY_STACK_PRINT
(
yyss
yyssp
)
;
}
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
*
+
+
yyvsp
=
yylval
;
YY_IGNORE_MAYBE_UNINITIALIZED_END
YY_SYMBOL_PRINT
(
"
Shifting
"
YY_ACCESSING_SYMBOL
(
yyn
)
yyvsp
yylsp
)
;
yystate
=
yyn
;
goto
yynewstate
;
yyacceptlab
:
yyresult
=
0
;
goto
yyreturnlab
;
yyabortlab
:
yyresult
=
1
;
goto
yyreturnlab
;
yyexhaustedlab
:
yyerror
(
context
YY_
(
"
memory
exhausted
"
)
)
;
yyresult
=
2
;
goto
yyreturnlab
;
yyreturnlab
:
if
(
yychar
!
=
PPEMPTY
)
{
yytoken
=
YYTRANSLATE
(
yychar
)
;
yydestruct
(
"
Cleanup
:
discarding
lookahead
"
yytoken
&
yylval
context
)
;
}
YYPOPSTACK
(
yylen
)
;
YY_STACK_PRINT
(
yyss
yyssp
)
;
while
(
yyssp
!
=
yyss
)
{
yydestruct
(
"
Cleanup
:
popping
"
YY_ACCESSING_SYMBOL
(
+
*
yyssp
)
yyvsp
context
)
;
YYPOPSTACK
(
1
)
;
}
#
ifndef
yyoverflow
if
(
yyss
!
=
yyssa
)
YYSTACK_FREE
(
yyss
)
;
#
endif
return
yyresult
;
}
int
yylex
(
YYSTYPE
*
lvalp
Context
*
context
)
{
angle
:
:
pp
:
:
Token
*
token
=
context
-
>
token
;
if
(
!
context
-
>
parsePresetToken
)
{
context
-
>
lexer
-
>
lex
(
token
)
;
}
context
-
>
parsePresetToken
=
false
;
int
type
=
0
;
switch
(
token
-
>
type
)
{
case
angle
:
:
pp
:
:
Token
:
:
CONST_INT
:
{
unsigned
int
val
=
0
;
int
testVal
=
0
;
if
(
!
token
-
>
uValue
(
&
val
)
|
|
(
!
token
-
>
iValue
(
&
testVal
)
&
&
context
-
>
errorSettings
.
integerLiteralsMustFit32BitSignedRange
)
)
{
context
-
>
diagnostics
-
>
report
(
angle
:
:
pp
:
:
Diagnostics
:
:
PP_INTEGER_OVERFLOW
token
-
>
location
token
-
>
text
)
;
*
(
context
-
>
valid
)
=
false
;
}
*
lvalp
=
static_cast
<
YYSTYPE
>
(
val
)
;
type
=
TOK_CONST_INT
;
break
;
}
case
angle
:
:
pp
:
:
Token
:
:
IDENTIFIER
:
*
lvalp
=
static_cast
<
YYSTYPE
>
(
-
1
)
;
type
=
TOK_IDENTIFIER
;
break
;
case
angle
:
:
pp
:
:
Token
:
:
OP_OR
:
type
=
TOK_OP_OR
;
break
;
case
angle
:
:
pp
:
:
Token
:
:
OP_AND
:
type
=
TOK_OP_AND
;
break
;
case
angle
:
:
pp
:
:
Token
:
:
OP_NE
:
type
=
TOK_OP_NE
;
break
;
case
angle
:
:
pp
:
:
Token
:
:
OP_EQ
:
type
=
TOK_OP_EQ
;
break
;
case
angle
:
:
pp
:
:
Token
:
:
OP_GE
:
type
=
TOK_OP_GE
;
break
;
case
angle
:
:
pp
:
:
Token
:
:
OP_LE
:
type
=
TOK_OP_LE
;
break
;
case
angle
:
:
pp
:
:
Token
:
:
OP_RIGHT
:
type
=
TOK_OP_RIGHT
;
break
;
case
angle
:
:
pp
:
:
Token
:
:
OP_LEFT
:
type
=
TOK_OP_LEFT
;
break
;
case
'
|
'
:
case
'
^
'
:
case
'
&
'
:
case
'
>
'
:
case
'
<
'
:
case
'
-
'
:
case
'
+
'
:
case
'
%
'
:
case
'
/
'
:
case
'
*
'
:
case
'
!
'
:
case
'
~
'
:
case
'
(
'
:
case
'
)
'
:
type
=
token
-
>
type
;
break
;
default
:
break
;
}
return
type
;
}
void
yyerror
(
Context
*
context
const
char
*
reason
)
{
context
-
>
diagnostics
-
>
report
(
angle
:
:
pp
:
:
Diagnostics
:
:
PP_INVALID_EXPRESSION
context
-
>
token
-
>
location
reason
)
;
}
namespace
angle
{
namespace
pp
{
ExpressionParser
:
:
ExpressionParser
(
Lexer
*
lexer
Diagnostics
*
diagnostics
)
:
mLexer
(
lexer
)
mDiagnostics
(
diagnostics
)
{
}
bool
ExpressionParser
:
:
parse
(
Token
*
token
int
*
result
bool
parsePresetToken
const
ErrorSettings
&
errorSettings
bool
*
valid
)
{
Context
context
;
context
.
diagnostics
=
mDiagnostics
;
context
.
lexer
=
mLexer
;
context
.
token
=
token
;
context
.
result
=
result
;
context
.
ignoreErrors
=
0
;
context
.
parsePresetToken
=
parsePresetToken
;
context
.
errorSettings
=
errorSettings
;
context
.
valid
=
valid
;
int
ret
=
yyparse
(
&
context
)
;
switch
(
ret
)
{
case
0
:
case
1
:
break
;
case
2
:
mDiagnostics
-
>
report
(
Diagnostics
:
:
PP_OUT_OF_MEMORY
token
-
>
location
"
"
)
;
break
;
default
:
assert
(
false
)
;
mDiagnostics
-
>
report
(
Diagnostics
:
:
PP_INTERNAL_ERROR
token
-
>
location
"
"
)
;
break
;
}
return
ret
=
=
0
;
}
}
}
