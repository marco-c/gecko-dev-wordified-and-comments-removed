#
ifndef
COMPILER_TRANSLATOR_SYMBOL_H_
#
define
COMPILER_TRANSLATOR_SYMBOL_H_
#
include
"
common
/
angleutils
.
h
"
#
include
"
compiler
/
translator
/
ExtensionBehavior
.
h
"
#
include
"
compiler
/
translator
/
ImmutableString
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
#
include
"
compiler
/
translator
/
SymbolUniqueId
.
h
"
namespace
sh
{
class
TSymbolTable
;
class
TSymbol
:
angle
:
:
NonCopyable
{
public
:
POOL_ALLOCATOR_NEW_DELETE
TSymbol
(
TSymbolTable
*
symbolTable
const
ImmutableString
&
name
SymbolType
symbolType
SymbolClass
symbolClass
TExtension
extension
=
TExtension
:
:
UNDEFINED
)
;
TSymbol
(
TSymbolTable
*
symbolTable
const
ImmutableString
&
name
SymbolType
symbolType
SymbolClass
symbolClass
const
std
:
:
array
<
TExtension
3u
>
&
extensions
)
;
~
TSymbol
(
)
=
default
;
ImmutableString
name
(
)
const
;
ImmutableString
getMangledName
(
)
const
;
bool
isFunction
(
)
const
{
return
mSymbolClass
=
=
SymbolClass
:
:
Function
;
}
bool
isVariable
(
)
const
{
return
mSymbolClass
=
=
SymbolClass
:
:
Variable
;
}
bool
isStruct
(
)
const
{
return
mSymbolClass
=
=
SymbolClass
:
:
Struct
;
}
bool
isInterfaceBlock
(
)
const
{
return
mSymbolClass
=
=
SymbolClass
:
:
InterfaceBlock
;
}
const
TSymbolUniqueId
&
uniqueId
(
)
const
{
return
mUniqueId
;
}
SymbolType
symbolType
(
)
const
{
return
mSymbolType
;
}
const
std
:
:
array
<
TExtension
3u
>
extensions
(
)
const
{
return
mExtensions
;
}
template
<
size_t
ExtensionCount
>
constexpr
const
std
:
:
array
<
TExtension
3u
>
CreateExtensionList
(
const
std
:
:
array
<
TExtension
ExtensionCount
>
&
extensions
)
{
switch
(
extensions
.
size
(
)
)
{
case
1
:
return
std
:
:
array
<
TExtension
3u
>
{
{
extensions
[
0
]
TExtension
:
:
UNDEFINED
TExtension
:
:
UNDEFINED
}
}
;
case
2
:
return
std
:
:
array
<
TExtension
3u
>
{
{
extensions
[
0
]
extensions
[
1
]
TExtension
:
:
UNDEFINED
}
}
;
case
3
:
return
std
:
:
array
<
TExtension
3u
>
{
{
extensions
[
0
]
extensions
[
1
]
extensions
[
2
]
}
}
;
default
:
UNREACHABLE
(
)
;
return
std
:
:
array
<
TExtension
3u
>
{
{
TExtension
:
:
UNDEFINED
TExtension
:
:
UNDEFINED
TExtension
:
:
UNDEFINED
}
}
;
}
}
protected
:
template
<
size_t
ExtensionCount
>
constexpr
TSymbol
(
const
TSymbolUniqueId
&
id
const
ImmutableString
&
name
SymbolType
symbolType
const
std
:
:
array
<
TExtension
ExtensionCount
>
&
extensions
SymbolClass
symbolClass
)
:
mName
(
name
)
mUniqueId
(
id
)
mExtensions
(
CreateExtensionList
(
extensions
)
)
mSymbolType
(
symbolType
)
mSymbolClass
(
symbolClass
)
{
}
const
ImmutableString
mName
;
private
:
const
TSymbolUniqueId
mUniqueId
;
const
std
:
:
array
<
TExtension
3u
>
mExtensions
;
const
SymbolType
mSymbolType
:
4
;
const
SymbolClass
mSymbolClass
:
4
;
}
;
static_assert
(
sizeof
(
TSymbol
)
<
=
24
"
Size
check
failed
"
)
;
class
TVariable
:
public
TSymbol
{
public
:
TVariable
(
TSymbolTable
*
symbolTable
const
ImmutableString
&
name
const
TType
*
type
SymbolType
symbolType
TExtension
ext
=
TExtension
:
:
UNDEFINED
)
;
TVariable
(
TSymbolTable
*
symbolTable
const
ImmutableString
&
name
const
TType
*
type
SymbolType
symbolType
const
std
:
:
array
<
TExtension
3u
>
&
extensions
)
;
const
TType
&
getType
(
)
const
{
return
*
mType
;
}
const
TConstantUnion
*
getConstPointer
(
)
const
{
return
unionArray
;
}
void
shareConstPointer
(
const
TConstantUnion
*
constArray
)
{
unionArray
=
constArray
;
}
constexpr
TVariable
(
const
TSymbolUniqueId
&
id
const
ImmutableString
&
name
SymbolType
symbolType
TExtension
extension
const
TType
*
type
)
:
TSymbol
(
id
name
symbolType
std
:
:
array
<
TExtension
1u
>
{
{
extension
}
}
SymbolClass
:
:
Variable
)
mType
(
type
)
unionArray
(
nullptr
)
{
}
template
<
size_t
ExtensionCount
>
constexpr
TVariable
(
const
TSymbolUniqueId
&
id
const
ImmutableString
&
name
SymbolType
symbolType
const
std
:
:
array
<
TExtension
ExtensionCount
>
&
extensions
const
TType
*
type
)
:
TSymbol
(
id
name
symbolType
extensions
SymbolClass
:
:
Variable
)
mType
(
type
)
unionArray
(
nullptr
)
{
}
private
:
const
TType
*
mType
;
const
TConstantUnion
*
unionArray
;
}
;
class
TStructure
:
public
TSymbol
public
TFieldListCollection
{
public
:
TStructure
(
TSymbolTable
*
symbolTable
const
ImmutableString
&
name
const
TFieldList
*
fields
SymbolType
symbolType
)
;
void
createSamplerSymbols
(
const
char
*
namePrefix
const
TString
&
apiNamePrefix
TVector
<
const
TVariable
*
>
*
outputSymbols
TMap
<
const
TVariable
*
TString
>
*
outputSymbolsToAPINames
TSymbolTable
*
symbolTable
)
const
;
void
setAtGlobalScope
(
bool
atGlobalScope
)
{
mAtGlobalScope
=
atGlobalScope
;
}
bool
atGlobalScope
(
)
const
{
return
mAtGlobalScope
;
}
private
:
friend
class
TSymbolTable
;
TStructure
(
const
TSymbolUniqueId
&
id
const
ImmutableString
&
name
TExtension
extension
const
TFieldList
*
fields
)
:
TSymbol
(
id
name
SymbolType
:
:
BuiltIn
std
:
:
array
<
TExtension
1u
>
{
{
extension
}
}
SymbolClass
:
:
Struct
)
TFieldListCollection
(
fields
)
{
}
template
<
size_t
ExtensionCount
>
TStructure
(
const
TSymbolUniqueId
&
id
const
ImmutableString
&
name
const
std
:
:
array
<
TExtension
ExtensionCount
>
&
extensions
const
TFieldList
*
fields
)
:
TSymbol
(
id
name
SymbolType
:
:
BuiltIn
extensions
SymbolClass
:
:
Struct
)
TFieldListCollection
(
fields
)
{
}
friend
class
RegenerateStructNamesTraverser
;
void
setName
(
const
ImmutableString
&
name
)
;
bool
mAtGlobalScope
;
}
;
class
TInterfaceBlock
:
public
TSymbol
public
TFieldListCollection
{
public
:
TInterfaceBlock
(
TSymbolTable
*
symbolTable
const
ImmutableString
&
name
const
TFieldList
*
fields
const
TLayoutQualifier
&
layoutQualifier
SymbolType
symbolType
TExtension
extension
=
TExtension
:
:
UNDEFINED
)
;
TInterfaceBlock
(
TSymbolTable
*
symbolTable
const
ImmutableString
&
name
const
TFieldList
*
fields
const
TLayoutQualifier
&
layoutQualifier
SymbolType
symbolType
const
std
:
:
array
<
TExtension
3u
>
&
extensions
)
;
TLayoutBlockStorage
blockStorage
(
)
const
{
return
mBlockStorage
;
}
int
blockBinding
(
)
const
{
return
mBinding
;
}
private
:
friend
class
TSymbolTable
;
TInterfaceBlock
(
const
TSymbolUniqueId
&
id
const
ImmutableString
&
name
TExtension
extension
const
TFieldList
*
fields
)
:
TSymbol
(
id
name
SymbolType
:
:
BuiltIn
std
:
:
array
<
TExtension
1u
>
{
{
extension
}
}
SymbolClass
:
:
InterfaceBlock
)
TFieldListCollection
(
fields
)
mBlockStorage
(
EbsUnspecified
)
mBinding
(
0
)
{
}
template
<
size_t
ExtensionCount
>
TInterfaceBlock
(
const
TSymbolUniqueId
&
id
const
ImmutableString
&
name
const
std
:
:
array
<
TExtension
ExtensionCount
>
&
extensions
const
TFieldList
*
fields
)
:
TSymbol
(
id
name
SymbolType
:
:
BuiltIn
extensions
SymbolClass
:
:
InterfaceBlock
)
TFieldListCollection
(
fields
)
mBlockStorage
(
EbsUnspecified
)
mBinding
(
0
)
{
}
TLayoutBlockStorage
mBlockStorage
;
int
mBinding
;
}
;
struct
TParameter
{
const
TVariable
*
createVariable
(
TSymbolTable
*
symbolTable
)
{
const
ImmutableString
constName
(
name
)
;
const
TType
*
constType
=
type
;
name
=
nullptr
;
type
=
nullptr
;
return
new
TVariable
(
symbolTable
constName
constType
constName
.
empty
(
)
?
SymbolType
:
:
Empty
:
SymbolType
:
:
UserDefined
)
;
}
const
char
*
name
;
TType
*
type
;
}
;
class
TFunction
:
public
TSymbol
{
public
:
TFunction
(
TSymbolTable
*
symbolTable
const
ImmutableString
&
name
SymbolType
symbolType
const
TType
*
retType
bool
knownToNotHaveSideEffects
)
;
void
addParameter
(
const
TVariable
*
p
)
;
void
shareParameters
(
const
TFunction
&
parametersSource
)
;
ImmutableString
getFunctionMangledName
(
)
const
{
ASSERT
(
symbolType
(
)
!
=
SymbolType
:
:
BuiltIn
)
;
if
(
mMangledName
.
empty
(
)
)
{
mMangledName
=
buildMangledName
(
)
;
}
return
mMangledName
;
}
const
TType
&
getReturnType
(
)
const
{
return
*
returnType
;
}
TOperator
getBuiltInOp
(
)
const
{
return
mOp
;
}
void
setDefined
(
)
{
defined
=
true
;
}
bool
isDefined
(
)
const
{
return
defined
;
}
void
setHasPrototypeDeclaration
(
)
{
mHasPrototypeDeclaration
=
true
;
}
bool
hasPrototypeDeclaration
(
)
const
{
return
mHasPrototypeDeclaration
;
}
void
setHasVoidParameter
(
)
{
mHasVoidParameter
=
true
;
}
bool
hasVoidParameter
(
)
const
{
return
mHasVoidParameter
;
}
size_t
getParamCount
(
)
const
{
return
mParamCount
;
}
const
TVariable
*
getParam
(
size_t
i
)
const
{
return
mParameters
[
i
]
;
}
bool
isKnownToNotHaveSideEffects
(
)
const
{
return
mKnownToNotHaveSideEffects
;
}
bool
isMain
(
)
const
;
bool
isImageFunction
(
)
const
;
bool
isAtomicCounterFunction
(
)
const
;
constexpr
TFunction
(
const
TSymbolUniqueId
&
id
const
ImmutableString
&
name
TExtension
extension
const
TVariable
*
const
*
parameters
size_t
paramCount
const
TType
*
retType
TOperator
op
bool
knownToNotHaveSideEffects
)
:
TSymbol
(
id
name
SymbolType
:
:
BuiltIn
std
:
:
array
<
TExtension
1u
>
{
{
extension
}
}
SymbolClass
:
:
Function
)
mParametersVector
(
nullptr
)
mParameters
(
parameters
)
returnType
(
retType
)
mMangledName
(
nullptr
)
mParamCount
(
paramCount
)
mOp
(
op
)
defined
(
false
)
mHasPrototypeDeclaration
(
false
)
mKnownToNotHaveSideEffects
(
knownToNotHaveSideEffects
)
mHasVoidParameter
(
false
)
{
}
template
<
size_t
ExtensionCount
>
constexpr
TFunction
(
const
TSymbolUniqueId
&
id
const
ImmutableString
&
name
const
std
:
:
array
<
TExtension
ExtensionCount
>
&
extensions
const
TVariable
*
const
*
parameters
size_t
paramCount
const
TType
*
retType
TOperator
op
bool
knownToNotHaveSideEffects
)
:
TSymbol
(
id
name
SymbolType
:
:
BuiltIn
extensions
SymbolClass
:
:
Function
)
mParametersVector
(
nullptr
)
mParameters
(
parameters
)
returnType
(
retType
)
mMangledName
(
nullptr
)
mParamCount
(
paramCount
)
mOp
(
op
)
defined
(
false
)
mHasPrototypeDeclaration
(
false
)
mKnownToNotHaveSideEffects
(
knownToNotHaveSideEffects
)
mHasVoidParameter
(
false
)
{
}
private
:
ImmutableString
buildMangledName
(
)
const
;
typedef
TVector
<
const
TVariable
*
>
TParamVector
;
TParamVector
*
mParametersVector
;
const
TVariable
*
const
*
mParameters
;
const
TType
*
const
returnType
;
mutable
ImmutableString
mMangledName
;
size_t
mParamCount
:
32
;
const
TOperator
mOp
;
bool
defined
:
1
;
bool
mHasPrototypeDeclaration
:
1
;
bool
mKnownToNotHaveSideEffects
:
1
;
bool
mHasVoidParameter
:
1
;
}
;
}
#
endif
