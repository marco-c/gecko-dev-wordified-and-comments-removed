#
ifndef
COMPILER_TRANSLATOR_SYMBOL_H_
#
define
COMPILER_TRANSLATOR_SYMBOL_H_
#
include
"
common
/
angleutils
.
h
"
#
include
"
compiler
/
translator
/
ExtensionBehavior
.
h
"
#
include
"
compiler
/
translator
/
ImmutableString
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
#
include
"
compiler
/
translator
/
SymbolUniqueId
.
h
"
namespace
sh
{
class
TSymbolTable
;
enum
class
SymbolType
{
BuiltIn
UserDefined
AngleInternal
Empty
}
;
class
TSymbol
:
angle
:
:
NonCopyable
{
public
:
POOL_ALLOCATOR_NEW_DELETE
(
)
;
TSymbol
(
TSymbolTable
*
symbolTable
const
ImmutableString
&
name
SymbolType
symbolType
TExtension
extension
=
TExtension
:
:
UNDEFINED
)
;
~
TSymbol
(
)
=
default
;
ImmutableString
name
(
)
const
;
virtual
ImmutableString
getMangledName
(
)
const
;
virtual
bool
isFunction
(
)
const
{
return
false
;
}
virtual
bool
isVariable
(
)
const
{
return
false
;
}
virtual
bool
isStruct
(
)
const
{
return
false
;
}
const
TSymbolUniqueId
&
uniqueId
(
)
const
{
return
mUniqueId
;
}
SymbolType
symbolType
(
)
const
{
return
mSymbolType
;
}
TExtension
extension
(
)
const
{
return
mExtension
;
}
protected
:
constexpr
TSymbol
(
const
TSymbolUniqueId
&
id
const
ImmutableString
&
name
SymbolType
symbolType
TExtension
extension
)
:
mName
(
name
)
mUniqueId
(
id
)
mSymbolType
(
symbolType
)
mExtension
(
extension
)
{
}
const
ImmutableString
mName
;
private
:
const
TSymbolUniqueId
mUniqueId
;
const
SymbolType
mSymbolType
;
const
TExtension
mExtension
;
}
;
class
TVariable
:
public
TSymbol
{
public
:
TVariable
(
TSymbolTable
*
symbolTable
const
ImmutableString
&
name
const
TType
*
type
SymbolType
symbolType
TExtension
ext
=
TExtension
:
:
UNDEFINED
)
;
bool
isVariable
(
)
const
override
{
return
true
;
}
const
TType
&
getType
(
)
const
{
return
*
mType
;
}
const
TConstantUnion
*
getConstPointer
(
)
const
{
return
unionArray
;
}
void
shareConstPointer
(
const
TConstantUnion
*
constArray
)
{
unionArray
=
constArray
;
}
private
:
constexpr
TVariable
(
const
TSymbolUniqueId
&
id
const
ImmutableString
&
name
SymbolType
symbolType
TExtension
extension
const
TType
*
type
)
:
TSymbol
(
id
name
symbolType
extension
)
mType
(
type
)
unionArray
(
nullptr
)
{
}
const
TType
*
mType
;
const
TConstantUnion
*
unionArray
;
}
;
class
TStructure
:
public
TSymbol
public
TFieldListCollection
{
public
:
TStructure
(
TSymbolTable
*
symbolTable
const
ImmutableString
&
name
const
TFieldList
*
fields
SymbolType
symbolType
)
;
bool
isStruct
(
)
const
override
{
return
true
;
}
void
createSamplerSymbols
(
const
char
*
namePrefix
const
TString
&
apiNamePrefix
TVector
<
const
TVariable
*
>
*
outputSymbols
TMap
<
const
TVariable
*
TString
>
*
outputSymbolsToAPINames
TSymbolTable
*
symbolTable
)
const
;
void
setAtGlobalScope
(
bool
atGlobalScope
)
{
mAtGlobalScope
=
atGlobalScope
;
}
bool
atGlobalScope
(
)
const
{
return
mAtGlobalScope
;
}
private
:
friend
class
RegenerateStructNames
;
void
setName
(
const
ImmutableString
&
name
)
;
bool
mAtGlobalScope
;
}
;
class
TInterfaceBlock
:
public
TSymbol
public
TFieldListCollection
{
public
:
TInterfaceBlock
(
TSymbolTable
*
symbolTable
const
ImmutableString
&
name
const
TFieldList
*
fields
const
TLayoutQualifier
&
layoutQualifier
SymbolType
symbolType
TExtension
extension
=
TExtension
:
:
UNDEFINED
)
;
TLayoutBlockStorage
blockStorage
(
)
const
{
return
mBlockStorage
;
}
int
blockBinding
(
)
const
{
return
mBinding
;
}
private
:
TLayoutBlockStorage
mBlockStorage
;
int
mBinding
;
}
;
struct
TConstParameter
{
POOL_ALLOCATOR_NEW_DELETE
(
)
;
TConstParameter
(
)
:
name
(
"
"
)
type
(
nullptr
)
{
}
explicit
TConstParameter
(
const
ImmutableString
&
n
)
:
name
(
n
)
type
(
nullptr
)
{
}
constexpr
explicit
TConstParameter
(
const
TType
*
t
)
:
name
(
"
"
)
type
(
t
)
{
}
TConstParameter
(
const
ImmutableString
&
n
const
TType
*
t
)
:
name
(
n
)
type
(
t
)
{
}
TConstParameter
(
ImmutableString
*
n
TType
*
t
)
=
delete
;
TConstParameter
(
const
ImmutableString
*
n
TType
*
t
)
=
delete
;
TConstParameter
(
ImmutableString
*
n
const
TType
*
t
)
=
delete
;
const
ImmutableString
name
;
const
TType
*
const
type
;
}
;
struct
TParameter
{
TConstParameter
turnToConst
(
)
{
const
ImmutableString
constName
(
name
)
;
const
TType
*
constType
=
type
;
name
=
nullptr
;
type
=
nullptr
;
return
TConstParameter
(
constName
constType
)
;
}
const
char
*
name
;
TType
*
type
;
}
;
class
TFunction
:
public
TSymbol
{
public
:
TFunction
(
TSymbolTable
*
symbolTable
const
ImmutableString
&
name
SymbolType
symbolType
const
TType
*
retType
bool
knownToNotHaveSideEffects
)
;
TFunction
(
TSymbolTable
*
symbolTable
const
ImmutableString
&
name
TExtension
extension
TConstParameter
*
parameters
size_t
paramCount
const
TType
*
retType
TOperator
op
bool
knownToNotHaveSideEffects
)
;
bool
isFunction
(
)
const
override
{
return
true
;
}
void
addParameter
(
const
TConstParameter
&
p
)
;
void
shareParameters
(
const
TFunction
&
parametersSource
)
;
ImmutableString
getMangledName
(
)
const
override
{
if
(
mMangledName
=
=
"
"
)
{
mMangledName
=
buildMangledName
(
)
;
}
return
mMangledName
;
}
const
TType
&
getReturnType
(
)
const
{
return
*
returnType
;
}
TOperator
getBuiltInOp
(
)
const
{
return
mOp
;
}
void
setDefined
(
)
{
defined
=
true
;
}
bool
isDefined
(
)
{
return
defined
;
}
void
setHasPrototypeDeclaration
(
)
{
mHasPrototypeDeclaration
=
true
;
}
bool
hasPrototypeDeclaration
(
)
const
{
return
mHasPrototypeDeclaration
;
}
size_t
getParamCount
(
)
const
{
return
mParamCount
;
}
const
TConstParameter
&
getParam
(
size_t
i
)
const
{
return
mParameters
[
i
]
;
}
bool
isKnownToNotHaveSideEffects
(
)
const
{
return
mKnownToNotHaveSideEffects
;
}
bool
isMain
(
)
const
;
bool
isImageFunction
(
)
const
;
private
:
constexpr
TFunction
(
const
TSymbolUniqueId
&
id
const
ImmutableString
&
name
TExtension
extension
const
TConstParameter
*
parameters
size_t
paramCount
const
TType
*
retType
const
ImmutableString
&
mangledName
TOperator
op
bool
knownToNotHaveSideEffects
)
:
TSymbol
(
id
name
SymbolType
:
:
BuiltIn
extension
)
mParametersVector
(
nullptr
)
mParameters
(
parameters
)
mParamCount
(
paramCount
)
returnType
(
retType
)
mMangledName
(
mangledName
)
mOp
(
op
)
defined
(
false
)
mHasPrototypeDeclaration
(
false
)
mKnownToNotHaveSideEffects
(
knownToNotHaveSideEffects
)
{
}
ImmutableString
buildMangledName
(
)
const
;
typedef
TVector
<
TConstParameter
>
TParamVector
;
TParamVector
*
mParametersVector
;
const
TConstParameter
*
mParameters
;
size_t
mParamCount
;
const
TType
*
const
returnType
;
mutable
ImmutableString
mMangledName
;
const
TOperator
mOp
;
bool
defined
;
bool
mHasPrototypeDeclaration
;
bool
mKnownToNotHaveSideEffects
;
}
;
}
#
endif
