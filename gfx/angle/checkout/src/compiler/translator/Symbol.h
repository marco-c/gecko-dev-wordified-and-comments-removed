#
ifndef
COMPILER_TRANSLATOR_SYMBOL_H_
#
define
COMPILER_TRANSLATOR_SYMBOL_H_
#
include
"
common
/
angleutils
.
h
"
#
include
"
compiler
/
translator
/
ExtensionBehavior
.
h
"
#
include
"
compiler
/
translator
/
ImmutableString
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
#
include
"
compiler
/
translator
/
SymbolUniqueId
.
h
"
namespace
sh
{
class
TSymbolTable
;
enum
class
SymbolType
{
BuiltIn
UserDefined
AngleInternal
Empty
}
;
enum
class
SymbolClass
{
Function
Variable
Struct
InterfaceBlock
}
;
class
TSymbol
:
angle
:
:
NonCopyable
{
public
:
POOL_ALLOCATOR_NEW_DELETE
(
)
;
TSymbol
(
TSymbolTable
*
symbolTable
const
ImmutableString
&
name
SymbolType
symbolType
SymbolClass
symbolClass
TExtension
extension
=
TExtension
:
:
UNDEFINED
)
;
~
TSymbol
(
)
=
default
;
ImmutableString
name
(
)
const
;
ImmutableString
getMangledName
(
)
const
;
bool
isFunction
(
)
const
{
return
mSymbolClass
=
=
SymbolClass
:
:
Function
;
}
bool
isVariable
(
)
const
{
return
mSymbolClass
=
=
SymbolClass
:
:
Variable
;
}
bool
isStruct
(
)
const
{
return
mSymbolClass
=
=
SymbolClass
:
:
Struct
;
}
const
TSymbolUniqueId
&
uniqueId
(
)
const
{
return
mUniqueId
;
}
SymbolType
symbolType
(
)
const
{
return
mSymbolType
;
}
TExtension
extension
(
)
const
{
return
mExtension
;
}
protected
:
constexpr
TSymbol
(
const
TSymbolUniqueId
&
id
const
ImmutableString
&
name
SymbolType
symbolType
TExtension
extension
SymbolClass
symbolClass
)
:
mName
(
name
)
mUniqueId
(
id
)
mSymbolType
(
symbolType
)
mExtension
(
extension
)
mSymbolClass
(
symbolClass
)
{
}
const
ImmutableString
mName
;
private
:
const
TSymbolUniqueId
mUniqueId
;
const
SymbolType
mSymbolType
;
const
TExtension
mExtension
;
const
SymbolClass
mSymbolClass
;
}
;
class
TVariable
:
public
TSymbol
{
public
:
TVariable
(
TSymbolTable
*
symbolTable
const
ImmutableString
&
name
const
TType
*
type
SymbolType
symbolType
TExtension
ext
=
TExtension
:
:
UNDEFINED
)
;
const
TType
&
getType
(
)
const
{
return
*
mType
;
}
const
TConstantUnion
*
getConstPointer
(
)
const
{
return
unionArray
;
}
void
shareConstPointer
(
const
TConstantUnion
*
constArray
)
{
unionArray
=
constArray
;
}
constexpr
TVariable
(
const
TSymbolUniqueId
&
id
const
ImmutableString
&
name
SymbolType
symbolType
TExtension
extension
const
TType
*
type
)
:
TSymbol
(
id
name
symbolType
extension
SymbolClass
:
:
Variable
)
mType
(
type
)
unionArray
(
nullptr
)
{
}
private
:
const
TType
*
mType
;
const
TConstantUnion
*
unionArray
;
}
;
class
TStructure
:
public
TSymbol
public
TFieldListCollection
{
public
:
TStructure
(
TSymbolTable
*
symbolTable
const
ImmutableString
&
name
const
TFieldList
*
fields
SymbolType
symbolType
)
;
void
createSamplerSymbols
(
const
char
*
namePrefix
const
TString
&
apiNamePrefix
TVector
<
const
TVariable
*
>
*
outputSymbols
TMap
<
const
TVariable
*
TString
>
*
outputSymbolsToAPINames
TSymbolTable
*
symbolTable
)
const
;
void
setAtGlobalScope
(
bool
atGlobalScope
)
{
mAtGlobalScope
=
atGlobalScope
;
}
bool
atGlobalScope
(
)
const
{
return
mAtGlobalScope
;
}
private
:
friend
class
TSymbolTable
;
TStructure
(
const
TSymbolUniqueId
&
id
const
ImmutableString
&
name
TExtension
extension
const
TFieldList
*
fields
)
;
friend
class
RegenerateStructNames
;
void
setName
(
const
ImmutableString
&
name
)
;
bool
mAtGlobalScope
;
}
;
class
TInterfaceBlock
:
public
TSymbol
public
TFieldListCollection
{
public
:
TInterfaceBlock
(
TSymbolTable
*
symbolTable
const
ImmutableString
&
name
const
TFieldList
*
fields
const
TLayoutQualifier
&
layoutQualifier
SymbolType
symbolType
TExtension
extension
=
TExtension
:
:
UNDEFINED
)
;
TLayoutBlockStorage
blockStorage
(
)
const
{
return
mBlockStorage
;
}
int
blockBinding
(
)
const
{
return
mBinding
;
}
private
:
friend
class
TSymbolTable
;
TInterfaceBlock
(
const
TSymbolUniqueId
&
id
const
ImmutableString
&
name
TExtension
extension
const
TFieldList
*
fields
)
;
TLayoutBlockStorage
mBlockStorage
;
int
mBinding
;
}
;
struct
TParameter
{
const
TVariable
*
createVariable
(
TSymbolTable
*
symbolTable
)
{
const
ImmutableString
constName
(
name
)
;
const
TType
*
constType
=
type
;
name
=
nullptr
;
type
=
nullptr
;
return
new
TVariable
(
symbolTable
constName
constType
constName
.
empty
(
)
?
SymbolType
:
:
Empty
:
SymbolType
:
:
UserDefined
)
;
}
const
char
*
name
;
TType
*
type
;
}
;
class
TFunction
:
public
TSymbol
{
public
:
TFunction
(
TSymbolTable
*
symbolTable
const
ImmutableString
&
name
SymbolType
symbolType
const
TType
*
retType
bool
knownToNotHaveSideEffects
)
;
void
addParameter
(
const
TVariable
*
p
)
;
void
shareParameters
(
const
TFunction
&
parametersSource
)
;
ImmutableString
getFunctionMangledName
(
)
const
{
ASSERT
(
symbolType
(
)
!
=
SymbolType
:
:
BuiltIn
)
;
if
(
mMangledName
.
empty
(
)
)
{
mMangledName
=
buildMangledName
(
)
;
}
return
mMangledName
;
}
const
TType
&
getReturnType
(
)
const
{
return
*
returnType
;
}
TOperator
getBuiltInOp
(
)
const
{
return
mOp
;
}
void
setDefined
(
)
{
defined
=
true
;
}
bool
isDefined
(
)
{
return
defined
;
}
void
setHasPrototypeDeclaration
(
)
{
mHasPrototypeDeclaration
=
true
;
}
bool
hasPrototypeDeclaration
(
)
const
{
return
mHasPrototypeDeclaration
;
}
size_t
getParamCount
(
)
const
{
return
mParamCount
;
}
const
TVariable
*
getParam
(
size_t
i
)
const
{
return
mParameters
[
i
]
;
}
bool
isKnownToNotHaveSideEffects
(
)
const
{
return
mKnownToNotHaveSideEffects
;
}
bool
isMain
(
)
const
;
bool
isImageFunction
(
)
const
;
constexpr
TFunction
(
const
TSymbolUniqueId
&
id
const
ImmutableString
&
name
TExtension
extension
const
TVariable
*
const
*
parameters
size_t
paramCount
const
TType
*
retType
TOperator
op
bool
knownToNotHaveSideEffects
)
:
TSymbol
(
id
name
SymbolType
:
:
BuiltIn
extension
SymbolClass
:
:
Function
)
mParametersVector
(
nullptr
)
mParameters
(
parameters
)
mParamCount
(
paramCount
)
returnType
(
retType
)
mMangledName
(
nullptr
)
mOp
(
op
)
defined
(
false
)
mHasPrototypeDeclaration
(
false
)
mKnownToNotHaveSideEffects
(
knownToNotHaveSideEffects
)
{
}
private
:
ImmutableString
buildMangledName
(
)
const
;
typedef
TVector
<
const
TVariable
*
>
TParamVector
;
TParamVector
*
mParametersVector
;
const
TVariable
*
const
*
mParameters
;
size_t
mParamCount
;
const
TType
*
const
returnType
;
mutable
ImmutableString
mMangledName
;
const
TOperator
mOp
;
bool
defined
;
bool
mHasPrototypeDeclaration
;
bool
mKnownToNotHaveSideEffects
;
}
;
}
#
endif
