#
include
"
compiler
/
translator
/
TranslatorGLSL
.
h
"
#
include
"
angle_gl
.
h
"
#
include
"
compiler
/
translator
/
BuiltInFunctionEmulatorGLSL
.
h
"
#
include
"
compiler
/
translator
/
ExtensionGLSL
.
h
"
#
include
"
compiler
/
translator
/
OutputGLSL
.
h
"
#
include
"
compiler
/
translator
/
VersionGLSL
.
h
"
#
include
"
compiler
/
translator
/
tree_ops
/
RewriteTexelFetchOffset
.
h
"
#
include
"
compiler
/
translator
/
tree_ops
/
apple
/
RewriteRowMajorMatrices
.
h
"
#
include
"
compiler
/
translator
/
tree_ops
/
apple
/
RewriteUnaryMinusOperatorFloat
.
h
"
namespace
sh
{
TranslatorGLSL
:
:
TranslatorGLSL
(
sh
:
:
GLenum
type
ShShaderSpec
spec
ShShaderOutput
output
)
:
TCompiler
(
type
spec
output
)
{
}
void
TranslatorGLSL
:
:
initBuiltInFunctionEmulator
(
BuiltInFunctionEmulator
*
emu
const
ShCompileOptions
&
compileOptions
)
{
if
(
compileOptions
.
emulateAbsIntFunction
)
{
InitBuiltInAbsFunctionEmulatorForGLSLWorkarounds
(
emu
getShaderType
(
)
)
;
}
if
(
compileOptions
.
emulateIsnanFloatFunction
)
{
InitBuiltInIsnanFunctionEmulatorForGLSLWorkarounds
(
emu
getShaderVersion
(
)
)
;
}
if
(
compileOptions
.
emulateAtan2FloatFunction
)
{
InitBuiltInAtanFunctionEmulatorForGLSLWorkarounds
(
emu
)
;
}
int
targetGLSLVersion
=
ShaderOutputTypeToGLSLVersion
(
getOutputType
(
)
)
;
InitBuiltInFunctionEmulatorForGLSLMissingFunctions
(
emu
getShaderType
(
)
targetGLSLVersion
)
;
}
bool
TranslatorGLSL
:
:
translate
(
TIntermBlock
*
root
const
ShCompileOptions
&
compileOptions
PerformanceDiagnostics
*
)
{
TInfoSinkBase
&
sink
=
getInfoSink
(
)
.
obj
;
writeVersion
(
root
)
;
writeExtensionBehavior
(
root
compileOptions
)
;
WritePragma
(
sink
compileOptions
getPragma
(
)
)
;
if
(
compileOptions
.
flattenPragmaSTDGLInvariantAll
&
&
getPragma
(
)
.
stdgl
.
invariantAll
&
&
!
sh
:
:
RemoveInvariant
(
getShaderType
(
)
getShaderVersion
(
)
getOutputType
(
)
compileOptions
)
)
{
ASSERT
(
wereVariablesCollected
(
)
)
;
switch
(
getShaderType
(
)
)
{
case
GL_VERTEX_SHADER
:
sink
<
<
"
invariant
gl_Position
;
\
n
"
;
conditionallyOutputInvariantDeclaration
(
"
gl_PointSize
"
)
;
break
;
case
GL_FRAGMENT_SHADER
:
conditionallyOutputInvariantDeclaration
(
"
gl_FragCoord
"
)
;
conditionallyOutputInvariantDeclaration
(
"
gl_PointCoord
"
)
;
break
;
default
:
ASSERT
(
false
)
;
break
;
}
}
if
(
compileOptions
.
rewriteTexelFetchOffsetToTexelFetch
)
{
if
(
!
sh
:
:
RewriteTexelFetchOffset
(
this
root
getSymbolTable
(
)
getShaderVersion
(
)
)
)
{
return
false
;
}
}
if
(
compileOptions
.
rewriteFloatUnaryMinusOperator
)
{
if
(
!
sh
:
:
RewriteUnaryMinusOperatorFloat
(
this
root
)
)
{
return
false
;
}
}
if
(
compileOptions
.
rewriteRowMajorMatrices
&
&
getShaderVersion
(
)
>
=
300
)
{
if
(
!
RewriteRowMajorMatrices
(
this
root
&
getSymbolTable
(
)
)
)
{
return
false
;
}
}
if
(
!
getBuiltInFunctionEmulator
(
)
.
isOutputEmpty
(
)
)
{
sink
<
<
"
/
/
BEGIN
:
Generated
code
for
built
-
in
function
emulation
\
n
\
n
"
;
sink
<
<
"
#
define
emu_precision
\
n
\
n
"
;
getBuiltInFunctionEmulator
(
)
.
outputEmulatedFunctions
(
sink
)
;
sink
<
<
"
/
/
END
:
Generated
code
for
built
-
in
function
emulation
\
n
\
n
"
;
}
if
(
getShaderType
(
)
=
=
GL_FRAGMENT_SHADER
)
{
const
bool
mayHaveESSL1SecondaryOutputs
=
IsExtensionEnabled
(
getExtensionBehavior
(
)
TExtension
:
:
EXT_blend_func_extended
)
&
&
getShaderVersion
(
)
=
=
100
;
const
bool
declareGLFragmentOutputs
=
IsGLSL130OrNewer
(
getOutputType
(
)
)
;
bool
hasGLFragColor
=
false
;
bool
hasGLFragData
=
false
;
bool
hasGLSecondaryFragColor
=
false
;
bool
hasGLSecondaryFragData
=
false
;
for
(
const
auto
&
outputVar
:
mOutputVariables
)
{
if
(
declareGLFragmentOutputs
)
{
if
(
outputVar
.
name
=
=
"
gl_FragColor
"
)
{
ASSERT
(
!
hasGLFragColor
)
;
hasGLFragColor
=
true
;
continue
;
}
else
if
(
outputVar
.
name
=
=
"
gl_FragData
"
)
{
ASSERT
(
!
hasGLFragData
)
;
hasGLFragData
=
true
;
continue
;
}
}
if
(
mayHaveESSL1SecondaryOutputs
)
{
if
(
outputVar
.
name
=
=
"
gl_SecondaryFragColorEXT
"
)
{
ASSERT
(
!
hasGLSecondaryFragColor
)
;
hasGLSecondaryFragColor
=
true
;
continue
;
}
else
if
(
outputVar
.
name
=
=
"
gl_SecondaryFragDataEXT
"
)
{
ASSERT
(
!
hasGLSecondaryFragData
)
;
hasGLSecondaryFragData
=
true
;
continue
;
}
}
}
ASSERT
(
!
(
(
hasGLFragColor
|
|
hasGLSecondaryFragColor
)
&
&
(
hasGLFragData
|
|
hasGLSecondaryFragData
)
)
)
;
if
(
hasGLFragColor
)
{
sink
<
<
"
out
vec4
webgl_FragColor
;
\
n
"
;
}
if
(
hasGLFragData
)
{
sink
<
<
"
out
vec4
webgl_FragData
[
gl_MaxDrawBuffers
]
;
\
n
"
;
}
if
(
hasGLSecondaryFragColor
)
{
sink
<
<
"
out
vec4
webgl_SecondaryFragColor
;
\
n
"
;
}
if
(
hasGLSecondaryFragData
)
{
sink
<
<
"
out
vec4
webgl_SecondaryFragData
[
"
<
<
getResources
(
)
.
MaxDualSourceDrawBuffers
<
<
"
]
;
\
n
"
;
}
EmitEarlyFragmentTestsGLSL
(
*
this
sink
)
;
}
if
(
getShaderType
(
)
=
=
GL_COMPUTE_SHADER
)
{
EmitWorkGroupSizeGLSL
(
*
this
sink
)
;
}
if
(
getShaderType
(
)
=
=
GL_GEOMETRY_SHADER_EXT
)
{
WriteGeometryShaderLayoutQualifiers
(
sink
getGeometryShaderInputPrimitiveType
(
)
getGeometryShaderInvocations
(
)
getGeometryShaderOutputPrimitiveType
(
)
getGeometryShaderMaxVertices
(
)
)
;
}
TOutputGLSL
outputGLSL
(
this
sink
compileOptions
)
;
root
-
>
traverse
(
&
outputGLSL
)
;
return
true
;
}
bool
TranslatorGLSL
:
:
shouldFlattenPragmaStdglInvariantAll
(
)
{
return
IsGLSL130OrNewer
(
getOutputType
(
)
)
;
}
bool
TranslatorGLSL
:
:
shouldCollectVariables
(
const
ShCompileOptions
&
compileOptions
)
{
return
compileOptions
.
flattenPragmaSTDGLInvariantAll
|
|
TCompiler
:
:
shouldCollectVariables
(
compileOptions
)
;
}
void
TranslatorGLSL
:
:
writeVersion
(
TIntermNode
*
root
)
{
TVersionGLSL
versionGLSL
(
getShaderType
(
)
getPragma
(
)
getOutputType
(
)
)
;
root
-
>
traverse
(
&
versionGLSL
)
;
int
version
=
versionGLSL
.
getVersion
(
)
;
if
(
version
>
110
)
{
TInfoSinkBase
&
sink
=
getInfoSink
(
)
.
obj
;
sink
<
<
"
#
version
"
<
<
version
<
<
"
\
n
"
;
}
}
void
TranslatorGLSL
:
:
writeExtensionBehavior
(
TIntermNode
*
root
const
ShCompileOptions
&
compileOptions
)
{
bool
usesTextureCubeMapArray
=
false
;
bool
usesTextureBuffer
=
false
;
TInfoSinkBase
&
sink
=
getInfoSink
(
)
.
obj
;
const
TExtensionBehavior
&
extBehavior
=
getExtensionBehavior
(
)
;
for
(
const
auto
&
iter
:
extBehavior
)
{
if
(
iter
.
second
=
=
EBhUndefined
)
{
continue
;
}
if
(
getOutputType
(
)
=
=
SH_GLSL_COMPATIBILITY_OUTPUT
)
{
if
(
iter
.
first
=
=
TExtension
:
:
EXT_shader_texture_lod
)
{
sink
<
<
"
#
extension
GL_ARB_shader_texture_lod
:
"
<
<
GetBehaviorString
(
iter
.
second
)
<
<
"
\
n
"
;
}
if
(
iter
.
first
=
=
TExtension
:
:
EXT_draw_buffers
)
{
sink
<
<
"
#
extension
GL_ARB_draw_buffers
:
"
<
<
GetBehaviorString
(
iter
.
second
)
<
<
"
\
n
"
;
}
if
(
iter
.
first
=
=
TExtension
:
:
EXT_geometry_shader
|
|
iter
.
first
=
=
TExtension
:
:
OES_geometry_shader
)
{
sink
<
<
"
#
extension
GL_ARB_geometry_shader4
:
"
<
<
GetBehaviorString
(
iter
.
second
)
<
<
"
\
n
"
;
}
}
const
bool
isMultiview
=
(
iter
.
first
=
=
TExtension
:
:
OVR_multiview
)
|
|
(
iter
.
first
=
=
TExtension
:
:
OVR_multiview2
)
;
if
(
isMultiview
)
{
if
(
(
iter
.
first
!
=
TExtension
:
:
OVR_multiview
)
|
|
!
IsExtensionEnabled
(
extBehavior
TExtension
:
:
OVR_multiview2
)
)
{
EmitMultiviewGLSL
(
*
this
compileOptions
iter
.
first
iter
.
second
sink
)
;
}
}
if
(
getShaderVersion
(
)
>
=
300
&
&
iter
.
first
=
=
TExtension
:
:
ANGLE_texture_multisample
&
&
getOutputType
(
)
<
SH_GLSL_330_CORE_OUTPUT
)
{
sink
<
<
"
#
extension
GL_ARB_texture_multisample
:
"
<
<
GetBehaviorString
(
iter
.
second
)
<
<
"
\
n
"
;
}
if
(
(
iter
.
first
=
=
TExtension
:
:
OES_texture_cube_map_array
|
|
iter
.
first
=
=
TExtension
:
:
EXT_texture_cube_map_array
)
&
&
(
iter
.
second
=
=
EBhRequire
|
|
iter
.
second
=
=
EBhEnable
)
)
{
usesTextureCubeMapArray
=
true
;
}
if
(
(
iter
.
first
=
=
TExtension
:
:
OES_texture_buffer
|
|
iter
.
first
=
=
TExtension
:
:
EXT_texture_buffer
)
&
&
(
iter
.
second
=
=
EBhRequire
|
|
iter
.
second
=
=
EBhEnable
)
)
{
usesTextureBuffer
=
true
;
}
}
if
(
getShaderVersion
(
)
>
=
300
&
&
getOutputType
(
)
<
SH_GLSL_330_CORE_OUTPUT
&
&
getShaderType
(
)
!
=
GL_COMPUTE_SHADER
)
{
sink
<
<
"
#
extension
GL_ARB_explicit_attrib_location
:
require
\
n
"
;
}
if
(
getOutputType
(
)
!
=
SH_ESSL_OUTPUT
&
&
getOutputType
(
)
<
SH_GLSL_400_CORE_OUTPUT
&
&
getShaderVersion
(
)
=
=
100
)
{
sink
<
<
"
#
extension
GL_ARB_gpu_shader5
:
enable
\
n
"
;
sink
<
<
"
#
extension
GL_EXT_gpu_shader5
:
enable
\
n
"
;
}
if
(
usesTextureCubeMapArray
)
{
if
(
getOutputType
(
)
>
=
SH_GLSL_COMPATIBILITY_OUTPUT
&
&
getOutputType
(
)
<
SH_GLSL_400_CORE_OUTPUT
)
{
sink
<
<
"
#
extension
GL_ARB_texture_cube_map_array
:
enable
\
n
"
;
}
else
if
(
getOutputType
(
)
=
=
SH_ESSL_OUTPUT
&
&
getShaderVersion
(
)
<
320
)
{
sink
<
<
"
#
extension
GL_OES_texture_cube_map_array
:
enable
\
n
"
;
sink
<
<
"
#
extension
GL_EXT_texture_cube_map_array
:
enable
\
n
"
;
}
}
if
(
usesTextureBuffer
)
{
if
(
getOutputType
(
)
>
=
SH_GLSL_COMPATIBILITY_OUTPUT
&
&
getOutputType
(
)
<
SH_GLSL_400_CORE_OUTPUT
)
{
sink
<
<
"
#
extension
GL_ARB_texture_buffer_objects
:
enable
\
n
"
;
}
else
if
(
getOutputType
(
)
=
=
SH_ESSL_OUTPUT
&
&
getShaderVersion
(
)
<
320
)
{
sink
<
<
"
#
extension
GL_OES_texture_buffer
:
enable
\
n
"
;
sink
<
<
"
#
extension
GL_EXT_texture_buffer
:
enable
\
n
"
;
}
}
TExtensionGLSL
extensionGLSL
(
getOutputType
(
)
)
;
root
-
>
traverse
(
&
extensionGLSL
)
;
for
(
const
auto
&
ext
:
extensionGLSL
.
getEnabledExtensions
(
)
)
{
sink
<
<
"
#
extension
"
<
<
ext
<
<
"
:
enable
\
n
"
;
}
for
(
const
auto
&
ext
:
extensionGLSL
.
getRequiredExtensions
(
)
)
{
sink
<
<
"
#
extension
"
<
<
ext
<
<
"
:
require
\
n
"
;
}
}
void
TranslatorGLSL
:
:
conditionallyOutputInvariantDeclaration
(
const
char
*
builtinVaryingName
)
{
if
(
isVaryingDefined
(
builtinVaryingName
)
)
{
TInfoSinkBase
&
sink
=
getInfoSink
(
)
.
obj
;
sink
<
<
"
invariant
"
<
<
builtinVaryingName
<
<
"
;
\
n
"
;
}
}
}
