#
ifndef
COMPILER_TRANSLATOR_SYMBOLTABLE_H_
#
define
COMPILER_TRANSLATOR_SYMBOLTABLE_H_
#
include
<
memory
>
#
include
<
set
>
#
include
"
common
/
angleutils
.
h
"
#
include
"
compiler
/
translator
/
ExtensionBehavior
.
h
"
#
include
"
compiler
/
translator
/
ImmutableString
.
h
"
#
include
"
compiler
/
translator
/
InfoSink
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
#
include
"
compiler
/
translator
/
Symbol
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable_autogen
.
h
"
namespace
sh
{
typedef
int
ESymbolLevel
;
const
int
COMMON_BUILTINS
=
0
;
const
int
ESSL1_BUILTINS
=
1
;
const
int
ESSL3_BUILTINS
=
2
;
const
int
ESSL3_1_BUILTINS
=
3
;
const
int
GLSL_BUILTINS
=
4
;
const
int
LAST_BUILTIN_LEVEL
=
GLSL_BUILTINS
;
struct
UnmangledBuiltIn
{
constexpr
UnmangledBuiltIn
(
TExtension
extension
)
:
extension
(
extension
)
{
}
TExtension
extension
;
}
;
class
TSymbolTable
:
angle
:
:
NonCopyable
TSymbolTableBase
{
public
:
TSymbolTable
(
)
;
~
TSymbolTable
(
)
;
bool
isEmpty
(
)
const
;
bool
atGlobalLevel
(
)
const
;
void
push
(
)
;
void
pop
(
)
;
bool
declare
(
TSymbol
*
symbol
)
;
bool
declareInternal
(
TSymbol
*
symbol
)
;
void
declareUserDefinedFunction
(
TFunction
*
function
bool
insertUnmangledName
)
;
const
TFunction
*
markFunctionHasPrototypeDeclaration
(
const
ImmutableString
&
mangledName
bool
*
hadPrototypeDeclarationOut
)
const
;
const
TFunction
*
setFunctionParameterNamesFromDefinition
(
const
TFunction
*
function
bool
*
wasDefinedOut
)
const
;
bool
setGlInArraySize
(
unsigned
int
inputArraySize
)
;
TVariable
*
getGlInVariableWithArraySize
(
)
const
;
const
TVariable
*
gl_FragData
(
)
const
;
const
TVariable
*
gl_SecondaryFragDataEXT
(
)
const
;
void
markStaticRead
(
const
TVariable
&
variable
)
;
void
markStaticWrite
(
const
TVariable
&
variable
)
;
bool
isStaticallyUsed
(
const
TVariable
&
variable
)
const
;
const
TSymbol
*
find
(
const
ImmutableString
&
name
int
shaderVersion
)
const
;
const
TSymbol
*
findUserDefined
(
const
ImmutableString
&
name
)
const
;
TFunction
*
findUserDefinedFunction
(
const
ImmutableString
&
name
)
const
;
const
TSymbol
*
findGlobal
(
const
ImmutableString
&
name
)
const
;
const
TSymbol
*
findBuiltIn
(
const
ImmutableString
&
name
int
shaderVersion
)
const
;
void
setDefaultPrecision
(
TBasicType
type
TPrecision
prec
)
;
TPrecision
getDefaultPrecision
(
TBasicType
type
)
const
;
void
addInvariantVarying
(
const
TVariable
&
variable
)
;
bool
isVaryingInvariant
(
const
TVariable
&
variable
)
const
;
void
setGlobalInvariant
(
bool
invariant
)
;
const
TSymbolUniqueId
nextUniqueId
(
)
{
return
TSymbolUniqueId
(
this
)
;
}
const
UnmangledBuiltIn
*
getUnmangledBuiltInForShaderVersion
(
const
ImmutableString
&
name
int
shaderVersion
)
;
void
initializeBuiltIns
(
sh
:
:
GLenum
type
ShShaderSpec
spec
const
ShBuiltInResources
&
resources
)
;
void
clearCompilationResults
(
)
;
private
:
friend
class
TSymbolUniqueId
;
struct
VariableMetadata
{
VariableMetadata
(
)
;
bool
staticRead
;
bool
staticWrite
;
bool
invariant
;
}
;
int
nextUniqueIdValue
(
)
;
class
TSymbolTableLevel
;
void
initSamplerDefaultPrecision
(
TBasicType
samplerType
)
;
void
initializeBuiltInVariables
(
sh
:
:
GLenum
shaderType
ShShaderSpec
spec
const
ShBuiltInResources
&
resources
)
;
VariableMetadata
*
getOrCreateVariableMetadata
(
const
TVariable
&
variable
)
;
std
:
:
vector
<
std
:
:
unique_ptr
<
TSymbolTableLevel
>
>
mTable
;
typedef
TMap
<
TBasicType
TPrecision
>
PrecisionStackLevel
;
std
:
:
vector
<
std
:
:
unique_ptr
<
PrecisionStackLevel
>
>
mPrecisionStack
;
bool
mGlobalInvariant
;
int
mUniqueIdCounter
;
static
const
int
kLastBuiltInId
;
sh
:
:
GLenum
mShaderType
;
ShBuiltInResources
mResources
;
std
:
:
map
<
int
VariableMetadata
>
mVariableMetadata
;
TVariable
*
mGlInVariableWithArraySize
;
}
;
}
#
endif
