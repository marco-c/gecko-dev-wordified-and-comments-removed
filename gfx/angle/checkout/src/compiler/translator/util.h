#
ifndef
COMPILER_TRANSLATOR_UTIL_H_
#
define
COMPILER_TRANSLATOR_UTIL_H_
#
include
<
stack
>
#
include
<
GLSLANG
/
ShaderLang
.
h
>
#
include
"
angle_gl
.
h
"
#
include
"
compiler
/
translator
/
HashNames
.
h
"
#
include
"
compiler
/
translator
/
ImmutableString
.
h
"
#
include
"
compiler
/
translator
/
Operator
.
h
"
#
include
"
compiler
/
translator
/
Types
.
h
"
bool
atoi_clamp
(
const
char
*
str
unsigned
int
*
value
)
;
namespace
sh
{
enum
class
ImplicitTypeConversion
{
Same
Left
Right
Invalid
}
;
class
TIntermBlock
;
class
TSymbolTable
;
class
TIntermTyped
;
float
NumericLexFloat32OutOfRangeToInfinity
(
const
std
:
:
string
&
str
)
;
bool
strtof_clamp
(
const
std
:
:
string
&
str
float
*
value
)
;
GLenum
GLVariableType
(
const
TType
&
type
)
;
GLenum
GLVariablePrecision
(
const
TType
&
type
)
;
bool
IsVaryingIn
(
TQualifier
qualifier
)
;
bool
IsVaryingOut
(
TQualifier
qualifier
)
;
bool
IsVarying
(
TQualifier
qualifier
)
;
bool
IsGeometryShaderInput
(
GLenum
shaderType
TQualifier
qualifier
)
;
InterpolationType
GetInterpolationType
(
TQualifier
qualifier
)
;
ImmutableString
ArrayString
(
const
TType
&
type
)
;
ImmutableString
GetTypeName
(
const
TType
&
type
ShHashFunction64
hashFunction
NameMap
*
nameMap
)
;
TType
GetShaderVariableBasicType
(
const
sh
:
:
ShaderVariable
&
var
)
;
void
DeclareGlobalVariable
(
TIntermBlock
*
root
const
TVariable
*
variable
)
;
bool
IsBuiltinOutputVariable
(
TQualifier
qualifier
)
;
bool
IsBuiltinFragmentInputVariable
(
TQualifier
qualifier
)
;
bool
CanBeInvariantESSL1
(
TQualifier
qualifier
)
;
bool
CanBeInvariantESSL3OrGreater
(
TQualifier
qualifier
)
;
bool
IsShaderOutput
(
TQualifier
qualifier
)
;
bool
IsOutputESSL
(
ShShaderOutput
output
)
;
bool
IsOutputGLSL
(
ShShaderOutput
output
)
;
bool
IsOutputHLSL
(
ShShaderOutput
output
)
;
bool
IsOutputVulkan
(
ShShaderOutput
output
)
;
bool
IsInShaderStorageBlock
(
TIntermTyped
*
node
)
;
GLenum
GetImageInternalFormatType
(
TLayoutImageInternalFormat
iifq
)
;
bool
IsSpecWithFunctionBodyNewScope
(
ShShaderSpec
shaderSpec
int
shaderVersion
)
;
ImplicitTypeConversion
GetConversion
(
TBasicType
t1
TBasicType
t2
)
;
bool
IsValidImplicitConversion
(
ImplicitTypeConversion
conversion
TOperator
op
)
;
}
#
endif
