#
include
"
compiler
/
translator
/
TranslatorHLSL
.
h
"
#
include
"
compiler
/
translator
/
OutputHLSL
.
h
"
#
include
"
compiler
/
translator
/
tree_ops
/
RemoveDynamicIndexing
.
h
"
#
include
"
compiler
/
translator
/
tree_ops
/
RewriteTexelFetchOffset
.
h
"
#
include
"
compiler
/
translator
/
tree_ops
/
SimplifyLoopConditions
.
h
"
#
include
"
compiler
/
translator
/
tree_ops
/
SplitSequenceOperator
.
h
"
#
include
"
compiler
/
translator
/
tree_ops
/
d3d
/
AddDefaultReturnStatements
.
h
"
#
include
"
compiler
/
translator
/
tree_ops
/
d3d
/
ArrayReturnValueToOutParameter
.
h
"
#
include
"
compiler
/
translator
/
tree_ops
/
d3d
/
BreakVariableAliasingInInnerLoops
.
h
"
#
include
"
compiler
/
translator
/
tree_ops
/
d3d
/
ExpandIntegerPowExpressions
.
h
"
#
include
"
compiler
/
translator
/
tree_ops
/
d3d
/
RecordUniformBlocksWithLargeArrayMember
.
h
"
#
include
"
compiler
/
translator
/
tree_ops
/
d3d
/
RewriteAtomicFunctionExpressions
.
h
"
#
include
"
compiler
/
translator
/
tree_ops
/
d3d
/
RewriteElseBlocks
.
h
"
#
include
"
compiler
/
translator
/
tree_ops
/
d3d
/
RewriteExpressionsWithShaderStorageBlock
.
h
"
#
include
"
compiler
/
translator
/
tree_ops
/
d3d
/
RewriteUnaryMinusOperatorInt
.
h
"
#
include
"
compiler
/
translator
/
tree_ops
/
d3d
/
SeparateArrayConstructorStatements
.
h
"
#
include
"
compiler
/
translator
/
tree_ops
/
d3d
/
SeparateArrayInitialization
.
h
"
#
include
"
compiler
/
translator
/
tree_ops
/
d3d
/
SeparateExpressionsReturningArrays
.
h
"
#
include
"
compiler
/
translator
/
tree_ops
/
d3d
/
UnfoldShortCircuitToIf
.
h
"
#
include
"
compiler
/
translator
/
tree_ops
/
d3d
/
WrapSwitchStatementsInBlocks
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNodePatternMatcher
.
h
"
namespace
sh
{
TranslatorHLSL
:
:
TranslatorHLSL
(
sh
:
:
GLenum
type
ShShaderSpec
spec
ShShaderOutput
output
)
:
TCompiler
(
type
spec
output
)
{
}
bool
TranslatorHLSL
:
:
translate
(
TIntermBlock
*
root
ShCompileOptions
compileOptions
PerformanceDiagnostics
*
perfDiagnostics
)
{
const
ShBuiltInResources
&
resources
=
getResources
(
)
;
int
numRenderTargets
=
resources
.
EXT_draw_buffers
?
resources
.
MaxDrawBuffers
:
1
;
int
maxDualSourceDrawBuffers
=
resources
.
EXT_blend_func_extended
?
resources
.
MaxDualSourceDrawBuffers
:
0
;
if
(
!
sh
:
:
AddDefaultReturnStatements
(
this
root
)
)
{
return
false
;
}
if
(
!
SimplifyLoopConditions
(
this
root
IntermNodePatternMatcher
:
:
kExpressionReturningArray
|
IntermNodePatternMatcher
:
:
kUnfoldedShortCircuitExpression
|
IntermNodePatternMatcher
:
:
kDynamicIndexingOfVectorOrMatrixInLValue
&
getSymbolTable
(
)
)
)
{
return
false
;
}
if
(
!
SplitSequenceOperator
(
this
root
IntermNodePatternMatcher
:
:
kExpressionReturningArray
|
IntermNodePatternMatcher
:
:
kUnfoldedShortCircuitExpression
|
IntermNodePatternMatcher
:
:
kDynamicIndexingOfVectorOrMatrixInLValue
&
getSymbolTable
(
)
)
)
{
return
false
;
}
if
(
!
UnfoldShortCircuitToIf
(
this
root
&
getSymbolTable
(
)
)
)
{
return
false
;
}
if
(
!
SeparateArrayConstructorStatements
(
this
root
)
)
{
return
false
;
}
if
(
!
SeparateExpressionsReturningArrays
(
this
root
&
getSymbolTable
(
)
)
)
{
return
false
;
}
if
(
!
SeparateArrayInitialization
(
this
root
)
)
{
return
false
;
}
if
(
!
ArrayReturnValueToOutParameter
(
this
root
&
getSymbolTable
(
)
)
)
{
return
false
;
}
if
(
!
shouldRunLoopAndIndexingValidation
(
compileOptions
)
)
{
if
(
!
RemoveDynamicIndexingOfNonSSBOVectorOrMatrix
(
this
root
&
getSymbolTable
(
)
perfDiagnostics
)
)
{
return
false
;
}
}
if
(
getOutputType
(
)
=
=
SH_HLSL_3_0_OUTPUT
&
&
getShaderType
(
)
=
=
GL_VERTEX_SHADER
)
{
if
(
!
sh
:
:
RewriteElseBlocks
(
this
root
&
getSymbolTable
(
)
)
)
{
return
false
;
}
}
if
(
!
sh
:
:
BreakVariableAliasingInInnerLoops
(
this
root
)
)
{
return
false
;
}
if
(
!
WrapSwitchStatementsInBlocks
(
this
root
)
)
{
return
false
;
}
bool
precisionEmulation
=
false
;
if
(
!
emulatePrecisionIfNeeded
(
root
getInfoSink
(
)
.
obj
&
precisionEmulation
getOutputType
(
)
)
)
return
false
;
if
(
(
compileOptions
&
SH_EXPAND_SELECT_HLSL_INTEGER_POW_EXPRESSIONS
)
!
=
0
)
{
if
(
!
sh
:
:
ExpandIntegerPowExpressions
(
this
root
&
getSymbolTable
(
)
)
)
{
return
false
;
}
}
if
(
(
compileOptions
&
SH_REWRITE_TEXELFETCHOFFSET_TO_TEXELFETCH
)
!
=
0
)
{
if
(
!
sh
:
:
RewriteTexelFetchOffset
(
this
root
getSymbolTable
(
)
getShaderVersion
(
)
)
)
{
return
false
;
}
}
if
(
(
(
compileOptions
&
SH_REWRITE_INTEGER_UNARY_MINUS_OPERATOR
)
!
=
0
)
&
&
getShaderType
(
)
=
=
GL_VERTEX_SHADER
)
{
if
(
!
sh
:
:
RewriteUnaryMinusOperatorInt
(
this
root
)
)
{
return
false
;
}
}
if
(
getShaderVersion
(
)
>
=
310
)
{
if
(
!
sh
:
:
RewriteExpressionsWithShaderStorageBlock
(
this
root
&
getSymbolTable
(
)
)
)
{
return
false
;
}
if
(
!
sh
:
:
RewriteAtomicFunctionExpressions
(
this
root
&
getSymbolTable
(
)
getShaderVersion
(
)
)
)
{
return
false
;
}
}
mUniformBlockOptimizedMap
.
clear
(
)
;
mSlowCompilingUniformBlockSet
.
clear
(
)
;
if
(
getShaderVersion
(
)
=
=
300
&
&
(
compileOptions
&
SH_ALLOW_TRANSLATE_UNIFORM_BLOCK_TO_STRUCTUREDBUFFER
)
!
=
0
)
{
if
(
!
sh
:
:
RecordUniformBlocksWithLargeArrayMember
(
root
mUniformBlockOptimizedMap
mSlowCompilingUniformBlockSet
)
)
{
return
false
;
}
}
sh
:
:
OutputHLSL
outputHLSL
(
getShaderType
(
)
getShaderSpec
(
)
getShaderVersion
(
)
getExtensionBehavior
(
)
getSourcePath
(
)
getOutputType
(
)
numRenderTargets
maxDualSourceDrawBuffers
getUniforms
(
)
compileOptions
getComputeShaderLocalSize
(
)
&
getSymbolTable
(
)
perfDiagnostics
mUniformBlockOptimizedMap
mShaderStorageBlocks
)
;
outputHLSL
.
output
(
root
getInfoSink
(
)
.
obj
)
;
mShaderStorageBlockRegisterMap
=
outputHLSL
.
getShaderStorageBlockRegisterMap
(
)
;
mUniformBlockRegisterMap
=
outputHLSL
.
getUniformBlockRegisterMap
(
)
;
mUniformBlockUseStructuredBufferMap
=
outputHLSL
.
getUniformBlockUseStructuredBufferMap
(
)
;
mUniformRegisterMap
=
outputHLSL
.
getUniformRegisterMap
(
)
;
mReadonlyImage2DRegisterIndex
=
outputHLSL
.
getReadonlyImage2DRegisterIndex
(
)
;
mImage2DRegisterIndex
=
outputHLSL
.
getImage2DRegisterIndex
(
)
;
mUsedImage2DFunctionNames
=
outputHLSL
.
getUsedImage2DFunctionNames
(
)
;
return
true
;
}
bool
TranslatorHLSL
:
:
shouldFlattenPragmaStdglInvariantAll
(
)
{
return
false
;
}
bool
TranslatorHLSL
:
:
hasShaderStorageBlock
(
const
std
:
:
string
&
uniformBlockName
)
const
{
return
(
mShaderStorageBlockRegisterMap
.
count
(
uniformBlockName
)
>
0
)
;
}
unsigned
int
TranslatorHLSL
:
:
getShaderStorageBlockRegister
(
const
std
:
:
string
&
shaderStorageBlockName
)
const
{
ASSERT
(
hasShaderStorageBlock
(
shaderStorageBlockName
)
)
;
return
mShaderStorageBlockRegisterMap
.
find
(
shaderStorageBlockName
)
-
>
second
;
}
bool
TranslatorHLSL
:
:
hasUniformBlock
(
const
std
:
:
string
&
uniformBlockName
)
const
{
return
(
mUniformBlockRegisterMap
.
count
(
uniformBlockName
)
>
0
)
;
}
unsigned
int
TranslatorHLSL
:
:
getUniformBlockRegister
(
const
std
:
:
string
&
uniformBlockName
)
const
{
ASSERT
(
hasUniformBlock
(
uniformBlockName
)
)
;
return
mUniformBlockRegisterMap
.
find
(
uniformBlockName
)
-
>
second
;
}
const
std
:
:
map
<
std
:
:
string
unsigned
int
>
*
TranslatorHLSL
:
:
getUniformRegisterMap
(
)
const
{
return
&
mUniformRegisterMap
;
}
const
std
:
:
set
<
std
:
:
string
>
*
TranslatorHLSL
:
:
getSlowCompilingUniformBlockSet
(
)
const
{
return
&
mSlowCompilingUniformBlockSet
;
}
unsigned
int
TranslatorHLSL
:
:
getReadonlyImage2DRegisterIndex
(
)
const
{
return
mReadonlyImage2DRegisterIndex
;
}
unsigned
int
TranslatorHLSL
:
:
getImage2DRegisterIndex
(
)
const
{
return
mImage2DRegisterIndex
;
}
const
std
:
:
set
<
std
:
:
string
>
*
TranslatorHLSL
:
:
getUsedImage2DFunctionNames
(
)
const
{
return
&
mUsedImage2DFunctionNames
;
}
bool
TranslatorHLSL
:
:
shouldUniformBlockUseStructuredBuffer
(
const
std
:
:
string
&
uniformBlockName
)
const
{
auto
uniformBlockIter
=
mUniformBlockUseStructuredBufferMap
.
find
(
uniformBlockName
)
;
return
uniformBlockIter
!
=
mUniformBlockUseStructuredBufferMap
.
end
(
)
&
&
uniformBlockIter
-
>
second
;
}
}
