#
include
"
compiler
/
translator
/
TranslatorHLSL
.
h
"
#
include
"
compiler
/
translator
/
AddDefaultReturnStatements
.
h
"
#
include
"
compiler
/
translator
/
ArrayReturnValueToOutParameter
.
h
"
#
include
"
compiler
/
translator
/
BreakVariableAliasingInInnerLoops
.
h
"
#
include
"
compiler
/
translator
/
EmulatePrecision
.
h
"
#
include
"
compiler
/
translator
/
ExpandIntegerPowExpressions
.
h
"
#
include
"
compiler
/
translator
/
IntermNodePatternMatcher
.
h
"
#
include
"
compiler
/
translator
/
OutputHLSL
.
h
"
#
include
"
compiler
/
translator
/
RemoveDynamicIndexing
.
h
"
#
include
"
compiler
/
translator
/
RemoveNoOpCasesFromEndOfSwitchStatements
.
h
"
#
include
"
compiler
/
translator
/
RewriteElseBlocks
.
h
"
#
include
"
compiler
/
translator
/
RewriteTexelFetchOffset
.
h
"
#
include
"
compiler
/
translator
/
RewriteUnaryMinusOperatorInt
.
h
"
#
include
"
compiler
/
translator
/
SeparateArrayConstructorStatements
.
h
"
#
include
"
compiler
/
translator
/
SeparateArrayInitialization
.
h
"
#
include
"
compiler
/
translator
/
SeparateDeclarations
.
h
"
#
include
"
compiler
/
translator
/
SeparateExpressionsReturningArrays
.
h
"
#
include
"
compiler
/
translator
/
SimplifyLoopConditions
.
h
"
#
include
"
compiler
/
translator
/
SplitSequenceOperator
.
h
"
#
include
"
compiler
/
translator
/
UnfoldShortCircuitToIf
.
h
"
#
include
"
compiler
/
translator
/
WrapSwitchStatementsInBlocks
.
h
"
namespace
sh
{
TranslatorHLSL
:
:
TranslatorHLSL
(
sh
:
:
GLenum
type
ShShaderSpec
spec
ShShaderOutput
output
)
:
TCompiler
(
type
spec
output
)
{
}
void
TranslatorHLSL
:
:
translate
(
TIntermBlock
*
root
ShCompileOptions
compileOptions
PerformanceDiagnostics
*
perfDiagnostics
)
{
const
ShBuiltInResources
&
resources
=
getResources
(
)
;
int
numRenderTargets
=
resources
.
EXT_draw_buffers
?
resources
.
MaxDrawBuffers
:
1
;
sh
:
:
AddDefaultReturnStatements
(
root
)
;
SimplifyLoopConditions
(
root
IntermNodePatternMatcher
:
:
kExpressionReturningArray
|
IntermNodePatternMatcher
:
:
kUnfoldedShortCircuitExpression
|
IntermNodePatternMatcher
:
:
kDynamicIndexingOfVectorOrMatrixInLValue
&
getSymbolTable
(
)
)
;
SplitSequenceOperator
(
root
IntermNodePatternMatcher
:
:
kExpressionReturningArray
|
IntermNodePatternMatcher
:
:
kUnfoldedShortCircuitExpression
|
IntermNodePatternMatcher
:
:
kDynamicIndexingOfVectorOrMatrixInLValue
&
getSymbolTable
(
)
)
;
UnfoldShortCircuitToIf
(
root
&
getSymbolTable
(
)
)
;
SeparateArrayConstructorStatements
(
root
)
;
SeparateExpressionsReturningArrays
(
root
&
getSymbolTable
(
)
)
;
SeparateArrayInitialization
(
root
)
;
ArrayReturnValueToOutParameter
(
root
&
getSymbolTable
(
)
)
;
if
(
!
shouldRunLoopAndIndexingValidation
(
compileOptions
)
)
{
RemoveDynamicIndexing
(
root
&
getSymbolTable
(
)
perfDiagnostics
)
;
}
if
(
getOutputType
(
)
=
=
SH_HLSL_3_0_OUTPUT
&
&
getShaderType
(
)
=
=
GL_VERTEX_SHADER
)
{
sh
:
:
RewriteElseBlocks
(
root
&
getSymbolTable
(
)
)
;
}
sh
:
:
BreakVariableAliasingInInnerLoops
(
root
)
;
if
(
WrapSwitchStatementsInBlocks
(
root
)
)
{
RemoveNoOpCasesFromEndOfSwitchStatements
(
root
&
getSymbolTable
(
)
)
;
}
bool
precisionEmulation
=
getResources
(
)
.
WEBGL_debug_shader_precision
&
&
getPragma
(
)
.
debugShaderPrecision
;
if
(
precisionEmulation
)
{
EmulatePrecision
emulatePrecision
(
&
getSymbolTable
(
)
)
;
root
-
>
traverse
(
&
emulatePrecision
)
;
emulatePrecision
.
updateTree
(
)
;
emulatePrecision
.
writeEmulationHelpers
(
getInfoSink
(
)
.
obj
getShaderVersion
(
)
getOutputType
(
)
)
;
}
if
(
(
compileOptions
&
SH_EXPAND_SELECT_HLSL_INTEGER_POW_EXPRESSIONS
)
!
=
0
)
{
sh
:
:
ExpandIntegerPowExpressions
(
root
&
getSymbolTable
(
)
)
;
}
if
(
(
compileOptions
&
SH_REWRITE_TEXELFETCHOFFSET_TO_TEXELFETCH
)
!
=
0
)
{
sh
:
:
RewriteTexelFetchOffset
(
root
getSymbolTable
(
)
getShaderVersion
(
)
)
;
}
if
(
(
(
compileOptions
&
SH_REWRITE_INTEGER_UNARY_MINUS_OPERATOR
)
!
=
0
)
&
&
getShaderType
(
)
=
=
GL_VERTEX_SHADER
)
{
sh
:
:
RewriteUnaryMinusOperatorInt
(
root
)
;
}
sh
:
:
OutputHLSL
outputHLSL
(
getShaderType
(
)
getShaderVersion
(
)
getExtensionBehavior
(
)
getSourcePath
(
)
getOutputType
(
)
numRenderTargets
getUniforms
(
)
compileOptions
&
getSymbolTable
(
)
perfDiagnostics
)
;
outputHLSL
.
output
(
root
getInfoSink
(
)
.
obj
)
;
mUniformBlockRegisterMap
=
outputHLSL
.
getUniformBlockRegisterMap
(
)
;
mUniformRegisterMap
=
outputHLSL
.
getUniformRegisterMap
(
)
;
}
bool
TranslatorHLSL
:
:
shouldFlattenPragmaStdglInvariantAll
(
)
{
return
false
;
}
bool
TranslatorHLSL
:
:
hasUniformBlock
(
const
std
:
:
string
&
uniformBlockName
)
const
{
return
(
mUniformBlockRegisterMap
.
count
(
uniformBlockName
)
>
0
)
;
}
unsigned
int
TranslatorHLSL
:
:
getUniformBlockRegister
(
const
std
:
:
string
&
uniformBlockName
)
const
{
ASSERT
(
hasUniformBlock
(
uniformBlockName
)
)
;
return
mUniformBlockRegisterMap
.
find
(
uniformBlockName
)
-
>
second
;
}
const
std
:
:
map
<
std
:
:
string
unsigned
int
>
*
TranslatorHLSL
:
:
getUniformRegisterMap
(
)
const
{
return
&
mUniformRegisterMap
;
}
}
