#
include
"
compiler
/
translator
/
AtomicCounterFunctionHLSL
.
h
"
#
include
"
compiler
/
translator
/
Common
.
h
"
#
include
"
compiler
/
translator
/
ImmutableStringBuilder
.
h
"
#
include
"
compiler
/
translator
/
InfoSink
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
namespace
sh
{
namespace
{
constexpr
ImmutableString
kAtomicCounter
(
"
atomicCounter
"
)
;
constexpr
ImmutableString
kAtomicCounterIncrement
(
"
atomicCounterIncrement
"
)
;
constexpr
ImmutableString
kAtomicCounterDecrement
(
"
atomicCounterDecrement
"
)
;
constexpr
ImmutableString
kAtomicCounterBaseName
(
"
_acbase_
"
)
;
}
AtomicCounterFunctionHLSL
:
:
AtomicCounterFunctionHLSL
(
bool
forceResolution
)
:
mForceResolution
(
forceResolution
)
{
}
ImmutableString
AtomicCounterFunctionHLSL
:
:
useAtomicCounterFunction
(
const
ImmutableString
&
name
)
{
ImmutableStringBuilder
hlslFunctionNameSB
(
kAtomicCounterBaseName
.
length
(
)
+
strlen
(
"
increment
"
)
)
;
hlslFunctionNameSB
<
<
kAtomicCounterBaseName
;
AtomicCounterFunction
atomicMethod
;
if
(
kAtomicCounter
=
=
name
)
{
atomicMethod
=
AtomicCounterFunction
:
:
LOAD
;
hlslFunctionNameSB
<
<
"
load
"
;
}
else
if
(
kAtomicCounterIncrement
=
=
name
)
{
atomicMethod
=
AtomicCounterFunction
:
:
INCREMENT
;
hlslFunctionNameSB
<
<
"
increment
"
;
}
else
if
(
kAtomicCounterDecrement
=
=
name
)
{
atomicMethod
=
AtomicCounterFunction
:
:
DECREMENT
;
hlslFunctionNameSB
<
<
"
decrement
"
;
}
else
{
atomicMethod
=
AtomicCounterFunction
:
:
INVALID
;
UNREACHABLE
(
)
;
}
ImmutableString
hlslFunctionName
(
hlslFunctionNameSB
)
;
mAtomicCounterFunctions
[
hlslFunctionName
]
=
atomicMethod
;
return
hlslFunctionName
;
}
void
AtomicCounterFunctionHLSL
:
:
atomicCounterFunctionHeader
(
TInfoSinkBase
&
out
)
{
for
(
auto
&
atomicFunction
:
mAtomicCounterFunctions
)
{
out
<
<
"
uint
"
<
<
atomicFunction
.
first
<
<
"
(
in
RWByteAddressBuffer
counter
int
address
)
\
n
"
"
{
\
n
"
"
uint
ret
;
\
n
"
;
switch
(
atomicFunction
.
second
)
{
case
AtomicCounterFunction
:
:
INCREMENT
:
out
<
<
"
counter
.
InterlockedAdd
(
address
1u
ret
)
;
\
n
"
;
break
;
case
AtomicCounterFunction
:
:
DECREMENT
:
out
<
<
"
counter
.
InterlockedAdd
(
address
0u
-
1u
ret
)
;
\
n
"
"
ret
-
=
1u
;
\
n
"
;
break
;
case
AtomicCounterFunction
:
:
LOAD
:
out
<
<
"
ret
=
counter
.
Load
(
address
)
;
\
n
"
;
break
;
default
:
UNREACHABLE
(
)
;
break
;
}
if
(
mForceResolution
&
&
atomicFunction
.
second
!
=
AtomicCounterFunction
:
:
LOAD
)
{
out
<
<
"
if
(
ret
=
=
0
)
{
\
n
"
"
ret
=
0
-
ret
;
\
n
"
"
}
\
n
"
;
}
out
<
<
"
return
ret
;
\
n
"
"
}
\
n
\
n
"
;
}
}
ImmutableString
getAtomicCounterNameForBinding
(
int
binding
)
{
std
:
:
stringstream
counterName
=
sh
:
:
InitializeStream
<
std
:
:
stringstream
>
(
)
;
counterName
<
<
kAtomicCounterBaseName
<
<
binding
;
return
ImmutableString
(
counterName
.
str
(
)
)
;
}
}
