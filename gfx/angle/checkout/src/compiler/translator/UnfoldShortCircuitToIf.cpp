#
include
"
compiler
/
translator
/
UnfoldShortCircuitToIf
.
h
"
#
include
"
compiler
/
translator
/
IntermNodePatternMatcher
.
h
"
#
include
"
compiler
/
translator
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
IntermTraverse
.
h
"
#
include
"
compiler
/
translator
/
StaticType
.
h
"
namespace
sh
{
namespace
{
class
UnfoldShortCircuitTraverser
:
public
TIntermTraverser
{
public
:
UnfoldShortCircuitTraverser
(
TSymbolTable
*
symbolTable
)
;
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
;
bool
visitTernary
(
Visit
visit
TIntermTernary
*
node
)
override
;
void
nextIteration
(
)
;
bool
foundShortCircuit
(
)
const
{
return
mFoundShortCircuit
;
}
protected
:
bool
mFoundShortCircuit
;
IntermNodePatternMatcher
mPatternToUnfoldMatcher
;
}
;
UnfoldShortCircuitTraverser
:
:
UnfoldShortCircuitTraverser
(
TSymbolTable
*
symbolTable
)
:
TIntermTraverser
(
true
false
true
symbolTable
)
mFoundShortCircuit
(
false
)
mPatternToUnfoldMatcher
(
IntermNodePatternMatcher
:
:
kUnfoldedShortCircuitExpression
)
{
}
bool
UnfoldShortCircuitTraverser
:
:
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
{
if
(
mFoundShortCircuit
)
return
false
;
if
(
visit
!
=
PreVisit
)
return
true
;
if
(
!
mPatternToUnfoldMatcher
.
match
(
node
getParentNode
(
)
)
)
return
true
;
ASSERT
(
node
-
>
getRight
(
)
-
>
hasSideEffects
(
)
)
;
mFoundShortCircuit
=
true
;
switch
(
node
-
>
getOp
(
)
)
{
case
EOpLogicalOr
:
{
TIntermSequence
insertions
;
const
TType
*
boolType
=
StaticType
:
:
Get
<
EbtBool
EbpUndefined
EvqTemporary
1
1
>
(
)
;
TVariable
*
resultVariable
=
CreateTempVariable
(
mSymbolTable
boolType
)
;
ASSERT
(
node
-
>
getLeft
(
)
-
>
getType
(
)
=
=
*
boolType
)
;
insertions
.
push_back
(
CreateTempInitDeclarationNode
(
resultVariable
node
-
>
getLeft
(
)
)
)
;
TIntermBlock
*
assignRightBlock
=
new
TIntermBlock
(
)
;
ASSERT
(
node
-
>
getRight
(
)
-
>
getType
(
)
=
=
*
boolType
)
;
assignRightBlock
-
>
getSequence
(
)
-
>
push_back
(
CreateTempAssignmentNode
(
resultVariable
node
-
>
getRight
(
)
)
)
;
TIntermUnary
*
notTempSymbol
=
new
TIntermUnary
(
EOpLogicalNot
CreateTempSymbolNode
(
resultVariable
)
)
;
TIntermIfElse
*
ifNode
=
new
TIntermIfElse
(
notTempSymbol
assignRightBlock
nullptr
)
;
insertions
.
push_back
(
ifNode
)
;
insertStatementsInParentBlock
(
insertions
)
;
queueReplacement
(
CreateTempSymbolNode
(
resultVariable
)
OriginalNode
:
:
IS_DROPPED
)
;
return
false
;
}
case
EOpLogicalAnd
:
{
TIntermSequence
insertions
;
const
TType
*
boolType
=
StaticType
:
:
Get
<
EbtBool
EbpUndefined
EvqTemporary
1
1
>
(
)
;
TVariable
*
resultVariable
=
CreateTempVariable
(
mSymbolTable
boolType
)
;
ASSERT
(
node
-
>
getLeft
(
)
-
>
getType
(
)
=
=
*
boolType
)
;
insertions
.
push_back
(
CreateTempInitDeclarationNode
(
resultVariable
node
-
>
getLeft
(
)
)
)
;
TIntermBlock
*
assignRightBlock
=
new
TIntermBlock
(
)
;
ASSERT
(
node
-
>
getRight
(
)
-
>
getType
(
)
=
=
*
boolType
)
;
assignRightBlock
-
>
getSequence
(
)
-
>
push_back
(
CreateTempAssignmentNode
(
resultVariable
node
-
>
getRight
(
)
)
)
;
TIntermIfElse
*
ifNode
=
new
TIntermIfElse
(
CreateTempSymbolNode
(
resultVariable
)
assignRightBlock
nullptr
)
;
insertions
.
push_back
(
ifNode
)
;
insertStatementsInParentBlock
(
insertions
)
;
queueReplacement
(
CreateTempSymbolNode
(
resultVariable
)
OriginalNode
:
:
IS_DROPPED
)
;
return
false
;
}
default
:
UNREACHABLE
(
)
;
return
true
;
}
}
bool
UnfoldShortCircuitTraverser
:
:
visitTernary
(
Visit
visit
TIntermTernary
*
node
)
{
if
(
mFoundShortCircuit
)
return
false
;
if
(
visit
!
=
PreVisit
)
return
true
;
if
(
!
mPatternToUnfoldMatcher
.
match
(
node
)
)
return
true
;
mFoundShortCircuit
=
true
;
TIntermSequence
insertions
;
TIntermDeclaration
*
tempDeclaration
=
nullptr
;
TVariable
*
resultVariable
=
DeclareTempVariable
(
mSymbolTable
new
TType
(
node
-
>
getType
(
)
)
EvqTemporary
&
tempDeclaration
)
;
insertions
.
push_back
(
tempDeclaration
)
;
TIntermBlock
*
trueBlock
=
new
TIntermBlock
(
)
;
TIntermBinary
*
trueAssignment
=
CreateTempAssignmentNode
(
resultVariable
node
-
>
getTrueExpression
(
)
)
;
trueBlock
-
>
getSequence
(
)
-
>
push_back
(
trueAssignment
)
;
TIntermBlock
*
falseBlock
=
new
TIntermBlock
(
)
;
TIntermBinary
*
falseAssignment
=
CreateTempAssignmentNode
(
resultVariable
node
-
>
getFalseExpression
(
)
)
;
falseBlock
-
>
getSequence
(
)
-
>
push_back
(
falseAssignment
)
;
TIntermIfElse
*
ifNode
=
new
TIntermIfElse
(
node
-
>
getCondition
(
)
-
>
getAsTyped
(
)
trueBlock
falseBlock
)
;
insertions
.
push_back
(
ifNode
)
;
insertStatementsInParentBlock
(
insertions
)
;
TIntermSymbol
*
ternaryResult
=
CreateTempSymbolNode
(
resultVariable
)
;
queueReplacement
(
ternaryResult
OriginalNode
:
:
IS_DROPPED
)
;
return
false
;
}
void
UnfoldShortCircuitTraverser
:
:
nextIteration
(
)
{
mFoundShortCircuit
=
false
;
}
}
void
UnfoldShortCircuitToIf
(
TIntermNode
*
root
TSymbolTable
*
symbolTable
)
{
UnfoldShortCircuitTraverser
traverser
(
symbolTable
)
;
do
{
traverser
.
nextIteration
(
)
;
root
-
>
traverse
(
&
traverser
)
;
if
(
traverser
.
foundShortCircuit
(
)
)
traverser
.
updateTree
(
)
;
}
while
(
traverser
.
foundShortCircuit
(
)
)
;
}
}
