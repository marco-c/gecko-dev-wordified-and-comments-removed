#
ifndef
COMPILER_TRANSLATOR_STATIC_TYPE_H_
#
define
COMPILER_TRANSLATOR_STATIC_TYPE_H_
#
include
"
compiler
/
translator
/
Types
.
h
"
namespace
sh
{
namespace
StaticType
{
namespace
Helpers
{
static
constexpr
size_t
kStaticMangledNameLength
=
TBasicMangledName
:
:
mangledNameSize
+
1
;
struct
StaticMangledName
{
char
name
[
kStaticMangledNameLength
+
1
]
=
{
}
;
}
;
constexpr
StaticMangledName
BuildStaticMangledName
(
TBasicType
basicType
TPrecision
precision
TQualifier
qualifier
unsigned
char
primarySize
unsigned
char
secondarySize
)
{
StaticMangledName
name
=
{
}
;
name
.
name
[
0
]
=
TType
:
:
GetSizeMangledName
(
primarySize
secondarySize
)
;
TBasicMangledName
typeName
(
basicType
)
;
char
*
mangledName
=
typeName
.
getName
(
)
;
static_assert
(
TBasicMangledName
:
:
mangledNameSize
=
=
2
"
Mangled
name
size
is
not
2
"
)
;
name
.
name
[
1
]
=
mangledName
[
0
]
;
name
.
name
[
2
]
=
mangledName
[
1
]
;
name
.
name
[
3
]
=
'
\
0
'
;
return
name
;
}
static
constexpr
size_t
kStaticArrayMangledNameLength
=
kStaticMangledNameLength
+
2
;
struct
StaticArrayMangledName
{
char
name
[
kStaticArrayMangledNameLength
+
1
]
=
{
}
;
}
;
constexpr
StaticArrayMangledName
BuildStaticArrayMangledName
(
TBasicType
basicType
TPrecision
precision
TQualifier
qualifier
unsigned
char
primarySize
unsigned
char
secondarySize
const
unsigned
int
*
arraySizes
size_t
numArraySizes
)
{
StaticMangledName
nonArrayName
=
BuildStaticMangledName
(
basicType
precision
qualifier
primarySize
secondarySize
)
;
StaticArrayMangledName
arrayName
=
{
}
;
static_assert
(
kStaticMangledNameLength
=
=
3
"
Static
mangled
name
size
is
not
3
"
)
;
arrayName
.
name
[
0
]
=
nonArrayName
.
name
[
0
]
;
arrayName
.
name
[
1
]
=
nonArrayName
.
name
[
1
]
;
arrayName
.
name
[
2
]
=
nonArrayName
.
name
[
2
]
;
arrayName
.
name
[
3
]
=
'
x
'
;
arrayName
.
name
[
4
]
=
static_cast
<
char
>
(
'
0
'
+
arraySizes
[
0
]
)
;
arrayName
.
name
[
5
]
=
'
\
0
'
;
return
arrayName
;
}
template
<
TBasicType
basicType
TPrecision
precision
TQualifier
qualifier
unsigned
char
primarySize
unsigned
char
secondarySize
>
static
constexpr
StaticMangledName
kMangledNameInstance
=
BuildStaticMangledName
(
basicType
precision
qualifier
primarySize
secondarySize
)
;
template
<
TBasicType
basicType
TPrecision
precision
TQualifier
qualifier
unsigned
char
primarySize
unsigned
char
secondarySize
const
unsigned
int
*
arraySizes
size_t
numArraySizes
>
static
constexpr
StaticArrayMangledName
kMangledNameArrayInstance
=
BuildStaticArrayMangledName
(
basicType
precision
qualifier
primarySize
secondarySize
arraySizes
numArraySizes
)
;
template
<
TBasicType
basicType
TPrecision
precision
TQualifier
qualifier
unsigned
char
primarySize
unsigned
char
secondarySize
>
static
constexpr
TType
instance
=
TType
(
basicType
precision
qualifier
primarySize
secondarySize
TSpan
<
const
unsigned
int
>
(
)
kMangledNameInstance
<
basicType
precision
qualifier
primarySize
secondarySize
>
.
name
)
;
template
<
TBasicType
basicType
TPrecision
precision
TQualifier
qualifier
unsigned
char
primarySize
unsigned
char
secondarySize
const
unsigned
int
*
arraySizes
size_t
numArraySizes
>
static
constexpr
TType
arrayInstance
=
TType
(
basicType
precision
qualifier
primarySize
secondarySize
TSpan
<
const
unsigned
int
>
(
arraySizes
numArraySizes
)
kMangledNameArrayInstance
<
basicType
precision
qualifier
primarySize
secondarySize
arraySizes
numArraySizes
>
.
name
)
;
}
template
<
TBasicType
basicType
TPrecision
precision
TQualifier
qualifier
unsigned
char
primarySize
unsigned
char
secondarySize
>
constexpr
const
TType
*
Get
(
)
{
static_assert
(
1
<
=
primarySize
&
&
primarySize
<
=
4
"
primarySize
out
of
bounds
"
)
;
static_assert
(
1
<
=
secondarySize
&
&
secondarySize
<
=
4
"
secondarySize
out
of
bounds
"
)
;
return
&
Helpers
:
:
instance
<
basicType
precision
qualifier
primarySize
secondarySize
>
;
}
template
<
TBasicType
basicType
TPrecision
precision
TQualifier
qualifier
unsigned
char
primarySize
unsigned
char
secondarySize
const
unsigned
int
*
arraySizes
size_t
numArraySizes
>
constexpr
const
TType
*
GetArray
(
)
{
static_assert
(
1
<
=
primarySize
&
&
primarySize
<
=
4
"
primarySize
out
of
bounds
"
)
;
static_assert
(
1
<
=
secondarySize
&
&
secondarySize
<
=
4
"
secondarySize
out
of
bounds
"
)
;
static_assert
(
numArraySizes
=
=
1
"
only
single
-
dimension
static
types
are
supported
"
)
;
static_assert
(
arraySizes
[
0
]
<
10
"
only
single
-
digit
dimensions
are
supported
in
static
types
"
)
;
return
&
Helpers
:
:
arrayInstance
<
basicType
precision
qualifier
primarySize
secondarySize
arraySizes
numArraySizes
>
;
}
template
<
TBasicType
basicType
unsigned
char
primarySize
=
1
unsigned
char
secondarySize
=
1
>
constexpr
const
TType
*
GetBasic
(
)
{
return
Get
<
basicType
EbpUndefined
EvqGlobal
primarySize
secondarySize
>
(
)
;
}
template
<
TBasicType
basicType
TQualifier
qualifier
unsigned
char
primarySize
=
1
unsigned
char
secondarySize
=
1
>
const
TType
*
GetQualified
(
)
{
return
Get
<
basicType
EbpUndefined
qualifier
primarySize
secondarySize
>
(
)
;
}
namespace
Helpers
{
template
<
TBasicType
basicType
TPrecision
precision
TQualifier
qualifier
unsigned
char
secondarySize
>
constexpr
const
TType
*
GetForVecMatHelper
(
unsigned
char
primarySize
)
{
static_assert
(
basicType
=
=
EbtFloat
|
|
basicType
=
=
EbtInt
|
|
basicType
=
=
EbtUInt
|
|
basicType
=
=
EbtBool
"
unsupported
basicType
"
)
;
switch
(
primarySize
)
{
case
1
:
return
Get
<
basicType
precision
qualifier
1
secondarySize
>
(
)
;
case
2
:
return
Get
<
basicType
precision
qualifier
2
secondarySize
>
(
)
;
case
3
:
return
Get
<
basicType
precision
qualifier
3
secondarySize
>
(
)
;
case
4
:
return
Get
<
basicType
precision
qualifier
4
secondarySize
>
(
)
;
default
:
UNREACHABLE
(
)
;
return
GetBasic
<
EbtVoid
>
(
)
;
}
}
}
template
<
TBasicType
basicType
TPrecision
precision
=
EbpUndefined
TQualifier
qualifier
=
EvqGlobal
>
constexpr
const
TType
*
GetForVecMat
(
unsigned
char
primarySize
unsigned
char
secondarySize
=
1
)
{
static_assert
(
basicType
=
=
EbtFloat
|
|
basicType
=
=
EbtInt
|
|
basicType
=
=
EbtUInt
|
|
basicType
=
=
EbtBool
"
unsupported
basicType
"
)
;
switch
(
secondarySize
)
{
case
1
:
return
Helpers
:
:
GetForVecMatHelper
<
basicType
precision
qualifier
1
>
(
primarySize
)
;
case
2
:
return
Helpers
:
:
GetForVecMatHelper
<
basicType
precision
qualifier
2
>
(
primarySize
)
;
case
3
:
return
Helpers
:
:
GetForVecMatHelper
<
basicType
precision
qualifier
3
>
(
primarySize
)
;
case
4
:
return
Helpers
:
:
GetForVecMatHelper
<
basicType
precision
qualifier
4
>
(
primarySize
)
;
default
:
UNREACHABLE
(
)
;
return
GetBasic
<
EbtVoid
>
(
)
;
}
}
template
<
TBasicType
basicType
TPrecision
precision
=
EbpUndefined
>
constexpr
const
TType
*
GetForVec
(
TQualifier
qualifier
unsigned
char
size
)
{
switch
(
qualifier
)
{
case
EvqGlobal
:
return
Helpers
:
:
GetForVecMatHelper
<
basicType
precision
EvqGlobal
1
>
(
size
)
;
case
EvqOut
:
return
Helpers
:
:
GetForVecMatHelper
<
basicType
precision
EvqOut
1
>
(
size
)
;
default
:
UNREACHABLE
(
)
;
return
GetBasic
<
EbtVoid
>
(
)
;
}
}
}
}
#
endif
