#
ifndef
COMPILER_TRANSLATOR_STATIC_TYPE_H_
#
define
COMPILER_TRANSLATOR_STATIC_TYPE_H_
#
include
"
compiler
/
translator
/
Types
.
h
"
namespace
sh
{
namespace
StaticType
{
namespace
Helpers
{
static
constexpr
size_t
kStaticMangledNameMaxLength
=
10
;
struct
StaticMangledName
{
char
name
[
kStaticMangledNameMaxLength
+
1
]
=
{
}
;
}
;
constexpr
StaticMangledName
BuildStaticMangledName
(
TBasicType
basicType
TPrecision
precision
TQualifier
qualifier
unsigned
char
primarySize
unsigned
char
secondarySize
)
{
StaticMangledName
name
=
{
}
;
size_t
at
=
0
;
bool
isMatrix
=
primarySize
>
1
&
&
secondarySize
>
1
;
bool
isVector
=
primarySize
>
1
&
&
secondarySize
=
=
1
;
if
(
isMatrix
)
{
name
.
name
[
at
+
+
]
=
'
m
'
;
}
else
if
(
isVector
)
{
name
.
name
[
at
+
+
]
=
'
v
'
;
}
{
const
char
*
basicMangledName
=
GetBasicMangledName
(
basicType
)
;
for
(
size_t
i
=
0
;
basicMangledName
[
i
]
!
=
'
\
0
'
;
+
+
i
)
{
name
.
name
[
at
+
+
]
=
basicMangledName
[
i
]
;
}
}
name
.
name
[
at
+
+
]
=
'
0
'
+
primarySize
;
if
(
isMatrix
)
{
name
.
name
[
at
+
+
]
=
'
x
'
;
name
.
name
[
at
+
+
]
=
'
0
'
+
secondarySize
;
}
name
.
name
[
at
+
+
]
=
'
;
'
;
name
.
name
[
at
]
=
'
\
0
'
;
return
name
;
}
template
<
TBasicType
basicType
TPrecision
precision
TQualifier
qualifier
unsigned
char
primarySize
unsigned
char
secondarySize
>
static
constexpr
StaticMangledName
kMangledNameInstance
=
BuildStaticMangledName
(
basicType
precision
qualifier
primarySize
secondarySize
)
;
template
<
TBasicType
basicType
TPrecision
precision
TQualifier
qualifier
unsigned
char
primarySize
unsigned
char
secondarySize
>
static
constexpr
TType
kInstance
=
TType
(
basicType
precision
qualifier
primarySize
secondarySize
kMangledNameInstance
<
basicType
precision
qualifier
primarySize
secondarySize
>
.
name
)
;
}
template
<
TBasicType
basicType
TPrecision
precision
TQualifier
qualifier
unsigned
char
primarySize
unsigned
char
secondarySize
>
constexpr
const
TType
*
Get
(
)
{
static_assert
(
1
<
=
primarySize
&
&
primarySize
<
=
4
"
primarySize
out
of
bounds
"
)
;
static_assert
(
1
<
=
secondarySize
&
&
secondarySize
<
=
4
"
secondarySize
out
of
bounds
"
)
;
return
&
Helpers
:
:
kInstance
<
basicType
precision
qualifier
primarySize
secondarySize
>
;
}
template
<
TBasicType
basicType
unsigned
char
primarySize
=
1
unsigned
char
secondarySize
=
1
>
constexpr
const
TType
*
GetBasic
(
)
{
return
Get
<
basicType
EbpUndefined
EvqGlobal
primarySize
secondarySize
>
(
)
;
}
template
<
TBasicType
basicType
TQualifier
qualifier
unsigned
char
primarySize
=
1
unsigned
char
secondarySize
=
1
>
const
TType
*
GetQualified
(
)
{
return
Get
<
basicType
EbpUndefined
qualifier
primarySize
secondarySize
>
(
)
;
}
namespace
Helpers
{
template
<
TBasicType
basicType
TPrecision
precision
TQualifier
qualifier
unsigned
char
secondarySize
>
constexpr
const
TType
*
GetForVecMatHelper
(
unsigned
char
primarySize
)
{
static_assert
(
basicType
=
=
EbtFloat
|
|
basicType
=
=
EbtInt
|
|
basicType
=
=
EbtUInt
|
|
basicType
=
=
EbtBool
"
unsupported
basicType
"
)
;
switch
(
primarySize
)
{
case
1
:
return
Get
<
basicType
precision
qualifier
1
secondarySize
>
(
)
;
case
2
:
return
Get
<
basicType
precision
qualifier
2
secondarySize
>
(
)
;
case
3
:
return
Get
<
basicType
precision
qualifier
3
secondarySize
>
(
)
;
case
4
:
return
Get
<
basicType
precision
qualifier
4
secondarySize
>
(
)
;
default
:
UNREACHABLE
(
)
;
return
GetBasic
<
EbtVoid
>
(
)
;
}
}
}
template
<
TBasicType
basicType
TPrecision
precision
=
EbpUndefined
TQualifier
qualifier
=
EvqGlobal
>
constexpr
const
TType
*
GetForVecMat
(
unsigned
char
primarySize
unsigned
char
secondarySize
=
1
)
{
static_assert
(
basicType
=
=
EbtFloat
|
|
basicType
=
=
EbtInt
|
|
basicType
=
=
EbtUInt
|
|
basicType
=
=
EbtBool
"
unsupported
basicType
"
)
;
switch
(
secondarySize
)
{
case
1
:
return
Helpers
:
:
GetForVecMatHelper
<
basicType
precision
qualifier
1
>
(
primarySize
)
;
case
2
:
return
Helpers
:
:
GetForVecMatHelper
<
basicType
precision
qualifier
2
>
(
primarySize
)
;
case
3
:
return
Helpers
:
:
GetForVecMatHelper
<
basicType
precision
qualifier
3
>
(
primarySize
)
;
case
4
:
return
Helpers
:
:
GetForVecMatHelper
<
basicType
precision
qualifier
4
>
(
primarySize
)
;
default
:
UNREACHABLE
(
)
;
return
GetBasic
<
EbtVoid
>
(
)
;
}
}
template
<
TBasicType
basicType
TPrecision
precision
=
EbpUndefined
>
constexpr
const
TType
*
GetForVec
(
TQualifier
qualifier
unsigned
char
size
)
{
switch
(
qualifier
)
{
case
EvqGlobal
:
return
Helpers
:
:
GetForVecMatHelper
<
basicType
precision
EvqGlobal
1
>
(
size
)
;
case
EvqOut
:
return
Helpers
:
:
GetForVecMatHelper
<
basicType
precision
EvqOut
1
>
(
size
)
;
default
:
UNREACHABLE
(
)
;
return
GetBasic
<
EbtVoid
>
(
)
;
}
}
const
TType
*
GetForFloatImage
(
TBasicType
basicType
)
;
const
TType
*
GetForIntImage
(
TBasicType
basicType
)
;
const
TType
*
GetForUintImage
(
TBasicType
basicType
)
;
}
}
#
endif
