#
include
"
compiler
/
translator
/
tree_util
/
RewriteSampleMaskVariable
.
h
"
#
include
"
common
/
bitset_utils
.
h
"
#
include
"
common
/
debug
.
h
"
#
include
"
common
/
utilities
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
BuiltIn
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
RunAtTheBeginningOfShader
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
RunAtTheEndOfShader
.
h
"
namespace
sh
{
namespace
{
constexpr
int
kMaxIndexForSampleMaskVar
=
0
;
constexpr
int
kFullSampleMask
=
0xFFFFFFFF
;
class
GLSampleMaskRelatedReferenceTraverser
:
public
TIntermTraverser
{
public
:
GLSampleMaskRelatedReferenceTraverser
(
const
TIntermSymbol
*
*
redeclaredSymOut
const
ImmutableString
&
targetStr
)
:
TIntermTraverser
(
true
false
false
)
mRedeclaredSym
(
redeclaredSymOut
)
mTargetStr
(
targetStr
)
{
*
mRedeclaredSym
=
nullptr
;
}
bool
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
node
)
override
{
const
TIntermSequence
&
sequence
=
*
(
node
-
>
getSequence
(
)
)
;
if
(
sequence
.
size
(
)
!
=
1
)
{
return
true
;
}
TIntermTyped
*
variable
=
sequence
.
front
(
)
-
>
getAsTyped
(
)
;
TIntermSymbol
*
symbol
=
variable
-
>
getAsSymbolNode
(
)
;
if
(
symbol
=
=
nullptr
|
|
symbol
-
>
getName
(
)
!
=
mTargetStr
)
{
return
true
;
}
*
mRedeclaredSym
=
symbol
;
return
true
;
}
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
{
TOperator
op
=
node
-
>
getOp
(
)
;
if
(
op
!
=
EOpIndexDirect
&
&
op
!
=
EOpIndexIndirect
)
{
return
true
;
}
TIntermSymbol
*
left
=
node
-
>
getLeft
(
)
-
>
getAsSymbolNode
(
)
;
if
(
!
left
)
{
return
true
;
}
if
(
left
-
>
getName
(
)
!
=
mTargetStr
)
{
return
true
;
}
const
TConstantUnion
*
constIdx
=
node
-
>
getRight
(
)
-
>
getConstantValue
(
)
;
if
(
!
constIdx
)
{
if
(
node
-
>
getRight
(
)
-
>
hasSideEffects
(
)
)
{
insertStatementInParentBlock
(
node
-
>
getRight
(
)
)
;
}
queueReplacementWithParent
(
node
node
-
>
getRight
(
)
CreateIndexNode
(
kMaxIndexForSampleMaskVar
)
OriginalNode
:
:
IS_DROPPED
)
;
}
return
true
;
}
private
:
const
TIntermSymbol
*
*
mRedeclaredSym
;
const
ImmutableString
mTargetStr
;
}
;
}
ANGLE_NO_DISCARD
bool
RewriteSampleMask
(
TCompiler
*
compiler
TIntermBlock
*
root
TSymbolTable
*
symbolTable
const
TIntermTyped
*
numSamplesUniform
)
{
const
TIntermSymbol
*
redeclaredGLSampleMask
=
nullptr
;
GLSampleMaskRelatedReferenceTraverser
indexTraverser
(
&
redeclaredGLSampleMask
ImmutableString
(
"
gl_SampleMask
"
)
)
;
root
-
>
traverse
(
&
indexTraverser
)
;
if
(
!
indexTraverser
.
updateTree
(
compiler
root
)
)
{
return
false
;
}
const
TVariable
*
glSampleMaskVar
=
nullptr
;
if
(
redeclaredGLSampleMask
)
{
glSampleMaskVar
=
&
redeclaredGLSampleMask
-
>
variable
(
)
;
}
else
{
glSampleMaskVar
=
static_cast
<
const
TVariable
*
>
(
symbolTable
-
>
findBuiltIn
(
ImmutableString
(
"
gl_SampleMask
"
)
320
)
)
;
}
if
(
!
glSampleMaskVar
)
{
return
false
;
}
const
unsigned
int
arraySizeOfSampleMask
=
glSampleMaskVar
-
>
getType
(
)
.
getOutermostArraySize
(
)
;
ASSERT
(
arraySizeOfSampleMask
=
=
1
)
;
TIntermSymbol
*
glSampleMaskSymbol
=
new
TIntermSymbol
(
glSampleMaskVar
)
;
TIntermConstantUnion
*
singleSampleCount
=
CreateUIntNode
(
1
)
;
TIntermBinary
*
equalTo
=
new
TIntermBinary
(
EOpEqual
numSamplesUniform
-
>
deepCopy
(
)
singleSampleCount
)
;
TIntermBlock
*
trueBlock
=
new
TIntermBlock
(
)
;
TIntermBinary
*
sampleMaskVar
=
new
TIntermBinary
(
EOpIndexDirect
glSampleMaskSymbol
-
>
deepCopy
(
)
CreateIndexNode
(
kMaxIndexForSampleMaskVar
)
)
;
TIntermConstantUnion
*
fullSampleMask
=
CreateIndexNode
(
kFullSampleMask
)
;
TIntermBinary
*
assignment
=
new
TIntermBinary
(
EOpAssign
sampleMaskVar
fullSampleMask
)
;
trueBlock
-
>
appendStatement
(
assignment
)
;
TIntermIfElse
*
multiSampleOrNot
=
new
TIntermIfElse
(
equalTo
trueBlock
nullptr
)
;
return
RunAtTheEndOfShader
(
compiler
root
multiSampleOrNot
symbolTable
)
;
}
ANGLE_NO_DISCARD
bool
RewriteSampleMaskIn
(
TCompiler
*
compiler
TIntermBlock
*
root
TSymbolTable
*
symbolTable
)
{
const
TIntermSymbol
*
redeclaredGLSampleMaskIn
=
nullptr
;
GLSampleMaskRelatedReferenceTraverser
indexTraverser
(
&
redeclaredGLSampleMaskIn
ImmutableString
(
"
gl_SampleMaskIn
"
)
)
;
root
-
>
traverse
(
&
indexTraverser
)
;
if
(
!
indexTraverser
.
updateTree
(
compiler
root
)
)
{
return
false
;
}
const
TVariable
*
glSampleMaskInVar
=
nullptr
;
glSampleMaskInVar
=
static_cast
<
const
TVariable
*
>
(
symbolTable
-
>
findBuiltIn
(
ImmutableString
(
"
gl_SampleMaskIn
"
)
320
)
)
;
if
(
!
glSampleMaskInVar
)
{
return
false
;
}
const
unsigned
int
arraySizeOfSampleMaskIn
=
glSampleMaskInVar
-
>
getType
(
)
.
getOutermostArraySize
(
)
;
ASSERT
(
arraySizeOfSampleMaskIn
=
=
1
)
;
return
true
;
}
}
