#
include
"
compiler
/
translator
/
tree_util
/
ReplaceClipDistanceVariable
.
h
"
#
include
"
common
/
bitset_utils
.
h
"
#
include
"
common
/
debug
.
h
"
#
include
"
common
/
utilities
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
BuiltIn
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
RunAtTheEndOfShader
.
h
"
namespace
sh
{
namespace
{
using
ClipDistanceIdxSet
=
angle
:
:
BitSet
<
32
>
;
class
GLClipDistanceReferenceTraverser
:
public
TIntermTraverser
{
public
:
GLClipDistanceReferenceTraverser
(
const
TIntermSymbol
*
*
redeclaredSymOut
bool
*
nonConstIdxUsedOut
unsigned
int
*
maxConstIdxOut
ClipDistanceIdxSet
*
constIndicesOut
)
:
TIntermTraverser
(
true
false
false
)
mRedeclaredSym
(
redeclaredSymOut
)
mUseNonConstClipDistanceIndex
(
nonConstIdxUsedOut
)
mMaxConstClipDistanceIndex
(
maxConstIdxOut
)
mConstClipDistanceIndices
(
constIndicesOut
)
{
*
mRedeclaredSym
=
nullptr
;
*
mUseNonConstClipDistanceIndex
=
false
;
*
mMaxConstClipDistanceIndex
=
0
;
mConstClipDistanceIndices
-
>
reset
(
)
;
}
bool
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
node
)
override
{
const
TIntermSequence
&
sequence
=
*
(
node
-
>
getSequence
(
)
)
;
if
(
sequence
.
size
(
)
!
=
1
)
{
return
true
;
}
TIntermTyped
*
variable
=
sequence
.
front
(
)
-
>
getAsTyped
(
)
;
if
(
!
variable
-
>
getAsSymbolNode
(
)
|
|
variable
-
>
getAsSymbolNode
(
)
-
>
getName
(
)
!
=
"
gl_ClipDistance
"
)
{
return
true
;
}
*
mRedeclaredSym
=
variable
-
>
getAsSymbolNode
(
)
;
return
true
;
}
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
{
TOperator
op
=
node
-
>
getOp
(
)
;
if
(
op
!
=
EOpIndexDirect
&
&
op
!
=
EOpIndexIndirect
)
{
return
true
;
}
TIntermSymbol
*
left
=
node
-
>
getLeft
(
)
-
>
getAsSymbolNode
(
)
;
if
(
!
left
)
{
return
true
;
}
if
(
left
-
>
getName
(
)
!
=
"
gl_ClipDistance
"
)
{
return
true
;
}
const
TConstantUnion
*
constIdx
=
node
-
>
getRight
(
)
-
>
getConstantValue
(
)
;
if
(
!
constIdx
)
{
*
mUseNonConstClipDistanceIndex
=
true
;
}
else
{
unsigned
int
idx
=
0
;
switch
(
constIdx
-
>
getType
(
)
)
{
case
EbtInt
:
idx
=
constIdx
-
>
getIConst
(
)
;
break
;
case
EbtUInt
:
idx
=
constIdx
-
>
getUConst
(
)
;
break
;
case
EbtFloat
:
idx
=
static_cast
<
unsigned
int
>
(
constIdx
-
>
getFConst
(
)
)
;
break
;
case
EbtBool
:
idx
=
constIdx
-
>
getBConst
(
)
?
1
:
0
;
break
;
default
:
UNREACHABLE
(
)
;
break
;
}
ASSERT
(
idx
<
mConstClipDistanceIndices
-
>
size
(
)
)
;
mConstClipDistanceIndices
-
>
set
(
idx
)
;
*
mMaxConstClipDistanceIndex
=
std
:
:
max
(
*
mMaxConstClipDistanceIndex
idx
)
;
}
return
true
;
}
private
:
const
TIntermSymbol
*
*
mRedeclaredSym
;
bool
*
mUseNonConstClipDistanceIndex
;
unsigned
int
*
mMaxConstClipDistanceIndex
;
ClipDistanceIdxSet
*
mConstClipDistanceIndices
;
}
;
class
ReplaceVariableExceptOneTraverser
:
public
TIntermTraverser
{
public
:
ReplaceVariableExceptOneTraverser
(
const
TVariable
*
toBeReplaced
const
TIntermTyped
*
replacement
const
TIntermSymbol
*
exception
)
:
TIntermTraverser
(
true
false
false
)
mToBeReplaced
(
toBeReplaced
)
mException
(
exception
)
mReplacement
(
replacement
)
{
}
void
visitSymbol
(
TIntermSymbol
*
node
)
override
{
if
(
&
node
-
>
variable
(
)
=
=
mToBeReplaced
&
&
node
!
=
mException
)
{
queueReplacement
(
mReplacement
-
>
deepCopy
(
)
OriginalNode
:
:
IS_DROPPED
)
;
}
}
private
:
const
TVariable
*
const
mToBeReplaced
;
const
TIntermSymbol
*
const
mException
;
const
TIntermTyped
*
const
mReplacement
;
}
;
}
ANGLE_NO_DISCARD
bool
ReplaceClipDistanceAssignments
(
TCompiler
*
compiler
TIntermBlock
*
root
TSymbolTable
*
symbolTable
const
TIntermTyped
*
clipDistanceEnableFlags
)
{
ClipDistanceIdxSet
constIndices
;
bool
useNonConstIndex
=
false
;
const
TIntermSymbol
*
redeclaredGLClipDistance
=
nullptr
;
unsigned
int
maxConstIndex
=
0
;
GLClipDistanceReferenceTraverser
indexTraverser
(
&
redeclaredGLClipDistance
&
useNonConstIndex
&
maxConstIndex
&
constIndices
)
;
root
-
>
traverse
(
&
indexTraverser
)
;
if
(
!
useNonConstIndex
&
&
constIndices
.
none
(
)
)
{
return
true
;
}
const
TVariable
*
glClipDistanceVar
=
nullptr
;
if
(
redeclaredGLClipDistance
)
{
glClipDistanceVar
=
&
redeclaredGLClipDistance
-
>
variable
(
)
;
}
else
{
ImmutableString
glClipDistanceName
(
"
gl_ClipDistance
"
)
;
glClipDistanceVar
=
static_cast
<
const
TVariable
*
>
(
symbolTable
-
>
findBuiltIn
(
glClipDistanceName
0
)
)
;
}
if
(
!
glClipDistanceVar
)
{
return
false
;
}
TType
*
clipDistanceType
=
new
TType
(
EbtFloat
EbpMedium
EvqGlobal
1
)
;
if
(
redeclaredGLClipDistance
)
{
clipDistanceType
-
>
makeArray
(
redeclaredGLClipDistance
-
>
getType
(
)
.
getOutermostArraySize
(
)
)
;
}
else
if
(
!
useNonConstIndex
)
{
ASSERT
(
maxConstIndex
<
glClipDistanceVar
-
>
getType
(
)
.
getOutermostArraySize
(
)
)
;
clipDistanceType
-
>
makeArray
(
maxConstIndex
+
1
)
;
}
else
{
clipDistanceType
-
>
makeArray
(
glClipDistanceVar
-
>
getType
(
)
.
getOutermostArraySize
(
)
)
;
}
clipDistanceType
-
>
realize
(
)
;
TVariable
*
clipDistanceVar
=
new
TVariable
(
symbolTable
ImmutableString
(
"
ANGLEClipDistance
"
)
clipDistanceType
SymbolType
:
:
AngleInternal
)
;
TIntermSymbol
*
clipDistanceDeclarator
=
new
TIntermSymbol
(
clipDistanceVar
)
;
TIntermDeclaration
*
clipDistanceDecl
=
new
TIntermDeclaration
;
clipDistanceDecl
-
>
appendDeclarator
(
clipDistanceDeclarator
)
;
root
-
>
insertStatement
(
0
clipDistanceDecl
)
;
ReplaceVariableExceptOneTraverser
replaceTraverser
(
glClipDistanceVar
new
TIntermSymbol
(
clipDistanceVar
)
redeclaredGLClipDistance
)
;
root
-
>
traverse
(
&
replaceTraverser
)
;
if
(
!
replaceTraverser
.
updateTree
(
compiler
root
)
)
{
return
false
;
}
TIntermBlock
*
reassignBlock
=
new
TIntermBlock
;
TIntermSymbol
*
glClipDistanceSymbol
=
new
TIntermSymbol
(
glClipDistanceVar
)
;
TIntermSymbol
*
clipDistanceSymbol
=
new
TIntermSymbol
(
clipDistanceVar
)
;
auto
assignFunc
=
[
=
]
(
unsigned
int
index
)
{
TIntermConstantUnion
*
bitMask
=
CreateUIntNode
(
0x1
<
<
index
)
;
TIntermBinary
*
bitwiseAnd
=
new
TIntermBinary
(
EOpBitwiseAnd
clipDistanceEnableFlags
-
>
deepCopy
(
)
bitMask
)
;
TIntermBinary
*
nonZero
=
new
TIntermBinary
(
EOpNotEqual
bitwiseAnd
CreateUIntNode
(
0
)
)
;
TIntermBinary
*
left
=
new
TIntermBinary
(
EOpIndexDirect
glClipDistanceSymbol
-
>
deepCopy
(
)
CreateIndexNode
(
index
)
)
;
TIntermBinary
*
right
=
new
TIntermBinary
(
EOpIndexDirect
clipDistanceSymbol
-
>
deepCopy
(
)
CreateIndexNode
(
index
)
)
;
TIntermBinary
*
assignment
=
new
TIntermBinary
(
EOpAssign
left
right
)
;
TIntermBlock
*
trueBlock
=
new
TIntermBlock
(
)
;
trueBlock
-
>
appendStatement
(
assignment
)
;
TIntermBinary
*
zeroAssignment
=
new
TIntermBinary
(
EOpAssign
left
-
>
deepCopy
(
)
CreateFloatNode
(
0
)
)
;
TIntermBlock
*
falseBlock
=
new
TIntermBlock
(
)
;
falseBlock
-
>
appendStatement
(
zeroAssignment
)
;
return
new
TIntermIfElse
(
nonZero
trueBlock
falseBlock
)
;
}
;
if
(
useNonConstIndex
)
{
for
(
unsigned
int
i
=
0
;
i
<
clipDistanceType
-
>
getOutermostArraySize
(
)
;
+
+
i
)
{
reassignBlock
-
>
appendStatement
(
assignFunc
(
i
)
)
;
}
}
else
{
for
(
unsigned
int
i
=
0
;
i
<
clipDistanceType
-
>
getOutermostArraySize
(
)
;
+
+
i
)
{
if
(
constIndices
.
test
(
i
)
)
{
reassignBlock
-
>
appendStatement
(
assignFunc
(
i
)
)
;
}
else
{
TIntermBinary
*
left
=
new
TIntermBinary
(
EOpIndexDirect
glClipDistanceSymbol
-
>
deepCopy
(
)
CreateIndexNode
(
i
)
)
;
TIntermBinary
*
zeroAssignment
=
new
TIntermBinary
(
EOpAssign
left
CreateFloatNode
(
0
)
)
;
reassignBlock
-
>
appendStatement
(
zeroAssignment
)
;
}
}
}
return
RunAtTheEndOfShader
(
compiler
root
reassignBlock
symbolTable
)
;
}
}
