#
include
"
compiler
/
translator
/
tree_util
/
FindPreciseNodes
.
h
"
#
include
"
common
/
hash_utils
.
h
"
#
include
"
compiler
/
translator
/
Compiler
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
#
include
"
compiler
/
translator
/
Symbol
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
class
AccessChain
{
public
:
AccessChain
(
)
=
default
;
bool
operator
=
=
(
const
AccessChain
&
other
)
const
{
return
mChain
=
=
other
.
mChain
;
}
const
TVariable
*
build
(
TIntermTyped
*
lvalue
)
;
const
TVector
<
size_t
>
&
getChain
(
)
const
{
return
mChain
;
}
void
reduceChain
(
size_t
newSize
)
{
ASSERT
(
newSize
<
=
mChain
.
size
(
)
)
;
mChain
.
resize
(
newSize
)
;
}
void
clear
(
)
{
reduceChain
(
0
)
;
}
void
push_back
(
size_t
index
)
{
mChain
.
push_back
(
index
)
;
}
void
pop_front
(
size_t
n
)
;
void
append
(
const
AccessChain
&
other
)
{
mChain
.
insert
(
mChain
.
end
(
)
other
.
mChain
.
begin
(
)
other
.
mChain
.
end
(
)
)
;
}
bool
removePrefix
(
const
AccessChain
&
other
)
;
private
:
TVector
<
size_t
>
mChain
;
}
;
bool
IsIndexOp
(
TOperator
op
)
{
switch
(
op
)
{
case
EOpIndexDirect
:
case
EOpIndexDirectStruct
:
case
EOpIndexDirectInterfaceBlock
:
case
EOpIndexIndirect
:
return
true
;
default
:
return
false
;
}
}
const
TVariable
*
AccessChain
:
:
build
(
TIntermTyped
*
lvalue
)
{
if
(
lvalue
-
>
getAsSwizzleNode
(
)
)
{
return
build
(
lvalue
-
>
getAsSwizzleNode
(
)
-
>
getOperand
(
)
)
;
}
if
(
lvalue
-
>
getAsSymbolNode
(
)
)
{
const
TVariable
*
var
=
&
lvalue
-
>
getAsSymbolNode
(
)
-
>
variable
(
)
;
if
(
var
-
>
getType
(
)
.
getInterfaceBlock
(
)
!
=
nullptr
)
{
mChain
.
push_back
(
var
-
>
getType
(
)
.
getInterfaceBlockFieldIndex
(
)
)
;
}
return
var
;
}
TIntermBinary
*
binary
=
lvalue
-
>
getAsBinaryNode
(
)
;
ASSERT
(
binary
)
;
TOperator
op
=
binary
-
>
getOp
(
)
;
ASSERT
(
IsIndexOp
(
op
)
)
;
const
TVariable
*
var
=
build
(
binary
-
>
getLeft
(
)
)
;
if
(
op
=
=
EOpIndexDirectStruct
|
|
op
=
=
EOpIndexDirectInterfaceBlock
)
{
int
fieldIndex
=
binary
-
>
getRight
(
)
-
>
getAsConstantUnion
(
)
-
>
getIConst
(
0
)
;
mChain
.
push_back
(
fieldIndex
)
;
}
return
var
;
}
void
AccessChain
:
:
pop_front
(
size_t
n
)
{
std
:
:
rotate
(
mChain
.
begin
(
)
mChain
.
begin
(
)
+
n
mChain
.
end
(
)
)
;
reduceChain
(
mChain
.
size
(
)
-
n
)
;
}
bool
AccessChain
:
:
removePrefix
(
const
AccessChain
&
other
)
{
size_t
commonSize
=
std
:
:
min
(
mChain
.
size
(
)
other
.
mChain
.
size
(
)
)
;
for
(
size_t
index
=
0
;
index
<
commonSize
;
+
+
index
)
{
if
(
mChain
[
index
]
!
=
other
.
mChain
[
index
]
)
{
return
false
;
}
}
pop_front
(
commonSize
)
;
return
true
;
}
AccessChain
GetAssignmentAccessChain
(
TIntermOperator
*
node
)
{
AccessChain
lvalueAccessChain
;
lvalueAccessChain
.
build
(
node
-
>
getChildNode
(
0
)
-
>
getAsTyped
(
)
)
;
return
lvalueAccessChain
;
}
template
<
typename
Traverser
>
void
TraverseIndexNodesOnly
(
TIntermNode
*
node
Traverser
*
traverser
)
{
if
(
node
-
>
getAsSwizzleNode
(
)
)
{
node
=
node
-
>
getAsSwizzleNode
(
)
-
>
getOperand
(
)
;
}
if
(
node
-
>
getAsSymbolNode
(
)
)
{
return
;
}
TIntermBinary
*
binary
=
node
-
>
getAsBinaryNode
(
)
;
ASSERT
(
binary
)
;
TOperator
op
=
binary
-
>
getOp
(
)
;
ASSERT
(
IsIndexOp
(
op
)
)
;
if
(
op
=
=
EOpIndexIndirect
)
{
binary
-
>
getRight
(
)
-
>
traverse
(
traverser
)
;
}
TraverseIndexNodesOnly
(
binary
-
>
getLeft
(
)
traverser
)
;
}
struct
ObjectAndAccessChain
{
const
TVariable
*
variable
;
AccessChain
accessChain
;
}
;
bool
operator
=
=
(
const
ObjectAndAccessChain
&
a
const
ObjectAndAccessChain
&
b
)
{
return
a
.
variable
=
=
b
.
variable
&
&
a
.
accessChain
=
=
b
.
accessChain
;
}
struct
ObjectAndAccessChainHash
{
size_t
operator
(
)
(
const
ObjectAndAccessChain
&
object
)
const
{
size_t
result
=
angle
:
:
ComputeGenericHash
(
&
object
.
variable
sizeof
(
object
.
variable
)
)
;
if
(
!
object
.
accessChain
.
getChain
(
)
.
empty
(
)
)
{
result
=
result
^
angle
:
:
ComputeGenericHash
(
object
.
accessChain
.
getChain
(
)
.
data
(
)
object
.
accessChain
.
getChain
(
)
.
size
(
)
*
sizeof
(
object
.
accessChain
.
getChain
(
)
[
0
]
)
)
;
}
return
result
;
}
}
;
using
VariableToAssignmentNodeMap
=
angle
:
:
HashMap
<
const
TVariable
*
TVector
<
TIntermOperator
*
>
>
;
using
PreciseReturnNodes
=
angle
:
:
HashSet
<
TIntermBranch
*
>
;
using
PreciseObjectSet
=
angle
:
:
HashSet
<
ObjectAndAccessChain
ObjectAndAccessChainHash
>
;
struct
ASTInfo
{
VariableToAssignmentNodeMap
variableAssignmentNodeMap
;
PreciseReturnNodes
preciseReturnNodes
;
PreciseObjectSet
preciseObjectsToProcess
;
PreciseObjectSet
preciseObjectsVisited
;
}
;
int
GetObjectPreciseSubChainLength
(
const
ObjectAndAccessChain
&
object
)
{
const
TType
&
type
=
object
.
variable
-
>
getType
(
)
;
if
(
type
.
isPrecise
(
)
)
{
return
0
;
}
const
TFieldListCollection
*
block
=
type
.
getInterfaceBlock
(
)
;
if
(
block
=
=
nullptr
)
{
block
=
type
.
getStruct
(
)
;
}
const
TVector
<
size_t
>
&
accessChain
=
object
.
accessChain
.
getChain
(
)
;
for
(
size_t
length
=
0
;
length
<
accessChain
.
size
(
)
;
+
+
length
)
{
ASSERT
(
block
!
=
nullptr
)
;
const
TField
*
field
=
block
-
>
fields
(
)
[
accessChain
[
length
]
]
;
if
(
field
-
>
type
(
)
-
>
isPrecise
(
)
)
{
return
static_cast
<
int
>
(
length
+
1
)
;
}
block
=
field
-
>
type
(
)
-
>
getStruct
(
)
;
}
return
-
1
;
}
void
AddPreciseObject
(
ASTInfo
*
info
const
ObjectAndAccessChain
&
object
)
{
if
(
info
-
>
preciseObjectsVisited
.
count
(
object
)
>
0
)
{
return
;
}
info
-
>
preciseObjectsToProcess
.
insert
(
object
)
;
info
-
>
preciseObjectsVisited
.
insert
(
object
)
;
}
void
AddPreciseSubObjects
(
ASTInfo
*
info
const
ObjectAndAccessChain
&
object
)
;
void
AddObjectIfPrecise
(
ASTInfo
*
info
const
ObjectAndAccessChain
&
object
)
{
int
preciseSubChainLength
=
GetObjectPreciseSubChainLength
(
object
)
;
if
(
preciseSubChainLength
=
=
-
1
)
{
AddPreciseSubObjects
(
info
object
)
;
return
;
}
ObjectAndAccessChain
preciseObject
=
object
;
preciseObject
.
accessChain
.
reduceChain
(
preciseSubChainLength
)
;
AddPreciseObject
(
info
preciseObject
)
;
}
void
AddPreciseSubObjects
(
ASTInfo
*
info
const
ObjectAndAccessChain
&
object
)
{
const
TFieldListCollection
*
block
=
object
.
variable
-
>
getType
(
)
.
getInterfaceBlock
(
)
;
if
(
block
=
=
nullptr
)
{
block
=
object
.
variable
-
>
getType
(
)
.
getStruct
(
)
;
}
const
TVector
<
size_t
>
&
accessChain
=
object
.
accessChain
.
getChain
(
)
;
for
(
size_t
length
=
0
;
length
<
accessChain
.
size
(
)
;
+
+
length
)
{
block
=
block
-
>
fields
(
)
[
accessChain
[
length
]
]
-
>
type
(
)
-
>
getStruct
(
)
;
}
if
(
block
=
=
nullptr
)
{
return
;
}
for
(
size_t
fieldIndex
=
0
;
fieldIndex
<
block
-
>
fields
(
)
.
size
(
)
;
+
+
fieldIndex
)
{
ObjectAndAccessChain
subObject
=
object
;
subObject
.
accessChain
.
push_back
(
fieldIndex
)
;
if
(
block
-
>
fields
(
)
[
fieldIndex
]
-
>
type
(
)
-
>
isPrecise
(
)
)
{
AddPreciseObject
(
info
subObject
)
;
}
else
{
AddPreciseSubObjects
(
info
subObject
)
;
}
}
}
bool
IsArithmeticOp
(
TOperator
op
)
{
switch
(
op
)
{
case
EOpNegative
:
case
EOpPostIncrement
:
case
EOpPostDecrement
:
case
EOpPreIncrement
:
case
EOpPreDecrement
:
case
EOpAdd
:
case
EOpSub
:
case
EOpMul
:
case
EOpDiv
:
case
EOpIMod
:
case
EOpVectorTimesScalar
:
case
EOpVectorTimesMatrix
:
case
EOpMatrixTimesVector
:
case
EOpMatrixTimesScalar
:
case
EOpMatrixTimesMatrix
:
case
EOpAddAssign
:
case
EOpSubAssign
:
case
EOpMulAssign
:
case
EOpVectorTimesMatrixAssign
:
case
EOpVectorTimesScalarAssign
:
case
EOpMatrixTimesScalarAssign
:
case
EOpMatrixTimesMatrixAssign
:
case
EOpDivAssign
:
case
EOpIModAssign
:
case
EOpDot
:
return
true
;
default
:
return
false
;
}
}
class
InfoGatherTraverser
:
public
TIntermTraverser
{
public
:
InfoGatherTraverser
(
ASTInfo
*
info
)
:
TIntermTraverser
(
true
false
false
)
mInfo
(
info
)
{
}
bool
visitUnary
(
Visit
visit
TIntermUnary
*
node
)
override
{
if
(
!
IsAssignment
(
node
-
>
getOp
(
)
)
)
{
return
true
;
}
visitLvalue
(
node
node
-
>
getOperand
(
)
)
;
return
false
;
}
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
{
if
(
IsAssignment
(
node
-
>
getOp
(
)
)
)
{
visitLvalue
(
node
node
-
>
getLeft
(
)
)
;
node
-
>
getRight
(
)
-
>
traverse
(
this
)
;
return
false
;
}
return
true
;
}
bool
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
node
)
override
{
const
TIntermSequence
&
sequence
=
*
(
node
-
>
getSequence
(
)
)
;
TIntermSymbol
*
symbol
=
sequence
.
front
(
)
-
>
getAsSymbolNode
(
)
;
TIntermBinary
*
initNode
=
sequence
.
front
(
)
-
>
getAsBinaryNode
(
)
;
TIntermTyped
*
initExpression
=
nullptr
;
if
(
symbol
=
=
nullptr
)
{
ASSERT
(
initNode
-
>
getOp
(
)
=
=
EOpInitialize
)
;
symbol
=
initNode
-
>
getLeft
(
)
-
>
getAsSymbolNode
(
)
;
initExpression
=
initNode
-
>
getRight
(
)
;
}
ASSERT
(
symbol
)
;
ObjectAndAccessChain
object
=
{
&
symbol
-
>
variable
(
)
{
}
}
;
AddObjectIfPrecise
(
mInfo
object
)
;
if
(
initExpression
)
{
mInfo
-
>
variableAssignmentNodeMap
[
object
.
variable
]
.
push_back
(
initNode
)
;
initExpression
-
>
traverse
(
this
)
;
}
return
false
;
}
bool
visitFunctionDefinition
(
Visit
visit
TIntermFunctionDefinition
*
node
)
override
{
mCurrentFunction
=
node
-
>
getFunction
(
)
;
for
(
size_t
paramIndex
=
0
;
paramIndex
<
mCurrentFunction
-
>
getParamCount
(
)
;
+
+
paramIndex
)
{
ObjectAndAccessChain
param
=
{
mCurrentFunction
-
>
getParam
(
paramIndex
)
{
}
}
;
AddObjectIfPrecise
(
mInfo
param
)
;
}
return
true
;
}
bool
visitBranch
(
Visit
visit
TIntermBranch
*
node
)
override
{
if
(
node
-
>
getFlowOp
(
)
=
=
EOpReturn
&
&
node
-
>
getChildCount
(
)
=
=
1
&
&
mCurrentFunction
-
>
getReturnType
(
)
.
isPrecise
(
)
)
{
mInfo
-
>
preciseReturnNodes
.
insert
(
node
)
;
}
return
true
;
}
bool
visitGlobalQualifierDeclaration
(
Visit
visit
TIntermGlobalQualifierDeclaration
*
node
)
override
{
if
(
node
-
>
isPrecise
(
)
)
{
ObjectAndAccessChain
preciseObject
=
{
&
node
-
>
getSymbol
(
)
-
>
variable
(
)
{
}
}
;
AddPreciseObject
(
mInfo
preciseObject
)
;
}
return
false
;
}
private
:
void
visitLvalue
(
TIntermOperator
*
assignmentNode
TIntermTyped
*
lvalueNode
)
{
AccessChain
lvalueChain
;
const
TVariable
*
lvalueBase
=
lvalueChain
.
build
(
lvalueNode
)
;
mInfo
-
>
variableAssignmentNodeMap
[
lvalueBase
]
.
push_back
(
assignmentNode
)
;
ObjectAndAccessChain
lvalue
=
{
lvalueBase
lvalueChain
}
;
AddObjectIfPrecise
(
mInfo
lvalue
)
;
TraverseIndexNodesOnly
(
lvalueNode
this
)
;
}
ASTInfo
*
mInfo
=
nullptr
;
const
TFunction
*
mCurrentFunction
=
nullptr
;
}
;
class
PropagatePreciseTraverser
:
public
TIntermTraverser
{
public
:
PropagatePreciseTraverser
(
ASTInfo
*
info
)
:
TIntermTraverser
(
true
false
false
)
mInfo
(
info
)
{
}
void
propagatePrecise
(
TIntermNode
*
expression
const
AccessChain
&
accessChain
)
{
mCurrentAccessChain
=
accessChain
;
expression
-
>
traverse
(
this
)
;
}
bool
visitUnary
(
Visit
visit
TIntermUnary
*
node
)
override
{
ASSERT
(
mCurrentAccessChain
.
getChain
(
)
.
empty
(
)
)
;
if
(
IsArithmeticOp
(
node
-
>
getOp
(
)
)
)
{
node
-
>
setIsPrecise
(
)
;
}
return
true
;
}
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
{
if
(
IsIndexOp
(
node
-
>
getOp
(
)
)
)
{
AccessChain
nodeAccessChain
;
const
TVariable
*
baseVariable
=
nodeAccessChain
.
build
(
node
)
;
nodeAccessChain
.
append
(
mCurrentAccessChain
)
;
ObjectAndAccessChain
preciseObject
=
{
baseVariable
nodeAccessChain
}
;
AddPreciseObject
(
mInfo
preciseObject
)
;
mCurrentAccessChain
.
clear
(
)
;
TraverseIndexNodesOnly
(
node
this
)
;
return
false
;
}
if
(
node
-
>
getOp
(
)
=
=
EOpComma
)
{
node
-
>
getRight
(
)
-
>
traverse
(
this
)
;
return
false
;
}
if
(
IsArithmeticOp
(
node
-
>
getOp
(
)
)
)
{
node
-
>
setIsPrecise
(
)
;
}
if
(
IsAssignment
(
node
-
>
getOp
(
)
)
|
|
node
-
>
getOp
(
)
=
=
EOpInitialize
)
{
node
-
>
getRight
(
)
-
>
traverse
(
this
)
;
mCurrentAccessChain
.
clear
(
)
;
TraverseIndexNodesOnly
(
node
-
>
getLeft
(
)
this
)
;
return
false
;
}
ASSERT
(
mCurrentAccessChain
.
getChain
(
)
.
empty
(
)
)
;
return
true
;
}
void
visitSymbol
(
TIntermSymbol
*
symbol
)
override
{
ObjectAndAccessChain
preciseObject
=
{
&
symbol
-
>
variable
(
)
mCurrentAccessChain
}
;
AddPreciseObject
(
mInfo
preciseObject
)
;
}
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
{
const
TType
&
type
=
node
-
>
getType
(
)
;
const
bool
isStructConstructor
=
node
-
>
getOp
(
)
=
=
EOpConstruct
&
&
type
.
getStruct
(
)
!
=
nullptr
&
&
!
type
.
isArray
(
)
;
if
(
!
mCurrentAccessChain
.
getChain
(
)
.
empty
(
)
&
&
isStructConstructor
)
{
size_t
selectedFieldIndex
=
mCurrentAccessChain
.
getChain
(
)
.
front
(
)
;
mCurrentAccessChain
.
pop_front
(
1
)
;
ASSERT
(
selectedFieldIndex
<
node
-
>
getChildCount
(
)
)
;
node
-
>
getChildNode
(
selectedFieldIndex
)
-
>
traverse
(
this
)
;
return
false
;
}
if
(
node
-
>
getOp
(
)
=
=
EOpConstruct
)
{
ASSERT
(
type
.
isArray
(
)
|
|
mCurrentAccessChain
.
getChain
(
)
.
empty
(
)
)
;
return
true
;
}
mCurrentAccessChain
.
clear
(
)
;
const
TFunction
*
function
=
node
-
>
getFunction
(
)
;
ASSERT
(
function
)
;
for
(
size_t
paramIndex
=
0
;
paramIndex
<
function
-
>
getParamCount
(
)
;
+
+
paramIndex
)
{
if
(
function
-
>
getParam
(
paramIndex
)
-
>
getType
(
)
.
getQualifier
(
)
!
=
EvqParamOut
)
{
node
-
>
getChildNode
(
paramIndex
)
-
>
traverse
(
this
)
;
}
}
if
(
IsArithmeticOp
(
node
-
>
getOp
(
)
)
)
{
node
-
>
setIsPrecise
(
)
;
}
return
false
;
}
private
:
ASTInfo
*
mInfo
=
nullptr
;
AccessChain
mCurrentAccessChain
;
}
;
}
void
FindPreciseNodes
(
TCompiler
*
compiler
TIntermBlock
*
root
)
{
ASTInfo
info
;
InfoGatherTraverser
infoGather
(
&
info
)
;
root
-
>
traverse
(
&
infoGather
)
;
PropagatePreciseTraverser
propagator
(
&
info
)
;
for
(
TIntermBranch
*
returnNode
:
info
.
preciseReturnNodes
)
{
ASSERT
(
returnNode
-
>
getChildCount
(
)
=
=
1
)
;
propagator
.
propagatePrecise
(
returnNode
-
>
getChildNode
(
0
)
{
}
)
;
}
while
(
!
info
.
preciseObjectsToProcess
.
empty
(
)
)
{
auto
first
=
info
.
preciseObjectsToProcess
.
begin
(
)
;
const
ObjectAndAccessChain
toProcess
=
*
first
;
info
.
preciseObjectsToProcess
.
erase
(
first
)
;
const
TVector
<
TIntermOperator
*
>
&
assignmentNodes
=
info
.
variableAssignmentNodeMap
[
toProcess
.
variable
]
;
for
(
TIntermOperator
*
assignmentNode
:
assignmentNodes
)
{
AccessChain
assignmentAccessChain
=
GetAssignmentAccessChain
(
assignmentNode
)
;
AccessChain
remainingAccessChain
=
toProcess
.
accessChain
;
if
(
!
remainingAccessChain
.
removePrefix
(
assignmentAccessChain
)
)
{
continue
;
}
propagator
.
propagatePrecise
(
assignmentNode
remainingAccessChain
)
;
}
}
compiler
-
>
enableValidateNoMoreTransformations
(
)
;
}
}
