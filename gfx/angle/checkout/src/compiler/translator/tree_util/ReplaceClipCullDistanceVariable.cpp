#
include
"
compiler
/
translator
/
tree_util
/
ReplaceClipCullDistanceVariable
.
h
"
#
include
"
common
/
bitset_utils
.
h
"
#
include
"
common
/
debug
.
h
"
#
include
"
common
/
utilities
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
BuiltIn
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
RunAtTheBeginningOfShader
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
RunAtTheEndOfShader
.
h
"
namespace
sh
{
namespace
{
using
ClipCullDistanceIdxSet
=
angle
:
:
BitSet
<
32
>
;
typedef
TIntermNode
*
AssignFunc
(
const
unsigned
int
index
TIntermSymbol
*
left
TIntermSymbol
*
right
const
TIntermTyped
*
enableFlags
)
;
template
<
typename
Variable
>
const
Variable
*
FindVariable
(
const
std
:
:
vector
<
Variable
>
&
mVars
const
ImmutableString
&
name
)
{
for
(
const
Variable
&
var
:
mVars
)
{
if
(
name
=
=
var
.
instanceName
)
{
return
&
var
;
}
}
return
nullptr
;
}
class
GLClipCullDistanceReferenceTraverser
:
public
TIntermTraverser
{
public
:
GLClipCullDistanceReferenceTraverser
(
const
TIntermSymbol
*
*
redeclaredSymOut
bool
*
nonConstIdxUsedOut
unsigned
int
*
maxConstIdxOut
ClipCullDistanceIdxSet
*
constIndicesOut
const
ImmutableString
&
targetStr
)
:
TIntermTraverser
(
true
false
false
)
mRedeclaredSym
(
redeclaredSymOut
)
mUseNonConstClipCullDistanceIndex
(
nonConstIdxUsedOut
)
mMaxConstClipCullDistanceIndex
(
maxConstIdxOut
)
mConstClipCullDistanceIndices
(
constIndicesOut
)
mTargetStr
(
targetStr
)
{
*
mRedeclaredSym
=
nullptr
;
*
mUseNonConstClipCullDistanceIndex
=
false
;
*
mMaxConstClipCullDistanceIndex
=
0
;
mConstClipCullDistanceIndices
-
>
reset
(
)
;
}
bool
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
node
)
override
{
const
TIntermSequence
&
sequence
=
*
(
node
-
>
getSequence
(
)
)
;
if
(
sequence
.
size
(
)
!
=
1
)
{
return
true
;
}
TIntermTyped
*
variable
=
sequence
.
front
(
)
-
>
getAsTyped
(
)
;
if
(
!
variable
-
>
getAsSymbolNode
(
)
|
|
variable
-
>
getAsSymbolNode
(
)
-
>
getName
(
)
!
=
mTargetStr
)
{
return
true
;
}
*
mRedeclaredSym
=
variable
-
>
getAsSymbolNode
(
)
;
return
true
;
}
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
{
TOperator
op
=
node
-
>
getOp
(
)
;
if
(
op
!
=
EOpIndexDirect
&
&
op
!
=
EOpIndexIndirect
)
{
return
true
;
}
TIntermTyped
*
left
=
node
-
>
getLeft
(
)
-
>
getAsTyped
(
)
;
if
(
!
left
)
{
return
true
;
}
ASSERT
(
op
=
=
EOpIndexDirect
|
|
op
=
=
EOpIndexIndirect
)
;
TIntermSymbol
*
clipCullDistance
=
left
-
>
getAsSymbolNode
(
)
;
if
(
!
clipCullDistance
)
{
return
true
;
}
if
(
clipCullDistance
-
>
getName
(
)
!
=
mTargetStr
)
{
return
true
;
}
const
TConstantUnion
*
constIdx
=
node
-
>
getRight
(
)
-
>
getConstantValue
(
)
;
if
(
!
constIdx
)
{
*
mUseNonConstClipCullDistanceIndex
=
true
;
}
else
{
unsigned
int
idx
=
0
;
switch
(
constIdx
-
>
getType
(
)
)
{
case
EbtInt
:
idx
=
constIdx
-
>
getIConst
(
)
;
break
;
case
EbtUInt
:
idx
=
constIdx
-
>
getUConst
(
)
;
break
;
case
EbtFloat
:
idx
=
static_cast
<
unsigned
int
>
(
constIdx
-
>
getFConst
(
)
)
;
break
;
case
EbtBool
:
idx
=
constIdx
-
>
getBConst
(
)
?
1
:
0
;
break
;
default
:
UNREACHABLE
(
)
;
break
;
}
ASSERT
(
idx
<
mConstClipCullDistanceIndices
-
>
size
(
)
)
;
mConstClipCullDistanceIndices
-
>
set
(
idx
)
;
*
mMaxConstClipCullDistanceIndex
=
std
:
:
max
(
*
mMaxConstClipCullDistanceIndex
idx
)
;
}
return
true
;
}
private
:
const
TIntermSymbol
*
*
mRedeclaredSym
;
bool
*
mUseNonConstClipCullDistanceIndex
;
unsigned
int
*
mMaxConstClipCullDistanceIndex
;
ClipCullDistanceIdxSet
*
mConstClipCullDistanceIndices
;
const
ImmutableString
mTargetStr
;
}
;
class
ReplaceVariableExceptOneTraverser
:
public
TIntermTraverser
{
public
:
ReplaceVariableExceptOneTraverser
(
const
TVariable
*
toBeReplaced
const
TIntermTyped
*
replacement
const
TIntermSymbol
*
exception
)
:
TIntermTraverser
(
true
false
false
)
mToBeReplaced
(
toBeReplaced
)
mException
(
exception
)
mReplacement
(
replacement
)
{
}
void
visitSymbol
(
TIntermSymbol
*
node
)
override
{
if
(
&
node
-
>
variable
(
)
=
=
mToBeReplaced
&
&
node
!
=
mException
)
{
queueReplacement
(
mReplacement
-
>
deepCopy
(
)
OriginalNode
:
:
IS_DROPPED
)
;
}
}
private
:
const
TVariable
*
const
mToBeReplaced
;
const
TIntermSymbol
*
const
mException
;
const
TIntermTyped
*
const
mReplacement
;
}
;
TIntermNode
*
simpleAssignFunc
(
const
unsigned
int
index
TIntermSymbol
*
leftSymbol
TIntermSymbol
*
rightSymbol
const
TIntermTyped
*
)
{
TIntermBinary
*
left
=
new
TIntermBinary
(
EOpIndexDirect
leftSymbol
-
>
deepCopy
(
)
CreateIndexNode
(
index
)
)
;
TIntermBinary
*
right
=
new
TIntermBinary
(
EOpIndexDirect
rightSymbol
-
>
deepCopy
(
)
CreateIndexNode
(
index
)
)
;
return
new
TIntermBinary
(
EOpAssign
left
right
)
;
}
TIntermNode
*
assignFuncWithEnableFlags
(
const
unsigned
int
index
TIntermSymbol
*
leftSymbol
TIntermSymbol
*
rightSymbol
const
TIntermTyped
*
enableFlags
)
{
TIntermConstantUnion
*
bitMask
=
CreateUIntNode
(
0x1
<
<
index
)
;
TIntermBinary
*
bitwiseAnd
=
new
TIntermBinary
(
EOpBitwiseAnd
enableFlags
-
>
deepCopy
(
)
bitMask
)
;
TIntermBinary
*
nonZero
=
new
TIntermBinary
(
EOpNotEqual
bitwiseAnd
CreateUIntNode
(
0
)
)
;
TIntermBinary
*
left
=
new
TIntermBinary
(
EOpIndexDirect
leftSymbol
-
>
deepCopy
(
)
CreateIndexNode
(
index
)
)
;
TIntermBinary
*
right
=
new
TIntermBinary
(
EOpIndexDirect
rightSymbol
-
>
deepCopy
(
)
CreateIndexNode
(
index
)
)
;
TIntermBinary
*
assignment
=
new
TIntermBinary
(
EOpAssign
left
right
)
;
TIntermBlock
*
trueBlock
=
new
TIntermBlock
(
)
;
trueBlock
-
>
appendStatement
(
assignment
)
;
TIntermBinary
*
zeroAssignment
=
new
TIntermBinary
(
EOpAssign
left
-
>
deepCopy
(
)
CreateFloatNode
(
0
)
)
;
TIntermBlock
*
falseBlock
=
new
TIntermBlock
(
)
;
falseBlock
-
>
appendStatement
(
zeroAssignment
)
;
return
new
TIntermIfElse
(
nonZero
trueBlock
falseBlock
)
;
}
class
ReplaceClipCullDistanceAssignments
:
angle
:
:
NonCopyable
{
public
:
ReplaceClipCullDistanceAssignments
(
TCompiler
*
compiler
TIntermBlock
*
root
TSymbolTable
*
symbolTable
const
TVariable
*
glClipCullDistanceVar
const
TIntermSymbol
*
redeclaredGlClipDistance
const
ImmutableString
&
angleVarName
)
:
mCompiler
(
compiler
)
mRoot
(
root
)
mSymbolTable
(
symbolTable
)
mGlVar
(
glClipCullDistanceVar
)
mRedeclaredGLVar
(
redeclaredGlClipDistance
)
mANGLEVarName
(
angleVarName
)
{
mEnabledDistances
=
0
;
}
unsigned
int
getEnabledClipCullDistance
(
const
bool
useNonConstIndex
const
unsigned
int
maxConstIndex
)
;
const
TVariable
*
declareANGLEVariable
(
)
;
bool
assignOriginalValueToANGLEVariable
(
const
GLenum
shaderType
)
;
bool
assignANGLEValueToOriginalVariable
(
const
GLenum
shaderType
const
bool
isRedeclared
const
TIntermTyped
*
enableFlags
const
ClipCullDistanceIdxSet
*
constIndices
AssignFunc
assignFunc
)
;
private
:
bool
assignOriginalValueToANGLEVariableImpl
(
)
;
bool
assignANGLEValueToOriginalVariableImpl
(
const
bool
isRedeclared
const
TIntermTyped
*
enableFlags
const
ClipCullDistanceIdxSet
*
constIndices
AssignFunc
assignFunc
)
;
TCompiler
*
mCompiler
;
TIntermBlock
*
mRoot
;
TSymbolTable
*
mSymbolTable
;
const
TVariable
*
mGlVar
;
const
TIntermSymbol
*
mRedeclaredGLVar
;
const
ImmutableString
mANGLEVarName
;
unsigned
int
mEnabledDistances
;
const
TVariable
*
mANGLEVar
;
}
;
unsigned
int
ReplaceClipCullDistanceAssignments
:
:
getEnabledClipCullDistance
(
const
bool
useNonConstIndex
const
unsigned
int
maxConstIndex
)
{
if
(
mRedeclaredGLVar
)
{
mEnabledDistances
=
mRedeclaredGLVar
-
>
getType
(
)
.
getOutermostArraySize
(
)
;
}
else
if
(
!
useNonConstIndex
)
{
ASSERT
(
maxConstIndex
<
mGlVar
-
>
getType
(
)
.
getOutermostArraySize
(
)
)
;
mEnabledDistances
=
maxConstIndex
+
1
;
}
return
mEnabledDistances
;
}
const
TVariable
*
ReplaceClipCullDistanceAssignments
:
:
declareANGLEVariable
(
)
{
ASSERT
(
mEnabledDistances
>
0
)
;
TType
*
clipCullDistanceType
=
new
TType
(
EbtFloat
EbpMedium
EvqGlobal
1
)
;
clipCullDistanceType
-
>
makeArray
(
mEnabledDistances
)
;
mANGLEVar
=
new
TVariable
(
mSymbolTable
mANGLEVarName
clipCullDistanceType
SymbolType
:
:
AngleInternal
)
;
TIntermSymbol
*
clipCullDistanceDeclarator
=
new
TIntermSymbol
(
mANGLEVar
)
;
TIntermDeclaration
*
clipCullDistanceDecl
=
new
TIntermDeclaration
;
clipCullDistanceDecl
-
>
appendDeclarator
(
clipCullDistanceDeclarator
)
;
mRoot
-
>
insertStatement
(
0
clipCullDistanceDecl
)
;
return
mANGLEVar
;
}
bool
ReplaceClipCullDistanceAssignments
:
:
assignOriginalValueToANGLEVariableImpl
(
)
{
ASSERT
(
mEnabledDistances
>
0
)
;
TIntermBlock
*
readBlock
=
new
TIntermBlock
;
TIntermSymbol
*
glClipCullDistanceSymbol
=
new
TIntermSymbol
(
mGlVar
)
;
TIntermSymbol
*
clipCullDistanceSymbol
=
new
TIntermSymbol
(
mANGLEVar
)
;
for
(
unsigned
int
i
=
0
;
i
<
mEnabledDistances
;
i
+
+
)
{
readBlock
-
>
appendStatement
(
simpleAssignFunc
(
i
glClipCullDistanceSymbol
clipCullDistanceSymbol
nullptr
)
)
;
}
return
RunAtTheBeginningOfShader
(
mCompiler
mRoot
readBlock
)
;
}
bool
ReplaceClipCullDistanceAssignments
:
:
assignANGLEValueToOriginalVariableImpl
(
const
bool
isRedeclared
const
TIntermTyped
*
enableFlags
const
ClipCullDistanceIdxSet
*
constIndices
AssignFunc
assignFunc
)
{
ASSERT
(
mEnabledDistances
>
0
)
;
TIntermBlock
*
assignBlock
=
new
TIntermBlock
;
TIntermSymbol
*
glClipCullDistanceSymbol
=
new
TIntermSymbol
(
mGlVar
)
;
TIntermSymbol
*
clipCullDistanceSymbol
=
new
TIntermSymbol
(
mANGLEVar
)
;
if
(
isRedeclared
|
|
!
constIndices
)
{
for
(
unsigned
int
i
=
0
;
i
<
mEnabledDistances
;
+
+
i
)
{
assignBlock
-
>
appendStatement
(
assignFunc
(
i
glClipCullDistanceSymbol
clipCullDistanceSymbol
enableFlags
)
)
;
}
}
else
{
for
(
unsigned
int
i
=
0
;
i
<
mEnabledDistances
;
+
+
i
)
{
if
(
constIndices
-
>
test
(
i
)
)
{
assignBlock
-
>
appendStatement
(
assignFunc
(
i
glClipCullDistanceSymbol
clipCullDistanceSymbol
enableFlags
)
)
;
}
else
{
TIntermBinary
*
left
=
new
TIntermBinary
(
EOpIndexDirect
glClipCullDistanceSymbol
-
>
deepCopy
(
)
CreateIndexNode
(
i
)
)
;
TIntermBinary
*
zeroAssignment
=
new
TIntermBinary
(
EOpAssign
left
CreateFloatNode
(
0
)
)
;
assignBlock
-
>
appendStatement
(
zeroAssignment
)
;
}
}
}
return
RunAtTheEndOfShader
(
mCompiler
mRoot
assignBlock
mSymbolTable
)
;
}
ANGLE_NO_DISCARD
bool
ReplaceClipCullDistanceAssignments
:
:
assignOriginalValueToANGLEVariable
(
const
GLenum
shaderType
)
{
switch
(
shaderType
)
{
case
GL_VERTEX_SHADER
:
break
;
case
GL_FRAGMENT_SHADER
:
{
if
(
!
assignOriginalValueToANGLEVariableImpl
(
)
)
{
return
false
;
}
break
;
}
default
:
{
UNREACHABLE
(
)
;
return
false
;
}
}
return
true
;
}
ANGLE_NO_DISCARD
bool
ReplaceClipCullDistanceAssignments
:
:
assignANGLEValueToOriginalVariable
(
const
GLenum
shaderType
const
bool
isRedeclared
const
TIntermTyped
*
enableFlags
const
ClipCullDistanceIdxSet
*
constIndices
AssignFunc
assignFunc
)
{
switch
(
shaderType
)
{
case
GL_VERTEX_SHADER
:
{
if
(
!
assignANGLEValueToOriginalVariableImpl
(
isRedeclared
enableFlags
constIndices
assignFuncWithEnableFlags
)
)
{
return
false
;
}
break
;
}
case
GL_FRAGMENT_SHADER
:
break
;
default
:
{
UNREACHABLE
(
)
;
return
false
;
}
}
return
true
;
}
}
ANGLE_NO_DISCARD
bool
ReplaceClipDistanceAssignments
(
TCompiler
*
compiler
TIntermBlock
*
root
TSymbolTable
*
symbolTable
const
GLenum
shaderType
const
TIntermTyped
*
clipDistanceEnableFlags
)
{
ImmutableString
glClipDistanceName
(
"
gl_ClipDistance
"
)
;
ClipCullDistanceIdxSet
constIndices
;
bool
useNonConstIndex
=
false
;
const
TIntermSymbol
*
redeclaredGlClipDistance
=
nullptr
;
unsigned
int
maxConstIndex
=
0
;
GLClipCullDistanceReferenceTraverser
indexTraverser
(
&
redeclaredGlClipDistance
&
useNonConstIndex
&
maxConstIndex
&
constIndices
glClipDistanceName
)
;
root
-
>
traverse
(
&
indexTraverser
)
;
if
(
!
useNonConstIndex
&
&
constIndices
.
none
(
)
)
{
return
true
;
}
const
TVariable
*
glClipDistanceVar
=
nullptr
;
if
(
redeclaredGlClipDistance
)
{
glClipDistanceVar
=
&
redeclaredGlClipDistance
-
>
variable
(
)
;
}
else
{
glClipDistanceVar
=
static_cast
<
const
TVariable
*
>
(
symbolTable
-
>
findBuiltIn
(
glClipDistanceName
300
)
)
;
}
if
(
!
glClipDistanceVar
)
{
return
false
;
}
ReplaceClipCullDistanceAssignments
replacementUtils
(
compiler
root
symbolTable
glClipDistanceVar
redeclaredGlClipDistance
ImmutableString
(
"
ANGLEClipDistance
"
)
)
;
unsigned
int
enabledClipDistances
=
replacementUtils
.
getEnabledClipCullDistance
(
useNonConstIndex
maxConstIndex
)
;
if
(
!
enabledClipDistances
)
{
return
false
;
}
const
TVariable
*
clipDistanceVar
=
replacementUtils
.
declareANGLEVariable
(
)
;
ReplaceVariableExceptOneTraverser
replaceTraverser
(
glClipDistanceVar
new
TIntermSymbol
(
clipDistanceVar
)
redeclaredGlClipDistance
)
;
root
-
>
traverse
(
&
replaceTraverser
)
;
if
(
!
replaceTraverser
.
updateTree
(
compiler
root
)
)
{
return
false
;
}
if
(
!
replacementUtils
.
assignOriginalValueToANGLEVariable
(
shaderType
)
)
{
return
false
;
}
const
bool
isRedeclared
=
(
redeclaredGlClipDistance
!
=
nullptr
)
;
if
(
!
replacementUtils
.
assignANGLEValueToOriginalVariable
(
shaderType
isRedeclared
clipDistanceEnableFlags
&
constIndices
assignFuncWithEnableFlags
)
)
{
return
false
;
}
return
true
;
}
ANGLE_NO_DISCARD
bool
ReplaceCullDistanceAssignments
(
TCompiler
*
compiler
TIntermBlock
*
root
TSymbolTable
*
symbolTable
const
GLenum
shaderType
)
{
ImmutableString
glCullDistanceName
(
"
gl_CullDistance
"
)
;
ClipCullDistanceIdxSet
constIndices
;
bool
useNonConstIndex
=
false
;
const
TIntermSymbol
*
redeclaredGLCullDistance
=
nullptr
;
unsigned
int
maxConstIndex
=
0
;
GLClipCullDistanceReferenceTraverser
indexTraverser
(
&
redeclaredGLCullDistance
&
useNonConstIndex
&
maxConstIndex
&
constIndices
glCullDistanceName
)
;
root
-
>
traverse
(
&
indexTraverser
)
;
if
(
!
useNonConstIndex
)
{
return
true
;
}
const
TVariable
*
glCullDistanceVar
=
nullptr
;
if
(
redeclaredGLCullDistance
)
{
glCullDistanceVar
=
&
redeclaredGLCullDistance
-
>
variable
(
)
;
}
else
{
glCullDistanceVar
=
static_cast
<
const
TVariable
*
>
(
symbolTable
-
>
findBuiltIn
(
glCullDistanceName
300
)
)
;
}
if
(
!
glCullDistanceVar
)
{
return
false
;
}
ReplaceClipCullDistanceAssignments
replacementUtils
(
compiler
root
symbolTable
glCullDistanceVar
redeclaredGLCullDistance
ImmutableString
(
"
ANGLECullDistance
"
)
)
;
unsigned
int
enabledCullDistances
=
replacementUtils
.
getEnabledClipCullDistance
(
useNonConstIndex
maxConstIndex
)
;
if
(
!
enabledCullDistances
)
{
return
false
;
}
const
TVariable
*
cullDistanceVar
=
replacementUtils
.
declareANGLEVariable
(
)
;
ReplaceVariableExceptOneTraverser
replaceTraverser
(
glCullDistanceVar
new
TIntermSymbol
(
cullDistanceVar
)
redeclaredGLCullDistance
)
;
root
-
>
traverse
(
&
replaceTraverser
)
;
if
(
!
replaceTraverser
.
updateTree
(
compiler
root
)
)
{
return
false
;
}
if
(
!
replacementUtils
.
assignOriginalValueToANGLEVariable
(
shaderType
)
)
{
return
false
;
}
const
bool
isRedeclared
=
(
redeclaredGLCullDistance
!
=
nullptr
)
;
if
(
!
replacementUtils
.
assignANGLEValueToOriginalVariable
(
shaderType
isRedeclared
nullptr
&
constIndices
simpleAssignFunc
)
)
{
return
false
;
}
return
true
;
}
}
