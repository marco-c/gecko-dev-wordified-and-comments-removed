#
ifndef
COMPILER_TRANSLATOR_TRANSLATORMETALDIRECT_INTERMREBUILD_H_
#
define
COMPILER_TRANSLATOR_TRANSLATORMETALDIRECT_INTERMREBUILD_H_
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
NodeType
.
h
"
namespace
sh
{
class
TIntermRebuild
:
angle
:
:
NonCopyable
{
enum
class
Action
{
ReplaceSingle
ReplaceMulti
Drop
Fail
}
;
public
:
struct
Fail
{
}
;
enum
VisitBits
:
size_t
{
Empty
=
0u
Children
=
1u
<
<
0u
Post
=
1u
<
<
1u
ChildrenRequiresSame
=
1u
<
<
2u
PostRequiresSame
=
1u
<
<
3u
RequireSame
=
ChildrenRequiresSame
|
PostRequiresSame
Neither
=
Empty
Both
=
Children
|
Post
BothWhenSame
=
Both
|
RequireSame
}
;
private
:
struct
NodeStackGuard
;
template
<
typename
T
>
struct
ConsList
{
T
value
;
ConsList
<
T
>
*
tail
;
}
;
class
BaseResult
{
BaseResult
(
const
BaseResult
&
)
=
delete
;
BaseResult
&
operator
=
(
const
BaseResult
&
)
=
delete
;
public
:
BaseResult
(
BaseResult
&
&
other
)
=
default
;
BaseResult
(
BaseResult
&
other
)
;
BaseResult
(
TIntermNode
&
node
VisitBits
visit
)
;
BaseResult
(
TIntermNode
*
node
VisitBits
visit
)
;
BaseResult
(
std
:
:
nullptr_t
)
;
BaseResult
(
Fail
)
;
BaseResult
(
std
:
:
vector
<
TIntermNode
*
>
&
&
nodes
)
;
void
moveAssignImpl
(
BaseResult
&
other
)
;
static
BaseResult
Multi
(
std
:
:
vector
<
TIntermNode
*
>
&
&
nodes
)
;
template
<
typename
Iter
>
static
BaseResult
Multi
(
Iter
nodesBegin
Iter
nodesEnd
)
{
std
:
:
vector
<
TIntermNode
*
>
nodes
;
for
(
Iter
nodesCurr
=
nodesBegin
;
nodesCurr
!
=
nodesEnd
;
+
+
nodesCurr
)
{
nodes
.
push_back
(
*
nodesCurr
)
;
}
return
std
:
:
move
(
nodes
)
;
}
bool
isFail
(
)
const
;
bool
isDrop
(
)
const
;
TIntermNode
*
single
(
)
const
;
const
std
:
:
vector
<
TIntermNode
*
>
*
multi
(
)
const
;
public
:
Action
mAction
;
VisitBits
mVisit
;
TIntermNode
*
mSingle
;
std
:
:
vector
<
TIntermNode
*
>
mMulti
;
}
;
public
:
class
PreResult
:
private
BaseResult
{
friend
class
TIntermRebuild
;
public
:
PreResult
(
PreResult
&
&
other
)
;
PreResult
(
TIntermNode
&
node
VisitBits
visit
=
VisitBits
:
:
BothWhenSame
)
;
PreResult
(
TIntermNode
*
node
VisitBits
visit
=
VisitBits
:
:
BothWhenSame
)
;
PreResult
(
std
:
:
nullptr_t
)
;
PreResult
(
Fail
)
;
void
operator
=
(
PreResult
&
&
other
)
;
static
PreResult
Multi
(
std
:
:
vector
<
TIntermNode
*
>
&
&
nodes
)
{
return
BaseResult
:
:
Multi
(
std
:
:
move
(
nodes
)
)
;
}
template
<
typename
Iter
>
static
PreResult
Multi
(
Iter
nodesBegin
Iter
nodesEnd
)
{
return
BaseResult
:
:
Multi
(
nodesBegin
nodesEnd
)
;
}
using
BaseResult
:
:
isDrop
;
using
BaseResult
:
:
isFail
;
using
BaseResult
:
:
multi
;
using
BaseResult
:
:
single
;
private
:
PreResult
(
BaseResult
&
&
other
)
;
}
;
class
PostResult
:
private
BaseResult
{
friend
class
TIntermRebuild
;
public
:
PostResult
(
PostResult
&
&
other
)
;
PostResult
(
TIntermNode
&
node
)
;
PostResult
(
TIntermNode
*
node
)
;
PostResult
(
std
:
:
nullptr_t
)
;
PostResult
(
Fail
)
;
void
operator
=
(
PostResult
&
&
other
)
;
static
PostResult
Multi
(
std
:
:
vector
<
TIntermNode
*
>
&
&
nodes
)
{
return
BaseResult
:
:
Multi
(
std
:
:
move
(
nodes
)
)
;
}
template
<
typename
Iter
>
static
PostResult
Multi
(
Iter
nodesBegin
Iter
nodesEnd
)
{
return
BaseResult
:
:
Multi
(
nodesBegin
nodesEnd
)
;
}
using
BaseResult
:
:
isDrop
;
using
BaseResult
:
:
isFail
;
using
BaseResult
:
:
multi
;
using
BaseResult
:
:
single
;
private
:
PostResult
(
BaseResult
&
&
other
)
;
}
;
public
:
TIntermRebuild
(
TCompiler
&
compiler
bool
preVisit
bool
postVisit
)
;
virtual
~
TIntermRebuild
(
)
;
[
[
nodiscard
]
]
bool
rebuildRoot
(
TIntermBlock
&
root
)
;
protected
:
virtual
PreResult
visitSymbolPre
(
TIntermSymbol
&
node
)
;
virtual
PreResult
visitConstantUnionPre
(
TIntermConstantUnion
&
node
)
;
virtual
PreResult
visitFunctionPrototypePre
(
TIntermFunctionPrototype
&
node
)
;
virtual
PreResult
visitPreprocessorDirectivePre
(
TIntermPreprocessorDirective
&
node
)
;
virtual
PreResult
visitUnaryPre
(
TIntermUnary
&
node
)
;
virtual
PreResult
visitBinaryPre
(
TIntermBinary
&
node
)
;
virtual
PreResult
visitTernaryPre
(
TIntermTernary
&
node
)
;
virtual
PreResult
visitSwizzlePre
(
TIntermSwizzle
&
node
)
;
virtual
PreResult
visitIfElsePre
(
TIntermIfElse
&
node
)
;
virtual
PreResult
visitSwitchPre
(
TIntermSwitch
&
node
)
;
virtual
PreResult
visitCasePre
(
TIntermCase
&
node
)
;
virtual
PreResult
visitLoopPre
(
TIntermLoop
&
node
)
;
virtual
PreResult
visitBranchPre
(
TIntermBranch
&
node
)
;
virtual
PreResult
visitDeclarationPre
(
TIntermDeclaration
&
node
)
;
virtual
PreResult
visitBlockPre
(
TIntermBlock
&
node
)
;
virtual
PreResult
visitAggregatePre
(
TIntermAggregate
&
node
)
;
virtual
PreResult
visitFunctionDefinitionPre
(
TIntermFunctionDefinition
&
node
)
;
virtual
PreResult
visitGlobalQualifierDeclarationPre
(
TIntermGlobalQualifierDeclaration
&
node
)
;
virtual
PostResult
visitSymbolPost
(
TIntermSymbol
&
node
)
;
virtual
PostResult
visitConstantUnionPost
(
TIntermConstantUnion
&
node
)
;
virtual
PostResult
visitFunctionPrototypePost
(
TIntermFunctionPrototype
&
node
)
;
virtual
PostResult
visitPreprocessorDirectivePost
(
TIntermPreprocessorDirective
&
node
)
;
virtual
PostResult
visitUnaryPost
(
TIntermUnary
&
node
)
;
virtual
PostResult
visitBinaryPost
(
TIntermBinary
&
node
)
;
virtual
PostResult
visitTernaryPost
(
TIntermTernary
&
node
)
;
virtual
PostResult
visitSwizzlePost
(
TIntermSwizzle
&
node
)
;
virtual
PostResult
visitIfElsePost
(
TIntermIfElse
&
node
)
;
virtual
PostResult
visitSwitchPost
(
TIntermSwitch
&
node
)
;
virtual
PostResult
visitCasePost
(
TIntermCase
&
node
)
;
virtual
PostResult
visitLoopPost
(
TIntermLoop
&
node
)
;
virtual
PostResult
visitBranchPost
(
TIntermBranch
&
node
)
;
virtual
PostResult
visitDeclarationPost
(
TIntermDeclaration
&
node
)
;
virtual
PostResult
visitBlockPost
(
TIntermBlock
&
node
)
;
virtual
PostResult
visitAggregatePost
(
TIntermAggregate
&
node
)
;
virtual
PostResult
visitFunctionDefinitionPost
(
TIntermFunctionDefinition
&
node
)
;
virtual
PostResult
visitGlobalQualifierDeclarationPost
(
TIntermGlobalQualifierDeclaration
&
node
)
;
[
[
nodiscard
]
]
PostResult
rebuild
(
TIntermNode
&
node
)
;
[
[
nodiscard
]
]
bool
rebuildInPlace
(
TIntermAggregate
&
node
)
;
[
[
nodiscard
]
]
bool
rebuildInPlace
(
TIntermBlock
&
node
)
;
[
[
nodiscard
]
]
bool
rebuildInPlace
(
TIntermDeclaration
&
node
)
;
const
TFunction
*
getParentFunction
(
)
const
;
TIntermNode
*
getParentNode
(
size_t
offset
=
0
)
const
;
private
:
template
<
typename
Node
>
[
[
nodiscard
]
]
bool
rebuildInPlaceImpl
(
Node
&
node
)
;
PostResult
traverseAny
(
TIntermNode
&
node
)
;
template
<
typename
Node
>
Node
*
traverseAnyAs
(
TIntermNode
&
node
)
;
template
<
typename
Node
>
bool
traverseAnyAs
(
TIntermNode
&
node
Node
*
&
out
)
;
PreResult
traversePre
(
TIntermNode
&
originalNode
)
;
TIntermNode
*
traverseChildren
(
NodeType
currNodeType
const
TIntermNode
&
originalNode
TIntermNode
&
currNode
VisitBits
visit
)
;
PostResult
traversePost
(
NodeType
nodeType
const
TIntermNode
&
originalNode
TIntermNode
&
currNode
VisitBits
visit
)
;
bool
traverseAggregateBaseChildren
(
TIntermAggregateBase
&
node
)
;
TIntermNode
*
traverseUnaryChildren
(
TIntermUnary
&
node
)
;
TIntermNode
*
traverseBinaryChildren
(
TIntermBinary
&
node
)
;
TIntermNode
*
traverseTernaryChildren
(
TIntermTernary
&
node
)
;
TIntermNode
*
traverseSwizzleChildren
(
TIntermSwizzle
&
node
)
;
TIntermNode
*
traverseIfElseChildren
(
TIntermIfElse
&
node
)
;
TIntermNode
*
traverseSwitchChildren
(
TIntermSwitch
&
node
)
;
TIntermNode
*
traverseCaseChildren
(
TIntermCase
&
node
)
;
TIntermNode
*
traverseLoopChildren
(
TIntermLoop
&
node
)
;
TIntermNode
*
traverseBranchChildren
(
TIntermBranch
&
node
)
;
TIntermNode
*
traverseDeclarationChildren
(
TIntermDeclaration
&
node
)
;
TIntermNode
*
traverseBlockChildren
(
TIntermBlock
&
node
)
;
TIntermNode
*
traverseAggregateChildren
(
TIntermAggregate
&
node
)
;
TIntermNode
*
traverseFunctionDefinitionChildren
(
TIntermFunctionDefinition
&
node
)
;
TIntermNode
*
traverseGlobalQualifierDeclarationChildren
(
TIntermGlobalQualifierDeclaration
&
node
)
;
protected
:
TCompiler
&
mCompiler
;
TSymbolTable
&
mSymbolTable
;
const
TFunction
*
mParentFunc
=
nullptr
;
GetNodeType
getNodeType
;
private
:
ConsList
<
TIntermNode
*
>
mNodeStack
{
nullptr
nullptr
}
;
bool
mPreVisit
;
bool
mPostVisit
;
}
;
}
#
endif
