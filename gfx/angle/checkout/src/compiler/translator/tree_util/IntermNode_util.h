#
ifndef
COMPILER_TRANSLATOR_INTERMNODEUTIL_H_
#
define
COMPILER_TRANSLATOR_INTERMNODEUTIL_H_
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
FindFunction
.
h
"
namespace
sh
{
class
TSymbolTable
;
class
TVariable
;
TIntermFunctionPrototype
*
CreateInternalFunctionPrototypeNode
(
const
TFunction
&
func
)
;
TIntermFunctionDefinition
*
CreateInternalFunctionDefinitionNode
(
const
TFunction
&
func
TIntermBlock
*
functionBody
)
;
TIntermTyped
*
CreateZeroNode
(
const
TType
&
type
)
;
TIntermConstantUnion
*
CreateFloatNode
(
float
value
TPrecision
precision
)
;
TIntermConstantUnion
*
CreateVecNode
(
const
float
values
[
]
unsigned
int
vecSize
TPrecision
precision
)
;
TIntermConstantUnion
*
CreateUVecNode
(
const
unsigned
int
values
[
]
unsigned
int
vecSize
TPrecision
precision
)
;
TIntermConstantUnion
*
CreateIndexNode
(
int
index
)
;
TIntermConstantUnion
*
CreateUIntNode
(
unsigned
int
value
)
;
TIntermConstantUnion
*
CreateBoolNode
(
bool
value
)
;
TVariable
*
CreateTempVariable
(
TSymbolTable
*
symbolTable
const
TType
*
type
)
;
TVariable
*
CreateTempVariable
(
TSymbolTable
*
symbolTable
const
TType
*
type
TQualifier
qualifier
)
;
TIntermSymbol
*
CreateTempSymbolNode
(
const
TVariable
*
tempVariable
)
;
TIntermDeclaration
*
CreateTempDeclarationNode
(
const
TVariable
*
tempVariable
)
;
TIntermDeclaration
*
CreateTempInitDeclarationNode
(
const
TVariable
*
tempVariable
TIntermTyped
*
initializer
)
;
TIntermBinary
*
CreateTempAssignmentNode
(
const
TVariable
*
tempVariable
TIntermTyped
*
rightNode
)
;
TVariable
*
DeclareTempVariable
(
TSymbolTable
*
symbolTable
const
TType
*
type
TQualifier
qualifier
TIntermDeclaration
*
*
declarationOut
)
;
TVariable
*
DeclareTempVariable
(
TSymbolTable
*
symbolTable
TIntermTyped
*
initializer
TQualifier
qualifier
TIntermDeclaration
*
*
declarationOut
)
;
std
:
:
pair
<
const
TVariable
*
const
TVariable
*
>
DeclareStructure
(
TIntermBlock
*
root
TSymbolTable
*
symbolTable
TFieldList
*
fieldList
TQualifier
qualifier
const
TMemoryQualifier
&
memoryQualifier
uint32_t
arraySize
const
ImmutableString
&
structTypeName
const
ImmutableString
*
structInstanceName
)
;
const
TVariable
*
DeclareInterfaceBlock
(
TIntermBlock
*
root
TSymbolTable
*
symbolTable
TFieldList
*
fieldList
TQualifier
qualifier
const
TLayoutQualifier
&
layoutQualifier
const
TMemoryQualifier
&
memoryQualifier
uint32_t
arraySize
const
ImmutableString
&
blockTypeName
const
ImmutableString
&
blockVariableName
)
;
TIntermBlock
*
EnsureBlock
(
TIntermNode
*
node
)
;
TIntermSymbol
*
ReferenceGlobalVariable
(
const
ImmutableString
&
name
const
TSymbolTable
&
symbolTable
)
;
TIntermSymbol
*
ReferenceBuiltInVariable
(
const
ImmutableString
&
name
const
TSymbolTable
&
symbolTable
int
shaderVersion
)
;
TIntermTyped
*
CreateBuiltInFunctionCallNode
(
const
char
*
name
TIntermSequence
*
arguments
const
TSymbolTable
&
symbolTable
int
shaderVersion
)
;
TIntermTyped
*
CreateBuiltInFunctionCallNode
(
const
char
*
name
const
std
:
:
initializer_list
<
TIntermNode
*
>
&
arguments
const
TSymbolTable
&
symbolTable
int
shaderVersion
)
;
TIntermTyped
*
CreateBuiltInUnaryFunctionCallNode
(
const
char
*
name
TIntermTyped
*
argument
const
TSymbolTable
&
symbolTable
int
shaderVersion
)
;
int
GetESSLOrGLSLVersion
(
ShShaderSpec
spec
int
esslVersion
int
glslVersion
)
;
inline
void
GetSwizzleIndex
(
TVector
<
int
>
*
indexOut
)
{
}
template
<
typename
T
typename
.
.
.
ArgsT
>
void
GetSwizzleIndex
(
TVector
<
int
>
*
indexOut
T
arg
ArgsT
.
.
.
args
)
{
indexOut
-
>
push_back
(
arg
)
;
GetSwizzleIndex
(
indexOut
args
.
.
.
)
;
}
template
<
typename
.
.
.
ArgsT
>
TIntermSwizzle
*
CreateSwizzle
(
TIntermTyped
*
reference
ArgsT
.
.
.
args
)
{
TVector
<
int
>
swizzleIndex
;
GetSwizzleIndex
(
&
swizzleIndex
args
.
.
.
)
;
return
new
TIntermSwizzle
(
reference
swizzleIndex
)
;
}
bool
EndsInBranch
(
TIntermBlock
*
block
)
;
}
#
endif
