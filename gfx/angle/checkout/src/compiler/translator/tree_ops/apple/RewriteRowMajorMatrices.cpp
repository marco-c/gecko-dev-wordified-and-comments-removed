#
include
"
compiler
/
translator
/
tree_ops
/
apple
/
RewriteRowMajorMatrices
.
h
"
#
include
"
compiler
/
translator
/
Compiler
.
h
"
#
include
"
compiler
/
translator
/
ImmutableStringBuilder
.
h
"
#
include
"
compiler
/
translator
/
StaticType
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
ReplaceVariable
.
h
"
namespace
sh
{
namespace
{
struct
StructConversionData
{
TStructure
*
convertedStruct
=
nullptr
;
TFunction
*
copyFromOriginal
=
nullptr
;
TFunction
*
copyToOriginal
=
nullptr
;
}
;
bool
DoesFieldContainRowMajorMatrix
(
const
TField
*
field
bool
isBlockRowMajor
)
{
TLayoutMatrixPacking
matrixPacking
=
field
-
>
type
(
)
-
>
getLayoutQualifier
(
)
.
matrixPacking
;
if
(
matrixPacking
=
=
EmpColumnMajor
|
|
(
matrixPacking
=
=
EmpUnspecified
&
&
!
isBlockRowMajor
)
)
{
return
false
;
}
const
TType
*
type
=
field
-
>
type
(
)
;
return
type
-
>
isMatrix
(
)
|
|
type
-
>
isStructureContainingMatrices
(
)
;
}
TField
*
DuplicateField
(
const
TField
*
field
)
{
return
new
TField
(
new
TType
(
*
field
-
>
type
(
)
)
field
-
>
name
(
)
field
-
>
line
(
)
field
-
>
symbolType
(
)
)
;
}
void
SetColumnMajor
(
TType
*
type
)
{
TLayoutQualifier
layoutQualifier
=
type
-
>
getLayoutQualifier
(
)
;
layoutQualifier
.
matrixPacking
=
EmpColumnMajor
;
type
-
>
setLayoutQualifier
(
layoutQualifier
)
;
}
TType
*
TransposeMatrixType
(
const
TType
*
type
)
{
TType
*
newType
=
new
TType
(
*
type
)
;
SetColumnMajor
(
newType
)
;
newType
-
>
setPrimarySize
(
type
-
>
getRows
(
)
)
;
newType
-
>
setSecondarySize
(
type
-
>
getCols
(
)
)
;
return
newType
;
}
void
CopyArraySizes
(
const
TType
*
from
TType
*
to
)
{
if
(
from
-
>
isArray
(
)
)
{
to
-
>
makeArrays
(
from
-
>
getArraySizes
(
)
)
;
}
}
bool
IsIndexNode
(
TIntermNode
*
node
TIntermNode
*
child
)
{
if
(
node
-
>
getAsSwizzleNode
(
)
)
{
return
true
;
}
TIntermBinary
*
binaryNode
=
node
-
>
getAsBinaryNode
(
)
;
if
(
binaryNode
=
=
nullptr
|
|
child
!
=
binaryNode
-
>
getLeft
(
)
)
{
return
false
;
}
TOperator
op
=
binaryNode
-
>
getOp
(
)
;
return
op
=
=
EOpIndexDirect
|
|
op
=
=
EOpIndexDirectInterfaceBlock
|
|
op
=
=
EOpIndexDirectStruct
|
|
op
=
=
EOpIndexIndirect
;
}
TIntermSymbol
*
CopyToTempVariable
(
TSymbolTable
*
symbolTable
TIntermTyped
*
node
TIntermSequence
*
prependStatements
)
{
TVariable
*
temp
=
CreateTempVariable
(
symbolTable
&
node
-
>
getType
(
)
)
;
TIntermDeclaration
*
tempDecl
=
CreateTempInitDeclarationNode
(
temp
node
)
;
prependStatements
-
>
push_back
(
tempDecl
)
;
return
new
TIntermSymbol
(
temp
)
;
}
TIntermAggregate
*
CreateStructCopyCall
(
const
TFunction
*
copyFunc
TIntermTyped
*
expression
)
{
TIntermSequence
args
=
{
expression
}
;
return
TIntermAggregate
:
:
CreateFunctionCall
(
*
copyFunc
&
args
)
;
}
TIntermTyped
*
CreateTransposeCall
(
TSymbolTable
*
symbolTable
TIntermTyped
*
expression
)
{
TIntermSequence
args
=
{
expression
}
;
return
CreateBuiltInFunctionCallNode
(
"
transpose
"
&
args
*
symbolTable
300
)
;
}
TOperator
GetIndex
(
TSymbolTable
*
symbolTable
TIntermNode
*
node
TIntermSequence
*
indices
TIntermSequence
*
prependStatements
)
{
TIntermSwizzle
*
asSwizzle
=
node
-
>
getAsSwizzleNode
(
)
;
if
(
asSwizzle
)
{
for
(
int
channel
:
asSwizzle
-
>
getSwizzleOffsets
(
)
)
{
indices
-
>
push_back
(
CreateIndexNode
(
channel
)
)
;
}
return
EOpIndexDirect
;
}
TIntermBinary
*
binaryNode
=
node
-
>
getAsBinaryNode
(
)
;
ASSERT
(
binaryNode
)
;
TOperator
op
=
binaryNode
-
>
getOp
(
)
;
ASSERT
(
op
=
=
EOpIndexDirect
|
|
op
=
=
EOpIndexDirectInterfaceBlock
|
|
op
=
=
EOpIndexDirectStruct
|
|
op
=
=
EOpIndexIndirect
)
;
TIntermTyped
*
rhs
=
binaryNode
-
>
getRight
(
)
-
>
deepCopy
(
)
;
if
(
rhs
-
>
getAsConstantUnion
(
)
=
=
nullptr
)
{
rhs
=
CopyToTempVariable
(
symbolTable
rhs
prependStatements
)
;
}
indices
-
>
push_back
(
rhs
)
;
return
op
;
}
TIntermTyped
*
ReplicateIndexNode
(
TSymbolTable
*
symbolTable
TIntermNode
*
node
TIntermTyped
*
lhs
TIntermSequence
*
indices
)
{
TIntermSwizzle
*
asSwizzle
=
node
-
>
getAsSwizzleNode
(
)
;
if
(
asSwizzle
)
{
return
new
TIntermSwizzle
(
lhs
asSwizzle
-
>
getSwizzleOffsets
(
)
)
;
}
TIntermBinary
*
binaryNode
=
node
-
>
getAsBinaryNode
(
)
;
ASSERT
(
binaryNode
)
;
ASSERT
(
indices
-
>
size
(
)
=
=
1
)
;
TIntermTyped
*
rhs
=
indices
-
>
front
(
)
-
>
getAsTyped
(
)
;
return
new
TIntermBinary
(
binaryNode
-
>
getOp
(
)
lhs
rhs
)
;
}
TOperator
GetIndexOp
(
TIntermNode
*
node
)
{
return
node
-
>
getAsConstantUnion
(
)
?
EOpIndexDirect
:
EOpIndexIndirect
;
}
bool
IsConvertedField
(
TIntermTyped
*
indexNode
const
angle
:
:
HashMap
<
const
TField
*
bool
>
&
convertedFields
)
{
TIntermBinary
*
asBinary
=
indexNode
-
>
getAsBinaryNode
(
)
;
if
(
asBinary
=
=
nullptr
)
{
return
false
;
}
if
(
asBinary
-
>
getOp
(
)
!
=
EOpIndexDirectInterfaceBlock
)
{
return
false
;
}
const
TInterfaceBlock
*
interfaceBlock
=
asBinary
-
>
getLeft
(
)
-
>
getType
(
)
.
getInterfaceBlock
(
)
;
ASSERT
(
interfaceBlock
)
;
TIntermConstantUnion
*
fieldIndexNode
=
asBinary
-
>
getRight
(
)
-
>
getAsConstantUnion
(
)
;
ASSERT
(
fieldIndexNode
)
;
ASSERT
(
fieldIndexNode
-
>
getConstantValue
(
)
!
=
nullptr
)
;
int
fieldIndex
=
fieldIndexNode
-
>
getConstantValue
(
)
-
>
getIConst
(
)
;
const
TField
*
field
=
interfaceBlock
-
>
fields
(
)
[
fieldIndex
]
;
return
convertedFields
.
count
(
field
)
>
0
&
&
convertedFields
.
at
(
field
)
;
}
class
TransformArrayHelper
{
public
:
TransformArrayHelper
(
TIntermTyped
*
baseExpression
)
:
mBaseExpression
(
baseExpression
)
mBaseExpressionType
(
baseExpression
-
>
getType
(
)
)
mArrayIndices
(
mBaseExpressionType
.
getArraySizes
(
)
.
size
(
)
0
)
{
}
TIntermTyped
*
getNextElement
(
TIntermTyped
*
valueExpression
TIntermTyped
*
*
valueElementOut
)
{
const
TSpan
<
const
unsigned
int
>
&
arraySizes
=
mBaseExpressionType
.
getArraySizes
(
)
;
if
(
mArrayIndices
.
back
(
)
>
=
arraySizes
.
back
(
)
)
{
return
nullptr
;
}
TIntermTyped
*
element
=
getCurrentElement
(
mBaseExpression
)
;
if
(
valueExpression
)
{
*
valueElementOut
=
getCurrentElement
(
valueExpression
)
;
}
incrementIndices
(
arraySizes
)
;
return
element
;
}
void
accumulateForRead
(
TSymbolTable
*
symbolTable
TIntermTyped
*
transformedElement
TIntermSequence
*
prependStatements
)
{
TIntermTyped
*
temp
=
CopyToTempVariable
(
symbolTable
transformedElement
prependStatements
)
;
mReadTransformConstructorArgs
.
push_back
(
temp
)
;
}
TIntermTyped
*
constructReadTransformExpression
(
)
{
const
TSpan
<
const
unsigned
int
>
&
baseTypeArraySizes
=
mBaseExpressionType
.
getArraySizes
(
)
;
TVector
<
unsigned
int
>
arraySizes
(
baseTypeArraySizes
.
begin
(
)
baseTypeArraySizes
.
end
(
)
)
;
TIntermTyped
*
firstElement
=
mReadTransformConstructorArgs
.
front
(
)
-
>
getAsTyped
(
)
;
const
TType
&
baseType
=
firstElement
-
>
getType
(
)
;
TVector
<
unsigned
int
>
accumulatedArraySizes
(
arraySizes
.
size
(
)
-
1
)
;
if
(
accumulatedArraySizes
.
size
(
)
>
0
)
{
accumulatedArraySizes
[
0
]
=
arraySizes
[
0
]
;
}
for
(
size_t
index
=
1
;
index
+
1
<
arraySizes
.
size
(
)
;
+
+
index
)
{
accumulatedArraySizes
[
index
]
=
accumulatedArraySizes
[
index
-
1
]
*
arraySizes
[
index
]
;
}
return
constructReadTransformExpressionHelper
(
arraySizes
accumulatedArraySizes
baseType
0
)
;
}
private
:
TIntermTyped
*
getCurrentElement
(
TIntermTyped
*
expression
)
{
TIntermTyped
*
element
=
expression
-
>
deepCopy
(
)
;
for
(
auto
it
=
mArrayIndices
.
rbegin
(
)
;
it
!
=
mArrayIndices
.
rend
(
)
;
+
+
it
)
{
unsigned
int
index
=
*
it
;
element
=
new
TIntermBinary
(
EOpIndexDirect
element
CreateIndexNode
(
index
)
)
;
}
return
element
;
}
void
incrementIndices
(
const
TSpan
<
const
unsigned
int
>
&
arraySizes
)
{
for
(
size_t
digitIndex
=
0
;
digitIndex
<
arraySizes
.
size
(
)
;
+
+
digitIndex
)
{
+
+
mArrayIndices
[
digitIndex
]
;
if
(
mArrayIndices
[
digitIndex
]
<
arraySizes
[
digitIndex
]
)
{
break
;
}
if
(
digitIndex
+
1
!
=
arraySizes
.
size
(
)
)
{
mArrayIndices
[
digitIndex
]
=
0
;
}
}
}
TIntermTyped
*
constructReadTransformExpressionHelper
(
const
TVector
<
unsigned
int
>
&
arraySizes
const
TVector
<
unsigned
int
>
&
accumulatedArraySizes
const
TType
&
baseType
size_t
elementsOffset
)
{
ASSERT
(
!
arraySizes
.
empty
(
)
)
;
TType
*
transformedType
=
new
TType
(
baseType
)
;
transformedType
-
>
makeArrays
(
arraySizes
)
;
if
(
arraySizes
.
size
(
)
=
=
1
)
{
ASSERT
(
accumulatedArraySizes
.
size
(
)
=
=
0
)
;
auto
sliceStart
=
mReadTransformConstructorArgs
.
begin
(
)
+
elementsOffset
;
TIntermSequence
slice
(
sliceStart
sliceStart
+
arraySizes
[
0
]
)
;
return
TIntermAggregate
:
:
CreateConstructor
(
*
transformedType
&
slice
)
;
}
TVector
<
unsigned
int
>
subArraySizes
(
arraySizes
.
begin
(
)
arraySizes
.
end
(
)
-
1
)
;
TVector
<
unsigned
int
>
subArrayAccumulatedSizes
(
accumulatedArraySizes
.
begin
(
)
accumulatedArraySizes
.
end
(
)
-
1
)
;
TIntermSequence
constructorArgs
;
unsigned
int
colStride
=
accumulatedArraySizes
.
back
(
)
;
for
(
size_t
col
=
0
;
col
<
arraySizes
.
back
(
)
;
+
+
col
)
{
size_t
colElementsOffset
=
elementsOffset
+
col
*
colStride
;
constructorArgs
.
push_back
(
constructReadTransformExpressionHelper
(
subArraySizes
subArrayAccumulatedSizes
baseType
colElementsOffset
)
)
;
}
return
TIntermAggregate
:
:
CreateConstructor
(
*
transformedType
&
constructorArgs
)
;
}
TIntermTyped
*
mBaseExpression
;
const
TType
&
mBaseExpressionType
;
TVector
<
unsigned
int
>
mArrayIndices
;
TIntermSequence
mReadTransformConstructorArgs
;
}
;
class
RewriteRowMajorMatricesTraverser
:
public
TIntermTraverser
{
public
:
RewriteRowMajorMatricesTraverser
(
TCompiler
*
compiler
TSymbolTable
*
symbolTable
)
:
TIntermTraverser
(
true
true
true
symbolTable
)
mCompiler
(
compiler
)
mStructMapOut
(
&
mOuterPass
.
structMap
)
mInterfaceBlockMap
(
&
mOuterPass
.
interfaceBlockMap
)
mInterfaceBlockFieldConvertedIn
(
mOuterPass
.
interfaceBlockFieldConverted
)
mCopyFunctionDefinitionsOut
(
&
mOuterPass
.
copyFunctionDefinitions
)
mOuterTraverser
(
nullptr
)
mInnerPassRoot
(
nullptr
)
mIsProcessingInnerPassSubtree
(
false
)
{
}
bool
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
node
)
override
{
if
(
mInnerPassRoot
!
=
nullptr
)
{
return
true
;
}
if
(
visit
!
=
PreVisit
)
{
return
true
;
}
const
TIntermSequence
&
sequence
=
*
(
node
-
>
getSequence
(
)
)
;
TIntermTyped
*
variable
=
sequence
.
front
(
)
-
>
getAsTyped
(
)
;
const
TType
&
type
=
variable
-
>
getType
(
)
;
if
(
type
.
isStructSpecifier
(
)
&
&
type
.
isStructureContainingMatrices
(
)
)
{
const
TStructure
*
structure
=
type
.
getStruct
(
)
;
ASSERT
(
structure
)
;
ASSERT
(
mOuterPass
.
structMap
.
count
(
structure
)
=
=
0
)
;
StructConversionData
structData
;
mOuterPass
.
structMap
[
structure
]
=
structData
;
return
false
;
}
if
(
type
.
isInterfaceBlock
(
)
&
&
type
.
getInterfaceBlock
(
)
-
>
containsMatrices
(
)
)
{
const
TInterfaceBlock
*
block
=
type
.
getInterfaceBlock
(
)
;
ASSERT
(
block
)
;
bool
isBlockRowMajor
=
type
.
getLayoutQualifier
(
)
.
matrixPacking
=
=
EmpRowMajor
;
const
TFieldList
&
fields
=
block
-
>
fields
(
)
;
bool
anyRowMajor
=
isBlockRowMajor
;
for
(
const
TField
*
field
:
fields
)
{
if
(
DoesFieldContainRowMajorMatrix
(
field
isBlockRowMajor
)
)
{
anyRowMajor
=
true
;
break
;
}
}
if
(
anyRowMajor
)
{
convertInterfaceBlock
(
node
)
;
}
return
false
;
}
return
true
;
}
void
visitSymbol
(
TIntermSymbol
*
symbol
)
override
{
if
(
mInnerPassRoot
!
=
nullptr
&
&
!
mIsProcessingInnerPassSubtree
)
{
return
;
}
const
TVariable
*
variable
=
&
symbol
-
>
variable
(
)
;
bool
needsRewrite
=
mInterfaceBlockMap
-
>
count
(
variable
)
!
=
0
;
if
(
!
needsRewrite
)
{
if
(
symbol
-
>
getType
(
)
.
getInterfaceBlock
(
)
&
&
!
variable
-
>
getType
(
)
.
isInterfaceBlock
(
)
)
{
needsRewrite
=
convertNamelessInterfaceBlockField
(
symbol
)
;
}
}
if
(
needsRewrite
)
{
transformExpression
(
symbol
)
;
}
}
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
{
if
(
node
=
=
mInnerPassRoot
)
{
mIsProcessingInnerPassSubtree
=
visit
=
=
InVisit
;
}
return
true
;
}
TIntermSequence
*
getStructCopyFunctions
(
)
{
return
&
mOuterPass
.
copyFunctionDefinitions
;
}
private
:
typedef
angle
:
:
HashMap
<
const
TStructure
*
StructConversionData
>
StructMap
;
typedef
angle
:
:
HashMap
<
const
TVariable
*
TVariable
*
>
InterfaceBlockMap
;
typedef
angle
:
:
HashMap
<
const
TField
*
bool
>
InterfaceBlockFieldConverted
;
RewriteRowMajorMatricesTraverser
(
TSymbolTable
*
symbolTable
RewriteRowMajorMatricesTraverser
*
outerTraverser
InterfaceBlockMap
*
interfaceBlockMap
const
InterfaceBlockFieldConverted
&
interfaceBlockFieldConverted
StructMap
*
structMap
TIntermSequence
*
copyFunctionDefinitions
TIntermBinary
*
innerPassRoot
)
:
TIntermTraverser
(
true
true
true
symbolTable
)
mStructMapOut
(
structMap
)
mInterfaceBlockMap
(
interfaceBlockMap
)
mInterfaceBlockFieldConvertedIn
(
interfaceBlockFieldConverted
)
mCopyFunctionDefinitionsOut
(
copyFunctionDefinitions
)
mOuterTraverser
(
outerTraverser
)
mInnerPassRoot
(
innerPassRoot
)
mIsProcessingInnerPassSubtree
(
false
)
{
}
void
convertInterfaceBlock
(
TIntermDeclaration
*
node
)
{
ASSERT
(
mInnerPassRoot
=
=
nullptr
)
;
const
TIntermSequence
&
sequence
=
*
(
node
-
>
getSequence
(
)
)
;
TIntermTyped
*
variableNode
=
sequence
.
front
(
)
-
>
getAsTyped
(
)
;
const
TType
&
type
=
variableNode
-
>
getType
(
)
;
const
TInterfaceBlock
*
block
=
type
.
getInterfaceBlock
(
)
;
ASSERT
(
block
)
;
bool
isBlockRowMajor
=
type
.
getLayoutQualifier
(
)
.
matrixPacking
=
=
EmpRowMajor
;
TIntermSequence
newDeclarations
;
TFieldList
*
newFields
=
new
TFieldList
;
for
(
const
TField
*
field
:
block
-
>
fields
(
)
)
{
TField
*
newField
=
nullptr
;
if
(
DoesFieldContainRowMajorMatrix
(
field
isBlockRowMajor
)
)
{
newField
=
convertField
(
field
&
newDeclarations
)
;
mOuterPass
.
interfaceBlockFieldConverted
[
field
]
=
true
;
}
else
{
newField
=
DuplicateField
(
field
)
;
}
newFields
-
>
push_back
(
newField
)
;
}
TLayoutQualifier
blockLayoutQualifier
=
type
.
getLayoutQualifier
(
)
;
blockLayoutQualifier
.
matrixPacking
=
EmpColumnMajor
;
TInterfaceBlock
*
newInterfaceBlock
=
new
TInterfaceBlock
(
mSymbolTable
block
-
>
name
(
)
newFields
blockLayoutQualifier
block
-
>
symbolType
(
)
block
-
>
extensions
(
)
)
;
ASSERT
(
sequence
.
size
(
)
=
=
1
)
;
TType
*
newInterfaceBlockType
=
new
TType
(
newInterfaceBlock
type
.
getQualifier
(
)
blockLayoutQualifier
)
;
TIntermDeclaration
*
newDeclaration
=
new
TIntermDeclaration
;
const
TVariable
*
variable
=
&
variableNode
-
>
getAsSymbolNode
(
)
-
>
variable
(
)
;
const
TType
*
newType
=
newInterfaceBlockType
;
if
(
type
.
isArray
(
)
)
{
TType
*
newArrayType
=
new
TType
(
*
newType
)
;
CopyArraySizes
(
&
type
newArrayType
)
;
newType
=
newArrayType
;
}
bool
variableIsTemp
=
variable
-
>
symbolType
(
)
=
=
SymbolType
:
:
Empty
;
const
ImmutableString
&
variableName
=
variableIsTemp
?
kEmptyImmutableString
:
variable
-
>
name
(
)
;
TVariable
*
newVariable
=
new
TVariable
(
mSymbolTable
variableName
newType
variable
-
>
symbolType
(
)
variable
-
>
extensions
(
)
)
;
newDeclaration
-
>
appendDeclarator
(
new
TIntermSymbol
(
newVariable
)
)
;
mOuterPass
.
interfaceBlockMap
[
variable
]
=
newVariable
;
newDeclarations
.
push_back
(
newDeclaration
)
;
mMultiReplacements
.
emplace_back
(
getParentNode
(
)
-
>
getAsBlock
(
)
node
std
:
:
move
(
newDeclarations
)
)
;
}
bool
convertNamelessInterfaceBlockField
(
TIntermSymbol
*
symbol
)
{
const
TVariable
*
variable
=
&
symbol
-
>
variable
(
)
;
const
TInterfaceBlock
*
interfaceBlock
=
symbol
-
>
getType
(
)
.
getInterfaceBlock
(
)
;
for
(
auto
iter
:
*
mInterfaceBlockMap
)
{
if
(
!
iter
.
first
-
>
getType
(
)
.
isInterfaceBlock
(
)
)
{
continue
;
}
if
(
iter
.
first
-
>
getType
(
)
.
getInterfaceBlock
(
)
!
=
interfaceBlock
)
{
continue
;
}
const
ImmutableString
symbolName
=
symbol
-
>
getName
(
)
;
const
TVector
<
TField
*
>
fields
=
interfaceBlock
-
>
fields
(
)
;
const
size_t
fieldIndex
=
variable
-
>
getType
(
)
.
getInterfaceBlockFieldIndex
(
)
;
ASSERT
(
fieldIndex
<
fields
.
size
(
)
)
;
const
TField
*
field
=
fields
[
fieldIndex
]
;
ASSERT
(
field
-
>
name
(
)
=
=
symbolName
)
;
if
(
mInterfaceBlockFieldConvertedIn
.
count
(
field
)
=
=
0
|
|
!
mInterfaceBlockFieldConvertedIn
.
at
(
field
)
)
{
break
;
}
TType
*
newType
=
new
TType
(
variable
-
>
getType
(
)
)
;
newType
-
>
setInterfaceBlockField
(
iter
.
second
-
>
getType
(
)
.
getInterfaceBlock
(
)
fieldIndex
)
;
TVariable
*
newVariable
=
new
TVariable
(
mSymbolTable
variable
-
>
name
(
)
newType
variable
-
>
symbolType
(
)
variable
-
>
extensions
(
)
)
;
(
*
mInterfaceBlockMap
)
[
variable
]
=
newVariable
;
return
true
;
}
return
false
;
}
void
convertStruct
(
const
TStructure
*
structure
TIntermSequence
*
newDeclarations
)
{
ASSERT
(
mInnerPassRoot
=
=
nullptr
)
;
ASSERT
(
mOuterPass
.
structMap
.
count
(
structure
)
!
=
0
)
;
StructConversionData
*
structData
=
&
mOuterPass
.
structMap
[
structure
]
;
if
(
structData
-
>
convertedStruct
)
{
return
;
}
TFieldList
*
newFields
=
new
TFieldList
;
for
(
const
TField
*
field
:
structure
-
>
fields
(
)
)
{
newFields
-
>
push_back
(
convertField
(
field
newDeclarations
)
)
;
}
TVariable
*
newStructTypeName
=
new
TVariable
(
mSymbolTable
kEmptyImmutableString
StaticType
:
:
GetBasic
<
EbtUInt
EbpUndefined
>
(
)
SymbolType
:
:
Empty
)
;
TStructure
*
newStruct
=
new
TStructure
(
mSymbolTable
newStructTypeName
-
>
name
(
)
newFields
SymbolType
:
:
AngleInternal
)
;
TType
*
newType
=
new
TType
(
newStruct
true
)
;
TVariable
*
newStructVar
=
new
TVariable
(
mSymbolTable
kEmptyImmutableString
newType
SymbolType
:
:
Empty
)
;
TIntermDeclaration
*
structDecl
=
new
TIntermDeclaration
;
structDecl
-
>
appendDeclarator
(
new
TIntermSymbol
(
newStructVar
)
)
;
newDeclarations
-
>
push_back
(
structDecl
)
;
structData
-
>
convertedStruct
=
newStruct
;
}
TField
*
convertField
(
const
TField
*
field
TIntermSequence
*
newDeclarations
)
{
ASSERT
(
mInnerPassRoot
=
=
nullptr
)
;
TField
*
newField
=
nullptr
;
const
TType
*
fieldType
=
field
-
>
type
(
)
;
TType
*
newType
=
nullptr
;
if
(
fieldType
-
>
isStructureContainingMatrices
(
)
)
{
const
TStructure
*
fieldTypeStruct
=
fieldType
-
>
getStruct
(
)
;
convertStruct
(
fieldTypeStruct
newDeclarations
)
;
StructConversionData
&
structData
=
mOuterPass
.
structMap
[
fieldTypeStruct
]
;
newType
=
new
TType
(
structData
.
convertedStruct
false
)
;
SetColumnMajor
(
newType
)
;
CopyArraySizes
(
fieldType
newType
)
;
}
else
if
(
fieldType
-
>
isMatrix
(
)
)
{
newType
=
TransposeMatrixType
(
fieldType
)
;
}
if
(
newType
)
{
newField
=
new
TField
(
newType
field
-
>
name
(
)
field
-
>
line
(
)
field
-
>
symbolType
(
)
)
;
}
else
{
newField
=
DuplicateField
(
field
)
;
}
return
newField
;
}
void
determineAccess
(
TIntermNode
*
expression
TIntermNode
*
accessor
bool
*
isReadOut
bool
*
isWriteOut
)
{
TIntermAggregate
*
functionCall
=
accessor
-
>
getAsAggregate
(
)
;
if
(
functionCall
)
{
TIntermSequence
*
arguments
=
functionCall
-
>
getSequence
(
)
;
for
(
size_t
argIndex
=
0
;
argIndex
<
arguments
-
>
size
(
)
;
+
+
argIndex
)
{
if
(
(
*
arguments
)
[
argIndex
]
=
=
expression
)
{
TQualifier
qualifier
=
EvqParamIn
;
const
TFunction
*
function
=
functionCall
-
>
getFunction
(
)
;
if
(
function
)
{
const
TVariable
*
param
=
function
-
>
getParam
(
argIndex
)
;
qualifier
=
param
-
>
getType
(
)
.
getQualifier
(
)
;
}
*
isReadOut
=
qualifier
!
=
EvqParamOut
;
*
isWriteOut
=
qualifier
=
=
EvqParamOut
|
|
qualifier
=
=
EvqParamInOut
;
break
;
}
}
return
;
}
TIntermBinary
*
assignment
=
accessor
-
>
getAsBinaryNode
(
)
;
if
(
assignment
&
&
IsAssignment
(
assignment
-
>
getOp
(
)
)
)
{
*
isReadOut
=
assignment
-
>
getRight
(
)
=
=
expression
;
*
isWriteOut
=
assignment
-
>
getLeft
(
)
=
=
expression
;
return
;
}
*
isReadOut
=
true
;
*
isWriteOut
=
false
;
}
void
transformExpression
(
TIntermSymbol
*
symbol
)
{
TIntermTyped
*
baseExpression
=
new
TIntermSymbol
(
mInterfaceBlockMap
-
>
at
(
&
symbol
-
>
variable
(
)
)
)
;
const
TStructure
*
structure
=
nullptr
;
TIntermNode
*
primaryIndex
=
nullptr
;
TIntermSequence
secondaryIndices
;
TIntermSequence
prependStatements
;
TIntermSequence
appendStatements
;
bool
requiresTransformation
=
!
symbol
-
>
getType
(
)
.
isInterfaceBlock
(
)
;
uint32_t
accessorIndex
=
0
;
TIntermTyped
*
previousAncestor
=
symbol
;
while
(
IsIndexNode
(
getAncestorNode
(
accessorIndex
)
previousAncestor
)
)
{
TIntermTyped
*
ancestor
=
getAncestorNode
(
accessorIndex
)
-
>
getAsTyped
(
)
;
ASSERT
(
ancestor
)
;
const
TType
&
previousAncestorType
=
previousAncestor
-
>
getType
(
)
;
TIntermSequence
indices
;
TOperator
op
=
GetIndex
(
mSymbolTable
ancestor
&
indices
&
prependStatements
)
;
bool
opIsIndex
=
op
=
=
EOpIndexDirect
|
|
op
=
=
EOpIndexIndirect
;
bool
isArrayIndex
=
opIsIndex
&
&
previousAncestorType
.
isArray
(
)
;
bool
isMatrixIndex
=
opIsIndex
&
&
previousAncestorType
.
isMatrix
(
)
;
bool
isMatrixPrimarySubscript
=
isMatrixIndex
&
&
!
isArrayIndex
;
ASSERT
(
!
isMatrixPrimarySubscript
|
|
(
primaryIndex
=
=
nullptr
&
&
secondaryIndices
.
empty
(
)
)
)
;
bool
isMatrixSecondarySubscript
=
primaryIndex
!
=
nullptr
;
ASSERT
(
!
isMatrixSecondarySubscript
|
|
(
opIsIndex
&
&
!
isArrayIndex
)
)
;
if
(
requiresTransformation
&
&
isMatrixPrimarySubscript
)
{
ASSERT
(
indices
.
size
(
)
=
=
1
)
;
primaryIndex
=
indices
.
front
(
)
;
const
uint8_t
rows
=
previousAncestorType
.
getRows
(
)
;
for
(
uint8_t
r
=
0
;
r
<
rows
;
+
+
r
)
{
secondaryIndices
.
push_back
(
CreateIndexNode
(
r
)
)
;
}
}
else
if
(
isMatrixSecondarySubscript
)
{
ASSERT
(
requiresTransformation
)
;
secondaryIndices
=
indices
;
+
+
accessorIndex
;
break
;
}
else
{
baseExpression
=
ReplicateIndexNode
(
mSymbolTable
ancestor
baseExpression
&
indices
)
;
const
TType
&
ancestorType
=
ancestor
-
>
getType
(
)
;
structure
=
ancestorType
.
getStruct
(
)
;
requiresTransformation
=
requiresTransformation
|
|
IsConvertedField
(
ancestor
mInterfaceBlockFieldConvertedIn
)
;
if
(
!
ancestorType
.
isMatrix
(
)
&
&
!
ancestorType
.
isStructureContainingMatrices
(
)
)
{
requiresTransformation
=
false
;
}
}
previousAncestor
=
ancestor
;
+
+
accessorIndex
;
}
TIntermNode
*
originalExpression
=
accessorIndex
=
=
0
?
symbol
:
getAncestorNode
(
accessorIndex
-
1
)
;
TIntermNode
*
accessor
=
getAncestorNode
(
accessorIndex
)
;
TIntermUnary
*
accessorAsUnary
=
accessor
-
>
getAsUnaryNode
(
)
;
if
(
requiresTransformation
&
&
accessorAsUnary
&
&
accessorAsUnary
-
>
getOp
(
)
=
=
EOpArrayLength
)
{
ASSERT
(
accessorAsUnary
-
>
getOperand
(
)
=
=
originalExpression
)
;
ASSERT
(
accessorAsUnary
-
>
getOperand
(
)
-
>
getType
(
)
.
isUnsizedArray
(
)
)
;
requiresTransformation
=
false
;
originalExpression
=
accessor
;
accessor
=
getAncestorNode
(
accessorIndex
+
1
)
;
baseExpression
=
new
TIntermUnary
(
EOpArrayLength
baseExpression
nullptr
)
;
}
if
(
!
requiresTransformation
)
{
ASSERT
(
primaryIndex
=
=
nullptr
)
;
queueReplacementWithParent
(
accessor
originalExpression
baseExpression
OriginalNode
:
:
IS_DROPPED
)
;
RewriteRowMajorMatricesTraverser
*
traverser
=
mOuterTraverser
?
mOuterTraverser
:
this
;
traverser
-
>
insertStatementsInParentBlock
(
prependStatements
appendStatements
)
;
return
;
}
ASSERT
(
structure
=
=
nullptr
|
|
primaryIndex
=
=
nullptr
)
;
ASSERT
(
structure
!
=
nullptr
|
|
baseExpression
-
>
getType
(
)
.
isMatrix
(
)
)
;
bool
isRead
=
false
;
bool
isWrite
=
false
;
determineAccess
(
originalExpression
accessor
&
isRead
&
isWrite
)
;
ASSERT
(
isRead
|
|
isWrite
)
;
TIntermTyped
*
readExpression
=
nullptr
;
if
(
isRead
)
{
readExpression
=
transformReadExpression
(
baseExpression
primaryIndex
&
secondaryIndices
structure
&
prependStatements
)
;
if
(
isWrite
)
{
readExpression
=
CopyToTempVariable
(
mSymbolTable
readExpression
&
prependStatements
)
;
}
queueReplacementWithParent
(
accessor
originalExpression
readExpression
OriginalNode
:
:
IS_DROPPED
)
;
}
TIntermSequence
postTransformPrependStatements
;
TIntermSequence
*
writeStatements
=
&
appendStatements
;
TOperator
assignmentOperator
=
EOpAssign
;
if
(
isWrite
)
{
TIntermTyped
*
valueExpression
=
readExpression
;
if
(
!
valueExpression
)
{
TVariable
*
temp
=
CreateTempVariable
(
mSymbolTable
&
originalExpression
-
>
getAsTyped
(
)
-
>
getType
(
)
)
;
TIntermDeclaration
*
tempDecl
=
nullptr
;
valueExpression
=
new
TIntermSymbol
(
temp
)
;
TIntermBinary
*
assignment
=
accessor
-
>
getAsBinaryNode
(
)
;
if
(
assignment
)
{
assignmentOperator
=
assignment
-
>
getOp
(
)
;
ASSERT
(
IsAssignment
(
assignmentOperator
)
)
;
RewriteRowMajorMatricesTraverser
*
outerTraverser
=
mOuterTraverser
?
mOuterTraverser
:
this
;
RewriteRowMajorMatricesTraverser
rhsTraverser
(
mSymbolTable
outerTraverser
mInterfaceBlockMap
mInterfaceBlockFieldConvertedIn
mStructMapOut
mCopyFunctionDefinitionsOut
assignment
)
;
getRootNode
(
)
-
>
traverse
(
&
rhsTraverser
)
;
bool
valid
=
rhsTraverser
.
updateTree
(
mCompiler
getRootNode
(
)
)
;
ASSERT
(
valid
)
;
tempDecl
=
CreateTempInitDeclarationNode
(
temp
assignment
-
>
getRight
(
)
)
;
writeStatements
=
&
prependStatements
;
TIntermTyped
*
assignmentResultExpression
=
transformReadExpression
(
baseExpression
-
>
deepCopy
(
)
primaryIndex
&
secondaryIndices
structure
&
postTransformPrependStatements
)
;
TIntermNode
*
accessorParent
=
getAncestorNode
(
accessorIndex
+
1
)
;
queueReplacementWithParent
(
accessorParent
accessor
assignmentResultExpression
OriginalNode
:
:
IS_DROPPED
)
;
}
else
{
tempDecl
=
CreateTempDeclarationNode
(
temp
)
;
queueReplacementWithParent
(
accessor
originalExpression
valueExpression
OriginalNode
:
:
IS_DROPPED
)
;
}
prependStatements
.
push_back
(
tempDecl
)
;
}
if
(
isRead
)
{
baseExpression
=
baseExpression
-
>
deepCopy
(
)
;
}
transformWriteExpression
(
baseExpression
primaryIndex
&
secondaryIndices
structure
valueExpression
assignmentOperator
writeStatements
)
;
}
prependStatements
.
insert
(
prependStatements
.
end
(
)
postTransformPrependStatements
.
begin
(
)
postTransformPrependStatements
.
end
(
)
)
;
RewriteRowMajorMatricesTraverser
*
traverser
=
mOuterTraverser
?
mOuterTraverser
:
this
;
traverser
-
>
insertStatementsInParentBlock
(
prependStatements
appendStatements
)
;
}
TIntermTyped
*
transformReadExpression
(
TIntermTyped
*
baseExpression
TIntermNode
*
primaryIndex
TIntermSequence
*
secondaryIndices
const
TStructure
*
structure
TIntermSequence
*
prependStatements
)
{
const
TType
&
baseExpressionType
=
baseExpression
-
>
getType
(
)
;
if
(
structure
)
{
ASSERT
(
primaryIndex
=
=
nullptr
&
&
secondaryIndices
-
>
empty
(
)
)
;
ASSERT
(
mStructMapOut
-
>
count
(
structure
)
!
=
0
)
;
ASSERT
(
(
*
mStructMapOut
)
[
structure
]
.
convertedStruct
!
=
nullptr
)
;
declareStructCopyToOriginal
(
structure
)
;
const
TFunction
*
copyToOriginal
=
(
*
mStructMapOut
)
[
structure
]
.
copyToOriginal
;
if
(
baseExpressionType
.
isArray
(
)
)
{
TransformArrayHelper
transformHelper
(
baseExpression
)
;
TIntermTyped
*
element
=
nullptr
;
while
(
(
element
=
transformHelper
.
getNextElement
(
nullptr
nullptr
)
)
!
=
nullptr
)
{
TIntermTyped
*
transformedElement
=
CreateStructCopyCall
(
copyToOriginal
element
)
;
transformHelper
.
accumulateForRead
(
mSymbolTable
transformedElement
prependStatements
)
;
}
return
transformHelper
.
constructReadTransformExpression
(
)
;
}
else
{
return
CreateStructCopyCall
(
copyToOriginal
baseExpression
)
;
}
}
if
(
primaryIndex
=
=
nullptr
)
{
ASSERT
(
secondaryIndices
-
>
empty
(
)
)
;
if
(
baseExpressionType
.
isArray
(
)
)
{
TransformArrayHelper
transformHelper
(
baseExpression
)
;
TIntermTyped
*
element
=
nullptr
;
while
(
(
element
=
transformHelper
.
getNextElement
(
nullptr
nullptr
)
)
!
=
nullptr
)
{
TIntermTyped
*
transformedElement
=
CreateTransposeCall
(
mSymbolTable
element
)
;
transformHelper
.
accumulateForRead
(
mSymbolTable
transformedElement
prependStatements
)
;
}
return
transformHelper
.
constructReadTransformExpression
(
)
;
}
else
{
return
CreateTransposeCall
(
mSymbolTable
baseExpression
)
;
}
}
ASSERT
(
!
secondaryIndices
-
>
empty
(
)
)
;
TOperator
primaryIndexOp
=
GetIndexOp
(
primaryIndex
)
;
TIntermTyped
*
primaryIndexAsTyped
=
primaryIndex
-
>
getAsTyped
(
)
;
TIntermSequence
transposedColumn
;
for
(
TIntermNode
*
secondaryIndex
:
*
secondaryIndices
)
{
TOperator
secondaryIndexOp
=
GetIndexOp
(
secondaryIndex
)
;
TIntermTyped
*
secondaryIndexAsTyped
=
secondaryIndex
-
>
getAsTyped
(
)
;
TIntermBinary
*
colIndexed
=
new
TIntermBinary
(
secondaryIndexOp
baseExpression
-
>
deepCopy
(
)
secondaryIndexAsTyped
-
>
deepCopy
(
)
)
;
TIntermBinary
*
colRowIndexed
=
new
TIntermBinary
(
primaryIndexOp
colIndexed
primaryIndexAsTyped
-
>
deepCopy
(
)
)
;
transposedColumn
.
push_back
(
colRowIndexed
)
;
}
if
(
secondaryIndices
-
>
size
(
)
=
=
1
)
{
return
transposedColumn
.
front
(
)
-
>
getAsTyped
(
)
;
}
TType
*
vecType
=
new
TType
(
baseExpressionType
.
getBasicType
(
)
secondaryIndices
-
>
size
(
)
)
;
return
TIntermAggregate
:
:
CreateConstructor
(
*
vecType
&
transposedColumn
)
;
}
void
transformWriteExpression
(
TIntermTyped
*
baseExpression
TIntermNode
*
primaryIndex
TIntermSequence
*
secondaryIndices
const
TStructure
*
structure
TIntermTyped
*
valueExpression
TOperator
assignmentOperator
TIntermSequence
*
writeStatements
)
{
const
TType
&
baseExpressionType
=
baseExpression
-
>
getType
(
)
;
if
(
structure
)
{
ASSERT
(
primaryIndex
=
=
nullptr
&
&
secondaryIndices
-
>
empty
(
)
)
;
ASSERT
(
mStructMapOut
-
>
count
(
structure
)
!
=
0
)
;
ASSERT
(
(
*
mStructMapOut
)
[
structure
]
.
convertedStruct
!
=
nullptr
)
;
declareStructCopyFromOriginal
(
structure
)
;
const
TFunction
*
copyFromOriginal
=
(
*
mStructMapOut
)
[
structure
]
.
copyFromOriginal
;
if
(
baseExpressionType
.
isArray
(
)
)
{
TransformArrayHelper
transformHelper
(
baseExpression
)
;
TIntermTyped
*
element
=
nullptr
;
TIntermTyped
*
valueElement
=
nullptr
;
while
(
(
element
=
transformHelper
.
getNextElement
(
valueExpression
&
valueElement
)
)
!
=
nullptr
)
{
TIntermTyped
*
functionCall
=
CreateStructCopyCall
(
copyFromOriginal
valueElement
)
;
writeStatements
-
>
push_back
(
new
TIntermBinary
(
EOpAssign
element
functionCall
)
)
;
}
}
else
{
TIntermTyped
*
functionCall
=
CreateStructCopyCall
(
copyFromOriginal
valueExpression
-
>
deepCopy
(
)
)
;
writeStatements
-
>
push_back
(
new
TIntermBinary
(
EOpAssign
baseExpression
functionCall
)
)
;
}
return
;
}
if
(
primaryIndex
=
=
nullptr
)
{
ASSERT
(
secondaryIndices
-
>
empty
(
)
)
;
if
(
baseExpressionType
.
isArray
(
)
)
{
TransformArrayHelper
transformHelper
(
baseExpression
)
;
TIntermTyped
*
element
=
nullptr
;
TIntermTyped
*
valueElement
=
nullptr
;
while
(
(
element
=
transformHelper
.
getNextElement
(
valueExpression
&
valueElement
)
)
!
=
nullptr
)
{
TIntermTyped
*
valueTransposed
=
CreateTransposeCall
(
mSymbolTable
valueElement
)
;
writeStatements
-
>
push_back
(
new
TIntermBinary
(
EOpAssign
element
valueTransposed
)
)
;
}
}
else
{
TIntermTyped
*
valueTransposed
=
CreateTransposeCall
(
mSymbolTable
valueExpression
-
>
deepCopy
(
)
)
;
writeStatements
-
>
push_back
(
new
TIntermBinary
(
assignmentOperator
baseExpression
valueTransposed
)
)
;
}
return
;
}
ASSERT
(
!
secondaryIndices
-
>
empty
(
)
)
;
bool
isValueExpressionScalar
=
valueExpression
-
>
getType
(
)
.
getNominalSize
(
)
=
=
1
;
ASSERT
(
isValueExpressionScalar
|
|
valueExpression
-
>
getType
(
)
.
getNominalSize
(
)
=
=
static_cast
<
int
>
(
secondaryIndices
-
>
size
(
)
)
)
;
TOperator
primaryIndexOp
=
GetIndexOp
(
primaryIndex
)
;
TIntermTyped
*
primaryIndexAsTyped
=
primaryIndex
-
>
getAsTyped
(
)
;
for
(
TIntermNode
*
secondaryIndex
:
*
secondaryIndices
)
{
TOperator
secondaryIndexOp
=
GetIndexOp
(
secondaryIndex
)
;
TIntermTyped
*
secondaryIndexAsTyped
=
secondaryIndex
-
>
getAsTyped
(
)
;
TIntermBinary
*
colIndexed
=
new
TIntermBinary
(
secondaryIndexOp
baseExpression
-
>
deepCopy
(
)
secondaryIndexAsTyped
-
>
deepCopy
(
)
)
;
TIntermBinary
*
colRowIndexed
=
new
TIntermBinary
(
primaryIndexOp
colIndexed
primaryIndexAsTyped
-
>
deepCopy
(
)
)
;
TIntermTyped
*
valueExpressionIndexed
=
valueExpression
-
>
deepCopy
(
)
;
if
(
!
isValueExpressionScalar
)
{
valueExpressionIndexed
=
new
TIntermBinary
(
secondaryIndexOp
valueExpressionIndexed
secondaryIndexAsTyped
-
>
deepCopy
(
)
)
;
}
writeStatements
-
>
push_back
(
new
TIntermBinary
(
assignmentOperator
colRowIndexed
valueExpressionIndexed
)
)
;
}
}
const
TFunction
*
getCopyStructFieldFunction
(
const
TType
*
fromFieldType
const
TType
*
toFieldType
bool
isCopyToOriginal
)
{
ASSERT
(
fromFieldType
-
>
getStruct
(
)
)
;
ASSERT
(
toFieldType
-
>
getStruct
(
)
)
;
const
TFunction
*
fieldCopyFunction
=
nullptr
;
if
(
isCopyToOriginal
)
{
const
TStructure
*
toFieldStruct
=
toFieldType
-
>
getStruct
(
)
;
auto
iter
=
mStructMapOut
-
>
find
(
toFieldStruct
)
;
if
(
iter
!
=
mStructMapOut
-
>
end
(
)
)
{
declareStructCopyToOriginal
(
toFieldStruct
)
;
fieldCopyFunction
=
iter
-
>
second
.
copyToOriginal
;
}
}
else
{
const
TStructure
*
fromFieldStruct
=
fromFieldType
-
>
getStruct
(
)
;
auto
iter
=
mStructMapOut
-
>
find
(
fromFieldStruct
)
;
if
(
iter
!
=
mStructMapOut
-
>
end
(
)
)
{
declareStructCopyFromOriginal
(
fromFieldStruct
)
;
fieldCopyFunction
=
iter
-
>
second
.
copyFromOriginal
;
}
}
return
fieldCopyFunction
;
}
void
addFieldCopy
(
TIntermBlock
*
body
TIntermTyped
*
to
TIntermTyped
*
from
bool
isCopyToOriginal
)
{
const
TType
&
fromType
=
from
-
>
getType
(
)
;
const
TType
&
toType
=
to
-
>
getType
(
)
;
TIntermTyped
*
rhs
=
from
;
if
(
fromType
.
getStruct
(
)
)
{
const
TFunction
*
fieldCopyFunction
=
getCopyStructFieldFunction
(
&
fromType
&
toType
isCopyToOriginal
)
;
if
(
fieldCopyFunction
)
{
rhs
=
CreateStructCopyCall
(
fieldCopyFunction
from
)
;
}
}
else
if
(
fromType
.
isMatrix
(
)
)
{
rhs
=
CreateTransposeCall
(
mSymbolTable
from
)
;
}
body
-
>
appendStatement
(
new
TIntermBinary
(
EOpAssign
to
rhs
)
)
;
}
TFunction
*
declareStructCopy
(
const
TStructure
*
from
const
TStructure
*
to
bool
isCopyToOriginal
)
{
TType
*
fromType
=
new
TType
(
from
true
)
;
TType
*
toType
=
new
TType
(
to
true
)
;
TVariable
*
fromVar
=
new
TVariable
(
mSymbolTable
ImmutableString
(
"
from
"
)
fromType
SymbolType
:
:
AngleInternal
)
;
TVariable
*
toVar
=
new
TVariable
(
mSymbolTable
ImmutableString
(
"
to
"
)
toType
SymbolType
:
:
AngleInternal
)
;
TIntermSymbol
*
fromSymbol
=
new
TIntermSymbol
(
fromVar
)
;
TIntermSymbol
*
toSymbol
=
new
TIntermSymbol
(
toVar
)
;
TIntermBlock
*
body
=
new
TIntermBlock
;
TIntermDeclaration
*
toDecl
=
new
TIntermDeclaration
(
)
;
toDecl
-
>
appendDeclarator
(
toSymbol
)
;
body
-
>
appendStatement
(
toDecl
)
;
const
TFieldList
&
fromFields
=
from
-
>
fields
(
)
;
const
TFieldList
&
toFields
=
to
-
>
fields
(
)
;
ASSERT
(
fromFields
.
size
(
)
=
=
toFields
.
size
(
)
)
;
for
(
size_t
fieldIndex
=
0
;
fieldIndex
<
fromFields
.
size
(
)
;
+
+
fieldIndex
)
{
TIntermTyped
*
fieldIndexNode
=
CreateIndexNode
(
static_cast
<
int
>
(
fieldIndex
)
)
;
TIntermTyped
*
fromField
=
new
TIntermBinary
(
EOpIndexDirectStruct
fromSymbol
-
>
deepCopy
(
)
fieldIndexNode
)
;
TIntermTyped
*
toField
=
new
TIntermBinary
(
EOpIndexDirectStruct
toSymbol
-
>
deepCopy
(
)
fieldIndexNode
-
>
deepCopy
(
)
)
;
const
TType
*
fromFieldType
=
fromFields
[
fieldIndex
]
-
>
type
(
)
;
bool
isStructOrMatrix
=
fromFieldType
-
>
getStruct
(
)
|
|
fromFieldType
-
>
isMatrix
(
)
;
if
(
fromFieldType
-
>
isArray
(
)
&
&
isStructOrMatrix
)
{
TransformArrayHelper
transformHelper
(
toField
)
;
TIntermTyped
*
toElement
=
nullptr
;
TIntermTyped
*
fromElement
=
nullptr
;
while
(
(
toElement
=
transformHelper
.
getNextElement
(
fromField
&
fromElement
)
)
!
=
nullptr
)
{
addFieldCopy
(
body
toElement
fromElement
isCopyToOriginal
)
;
}
}
else
{
addFieldCopy
(
body
toField
fromField
isCopyToOriginal
)
;
}
}
body
-
>
appendStatement
(
new
TIntermBranch
(
EOpReturn
toSymbol
-
>
deepCopy
(
)
)
)
;
TFunction
*
copyFunction
=
new
TFunction
(
mSymbolTable
kEmptyImmutableString
SymbolType
:
:
AngleInternal
toType
true
)
;
copyFunction
-
>
addParameter
(
fromVar
)
;
TIntermFunctionDefinition
*
functionDef
=
CreateInternalFunctionDefinitionNode
(
*
copyFunction
body
)
;
mCopyFunctionDefinitionsOut
-
>
push_back
(
functionDef
)
;
return
copyFunction
;
}
void
declareStructCopyFromOriginal
(
const
TStructure
*
structure
)
{
StructConversionData
*
structData
=
&
(
*
mStructMapOut
)
[
structure
]
;
if
(
structData
-
>
copyFromOriginal
)
{
return
;
}
structData
-
>
copyFromOriginal
=
declareStructCopy
(
structure
structData
-
>
convertedStruct
false
)
;
}
void
declareStructCopyToOriginal
(
const
TStructure
*
structure
)
{
StructConversionData
*
structData
=
&
(
*
mStructMapOut
)
[
structure
]
;
if
(
structData
-
>
copyToOriginal
)
{
return
;
}
structData
-
>
copyToOriginal
=
declareStructCopy
(
structData
-
>
convertedStruct
structure
true
)
;
}
TCompiler
*
mCompiler
;
struct
{
StructMap
structMap
;
InterfaceBlockMap
interfaceBlockMap
;
InterfaceBlockFieldConverted
interfaceBlockFieldConverted
;
TIntermSequence
copyFunctionDefinitions
;
}
mOuterPass
;
StructMap
*
mStructMapOut
;
InterfaceBlockMap
*
mInterfaceBlockMap
;
const
InterfaceBlockFieldConverted
&
mInterfaceBlockFieldConvertedIn
;
TIntermSequence
*
mCopyFunctionDefinitionsOut
;
RewriteRowMajorMatricesTraverser
*
mOuterTraverser
;
TIntermBinary
*
mInnerPassRoot
;
bool
mIsProcessingInnerPassSubtree
;
}
;
}
bool
RewriteRowMajorMatrices
(
TCompiler
*
compiler
TIntermBlock
*
root
TSymbolTable
*
symbolTable
)
{
RewriteRowMajorMatricesTraverser
traverser
(
compiler
symbolTable
)
;
root
-
>
traverse
(
&
traverser
)
;
if
(
!
traverser
.
updateTree
(
compiler
root
)
)
{
return
false
;
}
size_t
firstFunctionIndex
=
FindFirstFunctionDefinitionIndex
(
root
)
;
root
-
>
insertChildNodes
(
firstFunctionIndex
*
traverser
.
getStructCopyFunctions
(
)
)
;
return
compiler
-
>
validateAST
(
root
)
;
}
}
