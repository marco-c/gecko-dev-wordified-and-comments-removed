#
include
"
compiler
/
translator
/
tree_ops
/
FlagSamplersWithTexelFetch
.
h
"
#
include
"
angle_gl
.
h
"
#
include
"
common
/
utilities
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
ReplaceVariable
.
h
"
namespace
sh
{
namespace
{
constexpr
uint32_t
kTexelFetchSequenceLength
=
3u
;
constexpr
uint32_t
kTexelFetchOffsetSequenceLength
=
4u
;
class
FlagSamplersWithTexelFetchTraverser
:
public
TIntermTraverser
{
public
:
FlagSamplersWithTexelFetchTraverser
(
TSymbolTable
*
symbolTable
std
:
:
vector
<
ShaderVariable
>
*
uniforms
)
:
TIntermTraverser
(
true
true
true
symbolTable
)
mUniforms
(
uniforms
)
{
}
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
{
if
(
node
-
>
getOp
(
)
!
=
EOpCallBuiltInFunction
)
{
return
true
;
}
ASSERT
(
node
-
>
getFunction
(
)
-
>
symbolType
(
)
=
=
SymbolType
:
:
BuiltIn
)
;
if
(
node
-
>
getFunction
(
)
-
>
name
(
)
!
=
"
texelFetch
"
&
&
node
-
>
getFunction
(
)
-
>
name
(
)
!
=
"
texelFetchOffset
"
)
{
return
true
;
}
const
TIntermSequence
*
sequence
=
node
-
>
getSequence
(
)
;
ASSERT
(
sequence
-
>
size
(
)
=
=
(
node
-
>
getFunction
(
)
-
>
name
(
)
=
=
"
texelFetch
"
?
kTexelFetchSequenceLength
:
kTexelFetchOffsetSequenceLength
)
)
;
TIntermSymbol
*
samplerSymbol
=
sequence
-
>
at
(
0
)
-
>
getAsSymbolNode
(
)
;
ASSERT
(
samplerSymbol
!
=
nullptr
)
;
const
TVariable
&
samplerVariable
=
samplerSymbol
-
>
variable
(
)
;
for
(
ShaderVariable
&
uniform
:
*
mUniforms
)
{
if
(
samplerVariable
.
name
(
)
=
=
uniform
.
name
)
{
ASSERT
(
gl
:
:
IsSamplerType
(
uniform
.
type
)
)
;
uniform
.
texelFetchStaticUse
=
true
;
break
;
}
}
return
true
;
}
private
:
std
:
:
vector
<
ShaderVariable
>
*
mUniforms
;
}
;
}
bool
FlagSamplersForTexelFetch
(
TCompiler
*
compiler
TIntermBlock
*
root
TSymbolTable
*
symbolTable
std
:
:
vector
<
ShaderVariable
>
*
uniforms
)
{
ASSERT
(
uniforms
!
=
nullptr
)
;
if
(
uniforms
-
>
size
(
)
>
0
)
{
FlagSamplersWithTexelFetchTraverser
traverser
(
symbolTable
uniforms
)
;
root
-
>
traverse
(
&
traverser
)
;
}
return
true
;
}
}
