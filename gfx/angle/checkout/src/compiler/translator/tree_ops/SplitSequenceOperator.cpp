#
include
"
compiler
/
translator
/
tree_ops
/
SplitSequenceOperator
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNodePatternMatcher
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
class
SplitSequenceOperatorTraverser
:
public
TLValueTrackingTraverser
{
public
:
SplitSequenceOperatorTraverser
(
unsigned
int
patternsToSplitMask
TSymbolTable
*
symbolTable
)
;
bool
visitUnary
(
Visit
visit
TIntermUnary
*
node
)
override
;
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
;
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
;
bool
visitTernary
(
Visit
visit
TIntermTernary
*
node
)
override
;
void
nextIteration
(
)
;
bool
foundExpressionToSplit
(
)
const
{
return
mFoundExpressionToSplit
;
}
protected
:
bool
mFoundExpressionToSplit
;
int
mInsideSequenceOperator
;
IntermNodePatternMatcher
mPatternToSplitMatcher
;
}
;
SplitSequenceOperatorTraverser
:
:
SplitSequenceOperatorTraverser
(
unsigned
int
patternsToSplitMask
TSymbolTable
*
symbolTable
)
:
TLValueTrackingTraverser
(
true
false
true
symbolTable
)
mFoundExpressionToSplit
(
false
)
mInsideSequenceOperator
(
0
)
mPatternToSplitMatcher
(
patternsToSplitMask
)
{
}
void
SplitSequenceOperatorTraverser
:
:
nextIteration
(
)
{
mFoundExpressionToSplit
=
false
;
mInsideSequenceOperator
=
0
;
}
bool
SplitSequenceOperatorTraverser
:
:
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
{
if
(
mFoundExpressionToSplit
)
return
false
;
if
(
mInsideSequenceOperator
>
0
&
&
visit
=
=
PreVisit
)
{
mFoundExpressionToSplit
=
mPatternToSplitMatcher
.
match
(
node
getParentNode
(
)
)
;
return
!
mFoundExpressionToSplit
;
}
return
true
;
}
bool
SplitSequenceOperatorTraverser
:
:
visitUnary
(
Visit
visit
TIntermUnary
*
node
)
{
if
(
mFoundExpressionToSplit
)
return
false
;
if
(
mInsideSequenceOperator
>
0
&
&
visit
=
=
PreVisit
)
{
mFoundExpressionToSplit
=
mPatternToSplitMatcher
.
match
(
node
)
;
return
!
mFoundExpressionToSplit
;
}
return
true
;
}
bool
SplitSequenceOperatorTraverser
:
:
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
{
if
(
node
-
>
getOp
(
)
=
=
EOpComma
)
{
if
(
visit
=
=
PreVisit
)
{
if
(
mFoundExpressionToSplit
)
{
return
false
;
}
mInsideSequenceOperator
+
+
;
}
else
if
(
visit
=
=
PostVisit
)
{
if
(
mFoundExpressionToSplit
&
&
mInsideSequenceOperator
=
=
1
)
{
TIntermSequence
insertions
;
insertions
.
push_back
(
node
-
>
getLeft
(
)
)
;
insertStatementsInParentBlock
(
insertions
)
;
queueReplacement
(
node
-
>
getRight
(
)
OriginalNode
:
:
IS_DROPPED
)
;
}
mInsideSequenceOperator
-
-
;
}
return
true
;
}
if
(
mFoundExpressionToSplit
)
return
false
;
if
(
mInsideSequenceOperator
>
0
&
&
visit
=
=
PreVisit
)
{
mFoundExpressionToSplit
=
mPatternToSplitMatcher
.
match
(
node
getParentNode
(
)
isLValueRequiredHere
(
)
)
;
return
!
mFoundExpressionToSplit
;
}
return
true
;
}
bool
SplitSequenceOperatorTraverser
:
:
visitTernary
(
Visit
visit
TIntermTernary
*
node
)
{
if
(
mFoundExpressionToSplit
)
return
false
;
if
(
mInsideSequenceOperator
>
0
&
&
visit
=
=
PreVisit
)
{
mFoundExpressionToSplit
=
mPatternToSplitMatcher
.
match
(
node
)
;
return
!
mFoundExpressionToSplit
;
}
return
true
;
}
}
bool
SplitSequenceOperator
(
TCompiler
*
compiler
TIntermNode
*
root
int
patternsToSplitMask
TSymbolTable
*
symbolTable
)
{
SplitSequenceOperatorTraverser
traverser
(
patternsToSplitMask
symbolTable
)
;
do
{
traverser
.
nextIteration
(
)
;
root
-
>
traverse
(
&
traverser
)
;
if
(
traverser
.
foundExpressionToSplit
(
)
)
{
if
(
!
traverser
.
updateTree
(
compiler
root
)
)
{
return
false
;
}
}
}
while
(
traverser
.
foundExpressionToSplit
(
)
)
;
return
true
;
}
}
