#
include
"
compiler
/
translator
/
tree_ops
/
ClampIndirectIndices
.
h
"
#
include
"
compiler
/
translator
/
Compiler
.
h
"
#
include
"
compiler
/
translator
/
StaticType
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
class
ClampIndirectIndicesTraverser
:
public
TIntermTraverser
{
public
:
ClampIndirectIndicesTraverser
(
TCompiler
*
compiler
TSymbolTable
*
symbolTable
)
:
TIntermTraverser
(
true
false
false
symbolTable
)
mCompiler
(
compiler
)
{
}
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
{
ASSERT
(
visit
=
=
PreVisit
)
;
if
(
node
-
>
getOp
(
)
!
=
EOpIndexIndirect
)
{
return
true
;
}
bool
valid
=
ClampIndirectIndices
(
mCompiler
node
-
>
getLeft
(
)
mSymbolTable
)
;
ASSERT
(
valid
)
;
valid
=
ClampIndirectIndices
(
mCompiler
node
-
>
getRight
(
)
mSymbolTable
)
;
ASSERT
(
valid
)
;
const
TType
&
leftType
=
node
-
>
getLeft
(
)
-
>
getType
(
)
;
const
TType
&
rightType
=
node
-
>
getRight
(
)
-
>
getType
(
)
;
if
(
leftType
.
isUnsizedArray
(
)
)
{
return
true
;
}
const
bool
useFloatClamp
=
true
;
TIntermConstantUnion
*
zero
=
createClampValue
(
0
useFloatClamp
)
;
TIntermTyped
*
max
;
if
(
leftType
.
isArray
(
)
)
{
max
=
createClampValue
(
static_cast
<
int
>
(
leftType
.
getOutermostArraySize
(
)
)
-
1
useFloatClamp
)
;
}
else
{
ASSERT
(
leftType
.
isVector
(
)
|
|
leftType
.
isMatrix
(
)
)
;
max
=
createClampValue
(
leftType
.
getNominalSize
(
)
-
1
useFloatClamp
)
;
}
TIntermTyped
*
index
=
node
-
>
getRight
(
)
;
const
TBasicType
requiredBasicType
=
useFloatClamp
?
EbtFloat
:
EbtInt
;
if
(
rightType
.
getBasicType
(
)
!
=
requiredBasicType
)
{
const
TType
*
clampType
=
useFloatClamp
?
StaticType
:
:
GetBasic
<
EbtFloat
EbpHigh
>
(
)
:
StaticType
:
:
GetBasic
<
EbtInt
EbpHigh
>
(
)
;
TIntermSequence
constructorArgs
=
{
index
}
;
index
=
TIntermAggregate
:
:
CreateConstructor
(
*
clampType
&
constructorArgs
)
;
}
TIntermSequence
args
;
args
.
push_back
(
index
)
;
args
.
push_back
(
zero
)
;
args
.
push_back
(
max
)
;
TIntermTyped
*
clamped
=
CreateBuiltInFunctionCallNode
(
"
clamp
"
&
args
*
mSymbolTable
useFloatClamp
?
100
:
300
)
;
if
(
useFloatClamp
)
{
TIntermSequence
constructorArgs
=
{
clamped
}
;
clamped
=
TIntermAggregate
:
:
CreateConstructor
(
*
StaticType
:
:
GetBasic
<
EbtInt
EbpHigh
>
(
)
&
constructorArgs
)
;
}
queueReplacementWithParent
(
node
node
-
>
getRight
(
)
clamped
OriginalNode
:
:
IS_DROPPED
)
;
return
false
;
}
private
:
TIntermConstantUnion
*
createClampValue
(
int
value
bool
useFloat
)
{
if
(
useFloat
)
{
return
CreateFloatNode
(
static_cast
<
float
>
(
value
)
EbpHigh
)
;
}
return
CreateIndexNode
(
value
)
;
}
TCompiler
*
mCompiler
;
}
;
}
bool
ClampIndirectIndices
(
TCompiler
*
compiler
TIntermNode
*
root
TSymbolTable
*
symbolTable
)
{
ClampIndirectIndicesTraverser
traverser
(
compiler
symbolTable
)
;
root
-
>
traverse
(
&
traverser
)
;
return
traverser
.
updateTree
(
compiler
root
)
;
}
}
