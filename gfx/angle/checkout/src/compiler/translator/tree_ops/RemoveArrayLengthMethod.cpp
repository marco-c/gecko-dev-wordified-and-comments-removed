#
include
"
compiler
/
translator
/
tree_ops
/
RemoveArrayLengthMethod
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
class
RemoveArrayLengthTraverser
:
public
TIntermTraverser
{
public
:
RemoveArrayLengthTraverser
(
)
:
TIntermTraverser
(
true
false
false
)
mFoundArrayLength
(
false
)
{
}
bool
visitUnary
(
Visit
visit
TIntermUnary
*
node
)
override
;
void
nextIteration
(
)
{
mFoundArrayLength
=
false
;
}
bool
foundArrayLength
(
)
const
{
return
mFoundArrayLength
;
}
private
:
bool
mFoundArrayLength
;
}
;
bool
RemoveArrayLengthTraverser
:
:
visitUnary
(
Visit
visit
TIntermUnary
*
node
)
{
if
(
node
-
>
getOp
(
)
=
=
EOpArrayLength
&
&
!
node
-
>
getOperand
(
)
-
>
getType
(
)
.
isUnsizedArray
(
)
)
{
mFoundArrayLength
=
true
;
if
(
!
node
-
>
getOperand
(
)
-
>
hasSideEffects
(
)
)
{
queueReplacement
(
node
-
>
fold
(
nullptr
)
OriginalNode
:
:
IS_DROPPED
)
;
return
false
;
}
insertStatementInParentBlock
(
node
-
>
getOperand
(
)
-
>
deepCopy
(
)
)
;
TConstantUnion
*
constArray
=
new
TConstantUnion
[
1
]
;
constArray
-
>
setIConst
(
node
-
>
getOperand
(
)
-
>
getOutermostArraySize
(
)
)
;
queueReplacement
(
new
TIntermConstantUnion
(
constArray
node
-
>
getType
(
)
)
OriginalNode
:
:
IS_DROPPED
)
;
return
false
;
}
return
true
;
}
}
void
RemoveArrayLengthMethod
(
TIntermBlock
*
root
)
{
RemoveArrayLengthTraverser
traverser
;
do
{
traverser
.
nextIteration
(
)
;
root
-
>
traverse
(
&
traverser
)
;
if
(
traverser
.
foundArrayLength
(
)
)
traverser
.
updateTree
(
)
;
}
while
(
traverser
.
foundArrayLength
(
)
)
;
}
}
