#
include
"
compiler
/
translator
/
tree_ops
/
RemovePow
.
h
"
#
include
"
compiler
/
translator
/
InfoSink
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
bool
IsProblematicPow
(
TIntermTyped
*
node
)
{
TIntermAggregate
*
agg
=
node
-
>
getAsAggregate
(
)
;
if
(
agg
!
=
nullptr
&
&
agg
-
>
getOp
(
)
=
=
EOpPow
)
{
ASSERT
(
agg
-
>
getSequence
(
)
-
>
size
(
)
=
=
2
)
;
return
agg
-
>
getSequence
(
)
-
>
at
(
1
)
-
>
getAsConstantUnion
(
)
!
=
nullptr
;
}
return
false
;
}
class
RemovePowTraverser
:
public
TIntermTraverser
{
public
:
RemovePowTraverser
(
TSymbolTable
*
symbolTable
)
;
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
;
void
nextIteration
(
)
{
mNeedAnotherIteration
=
false
;
}
bool
needAnotherIteration
(
)
const
{
return
mNeedAnotherIteration
;
}
protected
:
bool
mNeedAnotherIteration
;
}
;
RemovePowTraverser
:
:
RemovePowTraverser
(
TSymbolTable
*
symbolTable
)
:
TIntermTraverser
(
true
false
false
symbolTable
)
mNeedAnotherIteration
(
false
)
{
}
bool
RemovePowTraverser
:
:
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
{
if
(
IsProblematicPow
(
node
)
)
{
TIntermTyped
*
x
=
node
-
>
getSequence
(
)
-
>
at
(
0
)
-
>
getAsTyped
(
)
;
TIntermTyped
*
y
=
node
-
>
getSequence
(
)
-
>
at
(
1
)
-
>
getAsTyped
(
)
;
TIntermSequence
*
logArgs
=
new
TIntermSequence
(
)
;
logArgs
-
>
push_back
(
x
)
;
TIntermTyped
*
log
=
CreateBuiltInFunctionCallNode
(
"
log2
"
logArgs
*
mSymbolTable
100
)
;
log
-
>
setLine
(
node
-
>
getLine
(
)
)
;
TOperator
op
=
TIntermBinary
:
:
GetMulOpBasedOnOperands
(
y
-
>
getType
(
)
log
-
>
getType
(
)
)
;
TIntermBinary
*
mul
=
new
TIntermBinary
(
op
y
log
)
;
mul
-
>
setLine
(
node
-
>
getLine
(
)
)
;
TIntermSequence
*
expArgs
=
new
TIntermSequence
(
)
;
expArgs
-
>
push_back
(
mul
)
;
TIntermTyped
*
exp
=
CreateBuiltInFunctionCallNode
(
"
exp2
"
expArgs
*
mSymbolTable
100
)
;
exp
-
>
setLine
(
node
-
>
getLine
(
)
)
;
queueReplacement
(
exp
OriginalNode
:
:
IS_DROPPED
)
;
if
(
IsProblematicPow
(
x
)
)
{
mNeedAnotherIteration
=
true
;
return
false
;
}
}
return
true
;
}
}
void
RemovePow
(
TIntermNode
*
root
TSymbolTable
*
symbolTable
)
{
RemovePowTraverser
traverser
(
symbolTable
)
;
do
{
traverser
.
nextIteration
(
)
;
root
-
>
traverse
(
&
traverser
)
;
traverser
.
updateTree
(
)
;
}
while
(
traverser
.
needAnotherIteration
(
)
)
;
}
}
