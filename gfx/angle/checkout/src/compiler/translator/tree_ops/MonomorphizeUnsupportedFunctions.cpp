#
include
"
compiler
/
translator
/
tree_ops
/
MonomorphizeUnsupportedFunctions
.
h
"
#
include
"
compiler
/
translator
/
ImmutableStringBuilder
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
ReplaceVariable
.
h
"
namespace
sh
{
namespace
{
struct
Argument
{
size_t
argumentIndex
;
TIntermTyped
*
argument
;
}
;
struct
FunctionData
{
bool
isOriginalUsed
;
TIntermFunctionDefinition
*
originalDefinition
;
TVector
<
TIntermFunctionDefinition
*
>
monomorphizedDefinitions
;
}
;
using
FunctionMap
=
angle
:
:
HashMap
<
const
TFunction
*
FunctionData
>
;
void
InitializeFunctionMap
(
TIntermBlock
*
root
FunctionMap
*
functionMapOut
)
{
TIntermSequence
&
sequence
=
*
root
-
>
getSequence
(
)
;
for
(
TIntermNode
*
node
:
sequence
)
{
TIntermFunctionDefinition
*
asFuncDef
=
node
-
>
getAsFunctionDefinition
(
)
;
if
(
asFuncDef
!
=
nullptr
)
{
const
TFunction
*
function
=
asFuncDef
-
>
getFunction
(
)
;
ASSERT
(
function
&
&
functionMapOut
-
>
find
(
function
)
=
=
functionMapOut
-
>
end
(
)
)
;
(
*
functionMapOut
)
[
function
]
=
FunctionData
{
false
asFuncDef
{
}
}
;
}
}
}
const
TVariable
*
GetBaseUniform
(
TIntermTyped
*
node
bool
*
isSamplerInStructOut
)
{
*
isSamplerInStructOut
=
false
;
while
(
node
-
>
getAsBinaryNode
(
)
)
{
TIntermBinary
*
asBinary
=
node
-
>
getAsBinaryNode
(
)
;
TOperator
op
=
asBinary
-
>
getOp
(
)
;
if
(
op
=
=
EOpIndexDirectInterfaceBlock
)
{
return
nullptr
;
}
if
(
op
=
=
EOpIndexDirectStruct
)
{
*
isSamplerInStructOut
=
true
;
}
node
=
asBinary
-
>
getLeft
(
)
;
}
if
(
node
-
>
getType
(
)
.
getQualifier
(
)
!
=
EvqUniform
)
{
return
nullptr
;
}
ASSERT
(
IsOpaqueType
(
node
-
>
getType
(
)
.
getBasicType
(
)
)
|
|
node
-
>
getType
(
)
.
isStructureContainingSamplers
(
)
)
;
TIntermSymbol
*
asSymbol
=
node
-
>
getAsSymbolNode
(
)
;
ASSERT
(
asSymbol
)
;
return
&
asSymbol
-
>
variable
(
)
;
}
TIntermTyped
*
ExtractSideEffects
(
TSymbolTable
*
symbolTable
TIntermTyped
*
node
TIntermSequence
*
replacementIndices
)
{
TIntermTyped
*
withoutSideEffects
=
node
-
>
deepCopy
(
)
;
for
(
TIntermBinary
*
asBinary
=
withoutSideEffects
-
>
getAsBinaryNode
(
)
;
asBinary
;
asBinary
=
asBinary
-
>
getLeft
(
)
-
>
getAsBinaryNode
(
)
)
{
TOperator
op
=
asBinary
-
>
getOp
(
)
;
TIntermTyped
*
index
=
asBinary
-
>
getRight
(
)
;
if
(
op
=
=
EOpIndexDirectStruct
)
{
break
;
}
if
(
op
=
=
EOpIndexDirect
)
{
ASSERT
(
index
-
>
getAsConstantUnion
(
)
)
;
continue
;
}
ASSERT
(
op
=
=
EOpIndexIndirect
)
;
if
(
index
-
>
getAsSymbolNode
(
)
)
{
continue
;
}
TIntermDeclaration
*
tempDecl
=
nullptr
;
TVariable
*
tempVar
=
DeclareTempVariable
(
symbolTable
index
EvqTemporary
&
tempDecl
)
;
replacementIndices
-
>
push_back
(
tempDecl
)
;
asBinary
-
>
replaceChildNode
(
index
new
TIntermSymbol
(
tempVar
)
)
;
}
return
withoutSideEffects
;
}
void
CreateMonomorphizedFunctionCallArgs
(
const
TIntermSequence
&
originalCallArguments
const
TVector
<
Argument
>
&
replacedArguments
TIntermSequence
*
substituteArgsOut
)
{
size_t
nextReplacedArg
=
0
;
for
(
size_t
argIndex
=
0
;
argIndex
<
originalCallArguments
.
size
(
)
;
+
+
argIndex
)
{
if
(
nextReplacedArg
>
=
replacedArguments
.
size
(
)
|
|
argIndex
!
=
replacedArguments
[
nextReplacedArg
]
.
argumentIndex
)
{
substituteArgsOut
-
>
push_back
(
originalCallArguments
[
argIndex
]
)
;
}
else
{
TIntermTyped
*
argument
=
replacedArguments
[
nextReplacedArg
]
.
argument
;
while
(
argument
-
>
getAsBinaryNode
(
)
)
{
TIntermBinary
*
asBinary
=
argument
-
>
getAsBinaryNode
(
)
;
if
(
asBinary
-
>
getOp
(
)
=
=
EOpIndexIndirect
)
{
TIntermTyped
*
index
=
asBinary
-
>
getRight
(
)
;
substituteArgsOut
-
>
push_back
(
index
-
>
deepCopy
(
)
)
;
}
argument
=
asBinary
-
>
getLeft
(
)
;
}
+
+
nextReplacedArg
;
}
}
}
const
TFunction
*
MonomorphizeFunction
(
TSymbolTable
*
symbolTable
const
TFunction
*
original
TVector
<
Argument
>
*
replacedArguments
VariableReplacementMap
*
argumentMapOut
)
{
TFunction
*
substituteFunction
=
new
TFunction
(
symbolTable
kEmptyImmutableString
SymbolType
:
:
AngleInternal
&
original
-
>
getReturnType
(
)
original
-
>
isKnownToNotHaveSideEffects
(
)
)
;
size_t
nextReplacedArg
=
0
;
for
(
size_t
paramIndex
=
0
;
paramIndex
<
original
-
>
getParamCount
(
)
;
+
+
paramIndex
)
{
const
TVariable
*
originalParam
=
original
-
>
getParam
(
paramIndex
)
;
if
(
nextReplacedArg
>
=
replacedArguments
-
>
size
(
)
|
|
paramIndex
!
=
(
*
replacedArguments
)
[
nextReplacedArg
]
.
argumentIndex
)
{
TVariable
*
substituteArgument
=
new
TVariable
(
symbolTable
originalParam
-
>
name
(
)
&
originalParam
-
>
getType
(
)
originalParam
-
>
symbolType
(
)
)
;
substituteFunction
-
>
addParameter
(
substituteArgument
)
;
(
*
argumentMapOut
)
[
originalParam
]
=
new
TIntermSymbol
(
substituteArgument
)
;
}
else
{
TIntermTyped
*
substituteArgument
=
(
*
replacedArguments
)
[
nextReplacedArg
]
.
argument
;
(
*
argumentMapOut
)
[
originalParam
]
=
substituteArgument
;
while
(
substituteArgument
-
>
getAsBinaryNode
(
)
)
{
TIntermBinary
*
asBinary
=
substituteArgument
-
>
getAsBinaryNode
(
)
;
if
(
asBinary
-
>
getOp
(
)
=
=
EOpIndexIndirect
)
{
TIntermTyped
*
index
=
asBinary
-
>
getRight
(
)
;
TType
*
indexType
=
new
TType
(
index
-
>
getType
(
)
)
;
indexType
-
>
setQualifier
(
EvqParamIn
)
;
TVariable
*
param
=
new
TVariable
(
symbolTable
kEmptyImmutableString
indexType
SymbolType
:
:
AngleInternal
)
;
substituteFunction
-
>
addParameter
(
param
)
;
asBinary
-
>
replaceChildNode
(
asBinary
-
>
getRight
(
)
new
TIntermSymbol
(
param
)
)
;
}
substituteArgument
=
asBinary
-
>
getLeft
(
)
;
}
+
+
nextReplacedArg
;
}
}
return
substituteFunction
;
}
class
MonomorphizeTraverser
final
:
public
TIntermTraverser
{
public
:
explicit
MonomorphizeTraverser
(
TCompiler
*
compiler
TSymbolTable
*
symbolTable
const
ShCompileOptions
&
compileOptions
UnsupportedFunctionArgsBitSet
unsupportedFunctionArgs
FunctionMap
*
functionMap
)
:
TIntermTraverser
(
true
false
false
symbolTable
)
mCompiler
(
compiler
)
mCompileOptions
(
compileOptions
)
mUnsupportedFunctionArgs
(
unsupportedFunctionArgs
)
mFunctionMap
(
functionMap
)
{
}
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
{
if
(
node
-
>
getOp
(
)
!
=
EOpCallFunctionInAST
)
{
return
true
;
}
const
TFunction
*
function
=
node
-
>
getFunction
(
)
;
ASSERT
(
function
&
&
mFunctionMap
-
>
find
(
function
)
!
=
mFunctionMap
-
>
end
(
)
)
;
FunctionData
&
data
=
(
*
mFunctionMap
)
[
function
]
;
TIntermFunctionDefinition
*
monomorphized
=
processFunctionCall
(
node
data
.
originalDefinition
&
data
.
isOriginalUsed
)
;
if
(
monomorphized
)
{
data
.
monomorphizedDefinitions
.
push_back
(
monomorphized
)
;
}
return
true
;
}
bool
getAnyMonomorphized
(
)
const
{
return
mAnyMonomorphized
;
}
private
:
bool
isUnsupportedArgument
(
TIntermTyped
*
callArgument
const
TVariable
*
funcArgument
)
const
{
const
bool
isOpaqueType
=
IsOpaqueType
(
funcArgument
-
>
getType
(
)
.
getBasicType
(
)
)
;
const
bool
isStructContainingSamplers
=
funcArgument
-
>
getType
(
)
.
isStructureContainingSamplers
(
)
;
if
(
!
isOpaqueType
&
&
!
isStructContainingSamplers
)
{
return
false
;
}
bool
isSamplerInStruct
=
false
;
const
TVariable
*
uniform
=
GetBaseUniform
(
callArgument
&
isSamplerInStruct
)
;
if
(
uniform
=
=
nullptr
)
{
return
false
;
}
const
TType
&
type
=
uniform
-
>
getType
(
)
;
if
(
mUnsupportedFunctionArgs
[
UnsupportedFunctionArgs
:
:
StructContainingSamplers
]
)
{
if
(
isStructContainingSamplers
)
{
return
true
;
}
}
if
(
mUnsupportedFunctionArgs
[
UnsupportedFunctionArgs
:
:
ArrayOfArrayOfSamplerOrImage
]
)
{
const
bool
isParameterArrayOfOpaqueType
=
funcArgument
-
>
getType
(
)
.
isArray
(
)
;
const
bool
isArrayOfArrayOfSamplerOrImage
=
(
type
.
isSampler
(
)
|
|
type
.
isImage
(
)
)
&
&
type
.
isArrayOfArrays
(
)
;
if
(
isSamplerInStruct
&
&
isParameterArrayOfOpaqueType
)
{
return
true
;
}
if
(
isArrayOfArrayOfSamplerOrImage
&
&
isParameterArrayOfOpaqueType
)
{
return
true
;
}
}
if
(
mUnsupportedFunctionArgs
[
UnsupportedFunctionArgs
:
:
AtomicCounter
]
)
{
if
(
type
.
isAtomicCounter
(
)
)
{
return
true
;
}
}
if
(
mUnsupportedFunctionArgs
[
UnsupportedFunctionArgs
:
:
SamplerCubeEmulation
]
)
{
if
(
type
.
isSamplerCube
(
)
&
&
mCompileOptions
.
emulateSeamfulCubeMapSampling
)
{
return
true
;
}
}
if
(
mUnsupportedFunctionArgs
[
UnsupportedFunctionArgs
:
:
Image
]
)
{
if
(
type
.
isImage
(
)
)
{
return
true
;
}
}
if
(
mUnsupportedFunctionArgs
[
UnsupportedFunctionArgs
:
:
PixelLocalStorage
]
)
{
if
(
type
.
isPixelLocal
(
)
)
{
return
true
;
}
}
return
false
;
}
TIntermFunctionDefinition
*
processFunctionCall
(
TIntermAggregate
*
functionCall
TIntermFunctionDefinition
*
originalDefinition
bool
*
isOriginalUsedOut
)
{
const
TFunction
*
function
=
functionCall
-
>
getFunction
(
)
;
const
TIntermSequence
&
callArguments
=
*
functionCall
-
>
getSequence
(
)
;
TVector
<
Argument
>
replacedArguments
;
TIntermSequence
replacementIndices
;
for
(
size_t
argIndex
=
0
;
argIndex
<
callArguments
.
size
(
)
;
+
+
argIndex
)
{
TIntermTyped
*
callArgument
=
callArguments
[
argIndex
]
-
>
getAsTyped
(
)
;
const
TVariable
*
funcArgument
=
function
-
>
getParam
(
argIndex
)
;
if
(
isUnsupportedArgument
(
callArgument
funcArgument
)
)
{
TIntermTyped
*
argument
=
ExtractSideEffects
(
mSymbolTable
callArgument
&
replacementIndices
)
;
replacedArguments
.
push_back
(
{
argIndex
argument
}
)
;
}
}
if
(
replacedArguments
.
empty
(
)
)
{
*
isOriginalUsedOut
=
true
;
return
nullptr
;
}
mAnyMonomorphized
=
true
;
insertStatementsInParentBlock
(
replacementIndices
)
;
TIntermSequence
newCallArgs
;
CreateMonomorphizedFunctionCallArgs
(
callArguments
replacedArguments
&
newCallArgs
)
;
VariableReplacementMap
argumentMap
;
const
TFunction
*
monomorphized
=
MonomorphizeFunction
(
mSymbolTable
function
&
replacedArguments
&
argumentMap
)
;
queueReplacement
(
TIntermAggregate
:
:
CreateFunctionCall
(
*
monomorphized
&
newCallArgs
)
OriginalNode
:
:
IS_DROPPED
)
;
TIntermFunctionPrototype
*
substitutePrototype
=
new
TIntermFunctionPrototype
(
monomorphized
)
;
TIntermBlock
*
substituteBlock
=
originalDefinition
-
>
getBody
(
)
-
>
deepCopy
(
)
;
GetDeclaratorReplacements
(
mSymbolTable
substituteBlock
&
argumentMap
)
;
bool
valid
=
ReplaceVariables
(
mCompiler
substituteBlock
argumentMap
)
;
ASSERT
(
valid
)
;
return
new
TIntermFunctionDefinition
(
substitutePrototype
substituteBlock
)
;
}
TCompiler
*
mCompiler
;
const
ShCompileOptions
&
mCompileOptions
;
UnsupportedFunctionArgsBitSet
mUnsupportedFunctionArgs
;
bool
mAnyMonomorphized
=
false
;
FunctionMap
*
mFunctionMap
;
}
;
class
UpdateFunctionsDefinitionsTraverser
final
:
public
TIntermTraverser
{
public
:
explicit
UpdateFunctionsDefinitionsTraverser
(
TSymbolTable
*
symbolTable
const
FunctionMap
&
functionMap
)
:
TIntermTraverser
(
true
false
false
symbolTable
)
mFunctionMap
(
functionMap
)
{
}
void
visitFunctionPrototype
(
TIntermFunctionPrototype
*
node
)
override
{
const
bool
isInFunctionDefinition
=
getParentNode
(
)
-
>
getAsFunctionDefinition
(
)
!
=
nullptr
;
if
(
isInFunctionDefinition
)
{
return
;
}
const
TFunction
*
function
=
node
-
>
getFunction
(
)
;
ASSERT
(
function
&
&
mFunctionMap
.
find
(
function
)
!
=
mFunctionMap
.
end
(
)
)
;
const
FunctionData
&
data
=
mFunctionMap
.
at
(
function
)
;
if
(
data
.
monomorphizedDefinitions
.
empty
(
)
)
{
ASSERT
(
data
.
isOriginalUsed
)
;
return
;
}
TIntermSequence
replacement
;
if
(
data
.
isOriginalUsed
)
{
replacement
.
push_back
(
node
)
;
}
for
(
TIntermFunctionDefinition
*
monomorphizedDefinition
:
data
.
monomorphizedDefinitions
)
{
replacement
.
push_back
(
new
TIntermFunctionPrototype
(
monomorphizedDefinition
-
>
getFunctionPrototype
(
)
-
>
getFunction
(
)
)
)
;
}
mMultiReplacements
.
emplace_back
(
getParentNode
(
)
-
>
getAsBlock
(
)
node
std
:
:
move
(
replacement
)
)
;
}
bool
visitFunctionDefinition
(
Visit
visit
TIntermFunctionDefinition
*
node
)
override
{
const
TFunction
*
function
=
node
-
>
getFunction
(
)
;
ASSERT
(
function
&
&
mFunctionMap
.
find
(
function
)
!
=
mFunctionMap
.
end
(
)
)
;
const
FunctionData
&
data
=
mFunctionMap
.
at
(
function
)
;
if
(
data
.
monomorphizedDefinitions
.
empty
(
)
)
{
ASSERT
(
data
.
isOriginalUsed
|
|
function
-
>
name
(
)
=
=
"
main
"
)
;
return
false
;
}
TIntermSequence
replacement
;
if
(
data
.
isOriginalUsed
)
{
replacement
.
push_back
(
node
)
;
}
for
(
TIntermFunctionDefinition
*
monomorphizedDefinition
:
data
.
monomorphizedDefinitions
)
{
replacement
.
push_back
(
monomorphizedDefinition
)
;
}
mMultiReplacements
.
emplace_back
(
getParentNode
(
)
-
>
getAsBlock
(
)
node
std
:
:
move
(
replacement
)
)
;
return
false
;
}
private
:
const
FunctionMap
&
mFunctionMap
;
}
;
void
SortDeclarations
(
TIntermBlock
*
root
)
{
TIntermSequence
*
original
=
root
-
>
getSequence
(
)
;
TIntermSequence
replacement
;
TIntermSequence
functionDefs
;
for
(
TIntermNode
*
node
:
*
original
)
{
if
(
node
-
>
getAsFunctionDefinition
(
)
|
|
node
-
>
getAsFunctionPrototypeNode
(
)
)
{
functionDefs
.
push_back
(
node
)
;
}
else
{
replacement
.
push_back
(
node
)
;
}
}
replacement
.
insert
(
replacement
.
end
(
)
functionDefs
.
begin
(
)
functionDefs
.
end
(
)
)
;
root
-
>
replaceAllChildren
(
replacement
)
;
}
bool
MonomorphizeUnsupportedFunctionsImpl
(
TCompiler
*
compiler
TIntermBlock
*
root
TSymbolTable
*
symbolTable
const
ShCompileOptions
&
compileOptions
UnsupportedFunctionArgsBitSet
unsupportedFunctionArgs
)
{
SortDeclarations
(
root
)
;
while
(
true
)
{
FunctionMap
functionMap
;
InitializeFunctionMap
(
root
&
functionMap
)
;
MonomorphizeTraverser
monomorphizer
(
compiler
symbolTable
compileOptions
unsupportedFunctionArgs
&
functionMap
)
;
root
-
>
traverse
(
&
monomorphizer
)
;
if
(
!
monomorphizer
.
getAnyMonomorphized
(
)
)
{
break
;
}
if
(
!
monomorphizer
.
updateTree
(
compiler
root
)
)
{
return
false
;
}
UpdateFunctionsDefinitionsTraverser
functionUpdater
(
symbolTable
functionMap
)
;
root
-
>
traverse
(
&
functionUpdater
)
;
if
(
!
functionUpdater
.
updateTree
(
compiler
root
)
)
{
return
false
;
}
}
return
true
;
}
}
bool
MonomorphizeUnsupportedFunctions
(
TCompiler
*
compiler
TIntermBlock
*
root
TSymbolTable
*
symbolTable
const
ShCompileOptions
&
compileOptions
UnsupportedFunctionArgsBitSet
unsupportedFunctionArgs
)
{
bool
enableValidateFunctionCall
=
compiler
-
>
disableValidateFunctionCall
(
)
;
bool
result
=
MonomorphizeUnsupportedFunctionsImpl
(
compiler
root
symbolTable
compileOptions
unsupportedFunctionArgs
)
;
compiler
-
>
restoreValidateFunctionCall
(
enableValidateFunctionCall
)
;
return
result
&
&
compiler
-
>
validateAST
(
root
)
;
}
}
