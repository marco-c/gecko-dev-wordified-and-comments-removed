#
include
"
compiler
/
translator
/
tree_ops
/
RewriteStructSamplers
.
h
"
#
include
"
compiler
/
translator
/
ImmutableStringBuilder
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
struct
StructureData
{
const
TStructure
*
modified
;
TVector
<
int
>
fieldMap
;
}
;
using
StructureMap
=
angle
:
:
HashMap
<
const
TStructure
*
StructureData
>
;
using
StructureUniformMap
=
angle
:
:
HashMap
<
const
TVariable
*
const
TVariable
*
>
;
using
ExtractedSamplerMap
=
angle
:
:
HashMap
<
std
:
:
string
const
TVariable
*
>
;
TIntermTyped
*
RewriteModifiedStructFieldSelectionExpression
(
TCompiler
*
compiler
TIntermBinary
*
node
const
StructureMap
&
structureMap
const
StructureUniformMap
&
structureUniformMap
const
ExtractedSamplerMap
&
extractedSamplers
)
;
TIntermTyped
*
RewriteExpressionVisitBinaryHelper
(
TCompiler
*
compiler
TIntermBinary
*
node
const
StructureMap
&
structureMap
const
StructureUniformMap
&
structureUniformMap
const
ExtractedSamplerMap
&
extractedSamplers
)
{
if
(
node
-
>
getOp
(
)
!
=
EOpIndexDirectStruct
)
{
return
nullptr
;
}
const
TStructure
*
structure
=
node
-
>
getLeft
(
)
-
>
getType
(
)
.
getStruct
(
)
;
ASSERT
(
structure
)
;
if
(
!
node
-
>
getType
(
)
.
isSampler
(
)
&
&
structureMap
.
find
(
structure
)
=
=
structureMap
.
end
(
)
)
{
return
nullptr
;
}
ASSERT
(
structureMap
.
find
(
structure
)
!
=
structureMap
.
end
(
)
)
;
return
RewriteModifiedStructFieldSelectionExpression
(
compiler
node
structureMap
structureUniformMap
extractedSamplers
)
;
}
class
RewriteExpressionTraverser
final
:
public
TIntermTraverser
{
public
:
explicit
RewriteExpressionTraverser
(
TCompiler
*
compiler
const
StructureMap
&
structureMap
const
StructureUniformMap
&
structureUniformMap
const
ExtractedSamplerMap
&
extractedSamplers
)
:
TIntermTraverser
(
true
false
false
)
mCompiler
(
compiler
)
mStructureMap
(
structureMap
)
mStructureUniformMap
(
structureUniformMap
)
mExtractedSamplers
(
extractedSamplers
)
{
}
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
{
TIntermTyped
*
rewritten
=
RewriteExpressionVisitBinaryHelper
(
mCompiler
node
mStructureMap
mStructureUniformMap
mExtractedSamplers
)
;
if
(
rewritten
=
=
nullptr
)
{
return
true
;
}
queueReplacement
(
rewritten
OriginalNode
:
:
IS_DROPPED
)
;
return
false
;
}
void
visitSymbol
(
TIntermSymbol
*
node
)
override
{
ASSERT
(
mStructureUniformMap
.
find
(
&
node
-
>
variable
(
)
)
=
=
mStructureUniformMap
.
end
(
)
)
;
}
private
:
TCompiler
*
mCompiler
;
const
StructureMap
&
mStructureMap
;
const
StructureUniformMap
&
mStructureUniformMap
;
const
ExtractedSamplerMap
&
mExtractedSamplers
;
}
;
void
RewriteIndexExpression
(
TCompiler
*
compiler
TIntermTyped
*
expression
const
StructureMap
&
structureMap
const
StructureUniformMap
&
structureUniformMap
const
ExtractedSamplerMap
&
extractedSamplers
)
{
RewriteExpressionTraverser
traverser
(
compiler
structureMap
structureUniformMap
extractedSamplers
)
;
expression
-
>
traverse
(
&
traverser
)
;
bool
valid
=
traverser
.
updateTree
(
compiler
expression
)
;
ASSERT
(
valid
)
;
}
TIntermTyped
*
RewriteModifiedStructFieldSelectionExpression
(
TCompiler
*
compiler
TIntermBinary
*
node
const
StructureMap
&
structureMap
const
StructureUniformMap
&
structureUniformMap
const
ExtractedSamplerMap
&
extractedSamplers
)
{
ASSERT
(
node
-
>
getOp
(
)
=
=
EOpIndexDirectStruct
)
;
const
bool
isSampler
=
node
-
>
getType
(
)
.
isSampler
(
)
;
TIntermSymbol
*
baseUniform
=
nullptr
;
std
:
:
string
samplerName
;
TVector
<
TIntermBinary
*
>
indexNodeStack
;
TIntermBinary
*
iter
=
node
;
while
(
baseUniform
=
=
nullptr
)
{
indexNodeStack
.
push_back
(
iter
)
;
baseUniform
=
iter
-
>
getLeft
(
)
-
>
getAsSymbolNode
(
)
;
if
(
isSampler
)
{
if
(
iter
-
>
getOp
(
)
=
=
EOpIndexDirectStruct
)
{
samplerName
.
insert
(
0
iter
-
>
getIndexStructFieldName
(
)
.
data
(
)
)
;
samplerName
.
insert
(
0
"
_
"
)
;
}
if
(
baseUniform
)
{
samplerName
.
insert
(
0
baseUniform
-
>
variable
(
)
.
name
(
)
.
data
(
)
)
;
}
}
iter
=
iter
-
>
getLeft
(
)
-
>
getAsBinaryNode
(
)
;
}
TIntermTyped
*
rewritten
=
nullptr
;
if
(
isSampler
)
{
ASSERT
(
extractedSamplers
.
find
(
samplerName
)
!
=
extractedSamplers
.
end
(
)
)
;
rewritten
=
new
TIntermSymbol
(
extractedSamplers
.
at
(
samplerName
)
)
;
}
else
{
const
TVariable
*
baseUniformVar
=
&
baseUniform
-
>
variable
(
)
;
ASSERT
(
structureUniformMap
.
find
(
baseUniformVar
)
!
=
structureUniformMap
.
end
(
)
)
;
rewritten
=
new
TIntermSymbol
(
structureUniformMap
.
at
(
baseUniformVar
)
)
;
}
for
(
auto
it
=
indexNodeStack
.
rbegin
(
)
;
it
!
=
indexNodeStack
.
rend
(
)
;
+
+
it
)
{
TIntermBinary
*
indexNode
=
*
it
;
switch
(
indexNode
-
>
getOp
(
)
)
{
case
EOpIndexDirectStruct
:
if
(
!
isSampler
)
{
const
TStructure
*
structure
=
indexNode
-
>
getLeft
(
)
-
>
getType
(
)
.
getStruct
(
)
;
ASSERT
(
structureMap
.
find
(
structure
)
!
=
structureMap
.
end
(
)
)
;
TIntermConstantUnion
*
asConstantUnion
=
indexNode
-
>
getRight
(
)
-
>
getAsConstantUnion
(
)
;
ASSERT
(
asConstantUnion
)
;
const
int
fieldIndex
=
asConstantUnion
-
>
getIConst
(
0
)
;
ASSERT
(
fieldIndex
<
static_cast
<
int
>
(
structureMap
.
at
(
structure
)
.
fieldMap
.
size
(
)
)
)
;
const
int
mappedFieldIndex
=
structureMap
.
at
(
structure
)
.
fieldMap
[
fieldIndex
]
;
rewritten
=
new
TIntermBinary
(
EOpIndexDirectStruct
rewritten
CreateIndexNode
(
mappedFieldIndex
)
)
;
}
break
;
case
EOpIndexDirect
:
rewritten
=
new
TIntermBinary
(
EOpIndexDirect
rewritten
indexNode
-
>
getRight
(
)
)
;
break
;
case
EOpIndexIndirect
:
{
TIntermTyped
*
indexExpression
=
indexNode
-
>
getRight
(
)
;
RewriteIndexExpression
(
compiler
indexExpression
structureMap
structureUniformMap
extractedSamplers
)
;
rewritten
=
new
TIntermBinary
(
EOpIndexIndirect
rewritten
indexExpression
)
;
break
;
}
default
:
UNREACHABLE
(
)
;
break
;
}
}
return
rewritten
;
}
class
RewriteStructSamplersTraverser
final
:
public
TIntermTraverser
{
public
:
explicit
RewriteStructSamplersTraverser
(
TCompiler
*
compiler
TSymbolTable
*
symbolTable
)
:
TIntermTraverser
(
true
false
false
symbolTable
)
mCompiler
(
compiler
)
mRemovedUniformsCount
(
0
)
{
}
int
removedUniformsCount
(
)
const
{
return
mRemovedUniformsCount
;
}
bool
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
decl
)
override
{
if
(
!
mInGlobalScope
)
{
return
true
;
}
const
TIntermSequence
&
sequence
=
*
(
decl
-
>
getSequence
(
)
)
;
TIntermTyped
*
declarator
=
sequence
.
front
(
)
-
>
getAsTyped
(
)
;
const
TType
&
type
=
declarator
-
>
getType
(
)
;
if
(
!
type
.
isStructureContainingSamplers
(
)
)
{
return
false
;
}
TIntermSequence
newSequence
;
if
(
type
.
isStructSpecifier
(
)
)
{
const
TStructure
*
structure
=
type
.
getStruct
(
)
;
ASSERT
(
structure
&
&
mStructureMap
.
find
(
structure
)
=
=
mStructureMap
.
end
(
)
)
;
stripStructSpecifierSamplers
(
structure
&
newSequence
)
;
}
else
{
const
TStructure
*
structure
=
type
.
getStruct
(
)
;
if
(
mStructureMap
.
find
(
structure
)
=
=
mStructureMap
.
end
(
)
)
{
stripStructSpecifierSamplers
(
structure
&
newSequence
)
;
}
TIntermSymbol
*
asSymbol
=
declarator
-
>
getAsSymbolNode
(
)
;
ASSERT
(
asSymbol
)
;
const
TVariable
&
variable
=
asSymbol
-
>
variable
(
)
;
ASSERT
(
variable
.
symbolType
(
)
!
=
SymbolType
:
:
Empty
)
;
extractStructSamplerUniforms
(
variable
structure
&
newSequence
)
;
}
mMultiReplacements
.
emplace_back
(
getParentNode
(
)
-
>
getAsBlock
(
)
decl
std
:
:
move
(
newSequence
)
)
;
return
false
;
}
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
{
TIntermTyped
*
rewritten
=
RewriteExpressionVisitBinaryHelper
(
mCompiler
node
mStructureMap
mStructureUniformMap
mExtractedSamplers
)
;
if
(
rewritten
=
=
nullptr
)
{
return
true
;
}
queueReplacement
(
rewritten
OriginalNode
:
:
IS_DROPPED
)
;
return
false
;
}
void
visitSymbol
(
TIntermSymbol
*
node
)
override
{
ASSERT
(
mStructureUniformMap
.
find
(
&
node
-
>
variable
(
)
)
=
=
mStructureUniformMap
.
end
(
)
)
;
}
private
:
void
stripStructSpecifierSamplers
(
const
TStructure
*
structure
TIntermSequence
*
newSequence
)
{
TFieldList
*
newFieldList
=
new
TFieldList
;
ASSERT
(
structure
-
>
containsSamplers
(
)
)
;
ASSERT
(
mStructureMap
.
find
(
structure
)
=
=
mStructureMap
.
end
(
)
)
;
StructureData
*
modifiedData
=
&
mStructureMap
[
structure
]
;
modifiedData
-
>
modified
=
nullptr
;
modifiedData
-
>
fieldMap
.
resize
(
structure
-
>
fields
(
)
.
size
(
)
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
)
;
for
(
size_t
fieldIndex
=
0
;
fieldIndex
<
structure
-
>
fields
(
)
.
size
(
)
;
+
+
fieldIndex
)
{
const
TField
*
field
=
structure
-
>
fields
(
)
[
fieldIndex
]
;
const
TType
&
fieldType
=
*
field
-
>
type
(
)
;
if
(
!
fieldType
.
isSampler
(
)
&
&
!
isRemovedStructType
(
fieldType
)
)
{
TType
*
newType
=
nullptr
;
if
(
fieldType
.
isStructureContainingSamplers
(
)
)
{
const
TStructure
*
fieldStruct
=
fieldType
.
getStruct
(
)
;
ASSERT
(
mStructureMap
.
find
(
fieldStruct
)
!
=
mStructureMap
.
end
(
)
)
;
const
TStructure
*
modifiedStruct
=
mStructureMap
[
fieldStruct
]
.
modified
;
ASSERT
(
modifiedStruct
)
;
newType
=
new
TType
(
modifiedStruct
true
)
;
if
(
fieldType
.
isArray
(
)
)
{
newType
-
>
makeArrays
(
fieldType
.
getArraySizes
(
)
)
;
}
}
else
{
newType
=
new
TType
(
fieldType
)
;
}
modifiedData
-
>
fieldMap
[
fieldIndex
]
=
static_cast
<
int
>
(
newFieldList
-
>
size
(
)
)
;
TField
*
newField
=
new
TField
(
newType
field
-
>
name
(
)
field
-
>
line
(
)
field
-
>
symbolType
(
)
)
;
newFieldList
-
>
push_back
(
newField
)
;
}
}
if
(
newFieldList
-
>
empty
(
)
)
{
return
;
}
modifiedData
-
>
modified
=
new
TStructure
(
mSymbolTable
structure
-
>
name
(
)
newFieldList
structure
-
>
symbolType
(
)
)
;
TType
*
newStructType
=
new
TType
(
modifiedData
-
>
modified
true
)
;
TVariable
*
newStructVar
=
new
TVariable
(
mSymbolTable
kEmptyImmutableString
newStructType
SymbolType
:
:
Empty
)
;
TIntermSymbol
*
newStructRef
=
new
TIntermSymbol
(
newStructVar
)
;
TIntermDeclaration
*
structDecl
=
new
TIntermDeclaration
;
structDecl
-
>
appendDeclarator
(
newStructRef
)
;
newSequence
-
>
push_back
(
structDecl
)
;
}
bool
isRemovedStructType
(
const
TType
&
type
)
const
{
const
TStructure
*
structure
=
type
.
getStruct
(
)
;
if
(
structure
=
=
nullptr
)
{
return
false
;
}
auto
iter
=
mStructureMap
.
find
(
structure
)
;
return
iter
!
=
mStructureMap
.
end
(
)
&
&
iter
-
>
second
.
modified
=
=
nullptr
;
}
void
extractStructSamplerUniforms
(
const
TVariable
&
variable
const
TStructure
*
structure
TIntermSequence
*
newSequence
)
{
ASSERT
(
structure
-
>
containsSamplers
(
)
)
;
ASSERT
(
mStructureMap
.
find
(
structure
)
!
=
mStructureMap
.
end
(
)
)
;
const
TType
&
type
=
variable
.
getType
(
)
;
enterArray
(
type
)
;
for
(
const
TField
*
field
:
structure
-
>
fields
(
)
)
{
extractFieldSamplers
(
variable
.
name
(
)
.
data
(
)
field
newSequence
)
;
}
const
TStructure
*
modified
=
mStructureMap
[
structure
]
.
modified
;
if
(
modified
!
=
nullptr
)
{
TType
*
newType
=
new
TType
(
modified
false
)
;
if
(
type
.
isArray
(
)
)
{
newType
-
>
makeArrays
(
type
.
getArraySizes
(
)
)
;
}
newType
-
>
setQualifier
(
EvqUniform
)
;
const
TVariable
*
newVariable
=
new
TVariable
(
mSymbolTable
variable
.
name
(
)
newType
variable
.
symbolType
(
)
)
;
TIntermDeclaration
*
newDecl
=
new
TIntermDeclaration
(
)
;
newDecl
-
>
appendDeclarator
(
new
TIntermSymbol
(
newVariable
)
)
;
newSequence
-
>
push_back
(
newDecl
)
;
ASSERT
(
mStructureUniformMap
.
find
(
&
variable
)
=
=
mStructureUniformMap
.
end
(
)
)
;
mStructureUniformMap
[
&
variable
]
=
newVariable
;
}
else
{
mRemovedUniformsCount
+
+
;
}
exitArray
(
type
)
;
}
void
extractFieldSamplers
(
const
std
:
:
string
&
prefix
const
TField
*
field
TIntermSequence
*
newSequence
)
{
const
TType
&
fieldType
=
*
field
-
>
type
(
)
;
if
(
fieldType
.
isSampler
(
)
|
|
fieldType
.
isStructureContainingSamplers
(
)
)
{
std
:
:
string
newPrefix
=
prefix
+
"
_
"
+
field
-
>
name
(
)
.
data
(
)
;
if
(
fieldType
.
isSampler
(
)
)
{
extractSampler
(
newPrefix
fieldType
newSequence
)
;
}
else
{
enterArray
(
fieldType
)
;
const
TStructure
*
structure
=
fieldType
.
getStruct
(
)
;
for
(
const
TField
*
nestedField
:
structure
-
>
fields
(
)
)
{
extractFieldSamplers
(
newPrefix
nestedField
newSequence
)
;
}
exitArray
(
fieldType
)
;
}
}
}
void
GenerateArraySizesFromStack
(
TVector
<
unsigned
int
>
*
sizesOut
)
{
sizesOut
-
>
reserve
(
mArraySizeStack
.
size
(
)
)
;
for
(
auto
it
=
mArraySizeStack
.
rbegin
(
)
;
it
!
=
mArraySizeStack
.
rend
(
)
;
+
+
it
)
{
sizesOut
-
>
push_back
(
*
it
)
;
}
}
void
extractSampler
(
const
std
:
:
string
&
newName
const
TType
&
fieldType
TIntermSequence
*
newSequence
)
{
ASSERT
(
fieldType
.
isSampler
(
)
)
;
TType
*
newType
=
new
TType
(
fieldType
)
;
TVector
<
unsigned
int
>
parentArraySizes
;
GenerateArraySizesFromStack
(
&
parentArraySizes
)
;
newType
-
>
makeArrays
(
parentArraySizes
)
;
ImmutableStringBuilder
nameBuilder
(
newName
.
size
(
)
+
1
)
;
nameBuilder
<
<
newName
;
newType
-
>
setQualifier
(
EvqUniform
)
;
TVariable
*
newVariable
=
new
TVariable
(
mSymbolTable
nameBuilder
newType
SymbolType
:
:
AngleInternal
)
;
TIntermSymbol
*
newSymbol
=
new
TIntermSymbol
(
newVariable
)
;
TIntermDeclaration
*
samplerDecl
=
new
TIntermDeclaration
;
samplerDecl
-
>
appendDeclarator
(
newSymbol
)
;
newSequence
-
>
push_back
(
samplerDecl
)
;
ASSERT
(
mExtractedSamplers
.
find
(
newName
)
=
=
mExtractedSamplers
.
end
(
)
)
;
mExtractedSamplers
[
newName
]
=
newVariable
;
}
void
enterArray
(
const
TType
&
arrayType
)
{
const
TSpan
<
const
unsigned
int
>
&
arraySizes
=
arrayType
.
getArraySizes
(
)
;
for
(
auto
it
=
arraySizes
.
rbegin
(
)
;
it
!
=
arraySizes
.
rend
(
)
;
+
+
it
)
{
unsigned
int
arraySize
=
*
it
;
mArraySizeStack
.
push_back
(
arraySize
)
;
}
}
void
exitArray
(
const
TType
&
arrayType
)
{
mArraySizeStack
.
resize
(
mArraySizeStack
.
size
(
)
-
arrayType
.
getNumArraySizes
(
)
)
;
}
TCompiler
*
mCompiler
;
int
mRemovedUniformsCount
;
StructureMap
mStructureMap
;
StructureUniformMap
mStructureUniformMap
;
ExtractedSamplerMap
mExtractedSamplers
;
TVector
<
unsigned
int
>
mArraySizeStack
;
}
;
}
bool
RewriteStructSamplers
(
TCompiler
*
compiler
TIntermBlock
*
root
TSymbolTable
*
symbolTable
int
*
removedUniformsCountOut
)
{
RewriteStructSamplersTraverser
traverser
(
compiler
symbolTable
)
;
root
-
>
traverse
(
&
traverser
)
;
*
removedUniformsCountOut
=
traverser
.
removedUniformsCount
(
)
;
return
traverser
.
updateTree
(
compiler
root
)
;
}
}
