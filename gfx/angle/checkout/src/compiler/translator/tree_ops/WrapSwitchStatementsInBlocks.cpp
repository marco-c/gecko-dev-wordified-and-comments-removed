#
include
"
compiler
/
translator
/
tree_ops
/
WrapSwitchStatementsInBlocks
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
class
WrapSwitchStatementsInBlocksTraverser
:
public
TIntermTraverser
{
public
:
WrapSwitchStatementsInBlocksTraverser
(
)
:
TIntermTraverser
(
true
false
false
)
{
}
bool
visitSwitch
(
Visit
visit
TIntermSwitch
*
node
)
override
;
}
;
bool
WrapSwitchStatementsInBlocksTraverser
:
:
visitSwitch
(
Visit
TIntermSwitch
*
node
)
{
std
:
:
vector
<
TIntermDeclaration
*
>
declarations
;
TIntermSequence
*
statementList
=
node
-
>
getStatementList
(
)
-
>
getSequence
(
)
;
for
(
TIntermNode
*
statement
:
*
statementList
)
{
TIntermDeclaration
*
asDeclaration
=
statement
-
>
getAsDeclarationNode
(
)
;
if
(
asDeclaration
)
{
declarations
.
push_back
(
asDeclaration
)
;
}
}
if
(
declarations
.
empty
(
)
)
{
return
true
;
}
TIntermBlock
*
wrapperBlock
=
new
TIntermBlock
(
)
;
for
(
TIntermDeclaration
*
declaration
:
declarations
)
{
ASSERT
(
declaration
-
>
getSequence
(
)
-
>
size
(
)
=
=
1
)
;
TIntermDeclaration
*
declarationInBlock
=
new
TIntermDeclaration
(
)
;
TIntermSymbol
*
declaratorAsSymbol
=
declaration
-
>
getSequence
(
)
-
>
at
(
0
)
-
>
getAsSymbolNode
(
)
;
if
(
declaratorAsSymbol
)
{
TIntermSequence
emptyReplacement
;
mMultiReplacements
.
push_back
(
NodeReplaceWithMultipleEntry
(
node
-
>
getStatementList
(
)
declaration
emptyReplacement
)
)
;
declarationInBlock
-
>
appendDeclarator
(
declaratorAsSymbol
-
>
deepCopy
(
)
)
;
ASSERT
(
declaration
!
=
statementList
-
>
back
(
)
)
;
}
else
{
TIntermBinary
*
declaratorAsBinary
=
declaration
-
>
getSequence
(
)
-
>
at
(
0
)
-
>
getAsBinaryNode
(
)
;
ASSERT
(
declaratorAsBinary
)
;
TIntermBinary
*
initAssignment
=
new
TIntermBinary
(
EOpAssign
declaratorAsBinary
-
>
getLeft
(
)
declaratorAsBinary
-
>
getRight
(
)
)
;
queueReplacementWithParent
(
node
-
>
getStatementList
(
)
declaration
initAssignment
OriginalNode
:
:
IS_DROPPED
)
;
declarationInBlock
-
>
appendDeclarator
(
declaratorAsBinary
-
>
getLeft
(
)
-
>
deepCopy
(
)
)
;
}
wrapperBlock
-
>
appendStatement
(
declarationInBlock
)
;
}
wrapperBlock
-
>
appendStatement
(
node
)
;
queueReplacement
(
wrapperBlock
OriginalNode
:
:
BECOMES_CHILD
)
;
return
true
;
}
}
void
WrapSwitchStatementsInBlocks
(
TIntermBlock
*
root
)
{
WrapSwitchStatementsInBlocksTraverser
traverser
;
root
-
>
traverse
(
&
traverser
)
;
traverser
.
updateTree
(
)
;
}
}
