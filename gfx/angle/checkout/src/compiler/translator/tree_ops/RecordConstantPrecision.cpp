#
include
"
compiler
/
translator
/
tree_ops
/
RecordConstantPrecision
.
h
"
#
include
"
compiler
/
translator
/
InfoSink
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
class
RecordConstantPrecisionTraverser
:
public
TIntermTraverser
{
public
:
RecordConstantPrecisionTraverser
(
TSymbolTable
*
symbolTable
)
;
void
visitConstantUnion
(
TIntermConstantUnion
*
node
)
override
;
void
nextIteration
(
)
;
bool
foundHigherPrecisionConstant
(
)
const
{
return
mFoundHigherPrecisionConstant
;
}
protected
:
bool
operandAffectsParentOperationPrecision
(
TIntermTyped
*
operand
)
;
bool
mFoundHigherPrecisionConstant
;
}
;
RecordConstantPrecisionTraverser
:
:
RecordConstantPrecisionTraverser
(
TSymbolTable
*
symbolTable
)
:
TIntermTraverser
(
true
false
true
symbolTable
)
mFoundHigherPrecisionConstant
(
false
)
{
}
bool
RecordConstantPrecisionTraverser
:
:
operandAffectsParentOperationPrecision
(
TIntermTyped
*
operand
)
{
if
(
getParentNode
(
)
-
>
getAsCaseNode
(
)
|
|
getParentNode
(
)
-
>
getAsBlock
(
)
)
{
return
false
;
}
const
TIntermBinary
*
parentAsBinary
=
getParentNode
(
)
-
>
getAsBinaryNode
(
)
;
if
(
parentAsBinary
!
=
nullptr
)
{
switch
(
parentAsBinary
-
>
getOp
(
)
)
{
case
EOpInitialize
:
case
EOpAssign
:
case
EOpIndexDirect
:
case
EOpIndexDirectStruct
:
case
EOpIndexDirectInterfaceBlock
:
case
EOpIndexIndirect
:
return
false
;
default
:
break
;
}
TIntermTyped
*
otherOperand
=
parentAsBinary
-
>
getRight
(
)
;
if
(
otherOperand
=
=
operand
)
{
otherOperand
=
parentAsBinary
-
>
getLeft
(
)
;
}
if
(
otherOperand
-
>
getAsConstantUnion
(
)
=
=
nullptr
&
&
otherOperand
-
>
getPrecision
(
)
>
=
operand
-
>
getPrecision
(
)
)
{
return
false
;
}
}
TIntermAggregate
*
parentAsAggregate
=
getParentNode
(
)
-
>
getAsAggregate
(
)
;
if
(
parentAsAggregate
!
=
nullptr
)
{
if
(
!
parentAsAggregate
-
>
gotPrecisionFromChildren
(
)
)
{
return
false
;
}
if
(
parentAsAggregate
-
>
isConstructor
(
)
&
&
parentAsAggregate
-
>
getBasicType
(
)
=
=
EbtBool
)
{
return
false
;
}
TIntermSequence
*
parameters
=
parentAsAggregate
-
>
getSequence
(
)
;
for
(
TIntermNode
*
parameter
:
*
parameters
)
{
const
TIntermTyped
*
typedParameter
=
parameter
-
>
getAsTyped
(
)
;
if
(
parameter
!
=
operand
&
&
typedParameter
!
=
nullptr
&
&
parameter
-
>
getAsConstantUnion
(
)
=
=
nullptr
&
&
typedParameter
-
>
getPrecision
(
)
>
=
operand
-
>
getPrecision
(
)
)
{
return
false
;
}
}
}
return
true
;
}
void
RecordConstantPrecisionTraverser
:
:
visitConstantUnion
(
TIntermConstantUnion
*
node
)
{
if
(
mFoundHigherPrecisionConstant
)
return
;
if
(
node
-
>
getPrecision
(
)
<
EbpMedium
)
return
;
if
(
!
operandAffectsParentOperationPrecision
(
node
)
)
return
;
TIntermDeclaration
*
variableDeclaration
=
nullptr
;
TVariable
*
variable
=
DeclareTempVariable
(
mSymbolTable
node
EvqConst
&
variableDeclaration
)
;
insertStatementInParentBlock
(
variableDeclaration
)
;
queueReplacement
(
CreateTempSymbolNode
(
variable
)
OriginalNode
:
:
IS_DROPPED
)
;
mFoundHigherPrecisionConstant
=
true
;
}
void
RecordConstantPrecisionTraverser
:
:
nextIteration
(
)
{
mFoundHigherPrecisionConstant
=
false
;
}
}
bool
RecordConstantPrecision
(
TCompiler
*
compiler
TIntermNode
*
root
TSymbolTable
*
symbolTable
)
{
RecordConstantPrecisionTraverser
traverser
(
symbolTable
)
;
do
{
traverser
.
nextIteration
(
)
;
root
-
>
traverse
(
&
traverser
)
;
if
(
traverser
.
foundHigherPrecisionConstant
(
)
)
{
if
(
!
traverser
.
updateTree
(
compiler
root
)
)
{
return
false
;
}
}
}
while
(
traverser
.
foundHigherPrecisionConstant
(
)
)
;
return
true
;
}
}
