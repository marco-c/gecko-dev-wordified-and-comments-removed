#
include
"
compiler
/
translator
/
tree_ops
/
RemoveUnreferencedVariables
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
class
CollectVariableRefCountsTraverser
:
public
TIntermTraverser
{
public
:
CollectVariableRefCountsTraverser
(
)
;
using
RefCountMap
=
std
:
:
unordered_map
<
int
unsigned
int
>
;
RefCountMap
&
getSymbolIdRefCounts
(
)
{
return
mSymbolIdRefCounts
;
}
RefCountMap
&
getStructIdRefCounts
(
)
{
return
mStructIdRefCounts
;
}
void
visitSymbol
(
TIntermSymbol
*
node
)
override
;
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
;
void
visitFunctionPrototype
(
TIntermFunctionPrototype
*
node
)
override
;
private
:
void
incrementStructTypeRefCount
(
const
TType
&
type
)
;
RefCountMap
mSymbolIdRefCounts
;
RefCountMap
mStructIdRefCounts
;
}
;
CollectVariableRefCountsTraverser
:
:
CollectVariableRefCountsTraverser
(
)
:
TIntermTraverser
(
true
false
false
)
{
}
void
CollectVariableRefCountsTraverser
:
:
incrementStructTypeRefCount
(
const
TType
&
type
)
{
if
(
type
.
isInterfaceBlock
(
)
)
{
const
auto
*
block
=
type
.
getInterfaceBlock
(
)
;
ASSERT
(
block
)
;
for
(
const
auto
&
field
:
block
-
>
fields
(
)
)
{
ASSERT
(
!
field
-
>
type
(
)
-
>
isInterfaceBlock
(
)
)
;
incrementStructTypeRefCount
(
*
field
-
>
type
(
)
)
;
}
return
;
}
const
auto
*
structure
=
type
.
getStruct
(
)
;
if
(
structure
!
=
nullptr
)
{
auto
structIter
=
mStructIdRefCounts
.
find
(
structure
-
>
uniqueId
(
)
.
get
(
)
)
;
if
(
structIter
=
=
mStructIdRefCounts
.
end
(
)
)
{
mStructIdRefCounts
[
structure
-
>
uniqueId
(
)
.
get
(
)
]
=
1u
;
for
(
const
auto
&
field
:
structure
-
>
fields
(
)
)
{
incrementStructTypeRefCount
(
*
field
-
>
type
(
)
)
;
}
return
;
}
+
+
(
structIter
-
>
second
)
;
}
}
void
CollectVariableRefCountsTraverser
:
:
visitSymbol
(
TIntermSymbol
*
node
)
{
incrementStructTypeRefCount
(
node
-
>
getType
(
)
)
;
auto
iter
=
mSymbolIdRefCounts
.
find
(
node
-
>
uniqueId
(
)
.
get
(
)
)
;
if
(
iter
=
=
mSymbolIdRefCounts
.
end
(
)
)
{
mSymbolIdRefCounts
[
node
-
>
uniqueId
(
)
.
get
(
)
]
=
1u
;
return
;
}
+
+
(
iter
-
>
second
)
;
}
bool
CollectVariableRefCountsTraverser
:
:
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
{
incrementStructTypeRefCount
(
node
-
>
getType
(
)
)
;
return
true
;
}
void
CollectVariableRefCountsTraverser
:
:
visitFunctionPrototype
(
TIntermFunctionPrototype
*
node
)
{
incrementStructTypeRefCount
(
node
-
>
getType
(
)
)
;
size_t
paramCount
=
node
-
>
getFunction
(
)
-
>
getParamCount
(
)
;
for
(
size_t
i
=
0
;
i
<
paramCount
;
+
+
i
)
{
incrementStructTypeRefCount
(
node
-
>
getFunction
(
)
-
>
getParam
(
i
)
-
>
getType
(
)
)
;
}
}
class
RemoveUnreferencedVariablesTraverser
:
public
TIntermTraverser
{
public
:
RemoveUnreferencedVariablesTraverser
(
CollectVariableRefCountsTraverser
:
:
RefCountMap
*
symbolIdRefCounts
CollectVariableRefCountsTraverser
:
:
RefCountMap
*
structIdRefCounts
TSymbolTable
*
symbolTable
)
;
bool
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
node
)
override
;
void
visitSymbol
(
TIntermSymbol
*
node
)
override
;
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
;
void
traverseBlock
(
TIntermBlock
*
block
)
override
;
void
traverseLoop
(
TIntermLoop
*
loop
)
override
;
private
:
void
removeVariableDeclaration
(
TIntermDeclaration
*
node
TIntermTyped
*
declarator
)
;
void
decrementStructTypeRefCount
(
const
TType
&
type
)
;
CollectVariableRefCountsTraverser
:
:
RefCountMap
*
mSymbolIdRefCounts
;
CollectVariableRefCountsTraverser
:
:
RefCountMap
*
mStructIdRefCounts
;
bool
mRemoveReferences
;
}
;
RemoveUnreferencedVariablesTraverser
:
:
RemoveUnreferencedVariablesTraverser
(
CollectVariableRefCountsTraverser
:
:
RefCountMap
*
symbolIdRefCounts
CollectVariableRefCountsTraverser
:
:
RefCountMap
*
structIdRefCounts
TSymbolTable
*
symbolTable
)
:
TIntermTraverser
(
true
false
true
symbolTable
)
mSymbolIdRefCounts
(
symbolIdRefCounts
)
mStructIdRefCounts
(
structIdRefCounts
)
mRemoveReferences
(
false
)
{
}
void
RemoveUnreferencedVariablesTraverser
:
:
decrementStructTypeRefCount
(
const
TType
&
type
)
{
auto
*
structure
=
type
.
getStruct
(
)
;
if
(
structure
!
=
nullptr
)
{
ASSERT
(
mStructIdRefCounts
-
>
find
(
structure
-
>
uniqueId
(
)
.
get
(
)
)
!
=
mStructIdRefCounts
-
>
end
(
)
)
;
unsigned
int
structRefCount
=
-
-
(
*
mStructIdRefCounts
)
[
structure
-
>
uniqueId
(
)
.
get
(
)
]
;
if
(
structRefCount
=
=
0
)
{
for
(
const
auto
&
field
:
structure
-
>
fields
(
)
)
{
decrementStructTypeRefCount
(
*
field
-
>
type
(
)
)
;
}
}
}
}
void
RemoveUnreferencedVariablesTraverser
:
:
removeVariableDeclaration
(
TIntermDeclaration
*
node
TIntermTyped
*
declarator
)
{
if
(
declarator
-
>
getType
(
)
.
isStructSpecifier
(
)
&
&
!
declarator
-
>
getType
(
)
.
isNamelessStruct
(
)
)
{
unsigned
int
structId
=
declarator
-
>
getType
(
)
.
getStruct
(
)
-
>
uniqueId
(
)
.
get
(
)
;
unsigned
int
structRefCountInThisDeclarator
=
1u
;
if
(
declarator
-
>
getAsBinaryNode
(
)
&
&
declarator
-
>
getAsBinaryNode
(
)
-
>
getRight
(
)
-
>
getAsAggregate
(
)
)
{
ASSERT
(
declarator
-
>
getAsBinaryNode
(
)
-
>
getLeft
(
)
-
>
getType
(
)
.
getStruct
(
)
=
=
declarator
-
>
getType
(
)
.
getStruct
(
)
)
;
ASSERT
(
declarator
-
>
getAsBinaryNode
(
)
-
>
getRight
(
)
-
>
getType
(
)
.
getStruct
(
)
=
=
declarator
-
>
getType
(
)
.
getStruct
(
)
)
;
structRefCountInThisDeclarator
=
2u
;
}
if
(
(
*
mStructIdRefCounts
)
[
structId
]
>
structRefCountInThisDeclarator
)
{
if
(
declarator
-
>
getAsSymbolNode
(
)
&
&
declarator
-
>
getAsSymbolNode
(
)
-
>
variable
(
)
.
symbolType
(
)
=
=
SymbolType
:
:
Empty
)
{
return
;
}
TVariable
*
emptyVariable
=
new
TVariable
(
mSymbolTable
ImmutableString
(
"
"
)
new
TType
(
declarator
-
>
getType
(
)
)
SymbolType
:
:
Empty
)
;
queueReplacementWithParent
(
node
declarator
new
TIntermSymbol
(
emptyVariable
)
OriginalNode
:
:
IS_DROPPED
)
;
return
;
}
}
if
(
getParentNode
(
)
-
>
getAsBlock
(
)
)
{
TIntermSequence
emptyReplacement
;
mMultiReplacements
.
push_back
(
NodeReplaceWithMultipleEntry
(
getParentNode
(
)
-
>
getAsBlock
(
)
node
emptyReplacement
)
)
;
}
else
{
ASSERT
(
getParentNode
(
)
-
>
getAsLoopNode
(
)
)
;
queueReplacement
(
nullptr
OriginalNode
:
:
IS_DROPPED
)
;
}
}
bool
RemoveUnreferencedVariablesTraverser
:
:
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
node
)
{
if
(
visit
=
=
PreVisit
)
{
ASSERT
(
node
-
>
getSequence
(
)
-
>
size
(
)
=
=
1u
)
;
TIntermTyped
*
declarator
=
node
-
>
getSequence
(
)
-
>
back
(
)
-
>
getAsTyped
(
)
;
ASSERT
(
declarator
)
;
TQualifier
qualifier
=
declarator
-
>
getQualifier
(
)
;
if
(
qualifier
!
=
EvqTemporary
&
&
qualifier
!
=
EvqGlobal
&
&
qualifier
!
=
EvqConst
)
{
return
true
;
}
bool
canRemoveVariable
=
false
;
TIntermSymbol
*
symbolNode
=
declarator
-
>
getAsSymbolNode
(
)
;
if
(
symbolNode
!
=
nullptr
)
{
canRemoveVariable
=
(
*
mSymbolIdRefCounts
)
[
symbolNode
-
>
uniqueId
(
)
.
get
(
)
]
=
=
1u
|
|
symbolNode
-
>
variable
(
)
.
symbolType
(
)
=
=
SymbolType
:
:
Empty
;
}
TIntermBinary
*
initNode
=
declarator
-
>
getAsBinaryNode
(
)
;
if
(
initNode
!
=
nullptr
)
{
ASSERT
(
initNode
-
>
getLeft
(
)
-
>
getAsSymbolNode
(
)
)
;
int
symbolId
=
initNode
-
>
getLeft
(
)
-
>
getAsSymbolNode
(
)
-
>
uniqueId
(
)
.
get
(
)
;
canRemoveVariable
=
(
*
mSymbolIdRefCounts
)
[
symbolId
]
=
=
1u
&
&
!
initNode
-
>
getRight
(
)
-
>
hasSideEffects
(
)
;
}
if
(
canRemoveVariable
)
{
removeVariableDeclaration
(
node
declarator
)
;
mRemoveReferences
=
true
;
}
return
true
;
}
ASSERT
(
visit
=
=
PostVisit
)
;
mRemoveReferences
=
false
;
return
true
;
}
void
RemoveUnreferencedVariablesTraverser
:
:
visitSymbol
(
TIntermSymbol
*
node
)
{
if
(
mRemoveReferences
)
{
ASSERT
(
mSymbolIdRefCounts
-
>
find
(
node
-
>
uniqueId
(
)
.
get
(
)
)
!
=
mSymbolIdRefCounts
-
>
end
(
)
)
;
-
-
(
*
mSymbolIdRefCounts
)
[
node
-
>
uniqueId
(
)
.
get
(
)
]
;
decrementStructTypeRefCount
(
node
-
>
getType
(
)
)
;
}
}
bool
RemoveUnreferencedVariablesTraverser
:
:
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
{
if
(
visit
=
=
PreVisit
&
&
mRemoveReferences
)
{
decrementStructTypeRefCount
(
node
-
>
getType
(
)
)
;
}
return
true
;
}
void
RemoveUnreferencedVariablesTraverser
:
:
traverseBlock
(
TIntermBlock
*
node
)
{
ScopedNodeInTraversalPath
addToPath
(
this
node
)
;
bool
visit
=
true
;
TIntermSequence
*
sequence
=
node
-
>
getSequence
(
)
;
if
(
preVisit
)
visit
=
visitBlock
(
PreVisit
node
)
;
if
(
visit
)
{
for
(
auto
iter
=
sequence
-
>
rbegin
(
)
;
iter
!
=
sequence
-
>
rend
(
)
;
+
+
iter
)
{
(
*
iter
)
-
>
traverse
(
this
)
;
if
(
visit
&
&
inVisit
)
{
if
(
(
iter
+
1
)
!
=
sequence
-
>
rend
(
)
)
visit
=
visitBlock
(
InVisit
node
)
;
}
}
}
if
(
visit
&
&
postVisit
)
visitBlock
(
PostVisit
node
)
;
}
void
RemoveUnreferencedVariablesTraverser
:
:
traverseLoop
(
TIntermLoop
*
node
)
{
ScopedNodeInTraversalPath
addToPath
(
this
node
)
;
bool
visit
=
true
;
if
(
preVisit
)
visit
=
visitLoop
(
PreVisit
node
)
;
if
(
visit
)
{
ASSERT
(
node
-
>
getExpression
(
)
=
=
nullptr
|
|
node
-
>
getExpression
(
)
-
>
getAsDeclarationNode
(
)
=
=
nullptr
)
;
ASSERT
(
node
-
>
getCondition
(
)
=
=
nullptr
|
|
node
-
>
getCondition
(
)
-
>
getAsDeclarationNode
(
)
=
=
nullptr
)
;
if
(
node
-
>
getBody
(
)
)
node
-
>
getBody
(
)
-
>
traverse
(
this
)
;
if
(
node
-
>
getInit
(
)
)
node
-
>
getInit
(
)
-
>
traverse
(
this
)
;
}
if
(
visit
&
&
postVisit
)
visitLoop
(
PostVisit
node
)
;
}
}
void
RemoveUnreferencedVariables
(
TIntermBlock
*
root
TSymbolTable
*
symbolTable
)
{
CollectVariableRefCountsTraverser
collector
;
root
-
>
traverse
(
&
collector
)
;
RemoveUnreferencedVariablesTraverser
traverser
(
&
collector
.
getSymbolIdRefCounts
(
)
&
collector
.
getStructIdRefCounts
(
)
symbolTable
)
;
root
-
>
traverse
(
&
traverser
)
;
traverser
.
updateTree
(
)
;
}
}
