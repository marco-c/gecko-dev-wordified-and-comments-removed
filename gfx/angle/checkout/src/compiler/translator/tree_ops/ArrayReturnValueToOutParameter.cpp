#
include
"
compiler
/
translator
/
tree_ops
/
ArrayReturnValueToOutParameter
.
h
"
#
include
<
map
>
#
include
"
compiler
/
translator
/
StaticType
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
constexpr
const
ImmutableString
kReturnValueVariableName
(
"
angle_return
"
)
;
class
ArrayReturnValueToOutParameterTraverser
:
private
TIntermTraverser
{
public
:
static
void
apply
(
TIntermNode
*
root
TSymbolTable
*
symbolTable
)
;
private
:
ArrayReturnValueToOutParameterTraverser
(
TSymbolTable
*
symbolTable
)
;
void
visitFunctionPrototype
(
TIntermFunctionPrototype
*
node
)
override
;
bool
visitFunctionDefinition
(
Visit
visit
TIntermFunctionDefinition
*
node
)
override
;
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
;
bool
visitBranch
(
Visit
visit
TIntermBranch
*
node
)
override
;
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
;
TIntermAggregate
*
createReplacementCall
(
TIntermAggregate
*
originalCall
TIntermTyped
*
returnValueTarget
)
;
TIntermFunctionDefinition
*
mFunctionWithArrayReturnValue
;
struct
ChangedFunction
{
const
TVariable
*
returnValueVariable
;
const
TFunction
*
func
;
}
;
std
:
:
map
<
int
ChangedFunction
>
mChangedFunctions
;
}
;
TIntermAggregate
*
ArrayReturnValueToOutParameterTraverser
:
:
createReplacementCall
(
TIntermAggregate
*
originalCall
TIntermTyped
*
returnValueTarget
)
{
TIntermSequence
*
replacementArguments
=
new
TIntermSequence
(
)
;
TIntermSequence
*
originalArguments
=
originalCall
-
>
getSequence
(
)
;
for
(
auto
&
arg
:
*
originalArguments
)
{
replacementArguments
-
>
push_back
(
arg
)
;
}
replacementArguments
-
>
push_back
(
returnValueTarget
)
;
ASSERT
(
originalCall
-
>
getFunction
(
)
)
;
const
TSymbolUniqueId
&
originalId
=
originalCall
-
>
getFunction
(
)
-
>
uniqueId
(
)
;
TIntermAggregate
*
replacementCall
=
TIntermAggregate
:
:
CreateFunctionCall
(
*
mChangedFunctions
[
originalId
.
get
(
)
]
.
func
replacementArguments
)
;
replacementCall
-
>
setLine
(
originalCall
-
>
getLine
(
)
)
;
return
replacementCall
;
}
void
ArrayReturnValueToOutParameterTraverser
:
:
apply
(
TIntermNode
*
root
TSymbolTable
*
symbolTable
)
{
ArrayReturnValueToOutParameterTraverser
arrayReturnValueToOutParam
(
symbolTable
)
;
root
-
>
traverse
(
&
arrayReturnValueToOutParam
)
;
arrayReturnValueToOutParam
.
updateTree
(
)
;
}
ArrayReturnValueToOutParameterTraverser
:
:
ArrayReturnValueToOutParameterTraverser
(
TSymbolTable
*
symbolTable
)
:
TIntermTraverser
(
true
false
true
symbolTable
)
mFunctionWithArrayReturnValue
(
nullptr
)
{
}
bool
ArrayReturnValueToOutParameterTraverser
:
:
visitFunctionDefinition
(
Visit
visit
TIntermFunctionDefinition
*
node
)
{
if
(
node
-
>
getFunctionPrototype
(
)
-
>
isArray
(
)
&
&
visit
=
=
PreVisit
)
{
mFunctionWithArrayReturnValue
=
node
;
}
if
(
visit
=
=
PostVisit
)
{
mFunctionWithArrayReturnValue
=
nullptr
;
}
return
true
;
}
void
ArrayReturnValueToOutParameterTraverser
:
:
visitFunctionPrototype
(
TIntermFunctionPrototype
*
node
)
{
if
(
node
-
>
isArray
(
)
)
{
const
TSymbolUniqueId
&
functionId
=
node
-
>
getFunction
(
)
-
>
uniqueId
(
)
;
if
(
mChangedFunctions
.
find
(
functionId
.
get
(
)
)
=
=
mChangedFunctions
.
end
(
)
)
{
TType
*
returnValueVariableType
=
new
TType
(
node
-
>
getType
(
)
)
;
returnValueVariableType
-
>
setQualifier
(
EvqOut
)
;
ChangedFunction
changedFunction
;
changedFunction
.
returnValueVariable
=
new
TVariable
(
mSymbolTable
kReturnValueVariableName
returnValueVariableType
SymbolType
:
:
AngleInternal
)
;
TFunction
*
func
=
new
TFunction
(
mSymbolTable
node
-
>
getFunction
(
)
-
>
name
(
)
node
-
>
getFunction
(
)
-
>
symbolType
(
)
StaticType
:
:
GetBasic
<
EbtVoid
>
(
)
false
)
;
for
(
size_t
i
=
0
;
i
<
node
-
>
getFunction
(
)
-
>
getParamCount
(
)
;
+
+
i
)
{
func
-
>
addParameter
(
node
-
>
getFunction
(
)
-
>
getParam
(
i
)
)
;
}
func
-
>
addParameter
(
changedFunction
.
returnValueVariable
)
;
changedFunction
.
func
=
func
;
mChangedFunctions
[
functionId
.
get
(
)
]
=
changedFunction
;
}
TIntermFunctionPrototype
*
replacement
=
new
TIntermFunctionPrototype
(
mChangedFunctions
[
functionId
.
get
(
)
]
.
func
)
;
replacement
-
>
setLine
(
node
-
>
getLine
(
)
)
;
queueReplacement
(
replacement
OriginalNode
:
:
IS_DROPPED
)
;
}
}
bool
ArrayReturnValueToOutParameterTraverser
:
:
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
{
ASSERT
(
!
node
-
>
isArray
(
)
|
|
node
-
>
getOp
(
)
!
=
EOpCallInternalRawFunction
)
;
if
(
visit
=
=
PreVisit
&
&
node
-
>
isArray
(
)
&
&
node
-
>
getOp
(
)
=
=
EOpCallFunctionInAST
)
{
TIntermBlock
*
parentBlock
=
getParentNode
(
)
-
>
getAsBlock
(
)
;
if
(
parentBlock
)
{
TIntermSequence
replacements
;
TIntermDeclaration
*
returnValueDeclaration
=
nullptr
;
TVariable
*
returnValue
=
DeclareTempVariable
(
mSymbolTable
new
TType
(
node
-
>
getType
(
)
)
EvqTemporary
&
returnValueDeclaration
)
;
replacements
.
push_back
(
returnValueDeclaration
)
;
TIntermSymbol
*
returnValueSymbol
=
CreateTempSymbolNode
(
returnValue
)
;
replacements
.
push_back
(
createReplacementCall
(
node
returnValueSymbol
)
)
;
mMultiReplacements
.
push_back
(
NodeReplaceWithMultipleEntry
(
parentBlock
node
replacements
)
)
;
}
return
false
;
}
return
true
;
}
bool
ArrayReturnValueToOutParameterTraverser
:
:
visitBranch
(
Visit
visit
TIntermBranch
*
node
)
{
if
(
mFunctionWithArrayReturnValue
&
&
node
-
>
getFlowOp
(
)
=
=
EOpReturn
)
{
TIntermSequence
replacements
;
TIntermTyped
*
expression
=
node
-
>
getExpression
(
)
;
ASSERT
(
expression
!
=
nullptr
)
;
const
TSymbolUniqueId
&
functionId
=
mFunctionWithArrayReturnValue
-
>
getFunction
(
)
-
>
uniqueId
(
)
;
ASSERT
(
mChangedFunctions
.
find
(
functionId
.
get
(
)
)
!
=
mChangedFunctions
.
end
(
)
)
;
TIntermSymbol
*
returnValueSymbol
=
new
TIntermSymbol
(
mChangedFunctions
[
functionId
.
get
(
)
]
.
returnValueVariable
)
;
TIntermBinary
*
replacementAssignment
=
new
TIntermBinary
(
EOpAssign
returnValueSymbol
expression
)
;
replacementAssignment
-
>
setLine
(
expression
-
>
getLine
(
)
)
;
replacements
.
push_back
(
replacementAssignment
)
;
TIntermBranch
*
replacementBranch
=
new
TIntermBranch
(
EOpReturn
nullptr
)
;
replacementBranch
-
>
setLine
(
node
-
>
getLine
(
)
)
;
replacements
.
push_back
(
replacementBranch
)
;
mMultiReplacements
.
push_back
(
NodeReplaceWithMultipleEntry
(
getParentNode
(
)
-
>
getAsBlock
(
)
node
replacements
)
)
;
}
return
false
;
}
bool
ArrayReturnValueToOutParameterTraverser
:
:
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
{
if
(
node
-
>
getOp
(
)
=
=
EOpAssign
&
&
node
-
>
getLeft
(
)
-
>
isArray
(
)
)
{
TIntermAggregate
*
rightAgg
=
node
-
>
getRight
(
)
-
>
getAsAggregate
(
)
;
ASSERT
(
rightAgg
=
=
nullptr
|
|
rightAgg
-
>
getOp
(
)
!
=
EOpCallInternalRawFunction
)
;
if
(
rightAgg
!
=
nullptr
&
&
rightAgg
-
>
getOp
(
)
=
=
EOpCallFunctionInAST
)
{
TIntermAggregate
*
replacementCall
=
createReplacementCall
(
rightAgg
node
-
>
getLeft
(
)
)
;
queueReplacement
(
replacementCall
OriginalNode
:
:
IS_DROPPED
)
;
}
}
return
false
;
}
}
void
ArrayReturnValueToOutParameter
(
TIntermNode
*
root
TSymbolTable
*
symbolTable
)
{
ArrayReturnValueToOutParameterTraverser
:
:
apply
(
root
symbolTable
)
;
}
}
