#
include
"
compiler
/
translator
/
tree_ops
/
RemoveInactiveInterfaceVariables
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
#
include
"
compiler
/
translator
/
util
.
h
"
namespace
sh
{
namespace
{
class
RemoveInactiveInterfaceVariablesTraverser
:
public
TIntermTraverser
{
public
:
RemoveInactiveInterfaceVariablesTraverser
(
TSymbolTable
*
symbolTable
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
attributes
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
inputVaryings
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
outputVariables
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
uniforms
const
std
:
:
vector
<
sh
:
:
InterfaceBlock
>
&
interfaceBlocks
bool
removeFragmentOutputs
)
;
bool
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
node
)
override
;
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
;
private
:
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
mAttributes
;
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
mInputVaryings
;
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
mOutputVariables
;
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
mUniforms
;
const
std
:
:
vector
<
sh
:
:
InterfaceBlock
>
&
mInterfaceBlocks
;
bool
mRemoveFragmentOutputs
;
}
;
RemoveInactiveInterfaceVariablesTraverser
:
:
RemoveInactiveInterfaceVariablesTraverser
(
TSymbolTable
*
symbolTable
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
attributes
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
inputVaryings
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
outputVariables
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
uniforms
const
std
:
:
vector
<
sh
:
:
InterfaceBlock
>
&
interfaceBlocks
bool
removeFragmentOutputs
)
:
TIntermTraverser
(
true
false
false
symbolTable
)
mAttributes
(
attributes
)
mInputVaryings
(
inputVaryings
)
mOutputVariables
(
outputVariables
)
mUniforms
(
uniforms
)
mInterfaceBlocks
(
interfaceBlocks
)
mRemoveFragmentOutputs
(
removeFragmentOutputs
)
{
}
template
<
typename
Variable
>
bool
IsVariableActive
(
const
std
:
:
vector
<
Variable
>
&
mVars
const
ImmutableString
&
name
)
{
for
(
const
Variable
&
var
:
mVars
)
{
if
(
name
=
=
var
.
name
)
{
return
var
.
active
;
}
}
UNREACHABLE
(
)
;
return
true
;
}
bool
RemoveInactiveInterfaceVariablesTraverser
:
:
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
node
)
{
ASSERT
(
node
-
>
getSequence
(
)
-
>
size
(
)
=
=
1u
)
;
TIntermTyped
*
declarator
=
node
-
>
getSequence
(
)
-
>
front
(
)
-
>
getAsTyped
(
)
;
ASSERT
(
declarator
)
;
TIntermSymbol
*
asSymbol
=
declarator
-
>
getAsSymbolNode
(
)
;
if
(
!
asSymbol
)
{
return
false
;
}
const
TType
&
type
=
declarator
-
>
getType
(
)
;
bool
removeDeclaration
=
false
;
const
TQualifier
qualifier
=
type
.
getQualifier
(
)
;
if
(
type
.
isInterfaceBlock
(
)
)
{
if
(
!
IsShaderIoBlock
(
type
.
getQualifier
(
)
)
&
&
type
.
getQualifier
(
)
!
=
EvqPatchIn
&
&
type
.
getQualifier
(
)
!
=
EvqPatchOut
)
{
removeDeclaration
=
!
IsVariableActive
(
mInterfaceBlocks
type
.
getInterfaceBlock
(
)
-
>
name
(
)
)
;
}
}
else
if
(
qualifier
=
=
EvqUniform
)
{
removeDeclaration
=
!
IsVariableActive
(
mUniforms
asSymbol
-
>
getName
(
)
)
;
}
else
if
(
qualifier
=
=
EvqAttribute
|
|
qualifier
=
=
EvqVertexIn
)
{
removeDeclaration
=
!
IsVariableActive
(
mAttributes
asSymbol
-
>
getName
(
)
)
;
}
else
if
(
IsShaderIn
(
qualifier
)
)
{
removeDeclaration
=
!
IsVariableActive
(
mInputVaryings
asSymbol
-
>
getName
(
)
)
;
}
else
if
(
qualifier
=
=
EvqFragmentOut
)
{
removeDeclaration
=
!
IsVariableActive
(
mOutputVariables
asSymbol
-
>
getName
(
)
)
&
&
mRemoveFragmentOutputs
;
}
if
(
removeDeclaration
)
{
TIntermSequence
replacement
;
if
(
type
.
isStructSpecifier
(
)
)
{
TType
*
structSpecifierType
=
new
TType
(
type
.
getStruct
(
)
true
)
;
TVariable
*
emptyVariable
=
new
TVariable
(
mSymbolTable
kEmptyImmutableString
structSpecifierType
SymbolType
:
:
Empty
)
;
TIntermDeclaration
*
declaration
=
new
TIntermDeclaration
(
)
;
declaration
-
>
appendDeclarator
(
new
TIntermSymbol
(
emptyVariable
)
)
;
replacement
.
push_back
(
declaration
)
;
}
mMultiReplacements
.
emplace_back
(
getParentNode
(
)
-
>
getAsBlock
(
)
node
std
:
:
move
(
replacement
)
)
;
}
return
false
;
}
bool
RemoveInactiveInterfaceVariablesTraverser
:
:
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
{
if
(
node
-
>
getOp
(
)
!
=
EOpAssign
)
{
return
false
;
}
TIntermSymbol
*
symbol
=
node
-
>
getLeft
(
)
-
>
getAsSymbolNode
(
)
;
if
(
symbol
=
=
nullptr
)
{
return
false
;
}
const
TQualifier
qualifier
=
symbol
-
>
getType
(
)
.
getQualifier
(
)
;
if
(
qualifier
!
=
EvqFragmentOut
|
|
IsVariableActive
(
mOutputVariables
symbol
-
>
getName
(
)
)
)
{
return
false
;
}
TIntermSequence
replacement
;
mMultiReplacements
.
emplace_back
(
getParentNode
(
)
-
>
getAsBlock
(
)
node
std
:
:
move
(
replacement
)
)
;
return
false
;
}
}
bool
RemoveInactiveInterfaceVariables
(
TCompiler
*
compiler
TIntermBlock
*
root
TSymbolTable
*
symbolTable
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
attributes
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
inputVaryings
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
outputVariables
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
uniforms
const
std
:
:
vector
<
sh
:
:
InterfaceBlock
>
&
interfaceBlocks
bool
removeFragmentOutputs
)
{
RemoveInactiveInterfaceVariablesTraverser
traverser
(
symbolTable
attributes
inputVaryings
outputVariables
uniforms
interfaceBlocks
removeFragmentOutputs
)
;
root
-
>
traverse
(
&
traverser
)
;
return
traverser
.
updateTree
(
compiler
root
)
;
}
}
