#
include
"
compiler
/
translator
/
tree_ops
/
d3d
/
AggregateAssignStructsInSSBOs
.
h
"
#
include
"
compiler
/
translator
/
StaticType
.
h
"
#
include
"
compiler
/
translator
/
Symbol
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
#
include
"
compiler
/
translator
/
util
.
h
"
namespace
sh
{
namespace
{
class
AggregateAssignStructsInSSBOsTraverser
:
public
TIntermTraverser
{
public
:
AggregateAssignStructsInSSBOsTraverser
(
TSymbolTable
*
symbolTable
)
:
TIntermTraverser
(
true
false
false
symbolTable
)
{
}
protected
:
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
{
const
TStructure
*
s
;
if
(
node
-
>
getOp
(
)
!
=
EOpAssign
)
{
return
true
;
}
else
if
(
!
IsInShaderStorageBlock
(
node
-
>
getLeft
(
)
)
)
{
return
true
;
}
else
if
(
!
(
s
=
node
-
>
getLeft
(
)
-
>
getType
(
)
.
getStruct
(
)
)
)
{
return
true
;
}
ASSERT
(
node
-
>
getRight
(
)
-
>
getType
(
)
.
getStruct
(
)
=
=
s
)
;
auto
*
block
=
new
TIntermBlock
(
)
;
for
(
int
i
=
0
;
i
<
static_cast
<
int
>
(
s
-
>
fields
(
)
.
size
(
)
)
;
+
+
i
)
{
auto
*
left
=
new
TIntermBinary
(
EOpIndexDirectStruct
node
-
>
getLeft
(
)
-
>
deepCopy
(
)
CreateIndexNode
(
i
)
)
;
auto
*
right
=
new
TIntermBinary
(
EOpIndexDirectStruct
node
-
>
getRight
(
)
-
>
deepCopy
(
)
CreateIndexNode
(
i
)
)
;
auto
*
assign
=
new
TIntermBinary
(
TOperator
:
:
EOpAssign
left
right
)
;
block
-
>
appendStatement
(
assign
)
;
}
queueReplacement
(
block
OriginalNode
:
:
IS_DROPPED
)
;
return
false
;
}
}
;
}
bool
AggregateAssignStructsInSSBOs
(
TCompiler
*
compiler
TIntermBlock
*
root
TSymbolTable
*
symbolTable
)
{
AggregateAssignStructsInSSBOsTraverser
traverser
(
symbolTable
)
;
root
-
>
traverse
(
&
traverser
)
;
return
traverser
.
updateTree
(
compiler
root
)
;
}
}
