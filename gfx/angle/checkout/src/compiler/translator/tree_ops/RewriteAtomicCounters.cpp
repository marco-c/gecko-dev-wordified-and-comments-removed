#
include
"
compiler
/
translator
/
tree_ops
/
RewriteAtomicCounters
.
h
"
#
include
"
compiler
/
translator
/
Compiler
.
h
"
#
include
"
compiler
/
translator
/
ImmutableStringBuilder
.
h
"
#
include
"
compiler
/
translator
/
StaticType
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
ReplaceVariable
.
h
"
namespace
sh
{
namespace
{
constexpr
ImmutableString
kAtomicCounterTypeName
=
ImmutableString
(
"
ANGLE_atomic_uint
"
)
;
constexpr
ImmutableString
kAtomicCountersVarName
=
ImmutableString
(
"
atomicCounters
"
)
;
constexpr
ImmutableString
kAtomicCounterFieldName
=
ImmutableString
(
"
counters
"
)
;
const
TVariable
*
DeclareAtomicCountersBuffers
(
TIntermBlock
*
root
TSymbolTable
*
symbolTable
)
{
TFieldList
*
fieldList
=
new
TFieldList
;
TType
*
counterType
=
new
TType
(
EbtUInt
)
;
counterType
-
>
makeArray
(
0
)
;
TField
*
countersField
=
new
TField
(
counterType
kAtomicCounterFieldName
TSourceLoc
(
)
SymbolType
:
:
AngleInternal
)
;
fieldList
-
>
push_back
(
countersField
)
;
TMemoryQualifier
coherentMemory
=
TMemoryQualifier
:
:
Create
(
)
;
coherentMemory
.
coherent
=
true
;
constexpr
uint32_t
kMaxAtomicCounterBuffers
=
8
;
return
DeclareInterfaceBlock
(
root
symbolTable
fieldList
EvqBuffer
coherentMemory
kMaxAtomicCounterBuffers
ImmutableString
(
vk
:
:
kAtomicCountersBlockName
)
kAtomicCountersVarName
)
;
}
TIntermConstantUnion
*
CreateUIntConstant
(
uint32_t
value
)
{
TType
*
constantType
=
new
TType
(
*
StaticType
:
:
GetBasic
<
EbtUInt
1
>
(
)
)
;
constantType
-
>
setQualifier
(
EvqConst
)
;
TConstantUnion
*
constantValue
=
new
TConstantUnion
;
constantValue
-
>
setUConst
(
value
)
;
return
new
TIntermConstantUnion
(
constantValue
*
constantType
)
;
}
TIntermTyped
*
CreateAtomicCounterConstant
(
TType
*
atomicCounterType
uint32_t
binding
uint32_t
offset
)
{
ASSERT
(
atomicCounterType
-
>
getBasicType
(
)
=
=
EbtStruct
)
;
TIntermSequence
*
arguments
=
new
TIntermSequence
(
)
;
arguments
-
>
push_back
(
CreateUIntConstant
(
binding
)
)
;
arguments
-
>
push_back
(
CreateUIntConstant
(
offset
)
)
;
return
TIntermAggregate
:
:
CreateConstructor
(
*
atomicCounterType
arguments
)
;
}
TIntermBinary
*
CreateAtomicCounterRef
(
const
TVariable
*
atomicCounters
const
TIntermTyped
*
bindingOffset
const
TIntermTyped
*
bufferOffsets
)
{
TIntermSymbol
*
atomicCountersRef
=
new
TIntermSymbol
(
atomicCounters
)
;
TIntermConstantUnion
*
bindingFieldRef
=
CreateIndexNode
(
0
)
;
TIntermConstantUnion
*
offsetFieldRef
=
CreateIndexNode
(
1
)
;
TIntermConstantUnion
*
countersFieldRef
=
CreateIndexNode
(
0
)
;
TIntermBinary
*
binding
=
new
TIntermBinary
(
EOpIndexDirectStruct
bindingOffset
-
>
deepCopy
(
)
bindingFieldRef
)
;
TIntermBinary
*
offset
=
new
TIntermBinary
(
EOpIndexDirectStruct
bindingOffset
-
>
deepCopy
(
)
offsetFieldRef
)
;
TIntermBinary
*
countersBlock
=
new
TIntermBinary
(
EOpIndexDirect
atomicCountersRef
binding
)
;
TIntermBinary
*
counters
=
new
TIntermBinary
(
EOpIndexDirectInterfaceBlock
countersBlock
countersFieldRef
)
;
TIntermBinary
*
bindingDivFour
=
new
TIntermBinary
(
EOpDiv
binding
-
>
deepCopy
(
)
CreateUIntConstant
(
4
)
)
;
TIntermBinary
*
bufferOffsetUint
=
new
TIntermBinary
(
EOpIndexDirect
bufferOffsets
-
>
deepCopy
(
)
bindingDivFour
)
;
TIntermBinary
*
bindingModFour
=
new
TIntermBinary
(
EOpIMod
binding
-
>
deepCopy
(
)
CreateUIntConstant
(
4
)
)
;
TIntermBinary
*
bufferOffsetShift
=
new
TIntermBinary
(
EOpMul
bindingModFour
CreateUIntConstant
(
8
)
)
;
TIntermBinary
*
bufferOffsetShifted
=
new
TIntermBinary
(
EOpBitShiftRight
bufferOffsetUint
bufferOffsetShift
)
;
TIntermBinary
*
bufferOffset
=
new
TIntermBinary
(
EOpBitwiseAnd
bufferOffsetShifted
CreateUIntConstant
(
0xFF
)
)
;
offset
=
new
TIntermBinary
(
EOpAdd
offset
bufferOffset
)
;
return
new
TIntermBinary
(
EOpIndexDirect
counters
offset
)
;
}
class
RewriteAtomicCountersTraverser
:
public
TIntermTraverser
{
public
:
RewriteAtomicCountersTraverser
(
TSymbolTable
*
symbolTable
const
TVariable
*
atomicCounters
const
TIntermTyped
*
acbBufferOffsets
)
:
TIntermTraverser
(
true
true
true
symbolTable
)
mAtomicCounters
(
atomicCounters
)
mAcbBufferOffsets
(
acbBufferOffsets
)
mAtomicCounterType
(
nullptr
)
mAtomicCounterTypeConst
(
nullptr
)
mAtomicCounterTypeDeclaration
(
nullptr
)
{
}
bool
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
node
)
override
{
if
(
visit
!
=
PreVisit
)
{
return
true
;
}
const
TIntermSequence
&
sequence
=
*
(
node
-
>
getSequence
(
)
)
;
TIntermTyped
*
variable
=
sequence
.
front
(
)
-
>
getAsTyped
(
)
;
const
TType
&
type
=
variable
-
>
getType
(
)
;
bool
isAtomicCounter
=
type
.
getQualifier
(
)
=
=
EvqUniform
&
&
type
.
isAtomicCounter
(
)
;
if
(
isAtomicCounter
)
{
TIntermSymbol
*
samplerVariable
=
variable
-
>
getAsSymbolNode
(
)
;
ASSERT
(
samplerVariable
!
=
nullptr
)
;
declareAtomicCounter
(
&
samplerVariable
-
>
variable
(
)
node
)
;
return
false
;
}
return
true
;
}
void
visitFunctionPrototype
(
TIntermFunctionPrototype
*
node
)
override
{
const
TFunction
*
function
=
node
-
>
getFunction
(
)
;
mRetyper
.
visitFunctionPrototype
(
)
;
for
(
size_t
paramIndex
=
0
;
paramIndex
<
function
-
>
getParamCount
(
)
;
+
+
paramIndex
)
{
const
TVariable
*
param
=
function
-
>
getParam
(
paramIndex
)
;
TVariable
*
replacement
=
convertFunctionParameter
(
node
param
)
;
if
(
replacement
)
{
mRetyper
.
replaceFunctionParam
(
param
replacement
)
;
}
}
TIntermFunctionPrototype
*
replacementPrototype
=
mRetyper
.
convertFunctionPrototype
(
mSymbolTable
function
)
;
if
(
replacementPrototype
)
{
queueReplacement
(
replacementPrototype
OriginalNode
:
:
IS_DROPPED
)
;
}
}
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
{
if
(
visit
=
=
PreVisit
)
{
mRetyper
.
preVisitAggregate
(
)
;
}
if
(
visit
!
=
PostVisit
)
{
return
true
;
}
if
(
node
-
>
getOp
(
)
=
=
EOpCallBuiltInFunction
)
{
convertBuiltinFunction
(
node
)
;
}
else
if
(
node
-
>
getOp
(
)
=
=
EOpCallFunctionInAST
)
{
TIntermAggregate
*
substituteCall
=
mRetyper
.
convertASTFunction
(
node
)
;
if
(
substituteCall
)
{
queueReplacement
(
substituteCall
OriginalNode
:
:
IS_DROPPED
)
;
}
}
mRetyper
.
postVisitAggregate
(
)
;
return
true
;
}
void
visitSymbol
(
TIntermSymbol
*
symbol
)
override
{
const
TVariable
*
symbolVariable
=
&
symbol
-
>
variable
(
)
;
if
(
!
symbol
-
>
getType
(
)
.
isAtomicCounter
(
)
)
{
return
;
}
TIntermTyped
*
bindingOffset
=
new
TIntermSymbol
(
mRetyper
.
getVariableReplacement
(
symbolVariable
)
)
;
ASSERT
(
bindingOffset
!
=
nullptr
)
;
TIntermNode
*
argument
=
convertFunctionArgument
(
symbol
&
bindingOffset
)
;
if
(
mRetyper
.
isInAggregate
(
)
)
{
mRetyper
.
replaceFunctionCallArg
(
argument
bindingOffset
)
;
}
else
{
TIntermBlock
*
block
=
nullptr
;
for
(
uint32_t
ancestorIndex
=
0
;
block
=
=
nullptr
;
+
+
ancestorIndex
)
{
block
=
getAncestorNode
(
ancestorIndex
)
-
>
getAsBlock
(
)
;
}
TIntermSequence
emptySequence
;
mMultiReplacements
.
emplace_back
(
block
argument
emptySequence
)
;
}
}
TIntermDeclaration
*
getAtomicCounterTypeDeclaration
(
)
{
return
mAtomicCounterTypeDeclaration
;
}
private
:
void
declareAtomicCounter
(
const
TVariable
*
atomicCounterVar
TIntermDeclaration
*
node
)
{
if
(
mAtomicCounterType
=
=
nullptr
)
{
declareAtomicCounterType
(
)
;
}
ASSERT
(
mAtomicCounterTypeConst
)
;
TVariable
*
bindingOffset
=
new
TVariable
(
mSymbolTable
atomicCounterVar
-
>
name
(
)
mAtomicCounterTypeConst
SymbolType
:
:
UserDefined
)
;
const
TType
&
atomicCounterType
=
atomicCounterVar
-
>
getType
(
)
;
uint32_t
offset
=
atomicCounterType
.
getLayoutQualifier
(
)
.
offset
;
uint32_t
binding
=
atomicCounterType
.
getLayoutQualifier
(
)
.
binding
;
ASSERT
(
offset
%
4
=
=
0
)
;
TIntermTyped
*
bindingOffsetInitValue
=
CreateAtomicCounterConstant
(
mAtomicCounterTypeConst
binding
offset
/
4
)
;
TIntermSymbol
*
bindingOffsetSymbol
=
new
TIntermSymbol
(
bindingOffset
)
;
TIntermBinary
*
bindingOffsetInit
=
new
TIntermBinary
(
EOpInitialize
bindingOffsetSymbol
bindingOffsetInitValue
)
;
TIntermDeclaration
*
bindingOffsetDeclaration
=
new
TIntermDeclaration
(
)
;
bindingOffsetDeclaration
-
>
appendDeclarator
(
bindingOffsetInit
)
;
TIntermSequence
replacement
;
replacement
.
push_back
(
bindingOffsetDeclaration
)
;
mMultiReplacements
.
emplace_back
(
getParentNode
(
)
-
>
getAsBlock
(
)
node
replacement
)
;
mRetyper
.
replaceGlobalVariable
(
atomicCounterVar
bindingOffset
)
;
}
void
declareAtomicCounterType
(
)
{
ASSERT
(
mAtomicCounterType
=
=
nullptr
)
;
TFieldList
*
fields
=
new
TFieldList
(
)
;
fields
-
>
push_back
(
new
TField
(
new
TType
(
EbtUInt
EbpUndefined
EvqGlobal
1
1
)
ImmutableString
(
"
binding
"
)
TSourceLoc
(
)
SymbolType
:
:
AngleInternal
)
)
;
fields
-
>
push_back
(
new
TField
(
new
TType
(
EbtUInt
EbpUndefined
EvqGlobal
1
1
)
ImmutableString
(
"
arrayIndex
"
)
TSourceLoc
(
)
SymbolType
:
:
AngleInternal
)
)
;
TStructure
*
atomicCounterTypeStruct
=
new
TStructure
(
mSymbolTable
kAtomicCounterTypeName
fields
SymbolType
:
:
AngleInternal
)
;
mAtomicCounterType
=
new
TType
(
atomicCounterTypeStruct
false
)
;
mAtomicCounterTypeDeclaration
=
new
TIntermDeclaration
;
TVariable
*
emptyVariable
=
new
TVariable
(
mSymbolTable
kEmptyImmutableString
mAtomicCounterType
SymbolType
:
:
Empty
)
;
mAtomicCounterTypeDeclaration
-
>
appendDeclarator
(
new
TIntermSymbol
(
emptyVariable
)
)
;
mAtomicCounterTypeConst
=
new
TType
(
*
mAtomicCounterType
)
;
mAtomicCounterTypeConst
-
>
setQualifier
(
EvqConst
)
;
}
TVariable
*
convertFunctionParameter
(
TIntermNode
*
parent
const
TVariable
*
param
)
{
if
(
!
param
-
>
getType
(
)
.
isAtomicCounter
(
)
)
{
return
nullptr
;
}
if
(
mAtomicCounterType
=
=
nullptr
)
{
declareAtomicCounterType
(
)
;
}
const
TType
*
paramType
=
&
param
-
>
getType
(
)
;
TType
*
newType
=
paramType
-
>
getQualifier
(
)
=
=
EvqConst
?
mAtomicCounterTypeConst
:
mAtomicCounterType
;
TVariable
*
replacementVar
=
new
TVariable
(
mSymbolTable
param
-
>
name
(
)
newType
SymbolType
:
:
UserDefined
)
;
return
replacementVar
;
}
TIntermTyped
*
convertFunctionArgumentHelper
(
const
TVector
<
unsigned
int
>
&
runningArraySizeProducts
TIntermTyped
*
flattenedSubscript
uint32_t
depth
uint32_t
*
subscriptCountOut
)
{
std
:
:
string
prefix
(
depth
'
'
)
;
TIntermNode
*
parent
=
getAncestorNode
(
depth
)
;
ASSERT
(
parent
)
;
TIntermBinary
*
arrayExpression
=
parent
-
>
getAsBinaryNode
(
)
;
if
(
!
arrayExpression
)
{
*
subscriptCountOut
=
depth
;
return
flattenedSubscript
;
}
ASSERT
(
arrayExpression
-
>
getOp
(
)
=
=
EOpIndexDirect
|
|
arrayExpression
-
>
getOp
(
)
=
=
EOpIndexIndirect
)
;
ASSERT
(
depth
<
runningArraySizeProducts
.
size
(
)
)
;
uint32_t
thisDimensionSize
=
runningArraySizeProducts
[
runningArraySizeProducts
.
size
(
)
-
1
-
depth
]
;
TIntermTyped
*
thisDimensionOffset
=
arrayExpression
-
>
getRight
(
)
;
TIntermConstantUnion
*
subscriptAsConstant
=
thisDimensionOffset
-
>
getAsConstantUnion
(
)
;
const
bool
subscriptIsZero
=
subscriptAsConstant
&
&
subscriptAsConstant
-
>
isZero
(
0
)
;
if
(
!
subscriptIsZero
)
{
thisDimensionOffset
=
thisDimensionOffset
-
>
deepCopy
(
)
;
if
(
thisDimensionSize
!
=
1
)
{
thisDimensionOffset
=
new
TIntermBinary
(
EOpMul
thisDimensionOffset
CreateUIntConstant
(
thisDimensionSize
)
)
;
}
if
(
flattenedSubscript
)
{
flattenedSubscript
=
new
TIntermBinary
(
EOpAdd
flattenedSubscript
thisDimensionOffset
)
;
}
else
{
flattenedSubscript
=
thisDimensionOffset
;
}
}
return
convertFunctionArgumentHelper
(
runningArraySizeProducts
flattenedSubscript
depth
+
1
subscriptCountOut
)
;
}
TIntermNode
*
convertFunctionArgument
(
TIntermNode
*
symbol
TIntermTyped
*
*
bindingOffset
)
{
TIntermSymbol
*
argumentAsSymbol
=
symbol
-
>
getAsSymbolNode
(
)
;
ASSERT
(
argumentAsSymbol
)
;
const
TSpan
<
const
unsigned
int
>
&
arraySizes
=
argumentAsSymbol
-
>
getType
(
)
.
getArraySizes
(
)
;
TVector
<
unsigned
int
>
runningArraySizeProducts
;
if
(
!
arraySizes
.
empty
(
)
)
{
runningArraySizeProducts
.
resize
(
arraySizes
.
size
(
)
)
;
uint32_t
runningProduct
=
1
;
for
(
size_t
dimension
=
0
;
dimension
<
arraySizes
.
size
(
)
;
+
+
dimension
)
{
runningArraySizeProducts
[
dimension
]
=
runningProduct
;
runningProduct
*
=
arraySizes
[
dimension
]
;
}
}
uint32_t
subscriptCount
=
0
;
TIntermTyped
*
flattenedSubscript
=
convertFunctionArgumentHelper
(
runningArraySizeProducts
nullptr
0
&
subscriptCount
)
;
TIntermNode
*
argument
=
subscriptCount
=
=
0
?
symbol
:
getAncestorNode
(
subscriptCount
-
1
)
;
ASSERT
(
argument
!
=
nullptr
)
;
if
(
flattenedSubscript
=
=
nullptr
)
{
return
argument
;
}
TVariable
*
modified
=
CreateTempVariable
(
mSymbolTable
mAtomicCounterType
)
;
TIntermDeclaration
*
modifiedDecl
=
CreateTempInitDeclarationNode
(
modified
*
bindingOffset
)
;
TIntermSymbol
*
modifiedSymbol
=
new
TIntermSymbol
(
modified
)
;
TConstantUnion
*
offsetFieldIndex
=
new
TConstantUnion
;
offsetFieldIndex
-
>
setIConst
(
1
)
;
TIntermConstantUnion
*
offsetFieldRef
=
new
TIntermConstantUnion
(
offsetFieldIndex
*
StaticType
:
:
GetBasic
<
EbtUInt
>
(
)
)
;
TIntermBinary
*
offsetField
=
new
TIntermBinary
(
EOpIndexDirectStruct
modifiedSymbol
offsetFieldRef
)
;
TIntermBinary
*
modifiedOffset
=
new
TIntermBinary
(
EOpAddAssign
offsetField
flattenedSubscript
)
;
TIntermSequence
*
modifySequence
=
new
TIntermSequence
(
{
modifiedDecl
modifiedOffset
}
)
;
insertStatementsInParentBlock
(
*
modifySequence
)
;
*
bindingOffset
=
modifiedSymbol
-
>
deepCopy
(
)
;
return
argument
;
}
void
convertBuiltinFunction
(
TIntermAggregate
*
node
)
{
if
(
node
-
>
getFunction
(
)
-
>
name
(
)
=
=
"
memoryBarrierAtomicCounter
"
)
{
TIntermTyped
*
substituteCall
=
CreateBuiltInFunctionCallNode
(
"
memoryBarrierBuffer
"
new
TIntermSequence
*
mSymbolTable
310
)
;
queueReplacement
(
substituteCall
OriginalNode
:
:
IS_DROPPED
)
;
return
;
}
if
(
!
node
-
>
getFunction
(
)
-
>
isAtomicCounterFunction
(
)
)
{
return
;
}
const
ImmutableString
&
functionName
=
node
-
>
getFunction
(
)
-
>
name
(
)
;
TIntermSequence
*
arguments
=
node
-
>
getSequence
(
)
;
uint32_t
valueChange
=
0
;
constexpr
char
kAtomicAddFunction
[
]
=
"
atomicAdd
"
;
bool
isDecrement
=
false
;
if
(
functionName
=
=
"
atomicCounterIncrement
"
)
{
valueChange
=
1
;
}
else
if
(
functionName
=
=
"
atomicCounterDecrement
"
)
{
valueChange
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
;
static_assert
(
static_cast
<
uint32_t
>
(
-
1
)
=
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
"
uint32_t
max
is
not
-
1
"
)
;
isDecrement
=
true
;
}
else
{
ASSERT
(
functionName
=
=
"
atomicCounter
"
)
;
}
const
TIntermNode
*
param
=
(
*
arguments
)
[
0
]
;
TIntermTyped
*
bindingOffset
=
mRetyper
.
getFunctionCallArgReplacement
(
param
)
;
TIntermSequence
*
substituteArguments
=
new
TIntermSequence
;
substituteArguments
-
>
push_back
(
CreateAtomicCounterRef
(
mAtomicCounters
bindingOffset
mAcbBufferOffsets
)
)
;
substituteArguments
-
>
push_back
(
CreateUIntConstant
(
valueChange
)
)
;
TIntermTyped
*
substituteCall
=
CreateBuiltInFunctionCallNode
(
kAtomicAddFunction
substituteArguments
*
mSymbolTable
310
)
;
if
(
isDecrement
)
{
substituteCall
=
new
TIntermBinary
(
EOpSub
substituteCall
CreateUIntConstant
(
1
)
)
;
}
queueReplacement
(
substituteCall
OriginalNode
:
:
IS_DROPPED
)
;
}
const
TVariable
*
mAtomicCounters
;
const
TIntermTyped
*
mAcbBufferOffsets
;
RetypeOpaqueVariablesHelper
mRetyper
;
TType
*
mAtomicCounterType
;
TType
*
mAtomicCounterTypeConst
;
TIntermDeclaration
*
mAtomicCounterTypeDeclaration
;
}
;
}
bool
RewriteAtomicCounters
(
TCompiler
*
compiler
TIntermBlock
*
root
TSymbolTable
*
symbolTable
const
TIntermTyped
*
acbBufferOffsets
)
{
const
TVariable
*
atomicCounters
=
DeclareAtomicCountersBuffers
(
root
symbolTable
)
;
RewriteAtomicCountersTraverser
traverser
(
symbolTable
atomicCounters
acbBufferOffsets
)
;
root
-
>
traverse
(
&
traverser
)
;
if
(
!
traverser
.
updateTree
(
compiler
root
)
)
{
return
false
;
}
TIntermDeclaration
*
atomicCounterTypeDeclaration
=
traverser
.
getAtomicCounterTypeDeclaration
(
)
;
if
(
atomicCounterTypeDeclaration
)
{
root
-
>
getSequence
(
)
-
>
insert
(
root
-
>
getSequence
(
)
-
>
begin
(
)
atomicCounterTypeDeclaration
)
;
}
return
compiler
-
>
validateAST
(
root
)
;
}
}
