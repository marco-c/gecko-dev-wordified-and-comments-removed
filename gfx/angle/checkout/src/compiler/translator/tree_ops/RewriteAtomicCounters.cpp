#
include
"
compiler
/
translator
/
tree_ops
/
RewriteAtomicCounters
.
h
"
#
include
"
compiler
/
translator
/
Compiler
.
h
"
#
include
"
compiler
/
translator
/
ImmutableStringBuilder
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
ReplaceVariable
.
h
"
namespace
sh
{
namespace
{
constexpr
ImmutableString
kAtomicCountersVarName
=
ImmutableString
(
"
atomicCounters
"
)
;
constexpr
ImmutableString
kAtomicCounterFieldName
=
ImmutableString
(
"
counters
"
)
;
const
TVariable
*
DeclareAtomicCountersBuffers
(
TIntermBlock
*
root
TSymbolTable
*
symbolTable
)
{
TFieldList
*
fieldList
=
new
TFieldList
;
TType
*
counterType
=
new
TType
(
EbtUInt
EbpHigh
EvqGlobal
)
;
counterType
-
>
makeArray
(
0
)
;
TField
*
countersField
=
new
TField
(
counterType
kAtomicCounterFieldName
TSourceLoc
(
)
SymbolType
:
:
AngleInternal
)
;
fieldList
-
>
push_back
(
countersField
)
;
TMemoryQualifier
coherentMemory
=
TMemoryQualifier
:
:
Create
(
)
;
coherentMemory
.
coherent
=
true
;
constexpr
uint32_t
kMaxAtomicCounterBuffers
=
8
;
TLayoutQualifier
layoutQualifier
=
TLayoutQualifier
:
:
Create
(
)
;
layoutQualifier
.
blockStorage
=
EbsStd430
;
return
DeclareInterfaceBlock
(
root
symbolTable
fieldList
EvqBuffer
layoutQualifier
coherentMemory
kMaxAtomicCounterBuffers
ImmutableString
(
vk
:
:
kAtomicCountersBlockName
)
kAtomicCountersVarName
)
;
}
TIntermTyped
*
CreateUniformBufferOffset
(
const
TIntermTyped
*
uniformBufferOffsets
int
binding
)
{
TIntermBinary
*
uniformBufferOffsetUint
=
new
TIntermBinary
(
EOpIndexDirect
uniformBufferOffsets
-
>
deepCopy
(
)
CreateIndexNode
(
binding
/
4
)
)
;
TIntermBinary
*
uniformBufferOffsetShifted
=
uniformBufferOffsetUint
;
if
(
binding
%
4
!
=
0
)
{
uniformBufferOffsetShifted
=
new
TIntermBinary
(
EOpBitShiftRight
uniformBufferOffsetUint
CreateUIntNode
(
(
binding
%
4
)
*
8
)
)
;
}
return
new
TIntermBinary
(
EOpBitwiseAnd
uniformBufferOffsetShifted
CreateUIntNode
(
0xFF
)
)
;
}
TIntermBinary
*
CreateAtomicCounterRef
(
TIntermTyped
*
atomicCounterExpression
const
TVariable
*
atomicCounters
const
TIntermTyped
*
uniformBufferOffsets
)
{
TIntermSymbol
*
atomicCounterSymbol
=
atomicCounterExpression
-
>
getAsSymbolNode
(
)
;
TIntermTyped
*
atomicCounterIndex
=
nullptr
;
int
atomicCounterConstIndex
=
0
;
TIntermBinary
*
asBinary
=
atomicCounterExpression
-
>
getAsBinaryNode
(
)
;
if
(
asBinary
!
=
nullptr
)
{
atomicCounterSymbol
=
asBinary
-
>
getLeft
(
)
-
>
getAsSymbolNode
(
)
;
switch
(
asBinary
-
>
getOp
(
)
)
{
case
EOpIndexDirect
:
atomicCounterConstIndex
=
asBinary
-
>
getRight
(
)
-
>
getAsConstantUnion
(
)
-
>
getIConst
(
0
)
;
break
;
case
EOpIndexIndirect
:
atomicCounterIndex
=
asBinary
-
>
getRight
(
)
;
break
;
default
:
UNREACHABLE
(
)
;
}
}
ASSERT
(
atomicCounterSymbol
)
;
const
TVariable
*
atomicCounterVar
=
&
atomicCounterSymbol
-
>
variable
(
)
;
const
TType
&
atomicCounterType
=
atomicCounterVar
-
>
getType
(
)
;
const
int
binding
=
atomicCounterType
.
getLayoutQualifier
(
)
.
binding
;
int
offset
=
atomicCounterType
.
getLayoutQualifier
(
)
.
offset
/
4
;
offset
+
=
atomicCounterConstIndex
;
TIntermTyped
*
index
=
CreateUniformBufferOffset
(
uniformBufferOffsets
binding
)
;
if
(
atomicCounterIndex
!
=
nullptr
)
{
index
=
new
TIntermBinary
(
EOpAdd
index
atomicCounterIndex
)
;
}
if
(
offset
!
=
0
)
{
index
=
new
TIntermBinary
(
EOpAdd
index
CreateIndexNode
(
offset
)
)
;
}
TIntermSymbol
*
atomicCountersRef
=
new
TIntermSymbol
(
atomicCounters
)
;
TIntermBinary
*
countersBlock
=
new
TIntermBinary
(
EOpIndexDirect
atomicCountersRef
CreateIndexNode
(
binding
)
)
;
TIntermBinary
*
counters
=
new
TIntermBinary
(
EOpIndexDirectInterfaceBlock
countersBlock
CreateIndexNode
(
0
)
)
;
return
new
TIntermBinary
(
EOpIndexIndirect
counters
index
)
;
}
class
RewriteAtomicCountersTraverser
:
public
TIntermTraverser
{
public
:
RewriteAtomicCountersTraverser
(
TSymbolTable
*
symbolTable
const
TVariable
*
atomicCounters
const
TIntermTyped
*
acbBufferOffsets
)
:
TIntermTraverser
(
true
false
false
symbolTable
)
mAtomicCounters
(
atomicCounters
)
mAcbBufferOffsets
(
acbBufferOffsets
)
{
}
bool
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
node
)
override
{
if
(
!
mInGlobalScope
)
{
return
true
;
}
const
TIntermSequence
&
sequence
=
*
(
node
-
>
getSequence
(
)
)
;
TIntermTyped
*
variable
=
sequence
.
front
(
)
-
>
getAsTyped
(
)
;
const
TType
&
type
=
variable
-
>
getType
(
)
;
bool
isAtomicCounter
=
type
.
isAtomicCounter
(
)
;
if
(
isAtomicCounter
)
{
ASSERT
(
type
.
getQualifier
(
)
=
=
EvqUniform
)
;
TIntermSequence
emptySequence
;
mMultiReplacements
.
emplace_back
(
getParentNode
(
)
-
>
getAsBlock
(
)
node
std
:
:
move
(
emptySequence
)
)
;
return
false
;
}
return
true
;
}
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
{
if
(
BuiltInGroup
:
:
IsBuiltIn
(
node
-
>
getOp
(
)
)
)
{
bool
converted
=
convertBuiltinFunction
(
node
)
;
return
!
converted
;
}
return
true
;
}
void
visitSymbol
(
TIntermSymbol
*
symbol
)
override
{
ASSERT
(
!
symbol
-
>
getType
(
)
.
isAtomicCounter
(
)
)
;
}
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
{
ASSERT
(
!
node
-
>
getType
(
)
.
isAtomicCounter
(
)
)
;
return
true
;
}
private
:
bool
convertBuiltinFunction
(
TIntermAggregate
*
node
)
{
const
TOperator
op
=
node
-
>
getOp
(
)
;
if
(
op
=
=
EOpMemoryBarrierAtomicCounter
)
{
TIntermSequence
emptySequence
;
TIntermTyped
*
substituteCall
=
CreateBuiltInFunctionCallNode
(
"
memoryBarrierBuffer
"
&
emptySequence
*
mSymbolTable
310
)
;
queueReplacement
(
substituteCall
OriginalNode
:
:
IS_DROPPED
)
;
return
true
;
}
if
(
!
node
-
>
getFunction
(
)
-
>
isAtomicCounterFunction
(
)
)
{
return
false
;
}
uint32_t
valueChange
=
0
;
constexpr
char
kAtomicAddFunction
[
]
=
"
atomicAdd
"
;
bool
isDecrement
=
false
;
if
(
op
=
=
EOpAtomicCounterIncrement
)
{
valueChange
=
1
;
}
else
if
(
op
=
=
EOpAtomicCounterDecrement
)
{
valueChange
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
;
static_assert
(
static_cast
<
uint32_t
>
(
-
1
)
=
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
"
uint32_t
max
is
not
-
1
"
)
;
isDecrement
=
true
;
}
else
{
ASSERT
(
op
=
=
EOpAtomicCounter
)
;
}
TIntermTyped
*
param
=
(
*
node
-
>
getSequence
(
)
)
[
0
]
-
>
getAsTyped
(
)
;
TIntermSequence
substituteArguments
;
substituteArguments
.
push_back
(
CreateAtomicCounterRef
(
param
mAtomicCounters
mAcbBufferOffsets
)
)
;
substituteArguments
.
push_back
(
CreateUIntNode
(
valueChange
)
)
;
TIntermTyped
*
substituteCall
=
CreateBuiltInFunctionCallNode
(
kAtomicAddFunction
&
substituteArguments
*
mSymbolTable
310
)
;
if
(
isDecrement
)
{
substituteCall
=
new
TIntermBinary
(
EOpSub
substituteCall
CreateUIntNode
(
1
)
)
;
}
queueReplacement
(
substituteCall
OriginalNode
:
:
IS_DROPPED
)
;
return
true
;
}
const
TVariable
*
mAtomicCounters
;
const
TIntermTyped
*
mAcbBufferOffsets
;
}
;
}
bool
RewriteAtomicCounters
(
TCompiler
*
compiler
TIntermBlock
*
root
TSymbolTable
*
symbolTable
const
TIntermTyped
*
acbBufferOffsets
)
{
const
TVariable
*
atomicCounters
=
DeclareAtomicCountersBuffers
(
root
symbolTable
)
;
RewriteAtomicCountersTraverser
traverser
(
symbolTable
atomicCounters
acbBufferOffsets
)
;
root
-
>
traverse
(
&
traverser
)
;
return
traverser
.
updateTree
(
compiler
root
)
;
}
}
