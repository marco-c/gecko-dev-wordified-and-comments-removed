#
include
"
compiler
/
translator
/
tree_ops
/
RewriteAtomicCounters
.
h
"
#
include
"
compiler
/
translator
/
ImmutableStringBuilder
.
h
"
#
include
"
compiler
/
translator
/
StaticType
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
const
TVariable
*
DeclareAtomicCountersBuffer
(
TIntermBlock
*
root
TSymbolTable
*
symbolTable
)
{
TFieldList
*
fieldList
=
new
TFieldList
;
TType
*
counterType
=
new
TType
(
EbtUInt
)
;
counterType
-
>
makeArray
(
0
)
;
TField
*
countersField
=
new
TField
(
counterType
ImmutableString
(
"
counters
"
)
TSourceLoc
(
)
SymbolType
:
:
AngleInternal
)
;
fieldList
-
>
push_back
(
countersField
)
;
TMemoryQualifier
coherentMemory
=
TMemoryQualifier
:
:
Create
(
)
;
coherentMemory
.
coherent
=
true
;
return
DeclareInterfaceBlock
(
root
symbolTable
fieldList
EvqBuffer
coherentMemory
"
ANGLEAtomicCounters
"
"
atomicCounters
"
)
;
}
TIntermBinary
*
CreateAtomicCounterRef
(
const
TVariable
*
atomicCounters
TIntermTyped
*
offset
)
{
TIntermSymbol
*
atomicCountersRef
=
new
TIntermSymbol
(
atomicCounters
)
;
TConstantUnion
*
firstFieldIndex
=
new
TConstantUnion
;
firstFieldIndex
-
>
setIConst
(
0
)
;
TIntermConstantUnion
*
firstFieldRef
=
new
TIntermConstantUnion
(
firstFieldIndex
*
StaticType
:
:
GetBasic
<
EbtUInt
>
(
)
)
;
TIntermBinary
*
firstField
=
new
TIntermBinary
(
EOpIndexDirectInterfaceBlock
atomicCountersRef
firstFieldRef
)
;
return
new
TIntermBinary
(
EOpIndexDirect
firstField
offset
)
;
}
TIntermConstantUnion
*
CreateUIntConstant
(
uint32_t
value
)
{
const
TType
*
constantType
=
StaticType
:
:
GetBasic
<
EbtUInt
1
>
(
)
;
TConstantUnion
*
constantValue
=
new
TConstantUnion
;
constantValue
-
>
setUConst
(
value
)
;
return
new
TIntermConstantUnion
(
constantValue
*
constantType
)
;
}
class
RewriteAtomicCountersTraverser
:
public
TIntermTraverser
{
public
:
RewriteAtomicCountersTraverser
(
TSymbolTable
*
symbolTable
const
TVariable
*
atomicCounters
)
:
TIntermTraverser
(
true
true
true
symbolTable
)
mAtomicCounters
(
atomicCounters
)
mCurrentAtomicCounterOffset
(
0
)
mCurrentAtomicCounterDecl
(
nullptr
)
mCurrentAtomicCounterDeclParent
(
nullptr
)
{
}
bool
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
node
)
override
{
const
TIntermSequence
&
sequence
=
*
(
node
-
>
getSequence
(
)
)
;
TIntermTyped
*
variable
=
sequence
.
front
(
)
-
>
getAsTyped
(
)
;
const
TType
&
type
=
variable
-
>
getType
(
)
;
bool
isAtomicCounter
=
type
.
getQualifier
(
)
=
=
EvqUniform
&
&
type
.
isAtomicCounter
(
)
;
if
(
visit
=
=
PreVisit
|
|
visit
=
=
InVisit
)
{
if
(
isAtomicCounter
)
{
ASSERT
(
type
.
getLayoutQualifier
(
)
.
binding
=
=
0
)
;
mCurrentAtomicCounterDecl
=
node
;
mCurrentAtomicCounterDeclParent
=
getParentNode
(
)
-
>
getAsBlock
(
)
;
mCurrentAtomicCounterOffset
=
type
.
getLayoutQualifier
(
)
.
offset
;
}
}
else
if
(
visit
=
=
PostVisit
)
{
mCurrentAtomicCounterDecl
=
nullptr
;
mCurrentAtomicCounterDeclParent
=
nullptr
;
mCurrentAtomicCounterOffset
=
0
;
}
return
true
;
}
void
visitFunctionPrototype
(
TIntermFunctionPrototype
*
node
)
override
{
const
TFunction
*
function
=
node
-
>
getFunction
(
)
;
mAtomicCounterFunctionParams
.
clear
(
)
;
for
(
size_t
paramIndex
=
0
;
paramIndex
<
function
-
>
getParamCount
(
)
;
+
+
paramIndex
)
{
const
TVariable
*
param
=
function
-
>
getParam
(
paramIndex
)
;
TVariable
*
replacement
=
convertFunctionParameter
(
node
param
)
;
if
(
replacement
)
{
mAtomicCounterFunctionParams
[
param
]
=
replacement
;
}
}
if
(
mAtomicCounterFunctionParams
.
empty
(
)
)
{
return
;
}
TFunction
*
replacementFunction
=
new
TFunction
(
mSymbolTable
function
-
>
name
(
)
SymbolType
:
:
UserDefined
new
TType
(
function
-
>
getReturnType
(
)
)
function
-
>
isKnownToNotHaveSideEffects
(
)
)
;
for
(
size_t
paramIndex
=
0
;
paramIndex
<
function
-
>
getParamCount
(
)
;
+
+
paramIndex
)
{
const
TVariable
*
param
=
function
-
>
getParam
(
paramIndex
)
;
TVariable
*
replacement
=
nullptr
;
if
(
param
-
>
getType
(
)
.
isAtomicCounter
(
)
)
{
ASSERT
(
mAtomicCounterFunctionParams
.
count
(
param
)
!
=
0
)
;
replacement
=
mAtomicCounterFunctionParams
[
param
]
;
}
else
{
replacement
=
new
TVariable
(
mSymbolTable
param
-
>
name
(
)
new
TType
(
param
-
>
getType
(
)
)
SymbolType
:
:
UserDefined
)
;
}
replacementFunction
-
>
addParameter
(
replacement
)
;
}
TIntermFunctionPrototype
*
replacementPrototype
=
new
TIntermFunctionPrototype
(
replacementFunction
)
;
queueReplacement
(
replacementPrototype
OriginalNode
:
:
IS_DROPPED
)
;
mReplacedFunctions
[
function
]
=
replacementFunction
;
}
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
{
if
(
visit
=
=
PreVisit
)
{
mAtomicCounterFunctionCallArgs
.
clear
(
)
;
}
if
(
visit
!
=
PostVisit
)
{
return
true
;
}
if
(
node
-
>
getOp
(
)
=
=
EOpCallBuiltInFunction
)
{
convertBuiltinFunction
(
node
)
;
}
else
if
(
node
-
>
getOp
(
)
=
=
EOpCallFunctionInAST
)
{
convertASTFunction
(
node
)
;
}
return
true
;
}
void
visitSymbol
(
TIntermSymbol
*
symbol
)
override
{
const
TVariable
*
symbolVariable
=
&
symbol
-
>
variable
(
)
;
if
(
mCurrentAtomicCounterDecl
)
{
declareAtomicCounter
(
symbolVariable
)
;
return
;
}
if
(
!
symbol
-
>
getType
(
)
.
isAtomicCounter
(
)
)
{
return
;
}
TIntermTyped
*
offset
=
nullptr
;
if
(
mAtomicCounterOffsets
.
count
(
symbolVariable
)
!
=
0
)
{
offset
=
new
TIntermSymbol
(
mAtomicCounterOffsets
[
symbolVariable
]
)
;
}
else
{
ASSERT
(
mAtomicCounterFunctionParams
.
count
(
symbolVariable
)
!
=
0
)
;
offset
=
new
TIntermSymbol
(
mAtomicCounterFunctionParams
[
symbolVariable
]
)
;
}
TIntermNode
*
argument
=
symbol
;
TIntermNode
*
parent
=
getParentNode
(
)
;
ASSERT
(
parent
)
;
TIntermBinary
*
arrayExpression
=
parent
-
>
getAsBinaryNode
(
)
;
if
(
arrayExpression
)
{
ASSERT
(
arrayExpression
-
>
getOp
(
)
=
=
EOpIndexDirect
|
|
arrayExpression
-
>
getOp
(
)
=
=
EOpIndexIndirect
)
;
offset
=
new
TIntermBinary
(
EOpAdd
offset
arrayExpression
-
>
getRight
(
)
-
>
deepCopy
(
)
)
;
argument
=
arrayExpression
;
}
mAtomicCounterFunctionCallArgs
[
argument
]
=
offset
;
}
private
:
void
declareAtomicCounter
(
const
TVariable
*
symbolVariable
)
{
TType
*
uintType
=
new
TType
(
*
StaticType
:
:
GetBasic
<
EbtUInt
1
>
(
)
)
;
uintType
-
>
setQualifier
(
EvqConst
)
;
TVariable
*
offset
=
new
TVariable
(
mSymbolTable
symbolVariable
-
>
name
(
)
uintType
SymbolType
:
:
UserDefined
)
;
ASSERT
(
mCurrentAtomicCounterOffset
%
4
=
=
0
)
;
TIntermConstantUnion
*
offsetInitValue
=
CreateIndexNode
(
mCurrentAtomicCounterOffset
/
4
)
;
TIntermSymbol
*
offsetSymbol
=
new
TIntermSymbol
(
offset
)
;
TIntermBinary
*
offsetInit
=
new
TIntermBinary
(
EOpInitialize
offsetSymbol
offsetInitValue
)
;
TIntermDeclaration
*
offsetDeclaration
=
new
TIntermDeclaration
(
)
;
offsetDeclaration
-
>
appendDeclarator
(
offsetInit
)
;
TIntermSequence
replacement
;
replacement
.
push_back
(
offsetDeclaration
)
;
mMultiReplacements
.
emplace_back
(
mCurrentAtomicCounterDeclParent
mCurrentAtomicCounterDecl
replacement
)
;
mAtomicCounterOffsets
[
symbolVariable
]
=
offset
;
}
TVariable
*
convertFunctionParameter
(
TIntermNode
*
parent
const
TVariable
*
param
)
{
if
(
!
param
-
>
getType
(
)
.
isAtomicCounter
(
)
)
{
return
nullptr
;
}
const
TType
*
newType
=
StaticType
:
:
GetBasic
<
EbtUInt
>
(
)
;
TVariable
*
replacementVar
=
new
TVariable
(
mSymbolTable
param
-
>
name
(
)
newType
SymbolType
:
:
UserDefined
)
;
return
replacementVar
;
}
void
convertBuiltinFunction
(
TIntermAggregate
*
node
)
{
if
(
node
-
>
getFunction
(
)
-
>
name
(
)
=
=
"
memoryBarrierAtomicCounter
"
)
{
TIntermTyped
*
substituteCall
=
CreateBuiltInFunctionCallNode
(
"
memoryBarrierBuffer
"
new
TIntermSequence
*
mSymbolTable
310
)
;
queueReplacement
(
substituteCall
OriginalNode
:
:
IS_DROPPED
)
;
return
;
}
if
(
!
node
-
>
getFunction
(
)
-
>
isAtomicCounterFunction
(
)
)
{
return
;
}
const
ImmutableString
&
functionName
=
node
-
>
getFunction
(
)
-
>
name
(
)
;
TIntermSequence
*
arguments
=
node
-
>
getSequence
(
)
;
uint32_t
valueChange
=
0
;
constexpr
char
kAtomicAddFunction
[
]
=
"
atomicAdd
"
;
bool
isDecrement
=
false
;
if
(
functionName
=
=
"
atomicCounterIncrement
"
)
{
valueChange
=
1
;
}
else
if
(
functionName
=
=
"
atomicCounterDecrement
"
)
{
valueChange
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
;
static_assert
(
static_cast
<
uint32_t
>
(
-
1
)
=
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
"
uint32_t
max
is
not
-
1
"
)
;
isDecrement
=
true
;
}
else
{
ASSERT
(
functionName
=
=
"
atomicCounter
"
)
;
}
const
TIntermNode
*
param
=
(
*
arguments
)
[
0
]
;
ASSERT
(
mAtomicCounterFunctionCallArgs
.
count
(
param
)
!
=
0
)
;
TIntermTyped
*
offset
=
mAtomicCounterFunctionCallArgs
[
param
]
;
TIntermSequence
*
substituteArguments
=
new
TIntermSequence
;
substituteArguments
-
>
push_back
(
CreateAtomicCounterRef
(
mAtomicCounters
offset
)
)
;
substituteArguments
-
>
push_back
(
CreateUIntConstant
(
valueChange
)
)
;
TIntermTyped
*
substituteCall
=
CreateBuiltInFunctionCallNode
(
kAtomicAddFunction
substituteArguments
*
mSymbolTable
310
)
;
if
(
isDecrement
)
{
substituteCall
=
new
TIntermBinary
(
EOpSub
substituteCall
CreateUIntConstant
(
1
)
)
;
}
queueReplacement
(
substituteCall
OriginalNode
:
:
IS_DROPPED
)
;
}
void
convertASTFunction
(
TIntermAggregate
*
node
)
{
const
TFunction
*
function
=
node
-
>
getFunction
(
)
;
if
(
mReplacedFunctions
.
count
(
function
)
=
=
0
)
{
return
;
}
TFunction
*
substituteFunction
=
mReplacedFunctions
[
function
]
;
TIntermSequence
*
substituteArguments
=
new
TIntermSequence
;
for
(
size_t
paramIndex
=
0
;
paramIndex
<
function
-
>
getParamCount
(
)
;
+
+
paramIndex
)
{
TIntermNode
*
param
=
node
-
>
getChildNode
(
paramIndex
)
;
TIntermNode
*
replacement
=
nullptr
;
if
(
param
-
>
getAsTyped
(
)
-
>
getType
(
)
.
isAtomicCounter
(
)
)
{
ASSERT
(
mAtomicCounterFunctionCallArgs
.
count
(
param
)
!
=
0
)
;
replacement
=
mAtomicCounterFunctionCallArgs
[
param
]
;
}
else
{
replacement
=
param
-
>
getAsTyped
(
)
-
>
deepCopy
(
)
;
}
substituteArguments
-
>
push_back
(
replacement
)
;
}
TIntermTyped
*
substituteCall
=
TIntermAggregate
:
:
CreateFunctionCall
(
*
substituteFunction
substituteArguments
)
;
queueReplacement
(
substituteCall
OriginalNode
:
:
IS_DROPPED
)
;
}
private
:
const
TVariable
*
mAtomicCounters
;
std
:
:
unordered_map
<
const
TVariable
*
TVariable
*
>
mAtomicCounterOffsets
;
std
:
:
unordered_map
<
const
TFunction
*
TFunction
*
>
mReplacedFunctions
;
std
:
:
unordered_map
<
const
TVariable
*
TVariable
*
>
mAtomicCounterFunctionParams
;
std
:
:
unordered_map
<
const
TIntermNode
*
TIntermTyped
*
>
mAtomicCounterFunctionCallArgs
;
uint32_t
mCurrentAtomicCounterOffset
;
TIntermDeclaration
*
mCurrentAtomicCounterDecl
;
TIntermAggregateBase
*
mCurrentAtomicCounterDeclParent
;
}
;
}
void
RewriteAtomicCounters
(
TIntermBlock
*
root
TSymbolTable
*
symbolTable
)
{
const
TVariable
*
atomicCounters
=
DeclareAtomicCountersBuffer
(
root
symbolTable
)
;
RewriteAtomicCountersTraverser
traverser
(
symbolTable
atomicCounters
)
;
root
-
>
traverse
(
&
traverser
)
;
traverser
.
updateTree
(
)
;
}
}
