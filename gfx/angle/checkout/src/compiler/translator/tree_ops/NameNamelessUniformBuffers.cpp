#
include
"
compiler
/
translator
/
tree_ops
/
NameNamelessUniformBuffers
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
class
NameUniformBufferVariablesTraverser
:
public
TIntermTraverser
{
public
:
explicit
NameUniformBufferVariablesTraverser
(
TSymbolTable
*
symbolTable
)
:
TIntermTraverser
(
true
false
false
symbolTable
)
{
}
bool
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
decl
)
override
{
ASSERT
(
visit
=
=
PreVisit
)
;
const
TIntermSequence
&
sequence
=
*
(
decl
-
>
getSequence
(
)
)
;
TIntermTyped
*
variableNode
=
sequence
.
front
(
)
-
>
getAsTyped
(
)
;
const
TType
&
type
=
variableNode
-
>
getType
(
)
;
if
(
!
type
.
isInterfaceBlock
(
)
)
{
return
true
;
}
ASSERT
(
sequence
.
size
(
)
=
=
1
)
;
const
TVariable
*
variable
=
&
variableNode
-
>
getAsSymbolNode
(
)
-
>
variable
(
)
;
if
(
variable
-
>
symbolType
(
)
!
=
SymbolType
:
:
Empty
)
{
return
false
;
}
TIntermDeclaration
*
newDeclaration
=
new
TIntermDeclaration
;
TVariable
*
newVariable
=
new
TVariable
(
mSymbolTable
kEmptyImmutableString
&
type
SymbolType
:
:
AngleInternal
variable
-
>
extensions
(
)
)
;
newDeclaration
-
>
appendDeclarator
(
new
TIntermSymbol
(
newVariable
)
)
;
queueReplacement
(
newDeclaration
OriginalNode
:
:
IS_DROPPED
)
;
mNamelessUniformBuffersMap
[
type
.
getInterfaceBlock
(
)
]
=
newVariable
;
return
false
;
}
void
visitSymbol
(
TIntermSymbol
*
symbol
)
override
{
const
TType
&
type
=
symbol
-
>
getType
(
)
;
if
(
type
.
isInterfaceBlock
(
)
|
|
type
.
getInterfaceBlock
(
)
=
=
nullptr
)
{
return
;
}
const
TInterfaceBlock
*
block
=
type
.
getInterfaceBlock
(
)
;
if
(
mNamelessUniformBuffersMap
.
count
(
block
)
=
=
0
)
{
return
;
}
const
ImmutableString
symbolName
=
symbol
-
>
getName
(
)
;
const
TVector
<
TField
*
>
fields
=
block
-
>
fields
(
)
;
for
(
size_t
fieldIndex
=
0
;
fieldIndex
<
fields
.
size
(
)
;
+
+
fieldIndex
)
{
const
TField
*
field
=
fields
[
fieldIndex
]
;
if
(
field
-
>
name
(
)
!
=
symbolName
)
{
continue
;
}
TIntermSymbol
*
namedUniformBuffer
=
new
TIntermSymbol
(
mNamelessUniformBuffersMap
[
block
]
)
;
TIntermBinary
*
replacement
=
new
TIntermBinary
(
EOpIndexDirectInterfaceBlock
namedUniformBuffer
CreateIndexNode
(
static_cast
<
uint32_t
>
(
fieldIndex
)
)
)
;
queueReplacement
(
replacement
OriginalNode
:
:
IS_DROPPED
)
;
return
;
}
UNREACHABLE
(
)
;
}
private
:
std
:
:
unordered_map
<
const
TInterfaceBlock
*
const
TVariable
*
>
mNamelessUniformBuffersMap
;
}
;
}
bool
NameNamelessUniformBuffers
(
TCompiler
*
compiler
TIntermBlock
*
root
TSymbolTable
*
symbolTable
)
{
NameUniformBufferVariablesTraverser
nameUniformBufferVariables
(
symbolTable
)
;
root
-
>
traverse
(
&
nameUniformBufferVariables
)
;
return
nameUniformBufferVariables
.
updateTree
(
compiler
root
)
;
}
}
