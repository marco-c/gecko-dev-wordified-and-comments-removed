#
include
"
compiler
/
translator
/
tree_ops
/
EarlyFragmentTestsOptimization
.
h
"
#
include
"
compiler
/
translator
/
InfoSink
.
h
"
#
include
"
compiler
/
translator
/
Symbol
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
class
CheckEFTOptimizationTraverser
:
public
TIntermTraverser
{
public
:
CheckEFTOptimizationTraverser
(
)
;
void
visitSymbol
(
TIntermSymbol
*
node
)
override
;
bool
visitBranch
(
Visit
visit
TIntermBranch
*
node
)
override
;
bool
isFragDepthUsed
(
)
{
return
mFragDepthUsed
;
}
bool
isDiscardOpUsed
(
)
{
return
mDiscardOpUsed
;
}
protected
:
bool
mFragDepthUsed
;
bool
mDiscardOpUsed
;
}
;
CheckEFTOptimizationTraverser
:
:
CheckEFTOptimizationTraverser
(
)
:
TIntermTraverser
(
true
false
false
)
mFragDepthUsed
(
false
)
mDiscardOpUsed
(
false
)
{
}
void
CheckEFTOptimizationTraverser
:
:
visitSymbol
(
TIntermSymbol
*
node
)
{
TQualifier
qualifier
=
node
-
>
variable
(
)
.
getType
(
)
.
getQualifier
(
)
;
if
(
qualifier
=
=
EvqFragDepth
|
|
qualifier
=
=
EvqFragDepthEXT
)
{
mFragDepthUsed
=
true
;
}
}
bool
CheckEFTOptimizationTraverser
:
:
visitBranch
(
Visit
visit
TIntermBranch
*
node
)
{
if
(
node
-
>
getFlowOp
(
)
=
=
EOpKill
)
{
mDiscardOpUsed
=
true
;
}
return
true
;
}
}
bool
CheckEarlyFragmentTestsFeasible
(
TCompiler
*
compiler
TIntermNode
*
root
)
{
CheckEFTOptimizationTraverser
traverser
;
root
-
>
traverse
(
&
traverser
)
;
if
(
traverser
.
isFragDepthUsed
(
)
|
|
traverser
.
isDiscardOpUsed
(
)
)
{
return
false
;
}
return
true
;
}
}
