#
include
"
compiler
/
translator
/
tree_ops
/
RewriteArrayOfArrayOfOpaqueUniforms
.
h
"
#
include
"
compiler
/
translator
/
Compiler
.
h
"
#
include
"
compiler
/
translator
/
ImmutableStringBuilder
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
ReplaceVariable
.
h
"
namespace
sh
{
namespace
{
struct
UniformData
{
const
TVariable
*
flattened
;
TVector
<
unsigned
int
>
mSubArraySizes
;
}
;
using
UniformMap
=
angle
:
:
HashMap
<
const
TVariable
*
UniformData
>
;
TIntermTyped
*
RewriteArrayOfArraySubscriptExpression
(
TCompiler
*
compiler
TIntermBinary
*
node
const
UniformMap
&
uniformMap
)
;
class
RewriteExpressionTraverser
final
:
public
TIntermTraverser
{
public
:
explicit
RewriteExpressionTraverser
(
TCompiler
*
compiler
const
UniformMap
&
uniformMap
)
:
TIntermTraverser
(
true
false
false
)
mCompiler
(
compiler
)
mUniformMap
(
uniformMap
)
{
}
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
{
TIntermTyped
*
rewritten
=
RewriteArrayOfArraySubscriptExpression
(
mCompiler
node
mUniformMap
)
;
if
(
rewritten
=
=
nullptr
)
{
return
true
;
}
queueReplacement
(
rewritten
OriginalNode
:
:
IS_DROPPED
)
;
return
false
;
}
void
visitSymbol
(
TIntermSymbol
*
node
)
override
{
ASSERT
(
!
IsOpaqueType
(
node
-
>
getType
(
)
.
getBasicType
(
)
)
|
|
mUniformMap
.
find
(
&
node
-
>
variable
(
)
)
=
=
mUniformMap
.
end
(
)
)
;
}
private
:
TCompiler
*
mCompiler
;
const
UniformMap
&
mUniformMap
;
}
;
void
RewriteIndexExpression
(
TCompiler
*
compiler
TIntermTyped
*
expression
const
UniformMap
&
uniformMap
)
{
RewriteExpressionTraverser
traverser
(
compiler
uniformMap
)
;
expression
-
>
traverse
(
&
traverser
)
;
bool
valid
=
traverser
.
updateTree
(
compiler
expression
)
;
ASSERT
(
valid
)
;
}
TIntermTyped
*
RewriteArrayOfArraySubscriptExpression
(
TCompiler
*
compiler
TIntermBinary
*
node
const
UniformMap
&
uniformMap
)
{
if
(
!
IsOpaqueType
(
node
-
>
getType
(
)
.
getBasicType
(
)
)
)
{
return
nullptr
;
}
TIntermSymbol
*
opaqueUniform
=
nullptr
;
TIntermBinary
*
iter
=
node
;
while
(
opaqueUniform
=
=
nullptr
)
{
ASSERT
(
iter
-
>
getOp
(
)
=
=
EOpIndexDirect
|
|
iter
-
>
getOp
(
)
=
=
EOpIndexIndirect
)
;
opaqueUniform
=
iter
-
>
getLeft
(
)
-
>
getAsSymbolNode
(
)
;
iter
=
iter
-
>
getLeft
(
)
-
>
getAsBinaryNode
(
)
;
}
auto
flattenedIter
=
uniformMap
.
find
(
&
opaqueUniform
-
>
variable
(
)
)
;
if
(
flattenedIter
=
=
uniformMap
.
end
(
)
)
{
return
nullptr
;
}
const
UniformData
&
data
=
flattenedIter
-
>
second
;
unsigned
int
constantOffset
=
0
;
TIntermTyped
*
variableIndex
=
nullptr
;
for
(
size_t
dimIndex
=
0
;
dimIndex
<
data
.
mSubArraySizes
.
size
(
)
;
+
+
dimIndex
)
{
ASSERT
(
node
)
;
unsigned
int
subArraySize
=
data
.
mSubArraySizes
[
dimIndex
]
;
switch
(
node
-
>
getOp
(
)
)
{
case
EOpIndexDirect
:
constantOffset
+
=
node
-
>
getRight
(
)
-
>
getAsConstantUnion
(
)
-
>
getIConst
(
0
)
*
subArraySize
;
break
;
case
EOpIndexIndirect
:
{
TIntermTyped
*
indexExpression
=
node
-
>
getRight
(
)
;
RewriteIndexExpression
(
compiler
indexExpression
uniformMap
)
;
if
(
subArraySize
!
=
1
)
{
indexExpression
=
new
TIntermBinary
(
EOpMul
indexExpression
CreateIndexNode
(
subArraySize
)
)
;
}
if
(
variableIndex
=
=
nullptr
)
{
variableIndex
=
indexExpression
;
}
else
{
variableIndex
=
new
TIntermBinary
(
EOpAdd
variableIndex
indexExpression
)
;
}
break
;
}
default
:
UNREACHABLE
(
)
;
break
;
}
node
=
node
-
>
getLeft
(
)
-
>
getAsBinaryNode
(
)
;
}
TIntermTyped
*
index
=
nullptr
;
if
(
constantOffset
=
=
0
&
&
variableIndex
!
=
nullptr
)
{
index
=
variableIndex
;
}
else
{
index
=
CreateIndexNode
(
constantOffset
)
;
if
(
variableIndex
)
{
index
=
new
TIntermBinary
(
EOpAdd
index
variableIndex
)
;
}
}
TOperator
op
=
variableIndex
?
EOpIndexIndirect
:
EOpIndexDirect
;
return
new
TIntermBinary
(
op
new
TIntermSymbol
(
data
.
flattened
)
index
)
;
}
class
RewriteArrayOfArrayOfOpaqueUniformsTraverser
:
public
TIntermTraverser
{
public
:
RewriteArrayOfArrayOfOpaqueUniformsTraverser
(
TCompiler
*
compiler
TSymbolTable
*
symbolTable
)
:
TIntermTraverser
(
true
false
false
symbolTable
)
mCompiler
(
compiler
)
{
}
bool
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
node
)
override
{
if
(
!
mInGlobalScope
)
{
return
true
;
}
const
TIntermSequence
&
sequence
=
*
(
node
-
>
getSequence
(
)
)
;
TIntermTyped
*
variable
=
sequence
.
front
(
)
-
>
getAsTyped
(
)
;
const
TType
&
type
=
variable
-
>
getType
(
)
;
bool
isOpaqueUniform
=
type
.
getQualifier
(
)
=
=
EvqUniform
&
&
IsOpaqueType
(
type
.
getBasicType
(
)
)
;
if
(
!
isOpaqueUniform
|
|
!
type
.
isArrayOfArrays
(
)
)
{
return
false
;
}
TIntermSymbol
*
symbol
=
variable
-
>
getAsSymbolNode
(
)
;
ASSERT
(
symbol
!
=
nullptr
)
;
const
TVariable
*
uniformVariable
=
&
symbol
-
>
variable
(
)
;
ASSERT
(
mUniformMap
.
find
(
uniformVariable
)
=
=
mUniformMap
.
end
(
)
)
;
UniformData
&
data
=
mUniformMap
[
uniformVariable
]
;
const
TSpan
<
const
unsigned
int
>
&
arraySizes
=
type
.
getArraySizes
(
)
;
mUniformMap
[
uniformVariable
]
.
mSubArraySizes
.
resize
(
arraySizes
.
size
(
)
)
;
unsigned
int
runningProduct
=
1
;
for
(
size_t
dimension
=
0
;
dimension
<
arraySizes
.
size
(
)
;
+
+
dimension
)
{
data
.
mSubArraySizes
[
dimension
]
=
runningProduct
;
runningProduct
*
=
arraySizes
[
dimension
]
;
}
TType
*
newType
=
new
TType
(
type
)
;
newType
-
>
toArrayBaseType
(
)
;
newType
-
>
makeArray
(
runningProduct
)
;
data
.
flattened
=
new
TVariable
(
mSymbolTable
uniformVariable
-
>
name
(
)
newType
uniformVariable
-
>
symbolType
(
)
)
;
TIntermDeclaration
*
decl
=
new
TIntermDeclaration
;
decl
-
>
appendDeclarator
(
new
TIntermSymbol
(
data
.
flattened
)
)
;
queueReplacement
(
decl
OriginalNode
:
:
IS_DROPPED
)
;
return
false
;
}
bool
visitFunctionDefinition
(
Visit
visit
TIntermFunctionDefinition
*
node
)
override
{
return
!
mUniformMap
.
empty
(
)
;
}
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
{
TIntermTyped
*
rewritten
=
RewriteArrayOfArraySubscriptExpression
(
mCompiler
node
mUniformMap
)
;
if
(
rewritten
=
=
nullptr
)
{
return
true
;
}
queueReplacement
(
rewritten
OriginalNode
:
:
IS_DROPPED
)
;
return
false
;
}
void
visitSymbol
(
TIntermSymbol
*
node
)
override
{
ASSERT
(
!
IsOpaqueType
(
node
-
>
getType
(
)
.
getBasicType
(
)
)
|
|
mUniformMap
.
find
(
&
node
-
>
variable
(
)
)
=
=
mUniformMap
.
end
(
)
)
;
}
private
:
TCompiler
*
mCompiler
;
UniformMap
mUniformMap
;
}
;
}
bool
RewriteArrayOfArrayOfOpaqueUniforms
(
TCompiler
*
compiler
TIntermBlock
*
root
TSymbolTable
*
symbolTable
)
{
RewriteArrayOfArrayOfOpaqueUniformsTraverser
traverser
(
compiler
symbolTable
)
;
root
-
>
traverse
(
&
traverser
)
;
return
traverser
.
updateTree
(
compiler
root
)
;
}
}
