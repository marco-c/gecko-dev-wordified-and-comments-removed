#
include
"
compiler
/
translator
/
tree_ops
/
SeparateArrayConstructorStatements
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
void
SplitConstructorArgs
(
const
TIntermSequence
&
originalArgs
TIntermSequence
*
argsOut
)
{
for
(
TIntermNode
*
arg
:
originalArgs
)
{
TIntermTyped
*
argTyped
=
arg
-
>
getAsTyped
(
)
;
if
(
argTyped
-
>
hasSideEffects
(
)
)
{
TIntermAggregate
*
argAggregate
=
argTyped
-
>
getAsAggregate
(
)
;
if
(
argTyped
-
>
isArray
(
)
&
&
argAggregate
&
&
argAggregate
-
>
isConstructor
(
)
)
{
SplitConstructorArgs
(
*
argAggregate
-
>
getSequence
(
)
argsOut
)
;
}
else
{
argsOut
-
>
push_back
(
argTyped
)
;
}
}
}
}
class
SeparateArrayConstructorStatementsTraverser
:
public
TIntermTraverser
{
public
:
SeparateArrayConstructorStatementsTraverser
(
)
;
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
;
}
;
SeparateArrayConstructorStatementsTraverser
:
:
SeparateArrayConstructorStatementsTraverser
(
)
:
TIntermTraverser
(
true
false
false
)
{
}
bool
SeparateArrayConstructorStatementsTraverser
:
:
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
{
TIntermBlock
*
parentAsBlock
=
getParentNode
(
)
-
>
getAsBlock
(
)
;
if
(
!
parentAsBlock
)
{
return
false
;
}
if
(
!
node
-
>
isArray
(
)
|
|
!
node
-
>
isConstructor
(
)
)
{
return
false
;
}
TIntermSequence
constructorArgs
;
SplitConstructorArgs
(
*
node
-
>
getSequence
(
)
&
constructorArgs
)
;
mMultiReplacements
.
push_back
(
NodeReplaceWithMultipleEntry
(
parentAsBlock
node
constructorArgs
)
)
;
return
false
;
}
}
void
SeparateArrayConstructorStatements
(
TIntermBlock
*
root
)
{
SeparateArrayConstructorStatementsTraverser
traverser
;
root
-
>
traverse
(
&
traverser
)
;
traverser
.
updateTree
(
)
;
}
}
