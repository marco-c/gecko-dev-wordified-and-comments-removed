#
include
"
compiler
/
translator
/
tree_ops
/
PruneNoOps
.
h
"
#
include
"
compiler
/
translator
/
Symbol
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
bool
IsNoOp
(
TIntermNode
*
node
)
{
if
(
node
-
>
getAsConstantUnion
(
)
!
=
nullptr
)
{
return
true
;
}
bool
isEmptyDeclaration
=
node
-
>
getAsDeclarationNode
(
)
!
=
nullptr
&
&
node
-
>
getAsDeclarationNode
(
)
-
>
getSequence
(
)
-
>
empty
(
)
;
if
(
isEmptyDeclaration
)
{
return
true
;
}
return
false
;
}
class
PruneNoOpsTraverser
:
private
TIntermTraverser
{
public
:
static
void
apply
(
TIntermBlock
*
root
TSymbolTable
*
symbolTable
)
;
private
:
PruneNoOpsTraverser
(
TSymbolTable
*
symbolTable
)
;
bool
visitDeclaration
(
Visit
TIntermDeclaration
*
node
)
override
;
bool
visitBlock
(
Visit
visit
TIntermBlock
*
node
)
override
;
bool
visitLoop
(
Visit
visit
TIntermLoop
*
loop
)
override
;
}
;
void
PruneNoOpsTraverser
:
:
apply
(
TIntermBlock
*
root
TSymbolTable
*
symbolTable
)
{
PruneNoOpsTraverser
prune
(
symbolTable
)
;
root
-
>
traverse
(
&
prune
)
;
prune
.
updateTree
(
)
;
}
PruneNoOpsTraverser
:
:
PruneNoOpsTraverser
(
TSymbolTable
*
symbolTable
)
:
TIntermTraverser
(
true
false
false
symbolTable
)
{
}
bool
PruneNoOpsTraverser
:
:
visitDeclaration
(
Visit
TIntermDeclaration
*
node
)
{
TIntermSequence
*
sequence
=
node
-
>
getSequence
(
)
;
if
(
sequence
-
>
size
(
)
>
=
1
)
{
TIntermSymbol
*
declaratorSymbol
=
sequence
-
>
front
(
)
-
>
getAsSymbolNode
(
)
;
if
(
declaratorSymbol
!
=
nullptr
&
&
declaratorSymbol
-
>
variable
(
)
.
symbolType
(
)
=
=
SymbolType
:
:
Empty
&
&
!
declaratorSymbol
-
>
isInterfaceBlock
(
)
)
{
if
(
sequence
-
>
size
(
)
>
1
)
{
TIntermSequence
emptyReplacement
;
mMultiReplacements
.
push_back
(
NodeReplaceWithMultipleEntry
(
node
declaratorSymbol
emptyReplacement
)
)
;
}
else
if
(
declaratorSymbol
-
>
getBasicType
(
)
!
=
EbtStruct
)
{
UNREACHABLE
(
)
;
}
else
if
(
declaratorSymbol
-
>
getQualifier
(
)
!
=
EvqGlobal
&
&
declaratorSymbol
-
>
getQualifier
(
)
!
=
EvqTemporary
)
{
TType
*
type
=
new
TType
(
declaratorSymbol
-
>
getType
(
)
)
;
if
(
mInGlobalScope
)
{
type
-
>
setQualifier
(
EvqGlobal
)
;
}
else
{
type
-
>
setQualifier
(
EvqTemporary
)
;
}
TVariable
*
variable
=
new
TVariable
(
mSymbolTable
ImmutableString
(
"
"
)
type
SymbolType
:
:
Empty
)
;
queueReplacementWithParent
(
node
declaratorSymbol
new
TIntermSymbol
(
variable
)
OriginalNode
:
:
IS_DROPPED
)
;
}
}
}
return
false
;
}
bool
PruneNoOpsTraverser
:
:
visitBlock
(
Visit
visit
TIntermBlock
*
node
)
{
TIntermSequence
*
statements
=
node
-
>
getSequence
(
)
;
for
(
TIntermNode
*
statement
:
*
statements
)
{
if
(
IsNoOp
(
statement
)
)
{
TIntermSequence
emptyReplacement
;
mMultiReplacements
.
push_back
(
NodeReplaceWithMultipleEntry
(
node
statement
emptyReplacement
)
)
;
}
}
return
true
;
}
bool
PruneNoOpsTraverser
:
:
visitLoop
(
Visit
visit
TIntermLoop
*
loop
)
{
TIntermTyped
*
expr
=
loop
-
>
getExpression
(
)
;
if
(
expr
!
=
nullptr
&
&
IsNoOp
(
expr
)
)
{
loop
-
>
setExpression
(
nullptr
)
;
}
TIntermNode
*
init
=
loop
-
>
getInit
(
)
;
if
(
init
!
=
nullptr
&
&
IsNoOp
(
init
)
)
{
loop
-
>
setInit
(
nullptr
)
;
}
return
true
;
}
}
void
PruneNoOps
(
TIntermBlock
*
root
TSymbolTable
*
symbolTable
)
{
PruneNoOpsTraverser
:
:
apply
(
root
symbolTable
)
;
}
}
