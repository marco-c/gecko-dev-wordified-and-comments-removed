#
include
"
compiler
/
translator
/
tree_ops
/
FoldExpressions
.
h
"
#
include
"
compiler
/
translator
/
Diagnostics
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
class
FoldExpressionsTraverser
:
public
TIntermTraverser
{
public
:
FoldExpressionsTraverser
(
TDiagnostics
*
diagnostics
)
:
TIntermTraverser
(
true
false
false
)
mDiagnostics
(
diagnostics
)
mDidReplace
(
false
)
{
}
bool
didReplace
(
)
{
return
mDidReplace
;
}
void
nextIteration
(
)
{
mDidReplace
=
false
;
}
protected
:
bool
visitTernary
(
Visit
visit
TIntermTernary
*
node
)
override
{
TIntermTyped
*
folded
=
node
-
>
fold
(
mDiagnostics
)
;
if
(
folded
!
=
node
)
{
queueReplacement
(
folded
OriginalNode
:
:
IS_DROPPED
)
;
mDidReplace
=
true
;
return
false
;
}
return
true
;
}
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
{
TIntermTyped
*
folded
=
node
-
>
fold
(
mDiagnostics
)
;
if
(
folded
!
=
node
)
{
queueReplacement
(
folded
OriginalNode
:
:
IS_DROPPED
)
;
mDidReplace
=
true
;
return
false
;
}
return
true
;
}
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
{
TIntermTyped
*
folded
=
node
-
>
fold
(
mDiagnostics
)
;
if
(
folded
!
=
node
)
{
queueReplacement
(
folded
OriginalNode
:
:
IS_DROPPED
)
;
mDidReplace
=
true
;
return
false
;
}
return
true
;
}
bool
visitUnary
(
Visit
visit
TIntermUnary
*
node
)
override
{
TIntermTyped
*
folded
=
node
-
>
fold
(
mDiagnostics
)
;
if
(
folded
!
=
node
)
{
queueReplacement
(
folded
OriginalNode
:
:
IS_DROPPED
)
;
mDidReplace
=
true
;
return
false
;
}
return
true
;
}
bool
visitSwizzle
(
Visit
visit
TIntermSwizzle
*
node
)
override
{
TIntermTyped
*
folded
=
node
-
>
fold
(
mDiagnostics
)
;
if
(
folded
!
=
node
)
{
queueReplacement
(
folded
OriginalNode
:
:
IS_DROPPED
)
;
mDidReplace
=
true
;
return
false
;
}
return
true
;
}
private
:
TDiagnostics
*
mDiagnostics
;
bool
mDidReplace
;
}
;
}
void
FoldExpressions
(
TIntermBlock
*
root
TDiagnostics
*
diagnostics
)
{
FoldExpressionsTraverser
traverser
(
diagnostics
)
;
do
{
traverser
.
nextIteration
(
)
;
root
-
>
traverse
(
&
traverser
)
;
traverser
.
updateTree
(
)
;
}
while
(
traverser
.
didReplace
(
)
)
;
}
}
