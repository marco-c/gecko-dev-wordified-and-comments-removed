#
include
"
compiler
/
translator
/
tree_ops
/
RemoveAtomicCounterBuiltins
.
h
"
#
include
"
compiler
/
translator
/
Compiler
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
bool
IsAtomicCounterDecl
(
const
TIntermDeclaration
*
node
)
{
const
TIntermSequence
&
sequence
=
*
(
node
-
>
getSequence
(
)
)
;
TIntermTyped
*
variable
=
sequence
.
front
(
)
-
>
getAsTyped
(
)
;
const
TType
&
type
=
variable
-
>
getType
(
)
;
return
type
.
getQualifier
(
)
=
=
EvqUniform
&
&
type
.
isAtomicCounter
(
)
;
}
class
RemoveAtomicCounterBuiltinsTraverser
:
public
TIntermTraverser
{
public
:
RemoveAtomicCounterBuiltinsTraverser
(
)
:
TIntermTraverser
(
true
false
false
)
{
}
bool
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
node
)
override
{
ASSERT
(
visit
=
=
PreVisit
)
;
ASSERT
(
!
IsAtomicCounterDecl
(
node
)
)
;
return
false
;
}
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
{
if
(
node
-
>
getOp
(
)
=
=
EOpMemoryBarrierAtomicCounter
)
{
TIntermSequence
emptySequence
;
mMultiReplacements
.
emplace_back
(
getParentNode
(
)
-
>
getAsBlock
(
)
node
emptySequence
)
;
return
true
;
}
ASSERT
(
!
(
node
-
>
getOp
(
)
=
=
EOpCallBuiltInFunction
&
&
node
-
>
getFunction
(
)
-
>
isAtomicCounterFunction
(
)
)
)
;
return
false
;
}
}
;
}
bool
RemoveAtomicCounterBuiltins
(
TCompiler
*
compiler
TIntermBlock
*
root
)
{
RemoveAtomicCounterBuiltinsTraverser
traverser
;
root
-
>
traverse
(
&
traverser
)
;
return
traverser
.
updateTree
(
compiler
root
)
;
}
}
