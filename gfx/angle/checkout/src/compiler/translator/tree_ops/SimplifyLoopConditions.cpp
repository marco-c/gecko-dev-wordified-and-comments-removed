#
include
"
compiler
/
translator
/
tree_ops
/
SimplifyLoopConditions
.
h
"
#
include
"
compiler
/
translator
/
StaticType
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNodePatternMatcher
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
class
SimplifyLoopConditionsTraverser
:
public
TLValueTrackingTraverser
{
public
:
SimplifyLoopConditionsTraverser
(
unsigned
int
conditionsToSimplifyMask
TSymbolTable
*
symbolTable
)
;
void
traverseLoop
(
TIntermLoop
*
node
)
override
;
bool
visitUnary
(
Visit
visit
TIntermUnary
*
node
)
override
;
bool
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
override
;
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
;
bool
visitTernary
(
Visit
visit
TIntermTernary
*
node
)
override
;
bool
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
node
)
override
;
bool
foundLoopToChange
(
)
const
{
return
mFoundLoopToChange
;
}
protected
:
bool
mFoundLoopToChange
;
bool
mInsideLoopInitConditionOrExpression
;
IntermNodePatternMatcher
mConditionsToSimplify
;
}
;
SimplifyLoopConditionsTraverser
:
:
SimplifyLoopConditionsTraverser
(
unsigned
int
conditionsToSimplifyMask
TSymbolTable
*
symbolTable
)
:
TLValueTrackingTraverser
(
true
false
false
symbolTable
)
mFoundLoopToChange
(
false
)
mInsideLoopInitConditionOrExpression
(
false
)
mConditionsToSimplify
(
conditionsToSimplifyMask
)
{
}
bool
SimplifyLoopConditionsTraverser
:
:
visitUnary
(
Visit
visit
TIntermUnary
*
node
)
{
if
(
!
mInsideLoopInitConditionOrExpression
)
return
false
;
if
(
mFoundLoopToChange
)
return
false
;
mFoundLoopToChange
=
mConditionsToSimplify
.
match
(
node
)
;
return
!
mFoundLoopToChange
;
}
bool
SimplifyLoopConditionsTraverser
:
:
visitBinary
(
Visit
visit
TIntermBinary
*
node
)
{
if
(
!
mInsideLoopInitConditionOrExpression
)
return
false
;
if
(
mFoundLoopToChange
)
return
false
;
mFoundLoopToChange
=
mConditionsToSimplify
.
match
(
node
getParentNode
(
)
isLValueRequiredHere
(
)
)
;
return
!
mFoundLoopToChange
;
}
bool
SimplifyLoopConditionsTraverser
:
:
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
{
if
(
!
mInsideLoopInitConditionOrExpression
)
return
false
;
if
(
mFoundLoopToChange
)
return
false
;
mFoundLoopToChange
=
mConditionsToSimplify
.
match
(
node
getParentNode
(
)
)
;
return
!
mFoundLoopToChange
;
}
bool
SimplifyLoopConditionsTraverser
:
:
visitTernary
(
Visit
visit
TIntermTernary
*
node
)
{
if
(
!
mInsideLoopInitConditionOrExpression
)
return
false
;
if
(
mFoundLoopToChange
)
return
false
;
mFoundLoopToChange
=
mConditionsToSimplify
.
match
(
node
)
;
return
!
mFoundLoopToChange
;
}
bool
SimplifyLoopConditionsTraverser
:
:
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
node
)
{
if
(
!
mInsideLoopInitConditionOrExpression
)
return
false
;
if
(
mFoundLoopToChange
)
return
false
;
mFoundLoopToChange
=
mConditionsToSimplify
.
match
(
node
)
;
return
!
mFoundLoopToChange
;
}
void
SimplifyLoopConditionsTraverser
:
:
traverseLoop
(
TIntermLoop
*
node
)
{
ScopedNodeInTraversalPath
addToPath
(
this
node
)
;
mInsideLoopInitConditionOrExpression
=
true
;
mFoundLoopToChange
=
false
;
if
(
!
mFoundLoopToChange
&
&
node
-
>
getInit
(
)
)
{
node
-
>
getInit
(
)
-
>
traverse
(
this
)
;
}
if
(
!
mFoundLoopToChange
&
&
node
-
>
getCondition
(
)
)
{
node
-
>
getCondition
(
)
-
>
traverse
(
this
)
;
}
if
(
!
mFoundLoopToChange
&
&
node
-
>
getExpression
(
)
)
{
node
-
>
getExpression
(
)
-
>
traverse
(
this
)
;
}
mInsideLoopInitConditionOrExpression
=
false
;
if
(
mFoundLoopToChange
)
{
const
TType
*
boolType
=
StaticType
:
:
Get
<
EbtBool
EbpUndefined
EvqTemporary
1
1
>
(
)
;
TVariable
*
conditionVariable
=
CreateTempVariable
(
mSymbolTable
boolType
)
;
TLoopType
loopType
=
node
-
>
getType
(
)
;
if
(
loopType
=
=
ELoopWhile
)
{
TIntermDeclaration
*
tempInitDeclaration
=
CreateTempInitDeclarationNode
(
conditionVariable
node
-
>
getCondition
(
)
-
>
deepCopy
(
)
)
;
insertStatementInParentBlock
(
tempInitDeclaration
)
;
TIntermBlock
*
newBody
=
new
TIntermBlock
(
)
;
if
(
node
-
>
getBody
(
)
)
{
newBody
-
>
getSequence
(
)
-
>
push_back
(
node
-
>
getBody
(
)
)
;
}
newBody
-
>
getSequence
(
)
-
>
push_back
(
CreateTempAssignmentNode
(
conditionVariable
node
-
>
getCondition
(
)
-
>
deepCopy
(
)
)
)
;
node
-
>
setBody
(
newBody
)
;
node
-
>
setCondition
(
CreateTempSymbolNode
(
conditionVariable
)
)
;
}
else
if
(
loopType
=
=
ELoopDoWhile
)
{
TIntermDeclaration
*
tempInitDeclaration
=
CreateTempInitDeclarationNode
(
conditionVariable
CreateBoolNode
(
true
)
)
;
insertStatementInParentBlock
(
tempInitDeclaration
)
;
TIntermBlock
*
newBody
=
new
TIntermBlock
(
)
;
if
(
node
-
>
getBody
(
)
)
{
newBody
-
>
getSequence
(
)
-
>
push_back
(
node
-
>
getBody
(
)
)
;
}
newBody
-
>
getSequence
(
)
-
>
push_back
(
CreateTempAssignmentNode
(
conditionVariable
node
-
>
getCondition
(
)
-
>
deepCopy
(
)
)
)
;
node
-
>
setBody
(
newBody
)
;
node
-
>
setCondition
(
CreateTempSymbolNode
(
conditionVariable
)
)
;
}
else
if
(
loopType
=
=
ELoopFor
)
{
TIntermBlock
*
loopScope
=
new
TIntermBlock
(
)
;
TIntermSequence
*
loopScopeSequence
=
loopScope
-
>
getSequence
(
)
;
if
(
node
-
>
getInit
(
)
)
{
loopScopeSequence
-
>
push_back
(
node
-
>
getInit
(
)
)
;
}
TIntermTyped
*
conditionInitializer
=
nullptr
;
if
(
node
-
>
getCondition
(
)
)
{
conditionInitializer
=
node
-
>
getCondition
(
)
-
>
deepCopy
(
)
;
}
else
{
conditionInitializer
=
CreateBoolNode
(
true
)
;
}
loopScopeSequence
-
>
push_back
(
CreateTempInitDeclarationNode
(
conditionVariable
conditionInitializer
)
)
;
TIntermBlock
*
whileLoopBody
=
new
TIntermBlock
(
)
;
if
(
node
-
>
getBody
(
)
)
{
whileLoopBody
-
>
getSequence
(
)
-
>
push_back
(
node
-
>
getBody
(
)
)
;
}
if
(
node
-
>
getExpression
(
)
)
{
whileLoopBody
-
>
getSequence
(
)
-
>
push_back
(
node
-
>
getExpression
(
)
)
;
}
if
(
node
-
>
getCondition
(
)
)
{
whileLoopBody
-
>
getSequence
(
)
-
>
push_back
(
CreateTempAssignmentNode
(
conditionVariable
node
-
>
getCondition
(
)
-
>
deepCopy
(
)
)
)
;
}
TIntermLoop
*
whileLoop
=
new
TIntermLoop
(
ELoopWhile
nullptr
CreateTempSymbolNode
(
conditionVariable
)
nullptr
whileLoopBody
)
;
loopScope
-
>
getSequence
(
)
-
>
push_back
(
whileLoop
)
;
queueReplacement
(
loopScope
OriginalNode
:
:
IS_DROPPED
)
;
}
}
mFoundLoopToChange
=
false
;
if
(
node
-
>
getBody
(
)
)
node
-
>
getBody
(
)
-
>
traverse
(
this
)
;
}
}
bool
SimplifyLoopConditions
(
TCompiler
*
compiler
TIntermNode
*
root
unsigned
int
conditionsToSimplifyMask
TSymbolTable
*
symbolTable
)
{
SimplifyLoopConditionsTraverser
traverser
(
conditionsToSimplifyMask
symbolTable
)
;
root
-
>
traverse
(
&
traverser
)
;
return
traverser
.
updateTree
(
compiler
root
)
;
}
}
