#
include
"
compiler
/
translator
/
tree_ops
/
RewritePixelLocalStorage
.
h
"
#
include
"
common
/
angleutils
.
h
"
#
include
"
compiler
/
translator
/
StaticType
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
"
compiler
/
translator
/
tree_ops
/
MonomorphizeUnsupportedFunctions
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
BuiltIn
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
FindMain
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
constexpr
static
TBasicType
DataTypeOfPLSType
(
TBasicType
plsType
)
{
switch
(
plsType
)
{
case
EbtPixelLocalANGLE
:
return
EbtFloat
;
case
EbtIPixelLocalANGLE
:
return
EbtInt
;
case
EbtUPixelLocalANGLE
:
return
EbtUInt
;
default
:
UNREACHABLE
(
)
;
return
EbtVoid
;
}
}
constexpr
static
TBasicType
DataTypeOfImageType
(
TBasicType
imageType
)
{
switch
(
imageType
)
{
case
EbtImage2D
:
return
EbtFloat
;
case
EbtIImage2D
:
return
EbtInt
;
case
EbtUImage2D
:
return
EbtUInt
;
default
:
UNREACHABLE
(
)
;
return
EbtVoid
;
}
}
template
<
typename
T
>
class
PLSBackingStoreMap
{
public
:
void
insertNew
(
TIntermSymbol
*
plsSymbol
const
T
&
backingStore
)
{
ASSERT
(
plsSymbol
)
;
ASSERT
(
IsPixelLocal
(
plsSymbol
-
>
getBasicType
(
)
)
)
;
int
binding
=
plsSymbol
-
>
getType
(
)
.
getLayoutQualifier
(
)
.
binding
;
ASSERT
(
binding
>
=
0
)
;
auto
result
=
mMap
.
insert
(
{
binding
backingStore
}
)
;
ASSERT
(
result
.
second
)
;
}
const
T
&
find
(
TIntermSymbol
*
plsSymbol
)
{
ASSERT
(
plsSymbol
)
;
ASSERT
(
IsPixelLocal
(
plsSymbol
-
>
getBasicType
(
)
)
)
;
int
binding
=
plsSymbol
-
>
getType
(
)
.
getLayoutQualifier
(
)
.
binding
;
ASSERT
(
binding
>
=
0
)
;
auto
iter
=
mMap
.
find
(
binding
)
;
ASSERT
(
iter
!
=
mMap
.
end
(
)
)
;
return
iter
-
>
second
;
}
const
std
:
:
map
<
int
T
>
&
bindingOrderedMap
(
)
const
{
return
mMap
;
}
private
:
std
:
:
map
<
int
T
>
mMap
;
}
;
class
RewritePLSTraverser
:
public
TIntermTraverser
{
public
:
RewritePLSTraverser
(
TCompiler
*
compiler
TSymbolTable
&
symbolTable
const
ShCompileOptions
&
compileOptions
int
shaderVersion
)
:
TIntermTraverser
(
true
false
false
&
symbolTable
)
mCompiler
(
compiler
)
mCompileOptions
(
&
compileOptions
)
mShaderVersion
(
shaderVersion
)
{
}
bool
visitDeclaration
(
Visit
TIntermDeclaration
*
decl
)
override
{
TIntermTyped
*
declVariable
=
(
decl
-
>
getSequence
(
)
)
-
>
front
(
)
-
>
getAsTyped
(
)
;
ASSERT
(
declVariable
)
;
if
(
!
IsPixelLocal
(
declVariable
-
>
getBasicType
(
)
)
)
{
return
true
;
}
ASSERT
(
!
declVariable
-
>
isArray
(
)
)
;
ASSERT
(
declVariable
-
>
getQualifier
(
)
=
=
EvqUniform
)
;
TIntermSymbol
*
plsSymbol
=
declVariable
-
>
getAsSymbolNode
(
)
;
ASSERT
(
plsSymbol
)
;
visitPLSDeclaration
(
plsSymbol
)
;
return
false
;
}
bool
visitAggregate
(
Visit
TIntermAggregate
*
aggregate
)
override
{
if
(
!
BuiltInGroup
:
:
IsPixelLocal
(
aggregate
-
>
getOp
(
)
)
)
{
return
true
;
}
const
TIntermSequence
&
args
=
*
aggregate
-
>
getSequence
(
)
;
ASSERT
(
args
.
size
(
)
>
=
1
)
;
TIntermSymbol
*
plsSymbol
=
args
[
0
]
-
>
getAsSymbolNode
(
)
;
if
(
aggregate
-
>
getOp
(
)
=
=
EOpPixelLocalLoadANGLE
)
{
visitPLSLoad
(
plsSymbol
)
;
return
false
;
}
if
(
aggregate
-
>
getOp
(
)
=
=
EOpPixelLocalStoreANGLE
)
{
TType
*
valueType
=
new
TType
(
DataTypeOfPLSType
(
plsSymbol
-
>
getBasicType
(
)
)
plsSymbol
-
>
getPrecision
(
)
EvqTemporary
4
)
;
TVariable
*
valueVar
=
CreateTempVariable
(
mSymbolTable
valueType
)
;
TIntermDeclaration
*
valueDecl
=
CreateTempInitDeclarationNode
(
valueVar
args
[
1
]
-
>
getAsTyped
(
)
)
;
valueDecl
-
>
traverse
(
this
)
;
insertStatementInParentBlock
(
valueDecl
)
;
visitPLSStore
(
plsSymbol
valueVar
)
;
return
false
;
}
return
true
;
}
virtual
void
injectSetupCode
(
TCompiler
*
TSymbolTable
&
const
ShCompileOptions
&
TIntermBlock
*
mainBody
size_t
plsBeginPosition
)
{
}
virtual
void
injectFinalizeCode
(
TCompiler
*
TSymbolTable
&
const
ShCompileOptions
&
TIntermBlock
*
mainBody
size_t
plsEndPosition
)
{
}
TVariable
*
globalPixelCoord
(
)
const
{
return
mGlobalPixelCoord
;
}
protected
:
virtual
void
visitPLSDeclaration
(
TIntermSymbol
*
plsSymbol
)
=
0
;
virtual
void
visitPLSLoad
(
TIntermSymbol
*
plsSymbol
)
=
0
;
virtual
void
visitPLSStore
(
TIntermSymbol
*
plsSymbol
TVariable
*
value
)
=
0
;
void
ensureGlobalPixelCoordDeclared
(
)
{
if
(
!
mGlobalPixelCoord
)
{
TType
*
coordType
=
new
TType
(
EbtInt
EbpHigh
EvqGlobal
2
)
;
mGlobalPixelCoord
=
CreateTempVariable
(
mSymbolTable
coordType
)
;
insertStatementInParentBlock
(
CreateTempDeclarationNode
(
mGlobalPixelCoord
)
)
;
}
}
const
TCompiler
*
const
mCompiler
;
const
ShCompileOptions
*
const
mCompileOptions
;
const
int
mShaderVersion
;
TVariable
*
mGlobalPixelCoord
=
nullptr
;
}
;
class
RewritePLSToImagesTraverser
:
public
RewritePLSTraverser
{
public
:
RewritePLSToImagesTraverser
(
TCompiler
*
compiler
TSymbolTable
&
symbolTable
const
ShCompileOptions
&
compileOptions
int
shaderVersion
)
:
RewritePLSTraverser
(
compiler
symbolTable
compileOptions
shaderVersion
)
{
}
private
:
void
visitPLSDeclaration
(
TIntermSymbol
*
plsSymbol
)
override
{
ensureGlobalPixelCoordDeclared
(
)
;
TVariable
*
image2D
=
createPLSImageReplacement
(
plsSymbol
)
;
mImages
.
insertNew
(
plsSymbol
image2D
)
;
queueReplacement
(
new
TIntermDeclaration
(
{
new
TIntermSymbol
(
image2D
)
}
)
OriginalNode
:
:
IS_DROPPED
)
;
}
bool
needsR32Packing
(
)
const
{
return
mCompileOptions
-
>
pls
.
type
=
=
ShPixelLocalStorageType
:
:
ImageStoreR32PackedFormats
;
}
TVariable
*
createPLSImageReplacement
(
const
TIntermSymbol
*
plsSymbol
)
{
ASSERT
(
plsSymbol
)
;
ASSERT
(
IsPixelLocal
(
plsSymbol
-
>
getBasicType
(
)
)
)
;
TType
*
imageType
=
new
TType
(
plsSymbol
-
>
getType
(
)
)
;
TLayoutQualifier
layoutQualifier
=
imageType
-
>
getLayoutQualifier
(
)
;
switch
(
layoutQualifier
.
imageInternalFormat
)
{
case
TLayoutImageInternalFormat
:
:
EiifRGBA8
:
if
(
needsR32Packing
(
)
)
{
layoutQualifier
.
imageInternalFormat
=
EiifR32UI
;
imageType
-
>
setPrecision
(
EbpHigh
)
;
imageType
-
>
setBasicType
(
EbtUImage2D
)
;
}
else
{
imageType
-
>
setBasicType
(
EbtImage2D
)
;
}
break
;
case
TLayoutImageInternalFormat
:
:
EiifRGBA8I
:
if
(
needsR32Packing
(
)
)
{
layoutQualifier
.
imageInternalFormat
=
EiifR32I
;
imageType
-
>
setPrecision
(
EbpHigh
)
;
}
imageType
-
>
setBasicType
(
EbtIImage2D
)
;
break
;
case
TLayoutImageInternalFormat
:
:
EiifRGBA8UI
:
if
(
needsR32Packing
(
)
)
{
layoutQualifier
.
imageInternalFormat
=
EiifR32UI
;
imageType
-
>
setPrecision
(
EbpHigh
)
;
}
imageType
-
>
setBasicType
(
EbtUImage2D
)
;
break
;
case
TLayoutImageInternalFormat
:
:
EiifR32F
:
imageType
-
>
setBasicType
(
EbtImage2D
)
;
break
;
case
TLayoutImageInternalFormat
:
:
EiifR32UI
:
imageType
-
>
setBasicType
(
EbtUImage2D
)
;
break
;
default
:
UNREACHABLE
(
)
;
}
layoutQualifier
.
rasterOrdered
=
mCompileOptions
-
>
pls
.
fragmentSynchronizationType
=
=
ShFragmentSynchronizationType
:
:
RasterizerOrderViews_D3D
;
imageType
-
>
setLayoutQualifier
(
layoutQualifier
)
;
TMemoryQualifier
memoryQualifier
{
}
;
memoryQualifier
.
coherent
=
true
;
memoryQualifier
.
restrictQualifier
=
true
;
memoryQualifier
.
volatileQualifier
=
false
;
memoryQualifier
.
readonly
=
false
;
memoryQualifier
.
writeonly
=
false
;
imageType
-
>
setMemoryQualifier
(
memoryQualifier
)
;
const
TVariable
&
plsVar
=
plsSymbol
-
>
variable
(
)
;
return
new
TVariable
(
plsVar
.
uniqueId
(
)
plsVar
.
name
(
)
plsVar
.
symbolType
(
)
plsVar
.
extensions
(
)
imageType
)
;
}
void
visitPLSLoad
(
TIntermSymbol
*
plsSymbol
)
override
{
TVariable
*
image2D
=
mImages
.
find
(
plsSymbol
)
;
ASSERT
(
mGlobalPixelCoord
)
;
TIntermTyped
*
pls
=
CreateBuiltInFunctionCallNode
(
"
imageLoad
"
{
new
TIntermSymbol
(
image2D
)
new
TIntermSymbol
(
mGlobalPixelCoord
)
}
*
mSymbolTable
310
)
;
pls
=
unpackImageDataIfNecessary
(
pls
plsSymbol
image2D
)
;
queueReplacement
(
pls
OriginalNode
:
:
IS_DROPPED
)
;
}
TIntermTyped
*
unpackImageDataIfNecessary
(
TIntermTyped
*
data
TIntermSymbol
*
plsSymbol
TVariable
*
image2D
)
{
TLayoutImageInternalFormat
plsFormat
=
plsSymbol
-
>
getType
(
)
.
getLayoutQualifier
(
)
.
imageInternalFormat
;
TLayoutImageInternalFormat
imageFormat
=
image2D
-
>
getType
(
)
.
getLayoutQualifier
(
)
.
imageInternalFormat
;
if
(
plsFormat
=
=
imageFormat
)
{
return
data
;
}
ASSERT
(
needsR32Packing
(
)
)
;
switch
(
plsFormat
)
{
case
EiifRGBA8
:
data
=
CreateBuiltInFunctionCallNode
(
"
unpackUnorm4x8
"
{
CreateSwizzle
(
data
0
)
}
*
mSymbolTable
310
)
;
break
;
case
EiifRGBA8I
:
case
EiifRGBA8UI
:
{
constexpr
unsigned
shifts
[
]
=
{
24
16
8
0
}
;
data
=
CreateSwizzle
(
data
0
0
0
0
)
;
data
=
new
TIntermBinary
(
EOpBitShiftLeft
data
CreateUVecNode
(
shifts
4
EbpHigh
)
)
;
data
=
new
TIntermBinary
(
EOpBitShiftRight
data
CreateUIntNode
(
24
)
)
;
break
;
}
default
:
UNREACHABLE
(
)
;
}
return
data
;
}
void
visitPLSStore
(
TIntermSymbol
*
plsSymbol
TVariable
*
value
)
override
{
TVariable
*
image2D
=
mImages
.
find
(
plsSymbol
)
;
TIntermTyped
*
packedData
=
clampAndPackPLSDataIfNecessary
(
value
plsSymbol
image2D
)
;
insertStatementsInParentBlock
(
{
CreateBuiltInFunctionCallNode
(
"
memoryBarrierImage
"
{
}
*
mSymbolTable
310
)
}
{
CreateBuiltInFunctionCallNode
(
"
memoryBarrierImage
"
{
}
*
mSymbolTable
310
)
}
)
;
ASSERT
(
mGlobalPixelCoord
)
;
queueReplacement
(
CreateBuiltInFunctionCallNode
(
"
imageStore
"
{
new
TIntermSymbol
(
image2D
)
new
TIntermSymbol
(
mGlobalPixelCoord
)
packedData
}
*
mSymbolTable
310
)
OriginalNode
:
:
IS_DROPPED
)
;
}
TIntermTyped
*
clampAndPackPLSDataIfNecessary
(
TVariable
*
plsVar
TIntermSymbol
*
plsSymbol
TVariable
*
image2D
)
{
TLayoutImageInternalFormat
plsFormat
=
plsSymbol
-
>
getType
(
)
.
getLayoutQualifier
(
)
.
imageInternalFormat
;
switch
(
plsFormat
)
{
case
EiifRGBA8I
:
{
TIntermTyped
*
newPLSValue
=
CreateBuiltInFunctionCallNode
(
"
clamp
"
{
new
TIntermSymbol
(
plsVar
)
CreateIndexNode
(
-
128
)
CreateIndexNode
(
127
)
}
*
mSymbolTable
mShaderVersion
)
;
insertStatementInParentBlock
(
CreateTempAssignmentNode
(
plsVar
newPLSValue
)
)
;
break
;
}
case
EiifRGBA8UI
:
{
TIntermTyped
*
newPLSValue
=
CreateBuiltInFunctionCallNode
(
"
min
"
{
new
TIntermSymbol
(
plsVar
)
CreateUIntNode
(
255
)
}
*
mSymbolTable
mShaderVersion
)
;
insertStatementInParentBlock
(
CreateTempAssignmentNode
(
plsVar
newPLSValue
)
)
;
break
;
}
default
:
break
;
}
TIntermTyped
*
result
=
new
TIntermSymbol
(
plsVar
)
;
TLayoutImageInternalFormat
imageFormat
=
image2D
-
>
getType
(
)
.
getLayoutQualifier
(
)
.
imageInternalFormat
;
if
(
plsFormat
=
=
imageFormat
)
{
return
result
;
}
ASSERT
(
needsR32Packing
(
)
)
;
switch
(
plsFormat
)
{
case
EiifRGBA8
:
{
if
(
mCompileOptions
-
>
passHighpToPackUnormSnormBuiltins
)
{
TType
*
highpType
=
new
TType
(
EbtFloat
EbpHigh
EvqTemporary
4
)
;
TVariable
*
workaroundHighpVar
=
CreateTempVariable
(
mSymbolTable
highpType
)
;
insertStatementInParentBlock
(
CreateTempInitDeclarationNode
(
workaroundHighpVar
result
)
)
;
result
=
new
TIntermSymbol
(
workaroundHighpVar
)
;
}
result
=
CreateBuiltInFunctionCallNode
(
"
packUnorm4x8
"
{
result
}
*
mSymbolTable
310
)
;
break
;
}
case
EiifRGBA8I
:
case
EiifRGBA8UI
:
{
if
(
plsFormat
=
=
EiifRGBA8I
)
{
insertStatementInParentBlock
(
new
TIntermBinary
(
EOpBitwiseAndAssign
new
TIntermSymbol
(
plsVar
)
CreateIndexNode
(
0xff
)
)
)
;
}
auto
shiftComponent
=
[
=
]
(
int
componentIdx
)
{
return
new
TIntermBinary
(
EOpBitShiftLeft
CreateSwizzle
(
new
TIntermSymbol
(
plsVar
)
componentIdx
)
CreateUIntNode
(
componentIdx
*
8
)
)
;
}
;
result
=
CreateSwizzle
(
result
0
)
;
result
=
new
TIntermBinary
(
EOpBitwiseOr
result
shiftComponent
(
1
)
)
;
result
=
new
TIntermBinary
(
EOpBitwiseOr
result
shiftComponent
(
2
)
)
;
result
=
new
TIntermBinary
(
EOpBitwiseOr
result
shiftComponent
(
3
)
)
;
break
;
}
default
:
UNREACHABLE
(
)
;
}
TType
imageStoreType
(
DataTypeOfImageType
(
image2D
-
>
getType
(
)
.
getBasicType
(
)
)
4
)
;
return
TIntermAggregate
:
:
CreateConstructor
(
imageStoreType
{
result
}
)
;
}
void
injectSetupCode
(
TCompiler
*
compiler
TSymbolTable
&
symbolTable
const
ShCompileOptions
&
compileOptions
TIntermBlock
*
mainBody
size_t
plsBeginPosition
)
override
{
compiler
-
>
specifyEarlyFragmentTests
(
)
;
switch
(
compileOptions
.
pls
.
fragmentSynchronizationType
)
{
case
ShFragmentSynchronizationType
:
:
RasterizerOrderViews_D3D
:
case
ShFragmentSynchronizationType
:
:
NotSupported
:
break
;
case
ShFragmentSynchronizationType
:
:
FragmentShaderInterlock_NV_GL
:
mainBody
-
>
insertStatement
(
plsBeginPosition
CreateBuiltInFunctionCallNode
(
"
beginInvocationInterlockNV
"
{
}
symbolTable
kESSLInternalBackendBuiltIns
)
)
;
break
;
case
ShFragmentSynchronizationType
:
:
FragmentShaderOrdering_INTEL_GL
:
mainBody
-
>
insertStatement
(
plsBeginPosition
CreateBuiltInFunctionCallNode
(
"
beginFragmentShaderOrderingINTEL
"
{
}
symbolTable
kESSLInternalBackendBuiltIns
)
)
;
break
;
case
ShFragmentSynchronizationType
:
:
FragmentShaderInterlock_ARB_GL
:
mainBody
-
>
insertStatement
(
plsBeginPosition
CreateBuiltInFunctionCallNode
(
"
beginInvocationInterlockARB
"
{
}
symbolTable
kESSLInternalBackendBuiltIns
)
)
;
break
;
default
:
UNREACHABLE
(
)
;
}
}
void
injectFinalizeCode
(
TCompiler
*
TSymbolTable
&
symbolTable
const
ShCompileOptions
&
compileOptions
TIntermBlock
*
mainBody
size_t
plsEndPosition
)
override
{
switch
(
compileOptions
.
pls
.
fragmentSynchronizationType
)
{
case
ShFragmentSynchronizationType
:
:
RasterizerOrderViews_D3D
:
case
ShFragmentSynchronizationType
:
:
FragmentShaderOrdering_INTEL_GL
:
case
ShFragmentSynchronizationType
:
:
NotSupported
:
break
;
case
ShFragmentSynchronizationType
:
:
FragmentShaderInterlock_NV_GL
:
mainBody
-
>
insertStatement
(
plsEndPosition
CreateBuiltInFunctionCallNode
(
"
endInvocationInterlockNV
"
{
}
symbolTable
kESSLInternalBackendBuiltIns
)
)
;
break
;
case
ShFragmentSynchronizationType
:
:
FragmentShaderInterlock_ARB_GL
:
mainBody
-
>
insertStatement
(
plsEndPosition
CreateBuiltInFunctionCallNode
(
"
endInvocationInterlockARB
"
{
}
symbolTable
kESSLInternalBackendBuiltIns
)
)
;
break
;
default
:
UNREACHABLE
(
)
;
}
}
PLSBackingStoreMap
<
TVariable
*
>
mImages
;
}
;
class
RewritePLSToFramebufferFetchTraverser
:
public
RewritePLSTraverser
{
public
:
RewritePLSToFramebufferFetchTraverser
(
TCompiler
*
compiler
TSymbolTable
&
symbolTable
const
ShCompileOptions
&
compileOptions
int
shaderVersion
)
:
RewritePLSTraverser
(
compiler
symbolTable
compileOptions
shaderVersion
)
{
}
void
visitPLSDeclaration
(
TIntermSymbol
*
plsSymbol
)
override
{
PLSAttachment
attachment
(
mCompiler
mSymbolTable
*
mCompileOptions
plsSymbol
-
>
variable
(
)
)
;
mPLSAttachments
.
insertNew
(
plsSymbol
attachment
)
;
insertStatementInParentBlock
(
new
TIntermDeclaration
(
{
new
TIntermSymbol
(
attachment
.
fragmentVar
)
}
)
)
;
queueReplacement
(
CreateTempDeclarationNode
(
attachment
.
accessVar
)
OriginalNode
:
:
IS_DROPPED
)
;
}
void
visitPLSLoad
(
TIntermSymbol
*
plsSymbol
)
override
{
const
PLSAttachment
&
attachment
=
mPLSAttachments
.
find
(
plsSymbol
)
;
queueReplacement
(
attachment
.
expandAccessVar
(
)
OriginalNode
:
:
IS_DROPPED
)
;
}
void
visitPLSStore
(
TIntermSymbol
*
plsSymbol
TVariable
*
value
)
override
{
const
PLSAttachment
&
attachment
=
mPLSAttachments
.
find
(
plsSymbol
)
;
queueReplacement
(
CreateTempAssignmentNode
(
attachment
.
accessVar
attachment
.
swizzle
(
value
)
)
OriginalNode
:
:
IS_DROPPED
)
;
}
void
injectSetupCode
(
TCompiler
*
compiler
TSymbolTable
&
symbolTable
const
ShCompileOptions
&
compileOptions
TIntermBlock
*
mainBody
size_t
plsBeginPosition
)
override
{
std
:
:
vector
<
TIntermNode
*
>
plsPreloads
;
plsPreloads
.
reserve
(
mPLSAttachments
.
bindingOrderedMap
(
)
.
size
(
)
)
;
for
(
const
auto
&
entry
:
mPLSAttachments
.
bindingOrderedMap
(
)
)
{
const
PLSAttachment
&
attachment
=
entry
.
second
;
plsPreloads
.
push_back
(
CreateTempAssignmentNode
(
attachment
.
accessVar
attachment
.
swizzleFragmentVar
(
)
)
)
;
}
mainBody
-
>
getSequence
(
)
-
>
insert
(
mainBody
-
>
getSequence
(
)
-
>
begin
(
)
+
plsBeginPosition
plsPreloads
.
begin
(
)
plsPreloads
.
end
(
)
)
;
}
void
injectFinalizeCode
(
TCompiler
*
TSymbolTable
&
symbolTable
const
ShCompileOptions
&
compileOptions
TIntermBlock
*
mainBody
size_t
plsEndPosition
)
override
{
std
:
:
vector
<
TIntermNode
*
>
plsWrites
;
plsWrites
.
reserve
(
mPLSAttachments
.
bindingOrderedMap
(
)
.
size
(
)
)
;
for
(
const
auto
&
entry
:
mPLSAttachments
.
bindingOrderedMap
(
)
)
{
const
PLSAttachment
&
attachment
=
entry
.
second
;
plsWrites
.
push_back
(
new
TIntermBinary
(
EOpAssign
attachment
.
swizzleFragmentVar
(
)
new
TIntermSymbol
(
attachment
.
accessVar
)
)
)
;
}
mainBody
-
>
getSequence
(
)
-
>
insert
(
mainBody
-
>
getSequence
(
)
-
>
begin
(
)
+
plsEndPosition
plsWrites
.
begin
(
)
plsWrites
.
end
(
)
)
;
}
private
:
struct
PLSAttachment
{
PLSAttachment
(
const
TCompiler
*
compiler
TSymbolTable
*
symbolTable
const
ShCompileOptions
&
compileOptions
const
TVariable
&
plsVar
)
{
const
TType
&
plsType
=
plsVar
.
getType
(
)
;
TType
*
accessVarType
;
switch
(
plsType
.
getLayoutQualifier
(
)
.
imageInternalFormat
)
{
default
:
UNREACHABLE
(
)
;
[
[
fallthrough
]
]
;
case
EiifRGBA8
:
accessVarType
=
new
TType
(
EbtFloat
4
)
;
break
;
case
EiifRGBA8I
:
accessVarType
=
new
TType
(
EbtInt
4
)
;
break
;
case
EiifRGBA8UI
:
accessVarType
=
new
TType
(
EbtUInt
4
)
;
break
;
case
EiifR32F
:
accessVarType
=
new
TType
(
EbtFloat
1
)
;
break
;
case
EiifR32UI
:
accessVarType
=
new
TType
(
EbtUInt
1
)
;
break
;
}
accessVarType
-
>
setPrecision
(
plsType
.
getPrecision
(
)
)
;
accessVar
=
CreateTempVariable
(
symbolTable
accessVarType
)
;
TType
*
fragmentVarType
=
new
TType
(
accessVarType
-
>
getBasicType
(
)
4
)
;
fragmentVarType
-
>
setPrecision
(
plsType
.
getPrecision
(
)
)
;
fragmentVarType
-
>
setQualifier
(
EvqFragmentInOut
)
;
TLayoutQualifier
layoutQualifier
=
TLayoutQualifier
:
:
Create
(
)
;
layoutQualifier
.
location
=
compiler
-
>
getResources
(
)
.
MaxCombinedDrawBuffersAndPixelLocalStoragePlanes
-
plsType
.
getLayoutQualifier
(
)
.
binding
-
1
;
layoutQualifier
.
locationsSpecified
=
1
;
if
(
compileOptions
.
pls
.
fragmentSynchronizationType
=
=
ShFragmentSynchronizationType
:
:
NotSupported
)
{
layoutQualifier
.
noncoherent
=
true
;
}
fragmentVarType
-
>
setLayoutQualifier
(
layoutQualifier
)
;
fragmentVar
=
new
TVariable
(
plsVar
.
uniqueId
(
)
plsVar
.
name
(
)
plsVar
.
symbolType
(
)
plsVar
.
extensions
(
)
fragmentVarType
)
;
}
TIntermTyped
*
expandAccessVar
(
)
const
{
TIntermTyped
*
expanded
=
new
TIntermSymbol
(
accessVar
)
;
if
(
accessVar
-
>
getType
(
)
.
getNominalSize
(
)
=
=
1
)
{
switch
(
accessVar
-
>
getType
(
)
.
getBasicType
(
)
)
{
case
EbtFloat
:
expanded
=
TIntermAggregate
:
:
CreateConstructor
(
TType
(
EbtFloat
4
)
{
expanded
CreateFloatNode
(
0
EbpHigh
)
CreateFloatNode
(
0
EbpHigh
)
CreateFloatNode
(
1
EbpHigh
)
}
)
;
break
;
case
EbtUInt
:
expanded
=
TIntermAggregate
:
:
CreateConstructor
(
TType
(
EbtUInt
4
)
{
expanded
CreateUIntNode
(
0
)
CreateUIntNode
(
0
)
CreateUIntNode
(
1
)
}
)
;
break
;
default
:
UNREACHABLE
(
)
;
break
;
}
}
return
expanded
;
}
TIntermTyped
*
swizzle
(
TVariable
*
var
)
const
{
TIntermTyped
*
swizzled
=
new
TIntermSymbol
(
var
)
;
if
(
var
-
>
getType
(
)
.
getNominalSize
(
)
!
=
accessVar
-
>
getType
(
)
.
getNominalSize
(
)
)
{
ASSERT
(
var
-
>
getType
(
)
.
getNominalSize
(
)
>
accessVar
-
>
getType
(
)
.
getNominalSize
(
)
)
;
TVector
swizzleOffsets
{
0
1
2
3
}
;
swizzleOffsets
.
resize
(
accessVar
-
>
getType
(
)
.
getNominalSize
(
)
)
;
swizzled
=
new
TIntermSwizzle
(
swizzled
swizzleOffsets
)
;
}
return
swizzled
;
}
TIntermTyped
*
swizzleFragmentVar
(
)
const
{
return
swizzle
(
fragmentVar
)
;
}
TVariable
*
fragmentVar
;
TVariable
*
accessVar
;
}
;
PLSBackingStoreMap
<
PLSAttachment
>
mPLSAttachments
;
}
;
}
bool
RewritePixelLocalStorage
(
TCompiler
*
compiler
TIntermBlock
*
root
TSymbolTable
&
symbolTable
const
ShCompileOptions
&
compileOptions
int
shaderVersion
)
{
if
(
!
MonomorphizeUnsupportedFunctions
(
compiler
root
&
symbolTable
compileOptions
UnsupportedFunctionArgsBitSet
{
UnsupportedFunctionArgs
:
:
PixelLocalStorage
}
)
)
{
return
false
;
}
TIntermBlock
*
mainBody
=
FindMainBody
(
root
)
;
std
:
:
unique_ptr
<
RewritePLSTraverser
>
traverser
;
switch
(
compileOptions
.
pls
.
type
)
{
case
ShPixelLocalStorageType
:
:
ImageStoreR32PackedFormats
:
case
ShPixelLocalStorageType
:
:
ImageStoreNativeFormats
:
traverser
=
std
:
:
make_unique
<
RewritePLSToImagesTraverser
>
(
compiler
symbolTable
compileOptions
shaderVersion
)
;
break
;
case
ShPixelLocalStorageType
:
:
FramebufferFetch
:
traverser
=
std
:
:
make_unique
<
RewritePLSToFramebufferFetchTraverser
>
(
compiler
symbolTable
compileOptions
shaderVersion
)
;
break
;
default
:
UNREACHABLE
(
)
;
return
false
;
}
root
-
>
traverse
(
traverser
.
get
(
)
)
;
if
(
!
traverser
-
>
updateTree
(
compiler
root
)
)
{
return
false
;
}
traverser
-
>
injectSetupCode
(
compiler
symbolTable
compileOptions
mainBody
0
)
;
traverser
-
>
injectFinalizeCode
(
compiler
symbolTable
compileOptions
mainBody
mainBody
-
>
getChildCount
(
)
)
;
if
(
traverser
-
>
globalPixelCoord
(
)
)
{
TIntermTyped
*
exp
;
exp
=
ReferenceBuiltInVariable
(
ImmutableString
(
"
gl_FragCoord
"
)
symbolTable
shaderVersion
)
;
exp
=
CreateSwizzle
(
exp
0
1
)
;
exp
=
CreateBuiltInFunctionCallNode
(
"
floor
"
{
exp
}
symbolTable
shaderVersion
)
;
exp
=
TIntermAggregate
:
:
CreateConstructor
(
TType
(
EbtInt
2
)
{
exp
}
)
;
exp
=
CreateTempAssignmentNode
(
traverser
-
>
globalPixelCoord
(
)
exp
)
;
mainBody
-
>
insertStatement
(
0
exp
)
;
}
return
compiler
-
>
validateAST
(
root
)
;
}
}
