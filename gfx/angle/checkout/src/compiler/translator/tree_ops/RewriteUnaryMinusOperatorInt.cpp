#
include
"
compiler
/
translator
/
tree_ops
/
RewriteUnaryMinusOperatorInt
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
class
Traverser
:
public
TIntermTraverser
{
public
:
static
void
Apply
(
TIntermNode
*
root
)
;
private
:
Traverser
(
)
;
bool
visitUnary
(
Visit
visit
TIntermUnary
*
node
)
override
;
void
nextIteration
(
)
;
bool
mFound
=
false
;
}
;
void
Traverser
:
:
Apply
(
TIntermNode
*
root
)
{
Traverser
traverser
;
do
{
traverser
.
nextIteration
(
)
;
root
-
>
traverse
(
&
traverser
)
;
if
(
traverser
.
mFound
)
{
traverser
.
updateTree
(
)
;
}
}
while
(
traverser
.
mFound
)
;
}
Traverser
:
:
Traverser
(
)
:
TIntermTraverser
(
true
false
false
)
{
}
void
Traverser
:
:
nextIteration
(
)
{
mFound
=
false
;
}
bool
Traverser
:
:
visitUnary
(
Visit
visit
TIntermUnary
*
node
)
{
if
(
mFound
)
{
return
false
;
}
if
(
node
-
>
getOp
(
)
!
=
EOpNegative
)
{
return
true
;
}
TIntermTyped
*
opr
=
node
-
>
getOperand
(
)
;
if
(
!
opr
-
>
getType
(
)
.
isScalarInt
(
)
)
{
return
true
;
}
TIntermUnary
*
bitwiseNot
=
new
TIntermUnary
(
EOpBitwiseNot
opr
nullptr
)
;
bitwiseNot
-
>
setLine
(
opr
-
>
getLine
(
)
)
;
TConstantUnion
*
one
=
new
TConstantUnion
(
)
;
if
(
opr
-
>
getType
(
)
.
getBasicType
(
)
=
=
EbtInt
)
{
one
-
>
setIConst
(
1
)
;
}
else
{
one
-
>
setUConst
(
1u
)
;
}
TIntermConstantUnion
*
oneNode
=
new
TIntermConstantUnion
(
one
TType
(
opr
-
>
getBasicType
(
)
opr
-
>
getPrecision
(
)
EvqConst
)
)
;
oneNode
-
>
setLine
(
opr
-
>
getLine
(
)
)
;
TIntermBinary
*
add
=
new
TIntermBinary
(
EOpAdd
bitwiseNot
oneNode
)
;
add
-
>
setLine
(
opr
-
>
getLine
(
)
)
;
queueReplacement
(
add
OriginalNode
:
:
IS_DROPPED
)
;
mFound
=
true
;
return
false
;
}
}
void
RewriteUnaryMinusOperatorInt
(
TIntermNode
*
root
)
{
Traverser
:
:
Apply
(
root
)
;
}
}
