#
include
"
compiler
/
translator
/
tree_ops
/
RewriteDfdy
.
h
"
#
include
"
common
/
angleutils
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
class
Traverser
:
public
TIntermTraverser
{
public
:
static
void
Apply
(
TIntermNode
*
root
const
TSymbolTable
&
symbolTable
TIntermBinary
*
viewportYScale
)
;
private
:
Traverser
(
TIntermBinary
*
viewportYScale
TSymbolTable
*
symbolTable
)
;
bool
visitUnary
(
Visit
visit
TIntermUnary
*
node
)
override
;
TIntermBinary
*
mViewportYScale
=
nullptr
;
}
;
Traverser
:
:
Traverser
(
TIntermBinary
*
viewportYScale
TSymbolTable
*
symbolTable
)
:
TIntermTraverser
(
true
false
false
symbolTable
)
mViewportYScale
(
viewportYScale
)
{
}
void
Traverser
:
:
Apply
(
TIntermNode
*
root
const
TSymbolTable
&
symbolTable
TIntermBinary
*
viewportYScale
)
{
TSymbolTable
*
pSymbolTable
=
const_cast
<
TSymbolTable
*
>
(
&
symbolTable
)
;
Traverser
traverser
(
viewportYScale
pSymbolTable
)
;
root
-
>
traverse
(
&
traverser
)
;
traverser
.
updateTree
(
)
;
}
bool
Traverser
:
:
visitUnary
(
Visit
visit
TIntermUnary
*
node
)
{
if
(
node
-
>
getOp
(
)
!
=
EOpDFdy
)
{
return
true
;
}
TIntermUnary
*
newDfdy
=
node
-
>
deepCopy
(
)
-
>
getAsUnaryNode
(
)
;
size_t
objectSize
=
node
-
>
getType
(
)
.
getObjectSize
(
)
;
TOperator
multiplyOp
=
(
objectSize
=
=
1
)
?
EOpMul
:
EOpVectorTimesScalar
;
TIntermBinary
*
correctedDfdy
=
new
TIntermBinary
(
multiplyOp
newDfdy
mViewportYScale
)
;
queueReplacement
(
correctedDfdy
OriginalNode
:
:
IS_DROPPED
)
;
return
true
;
}
}
void
RewriteDfdy
(
TIntermNode
*
root
const
TSymbolTable
&
symbolTable
int
shaderVersion
TIntermBinary
*
viewportYScale
)
{
if
(
shaderVersion
<
300
)
return
;
Traverser
:
:
Apply
(
root
symbolTable
viewportYScale
)
;
}
}
