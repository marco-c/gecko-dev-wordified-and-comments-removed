#
include
"
RewriteAtomicFunctionExpressions
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNodePatternMatcher
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermNode_util
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
class
RewriteAtomicFunctionExpressionsTraverser
:
public
TIntermTraverser
{
public
:
RewriteAtomicFunctionExpressionsTraverser
(
TSymbolTable
*
symbolTable
)
;
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
;
private
:
static
bool
IsAtomicExchangeOrCompSwapNoReturnValue
(
TIntermAggregate
*
node
TIntermNode
*
parentNode
)
;
void
separateAtomicFunctionCallNode
(
TIntermAggregate
*
oldAtomicFunctionNode
)
;
}
;
RewriteAtomicFunctionExpressionsTraverser
:
:
RewriteAtomicFunctionExpressionsTraverser
(
TSymbolTable
*
symbolTable
)
:
TIntermTraverser
(
true
false
false
symbolTable
)
{
}
void
RewriteAtomicFunctionExpressionsTraverser
:
:
separateAtomicFunctionCallNode
(
TIntermAggregate
*
oldAtomicFunctionNode
)
{
ASSERT
(
oldAtomicFunctionNode
)
;
TIntermSequence
insertions
;
TIntermDeclaration
*
returnVariableDeclaration
;
TVariable
*
returnVariable
=
DeclareTempVariable
(
mSymbolTable
&
oldAtomicFunctionNode
-
>
getType
(
)
EvqTemporary
&
returnVariableDeclaration
)
;
insertions
.
push_back
(
returnVariableDeclaration
)
;
TIntermBinary
*
atomicFunctionAssignment
=
new
TIntermBinary
(
TOperator
:
:
EOpAssign
CreateTempSymbolNode
(
returnVariable
)
oldAtomicFunctionNode
)
;
insertStatementsInParentBlock
(
insertions
)
;
queueReplacement
(
atomicFunctionAssignment
OriginalNode
:
:
IS_DROPPED
)
;
}
bool
RewriteAtomicFunctionExpressionsTraverser
:
:
IsAtomicExchangeOrCompSwapNoReturnValue
(
TIntermAggregate
*
node
TIntermNode
*
parentNode
)
{
ASSERT
(
node
)
;
return
(
node
-
>
getOp
(
)
=
=
EOpAtomicExchange
|
|
node
-
>
getOp
(
)
=
=
EOpAtomicCompSwap
)
&
&
parentNode
&
&
parentNode
-
>
getAsBlock
(
)
;
}
bool
RewriteAtomicFunctionExpressionsTraverser
:
:
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
{
if
(
IsAtomicExchangeOrCompSwapNoReturnValue
(
node
getParentNode
(
)
)
)
{
separateAtomicFunctionCallNode
(
node
)
;
return
false
;
}
return
true
;
}
}
void
RewriteAtomicFunctionExpressions
(
TIntermNode
*
root
TSymbolTable
*
symbolTable
)
{
RewriteAtomicFunctionExpressionsTraverser
traverser
(
symbolTable
)
;
traverser
.
traverse
(
root
)
;
traverser
.
updateTree
(
)
;
}
}
