#
ifndef
COMPILER_TRANSLATOR_COMPILER_H_
#
define
COMPILER_TRANSLATOR_COMPILER_H_
#
include
<
GLSLANG
/
ShaderVars
.
h
>
#
include
"
common
/
PackedEnums
.
h
"
#
include
"
compiler
/
translator
/
BuiltInFunctionEmulator
.
h
"
#
include
"
compiler
/
translator
/
CallDAG
.
h
"
#
include
"
compiler
/
translator
/
Diagnostics
.
h
"
#
include
"
compiler
/
translator
/
ExtensionBehavior
.
h
"
#
include
"
compiler
/
translator
/
HashNames
.
h
"
#
include
"
compiler
/
translator
/
InfoSink
.
h
"
#
include
"
compiler
/
translator
/
Pragma
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
"
compiler
/
translator
/
ValidateAST
.
h
"
#
include
"
third_party
/
compiler
/
ArrayBoundsClamper
.
h
"
namespace
sh
{
class
TCompiler
;
class
TParseContext
;
#
ifdef
ANGLE_ENABLE_HLSL
class
TranslatorHLSL
;
#
endif
using
SpecConstUsageBits
=
angle
:
:
PackedEnumBitSet
<
vk
:
:
SpecConstUsage
uint32_t
>
;
bool
IsGLSL130OrNewer
(
ShShaderOutput
output
)
;
bool
IsGLSL420OrNewer
(
ShShaderOutput
output
)
;
bool
IsGLSL410OrOlder
(
ShShaderOutput
output
)
;
bool
RemoveInvariant
(
sh
:
:
GLenum
shaderType
int
shaderVersion
ShShaderOutput
outputType
ShCompileOptions
compileOptions
)
;
class
TShHandleBase
{
public
:
TShHandleBase
(
)
;
virtual
~
TShHandleBase
(
)
;
virtual
TCompiler
*
getAsCompiler
(
)
{
return
0
;
}
#
ifdef
ANGLE_ENABLE_HLSL
virtual
TranslatorHLSL
*
getAsTranslatorHLSL
(
)
{
return
0
;
}
#
endif
protected
:
angle
:
:
PoolAllocator
allocator
;
}
;
class
TCompiler
:
public
TShHandleBase
{
public
:
TCompiler
(
sh
:
:
GLenum
type
ShShaderSpec
spec
ShShaderOutput
output
)
;
~
TCompiler
(
)
override
;
TCompiler
*
getAsCompiler
(
)
override
{
return
this
;
}
bool
Init
(
const
ShBuiltInResources
&
resources
)
;
TIntermBlock
*
compileTreeForTesting
(
const
char
*
const
shaderStrings
[
]
size_t
numStrings
ShCompileOptions
compileOptions
)
;
bool
compile
(
const
char
*
const
shaderStrings
[
]
size_t
numStrings
ShCompileOptions
compileOptions
)
;
int
getShaderVersion
(
)
const
{
return
mShaderVersion
;
}
TInfoSink
&
getInfoSink
(
)
{
return
mInfoSink
;
}
bool
isEarlyFragmentTestsSpecified
(
)
const
{
return
mEarlyFragmentTestsSpecified
;
}
bool
isEarlyFragmentTestsOptimized
(
)
const
{
return
mEarlyFragmentTestsOptimized
;
}
SpecConstUsageBits
getSpecConstUsageBits
(
)
const
{
return
mSpecConstUsageBits
;
}
bool
isComputeShaderLocalSizeDeclared
(
)
const
{
return
mComputeShaderLocalSizeDeclared
;
}
const
sh
:
:
WorkGroupSize
&
getComputeShaderLocalSize
(
)
const
{
return
mComputeShaderLocalSize
;
}
int
getNumViews
(
)
const
{
return
mNumViews
;
}
void
clearResults
(
)
;
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
getAttributes
(
)
const
{
return
mAttributes
;
}
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
getOutputVariables
(
)
const
{
return
mOutputVariables
;
}
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
getUniforms
(
)
const
{
return
mUniforms
;
}
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
getInputVaryings
(
)
const
{
return
mInputVaryings
;
}
const
std
:
:
vector
<
sh
:
:
ShaderVariable
>
&
getOutputVaryings
(
)
const
{
return
mOutputVaryings
;
}
const
std
:
:
vector
<
sh
:
:
InterfaceBlock
>
&
getInterfaceBlocks
(
)
const
{
return
mInterfaceBlocks
;
}
const
std
:
:
vector
<
sh
:
:
InterfaceBlock
>
&
getUniformBlocks
(
)
const
{
return
mUniformBlocks
;
}
const
std
:
:
vector
<
sh
:
:
InterfaceBlock
>
&
getShaderStorageBlocks
(
)
const
{
return
mShaderStorageBlocks
;
}
ShHashFunction64
getHashFunction
(
)
const
{
return
mResources
.
HashFunction
;
}
NameMap
&
getNameMap
(
)
{
return
mNameMap
;
}
TSymbolTable
&
getSymbolTable
(
)
{
return
mSymbolTable
;
}
ShShaderSpec
getShaderSpec
(
)
const
{
return
mShaderSpec
;
}
ShShaderOutput
getOutputType
(
)
const
{
return
mOutputType
;
}
const
std
:
:
string
&
getBuiltInResourcesString
(
)
const
{
return
mBuiltInResourcesString
;
}
bool
shouldRunLoopAndIndexingValidation
(
ShCompileOptions
compileOptions
)
const
;
const
ShBuiltInResources
&
getResources
(
)
const
;
int
getGeometryShaderMaxVertices
(
)
const
{
return
mGeometryShaderMaxVertices
;
}
int
getGeometryShaderInvocations
(
)
const
{
return
mGeometryShaderInvocations
;
}
TLayoutPrimitiveType
getGeometryShaderInputPrimitiveType
(
)
const
{
return
mGeometryShaderInputPrimitiveType
;
}
TLayoutPrimitiveType
getGeometryShaderOutputPrimitiveType
(
)
const
{
return
mGeometryShaderOutputPrimitiveType
;
}
unsigned
int
getStructSize
(
const
ShaderVariable
&
var
)
const
;
int
getTessControlShaderOutputVertices
(
)
const
{
return
mTessControlShaderOutputVertices
;
}
TLayoutTessEvaluationType
getTessEvaluationShaderInputPrimitiveType
(
)
const
{
return
mTessEvaluationShaderInputPrimitiveType
;
}
TLayoutTessEvaluationType
getTessEvaluationShaderInputVertexSpacingType
(
)
const
{
return
mTessEvaluationShaderInputVertexSpacingType
;
}
TLayoutTessEvaluationType
getTessEvaluationShaderInputOrderingType
(
)
const
{
return
mTessEvaluationShaderInputOrderingType
;
}
TLayoutTessEvaluationType
getTessEvaluationShaderInputPointType
(
)
const
{
return
mTessEvaluationShaderInputPointType
;
}
unsigned
int
getSharedMemorySize
(
)
const
;
sh
:
:
GLenum
getShaderType
(
)
const
{
return
mShaderType
;
}
bool
validateAST
(
TIntermNode
*
root
)
;
protected
:
virtual
void
initBuiltInFunctionEmulator
(
BuiltInFunctionEmulator
*
emu
ShCompileOptions
compileOptions
)
{
}
ANGLE_NO_DISCARD
virtual
bool
translate
(
TIntermBlock
*
root
ShCompileOptions
compileOptions
PerformanceDiagnostics
*
perfDiagnostics
)
=
0
;
const
TExtensionBehavior
&
getExtensionBehavior
(
)
const
;
const
char
*
getSourcePath
(
)
const
;
const
TPragma
&
getPragma
(
)
const
{
return
mPragma
;
}
void
writePragma
(
ShCompileOptions
compileOptions
)
;
bool
isVaryingDefined
(
const
char
*
varyingName
)
;
const
ArrayBoundsClamper
&
getArrayBoundsClamper
(
)
const
;
ShArrayIndexClampingStrategy
getArrayIndexClampingStrategy
(
)
const
;
const
BuiltInFunctionEmulator
&
getBuiltInFunctionEmulator
(
)
const
;
virtual
bool
shouldFlattenPragmaStdglInvariantAll
(
)
=
0
;
virtual
bool
shouldCollectVariables
(
ShCompileOptions
compileOptions
)
;
bool
emulatePrecisionIfNeeded
(
TIntermBlock
*
root
TInfoSinkBase
&
sink
bool
*
isNeeded
const
ShShaderOutput
outputLanguage
)
;
bool
wereVariablesCollected
(
)
const
;
std
:
:
vector
<
sh
:
:
ShaderVariable
>
mAttributes
;
std
:
:
vector
<
sh
:
:
ShaderVariable
>
mOutputVariables
;
std
:
:
vector
<
sh
:
:
ShaderVariable
>
mUniforms
;
std
:
:
vector
<
sh
:
:
ShaderVariable
>
mInputVaryings
;
std
:
:
vector
<
sh
:
:
ShaderVariable
>
mOutputVaryings
;
std
:
:
vector
<
sh
:
:
ShaderVariable
>
mSharedVariables
;
std
:
:
vector
<
sh
:
:
InterfaceBlock
>
mInterfaceBlocks
;
std
:
:
vector
<
sh
:
:
InterfaceBlock
>
mUniformBlocks
;
std
:
:
vector
<
sh
:
:
InterfaceBlock
>
mShaderStorageBlocks
;
ValidateASTOptions
mValidateASTOptions
;
SpecConstUsageBits
mSpecConstUsageBits
;
private
:
bool
initBuiltInSymbolTable
(
const
ShBuiltInResources
&
resources
)
;
void
setResourceString
(
)
;
bool
checkCallDepth
(
)
;
ANGLE_NO_DISCARD
bool
useAllMembersInUnusedStandardAndSharedBlocks
(
TIntermBlock
*
root
)
;
ANGLE_NO_DISCARD
bool
initializeOutputVariables
(
TIntermBlock
*
root
)
;
ANGLE_NO_DISCARD
bool
initializeGLPosition
(
TIntermBlock
*
root
)
;
bool
limitExpressionComplexity
(
TIntermBlock
*
root
)
;
bool
initCallDag
(
TIntermNode
*
root
)
;
bool
tagUsedFunctions
(
)
;
void
internalTagUsedFunction
(
size_t
index
)
;
void
collectInterfaceBlocks
(
)
;
bool
mVariablesCollected
;
bool
mGLPositionInitialized
;
class
UnusedPredicate
;
void
pruneUnusedFunctions
(
TIntermBlock
*
root
)
;
TIntermBlock
*
compileTreeImpl
(
const
char
*
const
shaderStrings
[
]
size_t
numStrings
const
ShCompileOptions
compileOptions
)
;
void
setASTMetadata
(
const
TParseContext
&
parseContext
)
;
bool
checkShaderVersion
(
TParseContext
*
parseContext
)
;
bool
checkAndSimplifyAST
(
TIntermBlock
*
root
const
TParseContext
&
parseContext
ShCompileOptions
compileOptions
)
;
sh
:
:
GLenum
mShaderType
;
ShShaderSpec
mShaderSpec
;
ShShaderOutput
mOutputType
;
struct
FunctionMetadata
{
FunctionMetadata
(
)
:
used
(
false
)
{
}
bool
used
;
}
;
CallDAG
mCallDag
;
std
:
:
vector
<
FunctionMetadata
>
mFunctionMetadata
;
ShBuiltInResources
mResources
;
std
:
:
string
mBuiltInResourcesString
;
TSymbolTable
mSymbolTable
;
TExtensionBehavior
mExtensionBehavior
;
ArrayBoundsClamper
mArrayBoundsClamper
;
BuiltInFunctionEmulator
mBuiltInFunctionEmulator
;
int
mShaderVersion
;
TInfoSink
mInfoSink
;
TDiagnostics
mDiagnostics
;
const
char
*
mSourcePath
;
bool
mEarlyFragmentTestsSpecified
;
bool
mEarlyFragmentTestsOptimized
;
bool
mComputeShaderLocalSizeDeclared
;
sh
:
:
WorkGroupSize
mComputeShaderLocalSize
;
int
mNumViews
;
int
mGeometryShaderMaxVertices
;
int
mGeometryShaderInvocations
;
TLayoutPrimitiveType
mGeometryShaderInputPrimitiveType
;
TLayoutPrimitiveType
mGeometryShaderOutputPrimitiveType
;
int
mTessControlShaderOutputVertices
;
TLayoutTessEvaluationType
mTessEvaluationShaderInputPrimitiveType
;
TLayoutTessEvaluationType
mTessEvaluationShaderInputVertexSpacingType
;
TLayoutTessEvaluationType
mTessEvaluationShaderInputOrderingType
;
TLayoutTessEvaluationType
mTessEvaluationShaderInputPointType
;
NameMap
mNameMap
;
TPragma
mPragma
;
ShCompileOptions
mCompileOptions
;
}
;
TCompiler
*
ConstructCompiler
(
sh
:
:
GLenum
type
ShShaderSpec
spec
ShShaderOutput
output
)
;
void
DeleteCompiler
(
TCompiler
*
)
;
void
EmitEarlyFragmentTestsGLSL
(
const
TCompiler
&
TInfoSinkBase
&
sink
)
;
void
EmitWorkGroupSizeGLSL
(
const
TCompiler
&
TInfoSinkBase
&
sink
)
;
void
EmitMultiviewGLSL
(
const
TCompiler
&
const
ShCompileOptions
&
const
TExtension
const
TBehavior
TInfoSinkBase
&
sink
)
;
}
#
endif
