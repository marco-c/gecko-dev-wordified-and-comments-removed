#
include
"
compiler
/
translator
/
ValidateLimitations
.
h
"
#
include
"
angle_gl
.
h
"
#
include
"
compiler
/
translator
/
Diagnostics
.
h
"
#
include
"
compiler
/
translator
/
ParseContext
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
int
GetLoopSymbolId
(
TIntermLoop
*
loop
)
{
TIntermSequence
*
declSeq
=
loop
-
>
getInit
(
)
-
>
getAsDeclarationNode
(
)
-
>
getSequence
(
)
;
TIntermBinary
*
declInit
=
(
*
declSeq
)
[
0
]
-
>
getAsBinaryNode
(
)
;
TIntermSymbol
*
symbol
=
declInit
-
>
getLeft
(
)
-
>
getAsSymbolNode
(
)
;
return
symbol
-
>
uniqueId
(
)
.
get
(
)
;
}
class
ValidateConstIndexExpr
:
public
TIntermTraverser
{
public
:
ValidateConstIndexExpr
(
const
std
:
:
vector
<
int
>
&
loopSymbols
)
:
TIntermTraverser
(
true
false
false
)
mValid
(
true
)
mLoopSymbolIds
(
loopSymbols
)
{
}
bool
isValid
(
)
const
{
return
mValid
;
}
void
visitSymbol
(
TIntermSymbol
*
symbol
)
override
{
if
(
mValid
)
{
bool
isLoopSymbol
=
std
:
:
find
(
mLoopSymbolIds
.
begin
(
)
mLoopSymbolIds
.
end
(
)
symbol
-
>
uniqueId
(
)
.
get
(
)
)
!
=
mLoopSymbolIds
.
end
(
)
;
mValid
=
(
symbol
-
>
getQualifier
(
)
=
=
EvqConst
)
|
|
isLoopSymbol
;
}
}
private
:
bool
mValid
;
const
std
:
:
vector
<
int
>
mLoopSymbolIds
;
}
;
class
ValidateLimitationsTraverser
:
public
TLValueTrackingTraverser
{
public
:
ValidateLimitationsTraverser
(
sh
:
:
GLenum
shaderType
TSymbolTable
*
symbolTable
TDiagnostics
*
diagnostics
)
;
void
visitSymbol
(
TIntermSymbol
*
node
)
override
;
bool
visitBinary
(
Visit
TIntermBinary
*
)
override
;
bool
visitLoop
(
Visit
TIntermLoop
*
)
override
;
private
:
void
error
(
TSourceLoc
loc
const
char
*
reason
const
char
*
token
)
;
void
error
(
TSourceLoc
loc
const
char
*
reason
const
ImmutableString
&
token
)
;
bool
isLoopIndex
(
TIntermSymbol
*
symbol
)
;
bool
validateLoopType
(
TIntermLoop
*
node
)
;
bool
validateForLoopHeader
(
TIntermLoop
*
node
)
;
int
validateForLoopInit
(
TIntermLoop
*
node
)
;
bool
validateForLoopCond
(
TIntermLoop
*
node
int
indexSymbolId
)
;
bool
validateForLoopExpr
(
TIntermLoop
*
node
int
indexSymbolId
)
;
bool
isConstExpr
(
TIntermNode
*
node
)
;
bool
isConstIndexExpr
(
TIntermNode
*
node
)
;
bool
validateIndexing
(
TIntermBinary
*
node
)
;
sh
:
:
GLenum
mShaderType
;
TDiagnostics
*
mDiagnostics
;
std
:
:
vector
<
int
>
mLoopSymbolIds
;
}
;
ValidateLimitationsTraverser
:
:
ValidateLimitationsTraverser
(
sh
:
:
GLenum
shaderType
TSymbolTable
*
symbolTable
TDiagnostics
*
diagnostics
)
:
TLValueTrackingTraverser
(
true
false
false
symbolTable
)
mShaderType
(
shaderType
)
mDiagnostics
(
diagnostics
)
{
ASSERT
(
diagnostics
)
;
}
void
ValidateLimitationsTraverser
:
:
visitSymbol
(
TIntermSymbol
*
node
)
{
if
(
isLoopIndex
(
node
)
&
&
isLValueRequiredHere
(
)
)
{
error
(
node
-
>
getLine
(
)
"
Loop
index
cannot
be
statically
assigned
to
within
the
body
of
the
loop
"
node
-
>
getName
(
)
)
;
}
}
bool
ValidateLimitationsTraverser
:
:
visitBinary
(
Visit
TIntermBinary
*
node
)
{
switch
(
node
-
>
getOp
(
)
)
{
case
EOpIndexDirect
:
case
EOpIndexIndirect
:
validateIndexing
(
node
)
;
break
;
default
:
break
;
}
return
true
;
}
bool
ValidateLimitationsTraverser
:
:
visitLoop
(
Visit
TIntermLoop
*
node
)
{
if
(
!
validateLoopType
(
node
)
)
return
false
;
if
(
!
validateForLoopHeader
(
node
)
)
return
false
;
TIntermNode
*
body
=
node
-
>
getBody
(
)
;
if
(
body
!
=
nullptr
)
{
mLoopSymbolIds
.
push_back
(
GetLoopSymbolId
(
node
)
)
;
body
-
>
traverse
(
this
)
;
mLoopSymbolIds
.
pop_back
(
)
;
}
return
false
;
}
void
ValidateLimitationsTraverser
:
:
error
(
TSourceLoc
loc
const
char
*
reason
const
char
*
token
)
{
mDiagnostics
-
>
error
(
loc
reason
token
)
;
}
void
ValidateLimitationsTraverser
:
:
error
(
TSourceLoc
loc
const
char
*
reason
const
ImmutableString
&
token
)
{
error
(
loc
reason
token
.
data
(
)
)
;
}
bool
ValidateLimitationsTraverser
:
:
isLoopIndex
(
TIntermSymbol
*
symbol
)
{
return
std
:
:
find
(
mLoopSymbolIds
.
begin
(
)
mLoopSymbolIds
.
end
(
)
symbol
-
>
uniqueId
(
)
.
get
(
)
)
!
=
mLoopSymbolIds
.
end
(
)
;
}
bool
ValidateLimitationsTraverser
:
:
validateLoopType
(
TIntermLoop
*
node
)
{
TLoopType
type
=
node
-
>
getType
(
)
;
if
(
type
=
=
ELoopFor
)
return
true
;
error
(
node
-
>
getLine
(
)
"
This
type
of
loop
is
not
allowed
"
type
=
=
ELoopWhile
?
"
while
"
:
"
do
"
)
;
return
false
;
}
bool
ValidateLimitationsTraverser
:
:
validateForLoopHeader
(
TIntermLoop
*
node
)
{
ASSERT
(
node
-
>
getType
(
)
=
=
ELoopFor
)
;
int
indexSymbolId
=
validateForLoopInit
(
node
)
;
if
(
indexSymbolId
<
0
)
return
false
;
if
(
!
validateForLoopCond
(
node
indexSymbolId
)
)
return
false
;
if
(
!
validateForLoopExpr
(
node
indexSymbolId
)
)
return
false
;
return
true
;
}
int
ValidateLimitationsTraverser
:
:
validateForLoopInit
(
TIntermLoop
*
node
)
{
TIntermNode
*
init
=
node
-
>
getInit
(
)
;
if
(
init
=
=
nullptr
)
{
error
(
node
-
>
getLine
(
)
"
Missing
init
declaration
"
"
for
"
)
;
return
-
1
;
}
TIntermDeclaration
*
decl
=
init
-
>
getAsDeclarationNode
(
)
;
if
(
decl
=
=
nullptr
)
{
error
(
init
-
>
getLine
(
)
"
Invalid
init
declaration
"
"
for
"
)
;
return
-
1
;
}
TIntermSequence
*
declSeq
=
decl
-
>
getSequence
(
)
;
if
(
declSeq
-
>
size
(
)
!
=
1
)
{
error
(
decl
-
>
getLine
(
)
"
Invalid
init
declaration
"
"
for
"
)
;
return
-
1
;
}
TIntermBinary
*
declInit
=
(
*
declSeq
)
[
0
]
-
>
getAsBinaryNode
(
)
;
if
(
(
declInit
=
=
nullptr
)
|
|
(
declInit
-
>
getOp
(
)
!
=
EOpInitialize
)
)
{
error
(
decl
-
>
getLine
(
)
"
Invalid
init
declaration
"
"
for
"
)
;
return
-
1
;
}
TIntermSymbol
*
symbol
=
declInit
-
>
getLeft
(
)
-
>
getAsSymbolNode
(
)
;
if
(
symbol
=
=
nullptr
)
{
error
(
declInit
-
>
getLine
(
)
"
Invalid
init
declaration
"
"
for
"
)
;
return
-
1
;
}
TBasicType
type
=
symbol
-
>
getBasicType
(
)
;
if
(
(
type
!
=
EbtInt
)
&
&
(
type
!
=
EbtUInt
)
&
&
(
type
!
=
EbtFloat
)
)
{
error
(
symbol
-
>
getLine
(
)
"
Invalid
type
for
loop
index
"
getBasicString
(
type
)
)
;
return
-
1
;
}
if
(
!
isConstExpr
(
declInit
-
>
getRight
(
)
)
)
{
error
(
declInit
-
>
getLine
(
)
"
Loop
index
cannot
be
initialized
with
non
-
constant
expression
"
symbol
-
>
getName
(
)
)
;
return
-
1
;
}
return
symbol
-
>
uniqueId
(
)
.
get
(
)
;
}
bool
ValidateLimitationsTraverser
:
:
validateForLoopCond
(
TIntermLoop
*
node
int
indexSymbolId
)
{
TIntermNode
*
cond
=
node
-
>
getCondition
(
)
;
if
(
cond
=
=
nullptr
)
{
error
(
node
-
>
getLine
(
)
"
Missing
condition
"
"
for
"
)
;
return
false
;
}
TIntermBinary
*
binOp
=
cond
-
>
getAsBinaryNode
(
)
;
if
(
binOp
=
=
nullptr
)
{
error
(
node
-
>
getLine
(
)
"
Invalid
condition
"
"
for
"
)
;
return
false
;
}
TIntermSymbol
*
symbol
=
binOp
-
>
getLeft
(
)
-
>
getAsSymbolNode
(
)
;
if
(
symbol
=
=
nullptr
)
{
error
(
binOp
-
>
getLine
(
)
"
Invalid
condition
"
"
for
"
)
;
return
false
;
}
if
(
symbol
-
>
uniqueId
(
)
.
get
(
)
!
=
indexSymbolId
)
{
error
(
symbol
-
>
getLine
(
)
"
Expected
loop
index
"
symbol
-
>
getName
(
)
)
;
return
false
;
}
switch
(
binOp
-
>
getOp
(
)
)
{
case
EOpEqual
:
case
EOpNotEqual
:
case
EOpLessThan
:
case
EOpGreaterThan
:
case
EOpLessThanEqual
:
case
EOpGreaterThanEqual
:
break
;
default
:
error
(
binOp
-
>
getLine
(
)
"
Invalid
relational
operator
"
GetOperatorString
(
binOp
-
>
getOp
(
)
)
)
;
break
;
}
if
(
!
isConstExpr
(
binOp
-
>
getRight
(
)
)
)
{
error
(
binOp
-
>
getLine
(
)
"
Loop
index
cannot
be
compared
with
non
-
constant
expression
"
symbol
-
>
getName
(
)
)
;
return
false
;
}
return
true
;
}
bool
ValidateLimitationsTraverser
:
:
validateForLoopExpr
(
TIntermLoop
*
node
int
indexSymbolId
)
{
TIntermNode
*
expr
=
node
-
>
getExpression
(
)
;
if
(
expr
=
=
nullptr
)
{
error
(
node
-
>
getLine
(
)
"
Missing
expression
"
"
for
"
)
;
return
false
;
}
TIntermUnary
*
unOp
=
expr
-
>
getAsUnaryNode
(
)
;
TIntermBinary
*
binOp
=
unOp
?
nullptr
:
expr
-
>
getAsBinaryNode
(
)
;
TOperator
op
=
EOpNull
;
TIntermSymbol
*
symbol
=
nullptr
;
if
(
unOp
!
=
nullptr
)
{
op
=
unOp
-
>
getOp
(
)
;
symbol
=
unOp
-
>
getOperand
(
)
-
>
getAsSymbolNode
(
)
;
}
else
if
(
binOp
!
=
nullptr
)
{
op
=
binOp
-
>
getOp
(
)
;
symbol
=
binOp
-
>
getLeft
(
)
-
>
getAsSymbolNode
(
)
;
}
if
(
symbol
=
=
nullptr
)
{
error
(
expr
-
>
getLine
(
)
"
Invalid
expression
"
"
for
"
)
;
return
false
;
}
if
(
symbol
-
>
uniqueId
(
)
.
get
(
)
!
=
indexSymbolId
)
{
error
(
symbol
-
>
getLine
(
)
"
Expected
loop
index
"
symbol
-
>
getName
(
)
)
;
return
false
;
}
switch
(
op
)
{
case
EOpPostIncrement
:
case
EOpPostDecrement
:
case
EOpPreIncrement
:
case
EOpPreDecrement
:
ASSERT
(
(
unOp
!
=
nullptr
)
&
&
(
binOp
=
=
nullptr
)
)
;
break
;
case
EOpAddAssign
:
case
EOpSubAssign
:
ASSERT
(
(
unOp
=
=
nullptr
)
&
&
(
binOp
!
=
nullptr
)
)
;
break
;
default
:
error
(
expr
-
>
getLine
(
)
"
Invalid
operator
"
GetOperatorString
(
op
)
)
;
return
false
;
}
if
(
binOp
!
=
nullptr
)
{
if
(
!
isConstExpr
(
binOp
-
>
getRight
(
)
)
)
{
error
(
binOp
-
>
getLine
(
)
"
Loop
index
cannot
be
modified
by
non
-
constant
expression
"
symbol
-
>
getName
(
)
)
;
return
false
;
}
}
return
true
;
}
bool
ValidateLimitationsTraverser
:
:
isConstExpr
(
TIntermNode
*
node
)
{
ASSERT
(
node
!
=
nullptr
)
;
return
node
-
>
getAsConstantUnion
(
)
!
=
nullptr
&
&
node
-
>
getAsTyped
(
)
-
>
getQualifier
(
)
=
=
EvqConst
;
}
bool
ValidateLimitationsTraverser
:
:
isConstIndexExpr
(
TIntermNode
*
node
)
{
ASSERT
(
node
!
=
nullptr
)
;
ValidateConstIndexExpr
validate
(
mLoopSymbolIds
)
;
node
-
>
traverse
(
&
validate
)
;
return
validate
.
isValid
(
)
;
}
bool
ValidateLimitationsTraverser
:
:
validateIndexing
(
TIntermBinary
*
node
)
{
ASSERT
(
(
node
-
>
getOp
(
)
=
=
EOpIndexDirect
)
|
|
(
node
-
>
getOp
(
)
=
=
EOpIndexIndirect
)
)
;
bool
valid
=
true
;
TIntermTyped
*
index
=
node
-
>
getRight
(
)
;
TIntermTyped
*
operand
=
node
-
>
getLeft
(
)
;
bool
skip
=
(
mShaderType
=
=
GL_VERTEX_SHADER
)
&
&
(
operand
-
>
getQualifier
(
)
=
=
EvqUniform
)
;
if
(
!
skip
&
&
!
isConstIndexExpr
(
index
)
)
{
error
(
index
-
>
getLine
(
)
"
Index
expression
must
be
constant
"
"
[
]
"
)
;
valid
=
false
;
}
return
valid
;
}
}
bool
ValidateLimitations
(
TIntermNode
*
root
GLenum
shaderType
TSymbolTable
*
symbolTable
TDiagnostics
*
diagnostics
)
{
ValidateLimitationsTraverser
validate
(
shaderType
symbolTable
diagnostics
)
;
root
-
>
traverse
(
&
validate
)
;
return
diagnostics
-
>
numErrors
(
)
=
=
0
;
}
}
