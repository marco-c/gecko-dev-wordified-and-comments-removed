#
if
defined
(
_MSC_VER
)
#
pragma
warning
(
disable
:
4718
)
#
endif
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
<
algorithm
>
#
include
<
set
>
#
include
"
angle_gl
.
h
"
#
include
"
compiler
/
translator
/
ImmutableString
.
h
"
#
include
"
compiler
/
translator
/
IntermNode
.
h
"
#
include
"
compiler
/
translator
/
StaticType
.
h
"
namespace
sh
{
class
TSymbolTable
:
:
TSymbolTableLevel
{
public
:
TSymbolTableLevel
(
)
:
mGlobalInvariant
(
false
)
{
}
bool
insert
(
TSymbol
*
symbol
)
;
void
insertUnmangled
(
TFunction
*
function
)
;
TSymbol
*
find
(
const
ImmutableString
&
name
)
const
;
void
addInvariantVarying
(
const
ImmutableString
&
name
)
{
mInvariantVaryings
.
insert
(
name
)
;
}
bool
isVaryingInvariant
(
const
ImmutableString
&
name
)
{
return
(
mGlobalInvariant
|
|
mInvariantVaryings
.
count
(
name
)
>
0
)
;
}
void
setGlobalInvariant
(
bool
invariant
)
{
mGlobalInvariant
=
invariant
;
}
private
:
using
tLevel
=
TUnorderedMap
<
ImmutableString
TSymbol
*
ImmutableString
:
:
FowlerNollVoHash
<
sizeof
(
size_t
)
>
>
;
using
tLevelPair
=
const
tLevel
:
:
value_type
;
using
tInsertResult
=
std
:
:
pair
<
tLevel
:
:
iterator
bool
>
;
tLevel
level
;
std
:
:
set
<
ImmutableString
>
mInvariantVaryings
;
bool
mGlobalInvariant
;
}
;
bool
TSymbolTable
:
:
TSymbolTableLevel
:
:
insert
(
TSymbol
*
symbol
)
{
tInsertResult
result
=
level
.
insert
(
tLevelPair
(
symbol
-
>
getMangledName
(
)
symbol
)
)
;
return
result
.
second
;
}
void
TSymbolTable
:
:
TSymbolTableLevel
:
:
insertUnmangled
(
TFunction
*
function
)
{
level
.
insert
(
tLevelPair
(
function
-
>
name
(
)
function
)
)
;
}
TSymbol
*
TSymbolTable
:
:
TSymbolTableLevel
:
:
find
(
const
ImmutableString
&
name
)
const
{
tLevel
:
:
const_iterator
it
=
level
.
find
(
name
)
;
if
(
it
=
=
level
.
end
(
)
)
return
nullptr
;
else
return
(
*
it
)
.
second
;
}
TSymbolTable
:
:
TSymbolTable
(
)
:
mUniqueIdCounter
(
0
)
mShaderType
(
GL_FRAGMENT_SHADER
)
mGlInVariableWithArraySize
(
nullptr
)
{
}
TSymbolTable
:
:
~
TSymbolTable
(
)
=
default
;
bool
TSymbolTable
:
:
isEmpty
(
)
const
{
return
mTable
.
empty
(
)
;
}
bool
TSymbolTable
:
:
atGlobalLevel
(
)
const
{
return
mTable
.
size
(
)
=
=
1u
;
}
void
TSymbolTable
:
:
push
(
)
{
mTable
.
push_back
(
std
:
:
unique_ptr
<
TSymbolTableLevel
>
(
new
TSymbolTableLevel
)
)
;
mPrecisionStack
.
push_back
(
std
:
:
unique_ptr
<
PrecisionStackLevel
>
(
new
PrecisionStackLevel
)
)
;
}
void
TSymbolTable
:
:
pop
(
)
{
mTable
.
pop_back
(
)
;
mPrecisionStack
.
pop_back
(
)
;
}
const
TFunction
*
TSymbolTable
:
:
markFunctionHasPrototypeDeclaration
(
const
ImmutableString
&
mangledName
bool
*
hadPrototypeDeclarationOut
)
{
TFunction
*
function
=
findUserDefinedFunction
(
mangledName
)
;
*
hadPrototypeDeclarationOut
=
function
-
>
hasPrototypeDeclaration
(
)
;
function
-
>
setHasPrototypeDeclaration
(
)
;
return
function
;
}
const
TFunction
*
TSymbolTable
:
:
setFunctionParameterNamesFromDefinition
(
const
TFunction
*
function
bool
*
wasDefinedOut
)
{
TFunction
*
firstDeclaration
=
findUserDefinedFunction
(
function
-
>
getMangledName
(
)
)
;
ASSERT
(
firstDeclaration
)
;
if
(
function
!
=
firstDeclaration
)
{
firstDeclaration
-
>
shareParameters
(
*
function
)
;
}
*
wasDefinedOut
=
firstDeclaration
-
>
isDefined
(
)
;
firstDeclaration
-
>
setDefined
(
)
;
return
firstDeclaration
;
}
bool
TSymbolTable
:
:
setGlInArraySize
(
unsigned
int
inputArraySize
)
{
if
(
mGlInVariableWithArraySize
)
{
return
mGlInVariableWithArraySize
-
>
getType
(
)
.
getOutermostArraySize
(
)
=
=
inputArraySize
;
}
const
TInterfaceBlock
*
glPerVertex
=
mVar_gl_PerVertex
;
TType
*
glInType
=
new
TType
(
glPerVertex
EvqPerVertexIn
TLayoutQualifier
:
:
Create
(
)
)
;
glInType
-
>
makeArray
(
inputArraySize
)
;
mGlInVariableWithArraySize
=
new
TVariable
(
this
ImmutableString
(
"
gl_in
"
)
glInType
SymbolType
:
:
BuiltIn
TExtension
:
:
EXT_geometry_shader
)
;
return
true
;
}
TVariable
*
TSymbolTable
:
:
getGlInVariableWithArraySize
(
)
const
{
return
mGlInVariableWithArraySize
;
}
const
TVariable
*
TSymbolTable
:
:
gl_FragData
(
)
const
{
return
mVar_gl_FragData
;
}
const
TVariable
*
TSymbolTable
:
:
gl_SecondaryFragDataEXT
(
)
const
{
return
mVar_gl_SecondaryFragDataEXT
;
}
void
TSymbolTable
:
:
markStaticWrite
(
const
TVariable
&
variable
)
{
int
id
=
variable
.
uniqueId
(
)
.
get
(
)
;
auto
iter
=
mVariableMetadata
.
find
(
id
)
;
if
(
iter
=
=
mVariableMetadata
.
end
(
)
)
{
iter
=
mVariableMetadata
.
insert
(
std
:
:
make_pair
(
id
VariableMetadata
(
)
)
)
.
first
;
}
iter
-
>
second
.
staticWrite
=
true
;
}
void
TSymbolTable
:
:
markStaticRead
(
const
TVariable
&
variable
)
{
int
id
=
variable
.
uniqueId
(
)
.
get
(
)
;
auto
iter
=
mVariableMetadata
.
find
(
id
)
;
if
(
iter
=
=
mVariableMetadata
.
end
(
)
)
{
iter
=
mVariableMetadata
.
insert
(
std
:
:
make_pair
(
id
VariableMetadata
(
)
)
)
.
first
;
}
iter
-
>
second
.
staticRead
=
true
;
}
bool
TSymbolTable
:
:
isStaticallyUsed
(
const
TVariable
&
variable
)
const
{
ASSERT
(
!
variable
.
getConstPointer
(
)
)
;
int
id
=
variable
.
uniqueId
(
)
.
get
(
)
;
auto
iter
=
mVariableMetadata
.
find
(
id
)
;
return
iter
!
=
mVariableMetadata
.
end
(
)
;
}
const
TSymbol
*
TSymbolTable
:
:
find
(
const
ImmutableString
&
name
int
shaderVersion
)
const
{
int
userDefinedLevel
=
static_cast
<
int
>
(
mTable
.
size
(
)
)
-
1
;
while
(
userDefinedLevel
>
=
0
)
{
const
TSymbol
*
symbol
=
mTable
[
userDefinedLevel
]
-
>
find
(
name
)
;
if
(
symbol
)
{
return
symbol
;
}
userDefinedLevel
-
-
;
}
return
findBuiltIn
(
name
shaderVersion
)
;
}
TFunction
*
TSymbolTable
:
:
findUserDefinedFunction
(
const
ImmutableString
&
name
)
const
{
ASSERT
(
!
mTable
.
empty
(
)
)
;
return
static_cast
<
TFunction
*
>
(
mTable
[
0
]
-
>
find
(
name
)
)
;
}
const
TSymbol
*
TSymbolTable
:
:
findGlobal
(
const
ImmutableString
&
name
)
const
{
ASSERT
(
!
mTable
.
empty
(
)
)
;
return
mTable
[
0
]
-
>
find
(
name
)
;
}
bool
TSymbolTable
:
:
declare
(
TSymbol
*
symbol
)
{
ASSERT
(
!
mTable
.
empty
(
)
)
;
ASSERT
(
symbol
-
>
symbolType
(
)
=
=
SymbolType
:
:
UserDefined
)
;
ASSERT
(
!
symbol
-
>
isFunction
(
)
)
;
return
mTable
.
back
(
)
-
>
insert
(
symbol
)
;
}
void
TSymbolTable
:
:
declareUserDefinedFunction
(
TFunction
*
function
bool
insertUnmangledName
)
{
ASSERT
(
!
mTable
.
empty
(
)
)
;
if
(
insertUnmangledName
)
{
mTable
[
0
]
-
>
insertUnmangled
(
function
)
;
}
mTable
[
0
]
-
>
insert
(
function
)
;
}
void
TSymbolTable
:
:
setDefaultPrecision
(
TBasicType
type
TPrecision
prec
)
{
int
indexOfLastElement
=
static_cast
<
int
>
(
mPrecisionStack
.
size
(
)
)
-
1
;
(
*
mPrecisionStack
[
indexOfLastElement
]
)
[
type
]
=
prec
;
}
TPrecision
TSymbolTable
:
:
getDefaultPrecision
(
TBasicType
type
)
const
{
if
(
!
SupportsPrecision
(
type
)
)
return
EbpUndefined
;
TBasicType
baseType
=
(
type
=
=
EbtUInt
)
?
EbtInt
:
type
;
int
level
=
static_cast
<
int
>
(
mPrecisionStack
.
size
(
)
)
-
1
;
ASSERT
(
level
>
=
0
)
;
TPrecision
prec
=
EbpUndefined
;
while
(
level
>
=
0
)
{
PrecisionStackLevel
:
:
iterator
it
=
mPrecisionStack
[
level
]
-
>
find
(
baseType
)
;
if
(
it
!
=
mPrecisionStack
[
level
]
-
>
end
(
)
)
{
prec
=
(
*
it
)
.
second
;
break
;
}
level
-
-
;
}
return
prec
;
}
void
TSymbolTable
:
:
addInvariantVarying
(
const
ImmutableString
&
originalName
)
{
ASSERT
(
atGlobalLevel
(
)
)
;
mTable
.
back
(
)
-
>
addInvariantVarying
(
originalName
)
;
}
bool
TSymbolTable
:
:
isVaryingInvariant
(
const
ImmutableString
&
originalName
)
const
{
ASSERT
(
atGlobalLevel
(
)
)
;
return
mTable
.
back
(
)
-
>
isVaryingInvariant
(
originalName
)
;
}
void
TSymbolTable
:
:
setGlobalInvariant
(
bool
invariant
)
{
ASSERT
(
atGlobalLevel
(
)
)
;
mTable
.
back
(
)
-
>
setGlobalInvariant
(
invariant
)
;
}
void
TSymbolTable
:
:
clearCompilationResults
(
)
{
mUniqueIdCounter
=
kLastBuiltInId
+
1
;
mVariableMetadata
.
clear
(
)
;
mGlInVariableWithArraySize
=
nullptr
;
ASSERT
(
mTable
.
size
(
)
=
=
0u
)
;
}
int
TSymbolTable
:
:
nextUniqueIdValue
(
)
{
ASSERT
(
mUniqueIdCounter
<
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
)
;
return
+
+
mUniqueIdCounter
;
}
void
TSymbolTable
:
:
initializeBuiltIns
(
sh
:
:
GLenum
type
ShShaderSpec
spec
const
ShBuiltInResources
&
resources
)
{
mShaderType
=
type
;
mResources
=
resources
;
mPrecisionStack
.
push_back
(
std
:
:
unique_ptr
<
PrecisionStackLevel
>
(
new
PrecisionStackLevel
)
)
;
switch
(
type
)
{
case
GL_FRAGMENT_SHADER
:
setDefaultPrecision
(
EbtInt
EbpMedium
)
;
break
;
case
GL_VERTEX_SHADER
:
case
GL_COMPUTE_SHADER
:
case
GL_GEOMETRY_SHADER_EXT
:
setDefaultPrecision
(
EbtInt
EbpHigh
)
;
setDefaultPrecision
(
EbtFloat
EbpHigh
)
;
break
;
default
:
UNREACHABLE
(
)
;
}
initSamplerDefaultPrecision
(
EbtSampler2D
)
;
initSamplerDefaultPrecision
(
EbtSamplerCube
)
;
initSamplerDefaultPrecision
(
EbtSamplerExternalOES
)
;
initSamplerDefaultPrecision
(
EbtSamplerExternal2DY2YEXT
)
;
initSamplerDefaultPrecision
(
EbtSampler2DRect
)
;
setDefaultPrecision
(
EbtAtomicCounter
EbpHigh
)
;
initializeBuiltInVariables
(
type
spec
resources
)
;
mUniqueIdCounter
=
kLastBuiltInId
+
1
;
}
void
TSymbolTable
:
:
initSamplerDefaultPrecision
(
TBasicType
samplerType
)
{
ASSERT
(
samplerType
>
=
EbtGuardSamplerBegin
&
&
samplerType
<
=
EbtGuardSamplerEnd
)
;
setDefaultPrecision
(
samplerType
EbpLow
)
;
}
TSymbolTable
:
:
VariableMetadata
:
:
VariableMetadata
(
)
:
staticRead
(
false
)
staticWrite
(
false
)
{
}
}
