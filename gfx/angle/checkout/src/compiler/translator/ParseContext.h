#
ifndef
COMPILER_TRANSLATOR_PARSECONTEXT_H_
#
define
COMPILER_TRANSLATOR_PARSECONTEXT_H_
#
include
"
compiler
/
preprocessor
/
Preprocessor
.
h
"
#
include
"
compiler
/
translator
/
Compiler
.
h
"
#
include
"
compiler
/
translator
/
Declarator
.
h
"
#
include
"
compiler
/
translator
/
Diagnostics
.
h
"
#
include
"
compiler
/
translator
/
DirectiveHandler
.
h
"
#
include
"
compiler
/
translator
/
FunctionLookup
.
h
"
#
include
"
compiler
/
translator
/
QualifierTypes
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
namespace
sh
{
struct
TMatrixFields
{
bool
wholeRow
;
bool
wholeCol
;
int
row
;
int
col
;
}
;
class
TParseContext
:
angle
:
:
NonCopyable
{
public
:
TParseContext
(
TSymbolTable
&
symt
TExtensionBehavior
&
ext
sh
:
:
GLenum
type
ShShaderSpec
spec
ShCompileOptions
options
bool
checksPrecErrors
TDiagnostics
*
diagnostics
const
ShBuiltInResources
&
resources
ShShaderOutput
outputType
)
;
~
TParseContext
(
)
;
bool
anyMultiviewExtensionAvailable
(
)
;
const
angle
:
:
pp
:
:
Preprocessor
&
getPreprocessor
(
)
const
{
return
mPreprocessor
;
}
angle
:
:
pp
:
:
Preprocessor
&
getPreprocessor
(
)
{
return
mPreprocessor
;
}
void
*
getScanner
(
)
const
{
return
mScanner
;
}
void
setScanner
(
void
*
scanner
)
{
mScanner
=
scanner
;
}
int
getShaderVersion
(
)
const
{
return
mShaderVersion
;
}
sh
:
:
GLenum
getShaderType
(
)
const
{
return
mShaderType
;
}
ShShaderSpec
getShaderSpec
(
)
const
{
return
mShaderSpec
;
}
int
numErrors
(
)
const
{
return
mDiagnostics
-
>
numErrors
(
)
;
}
void
error
(
const
TSourceLoc
&
loc
const
char
*
reason
const
char
*
token
)
;
void
error
(
const
TSourceLoc
&
loc
const
char
*
reason
const
ImmutableString
&
token
)
;
void
warning
(
const
TSourceLoc
&
loc
const
char
*
reason
const
char
*
token
)
;
void
outOfRangeError
(
bool
isError
const
TSourceLoc
&
loc
const
char
*
reason
const
char
*
token
)
;
TIntermBlock
*
getTreeRoot
(
)
const
{
return
mTreeRoot
;
}
void
setTreeRoot
(
TIntermBlock
*
treeRoot
)
;
bool
getFragmentPrecisionHigh
(
)
const
{
return
mFragmentPrecisionHighOnESSL1
|
|
mShaderVersion
>
=
300
;
}
void
setFragmentPrecisionHighOnESSL1
(
bool
fragmentPrecisionHigh
)
{
mFragmentPrecisionHighOnESSL1
=
fragmentPrecisionHigh
;
}
bool
isEarlyFragmentTestsSpecified
(
)
const
{
return
mEarlyFragmentTestsSpecified
;
}
void
setLoopNestingLevel
(
int
loopNestintLevel
)
{
mLoopNestingLevel
=
loopNestintLevel
;
}
void
incrLoopNestingLevel
(
)
{
+
+
mLoopNestingLevel
;
}
void
decrLoopNestingLevel
(
)
{
-
-
mLoopNestingLevel
;
}
void
incrSwitchNestingLevel
(
)
{
+
+
mSwitchNestingLevel
;
}
void
decrSwitchNestingLevel
(
)
{
-
-
mSwitchNestingLevel
;
}
bool
isComputeShaderLocalSizeDeclared
(
)
const
{
return
mComputeShaderLocalSizeDeclared
;
}
sh
:
:
WorkGroupSize
getComputeShaderLocalSize
(
)
const
;
int
getNumViews
(
)
const
{
return
mNumViews
;
}
void
enterFunctionDeclaration
(
)
{
mDeclaringFunction
=
true
;
}
void
exitFunctionDeclaration
(
)
{
mDeclaringFunction
=
false
;
}
bool
declaringFunction
(
)
const
{
return
mDeclaringFunction
;
}
TIntermConstantUnion
*
addScalarLiteral
(
const
TConstantUnion
*
constantUnion
const
TSourceLoc
&
line
)
;
const
TVariable
*
getNamedVariable
(
const
TSourceLoc
&
location
const
ImmutableString
&
name
const
TSymbol
*
symbol
)
;
TIntermTyped
*
parseVariableIdentifier
(
const
TSourceLoc
&
location
const
ImmutableString
&
name
const
TSymbol
*
symbol
)
;
bool
parseVectorFields
(
const
TSourceLoc
&
line
const
ImmutableString
&
compString
int
vecSize
TVector
<
int
>
*
fieldOffsets
)
;
void
assignError
(
const
TSourceLoc
&
line
const
char
*
op
const
TType
&
left
const
TType
&
right
)
;
void
unaryOpError
(
const
TSourceLoc
&
line
const
char
*
op
const
TType
&
operand
)
;
void
binaryOpError
(
const
TSourceLoc
&
line
const
char
*
op
const
TType
&
left
const
TType
&
right
)
;
bool
checkIsNotReserved
(
const
TSourceLoc
&
line
const
ImmutableString
&
identifier
)
;
void
checkPrecisionSpecified
(
const
TSourceLoc
&
line
TPrecision
precision
TBasicType
type
)
;
bool
checkCanBeLValue
(
const
TSourceLoc
&
line
const
char
*
op
TIntermTyped
*
node
)
;
void
checkIsConst
(
TIntermTyped
*
node
)
;
void
checkIsScalarInteger
(
TIntermTyped
*
node
const
char
*
token
)
;
bool
checkIsAtGlobalLevel
(
const
TSourceLoc
&
line
const
char
*
token
)
;
bool
checkConstructorArguments
(
const
TSourceLoc
&
line
const
TIntermSequence
&
arguments
const
TType
&
type
)
;
unsigned
int
checkIsValidArraySize
(
const
TSourceLoc
&
line
TIntermTyped
*
expr
)
;
bool
checkIsValidQualifierForArray
(
const
TSourceLoc
&
line
const
TPublicType
&
elementQualifier
)
;
bool
checkArrayElementIsNotArray
(
const
TSourceLoc
&
line
const
TPublicType
&
elementType
)
;
bool
checkArrayOfArraysInOut
(
const
TSourceLoc
&
line
const
TPublicType
&
elementType
const
TType
&
arrayType
)
;
bool
checkIsNonVoid
(
const
TSourceLoc
&
line
const
ImmutableString
&
identifier
const
TBasicType
&
type
)
;
bool
checkIsScalarBool
(
const
TSourceLoc
&
line
const
TIntermTyped
*
type
)
;
void
checkIsScalarBool
(
const
TSourceLoc
&
line
const
TPublicType
&
pType
)
;
bool
checkIsNotOpaqueType
(
const
TSourceLoc
&
line
const
TTypeSpecifierNonArray
&
pType
const
char
*
reason
)
;
void
checkDeclaratorLocationIsNotSpecified
(
const
TSourceLoc
&
line
const
TPublicType
&
pType
)
;
void
checkLocationIsNotSpecified
(
const
TSourceLoc
&
location
const
TLayoutQualifier
&
layoutQualifier
)
;
void
checkStd430IsForShaderStorageBlock
(
const
TSourceLoc
&
location
const
TLayoutBlockStorage
&
blockStorage
const
TQualifier
&
qualifier
)
;
void
checkIsParameterQualifierValid
(
const
TSourceLoc
&
line
const
TTypeQualifierBuilder
&
typeQualifierBuilder
TType
*
type
)
;
template
<
size_t
size
>
bool
checkCanUseOneOfExtensions
(
const
TSourceLoc
&
line
const
std
:
:
array
<
TExtension
size
>
&
extensions
)
;
bool
checkCanUseExtension
(
const
TSourceLoc
&
line
TExtension
extension
)
;
void
declarationQualifierErrorCheck
(
const
sh
:
:
TQualifier
qualifier
const
sh
:
:
TLayoutQualifier
&
layoutQualifier
const
TSourceLoc
&
location
)
;
void
nonEmptyDeclarationErrorCheck
(
const
TPublicType
&
publicType
const
TSourceLoc
&
identifierLocation
)
;
void
emptyDeclarationErrorCheck
(
const
TType
&
type
const
TSourceLoc
&
location
)
;
void
checkCanUseLayoutQualifier
(
const
TSourceLoc
&
location
)
;
bool
checkLayoutQualifierSupported
(
const
TSourceLoc
&
location
const
ImmutableString
&
layoutQualifierName
int
versionRequired
)
;
bool
checkWorkGroupSizeIsNotSpecified
(
const
TSourceLoc
&
location
const
TLayoutQualifier
&
layoutQualifier
)
;
void
functionCallRValueLValueErrorCheck
(
const
TFunction
*
fnCandidate
TIntermAggregate
*
fnCall
)
;
void
checkInvariantVariableQualifier
(
bool
invariant
const
TQualifier
qualifier
const
TSourceLoc
&
invariantLocation
)
;
void
checkInputOutputTypeIsValidES3
(
const
TQualifier
qualifier
const
TPublicType
&
type
const
TSourceLoc
&
qualifierLocation
)
;
void
checkLocalVariableConstStorageQualifier
(
const
TQualifierWrapperBase
&
qualifier
)
;
void
checkTCSOutVarIndexIsValid
(
TIntermBinary
*
binaryExpression
const
TSourceLoc
&
location
)
;
const
TPragma
&
pragma
(
)
const
{
return
mDirectiveHandler
.
pragma
(
)
;
}
const
TExtensionBehavior
&
extensionBehavior
(
)
const
{
return
mDirectiveHandler
.
extensionBehavior
(
)
;
}
bool
isExtensionEnabled
(
TExtension
extension
)
const
;
void
handleExtensionDirective
(
const
TSourceLoc
&
loc
const
char
*
extName
const
char
*
behavior
)
;
void
handlePragmaDirective
(
const
TSourceLoc
&
loc
const
char
*
name
const
char
*
value
bool
stdgl
)
;
bool
executeInitializer
(
const
TSourceLoc
&
line
const
ImmutableString
&
identifier
TType
*
type
TIntermTyped
*
initializer
TIntermBinary
*
*
initNode
)
;
TIntermNode
*
addConditionInitializer
(
const
TPublicType
&
pType
const
ImmutableString
&
identifier
TIntermTyped
*
initializer
const
TSourceLoc
&
loc
)
;
TIntermNode
*
addLoop
(
TLoopType
type
TIntermNode
*
init
TIntermNode
*
cond
TIntermTyped
*
expr
TIntermNode
*
body
const
TSourceLoc
&
loc
)
;
TIntermNode
*
addIfElse
(
TIntermTyped
*
cond
TIntermNodePair
code
const
TSourceLoc
&
loc
)
;
void
addFullySpecifiedType
(
TPublicType
*
typeSpecifier
)
;
TPublicType
addFullySpecifiedType
(
const
TTypeQualifierBuilder
&
typeQualifierBuilder
const
TPublicType
&
typeSpecifier
)
;
TIntermDeclaration
*
parseSingleDeclaration
(
TPublicType
&
publicType
const
TSourceLoc
&
identifierOrTypeLocation
const
ImmutableString
&
identifier
)
;
TIntermDeclaration
*
parseSingleArrayDeclaration
(
TPublicType
&
elementType
const
TSourceLoc
&
identifierLocation
const
ImmutableString
&
identifier
const
TSourceLoc
&
indexLocation
const
TVector
<
unsigned
int
>
&
arraySizes
)
;
TIntermDeclaration
*
parseSingleInitDeclaration
(
const
TPublicType
&
publicType
const
TSourceLoc
&
identifierLocation
const
ImmutableString
&
identifier
const
TSourceLoc
&
initLocation
TIntermTyped
*
initializer
)
;
TIntermDeclaration
*
parseSingleArrayInitDeclaration
(
TPublicType
&
elementType
const
TSourceLoc
&
identifierLocation
const
ImmutableString
&
identifier
const
TSourceLoc
&
indexLocation
const
TVector
<
unsigned
int
>
&
arraySizes
const
TSourceLoc
&
initLocation
TIntermTyped
*
initializer
)
;
TIntermGlobalQualifierDeclaration
*
parseGlobalQualifierDeclaration
(
const
TTypeQualifierBuilder
&
typeQualifierBuilder
const
TSourceLoc
&
identifierLoc
const
ImmutableString
&
identifier
const
TSymbol
*
symbol
)
;
void
parseDeclarator
(
TPublicType
&
publicType
const
TSourceLoc
&
identifierLocation
const
ImmutableString
&
identifier
TIntermDeclaration
*
declarationOut
)
;
void
parseArrayDeclarator
(
TPublicType
&
elementType
const
TSourceLoc
&
identifierLocation
const
ImmutableString
&
identifier
const
TSourceLoc
&
arrayLocation
const
TVector
<
unsigned
int
>
&
arraySizes
TIntermDeclaration
*
declarationOut
)
;
void
parseInitDeclarator
(
const
TPublicType
&
publicType
const
TSourceLoc
&
identifierLocation
const
ImmutableString
&
identifier
const
TSourceLoc
&
initLocation
TIntermTyped
*
initializer
TIntermDeclaration
*
declarationOut
)
;
void
parseArrayInitDeclarator
(
const
TPublicType
&
elementType
const
TSourceLoc
&
identifierLocation
const
ImmutableString
&
identifier
const
TSourceLoc
&
indexLocation
const
TVector
<
unsigned
int
>
&
arraySizes
const
TSourceLoc
&
initLocation
TIntermTyped
*
initializer
TIntermDeclaration
*
declarationOut
)
;
TIntermNode
*
addEmptyStatement
(
const
TSourceLoc
&
location
)
;
void
parseDefaultPrecisionQualifier
(
const
TPrecision
precision
const
TPublicType
&
type
const
TSourceLoc
&
loc
)
;
void
parseGlobalLayoutQualifier
(
const
TTypeQualifierBuilder
&
typeQualifierBuilder
)
;
TIntermFunctionPrototype
*
addFunctionPrototypeDeclaration
(
const
TFunction
&
parsedFunction
const
TSourceLoc
&
location
)
;
TIntermFunctionDefinition
*
addFunctionDefinition
(
TIntermFunctionPrototype
*
functionPrototype
TIntermBlock
*
functionBody
const
TSourceLoc
&
location
)
;
void
parseFunctionDefinitionHeader
(
const
TSourceLoc
&
location
const
TFunction
*
function
TIntermFunctionPrototype
*
*
prototypeOut
)
;
TFunction
*
parseFunctionDeclarator
(
const
TSourceLoc
&
location
TFunction
*
function
)
;
TFunction
*
parseFunctionHeader
(
const
TPublicType
&
type
const
ImmutableString
&
name
const
TSourceLoc
&
location
)
;
TFunctionLookup
*
addNonConstructorFunc
(
const
ImmutableString
&
name
const
TSymbol
*
symbol
)
;
TFunctionLookup
*
addConstructorFunc
(
const
TPublicType
&
publicType
)
;
TParameter
parseParameterDeclarator
(
const
TPublicType
&
publicType
const
ImmutableString
&
name
const
TSourceLoc
&
nameLoc
)
;
TParameter
parseParameterArrayDeclarator
(
const
ImmutableString
&
name
const
TSourceLoc
&
nameLoc
const
TVector
<
unsigned
int
>
&
arraySizes
const
TSourceLoc
&
arrayLoc
TPublicType
*
elementType
)
;
TIntermTyped
*
addIndexExpression
(
TIntermTyped
*
baseExpression
const
TSourceLoc
&
location
TIntermTyped
*
indexExpression
)
;
TIntermTyped
*
addFieldSelectionExpression
(
TIntermTyped
*
baseExpression
const
TSourceLoc
&
dotLocation
const
ImmutableString
&
fieldString
const
TSourceLoc
&
fieldLocation
)
;
TDeclarator
*
parseStructDeclarator
(
const
ImmutableString
&
identifier
const
TSourceLoc
&
loc
)
;
TDeclarator
*
parseStructArrayDeclarator
(
const
ImmutableString
&
identifier
const
TSourceLoc
&
loc
const
TVector
<
unsigned
int
>
*
arraySizes
)
;
void
checkDoesNotHaveDuplicateFieldName
(
const
TFieldList
:
:
const_iterator
begin
const
TFieldList
:
:
const_iterator
end
const
ImmutableString
&
name
const
TSourceLoc
&
location
)
;
TFieldList
*
addStructFieldList
(
TFieldList
*
fields
const
TSourceLoc
&
location
)
;
TFieldList
*
combineStructFieldLists
(
TFieldList
*
processedFields
const
TFieldList
*
newlyAddedFields
const
TSourceLoc
&
location
)
;
TFieldList
*
addStructDeclaratorListWithQualifiers
(
const
TTypeQualifierBuilder
&
typeQualifierBuilder
TPublicType
*
typeSpecifier
const
TDeclaratorList
*
declaratorList
)
;
TFieldList
*
addStructDeclaratorList
(
const
TPublicType
&
typeSpecifier
const
TDeclaratorList
*
declaratorList
)
;
TTypeSpecifierNonArray
addStructure
(
const
TSourceLoc
&
structLine
const
TSourceLoc
&
nameLine
const
ImmutableString
&
structName
TFieldList
*
fieldList
)
;
TIntermDeclaration
*
addInterfaceBlock
(
const
TTypeQualifierBuilder
&
typeQualifierBuilder
const
TSourceLoc
&
nameLine
const
ImmutableString
&
blockName
TFieldList
*
fieldList
const
ImmutableString
&
instanceName
const
TSourceLoc
&
instanceLine
const
TVector
<
unsigned
int
>
*
arraySizes
const
TSourceLoc
&
arraySizesLine
)
;
void
parseLocalSize
(
const
ImmutableString
&
qualifierType
const
TSourceLoc
&
qualifierTypeLine
int
intValue
const
TSourceLoc
&
intValueLine
const
std
:
:
string
&
intValueString
size_t
index
sh
:
:
WorkGroupSize
*
localSize
)
;
void
parseNumViews
(
int
intValue
const
TSourceLoc
&
intValueLine
const
std
:
:
string
&
intValueString
int
*
numViews
)
;
void
parseInvocations
(
int
intValue
const
TSourceLoc
&
intValueLine
const
std
:
:
string
&
intValueString
int
*
numInvocations
)
;
void
parseMaxVertices
(
int
intValue
const
TSourceLoc
&
intValueLine
const
std
:
:
string
&
intValueString
int
*
numMaxVertices
)
;
void
parseVertices
(
int
intValue
const
TSourceLoc
&
intValueLine
const
std
:
:
string
&
intValueString
int
*
numVertices
)
;
void
parseIndexLayoutQualifier
(
int
intValue
const
TSourceLoc
&
intValueLine
const
std
:
:
string
&
intValueString
int
*
index
)
;
TLayoutQualifier
parseLayoutQualifier
(
const
ImmutableString
&
qualifierType
const
TSourceLoc
&
qualifierTypeLine
)
;
TLayoutQualifier
parseLayoutQualifier
(
const
ImmutableString
&
qualifierType
const
TSourceLoc
&
qualifierTypeLine
int
intValue
const
TSourceLoc
&
intValueLine
)
;
TTypeQualifierBuilder
*
createTypeQualifierBuilder
(
const
TSourceLoc
&
loc
)
;
TStorageQualifierWrapper
*
parseGlobalStorageQualifier
(
TQualifier
qualifier
const
TSourceLoc
&
loc
)
;
TStorageQualifierWrapper
*
parseVaryingQualifier
(
const
TSourceLoc
&
loc
)
;
TStorageQualifierWrapper
*
parseInQualifier
(
const
TSourceLoc
&
loc
)
;
TStorageQualifierWrapper
*
parseOutQualifier
(
const
TSourceLoc
&
loc
)
;
TStorageQualifierWrapper
*
parseInOutQualifier
(
const
TSourceLoc
&
loc
)
;
TLayoutQualifier
joinLayoutQualifiers
(
TLayoutQualifier
leftQualifier
TLayoutQualifier
rightQualifier
const
TSourceLoc
&
rightQualifierLocation
)
;
void
enterStructDeclaration
(
const
TSourceLoc
&
line
const
ImmutableString
&
identifier
)
;
void
exitStructDeclaration
(
)
;
void
checkIsBelowStructNestingLimit
(
const
TSourceLoc
&
line
const
TField
&
field
)
;
TIntermSwitch
*
addSwitch
(
TIntermTyped
*
init
TIntermBlock
*
statementList
const
TSourceLoc
&
loc
)
;
TIntermCase
*
addCase
(
TIntermTyped
*
condition
const
TSourceLoc
&
loc
)
;
TIntermCase
*
addDefault
(
const
TSourceLoc
&
loc
)
;
TIntermTyped
*
addUnaryMath
(
TOperator
op
TIntermTyped
*
child
const
TSourceLoc
&
loc
)
;
TIntermTyped
*
addUnaryMathLValue
(
TOperator
op
TIntermTyped
*
child
const
TSourceLoc
&
loc
)
;
TIntermTyped
*
addBinaryMath
(
TOperator
op
TIntermTyped
*
left
TIntermTyped
*
right
const
TSourceLoc
&
loc
)
;
TIntermTyped
*
addBinaryMathBooleanResult
(
TOperator
op
TIntermTyped
*
left
TIntermTyped
*
right
const
TSourceLoc
&
loc
)
;
TIntermTyped
*
addAssign
(
TOperator
op
TIntermTyped
*
left
TIntermTyped
*
right
const
TSourceLoc
&
loc
)
;
TIntermTyped
*
addComma
(
TIntermTyped
*
left
TIntermTyped
*
right
const
TSourceLoc
&
loc
)
;
TIntermBranch
*
addBranch
(
TOperator
op
const
TSourceLoc
&
loc
)
;
TIntermBranch
*
addBranch
(
TOperator
op
TIntermTyped
*
expression
const
TSourceLoc
&
loc
)
;
void
appendStatement
(
TIntermBlock
*
block
TIntermNode
*
statement
)
;
void
checkTextureGather
(
TIntermAggregate
*
functionCall
)
;
void
checkTextureOffset
(
TIntermAggregate
*
functionCall
)
;
void
checkImageMemoryAccessForBuiltinFunctions
(
TIntermAggregate
*
functionCall
)
;
void
checkImageMemoryAccessForUserDefinedFunctions
(
const
TFunction
*
functionDefinition
const
TIntermAggregate
*
functionCall
)
;
void
checkAtomicMemoryBuiltinFunctions
(
TIntermAggregate
*
functionCall
)
;
void
checkInterpolationFS
(
TIntermAggregate
*
functionCall
)
;
TIntermTyped
*
addFunctionCallOrMethod
(
TFunctionLookup
*
fnCall
const
TSourceLoc
&
loc
)
;
TIntermTyped
*
addTernarySelection
(
TIntermTyped
*
cond
TIntermTyped
*
trueExpression
TIntermTyped
*
falseExpression
const
TSourceLoc
&
line
)
;
int
getGeometryShaderMaxVertices
(
)
const
{
return
mGeometryShaderMaxVertices
;
}
int
getGeometryShaderInvocations
(
)
const
{
return
(
mGeometryShaderInvocations
>
0
)
?
mGeometryShaderInvocations
:
1
;
}
TLayoutPrimitiveType
getGeometryShaderInputPrimitiveType
(
)
const
{
return
mGeometryShaderInputPrimitiveType
;
}
TLayoutPrimitiveType
getGeometryShaderOutputPrimitiveType
(
)
const
{
return
mGeometryShaderOutputPrimitiveType
;
}
int
getTessControlShaderOutputVertices
(
)
const
{
return
mTessControlShaderOutputVertices
;
}
TLayoutTessEvaluationType
getTessEvaluationShaderInputPrimitiveType
(
)
const
{
return
mTessEvaluationShaderInputPrimitiveType
;
}
TLayoutTessEvaluationType
getTessEvaluationShaderInputVertexSpacingType
(
)
const
{
return
mTessEvaluationShaderInputVertexSpacingType
;
}
TLayoutTessEvaluationType
getTessEvaluationShaderInputOrderingType
(
)
const
{
return
mTessEvaluationShaderInputOrderingType
;
}
TLayoutTessEvaluationType
getTessEvaluationShaderInputPointType
(
)
const
{
return
mTessEvaluationShaderInputPointType
;
}
ShShaderOutput
getOutputType
(
)
const
{
return
mOutputType
;
}
TSymbolTable
&
symbolTable
;
private
:
class
AtomicCounterBindingState
;
constexpr
static
size_t
kAtomicCounterSize
=
4
;
constexpr
static
size_t
kAtomicCounterArrayStride
=
4
;
void
markStaticReadIfSymbol
(
TIntermNode
*
node
)
;
int
checkIndexLessThan
(
bool
outOfRangeIndexIsError
const
TSourceLoc
&
location
int
index
int
arraySize
const
char
*
reason
)
;
bool
declareVariable
(
const
TSourceLoc
&
line
const
ImmutableString
&
identifier
const
TType
*
type
TVariable
*
*
variable
)
;
void
checkCanBeDeclaredWithoutInitializer
(
const
TSourceLoc
&
line
const
ImmutableString
&
identifier
TType
*
type
)
;
TParameter
parseParameterDeclarator
(
TType
*
type
const
ImmutableString
&
name
const
TSourceLoc
&
nameLoc
)
;
bool
checkIsValidTypeAndQualifierForArray
(
const
TSourceLoc
&
indexLocation
const
TPublicType
&
elementType
)
;
void
atomicCounterQualifierErrorCheck
(
const
TPublicType
&
publicType
const
TSourceLoc
&
location
)
;
bool
isMultiplicationTypeCombinationValid
(
TOperator
op
const
TType
&
left
const
TType
&
right
)
;
void
checkOutParameterIsNotOpaqueType
(
const
TSourceLoc
&
line
TQualifier
qualifier
const
TType
&
type
)
;
void
checkInternalFormatIsNotSpecified
(
const
TSourceLoc
&
location
TLayoutImageInternalFormat
internalFormat
)
;
void
checkMemoryQualifierIsNotSpecified
(
const
TMemoryQualifier
&
memoryQualifier
const
TSourceLoc
&
location
)
;
void
checkAtomicCounterOffsetDoesNotOverlap
(
bool
forceAppend
const
TSourceLoc
&
loc
TType
*
type
)
;
void
checkAtomicCounterOffsetAlignment
(
const
TSourceLoc
&
location
const
TType
&
type
)
;
void
checkIndexIsNotSpecified
(
const
TSourceLoc
&
location
int
index
)
;
void
checkBindingIsValid
(
const
TSourceLoc
&
identifierLocation
const
TType
&
type
)
;
void
checkBindingIsNotSpecified
(
const
TSourceLoc
&
location
int
binding
)
;
void
checkOffsetIsNotSpecified
(
const
TSourceLoc
&
location
int
offset
)
;
void
checkImageBindingIsValid
(
const
TSourceLoc
&
location
int
binding
int
arrayTotalElementCount
)
;
void
checkSamplerBindingIsValid
(
const
TSourceLoc
&
location
int
binding
int
arrayTotalElementCount
)
;
void
checkBlockBindingIsValid
(
const
TSourceLoc
&
location
const
TQualifier
&
qualifier
int
binding
int
arraySize
)
;
void
checkAtomicCounterBindingIsValid
(
const
TSourceLoc
&
location
int
binding
)
;
void
checkUniformLocationInRange
(
const
TSourceLoc
&
location
int
objectLocationCount
const
TLayoutQualifier
&
layoutQualifier
)
;
void
checkAttributeLocationInRange
(
const
TSourceLoc
&
location
int
objectLocationCount
const
TLayoutQualifier
&
layoutQualifier
)
;
void
checkYuvIsNotSpecified
(
const
TSourceLoc
&
location
bool
yuv
)
;
void
checkEarlyFragmentTestsIsNotSpecified
(
const
TSourceLoc
&
location
bool
earlyFragmentTests
)
;
void
checkNoncoherentIsSpecified
(
const
TSourceLoc
&
location
bool
noncoherent
)
;
void
checkNoncoherentIsNotSpecified
(
const
TSourceLoc
&
location
bool
noncoherent
)
;
bool
checkUnsizedArrayConstructorArgumentDimensionality
(
const
TIntermSequence
&
arguments
TType
type
const
TSourceLoc
&
line
)
;
void
checkCombinedClipCullDistanceIsValid
(
const
TSourceLoc
&
line
const
ImmutableString
&
identifier
const
int
arraySize
)
;
void
checkSingleTextureOffset
(
const
TSourceLoc
&
line
const
TConstantUnion
*
values
size_t
size
int
minOffsetValue
int
maxOffsetValue
)
;
void
checkGeometryShaderInputAndSetArraySize
(
const
TSourceLoc
&
location
const
ImmutableString
&
token
TType
*
type
)
;
void
checkTessellationShaderUnsizedArraysAndSetSize
(
const
TSourceLoc
&
location
const
ImmutableString
&
token
TType
*
type
)
;
void
checkIsNotUnsizedArray
(
const
TSourceLoc
&
line
const
char
*
errorMessage
const
ImmutableString
&
token
TType
*
arrayType
)
;
TIntermTyped
*
addBinaryMathInternal
(
TOperator
op
TIntermTyped
*
left
TIntermTyped
*
right
const
TSourceLoc
&
loc
)
;
TIntermTyped
*
createUnaryMath
(
TOperator
op
TIntermTyped
*
child
const
TSourceLoc
&
loc
const
TFunction
*
func
)
;
TIntermTyped
*
addMethod
(
TFunctionLookup
*
fnCall
const
TSourceLoc
&
loc
)
;
TIntermTyped
*
addConstructor
(
TFunctionLookup
*
fnCall
const
TSourceLoc
&
line
)
;
TIntermTyped
*
addNonConstructorFunctionCall
(
TFunctionLookup
*
fnCall
const
TSourceLoc
&
loc
)
;
TIntermTyped
*
expressionOrFoldedResult
(
TIntermTyped
*
expression
)
;
bool
binaryOpCommonCheck
(
TOperator
op
TIntermTyped
*
left
TIntermTyped
*
right
const
TSourceLoc
&
loc
)
;
TIntermFunctionPrototype
*
createPrototypeNodeFromFunction
(
const
TFunction
&
function
const
TSourceLoc
&
location
bool
insertParametersToSymbolTable
)
;
void
setAtomicCounterBindingDefaultOffset
(
const
TPublicType
&
declaration
const
TSourceLoc
&
location
)
;
bool
checkPrimitiveTypeMatchesTypeQualifier
(
const
TTypeQualifier
&
typeQualifier
)
;
bool
parseGeometryShaderInputLayoutQualifier
(
const
TTypeQualifier
&
typeQualifier
)
;
bool
parseGeometryShaderOutputLayoutQualifier
(
const
TTypeQualifier
&
typeQualifier
)
;
void
setGeometryShaderInputArraySize
(
unsigned
int
inputArraySize
const
TSourceLoc
&
line
)
;
bool
parseTessControlShaderOutputLayoutQualifier
(
const
TTypeQualifier
&
typeQualifier
)
;
bool
parseTessEvaluationShaderInputLayoutQualifier
(
const
TTypeQualifier
&
typeQualifier
)
;
bool
mDeferredNonEmptyDeclarationErrorCheck
;
sh
:
:
GLenum
mShaderType
;
ShShaderSpec
mShaderSpec
;
ShCompileOptions
mCompileOptions
;
int
mShaderVersion
;
TIntermBlock
*
mTreeRoot
;
int
mLoopNestingLevel
;
int
mStructNestingLevel
;
int
mSwitchNestingLevel
;
const
TType
*
mCurrentFunctionType
;
bool
mFunctionReturnsValue
;
bool
mChecksPrecisionErrors
;
bool
mFragmentPrecisionHighOnESSL1
;
bool
mEarlyFragmentTestsSpecified
;
TLayoutMatrixPacking
mDefaultUniformMatrixPacking
;
TLayoutBlockStorage
mDefaultUniformBlockStorage
;
TLayoutMatrixPacking
mDefaultBufferMatrixPacking
;
TLayoutBlockStorage
mDefaultBufferBlockStorage
;
TString
mHashErrMsg
;
TDiagnostics
*
mDiagnostics
;
TDirectiveHandler
mDirectiveHandler
;
angle
:
:
pp
:
:
Preprocessor
mPreprocessor
;
void
*
mScanner
;
int
mMinProgramTexelOffset
;
int
mMaxProgramTexelOffset
;
int
mMinProgramTextureGatherOffset
;
int
mMaxProgramTextureGatherOffset
;
bool
mComputeShaderLocalSizeDeclared
;
sh
:
:
WorkGroupSize
mComputeShaderLocalSize
;
int
mNumViews
;
int
mMaxNumViews
;
int
mMaxImageUnits
;
int
mMaxCombinedTextureImageUnits
;
int
mMaxUniformLocations
;
int
mMaxUniformBufferBindings
;
int
mMaxVertexAttribs
;
int
mMaxAtomicCounterBindings
;
int
mMaxShaderStorageBufferBindings
;
bool
mDeclaringFunction
;
std
:
:
map
<
int
AtomicCounterBindingState
>
mAtomicCounterBindingStates
;
TLayoutPrimitiveType
mGeometryShaderInputPrimitiveType
;
TLayoutPrimitiveType
mGeometryShaderOutputPrimitiveType
;
int
mGeometryShaderInvocations
;
int
mGeometryShaderMaxVertices
;
int
mMaxGeometryShaderInvocations
;
int
mMaxGeometryShaderMaxVertices
;
unsigned
int
mGeometryInputArraySize
;
int
mMaxPatchVertices
;
int
mTessControlShaderOutputVertices
;
TLayoutTessEvaluationType
mTessEvaluationShaderInputPrimitiveType
;
TLayoutTessEvaluationType
mTessEvaluationShaderInputVertexSpacingType
;
TLayoutTessEvaluationType
mTessEvaluationShaderInputOrderingType
;
TLayoutTessEvaluationType
mTessEvaluationShaderInputPointType
;
bool
mFunctionBodyNewScope
;
ShShaderOutput
mOutputType
;
}
;
int
PaParseStrings
(
size_t
count
const
char
*
const
string
[
]
const
int
length
[
]
TParseContext
*
context
)
;
}
#
endif
