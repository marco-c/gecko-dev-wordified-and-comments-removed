#
include
"
compiler
/
translator
/
ASTMetadataHLSL
.
h
"
#
include
"
compiler
/
translator
/
CallDAG
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
namespace
sh
{
namespace
{
class
PullGradient
:
public
TIntermTraverser
{
public
:
PullGradient
(
MetadataList
*
metadataList
size_t
index
const
CallDAG
&
dag
)
:
TIntermTraverser
(
true
false
true
)
mMetadataList
(
metadataList
)
mMetadata
(
&
(
*
metadataList
)
[
index
]
)
mIndex
(
index
)
mDag
(
dag
)
{
ASSERT
(
index
<
metadataList
-
>
size
(
)
)
;
mGradientBuiltinFunctions
.
insert
(
ImmutableString
(
"
texture2D
"
)
)
;
mGradientBuiltinFunctions
.
insert
(
ImmutableString
(
"
texture2DProj
"
)
)
;
mGradientBuiltinFunctions
.
insert
(
ImmutableString
(
"
textureCube
"
)
)
;
mGradientBuiltinFunctions
.
insert
(
ImmutableString
(
"
texture
"
)
)
;
mGradientBuiltinFunctions
.
insert
(
ImmutableString
(
"
textureProj
"
)
)
;
mGradientBuiltinFunctions
.
insert
(
ImmutableString
(
"
textureOffset
"
)
)
;
mGradientBuiltinFunctions
.
insert
(
ImmutableString
(
"
textureProjOffset
"
)
)
;
}
void
traverse
(
TIntermFunctionDefinition
*
node
)
{
node
-
>
traverse
(
this
)
;
ASSERT
(
mParents
.
empty
(
)
)
;
}
void
onGradient
(
)
{
mMetadata
-
>
mUsesGradient
=
true
;
if
(
!
mParents
.
empty
(
)
)
{
mMetadata
-
>
mControlFlowsContainingGradient
.
insert
(
mParents
.
back
(
)
)
;
}
}
void
visitControlFlow
(
Visit
visit
TIntermNode
*
node
)
{
if
(
visit
=
=
PreVisit
)
{
mParents
.
push_back
(
node
)
;
}
else
if
(
visit
=
=
PostVisit
)
{
ASSERT
(
mParents
.
back
(
)
=
=
node
)
;
mParents
.
pop_back
(
)
;
if
(
mMetadata
-
>
mControlFlowsContainingGradient
.
count
(
node
)
>
0
&
&
!
mParents
.
empty
(
)
)
{
mMetadata
-
>
mControlFlowsContainingGradient
.
insert
(
mParents
.
back
(
)
)
;
}
}
}
bool
visitLoop
(
Visit
visit
TIntermLoop
*
loop
)
override
{
visitControlFlow
(
visit
loop
)
;
return
true
;
}
bool
visitIfElse
(
Visit
visit
TIntermIfElse
*
ifElse
)
override
{
visitControlFlow
(
visit
ifElse
)
;
return
true
;
}
bool
visitUnary
(
Visit
visit
TIntermUnary
*
node
)
override
{
if
(
visit
=
=
PreVisit
)
{
switch
(
node
-
>
getOp
(
)
)
{
case
EOpDFdx
:
case
EOpDFdy
:
case
EOpFwidth
:
onGradient
(
)
;
break
;
default
:
break
;
}
}
return
true
;
}
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
{
if
(
visit
=
=
PreVisit
)
{
if
(
node
-
>
getOp
(
)
=
=
EOpCallFunctionInAST
)
{
size_t
calleeIndex
=
mDag
.
findIndex
(
node
-
>
getFunction
(
)
-
>
uniqueId
(
)
)
;
ASSERT
(
calleeIndex
!
=
CallDAG
:
:
InvalidIndex
&
&
calleeIndex
<
mIndex
)
;
if
(
(
*
mMetadataList
)
[
calleeIndex
]
.
mUsesGradient
)
{
onGradient
(
)
;
}
}
else
if
(
node
-
>
getOp
(
)
=
=
EOpCallBuiltInFunction
)
{
if
(
mGradientBuiltinFunctions
.
find
(
node
-
>
getFunction
(
)
-
>
name
(
)
)
!
=
mGradientBuiltinFunctions
.
end
(
)
)
{
onGradient
(
)
;
}
}
}
return
true
;
}
private
:
MetadataList
*
mMetadataList
;
ASTMetadataHLSL
*
mMetadata
;
size_t
mIndex
;
const
CallDAG
&
mDag
;
std
:
:
vector
<
TIntermNode
*
>
mParents
;
std
:
:
set
<
ImmutableString
>
mGradientBuiltinFunctions
;
}
;
class
PullComputeDiscontinuousAndGradientLoops
:
public
TIntermTraverser
{
public
:
PullComputeDiscontinuousAndGradientLoops
(
MetadataList
*
metadataList
size_t
index
const
CallDAG
&
dag
)
:
TIntermTraverser
(
true
false
true
)
mMetadataList
(
metadataList
)
mMetadata
(
&
(
*
metadataList
)
[
index
]
)
mIndex
(
index
)
mDag
(
dag
)
{
}
void
traverse
(
TIntermFunctionDefinition
*
node
)
{
node
-
>
traverse
(
this
)
;
ASSERT
(
mLoopsAndSwitches
.
empty
(
)
)
;
ASSERT
(
mIfs
.
empty
(
)
)
;
}
void
onGradientLoop
(
)
{
mMetadata
-
>
mHasGradientLoopInCallGraph
=
true
;
if
(
!
mIfs
.
empty
(
)
)
{
mMetadata
-
>
mIfsContainingGradientLoop
.
insert
(
mIfs
.
back
(
)
)
;
}
}
bool
visitLoop
(
Visit
visit
TIntermLoop
*
loop
)
override
{
if
(
visit
=
=
PreVisit
)
{
mLoopsAndSwitches
.
push_back
(
loop
)
;
if
(
mMetadata
-
>
hasGradientInCallGraph
(
loop
)
)
{
onGradientLoop
(
)
;
}
}
else
if
(
visit
=
=
PostVisit
)
{
ASSERT
(
mLoopsAndSwitches
.
back
(
)
=
=
loop
)
;
mLoopsAndSwitches
.
pop_back
(
)
;
}
return
true
;
}
bool
visitIfElse
(
Visit
visit
TIntermIfElse
*
node
)
override
{
if
(
visit
=
=
PreVisit
)
{
mIfs
.
push_back
(
node
)
;
}
else
if
(
visit
=
=
PostVisit
)
{
ASSERT
(
mIfs
.
back
(
)
=
=
node
)
;
mIfs
.
pop_back
(
)
;
if
(
mMetadata
-
>
mIfsContainingGradientLoop
.
count
(
node
)
>
0
&
&
!
mIfs
.
empty
(
)
)
{
mMetadata
-
>
mIfsContainingGradientLoop
.
insert
(
mIfs
.
back
(
)
)
;
}
}
return
true
;
}
bool
visitBranch
(
Visit
visit
TIntermBranch
*
node
)
override
{
if
(
visit
=
=
PreVisit
)
{
switch
(
node
-
>
getFlowOp
(
)
)
{
case
EOpBreak
:
{
ASSERT
(
!
mLoopsAndSwitches
.
empty
(
)
)
;
TIntermLoop
*
loop
=
mLoopsAndSwitches
.
back
(
)
-
>
getAsLoopNode
(
)
;
if
(
loop
!
=
nullptr
)
{
mMetadata
-
>
mDiscontinuousLoops
.
insert
(
loop
)
;
}
}
break
;
case
EOpContinue
:
{
ASSERT
(
!
mLoopsAndSwitches
.
empty
(
)
)
;
TIntermLoop
*
loop
=
nullptr
;
size_t
i
=
mLoopsAndSwitches
.
size
(
)
;
while
(
loop
=
=
nullptr
&
&
i
>
0
)
{
-
-
i
;
loop
=
mLoopsAndSwitches
.
at
(
i
)
-
>
getAsLoopNode
(
)
;
}
ASSERT
(
loop
!
=
nullptr
)
;
mMetadata
-
>
mDiscontinuousLoops
.
insert
(
loop
)
;
}
break
;
case
EOpKill
:
case
EOpReturn
:
if
(
!
mLoopsAndSwitches
.
empty
(
)
)
{
for
(
TIntermNode
*
intermNode
:
mLoopsAndSwitches
)
{
TIntermLoop
*
loop
=
intermNode
-
>
getAsLoopNode
(
)
;
if
(
loop
)
{
mMetadata
-
>
mDiscontinuousLoops
.
insert
(
loop
)
;
}
}
}
break
;
default
:
UNREACHABLE
(
)
;
}
}
return
true
;
}
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
{
if
(
visit
=
=
PreVisit
&
&
node
-
>
getOp
(
)
=
=
EOpCallFunctionInAST
)
{
size_t
calleeIndex
=
mDag
.
findIndex
(
node
-
>
getFunction
(
)
-
>
uniqueId
(
)
)
;
ASSERT
(
calleeIndex
!
=
CallDAG
:
:
InvalidIndex
&
&
calleeIndex
<
mIndex
)
;
if
(
(
*
mMetadataList
)
[
calleeIndex
]
.
mHasGradientLoopInCallGraph
)
{
onGradientLoop
(
)
;
}
}
return
true
;
}
bool
visitSwitch
(
Visit
visit
TIntermSwitch
*
node
)
override
{
if
(
visit
=
=
PreVisit
)
{
mLoopsAndSwitches
.
push_back
(
node
)
;
}
else
if
(
visit
=
=
PostVisit
)
{
ASSERT
(
mLoopsAndSwitches
.
back
(
)
=
=
node
)
;
mLoopsAndSwitches
.
pop_back
(
)
;
}
return
true
;
}
private
:
MetadataList
*
mMetadataList
;
ASTMetadataHLSL
*
mMetadata
;
size_t
mIndex
;
const
CallDAG
&
mDag
;
std
:
:
vector
<
TIntermNode
*
>
mLoopsAndSwitches
;
std
:
:
vector
<
TIntermIfElse
*
>
mIfs
;
}
;
class
PushDiscontinuousLoops
:
public
TIntermTraverser
{
public
:
PushDiscontinuousLoops
(
MetadataList
*
metadataList
size_t
index
const
CallDAG
&
dag
)
:
TIntermTraverser
(
true
true
true
)
mMetadataList
(
metadataList
)
mMetadata
(
&
(
*
metadataList
)
[
index
]
)
mIndex
(
index
)
mDag
(
dag
)
mNestedDiscont
(
mMetadata
-
>
mCalledInDiscontinuousLoop
?
1
:
0
)
{
}
void
traverse
(
TIntermFunctionDefinition
*
node
)
{
node
-
>
traverse
(
this
)
;
ASSERT
(
mNestedDiscont
=
=
(
mMetadata
-
>
mCalledInDiscontinuousLoop
?
1
:
0
)
)
;
}
bool
visitLoop
(
Visit
visit
TIntermLoop
*
loop
)
override
{
bool
isDiscontinuous
=
mMetadata
-
>
mDiscontinuousLoops
.
count
(
loop
)
>
0
;
if
(
visit
=
=
PreVisit
&
&
isDiscontinuous
)
{
mNestedDiscont
+
+
;
}
else
if
(
visit
=
=
PostVisit
&
&
isDiscontinuous
)
{
mNestedDiscont
-
-
;
}
return
true
;
}
bool
visitAggregate
(
Visit
visit
TIntermAggregate
*
node
)
override
{
switch
(
node
-
>
getOp
(
)
)
{
case
EOpCallFunctionInAST
:
if
(
visit
=
=
PreVisit
&
&
mNestedDiscont
>
0
)
{
size_t
calleeIndex
=
mDag
.
findIndex
(
node
-
>
getFunction
(
)
-
>
uniqueId
(
)
)
;
ASSERT
(
calleeIndex
!
=
CallDAG
:
:
InvalidIndex
&
&
calleeIndex
<
mIndex
)
;
(
*
mMetadataList
)
[
calleeIndex
]
.
mCalledInDiscontinuousLoop
=
true
;
}
break
;
default
:
break
;
}
return
true
;
}
private
:
MetadataList
*
mMetadataList
;
ASTMetadataHLSL
*
mMetadata
;
size_t
mIndex
;
const
CallDAG
&
mDag
;
int
mNestedDiscont
;
}
;
}
bool
ASTMetadataHLSL
:
:
hasGradientInCallGraph
(
TIntermLoop
*
node
)
{
return
mControlFlowsContainingGradient
.
count
(
node
)
>
0
;
}
bool
ASTMetadataHLSL
:
:
hasGradientLoop
(
TIntermIfElse
*
node
)
{
return
mIfsContainingGradientLoop
.
count
(
node
)
>
0
;
}
MetadataList
CreateASTMetadataHLSL
(
TIntermNode
*
root
const
CallDAG
&
callDag
)
{
MetadataList
metadataList
(
callDag
.
size
(
)
)
;
for
(
size_t
i
=
0
;
i
<
callDag
.
size
(
)
;
i
+
+
)
{
PullGradient
pull
(
&
metadataList
i
callDag
)
;
pull
.
traverse
(
callDag
.
getRecordFromIndex
(
i
)
.
node
)
;
}
for
(
size_t
i
=
0
;
i
<
callDag
.
size
(
)
;
i
+
+
)
{
PullComputeDiscontinuousAndGradientLoops
pull
(
&
metadataList
i
callDag
)
;
pull
.
traverse
(
callDag
.
getRecordFromIndex
(
i
)
.
node
)
;
}
for
(
size_t
i
=
callDag
.
size
(
)
;
i
-
-
>
0
;
)
{
PushDiscontinuousLoops
push
(
&
metadataList
i
callDag
)
;
push
.
traverse
(
callDag
.
getRecordFromIndex
(
i
)
.
node
)
;
}
for
(
auto
&
metadata
:
metadataList
)
{
metadata
.
mNeedsLod0
=
metadata
.
mCalledInDiscontinuousLoop
&
&
metadata
.
mUsesGradient
;
}
return
metadataList
;
}
}
