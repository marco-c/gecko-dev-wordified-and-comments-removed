#
include
"
ValidateVaryingLocations
.
h
"
#
include
"
compiler
/
translator
/
Diagnostics
.
h
"
#
include
"
compiler
/
translator
/
SymbolTable
.
h
"
#
include
"
compiler
/
translator
/
tree_util
/
IntermTraverse
.
h
"
#
include
"
compiler
/
translator
/
util
.
h
"
namespace
sh
{
namespace
{
void
error
(
const
TIntermSymbol
&
symbol
const
char
*
reason
TDiagnostics
*
diagnostics
)
{
diagnostics
-
>
error
(
symbol
.
getLine
(
)
reason
symbol
.
getName
(
)
.
data
(
)
)
;
}
int
GetStructLocationCount
(
const
TStructure
*
structure
)
;
int
GetFieldLocationCount
(
const
TField
*
field
)
{
int
field_size
=
0
;
const
TType
*
fieldType
=
field
-
>
type
(
)
;
if
(
fieldType
-
>
getStruct
(
)
!
=
nullptr
)
{
field_size
=
GetStructLocationCount
(
fieldType
-
>
getStruct
(
)
)
;
}
else
if
(
fieldType
-
>
isMatrix
(
)
)
{
field_size
=
fieldType
-
>
getNominalSize
(
)
;
}
else
{
ASSERT
(
fieldType
-
>
getSecondarySize
(
)
=
=
1
)
;
field_size
=
1
;
}
if
(
fieldType
-
>
isArray
(
)
)
{
field_size
*
=
fieldType
-
>
getArraySizeProduct
(
)
;
}
return
field_size
;
}
int
GetStructLocationCount
(
const
TStructure
*
structure
)
{
int
totalLocation
=
0
;
for
(
const
TField
*
field
:
structure
-
>
fields
(
)
)
{
totalLocation
+
=
GetFieldLocationCount
(
field
)
;
}
return
totalLocation
;
}
int
GetInterfaceBlockLocationCount
(
const
TType
&
varyingType
bool
ignoreVaryingArraySize
)
{
int
totalLocation
=
0
;
for
(
const
TField
*
field
:
varyingType
.
getInterfaceBlock
(
)
-
>
fields
(
)
)
{
totalLocation
+
=
GetFieldLocationCount
(
field
)
;
}
if
(
!
ignoreVaryingArraySize
&
&
varyingType
.
isArray
(
)
)
{
totalLocation
*
=
varyingType
.
getArraySizeProduct
(
)
;
}
return
totalLocation
;
}
int
GetLocationCount
(
const
TIntermSymbol
*
varying
bool
ignoreVaryingArraySize
)
{
const
TType
&
varyingType
=
varying
-
>
getType
(
)
;
ASSERT
(
!
varyingType
.
isInterfaceBlock
(
)
)
;
if
(
varyingType
.
getStruct
(
)
!
=
nullptr
)
{
int
totalLocation
=
0
;
for
(
const
TField
*
field
:
varyingType
.
getStruct
(
)
-
>
fields
(
)
)
{
const
TType
*
fieldType
=
field
-
>
type
(
)
;
ASSERT
(
fieldType
-
>
getStruct
(
)
=
=
nullptr
&
&
!
fieldType
-
>
isArray
(
)
)
;
totalLocation
+
=
GetFieldLocationCount
(
field
)
;
}
return
totalLocation
;
}
ASSERT
(
varyingType
.
isMatrix
(
)
|
|
varyingType
.
getSecondarySize
(
)
=
=
1
)
;
int
elementLocationCount
=
varyingType
.
isMatrix
(
)
?
varyingType
.
getNominalSize
(
)
:
1
;
if
(
ignoreVaryingArraySize
)
{
ASSERT
(
!
varyingType
.
isArrayOfArrays
(
)
)
;
return
elementLocationCount
;
}
return
elementLocationCount
*
varyingType
.
getArraySizeProduct
(
)
;
}
bool
ShouldIgnoreVaryingArraySize
(
TQualifier
qualifier
GLenum
shaderType
)
{
bool
isVaryingIn
=
IsShaderIn
(
qualifier
)
&
&
qualifier
!
=
EvqPatchIn
;
switch
(
shaderType
)
{
case
GL_GEOMETRY_SHADER
:
case
GL_TESS_EVALUATION_SHADER
:
return
isVaryingIn
;
case
GL_TESS_CONTROL_SHADER
:
return
(
IsShaderOut
(
qualifier
)
&
&
qualifier
!
=
EvqPatchOut
)
|
|
isVaryingIn
;
default
:
return
false
;
}
}
struct
SymbolAndField
{
const
TIntermSymbol
*
symbol
;
const
TField
*
field
;
}
;
using
LocationMap
=
std
:
:
map
<
int
SymbolAndField
>
;
void
MarkVaryingLocations
(
TDiagnostics
*
diagnostics
const
TIntermSymbol
*
varying
const
TField
*
field
int
location
int
elementCount
LocationMap
*
locationMap
)
{
for
(
int
elementIndex
=
0
;
elementIndex
<
elementCount
;
+
+
elementIndex
)
{
const
int
offsetLocation
=
location
+
elementIndex
;
auto
conflict
=
locationMap
-
>
find
(
offsetLocation
)
;
if
(
conflict
!
=
locationMap
-
>
end
(
)
)
{
std
:
:
stringstream
strstr
=
sh
:
:
InitializeStream
<
std
:
:
stringstream
>
(
)
;
strstr
<
<
"
'
"
<
<
varying
-
>
getName
(
)
;
if
(
field
)
{
strstr
<
<
"
.
"
<
<
field
-
>
name
(
)
;
}
strstr
<
<
"
'
conflicting
location
with
'
"
<
<
conflict
-
>
second
.
symbol
-
>
getName
(
)
;
if
(
conflict
-
>
second
.
field
)
{
strstr
<
<
"
.
"
<
<
conflict
-
>
second
.
field
-
>
name
(
)
;
}
strstr
<
<
"
'
"
;
error
(
*
varying
strstr
.
str
(
)
.
c_str
(
)
diagnostics
)
;
}
else
{
(
*
locationMap
)
[
offsetLocation
]
=
{
varying
field
}
;
}
}
}
using
VaryingVector
=
std
:
:
vector
<
const
TIntermSymbol
*
>
;
void
ValidateShaderInterfaceAndAssignLocations
(
TDiagnostics
*
diagnostics
const
VaryingVector
&
varyingVector
GLenum
shaderType
)
{
if
(
varyingVector
.
size
(
)
<
=
1
)
{
return
;
}
LocationMap
locationMap
;
for
(
const
TIntermSymbol
*
varying
:
varyingVector
)
{
const
TType
&
varyingType
=
varying
-
>
getType
(
)
;
const
int
location
=
varyingType
.
getLayoutQualifier
(
)
.
location
;
ASSERT
(
location
>
=
0
)
;
bool
ignoreVaryingArraySize
=
ShouldIgnoreVaryingArraySize
(
varying
-
>
getQualifier
(
)
shaderType
)
;
if
(
varyingType
.
isInterfaceBlock
(
)
)
{
int
currentLocation
=
location
;
bool
anyFieldWithLocation
=
false
;
for
(
const
TField
*
field
:
varyingType
.
getInterfaceBlock
(
)
-
>
fields
(
)
)
{
const
int
fieldLocation
=
field
-
>
type
(
)
-
>
getLayoutQualifier
(
)
.
location
;
if
(
fieldLocation
>
=
0
)
{
currentLocation
=
fieldLocation
;
anyFieldWithLocation
=
true
;
}
const
int
fieldLocationCount
=
GetFieldLocationCount
(
field
)
;
MarkVaryingLocations
(
diagnostics
varying
field
currentLocation
fieldLocationCount
&
locationMap
)
;
currentLocation
+
=
fieldLocationCount
;
}
ASSERT
(
ignoreVaryingArraySize
|
|
!
anyFieldWithLocation
|
|
!
varyingType
.
isArray
(
)
)
;
if
(
!
ignoreVaryingArraySize
&
&
varyingType
.
isArray
(
)
)
{
int
remainingLocations
=
currentLocation
*
(
varyingType
.
getArraySizeProduct
(
)
-
1
)
;
MarkVaryingLocations
(
diagnostics
varying
nullptr
currentLocation
remainingLocations
&
locationMap
)
;
}
}
else
{
const
int
elementCount
=
GetLocationCount
(
varying
ignoreVaryingArraySize
)
;
MarkVaryingLocations
(
diagnostics
varying
nullptr
location
elementCount
&
locationMap
)
;
}
}
}
class
ValidateVaryingLocationsTraverser
:
public
TIntermTraverser
{
public
:
ValidateVaryingLocationsTraverser
(
GLenum
shaderType
)
;
void
validate
(
TDiagnostics
*
diagnostics
)
;
private
:
bool
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
node
)
override
;
bool
visitFunctionDefinition
(
Visit
visit
TIntermFunctionDefinition
*
node
)
override
;
VaryingVector
mInputVaryingsWithLocation
;
VaryingVector
mOutputVaryingsWithLocation
;
GLenum
mShaderType
;
}
;
ValidateVaryingLocationsTraverser
:
:
ValidateVaryingLocationsTraverser
(
GLenum
shaderType
)
:
TIntermTraverser
(
true
false
false
)
mShaderType
(
shaderType
)
{
}
bool
ValidateVaryingLocationsTraverser
:
:
visitDeclaration
(
Visit
visit
TIntermDeclaration
*
node
)
{
const
TIntermSequence
&
sequence
=
*
(
node
-
>
getSequence
(
)
)
;
ASSERT
(
!
sequence
.
empty
(
)
)
;
const
TIntermSymbol
*
symbol
=
sequence
.
front
(
)
-
>
getAsSymbolNode
(
)
;
if
(
symbol
=
=
nullptr
)
{
return
false
;
}
if
(
symbol
-
>
variable
(
)
.
symbolType
(
)
=
=
SymbolType
:
:
Empty
)
{
return
false
;
}
const
TQualifier
qualifier
=
symbol
-
>
getQualifier
(
)
;
if
(
symbol
-
>
getType
(
)
.
getLayoutQualifier
(
)
.
location
!
=
-
1
)
{
if
(
IsVaryingIn
(
qualifier
)
)
{
mInputVaryingsWithLocation
.
push_back
(
symbol
)
;
}
else
if
(
IsVaryingOut
(
qualifier
)
)
{
mOutputVaryingsWithLocation
.
push_back
(
symbol
)
;
}
}
return
false
;
}
bool
ValidateVaryingLocationsTraverser
:
:
visitFunctionDefinition
(
Visit
visit
TIntermFunctionDefinition
*
node
)
{
return
false
;
}
void
ValidateVaryingLocationsTraverser
:
:
validate
(
TDiagnostics
*
diagnostics
)
{
ASSERT
(
diagnostics
)
;
ValidateShaderInterfaceAndAssignLocations
(
diagnostics
mInputVaryingsWithLocation
mShaderType
)
;
ValidateShaderInterfaceAndAssignLocations
(
diagnostics
mOutputVaryingsWithLocation
mShaderType
)
;
}
}
unsigned
int
CalculateVaryingLocationCount
(
TIntermSymbol
*
varying
GLenum
shaderType
)
{
const
TType
&
varyingType
=
varying
-
>
getType
(
)
;
const
TQualifier
qualifier
=
varyingType
.
getQualifier
(
)
;
const
bool
ignoreVaryingArraySize
=
ShouldIgnoreVaryingArraySize
(
qualifier
shaderType
)
;
if
(
varyingType
.
isInterfaceBlock
(
)
)
{
return
GetInterfaceBlockLocationCount
(
varyingType
ignoreVaryingArraySize
)
;
}
return
GetLocationCount
(
varying
ignoreVaryingArraySize
)
;
}
bool
ValidateVaryingLocations
(
TIntermBlock
*
root
TDiagnostics
*
diagnostics
GLenum
shaderType
)
{
ValidateVaryingLocationsTraverser
varyingValidator
(
shaderType
)
;
root
-
>
traverse
(
&
varyingValidator
)
;
int
numErrorsBefore
=
diagnostics
-
>
numErrors
(
)
;
varyingValidator
.
validate
(
diagnostics
)
;
return
(
diagnostics
-
>
numErrors
(
)
=
=
numErrorsBefore
)
;
}
}
