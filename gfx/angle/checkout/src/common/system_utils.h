#
ifndef
COMMON_SYSTEM_UTILS_H_
#
define
COMMON_SYSTEM_UTILS_H_
#
include
"
common
/
Optional
.
h
"
#
include
"
common
/
angleutils
.
h
"
#
include
<
functional
>
#
include
<
string
>
#
include
<
string_view
>
namespace
angle
{
std
:
:
string
GetExecutableName
(
)
;
std
:
:
string
GetExecutablePath
(
)
;
std
:
:
string
GetExecutableDirectory
(
)
;
std
:
:
string
GetModuleDirectory
(
)
;
const
char
*
GetSharedLibraryExtension
(
)
;
const
char
*
GetExecutableExtension
(
)
;
char
GetPathSeparator
(
)
;
Optional
<
std
:
:
string
>
GetCWD
(
)
;
bool
SetCWD
(
const
char
*
dirName
)
;
bool
SetEnvironmentVar
(
const
char
*
variableName
const
char
*
value
)
;
bool
UnsetEnvironmentVar
(
const
char
*
variableName
)
;
bool
GetBoolEnvironmentVar
(
const
char
*
variableName
)
;
std
:
:
string
GetEnvironmentVar
(
const
char
*
variableName
)
;
std
:
:
string
GetEnvironmentVarOrUnCachedAndroidProperty
(
const
char
*
variableName
const
char
*
propertyName
)
;
std
:
:
string
GetAndSetEnvironmentVarOrUnCachedAndroidProperty
(
const
char
*
variableName
const
char
*
propertyName
)
;
std
:
:
string
GetEnvironmentVarOrAndroidProperty
(
const
char
*
variableName
const
char
*
propertyName
)
;
const
char
*
GetPathSeparatorForEnvironmentVar
(
)
;
bool
PrependPathToEnvironmentVar
(
const
char
*
variableName
const
char
*
path
)
;
bool
IsDirectory
(
const
char
*
filename
)
;
bool
IsFullPath
(
std
:
:
string
dirName
)
;
std
:
:
string
GetRootDirectory
(
)
;
std
:
:
string
ConcatenatePath
(
std
:
:
string
first
std
:
:
string
second
)
;
Optional
<
std
:
:
string
>
GetTempDirectory
(
)
;
Optional
<
std
:
:
string
>
CreateTemporaryFileInDirectory
(
const
std
:
:
string
&
directory
)
;
Optional
<
std
:
:
string
>
CreateTemporaryFile
(
)
;
double
GetCurrentSystemTime
(
)
;
double
GetCurrentProcessCpuTime
(
)
;
uint64_t
GetCurrentThreadUniqueId
(
)
;
bool
RunApp
(
const
std
:
:
vector
<
const
char
*
>
&
args
std
:
:
string
*
stdoutOut
std
:
:
string
*
stderrOut
int
*
exitCodeOut
)
;
enum
class
SearchType
{
ModuleDir
SystemDir
AlreadyLoaded
}
;
void
*
OpenSystemLibrary
(
const
char
*
libraryName
SearchType
searchType
)
;
void
*
OpenSystemLibraryWithExtension
(
const
char
*
libraryName
SearchType
searchType
)
;
void
*
OpenSystemLibraryAndGetError
(
const
char
*
libraryName
SearchType
searchType
std
:
:
string
*
errorOut
)
;
void
*
OpenSystemLibraryWithExtensionAndGetError
(
const
char
*
libraryName
SearchType
searchType
std
:
:
string
*
errorOut
)
;
void
*
GetLibrarySymbol
(
void
*
libraryHandle
const
char
*
symbolName
)
;
std
:
:
string
GetLibraryPath
(
void
*
libraryHandle
)
;
void
CloseSystemLibrary
(
void
*
libraryHandle
)
;
class
Library
:
angle
:
:
NonCopyable
{
public
:
Library
(
)
{
}
Library
(
void
*
libraryHandle
)
:
mLibraryHandle
(
libraryHandle
)
{
}
~
Library
(
)
{
close
(
)
;
}
[
[
nodiscard
]
]
bool
open
(
const
char
*
libraryName
SearchType
searchType
)
{
close
(
)
;
mLibraryHandle
=
OpenSystemLibrary
(
libraryName
searchType
)
;
return
mLibraryHandle
!
=
nullptr
;
}
[
[
nodiscard
]
]
bool
openWithExtension
(
const
char
*
libraryName
SearchType
searchType
)
{
close
(
)
;
mLibraryHandle
=
OpenSystemLibraryWithExtension
(
libraryName
searchType
)
;
return
mLibraryHandle
!
=
nullptr
;
}
[
[
nodiscard
]
]
bool
openAndGetError
(
const
char
*
libraryName
SearchType
searchType
std
:
:
string
*
errorOut
)
{
close
(
)
;
mLibraryHandle
=
OpenSystemLibraryAndGetError
(
libraryName
searchType
errorOut
)
;
return
mLibraryHandle
!
=
nullptr
;
}
[
[
nodiscard
]
]
bool
openWithExtensionAndGetError
(
const
char
*
libraryName
SearchType
searchType
std
:
:
string
*
errorOut
)
{
close
(
)
;
mLibraryHandle
=
OpenSystemLibraryWithExtensionAndGetError
(
libraryName
searchType
errorOut
)
;
return
mLibraryHandle
!
=
nullptr
;
}
void
close
(
)
{
if
(
mLibraryHandle
)
{
CloseSystemLibrary
(
mLibraryHandle
)
;
mLibraryHandle
=
nullptr
;
}
}
void
*
getSymbol
(
const
char
*
symbolName
)
{
return
GetLibrarySymbol
(
mLibraryHandle
symbolName
)
;
}
void
*
getNative
(
)
const
{
return
mLibraryHandle
;
}
std
:
:
string
getPath
(
)
const
{
return
GetLibraryPath
(
mLibraryHandle
)
;
}
template
<
typename
FuncT
>
void
getAs
(
const
char
*
symbolName
FuncT
*
funcOut
)
{
*
funcOut
=
reinterpret_cast
<
FuncT
>
(
getSymbol
(
symbolName
)
)
;
}
private
:
void
*
mLibraryHandle
=
nullptr
;
}
;
Library
*
OpenSharedLibrary
(
const
char
*
libraryName
SearchType
searchType
)
;
Library
*
OpenSharedLibraryWithExtension
(
const
char
*
libraryName
SearchType
searchType
)
;
Library
*
OpenSharedLibraryAndGetError
(
const
char
*
libraryName
SearchType
searchType
std
:
:
string
*
errorOut
)
;
Library
*
OpenSharedLibraryWithExtensionAndGetError
(
const
char
*
libraryName
SearchType
searchType
std
:
:
string
*
errorOut
)
;
bool
IsDebuggerAttached
(
)
;
void
BreakDebugger
(
)
;
uint64_t
GetProcessMemoryUsageKB
(
)
;
bool
ProtectMemory
(
uintptr_t
start
size_t
size
)
;
bool
UnprotectMemory
(
uintptr_t
start
size_t
size
)
;
size_t
GetPageSize
(
)
;
enum
class
PageFaultHandlerRangeType
{
InRange
OutOfRange
}
;
using
PageFaultCallback
=
std
:
:
function
<
PageFaultHandlerRangeType
(
uintptr_t
)
>
;
class
PageFaultHandler
:
angle
:
:
NonCopyable
{
public
:
PageFaultHandler
(
PageFaultCallback
callback
)
;
virtual
~
PageFaultHandler
(
)
;
virtual
bool
enable
(
)
=
0
;
virtual
bool
disable
(
)
=
0
;
protected
:
PageFaultCallback
mCallback
;
}
;
PageFaultHandler
*
CreatePageFaultHandler
(
PageFaultCallback
callback
)
;
#
ifdef
ANGLE_PLATFORM_WINDOWS
std
:
:
string
Narrow
(
const
std
:
:
wstring_view
&
utf16
)
;
std
:
:
wstring
Widen
(
const
std
:
:
string_view
&
utf8
)
;
#
endif
std
:
:
string
StripFilenameFromPath
(
const
std
:
:
string
&
path
)
;
}
#
endif
