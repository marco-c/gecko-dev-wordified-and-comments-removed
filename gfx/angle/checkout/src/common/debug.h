#
ifndef
COMMON_DEBUG_H_
#
define
COMMON_DEBUG_H_
#
include
<
assert
.
h
>
#
include
<
stdio
.
h
>
#
include
<
ios
>
#
include
<
iomanip
>
#
include
<
sstream
>
#
include
<
string
>
#
include
"
common
/
angleutils
.
h
"
#
if
!
defined
(
TRACE_OUTPUT_FILE
)
#
define
TRACE_OUTPUT_FILE
"
angle_debug
.
txt
"
#
endif
namespace
gl
{
class
ScopedPerfEventHelper
:
angle
:
:
NonCopyable
{
public
:
ScopedPerfEventHelper
(
const
char
*
format
.
.
.
)
;
~
ScopedPerfEventHelper
(
)
;
}
;
using
LogSeverity
=
int
;
constexpr
LogSeverity
LOG_EVENT
=
0
;
constexpr
LogSeverity
LOG_WARN
=
1
;
constexpr
LogSeverity
LOG_ERR
=
2
;
constexpr
LogSeverity
LOG_NUM_SEVERITIES
=
3
;
void
Trace
(
LogSeverity
severity
const
char
*
message
)
;
class
LogMessage
:
angle
:
:
NonCopyable
{
public
:
LogMessage
(
const
char
*
function
int
line
LogSeverity
severity
)
;
~
LogMessage
(
)
;
std
:
:
ostream
&
stream
(
)
{
return
mStream
;
}
LogSeverity
getSeverity
(
)
const
;
std
:
:
string
getMessage
(
)
const
;
private
:
const
char
*
mFunction
;
const
int
mLine
;
const
LogSeverity
mSeverity
;
std
:
:
ostringstream
mStream
;
}
;
class
DebugAnnotator
:
angle
:
:
NonCopyable
{
public
:
DebugAnnotator
(
)
{
}
;
virtual
~
DebugAnnotator
(
)
{
}
;
virtual
void
beginEvent
(
const
wchar_t
*
eventName
)
=
0
;
virtual
void
endEvent
(
)
=
0
;
virtual
void
setMarker
(
const
wchar_t
*
markerName
)
=
0
;
virtual
bool
getStatus
(
)
=
0
;
virtual
void
logMessage
(
const
LogMessage
&
msg
)
const
=
0
;
}
;
void
InitializeDebugAnnotations
(
DebugAnnotator
*
debugAnnotator
)
;
void
UninitializeDebugAnnotations
(
)
;
bool
DebugAnnotationsActive
(
)
;
bool
DebugAnnotationsInitialized
(
)
;
namespace
priv
{
class
LogMessageVoidify
{
public
:
LogMessageVoidify
(
)
{
}
void
operator
&
(
std
:
:
ostream
&
)
{
}
}
;
extern
std
:
:
ostream
*
gSwallowStream
;
bool
ShouldCreatePlatformLogMessage
(
LogSeverity
severity
)
;
template
<
int
N
typename
T
>
std
:
:
ostream
&
FmtHex
(
std
:
:
ostream
&
os
T
value
)
{
os
<
<
"
0x
"
;
std
:
:
ios_base
:
:
fmtflags
oldFlags
=
os
.
flags
(
)
;
std
:
:
streamsize
oldWidth
=
os
.
width
(
)
;
std
:
:
ostream
:
:
char_type
oldFill
=
os
.
fill
(
)
;
os
<
<
std
:
:
hex
<
<
std
:
:
uppercase
<
<
std
:
:
setw
(
N
)
<
<
std
:
:
setfill
(
'
0
'
)
<
<
value
;
os
.
flags
(
oldFlags
)
;
os
.
width
(
oldWidth
)
;
os
.
fill
(
oldFill
)
;
return
os
;
}
template
<
typename
T
>
std
:
:
ostream
&
FmtHexAutoSized
(
std
:
:
ostream
&
os
T
value
)
{
constexpr
int
N
=
sizeof
(
T
)
*
2
;
return
priv
:
:
FmtHex
<
N
>
(
os
value
)
;
}
template
<
typename
T
>
class
FmtHexHelper
{
public
:
FmtHexHelper
(
const
char
*
prefix
T
value
)
:
mPrefix
(
prefix
)
mValue
(
value
)
{
}
explicit
FmtHexHelper
(
T
value
)
:
mPrefix
(
nullptr
)
mValue
(
value
)
{
}
private
:
const
char
*
mPrefix
;
T
mValue
;
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
os
const
FmtHexHelper
&
fmt
)
{
if
(
fmt
.
mPrefix
)
{
os
<
<
fmt
.
mPrefix
;
}
return
FmtHexAutoSized
(
os
fmt
.
mValue
)
;
}
}
;
}
template
<
typename
T
>
priv
:
:
FmtHexHelper
<
T
>
FmtHex
(
T
value
)
{
return
priv
:
:
FmtHexHelper
<
T
>
(
value
)
;
}
#
if
defined
(
ANGLE_PLATFORM_WINDOWS
)
priv
:
:
FmtHexHelper
<
HRESULT
>
FmtHR
(
HRESULT
value
)
;
priv
:
:
FmtHexHelper
<
DWORD
>
FmtErr
(
DWORD
value
)
;
#
endif
template
<
typename
T
>
std
:
:
ostream
&
FmtHex
(
std
:
:
ostream
&
os
T
value
)
{
return
priv
:
:
FmtHexAutoSized
(
os
value
)
;
}
#
define
COMPACT_ANGLE_LOG_EX_EVENT
(
ClassName
.
.
.
)
\
:
:
gl
:
:
ClassName
(
__FUNCTION__
__LINE__
:
:
gl
:
:
LOG_EVENT
#
#
__VA_ARGS__
)
#
define
COMPACT_ANGLE_LOG_EX_WARN
(
ClassName
.
.
.
)
\
:
:
gl
:
:
ClassName
(
__FUNCTION__
__LINE__
:
:
gl
:
:
LOG_WARN
#
#
__VA_ARGS__
)
#
define
COMPACT_ANGLE_LOG_EX_ERR
(
ClassName
.
.
.
)
\
:
:
gl
:
:
ClassName
(
__FUNCTION__
__LINE__
:
:
gl
:
:
LOG_ERR
#
#
__VA_ARGS__
)
#
define
COMPACT_ANGLE_LOG_EVENT
COMPACT_ANGLE_LOG_EX_EVENT
(
LogMessage
)
#
define
COMPACT_ANGLE_LOG_WARN
COMPACT_ANGLE_LOG_EX_WARN
(
LogMessage
)
#
define
COMPACT_ANGLE_LOG_ERR
COMPACT_ANGLE_LOG_EX_ERR
(
LogMessage
)
#
define
ANGLE_LOG_IS_ON
(
severity
)
(
:
:
gl
:
:
priv
:
:
ShouldCreatePlatformLogMessage
(
:
:
gl
:
:
LOG_
#
#
severity
)
)
#
define
ANGLE_LAZY_STREAM
(
stream
condition
)
\
!
(
condition
)
?
static_cast
<
void
>
(
0
)
:
:
:
gl
:
:
priv
:
:
LogMessageVoidify
(
)
&
(
stream
)
#
define
ANGLE_LOG_STREAM
(
severity
)
COMPACT_ANGLE_LOG_
#
#
severity
.
stream
(
)
#
define
ANGLE_LOG
(
severity
)
ANGLE_LAZY_STREAM
(
ANGLE_LOG_STREAM
(
severity
)
ANGLE_LOG_IS_ON
(
severity
)
)
}
#
if
defined
(
ANGLE_ENABLE_DEBUG_TRACE
)
|
|
defined
(
ANGLE_ENABLE_DEBUG_ANNOTATIONS
)
#
define
ANGLE_TRACE_ENABLED
#
endif
#
define
ANGLE_EMPTY_STATEMENT
for
(
;
;
)
break
#
if
!
defined
(
NDEBUG
)
|
|
defined
(
ANGLE_ENABLE_RELEASE_ASSERTS
)
#
define
ANGLE_ENABLE_ASSERTS
#
endif
#
define
WARN
(
)
ANGLE_LOG
(
WARN
)
#
define
ERR
(
)
ANGLE_LOG
(
ERR
)
#
if
defined
(
ANGLE_TRACE_ENABLED
)
#
if
defined
(
_MSC_VER
)
#
define
EVENT
(
message
.
.
.
)
gl
:
:
ScopedPerfEventHelper
scopedPerfEventHelper
#
#
__LINE__
(
"
%
s
"
message
"
\
n
"
__FUNCTION__
__VA_ARGS__
)
;
#
else
#
define
EVENT
(
message
.
.
.
)
gl
:
:
ScopedPerfEventHelper
scopedPerfEventHelper
(
"
%
s
"
message
"
\
n
"
__FUNCTION__
#
#
__VA_ARGS__
)
;
#
endif
#
else
#
define
EVENT
(
message
.
.
.
)
(
void
(
0
)
)
#
endif
#
if
defined
(
COMPILER_GCC
)
|
|
defined
(
__clang__
)
#
define
ANGLE_CRASH
(
)
__builtin_trap
(
)
#
else
#
define
ANGLE_CRASH
(
)
(
(
void
)
(
*
(
volatile
char
*
)
0
=
0
)
)
__assume
(
0
)
#
endif
#
if
!
defined
(
NDEBUG
)
#
define
ANGLE_ASSERT_IMPL
(
expression
)
assert
(
expression
)
#
define
ANGLE_ASSERT_IMPL_IS_NORETURN
0
#
else
#
define
ANGLE_ASSERT_IMPL
(
expression
)
ANGLE_CRASH
(
)
#
define
ANGLE_ASSERT_IMPL_IS_NORETURN
1
#
endif
#
define
ANGLE_EAT_STREAM_PARAMETERS
\
true
?
static_cast
<
void
>
(
0
)
:
:
:
gl
:
:
priv
:
:
LogMessageVoidify
(
)
&
(
*
:
:
gl
:
:
priv
:
:
gSwallowStream
)
#
if
defined
(
ANGLE_ENABLE_ASSERTS
)
#
define
ASSERT
(
expression
)
\
(
expression
?
static_cast
<
void
>
(
0
)
:
(
(
ERR
(
)
<
<
"
\
t
!
Assert
failed
in
"
<
<
__FUNCTION__
<
<
"
(
"
\
<
<
__LINE__
<
<
"
)
:
"
<
<
#
expression
)
\
ANGLE_ASSERT_IMPL
(
expression
)
)
)
#
define
UNREACHABLE_IS_NORETURN
ANGLE_ASSERT_IMPL_IS_NORETURN
#
else
#
define
ASSERT
(
condition
)
ANGLE_EAT_STREAM_PARAMETERS
<
<
!
(
condition
)
#
define
UNREACHABLE_IS_NORETURN
0
#
endif
#
define
ANGLE_UNUSED_VARIABLE
(
variable
)
(
static_cast
<
void
>
(
variable
)
)
#
ifndef
NOASSERT_UNIMPLEMENTED
#
define
NOASSERT_UNIMPLEMENTED
1
#
endif
#
if
defined
(
ANGLE_TRACE_ENABLED
)
|
|
defined
(
ANGLE_ENABLE_ASSERTS
)
#
define
UNIMPLEMENTED
(
)
\
{
\
WARN
(
)
<
<
"
\
t
!
Unimplemented
:
"
<
<
__FUNCTION__
<
<
"
(
"
<
<
__FILE__
<
<
"
:
"
<
<
__LINE__
\
<
<
"
)
"
;
\
ASSERT
(
NOASSERT_UNIMPLEMENTED
)
;
\
}
\
ANGLE_EMPTY_STATEMENT
#
define
UNREACHABLE
(
)
\
{
\
ERR
(
)
<
<
"
\
t
!
Unreachable
reached
:
"
<
<
__FUNCTION__
<
<
"
(
"
<
<
__FILE__
<
<
"
:
"
<
<
__LINE__
\
<
<
"
)
"
;
\
ASSERT
(
false
)
;
\
}
\
ANGLE_EMPTY_STATEMENT
#
else
#
define
UNIMPLEMENTED
(
)
\
{
\
ASSERT
(
NOASSERT_UNIMPLEMENTED
)
;
\
}
\
ANGLE_EMPTY_STATEMENT
#
define
UNREACHABLE
(
)
\
{
\
ASSERT
(
false
)
;
\
}
\
ANGLE_EMPTY_STATEMENT
#
endif
#
endif
