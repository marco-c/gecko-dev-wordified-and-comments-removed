#
include
"
PMurHash
.
h
"
#
include
<
stdint
.
h
>
#
undef
uint32_t
#
define
uint32_t
MH_UINT32
#
undef
uint8_t
#
define
uint8_t
MH_UINT8
#
if
defined
(
_MSC_VER
)
#
pragma
warning
(
disable
:
4127
)
/
*
conditional
expression
is
constant
*
/
#
endif
#
if
!
defined
(
__BIG_ENDIAN
)
#
define
__BIG_ENDIAN
4321
#
endif
#
if
!
defined
(
__LITTLE_ENDIAN
)
#
define
__LITTLE_ENDIAN
1234
#
endif
#
if
defined
(
_M_IX86
)
|
|
defined
(
__i386__
)
|
|
defined
(
__i386
)
|
|
defined
(
i386
)
#
define
__BYTE_ORDER
__LITTLE_ENDIAN
#
define
UNALIGNED_SAFE
#
endif
#
if
!
defined
(
__BYTE_ORDER
)
#
if
defined
(
__LITTLE_ENDIAN__
)
&
&
__LITTLE_ENDIAN__
=
=
1
|
|
defined
(
_LITTLE_ENDIAN
)
&
&
_LITTLE_ENDIAN
=
=
1
#
define
__BYTE_ORDER
__LITTLE_ENDIAN
#
elif
defined
(
__BIG_ENDIAN__
)
&
&
__BIG_ENDIAN__
=
=
1
|
|
defined
(
_BIG_ENDIAN
)
&
&
_BIG_ENDIAN
=
=
1
#
define
__BYTE_ORDER
__BIG_ENDIAN
#
endif
#
endif
#
if
!
defined
(
__BYTE_ORDER
)
#
if
defined
(
__ARMEL__
)
|
|
defined
(
__MIPSEL__
)
#
define
__BYTE_ORDER
__LITTLE_ENDIAN
#
endif
#
if
defined
(
__ARMEB__
)
|
|
defined
(
__MIPSEB__
)
#
define
__BYTE_ORDER
__BIG_ENDIAN
#
endif
#
endif
#
if
__BYTE_ORDER
=
=
__LITTLE_ENDIAN
#
define
READ_UINT32
(
ptr
)
(
*
(
(
uint32_t
*
)
(
ptr
)
)
)
#
elif
__BYTE_ORDER
=
=
__BIG_ENDIAN
#
if
defined
(
__GNUC__
)
&
&
(
__GNUC__
>
4
|
|
(
__GNUC__
=
=
4
&
&
__GNUC_MINOR__
>
=
3
)
)
#
define
READ_UINT32
(
ptr
)
(
__builtin_bswap32
(
*
(
(
uint32_t
*
)
(
ptr
)
)
)
)
#
else
#
define
READ_UINT32
(
ptr
)
(
ptr
[
0
]
|
ptr
[
1
]
<
<
8
|
ptr
[
2
]
<
<
16
|
ptr
[
3
]
<
<
24
)
#
define
UNALIGNED_SAFE
#
endif
#
else
#
define
READ_UINT32
(
ptr
)
(
ptr
[
0
]
|
ptr
[
1
]
<
<
8
|
ptr
[
2
]
<
<
16
|
ptr
[
3
]
<
<
24
)
#
define
UNALIGNED_SAFE
#
endif
#
if
defined
(
_MSC_VER
)
#
include
<
stdlib
.
h
>
#
define
ROTL32
(
x
r
)
_rotl
(
x
r
)
#
else
#
define
ROTL32
(
x
r
)
(
(
(
uint32_t
)
x
<
<
r
)
|
(
(
uint32_t
)
x
>
>
(
32
-
r
)
)
)
#
endif
#
define
C1
(
0xcc9e2d51
)
#
define
C2
(
0x1b873593
)
#
define
DOBLOCK
(
h1
k1
)
do
{
\
k1
*
=
C1
;
\
k1
=
ROTL32
(
k1
15
)
;
\
k1
*
=
C2
;
\
\
h1
^
=
k1
;
\
h1
=
ROTL32
(
h1
13
)
;
\
h1
=
h1
*
5
+
0xe6546b64
;
\
}
while
(
0
)
#
define
DOBYTES
(
cnt
h1
c
n
ptr
len
)
do
{
\
int
_i
=
cnt
;
\
while
(
_i
-
-
)
{
\
c
=
c
>
>
8
|
*
ptr
+
+
<
<
24
;
\
n
+
+
;
len
-
-
;
\
if
(
n
=
=
4
)
{
\
DOBLOCK
(
h1
c
)
;
\
n
=
0
;
\
}
\
}
}
while
(
0
)
namespace
angle
{
void
PMurHash32_Process
(
uint32_t
*
ph1
uint32_t
*
pcarry
const
void
*
key
int
len
)
{
uint32_t
h1
=
*
ph1
;
uint32_t
c
=
*
pcarry
;
const
uint8_t
*
ptr
=
(
uint8_t
*
)
key
;
const
uint8_t
*
end
;
int
n
=
c
&
3
;
#
if
defined
(
UNALIGNED_SAFE
)
int
i
=
(
4
-
n
)
&
3
;
if
(
i
&
&
i
<
=
len
)
{
DOBYTES
(
i
h1
c
n
ptr
len
)
;
}
end
=
ptr
+
len
/
4
*
4
;
for
(
;
ptr
<
end
;
ptr
+
=
4
)
{
uint32_t
k1
=
READ_UINT32
(
ptr
)
;
DOBLOCK
(
h1
k1
)
;
}
#
else
int
i
=
-
(
intptr_t
)
ptr
&
3
;
if
(
i
&
&
i
<
=
len
)
{
DOBYTES
(
i
h1
c
n
ptr
len
)
;
}
end
=
ptr
+
len
/
4
*
4
;
switch
(
n
)
{
case
0
:
for
(
;
ptr
<
end
;
ptr
+
=
4
)
{
uint32_t
k1
=
READ_UINT32
(
ptr
)
;
DOBLOCK
(
h1
k1
)
;
}
break
;
case
1
:
for
(
;
ptr
<
end
;
ptr
+
=
4
)
{
uint32_t
k1
=
c
>
>
24
;
c
=
READ_UINT32
(
ptr
)
;
k1
|
=
c
<
<
8
;
DOBLOCK
(
h1
k1
)
;
}
break
;
case
2
:
for
(
;
ptr
<
end
;
ptr
+
=
4
)
{
uint32_t
k1
=
c
>
>
16
;
c
=
READ_UINT32
(
ptr
)
;
k1
|
=
c
<
<
16
;
DOBLOCK
(
h1
k1
)
;
}
break
;
case
3
:
for
(
;
ptr
<
end
;
ptr
+
=
4
)
{
uint32_t
k1
=
c
>
>
8
;
c
=
READ_UINT32
(
ptr
)
;
k1
|
=
c
<
<
24
;
DOBLOCK
(
h1
k1
)
;
}
}
#
endif
len
-
=
len
/
4
*
4
;
DOBYTES
(
len
h1
c
n
ptr
len
)
;
*
ph1
=
h1
;
*
pcarry
=
(
c
&
~
0xff
)
|
n
;
}
uint32_t
PMurHash32_Result
(
uint32_t
h
uint32_t
carry
uint32_t
total_length
)
{
uint32_t
k1
;
int
n
=
carry
&
3
;
if
(
n
)
{
k1
=
carry
>
>
(
4
-
n
)
*
8
;
k1
*
=
C1
;
k1
=
ROTL32
(
k1
15
)
;
k1
*
=
C2
;
h
^
=
k1
;
}
h
^
=
total_length
;
h
^
=
h
>
>
16
;
h
*
=
0x85ebca6b
;
h
^
=
h
>
>
13
;
h
*
=
0xc2b2ae35
;
h
^
=
h
>
>
16
;
return
h
;
}
uint32_t
PMurHash32
(
uint32_t
seed
const
void
*
key
int
len
)
{
uint32_t
h1
=
seed
carry
=
0
;
PMurHash32_Process
(
&
h1
&
carry
key
len
)
;
return
PMurHash32_Result
(
h1
carry
len
)
;
}
void
PMurHash32_test
(
const
void
*
key
int
len
uint32_t
seed
void
*
out
)
{
uint32_t
h1
=
seed
carry
=
0
;
const
uint8_t
*
ptr
=
(
uint8_t
*
)
key
;
const
uint8_t
*
end
=
ptr
+
len
;
#
if
0
while
(
ptr
<
end
)
{
const
uint8_t
*
mid
=
ptr
+
(
rand
(
)
&
0xF
)
;
mid
=
mid
<
end
?
mid
:
end
;
PMurHash32_Process
(
&
h1
&
carry
ptr
mid
-
ptr
)
;
ptr
=
mid
;
}
#
else
PMurHash32_Process
(
&
h1
&
carry
ptr
(
int
)
(
end
-
ptr
)
)
;
#
endif
h1
=
PMurHash32_Result
(
h1
carry
len
)
;
*
(
uint32_t
*
)
out
=
h1
;
}
}
