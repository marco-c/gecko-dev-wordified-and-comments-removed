#
ifndef
ANGLEBASE_NUMERICS_SAFE_MATH_H_
#
define
ANGLEBASE_NUMERICS_SAFE_MATH_H_
#
include
<
stddef
.
h
>
#
include
<
limits
>
#
include
<
type_traits
>
#
include
"
anglebase
/
logging
.
h
"
#
include
"
anglebase
/
numerics
/
safe_math_impl
.
h
"
namespace
angle
{
namespace
base
{
namespace
internal
{
template
<
typename
T
>
class
CheckedNumeric
{
static_assert
(
std
:
:
is_arithmetic
<
T
>
:
:
value
"
CheckedNumeric
<
T
>
:
T
must
be
a
numeric
type
.
"
)
;
public
:
typedef
T
type
;
CheckedNumeric
(
)
{
}
template
<
typename
Src
>
CheckedNumeric
(
const
CheckedNumeric
<
Src
>
&
rhs
)
:
state_
(
rhs
.
ValueUnsafe
(
)
rhs
.
validity
(
)
)
{
}
template
<
typename
Src
>
CheckedNumeric
(
Src
value
RangeConstraint
validity
)
:
state_
(
value
validity
)
{
}
template
<
typename
Src
>
CheckedNumeric
(
Src
value
)
:
state_
(
value
)
{
static_assert
(
std
:
:
numeric_limits
<
Src
>
:
:
is_specialized
"
Argument
must
be
numeric
.
"
)
;
}
template
<
typename
Src
>
CheckedNumeric
(
StrictNumeric
<
Src
>
value
)
:
state_
(
static_cast
<
Src
>
(
value
)
)
{
}
bool
IsValid
(
)
const
{
return
validity
(
)
=
=
RANGE_VALID
;
}
template
<
typename
Dst
>
constexpr
bool
AssignIfValid
(
Dst
*
result
)
const
{
return
IsValid
(
)
?
(
(
*
result
=
static_cast
<
Dst
>
(
state_
.
value
(
)
)
)
true
)
:
false
;
}
T
ValueOrDie
(
)
const
{
CHECK
(
IsValid
(
)
)
;
return
state_
.
value
(
)
;
}
T
ValueOrDefault
(
T
default_value
)
const
{
return
IsValid
(
)
?
state_
.
value
(
)
:
default_value
;
}
T
ValueFloating
(
)
const
{
static_assert
(
std
:
:
numeric_limits
<
T
>
:
:
is_iec559
"
Argument
must
be
float
.
"
)
;
return
CheckedNumeric
<
T
>
:
:
cast
(
*
this
)
.
ValueUnsafe
(
)
;
}
RangeConstraint
validity
(
)
const
{
return
state_
.
validity
(
)
;
}
T
ValueUnsafe
(
)
const
{
return
state_
.
value
(
)
;
}
template
<
typename
Src
>
CheckedNumeric
&
operator
+
=
(
Src
rhs
)
;
template
<
typename
Src
>
CheckedNumeric
&
operator
-
=
(
Src
rhs
)
;
template
<
typename
Src
>
CheckedNumeric
&
operator
*
=
(
Src
rhs
)
;
template
<
typename
Src
>
CheckedNumeric
&
operator
/
=
(
Src
rhs
)
;
template
<
typename
Src
>
CheckedNumeric
&
operator
%
=
(
Src
rhs
)
;
CheckedNumeric
operator
-
(
)
const
{
RangeConstraint
validity
;
T
value
=
CheckedNeg
(
state_
.
value
(
)
&
validity
)
;
if
(
std
:
:
numeric_limits
<
T
>
:
:
is_iec559
)
return
CheckedNumeric
<
T
>
(
value
)
;
validity
=
GetRangeConstraint
(
state_
.
validity
(
)
|
validity
)
;
return
CheckedNumeric
<
T
>
(
value
validity
)
;
}
CheckedNumeric
Abs
(
)
const
{
RangeConstraint
validity
;
T
value
=
CheckedAbs
(
state_
.
value
(
)
&
validity
)
;
if
(
std
:
:
numeric_limits
<
T
>
:
:
is_iec559
)
return
CheckedNumeric
<
T
>
(
value
)
;
validity
=
GetRangeConstraint
(
state_
.
validity
(
)
|
validity
)
;
return
CheckedNumeric
<
T
>
(
value
validity
)
;
}
CheckedNumeric
<
typename
UnsignedOrFloatForSize
<
T
>
:
:
type
>
UnsignedAbs
(
)
const
{
return
CheckedNumeric
<
typename
UnsignedOrFloatForSize
<
T
>
:
:
type
>
(
CheckedUnsignedAbs
(
state_
.
value
(
)
)
state_
.
validity
(
)
)
;
}
CheckedNumeric
&
operator
+
+
(
)
{
*
this
+
=
1
;
return
*
this
;
}
CheckedNumeric
operator
+
+
(
int
)
{
CheckedNumeric
value
=
*
this
;
*
this
+
=
1
;
return
value
;
}
CheckedNumeric
&
operator
-
-
(
)
{
*
this
-
=
1
;
return
*
this
;
}
CheckedNumeric
operator
-
-
(
int
)
{
CheckedNumeric
value
=
*
this
;
*
this
-
=
1
;
return
value
;
}
template
<
typename
Src
>
static
CheckedNumeric
<
T
>
cast
(
Src
u
typename
std
:
:
enable_if
<
std
:
:
numeric_limits
<
Src
>
:
:
is_specialized
int
>
:
:
type
=
0
)
{
return
u
;
}
template
<
typename
Src
>
static
CheckedNumeric
<
T
>
cast
(
const
CheckedNumeric
<
Src
>
&
u
typename
std
:
:
enable_if
<
!
std
:
:
is_same
<
Src
T
>
:
:
value
int
>
:
:
type
=
0
)
{
return
u
;
}
static
const
CheckedNumeric
<
T
>
&
cast
(
const
CheckedNumeric
<
T
>
&
u
)
{
return
u
;
}
private
:
template
<
typename
NumericType
>
struct
UnderlyingType
{
using
type
=
NumericType
;
}
;
template
<
typename
NumericType
>
struct
UnderlyingType
<
CheckedNumeric
<
NumericType
>
>
{
using
type
=
NumericType
;
}
;
CheckedNumericState
<
T
>
state_
;
}
;
#
define
ANGLEBASE_NUMERIC_ARITHMETIC_OPERATORS
(
NAME
OP
COMPOUND_OP
)
\
template
<
typename
T
>
\
CheckedNumeric
<
typename
ArithmeticPromotion
<
T
>
:
:
type
>
operator
OP
(
\
const
CheckedNumeric
<
T
>
&
lhs
const
CheckedNumeric
<
T
>
&
rhs
)
\
{
\
typedef
typename
ArithmeticPromotion
<
T
>
:
:
type
Promotion
;
\
/
*
Floating
point
always
takes
the
fast
path
*
/
\
if
(
std
:
:
numeric_limits
<
T
>
:
:
is_iec559
)
\
return
CheckedNumeric
<
T
>
(
lhs
.
ValueUnsafe
(
)
OP
rhs
.
ValueUnsafe
(
)
)
;
\
if
(
IsIntegerArithmeticSafe
<
Promotion
T
T
>
:
:
value
)
\
return
CheckedNumeric
<
Promotion
>
(
lhs
.
ValueUnsafe
(
)
OP
rhs
.
ValueUnsafe
(
)
\
GetRangeConstraint
(
rhs
.
validity
(
)
|
lhs
.
validity
(
)
)
)
;
\
RangeConstraint
validity
=
RANGE_VALID
;
\
T
result
=
\
static_cast
<
T
>
(
Checked
#
#
NAME
(
static_cast
<
Promotion
>
(
lhs
.
ValueUnsafe
(
)
)
\
static_cast
<
Promotion
>
(
rhs
.
ValueUnsafe
(
)
)
&
validity
)
)
;
\
return
CheckedNumeric
<
Promotion
>
(
\
result
GetRangeConstraint
(
validity
|
lhs
.
validity
(
)
|
rhs
.
validity
(
)
)
)
;
\
}
\
/
*
Assignment
arithmetic
operator
implementation
from
CheckedNumeric
.
*
/
\
template
<
typename
T
>
\
template
<
typename
Src
>
\
CheckedNumeric
<
T
>
&
CheckedNumeric
<
T
>
:
:
operator
COMPOUND_OP
(
Src
rhs
)
\
{
\
*
this
=
CheckedNumeric
<
T
>
:
:
cast
(
*
this
)
\
OP
CheckedNumeric
<
typename
UnderlyingType
<
Src
>
:
:
type
>
:
:
cast
(
rhs
)
;
\
return
*
this
;
\
}
\
/
*
Binary
arithmetic
operator
for
CheckedNumeric
of
different
type
.
*
/
\
template
<
typename
T
typename
Src
>
\
CheckedNumeric
<
typename
ArithmeticPromotion
<
T
Src
>
:
:
type
>
operator
OP
(
\
const
CheckedNumeric
<
Src
>
&
lhs
const
CheckedNumeric
<
T
>
&
rhs
)
\
{
\
typedef
typename
ArithmeticPromotion
<
T
Src
>
:
:
type
Promotion
;
\
if
(
IsIntegerArithmeticSafe
<
Promotion
T
Src
>
:
:
value
)
\
return
CheckedNumeric
<
Promotion
>
(
lhs
.
ValueUnsafe
(
)
OP
rhs
.
ValueUnsafe
(
)
\
GetRangeConstraint
(
rhs
.
validity
(
)
|
lhs
.
validity
(
)
)
)
;
\
return
CheckedNumeric
<
Promotion
>
:
:
cast
(
lhs
)
OP
CheckedNumeric
<
Promotion
>
:
:
cast
(
rhs
)
;
\
}
\
/
*
Binary
arithmetic
operator
for
left
CheckedNumeric
and
right
numeric
.
*
/
\
template
<
typename
T
typename
Src
\
typename
std
:
:
enable_if
<
std
:
:
is_arithmetic
<
Src
>
:
:
value
>
:
:
type
*
=
nullptr
>
\
CheckedNumeric
<
typename
ArithmeticPromotion
<
T
Src
>
:
:
type
>
operator
OP
(
\
const
CheckedNumeric
<
T
>
&
lhs
Src
rhs
)
\
{
\
typedef
typename
ArithmeticPromotion
<
T
Src
>
:
:
type
Promotion
;
\
if
(
IsIntegerArithmeticSafe
<
Promotion
T
Src
>
:
:
value
)
\
return
CheckedNumeric
<
Promotion
>
(
lhs
.
ValueUnsafe
(
)
OP
rhs
lhs
.
validity
(
)
)
;
\
return
CheckedNumeric
<
Promotion
>
:
:
cast
(
lhs
)
OP
CheckedNumeric
<
Promotion
>
:
:
cast
(
rhs
)
;
\
}
\
/
*
Binary
arithmetic
operator
for
left
numeric
and
right
CheckedNumeric
.
*
/
\
template
<
typename
T
typename
Src
\
typename
std
:
:
enable_if
<
std
:
:
is_arithmetic
<
Src
>
:
:
value
>
:
:
type
*
=
nullptr
>
\
CheckedNumeric
<
typename
ArithmeticPromotion
<
T
Src
>
:
:
type
>
operator
OP
(
\
Src
lhs
const
CheckedNumeric
<
T
>
&
rhs
)
\
{
\
typedef
typename
ArithmeticPromotion
<
T
Src
>
:
:
type
Promotion
;
\
if
(
IsIntegerArithmeticSafe
<
Promotion
T
Src
>
:
:
value
)
\
return
CheckedNumeric
<
Promotion
>
(
lhs
OP
rhs
.
ValueUnsafe
(
)
rhs
.
validity
(
)
)
;
\
return
CheckedNumeric
<
Promotion
>
:
:
cast
(
lhs
)
OP
CheckedNumeric
<
Promotion
>
:
:
cast
(
rhs
)
;
\
}
ANGLEBASE_NUMERIC_ARITHMETIC_OPERATORS
(
Add
+
+
=
)
ANGLEBASE_NUMERIC_ARITHMETIC_OPERATORS
(
Sub
-
-
=
)
ANGLEBASE_NUMERIC_ARITHMETIC_OPERATORS
(
Mul
*
*
=
)
ANGLEBASE_NUMERIC_ARITHMETIC_OPERATORS
(
Div
/
/
=
)
ANGLEBASE_NUMERIC_ARITHMETIC_OPERATORS
(
Mod
%
%
=
)
#
undef
ANGLEBASE_NUMERIC_ARITHMETIC_OPERATORS
}
using
internal
:
:
CheckedNumeric
;
}
}
#
endif
