#
ifndef
ANGLEBASE_CONTAINERS_MRU_CACHE_H_
#
define
ANGLEBASE_CONTAINERS_MRU_CACHE_H_
#
include
<
stddef
.
h
>
#
include
<
algorithm
>
#
include
<
functional
>
#
include
<
list
>
#
include
<
map
>
#
include
<
unordered_map
>
#
include
<
utility
>
#
include
"
anglebase
/
logging
.
h
"
#
include
"
anglebase
/
macros
.
h
"
namespace
angle
{
namespace
base
{
template
<
class
KeyType
class
ValueType
class
CompareType
>
struct
MRUCacheStandardMap
{
typedef
std
:
:
map
<
KeyType
ValueType
CompareType
>
Type
;
}
;
template
<
class
KeyType
class
PayloadType
class
HashOrCompareType
template
<
typename
typename
typename
>
class
MapType
=
MRUCacheStandardMap
>
class
MRUCacheBase
{
public
:
typedef
std
:
:
pair
<
KeyType
PayloadType
>
value_type
;
private
:
typedef
std
:
:
list
<
value_type
>
PayloadList
;
typedef
typename
MapType
<
KeyType
typename
PayloadList
:
:
iterator
HashOrCompareType
>
:
:
Type
KeyIndex
;
public
:
typedef
typename
PayloadList
:
:
size_type
size_type
;
typedef
typename
PayloadList
:
:
iterator
iterator
;
typedef
typename
PayloadList
:
:
const_iterator
const_iterator
;
typedef
typename
PayloadList
:
:
reverse_iterator
reverse_iterator
;
typedef
typename
PayloadList
:
:
const_reverse_iterator
const_reverse_iterator
;
enum
{
NO_AUTO_EVICT
=
0
}
;
explicit
MRUCacheBase
(
size_type
max_size
)
:
max_size_
(
max_size
)
{
}
virtual
~
MRUCacheBase
(
)
{
}
size_type
max_size
(
)
const
{
return
max_size_
;
}
template
<
typename
Payload
>
iterator
Put
(
const
KeyType
&
key
Payload
&
&
payload
)
{
typename
KeyIndex
:
:
iterator
index_iter
=
index_
.
find
(
key
)
;
if
(
index_iter
!
=
index_
.
end
(
)
)
{
Erase
(
index_iter
-
>
second
)
;
}
else
if
(
max_size_
!
=
NO_AUTO_EVICT
)
{
ShrinkToSize
(
max_size_
-
1
)
;
}
ordering_
.
emplace_front
(
key
std
:
:
forward
<
Payload
>
(
payload
)
)
;
index_
.
emplace
(
key
ordering_
.
begin
(
)
)
;
return
ordering_
.
begin
(
)
;
}
iterator
Get
(
const
KeyType
&
key
)
{
typename
KeyIndex
:
:
iterator
index_iter
=
index_
.
find
(
key
)
;
if
(
index_iter
=
=
index_
.
end
(
)
)
return
end
(
)
;
typename
PayloadList
:
:
iterator
iter
=
index_iter
-
>
second
;
ordering_
.
splice
(
ordering_
.
begin
(
)
ordering_
iter
)
;
return
ordering_
.
begin
(
)
;
}
iterator
Peek
(
const
KeyType
&
key
)
{
typename
KeyIndex
:
:
const_iterator
index_iter
=
index_
.
find
(
key
)
;
if
(
index_iter
=
=
index_
.
end
(
)
)
return
end
(
)
;
return
index_iter
-
>
second
;
}
const_iterator
Peek
(
const
KeyType
&
key
)
const
{
typename
KeyIndex
:
:
const_iterator
index_iter
=
index_
.
find
(
key
)
;
if
(
index_iter
=
=
index_
.
end
(
)
)
return
end
(
)
;
return
index_iter
-
>
second
;
}
void
Swap
(
MRUCacheBase
&
other
)
{
ordering_
.
swap
(
other
.
ordering_
)
;
index_
.
swap
(
other
.
index_
)
;
std
:
:
swap
(
max_size_
other
.
max_size_
)
;
}
iterator
Erase
(
iterator
pos
)
{
index_
.
erase
(
pos
-
>
first
)
;
return
ordering_
.
erase
(
pos
)
;
}
reverse_iterator
Erase
(
reverse_iterator
pos
)
{
return
reverse_iterator
(
Erase
(
(
+
+
pos
)
.
base
(
)
)
)
;
}
void
ShrinkToSize
(
size_type
new_size
)
{
for
(
size_type
i
=
size
(
)
;
i
>
new_size
;
i
-
-
)
Erase
(
rbegin
(
)
)
;
}
void
Clear
(
)
{
index_
.
clear
(
)
;
ordering_
.
clear
(
)
;
}
size_type
size
(
)
const
{
DCHECK
(
index_
.
size
(
)
=
=
ordering_
.
size
(
)
)
;
return
index_
.
size
(
)
;
}
iterator
begin
(
)
{
return
ordering_
.
begin
(
)
;
}
const_iterator
begin
(
)
const
{
return
ordering_
.
begin
(
)
;
}
iterator
end
(
)
{
return
ordering_
.
end
(
)
;
}
const_iterator
end
(
)
const
{
return
ordering_
.
end
(
)
;
}
reverse_iterator
rbegin
(
)
{
return
ordering_
.
rbegin
(
)
;
}
const_reverse_iterator
rbegin
(
)
const
{
return
ordering_
.
rbegin
(
)
;
}
reverse_iterator
rend
(
)
{
return
ordering_
.
rend
(
)
;
}
const_reverse_iterator
rend
(
)
const
{
return
ordering_
.
rend
(
)
;
}
bool
empty
(
)
const
{
return
ordering_
.
empty
(
)
;
}
private
:
PayloadList
ordering_
;
KeyIndex
index_
;
size_type
max_size_
;
DISALLOW_COPY_AND_ASSIGN
(
MRUCacheBase
)
;
}
;
template
<
class
KeyType
class
PayloadType
class
CompareType
=
std
:
:
less
<
KeyType
>
>
class
MRUCache
:
public
MRUCacheBase
<
KeyType
PayloadType
CompareType
>
{
private
:
using
ParentType
=
MRUCacheBase
<
KeyType
PayloadType
CompareType
>
;
public
:
explicit
MRUCache
(
typename
ParentType
:
:
size_type
max_size
)
:
ParentType
(
max_size
)
{
}
virtual
~
MRUCache
(
)
{
}
private
:
DISALLOW_COPY_AND_ASSIGN
(
MRUCache
)
;
}
;
template
<
class
KeyType
class
ValueType
class
HashType
>
struct
MRUCacheHashMap
{
typedef
std
:
:
unordered_map
<
KeyType
ValueType
HashType
>
Type
;
}
;
template
<
class
KeyType
class
PayloadType
class
HashType
=
std
:
:
hash
<
KeyType
>
>
class
HashingMRUCache
:
public
MRUCacheBase
<
KeyType
PayloadType
HashType
MRUCacheHashMap
>
{
private
:
using
ParentType
=
MRUCacheBase
<
KeyType
PayloadType
HashType
MRUCacheHashMap
>
;
public
:
explicit
HashingMRUCache
(
typename
ParentType
:
:
size_type
max_size
)
:
ParentType
(
max_size
)
{
}
virtual
~
HashingMRUCache
(
)
{
}
private
:
DISALLOW_COPY_AND_ASSIGN
(
HashingMRUCache
)
;
}
;
}
}
#
endif
