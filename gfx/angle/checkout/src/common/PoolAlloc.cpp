#
include
"
common
/
PoolAlloc
.
h
"
#
include
<
assert
.
h
>
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
"
common
/
angleutils
.
h
"
#
include
"
common
/
debug
.
h
"
#
include
"
common
/
mathutil
.
h
"
#
include
"
common
/
platform
.
h
"
#
include
"
common
/
tls
.
h
"
namespace
angle
{
class
Allocation
{
public
:
Allocation
(
size_t
size
unsigned
char
*
mem
Allocation
*
prev
=
0
)
:
mSize
(
size
)
mMem
(
mem
)
mPrevAlloc
(
prev
)
{
#
if
defined
(
ANGLE_POOL_ALLOC_GUARD_BLOCKS
)
memset
(
preGuard
(
)
kGuardBlockBeginVal
kGuardBlockSize
)
;
memset
(
data
(
)
kUserDataFill
mSize
)
;
memset
(
postGuard
(
)
kGuardBlockEndVal
kGuardBlockSize
)
;
#
endif
}
void
checkAllocList
(
)
const
;
static
size_t
AlignedHeaderSize
(
uint8_t
*
allocationBasePtr
size_t
alignment
)
{
size_t
base
=
reinterpret_cast
<
size_t
>
(
allocationBasePtr
)
;
return
rx
:
:
roundUpPow2
(
base
+
kGuardBlockSize
+
HeaderSize
(
)
alignment
)
-
base
;
}
static
size_t
AllocationSize
(
uint8_t
*
allocationBasePtr
size_t
size
size_t
alignment
size_t
*
preAllocationPaddingOut
)
{
size_t
dataOffset
=
AlignedHeaderSize
(
allocationBasePtr
alignment
)
;
*
preAllocationPaddingOut
=
dataOffset
-
HeaderSize
(
)
-
kGuardBlockSize
;
return
dataOffset
+
size
+
kGuardBlockSize
;
}
static
uint8_t
*
GetDataPointer
(
uint8_t
*
memory
size_t
alignment
)
{
uint8_t
*
alignedPtr
=
memory
+
kGuardBlockSize
+
HeaderSize
(
)
;
ASSERT
(
(
reinterpret_cast
<
uintptr_t
>
(
alignedPtr
)
&
(
alignment
-
1
)
)
=
=
0
)
;
return
alignedPtr
;
}
private
:
void
checkGuardBlock
(
unsigned
char
*
blockMem
unsigned
char
val
const
char
*
locText
)
const
;
void
checkAlloc
(
)
const
{
checkGuardBlock
(
preGuard
(
)
kGuardBlockBeginVal
"
before
"
)
;
checkGuardBlock
(
postGuard
(
)
kGuardBlockEndVal
"
after
"
)
;
}
unsigned
char
*
preGuard
(
)
const
{
return
mMem
+
HeaderSize
(
)
;
}
unsigned
char
*
data
(
)
const
{
return
preGuard
(
)
+
kGuardBlockSize
;
}
unsigned
char
*
postGuard
(
)
const
{
return
data
(
)
+
mSize
;
}
size_t
mSize
;
unsigned
char
*
mMem
;
Allocation
*
mPrevAlloc
;
static
constexpr
unsigned
char
kGuardBlockBeginVal
=
0xfb
;
static
constexpr
unsigned
char
kGuardBlockEndVal
=
0xfe
;
static
constexpr
unsigned
char
kUserDataFill
=
0xcd
;
#
if
defined
(
ANGLE_POOL_ALLOC_GUARD_BLOCKS
)
static
constexpr
size_t
kGuardBlockSize
=
16
;
static
constexpr
size_t
HeaderSize
(
)
{
return
sizeof
(
Allocation
)
;
}
#
else
static
constexpr
size_t
kGuardBlockSize
=
0
;
static
constexpr
size_t
HeaderSize
(
)
{
return
0
;
}
#
endif
}
;
#
if
!
defined
(
ANGLE_DISABLE_POOL_ALLOC
)
class
PageHeader
{
public
:
PageHeader
(
PageHeader
*
nextPage
size_t
pageCount
)
:
nextPage
(
nextPage
)
pageCount
(
pageCount
)
#
if
defined
(
ANGLE_POOL_ALLOC_GUARD_BLOCKS
)
lastAllocation
(
nullptr
)
#
endif
{
}
~
PageHeader
(
)
{
#
if
defined
(
ANGLE_POOL_ALLOC_GUARD_BLOCKS
)
if
(
lastAllocation
)
{
lastAllocation
-
>
checkAllocList
(
)
;
}
#
endif
}
PageHeader
*
nextPage
;
size_t
pageCount
;
#
if
defined
(
ANGLE_POOL_ALLOC_GUARD_BLOCKS
)
Allocation
*
lastAllocation
;
#
endif
}
;
#
endif
PoolAllocator
:
:
PoolAllocator
(
int
growthIncrement
int
allocationAlignment
)
:
mAlignment
(
allocationAlignment
)
#
if
!
defined
(
ANGLE_DISABLE_POOL_ALLOC
)
mPageSize
(
growthIncrement
)
mFreeList
(
nullptr
)
mInUseList
(
nullptr
)
mNumCalls
(
0
)
mTotalBytes
(
0
)
#
endif
mLocked
(
false
)
{
initialize
(
growthIncrement
allocationAlignment
)
;
}
void
PoolAllocator
:
:
initialize
(
int
pageSize
int
alignment
)
{
mAlignment
=
alignment
;
#
if
!
defined
(
ANGLE_DISABLE_POOL_ALLOC
)
mPageSize
=
pageSize
;
mPageHeaderSkip
=
sizeof
(
PageHeader
)
;
if
(
mAlignment
!
=
1
)
{
#
endif
size_t
minAlign
=
sizeof
(
void
*
)
;
if
(
mAlignment
<
minAlign
)
{
mAlignment
=
minAlign
;
}
mAlignment
=
gl
:
:
ceilPow2
(
static_cast
<
unsigned
int
>
(
mAlignment
)
)
;
#
if
!
defined
(
ANGLE_DISABLE_POOL_ALLOC
)
}
if
(
mPageSize
<
4
*
1024
)
{
mPageSize
=
4
*
1024
;
}
mCurrentPageOffset
=
mPageSize
;
#
else
mStack
.
push_back
(
{
}
)
;
#
endif
}
PoolAllocator
:
:
~
PoolAllocator
(
)
{
#
if
!
defined
(
ANGLE_DISABLE_POOL_ALLOC
)
while
(
mInUseList
)
{
PageHeader
*
next
=
mInUseList
-
>
nextPage
;
mInUseList
-
>
~
PageHeader
(
)
;
delete
[
]
reinterpret_cast
<
char
*
>
(
mInUseList
)
;
mInUseList
=
next
;
}
while
(
mFreeList
)
{
PageHeader
*
next
=
mFreeList
-
>
nextPage
;
delete
[
]
reinterpret_cast
<
char
*
>
(
mFreeList
)
;
mFreeList
=
next
;
}
#
else
for
(
auto
&
allocs
:
mStack
)
{
for
(
auto
alloc
:
allocs
)
{
free
(
alloc
)
;
}
}
mStack
.
clear
(
)
;
#
endif
}
void
Allocation
:
:
checkGuardBlock
(
unsigned
char
*
blockMem
unsigned
char
val
const
char
*
locText
)
const
{
#
if
defined
(
ANGLE_POOL_ALLOC_GUARD_BLOCKS
)
for
(
size_t
x
=
0
;
x
<
kGuardBlockSize
;
x
+
+
)
{
if
(
blockMem
[
x
]
!
=
val
)
{
char
assertMsg
[
80
]
;
snprintf
(
assertMsg
sizeof
(
assertMsg
)
"
PoolAlloc
:
Damage
%
s
%
zu
byte
allocation
at
0x
%
p
\
n
"
locText
mSize
data
(
)
)
;
assert
(
0
&
&
"
PoolAlloc
:
Damage
in
guard
block
"
)
;
}
}
#
endif
}
void
PoolAllocator
:
:
push
(
)
{
#
if
!
defined
(
ANGLE_DISABLE_POOL_ALLOC
)
AllocState
state
=
{
mCurrentPageOffset
mInUseList
}
;
mStack
.
push_back
(
state
)
;
mCurrentPageOffset
=
mPageSize
;
#
else
mStack
.
push_back
(
{
}
)
;
#
endif
}
void
PoolAllocator
:
:
pop
(
)
{
if
(
mStack
.
size
(
)
<
1
)
{
return
;
}
#
if
!
defined
(
ANGLE_DISABLE_POOL_ALLOC
)
PageHeader
*
page
=
mStack
.
back
(
)
.
page
;
mCurrentPageOffset
=
mStack
.
back
(
)
.
offset
;
while
(
mInUseList
!
=
page
)
{
mInUseList
-
>
~
PageHeader
(
)
;
PageHeader
*
nextInUse
=
mInUseList
-
>
nextPage
;
if
(
mInUseList
-
>
pageCount
>
1
)
{
delete
[
]
reinterpret_cast
<
char
*
>
(
mInUseList
)
;
}
else
{
mInUseList
-
>
nextPage
=
mFreeList
;
mFreeList
=
mInUseList
;
}
mInUseList
=
nextInUse
;
}
mStack
.
pop_back
(
)
;
#
else
for
(
auto
&
alloc
:
mStack
.
back
(
)
)
{
free
(
alloc
)
;
}
mStack
.
pop_back
(
)
;
#
endif
}
void
PoolAllocator
:
:
popAll
(
)
{
while
(
mStack
.
size
(
)
>
0
)
pop
(
)
;
}
void
*
PoolAllocator
:
:
allocate
(
size_t
numBytes
)
{
ASSERT
(
!
mLocked
)
;
#
if
!
defined
(
ANGLE_DISABLE_POOL_ALLOC
)
+
+
mNumCalls
;
mTotalBytes
+
=
numBytes
;
uint8_t
*
currentPagePtr
=
reinterpret_cast
<
uint8_t
*
>
(
mInUseList
)
+
mCurrentPageOffset
;
size_t
preAllocationPadding
=
0
;
size_t
allocationSize
=
Allocation
:
:
AllocationSize
(
currentPagePtr
numBytes
mAlignment
&
preAllocationPadding
)
;
ASSERT
(
allocationSize
>
=
numBytes
)
;
if
(
allocationSize
<
=
mPageSize
-
mCurrentPageOffset
)
{
uint8_t
*
memory
=
currentPagePtr
+
preAllocationPadding
;
mCurrentPageOffset
+
=
allocationSize
;
return
initializeAllocation
(
memory
numBytes
)
;
}
if
(
allocationSize
>
mPageSize
-
mPageHeaderSkip
)
{
allocationSize
=
Allocation
:
:
AllocationSize
(
reinterpret_cast
<
uint8_t
*
>
(
mPageHeaderSkip
)
numBytes
mAlignment
&
preAllocationPadding
)
;
size_t
numBytesToAlloc
=
allocationSize
+
mPageHeaderSkip
+
mAlignment
;
ASSERT
(
numBytesToAlloc
>
=
allocationSize
)
;
PageHeader
*
memory
=
reinterpret_cast
<
PageHeader
*
>
(
:
:
new
char
[
numBytesToAlloc
]
)
;
if
(
memory
=
=
nullptr
)
{
return
nullptr
;
}
new
(
memory
)
PageHeader
(
mInUseList
(
numBytesToAlloc
+
mPageSize
-
1
)
/
mPageSize
)
;
mInUseList
=
memory
;
mCurrentPageOffset
=
mPageSize
;
currentPagePtr
=
reinterpret_cast
<
uint8_t
*
>
(
memory
)
+
mPageHeaderSkip
;
Allocation
:
:
AllocationSize
(
currentPagePtr
numBytes
mAlignment
&
preAllocationPadding
)
;
return
initializeAllocation
(
currentPagePtr
+
preAllocationPadding
numBytes
)
;
}
uint8_t
*
newPageAddr
=
allocateNewPage
(
numBytes
)
;
return
initializeAllocation
(
newPageAddr
numBytes
)
;
#
else
void
*
alloc
=
malloc
(
numBytes
+
mAlignment
-
1
)
;
mStack
.
back
(
)
.
push_back
(
alloc
)
;
intptr_t
intAlloc
=
reinterpret_cast
<
intptr_t
>
(
alloc
)
;
intAlloc
=
rx
:
:
roundUpPow2
<
intptr_t
>
(
intAlloc
mAlignment
)
;
return
reinterpret_cast
<
void
*
>
(
intAlloc
)
;
#
endif
}
#
if
!
defined
(
ANGLE_DISABLE_POOL_ALLOC
)
uint8_t
*
PoolAllocator
:
:
allocateNewPage
(
size_t
numBytes
)
{
PageHeader
*
memory
;
if
(
mFreeList
)
{
memory
=
mFreeList
;
mFreeList
=
mFreeList
-
>
nextPage
;
}
else
{
memory
=
reinterpret_cast
<
PageHeader
*
>
(
:
:
new
char
[
mPageSize
]
)
;
if
(
memory
=
=
nullptr
)
{
return
nullptr
;
}
}
new
(
memory
)
PageHeader
(
mInUseList
1
)
;
mInUseList
=
memory
;
mCurrentPageOffset
=
mPageHeaderSkip
;
uint8_t
*
currentPagePtr
=
reinterpret_cast
<
uint8_t
*
>
(
mInUseList
)
+
mCurrentPageOffset
;
size_t
preAllocationPadding
=
0
;
size_t
allocationSize
=
Allocation
:
:
AllocationSize
(
currentPagePtr
numBytes
mAlignment
&
preAllocationPadding
)
;
mCurrentPageOffset
+
=
allocationSize
;
return
reinterpret_cast
<
uint8_t
*
>
(
mInUseList
)
+
mPageHeaderSkip
+
preAllocationPadding
;
}
void
*
PoolAllocator
:
:
initializeAllocation
(
uint8_t
*
memory
size_t
numBytes
)
{
#
if
defined
(
ANGLE_POOL_ALLOC_GUARD_BLOCKS
)
new
(
memory
)
Allocation
(
numBytes
memory
mInUseList
-
>
lastAllocation
)
;
mInUseList
-
>
lastAllocation
=
reinterpret_cast
<
Allocation
*
>
(
memory
)
;
#
endif
return
Allocation
:
:
GetDataPointer
(
memory
mAlignment
)
;
}
#
endif
void
PoolAllocator
:
:
lock
(
)
{
ASSERT
(
!
mLocked
)
;
mLocked
=
true
;
}
void
PoolAllocator
:
:
unlock
(
)
{
ASSERT
(
mLocked
)
;
mLocked
=
false
;
}
void
Allocation
:
:
checkAllocList
(
)
const
{
for
(
const
Allocation
*
alloc
=
this
;
alloc
!
=
nullptr
;
alloc
=
alloc
-
>
mPrevAlloc
)
{
alloc
-
>
checkAlloc
(
)
;
}
}
}
