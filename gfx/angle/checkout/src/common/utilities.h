#
ifndef
COMMON_UTILITIES_H_
#
define
COMMON_UTILITIES_H_
#
include
<
EGL
/
egl
.
h
>
#
include
<
EGL
/
eglext
.
h
>
#
include
<
math
.
h
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
angle_gl
.
h
"
#
include
"
common
/
mathutil
.
h
"
namespace
sh
{
struct
ShaderVariable
;
}
namespace
gl
{
int
VariableComponentCount
(
GLenum
type
)
;
GLenum
VariableComponentType
(
GLenum
type
)
;
size_t
VariableComponentSize
(
GLenum
type
)
;
size_t
VariableInternalSize
(
GLenum
type
)
;
size_t
VariableExternalSize
(
GLenum
type
)
;
int
VariableRowCount
(
GLenum
type
)
;
int
VariableColumnCount
(
GLenum
type
)
;
bool
IsSamplerType
(
GLenum
type
)
;
bool
IsImageType
(
GLenum
type
)
;
bool
IsAtomicCounterType
(
GLenum
type
)
;
bool
IsOpaqueType
(
GLenum
type
)
;
GLenum
SamplerTypeToTextureType
(
GLenum
samplerType
)
;
bool
IsMatrixType
(
GLenum
type
)
;
GLenum
TransposeMatrixType
(
GLenum
type
)
;
int
VariableRegisterCount
(
GLenum
type
)
;
int
MatrixRegisterCount
(
GLenum
type
bool
isRowMajorMatrix
)
;
int
MatrixComponentCount
(
GLenum
type
bool
isRowMajorMatrix
)
;
int
VariableSortOrder
(
GLenum
type
)
;
GLenum
VariableBoolVectorType
(
GLenum
type
)
;
int
AllocateFirstFreeBits
(
unsigned
int
*
bits
unsigned
int
allocationSize
unsigned
int
bitsSize
)
;
static
const
GLenum
FirstCubeMapTextureTarget
=
GL_TEXTURE_CUBE_MAP_POSITIVE_X
;
static
const
GLenum
LastCubeMapTextureTarget
=
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
;
bool
IsCubeMapTextureTarget
(
GLenum
target
)
;
size_t
CubeMapTextureTargetToLayerIndex
(
GLenum
target
)
;
GLenum
LayerIndexToCubeMapTextureTarget
(
size_t
index
)
;
std
:
:
string
ParseResourceName
(
const
std
:
:
string
&
name
std
:
:
vector
<
unsigned
int
>
*
outSubscripts
)
;
const
sh
:
:
ShaderVariable
*
FindShaderVarField
(
const
sh
:
:
ShaderVariable
&
var
const
std
:
:
string
&
fullName
)
;
IndexRange
ComputeIndexRange
(
GLenum
indexType
const
GLvoid
*
indices
size_t
count
bool
primitiveRestartEnabled
)
;
GLuint
GetPrimitiveRestartIndex
(
GLenum
indexType
)
;
bool
IsTriangleMode
(
GLenum
drawMode
)
;
bool
IsIntegerFormat
(
GLenum
unsizedFormat
)
;
unsigned
int
ArraySizeProduct
(
const
std
:
:
vector
<
unsigned
int
>
&
arraySizes
)
;
unsigned
int
ParseArrayIndex
(
const
std
:
:
string
&
name
size_t
*
nameLengthWithoutArrayIndexOut
)
;
struct
UniformTypeInfo
final
:
angle
:
:
NonCopyable
{
constexpr
UniformTypeInfo
(
GLenum
type
GLenum
componentType
GLenum
textureType
GLenum
transposedMatrixType
GLenum
boolVectorType
int
rowCount
int
columnCount
int
componentCount
size_t
componentSize
size_t
internalSize
size_t
externalSize
bool
isSampler
bool
isMatrixType
bool
isImageType
)
:
type
(
type
)
componentType
(
componentType
)
textureType
(
textureType
)
transposedMatrixType
(
transposedMatrixType
)
boolVectorType
(
boolVectorType
)
rowCount
(
rowCount
)
columnCount
(
columnCount
)
componentCount
(
componentCount
)
componentSize
(
componentSize
)
internalSize
(
internalSize
)
externalSize
(
externalSize
)
isSampler
(
isSampler
)
isMatrixType
(
isMatrixType
)
isImageType
(
isImageType
)
{
}
GLenum
type
;
GLenum
componentType
;
GLenum
textureType
;
GLenum
transposedMatrixType
;
GLenum
boolVectorType
;
int
rowCount
;
int
columnCount
;
int
componentCount
;
size_t
componentSize
;
size_t
internalSize
;
size_t
externalSize
;
bool
isSampler
;
bool
isMatrixType
;
bool
isImageType
;
}
;
const
UniformTypeInfo
&
GetUniformTypeInfo
(
GLenum
uniformType
)
;
const
char
*
GetGenericErrorMessage
(
GLenum
error
)
;
unsigned
int
ElementTypeSize
(
GLenum
elementType
)
;
}
namespace
egl
{
static
const
EGLenum
FirstCubeMapTextureTarget
=
EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X_KHR
;
static
const
EGLenum
LastCubeMapTextureTarget
=
EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_KHR
;
bool
IsCubeMapTextureTarget
(
EGLenum
target
)
;
size_t
CubeMapTextureTargetToLayerIndex
(
EGLenum
target
)
;
EGLenum
LayerIndexToCubeMapTextureTarget
(
size_t
index
)
;
bool
IsTextureTarget
(
EGLenum
target
)
;
bool
IsRenderbufferTarget
(
EGLenum
target
)
;
const
char
*
GetGenericErrorMessage
(
EGLint
error
)
;
}
namespace
egl_gl
{
GLenum
EGLCubeMapTargetToGLCubeMapTarget
(
EGLenum
eglTarget
)
;
GLenum
EGLImageTargetToGLTextureTarget
(
EGLenum
eglTarget
)
;
GLenum
EGLTextureTargetToGLTextureTarget
(
EGLenum
eglTarget
)
;
GLuint
EGLClientBufferToGLObjectHandle
(
EGLClientBuffer
buffer
)
;
}
namespace
gl_egl
{
EGLenum
GLComponentTypeToEGLColorComponentType
(
GLenum
glComponentType
)
;
}
#
if
!
defined
(
ANGLE_ENABLE_WINDOWS_STORE
)
std
:
:
string
getTempPath
(
)
;
void
writeFile
(
const
char
*
path
const
void
*
data
size_t
size
)
;
#
endif
#
if
defined
(
ANGLE_PLATFORM_WINDOWS
)
void
ScheduleYield
(
)
;
#
endif
#
endif
