#
ifndef
COMMON_POOLALLOC_H_
#
define
COMMON_POOLALLOC_H_
#
if
!
defined
(
NDEBUG
)
#
define
ANGLE_POOL_ALLOC_GUARD_BLOCKS
#
endif
#
include
"
angleutils
.
h
"
#
include
"
common
/
debug
.
h
"
namespace
angle
{
class
Allocation
;
class
PageHeader
;
class
PoolAllocator
:
angle
:
:
NonCopyable
{
public
:
static
const
int
kDefaultAlignment
=
sizeof
(
void
*
)
;
PoolAllocator
(
int
growthIncrement
=
8
*
1024
int
allocationAlignment
=
kDefaultAlignment
)
;
~
PoolAllocator
(
)
;
void
initialize
(
int
pageSize
int
alignment
)
;
void
push
(
)
;
void
pop
(
)
;
void
popAll
(
)
;
void
*
allocate
(
size_t
numBytes
)
;
ANGLE_INLINE
uint8_t
*
fastAllocate
(
size_t
numBytes
)
{
#
if
defined
(
ANGLE_DISABLE_POOL_ALLOC
)
return
reinterpret_cast
<
uint8_t
*
>
(
allocate
(
numBytes
)
)
;
#
else
ASSERT
(
mAlignment
=
=
1
)
;
ASSERT
(
numBytes
<
=
(
mPageSize
-
mPageHeaderSkip
)
)
;
if
(
numBytes
<
=
mPageSize
-
mCurrentPageOffset
)
{
uint8_t
*
memory
=
reinterpret_cast
<
uint8_t
*
>
(
mInUseList
)
+
mCurrentPageOffset
;
mCurrentPageOffset
+
=
numBytes
;
return
memory
;
}
return
allocateNewPage
(
numBytes
)
;
#
endif
}
void
lock
(
)
;
void
unlock
(
)
;
private
:
size_t
mAlignment
;
#
if
!
defined
(
ANGLE_DISABLE_POOL_ALLOC
)
struct
AllocState
{
size_t
offset
;
PageHeader
*
page
;
}
;
using
AllocStack
=
std
:
:
vector
<
AllocState
>
;
uint8_t
*
allocateNewPage
(
size_t
numBytes
)
;
void
*
initializeAllocation
(
uint8_t
*
memory
size_t
numBytes
)
;
size_t
mPageSize
;
size_t
mPageHeaderSkip
;
size_t
mCurrentPageOffset
;
PageHeader
*
mFreeList
;
PageHeader
*
mInUseList
;
AllocStack
mStack
;
int
mNumCalls
;
size_t
mTotalBytes
;
#
else
std
:
:
vector
<
std
:
:
vector
<
void
*
>
>
mStack
;
#
endif
bool
mLocked
;
}
;
}
#
endif
