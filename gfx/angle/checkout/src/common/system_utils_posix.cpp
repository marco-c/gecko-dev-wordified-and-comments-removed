#
include
"
system_utils
.
h
"
#
include
<
array
>
#
include
<
dlfcn
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
wait
.
h
>
#
include
<
unistd
.
h
>
namespace
angle
{
namespace
{
struct
ScopedPipe
{
~
ScopedPipe
(
)
{
closeEndPoint
(
0
)
;
closeEndPoint
(
1
)
;
}
void
closeEndPoint
(
int
index
)
{
if
(
fds
[
index
]
>
=
0
)
{
close
(
fds
[
index
]
)
;
fds
[
index
]
=
-
1
;
}
}
int
fds
[
2
]
=
{
-
1
-
1
}
;
}
;
void
ReadEntireFile
(
int
fd
std
:
:
string
*
out
)
{
out
-
>
clear
(
)
;
while
(
true
)
{
char
buffer
[
256
]
;
ssize_t
bytesRead
=
read
(
fd
buffer
sizeof
(
buffer
)
)
;
if
(
bytesRead
<
0
&
&
errno
=
=
EINTR
)
{
continue
;
}
if
(
bytesRead
<
=
0
)
{
break
;
}
out
-
>
append
(
buffer
bytesRead
)
;
}
}
}
Optional
<
std
:
:
string
>
GetCWD
(
)
{
std
:
:
array
<
char
4096
>
pathBuf
;
char
*
result
=
getcwd
(
pathBuf
.
data
(
)
pathBuf
.
size
(
)
)
;
if
(
result
=
=
nullptr
)
{
return
Optional
<
std
:
:
string
>
:
:
Invalid
(
)
;
}
return
std
:
:
string
(
pathBuf
.
data
(
)
)
;
}
bool
SetCWD
(
const
char
*
dirName
)
{
return
(
chdir
(
dirName
)
=
=
0
)
;
}
bool
UnsetEnvironmentVar
(
const
char
*
variableName
)
{
return
(
unsetenv
(
variableName
)
=
=
0
)
;
}
bool
SetEnvironmentVar
(
const
char
*
variableName
const
char
*
value
)
{
return
(
setenv
(
variableName
value
1
)
=
=
0
)
;
}
std
:
:
string
GetEnvironmentVar
(
const
char
*
variableName
)
{
const
char
*
value
=
getenv
(
variableName
)
;
return
(
value
=
=
nullptr
?
std
:
:
string
(
)
:
std
:
:
string
(
value
)
)
;
}
const
char
*
GetPathSeparator
(
)
{
return
"
:
"
;
}
bool
RunApp
(
const
std
:
:
vector
<
const
char
*
>
&
args
std
:
:
string
*
stdoutOut
std
:
:
string
*
stderrOut
int
*
exitCodeOut
)
{
if
(
args
.
size
(
)
=
=
0
|
|
args
.
back
(
)
!
=
nullptr
)
{
return
false
;
}
ScopedPipe
stdoutPipe
;
ScopedPipe
stderrPipe
;
if
(
stdoutOut
&
&
pipe
(
stdoutPipe
.
fds
)
!
=
0
)
{
return
false
;
}
if
(
stderrOut
&
&
pipe
(
stderrPipe
.
fds
)
!
=
0
)
{
return
false
;
}
pid_t
pid
=
fork
(
)
;
if
(
pid
<
0
)
{
return
false
;
}
if
(
pid
=
=
0
)
{
if
(
stdoutOut
)
{
if
(
dup2
(
stdoutPipe
.
fds
[
1
]
STDOUT_FILENO
)
<
0
)
{
_exit
(
errno
)
;
}
}
if
(
stderrOut
)
{
if
(
dup2
(
stderrPipe
.
fds
[
1
]
STDERR_FILENO
)
<
0
)
{
_exit
(
errno
)
;
}
}
execv
(
args
[
0
]
const_cast
<
char
*
const
*
>
(
args
.
data
(
)
)
)
;
_exit
(
errno
)
;
}
stdoutPipe
.
closeEndPoint
(
1
)
;
stderrPipe
.
closeEndPoint
(
1
)
;
if
(
stdoutOut
)
{
ReadEntireFile
(
stdoutPipe
.
fds
[
0
]
stdoutOut
)
;
}
if
(
stderrOut
)
{
ReadEntireFile
(
stderrPipe
.
fds
[
0
]
stderrOut
)
;
}
int
status
=
0
;
do
{
pid_t
changedPid
=
waitpid
(
pid
&
status
0
)
;
if
(
changedPid
<
0
&
&
errno
=
=
EINTR
)
{
continue
;
}
if
(
changedPid
<
0
)
{
return
false
;
}
}
while
(
!
WIFEXITED
(
status
)
&
&
!
WIFSIGNALED
(
status
)
)
;
if
(
exitCodeOut
)
{
*
exitCodeOut
=
WEXITSTATUS
(
status
)
;
}
return
true
;
}
class
PosixLibrary
:
public
Library
{
public
:
PosixLibrary
(
const
char
*
libraryName
)
{
char
buffer
[
1000
]
;
int
ret
=
snprintf
(
buffer
1000
"
%
s
.
%
s
"
libraryName
GetSharedLibraryExtension
(
)
)
;
if
(
ret
>
0
&
&
ret
<
1000
)
{
mModule
=
dlopen
(
buffer
RTLD_NOW
)
;
}
}
~
PosixLibrary
(
)
override
{
if
(
mModule
)
{
dlclose
(
mModule
)
;
}
}
void
*
getSymbol
(
const
char
*
symbolName
)
override
{
if
(
!
mModule
)
{
return
nullptr
;
}
return
dlsym
(
mModule
symbolName
)
;
}
void
*
getNative
(
)
const
override
{
return
mModule
;
}
private
:
void
*
mModule
=
nullptr
;
}
;
Library
*
OpenSharedLibrary
(
const
char
*
libraryName
SearchType
searchType
)
{
return
new
PosixLibrary
(
libraryName
)
;
}
bool
IsDirectory
(
const
char
*
filename
)
{
struct
stat
st
;
int
result
=
stat
(
filename
&
st
)
;
return
result
=
=
0
&
&
(
(
st
.
st_mode
&
S_IFDIR
)
=
=
S_IFDIR
)
;
}
bool
IsDebuggerAttached
(
)
{
return
false
;
}
void
BreakDebugger
(
)
{
abort
(
)
;
}
}
