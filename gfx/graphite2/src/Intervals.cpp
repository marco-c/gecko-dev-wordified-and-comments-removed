#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
limits
>
#
include
"
inc
/
Intervals
.
h
"
#
include
"
inc
/
Segment
.
h
"
#
include
"
inc
/
Slot
.
h
"
#
include
"
inc
/
debug
.
h
"
#
include
"
inc
/
bits
.
h
"
using
namespace
graphite2
;
#
include
<
cmath
>
inline
Zones
:
:
Exclusion
Zones
:
:
Exclusion
:
:
split_at
(
float
p
)
{
Exclusion
r
(
*
this
)
;
r
.
xm
=
x
=
p
;
return
r
;
}
inline
void
Zones
:
:
Exclusion
:
:
left_trim
(
float
p
)
{
x
=
p
;
}
inline
Zones
:
:
Exclusion
&
Zones
:
:
Exclusion
:
:
operator
+
=
(
Exclusion
const
&
rhs
)
{
c
+
=
rhs
.
c
;
sm
+
=
rhs
.
sm
;
smx
+
=
rhs
.
smx
;
open
=
false
;
return
*
this
;
}
inline
uint8
Zones
:
:
Exclusion
:
:
outcode
(
float
val
)
const
{
float
p
=
val
;
return
(
(
p
>
=
xm
)
<
<
1
)
|
(
p
<
x
)
;
}
void
Zones
:
:
exclude_with_margins
(
float
xmin
float
xmax
int
axis
)
{
remove
(
xmin
xmax
)
;
weightedAxis
(
axis
xmin
-
_margin_len
xmin
0
0
_margin_weight
xmin
-
_margin_len
0
0
false
)
;
weightedAxis
(
axis
xmax
xmax
+
_margin_len
0
0
_margin_weight
xmax
+
_margin_len
0
0
false
)
;
}
namespace
{
inline
bool
separated
(
float
a
float
b
)
{
return
a
!
=
b
;
}
}
void
Zones
:
:
insert
(
Exclusion
e
)
{
#
if
!
defined
GRAPHITE2_NTRACING
addDebug
(
&
e
)
;
#
endif
e
.
x
=
std
:
:
max
(
e
.
x
_pos
)
;
e
.
xm
=
std
:
:
min
(
e
.
xm
_posm
)
;
if
(
e
.
x
>
=
e
.
xm
)
return
;
for
(
iterator
i
=
_exclusions
.
begin
(
)
ie
=
_exclusions
.
end
(
)
;
i
!
=
ie
&
&
e
.
x
<
e
.
xm
;
+
+
i
)
{
const
uint8
oca
=
e
.
outcode
(
i
-
>
x
)
ocb
=
e
.
outcode
(
i
-
>
xm
)
;
if
(
(
oca
&
ocb
)
!
=
0
)
continue
;
switch
(
oca
^
ocb
)
{
case
0
:
*
i
+
=
e
;
e
.
left_trim
(
i
-
>
xm
)
;
break
;
case
1
:
if
(
!
separated
(
i
-
>
xm
e
.
x
)
)
break
;
if
(
separated
(
i
-
>
x
e
.
x
)
)
{
i
=
_exclusions
.
insert
(
i
i
-
>
split_at
(
e
.
x
)
)
;
+
+
i
;
}
*
i
+
=
e
;
e
.
left_trim
(
i
-
>
xm
)
;
break
;
case
2
:
if
(
!
separated
(
e
.
xm
i
-
>
x
)
)
return
;
if
(
separated
(
e
.
xm
i
-
>
xm
)
)
i
=
_exclusions
.
insert
(
i
i
-
>
split_at
(
e
.
xm
)
)
;
*
i
+
=
e
;
return
;
case
3
:
if
(
separated
(
e
.
xm
i
-
>
xm
)
)
i
=
_exclusions
.
insert
(
i
i
-
>
split_at
(
e
.
xm
)
)
;
i
=
_exclusions
.
insert
(
i
i
-
>
split_at
(
e
.
x
)
)
;
*
+
+
i
+
=
e
;
return
;
}
ie
=
_exclusions
.
end
(
)
;
}
}
void
Zones
:
:
remove
(
float
x
float
xm
)
{
#
if
!
defined
GRAPHITE2_NTRACING
removeDebug
(
x
xm
)
;
#
endif
x
=
std
:
:
max
(
x
_pos
)
;
xm
=
std
:
:
min
(
xm
_posm
)
;
if
(
x
>
=
xm
)
return
;
for
(
iterator
i
=
_exclusions
.
begin
(
)
ie
=
_exclusions
.
end
(
)
;
i
!
=
ie
;
+
+
i
)
{
const
uint8
oca
=
i
-
>
outcode
(
x
)
ocb
=
i
-
>
outcode
(
xm
)
;
if
(
(
oca
&
ocb
)
!
=
0
)
continue
;
switch
(
oca
^
ocb
)
{
case
0
:
if
(
separated
(
i
-
>
x
x
)
)
{
i
=
_exclusions
.
insert
(
i
i
-
>
split_at
(
x
)
)
;
+
+
i
;
}
case
1
:
i
-
>
left_trim
(
xm
)
;
return
;
case
2
:
i
-
>
xm
=
x
;
if
(
separated
(
i
-
>
x
i
-
>
xm
)
)
break
;
case
3
:
i
=
_exclusions
.
erase
(
i
)
;
-
-
i
;
break
;
}
ie
=
_exclusions
.
end
(
)
;
}
}
Zones
:
:
const_iterator
Zones
:
:
find_exclusion_under
(
float
x
)
const
{
int
l
=
0
h
=
_exclusions
.
size
(
)
;
while
(
l
<
h
)
{
int
const
p
=
(
l
+
h
)
>
>
1
;
switch
(
_exclusions
[
p
]
.
outcode
(
x
)
)
{
case
0
:
return
_exclusions
.
begin
(
)
+
p
;
case
1
:
h
=
p
;
break
;
case
2
:
case
3
:
l
=
p
+
1
;
break
;
}
}
return
_exclusions
.
begin
(
)
+
l
;
}
float
Zones
:
:
closest
(
float
origin
float
&
cost
)
const
{
float
best_c
=
std
:
:
numeric_limits
<
float
>
:
:
max
(
)
best_x
=
0
;
const
const_iterator
start
=
find_exclusion_under
(
origin
)
;
for
(
const_iterator
i
=
start
ie
=
_exclusions
.
end
(
)
;
i
!
=
ie
;
+
+
i
)
if
(
i
-
>
track_cost
(
best_c
best_x
origin
)
)
break
;
for
(
const_iterator
i
=
start
-
1
ie
=
_exclusions
.
begin
(
)
-
1
;
i
!
=
ie
;
-
-
i
)
if
(
i
-
>
track_cost
(
best_c
best_x
origin
)
)
break
;
cost
=
(
best_c
=
=
std
:
:
numeric_limits
<
float
>
:
:
max
(
)
?
-
1
:
best_c
)
;
return
best_x
;
}
bool
Zones
:
:
Exclusion
:
:
track_cost
(
float
&
best_cost
float
&
best_pos
float
origin
)
const
{
const
float
p
=
test_position
(
origin
)
localc
=
cost
(
p
-
origin
)
;
if
(
open
&
&
localc
>
best_cost
)
return
true
;
if
(
localc
<
best_cost
)
{
best_cost
=
localc
;
best_pos
=
p
;
}
return
false
;
}
inline
float
Zones
:
:
Exclusion
:
:
cost
(
float
p
)
const
{
return
(
sm
*
p
-
2
*
smx
)
*
p
+
c
;
}
float
Zones
:
:
Exclusion
:
:
test_position
(
float
origin
)
const
{
if
(
sm
<
0
)
{
float
res
=
x
;
float
cl
=
cost
(
x
)
;
if
(
x
<
origin
&
&
xm
>
origin
)
{
float
co
=
cost
(
origin
)
;
if
(
co
<
cl
)
{
cl
=
co
;
res
=
origin
;
}
}
float
cr
=
cost
(
xm
)
;
return
cl
>
cr
?
xm
:
res
;
}
else
{
float
zerox
=
smx
/
sm
+
origin
;
if
(
zerox
<
x
)
return
x
;
else
if
(
zerox
>
xm
)
return
xm
;
else
return
zerox
;
}
}
#
if
!
defined
GRAPHITE2_NTRACING
void
Zones
:
:
jsonDbgOut
(
Segment
*
seg
)
const
{
if
(
_dbg
)
{
for
(
Zones
:
:
idebugs
s
=
dbgs_begin
(
)
e
=
dbgs_end
(
)
;
s
!
=
e
;
+
+
s
)
{
*
_dbg
<
<
json
:
:
flat
<
<
json
:
:
array
<
<
objectid
(
dslot
(
seg
(
Slot
*
)
(
s
-
>
_env
[
0
]
)
)
)
<
<
reinterpret_cast
<
ptrdiff_t
>
(
s
-
>
_env
[
1
]
)
;
if
(
s
-
>
_isdel
)
*
_dbg
<
<
"
remove
"
<
<
Position
(
s
-
>
_excl
.
x
s
-
>
_excl
.
xm
)
;
else
*
_dbg
<
<
"
exclude
"
<
<
json
:
:
flat
<
<
json
:
:
array
<
<
s
-
>
_excl
.
x
<
<
s
-
>
_excl
.
xm
<
<
s
-
>
_excl
.
sm
<
<
s
-
>
_excl
.
smx
<
<
s
-
>
_excl
.
c
<
<
json
:
:
close
;
*
_dbg
<
<
json
:
:
close
;
}
}
}
#
endif
