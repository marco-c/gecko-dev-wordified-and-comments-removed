#
include
<
cassert
>
#
include
"
inc
/
Decompressor
.
h
"
#
include
"
inc
/
Shrinker
.
h
"
using
namespace
shrinker
;
namespace
{
u8
const
LONG_DIST
=
0x10
;
u8
const
MATCH_LEN
=
0x0f
;
template
<
int
M
>
inline
u32
read_literal
(
u8
const
*
&
s
u8
const
*
const
e
u32
l
)
{
if
(
unlikely
(
l
=
=
M
)
)
{
u8
b
=
0
;
do
{
l
+
=
b
=
*
s
+
+
;
}
while
(
b
=
=
0xff
&
&
s
!
=
e
)
;
}
return
l
;
}
bool
read_directive
(
u8
const
*
&
src
u8
const
*
const
end
u32
&
literal_len
u32
&
match_len
u32
&
match_dist
)
{
u8
const
flag
=
*
src
+
+
;
literal_len
=
read_literal
<
7
>
(
src
end
flag
>
>
5
)
;
match_len
=
read_literal
<
15
>
(
src
end
flag
&
MATCH_LEN
)
;
match_dist
=
*
src
+
+
;
if
(
flag
&
LONG_DIST
)
match_dist
|
=
(
(
*
src
+
+
)
<
<
8
)
;
return
match_dist
!
=
0xffff
;
}
}
int
shrinker
:
:
decompress
(
void
const
*
in
size_t
in_size
void
*
out
size_t
out_size
)
{
u8
const
*
src
=
static_cast
<
u8
const
*
>
(
in
)
*
const
src_end
=
src
+
in_size
;
u8
*
dst
=
static_cast
<
u8
*
>
(
out
)
*
const
dst_end
=
dst
+
out_size
;
u32
literal_len
=
0
match_len
=
0
match_dist
=
0
;
while
(
read_directive
(
src
src_end
literal_len
match_len
match_dist
)
)
{
if
(
unlikely
(
dst
+
literal_len
+
sizeof
(
unsigned
long
)
>
dst_end
)
)
return
-
1
;
dst
=
memcpy_nooverlap
(
dst
src
literal_len
)
;
src
+
=
literal_len
;
u8
const
*
const
pcpy
=
dst
-
match_dist
-
1
;
if
(
unlikely
(
pcpy
<
static_cast
<
u8
*
>
(
out
)
|
|
dst
+
match_len
+
MINMATCH
+
sizeof
(
unsigned
long
)
>
dst_end
)
)
return
-
1
;
dst
=
memcpy_
(
dst
pcpy
match_len
+
MINMATCH
)
;
}
if
(
unlikely
(
dst
+
literal_len
>
dst_end
)
)
return
-
1
;
dst
=
memcpy_nooverlap_surpass
(
dst
src
literal_len
)
;
return
dst
-
(
u8
*
)
out
;
}
