#
include
<
cassert
>
#
include
"
inc
/
Decompressor
.
h
"
#
include
"
inc
/
Compression
.
h
"
using
namespace
lz4
;
namespace
{
inline
u32
read_literal
(
u8
const
*
&
s
u8
const
*
const
e
u32
l
)
{
if
(
l
=
=
15
&
&
s
!
=
e
)
{
u8
b
=
0
;
do
{
l
+
=
b
=
*
s
+
+
;
}
while
(
b
=
=
0xff
&
&
s
!
=
e
)
;
}
return
l
;
}
bool
read_sequence
(
u8
const
*
&
src
u8
const
*
const
end
u8
const
*
&
literal
u32
&
literal_len
u32
&
match_len
u32
&
match_dist
)
{
u8
const
token
=
*
src
+
+
;
literal_len
=
read_literal
(
src
end
token
>
>
4
)
;
literal
=
src
;
src
+
=
literal_len
;
if
(
src
>
end
-
2
)
return
false
;
match_dist
=
*
src
+
+
;
match_dist
|
=
*
src
+
+
<
<
8
;
match_len
=
read_literal
(
src
end
token
&
0xf
)
;
return
src
<
=
end
-
5
;
}
}
int
lz4
:
:
decompress
(
void
const
*
in
size_t
in_size
void
*
out
size_t
out_size
)
{
if
(
out_size
<
=
in_size
|
|
in_size
<
sizeof
(
unsigned
long
)
+
1
)
return
-
1
;
u8
const
*
src
=
static_cast
<
u8
const
*
>
(
in
)
*
literal
=
0
*
const
src_end
=
src
+
in_size
;
u8
*
dst
=
static_cast
<
u8
*
>
(
out
)
*
const
dst_end
=
dst
+
out_size
;
u32
literal_len
=
0
match_len
=
0
match_dist
=
0
;
while
(
read_sequence
(
src
src_end
literal
literal_len
match_len
match_dist
)
)
{
if
(
literal_len
!
=
0
)
{
if
(
dst
+
align
(
literal_len
)
>
dst_end
-
(
MINMATCH
+
5
)
)
return
-
1
;
dst
=
overrun_copy
(
dst
literal
literal_len
)
;
}
u8
const
*
const
pcpy
=
dst
-
match_dist
;
if
(
pcpy
<
static_cast
<
u8
*
>
(
out
)
|
|
dst
+
match_len
+
MINMATCH
>
dst_end
-
5
)
return
-
1
;
if
(
dst
>
pcpy
+
sizeof
(
unsigned
long
)
&
&
dst
+
align
(
match_len
+
MINMATCH
)
<
=
dst_end
)
dst
=
overrun_copy
(
dst
pcpy
match_len
+
MINMATCH
)
;
else
dst
=
safe_copy
(
dst
pcpy
match_len
+
MINMATCH
)
;
}
if
(
literal
+
literal_len
>
src_end
|
|
dst
+
literal_len
>
dst_end
)
return
-
1
;
dst
=
fast_copy
(
dst
literal
literal_len
)
;
return
dst
-
(
u8
*
)
out
;
}
