#
include
"
gtest
/
gtest
.
h
"
#
include
"
gmock
/
gmock
.
h
"
#
include
"
TestLayers
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Tools
.
h
"
#
include
"
mozilla
/
layers
/
BufferTexture
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxImageSurface
.
h
"
#
include
"
gfxTypes
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
mozilla
/
layers
/
ImageDataSerializer
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
namespace
mozilla
{
namespace
layers
{
static
void
SetupSurface
(
gfxImageSurface
*
surface
)
{
int
bpp
=
gfxASurface
:
:
BytePerPixelFromFormat
(
surface
-
>
Format
(
)
)
;
int
stride
=
surface
-
>
Stride
(
)
;
uint8_t
val
=
0
;
uint8_t
*
data
=
surface
-
>
Data
(
)
;
for
(
int
y
=
0
;
y
<
surface
-
>
Height
(
)
;
+
+
y
)
{
for
(
int
x
=
0
;
x
<
surface
-
>
Height
(
)
;
+
+
x
)
{
for
(
int
b
=
0
;
b
<
bpp
;
+
+
b
)
{
data
[
y
*
stride
+
x
*
bpp
+
b
]
=
val
;
if
(
val
=
=
100
)
{
val
=
0
;
}
else
{
+
+
val
;
}
}
}
}
}
static
void
AssertSurfacesEqual
(
gfxImageSurface
*
surface1
gfxImageSurface
*
surface2
)
{
ASSERT_EQ
(
surface1
-
>
GetSize
(
)
surface2
-
>
GetSize
(
)
)
;
ASSERT_EQ
(
surface1
-
>
Format
(
)
surface2
-
>
Format
(
)
)
;
uint8_t
*
data1
=
surface1
-
>
Data
(
)
;
uint8_t
*
data2
=
surface2
-
>
Data
(
)
;
int
stride1
=
surface1
-
>
Stride
(
)
;
int
stride2
=
surface2
-
>
Stride
(
)
;
int
bpp
=
gfxASurface
:
:
BytePerPixelFromFormat
(
surface1
-
>
Format
(
)
)
;
for
(
int
y
=
0
;
y
<
surface1
-
>
Height
(
)
;
+
+
y
)
{
for
(
int
x
=
0
;
x
<
surface1
-
>
Width
(
)
;
+
+
x
)
{
for
(
int
b
=
0
;
b
<
bpp
;
+
+
b
)
{
ASSERT_EQ
(
data1
[
y
*
stride1
+
x
*
bpp
+
b
]
data2
[
y
*
stride2
+
x
*
bpp
+
b
]
)
;
}
}
}
}
static
void
AssertSurfacesEqual
(
SourceSurface
*
surface1
SourceSurface
*
surface2
)
{
ASSERT_EQ
(
surface1
-
>
GetSize
(
)
surface2
-
>
GetSize
(
)
)
;
ASSERT_EQ
(
surface1
-
>
GetFormat
(
)
surface2
-
>
GetFormat
(
)
)
;
RefPtr
<
DataSourceSurface
>
dataSurface1
=
surface1
-
>
GetDataSurface
(
)
;
RefPtr
<
DataSourceSurface
>
dataSurface2
=
surface2
-
>
GetDataSurface
(
)
;
DataSourceSurface
:
:
MappedSurface
map1
;
DataSourceSurface
:
:
MappedSurface
map2
;
if
(
!
dataSurface1
-
>
Map
(
DataSourceSurface
:
:
READ
&
map1
)
)
{
return
;
}
if
(
!
dataSurface2
-
>
Map
(
DataSourceSurface
:
:
READ
&
map2
)
)
{
dataSurface1
-
>
Unmap
(
)
;
return
;
}
uint8_t
*
data1
=
map1
.
mData
;
uint8_t
*
data2
=
map2
.
mData
;
int
stride1
=
map1
.
mStride
;
int
stride2
=
map2
.
mStride
;
int
bpp
=
BytesPerPixel
(
surface1
-
>
GetFormat
(
)
)
;
int
width
=
surface1
-
>
GetSize
(
)
.
width
;
int
height
=
surface1
-
>
GetSize
(
)
.
height
;
for
(
int
y
=
0
;
y
<
height
;
+
+
y
)
{
for
(
int
x
=
0
;
x
<
width
;
+
+
x
)
{
for
(
int
b
=
0
;
b
<
bpp
;
+
+
b
)
{
ASSERT_EQ
(
data1
[
y
*
stride1
+
x
*
bpp
+
b
]
data2
[
y
*
stride2
+
x
*
bpp
+
b
]
)
;
}
}
}
dataSurface1
-
>
Unmap
(
)
;
dataSurface2
-
>
Unmap
(
)
;
}
void
TestTextureClientSurface
(
TextureClient
*
texture
gfxImageSurface
*
surface
)
{
ASSERT_TRUE
(
texture
-
>
CanExposeDrawTarget
(
)
)
;
ASSERT_TRUE
(
texture
-
>
Lock
(
OpenMode
:
:
OPEN_READ_WRITE
)
)
;
RefPtr
<
DrawTarget
>
dt
=
texture
-
>
BorrowDrawTarget
(
)
;
RefPtr
<
SourceSurface
>
source
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetSourceSurfaceForSurface
(
dt
surface
)
;
dt
-
>
CopySurface
(
source
IntRect
(
IntPoint
(
)
source
-
>
GetSize
(
)
)
IntPoint
(
)
)
;
RefPtr
<
SourceSurface
>
snapshot
=
dt
-
>
Snapshot
(
)
;
AssertSurfacesEqual
(
snapshot
source
)
;
dt
=
nullptr
;
texture
-
>
Unlock
(
)
;
SurfaceDescriptor
descriptor
;
ASSERT_TRUE
(
texture
-
>
ToSurfaceDescriptor
(
descriptor
)
)
;
ASSERT_NE
(
descriptor
.
type
(
)
SurfaceDescriptor
:
:
Tnull_t
)
;
RefPtr
<
TestSurfaceAllocator
>
deallocator
=
new
TestSurfaceAllocator
(
)
;
RefPtr
<
TextureHost
>
host
=
CreateBackendIndependentTextureHost
(
descriptor
deallocator
LayersBackend
:
:
LAYERS_NONE
texture
-
>
GetFlags
(
)
)
;
ASSERT_TRUE
(
host
.
get
(
)
!
=
nullptr
)
;
ASSERT_EQ
(
host
-
>
GetFlags
(
)
texture
-
>
GetFlags
(
)
)
;
if
(
host
-
>
Lock
(
)
)
{
RefPtr
<
mozilla
:
:
gfx
:
:
DataSourceSurface
>
hostDataSurface
=
host
-
>
GetAsSurface
(
)
;
DataSourceSurface
:
:
ScopedMap
map
(
hostDataSurface
DataSourceSurface
:
:
READ
)
;
RefPtr
<
gfxImageSurface
>
hostSurface
=
new
gfxImageSurface
(
map
.
GetData
(
)
hostDataSurface
-
>
GetSize
(
)
map
.
GetStride
(
)
SurfaceFormatToImageFormat
(
hostDataSurface
-
>
GetFormat
(
)
)
)
;
AssertSurfacesEqual
(
surface
hostSurface
.
get
(
)
)
;
host
-
>
Unlock
(
)
;
}
}
void
TestTextureClientYCbCr
(
TextureClient
*
client
PlanarYCbCrData
&
ycbcrData
)
{
client
-
>
Lock
(
OpenMode
:
:
OPEN_READ_WRITE
)
;
UpdateYCbCrTextureClient
(
client
ycbcrData
)
;
client
-
>
Unlock
(
)
;
SurfaceDescriptor
descriptor
;
ASSERT_TRUE
(
client
-
>
ToSurfaceDescriptor
(
descriptor
)
)
;
ASSERT_EQ
(
descriptor
.
type
(
)
SurfaceDescriptor
:
:
TSurfaceDescriptorBuffer
)
;
auto
bufferDesc
=
descriptor
.
get_SurfaceDescriptorBuffer
(
)
;
ASSERT_EQ
(
bufferDesc
.
desc
(
)
.
type
(
)
BufferDescriptor
:
:
TYCbCrDescriptor
)
;
auto
ycbcrDesc
=
bufferDesc
.
desc
(
)
.
get_YCbCrDescriptor
(
)
;
ASSERT_EQ
(
ycbcrDesc
.
ySize
(
)
ycbcrData
.
mYSize
)
;
ASSERT_EQ
(
ycbcrDesc
.
cbCrSize
(
)
ycbcrData
.
mCbCrSize
)
;
ASSERT_EQ
(
ycbcrDesc
.
stereoMode
(
)
ycbcrData
.
mStereoMode
)
;
RefPtr
<
TestSurfaceAllocator
>
deallocator
=
new
TestSurfaceAllocator
(
)
;
RefPtr
<
TextureHost
>
textureHost
=
CreateBackendIndependentTextureHost
(
descriptor
deallocator
LayersBackend
:
:
LAYERS_NONE
client
-
>
GetFlags
(
)
)
;
RefPtr
<
BufferTextureHost
>
host
=
static_cast
<
BufferTextureHost
*
>
(
textureHost
.
get
(
)
)
;
ASSERT_TRUE
(
host
.
get
(
)
!
=
nullptr
)
;
ASSERT_EQ
(
host
-
>
GetFlags
(
)
client
-
>
GetFlags
(
)
)
;
if
(
host
-
>
Lock
(
)
)
{
ASSERT_EQ
(
host
-
>
GetFormat
(
)
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
YUV
)
;
host
-
>
Unlock
(
)
;
}
}
}
}
TEST
(
Layers
TextureSerialization
)
{
gfxImageFormat
formats
[
3
]
=
{
SurfaceFormat
:
:
A8R8G8B8_UINT32
SurfaceFormat
:
:
X8R8G8B8_UINT32
SurfaceFormat
:
:
A8
}
;
for
(
int
f
=
0
;
f
<
3
;
+
+
f
)
{
RefPtr
<
gfxImageSurface
>
surface
=
new
gfxImageSurface
(
IntSize
(
400
300
)
formats
[
f
]
)
;
SetupSurface
(
surface
.
get
(
)
)
;
AssertSurfacesEqual
(
surface
surface
)
;
auto
texData
=
BufferTextureData
:
:
Create
(
surface
-
>
GetSize
(
)
gfx
:
:
ImageFormatToSurfaceFormat
(
surface
-
>
Format
(
)
)
gfx
:
:
BackendType
:
:
CAIRO
LayersBackend
:
:
LAYERS_NONE
TextureFlags
:
:
DEALLOCATE_CLIENT
ALLOC_DEFAULT
nullptr
)
;
ASSERT_TRUE
(
!
!
texData
)
;
RefPtr
<
TextureClient
>
client
=
new
TextureClient
(
texData
TextureFlags
:
:
DEALLOCATE_CLIENT
nullptr
)
;
TestTextureClientSurface
(
client
surface
)
;
}
}
TEST
(
Layers
TextureYCbCrSerialization
)
{
RefPtr
<
gfxImageSurface
>
ySurface
=
new
gfxImageSurface
(
IntSize
(
400
300
)
SurfaceFormat
:
:
A8
)
;
RefPtr
<
gfxImageSurface
>
cbSurface
=
new
gfxImageSurface
(
IntSize
(
200
150
)
SurfaceFormat
:
:
A8
)
;
RefPtr
<
gfxImageSurface
>
crSurface
=
new
gfxImageSurface
(
IntSize
(
200
150
)
SurfaceFormat
:
:
A8
)
;
SetupSurface
(
ySurface
.
get
(
)
)
;
SetupSurface
(
cbSurface
.
get
(
)
)
;
SetupSurface
(
crSurface
.
get
(
)
)
;
PlanarYCbCrData
clientData
;
clientData
.
mYChannel
=
ySurface
-
>
Data
(
)
;
clientData
.
mCbChannel
=
cbSurface
-
>
Data
(
)
;
clientData
.
mCrChannel
=
crSurface
-
>
Data
(
)
;
clientData
.
mYSize
=
ySurface
-
>
GetSize
(
)
;
clientData
.
mPicSize
=
ySurface
-
>
GetSize
(
)
;
clientData
.
mCbCrSize
=
cbSurface
-
>
GetSize
(
)
;
clientData
.
mYStride
=
ySurface
-
>
Stride
(
)
;
clientData
.
mCbCrStride
=
cbSurface
-
>
Stride
(
)
;
clientData
.
mStereoMode
=
StereoMode
:
:
MONO
;
clientData
.
mYUVColorSpace
=
YUVColorSpace
:
:
BT601
;
clientData
.
mColorDepth
=
ColorDepth
:
:
COLOR_8
;
clientData
.
mYSkip
=
0
;
clientData
.
mCbSkip
=
0
;
clientData
.
mCrSkip
=
0
;
clientData
.
mCrSkip
=
0
;
clientData
.
mPicX
=
0
;
clientData
.
mPicX
=
0
;
uint32_t
namespaceId
=
1
;
ImageBridgeChild
:
:
InitSameProcess
(
namespaceId
)
;
RefPtr
<
ImageBridgeChild
>
imageBridge
=
ImageBridgeChild
:
:
GetSingleton
(
)
;
static
int
retry
=
5
;
while
(
!
imageBridge
-
>
IPCOpen
(
)
&
&
retry
)
{
#
ifdef
XP_WIN
Sleep
(
1
)
;
#
else
sleep
(
1
)
;
#
endif
retry
-
-
;
}
if
(
!
retry
&
&
!
imageBridge
-
>
IPCOpen
(
)
)
{
return
;
}
RefPtr
<
TextureClient
>
client
=
TextureClient
:
:
CreateForYCbCr
(
imageBridge
clientData
.
mYSize
clientData
.
mYStride
clientData
.
mCbCrSize
clientData
.
mCbCrStride
StereoMode
:
:
MONO
gfx
:
:
ColorDepth
:
:
COLOR_8
YUVColorSpace
:
:
BT601
TextureFlags
:
:
DEALLOCATE_CLIENT
)
;
TestTextureClientYCbCr
(
client
clientData
)
;
}
