#
include
"
PolygonTestUtils
.
h
"
#
include
<
cmath
>
typedef
mozilla
:
:
gfx
:
:
Polygon
MozPolygon
;
namespace
mozilla
{
namespace
gfx
{
const
float
kEpsilon
=
0
.
001f
;
bool
FuzzyEquals
(
const
Point4D
&
lhs
const
Point4D
&
rhs
)
{
const
auto
d
=
lhs
-
rhs
;
return
std
:
:
abs
(
d
.
x
)
<
kEpsilon
&
&
std
:
:
abs
(
d
.
y
)
<
kEpsilon
&
&
std
:
:
abs
(
d
.
z
)
<
kEpsilon
&
&
std
:
:
abs
(
d
.
w
)
<
kEpsilon
;
}
bool
FuzzyEquals
(
const
Point3D
&
lhs
const
Point3D
&
rhs
)
{
const
auto
d
=
lhs
-
rhs
;
return
std
:
:
abs
(
d
.
x
)
<
kEpsilon
&
&
std
:
:
abs
(
d
.
y
)
<
kEpsilon
&
&
std
:
:
abs
(
d
.
z
)
<
kEpsilon
;
}
bool
FuzzyEquals
(
const
Point
&
lhs
const
Point
&
rhs
)
{
const
auto
d
=
lhs
-
rhs
;
return
std
:
:
abs
(
d
.
x
)
<
kEpsilon
&
&
std
:
:
abs
(
d
.
y
)
<
kEpsilon
;
}
bool
operator
=
=
(
const
Triangle
&
lhs
const
Triangle
&
rhs
)
{
return
FuzzyEquals
(
lhs
.
p1
rhs
.
p1
)
&
&
FuzzyEquals
(
lhs
.
p2
rhs
.
p2
)
&
&
FuzzyEquals
(
lhs
.
p3
rhs
.
p3
)
;
}
bool
operator
=
=
(
const
MozPolygon
&
lhs
const
MozPolygon
&
rhs
)
{
const
auto
&
left
=
lhs
.
GetPoints
(
)
;
const
auto
&
right
=
rhs
.
GetPoints
(
)
;
if
(
left
.
Length
(
)
!
=
right
.
Length
(
)
)
{
return
false
;
}
const
size_t
pointCount
=
left
.
Length
(
)
;
int
start
=
-
1
;
for
(
size_t
i
=
0
;
i
<
pointCount
;
+
+
i
)
{
if
(
FuzzyEquals
(
left
[
0
]
right
[
i
]
)
)
{
start
=
i
;
break
;
}
}
if
(
start
=
=
-
1
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
pointCount
;
+
+
i
)
{
size_t
j
=
(
start
+
i
)
%
pointCount
;
if
(
!
FuzzyEquals
(
left
[
i
]
right
[
j
]
)
)
{
return
false
;
}
}
return
true
;
}
}
}
TEST
(
PolygonTestUtils
TestSanity
)
{
EXPECT_TRUE
(
FuzzyEquals
(
Point4D
(
0
.
0f
0
.
0f
0
.
0f
1
.
0f
)
Point4D
(
0
.
0f
0
.
0f
0
.
0f
1
.
0f
)
)
)
;
EXPECT_TRUE
(
FuzzyEquals
(
Point4D
(
0
.
0f
0
.
0f
0
.
0f
1
.
0f
)
Point4D
(
0
.
00001f
0
.
00001f
0
.
00001f
1
.
0f
)
)
)
;
EXPECT_TRUE
(
FuzzyEquals
(
Point4D
(
0
.
00001f
0
.
00001f
0
.
00001f
1
.
0f
)
Point4D
(
0
.
0f
0
.
0f
0
.
0f
1
.
0f
)
)
)
;
EXPECT_FALSE
(
FuzzyEquals
(
Point4D
(
0
.
0f
0
.
0f
0
.
0f
1
.
0f
)
Point4D
(
0
.
01f
0
.
01f
0
.
01f
1
.
0f
)
)
)
;
EXPECT_FALSE
(
FuzzyEquals
(
Point4D
(
0
.
01f
0
.
01f
0
.
01f
1
.
0f
)
Point4D
(
0
.
0f
0
.
0f
0
.
0f
1
.
0f
)
)
)
;
MozPolygon
p1
{
Point4D
(
0
.
0f
0
.
0f
1
.
0f
1
.
0f
)
Point4D
(
1
.
0f
0
.
0f
1
.
0f
1
.
0f
)
Point4D
(
1
.
0f
1
.
0f
1
.
0f
1
.
0f
)
Point4D
(
0
.
0f
1
.
0f
1
.
0f
1
.
0f
)
}
;
MozPolygon
shifted
{
Point4D
(
0
.
0f
1
.
0f
1
.
0f
1
.
0f
)
Point4D
(
0
.
0f
0
.
0f
1
.
0f
1
.
0f
)
Point4D
(
1
.
0f
0
.
0f
1
.
0f
1
.
0f
)
Point4D
(
1
.
0f
1
.
0f
1
.
0f
1
.
0f
)
}
;
MozPolygon
p2
{
Point4D
(
0
.
00001f
0
.
00001f
1
.
00001f
1
.
0f
)
Point4D
(
1
.
00001f
0
.
00001f
1
.
00001f
1
.
0f
)
Point4D
(
1
.
00001f
1
.
00001f
1
.
00001f
1
.
0f
)
Point4D
(
0
.
00001f
1
.
00001f
1
.
00001f
1
.
0f
)
}
;
MozPolygon
p3
{
Point4D
(
0
.
01f
0
.
01f
1
.
01f
1
.
0f
)
Point4D
(
1
.
01f
0
.
01f
1
.
01f
1
.
0f
)
Point4D
(
1
.
01f
1
.
01f
1
.
01f
1
.
0f
)
Point4D
(
0
.
01f
1
.
01f
1
.
01f
1
.
0f
)
}
;
EXPECT_TRUE
(
p1
=
=
p1
)
;
EXPECT_TRUE
(
p2
=
=
p2
)
;
EXPECT_TRUE
(
p3
=
=
p3
)
;
EXPECT_TRUE
(
shifted
=
=
shifted
)
;
EXPECT_TRUE
(
p1
=
=
p2
)
;
EXPECT_TRUE
(
p1
=
=
shifted
)
;
EXPECT_FALSE
(
p1
=
=
p3
)
;
EXPECT_FALSE
(
p2
=
=
p3
)
;
EXPECT_FALSE
(
shifted
=
=
p3
)
;
const
nsTArray
<
Triangle
>
t1
{
Triangle
(
Point
(
0
.
0f
0
.
0f
)
Point
(
0
.
0f
1
.
0f
)
Point
(
1
.
0f
1
.
0f
)
)
}
;
const
nsTArray
<
Triangle
>
t2
{
Triangle
(
Point
(
0
.
0f
0
.
0f
)
Point
(
1
.
0f
1
.
0f
)
Point
(
1
.
0f
0
.
0f
)
)
}
;
const
nsTArray
<
Triangle
>
t3
{
Triangle
(
Point
(
0
.
00001f
0
.
00001f
)
Point
(
0
.
00001f
1
.
00001f
)
Point
(
1
.
00001f
1
.
00001f
)
)
}
;
EXPECT_TRUE
(
t1
[
0
]
=
=
t1
[
0
]
)
;
EXPECT_TRUE
(
t2
[
0
]
=
=
t2
[
0
]
)
;
EXPECT_TRUE
(
t3
[
0
]
=
=
t1
[
0
]
)
;
EXPECT_FALSE
(
t1
[
0
]
=
=
t2
[
0
]
)
;
EXPECT_FALSE
(
t2
[
0
]
=
=
t3
[
0
]
)
;
AssertArrayEQ
(
t1
t1
)
;
AssertArrayEQ
(
t2
t2
)
;
}
