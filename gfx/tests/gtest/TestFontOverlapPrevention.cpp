#
include
"
gtest
/
gtest
.
h
"
#
include
<
vector
>
#
include
<
string
>
#
define
StandardFonts
#
ifdef
XP_WIN
#
include
"
.
.
/
thebes
/
StandardFonts
-
win10
.
inc
"
#
elif
defined
(
XP_MACOSX
)
#
include
"
.
.
/
thebes
/
StandardFonts
-
macos
.
inc
"
#
elif
defined
(
XP_LINUX
)
#
include
"
.
.
/
thebes
/
StandardFonts
-
linux
.
inc
"
#
elif
defined
(
XP_ANDROID
)
#
include
"
.
.
/
thebes
/
StandardFonts
-
android
.
inc
"
#
endif
#
undef
StandardFonts
std
:
:
vector
<
std
:
:
string
>
GetFontRuleNames
(
)
{
std
:
:
vector
<
std
:
:
string
>
fontRuleNames
;
#
undef
FONT_RULE
#
define
FONT_RULE
(
fontName
.
.
.
)
fontRuleNames
.
push_back
(
fontName
)
;
#
define
FontInclusionByLocaleRules
#
ifdef
XP_WIN
#
include
"
.
.
/
thebes
/
StandardFonts
-
win10
.
inc
"
#
elif
defined
(
XP_MACOSX
)
#
include
"
.
.
/
thebes
/
StandardFonts
-
macos
.
inc
"
#
elif
defined
(
XP_LINUX
)
#
include
"
.
.
/
thebes
/
StandardFonts
-
linux
.
inc
"
#
elif
defined
(
XP_ANDROID
)
#
include
"
.
.
/
thebes
/
StandardFonts
-
android
.
inc
"
#
endif
#
undef
FontInclusionByLocaleRules
#
undef
FONT_RULE
return
fontRuleNames
;
}
TEST
(
StandardFontsTest
LangPackAndFontRuleNoOverlap
)
{
std
:
:
set
<
std
:
:
string
>
langPackFonts
;
for
(
const
char
*
font
:
kLangPackFonts
)
{
langPackFonts
.
insert
(
font
)
;
}
std
:
:
vector
<
std
:
:
string
>
fontRuleNames
=
GetFontRuleNames
(
)
;
for
(
const
auto
&
font
:
fontRuleNames
)
{
auto
it
=
std
:
:
find_if
(
langPackFonts
.
begin
(
)
langPackFonts
.
end
(
)
[
&
font
]
(
const
std
:
:
string
&
langPackFont
)
{
return
std
:
:
equal
(
font
.
begin
(
)
font
.
end
(
)
langPackFont
.
begin
(
)
langPackFont
.
end
(
)
[
]
(
char
a
char
b
)
{
return
tolower
(
a
)
=
=
tolower
(
b
)
;
}
)
;
}
)
;
ASSERT_EQ
(
it
langPackFonts
.
end
(
)
)
<
<
"
Font
'
"
<
<
font
<
<
"
'
is
in
both
kLangPackFonts
and
FONT_RULE
(
case
insensitive
)
"
;
}
}
