#
include
"
gtest
/
gtest
.
h
"
#
include
"
gmock
/
gmock
.
h
"
#
include
"
mozilla
/
gfx
/
TaskScheduler
.
h
"
#
ifndef
WIN32
#
include
<
pthread
.
h
>
#
include
<
sched
.
h
>
#
endif
#
include
<
stdlib
.
h
>
#
include
<
time
.
h
>
namespace
test_scheduler
{
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
;
void
MaybeYieldThread
(
)
{
#
ifndef
WIN32
if
(
rand
(
)
%
5
=
=
0
)
{
sched_yield
(
)
;
}
#
endif
}
struct
SanityChecker
{
std
:
:
vector
<
uint64_t
>
mAdvancements
;
mozilla
:
:
gfx
:
:
Mutex
mMutex
;
SanityChecker
(
uint64_t
aNumCmdBuffers
)
{
for
(
uint32_t
i
=
0
;
i
<
aNumCmdBuffers
;
+
+
i
)
{
mAdvancements
.
push_back
(
0
)
;
}
}
virtual
void
Check
(
uint64_t
aTaskId
uint64_t
aCmdId
)
{
MaybeYieldThread
(
)
;
MutexAutoLock
lock
(
&
mMutex
)
;
ASSERT_EQ
(
mAdvancements
[
aTaskId
]
aCmdId
-
1
)
;
mAdvancements
[
aTaskId
]
=
aCmdId
;
}
}
;
struct
JoinTestSanityCheck
:
public
SanityChecker
{
bool
mSpecialTaskHasRun
;
JoinTestSanityCheck
(
uint64_t
aNumCmdBuffers
)
:
SanityChecker
(
aNumCmdBuffers
)
mSpecialTaskHasRun
(
false
)
{
}
virtual
void
Check
(
uint64_t
aTaskId
uint64_t
aCmdId
)
override
{
if
(
aCmdId
=
=
0
)
{
ASSERT_FALSE
(
mSpecialTaskHasRun
)
;
mSpecialTaskHasRun
=
true
;
for
(
auto
advancement
:
mAdvancements
)
{
ASSERT_EQ
(
advancement
(
uint32_t
)
1
)
;
}
}
else
{
SanityChecker
:
:
Check
(
aTaskId
aCmdId
)
;
}
if
(
aCmdId
=
=
2
)
{
ASSERT_TRUE
(
mSpecialTaskHasRun
)
;
}
}
}
;
class
TestTask
:
public
Task
{
public
:
TestTask
(
uint64_t
aCmdId
uint64_t
aTaskId
SanityChecker
*
aChecker
MultiThreadedTaskQueue
*
aQueue
SyncObject
*
aStart
SyncObject
*
aCompletion
)
:
Task
(
aQueue
aStart
aCompletion
)
mCmdId
(
aCmdId
)
mCmdBufferId
(
aTaskId
)
mSanityChecker
(
aChecker
)
{
}
TaskStatus
Run
(
)
{
MaybeYieldThread
(
)
;
mSanityChecker
-
>
Check
(
mCmdBufferId
mCmdId
)
;
MaybeYieldThread
(
)
;
return
TaskStatus
:
:
Complete
;
}
uint64_t
mCmdId
;
uint64_t
mCmdBufferId
;
SanityChecker
*
mSanityChecker
;
}
;
void
TestSchedulerJoin
(
uint32_t
aNumThreads
uint32_t
aNumCmdBuffers
)
{
JoinTestSanityCheck
check
(
aNumCmdBuffers
)
;
RefPtr
<
SyncObject
>
beforeFilter
=
new
SyncObject
(
)
;
RefPtr
<
SyncObject
>
afterFilter
=
new
SyncObject
(
)
;
RefPtr
<
SyncObject
>
completion
=
new
SyncObject
(
)
;
for
(
uint32_t
i
=
0
;
i
<
aNumCmdBuffers
;
+
+
i
)
{
Task
*
t1
=
new
TestTask
(
1
i
&
check
TaskScheduler
:
:
GetDrawingQueue
(
)
nullptr
beforeFilter
)
;
TaskScheduler
:
:
SubmitTask
(
t1
)
;
MaybeYieldThread
(
)
;
}
TaskScheduler
:
:
SubmitTask
(
new
TestTask
(
0
0
&
check
TaskScheduler
:
:
GetDrawingQueue
(
)
beforeFilter
afterFilter
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aNumCmdBuffers
;
+
+
i
)
{
Task
*
t2
=
new
TestTask
(
2
i
&
check
TaskScheduler
:
:
GetDrawingQueue
(
)
afterFilter
completion
)
;
TaskScheduler
:
:
SubmitTask
(
t2
)
;
MaybeYieldThread
(
)
;
}
auto
evtTask
=
new
SetEventTask
(
TaskScheduler
:
:
GetDrawingQueue
(
)
completion
)
;
RefPtr
<
EventObject
>
waitForCompletion
=
evtTask
-
>
GetEvent
(
)
;
TaskScheduler
:
:
SubmitTask
(
evtTask
)
;
MaybeYieldThread
(
)
;
waitForCompletion
-
>
Wait
(
)
;
MaybeYieldThread
(
)
;
for
(
auto
advancement
:
check
.
mAdvancements
)
{
ASSERT_TRUE
(
advancement
=
=
2
)
;
}
}
void
TestSchedulerChain
(
uint32_t
aNumThreads
uint32_t
aNumCmdBuffers
)
{
SanityChecker
check
(
aNumCmdBuffers
)
;
RefPtr
<
SyncObject
>
completion
=
new
SyncObject
(
)
;
uint32_t
numTasks
=
10
;
for
(
uint32_t
i
=
0
;
i
<
aNumCmdBuffers
;
+
+
i
)
{
std
:
:
vector
<
RefPtr
<
SyncObject
>
>
syncs
;
std
:
:
vector
<
Task
*
>
tasks
;
syncs
.
reserve
(
numTasks
)
;
tasks
.
reserve
(
numTasks
)
;
for
(
uint32_t
t
=
0
;
t
<
numTasks
-
1
;
+
+
t
)
{
syncs
.
push_back
(
new
SyncObject
(
)
)
;
tasks
.
push_back
(
new
TestTask
(
t
+
1
i
&
check
TaskScheduler
:
:
GetDrawingQueue
(
)
t
=
=
0
?
nullptr
:
syncs
[
t
-
1
]
.
get
(
)
syncs
[
t
]
)
)
;
}
tasks
.
push_back
(
new
TestTask
(
numTasks
i
&
check
TaskScheduler
:
:
GetDrawingQueue
(
)
syncs
.
back
(
)
completion
)
)
;
if
(
i
%
2
=
=
0
)
{
for
(
Task
*
task
:
tasks
)
{
TaskScheduler
:
:
SubmitTask
(
task
)
;
MaybeYieldThread
(
)
;
}
}
else
{
for
(
int32_t
reverse
=
numTasks
-
1
;
reverse
>
=
0
;
-
-
reverse
)
{
TaskScheduler
:
:
SubmitTask
(
tasks
[
reverse
]
)
;
MaybeYieldThread
(
)
;
}
}
}
auto
evtTask
=
new
SetEventTask
(
TaskScheduler
:
:
GetDrawingQueue
(
)
completion
)
;
RefPtr
<
EventObject
>
waitForCompletion
=
evtTask
-
>
GetEvent
(
)
;
TaskScheduler
:
:
SubmitTask
(
evtTask
)
;
MaybeYieldThread
(
)
;
waitForCompletion
-
>
Wait
(
)
;
for
(
auto
advancement
:
check
.
mAdvancements
)
{
ASSERT_TRUE
(
advancement
=
=
numTasks
)
;
}
}
}
TEST
(
Moz2D
TaskScheduler_Join
)
{
srand
(
time
(
nullptr
)
)
;
for
(
uint32_t
threads
=
1
;
threads
<
16
;
+
+
threads
)
{
for
(
uint32_t
queues
=
1
;
queues
<
threads
;
+
+
queues
)
{
for
(
uint32_t
buffers
=
1
;
buffers
<
100
;
buffers
+
=
3
)
{
mozilla
:
:
gfx
:
:
TaskScheduler
:
:
Init
(
threads
queues
)
;
test_scheduler
:
:
TestSchedulerJoin
(
threads
buffers
)
;
mozilla
:
:
gfx
:
:
TaskScheduler
:
:
ShutDown
(
)
;
}
}
}
}
TEST
(
Moz2D
TaskScheduler_Chain
)
{
srand
(
time
(
nullptr
)
)
;
for
(
uint32_t
threads
=
1
;
threads
<
16
;
+
+
threads
)
{
for
(
uint32_t
queues
=
1
;
queues
<
threads
;
+
+
queues
)
{
for
(
uint32_t
buffers
=
1
;
buffers
<
50
;
buffers
+
=
3
)
{
mozilla
:
:
gfx
:
:
TaskScheduler
:
:
Init
(
threads
queues
)
;
test_scheduler
:
:
TestSchedulerChain
(
threads
buffers
)
;
mozilla
:
:
gfx
:
:
TaskScheduler
:
:
ShutDown
(
)
;
}
}
}
}
