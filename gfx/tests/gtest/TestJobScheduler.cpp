#
include
"
gtest
/
gtest
.
h
"
#
include
"
gmock
/
gmock
.
h
"
#
include
"
mozilla
/
gfx
/
JobScheduler
.
h
"
#
ifndef
WIN32
#
include
<
pthread
.
h
>
#
include
<
sched
.
h
>
#
endif
#
include
<
stdlib
.
h
>
#
include
<
time
.
h
>
namespace
test_scheduler
{
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
;
void
MaybeYieldThread
(
)
{
#
ifndef
WIN32
if
(
rand
(
)
%
5
=
=
0
)
{
sched_yield
(
)
;
}
#
endif
}
struct
SanityChecker
{
std
:
:
vector
<
uint64_t
>
mAdvancements
;
mozilla
:
:
gfx
:
:
CriticalSection
mSection
;
explicit
SanityChecker
(
uint64_t
aNumCmdBuffers
)
{
for
(
uint32_t
i
=
0
;
i
<
aNumCmdBuffers
;
+
+
i
)
{
mAdvancements
.
push_back
(
0
)
;
}
}
virtual
void
Check
(
uint64_t
aJobId
uint64_t
aCmdId
)
{
MaybeYieldThread
(
)
;
CriticalSectionAutoEnter
lock
(
&
mSection
)
;
ASSERT_EQ
(
mAdvancements
[
aJobId
]
aCmdId
-
1
)
;
mAdvancements
[
aJobId
]
=
aCmdId
;
}
}
;
struct
JoinTestSanityCheck
:
public
SanityChecker
{
bool
mSpecialJobHasRun
;
explicit
JoinTestSanityCheck
(
uint64_t
aNumCmdBuffers
)
:
SanityChecker
(
aNumCmdBuffers
)
mSpecialJobHasRun
(
false
)
{
}
virtual
void
Check
(
uint64_t
aJobId
uint64_t
aCmdId
)
override
{
if
(
aCmdId
=
=
0
)
{
ASSERT_FALSE
(
mSpecialJobHasRun
)
;
mSpecialJobHasRun
=
true
;
for
(
auto
advancement
:
mAdvancements
)
{
ASSERT_EQ
(
advancement
(
uint32_t
)
1
)
;
}
}
else
{
SanityChecker
:
:
Check
(
aJobId
aCmdId
)
;
}
if
(
aCmdId
=
=
2
)
{
ASSERT_TRUE
(
mSpecialJobHasRun
)
;
}
}
}
;
class
TestJob
:
public
Job
{
public
:
TestJob
(
uint64_t
aCmdId
uint64_t
aJobId
SanityChecker
*
aChecker
SyncObject
*
aStart
SyncObject
*
aCompletion
)
:
Job
(
aStart
aCompletion
nullptr
)
mCmdId
(
aCmdId
)
mCmdBufferId
(
aJobId
)
mSanityChecker
(
aChecker
)
{
}
JobStatus
Run
(
)
{
MaybeYieldThread
(
)
;
mSanityChecker
-
>
Check
(
mCmdBufferId
mCmdId
)
;
MaybeYieldThread
(
)
;
return
JobStatus
:
:
Complete
;
}
uint64_t
mCmdId
;
uint64_t
mCmdBufferId
;
SanityChecker
*
mSanityChecker
;
}
;
void
TestSchedulerJoin
(
uint32_t
aNumThreads
uint32_t
aNumCmdBuffers
)
{
JoinTestSanityCheck
check
(
aNumCmdBuffers
)
;
RefPtr
<
SyncObject
>
beforeFilter
=
new
SyncObject
(
aNumCmdBuffers
)
;
RefPtr
<
SyncObject
>
afterFilter
=
new
SyncObject
(
)
;
RefPtr
<
SyncObject
>
completion
=
new
SyncObject
(
aNumCmdBuffers
)
;
for
(
uint32_t
i
=
0
;
i
<
aNumCmdBuffers
;
+
+
i
)
{
Job
*
t1
=
new
TestJob
(
1
i
&
check
nullptr
beforeFilter
)
;
JobScheduler
:
:
SubmitJob
(
t1
)
;
MaybeYieldThread
(
)
;
}
beforeFilter
-
>
FreezePrerequisites
(
)
;
JobScheduler
:
:
SubmitJob
(
new
TestJob
(
0
0
&
check
beforeFilter
afterFilter
)
)
;
afterFilter
-
>
FreezePrerequisites
(
)
;
for
(
uint32_t
i
=
0
;
i
<
aNumCmdBuffers
;
+
+
i
)
{
Job
*
t2
=
new
TestJob
(
2
i
&
check
afterFilter
completion
)
;
JobScheduler
:
:
SubmitJob
(
t2
)
;
MaybeYieldThread
(
)
;
}
completion
-
>
FreezePrerequisites
(
)
;
RefPtr
<
EventObject
>
waitForCompletion
=
new
EventObject
(
)
;
auto
evtJob
=
new
SetEventJob
(
waitForCompletion
completion
)
;
JobScheduler
:
:
SubmitJob
(
evtJob
)
;
MaybeYieldThread
(
)
;
waitForCompletion
-
>
Wait
(
)
;
MaybeYieldThread
(
)
;
for
(
auto
advancement
:
check
.
mAdvancements
)
{
ASSERT_TRUE
(
advancement
=
=
2
)
;
}
}
void
TestSchedulerChain
(
uint32_t
aNumThreads
uint32_t
aNumCmdBuffers
)
{
SanityChecker
check
(
aNumCmdBuffers
)
;
RefPtr
<
SyncObject
>
completion
=
new
SyncObject
(
aNumCmdBuffers
)
;
uint32_t
numJobs
=
10
;
for
(
uint32_t
i
=
0
;
i
<
aNumCmdBuffers
;
+
+
i
)
{
std
:
:
vector
<
RefPtr
<
SyncObject
>
>
syncs
;
std
:
:
vector
<
Job
*
>
tasks
;
syncs
.
reserve
(
numJobs
)
;
tasks
.
reserve
(
numJobs
)
;
for
(
uint32_t
t
=
0
;
t
<
numJobs
-
1
;
+
+
t
)
{
syncs
.
push_back
(
new
SyncObject
(
)
)
;
tasks
.
push_back
(
new
TestJob
(
t
+
1
i
&
check
t
=
=
0
?
nullptr
:
syncs
[
t
-
1
]
.
get
(
)
syncs
[
t
]
)
)
;
syncs
.
back
(
)
-
>
FreezePrerequisites
(
)
;
}
tasks
.
push_back
(
new
TestJob
(
numJobs
i
&
check
syncs
.
back
(
)
completion
)
)
;
if
(
i
%
2
=
=
0
)
{
for
(
Job
*
task
:
tasks
)
{
JobScheduler
:
:
SubmitJob
(
task
)
;
MaybeYieldThread
(
)
;
}
}
else
{
for
(
int32_t
reverse
=
numJobs
-
1
;
reverse
>
=
0
;
-
-
reverse
)
{
JobScheduler
:
:
SubmitJob
(
tasks
[
reverse
]
)
;
MaybeYieldThread
(
)
;
}
}
}
completion
-
>
FreezePrerequisites
(
)
;
RefPtr
<
EventObject
>
waitForCompletion
=
new
EventObject
(
)
;
auto
evtJob
=
new
SetEventJob
(
waitForCompletion
completion
)
;
JobScheduler
:
:
SubmitJob
(
evtJob
)
;
MaybeYieldThread
(
)
;
waitForCompletion
-
>
Wait
(
)
;
for
(
auto
advancement
:
check
.
mAdvancements
)
{
ASSERT_TRUE
(
advancement
=
=
numJobs
)
;
}
}
}
TEST
(
Moz2D
JobScheduler_Join
)
{
srand
(
time
(
nullptr
)
)
;
for
(
uint32_t
threads
=
1
;
threads
<
8
;
+
+
threads
)
{
for
(
uint32_t
queues
=
1
;
queues
<
threads
;
+
+
queues
)
{
for
(
uint32_t
buffers
=
1
;
buffers
<
100
;
buffers
+
=
3
)
{
mozilla
:
:
gfx
:
:
JobScheduler
:
:
Init
(
threads
queues
)
;
test_scheduler
:
:
TestSchedulerJoin
(
threads
buffers
)
;
mozilla
:
:
gfx
:
:
JobScheduler
:
:
ShutDown
(
)
;
}
}
}
}
TEST
(
Moz2D
JobScheduler_Chain
)
{
srand
(
time
(
nullptr
)
)
;
for
(
uint32_t
threads
=
1
;
threads
<
8
;
+
+
threads
)
{
for
(
uint32_t
queues
=
1
;
queues
<
threads
;
+
+
queues
)
{
for
(
uint32_t
buffers
=
1
;
buffers
<
100
;
buffers
+
=
3
)
{
mozilla
:
:
gfx
:
:
JobScheduler
:
:
Init
(
threads
queues
)
;
test_scheduler
:
:
TestSchedulerChain
(
threads
buffers
)
;
mozilla
:
:
gfx
:
:
JobScheduler
:
:
ShutDown
(
)
;
}
}
}
}
