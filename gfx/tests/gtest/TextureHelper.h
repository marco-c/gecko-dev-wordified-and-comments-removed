#
include
<
vector
>
#
include
"
gfxImageSurface
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
layers
/
BufferTexture
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
ifdef
XP_WIN
#
include
"
IMFYCbCrImage
.
h
"
#
include
"
mozilla
/
gfx
/
DeviceManagerDx
.
h
"
#
include
"
mozilla
/
layers
/
D3D11YCbCrImage
.
h
"
#
include
"
mozilla
/
layers
/
TextureD3D11
.
h
"
#
include
"
mozilla
/
layers
/
TextureDIB
.
h
"
#
endif
using
mozilla
:
:
gfx
:
:
SurfaceFormat
;
namespace
mozilla
{
namespace
layers
{
static
already_AddRefed
<
TextureClient
>
CreateYCbCrTextureClientWithBackend
(
LayersBackend
aLayersBackend
)
{
TextureData
*
data
=
nullptr
;
IntSize
size
=
IntSize
(
200
150
)
;
IntSize
ySize
=
IntSize
(
400
300
)
;
RefPtr
<
gfxImageSurface
>
ySurface
=
new
gfxImageSurface
(
ySize
SurfaceFormat
:
:
A8
)
;
RefPtr
<
gfxImageSurface
>
cbSurface
=
new
gfxImageSurface
(
size
SurfaceFormat
:
:
A8
)
;
RefPtr
<
gfxImageSurface
>
crSurface
=
new
gfxImageSurface
(
size
SurfaceFormat
:
:
A8
)
;
PlanarYCbCrData
clientData
;
clientData
.
mYChannel
=
ySurface
-
>
Data
(
)
;
clientData
.
mCbChannel
=
cbSurface
-
>
Data
(
)
;
clientData
.
mCrChannel
=
crSurface
-
>
Data
(
)
;
clientData
.
mYSize
=
ySurface
-
>
GetSize
(
)
;
clientData
.
mPicSize
=
ySurface
-
>
GetSize
(
)
;
clientData
.
mCbCrSize
=
cbSurface
-
>
GetSize
(
)
;
clientData
.
mYStride
=
ySurface
-
>
Stride
(
)
;
clientData
.
mCbCrStride
=
cbSurface
-
>
Stride
(
)
;
clientData
.
mStereoMode
=
StereoMode
:
:
MONO
;
clientData
.
mYSkip
=
0
;
clientData
.
mCbSkip
=
0
;
clientData
.
mCrSkip
=
0
;
clientData
.
mCrSkip
=
0
;
clientData
.
mPicX
=
0
;
clientData
.
mPicX
=
0
;
if
(
aLayersBackend
=
=
LayersBackend
:
:
LAYERS_BASIC
)
{
return
TextureClient
:
:
CreateForYCbCr
(
nullptr
clientData
.
mYSize
clientData
.
mYStride
clientData
.
mCbCrSize
clientData
.
mCbCrStride
StereoMode
:
:
MONO
gfx
:
:
ColorDepth
:
:
COLOR_8
gfx
:
:
YUVColorSpace
:
:
BT601
gfx
:
:
ColorRange
:
:
LIMITED
TextureFlags
:
:
DEALLOCATE_CLIENT
)
;
}
#
ifdef
XP_WIN
RefPtr
<
ID3D11Device
>
device
=
DeviceManagerDx
:
:
Get
(
)
-
>
GetImageDevice
(
)
;
if
(
device
&
&
aLayersBackend
=
=
LayersBackend
:
:
LAYERS_D3D11
)
{
DXGIYCbCrTextureAllocationHelper
helper
(
clientData
TextureFlags
:
:
DEFAULT
device
)
;
RefPtr
<
TextureClient
>
texture
=
helper
.
Allocate
(
nullptr
)
;
return
texture
.
forget
(
)
;
}
#
endif
if
(
data
)
{
return
MakeAndAddRef
<
TextureClient
>
(
data
TextureFlags
:
:
DEALLOCATE_CLIENT
nullptr
)
;
}
return
nullptr
;
}
static
already_AddRefed
<
TextureClient
>
CreateTextureClientWithBackend
(
LayersBackend
aLayersBackend
)
{
TextureData
*
data
=
nullptr
;
SurfaceFormat
format
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
Optimal2DFormatForContent
(
gfxContentType
:
:
COLOR_ALPHA
)
;
BackendType
moz2DBackend
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetContentBackendFor
(
aLayersBackend
)
;
TextureAllocationFlags
allocFlags
=
TextureAllocationFlags
:
:
ALLOC_DEFAULT
;
IntSize
size
=
IntSize
(
400
300
)
;
TextureFlags
textureFlags
=
TextureFlags
:
:
DEALLOCATE_CLIENT
;
if
(
!
gfx
:
:
Factory
:
:
AllowedSurfaceSize
(
size
)
)
{
return
nullptr
;
}
#
ifdef
XP_WIN
if
(
aLayersBackend
=
=
LayersBackend
:
:
LAYERS_D3D11
&
&
(
moz2DBackend
=
=
BackendType
:
:
DIRECT2D
|
|
moz2DBackend
=
=
BackendType
:
:
DIRECT2D1_1
)
)
{
data
=
D3D11TextureData
:
:
Create
(
size
format
allocFlags
)
;
}
else
if
(
!
data
&
&
format
=
=
SurfaceFormat
:
:
B8G8R8X8
&
&
moz2DBackend
=
=
BackendType
:
:
CAIRO
)
{
data
=
DIBTextureData
:
:
Create
(
size
format
nullptr
)
;
}
#
endif
if
(
!
data
&
&
aLayersBackend
=
=
LayersBackend
:
:
LAYERS_BASIC
)
{
data
=
BufferTextureData
:
:
Create
(
size
format
moz2DBackend
aLayersBackend
textureFlags
allocFlags
nullptr
)
;
}
if
(
data
)
{
return
MakeAndAddRef
<
TextureClient
>
(
data
textureFlags
nullptr
)
;
}
return
nullptr
;
}
already_AddRefed
<
TextureHost
>
CreateTextureHostWithBackend
(
TextureClient
*
aClient
ISurfaceAllocator
*
aDeallocator
LayersBackend
&
aLayersBackend
)
{
if
(
!
aClient
)
{
return
nullptr
;
}
SurfaceDescriptor
descriptor
;
ReadLockDescriptor
readLock
=
null_t
(
)
;
RefPtr
<
TextureHost
>
textureHost
;
aClient
-
>
ToSurfaceDescriptor
(
descriptor
)
;
wr
:
:
MaybeExternalImageId
id
=
Nothing
(
)
;
return
TextureHost
:
:
Create
(
descriptor
readLock
aDeallocator
aLayersBackend
aClient
-
>
GetFlags
(
)
id
)
;
}
}
}
