#
ifndef
mozilla_gfx_config_gfxConfig_h
#
define
mozilla_gfx_config_gfxConfig_h
#
include
"
gfxFeature
.
h
"
#
include
"
gfxFallback
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
namespace
mozilla
{
namespace
gfx
{
class
gfxConfig
{
public
:
static
bool
IsEnabled
(
Feature
aFeature
)
;
static
bool
IsForcedOnByUser
(
Feature
aFeature
)
;
static
bool
IsDisabledByDefault
(
Feature
aFeature
)
;
static
FeatureStatus
GetValue
(
Feature
aFeature
)
;
static
bool
SetDefault
(
Feature
aFeature
bool
aEnable
FeatureStatus
aDisableStatus
const
char
*
aDisableMessage
)
;
static
void
Disable
(
Feature
aFeature
FeatureStatus
aStatus
const
char
*
aMessage
)
;
static
void
SetFailed
(
Feature
aFeature
FeatureStatus
aStatus
const
char
*
aMessage
)
;
static
void
ForceDisable
(
Feature
aFeature
FeatureStatus
aStatus
const
char
*
aMessage
)
{
SetFailed
(
aFeature
aStatus
aMessage
)
;
}
static
bool
MaybeSetFailed
(
Feature
aFeature
bool
aEnable
FeatureStatus
aDisableStatus
const
char
*
aDisableMessage
)
{
if
(
!
aEnable
)
{
SetFailed
(
aFeature
aDisableStatus
aDisableMessage
)
;
return
false
;
}
return
true
;
}
static
bool
MaybeSetFailed
(
Feature
aFeature
FeatureStatus
aStatus
const
char
*
aDisableMessage
)
{
return
MaybeSetFailed
(
aFeature
(
aStatus
!
=
FeatureStatus
:
:
Available
&
&
aStatus
!
=
FeatureStatus
:
:
ForceEnabled
)
aStatus
aDisableMessage
)
;
}
static
bool
InitOrUpdate
(
Feature
aFeature
bool
aEnable
FeatureStatus
aDisableStatus
const
char
*
aDisableMessage
)
;
static
void
UserEnable
(
Feature
aFeature
const
char
*
aMessage
)
;
static
void
UserForceEnable
(
Feature
aFeature
const
char
*
aMessage
)
;
static
void
UserDisable
(
Feature
aFeature
const
char
*
aMessage
)
;
static
bool
UseFallback
(
Fallback
aFallback
)
;
static
void
EnableFallback
(
Fallback
aFallback
const
char
*
aMessage
)
;
private
:
FeatureState
&
GetState
(
Feature
aFeature
)
{
MOZ_ASSERT
(
size_t
(
aFeature
)
<
kNumFeatures
)
;
return
mFeatures
[
size_t
(
aFeature
)
]
;
}
const
FeatureState
&
GetState
(
Feature
aFeature
)
const
{
MOZ_ASSERT
(
size_t
(
aFeature
)
<
kNumFeatures
)
;
return
mFeatures
[
size_t
(
aFeature
)
]
;
}
bool
UseFallbackImpl
(
Fallback
aFallback
)
const
;
void
EnableFallbackImpl
(
Fallback
aFallback
)
;
static
void
AssertStatusInitialized
(
Feature
aFeature
)
;
private
:
static
const
size_t
kNumFeatures
=
size_t
(
Feature
:
:
NumValues
)
;
private
:
FeatureState
mFeatures
[
kNumFeatures
]
;
uint64_t
mFallbackBits
;
}
;
}
}
#
endif
