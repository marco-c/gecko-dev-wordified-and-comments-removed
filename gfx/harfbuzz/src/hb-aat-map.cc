#
include
"
hb
.
hh
"
#
ifndef
HB_NO_AAT_SHAPE
#
include
"
hb
-
aat
-
map
.
hh
"
#
include
"
hb
-
aat
-
layout
.
hh
"
#
include
"
hb
-
aat
-
layout
-
feat
-
table
.
hh
"
void
hb_aat_map_builder_t
:
:
add_feature
(
const
hb_feature_t
&
feature
)
{
if
(
!
face
-
>
table
.
feat
-
>
has_data
(
)
)
return
;
if
(
feature
.
tag
=
=
HB_TAG
(
'
a
'
'
a
'
'
l
'
'
t
'
)
)
{
if
(
!
face
-
>
table
.
feat
-
>
exposes_feature
(
HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_ALTERNATIVES
)
)
return
;
feature_range_t
*
range
=
features
.
push
(
)
;
range
-
>
start
=
feature
.
start
;
range
-
>
end
=
feature
.
end
;
range
-
>
info
.
type
=
HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_ALTERNATIVES
;
range
-
>
info
.
setting
=
(
hb_aat_layout_feature_selector_t
)
feature
.
value
;
range
-
>
info
.
seq
=
features
.
length
;
range
-
>
info
.
is_exclusive
=
true
;
return
;
}
const
hb_aat_feature_mapping_t
*
mapping
=
hb_aat_layout_find_feature_mapping
(
feature
.
tag
)
;
if
(
!
mapping
)
return
;
const
AAT
:
:
FeatureName
*
feature_name
=
&
face
-
>
table
.
feat
-
>
get_feature
(
mapping
-
>
aatFeatureType
)
;
if
(
!
feature_name
-
>
has_data
(
)
)
{
if
(
mapping
-
>
aatFeatureType
=
=
HB_AAT_LAYOUT_FEATURE_TYPE_LOWER_CASE
&
&
mapping
-
>
selectorToEnable
=
=
HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_SMALL_CAPS
)
{
feature_name
=
&
face
-
>
table
.
feat
-
>
get_feature
(
HB_AAT_LAYOUT_FEATURE_TYPE_LETTER_CASE
)
;
if
(
!
feature_name
-
>
has_data
(
)
)
return
;
}
else
return
;
}
feature_range_t
*
range
=
features
.
push
(
)
;
range
-
>
start
=
feature
.
start
;
range
-
>
end
=
feature
.
end
;
range
-
>
info
.
type
=
mapping
-
>
aatFeatureType
;
range
-
>
info
.
setting
=
feature
.
value
?
mapping
-
>
selectorToEnable
:
mapping
-
>
selectorToDisable
;
range
-
>
info
.
seq
=
features
.
length
;
range
-
>
info
.
is_exclusive
=
feature_name
-
>
is_exclusive
(
)
;
}
void
hb_aat_map_builder_t
:
:
compile
(
hb_aat_map_t
&
m
)
{
hb_vector_t
<
feature_event_t
>
feature_events
;
feature_events
.
alloc_exact
(
features
.
length
*
2
+
1
)
;
for
(
unsigned
int
i
=
0
;
i
<
features
.
length
;
i
+
+
)
{
auto
&
feature
=
features
.
arrayZ
[
i
]
;
if
(
feature
.
start
=
=
feature
.
end
)
continue
;
feature_event_t
*
event
;
event
=
feature_events
.
push
(
)
;
event
-
>
index
=
feature
.
start
;
event
-
>
start
=
true
;
event
-
>
feature
=
feature
.
info
;
event
=
feature_events
.
push
(
)
;
event
-
>
index
=
feature
.
end
;
event
-
>
start
=
false
;
event
-
>
feature
=
feature
.
info
;
}
feature_events
.
qsort
(
)
;
{
feature_info_t
feature
;
feature
.
seq
=
features
.
length
+
1
;
feature_event_t
*
event
=
feature_events
.
push
(
)
;
event
-
>
index
=
-
1
;
event
-
>
start
=
false
;
event
-
>
feature
=
feature
;
}
hb_sorted_vector_t
<
feature_info_t
>
active_features
;
unsigned
int
last_index
=
0
;
for
(
unsigned
int
i
=
0
;
i
<
feature_events
.
length
;
i
+
+
)
{
feature_event_t
*
event
=
&
feature_events
[
i
]
;
if
(
event
-
>
index
!
=
last_index
)
{
current_features
=
active_features
;
range_first
=
last_index
;
range_last
=
event
-
>
index
-
1
;
if
(
current_features
.
length
)
{
current_features
.
qsort
(
)
;
unsigned
int
j
=
0
;
for
(
unsigned
int
i
=
1
;
i
<
current_features
.
length
;
i
+
+
)
if
(
current_features
.
arrayZ
[
i
]
.
type
!
=
current_features
.
arrayZ
[
j
]
.
type
|
|
(
!
current_features
.
arrayZ
[
i
]
.
is_exclusive
&
&
(
(
current_features
.
arrayZ
[
i
]
.
setting
&
~
1
)
!
=
(
current_features
.
arrayZ
[
j
]
.
setting
&
~
1
)
)
)
)
current_features
.
arrayZ
[
+
+
j
]
=
current_features
.
arrayZ
[
i
]
;
current_features
.
shrink
(
j
+
1
)
;
}
hb_aat_layout_compile_map
(
this
&
m
)
;
last_index
=
event
-
>
index
;
}
if
(
event
-
>
start
)
{
active_features
.
push
(
event
-
>
feature
)
;
}
else
{
feature_info_t
*
feature
=
active_features
.
lsearch
(
event
-
>
feature
)
;
if
(
feature
)
active_features
.
remove_ordered
(
feature
-
active_features
.
arrayZ
)
;
}
}
for
(
auto
&
chain_flags
:
m
.
chain_flags
)
chain_flags
.
tail
(
)
.
cluster_last
=
HB_FEATURE_GLOBAL_END
;
}
#
endif
