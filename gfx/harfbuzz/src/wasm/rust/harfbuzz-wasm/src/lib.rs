#
!
[
warn
(
missing_docs
)
]
#
!
[
allow
(
dead_code
)
]
use
std
:
:
ffi
:
:
{
c_int
CStr
CString
}
;
#
[
cfg
(
feature
=
"
kurbo
"
)
]
use
kurbo
:
:
BezPath
;
extern
"
C
"
{
fn
face_get_upem
(
face
:
u32
)
-
>
u32
;
fn
font_get_face
(
font
:
u32
)
-
>
u32
;
fn
font_get_glyph
(
font
:
u32
unicode
:
u32
uvs
:
u32
)
-
>
u32
;
fn
font_get_scale
(
font
:
u32
x_scale
:
*
mut
i32
y_scale
:
*
mut
i32
)
;
fn
font_get_glyph_extents
(
font
:
u32
glyph
:
u32
extents
:
*
mut
CGlyphExtents
)
-
>
bool
;
fn
font_glyph_to_string
(
font
:
u32
glyph
:
u32
str
:
*
const
u8
len
:
u32
)
;
fn
font_get_glyph_h_advance
(
font
:
u32
glyph
:
u32
)
-
>
i32
;
fn
font_get_glyph_v_advance
(
font
:
u32
glyph
:
u32
)
-
>
i32
;
fn
font_copy_glyph_outline
(
font
:
u32
glyph
:
u32
outline
:
*
mut
CGlyphOutline
)
-
>
bool
;
fn
face_copy_table
(
font
:
u32
tag
:
u32
blob
:
*
mut
Blob
)
-
>
bool
;
fn
buffer_copy_contents
(
buffer
:
u32
cbuffer
:
*
mut
CBufferContents
)
-
>
bool
;
fn
buffer_set_contents
(
buffer
:
u32
cbuffer
:
&
CBufferContents
)
-
>
bool
;
fn
debugprint
(
s
:
*
const
u8
)
;
fn
shape_with
(
font
:
u32
buffer
:
u32
features
:
u32
num_features
:
u32
shaper
:
*
const
u8
)
-
>
i32
;
}
#
[
derive
(
Debug
)
]
pub
struct
Font
(
u32
)
;
impl
Font
{
pub
fn
from_ref
(
ptr
:
u32
)
-
>
Self
{
Self
(
ptr
)
}
pub
fn
shape_with
(
&
self
buffer_ref
:
u32
shaper
:
&
str
)
{
let
c_shaper
=
CString
:
:
new
(
shaper
)
.
unwrap
(
)
;
unsafe
{
shape_with
(
self
.
0
buffer_ref
0
0
c_shaper
.
as_ptr
(
)
as
*
const
u8
)
;
}
}
pub
fn
get_face
(
&
self
)
-
>
Face
{
Face
(
unsafe
{
font_get_face
(
self
.
0
)
}
)
}
pub
fn
get_glyph
(
&
self
unicode
:
u32
uvs
:
u32
)
-
>
u32
{
unsafe
{
font_get_glyph
(
self
.
0
unicode
uvs
)
}
}
pub
fn
get_glyph_extents
(
&
self
glyph
:
u32
)
-
>
CGlyphExtents
{
let
mut
extents
=
CGlyphExtents
:
:
default
(
)
;
unsafe
{
font_get_glyph_extents
(
self
.
0
glyph
&
mut
extents
)
;
}
extents
}
pub
fn
get_glyph_h_advance
(
&
self
glyph
:
u32
)
-
>
i32
{
unsafe
{
font_get_glyph_h_advance
(
self
.
0
glyph
)
}
}
fn
get_glyph_v_advance
(
&
self
glyph
:
u32
)
-
>
i32
{
unsafe
{
font_get_glyph_v_advance
(
self
.
0
glyph
)
}
}
pub
fn
get_glyph_name
(
&
self
glyph
:
u32
)
-
>
String
{
let
mut
s
=
[
1u8
;
32
]
;
unsafe
{
font_glyph_to_string
(
self
.
0
glyph
s
.
as_mut_ptr
(
)
32
)
;
}
unsafe
{
CStr
:
:
from_ptr
(
s
.
as_ptr
(
)
as
*
const
_
)
}
.
to_str
(
)
.
unwrap
(
)
.
to_string
(
)
}
pub
fn
get_scale
(
&
self
)
-
>
(
i32
i32
)
{
let
mut
x_scale
:
i32
=
0
;
let
mut
y_scale
:
i32
=
0
;
unsafe
{
font_get_scale
(
self
.
0
&
mut
x_scale
as
*
mut
c_int
&
mut
y_scale
as
*
mut
c_int
)
}
;
(
x_scale
y_scale
)
}
#
[
cfg
(
feature
=
"
kurbo
"
)
]
pub
fn
get_outline
(
&
self
glyph
:
u32
)
-
>
Vec
<
BezPath
>
{
let
mut
outline
=
CGlyphOutline
{
n_points
:
0
points
:
std
:
:
ptr
:
:
null_mut
(
)
n_contours
:
0
contours
:
std
:
:
ptr
:
:
null_mut
(
)
}
;
let
end_pts_of_contours
:
&
[
usize
]
=
unsafe
{
font_copy_glyph_outline
(
self
.
0
glyph
&
mut
outline
)
;
std
:
:
slice
:
:
from_raw_parts
(
outline
.
contours
outline
.
n_contours
as
usize
)
}
;
let
points
:
&
[
CGlyphOutlinePoint
]
=
unsafe
{
std
:
:
slice
:
:
from_raw_parts
(
outline
.
points
outline
.
n_points
as
usize
)
}
;
let
mut
results
:
Vec
<
BezPath
>
=
vec
!
[
]
;
let
mut
start_pt
:
usize
=
0
;
for
end_pt
in
end_pts_of_contours
{
let
this_contour
=
&
points
[
start_pt
.
.
*
end_pt
]
;
start_pt
=
*
end_pt
;
let
mut
path
=
BezPath
:
:
new
(
)
;
let
mut
ix
=
0
;
while
ix
<
this_contour
.
len
(
)
{
let
point
=
&
this_contour
[
ix
]
;
match
point
.
pointtype
{
PointType
:
:
MoveTo
=
>
path
.
move_to
(
(
point
.
x
as
f64
point
.
y
as
f64
)
)
PointType
:
:
LineTo
=
>
path
.
line_to
(
(
point
.
x
as
f64
point
.
y
as
f64
)
)
PointType
:
:
QuadraticTo
=
>
{
ix
+
=
1
;
let
end_pt
=
&
this_contour
[
ix
]
;
path
.
quad_to
(
(
point
.
x
as
f64
point
.
y
as
f64
)
(
end_pt
.
x
as
f64
end_pt
.
y
as
f64
)
)
;
}
PointType
:
:
CubicTo
=
>
{
ix
+
=
1
;
let
mid_pt
=
&
this_contour
[
ix
]
;
ix
+
=
1
;
let
end_pt
=
&
this_contour
[
ix
]
;
path
.
curve_to
(
(
point
.
x
as
f64
point
.
y
as
f64
)
(
mid_pt
.
x
as
f64
mid_pt
.
y
as
f64
)
(
end_pt
.
x
as
f64
end_pt
.
y
as
f64
)
)
;
}
}
ix
+
=
1
;
}
path
.
close_path
(
)
;
results
.
push
(
path
)
;
}
results
}
}
#
[
derive
(
Debug
)
]
pub
struct
Face
(
u32
)
;
impl
Face
{
pub
fn
reference_table
(
&
self
tag
:
&
str
)
-
>
Blob
{
let
mut
tag_u
:
u32
=
0
;
let
mut
chars
=
tag
.
chars
(
)
;
tag_u
|
=
(
chars
.
next
(
)
.
unwrap
(
)
as
u32
)
<
<
24
;
tag_u
|
=
(
chars
.
next
(
)
.
unwrap
(
)
as
u32
)
<
<
16
;
tag_u
|
=
(
chars
.
next
(
)
.
unwrap
(
)
as
u32
)
<
<
8
;
tag_u
|
=
chars
.
next
(
)
.
unwrap
(
)
as
u32
;
let
mut
blob
=
Blob
{
data
:
std
:
:
ptr
:
:
null_mut
(
)
length
:
0
}
;
unsafe
{
face_copy_table
(
self
.
0
tag_u
&
mut
blob
)
;
}
blob
}
pub
fn
get_upem
(
&
self
)
-
>
u32
{
unsafe
{
face_get_upem
(
self
.
0
)
}
}
}
pub
trait
BufferItem
{
fn
from_c
(
info
:
CGlyphInfo
position
:
CGlyphPosition
)
-
>
Self
;
fn
to_c
(
self
)
-
>
(
CGlyphInfo
CGlyphPosition
)
;
}
#
[
derive
(
Debug
)
]
pub
struct
Buffer
<
T
:
BufferItem
>
{
_ptr
:
u32
pub
glyphs
:
Vec
<
T
>
}
impl
<
T
:
BufferItem
>
Buffer
<
T
>
{
pub
fn
from_ref
(
ptr
:
u32
)
-
>
Self
{
let
mut
c_contents
=
CBufferContents
{
info
:
std
:
:
ptr
:
:
null_mut
(
)
position
:
std
:
:
ptr
:
:
null_mut
(
)
length
:
0
}
;
unsafe
{
buffer_copy_contents
(
ptr
&
mut
c_contents
)
|
|
panic
!
(
"
Couldn
'
t
copy
buffer
contents
"
)
}
;
let
positions
:
Vec
<
CGlyphPosition
>
=
unsafe
{
std
:
:
slice
:
:
from_raw_parts
(
c_contents
.
position
c_contents
.
length
as
usize
)
.
to_vec
(
)
}
;
let
infos
:
Vec
<
CGlyphInfo
>
=
unsafe
{
std
:
:
slice
:
:
from_raw_parts
(
c_contents
.
info
c_contents
.
length
as
usize
)
.
to_vec
(
)
}
;
Buffer
{
glyphs
:
infos
.
into_iter
(
)
.
zip
(
positions
.
into_iter
(
)
)
.
map
(
|
(
i
p
)
|
T
:
:
from_c
(
i
p
)
)
.
collect
(
)
_ptr
:
ptr
}
}
}
impl
<
T
:
BufferItem
>
Drop
for
Buffer
<
T
>
{
fn
drop
(
&
mut
self
)
{
let
mut
positions
:
Vec
<
CGlyphPosition
>
;
let
mut
infos
:
Vec
<
CGlyphInfo
>
;
let
glyphs
=
std
:
:
mem
:
:
take
(
&
mut
self
.
glyphs
)
;
(
infos
positions
)
=
glyphs
.
into_iter
(
)
.
map
(
|
g
|
g
.
to_c
(
)
)
.
unzip
(
)
;
let
c_contents
=
CBufferContents
{
length
:
positions
.
len
(
)
as
u32
info
:
infos
[
.
.
]
.
as_mut_ptr
(
)
position
:
positions
[
.
.
]
.
as_mut_ptr
(
)
}
;
unsafe
{
if
!
buffer_set_contents
(
self
.
_ptr
&
c_contents
)
{
panic
!
(
"
Couldn
'
t
set
buffer
contents
"
)
;
}
}
}
}
#
[
derive
(
Debug
)
]
#
[
repr
(
C
)
]
pub
struct
Blob
{
pub
length
:
u32
pub
data
:
*
mut
u8
}
#
[
repr
(
C
)
]
#
[
derive
(
Debug
Clone
)
]
pub
struct
CGlyphInfo
{
pub
codepoint
:
u32
pub
mask
:
u32
pub
cluster
:
u32
pub
var1
:
u32
pub
var2
:
u32
}
#
[
derive
(
Debug
Clone
)
]
#
[
repr
(
C
)
]
pub
struct
CGlyphPosition
{
pub
x_advance
:
i32
pub
y_advance
:
i32
pub
x_offset
:
i32
pub
y_offset
:
i32
pub
var
:
u32
}
#
[
derive
(
Debug
Clone
Default
)
]
#
[
repr
(
C
)
]
pub
struct
CGlyphExtents
{
pub
x_bearing
:
i32
pub
y_bearing
:
i32
pub
width
:
i32
pub
height
:
i32
}
#
[
derive
(
Debug
)
]
#
[
repr
(
C
)
]
struct
CBufferContents
{
length
:
u32
info
:
*
mut
CGlyphInfo
position
:
*
mut
CGlyphPosition
}
#
[
derive
(
Debug
Clone
Copy
)
]
pub
struct
Glyph
{
pub
codepoint
:
u32
pub
cluster
:
u32
pub
x_advance
:
i32
pub
y_advance
:
i32
pub
x_offset
:
i32
pub
y_offset
:
i32
pub
flags
:
u32
}
impl
BufferItem
for
Glyph
{
fn
from_c
(
info
:
CGlyphInfo
pos
:
CGlyphPosition
)
-
>
Self
{
Self
{
codepoint
:
info
.
codepoint
cluster
:
info
.
cluster
x_advance
:
pos
.
x_advance
y_advance
:
pos
.
y_advance
x_offset
:
pos
.
x_offset
y_offset
:
pos
.
y_offset
flags
:
0
}
}
fn
to_c
(
self
)
-
>
(
CGlyphInfo
CGlyphPosition
)
{
let
info
=
CGlyphInfo
{
codepoint
:
self
.
codepoint
cluster
:
self
.
cluster
mask
:
0
var1
:
0
var2
:
0
}
;
let
pos
=
CGlyphPosition
{
x_advance
:
self
.
x_advance
y_advance
:
self
.
y_advance
x_offset
:
self
.
x_offset
y_offset
:
self
.
y_offset
var
:
0
}
;
(
info
pos
)
}
}
#
[
repr
(
C
)
]
#
[
allow
(
clippy
:
:
enum_variant_names
)
]
#
[
derive
(
Clone
Debug
)
]
enum
PointType
{
MoveTo
LineTo
QuadraticTo
CubicTo
}
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Debug
)
]
struct
CGlyphOutlinePoint
{
x
:
f32
y
:
f32
pointtype
:
PointType
}
#
[
repr
(
C
)
]
struct
CGlyphOutline
{
n_points
:
usize
points
:
*
mut
CGlyphOutlinePoint
n_contours
:
usize
contours
:
*
mut
usize
}
pub
type
GlyphBuffer
=
Buffer
<
Glyph
>
;
pub
fn
debug
(
s
:
&
str
)
{
let
c_s
=
CString
:
:
new
(
s
)
.
unwrap
(
)
;
unsafe
{
debugprint
(
c_s
.
as_ptr
(
)
as
*
const
u8
)
;
}
;
}
