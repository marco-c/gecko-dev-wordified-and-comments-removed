#
ifndef
HB_OT_LAYOUT_BASE_TABLE_HH
#
define
HB_OT_LAYOUT_BASE_TABLE_HH
#
include
"
hb
-
open
-
type
.
hh
"
#
include
"
hb
-
ot
-
layout
-
common
.
hh
"
typedef
hb_tag_t
hb_ot_layout_baseline_t
;
namespace
OT
{
struct
BaseCoordFormat1
{
hb_position_t
get_coord
(
)
const
{
return
coordinate
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
)
)
;
}
protected
:
HBUINT16
format
;
FWORD
coordinate
;
public
:
DEFINE_SIZE_STATIC
(
4
)
;
}
;
struct
BaseCoordFormat2
{
hb_position_t
get_coord
(
)
const
{
return
coordinate
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
protected
:
HBUINT16
format
;
FWORD
coordinate
;
GlyphID
referenceGlyph
;
HBUINT16
coordPoint
;
public
:
DEFINE_SIZE_STATIC
(
8
)
;
}
;
struct
BaseCoordFormat3
{
hb_position_t
get_coord
(
hb_font_t
*
font
const
VariationStore
&
var_store
hb_direction_t
direction
)
const
{
const
Device
&
device
=
this
+
deviceTable
;
return
coordinate
+
(
HB_DIRECTION_IS_VERTICAL
(
direction
)
?
device
.
get_y_delta
(
font
var_store
)
:
device
.
get_x_delta
(
font
var_store
)
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
deviceTable
.
sanitize
(
c
this
)
)
)
;
}
protected
:
HBUINT16
format
;
FWORD
coordinate
;
OffsetTo
<
Device
>
deviceTable
;
public
:
DEFINE_SIZE_STATIC
(
6
)
;
}
;
struct
BaseCoord
{
hb_position_t
get_coord
(
hb_font_t
*
font
const
VariationStore
&
var_store
hb_direction_t
direction
)
const
{
switch
(
u
.
format
)
{
case
1
:
return
u
.
format1
.
get_coord
(
)
;
case
2
:
return
u
.
format2
.
get_coord
(
)
;
case
3
:
return
u
.
format3
.
get_coord
(
font
var_store
direction
)
;
default
:
return
0
;
}
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
u
.
format
.
sanitize
(
c
)
)
)
return_trace
(
false
)
;
switch
(
u
.
format
)
{
case
1
:
return_trace
(
u
.
format1
.
sanitize
(
c
)
)
;
case
2
:
return_trace
(
u
.
format2
.
sanitize
(
c
)
)
;
case
3
:
return_trace
(
u
.
format3
.
sanitize
(
c
)
)
;
default
:
return_trace
(
false
)
;
}
}
protected
:
union
{
HBUINT16
format
;
BaseCoordFormat1
format1
;
BaseCoordFormat2
format2
;
BaseCoordFormat3
format3
;
}
u
;
public
:
DEFINE_SIZE_UNION
(
2
format
)
;
}
;
struct
FeatMinMaxRecord
{
static
int
cmp
(
const
void
*
key_
const
void
*
entry_
)
{
hb_tag_t
key
=
*
(
hb_tag_t
*
)
key_
;
const
FeatMinMaxRecord
&
entry
=
*
(
const
FeatMinMaxRecord
*
)
entry_
;
return
key
<
(
unsigned
int
)
entry
.
tag
?
-
1
:
key
>
(
unsigned
int
)
entry
.
tag
?
1
:
0
;
}
void
get_min_max
(
const
BaseCoord
*
*
min
const
BaseCoord
*
*
max
)
const
{
if
(
likely
(
min
)
)
*
min
=
&
(
this
+
minCoord
)
;
if
(
likely
(
max
)
)
*
max
=
&
(
this
+
maxCoord
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
minCoord
.
sanitize
(
c
this
)
&
&
maxCoord
.
sanitize
(
c
this
)
)
)
;
}
protected
:
Tag
tag
;
OffsetTo
<
BaseCoord
>
minCoord
;
OffsetTo
<
BaseCoord
>
maxCoord
;
public
:
DEFINE_SIZE_STATIC
(
8
)
;
}
;
struct
MinMax
{
void
get_min_max
(
hb_tag_t
feature_tag
const
BaseCoord
*
*
min
const
BaseCoord
*
*
max
)
const
{
const
FeatMinMaxRecord
*
minMaxCoord
=
(
const
FeatMinMaxRecord
*
)
hb_bsearch
(
&
feature_tag
featMinMaxRecords
.
arrayZ
featMinMaxRecords
.
len
FeatMinMaxRecord
:
:
static_size
FeatMinMaxRecord
:
:
cmp
)
;
if
(
minMaxCoord
)
minMaxCoord
-
>
get_min_max
(
min
max
)
;
else
{
if
(
likely
(
min
)
)
*
min
=
&
(
this
+
minCoord
)
;
if
(
likely
(
max
)
)
*
max
=
&
(
this
+
maxCoord
)
;
}
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
minCoord
.
sanitize
(
c
this
)
&
&
maxCoord
.
sanitize
(
c
this
)
&
&
featMinMaxRecords
.
sanitize
(
c
this
)
)
)
;
}
protected
:
OffsetTo
<
BaseCoord
>
minCoord
;
OffsetTo
<
BaseCoord
>
maxCoord
;
SortedArrayOf
<
FeatMinMaxRecord
>
featMinMaxRecords
;
public
:
DEFINE_SIZE_ARRAY
(
6
featMinMaxRecords
)
;
}
;
struct
BaseValues
{
const
BaseCoord
&
get_base_coord
(
int
baseline_tag_index
)
const
{
if
(
baseline_tag_index
=
=
-
1
)
baseline_tag_index
=
defaultIndex
;
return
this
+
baseCoords
[
baseline_tag_index
]
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
baseCoords
.
sanitize
(
c
this
)
)
)
;
}
protected
:
Index
defaultIndex
;
OffsetArrayOf
<
BaseCoord
>
baseCoords
;
public
:
DEFINE_SIZE_ARRAY
(
4
baseCoords
)
;
}
;
struct
BaseLangSysRecord
{
static
int
cmp
(
const
void
*
key_
const
void
*
entry_
)
{
hb_tag_t
key
=
*
(
hb_tag_t
*
)
key_
;
const
BaseLangSysRecord
&
entry
=
*
(
const
BaseLangSysRecord
*
)
entry_
;
return
key
<
(
unsigned
int
)
entry
.
baseLangSysTag
?
-
1
:
key
>
(
unsigned
int
)
entry
.
baseLangSysTag
?
1
:
0
;
}
const
MinMax
&
get_min_max
(
)
const
{
return
this
+
minMax
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
minMax
.
sanitize
(
c
this
)
)
)
;
}
protected
:
Tag
baseLangSysTag
;
OffsetTo
<
MinMax
>
minMax
;
public
:
DEFINE_SIZE_STATIC
(
6
)
;
}
;
struct
BaseScript
{
const
MinMax
&
get_min_max
(
hb_tag_t
language_tag
)
const
{
const
BaseLangSysRecord
*
record
=
(
const
BaseLangSysRecord
*
)
hb_bsearch
(
&
language_tag
baseLangSysRecords
.
arrayZ
baseLangSysRecords
.
len
BaseLangSysRecord
:
:
static_size
BaseLangSysRecord
:
:
cmp
)
;
return
record
?
record
-
>
get_min_max
(
)
:
this
+
defaultMinMax
;
}
const
BaseCoord
&
get_base_coord
(
int
baseline_tag_index
)
const
{
return
(
this
+
baseValues
)
.
get_base_coord
(
baseline_tag_index
)
;
}
bool
is_empty
(
)
const
{
return
!
baseValues
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
baseValues
.
sanitize
(
c
this
)
&
&
defaultMinMax
.
sanitize
(
c
this
)
&
&
baseLangSysRecords
.
sanitize
(
c
this
)
)
)
;
}
protected
:
OffsetTo
<
BaseValues
>
baseValues
;
OffsetTo
<
MinMax
>
defaultMinMax
;
SortedArrayOf
<
BaseLangSysRecord
>
baseLangSysRecords
;
public
:
DEFINE_SIZE_ARRAY
(
6
baseLangSysRecords
)
;
}
;
struct
BaseScriptList
;
struct
BaseScriptRecord
{
static
int
cmp
(
const
void
*
key_
const
void
*
entry_
)
{
hb_tag_t
key
=
*
(
hb_tag_t
*
)
key_
;
const
BaseScriptRecord
&
entry
=
*
(
const
BaseScriptRecord
*
)
entry_
;
return
key
<
(
unsigned
int
)
entry
.
baseScriptTag
?
-
1
:
key
>
(
unsigned
int
)
entry
.
baseScriptTag
?
1
:
0
;
}
const
BaseScript
&
get_base_script
(
const
BaseScriptList
*
list
)
const
{
return
list
+
baseScript
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
baseScript
.
sanitize
(
c
base
)
)
)
;
}
protected
:
Tag
baseScriptTag
;
OffsetTo
<
BaseScript
>
baseScript
;
public
:
DEFINE_SIZE_STATIC
(
6
)
;
}
;
struct
BaseScriptList
{
const
BaseScriptRecord
*
find_record
(
hb_tag_t
script
)
const
{
return
(
const
BaseScriptRecord
*
)
hb_bsearch
(
&
script
baseScriptRecords
.
arrayZ
baseScriptRecords
.
len
BaseScriptRecord
:
:
static_size
BaseScriptRecord
:
:
cmp
)
;
}
const
BaseScript
&
get_base_script
(
hb_tag_t
script
)
const
{
const
BaseScriptRecord
*
record
=
find_record
(
script
)
;
if
(
!
record
)
record
=
find_record
(
(
hb_script_t
)
HB_TAG
(
'
D
'
'
F
'
'
L
'
'
T
'
)
)
;
return
record
?
record
-
>
get_base_script
(
this
)
:
Null
(
BaseScript
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
baseScriptRecords
.
sanitize
(
c
this
)
)
;
}
protected
:
SortedArrayOf
<
BaseScriptRecord
>
baseScriptRecords
;
public
:
DEFINE_SIZE_ARRAY
(
2
baseScriptRecords
)
;
}
;
struct
Axis
{
bool
get_baseline
(
hb_ot_layout_baseline_t
baseline
hb_tag_t
script_tag
hb_tag_t
language_tag
const
BaseCoord
*
*
coord
)
const
{
const
BaseScript
&
base_script
=
(
this
+
baseScriptList
)
.
get_base_script
(
script_tag
)
;
if
(
base_script
.
is_empty
(
)
)
return
false
;
if
(
likely
(
coord
)
)
*
coord
=
&
base_script
.
get_base_coord
(
(
this
+
baseTagList
)
.
bsearch
(
baseline
)
)
;
return
true
;
}
bool
get_min_max
(
hb_tag_t
script_tag
hb_tag_t
language_tag
hb_tag_t
feature_tag
const
BaseCoord
*
*
min_coord
const
BaseCoord
*
*
max_coord
)
const
{
const
BaseScript
&
base_script
=
(
this
+
baseScriptList
)
.
get_base_script
(
script_tag
)
;
if
(
base_script
.
is_empty
(
)
)
return
false
;
base_script
.
get_min_max
(
language_tag
)
.
get_min_max
(
feature_tag
min_coord
max_coord
)
;
return
true
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
(
this
+
baseTagList
)
.
sanitize
(
c
)
&
&
(
this
+
baseScriptList
)
.
sanitize
(
c
)
)
)
;
}
protected
:
OffsetTo
<
SortedArrayOf
<
Tag
>
>
baseTagList
;
OffsetTo
<
BaseScriptList
>
baseScriptList
;
public
:
DEFINE_SIZE_STATIC
(
4
)
;
}
;
struct
BASE
{
static
constexpr
hb_tag_t
tableTag
=
HB_OT_TAG_BASE
;
const
Axis
&
get_axis
(
hb_direction_t
direction
)
const
{
return
HB_DIRECTION_IS_VERTICAL
(
direction
)
?
this
+
vAxis
:
this
+
hAxis
;
}
const
VariationStore
&
get_var_store
(
)
const
{
return
version
.
to_int
(
)
<
0x00010001u
?
Null
(
VariationStore
)
:
this
+
varStore
;
}
bool
get_baseline
(
hb_font_t
*
font
hb_ot_layout_baseline_t
baseline
hb_direction_t
direction
hb_tag_t
script_tag
hb_tag_t
language_tag
hb_position_t
*
base
)
const
{
const
BaseCoord
*
base_coord
;
if
(
!
get_axis
(
direction
)
.
get_baseline
(
baseline
script_tag
language_tag
&
base_coord
)
)
return
false
;
if
(
likely
(
base
&
&
base_coord
)
)
*
base
=
base_coord
-
>
get_coord
(
font
get_var_store
(
)
direction
)
;
return
true
;
}
bool
get_min_max
(
hb_font_t
*
font
hb_direction_t
direction
hb_tag_t
script_tag
hb_tag_t
language_tag
hb_tag_t
feature_tag
hb_position_t
*
min
hb_position_t
*
max
)
{
const
BaseCoord
*
min_coord
*
max_coord
;
if
(
!
get_axis
(
direction
)
.
get_min_max
(
script_tag
language_tag
feature_tag
&
min_coord
&
max_coord
)
)
return
false
;
const
VariationStore
&
var_store
=
get_var_store
(
)
;
if
(
likely
(
min
&
&
min_coord
)
)
*
min
=
min_coord
-
>
get_coord
(
font
var_store
direction
)
;
if
(
likely
(
max
&
&
max_coord
)
)
*
max
=
max_coord
-
>
get_coord
(
font
var_store
direction
)
;
return
true
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
likely
(
version
.
major
=
=
1
)
&
&
hAxis
.
sanitize
(
c
this
)
&
&
vAxis
.
sanitize
(
c
this
)
&
&
(
version
.
to_int
(
)
<
0x00010001u
|
|
varStore
.
sanitize
(
c
this
)
)
)
)
;
}
protected
:
FixedVersion
<
>
version
;
OffsetTo
<
Axis
>
hAxis
;
OffsetTo
<
Axis
>
vAxis
;
LOffsetTo
<
VariationStore
>
varStore
;
public
:
DEFINE_SIZE_MIN
(
8
)
;
}
;
}
#
endif
