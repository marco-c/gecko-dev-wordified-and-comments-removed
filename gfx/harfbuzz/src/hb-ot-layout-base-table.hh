#
ifndef
HB_OT_LAYOUT_BASE_TABLE_HH
#
define
HB_OT_LAYOUT_BASE_TABLE_HH
#
include
"
hb
-
open
-
type
.
hh
"
#
include
"
hb
-
ot
-
layout
-
common
.
hh
"
namespace
OT
{
struct
BaseCoordFormat1
{
hb_position_t
get_coord
(
hb_font_t
*
font
hb_direction_t
direction
)
const
{
return
HB_DIRECTION_IS_HORIZONTAL
(
direction
)
?
font
-
>
em_scale_y
(
coordinate
)
:
font
-
>
em_scale_x
(
coordinate
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
)
)
;
}
protected
:
HBUINT16
format
;
FWORD
coordinate
;
public
:
DEFINE_SIZE_STATIC
(
4
)
;
}
;
struct
BaseCoordFormat2
{
hb_position_t
get_coord
(
hb_font_t
*
font
hb_direction_t
direction
)
const
{
return
HB_DIRECTION_IS_HORIZONTAL
(
direction
)
?
font
-
>
em_scale_y
(
coordinate
)
:
font
-
>
em_scale_x
(
coordinate
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
protected
:
HBUINT16
format
;
FWORD
coordinate
;
HBGlyphID16
referenceGlyph
;
HBUINT16
coordPoint
;
public
:
DEFINE_SIZE_STATIC
(
8
)
;
}
;
struct
BaseCoordFormat3
{
hb_position_t
get_coord
(
hb_font_t
*
font
const
VariationStore
&
var_store
hb_direction_t
direction
)
const
{
const
Device
&
device
=
this
+
deviceTable
;
return
HB_DIRECTION_IS_HORIZONTAL
(
direction
)
?
font
-
>
em_scale_y
(
coordinate
)
+
device
.
get_y_delta
(
font
var_store
)
:
font
-
>
em_scale_x
(
coordinate
)
+
device
.
get_x_delta
(
font
var_store
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
deviceTable
.
sanitize
(
c
this
)
)
)
;
}
protected
:
HBUINT16
format
;
FWORD
coordinate
;
Offset16To
<
Device
>
deviceTable
;
public
:
DEFINE_SIZE_STATIC
(
6
)
;
}
;
struct
BaseCoord
{
bool
has_data
(
)
const
{
return
u
.
format
;
}
hb_position_t
get_coord
(
hb_font_t
*
font
const
VariationStore
&
var_store
hb_direction_t
direction
)
const
{
switch
(
u
.
format
)
{
case
1
:
return
u
.
format1
.
get_coord
(
font
direction
)
;
case
2
:
return
u
.
format2
.
get_coord
(
font
direction
)
;
case
3
:
return
u
.
format3
.
get_coord
(
font
var_store
direction
)
;
default
:
return
0
;
}
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
u
.
format
.
sanitize
(
c
)
)
)
return_trace
(
false
)
;
switch
(
u
.
format
)
{
case
1
:
return_trace
(
u
.
format1
.
sanitize
(
c
)
)
;
case
2
:
return_trace
(
u
.
format2
.
sanitize
(
c
)
)
;
case
3
:
return_trace
(
u
.
format3
.
sanitize
(
c
)
)
;
default
:
return_trace
(
false
)
;
}
}
protected
:
union
{
HBUINT16
format
;
BaseCoordFormat1
format1
;
BaseCoordFormat2
format2
;
BaseCoordFormat3
format3
;
}
u
;
public
:
DEFINE_SIZE_UNION
(
2
format
)
;
}
;
struct
FeatMinMaxRecord
{
int
cmp
(
hb_tag_t
key
)
const
{
return
tag
.
cmp
(
key
)
;
}
bool
has_data
(
)
const
{
return
tag
;
}
void
get_min_max
(
const
BaseCoord
*
*
min
const
BaseCoord
*
*
max
)
const
{
if
(
likely
(
min
)
)
*
min
=
&
(
this
+
minCoord
)
;
if
(
likely
(
max
)
)
*
max
=
&
(
this
+
maxCoord
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
minCoord
.
sanitize
(
c
this
)
&
&
maxCoord
.
sanitize
(
c
this
)
)
)
;
}
protected
:
Tag
tag
;
Offset16To
<
BaseCoord
>
minCoord
;
Offset16To
<
BaseCoord
>
maxCoord
;
public
:
DEFINE_SIZE_STATIC
(
8
)
;
}
;
struct
MinMax
{
void
get_min_max
(
hb_tag_t
feature_tag
const
BaseCoord
*
*
min
const
BaseCoord
*
*
max
)
const
{
const
FeatMinMaxRecord
&
minMaxCoord
=
featMinMaxRecords
.
bsearch
(
feature_tag
)
;
if
(
minMaxCoord
.
has_data
(
)
)
minMaxCoord
.
get_min_max
(
min
max
)
;
else
{
if
(
likely
(
min
)
)
*
min
=
&
(
this
+
minCoord
)
;
if
(
likely
(
max
)
)
*
max
=
&
(
this
+
maxCoord
)
;
}
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
minCoord
.
sanitize
(
c
this
)
&
&
maxCoord
.
sanitize
(
c
this
)
&
&
featMinMaxRecords
.
sanitize
(
c
this
)
)
)
;
}
protected
:
Offset16To
<
BaseCoord
>
minCoord
;
Offset16To
<
BaseCoord
>
maxCoord
;
SortedArray16Of
<
FeatMinMaxRecord
>
featMinMaxRecords
;
public
:
DEFINE_SIZE_ARRAY
(
6
featMinMaxRecords
)
;
}
;
struct
BaseValues
{
const
BaseCoord
&
get_base_coord
(
int
baseline_tag_index
)
const
{
if
(
baseline_tag_index
=
=
-
1
)
baseline_tag_index
=
defaultIndex
;
return
this
+
baseCoords
[
baseline_tag_index
]
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
baseCoords
.
sanitize
(
c
this
)
)
)
;
}
protected
:
Index
defaultIndex
;
Array16OfOffset16To
<
BaseCoord
>
baseCoords
;
public
:
DEFINE_SIZE_ARRAY
(
4
baseCoords
)
;
}
;
struct
BaseLangSysRecord
{
int
cmp
(
hb_tag_t
key
)
const
{
return
baseLangSysTag
.
cmp
(
key
)
;
}
bool
has_data
(
)
const
{
return
baseLangSysTag
;
}
const
MinMax
&
get_min_max
(
)
const
{
return
this
+
minMax
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
minMax
.
sanitize
(
c
this
)
)
)
;
}
protected
:
Tag
baseLangSysTag
;
Offset16To
<
MinMax
>
minMax
;
public
:
DEFINE_SIZE_STATIC
(
6
)
;
}
;
struct
BaseScript
{
const
MinMax
&
get_min_max
(
hb_tag_t
language_tag
)
const
{
const
BaseLangSysRecord
&
record
=
baseLangSysRecords
.
bsearch
(
language_tag
)
;
return
record
.
has_data
(
)
?
record
.
get_min_max
(
)
:
this
+
defaultMinMax
;
}
const
BaseCoord
&
get_base_coord
(
int
baseline_tag_index
)
const
{
return
(
this
+
baseValues
)
.
get_base_coord
(
baseline_tag_index
)
;
}
bool
has_data
(
)
const
{
return
baseValues
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
baseValues
.
sanitize
(
c
this
)
&
&
defaultMinMax
.
sanitize
(
c
this
)
&
&
baseLangSysRecords
.
sanitize
(
c
this
)
)
)
;
}
protected
:
Offset16To
<
BaseValues
>
baseValues
;
Offset16To
<
MinMax
>
defaultMinMax
;
SortedArray16Of
<
BaseLangSysRecord
>
baseLangSysRecords
;
public
:
DEFINE_SIZE_ARRAY
(
6
baseLangSysRecords
)
;
}
;
struct
BaseScriptList
;
struct
BaseScriptRecord
{
int
cmp
(
hb_tag_t
key
)
const
{
return
baseScriptTag
.
cmp
(
key
)
;
}
bool
has_data
(
)
const
{
return
baseScriptTag
;
}
const
BaseScript
&
get_base_script
(
const
BaseScriptList
*
list
)
const
{
return
list
+
baseScript
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
baseScript
.
sanitize
(
c
base
)
)
)
;
}
protected
:
Tag
baseScriptTag
;
Offset16To
<
BaseScript
>
baseScript
;
public
:
DEFINE_SIZE_STATIC
(
6
)
;
}
;
struct
BaseScriptList
{
const
BaseScript
&
get_base_script
(
hb_tag_t
script
)
const
{
const
BaseScriptRecord
*
record
=
&
baseScriptRecords
.
bsearch
(
script
)
;
if
(
!
record
-
>
has_data
(
)
)
record
=
&
baseScriptRecords
.
bsearch
(
HB_TAG
(
'
D
'
'
F
'
'
L
'
'
T
'
)
)
;
return
record
-
>
has_data
(
)
?
record
-
>
get_base_script
(
this
)
:
Null
(
BaseScript
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
baseScriptRecords
.
sanitize
(
c
this
)
)
;
}
protected
:
SortedArray16Of
<
BaseScriptRecord
>
baseScriptRecords
;
public
:
DEFINE_SIZE_ARRAY
(
2
baseScriptRecords
)
;
}
;
struct
Axis
{
bool
get_baseline
(
hb_tag_t
baseline_tag
hb_tag_t
script_tag
hb_tag_t
language_tag
const
BaseCoord
*
*
coord
)
const
{
const
BaseScript
&
base_script
=
(
this
+
baseScriptList
)
.
get_base_script
(
script_tag
)
;
if
(
!
base_script
.
has_data
(
)
)
{
*
coord
=
nullptr
;
return
false
;
}
if
(
likely
(
coord
)
)
{
unsigned
int
tag_index
=
0
;
if
(
!
(
this
+
baseTagList
)
.
bfind
(
baseline_tag
&
tag_index
)
)
{
*
coord
=
nullptr
;
return
false
;
}
*
coord
=
&
base_script
.
get_base_coord
(
tag_index
)
;
}
return
true
;
}
bool
get_min_max
(
hb_tag_t
script_tag
hb_tag_t
language_tag
hb_tag_t
feature_tag
const
BaseCoord
*
*
min_coord
const
BaseCoord
*
*
max_coord
)
const
{
const
BaseScript
&
base_script
=
(
this
+
baseScriptList
)
.
get_base_script
(
script_tag
)
;
if
(
!
base_script
.
has_data
(
)
)
{
*
min_coord
=
*
max_coord
=
nullptr
;
return
false
;
}
base_script
.
get_min_max
(
language_tag
)
.
get_min_max
(
feature_tag
min_coord
max_coord
)
;
return
true
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
(
this
+
baseTagList
)
.
sanitize
(
c
)
&
&
(
this
+
baseScriptList
)
.
sanitize
(
c
)
)
)
;
}
protected
:
Offset16To
<
SortedArray16Of
<
Tag
>
>
baseTagList
;
Offset16To
<
BaseScriptList
>
baseScriptList
;
public
:
DEFINE_SIZE_STATIC
(
4
)
;
}
;
struct
BASE
{
static
constexpr
hb_tag_t
tableTag
=
HB_OT_TAG_BASE
;
const
Axis
&
get_axis
(
hb_direction_t
direction
)
const
{
return
HB_DIRECTION_IS_VERTICAL
(
direction
)
?
this
+
vAxis
:
this
+
hAxis
;
}
const
VariationStore
&
get_var_store
(
)
const
{
return
version
.
to_int
(
)
<
0x00010001u
?
Null
(
VariationStore
)
:
this
+
varStore
;
}
bool
get_baseline
(
hb_font_t
*
font
hb_tag_t
baseline_tag
hb_direction_t
direction
hb_tag_t
script_tag
hb_tag_t
language_tag
hb_position_t
*
base
)
const
{
const
BaseCoord
*
base_coord
=
nullptr
;
if
(
unlikely
(
!
get_axis
(
direction
)
.
get_baseline
(
baseline_tag
script_tag
language_tag
&
base_coord
)
|
|
!
base_coord
|
|
!
base_coord
-
>
has_data
(
)
)
)
return
false
;
if
(
likely
(
base
)
)
*
base
=
base_coord
-
>
get_coord
(
font
get_var_store
(
)
direction
)
;
return
true
;
}
bool
get_min_max
(
hb_font_t
*
font
hb_direction_t
direction
hb_tag_t
script_tag
hb_tag_t
language_tag
hb_tag_t
feature_tag
hb_position_t
*
min
hb_position_t
*
max
)
{
const
BaseCoord
*
min_coord
*
max_coord
;
if
(
!
get_axis
(
direction
)
.
get_min_max
(
script_tag
language_tag
feature_tag
&
min_coord
&
max_coord
)
)
return
false
;
const
VariationStore
&
var_store
=
get_var_store
(
)
;
if
(
likely
(
min
&
&
min_coord
)
)
*
min
=
min_coord
-
>
get_coord
(
font
var_store
direction
)
;
if
(
likely
(
max
&
&
max_coord
)
)
*
max
=
max_coord
-
>
get_coord
(
font
var_store
direction
)
;
return
true
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
likely
(
version
.
major
=
=
1
)
&
&
hAxis
.
sanitize
(
c
this
)
&
&
vAxis
.
sanitize
(
c
this
)
&
&
(
version
.
to_int
(
)
<
0x00010001u
|
|
varStore
.
sanitize
(
c
this
)
)
)
)
;
}
protected
:
FixedVersion
<
>
version
;
Offset16To
<
Axis
>
hAxis
;
Offset16To
<
Axis
>
vAxis
;
Offset32To
<
VariationStore
>
varStore
;
public
:
DEFINE_SIZE_MIN
(
8
)
;
}
;
}
#
endif
