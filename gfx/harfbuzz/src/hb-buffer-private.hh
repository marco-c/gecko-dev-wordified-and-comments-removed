#
ifndef
HB_BUFFER_PRIVATE_HH
#
define
HB_BUFFER_PRIVATE_HH
#
include
"
hb
-
private
.
hh
"
#
include
"
hb
-
object
-
private
.
hh
"
#
include
"
hb
-
unicode
-
private
.
hh
"
#
ifndef
HB_BUFFER_MAX_EXPANSION_FACTOR
#
define
HB_BUFFER_MAX_EXPANSION_FACTOR
32
#
endif
#
ifndef
HB_BUFFER_MAX_LEN_MIN
#
define
HB_BUFFER_MAX_LEN_MIN
8192
#
endif
#
ifndef
HB_BUFFER_MAX_LEN_DEFAULT
#
define
HB_BUFFER_MAX_LEN_DEFAULT
0x3FFFFFFF
/
*
Shaping
more
than
a
billion
chars
?
Let
us
know
!
*
/
#
endif
ASSERT_STATIC
(
sizeof
(
hb_glyph_info_t
)
=
=
20
)
;
ASSERT_STATIC
(
sizeof
(
hb_glyph_info_t
)
=
=
sizeof
(
hb_glyph_position_t
)
)
;
HB_MARK_AS_FLAG_T
(
hb_buffer_flags_t
)
;
HB_MARK_AS_FLAG_T
(
hb_buffer_serialize_flags_t
)
;
enum
hb_buffer_scratch_flags_t
{
HB_BUFFER_SCRATCH_FLAG_DEFAULT
=
0x00000000u
HB_BUFFER_SCRATCH_FLAG_HAS_NON_ASCII
=
0x00000001u
HB_BUFFER_SCRATCH_FLAG_HAS_DEFAULT_IGNORABLES
=
0x00000002u
HB_BUFFER_SCRATCH_FLAG_HAS_SPACE_FALLBACK
=
0x00000004u
HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_CURSIVE
=
0x00000008u
HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT
=
0x00000010u
HB_BUFFER_SCRATCH_FLAG_COMPLEX0
=
0x01000000u
HB_BUFFER_SCRATCH_FLAG_COMPLEX1
=
0x02000000u
HB_BUFFER_SCRATCH_FLAG_COMPLEX2
=
0x04000000u
HB_BUFFER_SCRATCH_FLAG_COMPLEX3
=
0x08000000u
}
;
HB_MARK_AS_FLAG_T
(
hb_buffer_scratch_flags_t
)
;
struct
hb_buffer_t
{
hb_object_header_t
header
;
ASSERT_POD
(
)
;
hb_unicode_funcs_t
*
unicode
;
hb_buffer_flags_t
flags
;
hb_buffer_cluster_level_t
cluster_level
;
hb_codepoint_t
replacement
;
hb_buffer_scratch_flags_t
scratch_flags
;
unsigned
int
max_len
;
hb_buffer_content_type_t
content_type
;
hb_segment_properties_t
props
;
bool
in_error
;
bool
have_output
;
bool
have_positions
;
unsigned
int
idx
;
unsigned
int
len
;
unsigned
int
out_len
;
unsigned
int
allocated
;
hb_glyph_info_t
*
info
;
hb_glyph_info_t
*
out_info
;
hb_glyph_position_t
*
pos
;
inline
hb_glyph_info_t
&
cur
(
unsigned
int
i
=
0
)
{
return
info
[
idx
+
i
]
;
}
inline
hb_glyph_info_t
cur
(
unsigned
int
i
=
0
)
const
{
return
info
[
idx
+
i
]
;
}
inline
hb_glyph_position_t
&
cur_pos
(
unsigned
int
i
=
0
)
{
return
pos
[
idx
+
i
]
;
}
inline
hb_glyph_position_t
cur_pos
(
unsigned
int
i
=
0
)
const
{
return
pos
[
idx
+
i
]
;
}
inline
hb_glyph_info_t
&
prev
(
void
)
{
return
out_info
[
out_len
?
out_len
-
1
:
0
]
;
}
inline
hb_glyph_info_t
prev
(
void
)
const
{
return
out_info
[
out_len
?
out_len
-
1
:
0
]
;
}
inline
bool
has_separate_output
(
void
)
const
{
return
info
!
=
out_info
;
}
unsigned
int
serial
;
uint8_t
allocated_var_bytes
[
8
]
;
const
char
*
allocated_var_owner
[
8
]
;
static
const
unsigned
int
CONTEXT_LENGTH
=
5
;
hb_codepoint_t
context
[
2
]
[
CONTEXT_LENGTH
]
;
unsigned
int
context_len
[
2
]
;
hb_buffer_message_func_t
message_func
;
void
*
message_data
;
hb_destroy_func_t
message_destroy
;
HB_INTERNAL
void
reset
(
void
)
;
HB_INTERNAL
void
clear
(
void
)
;
inline
unsigned
int
backtrack_len
(
void
)
const
{
return
have_output
?
out_len
:
idx
;
}
inline
unsigned
int
lookahead_len
(
void
)
const
{
return
len
-
idx
;
}
inline
unsigned
int
next_serial
(
void
)
{
return
serial
+
+
;
}
HB_INTERNAL
void
allocate_var
(
unsigned
int
byte_i
unsigned
int
count
const
char
*
owner
)
;
HB_INTERNAL
void
deallocate_var
(
unsigned
int
byte_i
unsigned
int
count
const
char
*
owner
)
;
HB_INTERNAL
void
assert_var
(
unsigned
int
byte_i
unsigned
int
count
const
char
*
owner
)
;
HB_INTERNAL
void
deallocate_var_all
(
void
)
;
HB_INTERNAL
void
add
(
hb_codepoint_t
codepoint
unsigned
int
cluster
)
;
HB_INTERNAL
void
add_info
(
const
hb_glyph_info_t
&
glyph_info
)
;
HB_INTERNAL
void
reverse_range
(
unsigned
int
start
unsigned
int
end
)
;
HB_INTERNAL
void
reverse
(
void
)
;
HB_INTERNAL
void
reverse_clusters
(
void
)
;
HB_INTERNAL
void
guess_segment_properties
(
void
)
;
HB_INTERNAL
void
swap_buffers
(
void
)
;
HB_INTERNAL
void
remove_output
(
void
)
;
HB_INTERNAL
void
clear_output
(
void
)
;
HB_INTERNAL
void
clear_positions
(
void
)
;
HB_INTERNAL
void
replace_glyphs
(
unsigned
int
num_in
unsigned
int
num_out
const
hb_codepoint_t
*
glyph_data
)
;
HB_INTERNAL
void
replace_glyph
(
hb_codepoint_t
glyph_index
)
;
HB_INTERNAL
void
output_glyph
(
hb_codepoint_t
glyph_index
)
;
HB_INTERNAL
void
output_info
(
const
hb_glyph_info_t
&
glyph_info
)
;
HB_INTERNAL
void
copy_glyph
(
void
)
;
HB_INTERNAL
bool
move_to
(
unsigned
int
i
)
;
inline
void
next_glyph
(
void
)
{
if
(
have_output
)
{
if
(
unlikely
(
out_info
!
=
info
|
|
out_len
!
=
idx
)
)
{
if
(
unlikely
(
!
make_room_for
(
1
1
)
)
)
return
;
out_info
[
out_len
]
=
info
[
idx
]
;
}
out_len
+
+
;
}
idx
+
+
;
}
inline
void
skip_glyph
(
void
)
{
idx
+
+
;
}
inline
void
reset_masks
(
hb_mask_t
mask
)
{
for
(
unsigned
int
j
=
0
;
j
<
len
;
j
+
+
)
info
[
j
]
.
mask
=
mask
;
}
inline
void
add_masks
(
hb_mask_t
mask
)
{
for
(
unsigned
int
j
=
0
;
j
<
len
;
j
+
+
)
info
[
j
]
.
mask
|
=
mask
;
}
HB_INTERNAL
void
set_masks
(
hb_mask_t
value
hb_mask_t
mask
unsigned
int
cluster_start
unsigned
int
cluster_end
)
;
HB_INTERNAL
void
merge_clusters
(
unsigned
int
start
unsigned
int
end
)
{
if
(
end
-
start
<
2
)
return
;
merge_clusters_impl
(
start
end
)
;
}
HB_INTERNAL
void
merge_clusters_impl
(
unsigned
int
start
unsigned
int
end
)
;
HB_INTERNAL
void
merge_out_clusters
(
unsigned
int
start
unsigned
int
end
)
;
HB_INTERNAL
void
delete_glyph
(
void
)
;
HB_INTERNAL
bool
enlarge
(
unsigned
int
size
)
;
inline
bool
ensure
(
unsigned
int
size
)
{
return
likely
(
!
size
|
|
size
<
allocated
)
?
true
:
enlarge
(
size
)
;
}
inline
bool
ensure_inplace
(
unsigned
int
size
)
{
return
likely
(
!
size
|
|
size
<
allocated
)
;
}
HB_INTERNAL
bool
make_room_for
(
unsigned
int
num_in
unsigned
int
num_out
)
;
HB_INTERNAL
bool
shift_forward
(
unsigned
int
count
)
;
typedef
long
scratch_buffer_t
;
HB_INTERNAL
scratch_buffer_t
*
get_scratch_buffer
(
unsigned
int
*
size
)
;
inline
void
clear_context
(
unsigned
int
side
)
{
context_len
[
side
]
=
0
;
}
HB_INTERNAL
void
sort
(
unsigned
int
start
unsigned
int
end
int
(
*
compar
)
(
const
hb_glyph_info_t
*
const
hb_glyph_info_t
*
)
)
;
inline
bool
messaging
(
void
)
{
return
unlikely
(
message_func
)
;
}
inline
bool
message
(
hb_font_t
*
font
const
char
*
fmt
.
.
.
)
HB_PRINTF_FUNC
(
3
4
)
{
if
(
!
messaging
(
)
)
return
true
;
va_list
ap
;
va_start
(
ap
fmt
)
;
bool
ret
=
message_impl
(
font
fmt
ap
)
;
va_end
(
ap
)
;
return
ret
;
}
HB_INTERNAL
bool
message_impl
(
hb_font_t
*
font
const
char
*
fmt
va_list
ap
)
HB_PRINTF_FUNC
(
3
0
)
;
}
;
#
define
HB_BUFFER_XALLOCATE_VAR
(
b
func
var
owner
)
\
b
-
>
func
(
offsetof
(
hb_glyph_info_t
var
)
-
offsetof
(
hb_glyph_info_t
var1
)
\
sizeof
(
b
-
>
info
[
0
]
.
var
)
owner
)
#
define
HB_BUFFER_ALLOCATE_VAR
(
b
var
)
\
HB_BUFFER_XALLOCATE_VAR
(
b
allocate_var
var
(
)
#
var
)
#
define
HB_BUFFER_DEALLOCATE_VAR
(
b
var
)
\
HB_BUFFER_XALLOCATE_VAR
(
b
deallocate_var
var
(
)
#
var
)
#
define
HB_BUFFER_ASSERT_VAR
(
b
var
)
\
HB_BUFFER_XALLOCATE_VAR
(
b
assert_var
var
(
)
#
var
)
#
endif
