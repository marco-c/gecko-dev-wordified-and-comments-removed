#
ifndef
HB_AAT_LAYOUT_KERX_TABLE_HH
#
define
HB_AAT_LAYOUT_KERX_TABLE_HH
#
include
"
hb
-
open
-
type
-
private
.
hh
"
#
include
"
hb
-
aat
-
layout
-
common
-
private
.
hh
"
#
include
"
hb
-
aat
-
layout
-
ankr
-
table
.
hh
"
#
define
HB_AAT_TAG_kerx
HB_TAG
(
'
k
'
'
e
'
'
r
'
'
x
'
)
namespace
AAT
{
using
namespace
OT
;
struct
KerxFormat0Records
{
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
)
)
;
}
protected
:
GlyphID
left
;
GlyphID
right
;
FWORD
value
;
public
:
DEFINE_SIZE_STATIC
(
6
)
;
}
;
struct
KerxSubTableFormat0
{
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
recordsZ
.
sanitize
(
c
nPairs
)
)
)
;
}
protected
:
HBUINT32
nPairs
;
HBUINT32
searchRange
;
HBUINT32
entrySelector
;
HBUINT32
rangeShift
;
UnsizedArrayOf
<
KerxFormat0Records
>
recordsZ
;
public
:
DEFINE_SIZE_ARRAY
(
16
recordsZ
)
;
}
;
struct
KerxSubTableFormat1
{
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
stateHeader
.
sanitize
(
c
)
)
)
;
}
protected
:
StateTable
<
HBUINT16
>
stateHeader
;
LOffsetTo
<
ArrayOf
<
HBUINT16
>
>
valueTable
;
public
:
DEFINE_SIZE_STATIC
(
20
)
;
}
;
struct
KerxClassTable
{
inline
unsigned
int
get_class
(
hb_codepoint_t
g
)
const
{
return
classes
[
g
-
firstGlyph
]
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
firstGlyph
.
sanitize
(
c
)
&
&
classes
.
sanitize
(
c
)
)
)
;
}
protected
:
HBUINT16
firstGlyph
;
ArrayOf
<
HBUINT16
>
classes
;
public
:
DEFINE_SIZE_ARRAY
(
4
classes
)
;
}
;
struct
KerxSubTableFormat2
{
inline
int
get_kerning
(
hb_codepoint_t
left
hb_codepoint_t
right
const
char
*
end
)
const
{
unsigned
int
l
=
(
this
+
leftClassTable
)
.
get_class
(
left
)
;
unsigned
int
r
=
(
this
+
leftClassTable
)
.
get_class
(
left
)
;
unsigned
int
offset
=
l
*
rowWidth
+
r
*
sizeof
(
FWORD
)
;
const
FWORD
*
arr
=
&
(
this
+
array
)
;
if
(
unlikely
(
(
const
void
*
)
arr
<
(
const
void
*
)
this
|
|
(
const
void
*
)
arr
>
=
(
const
void
*
)
end
)
)
return
0
;
const
FWORD
*
v
=
&
StructAtOffset
<
FWORD
>
(
arr
offset
)
;
if
(
unlikely
(
(
const
void
*
)
v
<
(
const
void
*
)
arr
|
|
(
const
void
*
)
(
v
+
1
)
>
(
const
void
*
)
end
)
)
return
0
;
return
*
v
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
rowWidth
.
sanitize
(
c
)
&
&
leftClassTable
.
sanitize
(
c
this
)
&
&
rightClassTable
.
sanitize
(
c
this
)
&
&
array
.
sanitize
(
c
this
)
)
)
;
}
protected
:
HBUINT32
rowWidth
;
LOffsetTo
<
KerxClassTable
>
leftClassTable
;
LOffsetTo
<
KerxClassTable
>
rightClassTable
;
LOffsetTo
<
FWORD
>
array
;
public
:
DEFINE_SIZE_STATIC
(
16
)
;
}
;
struct
KerxSubTableFormat4
{
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
rowWidth
.
sanitize
(
c
)
&
&
leftClassTable
.
sanitize
(
c
this
)
&
&
rightClassTable
.
sanitize
(
c
this
)
&
&
array
.
sanitize
(
c
this
)
)
)
;
}
protected
:
HBUINT32
rowWidth
;
LOffsetTo
<
KerxClassTable
>
leftClassTable
;
LOffsetTo
<
KerxClassTable
>
rightClassTable
;
LOffsetTo
<
FWORD
>
array
;
public
:
DEFINE_SIZE_STATIC
(
16
)
;
}
;
struct
KerxSubTableFormat6
{
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
rowIndexTable
.
sanitize
(
c
this
)
&
&
columnIndexTable
.
sanitize
(
c
this
)
&
&
kerningArray
.
sanitize
(
c
this
)
&
&
kerningVector
.
sanitize
(
c
this
)
)
)
;
}
protected
:
HBUINT32
flags
;
HBUINT16
rowCount
;
HBUINT16
columnCount
;
LOffsetTo
<
Lookup
<
HBUINT16
>
>
rowIndexTable
;
LOffsetTo
<
Lookup
<
HBUINT16
>
>
columnIndexTable
;
LOffsetTo
<
Lookup
<
HBUINT16
>
>
kerningArray
;
LOffsetTo
<
Lookup
<
HBUINT16
>
>
kerningVector
;
public
:
DEFINE_SIZE_STATIC
(
24
)
;
}
;
enum
coverage_flags_t
{
COVERAGE_VERTICAL_FLAG
=
0x80u
COVERAGE_CROSSSTREAM_FLAG
=
0x40u
COVERAGE_VARIATION_FLAG
=
0x20u
COVERAGE_PROCESS_DIRECTION
=
0x10u
}
;
struct
KerxTable
{
inline
bool
apply
(
hb_aat_apply_context_t
*
c
const
AAT
:
:
ankr
*
ankr
)
const
{
TRACE_APPLY
(
this
)
;
return_trace
(
false
)
;
}
inline
unsigned
int
get_size
(
void
)
const
{
return
length
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
c
-
>
check_struct
(
this
)
)
)
return_trace
(
false
)
;
switch
(
format
)
{
case
0
:
return
u
.
format0
.
sanitize
(
c
)
;
case
1
:
return
u
.
format1
.
sanitize
(
c
)
;
case
2
:
return
u
.
format2
.
sanitize
(
c
)
;
case
4
:
return
u
.
format4
.
sanitize
(
c
)
;
case
6
:
return
u
.
format6
.
sanitize
(
c
)
;
default
:
return_trace
(
false
)
;
}
}
protected
:
HBUINT32
length
;
HBUINT8
coverage
;
HBUINT16
unused
;
HBUINT8
format
;
HBUINT32
tupleIndex
;
union
{
KerxSubTableFormat0
format0
;
KerxSubTableFormat1
format1
;
KerxSubTableFormat2
format2
;
KerxSubTableFormat4
format4
;
KerxSubTableFormat6
format6
;
}
u
;
public
:
DEFINE_SIZE_MIN
(
12
)
;
}
;
struct
SubtableGlyphCoverageArray
{
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
)
)
;
}
protected
:
HBUINT32
length
;
HBUINT32
coverage
;
HBUINT32
tupleCount
;
public
:
DEFINE_SIZE_STATIC
(
12
)
;
}
;
struct
kerx
{
static
const
hb_tag_t
tableTag
=
HB_AAT_TAG_kerx
;
inline
bool
apply
(
hb_aat_apply_context_t
*
c
const
AAT
:
:
ankr
*
ankr
)
const
{
TRACE_APPLY
(
this
)
;
const
KerxTable
&
table
=
StructAfter
<
KerxTable
>
(
*
this
)
;
return_trace
(
table
.
apply
(
c
ankr
)
)
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
(
c
-
>
check_struct
(
this
)
)
)
)
return_trace
(
false
)
;
const
KerxTable
*
table
=
&
StructAfter
<
KerxTable
>
(
*
this
)
;
if
(
unlikely
(
!
(
table
-
>
sanitize
(
c
)
)
)
)
return_trace
(
false
)
;
for
(
unsigned
int
i
=
0
;
i
<
nTables
-
1
;
+
+
i
)
{
table
=
&
StructAfter
<
KerxTable
>
(
*
table
)
;
if
(
unlikely
(
!
(
table
-
>
sanitize
(
c
)
)
)
)
return_trace
(
false
)
;
}
if
(
version
<
3
)
return_trace
(
true
)
;
return_trace
(
true
)
;
}
protected
:
HBUINT16
version
;
HBUINT16
padding
;
HBUINT32
nTables
;
public
:
DEFINE_SIZE_STATIC
(
8
)
;
}
;
}
#
endif
