#
include
"
hb
.
hh
"
#
ifdef
HAVE_GLIB
#
include
"
hb
-
glib
.
h
"
#
include
"
hb
-
machinery
.
hh
"
hb_script_t
hb_glib_script_to_script
(
GUnicodeScript
script
)
{
return
(
hb_script_t
)
g_unicode_script_to_iso15924
(
script
)
;
}
GUnicodeScript
hb_glib_script_from_script
(
hb_script_t
script
)
{
return
g_unicode_script_from_iso15924
(
script
)
;
}
static
hb_unicode_combining_class_t
hb_glib_unicode_combining_class
(
hb_unicode_funcs_t
*
ufuncs
HB_UNUSED
hb_codepoint_t
unicode
void
*
user_data
HB_UNUSED
)
{
return
(
hb_unicode_combining_class_t
)
g_unichar_combining_class
(
unicode
)
;
}
static
hb_unicode_general_category_t
hb_glib_unicode_general_category
(
hb_unicode_funcs_t
*
ufuncs
HB_UNUSED
hb_codepoint_t
unicode
void
*
user_data
HB_UNUSED
)
{
return
(
hb_unicode_general_category_t
)
g_unichar_type
(
unicode
)
;
}
static
hb_codepoint_t
hb_glib_unicode_mirroring
(
hb_unicode_funcs_t
*
ufuncs
HB_UNUSED
hb_codepoint_t
unicode
void
*
user_data
HB_UNUSED
)
{
g_unichar_get_mirror_char
(
unicode
&
unicode
)
;
return
unicode
;
}
static
hb_script_t
hb_glib_unicode_script
(
hb_unicode_funcs_t
*
ufuncs
HB_UNUSED
hb_codepoint_t
unicode
void
*
user_data
HB_UNUSED
)
{
return
hb_glib_script_to_script
(
g_unichar_get_script
(
unicode
)
)
;
}
static
hb_bool_t
hb_glib_unicode_compose
(
hb_unicode_funcs_t
*
ufuncs
HB_UNUSED
hb_codepoint_t
a
hb_codepoint_t
b
hb_codepoint_t
*
ab
void
*
user_data
HB_UNUSED
)
{
#
if
GLIB_CHECK_VERSION
(
2
29
12
)
return
g_unichar_compose
(
a
b
ab
)
;
#
endif
gchar
utf8
[
12
]
;
gchar
*
normalized
;
int
len
;
hb_bool_t
ret
;
len
=
g_unichar_to_utf8
(
a
utf8
)
;
len
+
=
g_unichar_to_utf8
(
b
utf8
+
len
)
;
normalized
=
g_utf8_normalize
(
utf8
len
G_NORMALIZE_NFC
)
;
len
=
g_utf8_strlen
(
normalized
-
1
)
;
if
(
unlikely
(
!
len
)
)
return
false
;
if
(
len
=
=
1
)
{
*
ab
=
g_utf8_get_char
(
normalized
)
;
ret
=
true
;
}
else
{
ret
=
false
;
}
g_free
(
normalized
)
;
return
ret
;
}
static
hb_bool_t
hb_glib_unicode_decompose
(
hb_unicode_funcs_t
*
ufuncs
HB_UNUSED
hb_codepoint_t
ab
hb_codepoint_t
*
a
hb_codepoint_t
*
b
void
*
user_data
HB_UNUSED
)
{
#
if
GLIB_CHECK_VERSION
(
2
29
12
)
return
g_unichar_decompose
(
ab
a
b
)
;
#
endif
gchar
utf8
[
6
]
;
gchar
*
normalized
;
int
len
;
hb_bool_t
ret
;
len
=
g_unichar_to_utf8
(
ab
utf8
)
;
normalized
=
g_utf8_normalize
(
utf8
len
G_NORMALIZE_NFD
)
;
len
=
g_utf8_strlen
(
normalized
-
1
)
;
if
(
unlikely
(
!
len
)
)
return
false
;
if
(
len
=
=
1
)
{
*
a
=
g_utf8_get_char
(
normalized
)
;
*
b
=
0
;
ret
=
*
a
!
=
ab
;
}
else
if
(
len
=
=
2
)
{
*
a
=
g_utf8_get_char
(
normalized
)
;
*
b
=
g_utf8_get_char
(
g_utf8_next_char
(
normalized
)
)
;
gchar
*
recomposed
=
g_utf8_normalize
(
normalized
-
1
G_NORMALIZE_NFC
)
;
hb_codepoint_t
c
=
g_utf8_get_char
(
recomposed
)
;
if
(
c
!
=
ab
&
&
c
!
=
*
a
)
{
*
a
=
c
;
*
b
=
0
;
}
g_free
(
recomposed
)
;
ret
=
true
;
}
else
{
gchar
*
end
=
g_utf8_offset_to_pointer
(
normalized
len
-
1
)
;
gchar
*
recomposed
;
*
b
=
g_utf8_get_char
(
end
)
;
recomposed
=
g_utf8_normalize
(
normalized
end
-
normalized
G_NORMALIZE_NFC
)
;
*
a
=
g_utf8_get_char
(
recomposed
)
;
g_free
(
recomposed
)
;
ret
=
true
;
}
g_free
(
normalized
)
;
return
ret
;
}
static
inline
void
free_static_glib_funcs
(
)
;
static
struct
hb_glib_unicode_funcs_lazy_loader_t
:
hb_unicode_funcs_lazy_loader_t
<
hb_glib_unicode_funcs_lazy_loader_t
>
{
static
hb_unicode_funcs_t
*
create
(
)
{
hb_unicode_funcs_t
*
funcs
=
hb_unicode_funcs_create
(
nullptr
)
;
hb_unicode_funcs_set_combining_class_func
(
funcs
hb_glib_unicode_combining_class
nullptr
nullptr
)
;
hb_unicode_funcs_set_general_category_func
(
funcs
hb_glib_unicode_general_category
nullptr
nullptr
)
;
hb_unicode_funcs_set_mirroring_func
(
funcs
hb_glib_unicode_mirroring
nullptr
nullptr
)
;
hb_unicode_funcs_set_script_func
(
funcs
hb_glib_unicode_script
nullptr
nullptr
)
;
hb_unicode_funcs_set_compose_func
(
funcs
hb_glib_unicode_compose
nullptr
nullptr
)
;
hb_unicode_funcs_set_decompose_func
(
funcs
hb_glib_unicode_decompose
nullptr
nullptr
)
;
hb_unicode_funcs_make_immutable
(
funcs
)
;
hb_atexit
(
free_static_glib_funcs
)
;
return
funcs
;
}
}
static_glib_funcs
;
static
inline
void
free_static_glib_funcs
(
)
{
static_glib_funcs
.
free_instance
(
)
;
}
hb_unicode_funcs_t
*
hb_glib_get_unicode_funcs
(
)
{
return
static_glib_funcs
.
get_unconst
(
)
;
}
#
if
GLIB_CHECK_VERSION
(
2
31
10
)
static
void
_hb_g_bytes_unref
(
void
*
data
)
{
g_bytes_unref
(
(
GBytes
*
)
data
)
;
}
hb_blob_t
*
hb_glib_blob_create
(
GBytes
*
gbytes
)
{
gsize
size
=
0
;
gconstpointer
data
=
g_bytes_get_data
(
gbytes
&
size
)
;
return
hb_blob_create
(
(
const
char
*
)
data
size
HB_MEMORY_MODE_READONLY
g_bytes_ref
(
gbytes
)
_hb_g_bytes_unref
)
;
}
#
endif
#
endif
