#
ifndef
HB_HH
#
define
HB_HH
#
define
_GNU_SOURCE
1
#
ifdef
HAVE_CONFIG_H
#
include
"
config
.
h
"
#
endif
#
include
"
hb
.
h
"
#
define
HB_H_IN
#
ifdef
HAVE_OT
#
include
"
hb
-
ot
.
h
"
#
define
HB_OT_H_IN
#
endif
#
include
<
math
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
stddef
.
h
>
#
include
<
string
.
h
>
#
include
<
assert
.
h
>
#
include
<
errno
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdarg
.
h
>
#
if
(
defined
(
_MSC_VER
)
&
&
_MSC_VER
>
=
1500
)
|
|
defined
(
__MINGW32__
)
#
include
<
intrin
.
h
>
#
endif
#
define
HB_PASTE1
(
a
b
)
a
#
#
b
#
define
HB_PASTE
(
a
b
)
HB_PASTE1
(
a
b
)
#
if
defined
(
hb_malloc_impl
)
\
&
&
defined
(
hb_calloc_impl
)
\
&
&
defined
(
hb_realloc_impl
)
\
&
&
defined
(
hb_free_impl
)
extern
"
C
"
void
*
hb_malloc_impl
(
size_t
size
)
;
extern
"
C
"
void
*
hb_calloc_impl
(
size_t
nmemb
size_t
size
)
;
extern
"
C
"
void
*
hb_realloc_impl
(
void
*
ptr
size_t
size
)
;
extern
"
C
"
void
hb_free_impl
(
void
*
ptr
)
;
#
define
malloc
hb_malloc_impl
#
define
calloc
hb_calloc_impl
#
define
realloc
hb_realloc_impl
#
define
free
hb_free_impl
#
if
defined
(
hb_memalign_impl
)
extern
"
C
"
int
hb_memalign_impl
(
void
*
*
memptr
size_t
alignment
size_t
size
)
;
#
define
posix_memalign
hb_memalign_impl
#
else
#
undef
HAVE_POSIX_MEMALIGN
#
endif
#
endif
#
if
__cplusplus
<
201103L
#
ifndef
nullptr
#
define
nullptr
NULL
#
endif
#
ifndef
constexpr
#
define
constexpr
const
#
endif
#
ifndef
static_assert
#
define
static_assert
(
e
msg
)
\
HB_UNUSED
typedef
int
HB_PASTE
(
static_assertion_failed_at_line_
__LINE__
)
[
(
e
)
?
1
:
-
1
]
#
endif
#
ifdef
__GNUC__
#
if
(
__GNUC__
<
4
|
|
(
__GNUC__
=
=
4
&
&
__GNUC_MINOR__
<
8
)
)
#
define
thread_local
__thread
#
endif
#
else
#
define
thread_local
#
endif
template
<
typename
T
>
struct
_hb_alignof
{
struct
s
{
char
c
;
T
t
;
}
;
static
constexpr
size_t
value
=
offsetof
(
s
t
)
;
}
;
#
ifndef
alignof
#
define
alignof
(
x
)
(
_hb_alignof
<
x
>
:
:
value
)
#
endif
#
ifndef
explicit_operator
#
define
explicit_operator
#
endif
#
else
#
ifndef
explicit_operator
#
define
explicit_operator
explicit
#
endif
#
endif
#
if
(
defined
(
__GNUC__
)
|
|
defined
(
__clang__
)
)
&
&
defined
(
__OPTIMIZE__
)
#
define
likely
(
expr
)
(
__builtin_expect
(
!
!
(
expr
)
1
)
)
#
define
unlikely
(
expr
)
(
__builtin_expect
(
!
!
(
expr
)
0
)
)
#
else
#
define
likely
(
expr
)
(
expr
)
#
define
unlikely
(
expr
)
(
expr
)
#
endif
#
if
!
defined
(
__GNUC__
)
&
&
!
defined
(
__clang__
)
#
undef
__attribute__
#
define
__attribute__
(
x
)
#
endif
#
if
__GNUC__
>
=
3
#
define
HB_PURE_FUNC
__attribute__
(
(
pure
)
)
#
define
HB_CONST_FUNC
__attribute__
(
(
const
)
)
#
define
HB_PRINTF_FUNC
(
format_idx
arg_idx
)
__attribute__
(
(
__format__
(
__printf__
format_idx
arg_idx
)
)
)
#
else
#
define
HB_PURE_FUNC
#
define
HB_CONST_FUNC
#
define
HB_PRINTF_FUNC
(
format_idx
arg_idx
)
#
endif
#
if
__GNUC__
>
=
4
#
define
HB_UNUSED
__attribute__
(
(
unused
)
)
#
elif
defined
(
_MSC_VER
)
#
define
HB_UNUSED
__pragma
(
warning
(
suppress
:
4100
4101
)
)
#
else
#
define
HB_UNUSED
#
endif
#
ifndef
HB_INTERNAL
#
if
!
defined
(
HB_NO_VISIBILITY
)
&
&
!
defined
(
__MINGW32__
)
&
&
!
defined
(
__CYGWIN__
)
&
&
!
defined
(
_MSC_VER
)
&
&
!
defined
(
__SUNPRO_CC
)
#
define
HB_INTERNAL
__attribute__
(
(
__visibility__
(
"
hidden
"
)
)
)
#
elif
defined
(
__MINGW32__
)
#
define
HB_INTERNAL
#
else
#
define
HB_INTERNAL
#
define
HB_NO_VISIBILITY
1
#
endif
#
endif
#
if
__GNUC__
>
=
3
#
define
HB_FUNC
__PRETTY_FUNCTION__
#
elif
defined
(
_MSC_VER
)
#
define
HB_FUNC
__FUNCSIG__
#
else
#
define
HB_FUNC
__func__
#
endif
#
if
defined
(
__SUNPRO_CC
)
&
&
(
__SUNPRO_CC
<
0x5140
)
#
define
__restrict
#
endif
#
if
defined
(
__clang__
)
&
&
__cplusplus
>
=
201103L
#
define
HB_FALLTHROUGH
[
[
clang
:
:
fallthrough
]
]
#
elif
__GNUC__
>
=
7
#
define
HB_FALLTHROUGH
__attribute__
(
(
fallthrough
)
)
#
elif
defined
(
_MSC_VER
)
#
include
<
sal
.
h
>
#
define
HB_FALLTHROUGH
__fallthrough
#
else
#
define
HB_FALLTHROUGH
#
endif
#
if
defined
(
_WIN32
)
|
|
defined
(
__CYGWIN__
)
#
if
defined
(
_WIN32_WINNT
)
&
&
_WIN32_WINNT
<
0x0600
#
undef
_WIN32_WINNT
#
endif
#
ifndef
_WIN32_WINNT
#
define
_WIN32_WINNT
0x0600
#
endif
#
ifndef
WIN32_LEAN_AND_MEAN
#
define
WIN32_LEAN_AND_MEAN
1
#
endif
#
ifndef
STRICT
#
define
STRICT
1
#
endif
#
if
defined
(
_WIN32_WCE
)
#
define
vsnprintf
_vsnprintf
#
define
getenv
(
Name
)
nullptr
#
if
_WIN32_WCE
<
0x800
#
define
setlocale
(
Category
Locale
)
"
C
"
static
int
errno
=
0
;
#
endif
#
elif
defined
(
WINAPI_FAMILY
)
&
&
(
WINAPI_FAMILY
=
=
WINAPI_FAMILY_PC_APP
|
|
WINAPI_FAMILY
=
=
WINAPI_FAMILY_PHONE_APP
)
#
define
getenv
(
Name
)
nullptr
#
endif
#
if
defined
(
_MSC_VER
)
&
&
_MSC_VER
<
1900
#
define
snprintf
_snprintf
#
endif
#
endif
#
if
HAVE_ATEXIT
#
if
defined
(
__linux
)
&
&
defined
(
__GLIBC_PREREQ
)
#
if
__GLIBC_PREREQ
(
2
3
)
#
define
HB_USE_ATEXIT
1
#
endif
#
elif
defined
(
_MSC_VER
)
|
|
defined
(
__MINGW32__
)
#
define
HB_USE_ATEXIT
1
#
elif
defined
(
__ANDROID__
)
#
define
HB_USE_ATEXIT
1
#
elif
defined
(
__APPLE__
)
#
define
HB_USE_ATEXIT
1
#
endif
#
endif
#
ifdef
HB_NO_ATEXIT
#
undef
HB_USE_ATEXIT
#
endif
#
define
HB_STMT_START
do
#
define
HB_STMT_END
while
(
0
)
template
<
unsigned
int
cond
>
class
hb_assert_constant_t
;
template
<
>
class
hb_assert_constant_t
<
1
>
{
}
;
#
define
ASSERT_STATIC_EXPR_ZERO
(
_cond
)
(
0
*
(
unsigned
int
)
sizeof
(
hb_assert_constant_t
<
_cond
>
)
)
static_assert
(
(
sizeof
(
int8_t
)
=
=
1
)
"
"
)
;
static_assert
(
(
sizeof
(
uint8_t
)
=
=
1
)
"
"
)
;
static_assert
(
(
sizeof
(
int16_t
)
=
=
2
)
"
"
)
;
static_assert
(
(
sizeof
(
uint16_t
)
=
=
2
)
"
"
)
;
static_assert
(
(
sizeof
(
int32_t
)
=
=
4
)
"
"
)
;
static_assert
(
(
sizeof
(
uint32_t
)
=
=
4
)
"
"
)
;
static_assert
(
(
sizeof
(
int64_t
)
=
=
8
)
"
"
)
;
static_assert
(
(
sizeof
(
uint64_t
)
=
=
8
)
"
"
)
;
static_assert
(
(
sizeof
(
hb_codepoint_t
)
=
=
4
)
"
"
)
;
static_assert
(
(
sizeof
(
hb_position_t
)
=
=
4
)
"
"
)
;
static_assert
(
(
sizeof
(
hb_mask_t
)
=
=
4
)
"
"
)
;
static_assert
(
(
sizeof
(
hb_var_int_t
)
=
=
4
)
"
"
)
;
#
define
_ASSERT_TYPE_POD1
(
_line
_type
)
union
_type_
#
#
_type
#
#
_on_line_
#
#
_line
#
#
_is_not_POD
{
_type
instance
;
}
#
define
_ASSERT_TYPE_POD0
(
_line
_type
)
_ASSERT_TYPE_POD1
(
_line
_type
)
#
define
ASSERT_TYPE_POD
(
_type
)
_ASSERT_TYPE_POD0
(
__LINE__
_type
)
#
ifdef
__GNUC__
#
define
_ASSERT_INSTANCE_POD1
(
_line
_instance
)
\
HB_STMT_START
{
\
typedef
__typeof__
(
_instance
)
_type_
#
#
_line
;
\
_ASSERT_TYPE_POD1
(
_line
_type_
#
#
_line
)
;
\
}
HB_STMT_END
#
else
#
define
_ASSERT_INSTANCE_POD1
(
_line
_instance
)
typedef
int
_assertion_on_line_
#
#
_line
#
#
_not_tested
#
endif
#
define
_ASSERT_INSTANCE_POD0
(
_line
_instance
)
_ASSERT_INSTANCE_POD1
(
_line
_instance
)
#
define
ASSERT_INSTANCE_POD
(
_instance
)
_ASSERT_INSTANCE_POD0
(
__LINE__
_instance
)
#
define
_ASSERT_POD1
(
_line
)
\
HB_UNUSED
inline
void
_static_assertion_on_line_
#
#
_line
(
void
)
const
\
{
_ASSERT_INSTANCE_POD1
(
_line
*
this
)
;
/
*
Make
sure
it
'
s
POD
.
*
/
}
#
define
_ASSERT_POD0
(
_line
)
_ASSERT_POD1
(
_line
)
#
define
ASSERT_POD
(
)
_ASSERT_POD0
(
__LINE__
)
#
define
HB_DISALLOW_COPY_AND_ASSIGN
(
TypeName
)
\
TypeName
(
const
TypeName
&
)
;
\
void
operator
=
(
const
TypeName
&
)
#
if
!
defined
(
HB_VECTOR_SIZE
)
#
define
HB_VECTOR_SIZE
0
#
endif
#
if
!
defined
(
HB_VECTOR_SIZE
)
#
if
defined
(
__GNUC__
)
&
&
(
__GNUC__
>
=
4
)
#
define
HB_VECTOR_SIZE
128
#
else
#
define
HB_VECTOR_SIZE
0
#
endif
#
endif
static_assert
(
0
=
=
(
HB_VECTOR_SIZE
&
(
HB_VECTOR_SIZE
-
1
)
)
"
HB_VECTOR_SIZE
is
not
power
of
2
.
"
)
;
static_assert
(
0
=
=
(
HB_VECTOR_SIZE
%
64
)
"
HB_VECTOR_SIZE
is
not
multiple
of
64
.
"
)
;
#
if
HB_VECTOR_SIZE
typedef
uint64_t
hb_vector_size_impl_t
__attribute__
(
(
vector_size
(
HB_VECTOR_SIZE
/
8
)
)
)
;
#
else
typedef
uint64_t
hb_vector_size_impl_t
;
#
endif
#
ifdef
NDEBUG
#
define
HB_NDEBUG
1
#
endif
#
ifdef
_MSC_VER
#
pragma
warning
(
disable
:
4200
)
#
pragma
warning
(
disable
:
4800
)
#
endif
#
define
HB_MARK_AS_FLAG_T
(
T
)
\
extern
"
C
+
+
"
{
\
static
inline
T
operator
|
(
T
l
T
r
)
{
return
T
(
(
unsigned
)
l
|
(
unsigned
)
r
)
;
}
\
static
inline
T
operator
&
(
T
l
T
r
)
{
return
T
(
(
unsigned
)
l
&
(
unsigned
)
r
)
;
}
\
static
inline
T
operator
^
(
T
l
T
r
)
{
return
T
(
(
unsigned
)
l
^
(
unsigned
)
r
)
;
}
\
static
inline
T
operator
~
(
T
r
)
{
return
T
(
~
(
unsigned
int
)
r
)
;
}
\
static
inline
T
&
operator
|
=
(
T
&
l
T
r
)
{
l
=
l
|
r
;
return
l
;
}
\
static
inline
T
&
operator
&
=
(
T
&
l
T
r
)
{
l
=
l
&
r
;
return
l
;
}
\
static
inline
T
&
operator
^
=
(
T
&
l
T
r
)
{
l
=
l
^
r
;
return
l
;
}
\
}
#
define
FLAG
(
x
)
(
ASSERT_STATIC_EXPR_ZERO
(
(
unsigned
int
)
(
x
)
<
32
)
+
(
1U
<
<
(
unsigned
int
)
(
x
)
)
)
#
define
FLAG_UNSAFE
(
x
)
(
(
unsigned
int
)
(
x
)
<
32
?
(
1U
<
<
(
unsigned
int
)
(
x
)
)
:
0
)
#
define
FLAG_RANGE
(
x
y
)
(
ASSERT_STATIC_EXPR_ZERO
(
(
x
)
<
(
y
)
)
+
FLAG
(
y
+
1
)
-
FLAG
(
x
)
)
#
define
VAR
1
static
inline
double
_hb_round
(
double
x
)
{
if
(
x
>
=
0
)
return
floor
(
x
+
0
.
5
)
;
else
return
ceil
(
x
-
0
.
5
)
;
}
#
if
!
defined
(
HAVE_ROUND
)
&
&
!
defined
(
HAVE_DECL_ROUND
)
#
define
round
(
x
)
_hb_round
(
x
)
#
endif
static
inline
int
_hb_memalign
(
void
*
*
memptr
size_t
alignment
size_t
size
)
{
if
(
unlikely
(
0
!
=
(
alignment
&
(
alignment
-
1
)
)
|
|
!
alignment
|
|
0
!
=
(
alignment
&
(
sizeof
(
void
*
)
-
1
)
)
)
)
return
EINVAL
;
char
*
p
=
(
char
*
)
malloc
(
size
+
alignment
-
1
)
;
if
(
unlikely
(
!
p
)
)
return
ENOMEM
;
size_t
off
=
(
size_t
)
p
&
(
alignment
-
1
)
;
if
(
off
)
p
+
=
alignment
-
off
;
*
memptr
=
(
void
*
)
p
;
return
0
;
}
#
if
!
defined
(
posix_memalign
)
&
&
!
defined
(
HAVE_POSIX_MEMALIGN
)
#
define
posix_memalign
_hb_memalign
#
endif
#
include
"
hb
-
atomic
.
hh
"
#
include
"
hb
-
debug
.
hh
"
#
include
"
hb
-
dsalgs
.
hh
"
#
include
"
hb
-
mutex
.
hh
"
#
include
"
hb
-
null
.
hh
"
#
include
"
hb
-
object
.
hh
"
#
endif
