#
ifndef
HB_OT_HMTX_TABLE_HH
#
define
HB_OT_HMTX_TABLE_HH
#
include
"
hb
-
open
-
type
.
hh
"
#
include
"
hb
-
ot
-
hhea
-
table
.
hh
"
#
include
"
hb
-
ot
-
os2
-
table
.
hh
"
#
include
"
hb
-
ot
-
var
-
hvar
-
table
.
hh
"
#
define
HB_OT_TAG_hmtx
HB_TAG
(
'
h
'
'
m
'
'
t
'
'
x
'
)
#
define
HB_OT_TAG_vmtx
HB_TAG
(
'
v
'
'
m
'
'
t
'
'
x
'
)
namespace
OT
{
struct
LongMetric
{
UFWORD
advance
;
FWORD
sb
;
public
:
DEFINE_SIZE_STATIC
(
4
)
;
}
;
template
<
typename
T
typename
H
>
struct
hmtxvmtx
{
bool
sanitize
(
hb_sanitize_context_t
*
c
HB_UNUSED
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
true
)
;
}
bool
subset_update_header
(
hb_subset_plan_t
*
plan
unsigned
int
num_hmetrics
)
const
{
hb_blob_t
*
src_blob
=
hb_sanitize_context_t
(
)
.
reference_table
<
H
>
(
plan
-
>
source
H
:
:
tableTag
)
;
hb_blob_t
*
dest_blob
=
hb_blob_copy_writable_or_fail
(
src_blob
)
;
hb_blob_destroy
(
src_blob
)
;
if
(
unlikely
(
!
dest_blob
)
)
{
return
false
;
}
unsigned
int
length
;
H
*
table
=
(
H
*
)
hb_blob_get_data
(
dest_blob
&
length
)
;
table
-
>
numberOfLongMetrics
.
set
(
num_hmetrics
)
;
bool
result
=
plan
-
>
add_table
(
H
:
:
tableTag
dest_blob
)
;
hb_blob_destroy
(
dest_blob
)
;
return
result
;
}
bool
subset
(
hb_subset_plan_t
*
plan
)
const
{
typename
T
:
:
accelerator_t
_mtx
;
_mtx
.
init
(
plan
-
>
source
)
;
hb_vector_t
<
hb_codepoint_t
>
&
gids
=
plan
-
>
glyphs
;
unsigned
int
num_advances
=
gids
.
length
;
unsigned
int
last_advance
=
_mtx
.
get_advance
(
gids
[
num_advances
-
1
]
)
;
while
(
num_advances
>
1
&
&
last_advance
=
=
_mtx
.
get_advance
(
gids
[
num_advances
-
2
]
)
)
{
num_advances
-
-
;
}
size_t
dest_sz
=
num_advances
*
4
+
(
gids
.
length
-
num_advances
)
*
2
;
void
*
dest
=
(
void
*
)
malloc
(
dest_sz
)
;
if
(
unlikely
(
!
dest
)
)
{
return
false
;
}
DEBUG_MSG
(
SUBSET
nullptr
"
%
c
%
c
%
c
%
c
in
src
has
%
d
advances
%
d
lsbs
"
HB_UNTAG
(
T
:
:
tableTag
)
_mtx
.
num_advances
_mtx
.
num_metrics
-
_mtx
.
num_advances
)
;
DEBUG_MSG
(
SUBSET
nullptr
"
%
c
%
c
%
c
%
c
in
dest
has
%
d
advances
%
d
lsbs
%
u
bytes
"
HB_UNTAG
(
T
:
:
tableTag
)
num_advances
gids
.
length
-
num_advances
(
unsigned
int
)
dest_sz
)
;
const
char
*
source_table
=
hb_blob_get_data
(
_mtx
.
table
.
get_blob
(
)
nullptr
)
;
LongMetric
*
old_metrics
=
(
LongMetric
*
)
source_table
;
FWORD
*
lsbs
=
(
FWORD
*
)
(
old_metrics
+
_mtx
.
num_advances
)
;
char
*
dest_pos
=
(
char
*
)
dest
;
bool
failed
=
false
;
for
(
unsigned
int
i
=
0
;
i
<
gids
.
length
;
i
+
+
)
{
LongMetric
*
src_metric
=
old_metrics
+
MIN
(
(
hb_codepoint_t
)
_mtx
.
num_advances
-
1
gids
[
i
]
)
;
if
(
gids
[
i
]
<
_mtx
.
num_advances
)
{
if
(
i
<
num_advances
)
{
*
(
(
LongMetric
*
)
dest_pos
)
=
*
src_metric
;
}
else
{
*
(
(
FWORD
*
)
dest_pos
)
=
src_metric
-
>
sb
;
}
}
else
{
if
(
gids
[
i
]
>
=
_mtx
.
num_metrics
)
{
DEBUG_MSG
(
SUBSET
nullptr
"
gid
%
d
is
>
=
number
of
source
metrics
%
d
"
gids
[
i
]
_mtx
.
num_metrics
)
;
failed
=
true
;
break
;
}
FWORD
src_sb
=
*
(
lsbs
+
gids
[
i
]
-
_mtx
.
num_advances
)
;
if
(
i
<
num_advances
)
{
LongMetric
*
metric
=
(
LongMetric
*
)
dest_pos
;
metric
-
>
advance
=
src_metric
-
>
advance
;
metric
-
>
sb
=
src_sb
;
}
else
{
*
(
(
FWORD
*
)
dest_pos
)
=
src_sb
;
}
}
dest_pos
+
=
(
i
<
num_advances
?
4
:
2
)
;
}
_mtx
.
fini
(
)
;
if
(
failed
|
|
unlikely
(
!
subset_update_header
(
plan
num_advances
)
)
)
{
free
(
dest
)
;
return
false
;
}
hb_blob_t
*
result
=
hb_blob_create
(
(
const
char
*
)
dest
dest_sz
HB_MEMORY_MODE_READONLY
dest
free
)
;
bool
success
=
plan
-
>
add_table
(
T
:
:
tableTag
result
)
;
hb_blob_destroy
(
result
)
;
return
success
;
}
struct
accelerator_t
{
friend
struct
hmtxvmtx
;
void
init
(
hb_face_t
*
face
unsigned
int
default_advance_
=
0
)
{
default_advance
=
default_advance_
?
default_advance_
:
hb_face_get_upem
(
face
)
;
bool
got_font_extents
=
false
;
if
(
T
:
:
os2Tag
!
=
HB_TAG_NONE
&
&
face
-
>
table
.
OS2
-
>
is_typo_metrics
(
)
)
{
ascender
=
abs
(
face
-
>
table
.
OS2
-
>
sTypoAscender
)
;
descender
=
-
abs
(
face
-
>
table
.
OS2
-
>
sTypoDescender
)
;
line_gap
=
face
-
>
table
.
OS2
-
>
sTypoLineGap
;
got_font_extents
=
(
ascender
|
descender
)
!
=
0
;
}
hb_blob_t
*
_hea_blob
=
hb_sanitize_context_t
(
)
.
reference_table
<
H
>
(
face
)
;
const
H
*
_hea_table
=
_hea_blob
-
>
as
<
H
>
(
)
;
num_advances
=
_hea_table
-
>
numberOfLongMetrics
;
if
(
!
got_font_extents
)
{
ascender
=
abs
(
_hea_table
-
>
ascender
)
;
descender
=
-
abs
(
_hea_table
-
>
descender
)
;
line_gap
=
_hea_table
-
>
lineGap
;
got_font_extents
=
(
ascender
|
descender
)
!
=
0
;
}
hb_blob_destroy
(
_hea_blob
)
;
has_font_extents
=
got_font_extents
;
table
=
hb_sanitize_context_t
(
)
.
reference_table
<
hmtxvmtx
>
(
face
T
:
:
tableTag
)
;
unsigned
int
len
=
table
.
get_length
(
)
;
if
(
unlikely
(
num_advances
*
4
>
len
)
)
num_advances
=
len
/
4
;
num_metrics
=
num_advances
+
(
len
-
4
*
num_advances
)
/
2
;
if
(
unlikely
(
!
num_advances
)
)
{
num_metrics
=
num_advances
=
0
;
table
.
destroy
(
)
;
table
=
hb_blob_get_empty
(
)
;
}
var_table
=
hb_sanitize_context_t
(
)
.
reference_table
<
HVARVVAR
>
(
face
T
:
:
variationsTag
)
;
}
void
fini
(
)
{
table
.
destroy
(
)
;
var_table
.
destroy
(
)
;
}
unsigned
int
get_side_bearing
(
hb_codepoint_t
glyph
)
const
{
if
(
glyph
<
num_advances
)
return
table
-
>
longMetricZ
[
glyph
]
.
sb
;
if
(
unlikely
(
glyph
>
=
num_metrics
)
)
return
0
;
const
FWORD
*
bearings
=
(
const
FWORD
*
)
&
table
-
>
longMetricZ
[
num_advances
]
;
return
bearings
[
glyph
-
num_advances
]
;
}
unsigned
int
get_advance
(
hb_codepoint_t
glyph
)
const
{
if
(
unlikely
(
glyph
>
=
num_metrics
)
)
{
if
(
num_metrics
)
return
0
;
else
return
default_advance
;
}
return
table
-
>
longMetricZ
[
MIN
(
glyph
(
uint32_t
)
num_advances
-
1
)
]
.
advance
;
}
unsigned
int
get_advance
(
hb_codepoint_t
glyph
hb_font_t
*
font
)
const
{
unsigned
int
advance
=
get_advance
(
glyph
)
;
if
(
likely
(
glyph
<
num_metrics
)
)
{
advance
+
=
(
font
-
>
num_coords
?
var_table
-
>
get_advance_var
(
glyph
font
-
>
coords
font
-
>
num_coords
)
:
0
)
;
}
return
advance
;
}
public
:
bool
has_font_extents
;
int
ascender
;
int
descender
;
int
line_gap
;
protected
:
unsigned
int
num_metrics
;
unsigned
int
num_advances
;
unsigned
int
default_advance
;
private
:
hb_blob_ptr_t
<
hmtxvmtx
>
table
;
hb_blob_ptr_t
<
HVARVVAR
>
var_table
;
}
;
protected
:
UnsizedArrayOf
<
LongMetric
>
longMetricZ
;
public
:
DEFINE_SIZE_ARRAY
(
0
longMetricZ
)
;
}
;
struct
hmtx
:
hmtxvmtx
<
hmtx
hhea
>
{
static
constexpr
hb_tag_t
tableTag
=
HB_OT_TAG_hmtx
;
static
constexpr
hb_tag_t
variationsTag
=
HB_OT_TAG_HVAR
;
static
constexpr
hb_tag_t
os2Tag
=
HB_OT_TAG_OS2
;
}
;
struct
vmtx
:
hmtxvmtx
<
vmtx
vhea
>
{
static
constexpr
hb_tag_t
tableTag
=
HB_OT_TAG_vmtx
;
static
constexpr
hb_tag_t
variationsTag
=
HB_OT_TAG_VVAR
;
static
constexpr
hb_tag_t
os2Tag
=
HB_TAG_NONE
;
}
;
struct
hmtx_accelerator_t
:
hmtx
:
:
accelerator_t
{
}
;
struct
vmtx_accelerator_t
:
vmtx
:
:
accelerator_t
{
}
;
}
#
endif
