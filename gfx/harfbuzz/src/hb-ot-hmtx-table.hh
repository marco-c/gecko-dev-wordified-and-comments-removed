#
ifndef
HB_OT_HMTX_TABLE_HH
#
define
HB_OT_HMTX_TABLE_HH
#
include
"
hb
-
open
-
type
.
hh
"
#
include
"
hb
-
ot
-
hhea
-
table
.
hh
"
#
include
"
hb
-
ot
-
var
-
hvar
-
table
.
hh
"
#
include
"
hb
-
ot
-
metrics
.
hh
"
#
define
HB_OT_TAG_hmtx
HB_TAG
(
'
h
'
'
m
'
'
t
'
'
x
'
)
#
define
HB_OT_TAG_vmtx
HB_TAG
(
'
v
'
'
m
'
'
t
'
'
x
'
)
HB_INTERNAL
int
_glyf_get_side_bearing_var
(
hb_font_t
*
font
hb_codepoint_t
glyph
bool
is_vertical
)
;
HB_INTERNAL
unsigned
_glyf_get_advance_var
(
hb_font_t
*
font
hb_codepoint_t
glyph
bool
is_vertical
)
;
namespace
OT
{
struct
LongMetric
{
UFWORD
advance
;
FWORD
sb
;
public
:
DEFINE_SIZE_STATIC
(
4
)
;
}
;
template
<
typename
T
typename
H
>
struct
hmtxvmtx
{
bool
sanitize
(
hb_sanitize_context_t
*
c
HB_UNUSED
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
true
)
;
}
bool
subset_update_header
(
hb_subset_plan_t
*
plan
unsigned
int
num_hmetrics
)
const
{
hb_blob_t
*
src_blob
=
hb_sanitize_context_t
(
)
.
reference_table
<
H
>
(
plan
-
>
source
H
:
:
tableTag
)
;
hb_blob_t
*
dest_blob
=
hb_blob_copy_writable_or_fail
(
src_blob
)
;
hb_blob_destroy
(
src_blob
)
;
if
(
unlikely
(
!
dest_blob
)
)
{
return
false
;
}
unsigned
int
length
;
H
*
table
=
(
H
*
)
hb_blob_get_data
(
dest_blob
&
length
)
;
table
-
>
numberOfLongMetrics
=
num_hmetrics
;
bool
result
=
plan
-
>
add_table
(
H
:
:
tableTag
dest_blob
)
;
hb_blob_destroy
(
dest_blob
)
;
return
result
;
}
template
<
typename
Iterator
hb_requires
(
hb_is_iterator
(
Iterator
)
)
>
void
serialize
(
hb_serialize_context_t
*
c
Iterator
it
unsigned
num_advances
)
{
unsigned
idx
=
0
;
+
it
|
hb_apply
(
[
c
&
idx
num_advances
]
(
const
hb_item_type
<
Iterator
>
&
_
)
{
if
(
idx
<
num_advances
)
{
LongMetric
lm
;
lm
.
advance
=
_
.
first
;
lm
.
sb
=
_
.
second
;
if
(
unlikely
(
!
c
-
>
embed
<
LongMetric
>
(
&
lm
)
)
)
return
;
}
else
{
FWORD
*
sb
=
c
-
>
allocate_size
<
FWORD
>
(
FWORD
:
:
static_size
)
;
if
(
unlikely
(
!
sb
)
)
return
;
*
sb
=
_
.
second
;
}
idx
+
+
;
}
)
;
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
T
*
table_prime
=
c
-
>
serializer
-
>
start_embed
<
T
>
(
)
;
if
(
unlikely
(
!
table_prime
)
)
return_trace
(
false
)
;
accelerator_t
_mtx
;
_mtx
.
init
(
c
-
>
plan
-
>
source
)
;
unsigned
num_advances
=
_mtx
.
num_advances_for_subset
(
c
-
>
plan
)
;
auto
it
=
+
hb_range
(
c
-
>
plan
-
>
num_output_glyphs
(
)
)
|
hb_map
(
[
c
&
_mtx
]
(
unsigned
_
)
{
hb_codepoint_t
old_gid
;
if
(
!
c
-
>
plan
-
>
old_gid_for_new_gid
(
_
&
old_gid
)
)
return
hb_pair
(
0u
0
)
;
return
hb_pair
(
_mtx
.
get_advance
(
old_gid
)
_mtx
.
get_side_bearing
(
old_gid
)
)
;
}
)
;
table_prime
-
>
serialize
(
c
-
>
serializer
it
num_advances
)
;
_mtx
.
fini
(
)
;
if
(
unlikely
(
c
-
>
serializer
-
>
ran_out_of_room
|
|
c
-
>
serializer
-
>
in_error
(
)
)
)
return_trace
(
false
)
;
if
(
unlikely
(
!
subset_update_header
(
c
-
>
plan
num_advances
)
)
)
return_trace
(
false
)
;
return_trace
(
true
)
;
}
struct
accelerator_t
{
friend
struct
hmtxvmtx
;
void
init
(
hb_face_t
*
face
unsigned
int
default_advance_
=
0
)
{
default_advance
=
default_advance_
?
default_advance_
:
hb_face_get_upem
(
face
)
;
num_advances
=
T
:
:
is_horizontal
?
face
-
>
table
.
hhea
-
>
numberOfLongMetrics
:
face
-
>
table
.
vhea
-
>
numberOfLongMetrics
;
table
=
hb_sanitize_context_t
(
)
.
reference_table
<
hmtxvmtx
>
(
face
T
:
:
tableTag
)
;
unsigned
int
len
=
table
.
get_length
(
)
;
if
(
unlikely
(
num_advances
*
4
>
len
)
)
num_advances
=
len
/
4
;
num_metrics
=
num_advances
+
(
len
-
4
*
num_advances
)
/
2
;
if
(
unlikely
(
!
num_advances
)
)
{
num_metrics
=
num_advances
=
0
;
table
.
destroy
(
)
;
table
=
hb_blob_get_empty
(
)
;
}
var_table
=
hb_sanitize_context_t
(
)
.
reference_table
<
HVARVVAR
>
(
face
T
:
:
variationsTag
)
;
}
void
fini
(
)
{
table
.
destroy
(
)
;
var_table
.
destroy
(
)
;
}
int
get_side_bearing
(
hb_codepoint_t
glyph
)
const
{
if
(
glyph
<
num_advances
)
return
table
-
>
longMetricZ
[
glyph
]
.
sb
;
if
(
unlikely
(
glyph
>
=
num_metrics
)
)
return
0
;
const
FWORD
*
bearings
=
(
const
FWORD
*
)
&
table
-
>
longMetricZ
[
num_advances
]
;
return
bearings
[
glyph
-
num_advances
]
;
}
int
get_side_bearing
(
hb_font_t
*
font
hb_codepoint_t
glyph
)
const
{
int
side_bearing
=
get_side_bearing
(
glyph
)
;
#
ifndef
HB_NO_VAR
if
(
unlikely
(
glyph
>
=
num_metrics
)
|
|
!
font
-
>
num_coords
)
return
side_bearing
;
if
(
var_table
.
get_length
(
)
)
return
side_bearing
+
var_table
-
>
get_side_bearing_var
(
glyph
font
-
>
coords
font
-
>
num_coords
)
;
return
_glyf_get_side_bearing_var
(
font
glyph
T
:
:
tableTag
=
=
HB_OT_TAG_vmtx
)
;
#
else
return
side_bearing
;
#
endif
}
unsigned
int
get_advance
(
hb_codepoint_t
glyph
)
const
{
if
(
unlikely
(
glyph
>
=
num_metrics
)
)
{
if
(
num_metrics
)
return
0
;
else
return
default_advance
;
}
return
table
-
>
longMetricZ
[
hb_min
(
glyph
(
uint32_t
)
num_advances
-
1
)
]
.
advance
;
}
unsigned
int
get_advance
(
hb_codepoint_t
glyph
hb_font_t
*
font
)
const
{
unsigned
int
advance
=
get_advance
(
glyph
)
;
#
ifndef
HB_NO_VAR
if
(
unlikely
(
glyph
>
=
num_metrics
)
|
|
!
font
-
>
num_coords
)
return
advance
;
if
(
var_table
.
get_length
(
)
)
return
advance
+
roundf
(
var_table
-
>
get_advance_var
(
glyph
font
)
)
;
return
_glyf_get_advance_var
(
font
glyph
T
:
:
tableTag
=
=
HB_OT_TAG_vmtx
)
;
#
else
return
advance
;
#
endif
}
unsigned
int
num_advances_for_subset
(
const
hb_subset_plan_t
*
plan
)
const
{
unsigned
int
num_advances
=
plan
-
>
num_output_glyphs
(
)
;
unsigned
int
last_advance
=
_advance_for_new_gid
(
plan
num_advances
-
1
)
;
while
(
num_advances
>
1
&
&
last_advance
=
=
_advance_for_new_gid
(
plan
num_advances
-
2
)
)
{
num_advances
-
-
;
}
return
num_advances
;
}
private
:
unsigned
int
_advance_for_new_gid
(
const
hb_subset_plan_t
*
plan
hb_codepoint_t
new_gid
)
const
{
hb_codepoint_t
old_gid
;
if
(
!
plan
-
>
old_gid_for_new_gid
(
new_gid
&
old_gid
)
)
return
0
;
return
get_advance
(
old_gid
)
;
}
protected
:
unsigned
int
num_metrics
;
unsigned
int
num_advances
;
unsigned
int
default_advance
;
private
:
hb_blob_ptr_t
<
hmtxvmtx
>
table
;
hb_blob_ptr_t
<
HVARVVAR
>
var_table
;
}
;
protected
:
UnsizedArrayOf
<
LongMetric
>
longMetricZ
;
public
:
DEFINE_SIZE_ARRAY
(
0
longMetricZ
)
;
}
;
struct
hmtx
:
hmtxvmtx
<
hmtx
hhea
>
{
static
constexpr
hb_tag_t
tableTag
=
HB_OT_TAG_hmtx
;
static
constexpr
hb_tag_t
variationsTag
=
HB_OT_TAG_HVAR
;
static
constexpr
bool
is_horizontal
=
true
;
}
;
struct
vmtx
:
hmtxvmtx
<
vmtx
vhea
>
{
static
constexpr
hb_tag_t
tableTag
=
HB_OT_TAG_vmtx
;
static
constexpr
hb_tag_t
variationsTag
=
HB_OT_TAG_VVAR
;
static
constexpr
bool
is_horizontal
=
false
;
}
;
struct
hmtx_accelerator_t
:
hmtx
:
:
accelerator_t
{
}
;
struct
vmtx_accelerator_t
:
vmtx
:
:
accelerator_t
{
}
;
}
#
endif
