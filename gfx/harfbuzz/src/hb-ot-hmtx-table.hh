#
ifndef
HB_OT_HMTX_TABLE_HH
#
define
HB_OT_HMTX_TABLE_HH
#
include
"
hb
-
open
-
type
-
private
.
hh
"
#
include
"
hb
-
ot
-
hhea
-
table
.
hh
"
#
include
"
hb
-
ot
-
os2
-
table
.
hh
"
#
include
"
hb
-
ot
-
var
-
hvar
-
table
.
hh
"
namespace
OT
{
#
define
HB_OT_TAG_hmtx
HB_TAG
(
'
h
'
'
m
'
'
t
'
'
x
'
)
#
define
HB_OT_TAG_vmtx
HB_TAG
(
'
v
'
'
m
'
'
t
'
'
x
'
)
struct
LongMetric
{
UFWORD
advance
;
FWORD
lsb
;
public
:
DEFINE_SIZE_STATIC
(
4
)
;
}
;
template
<
typename
T
>
struct
hmtxvmtx
{
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
true
)
;
}
struct
accelerator_t
{
inline
void
init
(
hb_face_t
*
face
unsigned
int
default_advance_
=
0
)
{
default_advance
=
default_advance_
?
default_advance_
:
face
-
>
get_upem
(
)
;
bool
got_font_extents
=
false
;
if
(
T
:
:
os2Tag
)
{
hb_blob_t
*
os2_blob
=
Sanitizer
<
os2
>
:
:
sanitize
(
face
-
>
reference_table
(
T
:
:
os2Tag
)
)
;
const
os2
*
os2_table
=
Sanitizer
<
os2
>
:
:
lock_instance
(
os2_blob
)
;
#
define
USE_TYPO_METRICS
(
1u
<
<
7
)
if
(
0
!
=
(
os2_table
-
>
fsSelection
&
USE_TYPO_METRICS
)
)
{
ascender
=
os2_table
-
>
sTypoAscender
;
descender
=
os2_table
-
>
sTypoDescender
;
line_gap
=
os2_table
-
>
sTypoLineGap
;
got_font_extents
=
(
ascender
|
descender
)
!
=
0
;
}
hb_blob_destroy
(
os2_blob
)
;
}
hb_blob_t
*
_hea_blob
=
Sanitizer
<
_hea
>
:
:
sanitize
(
face
-
>
reference_table
(
T
:
:
headerTag
)
)
;
const
_hea
*
_hea_table
=
Sanitizer
<
_hea
>
:
:
lock_instance
(
_hea_blob
)
;
num_advances
=
_hea_table
-
>
numberOfLongMetrics
;
if
(
!
got_font_extents
)
{
ascender
=
_hea_table
-
>
ascender
;
descender
=
_hea_table
-
>
descender
;
line_gap
=
_hea_table
-
>
lineGap
;
got_font_extents
=
(
ascender
|
descender
)
!
=
0
;
}
hb_blob_destroy
(
_hea_blob
)
;
has_font_extents
=
got_font_extents
;
blob
=
Sanitizer
<
hmtxvmtx
>
:
:
sanitize
(
face
-
>
reference_table
(
T
:
:
tableTag
)
)
;
unsigned
int
len
=
hb_blob_get_length
(
blob
)
;
if
(
unlikely
(
num_advances
*
4
>
len
)
)
num_advances
=
len
/
4
;
num_metrics
=
num_advances
+
(
len
-
4
*
num_advances
)
/
2
;
if
(
unlikely
(
!
num_advances
)
)
{
num_metrics
=
num_advances
=
0
;
hb_blob_destroy
(
blob
)
;
blob
=
hb_blob_get_empty
(
)
;
}
table
=
Sanitizer
<
hmtxvmtx
>
:
:
lock_instance
(
blob
)
;
var_blob
=
Sanitizer
<
HVARVVAR
>
:
:
sanitize
(
face
-
>
reference_table
(
T
:
:
variationsTag
)
)
;
var_table
=
Sanitizer
<
HVARVVAR
>
:
:
lock_instance
(
var_blob
)
;
}
inline
void
fini
(
void
)
{
hb_blob_destroy
(
blob
)
;
hb_blob_destroy
(
var_blob
)
;
}
inline
unsigned
int
get_advance
(
hb_codepoint_t
glyph
hb_font_t
*
font
)
const
{
if
(
unlikely
(
glyph
>
=
num_metrics
)
)
{
if
(
num_metrics
)
return
0
;
else
return
default_advance
;
}
return
table
-
>
longMetric
[
MIN
(
glyph
(
uint32_t
)
num_advances
-
1
)
]
.
advance
+
var_table
-
>
get_advance_var
(
glyph
font
-
>
coords
font
-
>
num_coords
)
;
}
public
:
bool
has_font_extents
;
unsigned
short
ascender
;
unsigned
short
descender
;
unsigned
short
line_gap
;
private
:
unsigned
int
num_metrics
;
unsigned
int
num_advances
;
unsigned
int
default_advance
;
const
hmtxvmtx
*
table
;
hb_blob_t
*
blob
;
const
HVARVVAR
*
var_table
;
hb_blob_t
*
var_blob
;
}
;
protected
:
LongMetric
longMetric
[
VAR
]
;
FWORD
leadingBearingX
[
VAR
]
;
public
:
DEFINE_SIZE_ARRAY2
(
0
longMetric
leadingBearingX
)
;
}
;
struct
hmtx
:
hmtxvmtx
<
hmtx
>
{
static
const
hb_tag_t
tableTag
=
HB_OT_TAG_hmtx
;
static
const
hb_tag_t
headerTag
=
HB_OT_TAG_hhea
;
static
const
hb_tag_t
variationsTag
=
HB_OT_TAG_HVAR
;
static
const
hb_tag_t
os2Tag
=
HB_OT_TAG_os2
;
}
;
struct
vmtx
:
hmtxvmtx
<
vmtx
>
{
static
const
hb_tag_t
tableTag
=
HB_OT_TAG_vmtx
;
static
const
hb_tag_t
headerTag
=
HB_OT_TAG_vhea
;
static
const
hb_tag_t
variationsTag
=
HB_OT_TAG_VVAR
;
static
const
hb_tag_t
os2Tag
=
HB_TAG_NONE
;
}
;
}
#
endif
