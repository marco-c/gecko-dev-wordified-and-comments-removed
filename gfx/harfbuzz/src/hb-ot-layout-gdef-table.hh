#
ifndef
HB_OT_LAYOUT_GDEF_TABLE_HH
#
define
HB_OT_LAYOUT_GDEF_TABLE_HH
#
include
"
hb
-
ot
-
layout
-
common
.
hh
"
#
include
"
hb
-
font
.
hh
"
namespace
OT
{
struct
AttachPoint
:
Array16Of
<
HBUINT16
>
{
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
auto
*
out
=
c
-
>
serializer
-
>
start_embed
(
*
this
)
;
if
(
unlikely
(
!
out
)
)
return_trace
(
false
)
;
return_trace
(
out
-
>
serialize
(
c
-
>
serializer
+
iter
(
)
)
)
;
}
}
;
struct
AttachList
{
unsigned
int
get_attach_points
(
hb_codepoint_t
glyph_id
unsigned
int
start_offset
unsigned
int
*
point_count
unsigned
int
*
point_array
)
const
{
unsigned
int
index
=
(
this
+
coverage
)
.
get_coverage
(
glyph_id
)
;
if
(
index
=
=
NOT_COVERED
)
{
if
(
point_count
)
*
point_count
=
0
;
return
0
;
}
const
AttachPoint
&
points
=
this
+
attachPoint
[
index
]
;
if
(
point_count
)
{
+
points
.
sub_array
(
start_offset
point_count
)
|
hb_sink
(
hb_array
(
point_array
*
point_count
)
)
;
}
return
points
.
len
;
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
const
hb_set_t
&
glyphset
=
*
c
-
>
plan
-
>
glyphset_gsub
(
)
;
const
hb_map_t
&
glyph_map
=
*
c
-
>
plan
-
>
glyph_map
;
auto
*
out
=
c
-
>
serializer
-
>
start_embed
(
*
this
)
;
if
(
unlikely
(
!
c
-
>
serializer
-
>
extend_min
(
out
)
)
)
return_trace
(
false
)
;
hb_sorted_vector_t
<
hb_codepoint_t
>
new_coverage
;
+
hb_zip
(
this
+
coverage
attachPoint
)
|
hb_filter
(
glyphset
hb_first
)
|
hb_filter
(
subset_offset_array
(
c
out
-
>
attachPoint
this
)
hb_second
)
|
hb_map
(
hb_first
)
|
hb_map
(
glyph_map
)
|
hb_sink
(
new_coverage
)
;
out
-
>
coverage
.
serialize_serialize
(
c
-
>
serializer
new_coverage
.
iter
(
)
)
;
return_trace
(
bool
(
new_coverage
)
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
coverage
.
sanitize
(
c
this
)
&
&
attachPoint
.
sanitize
(
c
this
)
)
;
}
protected
:
Offset16To
<
Coverage
>
coverage
;
Array16OfOffset16To
<
AttachPoint
>
attachPoint
;
public
:
DEFINE_SIZE_ARRAY
(
4
attachPoint
)
;
}
;
struct
CaretValueFormat1
{
friend
struct
CaretValue
;
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
auto
*
out
=
c
-
>
serializer
-
>
embed
(
this
)
;
if
(
unlikely
(
!
out
)
)
return_trace
(
false
)
;
return_trace
(
true
)
;
}
private
:
hb_position_t
get_caret_value
(
hb_font_t
*
font
hb_direction_t
direction
)
const
{
return
HB_DIRECTION_IS_HORIZONTAL
(
direction
)
?
font
-
>
em_scale_x
(
coordinate
)
:
font
-
>
em_scale_y
(
coordinate
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
protected
:
HBUINT16
caretValueFormat
;
FWORD
coordinate
;
public
:
DEFINE_SIZE_STATIC
(
4
)
;
}
;
struct
CaretValueFormat2
{
friend
struct
CaretValue
;
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
auto
*
out
=
c
-
>
serializer
-
>
embed
(
this
)
;
if
(
unlikely
(
!
out
)
)
return_trace
(
false
)
;
return_trace
(
true
)
;
}
private
:
hb_position_t
get_caret_value
(
hb_font_t
*
font
hb_direction_t
direction
hb_codepoint_t
glyph_id
)
const
{
hb_position_t
x
y
;
font
-
>
get_glyph_contour_point_for_origin
(
glyph_id
caretValuePoint
direction
&
x
&
y
)
;
return
HB_DIRECTION_IS_HORIZONTAL
(
direction
)
?
x
:
y
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
protected
:
HBUINT16
caretValueFormat
;
HBUINT16
caretValuePoint
;
public
:
DEFINE_SIZE_STATIC
(
4
)
;
}
;
struct
CaretValueFormat3
{
friend
struct
CaretValue
;
hb_position_t
get_caret_value
(
hb_font_t
*
font
hb_direction_t
direction
const
VariationStore
&
var_store
)
const
{
return
HB_DIRECTION_IS_HORIZONTAL
(
direction
)
?
font
-
>
em_scale_x
(
coordinate
)
+
(
this
+
deviceTable
)
.
get_x_delta
(
font
var_store
)
:
font
-
>
em_scale_y
(
coordinate
)
+
(
this
+
deviceTable
)
.
get_y_delta
(
font
var_store
)
;
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
auto
*
out
=
c
-
>
serializer
-
>
embed
(
this
)
;
if
(
unlikely
(
!
out
)
)
return_trace
(
false
)
;
return_trace
(
out
-
>
deviceTable
.
serialize_copy
(
c
-
>
serializer
deviceTable
this
c
-
>
serializer
-
>
to_bias
(
out
)
hb_serialize_context_t
:
:
Head
c
-
>
plan
-
>
layout_variation_idx_map
)
)
;
}
void
collect_variation_indices
(
hb_set_t
*
layout_variation_indices
)
const
{
(
this
+
deviceTable
)
.
collect_variation_indices
(
layout_variation_indices
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
deviceTable
.
sanitize
(
c
this
)
)
;
}
protected
:
HBUINT16
caretValueFormat
;
FWORD
coordinate
;
Offset16To
<
Device
>
deviceTable
;
public
:
DEFINE_SIZE_STATIC
(
6
)
;
}
;
struct
CaretValue
{
hb_position_t
get_caret_value
(
hb_font_t
*
font
hb_direction_t
direction
hb_codepoint_t
glyph_id
const
VariationStore
&
var_store
)
const
{
switch
(
u
.
format
)
{
case
1
:
return
u
.
format1
.
get_caret_value
(
font
direction
)
;
case
2
:
return
u
.
format2
.
get_caret_value
(
font
direction
glyph_id
)
;
case
3
:
return
u
.
format3
.
get_caret_value
(
font
direction
var_store
)
;
default
:
return
0
;
}
}
template
<
typename
context_t
typename
.
.
.
Ts
>
typename
context_t
:
:
return_t
dispatch
(
context_t
*
c
Ts
&
&
.
.
.
ds
)
const
{
TRACE_DISPATCH
(
this
u
.
format
)
;
if
(
unlikely
(
!
c
-
>
may_dispatch
(
this
&
u
.
format
)
)
)
return_trace
(
c
-
>
no_dispatch_return_value
(
)
)
;
switch
(
u
.
format
)
{
case
1
:
return_trace
(
c
-
>
dispatch
(
u
.
format1
std
:
:
forward
<
Ts
>
(
ds
)
.
.
.
)
)
;
case
2
:
return_trace
(
c
-
>
dispatch
(
u
.
format2
std
:
:
forward
<
Ts
>
(
ds
)
.
.
.
)
)
;
case
3
:
return_trace
(
c
-
>
dispatch
(
u
.
format3
std
:
:
forward
<
Ts
>
(
ds
)
.
.
.
)
)
;
default
:
return_trace
(
c
-
>
default_return_value
(
)
)
;
}
}
void
collect_variation_indices
(
hb_set_t
*
layout_variation_indices
)
const
{
switch
(
u
.
format
)
{
case
1
:
case
2
:
return
;
case
3
:
u
.
format3
.
collect_variation_indices
(
layout_variation_indices
)
;
return
;
default
:
return
;
}
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
!
u
.
format
.
sanitize
(
c
)
)
return_trace
(
false
)
;
switch
(
u
.
format
)
{
case
1
:
return_trace
(
u
.
format1
.
sanitize
(
c
)
)
;
case
2
:
return_trace
(
u
.
format2
.
sanitize
(
c
)
)
;
case
3
:
return_trace
(
u
.
format3
.
sanitize
(
c
)
)
;
default
:
return_trace
(
true
)
;
}
}
protected
:
union
{
HBUINT16
format
;
CaretValueFormat1
format1
;
CaretValueFormat2
format2
;
CaretValueFormat3
format3
;
}
u
;
public
:
DEFINE_SIZE_UNION
(
2
format
)
;
}
;
struct
LigGlyph
{
unsigned
get_lig_carets
(
hb_font_t
*
font
hb_direction_t
direction
hb_codepoint_t
glyph_id
const
VariationStore
&
var_store
unsigned
start_offset
unsigned
*
caret_count
hb_position_t
*
caret_array
)
const
{
if
(
caret_count
)
{
+
carets
.
sub_array
(
start_offset
caret_count
)
|
hb_map
(
hb_add
(
this
)
)
|
hb_map
(
[
&
]
(
const
CaretValue
&
value
)
{
return
value
.
get_caret_value
(
font
direction
glyph_id
var_store
)
;
}
)
|
hb_sink
(
hb_array
(
caret_array
*
caret_count
)
)
;
}
return
carets
.
len
;
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
auto
*
out
=
c
-
>
serializer
-
>
start_embed
(
*
this
)
;
if
(
unlikely
(
!
c
-
>
serializer
-
>
extend_min
(
out
)
)
)
return_trace
(
false
)
;
+
hb_iter
(
carets
)
|
hb_apply
(
subset_offset_array
(
c
out
-
>
carets
this
)
)
;
return_trace
(
bool
(
out
-
>
carets
)
)
;
}
void
collect_variation_indices
(
hb_collect_variation_indices_context_t
*
c
)
const
{
for
(
const
Offset16To
<
CaretValue
>
&
offset
:
carets
.
iter
(
)
)
(
this
+
offset
)
.
collect_variation_indices
(
c
-
>
layout_variation_indices
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
carets
.
sanitize
(
c
this
)
)
;
}
protected
:
Array16OfOffset16To
<
CaretValue
>
carets
;
public
:
DEFINE_SIZE_ARRAY
(
2
carets
)
;
}
;
struct
LigCaretList
{
unsigned
int
get_lig_carets
(
hb_font_t
*
font
hb_direction_t
direction
hb_codepoint_t
glyph_id
const
VariationStore
&
var_store
unsigned
int
start_offset
unsigned
int
*
caret_count
hb_position_t
*
caret_array
)
const
{
unsigned
int
index
=
(
this
+
coverage
)
.
get_coverage
(
glyph_id
)
;
if
(
index
=
=
NOT_COVERED
)
{
if
(
caret_count
)
*
caret_count
=
0
;
return
0
;
}
const
LigGlyph
&
lig_glyph
=
this
+
ligGlyph
[
index
]
;
return
lig_glyph
.
get_lig_carets
(
font
direction
glyph_id
var_store
start_offset
caret_count
caret_array
)
;
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
const
hb_set_t
&
glyphset
=
*
c
-
>
plan
-
>
glyphset_gsub
(
)
;
const
hb_map_t
&
glyph_map
=
*
c
-
>
plan
-
>
glyph_map
;
auto
*
out
=
c
-
>
serializer
-
>
start_embed
(
*
this
)
;
if
(
unlikely
(
!
c
-
>
serializer
-
>
extend_min
(
out
)
)
)
return_trace
(
false
)
;
hb_sorted_vector_t
<
hb_codepoint_t
>
new_coverage
;
+
hb_zip
(
this
+
coverage
ligGlyph
)
|
hb_filter
(
glyphset
hb_first
)
|
hb_filter
(
subset_offset_array
(
c
out
-
>
ligGlyph
this
)
hb_second
)
|
hb_map
(
hb_first
)
|
hb_map
(
glyph_map
)
|
hb_sink
(
new_coverage
)
;
out
-
>
coverage
.
serialize_serialize
(
c
-
>
serializer
new_coverage
.
iter
(
)
)
;
return_trace
(
bool
(
new_coverage
)
)
;
}
void
collect_variation_indices
(
hb_collect_variation_indices_context_t
*
c
)
const
{
+
hb_zip
(
this
+
coverage
ligGlyph
)
|
hb_filter
(
c
-
>
glyph_set
hb_first
)
|
hb_map
(
hb_second
)
|
hb_map
(
hb_add
(
this
)
)
|
hb_apply
(
[
c
]
(
const
LigGlyph
&
_
)
{
_
.
collect_variation_indices
(
c
)
;
}
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
coverage
.
sanitize
(
c
this
)
&
&
ligGlyph
.
sanitize
(
c
this
)
)
;
}
protected
:
Offset16To
<
Coverage
>
coverage
;
Array16OfOffset16To
<
LigGlyph
>
ligGlyph
;
public
:
DEFINE_SIZE_ARRAY
(
4
ligGlyph
)
;
}
;
struct
MarkGlyphSetsFormat1
{
bool
covers
(
unsigned
int
set_index
hb_codepoint_t
glyph_id
)
const
{
return
(
this
+
coverage
[
set_index
]
)
.
get_coverage
(
glyph_id
)
!
=
NOT_COVERED
;
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
auto
*
out
=
c
-
>
serializer
-
>
start_embed
(
*
this
)
;
if
(
unlikely
(
!
c
-
>
serializer
-
>
extend_min
(
out
)
)
)
return_trace
(
false
)
;
out
-
>
format
=
format
;
bool
ret
=
true
;
for
(
const
Offset32To
<
Coverage
>
&
offset
:
coverage
.
iter
(
)
)
{
auto
*
o
=
out
-
>
coverage
.
serialize_append
(
c
-
>
serializer
)
;
if
(
unlikely
(
!
o
)
)
{
ret
=
false
;
break
;
}
c
-
>
serializer
-
>
push
(
)
;
c
-
>
dispatch
(
this
+
offset
)
;
c
-
>
serializer
-
>
add_link
(
*
o
c
-
>
serializer
-
>
pop_pack
(
)
)
;
}
return_trace
(
ret
&
&
out
-
>
coverage
.
len
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
coverage
.
sanitize
(
c
this
)
)
;
}
protected
:
HBUINT16
format
;
Array16Of
<
Offset32To
<
Coverage
>
>
coverage
;
public
:
DEFINE_SIZE_ARRAY
(
4
coverage
)
;
}
;
struct
MarkGlyphSets
{
bool
covers
(
unsigned
int
set_index
hb_codepoint_t
glyph_id
)
const
{
switch
(
u
.
format
)
{
case
1
:
return
u
.
format1
.
covers
(
set_index
glyph_id
)
;
default
:
return
false
;
}
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
switch
(
u
.
format
)
{
case
1
:
return_trace
(
u
.
format1
.
subset
(
c
)
)
;
default
:
return_trace
(
false
)
;
}
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
!
u
.
format
.
sanitize
(
c
)
)
return_trace
(
false
)
;
switch
(
u
.
format
)
{
case
1
:
return_trace
(
u
.
format1
.
sanitize
(
c
)
)
;
default
:
return_trace
(
true
)
;
}
}
protected
:
union
{
HBUINT16
format
;
MarkGlyphSetsFormat1
format1
;
}
u
;
public
:
DEFINE_SIZE_UNION
(
2
format
)
;
}
;
template
<
typename
Types
>
struct
GDEFVersion1_2
{
friend
struct
GDEF
;
protected
:
FixedVersion
<
>
version
;
typename
Types
:
:
template
OffsetTo
<
ClassDef
>
glyphClassDef
;
typename
Types
:
:
template
OffsetTo
<
AttachList
>
attachList
;
typename
Types
:
:
template
OffsetTo
<
LigCaretList
>
ligCaretList
;
typename
Types
:
:
template
OffsetTo
<
ClassDef
>
markAttachClassDef
;
typename
Types
:
:
template
OffsetTo
<
MarkGlyphSets
>
markGlyphSetsDef
;
Offset32To
<
VariationStore
>
varStore
;
public
:
DEFINE_SIZE_MIN
(
4
+
4
*
Types
:
:
size
)
;
unsigned
int
get_size
(
)
const
{
return
min_size
+
(
version
.
to_int
(
)
>
=
0x00010002u
?
markGlyphSetsDef
.
static_size
:
0
)
+
(
version
.
to_int
(
)
>
=
0x00010003u
?
varStore
.
static_size
:
0
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
version
.
sanitize
(
c
)
&
&
glyphClassDef
.
sanitize
(
c
this
)
&
&
attachList
.
sanitize
(
c
this
)
&
&
ligCaretList
.
sanitize
(
c
this
)
&
&
markAttachClassDef
.
sanitize
(
c
this
)
&
&
(
version
.
to_int
(
)
<
0x00010002u
|
|
markGlyphSetsDef
.
sanitize
(
c
this
)
)
&
&
(
version
.
to_int
(
)
<
0x00010003u
|
|
varStore
.
sanitize
(
c
this
)
)
)
;
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
auto
*
out
=
c
-
>
serializer
-
>
embed
(
*
this
)
;
if
(
unlikely
(
!
out
)
)
return_trace
(
false
)
;
bool
subset_glyphclassdef
=
out
-
>
glyphClassDef
.
serialize_subset
(
c
glyphClassDef
this
nullptr
false
true
)
;
bool
subset_attachlist
=
out
-
>
attachList
.
serialize_subset
(
c
attachList
this
)
;
bool
subset_ligcaretlist
=
out
-
>
ligCaretList
.
serialize_subset
(
c
ligCaretList
this
)
;
bool
subset_markattachclassdef
=
out
-
>
markAttachClassDef
.
serialize_subset
(
c
markAttachClassDef
this
nullptr
false
true
)
;
bool
subset_markglyphsetsdef
=
false
;
if
(
version
.
to_int
(
)
>
=
0x00010002u
)
{
subset_markglyphsetsdef
=
out
-
>
markGlyphSetsDef
.
serialize_subset
(
c
markGlyphSetsDef
this
)
;
}
bool
subset_varstore
=
false
;
if
(
version
.
to_int
(
)
>
=
0x00010003u
)
{
subset_varstore
=
out
-
>
varStore
.
serialize_subset
(
c
varStore
this
)
;
}
if
(
subset_varstore
)
{
out
-
>
version
.
minor
=
3
;
}
else
if
(
subset_markglyphsetsdef
)
{
out
-
>
version
.
minor
=
2
;
}
else
{
out
-
>
version
.
minor
=
0
;
}
return_trace
(
subset_glyphclassdef
|
|
subset_attachlist
|
|
subset_ligcaretlist
|
|
subset_markattachclassdef
|
|
(
out
-
>
version
.
to_int
(
)
>
=
0x00010002u
&
&
subset_markglyphsetsdef
)
|
|
(
out
-
>
version
.
to_int
(
)
>
=
0x00010003u
&
&
subset_varstore
)
)
;
}
}
;
struct
GDEF
{
static
constexpr
hb_tag_t
tableTag
=
HB_OT_TAG_GDEF
;
enum
GlyphClasses
{
UnclassifiedGlyph
=
0
BaseGlyph
=
1
LigatureGlyph
=
2
MarkGlyph
=
3
ComponentGlyph
=
4
}
;
unsigned
int
get_size
(
)
const
{
switch
(
u
.
version
.
major
)
{
case
1
:
return
u
.
version1
.
get_size
(
)
;
#
ifndef
HB_NO_BEYOND_64K
case
2
:
return
u
.
version2
.
get_size
(
)
;
#
endif
default
:
return
u
.
version
.
static_size
;
}
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
u
.
version
.
sanitize
(
c
)
)
)
return_trace
(
false
)
;
switch
(
u
.
version
.
major
)
{
case
1
:
return_trace
(
u
.
version1
.
sanitize
(
c
)
)
;
#
ifndef
HB_NO_BEYOND_64K
case
2
:
return_trace
(
u
.
version2
.
sanitize
(
c
)
)
;
#
endif
default
:
return_trace
(
true
)
;
}
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
switch
(
u
.
version
.
major
)
{
case
1
:
return
u
.
version1
.
subset
(
c
)
;
#
ifndef
HB_NO_BEYOND_64K
case
2
:
return
u
.
version2
.
subset
(
c
)
;
#
endif
default
:
return
false
;
}
}
bool
has_glyph_classes
(
)
const
{
switch
(
u
.
version
.
major
)
{
case
1
:
return
u
.
version1
.
glyphClassDef
!
=
0
;
#
ifndef
HB_NO_BEYOND_64K
case
2
:
return
u
.
version2
.
glyphClassDef
!
=
0
;
#
endif
default
:
return
false
;
}
}
const
ClassDef
&
get_glyph_class_def
(
)
const
{
switch
(
u
.
version
.
major
)
{
case
1
:
return
this
+
u
.
version1
.
glyphClassDef
;
#
ifndef
HB_NO_BEYOND_64K
case
2
:
return
this
+
u
.
version2
.
glyphClassDef
;
#
endif
default
:
return
Null
(
ClassDef
)
;
}
}
bool
has_attach_list
(
)
const
{
switch
(
u
.
version
.
major
)
{
case
1
:
return
u
.
version1
.
attachList
!
=
0
;
#
ifndef
HB_NO_BEYOND_64K
case
2
:
return
u
.
version2
.
attachList
!
=
0
;
#
endif
default
:
return
false
;
}
}
const
AttachList
&
get_attach_list
(
)
const
{
switch
(
u
.
version
.
major
)
{
case
1
:
return
this
+
u
.
version1
.
attachList
;
#
ifndef
HB_NO_BEYOND_64K
case
2
:
return
this
+
u
.
version2
.
attachList
;
#
endif
default
:
return
Null
(
AttachList
)
;
}
}
bool
has_lig_carets
(
)
const
{
switch
(
u
.
version
.
major
)
{
case
1
:
return
u
.
version1
.
ligCaretList
!
=
0
;
#
ifndef
HB_NO_BEYOND_64K
case
2
:
return
u
.
version2
.
ligCaretList
!
=
0
;
#
endif
default
:
return
false
;
}
}
const
LigCaretList
&
get_lig_caret_list
(
)
const
{
switch
(
u
.
version
.
major
)
{
case
1
:
return
this
+
u
.
version1
.
ligCaretList
;
#
ifndef
HB_NO_BEYOND_64K
case
2
:
return
this
+
u
.
version2
.
ligCaretList
;
#
endif
default
:
return
Null
(
LigCaretList
)
;
}
}
bool
has_mark_attachment_types
(
)
const
{
switch
(
u
.
version
.
major
)
{
case
1
:
return
u
.
version1
.
markAttachClassDef
!
=
0
;
#
ifndef
HB_NO_BEYOND_64K
case
2
:
return
u
.
version2
.
markAttachClassDef
!
=
0
;
#
endif
default
:
return
false
;
}
}
const
ClassDef
&
get_mark_attach_class_def
(
)
const
{
switch
(
u
.
version
.
major
)
{
case
1
:
return
this
+
u
.
version1
.
markAttachClassDef
;
#
ifndef
HB_NO_BEYOND_64K
case
2
:
return
this
+
u
.
version2
.
markAttachClassDef
;
#
endif
default
:
return
Null
(
ClassDef
)
;
}
}
bool
has_mark_glyph_sets
(
)
const
{
switch
(
u
.
version
.
major
)
{
case
1
:
return
u
.
version
.
to_int
(
)
>
=
0x00010002u
&
&
u
.
version1
.
markGlyphSetsDef
!
=
0
;
#
ifndef
HB_NO_BEYOND_64K
case
2
:
return
u
.
version2
.
markGlyphSetsDef
!
=
0
;
#
endif
default
:
return
false
;
}
}
const
MarkGlyphSets
&
get_mark_glyph_sets
(
)
const
{
switch
(
u
.
version
.
major
)
{
case
1
:
return
u
.
version
.
to_int
(
)
>
=
0x00010002u
?
this
+
u
.
version1
.
markGlyphSetsDef
:
Null
(
MarkGlyphSets
)
;
#
ifndef
HB_NO_BEYOND_64K
case
2
:
return
this
+
u
.
version2
.
markGlyphSetsDef
;
#
endif
default
:
return
Null
(
MarkGlyphSets
)
;
}
}
bool
has_var_store
(
)
const
{
switch
(
u
.
version
.
major
)
{
case
1
:
return
u
.
version
.
to_int
(
)
>
=
0x00010003u
&
&
u
.
version1
.
varStore
!
=
0
;
#
ifndef
HB_NO_BEYOND_64K
case
2
:
return
u
.
version2
.
varStore
!
=
0
;
#
endif
default
:
return
false
;
}
}
const
VariationStore
&
get_var_store
(
)
const
{
switch
(
u
.
version
.
major
)
{
case
1
:
return
u
.
version
.
to_int
(
)
>
=
0x00010003u
?
this
+
u
.
version1
.
varStore
:
Null
(
VariationStore
)
;
#
ifndef
HB_NO_BEYOND_64K
case
2
:
return
this
+
u
.
version2
.
varStore
;
#
endif
default
:
return
Null
(
VariationStore
)
;
}
}
bool
has_data
(
)
const
{
return
u
.
version
.
to_int
(
)
;
}
unsigned
int
get_glyph_class
(
hb_codepoint_t
glyph
)
const
{
return
get_glyph_class_def
(
)
.
get_class
(
glyph
)
;
}
void
get_glyphs_in_class
(
unsigned
int
klass
hb_set_t
*
glyphs
)
const
{
get_glyph_class_def
(
)
.
collect_class
(
glyphs
klass
)
;
}
unsigned
int
get_mark_attachment_type
(
hb_codepoint_t
glyph
)
const
{
return
get_mark_attach_class_def
(
)
.
get_class
(
glyph
)
;
}
unsigned
int
get_attach_points
(
hb_codepoint_t
glyph_id
unsigned
int
start_offset
unsigned
int
*
point_count
unsigned
int
*
point_array
)
const
{
return
get_attach_list
(
)
.
get_attach_points
(
glyph_id
start_offset
point_count
point_array
)
;
}
unsigned
int
get_lig_carets
(
hb_font_t
*
font
hb_direction_t
direction
hb_codepoint_t
glyph_id
unsigned
int
start_offset
unsigned
int
*
caret_count
hb_position_t
*
caret_array
)
const
{
return
get_lig_caret_list
(
)
.
get_lig_carets
(
font
direction
glyph_id
get_var_store
(
)
start_offset
caret_count
caret_array
)
;
}
bool
mark_set_covers
(
unsigned
int
set_index
hb_codepoint_t
glyph_id
)
const
{
return
get_mark_glyph_sets
(
)
.
covers
(
set_index
glyph_id
)
;
}
unsigned
int
get_glyph_props
(
hb_codepoint_t
glyph
)
const
{
unsigned
int
klass
=
get_glyph_class
(
glyph
)
;
static_assert
(
(
(
unsigned
int
)
HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH
=
=
(
unsigned
int
)
LookupFlag
:
:
IgnoreBaseGlyphs
)
"
"
)
;
static_assert
(
(
(
unsigned
int
)
HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE
=
=
(
unsigned
int
)
LookupFlag
:
:
IgnoreLigatures
)
"
"
)
;
static_assert
(
(
(
unsigned
int
)
HB_OT_LAYOUT_GLYPH_PROPS_MARK
=
=
(
unsigned
int
)
LookupFlag
:
:
IgnoreMarks
)
"
"
)
;
switch
(
klass
)
{
default
:
return
HB_OT_LAYOUT_GLYPH_CLASS_UNCLASSIFIED
;
case
BaseGlyph
:
return
HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH
;
case
LigatureGlyph
:
return
HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE
;
case
MarkGlyph
:
klass
=
get_mark_attachment_type
(
glyph
)
;
return
HB_OT_LAYOUT_GLYPH_PROPS_MARK
|
(
klass
<
<
8
)
;
}
}
HB_INTERNAL
bool
is_blocklisted
(
hb_blob_t
*
blob
hb_face_t
*
face
)
const
;
struct
accelerator_t
{
accelerator_t
(
hb_face_t
*
face
)
{
table
=
hb_sanitize_context_t
(
)
.
reference_table
<
GDEF
>
(
face
)
;
if
(
unlikely
(
table
-
>
is_blocklisted
(
table
.
get_blob
(
)
face
)
)
)
{
hb_blob_destroy
(
table
.
get_blob
(
)
)
;
table
=
hb_blob_get_empty
(
)
;
}
}
~
accelerator_t
(
)
{
table
.
destroy
(
)
;
}
hb_blob_ptr_t
<
GDEF
>
table
;
}
;
void
collect_variation_indices
(
hb_collect_variation_indices_context_t
*
c
)
const
{
get_lig_caret_list
(
)
.
collect_variation_indices
(
c
)
;
}
void
remap_layout_variation_indices
(
const
hb_set_t
*
layout_variation_indices
hb_map_t
*
layout_variation_idx_map
)
const
{
if
(
!
has_var_store
(
)
)
return
;
if
(
layout_variation_indices
-
>
is_empty
(
)
)
return
;
unsigned
new_major
=
0
new_minor
=
0
;
unsigned
last_major
=
(
layout_variation_indices
-
>
get_min
(
)
)
>
>
16
;
for
(
unsigned
idx
:
layout_variation_indices
-
>
iter
(
)
)
{
uint16_t
major
=
idx
>
>
16
;
if
(
major
>
=
get_var_store
(
)
.
get_sub_table_count
(
)
)
break
;
if
(
major
!
=
last_major
)
{
new_minor
=
0
;
+
+
new_major
;
}
unsigned
new_idx
=
(
new_major
<
<
16
)
+
new_minor
;
layout_variation_idx_map
-
>
set
(
idx
new_idx
)
;
+
+
new_minor
;
last_major
=
major
;
}
}
protected
:
union
{
FixedVersion
<
>
version
;
GDEFVersion1_2
<
SmallTypes
>
version1
;
#
ifndef
HB_NO_BEYOND_64K
GDEFVersion1_2
<
MediumTypes
>
version2
;
#
endif
}
u
;
public
:
DEFINE_SIZE_MIN
(
4
)
;
}
;
struct
GDEF_accelerator_t
:
GDEF
:
:
accelerator_t
{
GDEF_accelerator_t
(
hb_face_t
*
face
)
:
GDEF
:
:
accelerator_t
(
face
)
{
}
}
;
}
#
endif
