#
ifndef
HB_OT_COLOR_SVG_TABLE_HH
#
define
HB_OT_COLOR_SVG_TABLE_HH
#
include
"
hb
-
open
-
type
.
hh
"
#
define
HB_OT_TAG_SVG
HB_TAG
(
'
S
'
'
V
'
'
G
'
'
'
)
namespace
OT
{
struct
SVGDocumentIndexEntry
{
int
cmp
(
hb_codepoint_t
g
)
const
{
return
g
<
startGlyphID
?
-
1
:
g
>
endGlyphID
?
1
:
0
;
}
hb_blob_t
*
reference_blob
(
hb_blob_t
*
svg_blob
unsigned
int
index_offset
)
const
{
return
hb_blob_create_sub_blob
(
svg_blob
index_offset
+
(
unsigned
int
)
svgDoc
svgDocLength
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
svgDoc
.
sanitize
(
c
base
svgDocLength
)
)
;
}
protected
:
HBUINT16
startGlyphID
;
HBUINT16
endGlyphID
;
NNOffset32To
<
UnsizedArrayOf
<
HBUINT8
>
>
svgDoc
;
HBUINT32
svgDocLength
;
public
:
DEFINE_SIZE_STATIC
(
12
)
;
}
;
struct
SVG
{
static
constexpr
hb_tag_t
tableTag
=
HB_OT_TAG_SVG
;
bool
has_data
(
)
const
{
return
svgDocEntries
;
}
struct
accelerator_t
{
accelerator_t
(
hb_face_t
*
face
)
{
table
=
hb_sanitize_context_t
(
)
.
reference_table
<
SVG
>
(
face
)
;
}
~
accelerator_t
(
)
{
table
.
destroy
(
)
;
}
hb_blob_t
*
reference_blob_for_glyph
(
hb_codepoint_t
glyph_id
)
const
{
return
table
-
>
get_glyph_entry
(
glyph_id
)
.
reference_blob
(
table
.
get_blob
(
)
table
-
>
svgDocEntries
)
;
}
bool
has_data
(
)
const
{
return
table
-
>
has_data
(
)
;
}
private
:
hb_blob_ptr_t
<
SVG
>
table
;
}
;
const
SVGDocumentIndexEntry
&
get_glyph_entry
(
hb_codepoint_t
glyph_id
)
const
{
return
(
this
+
svgDocEntries
)
.
bsearch
(
glyph_id
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
(
this
+
svgDocEntries
)
.
sanitize_shallow
(
c
)
)
)
;
}
protected
:
HBUINT16
version
;
Offset32To
<
SortedArray16Of
<
SVGDocumentIndexEntry
>
>
svgDocEntries
;
HBUINT32
reserved
;
public
:
DEFINE_SIZE_STATIC
(
10
)
;
}
;
struct
SVG_accelerator_t
:
SVG
:
:
accelerator_t
{
SVG_accelerator_t
(
hb_face_t
*
face
)
:
SVG
:
:
accelerator_t
(
face
)
{
}
}
;
}
#
endif
