#
ifndef
HB_AAT_FDSC_TABLE_HH
#
define
HB_AAT_FDSC_TABLE_HH
#
include
"
hb
-
aat
-
layout
-
common
.
hh
"
#
include
"
hb
-
open
-
type
.
hh
"
#
define
HB_AAT_TAG_fdsc
HB_TAG
(
'
f
'
'
d
'
'
s
'
'
c
'
)
namespace
AAT
{
struct
FontDescriptor
{
bool
has_data
(
)
const
{
return
tag
;
}
int
cmp
(
hb_tag_t
a
)
const
{
return
tag
.
cmp
(
a
)
;
}
float
get_value
(
)
const
{
return
u
.
value
.
to_float
(
)
;
}
enum
non_alphabetic_value_t
{
Alphabetic
=
0
Dingbats
=
1
PiCharacters
=
2
Fleurons
=
3
DecorativeBorders
=
4
InternationalSymbols
=
5
MathSymbols
=
6
}
;
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
protected
:
Tag
tag
;
union
{
Fixed
value
;
HBUINT32
nalfType
;
}
u
;
public
:
DEFINE_SIZE_STATIC
(
8
)
;
}
;
struct
fdsc
{
static
constexpr
hb_tag_t
tableTag
=
HB_AAT_TAG_fdsc
;
enum
{
Weight
=
HB_TAG
(
'
w
'
'
g
'
'
h
'
'
t
'
)
Width
=
HB_TAG
(
'
w
'
'
d
'
'
t
'
'
h
'
)
Slant
=
HB_TAG
(
'
s
'
'
l
'
'
n
'
'
t
'
)
OpticalSize
=
HB_TAG
(
'
o
'
'
p
'
'
s
'
'
z
'
)
NonAlphabetic
=
HB_TAG
(
'
n
'
'
a
'
'
l
'
'
f
'
)
}
;
const
FontDescriptor
&
get_descriptor
(
hb_tag_t
style
)
const
{
return
descriptors
.
lsearch
(
style
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
descriptors
.
sanitize
(
c
)
)
;
}
protected
:
Fixed
version
;
LArrayOf
<
FontDescriptor
>
descriptors
;
public
:
DEFINE_SIZE_ARRAY
(
8
descriptors
)
;
}
;
}
#
endif
