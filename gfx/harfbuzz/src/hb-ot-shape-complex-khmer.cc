#
include
"
hb
-
ot
-
shape
-
complex
-
khmer
-
private
.
hh
"
#
include
"
hb
-
ot
-
layout
-
private
.
hh
"
struct
feature_list_t
{
hb_tag_t
tag
;
hb_ot_map_feature_flags_t
flags
;
}
;
static
const
feature_list_t
khmer_features
[
]
=
{
{
HB_TAG
(
'
p
'
'
r
'
'
e
'
'
f
'
)
F_NONE
}
{
HB_TAG
(
'
b
'
'
l
'
'
w
'
'
f
'
)
F_NONE
}
{
HB_TAG
(
'
a
'
'
b
'
'
v
'
'
f
'
)
F_NONE
}
{
HB_TAG
(
'
p
'
'
s
'
'
t
'
'
f
'
)
F_NONE
}
{
HB_TAG
(
'
c
'
'
f
'
'
a
'
'
r
'
)
F_NONE
}
{
HB_TAG
(
'
p
'
'
r
'
'
e
'
'
s
'
)
F_GLOBAL
}
{
HB_TAG
(
'
a
'
'
b
'
'
v
'
'
s
'
)
F_GLOBAL
}
{
HB_TAG
(
'
b
'
'
l
'
'
w
'
'
s
'
)
F_GLOBAL
}
{
HB_TAG
(
'
p
'
'
s
'
'
t
'
'
s
'
)
F_GLOBAL
}
{
HB_TAG
(
'
d
'
'
i
'
'
s
'
'
t
'
)
F_GLOBAL
}
{
HB_TAG
(
'
a
'
'
b
'
'
v
'
'
m
'
)
F_GLOBAL
}
{
HB_TAG
(
'
b
'
'
l
'
'
w
'
'
m
'
)
F_GLOBAL
}
}
;
enum
{
PREF
BLWF
ABVF
PSTF
CFAR
_PRES
_ABVS
_BLWS
_PSTS
_DIST
_ABVM
_BLWM
KHMER_NUM_FEATURES
KHMER_BASIC_FEATURES
=
_PRES
}
;
static
void
setup_syllables
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
hb_buffer_t
*
buffer
)
;
static
void
initial_reordering
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
hb_buffer_t
*
buffer
)
;
static
void
final_reordering
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
hb_buffer_t
*
buffer
)
;
static
void
clear_syllables
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
hb_buffer_t
*
buffer
)
;
static
void
collect_features_khmer
(
hb_ot_shape_planner_t
*
plan
)
{
hb_ot_map_builder_t
*
map
=
&
plan
-
>
map
;
map
-
>
add_gsub_pause
(
setup_syllables
)
;
map
-
>
add_global_bool_feature
(
HB_TAG
(
'
l
'
'
o
'
'
c
'
'
l
'
)
)
;
map
-
>
add_global_bool_feature
(
HB_TAG
(
'
c
'
'
c
'
'
m
'
'
p
'
)
)
;
unsigned
int
i
=
0
;
map
-
>
add_gsub_pause
(
initial_reordering
)
;
for
(
;
i
<
KHMER_BASIC_FEATURES
;
i
+
+
)
{
map
-
>
add_feature
(
khmer_features
[
i
]
.
tag
1
khmer_features
[
i
]
.
flags
|
F_MANUAL_ZWJ
|
F_MANUAL_ZWNJ
)
;
map
-
>
add_gsub_pause
(
nullptr
)
;
}
map
-
>
add_gsub_pause
(
final_reordering
)
;
for
(
;
i
<
KHMER_NUM_FEATURES
;
i
+
+
)
{
map
-
>
add_feature
(
khmer_features
[
i
]
.
tag
1
khmer_features
[
i
]
.
flags
|
F_MANUAL_ZWJ
|
F_MANUAL_ZWNJ
)
;
}
map
-
>
add_global_bool_feature
(
HB_TAG
(
'
c
'
'
a
'
'
l
'
'
t
'
)
)
;
map
-
>
add_global_bool_feature
(
HB_TAG
(
'
c
'
'
l
'
'
i
'
'
g
'
)
)
;
map
-
>
add_gsub_pause
(
clear_syllables
)
;
}
static
void
override_features_khmer
(
hb_ot_shape_planner_t
*
plan
)
{
if
(
hb_options
(
)
.
uniscribe_bug_compatible
)
{
plan
-
>
map
.
add_feature
(
HB_TAG
(
'
k
'
'
e
'
'
r
'
'
n
'
)
0
F_GLOBAL
)
;
}
plan
-
>
map
.
add_feature
(
HB_TAG
(
'
l
'
'
i
'
'
g
'
'
a
'
)
0
F_GLOBAL
)
;
}
struct
would_substitute_feature_t
{
inline
void
init
(
const
hb_ot_map_t
*
map
hb_tag_t
feature_tag
bool
zero_context_
)
{
zero_context
=
zero_context_
;
map
-
>
get_stage_lookups
(
0
map
-
>
get_feature_stage
(
0
feature_tag
)
&
lookups
&
count
)
;
}
inline
bool
would_substitute
(
const
hb_codepoint_t
*
glyphs
unsigned
int
glyphs_count
hb_face_t
*
face
)
const
{
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
if
(
hb_ot_layout_lookup_would_substitute_fast
(
face
lookups
[
i
]
.
index
glyphs
glyphs_count
zero_context
)
)
return
true
;
return
false
;
}
private
:
const
hb_ot_map_t
:
:
lookup_map_t
*
lookups
;
unsigned
int
count
;
bool
zero_context
;
}
;
struct
khmer_shape_plan_t
{
ASSERT_POD
(
)
;
inline
bool
get_virama_glyph
(
hb_font_t
*
font
hb_codepoint_t
*
pglyph
)
const
{
hb_codepoint_t
glyph
=
virama_glyph
;
if
(
unlikely
(
virama_glyph
=
=
(
hb_codepoint_t
)
-
1
)
)
{
if
(
!
font
-
>
get_nominal_glyph
(
0x17D2u
&
glyph
)
)
glyph
=
0
;
virama_glyph
=
glyph
;
}
*
pglyph
=
glyph
;
return
glyph
!
=
0
;
}
mutable
hb_codepoint_t
virama_glyph
;
would_substitute_feature_t
pref
;
hb_mask_t
mask_array
[
KHMER_NUM_FEATURES
]
;
}
;
static
void
*
data_create_khmer
(
const
hb_ot_shape_plan_t
*
plan
)
{
khmer_shape_plan_t
*
khmer_plan
=
(
khmer_shape_plan_t
*
)
calloc
(
1
sizeof
(
khmer_shape_plan_t
)
)
;
if
(
unlikely
(
!
khmer_plan
)
)
return
nullptr
;
khmer_plan
-
>
virama_glyph
=
(
hb_codepoint_t
)
-
1
;
khmer_plan
-
>
pref
.
init
(
&
plan
-
>
map
HB_TAG
(
'
p
'
'
r
'
'
e
'
'
f
'
)
true
)
;
for
(
unsigned
int
i
=
0
;
i
<
ARRAY_LENGTH
(
khmer_plan
-
>
mask_array
)
;
i
+
+
)
khmer_plan
-
>
mask_array
[
i
]
=
(
khmer_features
[
i
]
.
flags
&
F_GLOBAL
)
?
0
:
plan
-
>
map
.
get_1_mask
(
khmer_features
[
i
]
.
tag
)
;
return
khmer_plan
;
}
static
void
data_destroy_khmer
(
void
*
data
)
{
free
(
data
)
;
}
enum
syllable_type_t
{
consonant_syllable
broken_cluster
non_khmer_cluster
}
;
#
include
"
hb
-
ot
-
shape
-
complex
-
khmer
-
machine
.
hh
"
static
void
setup_masks_khmer
(
const
hb_ot_shape_plan_t
*
plan
HB_UNUSED
hb_buffer_t
*
buffer
hb_font_t
*
font
HB_UNUSED
)
{
HB_BUFFER_ALLOCATE_VAR
(
buffer
khmer_category
)
;
HB_BUFFER_ALLOCATE_VAR
(
buffer
khmer_position
)
;
unsigned
int
count
=
buffer
-
>
len
;
hb_glyph_info_t
*
info
=
buffer
-
>
info
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
set_khmer_properties
(
info
[
i
]
)
;
}
static
void
setup_syllables
(
const
hb_ot_shape_plan_t
*
plan
HB_UNUSED
hb_font_t
*
font
HB_UNUSED
hb_buffer_t
*
buffer
)
{
find_syllables
(
buffer
)
;
foreach_syllable
(
buffer
start
end
)
buffer
-
>
unsafe_to_break
(
start
end
)
;
}
static
int
compare_khmer_order
(
const
hb_glyph_info_t
*
pa
const
hb_glyph_info_t
*
pb
)
{
int
a
=
pa
-
>
khmer_position
(
)
;
int
b
=
pb
-
>
khmer_position
(
)
;
return
a
<
b
?
-
1
:
a
=
=
b
?
0
:
+
1
;
}
static
void
initial_reordering_consonant_syllable
(
const
hb_ot_shape_plan_t
*
plan
hb_face_t
*
face
hb_buffer_t
*
buffer
unsigned
int
start
unsigned
int
end
)
{
const
khmer_shape_plan_t
*
khmer_plan
=
(
const
khmer_shape_plan_t
*
)
plan
-
>
data
;
hb_glyph_info_t
*
info
=
buffer
-
>
info
;
unsigned
int
base
=
start
;
info
[
base
]
.
khmer_position
(
)
=
POS_BASE_C
;
for
(
unsigned
int
i
=
base
+
1
;
i
<
end
;
i
+
+
)
if
(
is_consonant_or_vowel
(
info
[
i
]
)
)
info
[
i
]
.
khmer_position
(
)
=
POS_BELOW_C
;
for
(
unsigned
int
i
=
base
+
1
;
i
<
end
;
i
+
+
)
if
(
info
[
i
]
.
khmer_category
(
)
=
=
OT_M
)
{
for
(
unsigned
int
j
=
i
+
1
;
j
<
end
;
j
+
+
)
if
(
is_consonant_or_vowel
(
info
[
j
]
)
)
{
info
[
j
]
.
khmer_position
(
)
=
POS_FINAL_C
;
break
;
}
break
;
}
{
khmer_position_t
last_pos
=
POS_START
;
for
(
unsigned
int
i
=
start
;
i
<
end
;
i
+
+
)
{
if
(
(
FLAG_UNSAFE
(
info
[
i
]
.
khmer_category
(
)
)
&
(
JOINER_FLAGS
|
FLAG
(
OT_N
)
|
FLAG
(
OT_RS
)
|
MEDIAL_FLAGS
|
FLAG
(
OT_Coeng
)
)
)
)
{
info
[
i
]
.
khmer_position
(
)
=
last_pos
;
if
(
unlikely
(
info
[
i
]
.
khmer_category
(
)
=
=
OT_Coeng
&
&
info
[
i
]
.
khmer_position
(
)
=
=
POS_PRE_M
)
)
{
for
(
unsigned
int
j
=
i
;
j
>
start
;
j
-
-
)
if
(
info
[
j
-
1
]
.
khmer_position
(
)
!
=
POS_PRE_M
)
{
info
[
i
]
.
khmer_position
(
)
=
info
[
j
-
1
]
.
khmer_position
(
)
;
break
;
}
}
}
else
if
(
info
[
i
]
.
khmer_position
(
)
!
=
POS_SMVD
)
{
last_pos
=
(
khmer_position_t
)
info
[
i
]
.
khmer_position
(
)
;
}
}
}
{
unsigned
int
last
=
base
;
for
(
unsigned
int
i
=
base
+
1
;
i
<
end
;
i
+
+
)
if
(
is_consonant_or_vowel
(
info
[
i
]
)
)
{
for
(
unsigned
int
j
=
last
+
1
;
j
<
i
;
j
+
+
)
if
(
info
[
j
]
.
khmer_position
(
)
<
POS_SMVD
)
info
[
j
]
.
khmer_position
(
)
=
info
[
i
]
.
khmer_position
(
)
;
last
=
i
;
}
else
if
(
info
[
i
]
.
khmer_category
(
)
=
=
OT_M
)
last
=
i
;
}
{
unsigned
int
syllable
=
info
[
start
]
.
syllable
(
)
;
for
(
unsigned
int
i
=
start
;
i
<
end
;
i
+
+
)
info
[
i
]
.
syllable
(
)
=
i
-
start
;
hb_stable_sort
(
info
+
start
end
-
start
compare_khmer_order
)
;
base
=
end
;
for
(
unsigned
int
i
=
start
;
i
<
end
;
i
+
+
)
if
(
info
[
i
]
.
khmer_position
(
)
=
=
POS_BASE_C
)
{
base
=
i
;
break
;
}
if
(
unlikely
(
end
-
start
>
=
127
)
)
buffer
-
>
merge_clusters
(
start
end
)
;
else
for
(
unsigned
int
i
=
base
;
i
<
end
;
i
+
+
)
if
(
info
[
i
]
.
syllable
(
)
!
=
255
)
{
unsigned
int
max
=
i
;
unsigned
int
j
=
start
+
info
[
i
]
.
syllable
(
)
;
while
(
j
!
=
i
)
{
max
=
MAX
(
max
j
)
;
unsigned
int
next
=
start
+
info
[
j
]
.
syllable
(
)
;
info
[
j
]
.
syllable
(
)
=
255
;
j
=
next
;
}
if
(
i
!
=
max
)
buffer
-
>
merge_clusters
(
i
max
+
1
)
;
}
for
(
unsigned
int
i
=
start
;
i
<
end
;
i
+
+
)
info
[
i
]
.
syllable
(
)
=
syllable
;
}
{
hb_mask_t
mask
;
mask
=
khmer_plan
-
>
mask_array
[
BLWF
]
|
khmer_plan
-
>
mask_array
[
ABVF
]
|
khmer_plan
-
>
mask_array
[
PSTF
]
;
for
(
unsigned
int
i
=
base
+
1
;
i
<
end
;
i
+
+
)
info
[
i
]
.
mask
|
=
mask
;
}
unsigned
int
pref_len
=
2
;
if
(
khmer_plan
-
>
mask_array
[
PREF
]
&
&
base
+
pref_len
<
end
)
{
for
(
unsigned
int
i
=
base
+
1
;
i
+
pref_len
-
1
<
end
;
i
+
+
)
{
hb_codepoint_t
glyphs
[
2
]
;
for
(
unsigned
int
j
=
0
;
j
<
pref_len
;
j
+
+
)
glyphs
[
j
]
=
info
[
i
+
j
]
.
codepoint
;
if
(
khmer_plan
-
>
pref
.
would_substitute
(
glyphs
pref_len
face
)
)
{
for
(
unsigned
int
j
=
0
;
j
<
pref_len
;
j
+
+
)
info
[
i
+
+
]
.
mask
|
=
khmer_plan
-
>
mask_array
[
PREF
]
;
if
(
khmer_plan
-
>
mask_array
[
CFAR
]
)
for
(
;
i
<
end
;
i
+
+
)
info
[
i
]
.
mask
|
=
khmer_plan
-
>
mask_array
[
CFAR
]
;
break
;
}
}
}
}
static
void
initial_reordering_syllable
(
const
hb_ot_shape_plan_t
*
plan
hb_face_t
*
face
hb_buffer_t
*
buffer
unsigned
int
start
unsigned
int
end
)
{
syllable_type_t
syllable_type
=
(
syllable_type_t
)
(
buffer
-
>
info
[
start
]
.
syllable
(
)
&
0x0F
)
;
switch
(
syllable_type
)
{
case
broken_cluster
:
case
consonant_syllable
:
initial_reordering_consonant_syllable
(
plan
face
buffer
start
end
)
;
break
;
case
non_khmer_cluster
:
break
;
}
}
static
inline
void
insert_dotted_circles
(
const
hb_ot_shape_plan_t
*
plan
HB_UNUSED
hb_font_t
*
font
hb_buffer_t
*
buffer
)
{
bool
has_broken_syllables
=
false
;
unsigned
int
count
=
buffer
-
>
len
;
hb_glyph_info_t
*
info
=
buffer
-
>
info
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
if
(
(
info
[
i
]
.
syllable
(
)
&
0x0F
)
=
=
broken_cluster
)
{
has_broken_syllables
=
true
;
break
;
}
if
(
likely
(
!
has_broken_syllables
)
)
return
;
hb_codepoint_t
dottedcircle_glyph
;
if
(
!
font
-
>
get_nominal_glyph
(
0x25CCu
&
dottedcircle_glyph
)
)
return
;
hb_glyph_info_t
dottedcircle
=
{
0
}
;
dottedcircle
.
codepoint
=
0x25CCu
;
set_khmer_properties
(
dottedcircle
)
;
dottedcircle
.
codepoint
=
dottedcircle_glyph
;
buffer
-
>
clear_output
(
)
;
buffer
-
>
idx
=
0
;
unsigned
int
last_syllable
=
0
;
while
(
buffer
-
>
idx
<
buffer
-
>
len
&
&
buffer
-
>
successful
)
{
unsigned
int
syllable
=
buffer
-
>
cur
(
)
.
syllable
(
)
;
syllable_type_t
syllable_type
=
(
syllable_type_t
)
(
syllable
&
0x0F
)
;
if
(
unlikely
(
last_syllable
!
=
syllable
&
&
syllable_type
=
=
broken_cluster
)
)
{
last_syllable
=
syllable
;
hb_glyph_info_t
ginfo
=
dottedcircle
;
ginfo
.
cluster
=
buffer
-
>
cur
(
)
.
cluster
;
ginfo
.
mask
=
buffer
-
>
cur
(
)
.
mask
;
ginfo
.
syllable
(
)
=
buffer
-
>
cur
(
)
.
syllable
(
)
;
while
(
buffer
-
>
idx
<
buffer
-
>
len
&
&
buffer
-
>
successful
&
&
last_syllable
=
=
buffer
-
>
cur
(
)
.
syllable
(
)
&
&
buffer
-
>
cur
(
)
.
khmer_category
(
)
=
=
OT_Repha
)
buffer
-
>
next_glyph
(
)
;
buffer
-
>
output_info
(
ginfo
)
;
}
else
buffer
-
>
next_glyph
(
)
;
}
buffer
-
>
swap_buffers
(
)
;
}
static
void
initial_reordering
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
hb_buffer_t
*
buffer
)
{
insert_dotted_circles
(
plan
font
buffer
)
;
foreach_syllable
(
buffer
start
end
)
initial_reordering_syllable
(
plan
font
-
>
face
buffer
start
end
)
;
}
static
void
final_reordering_syllable
(
const
hb_ot_shape_plan_t
*
plan
hb_buffer_t
*
buffer
unsigned
int
start
unsigned
int
end
)
{
const
khmer_shape_plan_t
*
khmer_plan
=
(
const
khmer_shape_plan_t
*
)
plan
-
>
data
;
hb_glyph_info_t
*
info
=
buffer
-
>
info
;
if
(
khmer_plan
-
>
virama_glyph
)
{
unsigned
int
virama_glyph
=
khmer_plan
-
>
virama_glyph
;
for
(
unsigned
int
i
=
start
;
i
<
end
;
i
+
+
)
if
(
info
[
i
]
.
codepoint
=
=
virama_glyph
&
&
_hb_glyph_info_ligated
(
&
info
[
i
]
)
&
&
_hb_glyph_info_multiplied
(
&
info
[
i
]
)
)
{
info
[
i
]
.
khmer_category
(
)
=
OT_Coeng
;
_hb_glyph_info_clear_ligated_and_multiplied
(
&
info
[
i
]
)
;
}
}
bool
try_pref
=
!
!
khmer_plan
-
>
mask_array
[
PREF
]
;
unsigned
int
base
;
for
(
base
=
start
;
base
<
end
;
base
+
+
)
if
(
info
[
base
]
.
khmer_position
(
)
>
=
POS_BASE_C
)
{
if
(
try_pref
&
&
base
+
1
<
end
)
{
for
(
unsigned
int
i
=
base
+
1
;
i
<
end
;
i
+
+
)
if
(
(
info
[
i
]
.
mask
&
khmer_plan
-
>
mask_array
[
PREF
]
)
!
=
0
)
{
if
(
!
(
_hb_glyph_info_substituted
(
&
info
[
i
]
)
&
&
_hb_glyph_info_ligated_and_didnt_multiply
(
&
info
[
i
]
)
)
)
{
base
=
i
;
while
(
base
<
end
&
&
is_coeng
(
info
[
base
]
)
)
base
+
+
;
info
[
base
]
.
khmer_position
(
)
=
POS_BASE_C
;
try_pref
=
false
;
}
break
;
}
}
if
(
start
<
base
&
&
info
[
base
]
.
khmer_position
(
)
>
POS_BASE_C
)
base
-
-
;
break
;
}
if
(
base
=
=
end
&
&
start
<
base
&
&
is_one_of
(
info
[
base
-
1
]
FLAG
(
OT_ZWJ
)
)
)
base
-
-
;
if
(
base
<
end
)
while
(
start
<
base
&
&
is_one_of
(
info
[
base
]
(
FLAG
(
OT_N
)
|
FLAG
(
OT_Coeng
)
)
)
)
base
-
-
;
if
(
start
+
1
<
end
&
&
start
<
base
)
{
unsigned
int
new_pos
=
base
=
=
end
?
base
-
2
:
base
-
1
;
while
(
new_pos
>
start
&
&
!
(
is_one_of
(
info
[
new_pos
]
(
FLAG
(
OT_M
)
|
FLAG
(
OT_Coeng
)
)
)
)
)
new_pos
-
-
;
if
(
is_coeng
(
info
[
new_pos
]
)
&
&
info
[
new_pos
]
.
khmer_position
(
)
!
=
POS_PRE_M
)
{
if
(
new_pos
+
1
<
end
&
&
is_joiner
(
info
[
new_pos
+
1
]
)
)
new_pos
+
+
;
}
else
new_pos
=
start
;
if
(
start
<
new_pos
&
&
info
[
new_pos
]
.
khmer_position
(
)
!
=
POS_PRE_M
)
{
for
(
unsigned
int
i
=
new_pos
;
i
>
start
;
i
-
-
)
if
(
info
[
i
-
1
]
.
khmer_position
(
)
=
=
POS_PRE_M
)
{
unsigned
int
old_pos
=
i
-
1
;
if
(
old_pos
<
base
&
&
base
<
=
new_pos
)
base
-
-
;
hb_glyph_info_t
tmp
=
info
[
old_pos
]
;
memmove
(
&
info
[
old_pos
]
&
info
[
old_pos
+
1
]
(
new_pos
-
old_pos
)
*
sizeof
(
info
[
0
]
)
)
;
info
[
new_pos
]
=
tmp
;
buffer
-
>
merge_clusters
(
new_pos
MIN
(
end
base
+
1
)
)
;
new_pos
-
-
;
}
}
else
{
for
(
unsigned
int
i
=
start
;
i
<
base
;
i
+
+
)
if
(
info
[
i
]
.
khmer_position
(
)
=
=
POS_PRE_M
)
{
buffer
-
>
merge_clusters
(
i
MIN
(
end
base
+
1
)
)
;
break
;
}
}
}
if
(
try_pref
&
&
base
+
1
<
end
)
{
for
(
unsigned
int
i
=
base
+
1
;
i
<
end
;
i
+
+
)
if
(
(
info
[
i
]
.
mask
&
khmer_plan
-
>
mask_array
[
PREF
]
)
!
=
0
)
{
if
(
_hb_glyph_info_ligated_and_didnt_multiply
(
&
info
[
i
]
)
)
{
unsigned
int
new_pos
=
base
;
while
(
new_pos
>
start
&
&
!
(
is_one_of
(
info
[
new_pos
-
1
]
FLAG
(
OT_M
)
|
FLAG
(
OT_Coeng
)
)
)
)
new_pos
-
-
;
if
(
new_pos
>
start
&
&
info
[
new_pos
-
1
]
.
khmer_category
(
)
=
=
OT_M
)
{
unsigned
int
old_pos
=
i
;
for
(
unsigned
int
j
=
base
+
1
;
j
<
old_pos
;
j
+
+
)
if
(
info
[
j
]
.
khmer_category
(
)
=
=
OT_M
)
{
new_pos
-
-
;
break
;
}
}
if
(
new_pos
>
start
&
&
is_coeng
(
info
[
new_pos
-
1
]
)
)
{
if
(
new_pos
<
end
&
&
is_joiner
(
info
[
new_pos
]
)
)
new_pos
+
+
;
}
{
unsigned
int
old_pos
=
i
;
buffer
-
>
merge_clusters
(
new_pos
old_pos
+
1
)
;
hb_glyph_info_t
tmp
=
info
[
old_pos
]
;
memmove
(
&
info
[
new_pos
+
1
]
&
info
[
new_pos
]
(
old_pos
-
new_pos
)
*
sizeof
(
info
[
0
]
)
)
;
info
[
new_pos
]
=
tmp
;
if
(
new_pos
<
=
base
&
&
base
<
old_pos
)
base
+
+
;
}
}
break
;
}
}
if
(
hb_options
(
)
.
uniscribe_bug_compatible
)
{
buffer
-
>
merge_clusters
(
start
end
)
;
}
}
static
void
final_reordering
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
HB_UNUSED
hb_buffer_t
*
buffer
)
{
unsigned
int
count
=
buffer
-
>
len
;
if
(
unlikely
(
!
count
)
)
return
;
foreach_syllable
(
buffer
start
end
)
final_reordering_syllable
(
plan
buffer
start
end
)
;
HB_BUFFER_DEALLOCATE_VAR
(
buffer
khmer_category
)
;
HB_BUFFER_DEALLOCATE_VAR
(
buffer
khmer_position
)
;
}
static
void
clear_syllables
(
const
hb_ot_shape_plan_t
*
plan
HB_UNUSED
hb_font_t
*
font
HB_UNUSED
hb_buffer_t
*
buffer
)
{
hb_glyph_info_t
*
info
=
buffer
-
>
info
;
unsigned
int
count
=
buffer
-
>
len
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
info
[
i
]
.
syllable
(
)
=
0
;
}
static
bool
decompose_khmer
(
const
hb_ot_shape_normalize_context_t
*
c
hb_codepoint_t
ab
hb_codepoint_t
*
a
hb_codepoint_t
*
b
)
{
switch
(
ab
)
{
case
0x17BEu
:
*
a
=
0x17C1u
;
*
b
=
0x17BEu
;
return
true
;
case
0x17BFu
:
*
a
=
0x17C1u
;
*
b
=
0x17BFu
;
return
true
;
case
0x17C0u
:
*
a
=
0x17C1u
;
*
b
=
0x17C0u
;
return
true
;
case
0x17C4u
:
*
a
=
0x17C1u
;
*
b
=
0x17C4u
;
return
true
;
case
0x17C5u
:
*
a
=
0x17C1u
;
*
b
=
0x17C5u
;
return
true
;
}
return
(
bool
)
c
-
>
unicode
-
>
decompose
(
ab
a
b
)
;
}
static
bool
compose_khmer
(
const
hb_ot_shape_normalize_context_t
*
c
hb_codepoint_t
a
hb_codepoint_t
b
hb_codepoint_t
*
ab
)
{
if
(
HB_UNICODE_GENERAL_CATEGORY_IS_MARK
(
c
-
>
unicode
-
>
general_category
(
a
)
)
)
return
false
;
return
(
bool
)
c
-
>
unicode
-
>
compose
(
a
b
ab
)
;
}
const
hb_ot_complex_shaper_t
_hb_ot_complex_shaper_khmer
=
{
collect_features_khmer
override_features_khmer
data_create_khmer
data_destroy_khmer
nullptr
nullptr
HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT
decompose_khmer
compose_khmer
setup_masks_khmer
nullptr
nullptr
HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE
false
}
;
