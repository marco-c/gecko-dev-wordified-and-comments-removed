#
include
"
hb
.
hh
"
#
ifndef
HB_NO_OT_SHAPE
#
include
"
hb
-
ot
-
shape
-
normalize
.
hh
"
#
include
"
hb
-
ot
-
shaper
.
hh
"
#
include
"
hb
-
ot
-
shape
.
hh
"
static
inline
void
set_glyph
(
hb_glyph_info_t
&
info
hb_font_t
*
font
)
{
(
void
)
font
-
>
get_nominal_glyph
(
info
.
codepoint
&
info
.
glyph_index
(
)
)
;
}
static
inline
void
output_char
(
hb_buffer_t
*
buffer
hb_codepoint_t
unichar
hb_codepoint_t
glyph
)
{
buffer
-
>
cur
(
)
.
glyph_index
(
)
=
glyph
;
(
void
)
buffer
-
>
output_glyph
(
unichar
)
;
_hb_glyph_info_set_unicode_props
(
&
buffer
-
>
prev
(
)
buffer
)
;
}
static
inline
void
next_char
(
hb_buffer_t
*
buffer
hb_codepoint_t
glyph
)
{
buffer
-
>
cur
(
)
.
glyph_index
(
)
=
glyph
;
(
void
)
buffer
-
>
next_glyph
(
)
;
}
static
inline
void
skip_char
(
hb_buffer_t
*
buffer
)
{
buffer
-
>
skip_glyph
(
)
;
}
static
inline
unsigned
int
decompose
(
const
hb_ot_shape_normalize_context_t
*
c
bool
shortest
hb_codepoint_t
ab
)
{
hb_codepoint_t
a
=
0
b
=
0
a_glyph
=
0
b_glyph
=
0
;
hb_buffer_t
*
const
buffer
=
c
-
>
buffer
;
hb_font_t
*
const
font
=
c
-
>
font
;
if
(
!
c
-
>
decompose
(
c
ab
&
a
&
b
)
|
|
(
b
&
&
!
font
-
>
get_nominal_glyph
(
b
&
b_glyph
)
)
)
return
0
;
bool
has_a
=
(
bool
)
font
-
>
get_nominal_glyph
(
a
&
a_glyph
)
;
if
(
shortest
&
&
has_a
)
{
output_char
(
buffer
a
a_glyph
)
;
if
(
likely
(
b
)
)
{
output_char
(
buffer
b
b_glyph
)
;
return
2
;
}
return
1
;
}
if
(
unsigned
ret
=
decompose
(
c
shortest
a
)
)
{
if
(
b
)
{
output_char
(
buffer
b
b_glyph
)
;
return
ret
+
1
;
}
return
ret
;
}
if
(
has_a
)
{
output_char
(
buffer
a
a_glyph
)
;
if
(
likely
(
b
)
)
{
output_char
(
buffer
b
b_glyph
)
;
return
2
;
}
return
1
;
}
return
0
;
}
static
inline
void
decompose_current_character
(
const
hb_ot_shape_normalize_context_t
*
c
bool
shortest
)
{
hb_buffer_t
*
const
buffer
=
c
-
>
buffer
;
hb_codepoint_t
u
=
buffer
-
>
cur
(
)
.
codepoint
;
hb_codepoint_t
glyph
=
0
;
if
(
shortest
&
&
c
-
>
font
-
>
get_nominal_glyph
(
u
&
glyph
buffer
-
>
not_found
)
)
{
next_char
(
buffer
glyph
)
;
return
;
}
if
(
decompose
(
c
shortest
u
)
)
{
skip_char
(
buffer
)
;
return
;
}
if
(
!
shortest
&
&
c
-
>
font
-
>
get_nominal_glyph
(
u
&
glyph
buffer
-
>
not_found
)
)
{
next_char
(
buffer
glyph
)
;
return
;
}
if
(
_hb_glyph_info_is_unicode_space
(
&
buffer
-
>
cur
(
)
)
)
{
hb_codepoint_t
space_glyph
;
hb_unicode_funcs_t
:
:
space_t
space_type
=
buffer
-
>
unicode
-
>
space_fallback_type
(
u
)
;
if
(
space_type
!
=
hb_unicode_funcs_t
:
:
NOT_SPACE
&
&
(
c
-
>
font
-
>
get_nominal_glyph
(
0x0020
&
space_glyph
)
|
|
(
space_glyph
=
buffer
-
>
invisible
)
)
)
{
_hb_glyph_info_set_unicode_space_fallback_type
(
&
buffer
-
>
cur
(
)
space_type
)
;
next_char
(
buffer
space_glyph
)
;
buffer
-
>
scratch_flags
|
=
HB_BUFFER_SCRATCH_FLAG_HAS_SPACE_FALLBACK
;
return
;
}
}
if
(
u
=
=
0x2011u
)
{
hb_codepoint_t
other_glyph
;
if
(
c
-
>
font
-
>
get_nominal_glyph
(
0x2010u
&
other_glyph
)
)
{
next_char
(
buffer
other_glyph
)
;
return
;
}
}
next_char
(
buffer
glyph
)
;
}
static
inline
void
handle_variation_selector_cluster
(
const
hb_ot_shape_normalize_context_t
*
c
unsigned
int
end
bool
short_circuit
HB_UNUSED
)
{
hb_buffer_t
*
const
buffer
=
c
-
>
buffer
;
hb_font_t
*
const
font
=
c
-
>
font
;
for
(
;
buffer
-
>
idx
<
end
-
1
&
&
buffer
-
>
successful
;
)
{
if
(
unlikely
(
buffer
-
>
unicode
-
>
is_variation_selector
(
buffer
-
>
cur
(
+
1
)
.
codepoint
)
)
)
{
if
(
font
-
>
get_variation_glyph
(
buffer
-
>
cur
(
)
.
codepoint
buffer
-
>
cur
(
+
1
)
.
codepoint
&
buffer
-
>
cur
(
)
.
glyph_index
(
)
)
)
{
hb_codepoint_t
unicode
=
buffer
-
>
cur
(
)
.
codepoint
;
(
void
)
buffer
-
>
replace_glyphs
(
2
1
&
unicode
)
;
}
else
{
set_glyph
(
buffer
-
>
cur
(
)
font
)
;
(
void
)
buffer
-
>
next_glyph
(
)
;
buffer
-
>
scratch_flags
|
=
HB_BUFFER_SCRATCH_FLAG_HAS_VARIATION_SELECTOR_FALLBACK
;
_hb_glyph_info_set_variation_selector
(
&
buffer
-
>
cur
(
)
true
)
;
if
(
buffer
-
>
not_found_variation_selector
!
=
HB_CODEPOINT_INVALID
)
_hb_glyph_info_clear_default_ignorable
(
&
buffer
-
>
cur
(
)
)
;
set_glyph
(
buffer
-
>
cur
(
)
font
)
;
(
void
)
buffer
-
>
next_glyph
(
)
;
}
while
(
buffer
-
>
idx
<
end
&
&
buffer
-
>
successful
&
&
unlikely
(
buffer
-
>
unicode
-
>
is_variation_selector
(
buffer
-
>
cur
(
)
.
codepoint
)
)
)
{
set_glyph
(
buffer
-
>
cur
(
)
font
)
;
(
void
)
buffer
-
>
next_glyph
(
)
;
}
}
else
{
set_glyph
(
buffer
-
>
cur
(
)
font
)
;
(
void
)
buffer
-
>
next_glyph
(
)
;
}
}
if
(
likely
(
buffer
-
>
idx
<
end
)
)
{
set_glyph
(
buffer
-
>
cur
(
)
font
)
;
(
void
)
buffer
-
>
next_glyph
(
)
;
}
}
static
inline
void
decompose_multi_char_cluster
(
const
hb_ot_shape_normalize_context_t
*
c
unsigned
int
end
bool
short_circuit
)
{
hb_buffer_t
*
const
buffer
=
c
-
>
buffer
;
for
(
unsigned
int
i
=
buffer
-
>
idx
;
i
<
end
&
&
buffer
-
>
successful
;
i
+
+
)
if
(
unlikely
(
buffer
-
>
unicode
-
>
is_variation_selector
(
buffer
-
>
info
[
i
]
.
codepoint
)
)
)
{
handle_variation_selector_cluster
(
c
end
short_circuit
)
;
return
;
}
while
(
buffer
-
>
idx
<
end
&
&
buffer
-
>
successful
)
decompose_current_character
(
c
short_circuit
)
;
}
static
int
compare_combining_class
(
const
hb_glyph_info_t
*
pa
const
hb_glyph_info_t
*
pb
)
{
unsigned
int
a
=
_hb_glyph_info_get_modified_combining_class
(
pa
)
;
unsigned
int
b
=
_hb_glyph_info_get_modified_combining_class
(
pb
)
;
return
a
<
b
?
-
1
:
a
=
=
b
?
0
:
+
1
;
}
void
_hb_ot_shape_normalize
(
const
hb_ot_shape_plan_t
*
plan
hb_buffer_t
*
buffer
hb_font_t
*
font
)
{
if
(
unlikely
(
!
buffer
-
>
len
)
)
return
;
_hb_buffer_assert_unicode_vars
(
buffer
)
;
hb_ot_shape_normalization_mode_t
mode
=
plan
-
>
shaper
-
>
normalization_preference
;
if
(
mode
=
=
HB_OT_SHAPE_NORMALIZATION_MODE_AUTO
)
{
if
(
plan
-
>
has_gpos_mark
)
mode
=
HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS
;
else
mode
=
HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS
;
}
hb_ot_shape_normalize_context_t
c
=
{
plan
buffer
font
buffer
-
>
unicode
plan
-
>
shaper
-
>
decompose
?
plan
-
>
shaper
-
>
decompose
:
hb_ot_shape_normalize_context_t
:
:
decompose_unicode
plan
-
>
shaper
-
>
compose
?
plan
-
>
shaper
-
>
compose
:
hb_ot_shape_normalize_context_t
:
:
compose_unicode
}
;
c
.
override_decompose_and_compose
(
plan
-
>
shaper
-
>
decompose
plan
-
>
shaper
-
>
compose
)
;
bool
always_short_circuit
=
mode
=
=
HB_OT_SHAPE_NORMALIZATION_MODE_NONE
;
bool
might_short_circuit
=
always_short_circuit
|
|
(
mode
!
=
HB_OT_SHAPE_NORMALIZATION_MODE_DECOMPOSED
&
&
mode
!
=
HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT
)
;
unsigned
int
count
;
bool
all_simple
=
true
;
{
buffer
-
>
clear_output
(
)
;
count
=
buffer
-
>
len
;
buffer
-
>
idx
=
0
;
do
{
unsigned
int
end
;
for
(
end
=
buffer
-
>
idx
+
1
;
end
<
count
;
end
+
+
)
if
(
_hb_glyph_info_is_unicode_mark
(
&
buffer
-
>
info
[
end
]
)
)
break
;
if
(
end
<
count
)
end
-
-
;
if
(
might_short_circuit
)
{
unsigned
int
done
=
font
-
>
get_nominal_glyphs
(
end
-
buffer
-
>
idx
&
buffer
-
>
cur
(
)
.
codepoint
sizeof
(
buffer
-
>
info
[
0
]
)
&
buffer
-
>
cur
(
)
.
glyph_index
(
)
sizeof
(
buffer
-
>
info
[
0
]
)
)
;
if
(
unlikely
(
!
buffer
-
>
next_glyphs
(
done
)
)
)
break
;
}
while
(
buffer
-
>
idx
<
end
&
&
buffer
-
>
successful
)
decompose_current_character
(
&
c
might_short_circuit
)
;
if
(
buffer
-
>
idx
=
=
count
|
|
!
buffer
-
>
successful
)
break
;
all_simple
=
false
;
for
(
end
=
buffer
-
>
idx
+
1
;
end
<
count
;
end
+
+
)
if
(
!
_hb_glyph_info_is_unicode_mark
(
&
buffer
-
>
info
[
end
]
)
)
break
;
decompose_multi_char_cluster
(
&
c
end
always_short_circuit
)
;
}
while
(
buffer
-
>
idx
<
count
&
&
buffer
-
>
successful
)
;
buffer
-
>
sync
(
)
;
}
if
(
!
all_simple
&
&
buffer
-
>
message
(
font
"
start
reorder
"
)
)
{
count
=
buffer
-
>
len
;
hb_glyph_info_t
*
info
=
buffer
-
>
info
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
_hb_glyph_info_get_modified_combining_class
(
&
info
[
i
]
)
=
=
0
)
continue
;
unsigned
int
end
;
for
(
end
=
i
+
1
;
end
<
count
;
end
+
+
)
if
(
_hb_glyph_info_get_modified_combining_class
(
&
info
[
end
]
)
=
=
0
)
break
;
if
(
end
-
i
>
HB_OT_SHAPE_MAX_COMBINING_MARKS
)
{
i
=
end
;
continue
;
}
buffer
-
>
sort
(
i
end
compare_combining_class
)
;
if
(
plan
-
>
shaper
-
>
reorder_marks
)
plan
-
>
shaper
-
>
reorder_marks
(
plan
buffer
i
end
)
;
i
=
end
;
}
(
void
)
buffer
-
>
message
(
font
"
end
reorder
"
)
;
}
if
(
buffer
-
>
scratch_flags
&
HB_BUFFER_SCRATCH_FLAG_HAS_CGJ
)
{
unsigned
count
=
buffer
-
>
len
;
hb_glyph_info_t
*
info
=
buffer
-
>
info
;
for
(
unsigned
int
i
=
1
;
i
+
1
<
count
;
i
+
+
)
if
(
info
[
i
]
.
codepoint
=
=
0x034Fu
&
&
(
info_cc
(
info
[
i
+
1
]
)
=
=
0
|
|
info_cc
(
info
[
i
-
1
]
)
<
=
info_cc
(
info
[
i
+
1
]
)
)
)
{
_hb_glyph_info_unhide
(
&
info
[
i
]
)
;
}
}
if
(
!
all_simple
&
&
buffer
-
>
successful
&
&
(
mode
=
=
HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS
|
|
mode
=
=
HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT
)
)
{
buffer
-
>
clear_output
(
)
;
count
=
buffer
-
>
len
;
unsigned
int
starter
=
0
;
(
void
)
buffer
-
>
next_glyph
(
)
;
while
(
buffer
-
>
idx
<
count
)
{
hb_codepoint_t
composed
glyph
;
if
(
_hb_glyph_info_is_unicode_mark
(
&
buffer
-
>
cur
(
)
)
)
{
if
(
(
starter
=
=
buffer
-
>
out_len
-
1
|
|
info_cc
(
buffer
-
>
prev
(
)
)
<
info_cc
(
buffer
-
>
cur
(
)
)
)
&
&
c
.
compose
(
&
c
buffer
-
>
out_info
[
starter
]
.
codepoint
buffer
-
>
cur
(
)
.
codepoint
&
composed
)
&
&
font
-
>
get_nominal_glyph
(
composed
&
glyph
)
)
{
if
(
unlikely
(
!
buffer
-
>
next_glyph
(
)
)
)
break
;
buffer
-
>
merge_out_clusters
(
starter
buffer
-
>
out_len
)
;
buffer
-
>
out_len
-
-
;
buffer
-
>
out_info
[
starter
]
.
codepoint
=
composed
;
buffer
-
>
out_info
[
starter
]
.
glyph_index
(
)
=
glyph
;
_hb_glyph_info_set_unicode_props
(
&
buffer
-
>
out_info
[
starter
]
buffer
)
;
continue
;
}
}
if
(
unlikely
(
!
buffer
-
>
next_glyph
(
)
)
)
break
;
if
(
info_cc
(
buffer
-
>
prev
(
)
)
=
=
0
)
starter
=
buffer
-
>
out_len
-
1
;
}
buffer
-
>
sync
(
)
;
}
}
#
endif
