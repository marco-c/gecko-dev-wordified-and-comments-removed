#
ifndef
HB_OT_META_TABLE_HH
#
define
HB_OT_META_TABLE_HH
#
include
"
hb
-
open
-
type
.
hh
"
#
define
HB_OT_TAG_meta
HB_TAG
(
'
m
'
'
e
'
'
t
'
'
a
'
)
namespace
OT
{
struct
DataMap
{
int
cmp
(
hb_tag_t
a
)
const
{
return
tag
.
cmp
(
a
)
;
}
hb_tag_t
get_tag
(
)
const
{
return
tag
;
}
hb_blob_t
*
reference_entry
(
hb_blob_t
*
meta_blob
)
const
{
return
hb_blob_create_sub_blob
(
meta_blob
dataZ
dataLength
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
dataZ
.
sanitize
(
c
base
dataLength
)
)
)
;
}
protected
:
Tag
tag
;
LOffsetTo
<
UnsizedArrayOf
<
HBUINT8
>
>
dataZ
;
HBUINT32
dataLength
;
public
:
DEFINE_SIZE_STATIC
(
12
)
;
}
;
struct
meta
{
static
constexpr
hb_tag_t
tableTag
=
HB_OT_TAG_meta
;
struct
accelerator_t
{
void
init
(
hb_face_t
*
face
)
{
table
=
hb_sanitize_context_t
(
)
.
reference_table
<
meta
>
(
face
)
;
}
void
fini
(
)
{
table
.
destroy
(
)
;
}
hb_blob_t
*
reference_entry
(
hb_tag_t
tag
)
const
{
return
table
-
>
dataMaps
.
lsearch
(
tag
)
.
reference_entry
(
table
.
get_blob
(
)
)
;
}
unsigned
int
get_entries
(
unsigned
int
start_offset
unsigned
int
*
count
hb_ot_meta_tag_t
*
entries
)
const
{
if
(
count
)
{
+
table
-
>
dataMaps
.
sub_array
(
start_offset
count
)
|
hb_map
(
&
DataMap
:
:
get_tag
)
|
hb_map
(
[
]
(
hb_tag_t
tag
)
{
return
(
hb_ot_meta_tag_t
)
tag
;
}
)
|
hb_sink
(
hb_array
(
entries
*
count
)
)
;
}
return
table
-
>
dataMaps
.
len
;
}
private
:
hb_blob_ptr_t
<
meta
>
table
;
}
;
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
version
=
=
1
&
&
dataMaps
.
sanitize
(
c
this
)
)
)
;
}
protected
:
HBUINT32
version
;
HBUINT32
flags
;
HBUINT32
dataOffset
;
LArrayOf
<
DataMap
>
dataMaps
;
public
:
DEFINE_SIZE_ARRAY
(
16
dataMaps
)
;
}
;
struct
meta_accelerator_t
:
meta
:
:
accelerator_t
{
}
;
}
#
endif
