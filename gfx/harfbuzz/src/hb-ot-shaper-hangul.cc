#
include
"
hb
.
hh
"
#
ifndef
HB_NO_OT_SHAPE
#
include
"
hb
-
ot
-
shaper
.
hh
"
enum
{
_JMO
LJMO
VJMO
TJMO
FIRST_HANGUL_FEATURE
=
LJMO
HANGUL_FEATURE_COUNT
=
TJMO
+
1
}
;
static
const
hb_tag_t
hangul_features
[
HANGUL_FEATURE_COUNT
]
=
{
HB_TAG_NONE
HB_TAG
(
'
l
'
'
j
'
'
m
'
'
o
'
)
HB_TAG
(
'
v
'
'
j
'
'
m
'
'
o
'
)
HB_TAG
(
'
t
'
'
j
'
'
m
'
'
o
'
)
}
;
static
void
collect_features_hangul
(
hb_ot_shape_planner_t
*
plan
)
{
hb_ot_map_builder_t
*
map
=
&
plan
-
>
map
;
for
(
unsigned
int
i
=
FIRST_HANGUL_FEATURE
;
i
<
HANGUL_FEATURE_COUNT
;
i
+
+
)
map
-
>
add_feature
(
hangul_features
[
i
]
)
;
}
static
void
override_features_hangul
(
hb_ot_shape_planner_t
*
plan
)
{
plan
-
>
map
.
disable_feature
(
HB_TAG
(
'
c
'
'
a
'
'
l
'
'
t
'
)
)
;
}
struct
hangul_shape_plan_t
{
hb_mask_t
mask_array
[
HANGUL_FEATURE_COUNT
]
;
}
;
static
void
*
data_create_hangul
(
const
hb_ot_shape_plan_t
*
plan
)
{
hangul_shape_plan_t
*
hangul_plan
=
(
hangul_shape_plan_t
*
)
hb_calloc
(
1
sizeof
(
hangul_shape_plan_t
)
)
;
if
(
unlikely
(
!
hangul_plan
)
)
return
nullptr
;
for
(
unsigned
int
i
=
0
;
i
<
HANGUL_FEATURE_COUNT
;
i
+
+
)
hangul_plan
-
>
mask_array
[
i
]
=
plan
-
>
map
.
get_1_mask
(
hangul_features
[
i
]
)
;
return
hangul_plan
;
}
static
void
data_destroy_hangul
(
void
*
data
)
{
hb_free
(
data
)
;
}
#
define
LBase
0x1100u
#
define
VBase
0x1161u
#
define
TBase
0x11A7u
#
define
LCount
19u
#
define
VCount
21u
#
define
TCount
28u
#
define
SBase
0xAC00u
#
define
NCount
(
VCount
*
TCount
)
#
define
SCount
(
LCount
*
NCount
)
#
define
isCombiningL
(
u
)
(
hb_in_range
<
hb_codepoint_t
>
(
(
u
)
LBase
LBase
+
LCount
-
1
)
)
#
define
isCombiningV
(
u
)
(
hb_in_range
<
hb_codepoint_t
>
(
(
u
)
VBase
VBase
+
VCount
-
1
)
)
#
define
isCombiningT
(
u
)
(
hb_in_range
<
hb_codepoint_t
>
(
(
u
)
TBase
+
1
TBase
+
TCount
-
1
)
)
#
define
isCombinedS
(
u
)
(
hb_in_range
<
hb_codepoint_t
>
(
(
u
)
SBase
SBase
+
SCount
-
1
)
)
#
define
isL
(
u
)
(
hb_in_ranges
<
hb_codepoint_t
>
(
(
u
)
0x1100u
0x115Fu
0xA960u
0xA97Cu
)
)
#
define
isV
(
u
)
(
hb_in_ranges
<
hb_codepoint_t
>
(
(
u
)
0x1160u
0x11A7u
0xD7B0u
0xD7C6u
)
)
#
define
isT
(
u
)
(
hb_in_ranges
<
hb_codepoint_t
>
(
(
u
)
0x11A8u
0x11FFu
0xD7CBu
0xD7FBu
)
)
#
define
isHangulTone
(
u
)
(
hb_in_range
<
hb_codepoint_t
>
(
(
u
)
0x302Eu
0x302Fu
)
)
#
define
hangul_shaping_feature
(
)
ot_shaper_var_u8_auxiliary
(
)
/
*
hangul
jamo
shaping
feature
*
/
static
bool
is_zero_width_char
(
hb_font_t
*
font
hb_codepoint_t
unicode
)
{
hb_codepoint_t
glyph
;
return
hb_font_get_glyph
(
font
unicode
0
&
glyph
)
&
&
hb_font_get_glyph_h_advance
(
font
glyph
)
=
=
0
;
}
static
void
preprocess_text_hangul
(
const
hb_ot_shape_plan_t
*
plan
HB_UNUSED
hb_buffer_t
*
buffer
hb_font_t
*
font
)
{
HB_BUFFER_ALLOCATE_VAR
(
buffer
hangul_shaping_feature
)
;
buffer
-
>
clear_output
(
)
;
unsigned
int
start
=
0
end
=
0
;
unsigned
int
count
=
buffer
-
>
len
;
for
(
buffer
-
>
idx
=
0
;
buffer
-
>
idx
<
count
&
&
buffer
-
>
successful
;
)
{
hb_codepoint_t
u
=
buffer
-
>
cur
(
)
.
codepoint
;
if
(
isHangulTone
(
u
)
)
{
if
(
start
<
end
&
&
end
=
=
buffer
-
>
out_len
)
{
buffer
-
>
unsafe_to_break_from_outbuffer
(
start
buffer
-
>
idx
)
;
if
(
unlikely
(
!
buffer
-
>
next_glyph
(
)
)
)
break
;
if
(
!
is_zero_width_char
(
font
u
)
)
{
buffer
-
>
merge_out_clusters
(
start
end
+
1
)
;
hb_glyph_info_t
*
info
=
buffer
-
>
out_info
;
hb_glyph_info_t
tone
=
info
[
end
]
;
memmove
(
&
info
[
start
+
1
]
&
info
[
start
]
(
end
-
start
)
*
sizeof
(
hb_glyph_info_t
)
)
;
info
[
start
]
=
tone
;
}
}
else
{
if
(
!
(
buffer
-
>
flags
&
HB_BUFFER_FLAG_DO_NOT_INSERT_DOTTED_CIRCLE
)
&
&
font
-
>
has_glyph
(
0x25CCu
)
)
{
hb_codepoint_t
chars
[
2
]
;
if
(
!
is_zero_width_char
(
font
u
)
)
{
chars
[
0
]
=
u
;
chars
[
1
]
=
0x25CCu
;
}
else
{
chars
[
0
]
=
0x25CCu
;
chars
[
1
]
=
u
;
}
(
void
)
buffer
-
>
replace_glyphs
(
1
2
chars
)
;
}
else
{
(
void
)
buffer
-
>
next_glyph
(
)
;
}
}
start
=
end
=
buffer
-
>
out_len
;
continue
;
}
start
=
buffer
-
>
out_len
;
if
(
isL
(
u
)
&
&
buffer
-
>
idx
+
1
<
count
)
{
hb_codepoint_t
l
=
u
;
hb_codepoint_t
v
=
buffer
-
>
cur
(
+
1
)
.
codepoint
;
if
(
isV
(
v
)
)
{
hb_codepoint_t
t
=
0
;
unsigned
int
tindex
=
0
;
if
(
buffer
-
>
idx
+
2
<
count
)
{
t
=
buffer
-
>
cur
(
+
2
)
.
codepoint
;
if
(
isT
(
t
)
)
tindex
=
t
-
TBase
;
else
t
=
0
;
}
buffer
-
>
unsafe_to_break
(
buffer
-
>
idx
buffer
-
>
idx
+
(
t
?
3
:
2
)
)
;
if
(
isCombiningL
(
l
)
&
&
isCombiningV
(
v
)
&
&
(
t
=
=
0
|
|
isCombiningT
(
t
)
)
)
{
hb_codepoint_t
s
=
SBase
+
(
l
-
LBase
)
*
NCount
+
(
v
-
VBase
)
*
TCount
+
tindex
;
if
(
font
-
>
has_glyph
(
s
)
)
{
(
void
)
buffer
-
>
replace_glyphs
(
t
?
3
:
2
1
&
s
)
;
end
=
start
+
1
;
continue
;
}
}
buffer
-
>
cur
(
)
.
hangul_shaping_feature
(
)
=
LJMO
;
(
void
)
buffer
-
>
next_glyph
(
)
;
buffer
-
>
cur
(
)
.
hangul_shaping_feature
(
)
=
VJMO
;
(
void
)
buffer
-
>
next_glyph
(
)
;
if
(
t
)
{
buffer
-
>
cur
(
)
.
hangul_shaping_feature
(
)
=
TJMO
;
(
void
)
buffer
-
>
next_glyph
(
)
;
end
=
start
+
3
;
}
else
end
=
start
+
2
;
if
(
unlikely
(
!
buffer
-
>
successful
)
)
break
;
if
(
buffer
-
>
cluster_level
=
=
HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES
)
buffer
-
>
merge_out_clusters
(
start
end
)
;
continue
;
}
}
else
if
(
isCombinedS
(
u
)
)
{
hb_codepoint_t
s
=
u
;
bool
has_glyph
=
font
-
>
has_glyph
(
s
)
;
unsigned
int
lindex
=
(
s
-
SBase
)
/
NCount
;
unsigned
int
nindex
=
(
s
-
SBase
)
%
NCount
;
unsigned
int
vindex
=
nindex
/
TCount
;
unsigned
int
tindex
=
nindex
%
TCount
;
if
(
!
tindex
&
&
buffer
-
>
idx
+
1
<
count
&
&
isCombiningT
(
buffer
-
>
cur
(
+
1
)
.
codepoint
)
)
{
unsigned
int
new_tindex
=
buffer
-
>
cur
(
+
1
)
.
codepoint
-
TBase
;
hb_codepoint_t
new_s
=
s
+
new_tindex
;
if
(
font
-
>
has_glyph
(
new_s
)
)
{
(
void
)
buffer
-
>
replace_glyphs
(
2
1
&
new_s
)
;
end
=
start
+
1
;
continue
;
}
else
buffer
-
>
unsafe_to_break
(
buffer
-
>
idx
buffer
-
>
idx
+
2
)
;
}
if
(
!
has_glyph
|
|
(
!
tindex
&
&
buffer
-
>
idx
+
1
<
count
&
&
isT
(
buffer
-
>
cur
(
+
1
)
.
codepoint
)
)
)
{
hb_codepoint_t
decomposed
[
3
]
=
{
LBase
+
lindex
VBase
+
vindex
TBase
+
tindex
}
;
if
(
font
-
>
has_glyph
(
decomposed
[
0
]
)
&
&
font
-
>
has_glyph
(
decomposed
[
1
]
)
&
&
(
!
tindex
|
|
font
-
>
has_glyph
(
decomposed
[
2
]
)
)
)
{
unsigned
int
s_len
=
tindex
?
3
:
2
;
(
void
)
buffer
-
>
replace_glyphs
(
1
s_len
decomposed
)
;
if
(
has_glyph
&
&
!
tindex
)
{
(
void
)
buffer
-
>
next_glyph
(
)
;
s_len
+
+
;
}
if
(
unlikely
(
!
buffer
-
>
successful
)
)
break
;
hb_glyph_info_t
*
info
=
buffer
-
>
out_info
;
end
=
start
+
s_len
;
unsigned
int
i
=
start
;
info
[
i
+
+
]
.
hangul_shaping_feature
(
)
=
LJMO
;
info
[
i
+
+
]
.
hangul_shaping_feature
(
)
=
VJMO
;
if
(
i
<
end
)
info
[
i
+
+
]
.
hangul_shaping_feature
(
)
=
TJMO
;
if
(
buffer
-
>
cluster_level
=
=
HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES
)
buffer
-
>
merge_out_clusters
(
start
end
)
;
continue
;
}
else
if
(
(
!
tindex
&
&
buffer
-
>
idx
+
1
<
count
&
&
isT
(
buffer
-
>
cur
(
+
1
)
.
codepoint
)
)
)
buffer
-
>
unsafe_to_break
(
buffer
-
>
idx
buffer
-
>
idx
+
2
)
;
}
if
(
has_glyph
)
{
end
=
start
+
1
;
}
}
(
void
)
buffer
-
>
next_glyph
(
)
;
}
buffer
-
>
sync
(
)
;
}
static
void
setup_masks_hangul
(
const
hb_ot_shape_plan_t
*
plan
hb_buffer_t
*
buffer
hb_font_t
*
font
HB_UNUSED
)
{
const
hangul_shape_plan_t
*
hangul_plan
=
(
const
hangul_shape_plan_t
*
)
plan
-
>
data
;
if
(
likely
(
hangul_plan
)
)
{
unsigned
int
count
=
buffer
-
>
len
;
hb_glyph_info_t
*
info
=
buffer
-
>
info
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
info
+
+
)
info
-
>
mask
|
=
hangul_plan
-
>
mask_array
[
info
-
>
hangul_shaping_feature
(
)
]
;
}
HB_BUFFER_DEALLOCATE_VAR
(
buffer
hangul_shaping_feature
)
;
}
const
hb_ot_shaper_t
_hb_ot_shaper_hangul
=
{
collect_features_hangul
override_features_hangul
data_create_hangul
data_destroy_hangul
preprocess_text_hangul
nullptr
nullptr
nullptr
setup_masks_hangul
nullptr
HB_TAG_NONE
HB_OT_SHAPE_NORMALIZATION_MODE_NONE
HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE
false
}
;
#
endif
