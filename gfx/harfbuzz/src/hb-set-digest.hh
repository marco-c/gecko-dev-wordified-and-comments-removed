#
ifndef
HB_SET_DIGEST_HH
#
define
HB_SET_DIGEST_HH
#
include
"
hb
.
hh
"
#
include
"
hb
-
machinery
.
hh
"
static
constexpr
unsigned
hb_set_digest_shifts
[
]
=
{
4
0
6
}
;
struct
hb_set_digest_t
{
using
mask_t
=
uint64_t
;
static
constexpr
unsigned
n
=
ARRAY_LENGTH_CONST
(
hb_set_digest_shifts
)
;
static
constexpr
unsigned
mask_bytes
=
sizeof
(
mask_t
)
;
static
constexpr
unsigned
mask_bits
=
sizeof
(
mask_t
)
*
8
;
static
constexpr
hb_codepoint_t
mb1
=
mask_bits
-
1
;
static
constexpr
mask_t
one
=
1
;
static
constexpr
mask_t
all
=
(
mask_t
)
-
1
;
void
init
(
)
{
for
(
unsigned
i
=
0
;
i
<
n
;
i
+
+
)
masks
[
i
]
=
0
;
}
void
clear
(
)
{
init
(
)
;
}
static
hb_set_digest_t
full
(
)
{
hb_set_digest_t
d
;
for
(
unsigned
i
=
0
;
i
<
n
;
i
+
+
)
d
.
masks
[
i
]
=
all
;
return
d
;
}
void
union_
(
const
hb_set_digest_t
&
o
)
{
for
(
unsigned
i
=
0
;
i
<
n
;
i
+
+
)
masks
[
i
]
|
=
o
.
masks
[
i
]
;
}
bool
add_range
(
hb_codepoint_t
a
hb_codepoint_t
b
)
{
bool
ret
;
ret
=
false
;
for
(
unsigned
i
=
0
;
i
<
n
;
i
+
+
)
if
(
masks
[
i
]
!
=
all
)
ret
=
true
;
if
(
!
ret
)
return
false
;
ret
=
false
;
for
(
unsigned
i
=
0
;
i
<
n
;
i
+
+
)
{
mask_t
shift
=
hb_set_digest_shifts
[
i
]
;
if
(
(
b
>
>
shift
)
-
(
a
>
>
shift
)
>
=
mb1
)
masks
[
i
]
=
all
;
else
{
mask_t
ma
=
one
<
<
(
(
a
>
>
shift
)
&
mb1
)
;
mask_t
mb
=
one
<
<
(
(
b
>
>
shift
)
&
mb1
)
;
masks
[
i
]
|
=
mb
+
(
mb
-
ma
)
-
(
mb
<
ma
)
;
ret
=
true
;
}
}
return
ret
;
}
template
<
typename
T
>
void
add_array
(
const
T
*
array
unsigned
int
count
unsigned
int
stride
=
sizeof
(
T
)
)
{
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
add
(
*
array
)
;
array
=
&
StructAtOffsetUnaligned
<
T
>
(
(
const
void
*
)
array
stride
)
;
}
}
template
<
typename
T
>
void
add_array
(
const
hb_array_t
<
const
T
>
&
arr
)
{
add_array
(
&
arr
arr
.
len
(
)
)
;
}
template
<
typename
T
>
bool
add_sorted_array
(
const
T
*
array
unsigned
int
count
unsigned
int
stride
=
sizeof
(
T
)
)
{
add_array
(
array
count
stride
)
;
return
true
;
}
template
<
typename
T
>
bool
add_sorted_array
(
const
hb_sorted_array_t
<
const
T
>
&
arr
)
{
return
add_sorted_array
(
&
arr
arr
.
len
(
)
)
;
}
bool
operator
[
]
(
hb_codepoint_t
g
)
const
{
return
may_have
(
g
)
;
}
void
add
(
hb_codepoint_t
g
)
{
for
(
unsigned
i
=
0
;
i
<
n
;
i
+
+
)
masks
[
i
]
|
=
one
<
<
(
(
g
>
>
hb_set_digest_shifts
[
i
]
)
&
mb1
)
;
}
HB_ALWAYS_INLINE
bool
may_have
(
hb_codepoint_t
g
)
const
{
for
(
unsigned
i
=
0
;
i
<
n
;
i
+
+
)
if
(
!
(
masks
[
i
]
&
(
one
<
<
(
(
g
>
>
hb_set_digest_shifts
[
i
]
)
&
mb1
)
)
)
)
return
false
;
return
true
;
}
bool
may_intersect
(
const
hb_set_digest_t
&
o
)
const
{
for
(
unsigned
i
=
0
;
i
<
n
;
i
+
+
)
if
(
!
(
masks
[
i
]
&
o
.
masks
[
i
]
)
)
return
false
;
return
true
;
}
private
:
mask_t
masks
[
n
]
=
{
}
;
}
;
#
endif
