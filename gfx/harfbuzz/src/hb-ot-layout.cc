#
include
"
hb
-
open
-
type
.
hh
"
#
include
"
hb
-
ot
-
layout
.
hh
"
#
include
"
hb
-
ot
-
face
.
hh
"
#
include
"
hb
-
ot
-
map
.
hh
"
#
include
"
hb
-
map
.
hh
"
#
include
"
hb
-
ot
-
kern
-
table
.
hh
"
#
include
"
hb
-
ot
-
gasp
-
table
.
hh
"
#
include
"
hb
-
ot
-
layout
-
gdef
-
table
.
hh
"
#
include
"
hb
-
ot
-
layout
-
gsub
-
table
.
hh
"
#
include
"
hb
-
ot
-
layout
-
gpos
-
table
.
hh
"
#
include
"
hb
-
ot
-
layout
-
base
-
table
.
hh
"
#
include
"
hb
-
ot
-
layout
-
jstf
-
table
.
hh
"
#
include
"
hb
-
ot
-
name
-
table
.
hh
"
#
include
"
hb
-
ot
-
os2
-
table
.
hh
"
#
include
"
hb
-
aat
-
layout
-
lcar
-
table
.
hh
"
#
include
"
hb
-
aat
-
layout
-
morx
-
table
.
hh
"
bool
hb_ot_layout_has_kerning
(
hb_face_t
*
face
)
{
return
face
-
>
table
.
kern
-
>
has_data
(
)
;
}
bool
hb_ot_layout_has_machine_kerning
(
hb_face_t
*
face
)
{
return
face
-
>
table
.
kern
-
>
has_state_machine
(
)
;
}
bool
hb_ot_layout_has_cross_kerning
(
hb_face_t
*
face
)
{
return
face
-
>
table
.
kern
-
>
has_cross_stream
(
)
;
}
void
hb_ot_layout_kern
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
hb_buffer_t
*
buffer
)
{
hb_blob_t
*
blob
=
font
-
>
face
-
>
table
.
kern
.
get_blob
(
)
;
const
AAT
:
:
kern
&
kern
=
*
blob
-
>
as
<
AAT
:
:
kern
>
(
)
;
AAT
:
:
hb_aat_apply_context_t
c
(
plan
font
buffer
blob
)
;
kern
.
apply
(
&
c
)
;
}
bool
OT
:
:
GDEF
:
:
is_blacklisted
(
hb_blob_t
*
blob
hb_face_t
*
face
)
const
{
#
define
ENCODE
(
x
y
z
)
(
(
(
uint64_t
)
(
x
)
<
<
48
)
|
(
(
uint64_t
)
(
y
)
<
<
24
)
|
(
uint64_t
)
(
z
)
)
switch
ENCODE
(
blob
-
>
length
face
-
>
table
.
GSUB
-
>
table
.
get_length
(
)
face
-
>
table
.
GPOS
-
>
table
.
get_length
(
)
)
{
case
ENCODE
(
442
2874
42038
)
:
case
ENCODE
(
430
2874
40662
)
:
case
ENCODE
(
442
2874
39116
)
:
case
ENCODE
(
430
2874
39374
)
:
case
ENCODE
(
490
3046
41638
)
:
case
ENCODE
(
478
3046
41902
)
:
case
ENCODE
(
898
12554
46470
)
:
case
ENCODE
(
910
12566
47732
)
:
case
ENCODE
(
928
23298
59332
)
:
case
ENCODE
(
940
23310
60732
)
:
case
ENCODE
(
964
23836
60072
)
:
case
ENCODE
(
976
23832
61456
)
:
case
ENCODE
(
994
24474
60336
)
:
case
ENCODE
(
1006
24470
61740
)
:
case
ENCODE
(
1006
24576
61346
)
:
case
ENCODE
(
1018
24572
62828
)
:
case
ENCODE
(
1006
24576
61352
)
:
case
ENCODE
(
1018
24572
62834
)
:
case
ENCODE
(
832
7324
47162
)
:
case
ENCODE
(
844
7302
45474
)
:
case
ENCODE
(
180
13054
7254
)
:
case
ENCODE
(
192
12638
7254
)
:
case
ENCODE
(
192
12690
7254
)
:
case
ENCODE
(
188
248
3852
)
:
case
ENCODE
(
188
264
3426
)
:
case
ENCODE
(
1058
47032
11818
)
:
case
ENCODE
(
1046
47030
12600
)
:
case
ENCODE
(
1058
71796
16770
)
:
case
ENCODE
(
1046
71790
17862
)
:
case
ENCODE
(
1046
71788
17112
)
:
case
ENCODE
(
1058
71794
17514
)
:
case
ENCODE
(
1330
109904
57938
)
:
case
ENCODE
(
1330
109904
58972
)
:
case
ENCODE
(
1004
59092
14836
)
:
return
true
;
#
undef
ENCODE
}
return
false
;
}
static
void
_hb_ot_layout_set_glyph_props
(
hb_font_t
*
font
hb_buffer_t
*
buffer
)
{
_hb_buffer_assert_gsubgpos_vars
(
buffer
)
;
const
OT
:
:
GDEF
&
gdef
=
*
font
-
>
face
-
>
table
.
GDEF
-
>
table
;
unsigned
int
count
=
buffer
-
>
len
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
_hb_glyph_info_set_glyph_props
(
&
buffer
-
>
info
[
i
]
gdef
.
get_glyph_props
(
buffer
-
>
info
[
i
]
.
codepoint
)
)
;
_hb_glyph_info_clear_lig_props
(
&
buffer
-
>
info
[
i
]
)
;
buffer
-
>
info
[
i
]
.
syllable
(
)
=
0
;
}
}
hb_bool_t
hb_ot_layout_has_glyph_classes
(
hb_face_t
*
face
)
{
return
face
-
>
table
.
GDEF
-
>
table
-
>
has_glyph_classes
(
)
;
}
hb_ot_layout_glyph_class_t
hb_ot_layout_get_glyph_class
(
hb_face_t
*
face
hb_codepoint_t
glyph
)
{
return
(
hb_ot_layout_glyph_class_t
)
face
-
>
table
.
GDEF
-
>
table
-
>
get_glyph_class
(
glyph
)
;
}
void
hb_ot_layout_get_glyphs_in_class
(
hb_face_t
*
face
hb_ot_layout_glyph_class_t
klass
hb_set_t
*
glyphs
)
{
return
face
-
>
table
.
GDEF
-
>
table
-
>
get_glyphs_in_class
(
klass
glyphs
)
;
}
unsigned
int
hb_ot_layout_get_attach_points
(
hb_face_t
*
face
hb_codepoint_t
glyph
unsigned
int
start_offset
unsigned
int
*
point_count
unsigned
int
*
point_array
)
{
return
face
-
>
table
.
GDEF
-
>
table
-
>
get_attach_points
(
glyph
start_offset
point_count
point_array
)
;
}
unsigned
int
hb_ot_layout_get_ligature_carets
(
hb_font_t
*
font
hb_direction_t
direction
hb_codepoint_t
glyph
unsigned
int
start_offset
unsigned
int
*
caret_count
hb_position_t
*
caret_array
)
{
unsigned
int
result_caret_count
=
0
;
unsigned
int
result
=
font
-
>
face
-
>
table
.
GDEF
-
>
table
-
>
get_lig_carets
(
font
direction
glyph
start_offset
&
result_caret_count
caret_array
)
;
if
(
result
)
{
if
(
caret_count
)
*
caret_count
=
result_caret_count
;
}
else
result
=
font
-
>
face
-
>
table
.
lcar
-
>
get_lig_carets
(
font
direction
glyph
start_offset
caret_count
caret_array
)
;
return
result
;
}
bool
OT
:
:
GSUB
:
:
is_blacklisted
(
hb_blob_t
*
blob
HB_UNUSED
hb_face_t
*
face
)
const
{
if
(
unlikely
(
face
-
>
table
.
OS2
-
>
achVendID
=
=
HB_TAG
(
'
M
'
'
U
'
'
T
'
'
F
'
)
&
&
face
-
>
table
.
morx
-
>
has_data
(
)
)
)
return
true
;
return
false
;
}
bool
OT
:
:
GPOS
:
:
is_blacklisted
(
hb_blob_t
*
blob
HB_UNUSED
hb_face_t
*
face
HB_UNUSED
)
const
{
return
false
;
}
static
const
OT
:
:
GSUBGPOS
&
get_gsubgpos_table
(
hb_face_t
*
face
hb_tag_t
table_tag
)
{
switch
(
table_tag
)
{
case
HB_OT_TAG_GSUB
:
return
*
face
-
>
table
.
GSUB
-
>
table
;
case
HB_OT_TAG_GPOS
:
return
*
face
-
>
table
.
GPOS
-
>
table
;
default
:
return
Null
(
OT
:
:
GSUBGPOS
)
;
}
}
unsigned
int
hb_ot_layout_table_get_script_tags
(
hb_face_t
*
face
hb_tag_t
table_tag
unsigned
int
start_offset
unsigned
int
*
script_count
hb_tag_t
*
script_tags
)
{
const
OT
:
:
GSUBGPOS
&
g
=
get_gsubgpos_table
(
face
table_tag
)
;
return
g
.
get_script_tags
(
start_offset
script_count
script_tags
)
;
}
#
define
HB_OT_TAG_LATIN_SCRIPT
HB_TAG
(
'
l
'
'
a
'
'
t
'
'
n
'
)
hb_bool_t
hb_ot_layout_table_find_script
(
hb_face_t
*
face
hb_tag_t
table_tag
hb_tag_t
script_tag
unsigned
int
*
script_index
)
{
static_assert
(
(
OT
:
:
Index
:
:
NOT_FOUND_INDEX
=
=
HB_OT_LAYOUT_NO_SCRIPT_INDEX
)
"
"
)
;
const
OT
:
:
GSUBGPOS
&
g
=
get_gsubgpos_table
(
face
table_tag
)
;
if
(
g
.
find_script_index
(
script_tag
script_index
)
)
return
true
;
if
(
g
.
find_script_index
(
HB_OT_TAG_DEFAULT_SCRIPT
script_index
)
)
return
false
;
if
(
g
.
find_script_index
(
HB_OT_TAG_DEFAULT_LANGUAGE
script_index
)
)
return
false
;
if
(
g
.
find_script_index
(
HB_OT_TAG_LATIN_SCRIPT
script_index
)
)
return
false
;
if
(
script_index
)
*
script_index
=
HB_OT_LAYOUT_NO_SCRIPT_INDEX
;
return
false
;
}
hb_bool_t
hb_ot_layout_table_choose_script
(
hb_face_t
*
face
hb_tag_t
table_tag
const
hb_tag_t
*
script_tags
unsigned
int
*
script_index
hb_tag_t
*
chosen_script
)
{
const
hb_tag_t
*
t
;
for
(
t
=
script_tags
;
*
t
;
t
+
+
)
;
return
hb_ot_layout_table_select_script
(
face
table_tag
t
-
script_tags
script_tags
script_index
chosen_script
)
;
}
hb_bool_t
hb_ot_layout_table_select_script
(
hb_face_t
*
face
hb_tag_t
table_tag
unsigned
int
script_count
const
hb_tag_t
*
script_tags
unsigned
int
*
script_index
hb_tag_t
*
chosen_script
)
{
static_assert
(
(
OT
:
:
Index
:
:
NOT_FOUND_INDEX
=
=
HB_OT_LAYOUT_NO_SCRIPT_INDEX
)
"
"
)
;
const
OT
:
:
GSUBGPOS
&
g
=
get_gsubgpos_table
(
face
table_tag
)
;
unsigned
int
i
;
for
(
i
=
0
;
i
<
script_count
;
i
+
+
)
{
if
(
g
.
find_script_index
(
script_tags
[
i
]
script_index
)
)
{
if
(
chosen_script
)
*
chosen_script
=
script_tags
[
i
]
;
return
true
;
}
}
if
(
g
.
find_script_index
(
HB_OT_TAG_DEFAULT_SCRIPT
script_index
)
)
{
if
(
chosen_script
)
*
chosen_script
=
HB_OT_TAG_DEFAULT_SCRIPT
;
return
false
;
}
if
(
g
.
find_script_index
(
HB_OT_TAG_DEFAULT_LANGUAGE
script_index
)
)
{
if
(
chosen_script
)
*
chosen_script
=
HB_OT_TAG_DEFAULT_LANGUAGE
;
return
false
;
}
if
(
g
.
find_script_index
(
HB_OT_TAG_LATIN_SCRIPT
script_index
)
)
{
if
(
chosen_script
)
*
chosen_script
=
HB_OT_TAG_LATIN_SCRIPT
;
return
false
;
}
if
(
script_index
)
*
script_index
=
HB_OT_LAYOUT_NO_SCRIPT_INDEX
;
if
(
chosen_script
)
*
chosen_script
=
HB_OT_LAYOUT_NO_SCRIPT_INDEX
;
return
false
;
}
unsigned
int
hb_ot_layout_table_get_feature_tags
(
hb_face_t
*
face
hb_tag_t
table_tag
unsigned
int
start_offset
unsigned
int
*
feature_count
hb_tag_t
*
feature_tags
)
{
const
OT
:
:
GSUBGPOS
&
g
=
get_gsubgpos_table
(
face
table_tag
)
;
return
g
.
get_feature_tags
(
start_offset
feature_count
feature_tags
)
;
}
bool
hb_ot_layout_table_find_feature
(
hb_face_t
*
face
hb_tag_t
table_tag
hb_tag_t
feature_tag
unsigned
int
*
feature_index
)
{
static_assert
(
(
OT
:
:
Index
:
:
NOT_FOUND_INDEX
=
=
HB_OT_LAYOUT_NO_FEATURE_INDEX
)
"
"
)
;
const
OT
:
:
GSUBGPOS
&
g
=
get_gsubgpos_table
(
face
table_tag
)
;
unsigned
int
num_features
=
g
.
get_feature_count
(
)
;
for
(
unsigned
int
i
=
0
;
i
<
num_features
;
i
+
+
)
{
if
(
feature_tag
=
=
g
.
get_feature_tag
(
i
)
)
{
if
(
feature_index
)
*
feature_index
=
i
;
return
true
;
}
}
if
(
feature_index
)
*
feature_index
=
HB_OT_LAYOUT_NO_FEATURE_INDEX
;
return
false
;
}
unsigned
int
hb_ot_layout_script_get_language_tags
(
hb_face_t
*
face
hb_tag_t
table_tag
unsigned
int
script_index
unsigned
int
start_offset
unsigned
int
*
language_count
hb_tag_t
*
language_tags
)
{
const
OT
:
:
Script
&
s
=
get_gsubgpos_table
(
face
table_tag
)
.
get_script
(
script_index
)
;
return
s
.
get_lang_sys_tags
(
start_offset
language_count
language_tags
)
;
}
hb_bool_t
hb_ot_layout_script_find_language
(
hb_face_t
*
face
hb_tag_t
table_tag
unsigned
int
script_index
hb_tag_t
language_tag
unsigned
int
*
language_index
)
{
return
hb_ot_layout_script_select_language
(
face
table_tag
script_index
1
&
language_tag
language_index
)
;
}
hb_bool_t
hb_ot_layout_script_select_language
(
hb_face_t
*
face
hb_tag_t
table_tag
unsigned
int
script_index
unsigned
int
language_count
const
hb_tag_t
*
language_tags
unsigned
int
*
language_index
)
{
static_assert
(
(
OT
:
:
Index
:
:
NOT_FOUND_INDEX
=
=
HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX
)
"
"
)
;
const
OT
:
:
Script
&
s
=
get_gsubgpos_table
(
face
table_tag
)
.
get_script
(
script_index
)
;
unsigned
int
i
;
for
(
i
=
0
;
i
<
language_count
;
i
+
+
)
{
if
(
s
.
find_lang_sys_index
(
language_tags
[
i
]
language_index
)
)
return
true
;
}
if
(
s
.
find_lang_sys_index
(
HB_OT_TAG_DEFAULT_LANGUAGE
language_index
)
)
return
false
;
if
(
language_index
)
*
language_index
=
HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX
;
return
false
;
}
hb_bool_t
hb_ot_layout_language_get_required_feature_index
(
hb_face_t
*
face
hb_tag_t
table_tag
unsigned
int
script_index
unsigned
int
language_index
unsigned
int
*
feature_index
)
{
return
hb_ot_layout_language_get_required_feature
(
face
table_tag
script_index
language_index
feature_index
nullptr
)
;
}
hb_bool_t
hb_ot_layout_language_get_required_feature
(
hb_face_t
*
face
hb_tag_t
table_tag
unsigned
int
script_index
unsigned
int
language_index
unsigned
int
*
feature_index
hb_tag_t
*
feature_tag
)
{
const
OT
:
:
GSUBGPOS
&
g
=
get_gsubgpos_table
(
face
table_tag
)
;
const
OT
:
:
LangSys
&
l
=
g
.
get_script
(
script_index
)
.
get_lang_sys
(
language_index
)
;
unsigned
int
index
=
l
.
get_required_feature_index
(
)
;
if
(
feature_index
)
*
feature_index
=
index
;
if
(
feature_tag
)
*
feature_tag
=
g
.
get_feature_tag
(
index
)
;
return
l
.
has_required_feature
(
)
;
}
unsigned
int
hb_ot_layout_language_get_feature_indexes
(
hb_face_t
*
face
hb_tag_t
table_tag
unsigned
int
script_index
unsigned
int
language_index
unsigned
int
start_offset
unsigned
int
*
feature_count
unsigned
int
*
feature_indexes
)
{
const
OT
:
:
GSUBGPOS
&
g
=
get_gsubgpos_table
(
face
table_tag
)
;
const
OT
:
:
LangSys
&
l
=
g
.
get_script
(
script_index
)
.
get_lang_sys
(
language_index
)
;
return
l
.
get_feature_indexes
(
start_offset
feature_count
feature_indexes
)
;
}
unsigned
int
hb_ot_layout_language_get_feature_tags
(
hb_face_t
*
face
hb_tag_t
table_tag
unsigned
int
script_index
unsigned
int
language_index
unsigned
int
start_offset
unsigned
int
*
feature_count
hb_tag_t
*
feature_tags
)
{
const
OT
:
:
GSUBGPOS
&
g
=
get_gsubgpos_table
(
face
table_tag
)
;
const
OT
:
:
LangSys
&
l
=
g
.
get_script
(
script_index
)
.
get_lang_sys
(
language_index
)
;
static_assert
(
(
sizeof
(
unsigned
int
)
=
=
sizeof
(
hb_tag_t
)
)
"
"
)
;
unsigned
int
ret
=
l
.
get_feature_indexes
(
start_offset
feature_count
(
unsigned
int
*
)
feature_tags
)
;
if
(
feature_tags
)
{
unsigned
int
count
=
*
feature_count
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
feature_tags
[
i
]
=
g
.
get_feature_tag
(
(
unsigned
int
)
feature_tags
[
i
]
)
;
}
return
ret
;
}
hb_bool_t
hb_ot_layout_language_find_feature
(
hb_face_t
*
face
hb_tag_t
table_tag
unsigned
int
script_index
unsigned
int
language_index
hb_tag_t
feature_tag
unsigned
int
*
feature_index
)
{
static_assert
(
(
OT
:
:
Index
:
:
NOT_FOUND_INDEX
=
=
HB_OT_LAYOUT_NO_FEATURE_INDEX
)
"
"
)
;
const
OT
:
:
GSUBGPOS
&
g
=
get_gsubgpos_table
(
face
table_tag
)
;
const
OT
:
:
LangSys
&
l
=
g
.
get_script
(
script_index
)
.
get_lang_sys
(
language_index
)
;
unsigned
int
num_features
=
l
.
get_feature_count
(
)
;
for
(
unsigned
int
i
=
0
;
i
<
num_features
;
i
+
+
)
{
unsigned
int
f_index
=
l
.
get_feature_index
(
i
)
;
if
(
feature_tag
=
=
g
.
get_feature_tag
(
f_index
)
)
{
if
(
feature_index
)
*
feature_index
=
f_index
;
return
true
;
}
}
if
(
feature_index
)
*
feature_index
=
HB_OT_LAYOUT_NO_FEATURE_INDEX
;
return
false
;
}
unsigned
int
hb_ot_layout_feature_get_lookups
(
hb_face_t
*
face
hb_tag_t
table_tag
unsigned
int
feature_index
unsigned
int
start_offset
unsigned
int
*
lookup_count
unsigned
int
*
lookup_indexes
)
{
return
hb_ot_layout_feature_with_variations_get_lookups
(
face
table_tag
feature_index
HB_OT_LAYOUT_NO_VARIATIONS_INDEX
start_offset
lookup_count
lookup_indexes
)
;
}
unsigned
int
hb_ot_layout_table_get_lookup_count
(
hb_face_t
*
face
hb_tag_t
table_tag
)
{
return
get_gsubgpos_table
(
face
table_tag
)
.
get_lookup_count
(
)
;
}
struct
hb_collect_features_context_t
{
hb_collect_features_context_t
(
hb_face_t
*
face
hb_tag_t
table_tag
hb_set_t
*
feature_indexes_
)
:
g
(
get_gsubgpos_table
(
face
table_tag
)
)
feature_indexes
(
feature_indexes_
)
script_count
(
0
)
langsys_count
(
0
)
{
}
bool
visited
(
const
OT
:
:
Script
&
s
)
{
if
(
unlikely
(
!
s
.
has_default_lang_sys
(
)
&
&
!
s
.
get_lang_sys_count
(
)
)
)
return
true
;
if
(
script_count
+
+
>
HB_MAX_SCRIPTS
)
return
true
;
return
visited
(
s
visited_script
)
;
}
bool
visited
(
const
OT
:
:
LangSys
&
l
)
{
if
(
unlikely
(
!
l
.
has_required_feature
(
)
&
&
!
l
.
get_feature_count
(
)
)
)
return
true
;
if
(
langsys_count
+
+
>
HB_MAX_LANGSYS
)
return
true
;
return
visited
(
l
visited_langsys
)
;
}
private
:
template
<
typename
T
>
bool
visited
(
const
T
&
p
hb_set_t
&
visited_set
)
{
hb_codepoint_t
delta
=
(
hb_codepoint_t
)
(
(
uintptr_t
)
&
p
-
(
uintptr_t
)
&
g
)
;
if
(
visited_set
.
has
(
delta
)
)
return
true
;
visited_set
.
add
(
delta
)
;
return
false
;
}
public
:
const
OT
:
:
GSUBGPOS
&
g
;
hb_set_t
*
feature_indexes
;
private
:
hb_set_t
visited_script
;
hb_set_t
visited_langsys
;
unsigned
int
script_count
;
unsigned
int
langsys_count
;
}
;
static
void
langsys_collect_features
(
hb_collect_features_context_t
*
c
const
OT
:
:
LangSys
&
l
const
hb_tag_t
*
features
)
{
if
(
c
-
>
visited
(
l
)
)
return
;
if
(
!
features
)
{
if
(
l
.
has_required_feature
(
)
)
c
-
>
feature_indexes
-
>
add
(
l
.
get_required_feature_index
(
)
)
;
l
.
add_feature_indexes_to
(
c
-
>
feature_indexes
)
;
}
else
{
for
(
;
*
features
;
features
+
+
)
{
hb_tag_t
feature_tag
=
*
features
;
unsigned
int
num_features
=
l
.
get_feature_count
(
)
;
for
(
unsigned
int
i
=
0
;
i
<
num_features
;
i
+
+
)
{
unsigned
int
feature_index
=
l
.
get_feature_index
(
i
)
;
if
(
feature_tag
=
=
c
-
>
g
.
get_feature_tag
(
feature_index
)
)
{
c
-
>
feature_indexes
-
>
add
(
feature_index
)
;
break
;
}
}
}
}
}
static
void
script_collect_features
(
hb_collect_features_context_t
*
c
const
OT
:
:
Script
&
s
const
hb_tag_t
*
languages
const
hb_tag_t
*
features
)
{
if
(
c
-
>
visited
(
s
)
)
return
;
if
(
!
languages
)
{
if
(
s
.
has_default_lang_sys
(
)
)
langsys_collect_features
(
c
s
.
get_default_lang_sys
(
)
features
)
;
unsigned
int
count
=
s
.
get_lang_sys_count
(
)
;
for
(
unsigned
int
language_index
=
0
;
language_index
<
count
;
language_index
+
+
)
langsys_collect_features
(
c
s
.
get_lang_sys
(
language_index
)
features
)
;
}
else
{
for
(
;
*
languages
;
languages
+
+
)
{
unsigned
int
language_index
;
if
(
s
.
find_lang_sys_index
(
*
languages
&
language_index
)
)
langsys_collect_features
(
c
s
.
get_lang_sys
(
language_index
)
features
)
;
}
}
}
void
hb_ot_layout_collect_features
(
hb_face_t
*
face
hb_tag_t
table_tag
const
hb_tag_t
*
scripts
const
hb_tag_t
*
languages
const
hb_tag_t
*
features
hb_set_t
*
feature_indexes
)
{
hb_collect_features_context_t
c
(
face
table_tag
feature_indexes
)
;
if
(
!
scripts
)
{
unsigned
int
count
=
c
.
g
.
get_script_count
(
)
;
for
(
unsigned
int
script_index
=
0
;
script_index
<
count
;
script_index
+
+
)
script_collect_features
(
&
c
c
.
g
.
get_script
(
script_index
)
languages
features
)
;
}
else
{
for
(
;
*
scripts
;
scripts
+
+
)
{
unsigned
int
script_index
;
if
(
c
.
g
.
find_script_index
(
*
scripts
&
script_index
)
)
script_collect_features
(
&
c
c
.
g
.
get_script
(
script_index
)
languages
features
)
;
}
}
}
void
hb_ot_layout_collect_lookups
(
hb_face_t
*
face
hb_tag_t
table_tag
const
hb_tag_t
*
scripts
const
hb_tag_t
*
languages
const
hb_tag_t
*
features
hb_set_t
*
lookup_indexes
)
{
const
OT
:
:
GSUBGPOS
&
g
=
get_gsubgpos_table
(
face
table_tag
)
;
hb_set_t
feature_indexes
;
hb_ot_layout_collect_features
(
face
table_tag
scripts
languages
features
&
feature_indexes
)
;
for
(
hb_codepoint_t
feature_index
=
HB_SET_VALUE_INVALID
;
hb_set_next
(
&
feature_indexes
&
feature_index
)
;
)
g
.
get_feature
(
feature_index
)
.
add_lookup_indexes_to
(
lookup_indexes
)
;
}
void
hb_ot_layout_lookup_collect_glyphs
(
hb_face_t
*
face
hb_tag_t
table_tag
unsigned
int
lookup_index
hb_set_t
*
glyphs_before
hb_set_t
*
glyphs_input
hb_set_t
*
glyphs_after
hb_set_t
*
glyphs_output
)
{
OT
:
:
hb_collect_glyphs_context_t
c
(
face
glyphs_before
glyphs_input
glyphs_after
glyphs_output
)
;
switch
(
table_tag
)
{
case
HB_OT_TAG_GSUB
:
{
const
OT
:
:
SubstLookup
&
l
=
face
-
>
table
.
GSUB
-
>
table
-
>
get_lookup
(
lookup_index
)
;
l
.
collect_glyphs
(
&
c
)
;
return
;
}
case
HB_OT_TAG_GPOS
:
{
const
OT
:
:
PosLookup
&
l
=
face
-
>
table
.
GPOS
-
>
table
-
>
get_lookup
(
lookup_index
)
;
l
.
collect_glyphs
(
&
c
)
;
return
;
}
}
}
hb_bool_t
hb_ot_layout_table_find_feature_variations
(
hb_face_t
*
face
hb_tag_t
table_tag
const
int
*
coords
unsigned
int
num_coords
unsigned
int
*
variations_index
)
{
const
OT
:
:
GSUBGPOS
&
g
=
get_gsubgpos_table
(
face
table_tag
)
;
return
g
.
find_variations_index
(
coords
num_coords
variations_index
)
;
}
unsigned
int
hb_ot_layout_feature_with_variations_get_lookups
(
hb_face_t
*
face
hb_tag_t
table_tag
unsigned
int
feature_index
unsigned
int
variations_index
unsigned
int
start_offset
unsigned
int
*
lookup_count
unsigned
int
*
lookup_indexes
)
{
static_assert
(
(
OT
:
:
FeatureVariations
:
:
NOT_FOUND_INDEX
=
=
HB_OT_LAYOUT_NO_VARIATIONS_INDEX
)
"
"
)
;
const
OT
:
:
GSUBGPOS
&
g
=
get_gsubgpos_table
(
face
table_tag
)
;
const
OT
:
:
Feature
&
f
=
g
.
get_feature_variation
(
feature_index
variations_index
)
;
return
f
.
get_lookup_indexes
(
start_offset
lookup_count
lookup_indexes
)
;
}
hb_bool_t
hb_ot_layout_has_substitution
(
hb_face_t
*
face
)
{
return
face
-
>
table
.
GSUB
-
>
table
-
>
has_data
(
)
;
}
hb_bool_t
hb_ot_layout_lookup_would_substitute
(
hb_face_t
*
face
unsigned
int
lookup_index
const
hb_codepoint_t
*
glyphs
unsigned
int
glyphs_length
hb_bool_t
zero_context
)
{
return
hb_ot_layout_lookup_would_substitute_fast
(
face
lookup_index
glyphs
glyphs_length
zero_context
)
;
}
bool
hb_ot_layout_lookup_would_substitute_fast
(
hb_face_t
*
face
unsigned
int
lookup_index
const
hb_codepoint_t
*
glyphs
unsigned
int
glyphs_length
bool
zero_context
)
{
if
(
unlikely
(
lookup_index
>
=
face
-
>
table
.
GSUB
-
>
lookup_count
)
)
return
false
;
OT
:
:
hb_would_apply_context_t
c
(
face
glyphs
glyphs_length
(
bool
)
zero_context
)
;
const
OT
:
:
SubstLookup
&
l
=
face
-
>
table
.
GSUB
-
>
table
-
>
get_lookup
(
lookup_index
)
;
return
l
.
would_apply
(
&
c
&
face
-
>
table
.
GSUB
-
>
accels
[
lookup_index
]
)
;
}
void
hb_ot_layout_substitute_start
(
hb_font_t
*
font
hb_buffer_t
*
buffer
)
{
_hb_ot_layout_set_glyph_props
(
font
buffer
)
;
}
void
hb_ot_layout_delete_glyphs_inplace
(
hb_buffer_t
*
buffer
bool
(
*
filter
)
(
const
hb_glyph_info_t
*
info
)
)
{
unsigned
int
j
=
0
;
unsigned
int
count
=
buffer
-
>
len
;
hb_glyph_info_t
*
info
=
buffer
-
>
info
;
hb_glyph_position_t
*
pos
=
buffer
-
>
pos
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
filter
(
&
info
[
i
]
)
)
{
unsigned
int
cluster
=
info
[
i
]
.
cluster
;
if
(
i
+
1
<
count
&
&
cluster
=
=
info
[
i
+
1
]
.
cluster
)
continue
;
if
(
j
)
{
if
(
cluster
<
info
[
j
-
1
]
.
cluster
)
{
unsigned
int
mask
=
info
[
i
]
.
mask
;
unsigned
int
old_cluster
=
info
[
j
-
1
]
.
cluster
;
for
(
unsigned
k
=
j
;
k
&
&
info
[
k
-
1
]
.
cluster
=
=
old_cluster
;
k
-
-
)
buffer
-
>
set_cluster
(
info
[
k
-
1
]
cluster
mask
)
;
}
continue
;
}
if
(
i
+
1
<
count
)
buffer
-
>
merge_clusters
(
i
i
+
2
)
;
continue
;
}
if
(
j
!
=
i
)
{
info
[
j
]
=
info
[
i
]
;
pos
[
j
]
=
pos
[
i
]
;
}
j
+
+
;
}
buffer
-
>
len
=
j
;
}
void
hb_ot_layout_lookup_substitute_closure
(
hb_face_t
*
face
unsigned
int
lookup_index
hb_set_t
*
glyphs
)
{
hb_map_t
done_lookups
;
OT
:
:
hb_closure_context_t
c
(
face
glyphs
&
done_lookups
)
;
const
OT
:
:
SubstLookup
&
l
=
face
-
>
table
.
GSUB
-
>
table
-
>
get_lookup
(
lookup_index
)
;
l
.
closure
(
&
c
lookup_index
)
;
}
void
hb_ot_layout_lookups_substitute_closure
(
hb_face_t
*
face
const
hb_set_t
*
lookups
hb_set_t
*
glyphs
)
{
hb_map_t
done_lookups
;
OT
:
:
hb_closure_context_t
c
(
face
glyphs
&
done_lookups
)
;
const
OT
:
:
GSUB
&
gsub
=
*
face
-
>
table
.
GSUB
-
>
table
;
unsigned
int
iteration_count
=
0
;
unsigned
int
glyphs_length
;
do
{
glyphs_length
=
glyphs
-
>
get_population
(
)
;
if
(
lookups
!
=
nullptr
)
{
for
(
hb_codepoint_t
lookup_index
=
HB_SET_VALUE_INVALID
;
hb_set_next
(
lookups
&
lookup_index
)
;
)
gsub
.
get_lookup
(
lookup_index
)
.
closure
(
&
c
lookup_index
)
;
}
else
{
for
(
unsigned
int
i
=
0
;
i
<
gsub
.
get_lookup_count
(
)
;
i
+
+
)
gsub
.
get_lookup
(
i
)
.
closure
(
&
c
i
)
;
}
}
while
(
iteration_count
+
+
<
=
HB_CLOSURE_MAX_STAGES
&
&
glyphs_length
!
=
glyphs
-
>
get_population
(
)
)
;
}
hb_bool_t
hb_ot_layout_has_positioning
(
hb_face_t
*
face
)
{
return
face
-
>
table
.
GPOS
-
>
table
-
>
has_data
(
)
;
}
void
hb_ot_layout_position_start
(
hb_font_t
*
font
hb_buffer_t
*
buffer
)
{
OT
:
:
GPOS
:
:
position_start
(
font
buffer
)
;
}
void
hb_ot_layout_position_finish_advances
(
hb_font_t
*
font
hb_buffer_t
*
buffer
)
{
OT
:
:
GPOS
:
:
position_finish_advances
(
font
buffer
)
;
}
void
hb_ot_layout_position_finish_offsets
(
hb_font_t
*
font
hb_buffer_t
*
buffer
)
{
OT
:
:
GPOS
:
:
position_finish_offsets
(
font
buffer
)
;
}
hb_bool_t
hb_ot_layout_get_size_params
(
hb_face_t
*
face
unsigned
int
*
design_size
unsigned
int
*
subfamily_id
hb_ot_name_id_t
*
subfamily_name_id
unsigned
int
*
range_start
unsigned
int
*
range_end
)
{
const
OT
:
:
GPOS
&
gpos
=
*
face
-
>
table
.
GPOS
-
>
table
;
const
hb_tag_t
tag
=
HB_TAG
(
'
s
'
'
i
'
'
z
'
'
e
'
)
;
unsigned
int
num_features
=
gpos
.
get_feature_count
(
)
;
for
(
unsigned
int
i
=
0
;
i
<
num_features
;
i
+
+
)
{
if
(
tag
=
=
gpos
.
get_feature_tag
(
i
)
)
{
const
OT
:
:
Feature
&
f
=
gpos
.
get_feature
(
i
)
;
const
OT
:
:
FeatureParamsSize
&
params
=
f
.
get_feature_params
(
)
.
get_size_params
(
tag
)
;
if
(
params
.
designSize
)
{
if
(
design_size
)
*
design_size
=
params
.
designSize
;
if
(
subfamily_id
)
*
subfamily_id
=
params
.
subfamilyID
;
if
(
subfamily_name_id
)
*
subfamily_name_id
=
params
.
subfamilyNameID
;
if
(
range_start
)
*
range_start
=
params
.
rangeStart
;
if
(
range_end
)
*
range_end
=
params
.
rangeEnd
;
return
true
;
}
}
}
if
(
design_size
)
*
design_size
=
0
;
if
(
subfamily_id
)
*
subfamily_id
=
0
;
if
(
subfamily_name_id
)
*
subfamily_name_id
=
HB_OT_NAME_ID_INVALID
;
if
(
range_start
)
*
range_start
=
0
;
if
(
range_end
)
*
range_end
=
0
;
return
false
;
}
hb_bool_t
hb_ot_layout_feature_get_name_ids
(
hb_face_t
*
face
hb_tag_t
table_tag
unsigned
int
feature_index
hb_ot_name_id_t
*
label_id
hb_ot_name_id_t
*
tooltip_id
hb_ot_name_id_t
*
sample_id
unsigned
int
*
num_named_parameters
hb_ot_name_id_t
*
first_param_id
)
{
const
OT
:
:
GSUBGPOS
&
g
=
get_gsubgpos_table
(
face
table_tag
)
;
hb_tag_t
feature_tag
=
g
.
get_feature_tag
(
feature_index
)
;
const
OT
:
:
Feature
&
f
=
g
.
get_feature
(
feature_index
)
;
const
OT
:
:
FeatureParams
&
feature_params
=
f
.
get_feature_params
(
)
;
if
(
&
feature_params
!
=
&
Null
(
OT
:
:
FeatureParams
)
)
{
const
OT
:
:
FeatureParamsStylisticSet
&
ss_params
=
feature_params
.
get_stylistic_set_params
(
feature_tag
)
;
if
(
&
ss_params
!
=
&
Null
(
OT
:
:
FeatureParamsStylisticSet
)
)
{
if
(
label_id
)
*
label_id
=
ss_params
.
uiNameID
;
if
(
tooltip_id
)
*
tooltip_id
=
HB_OT_NAME_ID_INVALID
;
if
(
sample_id
)
*
sample_id
=
HB_OT_NAME_ID_INVALID
;
if
(
num_named_parameters
)
*
num_named_parameters
=
0
;
if
(
first_param_id
)
*
first_param_id
=
HB_OT_NAME_ID_INVALID
;
return
true
;
}
const
OT
:
:
FeatureParamsCharacterVariants
&
cv_params
=
feature_params
.
get_character_variants_params
(
feature_tag
)
;
if
(
&
cv_params
!
=
&
Null
(
OT
:
:
FeatureParamsCharacterVariants
)
)
{
if
(
label_id
)
*
label_id
=
cv_params
.
featUILableNameID
;
if
(
tooltip_id
)
*
tooltip_id
=
cv_params
.
featUITooltipTextNameID
;
if
(
sample_id
)
*
sample_id
=
cv_params
.
sampleTextNameID
;
if
(
num_named_parameters
)
*
num_named_parameters
=
cv_params
.
numNamedParameters
;
if
(
first_param_id
)
*
first_param_id
=
cv_params
.
firstParamUILabelNameID
;
return
true
;
}
}
if
(
label_id
)
*
label_id
=
HB_OT_NAME_ID_INVALID
;
if
(
tooltip_id
)
*
tooltip_id
=
HB_OT_NAME_ID_INVALID
;
if
(
sample_id
)
*
sample_id
=
HB_OT_NAME_ID_INVALID
;
if
(
num_named_parameters
)
*
num_named_parameters
=
0
;
if
(
first_param_id
)
*
first_param_id
=
HB_OT_NAME_ID_INVALID
;
return
false
;
}
unsigned
int
hb_ot_layout_feature_get_characters
(
hb_face_t
*
face
hb_tag_t
table_tag
unsigned
int
feature_index
unsigned
int
start_offset
unsigned
int
*
char_count
hb_codepoint_t
*
characters
)
{
const
OT
:
:
GSUBGPOS
&
g
=
get_gsubgpos_table
(
face
table_tag
)
;
hb_tag_t
feature_tag
=
g
.
get_feature_tag
(
feature_index
)
;
const
OT
:
:
Feature
&
f
=
g
.
get_feature
(
feature_index
)
;
const
OT
:
:
FeatureParams
&
feature_params
=
f
.
get_feature_params
(
)
;
const
OT
:
:
FeatureParamsCharacterVariants
&
cv_params
=
feature_params
.
get_character_variants_params
(
feature_tag
)
;
unsigned
int
len
=
0
;
if
(
char_count
&
&
characters
&
&
start_offset
<
cv_params
.
characters
.
len
)
{
len
=
MIN
(
cv_params
.
characters
.
len
-
start_offset
*
char_count
)
;
for
(
unsigned
int
i
=
0
;
i
<
len
;
+
+
i
)
characters
[
i
]
=
cv_params
.
characters
[
start_offset
+
i
]
;
}
if
(
char_count
)
*
char_count
=
len
;
return
cv_params
.
characters
.
len
;
}
struct
GSUBProxy
{
static
constexpr
unsigned
table_index
=
0u
;
static
constexpr
bool
inplace
=
false
;
typedef
OT
:
:
SubstLookup
Lookup
;
GSUBProxy
(
hb_face_t
*
face
)
:
table
(
*
face
-
>
table
.
GSUB
-
>
table
)
accels
(
face
-
>
table
.
GSUB
-
>
accels
)
{
}
const
OT
:
:
GSUB
&
table
;
const
OT
:
:
hb_ot_layout_lookup_accelerator_t
*
accels
;
}
;
struct
GPOSProxy
{
static
constexpr
unsigned
table_index
=
1u
;
static
constexpr
bool
inplace
=
true
;
typedef
OT
:
:
PosLookup
Lookup
;
GPOSProxy
(
hb_face_t
*
face
)
:
table
(
*
face
-
>
table
.
GPOS
-
>
table
)
accels
(
face
-
>
table
.
GPOS
-
>
accels
)
{
}
const
OT
:
:
GPOS
&
table
;
const
OT
:
:
hb_ot_layout_lookup_accelerator_t
*
accels
;
}
;
static
inline
bool
apply_forward
(
OT
:
:
hb_ot_apply_context_t
*
c
const
OT
:
:
hb_ot_layout_lookup_accelerator_t
&
accel
)
{
bool
ret
=
false
;
hb_buffer_t
*
buffer
=
c
-
>
buffer
;
while
(
buffer
-
>
idx
<
buffer
-
>
len
&
&
buffer
-
>
successful
)
{
bool
applied
=
false
;
if
(
accel
.
may_have
(
buffer
-
>
cur
(
)
.
codepoint
)
&
&
(
buffer
-
>
cur
(
)
.
mask
&
c
-
>
lookup_mask
)
&
&
c
-
>
check_glyph_property
(
&
buffer
-
>
cur
(
)
c
-
>
lookup_props
)
)
{
applied
=
accel
.
apply
(
c
)
;
}
if
(
applied
)
ret
=
true
;
else
buffer
-
>
next_glyph
(
)
;
}
return
ret
;
}
static
inline
bool
apply_backward
(
OT
:
:
hb_ot_apply_context_t
*
c
const
OT
:
:
hb_ot_layout_lookup_accelerator_t
&
accel
)
{
bool
ret
=
false
;
hb_buffer_t
*
buffer
=
c
-
>
buffer
;
do
{
if
(
accel
.
may_have
(
buffer
-
>
cur
(
)
.
codepoint
)
&
&
(
buffer
-
>
cur
(
)
.
mask
&
c
-
>
lookup_mask
)
&
&
c
-
>
check_glyph_property
(
&
buffer
-
>
cur
(
)
c
-
>
lookup_props
)
)
ret
|
=
accel
.
apply
(
c
)
;
buffer
-
>
idx
-
-
;
}
while
(
(
int
)
buffer
-
>
idx
>
=
0
)
;
return
ret
;
}
template
<
typename
Proxy
>
static
inline
void
apply_string
(
OT
:
:
hb_ot_apply_context_t
*
c
const
typename
Proxy
:
:
Lookup
&
lookup
const
OT
:
:
hb_ot_layout_lookup_accelerator_t
&
accel
)
{
hb_buffer_t
*
buffer
=
c
-
>
buffer
;
if
(
unlikely
(
!
buffer
-
>
len
|
|
!
c
-
>
lookup_mask
)
)
return
;
c
-
>
set_lookup_props
(
lookup
.
get_props
(
)
)
;
if
(
likely
(
!
lookup
.
is_reverse
(
)
)
)
{
if
(
Proxy
:
:
table_index
=
=
0u
)
buffer
-
>
clear_output
(
)
;
buffer
-
>
idx
=
0
;
bool
ret
;
ret
=
apply_forward
(
c
accel
)
;
if
(
ret
)
{
if
(
!
Proxy
:
:
inplace
)
buffer
-
>
swap_buffers
(
)
;
else
assert
(
!
buffer
-
>
has_separate_output
(
)
)
;
}
}
else
{
if
(
Proxy
:
:
table_index
=
=
0u
)
buffer
-
>
remove_output
(
)
;
buffer
-
>
idx
=
buffer
-
>
len
-
1
;
apply_backward
(
c
accel
)
;
}
}
template
<
typename
Proxy
>
inline
void
hb_ot_map_t
:
:
apply
(
const
Proxy
&
proxy
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
hb_buffer_t
*
buffer
)
const
{
const
unsigned
int
table_index
=
proxy
.
table_index
;
unsigned
int
i
=
0
;
OT
:
:
hb_ot_apply_context_t
c
(
table_index
font
buffer
)
;
c
.
set_recurse_func
(
Proxy
:
:
Lookup
:
:
apply_recurse_func
)
;
for
(
unsigned
int
stage_index
=
0
;
stage_index
<
stages
[
table_index
]
.
length
;
stage_index
+
+
)
{
const
stage_map_t
*
stage
=
&
stages
[
table_index
]
[
stage_index
]
;
for
(
;
i
<
stage
-
>
last_lookup
;
i
+
+
)
{
unsigned
int
lookup_index
=
lookups
[
table_index
]
[
i
]
.
index
;
if
(
!
buffer
-
>
message
(
font
"
start
lookup
%
d
"
lookup_index
)
)
continue
;
c
.
set_lookup_index
(
lookup_index
)
;
c
.
set_lookup_mask
(
lookups
[
table_index
]
[
i
]
.
mask
)
;
c
.
set_auto_zwj
(
lookups
[
table_index
]
[
i
]
.
auto_zwj
)
;
c
.
set_auto_zwnj
(
lookups
[
table_index
]
[
i
]
.
auto_zwnj
)
;
if
(
lookups
[
table_index
]
[
i
]
.
random
)
{
c
.
set_random
(
true
)
;
buffer
-
>
unsafe_to_break_all
(
)
;
}
apply_string
<
Proxy
>
(
&
c
proxy
.
table
.
get_lookup
(
lookup_index
)
proxy
.
accels
[
lookup_index
]
)
;
(
void
)
buffer
-
>
message
(
font
"
end
lookup
%
d
"
lookup_index
)
;
}
if
(
stage
-
>
pause_func
)
{
buffer
-
>
clear_output
(
)
;
stage
-
>
pause_func
(
plan
font
buffer
)
;
}
}
}
void
hb_ot_map_t
:
:
substitute
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
hb_buffer_t
*
buffer
)
const
{
GSUBProxy
proxy
(
font
-
>
face
)
;
apply
(
proxy
plan
font
buffer
)
;
}
void
hb_ot_map_t
:
:
position
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
hb_buffer_t
*
buffer
)
const
{
GPOSProxy
proxy
(
font
-
>
face
)
;
apply
(
proxy
plan
font
buffer
)
;
}
void
hb_ot_layout_substitute_lookup
(
OT
:
:
hb_ot_apply_context_t
*
c
const
OT
:
:
SubstLookup
&
lookup
const
OT
:
:
hb_ot_layout_lookup_accelerator_t
&
accel
)
{
apply_string
<
GSUBProxy
>
(
c
lookup
accel
)
;
}
#
if
0
static
const
OT
:
:
BASE
&
_get_base
(
hb_face_t
*
face
)
{
return
*
face
-
>
table
.
BASE
;
}
hb_bool_t
hb_ot_layout_get_baseline
(
hb_font_t
*
font
hb_ot_layout_baseline_t
baseline
hb_direction_t
direction
hb_tag_t
script_tag
hb_tag_t
language_tag
hb_position_t
*
coord
)
{
const
OT
:
:
BASE
&
base
=
_get_base
(
font
-
>
face
)
;
bool
result
=
base
.
get_baseline
(
font
baseline
direction
script_tag
language_tag
coord
)
;
if
(
!
result
&
&
coord
)
*
coord
=
0
;
if
(
coord
)
*
coord
=
font
-
>
em_scale_dir
(
*
coord
direction
)
;
return
result
;
}
typedef
enum
{
HB_OT_LAYOUT_BASELINE_HANG
=
HB_TAG
(
'
h
'
'
a
'
'
n
'
'
g
'
)
HB_OT_LAYOUT_BASELINE_ICFB
=
HB_TAG
(
'
i
'
'
c
'
'
f
'
'
b
'
)
HB_OT_LAYOUT_BASELINE_ICFT
=
HB_TAG
(
'
i
'
'
c
'
'
f
'
'
t
'
)
HB_OT_LAYOUT_BASELINE_IDEO
=
HB_TAG
(
'
i
'
'
d
'
'
e
'
'
o
'
)
HB_OT_LAYOUT_BASELINE_IDTB
=
HB_TAG
(
'
i
'
'
d
'
'
t
'
'
b
'
)
HB_OT_LAYOUT_BASELINE_MATH
=
HB_TAG
(
'
m
'
'
a
'
'
t
'
'
h
'
)
HB_OT_LAYOUT_BASELINE_ROMN
=
HB_TAG
(
'
r
'
'
o
'
'
m
'
'
n
'
)
}
hb_ot_layout_baseline_t
;
HB_EXTERN
hb_bool_t
hb_ot_layout_get_baseline
(
hb_font_t
*
font
hb_ot_layout_baseline_t
baseline
hb_direction_t
direction
hb_tag_t
script_tag
hb_tag_t
language_tag
hb_position_t
*
coord
)
;
#
endif
