#
ifndef
HB_MS_FEATURE_RANGES_HH
#
define
HB_MS_FEATURE_RANGES_HH
#
include
"
hb
.
hh
"
typedef
struct
hb_ms_feature_t
{
uint32_t
tag_le
;
uint32_t
value
;
}
hb_ms_feature_t
;
typedef
struct
hb_ms_features_t
{
hb_ms_feature_t
*
features
;
uint32_t
num_features
;
}
hb_ms_features_t
;
struct
hb_ms_active_feature_t
{
hb_ms_feature_t
fea
;
unsigned
int
order
;
HB_INTERNAL
static
int
cmp
(
const
void
*
pa
const
void
*
pb
)
{
const
auto
*
a
=
(
const
hb_ms_active_feature_t
*
)
pa
;
const
auto
*
b
=
(
const
hb_ms_active_feature_t
*
)
pb
;
return
a
-
>
fea
.
tag_le
<
b
-
>
fea
.
tag_le
?
-
1
:
a
-
>
fea
.
tag_le
>
b
-
>
fea
.
tag_le
?
1
:
a
-
>
order
<
b
-
>
order
?
-
1
:
a
-
>
order
>
b
-
>
order
?
1
:
a
-
>
fea
.
value
<
b
-
>
fea
.
value
?
-
1
:
a
-
>
fea
.
value
>
b
-
>
fea
.
value
?
1
:
0
;
}
bool
operator
=
=
(
const
hb_ms_active_feature_t
&
f
)
const
{
return
cmp
(
this
&
f
)
=
=
0
;
}
}
;
struct
hb_ms_feature_event_t
{
unsigned
int
index
;
bool
start
;
hb_ms_active_feature_t
feature
;
HB_INTERNAL
static
int
cmp
(
const
void
*
pa
const
void
*
pb
)
{
const
auto
*
a
=
(
const
hb_ms_feature_event_t
*
)
pa
;
const
auto
*
b
=
(
const
hb_ms_feature_event_t
*
)
pb
;
return
a
-
>
index
<
b
-
>
index
?
-
1
:
a
-
>
index
>
b
-
>
index
?
1
:
a
-
>
start
<
b
-
>
start
?
-
1
:
a
-
>
start
>
b
-
>
start
?
1
:
hb_ms_active_feature_t
:
:
cmp
(
&
a
-
>
feature
&
b
-
>
feature
)
;
}
}
;
struct
hb_ms_range_record_t
{
hb_ms_features_t
features
;
unsigned
int
index_first
;
unsigned
int
index_last
;
}
;
static
inline
bool
hb_ms_setup_features
(
const
hb_feature_t
*
features
unsigned
int
num_features
hb_vector_t
<
hb_ms_feature_t
>
&
feature_records
hb_vector_t
<
hb_ms_range_record_t
>
&
range_records
)
{
feature_records
.
shrink
(
0
)
;
range_records
.
shrink
(
0
)
;
hb_vector_t
<
hb_ms_feature_event_t
>
feature_events
;
for
(
unsigned
int
i
=
0
;
i
<
num_features
;
i
+
+
)
{
hb_ms_active_feature_t
feature
;
feature
.
fea
.
tag_le
=
hb_uint32_swap
(
features
[
i
]
.
tag
)
;
feature
.
fea
.
value
=
features
[
i
]
.
value
;
feature
.
order
=
i
;
hb_ms_feature_event_t
*
event
;
event
=
feature_events
.
push
(
)
;
event
-
>
index
=
features
[
i
]
.
start
;
event
-
>
start
=
true
;
event
-
>
feature
=
feature
;
event
=
feature_events
.
push
(
)
;
event
-
>
index
=
features
[
i
]
.
end
;
event
-
>
start
=
false
;
event
-
>
feature
=
feature
;
}
feature_events
.
qsort
(
)
;
{
hb_ms_active_feature_t
feature
;
feature
.
fea
.
tag_le
=
0
;
feature
.
fea
.
value
=
0
;
feature
.
order
=
num_features
+
1
;
auto
*
event
=
feature_events
.
push
(
)
;
event
-
>
index
=
0
;
event
-
>
start
=
false
;
event
-
>
feature
=
feature
;
}
hb_vector_t
<
hb_ms_active_feature_t
>
active_features
;
unsigned
int
last_index
=
0
;
for
(
unsigned
int
i
=
0
;
i
<
feature_events
.
length
;
i
+
+
)
{
auto
*
event
=
&
feature_events
[
i
]
;
if
(
event
-
>
index
!
=
last_index
)
{
auto
*
range
=
range_records
.
push
(
)
;
auto
offset
=
feature_records
.
length
;
active_features
.
qsort
(
)
;
for
(
unsigned
int
j
=
0
;
j
<
active_features
.
length
;
j
+
+
)
{
if
(
!
j
|
|
active_features
[
j
]
.
fea
.
tag_le
!
=
feature_records
[
feature_records
.
length
-
1
]
.
tag_le
)
{
feature_records
.
push
(
active_features
[
j
]
.
fea
)
;
}
else
{
feature_records
[
feature_records
.
length
-
1
]
.
value
=
active_features
[
j
]
.
fea
.
value
;
}
}
range
-
>
features
.
features
=
reinterpret_cast
<
hb_ms_feature_t
*
>
(
offset
)
;
range
-
>
features
.
num_features
=
feature_records
.
length
-
offset
;
range
-
>
index_first
=
last_index
;
range
-
>
index_last
=
event
-
>
index
-
1
;
last_index
=
event
-
>
index
;
}
if
(
event
-
>
start
)
{
active_features
.
push
(
event
-
>
feature
)
;
}
else
{
auto
*
feature
=
active_features
.
lsearch
(
event
-
>
feature
)
;
if
(
feature
)
active_features
.
remove_ordered
(
feature
-
active_features
.
arrayZ
)
;
}
}
if
(
!
range_records
.
length
)
num_features
=
0
;
for
(
unsigned
int
i
=
0
;
i
<
range_records
.
length
;
i
+
+
)
{
auto
*
range
=
&
range_records
[
i
]
;
range
-
>
features
.
features
=
(
hb_ms_feature_t
*
)
feature_records
+
reinterpret_cast
<
uintptr_t
>
(
range
-
>
features
.
features
)
;
}
return
!
!
num_features
;
}
static
inline
void
hb_ms_make_feature_ranges
(
hb_vector_t
<
hb_ms_feature_t
>
&
feature_records
hb_vector_t
<
hb_ms_range_record_t
>
&
range_records
unsigned
int
chars_offset
unsigned
int
chars_len
uint16_t
*
log_clusters
hb_vector_t
<
hb_ms_features_t
*
>
&
range_features
hb_vector_t
<
uint32_t
>
&
range_counts
)
{
range_features
.
shrink
(
0
)
;
range_counts
.
shrink
(
0
)
;
auto
*
last_range
=
&
range_records
[
0
]
;
for
(
unsigned
int
i
=
chars_offset
;
i
<
chars_len
;
i
+
+
)
{
auto
*
range
=
last_range
;
while
(
log_clusters
[
i
]
<
range
-
>
index_first
)
range
-
-
;
while
(
log_clusters
[
i
]
>
range
-
>
index_last
)
range
+
+
;
if
(
!
range_features
.
length
|
|
&
range
-
>
features
!
=
range_features
[
range_features
.
length
-
1
]
)
{
auto
*
*
features
=
range_features
.
push
(
)
;
auto
*
c
=
range_counts
.
push
(
)
;
if
(
unlikely
(
!
features
|
|
!
c
)
)
{
range_features
.
shrink
(
0
)
;
range_counts
.
shrink
(
0
)
;
break
;
}
*
features
=
&
range
-
>
features
;
*
c
=
1
;
}
else
{
range_counts
[
range_counts
.
length
-
1
]
+
+
;
}
last_range
=
range
;
}
}
#
endif
