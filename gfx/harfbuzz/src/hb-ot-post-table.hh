#
ifndef
HB_OT_POST_TABLE_HH
#
define
HB_OT_POST_TABLE_HH
#
include
"
hb
-
open
-
type
.
hh
"
#
define
HB_STRING_ARRAY_NAME
format1_names
#
define
HB_STRING_ARRAY_LIST
"
hb
-
ot
-
post
-
macroman
.
hh
"
#
include
"
hb
-
string
-
array
.
hh
"
#
undef
HB_STRING_ARRAY_LIST
#
undef
HB_STRING_ARRAY_NAME
#
define
NUM_FORMAT1_NAMES
258
#
define
HB_OT_TAG_post
HB_TAG
(
'
p
'
'
o
'
'
s
'
'
t
'
)
namespace
OT
{
struct
postV2Tail
{
friend
struct
post
;
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
glyphNameIndex
.
sanitize
(
c
)
)
;
}
protected
:
ArrayOf
<
HBUINT16
>
glyphNameIndex
;
public
:
DEFINE_SIZE_ARRAY
(
2
glyphNameIndex
)
;
}
;
struct
post
{
static
constexpr
hb_tag_t
tableTag
=
HB_OT_TAG_post
;
void
serialize
(
hb_serialize_context_t
*
c
)
const
{
post
*
post_prime
=
c
-
>
allocate_min
<
post
>
(
)
;
if
(
unlikely
(
!
post_prime
)
)
return
;
memcpy
(
post_prime
this
post
:
:
min_size
)
;
post_prime
-
>
version
.
major
=
3
;
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
post
*
post_prime
=
c
-
>
serializer
-
>
start_embed
<
post
>
(
)
;
if
(
unlikely
(
!
post_prime
)
)
return_trace
(
false
)
;
serialize
(
c
-
>
serializer
)
;
if
(
c
-
>
serializer
-
>
in_error
(
)
|
|
c
-
>
serializer
-
>
ran_out_of_room
)
return_trace
(
false
)
;
return_trace
(
true
)
;
}
struct
accelerator_t
{
void
init
(
hb_face_t
*
face
)
{
index_to_offset
.
init
(
)
;
table
=
hb_sanitize_context_t
(
)
.
reference_table
<
post
>
(
face
)
;
unsigned
int
table_length
=
table
.
get_length
(
)
;
version
=
table
-
>
version
.
to_int
(
)
;
if
(
version
!
=
0x00020000
)
return
;
const
postV2Tail
&
v2
=
table
-
>
v2X
;
glyphNameIndex
=
&
v2
.
glyphNameIndex
;
pool
=
&
StructAfter
<
uint8_t
>
(
v2
.
glyphNameIndex
)
;
const
uint8_t
*
end
=
(
const
uint8_t
*
)
(
const
void
*
)
table
+
table_length
;
for
(
const
uint8_t
*
data
=
pool
;
index_to_offset
.
length
<
65535
&
&
data
<
end
&
&
data
+
*
data
<
end
;
data
+
=
1
+
*
data
)
index_to_offset
.
push
(
data
-
pool
)
;
}
void
fini
(
)
{
index_to_offset
.
fini
(
)
;
free
(
gids_sorted_by_name
.
get
(
)
)
;
table
.
destroy
(
)
;
}
bool
get_glyph_name
(
hb_codepoint_t
glyph
char
*
buf
unsigned
int
buf_len
)
const
{
hb_bytes_t
s
=
find_glyph_name
(
glyph
)
;
if
(
!
s
.
length
)
return
false
;
if
(
!
buf_len
)
return
true
;
unsigned
int
len
=
hb_min
(
buf_len
-
1
s
.
length
)
;
strncpy
(
buf
s
.
arrayZ
len
)
;
buf
[
len
]
=
'
\
0
'
;
return
true
;
}
bool
get_glyph_from_name
(
const
char
*
name
int
len
hb_codepoint_t
*
glyph
)
const
{
unsigned
int
count
=
get_glyph_count
(
)
;
if
(
unlikely
(
!
count
)
)
return
false
;
if
(
len
<
0
)
len
=
strlen
(
name
)
;
if
(
unlikely
(
!
len
)
)
return
false
;
retry
:
uint16_t
*
gids
=
gids_sorted_by_name
.
get
(
)
;
if
(
unlikely
(
!
gids
)
)
{
gids
=
(
uint16_t
*
)
malloc
(
count
*
sizeof
(
gids
[
0
]
)
)
;
if
(
unlikely
(
!
gids
)
)
return
false
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
gids
[
i
]
=
i
;
hb_qsort
(
gids
count
sizeof
(
gids
[
0
]
)
cmp_gids
(
void
*
)
this
)
;
if
(
unlikely
(
!
gids_sorted_by_name
.
cmpexch
(
nullptr
gids
)
)
)
{
free
(
gids
)
;
goto
retry
;
}
}
hb_bytes_t
st
(
name
len
)
;
const
uint16_t
*
gid
=
(
const
uint16_t
*
)
hb_bsearch
(
hb_addressof
(
st
)
gids
count
sizeof
(
gids
[
0
]
)
cmp_key
(
void
*
)
this
)
;
if
(
gid
)
{
*
glyph
=
*
gid
;
return
true
;
}
return
false
;
}
protected
:
unsigned
int
get_glyph_count
(
)
const
{
if
(
version
=
=
0x00010000
)
return
NUM_FORMAT1_NAMES
;
if
(
version
=
=
0x00020000
)
return
glyphNameIndex
-
>
len
;
return
0
;
}
static
int
cmp_gids
(
const
void
*
pa
const
void
*
pb
void
*
arg
)
{
const
accelerator_t
*
thiz
=
(
const
accelerator_t
*
)
arg
;
uint16_t
a
=
*
(
const
uint16_t
*
)
pa
;
uint16_t
b
=
*
(
const
uint16_t
*
)
pb
;
return
thiz
-
>
find_glyph_name
(
b
)
.
cmp
(
thiz
-
>
find_glyph_name
(
a
)
)
;
}
static
int
cmp_key
(
const
void
*
pk
const
void
*
po
void
*
arg
)
{
const
accelerator_t
*
thiz
=
(
const
accelerator_t
*
)
arg
;
const
hb_bytes_t
*
key
=
(
const
hb_bytes_t
*
)
pk
;
uint16_t
o
=
*
(
const
uint16_t
*
)
po
;
return
thiz
-
>
find_glyph_name
(
o
)
.
cmp
(
*
key
)
;
}
hb_bytes_t
find_glyph_name
(
hb_codepoint_t
glyph
)
const
{
if
(
version
=
=
0x00010000
)
{
if
(
glyph
>
=
NUM_FORMAT1_NAMES
)
return
hb_bytes_t
(
)
;
return
format1_names
(
glyph
)
;
}
if
(
version
!
=
0x00020000
|
|
glyph
>
=
glyphNameIndex
-
>
len
)
return
hb_bytes_t
(
)
;
unsigned
int
index
=
glyphNameIndex
-
>
arrayZ
[
glyph
]
;
if
(
index
<
NUM_FORMAT1_NAMES
)
return
format1_names
(
index
)
;
index
-
=
NUM_FORMAT1_NAMES
;
if
(
index
>
=
index_to_offset
.
length
)
return
hb_bytes_t
(
)
;
unsigned
int
offset
=
index_to_offset
[
index
]
;
const
uint8_t
*
data
=
pool
+
offset
;
unsigned
int
name_length
=
*
data
;
data
+
+
;
return
hb_bytes_t
(
(
const
char
*
)
data
name_length
)
;
}
private
:
hb_blob_ptr_t
<
post
>
table
;
uint32_t
version
;
const
ArrayOf
<
HBUINT16
>
*
glyphNameIndex
;
hb_vector_t
<
uint32_t
>
index_to_offset
;
const
uint8_t
*
pool
;
hb_atomic_ptr_t
<
uint16_t
*
>
gids_sorted_by_name
;
}
;
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
(
version
.
to_int
(
)
=
=
0x00010000
|
|
(
version
.
to_int
(
)
=
=
0x00020000
&
&
v2X
.
sanitize
(
c
)
)
|
|
version
.
to_int
(
)
=
=
0x00030000
)
)
)
;
}
public
:
FixedVersion
<
>
version
;
Fixed
italicAngle
;
FWORD
underlinePosition
;
FWORD
underlineThickness
;
HBUINT32
isFixedPitch
;
HBUINT32
minMemType42
;
HBUINT32
maxMemType42
;
HBUINT32
minMemType1
;
HBUINT32
maxMemType1
;
postV2Tail
v2X
;
DEFINE_SIZE_MIN
(
32
)
;
}
;
struct
post_accelerator_t
:
post
:
:
accelerator_t
{
}
;
}
#
endif
