#
ifndef
HB_AAT_LAYOUT_TRAK_TABLE_HH
#
define
HB_AAT_LAYOUT_TRAK_TABLE_HH
#
include
"
hb
-
aat
-
layout
-
common
-
private
.
hh
"
#
include
"
hb
-
ot
-
layout
-
private
.
hh
"
#
include
"
hb
-
open
-
type
-
private
.
hh
"
#
define
HB_AAT_TAG_trak
HB_TAG
(
'
t
'
'
r
'
'
a
'
'
k
'
)
namespace
AAT
{
struct
TrackTableEntry
{
friend
struct
TrackData
;
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
unsigned
int
size
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
(
valuesZ
.
sanitize
(
c
base
size
)
)
)
)
;
}
private
:
inline
float
get_track_value
(
)
const
{
return
track
.
to_float
(
)
;
}
inline
int
get_value
(
const
void
*
base
unsigned
int
index
)
const
{
return
(
base
+
valuesZ
)
[
index
]
;
}
protected
:
Fixed
track
;
NameID
trackNameID
;
OffsetTo
<
UnsizedArrayOf
<
FWORD
>
>
valuesZ
;
public
:
DEFINE_SIZE_STATIC
(
8
)
;
}
;
struct
TrackData
{
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
sizeTable
.
sanitize
(
c
base
nSizes
)
&
&
trackTable
.
sanitize
(
c
nTracks
base
nSizes
)
)
;
}
inline
float
get_tracking
(
const
void
*
base
float
ptem
)
const
{
float
csspx
=
ptem
*
96
.
f
/
72
.
f
;
Fixed
fixed_size
;
fixed_size
.
set_float
(
csspx
)
;
unsigned
int
sizes
=
nSizes
;
const
TrackTableEntry
*
trackTableEntry
=
nullptr
;
for
(
unsigned
int
i
=
0
;
i
<
sizes
;
+
+
i
)
if
(
trackTable
[
i
]
.
get_track_value
(
)
=
=
0
.
f
)
trackTableEntry
=
&
trackTable
[
0
]
;
if
(
!
trackTableEntry
)
return
0
.
;
unsigned
int
size_index
;
UnsizedArrayOf
<
Fixed
>
size_table
=
base
+
sizeTable
;
for
(
size_index
=
0
;
size_index
<
sizes
;
+
+
size_index
)
if
(
size_table
[
size_index
]
>
=
fixed_size
)
break
;
if
(
size_index
=
=
sizes
)
return
trackTableEntry
-
>
get_value
(
base
sizes
-
1
)
;
if
(
size_index
=
=
0
|
|
size_table
[
size_index
]
=
=
fixed_size
)
return
trackTableEntry
-
>
get_value
(
base
size_index
)
;
float
s0
=
size_table
[
size_index
-
1
]
.
to_float
(
)
;
float
s1
=
size_table
[
size_index
]
.
to_float
(
)
;
float
t
=
(
csspx
-
s0
)
/
(
s1
-
s0
)
;
return
(
float
)
t
*
trackTableEntry
-
>
get_value
(
base
size_index
)
+
(
(
float
)
1
.
0
-
t
)
*
trackTableEntry
-
>
get_value
(
base
size_index
-
1
)
;
}
protected
:
HBUINT16
nTracks
;
HBUINT16
nSizes
;
LOffsetTo
<
UnsizedArrayOf
<
Fixed
>
>
sizeTable
;
UnsizedArrayOf
<
TrackTableEntry
>
trackTable
;
public
:
DEFINE_SIZE_ARRAY
(
8
trackTable
)
;
}
;
struct
trak
{
static
const
hb_tag_t
tableTag
=
HB_AAT_TAG_trak
;
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
unlikely
(
c
-
>
check_struct
(
this
)
&
&
horizData
.
sanitize
(
c
this
this
)
&
&
vertData
.
sanitize
(
c
this
this
)
)
)
;
}
inline
bool
apply
(
hb_aat_apply_context_t
*
c
)
const
{
TRACE_APPLY
(
this
)
;
const
float
ptem
=
c
-
>
font
-
>
ptem
;
if
(
unlikely
(
ptem
<
=
0
.
f
)
)
return_trace
(
false
)
;
hb_buffer_t
*
buffer
=
c
-
>
buffer
;
if
(
HB_DIRECTION_IS_HORIZONTAL
(
buffer
-
>
props
.
direction
)
)
{
const
TrackData
&
trackData
=
this
+
horizData
;
float
tracking
=
trackData
.
get_tracking
(
this
ptem
)
;
hb_position_t
advance_to_add
=
c
-
>
font
-
>
em_scalef_x
(
tracking
/
2
)
;
foreach_grapheme
(
buffer
start
end
)
{
buffer
-
>
pos
[
start
]
.
x_advance
+
=
advance_to_add
;
buffer
-
>
pos
[
end
]
.
x_advance
+
=
advance_to_add
;
}
}
else
{
const
TrackData
&
trackData
=
this
+
vertData
;
float
tracking
=
trackData
.
get_tracking
(
this
ptem
)
;
hb_position_t
advance_to_add
=
c
-
>
font
-
>
em_scalef_y
(
tracking
/
2
)
;
foreach_grapheme
(
buffer
start
end
)
{
buffer
-
>
pos
[
start
]
.
y_advance
+
=
advance_to_add
;
buffer
-
>
pos
[
end
]
.
y_advance
+
=
advance_to_add
;
}
}
return_trace
(
true
)
;
}
protected
:
FixedVersion
<
>
version
;
HBUINT16
format
;
OffsetTo
<
TrackData
>
horizData
;
OffsetTo
<
TrackData
>
vertData
;
HBUINT16
reserved
;
public
:
DEFINE_SIZE_MIN
(
12
)
;
}
;
}
#
endif
