#
ifndef
HB_OT_NAME_TABLE_HH
#
define
HB_OT_NAME_TABLE_HH
#
include
"
hb
-
open
-
type
.
hh
"
#
include
"
hb
-
ot
-
name
-
language
.
hh
"
#
include
"
hb
-
aat
-
layout
.
hh
"
namespace
OT
{
#
define
entry_score
var
.
u16
[
0
]
#
define
entry_index
var
.
u16
[
1
]
#
define
HB_OT_TAG_name
HB_TAG
(
'
n
'
'
a
'
'
m
'
'
e
'
)
#
define
UNSUPPORTED
42
struct
NameRecord
{
hb_language_t
language
(
hb_face_t
*
face
)
const
{
unsigned
int
p
=
platformID
;
unsigned
int
l
=
languageID
;
if
(
p
=
=
3
)
return
_hb_ot_name_language_for_ms_code
(
l
)
;
if
(
p
=
=
1
)
return
_hb_ot_name_language_for_mac_code
(
l
)
;
if
(
p
=
=
0
)
return
_hb_aat_language_get
(
face
l
)
;
return
HB_LANGUAGE_INVALID
;
}
uint16_t
score
(
)
const
{
unsigned
int
p
=
platformID
;
unsigned
int
e
=
encodingID
;
if
(
p
=
=
3
&
&
e
=
=
10
)
return
0
;
if
(
p
=
=
0
&
&
e
=
=
6
)
return
1
;
if
(
p
=
=
0
&
&
e
=
=
4
)
return
2
;
if
(
p
=
=
3
&
&
e
=
=
1
)
return
3
;
if
(
p
=
=
0
&
&
e
=
=
3
)
return
4
;
if
(
p
=
=
0
&
&
e
=
=
2
)
return
5
;
if
(
p
=
=
0
&
&
e
=
=
1
)
return
6
;
if
(
p
=
=
0
&
&
e
=
=
0
)
return
7
;
if
(
p
=
=
3
&
&
e
=
=
0
)
return
8
;
if
(
p
=
=
1
&
&
e
=
=
0
)
return
10
;
return
UNSUPPORTED
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
c
-
>
check_range
(
(
char
*
)
base
(
unsigned
int
)
length
+
offset
)
)
;
}
HBUINT16
platformID
;
HBUINT16
encodingID
;
HBUINT16
languageID
;
HBUINT16
nameID
;
HBUINT16
length
;
HBUINT16
offset
;
public
:
DEFINE_SIZE_STATIC
(
12
)
;
}
;
static
int
_hb_ot_name_entry_cmp_key
(
const
void
*
pa
const
void
*
pb
)
{
const
hb_ot_name_entry_t
*
a
=
(
const
hb_ot_name_entry_t
*
)
pa
;
const
hb_ot_name_entry_t
*
b
=
(
const
hb_ot_name_entry_t
*
)
pb
;
if
(
a
-
>
name_id
!
=
b
-
>
name_id
)
return
a
-
>
name_id
<
b
-
>
name_id
?
-
1
:
+
1
;
if
(
a
-
>
language
=
=
b
-
>
language
)
return
0
;
if
(
!
a
-
>
language
)
return
-
1
;
if
(
!
b
-
>
language
)
return
+
1
;
return
strcmp
(
hb_language_to_string
(
a
-
>
language
)
hb_language_to_string
(
b
-
>
language
)
)
;
}
static
int
_hb_ot_name_entry_cmp
(
const
void
*
pa
const
void
*
pb
)
{
int
v
=
_hb_ot_name_entry_cmp_key
(
pa
pb
)
;
if
(
v
)
return
v
;
const
hb_ot_name_entry_t
*
a
=
(
const
hb_ot_name_entry_t
*
)
pa
;
const
hb_ot_name_entry_t
*
b
=
(
const
hb_ot_name_entry_t
*
)
pb
;
if
(
a
-
>
entry_score
!
=
b
-
>
entry_score
)
return
a
-
>
entry_score
<
b
-
>
entry_score
?
-
1
:
+
1
;
if
(
a
-
>
entry_index
!
=
b
-
>
entry_index
)
return
a
-
>
entry_index
<
b
-
>
entry_index
?
-
1
:
+
1
;
return
0
;
}
struct
name
{
static
constexpr
hb_tag_t
tableTag
=
HB_OT_TAG_name
;
unsigned
int
get_size
(
)
const
{
return
min_size
+
count
*
nameRecordZ
.
item_size
;
}
bool
sanitize_records
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
const
void
*
string_pool
=
(
this
+
stringOffset
)
.
arrayZ
;
unsigned
int
_count
=
count
;
for
(
unsigned
int
i
=
0
;
i
<
_count
;
i
+
+
)
if
(
!
nameRecordZ
[
i
]
.
sanitize
(
c
string_pool
)
)
return_trace
(
false
)
;
return_trace
(
true
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
likely
(
format
=
=
0
|
|
format
=
=
1
)
&
&
c
-
>
check_array
(
nameRecordZ
.
arrayZ
count
)
&
&
c
-
>
check_range
(
this
stringOffset
)
)
;
}
struct
accelerator_t
{
void
init
(
hb_face_t
*
face
)
{
this
-
>
table
=
hb_sanitize_context_t
(
)
.
reference_table
<
name
>
(
face
)
;
assert
(
this
-
>
table
.
get_length
(
)
>
=
this
-
>
table
-
>
stringOffset
)
;
this
-
>
pool
=
(
const
char
*
)
(
const
void
*
)
(
this
-
>
table
+
this
-
>
table
-
>
stringOffset
)
;
this
-
>
pool_len
=
this
-
>
table
.
get_length
(
)
-
this
-
>
table
-
>
stringOffset
;
const
hb_array_t
<
const
NameRecord
>
all_names
(
this
-
>
table
-
>
nameRecordZ
.
arrayZ
this
-
>
table
-
>
count
)
;
this
-
>
names
.
init
(
)
;
this
-
>
names
.
alloc
(
all_names
.
length
)
;
for
(
unsigned
int
i
=
0
;
i
<
all_names
.
length
;
i
+
+
)
{
hb_ot_name_entry_t
*
entry
=
this
-
>
names
.
push
(
)
;
entry
-
>
name_id
=
all_names
[
i
]
.
nameID
;
entry
-
>
language
=
all_names
[
i
]
.
language
(
face
)
;
entry
-
>
entry_score
=
all_names
[
i
]
.
score
(
)
;
entry
-
>
entry_index
=
i
;
}
this
-
>
names
.
qsort
(
_hb_ot_name_entry_cmp
)
;
unsigned
int
j
=
0
;
for
(
unsigned
int
i
=
0
;
i
<
this
-
>
names
.
length
;
i
+
+
)
{
if
(
this
-
>
names
[
i
]
.
entry_score
=
=
UNSUPPORTED
|
|
this
-
>
names
[
i
]
.
language
=
=
HB_LANGUAGE_INVALID
)
continue
;
if
(
i
&
&
this
-
>
names
[
i
-
1
]
.
name_id
=
=
this
-
>
names
[
i
]
.
name_id
&
&
this
-
>
names
[
i
-
1
]
.
language
=
=
this
-
>
names
[
i
]
.
language
)
continue
;
this
-
>
names
[
j
+
+
]
=
this
-
>
names
[
i
]
;
}
this
-
>
names
.
resize
(
j
)
;
}
void
fini
(
)
{
this
-
>
names
.
fini
(
)
;
this
-
>
table
.
destroy
(
)
;
}
int
get_index
(
hb_ot_name_id_t
name_id
hb_language_t
language
unsigned
int
*
width
=
nullptr
)
const
{
const
hb_ot_name_entry_t
key
=
{
name_id
{
0
}
language
}
;
const
hb_ot_name_entry_t
*
entry
=
(
const
hb_ot_name_entry_t
*
)
hb_bsearch
(
&
key
(
const
hb_ot_name_entry_t
*
)
this
-
>
names
this
-
>
names
.
length
sizeof
(
key
)
_hb_ot_name_entry_cmp_key
)
;
if
(
!
entry
)
return
-
1
;
if
(
width
)
*
width
=
entry
-
>
entry_score
<
10
?
2
:
1
;
return
entry
-
>
entry_index
;
}
hb_bytes_t
get_name
(
unsigned
int
idx
)
const
{
const
hb_array_t
<
const
NameRecord
>
all_names
(
table
-
>
nameRecordZ
.
arrayZ
table
-
>
count
)
;
const
NameRecord
&
record
=
all_names
[
idx
]
;
const
hb_bytes_t
string_pool
(
pool
pool_len
)
;
return
string_pool
.
sub_array
(
record
.
offset
record
.
length
)
;
}
private
:
const
char
*
pool
;
unsigned
int
pool_len
;
public
:
hb_blob_ptr_t
<
name
>
table
;
hb_vector_t
<
hb_ot_name_entry_t
>
names
;
}
;
HBUINT16
format
;
HBUINT16
count
;
NNOffsetTo
<
UnsizedArrayOf
<
HBUINT8
>
>
stringOffset
;
UnsizedArrayOf
<
NameRecord
>
nameRecordZ
;
public
:
DEFINE_SIZE_ARRAY
(
6
nameRecordZ
)
;
}
;
struct
name_accelerator_t
:
name
:
:
accelerator_t
{
}
;
}
#
endif
