#
ifndef
_POSIX_C_SOURCE
#
define
_POSIX_C_SOURCE
200809L
#
endif
#
include
"
hb
-
private
.
hh
"
#
include
"
hb
-
blob
-
private
.
hh
"
#
ifdef
HAVE_SYS_MMAN_H
#
ifdef
HAVE_UNISTD_H
#
include
<
unistd
.
h
>
#
endif
#
include
<
sys
/
mman
.
h
>
#
endif
#
include
<
stdio
.
h
>
#
include
<
errno
.
h
>
#
include
<
stdlib
.
h
>
DEFINE_NULL_INSTANCE
(
hb_blob_t
)
=
{
HB_OBJECT_HEADER_STATIC
true
nullptr
0
HB_MEMORY_MODE_READONLY
nullptr
nullptr
}
;
hb_blob_t
*
hb_blob_create
(
const
char
*
data
unsigned
int
length
hb_memory_mode_t
mode
void
*
user_data
hb_destroy_func_t
destroy
)
{
hb_blob_t
*
blob
;
if
(
!
length
|
|
length
>
=
1u
<
<
31
|
|
!
(
blob
=
hb_object_create
<
hb_blob_t
>
(
)
)
)
{
if
(
destroy
)
destroy
(
user_data
)
;
return
hb_blob_get_empty
(
)
;
}
blob
-
>
data
=
data
;
blob
-
>
length
=
length
;
blob
-
>
mode
=
mode
;
blob
-
>
user_data
=
user_data
;
blob
-
>
destroy
=
destroy
;
if
(
blob
-
>
mode
=
=
HB_MEMORY_MODE_DUPLICATE
)
{
blob
-
>
mode
=
HB_MEMORY_MODE_READONLY
;
if
(
!
blob
-
>
try_make_writable
(
)
)
{
hb_blob_destroy
(
blob
)
;
return
hb_blob_get_empty
(
)
;
}
}
return
blob
;
}
static
void
_hb_blob_destroy
(
void
*
data
)
{
hb_blob_destroy
(
(
hb_blob_t
*
)
data
)
;
}
hb_blob_t
*
hb_blob_create_sub_blob
(
hb_blob_t
*
parent
unsigned
int
offset
unsigned
int
length
)
{
hb_blob_t
*
blob
;
if
(
!
length
|
|
offset
>
=
parent
-
>
length
)
return
hb_blob_get_empty
(
)
;
hb_blob_make_immutable
(
parent
)
;
blob
=
hb_blob_create
(
parent
-
>
data
+
offset
MIN
(
length
parent
-
>
length
-
offset
)
HB_MEMORY_MODE_READONLY
hb_blob_reference
(
parent
)
_hb_blob_destroy
)
;
return
blob
;
}
hb_blob_t
*
hb_blob_copy_writable_or_fail
(
hb_blob_t
*
blob
)
{
blob
=
hb_blob_create
(
blob
-
>
data
blob
-
>
length
HB_MEMORY_MODE_DUPLICATE
nullptr
nullptr
)
;
if
(
unlikely
(
blob
=
=
hb_blob_get_empty
(
)
)
)
blob
=
nullptr
;
return
blob
;
}
hb_blob_t
*
hb_blob_get_empty
(
void
)
{
return
const_cast
<
hb_blob_t
*
>
(
&
Null
(
hb_blob_t
)
)
;
}
hb_blob_t
*
hb_blob_reference
(
hb_blob_t
*
blob
)
{
return
hb_object_reference
(
blob
)
;
}
void
hb_blob_destroy
(
hb_blob_t
*
blob
)
{
if
(
!
hb_object_destroy
(
blob
)
)
return
;
blob
-
>
fini_shallow
(
)
;
free
(
blob
)
;
}
hb_bool_t
hb_blob_set_user_data
(
hb_blob_t
*
blob
hb_user_data_key_t
*
key
void
*
data
hb_destroy_func_t
destroy
hb_bool_t
replace
)
{
return
hb_object_set_user_data
(
blob
key
data
destroy
replace
)
;
}
void
*
hb_blob_get_user_data
(
hb_blob_t
*
blob
hb_user_data_key_t
*
key
)
{
return
hb_object_get_user_data
(
blob
key
)
;
}
void
hb_blob_make_immutable
(
hb_blob_t
*
blob
)
{
if
(
hb_object_is_inert
(
blob
)
)
return
;
blob
-
>
immutable
=
true
;
}
hb_bool_t
hb_blob_is_immutable
(
hb_blob_t
*
blob
)
{
return
blob
-
>
immutable
;
}
unsigned
int
hb_blob_get_length
(
hb_blob_t
*
blob
)
{
return
blob
-
>
length
;
}
const
char
*
hb_blob_get_data
(
hb_blob_t
*
blob
unsigned
int
*
length
)
{
if
(
length
)
*
length
=
blob
-
>
length
;
return
blob
-
>
data
;
}
char
*
hb_blob_get_data_writable
(
hb_blob_t
*
blob
unsigned
int
*
length
)
{
if
(
!
blob
-
>
try_make_writable
(
)
)
{
if
(
length
)
*
length
=
0
;
return
nullptr
;
}
if
(
length
)
*
length
=
blob
-
>
length
;
return
const_cast
<
char
*
>
(
blob
-
>
data
)
;
}
bool
hb_blob_t
:
:
try_make_writable_inplace_unix
(
void
)
{
#
if
defined
(
HAVE_SYS_MMAN_H
)
&
&
defined
(
HAVE_MPROTECT
)
uintptr_t
pagesize
=
-
1
mask
length
;
const
char
*
addr
;
#
if
defined
(
HAVE_SYSCONF
)
&
&
defined
(
_SC_PAGE_SIZE
)
pagesize
=
(
uintptr_t
)
sysconf
(
_SC_PAGE_SIZE
)
;
#
elif
defined
(
HAVE_SYSCONF
)
&
&
defined
(
_SC_PAGESIZE
)
pagesize
=
(
uintptr_t
)
sysconf
(
_SC_PAGESIZE
)
;
#
elif
defined
(
HAVE_GETPAGESIZE
)
pagesize
=
(
uintptr_t
)
getpagesize
(
)
;
#
endif
if
(
(
uintptr_t
)
-
1L
=
=
pagesize
)
{
DEBUG_MSG_FUNC
(
BLOB
this
"
failed
to
get
pagesize
:
%
s
"
strerror
(
errno
)
)
;
return
false
;
}
DEBUG_MSG_FUNC
(
BLOB
this
"
pagesize
is
%
lu
"
(
unsigned
long
)
pagesize
)
;
mask
=
~
(
pagesize
-
1
)
;
addr
=
(
const
char
*
)
(
(
(
uintptr_t
)
this
-
>
data
)
&
mask
)
;
length
=
(
const
char
*
)
(
(
(
uintptr_t
)
this
-
>
data
+
this
-
>
length
+
pagesize
-
1
)
&
mask
)
-
addr
;
DEBUG_MSG_FUNC
(
BLOB
this
"
calling
mprotect
on
[
%
p
.
.
%
p
]
(
%
lu
bytes
)
"
addr
addr
+
length
(
unsigned
long
)
length
)
;
if
(
-
1
=
=
mprotect
(
(
void
*
)
addr
length
PROT_READ
|
PROT_WRITE
)
)
{
DEBUG_MSG_FUNC
(
BLOB
this
"
mprotect
failed
:
%
s
"
strerror
(
errno
)
)
;
return
false
;
}
this
-
>
mode
=
HB_MEMORY_MODE_WRITABLE
;
DEBUG_MSG_FUNC
(
BLOB
this
"
successfully
made
[
%
p
.
.
%
p
]
(
%
lu
bytes
)
writable
\
n
"
addr
addr
+
length
(
unsigned
long
)
length
)
;
return
true
;
#
else
return
false
;
#
endif
}
bool
hb_blob_t
:
:
try_make_writable_inplace
(
void
)
{
DEBUG_MSG_FUNC
(
BLOB
this
"
making
writable
inplace
\
n
"
)
;
if
(
this
-
>
try_make_writable_inplace_unix
(
)
)
return
true
;
DEBUG_MSG_FUNC
(
BLOB
this
"
making
writable
-
>
FAILED
\
n
"
)
;
this
-
>
mode
=
HB_MEMORY_MODE_READONLY
;
return
false
;
}
bool
hb_blob_t
:
:
try_make_writable
(
void
)
{
if
(
this
-
>
immutable
)
return
false
;
if
(
this
-
>
mode
=
=
HB_MEMORY_MODE_WRITABLE
)
return
true
;
if
(
this
-
>
mode
=
=
HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE
&
&
this
-
>
try_make_writable_inplace
(
)
)
return
true
;
if
(
this
-
>
mode
=
=
HB_MEMORY_MODE_WRITABLE
)
return
true
;
DEBUG_MSG_FUNC
(
BLOB
this
"
current
data
is
-
>
%
p
\
n
"
this
-
>
data
)
;
char
*
new_data
;
new_data
=
(
char
*
)
malloc
(
this
-
>
length
)
;
if
(
unlikely
(
!
new_data
)
)
return
false
;
DEBUG_MSG_FUNC
(
BLOB
this
"
dupped
successfully
-
>
%
p
\
n
"
this
-
>
data
)
;
memcpy
(
new_data
this
-
>
data
this
-
>
length
)
;
this
-
>
destroy_user_data
(
)
;
this
-
>
mode
=
HB_MEMORY_MODE_WRITABLE
;
this
-
>
data
=
new_data
;
this
-
>
user_data
=
new_data
;
this
-
>
destroy
=
free
;
return
true
;
}
#
ifdef
HAVE_MMAP
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
fcntl
.
h
>
#
endif
#
if
defined
(
_WIN32
)
|
|
defined
(
__CYGWIN__
)
#
include
<
windows
.
h
>
#
else
#
ifndef
_O_BINARY
#
define
_O_BINARY
0
#
endif
#
endif
#
ifndef
MAP_NORESERVE
#
define
MAP_NORESERVE
0
#
endif
struct
hb_mapped_file_t
{
char
*
contents
;
unsigned
long
length
;
#
if
defined
(
_WIN32
)
|
|
defined
(
__CYGWIN__
)
HANDLE
mapping
;
#
endif
}
;
#
if
(
defined
(
HAVE_MMAP
)
|
|
defined
(
_WIN32
)
|
|
defined
(
__CYGWIN__
)
)
&
&
!
defined
(
HB_NO_MMAP
)
static
void
_hb_mapped_file_destroy
(
hb_mapped_file_t
*
file
)
{
#
ifdef
HAVE_MMAP
munmap
(
file
-
>
contents
file
-
>
length
)
;
#
elif
defined
(
_WIN32
)
|
|
defined
(
__CYGWIN__
)
UnmapViewOfFile
(
file
-
>
contents
)
;
CloseHandle
(
file
-
>
mapping
)
;
#
else
assert
(
0
)
;
#
endif
free
(
file
)
;
}
#
endif
hb_blob_t
*
hb_blob_create_from_file
(
const
char
*
file_name
)
{
#
if
defined
(
HAVE_MMAP
)
&
&
!
defined
(
HB_NO_MMAP
)
hb_mapped_file_t
*
file
=
(
hb_mapped_file_t
*
)
calloc
(
1
sizeof
(
hb_mapped_file_t
)
)
;
if
(
unlikely
(
!
file
)
)
return
hb_blob_get_empty
(
)
;
int
fd
=
open
(
file_name
O_RDONLY
|
_O_BINARY
0
)
;
if
(
unlikely
(
fd
=
=
-
1
)
)
goto
fail_without_close
;
struct
stat
st
;
if
(
unlikely
(
fstat
(
fd
&
st
)
=
=
-
1
)
)
goto
fail
;
file
-
>
length
=
(
unsigned
long
)
st
.
st_size
;
file
-
>
contents
=
(
char
*
)
mmap
(
nullptr
file
-
>
length
PROT_READ
MAP_PRIVATE
|
MAP_NORESERVE
fd
0
)
;
if
(
unlikely
(
file
-
>
contents
=
=
MAP_FAILED
)
)
goto
fail
;
close
(
fd
)
;
return
hb_blob_create
(
file
-
>
contents
file
-
>
length
HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE
(
void
*
)
file
(
hb_destroy_func_t
)
_hb_mapped_file_destroy
)
;
fail
:
close
(
fd
)
;
fail_without_close
:
free
(
file
)
;
#
elif
(
defined
(
_WIN32
)
|
|
defined
(
__CYGWIN__
)
)
&
&
!
defined
(
HB_NO_MMAP
)
hb_mapped_file_t
*
file
=
(
hb_mapped_file_t
*
)
calloc
(
1
sizeof
(
hb_mapped_file_t
)
)
;
if
(
unlikely
(
!
file
)
)
return
hb_blob_get_empty
(
)
;
HANDLE
fd
;
unsigned
int
size
=
strlen
(
file_name
)
+
1
;
wchar_t
*
wchar_file_name
=
(
wchar_t
*
)
malloc
(
sizeof
(
wchar_t
)
*
size
)
;
if
(
unlikely
(
wchar_file_name
=
=
nullptr
)
)
goto
fail_without_close
;
mbstowcs
(
wchar_file_name
file_name
size
)
;
fd
=
CreateFileW
(
wchar_file_name
GENERIC_READ
FILE_SHARE_READ
nullptr
OPEN_EXISTING
FILE_ATTRIBUTE_NORMAL
|
FILE_FLAG_OVERLAPPED
nullptr
)
;
free
(
wchar_file_name
)
;
if
(
unlikely
(
fd
=
=
INVALID_HANDLE_VALUE
)
)
goto
fail_without_close
;
file
-
>
length
=
(
unsigned
long
)
GetFileSize
(
fd
nullptr
)
;
file
-
>
mapping
=
CreateFileMapping
(
fd
nullptr
PAGE_READONLY
0
0
nullptr
)
;
if
(
unlikely
(
file
-
>
mapping
=
=
nullptr
)
)
goto
fail
;
file
-
>
contents
=
(
char
*
)
MapViewOfFile
(
file
-
>
mapping
FILE_MAP_READ
0
0
0
)
;
if
(
unlikely
(
file
-
>
contents
=
=
nullptr
)
)
goto
fail
;
CloseHandle
(
fd
)
;
return
hb_blob_create
(
file
-
>
contents
file
-
>
length
HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE
(
void
*
)
file
(
hb_destroy_func_t
)
_hb_mapped_file_destroy
)
;
fail
:
CloseHandle
(
fd
)
;
fail_without_close
:
free
(
file
)
;
#
endif
unsigned
long
len
=
0
allocated
=
BUFSIZ
*
16
;
char
*
data
=
(
char
*
)
malloc
(
allocated
)
;
if
(
unlikely
(
data
=
=
nullptr
)
)
return
hb_blob_get_empty
(
)
;
FILE
*
fp
=
fopen
(
file_name
"
rb
"
)
;
if
(
unlikely
(
fp
=
=
nullptr
)
)
goto
fread_fail_without_close
;
while
(
!
feof
(
fp
)
)
{
if
(
allocated
-
len
<
BUFSIZ
)
{
allocated
*
=
2
;
if
(
unlikely
(
allocated
>
(
2
<
<
28
)
)
)
goto
fread_fail
;
char
*
new_data
=
(
char
*
)
realloc
(
data
allocated
)
;
if
(
unlikely
(
new_data
=
=
nullptr
)
)
goto
fread_fail
;
data
=
new_data
;
}
unsigned
long
addition
=
fread
(
data
+
len
1
allocated
-
len
fp
)
;
int
err
=
ferror
(
fp
)
;
#
ifdef
EINTR
if
(
unlikely
(
err
=
=
EINTR
)
)
continue
;
#
endif
if
(
unlikely
(
err
)
)
goto
fread_fail
;
len
+
=
addition
;
}
return
hb_blob_create
(
data
len
HB_MEMORY_MODE_WRITABLE
data
(
hb_destroy_func_t
)
free
)
;
fread_fail
:
fclose
(
fp
)
;
fread_fail_without_close
:
free
(
data
)
;
return
hb_blob_get_empty
(
)
;
}
