#
ifndef
_POSIX_C_SOURCE
#
define
_POSIX_C_SOURCE
200809L
#
endif
#
include
"
hb
-
private
.
hh
"
#
include
"
hb
-
debug
.
hh
"
#
include
"
hb
-
blob
-
private
.
hh
"
#
ifdef
HAVE_SYS_MMAN_H
#
ifdef
HAVE_UNISTD_H
#
include
<
unistd
.
h
>
#
endif
#
include
<
sys
/
mman
.
h
>
#
endif
#
include
<
stdio
.
h
>
#
include
<
errno
.
h
>
#
include
<
stdlib
.
h
>
hb_blob_t
*
hb_blob_create
(
const
char
*
data
unsigned
int
length
hb_memory_mode_t
mode
void
*
user_data
hb_destroy_func_t
destroy
)
{
hb_blob_t
*
blob
;
if
(
!
length
|
|
length
>
=
1u
<
<
31
|
|
!
(
blob
=
hb_object_create
<
hb_blob_t
>
(
)
)
)
{
if
(
destroy
)
destroy
(
user_data
)
;
return
hb_blob_get_empty
(
)
;
}
blob
-
>
data
=
data
;
blob
-
>
length
=
length
;
blob
-
>
mode
=
mode
;
blob
-
>
user_data
=
user_data
;
blob
-
>
destroy
=
destroy
;
if
(
blob
-
>
mode
=
=
HB_MEMORY_MODE_DUPLICATE
)
{
blob
-
>
mode
=
HB_MEMORY_MODE_READONLY
;
if
(
!
blob
-
>
try_make_writable
(
)
)
{
hb_blob_destroy
(
blob
)
;
return
hb_blob_get_empty
(
)
;
}
}
return
blob
;
}
static
void
_hb_blob_destroy
(
void
*
data
)
{
hb_blob_destroy
(
(
hb_blob_t
*
)
data
)
;
}
hb_blob_t
*
hb_blob_create_sub_blob
(
hb_blob_t
*
parent
unsigned
int
offset
unsigned
int
length
)
{
hb_blob_t
*
blob
;
if
(
!
length
|
|
offset
>
=
parent
-
>
length
)
return
hb_blob_get_empty
(
)
;
hb_blob_make_immutable
(
parent
)
;
blob
=
hb_blob_create
(
parent
-
>
data
+
offset
MIN
(
length
parent
-
>
length
-
offset
)
HB_MEMORY_MODE_READONLY
hb_blob_reference
(
parent
)
_hb_blob_destroy
)
;
return
blob
;
}
hb_blob_t
*
hb_blob_copy_writable_or_fail
(
hb_blob_t
*
blob
)
{
blob
=
hb_blob_create
(
blob
-
>
data
blob
-
>
length
HB_MEMORY_MODE_DUPLICATE
nullptr
nullptr
)
;
if
(
unlikely
(
blob
=
=
hb_blob_get_empty
(
)
)
)
blob
=
nullptr
;
return
blob
;
}
hb_blob_t
*
hb_blob_get_empty
(
void
)
{
static
const
hb_blob_t
_hb_blob_nil
=
{
HB_OBJECT_HEADER_STATIC
true
nullptr
0
HB_MEMORY_MODE_READONLY
nullptr
nullptr
}
;
return
const_cast
<
hb_blob_t
*
>
(
&
_hb_blob_nil
)
;
}
hb_blob_t
*
hb_blob_reference
(
hb_blob_t
*
blob
)
{
return
hb_object_reference
(
blob
)
;
}
void
hb_blob_destroy
(
hb_blob_t
*
blob
)
{
if
(
!
hb_object_destroy
(
blob
)
)
return
;
blob
-
>
fini_shallow
(
)
;
free
(
blob
)
;
}
hb_bool_t
hb_blob_set_user_data
(
hb_blob_t
*
blob
hb_user_data_key_t
*
key
void
*
data
hb_destroy_func_t
destroy
hb_bool_t
replace
)
{
return
hb_object_set_user_data
(
blob
key
data
destroy
replace
)
;
}
void
*
hb_blob_get_user_data
(
hb_blob_t
*
blob
hb_user_data_key_t
*
key
)
{
return
hb_object_get_user_data
(
blob
key
)
;
}
void
hb_blob_make_immutable
(
hb_blob_t
*
blob
)
{
if
(
hb_object_is_inert
(
blob
)
)
return
;
blob
-
>
immutable
=
true
;
}
hb_bool_t
hb_blob_is_immutable
(
hb_blob_t
*
blob
)
{
return
blob
-
>
immutable
;
}
unsigned
int
hb_blob_get_length
(
hb_blob_t
*
blob
)
{
return
blob
-
>
length
;
}
const
char
*
hb_blob_get_data
(
hb_blob_t
*
blob
unsigned
int
*
length
)
{
if
(
length
)
*
length
=
blob
-
>
length
;
return
blob
-
>
data
;
}
char
*
hb_blob_get_data_writable
(
hb_blob_t
*
blob
unsigned
int
*
length
)
{
if
(
!
blob
-
>
try_make_writable
(
)
)
{
if
(
length
)
*
length
=
0
;
return
nullptr
;
}
if
(
length
)
*
length
=
blob
-
>
length
;
return
const_cast
<
char
*
>
(
blob
-
>
data
)
;
}
bool
hb_blob_t
:
:
try_make_writable_inplace_unix
(
void
)
{
#
if
defined
(
HAVE_SYS_MMAN_H
)
&
&
defined
(
HAVE_MPROTECT
)
uintptr_t
pagesize
=
-
1
mask
length
;
const
char
*
addr
;
#
if
defined
(
HAVE_SYSCONF
)
&
&
defined
(
_SC_PAGE_SIZE
)
pagesize
=
(
uintptr_t
)
sysconf
(
_SC_PAGE_SIZE
)
;
#
elif
defined
(
HAVE_SYSCONF
)
&
&
defined
(
_SC_PAGESIZE
)
pagesize
=
(
uintptr_t
)
sysconf
(
_SC_PAGESIZE
)
;
#
elif
defined
(
HAVE_GETPAGESIZE
)
pagesize
=
(
uintptr_t
)
getpagesize
(
)
;
#
endif
if
(
(
uintptr_t
)
-
1L
=
=
pagesize
)
{
DEBUG_MSG_FUNC
(
BLOB
this
"
failed
to
get
pagesize
:
%
s
"
strerror
(
errno
)
)
;
return
false
;
}
DEBUG_MSG_FUNC
(
BLOB
this
"
pagesize
is
%
lu
"
(
unsigned
long
)
pagesize
)
;
mask
=
~
(
pagesize
-
1
)
;
addr
=
(
const
char
*
)
(
(
(
uintptr_t
)
this
-
>
data
)
&
mask
)
;
length
=
(
const
char
*
)
(
(
(
uintptr_t
)
this
-
>
data
+
this
-
>
length
+
pagesize
-
1
)
&
mask
)
-
addr
;
DEBUG_MSG_FUNC
(
BLOB
this
"
calling
mprotect
on
[
%
p
.
.
%
p
]
(
%
lu
bytes
)
"
addr
addr
+
length
(
unsigned
long
)
length
)
;
if
(
-
1
=
=
mprotect
(
(
void
*
)
addr
length
PROT_READ
|
PROT_WRITE
)
)
{
DEBUG_MSG_FUNC
(
BLOB
this
"
mprotect
failed
:
%
s
"
strerror
(
errno
)
)
;
return
false
;
}
this
-
>
mode
=
HB_MEMORY_MODE_WRITABLE
;
DEBUG_MSG_FUNC
(
BLOB
this
"
successfully
made
[
%
p
.
.
%
p
]
(
%
lu
bytes
)
writable
\
n
"
addr
addr
+
length
(
unsigned
long
)
length
)
;
return
true
;
#
else
return
false
;
#
endif
}
bool
hb_blob_t
:
:
try_make_writable_inplace
(
void
)
{
DEBUG_MSG_FUNC
(
BLOB
this
"
making
writable
inplace
\
n
"
)
;
if
(
this
-
>
try_make_writable_inplace_unix
(
)
)
return
true
;
DEBUG_MSG_FUNC
(
BLOB
this
"
making
writable
-
>
FAILED
\
n
"
)
;
this
-
>
mode
=
HB_MEMORY_MODE_READONLY
;
return
false
;
}
bool
hb_blob_t
:
:
try_make_writable
(
void
)
{
if
(
this
-
>
immutable
)
return
false
;
if
(
this
-
>
mode
=
=
HB_MEMORY_MODE_WRITABLE
)
return
true
;
if
(
this
-
>
mode
=
=
HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE
&
&
this
-
>
try_make_writable_inplace
(
)
)
return
true
;
if
(
this
-
>
mode
=
=
HB_MEMORY_MODE_WRITABLE
)
return
true
;
DEBUG_MSG_FUNC
(
BLOB
this
"
current
data
is
-
>
%
p
\
n
"
this
-
>
data
)
;
char
*
new_data
;
new_data
=
(
char
*
)
malloc
(
this
-
>
length
)
;
if
(
unlikely
(
!
new_data
)
)
return
false
;
DEBUG_MSG_FUNC
(
BLOB
this
"
dupped
successfully
-
>
%
p
\
n
"
this
-
>
data
)
;
memcpy
(
new_data
this
-
>
data
this
-
>
length
)
;
this
-
>
destroy_user_data
(
)
;
this
-
>
mode
=
HB_MEMORY_MODE_WRITABLE
;
this
-
>
data
=
new_data
;
this
-
>
user_data
=
new_data
;
this
-
>
destroy
=
free
;
return
true
;
}
#
ifdef
HAVE_MMAP
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
fcntl
.
h
>
#
endif
#
if
defined
(
_WIN32
)
|
|
defined
(
__CYGWIN__
)
#
include
<
windows
.
h
>
#
endif
#
ifndef
_O_BINARY
#
define
_O_BINARY
0
#
endif
#
ifndef
MAP_NORESERVE
#
define
MAP_NORESERVE
0
#
endif
struct
hb_mapped_file_t
{
char
*
contents
;
unsigned
long
length
;
#
if
defined
(
_WIN32
)
|
|
defined
(
__CYGWIN__
)
HANDLE
mapping
;
#
endif
}
;
static
void
_hb_mapped_file_destroy
(
hb_mapped_file_t
*
file
)
{
#
ifdef
HAVE_MMAP
munmap
(
file
-
>
contents
file
-
>
length
)
;
#
elif
defined
(
_WIN32
)
|
|
defined
(
__CYGWIN__
)
UnmapViewOfFile
(
file
-
>
contents
)
;
CloseHandle
(
file
-
>
mapping
)
;
#
else
free
(
file
-
>
contents
)
;
#
endif
free
(
file
)
;
}
hb_blob_t
*
hb_blob_create_from_file
(
const
char
*
file_name
)
{
bool
writable
=
false
;
hb_memory_mode_t
mm
=
HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE
;
hb_mapped_file_t
*
file
=
(
hb_mapped_file_t
*
)
calloc
(
1
sizeof
(
hb_mapped_file_t
)
)
;
if
(
unlikely
(
!
file
)
)
return
hb_blob_get_empty
(
)
;
#
ifdef
HAVE_MMAP
int
fd
=
open
(
file_name
(
writable
?
O_RDWR
:
O_RDONLY
)
|
_O_BINARY
0
)
;
#
define
CLOSE
close
if
(
unlikely
(
fd
=
=
-
1
)
)
goto
fail_without_close
;
struct
stat
st
;
if
(
unlikely
(
fstat
(
fd
&
st
)
=
=
-
1
)
)
goto
fail
;
if
(
unlikely
(
st
.
st_size
=
=
0
&
&
S_ISREG
(
st
.
st_mode
)
)
)
goto
fail
;
file
-
>
length
=
(
unsigned
long
)
st
.
st_size
;
file
-
>
contents
=
(
char
*
)
mmap
(
nullptr
file
-
>
length
writable
?
PROT_READ
|
PROT_WRITE
:
PROT_READ
MAP_PRIVATE
|
MAP_NORESERVE
fd
0
)
;
if
(
unlikely
(
file
-
>
contents
=
=
MAP_FAILED
)
)
goto
fail
;
#
elif
defined
(
_WIN32
)
|
|
defined
(
__CYGWIN__
)
HANDLE
fd
=
CreateFile
(
file_name
writable
?
GENERIC_READ
|
GENERIC_WRITE
:
GENERIC_READ
FILE_SHARE_READ
nullptr
OPEN_EXISTING
FILE_ATTRIBUTE_NORMAL
|
FILE_FLAG_OVERLAPPED
nullptr
)
;
#
define
CLOSE
CloseHandle
if
(
unlikely
(
fd
=
=
INVALID_HANDLE_VALUE
)
)
goto
fail_without_close
;
file
-
>
length
=
(
unsigned
long
)
GetFileSize
(
fd
nullptr
)
;
file
-
>
mapping
=
CreateFileMapping
(
fd
nullptr
writable
?
PAGE_WRITECOPY
:
PAGE_READONLY
0
0
nullptr
)
;
if
(
unlikely
(
file
-
>
mapping
=
=
nullptr
)
)
goto
fail
;
file
-
>
contents
=
(
char
*
)
MapViewOfFile
(
file
-
>
mapping
writable
?
FILE_MAP_COPY
:
FILE_MAP_READ
0
0
0
)
;
if
(
unlikely
(
file
-
>
contents
=
=
nullptr
)
)
goto
fail
;
#
else
mm
=
HB_MEMORY_MODE_WRITABLE
;
FILE
*
fd
=
fopen
(
file_name
"
rb
"
)
;
#
define
CLOSE
fclose
if
(
unlikely
(
!
fd
)
)
goto
fail_without_close
;
fseek
(
fd
0
SEEK_END
)
;
file
-
>
length
=
ftell
(
fd
)
;
rewind
(
fd
)
;
file
-
>
contents
=
(
char
*
)
malloc
(
file
-
>
length
)
;
if
(
unlikely
(
!
file
-
>
contents
)
)
goto
fail
;
if
(
unlikely
(
fread
(
file
-
>
contents
1
file
-
>
length
fd
)
!
=
file
-
>
length
)
)
goto
fail
;
#
endif
CLOSE
(
fd
)
;
return
hb_blob_create
(
file
-
>
contents
file
-
>
length
mm
(
void
*
)
file
(
hb_destroy_func_t
)
_hb_mapped_file_destroy
)
;
fail
:
CLOSE
(
fd
)
;
#
undef
CLOSE
fail_without_close
:
free
(
file
)
;
return
hb_blob_get_empty
(
)
;
}
