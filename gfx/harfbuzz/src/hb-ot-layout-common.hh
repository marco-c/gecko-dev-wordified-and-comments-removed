#
ifndef
HB_OT_LAYOUT_COMMON_HH
#
define
HB_OT_LAYOUT_COMMON_HH
#
include
"
hb
.
hh
"
#
include
"
hb
-
ot
-
layout
.
hh
"
#
include
"
hb
-
open
-
type
.
hh
"
#
include
"
hb
-
set
.
hh
"
#
include
"
hb
-
bimap
.
hh
"
#
ifndef
HB_MAX_NESTING_LEVEL
#
define
HB_MAX_NESTING_LEVEL
6
#
endif
#
ifndef
HB_MAX_CONTEXT_LENGTH
#
define
HB_MAX_CONTEXT_LENGTH
64
#
endif
#
ifndef
HB_CLOSURE_MAX_STAGES
#
define
HB_CLOSURE_MAX_STAGES
32
#
endif
#
ifndef
HB_MAX_SCRIPTS
#
define
HB_MAX_SCRIPTS
500
#
endif
#
ifndef
HB_MAX_LANGSYS
#
define
HB_MAX_LANGSYS
2000
#
endif
namespace
OT
{
#
define
NOT_COVERED
(
(
unsigned
int
)
-
1
)
template
<
typename
Iterator
>
static
inline
void
Coverage_serialize
(
hb_serialize_context_t
*
c
Iterator
it
)
;
template
<
typename
Iterator
>
static
inline
void
ClassDef_serialize
(
hb_serialize_context_t
*
c
Iterator
it
)
;
static
void
ClassDef_remap_and_serialize
(
hb_serialize_context_t
*
c
const
hb_set_t
&
glyphset
const
hb_map_t
&
gid_klass_map
hb_sorted_vector_t
<
HBGlyphID
>
glyphs
hb_sorted_vector_t
<
unsigned
>
klasses
hb_map_t
*
klass_map
)
;
template
<
typename
OutputArray
>
struct
subset_offset_array_t
{
subset_offset_array_t
(
hb_subset_context_t
*
subset_context
OutputArray
&
out
const
void
*
src_base
const
void
*
dest_base
)
:
_subset_context
(
subset_context
)
_out
(
out
)
_src_base
(
src_base
)
_dest_base
(
dest_base
)
{
}
template
<
typename
T
>
bool
operator
(
)
(
T
&
&
offset
)
{
auto
*
o
=
_out
.
serialize_append
(
_subset_context
-
>
serializer
)
;
if
(
unlikely
(
!
o
)
)
return
false
;
auto
snap
=
_subset_context
-
>
serializer
-
>
snapshot
(
)
;
bool
ret
=
o
-
>
serialize_subset
(
_subset_context
offset
_src_base
_dest_base
)
;
if
(
!
ret
)
{
_out
.
pop
(
)
;
_subset_context
-
>
serializer
-
>
revert
(
snap
)
;
}
return
ret
;
}
private
:
hb_subset_context_t
*
_subset_context
;
OutputArray
&
_out
;
const
void
*
_src_base
;
const
void
*
_dest_base
;
}
;
struct
{
template
<
typename
OutputArray
>
subset_offset_array_t
<
OutputArray
>
operator
(
)
(
hb_subset_context_t
*
subset_context
OutputArray
&
out
const
void
*
src_base
const
void
*
dest_base
)
const
{
return
subset_offset_array_t
<
OutputArray
>
(
subset_context
out
src_base
dest_base
)
;
}
}
HB_FUNCOBJ
(
subset_offset_array
)
;
struct
Record_sanitize_closure_t
{
hb_tag_t
tag
;
const
void
*
list_base
;
}
;
struct
RecordList_subset_context_t
{
RecordList_subset_context_t
(
)
:
script_count
(
0
)
langsys_count
(
0
)
{
}
bool
visitScript
(
)
{
return
script_count
+
+
<
HB_MAX_SCRIPTS
;
}
bool
visitLangSys
(
)
{
return
langsys_count
+
+
<
HB_MAX_LANGSYS
;
}
private
:
unsigned
int
script_count
;
unsigned
int
langsys_count
;
}
;
template
<
typename
Type
>
struct
Record
{
int
cmp
(
hb_tag_t
a
)
const
{
return
tag
.
cmp
(
a
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
const
Record_sanitize_closure_t
closure
=
{
tag
base
}
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
offset
.
sanitize
(
c
base
&
closure
)
)
;
}
Tag
tag
;
OffsetTo
<
Type
>
offset
;
public
:
DEFINE_SIZE_STATIC
(
6
)
;
}
;
template
<
typename
Type
>
struct
RecordArrayOf
:
SortedArrayOf
<
Record
<
Type
>
>
{
const
OffsetTo
<
Type
>
&
get_offset
(
unsigned
int
i
)
const
{
return
(
*
this
)
[
i
]
.
offset
;
}
OffsetTo
<
Type
>
&
get_offset
(
unsigned
int
i
)
{
return
(
*
this
)
[
i
]
.
offset
;
}
const
Tag
&
get_tag
(
unsigned
int
i
)
const
{
return
(
*
this
)
[
i
]
.
tag
;
}
unsigned
int
get_tags
(
unsigned
int
start_offset
unsigned
int
*
record_count
hb_tag_t
*
record_tags
)
const
{
if
(
record_count
)
{
const
Record
<
Type
>
*
arr
=
this
-
>
sub_array
(
start_offset
record_count
)
;
unsigned
int
count
=
*
record_count
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
record_tags
[
i
]
=
arr
[
i
]
.
tag
;
}
return
this
-
>
len
;
}
bool
find_index
(
hb_tag_t
tag
unsigned
int
*
index
)
const
{
return
this
-
>
bfind
(
tag
index
HB_BFIND_NOT_FOUND_STORE
Index
:
:
NOT_FOUND_INDEX
)
;
}
}
;
template
<
typename
Type
>
struct
RecordListOf
:
RecordArrayOf
<
Type
>
{
const
Type
&
operator
[
]
(
unsigned
int
i
)
const
{
return
this
+
this
-
>
get_offset
(
i
)
;
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
auto
*
out
=
c
-
>
serializer
-
>
start_embed
(
*
this
)
;
if
(
unlikely
(
!
c
-
>
serializer
-
>
extend_min
(
out
)
)
)
return_trace
(
false
)
;
RecordList_subset_context_t
record_list_context
;
unsigned
int
count
=
this
-
>
len
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
auto
*
record
=
out
-
>
serialize_append
(
c
-
>
serializer
)
;
if
(
unlikely
(
!
record
)
)
return
false
;
auto
snap
=
c
-
>
serializer
-
>
snapshot
(
)
;
if
(
record
-
>
offset
.
serialize_subset
(
c
this
-
>
get_offset
(
i
)
this
out
&
record_list_context
)
)
{
record
-
>
tag
=
this
-
>
get_tag
(
i
)
;
continue
;
}
out
-
>
pop
(
)
;
c
-
>
serializer
-
>
revert
(
snap
)
;
}
return_trace
(
true
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
RecordArrayOf
<
Type
>
:
:
sanitize
(
c
this
)
)
;
}
}
;
struct
RangeRecord
{
int
cmp
(
hb_codepoint_t
g
)
const
{
return
g
<
start
?
-
1
:
g
<
=
end
?
0
:
+
1
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
bool
intersects
(
const
hb_set_t
*
glyphs
)
const
{
return
glyphs
-
>
intersects
(
start
end
)
;
}
template
<
typename
set_t
>
bool
add_coverage
(
set_t
*
glyphs
)
const
{
return
glyphs
-
>
add_range
(
start
end
)
;
}
HBGlyphID
start
;
HBGlyphID
end
;
HBUINT16
value
;
public
:
DEFINE_SIZE_STATIC
(
6
)
;
}
;
DECLARE_NULL_NAMESPACE_BYTES
(
OT
RangeRecord
)
;
struct
IndexArray
:
ArrayOf
<
Index
>
{
unsigned
int
get_indexes
(
unsigned
int
start_offset
unsigned
int
*
_count
unsigned
int
*
_indexes
)
const
{
if
(
_count
)
{
const
HBUINT16
*
arr
=
this
-
>
sub_array
(
start_offset
_count
)
;
unsigned
int
count
=
*
_count
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
_indexes
[
i
]
=
arr
[
i
]
;
}
return
this
-
>
len
;
}
void
add_indexes_to
(
hb_set_t
*
output
)
const
{
output
-
>
add_array
(
arrayZ
len
)
;
}
}
;
struct
Script
;
struct
LangSys
;
struct
Feature
;
struct
LangSys
{
unsigned
int
get_feature_count
(
)
const
{
return
featureIndex
.
len
;
}
hb_tag_t
get_feature_index
(
unsigned
int
i
)
const
{
return
featureIndex
[
i
]
;
}
unsigned
int
get_feature_indexes
(
unsigned
int
start_offset
unsigned
int
*
feature_count
unsigned
int
*
feature_indexes
)
const
{
return
featureIndex
.
get_indexes
(
start_offset
feature_count
feature_indexes
)
;
}
void
add_feature_indexes_to
(
hb_set_t
*
feature_indexes
)
const
{
featureIndex
.
add_indexes_to
(
feature_indexes
)
;
}
bool
has_required_feature
(
)
const
{
return
reqFeatureIndex
!
=
0xFFFFu
;
}
unsigned
int
get_required_feature_index
(
)
const
{
if
(
reqFeatureIndex
=
=
0xFFFFu
)
return
Index
:
:
NOT_FOUND_INDEX
;
return
reqFeatureIndex
;
}
LangSys
*
copy
(
hb_serialize_context_t
*
c
)
const
{
TRACE_SERIALIZE
(
this
)
;
return_trace
(
c
-
>
embed
(
*
this
)
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
const
Record_sanitize_closure_t
*
=
nullptr
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
featureIndex
.
sanitize
(
c
)
)
;
}
Offset16
lookupOrderZ
;
HBUINT16
reqFeatureIndex
;
IndexArray
featureIndex
;
public
:
DEFINE_SIZE_ARRAY_SIZED
(
6
featureIndex
)
;
}
;
DECLARE_NULL_NAMESPACE_BYTES
(
OT
LangSys
)
;
struct
Script
{
unsigned
int
get_lang_sys_count
(
)
const
{
return
langSys
.
len
;
}
const
Tag
&
get_lang_sys_tag
(
unsigned
int
i
)
const
{
return
langSys
.
get_tag
(
i
)
;
}
unsigned
int
get_lang_sys_tags
(
unsigned
int
start_offset
unsigned
int
*
lang_sys_count
hb_tag_t
*
lang_sys_tags
)
const
{
return
langSys
.
get_tags
(
start_offset
lang_sys_count
lang_sys_tags
)
;
}
const
LangSys
&
get_lang_sys
(
unsigned
int
i
)
const
{
if
(
i
=
=
Index
:
:
NOT_FOUND_INDEX
)
return
get_default_lang_sys
(
)
;
return
this
+
langSys
[
i
]
.
offset
;
}
bool
find_lang_sys_index
(
hb_tag_t
tag
unsigned
int
*
index
)
const
{
return
langSys
.
find_index
(
tag
index
)
;
}
bool
has_default_lang_sys
(
)
const
{
return
defaultLangSys
!
=
0
;
}
const
LangSys
&
get_default_lang_sys
(
)
const
{
return
this
+
defaultLangSys
;
}
bool
subset
(
hb_subset_context_t
*
c
RecordList_subset_context_t
*
record_list_context
)
const
{
TRACE_SUBSET
(
this
)
;
if
(
!
record_list_context
-
>
visitScript
(
)
)
return_trace
(
false
)
;
auto
*
out
=
c
-
>
serializer
-
>
start_embed
(
*
this
)
;
if
(
unlikely
(
!
c
-
>
serializer
-
>
extend_min
(
out
)
)
)
return_trace
(
false
)
;
out
-
>
defaultLangSys
.
serialize_copy
(
c
-
>
serializer
defaultLangSys
this
out
)
;
for
(
const
auto
&
src
:
langSys
)
{
if
(
!
record_list_context
-
>
visitLangSys
(
)
)
{
continue
;
}
auto
snap
=
c
-
>
serializer
-
>
snapshot
(
)
;
auto
*
lang_sys
=
c
-
>
serializer
-
>
embed
(
src
)
;
if
(
likely
(
lang_sys
)
&
&
lang_sys
-
>
offset
.
serialize_copy
(
c
-
>
serializer
src
.
offset
this
out
)
)
{
out
-
>
langSys
.
len
+
+
;
continue
;
}
c
-
>
serializer
-
>
revert
(
snap
)
;
}
return_trace
(
true
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
const
Record_sanitize_closure_t
*
=
nullptr
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
defaultLangSys
.
sanitize
(
c
this
)
&
&
langSys
.
sanitize
(
c
this
)
)
;
}
protected
:
OffsetTo
<
LangSys
>
defaultLangSys
;
RecordArrayOf
<
LangSys
>
langSys
;
public
:
DEFINE_SIZE_ARRAY_SIZED
(
4
langSys
)
;
}
;
typedef
RecordListOf
<
Script
>
ScriptList
;
struct
FeatureParamsSize
{
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
c
-
>
check_struct
(
this
)
)
)
return_trace
(
false
)
;
if
(
!
designSize
)
return_trace
(
false
)
;
else
if
(
subfamilyID
=
=
0
&
&
subfamilyNameID
=
=
0
&
&
rangeStart
=
=
0
&
&
rangeEnd
=
=
0
)
return_trace
(
true
)
;
else
if
(
designSize
<
rangeStart
|
|
designSize
>
rangeEnd
|
|
subfamilyNameID
<
256
|
|
subfamilyNameID
>
32767
)
return_trace
(
false
)
;
else
return_trace
(
true
)
;
}
HBUINT16
designSize
;
HBUINT16
subfamilyID
;
NameID
subfamilyNameID
;
HBUINT16
rangeStart
;
HBUINT16
rangeEnd
;
public
:
DEFINE_SIZE_STATIC
(
10
)
;
}
;
struct
FeatureParamsStylisticSet
{
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
HBUINT16
version
;
NameID
uiNameID
;
public
:
DEFINE_SIZE_STATIC
(
4
)
;
}
;
struct
FeatureParamsCharacterVariants
{
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
characters
.
sanitize
(
c
)
)
;
}
HBUINT16
format
;
NameID
featUILableNameID
;
NameID
featUITooltipTextNameID
;
NameID
sampleTextNameID
;
HBUINT16
numNamedParameters
;
NameID
firstParamUILabelNameID
;
ArrayOf
<
HBUINT24
>
characters
;
public
:
DEFINE_SIZE_ARRAY
(
14
characters
)
;
}
;
struct
FeatureParams
{
bool
sanitize
(
hb_sanitize_context_t
*
c
hb_tag_t
tag
)
const
{
#
ifdef
HB_NO_LAYOUT_FEATURE_PARAMS
return
true
;
#
endif
TRACE_SANITIZE
(
this
)
;
if
(
tag
=
=
HB_TAG
(
'
s
'
'
i
'
'
z
'
'
e
'
)
)
return_trace
(
u
.
size
.
sanitize
(
c
)
)
;
if
(
(
tag
&
0xFFFF0000u
)
=
=
HB_TAG
(
'
s
'
'
s
'
'
\
0
'
'
\
0
'
)
)
return_trace
(
u
.
stylisticSet
.
sanitize
(
c
)
)
;
if
(
(
tag
&
0xFFFF0000u
)
=
=
HB_TAG
(
'
c
'
'
v
'
'
\
0
'
'
\
0
'
)
)
return_trace
(
u
.
characterVariants
.
sanitize
(
c
)
)
;
return_trace
(
true
)
;
}
#
ifndef
HB_NO_LAYOUT_FEATURE_PARAMS
const
FeatureParamsSize
&
get_size_params
(
hb_tag_t
tag
)
const
{
if
(
tag
=
=
HB_TAG
(
'
s
'
'
i
'
'
z
'
'
e
'
)
)
return
u
.
size
;
return
Null
(
FeatureParamsSize
)
;
}
const
FeatureParamsStylisticSet
&
get_stylistic_set_params
(
hb_tag_t
tag
)
const
{
if
(
(
tag
&
0xFFFF0000u
)
=
=
HB_TAG
(
'
s
'
'
s
'
'
\
0
'
'
\
0
'
)
)
return
u
.
stylisticSet
;
return
Null
(
FeatureParamsStylisticSet
)
;
}
const
FeatureParamsCharacterVariants
&
get_character_variants_params
(
hb_tag_t
tag
)
const
{
if
(
(
tag
&
0xFFFF0000u
)
=
=
HB_TAG
(
'
c
'
'
v
'
'
\
0
'
'
\
0
'
)
)
return
u
.
characterVariants
;
return
Null
(
FeatureParamsCharacterVariants
)
;
}
#
endif
private
:
union
{
FeatureParamsSize
size
;
FeatureParamsStylisticSet
stylisticSet
;
FeatureParamsCharacterVariants
characterVariants
;
}
u
;
public
:
DEFINE_SIZE_MIN
(
0
)
;
}
;
struct
Feature
{
unsigned
int
get_lookup_count
(
)
const
{
return
lookupIndex
.
len
;
}
hb_tag_t
get_lookup_index
(
unsigned
int
i
)
const
{
return
lookupIndex
[
i
]
;
}
unsigned
int
get_lookup_indexes
(
unsigned
int
start_index
unsigned
int
*
lookup_count
unsigned
int
*
lookup_tags
)
const
{
return
lookupIndex
.
get_indexes
(
start_index
lookup_count
lookup_tags
)
;
}
void
add_lookup_indexes_to
(
hb_set_t
*
lookup_indexes
)
const
{
lookupIndex
.
add_indexes_to
(
lookup_indexes
)
;
}
const
FeatureParams
&
get_feature_params
(
)
const
{
return
this
+
featureParams
;
}
bool
subset
(
hb_subset_context_t
*
c
RecordList_subset_context_t
*
r
)
const
{
TRACE_SUBSET
(
this
)
;
auto
*
out
=
c
-
>
serializer
-
>
embed
(
*
this
)
;
if
(
unlikely
(
!
out
)
)
return_trace
(
false
)
;
out
-
>
featureParams
=
0
;
return_trace
(
true
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
const
Record_sanitize_closure_t
*
closure
=
nullptr
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
(
c
-
>
check_struct
(
this
)
&
&
lookupIndex
.
sanitize
(
c
)
)
)
)
return_trace
(
false
)
;
if
(
likely
(
featureParams
.
is_null
(
)
)
)
return_trace
(
true
)
;
unsigned
int
orig_offset
=
featureParams
;
if
(
unlikely
(
!
featureParams
.
sanitize
(
c
this
closure
?
closure
-
>
tag
:
HB_TAG_NONE
)
)
)
return_trace
(
false
)
;
if
(
featureParams
=
=
0
&
&
closure
&
&
closure
-
>
tag
=
=
HB_TAG
(
'
s
'
'
i
'
'
z
'
'
e
'
)
&
&
closure
-
>
list_base
&
&
closure
-
>
list_base
<
this
)
{
unsigned
int
new_offset_int
=
orig_offset
-
(
(
(
char
*
)
this
)
-
(
(
char
*
)
closure
-
>
list_base
)
)
;
OffsetTo
<
FeatureParams
>
new_offset
;
new_offset
=
new_offset_int
;
if
(
new_offset
=
=
new_offset_int
&
&
c
-
>
try_set
(
&
featureParams
new_offset_int
)
&
&
!
featureParams
.
sanitize
(
c
this
closure
?
closure
-
>
tag
:
HB_TAG_NONE
)
)
return_trace
(
false
)
;
}
return_trace
(
true
)
;
}
OffsetTo
<
FeatureParams
>
featureParams
;
IndexArray
lookupIndex
;
public
:
DEFINE_SIZE_ARRAY_SIZED
(
4
lookupIndex
)
;
}
;
typedef
RecordListOf
<
Feature
>
FeatureList
;
struct
LookupFlag
:
HBUINT16
{
enum
Flags
{
RightToLeft
=
0x0001u
IgnoreBaseGlyphs
=
0x0002u
IgnoreLigatures
=
0x0004u
IgnoreMarks
=
0x0008u
IgnoreFlags
=
0x000Eu
UseMarkFilteringSet
=
0x0010u
Reserved
=
0x00E0u
MarkAttachmentType
=
0xFF00u
}
;
public
:
DEFINE_SIZE_STATIC
(
2
)
;
}
;
}
HB_MARK_AS_FLAG_T
(
OT
:
:
LookupFlag
:
:
Flags
)
;
namespace
OT
{
struct
Lookup
{
unsigned
int
get_subtable_count
(
)
const
{
return
subTable
.
len
;
}
template
<
typename
TSubTable
>
const
OffsetArrayOf
<
TSubTable
>
&
get_subtables
(
)
const
{
return
CastR
<
OffsetArrayOf
<
TSubTable
>
>
(
subTable
)
;
}
template
<
typename
TSubTable
>
OffsetArrayOf
<
TSubTable
>
&
get_subtables
(
)
{
return
CastR
<
OffsetArrayOf
<
TSubTable
>
>
(
subTable
)
;
}
template
<
typename
TSubTable
>
const
TSubTable
&
get_subtable
(
unsigned
int
i
)
const
{
return
this
+
get_subtables
<
TSubTable
>
(
)
[
i
]
;
}
template
<
typename
TSubTable
>
TSubTable
&
get_subtable
(
unsigned
int
i
)
{
return
this
+
get_subtables
<
TSubTable
>
(
)
[
i
]
;
}
unsigned
int
get_size
(
)
const
{
const
HBUINT16
&
markFilteringSet
=
StructAfter
<
const
HBUINT16
>
(
subTable
)
;
if
(
lookupFlag
&
LookupFlag
:
:
UseMarkFilteringSet
)
return
(
const
char
*
)
&
StructAfter
<
const
char
>
(
markFilteringSet
)
-
(
const
char
*
)
this
;
return
(
const
char
*
)
&
markFilteringSet
-
(
const
char
*
)
this
;
}
unsigned
int
get_type
(
)
const
{
return
lookupType
;
}
uint32_t
get_props
(
)
const
{
unsigned
int
flag
=
lookupFlag
;
if
(
unlikely
(
flag
&
LookupFlag
:
:
UseMarkFilteringSet
)
)
{
const
HBUINT16
&
markFilteringSet
=
StructAfter
<
HBUINT16
>
(
subTable
)
;
flag
+
=
(
markFilteringSet
<
<
16
)
;
}
return
flag
;
}
template
<
typename
TSubTable
typename
context_t
typename
.
.
.
Ts
>
typename
context_t
:
:
return_t
dispatch
(
context_t
*
c
Ts
&
&
.
.
.
ds
)
const
{
unsigned
int
lookup_type
=
get_type
(
)
;
TRACE_DISPATCH
(
this
lookup_type
)
;
unsigned
int
count
=
get_subtable_count
(
)
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
typename
context_t
:
:
return_t
r
=
get_subtable
<
TSubTable
>
(
i
)
.
dispatch
(
c
lookup_type
hb_forward
<
Ts
>
(
ds
)
.
.
.
)
;
if
(
c
-
>
stop_sublookup_iteration
(
r
)
)
return_trace
(
r
)
;
}
return_trace
(
c
-
>
default_return_value
(
)
)
;
}
bool
serialize
(
hb_serialize_context_t
*
c
unsigned
int
lookup_type
uint32_t
lookup_props
unsigned
int
num_subtables
)
{
TRACE_SERIALIZE
(
this
)
;
if
(
unlikely
(
!
c
-
>
extend_min
(
*
this
)
)
)
return_trace
(
false
)
;
lookupType
=
lookup_type
;
lookupFlag
=
lookup_props
&
0xFFFFu
;
if
(
unlikely
(
!
subTable
.
serialize
(
c
num_subtables
)
)
)
return_trace
(
false
)
;
if
(
lookupFlag
&
LookupFlag
:
:
UseMarkFilteringSet
)
{
if
(
unlikely
(
!
c
-
>
extend
(
*
this
)
)
)
return_trace
(
false
)
;
HBUINT16
&
markFilteringSet
=
StructAfter
<
HBUINT16
>
(
subTable
)
;
markFilteringSet
=
lookup_props
>
>
16
;
}
return_trace
(
true
)
;
}
template
<
typename
TSubTable
>
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
auto
*
out
=
c
-
>
serializer
-
>
embed
(
*
this
)
;
if
(
unlikely
(
!
out
)
)
return_trace
(
false
)
;
const
OffsetArrayOf
<
TSubTable
>
&
subtables
=
get_subtables
<
TSubTable
>
(
)
;
OffsetArrayOf
<
TSubTable
>
&
out_subtables
=
out
-
>
get_subtables
<
TSubTable
>
(
)
;
unsigned
int
count
=
subTable
.
len
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
out_subtables
[
i
]
.
serialize_subset
(
c
subtables
[
i
]
this
out
get_type
(
)
)
;
return_trace
(
true
)
;
}
template
<
typename
TSubTable
>
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
!
(
c
-
>
check_struct
(
this
)
&
&
subTable
.
sanitize
(
c
)
)
)
return_trace
(
false
)
;
if
(
lookupFlag
&
LookupFlag
:
:
UseMarkFilteringSet
)
{
const
HBUINT16
&
markFilteringSet
=
StructAfter
<
HBUINT16
>
(
subTable
)
;
if
(
!
markFilteringSet
.
sanitize
(
c
)
)
return_trace
(
false
)
;
}
if
(
unlikely
(
!
get_subtables
<
TSubTable
>
(
)
.
sanitize
(
c
this
get_type
(
)
)
)
)
return_trace
(
false
)
;
if
(
unlikely
(
get_type
(
)
=
=
TSubTable
:
:
Extension
&
&
!
c
-
>
get_edit_count
(
)
)
)
{
unsigned
int
type
=
get_subtable
<
TSubTable
>
(
0
)
.
u
.
extension
.
get_type
(
)
;
unsigned
int
count
=
get_subtable_count
(
)
;
for
(
unsigned
int
i
=
1
;
i
<
count
;
i
+
+
)
if
(
get_subtable
<
TSubTable
>
(
i
)
.
u
.
extension
.
get_type
(
)
!
=
type
)
return_trace
(
false
)
;
}
return_trace
(
true
)
;
}
private
:
HBUINT16
lookupType
;
HBUINT16
lookupFlag
;
ArrayOf
<
Offset16
>
subTable
;
public
:
DEFINE_SIZE_ARRAY
(
6
subTable
)
;
}
;
typedef
OffsetListOf
<
Lookup
>
LookupList
;
struct
CoverageFormat1
{
friend
struct
Coverage
;
private
:
unsigned
int
get_coverage
(
hb_codepoint_t
glyph_id
)
const
{
unsigned
int
i
;
glyphArray
.
bfind
(
glyph_id
&
i
HB_BFIND_NOT_FOUND_STORE
NOT_COVERED
)
;
return
i
;
}
template
<
typename
Iterator
hb_requires
(
hb_is_sorted_source_of
(
Iterator
hb_codepoint_t
)
)
>
bool
serialize
(
hb_serialize_context_t
*
c
Iterator
glyphs
)
{
TRACE_SERIALIZE
(
this
)
;
return_trace
(
glyphArray
.
serialize
(
c
glyphs
)
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
glyphArray
.
sanitize
(
c
)
)
;
}
bool
intersects
(
const
hb_set_t
*
glyphs
)
const
{
unsigned
int
count
=
glyphArray
.
len
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
if
(
glyphs
-
>
has
(
glyphArray
[
i
]
)
)
return
true
;
return
false
;
}
bool
intersects_coverage
(
const
hb_set_t
*
glyphs
unsigned
int
index
)
const
{
return
glyphs
-
>
has
(
glyphArray
[
index
]
)
;
}
template
<
typename
set_t
>
bool
add_coverage
(
set_t
*
glyphs
)
const
{
return
glyphs
-
>
add_sorted_array
(
glyphArray
.
arrayZ
glyphArray
.
len
)
;
}
public
:
struct
iter_t
{
void
init
(
const
struct
CoverageFormat1
&
c_
)
{
c
=
&
c_
;
i
=
0
;
}
void
fini
(
)
{
}
bool
more
(
)
const
{
return
i
<
c
-
>
glyphArray
.
len
;
}
void
next
(
)
{
i
+
+
;
}
hb_codepoint_t
get_glyph
(
)
const
{
return
c
-
>
glyphArray
[
i
]
;
}
bool
operator
!
=
(
const
iter_t
&
o
)
const
{
return
i
!
=
o
.
i
|
|
c
!
=
o
.
c
;
}
private
:
const
struct
CoverageFormat1
*
c
;
unsigned
int
i
;
}
;
private
:
protected
:
HBUINT16
coverageFormat
;
SortedArrayOf
<
HBGlyphID
>
glyphArray
;
public
:
DEFINE_SIZE_ARRAY
(
4
glyphArray
)
;
}
;
struct
CoverageFormat2
{
friend
struct
Coverage
;
private
:
unsigned
int
get_coverage
(
hb_codepoint_t
glyph_id
)
const
{
const
RangeRecord
&
range
=
rangeRecord
.
bsearch
(
glyph_id
)
;
return
likely
(
range
.
start
<
=
range
.
end
)
?
(
unsigned
int
)
range
.
value
+
(
glyph_id
-
range
.
start
)
:
NOT_COVERED
;
}
template
<
typename
Iterator
hb_requires
(
hb_is_sorted_source_of
(
Iterator
hb_codepoint_t
)
)
>
bool
serialize
(
hb_serialize_context_t
*
c
Iterator
glyphs
)
{
TRACE_SERIALIZE
(
this
)
;
if
(
unlikely
(
!
c
-
>
extend_min
(
*
this
)
)
)
return_trace
(
false
)
;
if
(
unlikely
(
!
glyphs
)
)
{
rangeRecord
.
len
=
0
;
return_trace
(
true
)
;
}
unsigned
num_ranges
=
0
;
hb_codepoint_t
last
=
(
hb_codepoint_t
)
-
2
;
for
(
auto
g
:
glyphs
)
{
if
(
last
+
1
!
=
g
)
num_ranges
+
+
;
last
=
g
;
}
if
(
unlikely
(
!
rangeRecord
.
serialize
(
c
num_ranges
)
)
)
return_trace
(
false
)
;
unsigned
count
=
0
;
unsigned
range
=
(
unsigned
)
-
1
;
last
=
(
hb_codepoint_t
)
-
2
;
for
(
auto
g
:
glyphs
)
{
if
(
last
+
1
!
=
g
)
{
range
+
+
;
rangeRecord
[
range
]
.
start
=
g
;
rangeRecord
[
range
]
.
value
=
count
;
}
rangeRecord
[
range
]
.
end
=
g
;
last
=
g
;
count
+
+
;
}
return_trace
(
true
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
rangeRecord
.
sanitize
(
c
)
)
;
}
bool
intersects
(
const
hb_set_t
*
glyphs
)
const
{
unsigned
int
count
=
rangeRecord
.
len
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
if
(
rangeRecord
[
i
]
.
intersects
(
glyphs
)
)
return
true
;
return
false
;
}
bool
intersects_coverage
(
const
hb_set_t
*
glyphs
unsigned
int
index
)
const
{
unsigned
int
i
;
unsigned
int
count
=
rangeRecord
.
len
;
for
(
i
=
0
;
i
<
count
;
i
+
+
)
{
const
RangeRecord
&
range
=
rangeRecord
[
i
]
;
if
(
range
.
value
<
=
index
&
&
index
<
(
unsigned
int
)
range
.
value
+
(
range
.
end
-
range
.
start
)
&
&
range
.
intersects
(
glyphs
)
)
return
true
;
else
if
(
index
<
range
.
value
)
return
false
;
}
return
false
;
}
template
<
typename
set_t
>
bool
add_coverage
(
set_t
*
glyphs
)
const
{
unsigned
int
count
=
rangeRecord
.
len
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
if
(
unlikely
(
!
rangeRecord
[
i
]
.
add_coverage
(
glyphs
)
)
)
return
false
;
return
true
;
}
public
:
struct
iter_t
{
void
init
(
const
CoverageFormat2
&
c_
)
{
c
=
&
c_
;
coverage
=
0
;
i
=
0
;
j
=
c
-
>
rangeRecord
.
len
?
c
-
>
rangeRecord
[
0
]
.
start
:
0
;
if
(
unlikely
(
c
-
>
rangeRecord
[
0
]
.
start
>
c
-
>
rangeRecord
[
0
]
.
end
)
)
{
i
=
c
-
>
rangeRecord
.
len
;
}
}
void
fini
(
)
{
}
bool
more
(
)
const
{
return
i
<
c
-
>
rangeRecord
.
len
;
}
void
next
(
)
{
if
(
j
>
=
c
-
>
rangeRecord
[
i
]
.
end
)
{
i
+
+
;
if
(
more
(
)
)
{
unsigned
int
old
=
coverage
;
j
=
c
-
>
rangeRecord
[
i
]
.
start
;
coverage
=
c
-
>
rangeRecord
[
i
]
.
value
;
if
(
unlikely
(
coverage
!
=
old
+
1
)
)
{
i
=
c
-
>
rangeRecord
.
len
;
return
;
}
}
return
;
}
coverage
+
+
;
j
+
+
;
}
hb_codepoint_t
get_glyph
(
)
const
{
return
j
;
}
bool
operator
!
=
(
const
iter_t
&
o
)
const
{
return
i
!
=
o
.
i
|
|
j
!
=
o
.
j
|
|
c
!
=
o
.
c
;
}
private
:
const
struct
CoverageFormat2
*
c
;
unsigned
int
i
coverage
;
hb_codepoint_t
j
;
}
;
private
:
protected
:
HBUINT16
coverageFormat
;
SortedArrayOf
<
RangeRecord
>
rangeRecord
;
public
:
DEFINE_SIZE_ARRAY
(
4
rangeRecord
)
;
}
;
struct
Coverage
{
static
constexpr
unsigned
SENTINEL
=
NOT_COVERED
;
typedef
unsigned
int
value_t
;
value_t
operator
[
]
(
hb_codepoint_t
k
)
const
{
return
get
(
k
)
;
}
bool
has
(
hb_codepoint_t
k
)
const
{
return
(
*
this
)
[
k
]
!
=
SENTINEL
;
}
bool
operator
(
)
(
hb_codepoint_t
k
)
const
{
return
has
(
k
)
;
}
unsigned
int
get
(
hb_codepoint_t
k
)
const
{
return
get_coverage
(
k
)
;
}
unsigned
int
get_coverage
(
hb_codepoint_t
glyph_id
)
const
{
switch
(
u
.
format
)
{
case
1
:
return
u
.
format1
.
get_coverage
(
glyph_id
)
;
case
2
:
return
u
.
format2
.
get_coverage
(
glyph_id
)
;
default
:
return
NOT_COVERED
;
}
}
template
<
typename
Iterator
hb_requires
(
hb_is_sorted_source_of
(
Iterator
hb_codepoint_t
)
)
>
bool
serialize
(
hb_serialize_context_t
*
c
Iterator
glyphs
)
{
TRACE_SERIALIZE
(
this
)
;
if
(
unlikely
(
!
c
-
>
extend_min
(
*
this
)
)
)
return_trace
(
false
)
;
unsigned
count
=
0
;
unsigned
num_ranges
=
0
;
hb_codepoint_t
last
=
(
hb_codepoint_t
)
-
2
;
for
(
auto
g
:
glyphs
)
{
if
(
last
+
1
!
=
g
)
num_ranges
+
+
;
last
=
g
;
count
+
+
;
}
u
.
format
=
count
<
=
num_ranges
*
3
?
1
:
2
;
switch
(
u
.
format
)
{
case
1
:
return_trace
(
u
.
format1
.
serialize
(
c
glyphs
)
)
;
case
2
:
return_trace
(
u
.
format2
.
serialize
(
c
glyphs
)
)
;
default
:
return_trace
(
false
)
;
}
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
const
hb_set_t
&
glyphset
=
*
c
-
>
plan
-
>
glyphset
(
)
;
const
hb_map_t
&
glyph_map
=
*
c
-
>
plan
-
>
glyph_map
;
auto
it
=
+
iter
(
)
|
hb_filter
(
glyphset
)
|
hb_map_retains_sorting
(
glyph_map
)
;
bool
ret
=
bool
(
it
)
;
Coverage_serialize
(
c
-
>
serializer
it
)
;
return_trace
(
ret
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
!
u
.
format
.
sanitize
(
c
)
)
return_trace
(
false
)
;
switch
(
u
.
format
)
{
case
1
:
return_trace
(
u
.
format1
.
sanitize
(
c
)
)
;
case
2
:
return_trace
(
u
.
format2
.
sanitize
(
c
)
)
;
default
:
return_trace
(
true
)
;
}
}
bool
intersects
(
const
hb_set_t
*
glyphs
)
const
{
switch
(
u
.
format
)
{
case
1
:
return
u
.
format1
.
intersects
(
glyphs
)
;
case
2
:
return
u
.
format2
.
intersects
(
glyphs
)
;
default
:
return
false
;
}
}
bool
intersects_coverage
(
const
hb_set_t
*
glyphs
unsigned
int
index
)
const
{
switch
(
u
.
format
)
{
case
1
:
return
u
.
format1
.
intersects_coverage
(
glyphs
index
)
;
case
2
:
return
u
.
format2
.
intersects_coverage
(
glyphs
index
)
;
default
:
return
false
;
}
}
template
<
typename
set_t
>
bool
add_coverage
(
set_t
*
glyphs
)
const
{
switch
(
u
.
format
)
{
case
1
:
return
u
.
format1
.
add_coverage
(
glyphs
)
;
case
2
:
return
u
.
format2
.
add_coverage
(
glyphs
)
;
default
:
return
false
;
}
}
struct
iter_t
:
hb_iter_with_fallback_t
<
iter_t
hb_codepoint_t
>
{
static
constexpr
bool
is_sorted_iterator
=
true
;
iter_t
(
const
Coverage
&
c_
=
Null
(
Coverage
)
)
{
memset
(
this
0
sizeof
(
*
this
)
)
;
format
=
c_
.
u
.
format
;
switch
(
format
)
{
case
1
:
u
.
format1
.
init
(
c_
.
u
.
format1
)
;
return
;
case
2
:
u
.
format2
.
init
(
c_
.
u
.
format2
)
;
return
;
default
:
return
;
}
}
bool
__more__
(
)
const
{
switch
(
format
)
{
case
1
:
return
u
.
format1
.
more
(
)
;
case
2
:
return
u
.
format2
.
more
(
)
;
default
:
return
false
;
}
}
void
__next__
(
)
{
switch
(
format
)
{
case
1
:
u
.
format1
.
next
(
)
;
break
;
case
2
:
u
.
format2
.
next
(
)
;
break
;
default
:
break
;
}
}
typedef
hb_codepoint_t
__item_t__
;
__item_t__
__item__
(
)
const
{
return
get_glyph
(
)
;
}
hb_codepoint_t
get_glyph
(
)
const
{
switch
(
format
)
{
case
1
:
return
u
.
format1
.
get_glyph
(
)
;
case
2
:
return
u
.
format2
.
get_glyph
(
)
;
default
:
return
0
;
}
}
bool
operator
!
=
(
const
iter_t
&
o
)
const
{
if
(
format
!
=
o
.
format
)
return
true
;
switch
(
format
)
{
case
1
:
return
u
.
format1
!
=
o
.
u
.
format1
;
case
2
:
return
u
.
format2
!
=
o
.
u
.
format2
;
default
:
return
false
;
}
}
private
:
unsigned
int
format
;
union
{
CoverageFormat2
:
:
iter_t
format2
;
CoverageFormat1
:
:
iter_t
format1
;
}
u
;
}
;
iter_t
iter
(
)
const
{
return
iter_t
(
*
this
)
;
}
protected
:
union
{
HBUINT16
format
;
CoverageFormat1
format1
;
CoverageFormat2
format2
;
}
u
;
public
:
DEFINE_SIZE_UNION
(
2
format
)
;
}
;
template
<
typename
Iterator
>
static
inline
void
Coverage_serialize
(
hb_serialize_context_t
*
c
Iterator
it
)
{
c
-
>
start_embed
<
Coverage
>
(
)
-
>
serialize
(
c
it
)
;
}
static
void
ClassDef_remap_and_serialize
(
hb_serialize_context_t
*
c
const
hb_set_t
&
glyphset
const
hb_map_t
&
gid_klass_map
hb_sorted_vector_t
<
HBGlyphID
>
glyphs
hb_sorted_vector_t
<
unsigned
>
klasses
hb_map_t
*
klass_map
)
{
bool
has_no_match
=
glyphset
.
get_population
(
)
>
gid_klass_map
.
get_population
(
)
;
hb_map_t
m
;
if
(
!
klass_map
)
klass_map
=
&
m
;
if
(
has_no_match
)
klass_map
-
>
set
(
0
0
)
;
unsigned
idx
=
klass_map
-
>
has
(
0
)
?
1
:
0
;
for
(
const
unsigned
k
:
klasses
.
iter
(
)
)
{
if
(
klass_map
-
>
has
(
k
)
)
continue
;
klass_map
-
>
set
(
k
idx
)
;
idx
+
+
;
}
auto
it
=
+
glyphs
.
iter
(
)
|
hb_map_retains_sorting
(
[
&
]
(
const
HBGlyphID
&
gid
)
-
>
hb_pair_t
<
hb_codepoint_t
HBUINT16
>
{
HBUINT16
new_klass
;
new_klass
=
klass_map
-
>
get
(
gid_klass_map
[
gid
]
)
;
return
hb_pair
(
(
hb_codepoint_t
)
gid
new_klass
)
;
}
)
;
c
-
>
propagate_error
(
glyphs
klasses
)
;
ClassDef_serialize
(
c
it
)
;
}
struct
ClassDefFormat1
{
friend
struct
ClassDef
;
private
:
unsigned
int
get_class
(
hb_codepoint_t
glyph_id
)
const
{
return
classValue
[
(
unsigned
int
)
(
glyph_id
-
startGlyph
)
]
;
}
template
<
typename
Iterator
hb_requires
(
hb_is_iterator
(
Iterator
)
)
>
bool
serialize
(
hb_serialize_context_t
*
c
Iterator
it
)
{
TRACE_SERIALIZE
(
this
)
;
if
(
unlikely
(
!
c
-
>
extend_min
(
*
this
)
)
)
return_trace
(
false
)
;
if
(
unlikely
(
!
it
)
)
{
startGlyph
=
0
;
classValue
.
len
=
0
;
return_trace
(
true
)
;
}
startGlyph
=
(
*
it
)
.
first
;
classValue
.
serialize
(
c
+
it
|
hb_map
(
hb_second
)
)
;
return_trace
(
true
)
;
}
bool
subset
(
hb_subset_context_t
*
c
hb_map_t
*
klass_map
=
nullptr
)
const
{
TRACE_SUBSET
(
this
)
;
const
hb_set_t
&
glyphset
=
*
c
-
>
plan
-
>
glyphset
(
)
;
const
hb_map_t
&
glyph_map
=
*
c
-
>
plan
-
>
glyph_map
;
hb_sorted_vector_t
<
HBGlyphID
>
glyphs
;
hb_sorted_vector_t
<
unsigned
>
orig_klasses
;
hb_map_t
gid_org_klass_map
;
hb_codepoint_t
start
=
startGlyph
;
hb_codepoint_t
end
=
start
+
classValue
.
len
;
for
(
const
hb_codepoint_t
gid
:
+
hb_range
(
start
end
)
|
hb_filter
(
glyphset
)
)
{
unsigned
klass
=
classValue
[
gid
-
start
]
;
if
(
!
klass
)
continue
;
glyphs
.
push
(
glyph_map
[
gid
]
)
;
gid_org_klass_map
.
set
(
glyph_map
[
gid
]
klass
)
;
orig_klasses
.
push
(
klass
)
;
}
ClassDef_remap_and_serialize
(
c
-
>
serializer
glyphset
gid_org_klass_map
glyphs
orig_klasses
klass_map
)
;
return_trace
(
(
bool
)
glyphs
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
classValue
.
sanitize
(
c
)
)
;
}
template
<
typename
set_t
>
bool
add_coverage
(
set_t
*
glyphs
)
const
{
unsigned
int
start
=
0
;
unsigned
int
count
=
classValue
.
len
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
classValue
[
i
]
)
continue
;
if
(
start
!
=
i
)
if
(
unlikely
(
!
glyphs
-
>
add_range
(
startGlyph
+
start
startGlyph
+
i
)
)
)
return
false
;
start
=
i
+
1
;
}
if
(
start
!
=
count
)
if
(
unlikely
(
!
glyphs
-
>
add_range
(
startGlyph
+
start
startGlyph
+
count
)
)
)
return
false
;
return
true
;
}
template
<
typename
set_t
>
bool
add_class
(
set_t
*
glyphs
unsigned
int
klass
)
const
{
unsigned
int
count
=
classValue
.
len
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
if
(
classValue
[
i
]
=
=
klass
)
glyphs
-
>
add
(
startGlyph
+
i
)
;
return
true
;
}
bool
intersects
(
const
hb_set_t
*
glyphs
)
const
{
hb_codepoint_t
start
=
startGlyph
;
hb_codepoint_t
end
=
startGlyph
+
classValue
.
len
;
for
(
hb_codepoint_t
iter
=
startGlyph
-
1
;
hb_set_next
(
glyphs
&
iter
)
&
&
iter
<
end
;
)
if
(
classValue
[
iter
-
start
]
)
return
true
;
return
false
;
}
bool
intersects_class
(
const
hb_set_t
*
glyphs
unsigned
int
klass
)
const
{
unsigned
int
count
=
classValue
.
len
;
if
(
klass
=
=
0
)
{
hb_codepoint_t
g
=
HB_SET_VALUE_INVALID
;
if
(
!
hb_set_next
(
glyphs
&
g
)
)
return
false
;
if
(
g
<
startGlyph
)
return
true
;
g
=
startGlyph
+
count
-
1
;
if
(
hb_set_next
(
glyphs
&
g
)
)
return
true
;
}
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
if
(
classValue
[
i
]
=
=
klass
&
&
glyphs
-
>
has
(
startGlyph
+
i
)
)
return
true
;
return
false
;
}
protected
:
HBUINT16
classFormat
;
HBGlyphID
startGlyph
;
ArrayOf
<
HBUINT16
>
classValue
;
public
:
DEFINE_SIZE_ARRAY
(
6
classValue
)
;
}
;
struct
ClassDefFormat2
{
friend
struct
ClassDef
;
private
:
unsigned
int
get_class
(
hb_codepoint_t
glyph_id
)
const
{
return
rangeRecord
.
bsearch
(
glyph_id
)
.
value
;
}
template
<
typename
Iterator
hb_requires
(
hb_is_iterator
(
Iterator
)
)
>
bool
serialize
(
hb_serialize_context_t
*
c
Iterator
it
)
{
TRACE_SERIALIZE
(
this
)
;
if
(
unlikely
(
!
c
-
>
extend_min
(
*
this
)
)
)
return_trace
(
false
)
;
if
(
unlikely
(
!
it
)
)
{
rangeRecord
.
len
=
0
;
return_trace
(
true
)
;
}
unsigned
num_ranges
=
1
;
hb_codepoint_t
prev_gid
=
(
*
it
)
.
first
;
unsigned
prev_klass
=
(
*
it
)
.
second
;
RangeRecord
range_rec
;
range_rec
.
start
=
prev_gid
;
range_rec
.
end
=
prev_gid
;
range_rec
.
value
=
prev_klass
;
RangeRecord
*
record
=
c
-
>
copy
(
range_rec
)
;
if
(
unlikely
(
!
record
)
)
return_trace
(
false
)
;
for
(
const
auto
gid_klass_pair
:
+
(
+
+
it
)
)
{
hb_codepoint_t
cur_gid
=
gid_klass_pair
.
first
;
unsigned
cur_klass
=
gid_klass_pair
.
second
;
if
(
cur_gid
!
=
prev_gid
+
1
|
|
cur_klass
!
=
prev_klass
)
{
if
(
unlikely
(
!
record
)
)
break
;
record
-
>
end
=
prev_gid
;
num_ranges
+
+
;
range_rec
.
start
=
cur_gid
;
range_rec
.
end
=
cur_gid
;
range_rec
.
value
=
cur_klass
;
record
=
c
-
>
copy
(
range_rec
)
;
}
prev_klass
=
cur_klass
;
prev_gid
=
cur_gid
;
}
if
(
likely
(
record
)
)
record
-
>
end
=
prev_gid
;
rangeRecord
.
len
=
num_ranges
;
return_trace
(
true
)
;
}
bool
subset
(
hb_subset_context_t
*
c
hb_map_t
*
klass_map
=
nullptr
)
const
{
TRACE_SUBSET
(
this
)
;
const
hb_set_t
&
glyphset
=
*
c
-
>
plan
-
>
glyphset
(
)
;
const
hb_map_t
&
glyph_map
=
*
c
-
>
plan
-
>
glyph_map
;
hb_sorted_vector_t
<
HBGlyphID
>
glyphs
;
hb_sorted_vector_t
<
unsigned
>
orig_klasses
;
hb_map_t
gid_org_klass_map
;
unsigned
count
=
rangeRecord
.
len
;
for
(
unsigned
i
=
0
;
i
<
count
;
i
+
+
)
{
unsigned
klass
=
rangeRecord
[
i
]
.
value
;
if
(
!
klass
)
continue
;
hb_codepoint_t
start
=
rangeRecord
[
i
]
.
start
;
hb_codepoint_t
end
=
rangeRecord
[
i
]
.
end
+
1
;
for
(
hb_codepoint_t
g
=
start
;
g
<
end
;
g
+
+
)
{
if
(
!
glyphset
.
has
(
g
)
)
continue
;
glyphs
.
push
(
glyph_map
[
g
]
)
;
gid_org_klass_map
.
set
(
glyph_map
[
g
]
klass
)
;
orig_klasses
.
push
(
klass
)
;
}
}
ClassDef_remap_and_serialize
(
c
-
>
serializer
glyphset
gid_org_klass_map
glyphs
orig_klasses
klass_map
)
;
return_trace
(
(
bool
)
glyphs
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
rangeRecord
.
sanitize
(
c
)
)
;
}
template
<
typename
set_t
>
bool
add_coverage
(
set_t
*
glyphs
)
const
{
unsigned
int
count
=
rangeRecord
.
len
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
if
(
rangeRecord
[
i
]
.
value
)
if
(
unlikely
(
!
rangeRecord
[
i
]
.
add_coverage
(
glyphs
)
)
)
return
false
;
return
true
;
}
template
<
typename
set_t
>
bool
add_class
(
set_t
*
glyphs
unsigned
int
klass
)
const
{
unsigned
int
count
=
rangeRecord
.
len
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
rangeRecord
[
i
]
.
value
=
=
klass
)
if
(
unlikely
(
!
rangeRecord
[
i
]
.
add_coverage
(
glyphs
)
)
)
return
false
;
}
return
true
;
}
bool
intersects
(
const
hb_set_t
*
glyphs
)
const
{
unsigned
int
count
=
rangeRecord
.
len
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
if
(
rangeRecord
[
i
]
.
intersects
(
glyphs
)
)
return
true
;
return
false
;
}
bool
intersects_class
(
const
hb_set_t
*
glyphs
unsigned
int
klass
)
const
{
unsigned
int
count
=
rangeRecord
.
len
;
if
(
klass
=
=
0
)
{
hb_codepoint_t
g
=
HB_SET_VALUE_INVALID
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
!
hb_set_next
(
glyphs
&
g
)
)
break
;
if
(
g
<
rangeRecord
[
i
]
.
start
)
return
true
;
g
=
rangeRecord
[
i
]
.
end
;
}
if
(
g
!
=
HB_SET_VALUE_INVALID
&
&
hb_set_next
(
glyphs
&
g
)
)
return
true
;
}
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
if
(
rangeRecord
[
i
]
.
value
=
=
klass
&
&
rangeRecord
[
i
]
.
intersects
(
glyphs
)
)
return
true
;
return
false
;
}
protected
:
HBUINT16
classFormat
;
SortedArrayOf
<
RangeRecord
>
rangeRecord
;
public
:
DEFINE_SIZE_ARRAY
(
4
rangeRecord
)
;
}
;
struct
ClassDef
{
static
constexpr
unsigned
SENTINEL
=
0
;
typedef
unsigned
int
value_t
;
value_t
operator
[
]
(
hb_codepoint_t
k
)
const
{
return
get
(
k
)
;
}
bool
has
(
hb_codepoint_t
k
)
const
{
return
(
*
this
)
[
k
]
!
=
SENTINEL
;
}
hb_codepoint_t
operator
(
)
(
hb_codepoint_t
k
)
const
{
return
get
(
k
)
;
}
unsigned
int
get
(
hb_codepoint_t
k
)
const
{
return
get_class
(
k
)
;
}
unsigned
int
get_class
(
hb_codepoint_t
glyph_id
)
const
{
switch
(
u
.
format
)
{
case
1
:
return
u
.
format1
.
get_class
(
glyph_id
)
;
case
2
:
return
u
.
format2
.
get_class
(
glyph_id
)
;
default
:
return
0
;
}
}
template
<
typename
Iterator
hb_requires
(
hb_is_iterator
(
Iterator
)
)
>
bool
serialize
(
hb_serialize_context_t
*
c
Iterator
it
)
{
TRACE_SERIALIZE
(
this
)
;
if
(
unlikely
(
!
c
-
>
extend_min
(
*
this
)
)
)
return_trace
(
false
)
;
unsigned
format
=
2
;
if
(
likely
(
it
)
)
{
hb_codepoint_t
glyph_min
=
(
*
it
)
.
first
;
hb_codepoint_t
glyph_max
=
+
it
|
hb_map
(
hb_first
)
|
hb_reduce
(
hb_max
0u
)
;
unsigned
num_ranges
=
1
;
hb_codepoint_t
prev_gid
=
glyph_min
;
unsigned
prev_klass
=
(
*
it
)
.
second
;
for
(
const
auto
gid_klass_pair
:
it
)
{
hb_codepoint_t
cur_gid
=
gid_klass_pair
.
first
;
unsigned
cur_klass
=
gid_klass_pair
.
second
;
if
(
cur_gid
!
=
prev_gid
+
1
|
|
cur_klass
!
=
prev_klass
)
num_ranges
+
+
;
prev_gid
=
cur_gid
;
prev_klass
=
cur_klass
;
}
if
(
1
+
(
glyph_max
-
glyph_min
+
1
)
<
num_ranges
*
3
)
format
=
1
;
}
u
.
format
=
format
;
switch
(
u
.
format
)
{
case
1
:
return_trace
(
u
.
format1
.
serialize
(
c
it
)
)
;
case
2
:
return_trace
(
u
.
format2
.
serialize
(
c
it
)
)
;
default
:
return_trace
(
false
)
;
}
}
bool
subset
(
hb_subset_context_t
*
c
hb_map_t
*
klass_map
=
nullptr
)
const
{
TRACE_SUBSET
(
this
)
;
switch
(
u
.
format
)
{
case
1
:
return_trace
(
u
.
format1
.
subset
(
c
klass_map
)
)
;
case
2
:
return_trace
(
u
.
format2
.
subset
(
c
klass_map
)
)
;
default
:
return_trace
(
false
)
;
}
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
!
u
.
format
.
sanitize
(
c
)
)
return_trace
(
false
)
;
switch
(
u
.
format
)
{
case
1
:
return_trace
(
u
.
format1
.
sanitize
(
c
)
)
;
case
2
:
return_trace
(
u
.
format2
.
sanitize
(
c
)
)
;
default
:
return_trace
(
true
)
;
}
}
template
<
typename
set_t
>
bool
add_coverage
(
set_t
*
glyphs
)
const
{
switch
(
u
.
format
)
{
case
1
:
return
u
.
format1
.
add_coverage
(
glyphs
)
;
case
2
:
return
u
.
format2
.
add_coverage
(
glyphs
)
;
default
:
return
false
;
}
}
template
<
typename
set_t
>
bool
add_class
(
set_t
*
glyphs
unsigned
int
klass
)
const
{
switch
(
u
.
format
)
{
case
1
:
return
u
.
format1
.
add_class
(
glyphs
klass
)
;
case
2
:
return
u
.
format2
.
add_class
(
glyphs
klass
)
;
default
:
return
false
;
}
}
bool
intersects
(
const
hb_set_t
*
glyphs
)
const
{
switch
(
u
.
format
)
{
case
1
:
return
u
.
format1
.
intersects
(
glyphs
)
;
case
2
:
return
u
.
format2
.
intersects
(
glyphs
)
;
default
:
return
false
;
}
}
bool
intersects_class
(
const
hb_set_t
*
glyphs
unsigned
int
klass
)
const
{
switch
(
u
.
format
)
{
case
1
:
return
u
.
format1
.
intersects_class
(
glyphs
klass
)
;
case
2
:
return
u
.
format2
.
intersects_class
(
glyphs
klass
)
;
default
:
return
false
;
}
}
protected
:
union
{
HBUINT16
format
;
ClassDefFormat1
format1
;
ClassDefFormat2
format2
;
}
u
;
public
:
DEFINE_SIZE_UNION
(
2
format
)
;
}
;
template
<
typename
Iterator
>
static
inline
void
ClassDef_serialize
(
hb_serialize_context_t
*
c
Iterator
it
)
{
c
-
>
start_embed
<
ClassDef
>
(
)
-
>
serialize
(
c
it
)
;
}
struct
VarRegionAxis
{
float
evaluate
(
int
coord
)
const
{
int
start
=
startCoord
peak
=
peakCoord
end
=
endCoord
;
if
(
unlikely
(
start
>
peak
|
|
peak
>
end
)
)
return
1
.
;
if
(
unlikely
(
start
<
0
&
&
end
>
0
&
&
peak
!
=
0
)
)
return
1
.
;
if
(
peak
=
=
0
|
|
coord
=
=
peak
)
return
1
.
;
if
(
coord
<
=
start
|
|
end
<
=
coord
)
return
0
.
;
if
(
coord
<
peak
)
return
float
(
coord
-
start
)
/
(
peak
-
start
)
;
else
return
float
(
end
-
coord
)
/
(
end
-
peak
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
public
:
F2DOT14
startCoord
;
F2DOT14
peakCoord
;
F2DOT14
endCoord
;
public
:
DEFINE_SIZE_STATIC
(
6
)
;
}
;
struct
VarRegionList
{
float
evaluate
(
unsigned
int
region_index
const
int
*
coords
unsigned
int
coord_len
)
const
{
if
(
unlikely
(
region_index
>
=
regionCount
)
)
return
0
.
;
const
VarRegionAxis
*
axes
=
axesZ
.
arrayZ
+
(
region_index
*
axisCount
)
;
float
v
=
1
.
;
unsigned
int
count
=
axisCount
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
int
coord
=
i
<
coord_len
?
coords
[
i
]
:
0
;
float
factor
=
axes
[
i
]
.
evaluate
(
coord
)
;
if
(
factor
=
=
0
.
f
)
return
0
.
;
v
*
=
factor
;
}
return
v
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
axesZ
.
sanitize
(
c
(
unsigned
int
)
axisCount
*
(
unsigned
int
)
regionCount
)
)
;
}
bool
serialize
(
hb_serialize_context_t
*
c
const
VarRegionList
*
src
const
hb_bimap_t
&
region_map
)
{
TRACE_SERIALIZE
(
this
)
;
VarRegionList
*
out
=
c
-
>
allocate_min
<
VarRegionList
>
(
)
;
if
(
unlikely
(
!
out
)
)
return_trace
(
false
)
;
axisCount
=
src
-
>
axisCount
;
regionCount
=
region_map
.
get_population
(
)
;
if
(
unlikely
(
!
c
-
>
allocate_size
<
VarRegionList
>
(
get_size
(
)
-
min_size
)
)
)
return_trace
(
false
)
;
for
(
unsigned
int
r
=
0
;
r
<
regionCount
;
r
+
+
)
memcpy
(
&
axesZ
[
axisCount
*
r
]
&
src
-
>
axesZ
[
axisCount
*
region_map
.
backward
(
r
)
]
VarRegionAxis
:
:
static_size
*
axisCount
)
;
return_trace
(
true
)
;
}
unsigned
int
get_size
(
)
const
{
return
min_size
+
VarRegionAxis
:
:
static_size
*
axisCount
*
regionCount
;
}
unsigned
int
get_region_count
(
)
const
{
return
regionCount
;
}
protected
:
HBUINT16
axisCount
;
HBUINT16
regionCount
;
UnsizedArrayOf
<
VarRegionAxis
>
axesZ
;
public
:
DEFINE_SIZE_ARRAY
(
4
axesZ
)
;
}
;
struct
VarData
{
unsigned
int
get_region_index_count
(
)
const
{
return
regionIndices
.
len
;
}
unsigned
int
get_row_size
(
)
const
{
return
shortCount
+
regionIndices
.
len
;
}
unsigned
int
get_size
(
)
const
{
return
itemCount
*
get_row_size
(
)
;
}
float
get_delta
(
unsigned
int
inner
const
int
*
coords
unsigned
int
coord_count
const
VarRegionList
&
regions
)
const
{
if
(
unlikely
(
inner
>
=
itemCount
)
)
return
0
.
;
unsigned
int
count
=
regionIndices
.
len
;
unsigned
int
scount
=
shortCount
;
const
HBUINT8
*
bytes
=
get_delta_bytes
(
)
;
const
HBUINT8
*
row
=
bytes
+
inner
*
(
scount
+
count
)
;
float
delta
=
0
.
;
unsigned
int
i
=
0
;
const
HBINT16
*
scursor
=
reinterpret_cast
<
const
HBINT16
*
>
(
row
)
;
for
(
;
i
<
scount
;
i
+
+
)
{
float
scalar
=
regions
.
evaluate
(
regionIndices
.
arrayZ
[
i
]
coords
coord_count
)
;
delta
+
=
scalar
*
*
scursor
+
+
;
}
const
HBINT8
*
bcursor
=
reinterpret_cast
<
const
HBINT8
*
>
(
scursor
)
;
for
(
;
i
<
count
;
i
+
+
)
{
float
scalar
=
regions
.
evaluate
(
regionIndices
.
arrayZ
[
i
]
coords
coord_count
)
;
delta
+
=
scalar
*
*
bcursor
+
+
;
}
return
delta
;
}
void
get_scalars
(
int
*
coords
unsigned
int
coord_count
const
VarRegionList
&
regions
float
*
scalars
unsigned
int
num_scalars
)
const
{
unsigned
count
=
hb_min
(
num_scalars
regionIndices
.
len
)
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
scalars
[
i
]
=
regions
.
evaluate
(
regionIndices
.
arrayZ
[
i
]
coords
coord_count
)
;
for
(
unsigned
int
i
=
count
;
i
<
num_scalars
;
i
+
+
)
scalars
[
i
]
=
0
.
f
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
regionIndices
.
sanitize
(
c
)
&
&
shortCount
<
=
regionIndices
.
len
&
&
c
-
>
check_range
(
get_delta_bytes
(
)
itemCount
get_row_size
(
)
)
)
;
}
bool
serialize
(
hb_serialize_context_t
*
c
const
VarData
*
src
const
hb_inc_bimap_t
&
inner_map
const
hb_bimap_t
&
region_map
)
{
TRACE_SERIALIZE
(
this
)
;
if
(
unlikely
(
!
c
-
>
extend_min
(
*
this
)
)
)
return_trace
(
false
)
;
itemCount
=
inner_map
.
get_next_value
(
)
;
unsigned
short
ri_count
=
src
-
>
regionIndices
.
len
;
enum
delta_size_t
{
kZero
=
0
kByte
kShort
}
;
hb_vector_t
<
delta_size_t
>
delta_sz
;
hb_vector_t
<
unsigned
int
>
ri_map
;
delta_sz
.
resize
(
ri_count
)
;
ri_map
.
resize
(
ri_count
)
;
unsigned
int
new_short_count
=
0
;
unsigned
int
r
;
for
(
r
=
0
;
r
<
ri_count
;
r
+
+
)
{
delta_sz
[
r
]
=
kZero
;
for
(
unsigned
int
i
=
0
;
i
<
inner_map
.
get_next_value
(
)
;
i
+
+
)
{
unsigned
int
old
=
inner_map
.
backward
(
i
)
;
int16_t
delta
=
src
-
>
get_item_delta
(
old
r
)
;
if
(
delta
<
-
128
|
|
127
<
delta
)
{
delta_sz
[
r
]
=
kShort
;
new_short_count
+
+
;
break
;
}
else
if
(
delta
!
=
0
)
delta_sz
[
r
]
=
kByte
;
}
}
unsigned
int
short_index
=
0
;
unsigned
int
byte_index
=
new_short_count
;
unsigned
int
new_ri_count
=
0
;
for
(
r
=
0
;
r
<
ri_count
;
r
+
+
)
if
(
delta_sz
[
r
]
)
{
ri_map
[
r
]
=
(
delta_sz
[
r
]
=
=
kShort
)
?
short_index
+
+
:
byte_index
+
+
;
new_ri_count
+
+
;
}
shortCount
=
new_short_count
;
regionIndices
.
len
=
new_ri_count
;
unsigned
int
size
=
regionIndices
.
get_size
(
)
-
HBUINT16
:
:
static_size
+
(
get_row_size
(
)
*
itemCount
)
;
if
(
unlikely
(
!
c
-
>
allocate_size
<
HBUINT8
>
(
size
)
)
)
return_trace
(
false
)
;
for
(
r
=
0
;
r
<
ri_count
;
r
+
+
)
if
(
delta_sz
[
r
]
)
regionIndices
[
ri_map
[
r
]
]
=
region_map
[
src
-
>
regionIndices
[
r
]
]
;
for
(
unsigned
int
i
=
0
;
i
<
itemCount
;
i
+
+
)
{
unsigned
int
old
=
inner_map
.
backward
(
i
)
;
for
(
unsigned
int
r
=
0
;
r
<
ri_count
;
r
+
+
)
if
(
delta_sz
[
r
]
)
set_item_delta
(
i
ri_map
[
r
]
src
-
>
get_item_delta
(
old
r
)
)
;
}
return_trace
(
true
)
;
}
void
collect_region_refs
(
hb_inc_bimap_t
&
region_map
const
hb_inc_bimap_t
&
inner_map
)
const
{
for
(
unsigned
int
r
=
0
;
r
<
regionIndices
.
len
;
r
+
+
)
{
unsigned
int
region
=
regionIndices
[
r
]
;
if
(
region_map
.
has
(
region
)
)
continue
;
for
(
unsigned
int
i
=
0
;
i
<
inner_map
.
get_next_value
(
)
;
i
+
+
)
if
(
get_item_delta
(
inner_map
.
backward
(
i
)
r
)
!
=
0
)
{
region_map
.
add
(
region
)
;
break
;
}
}
}
protected
:
const
HBUINT8
*
get_delta_bytes
(
)
const
{
return
&
StructAfter
<
HBUINT8
>
(
regionIndices
)
;
}
HBUINT8
*
get_delta_bytes
(
)
{
return
&
StructAfter
<
HBUINT8
>
(
regionIndices
)
;
}
int16_t
get_item_delta
(
unsigned
int
item
unsigned
int
region
)
const
{
if
(
item
>
=
itemCount
|
|
unlikely
(
region
>
=
regionIndices
.
len
)
)
return
0
;
const
HBINT8
*
p
=
(
const
HBINT8
*
)
get_delta_bytes
(
)
+
item
*
get_row_size
(
)
;
if
(
region
<
shortCount
)
return
(
(
const
HBINT16
*
)
p
)
[
region
]
;
else
return
(
p
+
HBINT16
:
:
static_size
*
shortCount
)
[
region
-
shortCount
]
;
}
void
set_item_delta
(
unsigned
int
item
unsigned
int
region
int16_t
delta
)
{
HBINT8
*
p
=
(
HBINT8
*
)
get_delta_bytes
(
)
+
item
*
get_row_size
(
)
;
if
(
region
<
shortCount
)
(
(
HBINT16
*
)
p
)
[
region
]
=
delta
;
else
(
p
+
HBINT16
:
:
static_size
*
shortCount
)
[
region
-
shortCount
]
=
delta
;
}
protected
:
HBUINT16
itemCount
;
HBUINT16
shortCount
;
ArrayOf
<
HBUINT16
>
regionIndices
;
public
:
DEFINE_SIZE_ARRAY
(
6
regionIndices
)
;
}
;
struct
VariationStore
{
float
get_delta
(
unsigned
int
outer
unsigned
int
inner
const
int
*
coords
unsigned
int
coord_count
)
const
{
#
ifdef
HB_NO_VAR
return
0
.
f
;
#
endif
if
(
unlikely
(
outer
>
=
dataSets
.
len
)
)
return
0
.
f
;
return
(
this
+
dataSets
[
outer
]
)
.
get_delta
(
inner
coords
coord_count
this
+
regions
)
;
}
float
get_delta
(
unsigned
int
index
const
int
*
coords
unsigned
int
coord_count
)
const
{
unsigned
int
outer
=
index
>
>
16
;
unsigned
int
inner
=
index
&
0xFFFF
;
return
get_delta
(
outer
inner
coords
coord_count
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
#
ifdef
HB_NO_VAR
return
true
;
#
endif
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
format
=
=
1
&
&
regions
.
sanitize
(
c
this
)
&
&
dataSets
.
sanitize
(
c
this
)
)
;
}
bool
serialize
(
hb_serialize_context_t
*
c
const
VariationStore
*
src
const
hb_array_t
<
hb_inc_bimap_t
>
&
inner_maps
)
{
TRACE_SERIALIZE
(
this
)
;
unsigned
int
set_count
=
0
;
for
(
unsigned
int
i
=
0
;
i
<
inner_maps
.
length
;
i
+
+
)
if
(
inner_maps
[
i
]
.
get_population
(
)
>
0
)
set_count
+
+
;
unsigned
int
size
=
min_size
+
HBUINT32
:
:
static_size
*
set_count
;
if
(
unlikely
(
!
c
-
>
allocate_size
<
HBUINT32
>
(
size
)
)
)
return_trace
(
false
)
;
format
=
1
;
hb_inc_bimap_t
region_map
;
for
(
unsigned
int
i
=
0
;
i
<
inner_maps
.
length
;
i
+
+
)
(
src
+
src
-
>
dataSets
[
i
]
)
.
collect_region_refs
(
region_map
inner_maps
[
i
]
)
;
region_map
.
sort
(
)
;
if
(
unlikely
(
!
regions
.
serialize
(
c
this
)
.
serialize
(
c
&
(
src
+
src
-
>
regions
)
region_map
)
)
)
return_trace
(
false
)
;
dataSets
.
len
=
set_count
;
unsigned
int
set_index
=
0
;
for
(
unsigned
int
i
=
0
;
i
<
inner_maps
.
length
;
i
+
+
)
{
if
(
inner_maps
[
i
]
.
get_population
(
)
=
=
0
)
continue
;
if
(
unlikely
(
!
dataSets
[
set_index
+
+
]
.
serialize
(
c
this
)
.
serialize
(
c
&
(
src
+
src
-
>
dataSets
[
i
]
)
inner_maps
[
i
]
region_map
)
)
)
return_trace
(
false
)
;
}
return_trace
(
true
)
;
}
unsigned
int
get_region_index_count
(
unsigned
int
ivs
)
const
{
return
(
this
+
dataSets
[
ivs
]
)
.
get_region_index_count
(
)
;
}
void
get_scalars
(
unsigned
int
ivs
int
*
coords
unsigned
int
coord_count
float
*
scalars
unsigned
int
num_scalars
)
const
{
#
ifdef
HB_NO_VAR
for
(
unsigned
i
=
0
;
i
<
num_scalars
;
i
+
+
)
scalars
[
i
]
=
0
.
f
;
return
;
#
endif
(
this
+
dataSets
[
ivs
]
)
.
get_scalars
(
coords
coord_count
this
+
regions
&
scalars
[
0
]
num_scalars
)
;
}
unsigned
int
get_sub_table_count
(
)
const
{
return
dataSets
.
len
;
}
protected
:
HBUINT16
format
;
LOffsetTo
<
VarRegionList
>
regions
;
LOffsetArrayOf
<
VarData
>
dataSets
;
public
:
DEFINE_SIZE_ARRAY
(
8
dataSets
)
;
}
;
struct
ConditionFormat1
{
friend
struct
Condition
;
private
:
bool
evaluate
(
const
int
*
coords
unsigned
int
coord_len
)
const
{
int
coord
=
axisIndex
<
coord_len
?
coords
[
axisIndex
]
:
0
;
return
filterRangeMinValue
<
=
coord
&
&
coord
<
=
filterRangeMaxValue
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
protected
:
HBUINT16
format
;
HBUINT16
axisIndex
;
F2DOT14
filterRangeMinValue
;
F2DOT14
filterRangeMaxValue
;
public
:
DEFINE_SIZE_STATIC
(
8
)
;
}
;
struct
Condition
{
bool
evaluate
(
const
int
*
coords
unsigned
int
coord_len
)
const
{
switch
(
u
.
format
)
{
case
1
:
return
u
.
format1
.
evaluate
(
coords
coord_len
)
;
default
:
return
false
;
}
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
!
u
.
format
.
sanitize
(
c
)
)
return_trace
(
false
)
;
switch
(
u
.
format
)
{
case
1
:
return_trace
(
u
.
format1
.
sanitize
(
c
)
)
;
default
:
return_trace
(
true
)
;
}
}
protected
:
union
{
HBUINT16
format
;
ConditionFormat1
format1
;
}
u
;
public
:
DEFINE_SIZE_UNION
(
2
format
)
;
}
;
struct
ConditionSet
{
bool
evaluate
(
const
int
*
coords
unsigned
int
coord_len
)
const
{
unsigned
int
count
=
conditions
.
len
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
if
(
!
(
this
+
conditions
.
arrayZ
[
i
]
)
.
evaluate
(
coords
coord_len
)
)
return
false
;
return
true
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
conditions
.
sanitize
(
c
this
)
)
;
}
protected
:
LOffsetArrayOf
<
Condition
>
conditions
;
public
:
DEFINE_SIZE_ARRAY
(
2
conditions
)
;
}
;
struct
FeatureTableSubstitutionRecord
{
friend
struct
FeatureTableSubstitution
;
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
feature
.
sanitize
(
c
base
)
)
;
}
protected
:
HBUINT16
featureIndex
;
LOffsetTo
<
Feature
>
feature
;
public
:
DEFINE_SIZE_STATIC
(
6
)
;
}
;
struct
FeatureTableSubstitution
{
const
Feature
*
find_substitute
(
unsigned
int
feature_index
)
const
{
unsigned
int
count
=
substitutions
.
len
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
const
FeatureTableSubstitutionRecord
&
record
=
substitutions
.
arrayZ
[
i
]
;
if
(
record
.
featureIndex
=
=
feature_index
)
return
&
(
this
+
record
.
feature
)
;
}
return
nullptr
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
version
.
sanitize
(
c
)
&
&
likely
(
version
.
major
=
=
1
)
&
&
substitutions
.
sanitize
(
c
this
)
)
;
}
protected
:
FixedVersion
<
>
version
;
ArrayOf
<
FeatureTableSubstitutionRecord
>
substitutions
;
public
:
DEFINE_SIZE_ARRAY
(
6
substitutions
)
;
}
;
struct
FeatureVariationRecord
{
friend
struct
FeatureVariations
;
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
conditions
.
sanitize
(
c
base
)
&
&
substitutions
.
sanitize
(
c
base
)
)
;
}
protected
:
LOffsetTo
<
ConditionSet
>
conditions
;
LOffsetTo
<
FeatureTableSubstitution
>
substitutions
;
public
:
DEFINE_SIZE_STATIC
(
8
)
;
}
;
struct
FeatureVariations
{
static
constexpr
unsigned
NOT_FOUND_INDEX
=
0xFFFFFFFFu
;
bool
find_index
(
const
int
*
coords
unsigned
int
coord_len
unsigned
int
*
index
)
const
{
unsigned
int
count
=
varRecords
.
len
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
const
FeatureVariationRecord
&
record
=
varRecords
.
arrayZ
[
i
]
;
if
(
(
this
+
record
.
conditions
)
.
evaluate
(
coords
coord_len
)
)
{
*
index
=
i
;
return
true
;
}
}
*
index
=
NOT_FOUND_INDEX
;
return
false
;
}
const
Feature
*
find_substitute
(
unsigned
int
variations_index
unsigned
int
feature_index
)
const
{
const
FeatureVariationRecord
&
record
=
varRecords
[
variations_index
]
;
return
(
this
+
record
.
substitutions
)
.
find_substitute
(
feature_index
)
;
}
FeatureVariations
*
copy
(
hb_serialize_context_t
*
c
)
const
{
TRACE_SERIALIZE
(
this
)
;
return_trace
(
c
-
>
embed
(
*
this
)
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
version
.
sanitize
(
c
)
&
&
likely
(
version
.
major
=
=
1
)
&
&
varRecords
.
sanitize
(
c
this
)
)
;
}
protected
:
FixedVersion
<
>
version
;
LArrayOf
<
FeatureVariationRecord
>
varRecords
;
public
:
DEFINE_SIZE_ARRAY_SIZED
(
8
varRecords
)
;
}
;
struct
HintingDevice
{
friend
struct
Device
;
private
:
hb_position_t
get_x_delta
(
hb_font_t
*
font
)
const
{
return
get_delta
(
font
-
>
x_ppem
font
-
>
x_scale
)
;
}
hb_position_t
get_y_delta
(
hb_font_t
*
font
)
const
{
return
get_delta
(
font
-
>
y_ppem
font
-
>
y_scale
)
;
}
public
:
unsigned
int
get_size
(
)
const
{
unsigned
int
f
=
deltaFormat
;
if
(
unlikely
(
f
<
1
|
|
f
>
3
|
|
startSize
>
endSize
)
)
return
3
*
HBUINT16
:
:
static_size
;
return
HBUINT16
:
:
static_size
*
(
4
+
(
(
endSize
-
startSize
)
>
>
(
4
-
f
)
)
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
c
-
>
check_range
(
this
this
-
>
get_size
(
)
)
)
;
}
HintingDevice
*
copy
(
hb_serialize_context_t
*
c
)
const
{
TRACE_SERIALIZE
(
this
)
;
return_trace
(
c
-
>
embed
<
HintingDevice
>
(
this
)
)
;
}
private
:
int
get_delta
(
unsigned
int
ppem
int
scale
)
const
{
if
(
!
ppem
)
return
0
;
int
pixels
=
get_delta_pixels
(
ppem
)
;
if
(
!
pixels
)
return
0
;
return
(
int
)
(
pixels
*
(
int64_t
)
scale
/
ppem
)
;
}
int
get_delta_pixels
(
unsigned
int
ppem_size
)
const
{
unsigned
int
f
=
deltaFormat
;
if
(
unlikely
(
f
<
1
|
|
f
>
3
)
)
return
0
;
if
(
ppem_size
<
startSize
|
|
ppem_size
>
endSize
)
return
0
;
unsigned
int
s
=
ppem_size
-
startSize
;
unsigned
int
byte
=
deltaValueZ
[
s
>
>
(
4
-
f
)
]
;
unsigned
int
bits
=
(
byte
>
>
(
16
-
(
(
(
s
&
(
(
1
<
<
(
4
-
f
)
)
-
1
)
)
+
1
)
<
<
f
)
)
)
;
unsigned
int
mask
=
(
0xFFFFu
>
>
(
16
-
(
1
<
<
f
)
)
)
;
int
delta
=
bits
&
mask
;
if
(
(
unsigned
int
)
delta
>
=
(
(
mask
+
1
)
>
>
1
)
)
delta
-
=
mask
+
1
;
return
delta
;
}
protected
:
HBUINT16
startSize
;
HBUINT16
endSize
;
HBUINT16
deltaFormat
;
UnsizedArrayOf
<
HBUINT16
>
deltaValueZ
;
public
:
DEFINE_SIZE_ARRAY
(
6
deltaValueZ
)
;
}
;
struct
VariationDevice
{
friend
struct
Device
;
private
:
hb_position_t
get_x_delta
(
hb_font_t
*
font
const
VariationStore
&
store
)
const
{
return
font
-
>
em_scalef_x
(
get_delta
(
font
store
)
)
;
}
hb_position_t
get_y_delta
(
hb_font_t
*
font
const
VariationStore
&
store
)
const
{
return
font
-
>
em_scalef_y
(
get_delta
(
font
store
)
)
;
}
VariationDevice
*
copy
(
hb_serialize_context_t
*
c
)
const
{
TRACE_SERIALIZE
(
this
)
;
return_trace
(
c
-
>
embed
<
VariationDevice
>
(
this
)
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
private
:
float
get_delta
(
hb_font_t
*
font
const
VariationStore
&
store
)
const
{
return
store
.
get_delta
(
outerIndex
innerIndex
font
-
>
coords
font
-
>
num_coords
)
;
}
protected
:
HBUINT16
outerIndex
;
HBUINT16
innerIndex
;
HBUINT16
deltaFormat
;
public
:
DEFINE_SIZE_STATIC
(
6
)
;
}
;
struct
DeviceHeader
{
protected
:
HBUINT16
reserved1
;
HBUINT16
reserved2
;
public
:
HBUINT16
format
;
public
:
DEFINE_SIZE_STATIC
(
6
)
;
}
;
struct
Device
{
hb_position_t
get_x_delta
(
hb_font_t
*
font
const
VariationStore
&
store
=
Null
(
VariationStore
)
)
const
{
switch
(
u
.
b
.
format
)
{
#
ifndef
HB_NO_HINTING
case
1
:
case
2
:
case
3
:
return
u
.
hinting
.
get_x_delta
(
font
)
;
#
endif
#
ifndef
HB_NO_VAR
case
0x8000
:
return
u
.
variation
.
get_x_delta
(
font
store
)
;
#
endif
default
:
return
0
;
}
}
hb_position_t
get_y_delta
(
hb_font_t
*
font
const
VariationStore
&
store
=
Null
(
VariationStore
)
)
const
{
switch
(
u
.
b
.
format
)
{
case
1
:
case
2
:
case
3
:
#
ifndef
HB_NO_HINTING
return
u
.
hinting
.
get_y_delta
(
font
)
;
#
endif
#
ifndef
HB_NO_VAR
case
0x8000
:
return
u
.
variation
.
get_y_delta
(
font
store
)
;
#
endif
default
:
return
0
;
}
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
!
u
.
b
.
format
.
sanitize
(
c
)
)
return_trace
(
false
)
;
switch
(
u
.
b
.
format
)
{
#
ifndef
HB_NO_HINTING
case
1
:
case
2
:
case
3
:
return_trace
(
u
.
hinting
.
sanitize
(
c
)
)
;
#
endif
#
ifndef
HB_NO_VAR
case
0x8000
:
return_trace
(
u
.
variation
.
sanitize
(
c
)
)
;
#
endif
default
:
return_trace
(
true
)
;
}
}
Device
*
copy
(
hb_serialize_context_t
*
c
)
const
{
TRACE_SERIALIZE
(
this
)
;
switch
(
u
.
b
.
format
)
{
#
ifndef
HB_NO_HINTING
case
1
:
case
2
:
case
3
:
return_trace
(
reinterpret_cast
<
Device
*
>
(
u
.
hinting
.
copy
(
c
)
)
)
;
#
endif
#
ifndef
HB_NO_VAR
case
0x8000
:
return_trace
(
reinterpret_cast
<
Device
*
>
(
u
.
variation
.
copy
(
c
)
)
)
;
#
endif
default
:
return_trace
(
nullptr
)
;
}
}
protected
:
union
{
DeviceHeader
b
;
HintingDevice
hinting
;
#
ifndef
HB_NO_VAR
VariationDevice
variation
;
#
endif
}
u
;
public
:
DEFINE_SIZE_UNION
(
6
b
)
;
}
;
}
#
endif
