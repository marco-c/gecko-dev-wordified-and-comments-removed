#
include
"
hb
-
ot
-
shape
-
complex
-
myanmar
-
private
.
hh
"
static
const
hb_tag_t
basic_features
[
]
=
{
HB_TAG
(
'
r
'
'
p
'
'
h
'
'
f
'
)
HB_TAG
(
'
p
'
'
r
'
'
e
'
'
f
'
)
HB_TAG
(
'
b
'
'
l
'
'
w
'
'
f
'
)
HB_TAG
(
'
p
'
'
s
'
'
t
'
'
f
'
)
}
;
static
const
hb_tag_t
other_features
[
]
=
{
HB_TAG
(
'
p
'
'
r
'
'
e
'
'
s
'
)
HB_TAG
(
'
a
'
'
b
'
'
v
'
'
s
'
)
HB_TAG
(
'
b
'
'
l
'
'
w
'
'
s
'
)
HB_TAG
(
'
p
'
'
s
'
'
t
'
'
s
'
)
HB_TAG
(
'
d
'
'
i
'
'
s
'
'
t
'
)
HB_TAG
(
'
a
'
'
b
'
'
v
'
'
m
'
)
HB_TAG
(
'
b
'
'
l
'
'
w
'
'
m
'
)
}
;
static
void
setup_syllables
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
hb_buffer_t
*
buffer
)
;
static
void
initial_reordering
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
hb_buffer_t
*
buffer
)
;
static
void
final_reordering
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
hb_buffer_t
*
buffer
)
;
static
void
collect_features_myanmar
(
hb_ot_shape_planner_t
*
plan
)
{
hb_ot_map_builder_t
*
map
=
&
plan
-
>
map
;
map
-
>
add_gsub_pause
(
setup_syllables
)
;
map
-
>
add_global_bool_feature
(
HB_TAG
(
'
l
'
'
o
'
'
c
'
'
l
'
)
)
;
map
-
>
add_global_bool_feature
(
HB_TAG
(
'
c
'
'
c
'
'
m
'
'
p
'
)
)
;
map
-
>
add_gsub_pause
(
initial_reordering
)
;
for
(
unsigned
int
i
=
0
;
i
<
ARRAY_LENGTH
(
basic_features
)
;
i
+
+
)
{
map
-
>
add_feature
(
basic_features
[
i
]
1
F_GLOBAL
|
F_MANUAL_ZWJ
)
;
map
-
>
add_gsub_pause
(
nullptr
)
;
}
map
-
>
add_gsub_pause
(
final_reordering
)
;
for
(
unsigned
int
i
=
0
;
i
<
ARRAY_LENGTH
(
other_features
)
;
i
+
+
)
map
-
>
add_feature
(
other_features
[
i
]
1
F_GLOBAL
|
F_MANUAL_ZWJ
)
;
}
static
void
override_features_myanmar
(
hb_ot_shape_planner_t
*
plan
)
{
plan
-
>
map
.
add_feature
(
HB_TAG
(
'
l
'
'
i
'
'
g
'
'
a
'
)
0
F_GLOBAL
)
;
}
enum
syllable_type_t
{
consonant_syllable
punctuation_cluster
broken_cluster
non_myanmar_cluster
}
;
#
include
"
hb
-
ot
-
shape
-
complex
-
myanmar
-
machine
.
hh
"
static
void
setup_masks_myanmar
(
const
hb_ot_shape_plan_t
*
plan
HB_UNUSED
hb_buffer_t
*
buffer
hb_font_t
*
font
HB_UNUSED
)
{
HB_BUFFER_ALLOCATE_VAR
(
buffer
myanmar_category
)
;
HB_BUFFER_ALLOCATE_VAR
(
buffer
myanmar_position
)
;
unsigned
int
count
=
buffer
-
>
len
;
hb_glyph_info_t
*
info
=
buffer
-
>
info
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
set_myanmar_properties
(
info
[
i
]
)
;
}
static
void
setup_syllables
(
const
hb_ot_shape_plan_t
*
plan
HB_UNUSED
hb_font_t
*
font
HB_UNUSED
hb_buffer_t
*
buffer
)
{
find_syllables
(
buffer
)
;
foreach_syllable
(
buffer
start
end
)
buffer
-
>
unsafe_to_break
(
start
end
)
;
}
static
int
compare_myanmar_order
(
const
hb_glyph_info_t
*
pa
const
hb_glyph_info_t
*
pb
)
{
int
a
=
pa
-
>
myanmar_position
(
)
;
int
b
=
pb
-
>
myanmar_position
(
)
;
return
a
<
b
?
-
1
:
a
=
=
b
?
0
:
+
1
;
}
static
void
initial_reordering_consonant_syllable
(
hb_buffer_t
*
buffer
unsigned
int
start
unsigned
int
end
)
{
hb_glyph_info_t
*
info
=
buffer
-
>
info
;
unsigned
int
base
=
end
;
bool
has_reph
=
false
;
{
unsigned
int
limit
=
start
;
if
(
start
+
3
<
=
end
&
&
info
[
start
]
.
myanmar_category
(
)
=
=
OT_Ra
&
&
info
[
start
+
1
]
.
myanmar_category
(
)
=
=
OT_As
&
&
info
[
start
+
2
]
.
myanmar_category
(
)
=
=
OT_H
)
{
limit
+
=
3
;
base
=
start
;
has_reph
=
true
;
}
{
if
(
!
has_reph
)
base
=
limit
;
for
(
unsigned
int
i
=
limit
;
i
<
end
;
i
+
+
)
if
(
is_consonant
(
info
[
i
]
)
)
{
base
=
i
;
break
;
}
}
}
{
unsigned
int
i
=
start
;
for
(
;
i
<
start
+
(
has_reph
?
3
:
0
)
;
i
+
+
)
info
[
i
]
.
myanmar_position
(
)
=
POS_AFTER_MAIN
;
for
(
;
i
<
base
;
i
+
+
)
info
[
i
]
.
myanmar_position
(
)
=
POS_PRE_C
;
if
(
i
<
end
)
{
info
[
i
]
.
myanmar_position
(
)
=
POS_BASE_C
;
i
+
+
;
}
indic_position_t
pos
=
POS_AFTER_MAIN
;
for
(
;
i
<
end
;
i
+
+
)
{
if
(
info
[
i
]
.
myanmar_category
(
)
=
=
OT_MR
)
{
info
[
i
]
.
myanmar_position
(
)
=
POS_PRE_C
;
continue
;
}
if
(
info
[
i
]
.
myanmar_position
(
)
<
POS_BASE_C
)
{
continue
;
}
if
(
info
[
i
]
.
myanmar_category
(
)
=
=
OT_VS
)
{
info
[
i
]
.
myanmar_position
(
)
=
info
[
i
-
1
]
.
myanmar_position
(
)
;
continue
;
}
if
(
pos
=
=
POS_AFTER_MAIN
&
&
info
[
i
]
.
myanmar_category
(
)
=
=
OT_VBlw
)
{
pos
=
POS_BELOW_C
;
info
[
i
]
.
myanmar_position
(
)
=
pos
;
continue
;
}
if
(
pos
=
=
POS_BELOW_C
&
&
info
[
i
]
.
myanmar_category
(
)
=
=
OT_A
)
{
info
[
i
]
.
myanmar_position
(
)
=
POS_BEFORE_SUB
;
continue
;
}
if
(
pos
=
=
POS_BELOW_C
&
&
info
[
i
]
.
myanmar_category
(
)
=
=
OT_VBlw
)
{
info
[
i
]
.
myanmar_position
(
)
=
pos
;
continue
;
}
if
(
pos
=
=
POS_BELOW_C
&
&
info
[
i
]
.
myanmar_category
(
)
!
=
OT_A
)
{
pos
=
POS_AFTER_SUB
;
info
[
i
]
.
myanmar_position
(
)
=
pos
;
continue
;
}
info
[
i
]
.
myanmar_position
(
)
=
pos
;
}
}
buffer
-
>
sort
(
start
end
compare_myanmar_order
)
;
}
static
void
initial_reordering_syllable
(
const
hb_ot_shape_plan_t
*
plan
hb_face_t
*
face
hb_buffer_t
*
buffer
unsigned
int
start
unsigned
int
end
)
{
syllable_type_t
syllable_type
=
(
syllable_type_t
)
(
buffer
-
>
info
[
start
]
.
syllable
(
)
&
0x0F
)
;
switch
(
syllable_type
)
{
case
broken_cluster
:
case
consonant_syllable
:
initial_reordering_consonant_syllable
(
buffer
start
end
)
;
break
;
case
punctuation_cluster
:
case
non_myanmar_cluster
:
break
;
}
}
static
inline
void
insert_dotted_circles
(
const
hb_ot_shape_plan_t
*
plan
HB_UNUSED
hb_font_t
*
font
hb_buffer_t
*
buffer
)
{
bool
has_broken_syllables
=
false
;
unsigned
int
count
=
buffer
-
>
len
;
hb_glyph_info_t
*
info
=
buffer
-
>
info
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
if
(
(
info
[
i
]
.
syllable
(
)
&
0x0F
)
=
=
broken_cluster
)
{
has_broken_syllables
=
true
;
break
;
}
if
(
likely
(
!
has_broken_syllables
)
)
return
;
hb_codepoint_t
dottedcircle_glyph
;
if
(
!
font
-
>
get_nominal_glyph
(
0x25CCu
&
dottedcircle_glyph
)
)
return
;
hb_glyph_info_t
dottedcircle
=
{
0
}
;
dottedcircle
.
codepoint
=
0x25CCu
;
set_myanmar_properties
(
dottedcircle
)
;
dottedcircle
.
codepoint
=
dottedcircle_glyph
;
buffer
-
>
clear_output
(
)
;
buffer
-
>
idx
=
0
;
unsigned
int
last_syllable
=
0
;
while
(
buffer
-
>
idx
<
buffer
-
>
len
&
&
buffer
-
>
successful
)
{
unsigned
int
syllable
=
buffer
-
>
cur
(
)
.
syllable
(
)
;
syllable_type_t
syllable_type
=
(
syllable_type_t
)
(
syllable
&
0x0F
)
;
if
(
unlikely
(
last_syllable
!
=
syllable
&
&
syllable_type
=
=
broken_cluster
)
)
{
last_syllable
=
syllable
;
hb_glyph_info_t
ginfo
=
dottedcircle
;
ginfo
.
cluster
=
buffer
-
>
cur
(
)
.
cluster
;
ginfo
.
mask
=
buffer
-
>
cur
(
)
.
mask
;
ginfo
.
syllable
(
)
=
buffer
-
>
cur
(
)
.
syllable
(
)
;
buffer
-
>
output_info
(
ginfo
)
;
}
else
buffer
-
>
next_glyph
(
)
;
}
buffer
-
>
swap_buffers
(
)
;
}
static
void
initial_reordering
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
hb_buffer_t
*
buffer
)
{
insert_dotted_circles
(
plan
font
buffer
)
;
foreach_syllable
(
buffer
start
end
)
initial_reordering_syllable
(
plan
font
-
>
face
buffer
start
end
)
;
}
static
void
final_reordering
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
HB_UNUSED
hb_buffer_t
*
buffer
)
{
hb_glyph_info_t
*
info
=
buffer
-
>
info
;
unsigned
int
count
=
buffer
-
>
len
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
info
[
i
]
.
syllable
(
)
=
0
;
HB_BUFFER_DEALLOCATE_VAR
(
buffer
myanmar_category
)
;
HB_BUFFER_DEALLOCATE_VAR
(
buffer
myanmar_position
)
;
}
const
hb_ot_complex_shaper_t
_hb_ot_complex_shaper_myanmar_old
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
HB_OT_SHAPE_NORMALIZATION_MODE_DEFAULT
nullptr
nullptr
nullptr
nullptr
nullptr
HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE
true
}
;
const
hb_ot_complex_shaper_t
_hb_ot_complex_shaper_myanmar
=
{
collect_features_myanmar
override_features_myanmar
nullptr
nullptr
nullptr
nullptr
HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT
nullptr
nullptr
setup_masks_myanmar
nullptr
nullptr
HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY
false
}
;
