#
ifndef
HB_FREE_POOL_HH
#
define
HB_FREE_POOL_HH
#
include
"
hb
.
hh
"
template
<
typename
T
unsigned
ChunkLen
=
32
>
struct
hb_free_pool_t
{
hb_free_pool_t
(
)
:
next
(
nullptr
)
{
}
~
hb_free_pool_t
(
)
{
next
=
nullptr
;
+
hb_iter
(
chunks
)
|
hb_apply
(
hb_free
)
;
}
T
*
alloc
(
)
{
if
(
unlikely
(
!
next
)
)
{
if
(
unlikely
(
!
chunks
.
alloc
(
chunks
.
length
+
1
)
)
)
return
nullptr
;
chunk_t
*
chunk
=
(
chunk_t
*
)
hb_malloc
(
sizeof
(
chunk_t
)
)
;
if
(
unlikely
(
!
chunk
)
)
return
nullptr
;
chunks
.
push
(
chunk
)
;
next
=
chunk
-
>
thread
(
)
;
}
T
*
obj
=
next
;
next
=
*
(
(
T
*
*
)
next
)
;
hb_memset
(
obj
0
sizeof
(
T
)
)
;
return
obj
;
}
void
release
(
T
*
obj
)
{
*
(
T
*
*
)
obj
=
next
;
next
=
obj
;
}
private
:
static_assert
(
ChunkLen
>
1
"
"
)
;
static_assert
(
sizeof
(
T
)
>
=
sizeof
(
void
*
)
"
"
)
;
static_assert
(
alignof
(
T
)
%
alignof
(
void
*
)
=
=
0
"
"
)
;
struct
chunk_t
{
T
*
thread
(
)
{
for
(
unsigned
i
=
0
;
i
<
ARRAY_LENGTH
(
arrayZ
)
-
1
;
i
+
+
)
*
(
T
*
*
)
&
arrayZ
[
i
]
=
&
arrayZ
[
i
+
1
]
;
*
(
T
*
*
)
&
arrayZ
[
ARRAY_LENGTH
(
arrayZ
)
-
1
]
=
nullptr
;
return
arrayZ
;
}
T
arrayZ
[
ChunkLen
]
;
}
;
T
*
next
;
hb_vector_t
<
chunk_t
*
>
chunks
;
}
;
#
endif
