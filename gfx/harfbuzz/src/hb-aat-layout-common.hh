#
ifndef
HB_AAT_LAYOUT_COMMON_HH
#
define
HB_AAT_LAYOUT_COMMON_HH
#
include
"
hb
-
aat
-
layout
.
hh
"
namespace
AAT
{
using
namespace
OT
;
struct
BinSearchHeader
{
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
HBUINT16
unitSize
;
HBUINT16
nUnits
;
HBUINT16
searchRange
;
HBUINT16
entrySelector
;
HBUINT16
rangeShift
;
public
:
DEFINE_SIZE_STATIC
(
10
)
;
}
;
template
<
typename
Type
>
struct
BinSearchArrayOf
{
inline
const
Type
&
operator
[
]
(
unsigned
int
i
)
const
{
if
(
unlikely
(
i
>
=
header
.
nUnits
)
)
return
Null
(
Type
)
;
return
StructAtOffset
<
Type
>
(
bytesZ
i
*
header
.
unitSize
)
;
}
inline
Type
&
operator
[
]
(
unsigned
int
i
)
{
return
StructAtOffset
<
Type
>
(
bytesZ
i
*
header
.
unitSize
)
;
}
inline
unsigned
int
get_size
(
void
)
const
{
return
header
.
static_size
+
header
.
nUnits
*
header
.
unitSize
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
sanitize_shallow
(
c
)
)
)
return_trace
(
false
)
;
(
void
)
(
false
&
&
StructAtOffset
<
Type
>
(
bytesZ
0
)
.
sanitize
(
c
)
)
;
return_trace
(
true
)
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
sanitize_shallow
(
c
)
)
)
return_trace
(
false
)
;
unsigned
int
count
=
header
.
nUnits
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
if
(
unlikely
(
!
(
*
this
)
[
i
]
.
sanitize
(
c
base
)
)
)
return_trace
(
false
)
;
return_trace
(
true
)
;
}
template
<
typename
T
>
inline
const
Type
*
bsearch
(
const
T
&
key
)
const
{
unsigned
int
size
=
header
.
unitSize
;
int
min
=
0
max
=
(
int
)
header
.
nUnits
-
1
;
while
(
min
<
=
max
)
{
int
mid
=
(
min
+
max
)
/
2
;
const
Type
*
p
=
(
const
Type
*
)
(
(
(
const
char
*
)
bytesZ
)
+
(
mid
*
size
)
)
;
int
c
=
p
-
>
cmp
(
key
)
;
if
(
c
<
0
)
max
=
mid
-
1
;
else
if
(
c
>
0
)
min
=
mid
+
1
;
else
return
p
;
}
return
nullptr
;
}
private
:
inline
bool
sanitize_shallow
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
header
.
sanitize
(
c
)
&
&
Type
:
:
static_size
>
=
header
.
unitSize
&
&
c
-
>
check_array
(
bytesZ
header
.
unitSize
header
.
nUnits
)
)
;
}
protected
:
BinSearchHeader
header
;
HBUINT8
bytesZ
[
VAR
]
;
public
:
DEFINE_SIZE_ARRAY
(
10
bytesZ
)
;
}
;
template
<
typename
T
>
struct
Lookup
;
template
<
typename
T
>
struct
LookupFormat0
{
friend
struct
Lookup
<
T
>
;
private
:
inline
const
T
*
get_value
(
hb_codepoint_t
glyph_id
unsigned
int
num_glyphs
)
const
{
if
(
unlikely
(
glyph_id
>
=
num_glyphs
)
)
return
nullptr
;
return
&
arrayZ
[
glyph_id
]
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
arrayZ
.
sanitize
(
c
c
-
>
get_num_glyphs
(
)
)
)
;
}
protected
:
HBUINT16
format
;
UnsizedArrayOf
<
T
>
arrayZ
;
public
:
DEFINE_SIZE_ARRAY
(
2
arrayZ
)
;
}
;
template
<
typename
T
>
struct
LookupSegmentSingle
{
inline
int
cmp
(
hb_codepoint_t
g
)
const
{
return
g
<
first
?
-
1
:
g
<
=
last
?
0
:
+
1
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
value
.
sanitize
(
c
)
)
;
}
GlyphID
last
;
GlyphID
first
;
T
value
;
public
:
DEFINE_SIZE_STATIC
(
4
+
T
:
:
static_size
)
;
}
;
template
<
typename
T
>
struct
LookupFormat2
{
friend
struct
Lookup
<
T
>
;
private
:
inline
const
T
*
get_value
(
hb_codepoint_t
glyph_id
)
const
{
const
LookupSegmentSingle
<
T
>
*
v
=
segments
.
bsearch
(
glyph_id
)
;
return
v
?
&
v
-
>
value
:
nullptr
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
segments
.
sanitize
(
c
)
)
;
}
protected
:
HBUINT16
format
;
BinSearchArrayOf
<
LookupSegmentSingle
<
T
>
>
segments
;
public
:
DEFINE_SIZE_ARRAY
(
8
segments
)
;
}
;
template
<
typename
T
>
struct
LookupSegmentArray
{
inline
const
T
*
get_value
(
hb_codepoint_t
glyph_id
const
void
*
base
)
const
{
return
first
<
=
glyph_id
&
&
glyph_id
<
=
last
?
&
(
base
+
valuesZ
)
[
glyph_id
-
first
]
:
nullptr
;
}
inline
int
cmp
(
hb_codepoint_t
g
)
const
{
return
g
<
first
?
-
1
:
g
<
=
last
?
0
:
+
1
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
first
<
=
last
&
&
valuesZ
.
sanitize
(
c
base
last
-
first
+
1
)
)
;
}
GlyphID
last
;
GlyphID
first
;
OffsetTo
<
UnsizedArrayOf
<
T
>
>
valuesZ
;
public
:
DEFINE_SIZE_STATIC
(
6
)
;
}
;
template
<
typename
T
>
struct
LookupFormat4
{
friend
struct
Lookup
<
T
>
;
private
:
inline
const
T
*
get_value
(
hb_codepoint_t
glyph_id
)
const
{
const
LookupSegmentArray
<
T
>
*
v
=
segments
.
bsearch
(
glyph_id
)
;
return
v
?
v
-
>
get_value
(
glyph_id
this
)
:
nullptr
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
segments
.
sanitize
(
c
this
)
)
;
}
protected
:
HBUINT16
format
;
BinSearchArrayOf
<
LookupSegmentArray
<
T
>
>
segments
;
public
:
DEFINE_SIZE_ARRAY
(
8
segments
)
;
}
;
template
<
typename
T
>
struct
LookupSingle
{
inline
int
cmp
(
hb_codepoint_t
g
)
const
{
return
glyph
.
cmp
(
g
)
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
value
.
sanitize
(
c
)
)
;
}
GlyphID
glyph
;
T
value
;
public
:
DEFINE_SIZE_STATIC
(
4
+
T
:
:
static_size
)
;
}
;
template
<
typename
T
>
struct
LookupFormat6
{
friend
struct
Lookup
<
T
>
;
private
:
inline
const
T
*
get_value
(
hb_codepoint_t
glyph_id
)
const
{
const
LookupSingle
<
T
>
*
v
=
entries
.
bsearch
(
glyph_id
)
;
return
v
?
&
v
-
>
value
:
nullptr
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
entries
.
sanitize
(
c
)
)
;
}
protected
:
HBUINT16
format
;
BinSearchArrayOf
<
LookupSingle
<
T
>
>
entries
;
public
:
DEFINE_SIZE_ARRAY
(
8
entries
)
;
}
;
template
<
typename
T
>
struct
LookupFormat8
{
friend
struct
Lookup
<
T
>
;
private
:
inline
const
T
*
get_value
(
hb_codepoint_t
glyph_id
)
const
{
return
firstGlyph
<
=
glyph_id
&
&
glyph_id
-
firstGlyph
<
glyphCount
?
&
valueArrayZ
[
glyph_id
-
firstGlyph
]
:
nullptr
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
valueArrayZ
.
sanitize
(
c
glyphCount
)
)
;
}
protected
:
HBUINT16
format
;
GlyphID
firstGlyph
;
HBUINT16
glyphCount
;
UnsizedArrayOf
<
T
>
valueArrayZ
;
public
:
DEFINE_SIZE_ARRAY
(
6
valueArrayZ
)
;
}
;
template
<
typename
T
>
struct
Lookup
{
inline
const
T
*
get_value
(
hb_codepoint_t
glyph_id
unsigned
int
num_glyphs
)
const
{
switch
(
u
.
format
)
{
case
0
:
return
u
.
format0
.
get_value
(
glyph_id
num_glyphs
)
;
case
2
:
return
u
.
format2
.
get_value
(
glyph_id
)
;
case
4
:
return
u
.
format4
.
get_value
(
glyph_id
)
;
case
6
:
return
u
.
format6
.
get_value
(
glyph_id
)
;
case
8
:
return
u
.
format8
.
get_value
(
glyph_id
)
;
default
:
return
nullptr
;
}
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
!
u
.
format
.
sanitize
(
c
)
)
return_trace
(
false
)
;
switch
(
u
.
format
)
{
case
0
:
return_trace
(
u
.
format0
.
sanitize
(
c
)
)
;
case
2
:
return_trace
(
u
.
format2
.
sanitize
(
c
)
)
;
case
4
:
return_trace
(
u
.
format4
.
sanitize
(
c
)
)
;
case
6
:
return_trace
(
u
.
format6
.
sanitize
(
c
)
)
;
case
8
:
return_trace
(
u
.
format8
.
sanitize
(
c
)
)
;
default
:
return_trace
(
true
)
;
}
}
protected
:
union
{
HBUINT16
format
;
LookupFormat0
<
T
>
format0
;
LookupFormat2
<
T
>
format2
;
LookupFormat4
<
T
>
format4
;
LookupFormat6
<
T
>
format6
;
LookupFormat8
<
T
>
format8
;
}
u
;
public
:
DEFINE_SIZE_UNION
(
2
format
)
;
}
;
template
<
typename
T
>
struct
Entry
{
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
unsigned
int
count
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
public
:
HBUINT16
newState
;
HBUINT16
flags
;
T
data
;
public
:
DEFINE_SIZE_STATIC
(
4
+
T
:
:
static_size
)
;
}
;
template
<
>
struct
Entry
<
void
>
{
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
unsigned
int
count
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
public
:
HBUINT16
newState
;
HBUINT16
flags
;
public
:
DEFINE_SIZE_STATIC
(
4
)
;
}
;
template
<
typename
Extra
>
struct
StateTable
{
inline
unsigned
int
get_class
(
hb_codepoint_t
glyph_id
unsigned
int
num_glyphs
)
const
{
const
HBUINT16
*
v
=
(
this
+
classTable
)
.
get_value
(
glyph_id
num_glyphs
)
;
return
v
?
*
v
:
1
;
}
inline
const
Entry
<
Extra
>
*
get_entries
(
)
const
{
return
(
this
+
entryTable
)
.
arrayZ
;
}
inline
const
Entry
<
Extra
>
*
get_entryZ
(
unsigned
int
state
unsigned
int
klass
)
const
{
if
(
unlikely
(
klass
>
=
nClasses
)
)
return
nullptr
;
const
HBUINT16
*
states
=
(
this
+
stateArrayTable
)
.
arrayZ
;
const
Entry
<
Extra
>
*
entries
=
(
this
+
entryTable
)
.
arrayZ
;
unsigned
int
entry
=
states
[
state
*
nClasses
+
klass
]
;
return
&
entries
[
entry
]
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
unsigned
int
*
num_entries_out
=
nullptr
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
(
c
-
>
check_struct
(
this
)
&
&
classTable
.
sanitize
(
c
this
)
)
)
)
return_trace
(
false
)
;
const
HBUINT16
*
states
=
(
this
+
stateArrayTable
)
.
arrayZ
;
const
Entry
<
Extra
>
*
entries
=
(
this
+
entryTable
)
.
arrayZ
;
unsigned
int
num_states
=
1
;
unsigned
int
num_entries
=
0
;
unsigned
int
state
=
0
;
unsigned
int
entry
=
0
;
while
(
state
<
num_states
)
{
if
(
unlikely
(
!
c
-
>
check_array
(
states
states
[
0
]
.
static_size
*
nClasses
num_states
)
)
)
return_trace
(
false
)
;
{
const
HBUINT16
*
stop
=
&
states
[
num_states
*
nClasses
]
;
for
(
const
HBUINT16
*
p
=
&
states
[
state
*
nClasses
]
;
p
<
stop
;
p
+
+
)
num_entries
=
MAX
<
unsigned
int
>
(
num_entries
*
p
+
1
)
;
state
=
num_states
;
}
if
(
unlikely
(
!
c
-
>
check_array
(
entries
entries
[
0
]
.
static_size
num_entries
)
)
)
return_trace
(
false
)
;
{
const
Entry
<
Extra
>
*
stop
=
&
entries
[
num_entries
]
;
for
(
const
Entry
<
Extra
>
*
p
=
&
entries
[
entry
]
;
p
<
stop
;
p
+
+
)
num_states
=
MAX
<
unsigned
int
>
(
num_states
p
-
>
newState
+
1
)
;
entry
=
num_entries
;
}
}
if
(
num_entries_out
)
*
num_entries_out
=
num_entries
;
return_trace
(
true
)
;
}
protected
:
HBUINT32
nClasses
;
LOffsetTo
<
Lookup
<
HBUINT16
>
>
classTable
;
LOffsetTo
<
UnsizedArrayOf
<
HBUINT16
>
>
stateArrayTable
;
LOffsetTo
<
UnsizedArrayOf
<
Entry
<
Extra
>
>
>
entryTable
;
public
:
DEFINE_SIZE_STATIC
(
16
)
;
}
;
template
<
typename
EntryData
>
struct
StateTableDriver
{
inline
StateTableDriver
(
const
StateTable
<
EntryData
>
&
machine_
hb_buffer_t
*
buffer_
hb_face_t
*
face_
)
:
machine
(
machine_
)
buffer
(
buffer_
)
num_glyphs
(
face_
-
>
get_num_glyphs
(
)
)
{
}
template
<
typename
context_t
>
inline
void
drive
(
context_t
*
c
)
{
hb_glyph_info_t
*
info
=
buffer
-
>
info
;
if
(
!
c
-
>
in_place
)
buffer
-
>
clear_output
(
)
;
unsigned
int
state
=
0
;
bool
last_was_dont_advance
=
false
;
for
(
buffer
-
>
idx
=
0
;
;
)
{
unsigned
int
klass
=
buffer
-
>
idx
<
buffer
-
>
len
?
machine
.
get_class
(
info
[
buffer
-
>
idx
]
.
codepoint
num_glyphs
)
:
0
;
const
Entry
<
EntryData
>
*
entry
=
machine
.
get_entryZ
(
state
klass
)
;
if
(
unlikely
(
!
entry
)
)
break
;
if
(
state
&
&
buffer
-
>
idx
)
{
if
(
c
-
>
is_actionable
(
this
entry
)
|
|
!
(
entry
-
>
newState
=
=
0
&
&
entry
-
>
flags
=
=
context_t
:
:
DontAdvance
)
)
buffer
-
>
unsafe_to_break
(
buffer
-
>
idx
-
1
buffer
-
>
idx
+
1
)
;
}
if
(
buffer
-
>
idx
+
2
<
=
buffer
-
>
len
)
{
const
Entry
<
EntryData
>
*
end_entry
=
machine
.
get_entryZ
(
state
0
)
;
if
(
c
-
>
is_actionable
(
this
end_entry
)
)
buffer
-
>
unsafe_to_break
(
buffer
-
>
idx
buffer
-
>
idx
+
2
)
;
}
if
(
unlikely
(
!
c
-
>
transition
(
this
entry
)
)
)
break
;
last_was_dont_advance
=
(
entry
-
>
flags
&
context_t
:
:
DontAdvance
)
&
&
buffer
-
>
max_ops
-
-
>
0
;
state
=
entry
-
>
newState
;
if
(
buffer
-
>
idx
=
=
buffer
-
>
len
)
break
;
if
(
!
last_was_dont_advance
)
buffer
-
>
next_glyph
(
)
;
}
if
(
!
c
-
>
in_place
)
{
for
(
;
buffer
-
>
idx
<
buffer
-
>
len
;
)
buffer
-
>
next_glyph
(
)
;
buffer
-
>
swap_buffers
(
)
;
}
}
public
:
const
StateTable
<
EntryData
>
&
machine
;
hb_buffer_t
*
buffer
;
unsigned
int
num_glyphs
;
}
;
struct
hb_aat_apply_context_t
:
hb_dispatch_context_t
<
hb_aat_apply_context_t
bool
HB_DEBUG_APPLY
>
{
inline
const
char
*
get_name
(
void
)
{
return
"
APPLY
"
;
}
template
<
typename
T
>
inline
return_t
dispatch
(
const
T
&
obj
)
{
return
obj
.
apply
(
this
)
;
}
static
return_t
default_return_value
(
void
)
{
return
false
;
}
bool
stop_sublookup_iteration
(
return_t
r
)
const
{
return
r
;
}
hb_font_t
*
font
;
hb_face_t
*
face
;
hb_buffer_t
*
buffer
;
hb_sanitize_context_t
sanitizer
;
unsigned
int
lookup_index
;
unsigned
int
debug_depth
;
inline
hb_aat_apply_context_t
(
hb_font_t
*
font_
hb_buffer_t
*
buffer_
hb_blob_t
*
table
)
:
font
(
font_
)
face
(
font
-
>
face
)
buffer
(
buffer_
)
sanitizer
(
)
lookup_index
(
0
)
debug_depth
(
0
)
{
sanitizer
.
init
(
table
)
;
sanitizer
.
set_num_glyphs
(
face
-
>
get_num_glyphs
(
)
)
;
sanitizer
.
start_processing
(
)
;
}
inline
void
set_lookup_index
(
unsigned
int
i
)
{
lookup_index
=
i
;
}
inline
~
hb_aat_apply_context_t
(
void
)
{
sanitizer
.
end_processing
(
)
;
}
}
;
}
#
endif
