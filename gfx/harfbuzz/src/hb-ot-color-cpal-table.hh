#
ifndef
HB_OT_COLOR_CPAL_TABLE_HH
#
define
HB_OT_COLOR_CPAL_TABLE_HH
#
include
"
hb
-
open
-
type
-
private
.
hh
"
typedef
uint32_t
hb_ot_color_t
;
typedef
enum
{
HB_OT_COLOR_PALETTE_FLAG_DEFAULT
=
0x00000000u
HB_OT_COLOR_PALETTE_FLAG_FOR_LIGHT_BACKGROUND
=
0x00000001u
HB_OT_COLOR_PALETTE_FLAG_FOR_DARK_BACKGROUND
=
0x00000002u
}
hb_ot_color_palette_flags_t
;
#
define
HB_OT_TAG_CPAL
HB_TAG
(
'
C
'
'
P
'
'
A
'
'
L
'
)
namespace
OT
{
struct
CPALV1Tail
{
friend
struct
CPAL
;
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
unsigned
int
palettes
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
(
base
+
paletteFlagsZ
)
.
sanitize
(
c
palettes
)
&
&
(
base
+
paletteLabelZ
)
.
sanitize
(
c
palettes
)
&
&
(
base
+
paletteEntryLabelZ
)
.
sanitize
(
c
palettes
)
)
;
}
private
:
inline
hb_ot_color_palette_flags_t
get_palette_flags
(
const
void
*
base
unsigned
int
palette
)
const
{
return
(
hb_ot_color_palette_flags_t
)
(
uint32_t
)
(
base
+
paletteFlagsZ
)
[
palette
]
;
}
inline
unsigned
int
get_palette_name_id
(
const
void
*
base
unsigned
int
palette
)
const
{
return
(
base
+
paletteLabelZ
)
[
palette
]
;
}
protected
:
LOffsetTo
<
UnsizedArrayOf
<
HBUINT32
>
>
paletteFlagsZ
;
LOffsetTo
<
UnsizedArrayOf
<
HBUINT16
>
>
paletteLabelZ
;
LOffsetTo
<
UnsizedArrayOf
<
HBUINT16
>
>
paletteEntryLabelZ
;
public
:
DEFINE_SIZE_STATIC
(
12
)
;
}
;
typedef
HBUINT32
BGRAColor
;
struct
CPAL
{
static
const
hb_tag_t
tableTag
=
HB_OT_TAG_CPAL
;
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
(
c
-
>
check_struct
(
this
)
&
&
(
this
+
colorRecordsZ
)
.
sanitize
(
c
numColorRecords
)
)
)
)
return_trace
(
false
)
;
for
(
unsigned
int
i
=
0
;
i
<
numPalettes
;
+
+
i
)
if
(
unlikely
(
colorRecordIndicesZ
[
i
]
+
numPaletteEntries
>
numColorRecords
)
)
return_trace
(
false
)
;
if
(
version
=
=
0
)
return_trace
(
true
)
;
const
CPALV1Tail
&
v1
=
StructAfter
<
CPALV1Tail
>
(
*
this
)
;
return_trace
(
likely
(
v1
.
sanitize
(
c
this
numPalettes
)
)
)
;
}
inline
unsigned
int
get_size
(
void
)
const
{
return
min_size
+
numPalettes
*
sizeof
(
HBUINT16
)
;
}
inline
hb_ot_color_palette_flags_t
get_palette_flags
(
unsigned
int
palette
)
const
{
if
(
unlikely
(
version
=
=
0
|
|
palette
>
=
numPalettes
)
)
return
HB_OT_COLOR_PALETTE_FLAG_DEFAULT
;
const
CPALV1Tail
&
cpal1
=
StructAfter
<
CPALV1Tail
>
(
*
this
)
;
return
cpal1
.
get_palette_flags
(
this
palette
)
;
}
inline
unsigned
int
get_palette_name_id
(
unsigned
int
palette
)
const
{
if
(
unlikely
(
version
=
=
0
|
|
palette
>
=
numPalettes
)
)
return
0xFFFF
;
const
CPALV1Tail
&
cpal1
=
StructAfter
<
CPALV1Tail
>
(
*
this
)
;
return
cpal1
.
get_palette_name_id
(
this
palette
)
;
}
inline
unsigned
int
get_palette_count
(
)
const
{
return
numPalettes
;
}
inline
hb_ot_color_t
get_color_record_argb
(
unsigned
int
color_index
unsigned
int
palette
)
const
{
if
(
unlikely
(
color_index
>
=
numPaletteEntries
|
|
palette
>
=
numPalettes
)
)
return
0
;
const
UnsizedArrayOf
<
BGRAColor
>
&
color_records
=
this
+
colorRecordsZ
;
return
color_records
[
colorRecordIndicesZ
[
palette
]
+
color_index
]
;
}
protected
:
HBUINT16
version
;
HBUINT16
numPaletteEntries
;
HBUINT16
numPalettes
;
HBUINT16
numColorRecords
;
LOffsetTo
<
UnsizedArrayOf
<
BGRAColor
>
>
colorRecordsZ
;
UnsizedArrayOf
<
HBUINT16
>
colorRecordIndicesZ
;
public
:
DEFINE_SIZE_ARRAY
(
12
colorRecordIndicesZ
)
;
}
;
}
#
endif
