#
ifndef
HB_PRIVATE_HH
#
define
HB_PRIVATE_HH
#
define
_GNU_SOURCE
1
#
ifdef
HAVE_CONFIG_H
#
include
"
config
.
h
"
#
endif
#
include
"
hb
.
h
"
#
define
HB_H_IN
#
ifdef
HAVE_OT
#
include
"
hb
-
ot
.
h
"
#
define
HB_OT_H_IN
#
endif
#
include
<
math
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
stddef
.
h
>
#
include
<
string
.
h
>
#
include
<
assert
.
h
>
#
include
<
errno
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdarg
.
h
>
#
if
(
defined
(
_MSC_VER
)
&
&
_MSC_VER
>
=
1500
)
|
|
defined
(
__MINGW32__
)
#
include
<
intrin
.
h
>
#
endif
#
define
HB_PASTE1
(
a
b
)
a
#
#
b
#
define
HB_PASTE
(
a
b
)
HB_PASTE1
(
a
b
)
#
if
defined
(
hb_malloc_impl
)
\
&
&
defined
(
hb_calloc_impl
)
\
&
&
defined
(
hb_realloc_impl
)
\
&
&
defined
(
hb_free_impl
)
extern
"
C
"
void
*
hb_malloc_impl
(
size_t
size
)
;
extern
"
C
"
void
*
hb_calloc_impl
(
size_t
nmemb
size_t
size
)
;
extern
"
C
"
void
*
hb_realloc_impl
(
void
*
ptr
size_t
size
)
;
extern
"
C
"
void
hb_free_impl
(
void
*
ptr
)
;
#
define
malloc
hb_malloc_impl
#
define
calloc
hb_calloc_impl
#
define
realloc
hb_realloc_impl
#
define
free
hb_free_impl
#
if
defined
(
hb_memalign_impl
)
extern
"
C
"
int
hb_memalign_impl
(
void
*
*
memptr
size_t
alignment
size_t
size
)
;
#
define
posix_memalign
hb_memalign_impl
#
else
#
undef
HAVE_POSIX_MEMALIGN
#
endif
#
endif
template
<
typename
T
>
struct
_hb_alignof
{
struct
s
{
char
c
;
T
t
;
}
;
static
constexpr
unsigned
int
value
=
offsetof
(
s
t
)
;
}
;
#
if
__cplusplus
<
201103L
#
ifndef
nullptr
#
define
nullptr
NULL
#
endif
#
ifndef
constexpr
#
define
constexpr
const
#
endif
#
ifndef
static_assert
#
define
static_assert
(
e
msg
)
\
HB_UNUSED
typedef
int
HB_PASTE
(
static_assertion_failed_at_line_
__LINE__
)
[
(
e
)
?
1
:
-
1
]
#
endif
#
ifdef
__GNUC__
#
if
(
__GNUC__
<
4
|
|
(
__GNUC__
=
=
4
&
&
__GNUC_MINOR__
<
8
)
)
#
define
thread_local
__thread
#
endif
#
else
#
define
thread_local
#
endif
#
ifndef
alignof
#
define
alignof
(
x
)
(
_hb_alignof
<
x
>
:
:
value
)
#
endif
#
endif
#
if
(
defined
(
__GNUC__
)
|
|
defined
(
__clang__
)
)
&
&
defined
(
__OPTIMIZE__
)
#
define
likely
(
expr
)
(
__builtin_expect
(
!
!
(
expr
)
1
)
)
#
define
unlikely
(
expr
)
(
__builtin_expect
(
!
!
(
expr
)
0
)
)
#
else
#
define
likely
(
expr
)
(
expr
)
#
define
unlikely
(
expr
)
(
expr
)
#
endif
#
if
!
defined
(
__GNUC__
)
&
&
!
defined
(
__clang__
)
#
undef
__attribute__
#
define
__attribute__
(
x
)
#
endif
#
if
__GNUC__
>
=
3
#
define
HB_PURE_FUNC
__attribute__
(
(
pure
)
)
#
define
HB_CONST_FUNC
__attribute__
(
(
const
)
)
#
define
HB_PRINTF_FUNC
(
format_idx
arg_idx
)
__attribute__
(
(
__format__
(
__printf__
format_idx
arg_idx
)
)
)
#
else
#
define
HB_PURE_FUNC
#
define
HB_CONST_FUNC
#
define
HB_PRINTF_FUNC
(
format_idx
arg_idx
)
#
endif
#
if
__GNUC__
>
=
4
#
define
HB_UNUSED
__attribute__
(
(
unused
)
)
#
elif
defined
(
_MSC_VER
)
#
define
HB_UNUSED
__pragma
(
warning
(
suppress
:
4100
4101
)
)
#
else
#
define
HB_UNUSED
#
endif
#
ifndef
HB_INTERNAL
#
if
!
defined
(
HB_NO_VISIBILITY
)
&
&
!
defined
(
__MINGW32__
)
&
&
!
defined
(
__CYGWIN__
)
&
&
!
defined
(
_MSC_VER
)
&
&
!
defined
(
__SUNPRO_CC
)
#
define
HB_INTERNAL
__attribute__
(
(
__visibility__
(
"
hidden
"
)
)
)
#
else
#
define
HB_INTERNAL
#
define
HB_NO_VISIBILITY
1
#
endif
#
endif
#
if
__GNUC__
>
=
3
#
define
HB_FUNC
__PRETTY_FUNCTION__
#
elif
defined
(
_MSC_VER
)
#
define
HB_FUNC
__FUNCSIG__
#
else
#
define
HB_FUNC
__func__
#
endif
#
if
defined
(
__SUNPRO_CC
)
&
&
(
__SUNPRO_CC
<
0x5140
)
#
define
__restrict
#
endif
#
if
defined
(
__clang__
)
&
&
__cplusplus
>
=
201103L
#
define
HB_FALLTHROUGH
[
[
clang
:
:
fallthrough
]
]
#
elif
__GNUC__
>
=
7
#
define
HB_FALLTHROUGH
__attribute__
(
(
fallthrough
)
)
#
elif
defined
(
_MSC_VER
)
#
include
<
sal
.
h
>
#
define
HB_FALLTHROUGH
__fallthrough
#
else
#
define
HB_FALLTHROUGH
#
endif
#
if
defined
(
_WIN32
)
|
|
defined
(
__CYGWIN__
)
#
if
defined
(
_WIN32_WINNT
)
&
&
_WIN32_WINNT
<
0x0600
#
undef
_WIN32_WINNT
#
endif
#
ifndef
_WIN32_WINNT
#
define
_WIN32_WINNT
0x0600
#
endif
#
ifndef
WIN32_LEAN_AND_MEAN
#
define
WIN32_LEAN_AND_MEAN
1
#
endif
#
ifndef
STRICT
#
define
STRICT
1
#
endif
#
if
defined
(
_WIN32_WCE
)
#
define
vsnprintf
_vsnprintf
#
define
getenv
(
Name
)
nullptr
#
if
_WIN32_WCE
<
0x800
#
define
setlocale
(
Category
Locale
)
"
C
"
static
int
errno
=
0
;
#
endif
#
elif
defined
(
WINAPI_FAMILY
)
&
&
(
WINAPI_FAMILY
=
=
WINAPI_FAMILY_PC_APP
|
|
WINAPI_FAMILY
=
=
WINAPI_FAMILY_PHONE_APP
)
#
define
getenv
(
Name
)
nullptr
#
endif
#
if
defined
(
_MSC_VER
)
&
&
_MSC_VER
<
1900
#
define
snprintf
_snprintf
#
endif
#
endif
#
if
HAVE_ATEXIT
#
if
defined
(
__linux
)
&
&
defined
(
__GLIBC_PREREQ
)
#
if
__GLIBC_PREREQ
(
2
3
)
#
define
HB_USE_ATEXIT
1
#
endif
#
elif
defined
(
_MSC_VER
)
|
|
defined
(
__MINGW32__
)
#
define
HB_USE_ATEXIT
1
#
elif
defined
(
__ANDROID__
)
#
define
HB_USE_ATEXIT
1
#
elif
defined
(
__APPLE__
)
#
define
HB_USE_ATEXIT
1
#
endif
#
endif
#
ifdef
HB_NO_ATEXIT
#
undef
HB_USE_ATEXIT
#
endif
#
define
HB_STMT_START
do
#
define
HB_STMT_END
while
(
0
)
template
<
unsigned
int
cond
>
class
hb_assert_constant_t
;
template
<
>
class
hb_assert_constant_t
<
1
>
{
}
;
#
define
ASSERT_STATIC_EXPR_ZERO
(
_cond
)
(
0
*
(
unsigned
int
)
sizeof
(
hb_assert_constant_t
<
_cond
>
)
)
static_assert
(
(
sizeof
(
int8_t
)
=
=
1
)
"
"
)
;
static_assert
(
(
sizeof
(
uint8_t
)
=
=
1
)
"
"
)
;
static_assert
(
(
sizeof
(
int16_t
)
=
=
2
)
"
"
)
;
static_assert
(
(
sizeof
(
uint16_t
)
=
=
2
)
"
"
)
;
static_assert
(
(
sizeof
(
int32_t
)
=
=
4
)
"
"
)
;
static_assert
(
(
sizeof
(
uint32_t
)
=
=
4
)
"
"
)
;
static_assert
(
(
sizeof
(
int64_t
)
=
=
8
)
"
"
)
;
static_assert
(
(
sizeof
(
uint64_t
)
=
=
8
)
"
"
)
;
static_assert
(
(
sizeof
(
hb_codepoint_t
)
=
=
4
)
"
"
)
;
static_assert
(
(
sizeof
(
hb_position_t
)
=
=
4
)
"
"
)
;
static_assert
(
(
sizeof
(
hb_mask_t
)
=
=
4
)
"
"
)
;
static_assert
(
(
sizeof
(
hb_var_int_t
)
=
=
4
)
"
"
)
;
#
define
_ASSERT_TYPE_POD1
(
_line
_type
)
union
_type_
#
#
_type
#
#
_on_line_
#
#
_line
#
#
_is_not_POD
{
_type
instance
;
}
#
define
_ASSERT_TYPE_POD0
(
_line
_type
)
_ASSERT_TYPE_POD1
(
_line
_type
)
#
define
ASSERT_TYPE_POD
(
_type
)
_ASSERT_TYPE_POD0
(
__LINE__
_type
)
#
ifdef
__GNUC__
#
define
_ASSERT_INSTANCE_POD1
(
_line
_instance
)
\
HB_STMT_START
{
\
typedef
__typeof__
(
_instance
)
_type_
#
#
_line
;
\
_ASSERT_TYPE_POD1
(
_line
_type_
#
#
_line
)
;
\
}
HB_STMT_END
#
else
#
define
_ASSERT_INSTANCE_POD1
(
_line
_instance
)
typedef
int
_assertion_on_line_
#
#
_line
#
#
_not_tested
#
endif
#
define
_ASSERT_INSTANCE_POD0
(
_line
_instance
)
_ASSERT_INSTANCE_POD1
(
_line
_instance
)
#
define
ASSERT_INSTANCE_POD
(
_instance
)
_ASSERT_INSTANCE_POD0
(
__LINE__
_instance
)
#
define
_ASSERT_POD1
(
_line
)
\
HB_UNUSED
inline
void
_static_assertion_on_line_
#
#
_line
(
void
)
const
\
{
_ASSERT_INSTANCE_POD1
(
_line
*
this
)
;
/
*
Make
sure
it
'
s
POD
.
*
/
}
#
define
_ASSERT_POD0
(
_line
)
_ASSERT_POD1
(
_line
)
#
define
ASSERT_POD
(
)
_ASSERT_POD0
(
__LINE__
)
#
define
HB_DISALLOW_COPY_AND_ASSIGN
(
TypeName
)
\
TypeName
(
const
TypeName
&
)
;
\
void
operator
=
(
const
TypeName
&
)
#
define
HB_NULL_POOL_SIZE
264
static_assert
(
HB_NULL_POOL_SIZE
%
sizeof
(
void
*
)
=
=
0
"
Align
HB_NULL_POOL_SIZE
.
"
)
;
#
ifdef
HB_NO_VISIBILITY
static
#
else
extern
HB_INTERNAL
#
endif
void
*
const
_hb_NullPool
[
HB_NULL_POOL_SIZE
/
sizeof
(
void
*
)
]
#
ifdef
HB_NO_VISIBILITY
=
{
}
#
endif
;
template
<
typename
Type
>
static
inline
Type
const
&
Null
(
void
)
{
static_assert
(
sizeof
(
Type
)
<
=
HB_NULL_POOL_SIZE
"
Increase
HB_NULL_POOL_SIZE
.
"
)
;
return
*
reinterpret_cast
<
Type
const
*
>
(
_hb_NullPool
)
;
}
#
define
Null
(
Type
)
Null
<
Type
>
(
)
#
define
DEFINE_NULL_DATA
(
Namespace
Type
data
)
\
}
/
*
Close
namespace
.
*
/
\
static
const
char
_Null
#
#
Type
[
sizeof
(
Namespace
:
:
Type
)
+
1
]
=
data
;
/
*
+
1
is
for
nul
-
termination
in
data
*
/
\
template
<
>
\
/
*
static
*
/
inline
const
Namespace
:
:
Type
&
Null
<
Namespace
:
:
Type
>
(
void
)
{
\
return
*
reinterpret_cast
<
const
Namespace
:
:
Type
*
>
(
_Null
#
#
Type
)
;
\
}
\
namespace
Namespace
{
\
/
*
The
following
line
really
exists
such
that
we
end
in
a
place
needing
semicolon
*
/
\
static_assert
(
Namespace
:
:
Type
:
:
min_size
+
1
<
=
sizeof
(
_Null
#
#
Type
)
"
Null
pool
too
small
.
Enlarge
.
"
)
#
ifdef
HB_NO_VISIBILITY
static
#
else
extern
HB_INTERNAL
#
endif
void
*
_hb_CrapPool
[
HB_NULL_POOL_SIZE
/
sizeof
(
void
*
)
]
#
ifdef
HB_NO_VISIBILITY
=
{
}
#
endif
;
template
<
typename
Type
>
static
inline
Type
&
Crap
(
void
)
{
static_assert
(
sizeof
(
Type
)
<
=
HB_NULL_POOL_SIZE
"
Increase
HB_NULL_POOL_SIZE
.
"
)
;
Type
*
obj
=
reinterpret_cast
<
Type
*
>
(
_hb_CrapPool
)
;
*
obj
=
Null
(
Type
)
;
return
*
obj
;
}
#
define
Crap
(
Type
)
Crap
<
Type
>
(
)
template
<
typename
Type
>
struct
CrapOrNull
{
static
inline
Type
&
get
(
void
)
{
return
Crap
(
Type
)
;
}
}
;
template
<
typename
Type
>
struct
CrapOrNull
<
const
Type
>
{
static
inline
Type
const
&
get
(
void
)
{
return
Null
(
Type
)
;
}
}
;
#
define
CrapOrNull
(
Type
)
CrapOrNull
<
Type
>
:
:
get
(
)
static
inline
bool
ISALPHA
(
unsigned
char
c
)
{
return
(
c
>
=
'
a
'
&
&
c
<
=
'
z
'
)
|
|
(
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
)
;
}
static
inline
bool
ISALNUM
(
unsigned
char
c
)
{
return
(
c
>
=
'
a
'
&
&
c
<
=
'
z
'
)
|
|
(
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
)
|
|
(
c
>
=
'
0
'
&
&
c
<
=
'
9
'
)
;
}
static
inline
bool
ISSPACE
(
unsigned
char
c
)
{
return
c
=
=
'
'
|
|
c
=
=
'
\
f
'
|
|
c
=
=
'
\
n
'
|
|
c
=
=
'
\
r
'
|
|
c
=
=
'
\
t
'
|
|
c
=
=
'
\
v
'
;
}
static
inline
unsigned
char
TOUPPER
(
unsigned
char
c
)
{
return
(
c
>
=
'
a
'
&
&
c
<
=
'
z
'
)
?
c
-
'
a
'
+
'
A
'
:
c
;
}
static
inline
unsigned
char
TOLOWER
(
unsigned
char
c
)
{
return
(
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
)
?
c
-
'
A
'
+
'
a
'
:
c
;
}
#
ifdef
NDEBUG
#
define
HB_NDEBUG
1
#
endif
template
<
typename
T
>
class
hb_assert_unsigned_t
;
template
<
>
class
hb_assert_unsigned_t
<
unsigned
char
>
{
}
;
template
<
>
class
hb_assert_unsigned_t
<
unsigned
short
>
{
}
;
template
<
>
class
hb_assert_unsigned_t
<
unsigned
int
>
{
}
;
template
<
>
class
hb_assert_unsigned_t
<
unsigned
long
>
{
}
;
template
<
typename
T
>
static
inline
bool
hb_in_range
(
T
u
T
lo
T
hi
)
{
static_assert
(
(
sizeof
(
hb_assert_unsigned_t
<
T
>
)
>
=
0
)
"
"
)
;
return
(
T
)
(
u
-
lo
)
<
=
(
T
)
(
hi
-
lo
)
;
}
template
<
typename
T
>
static
inline
bool
hb_in_ranges
(
T
u
T
lo1
T
hi1
T
lo2
T
hi2
)
{
return
hb_in_range
(
u
lo1
hi1
)
|
|
hb_in_range
(
u
lo2
hi2
)
;
}
template
<
typename
T
>
static
inline
bool
hb_in_ranges
(
T
u
T
lo1
T
hi1
T
lo2
T
hi2
T
lo3
T
hi3
)
{
return
hb_in_range
(
u
lo1
hi1
)
|
|
hb_in_range
(
u
lo2
hi2
)
|
|
hb_in_range
(
u
lo3
hi3
)
;
}
#
ifdef
_MSC_VER
#
pragma
warning
(
disable
:
4200
)
#
pragma
warning
(
disable
:
4800
)
#
endif
#
define
HB_MARK_AS_FLAG_T
(
T
)
\
extern
"
C
+
+
"
{
\
static
inline
T
operator
|
(
T
l
T
r
)
{
return
T
(
(
unsigned
)
l
|
(
unsigned
)
r
)
;
}
\
static
inline
T
operator
&
(
T
l
T
r
)
{
return
T
(
(
unsigned
)
l
&
(
unsigned
)
r
)
;
}
\
static
inline
T
operator
^
(
T
l
T
r
)
{
return
T
(
(
unsigned
)
l
^
(
unsigned
)
r
)
;
}
\
static
inline
T
operator
~
(
T
r
)
{
return
T
(
~
(
unsigned
int
)
r
)
;
}
\
static
inline
T
&
operator
|
=
(
T
&
l
T
r
)
{
l
=
l
|
r
;
return
l
;
}
\
static
inline
T
&
operator
&
=
(
T
&
l
T
r
)
{
l
=
l
&
r
;
return
l
;
}
\
static
inline
T
&
operator
^
=
(
T
&
l
T
r
)
{
l
=
l
^
r
;
return
l
;
}
\
}
#
define
FLAG
(
x
)
(
ASSERT_STATIC_EXPR_ZERO
(
(
unsigned
int
)
(
x
)
<
32
)
+
(
1U
<
<
(
unsigned
int
)
(
x
)
)
)
#
define
FLAG_UNSAFE
(
x
)
(
(
unsigned
int
)
(
x
)
<
32
?
(
1U
<
<
(
unsigned
int
)
(
x
)
)
:
0
)
#
define
FLAG_RANGE
(
x
y
)
(
ASSERT_STATIC_EXPR_ZERO
(
(
x
)
<
(
y
)
)
+
FLAG
(
y
+
1
)
-
FLAG
(
x
)
)
#
if
!
defined
(
HB_VECTOR_SIZE
)
#
define
HB_VECTOR_SIZE
0
#
endif
#
if
!
defined
(
HB_VECTOR_SIZE
)
#
if
defined
(
__GNUC__
)
&
&
(
__GNUC__
>
=
4
)
#
define
HB_VECTOR_SIZE
128
#
else
#
define
HB_VECTOR_SIZE
0
#
endif
#
endif
struct
hb_options_t
{
unsigned
int
initialized
:
1
;
unsigned
int
uniscribe_bug_compatible
:
1
;
}
;
union
hb_options_union_t
{
unsigned
int
i
;
hb_options_t
opts
;
}
;
static_assert
(
(
sizeof
(
int
)
=
=
sizeof
(
hb_options_union_t
)
)
"
"
)
;
HB_INTERNAL
void
_hb_options_init
(
void
)
;
extern
HB_INTERNAL
hb_options_union_t
_hb_options
;
static
inline
hb_options_t
hb_options
(
void
)
{
if
(
unlikely
(
!
_hb_options
.
i
)
)
_hb_options_init
(
)
;
return
_hb_options
.
opts
;
}
#
define
VAR
1
static
inline
double
_hb_round
(
double
x
)
{
if
(
x
>
=
0
)
return
floor
(
x
+
0
.
5
)
;
else
return
ceil
(
x
-
0
.
5
)
;
}
#
if
!
defined
(
HAVE_ROUND
)
&
&
!
defined
(
HAVE_DECL_ROUND
)
#
define
round
(
x
)
_hb_round
(
x
)
#
endif
static
inline
int
_hb_memalign
(
void
*
*
memptr
size_t
alignment
size_t
size
)
{
if
(
unlikely
(
0
!
=
(
alignment
&
(
alignment
-
1
)
)
|
|
!
alignment
|
|
0
!
=
(
alignment
&
(
sizeof
(
void
*
)
-
1
)
)
)
)
return
EINVAL
;
char
*
p
=
(
char
*
)
malloc
(
size
+
alignment
-
1
)
;
if
(
unlikely
(
!
p
)
)
return
ENOMEM
;
size_t
off
=
(
size_t
)
p
&
(
alignment
-
1
)
;
if
(
off
)
p
+
=
alignment
-
off
;
*
memptr
=
(
void
*
)
p
;
return
0
;
}
#
if
!
defined
(
posix_memalign
)
&
&
!
defined
(
HAVE_POSIX_MEMALIGN
)
#
define
posix_memalign
_hb_memalign
#
endif
#
include
"
hb
-
atomic
-
private
.
hh
"
#
include
"
hb
-
debug
.
hh
"
#
include
"
hb
-
dsalgs
.
hh
"
#
include
"
hb
-
mutex
-
private
.
hh
"
#
include
"
hb
-
object
-
private
.
hh
"
#
endif
