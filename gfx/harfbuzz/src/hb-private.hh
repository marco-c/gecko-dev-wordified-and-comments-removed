#
ifndef
HB_PRIVATE_HH
#
define
HB_PRIVATE_HH
#
ifdef
HAVE_CONFIG_H
#
include
"
config
.
h
"
#
endif
#
include
"
hb
.
h
"
#
define
HB_H_IN
#
ifdef
HAVE_OT
#
include
"
hb
-
ot
.
h
"
#
define
HB_OT_H_IN
#
endif
#
include
<
stdlib
.
h
>
#
include
<
stddef
.
h
>
#
include
<
string
.
h
>
#
include
<
assert
.
h
>
#
include
<
stdio
.
h
>
#
include
<
errno
.
h
>
#
include
<
stdarg
.
h
>
#
if
defined
(
hb_malloc_impl
)
\
&
&
defined
(
hb_calloc_impl
)
\
&
&
defined
(
hb_realloc_impl
)
\
&
&
defined
(
hb_free_impl
)
extern
"
C
"
void
*
hb_malloc_impl
(
size_t
size
)
;
extern
"
C
"
void
*
hb_calloc_impl
(
size_t
nmemb
size_t
size
)
;
extern
"
C
"
void
*
hb_realloc_impl
(
void
*
ptr
size_t
size
)
;
extern
"
C
"
void
hb_free_impl
(
void
*
ptr
)
;
#
define
malloc
hb_malloc_impl
#
define
calloc
hb_calloc_impl
#
define
realloc
hb_realloc_impl
#
define
free
hb_free_impl
#
endif
#
if
__cplusplus
<
201103L
const
class
{
public
:
template
<
class
T
>
operator
T
*
(
)
const
{
return
0
;
}
template
<
class
C
class
T
>
operator
T
C
:
:
*
(
)
const
{
return
0
;
}
private
:
void
operator
&
(
)
const
;
}
_hb_nullptr
=
{
}
;
#
define
nullptr
_hb_nullptr
#
ifndef
static_assert
#
define
_PASTE1
(
a
b
)
a
#
#
b
#
define
_PASTE
(
a
b
)
_PASTE1
(
a
b
)
#
define
static_assert
(
e
msg
)
\
HB_UNUSED
typedef
int
_PASTE
(
static_assertion_failed_at_line_
__LINE__
)
[
(
e
)
?
1
:
-
1
]
#
endif
#
endif
#
if
(
defined
(
__GNUC__
)
|
|
defined
(
__clang__
)
)
&
&
defined
(
__OPTIMIZE__
)
#
define
likely
(
expr
)
(
__builtin_expect
(
!
!
(
expr
)
1
)
)
#
define
unlikely
(
expr
)
(
__builtin_expect
(
!
!
(
expr
)
0
)
)
#
else
#
define
likely
(
expr
)
(
expr
)
#
define
unlikely
(
expr
)
(
expr
)
#
endif
#
if
!
defined
(
__GNUC__
)
&
&
!
defined
(
__clang__
)
#
undef
__attribute__
#
define
__attribute__
(
x
)
#
endif
#
if
__GNUC__
>
=
3
#
define
HB_PURE_FUNC
__attribute__
(
(
pure
)
)
#
define
HB_CONST_FUNC
__attribute__
(
(
const
)
)
#
define
HB_PRINTF_FUNC
(
format_idx
arg_idx
)
__attribute__
(
(
__format__
(
__printf__
format_idx
arg_idx
)
)
)
#
else
#
define
HB_PURE_FUNC
#
define
HB_CONST_FUNC
#
define
HB_PRINTF_FUNC
(
format_idx
arg_idx
)
#
endif
#
if
__GNUC__
>
=
4
#
define
HB_UNUSED
__attribute__
(
(
unused
)
)
#
else
#
define
HB_UNUSED
#
endif
#
ifndef
HB_INTERNAL
#
if
!
defined
(
__MINGW32__
)
&
&
!
defined
(
__CYGWIN__
)
#
define
HB_INTERNAL
__attribute__
(
(
__visibility__
(
"
hidden
"
)
)
)
#
else
#
define
HB_INTERNAL
#
endif
#
endif
#
if
__GNUC__
>
=
3
#
define
HB_FUNC
__PRETTY_FUNCTION__
#
elif
defined
(
_MSC_VER
)
#
define
HB_FUNC
__FUNCSIG__
#
else
#
define
HB_FUNC
__func__
#
endif
#
if
defined
(
__clang__
)
&
&
__cplusplus
>
=
201103L
#
define
HB_FALLTHROUGH
[
[
clang
:
:
fallthrough
]
]
#
elif
defined
(
_MSC_VER
)
#
include
<
sal
.
h
>
#
define
HB_FALLTHROUGH
__fallthrough
#
else
#
define
HB_FALLTHROUGH
#
endif
#
if
defined
(
_WIN32
)
|
|
defined
(
__CYGWIN__
)
#
if
defined
(
_WIN32_WINNT
)
&
&
_WIN32_WINNT
<
0x0600
#
undef
_WIN32_WINNT
#
endif
#
ifndef
_WIN32_WINNT
#
define
_WIN32_WINNT
0x0600
#
endif
#
ifndef
WIN32_LEAN_AND_MEAN
#
define
WIN32_LEAN_AND_MEAN
1
#
endif
#
ifndef
STRICT
#
define
STRICT
1
#
endif
#
if
defined
(
_WIN32_WCE
)
#
define
vsnprintf
_vsnprintf
#
define
getenv
(
Name
)
nullptr
#
if
_WIN32_WCE
<
0x800
#
define
setlocale
(
Category
Locale
)
"
C
"
static
int
errno
=
0
;
#
endif
#
elif
defined
(
WINAPI_FAMILY
)
&
&
(
WINAPI_FAMILY
=
=
WINAPI_FAMILY_PC_APP
|
|
WINAPI_FAMILY
=
=
WINAPI_FAMILY_PHONE_APP
)
#
define
getenv
(
Name
)
nullptr
#
endif
#
if
defined
(
_MSC_VER
)
&
&
_MSC_VER
<
1900
#
define
snprintf
_snprintf
#
endif
#
endif
#
if
HAVE_ATEXIT
#
if
defined
(
__linux
)
&
&
defined
(
__GLIBC_PREREQ
)
#
if
__GLIBC_PREREQ
(
2
3
)
#
define
HB_USE_ATEXIT
1
#
endif
#
elif
defined
(
_MSC_VER
)
|
|
defined
(
__MINGW32__
)
#
define
HB_USE_ATEXIT
1
#
elif
defined
(
__ANDROID__
)
&
&
(
__GNUC__
>
4
|
|
(
__GNUC__
=
=
4
&
&
__GNUC_MINOR__
>
=
6
)
)
#
define
HB_USE_ATEXIT
1
#
endif
#
endif
#
undef
MIN
template
<
typename
Type
>
static
inline
Type
MIN
(
const
Type
&
a
const
Type
&
b
)
{
return
a
<
b
?
a
:
b
;
}
#
undef
MAX
template
<
typename
Type
>
static
inline
Type
MAX
(
const
Type
&
a
const
Type
&
b
)
{
return
a
>
b
?
a
:
b
;
}
static
inline
unsigned
int
DIV_CEIL
(
const
unsigned
int
a
unsigned
int
b
)
{
return
(
a
+
(
b
-
1
)
)
/
b
;
}
#
undef
ARRAY_LENGTH
template
<
typename
Type
unsigned
int
n
>
static
inline
unsigned
int
ARRAY_LENGTH
(
const
Type
(
&
)
[
n
]
)
{
return
n
;
}
#
define
ARRAY_LENGTH_CONST
(
__array
)
(
(
signed
int
)
(
sizeof
(
__array
)
/
sizeof
(
__array
[
0
]
)
)
)
#
define
HB_STMT_START
do
#
define
HB_STMT_END
while
(
0
)
template
<
unsigned
int
cond
>
class
hb_assert_constant_t
;
template
<
>
class
hb_assert_constant_t
<
1
>
{
}
;
#
define
ASSERT_STATIC_EXPR_ZERO
(
_cond
)
(
0
*
(
unsigned
int
)
sizeof
(
hb_assert_constant_t
<
_cond
>
)
)
static_assert
(
(
sizeof
(
int8_t
)
=
=
1
)
"
"
)
;
static_assert
(
(
sizeof
(
uint8_t
)
=
=
1
)
"
"
)
;
static_assert
(
(
sizeof
(
int16_t
)
=
=
2
)
"
"
)
;
static_assert
(
(
sizeof
(
uint16_t
)
=
=
2
)
"
"
)
;
static_assert
(
(
sizeof
(
int32_t
)
=
=
4
)
"
"
)
;
static_assert
(
(
sizeof
(
uint32_t
)
=
=
4
)
"
"
)
;
static_assert
(
(
sizeof
(
int64_t
)
=
=
8
)
"
"
)
;
static_assert
(
(
sizeof
(
uint64_t
)
=
=
8
)
"
"
)
;
static_assert
(
(
sizeof
(
hb_codepoint_t
)
=
=
4
)
"
"
)
;
static_assert
(
(
sizeof
(
hb_position_t
)
=
=
4
)
"
"
)
;
static_assert
(
(
sizeof
(
hb_mask_t
)
=
=
4
)
"
"
)
;
static_assert
(
(
sizeof
(
hb_var_int_t
)
=
=
4
)
"
"
)
;
#
define
_ASSERT_TYPE_POD1
(
_line
_type
)
union
_type_
#
#
_type
#
#
_on_line_
#
#
_line
#
#
_is_not_POD
{
_type
instance
;
}
#
define
_ASSERT_TYPE_POD0
(
_line
_type
)
_ASSERT_TYPE_POD1
(
_line
_type
)
#
define
ASSERT_TYPE_POD
(
_type
)
_ASSERT_TYPE_POD0
(
__LINE__
_type
)
#
ifdef
__GNUC__
#
define
_ASSERT_INSTANCE_POD1
(
_line
_instance
)
\
HB_STMT_START
{
\
typedef
__typeof__
(
_instance
)
_type_
#
#
_line
;
\
_ASSERT_TYPE_POD1
(
_line
_type_
#
#
_line
)
;
\
}
HB_STMT_END
#
else
#
define
_ASSERT_INSTANCE_POD1
(
_line
_instance
)
typedef
int
_assertion_on_line_
#
#
_line
#
#
_not_tested
#
endif
#
define
_ASSERT_INSTANCE_POD0
(
_line
_instance
)
_ASSERT_INSTANCE_POD1
(
_line
_instance
)
#
define
ASSERT_INSTANCE_POD
(
_instance
)
_ASSERT_INSTANCE_POD0
(
__LINE__
_instance
)
#
define
_ASSERT_POD1
(
_line
)
\
HB_UNUSED
inline
void
_static_assertion_on_line_
#
#
_line
(
void
)
const
\
{
_ASSERT_INSTANCE_POD1
(
_line
*
this
)
;
/
*
Make
sure
it
'
s
POD
.
*
/
}
#
define
_ASSERT_POD0
(
_line
)
_ASSERT_POD1
(
_line
)
#
define
ASSERT_POD
(
)
_ASSERT_POD0
(
__LINE__
)
struct
_hb_void_t
{
}
;
typedef
const
_hb_void_t
*
hb_void_t
;
#
define
HB_VOID
(
(
const
_hb_void_t
*
)
nullptr
)
static
inline
HB_CONST_FUNC
unsigned
int
_hb_popcount32
(
uint32_t
mask
)
{
#
if
__GNUC__
>
3
|
|
(
__GNUC__
=
=
3
&
&
__GNUC_MINOR__
>
=
4
)
return
__builtin_popcount
(
mask
)
;
#
else
uint32_t
y
;
y
=
(
mask
>
>
1
)
&
033333333333
;
y
=
mask
-
y
-
(
(
y
>
>
1
)
&
033333333333
)
;
return
(
(
(
y
+
(
y
>
>
3
)
)
&
030707070707
)
%
077
)
;
#
endif
}
static
inline
HB_CONST_FUNC
unsigned
int
_hb_popcount64
(
uint64_t
mask
)
{
#
if
__GNUC__
>
3
|
|
(
__GNUC__
=
=
3
&
&
__GNUC_MINOR__
>
=
4
)
if
(
sizeof
(
long
)
>
=
sizeof
(
mask
)
)
return
__builtin_popcountl
(
mask
)
;
#
endif
return
_hb_popcount32
(
mask
&
0xFFFFFFFF
)
+
_hb_popcount32
(
mask
>
>
32
)
;
}
template
<
typename
T
>
static
inline
unsigned
int
_hb_popcount
(
T
mask
)
;
template
<
>
inline
unsigned
int
_hb_popcount
<
uint32_t
>
(
uint32_t
mask
)
{
return
_hb_popcount32
(
mask
)
;
}
template
<
>
inline
unsigned
int
_hb_popcount
<
uint64_t
>
(
uint64_t
mask
)
{
return
_hb_popcount64
(
mask
)
;
}
static
inline
HB_CONST_FUNC
unsigned
int
_hb_bit_storage
(
unsigned
int
number
)
{
#
if
defined
(
__GNUC__
)
&
&
(
__GNUC__
>
=
4
)
&
&
defined
(
__OPTIMIZE__
)
return
likely
(
number
)
?
(
sizeof
(
unsigned
int
)
*
8
-
__builtin_clz
(
number
)
)
:
0
;
#
else
unsigned
int
n_bits
=
0
;
while
(
number
)
{
n_bits
+
+
;
number
>
>
=
1
;
}
return
n_bits
;
#
endif
}
static
inline
HB_CONST_FUNC
unsigned
int
_hb_ctz
(
unsigned
int
number
)
{
#
if
defined
(
__GNUC__
)
&
&
(
__GNUC__
>
=
4
)
&
&
defined
(
__OPTIMIZE__
)
return
likely
(
number
)
?
__builtin_ctz
(
number
)
:
0
;
#
else
unsigned
int
n_bits
=
0
;
if
(
unlikely
(
!
number
)
)
return
0
;
while
(
!
(
number
&
1
)
)
{
n_bits
+
+
;
number
>
>
=
1
;
}
return
n_bits
;
#
endif
}
static
inline
bool
_hb_unsigned_int_mul_overflows
(
unsigned
int
count
unsigned
int
size
)
{
return
(
size
>
0
)
&
&
(
count
>
=
(
(
unsigned
int
)
-
1
)
/
size
)
;
}
typedef
int
(
*
hb_compare_func_t
)
(
const
void
*
const
void
*
)
;
#
define
HB_PREALLOCED_ARRAY_INIT
{
0
0
nullptr
}
template
<
typename
Type
unsigned
int
StaticSize
=
16
>
struct
hb_prealloced_array_t
{
unsigned
int
len
;
unsigned
int
allocated
;
Type
*
array
;
Type
static_array
[
StaticSize
]
;
void
init
(
void
)
{
len
=
0
;
allocated
=
ARRAY_LENGTH
(
static_array
)
;
array
=
static_array
;
}
inline
Type
&
operator
[
]
(
unsigned
int
i
)
{
return
array
[
i
]
;
}
inline
const
Type
&
operator
[
]
(
unsigned
int
i
)
const
{
return
array
[
i
]
;
}
inline
Type
*
push
(
void
)
{
if
(
unlikely
(
!
resize
(
len
+
1
)
)
)
return
nullptr
;
return
&
array
[
len
-
1
]
;
}
inline
bool
resize
(
unsigned
int
size
)
{
if
(
unlikely
(
size
>
allocated
)
)
{
unsigned
int
new_allocated
=
allocated
;
while
(
size
>
=
new_allocated
)
new_allocated
+
=
(
new_allocated
>
>
1
)
+
8
;
Type
*
new_array
=
nullptr
;
if
(
array
=
=
static_array
)
{
new_array
=
(
Type
*
)
calloc
(
new_allocated
sizeof
(
Type
)
)
;
if
(
new_array
)
memcpy
(
new_array
array
len
*
sizeof
(
Type
)
)
;
}
else
{
bool
overflows
=
(
new_allocated
<
allocated
)
|
|
_hb_unsigned_int_mul_overflows
(
new_allocated
sizeof
(
Type
)
)
;
if
(
likely
(
!
overflows
)
)
{
new_array
=
(
Type
*
)
realloc
(
array
new_allocated
*
sizeof
(
Type
)
)
;
}
}
if
(
unlikely
(
!
new_array
)
)
return
false
;
array
=
new_array
;
allocated
=
new_allocated
;
}
len
=
size
;
return
true
;
}
inline
void
pop
(
void
)
{
len
-
-
;
}
inline
void
remove
(
unsigned
int
i
)
{
if
(
unlikely
(
i
>
=
len
)
)
return
;
memmove
(
static_cast
<
void
*
>
(
&
array
[
i
]
)
static_cast
<
void
*
>
(
&
array
[
i
+
1
]
)
(
len
-
i
-
1
)
*
sizeof
(
Type
)
)
;
len
-
-
;
}
inline
void
shrink
(
unsigned
int
l
)
{
if
(
l
<
len
)
len
=
l
;
}
template
<
typename
T
>
inline
Type
*
find
(
T
v
)
{
for
(
unsigned
int
i
=
0
;
i
<
len
;
i
+
+
)
if
(
array
[
i
]
=
=
v
)
return
&
array
[
i
]
;
return
nullptr
;
}
template
<
typename
T
>
inline
const
Type
*
find
(
T
v
)
const
{
for
(
unsigned
int
i
=
0
;
i
<
len
;
i
+
+
)
if
(
array
[
i
]
=
=
v
)
return
&
array
[
i
]
;
return
nullptr
;
}
inline
void
qsort
(
void
)
{
:
:
qsort
(
array
len
sizeof
(
Type
)
(
hb_compare_func_t
)
Type
:
:
cmp
)
;
}
inline
void
qsort
(
unsigned
int
start
unsigned
int
end
)
{
:
:
qsort
(
array
+
start
end
-
start
sizeof
(
Type
)
(
hb_compare_func_t
)
Type
:
:
cmp
)
;
}
template
<
typename
T
>
inline
Type
*
bsearch
(
T
*
x
)
{
unsigned
int
i
;
return
bfind
(
x
&
i
)
?
&
array
[
i
]
:
nullptr
;
}
template
<
typename
T
>
inline
const
Type
*
bsearch
(
T
*
x
)
const
{
unsigned
int
i
;
return
bfind
(
x
&
i
)
?
&
array
[
i
]
:
nullptr
;
}
template
<
typename
T
>
inline
bool
bfind
(
T
*
x
unsigned
int
*
i
)
const
{
int
min
=
0
max
=
(
int
)
this
-
>
len
-
1
;
while
(
min
<
=
max
)
{
int
mid
=
(
min
+
max
)
/
2
;
int
c
=
this
-
>
array
[
mid
]
.
cmp
(
x
)
;
if
(
c
<
0
)
max
=
mid
-
1
;
else
if
(
c
>
0
)
min
=
mid
+
1
;
else
{
*
i
=
mid
;
return
true
;
}
}
if
(
max
<
0
|
|
(
max
<
(
int
)
this
-
>
len
&
&
this
-
>
array
[
max
]
.
cmp
(
x
)
>
0
)
)
max
+
+
;
*
i
=
max
;
return
false
;
}
inline
void
finish
(
void
)
{
if
(
array
!
=
static_array
)
free
(
array
)
;
array
=
nullptr
;
allocated
=
len
=
0
;
}
}
;
template
<
typename
Type
>
struct
hb_auto_array_t
:
hb_prealloced_array_t
<
Type
>
{
hb_auto_array_t
(
void
)
{
hb_prealloced_array_t
<
Type
>
:
:
init
(
)
;
}
~
hb_auto_array_t
(
void
)
{
hb_prealloced_array_t
<
Type
>
:
:
finish
(
)
;
}
}
;
#
define
HB_LOCKABLE_SET_INIT
{
HB_PREALLOCED_ARRAY_INIT
}
template
<
typename
item_t
typename
lock_t
>
struct
hb_lockable_set_t
{
hb_prealloced_array_t
<
item_t
2
>
items
;
inline
void
init
(
void
)
{
items
.
init
(
)
;
}
template
<
typename
T
>
inline
item_t
*
replace_or_insert
(
T
v
lock_t
&
l
bool
replace
)
{
l
.
lock
(
)
;
item_t
*
item
=
items
.
find
(
v
)
;
if
(
item
)
{
if
(
replace
)
{
item_t
old
=
*
item
;
*
item
=
v
;
l
.
unlock
(
)
;
old
.
finish
(
)
;
}
else
{
item
=
nullptr
;
l
.
unlock
(
)
;
}
}
else
{
item
=
items
.
push
(
)
;
if
(
likely
(
item
)
)
*
item
=
v
;
l
.
unlock
(
)
;
}
return
item
;
}
template
<
typename
T
>
inline
void
remove
(
T
v
lock_t
&
l
)
{
l
.
lock
(
)
;
item_t
*
item
=
items
.
find
(
v
)
;
if
(
item
)
{
item_t
old
=
*
item
;
*
item
=
items
[
items
.
len
-
1
]
;
items
.
pop
(
)
;
l
.
unlock
(
)
;
old
.
finish
(
)
;
}
else
{
l
.
unlock
(
)
;
}
}
template
<
typename
T
>
inline
bool
find
(
T
v
item_t
*
i
lock_t
&
l
)
{
l
.
lock
(
)
;
item_t
*
item
=
items
.
find
(
v
)
;
if
(
item
)
*
i
=
*
item
;
l
.
unlock
(
)
;
return
!
!
item
;
}
template
<
typename
T
>
inline
item_t
*
find_or_insert
(
T
v
lock_t
&
l
)
{
l
.
lock
(
)
;
item_t
*
item
=
items
.
find
(
v
)
;
if
(
!
item
)
{
item
=
items
.
push
(
)
;
if
(
likely
(
item
)
)
*
item
=
v
;
}
l
.
unlock
(
)
;
return
item
;
}
inline
void
finish
(
lock_t
&
l
)
{
if
(
!
items
.
len
)
{
items
.
finish
(
)
;
return
;
}
l
.
lock
(
)
;
while
(
items
.
len
)
{
item_t
old
=
items
[
items
.
len
-
1
]
;
items
.
pop
(
)
;
l
.
unlock
(
)
;
old
.
finish
(
)
;
l
.
lock
(
)
;
}
items
.
finish
(
)
;
l
.
unlock
(
)
;
}
}
;
static
inline
bool
ISALPHA
(
unsigned
char
c
)
{
return
(
c
>
=
'
a
'
&
&
c
<
=
'
z
'
)
|
|
(
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
)
;
}
static
inline
bool
ISALNUM
(
unsigned
char
c
)
{
return
(
c
>
=
'
a
'
&
&
c
<
=
'
z
'
)
|
|
(
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
)
|
|
(
c
>
=
'
0
'
&
&
c
<
=
'
9
'
)
;
}
static
inline
bool
ISSPACE
(
unsigned
char
c
)
{
return
c
=
=
'
'
|
|
c
=
=
'
\
f
'
|
|
c
=
=
'
\
n
'
|
|
c
=
=
'
\
r
'
|
|
c
=
=
'
\
t
'
|
|
c
=
=
'
\
v
'
;
}
static
inline
unsigned
char
TOUPPER
(
unsigned
char
c
)
{
return
(
c
>
=
'
a
'
&
&
c
<
=
'
z
'
)
?
c
-
'
a
'
+
'
A
'
:
c
;
}
static
inline
unsigned
char
TOLOWER
(
unsigned
char
c
)
{
return
(
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
)
?
c
-
'
A
'
+
'
a
'
:
c
;
}
#
define
HB_TAG_CHAR4
(
s
)
(
HB_TAG
(
(
(
const
char
*
)
s
)
[
0
]
\
(
(
const
char
*
)
s
)
[
1
]
\
(
(
const
char
*
)
s
)
[
2
]
\
(
(
const
char
*
)
s
)
[
3
]
)
)
#
define
NO_COPY
(
T
)
\
T
(
const
T
&
o
)
;
\
T
&
operator
=
(
const
T
&
o
)
#
ifdef
NDEBUG
#
define
HB_NDEBUG
#
endif
#
ifndef
HB_DEBUG
#
define
HB_DEBUG
0
#
endif
static
inline
bool
_hb_debug
(
unsigned
int
level
unsigned
int
max_level
)
{
return
level
<
max_level
;
}
#
define
DEBUG_LEVEL_ENABLED
(
WHAT
LEVEL
)
(
_hb_debug
(
(
LEVEL
)
HB_DEBUG_
#
#
WHAT
)
)
#
define
DEBUG_ENABLED
(
WHAT
)
(
DEBUG_LEVEL_ENABLED
(
WHAT
0
)
)
static
inline
void
_hb_print_func
(
const
char
*
func
)
{
if
(
func
)
{
unsigned
int
func_len
=
strlen
(
func
)
;
if
(
0
=
=
strncmp
(
func
"
static
"
7
)
)
func
+
=
7
;
if
(
0
=
=
strncmp
(
func
"
typename
"
9
)
)
func
+
=
9
;
const
char
*
space
=
strchr
(
func
'
'
)
;
if
(
space
)
func
=
space
+
1
;
const
char
*
paren
=
strchr
(
func
'
(
'
)
;
if
(
paren
)
func_len
=
paren
-
func
;
fprintf
(
stderr
"
%
.
*
s
"
func_len
func
)
;
}
}
template
<
int
max_level
>
static
inline
void
_hb_debug_msg_va
(
const
char
*
what
const
void
*
obj
const
char
*
func
bool
indented
unsigned
int
level
int
level_dir
const
char
*
message
va_list
ap
)
HB_PRINTF_FUNC
(
7
0
)
;
template
<
int
max_level
>
static
inline
void
_hb_debug_msg_va
(
const
char
*
what
const
void
*
obj
const
char
*
func
bool
indented
unsigned
int
level
int
level_dir
const
char
*
message
va_list
ap
)
{
if
(
!
_hb_debug
(
level
max_level
)
)
return
;
fprintf
(
stderr
"
%
-
10s
"
what
?
what
:
"
"
)
;
if
(
obj
)
fprintf
(
stderr
"
(
%
0
*
lx
)
"
(
unsigned
int
)
(
2
*
sizeof
(
void
*
)
)
(
unsigned
long
)
obj
)
;
else
fprintf
(
stderr
"
%
*
s
"
(
unsigned
int
)
(
2
*
sizeof
(
void
*
)
)
"
"
)
;
if
(
indented
)
{
#
define
VBAR
"
\
342
\
224
\
202
"
/
*
U
+
2502
BOX
DRAWINGS
LIGHT
VERTICAL
*
/
#
define
VRBAR
"
\
342
\
224
\
234
"
/
*
U
+
251C
BOX
DRAWINGS
LIGHT
VERTICAL
AND
RIGHT
*
/
#
define
DLBAR
"
\
342
\
225
\
256
"
/
*
U
+
256E
BOX
DRAWINGS
LIGHT
ARC
DOWN
AND
LEFT
*
/
#
define
ULBAR
"
\
342
\
225
\
257
"
/
*
U
+
256F
BOX
DRAWINGS
LIGHT
ARC
UP
AND
LEFT
*
/
#
define
LBAR
"
\
342
\
225
\
264
"
/
*
U
+
2574
BOX
DRAWINGS
LIGHT
LEFT
*
/
static
const
char
bars
[
]
=
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
VBAR
;
fprintf
(
stderr
"
%
2u
%
s
"
VRBAR
"
%
s
"
level
bars
+
sizeof
(
bars
)
-
1
-
MIN
(
(
unsigned
int
)
sizeof
(
bars
)
-
1
(
unsigned
int
)
(
sizeof
(
VBAR
)
-
1
)
*
level
)
level_dir
?
(
level_dir
>
0
?
DLBAR
:
ULBAR
)
:
LBAR
)
;
}
else
fprintf
(
stderr
"
"
VRBAR
LBAR
)
;
_hb_print_func
(
func
)
;
if
(
message
)
{
fprintf
(
stderr
"
:
"
)
;
vfprintf
(
stderr
message
ap
)
;
}
fprintf
(
stderr
"
\
n
"
)
;
}
template
<
>
inline
void
_hb_debug_msg_va
<
0
>
(
const
char
*
what
HB_UNUSED
const
void
*
obj
HB_UNUSED
const
char
*
func
HB_UNUSED
bool
indented
HB_UNUSED
unsigned
int
level
HB_UNUSED
int
level_dir
HB_UNUSED
const
char
*
message
HB_UNUSED
va_list
ap
HB_UNUSED
)
{
}
template
<
int
max_level
>
static
inline
void
_hb_debug_msg
(
const
char
*
what
const
void
*
obj
const
char
*
func
bool
indented
unsigned
int
level
int
level_dir
const
char
*
message
.
.
.
)
HB_PRINTF_FUNC
(
7
8
)
;
template
<
int
max_level
>
static
inline
void
_hb_debug_msg
(
const
char
*
what
const
void
*
obj
const
char
*
func
bool
indented
unsigned
int
level
int
level_dir
const
char
*
message
.
.
.
)
{
va_list
ap
;
va_start
(
ap
message
)
;
_hb_debug_msg_va
<
max_level
>
(
what
obj
func
indented
level
level_dir
message
ap
)
;
va_end
(
ap
)
;
}
template
<
>
inline
void
_hb_debug_msg
<
0
>
(
const
char
*
what
HB_UNUSED
const
void
*
obj
HB_UNUSED
const
char
*
func
HB_UNUSED
bool
indented
HB_UNUSED
unsigned
int
level
HB_UNUSED
int
level_dir
HB_UNUSED
const
char
*
message
HB_UNUSED
.
.
.
)
HB_PRINTF_FUNC
(
7
8
)
;
template
<
>
inline
void
_hb_debug_msg
<
0
>
(
const
char
*
what
HB_UNUSED
const
void
*
obj
HB_UNUSED
const
char
*
func
HB_UNUSED
bool
indented
HB_UNUSED
unsigned
int
level
HB_UNUSED
int
level_dir
HB_UNUSED
const
char
*
message
HB_UNUSED
.
.
.
)
{
}
#
define
DEBUG_MSG_LEVEL
(
WHAT
OBJ
LEVEL
LEVEL_DIR
.
.
.
)
_hb_debug_msg
<
HB_DEBUG_
#
#
WHAT
>
(
#
WHAT
(
OBJ
)
nullptr
true
(
LEVEL
)
(
LEVEL_DIR
)
__VA_ARGS__
)
#
define
DEBUG_MSG
(
WHAT
OBJ
.
.
.
)
_hb_debug_msg
<
HB_DEBUG_
#
#
WHAT
>
(
#
WHAT
(
OBJ
)
nullptr
false
0
0
__VA_ARGS__
)
#
define
DEBUG_MSG_FUNC
(
WHAT
OBJ
.
.
.
)
_hb_debug_msg
<
HB_DEBUG_
#
#
WHAT
>
(
#
WHAT
(
OBJ
)
HB_FUNC
false
0
0
__VA_ARGS__
)
template
<
typename
T
>
struct
hb_printer_t
{
const
char
*
print
(
const
T
&
)
{
return
"
something
"
;
}
}
;
template
<
>
struct
hb_printer_t
<
bool
>
{
const
char
*
print
(
bool
v
)
{
return
v
?
"
true
"
:
"
false
"
;
}
}
;
template
<
>
struct
hb_printer_t
<
hb_void_t
>
{
const
char
*
print
(
hb_void_t
)
{
return
"
"
;
}
}
;
template
<
typename
T
>
static
inline
void
_hb_warn_no_return
(
bool
returned
)
{
if
(
unlikely
(
!
returned
)
)
{
fprintf
(
stderr
"
OUCH
returned
with
no
call
to
return_trace
(
)
.
This
is
a
bug
please
report
.
\
n
"
)
;
}
}
template
<
>
inline
void
_hb_warn_no_return
<
hb_void_t
>
(
bool
returned
HB_UNUSED
)
{
}
template
<
int
max_level
typename
ret_t
>
struct
hb_auto_trace_t
{
explicit
inline
hb_auto_trace_t
(
unsigned
int
*
plevel_
const
char
*
what_
const
void
*
obj_
const
char
*
func
const
char
*
message
.
.
.
)
:
plevel
(
plevel_
)
what
(
what_
)
obj
(
obj_
)
returned
(
false
)
{
if
(
plevel
)
+
+
*
plevel
;
va_list
ap
;
va_start
(
ap
message
)
;
_hb_debug_msg_va
<
max_level
>
(
what
obj
func
true
plevel
?
*
plevel
:
0
+
1
message
ap
)
;
va_end
(
ap
)
;
}
inline
~
hb_auto_trace_t
(
void
)
{
_hb_warn_no_return
<
ret_t
>
(
returned
)
;
if
(
!
returned
)
{
_hb_debug_msg
<
max_level
>
(
what
obj
nullptr
true
plevel
?
*
plevel
:
1
-
1
"
"
)
;
}
if
(
plevel
)
-
-
*
plevel
;
}
inline
ret_t
ret
(
ret_t
v
unsigned
int
line
=
0
)
{
if
(
unlikely
(
returned
)
)
{
fprintf
(
stderr
"
OUCH
double
calls
to
return_trace
(
)
.
This
is
a
bug
please
report
.
\
n
"
)
;
return
v
;
}
_hb_debug_msg
<
max_level
>
(
what
obj
nullptr
true
plevel
?
*
plevel
:
1
-
1
"
return
%
s
(
line
%
d
)
"
hb_printer_t
<
ret_t
>
(
)
.
print
(
v
)
line
)
;
if
(
plevel
)
-
-
*
plevel
;
plevel
=
nullptr
;
returned
=
true
;
return
v
;
}
private
:
unsigned
int
*
plevel
;
const
char
*
what
;
const
void
*
obj
;
bool
returned
;
}
;
template
<
typename
ret_t
>
struct
hb_auto_trace_t
<
0
ret_t
>
{
explicit
inline
hb_auto_trace_t
(
unsigned
int
*
plevel_
HB_UNUSED
const
char
*
what
HB_UNUSED
const
void
*
obj
HB_UNUSED
const
char
*
func
HB_UNUSED
const
char
*
message
HB_UNUSED
.
.
.
)
{
}
inline
ret_t
ret
(
ret_t
v
unsigned
int
line
HB_UNUSED
=
0
)
{
return
v
;
}
}
;
#
define
return_trace
(
RET
)
return
trace
.
ret
(
RET
__LINE__
)
template
<
typename
T
>
class
hb_assert_unsigned_t
;
template
<
>
class
hb_assert_unsigned_t
<
unsigned
char
>
{
}
;
template
<
>
class
hb_assert_unsigned_t
<
unsigned
short
>
{
}
;
template
<
>
class
hb_assert_unsigned_t
<
unsigned
int
>
{
}
;
template
<
>
class
hb_assert_unsigned_t
<
unsigned
long
>
{
}
;
template
<
typename
T
>
static
inline
bool
hb_in_range
(
T
u
T
lo
T
hi
)
{
static_assert
(
(
sizeof
(
hb_assert_unsigned_t
<
T
>
)
>
=
0
)
"
"
)
;
return
(
T
)
(
u
-
lo
)
<
=
(
T
)
(
hi
-
lo
)
;
}
template
<
typename
T
>
static
inline
bool
hb_in_ranges
(
T
u
T
lo1
T
hi1
T
lo2
T
hi2
)
{
return
hb_in_range
(
u
lo1
hi1
)
|
|
hb_in_range
(
u
lo2
hi2
)
;
}
template
<
typename
T
>
static
inline
bool
hb_in_ranges
(
T
u
T
lo1
T
hi1
T
lo2
T
hi2
T
lo3
T
hi3
)
{
return
hb_in_range
(
u
lo1
hi1
)
|
|
hb_in_range
(
u
lo2
hi2
)
|
|
hb_in_range
(
u
lo3
hi3
)
;
}
#
ifdef
_MSC_VER
#
pragma
warning
(
disable
:
4200
)
#
pragma
warning
(
disable
:
4800
)
#
endif
#
define
HB_MARK_AS_FLAG_T
(
T
)
\
extern
"
C
+
+
"
{
\
static
inline
T
operator
|
(
T
l
T
r
)
{
return
T
(
(
unsigned
)
l
|
(
unsigned
)
r
)
;
}
\
static
inline
T
operator
&
(
T
l
T
r
)
{
return
T
(
(
unsigned
)
l
&
(
unsigned
)
r
)
;
}
\
static
inline
T
operator
^
(
T
l
T
r
)
{
return
T
(
(
unsigned
)
l
^
(
unsigned
)
r
)
;
}
\
static
inline
T
operator
~
(
T
r
)
{
return
T
(
~
(
unsigned
int
)
r
)
;
}
\
static
inline
T
&
operator
|
=
(
T
&
l
T
r
)
{
l
=
l
|
r
;
return
l
;
}
\
static
inline
T
&
operator
&
=
(
T
&
l
T
r
)
{
l
=
l
&
r
;
return
l
;
}
\
static
inline
T
&
operator
^
=
(
T
&
l
T
r
)
{
l
=
l
^
r
;
return
l
;
}
\
}
#
define
FLAG
(
x
)
(
ASSERT_STATIC_EXPR_ZERO
(
(
unsigned
int
)
(
x
)
<
32
)
+
(
1U
<
<
(
unsigned
int
)
(
x
)
)
)
#
define
FLAG_UNSAFE
(
x
)
(
(
unsigned
int
)
(
x
)
<
32
?
(
1U
<
<
(
unsigned
int
)
(
x
)
)
:
0
)
#
define
FLAG_RANGE
(
x
y
)
(
ASSERT_STATIC_EXPR_ZERO
(
(
x
)
<
(
y
)
)
+
FLAG
(
y
+
1
)
-
FLAG
(
x
)
)
template
<
typename
T
typename
T2
>
static
inline
void
hb_stable_sort
(
T
*
array
unsigned
int
len
int
(
*
compar
)
(
const
T
*
const
T
*
)
T2
*
array2
)
{
for
(
unsigned
int
i
=
1
;
i
<
len
;
i
+
+
)
{
unsigned
int
j
=
i
;
while
(
j
&
&
compar
(
&
array
[
j
-
1
]
&
array
[
i
]
)
>
0
)
j
-
-
;
if
(
i
=
=
j
)
continue
;
{
T
t
=
array
[
i
]
;
memmove
(
&
array
[
j
+
1
]
&
array
[
j
]
(
i
-
j
)
*
sizeof
(
T
)
)
;
array
[
j
]
=
t
;
}
if
(
array2
)
{
T2
t
=
array2
[
i
]
;
memmove
(
&
array2
[
j
+
1
]
&
array2
[
j
]
(
i
-
j
)
*
sizeof
(
T2
)
)
;
array2
[
j
]
=
t
;
}
}
}
template
<
typename
T
>
static
inline
void
hb_stable_sort
(
T
*
array
unsigned
int
len
int
(
*
compar
)
(
const
T
*
const
T
*
)
)
{
hb_stable_sort
(
array
len
compar
(
int
*
)
nullptr
)
;
}
static
inline
hb_bool_t
hb_codepoint_parse
(
const
char
*
s
unsigned
int
len
int
base
hb_codepoint_t
*
out
)
{
char
buf
[
64
]
;
len
=
MIN
(
ARRAY_LENGTH
(
buf
)
-
1
len
)
;
strncpy
(
buf
s
len
)
;
buf
[
len
]
=
'
\
0
'
;
char
*
end
;
errno
=
0
;
unsigned
long
v
=
strtoul
(
buf
&
end
base
)
;
if
(
errno
)
return
false
;
if
(
*
end
)
return
false
;
*
out
=
v
;
return
true
;
}
struct
HbOpOr
{
static
const
bool
passthru_left
=
true
;
static
const
bool
passthru_right
=
true
;
template
<
typename
T
>
static
void
process
(
T
&
o
const
T
&
a
const
T
&
b
)
{
o
=
a
|
b
;
}
}
;
struct
HbOpAnd
{
static
const
bool
passthru_left
=
false
;
static
const
bool
passthru_right
=
false
;
template
<
typename
T
>
static
void
process
(
T
&
o
const
T
&
a
const
T
&
b
)
{
o
=
a
&
b
;
}
}
;
struct
HbOpMinus
{
static
const
bool
passthru_left
=
true
;
static
const
bool
passthru_right
=
false
;
template
<
typename
T
>
static
void
process
(
T
&
o
const
T
&
a
const
T
&
b
)
{
o
=
a
&
~
b
;
}
}
;
struct
HbOpXor
{
static
const
bool
passthru_left
=
true
;
static
const
bool
passthru_right
=
true
;
template
<
typename
T
>
static
void
process
(
T
&
o
const
T
&
a
const
T
&
b
)
{
o
=
a
^
b
;
}
}
;
template
<
typename
elt_t
unsigned
int
byte_size
>
struct
hb_vector_size_t
{
elt_t
&
operator
[
]
(
unsigned
int
i
)
{
return
v
[
i
]
;
}
const
elt_t
&
operator
[
]
(
unsigned
int
i
)
const
{
return
v
[
i
]
;
}
template
<
class
Op
>
inline
hb_vector_size_t
process
(
const
hb_vector_size_t
&
o
)
const
{
hb_vector_size_t
r
;
for
(
unsigned
int
i
=
0
;
i
<
ARRAY_LENGTH
(
v
)
;
i
+
+
)
Op
:
:
process
(
r
.
v
[
i
]
v
[
i
]
o
.
v
[
i
]
)
;
return
r
;
}
inline
hb_vector_size_t
operator
|
(
const
hb_vector_size_t
&
o
)
const
{
return
process
<
HbOpOr
>
(
o
)
;
}
inline
hb_vector_size_t
operator
&
(
const
hb_vector_size_t
&
o
)
const
{
return
process
<
HbOpAnd
>
(
o
)
;
}
inline
hb_vector_size_t
operator
^
(
const
hb_vector_size_t
&
o
)
const
{
return
process
<
HbOpXor
>
(
o
)
;
}
inline
hb_vector_size_t
operator
~
(
)
const
{
hb_vector_size_t
r
;
for
(
unsigned
int
i
=
0
;
i
<
ARRAY_LENGTH
(
v
)
;
i
+
+
)
r
.
v
[
i
]
=
~
v
[
i
]
;
return
r
;
}
private
:
static_assert
(
byte_size
/
sizeof
(
elt_t
)
*
sizeof
(
elt_t
)
=
=
byte_size
"
"
)
;
elt_t
v
[
byte_size
/
sizeof
(
elt_t
)
]
;
}
;
#
if
defined
(
__GNUC__
)
&
&
(
__GNUC__
>
=
4
)
#
define
HAVE_VECTOR_SIZE
1
#
endif
struct
hb_options_t
{
unsigned
int
initialized
:
1
;
unsigned
int
uniscribe_bug_compatible
:
1
;
}
;
union
hb_options_union_t
{
unsigned
int
i
;
hb_options_t
opts
;
}
;
static_assert
(
(
sizeof
(
int
)
=
=
sizeof
(
hb_options_union_t
)
)
"
"
)
;
HB_INTERNAL
void
_hb_options_init
(
void
)
;
extern
HB_INTERNAL
hb_options_union_t
_hb_options
;
static
inline
hb_options_t
hb_options
(
void
)
{
if
(
unlikely
(
!
_hb_options
.
i
)
)
_hb_options_init
(
)
;
return
_hb_options
.
opts
;
}
#
define
VAR
1
#
endif
