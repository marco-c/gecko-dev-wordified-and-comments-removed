#
include
"
hb
.
hh
"
#
include
"
hb
-
face
.
hh
"
#
include
"
hb
-
blob
.
hh
"
#
include
"
hb
-
open
-
file
.
hh
"
#
include
"
hb
-
ot
-
face
.
hh
"
#
include
"
hb
-
ot
-
cmap
-
table
.
hh
"
#
include
"
hb
-
map
.
hh
"
unsigned
int
hb_face_count
(
hb_blob_t
*
blob
)
{
if
(
unlikely
(
!
blob
)
)
return
0
;
hb_blob_t
*
sanitized
=
hb_sanitize_context_t
(
)
.
sanitize_blob
<
OT
:
:
OpenTypeFontFile
>
(
hb_blob_reference
(
blob
)
)
;
const
OT
:
:
OpenTypeFontFile
&
ot
=
*
sanitized
-
>
as
<
OT
:
:
OpenTypeFontFile
>
(
)
;
unsigned
int
ret
=
ot
.
get_face_count
(
)
;
hb_blob_destroy
(
sanitized
)
;
return
ret
;
}
DEFINE_NULL_INSTANCE
(
hb_face_t
)
=
{
HB_OBJECT_HEADER_STATIC
nullptr
nullptr
nullptr
0
1000
0
}
;
hb_face_t
*
hb_face_create_for_tables
(
hb_reference_table_func_t
reference_table_func
void
*
user_data
hb_destroy_func_t
destroy
)
{
hb_face_t
*
face
;
if
(
!
reference_table_func
|
|
!
(
face
=
hb_object_create
<
hb_face_t
>
(
)
)
)
{
if
(
destroy
)
destroy
(
user_data
)
;
return
hb_face_get_empty
(
)
;
}
face
-
>
reference_table_func
=
reference_table_func
;
face
-
>
user_data
=
user_data
;
face
-
>
destroy
=
destroy
;
face
-
>
num_glyphs
=
-
1
;
face
-
>
data
.
init0
(
face
)
;
face
-
>
table
.
init0
(
face
)
;
return
face
;
}
typedef
struct
hb_face_for_data_closure_t
{
hb_blob_t
*
blob
;
uint16_t
index
;
}
hb_face_for_data_closure_t
;
static
hb_face_for_data_closure_t
*
_hb_face_for_data_closure_create
(
hb_blob_t
*
blob
unsigned
int
index
)
{
hb_face_for_data_closure_t
*
closure
;
closure
=
(
hb_face_for_data_closure_t
*
)
hb_calloc
(
1
sizeof
(
hb_face_for_data_closure_t
)
)
;
if
(
unlikely
(
!
closure
)
)
return
nullptr
;
closure
-
>
blob
=
blob
;
closure
-
>
index
=
(
uint16_t
)
(
index
&
0xFFFFu
)
;
return
closure
;
}
static
void
_hb_face_for_data_closure_destroy
(
void
*
data
)
{
hb_face_for_data_closure_t
*
closure
=
(
hb_face_for_data_closure_t
*
)
data
;
hb_blob_destroy
(
closure
-
>
blob
)
;
hb_free
(
closure
)
;
}
static
hb_blob_t
*
_hb_face_for_data_reference_table
(
hb_face_t
*
face
HB_UNUSED
hb_tag_t
tag
void
*
user_data
)
{
hb_face_for_data_closure_t
*
data
=
(
hb_face_for_data_closure_t
*
)
user_data
;
if
(
tag
=
=
HB_TAG_NONE
)
return
hb_blob_reference
(
data
-
>
blob
)
;
const
OT
:
:
OpenTypeFontFile
&
ot_file
=
*
data
-
>
blob
-
>
as
<
OT
:
:
OpenTypeFontFile
>
(
)
;
unsigned
int
base_offset
;
const
OT
:
:
OpenTypeFontFace
&
ot_face
=
ot_file
.
get_face
(
data
-
>
index
&
base_offset
)
;
const
OT
:
:
OpenTypeTable
&
table
=
ot_face
.
get_table_by_tag
(
tag
)
;
hb_blob_t
*
blob
=
hb_blob_create_sub_blob
(
data
-
>
blob
base_offset
+
table
.
offset
table
.
length
)
;
return
blob
;
}
hb_face_t
*
hb_face_create
(
hb_blob_t
*
blob
unsigned
int
index
)
{
hb_face_t
*
face
;
if
(
unlikely
(
!
blob
)
)
blob
=
hb_blob_get_empty
(
)
;
blob
=
hb_sanitize_context_t
(
)
.
sanitize_blob
<
OT
:
:
OpenTypeFontFile
>
(
hb_blob_reference
(
blob
)
)
;
hb_face_for_data_closure_t
*
closure
=
_hb_face_for_data_closure_create
(
blob
index
)
;
if
(
unlikely
(
!
closure
)
)
{
hb_blob_destroy
(
blob
)
;
return
hb_face_get_empty
(
)
;
}
face
=
hb_face_create_for_tables
(
_hb_face_for_data_reference_table
closure
_hb_face_for_data_closure_destroy
)
;
face
-
>
index
=
index
;
return
face
;
}
hb_face_t
*
hb_face_get_empty
(
)
{
return
const_cast
<
hb_face_t
*
>
(
&
Null
(
hb_face_t
)
)
;
}
hb_face_t
*
hb_face_reference
(
hb_face_t
*
face
)
{
return
hb_object_reference
(
face
)
;
}
void
hb_face_destroy
(
hb_face_t
*
face
)
{
if
(
!
hb_object_destroy
(
face
)
)
return
;
for
(
hb_face_t
:
:
plan_node_t
*
node
=
face
-
>
shape_plans
;
node
;
)
{
hb_face_t
:
:
plan_node_t
*
next
=
node
-
>
next
;
hb_shape_plan_destroy
(
node
-
>
shape_plan
)
;
hb_free
(
node
)
;
node
=
next
;
}
face
-
>
data
.
fini
(
)
;
face
-
>
table
.
fini
(
)
;
if
(
face
-
>
destroy
)
face
-
>
destroy
(
face
-
>
user_data
)
;
hb_free
(
face
)
;
}
hb_bool_t
hb_face_set_user_data
(
hb_face_t
*
face
hb_user_data_key_t
*
key
void
*
data
hb_destroy_func_t
destroy
hb_bool_t
replace
)
{
return
hb_object_set_user_data
(
face
key
data
destroy
replace
)
;
}
void
*
hb_face_get_user_data
(
const
hb_face_t
*
face
hb_user_data_key_t
*
key
)
{
return
hb_object_get_user_data
(
face
key
)
;
}
void
hb_face_make_immutable
(
hb_face_t
*
face
)
{
if
(
hb_object_is_immutable
(
face
)
)
return
;
hb_object_make_immutable
(
face
)
;
}
hb_bool_t
hb_face_is_immutable
(
const
hb_face_t
*
face
)
{
return
hb_object_is_immutable
(
face
)
;
}
hb_blob_t
*
hb_face_reference_table
(
const
hb_face_t
*
face
hb_tag_t
tag
)
{
if
(
unlikely
(
tag
=
=
HB_TAG_NONE
)
)
return
hb_blob_get_empty
(
)
;
return
face
-
>
reference_table
(
tag
)
;
}
hb_blob_t
*
hb_face_reference_blob
(
hb_face_t
*
face
)
{
return
face
-
>
reference_table
(
HB_TAG_NONE
)
;
}
void
hb_face_set_index
(
hb_face_t
*
face
unsigned
int
index
)
{
if
(
hb_object_is_immutable
(
face
)
)
return
;
face
-
>
index
=
index
;
}
unsigned
int
hb_face_get_index
(
const
hb_face_t
*
face
)
{
return
face
-
>
index
;
}
void
hb_face_set_upem
(
hb_face_t
*
face
unsigned
int
upem
)
{
if
(
hb_object_is_immutable
(
face
)
)
return
;
face
-
>
upem
=
upem
;
}
unsigned
int
hb_face_get_upem
(
const
hb_face_t
*
face
)
{
return
face
-
>
get_upem
(
)
;
}
void
hb_face_set_glyph_count
(
hb_face_t
*
face
unsigned
int
glyph_count
)
{
if
(
hb_object_is_immutable
(
face
)
)
return
;
face
-
>
num_glyphs
=
glyph_count
;
}
unsigned
int
hb_face_get_glyph_count
(
const
hb_face_t
*
face
)
{
return
face
-
>
get_num_glyphs
(
)
;
}
unsigned
int
hb_face_get_table_tags
(
const
hb_face_t
*
face
unsigned
int
start_offset
unsigned
int
*
table_count
hb_tag_t
*
table_tags
)
{
if
(
face
-
>
destroy
!
=
(
hb_destroy_func_t
)
_hb_face_for_data_closure_destroy
)
{
if
(
table_count
)
*
table_count
=
0
;
return
0
;
}
hb_face_for_data_closure_t
*
data
=
(
hb_face_for_data_closure_t
*
)
face
-
>
user_data
;
const
OT
:
:
OpenTypeFontFile
&
ot_file
=
*
data
-
>
blob
-
>
as
<
OT
:
:
OpenTypeFontFile
>
(
)
;
const
OT
:
:
OpenTypeFontFace
&
ot_face
=
ot_file
.
get_face
(
data
-
>
index
)
;
return
ot_face
.
get_table_tags
(
start_offset
table_count
table_tags
)
;
}
#
ifndef
HB_NO_FACE_COLLECT_UNICODES
void
hb_face_collect_unicodes
(
hb_face_t
*
face
hb_set_t
*
out
)
{
face
-
>
table
.
cmap
-
>
collect_unicodes
(
out
face
-
>
get_num_glyphs
(
)
)
;
}
void
hb_face_collect_variation_selectors
(
hb_face_t
*
face
hb_set_t
*
out
)
{
face
-
>
table
.
cmap
-
>
collect_variation_selectors
(
out
)
;
}
void
hb_face_collect_variation_unicodes
(
hb_face_t
*
face
hb_codepoint_t
variation_selector
hb_set_t
*
out
)
{
face
-
>
table
.
cmap
-
>
collect_variation_unicodes
(
variation_selector
out
)
;
}
#
endif
struct
face_table_info_t
{
hb_blob_t
*
data
;
unsigned
order
;
}
;
struct
hb_face_builder_data_t
{
hb_hashmap_t
<
hb_tag_t
face_table_info_t
>
tables
;
}
;
static
int
compare_entries
(
const
void
*
pa
const
void
*
pb
)
{
const
auto
&
a
=
*
(
const
hb_pair_t
<
hb_tag_t
face_table_info_t
>
*
)
pa
;
const
auto
&
b
=
*
(
const
hb_pair_t
<
hb_tag_t
face_table_info_t
>
*
)
pb
;
if
(
a
.
second
.
order
!
=
b
.
second
.
order
)
return
a
.
second
.
order
<
b
.
second
.
order
?
-
1
:
+
1
;
if
(
a
.
second
.
data
-
>
length
!
=
b
.
second
.
data
-
>
length
)
return
a
.
second
.
data
-
>
length
<
b
.
second
.
data
-
>
length
?
-
1
:
+
1
;
return
a
.
first
<
b
.
first
?
-
1
:
a
.
first
=
=
b
.
first
?
0
:
+
1
;
}
static
hb_face_builder_data_t
*
_hb_face_builder_data_create
(
)
{
hb_face_builder_data_t
*
data
=
(
hb_face_builder_data_t
*
)
hb_calloc
(
1
sizeof
(
hb_face_builder_data_t
)
)
;
if
(
unlikely
(
!
data
)
)
return
nullptr
;
data
-
>
tables
.
init
(
)
;
return
data
;
}
static
void
_hb_face_builder_data_destroy
(
void
*
user_data
)
{
hb_face_builder_data_t
*
data
=
(
hb_face_builder_data_t
*
)
user_data
;
for
(
auto
info
:
data
-
>
tables
.
values
(
)
)
hb_blob_destroy
(
info
.
data
)
;
data
-
>
tables
.
fini
(
)
;
hb_free
(
data
)
;
}
static
hb_blob_t
*
_hb_face_builder_data_reference_blob
(
hb_face_builder_data_t
*
data
)
{
unsigned
int
table_count
=
data
-
>
tables
.
get_population
(
)
;
unsigned
int
face_length
=
table_count
*
16
+
12
;
for
(
auto
info
:
data
-
>
tables
.
values
(
)
)
face_length
+
=
hb_ceil_to_4
(
hb_blob_get_length
(
info
.
data
)
)
;
char
*
buf
=
(
char
*
)
hb_malloc
(
face_length
)
;
if
(
unlikely
(
!
buf
)
)
return
nullptr
;
hb_serialize_context_t
c
(
buf
face_length
)
;
c
.
propagate_error
(
data
-
>
tables
)
;
OT
:
:
OpenTypeFontFile
*
f
=
c
.
start_serialize
<
OT
:
:
OpenTypeFontFile
>
(
)
;
bool
is_cff
=
(
data
-
>
tables
.
has
(
HB_TAG
(
'
C
'
'
F
'
'
F
'
'
'
)
)
|
|
data
-
>
tables
.
has
(
HB_TAG
(
'
C
'
'
F
'
'
F
'
'
2
'
)
)
)
;
hb_tag_t
sfnt_tag
=
is_cff
?
OT
:
:
OpenTypeFontFile
:
:
CFFTag
:
OT
:
:
OpenTypeFontFile
:
:
TrueTypeTag
;
hb_vector_t
<
hb_pair_t
<
hb_tag_t
face_table_info_t
>
>
sorted_entries
;
data
-
>
tables
.
iter
(
)
|
hb_sink
(
sorted_entries
)
;
if
(
unlikely
(
sorted_entries
.
in_error
(
)
)
)
{
hb_free
(
buf
)
;
return
nullptr
;
}
sorted_entries
.
qsort
(
compare_entries
)
;
bool
ret
=
f
-
>
serialize_single
(
&
c
sfnt_tag
+
sorted_entries
.
iter
(
)
|
hb_map
(
[
&
]
(
hb_pair_t
<
hb_tag_t
face_table_info_t
>
_
)
{
return
hb_pair_t
<
hb_tag_t
hb_blob_t
*
>
(
_
.
first
_
.
second
.
data
)
;
}
)
)
;
c
.
end_serialize
(
)
;
if
(
unlikely
(
!
ret
)
)
{
hb_free
(
buf
)
;
return
nullptr
;
}
return
hb_blob_create
(
buf
face_length
HB_MEMORY_MODE_WRITABLE
buf
hb_free
)
;
}
static
hb_blob_t
*
_hb_face_builder_reference_table
(
hb_face_t
*
face
HB_UNUSED
hb_tag_t
tag
void
*
user_data
)
{
hb_face_builder_data_t
*
data
=
(
hb_face_builder_data_t
*
)
user_data
;
if
(
!
tag
)
return
_hb_face_builder_data_reference_blob
(
data
)
;
return
hb_blob_reference
(
data
-
>
tables
[
tag
]
.
data
)
;
}
hb_face_t
*
hb_face_builder_create
(
)
{
hb_face_builder_data_t
*
data
=
_hb_face_builder_data_create
(
)
;
if
(
unlikely
(
!
data
)
)
return
hb_face_get_empty
(
)
;
return
hb_face_create_for_tables
(
_hb_face_builder_reference_table
data
_hb_face_builder_data_destroy
)
;
}
hb_bool_t
hb_face_builder_add_table
(
hb_face_t
*
face
hb_tag_t
tag
hb_blob_t
*
blob
)
{
if
(
tag
=
=
HB_MAP_VALUE_INVALID
)
return
false
;
if
(
unlikely
(
face
-
>
destroy
!
=
(
hb_destroy_func_t
)
_hb_face_builder_data_destroy
)
)
return
false
;
hb_face_builder_data_t
*
data
=
(
hb_face_builder_data_t
*
)
face
-
>
user_data
;
hb_blob_t
*
previous
=
data
-
>
tables
.
get
(
tag
)
.
data
;
if
(
!
data
-
>
tables
.
set
(
tag
face_table_info_t
{
hb_blob_reference
(
blob
)
0
}
)
)
{
hb_blob_destroy
(
blob
)
;
return
false
;
}
hb_blob_destroy
(
previous
)
;
return
true
;
}
void
hb_face_builder_sort_tables
(
hb_face_t
*
face
const
hb_tag_t
*
tags
)
{
hb_face_builder_data_t
*
data
=
(
hb_face_builder_data_t
*
)
face
-
>
user_data
;
for
(
auto
&
info
:
data
-
>
tables
.
values_ref
(
)
)
info
.
order
=
-
1
;
unsigned
order
=
0
;
for
(
const
hb_tag_t
*
tag
=
tags
;
*
tag
;
tag
+
+
)
{
face_table_info_t
*
info
;
if
(
!
data
-
>
tables
.
has
(
*
tag
&
info
)
)
continue
;
info
-
>
order
=
order
+
+
;
}
}
