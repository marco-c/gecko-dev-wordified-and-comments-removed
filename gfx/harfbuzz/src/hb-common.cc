#
include
"
hb
.
hh
"
#
include
"
hb
-
machinery
.
hh
"
#
include
<
locale
.
h
>
#
ifdef
HAVE_XLOCALE_H
#
include
<
xlocale
.
h
>
#
endif
#
ifdef
HB_NO_SETLOCALE
#
define
setlocale
(
Category
Locale
)
"
C
"
#
endif
hb_atomic_int_t
_hb_options
;
void
_hb_options_init
(
)
{
hb_options_union_t
u
;
u
.
i
=
0
;
u
.
opts
.
initialized
=
true
;
const
char
*
c
=
getenv
(
"
HB_OPTIONS
"
)
;
if
(
c
)
{
while
(
*
c
)
{
const
char
*
p
=
strchr
(
c
'
:
'
)
;
if
(
!
p
)
p
=
c
+
strlen
(
c
)
;
#
define
OPTION
(
name
symbol
)
\
if
(
0
=
=
strncmp
(
c
name
p
-
c
)
&
&
strlen
(
name
)
=
=
static_cast
<
size_t
>
(
p
-
c
)
)
do
{
u
.
opts
.
symbol
=
true
;
}
while
(
0
)
OPTION
(
"
uniscribe
-
bug
-
compatible
"
uniscribe_bug_compatible
)
;
OPTION
(
"
aat
"
aat
)
;
#
undef
OPTION
c
=
*
p
?
p
+
1
:
p
;
}
}
_hb_options
.
set_relaxed
(
u
.
i
)
;
}
hb_tag_t
hb_tag_from_string
(
const
char
*
str
int
len
)
{
char
tag
[
4
]
;
unsigned
int
i
;
if
(
!
str
|
|
!
len
|
|
!
*
str
)
return
HB_TAG_NONE
;
if
(
len
<
0
|
|
len
>
4
)
len
=
4
;
for
(
i
=
0
;
i
<
(
unsigned
)
len
&
&
str
[
i
]
;
i
+
+
)
tag
[
i
]
=
str
[
i
]
;
for
(
;
i
<
4
;
i
+
+
)
tag
[
i
]
=
'
'
;
return
HB_TAG
(
tag
[
0
]
tag
[
1
]
tag
[
2
]
tag
[
3
]
)
;
}
void
hb_tag_to_string
(
hb_tag_t
tag
char
*
buf
)
{
buf
[
0
]
=
(
char
)
(
uint8_t
)
(
tag
>
>
24
)
;
buf
[
1
]
=
(
char
)
(
uint8_t
)
(
tag
>
>
16
)
;
buf
[
2
]
=
(
char
)
(
uint8_t
)
(
tag
>
>
8
)
;
buf
[
3
]
=
(
char
)
(
uint8_t
)
(
tag
>
>
0
)
;
}
const
char
direction_strings
[
]
[
4
]
=
{
"
ltr
"
"
rtl
"
"
ttb
"
"
btt
"
}
;
hb_direction_t
hb_direction_from_string
(
const
char
*
str
int
len
)
{
if
(
unlikely
(
!
str
|
|
!
len
|
|
!
*
str
)
)
return
HB_DIRECTION_INVALID
;
char
c
=
TOLOWER
(
str
[
0
]
)
;
for
(
unsigned
int
i
=
0
;
i
<
ARRAY_LENGTH
(
direction_strings
)
;
i
+
+
)
if
(
c
=
=
direction_strings
[
i
]
[
0
]
)
return
(
hb_direction_t
)
(
HB_DIRECTION_LTR
+
i
)
;
return
HB_DIRECTION_INVALID
;
}
const
char
*
hb_direction_to_string
(
hb_direction_t
direction
)
{
if
(
likely
(
(
unsigned
int
)
(
direction
-
HB_DIRECTION_LTR
)
<
ARRAY_LENGTH
(
direction_strings
)
)
)
return
direction_strings
[
direction
-
HB_DIRECTION_LTR
]
;
return
"
invalid
"
;
}
struct
hb_language_impl_t
{
const
char
s
[
1
]
;
}
;
static
const
char
canon_map
[
256
]
=
{
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
'
-
'
0
0
'
0
'
'
1
'
'
2
'
'
3
'
'
4
'
'
5
'
'
6
'
'
7
'
'
8
'
'
9
'
0
0
0
0
0
0
0
'
a
'
'
b
'
'
c
'
'
d
'
'
e
'
'
f
'
'
g
'
'
h
'
'
i
'
'
j
'
'
k
'
'
l
'
'
m
'
'
n
'
'
o
'
'
p
'
'
q
'
'
r
'
'
s
'
'
t
'
'
u
'
'
v
'
'
w
'
'
x
'
'
y
'
'
z
'
0
0
0
0
'
-
'
0
'
a
'
'
b
'
'
c
'
'
d
'
'
e
'
'
f
'
'
g
'
'
h
'
'
i
'
'
j
'
'
k
'
'
l
'
'
m
'
'
n
'
'
o
'
'
p
'
'
q
'
'
r
'
'
s
'
'
t
'
'
u
'
'
v
'
'
w
'
'
x
'
'
y
'
'
z
'
0
0
0
0
0
}
;
static
bool
lang_equal
(
hb_language_t
v1
const
void
*
v2
)
{
const
unsigned
char
*
p1
=
(
const
unsigned
char
*
)
v1
;
const
unsigned
char
*
p2
=
(
const
unsigned
char
*
)
v2
;
while
(
*
p1
&
&
*
p1
=
=
canon_map
[
*
p2
]
)
{
p1
+
+
;
p2
+
+
;
}
return
*
p1
=
=
canon_map
[
*
p2
]
;
}
#
if
0
static
unsigned
int
lang_hash
(
const
void
*
key
)
{
const
unsigned
char
*
p
=
key
;
unsigned
int
h
=
0
;
while
(
canon_map
[
*
p
]
)
{
h
=
(
h
<
<
5
)
-
h
+
canon_map
[
*
p
]
;
p
+
+
;
}
return
h
;
}
#
endif
struct
hb_language_item_t
{
struct
hb_language_item_t
*
next
;
hb_language_t
lang
;
bool
operator
=
=
(
const
char
*
s
)
const
{
return
lang_equal
(
lang
s
)
;
}
hb_language_item_t
&
operator
=
(
const
char
*
s
)
{
size_t
len
=
strlen
(
s
)
+
1
;
lang
=
(
hb_language_t
)
malloc
(
len
)
;
if
(
likely
(
lang
)
)
{
memcpy
(
(
unsigned
char
*
)
lang
s
len
)
;
for
(
unsigned
char
*
p
=
(
unsigned
char
*
)
lang
;
*
p
;
p
+
+
)
*
p
=
canon_map
[
*
p
]
;
}
return
*
this
;
}
void
fini
(
)
{
free
(
(
void
*
)
lang
)
;
}
}
;
static
hb_atomic_ptr_t
<
hb_language_item_t
>
langs
;
#
if
HB_USE_ATEXIT
static
void
free_langs
(
)
{
retry
:
hb_language_item_t
*
first_lang
=
langs
;
if
(
unlikely
(
!
langs
.
cmpexch
(
first_lang
nullptr
)
)
)
goto
retry
;
while
(
first_lang
)
{
hb_language_item_t
*
next
=
first_lang
-
>
next
;
first_lang
-
>
fini
(
)
;
free
(
first_lang
)
;
first_lang
=
next
;
}
}
#
endif
static
hb_language_item_t
*
lang_find_or_insert
(
const
char
*
key
)
{
retry
:
hb_language_item_t
*
first_lang
=
langs
;
for
(
hb_language_item_t
*
lang
=
first_lang
;
lang
;
lang
=
lang
-
>
next
)
if
(
*
lang
=
=
key
)
return
lang
;
hb_language_item_t
*
lang
=
(
hb_language_item_t
*
)
calloc
(
1
sizeof
(
hb_language_item_t
)
)
;
if
(
unlikely
(
!
lang
)
)
return
nullptr
;
lang
-
>
next
=
first_lang
;
*
lang
=
key
;
if
(
unlikely
(
!
lang
-
>
lang
)
)
{
free
(
lang
)
;
return
nullptr
;
}
if
(
unlikely
(
!
langs
.
cmpexch
(
first_lang
lang
)
)
)
{
lang
-
>
fini
(
)
;
free
(
lang
)
;
goto
retry
;
}
#
if
HB_USE_ATEXIT
if
(
!
first_lang
)
atexit
(
free_langs
)
;
#
endif
return
lang
;
}
hb_language_t
hb_language_from_string
(
const
char
*
str
int
len
)
{
if
(
!
str
|
|
!
len
|
|
!
*
str
)
return
HB_LANGUAGE_INVALID
;
hb_language_item_t
*
item
=
nullptr
;
if
(
len
>
=
0
)
{
char
strbuf
[
64
]
;
len
=
hb_min
(
len
(
int
)
sizeof
(
strbuf
)
-
1
)
;
memcpy
(
strbuf
str
len
)
;
strbuf
[
len
]
=
'
\
0
'
;
item
=
lang_find_or_insert
(
strbuf
)
;
}
else
item
=
lang_find_or_insert
(
str
)
;
return
likely
(
item
)
?
item
-
>
lang
:
HB_LANGUAGE_INVALID
;
}
const
char
*
hb_language_to_string
(
hb_language_t
language
)
{
return
language
-
>
s
;
}
hb_language_t
hb_language_get_default
(
)
{
static
hb_atomic_ptr_t
<
hb_language_t
>
default_language
;
hb_language_t
language
=
default_language
;
if
(
unlikely
(
language
=
=
HB_LANGUAGE_INVALID
)
)
{
language
=
hb_language_from_string
(
setlocale
(
LC_CTYPE
nullptr
)
-
1
)
;
(
void
)
default_language
.
cmpexch
(
HB_LANGUAGE_INVALID
language
)
;
}
return
language
;
}
hb_script_t
hb_script_from_iso15924_tag
(
hb_tag_t
tag
)
{
if
(
unlikely
(
tag
=
=
HB_TAG_NONE
)
)
return
HB_SCRIPT_INVALID
;
tag
=
(
tag
&
0xDFDFDFDFu
)
|
0x00202020u
;
switch
(
tag
)
{
case
HB_TAG
(
'
Q
'
'
a
'
'
a
'
'
i
'
)
:
return
HB_SCRIPT_INHERITED
;
case
HB_TAG
(
'
Q
'
'
a
'
'
a
'
'
c
'
)
:
return
HB_SCRIPT_COPTIC
;
case
HB_TAG
(
'
C
'
'
y
'
'
r
'
'
s
'
)
:
return
HB_SCRIPT_CYRILLIC
;
case
HB_TAG
(
'
L
'
'
a
'
'
t
'
'
f
'
)
:
return
HB_SCRIPT_LATIN
;
case
HB_TAG
(
'
L
'
'
a
'
'
t
'
'
g
'
)
:
return
HB_SCRIPT_LATIN
;
case
HB_TAG
(
'
S
'
'
y
'
'
r
'
'
e
'
)
:
return
HB_SCRIPT_SYRIAC
;
case
HB_TAG
(
'
S
'
'
y
'
'
r
'
'
j
'
)
:
return
HB_SCRIPT_SYRIAC
;
case
HB_TAG
(
'
S
'
'
y
'
'
r
'
'
n
'
)
:
return
HB_SCRIPT_SYRIAC
;
}
if
(
(
(
uint32_t
)
tag
&
0xE0E0E0E0u
)
=
=
0x40606060u
)
return
(
hb_script_t
)
tag
;
return
HB_SCRIPT_UNKNOWN
;
}
hb_script_t
hb_script_from_string
(
const
char
*
str
int
len
)
{
return
hb_script_from_iso15924_tag
(
hb_tag_from_string
(
str
len
)
)
;
}
hb_tag_t
hb_script_to_iso15924_tag
(
hb_script_t
script
)
{
return
(
hb_tag_t
)
script
;
}
hb_direction_t
hb_script_get_horizontal_direction
(
hb_script_t
script
)
{
switch
(
(
hb_tag_t
)
script
)
{
case
HB_SCRIPT_ARABIC
:
case
HB_SCRIPT_HEBREW
:
case
HB_SCRIPT_SYRIAC
:
case
HB_SCRIPT_THAANA
:
case
HB_SCRIPT_CYPRIOT
:
case
HB_SCRIPT_KHAROSHTHI
:
case
HB_SCRIPT_PHOENICIAN
:
case
HB_SCRIPT_NKO
:
case
HB_SCRIPT_LYDIAN
:
case
HB_SCRIPT_AVESTAN
:
case
HB_SCRIPT_IMPERIAL_ARAMAIC
:
case
HB_SCRIPT_INSCRIPTIONAL_PAHLAVI
:
case
HB_SCRIPT_INSCRIPTIONAL_PARTHIAN
:
case
HB_SCRIPT_OLD_SOUTH_ARABIAN
:
case
HB_SCRIPT_OLD_TURKIC
:
case
HB_SCRIPT_SAMARITAN
:
case
HB_SCRIPT_MANDAIC
:
case
HB_SCRIPT_MEROITIC_CURSIVE
:
case
HB_SCRIPT_MEROITIC_HIEROGLYPHS
:
case
HB_SCRIPT_MANICHAEAN
:
case
HB_SCRIPT_MENDE_KIKAKUI
:
case
HB_SCRIPT_NABATAEAN
:
case
HB_SCRIPT_OLD_NORTH_ARABIAN
:
case
HB_SCRIPT_PALMYRENE
:
case
HB_SCRIPT_PSALTER_PAHLAVI
:
case
HB_SCRIPT_HATRAN
:
case
HB_SCRIPT_ADLAM
:
case
HB_SCRIPT_HANIFI_ROHINGYA
:
case
HB_SCRIPT_OLD_SOGDIAN
:
case
HB_SCRIPT_SOGDIAN
:
return
HB_DIRECTION_RTL
;
case
HB_SCRIPT_OLD_HUNGARIAN
:
case
HB_SCRIPT_OLD_ITALIC
:
case
HB_SCRIPT_RUNIC
:
return
HB_DIRECTION_INVALID
;
}
return
HB_DIRECTION_LTR
;
}
bool
hb_user_data_array_t
:
:
set
(
hb_user_data_key_t
*
key
void
*
data
hb_destroy_func_t
destroy
hb_bool_t
replace
)
{
if
(
!
key
)
return
false
;
if
(
replace
)
{
if
(
!
data
&
&
!
destroy
)
{
items
.
remove
(
key
lock
)
;
return
true
;
}
}
hb_user_data_item_t
item
=
{
key
data
destroy
}
;
bool
ret
=
!
!
items
.
replace_or_insert
(
item
lock
(
bool
)
replace
)
;
return
ret
;
}
void
*
hb_user_data_array_t
:
:
get
(
hb_user_data_key_t
*
key
)
{
hb_user_data_item_t
item
=
{
nullptr
nullptr
nullptr
}
;
return
items
.
find
(
key
&
item
lock
)
?
item
.
data
:
nullptr
;
}
void
hb_version
(
unsigned
int
*
major
unsigned
int
*
minor
unsigned
int
*
micro
)
{
*
major
=
HB_VERSION_MAJOR
;
*
minor
=
HB_VERSION_MINOR
;
*
micro
=
HB_VERSION_MICRO
;
}
const
char
*
hb_version_string
(
)
{
return
HB_VERSION_STRING
;
}
hb_bool_t
hb_version_atleast
(
unsigned
int
major
unsigned
int
minor
unsigned
int
micro
)
{
return
HB_VERSION_ATLEAST
(
major
minor
micro
)
;
}
static
bool
parse_space
(
const
char
*
*
pp
const
char
*
end
)
{
while
(
*
pp
<
end
&
&
ISSPACE
(
*
*
pp
)
)
(
*
pp
)
+
+
;
return
true
;
}
static
bool
parse_char
(
const
char
*
*
pp
const
char
*
end
char
c
)
{
parse_space
(
pp
end
)
;
if
(
*
pp
=
=
end
|
|
*
*
pp
!
=
c
)
return
false
;
(
*
pp
)
+
+
;
return
true
;
}
static
bool
parse_uint
(
const
char
*
*
pp
const
char
*
end
unsigned
int
*
pv
)
{
char
buf
[
32
]
;
unsigned
int
len
=
hb_min
(
ARRAY_LENGTH
(
buf
)
-
1
(
unsigned
int
)
(
end
-
*
pp
)
)
;
strncpy
(
buf
*
pp
len
)
;
buf
[
len
]
=
'
\
0
'
;
char
*
p
=
buf
;
char
*
pend
=
p
;
unsigned
int
v
;
errno
=
0
;
v
=
strtol
(
p
&
pend
10
)
;
if
(
errno
|
|
p
=
=
pend
)
return
false
;
*
pv
=
v
;
*
pp
+
=
pend
-
p
;
return
true
;
}
static
bool
parse_uint32
(
const
char
*
*
pp
const
char
*
end
uint32_t
*
pv
)
{
char
buf
[
32
]
;
unsigned
int
len
=
hb_min
(
ARRAY_LENGTH
(
buf
)
-
1
(
unsigned
int
)
(
end
-
*
pp
)
)
;
strncpy
(
buf
*
pp
len
)
;
buf
[
len
]
=
'
\
0
'
;
char
*
p
=
buf
;
char
*
pend
=
p
;
unsigned
int
v
;
errno
=
0
;
v
=
strtol
(
p
&
pend
10
)
;
if
(
errno
|
|
p
=
=
pend
)
return
false
;
*
pv
=
v
;
*
pp
+
=
pend
-
p
;
return
true
;
}
#
if
defined
(
HAVE_NEWLOCALE
)
&
&
defined
(
HAVE_STRTOD_L
)
#
define
USE_XLOCALE
1
#
define
HB_LOCALE_T
locale_t
#
define
HB_CREATE_LOCALE
(
locName
)
newlocale
(
LC_ALL_MASK
locName
nullptr
)
#
define
HB_FREE_LOCALE
(
loc
)
freelocale
(
loc
)
#
elif
defined
(
_MSC_VER
)
#
define
USE_XLOCALE
1
#
define
HB_LOCALE_T
_locale_t
#
define
HB_CREATE_LOCALE
(
locName
)
_create_locale
(
LC_ALL
locName
)
#
define
HB_FREE_LOCALE
(
loc
)
_free_locale
(
loc
)
#
define
strtod_l
(
a
b
c
)
_strtod_l
(
(
a
)
(
b
)
(
c
)
)
#
endif
#
ifdef
USE_XLOCALE
#
if
HB_USE_ATEXIT
static
void
free_static_C_locale
(
)
;
#
endif
static
struct
hb_C_locale_lazy_loader_t
:
hb_lazy_loader_t
<
hb_remove_pointer
<
HB_LOCALE_T
>
hb_C_locale_lazy_loader_t
>
{
static
HB_LOCALE_T
create
(
)
{
HB_LOCALE_T
C_locale
=
HB_CREATE_LOCALE
(
"
C
"
)
;
#
if
HB_USE_ATEXIT
atexit
(
free_static_C_locale
)
;
#
endif
return
C_locale
;
}
static
void
destroy
(
HB_LOCALE_T
p
)
{
HB_FREE_LOCALE
(
p
)
;
}
static
HB_LOCALE_T
get_null
(
)
{
return
nullptr
;
}
}
static_C_locale
;
#
if
HB_USE_ATEXIT
static
void
free_static_C_locale
(
)
{
static_C_locale
.
free_instance
(
)
;
}
#
endif
static
HB_LOCALE_T
get_C_locale
(
)
{
return
static_C_locale
.
get_unconst
(
)
;
}
#
endif
static
bool
parse_float
(
const
char
*
*
pp
const
char
*
end
float
*
pv
)
{
char
buf
[
32
]
;
unsigned
int
len
=
hb_min
(
ARRAY_LENGTH
(
buf
)
-
1
(
unsigned
int
)
(
end
-
*
pp
)
)
;
strncpy
(
buf
*
pp
len
)
;
buf
[
len
]
=
'
\
0
'
;
char
*
p
=
buf
;
char
*
pend
=
p
;
float
v
;
errno
=
0
;
#
ifdef
USE_XLOCALE
v
=
strtod_l
(
p
&
pend
get_C_locale
(
)
)
;
#
else
v
=
strtod
(
p
&
pend
)
;
#
endif
if
(
errno
|
|
p
=
=
pend
)
return
false
;
*
pv
=
v
;
*
pp
+
=
pend
-
p
;
return
true
;
}
static
bool
parse_bool
(
const
char
*
*
pp
const
char
*
end
uint32_t
*
pv
)
{
parse_space
(
pp
end
)
;
const
char
*
p
=
*
pp
;
while
(
*
pp
<
end
&
&
ISALPHA
(
*
*
pp
)
)
(
*
pp
)
+
+
;
if
(
*
pp
-
p
=
=
2
&
&
TOLOWER
(
p
[
0
]
)
=
=
'
o
'
&
&
TOLOWER
(
p
[
1
]
)
=
=
'
n
'
)
*
pv
=
1
;
else
if
(
*
pp
-
p
=
=
3
&
&
TOLOWER
(
p
[
0
]
)
=
=
'
o
'
&
&
TOLOWER
(
p
[
1
]
)
=
=
'
f
'
&
&
TOLOWER
(
p
[
2
]
)
=
=
'
f
'
)
*
pv
=
0
;
else
return
false
;
return
true
;
}
static
bool
parse_feature_value_prefix
(
const
char
*
*
pp
const
char
*
end
hb_feature_t
*
feature
)
{
if
(
parse_char
(
pp
end
'
-
'
)
)
feature
-
>
value
=
0
;
else
{
parse_char
(
pp
end
'
+
'
)
;
feature
-
>
value
=
1
;
}
return
true
;
}
static
bool
parse_tag
(
const
char
*
*
pp
const
char
*
end
hb_tag_t
*
tag
)
{
parse_space
(
pp
end
)
;
char
quote
=
0
;
if
(
*
pp
<
end
&
&
(
*
*
pp
=
=
'
\
'
'
|
|
*
*
pp
=
=
'
"
'
)
)
{
quote
=
*
*
pp
;
(
*
pp
)
+
+
;
}
const
char
*
p
=
*
pp
;
while
(
*
pp
<
end
&
&
(
ISALNUM
(
*
*
pp
)
|
|
*
*
pp
=
=
'
_
'
)
)
(
*
pp
)
+
+
;
if
(
p
=
=
*
pp
|
|
*
pp
-
p
>
4
)
return
false
;
*
tag
=
hb_tag_from_string
(
p
*
pp
-
p
)
;
if
(
quote
)
{
if
(
*
pp
-
p
!
=
4
)
return
false
;
if
(
*
pp
=
=
end
|
|
*
*
pp
!
=
quote
)
return
false
;
(
*
pp
)
+
+
;
}
return
true
;
}
static
bool
parse_feature_indices
(
const
char
*
*
pp
const
char
*
end
hb_feature_t
*
feature
)
{
parse_space
(
pp
end
)
;
bool
has_start
;
feature
-
>
start
=
HB_FEATURE_GLOBAL_START
;
feature
-
>
end
=
HB_FEATURE_GLOBAL_END
;
if
(
!
parse_char
(
pp
end
'
[
'
)
)
return
true
;
has_start
=
parse_uint
(
pp
end
&
feature
-
>
start
)
;
if
(
parse_char
(
pp
end
'
:
'
)
|
|
parse_char
(
pp
end
'
;
'
)
)
{
parse_uint
(
pp
end
&
feature
-
>
end
)
;
}
else
{
if
(
has_start
)
feature
-
>
end
=
feature
-
>
start
+
1
;
}
return
parse_char
(
pp
end
'
]
'
)
;
}
static
bool
parse_feature_value_postfix
(
const
char
*
*
pp
const
char
*
end
hb_feature_t
*
feature
)
{
bool
had_equal
=
parse_char
(
pp
end
'
=
'
)
;
bool
had_value
=
parse_uint32
(
pp
end
&
feature
-
>
value
)
|
|
parse_bool
(
pp
end
&
feature
-
>
value
)
;
return
!
had_equal
|
|
had_value
;
}
static
bool
parse_one_feature
(
const
char
*
*
pp
const
char
*
end
hb_feature_t
*
feature
)
{
return
parse_feature_value_prefix
(
pp
end
feature
)
&
&
parse_tag
(
pp
end
&
feature
-
>
tag
)
&
&
parse_feature_indices
(
pp
end
feature
)
&
&
parse_feature_value_postfix
(
pp
end
feature
)
&
&
parse_space
(
pp
end
)
&
&
*
pp
=
=
end
;
}
hb_bool_t
hb_feature_from_string
(
const
char
*
str
int
len
hb_feature_t
*
feature
)
{
hb_feature_t
feat
;
if
(
len
<
0
)
len
=
strlen
(
str
)
;
if
(
likely
(
parse_one_feature
(
&
str
str
+
len
&
feat
)
)
)
{
if
(
feature
)
*
feature
=
feat
;
return
true
;
}
if
(
feature
)
memset
(
feature
0
sizeof
(
*
feature
)
)
;
return
false
;
}
void
hb_feature_to_string
(
hb_feature_t
*
feature
char
*
buf
unsigned
int
size
)
{
if
(
unlikely
(
!
size
)
)
return
;
char
s
[
128
]
;
unsigned
int
len
=
0
;
if
(
feature
-
>
value
=
=
0
)
s
[
len
+
+
]
=
'
-
'
;
hb_tag_to_string
(
feature
-
>
tag
s
+
len
)
;
len
+
=
4
;
while
(
len
&
&
s
[
len
-
1
]
=
=
'
'
)
len
-
-
;
if
(
feature
-
>
start
!
=
0
|
|
feature
-
>
end
!
=
(
unsigned
int
)
-
1
)
{
s
[
len
+
+
]
=
'
[
'
;
if
(
feature
-
>
start
)
len
+
=
hb_max
(
0
snprintf
(
s
+
len
ARRAY_LENGTH
(
s
)
-
len
"
%
u
"
feature
-
>
start
)
)
;
if
(
feature
-
>
end
!
=
feature
-
>
start
+
1
)
{
s
[
len
+
+
]
=
'
:
'
;
if
(
feature
-
>
end
!
=
(
unsigned
int
)
-
1
)
len
+
=
hb_max
(
0
snprintf
(
s
+
len
ARRAY_LENGTH
(
s
)
-
len
"
%
u
"
feature
-
>
end
)
)
;
}
s
[
len
+
+
]
=
'
]
'
;
}
if
(
feature
-
>
value
>
1
)
{
s
[
len
+
+
]
=
'
=
'
;
len
+
=
hb_max
(
0
snprintf
(
s
+
len
ARRAY_LENGTH
(
s
)
-
len
"
%
u
"
feature
-
>
value
)
)
;
}
assert
(
len
<
ARRAY_LENGTH
(
s
)
)
;
len
=
hb_min
(
len
size
-
1
)
;
memcpy
(
buf
s
len
)
;
buf
[
len
]
=
'
\
0
'
;
}
static
bool
parse_variation_value
(
const
char
*
*
pp
const
char
*
end
hb_variation_t
*
variation
)
{
parse_char
(
pp
end
'
=
'
)
;
return
parse_float
(
pp
end
&
variation
-
>
value
)
;
}
static
bool
parse_one_variation
(
const
char
*
*
pp
const
char
*
end
hb_variation_t
*
variation
)
{
return
parse_tag
(
pp
end
&
variation
-
>
tag
)
&
&
parse_variation_value
(
pp
end
variation
)
&
&
parse_space
(
pp
end
)
&
&
*
pp
=
=
end
;
}
hb_bool_t
hb_variation_from_string
(
const
char
*
str
int
len
hb_variation_t
*
variation
)
{
hb_variation_t
var
;
if
(
len
<
0
)
len
=
strlen
(
str
)
;
if
(
likely
(
parse_one_variation
(
&
str
str
+
len
&
var
)
)
)
{
if
(
variation
)
*
variation
=
var
;
return
true
;
}
if
(
variation
)
memset
(
variation
0
sizeof
(
*
variation
)
)
;
return
false
;
}
void
hb_variation_to_string
(
hb_variation_t
*
variation
char
*
buf
unsigned
int
size
)
{
if
(
unlikely
(
!
size
)
)
return
;
char
s
[
128
]
;
unsigned
int
len
=
0
;
hb_tag_to_string
(
variation
-
>
tag
s
+
len
)
;
len
+
=
4
;
while
(
len
&
&
s
[
len
-
1
]
=
=
'
'
)
len
-
-
;
s
[
len
+
+
]
=
'
=
'
;
len
+
=
hb_max
(
0
snprintf
(
s
+
len
ARRAY_LENGTH
(
s
)
-
len
"
%
g
"
(
double
)
variation
-
>
value
)
)
;
assert
(
len
<
ARRAY_LENGTH
(
s
)
)
;
len
=
hb_min
(
len
size
-
1
)
;
memcpy
(
buf
s
len
)
;
buf
[
len
]
=
'
\
0
'
;
}
uint8_t
(
hb_color_get_alpha
)
(
hb_color_t
color
)
{
return
hb_color_get_alpha
(
color
)
;
}
uint8_t
(
hb_color_get_red
)
(
hb_color_t
color
)
{
return
hb_color_get_red
(
color
)
;
}
uint8_t
(
hb_color_get_green
)
(
hb_color_t
color
)
{
return
hb_color_get_green
(
color
)
;
}
uint8_t
(
hb_color_get_blue
)
(
hb_color_t
color
)
{
return
hb_color_get_blue
(
color
)
;
}
#
ifdef
HB_NO_VISIBILITY
#
undef
HB_NO_VISIBILITY
#
include
"
hb
-
static
.
cc
"
#
define
HB_NO_VISIBILITY
1
#
endif
