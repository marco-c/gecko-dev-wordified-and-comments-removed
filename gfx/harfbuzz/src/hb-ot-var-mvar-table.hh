#
ifndef
HB_OT_VAR_MVAR_TABLE_HH
#
define
HB_OT_VAR_MVAR_TABLE_HH
#
include
"
hb
-
ot
-
layout
-
common
-
private
.
hh
"
namespace
OT
{
struct
VariationValueRecord
{
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
public
:
Tag
valueTag
;
ULONG
varIdx
;
public
:
DEFINE_SIZE_STATIC
(
8
)
;
}
;
#
define
HB_OT_TAG_MVAR
HB_TAG
(
'
M
'
'
V
'
'
A
'
'
R
'
)
struct
MVAR
{
static
const
hb_tag_t
tableTag
=
HB_OT_TAG_MVAR
;
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
version
.
sanitize
(
c
)
&
&
likely
(
version
.
major
=
=
1
)
&
&
c
-
>
check_struct
(
this
)
&
&
valueRecordSize
>
=
VariationValueRecord
:
:
static_size
&
&
varStore
.
sanitize
(
c
this
)
&
&
c
-
>
check_array
(
values
valueRecordSize
valueRecordCount
)
)
;
}
inline
float
get_var
(
hb_tag_t
tag
int
*
coords
unsigned
int
coord_count
)
const
{
const
VariationValueRecord
*
record
;
record
=
(
VariationValueRecord
*
)
bsearch
(
&
tag
values
valueRecordCount
valueRecordSize
(
hb_compare_func_t
)
tag_compare
)
;
if
(
!
record
)
return
0
.
;
return
(
this
+
varStore
)
.
get_delta
(
record
-
>
varIdx
coords
coord_count
)
;
}
protected
:
static
inline
int
tag_compare
(
const
hb_tag_t
*
a
const
Tag
*
b
)
{
return
b
-
>
cmp
(
*
a
)
;
}
protected
:
FixedVersion
<
>
version
;
USHORT
reserved
;
USHORT
valueRecordSize
;
USHORT
valueRecordCount
;
OffsetTo
<
VariationStore
>
varStore
;
BYTE
values
[
VAR
]
;
public
:
DEFINE_SIZE_ARRAY
(
12
values
)
;
}
;
}
#
endif
