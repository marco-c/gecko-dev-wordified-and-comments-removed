#
ifndef
HB_OT_SHAPE_COMPLEX_KHMER_HH
#
define
HB_OT_SHAPE_COMPLEX_KHMER_HH
#
include
"
hb
.
hh
"
#
include
"
hb
-
ot
-
shape
-
complex
-
indic
.
hh
"
#
define
khmer_category
(
)
indic_category
(
)
/
*
khmer_category_t
*
/
#
define
khmer_position
(
)
indic_position
(
)
/
*
khmer_position_t
*
/
typedef
indic_category_t
khmer_category_t
;
typedef
indic_position_t
khmer_position_t
;
static
inline
khmer_position_t
matra_position_khmer
(
khmer_position_t
side
)
{
switch
(
(
int
)
side
)
{
case
POS_PRE_C
:
return
POS_PRE_M
;
case
POS_POST_C
:
case
POS_ABOVE_C
:
case
POS_BELOW_C
:
return
POS_AFTER_POST
;
default
:
return
side
;
}
;
}
static
inline
bool
is_consonant_or_vowel
(
const
hb_glyph_info_t
&
info
)
{
return
is_one_of
(
info
CONSONANT_FLAGS
|
FLAG
(
OT_V
)
)
;
}
static
inline
bool
is_coeng
(
const
hb_glyph_info_t
&
info
)
{
return
is_one_of
(
info
FLAG
(
OT_Coeng
)
)
;
}
static
inline
void
set_khmer_properties
(
hb_glyph_info_t
&
info
)
{
hb_codepoint_t
u
=
info
.
codepoint
;
unsigned
int
type
=
hb_indic_get_categories
(
u
)
;
khmer_category_t
cat
=
(
khmer_category_t
)
(
type
&
0x7Fu
)
;
khmer_position_t
pos
=
(
khmer_position_t
)
(
type
>
>
8
)
;
if
(
unlikely
(
u
=
=
0x17C6u
)
)
cat
=
OT_N
;
else
if
(
unlikely
(
hb_in_range
<
hb_codepoint_t
>
(
u
0x17CDu
0x17D1u
)
|
|
u
=
=
0x17CBu
|
|
u
=
=
0x17D3u
|
|
u
=
=
0x17DDu
)
)
{
cat
=
OT_M
;
pos
=
POS_ABOVE_C
;
}
else
if
(
unlikely
(
hb_in_range
<
hb_codepoint_t
>
(
u
0x2010u
0x2011u
)
)
)
cat
=
OT_PLACEHOLDER
;
else
if
(
unlikely
(
u
=
=
0x25CCu
)
)
cat
=
OT_DOTTEDCIRCLE
;
if
(
(
FLAG_UNSAFE
(
cat
)
&
CONSONANT_FLAGS
)
)
{
pos
=
POS_BASE_C
;
if
(
u
=
=
0x179Au
)
cat
=
OT_Ra
;
}
else
if
(
cat
=
=
OT_M
)
{
pos
=
matra_position_khmer
(
pos
)
;
}
else
if
(
(
FLAG_UNSAFE
(
cat
)
&
(
FLAG
(
OT_SM
)
|
FLAG
(
OT_A
)
|
FLAG
(
OT_Symbol
)
)
)
)
{
pos
=
POS_SMVD
;
}
info
.
khmer_category
(
)
=
cat
;
info
.
khmer_position
(
)
=
pos
;
}
#
endif
