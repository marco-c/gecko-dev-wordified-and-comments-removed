#
ifndef
HB_OT_VAR_AVAR_TABLE_HH
#
define
HB_OT_VAR_AVAR_TABLE_HH
#
include
"
hb
-
open
-
type
.
hh
"
#
include
"
hb
-
ot
-
var
-
common
.
hh
"
#
define
HB_OT_TAG_avar
HB_TAG
(
'
a
'
'
v
'
'
a
'
'
r
'
)
namespace
OT
{
struct
avarV2Tail
{
friend
struct
avar
;
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
varIdxMap
.
sanitize
(
c
base
)
&
&
varStore
.
sanitize
(
c
base
)
)
;
}
protected
:
Offset32To
<
DeltaSetIndexMap
>
varIdxMap
;
Offset32To
<
ItemVariationStore
>
varStore
;
public
:
DEFINE_SIZE_STATIC
(
8
)
;
}
;
struct
AxisValueMap
{
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
void
set_mapping
(
float
from_coord
float
to_coord
)
{
coords
[
0
]
.
set_float
(
from_coord
)
;
coords
[
1
]
.
set_float
(
to_coord
)
;
}
bool
is_outside_axis_range
(
const
Triple
&
axis_range
)
const
{
double
from_coord
=
(
double
)
coords
[
0
]
.
to_float
(
)
;
return
!
axis_range
.
contains
(
from_coord
)
;
}
bool
must_include
(
)
const
{
float
from_coord
=
coords
[
0
]
.
to_float
(
)
;
float
to_coord
=
coords
[
1
]
.
to_float
(
)
;
return
(
from_coord
=
=
-
1
.
f
&
&
to_coord
=
=
-
1
.
f
)
|
|
(
from_coord
=
=
0
.
f
&
&
to_coord
=
=
0
.
f
)
|
|
(
from_coord
=
=
1
.
f
&
&
to_coord
=
=
1
.
f
)
;
}
void
instantiate
(
const
Triple
&
axis_range
const
Triple
&
unmapped_range
const
TripleDistances
&
triple_distances
)
{
float
from_coord
=
coords
[
0
]
.
to_float
(
)
;
float
to_coord
=
coords
[
1
]
.
to_float
(
)
;
from_coord
=
renormalizeValue
(
(
double
)
from_coord
unmapped_range
triple_distances
)
;
to_coord
=
renormalizeValue
(
(
double
)
to_coord
axis_range
triple_distances
)
;
coords
[
0
]
.
set_float
(
from_coord
)
;
coords
[
1
]
.
set_float
(
to_coord
)
;
}
HB_INTERNAL
static
int
cmp
(
const
void
*
pa
const
void
*
pb
)
{
const
AxisValueMap
*
a
=
(
const
AxisValueMap
*
)
pa
;
const
AxisValueMap
*
b
=
(
const
AxisValueMap
*
)
pb
;
int
a_from
=
a
-
>
coords
[
0
]
.
to_int
(
)
;
int
b_from
=
b
-
>
coords
[
0
]
.
to_int
(
)
;
if
(
a_from
!
=
b_from
)
return
a_from
-
b_from
;
int
a_to
=
a
-
>
coords
[
1
]
.
to_int
(
)
;
int
b_to
=
b
-
>
coords
[
1
]
.
to_int
(
)
;
return
a_to
-
b_to
;
}
bool
serialize
(
hb_serialize_context_t
*
c
)
const
{
TRACE_SERIALIZE
(
this
)
;
return_trace
(
c
-
>
embed
(
this
)
)
;
}
public
:
F2DOT14
coords
[
2
]
;
public
:
DEFINE_SIZE_STATIC
(
4
)
;
}
;
struct
SegmentMaps
:
Array16Of
<
AxisValueMap
>
{
float
map_float
(
float
value
unsigned
int
from_offset
=
0
unsigned
int
to_offset
=
1
)
const
{
#
define
fromCoord
coords
[
from_offset
]
.
to_float
(
)
#
define
toCoord
coords
[
to_offset
]
.
to_float
(
)
const
auto
*
map
=
arrayZ
;
if
(
len
<
2
)
{
if
(
!
len
)
return
value
;
else
return
value
-
map
[
0
]
.
fromCoord
+
map
[
0
]
.
toCoord
;
}
unsigned
start
=
0
;
unsigned
end
=
len
;
if
(
map
[
start
]
.
fromCoord
=
=
-
1
&
&
map
[
start
]
.
toCoord
=
=
-
1
&
&
map
[
start
+
1
]
.
fromCoord
=
=
-
1
)
start
+
+
;
if
(
map
[
end
-
1
]
.
fromCoord
=
=
+
1
&
&
map
[
end
-
1
]
.
toCoord
=
=
+
1
&
&
map
[
end
-
2
]
.
fromCoord
=
=
+
1
)
end
-
-
;
unsigned
i
;
for
(
i
=
start
;
i
<
end
;
i
+
+
)
if
(
value
=
=
map
[
i
]
.
fromCoord
)
break
;
if
(
i
<
end
)
{
unsigned
j
=
i
;
for
(
;
j
+
1
<
end
;
j
+
+
)
if
(
value
!
=
map
[
j
+
1
]
.
fromCoord
)
break
;
if
(
i
=
=
j
)
return
map
[
i
]
.
toCoord
;
if
(
i
+
2
=
=
j
)
return
map
[
i
+
1
]
.
toCoord
;
if
(
value
<
0
)
return
map
[
j
]
.
toCoord
;
if
(
value
>
0
)
return
map
[
i
]
.
toCoord
;
return
fabsf
(
map
[
i
]
.
toCoord
)
<
fabsf
(
map
[
j
]
.
toCoord
)
?
map
[
i
]
.
toCoord
:
map
[
j
]
.
toCoord
;
if
(
map
[
i
]
.
toCoord
=
=
0
)
return
map
[
j
]
.
toCoord
;
else
return
map
[
i
]
.
toCoord
;
}
for
(
i
=
start
;
i
<
end
;
i
+
+
)
if
(
value
<
map
[
i
]
.
fromCoord
)
break
;
if
(
i
=
=
0
)
{
return
value
-
map
[
0
]
.
fromCoord
+
map
[
0
]
.
toCoord
;
}
if
(
i
=
=
end
)
{
return
value
-
map
[
end
-
1
]
.
fromCoord
+
map
[
end
-
1
]
.
toCoord
;
}
auto
&
before
=
map
[
i
-
1
]
;
auto
&
after
=
map
[
i
]
;
float
denom
=
after
.
fromCoord
-
before
.
fromCoord
;
return
before
.
toCoord
+
(
(
after
.
toCoord
-
before
.
toCoord
)
*
(
value
-
before
.
fromCoord
)
)
/
denom
;
#
undef
toCoord
#
undef
fromCoord
}
float
unmap_float
(
float
value
)
const
{
return
map_float
(
value
1
0
)
;
}
Triple
unmap_axis_range
(
const
Triple
&
axis_range
)
const
{
float
unmapped_min
=
unmap_float
(
axis_range
.
minimum
)
;
float
unmapped_middle
=
unmap_float
(
axis_range
.
middle
)
;
float
unmapped_max
=
unmap_float
(
axis_range
.
maximum
)
;
return
Triple
{
(
double
)
unmapped_min
(
double
)
unmapped_middle
(
double
)
unmapped_max
}
;
}
bool
subset
(
hb_subset_context_t
*
c
hb_tag_t
axis_tag
)
const
{
TRACE_SUBSET
(
this
)
;
Triple
*
axis_range
;
if
(
!
c
-
>
plan
-
>
axes_location
.
has
(
axis_tag
&
axis_range
)
)
return
c
-
>
serializer
-
>
embed
(
*
this
)
;
TripleDistances
*
axis_triple_distances
;
if
(
!
c
-
>
plan
-
>
axes_triple_distances
.
has
(
axis_tag
&
axis_triple_distances
)
)
return_trace
(
false
)
;
auto
*
out
=
c
-
>
serializer
-
>
start_embed
(
this
)
;
if
(
unlikely
(
!
c
-
>
serializer
-
>
extend_min
(
out
)
)
)
return_trace
(
false
)
;
Triple
unmapped_range
=
unmap_axis_range
(
*
axis_range
)
;
hb_vector_t
<
AxisValueMap
>
value_mappings
;
for
(
const
auto
&
_
:
as_array
(
)
)
{
if
(
_
.
is_outside_axis_range
(
unmapped_range
)
)
continue
;
AxisValueMap
mapping
;
mapping
=
_
;
mapping
.
instantiate
(
*
axis_range
unmapped_range
*
axis_triple_distances
)
;
if
(
mapping
.
must_include
(
)
)
continue
;
value_mappings
.
push
(
mapping
)
;
}
AxisValueMap
m
;
m
.
set_mapping
(
-
1
.
f
-
1
.
f
)
;
value_mappings
.
push
(
m
)
;
m
.
set_mapping
(
0
.
f
0
.
f
)
;
value_mappings
.
push
(
m
)
;
m
.
set_mapping
(
1
.
f
1
.
f
)
;
value_mappings
.
push
(
m
)
;
value_mappings
.
qsort
(
)
;
for
(
const
auto
&
_
:
value_mappings
)
{
if
(
!
_
.
serialize
(
c
-
>
serializer
)
)
return_trace
(
false
)
;
}
return_trace
(
c
-
>
serializer
-
>
check_assign
(
out
-
>
len
value_mappings
.
length
HB_SERIALIZE_ERROR_INT_OVERFLOW
)
)
;
}
public
:
DEFINE_SIZE_ARRAY
(
2
*
this
)
;
}
;
struct
avar
{
static
constexpr
hb_tag_t
tableTag
=
HB_OT_TAG_avar
;
bool
has_data
(
)
const
{
return
version
.
to_int
(
)
;
}
const
SegmentMaps
*
get_segment_maps
(
)
const
{
return
&
firstAxisSegmentMaps
;
}
unsigned
get_axis_count
(
)
const
{
return
axisCount
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
!
(
version
.
sanitize
(
c
)
&
&
hb_barrier
(
)
&
&
(
version
.
major
=
=
1
#
ifndef
HB_NO_AVAR2
|
|
version
.
major
=
=
2
#
endif
)
&
&
c
-
>
check_struct
(
this
)
)
)
return_trace
(
false
)
;
const
SegmentMaps
*
map
=
&
firstAxisSegmentMaps
;
unsigned
int
count
=
axisCount
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
unlikely
(
!
map
-
>
sanitize
(
c
)
)
)
return_trace
(
false
)
;
map
=
&
StructAfter
<
SegmentMaps
>
(
*
map
)
;
}
#
ifndef
HB_NO_AVAR2
if
(
version
.
major
<
2
)
return_trace
(
true
)
;
hb_barrier
(
)
;
const
auto
&
v2
=
*
(
const
avarV2Tail
*
)
map
;
if
(
unlikely
(
!
v2
.
sanitize
(
c
this
)
)
)
return_trace
(
false
)
;
#
endif
return_trace
(
true
)
;
}
void
map_coords_16_16
(
int
*
coords
unsigned
int
coords_length
)
const
{
unsigned
int
count
=
hb_min
(
coords_length
axisCount
)
;
const
SegmentMaps
*
map
=
&
firstAxisSegmentMaps
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
coords
[
i
]
=
roundf
(
map
-
>
map_float
(
coords
[
i
]
/
65536
.
f
)
*
65536
.
f
)
;
map
=
&
StructAfter
<
SegmentMaps
>
(
*
map
)
;
}
#
ifndef
HB_NO_AVAR2
if
(
version
.
major
<
2
)
return
;
hb_barrier
(
)
;
for
(
;
count
<
axisCount
;
count
+
+
)
map
=
&
StructAfter
<
SegmentMaps
>
(
*
map
)
;
const
auto
&
v2
=
*
(
const
avarV2Tail
*
)
map
;
const
auto
&
varidx_map
=
this
+
v2
.
varIdxMap
;
const
auto
&
var_store
=
this
+
v2
.
varStore
;
auto
*
var_store_cache
=
var_store
.
create_cache
(
)
;
hb_vector_t
<
int
>
out
;
out
.
alloc
(
coords_length
)
;
for
(
unsigned
i
=
0
;
i
<
coords_length
;
i
+
+
)
{
int
v
=
coords
[
i
]
;
uint32_t
varidx
=
varidx_map
.
map
(
i
)
;
float
delta
=
var_store
.
get_delta
(
varidx
coords
coords_length
var_store_cache
)
;
v
+
=
roundf
(
delta
*
4
)
;
v
=
hb_clamp
(
v
-
(
1
<
<
16
)
+
(
1
<
<
16
)
)
;
out
.
push
(
v
)
;
}
for
(
unsigned
i
=
0
;
i
<
coords_length
;
i
+
+
)
coords
[
i
]
=
out
[
i
]
;
OT
:
:
ItemVariationStore
:
:
destroy_cache
(
var_store_cache
)
;
#
endif
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
unsigned
retained_axis_count
=
c
-
>
plan
-
>
axes_index_map
.
get_population
(
)
;
if
(
!
retained_axis_count
)
return_trace
(
false
)
;
avar
*
out
=
c
-
>
serializer
-
>
allocate_min
<
avar
>
(
)
;
if
(
unlikely
(
!
out
)
)
return_trace
(
false
)
;
out
-
>
version
.
major
=
1
;
out
-
>
version
.
minor
=
0
;
if
(
!
c
-
>
serializer
-
>
check_assign
(
out
-
>
axisCount
retained_axis_count
HB_SERIALIZE_ERROR_INT_OVERFLOW
)
)
return_trace
(
false
)
;
const
hb_map_t
&
axes_index_map
=
c
-
>
plan
-
>
axes_index_map
;
const
SegmentMaps
*
map
=
&
firstAxisSegmentMaps
;
unsigned
count
=
axisCount
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
axes_index_map
.
has
(
i
)
)
{
hb_tag_t
*
axis_tag
;
if
(
!
c
-
>
plan
-
>
axes_old_index_tag_map
.
has
(
i
&
axis_tag
)
)
return_trace
(
false
)
;
if
(
!
map
-
>
subset
(
c
*
axis_tag
)
)
return_trace
(
false
)
;
}
map
=
&
StructAfter
<
SegmentMaps
>
(
*
map
)
;
}
return_trace
(
true
)
;
}
protected
:
FixedVersion
<
>
version
;
HBUINT16
reserved
;
HBUINT16
axisCount
;
SegmentMaps
firstAxisSegmentMaps
;
public
:
DEFINE_SIZE_MIN
(
8
)
;
}
;
}
#
endif
