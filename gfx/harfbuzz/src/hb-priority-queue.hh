#
ifndef
HB_PRIORITY_QUEUE_HH
#
define
HB_PRIORITY_QUEUE_HH
#
include
"
hb
.
hh
"
#
include
"
hb
-
vector
.
hh
"
struct
hb_priority_queue_t
{
HB_DELETE_COPY_ASSIGN
(
hb_priority_queue_t
)
;
hb_priority_queue_t
(
)
{
init
(
)
;
}
~
hb_priority_queue_t
(
)
{
fini
(
)
;
}
private
:
typedef
hb_pair_t
<
int64_t
unsigned
>
item_t
;
hb_vector_t
<
item_t
>
heap
;
public
:
void
init
(
)
{
heap
.
init
(
)
;
}
void
fini
(
)
{
heap
.
fini
(
)
;
}
void
reset
(
)
{
heap
.
resize
(
0
)
;
}
bool
in_error
(
)
const
{
return
heap
.
in_error
(
)
;
}
void
insert
(
int64_t
priority
unsigned
value
)
{
heap
.
push
(
item_t
(
priority
value
)
)
;
bubble_up
(
heap
.
length
-
1
)
;
}
item_t
pop_minimum
(
)
{
item_t
result
=
heap
[
0
]
;
heap
[
0
]
=
heap
[
heap
.
length
-
1
]
;
heap
.
shrink
(
heap
.
length
-
1
)
;
bubble_down
(
0
)
;
return
result
;
}
const
item_t
&
minimum
(
)
{
return
heap
[
0
]
;
}
bool
is_empty
(
)
const
{
return
heap
.
length
=
=
0
;
}
explicit
operator
bool
(
)
const
{
return
!
is_empty
(
)
;
}
unsigned
int
get_population
(
)
const
{
return
heap
.
length
;
}
hb_priority_queue_t
&
operator
<
<
(
item_t
item
)
{
insert
(
item
.
first
item
.
second
)
;
return
*
this
;
}
private
:
static
constexpr
unsigned
parent
(
unsigned
index
)
{
return
(
index
-
1
)
/
2
;
}
static
constexpr
unsigned
left_child
(
unsigned
index
)
{
return
2
*
index
+
1
;
}
static
constexpr
unsigned
right_child
(
unsigned
index
)
{
return
2
*
index
+
2
;
}
void
bubble_down
(
unsigned
index
)
{
unsigned
left
=
left_child
(
index
)
;
unsigned
right
=
right_child
(
index
)
;
bool
has_left
=
left
<
heap
.
length
;
if
(
!
has_left
)
return
;
bool
has_right
=
right
<
heap
.
length
;
if
(
heap
[
index
]
.
first
<
=
heap
[
left
]
.
first
&
&
(
!
has_right
|
|
heap
[
index
]
.
first
<
=
heap
[
right
]
.
first
)
)
return
;
if
(
!
has_right
|
|
heap
[
left
]
.
first
<
heap
[
right
]
.
first
)
{
swap
(
index
left
)
;
bubble_down
(
left
)
;
return
;
}
swap
(
index
right
)
;
bubble_down
(
right
)
;
}
void
bubble_up
(
unsigned
index
)
{
if
(
index
=
=
0
)
return
;
unsigned
parent_index
=
parent
(
index
)
;
if
(
heap
[
parent_index
]
.
first
<
=
heap
[
index
]
.
first
)
return
;
swap
(
index
parent_index
)
;
bubble_up
(
parent_index
)
;
}
void
swap
(
unsigned
a
unsigned
b
)
{
item_t
temp
=
heap
[
a
]
;
heap
[
a
]
=
heap
[
b
]
;
heap
[
b
]
=
temp
;
}
}
;
#
endif
