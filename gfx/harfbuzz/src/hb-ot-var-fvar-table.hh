#
ifndef
HB_OT_VAR_FVAR_TABLE_HH
#
define
HB_OT_VAR_FVAR_TABLE_HH
#
include
"
hb
-
open
-
type
-
private
.
hh
"
#
define
HB_OT_TAG_fvar
HB_TAG
(
'
f
'
'
v
'
'
a
'
'
r
'
)
namespace
OT
{
struct
InstanceRecord
{
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
unsigned
int
axis_count
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
c
-
>
check_array
(
coordinates
coordinates
[
0
]
.
static_size
axis_count
)
)
;
}
protected
:
NameID
subfamilyNameID
;
HBUINT16
reserved
;
Fixed
coordinates
[
VAR
]
;
public
:
DEFINE_SIZE_ARRAY
(
4
coordinates
)
;
}
;
struct
AxisRecord
{
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
public
:
Tag
axisTag
;
Fixed
minValue
;
Fixed
defaultValue
;
Fixed
maxValue
;
HBUINT16
reserved
;
NameID
axisNameID
;
public
:
DEFINE_SIZE_STATIC
(
20
)
;
}
;
struct
fvar
{
static
const
hb_tag_t
tableTag
=
HB_OT_TAG_fvar
;
inline
bool
has_data
(
void
)
const
{
return
version
.
to_int
(
)
!
=
0
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
version
.
sanitize
(
c
)
&
&
likely
(
version
.
major
=
=
1
)
&
&
c
-
>
check_struct
(
this
)
&
&
instanceSize
>
=
axisCount
*
4
+
4
&
&
axisSize
<
=
1024
&
&
instanceSize
<
=
1024
&
&
c
-
>
check_range
(
this
things
)
&
&
c
-
>
check_range
(
&
StructAtOffset
<
char
>
(
this
things
)
axisCount
*
axisSize
+
instanceCount
*
instanceSize
)
)
;
}
inline
unsigned
int
get_axis_count
(
void
)
const
{
return
axisCount
;
}
inline
bool
get_axis
(
unsigned
int
index
hb_ot_var_axis_t
*
info
)
const
{
if
(
unlikely
(
index
>
=
axisCount
)
)
return
false
;
if
(
info
)
{
const
AxisRecord
&
axis
=
get_axes
(
)
[
index
]
;
info
-
>
tag
=
axis
.
axisTag
;
info
-
>
name_id
=
axis
.
axisNameID
;
info
-
>
default_value
=
axis
.
defaultValue
/
65536
.
;
info
-
>
min_value
=
MIN
<
float
>
(
info
-
>
default_value
axis
.
minValue
/
65536
.
)
;
info
-
>
max_value
=
MAX
<
float
>
(
info
-
>
default_value
axis
.
maxValue
/
65536
.
)
;
}
return
true
;
}
inline
unsigned
int
get_axis_infos
(
unsigned
int
start_offset
unsigned
int
*
axes_count
hb_ot_var_axis_t
*
axes_array
)
const
{
if
(
axes_count
)
{
unsigned
int
count
=
axisCount
;
start_offset
=
MIN
(
start_offset
count
)
;
count
-
=
start_offset
;
axes_array
+
=
start_offset
;
count
=
MIN
(
count
*
axes_count
)
;
*
axes_count
=
count
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
get_axis
(
start_offset
+
i
axes_array
+
i
)
;
}
return
axisCount
;
}
inline
bool
find_axis
(
hb_tag_t
tag
unsigned
int
*
index
hb_ot_var_axis_t
*
info
)
const
{
const
AxisRecord
*
axes
=
get_axes
(
)
;
unsigned
int
count
=
get_axis_count
(
)
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
if
(
axes
[
i
]
.
axisTag
=
=
tag
)
{
if
(
index
)
*
index
=
i
;
return
get_axis
(
i
info
)
;
}
if
(
index
)
*
index
=
HB_OT_VAR_NO_AXIS_INDEX
;
return
false
;
}
inline
int
normalize_axis_value
(
unsigned
int
axis_index
float
v
)
const
{
hb_ot_var_axis_t
axis
;
if
(
!
get_axis
(
axis_index
&
axis
)
)
return
0
;
v
=
MAX
(
MIN
(
v
axis
.
max_value
)
axis
.
min_value
)
;
if
(
v
=
=
axis
.
default_value
)
return
0
;
else
if
(
v
<
axis
.
default_value
)
v
=
(
v
-
axis
.
default_value
)
/
(
axis
.
default_value
-
axis
.
min_value
)
;
else
v
=
(
v
-
axis
.
default_value
)
/
(
axis
.
max_value
-
axis
.
default_value
)
;
return
(
int
)
(
v
*
16384
.
+
(
v
>
=
0
.
?
.
5
:
-
.
5
)
)
;
}
protected
:
inline
const
AxisRecord
*
get_axes
(
void
)
const
{
return
&
StructAtOffset
<
AxisRecord
>
(
this
things
)
;
}
inline
const
InstanceRecord
*
get_instances
(
void
)
const
{
return
&
StructAtOffset
<
InstanceRecord
>
(
get_axes
(
)
+
axisCount
0
)
;
}
protected
:
FixedVersion
<
>
version
;
Offset16
things
;
HBUINT16
reserved
;
HBUINT16
axisCount
;
HBUINT16
axisSize
;
HBUINT16
instanceCount
;
HBUINT16
instanceSize
;
public
:
DEFINE_SIZE_STATIC
(
16
)
;
}
;
}
#
endif
