#
ifndef
HB_OT_VAR_FVAR_TABLE_HH
#
define
HB_OT_VAR_FVAR_TABLE_HH
#
include
"
hb
-
open
-
type
.
hh
"
#
define
HB_OT_TAG_fvar
HB_TAG
(
'
f
'
'
v
'
'
a
'
'
r
'
)
namespace
OT
{
struct
InstanceRecord
{
friend
struct
fvar
;
hb_array_t
<
const
F16DOT16
>
get_coordinates
(
unsigned
int
axis_count
)
const
{
return
coordinatesZ
.
as_array
(
axis_count
)
;
}
bool
subset
(
hb_subset_context_t
*
c
unsigned
axis_count
bool
has_postscript_nameid
)
const
{
TRACE_SUBSET
(
this
)
;
if
(
unlikely
(
!
c
-
>
serializer
-
>
embed
(
subfamilyNameID
)
)
)
return_trace
(
false
)
;
if
(
unlikely
(
!
c
-
>
serializer
-
>
embed
(
flags
)
)
)
return_trace
(
false
)
;
const
hb_array_t
<
const
F16DOT16
>
coords
=
get_coordinates
(
axis_count
)
;
const
hb_hashmap_t
<
hb_tag_t
float
>
*
axes_location
=
&
c
-
>
plan
-
>
user_axes_location
;
for
(
unsigned
i
=
0
;
i
<
axis_count
;
i
+
+
)
{
uint32_t
*
axis_tag
;
if
(
!
c
-
>
plan
-
>
axes_old_index_tag_map
.
has
(
i
&
axis_tag
)
)
continue
;
if
(
axes_location
-
>
has
(
*
axis_tag
)
&
&
fabsf
(
axes_location
-
>
get
(
*
axis_tag
)
-
coords
[
i
]
.
to_float
(
)
)
>
0
.
001f
)
return_trace
(
false
)
;
if
(
!
c
-
>
plan
-
>
axes_index_map
.
has
(
i
)
)
continue
;
if
(
!
c
-
>
serializer
-
>
embed
(
coords
[
i
]
)
)
return_trace
(
false
)
;
}
if
(
has_postscript_nameid
)
{
NameID
name_id
;
name_id
=
StructAfter
<
NameID
>
(
coords
)
;
if
(
!
c
-
>
serializer
-
>
embed
(
name_id
)
)
return_trace
(
false
)
;
}
return_trace
(
true
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
unsigned
int
axis_count
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
c
-
>
check_array
(
coordinatesZ
.
arrayZ
axis_count
)
)
;
}
protected
:
NameID
subfamilyNameID
;
HBUINT16
flags
;
UnsizedArrayOf
<
F16DOT16
>
coordinatesZ
;
public
:
DEFINE_SIZE_UNBOUNDED
(
4
)
;
}
;
struct
AxisRecord
{
int
cmp
(
hb_tag_t
key
)
const
{
return
axisTag
.
cmp
(
key
)
;
}
enum
{
AXIS_FLAG_HIDDEN
=
0x0001
}
;
#
ifndef
HB_DISABLE_DEPRECATED
void
get_axis_deprecated
(
hb_ot_var_axis_t
*
info
)
const
{
info
-
>
tag
=
axisTag
;
info
-
>
name_id
=
axisNameID
;
get_coordinates
(
info
-
>
min_value
info
-
>
default_value
info
-
>
max_value
)
;
}
#
endif
void
get_axis_info
(
unsigned
axis_index
hb_ot_var_axis_info_t
*
info
)
const
{
info
-
>
axis_index
=
axis_index
;
info
-
>
tag
=
axisTag
;
info
-
>
name_id
=
axisNameID
;
info
-
>
flags
=
(
hb_ot_var_axis_flags_t
)
(
unsigned
int
)
flags
;
get_coordinates
(
info
-
>
min_value
info
-
>
default_value
info
-
>
max_value
)
;
info
-
>
reserved
=
0
;
}
hb_tag_t
get_axis_tag
(
)
const
{
return
axisTag
;
}
int
normalize_axis_value
(
float
v
)
const
{
float
min_value
default_value
max_value
;
get_coordinates
(
min_value
default_value
max_value
)
;
v
=
hb_clamp
(
v
min_value
max_value
)
;
if
(
v
=
=
default_value
)
return
0
;
else
if
(
v
<
default_value
)
v
=
(
v
-
default_value
)
/
(
default_value
-
min_value
)
;
else
v
=
(
v
-
default_value
)
/
(
max_value
-
default_value
)
;
return
roundf
(
v
*
16384
.
f
)
;
}
float
unnormalize_axis_value
(
int
v
)
const
{
float
min_value
default_value
max_value
;
get_coordinates
(
min_value
default_value
max_value
)
;
if
(
v
=
=
0
)
return
default_value
;
else
if
(
v
<
0
)
return
v
*
(
default_value
-
min_value
)
/
16384
.
f
+
default_value
;
else
return
v
*
(
max_value
-
default_value
)
/
16384
.
f
+
default_value
;
}
hb_ot_name_id_t
get_name_id
(
)
const
{
return
axisNameID
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
void
get_coordinates
(
float
&
min
float
&
default_
float
&
max
)
const
{
default_
=
defaultValue
.
to_float
(
)
;
min
=
hb_min
(
default_
minValue
.
to_float
(
)
)
;
max
=
hb_max
(
default_
maxValue
.
to_float
(
)
)
;
}
float
get_default
(
)
const
{
return
defaultValue
.
to_float
(
)
;
}
public
:
Tag
axisTag
;
protected
:
F16DOT16
minValue
;
F16DOT16
defaultValue
;
F16DOT16
maxValue
;
public
:
HBUINT16
flags
;
NameID
axisNameID
;
public
:
DEFINE_SIZE_STATIC
(
20
)
;
}
;
struct
fvar
{
static
constexpr
hb_tag_t
tableTag
=
HB_OT_TAG_fvar
;
bool
has_data
(
)
const
{
return
version
.
to_int
(
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
version
.
sanitize
(
c
)
&
&
likely
(
version
.
major
=
=
1
)
&
&
c
-
>
check_struct
(
this
)
&
&
axisSize
=
=
20
&
&
instanceSize
>
=
axisCount
*
4
+
4
&
&
get_axes
(
)
.
sanitize
(
c
)
&
&
c
-
>
check_range
(
get_instance
(
0
)
instanceCount
instanceSize
)
)
;
}
unsigned
int
get_axis_count
(
)
const
{
return
axisCount
;
}
#
ifndef
HB_DISABLE_DEPRECATED
unsigned
int
get_axes_deprecated
(
unsigned
int
start_offset
unsigned
int
*
axes_count
hb_ot_var_axis_t
*
axes_array
)
const
{
if
(
axes_count
)
{
hb_array_t
<
const
AxisRecord
>
arr
=
get_axes
(
)
.
sub_array
(
start_offset
axes_count
)
;
for
(
unsigned
i
=
0
;
i
<
arr
.
length
;
+
+
i
)
arr
[
i
]
.
get_axis_deprecated
(
&
axes_array
[
i
]
)
;
}
return
axisCount
;
}
#
endif
unsigned
int
get_axis_infos
(
unsigned
int
start_offset
unsigned
int
*
axes_count
hb_ot_var_axis_info_t
*
axes_array
)
const
{
if
(
axes_count
)
{
hb_array_t
<
const
AxisRecord
>
arr
=
get_axes
(
)
.
sub_array
(
start_offset
axes_count
)
;
for
(
unsigned
i
=
0
;
i
<
arr
.
length
;
+
+
i
)
arr
[
i
]
.
get_axis_info
(
start_offset
+
i
&
axes_array
[
i
]
)
;
}
return
axisCount
;
}
#
ifndef
HB_DISABLE_DEPRECATED
bool
find_axis_deprecated
(
hb_tag_t
tag
unsigned
*
axis_index
hb_ot_var_axis_t
*
info
)
const
{
unsigned
i
;
if
(
!
axis_index
)
axis_index
=
&
i
;
*
axis_index
=
HB_OT_VAR_NO_AXIS_INDEX
;
auto
axes
=
get_axes
(
)
;
return
axes
.
lfind
(
tag
axis_index
)
&
&
(
(
void
)
axes
[
*
axis_index
]
.
get_axis_deprecated
(
info
)
true
)
;
}
#
endif
bool
find_axis_info
(
hb_tag_t
tag
hb_ot_var_axis_info_t
*
info
)
const
{
unsigned
i
;
auto
axes
=
get_axes
(
)
;
return
axes
.
lfind
(
tag
&
i
)
&
&
(
(
void
)
axes
[
i
]
.
get_axis_info
(
i
info
)
true
)
;
}
int
normalize_axis_value
(
unsigned
int
axis_index
float
v
)
const
{
return
get_axes
(
)
[
axis_index
]
.
normalize_axis_value
(
v
)
;
}
float
unnormalize_axis_value
(
unsigned
int
axis_index
int
v
)
const
{
return
get_axes
(
)
[
axis_index
]
.
unnormalize_axis_value
(
v
)
;
}
unsigned
int
get_instance_count
(
)
const
{
return
instanceCount
;
}
hb_ot_name_id_t
get_instance_subfamily_name_id
(
unsigned
int
instance_index
)
const
{
const
InstanceRecord
*
instance
=
get_instance
(
instance_index
)
;
if
(
unlikely
(
!
instance
)
)
return
HB_OT_NAME_ID_INVALID
;
return
instance
-
>
subfamilyNameID
;
}
hb_ot_name_id_t
get_instance_postscript_name_id
(
unsigned
int
instance_index
)
const
{
const
InstanceRecord
*
instance
=
get_instance
(
instance_index
)
;
if
(
unlikely
(
!
instance
)
)
return
HB_OT_NAME_ID_INVALID
;
if
(
instanceSize
>
=
axisCount
*
4
+
6
)
return
StructAfter
<
NameID
>
(
instance
-
>
get_coordinates
(
axisCount
)
)
;
return
HB_OT_NAME_ID_INVALID
;
}
unsigned
int
get_instance_coords
(
unsigned
int
instance_index
unsigned
int
*
coords_length
float
*
coords
)
const
{
const
InstanceRecord
*
instance
=
get_instance
(
instance_index
)
;
if
(
unlikely
(
!
instance
)
)
{
if
(
coords_length
)
*
coords_length
=
0
;
return
0
;
}
if
(
coords_length
&
&
*
coords_length
)
{
hb_array_t
<
const
F16DOT16
>
instanceCoords
=
instance
-
>
get_coordinates
(
axisCount
)
.
sub_array
(
0
coords_length
)
;
for
(
unsigned
int
i
=
0
;
i
<
instanceCoords
.
length
;
i
+
+
)
coords
[
i
]
=
instanceCoords
.
arrayZ
[
i
]
.
to_float
(
)
;
}
return
axisCount
;
}
void
collect_name_ids
(
hb_hashmap_t
<
hb_tag_t
float
>
*
user_axes_location
hb_set_t
*
nameids
)
const
{
if
(
!
has_data
(
)
)
return
;
hb_map_t
pinned_axes
;
auto
axis_records
=
get_axes
(
)
;
for
(
unsigned
i
=
0
;
i
<
(
unsigned
)
axisCount
;
i
+
+
)
{
hb_tag_t
axis_tag
=
axis_records
[
i
]
.
get_axis_tag
(
)
;
if
(
user_axes_location
-
>
has
(
axis_tag
)
)
{
pinned_axes
.
set
(
i
axis_tag
)
;
continue
;
}
nameids
-
>
add
(
axis_records
[
i
]
.
get_name_id
(
)
)
;
}
for
(
unsigned
i
=
0
;
i
<
(
unsigned
)
instanceCount
;
i
+
+
)
{
const
InstanceRecord
*
instance
=
get_instance
(
i
)
;
if
(
hb_any
(
+
hb_enumerate
(
instance
-
>
get_coordinates
(
axisCount
)
)
|
hb_filter
(
pinned_axes
hb_first
)
|
hb_map
(
[
&
]
(
const
hb_pair_t
<
unsigned
const
F16DOT16
&
>
&
_
)
{
hb_tag_t
axis_tag
=
pinned_axes
.
get
(
_
.
first
)
;
float
location
=
user_axes_location
-
>
get
(
axis_tag
)
;
if
(
fabs
(
(
double
)
location
-
(
double
)
_
.
second
.
to_float
(
)
)
>
0
.
001
)
return
true
;
return
false
;
}
)
)
)
continue
;
nameids
-
>
add
(
instance
-
>
subfamilyNameID
)
;
if
(
instanceSize
>
=
axisCount
*
4
+
6
)
{
unsigned
post_script_name_id
=
StructAfter
<
NameID
>
(
instance
-
>
get_coordinates
(
axisCount
)
)
;
if
(
post_script_name_id
!
=
HB_OT_NAME_ID_INVALID
)
nameids
-
>
add
(
post_script_name_id
)
;
}
}
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
unsigned
retained_axis_count
=
c
-
>
plan
-
>
axes_index_map
.
get_population
(
)
;
if
(
!
retained_axis_count
)
return_trace
(
false
)
;
fvar
*
out
=
c
-
>
serializer
-
>
embed
(
this
)
;
if
(
unlikely
(
!
out
)
)
return_trace
(
false
)
;
if
(
!
c
-
>
serializer
-
>
check_assign
(
out
-
>
axisCount
retained_axis_count
HB_SERIALIZE_ERROR_INT_OVERFLOW
)
)
return_trace
(
false
)
;
bool
has_postscript_nameid
=
false
;
if
(
instanceSize
>
=
axisCount
*
4
+
6
)
has_postscript_nameid
=
true
;
if
(
!
c
-
>
serializer
-
>
check_assign
(
out
-
>
instanceSize
retained_axis_count
*
4
+
(
has_postscript_nameid
?
6
:
4
)
HB_SERIALIZE_ERROR_INT_OVERFLOW
)
)
return_trace
(
false
)
;
auto
axes_records
=
get_axes
(
)
;
for
(
unsigned
i
=
0
;
i
<
(
unsigned
)
axisCount
;
i
+
+
)
{
if
(
!
c
-
>
plan
-
>
axes_index_map
.
has
(
i
)
)
continue
;
if
(
unlikely
(
!
c
-
>
serializer
-
>
embed
(
axes_records
[
i
]
)
)
)
return_trace
(
false
)
;
}
if
(
!
c
-
>
serializer
-
>
check_assign
(
out
-
>
firstAxis
get_size
(
)
HB_SERIALIZE_ERROR_INT_OVERFLOW
)
)
return_trace
(
false
)
;
for
(
unsigned
i
=
0
;
i
<
(
unsigned
)
instanceCount
;
i
+
+
)
{
const
InstanceRecord
*
instance
=
get_instance
(
i
)
;
auto
snap
=
c
-
>
serializer
-
>
snapshot
(
)
;
if
(
!
instance
-
>
subset
(
c
axisCount
has_postscript_nameid
)
)
c
-
>
serializer
-
>
revert
(
snap
)
;
}
return_trace
(
true
)
;
}
public
:
hb_array_t
<
const
AxisRecord
>
get_axes
(
)
const
{
return
hb_array
(
&
(
this
+
firstAxis
)
axisCount
)
;
}
const
InstanceRecord
*
get_instance
(
unsigned
int
i
)
const
{
if
(
unlikely
(
i
>
=
instanceCount
)
)
return
nullptr
;
return
&
StructAtOffset
<
InstanceRecord
>
(
&
StructAfter
<
InstanceRecord
>
(
get_axes
(
)
)
i
*
instanceSize
)
;
}
protected
:
FixedVersion
<
>
version
;
Offset16To
<
AxisRecord
>
firstAxis
;
HBUINT16
reserved
;
HBUINT16
axisCount
;
HBUINT16
axisSize
;
HBUINT16
instanceCount
;
HBUINT16
instanceSize
;
public
:
DEFINE_SIZE_STATIC
(
16
)
;
}
;
}
#
endif
