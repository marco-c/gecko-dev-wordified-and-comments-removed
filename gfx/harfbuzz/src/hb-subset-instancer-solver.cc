#
include
"
hb
-
subset
-
instancer
-
solver
.
hh
"
constexpr
static
double
EPSILON
=
1
.
0
/
(
1
<
<
14
)
;
constexpr
static
double
MAX_F2DOT14
=
double
(
0x7FFF
)
/
(
1
<
<
14
)
;
static
inline
Triple
_reverse_negate
(
const
Triple
&
v
)
{
return
{
-
v
.
maximum
-
v
.
middle
-
v
.
minimum
}
;
}
static
inline
double
supportScalar
(
double
coord
const
Triple
&
tent
)
{
double
start
=
tent
.
minimum
peak
=
tent
.
middle
end
=
tent
.
maximum
;
if
(
unlikely
(
start
>
peak
|
|
peak
>
end
)
)
return
1
.
;
if
(
unlikely
(
start
<
0
&
&
end
>
0
&
&
peak
!
=
0
)
)
return
1
.
;
if
(
peak
=
=
0
|
|
coord
=
=
peak
)
return
1
.
;
if
(
coord
<
=
start
|
|
end
<
=
coord
)
return
0
.
;
if
(
coord
<
peak
)
return
(
coord
-
start
)
/
(
peak
-
start
)
;
else
return
(
end
-
coord
)
/
(
end
-
peak
)
;
}
static
inline
rebase_tent_result_t
_solve
(
Triple
tent
Triple
axisLimit
bool
negative
=
false
)
{
double
axisMin
=
axisLimit
.
minimum
;
double
axisDef
=
axisLimit
.
middle
;
double
axisMax
=
axisLimit
.
maximum
;
double
lower
=
tent
.
minimum
;
double
peak
=
tent
.
middle
;
double
upper
=
tent
.
maximum
;
if
(
axisDef
>
peak
)
{
rebase_tent_result_t
vec
=
_solve
(
_reverse_negate
(
tent
)
_reverse_negate
(
axisLimit
)
!
negative
)
;
for
(
auto
&
p
:
vec
)
p
=
hb_pair
(
p
.
first
_reverse_negate
(
p
.
second
)
)
;
return
vec
;
}
if
(
axisMax
<
=
lower
&
&
axisMax
<
peak
)
return
rebase_tent_result_t
{
}
;
if
(
axisMax
<
peak
)
{
double
mult
=
supportScalar
(
axisMax
tent
)
;
tent
=
Triple
{
lower
axisMax
axisMax
}
;
rebase_tent_result_t
vec
=
_solve
(
tent
axisLimit
)
;
for
(
auto
&
p
:
vec
)
p
=
hb_pair
(
p
.
first
*
mult
p
.
second
)
;
return
vec
;
}
double
gain
=
supportScalar
(
axisDef
tent
)
;
rebase_tent_result_t
out
{
hb_pair
(
gain
Triple
{
}
)
}
;
double
outGain
=
supportScalar
(
axisMax
tent
)
;
if
(
gain
>
=
outGain
)
{
double
crossing
=
peak
+
(
1
-
gain
)
*
(
upper
-
peak
)
;
Triple
loc
{
hb_max
(
lower
axisDef
)
peak
crossing
}
;
double
scalar
=
1
.
0
;
out
.
push
(
hb_pair
(
scalar
-
gain
loc
)
)
;
if
(
upper
>
=
axisMax
)
{
Triple
loc
{
crossing
axisMax
axisMax
}
;
double
scalar
=
outGain
;
out
.
push
(
hb_pair
(
scalar
-
gain
loc
)
)
;
}
else
{
if
(
upper
=
=
axisDef
)
upper
+
=
EPSILON
;
Triple
loc1
{
crossing
upper
axisMax
}
;
double
scalar1
=
0
.
0
;
Triple
loc2
{
upper
axisMax
axisMax
}
;
double
scalar2
=
0
.
0
;
out
.
push
(
hb_pair
(
scalar1
-
gain
loc1
)
)
;
out
.
push
(
hb_pair
(
scalar2
-
gain
loc2
)
)
;
}
}
else
{
if
(
axisMax
=
=
peak
)
upper
=
peak
;
double
newUpper
=
peak
+
(
1
-
gain
)
*
(
upper
-
peak
)
;
assert
(
axisMax
<
=
newUpper
)
;
if
(
false
&
&
(
newUpper
<
=
axisDef
+
(
axisMax
-
axisDef
)
*
2
)
)
{
upper
=
newUpper
;
if
(
!
negative
&
&
axisDef
+
(
axisMax
-
axisDef
)
*
MAX_F2DOT14
<
upper
)
{
upper
=
axisDef
+
(
axisMax
-
axisDef
)
*
MAX_F2DOT14
;
assert
(
peak
<
upper
)
;
}
Triple
loc
{
hb_max
(
axisDef
lower
)
peak
upper
}
;
double
scalar
=
1
.
0
;
out
.
push
(
hb_pair
(
scalar
-
gain
loc
)
)
;
}
else
{
Triple
loc1
{
hb_max
(
axisDef
lower
)
peak
axisMax
}
;
double
scalar1
=
1
.
0
;
Triple
loc2
{
peak
axisMax
axisMax
}
;
double
scalar2
=
outGain
;
out
.
push
(
hb_pair
(
scalar1
-
gain
loc1
)
)
;
if
(
peak
<
axisMax
)
out
.
push
(
hb_pair
(
scalar2
-
gain
loc2
)
)
;
}
}
if
(
lower
<
=
axisMin
)
{
Triple
loc
{
axisMin
axisMin
axisDef
}
;
double
scalar
=
supportScalar
(
axisMin
tent
)
;
out
.
push
(
hb_pair
(
scalar
-
gain
loc
)
)
;
}
else
{
if
(
lower
=
=
axisDef
)
lower
-
=
EPSILON
;
Triple
loc1
{
axisMin
lower
axisDef
}
;
double
scalar1
=
0
.
0
;
Triple
loc2
{
axisMin
axisMin
lower
}
;
double
scalar2
=
0
.
0
;
out
.
push
(
hb_pair
(
scalar1
-
gain
loc1
)
)
;
out
.
push
(
hb_pair
(
scalar2
-
gain
loc2
)
)
;
}
return
out
;
}
static
inline
TripleDistances
_reverse_triple_distances
(
const
TripleDistances
&
v
)
{
return
TripleDistances
(
v
.
positive
v
.
negative
)
;
}
double
renormalizeValue
(
double
v
const
Triple
&
triple
const
TripleDistances
&
triple_distances
bool
extrapolate
)
{
double
lower
=
triple
.
minimum
def
=
triple
.
middle
upper
=
triple
.
maximum
;
assert
(
lower
<
=
def
&
&
def
<
=
upper
)
;
if
(
!
extrapolate
)
v
=
hb_clamp
(
v
lower
upper
)
;
if
(
v
=
=
def
)
return
0
.
0
;
if
(
def
<
0
.
0
)
return
-
renormalizeValue
(
-
v
_reverse_negate
(
triple
)
_reverse_triple_distances
(
triple_distances
)
extrapolate
)
;
if
(
v
>
def
)
return
(
v
-
def
)
/
(
upper
-
def
)
;
if
(
lower
>
=
0
.
0
)
return
(
v
-
def
)
/
(
def
-
lower
)
;
double
total_distance
=
triple_distances
.
negative
*
(
-
lower
)
+
triple_distances
.
positive
*
def
;
double
v_distance
;
if
(
v
>
=
0
.
0
)
v_distance
=
(
def
-
v
)
*
triple_distances
.
positive
;
else
v_distance
=
(
-
v
)
*
triple_distances
.
negative
+
triple_distances
.
positive
*
def
;
return
(
-
v_distance
)
/
total_distance
;
}
rebase_tent_result_t
rebase_tent
(
Triple
tent
Triple
axisLimit
TripleDistances
axis_triple_distances
)
{
assert
(
-
1
.
0
<
=
axisLimit
.
minimum
&
&
axisLimit
.
minimum
<
=
axisLimit
.
middle
&
&
axisLimit
.
middle
<
=
axisLimit
.
maximum
&
&
axisLimit
.
maximum
<
=
+
1
.
0
)
;
assert
(
-
2
.
0
<
=
tent
.
minimum
&
&
tent
.
minimum
<
=
tent
.
middle
&
&
tent
.
middle
<
=
tent
.
maximum
&
&
tent
.
maximum
<
=
+
2
.
0
)
;
assert
(
tent
.
middle
!
=
0
.
0
)
;
rebase_tent_result_t
sols
=
_solve
(
tent
axisLimit
)
;
auto
n
=
[
&
axisLimit
&
axis_triple_distances
]
(
double
v
)
{
return
renormalizeValue
(
v
axisLimit
axis_triple_distances
)
;
}
;
rebase_tent_result_t
out
;
for
(
auto
&
p
:
sols
)
{
if
(
!
p
.
first
)
continue
;
if
(
p
.
second
=
=
Triple
{
}
)
{
out
.
push
(
p
)
;
continue
;
}
Triple
t
=
p
.
second
;
out
.
push
(
hb_pair
(
p
.
first
Triple
{
n
(
t
.
minimum
)
n
(
t
.
middle
)
n
(
t
.
maximum
)
}
)
)
;
}
return
out
;
}
