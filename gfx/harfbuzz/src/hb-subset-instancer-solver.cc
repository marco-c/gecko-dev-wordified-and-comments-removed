#
include
"
hb
.
hh
"
constexpr
static
float
EPSILON
=
1
.
f
/
(
1
<
<
14
)
;
constexpr
static
float
MAX_F2DOT14
=
float
(
0x7FFF
)
/
(
1
<
<
14
)
;
struct
Triple
{
Triple
(
)
:
minimum
(
0
.
f
)
middle
(
0
.
f
)
maximum
(
0
.
f
)
{
}
Triple
(
float
minimum_
float
middle_
float
maximum_
)
:
minimum
(
minimum_
)
middle
(
middle_
)
maximum
(
maximum_
)
{
}
bool
operator
=
=
(
const
Triple
&
o
)
const
{
return
minimum
=
=
o
.
minimum
&
&
middle
=
=
o
.
middle
&
&
maximum
=
=
o
.
maximum
;
}
float
minimum
;
float
middle
;
float
maximum
;
}
;
static
inline
Triple
_reverse_negate
(
const
Triple
&
v
)
{
return
{
-
v
.
maximum
-
v
.
middle
-
v
.
minimum
}
;
}
static
inline
float
supportScalar
(
float
coord
const
Triple
&
tent
)
{
float
start
=
tent
.
minimum
peak
=
tent
.
middle
end
=
tent
.
maximum
;
if
(
unlikely
(
start
>
peak
|
|
peak
>
end
)
)
return
1
.
;
if
(
unlikely
(
start
<
0
&
&
end
>
0
&
&
peak
!
=
0
)
)
return
1
.
;
if
(
peak
=
=
0
|
|
coord
=
=
peak
)
return
1
.
;
if
(
coord
<
=
start
|
|
end
<
=
coord
)
return
0
.
;
if
(
coord
<
peak
)
return
(
coord
-
start
)
/
(
peak
-
start
)
;
else
return
(
end
-
coord
)
/
(
end
-
peak
)
;
}
using
result_item_t
=
hb_pair_t
<
float
Triple
>
;
using
result_t
=
hb_vector_t
<
result_item_t
>
;
static
inline
result_t
_solve
(
Triple
tent
Triple
axisLimit
bool
negative
=
false
)
{
float
axisMin
=
axisLimit
.
minimum
;
float
axisDef
=
axisLimit
.
middle
;
float
axisMax
=
axisLimit
.
maximum
;
float
lower
=
tent
.
minimum
;
float
peak
=
tent
.
middle
;
float
upper
=
tent
.
maximum
;
if
(
axisDef
>
peak
)
{
result_t
vec
=
_solve
(
_reverse_negate
(
tent
)
_reverse_negate
(
axisLimit
)
!
negative
)
;
for
(
auto
&
p
:
vec
)
p
=
hb_pair
(
p
.
first
_reverse_negate
(
p
.
second
)
)
;
return
vec
;
}
if
(
axisMax
<
=
lower
&
&
axisMax
<
peak
)
return
result_t
{
}
;
if
(
axisMax
<
peak
)
{
float
mult
=
supportScalar
(
axisMax
tent
)
;
tent
=
Triple
{
lower
axisMax
axisMax
}
;
result_t
vec
=
_solve
(
tent
axisLimit
)
;
for
(
auto
&
p
:
vec
)
p
=
hb_pair
(
p
.
first
*
mult
p
.
second
)
;
return
vec
;
}
float
gain
=
supportScalar
(
axisDef
tent
)
;
result_t
out
{
hb_pair
(
gain
Triple
{
}
)
}
;
float
outGain
=
supportScalar
(
axisMax
tent
)
;
if
(
gain
>
outGain
)
{
float
crossing
=
peak
+
(
(
1
-
gain
)
*
(
upper
-
peak
)
/
(
1
-
outGain
)
)
;
Triple
loc
{
peak
peak
crossing
}
;
float
scalar
=
1
.
f
;
out
.
push
(
hb_pair
(
scalar
-
gain
loc
)
)
;
if
(
upper
>
=
axisMax
)
{
Triple
loc
{
crossing
axisMax
axisMax
}
;
float
scalar
=
supportScalar
(
axisMax
tent
)
;
out
.
push
(
hb_pair
(
scalar
-
gain
loc
)
)
;
}
else
{
if
(
upper
=
=
axisDef
)
upper
+
=
EPSILON
;
Triple
loc1
{
crossing
upper
axisMax
}
;
float
scalar1
=
0
.
f
;
Triple
loc2
{
upper
axisMax
axisMax
}
;
float
scalar2
=
1
.
f
;
out
.
push
(
hb_pair
(
scalar1
-
gain
loc1
)
)
;
out
.
push
(
hb_pair
(
scalar2
-
gain
loc2
)
)
;
}
}
else
if
(
axisDef
+
(
axisMax
-
axisDef
)
*
2
>
=
upper
)
{
if
(
!
negative
&
&
axisDef
+
(
axisMax
-
axisDef
)
*
MAX_F2DOT14
<
upper
)
{
upper
=
axisDef
+
(
axisMax
-
axisDef
)
*
MAX_F2DOT14
;
assert
(
peak
<
upper
)
;
}
if
(
axisMax
=
=
peak
)
upper
=
peak
;
Triple
loc1
{
hb_max
(
axisDef
lower
)
peak
upper
}
;
float
scalar1
=
1
.
f
;
Triple
loc2
{
peak
upper
upper
}
;
float
scalar2
=
0
.
f
;
if
(
axisDef
<
upper
)
out
.
push
(
hb_pair
(
scalar1
-
gain
loc1
)
)
;
if
(
peak
<
upper
)
out
.
push
(
hb_pair
(
scalar2
-
gain
loc2
)
)
;
}
else
{
Triple
loc1
{
hb_max
(
axisDef
lower
)
peak
axisMax
}
;
float
scalar1
=
1
.
f
;
Triple
loc2
{
peak
axisMax
axisMax
}
;
float
scalar2
=
supportScalar
(
axisMax
tent
)
;
out
.
push
(
hb_pair
(
scalar1
-
gain
loc1
)
)
;
if
(
peak
<
axisMax
)
out
.
push
(
hb_pair
(
scalar2
-
gain
loc2
)
)
;
}
if
(
lower
<
=
axisMin
)
{
Triple
loc
{
axisMin
axisMin
axisDef
}
;
float
scalar
=
supportScalar
(
axisMin
tent
)
;
out
.
push
(
hb_pair
(
scalar
-
gain
loc
)
)
;
}
else
{
if
(
lower
=
=
axisDef
)
lower
-
=
EPSILON
;
Triple
loc1
{
axisMin
lower
axisDef
}
;
float
scalar1
=
0
.
f
;
Triple
loc2
{
axisMin
axisMin
lower
}
;
float
scalar2
=
0
.
f
;
out
.
push
(
hb_pair
(
scalar1
-
gain
loc1
)
)
;
out
.
push
(
hb_pair
(
scalar2
-
gain
loc2
)
)
;
}
return
out
;
}
static
inline
float
normalizeValue
(
float
v
const
Triple
&
triple
bool
extrapolate
=
false
)
{
float
lower
=
triple
.
minimum
def
=
triple
.
middle
upper
=
triple
.
maximum
;
assert
(
lower
<
=
def
&
&
def
<
=
upper
)
;
if
(
!
extrapolate
)
v
=
hb_max
(
hb_min
(
v
upper
)
lower
)
;
if
(
(
v
=
=
def
)
|
|
(
lower
=
=
upper
)
)
return
0
.
f
;
if
(
(
v
<
def
&
&
lower
!
=
def
)
|
|
(
v
>
def
&
&
upper
=
=
def
)
)
return
(
v
-
def
)
/
(
def
-
lower
)
;
else
{
assert
(
(
v
>
def
&
&
upper
!
=
def
)
|
|
(
v
<
def
&
&
lower
=
=
def
)
)
;
return
(
v
-
def
)
/
(
upper
-
def
)
;
}
}
HB_INTERNAL
result_t
rebase_tent
(
Triple
tent
Triple
axisLimit
)
;
result_t
rebase_tent
(
Triple
tent
Triple
axisLimit
)
{
assert
(
-
1
.
f
<
=
axisLimit
.
minimum
&
&
axisLimit
.
minimum
<
=
axisLimit
.
middle
&
&
axisLimit
.
middle
<
=
axisLimit
.
maximum
&
&
axisLimit
.
maximum
<
=
+
1
.
f
)
;
assert
(
-
2
.
f
<
=
tent
.
minimum
&
&
tent
.
minimum
<
=
tent
.
middle
&
&
tent
.
middle
<
=
tent
.
maximum
&
&
tent
.
maximum
<
=
+
2
.
f
)
;
assert
(
tent
.
middle
!
=
0
.
f
)
;
result_t
sols
=
_solve
(
tent
axisLimit
)
;
auto
n
=
[
&
axisLimit
]
(
float
v
)
{
return
normalizeValue
(
v
axisLimit
true
)
;
}
;
result_t
out
;
for
(
auto
&
p
:
sols
)
{
if
(
!
p
.
first
)
continue
;
if
(
p
.
second
=
=
Triple
{
}
)
{
out
.
push
(
p
)
;
continue
;
}
Triple
t
=
p
.
second
;
out
.
push
(
hb_pair
(
p
.
first
Triple
{
n
(
t
.
minimum
)
n
(
t
.
middle
)
n
(
t
.
maximum
)
}
)
)
;
}
return
sols
;
}
