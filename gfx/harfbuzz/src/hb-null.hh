#
ifndef
HB_NULL_HH
#
define
HB_NULL_HH
#
include
"
hb
.
hh
"
#
define
HB_NULL_POOL_SIZE
9880
template
<
bool
>
struct
_hb_bool_type
{
}
;
template
<
typename
T
typename
B
>
struct
_hb_null_size
{
enum
{
value
=
sizeof
(
T
)
}
;
}
;
template
<
typename
T
>
struct
_hb_null_size
<
T
_hb_bool_type
<
(
bool
)
(
1
+
(
unsigned
int
)
T
:
:
min_size
)
>
>
{
enum
{
value
=
T
:
:
null_size
}
;
}
;
template
<
typename
T
>
struct
hb_null_size
{
enum
{
value
=
_hb_null_size
<
T
_hb_bool_type
<
true
>
>
:
:
value
}
;
}
;
#
define
hb_null_size
(
T
)
hb_null_size
<
T
>
:
:
value
template
<
typename
T
typename
B
>
struct
_hb_static_size
{
enum
{
value
=
sizeof
(
T
)
}
;
}
;
template
<
typename
T
>
struct
_hb_static_size
<
T
_hb_bool_type
<
(
bool
)
(
1
+
(
unsigned
int
)
T
:
:
min_size
)
>
>
{
enum
{
value
=
T
:
:
static_size
}
;
}
;
template
<
typename
T
>
struct
hb_static_size
{
enum
{
value
=
_hb_static_size
<
T
_hb_bool_type
<
true
>
>
:
:
value
}
;
}
;
#
define
hb_static_size
(
T
)
hb_static_size
<
T
>
:
:
value
template
<
typename
T
typename
V
typename
B
>
struct
_hb_assign
{
static
inline
void
value
(
T
&
o
const
V
v
)
{
o
=
v
;
}
}
;
template
<
typename
T
typename
V
>
struct
_hb_assign
<
T
V
_hb_bool_type
<
(
bool
)
(
1
+
(
unsigned
int
)
T
:
:
min_size
)
>
>
{
static
inline
void
value
(
T
&
o
const
V
v
)
{
o
.
set
(
v
)
;
}
}
;
template
<
typename
T
>
struct
_hb_assign
<
T
T
_hb_bool_type
<
(
bool
)
(
1
+
(
unsigned
int
)
T
:
:
min_size
)
>
>
{
static
inline
void
value
(
T
&
o
const
T
v
)
{
o
=
v
;
}
}
;
template
<
typename
T
typename
V
>
static
inline
void
hb_assign
(
T
&
o
const
V
v
)
{
_hb_assign
<
T
V
_hb_bool_type
<
true
>
>
:
:
value
(
o
v
)
;
}
extern
HB_INTERNAL
hb_vector_size_impl_t
const
_hb_NullPool
[
(
HB_NULL_POOL_SIZE
+
sizeof
(
hb_vector_size_impl_t
)
-
1
)
/
sizeof
(
hb_vector_size_impl_t
)
]
;
template
<
typename
Type
>
static
inline
Type
const
&
Null
(
)
{
static_assert
(
hb_null_size
(
Type
)
<
=
HB_NULL_POOL_SIZE
"
Increase
HB_NULL_POOL_SIZE
.
"
)
;
return
*
reinterpret_cast
<
Type
const
*
>
(
_hb_NullPool
)
;
}
template
<
typename
QType
>
struct
NullHelper
{
typedef
typename
hb_remove_const
(
typename
hb_remove_reference
(
QType
)
)
Type
;
static
const
Type
&
get_null
(
)
{
return
Null
<
Type
>
(
)
;
}
}
;
#
define
Null
(
Type
)
NullHelper
<
Type
>
:
:
get_null
(
)
#
define
DECLARE_NULL_NAMESPACE_BYTES
(
Namespace
Type
)
\
}
/
*
Close
namespace
.
*
/
\
extern
HB_INTERNAL
const
unsigned
char
_hb_Null_
#
#
Namespace
#
#
_
#
#
Type
[
Namespace
:
:
Type
:
:
null_size
]
;
\
template
<
>
\
/
*
static
*
/
inline
const
Namespace
:
:
Type
&
Null
<
Namespace
:
:
Type
>
(
)
{
\
return
*
reinterpret_cast
<
const
Namespace
:
:
Type
*
>
(
_hb_Null_
#
#
Namespace
#
#
_
#
#
Type
)
;
\
}
\
namespace
Namespace
{
\
static_assert
(
true
"
Just
so
we
take
semicolon
after
.
"
)
#
define
DEFINE_NULL_NAMESPACE_BYTES
(
Namespace
Type
)
\
const
unsigned
char
_hb_Null_
#
#
Namespace
#
#
_
#
#
Type
[
Namespace
:
:
Type
:
:
null_size
]
#
define
DECLARE_NULL_INSTANCE
(
Type
)
\
extern
HB_INTERNAL
const
Type
_hb_Null_
#
#
Type
;
\
template
<
>
\
/
*
static
*
/
inline
const
Type
&
Null
<
Type
>
(
)
{
\
return
_hb_Null_
#
#
Type
;
\
}
\
static_assert
(
true
"
Just
so
we
take
semicolon
after
.
"
)
#
define
DEFINE_NULL_INSTANCE
(
Type
)
\
const
Type
_hb_Null_
#
#
Type
extern
HB_INTERNAL
hb_vector_size_impl_t
_hb_CrapPool
[
(
HB_NULL_POOL_SIZE
+
sizeof
(
hb_vector_size_impl_t
)
-
1
)
/
sizeof
(
hb_vector_size_impl_t
)
]
;
template
<
typename
Type
>
static
inline
Type
&
Crap
(
)
{
static_assert
(
hb_null_size
(
Type
)
<
=
HB_NULL_POOL_SIZE
"
Increase
HB_NULL_POOL_SIZE
.
"
)
;
Type
*
obj
=
reinterpret_cast
<
Type
*
>
(
_hb_CrapPool
)
;
memcpy
(
obj
&
Null
(
Type
)
sizeof
(
*
obj
)
)
;
return
*
obj
;
}
template
<
typename
QType
>
struct
CrapHelper
{
typedef
typename
hb_remove_const
(
typename
hb_remove_reference
(
QType
)
)
Type
;
static
Type
&
get_crap
(
)
{
return
Crap
<
Type
>
(
)
;
}
}
;
#
define
Crap
(
Type
)
CrapHelper
<
Type
>
:
:
get_crap
(
)
template
<
typename
Type
>
struct
CrapOrNullHelper
{
static
Type
&
get
(
)
{
return
Crap
(
Type
)
;
}
}
;
template
<
typename
Type
>
struct
CrapOrNullHelper
<
const
Type
>
{
static
const
Type
&
get
(
)
{
return
Null
(
Type
)
;
}
}
;
#
define
CrapOrNull
(
Type
)
CrapOrNullHelper
<
Type
>
:
:
get
(
)
template
<
typename
P
>
struct
hb_nonnull_ptr_t
{
typedef
typename
hb_remove_pointer
(
P
)
T
;
hb_nonnull_ptr_t
(
T
*
v_
=
nullptr
)
:
v
(
v_
)
{
}
T
*
operator
=
(
T
*
v_
)
{
return
v
=
v_
;
}
T
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
T
&
operator
*
(
)
const
{
return
*
get
(
)
;
}
T
*
*
operator
&
(
)
const
{
return
&
v
;
}
template
<
typename
C
>
operator
const
C
*
(
)
const
{
return
get
(
)
;
}
operator
const
char
*
(
)
const
{
return
(
const
char
*
)
get
(
)
;
}
T
*
get
(
)
const
{
return
v
?
v
:
const_cast
<
T
*
>
(
&
Null
(
T
)
)
;
}
T
*
get_raw
(
)
const
{
return
v
;
}
T
*
v
;
}
;
#
endif
