#
ifndef
HB_OT_LAYOUT_GPOS_TABLE_HH
#
define
HB_OT_LAYOUT_GPOS_TABLE_HH
#
include
"
hb
-
ot
-
layout
-
gsubgpos
.
hh
"
namespace
OT
{
#
define
attach_chain
(
)
var
.
i16
[
0
]
/
*
glyph
to
which
this
attaches
to
relative
to
current
glyphs
;
negative
for
going
back
positive
for
forward
.
*
/
#
define
attach_type
(
)
var
.
u8
[
2
]
/
*
attachment
type
*
/
enum
attach_type_t
{
ATTACH_TYPE_NONE
=
0X00
ATTACH_TYPE_MARK
=
0X01
ATTACH_TYPE_CURSIVE
=
0X02
}
;
typedef
HBUINT16
Value
;
typedef
UnsizedArrayOf
<
Value
>
ValueRecord
;
struct
ValueFormat
:
HBUINT16
{
enum
Flags
{
xPlacement
=
0x0001u
yPlacement
=
0x0002u
xAdvance
=
0x0004u
yAdvance
=
0x0008u
xPlaDevice
=
0x0010u
yPlaDevice
=
0x0020u
xAdvDevice
=
0x0040u
yAdvDevice
=
0x0080u
ignored
=
0x0F00u
reserved
=
0xF000u
devices
=
0x00F0u
}
;
#
if
0
HBINT16
xPlacement
;
HBINT16
yPlacement
;
HBINT16
xAdvance
;
HBINT16
yAdvance
;
OffsetTo
<
Device
>
xPlaDevice
;
OffsetTo
<
Device
>
yPlaDevice
;
OffsetTo
<
Device
>
xAdvDevice
;
OffsetTo
<
Device
>
yAdvDevice
;
#
endif
unsigned
int
get_len
(
)
const
{
return
hb_popcount
(
(
unsigned
int
)
*
this
)
;
}
unsigned
int
get_size
(
)
const
{
return
get_len
(
)
*
Value
:
:
static_size
;
}
bool
apply_value
(
hb_ot_apply_context_t
*
c
const
void
*
base
const
Value
*
values
hb_glyph_position_t
&
glyph_pos
)
const
{
bool
ret
=
false
;
unsigned
int
format
=
*
this
;
if
(
!
format
)
return
ret
;
hb_font_t
*
font
=
c
-
>
font
;
bool
horizontal
=
HB_DIRECTION_IS_HORIZONTAL
(
c
-
>
direction
)
;
if
(
format
&
xPlacement
)
glyph_pos
.
x_offset
+
=
font
-
>
em_scale_x
(
get_short
(
values
+
+
&
ret
)
)
;
if
(
format
&
yPlacement
)
glyph_pos
.
y_offset
+
=
font
-
>
em_scale_y
(
get_short
(
values
+
+
&
ret
)
)
;
if
(
format
&
xAdvance
)
{
if
(
likely
(
horizontal
)
)
glyph_pos
.
x_advance
+
=
font
-
>
em_scale_x
(
get_short
(
values
&
ret
)
)
;
values
+
+
;
}
if
(
format
&
yAdvance
)
{
if
(
unlikely
(
!
horizontal
)
)
glyph_pos
.
y_advance
-
=
font
-
>
em_scale_y
(
get_short
(
values
&
ret
)
)
;
values
+
+
;
}
if
(
!
has_device
(
)
)
return
ret
;
bool
use_x_device
=
font
-
>
x_ppem
|
|
font
-
>
num_coords
;
bool
use_y_device
=
font
-
>
y_ppem
|
|
font
-
>
num_coords
;
if
(
!
use_x_device
&
&
!
use_y_device
)
return
ret
;
const
VariationStore
&
store
=
c
-
>
var_store
;
if
(
format
&
xPlaDevice
)
{
if
(
use_x_device
)
glyph_pos
.
x_offset
+
=
(
base
+
get_device
(
values
&
ret
)
)
.
get_x_delta
(
font
store
)
;
values
+
+
;
}
if
(
format
&
yPlaDevice
)
{
if
(
use_y_device
)
glyph_pos
.
y_offset
+
=
(
base
+
get_device
(
values
&
ret
)
)
.
get_y_delta
(
font
store
)
;
values
+
+
;
}
if
(
format
&
xAdvDevice
)
{
if
(
horizontal
&
&
use_x_device
)
glyph_pos
.
x_advance
+
=
(
base
+
get_device
(
values
&
ret
)
)
.
get_x_delta
(
font
store
)
;
values
+
+
;
}
if
(
format
&
yAdvDevice
)
{
if
(
!
horizontal
&
&
use_y_device
)
glyph_pos
.
y_advance
-
=
(
base
+
get_device
(
values
&
ret
)
)
.
get_y_delta
(
font
store
)
;
values
+
+
;
}
return
ret
;
}
private
:
bool
sanitize_value_devices
(
hb_sanitize_context_t
*
c
const
void
*
base
const
Value
*
values
)
const
{
unsigned
int
format
=
*
this
;
if
(
format
&
xPlacement
)
values
+
+
;
if
(
format
&
yPlacement
)
values
+
+
;
if
(
format
&
xAdvance
)
values
+
+
;
if
(
format
&
yAdvance
)
values
+
+
;
if
(
(
format
&
xPlaDevice
)
&
&
!
get_device
(
values
+
+
)
.
sanitize
(
c
base
)
)
return
false
;
if
(
(
format
&
yPlaDevice
)
&
&
!
get_device
(
values
+
+
)
.
sanitize
(
c
base
)
)
return
false
;
if
(
(
format
&
xAdvDevice
)
&
&
!
get_device
(
values
+
+
)
.
sanitize
(
c
base
)
)
return
false
;
if
(
(
format
&
yAdvDevice
)
&
&
!
get_device
(
values
+
+
)
.
sanitize
(
c
base
)
)
return
false
;
return
true
;
}
static
OffsetTo
<
Device
>
&
get_device
(
Value
*
value
)
{
return
*
CastP
<
OffsetTo
<
Device
>
>
(
value
)
;
}
static
const
OffsetTo
<
Device
>
&
get_device
(
const
Value
*
value
bool
*
worked
=
nullptr
)
{
if
(
worked
)
*
worked
|
=
bool
(
*
value
)
;
return
*
CastP
<
OffsetTo
<
Device
>
>
(
value
)
;
}
static
const
HBINT16
&
get_short
(
const
Value
*
value
bool
*
worked
=
nullptr
)
{
if
(
worked
)
*
worked
|
=
bool
(
*
value
)
;
return
*
CastP
<
HBINT16
>
(
value
)
;
}
public
:
bool
has_device
(
)
const
{
unsigned
int
format
=
*
this
;
return
(
format
&
devices
)
!
=
0
;
}
bool
sanitize_value
(
hb_sanitize_context_t
*
c
const
void
*
base
const
Value
*
values
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_range
(
values
get_size
(
)
)
&
&
(
!
has_device
(
)
|
|
sanitize_value_devices
(
c
base
values
)
)
)
;
}
bool
sanitize_values
(
hb_sanitize_context_t
*
c
const
void
*
base
const
Value
*
values
unsigned
int
count
)
const
{
TRACE_SANITIZE
(
this
)
;
unsigned
int
len
=
get_len
(
)
;
if
(
!
c
-
>
check_range
(
values
count
get_size
(
)
)
)
return_trace
(
false
)
;
if
(
!
has_device
(
)
)
return_trace
(
true
)
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
!
sanitize_value_devices
(
c
base
values
)
)
return_trace
(
false
)
;
values
+
=
len
;
}
return_trace
(
true
)
;
}
bool
sanitize_values_stride_unsafe
(
hb_sanitize_context_t
*
c
const
void
*
base
const
Value
*
values
unsigned
int
count
unsigned
int
stride
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
!
has_device
(
)
)
return_trace
(
true
)
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
!
sanitize_value_devices
(
c
base
values
)
)
return_trace
(
false
)
;
values
+
=
stride
;
}
return_trace
(
true
)
;
}
}
;
struct
AnchorFormat1
{
void
get_anchor
(
hb_ot_apply_context_t
*
c
hb_codepoint_t
glyph_id
HB_UNUSED
float
*
x
float
*
y
)
const
{
hb_font_t
*
font
=
c
-
>
font
;
*
x
=
font
-
>
em_fscale_x
(
xCoordinate
)
;
*
y
=
font
-
>
em_fscale_y
(
yCoordinate
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
protected
:
HBUINT16
format
;
FWORD
xCoordinate
;
FWORD
yCoordinate
;
public
:
DEFINE_SIZE_STATIC
(
6
)
;
}
;
struct
AnchorFormat2
{
void
get_anchor
(
hb_ot_apply_context_t
*
c
hb_codepoint_t
glyph_id
float
*
x
float
*
y
)
const
{
hb_font_t
*
font
=
c
-
>
font
;
unsigned
int
x_ppem
=
font
-
>
x_ppem
;
unsigned
int
y_ppem
=
font
-
>
y_ppem
;
hb_position_t
cx
=
0
cy
=
0
;
bool
ret
;
ret
=
(
x_ppem
|
|
y_ppem
)
&
&
font
-
>
get_glyph_contour_point_for_origin
(
glyph_id
anchorPoint
HB_DIRECTION_LTR
&
cx
&
cy
)
;
*
x
=
ret
&
&
x_ppem
?
cx
:
font
-
>
em_fscale_x
(
xCoordinate
)
;
*
y
=
ret
&
&
y_ppem
?
cy
:
font
-
>
em_fscale_y
(
yCoordinate
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
protected
:
HBUINT16
format
;
FWORD
xCoordinate
;
FWORD
yCoordinate
;
HBUINT16
anchorPoint
;
public
:
DEFINE_SIZE_STATIC
(
8
)
;
}
;
struct
AnchorFormat3
{
void
get_anchor
(
hb_ot_apply_context_t
*
c
hb_codepoint_t
glyph_id
HB_UNUSED
float
*
x
float
*
y
)
const
{
hb_font_t
*
font
=
c
-
>
font
;
*
x
=
font
-
>
em_fscale_x
(
xCoordinate
)
;
*
y
=
font
-
>
em_fscale_y
(
yCoordinate
)
;
if
(
font
-
>
x_ppem
|
|
font
-
>
num_coords
)
*
x
+
=
(
this
+
xDeviceTable
)
.
get_x_delta
(
font
c
-
>
var_store
)
;
if
(
font
-
>
y_ppem
|
|
font
-
>
num_coords
)
*
y
+
=
(
this
+
yDeviceTable
)
.
get_y_delta
(
font
c
-
>
var_store
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
xDeviceTable
.
sanitize
(
c
this
)
&
&
yDeviceTable
.
sanitize
(
c
this
)
)
;
}
protected
:
HBUINT16
format
;
FWORD
xCoordinate
;
FWORD
yCoordinate
;
OffsetTo
<
Device
>
xDeviceTable
;
OffsetTo
<
Device
>
yDeviceTable
;
public
:
DEFINE_SIZE_STATIC
(
10
)
;
}
;
struct
Anchor
{
void
get_anchor
(
hb_ot_apply_context_t
*
c
hb_codepoint_t
glyph_id
float
*
x
float
*
y
)
const
{
*
x
=
*
y
=
0
;
switch
(
u
.
format
)
{
case
1
:
u
.
format1
.
get_anchor
(
c
glyph_id
x
y
)
;
return
;
case
2
:
u
.
format2
.
get_anchor
(
c
glyph_id
x
y
)
;
return
;
case
3
:
u
.
format3
.
get_anchor
(
c
glyph_id
x
y
)
;
return
;
default
:
return
;
}
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
!
u
.
format
.
sanitize
(
c
)
)
return_trace
(
false
)
;
switch
(
u
.
format
)
{
case
1
:
return_trace
(
u
.
format1
.
sanitize
(
c
)
)
;
case
2
:
return_trace
(
u
.
format2
.
sanitize
(
c
)
)
;
case
3
:
return_trace
(
u
.
format3
.
sanitize
(
c
)
)
;
default
:
return_trace
(
true
)
;
}
}
protected
:
union
{
HBUINT16
format
;
AnchorFormat1
format1
;
AnchorFormat2
format2
;
AnchorFormat3
format3
;
}
u
;
public
:
DEFINE_SIZE_UNION
(
2
format
)
;
}
;
struct
AnchorMatrix
{
const
Anchor
&
get_anchor
(
unsigned
int
row
unsigned
int
col
unsigned
int
cols
bool
*
found
)
const
{
*
found
=
false
;
if
(
unlikely
(
row
>
=
rows
|
|
col
>
=
cols
)
)
return
Null
(
Anchor
)
;
*
found
=
!
matrixZ
[
row
*
cols
+
col
]
.
is_null
(
)
;
return
this
+
matrixZ
[
row
*
cols
+
col
]
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
unsigned
int
cols
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
!
c
-
>
check_struct
(
this
)
)
return_trace
(
false
)
;
if
(
unlikely
(
hb_unsigned_mul_overflows
(
rows
cols
)
)
)
return_trace
(
false
)
;
unsigned
int
count
=
rows
*
cols
;
if
(
!
c
-
>
check_array
(
matrixZ
.
arrayZ
count
)
)
return_trace
(
false
)
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
if
(
!
matrixZ
[
i
]
.
sanitize
(
c
this
)
)
return_trace
(
false
)
;
return_trace
(
true
)
;
}
HBUINT16
rows
;
protected
:
UnsizedArrayOf
<
OffsetTo
<
Anchor
>
>
matrixZ
;
public
:
DEFINE_SIZE_ARRAY
(
2
matrixZ
)
;
}
;
struct
MarkRecord
{
friend
struct
MarkArray
;
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
markAnchor
.
sanitize
(
c
base
)
)
;
}
protected
:
HBUINT16
klass
;
OffsetTo
<
Anchor
>
markAnchor
;
public
:
DEFINE_SIZE_STATIC
(
4
)
;
}
;
struct
MarkArray
:
ArrayOf
<
MarkRecord
>
{
bool
apply
(
hb_ot_apply_context_t
*
c
unsigned
int
mark_index
unsigned
int
glyph_index
const
AnchorMatrix
&
anchors
unsigned
int
class_count
unsigned
int
glyph_pos
)
const
{
TRACE_APPLY
(
this
)
;
hb_buffer_t
*
buffer
=
c
-
>
buffer
;
const
MarkRecord
&
record
=
ArrayOf
<
MarkRecord
>
:
:
operator
[
]
(
mark_index
)
;
unsigned
int
mark_class
=
record
.
klass
;
const
Anchor
&
mark_anchor
=
this
+
record
.
markAnchor
;
bool
found
;
const
Anchor
&
glyph_anchor
=
anchors
.
get_anchor
(
glyph_index
mark_class
class_count
&
found
)
;
if
(
unlikely
(
!
found
)
)
return_trace
(
false
)
;
float
mark_x
mark_y
base_x
base_y
;
buffer
-
>
unsafe_to_break
(
glyph_pos
buffer
-
>
idx
)
;
mark_anchor
.
get_anchor
(
c
buffer
-
>
cur
(
)
.
codepoint
&
mark_x
&
mark_y
)
;
glyph_anchor
.
get_anchor
(
c
buffer
-
>
info
[
glyph_pos
]
.
codepoint
&
base_x
&
base_y
)
;
hb_glyph_position_t
&
o
=
buffer
-
>
cur_pos
(
)
;
o
.
x_offset
=
round
(
base_x
-
mark_x
)
;
o
.
y_offset
=
round
(
base_y
-
mark_y
)
;
o
.
attach_type
(
)
=
ATTACH_TYPE_MARK
;
o
.
attach_chain
(
)
=
(
int
)
glyph_pos
-
(
int
)
buffer
-
>
idx
;
buffer
-
>
scratch_flags
|
=
HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT
;
buffer
-
>
idx
+
+
;
return_trace
(
true
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
ArrayOf
<
MarkRecord
>
:
:
sanitize
(
c
this
)
)
;
}
}
;
struct
SinglePosFormat1
{
bool
intersects
(
const
hb_set_t
*
glyphs
)
const
{
return
(
this
+
coverage
)
.
intersects
(
glyphs
)
;
}
void
collect_glyphs
(
hb_collect_glyphs_context_t
*
c
)
const
{
if
(
unlikely
(
!
(
this
+
coverage
)
.
add_coverage
(
c
-
>
input
)
)
)
return
;
}
const
Coverage
&
get_coverage
(
)
const
{
return
this
+
coverage
;
}
bool
apply
(
hb_ot_apply_context_t
*
c
)
const
{
TRACE_APPLY
(
this
)
;
hb_buffer_t
*
buffer
=
c
-
>
buffer
;
unsigned
int
index
=
(
this
+
coverage
)
.
get_coverage
(
buffer
-
>
cur
(
)
.
codepoint
)
;
if
(
likely
(
index
=
=
NOT_COVERED
)
)
return_trace
(
false
)
;
valueFormat
.
apply_value
(
c
this
values
buffer
-
>
cur_pos
(
)
)
;
buffer
-
>
idx
+
+
;
return_trace
(
true
)
;
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
return_trace
(
false
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
coverage
.
sanitize
(
c
this
)
&
&
valueFormat
.
sanitize_value
(
c
this
values
)
)
;
}
protected
:
HBUINT16
format
;
OffsetTo
<
Coverage
>
coverage
;
ValueFormat
valueFormat
;
ValueRecord
values
;
public
:
DEFINE_SIZE_ARRAY
(
6
values
)
;
}
;
struct
SinglePosFormat2
{
bool
intersects
(
const
hb_set_t
*
glyphs
)
const
{
return
(
this
+
coverage
)
.
intersects
(
glyphs
)
;
}
void
collect_glyphs
(
hb_collect_glyphs_context_t
*
c
)
const
{
if
(
unlikely
(
!
(
this
+
coverage
)
.
add_coverage
(
c
-
>
input
)
)
)
return
;
}
const
Coverage
&
get_coverage
(
)
const
{
return
this
+
coverage
;
}
bool
apply
(
hb_ot_apply_context_t
*
c
)
const
{
TRACE_APPLY
(
this
)
;
hb_buffer_t
*
buffer
=
c
-
>
buffer
;
unsigned
int
index
=
(
this
+
coverage
)
.
get_coverage
(
buffer
-
>
cur
(
)
.
codepoint
)
;
if
(
likely
(
index
=
=
NOT_COVERED
)
)
return_trace
(
false
)
;
if
(
likely
(
index
>
=
valueCount
)
)
return_trace
(
false
)
;
valueFormat
.
apply_value
(
c
this
&
values
[
index
*
valueFormat
.
get_len
(
)
]
buffer
-
>
cur_pos
(
)
)
;
buffer
-
>
idx
+
+
;
return_trace
(
true
)
;
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
return_trace
(
false
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
coverage
.
sanitize
(
c
this
)
&
&
valueFormat
.
sanitize_values
(
c
this
values
valueCount
)
)
;
}
protected
:
HBUINT16
format
;
OffsetTo
<
Coverage
>
coverage
;
ValueFormat
valueFormat
;
HBUINT16
valueCount
;
ValueRecord
values
;
public
:
DEFINE_SIZE_ARRAY
(
8
values
)
;
}
;
struct
SinglePos
{
template
<
typename
context_t
>
typename
context_t
:
:
return_t
dispatch
(
context_t
*
c
)
const
{
TRACE_DISPATCH
(
this
u
.
format
)
;
if
(
unlikely
(
!
c
-
>
may_dispatch
(
this
&
u
.
format
)
)
)
return_trace
(
c
-
>
no_dispatch_return_value
(
)
)
;
switch
(
u
.
format
)
{
case
1
:
return_trace
(
c
-
>
dispatch
(
u
.
format1
)
)
;
case
2
:
return_trace
(
c
-
>
dispatch
(
u
.
format2
)
)
;
default
:
return_trace
(
c
-
>
default_return_value
(
)
)
;
}
}
protected
:
union
{
HBUINT16
format
;
SinglePosFormat1
format1
;
SinglePosFormat2
format2
;
}
u
;
}
;
struct
PairValueRecord
{
friend
struct
PairSet
;
protected
:
GlyphID
secondGlyph
;
ValueRecord
values
;
public
:
DEFINE_SIZE_ARRAY
(
2
values
)
;
}
;
struct
PairSet
{
friend
struct
PairPosFormat1
;
bool
intersects
(
const
hb_set_t
*
glyphs
const
ValueFormat
*
valueFormats
)
const
{
unsigned
int
len1
=
valueFormats
[
0
]
.
get_len
(
)
;
unsigned
int
len2
=
valueFormats
[
1
]
.
get_len
(
)
;
unsigned
int
record_size
=
HBUINT16
:
:
static_size
*
(
1
+
len1
+
len2
)
;
const
PairValueRecord
*
record
=
&
firstPairValueRecord
;
unsigned
int
count
=
len
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
glyphs
-
>
has
(
record
-
>
secondGlyph
)
)
return
true
;
record
=
&
StructAtOffset
<
const
PairValueRecord
>
(
record
record_size
)
;
}
return
false
;
}
void
collect_glyphs
(
hb_collect_glyphs_context_t
*
c
const
ValueFormat
*
valueFormats
)
const
{
unsigned
int
len1
=
valueFormats
[
0
]
.
get_len
(
)
;
unsigned
int
len2
=
valueFormats
[
1
]
.
get_len
(
)
;
unsigned
int
record_size
=
HBUINT16
:
:
static_size
*
(
1
+
len1
+
len2
)
;
const
PairValueRecord
*
record
=
&
firstPairValueRecord
;
c
-
>
input
-
>
add_array
(
&
record
-
>
secondGlyph
len
record_size
)
;
}
bool
apply
(
hb_ot_apply_context_t
*
c
const
ValueFormat
*
valueFormats
unsigned
int
pos
)
const
{
TRACE_APPLY
(
this
)
;
hb_buffer_t
*
buffer
=
c
-
>
buffer
;
unsigned
int
len1
=
valueFormats
[
0
]
.
get_len
(
)
;
unsigned
int
len2
=
valueFormats
[
1
]
.
get_len
(
)
;
unsigned
int
record_size
=
HBUINT16
:
:
static_size
*
(
1
+
len1
+
len2
)
;
unsigned
int
count
=
len
;
if
(
unlikely
(
!
count
)
)
return_trace
(
false
)
;
hb_codepoint_t
x
=
buffer
-
>
info
[
pos
]
.
codepoint
;
int
min
=
0
max
=
(
int
)
count
-
1
;
while
(
min
<
=
max
)
{
int
mid
=
(
(
unsigned
int
)
min
+
(
unsigned
int
)
max
)
/
2
;
const
PairValueRecord
*
record
=
&
StructAtOffset
<
PairValueRecord
>
(
&
firstPairValueRecord
record_size
*
mid
)
;
hb_codepoint_t
mid_x
=
record
-
>
secondGlyph
;
if
(
x
<
mid_x
)
max
=
mid
-
1
;
else
if
(
x
>
mid_x
)
min
=
mid
+
1
;
else
{
if
(
valueFormats
[
0
]
.
apply_value
(
c
this
&
record
-
>
values
[
0
]
buffer
-
>
cur_pos
(
)
)
|
valueFormats
[
1
]
.
apply_value
(
c
this
&
record
-
>
values
[
len1
]
buffer
-
>
pos
[
pos
]
)
)
buffer
-
>
unsafe_to_break
(
buffer
-
>
idx
pos
+
1
)
;
if
(
len2
)
pos
+
+
;
buffer
-
>
idx
=
pos
;
return_trace
(
true
)
;
}
}
return_trace
(
false
)
;
}
struct
sanitize_closure_t
{
const
void
*
base
;
const
ValueFormat
*
valueFormats
;
unsigned
int
len1
;
unsigned
int
stride
;
}
;
bool
sanitize
(
hb_sanitize_context_t
*
c
const
sanitize_closure_t
*
closure
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
!
(
c
-
>
check_struct
(
this
)
&
&
c
-
>
check_range
(
&
firstPairValueRecord
len
HBUINT16
:
:
static_size
closure
-
>
stride
)
)
)
return_trace
(
false
)
;
unsigned
int
count
=
len
;
const
PairValueRecord
*
record
=
&
firstPairValueRecord
;
return_trace
(
closure
-
>
valueFormats
[
0
]
.
sanitize_values_stride_unsafe
(
c
closure
-
>
base
&
record
-
>
values
[
0
]
count
closure
-
>
stride
)
&
&
closure
-
>
valueFormats
[
1
]
.
sanitize_values_stride_unsafe
(
c
closure
-
>
base
&
record
-
>
values
[
closure
-
>
len1
]
count
closure
-
>
stride
)
)
;
}
protected
:
HBUINT16
len
;
PairValueRecord
firstPairValueRecord
;
public
:
DEFINE_SIZE_MIN
(
2
)
;
}
;
struct
PairPosFormat1
{
bool
intersects
(
const
hb_set_t
*
glyphs
)
const
{
unsigned
int
count
=
pairSet
.
len
;
for
(
Coverage
:
:
Iter
iter
(
this
+
coverage
)
;
iter
.
more
(
)
;
iter
.
next
(
)
)
{
if
(
unlikely
(
iter
.
get_coverage
(
)
>
=
count
)
)
break
;
if
(
glyphs
-
>
has
(
iter
.
get_glyph
(
)
)
&
&
(
this
+
pairSet
[
iter
.
get_coverage
(
)
]
)
.
intersects
(
glyphs
valueFormat
)
)
return
true
;
}
return
false
;
}
void
collect_glyphs
(
hb_collect_glyphs_context_t
*
c
)
const
{
if
(
unlikely
(
!
(
this
+
coverage
)
.
add_coverage
(
c
-
>
input
)
)
)
return
;
unsigned
int
count
=
pairSet
.
len
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
(
this
+
pairSet
[
i
]
)
.
collect_glyphs
(
c
valueFormat
)
;
}
const
Coverage
&
get_coverage
(
)
const
{
return
this
+
coverage
;
}
bool
apply
(
hb_ot_apply_context_t
*
c
)
const
{
TRACE_APPLY
(
this
)
;
hb_buffer_t
*
buffer
=
c
-
>
buffer
;
unsigned
int
index
=
(
this
+
coverage
)
.
get_coverage
(
buffer
-
>
cur
(
)
.
codepoint
)
;
if
(
likely
(
index
=
=
NOT_COVERED
)
)
return_trace
(
false
)
;
hb_ot_apply_context_t
:
:
skipping_iterator_t
&
skippy_iter
=
c
-
>
iter_input
;
skippy_iter
.
reset
(
buffer
-
>
idx
1
)
;
if
(
!
skippy_iter
.
next
(
)
)
return_trace
(
false
)
;
return_trace
(
(
this
+
pairSet
[
index
]
)
.
apply
(
c
valueFormat
skippy_iter
.
idx
)
)
;
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
return_trace
(
false
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
!
c
-
>
check_struct
(
this
)
)
return_trace
(
false
)
;
unsigned
int
len1
=
valueFormat
[
0
]
.
get_len
(
)
;
unsigned
int
len2
=
valueFormat
[
1
]
.
get_len
(
)
;
PairSet
:
:
sanitize_closure_t
closure
=
{
this
valueFormat
len1
1
+
len1
+
len2
}
;
return_trace
(
coverage
.
sanitize
(
c
this
)
&
&
pairSet
.
sanitize
(
c
this
&
closure
)
)
;
}
protected
:
HBUINT16
format
;
OffsetTo
<
Coverage
>
coverage
;
ValueFormat
valueFormat
[
2
]
;
OffsetArrayOf
<
PairSet
>
pairSet
;
public
:
DEFINE_SIZE_ARRAY
(
10
pairSet
)
;
}
;
struct
PairPosFormat2
{
bool
intersects
(
const
hb_set_t
*
glyphs
)
const
{
return
(
this
+
coverage
)
.
intersects
(
glyphs
)
&
&
(
this
+
classDef2
)
.
intersects
(
glyphs
)
;
}
void
collect_glyphs
(
hb_collect_glyphs_context_t
*
c
)
const
{
if
(
unlikely
(
!
(
this
+
coverage
)
.
add_coverage
(
c
-
>
input
)
)
)
return
;
if
(
unlikely
(
!
(
this
+
classDef2
)
.
add_coverage
(
c
-
>
input
)
)
)
return
;
}
const
Coverage
&
get_coverage
(
)
const
{
return
this
+
coverage
;
}
bool
apply
(
hb_ot_apply_context_t
*
c
)
const
{
TRACE_APPLY
(
this
)
;
hb_buffer_t
*
buffer
=
c
-
>
buffer
;
unsigned
int
index
=
(
this
+
coverage
)
.
get_coverage
(
buffer
-
>
cur
(
)
.
codepoint
)
;
if
(
likely
(
index
=
=
NOT_COVERED
)
)
return_trace
(
false
)
;
hb_ot_apply_context_t
:
:
skipping_iterator_t
&
skippy_iter
=
c
-
>
iter_input
;
skippy_iter
.
reset
(
buffer
-
>
idx
1
)
;
if
(
!
skippy_iter
.
next
(
)
)
return_trace
(
false
)
;
unsigned
int
len1
=
valueFormat1
.
get_len
(
)
;
unsigned
int
len2
=
valueFormat2
.
get_len
(
)
;
unsigned
int
record_len
=
len1
+
len2
;
unsigned
int
klass1
=
(
this
+
classDef1
)
.
get_class
(
buffer
-
>
cur
(
)
.
codepoint
)
;
unsigned
int
klass2
=
(
this
+
classDef2
)
.
get_class
(
buffer
-
>
info
[
skippy_iter
.
idx
]
.
codepoint
)
;
if
(
unlikely
(
klass1
>
=
class1Count
|
|
klass2
>
=
class2Count
)
)
return_trace
(
false
)
;
const
Value
*
v
=
&
values
[
record_len
*
(
klass1
*
class2Count
+
klass2
)
]
;
if
(
valueFormat1
.
apply_value
(
c
this
v
buffer
-
>
cur_pos
(
)
)
|
valueFormat2
.
apply_value
(
c
this
v
+
len1
buffer
-
>
pos
[
skippy_iter
.
idx
]
)
)
buffer
-
>
unsafe_to_break
(
buffer
-
>
idx
skippy_iter
.
idx
+
1
)
;
buffer
-
>
idx
=
skippy_iter
.
idx
;
if
(
len2
)
buffer
-
>
idx
+
+
;
return_trace
(
true
)
;
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
return_trace
(
false
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
!
(
c
-
>
check_struct
(
this
)
&
&
coverage
.
sanitize
(
c
this
)
&
&
classDef1
.
sanitize
(
c
this
)
&
&
classDef2
.
sanitize
(
c
this
)
)
)
return_trace
(
false
)
;
unsigned
int
len1
=
valueFormat1
.
get_len
(
)
;
unsigned
int
len2
=
valueFormat2
.
get_len
(
)
;
unsigned
int
stride
=
len1
+
len2
;
unsigned
int
record_size
=
valueFormat1
.
get_size
(
)
+
valueFormat2
.
get_size
(
)
;
unsigned
int
count
=
(
unsigned
int
)
class1Count
*
(
unsigned
int
)
class2Count
;
return_trace
(
c
-
>
check_range
(
(
const
void
*
)
values
count
record_size
)
&
&
valueFormat1
.
sanitize_values_stride_unsafe
(
c
this
&
values
[
0
]
count
stride
)
&
&
valueFormat2
.
sanitize_values_stride_unsafe
(
c
this
&
values
[
len1
]
count
stride
)
)
;
}
protected
:
HBUINT16
format
;
OffsetTo
<
Coverage
>
coverage
;
ValueFormat
valueFormat1
;
ValueFormat
valueFormat2
;
OffsetTo
<
ClassDef
>
classDef1
;
OffsetTo
<
ClassDef
>
classDef2
;
HBUINT16
class1Count
;
HBUINT16
class2Count
;
ValueRecord
values
;
public
:
DEFINE_SIZE_ARRAY
(
16
values
)
;
}
;
struct
PairPos
{
template
<
typename
context_t
>
typename
context_t
:
:
return_t
dispatch
(
context_t
*
c
)
const
{
TRACE_DISPATCH
(
this
u
.
format
)
;
if
(
unlikely
(
!
c
-
>
may_dispatch
(
this
&
u
.
format
)
)
)
return_trace
(
c
-
>
no_dispatch_return_value
(
)
)
;
switch
(
u
.
format
)
{
case
1
:
return_trace
(
c
-
>
dispatch
(
u
.
format1
)
)
;
case
2
:
return_trace
(
c
-
>
dispatch
(
u
.
format2
)
)
;
default
:
return_trace
(
c
-
>
default_return_value
(
)
)
;
}
}
protected
:
union
{
HBUINT16
format
;
PairPosFormat1
format1
;
PairPosFormat2
format2
;
}
u
;
}
;
struct
EntryExitRecord
{
friend
struct
CursivePosFormat1
;
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
entryAnchor
.
sanitize
(
c
base
)
&
&
exitAnchor
.
sanitize
(
c
base
)
)
;
}
protected
:
OffsetTo
<
Anchor
>
entryAnchor
;
OffsetTo
<
Anchor
>
exitAnchor
;
public
:
DEFINE_SIZE_STATIC
(
4
)
;
}
;
static
void
reverse_cursive_minor_offset
(
hb_glyph_position_t
*
pos
unsigned
int
i
hb_direction_t
direction
unsigned
int
new_parent
)
;
struct
CursivePosFormat1
{
bool
intersects
(
const
hb_set_t
*
glyphs
)
const
{
return
(
this
+
coverage
)
.
intersects
(
glyphs
)
;
}
void
collect_glyphs
(
hb_collect_glyphs_context_t
*
c
)
const
{
if
(
unlikely
(
!
(
this
+
coverage
)
.
add_coverage
(
c
-
>
input
)
)
)
return
;
}
const
Coverage
&
get_coverage
(
)
const
{
return
this
+
coverage
;
}
bool
apply
(
hb_ot_apply_context_t
*
c
)
const
{
TRACE_APPLY
(
this
)
;
hb_buffer_t
*
buffer
=
c
-
>
buffer
;
const
EntryExitRecord
&
this_record
=
entryExitRecord
[
(
this
+
coverage
)
.
get_coverage
(
buffer
-
>
cur
(
)
.
codepoint
)
]
;
if
(
!
this_record
.
entryAnchor
)
return_trace
(
false
)
;
hb_ot_apply_context_t
:
:
skipping_iterator_t
&
skippy_iter
=
c
-
>
iter_input
;
skippy_iter
.
reset
(
buffer
-
>
idx
1
)
;
if
(
!
skippy_iter
.
prev
(
)
)
return_trace
(
false
)
;
const
EntryExitRecord
&
prev_record
=
entryExitRecord
[
(
this
+
coverage
)
.
get_coverage
(
buffer
-
>
info
[
skippy_iter
.
idx
]
.
codepoint
)
]
;
if
(
!
prev_record
.
exitAnchor
)
return_trace
(
false
)
;
unsigned
int
i
=
skippy_iter
.
idx
;
unsigned
int
j
=
buffer
-
>
idx
;
buffer
-
>
unsafe_to_break
(
i
j
)
;
float
entry_x
entry_y
exit_x
exit_y
;
(
this
+
prev_record
.
exitAnchor
)
.
get_anchor
(
c
buffer
-
>
info
[
i
]
.
codepoint
&
exit_x
&
exit_y
)
;
(
this
+
this_record
.
entryAnchor
)
.
get_anchor
(
c
buffer
-
>
info
[
j
]
.
codepoint
&
entry_x
&
entry_y
)
;
hb_glyph_position_t
*
pos
=
buffer
-
>
pos
;
hb_position_t
d
;
switch
(
c
-
>
direction
)
{
case
HB_DIRECTION_LTR
:
pos
[
i
]
.
x_advance
=
round
(
exit_x
)
+
pos
[
i
]
.
x_offset
;
d
=
round
(
entry_x
)
+
pos
[
j
]
.
x_offset
;
pos
[
j
]
.
x_advance
-
=
d
;
pos
[
j
]
.
x_offset
-
=
d
;
break
;
case
HB_DIRECTION_RTL
:
d
=
round
(
exit_x
)
+
pos
[
i
]
.
x_offset
;
pos
[
i
]
.
x_advance
-
=
d
;
pos
[
i
]
.
x_offset
-
=
d
;
pos
[
j
]
.
x_advance
=
round
(
entry_x
)
+
pos
[
j
]
.
x_offset
;
break
;
case
HB_DIRECTION_TTB
:
pos
[
i
]
.
y_advance
=
round
(
exit_y
)
+
pos
[
i
]
.
y_offset
;
d
=
round
(
entry_y
)
+
pos
[
j
]
.
y_offset
;
pos
[
j
]
.
y_advance
-
=
d
;
pos
[
j
]
.
y_offset
-
=
d
;
break
;
case
HB_DIRECTION_BTT
:
d
=
round
(
exit_y
)
+
pos
[
i
]
.
y_offset
;
pos
[
i
]
.
y_advance
-
=
d
;
pos
[
i
]
.
y_offset
-
=
d
;
pos
[
j
]
.
y_advance
=
round
(
entry_y
)
;
break
;
case
HB_DIRECTION_INVALID
:
default
:
break
;
}
unsigned
int
child
=
i
;
unsigned
int
parent
=
j
;
hb_position_t
x_offset
=
entry_x
-
exit_x
;
hb_position_t
y_offset
=
entry_y
-
exit_y
;
if
(
!
(
c
-
>
lookup_props
&
LookupFlag
:
:
RightToLeft
)
)
{
unsigned
int
k
=
child
;
child
=
parent
;
parent
=
k
;
x_offset
=
-
x_offset
;
y_offset
=
-
y_offset
;
}
reverse_cursive_minor_offset
(
pos
child
c
-
>
direction
parent
)
;
pos
[
child
]
.
attach_type
(
)
=
ATTACH_TYPE_CURSIVE
;
pos
[
child
]
.
attach_chain
(
)
=
(
int
)
parent
-
(
int
)
child
;
buffer
-
>
scratch_flags
|
=
HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT
;
if
(
likely
(
HB_DIRECTION_IS_HORIZONTAL
(
c
-
>
direction
)
)
)
pos
[
child
]
.
y_offset
=
y_offset
;
else
pos
[
child
]
.
x_offset
=
x_offset
;
buffer
-
>
idx
+
+
;
return_trace
(
true
)
;
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
return_trace
(
false
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
coverage
.
sanitize
(
c
this
)
&
&
entryExitRecord
.
sanitize
(
c
this
)
)
;
}
protected
:
HBUINT16
format
;
OffsetTo
<
Coverage
>
coverage
;
ArrayOf
<
EntryExitRecord
>
entryExitRecord
;
public
:
DEFINE_SIZE_ARRAY
(
6
entryExitRecord
)
;
}
;
struct
CursivePos
{
template
<
typename
context_t
>
typename
context_t
:
:
return_t
dispatch
(
context_t
*
c
)
const
{
TRACE_DISPATCH
(
this
u
.
format
)
;
if
(
unlikely
(
!
c
-
>
may_dispatch
(
this
&
u
.
format
)
)
)
return_trace
(
c
-
>
no_dispatch_return_value
(
)
)
;
switch
(
u
.
format
)
{
case
1
:
return_trace
(
c
-
>
dispatch
(
u
.
format1
)
)
;
default
:
return_trace
(
c
-
>
default_return_value
(
)
)
;
}
}
protected
:
union
{
HBUINT16
format
;
CursivePosFormat1
format1
;
}
u
;
}
;
typedef
AnchorMatrix
BaseArray
;
struct
MarkBasePosFormat1
{
bool
intersects
(
const
hb_set_t
*
glyphs
)
const
{
return
(
this
+
markCoverage
)
.
intersects
(
glyphs
)
&
&
(
this
+
baseCoverage
)
.
intersects
(
glyphs
)
;
}
void
collect_glyphs
(
hb_collect_glyphs_context_t
*
c
)
const
{
if
(
unlikely
(
!
(
this
+
markCoverage
)
.
add_coverage
(
c
-
>
input
)
)
)
return
;
if
(
unlikely
(
!
(
this
+
baseCoverage
)
.
add_coverage
(
c
-
>
input
)
)
)
return
;
}
const
Coverage
&
get_coverage
(
)
const
{
return
this
+
markCoverage
;
}
bool
apply
(
hb_ot_apply_context_t
*
c
)
const
{
TRACE_APPLY
(
this
)
;
hb_buffer_t
*
buffer
=
c
-
>
buffer
;
unsigned
int
mark_index
=
(
this
+
markCoverage
)
.
get_coverage
(
buffer
-
>
cur
(
)
.
codepoint
)
;
if
(
likely
(
mark_index
=
=
NOT_COVERED
)
)
return_trace
(
false
)
;
hb_ot_apply_context_t
:
:
skipping_iterator_t
&
skippy_iter
=
c
-
>
iter_input
;
skippy_iter
.
reset
(
buffer
-
>
idx
1
)
;
skippy_iter
.
set_lookup_props
(
LookupFlag
:
:
IgnoreMarks
)
;
do
{
if
(
!
skippy_iter
.
prev
(
)
)
return_trace
(
false
)
;
if
(
!
_hb_glyph_info_multiplied
(
&
buffer
-
>
info
[
skippy_iter
.
idx
]
)
|
|
0
=
=
_hb_glyph_info_get_lig_comp
(
&
buffer
-
>
info
[
skippy_iter
.
idx
]
)
|
|
(
skippy_iter
.
idx
=
=
0
|
|
_hb_glyph_info_is_mark
(
&
buffer
-
>
info
[
skippy_iter
.
idx
-
1
]
)
|
|
_hb_glyph_info_get_lig_id
(
&
buffer
-
>
info
[
skippy_iter
.
idx
]
)
!
=
_hb_glyph_info_get_lig_id
(
&
buffer
-
>
info
[
skippy_iter
.
idx
-
1
]
)
|
|
_hb_glyph_info_get_lig_comp
(
&
buffer
-
>
info
[
skippy_iter
.
idx
]
)
!
=
_hb_glyph_info_get_lig_comp
(
&
buffer
-
>
info
[
skippy_iter
.
idx
-
1
]
)
+
1
)
)
break
;
skippy_iter
.
reject
(
)
;
}
while
(
true
)
;
unsigned
int
base_index
=
(
this
+
baseCoverage
)
.
get_coverage
(
buffer
-
>
info
[
skippy_iter
.
idx
]
.
codepoint
)
;
if
(
base_index
=
=
NOT_COVERED
)
return_trace
(
false
)
;
return_trace
(
(
this
+
markArray
)
.
apply
(
c
mark_index
base_index
this
+
baseArray
classCount
skippy_iter
.
idx
)
)
;
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
return_trace
(
false
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
markCoverage
.
sanitize
(
c
this
)
&
&
baseCoverage
.
sanitize
(
c
this
)
&
&
markArray
.
sanitize
(
c
this
)
&
&
baseArray
.
sanitize
(
c
this
(
unsigned
int
)
classCount
)
)
;
}
protected
:
HBUINT16
format
;
OffsetTo
<
Coverage
>
markCoverage
;
OffsetTo
<
Coverage
>
baseCoverage
;
HBUINT16
classCount
;
OffsetTo
<
MarkArray
>
markArray
;
OffsetTo
<
BaseArray
>
baseArray
;
public
:
DEFINE_SIZE_STATIC
(
12
)
;
}
;
struct
MarkBasePos
{
template
<
typename
context_t
>
typename
context_t
:
:
return_t
dispatch
(
context_t
*
c
)
const
{
TRACE_DISPATCH
(
this
u
.
format
)
;
if
(
unlikely
(
!
c
-
>
may_dispatch
(
this
&
u
.
format
)
)
)
return_trace
(
c
-
>
no_dispatch_return_value
(
)
)
;
switch
(
u
.
format
)
{
case
1
:
return_trace
(
c
-
>
dispatch
(
u
.
format1
)
)
;
default
:
return_trace
(
c
-
>
default_return_value
(
)
)
;
}
}
protected
:
union
{
HBUINT16
format
;
MarkBasePosFormat1
format1
;
}
u
;
}
;
typedef
AnchorMatrix
LigatureAttach
;
typedef
OffsetListOf
<
LigatureAttach
>
LigatureArray
;
struct
MarkLigPosFormat1
{
bool
intersects
(
const
hb_set_t
*
glyphs
)
const
{
return
(
this
+
markCoverage
)
.
intersects
(
glyphs
)
&
&
(
this
+
ligatureCoverage
)
.
intersects
(
glyphs
)
;
}
void
collect_glyphs
(
hb_collect_glyphs_context_t
*
c
)
const
{
if
(
unlikely
(
!
(
this
+
markCoverage
)
.
add_coverage
(
c
-
>
input
)
)
)
return
;
if
(
unlikely
(
!
(
this
+
ligatureCoverage
)
.
add_coverage
(
c
-
>
input
)
)
)
return
;
}
const
Coverage
&
get_coverage
(
)
const
{
return
this
+
markCoverage
;
}
bool
apply
(
hb_ot_apply_context_t
*
c
)
const
{
TRACE_APPLY
(
this
)
;
hb_buffer_t
*
buffer
=
c
-
>
buffer
;
unsigned
int
mark_index
=
(
this
+
markCoverage
)
.
get_coverage
(
buffer
-
>
cur
(
)
.
codepoint
)
;
if
(
likely
(
mark_index
=
=
NOT_COVERED
)
)
return_trace
(
false
)
;
hb_ot_apply_context_t
:
:
skipping_iterator_t
&
skippy_iter
=
c
-
>
iter_input
;
skippy_iter
.
reset
(
buffer
-
>
idx
1
)
;
skippy_iter
.
set_lookup_props
(
LookupFlag
:
:
IgnoreMarks
)
;
if
(
!
skippy_iter
.
prev
(
)
)
return_trace
(
false
)
;
unsigned
int
j
=
skippy_iter
.
idx
;
unsigned
int
lig_index
=
(
this
+
ligatureCoverage
)
.
get_coverage
(
buffer
-
>
info
[
j
]
.
codepoint
)
;
if
(
lig_index
=
=
NOT_COVERED
)
return_trace
(
false
)
;
const
LigatureArray
&
lig_array
=
this
+
ligatureArray
;
const
LigatureAttach
&
lig_attach
=
lig_array
[
lig_index
]
;
unsigned
int
comp_count
=
lig_attach
.
rows
;
if
(
unlikely
(
!
comp_count
)
)
return_trace
(
false
)
;
unsigned
int
comp_index
;
unsigned
int
lig_id
=
_hb_glyph_info_get_lig_id
(
&
buffer
-
>
info
[
j
]
)
;
unsigned
int
mark_id
=
_hb_glyph_info_get_lig_id
(
&
buffer
-
>
cur
(
)
)
;
unsigned
int
mark_comp
=
_hb_glyph_info_get_lig_comp
(
&
buffer
-
>
cur
(
)
)
;
if
(
lig_id
&
&
lig_id
=
=
mark_id
&
&
mark_comp
>
0
)
comp_index
=
MIN
(
comp_count
_hb_glyph_info_get_lig_comp
(
&
buffer
-
>
cur
(
)
)
)
-
1
;
else
comp_index
=
comp_count
-
1
;
return_trace
(
(
this
+
markArray
)
.
apply
(
c
mark_index
comp_index
lig_attach
classCount
j
)
)
;
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
return_trace
(
false
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
markCoverage
.
sanitize
(
c
this
)
&
&
ligatureCoverage
.
sanitize
(
c
this
)
&
&
markArray
.
sanitize
(
c
this
)
&
&
ligatureArray
.
sanitize
(
c
this
(
unsigned
int
)
classCount
)
)
;
}
protected
:
HBUINT16
format
;
OffsetTo
<
Coverage
>
markCoverage
;
OffsetTo
<
Coverage
>
ligatureCoverage
;
HBUINT16
classCount
;
OffsetTo
<
MarkArray
>
markArray
;
OffsetTo
<
LigatureArray
>
ligatureArray
;
public
:
DEFINE_SIZE_STATIC
(
12
)
;
}
;
struct
MarkLigPos
{
template
<
typename
context_t
>
typename
context_t
:
:
return_t
dispatch
(
context_t
*
c
)
const
{
TRACE_DISPATCH
(
this
u
.
format
)
;
if
(
unlikely
(
!
c
-
>
may_dispatch
(
this
&
u
.
format
)
)
)
return_trace
(
c
-
>
no_dispatch_return_value
(
)
)
;
switch
(
u
.
format
)
{
case
1
:
return_trace
(
c
-
>
dispatch
(
u
.
format1
)
)
;
default
:
return_trace
(
c
-
>
default_return_value
(
)
)
;
}
}
protected
:
union
{
HBUINT16
format
;
MarkLigPosFormat1
format1
;
}
u
;
}
;
typedef
AnchorMatrix
Mark2Array
;
struct
MarkMarkPosFormat1
{
bool
intersects
(
const
hb_set_t
*
glyphs
)
const
{
return
(
this
+
mark1Coverage
)
.
intersects
(
glyphs
)
&
&
(
this
+
mark2Coverage
)
.
intersects
(
glyphs
)
;
}
void
collect_glyphs
(
hb_collect_glyphs_context_t
*
c
)
const
{
if
(
unlikely
(
!
(
this
+
mark1Coverage
)
.
add_coverage
(
c
-
>
input
)
)
)
return
;
if
(
unlikely
(
!
(
this
+
mark2Coverage
)
.
add_coverage
(
c
-
>
input
)
)
)
return
;
}
const
Coverage
&
get_coverage
(
)
const
{
return
this
+
mark1Coverage
;
}
bool
apply
(
hb_ot_apply_context_t
*
c
)
const
{
TRACE_APPLY
(
this
)
;
hb_buffer_t
*
buffer
=
c
-
>
buffer
;
unsigned
int
mark1_index
=
(
this
+
mark1Coverage
)
.
get_coverage
(
buffer
-
>
cur
(
)
.
codepoint
)
;
if
(
likely
(
mark1_index
=
=
NOT_COVERED
)
)
return_trace
(
false
)
;
hb_ot_apply_context_t
:
:
skipping_iterator_t
&
skippy_iter
=
c
-
>
iter_input
;
skippy_iter
.
reset
(
buffer
-
>
idx
1
)
;
skippy_iter
.
set_lookup_props
(
c
-
>
lookup_props
&
~
LookupFlag
:
:
IgnoreFlags
)
;
if
(
!
skippy_iter
.
prev
(
)
)
return_trace
(
false
)
;
if
(
!
_hb_glyph_info_is_mark
(
&
buffer
-
>
info
[
skippy_iter
.
idx
]
)
)
{
return_trace
(
false
)
;
}
unsigned
int
j
=
skippy_iter
.
idx
;
unsigned
int
id1
=
_hb_glyph_info_get_lig_id
(
&
buffer
-
>
cur
(
)
)
;
unsigned
int
id2
=
_hb_glyph_info_get_lig_id
(
&
buffer
-
>
info
[
j
]
)
;
unsigned
int
comp1
=
_hb_glyph_info_get_lig_comp
(
&
buffer
-
>
cur
(
)
)
;
unsigned
int
comp2
=
_hb_glyph_info_get_lig_comp
(
&
buffer
-
>
info
[
j
]
)
;
if
(
likely
(
id1
=
=
id2
)
)
{
if
(
id1
=
=
0
)
goto
good
;
else
if
(
comp1
=
=
comp2
)
goto
good
;
}
else
{
if
(
(
id1
>
0
&
&
!
comp1
)
|
|
(
id2
>
0
&
&
!
comp2
)
)
goto
good
;
}
return_trace
(
false
)
;
good
:
unsigned
int
mark2_index
=
(
this
+
mark2Coverage
)
.
get_coverage
(
buffer
-
>
info
[
j
]
.
codepoint
)
;
if
(
mark2_index
=
=
NOT_COVERED
)
return_trace
(
false
)
;
return_trace
(
(
this
+
mark1Array
)
.
apply
(
c
mark1_index
mark2_index
this
+
mark2Array
classCount
j
)
)
;
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
return_trace
(
false
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
mark1Coverage
.
sanitize
(
c
this
)
&
&
mark2Coverage
.
sanitize
(
c
this
)
&
&
mark1Array
.
sanitize
(
c
this
)
&
&
mark2Array
.
sanitize
(
c
this
(
unsigned
int
)
classCount
)
)
;
}
protected
:
HBUINT16
format
;
OffsetTo
<
Coverage
>
mark1Coverage
;
OffsetTo
<
Coverage
>
mark2Coverage
;
HBUINT16
classCount
;
OffsetTo
<
MarkArray
>
mark1Array
;
OffsetTo
<
Mark2Array
>
mark2Array
;
public
:
DEFINE_SIZE_STATIC
(
12
)
;
}
;
struct
MarkMarkPos
{
template
<
typename
context_t
>
typename
context_t
:
:
return_t
dispatch
(
context_t
*
c
)
const
{
TRACE_DISPATCH
(
this
u
.
format
)
;
if
(
unlikely
(
!
c
-
>
may_dispatch
(
this
&
u
.
format
)
)
)
return_trace
(
c
-
>
no_dispatch_return_value
(
)
)
;
switch
(
u
.
format
)
{
case
1
:
return_trace
(
c
-
>
dispatch
(
u
.
format1
)
)
;
default
:
return_trace
(
c
-
>
default_return_value
(
)
)
;
}
}
protected
:
union
{
HBUINT16
format
;
MarkMarkPosFormat1
format1
;
}
u
;
}
;
struct
ContextPos
:
Context
{
}
;
struct
ChainContextPos
:
ChainContext
{
}
;
struct
ExtensionPos
:
Extension
<
ExtensionPos
>
{
typedef
struct
PosLookupSubTable
SubTable
;
}
;
struct
PosLookupSubTable
{
friend
struct
Lookup
;
friend
struct
PosLookup
;
enum
Type
{
Single
=
1
Pair
=
2
Cursive
=
3
MarkBase
=
4
MarkLig
=
5
MarkMark
=
6
Context
=
7
ChainContext
=
8
Extension
=
9
}
;
template
<
typename
context_t
>
typename
context_t
:
:
return_t
dispatch
(
context_t
*
c
unsigned
int
lookup_type
)
const
{
TRACE_DISPATCH
(
this
lookup_type
)
;
switch
(
lookup_type
)
{
case
Single
:
return_trace
(
u
.
single
.
dispatch
(
c
)
)
;
case
Pair
:
return_trace
(
u
.
pair
.
dispatch
(
c
)
)
;
case
Cursive
:
return_trace
(
u
.
cursive
.
dispatch
(
c
)
)
;
case
MarkBase
:
return_trace
(
u
.
markBase
.
dispatch
(
c
)
)
;
case
MarkLig
:
return_trace
(
u
.
markLig
.
dispatch
(
c
)
)
;
case
MarkMark
:
return_trace
(
u
.
markMark
.
dispatch
(
c
)
)
;
case
Context
:
return_trace
(
u
.
context
.
dispatch
(
c
)
)
;
case
ChainContext
:
return_trace
(
u
.
chainContext
.
dispatch
(
c
)
)
;
case
Extension
:
return_trace
(
u
.
extension
.
dispatch
(
c
)
)
;
default
:
return_trace
(
c
-
>
default_return_value
(
)
)
;
}
}
protected
:
union
{
SinglePos
single
;
PairPos
pair
;
CursivePos
cursive
;
MarkBasePos
markBase
;
MarkLigPos
markLig
;
MarkMarkPos
markMark
;
ContextPos
context
;
ChainContextPos
chainContext
;
ExtensionPos
extension
;
}
u
;
public
:
DEFINE_SIZE_MIN
(
0
)
;
}
;
struct
PosLookup
:
Lookup
{
typedef
struct
PosLookupSubTable
SubTable
;
const
SubTable
&
get_subtable
(
unsigned
int
i
)
const
{
return
Lookup
:
:
get_subtable
<
SubTable
>
(
i
)
;
}
bool
is_reverse
(
)
const
{
return
false
;
}
bool
apply
(
hb_ot_apply_context_t
*
c
)
const
{
TRACE_APPLY
(
this
)
;
return_trace
(
dispatch
(
c
)
)
;
}
bool
intersects
(
const
hb_set_t
*
glyphs
)
const
{
hb_intersects_context_t
c
(
glyphs
)
;
return
dispatch
(
&
c
)
;
}
hb_collect_glyphs_context_t
:
:
return_t
collect_glyphs
(
hb_collect_glyphs_context_t
*
c
)
const
{
return
dispatch
(
c
)
;
}
template
<
typename
set_t
>
void
add_coverage
(
set_t
*
glyphs
)
const
{
hb_add_coverage_context_t
<
set_t
>
c
(
glyphs
)
;
dispatch
(
&
c
)
;
}
static
bool
apply_recurse_func
(
hb_ot_apply_context_t
*
c
unsigned
int
lookup_index
)
;
template
<
typename
context_t
>
static
typename
context_t
:
:
return_t
dispatch_recurse_func
(
context_t
*
c
unsigned
int
lookup_index
)
;
template
<
typename
context_t
>
typename
context_t
:
:
return_t
dispatch
(
context_t
*
c
)
const
{
return
Lookup
:
:
dispatch
<
SubTable
>
(
c
)
;
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
return
Lookup
:
:
subset
<
SubTable
>
(
c
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
return
Lookup
:
:
sanitize
<
SubTable
>
(
c
)
;
}
}
;
struct
GPOS
:
GSUBGPOS
{
static
constexpr
hb_tag_t
tableTag
=
HB_OT_TAG_GPOS
;
const
PosLookup
&
get_lookup
(
unsigned
int
i
)
const
{
return
CastR
<
PosLookup
>
(
GSUBGPOS
:
:
get_lookup
(
i
)
)
;
}
static
inline
void
position_start
(
hb_font_t
*
font
hb_buffer_t
*
buffer
)
;
static
inline
void
position_finish_advances
(
hb_font_t
*
font
hb_buffer_t
*
buffer
)
;
static
inline
void
position_finish_offsets
(
hb_font_t
*
font
hb_buffer_t
*
buffer
)
;
bool
subset
(
hb_subset_context_t
*
c
)
const
{
return
GSUBGPOS
:
:
subset
<
PosLookup
>
(
c
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
return
GSUBGPOS
:
:
sanitize
<
PosLookup
>
(
c
)
;
}
HB_INTERNAL
bool
is_blacklisted
(
hb_blob_t
*
blob
hb_face_t
*
face
)
const
;
typedef
GSUBGPOS
:
:
accelerator_t
<
GPOS
>
accelerator_t
;
}
;
static
void
reverse_cursive_minor_offset
(
hb_glyph_position_t
*
pos
unsigned
int
i
hb_direction_t
direction
unsigned
int
new_parent
)
{
int
chain
=
pos
[
i
]
.
attach_chain
(
)
type
=
pos
[
i
]
.
attach_type
(
)
;
if
(
likely
(
!
chain
|
|
0
=
=
(
type
&
ATTACH_TYPE_CURSIVE
)
)
)
return
;
pos
[
i
]
.
attach_chain
(
)
=
0
;
unsigned
int
j
=
(
int
)
i
+
chain
;
if
(
j
=
=
new_parent
)
return
;
reverse_cursive_minor_offset
(
pos
j
direction
new_parent
)
;
if
(
HB_DIRECTION_IS_HORIZONTAL
(
direction
)
)
pos
[
j
]
.
y_offset
=
-
pos
[
i
]
.
y_offset
;
else
pos
[
j
]
.
x_offset
=
-
pos
[
i
]
.
x_offset
;
pos
[
j
]
.
attach_chain
(
)
=
-
chain
;
pos
[
j
]
.
attach_type
(
)
=
type
;
}
static
void
propagate_attachment_offsets
(
hb_glyph_position_t
*
pos
unsigned
int
len
unsigned
int
i
hb_direction_t
direction
)
{
int
chain
=
pos
[
i
]
.
attach_chain
(
)
type
=
pos
[
i
]
.
attach_type
(
)
;
if
(
likely
(
!
chain
)
)
return
;
pos
[
i
]
.
attach_chain
(
)
=
0
;
unsigned
int
j
=
(
int
)
i
+
chain
;
if
(
unlikely
(
j
>
=
len
)
)
return
;
propagate_attachment_offsets
(
pos
len
j
direction
)
;
assert
(
!
!
(
type
&
ATTACH_TYPE_MARK
)
^
!
!
(
type
&
ATTACH_TYPE_CURSIVE
)
)
;
if
(
type
&
ATTACH_TYPE_CURSIVE
)
{
if
(
HB_DIRECTION_IS_HORIZONTAL
(
direction
)
)
pos
[
i
]
.
y_offset
+
=
pos
[
j
]
.
y_offset
;
else
pos
[
i
]
.
x_offset
+
=
pos
[
j
]
.
x_offset
;
}
else
{
pos
[
i
]
.
x_offset
+
=
pos
[
j
]
.
x_offset
;
pos
[
i
]
.
y_offset
+
=
pos
[
j
]
.
y_offset
;
assert
(
j
<
i
)
;
if
(
HB_DIRECTION_IS_FORWARD
(
direction
)
)
for
(
unsigned
int
k
=
j
;
k
<
i
;
k
+
+
)
{
pos
[
i
]
.
x_offset
-
=
pos
[
k
]
.
x_advance
;
pos
[
i
]
.
y_offset
-
=
pos
[
k
]
.
y_advance
;
}
else
for
(
unsigned
int
k
=
j
+
1
;
k
<
i
+
1
;
k
+
+
)
{
pos
[
i
]
.
x_offset
+
=
pos
[
k
]
.
x_advance
;
pos
[
i
]
.
y_offset
+
=
pos
[
k
]
.
y_advance
;
}
}
}
void
GPOS
:
:
position_start
(
hb_font_t
*
font
HB_UNUSED
hb_buffer_t
*
buffer
)
{
unsigned
int
count
=
buffer
-
>
len
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
buffer
-
>
pos
[
i
]
.
attach_chain
(
)
=
buffer
-
>
pos
[
i
]
.
attach_type
(
)
=
0
;
}
void
GPOS
:
:
position_finish_advances
(
hb_font_t
*
font
HB_UNUSED
hb_buffer_t
*
buffer
HB_UNUSED
)
{
}
void
GPOS
:
:
position_finish_offsets
(
hb_font_t
*
font
HB_UNUSED
hb_buffer_t
*
buffer
)
{
_hb_buffer_assert_gsubgpos_vars
(
buffer
)
;
unsigned
int
len
;
hb_glyph_position_t
*
pos
=
hb_buffer_get_glyph_positions
(
buffer
&
len
)
;
hb_direction_t
direction
=
buffer
-
>
props
.
direction
;
if
(
buffer
-
>
scratch_flags
&
HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT
)
for
(
unsigned
int
i
=
0
;
i
<
len
;
i
+
+
)
propagate_attachment_offsets
(
pos
len
i
direction
)
;
}
struct
GPOS_accelerator_t
:
GPOS
:
:
accelerator_t
{
}
;
template
<
typename
context_t
>
inline
typename
context_t
:
:
return_t
PosLookup
:
:
dispatch_recurse_func
(
context_t
*
c
unsigned
int
lookup_index
)
{
const
PosLookup
&
l
=
c
-
>
face
-
>
table
.
GPOS
.
get_relaxed
(
)
-
>
table
-
>
get_lookup
(
lookup_index
)
;
return
l
.
dispatch
(
c
)
;
}
inline
bool
PosLookup
:
:
apply_recurse_func
(
hb_ot_apply_context_t
*
c
unsigned
int
lookup_index
)
{
const
PosLookup
&
l
=
c
-
>
face
-
>
table
.
GPOS
.
get_relaxed
(
)
-
>
table
-
>
get_lookup
(
lookup_index
)
;
unsigned
int
saved_lookup_props
=
c
-
>
lookup_props
;
unsigned
int
saved_lookup_index
=
c
-
>
lookup_index
;
c
-
>
set_lookup_index
(
lookup_index
)
;
c
-
>
set_lookup_props
(
l
.
get_props
(
)
)
;
bool
ret
=
l
.
dispatch
(
c
)
;
c
-
>
set_lookup_index
(
saved_lookup_index
)
;
c
-
>
set_lookup_props
(
saved_lookup_props
)
;
return
ret
;
}
}
#
endif
