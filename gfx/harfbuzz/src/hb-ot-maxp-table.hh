#
ifndef
HB_OT_MAXP_TABLE_HH
#
define
HB_OT_MAXP_TABLE_HH
#
include
"
hb
-
open
-
type
.
hh
"
namespace
OT
{
#
define
HB_OT_TAG_maxp
HB_TAG
(
'
m
'
'
a
'
'
x
'
'
p
'
)
struct
maxpV1Tail
{
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
HBUINT16
maxPoints
;
HBUINT16
maxContours
;
HBUINT16
maxCompositePoints
;
HBUINT16
maxCompositeContours
;
HBUINT16
maxZones
;
HBUINT16
maxTwilightPoints
;
HBUINT16
maxStorage
;
HBUINT16
maxFunctionDefs
;
HBUINT16
maxInstructionDefs
;
HBUINT16
maxStackElements
;
HBUINT16
maxSizeOfInstructions
;
HBUINT16
maxComponentElements
;
HBUINT16
maxComponentDepth
;
public
:
DEFINE_SIZE_STATIC
(
26
)
;
}
;
struct
maxp
{
static
constexpr
hb_tag_t
tableTag
=
HB_OT_TAG_maxp
;
unsigned
int
get_num_glyphs
(
)
const
{
return
numGlyphs
;
}
void
set_num_glyphs
(
unsigned
int
count
)
{
numGlyphs
.
set
(
count
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
c
-
>
check_struct
(
this
)
)
)
return_trace
(
false
)
;
if
(
version
.
major
=
=
1
)
{
const
maxpV1Tail
&
v1
=
StructAfter
<
maxpV1Tail
>
(
*
this
)
;
return_trace
(
v1
.
sanitize
(
c
)
)
;
}
return_trace
(
likely
(
version
.
major
=
=
0
&
&
version
.
minor
=
=
0x5000u
)
)
;
}
bool
subset
(
hb_subset_plan_t
*
plan
)
const
{
hb_blob_t
*
maxp_blob
=
hb_sanitize_context_t
(
)
.
reference_table
<
maxp
>
(
plan
-
>
source
)
;
hb_blob_t
*
maxp_prime_blob
=
hb_blob_copy_writable_or_fail
(
maxp_blob
)
;
hb_blob_destroy
(
maxp_blob
)
;
if
(
unlikely
(
!
maxp_prime_blob
)
)
{
return
false
;
}
maxp
*
maxp_prime
=
(
maxp
*
)
hb_blob_get_data
(
maxp_prime_blob
nullptr
)
;
maxp_prime
-
>
set_num_glyphs
(
plan
-
>
glyphs
.
length
)
;
if
(
plan
-
>
drop_hints
)
drop_hint_fields
(
plan
maxp_prime
)
;
bool
result
=
plan
-
>
add_table
(
HB_OT_TAG_maxp
maxp_prime_blob
)
;
hb_blob_destroy
(
maxp_prime_blob
)
;
return
result
;
}
static
void
drop_hint_fields
(
hb_subset_plan_t
*
plan
HB_UNUSED
maxp
*
maxp_prime
)
{
if
(
maxp_prime
-
>
version
.
major
=
=
1
)
{
maxpV1Tail
&
v1
=
StructAfter
<
maxpV1Tail
>
(
*
maxp_prime
)
;
v1
.
maxZones
.
set
(
1
)
;
v1
.
maxTwilightPoints
.
set
(
0
)
;
v1
.
maxStorage
.
set
(
0
)
;
v1
.
maxFunctionDefs
.
set
(
0
)
;
v1
.
maxInstructionDefs
.
set
(
0
)
;
v1
.
maxStackElements
.
set
(
0
)
;
v1
.
maxSizeOfInstructions
.
set
(
0
)
;
}
}
protected
:
FixedVersion
<
>
version
;
HBUINT16
numGlyphs
;
public
:
DEFINE_SIZE_STATIC
(
6
)
;
}
;
}
#
endif
