#
include
"
hb
.
hh
"
#
include
"
hb
-
shaper
.
hh
"
#
include
"
hb
-
shape
-
plan
.
hh
"
#
include
"
hb
-
buffer
.
hh
"
#
include
"
hb
-
font
.
hh
"
#
include
"
hb
-
machinery
.
hh
"
#
ifndef
HB_NO_SHAPER
static
inline
void
free_static_shaper_list
(
)
;
static
const
char
*
const
nil_shaper_list
[
]
=
{
nullptr
}
;
static
struct
hb_shaper_list_lazy_loader_t
:
hb_lazy_loader_t
<
const
char
*
hb_shaper_list_lazy_loader_t
>
{
static
const
char
*
*
create
(
)
{
const
char
*
*
shaper_list
=
(
const
char
*
*
)
hb_calloc
(
1
+
HB_SHAPERS_COUNT
sizeof
(
const
char
*
)
)
;
if
(
unlikely
(
!
shaper_list
)
)
return
nullptr
;
const
hb_shaper_entry_t
*
shapers
=
_hb_shapers_get
(
)
;
unsigned
int
i
;
for
(
i
=
0
;
i
<
HB_SHAPERS_COUNT
;
i
+
+
)
shaper_list
[
i
]
=
shapers
[
i
]
.
name
;
shaper_list
[
i
]
=
nullptr
;
hb_atexit
(
free_static_shaper_list
)
;
return
shaper_list
;
}
static
void
destroy
(
const
char
*
*
l
)
{
hb_free
(
l
)
;
}
static
const
char
*
const
*
get_null
(
)
{
return
nil_shaper_list
;
}
}
static_shaper_list
;
static
inline
void
free_static_shaper_list
(
)
{
static_shaper_list
.
free_instance
(
)
;
}
const
char
*
*
hb_shape_list_shapers
(
)
{
return
static_shaper_list
.
get_unconst
(
)
;
}
hb_bool_t
hb_shape_full
(
hb_font_t
*
font
hb_buffer_t
*
buffer
const
hb_feature_t
*
features
unsigned
int
num_features
const
char
*
const
*
shaper_list
)
{
if
(
unlikely
(
!
buffer
-
>
len
)
)
return
true
;
buffer
-
>
enter
(
)
;
hb_buffer_t
*
text_buffer
=
nullptr
;
if
(
buffer
-
>
flags
&
HB_BUFFER_FLAG_VERIFY
)
{
text_buffer
=
hb_buffer_create
(
)
;
hb_buffer_append
(
text_buffer
buffer
0
-
1
)
;
}
hb_shape_plan_t
*
shape_plan
=
hb_shape_plan_create_cached2
(
font
-
>
face
&
buffer
-
>
props
features
num_features
font
-
>
coords
font
-
>
num_coords
shaper_list
)
;
hb_bool_t
res
=
hb_shape_plan_execute
(
shape_plan
font
buffer
features
num_features
)
;
if
(
buffer
-
>
max_ops
<
=
0
)
buffer
-
>
shaping_failed
=
true
;
hb_shape_plan_destroy
(
shape_plan
)
;
if
(
text_buffer
)
{
if
(
res
&
&
buffer
-
>
successful
&
&
!
buffer
-
>
shaping_failed
&
&
text_buffer
-
>
successful
&
&
!
buffer
-
>
verify
(
text_buffer
font
features
num_features
shaper_list
)
)
res
=
false
;
hb_buffer_destroy
(
text_buffer
)
;
}
buffer
-
>
leave
(
)
;
return
res
;
}
void
hb_shape
(
hb_font_t
*
font
hb_buffer_t
*
buffer
const
hb_feature_t
*
features
unsigned
int
num_features
)
{
hb_shape_full
(
font
buffer
features
num_features
nullptr
)
;
}
#
ifdef
HB_EXPERIMENTAL_API
static
float
buffer_advance
(
hb_buffer_t
*
buffer
)
{
float
a
=
0
;
auto
*
pos
=
buffer
-
>
pos
;
unsigned
count
=
buffer
-
>
len
;
if
(
HB_DIRECTION_IS_HORIZONTAL
(
buffer
-
>
props
.
direction
)
)
for
(
unsigned
i
=
0
;
i
<
count
;
i
+
+
)
a
+
=
pos
[
i
]
.
x_advance
;
else
for
(
unsigned
i
=
0
;
i
<
count
;
i
+
+
)
a
+
=
pos
[
i
]
.
y_advance
;
return
a
;
}
static
void
reset_buffer
(
hb_buffer_t
*
buffer
hb_array_t
<
const
hb_glyph_info_t
>
text
)
{
assert
(
buffer
-
>
ensure
(
text
.
length
)
)
;
buffer
-
>
have_positions
=
false
;
buffer
-
>
len
=
text
.
length
;
memcpy
(
buffer
-
>
info
text
.
arrayZ
text
.
length
*
sizeof
(
buffer
-
>
info
[
0
]
)
)
;
hb_buffer_set_content_type
(
buffer
HB_BUFFER_CONTENT_TYPE_UNICODE
)
;
}
hb_bool_t
hb_shape_justify
(
hb_font_t
*
font
hb_buffer_t
*
buffer
const
hb_feature_t
*
features
unsigned
int
num_features
const
char
*
const
*
shaper_list
float
min_target_advance
float
max_target_advance
float
*
advance
hb_tag_t
*
var_tag
float
*
var_value
)
{
if
(
min_target_advance
<
=
*
advance
&
&
*
advance
<
=
max_target_advance
)
return
hb_shape_full
(
font
buffer
features
num_features
shaper_list
)
;
hb_face_t
*
face
=
font
-
>
face
;
hb_tag_t
tag
=
HB_TAG_NONE
;
hb_ot_var_axis_info_t
axis_info
;
hb_tag_t
tags
[
]
=
{
HB_TAG
(
'
j
'
'
s
'
'
t
'
'
f
'
)
HB_TAG
(
'
w
'
'
d
'
'
t
'
'
h
'
)
}
;
for
(
unsigned
i
=
0
;
i
<
ARRAY_LENGTH
(
tags
)
;
i
+
+
)
if
(
hb_ot_var_find_axis_info
(
face
tags
[
i
]
&
axis_info
)
)
{
tag
=
*
var_tag
=
tags
[
i
]
;
break
;
}
if
(
!
tag
)
{
if
(
hb_shape_full
(
font
buffer
features
num_features
shaper_list
)
)
{
*
advance
=
buffer_advance
(
buffer
)
;
return
true
;
}
else
return
false
;
}
unsigned
text_len
=
buffer
-
>
len
;
auto
*
text_info
=
(
hb_glyph_info_t
*
)
hb_malloc
(
text_len
*
sizeof
(
buffer
-
>
info
[
0
]
)
)
;
if
(
unlikely
(
text_len
&
&
!
text_info
)
)
return
false
;
hb_memcpy
(
text_info
buffer
-
>
info
text_len
*
sizeof
(
buffer
-
>
info
[
0
]
)
)
;
auto
text
=
hb_array
<
const
hb_glyph_info_t
>
(
text_info
text_len
)
;
if
(
!
*
advance
)
{
hb_font_set_variation
(
font
tag
axis_info
.
default_value
)
;
if
(
!
hb_shape_full
(
font
buffer
features
num_features
shaper_list
)
)
return
false
;
*
advance
=
buffer_advance
(
buffer
)
;
}
if
(
min_target_advance
<
=
*
advance
&
&
*
advance
<
=
max_target_advance
)
return
true
;
double
a
b
ya
yb
;
if
(
*
advance
<
min_target_advance
)
{
ya
=
(
double
)
*
advance
;
a
=
(
double
)
axis_info
.
default_value
;
b
=
(
double
)
axis_info
.
max_value
;
hb_font_set_variation
(
font
tag
(
float
)
b
)
;
reset_buffer
(
buffer
text
)
;
if
(
!
hb_shape_full
(
font
buffer
features
num_features
shaper_list
)
)
return
false
;
yb
=
(
double
)
buffer_advance
(
buffer
)
;
if
(
yb
<
=
(
double
)
max_target_advance
)
{
*
advance
=
(
float
)
yb
;
return
true
;
}
}
else
{
yb
=
(
double
)
*
advance
;
a
=
(
double
)
axis_info
.
min_value
;
b
=
(
double
)
axis_info
.
default_value
;
hb_font_set_variation
(
font
tag
(
float
)
a
)
;
reset_buffer
(
buffer
text
)
;
if
(
!
hb_shape_full
(
font
buffer
features
num_features
shaper_list
)
)
return
false
;
ya
=
(
double
)
buffer_advance
(
buffer
)
;
if
(
ya
>
=
(
double
)
min_target_advance
)
{
*
advance
=
(
float
)
ya
;
return
true
;
}
}
double
epsilon
=
(
b
-
a
)
/
(
1
<
<
14
)
;
bool
failed
=
false
;
auto
f
=
[
&
]
(
double
x
)
{
hb_font_set_variation
(
font
tag
(
float
)
x
)
;
reset_buffer
(
buffer
text
)
;
if
(
unlikely
(
!
hb_shape_full
(
font
buffer
features
num_features
shaper_list
)
)
)
{
failed
=
true
;
return
(
double
)
min_target_advance
;
}
double
w
=
(
double
)
buffer_advance
(
buffer
)
;
DEBUG_MSG
(
JUSTIFY
nullptr
"
Trying
'
%
c
%
c
%
c
%
c
'
axis
parameter
%
f
.
Advance
%
g
.
Target
:
min
%
g
max
%
g
"
HB_UNTAG
(
tag
)
x
w
(
double
)
min_target_advance
(
double
)
max_target_advance
)
;
return
w
;
}
;
double
y
=
0
;
double
itp
=
solve_itp
(
f
a
b
epsilon
(
double
)
min_target_advance
(
double
)
max_target_advance
ya
yb
y
)
;
hb_free
(
text_info
)
;
if
(
failed
)
return
false
;
*
var_value
=
(
float
)
itp
;
*
advance
=
(
float
)
y
;
return
true
;
}
#
endif
#
endif
