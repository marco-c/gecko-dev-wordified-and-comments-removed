#
include
"
hb
.
hh
"
static
hb_tag_t
hb_ot_old_tag_from_script
(
hb_script_t
script
)
{
switch
(
(
hb_tag_t
)
script
)
{
case
HB_SCRIPT_INVALID
:
return
HB_OT_TAG_DEFAULT_SCRIPT
;
case
HB_SCRIPT_HIRAGANA
:
return
HB_TAG
(
'
k
'
'
a
'
'
n
'
'
a
'
)
;
case
HB_SCRIPT_LAO
:
return
HB_TAG
(
'
l
'
'
a
'
'
o
'
'
'
)
;
case
HB_SCRIPT_YI
:
return
HB_TAG
(
'
y
'
'
i
'
'
'
'
'
)
;
case
HB_SCRIPT_NKO
:
return
HB_TAG
(
'
n
'
'
k
'
'
o
'
'
'
)
;
case
HB_SCRIPT_VAI
:
return
HB_TAG
(
'
v
'
'
a
'
'
i
'
'
'
)
;
}
return
(
(
hb_tag_t
)
script
)
|
0x20000000u
;
}
static
hb_script_t
hb_ot_old_tag_to_script
(
hb_tag_t
tag
)
{
if
(
unlikely
(
tag
=
=
HB_OT_TAG_DEFAULT_SCRIPT
)
)
return
HB_SCRIPT_INVALID
;
if
(
unlikely
(
(
tag
&
0x0000FF00u
)
=
=
0x00002000u
)
)
tag
|
=
(
tag
>
>
8
)
&
0x0000FF00u
;
if
(
unlikely
(
(
tag
&
0x000000FFu
)
=
=
0x00000020u
)
)
tag
|
=
(
tag
>
>
8
)
&
0x000000FFu
;
return
(
hb_script_t
)
(
tag
&
~
0x20000000u
)
;
}
static
hb_tag_t
hb_ot_new_tag_from_script
(
hb_script_t
script
)
{
switch
(
(
hb_tag_t
)
script
)
{
case
HB_SCRIPT_BENGALI
:
return
HB_TAG
(
'
b
'
'
n
'
'
g
'
'
2
'
)
;
case
HB_SCRIPT_DEVANAGARI
:
return
HB_TAG
(
'
d
'
'
e
'
'
v
'
'
2
'
)
;
case
HB_SCRIPT_GUJARATI
:
return
HB_TAG
(
'
g
'
'
j
'
'
r
'
'
2
'
)
;
case
HB_SCRIPT_GURMUKHI
:
return
HB_TAG
(
'
g
'
'
u
'
'
r
'
'
2
'
)
;
case
HB_SCRIPT_KANNADA
:
return
HB_TAG
(
'
k
'
'
n
'
'
d
'
'
2
'
)
;
case
HB_SCRIPT_MALAYALAM
:
return
HB_TAG
(
'
m
'
'
l
'
'
m
'
'
2
'
)
;
case
HB_SCRIPT_ORIYA
:
return
HB_TAG
(
'
o
'
'
r
'
'
y
'
'
2
'
)
;
case
HB_SCRIPT_TAMIL
:
return
HB_TAG
(
'
t
'
'
m
'
'
l
'
'
2
'
)
;
case
HB_SCRIPT_TELUGU
:
return
HB_TAG
(
'
t
'
'
e
'
'
l
'
'
2
'
)
;
case
HB_SCRIPT_MYANMAR
:
return
HB_TAG
(
'
m
'
'
y
'
'
m
'
'
2
'
)
;
}
return
HB_OT_TAG_DEFAULT_SCRIPT
;
}
static
hb_script_t
hb_ot_new_tag_to_script
(
hb_tag_t
tag
)
{
switch
(
tag
)
{
case
HB_TAG
(
'
b
'
'
n
'
'
g
'
'
2
'
)
:
return
HB_SCRIPT_BENGALI
;
case
HB_TAG
(
'
d
'
'
e
'
'
v
'
'
2
'
)
:
return
HB_SCRIPT_DEVANAGARI
;
case
HB_TAG
(
'
g
'
'
j
'
'
r
'
'
2
'
)
:
return
HB_SCRIPT_GUJARATI
;
case
HB_TAG
(
'
g
'
'
u
'
'
r
'
'
2
'
)
:
return
HB_SCRIPT_GURMUKHI
;
case
HB_TAG
(
'
k
'
'
n
'
'
d
'
'
2
'
)
:
return
HB_SCRIPT_KANNADA
;
case
HB_TAG
(
'
m
'
'
l
'
'
m
'
'
2
'
)
:
return
HB_SCRIPT_MALAYALAM
;
case
HB_TAG
(
'
o
'
'
r
'
'
y
'
'
2
'
)
:
return
HB_SCRIPT_ORIYA
;
case
HB_TAG
(
'
t
'
'
m
'
'
l
'
'
2
'
)
:
return
HB_SCRIPT_TAMIL
;
case
HB_TAG
(
'
t
'
'
e
'
'
l
'
'
2
'
)
:
return
HB_SCRIPT_TELUGU
;
case
HB_TAG
(
'
m
'
'
y
'
'
m
'
'
2
'
)
:
return
HB_SCRIPT_MYANMAR
;
}
return
HB_SCRIPT_UNKNOWN
;
}
void
hb_ot_tags_from_script
(
hb_script_t
script
hb_tag_t
*
script_tag_1
hb_tag_t
*
script_tag_2
)
{
unsigned
int
count
=
2
;
hb_tag_t
tags
[
2
]
;
hb_ot_tags_from_script_and_language
(
script
HB_LANGUAGE_INVALID
&
count
tags
nullptr
nullptr
)
;
*
script_tag_1
=
count
>
0
?
tags
[
0
]
:
HB_OT_TAG_DEFAULT_SCRIPT
;
*
script_tag_2
=
count
>
1
?
tags
[
1
]
:
HB_OT_TAG_DEFAULT_SCRIPT
;
}
static
void
hb_ot_all_tags_from_script
(
hb_script_t
script
unsigned
int
*
count
hb_tag_t
*
tags
)
{
unsigned
int
i
=
0
;
hb_tag_t
new_tag
=
hb_ot_new_tag_from_script
(
script
)
;
if
(
unlikely
(
new_tag
!
=
HB_OT_TAG_DEFAULT_SCRIPT
)
)
{
tags
[
i
+
+
]
=
new_tag
|
'
3
'
;
if
(
*
count
>
i
)
tags
[
i
+
+
]
=
new_tag
;
}
if
(
*
count
>
i
)
{
hb_tag_t
old_tag
=
hb_ot_old_tag_from_script
(
script
)
;
if
(
old_tag
!
=
HB_OT_TAG_DEFAULT_SCRIPT
)
tags
[
i
+
+
]
=
old_tag
;
}
*
count
=
i
;
}
hb_script_t
hb_ot_tag_to_script
(
hb_tag_t
tag
)
{
unsigned
char
digit
=
tag
&
0x000000FFu
;
if
(
unlikely
(
digit
=
=
'
2
'
|
|
digit
=
=
'
3
'
)
)
return
hb_ot_new_tag_to_script
(
tag
&
0xFFFFFF32
)
;
return
hb_ot_old_tag_to_script
(
tag
)
;
}
static
bool
subtag_matches
(
const
char
*
lang_str
const
char
*
limit
const
char
*
subtag
)
{
do
{
const
char
*
s
=
strstr
(
lang_str
subtag
)
;
if
(
!
s
|
|
s
>
=
limit
)
return
false
;
if
(
!
ISALNUM
(
s
[
strlen
(
subtag
)
]
)
)
return
true
;
lang_str
=
s
+
strlen
(
subtag
)
;
}
while
(
true
)
;
}
static
hb_bool_t
lang_matches
(
const
char
*
lang_str
const
char
*
spec
)
{
unsigned
int
len
=
strlen
(
spec
)
;
return
strncmp
(
lang_str
spec
len
)
=
=
0
&
&
(
lang_str
[
len
]
=
=
'
\
0
'
|
|
lang_str
[
len
]
=
=
'
-
'
)
;
}
struct
LangTag
{
char
language
[
4
]
;
hb_tag_t
tags
[
HB_OT_MAX_TAGS_PER_LANGUAGE
]
;
int
cmp
(
const
char
*
a
)
const
{
const
char
*
b
=
this
-
>
language
;
unsigned
int
da
db
;
const
char
*
p
;
p
=
strchr
(
a
'
-
'
)
;
da
=
p
?
(
unsigned
int
)
(
p
-
a
)
:
strlen
(
a
)
;
p
=
strchr
(
b
'
-
'
)
;
db
=
p
?
(
unsigned
int
)
(
p
-
b
)
:
strlen
(
b
)
;
return
strncmp
(
a
b
MAX
(
da
db
)
)
;
}
int
cmp
(
const
LangTag
*
that
)
const
{
return
cmp
(
that
-
>
language
)
;
}
}
;
#
include
"
hb
-
ot
-
tag
-
table
.
hh
"
hb_tag_t
hb_ot_tag_from_language
(
hb_language_t
language
)
{
unsigned
int
count
=
1
;
hb_tag_t
tags
[
1
]
;
hb_ot_tags_from_script_and_language
(
HB_SCRIPT_UNKNOWN
language
nullptr
nullptr
&
count
tags
)
;
return
count
>
0
?
tags
[
0
]
:
HB_OT_TAG_DEFAULT_LANGUAGE
;
}
static
void
hb_ot_tags_from_language
(
const
char
*
lang_str
const
char
*
limit
unsigned
int
*
count
hb_tag_t
*
tags
)
{
const
char
*
s
;
if
(
hb_ot_tags_from_complex_language
(
lang_str
limit
count
tags
)
)
return
;
s
=
strchr
(
lang_str
'
-
'
)
;
{
const
LangTag
*
lang_tag
;
if
(
s
&
&
limit
-
lang_str
>
=
6
)
{
const
char
*
extlang_end
=
strchr
(
s
+
1
'
-
'
)
;
if
(
3
=
=
(
extlang_end
?
extlang_end
-
s
-
1
:
strlen
(
s
+
1
)
)
&
&
ISALPHA
(
s
[
1
]
)
)
lang_str
=
s
+
1
;
}
lang_tag
=
hb_sorted_array
(
ot_languages
)
.
bsearch
(
lang_str
)
;
if
(
lang_tag
)
{
unsigned
int
i
;
for
(
i
=
0
;
i
<
*
count
&
&
lang_tag
-
>
tags
[
i
]
!
=
HB_TAG_NONE
;
i
+
+
)
tags
[
i
]
=
lang_tag
-
>
tags
[
i
]
;
*
count
=
i
;
return
;
}
}
if
(
!
s
)
s
=
lang_str
+
strlen
(
lang_str
)
;
if
(
s
-
lang_str
=
=
3
)
{
tags
[
0
]
=
hb_tag_from_string
(
lang_str
s
-
lang_str
)
&
~
0x20202000u
;
*
count
=
1
;
return
;
}
*
count
=
0
;
}
static
bool
parse_private_use_subtag
(
const
char
*
private_use_subtag
unsigned
int
*
count
hb_tag_t
*
tags
const
char
*
prefix
unsigned
char
(
*
normalize
)
(
unsigned
char
)
)
{
if
(
private_use_subtag
&
&
count
&
&
tags
&
&
*
count
)
{
const
char
*
s
=
strstr
(
private_use_subtag
prefix
)
;
if
(
s
)
{
char
tag
[
4
]
;
int
i
;
s
+
=
strlen
(
prefix
)
;
for
(
i
=
0
;
i
<
4
&
&
ISALNUM
(
s
[
i
]
)
;
i
+
+
)
tag
[
i
]
=
normalize
(
s
[
i
]
)
;
if
(
i
)
{
for
(
;
i
<
4
;
i
+
+
)
tag
[
i
]
=
'
'
;
tags
[
0
]
=
HB_TAG
(
tag
[
0
]
tag
[
1
]
tag
[
2
]
tag
[
3
]
)
;
if
(
(
tags
[
0
]
&
0xDFDFDFDF
)
=
=
HB_OT_TAG_DEFAULT_SCRIPT
)
tags
[
0
]
^
=
~
0xDFDFDFDF
;
*
count
=
1
;
return
false
;
}
}
}
return
true
;
}
void
hb_ot_tags_from_script_and_language
(
hb_script_t
script
hb_language_t
language
unsigned
int
*
script_count
hb_tag_t
*
script_tags
unsigned
int
*
language_count
hb_tag_t
*
language_tags
)
{
bool
needs_script
=
true
;
if
(
language
=
=
HB_LANGUAGE_INVALID
)
{
if
(
language_count
&
&
language_tags
&
&
*
language_count
)
*
language_count
=
0
;
}
else
{
const
char
*
lang_str
*
s
*
limit
*
private_use_subtag
;
bool
needs_language
;
lang_str
=
hb_language_to_string
(
language
)
;
limit
=
nullptr
;
private_use_subtag
=
nullptr
;
if
(
lang_str
[
0
]
=
=
'
x
'
&
&
lang_str
[
1
]
=
=
'
-
'
)
{
private_use_subtag
=
lang_str
;
}
else
{
for
(
s
=
lang_str
+
1
;
*
s
;
s
+
+
)
{
if
(
s
[
-
1
]
=
=
'
-
'
&
&
s
[
1
]
=
=
'
-
'
)
{
if
(
s
[
0
]
=
=
'
x
'
)
{
private_use_subtag
=
s
;
if
(
!
limit
)
limit
=
s
-
1
;
break
;
}
else
if
(
!
limit
)
{
limit
=
s
-
1
;
}
}
}
if
(
!
limit
)
limit
=
s
;
}
needs_script
=
parse_private_use_subtag
(
private_use_subtag
script_count
script_tags
"
-
hbsc
"
TOLOWER
)
;
needs_language
=
parse_private_use_subtag
(
private_use_subtag
language_count
language_tags
"
-
hbot
"
TOUPPER
)
;
if
(
needs_language
&
&
language_count
&
&
language_tags
&
&
*
language_count
)
hb_ot_tags_from_language
(
lang_str
limit
language_count
language_tags
)
;
}
if
(
needs_script
&
&
script_count
&
&
script_tags
&
&
*
script_count
)
hb_ot_all_tags_from_script
(
script
script_count
script_tags
)
;
}
hb_language_t
hb_ot_tag_to_language
(
hb_tag_t
tag
)
{
unsigned
int
i
;
if
(
tag
=
=
HB_OT_TAG_DEFAULT_LANGUAGE
)
return
nullptr
;
{
hb_language_t
disambiguated_tag
=
hb_ot_ambiguous_tag_to_language
(
tag
)
;
if
(
disambiguated_tag
!
=
HB_LANGUAGE_INVALID
)
return
disambiguated_tag
;
}
for
(
i
=
0
;
i
<
ARRAY_LENGTH
(
ot_languages
)
;
i
+
+
)
if
(
ot_languages
[
i
]
.
tags
[
0
]
=
=
tag
)
return
hb_language_from_string
(
ot_languages
[
i
]
.
language
-
1
)
;
{
unsigned
char
buf
[
11
]
=
"
x
-
hbot
"
;
buf
[
6
]
=
tag
>
>
24
;
buf
[
7
]
=
(
tag
>
>
16
)
&
0xFF
;
buf
[
8
]
=
(
tag
>
>
8
)
&
0xFF
;
buf
[
9
]
=
tag
&
0xFF
;
if
(
buf
[
9
]
=
=
0x20
)
buf
[
9
]
=
'
\
0
'
;
buf
[
10
]
=
'
\
0
'
;
return
hb_language_from_string
(
(
char
*
)
buf
-
1
)
;
}
}
void
hb_ot_tags_to_script_and_language
(
hb_tag_t
script_tag
hb_tag_t
language_tag
hb_script_t
*
script
hb_language_t
*
language
)
{
hb_script_t
script_out
=
hb_ot_tag_to_script
(
script_tag
)
;
if
(
script
)
*
script
=
script_out
;
if
(
language
)
{
unsigned
int
script_count
=
1
;
hb_tag_t
primary_script_tag
[
1
]
;
hb_ot_tags_from_script_and_language
(
script_out
HB_LANGUAGE_INVALID
&
script_count
primary_script_tag
nullptr
nullptr
)
;
*
language
=
hb_ot_tag_to_language
(
language_tag
)
;
if
(
script_count
=
=
0
|
|
primary_script_tag
[
0
]
!
=
script_tag
)
{
unsigned
char
*
buf
;
const
char
*
lang_str
=
hb_language_to_string
(
*
language
)
;
size_t
len
=
strlen
(
lang_str
)
;
buf
=
(
unsigned
char
*
)
malloc
(
len
+
11
)
;
if
(
unlikely
(
!
buf
)
)
{
*
language
=
nullptr
;
}
else
{
memcpy
(
buf
lang_str
len
)
;
if
(
lang_str
[
0
]
!
=
'
x
'
|
|
lang_str
[
1
]
!
=
'
-
'
)
{
buf
[
len
+
+
]
=
'
-
'
;
buf
[
len
+
+
]
=
'
x
'
;
}
buf
[
len
+
+
]
=
'
-
'
;
buf
[
len
+
+
]
=
'
h
'
;
buf
[
len
+
+
]
=
'
b
'
;
buf
[
len
+
+
]
=
'
s
'
;
buf
[
len
+
+
]
=
'
c
'
;
buf
[
len
+
+
]
=
script_tag
>
>
24
;
buf
[
len
+
+
]
=
(
script_tag
>
>
16
)
&
0xFF
;
buf
[
len
+
+
]
=
(
script_tag
>
>
8
)
&
0xFF
;
buf
[
len
+
+
]
=
script_tag
&
0xFF
;
*
language
=
hb_language_from_string
(
(
char
*
)
buf
len
)
;
free
(
buf
)
;
}
}
}
}
#
ifdef
MAIN
static
inline
void
test_langs_sorted
(
)
{
for
(
unsigned
int
i
=
1
;
i
<
ARRAY_LENGTH
(
ot_languages
)
;
i
+
+
)
{
int
c
=
ot_languages
[
i
]
.
cmp
(
&
ot_languages
[
i
-
1
]
)
;
if
(
c
>
=
0
)
{
fprintf
(
stderr
"
ot_languages
not
sorted
at
index
%
d
:
%
s
%
d
%
s
\
n
"
i
ot_languages
[
i
-
1
]
.
language
c
ot_languages
[
i
]
.
language
)
;
abort
(
)
;
}
}
}
int
main
(
)
{
test_langs_sorted
(
)
;
return
0
;
}
#
endif
