#
ifndef
HB_OPEN_FILE_PRIVATE_HH
#
define
HB_OPEN_FILE_PRIVATE_HH
#
include
"
hb
-
open
-
type
-
private
.
hh
"
namespace
OT
{
struct
OpenTypeFontFile
;
struct
OffsetTable
;
struct
TTCHeader
;
typedef
struct
TableRecord
{
int
cmp
(
Tag
t
)
const
{
return
t
.
cmp
(
tag
)
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
Tag
tag
;
CheckSum
checkSum
;
UINT32
offset
;
UINT32
length
;
public
:
DEFINE_SIZE_STATIC
(
16
)
;
}
OpenTypeTable
;
typedef
struct
OffsetTable
{
friend
struct
OpenTypeFontFile
;
inline
unsigned
int
get_table_count
(
void
)
const
{
return
tables
.
len
;
}
inline
const
TableRecord
&
get_table
(
unsigned
int
i
)
const
{
return
tables
[
i
]
;
}
inline
unsigned
int
get_table_tags
(
unsigned
int
start_offset
unsigned
int
*
table_count
hb_tag_t
*
table_tags
)
const
{
if
(
table_count
)
{
if
(
start_offset
>
=
tables
.
len
)
*
table_count
=
0
;
else
*
table_count
=
MIN
<
unsigned
int
>
(
*
table_count
tables
.
len
-
start_offset
)
;
const
TableRecord
*
sub_tables
=
tables
.
array
+
start_offset
;
unsigned
int
count
=
*
table_count
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
table_tags
[
i
]
=
sub_tables
[
i
]
.
tag
;
}
return
tables
.
len
;
}
inline
bool
find_table_index
(
hb_tag_t
tag
unsigned
int
*
table_index
)
const
{
Tag
t
;
t
.
set
(
tag
)
;
int
i
=
tables
.
len
<
64
?
tables
.
lsearch
(
t
)
:
tables
.
bsearch
(
t
)
;
if
(
table_index
)
*
table_index
=
i
=
=
-
1
?
Index
:
:
NOT_FOUND_INDEX
:
(
unsigned
int
)
i
;
return
i
!
=
-
1
;
}
inline
const
TableRecord
&
get_table_by_tag
(
hb_tag_t
tag
)
const
{
unsigned
int
table_index
;
find_table_index
(
tag
&
table_index
)
;
return
get_table
(
table_index
)
;
}
public
:
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
tables
.
sanitize
(
c
)
)
;
}
protected
:
Tag
sfnt_version
;
BinSearchArrayOf
<
TableRecord
>
tables
;
public
:
DEFINE_SIZE_ARRAY
(
12
tables
)
;
}
OpenTypeFontFace
;
struct
TTCHeaderVersion1
{
friend
struct
TTCHeader
;
inline
unsigned
int
get_face_count
(
void
)
const
{
return
table
.
len
;
}
inline
const
OpenTypeFontFace
&
get_face
(
unsigned
int
i
)
const
{
return
this
+
table
[
i
]
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
table
.
sanitize
(
c
this
)
)
;
}
protected
:
Tag
ttcTag
;
FixedVersion
<
>
version
;
ArrayOf
<
LOffsetTo
<
OffsetTable
>
UINT32
>
table
;
public
:
DEFINE_SIZE_ARRAY
(
12
table
)
;
}
;
struct
TTCHeader
{
friend
struct
OpenTypeFontFile
;
private
:
inline
unsigned
int
get_face_count
(
void
)
const
{
switch
(
u
.
header
.
version
.
major
)
{
case
2
:
case
1
:
return
u
.
version1
.
get_face_count
(
)
;
default
:
return
0
;
}
}
inline
const
OpenTypeFontFace
&
get_face
(
unsigned
int
i
)
const
{
switch
(
u
.
header
.
version
.
major
)
{
case
2
:
case
1
:
return
u
.
version1
.
get_face
(
i
)
;
default
:
return
Null
(
OpenTypeFontFace
)
;
}
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
u
.
header
.
version
.
sanitize
(
c
)
)
)
return_trace
(
false
)
;
switch
(
u
.
header
.
version
.
major
)
{
case
2
:
case
1
:
return_trace
(
u
.
version1
.
sanitize
(
c
)
)
;
default
:
return_trace
(
true
)
;
}
}
protected
:
union
{
struct
{
Tag
ttcTag
;
FixedVersion
<
>
version
;
}
header
;
TTCHeaderVersion1
version1
;
}
u
;
}
;
struct
OpenTypeFontFile
{
static
const
hb_tag_t
tableTag
=
HB_TAG
(
'
_
'
'
_
'
'
_
'
'
_
'
)
;
static
const
hb_tag_t
CFFTag
=
HB_TAG
(
'
O
'
'
T
'
'
T
'
'
O
'
)
;
static
const
hb_tag_t
TrueTypeTag
=
HB_TAG
(
0
1
0
0
)
;
static
const
hb_tag_t
TTCTag
=
HB_TAG
(
'
t
'
'
t
'
'
c
'
'
f
'
)
;
static
const
hb_tag_t
TrueTag
=
HB_TAG
(
'
t
'
'
r
'
'
u
'
'
e
'
)
;
static
const
hb_tag_t
Typ1Tag
=
HB_TAG
(
'
t
'
'
y
'
'
p
'
'
1
'
)
;
inline
hb_tag_t
get_tag
(
void
)
const
{
return
u
.
tag
;
}
inline
unsigned
int
get_face_count
(
void
)
const
{
switch
(
u
.
tag
)
{
case
CFFTag
:
case
TrueTag
:
case
Typ1Tag
:
case
TrueTypeTag
:
return
1
;
case
TTCTag
:
return
u
.
ttcHeader
.
get_face_count
(
)
;
default
:
return
0
;
}
}
inline
const
OpenTypeFontFace
&
get_face
(
unsigned
int
i
)
const
{
switch
(
u
.
tag
)
{
case
CFFTag
:
case
TrueTag
:
case
Typ1Tag
:
case
TrueTypeTag
:
return
u
.
fontFace
;
case
TTCTag
:
return
u
.
ttcHeader
.
get_face
(
i
)
;
default
:
return
Null
(
OpenTypeFontFace
)
;
}
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
u
.
tag
.
sanitize
(
c
)
)
)
return_trace
(
false
)
;
switch
(
u
.
tag
)
{
case
CFFTag
:
case
TrueTag
:
case
Typ1Tag
:
case
TrueTypeTag
:
return_trace
(
u
.
fontFace
.
sanitize
(
c
)
)
;
case
TTCTag
:
return_trace
(
u
.
ttcHeader
.
sanitize
(
c
)
)
;
default
:
return_trace
(
true
)
;
}
}
protected
:
union
{
Tag
tag
;
OpenTypeFontFace
fontFace
;
TTCHeader
ttcHeader
;
}
u
;
public
:
DEFINE_SIZE_UNION
(
4
tag
)
;
}
;
}
#
endif
