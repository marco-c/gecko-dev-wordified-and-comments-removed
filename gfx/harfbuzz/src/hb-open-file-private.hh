#
ifndef
HB_OPEN_FILE_PRIVATE_HH
#
define
HB_OPEN_FILE_PRIVATE_HH
#
include
"
hb
-
open
-
type
-
private
.
hh
"
#
include
"
hb
-
ot
-
head
-
table
.
hh
"
namespace
OT
{
struct
OpenTypeFontFile
;
struct
OffsetTable
;
struct
TTCHeader
;
typedef
struct
TableRecord
{
int
cmp
(
Tag
t
)
const
{
return
-
t
.
cmp
(
tag
)
;
}
static
int
cmp
(
const
void
*
pa
const
void
*
pb
)
{
const
TableRecord
*
a
=
(
const
TableRecord
*
)
pa
;
const
TableRecord
*
b
=
(
const
TableRecord
*
)
pb
;
return
b
-
>
cmp
(
a
-
>
tag
)
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
Tag
tag
;
CheckSum
checkSum
;
Offset32
offset
;
HBUINT32
length
;
public
:
DEFINE_SIZE_STATIC
(
16
)
;
}
OpenTypeTable
;
typedef
struct
OffsetTable
{
friend
struct
OpenTypeFontFile
;
inline
unsigned
int
get_table_count
(
void
)
const
{
return
tables
.
len
;
}
inline
const
TableRecord
&
get_table
(
unsigned
int
i
)
const
{
return
tables
[
i
]
;
}
inline
unsigned
int
get_table_tags
(
unsigned
int
start_offset
unsigned
int
*
table_count
hb_tag_t
*
table_tags
)
const
{
if
(
table_count
)
{
if
(
start_offset
>
=
tables
.
len
)
*
table_count
=
0
;
else
*
table_count
=
MIN
<
unsigned
int
>
(
*
table_count
tables
.
len
-
start_offset
)
;
const
TableRecord
*
sub_tables
=
tables
.
arrayZ
+
start_offset
;
unsigned
int
count
=
*
table_count
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
table_tags
[
i
]
=
sub_tables
[
i
]
.
tag
;
}
return
tables
.
len
;
}
inline
bool
find_table_index
(
hb_tag_t
tag
unsigned
int
*
table_index
)
const
{
Tag
t
;
t
.
set
(
tag
)
;
int
i
=
tables
.
len
<
64
?
tables
.
lsearch
(
t
)
:
tables
.
bsearch
(
t
)
;
if
(
table_index
)
*
table_index
=
i
=
=
-
1
?
Index
:
:
NOT_FOUND_INDEX
:
(
unsigned
int
)
i
;
return
i
!
=
-
1
;
}
inline
const
TableRecord
&
get_table_by_tag
(
hb_tag_t
tag
)
const
{
unsigned
int
table_index
;
find_table_index
(
tag
&
table_index
)
;
return
get_table
(
table_index
)
;
}
public
:
inline
bool
serialize
(
hb_serialize_context_t
*
c
hb_tag_t
sfnt_tag
Supplier
<
hb_tag_t
>
&
tags
Supplier
<
hb_blob_t
*
>
&
blobs
unsigned
int
table_count
)
{
TRACE_SERIALIZE
(
this
)
;
if
(
unlikely
(
!
c
-
>
extend_min
(
*
this
)
)
)
return_trace
(
false
)
;
sfnt_version
.
set
(
sfnt_tag
)
;
if
(
unlikely
(
!
tables
.
serialize
(
c
table_count
)
)
)
return_trace
(
false
)
;
const
char
*
dir_end
=
(
const
char
*
)
c
-
>
head
;
HBUINT32
*
checksum_adjustment
=
nullptr
;
for
(
unsigned
int
i
=
0
;
i
<
table_count
;
i
+
+
)
{
TableRecord
&
rec
=
tables
.
arrayZ
[
i
]
;
hb_blob_t
*
blob
=
blobs
[
i
]
;
rec
.
tag
.
set
(
tags
[
i
]
)
;
rec
.
length
.
set
(
hb_blob_get_length
(
blob
)
)
;
rec
.
offset
.
serialize
(
c
this
)
;
char
*
start
=
(
char
*
)
c
-
>
allocate_size
<
void
>
(
rec
.
length
)
;
if
(
unlikely
(
!
start
)
)
{
return
false
;
}
memcpy
(
start
hb_blob_get_data
(
blob
nullptr
)
rec
.
length
)
;
if
(
rec
.
length
%
4
)
c
-
>
allocate_size
<
void
>
(
4
-
rec
.
length
%
4
)
;
const
char
*
end
=
(
const
char
*
)
c
-
>
head
;
if
(
tags
[
i
]
=
=
HB_OT_TAG_head
&
&
end
-
start
>
=
head
:
:
static_size
)
{
head
*
h
=
(
head
*
)
start
;
checksum_adjustment
=
&
h
-
>
checkSumAdjustment
;
checksum_adjustment
-
>
set
(
0
)
;
}
rec
.
checkSum
.
set_for_data
(
start
end
-
start
)
;
}
tags
+
=
table_count
;
blobs
+
=
table_count
;
tables
.
qsort
(
)
;
if
(
checksum_adjustment
)
{
CheckSum
checksum
;
checksum
.
set_for_data
(
this
dir_end
-
(
const
char
*
)
this
)
;
for
(
unsigned
int
i
=
0
;
i
<
table_count
;
i
+
+
)
{
TableRecord
&
rec
=
tables
.
arrayZ
[
i
]
;
checksum
.
set
(
checksum
+
rec
.
checkSum
)
;
}
checksum_adjustment
-
>
set
(
0xB1B0AFBAu
-
checksum
)
;
}
return_trace
(
true
)
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
tables
.
sanitize
(
c
)
)
;
}
protected
:
Tag
sfnt_version
;
BinSearchArrayOf
<
TableRecord
>
tables
;
public
:
DEFINE_SIZE_ARRAY
(
12
tables
)
;
}
OpenTypeFontFace
;
struct
TTCHeaderVersion1
{
friend
struct
TTCHeader
;
inline
unsigned
int
get_face_count
(
void
)
const
{
return
table
.
len
;
}
inline
const
OpenTypeFontFace
&
get_face
(
unsigned
int
i
)
const
{
return
this
+
table
[
i
]
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
table
.
sanitize
(
c
this
)
)
;
}
protected
:
Tag
ttcTag
;
FixedVersion
<
>
version
;
LArrayOf
<
LOffsetTo
<
OffsetTable
>
>
table
;
public
:
DEFINE_SIZE_ARRAY
(
12
table
)
;
}
;
struct
TTCHeader
{
friend
struct
OpenTypeFontFile
;
private
:
inline
unsigned
int
get_face_count
(
void
)
const
{
switch
(
u
.
header
.
version
.
major
)
{
case
2
:
case
1
:
return
u
.
version1
.
get_face_count
(
)
;
default
:
return
0
;
}
}
inline
const
OpenTypeFontFace
&
get_face
(
unsigned
int
i
)
const
{
switch
(
u
.
header
.
version
.
major
)
{
case
2
:
case
1
:
return
u
.
version1
.
get_face
(
i
)
;
default
:
return
Null
(
OpenTypeFontFace
)
;
}
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
u
.
header
.
version
.
sanitize
(
c
)
)
)
return_trace
(
false
)
;
switch
(
u
.
header
.
version
.
major
)
{
case
2
:
case
1
:
return_trace
(
u
.
version1
.
sanitize
(
c
)
)
;
default
:
return_trace
(
true
)
;
}
}
protected
:
union
{
struct
{
Tag
ttcTag
;
FixedVersion
<
>
version
;
}
header
;
TTCHeaderVersion1
version1
;
}
u
;
}
;
struct
ResourceRefItem
{
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
)
)
;
}
HBINT16
id
;
HBINT16
nameOffset
;
HBUINT8
attr
;
HBUINT24
dataOffset
;
HBUINT32
reserved
;
public
:
DEFINE_SIZE_STATIC
(
12
)
;
}
;
struct
ResourceTypeItem
{
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
)
)
;
}
inline
unsigned
int
get_resource_count
(
)
const
{
return
numRes
+
1
;
}
inline
bool
is_sfnt
(
)
const
{
return
type
=
=
HB_TAG
(
'
s
'
'
f
'
'
n
'
'
t
'
)
;
}
inline
const
ResourceRefItem
&
get_ref_item
(
const
void
*
base
unsigned
int
i
)
const
{
return
(
base
+
refList
)
[
i
]
;
}
protected
:
Tag
type
;
HBUINT16
numRes
;
OffsetTo
<
UnsizedArrayOf
<
ResourceRefItem
>
>
refList
;
public
:
DEFINE_SIZE_STATIC
(
8
)
;
}
;
struct
ResourceMap
{
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
c
-
>
check_struct
(
this
)
)
)
return_trace
(
false
)
;
for
(
unsigned
int
i
=
0
;
i
<
get_types_count
(
)
;
+
+
i
)
{
const
ResourceTypeItem
&
type
=
get_type
(
i
)
;
if
(
unlikely
(
!
type
.
sanitize
(
c
)
)
)
return_trace
(
false
)
;
for
(
unsigned
int
j
=
0
;
j
<
type
.
get_resource_count
(
)
;
+
+
j
)
if
(
unlikely
(
!
get_ref_item
(
type
j
)
.
sanitize
(
c
)
)
)
return_trace
(
false
)
;
}
return_trace
(
true
)
;
}
inline
const
ResourceTypeItem
&
get_type
(
unsigned
int
i
)
const
{
return
(
(
&
reserved
[
2
]
)
+
typeList
)
[
i
]
;
}
inline
unsigned
int
get_types_count
(
)
const
{
return
nTypes
+
1
;
}
inline
const
ResourceRefItem
&
get_ref_item
(
const
ResourceTypeItem
&
type
unsigned
int
i
)
const
{
return
type
.
get_ref_item
(
&
(
this
+
typeList
)
i
)
;
}
inline
const
PString
&
get_name
(
const
ResourceRefItem
&
item
unsigned
int
i
)
const
{
if
(
item
.
nameOffset
=
=
-
1
)
return
Null
(
PString
)
;
return
StructAtOffset
<
PString
>
(
this
nameList
+
item
.
nameOffset
)
;
}
protected
:
HBUINT8
reserved
[
16
]
;
LOffsetTo
<
ResourceMap
>
reserved1
;
HBUINT16
reserved2
;
HBUINT16
attr
;
OffsetTo
<
UnsizedArrayOf
<
ResourceTypeItem
>
>
typeList
;
HBUINT16
nameList
;
HBUINT16
nTypes
;
public
:
DEFINE_SIZE_STATIC
(
30
)
;
}
;
struct
ResourceForkHeader
{
inline
unsigned
int
get_face_count
(
)
const
{
const
ResourceMap
&
resource_map
=
this
+
map
;
for
(
unsigned
int
i
=
0
;
i
<
resource_map
.
get_types_count
(
)
;
+
+
i
)
{
const
ResourceTypeItem
&
type
=
resource_map
.
get_type
(
i
)
;
if
(
type
.
is_sfnt
(
)
)
return
type
.
get_resource_count
(
)
;
}
return
0
;
}
inline
const
LArrayOf
<
HBUINT8
>
&
get_data
(
const
ResourceTypeItem
&
type
unsigned
int
idx
)
const
{
const
ResourceMap
&
resource_map
=
this
+
map
;
unsigned
int
offset
=
dataOffset
;
offset
+
=
resource_map
.
get_ref_item
(
type
idx
)
.
dataOffset
;
return
StructAtOffset
<
LArrayOf
<
HBUINT8
>
>
(
this
offset
)
;
}
inline
const
OpenTypeFontFace
&
get_face
(
unsigned
int
idx
)
const
{
const
ResourceMap
&
resource_map
=
this
+
map
;
for
(
unsigned
int
i
=
0
;
i
<
resource_map
.
get_types_count
(
)
;
+
+
i
)
{
const
ResourceTypeItem
&
type
=
resource_map
.
get_type
(
i
)
;
if
(
type
.
is_sfnt
(
)
&
&
idx
<
type
.
get_resource_count
(
)
)
return
(
OpenTypeFontFace
&
)
get_data
(
type
idx
)
.
arrayZ
;
}
return
Null
(
OpenTypeFontFace
)
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
c
-
>
check_struct
(
this
)
)
)
return_trace
(
false
)
;
const
ResourceMap
&
resource_map
=
this
+
map
;
if
(
unlikely
(
!
resource_map
.
sanitize
(
c
)
)
)
return_trace
(
false
)
;
for
(
unsigned
int
i
=
0
;
i
<
resource_map
.
get_types_count
(
)
;
+
+
i
)
{
const
ResourceTypeItem
&
type
=
resource_map
.
get_type
(
i
)
;
for
(
unsigned
int
j
=
0
;
j
<
type
.
get_resource_count
(
)
;
+
+
j
)
{
const
LArrayOf
<
HBUINT8
>
&
data
=
get_data
(
type
j
)
;
if
(
unlikely
(
!
(
data
.
sanitize
(
c
)
&
&
(
(
OpenTypeFontFace
&
)
data
.
arrayZ
)
.
sanitize
(
c
)
)
)
)
return_trace
(
false
)
;
}
}
return_trace
(
true
)
;
}
protected
:
HBUINT32
dataOffset
;
LOffsetTo
<
ResourceMap
>
map
;
HBUINT32
dataLen
;
HBUINT32
mapLen
;
public
:
DEFINE_SIZE_STATIC
(
16
)
;
}
;
struct
OpenTypeFontFile
{
enum
{
CFFTag
=
HB_TAG
(
'
O
'
'
T
'
'
T
'
'
O
'
)
TrueTypeTag
=
HB_TAG
(
0
1
0
0
)
TTCTag
=
HB_TAG
(
'
t
'
'
t
'
'
c
'
'
f
'
)
DFontTag
=
HB_TAG
(
0
0
1
0
)
TrueTag
=
HB_TAG
(
'
t
'
'
r
'
'
u
'
'
e
'
)
Typ1Tag
=
HB_TAG
(
'
t
'
'
y
'
'
p
'
'
1
'
)
}
;
inline
hb_tag_t
get_tag
(
void
)
const
{
return
u
.
tag
;
}
inline
unsigned
int
get_face_count
(
void
)
const
{
switch
(
u
.
tag
)
{
case
CFFTag
:
case
TrueTag
:
case
Typ1Tag
:
case
TrueTypeTag
:
return
1
;
case
TTCTag
:
return
u
.
ttcHeader
.
get_face_count
(
)
;
default
:
return
0
;
}
}
inline
const
OpenTypeFontFace
&
get_face
(
unsigned
int
i
)
const
{
switch
(
u
.
tag
)
{
case
CFFTag
:
case
TrueTag
:
case
Typ1Tag
:
case
TrueTypeTag
:
return
u
.
fontFace
;
case
TTCTag
:
return
u
.
ttcHeader
.
get_face
(
i
)
;
default
:
return
Null
(
OpenTypeFontFace
)
;
}
}
inline
bool
serialize_single
(
hb_serialize_context_t
*
c
hb_tag_t
sfnt_tag
Supplier
<
hb_tag_t
>
&
tags
Supplier
<
hb_blob_t
*
>
&
blobs
unsigned
int
table_count
)
{
TRACE_SERIALIZE
(
this
)
;
assert
(
sfnt_tag
!
=
TTCTag
)
;
if
(
unlikely
(
!
c
-
>
extend_min
(
*
this
)
)
)
return_trace
(
false
)
;
return_trace
(
u
.
fontFace
.
serialize
(
c
sfnt_tag
tags
blobs
table_count
)
)
;
}
inline
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
u
.
tag
.
sanitize
(
c
)
)
)
return_trace
(
false
)
;
switch
(
u
.
tag
)
{
case
CFFTag
:
case
TrueTag
:
case
Typ1Tag
:
case
TrueTypeTag
:
return_trace
(
u
.
fontFace
.
sanitize
(
c
)
)
;
case
TTCTag
:
return_trace
(
u
.
ttcHeader
.
sanitize
(
c
)
)
;
default
:
return_trace
(
true
)
;
}
}
protected
:
union
{
Tag
tag
;
OpenTypeFontFace
fontFace
;
TTCHeader
ttcHeader
;
ResourceForkHeader
rfHeader
;
}
u
;
public
:
DEFINE_SIZE_UNION
(
4
tag
)
;
}
;
}
#
endif
