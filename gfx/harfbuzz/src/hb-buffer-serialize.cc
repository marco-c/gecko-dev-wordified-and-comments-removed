#
include
"
hb
.
hh
"
#
ifndef
HB_NO_BUFFER_SERIALIZE
#
include
"
hb
-
buffer
.
hh
"
static
const
char
*
_hb_buffer_serialize_formats
[
]
=
{
"
text
"
"
json
"
nullptr
}
;
const
char
*
*
hb_buffer_serialize_list_formats
(
)
{
return
_hb_buffer_serialize_formats
;
}
hb_buffer_serialize_format_t
hb_buffer_serialize_format_from_string
(
const
char
*
str
int
len
)
{
return
(
hb_buffer_serialize_format_t
)
(
hb_tag_from_string
(
str
len
)
&
~
0x20202020u
)
;
}
const
char
*
hb_buffer_serialize_format_to_string
(
hb_buffer_serialize_format_t
format
)
{
switch
(
(
unsigned
)
format
)
{
case
HB_BUFFER_SERIALIZE_FORMAT_TEXT
:
return
_hb_buffer_serialize_formats
[
0
]
;
case
HB_BUFFER_SERIALIZE_FORMAT_JSON
:
return
_hb_buffer_serialize_formats
[
1
]
;
default
:
case
HB_BUFFER_SERIALIZE_FORMAT_INVALID
:
return
nullptr
;
}
}
static
unsigned
int
_hb_buffer_serialize_glyphs_json
(
hb_buffer_t
*
buffer
unsigned
int
start
unsigned
int
end
char
*
buf
unsigned
int
buf_size
unsigned
int
*
buf_consumed
hb_font_t
*
font
hb_buffer_serialize_flags_t
flags
)
{
hb_glyph_info_t
*
info
=
hb_buffer_get_glyph_infos
(
buffer
nullptr
)
;
hb_glyph_position_t
*
pos
=
(
flags
&
HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS
)
?
nullptr
:
hb_buffer_get_glyph_positions
(
buffer
nullptr
)
;
*
buf_consumed
=
0
;
hb_position_t
x
=
0
y
=
0
;
for
(
unsigned
int
i
=
start
;
i
<
end
;
i
+
+
)
{
char
b
[
1024
]
;
char
*
p
=
b
;
#
define
APPEND
(
s
)
HB_STMT_START
{
strcpy
(
p
s
)
;
p
+
=
strlen
(
s
)
;
}
HB_STMT_END
if
(
i
)
*
p
+
+
=
'
'
;
else
*
p
+
+
=
'
[
'
;
*
p
+
+
=
'
{
'
;
APPEND
(
"
\
"
g
\
"
:
"
)
;
if
(
!
(
flags
&
HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES
)
)
{
char
g
[
128
]
;
hb_font_glyph_to_string
(
font
info
[
i
]
.
codepoint
g
sizeof
(
g
)
)
;
*
p
+
+
=
'
"
'
;
for
(
char
*
q
=
g
;
*
q
;
q
+
+
)
{
if
(
unlikely
(
*
q
=
=
'
"
'
|
|
*
q
=
=
'
\
\
'
)
)
*
p
+
+
=
'
\
\
'
;
*
p
+
+
=
*
q
;
}
*
p
+
+
=
'
"
'
;
}
else
p
+
=
hb_max
(
0
snprintf
(
p
ARRAY_LENGTH
(
b
)
-
(
p
-
b
)
"
%
u
"
info
[
i
]
.
codepoint
)
)
;
if
(
!
(
flags
&
HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS
)
)
{
p
+
=
hb_max
(
0
snprintf
(
p
ARRAY_LENGTH
(
b
)
-
(
p
-
b
)
"
\
"
cl
\
"
:
%
u
"
info
[
i
]
.
cluster
)
)
;
}
if
(
!
(
flags
&
HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS
)
)
{
p
+
=
hb_max
(
0
snprintf
(
p
ARRAY_LENGTH
(
b
)
-
(
p
-
b
)
"
\
"
dx
\
"
:
%
d
\
"
dy
\
"
:
%
d
"
x
+
pos
[
i
]
.
x_offset
y
+
pos
[
i
]
.
y_offset
)
)
;
if
(
!
(
flags
&
HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES
)
)
p
+
=
hb_max
(
0
snprintf
(
p
ARRAY_LENGTH
(
b
)
-
(
p
-
b
)
"
\
"
ax
\
"
:
%
d
\
"
ay
\
"
:
%
d
"
pos
[
i
]
.
x_advance
pos
[
i
]
.
y_advance
)
)
;
}
if
(
flags
&
HB_BUFFER_SERIALIZE_FLAG_GLYPH_FLAGS
)
{
if
(
info
[
i
]
.
mask
&
HB_GLYPH_FLAG_DEFINED
)
p
+
=
hb_max
(
0
snprintf
(
p
ARRAY_LENGTH
(
b
)
-
(
p
-
b
)
"
\
"
fl
\
"
:
%
u
"
info
[
i
]
.
mask
&
HB_GLYPH_FLAG_DEFINED
)
)
;
}
if
(
flags
&
HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS
)
{
hb_glyph_extents_t
extents
;
hb_font_get_glyph_extents
(
font
info
[
i
]
.
codepoint
&
extents
)
;
p
+
=
hb_max
(
0
snprintf
(
p
ARRAY_LENGTH
(
b
)
-
(
p
-
b
)
"
\
"
xb
\
"
:
%
d
\
"
yb
\
"
:
%
d
"
extents
.
x_bearing
extents
.
y_bearing
)
)
;
p
+
=
hb_max
(
0
snprintf
(
p
ARRAY_LENGTH
(
b
)
-
(
p
-
b
)
"
\
"
w
\
"
:
%
d
\
"
h
\
"
:
%
d
"
extents
.
width
extents
.
height
)
)
;
}
*
p
+
+
=
'
}
'
;
if
(
i
=
=
end
-
1
)
*
p
+
+
=
'
]
'
;
unsigned
int
l
=
p
-
b
;
if
(
buf_size
>
l
)
{
hb_memcpy
(
buf
b
l
)
;
buf
+
=
l
;
buf_size
-
=
l
;
*
buf_consumed
+
=
l
;
*
buf
=
'
\
0
'
;
}
else
return
i
-
start
;
if
(
pos
&
&
(
flags
&
HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES
)
)
{
x
+
=
pos
[
i
]
.
x_advance
;
y
+
=
pos
[
i
]
.
y_advance
;
}
}
return
end
-
start
;
}
static
unsigned
int
_hb_buffer_serialize_unicode_json
(
hb_buffer_t
*
buffer
unsigned
int
start
unsigned
int
end
char
*
buf
unsigned
int
buf_size
unsigned
int
*
buf_consumed
hb_buffer_serialize_flags_t
flags
)
{
hb_glyph_info_t
*
info
=
hb_buffer_get_glyph_infos
(
buffer
nullptr
)
;
*
buf_consumed
=
0
;
for
(
unsigned
int
i
=
start
;
i
<
end
;
i
+
+
)
{
char
b
[
1024
]
;
char
*
p
=
b
;
if
(
i
)
*
p
+
+
=
'
'
;
else
*
p
+
+
=
'
[
'
;
*
p
+
+
=
'
{
'
;
APPEND
(
"
\
"
u
\
"
:
"
)
;
p
+
=
hb_max
(
0
snprintf
(
p
ARRAY_LENGTH
(
b
)
-
(
p
-
b
)
"
%
u
"
info
[
i
]
.
codepoint
)
)
;
if
(
!
(
flags
&
HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS
)
)
{
p
+
=
hb_max
(
0
snprintf
(
p
ARRAY_LENGTH
(
b
)
-
(
p
-
b
)
"
\
"
cl
\
"
:
%
u
"
info
[
i
]
.
cluster
)
)
;
}
*
p
+
+
=
'
}
'
;
if
(
i
=
=
end
-
1
)
*
p
+
+
=
'
]
'
;
unsigned
int
l
=
p
-
b
;
if
(
buf_size
>
l
)
{
hb_memcpy
(
buf
b
l
)
;
buf
+
=
l
;
buf_size
-
=
l
;
*
buf_consumed
+
=
l
;
*
buf
=
'
\
0
'
;
}
else
return
i
-
start
;
}
return
end
-
start
;
}
static
unsigned
int
_hb_buffer_serialize_glyphs_text
(
hb_buffer_t
*
buffer
unsigned
int
start
unsigned
int
end
char
*
buf
unsigned
int
buf_size
unsigned
int
*
buf_consumed
hb_font_t
*
font
hb_buffer_serialize_flags_t
flags
)
{
hb_glyph_info_t
*
info
=
hb_buffer_get_glyph_infos
(
buffer
nullptr
)
;
hb_glyph_position_t
*
pos
=
(
flags
&
HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS
)
?
nullptr
:
hb_buffer_get_glyph_positions
(
buffer
nullptr
)
;
*
buf_consumed
=
0
;
hb_position_t
x
=
0
y
=
0
;
for
(
unsigned
int
i
=
start
;
i
<
end
;
i
+
+
)
{
char
b
[
1024
]
;
char
*
p
=
b
;
if
(
i
)
*
p
+
+
=
'
|
'
;
else
*
p
+
+
=
'
[
'
;
if
(
!
(
flags
&
HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES
)
)
{
hb_font_glyph_to_string
(
font
info
[
i
]
.
codepoint
p
128
)
;
p
+
=
strlen
(
p
)
;
}
else
p
+
=
hb_max
(
0
snprintf
(
p
ARRAY_LENGTH
(
b
)
-
(
p
-
b
)
"
%
u
"
info
[
i
]
.
codepoint
)
)
;
if
(
!
(
flags
&
HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS
)
)
{
p
+
=
hb_max
(
0
snprintf
(
p
ARRAY_LENGTH
(
b
)
-
(
p
-
b
)
"
=
%
u
"
info
[
i
]
.
cluster
)
)
;
}
if
(
!
(
flags
&
HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS
)
)
{
if
(
x
+
pos
[
i
]
.
x_offset
|
|
y
+
pos
[
i
]
.
y_offset
)
p
+
=
hb_max
(
0
snprintf
(
p
ARRAY_LENGTH
(
b
)
-
(
p
-
b
)
"
%
d
%
d
"
x
+
pos
[
i
]
.
x_offset
y
+
pos
[
i
]
.
y_offset
)
)
;
if
(
!
(
flags
&
HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES
)
)
{
*
p
+
+
=
'
+
'
;
p
+
=
hb_max
(
0
snprintf
(
p
ARRAY_LENGTH
(
b
)
-
(
p
-
b
)
"
%
d
"
pos
[
i
]
.
x_advance
)
)
;
if
(
pos
[
i
]
.
y_advance
)
p
+
=
hb_max
(
0
snprintf
(
p
ARRAY_LENGTH
(
b
)
-
(
p
-
b
)
"
%
d
"
pos
[
i
]
.
y_advance
)
)
;
}
}
if
(
flags
&
HB_BUFFER_SERIALIZE_FLAG_GLYPH_FLAGS
)
{
if
(
info
[
i
]
.
mask
&
HB_GLYPH_FLAG_DEFINED
)
p
+
=
hb_max
(
0
snprintf
(
p
ARRAY_LENGTH
(
b
)
-
(
p
-
b
)
"
#
%
X
"
info
[
i
]
.
mask
&
HB_GLYPH_FLAG_DEFINED
)
)
;
}
if
(
flags
&
HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS
)
{
hb_glyph_extents_t
extents
;
hb_font_get_glyph_extents
(
font
info
[
i
]
.
codepoint
&
extents
)
;
p
+
=
hb_max
(
0
snprintf
(
p
ARRAY_LENGTH
(
b
)
-
(
p
-
b
)
"
<
%
d
%
d
%
d
%
d
>
"
extents
.
x_bearing
extents
.
y_bearing
extents
.
width
extents
.
height
)
)
;
}
if
(
i
=
=
end
-
1
)
{
*
p
+
+
=
'
]
'
;
}
unsigned
int
l
=
p
-
b
;
if
(
buf_size
>
l
)
{
hb_memcpy
(
buf
b
l
)
;
buf
+
=
l
;
buf_size
-
=
l
;
*
buf_consumed
+
=
l
;
*
buf
=
'
\
0
'
;
}
else
return
i
-
start
;
if
(
pos
&
&
(
flags
&
HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES
)
)
{
x
+
=
pos
[
i
]
.
x_advance
;
y
+
=
pos
[
i
]
.
y_advance
;
}
}
return
end
-
start
;
}
static
unsigned
int
_hb_buffer_serialize_unicode_text
(
hb_buffer_t
*
buffer
unsigned
int
start
unsigned
int
end
char
*
buf
unsigned
int
buf_size
unsigned
int
*
buf_consumed
hb_buffer_serialize_flags_t
flags
)
{
hb_glyph_info_t
*
info
=
hb_buffer_get_glyph_infos
(
buffer
nullptr
)
;
*
buf_consumed
=
0
;
for
(
unsigned
int
i
=
start
;
i
<
end
;
i
+
+
)
{
char
b
[
1024
]
;
char
*
p
=
b
;
if
(
i
)
*
p
+
+
=
'
|
'
;
else
*
p
+
+
=
'
<
'
;
p
+
=
hb_max
(
0
snprintf
(
p
ARRAY_LENGTH
(
b
)
-
(
p
-
b
)
"
U
+
%
04X
"
info
[
i
]
.
codepoint
)
)
;
if
(
!
(
flags
&
HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS
)
)
{
p
+
=
hb_max
(
0
snprintf
(
p
ARRAY_LENGTH
(
b
)
-
(
p
-
b
)
"
=
%
u
"
info
[
i
]
.
cluster
)
)
;
}
if
(
i
=
=
end
-
1
)
*
p
+
+
=
'
>
'
;
unsigned
int
l
=
p
-
b
;
if
(
buf_size
>
l
)
{
hb_memcpy
(
buf
b
l
)
;
buf
+
=
l
;
buf_size
-
=
l
;
*
buf_consumed
+
=
l
;
*
buf
=
'
\
0
'
;
}
else
return
i
-
start
;
}
return
end
-
start
;
}
unsigned
int
hb_buffer_serialize_glyphs
(
hb_buffer_t
*
buffer
unsigned
int
start
unsigned
int
end
char
*
buf
unsigned
int
buf_size
unsigned
int
*
buf_consumed
hb_font_t
*
font
hb_buffer_serialize_format_t
format
hb_buffer_serialize_flags_t
flags
)
{
end
=
hb_clamp
(
end
start
buffer
-
>
len
)
;
start
=
hb_min
(
start
end
)
;
unsigned
int
sconsumed
;
if
(
!
buf_consumed
)
buf_consumed
=
&
sconsumed
;
*
buf_consumed
=
0
;
if
(
buf_size
)
*
buf
=
'
\
0
'
;
buffer
-
>
assert_glyphs
(
)
;
if
(
!
buffer
-
>
have_positions
)
flags
|
=
HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS
;
if
(
unlikely
(
start
=
=
end
)
)
return
0
;
if
(
!
font
)
font
=
hb_font_get_empty
(
)
;
switch
(
format
)
{
case
HB_BUFFER_SERIALIZE_FORMAT_TEXT
:
return
_hb_buffer_serialize_glyphs_text
(
buffer
start
end
buf
buf_size
buf_consumed
font
flags
)
;
case
HB_BUFFER_SERIALIZE_FORMAT_JSON
:
return
_hb_buffer_serialize_glyphs_json
(
buffer
start
end
buf
buf_size
buf_consumed
font
flags
)
;
default
:
case
HB_BUFFER_SERIALIZE_FORMAT_INVALID
:
return
0
;
}
}
unsigned
int
hb_buffer_serialize_unicode
(
hb_buffer_t
*
buffer
unsigned
int
start
unsigned
int
end
char
*
buf
unsigned
int
buf_size
unsigned
int
*
buf_consumed
hb_buffer_serialize_format_t
format
hb_buffer_serialize_flags_t
flags
)
{
end
=
hb_clamp
(
end
start
buffer
-
>
len
)
;
start
=
hb_min
(
start
end
)
;
unsigned
int
sconsumed
;
if
(
!
buf_consumed
)
buf_consumed
=
&
sconsumed
;
*
buf_consumed
=
0
;
if
(
buf_size
)
*
buf
=
'
\
0
'
;
buffer
-
>
assert_unicode
(
)
;
if
(
unlikely
(
start
=
=
end
)
)
return
0
;
switch
(
format
)
{
case
HB_BUFFER_SERIALIZE_FORMAT_TEXT
:
return
_hb_buffer_serialize_unicode_text
(
buffer
start
end
buf
buf_size
buf_consumed
flags
)
;
case
HB_BUFFER_SERIALIZE_FORMAT_JSON
:
return
_hb_buffer_serialize_unicode_json
(
buffer
start
end
buf
buf_size
buf_consumed
flags
)
;
default
:
case
HB_BUFFER_SERIALIZE_FORMAT_INVALID
:
return
0
;
}
}
static
unsigned
int
_hb_buffer_serialize_invalid
(
hb_buffer_t
*
buffer
unsigned
int
start
unsigned
int
end
char
*
buf
unsigned
int
buf_size
unsigned
int
*
buf_consumed
hb_buffer_serialize_format_t
format
hb_buffer_serialize_flags_t
flags
)
{
assert
(
!
buffer
-
>
len
)
;
unsigned
int
sconsumed
;
if
(
!
buf_consumed
)
buf_consumed
=
&
sconsumed
;
if
(
buf_size
<
3
)
return
0
;
if
(
format
=
=
HB_BUFFER_SERIALIZE_FORMAT_JSON
)
{
*
buf
+
+
=
'
[
'
;
*
buf
+
+
=
'
]
'
;
*
buf
=
'
\
0
'
;
}
else
if
(
format
=
=
HB_BUFFER_SERIALIZE_FORMAT_TEXT
)
{
*
buf
+
+
=
'
!
'
;
*
buf
+
+
=
'
!
'
;
*
buf
=
'
\
0
'
;
}
*
buf_consumed
=
2
;
return
0
;
}
unsigned
int
hb_buffer_serialize
(
hb_buffer_t
*
buffer
unsigned
int
start
unsigned
int
end
char
*
buf
unsigned
int
buf_size
unsigned
int
*
buf_consumed
hb_font_t
*
font
hb_buffer_serialize_format_t
format
hb_buffer_serialize_flags_t
flags
)
{
switch
(
buffer
-
>
content_type
)
{
case
HB_BUFFER_CONTENT_TYPE_GLYPHS
:
return
hb_buffer_serialize_glyphs
(
buffer
start
end
buf
buf_size
buf_consumed
font
format
flags
)
;
case
HB_BUFFER_CONTENT_TYPE_UNICODE
:
return
hb_buffer_serialize_unicode
(
buffer
start
end
buf
buf_size
buf_consumed
format
flags
)
;
case
HB_BUFFER_CONTENT_TYPE_INVALID
:
default
:
return
_hb_buffer_serialize_invalid
(
buffer
start
end
buf
buf_size
buf_consumed
format
flags
)
;
}
}
static
bool
parse_int
(
const
char
*
pp
const
char
*
end
int32_t
*
pv
)
{
int
v
;
const
char
*
p
=
pp
;
if
(
unlikely
(
!
hb_parse_int
(
&
p
end
&
v
true
)
)
)
return
false
;
*
pv
=
v
;
return
true
;
}
static
bool
parse_uint
(
const
char
*
pp
const
char
*
end
uint32_t
*
pv
)
{
unsigned
int
v
;
const
char
*
p
=
pp
;
if
(
unlikely
(
!
hb_parse_uint
(
&
p
end
&
v
true
)
)
)
return
false
;
*
pv
=
v
;
return
true
;
}
static
bool
parse_hex
(
const
char
*
pp
const
char
*
end
uint32_t
*
pv
)
{
unsigned
int
v
;
const
char
*
p
=
pp
;
if
(
unlikely
(
!
hb_parse_uint
(
&
p
end
&
v
true
16
)
)
)
return
false
;
*
pv
=
v
;
return
true
;
}
#
include
"
hb
-
buffer
-
deserialize
-
json
.
hh
"
#
include
"
hb
-
buffer
-
deserialize
-
text
.
hh
"
hb_bool_t
hb_buffer_deserialize_glyphs
(
hb_buffer_t
*
buffer
const
char
*
buf
int
buf_len
const
char
*
*
end_ptr
hb_font_t
*
font
hb_buffer_serialize_format_t
format
)
{
const
char
*
end
;
if
(
!
end_ptr
)
end_ptr
=
&
end
;
*
end_ptr
=
buf
;
buffer
-
>
assert_glyphs
(
)
;
if
(
unlikely
(
hb_object_is_immutable
(
buffer
)
)
)
{
if
(
end_ptr
)
*
end_ptr
=
buf
;
return
false
;
}
if
(
buf_len
=
=
-
1
)
buf_len
=
strlen
(
buf
)
;
if
(
!
buf_len
)
{
*
end_ptr
=
buf
;
return
false
;
}
hb_buffer_set_content_type
(
buffer
HB_BUFFER_CONTENT_TYPE_GLYPHS
)
;
if
(
!
font
)
font
=
hb_font_get_empty
(
)
;
switch
(
format
)
{
case
HB_BUFFER_SERIALIZE_FORMAT_TEXT
:
return
_hb_buffer_deserialize_text
(
buffer
buf
buf_len
end_ptr
font
)
;
case
HB_BUFFER_SERIALIZE_FORMAT_JSON
:
return
_hb_buffer_deserialize_json
(
buffer
buf
buf_len
end_ptr
font
)
;
default
:
case
HB_BUFFER_SERIALIZE_FORMAT_INVALID
:
return
false
;
}
}
hb_bool_t
hb_buffer_deserialize_unicode
(
hb_buffer_t
*
buffer
const
char
*
buf
int
buf_len
const
char
*
*
end_ptr
hb_buffer_serialize_format_t
format
)
{
const
char
*
end
;
if
(
!
end_ptr
)
end_ptr
=
&
end
;
*
end_ptr
=
buf
;
buffer
-
>
assert_unicode
(
)
;
if
(
unlikely
(
hb_object_is_immutable
(
buffer
)
)
)
{
if
(
end_ptr
)
*
end_ptr
=
buf
;
return
false
;
}
if
(
buf_len
=
=
-
1
)
buf_len
=
strlen
(
buf
)
;
if
(
!
buf_len
)
{
*
end_ptr
=
buf
;
return
false
;
}
hb_buffer_set_content_type
(
buffer
HB_BUFFER_CONTENT_TYPE_UNICODE
)
;
hb_font_t
*
font
=
hb_font_get_empty
(
)
;
switch
(
format
)
{
case
HB_BUFFER_SERIALIZE_FORMAT_TEXT
:
return
_hb_buffer_deserialize_text
(
buffer
buf
buf_len
end_ptr
font
)
;
case
HB_BUFFER_SERIALIZE_FORMAT_JSON
:
return
_hb_buffer_deserialize_json
(
buffer
buf
buf_len
end_ptr
font
)
;
default
:
case
HB_BUFFER_SERIALIZE_FORMAT_INVALID
:
return
false
;
}
}
#
endif
