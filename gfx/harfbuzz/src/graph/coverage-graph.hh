#
include
"
graph
.
hh
"
#
include
"
.
.
/
OT
/
Layout
/
Common
/
Coverage
.
hh
"
#
ifndef
GRAPH_COVERAGE_GRAPH_HH
#
define
GRAPH_COVERAGE_GRAPH_HH
namespace
graph
{
struct
CoverageFormat1
:
public
OT
:
:
Layout
:
:
Common
:
:
CoverageFormat1_3
<
SmallTypes
>
{
bool
sanitize
(
graph_t
:
:
vertex_t
&
vertex
)
const
{
int64_t
vertex_len
=
vertex
.
obj
.
tail
-
vertex
.
obj
.
head
;
constexpr
unsigned
min_size
=
OT
:
:
Layout
:
:
Common
:
:
CoverageFormat1_3
<
SmallTypes
>
:
:
min_size
;
if
(
vertex_len
<
min_size
)
return
false
;
return
vertex_len
>
=
min_size
+
glyphArray
.
get_size
(
)
-
glyphArray
.
len
.
get_size
(
)
;
}
}
;
struct
CoverageFormat2
:
public
OT
:
:
Layout
:
:
Common
:
:
CoverageFormat2_4
<
SmallTypes
>
{
bool
sanitize
(
graph_t
:
:
vertex_t
&
vertex
)
const
{
int64_t
vertex_len
=
vertex
.
obj
.
tail
-
vertex
.
obj
.
head
;
constexpr
unsigned
min_size
=
OT
:
:
Layout
:
:
Common
:
:
CoverageFormat2_4
<
SmallTypes
>
:
:
min_size
;
if
(
vertex_len
<
min_size
)
return
false
;
return
vertex_len
>
=
min_size
+
rangeRecord
.
get_size
(
)
-
rangeRecord
.
len
.
get_size
(
)
;
}
}
;
struct
Coverage
:
public
OT
:
:
Layout
:
:
Common
:
:
Coverage
{
bool
sanitize
(
graph_t
:
:
vertex_t
&
vertex
)
const
{
int64_t
vertex_len
=
vertex
.
obj
.
tail
-
vertex
.
obj
.
head
;
if
(
vertex_len
<
OT
:
:
Layout
:
:
Common
:
:
Coverage
:
:
min_size
)
return
false
;
switch
(
u
.
format
)
{
case
1
:
return
(
(
CoverageFormat1
*
)
this
)
-
>
sanitize
(
vertex
)
;
case
2
:
return
(
(
CoverageFormat2
*
)
this
)
-
>
sanitize
(
vertex
)
;
#
ifndef
HB_NO_BORING_EXPANSION
case
3
:
case
4
:
#
endif
default
:
return
false
;
}
}
}
;
}
#
endif
