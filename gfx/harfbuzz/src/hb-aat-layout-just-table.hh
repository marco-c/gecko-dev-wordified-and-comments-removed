#
ifndef
HB_AAT_LAYOUT_JUST_TABLE_HH
#
define
HB_AAT_LAYOUT_JUST_TABLE_HH
#
include
"
hb
-
aat
-
layout
-
common
.
hh
"
#
include
"
hb
-
ot
-
layout
.
hh
"
#
include
"
hb
-
open
-
type
.
hh
"
#
include
"
hb
-
aat
-
layout
-
morx
-
table
.
hh
"
#
define
HB_AAT_TAG_just
HB_TAG
(
'
j
'
'
u
'
'
s
'
'
t
'
)
namespace
AAT
{
using
namespace
OT
;
struct
ActionSubrecordHeader
{
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
)
)
;
}
HBUINT16
actionClass
;
HBUINT16
actionType
;
HBUINT16
actionLength
;
public
:
DEFINE_SIZE_STATIC
(
6
)
;
}
;
struct
DecompositionAction
{
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
)
)
;
}
ActionSubrecordHeader
header
;
Fixed
lowerLimit
;
Fixed
upperLimit
;
HBUINT16
order
;
ArrayOf
<
HBUINT16
>
decomposedglyphs
;
public
:
DEFINE_SIZE_ARRAY
(
18
decomposedglyphs
)
;
}
;
struct
UnconditionalAddGlyphAction
{
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
protected
:
ActionSubrecordHeader
header
;
GlyphID
addGlyph
;
public
:
DEFINE_SIZE_STATIC
(
8
)
;
}
;
struct
ConditionalAddGlyphAction
{
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
)
)
;
}
protected
:
ActionSubrecordHeader
header
;
Fixed
substThreshold
;
GlyphID
addGlyph
;
GlyphID
substGlyph
;
public
:
DEFINE_SIZE_STATIC
(
14
)
;
}
;
struct
DuctileGlyphAction
{
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
)
)
;
}
protected
:
ActionSubrecordHeader
header
;
HBUINT32
variationAxis
;
Fixed
minimumLimit
;
Fixed
noStretchValue
;
Fixed
maximumLimit
;
public
:
DEFINE_SIZE_STATIC
(
22
)
;
}
;
struct
RepeatedAddGlyphAction
{
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
)
)
;
}
protected
:
ActionSubrecordHeader
header
;
HBUINT16
flags
;
GlyphID
glyph
;
public
:
DEFINE_SIZE_STATIC
(
10
)
;
}
;
struct
ActionSubrecord
{
unsigned
int
get_length
(
)
const
{
return
u
.
header
.
actionLength
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
c
-
>
check_struct
(
this
)
)
)
return_trace
(
false
)
;
switch
(
u
.
header
.
actionType
)
{
case
0
:
return_trace
(
u
.
decompositionAction
.
sanitize
(
c
)
)
;
case
1
:
return_trace
(
u
.
unconditionalAddGlyphAction
.
sanitize
(
c
)
)
;
case
2
:
return_trace
(
u
.
conditionalAddGlyphAction
.
sanitize
(
c
)
)
;
case
4
:
return_trace
(
u
.
decompositionAction
.
sanitize
(
c
)
)
;
case
5
:
return_trace
(
u
.
decompositionAction
.
sanitize
(
c
)
)
;
default
:
return_trace
(
true
)
;
}
}
protected
:
union
{
ActionSubrecordHeader
header
;
DecompositionAction
decompositionAction
;
UnconditionalAddGlyphAction
unconditionalAddGlyphAction
;
ConditionalAddGlyphAction
conditionalAddGlyphAction
;
DuctileGlyphAction
ductileGlyphAction
;
RepeatedAddGlyphAction
repeatedAddGlyphAction
;
}
u
;
public
:
DEFINE_SIZE_UNION
(
6
header
)
;
}
;
struct
PostcompensationActionChain
{
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
c
-
>
check_struct
(
this
)
)
)
return_trace
(
false
)
;
unsigned
int
offset
=
min_size
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
const
ActionSubrecord
&
subrecord
=
StructAtOffset
<
ActionSubrecord
>
(
this
offset
)
;
if
(
unlikely
(
!
subrecord
.
sanitize
(
c
)
)
)
return_trace
(
false
)
;
offset
+
=
subrecord
.
get_length
(
)
;
}
return_trace
(
true
)
;
}
protected
:
HBUINT32
count
;
public
:
DEFINE_SIZE_STATIC
(
4
)
;
}
;
struct
JustWidthDeltaEntry
{
enum
Flags
{
Reserved1
=
0xE000
UnlimiteGap
=
0x1000
Reserved2
=
0x0FF0
Priority
=
0x000F
}
;
enum
Priority
{
Kashida
=
0
Whitespace
=
1
InterCharacter
=
2
NullPriority
=
3
}
;
protected
:
Fixed
beforeGrowLimit
;
Fixed
beforeShrinkLimit
;
Fixed
afterGrowLimit
;
Fixed
afterShrinkLimit
;
HBUINT16
growFlags
;
HBUINT16
shrinkFlags
;
public
:
DEFINE_SIZE_STATIC
(
20
)
;
}
;
struct
WidthDeltaPair
{
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
)
)
;
}
protected
:
HBUINT32
justClass
;
JustWidthDeltaEntry
wdRecord
;
public
:
DEFINE_SIZE_STATIC
(
24
)
;
}
;
typedef
OT
:
:
LArrayOf
<
WidthDeltaPair
>
WidthDeltaCluster
;
struct
JustificationCategory
{
typedef
void
EntryData
;
enum
Flags
{
SetMark
=
0x8000
DontAdvance
=
0x4000
MarkCategory
=
0x3F80
CurrentCategory
=
0x007F
}
;
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
morphHeader
.
sanitize
(
c
)
&
&
stHeader
.
sanitize
(
c
)
)
)
;
}
protected
:
ChainSubtable
<
ObsoleteTypes
>
morphHeader
;
StateTable
<
ObsoleteTypes
EntryData
>
stHeader
;
public
:
DEFINE_SIZE_STATIC
(
30
)
;
}
;
struct
JustificationHeader
{
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
justClassTable
.
sanitize
(
c
base
base
)
&
&
wdcTable
.
sanitize
(
c
base
)
&
&
pcTable
.
sanitize
(
c
base
)
&
&
lookupTable
.
sanitize
(
c
base
)
)
)
;
}
protected
:
OffsetTo
<
JustificationCategory
>
justClassTable
;
OffsetTo
<
WidthDeltaCluster
>
wdcTable
;
OffsetTo
<
PostcompensationActionChain
>
pcTable
;
Lookup
<
OffsetTo
<
WidthDeltaCluster
>
>
lookupTable
;
public
:
DEFINE_SIZE_MIN
(
8
)
;
}
;
struct
just
{
static
constexpr
hb_tag_t
tableTag
=
HB_AAT_TAG_just
;
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
version
.
major
=
=
1
&
&
horizData
.
sanitize
(
c
this
this
)
&
&
vertData
.
sanitize
(
c
this
this
)
)
)
;
}
protected
:
FixedVersion
<
>
version
;
HBUINT16
format
;
OffsetTo
<
JustificationHeader
>
horizData
;
OffsetTo
<
JustificationHeader
>
vertData
;
public
:
DEFINE_SIZE_STATIC
(
10
)
;
}
;
}
#
endif
