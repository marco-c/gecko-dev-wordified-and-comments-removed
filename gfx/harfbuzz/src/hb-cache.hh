#
ifndef
HB_CACHE_HH
#
define
HB_CACHE_HH
#
include
"
hb
.
hh
"
template
<
unsigned
int
key_bits
=
16
unsigned
int
value_bits
=
8
+
32
-
key_bits
unsigned
int
cache_bits
=
8
bool
thread_safe
=
true
>
struct
hb_cache_t
{
using
item_t
=
typename
std
:
:
conditional
<
thread_safe
typename
std
:
:
conditional
<
key_bits
+
value_bits
-
cache_bits
<
=
16
hb_atomic_t
<
unsigned
short
>
hb_atomic_t
<
unsigned
int
>
>
:
:
type
typename
std
:
:
conditional
<
key_bits
+
value_bits
-
cache_bits
<
=
16
unsigned
short
unsigned
int
>
:
:
type
>
:
:
type
;
static_assert
(
(
key_bits
>
=
cache_bits
)
"
"
)
;
static_assert
(
(
key_bits
+
value_bits
<
=
cache_bits
+
8
*
sizeof
(
item_t
)
)
"
"
)
;
hb_cache_t
(
)
{
clear
(
)
;
}
void
clear
(
)
{
for
(
auto
&
v
:
values
)
v
=
-
1
;
}
HB_HOT
bool
get
(
unsigned
int
key
unsigned
int
*
value
)
const
{
unsigned
int
k
=
key
&
(
(
1u
<
<
cache_bits
)
-
1
)
;
unsigned
int
v
=
values
[
k
]
;
if
(
(
key_bits
+
value_bits
-
cache_bits
=
=
8
*
sizeof
(
item_t
)
&
&
v
=
=
(
unsigned
int
)
-
1
)
|
|
(
v
>
>
value_bits
)
!
=
(
key
>
>
cache_bits
)
)
return
false
;
*
value
=
v
&
(
(
1u
<
<
value_bits
)
-
1
)
;
return
true
;
}
HB_HOT
void
set
(
unsigned
int
key
unsigned
int
value
)
{
if
(
unlikely
(
(
key
>
>
key_bits
)
|
|
(
value
>
>
value_bits
)
)
)
return
;
unsigned
int
k
=
key
&
(
(
1u
<
<
cache_bits
)
-
1
)
;
unsigned
int
v
=
(
(
key
>
>
cache_bits
)
<
<
value_bits
)
|
value
;
values
[
k
]
=
v
;
}
private
:
item_t
values
[
1u
<
<
cache_bits
]
;
}
;
#
endif
