#
ifndef
HB_REPACKER_HH
#
define
HB_REPACKER_HH
#
include
"
hb
-
open
-
type
.
hh
"
#
include
"
hb
-
map
.
hh
"
#
include
"
hb
-
vector
.
hh
"
#
include
"
graph
/
graph
.
hh
"
#
include
"
graph
/
gsubgpos
-
graph
.
hh
"
#
include
"
graph
/
serialize
.
hh
"
using
graph
:
:
graph_t
;
struct
lookup_size_t
{
unsigned
lookup_index
;
size_t
size
;
unsigned
num_subtables
;
static
int
cmp
(
const
void
*
a
const
void
*
b
)
{
return
cmp
(
(
const
lookup_size_t
*
)
a
(
const
lookup_size_t
*
)
b
)
;
}
static
int
cmp
(
const
lookup_size_t
*
a
const
lookup_size_t
*
b
)
{
double
subtables_per_byte_a
=
(
double
)
a
-
>
num_subtables
/
(
double
)
a
-
>
size
;
double
subtables_per_byte_b
=
(
double
)
b
-
>
num_subtables
/
(
double
)
b
-
>
size
;
if
(
subtables_per_byte_a
=
=
subtables_per_byte_b
)
{
return
b
-
>
lookup_index
-
a
-
>
lookup_index
;
}
double
cmp
=
subtables_per_byte_b
-
subtables_per_byte_a
;
if
(
cmp
<
0
)
return
-
1
;
if
(
cmp
>
0
)
return
1
;
return
0
;
}
}
;
static
inline
bool
_presplit_subtables_if_needed
(
graph
:
:
gsubgpos_graph_context_t
&
ext_context
)
{
hb_set_t
lookup_indices
(
ext_context
.
lookups
.
keys
(
)
)
;
for
(
unsigned
lookup_index
:
lookup_indices
)
{
graph
:
:
Lookup
*
lookup
=
ext_context
.
lookups
.
get
(
lookup_index
)
;
if
(
!
lookup
-
>
split_subtables_if_needed
(
ext_context
lookup_index
)
)
return
false
;
}
return
true
;
}
static
inline
bool
_promote_extensions_if_needed
(
graph
:
:
gsubgpos_graph_context_t
&
ext_context
)
{
if
(
!
ext_context
.
lookups
)
return
true
;
unsigned
total_lookup_table_sizes
=
0
;
hb_vector_t
<
lookup_size_t
>
lookup_sizes
;
lookup_sizes
.
alloc
(
ext_context
.
lookups
.
get_population
(
)
true
)
;
for
(
unsigned
lookup_index
:
ext_context
.
lookups
.
keys
(
)
)
{
const
auto
&
lookup_v
=
ext_context
.
graph
.
vertices_
[
lookup_index
]
;
total_lookup_table_sizes
+
=
lookup_v
.
table_size
(
)
;
const
graph
:
:
Lookup
*
lookup
=
ext_context
.
lookups
.
get
(
lookup_index
)
;
hb_set_t
visited
;
lookup_sizes
.
push
(
lookup_size_t
{
lookup_index
ext_context
.
graph
.
find_subgraph_size
(
lookup_index
visited
)
lookup
-
>
number_of_subtables
(
)
}
)
;
}
lookup_sizes
.
qsort
(
)
;
size_t
lookup_list_size
=
ext_context
.
graph
.
vertices_
[
ext_context
.
lookup_list_index
]
.
table_size
(
)
;
size_t
l2_l3_size
=
lookup_list_size
+
total_lookup_table_sizes
;
size_t
l3_l4_size
=
total_lookup_table_sizes
;
size_t
l4_plus_size
=
0
;
for
(
auto
p
:
lookup_sizes
)
{
unsigned
subtables_size
=
p
.
num_subtables
*
8
;
l3_l4_size
+
=
subtables_size
;
l4_plus_size
+
=
subtables_size
;
}
bool
layers_full
=
false
;
for
(
auto
p
:
lookup_sizes
)
{
const
graph
:
:
Lookup
*
lookup
=
ext_context
.
lookups
.
get
(
p
.
lookup_index
)
;
if
(
lookup
-
>
is_extension
(
ext_context
.
table_tag
)
)
continue
;
if
(
!
layers_full
)
{
size_t
lookup_size
=
ext_context
.
graph
.
vertices_
[
p
.
lookup_index
]
.
table_size
(
)
;
hb_set_t
visited
;
size_t
subtables_size
=
ext_context
.
graph
.
find_subgraph_size
(
p
.
lookup_index
visited
1
)
-
lookup_size
;
size_t
remaining_size
=
p
.
size
-
subtables_size
-
lookup_size
;
l3_l4_size
+
=
subtables_size
;
l3_l4_size
-
=
p
.
num_subtables
*
8
;
l4_plus_size
+
=
subtables_size
+
remaining_size
;
if
(
l2_l3_size
<
(
1
<
<
16
)
&
&
l3_l4_size
<
(
1
<
<
16
)
&
&
l4_plus_size
<
(
1
<
<
16
)
)
continue
;
layers_full
=
true
;
}
if
(
!
ext_context
.
lookups
.
get
(
p
.
lookup_index
)
-
>
make_extension
(
ext_context
p
.
lookup_index
)
)
return
false
;
}
return
true
;
}
static
inline
bool
_try_isolating_subgraphs
(
const
hb_vector_t
<
graph
:
:
overflow_record_t
>
&
overflows
graph_t
&
sorted_graph
)
{
unsigned
space
=
0
;
hb_set_t
roots_to_isolate
;
for
(
int
i
=
overflows
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
graph
:
:
overflow_record_t
&
r
=
overflows
[
i
]
;
unsigned
root
;
unsigned
overflow_space
=
sorted_graph
.
space_for
(
r
.
parent
&
root
)
;
if
(
!
overflow_space
)
continue
;
if
(
sorted_graph
.
num_roots_for_space
(
overflow_space
)
<
=
1
)
continue
;
if
(
!
space
)
{
space
=
overflow_space
;
}
if
(
space
=
=
overflow_space
)
roots_to_isolate
.
add
(
root
)
;
}
if
(
!
roots_to_isolate
)
return
false
;
unsigned
maximum_to_move
=
hb_max
(
(
sorted_graph
.
num_roots_for_space
(
space
)
/
2u
)
1u
)
;
if
(
roots_to_isolate
.
get_population
(
)
>
maximum_to_move
)
{
unsigned
extra
=
roots_to_isolate
.
get_population
(
)
-
maximum_to_move
;
while
(
extra
-
-
)
{
uint32_t
root
=
HB_SET_VALUE_INVALID
;
roots_to_isolate
.
previous
(
&
root
)
;
roots_to_isolate
.
del
(
root
)
;
}
}
DEBUG_MSG
(
SUBSET_REPACK
nullptr
"
Overflow
in
space
%
u
(
%
u
roots
)
.
Moving
%
u
roots
to
space
%
u
.
"
space
sorted_graph
.
num_roots_for_space
(
space
)
roots_to_isolate
.
get_population
(
)
sorted_graph
.
next_space
(
)
)
;
sorted_graph
.
isolate_subgraph
(
roots_to_isolate
)
;
sorted_graph
.
move_to_new_space
(
roots_to_isolate
)
;
return
true
;
}
static
inline
bool
_resolve_shared_overflow
(
const
hb_vector_t
<
graph
:
:
overflow_record_t
>
&
overflows
int
overflow_index
graph_t
&
sorted_graph
)
{
const
graph
:
:
overflow_record_t
&
r
=
overflows
[
overflow_index
]
;
hb_set_t
parents
;
parents
.
add
(
r
.
parent
)
;
for
(
int
i
=
overflow_index
-
1
;
i
>
=
0
;
i
-
-
)
{
const
graph
:
:
overflow_record_t
&
r2
=
overflows
[
i
]
;
if
(
r2
.
child
=
=
r
.
child
)
{
parents
.
add
(
r2
.
parent
)
;
}
}
unsigned
result
=
sorted_graph
.
duplicate
(
&
parents
r
.
child
)
;
if
(
result
=
=
(
unsigned
)
-
1
&
&
parents
.
get_population
(
)
>
2
)
{
parents
.
del
(
parents
.
get_min
(
)
)
;
result
=
sorted_graph
.
duplicate
(
&
parents
r
.
child
)
;
}
if
(
result
=
=
(
unsigned
)
-
1
)
return
false
;
if
(
parents
.
get_population
(
)
>
1
)
{
sorted_graph
.
vertices_
[
result
]
.
give_max_priority
(
)
;
}
return
true
;
}
static
inline
bool
_process_overflows
(
const
hb_vector_t
<
graph
:
:
overflow_record_t
>
&
overflows
hb_set_t
&
priority_bumped_parents
graph_t
&
sorted_graph
)
{
bool
resolution_attempted
=
false
;
for
(
int
i
=
overflows
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
graph
:
:
overflow_record_t
&
r
=
overflows
[
i
]
;
const
auto
&
child
=
sorted_graph
.
vertices_
[
r
.
child
]
;
if
(
child
.
is_shared
(
)
)
{
if
(
_resolve_shared_overflow
(
overflows
i
sorted_graph
)
)
return
true
;
}
if
(
child
.
is_leaf
(
)
&
&
!
priority_bumped_parents
.
has
(
r
.
parent
)
)
{
if
(
sorted_graph
.
raise_childrens_priority
(
r
.
parent
)
)
{
priority_bumped_parents
.
add
(
r
.
parent
)
;
resolution_attempted
=
true
;
}
continue
;
}
}
return
resolution_attempted
;
}
inline
bool
hb_resolve_graph_overflows
(
hb_tag_t
table_tag
unsigned
max_rounds
bool
always_recalculate_extensions
graph_t
&
sorted_graph
)
{
DEBUG_MSG
(
SUBSET_REPACK
nullptr
"
Repacking
%
c
%
c
%
c
%
c
.
"
HB_UNTAG
(
table_tag
)
)
;
sorted_graph
.
sort_shortest_distance
(
)
;
if
(
sorted_graph
.
in_error
(
)
)
{
DEBUG_MSG
(
SUBSET_REPACK
nullptr
"
Sorted
graph
in
error
state
after
initial
sort
.
"
)
;
return
false
;
}
bool
will_overflow
=
graph
:
:
will_overflow
(
sorted_graph
)
;
if
(
!
will_overflow
)
return
true
;
bool
is_gsub_or_gpos
=
(
table_tag
=
=
HB_OT_TAG_GPOS
|
|
table_tag
=
=
HB_OT_TAG_GSUB
)
;
graph
:
:
gsubgpos_graph_context_t
ext_context
(
table_tag
sorted_graph
)
;
if
(
is_gsub_or_gpos
&
&
will_overflow
)
{
DEBUG_MSG
(
SUBSET_REPACK
nullptr
"
Applying
GSUB
/
GPOS
repacking
specializations
.
"
)
;
if
(
always_recalculate_extensions
)
{
DEBUG_MSG
(
SUBSET_REPACK
nullptr
"
Splitting
subtables
if
needed
.
"
)
;
if
(
!
_presplit_subtables_if_needed
(
ext_context
)
)
{
DEBUG_MSG
(
SUBSET_REPACK
nullptr
"
Subtable
splitting
failed
.
"
)
;
return
false
;
}
DEBUG_MSG
(
SUBSET_REPACK
nullptr
"
Promoting
lookups
to
extensions
if
needed
.
"
)
;
if
(
!
_promote_extensions_if_needed
(
ext_context
)
)
{
DEBUG_MSG
(
SUBSET_REPACK
nullptr
"
Extensions
promotion
failed
.
"
)
;
return
false
;
}
}
DEBUG_MSG
(
SUBSET_REPACK
nullptr
"
Assigning
spaces
to
32
bit
subgraphs
.
"
)
;
if
(
sorted_graph
.
assign_spaces
(
)
)
sorted_graph
.
sort_shortest_distance
(
)
;
else
sorted_graph
.
sort_shortest_distance_if_needed
(
)
;
}
unsigned
round
=
0
;
hb_vector_t
<
graph
:
:
overflow_record_t
>
overflows
;
while
(
!
sorted_graph
.
in_error
(
)
&
&
graph
:
:
will_overflow
(
sorted_graph
&
overflows
)
&
&
round
<
max_rounds
)
{
DEBUG_MSG
(
SUBSET_REPACK
nullptr
"
=
=
=
Overflow
resolution
round
%
u
=
=
=
"
round
)
;
print_overflows
(
sorted_graph
overflows
)
;
hb_set_t
priority_bumped_parents
;
if
(
!
_try_isolating_subgraphs
(
overflows
sorted_graph
)
)
{
round
+
+
;
if
(
!
_process_overflows
(
overflows
priority_bumped_parents
sorted_graph
)
)
{
DEBUG_MSG
(
SUBSET_REPACK
nullptr
"
No
resolution
available
:
(
"
)
;
break
;
}
}
sorted_graph
.
sort_shortest_distance
(
)
;
}
if
(
sorted_graph
.
in_error
(
)
)
{
DEBUG_MSG
(
SUBSET_REPACK
nullptr
"
Sorted
graph
in
error
state
.
"
)
;
return
false
;
}
if
(
graph
:
:
will_overflow
(
sorted_graph
)
)
{
if
(
is_gsub_or_gpos
&
&
!
always_recalculate_extensions
)
{
DEBUG_MSG
(
SUBSET_REPACK
nullptr
"
Failed
to
find
a
resolution
.
Re
-
running
with
extension
promotion
and
table
splitting
enabled
.
"
)
;
return
hb_resolve_graph_overflows
(
table_tag
max_rounds
true
sorted_graph
)
;
}
DEBUG_MSG
(
SUBSET_REPACK
nullptr
"
Offset
overflow
resolution
failed
.
"
)
;
return
false
;
}
return
true
;
}
template
<
typename
T
>
inline
hb_blob_t
*
hb_resolve_overflows
(
const
T
&
packed
hb_tag_t
table_tag
unsigned
max_rounds
=
32
bool
recalculate_extensions
=
false
)
{
graph_t
sorted_graph
(
packed
)
;
if
(
sorted_graph
.
in_error
(
)
)
{
return
nullptr
;
}
if
(
!
sorted_graph
.
is_fully_connected
(
)
)
{
sorted_graph
.
print_orphaned_nodes
(
)
;
return
nullptr
;
}
if
(
sorted_graph
.
in_error
(
)
)
{
DEBUG_MSG
(
SUBSET_REPACK
nullptr
"
Graph
is
in
error
likely
due
to
a
memory
allocation
error
.
"
)
;
return
nullptr
;
}
if
(
!
hb_resolve_graph_overflows
(
table_tag
max_rounds
recalculate_extensions
sorted_graph
)
)
return
nullptr
;
return
graph
:
:
serialize
(
sorted_graph
)
;
}
#
endif
