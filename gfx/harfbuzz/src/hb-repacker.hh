#
ifndef
HB_REPACKER_HH
#
define
HB_REPACKER_HH
#
include
"
hb
-
open
-
type
.
hh
"
#
include
"
hb
-
map
.
hh
"
#
include
"
hb
-
priority
-
queue
.
hh
"
#
include
"
hb
-
serialize
.
hh
"
#
include
"
hb
-
vector
.
hh
"
#
include
"
graph
/
graph
.
hh
"
#
include
"
graph
/
serialize
.
hh
"
using
graph
:
:
graph_t
;
static
inline
bool
_try_isolating_subgraphs
(
const
hb_vector_t
<
graph
:
:
overflow_record_t
>
&
overflows
graph_t
&
sorted_graph
)
{
unsigned
space
=
0
;
hb_set_t
roots_to_isolate
;
for
(
int
i
=
overflows
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
graph
:
:
overflow_record_t
&
r
=
overflows
[
i
]
;
unsigned
root
;
unsigned
overflow_space
=
sorted_graph
.
space_for
(
r
.
parent
&
root
)
;
if
(
!
overflow_space
)
continue
;
if
(
sorted_graph
.
num_roots_for_space
(
overflow_space
)
<
=
1
)
continue
;
if
(
!
space
)
{
space
=
overflow_space
;
}
if
(
space
=
=
overflow_space
)
roots_to_isolate
.
add
(
root
)
;
}
if
(
!
roots_to_isolate
)
return
false
;
unsigned
maximum_to_move
=
hb_max
(
(
sorted_graph
.
num_roots_for_space
(
space
)
/
2u
)
1u
)
;
if
(
roots_to_isolate
.
get_population
(
)
>
maximum_to_move
)
{
unsigned
extra
=
roots_to_isolate
.
get_population
(
)
-
maximum_to_move
;
while
(
extra
-
-
)
{
unsigned
root
=
HB_SET_VALUE_INVALID
;
roots_to_isolate
.
previous
(
&
root
)
;
roots_to_isolate
.
del
(
root
)
;
}
}
DEBUG_MSG
(
SUBSET_REPACK
nullptr
"
Overflow
in
space
%
d
(
%
d
roots
)
.
Moving
%
d
roots
to
space
%
d
.
"
space
sorted_graph
.
num_roots_for_space
(
space
)
roots_to_isolate
.
get_population
(
)
sorted_graph
.
next_space
(
)
)
;
sorted_graph
.
isolate_subgraph
(
roots_to_isolate
)
;
sorted_graph
.
move_to_new_space
(
roots_to_isolate
)
;
return
true
;
}
static
inline
bool
_process_overflows
(
const
hb_vector_t
<
graph
:
:
overflow_record_t
>
&
overflows
hb_set_t
&
priority_bumped_parents
graph_t
&
sorted_graph
)
{
bool
resolution_attempted
=
false
;
for
(
int
i
=
overflows
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
graph
:
:
overflow_record_t
&
r
=
overflows
[
i
]
;
const
auto
&
child
=
sorted_graph
.
vertices_
[
r
.
child
]
;
if
(
child
.
is_shared
(
)
)
{
if
(
!
sorted_graph
.
duplicate
(
r
.
parent
r
.
child
)
)
continue
;
return
true
;
}
if
(
child
.
is_leaf
(
)
&
&
!
priority_bumped_parents
.
has
(
r
.
parent
)
)
{
if
(
sorted_graph
.
raise_childrens_priority
(
r
.
parent
)
)
{
priority_bumped_parents
.
add
(
r
.
parent
)
;
resolution_attempted
=
true
;
}
continue
;
}
}
return
resolution_attempted
;
}
template
<
typename
T
>
inline
hb_blob_t
*
hb_resolve_overflows
(
const
T
&
packed
hb_tag_t
table_tag
unsigned
max_rounds
=
20
)
{
graph_t
sorted_graph
(
packed
)
;
sorted_graph
.
sort_shortest_distance
(
)
;
bool
will_overflow
=
graph
:
:
will_overflow
(
sorted_graph
)
;
if
(
!
will_overflow
)
{
return
graph
:
:
serialize
(
sorted_graph
)
;
}
if
(
(
table_tag
=
=
HB_OT_TAG_GPOS
|
|
table_tag
=
=
HB_OT_TAG_GSUB
)
&
&
will_overflow
)
{
DEBUG_MSG
(
SUBSET_REPACK
nullptr
"
Assigning
spaces
to
32
bit
subgraphs
.
"
)
;
if
(
sorted_graph
.
assign_32bit_spaces
(
)
)
sorted_graph
.
sort_shortest_distance
(
)
;
}
unsigned
round
=
0
;
hb_vector_t
<
graph
:
:
overflow_record_t
>
overflows
;
while
(
!
sorted_graph
.
in_error
(
)
&
&
graph
:
:
will_overflow
(
sorted_graph
&
overflows
)
&
&
round
+
+
<
max_rounds
)
{
DEBUG_MSG
(
SUBSET_REPACK
nullptr
"
=
=
=
Overflow
resolution
round
%
d
=
=
=
"
round
)
;
print_overflows
(
sorted_graph
overflows
)
;
hb_set_t
priority_bumped_parents
;
if
(
!
_try_isolating_subgraphs
(
overflows
sorted_graph
)
)
{
if
(
!
_process_overflows
(
overflows
priority_bumped_parents
sorted_graph
)
)
{
DEBUG_MSG
(
SUBSET_REPACK
nullptr
"
No
resolution
available
:
(
"
)
;
break
;
}
}
sorted_graph
.
sort_shortest_distance
(
)
;
}
if
(
sorted_graph
.
in_error
(
)
)
{
DEBUG_MSG
(
SUBSET_REPACK
nullptr
"
Sorted
graph
in
error
state
.
"
)
;
return
nullptr
;
}
if
(
graph
:
:
will_overflow
(
sorted_graph
)
)
{
DEBUG_MSG
(
SUBSET_REPACK
nullptr
"
Offset
overflow
resolution
failed
.
"
)
;
return
nullptr
;
}
return
graph
:
:
serialize
(
sorted_graph
)
;
}
#
endif
