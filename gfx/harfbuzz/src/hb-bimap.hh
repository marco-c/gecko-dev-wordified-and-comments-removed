#
ifndef
HB_BIMAP_HH
#
define
HB_BIMAP_HH
#
include
"
hb
.
hh
"
struct
hb_bimap_t
{
hb_bimap_t
(
)
{
init
(
)
;
}
~
hb_bimap_t
(
)
{
fini
(
)
;
}
void
init
(
)
{
forw_map
.
init
(
)
;
back_map
.
init
(
)
;
}
void
fini
(
)
{
forw_map
.
fini
(
)
;
back_map
.
fini
(
)
;
}
void
reset
(
)
{
forw_map
.
reset
(
)
;
back_map
.
reset
(
)
;
}
bool
in_error
(
)
const
{
return
forw_map
.
in_error
(
)
|
|
back_map
.
in_error
(
)
;
}
void
set
(
hb_codepoint_t
lhs
hb_codepoint_t
rhs
)
{
forw_map
.
set
(
lhs
rhs
)
;
back_map
.
set
(
rhs
lhs
)
;
}
hb_codepoint_t
get
(
hb_codepoint_t
lhs
)
const
{
return
forw_map
.
get
(
lhs
)
;
}
hb_codepoint_t
backward
(
hb_codepoint_t
rhs
)
const
{
return
back_map
.
get
(
rhs
)
;
}
hb_codepoint_t
operator
[
]
(
hb_codepoint_t
lhs
)
const
{
return
get
(
lhs
)
;
}
bool
has
(
hb_codepoint_t
lhs
hb_codepoint_t
*
vp
=
nullptr
)
const
{
return
forw_map
.
has
(
lhs
vp
)
;
}
void
del
(
hb_codepoint_t
lhs
)
{
back_map
.
del
(
get
(
lhs
)
)
;
forw_map
.
del
(
lhs
)
;
}
void
clear
(
)
{
forw_map
.
clear
(
)
;
back_map
.
clear
(
)
;
}
bool
is_empty
(
)
const
{
return
get_population
(
)
=
=
0
;
}
unsigned
int
get_population
(
)
const
{
return
forw_map
.
get_population
(
)
;
}
protected
:
hb_map_t
forw_map
;
hb_map_t
back_map
;
}
;
struct
hb_inc_bimap_t
:
hb_bimap_t
{
hb_codepoint_t
add
(
hb_codepoint_t
lhs
)
{
hb_codepoint_t
rhs
=
forw_map
[
lhs
]
;
if
(
rhs
=
=
HB_MAP_VALUE_INVALID
)
{
rhs
=
get_population
(
)
;
set
(
lhs
rhs
)
;
}
return
rhs
;
}
bool
identity
(
unsigned
int
size
)
{
clear
(
)
;
for
(
hb_codepoint_t
i
=
0
;
i
<
size
;
i
+
+
)
set
(
i
i
)
;
return
!
in_error
(
)
;
}
protected
:
static
int
cmp_id
(
const
void
*
a
const
void
*
b
)
{
return
(
int
)
*
(
const
hb_codepoint_t
*
)
a
-
(
int
)
*
(
const
hb_codepoint_t
*
)
b
;
}
public
:
void
sort
(
)
{
hb_codepoint_t
count
=
get_population
(
)
;
hb_vector_t
<
hb_codepoint_t
>
work
;
work
.
resize
(
count
)
;
for
(
hb_codepoint_t
rhs
=
0
;
rhs
<
count
;
rhs
+
+
)
work
[
rhs
]
=
back_map
[
rhs
]
;
work
.
qsort
(
cmp_id
)
;
for
(
hb_codepoint_t
rhs
=
0
;
rhs
<
count
;
rhs
+
+
)
set
(
work
[
rhs
]
rhs
)
;
}
}
;
#
endif
