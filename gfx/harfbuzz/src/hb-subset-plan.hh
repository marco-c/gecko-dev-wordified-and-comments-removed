#
ifndef
HB_SUBSET_PLAN_HH
#
define
HB_SUBSET_PLAN_HH
#
include
"
hb
.
hh
"
#
include
"
hb
-
subset
.
h
"
#
include
"
hb
-
subset
-
input
.
hh
"
#
include
"
hb
-
subset
-
accelerator
.
hh
"
#
include
"
hb
-
map
.
hh
"
#
include
"
hb
-
bimap
.
hh
"
#
include
"
hb
-
set
.
hh
"
namespace
OT
{
struct
Feature
;
}
struct
os2_info_t
{
hb_codepoint_t
min_cmap_codepoint
;
hb_codepoint_t
max_cmap_codepoint
;
}
;
typedef
struct
os2_info_t
os2_info_t
;
struct
head_maxp_info_t
{
head_maxp_info_t
(
)
:
xMin
(
0x7FFF
)
xMax
(
-
0x7FFF
)
yMin
(
0x7FFF
)
yMax
(
-
0x7FFF
)
maxPoints
(
0
)
maxContours
(
0
)
maxCompositePoints
(
0
)
maxCompositeContours
(
0
)
maxComponentElements
(
0
)
maxComponentDepth
(
0
)
allXMinIsLsb
(
true
)
{
}
int
xMin
;
int
xMax
;
int
yMin
;
int
yMax
;
unsigned
maxPoints
;
unsigned
maxContours
;
unsigned
maxCompositePoints
;
unsigned
maxCompositeContours
;
unsigned
maxComponentElements
;
unsigned
maxComponentDepth
;
bool
allXMinIsLsb
;
}
;
typedef
struct
head_maxp_info_t
head_maxp_info_t
;
struct
contour_point_t
{
void
init
(
float
x_
=
0
.
f
float
y_
=
0
.
f
bool
is_end_point_
=
false
)
{
flag
=
0
;
x
=
x_
;
y
=
y_
;
is_end_point
=
is_end_point_
;
}
void
transform
(
const
float
(
&
matrix
)
[
4
]
)
{
float
x_
=
x
*
matrix
[
0
]
+
y
*
matrix
[
2
]
;
y
=
x
*
matrix
[
1
]
+
y
*
matrix
[
3
]
;
x
=
x_
;
}
void
add_delta
(
float
delta_x
float
delta_y
)
{
x
+
=
delta_x
;
y
+
=
delta_y
;
}
HB_ALWAYS_INLINE
void
translate
(
const
contour_point_t
&
p
)
{
x
+
=
p
.
x
;
y
+
=
p
.
y
;
}
float
x
;
float
y
;
uint8_t
flag
;
bool
is_end_point
;
}
;
struct
contour_point_vector_t
:
hb_vector_t
<
contour_point_t
>
{
bool
add_deltas
(
hb_array_t
<
const
float
>
deltas_x
hb_array_t
<
const
float
>
deltas_y
hb_array_t
<
const
bool
>
indices
)
{
if
(
indices
.
length
!
=
deltas_x
.
length
|
|
indices
.
length
!
=
deltas_y
.
length
)
return
false
;
for
(
unsigned
i
=
0
;
i
<
indices
.
length
;
i
+
+
)
{
if
(
!
indices
.
arrayZ
[
i
]
)
continue
;
arrayZ
[
i
]
.
add_delta
(
deltas_x
.
arrayZ
[
i
]
deltas_y
.
arrayZ
[
i
]
)
;
}
return
true
;
}
}
;
namespace
OT
{
struct
cff1_subset_accelerator_t
;
struct
cff2_subset_accelerator_t
;
}
struct
hb_subset_plan_t
{
HB_INTERNAL
hb_subset_plan_t
(
hb_face_t
*
const
hb_subset_input_t
*
input
)
;
HB_INTERNAL
~
hb_subset_plan_t
(
)
;
hb_object_header_t
header
;
bool
successful
;
unsigned
flags
;
bool
attach_accelerator_data
=
false
;
bool
force_long_loca
=
false
;
hb_map_t
*
codepoint_to_glyph
;
hb_map_t
*
glyph_map
;
hb_map_t
*
reverse_glyph_map
;
hb_face_t
*
source
;
#
ifndef
HB_NO_SUBSET_CFF
hb_face_lazy_loader_t
<
OT
:
:
cff1_subset_accelerator_t
1
>
cff1_accel
;
hb_face_lazy_loader_t
<
OT
:
:
cff2_subset_accelerator_t
2
>
cff2_accel
;
#
endif
hb_face_t
*
dest
;
unsigned
int
_num_output_glyphs
;
bool
all_axes_pinned
;
bool
pinned_at_default
;
bool
has_seac
;
bool
gsub_insert_catch_all_feature_variation_rec
;
bool
gpos_insert_catch_all_feature_variation_rec
;
mutable
bool
has_gdef_varstore
;
#
define
HB_SUBSET_PLAN_MEMBER
(
Type
Name
)
Type
Name
;
#
include
"
hb
-
subset
-
plan
-
member
-
list
.
hh
"
#
undef
HB_SUBSET_PLAN_MEMBER
mutable
head_maxp_info_t
head_maxp_info
;
os2_info_t
os2_info
;
const
hb_subset_accelerator_t
*
accelerator
;
hb_subset_accelerator_t
*
inprogress_accelerator
;
public
:
template
<
typename
T
>
struct
source_table_loader
{
hb_blob_ptr_t
<
T
>
operator
(
)
(
hb_subset_plan_t
*
plan
)
{
hb_lock_t
lock
(
plan
-
>
accelerator
?
&
plan
-
>
accelerator
-
>
sanitized_table_cache_lock
:
nullptr
)
;
auto
*
cache
=
plan
-
>
accelerator
?
&
plan
-
>
accelerator
-
>
sanitized_table_cache
:
&
plan
-
>
sanitized_table_cache
;
if
(
cache
&
&
!
cache
-
>
in_error
(
)
&
&
cache
-
>
has
(
+
T
:
:
tableTag
)
)
{
return
hb_blob_reference
(
cache
-
>
get
(
+
T
:
:
tableTag
)
.
get
(
)
)
;
}
hb
:
:
unique_ptr
<
hb_blob_t
>
table_blob
{
hb_sanitize_context_t
(
)
.
reference_table
<
T
>
(
plan
-
>
source
)
}
;
hb_blob_t
*
ret
=
hb_blob_reference
(
table_blob
.
get
(
)
)
;
if
(
likely
(
cache
)
)
cache
-
>
set
(
+
T
:
:
tableTag
std
:
:
move
(
table_blob
)
)
;
return
ret
;
}
}
;
template
<
typename
T
>
auto
source_table
(
)
HB_AUTO_RETURN
(
source_table_loader
<
T
>
{
}
(
this
)
)
bool
in_error
(
)
const
{
return
!
successful
;
}
bool
check_success
(
bool
success
)
{
successful
=
(
successful
&
&
success
)
;
return
successful
;
}
inline
const
hb_set_t
*
glyphset
(
)
const
{
return
&
_glyphset
;
}
inline
const
hb_set_t
*
glyphset_gsub
(
)
const
{
return
&
_glyphset_gsub
;
}
inline
unsigned
int
num_output_glyphs
(
)
const
{
return
_num_output_glyphs
;
}
inline
bool
new_gid_for_codepoint
(
hb_codepoint_t
codepoint
hb_codepoint_t
*
new_gid
)
const
{
hb_codepoint_t
old_gid
=
codepoint_to_glyph
-
>
get
(
codepoint
)
;
if
(
old_gid
=
=
HB_MAP_VALUE_INVALID
)
return
false
;
return
new_gid_for_old_gid
(
old_gid
new_gid
)
;
}
inline
bool
new_gid_for_old_gid
(
hb_codepoint_t
old_gid
hb_codepoint_t
*
new_gid
)
const
{
hb_codepoint_t
gid
=
glyph_map
-
>
get
(
old_gid
)
;
if
(
gid
=
=
HB_MAP_VALUE_INVALID
)
return
false
;
*
new_gid
=
gid
;
return
true
;
}
inline
bool
old_gid_for_new_gid
(
hb_codepoint_t
new_gid
hb_codepoint_t
*
old_gid
)
const
{
hb_codepoint_t
gid
=
reverse_glyph_map
-
>
get
(
new_gid
)
;
if
(
gid
=
=
HB_MAP_VALUE_INVALID
)
return
false
;
*
old_gid
=
gid
;
return
true
;
}
inline
bool
add_table
(
hb_tag_t
tag
hb_blob_t
*
contents
)
{
if
(
HB_DEBUG_SUBSET
)
{
hb_blob_t
*
source_blob
=
source
-
>
reference_table
(
tag
)
;
DEBUG_MSG
(
SUBSET
nullptr
"
add
table
%
c
%
c
%
c
%
c
dest
%
u
bytes
source
%
u
bytes
"
HB_UNTAG
(
tag
)
hb_blob_get_length
(
contents
)
hb_blob_get_length
(
source_blob
)
)
;
hb_blob_destroy
(
source_blob
)
;
}
return
hb_face_builder_add_table
(
dest
tag
contents
)
;
}
}
;
#
endif
