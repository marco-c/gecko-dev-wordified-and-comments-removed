#
ifndef
HB_SUBSET_PLAN_HH
#
define
HB_SUBSET_PLAN_HH
#
include
"
hb
.
hh
"
#
include
"
hb
-
subset
.
h
"
#
include
"
hb
-
subset
-
input
.
hh
"
#
include
"
hb
-
map
.
hh
"
#
include
"
hb
-
set
.
hh
"
struct
hb_subset_plan_t
{
hb_object_header_t
header
;
bool
successful
;
unsigned
flags
;
hb_set_t
*
unicodes
;
hb_set_t
*
name_ids
;
hb_set_t
*
name_languages
;
hb_set_t
*
layout_features
;
hb_set_t
*
glyphs_requested
;
hb_set_t
*
no_subset_tables
;
hb_set_t
*
drop_tables
;
hb_map_t
*
codepoint_to_glyph
;
hb_map_t
*
glyph_map
;
hb_map_t
*
reverse_glyph_map
;
hb_face_t
*
source
;
hb_face_t
*
dest
;
unsigned
int
_num_output_glyphs
;
hb_set_t
*
_glyphset
;
hb_set_t
*
_glyphset_gsub
;
hb_map_t
*
gsub_lookups
;
hb_map_t
*
gpos_lookups
;
hb_hashmap_t
<
unsigned
hb_set_t
*
(
unsigned
)
-
1
nullptr
>
*
gsub_langsys
;
hb_hashmap_t
<
unsigned
hb_set_t
*
(
unsigned
)
-
1
nullptr
>
*
gpos_langsys
;
hb_map_t
*
gsub_features
;
hb_map_t
*
gpos_features
;
hb_map_t
*
colrv1_layers
;
hb_map_t
*
colr_palettes
;
hb_set_t
*
layout_variation_indices
;
hb_map_t
*
layout_variation_idx_map
;
public
:
bool
in_error
(
)
const
{
return
!
successful
;
}
bool
check_success
(
bool
success
)
{
successful
=
(
successful
&
&
success
)
;
return
successful
;
}
inline
const
hb_set_t
*
glyphset
(
)
const
{
return
_glyphset
;
}
inline
const
hb_set_t
*
glyphset_gsub
(
)
const
{
return
_glyphset_gsub
;
}
inline
unsigned
int
num_output_glyphs
(
)
const
{
return
_num_output_glyphs
;
}
inline
bool
is_empty_glyph
(
hb_codepoint_t
gid
)
const
{
return
!
_glyphset
-
>
has
(
gid
)
;
}
inline
bool
new_gid_for_codepoint
(
hb_codepoint_t
codepoint
hb_codepoint_t
*
new_gid
)
const
{
hb_codepoint_t
old_gid
=
codepoint_to_glyph
-
>
get
(
codepoint
)
;
if
(
old_gid
=
=
HB_MAP_VALUE_INVALID
)
return
false
;
return
new_gid_for_old_gid
(
old_gid
new_gid
)
;
}
inline
bool
new_gid_for_old_gid
(
hb_codepoint_t
old_gid
hb_codepoint_t
*
new_gid
)
const
{
hb_codepoint_t
gid
=
glyph_map
-
>
get
(
old_gid
)
;
if
(
gid
=
=
HB_MAP_VALUE_INVALID
)
return
false
;
*
new_gid
=
gid
;
return
true
;
}
inline
bool
old_gid_for_new_gid
(
hb_codepoint_t
new_gid
hb_codepoint_t
*
old_gid
)
const
{
hb_codepoint_t
gid
=
reverse_glyph_map
-
>
get
(
new_gid
)
;
if
(
gid
=
=
HB_MAP_VALUE_INVALID
)
return
false
;
*
old_gid
=
gid
;
return
true
;
}
inline
bool
add_table
(
hb_tag_t
tag
hb_blob_t
*
contents
)
{
if
(
HB_DEBUG_SUBSET
)
{
hb_blob_t
*
source_blob
=
source
-
>
reference_table
(
tag
)
;
DEBUG_MSG
(
SUBSET
nullptr
"
add
table
%
c
%
c
%
c
%
c
dest
%
d
bytes
source
%
d
bytes
"
HB_UNTAG
(
tag
)
hb_blob_get_length
(
contents
)
hb_blob_get_length
(
source_blob
)
)
;
hb_blob_destroy
(
source_blob
)
;
}
return
hb_face_builder_add_table
(
dest
tag
contents
)
;
}
}
;
typedef
struct
hb_subset_plan_t
hb_subset_plan_t
;
HB_INTERNAL
hb_subset_plan_t
*
hb_subset_plan_create
(
hb_face_t
*
face
const
hb_subset_input_t
*
input
)
;
HB_INTERNAL
void
hb_subset_plan_destroy
(
hb_subset_plan_t
*
plan
)
;
#
endif
