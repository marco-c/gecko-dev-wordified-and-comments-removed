#
ifndef
HB_OPEN_TYPE_HH
#
define
HB_OPEN_TYPE_HH
#
include
"
hb
.
hh
"
#
include
"
hb
-
blob
.
hh
"
#
include
"
hb
-
face
.
hh
"
#
include
"
hb
-
machinery
.
hh
"
#
include
"
hb
-
subset
.
hh
"
namespace
OT
{
template
<
typename
Type
unsigned
int
Size
>
struct
IntType
{
typedef
Type
type
;
typedef
hb_conditional
<
hb_is_signed
(
Type
)
signed
unsigned
>
wide_type
;
IntType
&
operator
=
(
wide_type
i
)
{
v
=
i
;
return
*
this
;
}
operator
wide_type
(
)
const
{
return
v
;
}
bool
operator
=
=
(
const
IntType
&
o
)
const
{
return
(
Type
)
v
=
=
(
Type
)
o
.
v
;
}
bool
operator
!
=
(
const
IntType
&
o
)
const
{
return
!
(
*
this
=
=
o
)
;
}
HB_INTERNAL
static
int
cmp
(
const
IntType
*
a
const
IntType
*
b
)
{
return
b
-
>
cmp
(
*
a
)
;
}
template
<
typename
Type2
>
int
cmp
(
Type2
a
)
const
{
Type
b
=
v
;
if
(
sizeof
(
Type
)
<
sizeof
(
int
)
&
&
sizeof
(
Type2
)
<
sizeof
(
int
)
)
return
(
int
)
a
-
(
int
)
b
;
else
return
a
<
b
?
-
1
:
a
=
=
b
?
0
:
+
1
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
)
)
;
}
protected
:
BEInt
<
Type
Size
>
v
;
public
:
DEFINE_SIZE_STATIC
(
Size
)
;
}
;
typedef
IntType
<
uint8_t
1
>
HBUINT8
;
typedef
IntType
<
int8_t
1
>
HBINT8
;
typedef
IntType
<
uint16_t
2
>
HBUINT16
;
typedef
IntType
<
int16_t
2
>
HBINT16
;
typedef
IntType
<
uint32_t
4
>
HBUINT32
;
typedef
IntType
<
int32_t
4
>
HBINT32
;
typedef
IntType
<
uint32_t
3
>
HBUINT24
;
typedef
HBINT16
FWORD
;
typedef
HBINT32
FWORD32
;
typedef
HBUINT16
UFWORD
;
struct
F2DOT14
:
HBINT16
{
F2DOT14
&
operator
=
(
uint16_t
i
)
{
HBINT16
:
:
operator
=
(
i
)
;
return
*
this
;
}
float
to_float
(
)
const
{
return
(
(
int32_t
)
v
)
/
16384
.
f
;
}
void
set_float
(
float
f
)
{
v
=
roundf
(
f
*
16384
.
f
)
;
}
public
:
DEFINE_SIZE_STATIC
(
2
)
;
}
;
struct
Fixed
:
HBINT32
{
Fixed
&
operator
=
(
uint32_t
i
)
{
HBINT32
:
:
operator
=
(
i
)
;
return
*
this
;
}
float
to_float
(
)
const
{
return
(
(
int32_t
)
v
)
/
65536
.
f
;
}
void
set_float
(
float
f
)
{
v
=
roundf
(
f
*
65536
.
f
)
;
}
public
:
DEFINE_SIZE_STATIC
(
4
)
;
}
;
struct
LONGDATETIME
{
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
)
)
;
}
protected
:
HBINT32
major
;
HBUINT32
minor
;
public
:
DEFINE_SIZE_STATIC
(
8
)
;
}
;
struct
Tag
:
HBUINT32
{
Tag
&
operator
=
(
hb_tag_t
i
)
{
HBUINT32
:
:
operator
=
(
i
)
;
return
*
this
;
}
operator
const
char
*
(
)
const
{
return
reinterpret_cast
<
const
char
*
>
(
&
this
-
>
v
)
;
}
operator
char
*
(
)
{
return
reinterpret_cast
<
char
*
>
(
&
this
-
>
v
)
;
}
public
:
DEFINE_SIZE_STATIC
(
4
)
;
}
;
struct
GlyphID
:
HBUINT16
{
GlyphID
&
operator
=
(
uint16_t
i
)
{
HBUINT16
:
:
operator
=
(
i
)
;
return
*
this
;
}
}
;
struct
Index
:
HBUINT16
{
static
constexpr
unsigned
NOT_FOUND_INDEX
=
0xFFFFu
;
Index
&
operator
=
(
uint16_t
i
)
{
HBUINT16
:
:
operator
=
(
i
)
;
return
*
this
;
}
}
;
DECLARE_NULL_NAMESPACE_BYTES
(
OT
Index
)
;
typedef
Index
NameID
;
template
<
typename
Type
bool
has_null
=
true
>
struct
Offset
:
Type
{
Offset
&
operator
=
(
typename
Type
:
:
type
i
)
{
Type
:
:
operator
=
(
i
)
;
return
*
this
;
}
typedef
Type
type
;
bool
is_null
(
)
const
{
return
has_null
&
&
0
=
=
*
this
;
}
void
*
serialize
(
hb_serialize_context_t
*
c
const
void
*
base
)
{
void
*
t
=
c
-
>
start_embed
<
void
>
(
)
;
c
-
>
check_assign
(
*
this
(
unsigned
)
(
(
char
*
)
t
-
(
char
*
)
base
)
)
;
return
t
;
}
public
:
DEFINE_SIZE_STATIC
(
sizeof
(
Type
)
)
;
}
;
typedef
Offset
<
HBUINT16
>
Offset16
;
typedef
Offset
<
HBUINT32
>
Offset32
;
struct
CheckSum
:
HBUINT32
{
CheckSum
&
operator
=
(
uint32_t
i
)
{
HBUINT32
:
:
operator
=
(
i
)
;
return
*
this
;
}
static
uint32_t
CalcTableChecksum
(
const
HBUINT32
*
Table
uint32_t
Length
)
{
uint32_t
Sum
=
0L
;
assert
(
0
=
=
(
Length
&
3
)
)
;
const
HBUINT32
*
EndPtr
=
Table
+
Length
/
HBUINT32
:
:
static_size
;
while
(
Table
<
EndPtr
)
Sum
+
=
*
Table
+
+
;
return
Sum
;
}
void
set_for_data
(
const
void
*
data
unsigned
int
length
)
{
*
this
=
CalcTableChecksum
(
(
const
HBUINT32
*
)
data
length
)
;
}
public
:
DEFINE_SIZE_STATIC
(
4
)
;
}
;
template
<
typename
FixedType
=
HBUINT16
>
struct
FixedVersion
{
uint32_t
to_int
(
)
const
{
return
(
major
<
<
(
sizeof
(
FixedType
)
*
8
)
)
+
minor
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
FixedType
major
;
FixedType
minor
;
public
:
DEFINE_SIZE_STATIC
(
2
*
sizeof
(
FixedType
)
)
;
}
;
template
<
typename
Type
bool
has_null
>
struct
_hb_has_null
{
static
const
Type
*
get_null
(
)
{
return
nullptr
;
}
static
Type
*
get_crap
(
)
{
return
nullptr
;
}
}
;
template
<
typename
Type
>
struct
_hb_has_null
<
Type
true
>
{
static
const
Type
*
get_null
(
)
{
return
&
Null
(
Type
)
;
}
static
Type
*
get_crap
(
)
{
return
&
Crap
(
Type
)
;
}
}
;
template
<
typename
Type
typename
OffsetType
=
HBUINT16
bool
has_null
=
true
>
struct
OffsetTo
:
Offset
<
OffsetType
has_null
>
{
HB_DELETE_COPY_ASSIGN
(
OffsetTo
)
;
OffsetTo
(
)
=
default
;
OffsetTo
&
operator
=
(
typename
OffsetType
:
:
type
i
)
{
OffsetType
:
:
operator
=
(
i
)
;
return
*
this
;
}
const
Type
&
operator
(
)
(
const
void
*
base
)
const
{
if
(
unlikely
(
this
-
>
is_null
(
)
)
)
return
*
_hb_has_null
<
Type
has_null
>
:
:
get_null
(
)
;
return
StructAtOffset
<
const
Type
>
(
base
*
this
)
;
}
Type
&
operator
(
)
(
void
*
base
)
const
{
if
(
unlikely
(
this
-
>
is_null
(
)
)
)
return
*
_hb_has_null
<
Type
has_null
>
:
:
get_crap
(
)
;
return
StructAtOffset
<
Type
>
(
base
*
this
)
;
}
template
<
typename
Base
hb_enable_if
(
hb_is_convertible
(
const
Base
const
void
*
)
)
>
friend
const
Type
&
operator
+
(
const
Base
&
base
const
OffsetTo
&
offset
)
{
return
offset
(
(
const
void
*
)
base
)
;
}
template
<
typename
Base
hb_enable_if
(
hb_is_convertible
(
const
Base
const
void
*
)
)
>
friend
const
Type
&
operator
+
(
const
OffsetTo
&
offset
const
Base
&
base
)
{
return
offset
(
(
const
void
*
)
base
)
;
}
template
<
typename
Base
hb_enable_if
(
hb_is_convertible
(
Base
void
*
)
)
>
friend
Type
&
operator
+
(
Base
&
&
base
OffsetTo
&
offset
)
{
return
offset
(
(
void
*
)
base
)
;
}
template
<
typename
Base
hb_enable_if
(
hb_is_convertible
(
Base
void
*
)
)
>
friend
Type
&
operator
+
(
OffsetTo
&
offset
Base
&
&
base
)
{
return
offset
(
(
void
*
)
base
)
;
}
Type
&
serialize
(
hb_serialize_context_t
*
c
const
void
*
base
)
{
return
*
(
Type
*
)
Offset
<
OffsetType
>
:
:
serialize
(
c
base
)
;
}
template
<
typename
.
.
.
Ts
>
bool
serialize_subset
(
hb_subset_context_t
*
c
const
OffsetTo
&
src
const
void
*
src_base
const
void
*
dst_base
Ts
&
&
.
.
.
ds
)
{
*
this
=
0
;
if
(
src
.
is_null
(
)
)
return
false
;
auto
*
s
=
c
-
>
serializer
;
s
-
>
push
(
)
;
bool
ret
=
c
-
>
dispatch
(
src_base
+
src
hb_forward
<
Ts
>
(
ds
)
.
.
.
)
;
if
(
ret
|
|
!
has_null
)
s
-
>
add_link
(
*
this
s
-
>
pop_pack
(
)
dst_base
)
;
else
s
-
>
pop_discard
(
)
;
return
ret
;
}
template
<
typename
.
.
.
Ts
>
bool
serialize_copy
(
hb_serialize_context_t
*
c
const
OffsetTo
&
src
const
void
*
src_base
const
void
*
dst_base
Ts
&
&
.
.
.
ds
)
{
*
this
=
0
;
if
(
src
.
is_null
(
)
)
return
false
;
c
-
>
push
(
)
;
bool
ret
=
c
-
>
copy
(
src_base
+
src
hb_forward
<
Ts
>
(
ds
)
.
.
.
)
;
c
-
>
add_link
(
*
this
c
-
>
pop_pack
(
)
dst_base
)
;
return
ret
;
}
bool
sanitize_shallow
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
c
-
>
check_struct
(
this
)
)
)
return_trace
(
false
)
;
if
(
unlikely
(
this
-
>
is_null
(
)
)
)
return_trace
(
true
)
;
if
(
unlikely
(
!
c
-
>
check_range
(
base
*
this
)
)
)
return_trace
(
false
)
;
return_trace
(
true
)
;
}
template
<
typename
.
.
.
Ts
>
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
Ts
&
&
.
.
.
ds
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
sanitize_shallow
(
c
base
)
&
&
(
this
-
>
is_null
(
)
|
|
c
-
>
dispatch
(
StructAtOffset
<
Type
>
(
base
*
this
)
hb_forward
<
Ts
>
(
ds
)
.
.
.
)
|
|
neuter
(
c
)
)
)
;
}
bool
neuter
(
hb_sanitize_context_t
*
c
)
const
{
if
(
!
has_null
)
return
false
;
return
c
-
>
try_set
(
this
0
)
;
}
DEFINE_SIZE_STATIC
(
sizeof
(
OffsetType
)
)
;
}
;
template
<
typename
Type
bool
has_null
=
true
>
using
LOffsetTo
=
OffsetTo
<
Type
HBUINT32
has_null
>
;
template
<
typename
Type
typename
OffsetType
=
HBUINT16
>
using
NNOffsetTo
=
OffsetTo
<
Type
OffsetType
false
>
;
template
<
typename
Type
>
using
LNNOffsetTo
=
LOffsetTo
<
Type
false
>
;
template
<
typename
Type
>
struct
UnsizedArrayOf
{
typedef
Type
item_t
;
static
constexpr
unsigned
item_size
=
hb_static_size
(
Type
)
;
HB_DELETE_CREATE_COPY_ASSIGN
(
UnsizedArrayOf
)
;
const
Type
&
operator
[
]
(
int
i_
)
const
{
unsigned
int
i
=
(
unsigned
int
)
i_
;
const
Type
*
p
=
&
arrayZ
[
i
]
;
if
(
unlikely
(
p
<
arrayZ
)
)
return
Null
(
Type
)
;
return
*
p
;
}
Type
&
operator
[
]
(
int
i_
)
{
unsigned
int
i
=
(
unsigned
int
)
i_
;
Type
*
p
=
&
arrayZ
[
i
]
;
if
(
unlikely
(
p
<
arrayZ
)
)
return
Crap
(
Type
)
;
return
*
p
;
}
unsigned
int
get_size
(
unsigned
int
len
)
const
{
return
len
*
Type
:
:
static_size
;
}
template
<
typename
T
>
operator
T
*
(
)
{
return
arrayZ
;
}
template
<
typename
T
>
operator
const
T
*
(
)
const
{
return
arrayZ
;
}
hb_array_t
<
Type
>
as_array
(
unsigned
int
len
)
{
return
hb_array
(
arrayZ
len
)
;
}
hb_array_t
<
const
Type
>
as_array
(
unsigned
int
len
)
const
{
return
hb_array
(
arrayZ
len
)
;
}
operator
hb_array_t
<
Type
>
(
)
{
return
as_array
(
)
;
}
operator
hb_array_t
<
const
Type
>
(
)
const
{
return
as_array
(
)
;
}
template
<
typename
T
>
Type
&
lsearch
(
unsigned
int
len
const
T
&
x
Type
&
not_found
=
Crap
(
Type
)
)
{
return
*
as_array
(
len
)
.
lsearch
(
x
&
not_found
)
;
}
template
<
typename
T
>
const
Type
&
lsearch
(
unsigned
int
len
const
T
&
x
const
Type
&
not_found
=
Null
(
Type
)
)
const
{
return
*
as_array
(
len
)
.
lsearch
(
x
&
not_found
)
;
}
void
qsort
(
unsigned
int
len
unsigned
int
start
=
0
unsigned
int
end
=
(
unsigned
int
)
-
1
)
{
as_array
(
len
)
.
qsort
(
start
end
)
;
}
bool
serialize
(
hb_serialize_context_t
*
c
unsigned
int
items_len
)
{
TRACE_SERIALIZE
(
this
)
;
if
(
unlikely
(
!
c
-
>
extend
(
*
this
items_len
)
)
)
return_trace
(
false
)
;
return_trace
(
true
)
;
}
template
<
typename
Iterator
hb_requires
(
hb_is_source_of
(
Iterator
Type
)
)
>
bool
serialize
(
hb_serialize_context_t
*
c
Iterator
items
)
{
TRACE_SERIALIZE
(
this
)
;
unsigned
count
=
items
.
len
(
)
;
if
(
unlikely
(
!
serialize
(
c
count
)
)
)
return_trace
(
false
)
;
for
(
unsigned
i
=
0
;
i
<
count
;
i
+
+
+
+
items
)
arrayZ
[
i
]
=
*
items
;
return_trace
(
true
)
;
}
UnsizedArrayOf
*
copy
(
hb_serialize_context_t
*
c
unsigned
count
)
const
{
TRACE_SERIALIZE
(
this
)
;
auto
*
out
=
c
-
>
start_embed
(
this
)
;
if
(
unlikely
(
!
as_array
(
count
)
.
copy
(
c
)
)
)
return_trace
(
nullptr
)
;
return_trace
(
out
)
;
}
template
<
typename
.
.
.
Ts
>
bool
sanitize
(
hb_sanitize_context_t
*
c
unsigned
int
count
Ts
&
&
.
.
.
ds
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
sanitize_shallow
(
c
count
)
)
)
return_trace
(
false
)
;
if
(
!
sizeof
.
.
.
(
Ts
)
&
&
hb_is_trivially_copyable
(
Type
)
)
return_trace
(
true
)
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
if
(
unlikely
(
!
c
-
>
dispatch
(
arrayZ
[
i
]
hb_forward
<
Ts
>
(
ds
)
.
.
.
)
)
)
return_trace
(
false
)
;
return_trace
(
true
)
;
}
bool
sanitize_shallow
(
hb_sanitize_context_t
*
c
unsigned
int
count
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_array
(
arrayZ
count
)
)
;
}
public
:
Type
arrayZ
[
VAR
]
;
public
:
DEFINE_SIZE_UNBOUNDED
(
0
)
;
}
;
template
<
typename
Type
typename
OffsetType
bool
has_null
=
true
>
using
UnsizedOffsetArrayOf
=
UnsizedArrayOf
<
OffsetTo
<
Type
OffsetType
has_null
>
>
;
template
<
typename
Type
typename
OffsetType
bool
has_null
=
true
>
struct
UnsizedOffsetListOf
:
UnsizedOffsetArrayOf
<
Type
OffsetType
has_null
>
{
const
Type
&
operator
[
]
(
int
i_
)
const
{
unsigned
int
i
=
(
unsigned
int
)
i_
;
const
OffsetTo
<
Type
OffsetType
has_null
>
*
p
=
&
this
-
>
arrayZ
[
i
]
;
if
(
unlikely
(
p
<
this
-
>
arrayZ
)
)
return
Null
(
Type
)
;
return
this
+
*
p
;
}
Type
&
operator
[
]
(
int
i_
)
{
unsigned
int
i
=
(
unsigned
int
)
i_
;
const
OffsetTo
<
Type
OffsetType
has_null
>
*
p
=
&
this
-
>
arrayZ
[
i
]
;
if
(
unlikely
(
p
<
this
-
>
arrayZ
)
)
return
Crap
(
Type
)
;
return
this
+
*
p
;
}
template
<
typename
.
.
.
Ts
>
bool
sanitize
(
hb_sanitize_context_t
*
c
unsigned
int
count
Ts
&
&
.
.
.
ds
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
(
UnsizedOffsetArrayOf
<
Type
OffsetType
has_null
>
:
:
sanitize
(
c
count
this
hb_forward
<
Ts
>
(
ds
)
.
.
.
)
)
)
;
}
}
;
template
<
typename
Type
>
struct
SortedUnsizedArrayOf
:
UnsizedArrayOf
<
Type
>
{
hb_sorted_array_t
<
Type
>
as_array
(
unsigned
int
len
)
{
return
hb_sorted_array
(
this
-
>
arrayZ
len
)
;
}
hb_sorted_array_t
<
const
Type
>
as_array
(
unsigned
int
len
)
const
{
return
hb_sorted_array
(
this
-
>
arrayZ
len
)
;
}
operator
hb_sorted_array_t
<
Type
>
(
)
{
return
as_array
(
)
;
}
operator
hb_sorted_array_t
<
const
Type
>
(
)
const
{
return
as_array
(
)
;
}
template
<
typename
T
>
Type
&
bsearch
(
unsigned
int
len
const
T
&
x
Type
&
not_found
=
Crap
(
Type
)
)
{
return
*
as_array
(
len
)
.
bsearch
(
x
&
not_found
)
;
}
template
<
typename
T
>
const
Type
&
bsearch
(
unsigned
int
len
const
T
&
x
const
Type
&
not_found
=
Null
(
Type
)
)
const
{
return
*
as_array
(
len
)
.
bsearch
(
x
&
not_found
)
;
}
template
<
typename
T
>
bool
bfind
(
unsigned
int
len
const
T
&
x
unsigned
int
*
i
=
nullptr
hb_bfind_not_found_t
not_found
=
HB_BFIND_NOT_FOUND_DONT_STORE
unsigned
int
to_store
=
(
unsigned
int
)
-
1
)
const
{
return
as_array
(
len
)
.
bfind
(
x
i
not_found
to_store
)
;
}
}
;
template
<
typename
Type
typename
LenType
=
HBUINT16
>
struct
ArrayOf
{
typedef
Type
item_t
;
static
constexpr
unsigned
item_size
=
hb_static_size
(
Type
)
;
HB_DELETE_CREATE_COPY_ASSIGN
(
ArrayOf
)
;
const
Type
&
operator
[
]
(
int
i_
)
const
{
unsigned
int
i
=
(
unsigned
int
)
i_
;
if
(
unlikely
(
i
>
=
len
)
)
return
Null
(
Type
)
;
return
arrayZ
[
i
]
;
}
Type
&
operator
[
]
(
int
i_
)
{
unsigned
int
i
=
(
unsigned
int
)
i_
;
if
(
unlikely
(
i
>
=
len
)
)
return
Crap
(
Type
)
;
return
arrayZ
[
i
]
;
}
unsigned
int
get_size
(
)
const
{
return
len
.
static_size
+
len
*
Type
:
:
static_size
;
}
explicit
operator
bool
(
)
const
{
return
len
;
}
hb_array_t
<
Type
>
as_array
(
)
{
return
hb_array
(
arrayZ
len
)
;
}
hb_array_t
<
const
Type
>
as_array
(
)
const
{
return
hb_array
(
arrayZ
len
)
;
}
typedef
hb_array_t
<
const
Type
>
iter_t
;
typedef
hb_array_t
<
Type
>
writer_t
;
iter_t
iter
(
)
const
{
return
as_array
(
)
;
}
writer_t
writer
(
)
{
return
as_array
(
)
;
}
operator
iter_t
(
)
const
{
return
iter
(
)
;
}
operator
writer_t
(
)
{
return
writer
(
)
;
}
hb_array_t
<
const
Type
>
sub_array
(
unsigned
int
start_offset
unsigned
int
count
)
const
{
return
as_array
(
)
.
sub_array
(
start_offset
count
)
;
}
hb_array_t
<
const
Type
>
sub_array
(
unsigned
int
start_offset
unsigned
int
*
count
=
nullptr
)
const
{
return
as_array
(
)
.
sub_array
(
start_offset
count
)
;
}
hb_array_t
<
Type
>
sub_array
(
unsigned
int
start_offset
unsigned
int
count
)
{
return
as_array
(
)
.
sub_array
(
start_offset
count
)
;
}
hb_array_t
<
Type
>
sub_array
(
unsigned
int
start_offset
unsigned
int
*
count
=
nullptr
)
{
return
as_array
(
)
.
sub_array
(
start_offset
count
)
;
}
bool
serialize
(
hb_serialize_context_t
*
c
unsigned
int
items_len
)
{
TRACE_SERIALIZE
(
this
)
;
if
(
unlikely
(
!
c
-
>
extend_min
(
*
this
)
)
)
return_trace
(
false
)
;
c
-
>
check_assign
(
len
items_len
)
;
if
(
unlikely
(
!
c
-
>
extend
(
*
this
)
)
)
return_trace
(
false
)
;
return_trace
(
true
)
;
}
template
<
typename
Iterator
hb_requires
(
hb_is_source_of
(
Iterator
Type
)
)
>
bool
serialize
(
hb_serialize_context_t
*
c
Iterator
items
)
{
TRACE_SERIALIZE
(
this
)
;
unsigned
count
=
items
.
len
(
)
;
if
(
unlikely
(
!
serialize
(
c
count
)
)
)
return_trace
(
false
)
;
for
(
unsigned
i
=
0
;
i
<
count
;
i
+
+
+
+
items
)
arrayZ
[
i
]
=
*
items
;
return_trace
(
true
)
;
}
ArrayOf
*
copy
(
hb_serialize_context_t
*
c
)
const
{
TRACE_SERIALIZE
(
this
)
;
auto
*
out
=
c
-
>
start_embed
(
this
)
;
if
(
unlikely
(
!
c
-
>
extend_min
(
out
)
)
)
return_trace
(
nullptr
)
;
c
-
>
check_assign
(
out
-
>
len
len
)
;
if
(
unlikely
(
!
as_array
(
)
.
copy
(
c
)
)
)
return_trace
(
nullptr
)
;
return_trace
(
out
)
;
}
template
<
typename
.
.
.
Ts
>
bool
sanitize
(
hb_sanitize_context_t
*
c
Ts
&
&
.
.
.
ds
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
sanitize_shallow
(
c
)
)
)
return_trace
(
false
)
;
if
(
!
sizeof
.
.
.
(
Ts
)
&
&
hb_is_trivially_copyable
(
Type
)
)
return_trace
(
true
)
;
unsigned
int
count
=
len
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
if
(
unlikely
(
!
c
-
>
dispatch
(
arrayZ
[
i
]
hb_forward
<
Ts
>
(
ds
)
.
.
.
)
)
)
return_trace
(
false
)
;
return_trace
(
true
)
;
}
template
<
typename
T
>
Type
&
lsearch
(
const
T
&
x
Type
&
not_found
=
Crap
(
Type
)
)
{
return
*
as_array
(
)
.
lsearch
(
x
&
not_found
)
;
}
template
<
typename
T
>
const
Type
&
lsearch
(
const
T
&
x
const
Type
&
not_found
=
Null
(
Type
)
)
const
{
return
*
as_array
(
)
.
lsearch
(
x
&
not_found
)
;
}
void
qsort
(
unsigned
int
start
=
0
unsigned
int
end
=
(
unsigned
int
)
-
1
)
{
as_array
(
)
.
qsort
(
start
end
)
;
}
bool
sanitize_shallow
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
len
.
sanitize
(
c
)
&
&
c
-
>
check_array
(
arrayZ
len
)
)
;
}
public
:
LenType
len
;
Type
arrayZ
[
VAR
]
;
public
:
DEFINE_SIZE_ARRAY
(
sizeof
(
LenType
)
arrayZ
)
;
}
;
template
<
typename
Type
>
using
LArrayOf
=
ArrayOf
<
Type
HBUINT32
>
;
using
PString
=
ArrayOf
<
HBUINT8
HBUINT8
>
;
template
<
typename
Type
>
using
OffsetArrayOf
=
ArrayOf
<
OffsetTo
<
Type
HBUINT16
>
>
;
template
<
typename
Type
>
using
LOffsetArrayOf
=
ArrayOf
<
OffsetTo
<
Type
HBUINT32
>
>
;
template
<
typename
Type
>
using
LOffsetLArrayOf
=
ArrayOf
<
OffsetTo
<
Type
HBUINT32
>
HBUINT32
>
;
template
<
typename
Type
>
struct
OffsetListOf
:
OffsetArrayOf
<
Type
>
{
const
Type
&
operator
[
]
(
int
i_
)
const
{
unsigned
int
i
=
(
unsigned
int
)
i_
;
if
(
unlikely
(
i
>
=
this
-
>
len
)
)
return
Null
(
Type
)
;
return
this
+
this
-
>
arrayZ
[
i
]
;
}
const
Type
&
operator
[
]
(
int
i_
)
{
unsigned
int
i
=
(
unsigned
int
)
i_
;
if
(
unlikely
(
i
>
=
this
-
>
len
)
)
return
Crap
(
Type
)
;
return
this
+
this
-
>
arrayZ
[
i
]
;
}
bool
subset
(
hb_subset_context_t
*
c
)
const
{
TRACE_SUBSET
(
this
)
;
struct
OffsetListOf
<
Type
>
*
out
=
c
-
>
serializer
-
>
embed
(
*
this
)
;
if
(
unlikely
(
!
out
)
)
return_trace
(
false
)
;
unsigned
int
count
=
this
-
>
len
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
out
-
>
arrayZ
[
i
]
.
serialize_subset
(
c
this
-
>
arrayZ
[
i
]
this
out
)
;
return_trace
(
true
)
;
}
template
<
typename
.
.
.
Ts
>
bool
sanitize
(
hb_sanitize_context_t
*
c
Ts
&
&
.
.
.
ds
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
OffsetArrayOf
<
Type
>
:
:
sanitize
(
c
this
hb_forward
<
Ts
>
(
ds
)
.
.
.
)
)
;
}
}
;
template
<
typename
Type
typename
LenType
=
HBUINT16
>
struct
HeadlessArrayOf
{
static
constexpr
unsigned
item_size
=
Type
:
:
static_size
;
HB_DELETE_CREATE_COPY_ASSIGN
(
HeadlessArrayOf
)
;
const
Type
&
operator
[
]
(
int
i_
)
const
{
unsigned
int
i
=
(
unsigned
int
)
i_
;
if
(
unlikely
(
i
>
=
lenP1
|
|
!
i
)
)
return
Null
(
Type
)
;
return
arrayZ
[
i
-
1
]
;
}
Type
&
operator
[
]
(
int
i_
)
{
unsigned
int
i
=
(
unsigned
int
)
i_
;
if
(
unlikely
(
i
>
=
lenP1
|
|
!
i
)
)
return
Crap
(
Type
)
;
return
arrayZ
[
i
-
1
]
;
}
unsigned
int
get_size
(
)
const
{
return
lenP1
.
static_size
+
(
lenP1
?
lenP1
-
1
:
0
)
*
Type
:
:
static_size
;
}
bool
serialize
(
hb_serialize_context_t
*
c
hb_array_t
<
const
Type
>
items
)
{
TRACE_SERIALIZE
(
this
)
;
if
(
unlikely
(
!
c
-
>
extend_min
(
*
this
)
)
)
return_trace
(
false
)
;
c
-
>
check_assign
(
lenP1
items
.
length
+
1
)
;
if
(
unlikely
(
!
c
-
>
extend
(
*
this
)
)
)
return_trace
(
false
)
;
for
(
unsigned
int
i
=
0
;
i
<
items
.
length
;
i
+
+
)
arrayZ
[
i
]
=
items
[
i
]
;
return_trace
(
true
)
;
}
template
<
typename
.
.
.
Ts
>
bool
sanitize
(
hb_sanitize_context_t
*
c
Ts
&
&
.
.
.
ds
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
sanitize_shallow
(
c
)
)
)
return_trace
(
false
)
;
if
(
!
sizeof
.
.
.
(
Ts
)
&
&
hb_is_trivially_copyable
(
Type
)
)
return_trace
(
true
)
;
unsigned
int
count
=
lenP1
?
lenP1
-
1
:
0
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
if
(
unlikely
(
!
c
-
>
dispatch
(
arrayZ
[
i
]
hb_forward
<
Ts
>
(
ds
)
.
.
.
)
)
)
return_trace
(
false
)
;
return_trace
(
true
)
;
}
private
:
bool
sanitize_shallow
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
lenP1
.
sanitize
(
c
)
&
&
(
!
lenP1
|
|
c
-
>
check_array
(
arrayZ
lenP1
-
1
)
)
)
;
}
public
:
LenType
lenP1
;
Type
arrayZ
[
VAR
]
;
public
:
DEFINE_SIZE_ARRAY
(
sizeof
(
LenType
)
arrayZ
)
;
}
;
template
<
typename
Type
typename
LenType
=
HBUINT16
>
struct
ArrayOfM1
{
HB_DELETE_CREATE_COPY_ASSIGN
(
ArrayOfM1
)
;
const
Type
&
operator
[
]
(
int
i_
)
const
{
unsigned
int
i
=
(
unsigned
int
)
i_
;
if
(
unlikely
(
i
>
lenM1
)
)
return
Null
(
Type
)
;
return
arrayZ
[
i
]
;
}
Type
&
operator
[
]
(
int
i_
)
{
unsigned
int
i
=
(
unsigned
int
)
i_
;
if
(
unlikely
(
i
>
lenM1
)
)
return
Crap
(
Type
)
;
return
arrayZ
[
i
]
;
}
unsigned
int
get_size
(
)
const
{
return
lenM1
.
static_size
+
(
lenM1
+
1
)
*
Type
:
:
static_size
;
}
template
<
typename
.
.
.
Ts
>
bool
sanitize
(
hb_sanitize_context_t
*
c
Ts
&
&
.
.
.
ds
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
sanitize_shallow
(
c
)
)
)
return_trace
(
false
)
;
unsigned
int
count
=
lenM1
+
1
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
if
(
unlikely
(
!
c
-
>
dispatch
(
arrayZ
[
i
]
hb_forward
<
Ts
>
(
ds
)
.
.
.
)
)
)
return_trace
(
false
)
;
return_trace
(
true
)
;
}
private
:
bool
sanitize_shallow
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
lenM1
.
sanitize
(
c
)
&
&
(
c
-
>
check_array
(
arrayZ
lenM1
+
1
)
)
)
;
}
public
:
LenType
lenM1
;
Type
arrayZ
[
VAR
]
;
public
:
DEFINE_SIZE_ARRAY
(
sizeof
(
LenType
)
arrayZ
)
;
}
;
template
<
typename
Type
typename
LenType
=
HBUINT16
>
struct
SortedArrayOf
:
ArrayOf
<
Type
LenType
>
{
hb_sorted_array_t
<
Type
>
as_array
(
)
{
return
hb_sorted_array
(
this
-
>
arrayZ
this
-
>
len
)
;
}
hb_sorted_array_t
<
const
Type
>
as_array
(
)
const
{
return
hb_sorted_array
(
this
-
>
arrayZ
this
-
>
len
)
;
}
typedef
hb_sorted_array_t
<
const
Type
>
iter_t
;
typedef
hb_sorted_array_t
<
Type
>
writer_t
;
iter_t
iter
(
)
const
{
return
as_array
(
)
;
}
writer_t
writer
(
)
{
return
as_array
(
)
;
}
operator
iter_t
(
)
const
{
return
iter
(
)
;
}
operator
writer_t
(
)
{
return
writer
(
)
;
}
hb_sorted_array_t
<
const
Type
>
sub_array
(
unsigned
int
start_offset
unsigned
int
count
)
const
{
return
as_array
(
)
.
sub_array
(
start_offset
count
)
;
}
hb_sorted_array_t
<
const
Type
>
sub_array
(
unsigned
int
start_offset
unsigned
int
*
count
=
nullptr
)
const
{
return
as_array
(
)
.
sub_array
(
start_offset
count
)
;
}
hb_sorted_array_t
<
Type
>
sub_array
(
unsigned
int
start_offset
unsigned
int
count
)
{
return
as_array
(
)
.
sub_array
(
start_offset
count
)
;
}
hb_sorted_array_t
<
Type
>
sub_array
(
unsigned
int
start_offset
unsigned
int
*
count
=
nullptr
)
{
return
as_array
(
)
.
sub_array
(
start_offset
count
)
;
}
bool
serialize
(
hb_serialize_context_t
*
c
unsigned
int
items_len
)
{
TRACE_SERIALIZE
(
this
)
;
bool
ret
=
ArrayOf
<
Type
LenType
>
:
:
serialize
(
c
items_len
)
;
return_trace
(
ret
)
;
}
template
<
typename
Iterator
hb_requires
(
hb_is_sorted_source_of
(
Iterator
Type
)
)
>
bool
serialize
(
hb_serialize_context_t
*
c
Iterator
items
)
{
TRACE_SERIALIZE
(
this
)
;
bool
ret
=
ArrayOf
<
Type
LenType
>
:
:
serialize
(
c
items
)
;
return_trace
(
ret
)
;
}
template
<
typename
T
>
Type
&
bsearch
(
const
T
&
x
Type
&
not_found
=
Crap
(
Type
)
)
{
return
*
as_array
(
)
.
bsearch
(
x
&
not_found
)
;
}
template
<
typename
T
>
const
Type
&
bsearch
(
const
T
&
x
const
Type
&
not_found
=
Null
(
Type
)
)
const
{
return
*
as_array
(
)
.
bsearch
(
x
&
not_found
)
;
}
template
<
typename
T
>
bool
bfind
(
const
T
&
x
unsigned
int
*
i
=
nullptr
hb_bfind_not_found_t
not_found
=
HB_BFIND_NOT_FOUND_DONT_STORE
unsigned
int
to_store
=
(
unsigned
int
)
-
1
)
const
{
return
as_array
(
)
.
bfind
(
x
i
not_found
to_store
)
;
}
}
;
template
<
typename
LenType
=
HBUINT16
>
struct
BinSearchHeader
{
operator
uint32_t
(
)
const
{
return
len
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
BinSearchHeader
&
operator
=
(
unsigned
int
v
)
{
len
=
v
;
assert
(
len
=
=
v
)
;
entrySelector
=
hb_max
(
1u
hb_bit_storage
(
v
)
)
-
1
;
searchRange
=
16
*
(
1u
<
<
entrySelector
)
;
rangeShift
=
v
*
16
>
searchRange
?
16
*
v
-
searchRange
:
0
;
return
*
this
;
}
protected
:
LenType
len
;
LenType
searchRange
;
LenType
entrySelector
;
LenType
rangeShift
;
public
:
DEFINE_SIZE_STATIC
(
8
)
;
}
;
template
<
typename
Type
typename
LenType
=
HBUINT16
>
using
BinSearchArrayOf
=
SortedArrayOf
<
Type
BinSearchHeader
<
LenType
>
>
;
struct
VarSizedBinSearchHeader
{
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
HBUINT16
unitSize
;
HBUINT16
nUnits
;
HBUINT16
searchRange
;
HBUINT16
entrySelector
;
HBUINT16
rangeShift
;
public
:
DEFINE_SIZE_STATIC
(
10
)
;
}
;
template
<
typename
Type
>
struct
VarSizedBinSearchArrayOf
{
static
constexpr
unsigned
item_size
=
Type
:
:
static_size
;
HB_DELETE_CREATE_COPY_ASSIGN
(
VarSizedBinSearchArrayOf
)
;
bool
last_is_terminator
(
)
const
{
if
(
unlikely
(
!
header
.
nUnits
)
)
return
false
;
const
HBUINT16
*
words
=
&
StructAtOffset
<
HBUINT16
>
(
&
bytesZ
(
header
.
nUnits
-
1
)
*
header
.
unitSize
)
;
unsigned
int
count
=
Type
:
:
TerminationWordCount
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
if
(
words
[
i
]
!
=
0xFFFFu
)
return
false
;
return
true
;
}
const
Type
&
operator
[
]
(
int
i_
)
const
{
unsigned
int
i
=
(
unsigned
int
)
i_
;
if
(
unlikely
(
i
>
=
get_length
(
)
)
)
return
Null
(
Type
)
;
return
StructAtOffset
<
Type
>
(
&
bytesZ
i
*
header
.
unitSize
)
;
}
Type
&
operator
[
]
(
int
i_
)
{
unsigned
int
i
=
(
unsigned
int
)
i_
;
if
(
unlikely
(
i
>
=
get_length
(
)
)
)
return
Crap
(
Type
)
;
return
StructAtOffset
<
Type
>
(
&
bytesZ
i
*
header
.
unitSize
)
;
}
unsigned
int
get_length
(
)
const
{
return
header
.
nUnits
-
last_is_terminator
(
)
;
}
unsigned
int
get_size
(
)
const
{
return
header
.
static_size
+
header
.
nUnits
*
header
.
unitSize
;
}
template
<
typename
.
.
.
Ts
>
bool
sanitize
(
hb_sanitize_context_t
*
c
Ts
&
&
.
.
.
ds
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
sanitize_shallow
(
c
)
)
)
return_trace
(
false
)
;
if
(
!
sizeof
.
.
.
(
Ts
)
&
&
hb_is_trivially_copyable
(
Type
)
)
return_trace
(
true
)
;
unsigned
int
count
=
get_length
(
)
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
if
(
unlikely
(
!
(
*
this
)
[
i
]
.
sanitize
(
c
hb_forward
<
Ts
>
(
ds
)
.
.
.
)
)
)
return_trace
(
false
)
;
return_trace
(
true
)
;
}
template
<
typename
T
>
const
Type
*
bsearch
(
const
T
&
key
)
const
{
unsigned
int
size
=
header
.
unitSize
;
int
min
=
0
max
=
(
int
)
get_length
(
)
-
1
;
while
(
min
<
=
max
)
{
int
mid
=
(
(
unsigned
int
)
min
+
(
unsigned
int
)
max
)
/
2
;
const
Type
*
p
=
(
const
Type
*
)
(
(
(
const
char
*
)
&
bytesZ
)
+
(
mid
*
size
)
)
;
int
c
=
p
-
>
cmp
(
key
)
;
if
(
c
<
0
)
max
=
mid
-
1
;
else
if
(
c
>
0
)
min
=
mid
+
1
;
else
return
p
;
}
return
nullptr
;
}
private
:
bool
sanitize_shallow
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
header
.
sanitize
(
c
)
&
&
Type
:
:
static_size
<
=
header
.
unitSize
&
&
c
-
>
check_range
(
bytesZ
.
arrayZ
header
.
nUnits
header
.
unitSize
)
)
;
}
protected
:
VarSizedBinSearchHeader
header
;
UnsizedArrayOf
<
HBUINT8
>
bytesZ
;
public
:
DEFINE_SIZE_ARRAY
(
10
bytesZ
)
;
}
;
}
#
endif
