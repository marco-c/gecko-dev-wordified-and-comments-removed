#
include
"
hb
.
hh
"
#
ifndef
HB_NO_OT_SHAPE
#
include
"
hb
-
ot
-
shaper
-
indic
.
hh
"
#
include
"
hb
-
ot
-
shaper
-
indic
-
machine
.
hh
"
#
include
"
hb
-
ot
-
shaper
-
vowel
-
constraints
.
hh
"
#
include
"
hb
-
ot
-
layout
.
hh
"
static
inline
void
set_indic_properties
(
hb_glyph_info_t
&
info
)
{
hb_codepoint_t
u
=
info
.
codepoint
;
unsigned
int
type
=
hb_indic_get_categories
(
u
)
;
info
.
indic_category
(
)
=
(
indic_category_t
)
(
type
&
0xFFu
)
;
info
.
indic_position
(
)
=
(
indic_position_t
)
(
type
>
>
8
)
;
}
static
inline
bool
is_one_of
(
const
hb_glyph_info_t
&
info
unsigned
int
flags
)
{
if
(
_hb_glyph_info_ligated
(
&
info
)
)
return
false
;
return
!
!
(
FLAG_UNSAFE
(
info
.
indic_category
(
)
)
&
flags
)
;
}
#
define
CONSONANT_FLAGS_INDIC
(
FLAG
(
I_Cat
(
C
)
)
|
FLAG
(
I_Cat
(
CS
)
)
|
FLAG
(
I_Cat
(
Ra
)
)
|
FLAG
(
I_Cat
(
CM
)
)
|
FLAG
(
I_Cat
(
V
)
)
|
FLAG
(
I_Cat
(
PLACEHOLDER
)
)
|
FLAG
(
I_Cat
(
DOTTEDCIRCLE
)
)
)
static
inline
bool
is_consonant
(
const
hb_glyph_info_t
&
info
)
{
return
is_one_of
(
info
CONSONANT_FLAGS_INDIC
)
;
}
#
define
JOINER_FLAGS
(
FLAG
(
I_Cat
(
ZWJ
)
)
|
FLAG
(
I_Cat
(
ZWNJ
)
)
)
static
inline
bool
is_joiner
(
const
hb_glyph_info_t
&
info
)
{
return
is_one_of
(
info
JOINER_FLAGS
)
;
}
static
inline
bool
is_halant
(
const
hb_glyph_info_t
&
info
)
{
return
is_one_of
(
info
FLAG
(
I_Cat
(
H
)
)
)
;
}
struct
hb_indic_would_substitute_feature_t
{
void
init
(
const
hb_ot_map_t
*
map
hb_tag_t
feature_tag
bool
zero_context_
)
{
zero_context
=
zero_context_
;
lookups
=
map
-
>
get_stage_lookups
(
0
map
-
>
get_feature_stage
(
0
feature_tag
)
)
;
}
bool
would_substitute
(
const
hb_codepoint_t
*
glyphs
unsigned
int
glyphs_count
hb_face_t
*
face
)
const
{
for
(
const
auto
&
lookup
:
lookups
)
if
(
hb_ot_layout_lookup_would_substitute
(
face
lookup
.
index
glyphs
glyphs_count
zero_context
)
)
return
true
;
return
false
;
}
private
:
hb_array_t
<
const
hb_ot_map_t
:
:
lookup_map_t
>
lookups
;
bool
zero_context
;
}
;
enum
reph_position_t
{
REPH_POS_AFTER_MAIN
=
POS_AFTER_MAIN
REPH_POS_BEFORE_SUB
=
POS_BEFORE_SUB
REPH_POS_AFTER_SUB
=
POS_AFTER_SUB
REPH_POS_BEFORE_POST
=
POS_BEFORE_POST
REPH_POS_AFTER_POST
=
POS_AFTER_POST
}
;
enum
reph_mode_t
{
REPH_MODE_IMPLICIT
REPH_MODE_EXPLICIT
REPH_MODE_LOG_REPHA
}
;
enum
blwf_mode_t
{
BLWF_MODE_PRE_AND_POST
BLWF_MODE_POST_ONLY
}
;
struct
indic_config_t
{
hb_script_t
script
;
bool
has_old_spec
;
hb_codepoint_t
virama
;
reph_position_t
reph_pos
;
reph_mode_t
reph_mode
;
blwf_mode_t
blwf_mode
;
}
;
static
const
indic_config_t
indic_configs
[
]
=
{
{
HB_SCRIPT_INVALID
false
0
REPH_POS_BEFORE_POST
REPH_MODE_IMPLICIT
BLWF_MODE_PRE_AND_POST
}
{
HB_SCRIPT_DEVANAGARI
true
0x094Du
REPH_POS_BEFORE_POST
REPH_MODE_IMPLICIT
BLWF_MODE_PRE_AND_POST
}
{
HB_SCRIPT_BENGALI
true
0x09CDu
REPH_POS_AFTER_SUB
REPH_MODE_IMPLICIT
BLWF_MODE_PRE_AND_POST
}
{
HB_SCRIPT_GURMUKHI
true
0x0A4Du
REPH_POS_BEFORE_SUB
REPH_MODE_IMPLICIT
BLWF_MODE_PRE_AND_POST
}
{
HB_SCRIPT_GUJARATI
true
0x0ACDu
REPH_POS_BEFORE_POST
REPH_MODE_IMPLICIT
BLWF_MODE_PRE_AND_POST
}
{
HB_SCRIPT_ORIYA
true
0x0B4Du
REPH_POS_AFTER_MAIN
REPH_MODE_IMPLICIT
BLWF_MODE_PRE_AND_POST
}
{
HB_SCRIPT_TAMIL
true
0x0BCDu
REPH_POS_AFTER_POST
REPH_MODE_IMPLICIT
BLWF_MODE_PRE_AND_POST
}
{
HB_SCRIPT_TELUGU
true
0x0C4Du
REPH_POS_AFTER_POST
REPH_MODE_EXPLICIT
BLWF_MODE_POST_ONLY
}
{
HB_SCRIPT_KANNADA
true
0x0CCDu
REPH_POS_AFTER_POST
REPH_MODE_IMPLICIT
BLWF_MODE_POST_ONLY
}
{
HB_SCRIPT_MALAYALAM
true
0x0D4Du
REPH_POS_AFTER_MAIN
REPH_MODE_LOG_REPHA
BLWF_MODE_PRE_AND_POST
}
}
;
static
const
hb_ot_map_feature_t
indic_features
[
]
=
{
{
HB_TAG
(
'
n
'
'
u
'
'
k
'
'
t
'
)
F_GLOBAL_MANUAL_JOINERS
|
F_PER_SYLLABLE
}
{
HB_TAG
(
'
a
'
'
k
'
'
h
'
'
n
'
)
F_GLOBAL_MANUAL_JOINERS
|
F_PER_SYLLABLE
}
{
HB_TAG
(
'
r
'
'
p
'
'
h
'
'
f
'
)
F_MANUAL_JOINERS
|
F_PER_SYLLABLE
}
{
HB_TAG
(
'
r
'
'
k
'
'
r
'
'
f
'
)
F_GLOBAL_MANUAL_JOINERS
|
F_PER_SYLLABLE
}
{
HB_TAG
(
'
p
'
'
r
'
'
e
'
'
f
'
)
F_MANUAL_JOINERS
|
F_PER_SYLLABLE
}
{
HB_TAG
(
'
b
'
'
l
'
'
w
'
'
f
'
)
F_MANUAL_JOINERS
|
F_PER_SYLLABLE
}
{
HB_TAG
(
'
a
'
'
b
'
'
v
'
'
f
'
)
F_MANUAL_JOINERS
|
F_PER_SYLLABLE
}
{
HB_TAG
(
'
h
'
'
a
'
'
l
'
'
f
'
)
F_MANUAL_JOINERS
|
F_PER_SYLLABLE
}
{
HB_TAG
(
'
p
'
'
s
'
'
t
'
'
f
'
)
F_MANUAL_JOINERS
|
F_PER_SYLLABLE
}
{
HB_TAG
(
'
v
'
'
a
'
'
t
'
'
u
'
)
F_GLOBAL_MANUAL_JOINERS
|
F_PER_SYLLABLE
}
{
HB_TAG
(
'
c
'
'
j
'
'
c
'
'
t
'
)
F_GLOBAL_MANUAL_JOINERS
|
F_PER_SYLLABLE
}
{
HB_TAG
(
'
i
'
'
n
'
'
i
'
'
t
'
)
F_MANUAL_JOINERS
|
F_PER_SYLLABLE
}
{
HB_TAG
(
'
p
'
'
r
'
'
e
'
'
s
'
)
F_GLOBAL_MANUAL_JOINERS
|
F_PER_SYLLABLE
}
{
HB_TAG
(
'
a
'
'
b
'
'
v
'
'
s
'
)
F_GLOBAL_MANUAL_JOINERS
|
F_PER_SYLLABLE
}
{
HB_TAG
(
'
b
'
'
l
'
'
w
'
'
s
'
)
F_GLOBAL_MANUAL_JOINERS
|
F_PER_SYLLABLE
}
{
HB_TAG
(
'
p
'
'
s
'
'
t
'
'
s
'
)
F_GLOBAL_MANUAL_JOINERS
|
F_PER_SYLLABLE
}
{
HB_TAG
(
'
h
'
'
a
'
'
l
'
'
n
'
)
F_GLOBAL_MANUAL_JOINERS
|
F_PER_SYLLABLE
}
}
;
enum
{
_INDIC_NUKT
_INDIC_AKHN
INDIC_RPHF
_INDIC_RKRF
INDIC_PREF
INDIC_BLWF
INDIC_ABVF
INDIC_HALF
INDIC_PSTF
_INDIC_VATU
_INDIC_CJCT
INDIC_INIT
_INDIC_PRES
_INDIC_ABVS
_INDIC_BLWS
_INDIC_PSTS
_INDIC_HALN
INDIC_NUM_FEATURES
INDIC_BASIC_FEATURES
=
INDIC_INIT
}
;
static
void
setup_syllables_indic
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
hb_buffer_t
*
buffer
)
;
static
void
initial_reordering_indic
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
hb_buffer_t
*
buffer
)
;
static
void
final_reordering_indic
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
hb_buffer_t
*
buffer
)
;
static
void
collect_features_indic
(
hb_ot_shape_planner_t
*
plan
)
{
hb_ot_map_builder_t
*
map
=
&
plan
-
>
map
;
map
-
>
add_gsub_pause
(
setup_syllables_indic
)
;
map
-
>
enable_feature
(
HB_TAG
(
'
l
'
'
o
'
'
c
'
'
l
'
)
F_PER_SYLLABLE
)
;
map
-
>
enable_feature
(
HB_TAG
(
'
c
'
'
c
'
'
m
'
'
p
'
)
F_PER_SYLLABLE
)
;
unsigned
int
i
=
0
;
map
-
>
add_gsub_pause
(
initial_reordering_indic
)
;
for
(
;
i
<
INDIC_BASIC_FEATURES
;
i
+
+
)
{
map
-
>
add_feature
(
indic_features
[
i
]
)
;
map
-
>
add_gsub_pause
(
nullptr
)
;
}
map
-
>
add_gsub_pause
(
final_reordering_indic
)
;
for
(
;
i
<
INDIC_NUM_FEATURES
;
i
+
+
)
map
-
>
add_feature
(
indic_features
[
i
]
)
;
}
static
void
override_features_indic
(
hb_ot_shape_planner_t
*
plan
)
{
plan
-
>
map
.
disable_feature
(
HB_TAG
(
'
l
'
'
i
'
'
g
'
'
a
'
)
)
;
plan
-
>
map
.
add_gsub_pause
(
hb_syllabic_clear_var
)
;
}
struct
indic_shape_plan_t
{
bool
load_virama_glyph
(
hb_font_t
*
font
hb_codepoint_t
*
pglyph
)
const
{
hb_codepoint_t
glyph
=
virama_glyph
.
get_relaxed
(
)
;
if
(
unlikely
(
glyph
=
=
(
hb_codepoint_t
)
-
1
)
)
{
if
(
!
config
-
>
virama
|
|
!
font
-
>
get_nominal_glyph
(
config
-
>
virama
&
glyph
)
)
glyph
=
0
;
virama_glyph
.
set_relaxed
(
(
int
)
glyph
)
;
}
*
pglyph
=
glyph
;
return
glyph
!
=
0
;
}
const
indic_config_t
*
config
;
bool
is_old_spec
;
#
ifndef
HB_NO_UNISCRIBE_BUG_COMPATIBLE
bool
uniscribe_bug_compatible
;
#
else
static
constexpr
bool
uniscribe_bug_compatible
=
false
;
#
endif
mutable
hb_atomic_int_t
virama_glyph
;
hb_indic_would_substitute_feature_t
rphf
;
hb_indic_would_substitute_feature_t
pref
;
hb_indic_would_substitute_feature_t
blwf
;
hb_indic_would_substitute_feature_t
pstf
;
hb_indic_would_substitute_feature_t
vatu
;
hb_mask_t
mask_array
[
INDIC_NUM_FEATURES
]
;
}
;
static
void
*
data_create_indic
(
const
hb_ot_shape_plan_t
*
plan
)
{
indic_shape_plan_t
*
indic_plan
=
(
indic_shape_plan_t
*
)
hb_calloc
(
1
sizeof
(
indic_shape_plan_t
)
)
;
if
(
unlikely
(
!
indic_plan
)
)
return
nullptr
;
indic_plan
-
>
config
=
&
indic_configs
[
0
]
;
for
(
unsigned
int
i
=
1
;
i
<
ARRAY_LENGTH
(
indic_configs
)
;
i
+
+
)
if
(
plan
-
>
props
.
script
=
=
indic_configs
[
i
]
.
script
)
{
indic_plan
-
>
config
=
&
indic_configs
[
i
]
;
break
;
}
indic_plan
-
>
is_old_spec
=
indic_plan
-
>
config
-
>
has_old_spec
&
&
(
(
plan
-
>
map
.
chosen_script
[
0
]
&
0x000000FFu
)
!
=
'
2
'
)
;
#
ifndef
HB_NO_UNISCRIBE_BUG_COMPATIBLE
indic_plan
-
>
uniscribe_bug_compatible
=
hb_options
(
)
.
uniscribe_bug_compatible
;
#
endif
indic_plan
-
>
virama_glyph
.
set_relaxed
(
-
1
)
;
bool
zero_context
=
!
indic_plan
-
>
is_old_spec
&
&
plan
-
>
props
.
script
!
=
HB_SCRIPT_MALAYALAM
;
indic_plan
-
>
rphf
.
init
(
&
plan
-
>
map
HB_TAG
(
'
r
'
'
p
'
'
h
'
'
f
'
)
zero_context
)
;
indic_plan
-
>
pref
.
init
(
&
plan
-
>
map
HB_TAG
(
'
p
'
'
r
'
'
e
'
'
f
'
)
zero_context
)
;
indic_plan
-
>
blwf
.
init
(
&
plan
-
>
map
HB_TAG
(
'
b
'
'
l
'
'
w
'
'
f
'
)
zero_context
)
;
indic_plan
-
>
pstf
.
init
(
&
plan
-
>
map
HB_TAG
(
'
p
'
'
s
'
'
t
'
'
f
'
)
zero_context
)
;
indic_plan
-
>
vatu
.
init
(
&
plan
-
>
map
HB_TAG
(
'
v
'
'
a
'
'
t
'
'
u
'
)
zero_context
)
;
for
(
unsigned
int
i
=
0
;
i
<
ARRAY_LENGTH
(
indic_plan
-
>
mask_array
)
;
i
+
+
)
indic_plan
-
>
mask_array
[
i
]
=
(
indic_features
[
i
]
.
flags
&
F_GLOBAL
)
?
0
:
plan
-
>
map
.
get_1_mask
(
indic_features
[
i
]
.
tag
)
;
return
indic_plan
;
}
static
void
data_destroy_indic
(
void
*
data
)
{
hb_free
(
data
)
;
}
static
indic_position_t
consonant_position_from_face
(
const
indic_shape_plan_t
*
indic_plan
const
hb_codepoint_t
consonant
const
hb_codepoint_t
virama
hb_face_t
*
face
)
{
hb_codepoint_t
glyphs
[
3
]
=
{
virama
consonant
virama
}
;
if
(
indic_plan
-
>
blwf
.
would_substitute
(
glyphs
2
face
)
|
|
indic_plan
-
>
blwf
.
would_substitute
(
glyphs
+
1
2
face
)
|
|
indic_plan
-
>
vatu
.
would_substitute
(
glyphs
2
face
)
|
|
indic_plan
-
>
vatu
.
would_substitute
(
glyphs
+
1
2
face
)
)
return
POS_BELOW_C
;
if
(
indic_plan
-
>
pstf
.
would_substitute
(
glyphs
2
face
)
|
|
indic_plan
-
>
pstf
.
would_substitute
(
glyphs
+
1
2
face
)
)
return
POS_POST_C
;
if
(
indic_plan
-
>
pref
.
would_substitute
(
glyphs
2
face
)
|
|
indic_plan
-
>
pref
.
would_substitute
(
glyphs
+
1
2
face
)
)
return
POS_POST_C
;
return
POS_BASE_C
;
}
static
void
setup_masks_indic
(
const
hb_ot_shape_plan_t
*
plan
HB_UNUSED
hb_buffer_t
*
buffer
hb_font_t
*
font
HB_UNUSED
)
{
HB_BUFFER_ALLOCATE_VAR
(
buffer
indic_category
)
;
HB_BUFFER_ALLOCATE_VAR
(
buffer
indic_position
)
;
unsigned
int
count
=
buffer
-
>
len
;
hb_glyph_info_t
*
info
=
buffer
-
>
info
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
set_indic_properties
(
info
[
i
]
)
;
}
static
void
setup_syllables_indic
(
const
hb_ot_shape_plan_t
*
plan
HB_UNUSED
hb_font_t
*
font
HB_UNUSED
hb_buffer_t
*
buffer
)
{
HB_BUFFER_ALLOCATE_VAR
(
buffer
syllable
)
;
find_syllables_indic
(
buffer
)
;
foreach_syllable
(
buffer
start
end
)
buffer
-
>
unsafe_to_break
(
start
end
)
;
}
static
int
compare_indic_order
(
const
hb_glyph_info_t
*
pa
const
hb_glyph_info_t
*
pb
)
{
int
a
=
pa
-
>
indic_position
(
)
;
int
b
=
pb
-
>
indic_position
(
)
;
return
(
int
)
a
-
(
int
)
b
;
}
static
void
update_consonant_positions_indic
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
hb_buffer_t
*
buffer
)
{
const
indic_shape_plan_t
*
indic_plan
=
(
const
indic_shape_plan_t
*
)
plan
-
>
data
;
hb_codepoint_t
virama
;
if
(
indic_plan
-
>
load_virama_glyph
(
font
&
virama
)
)
{
hb_face_t
*
face
=
font
-
>
face
;
unsigned
int
count
=
buffer
-
>
len
;
hb_glyph_info_t
*
info
=
buffer
-
>
info
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
if
(
info
[
i
]
.
indic_position
(
)
=
=
POS_BASE_C
)
{
hb_codepoint_t
consonant
=
info
[
i
]
.
codepoint
;
info
[
i
]
.
indic_position
(
)
=
consonant_position_from_face
(
indic_plan
consonant
virama
face
)
;
}
}
}
static
void
initial_reordering_consonant_syllable
(
const
hb_ot_shape_plan_t
*
plan
hb_face_t
*
face
hb_buffer_t
*
buffer
unsigned
int
start
unsigned
int
end
)
{
const
indic_shape_plan_t
*
indic_plan
=
(
const
indic_shape_plan_t
*
)
plan
-
>
data
;
hb_glyph_info_t
*
info
=
buffer
-
>
info
;
if
(
buffer
-
>
props
.
script
=
=
HB_SCRIPT_KANNADA
&
&
start
+
3
<
=
end
&
&
is_one_of
(
info
[
start
]
FLAG
(
I_Cat
(
Ra
)
)
)
&
&
is_one_of
(
info
[
start
+
1
]
FLAG
(
I_Cat
(
H
)
)
)
&
&
is_one_of
(
info
[
start
+
2
]
FLAG
(
I_Cat
(
ZWJ
)
)
)
)
{
buffer
-
>
merge_clusters
(
start
+
1
start
+
3
)
;
hb_glyph_info_t
tmp
=
info
[
start
+
1
]
;
info
[
start
+
1
]
=
info
[
start
+
2
]
;
info
[
start
+
2
]
=
tmp
;
}
unsigned
int
base
=
end
;
bool
has_reph
=
false
;
{
unsigned
int
limit
=
start
;
if
(
indic_plan
-
>
mask_array
[
INDIC_RPHF
]
&
&
start
+
3
<
=
end
&
&
(
(
indic_plan
-
>
config
-
>
reph_mode
=
=
REPH_MODE_IMPLICIT
&
&
!
is_joiner
(
info
[
start
+
2
]
)
)
|
|
(
indic_plan
-
>
config
-
>
reph_mode
=
=
REPH_MODE_EXPLICIT
&
&
info
[
start
+
2
]
.
indic_category
(
)
=
=
I_Cat
(
ZWJ
)
)
)
)
{
hb_codepoint_t
glyphs
[
3
]
=
{
info
[
start
]
.
codepoint
info
[
start
+
1
]
.
codepoint
indic_plan
-
>
config
-
>
reph_mode
=
=
REPH_MODE_EXPLICIT
?
info
[
start
+
2
]
.
codepoint
:
0
}
;
if
(
indic_plan
-
>
rphf
.
would_substitute
(
glyphs
2
face
)
|
|
(
indic_plan
-
>
config
-
>
reph_mode
=
=
REPH_MODE_EXPLICIT
&
&
indic_plan
-
>
rphf
.
would_substitute
(
glyphs
3
face
)
)
)
{
limit
+
=
2
;
while
(
limit
<
end
&
&
is_joiner
(
info
[
limit
]
)
)
limit
+
+
;
base
=
start
;
has_reph
=
true
;
}
}
else
if
(
indic_plan
-
>
config
-
>
reph_mode
=
=
REPH_MODE_LOG_REPHA
&
&
info
[
start
]
.
indic_category
(
)
=
=
I_Cat
(
Repha
)
)
{
limit
+
=
1
;
while
(
limit
<
end
&
&
is_joiner
(
info
[
limit
]
)
)
limit
+
+
;
base
=
start
;
has_reph
=
true
;
}
{
unsigned
int
i
=
end
;
bool
seen_below
=
false
;
do
{
i
-
-
;
if
(
is_consonant
(
info
[
i
]
)
)
{
if
(
info
[
i
]
.
indic_position
(
)
!
=
POS_BELOW_C
&
&
(
info
[
i
]
.
indic_position
(
)
!
=
POS_POST_C
|
|
seen_below
)
)
{
base
=
i
;
break
;
}
if
(
info
[
i
]
.
indic_position
(
)
=
=
POS_BELOW_C
)
seen_below
=
true
;
base
=
i
;
}
else
{
if
(
start
<
i
&
&
info
[
i
]
.
indic_category
(
)
=
=
I_Cat
(
ZWJ
)
&
&
info
[
i
-
1
]
.
indic_category
(
)
=
=
I_Cat
(
H
)
)
break
;
}
}
while
(
i
>
limit
)
;
}
if
(
has_reph
&
&
base
=
=
start
&
&
limit
-
base
<
=
2
)
{
has_reph
=
false
;
}
}
for
(
unsigned
int
i
=
start
;
i
<
base
;
i
+
+
)
info
[
i
]
.
indic_position
(
)
=
hb_min
(
POS_PRE_C
(
indic_position_t
)
info
[
i
]
.
indic_position
(
)
)
;
if
(
base
<
end
)
info
[
base
]
.
indic_position
(
)
=
POS_BASE_C
;
if
(
has_reph
)
info
[
start
]
.
indic_position
(
)
=
POS_RA_TO_BECOME_REPH
;
if
(
indic_plan
-
>
is_old_spec
)
{
bool
disallow_double_halants
=
buffer
-
>
props
.
script
=
=
HB_SCRIPT_KANNADA
;
for
(
unsigned
int
i
=
base
+
1
;
i
<
end
;
i
+
+
)
if
(
info
[
i
]
.
indic_category
(
)
=
=
I_Cat
(
H
)
)
{
unsigned
int
j
;
for
(
j
=
end
-
1
;
j
>
i
;
j
-
-
)
if
(
is_consonant
(
info
[
j
]
)
|
|
(
disallow_double_halants
&
&
info
[
j
]
.
indic_category
(
)
=
=
I_Cat
(
H
)
)
)
break
;
if
(
info
[
j
]
.
indic_category
(
)
!
=
I_Cat
(
H
)
&
&
j
>
i
)
{
hb_glyph_info_t
t
=
info
[
i
]
;
memmove
(
&
info
[
i
]
&
info
[
i
+
1
]
(
j
-
i
)
*
sizeof
(
info
[
0
]
)
)
;
info
[
j
]
=
t
;
}
break
;
}
}
{
indic_position_t
last_pos
=
POS_START
;
for
(
unsigned
int
i
=
start
;
i
<
end
;
i
+
+
)
{
if
(
(
FLAG_UNSAFE
(
info
[
i
]
.
indic_category
(
)
)
&
(
JOINER_FLAGS
|
FLAG
(
I_Cat
(
N
)
)
|
FLAG
(
I_Cat
(
RS
)
)
|
FLAG
(
I_Cat
(
CM
)
)
|
FLAG
(
I_Cat
(
H
)
)
)
)
)
{
info
[
i
]
.
indic_position
(
)
=
last_pos
;
if
(
unlikely
(
info
[
i
]
.
indic_category
(
)
=
=
I_Cat
(
H
)
&
&
info
[
i
]
.
indic_position
(
)
=
=
POS_PRE_M
)
)
{
for
(
unsigned
int
j
=
i
;
j
>
start
;
j
-
-
)
if
(
info
[
j
-
1
]
.
indic_position
(
)
!
=
POS_PRE_M
)
{
info
[
i
]
.
indic_position
(
)
=
info
[
j
-
1
]
.
indic_position
(
)
;
break
;
}
}
}
else
if
(
info
[
i
]
.
indic_position
(
)
!
=
POS_SMVD
)
{
last_pos
=
(
indic_position_t
)
info
[
i
]
.
indic_position
(
)
;
}
}
}
{
unsigned
int
last
=
base
;
for
(
unsigned
int
i
=
base
+
1
;
i
<
end
;
i
+
+
)
if
(
is_consonant
(
info
[
i
]
)
)
{
for
(
unsigned
int
j
=
last
+
1
;
j
<
i
;
j
+
+
)
if
(
info
[
j
]
.
indic_position
(
)
<
POS_SMVD
)
info
[
j
]
.
indic_position
(
)
=
info
[
i
]
.
indic_position
(
)
;
last
=
i
;
}
else
if
(
info
[
i
]
.
indic_category
(
)
=
=
I_Cat
(
M
)
)
last
=
i
;
}
{
unsigned
int
syllable
=
info
[
start
]
.
syllable
(
)
;
for
(
unsigned
int
i
=
start
;
i
<
end
;
i
+
+
)
info
[
i
]
.
syllable
(
)
=
i
-
start
;
hb_stable_sort
(
info
+
start
end
-
start
compare_indic_order
)
;
base
=
end
;
for
(
unsigned
int
i
=
start
;
i
<
end
;
i
+
+
)
if
(
info
[
i
]
.
indic_position
(
)
=
=
POS_BASE_C
)
{
base
=
i
;
break
;
}
if
(
indic_plan
-
>
is_old_spec
|
|
end
-
start
>
127
)
buffer
-
>
merge_clusters
(
base
end
)
;
else
{
for
(
unsigned
int
i
=
base
;
i
<
end
;
i
+
+
)
if
(
info
[
i
]
.
syllable
(
)
!
=
255
)
{
unsigned
int
min
=
i
;
unsigned
int
max
=
i
;
unsigned
int
j
=
start
+
info
[
i
]
.
syllable
(
)
;
while
(
j
!
=
i
)
{
min
=
hb_min
(
min
j
)
;
max
=
hb_max
(
max
j
)
;
unsigned
int
next
=
start
+
info
[
j
]
.
syllable
(
)
;
info
[
j
]
.
syllable
(
)
=
255
;
j
=
next
;
}
buffer
-
>
merge_clusters
(
hb_max
(
base
min
)
max
+
1
)
;
}
}
for
(
unsigned
int
i
=
start
;
i
<
end
;
i
+
+
)
info
[
i
]
.
syllable
(
)
=
syllable
;
}
{
hb_mask_t
mask
;
for
(
unsigned
int
i
=
start
;
i
<
end
&
&
info
[
i
]
.
indic_position
(
)
=
=
POS_RA_TO_BECOME_REPH
;
i
+
+
)
info
[
i
]
.
mask
|
=
indic_plan
-
>
mask_array
[
INDIC_RPHF
]
;
mask
=
indic_plan
-
>
mask_array
[
INDIC_HALF
]
;
if
(
!
indic_plan
-
>
is_old_spec
&
&
indic_plan
-
>
config
-
>
blwf_mode
=
=
BLWF_MODE_PRE_AND_POST
)
mask
|
=
indic_plan
-
>
mask_array
[
INDIC_BLWF
]
;
for
(
unsigned
int
i
=
start
;
i
<
base
;
i
+
+
)
info
[
i
]
.
mask
|
=
mask
;
mask
=
0
;
if
(
base
<
end
)
info
[
base
]
.
mask
|
=
mask
;
mask
=
indic_plan
-
>
mask_array
[
INDIC_BLWF
]
|
indic_plan
-
>
mask_array
[
INDIC_ABVF
]
|
indic_plan
-
>
mask_array
[
INDIC_PSTF
]
;
for
(
unsigned
int
i
=
base
+
1
;
i
<
end
;
i
+
+
)
info
[
i
]
.
mask
|
=
mask
;
}
if
(
indic_plan
-
>
is_old_spec
&
&
buffer
-
>
props
.
script
=
=
HB_SCRIPT_DEVANAGARI
)
{
for
(
unsigned
int
i
=
start
;
i
+
1
<
base
;
i
+
+
)
if
(
info
[
i
]
.
indic_category
(
)
=
=
I_Cat
(
Ra
)
&
&
info
[
i
+
1
]
.
indic_category
(
)
=
=
I_Cat
(
H
)
&
&
(
i
+
2
=
=
base
|
|
info
[
i
+
2
]
.
indic_category
(
)
!
=
I_Cat
(
ZWJ
)
)
)
{
info
[
i
]
.
mask
|
=
indic_plan
-
>
mask_array
[
INDIC_BLWF
]
;
info
[
i
+
1
]
.
mask
|
=
indic_plan
-
>
mask_array
[
INDIC_BLWF
]
;
}
}
unsigned
int
pref_len
=
2
;
if
(
indic_plan
-
>
mask_array
[
INDIC_PREF
]
&
&
base
+
pref_len
<
end
)
{
for
(
unsigned
int
i
=
base
+
1
;
i
+
pref_len
-
1
<
end
;
i
+
+
)
{
hb_codepoint_t
glyphs
[
2
]
;
for
(
unsigned
int
j
=
0
;
j
<
pref_len
;
j
+
+
)
glyphs
[
j
]
=
info
[
i
+
j
]
.
codepoint
;
if
(
indic_plan
-
>
pref
.
would_substitute
(
glyphs
pref_len
face
)
)
{
for
(
unsigned
int
j
=
0
;
j
<
pref_len
;
j
+
+
)
info
[
i
+
+
]
.
mask
|
=
indic_plan
-
>
mask_array
[
INDIC_PREF
]
;
break
;
}
}
}
for
(
unsigned
int
i
=
start
+
1
;
i
<
end
;
i
+
+
)
if
(
is_joiner
(
info
[
i
]
)
)
{
bool
non_joiner
=
info
[
i
]
.
indic_category
(
)
=
=
I_Cat
(
ZWNJ
)
;
unsigned
int
j
=
i
;
do
{
j
-
-
;
if
(
non_joiner
)
info
[
j
]
.
mask
&
=
~
indic_plan
-
>
mask_array
[
INDIC_HALF
]
;
}
while
(
j
>
start
&
&
!
is_consonant
(
info
[
j
]
)
)
;
}
}
static
void
initial_reordering_standalone_cluster
(
const
hb_ot_shape_plan_t
*
plan
hb_face_t
*
face
hb_buffer_t
*
buffer
unsigned
int
start
unsigned
int
end
)
{
const
indic_shape_plan_t
*
indic_plan
=
(
const
indic_shape_plan_t
*
)
plan
-
>
data
;
if
(
indic_plan
-
>
uniscribe_bug_compatible
)
{
if
(
buffer
-
>
info
[
end
-
1
]
.
indic_category
(
)
=
=
I_Cat
(
DOTTEDCIRCLE
)
)
return
;
}
initial_reordering_consonant_syllable
(
plan
face
buffer
start
end
)
;
}
static
void
initial_reordering_syllable_indic
(
const
hb_ot_shape_plan_t
*
plan
hb_face_t
*
face
hb_buffer_t
*
buffer
unsigned
int
start
unsigned
int
end
)
{
indic_syllable_type_t
syllable_type
=
(
indic_syllable_type_t
)
(
buffer
-
>
info
[
start
]
.
syllable
(
)
&
0x0F
)
;
switch
(
syllable_type
)
{
case
indic_vowel_syllable
:
case
indic_consonant_syllable
:
initial_reordering_consonant_syllable
(
plan
face
buffer
start
end
)
;
break
;
case
indic_broken_cluster
:
case
indic_standalone_cluster
:
initial_reordering_standalone_cluster
(
plan
face
buffer
start
end
)
;
break
;
case
indic_symbol_cluster
:
case
indic_non_indic_cluster
:
break
;
}
}
static
void
initial_reordering_indic
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
hb_buffer_t
*
buffer
)
{
if
(
!
buffer
-
>
message
(
font
"
start
reordering
indic
initial
"
)
)
return
;
update_consonant_positions_indic
(
plan
font
buffer
)
;
hb_syllabic_insert_dotted_circles
(
font
buffer
indic_broken_cluster
I_Cat
(
DOTTEDCIRCLE
)
I_Cat
(
Repha
)
POS_END
)
;
foreach_syllable
(
buffer
start
end
)
initial_reordering_syllable_indic
(
plan
font
-
>
face
buffer
start
end
)
;
(
void
)
buffer
-
>
message
(
font
"
end
reordering
indic
initial
"
)
;
}
static
void
final_reordering_syllable_indic
(
const
hb_ot_shape_plan_t
*
plan
hb_buffer_t
*
buffer
unsigned
int
start
unsigned
int
end
)
{
const
indic_shape_plan_t
*
indic_plan
=
(
const
indic_shape_plan_t
*
)
plan
-
>
data
;
hb_glyph_info_t
*
info
=
buffer
-
>
info
;
hb_codepoint_t
virama_glyph
=
indic_plan
-
>
virama_glyph
.
get_relaxed
(
)
;
if
(
virama_glyph
)
{
for
(
unsigned
int
i
=
start
;
i
<
end
;
i
+
+
)
if
(
info
[
i
]
.
codepoint
=
=
virama_glyph
&
&
_hb_glyph_info_ligated
(
&
info
[
i
]
)
&
&
_hb_glyph_info_multiplied
(
&
info
[
i
]
)
)
{
info
[
i
]
.
indic_category
(
)
=
I_Cat
(
H
)
;
_hb_glyph_info_clear_ligated_and_multiplied
(
&
info
[
i
]
)
;
}
}
bool
try_pref
=
!
!
indic_plan
-
>
mask_array
[
INDIC_PREF
]
;
unsigned
int
base
;
for
(
base
=
start
;
base
<
end
;
base
+
+
)
if
(
info
[
base
]
.
indic_position
(
)
>
=
POS_BASE_C
)
{
if
(
try_pref
&
&
base
+
1
<
end
)
{
for
(
unsigned
int
i
=
base
+
1
;
i
<
end
;
i
+
+
)
if
(
(
info
[
i
]
.
mask
&
indic_plan
-
>
mask_array
[
INDIC_PREF
]
)
!
=
0
)
{
if
(
!
(
_hb_glyph_info_substituted
(
&
info
[
i
]
)
&
&
_hb_glyph_info_ligated_and_didnt_multiply
(
&
info
[
i
]
)
)
)
{
base
=
i
;
while
(
base
<
end
&
&
is_halant
(
info
[
base
]
)
)
base
+
+
;
info
[
base
]
.
indic_position
(
)
=
POS_BASE_C
;
try_pref
=
false
;
}
break
;
}
}
if
(
buffer
-
>
props
.
script
=
=
HB_SCRIPT_MALAYALAM
)
{
for
(
unsigned
int
i
=
base
+
1
;
i
<
end
;
i
+
+
)
{
while
(
i
<
end
&
&
is_joiner
(
info
[
i
]
)
)
i
+
+
;
if
(
i
=
=
end
|
|
!
is_halant
(
info
[
i
]
)
)
break
;
i
+
+
;
while
(
i
<
end
&
&
is_joiner
(
info
[
i
]
)
)
i
+
+
;
if
(
i
<
end
&
&
is_consonant
(
info
[
i
]
)
&
&
info
[
i
]
.
indic_position
(
)
=
=
POS_BELOW_C
)
{
base
=
i
;
info
[
base
]
.
indic_position
(
)
=
POS_BASE_C
;
}
}
}
if
(
start
<
base
&
&
info
[
base
]
.
indic_position
(
)
>
POS_BASE_C
)
base
-
-
;
break
;
}
if
(
base
=
=
end
&
&
start
<
base
&
&
is_one_of
(
info
[
base
-
1
]
FLAG
(
I_Cat
(
ZWJ
)
)
)
)
base
-
-
;
if
(
base
<
end
)
while
(
start
<
base
&
&
is_one_of
(
info
[
base
]
(
FLAG
(
I_Cat
(
N
)
)
|
FLAG
(
I_Cat
(
H
)
)
)
)
)
base
-
-
;
if
(
start
+
1
<
end
&
&
start
<
base
)
{
unsigned
int
new_pos
=
base
=
=
end
?
base
-
2
:
base
-
1
;
if
(
buffer
-
>
props
.
script
!
=
HB_SCRIPT_MALAYALAM
&
&
buffer
-
>
props
.
script
!
=
HB_SCRIPT_TAMIL
)
{
search
:
while
(
new_pos
>
start
&
&
!
(
is_one_of
(
info
[
new_pos
]
(
FLAG
(
I_Cat
(
M
)
)
|
FLAG
(
I_Cat
(
H
)
)
)
)
)
)
new_pos
-
-
;
if
(
is_halant
(
info
[
new_pos
]
)
&
&
info
[
new_pos
]
.
indic_position
(
)
!
=
POS_PRE_M
)
{
#
if
0
if
(
new_pos
+
1
<
end
&
&
is_joiner
(
info
[
new_pos
+
1
]
)
)
new_pos
+
+
;
#
endif
if
(
new_pos
+
1
<
end
)
{
if
(
info
[
new_pos
+
1
]
.
indic_category
(
)
=
=
I_Cat
(
ZWJ
)
)
{
if
(
new_pos
>
start
)
{
new_pos
-
-
;
goto
search
;
}
}
}
}
else
new_pos
=
start
;
}
if
(
start
<
new_pos
&
&
info
[
new_pos
]
.
indic_position
(
)
!
=
POS_PRE_M
)
{
for
(
unsigned
int
i
=
new_pos
;
i
>
start
;
i
-
-
)
if
(
info
[
i
-
1
]
.
indic_position
(
)
=
=
POS_PRE_M
)
{
unsigned
int
old_pos
=
i
-
1
;
if
(
old_pos
<
base
&
&
base
<
=
new_pos
)
base
-
-
;
hb_glyph_info_t
tmp
=
info
[
old_pos
]
;
memmove
(
&
info
[
old_pos
]
&
info
[
old_pos
+
1
]
(
new_pos
-
old_pos
)
*
sizeof
(
info
[
0
]
)
)
;
info
[
new_pos
]
=
tmp
;
buffer
-
>
merge_clusters
(
new_pos
hb_min
(
end
base
+
1
)
)
;
new_pos
-
-
;
}
}
else
{
for
(
unsigned
int
i
=
start
;
i
<
base
;
i
+
+
)
if
(
info
[
i
]
.
indic_position
(
)
=
=
POS_PRE_M
)
{
buffer
-
>
merge_clusters
(
i
hb_min
(
end
base
+
1
)
)
;
break
;
}
}
}
if
(
start
+
1
<
end
&
&
info
[
start
]
.
indic_position
(
)
=
=
POS_RA_TO_BECOME_REPH
&
&
(
(
info
[
start
]
.
indic_category
(
)
=
=
I_Cat
(
Repha
)
)
^
_hb_glyph_info_ligated_and_didnt_multiply
(
&
info
[
start
]
)
)
)
{
unsigned
int
new_reph_pos
;
reph_position_t
reph_pos
=
indic_plan
-
>
config
-
>
reph_pos
;
if
(
reph_pos
=
=
REPH_POS_AFTER_POST
)
{
goto
reph_step_5
;
}
{
new_reph_pos
=
start
+
1
;
while
(
new_reph_pos
<
base
&
&
!
is_halant
(
info
[
new_reph_pos
]
)
)
new_reph_pos
+
+
;
if
(
new_reph_pos
<
base
&
&
is_halant
(
info
[
new_reph_pos
]
)
)
{
if
(
new_reph_pos
+
1
<
base
&
&
is_joiner
(
info
[
new_reph_pos
+
1
]
)
)
new_reph_pos
+
+
;
goto
reph_move
;
}
}
if
(
reph_pos
=
=
REPH_POS_AFTER_MAIN
)
{
new_reph_pos
=
base
;
while
(
new_reph_pos
+
1
<
end
&
&
info
[
new_reph_pos
+
1
]
.
indic_position
(
)
<
=
POS_AFTER_MAIN
)
new_reph_pos
+
+
;
if
(
new_reph_pos
<
end
)
goto
reph_move
;
}
if
(
reph_pos
=
=
REPH_POS_AFTER_SUB
)
{
new_reph_pos
=
base
;
while
(
new_reph_pos
+
1
<
end
&
&
!
(
FLAG_UNSAFE
(
info
[
new_reph_pos
+
1
]
.
indic_position
(
)
)
&
(
FLAG
(
POS_POST_C
)
|
FLAG
(
POS_AFTER_POST
)
|
FLAG
(
POS_SMVD
)
)
)
)
new_reph_pos
+
+
;
if
(
new_reph_pos
<
end
)
goto
reph_move
;
}
reph_step_5
:
{
new_reph_pos
=
start
+
1
;
while
(
new_reph_pos
<
base
&
&
!
is_halant
(
info
[
new_reph_pos
]
)
)
new_reph_pos
+
+
;
if
(
new_reph_pos
<
base
&
&
is_halant
(
info
[
new_reph_pos
]
)
)
{
if
(
new_reph_pos
+
1
<
base
&
&
is_joiner
(
info
[
new_reph_pos
+
1
]
)
)
new_reph_pos
+
+
;
goto
reph_move
;
}
}
{
new_reph_pos
=
end
-
1
;
while
(
new_reph_pos
>
start
&
&
info
[
new_reph_pos
]
.
indic_position
(
)
=
=
POS_SMVD
)
new_reph_pos
-
-
;
if
(
!
indic_plan
-
>
uniscribe_bug_compatible
&
&
unlikely
(
is_halant
(
info
[
new_reph_pos
]
)
)
)
{
for
(
unsigned
int
i
=
base
+
1
;
i
<
new_reph_pos
;
i
+
+
)
if
(
info
[
i
]
.
indic_category
(
)
=
=
I_Cat
(
M
)
)
{
new_reph_pos
-
-
;
}
}
goto
reph_move
;
}
reph_move
:
{
buffer
-
>
merge_clusters
(
start
new_reph_pos
+
1
)
;
hb_glyph_info_t
reph
=
info
[
start
]
;
memmove
(
&
info
[
start
]
&
info
[
start
+
1
]
(
new_reph_pos
-
start
)
*
sizeof
(
info
[
0
]
)
)
;
info
[
new_reph_pos
]
=
reph
;
if
(
start
<
base
&
&
base
<
=
new_reph_pos
)
base
-
-
;
}
}
if
(
try_pref
&
&
base
+
1
<
end
)
{
for
(
unsigned
int
i
=
base
+
1
;
i
<
end
;
i
+
+
)
if
(
(
info
[
i
]
.
mask
&
indic_plan
-
>
mask_array
[
INDIC_PREF
]
)
!
=
0
)
{
if
(
_hb_glyph_info_ligated_and_didnt_multiply
(
&
info
[
i
]
)
)
{
unsigned
int
new_pos
=
base
;
if
(
buffer
-
>
props
.
script
!
=
HB_SCRIPT_MALAYALAM
&
&
buffer
-
>
props
.
script
!
=
HB_SCRIPT_TAMIL
)
{
while
(
new_pos
>
start
&
&
!
(
is_one_of
(
info
[
new_pos
-
1
]
FLAG
(
I_Cat
(
M
)
)
|
FLAG
(
I_Cat
(
H
)
)
)
)
)
new_pos
-
-
;
}
if
(
new_pos
>
start
&
&
is_halant
(
info
[
new_pos
-
1
]
)
)
{
if
(
new_pos
<
end
&
&
is_joiner
(
info
[
new_pos
]
)
)
new_pos
+
+
;
}
{
unsigned
int
old_pos
=
i
;
buffer
-
>
merge_clusters
(
new_pos
old_pos
+
1
)
;
hb_glyph_info_t
tmp
=
info
[
old_pos
]
;
memmove
(
&
info
[
new_pos
+
1
]
&
info
[
new_pos
]
(
old_pos
-
new_pos
)
*
sizeof
(
info
[
0
]
)
)
;
info
[
new_pos
]
=
tmp
;
if
(
new_pos
<
=
base
&
&
base
<
old_pos
)
base
+
+
;
}
}
break
;
}
}
if
(
info
[
start
]
.
indic_position
(
)
=
=
POS_PRE_M
)
{
if
(
!
start
|
|
!
(
FLAG_UNSAFE
(
_hb_glyph_info_get_general_category
(
&
info
[
start
-
1
]
)
)
&
FLAG_RANGE
(
HB_UNICODE_GENERAL_CATEGORY_FORMAT
HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK
)
)
)
info
[
start
]
.
mask
|
=
indic_plan
-
>
mask_array
[
INDIC_INIT
]
;
else
buffer
-
>
unsafe_to_break
(
start
-
1
start
+
1
)
;
}
if
(
indic_plan
-
>
uniscribe_bug_compatible
)
{
switch
(
(
hb_tag_t
)
plan
-
>
props
.
script
)
{
case
HB_SCRIPT_TAMIL
:
break
;
default
:
buffer
-
>
merge_clusters
(
start
end
)
;
break
;
}
}
}
static
void
final_reordering_indic
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
HB_UNUSED
hb_buffer_t
*
buffer
)
{
unsigned
int
count
=
buffer
-
>
len
;
if
(
unlikely
(
!
count
)
)
return
;
if
(
buffer
-
>
message
(
font
"
start
reordering
indic
final
"
)
)
{
foreach_syllable
(
buffer
start
end
)
final_reordering_syllable_indic
(
plan
buffer
start
end
)
;
(
void
)
buffer
-
>
message
(
font
"
end
reordering
indic
final
"
)
;
}
HB_BUFFER_DEALLOCATE_VAR
(
buffer
indic_category
)
;
HB_BUFFER_DEALLOCATE_VAR
(
buffer
indic_position
)
;
}
static
void
preprocess_text_indic
(
const
hb_ot_shape_plan_t
*
plan
hb_buffer_t
*
buffer
hb_font_t
*
font
)
{
const
indic_shape_plan_t
*
indic_plan
=
(
const
indic_shape_plan_t
*
)
plan
-
>
data
;
if
(
!
indic_plan
-
>
uniscribe_bug_compatible
)
_hb_preprocess_text_vowel_constraints
(
plan
buffer
font
)
;
}
static
bool
decompose_indic
(
const
hb_ot_shape_normalize_context_t
*
c
hb_codepoint_t
ab
hb_codepoint_t
*
a
hb_codepoint_t
*
b
)
{
switch
(
ab
)
{
case
0x0931u
:
return
false
;
case
0x09DCu
:
return
false
;
case
0x09DDu
:
return
false
;
case
0x0B94u
:
return
false
;
#
if
0
case
0x0B57u
:
*
a
=
no
decomp
-
>
RIGHT
;
return
true
;
#
endif
}
return
(
bool
)
c
-
>
unicode
-
>
decompose
(
ab
a
b
)
;
}
static
bool
compose_indic
(
const
hb_ot_shape_normalize_context_t
*
c
hb_codepoint_t
a
hb_codepoint_t
b
hb_codepoint_t
*
ab
)
{
if
(
HB_UNICODE_GENERAL_CATEGORY_IS_MARK
(
c
-
>
unicode
-
>
general_category
(
a
)
)
)
return
false
;
if
(
a
=
=
0x09AFu
&
&
b
=
=
0x09BCu
)
{
*
ab
=
0x09DFu
;
return
true
;
}
return
(
bool
)
c
-
>
unicode
-
>
compose
(
a
b
ab
)
;
}
const
hb_ot_shaper_t
_hb_ot_shaper_indic
=
{
collect_features_indic
override_features_indic
data_create_indic
data_destroy_indic
preprocess_text_indic
nullptr
decompose_indic
compose_indic
setup_masks_indic
nullptr
HB_TAG_NONE
HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT
HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE
false
}
;
#
endif
