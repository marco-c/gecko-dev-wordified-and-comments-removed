#
include
"
hb
.
hh
"
#
ifndef
HB_NO_OT_SHAPE
#
include
"
hb
-
ot
-
shaper
-
khmer
-
machine
.
hh
"
#
include
"
hb
-
ot
-
shaper
-
indic
.
hh
"
#
include
"
hb
-
ot
-
layout
.
hh
"
static
const
hb_ot_map_feature_t
khmer_features
[
]
=
{
{
HB_TAG
(
'
p
'
'
r
'
'
e
'
'
f
'
)
F_MANUAL_JOINERS
|
F_PER_SYLLABLE
}
{
HB_TAG
(
'
b
'
'
l
'
'
w
'
'
f
'
)
F_MANUAL_JOINERS
|
F_PER_SYLLABLE
}
{
HB_TAG
(
'
a
'
'
b
'
'
v
'
'
f
'
)
F_MANUAL_JOINERS
|
F_PER_SYLLABLE
}
{
HB_TAG
(
'
p
'
'
s
'
'
t
'
'
f
'
)
F_MANUAL_JOINERS
|
F_PER_SYLLABLE
}
{
HB_TAG
(
'
c
'
'
f
'
'
a
'
'
r
'
)
F_MANUAL_JOINERS
|
F_PER_SYLLABLE
}
{
HB_TAG
(
'
p
'
'
r
'
'
e
'
'
s
'
)
F_GLOBAL_MANUAL_JOINERS
}
{
HB_TAG
(
'
a
'
'
b
'
'
v
'
'
s
'
)
F_GLOBAL_MANUAL_JOINERS
}
{
HB_TAG
(
'
b
'
'
l
'
'
w
'
'
s
'
)
F_GLOBAL_MANUAL_JOINERS
}
{
HB_TAG
(
'
p
'
'
s
'
'
t
'
'
s
'
)
F_GLOBAL_MANUAL_JOINERS
}
}
;
enum
{
KHMER_PREF
KHMER_BLWF
KHMER_ABVF
KHMER_PSTF
KHMER_CFAR
_KHMER_PRES
_KHMER_ABVS
_KHMER_BLWS
_KHMER_PSTS
KHMER_NUM_FEATURES
KHMER_BASIC_FEATURES
=
_KHMER_PRES
}
;
static
inline
void
set_khmer_properties
(
hb_glyph_info_t
&
info
)
{
hb_codepoint_t
u
=
info
.
codepoint
;
unsigned
int
type
=
hb_indic_get_categories
(
u
)
;
info
.
khmer_category
(
)
=
(
khmer_category_t
)
(
type
&
0xFFu
)
;
}
static
void
setup_syllables_khmer
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
hb_buffer_t
*
buffer
)
;
static
void
reorder_khmer
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
hb_buffer_t
*
buffer
)
;
static
void
collect_features_khmer
(
hb_ot_shape_planner_t
*
plan
)
{
hb_ot_map_builder_t
*
map
=
&
plan
-
>
map
;
map
-
>
add_gsub_pause
(
setup_syllables_khmer
)
;
map
-
>
add_gsub_pause
(
reorder_khmer
)
;
map
-
>
enable_feature
(
HB_TAG
(
'
l
'
'
o
'
'
c
'
'
l
'
)
F_PER_SYLLABLE
)
;
map
-
>
enable_feature
(
HB_TAG
(
'
c
'
'
c
'
'
m
'
'
p
'
)
F_PER_SYLLABLE
)
;
unsigned
int
i
=
0
;
for
(
;
i
<
KHMER_BASIC_FEATURES
;
i
+
+
)
map
-
>
add_feature
(
khmer_features
[
i
]
)
;
map
-
>
add_gsub_pause
(
hb_syllabic_clear_var
)
;
for
(
;
i
<
KHMER_NUM_FEATURES
;
i
+
+
)
map
-
>
add_feature
(
khmer_features
[
i
]
)
;
}
static
void
override_features_khmer
(
hb_ot_shape_planner_t
*
plan
)
{
hb_ot_map_builder_t
*
map
=
&
plan
-
>
map
;
map
-
>
enable_feature
(
HB_TAG
(
'
c
'
'
l
'
'
i
'
'
g
'
)
)
;
if
(
hb_options
(
)
.
uniscribe_bug_compatible
)
{
map
-
>
disable_feature
(
HB_TAG
(
'
k
'
'
e
'
'
r
'
'
n
'
)
)
;
}
map
-
>
disable_feature
(
HB_TAG
(
'
l
'
'
i
'
'
g
'
'
a
'
)
)
;
}
struct
khmer_shape_plan_t
{
hb_mask_t
mask_array
[
KHMER_NUM_FEATURES
]
;
}
;
static
void
*
data_create_khmer
(
const
hb_ot_shape_plan_t
*
plan
)
{
khmer_shape_plan_t
*
khmer_plan
=
(
khmer_shape_plan_t
*
)
hb_calloc
(
1
sizeof
(
khmer_shape_plan_t
)
)
;
if
(
unlikely
(
!
khmer_plan
)
)
return
nullptr
;
for
(
unsigned
int
i
=
0
;
i
<
ARRAY_LENGTH
(
khmer_plan
-
>
mask_array
)
;
i
+
+
)
khmer_plan
-
>
mask_array
[
i
]
=
(
khmer_features
[
i
]
.
flags
&
F_GLOBAL
)
?
0
:
plan
-
>
map
.
get_1_mask
(
khmer_features
[
i
]
.
tag
)
;
return
khmer_plan
;
}
static
void
data_destroy_khmer
(
void
*
data
)
{
hb_free
(
data
)
;
}
static
void
setup_masks_khmer
(
const
hb_ot_shape_plan_t
*
plan
HB_UNUSED
hb_buffer_t
*
buffer
hb_font_t
*
font
HB_UNUSED
)
{
HB_BUFFER_ALLOCATE_VAR
(
buffer
khmer_category
)
;
unsigned
int
count
=
buffer
-
>
len
;
hb_glyph_info_t
*
info
=
buffer
-
>
info
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
set_khmer_properties
(
info
[
i
]
)
;
}
static
void
setup_syllables_khmer
(
const
hb_ot_shape_plan_t
*
plan
HB_UNUSED
hb_font_t
*
font
HB_UNUSED
hb_buffer_t
*
buffer
)
{
HB_BUFFER_ALLOCATE_VAR
(
buffer
syllable
)
;
find_syllables_khmer
(
buffer
)
;
foreach_syllable
(
buffer
start
end
)
buffer
-
>
unsafe_to_break
(
start
end
)
;
}
static
void
reorder_consonant_syllable
(
const
hb_ot_shape_plan_t
*
plan
hb_face_t
*
face
HB_UNUSED
hb_buffer_t
*
buffer
unsigned
int
start
unsigned
int
end
)
{
const
khmer_shape_plan_t
*
khmer_plan
=
(
const
khmer_shape_plan_t
*
)
plan
-
>
data
;
hb_glyph_info_t
*
info
=
buffer
-
>
info
;
{
hb_mask_t
mask
=
khmer_plan
-
>
mask_array
[
KHMER_BLWF
]
|
khmer_plan
-
>
mask_array
[
KHMER_ABVF
]
|
khmer_plan
-
>
mask_array
[
KHMER_PSTF
]
;
for
(
unsigned
int
i
=
start
+
1
;
i
<
end
;
i
+
+
)
info
[
i
]
.
mask
|
=
mask
;
}
unsigned
int
num_coengs
=
0
;
for
(
unsigned
int
i
=
start
+
1
;
i
<
end
;
i
+
+
)
{
if
(
info
[
i
]
.
khmer_category
(
)
=
=
K_Cat
(
H
)
&
&
num_coengs
<
=
2
&
&
i
+
1
<
end
)
{
num_coengs
+
+
;
if
(
info
[
i
+
1
]
.
khmer_category
(
)
=
=
K_Cat
(
Ra
)
)
{
for
(
unsigned
int
j
=
0
;
j
<
2
;
j
+
+
)
info
[
i
+
j
]
.
mask
|
=
khmer_plan
-
>
mask_array
[
KHMER_PREF
]
;
buffer
-
>
merge_clusters
(
start
i
+
2
)
;
hb_glyph_info_t
t0
=
info
[
i
]
;
hb_glyph_info_t
t1
=
info
[
i
+
1
]
;
memmove
(
&
info
[
start
+
2
]
&
info
[
start
]
(
i
-
start
)
*
sizeof
(
info
[
0
]
)
)
;
info
[
start
]
=
t0
;
info
[
start
+
1
]
=
t1
;
if
(
khmer_plan
-
>
mask_array
[
KHMER_CFAR
]
)
for
(
unsigned
int
j
=
i
+
2
;
j
<
end
;
j
+
+
)
info
[
j
]
.
mask
|
=
khmer_plan
-
>
mask_array
[
KHMER_CFAR
]
;
num_coengs
=
2
;
}
}
else
if
(
info
[
i
]
.
khmer_category
(
)
=
=
K_Cat
(
VPre
)
)
{
buffer
-
>
merge_clusters
(
start
i
+
1
)
;
hb_glyph_info_t
t
=
info
[
i
]
;
memmove
(
&
info
[
start
+
1
]
&
info
[
start
]
(
i
-
start
)
*
sizeof
(
info
[
0
]
)
)
;
info
[
start
]
=
t
;
}
}
}
static
void
reorder_syllable_khmer
(
const
hb_ot_shape_plan_t
*
plan
hb_face_t
*
face
hb_buffer_t
*
buffer
unsigned
int
start
unsigned
int
end
)
{
khmer_syllable_type_t
syllable_type
=
(
khmer_syllable_type_t
)
(
buffer
-
>
info
[
start
]
.
syllable
(
)
&
0x0F
)
;
switch
(
syllable_type
)
{
case
khmer_broken_cluster
:
case
khmer_consonant_syllable
:
reorder_consonant_syllable
(
plan
face
buffer
start
end
)
;
break
;
case
khmer_non_khmer_cluster
:
break
;
}
}
static
void
reorder_khmer
(
const
hb_ot_shape_plan_t
*
plan
hb_font_t
*
font
hb_buffer_t
*
buffer
)
{
if
(
buffer
-
>
message
(
font
"
start
reordering
khmer
"
)
)
{
hb_syllabic_insert_dotted_circles
(
font
buffer
khmer_broken_cluster
K_Cat
(
DOTTEDCIRCLE
)
(
unsigned
)
-
1
)
;
foreach_syllable
(
buffer
start
end
)
reorder_syllable_khmer
(
plan
font
-
>
face
buffer
start
end
)
;
(
void
)
buffer
-
>
message
(
font
"
end
reordering
khmer
"
)
;
}
HB_BUFFER_DEALLOCATE_VAR
(
buffer
khmer_category
)
;
}
static
bool
decompose_khmer
(
const
hb_ot_shape_normalize_context_t
*
c
hb_codepoint_t
ab
hb_codepoint_t
*
a
hb_codepoint_t
*
b
)
{
switch
(
ab
)
{
case
0x17BEu
:
*
a
=
0x17C1u
;
*
b
=
0x17BEu
;
return
true
;
case
0x17BFu
:
*
a
=
0x17C1u
;
*
b
=
0x17BFu
;
return
true
;
case
0x17C0u
:
*
a
=
0x17C1u
;
*
b
=
0x17C0u
;
return
true
;
case
0x17C4u
:
*
a
=
0x17C1u
;
*
b
=
0x17C4u
;
return
true
;
case
0x17C5u
:
*
a
=
0x17C1u
;
*
b
=
0x17C5u
;
return
true
;
}
return
(
bool
)
c
-
>
unicode
-
>
decompose
(
ab
a
b
)
;
}
static
bool
compose_khmer
(
const
hb_ot_shape_normalize_context_t
*
c
hb_codepoint_t
a
hb_codepoint_t
b
hb_codepoint_t
*
ab
)
{
if
(
HB_UNICODE_GENERAL_CATEGORY_IS_MARK
(
c
-
>
unicode
-
>
general_category
(
a
)
)
)
return
false
;
return
(
bool
)
c
-
>
unicode
-
>
compose
(
a
b
ab
)
;
}
const
hb_ot_shaper_t
_hb_ot_shaper_khmer
=
{
collect_features_khmer
override_features_khmer
data_create_khmer
data_destroy_khmer
nullptr
nullptr
decompose_khmer
compose_khmer
setup_masks_khmer
nullptr
HB_TAG_NONE
HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT
HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE
false
}
;
#
endif
