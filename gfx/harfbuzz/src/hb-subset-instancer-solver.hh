#
ifndef
HB_SUBSET_INSTANCER_SOLVER_HH
#
define
HB_SUBSET_INSTANCER_SOLVER_HH
#
include
"
hb
.
hh
"
struct
TripleDistances
{
TripleDistances
(
)
:
negative
(
1
.
f
)
positive
(
1
.
f
)
{
}
TripleDistances
(
float
neg_
float
pos_
)
:
negative
(
neg_
)
positive
(
pos_
)
{
}
TripleDistances
(
float
min
float
default_
float
max
)
{
negative
=
default_
-
min
;
positive
=
max
-
default_
;
}
float
negative
;
float
positive
;
}
;
struct
Triple
{
Triple
(
)
:
minimum
(
0
.
f
)
middle
(
0
.
f
)
maximum
(
0
.
f
)
{
}
Triple
(
float
minimum_
float
middle_
float
maximum_
)
:
minimum
(
minimum_
)
middle
(
middle_
)
maximum
(
maximum_
)
{
}
bool
operator
=
=
(
const
Triple
&
o
)
const
{
return
minimum
=
=
o
.
minimum
&
&
middle
=
=
o
.
middle
&
&
maximum
=
=
o
.
maximum
;
}
bool
operator
!
=
(
const
Triple
o
)
const
{
return
!
(
*
this
=
=
o
)
;
}
bool
is_point
(
)
const
{
return
minimum
=
=
middle
&
&
middle
=
=
maximum
;
}
bool
contains
(
float
point
)
const
{
return
minimum
<
=
point
&
&
point
<
=
maximum
;
}
uint32_t
hash
(
)
const
{
uint32_t
current
=
0x84222325
;
current
=
current
^
hb_hash
(
minimum
)
;
current
=
current
*
16777619
;
current
=
current
^
hb_hash
(
middle
)
;
current
=
current
*
16777619
;
current
=
current
^
hb_hash
(
maximum
)
;
current
=
current
*
16777619
;
return
current
;
}
float
minimum
;
float
middle
;
float
maximum
;
}
;
using
result_item_t
=
hb_pair_t
<
float
Triple
>
;
using
result_t
=
hb_vector_t
<
result_item_t
>
;
HB_INTERNAL
float
renormalizeValue
(
float
v
const
Triple
&
triple
const
TripleDistances
&
triple_distances
bool
extrapolate
=
true
)
;
HB_INTERNAL
result_t
rebase_tent
(
Triple
tent
Triple
axisLimit
TripleDistances
axis_triple_distances
)
;
#
endif
