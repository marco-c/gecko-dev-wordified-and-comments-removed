#
ifndef
HB_AAT_LAYOUT_MORX_TABLE_HH
#
define
HB_AAT_LAYOUT_MORX_TABLE_HH
#
include
"
hb
-
open
-
type
.
hh
"
#
include
"
hb
-
aat
-
layout
-
common
.
hh
"
#
include
"
hb
-
ot
-
layout
-
common
.
hh
"
#
include
"
hb
-
ot
-
layout
-
gdef
-
table
.
hh
"
#
include
"
hb
-
aat
-
map
.
hh
"
#
define
HB_AAT_TAG_morx
HB_TAG
(
'
m
'
'
o
'
'
r
'
'
x
'
)
#
define
HB_AAT_TAG_mort
HB_TAG
(
'
m
'
'
o
'
'
r
'
'
t
'
)
namespace
AAT
{
using
namespace
OT
;
template
<
typename
Types
>
struct
RearrangementSubtable
{
typedef
typename
Types
:
:
HBUINT
HBUINT
;
typedef
void
EntryData
;
struct
driver_context_t
{
static
constexpr
bool
in_place
=
true
;
enum
Flags
{
MarkFirst
=
0x8000
DontAdvance
=
0x4000
MarkLast
=
0x2000
Reserved
=
0x1FF0
Verb
=
0x000F
}
;
driver_context_t
(
const
RearrangementSubtable
*
table
HB_UNUSED
)
:
ret
(
false
)
start
(
0
)
end
(
0
)
{
}
bool
is_actionable
(
StateTableDriver
<
Types
EntryData
>
*
driver
HB_UNUSED
const
Entry
<
EntryData
>
&
entry
)
{
return
(
entry
.
flags
&
Verb
)
&
&
start
<
end
;
}
void
transition
(
StateTableDriver
<
Types
EntryData
>
*
driver
const
Entry
<
EntryData
>
&
entry
)
{
hb_buffer_t
*
buffer
=
driver
-
>
buffer
;
unsigned
int
flags
=
entry
.
flags
;
if
(
flags
&
MarkFirst
)
start
=
buffer
-
>
idx
;
if
(
flags
&
MarkLast
)
end
=
hb_min
(
buffer
-
>
idx
+
1
buffer
-
>
len
)
;
if
(
(
flags
&
Verb
)
&
&
start
<
end
)
{
const
unsigned
char
map
[
16
]
=
{
0x00
0x10
0x01
0x11
0x20
0x30
0x02
0x03
0x12
0x13
0x21
0x31
0x22
0x32
0x23
0x33
}
;
unsigned
int
m
=
map
[
flags
&
Verb
]
;
unsigned
int
l
=
hb_min
(
2u
m
>
>
4
)
;
unsigned
int
r
=
hb_min
(
2u
m
&
0x0F
)
;
bool
reverse_l
=
3
=
=
(
m
>
>
4
)
;
bool
reverse_r
=
3
=
=
(
m
&
0x0F
)
;
if
(
end
-
start
>
=
l
+
r
&
&
end
-
start
<
=
HB_MAX_CONTEXT_LENGTH
)
{
buffer
-
>
merge_clusters
(
start
hb_min
(
buffer
-
>
idx
+
1
buffer
-
>
len
)
)
;
buffer
-
>
merge_clusters
(
start
end
)
;
hb_glyph_info_t
*
info
=
buffer
-
>
info
;
hb_glyph_info_t
buf
[
4
]
;
memcpy
(
buf
info
+
start
l
*
sizeof
(
buf
[
0
]
)
)
;
memcpy
(
buf
+
2
info
+
end
-
r
r
*
sizeof
(
buf
[
0
]
)
)
;
if
(
l
!
=
r
)
memmove
(
info
+
start
+
r
info
+
start
+
l
(
end
-
start
-
l
-
r
)
*
sizeof
(
buf
[
0
]
)
)
;
memcpy
(
info
+
start
buf
+
2
r
*
sizeof
(
buf
[
0
]
)
)
;
memcpy
(
info
+
end
-
l
buf
l
*
sizeof
(
buf
[
0
]
)
)
;
if
(
reverse_l
)
{
buf
[
0
]
=
info
[
end
-
1
]
;
info
[
end
-
1
]
=
info
[
end
-
2
]
;
info
[
end
-
2
]
=
buf
[
0
]
;
}
if
(
reverse_r
)
{
buf
[
0
]
=
info
[
start
]
;
info
[
start
]
=
info
[
start
+
1
]
;
info
[
start
+
1
]
=
buf
[
0
]
;
}
}
}
}
public
:
bool
ret
;
private
:
unsigned
int
start
;
unsigned
int
end
;
}
;
bool
apply
(
hb_aat_apply_context_t
*
c
)
const
{
TRACE_APPLY
(
this
)
;
driver_context_t
dc
(
this
)
;
StateTableDriver
<
Types
EntryData
>
driver
(
machine
c
-
>
buffer
c
-
>
face
)
;
driver
.
drive
(
&
dc
)
;
return_trace
(
dc
.
ret
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
machine
.
sanitize
(
c
)
)
;
}
protected
:
StateTable
<
Types
EntryData
>
machine
;
public
:
DEFINE_SIZE_STATIC
(
16
)
;
}
;
template
<
typename
Types
>
struct
ContextualSubtable
{
typedef
typename
Types
:
:
HBUINT
HBUINT
;
struct
EntryData
{
HBUINT16
markIndex
;
HBUINT16
currentIndex
;
public
:
DEFINE_SIZE_STATIC
(
4
)
;
}
;
struct
driver_context_t
{
static
constexpr
bool
in_place
=
true
;
enum
Flags
{
SetMark
=
0x8000
DontAdvance
=
0x4000
Reserved
=
0x3FFF
}
;
driver_context_t
(
const
ContextualSubtable
*
table_
hb_aat_apply_context_t
*
c_
)
:
ret
(
false
)
c
(
c_
)
gdef
(
*
c
-
>
gdef_table
)
mark_set
(
false
)
has_glyph_classes
(
gdef
.
has_glyph_classes
(
)
)
mark
(
0
)
table
(
table_
)
subs
(
table
+
table
-
>
substitutionTables
)
{
}
bool
is_actionable
(
StateTableDriver
<
Types
EntryData
>
*
driver
const
Entry
<
EntryData
>
&
entry
)
{
hb_buffer_t
*
buffer
=
driver
-
>
buffer
;
if
(
buffer
-
>
idx
=
=
buffer
-
>
len
&
&
!
mark_set
)
return
false
;
return
entry
.
data
.
markIndex
!
=
0xFFFF
|
|
entry
.
data
.
currentIndex
!
=
0xFFFF
;
}
void
transition
(
StateTableDriver
<
Types
EntryData
>
*
driver
const
Entry
<
EntryData
>
&
entry
)
{
hb_buffer_t
*
buffer
=
driver
-
>
buffer
;
if
(
buffer
-
>
idx
=
=
buffer
-
>
len
&
&
!
mark_set
)
return
;
const
HBGlyphID16
*
replacement
;
replacement
=
nullptr
;
if
(
Types
:
:
extended
)
{
if
(
entry
.
data
.
markIndex
!
=
0xFFFF
)
{
const
Lookup
<
HBGlyphID16
>
&
lookup
=
subs
[
entry
.
data
.
markIndex
]
;
replacement
=
lookup
.
get_value
(
buffer
-
>
info
[
mark
]
.
codepoint
driver
-
>
num_glyphs
)
;
}
}
else
{
unsigned
int
offset
=
entry
.
data
.
markIndex
+
buffer
-
>
info
[
mark
]
.
codepoint
;
const
UnsizedArrayOf
<
HBGlyphID16
>
&
subs_old
=
(
const
UnsizedArrayOf
<
HBGlyphID16
>
&
)
subs
;
replacement
=
&
subs_old
[
Types
:
:
wordOffsetToIndex
(
offset
table
subs_old
.
arrayZ
)
]
;
if
(
!
replacement
-
>
sanitize
(
&
c
-
>
sanitizer
)
|
|
!
*
replacement
)
replacement
=
nullptr
;
}
if
(
replacement
)
{
buffer
-
>
unsafe_to_break
(
mark
hb_min
(
buffer
-
>
idx
+
1
buffer
-
>
len
)
)
;
buffer
-
>
info
[
mark
]
.
codepoint
=
*
replacement
;
if
(
has_glyph_classes
)
_hb_glyph_info_set_glyph_props
(
&
buffer
-
>
info
[
mark
]
gdef
.
get_glyph_props
(
*
replacement
)
)
;
ret
=
true
;
}
replacement
=
nullptr
;
unsigned
int
idx
=
hb_min
(
buffer
-
>
idx
buffer
-
>
len
-
1
)
;
if
(
Types
:
:
extended
)
{
if
(
entry
.
data
.
currentIndex
!
=
0xFFFF
)
{
const
Lookup
<
HBGlyphID16
>
&
lookup
=
subs
[
entry
.
data
.
currentIndex
]
;
replacement
=
lookup
.
get_value
(
buffer
-
>
info
[
idx
]
.
codepoint
driver
-
>
num_glyphs
)
;
}
}
else
{
unsigned
int
offset
=
entry
.
data
.
currentIndex
+
buffer
-
>
info
[
idx
]
.
codepoint
;
const
UnsizedArrayOf
<
HBGlyphID16
>
&
subs_old
=
(
const
UnsizedArrayOf
<
HBGlyphID16
>
&
)
subs
;
replacement
=
&
subs_old
[
Types
:
:
wordOffsetToIndex
(
offset
table
subs_old
.
arrayZ
)
]
;
if
(
!
replacement
-
>
sanitize
(
&
c
-
>
sanitizer
)
|
|
!
*
replacement
)
replacement
=
nullptr
;
}
if
(
replacement
)
{
buffer
-
>
info
[
idx
]
.
codepoint
=
*
replacement
;
if
(
has_glyph_classes
)
_hb_glyph_info_set_glyph_props
(
&
buffer
-
>
info
[
idx
]
gdef
.
get_glyph_props
(
*
replacement
)
)
;
ret
=
true
;
}
if
(
entry
.
flags
&
SetMark
)
{
mark_set
=
true
;
mark
=
buffer
-
>
idx
;
}
}
public
:
bool
ret
;
private
:
hb_aat_apply_context_t
*
c
;
const
OT
:
:
GDEF
&
gdef
;
bool
mark_set
;
bool
has_glyph_classes
;
unsigned
int
mark
;
const
ContextualSubtable
*
table
;
const
UnsizedListOfOffset16To
<
Lookup
<
HBGlyphID16
>
HBUINT
false
>
&
subs
;
}
;
bool
apply
(
hb_aat_apply_context_t
*
c
)
const
{
TRACE_APPLY
(
this
)
;
driver_context_t
dc
(
this
c
)
;
StateTableDriver
<
Types
EntryData
>
driver
(
machine
c
-
>
buffer
c
-
>
face
)
;
driver
.
drive
(
&
dc
)
;
return_trace
(
dc
.
ret
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
unsigned
int
num_entries
=
0
;
if
(
unlikely
(
!
machine
.
sanitize
(
c
&
num_entries
)
)
)
return_trace
(
false
)
;
if
(
!
Types
:
:
extended
)
return_trace
(
substitutionTables
.
sanitize
(
c
this
0
)
)
;
unsigned
int
num_lookups
=
0
;
const
Entry
<
EntryData
>
*
entries
=
machine
.
get_entries
(
)
;
for
(
unsigned
int
i
=
0
;
i
<
num_entries
;
i
+
+
)
{
const
EntryData
&
data
=
entries
[
i
]
.
data
;
if
(
data
.
markIndex
!
=
0xFFFF
)
num_lookups
=
hb_max
(
num_lookups
1u
+
data
.
markIndex
)
;
if
(
data
.
currentIndex
!
=
0xFFFF
)
num_lookups
=
hb_max
(
num_lookups
1u
+
data
.
currentIndex
)
;
}
return_trace
(
substitutionTables
.
sanitize
(
c
this
num_lookups
)
)
;
}
protected
:
StateTable
<
Types
EntryData
>
machine
;
NNOffsetTo
<
UnsizedListOfOffset16To
<
Lookup
<
HBGlyphID16
>
HBUINT
false
>
HBUINT
>
substitutionTables
;
public
:
DEFINE_SIZE_STATIC
(
20
)
;
}
;
template
<
bool
extended
>
struct
LigatureEntry
;
template
<
>
struct
LigatureEntry
<
true
>
{
enum
Flags
{
SetComponent
=
0x8000
DontAdvance
=
0x4000
PerformAction
=
0x2000
Reserved
=
0x1FFF
}
;
struct
EntryData
{
HBUINT16
ligActionIndex
;
public
:
DEFINE_SIZE_STATIC
(
2
)
;
}
;
static
bool
performAction
(
const
Entry
<
EntryData
>
&
entry
)
{
return
entry
.
flags
&
PerformAction
;
}
static
unsigned
int
ligActionIndex
(
const
Entry
<
EntryData
>
&
entry
)
{
return
entry
.
data
.
ligActionIndex
;
}
}
;
template
<
>
struct
LigatureEntry
<
false
>
{
enum
Flags
{
SetComponent
=
0x8000
DontAdvance
=
0x4000
Offset
=
0x3FFF
}
;
typedef
void
EntryData
;
static
bool
performAction
(
const
Entry
<
EntryData
>
&
entry
)
{
return
entry
.
flags
&
Offset
;
}
static
unsigned
int
ligActionIndex
(
const
Entry
<
EntryData
>
&
entry
)
{
return
entry
.
flags
&
Offset
;
}
}
;
template
<
typename
Types
>
struct
LigatureSubtable
{
typedef
typename
Types
:
:
HBUINT
HBUINT
;
typedef
LigatureEntry
<
Types
:
:
extended
>
LigatureEntryT
;
typedef
typename
LigatureEntryT
:
:
EntryData
EntryData
;
struct
driver_context_t
{
static
constexpr
bool
in_place
=
false
;
enum
{
DontAdvance
=
LigatureEntryT
:
:
DontAdvance
}
;
enum
LigActionFlags
{
LigActionLast
=
0x80000000
LigActionStore
=
0x40000000
LigActionOffset
=
0x3FFFFFFF
}
;
driver_context_t
(
const
LigatureSubtable
*
table_
hb_aat_apply_context_t
*
c_
)
:
ret
(
false
)
c
(
c_
)
table
(
table_
)
ligAction
(
table
+
table
-
>
ligAction
)
component
(
table
+
table
-
>
component
)
ligature
(
table
+
table
-
>
ligature
)
match_length
(
0
)
{
}
bool
is_actionable
(
StateTableDriver
<
Types
EntryData
>
*
driver
HB_UNUSED
const
Entry
<
EntryData
>
&
entry
)
{
return
LigatureEntryT
:
:
performAction
(
entry
)
;
}
void
transition
(
StateTableDriver
<
Types
EntryData
>
*
driver
const
Entry
<
EntryData
>
&
entry
)
{
hb_buffer_t
*
buffer
=
driver
-
>
buffer
;
DEBUG_MSG
(
APPLY
nullptr
"
Ligature
transition
at
%
u
"
buffer
-
>
idx
)
;
if
(
entry
.
flags
&
LigatureEntryT
:
:
SetComponent
)
{
if
(
match_length
&
&
match_positions
[
(
match_length
-
1u
)
%
ARRAY_LENGTH
(
match_positions
)
]
=
=
buffer
-
>
out_len
)
match_length
-
-
;
match_positions
[
match_length
+
+
%
ARRAY_LENGTH
(
match_positions
)
]
=
buffer
-
>
out_len
;
DEBUG_MSG
(
APPLY
nullptr
"
Set
component
at
%
u
"
buffer
-
>
out_len
)
;
}
if
(
LigatureEntryT
:
:
performAction
(
entry
)
)
{
DEBUG_MSG
(
APPLY
nullptr
"
Perform
action
with
%
u
"
match_length
)
;
unsigned
int
end
=
buffer
-
>
out_len
;
if
(
unlikely
(
!
match_length
)
)
return
;
if
(
buffer
-
>
idx
>
=
buffer
-
>
len
)
return
;
unsigned
int
cursor
=
match_length
;
unsigned
int
action_idx
=
LigatureEntryT
:
:
ligActionIndex
(
entry
)
;
action_idx
=
Types
:
:
offsetToIndex
(
action_idx
table
ligAction
.
arrayZ
)
;
const
HBUINT32
*
actionData
=
&
ligAction
[
action_idx
]
;
unsigned
int
ligature_idx
=
0
;
unsigned
int
action
;
do
{
if
(
unlikely
(
!
cursor
)
)
{
DEBUG_MSG
(
APPLY
nullptr
"
Stack
underflow
"
)
;
match_length
=
0
;
break
;
}
DEBUG_MSG
(
APPLY
nullptr
"
Moving
to
stack
position
%
u
"
cursor
-
1
)
;
if
(
unlikely
(
!
buffer
-
>
move_to
(
match_positions
[
-
-
cursor
%
ARRAY_LENGTH
(
match_positions
)
]
)
)
)
return
;
if
(
unlikely
(
!
actionData
-
>
sanitize
(
&
c
-
>
sanitizer
)
)
)
break
;
action
=
*
actionData
;
uint32_t
uoffset
=
action
&
LigActionOffset
;
if
(
uoffset
&
0x20000000
)
uoffset
|
=
0xC0000000
;
int32_t
offset
=
(
int32_t
)
uoffset
;
unsigned
int
component_idx
=
buffer
-
>
cur
(
)
.
codepoint
+
offset
;
component_idx
=
Types
:
:
wordOffsetToIndex
(
component_idx
table
component
.
arrayZ
)
;
const
HBUINT16
&
componentData
=
component
[
component_idx
]
;
if
(
unlikely
(
!
componentData
.
sanitize
(
&
c
-
>
sanitizer
)
)
)
break
;
ligature_idx
+
=
componentData
;
DEBUG_MSG
(
APPLY
nullptr
"
Action
store
%
u
last
%
u
"
bool
(
action
&
LigActionStore
)
bool
(
action
&
LigActionLast
)
)
;
if
(
action
&
(
LigActionStore
|
LigActionLast
)
)
{
ligature_idx
=
Types
:
:
offsetToIndex
(
ligature_idx
table
ligature
.
arrayZ
)
;
const
HBGlyphID16
&
ligatureData
=
ligature
[
ligature_idx
]
;
if
(
unlikely
(
!
ligatureData
.
sanitize
(
&
c
-
>
sanitizer
)
)
)
break
;
hb_codepoint_t
lig
=
ligatureData
;
DEBUG_MSG
(
APPLY
nullptr
"
Produced
ligature
%
u
"
lig
)
;
if
(
unlikely
(
!
buffer
-
>
replace_glyph
(
lig
)
)
)
return
;
unsigned
int
lig_end
=
match_positions
[
(
match_length
-
1u
)
%
ARRAY_LENGTH
(
match_positions
)
]
+
1u
;
while
(
match_length
-
1u
>
cursor
)
{
DEBUG_MSG
(
APPLY
nullptr
"
Skipping
ligature
component
"
)
;
if
(
unlikely
(
!
buffer
-
>
move_to
(
match_positions
[
-
-
match_length
%
ARRAY_LENGTH
(
match_positions
)
]
)
)
)
return
;
if
(
unlikely
(
!
buffer
-
>
replace_glyph
(
DELETED_GLYPH
)
)
)
return
;
}
if
(
unlikely
(
!
buffer
-
>
move_to
(
lig_end
)
)
)
return
;
buffer
-
>
merge_out_clusters
(
match_positions
[
cursor
%
ARRAY_LENGTH
(
match_positions
)
]
buffer
-
>
out_len
)
;
}
actionData
+
+
;
}
while
(
!
(
action
&
LigActionLast
)
)
;
if
(
unlikely
(
!
buffer
-
>
move_to
(
end
)
)
)
return
;
}
}
public
:
bool
ret
;
private
:
hb_aat_apply_context_t
*
c
;
const
LigatureSubtable
*
table
;
const
UnsizedArrayOf
<
HBUINT32
>
&
ligAction
;
const
UnsizedArrayOf
<
HBUINT16
>
&
component
;
const
UnsizedArrayOf
<
HBGlyphID16
>
&
ligature
;
unsigned
int
match_length
;
unsigned
int
match_positions
[
HB_MAX_CONTEXT_LENGTH
]
;
}
;
bool
apply
(
hb_aat_apply_context_t
*
c
)
const
{
TRACE_APPLY
(
this
)
;
driver_context_t
dc
(
this
c
)
;
StateTableDriver
<
Types
EntryData
>
driver
(
machine
c
-
>
buffer
c
-
>
face
)
;
driver
.
drive
(
&
dc
)
;
return_trace
(
dc
.
ret
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
machine
.
sanitize
(
c
)
&
&
ligAction
&
&
component
&
&
ligature
)
;
}
protected
:
StateTable
<
Types
EntryData
>
machine
;
NNOffsetTo
<
UnsizedArrayOf
<
HBUINT32
>
HBUINT
>
ligAction
;
NNOffsetTo
<
UnsizedArrayOf
<
HBUINT16
>
HBUINT
>
component
;
NNOffsetTo
<
UnsizedArrayOf
<
HBGlyphID16
>
HBUINT
>
ligature
;
public
:
DEFINE_SIZE_STATIC
(
28
)
;
}
;
template
<
typename
Types
>
struct
NoncontextualSubtable
{
bool
apply
(
hb_aat_apply_context_t
*
c
)
const
{
TRACE_APPLY
(
this
)
;
const
OT
:
:
GDEF
&
gdef
(
*
c
-
>
gdef_table
)
;
bool
has_glyph_classes
=
gdef
.
has_glyph_classes
(
)
;
bool
ret
=
false
;
unsigned
int
num_glyphs
=
c
-
>
face
-
>
get_num_glyphs
(
)
;
hb_glyph_info_t
*
info
=
c
-
>
buffer
-
>
info
;
unsigned
int
count
=
c
-
>
buffer
-
>
len
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
const
HBGlyphID16
*
replacement
=
substitute
.
get_value
(
info
[
i
]
.
codepoint
num_glyphs
)
;
if
(
replacement
)
{
info
[
i
]
.
codepoint
=
*
replacement
;
if
(
has_glyph_classes
)
_hb_glyph_info_set_glyph_props
(
&
info
[
i
]
gdef
.
get_glyph_props
(
*
replacement
)
)
;
ret
=
true
;
}
}
return_trace
(
ret
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
substitute
.
sanitize
(
c
)
)
;
}
protected
:
Lookup
<
HBGlyphID16
>
substitute
;
public
:
DEFINE_SIZE_MIN
(
2
)
;
}
;
template
<
typename
Types
>
struct
InsertionSubtable
{
typedef
typename
Types
:
:
HBUINT
HBUINT
;
struct
EntryData
{
HBUINT16
currentInsertIndex
;
HBUINT16
markedInsertIndex
;
public
:
DEFINE_SIZE_STATIC
(
4
)
;
}
;
struct
driver_context_t
{
static
constexpr
bool
in_place
=
false
;
enum
Flags
{
SetMark
=
0x8000
DontAdvance
=
0x4000
CurrentIsKashidaLike
=
0x2000
MarkedIsKashidaLike
=
0x1000
CurrentInsertBefore
=
0x0800
MarkedInsertBefore
=
0x0400
CurrentInsertCount
=
0x3E0
MarkedInsertCount
=
0x001F
}
;
driver_context_t
(
const
InsertionSubtable
*
table
hb_aat_apply_context_t
*
c_
)
:
ret
(
false
)
c
(
c_
)
mark
(
0
)
insertionAction
(
table
+
table
-
>
insertionAction
)
{
}
bool
is_actionable
(
StateTableDriver
<
Types
EntryData
>
*
driver
HB_UNUSED
const
Entry
<
EntryData
>
&
entry
)
{
return
(
entry
.
flags
&
(
CurrentInsertCount
|
MarkedInsertCount
)
)
&
&
(
entry
.
data
.
currentInsertIndex
!
=
0xFFFF
|
|
entry
.
data
.
markedInsertIndex
!
=
0xFFFF
)
;
}
void
transition
(
StateTableDriver
<
Types
EntryData
>
*
driver
const
Entry
<
EntryData
>
&
entry
)
{
hb_buffer_t
*
buffer
=
driver
-
>
buffer
;
unsigned
int
flags
=
entry
.
flags
;
unsigned
mark_loc
=
buffer
-
>
out_len
;
if
(
entry
.
data
.
markedInsertIndex
!
=
0xFFFF
)
{
unsigned
int
count
=
(
flags
&
MarkedInsertCount
)
;
if
(
unlikely
(
(
buffer
-
>
max_ops
-
=
count
)
<
=
0
)
)
return
;
unsigned
int
start
=
entry
.
data
.
markedInsertIndex
;
const
HBGlyphID16
*
glyphs
=
&
insertionAction
[
start
]
;
if
(
unlikely
(
!
c
-
>
sanitizer
.
check_array
(
glyphs
count
)
)
)
count
=
0
;
bool
before
=
flags
&
MarkedInsertBefore
;
unsigned
int
end
=
buffer
-
>
out_len
;
if
(
unlikely
(
!
buffer
-
>
move_to
(
mark
)
)
)
return
;
if
(
buffer
-
>
idx
<
buffer
-
>
len
&
&
!
before
)
if
(
unlikely
(
!
buffer
-
>
copy_glyph
(
)
)
)
return
;
if
(
unlikely
(
!
buffer
-
>
replace_glyphs
(
0
count
glyphs
)
)
)
return
;
if
(
buffer
-
>
idx
<
buffer
-
>
len
&
&
!
before
)
buffer
-
>
skip_glyph
(
)
;
if
(
unlikely
(
!
buffer
-
>
move_to
(
end
+
count
)
)
)
return
;
buffer
-
>
unsafe_to_break_from_outbuffer
(
mark
hb_min
(
buffer
-
>
idx
+
1
buffer
-
>
len
)
)
;
}
if
(
flags
&
SetMark
)
mark
=
mark_loc
;
if
(
entry
.
data
.
currentInsertIndex
!
=
0xFFFF
)
{
unsigned
int
count
=
(
flags
&
CurrentInsertCount
)
>
>
5
;
if
(
unlikely
(
(
buffer
-
>
max_ops
-
=
count
)
<
=
0
)
)
return
;
unsigned
int
start
=
entry
.
data
.
currentInsertIndex
;
const
HBGlyphID16
*
glyphs
=
&
insertionAction
[
start
]
;
if
(
unlikely
(
!
c
-
>
sanitizer
.
check_array
(
glyphs
count
)
)
)
count
=
0
;
bool
before
=
flags
&
CurrentInsertBefore
;
unsigned
int
end
=
buffer
-
>
out_len
;
if
(
buffer
-
>
idx
<
buffer
-
>
len
&
&
!
before
)
if
(
unlikely
(
!
buffer
-
>
copy_glyph
(
)
)
)
return
;
if
(
unlikely
(
!
buffer
-
>
replace_glyphs
(
0
count
glyphs
)
)
)
return
;
if
(
buffer
-
>
idx
<
buffer
-
>
len
&
&
!
before
)
buffer
-
>
skip_glyph
(
)
;
if
(
unlikely
(
!
buffer
-
>
move_to
(
(
flags
&
DontAdvance
)
?
end
:
end
+
count
)
)
)
return
;
}
}
public
:
bool
ret
;
private
:
hb_aat_apply_context_t
*
c
;
unsigned
int
mark
;
const
UnsizedArrayOf
<
HBGlyphID16
>
&
insertionAction
;
}
;
bool
apply
(
hb_aat_apply_context_t
*
c
)
const
{
TRACE_APPLY
(
this
)
;
driver_context_t
dc
(
this
c
)
;
StateTableDriver
<
Types
EntryData
>
driver
(
machine
c
-
>
buffer
c
-
>
face
)
;
driver
.
drive
(
&
dc
)
;
return_trace
(
dc
.
ret
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
machine
.
sanitize
(
c
)
&
&
insertionAction
)
;
}
protected
:
StateTable
<
Types
EntryData
>
machine
;
NNOffsetTo
<
UnsizedArrayOf
<
HBGlyphID16
>
HBUINT
>
insertionAction
;
public
:
DEFINE_SIZE_STATIC
(
20
)
;
}
;
struct
Feature
{
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
public
:
HBUINT16
featureType
;
HBUINT16
featureSetting
;
HBUINT32
enableFlags
;
HBUINT32
disableFlags
;
public
:
DEFINE_SIZE_STATIC
(
12
)
;
}
;
template
<
typename
Types
>
struct
ChainSubtable
{
typedef
typename
Types
:
:
HBUINT
HBUINT
;
template
<
typename
T
>
friend
struct
Chain
;
unsigned
int
get_size
(
)
const
{
return
length
;
}
unsigned
int
get_type
(
)
const
{
return
coverage
&
0xFF
;
}
unsigned
int
get_coverage
(
)
const
{
return
coverage
>
>
(
sizeof
(
HBUINT
)
*
8
-
8
)
;
}
enum
Coverage
{
Vertical
=
0x80
Backwards
=
0x40
AllDirections
=
0x20
Logical
=
0x10
}
;
enum
Type
{
Rearrangement
=
0
Contextual
=
1
Ligature
=
2
Noncontextual
=
4
Insertion
=
5
}
;
template
<
typename
context_t
typename
.
.
.
Ts
>
typename
context_t
:
:
return_t
dispatch
(
context_t
*
c
Ts
&
&
.
.
.
ds
)
const
{
unsigned
int
subtable_type
=
get_type
(
)
;
TRACE_DISPATCH
(
this
subtable_type
)
;
switch
(
subtable_type
)
{
case
Rearrangement
:
return_trace
(
c
-
>
dispatch
(
u
.
rearrangement
std
:
:
forward
<
Ts
>
(
ds
)
.
.
.
)
)
;
case
Contextual
:
return_trace
(
c
-
>
dispatch
(
u
.
contextual
std
:
:
forward
<
Ts
>
(
ds
)
.
.
.
)
)
;
case
Ligature
:
return_trace
(
c
-
>
dispatch
(
u
.
ligature
std
:
:
forward
<
Ts
>
(
ds
)
.
.
.
)
)
;
case
Noncontextual
:
return_trace
(
c
-
>
dispatch
(
u
.
noncontextual
std
:
:
forward
<
Ts
>
(
ds
)
.
.
.
)
)
;
case
Insertion
:
return_trace
(
c
-
>
dispatch
(
u
.
insertion
std
:
:
forward
<
Ts
>
(
ds
)
.
.
.
)
)
;
default
:
return_trace
(
c
-
>
default_return_value
(
)
)
;
}
}
bool
apply
(
hb_aat_apply_context_t
*
c
)
const
{
TRACE_APPLY
(
this
)
;
hb_sanitize_with_object_t
with
(
&
c
-
>
sanitizer
this
)
;
return_trace
(
dispatch
(
c
)
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
!
length
.
sanitize
(
c
)
|
|
length
<
=
min_size
|
|
!
c
-
>
check_range
(
this
length
)
)
return_trace
(
false
)
;
hb_sanitize_with_object_t
with
(
c
this
)
;
return_trace
(
dispatch
(
c
)
)
;
}
protected
:
HBUINT
length
;
HBUINT
coverage
;
HBUINT32
subFeatureFlags
;
union
{
RearrangementSubtable
<
Types
>
rearrangement
;
ContextualSubtable
<
Types
>
contextual
;
LigatureSubtable
<
Types
>
ligature
;
NoncontextualSubtable
<
Types
>
noncontextual
;
InsertionSubtable
<
Types
>
insertion
;
}
u
;
public
:
DEFINE_SIZE_MIN
(
2
*
sizeof
(
HBUINT
)
+
4
)
;
}
;
template
<
typename
Types
>
struct
Chain
{
typedef
typename
Types
:
:
HBUINT
HBUINT
;
hb_mask_t
compile_flags
(
const
hb_aat_map_builder_t
*
map
)
const
{
hb_mask_t
flags
=
defaultFlags
;
{
unsigned
int
count
=
featureCount
;
for
(
unsigned
i
=
0
;
i
<
count
;
i
+
+
)
{
const
Feature
&
feature
=
featureZ
[
i
]
;
hb_aat_layout_feature_type_t
type
=
(
hb_aat_layout_feature_type_t
)
(
unsigned
int
)
feature
.
featureType
;
hb_aat_layout_feature_selector_t
setting
=
(
hb_aat_layout_feature_selector_t
)
(
unsigned
int
)
feature
.
featureSetting
;
retry
:
hb_aat_map_builder_t
:
:
feature_info_t
info
=
{
type
setting
false
0
}
;
if
(
map
-
>
features
.
bsearch
(
info
)
)
{
flags
&
=
feature
.
disableFlags
;
flags
|
=
feature
.
enableFlags
;
}
else
if
(
type
=
=
HB_AAT_LAYOUT_FEATURE_TYPE_LETTER_CASE
&
&
setting
=
=
HB_AAT_LAYOUT_FEATURE_SELECTOR_SMALL_CAPS
)
{
type
=
HB_AAT_LAYOUT_FEATURE_TYPE_LOWER_CASE
;
setting
=
HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_SMALL_CAPS
;
goto
retry
;
}
#
ifndef
HB_NO_AAT
else
if
(
type
=
=
HB_AAT_LAYOUT_FEATURE_TYPE_LANGUAGE_TAG_TYPE
&
&
setting
&
&
hb_language_matches
(
map
-
>
face
-
>
table
.
ltag
-
>
get_language
(
setting
-
1
)
map
-
>
props
.
language
)
)
{
flags
&
=
feature
.
disableFlags
;
flags
|
=
feature
.
enableFlags
;
}
#
endif
}
}
return
flags
;
}
void
apply
(
hb_aat_apply_context_t
*
c
hb_mask_t
flags
)
const
{
const
ChainSubtable
<
Types
>
*
subtable
=
&
StructAfter
<
ChainSubtable
<
Types
>
>
(
featureZ
.
as_array
(
featureCount
)
)
;
unsigned
int
count
=
subtableCount
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
bool
reverse
;
if
(
!
(
subtable
-
>
subFeatureFlags
&
flags
)
)
goto
skip
;
if
(
!
(
subtable
-
>
get_coverage
(
)
&
ChainSubtable
<
Types
>
:
:
AllDirections
)
&
&
HB_DIRECTION_IS_VERTICAL
(
c
-
>
buffer
-
>
props
.
direction
)
!
=
bool
(
subtable
-
>
get_coverage
(
)
&
ChainSubtable
<
Types
>
:
:
Vertical
)
)
goto
skip
;
reverse
=
subtable
-
>
get_coverage
(
)
&
ChainSubtable
<
Types
>
:
:
Logical
?
bool
(
subtable
-
>
get_coverage
(
)
&
ChainSubtable
<
Types
>
:
:
Backwards
)
:
bool
(
subtable
-
>
get_coverage
(
)
&
ChainSubtable
<
Types
>
:
:
Backwards
)
!
=
HB_DIRECTION_IS_BACKWARD
(
c
-
>
buffer
-
>
props
.
direction
)
;
if
(
!
c
-
>
buffer
-
>
message
(
c
-
>
font
"
start
chainsubtable
%
d
"
c
-
>
lookup_index
)
)
goto
skip
;
if
(
reverse
)
c
-
>
buffer
-
>
reverse
(
)
;
subtable
-
>
apply
(
c
)
;
if
(
reverse
)
c
-
>
buffer
-
>
reverse
(
)
;
(
void
)
c
-
>
buffer
-
>
message
(
c
-
>
font
"
end
chainsubtable
%
d
"
c
-
>
lookup_index
)
;
if
(
unlikely
(
!
c
-
>
buffer
-
>
successful
)
)
return
;
skip
:
subtable
=
&
StructAfter
<
ChainSubtable
<
Types
>
>
(
*
subtable
)
;
c
-
>
set_lookup_index
(
c
-
>
lookup_index
+
1
)
;
}
}
unsigned
int
get_size
(
)
const
{
return
length
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
unsigned
int
version
HB_UNUSED
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
!
length
.
sanitize
(
c
)
|
|
length
<
min_size
|
|
!
c
-
>
check_range
(
this
length
)
)
return_trace
(
false
)
;
if
(
!
c
-
>
check_array
(
featureZ
.
arrayZ
featureCount
)
)
return_trace
(
false
)
;
const
ChainSubtable
<
Types
>
*
subtable
=
&
StructAfter
<
ChainSubtable
<
Types
>
>
(
featureZ
.
as_array
(
featureCount
)
)
;
unsigned
int
count
=
subtableCount
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
!
subtable
-
>
sanitize
(
c
)
)
return_trace
(
false
)
;
subtable
=
&
StructAfter
<
ChainSubtable
<
Types
>
>
(
*
subtable
)
;
}
return_trace
(
true
)
;
}
protected
:
HBUINT32
defaultFlags
;
HBUINT32
length
;
HBUINT
featureCount
;
HBUINT
subtableCount
;
UnsizedArrayOf
<
Feature
>
featureZ
;
public
:
DEFINE_SIZE_MIN
(
8
+
2
*
sizeof
(
HBUINT
)
)
;
}
;
template
<
typename
Types
hb_tag_t
TAG
>
struct
mortmorx
{
static
constexpr
hb_tag_t
tableTag
=
TAG
;
bool
has_data
(
)
const
{
return
version
!
=
0
;
}
void
compile_flags
(
const
hb_aat_map_builder_t
*
mapper
hb_aat_map_t
*
map
)
const
{
const
Chain
<
Types
>
*
chain
=
&
firstChain
;
unsigned
int
count
=
chainCount
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
map
-
>
chain_flags
.
push
(
chain
-
>
compile_flags
(
mapper
)
)
;
chain
=
&
StructAfter
<
Chain
<
Types
>
>
(
*
chain
)
;
}
}
void
apply
(
hb_aat_apply_context_t
*
c
)
const
{
if
(
unlikely
(
!
c
-
>
buffer
-
>
successful
)
)
return
;
c
-
>
set_lookup_index
(
0
)
;
const
Chain
<
Types
>
*
chain
=
&
firstChain
;
unsigned
int
count
=
chainCount
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
chain
-
>
apply
(
c
c
-
>
plan
-
>
aat_map
.
chain_flags
[
i
]
)
;
if
(
unlikely
(
!
c
-
>
buffer
-
>
successful
)
)
return
;
chain
=
&
StructAfter
<
Chain
<
Types
>
>
(
*
chain
)
;
}
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
!
version
.
sanitize
(
c
)
|
|
!
version
|
|
!
chainCount
.
sanitize
(
c
)
)
return_trace
(
false
)
;
const
Chain
<
Types
>
*
chain
=
&
firstChain
;
unsigned
int
count
=
chainCount
;
for
(
unsigned
int
i
=
0
;
i
<
count
;
i
+
+
)
{
if
(
!
chain
-
>
sanitize
(
c
version
)
)
return_trace
(
false
)
;
chain
=
&
StructAfter
<
Chain
<
Types
>
>
(
*
chain
)
;
}
return_trace
(
true
)
;
}
protected
:
HBUINT16
version
;
HBUINT16
unused
;
HBUINT32
chainCount
;
Chain
<
Types
>
firstChain
;
public
:
DEFINE_SIZE_MIN
(
8
)
;
}
;
struct
morx
:
mortmorx
<
ExtendedTypes
HB_AAT_TAG_morx
>
{
}
;
struct
mort
:
mortmorx
<
ObsoleteTypes
HB_AAT_TAG_mort
>
{
}
;
}
#
endif
