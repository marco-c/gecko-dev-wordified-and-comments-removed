#
ifndef
HB_AAT_LAYOUT_OPBD_TABLE_HH
#
define
HB_AAT_LAYOUT_OPBD_TABLE_HH
#
include
"
hb
-
aat
-
layout
-
common
.
hh
"
#
include
"
hb
-
open
-
type
.
hh
"
#
define
HB_AAT_TAG_opbd
HB_TAG
(
'
o
'
'
p
'
'
b
'
'
d
'
)
namespace
AAT
{
struct
OpticalBounds
{
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
)
)
;
}
FWORD
leftSide
;
FWORD
topSide
;
FWORD
rightSide
;
FWORD
bottomSide
;
public
:
DEFINE_SIZE_STATIC
(
8
)
;
}
;
struct
opbdFormat0
{
bool
get_bounds
(
hb_font_t
*
font
hb_codepoint_t
glyph_id
hb_glyph_extents_t
*
extents
const
void
*
base
)
const
{
const
Offset16To
<
OpticalBounds
>
*
bounds_offset
=
lookupTable
.
get_value
(
glyph_id
font
-
>
face
-
>
get_num_glyphs
(
)
)
;
if
(
!
bounds_offset
)
return
false
;
const
OpticalBounds
&
bounds
=
base
+
*
bounds_offset
;
if
(
extents
)
*
extents
=
{
font
-
>
em_scale_x
(
bounds
.
leftSide
)
font
-
>
em_scale_y
(
bounds
.
topSide
)
font
-
>
em_scale_x
(
bounds
.
rightSide
)
font
-
>
em_scale_y
(
bounds
.
bottomSide
)
}
;
return
true
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
lookupTable
.
sanitize
(
c
base
)
)
)
;
}
protected
:
Lookup
<
Offset16To
<
OpticalBounds
>
>
lookupTable
;
public
:
DEFINE_SIZE_MIN
(
2
)
;
}
;
struct
opbdFormat1
{
bool
get_bounds
(
hb_font_t
*
font
hb_codepoint_t
glyph_id
hb_glyph_extents_t
*
extents
const
void
*
base
)
const
{
const
Offset16To
<
OpticalBounds
>
*
bounds_offset
=
lookupTable
.
get_value
(
glyph_id
font
-
>
face
-
>
get_num_glyphs
(
)
)
;
if
(
!
bounds_offset
)
return
false
;
const
OpticalBounds
&
bounds
=
base
+
*
bounds_offset
;
hb_position_t
left
=
0
top
=
0
right
=
0
bottom
=
0
ignore
;
if
(
font
-
>
get_glyph_contour_point
(
glyph_id
bounds
.
leftSide
&
left
&
ignore
)
|
|
font
-
>
get_glyph_contour_point
(
glyph_id
bounds
.
topSide
&
ignore
&
top
)
|
|
font
-
>
get_glyph_contour_point
(
glyph_id
bounds
.
rightSide
&
right
&
ignore
)
|
|
font
-
>
get_glyph_contour_point
(
glyph_id
bounds
.
bottomSide
&
ignore
&
bottom
)
)
{
if
(
extents
)
*
extents
=
{
left
top
right
bottom
}
;
return
true
;
}
return
false
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
lookupTable
.
sanitize
(
c
base
)
)
)
;
}
protected
:
Lookup
<
Offset16To
<
OpticalBounds
>
>
lookupTable
;
public
:
DEFINE_SIZE_MIN
(
2
)
;
}
;
struct
opbd
{
static
constexpr
hb_tag_t
tableTag
=
HB_AAT_TAG_opbd
;
bool
get_bounds
(
hb_font_t
*
font
hb_codepoint_t
glyph_id
hb_glyph_extents_t
*
extents
)
const
{
switch
(
format
)
{
case
0
:
return
u
.
format0
.
get_bounds
(
font
glyph_id
extents
this
)
;
case
1
:
return
u
.
format1
.
get_bounds
(
font
glyph_id
extents
this
)
;
default
:
return
false
;
}
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
unlikely
(
!
c
-
>
check_struct
(
this
)
|
|
version
.
major
!
=
1
)
)
return_trace
(
false
)
;
switch
(
format
)
{
case
0
:
return_trace
(
u
.
format0
.
sanitize
(
c
this
)
)
;
case
1
:
return_trace
(
u
.
format1
.
sanitize
(
c
this
)
)
;
default
:
return_trace
(
true
)
;
}
}
protected
:
FixedVersion
<
>
version
;
HBUINT16
format
;
union
{
opbdFormat0
format0
;
opbdFormat1
format1
;
}
u
;
public
:
DEFINE_SIZE_MIN
(
8
)
;
}
;
}
#
endif
