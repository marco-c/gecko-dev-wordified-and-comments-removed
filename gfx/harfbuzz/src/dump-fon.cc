#
include
"
hb
-
static
.
cc
"
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
"
hb
-
open
-
type
-
private
.
hh
"
template
<
typename
Type
int
Bytes
>
struct
LEInt
;
template
<
typename
Type
>
struct
LEInt
<
Type
1
>
{
public
:
inline
void
set
(
Type
V
)
{
v
=
V
;
}
inline
operator
Type
(
void
)
const
{
return
v
;
}
private
:
uint8_t
v
;
}
;
template
<
typename
Type
>
struct
LEInt
<
Type
2
>
{
public
:
inline
void
set
(
Type
V
)
{
v
[
1
]
=
(
V
>
>
8
)
&
0xFF
;
v
[
0
]
=
(
V
)
&
0xFF
;
}
inline
operator
Type
(
void
)
const
{
return
(
v
[
1
]
<
<
8
)
+
(
v
[
0
]
)
;
}
private
:
uint8_t
v
[
2
]
;
}
;
template
<
typename
Type
>
struct
LEInt
<
Type
3
>
{
public
:
inline
void
set
(
Type
V
)
{
v
[
2
]
=
(
V
>
>
16
)
&
0xFF
;
v
[
1
]
=
(
V
>
>
8
)
&
0xFF
;
v
[
0
]
=
(
V
)
&
0xFF
;
}
inline
operator
Type
(
void
)
const
{
return
(
v
[
2
]
<
<
16
)
+
(
v
[
1
]
<
<
8
)
+
(
v
[
0
]
)
;
}
private
:
uint8_t
v
[
3
]
;
}
;
template
<
typename
Type
>
struct
LEInt
<
Type
4
>
{
public
:
inline
void
set
(
Type
V
)
{
v
[
3
]
=
(
V
>
>
24
)
&
0xFF
;
v
[
2
]
=
(
V
>
>
16
)
&
0xFF
;
v
[
1
]
=
(
V
>
>
8
)
&
0xFF
;
v
[
0
]
=
(
V
)
&
0xFF
;
}
inline
operator
Type
(
void
)
const
{
return
(
v
[
3
]
<
<
24
)
+
(
v
[
2
]
<
<
16
)
+
(
v
[
1
]
<
<
8
)
+
(
v
[
0
]
)
;
}
private
:
uint8_t
v
[
4
]
;
}
;
template
<
typename
Type
unsigned
int
Size
>
struct
LEIntType
{
inline
void
set
(
Type
i
)
{
v
.
set
(
i
)
;
}
inline
operator
Type
(
void
)
const
{
return
v
;
}
inline
bool
sanitize
(
OT
:
:
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
)
)
;
}
protected
:
LEInt
<
Type
Size
>
v
;
public
:
DEFINE_SIZE_STATIC
(
Size
)
;
}
;
typedef
LEIntType
<
uint8_t
1
>
LEUINT8
;
typedef
LEIntType
<
int8_t
1
>
LEINT8
;
typedef
LEIntType
<
uint16_t
2
>
LEUINT16
;
typedef
LEIntType
<
int16_t
2
>
LEINT16
;
typedef
LEIntType
<
uint32_t
4
>
LEUINT32
;
typedef
LEIntType
<
int32_t
4
>
LEINT32
;
typedef
LEIntType
<
uint32_t
3
>
LEUINT24
;
struct
LE_FONTINFO16
{
inline
bool
sanitize
(
OT
:
:
hb_sanitize_context_t
*
c
unsigned
int
length
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
c
-
>
check_range
(
this
length
)
)
)
;
}
enum
charset_t
{
ANSI
=
0x00
DEFAULT
=
0x01
SYMBOL
=
0x02
SHIFTJIS
=
0x80
HANGUL
=
0x81
GB2312
=
0x86
CHINESEBIG5
=
0x88
GREEK
=
0xA1
TURKISH
=
0xA2
HEBREW
=
0xB1
ARABIC
=
0xB2
BALTIC
=
0xBA
RUSSIAN
=
0xCC
THAI
=
0xDE
EE
=
0xEE
OEM
=
0xFF
}
;
inline
const
char
*
get_charset
(
)
const
{
switch
(
dfCharSet
)
{
case
ANSI
:
return
"
ISO8859
"
;
case
DEFAULT
:
return
"
WinDefault
"
;
case
SYMBOL
:
return
"
Symbol
"
;
case
SHIFTJIS
:
return
"
JISX0208
.
1983
"
;
case
HANGUL
:
return
"
MSHangul
"
;
case
GB2312
:
return
"
GB2312
.
1980
"
;
case
CHINESEBIG5
:
return
"
Big5
"
;
case
GREEK
:
return
"
CP1253
"
;
case
TURKISH
:
return
"
CP1254
"
;
case
HEBREW
:
return
"
CP1255
"
;
case
ARABIC
:
return
"
CP1256
"
;
case
BALTIC
:
return
"
CP1257
"
;
case
RUSSIAN
:
return
"
CP1251
"
;
case
THAI
:
return
"
CP874
"
;
case
EE
:
return
"
CP1250
"
;
case
OEM
:
return
"
OEM
"
;
default
:
return
"
Unknown
"
;
}
}
inline
unsigned
int
get_version
(
)
const
{
return
dfVersion
;
}
inline
unsigned
int
get_weight
(
)
const
{
return
dfWeight
;
}
enum
weight_t
{
DONTCARE
=
0
THIN
=
100
EXTRALIGHT
=
200
ULTRALIGHT
=
200
LIGHT
=
300
NORMAL
=
400
REGULAR
=
400
MEDIUM
=
500
SEMIBOLD
=
600
DEMIBOLD
=
600
BOLD
=
700
EXTRABOLD
=
800
ULTRABOLD
=
800
HEAVY
=
900
BLACK
=
900
}
;
inline
void
dump
(
)
const
{
unsigned
int
ctstart
;
unsigned
int
ctsize
;
if
(
dfVersion
=
=
0x200
)
{
ctstart
=
0x76
;
ctsize
=
4
;
}
else
{
return
;
ctstart
=
0x94
;
ctsize
=
6
;
}
for
(
unsigned
int
i
=
dfFirstChar
;
i
<
dfLastChar
;
+
+
i
)
{
unsigned
int
entry
=
ctstart
+
ctsize
*
(
i
-
dfFirstChar
)
;
unsigned
int
w
=
(
uint16_t
)
OT
:
:
StructAtOffset
<
LEUINT16
>
(
this
entry
)
;
unsigned
int
off
;
if
(
ctsize
=
=
4
)
off
=
(
uint16_t
)
OT
:
:
StructAtOffset
<
LEUINT16
>
(
this
entry
+
2
)
;
else
off
=
(
uint32_t
)
OT
:
:
StructAtOffset
<
LEUINT32
>
(
this
entry
+
2
)
;
unsigned
int
widthbytes
=
(
w
+
7
)
/
8
;
for
(
unsigned
int
j
=
0
;
j
<
dfPixHeight
;
+
+
j
)
{
for
(
unsigned
int
k
=
0
;
k
<
widthbytes
;
+
+
k
)
{
unsigned
int
bytepos
=
off
+
k
*
dfPixHeight
+
j
;
const
uint8_t
b
=
(
uint8_t
)
OT
:
:
StructAtOffset
<
LEINT8
>
(
this
bytepos
)
;
for
(
unsigned
int
a
=
128
;
a
>
0
;
a
>
>
=
1
)
printf
(
b
&
a
?
"
x
"
:
"
.
"
)
;
}
printf
(
"
\
n
"
)
;
}
printf
(
"
\
n
\
n
"
)
;
}
}
protected
:
LEUINT16
dfVersion
;
LEUINT32
dfSize
;
LEUINT8
dfCopyright
[
60
]
;
LEUINT16
dfType
;
LEUINT16
dfPoints
;
LEUINT16
dfVertRes
;
LEUINT16
dfHorizRes
;
LEUINT16
dfAscent
;
LEUINT16
dfInternalLeading
;
LEUINT16
dfExternalLeading
;
LEUINT8
dfItalic
;
LEUINT8
dfUnderline
;
LEUINT8
dfStrikeOut
;
LEUINT16
dfWeight
;
LEUINT8
dfCharSet
;
LEUINT16
dfPixWidth
;
LEUINT16
dfPixHeight
;
LEUINT8
dfPitchAndFamily
;
LEUINT16
dfAvgWidth
;
LEUINT16
dfMaxWidth
;
LEUINT8
dfFirstChar
;
LEUINT8
dfLastChar
;
LEUINT8
dfDefaultChar
;
LEUINT8
dfBreakChar
;
LEUINT16
dfWidthBytes
;
LEUINT32
dfDevice
;
LEUINT32
dfFace
;
LEUINT32
dfBitsPointer
;
LEUINT32
dfBitsOffset
;
LEUINT8
dfReserved
;
OT
:
:
UnsizedArrayOf
<
LEUINT8
>
dataZ
;
public
:
DEFINE_SIZE_ARRAY
(
118
dataZ
)
;
}
;
struct
NE_NAMEINFO
{
friend
struct
NE_TYPEINFO
;
inline
bool
sanitize
(
OT
:
:
hb_sanitize_context_t
*
c
const
void
*
base
unsigned
int
shift
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
get_font
(
base
shift
)
.
sanitize
(
c
length
<
<
shift
)
)
)
;
}
inline
const
LE_FONTINFO16
&
get_font
(
const
void
*
base
int
shift
)
const
{
return
OT
:
:
StructAtOffset
<
LE_FONTINFO16
>
(
base
offset
<
<
shift
)
;
}
enum
resource_type_flag_t
{
NONE
=
0x0000
MOVEABLE
=
0x0010
PURE
=
0x0020
PRELOAD
=
0x0040
}
;
protected
:
LEUINT16
offset
;
LEUINT16
length
;
LEUINT16
flags
;
LEUINT16
id
;
LEUINT16
handle
;
LEUINT16
usage
;
public
:
DEFINE_SIZE_STATIC
(
12
)
;
}
;
struct
NE_TYPEINFO
{
inline
bool
sanitize
(
OT
:
:
hb_sanitize_context_t
*
c
const
void
*
base
unsigned
int
shift
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
resources
.
sanitize
(
c
count
base
shift
)
)
;
}
inline
unsigned
int
get_size
(
void
)
const
{
return
8
+
count
*
NE_NAMEINFO
:
:
static_size
;
}
inline
const
NE_TYPEINFO
&
next
(
)
const
{
const
NE_TYPEINFO
&
next
=
OT
:
:
StructAfter
<
NE_TYPEINFO
>
(
*
this
)
;
if
(
type_id
=
=
0
)
return
Null
(
NE_TYPEINFO
)
;
return
next
;
}
inline
const
LE_FONTINFO16
&
get_font
(
unsigned
int
idx
const
void
*
base
int
shift
)
const
{
if
(
idx
<
count
)
return
resources
[
idx
]
.
get_font
(
base
shift
)
;
return
Null
(
LE_FONTINFO16
)
;
}
inline
unsigned
int
get_count
(
)
const
{
return
count
;
}
inline
unsigned
int
get_type_id
(
)
const
{
return
type_id
;
}
enum
type_id_t
{
CURSOR
=
0x8001
BITMAP
=
0x8002
ICON
=
0x8003
MENU
=
0x8004
DIALOG
=
0x8005
STRING
=
0x8006
FONT_DIRECTORY
=
0x8007
FONT
=
0x8008
ACCELERATOR_TABLE
=
0x8009
RESOURCE_DATA
=
0x800a
GROUP_CURSOR
=
0x800c
GROUP_ICON
=
0x800e
VERSION
=
0x8010
}
;
protected
:
LEUINT16
type_id
;
LEUINT16
count
;
LEUINT32
resloader
;
OT
:
:
UnsizedArrayOf
<
NE_NAMEINFO
>
resources
;
public
:
DEFINE_SIZE_ARRAY
(
8
resources
)
;
}
;
struct
NE_RESOURCE_TABLE
{
inline
bool
sanitize
(
OT
:
:
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
if
(
!
c
-
>
check_struct
(
this
)
)
return_trace
(
false
)
;
const
NE_TYPEINFO
*
n
=
&
chain
;
while
(
n
!
=
&
Null
(
NE_TYPEINFO
)
&
&
c
-
>
check_struct
(
n
)
&
&
n
-
>
get_type_id
(
)
!
=
0
)
{
if
(
n
-
>
get_type_id
(
)
=
=
NE_TYPEINFO
:
:
FONT
)
return_trace
(
n
-
>
sanitize
(
c
base
alignmentShiftCount
)
)
;
n
=
&
n
-
>
next
(
)
;
}
return_trace
(
false
)
;
}
inline
unsigned
int
get_shift_value
(
)
const
{
return
alignmentShiftCount
;
}
inline
const
NE_TYPEINFO
&
get_fonts_entry
(
)
const
{
const
NE_TYPEINFO
*
n
=
&
chain
;
while
(
n
!
=
&
Null
(
NE_TYPEINFO
)
&
&
n
-
>
get_type_id
(
)
!
=
0
)
{
if
(
n
-
>
get_type_id
(
)
=
=
NE_TYPEINFO
:
:
FONT
)
return
*
n
;
n
=
&
n
-
>
next
(
)
;
}
return
Null
(
NE_TYPEINFO
)
;
}
protected
:
LEUINT16
alignmentShiftCount
;
NE_TYPEINFO
chain
;
public
:
DEFINE_SIZE_MIN
(
2
)
;
}
;
struct
LE_IMAGE_OS2_HEADER
{
inline
bool
sanitize
(
OT
:
:
hb_sanitize_context_t
*
c
const
void
*
base
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
(
this
+
rsrctab
)
.
sanitize
(
c
base
)
)
)
;
}
inline
const
NE_RESOURCE_TABLE
&
get_resource_table
(
)
const
{
if
(
magic
!
=
0x454E
)
return
Null
(
NE_RESOURCE_TABLE
)
;
return
this
+
rsrctab
;
}
protected
:
LEUINT16
magic
;
LEUINT8
ver
;
LEUINT8
rev
;
LEUINT16
enttab
;
LEUINT16
cbenttab
;
LEUINT32
crc
;
LEUINT16
flags
;
LEUINT16
autodata
;
LEUINT16
heap
;
LEUINT16
stack
;
LEUINT32
csip
;
LEUINT32
sssp
;
LEUINT16
cseg
;
LEUINT16
cmod
;
LEUINT16
cbnrestab
;
LEUINT16
segtab
;
OT
:
:
OffsetTo
<
NE_RESOURCE_TABLE
LEUINT16
>
rsrctab
;
LEUINT16
restab
;
LEUINT16
modtab
;
LEUINT16
imptab
;
LEUINT32
nrestab
;
LEUINT16
cmovent
;
LEUINT16
align
;
LEUINT16
cres
;
LEUINT8
exetyp
;
LEUINT8
flagsothers
;
LEUINT16
pretthunks
;
LEUINT16
psegrefbytes
;
LEUINT16
swaparea
;
LEUINT16
expver
;
public
:
DEFINE_SIZE_STATIC
(
64
)
;
}
;
struct
LE_IMAGE_DOS_HEADER
{
inline
bool
sanitize
(
OT
:
:
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
likely
(
c
-
>
check_struct
(
this
)
&
&
get_os2_header
(
)
.
sanitize
(
c
this
)
)
)
;
}
inline
const
LE_IMAGE_OS2_HEADER
&
get_os2_header
(
)
const
{
return
this
+
e_lfanew
;
}
protected
:
LEUINT16
e_magic
;
LEUINT16
e_cblp
;
LEUINT16
e_cp
;
LEUINT16
e_crlc
;
LEUINT16
e_cparhdr
;
LEUINT16
e_minalloc
;
LEUINT16
e_maxalloc
;
LEUINT16
e_ss
;
LEUINT16
e_sp
;
LEUINT16
e_csum
;
LEUINT16
e_ip
;
LEUINT16
e_cs
;
LEUINT16
e_lfarlc
;
LEUINT16
e_ovno
;
LEUINT16
e_res_0
;
LEUINT16
e_res_1
;
LEUINT16
e_res_2
;
LEUINT16
e_res_3
;
LEUINT16
e_oemid
;
LEUINT16
e_oeminfo
;
LEUINT16
e_res2_0
;
LEUINT16
e_res2_1
;
LEUINT16
e_res2_2
;
LEUINT16
e_res2_3
;
LEUINT16
e_res2_4
;
LEUINT16
e_res2_5
;
LEUINT16
e_res2_6
;
LEUINT16
e_res2_7
;
LEUINT16
e_res2_8
;
LEUINT16
e_res2_9
;
OT
:
:
OffsetTo
<
LE_IMAGE_OS2_HEADER
LEUINT32
>
e_lfanew
;
public
:
DEFINE_SIZE_STATIC
(
64
)
;
}
;
int
main
(
int
argc
char
*
*
argv
)
{
hb_blob_t
*
blob
=
hb_blob_create_from_file
(
argv
[
1
]
)
;
OT
:
:
Sanitizer
<
LE_IMAGE_DOS_HEADER
>
sanitizer
;
hb_blob_t
*
font_blob
=
sanitizer
.
sanitize
(
blob
)
;
const
LE_IMAGE_DOS_HEADER
*
dos_header
=
font_blob
-
>
as
<
LE_IMAGE_DOS_HEADER
>
(
)
;
const
NE_RESOURCE_TABLE
&
rtable
=
dos_header
-
>
get_os2_header
(
)
.
get_resource_table
(
)
;
int
shift
=
rtable
.
get_shift_value
(
)
;
const
NE_TYPEINFO
&
entry
=
rtable
.
get_fonts_entry
(
)
;
for
(
unsigned
int
i
=
0
;
i
<
entry
.
get_count
(
)
;
+
+
i
)
{
const
LE_FONTINFO16
&
font
=
entry
.
get_font
(
i
dos_header
shift
)
;
printf
(
"
version
:
%
x
weight
:
%
d
charset
:
%
s
\
n
"
font
.
get_version
(
)
font
.
get_weight
(
)
font
.
get_charset
(
)
)
;
}
return
0
;
}
