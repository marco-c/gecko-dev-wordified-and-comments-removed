#
ifndef
HB_OT_VORG_TABLE_HH
#
define
HB_OT_VORG_TABLE_HH
#
include
"
hb
-
open
-
type
.
hh
"
#
define
HB_OT_TAG_VORG
HB_TAG
(
'
V
'
'
O
'
'
R
'
'
G
'
)
namespace
OT
{
struct
VertOriginMetric
{
int
cmp
(
hb_codepoint_t
g
)
const
{
return
glyph
.
cmp
(
g
)
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
)
;
}
public
:
GlyphID
glyph
;
FWORD
vertOriginY
;
public
:
DEFINE_SIZE_STATIC
(
4
)
;
}
;
struct
VORG
{
static
constexpr
hb_tag_t
tableTag
=
HB_OT_TAG_VORG
;
bool
has_data
(
)
const
{
return
version
.
to_int
(
)
;
}
int
get_y_origin
(
hb_codepoint_t
glyph
)
const
{
unsigned
int
i
;
if
(
!
vertYOrigins
.
bfind
(
glyph
&
i
)
)
return
defaultVertOriginY
;
return
vertYOrigins
[
i
]
.
vertOriginY
;
}
bool
_subset
(
const
hb_subset_plan_t
*
plan
HB_UNUSED
const
VORG
*
vorg_table
const
hb_vector_t
<
VertOriginMetric
>
&
subset_metrics
unsigned
int
dest_sz
void
*
dest
)
const
{
hb_serialize_context_t
c
(
dest
dest_sz
)
;
VORG
*
subset_table
=
c
.
start_serialize
<
VORG
>
(
)
;
if
(
unlikely
(
!
c
.
extend_min
(
*
subset_table
)
)
)
return
false
;
subset_table
-
>
version
.
major
.
set
(
1
)
;
subset_table
-
>
version
.
minor
.
set
(
0
)
;
subset_table
-
>
defaultVertOriginY
.
set
(
vorg_table
-
>
defaultVertOriginY
)
;
subset_table
-
>
vertYOrigins
.
len
.
set
(
subset_metrics
.
length
)
;
bool
success
=
true
;
if
(
subset_metrics
.
length
>
0
)
{
unsigned
int
size
=
VertOriginMetric
:
:
static_size
*
subset_metrics
.
length
;
VertOriginMetric
*
metrics
=
c
.
allocate_size
<
VertOriginMetric
>
(
size
)
;
if
(
likely
(
metrics
!
=
nullptr
)
)
memcpy
(
metrics
&
subset_metrics
[
0
]
size
)
;
else
success
=
false
;
}
c
.
end_serialize
(
)
;
return
success
;
}
bool
subset
(
hb_subset_plan_t
*
plan
)
const
{
hb_blob_t
*
vorg_blob
=
hb_sanitize_context_t
(
)
.
reference_table
<
VORG
>
(
plan
-
>
source
)
;
const
VORG
*
vorg_table
=
vorg_blob
-
>
as
<
VORG
>
(
)
;
hb_vector_t
<
VertOriginMetric
>
subset_metrics
;
subset_metrics
.
init
(
)
;
unsigned
int
glyph
=
0
;
unsigned
int
i
=
0
;
while
(
(
glyph
<
plan
-
>
glyphs
.
length
)
&
&
(
i
<
vertYOrigins
.
len
)
)
{
if
(
plan
-
>
glyphs
[
glyph
]
>
vertYOrigins
[
i
]
.
glyph
)
i
+
+
;
else
if
(
plan
-
>
glyphs
[
glyph
]
<
vertYOrigins
[
i
]
.
glyph
)
glyph
+
+
;
else
{
VertOriginMetric
*
metrics
=
subset_metrics
.
push
(
)
;
metrics
-
>
glyph
.
set
(
glyph
)
;
metrics
-
>
vertOriginY
.
set
(
vertYOrigins
[
i
]
.
vertOriginY
)
;
glyph
+
+
;
i
+
+
;
}
}
unsigned
int
dest_sz
=
VORG
:
:
min_size
+
VertOriginMetric
:
:
static_size
*
subset_metrics
.
length
;
void
*
dest
=
(
void
*
)
malloc
(
dest_sz
)
;
if
(
unlikely
(
!
dest
)
)
{
subset_metrics
.
fini
(
)
;
hb_blob_destroy
(
vorg_blob
)
;
return
false
;
}
if
(
!
_subset
(
plan
vorg_table
subset_metrics
dest_sz
dest
)
)
{
subset_metrics
.
fini
(
)
;
free
(
dest
)
;
hb_blob_destroy
(
vorg_blob
)
;
return
false
;
}
hb_blob_t
*
result
=
hb_blob_create
(
(
const
char
*
)
dest
dest_sz
HB_MEMORY_MODE_READONLY
dest
free
)
;
bool
success
=
plan
-
>
add_table
(
HB_OT_TAG_VORG
result
)
;
hb_blob_destroy
(
result
)
;
subset_metrics
.
fini
(
)
;
hb_blob_destroy
(
vorg_blob
)
;
return
success
;
}
bool
sanitize
(
hb_sanitize_context_t
*
c
)
const
{
TRACE_SANITIZE
(
this
)
;
return_trace
(
c
-
>
check_struct
(
this
)
&
&
version
.
major
=
=
1
&
&
vertYOrigins
.
sanitize
(
c
)
)
;
}
protected
:
FixedVersion
<
>
version
;
FWORD
defaultVertOriginY
;
SortedArrayOf
<
VertOriginMetric
>
vertYOrigins
;
public
:
DEFINE_SIZE_ARRAY
(
8
vertYOrigins
)
;
}
;
}
#
endif
