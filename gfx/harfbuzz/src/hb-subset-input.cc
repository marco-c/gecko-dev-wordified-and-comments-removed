#
include
"
hb
-
subset
.
hh
"
#
include
"
hb
-
set
.
hh
"
#
include
"
hb
-
utf
.
hh
"
hb_subset_input_t
:
:
hb_subset_input_t
(
)
{
for
(
auto
&
set
:
sets_iter
(
)
)
set
=
hb
:
:
shared_ptr
<
hb_set_t
>
(
hb_set_create
(
)
)
;
if
(
in_error
(
)
)
return
;
flags
=
HB_SUBSET_FLAGS_DEFAULT
;
hb_set_add_range
(
sets
.
name_ids
0
6
)
;
hb_set_add
(
sets
.
name_languages
0x0409
)
;
hb_tag_t
default_drop_tables
[
]
=
{
HB_TAG
(
'
m
'
'
o
'
'
r
'
'
x
'
)
HB_TAG
(
'
m
'
'
o
'
'
r
'
'
t
'
)
HB_TAG
(
'
k
'
'
e
'
'
r
'
'
x
'
)
HB_TAG
(
'
k
'
'
e
'
'
r
'
'
n
'
)
HB_TAG
(
'
B
'
'
A
'
'
S
'
'
E
'
)
HB_TAG
(
'
J
'
'
S
'
'
T
'
'
F
'
)
HB_TAG
(
'
D
'
'
S
'
'
I
'
'
G
'
)
HB_TAG
(
'
E
'
'
B
'
'
D
'
'
T
'
)
HB_TAG
(
'
E
'
'
B
'
'
L
'
'
C
'
)
HB_TAG
(
'
E
'
'
B
'
'
S
'
'
C
'
)
HB_TAG
(
'
S
'
'
V
'
'
G
'
'
'
)
HB_TAG
(
'
P
'
'
C
'
'
L
'
'
T
'
)
HB_TAG
(
'
L
'
'
T
'
'
S
'
'
H
'
)
HB_TAG
(
'
F
'
'
e
'
'
a
'
'
t
'
)
HB_TAG
(
'
G
'
'
l
'
'
a
'
'
t
'
)
HB_TAG
(
'
G
'
'
l
'
'
o
'
'
c
'
)
HB_TAG
(
'
S
'
'
i
'
'
l
'
'
f
'
)
HB_TAG
(
'
S
'
'
i
'
'
l
'
'
l
'
)
}
;
sets
.
drop_tables
-
>
add_array
(
default_drop_tables
ARRAY_LENGTH
(
default_drop_tables
)
)
;
hb_tag_t
default_no_subset_tables
[
]
=
{
HB_TAG
(
'
a
'
'
v
'
'
a
'
'
r
'
)
HB_TAG
(
'
g
'
'
a
'
'
s
'
'
p
'
)
HB_TAG
(
'
f
'
'
p
'
'
g
'
'
m
'
)
HB_TAG
(
'
p
'
'
r
'
'
e
'
'
p
'
)
HB_TAG
(
'
V
'
'
D
'
'
M
'
'
X
'
)
HB_TAG
(
'
D
'
'
S
'
'
I
'
'
G
'
)
HB_TAG
(
'
M
'
'
V
'
'
A
'
'
R
'
)
HB_TAG
(
'
c
'
'
v
'
'
a
'
'
r
'
)
}
;
sets
.
no_subset_tables
-
>
add_array
(
default_no_subset_tables
ARRAY_LENGTH
(
default_no_subset_tables
)
)
;
hb_tag_t
default_layout_features
[
]
=
{
HB_TAG
(
'
r
'
'
v
'
'
r
'
'
n
'
)
HB_TAG
(
'
c
'
'
c
'
'
m
'
'
p
'
)
HB_TAG
(
'
l
'
'
i
'
'
g
'
'
a
'
)
HB_TAG
(
'
l
'
'
o
'
'
c
'
'
l
'
)
HB_TAG
(
'
m
'
'
a
'
'
r
'
'
k
'
)
HB_TAG
(
'
m
'
'
k
'
'
m
'
'
k
'
)
HB_TAG
(
'
r
'
'
l
'
'
i
'
'
g
'
)
HB_TAG
(
'
f
'
'
r
'
'
a
'
'
c
'
)
HB_TAG
(
'
n
'
'
u
'
'
m
'
'
r
'
)
HB_TAG
(
'
d
'
'
n
'
'
o
'
'
m
'
)
HB_TAG
(
'
c
'
'
a
'
'
l
'
'
t
'
)
HB_TAG
(
'
c
'
'
l
'
'
i
'
'
g
'
)
HB_TAG
(
'
c
'
'
u
'
'
r
'
'
s
'
)
HB_TAG
(
'
k
'
'
e
'
'
r
'
'
n
'
)
HB_TAG
(
'
r
'
'
c
'
'
l
'
'
t
'
)
HB_TAG
(
'
v
'
'
a
'
'
l
'
'
t
'
)
HB_TAG
(
'
v
'
'
e
'
'
r
'
'
t
'
)
HB_TAG
(
'
v
'
'
k
'
'
r
'
'
n
'
)
HB_TAG
(
'
v
'
'
p
'
'
a
'
'
l
'
)
HB_TAG
(
'
v
'
'
r
'
'
t
'
'
2
'
)
HB_TAG
(
'
l
'
'
t
'
'
r
'
'
a
'
)
HB_TAG
(
'
l
'
'
t
'
'
r
'
'
m
'
)
HB_TAG
(
'
r
'
'
t
'
'
l
'
'
a
'
)
HB_TAG
(
'
r
'
'
t
'
'
l
'
'
m
'
)
HB_TAG
(
'
r
'
'
a
'
'
n
'
'
d
'
)
HB_TAG
(
'
j
'
'
a
'
'
l
'
'
t
'
)
HB_TAG
(
'
H
'
'
a
'
'
r
'
'
f
'
)
HB_TAG
(
'
H
'
'
A
'
'
R
'
'
F
'
)
HB_TAG
(
'
B
'
'
u
'
'
z
'
'
z
'
)
HB_TAG
(
'
B
'
'
U
'
'
Z
'
'
Z
'
)
HB_TAG
(
'
i
'
'
n
'
'
i
'
'
t
'
)
HB_TAG
(
'
m
'
'
e
'
'
d
'
'
i
'
)
HB_TAG
(
'
f
'
'
i
'
'
n
'
'
a
'
)
HB_TAG
(
'
i
'
'
s
'
'
o
'
'
l
'
)
HB_TAG
(
'
m
'
'
e
'
'
d
'
'
2
'
)
HB_TAG
(
'
f
'
'
i
'
'
n
'
'
2
'
)
HB_TAG
(
'
f
'
'
i
'
'
n
'
'
3
'
)
HB_TAG
(
'
c
'
'
s
'
'
w
'
'
h
'
)
HB_TAG
(
'
m
'
'
s
'
'
e
'
'
t
'
)
HB_TAG
(
'
s
'
'
t
'
'
c
'
'
h
'
)
HB_TAG
(
'
l
'
'
j
'
'
m
'
'
o
'
)
HB_TAG
(
'
v
'
'
j
'
'
m
'
'
o
'
)
HB_TAG
(
'
t
'
'
j
'
'
m
'
'
o
'
)
HB_TAG
(
'
a
'
'
b
'
'
v
'
'
s
'
)
HB_TAG
(
'
b
'
'
l
'
'
w
'
'
s
'
)
HB_TAG
(
'
a
'
'
b
'
'
v
'
'
m
'
)
HB_TAG
(
'
b
'
'
l
'
'
w
'
'
m
'
)
HB_TAG
(
'
n
'
'
u
'
'
k
'
'
t
'
)
HB_TAG
(
'
a
'
'
k
'
'
h
'
'
n
'
)
HB_TAG
(
'
r
'
'
p
'
'
h
'
'
f
'
)
HB_TAG
(
'
r
'
'
k
'
'
r
'
'
f
'
)
HB_TAG
(
'
p
'
'
r
'
'
e
'
'
f
'
)
HB_TAG
(
'
b
'
'
l
'
'
w
'
'
f
'
)
HB_TAG
(
'
h
'
'
a
'
'
l
'
'
f
'
)
HB_TAG
(
'
a
'
'
b
'
'
v
'
'
f
'
)
HB_TAG
(
'
p
'
'
s
'
'
t
'
'
f
'
)
HB_TAG
(
'
c
'
'
f
'
'
a
'
'
r
'
)
HB_TAG
(
'
v
'
'
a
'
'
t
'
'
u
'
)
HB_TAG
(
'
c
'
'
j
'
'
c
'
'
t
'
)
HB_TAG
(
'
i
'
'
n
'
'
i
'
'
t
'
)
HB_TAG
(
'
p
'
'
r
'
'
e
'
'
s
'
)
HB_TAG
(
'
a
'
'
b
'
'
v
'
'
s
'
)
HB_TAG
(
'
b
'
'
l
'
'
w
'
'
s
'
)
HB_TAG
(
'
p
'
'
s
'
'
t
'
'
s
'
)
HB_TAG
(
'
h
'
'
a
'
'
l
'
'
n
'
)
HB_TAG
(
'
d
'
'
i
'
'
s
'
'
t
'
)
HB_TAG
(
'
a
'
'
b
'
'
v
'
'
m
'
)
HB_TAG
(
'
b
'
'
l
'
'
w
'
'
m
'
)
}
;
sets
.
layout_features
-
>
add_array
(
default_layout_features
ARRAY_LENGTH
(
default_layout_features
)
)
;
sets
.
layout_scripts
-
>
invert
(
)
;
}
hb_subset_input_t
*
hb_subset_input_create_or_fail
(
void
)
{
hb_subset_input_t
*
input
=
hb_object_create
<
hb_subset_input_t
>
(
)
;
if
(
unlikely
(
!
input
)
)
return
nullptr
;
if
(
input
-
>
in_error
(
)
)
{
hb_subset_input_destroy
(
input
)
;
return
nullptr
;
}
return
input
;
}
hb_subset_input_t
*
hb_subset_input_reference
(
hb_subset_input_t
*
input
)
{
return
hb_object_reference
(
input
)
;
}
void
hb_subset_input_destroy
(
hb_subset_input_t
*
input
)
{
if
(
!
hb_object_destroy
(
input
)
)
return
;
hb_free
(
input
)
;
}
HB_EXTERN
hb_set_t
*
hb_subset_input_unicode_set
(
hb_subset_input_t
*
input
)
{
return
input
-
>
sets
.
unicodes
;
}
HB_EXTERN
hb_set_t
*
hb_subset_input_glyph_set
(
hb_subset_input_t
*
input
)
{
return
input
-
>
sets
.
glyphs
;
}
HB_EXTERN
hb_set_t
*
hb_subset_input_set
(
hb_subset_input_t
*
input
hb_subset_sets_t
set_type
)
{
return
input
-
>
sets_iter
(
)
[
set_type
]
;
}
HB_EXTERN
hb_subset_flags_t
hb_subset_input_get_flags
(
hb_subset_input_t
*
input
)
{
return
(
hb_subset_flags_t
)
input
-
>
flags
;
}
HB_EXTERN
void
hb_subset_input_set_flags
(
hb_subset_input_t
*
input
unsigned
value
)
{
input
-
>
flags
=
(
hb_subset_flags_t
)
value
;
}
hb_bool_t
hb_subset_input_set_user_data
(
hb_subset_input_t
*
input
hb_user_data_key_t
*
key
void
*
data
hb_destroy_func_t
destroy
hb_bool_t
replace
)
{
return
hb_object_set_user_data
(
input
key
data
destroy
replace
)
;
}
void
*
hb_subset_input_get_user_data
(
const
hb_subset_input_t
*
input
hb_user_data_key_t
*
key
)
{
return
hb_object_get_user_data
(
input
key
)
;
}
void
hb_subset_input_keep_everything
(
hb_subset_input_t
*
input
)
{
const
hb_subset_sets_t
indices
[
]
=
{
HB_SUBSET_SETS_UNICODE
HB_SUBSET_SETS_GLYPH_INDEX
HB_SUBSET_SETS_NAME_ID
HB_SUBSET_SETS_NAME_LANG_ID
HB_SUBSET_SETS_LAYOUT_FEATURE_TAG
HB_SUBSET_SETS_LAYOUT_SCRIPT_TAG
}
;
for
(
auto
idx
:
hb_iter
(
indices
)
)
{
hb_set_t
*
set
=
hb_subset_input_set
(
input
idx
)
;
hb_set_clear
(
set
)
;
hb_set_invert
(
set
)
;
}
hb_set_clear
(
hb_subset_input_set
(
input
HB_SUBSET_SETS_DROP_TABLE_TAG
)
)
;
hb_subset_input_set_flags
(
input
HB_SUBSET_FLAGS_NOTDEF_OUTLINE
|
HB_SUBSET_FLAGS_GLYPH_NAMES
|
HB_SUBSET_FLAGS_NO_PRUNE_UNICODE_RANGES
|
HB_SUBSET_FLAGS_PASSTHROUGH_UNRECOGNIZED
)
;
}
#
ifndef
HB_NO_VAR
HB_EXTERN
hb_bool_t
hb_subset_input_pin_axis_to_default
(
hb_subset_input_t
*
input
hb_face_t
*
face
hb_tag_t
axis_tag
)
{
hb_ot_var_axis_info_t
axis_info
;
if
(
!
hb_ot_var_find_axis_info
(
face
axis_tag
&
axis_info
)
)
return
false
;
return
input
-
>
axes_location
.
set
(
axis_tag
axis_info
.
default_value
)
;
}
HB_EXTERN
hb_bool_t
hb_subset_input_pin_axis_location
(
hb_subset_input_t
*
input
hb_face_t
*
face
hb_tag_t
axis_tag
float
axis_value
)
{
hb_ot_var_axis_info_t
axis_info
;
if
(
!
hb_ot_var_find_axis_info
(
face
axis_tag
&
axis_info
)
)
return
false
;
float
val
=
hb_clamp
(
axis_value
axis_info
.
min_value
axis_info
.
max_value
)
;
return
input
-
>
axes_location
.
set
(
axis_tag
val
)
;
}
#
endif
HB_EXTERN
hb_face_t
*
hb_subset_preprocess
(
hb_face_t
*
source
)
{
hb_subset_input_t
*
input
=
hb_subset_input_create_or_fail
(
)
;
if
(
!
input
)
return
hb_face_reference
(
source
)
;
hb_subset_input_keep_everything
(
input
)
;
input
-
>
attach_accelerator_data
=
true
;
input
-
>
force_long_loca
=
true
;
hb_face_t
*
new_source
=
hb_subset_or_fail
(
source
input
)
;
hb_subset_input_destroy
(
input
)
;
if
(
!
new_source
)
{
DEBUG_MSG
(
SUBSET
nullptr
"
Preprocessing
failed
due
to
subset
failure
.
"
)
;
return
hb_face_reference
(
source
)
;
}
return
new_source
;
}
HB_EXTERN
hb_map_t
*
hb_subset_input_old_to_new_glyph_mapping
(
hb_subset_input_t
*
input
)
{
return
&
input
-
>
glyph_map
;
}
#
ifdef
HB_EXPERIMENTAL_API
HB_EXTERN
hb_bool_t
hb_subset_input_override_name_table
(
hb_subset_input_t
*
input
hb_ot_name_id_t
name_id
unsigned
platform_id
unsigned
encoding_id
unsigned
language_id
const
char
*
name_str
int
str_len
)
{
if
(
!
name_str
)
{
str_len
=
0
;
}
else
if
(
str_len
=
=
-
1
)
{
str_len
=
strlen
(
name_str
)
;
}
hb_bytes_t
name_bytes
(
nullptr
0
)
;
if
(
str_len
)
{
if
(
platform_id
=
=
1
)
{
const
uint8_t
*
src
=
reinterpret_cast
<
const
uint8_t
*
>
(
name_str
)
;
const
uint8_t
*
src_end
=
src
+
str_len
;
hb_codepoint_t
unicode
;
const
hb_codepoint_t
replacement
=
HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT
;
while
(
src
<
src_end
)
{
src
=
hb_utf8_t
:
:
next
(
src
src_end
&
unicode
replacement
)
;
if
(
unicode
>
=
0x0080u
)
{
printf
(
"
Non
-
ascii
character
detected
ignored
.
.
.
This
API
supports
acsii
characters
only
for
mac
platform
\
n
"
)
;
return
false
;
}
}
}
char
*
override_name
=
(
char
*
)
hb_malloc
(
str_len
)
;
if
(
unlikely
(
!
override_name
)
)
return
false
;
hb_memcpy
(
override_name
name_str
str_len
)
;
name_bytes
=
hb_bytes_t
(
override_name
str_len
)
;
}
input
-
>
name_table_overrides
.
set
(
hb_ot_name_record_ids_t
(
platform_id
encoding_id
language_id
name_id
)
name_bytes
)
;
return
true
;
}
#
endif
