use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
sync
:
:
Mutex
;
use
webrender
:
:
api
:
:
*
;
pub
fn
serialize_blob
(
color
:
ColorU
)
-
>
Vec
<
u8
>
{
vec
!
[
color
.
r
color
.
g
color
.
b
color
.
a
]
}
fn
deserialize_blob
(
blob
:
&
[
u8
]
)
-
>
Result
<
ColorU
(
)
>
{
let
mut
iter
=
blob
.
iter
(
)
;
return
match
(
iter
.
next
(
)
iter
.
next
(
)
iter
.
next
(
)
iter
.
next
(
)
)
{
(
Some
(
&
r
)
Some
(
&
g
)
Some
(
&
b
)
Some
(
&
a
)
)
=
>
Ok
(
ColorU
:
:
new
(
r
g
b
a
)
)
(
Some
(
&
a
)
None
None
None
)
=
>
Ok
(
ColorU
:
:
new
(
a
a
a
a
)
)
_
=
>
Err
(
(
)
)
}
;
}
fn
render_blob
(
color
:
ColorU
descriptor
:
&
BlobImageDescriptor
tile
:
Option
<
TileOffset
>
)
-
>
BlobImageResult
{
let
mut
texels
=
Vec
:
:
with_capacity
(
(
descriptor
.
width
*
descriptor
.
height
*
4
)
as
usize
)
;
let
tile_checker
=
match
tile
{
Some
(
tile
)
=
>
(
tile
.
x
%
2
=
=
0
)
!
=
(
tile
.
y
%
2
=
=
0
)
None
=
>
true
}
;
for
y
in
0
.
.
descriptor
.
height
{
for
x
in
0
.
.
descriptor
.
width
{
let
x2
=
x
+
descriptor
.
offset
.
x
as
u32
;
let
y2
=
y
+
descriptor
.
offset
.
y
as
u32
;
let
checker
=
if
(
x2
%
20
>
=
10
)
!
=
(
y2
%
20
>
=
10
)
{
1
}
else
{
0
}
;
let
tc
=
if
tile_checker
{
0
}
else
{
(
1
-
checker
)
*
40
}
;
match
descriptor
.
format
{
ImageFormat
:
:
BGRA8
=
>
{
texels
.
push
(
color
.
b
*
checker
+
tc
)
;
texels
.
push
(
color
.
g
*
checker
+
tc
)
;
texels
.
push
(
color
.
r
*
checker
+
tc
)
;
texels
.
push
(
color
.
a
*
checker
+
tc
)
;
}
ImageFormat
:
:
R8
=
>
{
texels
.
push
(
color
.
a
*
checker
+
tc
)
;
}
_
=
>
{
return
Err
(
BlobImageError
:
:
Other
(
format
!
(
"
Usupported
image
format
{
:
?
}
"
descriptor
.
format
)
)
)
;
}
}
}
}
Ok
(
RasterizedBlobImage
{
data
:
texels
width
:
descriptor
.
width
height
:
descriptor
.
height
}
)
}
pub
struct
BlobCallbacks
{
pub
request
:
Box
<
Fn
(
&
BlobImageRequest
)
+
Send
+
'
static
>
pub
resolve
:
Box
<
Fn
(
)
+
Send
+
'
static
>
}
impl
BlobCallbacks
{
pub
fn
new
(
)
-
>
Self
{
BlobCallbacks
{
request
:
Box
:
:
new
(
|
_
|
(
)
)
resolve
:
Box
:
:
new
(
|
|
(
(
)
)
)
}
}
}
pub
struct
CheckerboardRenderer
{
image_cmds
:
HashMap
<
ImageKey
ColorU
>
callbacks
:
Arc
<
Mutex
<
BlobCallbacks
>
>
rendered_images
:
HashMap
<
BlobImageRequest
BlobImageResult
>
}
impl
CheckerboardRenderer
{
pub
fn
new
(
callbacks
:
Arc
<
Mutex
<
BlobCallbacks
>
>
)
-
>
Self
{
CheckerboardRenderer
{
callbacks
image_cmds
:
HashMap
:
:
new
(
)
rendered_images
:
HashMap
:
:
new
(
)
}
}
}
impl
BlobImageRenderer
for
CheckerboardRenderer
{
fn
add
(
&
mut
self
key
:
ImageKey
cmds
:
BlobImageData
_
:
Option
<
TileSize
>
)
{
self
.
image_cmds
.
insert
(
key
deserialize_blob
(
&
cmds
[
.
.
]
)
.
unwrap
(
)
)
;
}
fn
update
(
&
mut
self
key
:
ImageKey
cmds
:
BlobImageData
_dirty_rect
:
Option
<
DeviceUintRect
>
)
{
self
.
image_cmds
.
insert
(
key
deserialize_blob
(
&
cmds
[
.
.
]
)
.
unwrap
(
)
)
;
}
fn
delete
(
&
mut
self
key
:
ImageKey
)
{
self
.
image_cmds
.
remove
(
&
key
)
;
}
fn
request
(
&
mut
self
_resources
:
&
BlobImageResources
request
:
BlobImageRequest
descriptor
:
&
BlobImageDescriptor
_dirty_rect
:
Option
<
DeviceUintRect
>
)
{
(
self
.
callbacks
.
lock
(
)
.
unwrap
(
)
.
request
)
(
&
request
)
;
assert
!
(
!
self
.
rendered_images
.
contains_key
(
&
request
)
)
;
let
cmds
=
self
.
image_cmds
.
get
(
&
request
.
key
)
.
unwrap
(
)
;
let
result
=
render_blob
(
*
cmds
descriptor
request
.
tile
)
;
self
.
rendered_images
.
insert
(
request
result
)
;
}
fn
resolve
(
&
mut
self
request
:
BlobImageRequest
)
-
>
BlobImageResult
{
(
self
.
callbacks
.
lock
(
)
.
unwrap
(
)
.
resolve
)
(
)
;
self
.
rendered_images
.
remove
(
&
request
)
.
unwrap
(
)
}
fn
delete_font
(
&
mut
self
_key
:
FontKey
)
{
}
fn
delete_font_instance
(
&
mut
self
_key
:
FontInstanceKey
)
{
}
}
