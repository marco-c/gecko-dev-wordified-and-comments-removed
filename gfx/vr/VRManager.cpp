#
include
"
VRManager
.
h
"
#
include
"
VRManagerParent
.
h
"
#
include
"
VRShMem
.
h
"
#
include
"
VRThread
.
h
"
#
include
"
gfxVR
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
dom
/
VRDisplay
.
h
"
#
include
"
mozilla
/
dom
/
GamepadEventTypes
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
gfxVR
.
h
"
#
include
<
cstring
>
#
include
"
ipc
/
VRLayerParent
.
h
"
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
#
include
"
VRServiceHost
.
h
"
#
endif
#
ifdef
XP_WIN
#
include
"
CompositorD3D11
.
h
"
#
include
"
TextureD3D11
.
h
"
#
include
<
d3d11
.
h
>
#
include
"
gfxWindowsPlatform
.
h
"
#
include
"
mozilla
/
gfx
/
DeviceManagerDx
.
h
"
#
elif
defined
(
XP_MACOSX
)
#
include
"
mozilla
/
gfx
/
MacIOSurface
.
h
"
#
include
<
errno
.
h
>
#
elif
defined
(
MOZ_WIDGET_ANDROID
)
#
include
<
string
.
h
>
#
include
<
pthread
.
h
>
#
include
"
GeckoVRManager
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
gl
;
namespace
mozilla
{
namespace
gfx
{
const
uint32_t
kVRActiveTaskInterval
=
1
;
const
uint32_t
kVRIdleTaskInterval
=
100
;
const
double
kVRMaxFrameSubmitDuration
=
4000
.
0f
;
static
StaticRefPtr
<
VRManager
>
sVRManagerSingleton
;
VRManager
*
VRManager
:
:
Get
(
)
{
MOZ_ASSERT
(
sVRManagerSingleton
!
=
nullptr
)
;
return
sVRManagerSingleton
;
}
Atomic
<
uint32_t
>
VRManager
:
:
sDisplayBase
(
0
)
;
uint32_t
VRManager
:
:
AllocateDisplayID
(
)
{
return
+
+
sDisplayBase
;
}
void
VRManager
:
:
ManagerInit
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
StaticPrefs
:
:
dom_vr_enabled
(
)
&
&
XRE_IsParentProcess
(
)
)
{
Preferences
:
:
SetBool
(
"
dom
.
gamepad
.
extensions
.
enabled
"
true
)
;
}
if
(
sVRManagerSingleton
=
=
nullptr
)
{
sVRManagerSingleton
=
new
VRManager
(
)
;
ClearOnShutdown
(
&
sVRManagerSingleton
)
;
}
}
VRManager
:
:
VRManager
(
)
:
mState
(
VRManagerState
:
:
Disabled
)
mAccumulator100ms
(
0
.
0f
)
mVRDisplaysRequested
(
false
)
mVRDisplaysRequestedNonFocus
(
false
)
mVRControllersRequested
(
false
)
mFrameStarted
(
false
)
mTaskInterval
(
0
)
mCurrentSubmitTaskMonitor
(
"
CurrentSubmitTaskMonitor
"
)
mCurrentSubmitTask
(
nullptr
)
mLastSubmittedFrameId
(
0
)
mLastStartedFrame
(
0
)
mEnumerationCompleted
(
false
)
mAppPaused
(
false
)
mShmem
(
nullptr
)
mHapticPulseRemaining
{
}
mDisplayInfo
{
}
mLastUpdateDisplayInfo
{
}
mBrowserState
{
}
mLastSensorState
{
}
{
MOZ_ASSERT
(
sVRManagerSingleton
=
=
nullptr
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
mVRProcessEnabled
=
StaticPrefs
:
:
dom_vr_process_enabled_AtStartup
(
)
&
&
XRE_IsGPUProcess
(
)
;
VRServiceHost
:
:
Init
(
mVRProcessEnabled
)
;
mServiceHost
=
VRServiceHost
:
:
Get
(
)
;
#
else
mVRProcessEnabled
=
false
;
#
endif
nsCOMPtr
<
nsIObserverService
>
service
=
services
:
:
GetObserverService
(
)
;
if
(
service
)
{
service
-
>
AddObserver
(
this
"
application
-
background
"
false
)
;
service
-
>
AddObserver
(
this
"
application
-
foreground
"
false
)
;
}
}
void
VRManager
:
:
OpenShmem
(
)
{
if
(
mShmem
=
=
nullptr
)
{
mShmem
=
(
new
VRShMem
(
nullptr
mVRProcessEnabled
XRE_IsParentProcess
(
)
)
)
;
mShmem
-
>
CreateShMem
(
)
;
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
if
(
!
mVRProcessEnabled
)
{
mServiceHost
-
>
CreateService
(
mShmem
-
>
GetExternalShmem
(
)
)
;
return
;
}
#
endif
}
else
{
mShmem
-
>
ClearShMem
(
)
;
}
}
void
VRManager
:
:
CloseShmem
(
)
{
if
(
mShmem
!
=
nullptr
)
{
mShmem
-
>
CloseShMem
(
)
;
delete
mShmem
;
mShmem
=
nullptr
;
}
}
VRManager
:
:
~
VRManager
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mState
=
=
VRManagerState
:
:
Disabled
)
;
nsCOMPtr
<
nsIObserverService
>
service
=
services
:
:
GetObserverService
(
)
;
if
(
service
)
{
service
-
>
RemoveObserver
(
this
"
application
-
background
"
)
;
service
-
>
RemoveObserver
(
this
"
application
-
foreground
"
)
;
}
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
mServiceHost
-
>
Shutdown
(
)
;
#
endif
CloseShmem
(
)
;
}
void
VRManager
:
:
AddLayer
(
VRLayerParent
*
aLayer
)
{
mLayers
.
AppendElement
(
aLayer
)
;
mDisplayInfo
.
mPresentingGroups
|
=
aLayer
-
>
GetGroup
(
)
;
if
(
mLayers
.
Length
(
)
=
=
1
)
{
StartPresentation
(
)
;
}
RefreshVRDisplays
(
)
;
}
void
VRManager
:
:
RemoveLayer
(
VRLayerParent
*
aLayer
)
{
mLayers
.
RemoveElement
(
aLayer
)
;
if
(
mLayers
.
Length
(
)
=
=
0
)
{
StopPresentation
(
)
;
}
mDisplayInfo
.
mPresentingGroups
=
0
;
for
(
auto
layer
:
mLayers
)
{
mDisplayInfo
.
mPresentingGroups
|
=
layer
-
>
GetGroup
(
)
;
}
RefreshVRDisplays
(
)
;
}
void
VRManager
:
:
AddVRManagerParent
(
VRManagerParent
*
aVRManagerParent
)
{
mVRManagerParents
.
PutEntry
(
aVRManagerParent
)
;
}
void
VRManager
:
:
RemoveVRManagerParent
(
VRManagerParent
*
aVRManagerParent
)
{
mVRManagerParents
.
RemoveEntry
(
aVRManagerParent
)
;
if
(
mVRManagerParents
.
IsEmpty
(
)
)
{
Destroy
(
)
;
}
}
void
VRManager
:
:
UpdateRequestedDevices
(
)
{
bool
bHaveEventListener
=
false
;
bool
bHaveEventListenerNonFocus
=
false
;
bool
bHaveControllerListener
=
false
;
for
(
auto
iter
=
mVRManagerParents
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
VRManagerParent
*
vmp
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
bHaveEventListener
|
=
vmp
-
>
HaveEventListener
(
)
&
&
vmp
-
>
GetVRActiveStatus
(
)
;
bHaveEventListenerNonFocus
|
=
vmp
-
>
HaveEventListener
(
)
&
&
!
vmp
-
>
GetVRActiveStatus
(
)
;
bHaveControllerListener
|
=
vmp
-
>
HaveControllerListener
(
)
;
}
mVRDisplaysRequested
=
bHaveEventListener
;
mVRDisplaysRequestedNonFocus
=
bHaveEventListenerNonFocus
;
mVRControllersRequested
=
mVRDisplaysRequested
&
&
bHaveControllerListener
;
}
void
VRManager
:
:
NotifyVsync
(
const
TimeStamp
&
aVsyncTimestamp
)
{
if
(
mState
!
=
VRManagerState
:
:
Active
)
{
return
;
}
if
(
mDisplayInfo
.
mPresentingGroups
=
=
0
)
{
StartFrame
(
)
;
}
}
void
VRManager
:
:
StartTasks
(
)
{
if
(
!
mTaskTimer
)
{
mTaskInterval
=
GetOptimalTaskInterval
(
)
;
mTaskTimer
=
NS_NewTimer
(
)
;
mTaskTimer
-
>
SetTarget
(
CompositorThreadHolder
:
:
Loop
(
)
-
>
SerialEventTarget
(
)
)
;
mTaskTimer
-
>
InitWithNamedFuncCallback
(
TaskTimerCallback
this
mTaskInterval
nsITimer
:
:
TYPE_REPEATING_PRECISE_CAN_SKIP
"
VRManager
:
:
TaskTimerCallback
"
)
;
}
}
void
VRManager
:
:
StopTasks
(
)
{
if
(
mTaskTimer
)
{
mTaskTimer
-
>
Cancel
(
)
;
mTaskTimer
=
nullptr
;
}
}
void
VRManager
:
:
TaskTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
VRManager
*
self
=
static_cast
<
VRManager
*
>
(
aClosure
)
;
self
-
>
RunTasks
(
)
;
if
(
self
-
>
mAppPaused
)
{
self
-
>
StopTasks
(
)
;
}
}
void
VRManager
:
:
RunTasks
(
)
{
if
(
mState
=
=
VRManagerState
:
:
Disabled
)
{
return
;
}
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
double
lastTickMs
=
mAccumulator100ms
;
double
deltaTime
=
0
.
0f
;
if
(
!
mLastTickTime
.
IsNull
(
)
)
{
deltaTime
=
(
now
-
mLastTickTime
)
.
ToMilliseconds
(
)
;
}
mAccumulator100ms
+
=
deltaTime
;
mLastTickTime
=
now
;
if
(
deltaTime
>
0
.
0f
&
&
floor
(
mAccumulator100ms
)
!
=
floor
(
lastTickMs
)
)
{
Run1msTasks
(
deltaTime
)
;
}
if
(
floor
(
mAccumulator100ms
*
0
.
1f
)
!
=
floor
(
lastTickMs
*
0
.
1f
)
)
{
Run10msTasks
(
)
;
}
if
(
mAccumulator100ms
>
=
100
.
0f
)
{
Run100msTasks
(
)
;
mAccumulator100ms
=
fmod
(
mAccumulator100ms
100
.
0f
)
;
}
uint32_t
optimalTaskInterval
=
GetOptimalTaskInterval
(
)
;
if
(
mTaskTimer
&
&
optimalTaskInterval
!
=
mTaskInterval
)
{
mTaskTimer
-
>
SetDelay
(
optimalTaskInterval
)
;
mTaskInterval
=
optimalTaskInterval
;
}
}
uint32_t
VRManager
:
:
GetOptimalTaskInterval
(
)
{
bool
wantGranularTasks
=
mVRDisplaysRequested
|
|
mVRControllersRequested
|
|
mDisplayInfo
.
mDisplayID
!
=
0
;
if
(
wantGranularTasks
)
{
return
kVRActiveTaskInterval
;
}
return
kVRIdleTaskInterval
;
}
void
VRManager
:
:
Run1msTasks
(
double
aDeltaTime
)
{
UpdateHaptics
(
aDeltaTime
)
;
}
void
VRManager
:
:
Run10msTasks
(
)
{
UpdateRequestedDevices
(
)
;
CheckWatchDog
(
)
;
ExpireNavigationTransition
(
)
;
PullState
(
)
;
PushState
(
)
;
}
void
VRManager
:
:
Run100msTasks
(
)
{
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
mServiceHost
-
>
Refresh
(
)
;
CheckForPuppetCompletion
(
)
;
#
endif
RefreshVRDisplays
(
)
;
CheckForInactiveTimeout
(
)
;
CheckForShutdown
(
)
;
}
void
VRManager
:
:
CheckForInactiveTimeout
(
)
{
if
(
mVRDisplaysRequested
|
|
mVRDisplaysRequestedNonFocus
|
|
mVRControllersRequested
)
{
mLastActiveTime
=
TimeStamp
:
:
Now
(
)
;
}
else
if
(
mLastActiveTime
.
IsNull
(
)
)
{
Shutdown
(
)
;
}
else
{
TimeDuration
duration
=
TimeStamp
:
:
Now
(
)
-
mLastActiveTime
;
if
(
duration
.
ToMilliseconds
(
)
>
StaticPrefs
:
:
dom_vr_inactive_timeout
(
)
)
{
Shutdown
(
)
;
mLastDisplayEnumerationTime
=
TimeStamp
(
)
;
}
}
}
void
VRManager
:
:
CheckForShutdown
(
)
{
if
(
mState
!
=
VRManagerState
:
:
Disabled
&
&
mState
!
=
VRManagerState
:
:
Idle
&
&
mDisplayInfo
.
mDisplayState
.
shutdown
)
{
Shutdown
(
)
;
}
}
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
void
VRManager
:
:
CheckForPuppetCompletion
(
)
{
if
(
mState
!
=
VRManagerState
:
:
Active
)
{
for
(
auto
iter
=
mManagerParentsWaitingForPuppetReset
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
Unused
<
<
iter
.
Get
(
)
-
>
GetKey
(
)
-
>
SendNotifyPuppetResetComplete
(
)
;
}
mManagerParentsWaitingForPuppetReset
.
Clear
(
)
;
}
if
(
mManagerParentRunningPuppet
)
{
if
(
mServiceHost
-
>
PuppetHasEnded
(
)
)
{
Unused
<
<
mManagerParentRunningPuppet
-
>
SendNotifyPuppetCommandBufferCompleted
(
true
)
;
mManagerParentRunningPuppet
=
nullptr
;
}
}
}
#
endif
void
VRManager
:
:
StartFrame
(
)
{
if
(
mState
!
=
VRManagerState
:
:
Active
)
{
return
;
}
AUTO_PROFILER_TRACING
(
"
VR
"
"
GetSensorState
"
OTHER
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
const
TimeStamp
lastFrameStart
=
mLastFrameStart
[
mDisplayInfo
.
mFrameId
%
kVRMaxLatencyFrames
]
;
const
bool
isPresenting
=
mLastUpdateDisplayInfo
.
GetPresentingGroups
(
)
!
=
0
;
double
duration
=
lastFrameStart
.
IsNull
(
)
?
0
.
0
:
(
now
-
lastFrameStart
)
.
ToMilliseconds
(
)
;
if
(
isPresenting
&
&
mLastStartedFrame
>
0
&
&
mDisplayInfo
.
mDisplayState
.
lastSubmittedFrameId
<
mLastStartedFrame
&
&
duration
<
kVRMaxFrameSubmitDuration
)
{
return
;
}
mDisplayInfo
.
mFrameId
+
+
;
size_t
bufferIndex
=
mDisplayInfo
.
mFrameId
%
kVRMaxLatencyFrames
;
mDisplayInfo
.
mLastSensorState
[
bufferIndex
]
=
mLastSensorState
;
mLastFrameStart
[
bufferIndex
]
=
now
;
mFrameStarted
=
true
;
mLastStartedFrame
=
mDisplayInfo
.
mFrameId
;
DispatchVRDisplayInfoUpdate
(
)
;
}
void
VRManager
:
:
EnumerateVRDisplays
(
)
{
if
(
!
StaticPrefs
:
:
dom_vr_enabled
(
)
)
{
return
;
}
if
(
mState
=
=
VRManagerState
:
:
Disabled
)
{
StartTasks
(
)
;
mState
=
VRManagerState
:
:
Idle
;
}
if
(
mState
=
=
VRManagerState
:
:
Idle
)
{
if
(
!
mLastDisplayEnumerationTime
.
IsNull
(
)
)
{
TimeDuration
duration
=
TimeStamp
:
:
Now
(
)
-
mLastDisplayEnumerationTime
;
if
(
duration
.
ToMilliseconds
(
)
<
StaticPrefs
:
:
dom_vr_display_enumerate_interval
(
)
)
{
return
;
}
}
if
(
!
mEarliestRestartTime
.
IsNull
(
)
&
&
mEarliestRestartTime
>
TimeStamp
:
:
Now
(
)
)
{
return
;
}
mLastDisplayEnumerationTime
=
TimeStamp
:
:
Now
(
)
;
OpenShmem
(
)
;
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
mServiceHost
-
>
StartService
(
)
;
#
endif
if
(
mShmem
)
{
mDisplayInfo
.
Clear
(
)
;
mLastUpdateDisplayInfo
.
Clear
(
)
;
mFrameStarted
=
false
;
mBrowserState
.
Clear
(
)
;
mLastSensorState
.
Clear
(
)
;
mDisplayInfo
.
mGroupMask
=
kVRGroupContent
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
if
(
mShmem
-
>
GetExternalShmem
(
)
)
{
mState
=
VRManagerState
:
:
Enumeration
;
}
#
else
mState
=
VRManagerState
:
:
Enumeration
;
#
endif
}
}
if
(
mState
=
=
VRManagerState
:
:
Enumeration
)
{
MOZ_ASSERT
(
mShmem
!
=
nullptr
)
;
PullState
(
)
;
if
(
mEnumerationCompleted
)
{
if
(
mDisplayInfo
.
mDisplayState
.
isConnected
)
{
mDisplayInfo
.
mDisplayID
=
VRManager
:
:
AllocateDisplayID
(
)
;
mState
=
VRManagerState
:
:
Active
;
}
else
{
Shutdown
(
)
;
}
}
}
}
void
VRManager
:
:
RefreshVRDisplays
(
bool
aMustDispatch
)
{
uint32_t
previousDisplayID
=
mDisplayInfo
.
GetDisplayID
(
)
;
if
(
mVRDisplaysRequested
|
|
aMustDispatch
)
{
EnumerateVRDisplays
(
)
;
}
if
(
mState
=
=
VRManagerState
:
:
Enumeration
)
{
return
;
}
bool
changed
=
false
;
if
(
previousDisplayID
!
=
mDisplayInfo
.
GetDisplayID
(
)
)
{
changed
=
true
;
}
if
(
mState
=
=
VRManagerState
:
:
Active
&
&
mDisplayInfo
!
=
mLastUpdateDisplayInfo
)
{
changed
=
true
;
}
if
(
changed
|
|
aMustDispatch
)
{
DispatchVRDisplayInfoUpdate
(
)
;
}
}
void
VRManager
:
:
DispatchVRDisplayInfoUpdate
(
)
{
nsTArray
<
VRDisplayInfo
>
displayUpdates
;
if
(
mState
=
=
VRManagerState
:
:
Active
)
{
MOZ_ASSERT
(
mDisplayInfo
.
mDisplayID
!
=
0
)
;
displayUpdates
.
AppendElement
(
mDisplayInfo
)
;
}
for
(
auto
iter
=
mVRManagerParents
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
Unused
<
<
iter
.
Get
(
)
-
>
GetKey
(
)
-
>
SendUpdateDisplayInfo
(
displayUpdates
)
;
}
mLastUpdateDisplayInfo
=
mDisplayInfo
;
}
void
VRManager
:
:
StopAllHaptics
(
)
{
for
(
size_t
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
mBrowserState
.
hapticState
)
;
i
+
+
)
{
ClearHapticSlot
(
i
)
;
}
PushState
(
)
;
}
void
VRManager
:
:
VibrateHaptic
(
uint32_t
aControllerIdx
uint32_t
aHapticIndex
double
aIntensity
double
aDuration
const
VRManagerPromise
&
aPromise
)
{
if
(
mState
!
=
VRManagerState
:
:
Active
)
{
return
;
}
uint32_t
controllerBaseIndex
=
kVRControllerMaxCount
*
mDisplayInfo
.
mDisplayID
;
uint32_t
controllerIndex
=
aControllerIdx
-
controllerBaseIndex
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
size_t
bestSlotIndex
=
0
;
for
(
size_t
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
mBrowserState
.
hapticState
)
;
i
+
+
)
{
const
VRHapticState
&
state
=
mBrowserState
.
hapticState
[
i
]
;
if
(
state
.
inputFrameID
=
=
0
)
{
bestSlotIndex
=
i
;
break
;
}
if
(
mHapticPulseRemaining
[
i
]
<
mHapticPulseRemaining
[
bestSlotIndex
]
)
{
bestSlotIndex
=
i
;
}
}
for
(
size_t
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
mBrowserState
.
hapticState
)
;
i
+
+
)
{
const
VRHapticState
&
state
=
mBrowserState
.
hapticState
[
i
]
;
if
(
state
.
inputFrameID
=
=
0
)
{
continue
;
}
if
(
state
.
controllerIndex
=
=
controllerIndex
&
&
state
.
hapticIndex
=
=
aHapticIndex
)
{
bestSlotIndex
=
i
;
}
}
ClearHapticSlot
(
bestSlotIndex
)
;
size_t
bufferIndex
=
mDisplayInfo
.
mFrameId
%
kVRMaxLatencyFrames
;
VRHapticState
&
bestSlot
=
mBrowserState
.
hapticState
[
bestSlotIndex
]
;
bestSlot
.
inputFrameID
=
mDisplayInfo
.
mLastSensorState
[
bufferIndex
]
.
inputFrameID
;
bestSlot
.
controllerIndex
=
controllerIndex
;
bestSlot
.
hapticIndex
=
aHapticIndex
;
bestSlot
.
pulseStart
=
(
float
)
(
now
-
mLastFrameStart
[
bufferIndex
]
)
.
ToSeconds
(
)
;
bestSlot
.
pulseDuration
=
(
float
)
aDuration
*
0
.
001f
;
bestSlot
.
pulseIntensity
=
(
float
)
aIntensity
;
mHapticPulseRemaining
[
bestSlotIndex
]
=
aDuration
;
MOZ_ASSERT
(
bestSlotIndex
<
=
mHapticPromises
.
Length
(
)
)
;
if
(
bestSlotIndex
=
=
mHapticPromises
.
Length
(
)
)
{
mHapticPromises
.
AppendElement
(
UniquePtr
<
VRManagerPromise
>
(
new
VRManagerPromise
(
aPromise
)
)
)
;
}
else
{
mHapticPromises
[
bestSlotIndex
]
=
UniquePtr
<
VRManagerPromise
>
(
new
VRManagerPromise
(
aPromise
)
)
;
}
PushState
(
)
;
}
void
VRManager
:
:
StopVibrateHaptic
(
uint32_t
aControllerIdx
)
{
if
(
mState
!
=
VRManagerState
:
:
Active
)
{
return
;
}
uint32_t
controllerBaseIndex
=
kVRControllerMaxCount
*
mDisplayInfo
.
mDisplayID
;
uint32_t
controllerIndex
=
aControllerIdx
-
controllerBaseIndex
;
for
(
size_t
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
mBrowserState
.
hapticState
)
;
i
+
+
)
{
VRHapticState
&
state
=
mBrowserState
.
hapticState
[
i
]
;
if
(
state
.
controllerIndex
=
=
controllerIndex
)
{
memset
(
&
state
0
sizeof
(
VRHapticState
)
)
;
}
}
PushState
(
)
;
}
void
VRManager
:
:
NotifyVibrateHapticCompleted
(
const
VRManagerPromise
&
aPromise
)
{
aPromise
.
mParent
-
>
SendReplyGamepadVibrateHaptic
(
aPromise
.
mPromiseID
)
;
}
void
VRManager
:
:
StartVRNavigation
(
const
uint32_t
&
aDisplayID
)
{
if
(
mState
!
=
VRManagerState
:
:
Active
)
{
return
;
}
if
(
mDisplayInfo
.
GetDisplayID
(
)
!
=
aDisplayID
)
{
return
;
}
mBrowserState
.
navigationTransitionActive
=
true
;
mVRNavigationTransitionEnd
=
TimeStamp
(
)
;
PushState
(
)
;
}
void
VRManager
:
:
StopVRNavigation
(
const
uint32_t
&
aDisplayID
const
TimeDuration
&
aTimeout
)
{
if
(
mState
!
=
VRManagerState
:
:
Active
)
{
return
;
}
if
(
mDisplayInfo
.
GetDisplayID
(
)
!
=
aDisplayID
)
{
return
;
}
if
(
aTimeout
.
ToMilliseconds
(
)
<
=
0
)
{
mBrowserState
.
navigationTransitionActive
=
false
;
mVRNavigationTransitionEnd
=
TimeStamp
(
)
;
PushState
(
)
;
}
mVRNavigationTransitionEnd
=
TimeStamp
:
:
Now
(
)
+
aTimeout
;
}
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
bool
VRManager
:
:
RunPuppet
(
const
nsTArray
<
uint64_t
>
&
aBuffer
VRManagerParent
*
aManagerParent
)
{
if
(
!
StaticPrefs
:
:
dom_vr_puppet_enabled
(
)
)
{
return
false
;
}
if
(
mManagerParentRunningPuppet
!
=
nullptr
)
{
return
false
;
}
mManagerParentRunningPuppet
=
aManagerParent
;
mServiceHost
-
>
PuppetSubmit
(
aBuffer
)
;
return
true
;
}
void
VRManager
:
:
ResetPuppet
(
VRManagerParent
*
aManagerParent
)
{
mManagerParentsWaitingForPuppetReset
.
PutEntry
(
aManagerParent
)
;
if
(
mManagerParentRunningPuppet
!
=
nullptr
)
{
Unused
<
<
mManagerParentRunningPuppet
-
>
SendNotifyPuppetCommandBufferCompleted
(
false
)
;
mManagerParentRunningPuppet
=
nullptr
;
}
mServiceHost
-
>
PuppetReset
(
)
;
CheckForPuppetCompletion
(
)
;
}
#
endif
void
VRManager
:
:
PullState
(
const
std
:
:
function
<
bool
(
)
>
&
aWaitCondition
)
{
if
(
mShmem
!
=
nullptr
)
{
mShmem
-
>
PullSystemState
(
mDisplayInfo
.
mDisplayState
mLastSensorState
mDisplayInfo
.
mControllerState
mEnumerationCompleted
aWaitCondition
)
;
}
}
void
VRManager
:
:
PushState
(
bool
aNotifyCond
)
{
if
(
mShmem
!
=
nullptr
)
{
mShmem
-
>
PushBrowserState
(
mBrowserState
aNotifyCond
)
;
}
}
void
VRManager
:
:
Destroy
(
)
{
if
(
mState
=
=
VRManagerState
:
:
Disabled
)
{
return
;
}
Shutdown
(
)
;
StopTasks
(
)
;
mState
=
VRManagerState
:
:
Disabled
;
}
void
VRManager
:
:
Shutdown
(
)
{
if
(
mState
=
=
VRManagerState
:
:
Disabled
|
|
mState
=
=
VRManagerState
:
:
Idle
)
{
return
;
}
if
(
mDisplayInfo
.
mDisplayState
.
shutdown
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
mEarliestRestartTime
=
now
+
TimeDuration
:
:
FromMilliseconds
(
(
double
)
mDisplayInfo
.
mDisplayState
.
minRestartInterval
)
;
}
StopAllHaptics
(
)
;
StopPresentation
(
)
;
CancelCurrentSubmitTask
(
)
;
ShutdownSubmitThread
(
)
;
mDisplayInfo
.
Clear
(
)
;
mEnumerationCompleted
=
false
;
if
(
mState
=
=
VRManagerState
:
:
Enumeration
)
{
DispatchVRDisplayInfoUpdate
(
)
;
}
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
mServiceHost
-
>
StopService
(
)
;
#
endif
mState
=
VRManagerState
:
:
Idle
;
}
void
VRManager
:
:
CheckWatchDog
(
)
{
if
(
mState
!
=
VRManagerState
:
:
Active
)
{
return
;
}
bool
bShouldStartFrame
=
false
;
TimeStamp
lastFrameStart
=
mLastFrameStart
[
mDisplayInfo
.
mFrameId
%
kVRMaxLatencyFrames
]
;
if
(
lastFrameStart
.
IsNull
(
)
)
{
bShouldStartFrame
=
true
;
}
else
{
TimeDuration
duration
=
TimeStamp
:
:
Now
(
)
-
lastFrameStart
;
if
(
duration
.
ToMilliseconds
(
)
>
StaticPrefs
:
:
dom_vr_display_rafMaxDuration
(
)
)
{
bShouldStartFrame
=
true
;
}
}
if
(
bShouldStartFrame
)
{
StartFrame
(
)
;
}
}
void
VRManager
:
:
ExpireNavigationTransition
(
)
{
if
(
mState
!
=
VRManagerState
:
:
Active
)
{
return
;
}
if
(
!
mVRNavigationTransitionEnd
.
IsNull
(
)
&
&
TimeStamp
:
:
Now
(
)
>
mVRNavigationTransitionEnd
)
{
mBrowserState
.
navigationTransitionActive
=
false
;
}
}
void
VRManager
:
:
UpdateHaptics
(
double
aDeltaTime
)
{
if
(
mState
!
=
VRManagerState
:
:
Active
)
{
return
;
}
bool
bNeedPush
=
false
;
for
(
size_t
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
mBrowserState
.
hapticState
)
;
i
+
+
)
{
const
VRHapticState
&
state
=
mBrowserState
.
hapticState
[
i
]
;
if
(
state
.
inputFrameID
=
=
0
)
{
continue
;
}
mHapticPulseRemaining
[
i
]
-
=
aDeltaTime
;
if
(
mHapticPulseRemaining
[
i
]
<
=
0
.
0f
)
{
ClearHapticSlot
(
i
)
;
bNeedPush
=
true
;
}
}
if
(
bNeedPush
)
{
PushState
(
)
;
}
}
void
VRManager
:
:
ClearHapticSlot
(
size_t
aSlot
)
{
MOZ_ASSERT
(
aSlot
<
mozilla
:
:
ArrayLength
(
mBrowserState
.
hapticState
)
)
;
memset
(
&
mBrowserState
.
hapticState
[
aSlot
]
0
sizeof
(
VRHapticState
)
)
;
mHapticPulseRemaining
[
aSlot
]
=
0
.
0f
;
if
(
aSlot
<
mHapticPromises
.
Length
(
)
&
&
mHapticPromises
[
aSlot
]
)
{
NotifyVibrateHapticCompleted
(
*
(
mHapticPromises
[
aSlot
]
)
)
;
mHapticPromises
[
aSlot
]
=
nullptr
;
}
}
void
VRManager
:
:
ShutdownSubmitThread
(
)
{
if
(
mSubmitThread
)
{
mSubmitThread
-
>
Shutdown
(
)
;
mSubmitThread
=
nullptr
;
}
}
void
VRManager
:
:
StartPresentation
(
)
{
if
(
mState
!
=
VRManagerState
:
:
Active
)
{
return
;
}
if
(
mBrowserState
.
presentationActive
)
{
return
;
}
mTelemetry
.
Clear
(
)
;
mTelemetry
.
mPresentationStart
=
TimeStamp
:
:
Now
(
)
;
mBrowserState
.
presentationActive
=
true
;
mBrowserState
.
layerState
[
0
]
.
type
=
VRLayerType
:
:
LayerType_Stereo_Immersive
;
PushState
(
)
;
mDisplayInfo
.
mDisplayState
.
lastSubmittedFrameId
=
0
;
if
(
mDisplayInfo
.
mDisplayState
.
reportsDroppedFrames
)
{
mTelemetry
.
mLastDroppedFrameCount
=
mDisplayInfo
.
mDisplayState
.
droppedFrameCount
;
}
mLastSubmittedFrameId
=
0
;
mLastStartedFrame
=
0
;
}
void
VRManager
:
:
StopPresentation
(
)
{
if
(
mState
!
=
VRManagerState
:
:
Active
)
{
return
;
}
if
(
!
mBrowserState
.
presentationActive
)
{
return
;
}
mBrowserState
.
presentationActive
=
false
;
memset
(
mBrowserState
.
layerState
0
sizeof
(
VRLayerState
)
*
mozilla
:
:
ArrayLength
(
mBrowserState
.
layerState
)
)
;
PushState
(
true
)
;
Telemetry
:
:
HistogramID
timeSpentID
=
Telemetry
:
:
HistogramCount
;
Telemetry
:
:
HistogramID
droppedFramesID
=
Telemetry
:
:
HistogramCount
;
int
viewIn
=
0
;
if
(
mDisplayInfo
.
mDisplayState
.
eightCC
=
=
GFX_VR_EIGHTCC
(
'
O
'
'
c
'
'
u
'
'
l
'
'
u
'
'
s
'
'
'
'
D
'
)
)
{
timeSpentID
=
Telemetry
:
:
WEBVR_TIME_SPENT_VIEWING_IN_OCULUS
;
droppedFramesID
=
Telemetry
:
:
WEBVR_DROPPED_FRAMES_IN_OCULUS
;
viewIn
=
1
;
}
else
if
(
mDisplayInfo
.
mDisplayState
.
eightCC
=
=
GFX_VR_EIGHTCC
(
'
O
'
'
p
'
'
e
'
'
n
'
'
V
'
'
R
'
'
'
'
'
)
)
{
timeSpentID
=
Telemetry
:
:
WEBVR_TIME_SPENT_VIEWING_IN_OPENVR
;
droppedFramesID
=
Telemetry
:
:
WEBVR_DROPPED_FRAMES_IN_OPENVR
;
viewIn
=
2
;
}
if
(
viewIn
)
{
const
TimeDuration
duration
=
TimeStamp
:
:
Now
(
)
-
mTelemetry
.
mPresentationStart
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEBVR_USERS_VIEW_IN
viewIn
)
;
Telemetry
:
:
Accumulate
(
timeSpentID
duration
.
ToMilliseconds
(
)
)
;
const
uint32_t
droppedFramesPerSec
=
(
uint32_t
)
(
(
double
)
(
mDisplayInfo
.
mDisplayState
.
droppedFrameCount
-
mTelemetry
.
mLastDroppedFrameCount
)
/
duration
.
ToSeconds
(
)
)
;
Telemetry
:
:
Accumulate
(
droppedFramesID
droppedFramesPerSec
)
;
}
}
bool
VRManager
:
:
IsPresenting
(
)
{
if
(
mShmem
)
{
return
mDisplayInfo
.
mPresentingGroups
!
=
0
;
}
return
false
;
}
void
VRManager
:
:
SetGroupMask
(
uint32_t
aGroupMask
)
{
if
(
mState
!
=
VRManagerState
:
:
Active
)
{
return
;
}
mDisplayInfo
.
mGroupMask
=
aGroupMask
;
}
void
VRManager
:
:
SubmitFrame
(
VRLayerParent
*
aLayer
const
layers
:
:
SurfaceDescriptor
&
aTexture
uint64_t
aFrameId
const
gfx
:
:
Rect
&
aLeftEyeRect
const
gfx
:
:
Rect
&
aRightEyeRect
)
{
if
(
mState
!
=
VRManagerState
:
:
Active
)
{
return
;
}
MonitorAutoLock
lock
(
mCurrentSubmitTaskMonitor
)
;
if
(
(
mDisplayInfo
.
mGroupMask
&
aLayer
-
>
GetGroup
(
)
)
=
=
0
)
{
return
;
}
if
(
!
mFrameStarted
|
|
aFrameId
!
=
mDisplayInfo
.
mFrameId
)
{
return
;
}
if
(
mLastSubmittedFrameId
>
0
&
&
mLastSubmittedFrameId
!
=
mDisplayInfo
.
mDisplayState
.
lastSubmittedFrameId
)
{
mLastStartedFrame
=
0
;
return
;
}
mLastSubmittedFrameId
=
aFrameId
;
mFrameStarted
=
false
;
RefPtr
<
CancelableRunnable
>
task
=
NewCancelableRunnableMethod
<
StoreCopyPassByConstLRef
<
layers
:
:
SurfaceDescriptor
>
uint64_t
StoreCopyPassByConstLRef
<
gfx
:
:
Rect
>
StoreCopyPassByConstLRef
<
gfx
:
:
Rect
>
>
(
"
gfx
:
:
VRManager
:
:
SubmitFrameInternal
"
this
&
VRManager
:
:
SubmitFrameInternal
aTexture
aFrameId
aLeftEyeRect
aRightEyeRect
)
;
if
(
!
mCurrentSubmitTask
)
{
mCurrentSubmitTask
=
task
;
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
if
(
!
mSubmitThread
)
{
mSubmitThread
=
new
VRThread
(
NS_LITERAL_CSTRING
(
"
VR_SubmitFrame
"
)
)
;
}
mSubmitThread
-
>
Start
(
)
;
mSubmitThread
-
>
PostTask
(
task
.
forget
(
)
)
;
#
else
CompositorThreadHolder
:
:
Loop
(
)
-
>
PostTask
(
task
.
forget
(
)
)
;
#
endif
}
}
bool
VRManager
:
:
SubmitFrame
(
const
layers
:
:
SurfaceDescriptor
&
aTexture
uint64_t
aFrameId
const
gfx
:
:
Rect
&
aLeftEyeRect
const
gfx
:
:
Rect
&
aRightEyeRect
)
{
if
(
mState
!
=
VRManagerState
:
:
Active
)
{
return
false
;
}
#
if
defined
(
XP_WIN
)
|
|
defined
(
XP_MACOSX
)
|
|
defined
(
MOZ_WIDGET_ANDROID
)
MOZ_ASSERT
(
mBrowserState
.
layerState
[
0
]
.
type
=
=
VRLayerType
:
:
LayerType_Stereo_Immersive
)
;
VRLayer_Stereo_Immersive
&
layer
=
mBrowserState
.
layerState
[
0
]
.
layer_stereo_immersive
;
switch
(
aTexture
.
type
(
)
)
{
#
if
defined
(
XP_WIN
)
case
SurfaceDescriptor
:
:
TSurfaceDescriptorD3D10
:
{
const
SurfaceDescriptorD3D10
&
surf
=
aTexture
.
get_SurfaceDescriptorD3D10
(
)
;
layer
.
textureType
=
VRLayerTextureType
:
:
LayerTextureType_D3D10SurfaceDescriptor
;
layer
.
textureHandle
=
(
void
*
)
surf
.
handle
(
)
;
layer
.
textureSize
.
width
=
surf
.
size
(
)
.
width
;
layer
.
textureSize
.
height
=
surf
.
size
(
)
.
height
;
}
break
;
#
elif
defined
(
XP_MACOSX
)
case
SurfaceDescriptor
:
:
TSurfaceDescriptorMacIOSurface
:
{
const
auto
&
desc
=
aTexture
.
get_SurfaceDescriptorMacIOSurface
(
)
;
layer
.
textureType
=
VRLayerTextureType
:
:
LayerTextureType_MacIOSurface
;
layer
.
textureHandle
=
desc
.
surfaceId
(
)
;
RefPtr
<
MacIOSurface
>
surf
=
MacIOSurface
:
:
LookupSurface
(
desc
.
surfaceId
(
)
desc
.
scaleFactor
(
)
!
desc
.
isOpaque
(
)
desc
.
yUVColorSpace
(
)
)
;
if
(
surf
)
{
layer
.
textureSize
.
width
=
surf
-
>
GetDevicePixelWidth
(
)
;
layer
.
textureSize
.
height
=
surf
-
>
GetDevicePixelHeight
(
)
;
}
}
break
;
#
elif
defined
(
MOZ_WIDGET_ANDROID
)
case
SurfaceDescriptor
:
:
TSurfaceTextureDescriptor
:
{
const
SurfaceTextureDescriptor
&
desc
=
aTexture
.
get_SurfaceTextureDescriptor
(
)
;
java
:
:
GeckoSurfaceTexture
:
:
LocalRef
surfaceTexture
=
java
:
:
GeckoSurfaceTexture
:
:
Lookup
(
desc
.
handle
(
)
)
;
if
(
!
surfaceTexture
)
{
NS_WARNING
(
"
VRManager
:
:
SubmitFrame
failed
to
get
a
SurfaceTexture
"
)
;
return
false
;
}
layer
.
textureType
=
VRLayerTextureType
:
:
LayerTextureType_GeckoSurfaceTexture
;
layer
.
textureHandle
=
desc
.
handle
(
)
;
layer
.
textureSize
.
width
=
desc
.
size
(
)
.
width
;
layer
.
textureSize
.
height
=
desc
.
size
(
)
.
height
;
}
break
;
#
endif
default
:
{
MOZ_ASSERT
(
false
)
;
return
false
;
}
}
layer
.
frameId
=
aFrameId
;
layer
.
inputFrameId
=
mDisplayInfo
.
mLastSensorState
[
mDisplayInfo
.
mFrameId
%
kVRMaxLatencyFrames
]
.
inputFrameID
;
layer
.
leftEyeRect
.
x
=
aLeftEyeRect
.
x
;
layer
.
leftEyeRect
.
y
=
aLeftEyeRect
.
y
;
layer
.
leftEyeRect
.
width
=
aLeftEyeRect
.
width
;
layer
.
leftEyeRect
.
height
=
aLeftEyeRect
.
height
;
layer
.
rightEyeRect
.
x
=
aRightEyeRect
.
x
;
layer
.
rightEyeRect
.
y
=
aRightEyeRect
.
y
;
layer
.
rightEyeRect
.
width
=
aRightEyeRect
.
width
;
layer
.
rightEyeRect
.
height
=
aRightEyeRect
.
height
;
PushState
(
true
)
;
PullState
(
[
&
]
(
)
{
return
(
mDisplayInfo
.
mDisplayState
.
lastSubmittedFrameId
>
=
aFrameId
)
|
|
mDisplayInfo
.
mDisplayState
.
suppressFrames
|
|
!
mDisplayInfo
.
mDisplayState
.
isConnected
;
}
)
;
if
(
mDisplayInfo
.
mDisplayState
.
suppressFrames
|
|
!
mDisplayInfo
.
mDisplayState
.
isConnected
)
{
return
false
;
}
return
mDisplayInfo
.
mDisplayState
.
lastSubmittedFrameSuccessful
;
#
else
MOZ_ASSERT
(
false
)
;
return
false
;
#
endif
}
void
VRManager
:
:
SubmitFrameInternal
(
const
layers
:
:
SurfaceDescriptor
&
aTexture
uint64_t
aFrameId
const
gfx
:
:
Rect
&
aLeftEyeRect
const
gfx
:
:
Rect
&
aRightEyeRect
)
{
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
MOZ_ASSERT
(
mSubmitThread
-
>
GetThread
(
)
=
=
NS_GetCurrentThread
(
)
)
;
#
endif
AUTO_PROFILER_TRACING
(
"
VR
"
"
SubmitFrameAtVRDisplayExternal
"
OTHER
)
;
{
MonitorAutoLock
lock
(
mCurrentSubmitTaskMonitor
)
;
if
(
!
SubmitFrame
(
aTexture
aFrameId
aLeftEyeRect
aRightEyeRect
)
)
{
mCurrentSubmitTask
=
nullptr
;
return
;
}
mCurrentSubmitTask
=
nullptr
;
}
#
if
defined
(
XP_WIN
)
|
|
defined
(
XP_MACOSX
)
MessageLoop
*
loop
=
CompositorThreadHolder
:
:
Loop
(
)
;
loop
-
>
PostTask
(
NewRunnableMethod
(
"
gfx
:
:
VRManager
:
:
StartFrame
"
this
&
VRManager
:
:
StartFrame
)
)
;
#
elif
defined
(
MOZ_WIDGET_ANDROID
)
StartFrame
(
)
;
#
endif
}
void
VRManager
:
:
CancelCurrentSubmitTask
(
)
{
MonitorAutoLock
lock
(
mCurrentSubmitTaskMonitor
)
;
if
(
mCurrentSubmitTask
)
{
mCurrentSubmitTask
-
>
Cancel
(
)
;
mCurrentSubmitTask
=
nullptr
;
}
}
NS_IMETHODIMP
VRManager
:
:
Observe
(
nsISupports
*
subject
const
char
*
topic
const
char16_t
*
data
)
{
if
(
!
strcmp
(
topic
"
application
-
background
"
)
)
{
mAppPaused
=
true
;
}
else
if
(
!
strcmp
(
topic
"
application
-
foreground
"
)
&
&
mAppPaused
)
{
mAppPaused
=
false
;
StartTasks
(
)
;
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
VRManager
nsIObserver
)
}
}
