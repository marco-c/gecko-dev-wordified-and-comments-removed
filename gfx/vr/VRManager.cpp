#
include
"
VRManager
.
h
"
#
include
"
VRManagerParent
.
h
"
#
include
"
gfxVR
.
h
"
#
include
"
gfxVROpenVR
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
dom
/
VRDisplay
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
gfxVR
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
gfxVROculus
.
h
"
#
endif
#
if
defined
(
XP_WIN
)
|
|
defined
(
XP_MACOSX
)
|
|
defined
(
XP_LINUX
)
#
include
"
gfxVROSVR
.
h
"
#
endif
#
include
"
ipc
/
VRLayerParent
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
gl
;
namespace
mozilla
{
namespace
gfx
{
static
StaticRefPtr
<
VRManager
>
sVRManagerSingleton
;
void
VRManager
:
:
ManagerInit
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
sVRManagerSingleton
=
=
nullptr
)
{
sVRManagerSingleton
=
new
VRManager
(
)
;
ClearOnShutdown
(
&
sVRManagerSingleton
)
;
}
}
VRManager
:
:
VRManager
(
)
:
mInitialized
(
false
)
{
MOZ_COUNT_CTOR
(
VRManager
)
;
MOZ_ASSERT
(
sVRManagerSingleton
=
=
nullptr
)
;
RefPtr
<
VRDisplayManager
>
mgr
;
#
if
defined
(
XP_WIN
)
mgr
=
VRDisplayManagerOculus
:
:
Create
(
)
;
if
(
mgr
)
{
mManagers
.
AppendElement
(
mgr
)
;
}
#
endif
#
if
defined
(
XP_WIN
)
|
|
defined
(
XP_MACOSX
)
|
|
defined
(
XP_LINUX
)
mgr
=
VRDisplayManagerOpenVR
:
:
Create
(
)
;
if
(
mgr
)
{
mManagers
.
AppendElement
(
mgr
)
;
}
mgr
=
VRDisplayManagerOSVR
:
:
Create
(
)
;
if
(
mgr
)
{
mManagers
.
AppendElement
(
mgr
)
;
}
#
endif
}
VRManager
:
:
~
VRManager
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
mInitialized
)
;
MOZ_COUNT_DTOR
(
VRManager
)
;
}
void
VRManager
:
:
Destroy
(
)
{
mVRDisplays
.
Clear
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mManagers
.
Length
(
)
;
+
+
i
)
{
mManagers
[
i
]
-
>
Destroy
(
)
;
}
mInitialized
=
false
;
}
void
VRManager
:
:
Init
(
)
{
for
(
uint32_t
i
=
0
;
i
<
mManagers
.
Length
(
)
;
+
+
i
)
{
mManagers
[
i
]
-
>
Init
(
)
;
}
mInitialized
=
true
;
}
VRManager
*
VRManager
:
:
Get
(
)
{
MOZ_ASSERT
(
sVRManagerSingleton
!
=
nullptr
)
;
return
sVRManagerSingleton
;
}
void
VRManager
:
:
AddVRManagerParent
(
VRManagerParent
*
aVRManagerParent
)
{
if
(
mVRManagerParents
.
IsEmpty
(
)
)
{
Init
(
)
;
}
mVRManagerParents
.
PutEntry
(
aVRManagerParent
)
;
}
void
VRManager
:
:
RemoveVRManagerParent
(
VRManagerParent
*
aVRManagerParent
)
{
mVRManagerParents
.
RemoveEntry
(
aVRManagerParent
)
;
if
(
mVRManagerParents
.
IsEmpty
(
)
)
{
Destroy
(
)
;
}
}
void
VRManager
:
:
NotifyVsync
(
const
TimeStamp
&
aVsyncTimestamp
)
{
const
double
kVRDisplayRefreshMaxDuration
=
5000
;
bool
bHaveEventListener
=
false
;
for
(
auto
iter
=
mVRManagerParents
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
VRManagerParent
*
vmp
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
Unused
<
<
vmp
-
>
SendNotifyVSync
(
)
;
bHaveEventListener
|
=
vmp
-
>
HaveEventListener
(
)
;
}
for
(
auto
iter
=
mVRDisplays
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
gfx
:
:
VRDisplayHost
*
display
=
iter
.
UserData
(
)
;
display
-
>
NotifyVSync
(
)
;
}
if
(
bHaveEventListener
)
{
if
(
mLastRefreshTime
.
IsNull
(
)
)
{
RefreshVRDisplays
(
)
;
}
else
{
TimeDuration
duration
=
TimeStamp
:
:
Now
(
)
-
mLastRefreshTime
;
if
(
duration
.
ToMilliseconds
(
)
>
kVRDisplayRefreshMaxDuration
)
{
RefreshVRDisplays
(
)
;
}
}
}
}
void
VRManager
:
:
NotifyVRVsync
(
const
uint32_t
&
aDisplayID
)
{
for
(
auto
iter
=
mVRManagerParents
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
Unused
<
<
iter
.
Get
(
)
-
>
GetKey
(
)
-
>
SendNotifyVRVSync
(
aDisplayID
)
;
}
}
void
VRManager
:
:
RefreshVRDisplays
(
bool
aMustDispatch
)
{
nsTArray
<
RefPtr
<
gfx
:
:
VRDisplayHost
>
>
displays
;
for
(
uint32_t
i
=
0
;
i
<
mManagers
.
Length
(
)
&
&
displays
.
Length
(
)
=
=
0
;
+
+
i
)
{
mManagers
[
i
]
-
>
GetHMDs
(
displays
)
;
}
bool
displayInfoChanged
=
false
;
if
(
displays
.
Length
(
)
!
=
mVRDisplays
.
Count
(
)
)
{
displayInfoChanged
=
true
;
}
for
(
const
auto
&
display
:
displays
)
{
if
(
!
GetDisplay
(
display
-
>
GetDisplayInfo
(
)
.
GetDisplayID
(
)
)
)
{
displayInfoChanged
=
true
;
break
;
}
if
(
display
-
>
CheckClearDisplayInfoDirty
(
)
)
{
displayInfoChanged
=
true
;
break
;
}
}
if
(
displayInfoChanged
)
{
mVRDisplays
.
Clear
(
)
;
for
(
const
auto
&
display
:
displays
)
{
mVRDisplays
.
Put
(
display
-
>
GetDisplayInfo
(
)
.
GetDisplayID
(
)
display
)
;
}
}
if
(
displayInfoChanged
|
|
aMustDispatch
)
{
DispatchVRDisplayInfoUpdate
(
)
;
}
mLastRefreshTime
=
TimeStamp
:
:
Now
(
)
;
}
void
VRManager
:
:
DispatchVRDisplayInfoUpdate
(
)
{
nsTArray
<
VRDisplayInfo
>
update
;
GetVRDisplayInfo
(
update
)
;
for
(
auto
iter
=
mVRManagerParents
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
Unused
<
<
iter
.
Get
(
)
-
>
GetKey
(
)
-
>
SendUpdateDisplayInfo
(
update
)
;
}
}
void
VRManager
:
:
GetVRDisplayInfo
(
nsTArray
<
VRDisplayInfo
>
&
aDisplayInfo
)
{
aDisplayInfo
.
Clear
(
)
;
for
(
auto
iter
=
mVRDisplays
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
gfx
:
:
VRDisplayHost
*
display
=
iter
.
UserData
(
)
;
aDisplayInfo
.
AppendElement
(
VRDisplayInfo
(
display
-
>
GetDisplayInfo
(
)
)
)
;
}
}
RefPtr
<
gfx
:
:
VRDisplayHost
>
VRManager
:
:
GetDisplay
(
const
uint32_t
&
aDisplayID
)
{
RefPtr
<
gfx
:
:
VRDisplayHost
>
display
;
if
(
mVRDisplays
.
Get
(
aDisplayID
getter_AddRefs
(
display
)
)
)
{
return
display
;
}
return
nullptr
;
}
void
VRManager
:
:
SubmitFrame
(
VRLayerParent
*
aLayer
layers
:
:
PTextureParent
*
aTexture
const
gfx
:
:
Rect
&
aLeftEyeRect
const
gfx
:
:
Rect
&
aRightEyeRect
)
{
TextureHost
*
th
=
TextureHost
:
:
AsTextureHost
(
aTexture
)
;
mLastFrame
=
th
;
RefPtr
<
VRDisplayHost
>
display
=
GetDisplay
(
aLayer
-
>
GetDisplayID
(
)
)
;
if
(
display
)
{
display
-
>
SubmitFrame
(
aLayer
0
aTexture
aLeftEyeRect
aRightEyeRect
)
;
}
}
}
}
