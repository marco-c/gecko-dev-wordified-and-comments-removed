#
include
"
VRPuppetCommandBuffer
.
h
"
#
include
"
prthread
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
namespace
mozilla
{
namespace
gfx
{
static
StaticRefPtr
<
VRPuppetCommandBuffer
>
sVRPuppetCommandBufferSingleton
;
VRPuppetCommandBuffer
&
VRPuppetCommandBuffer
:
:
Get
(
)
{
if
(
sVRPuppetCommandBufferSingleton
=
=
nullptr
)
{
sVRPuppetCommandBufferSingleton
=
new
VRPuppetCommandBuffer
(
)
;
ClearOnShutdown
(
&
sVRPuppetCommandBufferSingleton
)
;
}
return
*
sVRPuppetCommandBufferSingleton
;
}
VRPuppetCommandBuffer
:
:
VRPuppetCommandBuffer
(
)
:
mMutex
(
"
VRPuppetCommandBuffer
:
:
mMutex
"
)
{
MOZ_COUNT_CTOR
(
VRPuppetCommandBuffer
)
;
MOZ_ASSERT
(
sVRPuppetCommandBufferSingleton
=
=
nullptr
)
;
Reset
(
)
;
}
VRPuppetCommandBuffer
:
:
~
VRPuppetCommandBuffer
(
)
{
MOZ_COUNT_DTOR
(
VRPuppetCommandBuffer
)
;
}
void
VRPuppetCommandBuffer
:
:
Submit
(
const
nsTArray
<
uint64_t
>
&
aBuffer
)
{
MutexAutoLock
lock
(
mMutex
)
;
mBuffer
.
AppendElements
(
aBuffer
)
;
mEnded
=
false
;
mEndedWithTimeout
=
false
;
}
bool
VRPuppetCommandBuffer
:
:
HasEnded
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mEnded
;
}
void
VRPuppetCommandBuffer
:
:
Reset
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
memset
(
&
mPendingState
0
sizeof
(
VRSystemState
)
)
;
memset
(
&
mCommittedState
0
sizeof
(
VRSystemState
)
)
;
for
(
int
iControllerIdx
=
0
;
iControllerIdx
<
kVRControllerMaxCount
;
iControllerIdx
+
+
)
{
for
(
int
iHaptic
=
0
;
iHaptic
<
kNumPuppetHaptics
;
iHaptic
+
+
)
{
mHapticPulseRemaining
[
iControllerIdx
]
[
iHaptic
]
=
0
.
0f
;
mHapticPulseIntensity
[
iControllerIdx
]
[
iHaptic
]
=
0
.
0f
;
}
}
mDataOffset
=
0
;
mPresentationRequested
=
false
;
mFrameSubmitted
=
false
;
mFrameAccepted
=
false
;
mTimeoutDuration
=
10
.
0f
;
mWaitRemaining
=
0
.
0f
;
mBlockedTime
=
0
.
0f
;
mTimerElapsed
=
0
.
0f
;
mEnded
=
true
;
mEndedWithTimeout
=
false
;
mLastRunTimestamp
=
TimeStamp
(
)
;
mTimerSamples
.
Clear
(
)
;
mBuffer
.
Clear
(
)
;
}
bool
VRPuppetCommandBuffer
:
:
RunCommand
(
uint64_t
aCommand
double
aDeltaTime
)
{
switch
(
(
VRPuppet_Command
)
(
aCommand
&
0xff00000000000000
)
)
{
case
VRPuppet_Command
:
:
VRPuppet_End
:
CompleteTest
(
false
)
;
break
;
case
VRPuppet_Command
:
:
VRPuppet_ClearAll
:
memset
(
&
mPendingState
0
sizeof
(
VRSystemState
)
)
;
memset
(
&
mCommittedState
0
sizeof
(
VRSystemState
)
)
;
mPresentationRequested
=
false
;
mFrameSubmitted
=
false
;
mFrameAccepted
=
false
;
break
;
case
VRPuppet_Command
:
:
VRPuppet_ClearController
:
{
uint8_t
controllerIdx
=
aCommand
&
0x00000000000000ff
;
if
(
controllerIdx
<
kVRControllerMaxCount
)
{
mPendingState
.
controllerState
[
controllerIdx
]
.
Clear
(
)
;
}
}
break
;
case
VRPuppet_Command
:
:
VRPuppet_Timeout
:
mTimeoutDuration
=
(
double
)
(
aCommand
&
0x00000000ffffffff
)
/
1000
.
0f
;
break
;
case
VRPuppet_Command
:
:
VRPuppet_Wait
:
if
(
mWaitRemaining
=
=
0
.
0f
)
{
mWaitRemaining
=
(
double
)
(
aCommand
&
0x00000000ffffffff
)
/
1000
.
0f
;
return
false
;
}
mWaitRemaining
-
=
aDeltaTime
;
if
(
mWaitRemaining
>
0
.
0f
)
{
return
false
;
}
mWaitRemaining
=
0
.
0f
;
break
;
case
VRPuppet_Command
:
:
VRPuppet_WaitSubmit
:
if
(
!
mFrameSubmitted
)
{
return
false
;
}
break
;
case
VRPuppet_Command
:
:
VRPuppet_CaptureFrame
:
break
;
case
VRPuppet_Command
:
:
VRPuppet_AcknowledgeFrame
:
mFrameSubmitted
=
false
;
mFrameAccepted
=
true
;
break
;
case
VRPuppet_Command
:
:
VRPuppet_RejectFrame
:
mFrameSubmitted
=
false
;
mFrameAccepted
=
false
;
break
;
case
VRPuppet_Command
:
:
VRPuppet_WaitPresentationStart
:
if
(
!
mPresentationRequested
)
{
return
false
;
}
break
;
case
VRPuppet_Command
:
:
VRPuppet_WaitPresentationEnd
:
if
(
mPresentationRequested
)
{
return
false
;
}
break
;
case
VRPuppet_Command
:
:
VRPuppet_WaitHapticIntensity
:
{
uint8_t
iControllerIdx
=
(
aCommand
&
0x0000ff0000000000
)
>
>
40
;
if
(
iControllerIdx
>
=
kVRControllerMaxCount
)
{
return
false
;
}
uint8_t
iHapticIdx
=
(
aCommand
&
0x000000ff00000000
)
>
>
32
;
if
(
iHapticIdx
>
=
kNumPuppetHaptics
)
{
return
false
;
}
uint32_t
iHapticIntensity
=
aCommand
&
0x00000000ffffffff
;
SimulateHaptics
(
aDeltaTime
)
;
uint64_t
iCurrentIntensity
=
round
(
mHapticPulseIntensity
[
iControllerIdx
]
[
iHapticIdx
]
*
(
1
<
<
16
)
)
;
if
(
iCurrentIntensity
>
0xffffffff
)
{
iCurrentIntensity
=
0xffffffff
;
}
if
(
iCurrentIntensity
!
=
iHapticIntensity
)
{
return
false
;
}
}
break
;
case
VRPuppet_Command
:
:
VRPuppet_StartTimer
:
mTimerElapsed
=
0
.
0f
;
break
;
case
VRPuppet_Command
:
:
VRPuppet_StopTimer
:
mTimerSamples
.
AppendElements
(
mTimerElapsed
)
;
break
;
case
VRPuppet_Command
:
:
VRPuppet_UpdateDisplay
:
mDataOffset
=
(
uint8_t
*
)
&
mPendingState
.
displayState
-
(
uint8_t
*
)
&
mPendingState
+
(
aCommand
&
0x00000000ffffffff
)
;
break
;
case
VRPuppet_Command
:
:
VRPuppet_UpdateSensor
:
mDataOffset
=
(
uint8_t
*
)
&
mPendingState
.
sensorState
-
(
uint8_t
*
)
&
mPendingState
+
(
aCommand
&
0x00000000ffffffff
)
;
break
;
case
VRPuppet_Command
:
:
VRPuppet_UpdateControllers
:
mDataOffset
=
(
uint8_t
*
)
&
mPendingState
.
controllerState
[
aCommand
&
0x00000000000000ff
]
-
(
uint8_t
*
)
&
mPendingState
+
(
aCommand
&
0x00000000ffffffff
)
;
break
;
case
VRPuppet_Command
:
:
VRPuppet_Commit
:
memcpy
(
&
mCommittedState
&
mPendingState
sizeof
(
VRSystemState
)
)
;
break
;
case
VRPuppet_Command
:
:
VRPuppet_Data7
:
WriteData
(
(
aCommand
&
0x00ff000000000000
)
>
>
48
)
;
MOZ_FALLTHROUGH
;
case
VRPuppet_Command
:
:
VRPuppet_Data6
:
WriteData
(
(
aCommand
&
0x0000ff0000000000
)
>
>
40
)
;
MOZ_FALLTHROUGH
;
case
VRPuppet_Command
:
:
VRPuppet_Data5
:
WriteData
(
(
aCommand
&
0x000000ff00000000
)
>
>
32
)
;
MOZ_FALLTHROUGH
;
case
VRPuppet_Command
:
:
VRPuppet_Data4
:
WriteData
(
(
aCommand
&
0x00000000ff000000
)
>
>
24
)
;
MOZ_FALLTHROUGH
;
case
VRPuppet_Command
:
:
VRPuppet_Data3
:
WriteData
(
(
aCommand
&
0x0000000000ff0000
)
>
>
16
)
;
MOZ_FALLTHROUGH
;
case
VRPuppet_Command
:
:
VRPuppet_Data2
:
WriteData
(
(
aCommand
&
0x000000000000ff00
)
>
>
8
)
;
MOZ_FALLTHROUGH
;
case
VRPuppet_Command
:
:
VRPuppet_Data1
:
WriteData
(
aCommand
&
0x00000000000000ff
)
;
break
;
}
return
true
;
}
void
VRPuppetCommandBuffer
:
:
WriteData
(
uint8_t
aData
)
{
if
(
mDataOffset
&
&
mDataOffset
<
sizeof
(
VRSystemState
)
)
{
(
(
uint8_t
*
)
&
mPendingState
)
[
mDataOffset
+
+
]
=
aData
;
}
}
void
VRPuppetCommandBuffer
:
:
Run
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
double
deltaTime
=
0
.
0f
;
if
(
!
mLastRunTimestamp
.
IsNull
(
)
)
{
deltaTime
=
(
now
-
mLastRunTimestamp
)
.
ToSeconds
(
)
;
}
mLastRunTimestamp
=
now
;
mTimerElapsed
+
=
deltaTime
;
size_t
transactionLength
=
0
;
while
(
transactionLength
<
mBuffer
.
Length
(
)
&
&
!
mEnded
)
{
if
(
RunCommand
(
mBuffer
[
transactionLength
]
deltaTime
)
)
{
mBlockedTime
=
0
.
0f
;
transactionLength
+
+
;
}
else
{
mBlockedTime
+
=
deltaTime
;
if
(
mBlockedTime
>
mTimeoutDuration
)
{
CompleteTest
(
true
)
;
}
break
;
}
}
mBuffer
.
RemoveElementsAt
(
0
transactionLength
)
;
}
void
VRPuppetCommandBuffer
:
:
Run
(
VRSystemState
&
aState
)
{
Run
(
)
;
bool
bEnumerationCompleted
=
aState
.
enumerationCompleted
;
bool
bShutdown
=
aState
.
displayState
.
shutdown
;
uint32_t
minRestartInterval
=
aState
.
displayState
.
minRestartInterval
;
memcpy
(
&
aState
&
mCommittedState
sizeof
(
VRSystemState
)
)
;
aState
.
enumerationCompleted
=
bEnumerationCompleted
;
aState
.
displayState
.
shutdown
=
bShutdown
;
aState
.
displayState
.
minRestartInterval
=
minRestartInterval
;
}
void
VRPuppetCommandBuffer
:
:
StartPresentation
(
)
{
mPresentationRequested
=
true
;
Run
(
)
;
}
void
VRPuppetCommandBuffer
:
:
StopPresentation
(
)
{
mPresentationRequested
=
false
;
Run
(
)
;
}
bool
VRPuppetCommandBuffer
:
:
SubmitFrame
(
)
{
mFrameSubmitted
=
true
;
mFrameAccepted
=
false
;
while
(
true
)
{
Run
(
)
;
if
(
!
mFrameSubmitted
|
|
mEnded
)
{
break
;
}
PR_Sleep
(
PR_INTERVAL_NO_WAIT
)
;
}
return
mFrameAccepted
;
}
void
VRPuppetCommandBuffer
:
:
VibrateHaptic
(
uint32_t
aControllerIdx
uint32_t
aHapticIndex
float
aIntensity
float
aDuration
)
{
if
(
aHapticIndex
>
=
kNumPuppetHaptics
|
|
aControllerIdx
>
=
kVRControllerMaxCount
)
{
return
;
}
Run
(
)
;
mHapticPulseRemaining
[
aControllerIdx
]
[
aHapticIndex
]
=
aDuration
;
mHapticPulseIntensity
[
aControllerIdx
]
[
aHapticIndex
]
=
aIntensity
;
Run
(
)
;
}
void
VRPuppetCommandBuffer
:
:
StopVibrateHaptic
(
uint32_t
aControllerIdx
)
{
if
(
aControllerIdx
>
=
kVRControllerMaxCount
)
{
return
;
}
Run
(
)
;
for
(
int
iHaptic
=
0
;
iHaptic
<
kNumPuppetHaptics
;
iHaptic
+
+
)
{
mHapticPulseRemaining
[
aControllerIdx
]
[
iHaptic
]
=
0
.
0f
;
mHapticPulseIntensity
[
aControllerIdx
]
[
iHaptic
]
=
0
.
0f
;
}
Run
(
)
;
}
void
VRPuppetCommandBuffer
:
:
StopAllHaptics
(
)
{
Run
(
)
;
for
(
int
iControllerIdx
=
0
;
iControllerIdx
<
kVRControllerMaxCount
;
iControllerIdx
+
+
)
{
for
(
int
iHaptic
=
0
;
iHaptic
<
kNumPuppetHaptics
;
iHaptic
+
+
)
{
mHapticPulseRemaining
[
iControllerIdx
]
[
iHaptic
]
=
0
.
0f
;
mHapticPulseIntensity
[
iControllerIdx
]
[
iHaptic
]
=
0
.
0f
;
}
}
Run
(
)
;
}
void
VRPuppetCommandBuffer
:
:
SimulateHaptics
(
double
aDeltaTime
)
{
for
(
int
iControllerIdx
=
0
;
iControllerIdx
<
kVRControllerMaxCount
;
iControllerIdx
+
+
)
{
for
(
int
iHaptic
=
0
;
iHaptic
<
kNumPuppetHaptics
;
iHaptic
+
+
)
{
if
(
mHapticPulseIntensity
[
iControllerIdx
]
[
iHaptic
]
>
0
.
0f
)
{
mHapticPulseRemaining
[
iControllerIdx
]
[
iHaptic
]
-
=
aDeltaTime
;
if
(
mHapticPulseRemaining
[
iControllerIdx
]
[
iHaptic
]
<
=
0
.
0f
)
{
mHapticPulseRemaining
[
iControllerIdx
]
[
iHaptic
]
=
0
.
0f
;
mHapticPulseIntensity
[
iControllerIdx
]
[
iHaptic
]
=
0
.
0f
;
}
}
}
}
}
void
VRPuppetCommandBuffer
:
:
CompleteTest
(
bool
aTimedOut
)
{
mEndedWithTimeout
=
aTimedOut
;
mEnded
=
true
;
}
void
VRPuppetCommandBuffer
:
:
EncodeStruct
(
nsTArray
<
uint64_t
>
&
aBuffer
uint8_t
*
aSrcStart
uint8_t
*
aDstStart
size_t
aLength
VRPuppet_Command
aUpdateCommand
)
{
uint8_t
*
src
=
aSrcStart
;
uint8_t
*
dst
=
aDstStart
;
uint8_t
bufLen
=
0
;
uint64_t
bufData
=
0
;
auto
purgeBuffer
=
[
&
]
(
)
{
if
(
bufLen
>
0
)
{
MOZ_ASSERT
(
bufLen
<
=
7
)
;
uint64_t
command
=
(
uint64_t
)
VRPuppet_Command
:
:
VRPuppet_Data1
;
command
+
=
(
(
uint64_t
)
VRPuppet_Command
:
:
VRPuppet_Data2
-
(
uint64_t
)
VRPuppet_Command
:
:
VRPuppet_Data1
)
*
(
bufLen
-
1
)
;
command
|
=
bufData
;
aBuffer
.
AppendElement
(
command
)
;
bufLen
=
0
;
bufData
=
0
;
}
}
;
for
(
size_t
i
=
0
;
i
<
aLength
;
i
+
+
)
{
if
(
*
src
!
=
*
dst
)
{
*
dst
=
*
src
;
if
(
bufLen
=
=
0
)
{
aBuffer
.
AppendElement
(
(
uint64_t
)
aUpdateCommand
+
i
)
;
bufLen
=
1
;
bufData
=
*
src
;
}
else
if
(
bufLen
<
=
6
)
{
bufData
=
(
bufData
<
<
8
)
|
*
src
;
bufLen
+
+
;
}
else
{
MOZ_ASSERT
(
bufLen
=
=
7
)
;
aBuffer
.
AppendElement
(
(
uint64_t
)
VRPuppet_Command
:
:
VRPuppet_Data7
+
bufData
)
;
bufLen
=
1
;
bufData
=
*
src
;
}
}
else
{
purgeBuffer
(
)
;
}
+
+
src
;
+
+
dst
;
}
purgeBuffer
(
)
;
}
}
}
