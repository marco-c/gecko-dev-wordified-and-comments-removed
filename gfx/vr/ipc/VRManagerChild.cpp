#
include
"
VRManagerChild
.
h
"
#
include
"
VRManagerParent
.
h
"
#
include
"
VRDisplayClient
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
dom
/
Navigator
.
h
"
#
include
"
mozilla
/
dom
/
VREventObserver
.
h
"
#
include
"
mozilla
/
dom
/
WindowBinding
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
dom
/
GamepadManager
.
h
"
using
layers
:
:
TextureClient
;
namespace
{
const
nsTArray
<
RefPtr
<
dom
:
:
VREventObserver
>
>
:
:
index_type
kNoIndex
=
nsTArray
<
RefPtr
<
dom
:
:
VREventObserver
>
>
:
:
NoIndex
;
}
namespace
mozilla
{
namespace
gfx
{
static
StaticRefPtr
<
VRManagerChild
>
sVRManagerChildSingleton
;
static
StaticRefPtr
<
VRManagerParent
>
sVRManagerParentSingleton
;
void
ReleaseVRManagerParentSingleton
(
)
{
sVRManagerParentSingleton
=
nullptr
;
}
VRManagerChild
:
:
VRManagerChild
(
)
:
TextureForwarder
(
)
mDisplaysInitialized
(
false
)
mInputFrameID
(
-
1
)
mMessageLoop
(
MessageLoop
:
:
current
(
)
)
mFrameRequestCallbackCounter
(
0
)
mBackend
(
layers
:
:
LayersBackend
:
:
LAYERS_NONE
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mStartTimeStamp
=
TimeStamp
:
:
Now
(
)
;
}
VRManagerChild
:
:
~
VRManagerChild
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
void
VRManagerChild
:
:
IdentifyTextureHost
(
const
TextureFactoryIdentifier
&
aIdentifier
)
{
if
(
sVRManagerChildSingleton
)
{
sVRManagerChildSingleton
-
>
mBackend
=
aIdentifier
.
mParentBackend
;
sVRManagerChildSingleton
-
>
mSyncObject
=
SyncObject
:
:
CreateSyncObject
(
aIdentifier
.
mSyncHandle
)
;
}
}
layers
:
:
LayersBackend
VRManagerChild
:
:
GetBackendType
(
)
const
{
return
mBackend
;
}
VRManagerChild
*
VRManagerChild
:
:
Get
(
)
{
MOZ_ASSERT
(
sVRManagerChildSingleton
)
;
return
sVRManagerChildSingleton
;
}
bool
VRManagerChild
:
:
IsCreated
(
)
{
return
!
!
sVRManagerChildSingleton
;
}
bool
VRManagerChild
:
:
InitForContent
(
Endpoint
<
PVRManagerChild
>
&
&
aEndpoint
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
sVRManagerChildSingleton
)
;
RefPtr
<
VRManagerChild
>
child
(
new
VRManagerChild
(
)
)
;
if
(
!
aEndpoint
.
Bind
(
child
)
)
{
NS_RUNTIMEABORT
(
"
Couldn
'
t
Open
(
)
Compositor
channel
.
"
)
;
return
false
;
}
sVRManagerChildSingleton
=
child
;
return
true
;
}
bool
VRManagerChild
:
:
ReinitForContent
(
Endpoint
<
PVRManagerChild
>
&
&
aEndpoint
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
ShutDown
(
)
;
return
InitForContent
(
Move
(
aEndpoint
)
)
;
}
void
VRManagerChild
:
:
InitSameProcess
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
sVRManagerChildSingleton
)
;
sVRManagerChildSingleton
=
new
VRManagerChild
(
)
;
sVRManagerParentSingleton
=
VRManagerParent
:
:
CreateSameProcess
(
)
;
sVRManagerChildSingleton
-
>
Open
(
sVRManagerParentSingleton
-
>
GetIPCChannel
(
)
mozilla
:
:
layers
:
:
CompositorThreadHolder
:
:
Loop
(
)
mozilla
:
:
ipc
:
:
ChildSide
)
;
}
void
VRManagerChild
:
:
InitWithGPUProcess
(
Endpoint
<
PVRManagerChild
>
&
&
aEndpoint
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
sVRManagerChildSingleton
)
;
sVRManagerChildSingleton
=
new
VRManagerChild
(
)
;
if
(
!
aEndpoint
.
Bind
(
sVRManagerChildSingleton
)
)
{
NS_RUNTIMEABORT
(
"
Couldn
'
t
Open
(
)
Compositor
channel
.
"
)
;
return
;
}
}
void
VRManagerChild
:
:
ShutDown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
sVRManagerChildSingleton
)
{
sVRManagerChildSingleton
-
>
Destroy
(
)
;
sVRManagerChildSingleton
=
nullptr
;
}
}
void
VRManagerChild
:
:
DeferredDestroy
(
RefPtr
<
VRManagerChild
>
aVRManagerChild
)
{
aVRManagerChild
-
>
Close
(
)
;
}
void
VRManagerChild
:
:
Destroy
(
)
{
mTexturesWaitingRecycled
.
Clear
(
)
;
RefPtr
<
VRManagerChild
>
selfRef
=
this
;
MessageLoop
:
:
current
(
)
-
>
PostTask
(
NewRunnableFunction
(
DeferredDestroy
selfRef
)
)
;
}
layers
:
:
PTextureChild
*
VRManagerChild
:
:
AllocPTextureChild
(
const
SurfaceDescriptor
&
const
LayersBackend
&
const
TextureFlags
&
const
uint64_t
&
)
{
return
TextureClient
:
:
CreateIPDLActor
(
)
;
}
bool
VRManagerChild
:
:
DeallocPTextureChild
(
PTextureChild
*
actor
)
{
return
TextureClient
:
:
DestroyIPDLActor
(
actor
)
;
}
PVRLayerChild
*
VRManagerChild
:
:
AllocPVRLayerChild
(
const
uint32_t
&
aDisplayID
const
float
&
aLeftEyeX
const
float
&
aLeftEyeY
const
float
&
aLeftEyeWidth
const
float
&
aLeftEyeHeight
const
float
&
aRightEyeX
const
float
&
aRightEyeY
const
float
&
aRightEyeWidth
const
float
&
aRightEyeHeight
)
{
RefPtr
<
VRLayerChild
>
layer
=
new
VRLayerChild
(
aDisplayID
this
)
;
return
layer
.
forget
(
)
.
take
(
)
;
}
bool
VRManagerChild
:
:
DeallocPVRLayerChild
(
PVRLayerChild
*
actor
)
{
delete
actor
;
return
true
;
}
void
VRManagerChild
:
:
UpdateDisplayInfo
(
nsTArray
<
VRDisplayInfo
>
&
aDisplayUpdates
)
{
nsTArray
<
uint32_t
>
disconnectedDisplays
;
nsTArray
<
uint32_t
>
connectedDisplays
;
for
(
auto
&
display
:
mDisplays
)
{
bool
found
=
false
;
for
(
auto
&
displayUpdate
:
aDisplayUpdates
)
{
if
(
display
-
>
GetDisplayInfo
(
)
.
GetDisplayID
(
)
=
=
displayUpdate
.
GetDisplayID
(
)
)
{
found
=
true
;
break
;
}
}
if
(
!
found
)
{
display
-
>
NotifyDisconnected
(
)
;
disconnectedDisplays
.
AppendElement
(
display
-
>
GetDisplayInfo
(
)
.
GetDisplayID
(
)
)
;
}
}
nsTArray
<
RefPtr
<
VRDisplayClient
>
>
displays
;
for
(
VRDisplayInfo
&
displayUpdate
:
aDisplayUpdates
)
{
bool
isNewDisplay
=
true
;
for
(
auto
&
display
:
mDisplays
)
{
const
VRDisplayInfo
&
prevInfo
=
display
-
>
GetDisplayInfo
(
)
;
if
(
prevInfo
.
GetDisplayID
(
)
=
=
displayUpdate
.
GetDisplayID
(
)
)
{
if
(
displayUpdate
.
GetIsConnected
(
)
&
&
!
prevInfo
.
GetIsConnected
(
)
)
{
connectedDisplays
.
AppendElement
(
displayUpdate
.
GetDisplayID
(
)
)
;
}
if
(
!
displayUpdate
.
GetIsConnected
(
)
&
&
prevInfo
.
GetIsConnected
(
)
)
{
disconnectedDisplays
.
AppendElement
(
displayUpdate
.
GetDisplayID
(
)
)
;
}
display
-
>
UpdateDisplayInfo
(
displayUpdate
)
;
displays
.
AppendElement
(
display
)
;
isNewDisplay
=
false
;
break
;
}
}
if
(
isNewDisplay
)
{
displays
.
AppendElement
(
new
VRDisplayClient
(
displayUpdate
)
)
;
connectedDisplays
.
AppendElement
(
displayUpdate
.
GetDisplayID
(
)
)
;
}
}
mDisplays
=
displays
;
for
(
uint32_t
displayID
:
disconnectedDisplays
)
{
FireDOMVRDisplayDisconnectEvent
(
displayID
)
;
}
for
(
uint32_t
displayID
:
connectedDisplays
)
{
FireDOMVRDisplayConnectEvent
(
displayID
)
;
}
mDisplaysInitialized
=
true
;
}
mozilla
:
:
ipc
:
:
IPCResult
VRManagerChild
:
:
RecvUpdateDisplayInfo
(
nsTArray
<
VRDisplayInfo
>
&
&
aDisplayUpdates
)
{
UpdateDisplayInfo
(
aDisplayUpdates
)
;
for
(
auto
&
windowId
:
mNavigatorCallbacks
)
{
nsGlobalWindow
*
window
=
nsGlobalWindow
:
:
GetInnerWindowWithId
(
windowId
)
;
if
(
!
window
)
{
continue
;
}
ErrorResult
result
;
dom
:
:
Navigator
*
nav
=
window
-
>
GetNavigator
(
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
continue
;
}
nav
-
>
NotifyVRDisplaysUpdated
(
)
;
}
mNavigatorCallbacks
.
Clear
(
)
;
return
IPC_OK
(
)
;
}
bool
VRManagerChild
:
:
GetVRDisplays
(
nsTArray
<
RefPtr
<
VRDisplayClient
>
>
&
aDisplays
)
{
if
(
!
mDisplaysInitialized
)
{
nsTArray
<
VRDisplayInfo
>
displays
;
Unused
<
<
SendGetDisplays
(
&
displays
)
;
UpdateDisplayInfo
(
displays
)
;
}
aDisplays
=
mDisplays
;
return
true
;
}
bool
VRManagerChild
:
:
RefreshVRDisplaysWithCallback
(
uint64_t
aWindowId
)
{
bool
success
=
SendRefreshDisplays
(
)
;
if
(
success
)
{
mNavigatorCallbacks
.
AppendElement
(
aWindowId
)
;
}
return
success
;
}
int
VRManagerChild
:
:
GetInputFrameID
(
)
{
return
mInputFrameID
;
}
mozilla
:
:
ipc
:
:
IPCResult
VRManagerChild
:
:
RecvParentAsyncMessages
(
InfallibleTArray
<
AsyncParentMessageData
>
&
&
aMessages
)
{
for
(
InfallibleTArray
<
AsyncParentMessageData
>
:
:
index_type
i
=
0
;
i
<
aMessages
.
Length
(
)
;
+
+
i
)
{
const
AsyncParentMessageData
&
message
=
aMessages
[
i
]
;
switch
(
message
.
type
(
)
)
{
case
AsyncParentMessageData
:
:
TOpNotifyNotUsed
:
{
const
OpNotifyNotUsed
&
op
=
message
.
get_OpNotifyNotUsed
(
)
;
NotifyNotUsed
(
op
.
TextureId
(
)
op
.
fwdTransactionId
(
)
)
;
break
;
}
default
:
NS_ERROR
(
"
unknown
AsyncParentMessageData
type
"
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
}
return
IPC_OK
(
)
;
}
PTextureChild
*
VRManagerChild
:
:
CreateTexture
(
const
SurfaceDescriptor
&
aSharedData
LayersBackend
aLayersBackend
TextureFlags
aFlags
uint64_t
aSerial
)
{
return
SendPTextureConstructor
(
aSharedData
aLayersBackend
aFlags
aSerial
)
;
}
void
VRManagerChild
:
:
CancelWaitForRecycle
(
uint64_t
aTextureId
)
{
RefPtr
<
TextureClient
>
client
=
mTexturesWaitingRecycled
.
Get
(
aTextureId
)
;
if
(
!
client
)
{
return
;
}
mTexturesWaitingRecycled
.
Remove
(
aTextureId
)
;
}
void
VRManagerChild
:
:
NotifyNotUsed
(
uint64_t
aTextureId
uint64_t
aFwdTransactionId
)
{
RefPtr
<
TextureClient
>
client
=
mTexturesWaitingRecycled
.
Get
(
aTextureId
)
;
if
(
!
client
)
{
return
;
}
mTexturesWaitingRecycled
.
Remove
(
aTextureId
)
;
}
bool
VRManagerChild
:
:
AllocShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
return
PVRManagerChild
:
:
AllocShmem
(
aSize
aType
aShmem
)
;
}
bool
VRManagerChild
:
:
AllocUnsafeShmem
(
size_t
aSize
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aType
ipc
:
:
Shmem
*
aShmem
)
{
return
PVRManagerChild
:
:
AllocUnsafeShmem
(
aSize
aType
aShmem
)
;
}
bool
VRManagerChild
:
:
DeallocShmem
(
ipc
:
:
Shmem
&
aShmem
)
{
return
PVRManagerChild
:
:
DeallocShmem
(
aShmem
)
;
}
PVRLayerChild
*
VRManagerChild
:
:
CreateVRLayer
(
uint32_t
aDisplayID
const
Rect
&
aLeftEyeRect
const
Rect
&
aRightEyeRect
)
{
return
SendPVRLayerConstructor
(
aDisplayID
aLeftEyeRect
.
x
aLeftEyeRect
.
y
aLeftEyeRect
.
width
aLeftEyeRect
.
height
aRightEyeRect
.
x
aRightEyeRect
.
y
aRightEyeRect
.
width
aRightEyeRect
.
height
)
;
}
struct
VRManagerChild
:
:
FrameRequest
{
FrameRequest
(
mozilla
:
:
dom
:
:
FrameRequestCallback
&
aCallback
int32_t
aHandle
)
:
mCallback
(
&
aCallback
)
mHandle
(
aHandle
)
{
}
operator
const
RefPtr
<
mozilla
:
:
dom
:
:
FrameRequestCallback
>
&
(
)
const
{
return
mCallback
;
}
bool
operator
=
=
(
int32_t
aHandle
)
const
{
return
mHandle
=
=
aHandle
;
}
bool
operator
<
(
int32_t
aHandle
)
const
{
return
mHandle
<
aHandle
;
}
RefPtr
<
mozilla
:
:
dom
:
:
FrameRequestCallback
>
mCallback
;
int32_t
mHandle
;
}
;
nsresult
VRManagerChild
:
:
ScheduleFrameRequestCallback
(
mozilla
:
:
dom
:
:
FrameRequestCallback
&
aCallback
int32_t
*
aHandle
)
{
if
(
mFrameRequestCallbackCounter
=
=
INT32_MAX
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
int32_t
newHandle
=
+
+
mFrameRequestCallbackCounter
;
DebugOnly
<
FrameRequest
*
>
request
=
mFrameRequestCallbacks
.
AppendElement
(
FrameRequest
(
aCallback
newHandle
)
)
;
NS_ASSERTION
(
request
"
This
is
supposed
to
be
infallible
!
"
)
;
*
aHandle
=
newHandle
;
return
NS_OK
;
}
void
VRManagerChild
:
:
CancelFrameRequestCallback
(
int32_t
aHandle
)
{
mFrameRequestCallbacks
.
RemoveElementSorted
(
aHandle
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
VRManagerChild
:
:
RecvNotifyVSync
(
)
{
for
(
auto
&
display
:
mDisplays
)
{
display
-
>
NotifyVsync
(
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
VRManagerChild
:
:
RecvNotifyVRVSync
(
const
uint32_t
&
aDisplayID
)
{
for
(
auto
&
display
:
mDisplays
)
{
if
(
display
-
>
GetDisplayInfo
(
)
.
GetDisplayID
(
)
=
=
aDisplayID
)
{
display
-
>
NotifyVRVsync
(
)
;
}
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
VRManagerChild
:
:
RecvGamepadUpdate
(
const
GamepadChangeEvent
&
aGamepadEvent
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
|
|
IsSameProcess
(
)
)
;
RefPtr
<
GamepadManager
>
gamepadManager
(
GamepadManager
:
:
GetService
(
)
)
;
if
(
gamepadManager
)
{
gamepadManager
-
>
Update
(
aGamepadEvent
)
;
}
return
IPC_OK
(
)
;
}
void
VRManagerChild
:
:
RunFrameRequestCallbacks
(
)
{
TimeStamp
nowTime
=
TimeStamp
:
:
Now
(
)
;
mozilla
:
:
TimeDuration
duration
=
nowTime
-
mStartTimeStamp
;
DOMHighResTimeStamp
timeStamp
=
duration
.
ToMilliseconds
(
)
;
nsTArray
<
FrameRequest
>
callbacks
;
callbacks
.
AppendElements
(
mFrameRequestCallbacks
)
;
mFrameRequestCallbacks
.
Clear
(
)
;
for
(
auto
&
callback
:
callbacks
)
{
callback
.
mCallback
-
>
Call
(
timeStamp
)
;
}
}
void
VRManagerChild
:
:
FireDOMVRDisplayMountedEvent
(
uint32_t
aDisplayID
)
{
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
<
uint32_t
>
(
this
&
VRManagerChild
:
:
FireDOMVRDisplayMountedEventInternal
aDisplayID
)
)
;
}
void
VRManagerChild
:
:
FireDOMVRDisplayUnmountedEvent
(
uint32_t
aDisplayID
)
{
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
<
uint32_t
>
(
this
&
VRManagerChild
:
:
FireDOMVRDisplayUnmountedEventInternal
aDisplayID
)
)
;
}
void
VRManagerChild
:
:
FireDOMVRDisplayConnectEvent
(
uint32_t
aDisplayID
)
{
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
<
uint32_t
>
(
this
&
VRManagerChild
:
:
FireDOMVRDisplayConnectEventInternal
aDisplayID
)
)
;
}
void
VRManagerChild
:
:
FireDOMVRDisplayDisconnectEvent
(
uint32_t
aDisplayID
)
{
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
<
uint32_t
>
(
this
&
VRManagerChild
:
:
FireDOMVRDisplayDisconnectEventInternal
aDisplayID
)
)
;
}
void
VRManagerChild
:
:
FireDOMVRDisplayPresentChangeEvent
(
uint32_t
aDisplayID
)
{
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
<
uint32_t
>
(
this
&
VRManagerChild
:
:
FireDOMVRDisplayPresentChangeEventInternal
aDisplayID
)
)
;
}
void
VRManagerChild
:
:
FireDOMVRDisplayMountedEventInternal
(
uint32_t
aDisplayID
)
{
nsTArray
<
RefPtr
<
dom
:
:
VREventObserver
>
>
listeners
;
listeners
=
mListeners
;
for
(
auto
&
listener
:
listeners
)
{
listener
-
>
NotifyVRDisplayMounted
(
aDisplayID
)
;
}
}
void
VRManagerChild
:
:
FireDOMVRDisplayUnmountedEventInternal
(
uint32_t
aDisplayID
)
{
nsTArray
<
RefPtr
<
dom
:
:
VREventObserver
>
>
listeners
;
listeners
=
mListeners
;
for
(
auto
&
listener
:
listeners
)
{
listener
-
>
NotifyVRDisplayUnmounted
(
aDisplayID
)
;
}
}
void
VRManagerChild
:
:
FireDOMVRDisplayConnectEventInternal
(
uint32_t
aDisplayID
)
{
nsTArray
<
RefPtr
<
dom
:
:
VREventObserver
>
>
listeners
;
listeners
=
mListeners
;
for
(
auto
&
listener
:
listeners
)
{
listener
-
>
NotifyVRDisplayConnect
(
aDisplayID
)
;
}
}
void
VRManagerChild
:
:
FireDOMVRDisplayDisconnectEventInternal
(
uint32_t
aDisplayID
)
{
nsTArray
<
RefPtr
<
dom
:
:
VREventObserver
>
>
listeners
;
listeners
=
mListeners
;
for
(
auto
&
listener
:
listeners
)
{
listener
-
>
NotifyVRDisplayDisconnect
(
aDisplayID
)
;
}
}
void
VRManagerChild
:
:
FireDOMVRDisplayPresentChangeEventInternal
(
uint32_t
aDisplayID
)
{
nsTArray
<
RefPtr
<
dom
:
:
VREventObserver
>
>
listeners
;
listeners
=
mListeners
;
for
(
auto
&
listener
:
listeners
)
{
listener
-
>
NotifyVRDisplayPresentChange
(
aDisplayID
)
;
}
}
void
VRManagerChild
:
:
AddListener
(
dom
:
:
VREventObserver
*
aObserver
)
{
MOZ_ASSERT
(
aObserver
)
;
if
(
mListeners
.
IndexOf
(
aObserver
)
!
=
kNoIndex
)
{
return
;
}
mListeners
.
AppendElement
(
aObserver
)
;
if
(
mListeners
.
Length
(
)
=
=
1
)
{
Unused
<
<
SendSetHaveEventListener
(
true
)
;
}
}
void
VRManagerChild
:
:
RemoveListener
(
dom
:
:
VREventObserver
*
aObserver
)
{
MOZ_ASSERT
(
aObserver
)
;
mListeners
.
RemoveElement
(
aObserver
)
;
if
(
mListeners
.
IsEmpty
(
)
)
{
Unused
<
<
SendSetHaveEventListener
(
false
)
;
}
}
void
VRManagerChild
:
:
HandleFatalError
(
const
char
*
aName
const
char
*
aMsg
)
const
{
dom
:
:
ContentChild
:
:
FatalErrorIfNotUsingGPUProcess
(
aName
aMsg
OtherPid
(
)
)
;
}
}
}
