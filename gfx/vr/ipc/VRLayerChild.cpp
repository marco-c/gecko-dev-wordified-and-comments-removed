#
include
"
VRLayerChild
.
h
"
#
include
"
mozilla
/
dom
/
HTMLCanvasElement
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
layers
/
SyncObject
.
h
"
#
include
"
mozilla
/
StaticPrefs_webgl
.
h
"
#
include
"
ClientWebGLContext
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
GLScreenBuffer
.
h
"
#
include
"
SharedSurface
.
h
"
#
include
"
SharedSurfaceGL
.
h
"
namespace
mozilla
:
:
gfx
{
VRLayerChild
:
:
VRLayerChild
(
)
{
MOZ_COUNT_CTOR
(
VRLayerChild
)
;
}
VRLayerChild
:
:
~
VRLayerChild
(
)
{
ClearSurfaces
(
)
;
MOZ_COUNT_DTOR
(
VRLayerChild
)
;
}
void
VRLayerChild
:
:
Initialize
(
dom
:
:
HTMLCanvasElement
*
aCanvasElement
const
gfx
:
:
Rect
&
aLeftEyeRect
const
gfx
:
:
Rect
&
aRightEyeRect
)
{
MOZ_ASSERT
(
aCanvasElement
)
;
mLeftEyeRect
=
aLeftEyeRect
;
mRightEyeRect
=
aRightEyeRect
;
mCanvasElement
=
aCanvasElement
;
}
void
VRLayerChild
:
:
SetXRFramebuffer
(
WebGLFramebufferJS
*
fb
)
{
mFramebuffer
=
fb
;
}
static
constexpr
bool
kIsAndroid
=
#
if
defined
(
MOZ_WIDGET_ANDROID
)
true
;
#
else
false
;
#
endif
void
VRLayerChild
:
:
SubmitFrame
(
const
VRDisplayInfo
&
aDisplayInfo
)
{
uint64_t
frameId
=
aDisplayInfo
.
GetFrameId
(
)
;
if
(
!
mCanvasElement
|
|
frameId
=
=
mLastSubmittedFrameId
)
{
return
;
}
const
auto
&
webgl
=
mCanvasElement
-
>
GetWebGLContext
(
)
;
if
(
!
webgl
)
return
;
mLastFrameTextureDesc
=
mThisFrameTextureDesc
;
bool
getNewFrame
=
true
;
if
(
kIsAndroid
)
{
getNewFrame
=
(
!
mThisFrameTextureDesc
|
|
aDisplayInfo
.
mDisplayState
.
lastSubmittedFrameId
=
=
mLastSubmittedFrameId
)
;
}
if
(
getNewFrame
)
{
const
RefPtr
<
layers
:
:
ImageBridgeChild
>
imageBridge
=
layers
:
:
ImageBridgeChild
:
:
GetSingleton
(
)
;
auto
texType
=
layers
:
:
TextureType
:
:
Unknown
;
if
(
imageBridge
)
{
texType
=
layers
:
:
PreferredCanvasTextureType
(
imageBridge
)
;
}
if
(
kIsAndroid
&
&
StaticPrefs
:
:
webgl_enable_surface_texture
(
)
)
{
texType
=
layers
:
:
TextureType
:
:
AndroidNativeWindow
;
}
webgl
-
>
Present
(
mFramebuffer
texType
true
)
;
mThisFrameTextureDesc
=
webgl
-
>
GetFrontBuffer
(
mFramebuffer
true
)
;
}
mLastSubmittedFrameId
=
frameId
;
if
(
!
mThisFrameTextureDesc
)
{
gfxCriticalError
(
)
<
<
"
ToSurfaceDescriptor
failed
in
"
"
VRLayerChild
:
:
SubmitFrame
"
;
return
;
}
SendSubmitFrame
(
*
mThisFrameTextureDesc
frameId
mLeftEyeRect
mRightEyeRect
)
;
}
bool
VRLayerChild
:
:
IsIPCOpen
(
)
{
return
mIPCOpen
;
}
void
VRLayerChild
:
:
ClearSurfaces
(
)
{
mThisFrameTextureDesc
=
Nothing
(
)
;
mLastFrameTextureDesc
=
Nothing
(
)
;
const
auto
&
webgl
=
mCanvasElement
-
>
GetWebGLContext
(
)
;
if
(
!
mFramebuffer
&
&
webgl
)
{
webgl
-
>
ClearVRSwapChain
(
)
;
}
}
void
VRLayerChild
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
mIPCOpen
=
false
;
}
PVRLayerChild
*
VRLayerChild
:
:
CreateIPDLActor
(
)
{
VRLayerChild
*
c
=
new
VRLayerChild
(
)
;
c
-
>
AddIPDLReference
(
)
;
return
c
;
}
bool
VRLayerChild
:
:
DestroyIPDLActor
(
PVRLayerChild
*
actor
)
{
static_cast
<
VRLayerChild
*
>
(
actor
)
-
>
ReleaseIPDLReference
(
)
;
return
true
;
}
void
VRLayerChild
:
:
AddIPDLReference
(
)
{
MOZ_ASSERT
(
mIPCOpen
=
=
false
)
;
mIPCOpen
=
true
;
AddRef
(
)
;
}
void
VRLayerChild
:
:
ReleaseIPDLReference
(
)
{
MOZ_ASSERT
(
mIPCOpen
=
=
false
)
;
Release
(
)
;
}
}
