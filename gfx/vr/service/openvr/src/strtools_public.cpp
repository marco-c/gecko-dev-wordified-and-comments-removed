#
include
"
strtools_public
.
h
"
#
include
<
string
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
sstream
>
#
include
<
iostream
>
#
include
<
functional
>
#
include
<
locale
>
#
if
defined
(
_WIN32
)
#
include
<
windows
.
h
>
#
endif
bool
StringHasPrefix
(
const
std
:
:
string
&
sString
const
std
:
:
string
&
sPrefix
)
{
return
0
=
=
strnicmp
(
sString
.
c_str
(
)
sPrefix
.
c_str
(
)
sPrefix
.
length
(
)
)
;
}
bool
StringHasPrefixCaseSensitive
(
const
std
:
:
string
&
sString
const
std
:
:
string
&
sPrefix
)
{
return
0
=
=
strncmp
(
sString
.
c_str
(
)
sPrefix
.
c_str
(
)
sPrefix
.
length
(
)
)
;
}
bool
StringHasSuffix
(
const
std
:
:
string
&
sString
const
std
:
:
string
&
sSuffix
)
{
size_t
cStrLen
=
sString
.
length
(
)
;
size_t
cSuffixLen
=
sSuffix
.
length
(
)
;
if
(
cSuffixLen
>
cStrLen
)
return
false
;
std
:
:
string
sStringSuffix
=
sString
.
substr
(
cStrLen
-
cSuffixLen
cSuffixLen
)
;
return
0
=
=
stricmp
(
sStringSuffix
.
c_str
(
)
sSuffix
.
c_str
(
)
)
;
}
bool
StringHasSuffixCaseSensitive
(
const
std
:
:
string
&
sString
const
std
:
:
string
&
sSuffix
)
{
size_t
cStrLen
=
sString
.
length
(
)
;
size_t
cSuffixLen
=
sSuffix
.
length
(
)
;
if
(
cSuffixLen
>
cStrLen
)
return
false
;
std
:
:
string
sStringSuffix
=
sString
.
substr
(
cStrLen
-
cSuffixLen
cSuffixLen
)
;
return
0
=
=
strncmp
(
sStringSuffix
.
c_str
(
)
sSuffix
.
c_str
(
)
cSuffixLen
)
;
}
#
if
defined
(
_WIN32
)
std
:
:
string
UTF16to8
(
const
wchar_t
*
in
)
{
int
retLength
=
:
:
WideCharToMultiByte
(
CP_UTF8
0
in
-
1
nullptr
0
nullptr
nullptr
)
;
if
(
retLength
=
=
0
)
{
return
std
:
:
string
(
)
;
}
char
*
retString
=
new
char
[
retLength
]
;
:
:
WideCharToMultiByte
(
CP_UTF8
0
in
-
1
retString
retLength
nullptr
nullptr
)
;
std
:
:
string
retStringValue
(
retString
)
;
delete
[
]
retString
;
return
retStringValue
;
}
std
:
:
string
UTF16to8
(
const
std
:
:
wstring
&
in
)
{
return
UTF16to8
(
in
.
c_str
(
)
)
;
}
std
:
:
wstring
UTF8to16
(
const
char
*
in
)
{
int
retLength
=
:
:
MultiByteToWideChar
(
CP_UTF8
0
in
-
1
nullptr
0
)
;
if
(
retLength
=
=
0
)
{
return
std
:
:
wstring
(
)
;
}
wchar_t
*
retString
=
new
wchar_t
[
retLength
]
;
:
:
MultiByteToWideChar
(
CP_UTF8
0
in
-
1
retString
retLength
)
;
std
:
:
wstring
retStringValue
(
retString
)
;
delete
[
]
retString
;
return
retStringValue
;
}
std
:
:
wstring
UTF8to16
(
const
std
:
:
string
&
in
)
{
return
UTF8to16
(
in
.
c_str
(
)
)
;
}
#
endif
#
if
defined
(
_WIN32
)
std
:
:
string
DefaultACPtoUTF8
(
const
char
*
pszStr
)
{
if
(
GetACP
(
)
=
=
CP_UTF8
)
{
return
pszStr
;
}
else
{
std
:
:
vector
<
wchar_t
>
vecBuf
(
strlen
(
pszStr
)
+
1
)
;
MultiByteToWideChar
(
CP_ACP
MB_PRECOMPOSED
pszStr
-
1
vecBuf
.
data
(
)
(
int
)
vecBuf
.
size
(
)
)
;
return
UTF16to8
(
vecBuf
.
data
(
)
)
;
}
}
#
endif
void
strcpy_safe
(
char
*
pchBuffer
size_t
unBufferSizeBytes
const
char
*
pchSource
)
{
strncpy
(
pchBuffer
pchSource
unBufferSizeBytes
-
1
)
;
pchBuffer
[
unBufferSizeBytes
-
1
]
=
'
\
0
'
;
}
std
:
:
string
StringToUpper
(
const
std
:
:
string
&
sString
)
{
std
:
:
string
sOut
;
sOut
.
reserve
(
sString
.
size
(
)
+
1
)
;
for
(
std
:
:
string
:
:
const_iterator
i
=
sString
.
begin
(
)
;
i
!
=
sString
.
end
(
)
;
i
+
+
)
{
sOut
.
push_back
(
(
char
)
toupper
(
*
i
)
)
;
}
return
sOut
;
}
std
:
:
string
StringToLower
(
const
std
:
:
string
&
sString
)
{
std
:
:
string
sOut
;
sOut
.
reserve
(
sString
.
size
(
)
+
1
)
;
for
(
std
:
:
string
:
:
const_iterator
i
=
sString
.
begin
(
)
;
i
!
=
sString
.
end
(
)
;
i
+
+
)
{
sOut
.
push_back
(
(
char
)
tolower
(
*
i
)
)
;
}
return
sOut
;
}
uint32_t
ReturnStdString
(
const
std
:
:
string
&
sValue
char
*
pchBuffer
uint32_t
unBufferLen
)
{
uint32_t
unLen
=
(
uint32_t
)
sValue
.
length
(
)
+
1
;
if
(
!
pchBuffer
|
|
!
unBufferLen
)
return
unLen
;
if
(
unBufferLen
<
unLen
)
{
pchBuffer
[
0
]
=
'
\
0
'
;
}
else
{
memcpy
(
pchBuffer
sValue
.
c_str
(
)
unLen
)
;
}
return
unLen
;
}
uint64_t
StringToUint64
(
const
std
:
:
string
&
sValue
)
{
return
strtoull
(
sValue
.
c_str
(
)
NULL
0
)
;
}
char
cIntToHexDigit
(
int
nValue
)
{
return
"
0123456789ABCDEF
"
[
nValue
&
15
]
;
}
int
iHexCharToInt
(
char
cValue
)
{
int32_t
iValue
=
cValue
;
if
(
(
uint32_t
)
(
iValue
-
'
0
'
)
<
10
)
return
iValue
-
'
0
'
;
iValue
|
=
0x20
;
if
(
(
uint32_t
)
(
iValue
-
'
a
'
)
<
6
)
return
iValue
-
'
a
'
+
10
;
return
-
1
;
}
static
bool
CharNeedsEscape_Component
(
const
char
c
)
{
return
(
!
(
c
>
=
'
a
'
&
&
c
<
=
'
z
'
)
&
&
!
(
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
)
&
&
!
(
c
>
=
'
0
'
&
&
c
<
=
'
9
'
)
&
&
c
!
=
'
-
'
&
&
c
!
=
'
_
'
&
&
c
!
=
'
.
'
)
;
}
static
bool
CharNeedsEscape_FullPath
(
const
char
c
)
{
return
(
!
(
c
>
=
'
a
'
&
&
c
<
=
'
z
'
)
&
&
!
(
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
)
&
&
!
(
c
>
=
'
0
'
&
&
c
<
=
'
9
'
)
&
&
c
!
=
'
-
'
&
&
c
!
=
'
_
'
&
&
c
!
=
'
.
'
&
&
c
!
=
'
/
'
&
&
c
!
=
'
:
'
)
;
}
void
V_URLEncodeInternal
(
char
*
pchDest
int
nDestLen
const
char
*
pchSource
int
nSourceLen
bool
bUsePlusForSpace
std
:
:
function
<
bool
(
const
char
)
>
fnNeedsEscape
)
{
int
iDestPos
=
0
;
for
(
int
i
=
0
;
i
<
nSourceLen
;
+
+
i
)
{
if
(
(
iDestPos
+
3
)
>
nDestLen
)
{
pchDest
[
0
]
=
'
\
0
'
;
return
;
}
if
(
fnNeedsEscape
(
pchSource
[
i
]
)
)
{
if
(
bUsePlusForSpace
&
&
pchSource
[
i
]
=
=
'
'
)
{
pchDest
[
iDestPos
+
+
]
=
'
+
'
;
}
else
{
pchDest
[
iDestPos
+
+
]
=
'
%
'
;
uint8_t
iValue
=
pchSource
[
i
]
;
if
(
iValue
=
=
0
)
{
pchDest
[
iDestPos
+
+
]
=
'
0
'
;
pchDest
[
iDestPos
+
+
]
=
'
0
'
;
}
else
{
char
cHexDigit1
=
cIntToHexDigit
(
iValue
%
16
)
;
iValue
/
=
16
;
char
cHexDigit2
=
cIntToHexDigit
(
iValue
)
;
pchDest
[
iDestPos
+
+
]
=
cHexDigit2
;
pchDest
[
iDestPos
+
+
]
=
cHexDigit1
;
}
}
}
else
{
pchDest
[
iDestPos
+
+
]
=
pchSource
[
i
]
;
}
}
if
(
(
iDestPos
+
1
)
>
nDestLen
)
{
pchDest
[
0
]
=
'
\
0
'
;
return
;
}
pchDest
[
iDestPos
+
+
]
=
0
;
}
size_t
V_URLDecodeInternal
(
char
*
pchDecodeDest
int
nDecodeDestLen
const
char
*
pchEncodedSource
int
nEncodedSourceLen
bool
bUsePlusForSpace
)
{
if
(
nDecodeDestLen
<
nEncodedSourceLen
)
{
return
0
;
}
int
iDestPos
=
0
;
for
(
int
i
=
0
;
i
<
nEncodedSourceLen
;
+
+
i
)
{
if
(
bUsePlusForSpace
&
&
pchEncodedSource
[
i
]
=
=
'
+
'
)
{
pchDecodeDest
[
iDestPos
+
+
]
=
'
'
;
}
else
if
(
pchEncodedSource
[
i
]
=
=
'
%
'
)
{
if
(
i
<
nEncodedSourceLen
-
2
)
{
char
cHexDigit1
=
pchEncodedSource
[
i
+
1
]
;
char
cHexDigit2
=
pchEncodedSource
[
i
+
2
]
;
bool
bValid
=
false
;
int
iValue
=
iHexCharToInt
(
cHexDigit1
)
;
if
(
iValue
!
=
-
1
)
{
iValue
*
=
16
;
int
iValue2
=
iHexCharToInt
(
cHexDigit2
)
;
if
(
iValue2
!
=
-
1
)
{
iValue
+
=
iValue2
;
pchDecodeDest
[
iDestPos
+
+
]
=
(
char
)
iValue
;
bValid
=
true
;
}
}
if
(
!
bValid
)
{
pchDecodeDest
[
iDestPos
+
+
]
=
'
%
'
;
pchDecodeDest
[
iDestPos
+
+
]
=
cHexDigit1
;
pchDecodeDest
[
iDestPos
+
+
]
=
cHexDigit2
;
}
}
i
+
=
2
;
}
else
{
pchDecodeDest
[
iDestPos
+
+
]
=
pchEncodedSource
[
i
]
;
}
}
if
(
iDestPos
<
nDecodeDestLen
)
{
pchDecodeDest
[
iDestPos
]
=
0
;
}
return
(
size_t
)
iDestPos
;
}
void
V_URLEncode
(
char
*
pchDest
int
nDestLen
const
char
*
pchSource
int
nSourceLen
)
{
return
V_URLEncodeInternal
(
pchDest
nDestLen
pchSource
nSourceLen
true
CharNeedsEscape_Component
)
;
}
void
V_URLEncodeNoPlusForSpace
(
char
*
pchDest
int
nDestLen
const
char
*
pchSource
int
nSourceLen
)
{
return
V_URLEncodeInternal
(
pchDest
nDestLen
pchSource
nSourceLen
false
CharNeedsEscape_Component
)
;
}
void
V_URLEncodeFullPath
(
char
*
pchDest
int
nDestLen
const
char
*
pchSource
int
nSourceLen
)
{
return
V_URLEncodeInternal
(
pchDest
nDestLen
pchSource
nSourceLen
false
CharNeedsEscape_FullPath
)
;
}
size_t
V_URLDecode
(
char
*
pchDecodeDest
int
nDecodeDestLen
const
char
*
pchEncodedSource
int
nEncodedSourceLen
)
{
return
V_URLDecodeInternal
(
pchDecodeDest
nDecodeDestLen
pchEncodedSource
nEncodedSourceLen
true
)
;
}
size_t
V_URLDecodeNoPlusForSpace
(
char
*
pchDecodeDest
int
nDecodeDestLen
const
char
*
pchEncodedSource
int
nEncodedSourceLen
)
{
return
V_URLDecodeInternal
(
pchDecodeDest
nDecodeDestLen
pchEncodedSource
nEncodedSourceLen
false
)
;
}
void
V_StripExtension
(
std
:
:
string
&
in
)
{
std
:
:
string
:
:
size_type
test
=
in
.
rfind
(
'
.
'
)
;
if
(
test
!
=
std
:
:
string
:
:
npos
)
{
if
(
in
.
rfind
(
'
\
\
'
)
<
test
&
&
in
.
rfind
(
'
/
'
)
<
test
)
{
in
.
resize
(
test
)
;
}
}
}
std
:
:
vector
<
std
:
:
string
>
TokenizeString
(
const
std
:
:
string
&
sString
char
cToken
)
{
std
:
:
vector
<
std
:
:
string
>
vecStrings
;
std
:
:
istringstream
stream
(
sString
)
;
std
:
:
string
s
;
while
(
std
:
:
getline
(
stream
s
cToken
)
)
{
vecStrings
.
push_back
(
s
)
;
}
return
vecStrings
;
}
