#
include
"
strtools_public
.
h
"
#
include
<
string
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
sstream
>
#
include
<
iostream
>
bool
StringHasPrefix
(
const
std
:
:
string
&
sString
const
std
:
:
string
&
sPrefix
)
{
return
0
=
=
strnicmp
(
sString
.
c_str
(
)
sPrefix
.
c_str
(
)
sPrefix
.
length
(
)
)
;
}
bool
StringHasPrefixCaseSensitive
(
const
std
:
:
string
&
sString
const
std
:
:
string
&
sPrefix
)
{
return
0
=
=
strncmp
(
sString
.
c_str
(
)
sPrefix
.
c_str
(
)
sPrefix
.
length
(
)
)
;
}
bool
StringHasSuffix
(
const
std
:
:
string
&
sString
const
std
:
:
string
&
sSuffix
)
{
size_t
cStrLen
=
sString
.
length
(
)
;
size_t
cSuffixLen
=
sSuffix
.
length
(
)
;
if
(
cSuffixLen
>
cStrLen
)
return
false
;
std
:
:
string
sStringSuffix
=
sString
.
substr
(
cStrLen
-
cSuffixLen
cSuffixLen
)
;
return
0
=
=
stricmp
(
sStringSuffix
.
c_str
(
)
sSuffix
.
c_str
(
)
)
;
}
bool
StringHasSuffixCaseSensitive
(
const
std
:
:
string
&
sString
const
std
:
:
string
&
sSuffix
)
{
size_t
cStrLen
=
sString
.
length
(
)
;
size_t
cSuffixLen
=
sSuffix
.
length
(
)
;
if
(
cSuffixLen
>
cStrLen
)
return
false
;
std
:
:
string
sStringSuffix
=
sString
.
substr
(
cStrLen
-
cSuffixLen
cSuffixLen
)
;
return
0
=
=
strncmp
(
sStringSuffix
.
c_str
(
)
sSuffix
.
c_str
(
)
cSuffixLen
)
;
}
std
:
:
string
UTF16to8
(
const
wchar_t
*
in
)
{
std
:
:
string
out
;
unsigned
int
codepoint
=
0
;
for
(
;
in
&
&
*
in
!
=
0
;
+
+
in
)
{
if
(
*
in
>
=
0xd800
&
&
*
in
<
=
0xdbff
)
codepoint
=
(
(
*
in
-
0xd800
)
<
<
10
)
+
0x10000
;
else
{
if
(
*
in
>
=
0xdc00
&
&
*
in
<
=
0xdfff
)
codepoint
|
=
*
in
-
0xdc00
;
else
codepoint
=
*
in
;
if
(
codepoint
<
=
0x7f
)
out
.
append
(
1
static_cast
<
char
>
(
codepoint
)
)
;
else
if
(
codepoint
<
=
0x7ff
)
{
out
.
append
(
1
static_cast
<
char
>
(
0xc0
|
(
(
codepoint
>
>
6
)
&
0x1f
)
)
)
;
out
.
append
(
1
static_cast
<
char
>
(
0x80
|
(
codepoint
&
0x3f
)
)
)
;
}
else
if
(
codepoint
<
=
0xffff
)
{
out
.
append
(
1
static_cast
<
char
>
(
0xe0
|
(
(
codepoint
>
>
12
)
&
0x0f
)
)
)
;
out
.
append
(
1
static_cast
<
char
>
(
0x80
|
(
(
codepoint
>
>
6
)
&
0x3f
)
)
)
;
out
.
append
(
1
static_cast
<
char
>
(
0x80
|
(
codepoint
&
0x3f
)
)
)
;
}
else
{
out
.
append
(
1
static_cast
<
char
>
(
0xf0
|
(
(
codepoint
>
>
18
)
&
0x07
)
)
)
;
out
.
append
(
1
static_cast
<
char
>
(
0x80
|
(
(
codepoint
>
>
12
)
&
0x3f
)
)
)
;
out
.
append
(
1
static_cast
<
char
>
(
0x80
|
(
(
codepoint
>
>
6
)
&
0x3f
)
)
)
;
out
.
append
(
1
static_cast
<
char
>
(
0x80
|
(
codepoint
&
0x3f
)
)
)
;
}
codepoint
=
0
;
}
}
return
out
;
}
std
:
:
wstring
UTF8to16
(
const
char
*
in
)
{
std
:
:
wstring
out
;
unsigned
int
codepoint
=
0
;
int
following
=
0
;
for
(
;
in
&
&
*
in
!
=
0
;
+
+
in
)
{
unsigned
char
ch
=
*
in
;
if
(
ch
<
=
0x7f
)
{
codepoint
=
ch
;
following
=
0
;
}
else
if
(
ch
<
=
0xbf
)
{
if
(
following
>
0
)
{
codepoint
=
(
codepoint
<
<
6
)
|
(
ch
&
0x3f
)
;
-
-
following
;
}
}
else
if
(
ch
<
=
0xdf
)
{
codepoint
=
ch
&
0x1f
;
following
=
1
;
}
else
if
(
ch
<
=
0xef
)
{
codepoint
=
ch
&
0x0f
;
following
=
2
;
}
else
{
codepoint
=
ch
&
0x07
;
following
=
3
;
}
if
(
following
=
=
0
)
{
if
(
codepoint
>
0xffff
)
{
out
.
append
(
1
static_cast
<
wchar_t
>
(
0xd800
+
(
codepoint
>
>
10
)
)
)
;
out
.
append
(
1
static_cast
<
wchar_t
>
(
0xdc00
+
(
codepoint
&
0x03ff
)
)
)
;
}
else
out
.
append
(
1
static_cast
<
wchar_t
>
(
codepoint
)
)
;
codepoint
=
0
;
}
}
return
out
;
}
void
strcpy_safe
(
char
*
pchBuffer
size_t
unBufferSizeBytes
const
char
*
pchSource
)
{
strncpy
(
pchBuffer
pchSource
unBufferSizeBytes
-
1
)
;
pchBuffer
[
unBufferSizeBytes
-
1
]
=
'
\
0
'
;
}
std
:
:
string
StringToUpper
(
const
std
:
:
string
&
sString
)
{
std
:
:
string
sOut
;
sOut
.
reserve
(
sString
.
size
(
)
+
1
)
;
for
(
std
:
:
string
:
:
const_iterator
i
=
sString
.
begin
(
)
;
i
!
=
sString
.
end
(
)
;
i
+
+
)
{
sOut
.
push_back
(
(
char
)
toupper
(
*
i
)
)
;
}
return
sOut
;
}
std
:
:
string
StringToLower
(
const
std
:
:
string
&
sString
)
{
std
:
:
string
sOut
;
sOut
.
reserve
(
sString
.
size
(
)
+
1
)
;
for
(
std
:
:
string
:
:
const_iterator
i
=
sString
.
begin
(
)
;
i
!
=
sString
.
end
(
)
;
i
+
+
)
{
sOut
.
push_back
(
(
char
)
tolower
(
*
i
)
)
;
}
return
sOut
;
}
uint32_t
ReturnStdString
(
const
std
:
:
string
&
sValue
char
*
pchBuffer
uint32_t
unBufferLen
)
{
uint32_t
unLen
=
(
uint32_t
)
sValue
.
length
(
)
+
1
;
if
(
!
pchBuffer
|
|
!
unBufferLen
)
return
unLen
;
if
(
unBufferLen
<
unLen
)
{
pchBuffer
[
0
]
=
'
\
0
'
;
}
else
{
memcpy
(
pchBuffer
sValue
.
c_str
(
)
unLen
)
;
}
return
unLen
;
}
uint64_t
StringToUint64
(
const
std
:
:
string
&
sValue
)
{
return
strtoull
(
sValue
.
c_str
(
)
NULL
0
)
;
}
char
cIntToHexDigit
(
int
nValue
)
{
return
"
0123456789ABCDEF
"
[
nValue
&
15
]
;
}
int
iHexCharToInt
(
char
cValue
)
{
int32_t
iValue
=
cValue
;
if
(
(
uint32_t
)
(
iValue
-
'
0
'
)
<
10
)
return
iValue
-
'
0
'
;
iValue
|
=
0x20
;
if
(
(
uint32_t
)
(
iValue
-
'
a
'
)
<
6
)
return
iValue
-
'
a
'
+
10
;
return
-
1
;
}
void
V_URLEncodeInternal
(
char
*
pchDest
int
nDestLen
const
char
*
pchSource
int
nSourceLen
bool
bUsePlusForSpace
)
{
int
iDestPos
=
0
;
for
(
int
i
=
0
;
i
<
nSourceLen
;
+
+
i
)
{
if
(
(
iDestPos
+
3
)
>
nDestLen
)
{
pchDest
[
0
]
=
'
\
0
'
;
return
;
}
if
(
!
(
pchSource
[
i
]
>
=
'
a
'
&
&
pchSource
[
i
]
<
=
'
z
'
)
&
&
!
(
pchSource
[
i
]
>
=
'
A
'
&
&
pchSource
[
i
]
<
=
'
Z
'
)
&
&
!
(
pchSource
[
i
]
>
=
'
0
'
&
&
pchSource
[
i
]
<
=
'
9
'
)
&
&
pchSource
[
i
]
!
=
'
-
'
&
&
pchSource
[
i
]
!
=
'
_
'
&
&
pchSource
[
i
]
!
=
'
.
'
)
{
if
(
bUsePlusForSpace
&
&
pchSource
[
i
]
=
=
'
'
)
{
pchDest
[
iDestPos
+
+
]
=
'
+
'
;
}
else
{
pchDest
[
iDestPos
+
+
]
=
'
%
'
;
uint8_t
iValue
=
pchSource
[
i
]
;
if
(
iValue
=
=
0
)
{
pchDest
[
iDestPos
+
+
]
=
'
0
'
;
pchDest
[
iDestPos
+
+
]
=
'
0
'
;
}
else
{
char
cHexDigit1
=
cIntToHexDigit
(
iValue
%
16
)
;
iValue
/
=
16
;
char
cHexDigit2
=
cIntToHexDigit
(
iValue
)
;
pchDest
[
iDestPos
+
+
]
=
cHexDigit2
;
pchDest
[
iDestPos
+
+
]
=
cHexDigit1
;
}
}
}
else
{
pchDest
[
iDestPos
+
+
]
=
pchSource
[
i
]
;
}
}
if
(
(
iDestPos
+
1
)
>
nDestLen
)
{
pchDest
[
0
]
=
'
\
0
'
;
return
;
}
pchDest
[
iDestPos
+
+
]
=
0
;
}
size_t
V_URLDecodeInternal
(
char
*
pchDecodeDest
int
nDecodeDestLen
const
char
*
pchEncodedSource
int
nEncodedSourceLen
bool
bUsePlusForSpace
)
{
if
(
nDecodeDestLen
<
nEncodedSourceLen
)
{
return
0
;
}
int
iDestPos
=
0
;
for
(
int
i
=
0
;
i
<
nEncodedSourceLen
;
+
+
i
)
{
if
(
bUsePlusForSpace
&
&
pchEncodedSource
[
i
]
=
=
'
+
'
)
{
pchDecodeDest
[
iDestPos
+
+
]
=
'
'
;
}
else
if
(
pchEncodedSource
[
i
]
=
=
'
%
'
)
{
if
(
i
<
nEncodedSourceLen
-
2
)
{
char
cHexDigit1
=
pchEncodedSource
[
i
+
1
]
;
char
cHexDigit2
=
pchEncodedSource
[
i
+
2
]
;
bool
bValid
=
false
;
int
iValue
=
iHexCharToInt
(
cHexDigit1
)
;
if
(
iValue
!
=
-
1
)
{
iValue
*
=
16
;
int
iValue2
=
iHexCharToInt
(
cHexDigit2
)
;
if
(
iValue2
!
=
-
1
)
{
iValue
+
=
iValue2
;
pchDecodeDest
[
iDestPos
+
+
]
=
(
char
)
iValue
;
bValid
=
true
;
}
}
if
(
!
bValid
)
{
pchDecodeDest
[
iDestPos
+
+
]
=
'
%
'
;
pchDecodeDest
[
iDestPos
+
+
]
=
cHexDigit1
;
pchDecodeDest
[
iDestPos
+
+
]
=
cHexDigit2
;
}
}
i
+
=
2
;
}
else
{
pchDecodeDest
[
iDestPos
+
+
]
=
pchEncodedSource
[
i
]
;
}
}
if
(
iDestPos
<
nDecodeDestLen
)
{
pchDecodeDest
[
iDestPos
]
=
0
;
}
return
(
size_t
)
iDestPos
;
}
void
V_URLEncode
(
char
*
pchDest
int
nDestLen
const
char
*
pchSource
int
nSourceLen
)
{
return
V_URLEncodeInternal
(
pchDest
nDestLen
pchSource
nSourceLen
true
)
;
}
size_t
V_URLDecode
(
char
*
pchDecodeDest
int
nDecodeDestLen
const
char
*
pchEncodedSource
int
nEncodedSourceLen
)
{
return
V_URLDecodeInternal
(
pchDecodeDest
nDecodeDestLen
pchEncodedSource
nEncodedSourceLen
true
)
;
}
void
V_StripExtension
(
std
:
:
string
&
in
)
{
std
:
:
string
:
:
size_type
test
=
in
.
rfind
(
'
.
'
)
;
if
(
test
!
=
std
:
:
string
:
:
npos
)
{
if
(
in
.
rfind
(
'
\
\
'
)
<
test
&
&
in
.
rfind
(
'
/
'
)
<
test
)
{
in
.
resize
(
test
)
;
}
}
}
std
:
:
vector
<
std
:
:
string
>
TokenizeString
(
const
std
:
:
string
&
sString
char
cToken
)
{
std
:
:
vector
<
std
:
:
string
>
vecStrings
;
std
:
:
istringstream
stream
(
sString
)
;
std
:
:
string
s
;
while
(
std
:
:
getline
(
stream
s
cToken
)
)
{
vecStrings
.
push_back
(
s
)
;
}
return
vecStrings
;
}
