#
pragma
once
#
ifndef
_OPENVR_API
#
define
_OPENVR_API
#
include
<
stdint
.
h
>
#
ifndef
_INCLUDE_VRTYPES_H
#
define
_INCLUDE_VRTYPES_H
struct
VkDevice_T
;
struct
VkPhysicalDevice_T
;
struct
VkInstance_T
;
struct
VkQueue_T
;
struct
ID3D12Resource
;
struct
ID3D12CommandQueue
;
namespace
vr
{
#
pragma
pack
(
push
8
)
typedef
void
*
glSharedTextureHandle_t
;
typedef
int32_t
glInt_t
;
typedef
uint32_t
glUInt_t
;
struct
HmdMatrix34_t
{
float
m
[
3
]
[
4
]
;
}
;
struct
HmdMatrix44_t
{
float
m
[
4
]
[
4
]
;
}
;
struct
HmdVector3_t
{
float
v
[
3
]
;
}
;
struct
HmdVector4_t
{
float
v
[
4
]
;
}
;
struct
HmdVector3d_t
{
double
v
[
3
]
;
}
;
struct
HmdVector2_t
{
float
v
[
2
]
;
}
;
struct
HmdQuaternion_t
{
double
w
x
y
z
;
}
;
struct
HmdColor_t
{
float
r
g
b
a
;
}
;
struct
HmdQuad_t
{
HmdVector3_t
vCorners
[
4
]
;
}
;
struct
HmdRect2_t
{
HmdVector2_t
vTopLeft
;
HmdVector2_t
vBottomRight
;
}
;
struct
DistortionCoordinates_t
{
float
rfRed
[
2
]
;
float
rfGreen
[
2
]
;
float
rfBlue
[
2
]
;
}
;
enum
EVREye
{
Eye_Left
=
0
Eye_Right
=
1
}
;
enum
ETextureType
{
TextureType_DirectX
=
0
TextureType_OpenGL
=
1
TextureType_Vulkan
=
2
TextureType_IOSurface
=
3
TextureType_DirectX12
=
4
TextureType_DXGISharedHandle
=
5
}
;
enum
EColorSpace
{
ColorSpace_Auto
=
0
ColorSpace_Gamma
=
1
ColorSpace_Linear
=
2
}
;
struct
Texture_t
{
void
*
handle
;
ETextureType
eType
;
EColorSpace
eColorSpace
;
}
;
typedef
uint64_t
SharedTextureHandle_t
;
#
define
INVALID_SHARED_TEXTURE_HANDLE
(
(
vr
:
:
SharedTextureHandle_t
)
0
)
enum
ETrackingResult
{
TrackingResult_Uninitialized
=
1
TrackingResult_Calibrating_InProgress
=
100
TrackingResult_Calibrating_OutOfRange
=
101
TrackingResult_Running_OK
=
200
TrackingResult_Running_OutOfRange
=
201
}
;
typedef
uint32_t
DriverId_t
;
static
const
uint32_t
k_nDriverNone
=
0xFFFFFFFF
;
static
const
uint32_t
k_unMaxDriverDebugResponseSize
=
32768
;
typedef
uint32_t
TrackedDeviceIndex_t
;
static
const
uint32_t
k_unTrackedDeviceIndex_Hmd
=
0
;
static
const
uint32_t
k_unMaxTrackedDeviceCount
=
64
;
static
const
uint32_t
k_unTrackedDeviceIndexOther
=
0xFFFFFFFE
;
static
const
uint32_t
k_unTrackedDeviceIndexInvalid
=
0xFFFFFFFF
;
enum
ETrackedDeviceClass
{
TrackedDeviceClass_Invalid
=
0
TrackedDeviceClass_HMD
=
1
TrackedDeviceClass_Controller
=
2
TrackedDeviceClass_GenericTracker
=
3
TrackedDeviceClass_TrackingReference
=
4
TrackedDeviceClass_DisplayRedirect
=
5
}
;
enum
ETrackedControllerRole
{
TrackedControllerRole_Invalid
=
0
TrackedControllerRole_LeftHand
=
1
TrackedControllerRole_RightHand
=
2
TrackedControllerRole_OptOut
=
3
TrackedControllerRole_Max
=
4
}
;
struct
TrackedDevicePose_t
{
HmdMatrix34_t
mDeviceToAbsoluteTracking
;
HmdVector3_t
vVelocity
;
HmdVector3_t
vAngularVelocity
;
ETrackingResult
eTrackingResult
;
bool
bPoseIsValid
;
bool
bDeviceIsConnected
;
}
;
enum
ETrackingUniverseOrigin
{
TrackingUniverseSeated
=
0
TrackingUniverseStanding
=
1
TrackingUniverseRawAndUncalibrated
=
2
}
;
typedef
uint64_t
WebConsoleHandle_t
;
#
define
INVALID_WEB_CONSOLE_HANDLE
(
(
vr
:
:
WebConsoleHandle_t
)
0
)
typedef
uint64_t
PropertyContainerHandle_t
;
typedef
uint32_t
PropertyTypeTag_t
;
static
const
PropertyContainerHandle_t
k_ulInvalidPropertyContainer
=
0
;
static
const
PropertyTypeTag_t
k_unInvalidPropertyTag
=
0
;
typedef
PropertyContainerHandle_t
DriverHandle_t
;
static
const
PropertyContainerHandle_t
k_ulInvalidDriverHandle
=
0
;
static
const
PropertyTypeTag_t
k_unFloatPropertyTag
=
1
;
static
const
PropertyTypeTag_t
k_unInt32PropertyTag
=
2
;
static
const
PropertyTypeTag_t
k_unUint64PropertyTag
=
3
;
static
const
PropertyTypeTag_t
k_unBoolPropertyTag
=
4
;
static
const
PropertyTypeTag_t
k_unStringPropertyTag
=
5
;
static
const
PropertyTypeTag_t
k_unHmdMatrix34PropertyTag
=
20
;
static
const
PropertyTypeTag_t
k_unHmdMatrix44PropertyTag
=
21
;
static
const
PropertyTypeTag_t
k_unHmdVector3PropertyTag
=
22
;
static
const
PropertyTypeTag_t
k_unHmdVector4PropertyTag
=
23
;
static
const
PropertyTypeTag_t
k_unHiddenAreaPropertyTag
=
30
;
static
const
PropertyTypeTag_t
k_unPathHandleInfoTag
=
31
;
static
const
PropertyTypeTag_t
k_unActionPropertyTag
=
32
;
static
const
PropertyTypeTag_t
k_unInputValuePropertyTag
=
33
;
static
const
PropertyTypeTag_t
k_unWildcardPropertyTag
=
34
;
static
const
PropertyTypeTag_t
k_unHapticVibrationPropertyTag
=
35
;
static
const
PropertyTypeTag_t
k_unOpenVRInternalReserved_Start
=
1000
;
static
const
PropertyTypeTag_t
k_unOpenVRInternalReserved_End
=
10000
;
enum
ETrackedDeviceProperty
{
Prop_Invalid
=
0
Prop_TrackingSystemName_String
=
1000
Prop_ModelNumber_String
=
1001
Prop_SerialNumber_String
=
1002
Prop_RenderModelName_String
=
1003
Prop_WillDriftInYaw_Bool
=
1004
Prop_ManufacturerName_String
=
1005
Prop_TrackingFirmwareVersion_String
=
1006
Prop_HardwareRevision_String
=
1007
Prop_AllWirelessDongleDescriptions_String
=
1008
Prop_ConnectedWirelessDongle_String
=
1009
Prop_DeviceIsWireless_Bool
=
1010
Prop_DeviceIsCharging_Bool
=
1011
Prop_DeviceBatteryPercentage_Float
=
1012
Prop_StatusDisplayTransform_Matrix34
=
1013
Prop_Firmware_UpdateAvailable_Bool
=
1014
Prop_Firmware_ManualUpdate_Bool
=
1015
Prop_Firmware_ManualUpdateURL_String
=
1016
Prop_HardwareRevision_Uint64
=
1017
Prop_FirmwareVersion_Uint64
=
1018
Prop_FPGAVersion_Uint64
=
1019
Prop_VRCVersion_Uint64
=
1020
Prop_RadioVersion_Uint64
=
1021
Prop_DongleVersion_Uint64
=
1022
Prop_BlockServerShutdown_Bool
=
1023
Prop_CanUnifyCoordinateSystemWithHmd_Bool
=
1024
Prop_ContainsProximitySensor_Bool
=
1025
Prop_DeviceProvidesBatteryStatus_Bool
=
1026
Prop_DeviceCanPowerOff_Bool
=
1027
Prop_Firmware_ProgrammingTarget_String
=
1028
Prop_DeviceClass_Int32
=
1029
Prop_HasCamera_Bool
=
1030
Prop_DriverVersion_String
=
1031
Prop_Firmware_ForceUpdateRequired_Bool
=
1032
Prop_ViveSystemButtonFixRequired_Bool
=
1033
Prop_ParentDriver_Uint64
=
1034
Prop_ResourceRoot_String
=
1035
Prop_RegisteredDeviceType_String
=
1036
Prop_InputProfilePath_String
=
1037
Prop_NeverTracked_Bool
=
1038
Prop_NumCameras_Int32
=
1039
Prop_CameraFrameLayout_Int32
=
1040
Prop_ReportsTimeSinceVSync_Bool
=
2000
Prop_SecondsFromVsyncToPhotons_Float
=
2001
Prop_DisplayFrequency_Float
=
2002
Prop_UserIpdMeters_Float
=
2003
Prop_CurrentUniverseId_Uint64
=
2004
Prop_PreviousUniverseId_Uint64
=
2005
Prop_DisplayFirmwareVersion_Uint64
=
2006
Prop_IsOnDesktop_Bool
=
2007
Prop_DisplayMCType_Int32
=
2008
Prop_DisplayMCOffset_Float
=
2009
Prop_DisplayMCScale_Float
=
2010
Prop_EdidVendorID_Int32
=
2011
Prop_DisplayMCImageLeft_String
=
2012
Prop_DisplayMCImageRight_String
=
2013
Prop_DisplayGCBlackClamp_Float
=
2014
Prop_EdidProductID_Int32
=
2015
Prop_CameraToHeadTransform_Matrix34
=
2016
Prop_DisplayGCType_Int32
=
2017
Prop_DisplayGCOffset_Float
=
2018
Prop_DisplayGCScale_Float
=
2019
Prop_DisplayGCPrescale_Float
=
2020
Prop_DisplayGCImage_String
=
2021
Prop_LensCenterLeftU_Float
=
2022
Prop_LensCenterLeftV_Float
=
2023
Prop_LensCenterRightU_Float
=
2024
Prop_LensCenterRightV_Float
=
2025
Prop_UserHeadToEyeDepthMeters_Float
=
2026
Prop_CameraFirmwareVersion_Uint64
=
2027
Prop_CameraFirmwareDescription_String
=
2028
Prop_DisplayFPGAVersion_Uint64
=
2029
Prop_DisplayBootloaderVersion_Uint64
=
2030
Prop_DisplayHardwareVersion_Uint64
=
2031
Prop_AudioFirmwareVersion_Uint64
=
2032
Prop_CameraCompatibilityMode_Int32
=
2033
Prop_ScreenshotHorizontalFieldOfViewDegrees_Float
=
2034
Prop_ScreenshotVerticalFieldOfViewDegrees_Float
=
2035
Prop_DisplaySuppressed_Bool
=
2036
Prop_DisplayAllowNightMode_Bool
=
2037
Prop_DisplayMCImageWidth_Int32
=
2038
Prop_DisplayMCImageHeight_Int32
=
2039
Prop_DisplayMCImageNumChannels_Int32
=
2040
Prop_DisplayMCImageData_Binary
=
2041
Prop_SecondsFromPhotonsToVblank_Float
=
2042
Prop_DriverDirectModeSendsVsyncEvents_Bool
=
2043
Prop_DisplayDebugMode_Bool
=
2044
Prop_GraphicsAdapterLuid_Uint64
=
2045
Prop_DriverProvidedChaperonePath_String
=
2048
Prop_ExpectedTrackingReferenceCount_Int32
=
2049
Prop_ExpectedControllerCount_Int32
=
2050
Prop_NamedIconPathControllerLeftDeviceOff_String
=
2051
Prop_NamedIconPathControllerRightDeviceOff_String
=
2052
Prop_NamedIconPathTrackingReferenceDeviceOff_String
=
2053
Prop_DoNotApplyPrediction_Bool
=
2054
Prop_CameraToHeadTransforms_Matrix34_Array
=
2055
Prop_DistortionMeshResolution_Int32
=
2056
Prop_DriverIsDrawingControllers_Bool
=
2057
Prop_DriverRequestsApplicationPause_Bool
=
2058
Prop_DriverRequestsReducedRendering_Bool
=
2059
Prop_MinimumIpdStepMeters_Float
=
2060
Prop_AudioBridgeFirmwareVersion_Uint64
=
2061
Prop_ImageBridgeFirmwareVersion_Uint64
=
2062
Prop_AttachedDeviceId_String
=
3000
Prop_SupportedButtons_Uint64
=
3001
Prop_Axis0Type_Int32
=
3002
Prop_Axis1Type_Int32
=
3003
Prop_Axis2Type_Int32
=
3004
Prop_Axis3Type_Int32
=
3005
Prop_Axis4Type_Int32
=
3006
Prop_ControllerRoleHint_Int32
=
3007
Prop_FieldOfViewLeftDegrees_Float
=
4000
Prop_FieldOfViewRightDegrees_Float
=
4001
Prop_FieldOfViewTopDegrees_Float
=
4002
Prop_FieldOfViewBottomDegrees_Float
=
4003
Prop_TrackingRangeMinimumMeters_Float
=
4004
Prop_TrackingRangeMaximumMeters_Float
=
4005
Prop_ModeLabel_String
=
4006
Prop_IconPathName_String
=
5000
Prop_NamedIconPathDeviceOff_String
=
5001
Prop_NamedIconPathDeviceSearching_String
=
5002
Prop_NamedIconPathDeviceSearchingAlert_String
=
5003
Prop_NamedIconPathDeviceReady_String
=
5004
Prop_NamedIconPathDeviceReadyAlert_String
=
5005
Prop_NamedIconPathDeviceNotReady_String
=
5006
Prop_NamedIconPathDeviceStandby_String
=
5007
Prop_NamedIconPathDeviceAlertLow_String
=
5008
Prop_DisplayHiddenArea_Binary_Start
=
5100
Prop_DisplayHiddenArea_Binary_End
=
5150
Prop_ParentContainer
=
5151
Prop_UserConfigPath_String
=
6000
Prop_InstallPath_String
=
6001
Prop_HasDisplayComponent_Bool
=
6002
Prop_HasControllerComponent_Bool
=
6003
Prop_HasCameraComponent_Bool
=
6004
Prop_HasDriverDirectModeComponent_Bool
=
6005
Prop_HasVirtualDisplayComponent_Bool
=
6006
Prop_ControllerType_String
=
7000
Prop_LegacyInputProfile_String
=
7001
Prop_VendorSpecific_Reserved_Start
=
10000
Prop_VendorSpecific_Reserved_End
=
10999
Prop_TrackedDeviceProperty_Max
=
1000000
}
;
static
const
uint32_t
k_unMaxPropertyStringSize
=
32
*
1024
;
enum
ETrackedPropertyError
{
TrackedProp_Success
=
0
TrackedProp_WrongDataType
=
1
TrackedProp_WrongDeviceClass
=
2
TrackedProp_BufferTooSmall
=
3
TrackedProp_UnknownProperty
=
4
TrackedProp_InvalidDevice
=
5
TrackedProp_CouldNotContactServer
=
6
TrackedProp_ValueNotProvidedByDevice
=
7
TrackedProp_StringExceedsMaximumLength
=
8
TrackedProp_NotYetAvailable
=
9
TrackedProp_PermissionDenied
=
10
TrackedProp_InvalidOperation
=
11
TrackedProp_CannotWriteToWildcards
=
12
}
;
struct
VRTextureBounds_t
{
float
uMin
vMin
;
float
uMax
vMax
;
}
;
struct
VRTextureWithPose_t
:
public
Texture_t
{
HmdMatrix34_t
mDeviceToAbsoluteTracking
;
}
;
struct
VRTextureDepthInfo_t
{
void
*
handle
;
HmdMatrix44_t
mProjection
;
HmdVector2_t
vRange
;
}
;
struct
VRTextureWithDepth_t
:
public
Texture_t
{
VRTextureDepthInfo_t
depth
;
}
;
struct
VRTextureWithPoseAndDepth_t
:
public
VRTextureWithPose_t
{
VRTextureDepthInfo_t
depth
;
}
;
enum
EVRSubmitFlags
{
Submit_Default
=
0x00
Submit_LensDistortionAlreadyApplied
=
0x01
Submit_GlRenderBuffer
=
0x02
Submit_Reserved
=
0x04
Submit_TextureWithPose
=
0x08
Submit_TextureWithDepth
=
0x10
}
;
struct
VRVulkanTextureData_t
{
uint64_t
m_nImage
;
VkDevice_T
*
m_pDevice
;
VkPhysicalDevice_T
*
m_pPhysicalDevice
;
VkInstance_T
*
m_pInstance
;
VkQueue_T
*
m_pQueue
;
uint32_t
m_nQueueFamilyIndex
;
uint32_t
m_nWidth
m_nHeight
m_nFormat
m_nSampleCount
;
}
;
struct
D3D12TextureData_t
{
ID3D12Resource
*
m_pResource
;
ID3D12CommandQueue
*
m_pCommandQueue
;
uint32_t
m_nNodeMask
;
}
;
enum
EVRState
{
VRState_Undefined
=
-
1
VRState_Off
=
0
VRState_Searching
=
1
VRState_Searching_Alert
=
2
VRState_Ready
=
3
VRState_Ready_Alert
=
4
VRState_NotReady
=
5
VRState_Standby
=
6
VRState_Ready_Alert_Low
=
7
}
;
enum
EVREventType
{
VREvent_None
=
0
VREvent_TrackedDeviceActivated
=
100
VREvent_TrackedDeviceDeactivated
=
101
VREvent_TrackedDeviceUpdated
=
102
VREvent_TrackedDeviceUserInteractionStarted
=
103
VREvent_TrackedDeviceUserInteractionEnded
=
104
VREvent_IpdChanged
=
105
VREvent_EnterStandbyMode
=
106
VREvent_LeaveStandbyMode
=
107
VREvent_TrackedDeviceRoleChanged
=
108
VREvent_WatchdogWakeUpRequested
=
109
VREvent_LensDistortionChanged
=
110
VREvent_PropertyChanged
=
111
VREvent_WirelessDisconnect
=
112
VREvent_WirelessReconnect
=
113
VREvent_ButtonPress
=
200
VREvent_ButtonUnpress
=
201
VREvent_ButtonTouch
=
202
VREvent_ButtonUntouch
=
203
VREvent_DualAnalog_Press
=
250
VREvent_DualAnalog_Unpress
=
251
VREvent_DualAnalog_Touch
=
252
VREvent_DualAnalog_Untouch
=
253
VREvent_DualAnalog_Move
=
254
VREvent_DualAnalog_ModeSwitch1
=
255
VREvent_DualAnalog_ModeSwitch2
=
256
VREvent_DualAnalog_Cancel
=
257
VREvent_MouseMove
=
300
VREvent_MouseButtonDown
=
301
VREvent_MouseButtonUp
=
302
VREvent_FocusEnter
=
303
VREvent_FocusLeave
=
304
VREvent_Scroll
=
305
VREvent_TouchPadMove
=
306
VREvent_OverlayFocusChanged
=
307
VREvent_InputFocusCaptured
=
400
VREvent_InputFocusReleased
=
401
VREvent_SceneFocusLost
=
402
VREvent_SceneFocusGained
=
403
VREvent_SceneApplicationChanged
=
404
VREvent_SceneFocusChanged
=
405
VREvent_InputFocusChanged
=
406
VREvent_SceneApplicationSecondaryRenderingStarted
=
407
VREvent_SceneApplicationUsingWrongGraphicsAdapter
=
408
VREvent_ActionBindingReloaded
=
409
VREvent_HideRenderModels
=
410
VREvent_ShowRenderModels
=
411
VREvent_ConsoleOpened
=
420
VREvent_ConsoleClosed
=
421
VREvent_OverlayShown
=
500
VREvent_OverlayHidden
=
501
VREvent_DashboardActivated
=
502
VREvent_DashboardDeactivated
=
503
VREvent_DashboardThumbSelected
=
504
VREvent_DashboardRequested
=
505
VREvent_ResetDashboard
=
506
VREvent_RenderToast
=
507
VREvent_ImageLoaded
=
508
VREvent_ShowKeyboard
=
509
VREvent_HideKeyboard
=
510
VREvent_OverlayGamepadFocusGained
=
511
VREvent_OverlayGamepadFocusLost
=
512
VREvent_OverlaySharedTextureChanged
=
513
VREvent_ScreenshotTriggered
=
516
VREvent_ImageFailed
=
517
VREvent_DashboardOverlayCreated
=
518
VREvent_SwitchGamepadFocus
=
519
VREvent_RequestScreenshot
=
520
VREvent_ScreenshotTaken
=
521
VREvent_ScreenshotFailed
=
522
VREvent_SubmitScreenshotToDashboard
=
523
VREvent_ScreenshotProgressToDashboard
=
524
VREvent_PrimaryDashboardDeviceChanged
=
525
VREvent_RoomViewShown
=
526
VREvent_RoomViewHidden
=
527
VREvent_Notification_Shown
=
600
VREvent_Notification_Hidden
=
601
VREvent_Notification_BeginInteraction
=
602
VREvent_Notification_Destroyed
=
603
VREvent_Quit
=
700
VREvent_ProcessQuit
=
701
VREvent_QuitAborted_UserPrompt
=
702
VREvent_QuitAcknowledged
=
703
VREvent_DriverRequestedQuit
=
704
VREvent_ChaperoneDataHasChanged
=
800
VREvent_ChaperoneUniverseHasChanged
=
801
VREvent_ChaperoneTempDataHasChanged
=
802
VREvent_ChaperoneSettingsHaveChanged
=
803
VREvent_SeatedZeroPoseReset
=
804
VREvent_AudioSettingsHaveChanged
=
820
VREvent_BackgroundSettingHasChanged
=
850
VREvent_CameraSettingsHaveChanged
=
851
VREvent_ReprojectionSettingHasChanged
=
852
VREvent_ModelSkinSettingsHaveChanged
=
853
VREvent_EnvironmentSettingsHaveChanged
=
854
VREvent_PowerSettingsHaveChanged
=
855
VREvent_EnableHomeAppSettingsHaveChanged
=
856
VREvent_SteamVRSectionSettingChanged
=
857
VREvent_LighthouseSectionSettingChanged
=
858
VREvent_NullSectionSettingChanged
=
859
VREvent_UserInterfaceSectionSettingChanged
=
860
VREvent_NotificationsSectionSettingChanged
=
861
VREvent_KeyboardSectionSettingChanged
=
862
VREvent_PerfSectionSettingChanged
=
863
VREvent_DashboardSectionSettingChanged
=
864
VREvent_WebInterfaceSectionSettingChanged
=
865
VREvent_StatusUpdate
=
900
VREvent_WebInterface_InstallDriverCompleted
=
950
VREvent_MCImageUpdated
=
1000
VREvent_FirmwareUpdateStarted
=
1100
VREvent_FirmwareUpdateFinished
=
1101
VREvent_KeyboardClosed
=
1200
VREvent_KeyboardCharInput
=
1201
VREvent_KeyboardDone
=
1202
VREvent_ApplicationTransitionStarted
=
1300
VREvent_ApplicationTransitionAborted
=
1301
VREvent_ApplicationTransitionNewAppStarted
=
1302
VREvent_ApplicationListUpdated
=
1303
VREvent_ApplicationMimeTypeLoad
=
1304
VREvent_ApplicationTransitionNewAppLaunchComplete
=
1305
VREvent_ProcessConnected
=
1306
VREvent_ProcessDisconnected
=
1307
VREvent_Compositor_MirrorWindowShown
=
1400
VREvent_Compositor_MirrorWindowHidden
=
1401
VREvent_Compositor_ChaperoneBoundsShown
=
1410
VREvent_Compositor_ChaperoneBoundsHidden
=
1411
VREvent_TrackedCamera_StartVideoStream
=
1500
VREvent_TrackedCamera_StopVideoStream
=
1501
VREvent_TrackedCamera_PauseVideoStream
=
1502
VREvent_TrackedCamera_ResumeVideoStream
=
1503
VREvent_TrackedCamera_EditingSurface
=
1550
VREvent_PerformanceTest_EnableCapture
=
1600
VREvent_PerformanceTest_DisableCapture
=
1601
VREvent_PerformanceTest_FidelityLevel
=
1602
VREvent_MessageOverlay_Closed
=
1650
VREvent_MessageOverlayCloseRequested
=
1651
VREvent_Input_HapticVibration
=
1700
VREvent_VendorSpecific_Reserved_Start
=
10000
VREvent_VendorSpecific_Reserved_End
=
19999
}
;
enum
EDeviceActivityLevel
{
k_EDeviceActivityLevel_Unknown
=
-
1
k_EDeviceActivityLevel_Idle
=
0
k_EDeviceActivityLevel_UserInteraction
=
1
k_EDeviceActivityLevel_UserInteraction_Timeout
=
2
k_EDeviceActivityLevel_Standby
=
3
}
;
enum
EVRButtonId
{
k_EButton_System
=
0
k_EButton_ApplicationMenu
=
1
k_EButton_Grip
=
2
k_EButton_DPad_Left
=
3
k_EButton_DPad_Up
=
4
k_EButton_DPad_Right
=
5
k_EButton_DPad_Down
=
6
k_EButton_A
=
7
k_EButton_ProximitySensor
=
31
k_EButton_Axis0
=
32
k_EButton_Axis1
=
33
k_EButton_Axis2
=
34
k_EButton_Axis3
=
35
k_EButton_Axis4
=
36
k_EButton_SteamVR_Touchpad
=
k_EButton_Axis0
k_EButton_SteamVR_Trigger
=
k_EButton_Axis1
k_EButton_Dashboard_Back
=
k_EButton_Grip
k_EButton_Max
=
64
}
;
inline
uint64_t
ButtonMaskFromId
(
EVRButtonId
id
)
{
return
1ull
<
<
id
;
}
struct
VREvent_Controller_t
{
uint32_t
button
;
}
;
enum
EVRMouseButton
{
VRMouseButton_Left
=
0x0001
VRMouseButton_Right
=
0x0002
VRMouseButton_Middle
=
0x0004
}
;
struct
VREvent_Mouse_t
{
float
x
y
;
uint32_t
button
;
}
;
struct
VREvent_Scroll_t
{
float
xdelta
ydelta
;
uint32_t
repeatCount
;
}
;
struct
VREvent_TouchPadMove_t
{
bool
bFingerDown
;
float
flSecondsFingerDown
;
float
fValueXFirst
;
float
fValueYFirst
;
float
fValueXRaw
;
float
fValueYRaw
;
}
;
struct
VREvent_Notification_t
{
uint64_t
ulUserValue
;
uint32_t
notificationId
;
}
;
struct
VREvent_Process_t
{
uint32_t
pid
;
uint32_t
oldPid
;
bool
bForced
;
}
;
struct
VREvent_Overlay_t
{
uint64_t
overlayHandle
;
uint64_t
devicePath
;
}
;
struct
VREvent_Status_t
{
uint32_t
statusState
;
}
;
struct
VREvent_Keyboard_t
{
char
cNewInput
[
8
]
;
uint64_t
uUserValue
;
}
;
struct
VREvent_Ipd_t
{
float
ipdMeters
;
}
;
struct
VREvent_Chaperone_t
{
uint64_t
m_nPreviousUniverse
;
uint64_t
m_nCurrentUniverse
;
}
;
struct
VREvent_Reserved_t
{
uint64_t
reserved0
;
uint64_t
reserved1
;
uint64_t
reserved2
;
uint64_t
reserved3
;
}
;
struct
VREvent_PerformanceTest_t
{
uint32_t
m_nFidelityLevel
;
}
;
struct
VREvent_SeatedZeroPoseReset_t
{
bool
bResetBySystemMenu
;
}
;
struct
VREvent_Screenshot_t
{
uint32_t
handle
;
uint32_t
type
;
}
;
struct
VREvent_ScreenshotProgress_t
{
float
progress
;
}
;
struct
VREvent_ApplicationLaunch_t
{
uint32_t
pid
;
uint32_t
unArgsHandle
;
}
;
struct
VREvent_EditingCameraSurface_t
{
uint64_t
overlayHandle
;
uint32_t
nVisualMode
;
}
;
struct
VREvent_MessageOverlay_t
{
uint32_t
unVRMessageOverlayResponse
;
}
;
struct
VREvent_Property_t
{
PropertyContainerHandle_t
container
;
ETrackedDeviceProperty
prop
;
}
;
enum
EDualAnalogWhich
{
k_EDualAnalog_Left
=
0
k_EDualAnalog_Right
=
1
}
;
struct
VREvent_DualAnalog_t
{
float
x
y
;
float
transformedX
transformedY
;
EDualAnalogWhich
which
;
}
;
struct
VREvent_HapticVibration_t
{
uint64_t
containerHandle
;
uint64_t
componentHandle
;
float
fDurationSeconds
;
float
fFrequency
;
float
fAmplitude
;
}
;
struct
VREvent_WebConsole_t
{
WebConsoleHandle_t
webConsoleHandle
;
}
;
typedef
union
{
VREvent_Reserved_t
reserved
;
VREvent_Controller_t
controller
;
VREvent_Mouse_t
mouse
;
VREvent_Scroll_t
scroll
;
VREvent_Process_t
process
;
VREvent_Notification_t
notification
;
VREvent_Overlay_t
overlay
;
VREvent_Status_t
status
;
VREvent_Keyboard_t
keyboard
;
VREvent_Ipd_t
ipd
;
VREvent_Chaperone_t
chaperone
;
VREvent_PerformanceTest_t
performanceTest
;
VREvent_TouchPadMove_t
touchPadMove
;
VREvent_SeatedZeroPoseReset_t
seatedZeroPoseReset
;
VREvent_Screenshot_t
screenshot
;
VREvent_ScreenshotProgress_t
screenshotProgress
;
VREvent_ApplicationLaunch_t
applicationLaunch
;
VREvent_EditingCameraSurface_t
cameraSurface
;
VREvent_MessageOverlay_t
messageOverlay
;
VREvent_Property_t
property
;
VREvent_DualAnalog_t
dualAnalog
;
VREvent_HapticVibration_t
hapticVibration
;
VREvent_WebConsole_t
webConsole
;
}
VREvent_Data_t
;
#
if
defined
(
__linux__
)
|
|
defined
(
__APPLE__
)
#
pragma
pack
(
push
4
)
#
endif
struct
VREvent_t
{
uint32_t
eventType
;
TrackedDeviceIndex_t
trackedDeviceIndex
;
float
eventAgeSeconds
;
VREvent_Data_t
data
;
}
;
#
if
defined
(
__linux__
)
|
|
defined
(
__APPLE__
)
#
pragma
pack
(
pop
)
#
endif
enum
EVRInputError
{
VRInputError_None
=
0
VRInputError_NameNotFound
=
1
VRInputError_WrongType
=
2
VRInputError_InvalidHandle
=
3
VRInputError_InvalidParam
=
4
VRInputError_NoSteam
=
5
VRInputError_MaxCapacityReached
=
6
VRInputError_IPCError
=
7
VRInputError_NoActiveActionSet
=
8
VRInputError_InvalidDevice
=
9
}
;
struct
HiddenAreaMesh_t
{
const
HmdVector2_t
*
pVertexData
;
uint32_t
unTriangleCount
;
}
;
enum
EHiddenAreaMeshType
{
k_eHiddenAreaMesh_Standard
=
0
k_eHiddenAreaMesh_Inverse
=
1
k_eHiddenAreaMesh_LineLoop
=
2
k_eHiddenAreaMesh_Max
=
3
}
;
enum
EVRControllerAxisType
{
k_eControllerAxis_None
=
0
k_eControllerAxis_TrackPad
=
1
k_eControllerAxis_Joystick
=
2
k_eControllerAxis_Trigger
=
3
}
;
struct
VRControllerAxis_t
{
float
x
;
float
y
;
}
;
static
const
uint32_t
k_unControllerStateAxisCount
=
5
;
#
if
defined
(
__linux__
)
|
|
defined
(
__APPLE__
)
#
pragma
pack
(
push
4
)
#
endif
struct
VRControllerState001_t
{
uint32_t
unPacketNum
;
uint64_t
ulButtonPressed
;
uint64_t
ulButtonTouched
;
VRControllerAxis_t
rAxis
[
k_unControllerStateAxisCount
]
;
}
;
#
if
defined
(
__linux__
)
|
|
defined
(
__APPLE__
)
#
pragma
pack
(
pop
)
#
endif
typedef
VRControllerState001_t
VRControllerState_t
;
enum
EVRControllerEventOutputType
{
ControllerEventOutput_OSEvents
=
0
ControllerEventOutput_VREvents
=
1
}
;
enum
ECollisionBoundsStyle
{
COLLISION_BOUNDS_STYLE_BEGINNER
=
0
COLLISION_BOUNDS_STYLE_INTERMEDIATE
COLLISION_BOUNDS_STYLE_SQUARES
COLLISION_BOUNDS_STYLE_ADVANCED
COLLISION_BOUNDS_STYLE_NONE
COLLISION_BOUNDS_STYLE_COUNT
}
;
struct
Compositor_OverlaySettings
{
uint32_t
size
;
bool
curved
antialias
;
float
scale
distance
alpha
;
float
uOffset
vOffset
uScale
vScale
;
float
gridDivs
gridWidth
gridScale
;
HmdMatrix44_t
transform
;
}
;
typedef
uint64_t
VROverlayHandle_t
;
static
const
VROverlayHandle_t
k_ulOverlayHandleInvalid
=
0
;
enum
EVROverlayError
{
VROverlayError_None
=
0
VROverlayError_UnknownOverlay
=
10
VROverlayError_InvalidHandle
=
11
VROverlayError_PermissionDenied
=
12
VROverlayError_OverlayLimitExceeded
=
13
VROverlayError_WrongVisibilityType
=
14
VROverlayError_KeyTooLong
=
15
VROverlayError_NameTooLong
=
16
VROverlayError_KeyInUse
=
17
VROverlayError_WrongTransformType
=
18
VROverlayError_InvalidTrackedDevice
=
19
VROverlayError_InvalidParameter
=
20
VROverlayError_ThumbnailCantBeDestroyed
=
21
VROverlayError_ArrayTooSmall
=
22
VROverlayError_RequestFailed
=
23
VROverlayError_InvalidTexture
=
24
VROverlayError_UnableToLoadFile
=
25
VROverlayError_KeyboardAlreadyInUse
=
26
VROverlayError_NoNeighbor
=
27
VROverlayError_TooManyMaskPrimitives
=
29
VROverlayError_BadMaskPrimitive
=
30
VROverlayError_TextureAlreadyLocked
=
31
VROverlayError_TextureLockCapacityReached
=
32
VROverlayError_TextureNotLocked
=
33
}
;
enum
EVRApplicationType
{
VRApplication_Other
=
0
VRApplication_Scene
=
1
VRApplication_Overlay
=
2
VRApplication_Background
=
3
VRApplication_Utility
=
4
VRApplication_VRMonitor
=
5
VRApplication_SteamWatchdog
=
6
VRApplication_Bootstrapper
=
7
VRApplication_Max
}
;
enum
EVRFirmwareError
{
VRFirmwareError_None
=
0
VRFirmwareError_Success
=
1
VRFirmwareError_Fail
=
2
}
;
enum
EVRNotificationError
{
VRNotificationError_OK
=
0
VRNotificationError_InvalidNotificationId
=
100
VRNotificationError_NotificationQueueFull
=
101
VRNotificationError_InvalidOverlayHandle
=
102
VRNotificationError_SystemWithUserValueAlreadyExists
=
103
}
;
enum
EVRInitError
{
VRInitError_None
=
0
VRInitError_Unknown
=
1
VRInitError_Init_InstallationNotFound
=
100
VRInitError_Init_InstallationCorrupt
=
101
VRInitError_Init_VRClientDLLNotFound
=
102
VRInitError_Init_FileNotFound
=
103
VRInitError_Init_FactoryNotFound
=
104
VRInitError_Init_InterfaceNotFound
=
105
VRInitError_Init_InvalidInterface
=
106
VRInitError_Init_UserConfigDirectoryInvalid
=
107
VRInitError_Init_HmdNotFound
=
108
VRInitError_Init_NotInitialized
=
109
VRInitError_Init_PathRegistryNotFound
=
110
VRInitError_Init_NoConfigPath
=
111
VRInitError_Init_NoLogPath
=
112
VRInitError_Init_PathRegistryNotWritable
=
113
VRInitError_Init_AppInfoInitFailed
=
114
VRInitError_Init_Retry
=
115
VRInitError_Init_InitCanceledByUser
=
116
VRInitError_Init_AnotherAppLaunching
=
117
VRInitError_Init_SettingsInitFailed
=
118
VRInitError_Init_ShuttingDown
=
119
VRInitError_Init_TooManyObjects
=
120
VRInitError_Init_NoServerForBackgroundApp
=
121
VRInitError_Init_NotSupportedWithCompositor
=
122
VRInitError_Init_NotAvailableToUtilityApps
=
123
VRInitError_Init_Internal
=
124
VRInitError_Init_HmdDriverIdIsNone
=
125
VRInitError_Init_HmdNotFoundPresenceFailed
=
126
VRInitError_Init_VRMonitorNotFound
=
127
VRInitError_Init_VRMonitorStartupFailed
=
128
VRInitError_Init_LowPowerWatchdogNotSupported
=
129
VRInitError_Init_InvalidApplicationType
=
130
VRInitError_Init_NotAvailableToWatchdogApps
=
131
VRInitError_Init_WatchdogDisabledInSettings
=
132
VRInitError_Init_VRDashboardNotFound
=
133
VRInitError_Init_VRDashboardStartupFailed
=
134
VRInitError_Init_VRHomeNotFound
=
135
VRInitError_Init_VRHomeStartupFailed
=
136
VRInitError_Init_RebootingBusy
=
137
VRInitError_Init_FirmwareUpdateBusy
=
138
VRInitError_Init_FirmwareRecoveryBusy
=
139
VRInitError_Init_USBServiceBusy
=
140
VRInitError_Init_VRWebHelperStartupFailed
=
141
VRInitError_Driver_Failed
=
200
VRInitError_Driver_Unknown
=
201
VRInitError_Driver_HmdUnknown
=
202
VRInitError_Driver_NotLoaded
=
203
VRInitError_Driver_RuntimeOutOfDate
=
204
VRInitError_Driver_HmdInUse
=
205
VRInitError_Driver_NotCalibrated
=
206
VRInitError_Driver_CalibrationInvalid
=
207
VRInitError_Driver_HmdDisplayNotFound
=
208
VRInitError_Driver_TrackedDeviceInterfaceUnknown
=
209
VRInitError_Driver_HmdDriverIdOutOfBounds
=
211
VRInitError_Driver_HmdDisplayMirrored
=
212
VRInitError_IPC_ServerInitFailed
=
300
VRInitError_IPC_ConnectFailed
=
301
VRInitError_IPC_SharedStateInitFailed
=
302
VRInitError_IPC_CompositorInitFailed
=
303
VRInitError_IPC_MutexInitFailed
=
304
VRInitError_IPC_Failed
=
305
VRInitError_IPC_CompositorConnectFailed
=
306
VRInitError_IPC_CompositorInvalidConnectResponse
=
307
VRInitError_IPC_ConnectFailedAfterMultipleAttempts
=
308
VRInitError_Compositor_Failed
=
400
VRInitError_Compositor_D3D11HardwareRequired
=
401
VRInitError_Compositor_FirmwareRequiresUpdate
=
402
VRInitError_Compositor_OverlayInitFailed
=
403
VRInitError_Compositor_ScreenshotsInitFailed
=
404
VRInitError_Compositor_UnableToCreateDevice
=
405
VRInitError_VendorSpecific_UnableToConnectToOculusRuntime
=
1000
VRInitError_VendorSpecific_WindowsNotInDevMode
=
1001
VRInitError_VendorSpecific_HmdFound_CantOpenDevice
=
1101
VRInitError_VendorSpecific_HmdFound_UnableToRequestConfigStart
=
1102
VRInitError_VendorSpecific_HmdFound_NoStoredConfig
=
1103
VRInitError_VendorSpecific_HmdFound_ConfigTooBig
=
1104
VRInitError_VendorSpecific_HmdFound_ConfigTooSmall
=
1105
VRInitError_VendorSpecific_HmdFound_UnableToInitZLib
=
1106
VRInitError_VendorSpecific_HmdFound_CantReadFirmwareVersion
=
1107
VRInitError_VendorSpecific_HmdFound_UnableToSendUserDataStart
=
1108
VRInitError_VendorSpecific_HmdFound_UnableToGetUserDataStart
=
1109
VRInitError_VendorSpecific_HmdFound_UnableToGetUserDataNext
=
1110
VRInitError_VendorSpecific_HmdFound_UserDataAddressRange
=
1111
VRInitError_VendorSpecific_HmdFound_UserDataError
=
1112
VRInitError_VendorSpecific_HmdFound_ConfigFailedSanityCheck
=
1113
VRInitError_Steam_SteamInstallationNotFound
=
2000
}
;
enum
EVRScreenshotType
{
VRScreenshotType_None
=
0
VRScreenshotType_Mono
=
1
VRScreenshotType_Stereo
=
2
VRScreenshotType_Cubemap
=
3
VRScreenshotType_MonoPanorama
=
4
VRScreenshotType_StereoPanorama
=
5
}
;
enum
EVRScreenshotPropertyFilenames
{
VRScreenshotPropertyFilenames_Preview
=
0
VRScreenshotPropertyFilenames_VR
=
1
}
;
enum
EVRTrackedCameraError
{
VRTrackedCameraError_None
=
0
VRTrackedCameraError_OperationFailed
=
100
VRTrackedCameraError_InvalidHandle
=
101
VRTrackedCameraError_InvalidFrameHeaderVersion
=
102
VRTrackedCameraError_OutOfHandles
=
103
VRTrackedCameraError_IPCFailure
=
104
VRTrackedCameraError_NotSupportedForThisDevice
=
105
VRTrackedCameraError_SharedMemoryFailure
=
106
VRTrackedCameraError_FrameBufferingFailure
=
107
VRTrackedCameraError_StreamSetupFailure
=
108
VRTrackedCameraError_InvalidGLTextureId
=
109
VRTrackedCameraError_InvalidSharedTextureHandle
=
110
VRTrackedCameraError_FailedToGetGLTextureId
=
111
VRTrackedCameraError_SharedTextureFailure
=
112
VRTrackedCameraError_NoFrameAvailable
=
113
VRTrackedCameraError_InvalidArgument
=
114
VRTrackedCameraError_InvalidFrameBufferSize
=
115
}
;
enum
EVRTrackedCameraFrameLayout
{
EVRTrackedCameraFrameLayout_Mono
=
0x0001
EVRTrackedCameraFrameLayout_Stereo
=
0x0002
EVRTrackedCameraFrameLayout_VerticalLayout
=
0x0010
EVRTrackedCameraFrameLayout_HorizontalLayout
=
0x0020
}
;
enum
EVRTrackedCameraFrameType
{
VRTrackedCameraFrameType_Distorted
=
0
VRTrackedCameraFrameType_Undistorted
VRTrackedCameraFrameType_MaximumUndistorted
MAX_CAMERA_FRAME_TYPES
}
;
typedef
uint64_t
TrackedCameraHandle_t
;
#
define
INVALID_TRACKED_CAMERA_HANDLE
(
(
vr
:
:
TrackedCameraHandle_t
)
0
)
struct
CameraVideoStreamFrameHeader_t
{
EVRTrackedCameraFrameType
eFrameType
;
uint32_t
nWidth
;
uint32_t
nHeight
;
uint32_t
nBytesPerPixel
;
uint32_t
nFrameSequence
;
TrackedDevicePose_t
standingTrackedDevicePose
;
}
;
typedef
uint32_t
ScreenshotHandle_t
;
static
const
uint32_t
k_unScreenshotHandleInvalid
=
0
;
struct
DriverDirectMode_FrameTiming
{
uint32_t
m_nSize
;
uint32_t
m_nNumFramePresents
;
uint32_t
m_nNumMisPresented
;
uint32_t
m_nNumDroppedFrames
;
uint32_t
m_nReprojectionFlags
;
}
;
enum
EVSync
{
VSync_None
VSync_WaitRender
VSync_NoWaitRender
}
;
#
pragma
pack
(
pop
)
#
define
VR_INTERFACE
#
if
defined
(
_WIN32
)
#
define
VR_CALLTYPE
__cdecl
#
else
#
define
VR_CALLTYPE
#
endif
}
#
endif
#
ifdef
API_GEN
#
define
VR_CLANG_ATTR
(
ATTR
)
__attribute__
(
(
annotate
(
ATTR
)
)
)
#
else
#
define
VR_CLANG_ATTR
(
ATTR
)
#
endif
#
define
VR_METHOD_DESC
(
DESC
)
VR_CLANG_ATTR
(
"
desc
:
"
#
DESC
"
;
"
)
#
define
VR_IGNOREATTR
(
)
VR_CLANG_ATTR
(
"
ignore
"
)
#
define
VR_OUT_STRUCT
(
)
VR_CLANG_ATTR
(
"
out_struct
:
;
"
)
#
define
VR_OUT_STRING
(
)
VR_CLANG_ATTR
(
"
out_string
:
;
"
)
#
define
VR_OUT_ARRAY_CALL
(
COUNTER
FUNCTION
PARAMS
)
VR_CLANG_ATTR
(
"
out_array_call
:
"
#
COUNTER
"
"
#
FUNCTION
"
"
#
PARAMS
"
;
"
)
#
define
VR_OUT_ARRAY_COUNT
(
COUNTER
)
VR_CLANG_ATTR
(
"
out_array_count
:
"
#
COUNTER
"
;
"
)
#
define
VR_ARRAY_COUNT
(
COUNTER
)
VR_CLANG_ATTR
(
"
array_count
:
"
#
COUNTER
"
;
"
)
#
define
VR_ARRAY_COUNT_D
(
COUNTER
DESC
)
VR_CLANG_ATTR
(
"
array_count
:
"
#
COUNTER
"
;
desc
:
"
#
DESC
)
#
define
VR_BUFFER_COUNT
(
COUNTER
)
VR_CLANG_ATTR
(
"
buffer_count
:
"
#
COUNTER
"
;
"
)
#
define
VR_OUT_BUFFER_COUNT
(
COUNTER
)
VR_CLANG_ATTR
(
"
out_buffer_count
:
"
#
COUNTER
"
;
"
)
#
define
VR_OUT_STRING_COUNT
(
COUNTER
)
VR_CLANG_ATTR
(
"
out_string_count
:
"
#
COUNTER
"
;
"
)
namespace
vr
{
class
IVRSystem
{
public
:
virtual
void
GetRecommendedRenderTargetSize
(
uint32_t
*
pnWidth
uint32_t
*
pnHeight
)
=
0
;
virtual
HmdMatrix44_t
GetProjectionMatrix
(
EVREye
eEye
float
fNearZ
float
fFarZ
)
=
0
;
virtual
void
GetProjectionRaw
(
EVREye
eEye
float
*
pfLeft
float
*
pfRight
float
*
pfTop
float
*
pfBottom
)
=
0
;
virtual
bool
ComputeDistortion
(
EVREye
eEye
float
fU
float
fV
DistortionCoordinates_t
*
pDistortionCoordinates
)
=
0
;
virtual
HmdMatrix34_t
GetEyeToHeadTransform
(
EVREye
eEye
)
=
0
;
virtual
bool
GetTimeSinceLastVsync
(
float
*
pfSecondsSinceLastVsync
uint64_t
*
pulFrameCounter
)
=
0
;
virtual
int32_t
GetD3D9AdapterIndex
(
)
=
0
;
virtual
void
GetDXGIOutputInfo
(
int32_t
*
pnAdapterIndex
)
=
0
;
virtual
void
GetOutputDevice
(
uint64_t
*
pnDevice
ETextureType
textureType
VkInstance_T
*
pInstance
=
nullptr
)
=
0
;
virtual
bool
IsDisplayOnDesktop
(
)
=
0
;
virtual
bool
SetDisplayVisibility
(
bool
bIsVisibleOnDesktop
)
=
0
;
virtual
void
GetDeviceToAbsoluteTrackingPose
(
ETrackingUniverseOrigin
eOrigin
float
fPredictedSecondsToPhotonsFromNow
VR_ARRAY_COUNT
(
unTrackedDevicePoseArrayCount
)
TrackedDevicePose_t
*
pTrackedDevicePoseArray
uint32_t
unTrackedDevicePoseArrayCount
)
=
0
;
virtual
void
ResetSeatedZeroPose
(
)
=
0
;
virtual
HmdMatrix34_t
GetSeatedZeroPoseToStandingAbsoluteTrackingPose
(
)
=
0
;
virtual
HmdMatrix34_t
GetRawZeroPoseToStandingAbsoluteTrackingPose
(
)
=
0
;
virtual
uint32_t
GetSortedTrackedDeviceIndicesOfClass
(
ETrackedDeviceClass
eTrackedDeviceClass
VR_ARRAY_COUNT
(
unTrackedDeviceIndexArrayCount
)
vr
:
:
TrackedDeviceIndex_t
*
punTrackedDeviceIndexArray
uint32_t
unTrackedDeviceIndexArrayCount
vr
:
:
TrackedDeviceIndex_t
unRelativeToTrackedDeviceIndex
=
k_unTrackedDeviceIndex_Hmd
)
=
0
;
virtual
EDeviceActivityLevel
GetTrackedDeviceActivityLevel
(
vr
:
:
TrackedDeviceIndex_t
unDeviceId
)
=
0
;
virtual
void
ApplyTransform
(
TrackedDevicePose_t
*
pOutputPose
const
TrackedDevicePose_t
*
pTrackedDevicePose
const
HmdMatrix34_t
*
pTransform
)
=
0
;
virtual
vr
:
:
TrackedDeviceIndex_t
GetTrackedDeviceIndexForControllerRole
(
vr
:
:
ETrackedControllerRole
unDeviceType
)
=
0
;
virtual
vr
:
:
ETrackedControllerRole
GetControllerRoleForTrackedDeviceIndex
(
vr
:
:
TrackedDeviceIndex_t
unDeviceIndex
)
=
0
;
virtual
ETrackedDeviceClass
GetTrackedDeviceClass
(
vr
:
:
TrackedDeviceIndex_t
unDeviceIndex
)
=
0
;
virtual
bool
IsTrackedDeviceConnected
(
vr
:
:
TrackedDeviceIndex_t
unDeviceIndex
)
=
0
;
virtual
bool
GetBoolTrackedDeviceProperty
(
vr
:
:
TrackedDeviceIndex_t
unDeviceIndex
ETrackedDeviceProperty
prop
ETrackedPropertyError
*
pError
=
0L
)
=
0
;
virtual
float
GetFloatTrackedDeviceProperty
(
vr
:
:
TrackedDeviceIndex_t
unDeviceIndex
ETrackedDeviceProperty
prop
ETrackedPropertyError
*
pError
=
0L
)
=
0
;
virtual
int32_t
GetInt32TrackedDeviceProperty
(
vr
:
:
TrackedDeviceIndex_t
unDeviceIndex
ETrackedDeviceProperty
prop
ETrackedPropertyError
*
pError
=
0L
)
=
0
;
virtual
uint64_t
GetUint64TrackedDeviceProperty
(
vr
:
:
TrackedDeviceIndex_t
unDeviceIndex
ETrackedDeviceProperty
prop
ETrackedPropertyError
*
pError
=
0L
)
=
0
;
virtual
HmdMatrix34_t
GetMatrix34TrackedDeviceProperty
(
vr
:
:
TrackedDeviceIndex_t
unDeviceIndex
ETrackedDeviceProperty
prop
ETrackedPropertyError
*
pError
=
0L
)
=
0
;
virtual
uint32_t
GetArrayTrackedDeviceProperty
(
vr
:
:
TrackedDeviceIndex_t
unDeviceIndex
ETrackedDeviceProperty
prop
PropertyTypeTag_t
propType
void
*
pBuffer
uint32_t
unBufferSize
ETrackedPropertyError
*
pError
=
0L
)
=
0
;
virtual
uint32_t
GetStringTrackedDeviceProperty
(
vr
:
:
TrackedDeviceIndex_t
unDeviceIndex
ETrackedDeviceProperty
prop
VR_OUT_STRING
(
)
char
*
pchValue
uint32_t
unBufferSize
ETrackedPropertyError
*
pError
=
0L
)
=
0
;
virtual
const
char
*
GetPropErrorNameFromEnum
(
ETrackedPropertyError
error
)
=
0
;
virtual
bool
PollNextEvent
(
VREvent_t
*
pEvent
uint32_t
uncbVREvent
)
=
0
;
virtual
bool
PollNextEventWithPose
(
ETrackingUniverseOrigin
eOrigin
VREvent_t
*
pEvent
uint32_t
uncbVREvent
vr
:
:
TrackedDevicePose_t
*
pTrackedDevicePose
)
=
0
;
virtual
const
char
*
GetEventTypeNameFromEnum
(
EVREventType
eType
)
=
0
;
virtual
HiddenAreaMesh_t
GetHiddenAreaMesh
(
EVREye
eEye
EHiddenAreaMeshType
type
=
k_eHiddenAreaMesh_Standard
)
=
0
;
virtual
bool
GetControllerState
(
vr
:
:
TrackedDeviceIndex_t
unControllerDeviceIndex
vr
:
:
VRControllerState_t
*
pControllerState
uint32_t
unControllerStateSize
)
=
0
;
virtual
bool
GetControllerStateWithPose
(
ETrackingUniverseOrigin
eOrigin
vr
:
:
TrackedDeviceIndex_t
unControllerDeviceIndex
vr
:
:
VRControllerState_t
*
pControllerState
uint32_t
unControllerStateSize
TrackedDevicePose_t
*
pTrackedDevicePose
)
=
0
;
virtual
void
TriggerHapticPulse
(
vr
:
:
TrackedDeviceIndex_t
unControllerDeviceIndex
uint32_t
unAxisId
unsigned
short
usDurationMicroSec
)
=
0
;
virtual
const
char
*
GetButtonIdNameFromEnum
(
EVRButtonId
eButtonId
)
=
0
;
virtual
const
char
*
GetControllerAxisTypeNameFromEnum
(
EVRControllerAxisType
eAxisType
)
=
0
;
virtual
bool
IsInputAvailable
(
)
=
0
;
virtual
bool
IsSteamVRDrawingControllers
(
)
=
0
;
virtual
bool
ShouldApplicationPause
(
)
=
0
;
virtual
bool
ShouldApplicationReduceRenderingWork
(
)
=
0
;
virtual
uint32_t
DriverDebugRequest
(
vr
:
:
TrackedDeviceIndex_t
unDeviceIndex
const
char
*
pchRequest
VR_OUT_STRING
(
)
char
*
pchResponseBuffer
uint32_t
unResponseBufferSize
)
=
0
;
virtual
vr
:
:
EVRFirmwareError
PerformFirmwareUpdate
(
vr
:
:
TrackedDeviceIndex_t
unDeviceIndex
)
=
0
;
virtual
void
AcknowledgeQuit_Exiting
(
)
=
0
;
virtual
void
AcknowledgeQuit_UserPrompt
(
)
=
0
;
}
;
static
const
char
*
const
IVRSystem_Version
=
"
IVRSystem_019
"
;
}
namespace
vr
{
enum
EVRApplicationError
{
VRApplicationError_None
=
0
VRApplicationError_AppKeyAlreadyExists
=
100
VRApplicationError_NoManifest
=
101
VRApplicationError_NoApplication
=
102
VRApplicationError_InvalidIndex
=
103
VRApplicationError_UnknownApplication
=
104
VRApplicationError_IPCFailed
=
105
VRApplicationError_ApplicationAlreadyRunning
=
106
VRApplicationError_InvalidManifest
=
107
VRApplicationError_InvalidApplication
=
108
VRApplicationError_LaunchFailed
=
109
VRApplicationError_ApplicationAlreadyStarting
=
110
VRApplicationError_LaunchInProgress
=
111
VRApplicationError_OldApplicationQuitting
=
112
VRApplicationError_TransitionAborted
=
113
VRApplicationError_IsTemplate
=
114
VRApplicationError_SteamVRIsExiting
=
115
VRApplicationError_BufferTooSmall
=
200
VRApplicationError_PropertyNotSet
=
201
VRApplicationError_UnknownProperty
=
202
VRApplicationError_InvalidParameter
=
203
}
;
static
const
uint32_t
k_unMaxApplicationKeyLength
=
128
;
enum
EVRApplicationProperty
{
VRApplicationProperty_Name_String
=
0
VRApplicationProperty_LaunchType_String
=
11
VRApplicationProperty_WorkingDirectory_String
=
12
VRApplicationProperty_BinaryPath_String
=
13
VRApplicationProperty_Arguments_String
=
14
VRApplicationProperty_URL_String
=
15
VRApplicationProperty_Description_String
=
50
VRApplicationProperty_NewsURL_String
=
51
VRApplicationProperty_ImagePath_String
=
52
VRApplicationProperty_Source_String
=
53
VRApplicationProperty_ActionManifestURL_String
=
54
VRApplicationProperty_IsDashboardOverlay_Bool
=
60
VRApplicationProperty_IsTemplate_Bool
=
61
VRApplicationProperty_IsInstanced_Bool
=
62
VRApplicationProperty_IsInternal_Bool
=
63
VRApplicationProperty_WantsCompositorPauseInStandby_Bool
=
64
VRApplicationProperty_LastLaunchTime_Uint64
=
70
}
;
enum
EVRApplicationTransitionState
{
VRApplicationTransition_None
=
0
VRApplicationTransition_OldAppQuitSent
=
10
VRApplicationTransition_WaitingForExternalLaunch
=
11
VRApplicationTransition_NewAppLaunched
=
20
}
;
struct
AppOverrideKeys_t
{
const
char
*
pchKey
;
const
char
*
pchValue
;
}
;
static
const
char
*
const
k_pch_MimeType_HomeApp
=
"
vr
/
home
"
;
static
const
char
*
const
k_pch_MimeType_GameTheater
=
"
vr
/
game_theater
"
;
class
IVRApplications
{
public
:
virtual
EVRApplicationError
AddApplicationManifest
(
const
char
*
pchApplicationManifestFullPath
bool
bTemporary
=
false
)
=
0
;
virtual
EVRApplicationError
RemoveApplicationManifest
(
const
char
*
pchApplicationManifestFullPath
)
=
0
;
virtual
bool
IsApplicationInstalled
(
const
char
*
pchAppKey
)
=
0
;
virtual
uint32_t
GetApplicationCount
(
)
=
0
;
virtual
EVRApplicationError
GetApplicationKeyByIndex
(
uint32_t
unApplicationIndex
VR_OUT_STRING
(
)
char
*
pchAppKeyBuffer
uint32_t
unAppKeyBufferLen
)
=
0
;
virtual
EVRApplicationError
GetApplicationKeyByProcessId
(
uint32_t
unProcessId
VR_OUT_STRING
(
)
char
*
pchAppKeyBuffer
uint32_t
unAppKeyBufferLen
)
=
0
;
virtual
EVRApplicationError
LaunchApplication
(
const
char
*
pchAppKey
)
=
0
;
virtual
EVRApplicationError
LaunchTemplateApplication
(
const
char
*
pchTemplateAppKey
const
char
*
pchNewAppKey
VR_ARRAY_COUNT
(
unKeys
)
const
AppOverrideKeys_t
*
pKeys
uint32_t
unKeys
)
=
0
;
virtual
vr
:
:
EVRApplicationError
LaunchApplicationFromMimeType
(
const
char
*
pchMimeType
const
char
*
pchArgs
)
=
0
;
virtual
EVRApplicationError
LaunchDashboardOverlay
(
const
char
*
pchAppKey
)
=
0
;
virtual
bool
CancelApplicationLaunch
(
const
char
*
pchAppKey
)
=
0
;
virtual
EVRApplicationError
IdentifyApplication
(
uint32_t
unProcessId
const
char
*
pchAppKey
)
=
0
;
virtual
uint32_t
GetApplicationProcessId
(
const
char
*
pchAppKey
)
=
0
;
virtual
const
char
*
GetApplicationsErrorNameFromEnum
(
EVRApplicationError
error
)
=
0
;
virtual
uint32_t
GetApplicationPropertyString
(
const
char
*
pchAppKey
EVRApplicationProperty
eProperty
VR_OUT_STRING
(
)
char
*
pchPropertyValueBuffer
uint32_t
unPropertyValueBufferLen
EVRApplicationError
*
peError
=
nullptr
)
=
0
;
virtual
bool
GetApplicationPropertyBool
(
const
char
*
pchAppKey
EVRApplicationProperty
eProperty
EVRApplicationError
*
peError
=
nullptr
)
=
0
;
virtual
uint64_t
GetApplicationPropertyUint64
(
const
char
*
pchAppKey
EVRApplicationProperty
eProperty
EVRApplicationError
*
peError
=
nullptr
)
=
0
;
virtual
EVRApplicationError
SetApplicationAutoLaunch
(
const
char
*
pchAppKey
bool
bAutoLaunch
)
=
0
;
virtual
bool
GetApplicationAutoLaunch
(
const
char
*
pchAppKey
)
=
0
;
virtual
EVRApplicationError
SetDefaultApplicationForMimeType
(
const
char
*
pchAppKey
const
char
*
pchMimeType
)
=
0
;
virtual
bool
GetDefaultApplicationForMimeType
(
const
char
*
pchMimeType
VR_OUT_STRING
(
)
char
*
pchAppKeyBuffer
uint32_t
unAppKeyBufferLen
)
=
0
;
virtual
bool
GetApplicationSupportedMimeTypes
(
const
char
*
pchAppKey
VR_OUT_STRING
(
)
char
*
pchMimeTypesBuffer
uint32_t
unMimeTypesBuffer
)
=
0
;
virtual
uint32_t
GetApplicationsThatSupportMimeType
(
const
char
*
pchMimeType
VR_OUT_STRING
(
)
char
*
pchAppKeysThatSupportBuffer
uint32_t
unAppKeysThatSupportBuffer
)
=
0
;
virtual
uint32_t
GetApplicationLaunchArguments
(
uint32_t
unHandle
VR_OUT_STRING
(
)
char
*
pchArgs
uint32_t
unArgs
)
=
0
;
virtual
EVRApplicationError
GetStartingApplication
(
VR_OUT_STRING
(
)
char
*
pchAppKeyBuffer
uint32_t
unAppKeyBufferLen
)
=
0
;
virtual
EVRApplicationTransitionState
GetTransitionState
(
)
=
0
;
virtual
EVRApplicationError
PerformApplicationPrelaunchCheck
(
const
char
*
pchAppKey
)
=
0
;
virtual
const
char
*
GetApplicationsTransitionStateNameFromEnum
(
EVRApplicationTransitionState
state
)
=
0
;
virtual
bool
IsQuitUserPromptRequested
(
)
=
0
;
virtual
EVRApplicationError
LaunchInternalProcess
(
const
char
*
pchBinaryPath
const
char
*
pchArguments
const
char
*
pchWorkingDirectory
)
=
0
;
virtual
uint32_t
GetCurrentSceneProcessId
(
)
=
0
;
}
;
static
const
char
*
const
IVRApplications_Version
=
"
IVRApplications_006
"
;
}
namespace
vr
{
enum
EVRSettingsError
{
VRSettingsError_None
=
0
VRSettingsError_IPCFailed
=
1
VRSettingsError_WriteFailed
=
2
VRSettingsError_ReadFailed
=
3
VRSettingsError_JsonParseFailed
=
4
VRSettingsError_UnsetSettingHasNoDefault
=
5
}
;
static
const
uint32_t
k_unMaxSettingsKeyLength
=
128
;
class
IVRSettings
{
public
:
virtual
const
char
*
GetSettingsErrorNameFromEnum
(
EVRSettingsError
eError
)
=
0
;
virtual
bool
Sync
(
bool
bForce
=
false
EVRSettingsError
*
peError
=
nullptr
)
=
0
;
virtual
void
SetBool
(
const
char
*
pchSection
const
char
*
pchSettingsKey
bool
bValue
EVRSettingsError
*
peError
=
nullptr
)
=
0
;
virtual
void
SetInt32
(
const
char
*
pchSection
const
char
*
pchSettingsKey
int32_t
nValue
EVRSettingsError
*
peError
=
nullptr
)
=
0
;
virtual
void
SetFloat
(
const
char
*
pchSection
const
char
*
pchSettingsKey
float
flValue
EVRSettingsError
*
peError
=
nullptr
)
=
0
;
virtual
void
SetString
(
const
char
*
pchSection
const
char
*
pchSettingsKey
const
char
*
pchValue
EVRSettingsError
*
peError
=
nullptr
)
=
0
;
virtual
bool
GetBool
(
const
char
*
pchSection
const
char
*
pchSettingsKey
EVRSettingsError
*
peError
=
nullptr
)
=
0
;
virtual
int32_t
GetInt32
(
const
char
*
pchSection
const
char
*
pchSettingsKey
EVRSettingsError
*
peError
=
nullptr
)
=
0
;
virtual
float
GetFloat
(
const
char
*
pchSection
const
char
*
pchSettingsKey
EVRSettingsError
*
peError
=
nullptr
)
=
0
;
virtual
void
GetString
(
const
char
*
pchSection
const
char
*
pchSettingsKey
VR_OUT_STRING
(
)
char
*
pchValue
uint32_t
unValueLen
EVRSettingsError
*
peError
=
nullptr
)
=
0
;
virtual
void
RemoveSection
(
const
char
*
pchSection
EVRSettingsError
*
peError
=
nullptr
)
=
0
;
virtual
void
RemoveKeyInSection
(
const
char
*
pchSection
const
char
*
pchSettingsKey
EVRSettingsError
*
peError
=
nullptr
)
=
0
;
}
;
static
const
char
*
const
IVRSettings_Version
=
"
IVRSettings_002
"
;
static
const
char
*
const
k_pch_SteamVR_Section
=
"
steamvr
"
;
static
const
char
*
const
k_pch_SteamVR_RequireHmd_String
=
"
requireHmd
"
;
static
const
char
*
const
k_pch_SteamVR_ForcedDriverKey_String
=
"
forcedDriver
"
;
static
const
char
*
const
k_pch_SteamVR_ForcedHmdKey_String
=
"
forcedHmd
"
;
static
const
char
*
const
k_pch_SteamVR_DisplayDebug_Bool
=
"
displayDebug
"
;
static
const
char
*
const
k_pch_SteamVR_DebugProcessPipe_String
=
"
debugProcessPipe
"
;
static
const
char
*
const
k_pch_SteamVR_DisplayDebugX_Int32
=
"
displayDebugX
"
;
static
const
char
*
const
k_pch_SteamVR_DisplayDebugY_Int32
=
"
displayDebugY
"
;
static
const
char
*
const
k_pch_SteamVR_SendSystemButtonToAllApps_Bool
=
"
sendSystemButtonToAllApps
"
;
static
const
char
*
const
k_pch_SteamVR_LogLevel_Int32
=
"
loglevel
"
;
static
const
char
*
const
k_pch_SteamVR_IPD_Float
=
"
ipd
"
;
static
const
char
*
const
k_pch_SteamVR_Background_String
=
"
background
"
;
static
const
char
*
const
k_pch_SteamVR_BackgroundUseDomeProjection_Bool
=
"
backgroundUseDomeProjection
"
;
static
const
char
*
const
k_pch_SteamVR_BackgroundCameraHeight_Float
=
"
backgroundCameraHeight
"
;
static
const
char
*
const
k_pch_SteamVR_BackgroundDomeRadius_Float
=
"
backgroundDomeRadius
"
;
static
const
char
*
const
k_pch_SteamVR_GridColor_String
=
"
gridColor
"
;
static
const
char
*
const
k_pch_SteamVR_PlayAreaColor_String
=
"
playAreaColor
"
;
static
const
char
*
const
k_pch_SteamVR_ShowStage_Bool
=
"
showStage
"
;
static
const
char
*
const
k_pch_SteamVR_ActivateMultipleDrivers_Bool
=
"
activateMultipleDrivers
"
;
static
const
char
*
const
k_pch_SteamVR_DirectMode_Bool
=
"
directMode
"
;
static
const
char
*
const
k_pch_SteamVR_DirectModeEdidVid_Int32
=
"
directModeEdidVid
"
;
static
const
char
*
const
k_pch_SteamVR_DirectModeEdidPid_Int32
=
"
directModeEdidPid
"
;
static
const
char
*
const
k_pch_SteamVR_UsingSpeakers_Bool
=
"
usingSpeakers
"
;
static
const
char
*
const
k_pch_SteamVR_SpeakersForwardYawOffsetDegrees_Float
=
"
speakersForwardYawOffsetDegrees
"
;
static
const
char
*
const
k_pch_SteamVR_BaseStationPowerManagement_Bool
=
"
basestationPowerManagement
"
;
static
const
char
*
const
k_pch_SteamVR_NeverKillProcesses_Bool
=
"
neverKillProcesses
"
;
static
const
char
*
const
k_pch_SteamVR_SupersampleScale_Float
=
"
supersampleScale
"
;
static
const
char
*
const
k_pch_SteamVR_AllowAsyncReprojection_Bool
=
"
allowAsyncReprojection
"
;
static
const
char
*
const
k_pch_SteamVR_AllowReprojection_Bool
=
"
allowInterleavedReprojection
"
;
static
const
char
*
const
k_pch_SteamVR_ForceReprojection_Bool
=
"
forceReprojection
"
;
static
const
char
*
const
k_pch_SteamVR_ForceFadeOnBadTracking_Bool
=
"
forceFadeOnBadTracking
"
;
static
const
char
*
const
k_pch_SteamVR_DefaultMirrorView_Int32
=
"
defaultMirrorView
"
;
static
const
char
*
const
k_pch_SteamVR_ShowMirrorView_Bool
=
"
showMirrorView
"
;
static
const
char
*
const
k_pch_SteamVR_MirrorViewGeometry_String
=
"
mirrorViewGeometry
"
;
static
const
char
*
const
k_pch_SteamVR_StartMonitorFromAppLaunch
=
"
startMonitorFromAppLaunch
"
;
static
const
char
*
const
k_pch_SteamVR_StartCompositorFromAppLaunch_Bool
=
"
startCompositorFromAppLaunch
"
;
static
const
char
*
const
k_pch_SteamVR_StartDashboardFromAppLaunch_Bool
=
"
startDashboardFromAppLaunch
"
;
static
const
char
*
const
k_pch_SteamVR_StartOverlayAppsFromDashboard_Bool
=
"
startOverlayAppsFromDashboard
"
;
static
const
char
*
const
k_pch_SteamVR_EnableHomeApp
=
"
enableHomeApp
"
;
static
const
char
*
const
k_pch_SteamVR_CycleBackgroundImageTimeSec_Int32
=
"
CycleBackgroundImageTimeSec
"
;
static
const
char
*
const
k_pch_SteamVR_RetailDemo_Bool
=
"
retailDemo
"
;
static
const
char
*
const
k_pch_SteamVR_IpdOffset_Float
=
"
ipdOffset
"
;
static
const
char
*
const
k_pch_SteamVR_AllowSupersampleFiltering_Bool
=
"
allowSupersampleFiltering
"
;
static
const
char
*
const
k_pch_SteamVR_SupersampleManualOverride_Bool
=
"
supersampleManualOverride
"
;
static
const
char
*
const
k_pch_SteamVR_EnableLinuxVulkanAsync_Bool
=
"
enableLinuxVulkanAsync
"
;
static
const
char
*
const
k_pch_SteamVR_AllowDisplayLockedMode_Bool
=
"
allowDisplayLockedMode
"
;
static
const
char
*
const
k_pch_SteamVR_HaveStartedTutorialForNativeChaperoneDriver_Bool
=
"
haveStartedTutorialForNativeChaperoneDriver
"
;
static
const
char
*
const
k_pch_SteamVR_ForceWindows32bitVRMonitor
=
"
forceWindows32BitVRMonitor
"
;
static
const
char
*
const
k_pch_SteamVR_DebugInput
=
"
debugInput
"
;
static
const
char
*
const
k_pch_SteamVR_LegacyInputRebinding
=
"
legacyInputRebinding
"
;
static
const
char
*
const
k_pch_Lighthouse_Section
=
"
driver_lighthouse
"
;
static
const
char
*
const
k_pch_Lighthouse_DisableIMU_Bool
=
"
disableimu
"
;
static
const
char
*
const
k_pch_Lighthouse_DisableIMUExceptHMD_Bool
=
"
disableimuexcepthmd
"
;
static
const
char
*
const
k_pch_Lighthouse_UseDisambiguation_String
=
"
usedisambiguation
"
;
static
const
char
*
const
k_pch_Lighthouse_DisambiguationDebug_Int32
=
"
disambiguationdebug
"
;
static
const
char
*
const
k_pch_Lighthouse_PrimaryBasestation_Int32
=
"
primarybasestation
"
;
static
const
char
*
const
k_pch_Lighthouse_DBHistory_Bool
=
"
dbhistory
"
;
static
const
char
*
const
k_pch_Lighthouse_EnableBluetooth_Bool
=
"
enableBluetooth
"
;
static
const
char
*
const
k_pch_Lighthouse_PowerManagedBaseStations_String
=
"
PowerManagedBaseStations
"
;
static
const
char
*
const
k_pch_Null_Section
=
"
driver_null
"
;
static
const
char
*
const
k_pch_Null_SerialNumber_String
=
"
serialNumber
"
;
static
const
char
*
const
k_pch_Null_ModelNumber_String
=
"
modelNumber
"
;
static
const
char
*
const
k_pch_Null_WindowX_Int32
=
"
windowX
"
;
static
const
char
*
const
k_pch_Null_WindowY_Int32
=
"
windowY
"
;
static
const
char
*
const
k_pch_Null_WindowWidth_Int32
=
"
windowWidth
"
;
static
const
char
*
const
k_pch_Null_WindowHeight_Int32
=
"
windowHeight
"
;
static
const
char
*
const
k_pch_Null_RenderWidth_Int32
=
"
renderWidth
"
;
static
const
char
*
const
k_pch_Null_RenderHeight_Int32
=
"
renderHeight
"
;
static
const
char
*
const
k_pch_Null_SecondsFromVsyncToPhotons_Float
=
"
secondsFromVsyncToPhotons
"
;
static
const
char
*
const
k_pch_Null_DisplayFrequency_Float
=
"
displayFrequency
"
;
static
const
char
*
const
k_pch_UserInterface_Section
=
"
userinterface
"
;
static
const
char
*
const
k_pch_UserInterface_StatusAlwaysOnTop_Bool
=
"
StatusAlwaysOnTop
"
;
static
const
char
*
const
k_pch_UserInterface_MinimizeToTray_Bool
=
"
MinimizeToTray
"
;
static
const
char
*
const
k_pch_UserInterface_Screenshots_Bool
=
"
screenshots
"
;
static
const
char
*
const
k_pch_UserInterface_ScreenshotType_Int
=
"
screenshotType
"
;
static
const
char
*
const
k_pch_Notifications_Section
=
"
notifications
"
;
static
const
char
*
const
k_pch_Notifications_DoNotDisturb_Bool
=
"
DoNotDisturb
"
;
static
const
char
*
const
k_pch_Keyboard_Section
=
"
keyboard
"
;
static
const
char
*
const
k_pch_Keyboard_TutorialCompletions
=
"
TutorialCompletions
"
;
static
const
char
*
const
k_pch_Keyboard_ScaleX
=
"
ScaleX
"
;
static
const
char
*
const
k_pch_Keyboard_ScaleY
=
"
ScaleY
"
;
static
const
char
*
const
k_pch_Keyboard_OffsetLeftX
=
"
OffsetLeftX
"
;
static
const
char
*
const
k_pch_Keyboard_OffsetRightX
=
"
OffsetRightX
"
;
static
const
char
*
const
k_pch_Keyboard_OffsetY
=
"
OffsetY
"
;
static
const
char
*
const
k_pch_Keyboard_Smoothing
=
"
Smoothing
"
;
static
const
char
*
const
k_pch_Perf_Section
=
"
perfcheck
"
;
static
const
char
*
const
k_pch_Perf_HeuristicActive_Bool
=
"
heuristicActive
"
;
static
const
char
*
const
k_pch_Perf_NotifyInHMD_Bool
=
"
warnInHMD
"
;
static
const
char
*
const
k_pch_Perf_NotifyOnlyOnce_Bool
=
"
warnOnlyOnce
"
;
static
const
char
*
const
k_pch_Perf_AllowTimingStore_Bool
=
"
allowTimingStore
"
;
static
const
char
*
const
k_pch_Perf_SaveTimingsOnExit_Bool
=
"
saveTimingsOnExit
"
;
static
const
char
*
const
k_pch_Perf_TestData_Float
=
"
perfTestData
"
;
static
const
char
*
const
k_pch_Perf_LinuxGPUProfiling_Bool
=
"
linuxGPUProfiling
"
;
static
const
char
*
const
k_pch_CollisionBounds_Section
=
"
collisionBounds
"
;
static
const
char
*
const
k_pch_CollisionBounds_Style_Int32
=
"
CollisionBoundsStyle
"
;
static
const
char
*
const
k_pch_CollisionBounds_GroundPerimeterOn_Bool
=
"
CollisionBoundsGroundPerimeterOn
"
;
static
const
char
*
const
k_pch_CollisionBounds_CenterMarkerOn_Bool
=
"
CollisionBoundsCenterMarkerOn
"
;
static
const
char
*
const
k_pch_CollisionBounds_PlaySpaceOn_Bool
=
"
CollisionBoundsPlaySpaceOn
"
;
static
const
char
*
const
k_pch_CollisionBounds_FadeDistance_Float
=
"
CollisionBoundsFadeDistance
"
;
static
const
char
*
const
k_pch_CollisionBounds_ColorGammaR_Int32
=
"
CollisionBoundsColorGammaR
"
;
static
const
char
*
const
k_pch_CollisionBounds_ColorGammaG_Int32
=
"
CollisionBoundsColorGammaG
"
;
static
const
char
*
const
k_pch_CollisionBounds_ColorGammaB_Int32
=
"
CollisionBoundsColorGammaB
"
;
static
const
char
*
const
k_pch_CollisionBounds_ColorGammaA_Int32
=
"
CollisionBoundsColorGammaA
"
;
static
const
char
*
const
k_pch_Camera_Section
=
"
camera
"
;
static
const
char
*
const
k_pch_Camera_EnableCamera_Bool
=
"
enableCamera
"
;
static
const
char
*
const
k_pch_Camera_EnableCameraInDashboard_Bool
=
"
enableCameraInDashboard
"
;
static
const
char
*
const
k_pch_Camera_EnableCameraForCollisionBounds_Bool
=
"
enableCameraForCollisionBounds
"
;
static
const
char
*
const
k_pch_Camera_EnableCameraForRoomView_Bool
=
"
enableCameraForRoomView
"
;
static
const
char
*
const
k_pch_Camera_BoundsColorGammaR_Int32
=
"
cameraBoundsColorGammaR
"
;
static
const
char
*
const
k_pch_Camera_BoundsColorGammaG_Int32
=
"
cameraBoundsColorGammaG
"
;
static
const
char
*
const
k_pch_Camera_BoundsColorGammaB_Int32
=
"
cameraBoundsColorGammaB
"
;
static
const
char
*
const
k_pch_Camera_BoundsColorGammaA_Int32
=
"
cameraBoundsColorGammaA
"
;
static
const
char
*
const
k_pch_Camera_BoundsStrength_Int32
=
"
cameraBoundsStrength
"
;
static
const
char
*
const
k_pch_Camera_RoomViewMode_Int32
=
"
cameraRoomViewMode
"
;
static
const
char
*
const
k_pch_audio_Section
=
"
audio
"
;
static
const
char
*
const
k_pch_audio_OnPlaybackDevice_String
=
"
onPlaybackDevice
"
;
static
const
char
*
const
k_pch_audio_OnRecordDevice_String
=
"
onRecordDevice
"
;
static
const
char
*
const
k_pch_audio_OnPlaybackMirrorDevice_String
=
"
onPlaybackMirrorDevice
"
;
static
const
char
*
const
k_pch_audio_OffPlaybackDevice_String
=
"
offPlaybackDevice
"
;
static
const
char
*
const
k_pch_audio_OffRecordDevice_String
=
"
offRecordDevice
"
;
static
const
char
*
const
k_pch_audio_VIVEHDMIGain
=
"
viveHDMIGain
"
;
static
const
char
*
const
k_pch_Power_Section
=
"
power
"
;
static
const
char
*
const
k_pch_Power_PowerOffOnExit_Bool
=
"
powerOffOnExit
"
;
static
const
char
*
const
k_pch_Power_TurnOffScreensTimeout_Float
=
"
turnOffScreensTimeout
"
;
static
const
char
*
const
k_pch_Power_TurnOffControllersTimeout_Float
=
"
turnOffControllersTimeout
"
;
static
const
char
*
const
k_pch_Power_ReturnToWatchdogTimeout_Float
=
"
returnToWatchdogTimeout
"
;
static
const
char
*
const
k_pch_Power_AutoLaunchSteamVROnButtonPress
=
"
autoLaunchSteamVROnButtonPress
"
;
static
const
char
*
const
k_pch_Power_PauseCompositorOnStandby_Bool
=
"
pauseCompositorOnStandby
"
;
static
const
char
*
const
k_pch_Dashboard_Section
=
"
dashboard
"
;
static
const
char
*
const
k_pch_Dashboard_EnableDashboard_Bool
=
"
enableDashboard
"
;
static
const
char
*
const
k_pch_Dashboard_ArcadeMode_Bool
=
"
arcadeMode
"
;
static
const
char
*
const
k_pch_Dashboard_EnableWebUI
=
"
webUI
"
;
static
const
char
*
const
k_pch_Dashboard_EnableWebUIDevTools
=
"
webUIDevTools
"
;
static
const
char
*
const
k_pch_modelskin_Section
=
"
modelskins
"
;
static
const
char
*
const
k_pch_Driver_Enable_Bool
=
"
enable
"
;
static
const
char
*
const
k_pch_WebInterface_Section
=
"
WebInterface
"
;
static
const
char
*
const
k_pch_WebInterface_WebPort_String
=
"
WebPort
"
;
}
namespace
vr
{
#
pragma
pack
(
push
8
)
enum
ChaperoneCalibrationState
{
ChaperoneCalibrationState_OK
=
1
ChaperoneCalibrationState_Warning
=
100
ChaperoneCalibrationState_Warning_BaseStationMayHaveMoved
=
101
ChaperoneCalibrationState_Warning_BaseStationRemoved
=
102
ChaperoneCalibrationState_Warning_SeatedBoundsInvalid
=
103
ChaperoneCalibrationState_Error
=
200
ChaperoneCalibrationState_Error_BaseStationUninitialized
=
201
ChaperoneCalibrationState_Error_BaseStationConflict
=
202
ChaperoneCalibrationState_Error_PlayAreaInvalid
=
203
ChaperoneCalibrationState_Error_CollisionBoundsInvalid
=
204
}
;
class
IVRChaperone
{
public
:
virtual
ChaperoneCalibrationState
GetCalibrationState
(
)
=
0
;
virtual
bool
GetPlayAreaSize
(
float
*
pSizeX
float
*
pSizeZ
)
=
0
;
virtual
bool
GetPlayAreaRect
(
HmdQuad_t
*
rect
)
=
0
;
virtual
void
ReloadInfo
(
void
)
=
0
;
virtual
void
SetSceneColor
(
HmdColor_t
color
)
=
0
;
virtual
void
GetBoundsColor
(
HmdColor_t
*
pOutputColorArray
int
nNumOutputColors
float
flCollisionBoundsFadeDistance
HmdColor_t
*
pOutputCameraColor
)
=
0
;
virtual
bool
AreBoundsVisible
(
)
=
0
;
virtual
void
ForceBoundsVisible
(
bool
bForce
)
=
0
;
}
;
static
const
char
*
const
IVRChaperone_Version
=
"
IVRChaperone_003
"
;
#
pragma
pack
(
pop
)
}
namespace
vr
{
enum
EChaperoneConfigFile
{
EChaperoneConfigFile_Live
=
1
EChaperoneConfigFile_Temp
=
2
}
;
enum
EChaperoneImportFlags
{
EChaperoneImport_BoundsOnly
=
0x0001
}
;
class
IVRChaperoneSetup
{
public
:
virtual
bool
CommitWorkingCopy
(
EChaperoneConfigFile
configFile
)
=
0
;
virtual
void
RevertWorkingCopy
(
)
=
0
;
virtual
bool
GetWorkingPlayAreaSize
(
float
*
pSizeX
float
*
pSizeZ
)
=
0
;
virtual
bool
GetWorkingPlayAreaRect
(
HmdQuad_t
*
rect
)
=
0
;
virtual
bool
GetWorkingCollisionBoundsInfo
(
VR_OUT_ARRAY_COUNT
(
punQuadsCount
)
HmdQuad_t
*
pQuadsBuffer
uint32_t
*
punQuadsCount
)
=
0
;
virtual
bool
GetLiveCollisionBoundsInfo
(
VR_OUT_ARRAY_COUNT
(
punQuadsCount
)
HmdQuad_t
*
pQuadsBuffer
uint32_t
*
punQuadsCount
)
=
0
;
virtual
bool
GetWorkingSeatedZeroPoseToRawTrackingPose
(
HmdMatrix34_t
*
pmatSeatedZeroPoseToRawTrackingPose
)
=
0
;
virtual
bool
GetWorkingStandingZeroPoseToRawTrackingPose
(
HmdMatrix34_t
*
pmatStandingZeroPoseToRawTrackingPose
)
=
0
;
virtual
void
SetWorkingPlayAreaSize
(
float
sizeX
float
sizeZ
)
=
0
;
virtual
void
SetWorkingCollisionBoundsInfo
(
VR_ARRAY_COUNT
(
unQuadsCount
)
HmdQuad_t
*
pQuadsBuffer
uint32_t
unQuadsCount
)
=
0
;
virtual
void
SetWorkingSeatedZeroPoseToRawTrackingPose
(
const
HmdMatrix34_t
*
pMatSeatedZeroPoseToRawTrackingPose
)
=
0
;
virtual
void
SetWorkingStandingZeroPoseToRawTrackingPose
(
const
HmdMatrix34_t
*
pMatStandingZeroPoseToRawTrackingPose
)
=
0
;
virtual
void
ReloadFromDisk
(
EChaperoneConfigFile
configFile
)
=
0
;
virtual
bool
GetLiveSeatedZeroPoseToRawTrackingPose
(
HmdMatrix34_t
*
pmatSeatedZeroPoseToRawTrackingPose
)
=
0
;
virtual
void
SetWorkingCollisionBoundsTagsInfo
(
VR_ARRAY_COUNT
(
unTagCount
)
uint8_t
*
pTagsBuffer
uint32_t
unTagCount
)
=
0
;
virtual
bool
GetLiveCollisionBoundsTagsInfo
(
VR_OUT_ARRAY_COUNT
(
punTagCount
)
uint8_t
*
pTagsBuffer
uint32_t
*
punTagCount
)
=
0
;
virtual
bool
SetWorkingPhysicalBoundsInfo
(
VR_ARRAY_COUNT
(
unQuadsCount
)
HmdQuad_t
*
pQuadsBuffer
uint32_t
unQuadsCount
)
=
0
;
virtual
bool
GetLivePhysicalBoundsInfo
(
VR_OUT_ARRAY_COUNT
(
punQuadsCount
)
HmdQuad_t
*
pQuadsBuffer
uint32_t
*
punQuadsCount
)
=
0
;
virtual
bool
ExportLiveToBuffer
(
VR_OUT_STRING
(
)
char
*
pBuffer
uint32_t
*
pnBufferLength
)
=
0
;
virtual
bool
ImportFromBufferToWorking
(
const
char
*
pBuffer
uint32_t
nImportFlags
)
=
0
;
}
;
static
const
char
*
const
IVRChaperoneSetup_Version
=
"
IVRChaperoneSetup_005
"
;
}
namespace
vr
{
#
pragma
pack
(
push
8
)
enum
EVRCompositorError
{
VRCompositorError_None
=
0
VRCompositorError_RequestFailed
=
1
VRCompositorError_IncompatibleVersion
=
100
VRCompositorError_DoNotHaveFocus
=
101
VRCompositorError_InvalidTexture
=
102
VRCompositorError_IsNotSceneApplication
=
103
VRCompositorError_TextureIsOnWrongDevice
=
104
VRCompositorError_TextureUsesUnsupportedFormat
=
105
VRCompositorError_SharedTexturesNotSupported
=
106
VRCompositorError_IndexOutOfRange
=
107
VRCompositorError_AlreadySubmitted
=
108
VRCompositorError_InvalidBounds
=
109
}
;
enum
EVRCompositorTimingMode
{
VRCompositorTimingMode_Implicit
=
0
VRCompositorTimingMode_Explicit_RuntimePerformsPostPresentHandoff
=
1
VRCompositorTimingMode_Explicit_ApplicationPerformsPostPresentHandoff
=
2
}
;
const
uint32_t
VRCompositor_ReprojectionReason_Cpu
=
0x01
;
const
uint32_t
VRCompositor_ReprojectionReason_Gpu
=
0x02
;
const
uint32_t
VRCompositor_ReprojectionAsync
=
0x04
;
struct
Compositor_FrameTiming
{
uint32_t
m_nSize
;
uint32_t
m_nFrameIndex
;
uint32_t
m_nNumFramePresents
;
uint32_t
m_nNumMisPresented
;
uint32_t
m_nNumDroppedFrames
;
uint32_t
m_nReprojectionFlags
;
double
m_flSystemTimeInSeconds
;
float
m_flPreSubmitGpuMs
;
float
m_flPostSubmitGpuMs
;
float
m_flTotalRenderGpuMs
;
float
m_flCompositorRenderGpuMs
;
float
m_flCompositorRenderCpuMs
;
float
m_flCompositorIdleCpuMs
;
float
m_flClientFrameIntervalMs
;
float
m_flPresentCallCpuMs
;
float
m_flWaitForPresentCpuMs
;
float
m_flSubmitFrameMs
;
float
m_flWaitGetPosesCalledMs
;
float
m_flNewPosesReadyMs
;
float
m_flNewFrameReadyMs
;
float
m_flCompositorUpdateStartMs
;
float
m_flCompositorUpdateEndMs
;
float
m_flCompositorRenderStartMs
;
vr
:
:
TrackedDevicePose_t
m_HmdPose
;
}
;
struct
Compositor_CumulativeStats
{
uint32_t
m_nPid
;
uint32_t
m_nNumFramePresents
;
uint32_t
m_nNumDroppedFrames
;
uint32_t
m_nNumReprojectedFrames
;
uint32_t
m_nNumFramePresentsOnStartup
;
uint32_t
m_nNumDroppedFramesOnStartup
;
uint32_t
m_nNumReprojectedFramesOnStartup
;
uint32_t
m_nNumLoading
;
uint32_t
m_nNumFramePresentsLoading
;
uint32_t
m_nNumDroppedFramesLoading
;
uint32_t
m_nNumReprojectedFramesLoading
;
uint32_t
m_nNumTimedOut
;
uint32_t
m_nNumFramePresentsTimedOut
;
uint32_t
m_nNumDroppedFramesTimedOut
;
uint32_t
m_nNumReprojectedFramesTimedOut
;
}
;
#
pragma
pack
(
pop
)
class
IVRCompositor
{
public
:
virtual
void
SetTrackingSpace
(
ETrackingUniverseOrigin
eOrigin
)
=
0
;
virtual
ETrackingUniverseOrigin
GetTrackingSpace
(
)
=
0
;
virtual
EVRCompositorError
WaitGetPoses
(
VR_ARRAY_COUNT
(
unRenderPoseArrayCount
)
TrackedDevicePose_t
*
pRenderPoseArray
uint32_t
unRenderPoseArrayCount
VR_ARRAY_COUNT
(
unGamePoseArrayCount
)
TrackedDevicePose_t
*
pGamePoseArray
uint32_t
unGamePoseArrayCount
)
=
0
;
virtual
EVRCompositorError
GetLastPoses
(
VR_ARRAY_COUNT
(
unRenderPoseArrayCount
)
TrackedDevicePose_t
*
pRenderPoseArray
uint32_t
unRenderPoseArrayCount
VR_ARRAY_COUNT
(
unGamePoseArrayCount
)
TrackedDevicePose_t
*
pGamePoseArray
uint32_t
unGamePoseArrayCount
)
=
0
;
virtual
EVRCompositorError
GetLastPoseForTrackedDeviceIndex
(
TrackedDeviceIndex_t
unDeviceIndex
TrackedDevicePose_t
*
pOutputPose
TrackedDevicePose_t
*
pOutputGamePose
)
=
0
;
virtual
EVRCompositorError
Submit
(
EVREye
eEye
const
Texture_t
*
pTexture
const
VRTextureBounds_t
*
pBounds
=
0
EVRSubmitFlags
nSubmitFlags
=
Submit_Default
)
=
0
;
virtual
void
ClearLastSubmittedFrame
(
)
=
0
;
virtual
void
PostPresentHandoff
(
)
=
0
;
virtual
bool
GetFrameTiming
(
Compositor_FrameTiming
*
pTiming
uint32_t
unFramesAgo
=
0
)
=
0
;
virtual
uint32_t
GetFrameTimings
(
Compositor_FrameTiming
*
pTiming
uint32_t
nFrames
)
=
0
;
virtual
float
GetFrameTimeRemaining
(
)
=
0
;
virtual
void
GetCumulativeStats
(
Compositor_CumulativeStats
*
pStats
uint32_t
nStatsSizeInBytes
)
=
0
;
virtual
void
FadeToColor
(
float
fSeconds
float
fRed
float
fGreen
float
fBlue
float
fAlpha
bool
bBackground
=
false
)
=
0
;
virtual
HmdColor_t
GetCurrentFadeColor
(
bool
bBackground
=
false
)
=
0
;
virtual
void
FadeGrid
(
float
fSeconds
bool
bFadeIn
)
=
0
;
virtual
float
GetCurrentGridAlpha
(
)
=
0
;
virtual
EVRCompositorError
SetSkyboxOverride
(
VR_ARRAY_COUNT
(
unTextureCount
)
const
Texture_t
*
pTextures
uint32_t
unTextureCount
)
=
0
;
virtual
void
ClearSkyboxOverride
(
)
=
0
;
virtual
void
CompositorBringToFront
(
)
=
0
;
virtual
void
CompositorGoToBack
(
)
=
0
;
virtual
void
CompositorQuit
(
)
=
0
;
virtual
bool
IsFullscreen
(
)
=
0
;
virtual
uint32_t
GetCurrentSceneFocusProcess
(
)
=
0
;
virtual
uint32_t
GetLastFrameRenderer
(
)
=
0
;
virtual
bool
CanRenderScene
(
)
=
0
;
virtual
void
ShowMirrorWindow
(
)
=
0
;
virtual
void
HideMirrorWindow
(
)
=
0
;
virtual
bool
IsMirrorWindowVisible
(
)
=
0
;
virtual
void
CompositorDumpImages
(
)
=
0
;
virtual
bool
ShouldAppRenderWithLowResources
(
)
=
0
;
virtual
void
ForceInterleavedReprojectionOn
(
bool
bOverride
)
=
0
;
virtual
void
ForceReconnectProcess
(
)
=
0
;
virtual
void
SuspendRendering
(
bool
bSuspend
)
=
0
;
virtual
vr
:
:
EVRCompositorError
GetMirrorTextureD3D11
(
vr
:
:
EVREye
eEye
void
*
pD3D11DeviceOrResource
void
*
*
ppD3D11ShaderResourceView
)
=
0
;
virtual
void
ReleaseMirrorTextureD3D11
(
void
*
pD3D11ShaderResourceView
)
=
0
;
virtual
vr
:
:
EVRCompositorError
GetMirrorTextureGL
(
vr
:
:
EVREye
eEye
vr
:
:
glUInt_t
*
pglTextureId
vr
:
:
glSharedTextureHandle_t
*
pglSharedTextureHandle
)
=
0
;
virtual
bool
ReleaseSharedGLTexture
(
vr
:
:
glUInt_t
glTextureId
vr
:
:
glSharedTextureHandle_t
glSharedTextureHandle
)
=
0
;
virtual
void
LockGLSharedTextureForAccess
(
vr
:
:
glSharedTextureHandle_t
glSharedTextureHandle
)
=
0
;
virtual
void
UnlockGLSharedTextureForAccess
(
vr
:
:
glSharedTextureHandle_t
glSharedTextureHandle
)
=
0
;
virtual
uint32_t
GetVulkanInstanceExtensionsRequired
(
VR_OUT_STRING
(
)
char
*
pchValue
uint32_t
unBufferSize
)
=
0
;
virtual
uint32_t
GetVulkanDeviceExtensionsRequired
(
VkPhysicalDevice_T
*
pPhysicalDevice
VR_OUT_STRING
(
)
char
*
pchValue
uint32_t
unBufferSize
)
=
0
;
virtual
void
SetExplicitTimingMode
(
EVRCompositorTimingMode
eTimingMode
)
=
0
;
virtual
EVRCompositorError
SubmitExplicitTimingData
(
)
=
0
;
}
;
static
const
char
*
const
IVRCompositor_Version
=
"
IVRCompositor_022
"
;
}
namespace
vr
{
#
pragma
pack
(
push
8
)
struct
NotificationBitmap_t
{
NotificationBitmap_t
(
)
:
m_pImageData
(
nullptr
)
m_nWidth
(
0
)
m_nHeight
(
0
)
m_nBytesPerPixel
(
0
)
{
}
;
void
*
m_pImageData
;
int32_t
m_nWidth
;
int32_t
m_nHeight
;
int32_t
m_nBytesPerPixel
;
}
;
enum
EVRNotificationType
{
EVRNotificationType_Transient
=
0
EVRNotificationType_Persistent
=
1
EVRNotificationType_Transient_SystemWithUserValue
=
2
}
;
enum
EVRNotificationStyle
{
EVRNotificationStyle_None
=
0
EVRNotificationStyle_Application
=
100
EVRNotificationStyle_Contact_Disabled
=
200
EVRNotificationStyle_Contact_Enabled
=
201
EVRNotificationStyle_Contact_Active
=
202
}
;
static
const
uint32_t
k_unNotificationTextMaxSize
=
256
;
typedef
uint32_t
VRNotificationId
;
#
pragma
pack
(
pop
)
class
IVRNotifications
{
public
:
virtual
EVRNotificationError
CreateNotification
(
VROverlayHandle_t
ulOverlayHandle
uint64_t
ulUserValue
EVRNotificationType
type
const
char
*
pchText
EVRNotificationStyle
style
const
NotificationBitmap_t
*
pImage
VRNotificationId
*
pNotificationId
)
=
0
;
virtual
EVRNotificationError
RemoveNotification
(
VRNotificationId
notificationId
)
=
0
;
}
;
static
const
char
*
const
IVRNotifications_Version
=
"
IVRNotifications_002
"
;
}
namespace
vr
{
static
const
uint32_t
k_unVROverlayMaxKeyLength
=
128
;
static
const
uint32_t
k_unVROverlayMaxNameLength
=
128
;
static
const
uint32_t
k_unMaxOverlayCount
=
64
;
static
const
uint32_t
k_unMaxOverlayIntersectionMaskPrimitivesCount
=
32
;
enum
VROverlayInputMethod
{
VROverlayInputMethod_None
=
0
VROverlayInputMethod_Mouse
=
1
VROverlayInputMethod_DualAnalog
=
2
}
;
enum
VROverlayTransformType
{
VROverlayTransform_Absolute
=
0
VROverlayTransform_TrackedDeviceRelative
=
1
VROverlayTransform_SystemOverlay
=
2
VROverlayTransform_TrackedComponent
=
3
}
;
enum
VROverlayFlags
{
VROverlayFlags_None
=
0
VROverlayFlags_Curved
=
1
VROverlayFlags_RGSS4X
=
2
VROverlayFlags_NoDashboardTab
=
3
VROverlayFlags_AcceptsGamepadEvents
=
4
VROverlayFlags_ShowGamepadFocus
=
5
VROverlayFlags_SendVRScrollEvents
=
6
VROverlayFlags_SendVRTouchpadEvents
=
7
VROverlayFlags_ShowTouchPadScrollWheel
=
8
VROverlayFlags_TransferOwnershipToInternalProcess
=
9
VROverlayFlags_SideBySide_Parallel
=
10
VROverlayFlags_SideBySide_Crossed
=
11
VROverlayFlags_Panorama
=
12
VROverlayFlags_StereoPanorama
=
13
VROverlayFlags_SortWithNonSceneOverlays
=
14
VROverlayFlags_VisibleInDashboard
=
15
}
;
enum
VRMessageOverlayResponse
{
VRMessageOverlayResponse_ButtonPress_0
=
0
VRMessageOverlayResponse_ButtonPress_1
=
1
VRMessageOverlayResponse_ButtonPress_2
=
2
VRMessageOverlayResponse_ButtonPress_3
=
3
VRMessageOverlayResponse_CouldntFindSystemOverlay
=
4
VRMessageOverlayResponse_CouldntFindOrCreateClientOverlay
=
5
VRMessageOverlayResponse_ApplicationQuit
=
6
}
;
struct
VROverlayIntersectionParams_t
{
HmdVector3_t
vSource
;
HmdVector3_t
vDirection
;
ETrackingUniverseOrigin
eOrigin
;
}
;
struct
VROverlayIntersectionResults_t
{
HmdVector3_t
vPoint
;
HmdVector3_t
vNormal
;
HmdVector2_t
vUVs
;
float
fDistance
;
}
;
enum
EGamepadTextInputMode
{
k_EGamepadTextInputModeNormal
=
0
k_EGamepadTextInputModePassword
=
1
k_EGamepadTextInputModeSubmit
=
2
}
;
enum
EGamepadTextInputLineMode
{
k_EGamepadTextInputLineModeSingleLine
=
0
k_EGamepadTextInputLineModeMultipleLines
=
1
}
;
enum
EOverlayDirection
{
OverlayDirection_Up
=
0
OverlayDirection_Down
=
1
OverlayDirection_Left
=
2
OverlayDirection_Right
=
3
OverlayDirection_Count
=
4
}
;
enum
EVROverlayIntersectionMaskPrimitiveType
{
OverlayIntersectionPrimitiveType_Rectangle
OverlayIntersectionPrimitiveType_Circle
}
;
struct
IntersectionMaskRectangle_t
{
float
m_flTopLeftX
;
float
m_flTopLeftY
;
float
m_flWidth
;
float
m_flHeight
;
}
;
struct
IntersectionMaskCircle_t
{
float
m_flCenterX
;
float
m_flCenterY
;
float
m_flRadius
;
}
;
typedef
union
{
IntersectionMaskRectangle_t
m_Rectangle
;
IntersectionMaskCircle_t
m_Circle
;
}
VROverlayIntersectionMaskPrimitive_Data_t
;
struct
VROverlayIntersectionMaskPrimitive_t
{
EVROverlayIntersectionMaskPrimitiveType
m_nPrimitiveType
;
VROverlayIntersectionMaskPrimitive_Data_t
m_Primitive
;
}
;
class
IVROverlay
{
public
:
virtual
EVROverlayError
FindOverlay
(
const
char
*
pchOverlayKey
VROverlayHandle_t
*
pOverlayHandle
)
=
0
;
virtual
EVROverlayError
CreateOverlay
(
const
char
*
pchOverlayKey
const
char
*
pchOverlayName
VROverlayHandle_t
*
pOverlayHandle
)
=
0
;
virtual
EVROverlayError
DestroyOverlay
(
VROverlayHandle_t
ulOverlayHandle
)
=
0
;
virtual
EVROverlayError
SetHighQualityOverlay
(
VROverlayHandle_t
ulOverlayHandle
)
=
0
;
virtual
vr
:
:
VROverlayHandle_t
GetHighQualityOverlay
(
)
=
0
;
virtual
uint32_t
GetOverlayKey
(
VROverlayHandle_t
ulOverlayHandle
VR_OUT_STRING
(
)
char
*
pchValue
uint32_t
unBufferSize
EVROverlayError
*
pError
=
0L
)
=
0
;
virtual
uint32_t
GetOverlayName
(
VROverlayHandle_t
ulOverlayHandle
VR_OUT_STRING
(
)
char
*
pchValue
uint32_t
unBufferSize
EVROverlayError
*
pError
=
0L
)
=
0
;
virtual
EVROverlayError
SetOverlayName
(
VROverlayHandle_t
ulOverlayHandle
const
char
*
pchName
)
=
0
;
virtual
EVROverlayError
GetOverlayImageData
(
VROverlayHandle_t
ulOverlayHandle
void
*
pvBuffer
uint32_t
unBufferSize
uint32_t
*
punWidth
uint32_t
*
punHeight
)
=
0
;
virtual
const
char
*
GetOverlayErrorNameFromEnum
(
EVROverlayError
error
)
=
0
;
virtual
EVROverlayError
SetOverlayRenderingPid
(
VROverlayHandle_t
ulOverlayHandle
uint32_t
unPID
)
=
0
;
virtual
uint32_t
GetOverlayRenderingPid
(
VROverlayHandle_t
ulOverlayHandle
)
=
0
;
virtual
EVROverlayError
SetOverlayFlag
(
VROverlayHandle_t
ulOverlayHandle
VROverlayFlags
eOverlayFlag
bool
bEnabled
)
=
0
;
virtual
EVROverlayError
GetOverlayFlag
(
VROverlayHandle_t
ulOverlayHandle
VROverlayFlags
eOverlayFlag
bool
*
pbEnabled
)
=
0
;
virtual
EVROverlayError
SetOverlayColor
(
VROverlayHandle_t
ulOverlayHandle
float
fRed
float
fGreen
float
fBlue
)
=
0
;
virtual
EVROverlayError
GetOverlayColor
(
VROverlayHandle_t
ulOverlayHandle
float
*
pfRed
float
*
pfGreen
float
*
pfBlue
)
=
0
;
virtual
EVROverlayError
SetOverlayAlpha
(
VROverlayHandle_t
ulOverlayHandle
float
fAlpha
)
=
0
;
virtual
EVROverlayError
GetOverlayAlpha
(
VROverlayHandle_t
ulOverlayHandle
float
*
pfAlpha
)
=
0
;
virtual
EVROverlayError
SetOverlayTexelAspect
(
VROverlayHandle_t
ulOverlayHandle
float
fTexelAspect
)
=
0
;
virtual
EVROverlayError
GetOverlayTexelAspect
(
VROverlayHandle_t
ulOverlayHandle
float
*
pfTexelAspect
)
=
0
;
virtual
EVROverlayError
SetOverlaySortOrder
(
VROverlayHandle_t
ulOverlayHandle
uint32_t
unSortOrder
)
=
0
;
virtual
EVROverlayError
GetOverlaySortOrder
(
VROverlayHandle_t
ulOverlayHandle
uint32_t
*
punSortOrder
)
=
0
;
virtual
EVROverlayError
SetOverlayWidthInMeters
(
VROverlayHandle_t
ulOverlayHandle
float
fWidthInMeters
)
=
0
;
virtual
EVROverlayError
GetOverlayWidthInMeters
(
VROverlayHandle_t
ulOverlayHandle
float
*
pfWidthInMeters
)
=
0
;
virtual
EVROverlayError
SetOverlayAutoCurveDistanceRangeInMeters
(
VROverlayHandle_t
ulOverlayHandle
float
fMinDistanceInMeters
float
fMaxDistanceInMeters
)
=
0
;
virtual
EVROverlayError
GetOverlayAutoCurveDistanceRangeInMeters
(
VROverlayHandle_t
ulOverlayHandle
float
*
pfMinDistanceInMeters
float
*
pfMaxDistanceInMeters
)
=
0
;
virtual
EVROverlayError
SetOverlayTextureColorSpace
(
VROverlayHandle_t
ulOverlayHandle
EColorSpace
eTextureColorSpace
)
=
0
;
virtual
EVROverlayError
GetOverlayTextureColorSpace
(
VROverlayHandle_t
ulOverlayHandle
EColorSpace
*
peTextureColorSpace
)
=
0
;
virtual
EVROverlayError
SetOverlayTextureBounds
(
VROverlayHandle_t
ulOverlayHandle
const
VRTextureBounds_t
*
pOverlayTextureBounds
)
=
0
;
virtual
EVROverlayError
GetOverlayTextureBounds
(
VROverlayHandle_t
ulOverlayHandle
VRTextureBounds_t
*
pOverlayTextureBounds
)
=
0
;
virtual
uint32_t
GetOverlayRenderModel
(
vr
:
:
VROverlayHandle_t
ulOverlayHandle
VR_OUT_STRING
(
)
char
*
pchValue
uint32_t
unBufferSize
HmdColor_t
*
pColor
vr
:
:
EVROverlayError
*
pError
)
=
0
;
virtual
vr
:
:
EVROverlayError
SetOverlayRenderModel
(
vr
:
:
VROverlayHandle_t
ulOverlayHandle
const
char
*
pchRenderModel
const
HmdColor_t
*
pColor
)
=
0
;
virtual
EVROverlayError
GetOverlayTransformType
(
VROverlayHandle_t
ulOverlayHandle
VROverlayTransformType
*
peTransformType
)
=
0
;
virtual
EVROverlayError
SetOverlayTransformAbsolute
(
VROverlayHandle_t
ulOverlayHandle
ETrackingUniverseOrigin
eTrackingOrigin
const
HmdMatrix34_t
*
pmatTrackingOriginToOverlayTransform
)
=
0
;
virtual
EVROverlayError
GetOverlayTransformAbsolute
(
VROverlayHandle_t
ulOverlayHandle
ETrackingUniverseOrigin
*
peTrackingOrigin
HmdMatrix34_t
*
pmatTrackingOriginToOverlayTransform
)
=
0
;
virtual
EVROverlayError
SetOverlayTransformTrackedDeviceRelative
(
VROverlayHandle_t
ulOverlayHandle
TrackedDeviceIndex_t
unTrackedDevice
const
HmdMatrix34_t
*
pmatTrackedDeviceToOverlayTransform
)
=
0
;
virtual
EVROverlayError
GetOverlayTransformTrackedDeviceRelative
(
VROverlayHandle_t
ulOverlayHandle
TrackedDeviceIndex_t
*
punTrackedDevice
HmdMatrix34_t
*
pmatTrackedDeviceToOverlayTransform
)
=
0
;
virtual
EVROverlayError
SetOverlayTransformTrackedDeviceComponent
(
VROverlayHandle_t
ulOverlayHandle
TrackedDeviceIndex_t
unDeviceIndex
const
char
*
pchComponentName
)
=
0
;
virtual
EVROverlayError
GetOverlayTransformTrackedDeviceComponent
(
VROverlayHandle_t
ulOverlayHandle
TrackedDeviceIndex_t
*
punDeviceIndex
VR_OUT_STRING
(
)
char
*
pchComponentName
uint32_t
unComponentNameSize
)
=
0
;
virtual
vr
:
:
EVROverlayError
GetOverlayTransformOverlayRelative
(
VROverlayHandle_t
ulOverlayHandle
VROverlayHandle_t
*
ulOverlayHandleParent
HmdMatrix34_t
*
pmatParentOverlayToOverlayTransform
)
=
0
;
virtual
vr
:
:
EVROverlayError
SetOverlayTransformOverlayRelative
(
VROverlayHandle_t
ulOverlayHandle
VROverlayHandle_t
ulOverlayHandleParent
const
HmdMatrix34_t
*
pmatParentOverlayToOverlayTransform
)
=
0
;
virtual
EVROverlayError
ShowOverlay
(
VROverlayHandle_t
ulOverlayHandle
)
=
0
;
virtual
EVROverlayError
HideOverlay
(
VROverlayHandle_t
ulOverlayHandle
)
=
0
;
virtual
bool
IsOverlayVisible
(
VROverlayHandle_t
ulOverlayHandle
)
=
0
;
virtual
EVROverlayError
GetTransformForOverlayCoordinates
(
VROverlayHandle_t
ulOverlayHandle
ETrackingUniverseOrigin
eTrackingOrigin
HmdVector2_t
coordinatesInOverlay
HmdMatrix34_t
*
pmatTransform
)
=
0
;
virtual
bool
PollNextOverlayEvent
(
VROverlayHandle_t
ulOverlayHandle
VREvent_t
*
pEvent
uint32_t
uncbVREvent
)
=
0
;
virtual
EVROverlayError
GetOverlayInputMethod
(
VROverlayHandle_t
ulOverlayHandle
VROverlayInputMethod
*
peInputMethod
)
=
0
;
virtual
EVROverlayError
SetOverlayInputMethod
(
VROverlayHandle_t
ulOverlayHandle
VROverlayInputMethod
eInputMethod
)
=
0
;
virtual
EVROverlayError
GetOverlayMouseScale
(
VROverlayHandle_t
ulOverlayHandle
HmdVector2_t
*
pvecMouseScale
)
=
0
;
virtual
EVROverlayError
SetOverlayMouseScale
(
VROverlayHandle_t
ulOverlayHandle
const
HmdVector2_t
*
pvecMouseScale
)
=
0
;
virtual
bool
ComputeOverlayIntersection
(
VROverlayHandle_t
ulOverlayHandle
const
VROverlayIntersectionParams_t
*
pParams
VROverlayIntersectionResults_t
*
pResults
)
=
0
;
virtual
bool
IsHoverTargetOverlay
(
VROverlayHandle_t
ulOverlayHandle
)
=
0
;
virtual
vr
:
:
VROverlayHandle_t
GetGamepadFocusOverlay
(
)
=
0
;
virtual
EVROverlayError
SetGamepadFocusOverlay
(
VROverlayHandle_t
ulNewFocusOverlay
)
=
0
;
virtual
EVROverlayError
SetOverlayNeighbor
(
EOverlayDirection
eDirection
VROverlayHandle_t
ulFrom
VROverlayHandle_t
ulTo
)
=
0
;
virtual
EVROverlayError
MoveGamepadFocusToNeighbor
(
EOverlayDirection
eDirection
VROverlayHandle_t
ulFrom
)
=
0
;
virtual
EVROverlayError
SetOverlayDualAnalogTransform
(
VROverlayHandle_t
ulOverlay
EDualAnalogWhich
eWhich
const
HmdVector2_t
&
vCenter
float
fRadius
)
=
0
;
virtual
EVROverlayError
GetOverlayDualAnalogTransform
(
VROverlayHandle_t
ulOverlay
EDualAnalogWhich
eWhich
HmdVector2_t
*
pvCenter
float
*
pfRadius
)
=
0
;
virtual
EVROverlayError
SetOverlayTexture
(
VROverlayHandle_t
ulOverlayHandle
const
Texture_t
*
pTexture
)
=
0
;
virtual
EVROverlayError
ClearOverlayTexture
(
VROverlayHandle_t
ulOverlayHandle
)
=
0
;
virtual
EVROverlayError
SetOverlayRaw
(
VROverlayHandle_t
ulOverlayHandle
void
*
pvBuffer
uint32_t
unWidth
uint32_t
unHeight
uint32_t
unDepth
)
=
0
;
virtual
EVROverlayError
SetOverlayFromFile
(
VROverlayHandle_t
ulOverlayHandle
const
char
*
pchFilePath
)
=
0
;
virtual
EVROverlayError
GetOverlayTexture
(
VROverlayHandle_t
ulOverlayHandle
void
*
*
pNativeTextureHandle
void
*
pNativeTextureRef
uint32_t
*
pWidth
uint32_t
*
pHeight
uint32_t
*
pNativeFormat
ETextureType
*
pAPIType
EColorSpace
*
pColorSpace
VRTextureBounds_t
*
pTextureBounds
)
=
0
;
virtual
EVROverlayError
ReleaseNativeOverlayHandle
(
VROverlayHandle_t
ulOverlayHandle
void
*
pNativeTextureHandle
)
=
0
;
virtual
EVROverlayError
GetOverlayTextureSize
(
VROverlayHandle_t
ulOverlayHandle
uint32_t
*
pWidth
uint32_t
*
pHeight
)
=
0
;
virtual
EVROverlayError
CreateDashboardOverlay
(
const
char
*
pchOverlayKey
const
char
*
pchOverlayFriendlyName
VROverlayHandle_t
*
pMainHandle
VROverlayHandle_t
*
pThumbnailHandle
)
=
0
;
virtual
bool
IsDashboardVisible
(
)
=
0
;
virtual
bool
IsActiveDashboardOverlay
(
VROverlayHandle_t
ulOverlayHandle
)
=
0
;
virtual
EVROverlayError
SetDashboardOverlaySceneProcess
(
VROverlayHandle_t
ulOverlayHandle
uint32_t
unProcessId
)
=
0
;
virtual
EVROverlayError
GetDashboardOverlaySceneProcess
(
VROverlayHandle_t
ulOverlayHandle
uint32_t
*
punProcessId
)
=
0
;
virtual
void
ShowDashboard
(
const
char
*
pchOverlayToShow
)
=
0
;
virtual
vr
:
:
TrackedDeviceIndex_t
GetPrimaryDashboardDevice
(
)
=
0
;
virtual
EVROverlayError
ShowKeyboard
(
EGamepadTextInputMode
eInputMode
EGamepadTextInputLineMode
eLineInputMode
const
char
*
pchDescription
uint32_t
unCharMax
const
char
*
pchExistingText
bool
bUseMinimalMode
uint64_t
uUserValue
)
=
0
;
virtual
EVROverlayError
ShowKeyboardForOverlay
(
VROverlayHandle_t
ulOverlayHandle
EGamepadTextInputMode
eInputMode
EGamepadTextInputLineMode
eLineInputMode
const
char
*
pchDescription
uint32_t
unCharMax
const
char
*
pchExistingText
bool
bUseMinimalMode
uint64_t
uUserValue
)
=
0
;
virtual
uint32_t
GetKeyboardText
(
VR_OUT_STRING
(
)
char
*
pchText
uint32_t
cchText
)
=
0
;
virtual
void
HideKeyboard
(
)
=
0
;
virtual
void
SetKeyboardTransformAbsolute
(
ETrackingUniverseOrigin
eTrackingOrigin
const
HmdMatrix34_t
*
pmatTrackingOriginToKeyboardTransform
)
=
0
;
virtual
void
SetKeyboardPositionForOverlay
(
VROverlayHandle_t
ulOverlayHandle
HmdRect2_t
avoidRect
)
=
0
;
virtual
EVROverlayError
SetOverlayIntersectionMask
(
VROverlayHandle_t
ulOverlayHandle
VROverlayIntersectionMaskPrimitive_t
*
pMaskPrimitives
uint32_t
unNumMaskPrimitives
uint32_t
unPrimitiveSize
=
sizeof
(
VROverlayIntersectionMaskPrimitive_t
)
)
=
0
;
virtual
EVROverlayError
GetOverlayFlags
(
VROverlayHandle_t
ulOverlayHandle
uint32_t
*
pFlags
)
=
0
;
virtual
VRMessageOverlayResponse
ShowMessageOverlay
(
const
char
*
pchText
const
char
*
pchCaption
const
char
*
pchButton0Text
const
char
*
pchButton1Text
=
nullptr
const
char
*
pchButton2Text
=
nullptr
const
char
*
pchButton3Text
=
nullptr
)
=
0
;
virtual
void
CloseMessageOverlay
(
)
=
0
;
}
;
static
const
char
*
const
IVROverlay_Version
=
"
IVROverlay_018
"
;
}
namespace
vr
{
static
const
char
*
const
k_pch_Controller_Component_GDC2015
=
"
gdc2015
"
;
static
const
char
*
const
k_pch_Controller_Component_Base
=
"
base
"
;
static
const
char
*
const
k_pch_Controller_Component_Tip
=
"
tip
"
;
static
const
char
*
const
k_pch_Controller_Component_HandGrip
=
"
handgrip
"
;
static
const
char
*
const
k_pch_Controller_Component_Status
=
"
status
"
;
#
pragma
pack
(
push
8
)
enum
EVRRenderModelError
{
VRRenderModelError_None
=
0
VRRenderModelError_Loading
=
100
VRRenderModelError_NotSupported
=
200
VRRenderModelError_InvalidArg
=
300
VRRenderModelError_InvalidModel
=
301
VRRenderModelError_NoShapes
=
302
VRRenderModelError_MultipleShapes
=
303
VRRenderModelError_TooManyVertices
=
304
VRRenderModelError_MultipleTextures
=
305
VRRenderModelError_BufferTooSmall
=
306
VRRenderModelError_NotEnoughNormals
=
307
VRRenderModelError_NotEnoughTexCoords
=
308
VRRenderModelError_InvalidTexture
=
400
}
;
typedef
uint32_t
VRComponentProperties
;
enum
EVRComponentProperty
{
VRComponentProperty_IsStatic
=
(
1
<
<
0
)
VRComponentProperty_IsVisible
=
(
1
<
<
1
)
VRComponentProperty_IsTouched
=
(
1
<
<
2
)
VRComponentProperty_IsPressed
=
(
1
<
<
3
)
VRComponentProperty_IsScrolled
=
(
1
<
<
4
)
}
;
struct
RenderModel_ComponentState_t
{
HmdMatrix34_t
mTrackingToComponentRenderModel
;
HmdMatrix34_t
mTrackingToComponentLocal
;
VRComponentProperties
uProperties
;
}
;
struct
RenderModel_Vertex_t
{
HmdVector3_t
vPosition
;
HmdVector3_t
vNormal
;
float
rfTextureCoord
[
2
]
;
}
;
#
if
defined
(
__linux__
)
|
|
defined
(
__APPLE__
)
#
pragma
pack
(
push
4
)
#
endif
struct
RenderModel_TextureMap_t
{
uint16_t
unWidth
unHeight
;
const
uint8_t
*
rubTextureMapData
;
}
;
#
if
defined
(
__linux__
)
|
|
defined
(
__APPLE__
)
#
pragma
pack
(
pop
)
#
endif
typedef
int32_t
TextureID_t
;
const
TextureID_t
INVALID_TEXTURE_ID
=
-
1
;
#
if
defined
(
__linux__
)
|
|
defined
(
__APPLE__
)
#
pragma
pack
(
push
4
)
#
endif
struct
RenderModel_t
{
const
RenderModel_Vertex_t
*
rVertexData
;
uint32_t
unVertexCount
;
const
uint16_t
*
rIndexData
;
uint32_t
unTriangleCount
;
TextureID_t
diffuseTextureId
;
}
;
#
if
defined
(
__linux__
)
|
|
defined
(
__APPLE__
)
#
pragma
pack
(
pop
)
#
endif
struct
RenderModel_ControllerMode_State_t
{
bool
bScrollWheelVisible
;
}
;
#
pragma
pack
(
pop
)
class
IVRRenderModels
{
public
:
virtual
EVRRenderModelError
LoadRenderModel_Async
(
const
char
*
pchRenderModelName
RenderModel_t
*
*
ppRenderModel
)
=
0
;
virtual
void
FreeRenderModel
(
RenderModel_t
*
pRenderModel
)
=
0
;
virtual
EVRRenderModelError
LoadTexture_Async
(
TextureID_t
textureId
RenderModel_TextureMap_t
*
*
ppTexture
)
=
0
;
virtual
void
FreeTexture
(
RenderModel_TextureMap_t
*
pTexture
)
=
0
;
virtual
EVRRenderModelError
LoadTextureD3D11_Async
(
TextureID_t
textureId
void
*
pD3D11Device
void
*
*
ppD3D11Texture2D
)
=
0
;
virtual
EVRRenderModelError
LoadIntoTextureD3D11_Async
(
TextureID_t
textureId
void
*
pDstTexture
)
=
0
;
virtual
void
FreeTextureD3D11
(
void
*
pD3D11Texture2D
)
=
0
;
virtual
uint32_t
GetRenderModelName
(
uint32_t
unRenderModelIndex
VR_OUT_STRING
(
)
char
*
pchRenderModelName
uint32_t
unRenderModelNameLen
)
=
0
;
virtual
uint32_t
GetRenderModelCount
(
)
=
0
;
virtual
uint32_t
GetComponentCount
(
const
char
*
pchRenderModelName
)
=
0
;
virtual
uint32_t
GetComponentName
(
const
char
*
pchRenderModelName
uint32_t
unComponentIndex
VR_OUT_STRING
(
)
char
*
pchComponentName
uint32_t
unComponentNameLen
)
=
0
;
virtual
uint64_t
GetComponentButtonMask
(
const
char
*
pchRenderModelName
const
char
*
pchComponentName
)
=
0
;
virtual
uint32_t
GetComponentRenderModelName
(
const
char
*
pchRenderModelName
const
char
*
pchComponentName
VR_OUT_STRING
(
)
char
*
pchComponentRenderModelName
uint32_t
unComponentRenderModelNameLen
)
=
0
;
virtual
bool
GetComponentState
(
const
char
*
pchRenderModelName
const
char
*
pchComponentName
const
vr
:
:
VRControllerState_t
*
pControllerState
const
RenderModel_ControllerMode_State_t
*
pState
RenderModel_ComponentState_t
*
pComponentState
)
=
0
;
virtual
bool
RenderModelHasComponent
(
const
char
*
pchRenderModelName
const
char
*
pchComponentName
)
=
0
;
virtual
uint32_t
GetRenderModelThumbnailURL
(
const
char
*
pchRenderModelName
VR_OUT_STRING
(
)
char
*
pchThumbnailURL
uint32_t
unThumbnailURLLen
vr
:
:
EVRRenderModelError
*
peError
)
=
0
;
virtual
uint32_t
GetRenderModelOriginalPath
(
const
char
*
pchRenderModelName
VR_OUT_STRING
(
)
char
*
pchOriginalPath
uint32_t
unOriginalPathLen
vr
:
:
EVRRenderModelError
*
peError
)
=
0
;
virtual
const
char
*
GetRenderModelErrorNameFromEnum
(
vr
:
:
EVRRenderModelError
error
)
=
0
;
}
;
static
const
char
*
const
IVRRenderModels_Version
=
"
IVRRenderModels_005
"
;
}
namespace
vr
{
class
IVRExtendedDisplay
{
public
:
virtual
void
GetWindowBounds
(
int32_t
*
pnX
int32_t
*
pnY
uint32_t
*
pnWidth
uint32_t
*
pnHeight
)
=
0
;
virtual
void
GetEyeOutputViewport
(
EVREye
eEye
uint32_t
*
pnX
uint32_t
*
pnY
uint32_t
*
pnWidth
uint32_t
*
pnHeight
)
=
0
;
virtual
void
GetDXGIOutputInfo
(
int32_t
*
pnAdapterIndex
int32_t
*
pnAdapterOutputIndex
)
=
0
;
}
;
static
const
char
*
const
IVRExtendedDisplay_Version
=
"
IVRExtendedDisplay_001
"
;
}
namespace
vr
{
class
IVRTrackedCamera
{
public
:
virtual
const
char
*
GetCameraErrorNameFromEnum
(
vr
:
:
EVRTrackedCameraError
eCameraError
)
=
0
;
virtual
vr
:
:
EVRTrackedCameraError
HasCamera
(
vr
:
:
TrackedDeviceIndex_t
nDeviceIndex
bool
*
pHasCamera
)
=
0
;
virtual
vr
:
:
EVRTrackedCameraError
GetCameraFrameSize
(
vr
:
:
TrackedDeviceIndex_t
nDeviceIndex
vr
:
:
EVRTrackedCameraFrameType
eFrameType
uint32_t
*
pnWidth
uint32_t
*
pnHeight
uint32_t
*
pnFrameBufferSize
)
=
0
;
virtual
vr
:
:
EVRTrackedCameraError
GetCameraIntrinsics
(
vr
:
:
TrackedDeviceIndex_t
nDeviceIndex
vr
:
:
EVRTrackedCameraFrameType
eFrameType
vr
:
:
HmdVector2_t
*
pFocalLength
vr
:
:
HmdVector2_t
*
pCenter
)
=
0
;
virtual
vr
:
:
EVRTrackedCameraError
GetCameraProjection
(
vr
:
:
TrackedDeviceIndex_t
nDeviceIndex
vr
:
:
EVRTrackedCameraFrameType
eFrameType
float
flZNear
float
flZFar
vr
:
:
HmdMatrix44_t
*
pProjection
)
=
0
;
virtual
vr
:
:
EVRTrackedCameraError
AcquireVideoStreamingService
(
vr
:
:
TrackedDeviceIndex_t
nDeviceIndex
vr
:
:
TrackedCameraHandle_t
*
pHandle
)
=
0
;
virtual
vr
:
:
EVRTrackedCameraError
ReleaseVideoStreamingService
(
vr
:
:
TrackedCameraHandle_t
hTrackedCamera
)
=
0
;
virtual
vr
:
:
EVRTrackedCameraError
GetVideoStreamFrameBuffer
(
vr
:
:
TrackedCameraHandle_t
hTrackedCamera
vr
:
:
EVRTrackedCameraFrameType
eFrameType
void
*
pFrameBuffer
uint32_t
nFrameBufferSize
vr
:
:
CameraVideoStreamFrameHeader_t
*
pFrameHeader
uint32_t
nFrameHeaderSize
)
=
0
;
virtual
vr
:
:
EVRTrackedCameraError
GetVideoStreamTextureSize
(
vr
:
:
TrackedDeviceIndex_t
nDeviceIndex
vr
:
:
EVRTrackedCameraFrameType
eFrameType
vr
:
:
VRTextureBounds_t
*
pTextureBounds
uint32_t
*
pnWidth
uint32_t
*
pnHeight
)
=
0
;
virtual
vr
:
:
EVRTrackedCameraError
GetVideoStreamTextureD3D11
(
vr
:
:
TrackedCameraHandle_t
hTrackedCamera
vr
:
:
EVRTrackedCameraFrameType
eFrameType
void
*
pD3D11DeviceOrResource
void
*
*
ppD3D11ShaderResourceView
vr
:
:
CameraVideoStreamFrameHeader_t
*
pFrameHeader
uint32_t
nFrameHeaderSize
)
=
0
;
virtual
vr
:
:
EVRTrackedCameraError
GetVideoStreamTextureGL
(
vr
:
:
TrackedCameraHandle_t
hTrackedCamera
vr
:
:
EVRTrackedCameraFrameType
eFrameType
vr
:
:
glUInt_t
*
pglTextureId
vr
:
:
CameraVideoStreamFrameHeader_t
*
pFrameHeader
uint32_t
nFrameHeaderSize
)
=
0
;
virtual
vr
:
:
EVRTrackedCameraError
ReleaseVideoStreamTextureGL
(
vr
:
:
TrackedCameraHandle_t
hTrackedCamera
vr
:
:
glUInt_t
glTextureId
)
=
0
;
}
;
static
const
char
*
const
IVRTrackedCamera_Version
=
"
IVRTrackedCamera_003
"
;
}
namespace
vr
{
enum
EVRScreenshotError
{
VRScreenshotError_None
=
0
VRScreenshotError_RequestFailed
=
1
VRScreenshotError_IncompatibleVersion
=
100
VRScreenshotError_NotFound
=
101
VRScreenshotError_BufferTooSmall
=
102
VRScreenshotError_ScreenshotAlreadyInProgress
=
108
}
;
class
IVRScreenshots
{
public
:
virtual
vr
:
:
EVRScreenshotError
RequestScreenshot
(
vr
:
:
ScreenshotHandle_t
*
pOutScreenshotHandle
vr
:
:
EVRScreenshotType
type
const
char
*
pchPreviewFilename
const
char
*
pchVRFilename
)
=
0
;
virtual
vr
:
:
EVRScreenshotError
HookScreenshot
(
VR_ARRAY_COUNT
(
numTypes
)
const
vr
:
:
EVRScreenshotType
*
pSupportedTypes
int
numTypes
)
=
0
;
virtual
vr
:
:
EVRScreenshotType
GetScreenshotPropertyType
(
vr
:
:
ScreenshotHandle_t
screenshotHandle
vr
:
:
EVRScreenshotError
*
pError
)
=
0
;
virtual
uint32_t
GetScreenshotPropertyFilename
(
vr
:
:
ScreenshotHandle_t
screenshotHandle
vr
:
:
EVRScreenshotPropertyFilenames
filenameType
VR_OUT_STRING
(
)
char
*
pchFilename
uint32_t
cchFilename
vr
:
:
EVRScreenshotError
*
pError
)
=
0
;
virtual
vr
:
:
EVRScreenshotError
UpdateScreenshotProgress
(
vr
:
:
ScreenshotHandle_t
screenshotHandle
float
flProgress
)
=
0
;
virtual
vr
:
:
EVRScreenshotError
TakeStereoScreenshot
(
vr
:
:
ScreenshotHandle_t
*
pOutScreenshotHandle
const
char
*
pchPreviewFilename
const
char
*
pchVRFilename
)
=
0
;
virtual
vr
:
:
EVRScreenshotError
SubmitScreenshot
(
vr
:
:
ScreenshotHandle_t
screenshotHandle
vr
:
:
EVRScreenshotType
type
const
char
*
pchSourcePreviewFilename
const
char
*
pchSourceVRFilename
)
=
0
;
}
;
static
const
char
*
const
IVRScreenshots_Version
=
"
IVRScreenshots_001
"
;
}
namespace
vr
{
class
IVRResources
{
public
:
virtual
uint32_t
LoadSharedResource
(
const
char
*
pchResourceName
char
*
pchBuffer
uint32_t
unBufferLen
)
=
0
;
virtual
uint32_t
GetResourceFullPath
(
const
char
*
pchResourceName
const
char
*
pchResourceTypeDirectory
VR_OUT_STRING
(
)
char
*
pchPathBuffer
uint32_t
unBufferLen
)
=
0
;
}
;
static
const
char
*
const
IVRResources_Version
=
"
IVRResources_001
"
;
}
namespace
vr
{
class
IVRDriverManager
{
public
:
virtual
uint32_t
GetDriverCount
(
)
const
=
0
;
virtual
uint32_t
GetDriverName
(
vr
:
:
DriverId_t
nDriver
VR_OUT_STRING
(
)
char
*
pchValue
uint32_t
unBufferSize
)
=
0
;
virtual
DriverHandle_t
GetDriverHandle
(
const
char
*
pchDriverName
)
=
0
;
}
;
static
const
char
*
const
IVRDriverManager_Version
=
"
IVRDriverManager_001
"
;
}
#
endif
namespace
vr
{
inline
IVRSystem
*
VR_Init
(
EVRInitError
*
peError
EVRApplicationType
eApplicationType
const
char
*
pStartupInfo
=
nullptr
)
;
inline
void
VR_Shutdown
(
)
;
VR_INTERFACE
bool
VR_CALLTYPE
VR_IsHmdPresent
(
)
;
VR_INTERFACE
bool
VR_CALLTYPE
VR_IsRuntimeInstalled
(
)
;
VR_INTERFACE
const
char
*
VR_CALLTYPE
VR_RuntimePath
(
)
;
VR_INTERFACE
const
char
*
VR_CALLTYPE
VR_GetVRInitErrorAsSymbol
(
EVRInitError
error
)
;
VR_INTERFACE
const
char
*
VR_CALLTYPE
VR_GetVRInitErrorAsEnglishDescription
(
EVRInitError
error
)
;
VR_INTERFACE
void
*
VR_CALLTYPE
VR_GetGenericInterface
(
const
char
*
pchInterfaceVersion
EVRInitError
*
peError
)
;
VR_INTERFACE
bool
VR_CALLTYPE
VR_IsInterfaceVersionValid
(
const
char
*
pchInterfaceVersion
)
;
VR_INTERFACE
uint32_t
VR_CALLTYPE
VR_GetInitToken
(
)
;
typedef
EVRInitError
HmdError
;
typedef
EVREye
Hmd_Eye
;
typedef
EColorSpace
ColorSpace
;
typedef
ETrackingResult
HmdTrackingResult
;
typedef
ETrackedDeviceClass
TrackedDeviceClass
;
typedef
ETrackingUniverseOrigin
TrackingUniverseOrigin
;
typedef
ETrackedDeviceProperty
TrackedDeviceProperty
;
typedef
ETrackedPropertyError
TrackedPropertyError
;
typedef
EVRSubmitFlags
VRSubmitFlags_t
;
typedef
EVRState
VRState_t
;
typedef
ECollisionBoundsStyle
CollisionBoundsStyle_t
;
typedef
EVROverlayError
VROverlayError
;
typedef
EVRFirmwareError
VRFirmwareError
;
typedef
EVRCompositorError
VRCompositorError
;
typedef
EVRScreenshotError
VRScreenshotsError
;
inline
uint32_t
&
VRToken
(
)
{
static
uint32_t
token
;
return
token
;
}
class
COpenVRContext
{
public
:
COpenVRContext
(
)
{
Clear
(
)
;
}
void
Clear
(
)
;
inline
void
CheckClear
(
)
{
if
(
VRToken
(
)
!
=
VR_GetInitToken
(
)
)
{
Clear
(
)
;
VRToken
(
)
=
VR_GetInitToken
(
)
;
}
}
IVRSystem
*
VRSystem
(
)
{
CheckClear
(
)
;
if
(
m_pVRSystem
=
=
nullptr
)
{
EVRInitError
eError
;
m_pVRSystem
=
(
IVRSystem
*
)
VR_GetGenericInterface
(
IVRSystem_Version
&
eError
)
;
}
return
m_pVRSystem
;
}
IVRChaperone
*
VRChaperone
(
)
{
CheckClear
(
)
;
if
(
m_pVRChaperone
=
=
nullptr
)
{
EVRInitError
eError
;
m_pVRChaperone
=
(
IVRChaperone
*
)
VR_GetGenericInterface
(
IVRChaperone_Version
&
eError
)
;
}
return
m_pVRChaperone
;
}
IVRChaperoneSetup
*
VRChaperoneSetup
(
)
{
CheckClear
(
)
;
if
(
m_pVRChaperoneSetup
=
=
nullptr
)
{
EVRInitError
eError
;
m_pVRChaperoneSetup
=
(
IVRChaperoneSetup
*
)
VR_GetGenericInterface
(
IVRChaperoneSetup_Version
&
eError
)
;
}
return
m_pVRChaperoneSetup
;
}
IVRCompositor
*
VRCompositor
(
)
{
CheckClear
(
)
;
if
(
m_pVRCompositor
=
=
nullptr
)
{
EVRInitError
eError
;
m_pVRCompositor
=
(
IVRCompositor
*
)
VR_GetGenericInterface
(
IVRCompositor_Version
&
eError
)
;
}
return
m_pVRCompositor
;
}
IVROverlay
*
VROverlay
(
)
{
CheckClear
(
)
;
if
(
m_pVROverlay
=
=
nullptr
)
{
EVRInitError
eError
;
m_pVROverlay
=
(
IVROverlay
*
)
VR_GetGenericInterface
(
IVROverlay_Version
&
eError
)
;
}
return
m_pVROverlay
;
}
IVRResources
*
VRResources
(
)
{
CheckClear
(
)
;
if
(
m_pVRResources
=
=
nullptr
)
{
EVRInitError
eError
;
m_pVRResources
=
(
IVRResources
*
)
VR_GetGenericInterface
(
IVRResources_Version
&
eError
)
;
}
return
m_pVRResources
;
}
IVRScreenshots
*
VRScreenshots
(
)
{
CheckClear
(
)
;
if
(
m_pVRScreenshots
=
=
nullptr
)
{
EVRInitError
eError
;
m_pVRScreenshots
=
(
IVRScreenshots
*
)
VR_GetGenericInterface
(
IVRScreenshots_Version
&
eError
)
;
}
return
m_pVRScreenshots
;
}
IVRRenderModels
*
VRRenderModels
(
)
{
CheckClear
(
)
;
if
(
m_pVRRenderModels
=
=
nullptr
)
{
EVRInitError
eError
;
m_pVRRenderModels
=
(
IVRRenderModels
*
)
VR_GetGenericInterface
(
IVRRenderModels_Version
&
eError
)
;
}
return
m_pVRRenderModels
;
}
IVRExtendedDisplay
*
VRExtendedDisplay
(
)
{
CheckClear
(
)
;
if
(
m_pVRExtendedDisplay
=
=
nullptr
)
{
EVRInitError
eError
;
m_pVRExtendedDisplay
=
(
IVRExtendedDisplay
*
)
VR_GetGenericInterface
(
IVRExtendedDisplay_Version
&
eError
)
;
}
return
m_pVRExtendedDisplay
;
}
IVRSettings
*
VRSettings
(
)
{
CheckClear
(
)
;
if
(
m_pVRSettings
=
=
nullptr
)
{
EVRInitError
eError
;
m_pVRSettings
=
(
IVRSettings
*
)
VR_GetGenericInterface
(
IVRSettings_Version
&
eError
)
;
}
return
m_pVRSettings
;
}
IVRApplications
*
VRApplications
(
)
{
CheckClear
(
)
;
if
(
m_pVRApplications
=
=
nullptr
)
{
EVRInitError
eError
;
m_pVRApplications
=
(
IVRApplications
*
)
VR_GetGenericInterface
(
IVRApplications_Version
&
eError
)
;
}
return
m_pVRApplications
;
}
IVRTrackedCamera
*
VRTrackedCamera
(
)
{
CheckClear
(
)
;
if
(
m_pVRTrackedCamera
=
=
nullptr
)
{
EVRInitError
eError
;
m_pVRTrackedCamera
=
(
IVRTrackedCamera
*
)
VR_GetGenericInterface
(
IVRTrackedCamera_Version
&
eError
)
;
}
return
m_pVRTrackedCamera
;
}
IVRDriverManager
*
VRDriverManager
(
)
{
CheckClear
(
)
;
if
(
!
m_pVRDriverManager
)
{
EVRInitError
eError
;
m_pVRDriverManager
=
(
IVRDriverManager
*
)
VR_GetGenericInterface
(
IVRDriverManager_Version
&
eError
)
;
}
return
m_pVRDriverManager
;
}
private
:
IVRSystem
*
m_pVRSystem
;
IVRChaperone
*
m_pVRChaperone
;
IVRChaperoneSetup
*
m_pVRChaperoneSetup
;
IVRCompositor
*
m_pVRCompositor
;
IVROverlay
*
m_pVROverlay
;
IVRResources
*
m_pVRResources
;
IVRRenderModels
*
m_pVRRenderModels
;
IVRExtendedDisplay
*
m_pVRExtendedDisplay
;
IVRSettings
*
m_pVRSettings
;
IVRApplications
*
m_pVRApplications
;
IVRTrackedCamera
*
m_pVRTrackedCamera
;
IVRScreenshots
*
m_pVRScreenshots
;
IVRDriverManager
*
m_pVRDriverManager
;
}
;
inline
COpenVRContext
&
OpenVRInternal_ModuleContext
(
)
{
static
void
*
ctx
[
sizeof
(
COpenVRContext
)
/
sizeof
(
void
*
)
]
;
return
*
(
COpenVRContext
*
)
ctx
;
}
inline
IVRSystem
*
VR_CALLTYPE
VRSystem
(
)
{
return
OpenVRInternal_ModuleContext
(
)
.
VRSystem
(
)
;
}
inline
IVRChaperone
*
VR_CALLTYPE
VRChaperone
(
)
{
return
OpenVRInternal_ModuleContext
(
)
.
VRChaperone
(
)
;
}
inline
IVRChaperoneSetup
*
VR_CALLTYPE
VRChaperoneSetup
(
)
{
return
OpenVRInternal_ModuleContext
(
)
.
VRChaperoneSetup
(
)
;
}
inline
IVRCompositor
*
VR_CALLTYPE
VRCompositor
(
)
{
return
OpenVRInternal_ModuleContext
(
)
.
VRCompositor
(
)
;
}
inline
IVROverlay
*
VR_CALLTYPE
VROverlay
(
)
{
return
OpenVRInternal_ModuleContext
(
)
.
VROverlay
(
)
;
}
inline
IVRScreenshots
*
VR_CALLTYPE
VRScreenshots
(
)
{
return
OpenVRInternal_ModuleContext
(
)
.
VRScreenshots
(
)
;
}
inline
IVRRenderModels
*
VR_CALLTYPE
VRRenderModels
(
)
{
return
OpenVRInternal_ModuleContext
(
)
.
VRRenderModels
(
)
;
}
inline
IVRApplications
*
VR_CALLTYPE
VRApplications
(
)
{
return
OpenVRInternal_ModuleContext
(
)
.
VRApplications
(
)
;
}
inline
IVRSettings
*
VR_CALLTYPE
VRSettings
(
)
{
return
OpenVRInternal_ModuleContext
(
)
.
VRSettings
(
)
;
}
inline
IVRResources
*
VR_CALLTYPE
VRResources
(
)
{
return
OpenVRInternal_ModuleContext
(
)
.
VRResources
(
)
;
}
inline
IVRExtendedDisplay
*
VR_CALLTYPE
VRExtendedDisplay
(
)
{
return
OpenVRInternal_ModuleContext
(
)
.
VRExtendedDisplay
(
)
;
}
inline
IVRTrackedCamera
*
VR_CALLTYPE
VRTrackedCamera
(
)
{
return
OpenVRInternal_ModuleContext
(
)
.
VRTrackedCamera
(
)
;
}
inline
IVRDriverManager
*
VR_CALLTYPE
VRDriverManager
(
)
{
return
OpenVRInternal_ModuleContext
(
)
.
VRDriverManager
(
)
;
}
inline
void
COpenVRContext
:
:
Clear
(
)
{
m_pVRSystem
=
nullptr
;
m_pVRChaperone
=
nullptr
;
m_pVRChaperoneSetup
=
nullptr
;
m_pVRCompositor
=
nullptr
;
m_pVROverlay
=
nullptr
;
m_pVRRenderModels
=
nullptr
;
m_pVRExtendedDisplay
=
nullptr
;
m_pVRSettings
=
nullptr
;
m_pVRApplications
=
nullptr
;
m_pVRTrackedCamera
=
nullptr
;
m_pVRResources
=
nullptr
;
m_pVRScreenshots
=
nullptr
;
m_pVRDriverManager
=
nullptr
;
}
VR_INTERFACE
uint32_t
VR_CALLTYPE
VR_InitInternal2
(
EVRInitError
*
peError
EVRApplicationType
eApplicationType
const
char
*
pStartupInfo
)
;
VR_INTERFACE
void
VR_CALLTYPE
VR_ShutdownInternal
(
)
;
inline
IVRSystem
*
VR_Init
(
EVRInitError
*
peError
EVRApplicationType
eApplicationType
const
char
*
pStartupInfo
)
{
IVRSystem
*
pVRSystem
=
nullptr
;
EVRInitError
eError
;
VRToken
(
)
=
VR_InitInternal2
(
&
eError
eApplicationType
pStartupInfo
)
;
COpenVRContext
&
ctx
=
OpenVRInternal_ModuleContext
(
)
;
ctx
.
Clear
(
)
;
if
(
eError
=
=
VRInitError_None
)
{
if
(
VR_IsInterfaceVersionValid
(
IVRSystem_Version
)
)
{
pVRSystem
=
VRSystem
(
)
;
}
else
{
VR_ShutdownInternal
(
)
;
eError
=
VRInitError_Init_InterfaceNotFound
;
}
}
if
(
peError
)
*
peError
=
eError
;
return
pVRSystem
;
}
inline
void
VR_Shutdown
(
)
{
VR_ShutdownInternal
(
)
;
}
}
