#
include
"
VRService
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
.
.
/
gfxVRMutex
.
h
"
#
include
"
base
/
thread
.
h
"
#
include
<
cstring
>
#
if
defined
(
XP_WIN
)
#
include
"
OculusSession
.
h
"
#
endif
#
if
defined
(
XP_WIN
)
|
|
defined
(
XP_MACOSX
)
|
|
\
(
defined
(
XP_LINUX
)
&
&
!
defined
(
MOZ_WIDGET_ANDROID
)
)
#
include
"
OpenVRSession
.
h
"
#
endif
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
#
include
"
OSVRSession
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
std
;
namespace
{
int64_t
FrameIDFromBrowserState
(
const
mozilla
:
:
gfx
:
:
VRBrowserState
&
aState
)
{
for
(
const
auto
&
layer
:
aState
.
layerState
)
{
if
(
layer
.
type
=
=
VRLayerType
:
:
LayerType_Stereo_Immersive
)
{
return
layer
.
layer_stereo_immersive
.
frameId
;
}
}
return
0
;
}
bool
IsImmersiveContentActive
(
const
mozilla
:
:
gfx
:
:
VRBrowserState
&
aState
)
{
for
(
const
auto
&
layer
:
aState
.
layerState
)
{
if
(
layer
.
type
=
=
VRLayerType
:
:
LayerType_Stereo_Immersive
)
{
return
true
;
}
}
return
false
;
}
}
already_AddRefed
<
VRService
>
VRService
:
:
Create
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
gfxPrefs
:
:
VRServiceEnabled
(
)
)
{
return
nullptr
;
}
RefPtr
<
VRService
>
service
=
new
VRService
(
)
;
return
service
.
forget
(
)
;
}
VRService
:
:
VRService
(
)
:
mSystemState
{
}
mBrowserState
{
}
mBrowserGeneration
(
0
)
mServiceThread
(
nullptr
)
mShutdownRequested
(
false
)
mAPIShmem
(
nullptr
)
mTargetShmemFile
(
0
)
mLastHapticState
{
}
mFrameStartTime
{
}
#
if
defined
(
XP_WIN
)
mMutex
(
NULL
)
#
endif
mVRProcessEnabled
(
gfxPrefs
:
:
VRProcessEnabled
(
)
)
{
if
(
!
mVRProcessEnabled
)
{
mAPIShmem
=
new
VRExternalShmem
(
)
;
memset
(
mAPIShmem
0
sizeof
(
VRExternalShmem
)
)
;
}
}
VRService
:
:
~
VRService
(
)
{
Stop
(
)
;
if
(
!
mVRProcessEnabled
&
&
mAPIShmem
)
{
delete
mAPIShmem
;
mAPIShmem
=
nullptr
;
}
}
void
VRService
:
:
Refresh
(
)
{
if
(
!
mAPIShmem
)
{
return
;
}
if
(
mAPIShmem
-
>
state
.
displayState
.
shutdown
)
{
Stop
(
)
;
}
}
void
VRService
:
:
Start
(
)
{
if
(
!
mServiceThread
)
{
memset
(
&
mSystemState
0
sizeof
(
mSystemState
)
)
;
PushState
(
mSystemState
)
;
mServiceThread
=
new
base
:
:
Thread
(
"
VRService
"
)
;
base
:
:
Thread
:
:
Options
options
;
options
.
transient_hang_timeout
=
128
;
options
.
permanent_hang_timeout
=
2048
;
if
(
!
mServiceThread
-
>
StartWithOptions
(
options
)
)
{
mServiceThread
-
>
Stop
(
)
;
delete
mServiceThread
;
mServiceThread
=
nullptr
;
return
;
}
mServiceThread
-
>
message_loop
(
)
-
>
PostTask
(
NewRunnableMethod
(
"
gfx
:
:
VRService
:
:
ServiceInitialize
"
this
&
VRService
:
:
ServiceInitialize
)
)
;
}
}
void
VRService
:
:
Stop
(
)
{
if
(
mServiceThread
)
{
mShutdownRequested
=
true
;
mServiceThread
-
>
Stop
(
)
;
delete
mServiceThread
;
mServiceThread
=
nullptr
;
}
if
(
mTargetShmemFile
)
{
#
if
defined
(
XP_WIN
)
CloseHandle
(
mTargetShmemFile
)
;
#
endif
mTargetShmemFile
=
0
;
}
if
(
mVRProcessEnabled
&
&
mAPIShmem
)
{
#
if
defined
(
XP_WIN
)
UnmapViewOfFile
(
(
void
*
)
mAPIShmem
)
;
#
endif
mAPIShmem
=
nullptr
;
}
#
if
defined
(
XP_WIN
)
if
(
mMutex
)
{
CloseHandle
(
mMutex
)
;
}
#
endif
mSession
=
nullptr
;
}
bool
VRService
:
:
InitShmem
(
)
{
#
if
defined
(
XP_WIN
)
if
(
!
mMutex
)
{
mMutex
=
OpenMutex
(
MUTEX_ALL_ACCESS
false
TEXT
(
"
mozilla
:
:
vr
:
:
ShmemMutex
"
)
)
;
if
(
mMutex
=
=
NULL
)
{
nsAutoCString
msg
(
"
VRService
OpenMutex
error
\
"
%
lu
\
"
.
"
GetLastError
(
)
)
;
NS_WARNING
(
msg
.
get
(
)
)
;
MOZ_ASSERT
(
false
)
;
return
false
;
}
}
#
endif
if
(
!
mVRProcessEnabled
)
{
return
true
;
}
#
if
defined
(
XP_WIN
)
const
char
*
kShmemName
=
"
moz
.
gecko
.
vr_ext
.
0
.
0
.
1
"
;
base
:
:
ProcessHandle
targetHandle
=
0
;
targetHandle
=
OpenFileMappingA
(
FILE_MAP_ALL_ACCESS
FALSE
kShmemName
)
;
MOZ_ASSERT
(
GetLastError
(
)
=
=
0
)
;
LARGE_INTEGER
length
;
length
.
QuadPart
=
sizeof
(
VRExternalShmem
)
;
mAPIShmem
=
(
VRExternalShmem
*
)
MapViewOfFile
(
reinterpret_cast
<
base
:
:
ProcessHandle
>
(
targetHandle
)
FILE_MAP_ALL_ACCESS
0
0
length
.
QuadPart
)
;
MOZ_ASSERT
(
GetLastError
(
)
=
=
0
)
;
mTargetShmemFile
=
targetHandle
;
if
(
!
mAPIShmem
)
{
MOZ_ASSERT
(
mAPIShmem
)
;
return
false
;
}
#
else
#
endif
return
true
;
}
bool
VRService
:
:
IsInServiceThread
(
)
{
return
(
mServiceThread
!
=
nullptr
)
&
&
mServiceThread
-
>
thread_id
(
)
=
=
PlatformThread
:
:
CurrentId
(
)
;
}
void
VRService
:
:
ServiceInitialize
(
)
{
MOZ_ASSERT
(
IsInServiceThread
(
)
)
;
if
(
!
InitShmem
(
)
)
{
return
;
}
mShutdownRequested
=
false
;
memset
(
&
mBrowserState
0
sizeof
(
mBrowserState
)
)
;
UniquePtr
<
VRSession
>
session
;
#
if
defined
(
XP_WIN
)
session
=
MakeUnique
<
OculusSession
>
(
)
;
if
(
!
session
-
>
Initialize
(
mSystemState
)
)
{
session
=
nullptr
;
}
#
endif
#
if
defined
(
XP_WIN
)
|
|
defined
(
XP_MACOSX
)
|
|
\
(
defined
(
XP_LINUX
)
&
&
!
defined
(
MOZ_WIDGET_ANDROID
)
)
if
(
!
session
)
{
session
=
MakeUnique
<
OpenVRSession
>
(
)
;
if
(
!
session
-
>
Initialize
(
mSystemState
)
)
{
session
=
nullptr
;
}
}
#
endif
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
if
(
!
session
)
{
session
=
MakeUnique
<
OSVRSession
>
(
)
;
if
(
!
session
-
>
Initialize
(
mSystemState
)
)
{
session
=
nullptr
;
}
}
#
endif
if
(
session
)
{
mSession
=
std
:
:
move
(
session
)
;
mSystemState
.
enumerationCompleted
=
true
;
PushState
(
mSystemState
)
;
MessageLoop
:
:
current
(
)
-
>
PostTask
(
NewRunnableMethod
(
"
gfx
:
:
VRService
:
:
ServiceWaitForImmersive
"
this
&
VRService
:
:
ServiceWaitForImmersive
)
)
;
}
else
{
memset
(
&
mSystemState
0
sizeof
(
mSystemState
)
)
;
mSystemState
.
enumerationCompleted
=
true
;
mSystemState
.
displayState
.
minRestartInterval
=
gfxPrefs
:
:
VRExternalNotDetectedTimeout
(
)
;
mSystemState
.
displayState
.
shutdown
=
true
;
PushState
(
mSystemState
)
;
}
}
void
VRService
:
:
ServiceShutdown
(
)
{
MOZ_ASSERT
(
IsInServiceThread
(
)
)
;
memset
(
&
mSystemState
0
sizeof
(
mSystemState
)
)
;
mSystemState
.
enumerationCompleted
=
true
;
mSystemState
.
displayState
.
shutdown
=
true
;
if
(
mSession
&
&
mSession
-
>
ShouldQuit
(
)
)
{
mSystemState
.
displayState
.
minRestartInterval
=
gfxPrefs
:
:
VRExternalQuitTimeout
(
)
;
}
PushState
(
mSystemState
)
;
mSession
=
nullptr
;
}
void
VRService
:
:
ServiceWaitForImmersive
(
)
{
MOZ_ASSERT
(
IsInServiceThread
(
)
)
;
MOZ_ASSERT
(
mSession
)
;
mSession
-
>
ProcessEvents
(
mSystemState
)
;
PushState
(
mSystemState
)
;
PullState
(
mBrowserState
)
;
if
(
mSession
-
>
ShouldQuit
(
)
|
|
mShutdownRequested
)
{
MessageLoop
:
:
current
(
)
-
>
PostTask
(
NewRunnableMethod
(
"
gfx
:
:
VRService
:
:
ServiceShutdown
"
this
&
VRService
:
:
ServiceShutdown
)
)
;
}
else
if
(
IsImmersiveContentActive
(
mBrowserState
)
)
{
mSession
-
>
StartPresentation
(
)
;
mSession
-
>
StartFrame
(
mSystemState
)
;
PushState
(
mSystemState
)
;
MessageLoop
:
:
current
(
)
-
>
PostTask
(
NewRunnableMethod
(
"
gfx
:
:
VRService
:
:
ServiceImmersiveMode
"
this
&
VRService
:
:
ServiceImmersiveMode
)
)
;
}
else
{
MessageLoop
:
:
current
(
)
-
>
PostTask
(
NewRunnableMethod
(
"
gfx
:
:
VRService
:
:
ServiceWaitForImmersive
"
this
&
VRService
:
:
ServiceWaitForImmersive
)
)
;
}
}
void
VRService
:
:
ServiceImmersiveMode
(
)
{
MOZ_ASSERT
(
IsInServiceThread
(
)
)
;
MOZ_ASSERT
(
mSession
)
;
mSession
-
>
ProcessEvents
(
mSystemState
)
;
UpdateHaptics
(
)
;
PushState
(
mSystemState
)
;
PullState
(
mBrowserState
)
;
if
(
mSession
-
>
ShouldQuit
(
)
|
|
mShutdownRequested
)
{
MessageLoop
:
:
current
(
)
-
>
PostTask
(
NewRunnableMethod
(
"
gfx
:
:
VRService
:
:
ServiceShutdown
"
this
&
VRService
:
:
ServiceShutdown
)
)
;
return
;
}
if
(
!
IsImmersiveContentActive
(
mBrowserState
)
)
{
mSession
-
>
StopAllHaptics
(
)
;
mSession
-
>
StopPresentation
(
)
;
MessageLoop
:
:
current
(
)
-
>
PostTask
(
NewRunnableMethod
(
"
gfx
:
:
VRService
:
:
ServiceWaitForImmersive
"
this
&
VRService
:
:
ServiceWaitForImmersive
)
)
;
return
;
}
uint64_t
newFrameId
=
FrameIDFromBrowserState
(
mBrowserState
)
;
if
(
newFrameId
!
=
mSystemState
.
displayState
.
lastSubmittedFrameId
)
{
bool
success
=
false
;
for
(
const
auto
&
layer
:
mBrowserState
.
layerState
)
{
if
(
layer
.
type
=
=
VRLayerType
:
:
LayerType_Stereo_Immersive
)
{
success
=
mSession
-
>
SubmitFrame
(
layer
.
layer_stereo_immersive
)
;
break
;
}
}
mSystemState
.
displayState
.
lastSubmittedFrameId
=
newFrameId
;
mSystemState
.
displayState
.
lastSubmittedFrameSuccessful
=
success
;
mSession
-
>
StartFrame
(
mSystemState
)
;
mSystemState
.
sensorState
.
inputFrameID
+
+
;
size_t
historyIndex
=
mSystemState
.
sensorState
.
inputFrameID
%
ArrayLength
(
mFrameStartTime
)
;
mFrameStartTime
[
historyIndex
]
=
TimeStamp
:
:
Now
(
)
;
PushState
(
mSystemState
)
;
}
MessageLoop
:
:
current
(
)
-
>
PostTask
(
NewRunnableMethod
(
"
gfx
:
:
VRService
:
:
ServiceImmersiveMode
"
this
&
VRService
:
:
ServiceImmersiveMode
)
)
;
}
void
VRService
:
:
UpdateHaptics
(
)
{
MOZ_ASSERT
(
IsInServiceThread
(
)
)
;
MOZ_ASSERT
(
mSession
)
;
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
mBrowserState
.
hapticState
)
;
i
+
+
)
{
VRHapticState
&
state
=
mBrowserState
.
hapticState
[
i
]
;
VRHapticState
&
lastState
=
mLastHapticState
[
i
]
;
if
(
memcmp
(
&
state
&
lastState
sizeof
(
VRHapticState
)
)
=
=
0
)
{
continue
;
}
if
(
state
.
inputFrameID
=
=
0
)
{
mSession
-
>
StopVibrateHaptic
(
state
.
controllerIndex
)
;
}
else
{
TimeStamp
now
;
if
(
now
.
IsNull
(
)
)
{
now
=
TimeStamp
:
:
Now
(
)
;
}
size_t
historyIndex
=
state
.
inputFrameID
%
ArrayLength
(
mFrameStartTime
)
;
float
startOffset
=
(
float
)
(
now
-
mFrameStartTime
[
historyIndex
]
)
.
ToSeconds
(
)
;
mSession
-
>
VibrateHaptic
(
state
.
controllerIndex
state
.
hapticIndex
state
.
pulseIntensity
state
.
pulseDuration
+
state
.
pulseStart
-
startOffset
)
;
}
memcpy
(
&
lastState
&
state
sizeof
(
VRHapticState
)
)
;
}
}
void
VRService
:
:
PushState
(
const
mozilla
:
:
gfx
:
:
VRSystemState
&
aState
)
{
if
(
!
mAPIShmem
)
{
return
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
if
(
pthread_mutex_lock
(
(
pthread_mutex_t
*
)
&
(
mExternalShmem
-
>
systemMutex
)
)
=
=
0
)
{
memcpy
(
(
void
*
)
&
mAPIShmem
-
>
state
&
aState
sizeof
(
VRSystemState
)
)
;
pthread_mutex_unlock
(
(
pthread_mutex_t
*
)
&
(
mExternalShmem
-
>
systemMutex
)
)
;
}
#
else
bool
state
=
true
;
#
if
defined
(
XP_WIN
)
WaitForMutex
lock
(
mMutex
)
;
state
=
lock
.
GetStatus
(
)
;
#
endif
if
(
state
)
{
mAPIShmem
-
>
generationA
+
+
;
memcpy
(
(
void
*
)
&
mAPIShmem
-
>
state
&
aState
sizeof
(
VRSystemState
)
)
;
mAPIShmem
-
>
generationB
+
+
;
}
#
endif
}
void
VRService
:
:
PullState
(
mozilla
:
:
gfx
:
:
VRBrowserState
&
aState
)
{
if
(
!
mAPIShmem
)
{
return
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
if
(
pthread_mutex_lock
(
(
pthread_mutex_t
*
)
&
(
mExternalShmem
-
>
geckoMutex
)
)
=
=
0
)
{
memcpy
(
&
aState
&
tmp
.
geckoState
sizeof
(
VRBrowserState
)
)
;
pthread_mutex_unlock
(
(
pthread_mutex_t
*
)
&
(
mExternalShmem
-
>
geckoMutex
)
)
;
}
#
else
bool
status
=
true
;
#
if
defined
(
XP_WIN
)
WaitForMutex
lock
(
mMutex
)
;
status
=
lock
.
GetStatus
(
)
;
#
endif
if
(
status
)
{
VRExternalShmem
tmp
;
if
(
mAPIShmem
-
>
geckoGenerationA
!
=
mBrowserGeneration
)
{
memcpy
(
&
tmp
mAPIShmem
sizeof
(
VRExternalShmem
)
)
;
if
(
tmp
.
geckoGenerationA
=
=
tmp
.
geckoGenerationB
&
&
tmp
.
geckoGenerationA
!
=
0
&
&
tmp
.
geckoGenerationA
!
=
-
1
)
{
memcpy
(
&
aState
&
tmp
.
geckoState
sizeof
(
VRBrowserState
)
)
;
mBrowserGeneration
=
tmp
.
geckoGenerationA
;
}
}
}
#
endif
}
VRExternalShmem
*
VRService
:
:
GetAPIShmem
(
)
{
return
mAPIShmem
;
}
