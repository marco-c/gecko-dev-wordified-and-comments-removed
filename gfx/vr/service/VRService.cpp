#
include
"
VRService
.
h
"
#
include
<
cstring
>
#
include
"
.
.
/
VRShMem
.
h
"
#
include
"
.
.
/
gfxVRMutex
.
h
"
#
include
"
PuppetSession
.
h
"
#
include
"
mozilla
/
BackgroundHangMonitor
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
nsThread
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
OculusSession
.
h
"
#
endif
#
if
defined
(
XP_WIN
)
|
|
defined
(
XP_MACOSX
)
|
|
\
(
defined
(
XP_LINUX
)
&
&
!
defined
(
MOZ_WIDGET_ANDROID
)
)
#
include
"
OpenVRSession
.
h
"
#
endif
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
#
include
"
OSVRSession
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
namespace
{
int64_t
FrameIDFromBrowserState
(
const
mozilla
:
:
gfx
:
:
VRBrowserState
&
aState
)
{
for
(
const
auto
&
layer
:
aState
.
layerState
)
{
if
(
layer
.
type
=
=
VRLayerType
:
:
LayerType_Stereo_Immersive
)
{
return
layer
.
layer_stereo_immersive
.
frameId
;
}
}
return
0
;
}
bool
IsImmersiveContentActive
(
const
mozilla
:
:
gfx
:
:
VRBrowserState
&
aState
)
{
for
(
const
auto
&
layer
:
aState
.
layerState
)
{
if
(
layer
.
type
=
=
VRLayerType
:
:
LayerType_Stereo_Immersive
)
{
return
true
;
}
}
return
false
;
}
}
already_AddRefed
<
VRService
>
VRService
:
:
Create
(
volatile
VRExternalShmem
*
aShmem
)
{
RefPtr
<
VRService
>
service
=
new
VRService
(
aShmem
)
;
return
service
.
forget
(
)
;
}
VRService
:
:
VRService
(
volatile
VRExternalShmem
*
aShmem
)
:
mSystemState
{
}
mBrowserState
{
}
mShutdownRequested
(
false
)
mLastHapticState
{
}
mFrameStartTime
{
}
{
mShmem
=
new
VRShMem
(
aShmem
aShmem
=
=
nullptr
)
;
}
VRService
:
:
~
VRService
(
)
{
StopInternal
(
true
)
;
}
void
VRService
:
:
Refresh
(
)
{
if
(
mShmem
!
=
nullptr
&
&
mShmem
-
>
IsDisplayStateShutdown
(
)
)
{
Stop
(
)
;
}
}
void
VRService
:
:
Start
(
)
{
if
(
!
mServiceThread
)
{
memset
(
&
mSystemState
0
sizeof
(
mSystemState
)
)
;
PushState
(
mSystemState
)
;
RefPtr
<
VRService
>
self
=
this
;
nsCOMPtr
<
nsIThread
>
thread
;
nsresult
rv
=
NS_NewNamedThread
(
"
VRService
"
getter_AddRefs
(
thread
)
NS_NewRunnableFunction
(
"
VRService
:
:
ServiceThreadStartup
"
[
self
]
(
)
{
self
-
>
mBackgroundHangMonitor
=
MakeUnique
<
mozilla
:
:
BackgroundHangMonitor
>
(
"
VRService
"
128
2048
)
;
static_cast
<
nsThread
*
>
(
NS_GetCurrentThread
(
)
)
-
>
SetUseHangMonitor
(
true
)
;
}
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
thread
.
swap
(
mServiceThread
)
;
MOZ_ALWAYS_SUCCEEDS
(
mServiceThread
-
>
Dispatch
(
NewRunnableMethod
(
"
gfx
:
:
VRService
:
:
ServiceInitialize
"
this
&
VRService
:
:
ServiceInitialize
)
)
)
;
}
}
void
VRService
:
:
Stop
(
)
{
StopInternal
(
false
)
;
}
void
VRService
:
:
StopInternal
(
bool
aFromDtor
)
{
if
(
mServiceThread
)
{
mServiceThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
VRService
:
:
StopInternal
"
[
self
=
RefPtr
<
VRService
>
(
this
)
this
]
{
static_cast
<
nsThread
*
>
(
NS_GetCurrentThread
(
)
)
-
>
SetUseHangMonitor
(
false
)
;
mBackgroundHangMonitor
=
nullptr
;
}
)
)
;
mShutdownRequested
=
true
;
mServiceThread
-
>
Shutdown
(
)
;
mServiceThread
=
nullptr
;
}
if
(
mShmem
!
=
nullptr
&
&
(
aFromDtor
|
|
!
mShmem
-
>
IsSharedExternalShmem
(
)
)
)
{
mShmem
-
>
LeaveShMem
(
)
;
delete
mShmem
;
mShmem
=
nullptr
;
}
mSession
=
nullptr
;
}
bool
VRService
:
:
InitShmem
(
)
{
return
mShmem
-
>
JoinShMem
(
)
;
}
bool
VRService
:
:
IsInServiceThread
(
)
{
return
mServiceThread
&
&
mServiceThread
-
>
IsOnCurrentThread
(
)
;
}
void
VRService
:
:
ServiceInitialize
(
)
{
MOZ_ASSERT
(
IsInServiceThread
(
)
)
;
if
(
!
InitShmem
(
)
)
{
return
;
}
mShutdownRequested
=
false
;
PullState
(
mBrowserState
)
;
UniquePtr
<
VRSession
>
session
;
if
(
StaticPrefs
:
:
dom_vr_puppet_enabled
(
)
)
{
session
=
MakeUnique
<
PuppetSession
>
(
)
;
if
(
!
session
-
>
Initialize
(
mSystemState
mBrowserState
.
detectRuntimesOnly
)
)
{
session
=
nullptr
;
}
}
else
{
#
if
defined
(
XP_WIN
)
if
(
!
session
)
{
session
=
MakeUnique
<
OculusSession
>
(
)
;
if
(
!
session
-
>
Initialize
(
mSystemState
mBrowserState
.
detectRuntimesOnly
)
)
{
session
=
nullptr
;
}
}
#
endif
#
if
defined
(
XP_WIN
)
|
|
defined
(
XP_MACOSX
)
|
|
\
(
defined
(
XP_LINUX
)
&
&
!
defined
(
MOZ_WIDGET_ANDROID
)
)
if
(
!
session
)
{
session
=
MakeUnique
<
OpenVRSession
>
(
)
;
if
(
!
session
-
>
Initialize
(
mSystemState
mBrowserState
.
detectRuntimesOnly
)
)
{
session
=
nullptr
;
}
}
#
endif
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
if
(
!
session
)
{
session
=
MakeUnique
<
OSVRSession
>
(
)
;
if
(
!
session
-
>
Initialize
(
mSystemState
mBrowserState
.
detectRuntimesOnly
)
)
{
session
=
nullptr
;
}
}
#
endif
}
if
(
session
)
{
mSession
=
std
:
:
move
(
session
)
;
mSystemState
.
enumerationCompleted
=
true
;
PushState
(
mSystemState
)
;
mServiceThread
-
>
Dispatch
(
NewRunnableMethod
(
"
gfx
:
:
VRService
:
:
ServiceWaitForImmersive
"
this
&
VRService
:
:
ServiceWaitForImmersive
)
)
;
}
else
{
VRDisplayCapabilityFlags
capFlags
=
mSystemState
.
displayState
.
capabilityFlags
;
memset
(
&
mSystemState
0
sizeof
(
mSystemState
)
)
;
mSystemState
.
enumerationCompleted
=
true
;
if
(
mBrowserState
.
detectRuntimesOnly
)
{
mSystemState
.
displayState
.
capabilityFlags
=
capFlags
;
}
else
{
mSystemState
.
displayState
.
minRestartInterval
=
StaticPrefs
:
:
dom_vr_external_notdetected_timeout
(
)
;
}
mSystemState
.
displayState
.
shutdown
=
true
;
PushState
(
mSystemState
)
;
}
}
void
VRService
:
:
ServiceShutdown
(
)
{
MOZ_ASSERT
(
IsInServiceThread
(
)
)
;
memset
(
&
mSystemState
0
sizeof
(
mSystemState
)
)
;
mSystemState
.
enumerationCompleted
=
true
;
mSystemState
.
displayState
.
shutdown
=
true
;
if
(
mSession
&
&
mSession
-
>
ShouldQuit
(
)
)
{
mSystemState
.
displayState
.
minRestartInterval
=
StaticPrefs
:
:
dom_vr_external_quit_timeout
(
)
;
}
PushState
(
mSystemState
)
;
mSession
=
nullptr
;
}
void
VRService
:
:
ServiceWaitForImmersive
(
)
{
MOZ_ASSERT
(
IsInServiceThread
(
)
)
;
MOZ_ASSERT
(
mSession
)
;
mSession
-
>
ProcessEvents
(
mSystemState
)
;
PushState
(
mSystemState
)
;
PullState
(
mBrowserState
)
;
if
(
mSession
-
>
ShouldQuit
(
)
|
|
mShutdownRequested
)
{
mServiceThread
-
>
Dispatch
(
NewRunnableMethod
(
"
gfx
:
:
VRService
:
:
ServiceShutdown
"
this
&
VRService
:
:
ServiceShutdown
)
)
;
}
else
if
(
IsImmersiveContentActive
(
mBrowserState
)
)
{
mSession
-
>
StartPresentation
(
)
;
mSession
-
>
StartFrame
(
mSystemState
)
;
PushState
(
mSystemState
)
;
mServiceThread
-
>
Dispatch
(
NewRunnableMethod
(
"
gfx
:
:
VRService
:
:
ServiceImmersiveMode
"
this
&
VRService
:
:
ServiceImmersiveMode
)
)
;
}
else
{
mServiceThread
-
>
Dispatch
(
NewRunnableMethod
(
"
gfx
:
:
VRService
:
:
ServiceWaitForImmersive
"
this
&
VRService
:
:
ServiceWaitForImmersive
)
)
;
}
}
void
VRService
:
:
ServiceImmersiveMode
(
)
{
MOZ_ASSERT
(
IsInServiceThread
(
)
)
;
MOZ_ASSERT
(
mSession
)
;
mSession
-
>
ProcessEvents
(
mSystemState
)
;
UpdateHaptics
(
)
;
PushState
(
mSystemState
)
;
PullState
(
mBrowserState
)
;
if
(
mSession
-
>
ShouldQuit
(
)
|
|
mShutdownRequested
)
{
mServiceThread
-
>
Dispatch
(
NewRunnableMethod
(
"
gfx
:
:
VRService
:
:
ServiceShutdown
"
this
&
VRService
:
:
ServiceShutdown
)
)
;
return
;
}
if
(
!
IsImmersiveContentActive
(
mBrowserState
)
)
{
mSession
-
>
StopAllHaptics
(
)
;
mSession
-
>
StopPresentation
(
)
;
mServiceThread
-
>
Dispatch
(
NewRunnableMethod
(
"
gfx
:
:
VRService
:
:
ServiceWaitForImmersive
"
this
&
VRService
:
:
ServiceWaitForImmersive
)
)
;
return
;
}
uint64_t
newFrameId
=
FrameIDFromBrowserState
(
mBrowserState
)
;
if
(
newFrameId
!
=
mSystemState
.
displayState
.
lastSubmittedFrameId
)
{
bool
success
=
false
;
for
(
const
auto
&
layer
:
mBrowserState
.
layerState
)
{
if
(
layer
.
type
=
=
VRLayerType
:
:
LayerType_Stereo_Immersive
)
{
success
=
mSession
-
>
SubmitFrame
(
layer
.
layer_stereo_immersive
)
;
break
;
}
}
mSystemState
.
displayState
.
lastSubmittedFrameId
=
newFrameId
;
mSystemState
.
displayState
.
lastSubmittedFrameSuccessful
=
success
;
mSession
-
>
StartFrame
(
mSystemState
)
;
mSystemState
.
sensorState
.
inputFrameID
+
+
;
size_t
historyIndex
=
mSystemState
.
sensorState
.
inputFrameID
%
ArrayLength
(
mFrameStartTime
)
;
mFrameStartTime
[
historyIndex
]
=
TimeStamp
:
:
Now
(
)
;
PushState
(
mSystemState
)
;
}
mServiceThread
-
>
Dispatch
(
NewRunnableMethod
(
"
gfx
:
:
VRService
:
:
ServiceImmersiveMode
"
this
&
VRService
:
:
ServiceImmersiveMode
)
)
;
}
void
VRService
:
:
UpdateHaptics
(
)
{
MOZ_ASSERT
(
IsInServiceThread
(
)
)
;
MOZ_ASSERT
(
mSession
)
;
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
mBrowserState
.
hapticState
)
;
i
+
+
)
{
VRHapticState
&
state
=
mBrowserState
.
hapticState
[
i
]
;
VRHapticState
&
lastState
=
mLastHapticState
[
i
]
;
if
(
memcmp
(
&
state
&
lastState
sizeof
(
VRHapticState
)
)
=
=
0
)
{
continue
;
}
if
(
state
.
inputFrameID
=
=
0
)
{
mSession
-
>
StopVibrateHaptic
(
state
.
controllerIndex
)
;
}
else
{
TimeStamp
now
;
if
(
now
.
IsNull
(
)
)
{
now
=
TimeStamp
:
:
Now
(
)
;
}
size_t
historyIndex
=
state
.
inputFrameID
%
ArrayLength
(
mFrameStartTime
)
;
float
startOffset
=
(
float
)
(
now
-
mFrameStartTime
[
historyIndex
]
)
.
ToSeconds
(
)
;
mSession
-
>
VibrateHaptic
(
state
.
controllerIndex
state
.
hapticIndex
state
.
pulseIntensity
state
.
pulseDuration
+
state
.
pulseStart
-
startOffset
)
;
}
memcpy
(
&
lastState
&
state
sizeof
(
VRHapticState
)
)
;
}
}
void
VRService
:
:
PushState
(
const
mozilla
:
:
gfx
:
:
VRSystemState
&
aState
)
{
if
(
mShmem
!
=
nullptr
)
{
mShmem
-
>
PushSystemState
(
aState
)
;
}
}
void
VRService
:
:
PullState
(
mozilla
:
:
gfx
:
:
VRBrowserState
&
aState
)
{
if
(
mShmem
!
=
nullptr
)
{
mShmem
-
>
PullBrowserState
(
aState
)
;
}
}
