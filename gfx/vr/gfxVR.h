#
ifndef
GFX_VR_H
#
define
GFX_VR_H
#
include
"
nsTArray
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
namespace
mozilla
{
namespace
layers
{
class
Compositor
;
class
CompositingRenderTarget
;
}
namespace
gfx
{
enum
class
VRHMDType
:
uint16_t
{
Oculus
OSVR
NumHMDTypes
}
;
enum
class
VRStateValidFlags
:
uint16_t
{
State_None
=
0
State_Position
=
1
<
<
1
State_Orientation
=
1
<
<
2
State_All
=
(
1
<
<
3
)
-
1
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
VRStateValidFlags
)
struct
VRFieldOfView
{
VRFieldOfView
(
)
{
}
VRFieldOfView
(
double
up
double
right
double
down
double
left
)
:
upDegrees
(
up
)
rightDegrees
(
right
)
downDegrees
(
down
)
leftDegrees
(
left
)
{
}
bool
operator
=
=
(
const
VRFieldOfView
&
other
)
const
{
return
other
.
upDegrees
=
=
upDegrees
&
&
other
.
downDegrees
=
=
downDegrees
&
&
other
.
rightDegrees
=
=
rightDegrees
&
&
other
.
leftDegrees
=
=
leftDegrees
;
}
bool
operator
!
=
(
const
VRFieldOfView
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
bool
IsZero
(
)
const
{
return
upDegrees
=
=
0
.
0
|
|
rightDegrees
=
=
0
.
0
|
|
downDegrees
=
=
0
.
0
|
|
leftDegrees
=
=
0
.
0
;
}
Matrix4x4
ConstructProjectionMatrix
(
float
zNear
float
zFar
bool
rightHanded
)
;
double
upDegrees
;
double
rightDegrees
;
double
downDegrees
;
double
leftDegrees
;
}
;
struct
VRDistortionVertex
{
float
values
[
12
]
;
}
;
struct
VRDistortionMesh
{
nsTArray
<
VRDistortionVertex
>
mVertices
;
nsTArray
<
uint16_t
>
mIndices
;
}
;
struct
VRDistortionConstants
{
float
eyeToSourceScaleAndOffset
[
4
]
;
float
destinationScaleAndOffset
[
4
]
;
}
;
struct
VRDisplayInfo
{
VRHMDType
GetType
(
)
const
{
return
mType
;
}
uint32_t
GetDeviceID
(
)
const
{
return
mDeviceID
;
}
const
nsCString
&
GetDeviceName
(
)
const
{
return
mDeviceName
;
}
VRStateValidFlags
GetSupportedSensorStateBits
(
)
const
{
return
mSupportedSensorBits
;
}
const
VRFieldOfView
&
GetRecommendedEyeFOV
(
uint32_t
whichEye
)
const
{
return
mRecommendedEyeFOV
[
whichEye
]
;
}
const
VRFieldOfView
&
GetMaximumEyeFOV
(
uint32_t
whichEye
)
const
{
return
mMaximumEyeFOV
[
whichEye
]
;
}
const
IntSize
&
SuggestedEyeResolution
(
)
const
{
return
mEyeResolution
;
}
const
Point3D
&
GetEyeTranslation
(
uint32_t
whichEye
)
const
{
return
mEyeTranslation
[
whichEye
]
;
}
const
Matrix4x4
&
GetEyeProjectionMatrix
(
uint32_t
whichEye
)
const
{
return
mEyeProjectionMatrix
[
whichEye
]
;
}
const
VRFieldOfView
&
GetEyeFOV
(
uint32_t
whichEye
)
const
{
return
mEyeFOV
[
whichEye
]
;
}
enum
Eye
{
Eye_Left
Eye_Right
NumEyes
}
;
uint32_t
mDeviceID
;
VRHMDType
mType
;
nsCString
mDeviceName
;
VRStateValidFlags
mSupportedSensorBits
;
VRFieldOfView
mMaximumEyeFOV
[
VRDisplayInfo
:
:
NumEyes
]
;
VRFieldOfView
mRecommendedEyeFOV
[
VRDisplayInfo
:
:
NumEyes
]
;
VRFieldOfView
mEyeFOV
[
VRDisplayInfo
:
:
NumEyes
]
;
Point3D
mEyeTranslation
[
VRDisplayInfo
:
:
NumEyes
]
;
Matrix4x4
mEyeProjectionMatrix
[
VRDisplayInfo
:
:
NumEyes
]
;
IntSize
mEyeResolution
;
IntRect
mScreenRect
;
bool
mIsFakeScreen
;
bool
operator
=
=
(
const
VRDisplayInfo
&
other
)
const
{
return
mType
=
=
other
.
mType
&
&
mDeviceID
=
=
other
.
mDeviceID
&
&
mDeviceName
=
=
other
.
mDeviceName
&
&
mSupportedSensorBits
=
=
other
.
mSupportedSensorBits
&
&
mEyeResolution
=
=
other
.
mEyeResolution
&
&
mScreenRect
=
=
other
.
mScreenRect
&
&
mIsFakeScreen
=
=
other
.
mIsFakeScreen
&
&
mMaximumEyeFOV
[
0
]
=
=
other
.
mMaximumEyeFOV
[
0
]
&
&
mMaximumEyeFOV
[
1
]
=
=
other
.
mMaximumEyeFOV
[
1
]
&
&
mRecommendedEyeFOV
[
0
]
=
=
other
.
mRecommendedEyeFOV
[
0
]
&
&
mRecommendedEyeFOV
[
1
]
=
=
other
.
mRecommendedEyeFOV
[
1
]
&
&
mEyeFOV
[
0
]
=
=
other
.
mEyeFOV
[
0
]
&
&
mEyeFOV
[
1
]
=
=
other
.
mEyeFOV
[
1
]
&
&
mEyeTranslation
[
0
]
=
=
other
.
mEyeTranslation
[
0
]
&
&
mEyeTranslation
[
1
]
=
=
other
.
mEyeTranslation
[
1
]
&
&
mEyeProjectionMatrix
[
0
]
=
=
other
.
mEyeProjectionMatrix
[
0
]
&
&
mEyeProjectionMatrix
[
1
]
=
=
other
.
mEyeProjectionMatrix
[
1
]
;
}
bool
operator
!
=
(
const
VRDisplayInfo
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
}
;
struct
VRHMDSensorState
{
double
timestamp
;
int32_t
inputFrameID
;
VRStateValidFlags
flags
;
float
orientation
[
4
]
;
float
position
[
3
]
;
float
angularVelocity
[
3
]
;
float
angularAcceleration
[
3
]
;
float
linearVelocity
[
3
]
;
float
linearAcceleration
[
3
]
;
void
Clear
(
)
{
memset
(
this
0
sizeof
(
VRHMDSensorState
)
)
;
}
}
;
struct
VRSensorUpdate
{
VRSensorUpdate
(
)
{
}
;
VRSensorUpdate
(
uint32_t
aDeviceID
const
VRHMDSensorState
&
aSensorState
)
:
mDeviceID
(
aDeviceID
)
mSensorState
(
aSensorState
)
{
}
;
uint32_t
mDeviceID
;
VRHMDSensorState
mSensorState
;
}
;
struct
VRDisplayUpdate
{
VRDisplayUpdate
(
)
{
}
;
VRDisplayUpdate
(
const
VRDisplayInfo
&
aDeviceInfo
const
VRHMDSensorState
&
aSensorState
)
:
mDeviceInfo
(
aDeviceInfo
)
mSensorState
(
aSensorState
)
{
}
;
VRDisplayInfo
mDeviceInfo
;
VRHMDSensorState
mSensorState
;
}
;
struct
VRHMDConfiguration
{
VRHMDConfiguration
(
)
:
hmdType
(
VRHMDType
:
:
NumHMDTypes
)
{
}
bool
operator
=
=
(
const
VRHMDConfiguration
&
other
)
const
{
return
hmdType
=
=
other
.
hmdType
&
&
value
=
=
other
.
value
&
&
fov
[
0
]
=
=
other
.
fov
[
0
]
&
&
fov
[
1
]
=
=
other
.
fov
[
1
]
;
}
bool
operator
!
=
(
const
VRHMDConfiguration
&
other
)
const
{
return
hmdType
!
=
other
.
hmdType
|
|
value
!
=
other
.
value
|
|
fov
[
0
]
!
=
other
.
fov
[
0
]
|
|
fov
[
1
]
!
=
other
.
fov
[
1
]
;
}
bool
IsValid
(
)
const
{
return
hmdType
!
=
VRHMDType
:
:
NumHMDTypes
;
}
VRHMDType
hmdType
;
uint32_t
value
;
VRFieldOfView
fov
[
2
]
;
}
;
class
VRHMDRenderingSupport
{
public
:
struct
RenderTargetSet
{
RenderTargetSet
(
)
;
NS_INLINE_DECL_REFCOUNTING
(
RenderTargetSet
)
RefPtr
<
layers
:
:
Compositor
>
compositor
;
IntSize
size
;
nsTArray
<
RefPtr
<
layers
:
:
CompositingRenderTarget
>
>
renderTargets
;
virtual
already_AddRefed
<
layers
:
:
CompositingRenderTarget
>
GetNextRenderTarget
(
)
=
0
;
protected
:
virtual
~
RenderTargetSet
(
)
;
}
;
virtual
already_AddRefed
<
RenderTargetSet
>
CreateRenderTargetSet
(
layers
:
:
Compositor
*
aCompositor
const
IntSize
&
aSize
)
=
0
;
virtual
void
DestroyRenderTargetSet
(
RenderTargetSet
*
aRTSet
)
=
0
;
virtual
void
SubmitFrame
(
RenderTargetSet
*
aRTSet
int32_t
aInputFrameID
)
=
0
;
protected
:
VRHMDRenderingSupport
(
)
{
}
}
;
class
VRHMDInfo
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
VRHMDInfo
)
const
VRHMDConfiguration
&
GetConfiguration
(
)
const
{
return
mConfiguration
;
}
const
VRDisplayInfo
&
GetDeviceInfo
(
)
const
{
return
mDeviceInfo
;
}
virtual
bool
SetFOV
(
const
VRFieldOfView
&
aFOVLeft
const
VRFieldOfView
&
aFOVRight
double
zNear
double
zFar
)
=
0
;
virtual
bool
KeepSensorTracking
(
)
=
0
;
virtual
void
NotifyVsync
(
const
TimeStamp
&
aVsyncTimestamp
)
=
0
;
virtual
VRHMDSensorState
GetSensorState
(
)
=
0
;
virtual
VRHMDSensorState
GetImmediateSensorState
(
)
=
0
;
virtual
void
ZeroSensor
(
)
=
0
;
virtual
VRHMDRenderingSupport
*
GetRenderingSupport
(
)
{
return
nullptr
;
}
virtual
void
FillDistortionConstants
(
uint32_t
whichEye
const
IntSize
&
textureSize
const
IntRect
&
eyeViewport
const
Size
&
destViewport
const
Rect
&
destRect
VRDistortionConstants
&
values
)
=
0
;
const
VRDistortionMesh
&
GetDistortionMesh
(
uint32_t
whichEye
)
const
{
return
mDistortionMesh
[
whichEye
]
;
}
protected
:
explicit
VRHMDInfo
(
VRHMDType
aType
)
;
virtual
~
VRHMDInfo
(
)
;
VRHMDConfiguration
mConfiguration
;
VRDisplayInfo
mDeviceInfo
;
VRDistortionMesh
mDistortionMesh
[
VRDisplayInfo
:
:
NumEyes
]
;
}
;
class
VRHMDManager
{
public
:
static
uint32_t
AllocateDeviceID
(
)
;
protected
:
static
Atomic
<
uint32_t
>
sDeviceBase
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
VRHMDManager
)
virtual
bool
Init
(
)
=
0
;
virtual
void
Destroy
(
)
=
0
;
virtual
void
GetHMDs
(
nsTArray
<
RefPtr
<
VRHMDInfo
>
>
&
aHMDResult
)
=
0
;
protected
:
VRHMDManager
(
)
{
}
virtual
~
VRHMDManager
(
)
{
}
}
;
}
}
#
endif
